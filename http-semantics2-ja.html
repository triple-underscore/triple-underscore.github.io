<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Semantics （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>
<script>
source_data.init = function(){
	this.ref_base = '~HTTPinfra';
}

</script>
<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP Semantics
trans_update:2024-11-24
page_state_key:HTTP
original_url:https://httpwg.org/specs/rfc9110.html
abbr_url:HTTPsem
spec_status:IETFSTD
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●mdn_urls

CONNECT:HTTP/Methods/CONNECT
DELETE:HTTP/Methods/DELETE
GET:HTTP/Methods/GET
HEAD:HTTP/Methods/HEAD
OPTIONS:HTTP/Methods/OPTIONS
POST:HTTP/Methods/POST
PUT:HTTP/Methods/PUT
TRACE:HTTP/Methods/TRACE

field.accept-charset:HTTP/Headers/Accept-Charset
field.accept-encoding:HTTP/Headers/Accept-Encoding
field.accept-language:HTTP/Headers/Accept-Language
field.accept-ranges:HTTP/Headers/Accept-Ranges
field.accept:HTTP/Headers/Accept
field.allow:HTTP/Headers/Allow
	field.authentication-info:HTTP/Headers/Authentication-Info
field.authorization:HTTP/Headers/Authorization
field.connection:HTTP/Headers/Connection
field.content-encoding:HTTP/Headers/Content-Encoding
field.content-language:HTTP/Headers/Content-Language
field.content-length:HTTP/Headers/Content-Length
field.content-location:HTTP/Headers/Content-Location
field.content-range:HTTP/Headers/Content-Range
field.content-type:HTTP/Headers/Content-Type
field.etag:HTTP/Headers/ETag
field.expect:HTTP/Headers/Expect
field.from:HTTP/Headers/From
field.host:HTTP/Headers/Host
field.if-match:HTTP/Headers/If-Match
field.if-modified-since:HTTP/Headers/If-Modified-Since
field.if-none-match:HTTP/Headers/If-None-Match
field.if-range:HTTP/Headers/If-Range
field.if-unmodified-since:HTTP/Headers/If-Unmodified-Since
field.last-modified:HTTP/Headers/Last-Modified
field.location:HTTP/Headers/Location
	field.max-forwards:HTTP/Headers/Max-Forwards
field.proxy-authenticate:HTTP/Headers/Proxy-Authenticate
	field.proxy-authentication-info:HTTP/Headers/Proxy-Authentication-Info
field.proxy-authorization:HTTP/Headers/Proxy-Authorization
field.range:HTTP/Headers/Range
field.referer:HTTP/Headers/Referer
field.retry-after:HTTP/Headers/Retry-After
field.server:HTTP/Headers/Server
field.te:HTTP/Headers/TE
field.upgrade:HTTP/Headers/Upgrade
field.user-agent:HTTP/Headers/User-Agent
field.vary:HTTP/Headers/Vary
field.via:HTTP/Headers/Via
field.www-authenticate:HTTP/Headers/WWW-Authenticate

status.codes:HTTP/Status
status.100:HTTP/Status/100
status.101:HTTP/Status/101
status.200:HTTP/Status/200
status.201:HTTP/Status/201
status.202:HTTP/Status/202
status.203:HTTP/Status/203
status.204:HTTP/Status/204
status.205:HTTP/Status/205
status.206:HTTP/Status/206
status.300:HTTP/Status/300
status.301:HTTP/Status/301
status.302:HTTP/Status/302
status.303:HTTP/Status/303
status.304:HTTP/Status/304
status.305:HTTP/Status/305
status.306:HTTP/Status/306
status.307:HTTP/Status/307
status.308:HTTP/Status/308
status.400:HTTP/Status/400
status.401:HTTP/Status/401
status.402:HTTP/Status/402
status.403:HTTP/Status/403
status.404:HTTP/Status/404
status.405:HTTP/Status/405
status.406:HTTP/Status/406
status.407:HTTP/Status/407
status.408:HTTP/Status/408
status.409:HTTP/Status/409
status.410:HTTP/Status/410
status.411:HTTP/Status/411
status.412:HTTP/Status/412
status.413:HTTP/Status/413
status.414:HTTP/Status/414
status.415:HTTP/Status/415
status.416:HTTP/Status/416
status.417:HTTP/Status/417
status.418:HTTP/Status/418
status.422:HTTP/Status/422
status.426:HTTP/Status/426
status.500:HTTP/Status/500
status.501:HTTP/Status/501
status.502:HTTP/Status/502
status.503:HTTP/Status/503
status.504:HTTP/Status/504
status.505:HTTP/Status/505


●●link_map
h.Received:~RFCx/rfc5322#section-3.6.7
h.Accept-Patch:~HTTPpatch#accept-patch
		RFC5789/3.1:~HTTPpatch#section-3.1
h.Keep-Alive:~HTTPv1#compatibility.with.http.1.0.persistent.connections
h.Proxy-Connection:~HTTPv1#compatibility.with.http.1.0.persistent.connections

h.If:~RFCx/rfc4918#section-10.4
	h.Digest:
h.Origin:~FETCH#http-origin
	h.Origin:~RFCx/rfc6454#section-4

p.Accept-Charset:~HTTPsem#p.Accept-Charset
p.Accept-Encoding:~HTTPsem#p.Accept-Encoding
p.Accept-Language:~HTTPsem#p.Accept-Language
p.Accept-Ranges:~HTTPsem#p.Accept-Ranges
p.Accept:~HTTPsem#p.Accept
p.Allow:~HTTPsem#p.Allow
p.Authentication-Info:~HTTPsem#p.Authentication-Info
p.Authorization:~HTTPsem#p.Authorization
p.Connection:~HTTPsem#p.Connection
p.Content-Encoding:~HTTPsem#p.Content-Encoding
p.Content-Language:~HTTPsem#p.Content-Language
p.Content-Length:~HTTPsem#p.Content-Length
p.Content-Location:~HTTPsem#p.Content-Location
p.Content-Range:~HTTPsem#p.Content-Range
p.Content-Type:~HTTPsem#p.Content-Type
p.ETag:~HTTPsem#p.ETag
p.Expect:~HTTPsem#p.Expect
p.From:~HTTPsem#p.From
p.Host:~HTTPsem#p.Host
p.If-Match:~HTTPsem#p.If-Match
p.If-Modified-Since:~HTTPsem#p.If-Modified-Since
p.If-None-Match:~HTTPsem#p.If-None-Match
p.If-Range:~HTTPsem#p.If-Range
p.If-Unmodified-Since:~HTTPsem#p.If-Unmodified-Since
p.Last-Modified:~HTTPsem#p.Last-Modified
p.Location:~HTTPsem#p.Location
p.Max-Forwards:~HTTPsem#p.Max-Forwards
p.Proxy-Authenticate:~HTTPsem#p.Proxy-Authenticate
p.Proxy-Authentication-Info:~HTTPsem#p.Proxy-Authentication-Info
p.Proxy-Authorization:~HTTPsem#p.Proxy-Authorization
p.Range:~HTTPsem#p.Range
p.Referer:~HTTPsem#p.Referer
p.Retry-After:~HTTPsem#p.Retry-After
p.Server:~HTTPsem#p.Server
p.TE:~HTTPsem#p.TE
p.Upgrade:~HTTPsem#p.Upgrade
p.User-Agent:~HTTPsem#p.User-Agent
p.Vary:~HTTPsem#p.Vary
p.Via:~HTTPsem#p.Via
p.WWW-Authenticate:~HTTPsem#p.WWW-Authenticate


c.bytes:~HTTPsem#_bytes
c.q:~HTTPsem#c.q
c.trailers:~HTTPsem#_trailers-token
c.message/http:~HTTPv1#media.type.message.http
c.none:~HTTPsem#range-none
c.application/octet-stream:~RFCx/rfc2046#section-4.5.1

sdir.immutable:~RFC8246#cache-response-directive.immutable
sdir.no-transform:~HTTPcache#cache-response-directive.no-transform

		:#rule.token.separators
		:#rule.quoted-pair
		:#rule.parameter
		:#rule.ranges-specifier
		:#rule.ranges-specifier.suffix

		p.range-unit:#range.units
		p.first-pos:#rule.int-range
		p.int-range:#rule.int-range
		p.last-pos:#rule.int-range
		p.other-range:#rule.other-range
		p.range-set:#rule.ranges-specifier
		p.range-spec:#rule.ranges-specifier
		p.ranges-specifier:#rule.ranges-specifier
		p.suffix-length:#rule.suffix-range
		p.suffix-range:#rule.suffix-range


役割:~HTTPinfra#role
絶対~形:~HTTPinfra#p.absolute-URI
~scheme:~HTTPinfra#p.scheme
~host:~HTTPinfra#p.host
~port:~HTTPinfra#p.port
生成元:~HTTPinfra#uri-origin

複-部位t:#multipart
接続~option:#connection-option
既定の重み:#defult-weight
形式変換ng~proxy:#transforming-proxy
最終-受信者:#final-recipient
強い:#strong-validator
弱い:#weak-validator
不透明:#opaque
評価-:#evaluation

満足可能:#satisfiable
1.満足可能:#satisfiable1

首な資源:#primary-resource
選定用~header:#selecting-header
	実効~要請~URI:#effective.request.uri
権限的な応答:~HTTPinfra#authoritative

base64:~4648#section-4
base64url:~4648#section-5
base32:~4648#section-7
base16:~4648#section-8
~lock:~RFCx/rfc4918#section-6

既定では，経験的に~cache可能である:#heuristically-cacheable-by-default

新鮮:~HTTPcache#fresh
	再検証:~HTTPcache#revalidating
無効化-:~HTTPcache#invalidate
	無効化-:~HTTPcache#invalidation
~cache鮮度:~HTTPcache#expiration.model

要請~密入~攻撃:~HTTPv1#request.smuggling
応答~分割~攻撃:~HTTPv1#response.splitting

cite.内容~符号法~registry:~IANA-a/http-parameters
cite.~HTTP範囲~単位~registry:~IANA-a/http-parameters
cite.~HTTP状態s~code~registry:~IANA-a/http-status-codes
cite.~HTTP認証~scheme~registry:~IANA-a/http-authschemes


	●§

4.3.2:~HTTPinfra#http.origin
4.3.3:~HTTPinfra#https.origin
7.4:#routing.reject
8.1:#representation.data
8.3.2:#charset
8.8:#response.validator
8.8.2.2:#lastmod.comparison
11.3:#challenge.and.response
12.1:#proactive.negotiation
12.4.2:~HTTPsem#quality.values
事前条件の評価:#evaluation
	13.2:#evaluation
13.3:#precedence
14.5:#partial.PUT

2.5:~HTTPinfra#protocol.version
3.7:~HTTPinfra#intermediaries
4:~HTTPinfra#uri
5.6.1:~HTTPinfra#abnf.extension
6.5:~HTTPinfra#trailer.fields

16.1:~HTTPinfra#method.extensibility
16.2:~HTTPinfra#status.code.extensibility
16.3.1:~HTTPinfra#fields.registry
16.5:~HTTPinfra#range.unit.extensibility
16.5.1:~HTTPinfra#range.unit.registry
16.6:~HTTPinfra#content.coding.extensibility
16.7:~HTTPinfra#upgrade.token.registry
17:~HTTPinfra#security.considerations
17.3:~HTTPinfra#attack.pathname
17.5:~HTTPinfra#attack.protocol.element.length
17.9:~HTTPinfra#sensitive.information.in.uris
17.13:~HTTPinfra#fingerprinting
17.15:~HTTPinfra#overlapping.ranges
17.16.1:~HTTPinfra#confidentiality.of.credentials
著作者の~address:~HTTPinfra#rfc.authors

uri.2.3:~RFCx/rfc3986#section-2.3
uri.3.5:~RFCx/rfc3986#section-3.5
uri.5:~RFCx/rfc3986#section-5
uri.1.2.2:~RFCx/rfc3986#section-1.2.2
uri.4.2:~RFCx/rfc3986#section-4.2

●●words_table1
RFC7231:RFC7231-ja.html

●●words_table

	●network／環境
UNIX:
IP:
HTTP-to-HTTP:
HTTP2:HTTP/2
HTTP3:HTTP/3
横取n:interception::横取り
横取り:intercept::~
interception:
負荷分散:load balancing::~
	~frame法:framing
	~frame化:framing
trace::::トレース
portal::::ポータル
応答待ち:outstanding::~
帯域:band::~
通過中:transit 中:~
媒介:intermediate::~

	●構文
US-ASCII:
縮約-:collapse:~
小数点:decimal point:~
数字列:numerals:~
英字:letter:~
改行:line break:~
wildcard::::ワイルドカード
	片:fragment
構成-:compose:~
	構成し直-:recompose
固定的:fixed:~
	前後:-
alphabet::::アルファベット
切落す:truncateする:切り落とす
切落して:truncateして:切り落として
省かれ:elideされ:~

	●範囲
下位範囲:subrange::~
区分-:partition:~
満足可能:satisfiable:~
	満足可能でない:unsatisfiable

	~~尾部:suffix
	先頭:beginning
	列:sequence
	~address可能:addressable
	完全~化:completing

	●保安
CSRF:
malware::::マルウェア
密入:smuggling::~
非公開:non-public:~
本物の:realな:~
迂回-:bypass:~
spam::::スパム
製品:product::~
下位製品:subproduct::~
不用意:accidental:~
受動的:passive:~
各個人:individual:~
特権拡大:privilege escalation:~
証明書:certificate::~
分割:splitting:~

	晒し:expose
	~secure化:secured
	~secure化されてない:unsecured
	誤って~directされた:misdirected

	●仕様
critical:
scale::::スケール
	~scale能:scalability
主張-:claim:~
確立:establishment::~
無視r:disregard:無視することに
不整合:inconsistency:~
放棄-:abandon:~
拒否-:refuse:~
奇妙:bizarre:~
引換関係:trade-off:引き換え関係
想定-:suppose:~
指示書き:instruction:~
機能:function:~
仮の:hypotheticalな:~
招いて:inviteして:~
衝突:collision:~
衝突-:collide:~
誂えら:tailorさ:あつらえら
誂える:tailorする:あつらえる
無用:useless:~
心配:fear:~
負担:burden:~
無差別:indiscriminate:~
請求-:demand:~
放置:inactivity:~
協力的:cooperative:~
短絡-:short-circuit:~
理解度:intelligibility:~
直交的:orthogonal:独立
価値:value:~
浪費-:waste:~
アタリマエ:ubiquitous::あたりまえ
改訂履歴:revision::~
不作為:inadvertent:~
木目細かな:fine-grainedな:~
最大化する:maximizeする:最大限に得る
正当化-:justify:~
楽観的:optimistic:~
厳格:stringent:~
排する:eliminateする:~
周知:well-known:~
理想的:ideal:~
等価性:equivalency:~
裁量:discretion:~
助言-:advise:~
助言:advice:~
	通告
過度:excessive:~
管轄:administrative domain:~
変種:variant:~
満足可能:satisfiable:~
信頼性:reliability:~
介入-:intervene:~
綴り:spell:~
拡げる:expandする:~
演繹-:deduce:~
	演繹-法:method
複雑化-:complicate:~
取決め:agreement:取り決め
不都合:inconvenience:~
	不都合がある:is inconvenient
原理:principle:~
対象範囲:extent:~
順応的:adaptive:~
非効率:inefficient:~
制定-:prescribe:~
取戻され:reclaimされ:取り戻され
分類上の:categorization:~
損なう:loseする:~
根本的:fundamental:~
壊れた:broken:~
縛られ:tieされ:~
包括的:comprehensive:~
進捗状況:progress:~
強要-:insist:~
連絡:contact:~
移行-:transition::~
収束-:converge:~
合意:agreement:~
	ついて合意が得られなかった:disagreement over
診断用の:diagnostic:~
選好度:relative preference:~
収まる:fitする:~
能動的:active::~::アクティブ
joke::::ジョーク
流儀:fashion:~
注力-:focus:~
望み:wish:~
利用度:usage:~

	IESG
	実効:effective
	~~見かけ上:apparently
	~~精確に~~述べる:delineate
	~~手間を要する:suffers from the
	~~勧める:advised to
	〜とも呼ばれる:a.k.a
	すなわち:a.k.a
	よって:hence
	~~基準に:with respect to
	かまわない:free
	助け:help
	問わず:regardless／
	~~可能性がある:potential
	~~可能性もある:potentially
	かねない:potentially
	〜としても:potential
	なり得る:potential
	おそれがある:potential as
	とても:very
	は別として／の他に／以外:aside from
	優先:take precedence over
	視る:view
	今や:now
	好ましい:preferable
	用意はない:unwilling
	用意があった:willing to
	また，:In turn
	~~責務者:person responsible for
	各:respective
	予め見做される:presume
	再利用-能:reusability

	相互運用するため:for the sake of interoperating
	整合性:consistent with
	~~働く:act
	通例的でない:unusual
	~~価する:worthwhile
	~~馴染んで:familiar with
	挙げられ:mention
	~~無為に:circumvents
	必要とされてはいないが:, but not necessarily
	~~関知:held accountable for
	くだけて言えば:Informally／:Verbally
	-:pertaining
	適宜:as appropriate
	~~長年にわたり:for a long time
	予約-済みでない:unreserved
	反して:against
	害を及ぼす:causing harm
	~~考えられがち:tempting to think of
	受け入れられ易い:amenable
	~~強いるものではない:not prevent
	~~望ましくない:unfortunate
	~~落と:markdown
	反し／反する:contrary
	大きく:highly
	It knows that:わかっている
	~~特徴がある:distinguished
	他にもある:(among others)
	解さなければならない:must-understand
	に関して指令する:has some direction regarding
	はるかに:far more
	無分別:foolish
	込み入った:elaborate
	〜から:by virtue of
	多少を問わず:more or less than
	言って:say
	滅多にない:seldom
	ほぼ:nearly
	よく似る:very similar
	前項に代えて:Alternatively
	きちんと:well-
	~~不必要に:Overly
	~~不必要に:needlessly
	~~悪影響:adverse impact
	~~委ね:left to
	陥った:descended into
	もちろん:obvious
	あろうとし続ける:tries to remain
	たとえ:albeit
	~~誤った:erroneous
	~~間違い:wrong
	~~記述するもの:descriptive
	~~正しくない:malformed
	どっちつかず:noncommittal
	~~誤認を誘うもの:deceptive
	~~注意して行う:done with care
	鶏と卵:chicken-and-egg
	事実がなかった:were not for the fact
	~~理由:because
	~~同類の:sibling
	~~効率が劣る:less efficiently
	から見て:perspective
	もの:flavor
	対象に:over
	課す:impose
	~~最大の:best
	あまり〜でない:far less
	~~支配的:prevailing
	視野を絞る:identify the scope
	代わるもの:replacement
	依存-:dependent
	運用~上の:operational
	拘束されない:unconstrained
	してもらう:encourage
	特に関心を引くもの:of particular interest
	類する:analogous な
	“同じさの質”: “sameness” ~quality
	同じさ度合い:sameness
	ならない見込みが高い:unlikely
	ならないと見込まれる:unlikely
	いずれにせよ、:Regardless,
	全面的:entirely
	大多数:overwhelming majority
	環境設定し直す:reconfigure
	安全か否か:between safe and unsafe
	に宛てて:target
	~~大体~同じ:around the same
	組で:together
	分かれる:split
	査定:assessment of
	及ぶ:extend
	細かな:minor
	好ましい:preferable
	捉える:think of
	~~総称される:collectively referred to as
	称される:referred to as
	~~固有:unique
	~riskが高い:riskier
	本質的でない:nonessential
	発揮する:creating
	逆に:conversely
	足るまで:sufficiently
	誰からも:anyone
	どの情報も:anything
	自覚しない:unaware
	従い続ける:follow through
	の方が適する:better suited
	予め除外する:preclude
	適合するか否か:conformance (or lack thereof)
	許容しないように:disallow
	~~確信がある:sufficient confidence
	~~同類の:sibling

	●事例
分析:analysis:~
解析:analytics:~
医療:medical:~
科学的:scientific:~
画像処理:imaging:~
投函-:post:~
目録:catalog::~::カタログ
ニュースグループ:newsgroup:::~
メーリングリスト:mailing list:::~
ブログ:blog:::~
課金:charge:~
記事:article:~
広告料:advertising account:~
	広告-用:advertising
掲示板:bulletin board:~
英国:British:~
言語上の:linguistic:~
	inline:in-line
仮装-:masquerade:~
誤入力:mistype:~
SMTP:
Canada::カナダ
Danish::デンマーク語
Maori::マオリ語
入門書:primer:~
初学者:beginner:~
紙:paper:~
購入:purchase:~
領収書:receipt document:~
加工-:craft:~
	臨時の販促:limited-time, promotional
満杯:full:~
編集-:edit:~
編集:editing:~
	~link編集:link-editing
notepad::::ノートパッド
一括的:batch-oriented:~
会話-:communicate:~
企業:corporate:~
	英語の一方言:variety of English
	ワイタンギ条約:Treaty of Waitangi
	気象情報:weather report
	天気:weather
	CERN:

	●未分類
透過的:transparent::~
逐語的:verbatim:~
routine::::ルーチン
pipe::::パイプ
digital::::デジタル
完全修飾:fully qualified::~
参照先の:referenced:~
参照r:refer:参照
変名:variation:~
後続-:follow:~
仮想:virtual::~
総計:total:~
増分的:incremental:~
増分:increment:~
	増やす:increase
peer::::ピア
保つ:keepする:~
sniff:
	~sniff法:sniffing
分散-:distribute:~
排他的:mutually exclusive:~
符号化形:coded form::~::コード化形
自動解凍-:automatic に decompress:~
視聴者:audience:~
話者:-literate audience:~
遅い:slowな:~
選好順:descending preference の order:選好度の高い順
再検証:revalidation::~
差控える:forgoする:差し控える
不変:unchanged:~
後側の:later:~
backup::::バックアップ
非作動化-:deactivate::~::非アクティブ化
loop-back::::ループバック
読専:read-only:読み取り専用
上書-:overwrite::上書き
閉な:closed:閉じた
可分:nonatomic:~

semaphore::::セマフォ
拡がり:expansion:~
	:refer
間隙:gap:~
和集合:union:~
連続的:continuous:~
完結:finalization:~
分解能:resolution:~
整形式:well-formed:~
枯渇-:exhaust:~
	枯渇-:exhaustion of
循環的:cyclical:~
耐衝突:collision-resistant:~
	最後に改変された:last-modified
real-time:::リアルタイム
変動-:vary::~
変動:variance::~
発行-:issue:~
遊休中:idle:~
制限時間:timeout::~
書込んで:writeして::書き込んで
書込まれ:writeされ::書き込まれ
係数:factor:~
監視器:monitor::~::モニタ
符号変換器:transcoder::~::トランスコーダ
冪等性:idempotent property::~
外向けの:outgoing:~
選定用:selecting::~
refresh:
模倣-:emulate:~
時間枠:window::~
復旧-:restore:~

	~~獲得-:gain
	^en:deep linking
	~~実行済みで:enact されて
	~~最新な:up-to-date な
	入って来る:incoming
	始める:begin
	その場で:on the fly
	~~遡る:follow 〜 back to
	型~付け:typing
	失われ:lost
	失われ:lose
	32-bit
	CRC
	LZ77
	Huffman
	zlib
	渡-:pass
	最下~層のものから昇順に:layer-ascending order
	？:conclude
	不在:absence
	秒:seconds
	秒単位:every second／single second／one-second
	秒単位より細かい:sub-second
	定まる秒~数の間:during the second covered by
	取り去っ:left out
	相互に:mutually
	開始し直す:restart

	●言い換え
	〜な時間内に:within 〜 period of time
	期間:period of time
	範囲に含まれ:inclusive／inclusive numbered parts
	結合し直:recombine
	~~完全に:quite
	利用者に知覚される:user-perceived
	~~増やす:degrade
	現れる:appear
	再掲-:restate
	~~連続する一連の:ordered subsequence
	最短:minimum
	等しく:equally
	直近:immediate
	ごく小さな割合:small percentage
	埋め~~始め:starts filling
	~~過去に戻る:back in time
	~~過去の:earlier
	~~過去:before
	~~巨大:huge:巨大
	築く:building
	群:group of
	一部分だけ:only a subset
	ある 1 ~page:a single page
	ある~~断片:dimensions
	要請-中にある:being requested
	-:speaking
	から来た:came from
	-:highlighted by
	~~元に戻す:undo
	戻れる~link:back-links
	返送:back
	必要十分に〜ない:poorly
	先頭部分:prefix
	単独の部位t:single-part
	継続-中:continuing
	~linkし直す:re-link
	提出し直-:resubmit
	計算し直-:recalculate
	~~遠い:distant
	~~相対的:against
	検証-用:validating
	一時的に可用でない:temporary unavailability
	-可能:possible
	〜を成す部分:partly
	ものもある:partly
	serves as 〜 form:形をとる
	〜の場合でも:including 〜
	~robot的:robotic
	入らない:outside
	区切るため:for delimitation
	内容の中途:mid-content
	構文として:syntactically
	に向けられ:directed at
	~log~file:logfile
	〜などにより:or
	複-部位t:multipart
	0 〜 1 個の:potential
	0 個以上の:potential
	0 個以上の:optional
	末尾に:followed by

	●他の語
	一種／:variation
	次に挙げるものなど:including (but not limited to)
	1 個の:exactly one
	初回:first time
	次回の:second
	次回の:next
	次に:next
	多種多様:wide variety of
	~~位置:offset
	位置:position
	位置／番:offset
	~~事前:before actually doing so
	〜用の~codeが〜直書きされ:hard-coded
	もたらす／:cause
	一連の:sequence
	圧縮-済み:compressed
	~~一過性の:transitory
	~~正常に~~処理されました。:It worked!
	~~伝える:tell
	~~直前:-
	~~直前:just prior to
	~~部品:part
	各部:parts
	保存…:…Save as ...
	短い:short
	ほぼ:mostly
	最終的:ultimately
	各自の:own
	指す:point to
	~escapeを外そ:unescaping
	-:located
	通過-:passed through
	~~部署:office and regional
	~~風刺-:lampoon
	~hypertext:hypertext note
	~~細切れにされた:small disjoint
	~~細切れ:small
	~~若い:younger
	〜分間:minutes
	日に一度だけ:once per day
	適量:appropriate amount
	代えて／代えられ:supplant
	~~確定していない:might or might not
	するとき／しないとき:might or might not
	~~消失した:gone
	旧い:old
	旧い:older

	他方の:one of the two
	離れて他へ:away from
	いつまでも:arbitrarily long periods
	いつまでも:any length of time
	いつまで:how long
	いつまでか:how long
	ときには:occasional
	その時々:on occasion
	~~直前:just before
	直後:immediately after
	小さな:small
	より大き:larger
	だけ:alone
	当時の:then-current
	最終的に:eventually


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP Semantics</a>
の
§ 7 〜 § 15
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP 意味論（ § 7 〜 § 15 ）</h1>
<p>RFC 9110 — HTTP Semantics</p>
	</hgroup>
</header>

<div id="MAIN" hidden>

<p class="trans-note">【
この~pageでは、
~HTTP意味論を成す内容のうち，
§ 7 〜 § 15 を述べる。
仕様の~metadata情報は、
`~HTTP意味論（共通基盤）＠~HTTPinfra$
を参照されたし。
】</p>

<main id="MAIN0">
	<section id="routing">
<h2 title="Routing HTTP Messages">7. ~HTTP~messageの~route法</h2>

<p>
~HTTP要請~messageの~route法は、
各`~client$により，次に基づいて決定される
⇒＃
`~target資源$,
~clientの~proxy環境設定,
`内方$への接続の確立／再利用
◎
HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection.＼
</p>

<p>
対応する応答の~route法は、
同じ接続`連鎖$を，~clientまで~~遡る。
◎
The corresponding response routing follows the same connection chain back to the client.
</p>

		<section id="target.resource">
<h3 title="Determining the Target Resource">7.1. ~target資源の決定-法</h3>

<p>
~HTTPは，多種多様な応用で利用されるが、
ほとんどの`~client$は，一般用~Web~browserと同じ［
`資源$【`~target資源$】を識別するための仕組み, 環境設定~技法
］に依拠する。
それらを組合せた効果は
— 通信~option用の~codeが~clientの環境設定~内に直書きされていようが —
`~URI参照$と捉えることができる。
◎
Although HTTP is used in a wide variety of applications, most clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers. Even when communication options are hard-coded in a client's configuration, we can think of their combined effect as a URI reference (Section 4.1).
</p>

<p>
`~URI参照$は、
`~target~URI@
（ `target URI^en ）
を得するために`絶対~形$に解決される。
~URI参照~内の素片（ `fragment$p ）成分は、
在っても，~target~URIからは除外される
— 素片~識別子は、
`~client$側の処理~用に予約-済みなので（ `URI$r `3.5§uri ）。
◎
A URI reference is resolved to its absolute form in order to obtain the "target URI". The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing ([URI], Section 3.5).
</p>

<p>
`~client$は、
`~target資源@
（ `target resource^en ）に対し動作を遂行するため，
送信する要請~message内に［
【！its parsed】`~target~URI$を成す各~成分
］のうち［
`受信者$が，当の`~target資源$【！that same resource】を識別すること
］を［
可能化するために十分な成分たち
］を包含する。
そのような［
一連の~URI成分からなるもの
］は、
`要請~target@
（ `request target^en ）と~~総称される。
歴史的な理由から、
`要請~target$は，~messageの［
`制御~data$／
`Host$h ~header
］の中に送信される。
◎
To perform an action on a "target resource", the client sends a request message containing enough components of its parsed target URI to enable recipients to identify that same resource. For historical reasons, the parsed target URI components, collectively referred to as the "request target", are sent within the message control data and the Host header field (Section 7.2).
</p>

<p>
`要請~target$を成す成分たちが~methodに特有な形をとるような，通例的でない事例が 2 つある：
◎
There are two unusual cases for which the request target components are in a method-specific form:
</p>
<ul>
	<li>
`CONNECT$m 用には
⇒
`要請~target$は、
`~tunnel$の行先を与える，~colonで分離された［
~host名と~port番号
］になる。
◎
For CONNECT (Section 9.3.6), the request target is the host name and port number of the tunnel destination, separated by a colon.
</li>
	<li>
`OPTIONS$m 用には
⇒
`要請~target$は、
1 個の~asterisk（ "`*^c" ）にもなり得る。
◎
For OPTIONS (Section 9.3.7), the request target can be a single asterisk ("*").
</li>
</ul>

<p>
詳細は、
各~methodの定義を見よ。
これらの形は、
他の~methodと伴に利用してはナラナイ。
◎
See the respective method definitions for details. These forms MUST NOT be used with other methods.
</p>

<p>
`~server$は、
`~client$からの要請の受領に際して，［
各自の局所的な環境設定, 入って来る接続の文脈
］に則って，受信した成分から`~target~URI$を再構築する。
この再構築は、
~protocolの各`~major~version$に特有である。
例えば，
`HTTP/1.1$r `~target~URIの再構築-法＠~HTTPv1#reconstructing.target.uri§は、
~serverが~HTTP11要請の`~target~URI$をどう決定するかを定義する。
◎
Upon receipt of a client's request, a server reconstructs the target URI from the received components in accordance with their local configuration and incoming connection context. This reconstruction is specific to each major protocol version. For example, Section 3.3 of [HTTP/1.1] defines how a server determines the target URI of an HTTP/1.1 request.
</p>

<p class="note">注記：
以前の仕様は、
構成し直した~target~URIを，別個な概念を成す
`実効~要請~URI^dfn
（ `effective request URI^en ）として定義していた。
◎
Note: Previous specifications defined the recomposed target URI as a distinct concept, the "effective request URI".
</p>

		</section>
		<section id="field.host">
<h3 title="Host and :authority">7.2. `Host^h ／ `authority^ph</h3>

<p>
要請~内の `Host^h ~headerは、
`~target~URI$からの［
`~host$, `~port$
］情報を供する
— それは、［
同じ`生成元~server$が，複数の~host名に対し要請を~serviceしている間
］でも［
`資源$たちを互いに判別する
］ことを可能化する。
◎
The "Host" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names.
</p>

<p>
［
~HTTP2 `HTTP/2$r, ~HTTP3 `HTTP/3$r
］においては、
`Host$h ~headerは，一部の事例では［
要請の`制御~data$を成す "`authority^ph" 疑似-~header
］に代えられる。
◎
In HTTP/2 [HTTP/2] and HTTP/3 [HTTP/3], the Host header field is, in some cases, supplanted by the ":authority" pseudo-header field of a request's control data.
</p>

<pre class="bnf">
`Host@p
	= `uri-host$p [ ":" `port$p ] ; `4§
</pre>

<p>
`~target~URI$の権限~情報（ `authority$p ）は、
要請を取扱うための~criticalな情報である。
よって，`~UA$は、
その情報を "`authority^ph" 疑似-~headerとして送信しない場合には，
`Host^h ~headerを
⇒＃
要請~内に`生成-$しなければナラナイ。
要請~内の`~header節$を成す最初の`~field$として送信するベキである。
◎
The target URI's authority information is critical for handling a request. A user agent MUST generate a Host header field in a request unless it sends that information as an ":authority" pseudo-header field. A user agent that sends Host SHOULD send it as the first field in the header section of a request.
</p>

<div class="example">
<p>
例えば、
`http://www.example.org/pub/WWW/^c
用の`生成元~server$へ向けた `GET$m 要請 は，次で始まることになろう：
◎
For example, a GET request to the origin server for &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</p>

<pre class="lang-http">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</pre>
</div>

<p>
［
`~host$, `~port$
］情報は，応用~levelの~route法の仕組みとして動作するので、
~malwareにとっては［
`共用~cache$を汚染する／
要請を意図されていない`~server$へ~redirectさせる
］ための格好の~targetになる。
`横取n~proxy$は、
次に該当するときは，特に脆弱になる
⇒
［
要請を内部~serverへ~redirectする／`共用~cache$内の~cache~keyとして利用する
］ときに［
`~host$, `~port$
］情報に依拠していて，［
横取りされた接続が，当の~host用の妥当な~IP~addressを~targetにしているかどうか
］を最初に検証yしていない場合
◎
Since the host and port information acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server. An interception proxy is particularly vulnerable if it relies on the host and port information for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.
</p>

		</section>
		<section id="routing.inbound">
<h3 title="Routing Inbound Requests">7.3. 内方への要請の~route法</h3>

<p>
`~target~URI$と その`生成元$が決定されたなら、
`~client$は，次を裁定する
⇒＃
欲された意味論を成遂げるためには，~network要請が必要yであるかどうか／
必要yなら，その要請をどこへ~directするか
◎
Once the target URI and its origin are determined, a client decides whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.
</p>

			<section id="routing.cache">
<h4 title="To a Cache">7.3.1. ~cacheへの~route法</h4>

<p>
`~client$が`~cache$ `CACHING$r を備えていて, かつ
それにより要請を満足できる場合、
要請は，通例的に，最初にそこへ~directされる。
◎
If the client has a cache [CACHING] and the request can be satisfied by it, then the request is usually directed there first.
</p>

			</section>
			<section id="routing.proxy">
<h4 title="To a Proxy">7.3.2. ~proxyへの~route法</h4>

<p>
代表的な`~client$は、［
要請が`~cache$により満足できない
］場合に［
要請を満足するために利用される`~proxy$があるかどうか
］を決定するため，自身の環境設定を検査することになる。
~proxy環境設定は、
実装に依存するが，［
~URI接頭辞の照合,
選択的な権限の照合,
または この両者
］に基づくことが多く、
~proxy自身は，通例的に［
"`http$c" ／ "`https$c"
］~URIにより識別される。
◎
If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an "http" or "https" URI.
</p>

<p>
適用-可能な［
"`http$c" ／ "`https$c"
］`~proxy$がある場合、
`~client$は，［
その~proxyへの接続を確立する（または再利用する）
］ことにより`内方$へ接続してから［
`~client$の`~target~URI$に合致する`要請~target$
］を包含している~HTTP要請~messageをそこへ送信する。
◎
If an "http" or "https" proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy and then sending it an HTTP request message containing a request target that matches the client's target URI.
</p>

			</section>
			<section id="routing.origin">
<h4 title="To the Origin">7.3.3. 生成元への~route法</h4>

<p>
適用-可能な`~proxy$は無い場合、
代表的な`~client$は，［
当の識別された資源への~accessを得するために，
（`~target~URI$の`~scheme$に特有な）~handler~routineを呼出す
］ことになる。
これが どう成遂げられるかは、
`~target~URI$の`~scheme$に依存し，それを~~規定する仕様により定義される。
◎
If no proxy is applicable, a typical client will invoke a handler routine (specific to the target URI's scheme) to obtain access to the identified resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification.
</p>

<p>
`4.3.2§ は、
"`http$c" 資源への~accessを得する方法を定義する
— 識別された`生成元~server$に向けて`内方$への接続を確立-（または再利用-）してから，［
`~client$の`~target~URI$に合致する`要請~target$
］を包含している~HTTP要請~messageをそこへ送信することにより。
◎
Section 4.3.2 defines how to obtain access to an "http" resource by establishing (or reusing) an inbound connection to the identified origin server and then sending it an HTTP request message containing a request target that matches the client's target URI.
</p>

<p>
`4.3.3§ は、
"`https$c" 資源への~accessを得する方法を定義する
— ［
識別された`生成元$に対し権限的な`生成元~server$
］に向けて`内方$への`~secure化$された接続を確立-（または再利用-）してから，［
`~client$の`~target~URI$に合致する`要請~target$
］を包含している~HTTP要請~messageをそこへ送信することにより。
◎
Section 4.3.3 defines how to obtain access to an "https" resource by establishing (or reusing) an inbound secured connection to an origin server that is authoritative for the identified origin and then sending it an HTTP request message containing a request target that matches the client's target URI.
</p>

			</section>
		</section>
		<section id="routing.reject">
<h3 title="Rejecting Misdirected Requests">7.4. 誤って~directされた要請の却下-法</h3>

<div class="p">
<p>
`~server$は、
要請を受信して，その`~target~URI$を決定するに足るまで構文解析したなら、
次について裁定する
⇒＃
当の要請を処理するかどうか,
当の要請を別の~serverへ回送するかどうか,
`~client$を異なる資源へ~redirectするかどうか,
~errorで応答するかどうか,
当の接続を落とすかどうか
◎
Once a request is received by a server and parsed sufficiently to determine its target URI, the server decides whether to process the request itself, forward the request to another server, redirect the client to a different resource, respond with an error, or drop the connection.＼
</p>

<p>
この裁定には，当の要請や接続~文脈についての どの情報も波及し得るが、
特定的には，次に向けられる
⇒＃
~serverは、当の~target~URI向けの要請を処理するよう環境設定されているかどうか／
接続~文脈は、当の要請~用に適切かどうか
◎
This decision can be influenced by anything about the request or connection context, but is specifically directed at whether the server has been configured to process requests for that target URI and whether the connection context is appropriate for that request.
</p>
</div>

<div class="p">
<p>
例えば，受信した要請の `Host$h ~headerの中の情報は、
故意に, あるいは不用意に誤って［
接続の［
`~host$／`~port$
］とは相違する何か
］を~directしているかもしれない。
そのような不整合は、
信用-済みな`~gateway$からの接続である場合は，予期されたものかもしれないが、
他の場合，次の試みを指示しているかもしれない
⇒＃
~security~filterを迂回する ／
非公開な内容を送達させるよう，~serverを騙す ／
~cacheを汚染する
◎
For example, a request might have been misdirected, deliberately or accidentally, such that the information within a received Host header field differs from the connection's host or port. If the connection is from a trusted gateway, such inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache.＼
</p>

<p>
~messageの~route法に関する~securityの考慮点は、
`17§ を見よ。
◎
See Section 17 for security considerations regarding message routing.
</p>
</div>

<p>
信用-済みな`~gateway$からの接続である場合を除き、
`生成元~server$は，要請のうち［
その`~target~URI$の`~scheme$に特有な要件
］を満たさないものを却下しなければナラナイ。
特に， "`https$c" 資源への要請は、［
その`~target~URI$の`生成元$用の妥当な証明書
］を介して`~secure化$された接続~越しに受信されていない場合には
— `https§c にて定義されるとおり —
却下しなければナラナイ。
◎
Unless the connection is from a trusted gateway, an origin server MUST reject a request if any scheme-specific requirements for the target URI are not met. In particular, a request for an "https" resource MUST be rejected unless it has been received over a connection that has been secured via a certificate valid for that target URI's origin, as defined by Section 4.2.2.
</p>

<p>
状態s~code `421$st は、
次を指示する
⇒
当の応答が応対した要請は，誤って~directされたように出現するので、
`生成元~server$は，それを却下した。
◎
The 421 (Misdirected Request) status code in a response indicates that the origin server has rejected the request because it appears to have been misdirected (Section 15.5.20).
</p>

		</section>
		<section id="response.correlation">
<h3 title="Response Correlation">7.5. 応答の相関</h3>

<p>
同じ接続が，複数の［
要請, 対する応答の交換
］に利用されることもある。
要請~messageと応答~messageとを相関するために利用される仕組みは、
~versionに依存する
— ~HTTPの
ある~versionは~messageの暗黙的な順序付けを利用する一方で，
他の~versionは明示的な識別子を利用する。
◎
A connection might be used for multiple request/response exchanges. The mechanism used to correlate between request and response messages is version dependent; some versions of HTTP use implicit ordering of messages, while others use an explicit identifier.
</p>

<p>
すべての応答は、
`状態s~code$に関わらず（すなわち，`非最終-応答$も含む），
要請を受信し始めた後のいつでも
— 要請がまだ`完全$でなくとも —
送信され得る。
応答は、
それが応対した要請が【~serverにおいて】`完全$になる前に，
【~clientにおいて】`完全$になり得る。
同様に，`~client$には、
応答に対し特定の量の時間だけ待機することは期待されない。
~client（`媒介者$も含む）は、
応答が適度な時間内に受信されなければ，要請を放棄することもある。
◎
All responses, regardless of the status code (including interim responses) can be sent at any time after a request is received, even if the request is not yet complete. A response can complete before its corresponding request is complete (Section 6.1). Likewise, clients are not expected to wait any specific amount of time for a response. Clients (including intermediaries) might abandon a request if the response is not received within a reasonable period of time.
</p>

<p>
`~client$は、
要請を送信し終える前に 対する応答を受信したときでも，要請の送信を継続するベキである
— ただし、
それに反する明示的な指示を受信した場合は除く
（例：
`HTTP/1.1$r `失敗と制限時間＠~HTTPv1#persistent.failures§ ／
`HTTP/2$r `RST_STREAM＠https://httpwg.org/specs/rfc9113.html#RST_STREAM§
を見よ）。
◎
A client that receives a response while it is still sending the associated request SHOULD continue sending that request unless it receives an explicit indication to the contrary (see, e.g., Section 9.5 of [HTTP/1.1] and Section 6.4 of [HTTP/2]).
</p>

		</section>
		<section id="message.forwarding">
<h3 title="Message Forwarding">7.6. ~messageの回送-法</h3>

<p>
`媒介者$は
— `3.7§ にて述べたとおり —
~HTTP［
要請, 応答
］の処理において，様々な`役割$を~serveし得る。
媒介者には、［
処理能や可用性を改善する
］ために利用されるものもあれば，［
~accessを制御する／内容を~filterする
］ために利用されるものもある。
~HTTP~streamには，［
~pipe＆~filter
~architecture
］に類似な特性があるので、
`媒介者$が増強-（または干渉-）し得る限度には
— ~streamの方向を問わず —
内来的な制限は無い。
◎
As described in Section 3.7, intermediaries can serve a variety of roles in the processing of HTTP requests and responses. Some intermediaries are used to improve performance or availability. Others are used for access control or to filter content. Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.
</p>

<p>
`媒介者$は、
認識しない~protocol要素（例：新たな［
`~method$／`状態s~code$／`~field名$
］）があっても，~messageを回送することが期待される
— それは、
`下流$の`受信者$用に拡張能を保全するので。
◎
Intermediaries are expected to forward messages even when protocol elements are not recognized (e.g., new methods, status codes, or field names) since that preserves extensibility for downstream recipients.
</p>

<p>
`~tunnel$として動作しない`媒介者$は、
`Connection$h ~headerを，その節に指定されるとおりに実装しなければナラナイ
— 加えて，［
自身宛の接続のみに意図されている~field
］は、
回送する際に除外しなければナラナイ。
◎
An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 7.6.1, and exclude fields from being forwarded that are only intended for the incoming connection.
</p>

<p>
`媒介者$は、
自身宛の~messageを回送してはナラナイ
— それが，無限~要請~loopから保護されていない限り【？】。
一般に，`媒介者$は、
自前の~server名
— ［
別名,
局所的な変名,
~literal~IP~address
］も含む —
を認識して，そのような要請に対し直に応答する~OUGHT。
◎
An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop. In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.
</p>

<p>
~HTTP~messageは、［
増分的に処理する／`下流$へ回送する
］ときには，~streamとして構文解析できる。
しかしながら，`送信者$も`受信者$も、
増分的な送達による部分的な~messageには依拠できない
— 一部の実装は、［
~network効率,
~security検査,
`内容$の`形式変換$
］の~~目的で，~message回送を~bufferしたり遅延するので。
◎
An HTTP message can be parsed as a stream for incremental processing or forwarding downstream. However, senders and recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or content transformations.
</p>

			<section id="field.connection">
<h4>7.6.1. `Connection^h</h4>

<p>
`Connection^h ~headerは、［
現在の接続に欲される制御~option
］を~listすることを，`送信者$に許容する。
◎
The "Connection" header field allows the sender to list desired control options for the current connection.
</p>

<pre class="bnf">
`Connection@p
	= #`connection-option$p
`connection-option@p
	= `token$p
</pre>

<p>
`connection-option$p が各
`接続~option@
（ `connection options^en ）を与える。
それらは、
文字大小無視である。
◎
Connection options are case-insensitive.
</p>

<p>
`送信者$は、［
`Connection^h 以外の`~field$
］を［
現在の接続［
用／について
］の制御~情報を給する
］ために利用するときは，対応する`~field名$を `Connection^h ~headerの中に~listしなければナラナイ。
~HTTPの一部の~versionは、
そのような情報~用の~fieldの利用を禁制する
— したがって， `Connection^h ~fieldを許容しない —
ことに注意。
◎
When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field. Note that some versions of HTTP prohibit the use of fields for such information, and therefore do not allow the Connection field.
</p>

<div class="p">
<p>
`媒介者$は、
受信した~message %M を回送する前に，次を行わなければナラナイ：
◎
Intermediaries MUST＼
</p>
<ol>
	<li>
%M 内の `Connection^h ~headerの`~field値$を構文解析する
◎
parse a received Connection header field before a message is forwarded and,＼
</li>
	<li>
前~段の結果を成す各 `connection-option$p に対し
⇒
%M から［
`connection-option$p と同じ名前を`~field名$に伴う［
`~header$／`~trailer$
］］をすべて除去する
◎
for each connection-option in this field, remove any header or trailer field(s) from the message with the same name as the connection-option, and then＼
</li>
	<li>
%M 内の `Connection^h ~headerを除去するか，その値を自前の制御~optionで置換する
◎
remove the Connection header field itself (or replace it with the intermediary's own control options for the forwarded message).
</li>
</ol>
</div>

<p>
すなわち， `Connection^h ~headerは、［
直近の`受信者$のみに意図された（`隣点間$）`~field$
］と［
`連鎖$上にある すべての`受信者$に意図された（`端点間$）`~field$
］とを判別できるようにする，宣言的な仕方を供する
— それは、
~messageを`自己-記述的$にすることで，［
接続ごとに特有な，将来の拡張
］を［
旧い`媒介者$により盲目的に回送されるおそれ
］なく配備することを許容する。
◎
Hence, the Connection header field provides a declarative way of distinguishing fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.
</p>

<p>
さらに，`媒介者$は、［
回送する前に除去が要求される
］ことが既知な各~fieldを，
~fieldの意味論を適用した後に［
除去するか置換する
］ベキである
— ~field名が `connection-option$p として出現したかどうかを問わず。
次に挙げる~fieldは，これに含まれるが、
この限りでない
⇒＃
`Proxy-Connection$h `HTTP/1.1$r,
`Keep-Alive$h `2068/19.7.1$rfc,
`TE$h,
`Transfer-Encoding$h `HTTP/1.1$r,
`Upgrade$h
◎
Furthermore, intermediaries SHOULD remove or replace fields that are known to require removal before forwarding, whether or not they appear as a connection-option, after applying those fields' semantics. This includes but is not limited to:

• Proxy-Connection (Appendix C.2.2 of [HTTP/1.1])
• Keep-Alive (Section 19.7.1 of [RFC2068])
• TE (Section 10.1.4)
• Transfer-Encoding (Section 6.1 of [HTTP/1.1])
• Upgrade (Section 7.8)
</p>

<p>
`送信者$は、
`接続~option$として［
`内容$を受け取るすべての`受信者$向けに意図された`~field$
］に対応するものは，送信してはナラナイ。
例えば， `Cache-Control$h は、
接続~optionとしては，決して適切にならない。
◎
A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [CACHING]).
</p>

<p>
`接続~option$は、
常に［
~message内に在る`~field$
］に対応するとは限らない
— 結付けられる~parameterが無い接続~optionに対しては、［
接続ごとに特有な`~field$
］は不要になり得るので。
対照的に，［
対応する接続~optionを伴わずに受信した，接続ごとに特有な~field
］は、
通例的に［
当の~fieldは`媒介者$により不適正に回送された
］ことを指示するので，`受信者$は無視する~OUGHT。
◎
Connection options do not always correspond to a field present in the message, since a connection-specific field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific field received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.
</p>

<p>
仕様~策定者は，~field【登録-済みな~field名】に対応しない新たな`接続~option$を定義するときは、
今後の衝突を避けるべく，対応する`~field名$を予約する~OUGHT。
そのように予約された~field名は、
`~HTTP~field名~registry^cite（ `16.3.1§ ）に登録される。
◎
When defining a new connection option that does not correspond to a field, specification authors ought to reserve the corresponding field name anyway in order to avoid later collisions. Such reserved field names are registered in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" (Section 16.3.1).
</p>

			</section>
			<section id="field.max-forwards">
<h4>7.6.2. `Max-Forwards^h</h4>

<p>
`Max-Forwards^h ~headerは、
`要請~method$［
`TRACE$m ／ `OPTIONS$m
］と伴に，［
要請が`~proxy$により回送される回数
］を制限する仕組みを供する。
これは、
`~client$が［`連鎖$の途上で［
失敗する／~loopする
］ように出現する要請
］を~traceするよう試みるとき，有用になり得る。
◎
The "Max-Forwards" header field provides a mechanism with the TRACE (Section 9.3.8) and OPTIONS (Section 9.3.7) request methods to limit the number of times that the request is forwarded by proxies. This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.
</p>

<pre class="bnf">
`Max-Forwards@p
	= 1*`DIGIT$P
</pre>

<p>
`Max-Forwards^h は、［
当の要請~messageを回送できる残りの回数
］を指示する~decimal整数を値にとる。
◎
The Max-Forwards value is a decimal integer indicating the remaining number of times this request message can be forwarded.
</p>

<div class="p">
<p>
各`媒介者$は、
`Max-Forwards^h ~headerを包含している［
`TRACE$m ／ `OPTIONS$m 
］要請を受信したときは、
要請を回送するに先立って，その値 %N を検査して更新しなければナラナイ。
`媒介者$は、
%N に応じて：
◎
Each intermediary that receives a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request.＼
</p>
<ul class="switch">
	<li>
%N ~EQ 0 の場合
⇒
要請を回送してはナラナイ
— 代わりに、
`最終-受信者$として応答しなければナラナイ。
◎
If the received value is zero (0), the intermediary MUST NOT forward the request; instead, the intermediary MUST respond as the final recipient.＼
</li>
	<li>
他の場合（ %N ~GTE 1 ）
⇒
回送する~message内に
`Max-Forwards^h ~header【！~field】を
— その`~field値$を次のうち最小に更新した上で —
`生成-$しなければナラナイ
⇒＃
%N ~MINUS 1,
当の受信者が `Max-Forwards^h 用に~supportする最大~値
◎
If the received Max-Forwards value is greater than zero, the intermediary MUST generate an updated Max-Forwards field in the forwarded message with a field value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards.
</li>
</ul>
</div>

<p>
`受信者$は、［
他の`要請~method$に伴って受信した `Max-Forwards^h ~header
］については，無視してもヨイ。
◎
A recipient MAY ignore a Max-Forwards header field received with any other request methods.
</p>

			</section>
			<section id="field.via">
<h4>7.6.3. `Via^h</h4>

<div class="p">
<p>
`Via$h ~headerは、
媒介~protocolが在ること, および［
要請においては `~UA$ ↔ ︎`~server$ 間にある`受信者$たち ／
応答においては `生成元~server$ ↔ `~client$ 間にある`受信者$たち
］を指示する。
それは、
~emailにおける `Received$h ~header `RFC5322$r に類似する。
◎
The "Via" header field indicates the presence of intermediate protocols and recipients between the user agent and the server (on requests) or between the origin server and the client (on responses), similar to the "Received" header field in email (Section 3.6.7 of [RFC5322]).＼
</p>

<p>
`Via$h は、
次の用途に利用できる
⇒＃
各~message回送-の追跡 ／
要請~loopを避ける ／
［要請／応答］の`連鎖$沿いにある各`送信者$の~protocol能力を識別する
◎
Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.
</p>
</div>

<pre class="bnf">
`Via@p
	= #( `received-protocol$p `RWS$p `received-by$p [ `RWS$p `comment$p ] )
`received-protocol@p
	= [ `protocol-name$p "/" ] `protocol-version$p【！; see `7.8§】
`received-by@p
	= `pseudonym$p [ ":" `port$p ]
`pseudonym@p
	= `token$p
</pre>

<p class="trans-note">【
“`pseudonym^p” ＝ “`pseudo^en” + “`anonymous^en” （ “~~疑似匿名（~~仮名）” ）
】</p>

<p>
`Via$h `~field値$を成す各~memberは、
当の~messageを回送した［
`~proxy$／`~gateway$
］を表現する。
各`媒介者$は、［
~messageがどう受信されたかについての，自前の情報
］を［
回送した`受信者$たちの順序が保たれる
］ように付加する。
◎
Each member of the Via field value represents a proxy or gateway that has forwarded the message. Each intermediary appends its own information about how the message was received, such that the end result is ordered according to the sequence of forwarding recipients.
</p>

<div class="p">
<p>
`~proxy$は、
以下に述べるとおり，
回送する各~message内に適切な `Via$h ~headerを送信しなければナラナイ。
◎
A proxy MUST send an appropriate Via header field, as described below, in each message that it forwards.＼
</p>

<p>
~HTTP-to-HTTP`~gateway$は、
回送する~messageが：
◎
An HTTP-to-HTTP gateway＼
</p>
<ul>
	<li>
`内方$への要請ならば、
適切な `Via$h ~headerを送信しなければナラナイ。
◎
MUST send an appropriate Via header field in each inbound request message and＼
</li>
	<li>
【`外方$への】応答ならば、
`Via$h ~headerを送信してもヨイ。
◎
MAY send a Via header field in forwarded response messages.
</li>
</ul>
</div>

<p>
`received-protocol$p は、
~messageの`下流$の`媒介者$たちに対し，［
`上流$の`送信者$により利用された~protocol, その~version
］を指示する。
すなわち， `Via$h `~field値$は、［
要請／応答
］`連鎖$にて広告された~protocol能力を，`下流$の`受信者$から可視であり続けるように記録する
— これは、
`2.5§ にて述べたとおり，［
後方-互換でない特能のうち，どれが［
応答／今後の要請
］の中で利用するときに安全になり得るか
］を決定するときに有用になり得る。
~~簡潔にするため、
受信される~protocolが~HTTPであるときは，
`received-protocol$p 内の `protocol-name^p は省略される【されてもヨイ？】
。
◎
For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 2.5. For brevity, the protocol-name is omitted when the received protocol is HTTP.
</p>

<p>
`received-by$p を成す部位は、
通常は［
`受信者$である`~server$, または［
~messageを~~後続へ回送した`~client$
］］の［
`~host$, および省略可能な`~port$番号
］になる。
しかしながら，［
本物の~hostは敏感な情報である
］と見なされる場合、
`送信者$は，それを `pseudonym$p に置換してもヨイ。
`port$p が供されていない場合、
`受信者$は，それを［
`received-protocol$p の既定の~TCP~port上で受信されたことを意味している
］と解釈してもヨイ
— 当の~protocolに既定の~portが定義されている限り。
◎
The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.
</p>

<p>
`送信者$は、
各`受信者$の~softwareを識別するために【識別する側とされる側が逆？】，
`comment$p を`生成-$してもヨイ
— ［
`User-Agent$h ／ `Server$h
］~headerに相似的な。
しかしながら，
`Via$h ~header内の~commentは任意選択であり、
受信者は
— ~messageを回送するに先立って —
それらを除去してもヨイ。
◎
A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.
</p>

<div class="example">
<div class="p">
<p>
例えば，要請~messageが：
◎
For example, a request message could＼
</p>
<ol>
	<li>
~HTTP10`~UA$から［
~code名 "`fred^c" の内部~proxy
］に向けて送信され，
◎
be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred",＼
</li>
	<li>
その内部~proxyは，それを［
`p.example.net^c にある公共~proxy
］に向けて回送するときに~HTTP11を利用し，
◎
which uses HTTP/1.1 to forward the request to a public proxy at p.example.net,＼
</li>
	<li>
その公共~proxyは，それを［
`www.example.com^c にある`生成元~server$
］に向けて回送して，完了した
◎
which completes the request by forwarding it to the origin server at www.example.com.＼
</li>
</ol>

<p>
とするとき、
`www.example.com^c にて受信される要請には，次の `Via$h ~headerが在ることになろう：
◎
The request received by www.example.com would then have the following Via header field:
</p>
</div>

<pre class="lang-http">
Via: 1.0 fred, 1.1 p.example.net
</pre>
</div>

<p>
［
~network~firewallを通る~portal
］として利用される`媒介者$は、
明示的に可能化されていない限り，［
~firewall領域の中の各~host
］の［
名前, ~port
］を回送するベキでない。
可能化されていない場合、
そのような`媒介者$は，［
~firewallの背後の~hostを表すような，各 `received-by$p ~host
］を［
その~hostに適切な `pseudonym$p
］に置換するベキである。
◎
An intermediary used as a portal through a network firewall SHOULD NOT forward the names and ports of hosts within the firewall region unless it is explicitly enabled to do so. If not enabled, such an intermediary SHOULD replace each received-by host of any host behind the firewall by an appropriate pseudonym for that host.
</p>

<p>
`媒介者$は、
`Via$h ~headerの［
`received-protocol$p 値が互いに一致する，~~連続する一連の~list~member
］を，単独の~memberに結合してもヨイ。
◎
An intermediary MAY combine an ordered subsequence of Via header field list members into a single member if the entries have identical received-protocol values.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</pre>

<p>
は、
次の様に縮約することもできる：
◎
could be collapsed to
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</pre>
</div>

<div class="p">
<p>
`送信者$は：
◎
↓</p>
<ul>
	<li>
複数の~list~memberを 1 つに結合するベキでない
— ただし、［
それらすべてが同じ組織の制御~下にある
］かつ［
それらの~hostは すでに `pseudonym$p に置換されている
］場合は除く。
◎
A sender SHOULD NOT combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.＼
</li>
	<li>
［
`received-protocol$p 値が互いに異なる，複数の~member
］を 1 つに結合してはナラナイ。
◎
A sender MUST NOT combine members that have different received-protocol values.
</li>
</ul>
</div>

			</section>
		</section>
		<section id="message.transformations">
<h3 title="Message Transformations">7.7. ~messageの形式変換</h3>

<p>
一部の`媒介者$は、［
~messageとその`内容$
］を
`形式変換-@
する（ `transform^en する）ための特能を有している。
例えば，`~proxy$には、［
~cache空間を節約する／
遅い~link上の流通~量を抑制する
］ために，画像~形式を変換するものもある。
しかしながら、
これらの形式変換が［
~criticalな応用
— 医療~用の画像処理や科学的な~data分析など —
に意図された`内容$
］に適用されると，運用~上の問題が生じるかもしれない
— 特に、
受信される`内容$が元の内容と一致することを確保するために，
完全性~検査や~digital署名が利用されている下では。
◎
Some intermediaries include features for transforming messages and their content. A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. However, operational problems might occur when these transformations are applied to content intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the content received is identical to the original.
</p>

<p>
~messageを意味論的に有意義な仕方で改変するよう［
設計された／環境設定された
］~HTTP-to-HTTP`~proxy$は、
`形式変換ng~proxy@
（ `transforming proxy^en ）と呼ばれる
（改変するとは、
通常の~HTTP処理に要求されるものを超えて，［
元の`送信者$にとって有意になる
］あるいは［
`下流$の`受信者$にとって有意になり得る
］ような仕方で~messageを変更することを意味する）。
例えば，形式変換ng~proxyには、［
共用~注釈~server
（応答を［
局所的な注釈~databaseへの参照を内包する
］よう改変する）／
~malware~filter／
形式~符号変換器／
~privacy~filter
］などとして動作しているものも，あるかもしれない。
そのような`形式変換$は、
~client（または~client組織）が何であれ，［
`~client$が欲して`~proxy$を選んだ
］ものと予め見做される。
◎
An HTTP-to-HTTP proxy is called a "transforming proxy" if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients). For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter. Such transformations are presumed to be desired by whichever client (or client organization) chose the proxy.
</p>

<p>
`~proxy$は：
◎
↓</p>
<ul>
	<li>
<p>
受信した`~target~URI$の`~host$名が完全修飾~domain名でない場合には、
要請を回送するときに，受信した`~host$名に自前の~domainを追加してもヨイ。
◎
If a proxy receives a target URI with a host name that is not a fully qualified domain name, it MAY add its own domain to the host name it received when forwarding the request.＼
</p>

<p>
`~target~URI$が完全修飾~domain名を包含する場合には、
`~host$名を変更してはナラナイ。
◎
A proxy MUST NOT change the host name if the target URI contains a fully qualified domain name.
</p>

	</li>
	<li>
受信した`~target~URI$を`内方$にある次の`~server$へ回送するときには、
その［
`absolute-path$p, `query$p
］を成す部分を改変してはナラナイ
— ただし、
回送~protocolにより要求される場合を除く。
例えば，~HTTP11を介して要請を`生成元~server$へ回送している`~proxy$は、
空な `path$p を要請~methodに応じて，次のいずれかに置換することになる
⇒＃
"`/^c" （ `HTTP/1.1$r `origin-form＠~HTTPv1#origin-form§c により要求される）／
"`*^c" （ `HTTP/1.1$r `asterisk-form＠~HTTPv1#asterisk-form§c により要求される）
◎
A proxy MUST NOT modify the "absolute-path" and "query" parts of the received target URI when forwarding it to the next inbound server except as required by that forwarding protocol. For example, a proxy forwarding a request to an origin server via HTTP/1.1 will replace an empty path with "/" (Section 3.2.1 of [HTTP/1.1]) or "*" (Section 3.2.4 of [HTTP/1.1]), depending on the request method.
</li>
	<li>
応答~messageが `no-transform$sdir `~cache指令$を包含する場合、
その`内容$を`形式変換-$してはナラナイ。
これは、
`内容$を変更しない~message形式変換
— `転送~符号法$の追加や除去など —
には適用されないことに注意。
◎
A proxy MUST NOT transform the content (Section 6.4) of a response message that contains a no-transform cache directive (Section 5.2.2.6 of [CACHING]).＼
Note that this does not apply to message transformations that do not change the content, such as the addition or removal of transfer codings (Section 7 of [HTTP/1.1]).
</li>
			<li>
~messageが `no-transform^dir `~cache指令$を包含しない場合、
その`内容$を`形式変換-$してもヨイ。
加えて，［
`200$st 応答の`内容$
］を`形式変換-$するときは、［
応答の`状態s~code$を `203$st に変更する
］ことにより［
`下流$の`受信者$たちに`形式変換$が適用されたことを伝える
］こともできる。
◎
A proxy MAY transform the content of a message that does not contain a no-transform cache directive. A proxy that transforms the content of a 200 (OK) response can inform downstream recipients that a transformation has been applied by changing the response status code to 203 (Non-Authoritative Information) (Section 15.3.4).
</li>
	<li>
<p>
次についての情報を供する~headerは、
改変するベキでない
⇒＃
通信`連鎖$の両`端点$,
`資源$の状態,
`選定された表現$（`内容$について以外の）
◎
A proxy SHOULD NOT modify header fields that provide information about the endpoints of the communication chain, the resource state, or the selected representation (other than the content)＼
</p>

<p>
— ただし，次に該当するときは除く
⇒＃
~headerの定義が，そのような改変を特定的に許容している ／
~privacyや~securityのために，改変が必要と判断される
◎
unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security.
</p>
	</li>
</ul>

		</section>
		<section id="field.upgrade">
<h3>7.8. `Upgrade^h</h3>

<p>
`Upgrade^h ~headerは、［
ある接続~上で，`~HTTP11$から 何らかの他の~protocolへ移行する
］ための単純な仕組みを供するためとして意図される。
◎
The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.
</p>

<p>
`~client$は、
要請の `Upgrade^h ~header内に［
選好順による，~protocol名たちが成す~list
］を送信して，［
`~server$が`最終-応答$を送信する前に，
1 個~以上の それらの名前の~protocolに切替えてもらう
］よう，~serverを招いてもヨイ。
`~server$は、
その接続~上で現在の~protocolを利用し続けるよう望むならば，
受信した `Upgrade^h ~headerを無視してもヨイ。
`Upgrade^h は、
~protocol変更を強要するために利用できるものではない。
◎
A client MAY send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.
</p>

<pre class="bnf">
`Upgrade@p
	= #`protocol$p
`protocol@p
	= `protocol-name$p ["/" `protocol-version$p]
`protocol-name@p
	= `token$p
`protocol-version@p
	= `token$p
</pre>

<p>
~protocol名は，選好される文字大小で登録されるが、
`受信者$は，［
各 `protocol-name$p を自身が~supportする~protocolと照合する
］ときには文字大小無視で比較するベキである。
◎
Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.
</p>

<p>
`~server$は：
◎
↓</p>
<ul>
	<li>
<p>
`101$st 応答を送信するときは：
◎
A server that sends a 101 (Switching Protocols) response＼
</p>
		<ul>
			<li>
`Upgrade^h ~headerを送信して、
切替えようとしている接続に対し，
1 個~以上の新たな~protocolを指示しなければナラナイ。
◎
MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched;＼
</li>
			<li>
切替えようとしている~protocol層が複数ある場合、
それらを最下~層のものから昇順に~listしなければナラナイ。
◎
if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.＼
</li>
			<li>
~protocolを次に該当するもの以外に切替えてはナラナイ
⇒
`~client$により［
応答が応対した要請の `Upgrade^h ~header
］内に指示されたもの
◎
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.＼
</li>
			<li>
`~client$により指示された［
選好の順序
］を無視することを選んで，他の要因
— 要請の資質や, ~server上の現在の負荷など —
に基づく新たな†~protocol（たち）を選定してもヨイ。
【† “新たな” — 前項に反しない下で。】
◎
A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.
</li>
		</ul>
	</li>
	<li>
`426$st 応答を送信するときは
⇒
［
選好順による， `Upgrade^h ~header
］を送信して，受容-可能な~protocolを指示しなければナラナイ。
◎
A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.
</li>
	<li>
他の応答においても、
未来の要請~用に適切になるときは
⇒
［
選好順による， `Upgrade^h ~header
］を送信して，［
~listされた~protocolに昇格するための~supportを，自身が実装している
］ことを広告してもヨイ。
◎
A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.
</li>
</ul>

<div class="example">
<p>
`~client$により送信される仮の例：
◎
The following is a hypothetical example sent by a client:
</p>

<pre class="lang-http">
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
</pre>
</div>

<p>
~protocol変更~後における，応用~levelの通信の［
能力, 資質
］は、［
選ばれた新たな~protocol（たち）
］に全面的に依存する。
しかしながら，`~server$には、
`101$st 応答を送信した直後に［
新たな~protocolの中で，元の要請に等価なもの
］を受信したかのように，応答を継続することが期待される
（すなわち，~protocolが変更された後であっても、
満足するべき応答待ち要請【まだ`最終-応答$は受信されていない要請】は在って，
~serverには［
要請の繰返しを要求することなく，それを満足する
］ことが期待されている）。
◎
The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).
</p>

<p>
例えば，~serverが［
`GET$m 要請にて `Upgrade^h ~headerが受信された
］下で~protocolを切替えるものと裁定した場合には、
まず［
HTTP/1.1 `101$st ~message
］で応答して，直後に［
新たな~protocolにおける［
`~target資源$への `GET$m に対する応答
］に等価なもの
］が後続する。
これは、［
追加的な往復による待時間~cost
］を伴わずに接続を［
~HTTPと同じ意味論を有する~protocol
］へ昇格することを許容する。
`~server$は、
新たな~protocolが［
受信した~messageの意味論
］を尊守し得ない場合には，~protocolを切替えてはナラナイ
— `OPTIONS$m 要請は、
どの~protocolからも尊守し得る。
◎
For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.
</p>

<div class="example">
<p>
上に示した仮の要請に対する応答の例：
◎
The following is an example response to the above hypothetical request:
</p>

<pre class="lang-http">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

<span class="comment">
[…… "`GET /hello^c" 要請に対し，適切な応答により~data~streamを
websocket に切替える（その新たな~protocolによる定義に従って）…… ]
◎
[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
</span>
</pre>
</div>

<p>
`Upgrade^h の`送信者$は、
`媒介者$に この~fieldを回送しないよう伝えるため，
`Connection$h ~header内に "`Upgrade^c" `接続~option$を送信しなければナラナイ。
◎
A sender of Upgrade MUST also send an "Upgrade" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.＼
</p>

<p>
~HTTP10要請~内に `Upgrade^h ~headerを受信した`~server$は、
それを無視しなければナラナイ。
◎
A server that receives an Upgrade header field in an HTTP/1.0 request MUST ignore that Upgrade field.
</p>

<p>
`~client$は、［
要請~messageを完全に送信し終える
］まで，接続~上にて昇格された~protocolの利用を~~開始できない
（すなわち，~clientは、
~messageの中途で，送信している~protocolを変更できない）。
`~server$は、［
`Upgrade^h,
`100-continue$c `期待$を伴う `Expect$h
］両~headerとも受信したときは，
`101$st 応答を送信する前に `100$st 応答を送信しなければナラナイ。
◎
A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the "100-continue" expectation (Section 10.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.
</p>

<p>
`Upgrade^h ~headerは、［
既存の接続の上層にある~protocolを切替える
］ために限り，適用される。
それは、［
下層~接続の（~transport）~protocolを切替える／
既存の通信を異なる接続に切替える
］ためには，利用できない。
その種の目的には、
`3xx$st 応答を利用する方が適切である。
◎
The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 15.4).
</p>

<p>
この仕様は、［
Hypertext Transfer Protocol 族
］に利用するための~protocol名として
— ［
`2.5§ による~HTTP~version規則, および この仕様に対する将来の更新
］にて定義されるとおり —
"`HTTP^c" のみを定義する。
追加的な~protocol名は、
`16.7§ にて定義される登録~手続-を利用して登録される~OUGHT。
◎
This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 2.5 and future updates to this specification. Additional protocol names ought to be registered using the registration procedure defined in Section 16.7.
</p>

		</section>
	</section>
	<section id="representation.data.and.metadata">
<h2 title="Representation Data and Metadata">8. 表現~dataと表現~metadata</h2>

		<section id="representation.data">
<h3 title="Representation Data">8.1. 表現~data</h3>

<p>
~HTTP~messageに結付けられる
`表現~data@
（ `representation data^en ）（当の`表現$を成す~data）は、
~messageの`内容$として供されるか，または［
~message意味論と`~target~URI$
］により指される。
`表現~data$の［
形式, 符号化法
］は、
`表現~header$【！表現~metadata~header】により定義される。
◎
The representation data associated with an HTTP message is either provided as the content of the message or referred to by the message semantics and the target URI. The representation data is in a format and encoding defined by the representation metadata header fields.
</p>

<p>
`表現~data$の~data型は、［
`Content-Type$h, および `Content-Encoding$h 
］~headerを介して決定される。
これらは［
2 つの層からなる, 順序付けられた符号化~model
］を定義する：
◎
The data type of the representation data is determined via the header fields Content-Type and Content-Encoding. These define a two-layer, ordered encoding model:
</p>

<blockquote>
表現~data := %Content-Encoding ( %Content-Type ( ~data ) )
◎
representation-data := Content-Encoding( Content-Type( data ) )
</blockquote>

		</section>
		<section id="representation.metadata">
<h3 title="Representation Metadata">8.2. 表現~metadata</h3>

<p>
`表現~header@
†は、
`表現~metadata@
— 当の`表現$についての~metadata —
を供する。
表現~headerたちは、
~messageが`内容$を内包するとき，それを解釈する方法を述べる。
`HEAD$m 要請に対する応答においては、
表現~headerたちは，［
その要請が `GET$m であったとするとき，当の`内容$内に同封されることになる`表現~data$
］について述べる。
◎
Representation header fields provide metadata about the representation. When a message includes content, the representation header fields describe how to interpret that data. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the content if the same request had been a GET.
</p>

<p class="trans-note">【†
特に，以下の各 § 8.x にて定義されるもの（`検証子~field$も含む）が該当するが、
それらに限定されてはいない。
】</p>

		</section>
		<section id="field.content-type">
<h3>8.3. `Content-Type^h</h3>

<p>
`Content-Type^h ~headerは、
結付けられている`表現$
— ~message意味論に従って決定された，［
~messageの`内容$内に同封された表現, または`選定された表現$
］ —
の`~MIME型$を指示する。
指示された~MIME型は、［
`Content-Encoding$h により指示される`内容~符号法$（たち）を復号した結果の~data
］の形式および［
`受信者$は，それをどう処理するものと意図されているか
］を，受信された~message意味論の視野の中で定義する。
◎
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message content or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by Content-Encoding are decoded.
</p>

<pre class="bnf">
`Content-Type@p
	= `media-type$p
</pre>

<div class="example">
<p>
【！ ~MIME型は 6.1.1 にて定義される。】
~headerの例：
◎
Media types are defined in Section 8.3.1. An example of the field is
</p>

<pre class="lang-http">
Content-Type: text/html; charset=ISO-8859-4
</pre>
</div>

<p>
`送信者$は，~message内に`内容$を`生成-$するときは、
同封された`表現$に意図された`~MIME型$について既知ならば，その~message内に `Content-Type^h ~headerも`生成-$するベキである。
`受信者$は，~message内に `Content-Type^h ~headerが無い場合には、
その~MIME型を
"`application/octet-stream$c" `RFC2046$r
と見做すか, または
その`内容$を精査して決定してもヨイ。
◎
A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a Content-Type header field is not present, the recipient MAY either assume a media type of "application/octet-stream" ([RFC2046], Section 4.5.1) or examine the data to determine its type.
</p>

<p>
実施においては，`資源$の所有者は、
`生成元~server$が［
所与の`表現$用に正しい `Content-Type^h を供する
］ように，常に適正に環境設定しているとは限らない。
一部の~UAは、
`内容$を精査して，ある種の事例で指定された型を上書きする
（例えば `Sniffing$r を見よ）。
この “~MIME~sniff法” には、
~dataについて不正な結論に至る~riskがあり，追加的な~security~riskに利用者を晒し得る
（例： “特権拡大” ）。
更には、
別個な`~MIME型$たちが，共通な~data形式を共有していて［
当の~dataはどう処理されるものと意図されるか
］に限り相違することも多い
— ~dataだけを検分して，それを判別することは、
不可能である。
~sniff法を実装する実装者には、
それを不能化する手段を利用者に供することが奨励される。
◎
In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine the content and, in certain cases, override the received type (for example, see [Sniffing]). This "MIME sniffing" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., "privilege escalation"). Furthermore, distinct media types often share a common data format, differing only in how the data is intended to be processed, which is impossible to distinguish by inspecting the data alone. When sniffing is implemented, implementers are encouraged to provide a means for the user to disable it.
</p>

<p>
`Content-Type^h は`単数~field$として定義されるが、
不正に複数回 `生成-$され，その結果 `結合-$された`~field値$が~listのように出現することもある。
受信者は，この~errorを［
~listを成す構文上は妥当な~memberのうち，最後のものを利用して取扱う
］よう試みることが多く、
この~errorを取扱う挙動が実装に応じて異なる場合，［
相互運用能／~security
］の課題へ導くことになり得る。
◎
Although Content-Type is defined as a singleton field, it is sometimes incorrectly generated multiple times, resulting in a combined field value that appears to be a list. Recipients often attempt to handle this error by using the last syntactically valid member of the list, leading to potential interoperability and security issues if different implementations have different error handling behaviors.
</p>

			<section id="media.type">
<h4 title="Media Type">8.3.1. ~MIME型</h4>

<p class="trans-note">【
この訳では、
原文の［
`Internet media type^en, その略称 `media type^en
］を，一律に “~MIME型” と表記する
（ ~RFC以外の他の~web標準と一貫させるため）。
】</p>

<p>
~HTTPは、［
~openかつ拡張できる，~dataの型~付けと型~折衝
］を供するため，［
`Content-Type$h, `Accept$h
］~header内で~MIME型 `RFC2046$r を利用する。
`~MIME型@
（ `media-type$p ）は、
~data形式, および様々な処理~model
— ~message文脈に則って，~dataを処理する方法 —
を定義する。
◎
HTTP uses media types [RFC2046] in the Content-Type (Section 8.3) and Accept (Section 12.5.1) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with the message context.
</p>

<pre class="bnf">
`media-type@p
	= `type$p "/" `subtype$p `parameters$p
`type@p
	= `token$p
`subtype@p
	= `token$p
</pre>

【！ Errata 4031 Rejected】

<p>
［
`type$p, `subtype$p
］どちらも、
文字大小無視である。
◎
The type and subtype tokens are case-insensitive.
</p>

<p>
`type/subtype^p には、
~semicolonで区切られた何個かの
`~MIME型~parameter@
— ［
名前, 値
］が成す~pairの形をとる`~parameter$ —
が後続してもヨイ。
~parameterの有無は、［
~MIME型~registryにおける その定義
］に依存して，~MIME型の処理に有意になり得る。
各~parameterの値が文字大小区別になるかどうかは、
当の~parameterの名前の意味論に依存する。
◎
The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs. The presence or absence of a parameter might be significant to the processing of a media type, depending on its definition within the media type registry. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name.
</p>

<div class="example">
<p>
例えば，次に挙げるものは、［
~UTF-8文字~符号化~schemeに符号化された~HTML~text~data
］を述べるときには，どれも等価になる
（ "`charset^c" ~parameterの値は、
`2046/4.1.2$rfc にて，文字大小無視として定義されている）
— 一貫性を得るため、
最初のものが選好されるが：
◎
For example, the following media types are equivalent in describing HTML text data encoded in the UTF-8 character encoding scheme, but the first is preferred for consistency (the "charset" parameter value is defined as being case-insensitive in [RFC2046], Section 4.1.2):
</p>

<pre class="lang-http">
text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
text/html;charset=UTF-8
</pre>
</div>

<p>
~MIME型は、
`BCP13$r にて定義される手続-に則って，~IANAにより登録される~OUGHT。
◎
Media types ought to be registered with IANA according to the procedures defined in [BCP13].
</p>

			</section>
			<section id="charset">
<h4 title="Charset">8.3.2. ~charset</h4>

<p>
~HTTPでは、［
~textな表現の文字~符号化~scheme `6365/2$rfc
］を［
指示する／折衝する
］ときに，
`~charset^dfn
（ `charset^en ）名を利用する。
この文書に定義される~fieldにおいては、
~charset名は［
`Content-Type$h の `parameters$p 内に／
`Accept-Encoding$p† 用に素な~token形として
］出現する。
どちらの事例でも、
~charset名は文字大小無視で照合される。
◎
HTTP uses "charset" names to indicate or negotiate the character encoding scheme ([RFC6365], Section 2) of a textual representation. In the fields defined by this document, charset names appear either in parameters (Content-Type), or, for Accept-Encoding, in the form of a plain token. In both cases, charset names are matched case-insensitively.
</p>

<p class="trans-note">【†
`7419$errata（Verified）：
`Accept-Encoding^p は `Accept-Charset$p に置換するべき。
】</p>

<p>
~charset名は、
`2978/2$rfc にて定義される手続-に則って，
~IANA `Character Sets＠~IANA-a/character-sets$cite ~registryに登録される~OUGHT。
◎
Charset names ought to be registered in the IANA "Character Sets" registry (&lt;https://www.iana.org/assignments/character-sets&gt;) according to the procedures defined in Section 2 of [RFC2978].
</p>

<p class="note">注記：
理論~上は、
~charset名は， `mime-charset^p ~ABNF規則  `2978/2.3$rfc にて定義される
（ `Err1912$r により正された上で）。
その規則は， `token$p に含まれない 2 つの文字（ "`{^c", "`}^c" ）を許容するが、
これを書いた時点では，それらの文字を含む~charset名は登録されていない
（ `Err5433$r を見よ）。
◎
Note: In theory, charset names are defined by the "mime-charset" ABNF rule defined in Section 2.3 of [RFC2978] (as corrected in [Err1912]). That rule allows two characters that are not included in "token" ("{" and "}"), but no charset name registered at the time of this writing includes braces (see [Err5433]).
</p>

			</section>
			<section id="multipart.types">
<h4 title="Multipart Types">8.3.3. `multipart^c 型</h4>

<p>
~MIMEは、［
単独の`~message本体$の中に， 1 個以上の`表現$が~capsule化される
］ような，いくつかの "`multipart^c" 型を供する。
すべての "`multipart^c" 型は、
`2046/5.1.1$rfc にて定義されるとおり，共通な構文を共有し、
`~MIME型$ 値の一部として，境界~parameterを内包する。
`~message本体$自身は、
~protocol要素である
— `送信者$は、
本体の各 部分~間の改行を表現するときは，
`CRLF$P のみを`生成-$しなければナラナイ。
◎
MIME provides for a number of "multipart" types -- encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in Section 5.1.1 of [RFC2046], and include a boundary parameter as part of the media type value. The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.
</p>

<p>
~HTTP~message~frame法においては、
"`multipart^c" 境界が `~message本体$の長さの指示子として利用されることはない
— `内容$を［
生成する／処理する
］実装により，利用されることはあっても。
例えば， "`multipart/form-data^c" 型は、
`RFC7578$r にて述べられるとおり，要請~内に~form~dataを運ばせるために利用されることが多い。
また， "`multipart/byteranges$c" 型は、
一部の `206$st 応答に利用するためとして，この仕様により定義される。
◎
HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the content. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [RFC7578], and the "multipart/byteranges" type is defined by this specification for use in some 206 (Partial Content) responses (see Section 15.3.7).
</p>

			</section>
		</section>
		<section id="field.content-encoding">
<h3>8.4. `Content-Encoding^h</h3>

<p>
`Content-Encoding^h ~headerは、
次を指示する
⇒
`~MIME型$に内来的なものを超えて，`表現$に適用された`内容~符号法$
— したがって、［［
`Content-Type$h ~headerにより参照された~MIME型
］による~data
］を得するために適用する必要がある，復号の仕組み
◎
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field.＼
</p>

<p>
`Content-Encoding^h は、
首に，次を許容するために利用される
⇒
下層の~MIME型の同一性を損なうことなく，表現の~dataを圧縮する
◎
Content-Encoding is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
</p>

<pre class="bnf">
`Content-Encoding@p
	= #`content-coding$p
</pre>

<div class="example">
<p>
その利用~例：
◎
An example of its use is
</p>

<pre class="lang-http">
Content-Encoding: gzip
</pre>
</div>

<p>
`送信者$は、［
`表現$に一つ以上の符号化法を適用する
］ときには，［
各 `内容~符号法$を適用した順序で~listする，
`Content-Encoding^h ~header
］を`生成-$しなければナラナイ。
"`identity$c" と命名される符号法は、
`Accept-Encoding$h における特別な役割に予約されており，内包するベキではない。
◎
If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied. Note that the coding named "identity" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.
</p>

<p>
［
符号化法の各種~parameterについての追加的な情報
］も［
この仕様では定義されない他の~header
］により供され得る。
◎
Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>

<p>
`Transfer-Encoding$h と違って，［
`Content-Encoding^h 内に~listされた符号法
］は、
`表現$の特性である
— 表現は、
符号化形の用語を通して定義される。
また，表現に関する他のすべての~metadataは、
その~metadata定義にて注記されない限り，符号化形に関するものである。
表現が復号されるのは、
概して，それを具現化する, またはそれに類する用法の~~直前に限られる。
◎
Unlike Transfer-Encoding (Section 6.1 of [HTTP/1.1]), the codings listed in Content-Encoding are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
</p>

<p>
`~MIME型$が含む内来的な符号化法
— 常に圧縮される~data形式など —
は、
それが［
いずれかの`内容~符号法$と たまたま同じ~algoである
］としても、
`Content-Encoding^h 内には再掲されない。
そのような内容~符号法が~listされるのは、［
`表現$を形成するときに，何らかの奇妙な理由から 二重に適用された場合
］に限られることになる。
同様に，`生成元~server$は、
同じ~dataを［［
符号法が［
`Content-Type$h や `Content-Encoding^h
］の一部として定義されるかどうか
］においてのみ相違するような，複数の表現
］として公表することを選ぶかもしれない
— 一部の~UAは、
応答ごとに取扱いを違えるように挙動するので
（例： 内容を自動解凍して具現化する代わりに， “保存…” ~dialogを開く）。
◎
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in Content-Encoding even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of Content-Type or Content-Encoding, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).
</p>

<p>
`生成元~server$は、
要請~message内の`表現$に受容-可能でない`内容~符号法$があるときには，
`415$st で応答してもヨイ。
◎
An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.
</p>

			<section id="content.codings">
<h4 title="Content Codings">8.4.1. 内容~符号法</h4>

<p>
内容~符号法の値（ `content-coding$p ）は、［
`表現$に［
適用された／適用できる
］符号化法による形式変換
］を指示する。
内容~符号法は、
首に，次を許容するために利用される
⇒
表現の下層の［
`~MIME型$の同一性, 情報
］を損なうことなく，表現を
— 圧縮するなど —
有用に形式変換する。
◎終
表現が［
符号化形で格納され，直に伝送され
］，最終-受信者のみがそれを復号することは、
~~頻繁にある。
◎
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
</p>

<pre class="bnf">
`content-coding@p
	= `token$p
</pre>

<p>
すべての内容~符号法は、
文字大小無視であり，［
`16.6§ にて述べるとおり，
`内容~符号法~registry$cite の中に登録される
］~OUGHT。
◎
All content codings are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as described in Section 16.6
</p>

<p>
各種 内容~符号法~値は、［
`Accept-Encoding$h,
`Content-Encoding$h
］~header内で利用される。
◎
Content-coding values are used in the Accept-Encoding (Section 12.5.3) and Content-Encoding (Section 8.4) header fields.
</p>

				<section id="compress.coding">
<h5 title="Compress Coding">8.4.1.1. "`compress^c" 符号法</h5>

<p>
"`compress^c" 符号法は、［
順応的 LZW（ `Lempel-Ziv-Welch^en ）符号法 `Welch$r
］であり，［
~UNIX~file圧縮~program “compress”
］により共通的に生産される。
`受信者$は、
"`x-compress^c" を "`compress^c" と等価と見なすベキである。
◎
The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding [Welch] that is commonly produced by the UNIX file compression program "compress". A recipient SHOULD consider "x-compress" to be equivalent to "compress".
</p>

				</section>
				<section id="deflate.coding">
<h5 title="Deflate Coding">8.4.1.2. "`deflate^c" 符号法</h5>

<p>
"`deflate^c" 符号法は、
“zlib” ~data形式 `RFC1950$r であり，［
LZ77 （ `Lempel-Ziv^en ）圧縮~algoと Huffman 符号法
］が組合された “deflate” 圧縮-済み~data~stream `RFC1951$r を包含する。
◎
The "deflate" coding is a "zlib" data format [RFC1950] containing a "deflate" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.
</p>

<p class="note">注記：
一部の適合しない実装は、
“deflate” 圧縮-済み~dataを “zlib” で包装することなく送信する。
◎
Note: Some non-conformant implementations send the "deflate" compressed data without the zlib wrapper.
</p>

				</section>
				<section id="gzip.coding">
<h5 title="Gzip Coding">8.4.1.3. "`gzip^c" 符号法</h5>

<p>
"`gzip^c" 符号法は、［
32-bit CRC（ `Cyclic Redundancy Check^en ）が伴われた LZ77 符号法
］であり，［
“gzip” ~file圧縮~program `RFC1952$r
］により共通的に生産される。
`受信者$は、
"`x-gzip^c" を "`gzip^c" と等価と見なすベキである。
◎
The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]. A recipient SHOULD consider "x-gzip" to be equivalent to "gzip".
</p>

				</section>
			</section>
		</section>
		<section id="field.content-language">
<h3>8.5. `Content-Language^h</h3>

<p>
`Content-Language^h ~headerは、
`表現$用に意図される視聴者の自然~言語（たち）を述べる。
これは、［
表現の中で利用される どの言語にも等価にならない
］場合もあることに注意。
◎
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
</p>

<pre class="bnf">
`Content-Language@p
	= #`language-tag$p
</pre>

<p>
【！ 言語~tagは、6.1.3にて定義される。】
`Content-Language^h の首な目的は、
次を許容することである
⇒
利用者が，自身が選好する言語に則って表現たちを識別したり相違化する
◎
Language tags are defined in Section 8.5.1. The primary purpose of Content-Language is to allow a user to identify and differentiate representations according to the users' own preferred language.＼
</p>

<div class="example">
<p>
したがって、
~Danish話者~向けのみを意図した内容~用に適切になる~fieldは：
◎
Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
</p>

<pre class="lang-http">
Content-Language: da
</pre>
</div>

<p>
`Content-Language^h が指定されていない場合、［
内容は，すべての言語にわたる視聴者~向けを意図する
］ことが，既定になる。
これは、
送信者が［
内容は どの自然~言語にも特有でないと見なしている／
内容に意図された言語を知らない
］ことを意味するかもしれない。
◎
If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
</p>

<p>
［
複数の言語にわたる視聴者~向けに意図される内容
］用には、
複数の言語が~listされてもヨイ。
◎
Multiple languages MAY be listed for content that is intended for multiple audiences.＼
</p>

<div class="example">
<p>
例えば， “ワイタンギ条約” を，元の~Maoriと英語~versionで同時に呈示させたい場合、
次を用いることになろう：
◎
For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
</p>

<pre class="lang-http">
Content-Language: mi, en
</pre>
</div>

<p>
しかしながら、
表現の中に複数の言語が在るだけで，
複数の言語にわたる話者~向けが意図されたことにはならない。
例えば，
“`A First Lesson in Latin^en” のような［
英語~話者~向けが明瞭な，初学者~向けの言語~入門書
］であれば、
`Content-Language^h は "`en^c" のみを内包する方が適正になろう。
◎
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".
</p>

<p>
`Content-Language^h は、
どの`~MIME型$に適用されてもヨイ
— ~textな文書のみに制限されない。
◎
Content-Language MAY be applied to any media type -- it is not limited to textual documents.
</p>

			<section id="language.tags">
<h4 title="Language Tags">8.5.1. 言語~tag</h4>

<p>
`言語~tag@
（ `language tag^en ）は、
`RFC5646$r にて定義されるとおり，
自然~言語
— 他者と情報をやりとりするために，ヒトにより［
話される／書かれる
］などにより伝達される言語 —
を識別する。
~computer言語は、
明示的に除外される。
◎
A language tag, as defined in [RFC5646], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
</p>

<p>
~HTTPでは、
言語~tagを［
`Accept-Language$h ／ `Content-Language$h
］~headerの中で利用する。
`Accept-Language$h は，より~~広い `language-range$p 生成規則を利用するように定義される一方、
`Content-Language$h は，次に定義する `language-tag$p 生成規則を利用する：
◎
HTTP uses language tags within the Accept-Language and Content-Language header fields. Accept-Language uses the broader language-range production defined in Section 12.5.4, whereas Content-Language uses the language-tag production defined below.
</p>

<pre class="bnf">
`language-tag@p
	= &lt;Language-Tag, `5646/2.1$rfc&gt;
</pre>

<div class="p">
<p>
言語~tagは、
文字~hyphen（ "`-^c", `2D^X ）で互いに分離された，
1 個~以上の~subtag（文字大小無視）たちが成す連列である。
ほとんどの事例では、
言語~tagは，次の並びからなる：
◎
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of＼
</p>
<ol>
	<li>
関係する言語の~~広い族を識別する，首な言語~subtag（例： "`en^c" は英語）
◎
a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is＼
</li>
	<li>
前項の言語の範囲を［
精緻化する／~~狭める
］省略可能な一連の~subtag
（例： "`en-CA^c" は、
~Canadaで会話される英語の一方言）
◎
optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada).＼
</li>
</ol>

<p>
言語~tagの中では、
`空白$は許容されない。
◎
Whitespace is not allowed within a language tag.＼
</p>
</div>

<div class="example">
<p>
~tagの例：
◎
Example tags include:
</p>

<pre class="lang-http">
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</pre>
</div>

<p>
更なる情報は、
`RFC5646$r を見よ。
◎
See [RFC5646] for further information.
</p>

			</section>
		</section>
		<section id="field.content-length">
<h3>8.6. `Content-Length^h</h3>

<div class="p">
<p>
`Content-Length^h ~headerは、［
~messageに結付けられた`表現$を成す~data
］の長さを［
負でない~decimal整数による~octet数
］として指示する。
`Content-Length^h は：
◎
The "Content-Length" header field indicates the associated representation's data length as a decimal non-negative integer number of octets.＼
</p>
<ul>
	<li>
表現が`内容$として転送されるときは、
~frame法を区切るために利用できるよう
（例： `HTTP/1.1$r `Content-Length＠~HTTPv1#body.content-length§h ），
同封された~dataの量を特定的に指す。
◎
When transferring a representation as content, Content-Length refers specifically to the amount of data enclosed so that it can be used to delimit framing (e.g., Section 6.2 of [HTTP/1.1]).＼
</li>
	<li>
他の事例では、
`選定された表現$の現在の長さを指示する
— `受信者$は、［
転送~時間を見積もる／以前に格納した表現と比較する
］ときに，それを利用できる。
◎
In other cases, Content-Length indicates the selected representation's current length, which can be used by recipients to estimate transfer time or to compare with previously stored representations.
</li>
</ul>
</div>

<pre class="bnf">
`Content-Length@p
	= 1*`DIGIT$P
</pre>

<div class="example">
<p>
例：
◎
An example is
</p>

<pre class="lang-http">
Content-Length: 3495
</pre>
</div>

<p class="trans-note">【
構文としては、
先頭の 0 も許容されている
— 例えば "`011^c" を数として解釈するときは、
11 と見なすと見受けられる
（先頭の 0 の有無に応じて異なる数に解釈するような要件は、
この仕様には無い）。
】</p>

<div class="p">
<p>
`~UA$は：
◎
↓</p>
<ul>
	<li>
<p>
次に該当するときは、
要請~内に `Content-Length^h を送信するベキである
⇒
［
要請の`~method$は、
同封される`内容$用の意味を定義している
］かつ［
`Transfer-Encoding$h は送信していない
］
◎
A user agent SHOULD send Content-Length in a request when the method defines a meaning for enclosed content and it is not sending Transfer-Encoding.＼
</p>

<p>
例えば `POST$m 要請においては、
通常は， `Content-Length^h を送信することになる
— その値が 0 であっても
（値 0 は、
`内容$が空であることを指示する）。
◎
For example, a user agent normally sends Content-Length in a POST request even when the value is 0 (indicating empty content).＼
</p>
	</li>
	<li>
次に該当するときは、
要請~内に `Content-Length^h を送信するベキでない
⇒
［
要請は`内容$を包含しない
］かつ［
~method意味論からも そのような~dataは見越されない
］
◎
A user agent SHOULD NOT send a Content-Length header field when the request message does not contain content and the method semantics do not anticipate such data.
</li>
</ul>
</div>

<p>
`~server$は：
◎
↓</p>
<ul>
	<li>
［
`HEAD$m 要請に対する応答
］内に `Content-Length^h ~headerを送信してもヨイ
— 送信する場合、
その`~field値$は，次に等しい~decimal~~表現でなければナラナイ
⇒
同じ要請に `GET$m ~methodが利用されていたとするとき，応答の`内容$内に送信することになる~octet数
◎
A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.
</li>
	<li>
［
条件付き `GET$m 要請に対する `304$st 応答
］内に `Content-Length^h ~headerを送信してもヨイ
— 送信する場合、
`~field値$は，次に等しい~decimal~~表現でなければナラナイ
⇒
同じ要請に対し `200$st 応答を送信したとするとき，応答の`内容$内に送信することになる~octet数
◎
A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.
</li>
	<li>
次のいずれかに該当する応答~内には，
`Content-Length^h ~headerを送信してはナラナイ
⇒＃
`1xx$st 応答／
`204$st 応答／
`CONNECT$m 要請に対する `2xx$st 応答
◎
A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).
</li>
</ul>

<p>
上に定義された各 事例を除き、
`Transfer-Encoding$h が無い下では，
`生成元~server$は［
`~header節$の送信を完了するに先立って，`内容$の~sizeが既知なとき
］には，
`Content-Length^h ~headerを送信するベキである。
これは、
`下流$の各`受信者$に次を許容することになる
⇒＃
転送の進捗を測定する／
受信される~messageがいつ完了するかを知る／
追加的な要請~用に接続を後で再利用する
◎
Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.
</p>

<p>
`Content-Length^h に対する 0 以上のどの`~field値$も，妥当である。
［
`内容$の長さに対する定義済み制限
］は無いので、
`受信者$は，それを構文解析する際に［
~decimal数字列が巨大になり得ること／
整数~変換の桁溢れ／
整数~変換に因る精度~損失
］を見越して，それらによる~errorを防止しなければナラナイ（ `17.5§ ）。
◎
Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).
</p>

<p>
`Content-Length^h は、
~HTTP11においては~messageを区切るために利用されるので，その`~field値$は［
`下流$の`受信者$が，~messageを どう構文解析するか
］に影響iし得る
— 直近の接続が~HTTP11を利用していないときでも。
下流の ある`媒介者$が~messageを回送している下で、
受信した~messageにおいて
`Content-Length^h の~field値が その~frame法と整合でない場合，［
`要請~密入~攻撃$／`応答~分割~攻撃$
］に因る~securityの失敗をもたらすかもしれない。
◎
Because Content-Length is used for message delimitation in HTTP/1.1, its field value can impact how the message is parsed by downstream recipients even when the immediate connection is not using HTTP/1.1. If the message is forwarded by a downstream intermediary, a Content-Length field value that is inconsistent with the received message framing might cause a security failure due to request smuggling or response splitting.
</p>

<p>
よって，`送信者$は、［
受信した~messageに `Content-Length^h ~headerが在って，
その`~field値$が次のいずれかに該当する場合
］には，当の~messageを回送してはナラナイ
⇒＃
(A) 不正であることが既知である／
(B) 上の~ABNFに合致していない
◎
As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.
◎
Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above,＼
</p>

<p id="invalid-Content-Length">
ただし， (A) には該当しないが (B) に該当する場合、
次の例外がある
⇒
~field値が［
~commaで分離された~listとして，同じ~decimal値からなる
］場合には（例： `Content-Length: 42, 42^c ）、
`受信者$は，
当の~messageを妥当でないものとして却下しても,
その妥当でない~field値を 1 個の同じ~decimal値に置換してもヨイ
— そのような値は、
`上流$の~message処理器が `Content-Length^h ~headerを［
重複して`生成-$した／`結合-$した
］ことを指示しているので。
◎
with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, "Content-Length: 42, 42") MAY either＼
reject the message as invalid or＼
replace that invalid field value with a single instance of the decimal value,＼
since this likely indicates that a duplicate was generated or combined by an upstream message processor.
</p>

<p class="trans-note">【
`Content-Length^h は`~listに基づく~field$ではないが、
この場合に限り，許容され得る。
同じ数を表現する異なる値（ "`042^c" と "`42^c" など）でも，
同様になると思われる。
】</p>

		</section>
		<section id="field.content-location">
<h3>8.7. `Content-Location^h</h3>

<p>
`Content-Location^h ~headerは、［
この~messageの`内容$内の`表現$に対応する，特定の`資源$
］用の識別子として利用できる`~URI$を参照する。
言い換えれば、
この~messageの`生成-$時に，［
どこかから この~URIに向けて `GET$m 要請が遂行された
］ならば、
それに対する `200$st 応答は，［
この~message内の`内容$に同封されるものと同じ表現
］を包含することになろう。
◎
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's content. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as content in this message.
</p>

<pre class="bnf">
`Content-Location@p
	= `absolute-URI$p
	/ `partial-URI$p
</pre>

<p>
`~field値$は、
`absolute-URI$p か `partial-URI$p をとる。
後者の事例では、
参照先の~URIは，`~target~URI$に相対的になる（ `URI$r `5§uri ）。
◎
The field value is either an absolute-URI or a partial-URI. In the latter case (Section 4), the referenced URI is relative to the target URI ([URI], Section 5).
</p>

<p>
`Content-Location^h 値は、
`~target~URI$に代わるものではない。
それは、
`表現~metadata$である。
その構文と意味論は、［
~MIME本体 部分~用に定義される同じ名前の~header `2557/4$rfc
］と同じである。
しかしながら，~HTTP~messageにおける
`Content-Location^h の出現は、
~HTTP受信者にとっては，ある特別な含意がある。
◎
The Content-Location value is not a replacement for the target URI (Section 7.1). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in Section 4 of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
</p>

<p>
`Content-Location^h が `2xx$st 応答~message %応答 内に内包されたものである場合、
その`~field値$（を`絶対~形$へ変換した結果の値）が与える`~URI$ %~URI が：
◎
If Content-Location is included in a 2xx (Successful) response message and its value refers (after conversion to absolute form)＼
</p>

<dl class="switch">
	<dt>
`~target~URI$と同じ場合：
◎
to a URI that is the same as the target URI, then＼
</dt>
	<dd>
<p>
`受信者$は、
%応答 の`内容$を［
`~messageの出生日時$で指示される時点における，
その`資源$【~target~URIにより識別される資源】の現在の`表現$である
］と見なしてもヨイ。
これは、
%応答 が応対した要請の~methodが：
◎
the recipient MAY consider the content to be a current representation of that resource at the time indicated by the message origination date.＼
</p>
		<ul>
			<li>
［
`GET$m ／ `HEAD$m
］である場合、
その意味論は，［
`~server$により `Content-Location^h が供されなかったとき
］の既定の意味論と同じである。
◎
For a GET (Section 9.3.1) or HEAD (Section 9.3.2) request, this is the same as the default semantics when no Content-Location is provided by the server.＼
</li>
			<li>
`PUT$m や `POST$m など，状態変更~methodである場合、［
%応答 は，その`資源$の新たな`表現$を包含する
］ことを含意する
— それにより，［
動作についてのみを報告し得るような`表現$（例： “~~正常に~~処理されました。” ）
］との違いを判別できる。
これは、
著作~用の応用に［
後続な `GET$m 要請を伴わずに，自身の局所的な複製を更新する
］ことを許容する。
◎
For a state-changing request like PUT (Section 9.3.4) or POST (Section 9.3.3), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
</li>
		</ul>
	</dd>

	<dt>
`~target~URI$と相違する場合：
◎
If Content-Location is included in a 2xx (Successful) response message and its field value refers to a URI that differs from the target URI, then＼
</dt>
	<dd>
<p>
`生成元~server$は、［
%~URI は，同封された`表現$に対応する異なる`資源$用の識別子である
］ことを主張している。
そのような主張-を信用できるのは、［
両~識別子が同じ資源~所有者を共有する
］ときに限られる
— それは、
~HTTPを介しては~program的には決定できない。
これは：
◎
the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
</p>
		<ul>
			<li>
<p>
%応答 が応対した要請の~methodが［
`GET$m ／ `HEAD$m
］であるならば、
次の 2 つを指示する：
</p>
				<ul>
					<li>
`~target~URI$が指している`資源$は、
`内容~折衝$の~subjectである。
</li>
					<li>
%~URI は、
`選定された表現$用の，より特定な識別子である。
</li>
				</ul>
◎
For a response to a GET or HEAD request, this is an indication that the target URI refers to a resource that is subject to content negotiation and the Content-Location field value is a more specific identifier for the selected representation.
</li>
			<li>
%応答 は状態変更~methodに対する `201$st 応答であって，
%~URI は %応答 の `Location$h の`~field値$【を`絶対~形$に解決した結果の~URI】と一致するならば、
次を指示する
⇒
%応答 の`内容$は、
新たに作成された`資源$の現在の`表現$である。
◎
For a 201 (Created) response to a state-changing method, a Content-Location field value that is identical to the Location field value indicates that this content is a current representation of the newly created resource.
</li>
			<li>
<p>
他の場合、
次の 2 つを指示する：
◎
Otherwise, such a Content-Location indicates that＼
</p>

				<ul>
					<li>
%応答 の`内容$は、
要請された動作の状態sを報告している`表現$である。
◎
this content is a representation reporting on the requested action's status and that＼
</li>
					<li>
同じ報告が、
%~URI においても（ `GET$m による未来の~access用に）可用である。
◎
the same report is available (for future access with GET) at the given URI.＼
</li>
				</ul>
<p>
例えば，［
`POST$m 要請を介して為された購入~transaction
］は、［
`200$st 応答の`内容$
］として，領収書を内包することもある
— このときの %~URI は、
未来に同じ領収書の複製を検索取得するための識別子を供する。
◎
For example, a purchase transaction made via a POST request might include a receipt document as the content of the 200 (OK) response; the Content-Location field value provides an identifier for retrieving a copy of that same receipt in the future.
</p>
			</li>
		</ul>
	</dd>
</dl>

<p>
`Content-Location^h を要請~message内に送信する`~UA$は、
その値が［
同封された`表現$の内容を~UAが~~元々（当の~UAにより為された改変に先立って）得した所
］を指していることを言明している。
言い換えれば、
~UAは，［
元の表現の~sourceへ戻る~link
］を供している。
◎
A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
</p>

<div class="p">
<p>
要請~message内に `Content-Location^h ~fieldを受信した`生成元~server$は：
◎
An origin server that receives a Content-Location field in a request message＼
</p>
<ul>
	<li>
その情報を，~~一過性の要請~文脈として扱わなければナラナイ
— `表現$の一部として逐語的に保存されることになる~metadataとしてではなく。
◎
MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation.＼
</li>
	<li>
その文脈を，要請の処理を手引きするために利用しても, 他の利用~用に保存してもヨイ
— ~source~linkや~version法~metadataの中などに。
◎
An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata.＼
</li>
	<li>
しかしながら、
そのような文脈~情報を，当の要請の意味論を改めるために利用してはナラナイ。
◎
However, an origin server MUST NOT use such context information to alter the request semantics.
</li>
</ul>
</div>

<p>
例えば、
~clientが折衝された`資源$ %資源 に対し `PUT$m 要請 %要請 を為して，
生成元~serverが %要請 を（~redirectionを伴わずに）受容した場合、
%資源 の新たな状態は， %要請 内に給された一つの`表現$と整合するものと期待される。
`Content-Location^h は、［
折衝された表現のうち一つだけを更新する
］ための
“逆-内容~選定~識別子”
の形としては，利用できない
— ~UAがそのような意味論を求めていたなら、
`Content-Location^h の~URIに対し，直に `PUT$m を適用したであろう。
◎
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.
</p>

		</section>
		<section id="response.validator">
<h3 title="Validator Fields">8.8. 検証子~field</h3>

<p>
資源~metadataのうち，［
`条件付き要請$を為すために`事前条件$の中で利用され得るもの
］は、
`検証子@
（ `validator^en ）
と称される。
`検証子~field@†
は、
`選定された表現$用の現在の`検証子$を伝達する。
◎
Resource metadata is referred to as a "validator" if it can be used within a precondition (Section 13.1) to make a conditional request (Section 13). Validator fields convey a current validator for the selected representation (Section 3.2).
</p>

<p class="trans-note">【†
特に，この節にて定義される `ETag$h, `Last-Modified$h が該当するが、
それらに限定されてはいない。
】</p>

<p>
［
`安全$な要請に対する応答
］内の`検証子~field$は、［
応答の取扱い中に，`生成元~server$により選ばれ, `選定された表現$
］について述べる。
［
`~method$, `状態s~code$の意味論
］に依存して、［
所与の応答~用に`選定された表現$と当の応答の`内容$に同封された表現
］は，必ずしも同じになるとは限らないことに注意。
◎
In responses to safe requests, validator fields describe the selected representation chosen by the origin server while handling the response. Note that, depending on the method and status code semantics, the selected representation for a given response is not necessarily the same as the representation enclosed as response content.
</p>

<p>
［
状態変更 要請に対する成功裡な応答
］内の`検証子~field$は、［
その要請を処理した結果
］として，［［
それに先立って`選定された表現$
］を置換する，新たな`表現$
］について述べる。
◎
In a successful response to a state-changing request, validator fields describe the new representation that has replaced the prior selected representation as a result of processing the request.
</p>

<p>
例えば，［
`201$st 応答~内の `ETag$h ~field
］は、
“`更新喪失$” 問題を防止するため，［
新たに作成された資源の表現~用の`実体~tag$
］を通信して、
それを今後の`条件付き要請$内で`検証子$として利用できるようにする。
◎
For example, an ETag field in a 201 (Created) response communicates the entity tag of the newly created resource's representation, so that the entity tag can be used as a validator in later conditional requests to prevent the "lost update" problem.
</p>

<p>
この仕様は、［
`資源$の状態を観測する, および
`事前条件$を~testする
］ために共通的に利用される~metadataとして，
2 種の形
— `改変~日時$, `不透明$な`実体~tag$ —
を定義する。
`資源$の状態を反映する追加的な~metadataも，~HTTPの様々な拡張により定義されている
— この仕様の視野を超える `WEBDAV$r など。
◎
This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (Section 8.8.2) and opaque entity tags (Section 8.8.3). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning [WEBDAV], that are beyond the scope of this specification.
</p>

			<section id="weak.and.strong.validators">
<h4 title="Weak versus Strong">8.8.1. 弱い vs. 強い</h4>

<p>
検証子には、［
強いもの, 弱いもの
］がある。
`弱い検証子$は、
容易に生成できるが，
比較~~用途には あまり有用でない。
`強い検証子$は、
比較~~用途には理想的であるが，
効率的に生成することは とても困難にも（ときには不可能にも）なり得る。
~HTTPは、［
すべての形の`資源$が，同じ強さの検証子を固守する
］ことを課すのではなく，［
利用-中にある検証子の型を公開する
］こと, および［
`弱い検証子$を いつどこで`事前条件$に利用できるか
］についての制約を課す。
◎
Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.
</p>

<p>
`強い検証子@
（ `strong validator^en ）とは、［
`表現~data$が変化する度に値が変化する，`表現~metadata$
］であって，［
`GET$m 要請に対する `200$st 応答
］の`内容$にて観測-可能になるものである。
◎
A "strong validator" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the content of a 200 (OK) response to GET.
</p>

<p>
`強い検証子$は，`表現~data$の変化-以外の理由
— `表現~metadata$の意味論的に有意な部分（例： `Content-Type$h ）が変更されたなど —
から変化することもあるが、
`生成元~server$にとって~~最大の関心~事は，［［
~remote~cacheや著作~toolにより保持されている，格納-済み応答
］を無効化する必要がある
］ときに限り値を変更することである。
◎
A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., Content-Type), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.
</p>

<p>
~cache~entryは、
その失効~時機に関わらず，いつまでも持続し続けるかもしれない。
したがって~cacheは、［
~~遠い過去に得された検証子を利用している~entry
］を検証するよう試みることもある。
`強い検証子$は、［
ある特定の`資源$に結付けられた，すべての`表現$のすべての~version
］間で，時間~越しに一意になる。
しかしながら、［
互いに異なる資源
］の表現~間にわたる一意性については，含意されない
（すなわち、［
同じ`強い検証子$が，同~時に複数の資源の表現~用に利用-中にある
］かもしれないが，それらの表現が等価になることは含意しない）。
◎
Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).
</p>

<p>
実施においては、
種々の`強い検証子$が利用されている。
厳密な改訂~制御に基づくものが最良である
— 表現に対する各~変更に際して，［
表現が `GET$m から~access可能にされる前
］に，常に，一意な~node名と改訂~識別子がアテガわれるような。
［
`応答~header$が送信されるに先立って，~dataが可用である
］下では，耐衝突~hash関数を`表現~data$に適用して得られる~digestでも足り、
検証~要請が受信される度に計算し直す必要はない。
ただし，`資源$が［
~metadataにおいてのみ相違するような，別個な`表現$を有する
］場合には
（`内容~折衝$の対象になる`~MIME型$のうち複数のものが，同じ~data形式を共有するときに生じ得る）、
`生成元~server$は，［
それらの表現どうしを判別するための追加的な情報
］を検証子に組入れる必要がある。
◎
There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.
</p>

<div class="p">
<p>
対照的に，
`弱い検証子@
（ `weak validator^en ）は、
`表現~data$が変化しても変化しない場合もあるような，`表現~metadata$である。
この弱さは、
次のいずれかに因り得る：
◎
In contrast, a "weak validator" is representation metadata that might not change for every change to the representation data. This weakness might be due to＼
</p>
<ul>
	<li>
値が計算される方法における制限（例：`時計$の分解能）。
◎
limitations in how the value is calculated (e.g., clock resolution),＼
</li>
	<li>
`資源$にアリなすべての`表現$ 間での一意性を，確保できないとき。
◎
an inability to ensure uniqueness for all possible representations of the resource, or＼
</li>
	<li>
資源~所有者は、
`表現$ 間で一意な~data列ではなく，［
何らかの自己-決定される等価性に基づいて、
`表現$たちを いくつかの集合に~group化する
］よう欲しているとき。
◎
a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.
</li>
</ul>
</div>

<p>
`生成元~server$は、［
先立つ`表現$たちが現在の`表現$の代用として受容-可能でない
］と見なす度に，`弱い$`実体~tag$を変更するベキである。
言い換えれば、
~cacheの中の旧い応答を無効化するよう求める度に，変更する~OUGHT。
◎
An origin server SHOULD change a weak entity tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity tag ought to change whenever the origin server wants caches to invalidate old responses.
</p>

<p>
例えば，［
動的な測定に基づいて内容が秒単位で変化するような，気象情報の表現
］は、
同じ`弱い検証子$により，
（`生成元~server$から見て）等価な表現たちが成す集合に~group化されるかもしれない
— ~cache済み表現が、
（たぶん，~server負荷や天気の質に基づいて動的に調整されるような）適度な期間，
有効であり続けられるようにするために。
同様に、
表現の改変~時刻が秒単位の分解能で定義されていて，
その表現が 1 秒~間に 2 回~改変され，
それらの改変の合間に検索取得され得る場合には、
`弱い検証子$になることがある。
◎
For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.
</p>

<p>
同様に、
検証子は、
所与の`資源$の~~複数の`表現$間で同~時に共有されているならば，
`弱い$ものになる
— それらの`表現~data$が一致しない限り。
例えば，`生成元~server$が［
`gzip$c `内容~符号法$が適用された`表現$
］に対し［
内容~符号法を伴わない表現のときと同じ`検証子$
］を送信する場合、
それは`弱い検証子$になる。
しかしながら、
複数の`表現$が同じ`強い検証子$を同時に共有することもある
— 同じ`表現~data$に対し，複数の異なる`~MIME型$が可用であるときなど、
それらが`表現~metadata$においてのみ相違する場合には。
【！ https://www.rfc-editor.org/errata/eid5162】
◎
Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.
</p>

<p>
`強い検証子$は、
どの`条件付き要請$にも利用できる
— ［
`~cache検証$,
内容の`部分的$な範囲,
“`更新喪失$” 回避法
］も含め。
`弱い検証子$を利用できるのは、［
~clientが以前に得した`表現~data$との正確な同等性を要求しないとき
］に限られる
— ~cache~entryを検証するときや，近過去な変更に対しては、
~webの辿りを制限するときなど。
◎
Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.
</p>

			</section>
			<section id="field.last-modified">
<h4>8.8.2. `Last-Modified^h</h4>

<p>
応答~内の `Last-Modified$h ~headerは、
`生成元~server$が要請の取扱いから結論に至った，
`改変~日時@
— `選定された表現$が最後に改変された日付時刻 —
を指示する時刻印を供する。
◎
The "Last-Modified" header field in a response provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.
</p>

<pre class="bnf">
`Last-Modified@p
	= `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of its use is
</p>

<pre class="lang-http">
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre>
</div>

				<section id="lastmod.generation">
<h5 title="Generation">8.8.2.1. 生成</h5>

<p>
`生成元~server$は、［
`選定された表現$に対し，その最後の`改変~日時$を適度かつ一貫するように決定できる
］ならば，
`Last-Modified$h を送信するベキである
— ［
`条件付き要請$／`~cache鮮度$の評価
］における その利用は、
不必要な転送を相当に抑制し，~serviceの［
可用性, ~scale能
］を有意に改善するので。
◎
An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.
</p>

<p>
`表現$は、
概して，資源~interfaceの背後にある多数の~~部品の総和である。
最後に改変された時刻は、
通例的に，最も近過去な［
それらのうち，いずれかの~~部品が変化した時刻
］になる。
所与の`資源$に対し，そのような時刻を決定する方法は、
実装の詳細であり，この仕様の視野を超える。
◎
A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification.
</p>

<p>
`生成元~server$は：
◎
↓</p>
<ul>
	<li>
`表現$の `Last-Modified$h 値として［
自身が応答~用に `Date$h `~field値$を`生成-$する時刻
］にアリな限り近い値を得するベキである。
これは、
表現の改変~時刻を正確aに査定することを`受信者$に許容する
— とりわけ，表現が変化した時刻と応答が`生成-$された時刻が近い場合に。
◎
An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.
</li>
	<li>
`時計$を備えているならば、
`Last-Modified$h の値として［
~serverによる~message出生時の時刻（ `Date$h ）より後の日時
］を`生成-$してはナラナイ。
最後の改変~時刻が実装に特有な~metadataから導出されていて，それは［
生成元~serverの`時計$に則って，ある未来の時刻に評価される
］場合、
その値を~message出生時の日時に置換しなければナラナイ。
未来の`改変~日時$は、
`~cache検証$に~~悪影響があるので。
◎
An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.
</li>
	<li>
`時計$を備えていないならば、
応答~用の `Last-Modified$h 日時を`生成-$してはナラナイ
— ただし、
その日時~値が［
他の何らかの（大概は`時計$を備える）~systemにより，当の`資源$にアテガわれたもの
］である場合は除く。
◎
An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).
</li>
</ul>

				</section>
				<section id="lastmod.comparison">
<h5 title="Comparison">8.8.2.2. 比較</h5>

<p>
`Last-Modified$h 値が与える時刻 %V は，要請~内の検証子として利用されるときは、
次に挙げるいずれかの規則を利用して`強い検証子$であることが演繹できない限り，
暗黙的に`弱い検証子$になる
— 以下における %表現 は、
その検証子に結付けられた`表現$を指す：
◎
A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:
</p>
<dl class="switch">
	<dt>
`生成元~server$が、
%V を［
%表現 用の実際の現在の検証子
］と比較しているとき：
◎
The validator is being compared by an origin server to the actual current validator for the representation and,
</dt>
	<dd>
当の生成元~serverは、［
%表現 は、
%V が受持つ 1 秒の間は 2 回~変化しない
］ことを依拠-可能に知り得る。
◎
That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator;
</dd>

	<dt>
`~client$が、
%表現 用の~cache~entryを有しているので，
%V を［
`If-Modified-Since$h ／
`If-Unmodified-Since$h ／
`If-Range$h
］~header内に利用しつつあるとき：
◎
or
◎
The validator is about to be used by a client in an If-Modified-Since, If-Unmodified-Since, or If-Range header field, because the client has a cache entry for the associated representation, and
</dt>
	<dt>
媒介~cacheが、
検証子 %V を［
自身の~cache~entry内に格納-済みな %表現 用の検証子
］と比較しているとき：
◎
↓</dt>
	<dd>
<p>
［
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻
］を与える `Date$h 値 %Date を内包する
］~AND［
~OR↓ が満たされる
］：
</p>
		<ul>
			<li>
［
%Date は %V より 1 秒~以上後
］~AND［
当の［
~client／~cache
］には、［
%V と %Date は同じ時計により生成された
］ものと予見する理由がある
］。
</li>
			<li>
%Date と%V の間には、
時計~同期法の課題にはならないと見込まれるほどに，十分な相違がある。
</li>
		</ul>
◎
That cache entry includes a Date value which is at least one second after the Last-Modified value and the client has reason to believe that they were generated by the same clock or that there is enough difference between the Last-Modified and Date values to make clock synchronization issues unlikely;
◎
or
◎
The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and
◎
That cache entry includes a Date value which is at least one second after the Last-Modified value and the cache has reason to believe that they were generated by the same clock or that there is enough difference between the Last-Modified and Date values to make clock synchronization issues unlikely.
</dd>
</dl>

<p>
この演繹-法は、
次の事実に依拠する
⇒
同じ秒の間に 2 個の応答が`生成元~server$から送信されたが，
どちらも同じ `Last-Modified$h 時刻を有していた場合には、
少なくとも一方の応答は，
その `Last-Modified$h 時刻に等しい `Date$h 値を有することになる
◎
This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time.
</p>

				</section>
			</section>
			<section id="field.etag">
<h4>8.8.3. `ETag^h</h4>

<p>
応答~内の `ETag$h ~fieldは、
それが応対した要請の取扱いから結論に至った，［
`選定された表現$用の現在の`実体~tag$（ `entity-tag$p ）
］を供する。
`実体~tag@
（ `entity tag^en ）は、［
同じ`資源$からの複数の`表現$を相違化するための，`不透明$な検証子
］であり，
表現が複数あることが何に因るのか
— ［
`資源$の状態が時間~越しに変化したこと／
`内容~折衝$により同~時に複数の表現が妥当になったこと／
あるいはこの両者
］に因るのか —
は問わない。
`実体~tag$の主部は，引用符で括られた`不透明$な文字列（ `opaque-tag$p ）であり、
`弱い検証子$であるときは，それを指示する `weak$p も接頭される：
◎
The "ETag" field in a response provides the current entity tag for the selected representation, as determined at the conclusion of handling the request. An entity tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
</p>

<pre class="bnf">
`ETag@p
	= `entity-tag$p

`entity-tag@p
	= [ `weak$p ] `opaque-tag$p
`weak@p
	= ~Ps"W/"
`opaque-tag@p
	= `DQUOTE$P *`etagc$p `DQUOTE$P
`etagc@p
	= `21^X
	/ `23-7E^X
	/ `obs-text$p
	; <span class="comment">
`DQUOTE^P を除く `VCHAR^P, および `obs-text^p
◎
VCHAR except double quotes, plus obs-text
</span>
</pre>

<p class="note">注記：
`opaque-tag$p は、
以前は `quoted-string$p （ `2616/3.11$rfc ）として定義されていた。
そのため、
受信者の中には，~backslash~escapeを外そうとするものもある。
したがって，~serverは、
`実体~tag$内では~backslash文字を避ける~OUGHT。
◎
Note: Previously, opaque-tag was defined to be a quoted-string ([RFC2616], Section 3.11); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.
</p>

<div class="p">
<p>
次に挙げるいずれかの状況では、
`実体~tag$は，検証において`改変~日時$よりも依拠-可能になり得る：
◎
An entity tag can be more reliable for validation than a modification date in situations＼
</p>
<ul>
	<li>
`改変~日時$を格納しにくい不都合がある。
◎
where it is inconvenient to store modification dates,＼
</li>
	<li>
`HTTP-date$p 値の秒単位の分解能では足らない。
◎
where the one-second resolution of HTTP-date values is not sufficient, or＼
</li>
	<li>
`改変~日時$が一貫して保守されていない。
◎
where modification dates are not consistently maintained.
</li>
</ul>
</div>

<div class="example">
<p>
いくつかの例：
◎
Examples:
</p>

<pre class="lang-http">
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</pre>
</div>

<p>
`実体~tag$は、［
`弱い検証子$,
`強い検証子$（これが既定）
］どちらにもなり得る。
`表現$に`実体~tag$を供する`生成元~server$は、［
その代の`実体~tag$が，
`強い検証子$の特性~すべてを満足するものでない場合
］には、
`実体~tag$に `weak$p （ "`W/^c", 文字大小区別）を接頭して，
`弱い検証子$として~markしなければナラナイ。
◎
An entity tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all of the characteristics of a strong validator (Section 8.8.1), then the origin server MUST mark the entity tag as weak by prefixing its opaque value with "W/" (case-sensitive).
</p>

<p>
`送信者$は、
`ETag^h ~fieldを`~trailer節$内に送信してもヨイ
（ `6.5§ を見よ）。
しかしながら，`~trailer$は無視されることが多いので、
`ETag^h は
— `内容$の送信-中に`実体~tag$を`生成-$していない限り —
`~header$として送信する方が好ましい。
◎
A sender MAY send the ETag field in a trailer section (see Section 6.5). However, since trailers are often ignored, it is preferable to send ETag as a header field unless the entity tag is generated while sending the content.
</p>

				<section id="entity.tag.generation">
<h5 title="Generation">8.8.3.1. 生成</h5>

<div class="p">
<p>
`実体~tag$の背後にある原理は、
次の 2 点にある：
◎
The principle behind entity tags is that＼
</p>
<ul>
	<li>
`資源$用の検証の仕組みとして最も正確aかつ効率的なものを選定するために，資源の実装を十分良く知る者は、
当の~serviceの作者に限られる。
◎
only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that＼
</li>
	<li>
そのようなどの仕組みも、
比較を容易にするために，単純な~octet列に対応付けれる。
◎
any such mechanism can be mapped to a simple sequence of octets for easy comparison.＼
</li>
</ul>

<p>
値は
`不透明@
（ `opaque^en ）なので、
~clientは，各`実体~tag$がどう構築されたかを自覚する必要はない。
◎
Since the value is opaque, there is no need for the client to be aware of how each entity tag is constructed.
</p>
</div>

<p>
例えば、［
どの変化にも適用される，実装に特有な~version法
］を備える`資源$は、
内部~改訂~番号を利用するかもしれない
— たぶん、
互いの`表現$を正確aに相違化するため，`内容~折衝$用の変動~識別子と組合されるような。
［
表現~内容の耐衝突~hash ／
様々な~file属性の組合n ／
分解能が秒単位より細かい改変~時刻印
］を利用する実装もあり得る。
◎
For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.
</p>

<p>
`生成元~server$は、［
`選定された表現$に対し，その変化を適度かつ一貫して検出できる
【！detection of changes 〜 determined】
］ならば，
`ETag$h を送信するベキである
— `条件付き要請$における`実体~tag$の利用, および`~cache鮮度$の評価は、
不必要な転送を相当に抑制し，~serviceの［
可用性, ~scale能, 信頼性
］を有意に改善するので。
◎
An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.
</p>

				</section>
				<section id="entity.tag.comparison">
<h5 title="Comparison">8.8.3.2. 比較</h5>

<p>
`実体~tag$の比較には、
その文脈において`弱い検証子$の利用が許容されるかどうかに依存して，
次に挙げるいずれかの関数が用いられる：
◎
There are two entity tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:
</p>
<ul>
	<li>
`強い比較~関数@
（ `strong comparison^en ）
⇒
2 つの`実体~tag$は、
次を満たすならば，等価とされる
⇒
［
どちらも`弱い検証子$でない
］~AND［
互いの `opaque-tag$p は各~文字ごとに合致する
］
◎
"Strong comparison":
• two entity tags are equivalent if both are not weak and their opaque-tags match character-by-character.
</li>
	<li>
`弱い比較~関数@
（ `weak comparison^en ）
⇒
2 つの`実体~tag$は、
次を満たすならば，等価とされる
⇒
（`弱い$かどうかを問わず，）
互いの `opaque-tag$p は各~文字ごとに合致する
◎
"Weak comparison":
• two entity tags are equivalent if their opaque-tags match character-by-character, regardless of either or both being tagged as "weak".
</li>
</ul>

<p>
各種［
2 つの`実体~tag$
］例に対する，両~比較~関数の結果を下に示す:
◎
The example below shows the results for a set of entity tag pairs and both the weak and strong comparison function results:
</p>

<div >
<table><thead>
<tr><td>`ETag$p （ 1 個目）
<td>`ETag^p （ 2 個目）
<td>`強い比較~関数$
<td>`弱い比較~関数$
<tbody>

<tr><td>`W/"1"^c
<td>`W/"1"^c
<td>合致しない
<td>合致する

<tr><td>`W/"1"^c
<td>`W/"2"^c
<td>合致しない
<td>合致しない

<tr><td>`W/"1"^c
<td>`"1"^c
<td>合致しない
<td>合致する

<tr><td>`"1"^c
<td>`"1"^c
<td>合致する
<td>合致する
</table>
◎
Table 3
ETag 1 	ETag 2 	Strong Comparison 	Weak Comparison

W/"1" 	W/"1" 	no match 	match
W/"1" 	W/"2" 	no match 	no match
W/"1" 	"1" 	no match 	match
"1" 	"1" 	match 	match
</div>

				</section>
				<section id="example.entity.tag.vs.conneg">
<h5 title="Example: Entity Tags Varying on Content-Negotiated Resources">8.8.3.3. 内容~折衝された資源に応じて`実体~tag$が変わる例</h5>

<p>
`資源$が`内容~折衝$の~subjectであって，
`GET$m 要請に対する応答~内に送信される`表現$が
`Accept-Encoding$h 要請~headerに基づいて変わるときを考える。
◎
Consider a resource that is subject to content negotiation (Section 12), and where the representations sent in response to a GET request vary based on the Accept-Encoding request header field (Section 12.5.3):
</p>

<div class="example">
<p>
&gt;&gt; 要請：
◎
&gt;&gt; Request:
</p>

<pre class="lang-http">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip
</pre>

<p>
この事例では、
応答は `gzip$c `内容~符号法$を［
利用するとき, 利用しないとき
］があるとする。
利用しない場合の応答は、
次の様な~~形になる：
◎
In this case, the response might or might not use the gzip content coding. If it does not, the response might look like:
</p>

<p>
&gt;&gt; 応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</pre>

<p>
代替~表現が `gzip^c `内容~符号法$を利用するときは：
◎
An alternative representation that does use gzip content coding would be:
</p>

<p>
&gt;&gt;
応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

`…~binary~data…^com
</pre>
</div>

<p class="note">注記：
`内容~符号法$は`表現~data$の~propertyであり、
~cache更新や`範囲~要請$の間に競合が起きないようにするため、［
内容が符号化された`表現$,
されていない`表現$
］に対する`強い$`実体~tag$は，互いに別個なものになる。
対照的に，`転送~符号法$は、
~message転送の間に限り適用されるので，別個な`実体~tag$にはならない。
◎
Note: Content codings are a property of the representation data, so a strong entity tag for a content-encoded representation has to be distinct from the entity tag of an unencoded representation to prevent potential conflicts during cache updates and range requests. In contrast, transfer codings (Section 7 of [HTTP/1.1]) apply only during message transfer and do not result in distinct entity tags.
</p>

				</section>
			</section>
		</section>
	</section>
	<section id="methods">
<h2 title="Methods">9. ~method</h2>

		<section id="method.overview">
<h3 title="Overview">9.1. 概観</h3>

<p>
要請 `method$p ~tokenが、
要請の意味論の首な~sourceになる
— それは、
`~client$が［
当の要請を為した目的, および成功裡な結果として期待するもの
］を指示する。
◎
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
</p>

<p>
`要請~method$の意味論は、
要請~内に［
その~methodと競合しない意味論を追加する，何らかの~header
］が在るときには，更に特化され得る。
例えば，~clientは、
`条件付き要請~header$を送信して，［
`~target資源$の現在の状態に要請される動作
］を条件付きにすることができる。
◎
The request method's semantics might be further specialized by the semantics of some header fields when present in a request if those additional semantics do not conflict with the method. For example, a client can send conditional request header fields (Section 13.1) to make the requested action conditional on the current state of the target resource.
</p>

<p>
~HTTPは、
分散型の~obj~system用の~interfaceとして利用できるよう設計されている。
`要請~method$は、
`~target資源$に適用されることになる動作を呼出す
— 識別された~objへ~remote~method呼出nを送信できたときとほぼ同じ仕方で。
◎
HTTP is designed to be usable as an interface to distributed object systems. The request method invokes an action to be applied to a target resource in much the same way that a remote method invocation can be sent to an identified object.
</p>

<pre class="bnf">
`method@p
	= `token$p
</pre>
【！ Errata 4224 Rejected】

<p>
`method$p ~tokenは、
文字大小区別である
— ［
~method名が文字大小区別であるような，~objに基づく~system
］への~gatewayとしても，利用され得るので。
標準~化された~method名は、
慣行により，大文字のみからなる~US-ASCII英字で定義される。
◎
The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names. By convention, standardized methods are defined in all-uppercase US-ASCII letters.
</p>

<p>
分散型の~objと違って、
~HTTPにおける標準~化された`要請~method$は，`資源$に特有ではない
— ~networkに基づく~systemにおいては、
統一的な~interfaceの方が［
可視性, 再利用
］を良く供するので `REST$r 。
標準~化された~methodは、
いったん定義されたなら，
どの資源に適用されるときにも同じ意味論を備える~OUGHT
— それらの意味論を，自身に［
実装する／許容する
］かどうかは、
各~資源が決定するが。
◎
Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]. Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.
</p>

<p>
この仕様は、
~HTTPにおいて共通的に利用される，いくつかの標準~化された~methodを定義する。
それらは、
次の表tに要旨される：
◎
This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table.
◎
Table 4
Method Name 	Description 	Section
</p>

<table><thead>
<tr><th>~method名
<th>記述
<tbody>

<tr><td>`GET$m
<td>
`~target資源$の現在の`表現$を転送する。
◎
Transfer a current representation of the target resource. 	9.3.1

<tr><td>`HEAD$m
<td>
応答の`内容$は転送しないことを除いて，
`GET$m と同じ。
◎
Same as GET, but do not transfer the response content. 	9.3.2

<tr><td>`POST$m
<td>
要請の`内容$に対し，~target資源【！資源】に特有な処理を遂行する。
◎
Perform resource-specific processing on the request content. 	9.3.3

<tr><td>`PUT$m
<td>
~target資源の現在の表現~すべてを，要請の`内容$で置換する。
◎
Replace all current representations of the target resource with the request content. 	9.3.4

<tr><td>`DELETE$m
<td>
~target資源の現在の表現~すべてを，除去する。
◎
Remove all current representations of the target resource. 	9.3.5

<tr><td>`CONNECT$m
<td>
~target資源で識別される`~server$へ，`~tunnel$を確立する。
◎
Establish a tunnel to the server identified by the target resource. 	9.3.6

<tr><td>`OPTIONS$m
<td>
~target資源~用の通信~optionを述べる。
◎
Describe the communication options for the target resource. 	9.3.7

<tr><td>`TRACE$m
<td>
~target資源への経路に沿って~message~loop-back~testを遂行する。
◎
Perform a message loop-back test along the path to the target resource. 	9.3.8
</table>

<p>
すべての一般用`~server$は、
`GET$m および `HEAD$m を~supportしなければナラナイ。
他の~methodの~supportは、
どれも`任意選択^2119である。
◎
All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.
</p>

<div class="p">
<p>
`~target資源$に許容される~methodたちが成す集合は，
`Allow$h ~header内に~listできる／され得る。
加えて，その集合は、
【応答ごとに】
動的に変更できる／変化し得る。
◎
The set of methods allowed by a target resource can be listed in an Allow header field (Section 10.2.1). However, the set of allowed methods can change dynamically.＼
</p>

<p>
`生成元~server$は、
受信した`要請~method$を：
◎
＼
</p>
<ul>
	<li>
［
認識できない／実装していない
］ならば
⇒
`501$st で応答するベキである。
◎
An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.＼
</li>
	<li>
他の場合，~target資源には許容されないならば
⇒
`405$st で応答するベキである。
◎
An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.
</li>
</ul>
</div>

<p>
この仕様の視野から外れる追加的な~methodも、
~HTTPにおける利用~用に指定されている。
そのような~methodは、
すべて，`~HTTP~method~registry^citeの中に
— `16.1§ にて述べるとおりに —
登録される~OUGHT。
◎
Additional methods, outside the scope of this specification, have been specified for use in HTTP. All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry", as described in Section 16.1.
</p>

		</section>
		<section id="method.properties">
<h3 title="Common Method Properties">9.2. 共通な~method~property</h3>

			<section id="safe.methods">
<h4 title="Safe Methods">9.2.1. 安全な~method</h4>

<p>
`要請~method$は、［
それに定義される意味論が本質的に読専である
］とき，
`安全@
（ `safe^en ）であると見なされる
— すなわち，`~client$は、［
`安全$な~methodを`~target資源$に適用した結果
］として，`生成元~server$上の いかなる状態~変化も［
要請しない／期待しない
］。
同様に，［
`安全$な~methodの適度な利用
］は、
生成元~server上に，いかなる［
害／~propertyの損失／通例的でない負担
］も及ぼさないものと期待されている。
◎
Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.
</p>

<p>
この［
`安全$な~methodの定義
］は、
その呼出ngが［
有害にもなり得る ／
読専でない~~部分がある ／
副作用を及ぼす
］ような挙動を含まないことを実装に~~強いるものではない。
しかしながら，重要な点は、
`~client$は［
追加的な挙動を要請しないし, それについて~~関知できない
］ことにある。
例えば、
ほとんどの~serverは，［
~methodに関わらず，応答が完了するごとに要請~情報を~access~log~fileに付加する
］が、［
その~log~storageが満杯になり，~serverを失敗させ得る
］としても，`安全$と見なされる。
同様に，~Web広告を選定することにより起動される要請は、
`安全$であっても，広告料を課金するような副作用を伴うことが多い。
◎
This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and cause the server to fail. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.
</p>

<p>
この仕様が定義する`要請~method$のうち［
`GET$m ,
`HEAD$m ,
`OPTIONS$m ,
`TRACE$m
］は、
`安全$であるものと定義される。
◎
Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
</p>

<p>
~methodが`安全$か否かを判別する目的は、［
自動化された検索取得~処理n（~spider）／
~cache処理能の最適化（事前fetch）
］が，害を及ぼす心配なしに働くことを許容することにある。
加えて、
~UAが，信用できない~~可能性もある内容を処理する際に［
`安全$でない~methodが自動的に利用されないよう，適切な拘束を適用する
］ことも許容する。
◎
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.
</p>

<p>
`~UA$は、
~methodが`安全$か否かを判別して，［
`安全$でない動作は，要請される前に利用者が自覚できる
］よう［
~~行われ得る動作を利用者に呈示する
］ベキである。
◎
A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.
</p>

<p>
`資源$が［
`~target~URI$の中の~parameter群が動作を選定する効果を有する
］ように構築されているとき、［
その動作が`要請~method$の意味論に整合する
］ことを確保することは，資源~所有者の責務である。
例えば，~Webに基づく内容~編集~softwareが［
`query$p ~parameterの中で，
"`page?do=delete^c" などの動作を利用する
］ことは、
共通的にある。
そのような資源の目的が，安全でない動作を遂行することにある場合、
資源~所有者は，［
それが`安全$な要請~methodを利用して~accessされる
］ときには［
その動作を不能化するなどにより許容しない
］ようにしなければナラナイ。
さもなければ、［
~link保守, 事前fetch, 探索~indexを築く, 等々
］の~~目的で［
どの`~URI参照$に対しても，自動化された処理により `GET$m が遂行される
］ときに，~~望ましくない副作用が~~生じることになる。
◎
When a resource is constructed such that parameters within the target URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete". If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.
</p>

			</section>
			<section id="idempotent.methods">
<h4 title="Idempotent Methods">9.2.2. 冪等~method</h4>

<p>
`要請~method$は、［
複数回の［
互いに一致する，その~methodを伴う要請
］により意図される，`~server$に対する効果
］が［
一回の［
そのような要請
］による効果
］と同じになるとき，
`冪等@
（ `idempotent^en ）であると見なされる。
この仕様が定義する要請~methodのうち［
`PUT$m, `DELETE$m
］, および`安全$とされるものは、
冪等である。
【`安全$な要請~methodは、この仕様が定義しないものでも，定義により冪等になろう。】
◎
A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
</p>

<p>
`安全$の定義と同様に、
冪等性の定義が適用されるのは，［
利用者から何が要請されたか
］に限られる
— `~server$は、
各 冪等な要請に対し，次を行ってもかまわない
⇒＃
その~logを別にとる／
改訂~制御~用の履歴を維持する／
他の非~冪等な副作用を実装する
◎
Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.
</p>

<p>
冪等な~methodには、［
`~client$が`~server$の応答を読取n可能になる前に，通信が失敗した場合には、
要請を自動的に繰返せる
］という~~特徴がある。
例えば、
~clientが `PUT$m 要請を送信したとき，
応答が受信される前に下層の接続が~closeされた場合、
~clientは，新たな接続を確立して冪等な要請を再試行できる。
元の要請が成功していたとしても、
その要請を繰返した結果が
— 応答は相違するかもしれないが —
意図された効果と同じになることは，わかっているので。
◎
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.
</p>

<div class="p">
<p>
`~client$は、［
`冪等$でない~methodを伴う要請
］を自動的に再試行するベキではない
— ただし，何らかの手段により次のいずれかを行えるときは除く：
◎
A client SHOULD NOT automatically retry a request with a non-idempotent method unless it has＼
</p>
<ul>
	<li>
~methodに関わらず，要請の意味論が実際には`冪等$であることを知る。
◎
some means to know that the request semantics are actually idempotent, regardless of the method, or＼
</li>
	<li>
元の要請は決して【~target資源に】適用されていないことを検出する。
◎
some means to detect that the original request was never applied.
</li>
</ul>

<p>
例えば，`~UA$は、［
所与の`資源$に対する `POST$m 要請が`安全$である
］ことを（設計または環境設定を通して）知るならば，
その要請を自動的に繰返せる。
同様に，~version制御~repository上で運用するように特定的に設計された~UAは、
部分的な失敗~条件から，概ね次の流れで回復-可能になることもあろう：
◎
For example, a user agent can repeat a POST request automatically if it knows (through design or configuration) that the request is safe for that resource. Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by＼
</p>
<ol>
	<li>
接続が失敗した後に，`~target資源$の改訂履歴を検査する。
◎
checking the target resource revision(s) after a failed connection,＼
</li>
	<li>
部分的に適用された変更を復帰するなどにより修正する。
◎
reverting or fixing any changes that were partially applied,＼
</li>
	<li>
失敗した要請を自動的に再試行する。
◎
and then automatically retrying the requests that failed.
</li>
</ol>
</div>

<p>
一部の`~client$は、
自動的な再試行がアリなときに，より~riskが高い~approachで推測するよう試みる。
例えば，~clientは、
`POST$m 要請に対する応答を一部でも受信する前に，
下層の~transport接続が~closeされた場合には
— 特に，遊休中かつ持続的な接続が利用されているときは —
それを自動的に再試行するかもしれない。
◎
Some clients take a riskier approach and attempt to guess when an automatic retry is possible. For example, a client might automatically retry a POST request if the underlying transport connection closed before any part of a response is received, particularly if an idle persistent connection was used.
</p>

<p>
`~proxy$は、
冪等でない要請を自動的に再試行してはナラナイ。
`~client$は、［
失敗した自動的な再試行
］を自動的に再試行するベキでない。
◎
A proxy MUST NOT automatically retry non-idempotent requests. A client SHOULD NOT automatically retry a failed automatic retry.
</p>

			</section>
			<section id="cacheable.methods">
<h4 title="Methods and Caching">9.2.3. ~methodと~cache法</h4>

<p>
~cacheが応答を格納して利用するためには、
当の応答が応対した要請の~method【！the associated method】が~cachingを明示的に許容している必要があり，［
後続な要請を満足するために当の応答を利用できる条件
］についての詳細も必要になる
— ~method定義が許容していない場合、
~cacheできない。
追加的な要件については、
`CACHING$r を見よ。
◎
For a cache to store and use a response, the associated method needs to explicitly allow caching and to detail under what conditions a response can be used to satisfy subsequent requests; a method definition that does not do so cannot be cached. For additional requirements see [CACHING].
</p>

<p>
この仕様は、［
`GET$m, `HEAD$m, `POST$m 
］~method用に~cache法の意味論を定義する
— 大多数の~cache実装は、［
`GET$m, `HEAD$m
］しか~supportしていないが。
◎
This specification defines caching semantics for GET, HEAD, and POST, although the overwhelming majority of cache implementations only support GET and HEAD.
</p>

			</section>
		</section>
		<section id="method.definitions">
<h3 title="Method Definitions">9.3. ~method定義</h3>

			<section id="GET">
<h4>9.3.1. `GET^m</h4>

<p>
`GET^m ~methodは、
現在の［
`~target資源$用に`選定される表現$
］を転送するよう要請する。
成功裡な応答は、
`~target~URI$により識別される “同じさの質” を反映する
（ `URI$r `1.2.2§uri ）。
よって，~HTTPを介して識別-可能な情報を検索取得することは、
通例的に，ある識別子
— ［
その情報を `200$st 応答~内に供する~~可能性
］が結付けられた識別子 —
に対し `GET^m 要請を為すことにより遂行される。
◎
The GET method requests transfer of a current selected representation for the target resource. A successful response reflects the quality of "sameness" identified by the target URI (Section 1.2.2 of [URI]). Hence, retrieving identifiable information via HTTP is usually performed by making a GET request on an identifier associated with the potential for providing that information in a 200 (OK) response.
</p>

<p>
`GET^m は、
情報を検索取得する首な仕組みであり，
ほぼすべての処理能~最適化は そこに注力される。
重要な各~資源に対し，~URIを生産する応用は、［
そのような最適化による便益を得ながら，他の応用によるそれらの再利用-も可能化する
］ことで，~Webの更なる拡がりを促進する~network効果を発揮することになる。
◎
GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Applications that produce a URI for each important resource can benefit from those optimizations while enabling their reuse by other applications, creating a network effect that promotes further expansion of the Web.
</p>

<p>
資源~識別子は ~remote~file~systemの~pathnameで，
`表現$は そのような~file内容の複製であると、
~~考えられがちである。
事実、
多くの`資源$が実装されている方法でもある
（関係する~securityの考慮点については `17.3§ を見よ）。
しかしながら、
実施においては，そのような制限は無い。
◎
It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files. In fact, that is how many resources are implemented (see Section 17.3 for related security considerations). However, there are no such limitations in practice.
</p>

<p>
資源~用の~HTTP~interfaceは、
単に［
内容~objたちが成す~tree ／
様々な~database~record上の~program的な~view ／
他の情報~systemへの~gateway
］などとして実装される見込みも高い。
`~URI$を【資源へ】対応付ける仕組みが~file~systemに縛られているときでも、
`生成元~server$は
— ~fileを直に転送するのではなく —
［
要請を入力に~fileを実行して，その出力として表現を送信する
］よう環境設定されることもある。
いずれにせよ、［
各~資源~識別子が どの実装に対応するか
］や［
その実装が［
`~target資源$の現在の表現を選定して送信すること
］を どう管理するか
］を知る必要があるのは、
生成元~serverのみである。
◎
The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems. Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly. Regardless, only the origin server needs to know how each resource identifier corresponds to an implementation and how that implementation manages to select and send a current representation of the target resource.
</p>

<p>
`~client$は、
要請~内に `Range$h ~headerを送信することにより，
`GET^m の意味論を`範囲~要請$
— `選定された表現$を成すいくつかの部分に限り，転送を要請する要請 —
に改めることもできる。
◎
A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a Range header field in the request (Section 14.2).
</p>

<p>
要請~messageの~frame法は，利用される~methodとは独立であるが、
`GET^m 要請~内に受信される`内容$には、
一般に意味論は定義されず，要請の意味や~targetを改めることはない
— 加えて，`要請~密入~攻撃$ `HTTP/1.1$r のおそれがあるので、
一部の実装を［
要請を却下して接続を~closeする
］よう導くかもしれない。
`~client$は、
`GET^m 要請~内に`内容$を`生成-$するベキでない
— ただし、
それまでに［
そのような要請には目的があり，必要十分に~supportされることになる
］ものと帯域の［
内／外
］にて指示されていて，
当の要請が`生成元~server$へ向けて直に為される場合は除く。
`生成元~server$は、［
内容を受信する私的な合意
］があったとしても，それに依拠するベキでない
— ~HTTP通信における各~参加者は、
要請の`連鎖$沿いにある`媒介者$たちを自覚しないことが多いので。
◎
Although request message framing is independent of the method used, content received in a GET request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a GET request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.
</p>

<p>
`GET^m 要請に対する応答は、
`~cache可能$である
— `Cache-Control$h ~headerから他が指示されない限り、
後続な［
`GET^m ／ `HEAD$m
］要請を満足するためとして，その応答を~cacheに利用してもヨイ。
◎
The response to a GET request is cacheable; a cache MAY use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [CACHING]).
</p>

<p>
情報の検索取得が，利用者が供した情報から`~target~URI$を構築する仕組み
（例： `GET^m を利用している~formの~query~field【`参照＠~HTMLforms#concept-fs-action$】など）
で遂行されるとき、［
~URIの中に開示するには適切にならない，敏感になり得る~data
］が供されるかもしれない（ `17.9§ を見よ）。
一部の事例では、
そのような情報を露呈しないよう，当の~dataを［
~filter／形式変換
］できる。
他の事例
— 特に，応答を~cacheしても便益は無いとき —
においては、
`GET^m に代えて `POST$m ~methodを利用すれば，
そのような情報は
— `~target~URI$の中ではなく —
要請の`内容$内に伝送できる。
◎
When information retrieval is performed with a mechanism that constructs a target URI from user-provided information, such as the query fields of a form using GET, potentially sensitive data might be provided that would not be appropriate for disclosure within a URI (see Section 17.9). In some cases, the data can be filtered or transformed such that it would not reveal such information. In others, particularly when there is no benefit from caching a response, using the POST method (Section 9.3.3) instead of GET can transmit such information in the request content rather than within the target URI.
</p>

			</section>
			<section id="HEAD">
<h4>9.3.2. `HEAD^m</h4>

<p>
`HEAD^m ~methodは、［
`~server$は、
対する応答~内に`内容$を送信してはナラナイ
］ことを除いて，
`GET$m に一致する。
`HEAD^m は、
`選定された表現$について［
その`表現~data$を転送することなく，その~metadataを得する
］ために利用される。
それは、［
~hypertext~linkを~testする／近過去な改変を見出す
］~~目的で利用されることが多い
◎
The HEAD method is identical to GET except that the server MUST NOT send content in the response. HEAD is used to obtain metadata about the selected representation without transferring its representation data, often for the sake of testing hypertext links or finding recent modifications.
</p>

<p>
`~server$は、
`HEAD^m 要請に対する応答~内に，［
要請~methodが `GET$m であったときに送信することになる~headerたち
］と同じ~headerたちを送信するベキである
— ただし，~headerのうち［
`内容$を`生成-$する間に限り，その値が決定されるもの
］は、
省略してもヨイ。
例えば，一部の~serverは、
`GET^m に対する動的な応答を［
小さな応答をより効率的に区切る／内容~選定に関する裁定を後で下す
］ために必要な最小~量な~dataが`生成-$されるまで，~bufferする。
`GET^m に対するそのような応答は、
`HEAD^m に対する応答の中には`生成-$されない~field
— 例えば `Content-Length$h や `Vary$h —
を包含するかもしれない。
`HEAD^h 要請~用には、
これらの細かな不整合は，【~field値を得るために】`内容$を`生成-$して破棄するより好ましいと見なされる
— `HEAD^m は、
通例的に，効率の~~目的で要請されるので。
◎
The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET. However, a server MAY omit header fields for which a value is determined only while generating the content. For example, some servers buffer a dynamic response to GET until a minimum amount of data is generated so that they can more efficiently delimit small responses or make late decisions with regard to content selection. Such a response to GET might contain Content-Length and Vary fields, for example, that are not generated within a HEAD response. These minor inconsistencies are considered preferable to generating and discarding the content for a HEAD request, since HEAD is usually requested for the sake of efficiency.
</p>

<p>
要請~messageの~frame法は，利用される~methodとは独立ではあるが、
`HEAD^m 要請~内に受信される`内容$には、
一般に意味論は定義されず，要請の意味や~targetを改めることはない
— 加えて，`要請~密入~攻撃$ `HTTP/1.1$r のおそれがあるので、
一部の実装を［
要請を却下して接続を~closeする
］よう導くかもしれない。
`~client$は、
`HEAD^m 要請~内に`内容$を`生成-$するベキでない
— ただし、
それまでに［
そのような要請には目的があり，必要十分に~supportされることになる
］ものと帯域の［
内／外
］にて指示されていて，`生成元~server$へ向けて直に為される場合は除く。
`生成元~server$は、［
内容を受信する私的な合意
］があったとしても，それに依拠するベキでない
— ~HTTP通信における参加者は、
要請の`連鎖$沿いにある`媒介者$を自覚しないことが多いので。
◎
Although request message framing is independent of the method used, content received in a HEAD request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a HEAD request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.
</p>

<p>
`HEAD^m 要請に対する応答は、
`~cache可能$である
— `Cache-Control$h ~headerから他が指示されない限り、
後続な `HEAD^m 要請を満足するためとして，その応答を~cacheに利用してもヨイ。
そのような応答は、［
以前に~cacheされた `GET$m に対する応答
］にも影響するかもしれない
— `CACHING$r `4.3.5＠~HTTPcache#head.effects§ を見よ。
◎
The response to a HEAD request is cacheable; a cache MAY use it to satisfy subsequent HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [CACHING]). A HEAD response might also affect previously cached responses to GET; see Section 4.3.5 of [CACHING].
</p>

			</section>
			<section id="POST">
<h4>9.3.3. `POST^m</h4>

<p>
`POST^m ~methodは、
`~target資源$が［
自前の特有な意味論に則って，要請~内に同封された`表現$を処理する
］よう要請する。
この~methodは、
例えば，次に挙げる機能に利用される（他にもある）：
◎
The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others):
</p>
<ul>
	<li>
一群の~data
— ~HTML~formに手入力された一連の~fieldなど —
が成す~blockを，~data取扱い処理nに供する。
◎
Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;
</li>
	<li>
［
掲示板,
ニュースグループ,
メーリングリスト,
ブログ,
その他~類似な記事~群など
］へ，~messageを投函する。
◎
Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;
</li>
	<li>
`生成元~server$からは まだ識別されていない，新たな`資源$を作成する。
◎
Creating a new resource that has yet to be identified by the origin server; and
</li>
	<li>
既存の`資源$の`表現$（たち）に~dataを付加する。
◎
Appending data to a resource's existing representation(s).
</li>
</ul>

<p>
`生成元~server$は、［
`POST^m 要請の処理~結果に依存して，適切な`状態s~code$を選ぶ
］ことにより，応答の意味論を指示する
— `POST^m に対する応答~内には、
この仕様が定義する ほぼすべての状態s~codeが受信され得る
（例外は： `206$st, `304$st, `416$st ）。
◎
An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification could be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)).
</p>

<div class="p">
<p>
`POST^m 要請が成功裡に処理された結果，
`生成元~server$上で 1 個以上の`資源$が作成された場合、
生成元~serverは，次を包含する `201$st 応答を送信するベキである：
◎
If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing＼
</p>
<ul>
	<li>
作成された`首な資源$用の識別子を供する `Location$h ~header
◎
a Location header field that provides an identifier for the primary resource created (Section 10.2.2) and＼
</li>
	<li>
新たな資源（たち）を指しつつ, 要請の状態sも述べるような，`表現$
◎
a representation that describes the status of the request while referring to the new resource(s).
</li>
</ul>
</div>

<div class="p">
<p>
`POST^m 要請に対する応答が`~cache可能$になるのは、
それが［
明示的な`鮮度~情報$
］および［
当の要請の`~target~URI$と同じ値をとる `Content-Location$h ~header
］を内包するときに限られる。
~cacheされた `POST^m 応答は：
◎
Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [CACHING]) and a Content-Location header field that has the same value as the POST's target URI (Section 8.7).＼
</p>
<ul>
	<li>
今後の［
`GET$m ／ `HEAD$m
］要請を満足するために再利用できる。
◎
A cached POST response can be reused to satisfy a later GET or HEAD request.＼
</li>
	<li>
今後の `POST^m 要請を満足するために再利用することはできない
— `POST^m は`安全$でない~~可能性もあるので。
`CACHING$r
`~cacheからの応答の構築-法＠~HTTPcache#constructing.responses.from.caches§
【`格納-済み応答の無効化-法＠~HTTPcache#invalidation§？】
を見よ。
◎
In contrast, a POST request cannot be satisfied by a cached POST response because POST is potentially unsafe; see Section 4 of [CACHING].
</li>
</ul>
</div>

<p>
`POST^m の処理~結果が既存の`資源$の`表現$と等価になる場合、
`生成元~server$は、
`303$st 応答を
— その `Location$h ~header【！~field】内に当の資源の識別子を伴わせた上で —
送信することにより，
`~UA$を~redirectしてもヨイ。
これには便益がある：
~UAに資源~識別子を供して，より［
`共用~cache$に受け入れられ易い~method
］を介して［
当の`表現$を転送させる
］ような
— ~UAが~cache済み表現をまだ有していない場合、
余分な要請~costがかかるが。
◎
If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.
</p>

			</section>
			<section id="PUT">
<h4>9.3.4. `PUT^m</h4>

<div class="p">
<p>
`PUT^m ~methodは、
次を要請する
⇒
`~target資源$の状態を，［
要請~messageの`内容$内に同封された`表現$
］により定義される状態として作成する, あるいは その状態に置換する。
◎
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message content.＼
</p>

<p>
所与の`表現$に対する成功裡な `PUT^m 要請は、［
同じ`~target資源$に対する後続な `GET$m の結果は、
対する `200$st 応答~内に送信される表現と等価になる
］ことを示唆する。
しかしながら，［
そのような状態~変化が観測-可能になる
］ことは保証されない
— 当の~target資源は、［
後続な `GET$m が受信される前に，並列的な他の`~UA$により動作される
］ことも［
`生成元~server$による動的~処理の~subjectになる
］こともあるので。
成功裡な応答は、
その処理~時点で［
~UAの意図は，生成元~serverにより達成された
］ことのみを含意する。
◎
A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
</p>
</div>

<p>
`生成元~server$には、
以下の要件が課される
— 以下、
`PUT^m された`表現$を %P と記す：
◎
↓</p>
<ul>
	<li>
<p>
`~target資源$用の現在の`表現$が：
◎
↓</p>
		<ul class="switch">
			<li>
無い場合
⇒
`PUT^m が何か一つを成功裡に作成したときは、
`201$st 応答を`~UA$に送信して，その旨を伝えなければナラナイ。
◎
If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response.＼
</li>
			<li>
在る場合
⇒
その表現が %P の状態に則って成功裡に改変されたときは、
`200$st または `204$st 応答を送信して，要請の成功裡な完了を指示しなければナラナイ。
◎
If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.
</li>
		</ul>
	</li>
	<li>

<div class="p">
<p>
`~target資源$用に環境設定されたどの拘束にも，
%P が整合することを検証yするベキである。
例えば，`生成元~server$は、
資源の`表現~metadata$を~URIに基づいて決定する場合には，［
成功裡な `PUT^m 要請~内に受信した内容が，その~metadataと整合する
］ことを確保する必要がある。
◎
An origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource. For example, if an origin server determines a resource's representation metadata based on the URI, then the origin server needs to ensure that the content received in a successful PUT request is consistent with that metadata.＼
</p>

<p>
%P が~target資源と整合でないときは、
次のいずれかを行うベキである：
◎
When a PUT representation is inconsistent with the target resource, the origin server SHOULD either＼
</p>
		<ul>
			<li>
［
%P を形式変換するか, 資源についての環境設定を変更する
］ことにより，それらを整合させる。
◎
make them consistent, by transforming the representation or changing the resource configuration, or＼
</li>
			<li>
［
何故 %P が相応でないかを説明するに足る情報
］を包含する，適切な~error~messageで応答する。
それが `Content-Type$h 値に対する拘束に特有であるときは、［
`409$st ／ `415$st
］が示唆される。
◎
respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.
</li>
		</ul>
</div>

<div class="example">
<p>
例えば，［
`~target資源$における `Content-Type$h は常に "`text/html^c" になる
］ように環境設定されていて, ［
%P における `Content-Type$h は "`image/jpeg^c" になる
］場合、
次のいずれかを行う~OUGHT：
◎
For example, if the target resource is configured to always have a Content-Type of "text/html" and the representation being PUT has a Content-Type of "image/jpeg", the origin server ought to do one of:
</p>
		<ul>
			<li>
~target資源が新たな`~MIME型$を反映するよう，環境設定し直す。
◎
reconfigure the target resource to reflect the new media type;
</li>
			<li>
%P を新たな資源~状態として保存する前に、
%P の形式が資源の形式と整合するよう，
%P を形式変換する。
◎
transform the PUT representation to a format consistent with that of the resource before saving it as the new resource state; or,
</li>
			<li>
要請に対し、［
~target資源が "`text/html^c" に制限されていることを指示する， `415$st 応答
］で却下する
— たぶん［
新たな`表現$に相応しい~targetになる，異なる資源への~link
］を内包するような。
◎
reject the request with a 415 (Unsupported Media Type) response indicating that the target resource is limited to "text/html", perhaps including a link to a different resource that would be a suitable target for the new representation.
</li>
		</ul>
</div>
	</li>
</ul>

<div class="p">
<p>
~HTTPは、
次に挙げるものは定義しない：
◎
HTTP does not define＼
</p>
<ul>
	<li>
`PUT^m ~methodが`生成元~server$の状態に正確にどう影響するかについて
— ［
~UAによる要請の意図／生成元~serverによる応答の意味論
］により表出し得るものを超えるような。
◎
exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and the semantics of the origin server response.＼
</li>
	<li>
資源が何になり得るかについて
— ［
~HTTPを介して供される~interface
］を超えるような，その言葉が表すいかなるイミにおいても。
◎
It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP.＼
</li>
	<li>
資源~状態がどう “格納される” か。
◎
It does not define how resource state is "stored", nor＼
</li>
	<li>
資源~状態が変化した結果，そのような~storageがどう変化し得るか。
◎
how such storage might change as a result of a change in resource state, nor＼
</li>
	<li>
生成元~serverが，資源~状態をどう`表現$に翻訳するか。
◎
how the origin server translates resource state into representations.＼
</li>
</ul>

<p>
一般に、［
資源~interfaceの背後にある，実装の詳細
］すべては，`~server$により意図的に隠される。
◎
Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.
</p>
</div>

<p>
このことは、
各`~field$（~header／~trailer）がどう格納されるかにも及ぶ。
`Content-Type$h の様な共通な~headerは、
概して格納され，後続な `GET$m 要請に際して返されることになるが、
各~fieldの取扱いは，当の要請を受信した資源に特有である。
その結果として、
`生成元~server$は，［
`PUT$m 要請~内に受信した~fieldのうち，自身が認識しないもの
］を無視するベキである
（すなわち，それらを当の資源~状態の一部として保存しない）。
◎
This extends to how header and trailer fields are stored; while common header fields like Content-Type will typically be stored and returned upon subsequent GET requests, header and trailer field handling is specific to the resource that received the request. As a result, an origin server SHOULD ignore unrecognized header and trailer fields received in a PUT request (i.e., not save them as part of the resource state).
</p>

<div class="p">
<p>
`生成元~server$は、
~AND↓ が満たされない限り，［
`PUT^m に対する成功裡な応答
］内に`検証子~field$
— `ETag$h や `Last-Modified$h など —
を送信してはナラナイ：
◎
An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless＼
</p>
<ul>
	<li>
要請の`表現~data$は、
`内容$にいかなる形式変換も適用されずに，保存された
（すなわち，資源の新たな表現~dataは、
`PUT^m 要請~内に受信された`内容$と一致する）。
◎
the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and＼
</li>
	<li>
`検証子$を成す`~field値$は、
新たな`表現$を反映している。
◎
the validator field value reflects the new representation.＼
</li>
</ul>

<p>
この要件により，`~UA$は、
自身が送信した（~memory内に有する）表現が `PUT^m の結果に一致するのは
— したがって，生成元~serverから再び検索取得する必要がないのは —
いつなのか，知れるようになる。
応答~内に受信した新たな`検証子$（たち）は、
偶発的な上書-を防止するためとして，未来の`条件付き要請$に利用できる。
◎
This requirement allows a user agent to know when the representation it sent (and retains in memory) is the result of the PUT, and thus it doesn't need to be retrieved again from the origin server. The new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 13.1).
</p>
</div>

<div class="p">
<p>
`POST$m と `PUT^m の間の根本的な相違は、
同封された`表現$の意図が異なることにある：
◎
The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation.＼
</p>
<ul>
	<li>
`POST$m 要請には、［
`~target資源$が，自前の意味論に則って同封された表現を取扱う
］ことが意図される。
◎
The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas＼
</li>
	<li>
`PUT^m 要請は、［
同封された表現が，~target資源の状態を置換する
］ものとして定義される。
◎
the enclosed representation in a PUT request is defined as replacing the state of the target resource.＼
</li>
</ul>

<p>
よって，`PUT^m の意図は
— その正確な効果を知るのは`生成元~server$のみであっても —
`冪等$であり，`媒介者$から可視になる。
◎
Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.
</p>
</div>

<p>
`PUT^m 要請を適正に解釈するためには、［
~UAが，どの`~target資源$が【利用者から】欲されているか知っている
］ことが前提になる。
［
~clientに利するために、
状態変更 要請を受信した後，適正な`~URI$を選定する~service
］は、
`PUT^m ではなく， `POST$m ~methodを利用して実装するベキである。
`生成元~server$は、
要請された `PUT^m を
— それにより`~target資源$の状態を変更することなく —
異なる資源に適用するよう望む場合には
（例：当の資源は異なる~URIへ移動されたなど），
適切な `3xx$st 応答を送信しなければナラナイ。
また，`~UA$は、
要請を~redirectするかどうかに関して，自前の裁定を下してもヨイ。
◎
Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.
</p>

<p>
`~target資源$に適用される `PUT^m 要請は、
他の`資源$に副作用を及ぼし得る。
例えば，ある記事は、
“各~version” 
（ある時点で他のいずれかの~versionと同じ状態を共有する，互いに異なる資源）
を識別するために，別々な`~URI$を有するかもしれない。
したがって， “現在の~version” の~URIに対する成功裡な `PUT^m 要請は、
~target資源の状態を変更することに加え，［
新たな~versionの資源を作成したり、
更には，関係する資源~間の~linkを追加する
］こともある。
◎
A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying "the current version" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on "the current version" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.
</p>

<p>
一部の`生成元~server$は、
部分的な `PUT$m （ `14.5§ ）を遂行するためとして，
［
`Content-Range$h ~headerを
`PUT$m 要請に対する改変子として利用する
］ことを~supportする。
◎
Some origin servers support use of the Content-Range header field (Section 14.4) as a request modifier to perform a partial PUT, as described in Section 14.5.
</p>

<p>
`PUT^m ~methodに対する応答は、
`~cache可能$でない。
成功裡な `PUT^m 要請が~cacheを通過した場合、
その~cacheに格納-済みな`~target~URI$用の応答は，
（もし在れば）すべて`無効化-$されることになる。
◎
Responses to the PUT method are not cacheable. If a successful PUT request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [CACHING]).
</p>

			</section>
			<section id="DELETE">
<h4>9.3.5. `DELETE^m</h4>

<p>
`DELETE^m ~methodは、［
`~target資源$と，その現在の機能性との間の結付け
］を除去してもらうよう，`生成元~server$に要請する。
この~methodは，その効果においては UNIX の "rm" ~commandに類似するが、［
以前に結付けられた情報が削除される
］という期待ではなく，［
生成元~serverによる~URI対応付けにおける削除~演算
］を表出する。
◎
The DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the "rm" command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.
</p>

<p>
`~target資源$に それ用の現在の`表現$が 1 個以上ある場合に，［
それらが`生成元~server$により破壊される／
それらに結付けられた~storageが取戻される
］かどうかは、
その`資源$の［
資質, 生成元~serverによる実装（この仕様の視野を超える）
］に全面的に依存する。
同様に、
`DELETE^m の結果として，［
~databaseや~gateway接続など，資源の他の実装~側面
］が［
非作動化される／~archiveされる
］必要が~~生じることもある。
一般に，生成元~serverが `DELETE^m を許容する`資源$は、［
削除を成遂げる仕組みが制定されたもの
］に限られると見做されている。
◎
If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification). Likewise, other implementation aspects of a resource might need to be deactivated or archived as a result of a DELETE, such as database or gateway connections. In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion.
</p>

<p>
`DELETE^m ~methodを許容する`資源$は、
相対的に少数である
— それは首に、［
利用者が，その効果に関して指令する
］ような，~remote著作~用の環境に利用される。
例えば，［
`PUT$m 要請を利用して，以前に作成された資源
］や［
`POST$m 要請に対する`201$st 応答の `Location$h ~headerを介して識別される資源
］は、［
それらの動作を~~元に戻すような，対応する `DELETE^m 要請
］を許容することもある。
類似に，著作~機能を実装する~customな~UA実装
— ~remoteで運用するために，~HTTP利用して改訂を制御する~clientなど —
は、［
~serverの~URI空間は、
~version~repositoryに対応するよう加工-済みである前提
］に基づいて， `DELETE^m を利用できることもある。
◎
Relatively few resources allow the DELETE method -- its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the Location header field after a 201 (Created) response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.
</p>

<div class="p">
<p>
`DELETE^m ~methodが成功裡に適用された場合、
`生成元~server$は、
動作~~状況に応じて，次のいずれかの状態s~codeを送信するベキである：
◎
If a DELETE method is successfully applied, the origin server SHOULD send
</p>
<ul class="switch">
	<li>
動作は成功する見込みが高いが、
まだ~~実行済みでない場合
⇒
`202$st
◎
a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted,
</li>
	<li>
動作は実行済みで、
更なる情報は給されない場合
⇒
`204$st
◎
a 204 (No Content) status code if the action has been enacted and no further information is to be supplied, or
</li>
	<li>
動作は実行済みで、
応答~messageが［
その状態sを述べる`表現$
］を内包する場合
⇒
`200$st
◎
a 200 (OK) status code if the action has been enacted and the response message includes a representation describing the status.
</li>
</ul>
</div>

<p>
要請~messageの~frame法は，利用される~methodとは独立ではあるが、
`DELETE^m 要請~内に受信される`内容$には、
一般に意味論は定義されず，要請の意味や~targetを改めることはない
— 加えて，`要請~密入~攻撃$ `HTTP/1.1$r のおそれがあるので、
一部の実装を［
要請を却下して接続を~closeする
］よう導くかもしれない。
`~client$は、
`DELETE^m 要請~内に`内容$を`生成-$するベキでない
— ただし、
それまでに［
そのような要請には目的があり，必要十分に~supportされることになる
］ものと帯域の［
内／外
］にて指示されていて，`生成元~server$へ向けて直に為される場合は除く。
`生成元~server$は、［
内容を受信する私的な合意
］があったとしても，それに依拠するベキでない
— ~HTTP通信における参加者は、
要請の`連鎖$沿いにある`媒介者$を自覚しないことが多いので。
◎
Although request message framing is independent of the method used, content received in a DELETE request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a DELETE request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.
</p>

<p>
`DELETE^m ~methodに対する応答は、
`~cache可能$でない。
成功裡な `DELETE^m 要請が~cacheを通過した場合、
その~cacheに格納-済みな`~target~URI$用の応答は（もし在れば），
すべて`無効化-$されることになる。
◎
Responses to the DELETE method are not cacheable. If a successful DELETE request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [CACHING]).
</p>

			</section>
			<section id="CONNECT">
<h4>9.3.6. `CONNECT^m</h4>

<div class="p">
<p>
`CONNECT^m ~methodは、
次を`受信者$に要請する：
◎
The CONNECT method requests that＼
</p>
<ol>
	<li>
［
`要請~target$により識別される`生成元~server$
］を行先とする`~tunnel$を確立する。
◎
the recipient establish a tunnel to the destination origin server identified by the request target and,＼
</li>
	<li>
前項に成功したならば、
当の~tunnelが~closeされるまで，受信者の挙動を
— 両~方向とも —
~dataの盲目的な回送に制約する。
◎
if successful, thereafter restrict its behavior to blind forwarding of data, in both directions, until the tunnel is closed.＼
</li>
</ol>

<p>
~tunnelは、［
1 個以上の`~proxy$を通して，端点間の仮想~接続を作成する
］ときに共通的に利用される
— そうすれば、
~TLS（ `Transport Layer Security^en, `TLS13$r ）を利用して`~secure化$できるようになる。
◎
Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [TLS13]).
</p>
</div>

<p>
`CONNECT^h は、
`要請~target$に特別な形を利用する
— それは，この~methodに~~固有であり、
`~tunnel$の行先を成す，~colonで分離された［
~host名と~port番号
］のみからなる。
既定の~portは無いので、
`~client$は，~port番号を送信しなければナラナイ
— `CONNECT^h 要請が［
`authority$p 成分を包含していて，~portが省かれた`~URI参照$
］に基づく場合でも。
◎
CONNECT uses a special form of request target, unique to this method, consisting of only the host and port number of the tunnel destination, separated by a colon. There is no default port; a client MUST send the port number even if the CONNECT request is based on a URI reference that contains an authority component with an elided port (Section 4.1).＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com
</pre>
</div>

<p>
`~server$は、
空または妥当でない~port番号を~targetにしている `CONNECT^m 要請に対しては
— 概して， `400$st で応答することにより —
却下しなければナラナイ。
◎
A server MUST reject a CONNECT request that targets an empty or invalid port number, typically by responding with a 400 (Bad Request) status code.
</p>

<p>
`CONNECT^h は，~HTTP接続の［
要請／応答
］に関する資質を変更するので、
その意味論を~protocolの伝送路~形式へ対応付ける仕方は，
特定の~HTTP~versionごとに異なるかもれない。
◎
Because CONNECT changes the request/response nature of an HTTP connection, specific HTTP versions might have different ways of mapping its semantics into the protocol's wire format.
</p>

<p>
`CONNECT^m の利用は、
`~proxy$へ向けた要請に意図されている。
`CONNECT^m 要請を受信した~proxyは、［
`要請~target$により識別される`~server$へ直に接続する
］か, あるいは［
別の~proxyを利用するよう環境設定されている場合は，当の要請を`内方$にある次の~proxyへ回送する
］ことにより，`~tunnel$を確立できる。
`生成元~server$は，
`CONNECT^m 要請を受容してもヨイが、
ほとんどの生成元~serverは，
`CONNECT^m を実装しない。
◎
CONNECT is intended for use in requests to a proxy. The recipient can establish a tunnel either by directly connecting to the server identified by the request target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy. An origin server MAY accept a CONNECT request, but most origin servers do not implement CONNECT.
</p>

<p>
`CONNECT^m 要請に対する応答は、
その`状態s~code$に応じて，次を指示する：
◎
↓</p>
<ul class="switch">
	<li>
`2xx$st
⇒
`送信者$（および`内方$にある すべての`~proxy$）は、
その`~header節$の後に~tunnel~modeへ切替えることになる
— これ以降に受信される~dataは、
`要請~target$により識別される~serverからのものになる。
◎
Any 2xx (Successful) response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the response header section; data received after that header section is from the server identified by the request target.＼
</li>
	<li>
他の場合
⇒
~tunnelは、
まだ形成されていない。
◎
Any response other than a successful response indicates that the tunnel has not yet been formed.
</li>
</ul>

<div class="p">
<p>
`~tunnel$は、［
~tunnel媒介者が，いずれかの側がその接続を~closeしたことを検出した
］とき，~closeされる
— その際には、
`媒介者$は，次を行わなければナラナイ：
◎
A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary MUST＼
</p>
<ol>
	<li>
~closeされた側から来た，応答待ち~dataすべてを、
他の側へ送信するよう試みる。
◎
attempt to send any outstanding data that came from the closed side to the other side,＼
</li>
	<li>
接続を両~側とも~closeする。
◎
close both connections, and＼
</li>
	<li>
送達されなかった残りの~dataは、
すべて破棄する。
◎
then discard any remaining data left undelivered.
</li>
</ol>
</div>

<p>
~proxy認証が，`~tunnel$を作成するための権限を確立するために利用されることもある。
◎
Proxy authentication might be used to establish the authority to create a tunnel.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=
</pre>
</div>

<p>
任意な~serverへ`~tunnel$を確立することには、
有意な~riskがある
— 特に、
その行先が，~Web流通~用には意図されていない［
周知な／予約-済みな
］~TCP~portであるときは。
例えば，［
"`example.com:25^c" への `CONNECT^m
］は、
~proxyに［
~SMTP流通~用に予約-済みな~port
］へ接続するよう示唆することになろう
— 許容された場合、
~proxyを，~spam~emailを中継させるように騙せてしまう。
`CONNECT^m を~supportする`~proxy$は、
その利用を［
既知な~portたちが成す制限された集合
］または［
環境設定-可能な，安全な`要請~target$たちが成す~list
］に制約するベキである。
◎
There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT SHOULD restrict its use to a limited set of known ports or a configurable list of safe request targets.
</p>

<p>
`~server$は、［
`CONNECT^m に対する `2xx$st 応答
］内に［
`Transfer-Encoding$h ／ `Content-Length$h
］~headerを送信してはナラナイ。
`~client$は、［
`CONNECT^m に対する成功裡な応答
］内に受信された［
`Content-Length$h ／ `Transfer-Encoding$h
］~headerを，無視しなければナラナイ。
◎
A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to CONNECT.
</p>

<p>
`CONNECT^m 要請~messageには、
`内容$は無い。
`CONNECT^m 要請~messageの`~header節$より後に送信された~dataの解釈は、
利用-中にある~HTTP~versionに特有になる。
◎
A CONNECT request message does not have content. The interpretation of data sent after the header section of the CONNECT request message is specific to the version of HTTP in use.
</p>

<p>
`CONNECT^m ~methodに対する応答は、
`~cache可能$でない。
◎
Responses to the CONNECT method are not cacheable.
</p>

			</section>
			<section id="OPTIONS">
<h4>9.3.7. `OPTIONS^m</h4>

<p>
`OPTIONS^m ~methodは、［
`生成元~server$／介在している`媒介者$
］に対し，［
`~target資源$に可用な通信~optionについての情報
］を要請する。
この~methodは、
当の`資源$に対する動作を含意することなく［
資源に結付けられた［
~option／要件
］／
~serverの能力
］を決定することを`~client$に許容する。
◎
The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.
</p>

<p>
`OPTIONS^m 要請のうち，`要請~target$として~asterisk （ "`*^c" ）を伴うものは、
特定の`資源$に対してではなく，
`~server-wide@
に適用される。
`~server$の通信~optionは，概して`資源$に依存するので、
この種の要請が有用になるのは，
~clientが~serverの能力を~testすること以外は何もしないもの
— “`ping^en” や “`no-op^en” などに類する~methodなど —
に限られる。
例えば、［
`~HTTP11$に適合するか否か，`~proxy$を~testする
］ときに，これを利用できる。
◎
An OPTIONS request with an asterisk ("*") as the request target (Section 7.1) applies to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).
</p>

<p>
`OPTIONS^m 要請のうち，
`要請~target$が~asterisk（ "`*^c" ）でないものは、
`~target資源$と通信するときに可用な~optionに適用される。
◎
If the request target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.
</p>

<div class="p">
<p>
`~server$は、
そのような `OPTIONS^m 要請に対し成功裡な応答を`生成-$するときは：
◎
A server generating a successful response to OPTIONS＼
</p>
<ul>
	<li>
自身が実装している~headerのうち，［
`~target資源$に適用-可能な，任意選択な特能を指示するかもしれないもの
］（例： `Allow$h ）すべてを
— この仕様で定義されていない拡張があれば，それも含めて —
送信するベキである。
◎
SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.＼
</li>
	<li>
応答の`内容$も（もしあれば）、
~machineやヒトから読取n可能な`表現$により，通信~optionを述べるかもしれない。
そのような表現~用の標準~形式は、
この仕様では定義されないが，将来の~HTTP拡張により定義されるかもしれない。
◎
The response content, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP.
</li>
</ul>
</div>

<p>
`~client$は、
`OPTIONS^m 要請~内に，［
要請の`連鎖$にある，特定の`受信者$
］に宛てて `Max-Forwards$h ~headerを送信してもヨイ。
`~proxy$は、
受信した要請を回送するときには，それが
`Max-Forwards$h ~headerを伴っていない限り，
`Max-Forwards$h ~headerを`生成-$してはナラナイ。
◎
A client MAY send a Max-Forwards header field in an OPTIONS request to target a specific recipient in the request chain (see Section 7.6.2). A proxy MUST NOT generate a Max-Forwards header field while forwarding a request unless that request was received with a Max-Forwards field.
</p>

<p>
`~client$は、［
`内容$を包含する `OPTIONS^m 要請
］を`生成-$するときは，［
当の`表現$の`~MIME型$を述べる妥当な `Content-Type$h ~header
］を送信しなければナラナイ。
この仕様は、
そのような`内容$の利用については，何も定義しないことに注意。
◎
A client that generates an OPTIONS request containing content MUST send a valid Content-Type header field describing the representation media type. Note that this specification does not define any use for such content.
</p>

<p>
`OPTIONS^m ~methodに対する応答は、
`~cache可能$でない。
◎
Responses to the OPTIONS method are not cacheable.
</p>

			</section>
			<section id="TRACE">
<h4>9.3.8. `TRACE^m</h4>

<p>
`TRACE^m ~methodは、
当の要請~message用に［
~remoteからの，応用~levelの~loop-back
］を要請する。
要請の`最終-受信者$は、［
受信した~messageを`内容$として内包する `200$st 応答
］を`~client$へ返送して，受信した~messageを反映するベキである
— ただし、
下に述べる【 “敏感な~dataを包含しそうな” 】`~field$は，~messageから除外した上で。
"`message/http$c" 形式 `HTTP/1.1$r は、
それを行う仕方の一つである。
◎
The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the content of a 200 (OK) response. The "message/http" format (Section 10.1 of [HTTP/1.1]) is one way to do so.＼
</p>

<p>
`最終-受信者@
（ `final recipient^en ）とは、
`生成元~server$, または最初に［
要請~内の `Max-Forwards$h 値に 0 を受信した`~server$
］である。
◎
The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 7.6.2).
</p>

<p>
`~client$は、
`TRACE^m 要請~内に［
応答により開示され得るような，敏感な~dataを包含する`~field$
］を`生成-$してはナラナイ。
例えば，［
格納されている利用者の`資格証$や~cookie `COOKIE$r
］を `TRACE^m 要請~内に送信するような~UAは、
無分別になろう。
要請の`最終-受信者$は、
応答の`内容$を`生成-$するときには，［
要請~内の`~field$のうち，敏感な~dataを包含しそうなもの
］を除外するベキである。
◎
A client MUST NOT generate fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials (Section 11) or cookies [COOKIE] in a TRACE request. The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response content.
</p>

<p>
`TRACE^m は、
`~client$が［
要請の`連鎖$における，他方の終端で受信されたもの
］を見て，その~dataを［
~test用や診断用の情報
］に利用することを許容する。
特に関心~事になるものは、
`Via$h ~headerの値である
— それは、
要請~連鎖の~traceとして動作するので。
`Max-Forwards$h ~headerの利用は、
~clientが要請~連鎖の長さを制限することを許容する
— それは、［
~messageを回送している`~proxy$の`連鎖$が，無限~loopになっている
］かどうか~testするとき，有用になる。
◎
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (Section 7.6.3) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
</p>

<p>
`~client$は、
`TRACE^m 要請~内に`内容$を送信してはナラナイ。
◎
A client MUST NOT send content in a TRACE request.
</p>

<p>
`TRACE^m ~methodに対する応答は、
`~cache可能$でない。
◎
Responses to the TRACE method are not cacheable.
</p>

			</section>
		</section>
	</section>
	<section id="context">
<h2 title="Message Context">10. ~message文脈</h2>

		<section id="request.context">
<h3 title="Request Context Fields">10.1. 要請~文脈における~field</h3>

<p>
以下に挙げる要請~headerは、［
利用者, ~UA, 要請の背後にある`資源$
］についての情報も含め，要請の文脈についての追加的な情報を供する。
◎
The request header fields below provide additional information about the request context, including information about the user, user agent, and resource behind the request.
</p>

			<section id="field.expect">
<h4>10.1.1. `Expect^h</h4>

<p>
要請~内の `Expect^h ~headerは、
`期待@
（ `expectation$p ）を指示する
— それは、［
当の要請を適正に取扱うためには、
~serverが~supportする必要がある
］ような，一定の挙動たちが成す集合である。
◎
The "Expect" header field in a request indicates a certain set of behaviors (expectations) that need to be supported by the server in order to properly handle this request.
</p>

<pre class="bnf">
`Expect@p
	= #`expectation$p
`expectation@p
	= `token$p [ "=" ( `token$p / `quoted-string$p ) `parameters$p ]
</pre>

<p>
`Expect^h `~field値$は文字大小無視である。
◎
The Expect field value is case-insensitive.
</p>

<p>
この仕様が定義する唯一の期待は、
"`100-continue$c" である（定義される~parameterは無い）。
◎
The only expectation defined by this specification is "100-continue" (with no defined parameters).
</p>

<p>
`Expect^h にて［
`100-continue$c 以外の~memberを包含している`~field値$
］を受信した`~server$は、
`417$st で応答して，予期されない期待には応えられないことを指示してもヨイ。
◎
A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.
</p>

<p>
`期待$
`100-continue@c
は、［
`~client$は，当の要請~内に（大概は巨大な）`内容$を送信しつつあり、［
~method, `~target~URI$, および各種~header
］が［
即時に成功をもたらすには足らない／~redirectになる／~error応答になる
］かどうかについて，`非最終-応答$ `100$st を受信するよう望んでいる
］ことを`受信者$に伝える。
これにより、
~clientは，~~事前に［
`内容$を送信するに~~価するかどうかの指示
］があるまで待機できるようになり、［
~dataが~~巨大なとき／
~errorになる見込みが高いと~clientが見越すとき
（例：以前に検証yされた認証用の`資格証$を伴わずに，初回に状態変更~methodを送信するとき）
］に効率を改善できる。
◎
A "100-continue" expectation informs recipients that the client is about to send (presumably large) content in this request and wishes to receive a 100 (Continue) interim response if the method, target URI, and header fields are not sufficient to cause an immediate success, redirect, or error response. This allows the client to wait for an indication that it is worthwhile to send the content before actually doing so, which can improve efficiency when the data is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials).
</p>

<div class="example">
<p>
例えば，次で始まる要請により：
◎
For example, a request that begins with
</p>

<pre class="lang-http">
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue
</pre>
</div>

<p>
`生成元~server$は、［
`~client$が，不必要な~data転送で~pipeを埋め~~始める
］前に，［
`401$st や `405$st などの~error~message
］で即時に応答できるようになる。
◎
allows the origin server to immediately respond with an error message, such as 401 (Unauthorized) or 405 (Method Not Allowed), before the client starts filling the pipes with an unnecessary data transfer.
</p>

<p>
`~client$に課される要件は：
◎
Requirements for clients:
</p>
<ul>
	<li>
`内容$を内包しない要請~内に
`100-continue$c 期待を`生成-$してはナラナイ。
◎
A client MUST NOT generate a 100-continue expectation in a request that does not include content.
</li>
	<li>
要請の`内容$を送信する前に， `100$st 応答を待機するつもりがあるときは、
`100-continue$c 期待を包含する `Expect^h ~headerを送信しなければナラナイ。
◎
A client that will wait for a 100 (Continue) response before sending the request content MUST send an Expect header field containing a 100-continue expectation.
</li>
	<li>
`100-continue$c 期待を送信してから，特定の長さの時間 待機することは、
要求されない
— 応答がまだ受信されないうちに，`内容$の送信を続行してもヨイ。
更には，
`100$st 応答は ~HTTP10媒介者を通しては送信され得ないので、
`内容$を送信する前に不定~期間 待機するベキでない。
◎
A client that sends a 100-continue expectation is not required to wait for any specific length of time; such a client MAY proceed to send the content even if it has not yet received a response. Furthermore, since 100 (Continue) responses cannot be sent through an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an indefinite period before sending the content.
</li>
	<li>
`100-continue$c 期待を包含する要請に対する応答~内に， `417$st を受信したときは、
その要請を， `100-continue$c 期待を除いた上で繰返すベキである
— この `417^st0 応答は、
単に，［
応答の`連鎖$は、
期待を~supportしていない
］ことを指示するので
（例：~HTTP10~serverを通して渡されるとき）。
◎
A client that receives a 417 (Expectation Failed) status code in response to a request containing a 100-continue expectation SHOULD repeat that request without a 100-continue expectation, since the 417 response merely indicates that the response chain does not support expectations (e.g., it passes through an HTTP/1.0 server).
</li>
</ul>

<p>
`~server$に課される要件は：
◎
Requirements for servers:
</p>
<ul>
	<li>
~HTTP10要請~内に受信された
`100-continue$c 期待は、
無視しなければナラナイ。
◎
A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.
</li>
	<li>
次のいずれかに該当する場合、
`100$st 応答の送信を省略してもヨイ
⇒＃
応対した要請の`内容$の一部をすでに受信した／
~frame法が，`内容$が無いことを指示している
◎
A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.
</li>
	<li>
`100$st 応答を送信した後，要請の`内容$を受信して処理したなら、
接続が尚早に~closeされない限り，
最終的には `最終-応答$【！最終-状態s~code】を送信しなければナラナイ。
◎
A server that sends a 100 (Continue) response MUST ultimately send a final status code, once it receives and processes the request content, unless the connection is closed prematurely.
</li>
	<li>
要請の`内容$全体を読取る前に，`最終-応答$【！最終-状態s~code】で応答するときは、
次のどちらを意図するか指示するベキである
⇒＃
接続を~closeする（例： `HTTP/1.1$r `9.6＠~HTTPv1#persistent.tear-down§ を見よ）／
`内容$の読取りを継続する
◎
A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.
</li>
</ul>

<div>
<p>
［
`生成元~server$／`~proxy$
］は，`~HTTP11$（または それ以上の~versionの）要請に対し、
その［
~method, `~target~URI$, 完全な`~header節$
］を受信した時点で，当の要請は［
`100-continue$c 期待を包含していて，`内容$が後続することを指示している
］ならば、
次に従わなければナラナイ：
</p>
<ol>
	<li>
［
~method, `~target~URI$, 各~header
］を精査するだけで，状態sを決定できるならば、
即時に，その`状態s~code$を伴う`最終-応答$【！最終-状態s~codeを伴う応答】を送信する。
</li>
	<li>
<p>
他の場合、
`生成元~server$は
⇒
`~client$に要請の`内容$を送信してもらうよう奨励するため，
即時に `100$st 応答を送信する
— この応答を送信する前に，`内容$を待機してはナラナイ。
</p>

<p>
他の場合、
`~proxy$は
⇒
`内方$にある次の`~server$へ対応する［
~method, `~target~URI$【！＊`request-line$p】, `~header節$
］を送信することにより、
`生成元~server$へ向けて当の要請を回送する
— ただし
⇒
［
内方にある次の~serverが~HTTP10のみを~supportする
］ことを（環境設定または過去のやりとりから）予見できるならば、
`~client$に`内容$を送信し始めるよう奨励するため，
即時に `100$st 応答を`生成-$してもヨイ。
</p>
	</li>
</ol>
◎
Upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and an indication that request content will follow, an origin server MUST send either:
• an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or
• an immediate 100 (Continue) response to encourage the client to send the request content.
◎
The origin server MUST NOT wait for the content before sending the 100 (Continue) response.
◎
Upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and indicates a request content will follow, a proxy MUST either:
• send an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or
• forward the request toward the origin server by sending a corresponding request-line and header section to the next inbound server.
• If the proxy believes (from configuration or past interaction) that the next inbound server only supports HTTP/1.0, the proxy MAY generate an immediate 100 (Continue) response to encourage the client to begin sending the content.
</div>

			</section>
			<section id="field.from">
<h4>10.1.2. `From^h</h4>

<p>
`From^h ~headerは、［
要請を~~発行する~UAを制御するヒト利用者
］の~Internet~email~addressを包含する。
~addressは、
~machineから利用-可能な［
`5322/3.4$rfc にて定義される `mailbox^p
］になる~OUGHT：
◎
The "From" header field contains an Internet email address for a human user who controls the requesting user agent. The address ought to be machine-usable, as defined by "mailbox" in Section 3.4 of [RFC5322]:
</p>

<pre class="bnf">
`From@p
	= `mailbox$p

`mailbox@p
	= &lt;mailbox, `5322/3.4$rfc&gt;
</pre>

<div class="example">
<p>
例：
◎
An example is:
</p>

<pre class="lang-http">
From: spider-admin@example.org
</pre>
</div>

<p>
`From^h ~headerが~robot的でない~UAにより送信されることは稀である。
`~UA$は、
利用者により明示的に環境設定されない限り，
`From^h ~headerを送信するベキでない
— ［
利用者の~privacyへの関心や, それらの~siteの~security施策
］と競合するかもしれないので。
◎
The From header field is rarely sent by non-robotic user agents. A user agent SHOULD NOT send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.
</p>

<p>
~robot的な~UAは、
自身が［
過度な／求まれていない／妥当でない
］要請を送信しているときなど，［
~server上に問題が生じた場合に，~robotを稼働させている~~責務者と連絡をとれる
］ような，［
妥当な `From^h ~header
］を送信するベキである。
◎
A robotic user agent SHOULD send a valid From header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.
</p>

<p>
`~server$は、
`From^h ~headerを［
~access制御や認証
］用に利用するベキでない
— その値は、［
当の要請を受信-または観測している誰からも可視になる
］ものと期待され，~log~fileや~error報告の中に
— ~privacyは何ら期待されていないとみなして —
記録されることが多いので。
◎
A server SHOULD NOT use the From header field for access control or authentication, since its value is expected to be visible to anyone receiving or observing the request and is often recorded within logfiles and error reports without any expectation of privacy.
</p>

			</section>
			<section id="field.referer">
<h4>10.1.3. `Referer^h</h4>

<p>
`Referer^h ~headerは、
次を`~UA$に許容する
⇒
`~target~URI$が，ある`資源$†から得されたものであるとき、
その資源~用の`~URI参照$を指定する。
（† すなわち， “`referrer^en（~~参照元）”
— `~field名$の綴りは誤っているが。）
◎
The "Referer" [sic] header field allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the "referrer", though the field name is misspelled).＼
</p>

<p>
`~UA$は、
`Referer^h `~field値$を`生成-$するときは，~URI参照に［
`fragment$p ／ `userinfo$p
］成分 `URI$r を内包してはナラナイ。
◎
A user agent MUST NOT include the fragment and userinfo components of the URI reference [URI], if any, when generating the Referer field value.
</p>

<pre class="bnf">
`Referer@p
	= `absolute-URI$p
	/ `partial-URI$p
</pre>

<p>
`~field値$は、
`absolute-URI$p か `partial-URI$p をとる。
後者の事例では、
参照先の~URIは，`~target~URI$に相対的になる（ `URI$r `5§uri ）。
◎
The field value is either an absolute-URI or a partial-URI. In the latter case (Section 4), the referenced URI is relative to the target URI ([URI], Section 5).
</p>

<p>
`Referer^h ~headerは、［
単純な解析／~log取り／最適化された~caching／等々
］用に［
他の`資源$へ戻れる~linkを`生成-$する
］ことを`~server$に許容する。
それはまた、
保守~用に［
廃用にされた／誤入力された
］~linkを見出すことも可能にする。
一部の~serverは， `Referer^h ~headerを［
他~siteからの~link（いわゆる “`deep linking^en（深く~linkする）” ）を否認する／
~CSRF（ `cross-site request forgery^en ）を制約する
］ための手段として利用するが、
すべての要請がそれを包含するわけではない。
◎
The Referer header field allows servers to generate back-links to other resources for simple analytics, logging, optimized caching, etc. It also allows obsolete or mistyped links to be found for maintenance. Some servers use the Referer header field as a means of denying links from other sites (so-called "deep linking") or restricting cross-site request forgery (CSRF), but not all requests contain it.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
Referer: http://www.example.org/hypertext/Overview.html
</pre>
</div>

<p>
`~target~URI$が［
~URIを有さない~sourceから得されたもの
］である場合（例：利用者~keyboardからの入力, 利用者の~bookmark）、
`Referer^h ~headerを除外するか, または その値に "`about:blank^c" を送信しなければナラナイ。
◎
If the target URI was obtained from a source that does not have its own URI (e.g., input from the user keyboard, or an entry within the user's bookmarks/favorites), the user agent MUST either exclude the Referer header field or send it with a value of "about:blank".
</p>

<p>
`Referer^h ~headerの`~field値$は、
参照元~資源の全部的な~URIを伝達する必要はない
— `~UA$は、
参照元~URIの`生成元$以外を成す各部を切落してもヨイ。
◎
The Referer header field value need not convey the full URI of the referring resource; a user agent MAY truncate parts other than the referring origin.
</p>

<div class="p">
<p>
`Referer^h ~headerは、［
要請の文脈／利用者の閲覧~履歴
］についての情報を露呈するものになり得る
— それは、［
参照元~資源の識別子が（~account名などの）個人-情報を露呈する場合
］や［
資源が機密的と想定される
（~firewallの背後や, `~secure化$された~serviceの内部など）場合
］に，~privacyの懸念になる。
ほとんどの一般用~UAは、
参照元~資源が局所的な［
"`file^c" ／ "`data^c"
］~URI【`~scheme$】であるときには，
`Referer^h ~headerを送信しない。
◎
The Referer header field has the potential to reveal information about the request context or browsing history of the user, which is a privacy concern if the referring resource's identifier reveals personal information (such as an account name) or a resource that is supposed to be confidential (such as behind a firewall or internal to a secured service). Most general-purpose user agents do not send the Referer header field when the referring resource is a local "file" or "data" URI.＼
</p>

<div>
<p>
`~UA$は、
参照元~資源が~secureな~protocolで~accessされていた場合には：
</p>
<ul>
	<li>
`~secure化$されてない~HTTP要請~内に、
`Referer^h ~headerを送信してはナラナイ。
</li>
	<li>
［
`要請~target$, 参照元~資源
］の`生成元$が相違する場合、
参照元~資源から明示的に許容されている場合を除き，
`Referer^h ~headerを送信するベキでない。
</li>
</ul>
◎
A user agent SHOULD NOT send a Referer header field if the referring resource was accessed with a secure protocol and the request target has an origin differing from that of the referring resource, unless the referring resource explicitly allows Referer to be sent.＼
A user agent MUST NOT send a Referer header field in an unsecured HTTP request if the referring resource was accessed with a secure protocol.＼
</div>

<p>
追加的な~securityの考慮点については、
`17.9§ を見よ。
◎
See Section 17.9 for additional security considerations.
</p>
</div>

<p>
一部の`媒介者$は、［
外向けの要請から `Referer^h ~headerを無差別に除去する
］ことが既知である。
これは、
~CSRF攻撃に対する保護に干渉するような，~~望ましくない副作用を及ぼす
— それは、
利用者にとり，はるかに有害になる。
`Referer^h 内への情報~開示を制限するよう望む［
`媒介者$／`~UA$
］拡張は、
それらの変更を特定の編集-
— 内部~domain名を `pseudonym$p に置換したり，`query$p や`path$p 成分を切落すなど —
に制約する~OUGHT。
`媒介者$は、［
`Referer^h ~headerの`~field値$, `~target~URI$
］が同じ［
`~scheme$, `~host$
］を共有するときは，
`Referer^h ~headerを改変したり削除するベキでない。
◎
Some intermediaries have been known to indiscriminately remove Referer header fields from outgoing requests. This has the unfortunate side effect of interfering with protection against CSRF attacks, which can be far more harmful to their users. Intermediaries and user agent extensions that wish to limit information disclosure in Referer ought to restrict their changes to specific edits, such as replacing internal domain names with pseudonyms or truncating the query and/or path components. An intermediary SHOULD NOT modify or delete the Referer header field when the field value shares the same scheme and host as the target URI.
</p>

			</section>
			<section id="field.te">
<h4>10.1.4. `TE^h</h4>

<p>
`TE^h ~headerは、［
`転送~符号法$／`~trailer節$
］に関する`~client$の能力を述べる。
◎
The "TE" header field describes capabilities of the client with regard to transfer codings and trailer sections.
</p>

<p>
要請~内に送信された `TE^h ~fieldのうち
"`trailers@c"
~memberを伴うものは、［
`~client$は`~trailer$を破棄しない
］ことを指示する。
◎
As described in Section 6.5, a TE field with a "trailers" member sent in a request indicates that the client will not discard trailer fields.
</p>

<p>
`TE^h はまた、
~HTTP11の中で，［［
`~client$は、
応答~内に どの`転送~符号法$を受容-可能か
］について，~serverに助言する
］ためにも利用される。
この仕様の公表~時点では、
~HTTP11のみが`転送~符号法$を利用する。
◎
TE is also used within HTTP/1.1 to advise servers about which transfer codings the client is able to accept in a response. As of publication, only HTTP/1.1 uses transfer codings (see Section 7 of [HTTP/1.1]).
</p>

<div class="p">
<p>
`TE$h の`~field値$は，~listであり、
それを成す各~member（ `t-codings$p ）は
— "`trailers$c" は別として —
次に挙げるものからなる：
◎
The TE field value is a list of members, with each member (aside from "trailers") consisting of＼
</p>
<ul>
	<li>
`token$p
— 当の転送~符号法の名前を与える。
◎
a transfer coding name token＼
</li>
	<li>
省略可能な `weight$p
— 当の転送~符号法に対する`~client$の選好度（ `12.4.2§ ）を指示する。
◎
with an optional weight indicating the client's relative preference for that transfer coding (Section 12.4.2)＼
</li>
	<li>
0 個以上の `transfer-parameter$p
— 当の転送~符号法~用の~parameter群を与える。
◎
and optional parameters for that transfer coding.
</li>
</ul>
</div>

<pre class="bnf">
`TE@p
	= #`t-codings$p
`t-codings@p
	= "`trailers$c"
	/ ( `transfer-coding$p [ `weight$p ] )
`transfer-coding@p
	= `token$p *( `OWS$p ";" `OWS$p `transfer-parameter$p )
`transfer-parameter@p
	= `token$p `BWS$p "=" `BWS$p ( `token$p / `quoted-string$p )
</pre>

<p class="trans-note">【
各~parameterを与える `transfer-parameter^p の構文は、
`BWS^p を除けば `parameter$p と一致する。
】</p>

<p>
`TE^h の`送信者$は、
`媒介者$に この~fieldを回送しないよう伝えるため，
`Connection$h ~header内に "`TE^c" `接続~option$を送信しなければナラナイ。
◎
A sender of TE MUST also send a "TE" connection option within the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.
</p>

			</section>
			<section id="field.user-agent">
<h4>10.1.5. `User-Agent^h</h4>

<div class="p">
<p>
`User-Agent^h ~headerは、［
要請を出生した`~UA$
］についての情報を包含する
— `~server$は、
次のために，これを利用することが多い：
◎
The "User-Agent" header field contains information about the user agent originating the request, which is often used by servers＼
</p>
<ul>
	<li>
報告された相互運用能の問題を絞り込むための補助。
◎
to help identify the scope of reported interoperability problems,＼
</li>
	<li>
特定0の~UA制限を避けるために，［
対処する／応答を誂える
］。
◎
to work around or tailor responses to avoid particular user agent limitations, and＼
</li>
	<li>
利用されている~browserや OS に関する解析。
◎
for analytics regarding browser or operating system use.＼
</li>
</ul>

<p>
`~UA$は、
特定的に環境設定されていない限り，各~要請~内に `User-Agent^h ~headerを送信するベキである。
◎
A user agent SHOULD send a User-Agent header field in each request unless specifically configured not to do so.
</p>
</div>

<pre class="bnf">
`User-Agent@p
	= `product$p *( `RWS$p ( `product$p / `comment$p ) )
</pre>

<p>
`User-Agent^h `~field値$は、
1 個~以上の
`製品~識別子@
（ `product$p ）からなる
— 各 `製品~識別子$には 0 個以上の~comment（ `comment$p ）が後続する。
それらは組で［
~UA~software, その有意な下位製品
］を識別する。
慣行により、
製品~識別子たちは［
~UA~softwareの識別-用における有意度
］の降順で~listされる。
各 `製品~識別子$は、
【~softwareの】［
名前, 省略可能な~version（ `product-version$p ）
］からなる。
◎
The User-Agent field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.6.5), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.
</p>

<pre class="bnf">
`product@p
	= `token$p ["/" `product-version$p]
`product-version@p
	= `token$p
</pre>

<div class="p">
<p>
`送信者$は：
◎
↓</p>
<ul>
	<li>
`生成-$する`製品~識別子$を［
製品を識別するために必要yなもの
］に制限するベキである。
◎
A sender SHOULD limit generated product identifiers to what is necessary to identify the product;＼
</li>
	<li>
`製品~識別子$の中に［
広告-用その他の本質的でない情報
］を`生成-$してはナラナイ。
◎
a sender MUST NOT generate advertising or other nonessential information within the product identifier.＼
</li>
	<li>
`product-version$p 内に，~version識別子でない情報を`生成-$するベキでない
（すなわち，［
同じ製品~名の 一連の~version
］は、［
製品~識別子の `product-version$p 部位
］においてのみ相違する~OUGHT）。
◎
A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).
</li>
</ul>
</div>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</pre>
</div>

<div class="p">
<p>
`~UA$は：
◎
A user agent＼
</p>
<ul>
	<li>
~~不必要に木目細かな詳細を包含する `User-Agent^h ~headerを，`生成-$するベキでない。
◎
SHOULD NOT generate a User-Agent header field containing needlessly fine-grained detail and＼
</li>
	<li>
第三者-主体による下位製品の追加を，制限するベキである。
◎
SHOULD limit the addition of subproducts by third parties.＼
</li>
</ul>

<p>
~~不必要に長く詳細な `User-Agent^h `~field値$は、
要請の待時間を増やすのみならず，
利用者が望みに反して識別される~risk（ “`指紋収集$” ）を高める。
◎
Overly long and detailed User-Agent field values increase request latency and the risk of a user being identified against their wishes ("fingerprinting").
</p>
</div>

<p>
同様に，実装には、［
他の実装の製品~tokenを互換性を宣言するために利用する
］ことは奨励されない
— そうすると，この~fieldの目的を~~無為にするので。
別の~UAとして仮装する~UAに対しては、
`受信者$は，［
利用者が意図的に，その別の~UA用に誂えられた応答を
— それが実際に利用されている~UAで働くかどうかに関わらず —
見るよう欲している
］ものと見做せる。
◎
Likewise, implementations are encouraged not to use the product tokens of other implementations in order to declare compatibility with them, as this circumvents the purpose of the field. If a user agent masquerades as a different user agent, recipients can assume that the user intentionally desires to see responses tailored for that identified user agent, even if they might not work as well for the actual user agent being used.
</p>

			</section>
		</section>
		<section id="response.context">
<h3 title="Response Context Fields">10.2. 応答~文脈における~field</h3>

<p>
以下に挙げる応答~headerは、
当の応答についての追加的な情報
— 応答の`状態s~code$が含意するものを超える情報 —
を供する。
それには、［
~server／`~target資源$／関係する`資源$
］についても含まれる。
◎
The response header fields below provide additional information about the response, beyond what is implied by the status code, including information about the server, about the target resource, or about related resources.
</p>

			<section id="field.allow">
<h4>10.2.1. `Allow^h</h4>

<p>
`Allow^h ~headerは、［
`~target資源$が~supportするものとして広告された~method
］たちを~listする。
この~fieldの目的は、［
当の`資源$への要請において妥当になる`要請~method$
］を`受信者$に厳密に伝えることである。
◎
The "Allow" header field lists the set of methods advertised as supported by the target resource. The purpose of this field is strictly to inform the recipient of valid request methods associated with the resource.
</p>

<pre class="bnf">
`Allow@p
	= #`method$p
</pre>

<div class="example">
<p>
利用~例：
◎
Example of use:
</p>

<pre class="lang-http">
Allow: GET, HEAD, PUT
</pre>
</div>

<p>
許容される~methodたちが成す実際の集合は、
各~要請の時点で，`生成元~server$により定義される。
`生成元~server$は、
`405$st 応答~内には， `Allow^h ~headerを`生成-$しなければナラナイ。
また、
他のどの応答~内にも`生成-$してもヨイ。
空な `Allow^h `~field値$は、［
当の`資源$は，どの~methodも許容しない
］ことを指示する
— それは、［
当の資源は，環境設定により一時的に不能化されている場合
］に `405$st0 応答~内に生じ得る。
◎
The actual set of allowed methods is defined by the origin server at the time of each request. An origin server MUST generate an Allow header field in a 405 (Method Not Allowed) response and MAY do so in any other response. An empty Allow field value indicates that the resource allows no methods, which might occur in a 405 response if the resource has been temporarily disabled by configuration.
</p>

<p>
`~proxy$は、
`Allow^h ~headerを改変してはナラナイ
— その値の中に指示された どの~methodも、
汎用な~message取扱い規則に則って取扱うときは，解する必要はない。
◎
A proxy MUST NOT modify the Allow header field -- it does not need to understand all of the indicated methods in order to handle them according to the generic message handling rules.
</p>

			</section>
			<section id="field.location">
<h4>10.2.2. `Location^h</h4>

<p>
`Location^h ~headerは、
応答に関係する特定の`資源$を指すために，
一部の応答~内で利用される。
関係性の型は、［
`要請~method$, `状態s~code$
］の意味論の組合nで定義される。
◎
The "Location" header field is used in some responses to refer to a specific resource in relation to the response. The type of relationship is defined by the combination of request method and status code semantics.
</p>

<pre class="bnf">
`Location@p
	= `URI-reference$p
</pre>

<p>
`~field値$は、
単独の `URI-reference$p からなる。
値が相対~参照（ `URI$r `4.2§uri ）の形をとる場合、
最終-値は，`~target~URI$に~~相対的に解決することで算出される（ `URI$r `5§uri ）。
◎
The field value consists of a single URI-reference. When it has the form of a relative reference ([URI], Section 4.2), the final value is computed by resolving it against the target URI ([URI], Section 5).
</p>

<p>
`Location^h の値は：
◎
↓</p>
<ul>
	<li>
`201$st 応答においては、
要請により作成された`首な資源$を指す。
◎
For 201 (Created) responses, the Location value refers to the primary resource created by the request.＼
</li>
	<li>
`3xx$st 応答においては、
要請を自動的に~redirectするときに選好される`~target資源$を指す。
◎
For 3xx (Redirection) responses, the Location value refers to the preferred target resource for automatically redirecting the request.
</li>
</ul>

<p>
後者の場合，当の値に素片~成分（ `fragment$p ）が無い場合、
`~UA$は，当の~redirectionを［
当の値は［
`~target~URI$を`生成-$するときに利用した`~URI参照$
］の素片~成分を継承している
］かのように処理しなければナラナイ
（すなわち，~redirectionは、
元の参照に素片があるならば，それを継承する）。
◎
If the Location value provided in a 3xx (Redirection) response does not have a fragment component, a user agent MUST process the redirection as if the value inherits the fragment component of the URI reference used to generate the target URI (i.e., the redirection inherits the original reference's fragment, if any).
</p>

<div class="example">
<p>
例えば、［
~URI参照 "`http://www.example.org/~tim^c" に対し`生成-$された `GET$m 要請
］の結果が，次の~headerを包含する `303$st 応答になるならば：
◎
For example, a GET request generated for the URI reference "http://www.example.org/~tim" might result in a 303 (See Other) response containing the header field:
</p>

<pre class="lang-http">
Location: /People.html#tim
</pre>

<p>
これは、
~UAが
"`http://www.example.org/People.html#tim^c"
へ~redirectすることを示唆する。
◎
which suggests that the user agent redirect to "http://www.example.org/People.html#tim"
</p>

<p>
同様に、［
~URI参照 "`http://www.example.org/index.html#larry^c" に対し`生成-$された `GET$m 要請
］の結果が，次の~headerを包含する `301$st 応答になるならば：
◎
Likewise, a GET request generated for the URI reference "http://www.example.org/index.html#larry" might result in a 301 (Moved Permanently) response containing the header field:
</p>

<pre class="lang-http">
Location: http://www.example.net/index.html
</pre>

<p>
これは、
~UAが，元の素片~識別子を保全して
"`http://www.example.net/index.html#larry^c"
へ~redirectすることを示唆する。
◎
which suggests that the user agent redirect to "http://www.example.net/index.html#larry", preserving the original fragment identifier.
</p>
</div>

<p>
`Location^h 値~内の素片~識別子が，適切でなくなる状況もある：
例えば，［
`201$st 応答~内の `Location^h ~header
］は、［
作成された`資源$に特有な~URI
］を供するものと仮定されることになる。
◎
There are circumstances in which a fragment identifier in a Location value would not be appropriate. For example, the Location header field in a 201 (Created) response is supposed to provide a URI that is specific to the created resource.
</p>

<p class="note">注記：
一部の`受信者$は、［
`Location^h ~headerの`~URI参照$が妥当でない
］ときに，その回復を試みる。
この仕様は，そのような処理を義務化したり定義しないが、
堅牢性の~~目的で，それを許容する。
`Location^h の`~field値$は、
~memberたちが成す~listを許容し得ない
— ~list分離子である~commaは、
`URI-reference$p の中でも妥当な~data文字なので。
複数個の `Location$h `~field行l$を伴う妥当でない~messageが送信された場合、
当の経路~上の ある`受信者$は，それらの~field行lを一つに`結合-$するかもしれない。
その状況から妥当な `Location^h `~field値$を回復するのは、
困難であり，各 実装~間で相互運用可能にならない。
◎
Note: Some recipients attempt to recover from Location header fields that are not valid URI references. This specification does not mandate or define such processing, but does allow it for the sake of robustness. A Location field value cannot allow a list of members because the comma list separator is a valid data character within a URI-reference. If an invalid message is sent with multiple Location field lines, a recipient along the path might combine those field lines into one value. Recovery of a valid Location field value from that situation is difficult and not interoperable across implementations.
</p>

<p class="note">注記：
`Content-Location$h ~headerは、
それが［
同封された`表現$に対応する最も特定な`資源$
］を指す点で， `Location^h から相違する。
したがって、
応答が［
`Location^h, `Content-Location$h
］両~headerを包含することもアリである。
◎
Note: The Content-Location header field (Section 8.7) differs from Location in that the Content-Location refers to the most specific resource corresponding to the enclosed representation. It is therefore possible for a response to contain both the Location and Content-Location header fields.
</p>

			</section>
			<section id="field.retry-after">
<h4>10.2.3. `Retry-After^h</h4>

<p>
~serverは、［
~UAが後継の要請を為す前に，いつまで待機する~OUGHT
］かを指示するために， `Retry-After^h ~headerを送信する。
`503$st 応答に伴って送信されてきた `Retry-After^h は、［
当の~serviceが~clientに可用でないと予期されるのは、
いつまでか
］を指示する。
`3xx$st 応答に伴って送信されてきた `Retry-After^h は、［
~redirect要請を発行する前に，~UAに待機するよう依頼する最短な時間
］を指示する。
◎
Servers send the "Retry-After" header field to indicate how long the user agent ought to wait before making a follow-up request. When sent with a 503 (Service Unavailable) response, Retry-After indicates how long the service is expected to be unavailable to the client. When sent with any 3xx (Redirection) response, Retry-After indicates the minimum time that the user agent is asked to wait before issuing the redirected request.
</p>

<p>
`Retry-After^h の`~field値$は、
次のいずれかをとる
⇒＃
【日時を与える】 `HTTP-date$p ／
応答を受信してからの遅延~秒数【を与える `delay-seconds$p 】
◎
The Retry-After field value can be either an HTTP-date or a number of seconds to delay after receiving the response.
</p>

<pre class="bnf">
`Retry-After@p
	= `HTTP-date$p
	/ `delay-seconds$p
</pre>

<p>
`delay-seconds$p 値は、
秒数を表現する負でない~decimal整数である。
◎
A delay-seconds value is a non-negative decimal integer, representing time in seconds.
</p>

<pre class="bnf">
`delay-seconds@p
	= 1*`DIGIT$P
</pre>

<div class="example">
<p>
その利用~例：
◎
Two examples of its use are
</p>

<pre class="lang-http">
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
</pre>

<p>
後者の遅延は 2 分間になる。
◎
In the latter example, the delay is 2 minutes.
</p>
</div>

			</section>
			<section id="field.server">
<h4>10.2.4. `Server^h</h4>

<div class="p">
<p>
`Server^h ~headerは、［
`生成元~server$が，要請を取扱うために利用している~software
］についての情報を包含する
— それは、
次のために，~clientに利用されることが多い：
◎
The "Server" header field contains information about the software used by the origin server to handle the request, which is often used by clients＼
</p>
<ul>
	<li>
報告された相互運用能の問題の視野を絞るための補助。
◎
to help identify the scope of reported interoperability problems,＼
</li>
	<li>
特定0の~server制限を避けるために［
対処する／要請を誂える
］。
◎
to work around or tailor requests to avoid particular server limitations, and＼
</li>
	<li>
［
~server／~OS
］の利用に関する分析。
◎
for analytics regarding server or operating system use.＼
</li>
</ul>

<p>
`生成元~server$は、
自身の応答~内に `Server^h ~headerを`生成-$してもヨイ。
◎
An origin server MAY generate a Server header field in its responses.
</p>
</div>

<pre class="bnf">
`Server@p
	= `product$p *( `RWS$p ( `product$p / `comment$p ) )
</pre>

<p>
`Server^h ~headerの`~field値$は、
1 個~以上の`製品~識別子$からなる
— 各 `製品~識別子$には 0 個以上の `comment$p が後続する。
それらは組で［
生成元~serverの~software, その有意な下位製品
］を識別する。
慣行により、
製品~識別子たちは［
生成元~serverの~softwareの識別-用における有意度
］の降順で~listされる。
各 `製品~識別子$は、
それに定義されるとおり，【~softwareの】［
名前, 省略可能な~version
］からなる。
◎
The Server header field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.6.5), which together identify the origin server software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the origin server software. Each product identifier consists of a name and optional version, as defined in Section 10.1.5.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
Server: CERN/3.0 libwww/2.17
</pre>
</div>

<p>
`生成元~server$は、［
~~不必要に木目細かな詳細を包含する `Server^h ~header
］を`生成-$するベキでない。
また、［
第三者-主体による下位製品の追加
］を制限するベキである。
~~過度に長く詳細な `Server^h `~field値$は、
応答の待時間を増やすのみならず，
内部~実装の詳細を露呈しかねないので、
攻撃者が既知な~securityの穴を見出して悪用することも（少しばかり）容易になる。
◎
An origin server SHOULD NOT generate a Server header field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties. Overly long and detailed Server field values increase response latency and potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.
</p>

			</section>
		</section>
	</section>
	<section id="authentication">
<h2 title="HTTP Authentication">11. ~HTTP認証</h2>

		<section id="auth.scheme">
<h3 title="Authentication Scheme">11.1. 認証~scheme</h3>

<p>
~HTTPは、［
~access制御と認証~用の一般的な~framework
］を［
［~challenge→応答］`認証~scheme$
］たちが成す拡張-可能な集合を介して，供する
— それは、［
`~server$が~client要請を~challengeする
］ため, および［
`~client$が認証~情報を供する
］ために利用できる。
それは、
認証~schemeを識別するため，文字大小区別な~tokenを利用する：
◎
HTTP provides a general framework for access control and authentication, via an extensible set of challenge-response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information. It uses a case-insensitive token to identify the authentication scheme:
</p>

<pre class="bnf">
`auth-scheme@p
	= `token$p
</pre>

<p>
一般的な~frameworkは別として、
この文書は，どの認証~schemeも指定しない。
［
新たな／既存の
］認証~schemeは、
独立に指定された上で，
`~HTTP認証~scheme~registry$cite
の中に登録される~OUGHT。
例えば，認証~scheme［
"`basic^c" は `RFC7617$r ／
"`digest^c" は `RFC7616$r
］にて定義される。
◎
Aside from the general framework, this document does not specify any authentication schemes. New and existing authentication schemes are specified independently and ought to be registered within the "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry". For example, the "basic" and "digest" authentication schemes are defined by [RFC7617] and [RFC7616], respectively.
</p>

		</section>
		<section id="auth.params">
<h3 title="Authentication Parameters">11.2. 認証~parameter</h3>

<p>
認証~schemeには、
その~schemeを介して認証を達成するために必要yな追加的な情報として，次のいずれかが後続する
⇒＃
~commaで分離された`認証~parameter$たちが成す~list／
base64 符号化された情報を保持する能力がある 1 個の文字~列（ `token68$p ）。
◎
The authentication scheme is followed by additional information necessary for achieving authentication via that scheme as either a comma-separated list of parameters or a single sequence of characters capable of holding base64-encoded information.
</p>

<pre class="bnf">
`token68@p
	= 1*( `ALPHA$P / `DIGIT$P / "-" / "." / "_" / "~" / "+" / "/" ) *"="
</pre>

<p>
`token68$p 構文は、
予約-済みでない 66 個の~URI文字（ `URI$r `2.3§uri ）に加えて，
空白~以外の少数の文字も許容する
— 次に挙げる符号化法 `RFC4648$r を，~paddingの有無も込みで保持できるようにするための
⇒＃
`base64$,
`base64url$ （~URLや~filenameに用いても安全な~alphabet）,
`base32$,
`base16$ （ 16 進）
◎
The token68 syntax allows the 66 unreserved URI characters ([URI]), plus a few others, so that it can hold a base64, base64url (URL and filename safe alphabet), base32, or base16 (hex) encoding, with or without padding, but excluding whitespace ([RFC4648]).
</p>

<div class="p">
<p>
各
`認証~parameter@
（ `auth-param$p ）は、［
名前, 値
］が成す~pairを与える：
◎
Authentication parameters are name/value pairs, where＼
</p>
<ul>
	<li>
名前は、
文字大小無視で照合される `token$p である。
◎
the name token is matched case-insensitively and＼
</li>
	<li>
各 `challenge$p 内には同じ名前が複数回~生じてはナラナイ。
◎
each parameter name MUST only occur once per challenge.
</li>
</ul>
</div>

<pre class="bnf">
`auth-param@p
	= `token$p `BWS$p "=" `BWS$p ( `token$p / `quoted-string$p )
</pre>

<p>
~parameterの値は、
"`token$p" としても "`quoted-string$p" としても表出できる。
［
`認証~scheme$に関わらず，汎用な構文解析~componentを利用する
］ことを受信者に許容するため、
認証~scheme定義は，`送信者$用にも`受信者$用にも，両~表記法を受容する必要がある。
◎
Parameter values can be expressed either as "token" or as "quoted-string" (Section 5.6). Authentication scheme definitions need to accept both notations, both for senders and recipients, to allow recipients to use generic parsing components regardless of the authentication scheme.
</p>

<p>
後方-互換性を得るため、
認証~scheme定義は，送信者~用の形式を この 2 つの変種の片方に制約できる。
これは、［
配備-済みな実装が，他方の形式に遭遇したときには失敗する
］ことが既知なとき，重要になり得る。
◎
For backwards compatibility, authentication scheme definitions can restrict the format for senders to one of the two variants. This can be important when it is known that deployed implementations will fail when encountering one of the two formats.
</p>

		</section>
		<section id="challenge.and.response">
<h3 title="Challenge and Response">11.3. ~challengeと応答</h3>

<p>
`401$st 応答~messageは、
次を包含する `WWW-Authenticate$h ~headerを内包する
⇒
要請された`資源$に適用-可能な
1 個~以上の `challenge$p
— それらは、
`~UA$への権限付与を~challengeするために，
`生成元~server$により利用される。
◎
A 401 (Unauthorized) response message is used by an origin server to challenge the authorization of a user agent, including a WWW-Authenticate header field containing at least one challenge applicable to the requested resource.
</p>

<p>
`407$st 応答~messageは、
次を包含する `Proxy-Authenticate$h ~headerを内包する
⇒
要請された`資源$用に~proxyに適用-可能な 1 個~以上の `challenge$p
— それらは、
`~client$への権限付与を~challengeするために，
`~proxy$により利用される。
◎
A 407 (Proxy Authentication Required) response message is used by a proxy to challenge the authorization of a client, including a Proxy-Authenticate header field containing at least one challenge applicable to the proxy for the requested resource.
</p>

<pre class="bnf">
`challenge@p
	= `auth-scheme$p [ 1*`SP$P ( `token68$p / #`auth-param$p ) ]
</pre>

<p class="note">注記：
多くの`~client$は、
`challenge$p が未知な~schemeを包含する場合，その構文解析-に失敗する。
この問題への対処法は、
~~最初の方に［
きちんと~supportされている~schemeたち（ "`basic^c" など）
］を挙げることである。
◎
Note: Many clients fail to parse a challenge that contains an unknown scheme. A workaround for this problem is to list well-supported schemes (such as "basic") first.
</p>

<p>
`~UA$は
— 必要とされてはいないが通例的には， `401$st を受信した後に —
［
要請に `Authorization$h ~headerを内包する
］ことにより，［
自身を`生成元~server$から認証してもらう
］ことができる。
◎
A user agent that wishes to authenticate itself with an origin server -- usually, but not necessarily, after receiving a 401 (Unauthorized) -- can do so by including an Authorization header field with the request.
</p>

<p>
`~client$は
— 必要とされてはいないが通例的には， `407$st を受信した後に —
［
要請に `Proxy-Authorization$h ~headerを内包する
］ことにより，［
自身を`~proxy$から認証してもらう
］ことができる。
◎
A client that wishes to authenticate itself with a proxy -- usually, but not necessarily, after receiving a 407 (Proxy Authentication Required) -- can do so by including a Proxy-Authorization header field with the request.
</p>

		</section>
		<section id="credentials">
<h3 title="Credentials">11.4. 資格証</h3>

<div class="p">
<p>
［
`Authorization$h, `Proxy-Authorization$h
］の`~field値$は、
どちらも，［
要請-中にある`資源$が属する `realm$c
］用の［
`~client$の
`資格証@
（ `credentials$p ）
］を包含する
— それは、
応答~内に（場合によっては過去のある時点で）受信された `challenge$p に基づく。
`~UA$は、
それらの値を，次を行うことにより作成する~OUGHT：
◎
Both the Authorization field value and the Proxy-Authorization field value contain the client's credentials for the realm of the resource being requested, based upon a challenge received in a response (possibly at some point in the past). When creating their values, the user agent ought to do so by＼
</p>
<ul>
	<li>
受信した各 `challenge$p のうち［
自身が解する かつ最も~secureであると見なす `auth-scheme$p
］を伴うものを選定する。
◎
selecting the challenge with what it considers to be the most secure auth-scheme that it understands,＼
</li>
	<li>
利用者から適宜 `資格証$を得する。
◎
obtaining credentials from the user as appropriate.＼
</li>
</ul>

<p>
`資格証$を~headerの`~field値$の中に伝送することは、
下層~接続の機密性に関する，有意な~securityの考慮点も含意する
— `17.16.1§ を見よ。
◎
Transmission of credentials within header field values implies significant security considerations regarding the confidentiality of the underlying connection, as described in Section 17.16.1.
</p>
</div>

<pre class="bnf">
`credentials@p
	= `auth-scheme$p [ 1*`SP$P ( `token68$p / #`auth-param$p ) ]
</pre>

<div class="p">
<p>
`生成元~server$は、
保護される`資源$用の`資格証$が［
省略された／
無効である（例： 不良な~password）／
部分的である（例：`認証~scheme$には複数~回の往復が要求される）
］要請の受領に際しては，次のような `401$st 応答を送信するベキである：
◎
Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that＼
</p>
<ul>
	<li>
`WWW-Authenticate$h ~headerを包含する。
◎
contains a WWW-Authenticate header field＼
</li>
	<li>
この~headerには、
1 個~以上の［
要請された`資源$に適用-可能な `challenge$p
］を伴わせる
（場合によっては、
新たなそれも含ませる）。
◎
with at least one (possibly new) challenge applicable to the requested resource.
</li>
</ul>
</div>

<div class="p">
<p>
同様に，認証を要求する`~proxy$は、
~proxy`資格証$が［
省略された／
無効である／
部分的である
］要請の受領に際しては，次のような `407$st 応答を`生成-$するベキである：
◎
Likewise, upon receipt of a request that omits proxy credentials or contains invalid or partial proxy credentials, a proxy that requires authentication SHOULD generate a 407 (Proxy Authentication Required) response that＼
</p>
<ul>
	<li>
`Proxy-Authenticate$h ~headerを包含する。
◎
contains a Proxy-Authenticate header field＼
</li>
	<li>
この~headerには、
1 個~以上の［
当の`~proxy$に適用-可能な `challenge$p
］を伴わせる
（場合によっては、
新たなそれも含ませる）。
◎
with at least one (possibly new) challenge applicable to the proxy.
</li>
</ul>
</div>

<p>
`~server$は、
妥当であるが ~accessを~~獲得するには必要十分でない`資格証$を受信したときは，
状態s~code `403$st で応答する~OUGHT。
◎
A server that receives valid credentials that are not adequate to gain access ought to respond with the 403 (Forbidden) status code (Section 15.5.4).
</p>

<p>
~HTTPは、
この単純な［~challenge→応答］~frameworkによる応用を，
~access認証のみに制約しない。
追加的な仕組みも利用できる
— ［
~transport~levelの認証として, あるいは
~messageによる~capsule化を介して
］, および［
認証~情報を指定する追加的な~headerを伴わせる
］ような。
しかしながら、
そのような追加的な仕組みは，この仕様では定義されない。
◎
HTTP does not restrict applications to this simple challenge-response framework for access authentication. Additional mechanisms can be used, such as authentication at the transport level or via message encapsulation, and with additional header fields specifying authentication information. However, such additional mechanisms are not defined by this specification.
</p>

<p>
利用者~認証~用の様々な~customな仕組みが、
`COOKIE$r に定義される［
`Set-Cookie$h, `Cookie$h
］~headerを利用して認証に関係する~tokenを渡すことに注意。
◎
Note that various custom mechanisms for user authentication use the Set-Cookie and Cookie header fields, defined in [COOKIE], for passing tokens related to authentication.
</p>

		</section>
		<section id="protection.space">
<h3 title="Establishing a Protection Space (Realm)">11.5. 保護~空間（ `realm^c ）の確立-法</h3>

<p>
名前
`realm@c
の`認証~parameter$は、
`認証~scheme$における保護の視野
— `保護~空間$ —
を指示する利用が望まれるときのために，予約されている。
◎
The "realm" authentication parameter is reserved for use by authentication schemes that wish to indicate a scope of protection.
</p>

<p>
`保護~空間@
（ `protection space^en ）は、［
~accessされている`~server$の`生成元$,
この `realm$c 値（もし在るなら）
］の組合nにより定義される。
`realm$c は、［
`~server$上の保護される`資源$たちを，いくつかの`保護~空間$に区分する
］ことを許容する
— それら各~空間が自前の［
`認証~scheme$や権限付与~database
］を伴うよう。
`realm$c 値は、
一般に，`生成元~server$により アテガわれる文字列であり、
`認証~scheme$に特有な追加的な意味論を有し得る。
応答は、［
同じ `auth-scheme$p を伴いつつ, 異なる `realm$c 値を伴う
］ような，複数の `challenge$p を有し得ることに注意。
◎
A "protection space" is defined by the origin (see Section 4.3.1) of the server being accessed, in combination with the realm value if present. These realms allow the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme and/or authorization database. The realm value is a string, generally assigned by the origin server, that can have additional semantics specific to the authentication scheme. Note that a response can have multiple challenges with the same auth-scheme but with different realms.
</p>

<p>
`保護~空間$は、
`資格証$を自動的に適用できる~domainを決定する。
先立つ要請に権限付与されていた場合、
`~UA$は、
その`保護~空間$に属する他のすべての要請に対し，
同じ`資格証$を ある期間までは再利用してもヨイ
— その期間は、［
`認証~scheme$,
`認証~parameter$たち,
利用者-選好（環境設定-可能な放置 制限時間など）
］のうち いくつかから決定される。
◎
The protection space determines the domain over which credentials can be automatically applied. If a prior request has been authorized, the user agent MAY reuse the same credentials for all other requests within that protection space for a period of time determined by the authentication scheme, parameters, and/or user preferences (such as a configurable inactivity timeout).
</p>

<p>
`保護~空間$の対象範囲
— したがって、
どの要請に`資格証$が自動的に適用され得るか —
は、
追加的な情報を伴わない下では，`~client$に既知になるとは限らない。
`認証~scheme$は、
ある`保護~空間$の対象範囲を述べる~parameter群を定義するかもしれない。
`認証~scheme$により特定的に許容されない限り、
単独の`保護~空間$は，その`~server$の視野から外へは拡張し得ない。
◎
The extent of a protection space, and therefore the requests to which credentials might be automatically applied, is not necessarily known to clients without additional information. An authentication scheme might define parameters that describe the extent of a protection space. Unless specifically allowed by the authentication scheme, a single protection space cannot extend outside the scope of its server.
</p>

<p>
歴史的な理由から、
`送信者$は，
【 `realm^c `認証~parameter$の値として】
`quoted-string$p 構文のみを`生成-$しなければナラナイ。
~~長年にわたり `token$p 表記法も受容してきた既存の`~client$との相互運用能を最大にするためには、
`受信者$は，どちらの構文も~supportする必要があるかもしれない。
◎
For historical reasons, a sender MUST only generate the quoted-string syntax. Recipients might have to support both token and quoted-string syntax for maximum interoperability with existing clients that have been accepting both notations for a long time.
</p>

		</section>
		<section id="auth.user.origin.server">
<h3 title="Authenticating Users to Origin Servers">11.6. 生成元~serverへの利用者の認証-法</h3>

			<section id="field.www-authenticate">
<h4>11.6.1. `WWW-Authenticate^h</h4>

<p>
`WWW-Authenticate^h 応答~headerは、
`~target資源$に適用-可能な［
`認証~scheme$たち, および
`認証~parameter$たち
］を指示する。
◎
The "WWW-Authenticate" response header field indicates the authentication scheme(s) and parameters applicable to the target resource.
</p>

<pre class="bnf">
`WWW-Authenticate@p
	= #`challenge$p
</pre>

<p>
`401$st 応答を`生成-$する`~server$は、［
 1 個~以上の `challenge$p を包含する，
`WWW-Authenticate^h ~header
］を送信しなければナラナイ。
~serverは、
他の応答~message内にも，
`WWW-Authenticate^h ~headerを`生成-$してもヨイ
— 【後の要請に】 `資格証$（または異なる`資格証$）を給することが，
対する応答に影響し得ることを指示するために。
◎
A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge. A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.
</p>

<p>
応答を回送している`~proxy$は、
その応答~内の `WWW-Authenticate^h ~headerを改変してはナラナイ。
◎
A proxy forwarding a response MUST NOT modify any WWW-Authenticate header fields in that response.
</p>

<p>
`~UA$には、
`~field値$を構文解析するときには特別に~careすることを~~勧める
— それは，複数個の `challenge$p を包含するかもしれず、
各 `challenge$p も［
~commaで分離された`認証~parameter$たちが成す~list
］を包含し得るので。
更には、
この~header自体も複数~回 生じ得る。
◎
User agents are advised to take special care in parsing the field value, as it might contain more than one challenge, and each challenge can contain a comma-separated list of authentication parameters. Furthermore, the header field itself can occur multiple times.
</p>

<div class="example">
<p>
一例として：
◎
For instance:
</p>

<pre class="lang-http">
WWW-Authenticate: Basic realm="simple", Newauth realm="apps", type=1, title="Login to \"apps\""
</pre>

<p>
この~headerは、
2 個の `challenge$p を包含する
⇒＃
`Basic^c ~scheme用の `realm$c 値 "`simple^c" を伴うもの,
`Newauth^c ~scheme用の `realm$c 値 "`apps^c" を伴うもの
◎終
また，追加的な~parameterとして `type^c, `title^c も伴う。
◎
This header field contains two challenges,＼
one for the "Basic" scheme with a realm value of "simple"＼
and another for the "Newauth" scheme with a realm value of "apps",＼
It also contains two additional parameters, "type" and "title".
</p>
</div>

<p>
しかしながら、
一部の~UAは，この形を認識しない。
結果として、［
`WWW-Authenticate^h の`~field値$を同じ`~field行l$に複数個の~memberを伴わせて送信する
］ことは，相互運用可能にならないかもしれない。
◎
Some user agents do not recognize this form, however. As a result, sending a WWW-Authenticate field value with more than one member on the same field line might not be interoperable.
</p>

<p class="note">注記：
`challenge$p 文法~生成規則も~list構文を利用する。
したがって，［
~comma, 空白, ~comma
］が成す連列は、［
先行している `challenge$p に適用するもの
］としても, ［
`challenge$p たちが成す~listにおける，空な~entry
］としても見なせる。
実施においては，この多義性は、
当の~headerの`~field値$の意味論に影響しないので，無害である。
◎
Note: The challenge grammar production uses the list syntax as well. Therefore, a sequence of comma, whitespace, and comma can be considered either as applying to the preceding challenge, or to be an empty entry in the list of challenges. In practice, this ambiguity does not affect the semantics of the header field value and thus is harmless.
</p>

			</section>
			<section id="field.authorization">
<h4>11.6.2. `Authorization^h</h4>

<p>
`Authorization^h 【要請】~headerにより、
`~UA$は，自身を`生成元~server$から認証してもらうことが可能になる
— 必要とされてはいないが通例的には， `401$st 応答を受信した後に。
その値は、［
要請-中にある`資源$の `realm$c 用の，`~UA$の認証~情報
］を包含する`資格証$からなる。
◎
The "Authorization" header field allows a user agent to authenticate itself with an origin server -- usually, but not necessarily, after receiving a 401 (Unauthorized) response. Its value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.
</p>

<pre class="bnf">
`Authorization@p
	= `credentials$p
</pre>

<p>
要請が認証され, かつ `realm$c も指定されている場合、
同じ`資格証$は，［
この `realm$c に属する 他のすべての要請に対しても，妥当である
］ものと予め見做されるようになる（`認証~scheme$自体が，他のもの
— ［
`challenge$p 値に則って, あるいは同期された`時計$を利用して
］様々になるような`資格証$など —
を要求しない限りにおいて）。
◎
If a request is authenticated and a realm specified, the same credentials are presumed to be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).
</p>

<p>
要請を回送している`~proxy$は、
その要請~内のどの `Authorization^h ~headerも，改変してはナラナイ。
~HTTP~cacheによる `Authorization^h ~headerの取扱い［
の詳細／に課される要件
］については、
`CACHING$r `認証-済み要請に対する応答の格納-法＠~HTTPcache#caching.authenticated.responses§
を見よ。
◎
A proxy forwarding a request MUST NOT modify any Authorization header fields in that request. See Section 3.5 of [CACHING] for details of and requirements pertaining to handling of the Authorization header field by HTTP caches.
</p>

			</section>
			<section id="field.authentication-info">
<h4>11.6.3. `Authentication-Info^h</h4>

<p>
~HTTP`認証~scheme$では、
`~client$の認証用の`資格証$を受容した後に，
`Authentication-Info^h 応答~fieldを利用して情報を通信できる。
この情報は~serverからの【認証の】完結~messageを内包し得る（例：~server認証を包含し得る）。
◎
HTTP authentication schemes can use the "Authentication-Info" response field to communicate information after the client's authentication credentials have been accepted. This information can include a finalization message from the server (e.g., it can contain the server authentication).
</p>

<p>
その`~field値$は、
`auth-param$p 構文を利用する~parameter（名前, 値が成す~pair）たちが成す~listである。
この仕様は、
汎用な形式のみを述べる
— 個々の~parameterは、
`Authentication-Info^h を利用している`認証~scheme$が定義することになる。
一例として， `Digest^c 認証~schemeは、
`7616/3.5$rfc にて複数の~parameterを定義する。
◎
The field value is a list of parameters (name/value pairs), using the "auth-param" syntax defined in Section 11.3. This specification only describes the generic format; authentication schemes using Authentication-Info will define the individual parameters. The "Digest" Authentication Scheme, for instance, defines multiple parameters in Section 3.5 of [RFC7616].
</p>

<pre class="bnf">
`Authentication-Info@p
	= #`auth-param$p
</pre>

<p>
`Authentication-Info^h ~fieldは、
`要請~method$や`状態s~code$とは独立に，どの~HTTP応答にも利用できる。
その意味論は、［
それが応対した要請の `Authorization$h ~headerにより指示される`認証~scheme$
］により定義される。
◎
The Authentication-Info field can be used in any HTTP response, independently of request method and status code. Its semantics are defined by the authentication scheme indicated by the Authorization header field (Section 11.6.2) of the corresponding request.
</p>

<p>
応答を回送している`~proxy$には、
どの仕方であろうと，`~field値$を改変することは許容されない。
◎
A proxy forwarding a response is not allowed to modify the field value in any way.
</p>

<p>
`Authentication-Info^h は、
`認証~scheme$が明示的に許容するときには，`~trailer$として送信され得る（ `6.5§ ）。
◎
Authentication-Info can be sent as a trailer field (Section 6.5) when the authentication scheme explicitly allows this.
</p>

			</section>
		</section>
		<section id="auth.client.proxy">
<h3 title="Authenticating Clients to Proxies">11.7. ~proxyへの~clientの認証-法</h3>

			<section id="field.proxy-authenticate">
<h4>11.7.1. `Proxy-Authenticate^h</h4>

<p>
`Proxy-Authenticate^h 【応答】~headerは、
1 個~以上の `challenge$p からなる
— 各 `challenge^p は、
この【~~今後の？】要請~用に`~proxy$に適用-可能な［
`認証~scheme$, `認証~parameter$たち
］を指示する。
`~proxy$は、
自身が`生成-$する各 `407$st 応答~内に
1 個~以上の `Proxy-Authenticate^h ~headerを送信しなければナラナイ。
◎
The "Proxy-Authenticate" header field consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the proxy for this request. A proxy MUST send at least one Proxy-Authenticate header field in each 407 (Proxy Authentication Required) response that it generates.
</p>

<pre class="bnf">
`Proxy-Authenticate@p
	= #`challenge$p
</pre>

<p>
`WWW-Authenticate$h と違って、
`Proxy-Authenticate^h ~headerが適用されるのは，［
応答`連鎖$の`外方$にある次の`~client$
］に限られる
— 当の`~proxy$を選んだ`~client$のみが，認証に必要yな`資格証$を有するものと見込まれるので。
しかしながら，
同じ管轄の中で複数の~proxyが利用されるとき
— 巨大~企業~networkの中の，各~~部署の~caching~proxyなど —
は、［
`~UA$により`生成-$された`資格証$が，消費されるまで階層を通過する
］ことは共通的にある。
よって，そのような環境設定の下では、
各~proxyは同じ `challenge$p 集合を送信することになり，
`Proxy-Authenticate^h は回送されているかのように出現することになる。
◎
Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the next outbound client on the response chain. This is because only the client that chose a given proxy is likely to have the credentials necessary for authentication. However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed. Hence, in such a configuration, it will appear as if Proxy-Authenticate is being forwarded because each proxy will send the same challenge set.
</p>

<p>
`WWW-Authenticate$h ~headerの構文解析に対する考慮点は、
この~fieldにも適用されることに注意。
◎
Note that the parsing considerations for WWW-Authenticate apply to this header field as well; see Section 11.6.1 for details.
</p>

			</section>
			<section id="field.proxy-authorization">
<h4>11.7.2. `Proxy-Authorization^h</h4>

<div class="p">
<p>
`Proxy-Authorization^h ~headerは：
◎
The "Proxy-Authorization" header field＼
</p>
<ul>
	<li>
次を`~client$に許容する
⇒
認証を要求している`~proxy$に対し，自身を（または その利用者を）識別してもらう
◎
allows the client to identify itself (or its user) to a proxy that requires authentication.＼
</li>
	<li>
その値は、
次を包含する`資格証$からなる
⇒
［
当の~proxy／要請-中にある`資源$の `realm$c
］用の`~client$の認証~情報
◎
Its value consists of credentials containing the authentication information of the client for the proxy and/or realm of the resource being requested.
</li>
</ul>
</div>

<pre class="bnf">
`Proxy-Authorization@p
	= `credentials$p
</pre>

<p>
`Authorization$h と違って，
`Proxy-Authorization^h ~headerが適用されるのは、［
`Proxy-Authenticate$h ~headerを利用して認証を請求した，`内方$にある次の`~proxy$
］に限られる。
`連鎖$にて複数の~proxyが利用されているときは、
`Proxy-Authorization^h ~headerは，［
`資格証$の受信を期待していた~proxyのうち，`内方$にある最初のもの
］により消費される。
複数の~proxyが，所与の要請を協力的に認証する仕組みを成している場合、
それらに属する~proxyは，~client要請からの`資格証$を 次の~proxyへ中継してもヨイ。
◎
Unlike Authorization, the Proxy-Authorization header field applies only to the next inbound proxy that demanded authentication using the Proxy-Authenticate header field. When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed by the first inbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.
</p>

			</section>
			<section id="field.proxy-authentication-info">
<h4>11.7.3. `Proxy-Authentication-Info^h</h4>

<p>
`Proxy-Authentication-Info^h 応答~headerは、
次を除き， `Authentication-Info$h に等価である
⇒
この~headerは，~proxy認証（ `11.3§ ）に適用され、
その意味論は，［
応対した要請の `Proxy-Authorization$h ~headerに指示される`認証~scheme$
］により定義される。
◎
The "Proxy-Authentication-Info" response header field is equivalent to Authentication-Info, except that it applies to proxy authentication (Section 11.3) and its semantics are defined by the authentication scheme indicated by the Proxy-Authorization header field (Section 11.7.2) of the corresponding request:
</p>

<pre class="bnf">
`Proxy-Authentication-Info@p
	= #`auth-param$p
</pre>

<p>
しかしながら， `Authentication-Info$h と違って、
`Proxy-Authentication-Info^h ~headerが適用されるのは，応答`連鎖$において`外方$にある次の`~client$に限られる
— 当の`~proxy$を選んだ`~client$のみが，認証に必要yな`資格証$を有するものと見込まれるので。
しかしながら，同じ管轄の中で複数の~proxyが利用されるときは
— 巨大~企業~networkの中の，各~~部署の~caching~proxyなど —
`~UA$により`生成-$された`資格証$が，消費されるまで階層を通過することは、
共通的にある。
よって，そのような環境設定の下では、
各~proxyが同じ`~field値$を送信することになり，
`Proxy-Authentication-Info^h は回送されているかのように出現することになる。
◎
However, unlike Authentication-Info, the Proxy-Authentication-Info header field applies only to the next outbound client on the response chain. This is because only the client that chose a given proxy is likely to have the credentials necessary for authentication. However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed. Hence, in such a configuration, it will appear as if Proxy-Authentication-Info is being forwarded because each proxy will send the same field value.
</p>

<p>
`Proxy-Authentication-Info^h は、
`認証~scheme$が明示的に許容するときには，`~trailer$として送信され得る（ `6.5§ ）。
◎
Proxy-Authentication-Info can be sent as a trailer field (Section 6.5) when the authentication scheme explicitly allows this.
</p>

			</section>
		</section>
	</section>
	<section id="content.negotiation">
<h2 title="Content Negotiation">12. 内容~折衝</h2>

<p>
`生成元~server$は、
応答~内に`内容$を伝達するとき
— 応答が成功, ~errorどちらを指示するにしても —
その情報を，いくつか異なる仕方で表現することが多い
— 例えば，異なる［
形式／言語／符号化法
］で。
また，［
能力／特性／選好
］は［
利用者や~UA
］ごとに異なり得るので、［
可用な`表現$のうち，どれを送達するのが最良になるか
］も変わり得る。
この理由から、
~HTTPは，`内容~折衝$用の仕組みをいくつか供する。
◎
When responses convey content, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
</p>

<div class="p">
<p>
この仕様は、
~protocolの中で可視にされ得る
`内容~折衝@
（ `content negotiation^en ）として，次の 3 種の~patternを定義する：
◎
This specification defines three patterns of content negotiation that can be made visible within the protocol:＼
</p>
<ul>
	<li>
`~proactive折衝$
⇒
`~server$が、
`~UA$が言明した選好に基づいて，`表現$を選定する。
◎
"proactive" negotiation, where the server selects the representation based upon the user agent's stated preferences;＼
</li>
	<li>
`~reactive折衝$
⇒
`~server$が、
`~UA$に選んでもらう`表現$たちが成す~listを供する。
◎
"reactive" negotiation, where the server provides a list of representations for the user agent to choose from;＼
</li>
	<li>
`要請~内容~折衝$
⇒
`~UA$が、
`~server$が過去の応答~内で言明した選好に基づいて，未来の要請~用の`表現$を選定する。
◎
and "request content" negotiation, where the user agent selects the representation for a future request based upon the server's stated preferences in past responses.
</li>
</ul>
</div>

<div class="p">
<p>
他の~patternによる`内容~折衝$には、
次に挙げるものが含まれる：
◎
Other patterns of content negotiation include＼
</p>
<ul>
	<li>
条件付き内容
⇒
`表現$は複数個の部分からなっていて、
各部分は
— ~UAの各種~parameterに基づいて —
選択的に具現化される。
◎
"conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters,＼
</li>
	<li>
能動的な内容
⇒
`表現$は~scriptを包含していて、
それが
— ~UAの特性に基づいて —
追加的な（より特定な）要請を為す。
◎
"active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and＼
</li>
	<li>
透過的な内容~折衝（ `Transparent Content Negotiation^en `RFC2295$r ）
⇒
`媒介者$が、
`内容$の選定を遂行する。
◎
"Transparent Content Negotiation" ([RFC2295]), where content selection is performed by an intermediary.＼
</li>
</ul>

<p>
これらの~patternは、
排他的ではない
— 各~patternには、
適用能と実用性の引換関係がある。
◎
These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
</p>
</div>

<p>
すべての事例において、
~HTTPは，`資源$の意味論を自覚しないことに注意。
要請に対し応答する`生成元~server$の［
時間~越し, および`内容~折衝$の様々な次元
］にわたる一貫性
— したがって、
時間~越しに資源に観測される，`表現$の “同じさ度合い” —
は、
全面的に［
それらの応答を［
選定する／`生成-$する
］実体や~algo
］により決定される。
◎
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses.
</p>

		<section id="proactive.negotiation">
<h3 title="Proactive Negotiation">12.1. ~proactive折衝</h3>

<div class="p">
<p>
`~proactive折衝@
（ `proactive negotiation^en ）と呼ばれる`内容~折衝$
（ “~server駆動な折衝” とも呼ばれる）
においては、
まず`~UA$が，要請~内に［
`~server$に所在する~algoに，選好される`表現$を選定するよう促す選好
］を送信する。
この選定は、
次の 2 つの比較対照に基づく：
◎
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called "proactive negotiation" (a.k.a., "server-driven negotiation"). Selection is based on＼
</p>
<ul>
	<li>
応答に可用な`表現$
（選好の次元は、
言語, `内容~符号法$, 等々，多様になり得る）。
◎
the available representations for a response (the dimensions over which it might vary, such as language, content coding, etc.) compared to＼
</li>
	<li>
要請~内に給される様々な情報。
これには、
以下に与える明示的な折衝~headerや，暗黙的な特性
— ~clientの~network~address, `User-Agent$h ~field値の各部など —
も含まれる。
◎
various information supplied in the request, including both the explicit negotiation header fields below and implicit characteristics, such as the client's network address or parts of the User-Agent field.
</li>
</ul>
</div>

<div class="p">
<p>
~proactive折衝は、
次のときに有利になる：
◎
Proactive negotiation is advantageous when＼
</p>
<ul>
	<li>
［
可用な`表現$の中から一つを選定するための~algo
］を，~UAに向けて述べるのが困難であるとき。
◎
the algorithm for selecting from among the available representations is difficult to describe to a user agent, or＼
</li>
	<li>
`~server$が，最初の応答にて［
~UAにとって “最良と推測される” もの
］を送信するよう欲するとき
（利用者にとり，その推測で十分良いなら、
これは，後続な要請の往復による遅延を避ける）。
◎
when the server desires to send its "best guess" to the user agent along with the first response (when that "best guess" is good enough for the user, this avoids the round-trip delay of a subsequent request).＼
</li>
</ul>

<p>
`~UA$は、
`~server$による推測を改善させるために，［
自身の選好を述べる要請~header
］を送信してもヨイ。
◎
In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.
</p>
</div>

<p>
~proactive折衝には、
深刻な不利がある：
◎
Proactive negotiation has serious disadvantages:
</p>
<ul>
	<li>
`~server$にとっては、［
任意の利用者にとって，何が “最良” になるか
］を正確aに決定することは，不可能である
— そのためには、［
~UAに備わる能力,
応答に対し意図される利用
（例： 利用者が求めているのは、［
~screen上で視る, 紙に印刷する
］のどっちか？）
］どちらについても，完全な知識を要求することになるので。
◎
It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);
</li>
	<li>
~UAが，毎回の要請にて自身に備わる能力を述べるとするなら、
とても非効率になり得る
（`表現$が複数あるのは、
ごく小さな割合の応答に限られる下では）。
更に、
利用者の~privacyに対する~riskも高くなり得る。
◎
Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;
</li>
	<li>
［
`生成元~server$,
要請に対する応答を生成する~algo
］の実装が複雑化する。
◎
It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,
</li>
	<li>
共用~cachingにおける応答の再利用-能は，制限される。
◎
It limits the reusability of responses for shared caching.
</li>
</ul>

<p>
`~UA$は、［
~proactive折衝による選好が一貫して尊守される
］ことに依拠できない
— `生成元~server$は、
要請された`資源$用には ~proactive折衝を実装していなかったり，［
~UAの選好に適合しない応答を送信する方が， `406$st 応答を送信するより良い
］と裁定することもあるので。
◎
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a 406 (Not Acceptable) response.
</p>

<p>
`Vary$h ~headerは、［
要請のどの部分の情報が，選定~algoに利用されるか
］を指示するために，［
~proactive折衝を~subjectとする応答
］内に送信されることが多い。
◎
A Vary header field (Section 12.5.5) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
</p>

<p>
以下に定義される［
`Accept$h, `Accept-Charset$h, `Accept-Encoding$h, `Accept-Language$h
］要請~headerは、［
応答`内容$の`~proactive折衝$
］に携わるために，`~UA$により送信され得る。
これらの~field内に送信される選好は、
次に挙げるものを含め，対する応答~内の どの内容にも適用される
⇒＃
`~target資源$の`表現$,
~errorや処理~状態sの`表現$,
~protocolの中に出現し得る 他の~text文字列
◎
The request header fields Accept, Accept-Charset, Accept-Encoding, and Accept-Language are defined below for a user agent to engage in proactive negotiation of the response content. The preferences sent in these fields apply to any content in the response, including representations of the target resource, representations of error or processing status, and potentially even the miscellaneous text strings that might appear within the protocol.
</p>

		</section>
		<section id="reactive.negotiation">
<h3 title="Reactive Negotiation">12.2. ~reactive折衝</h3>

<p>
`~reactive折衝@
（ `reactive negotiation^en ）と呼ばれる`内容~折衝$
（ “~agent駆動な折衝” とも呼ばれる）
においては、
`~UA$が，初期~応答を受信した後に`内容$の選定を遂行する（`状態s~code$に関わらず）。
~reactive折衝~用の仕組みは、［
代替~表現への参照
］たちが成す~listと~~同程度に単純なこともある。
◎
With "reactive negotiation" (a.k.a., "agent-driven negotiation"), selection of content (regardless of the status code) is performed by the user agent after receiving an initial response. The mechanism for reactive negotiation might be as simple as a list of references to alternative representations.
</p>

<p>
`~UA$は，初期~応答の`内容$で満足されない場合は、
異なる`表現$を得するために，一つ以上の代替な`資源$へ向けて `GET$m 要請を遂行できる。
そのような代替の選定は、
（~UAにより）自動的に遂行されることも，
（利用者が~hypertext~menuから選定することにより）手動で遂行されることもある。
◎
If the user agent is not satisfied by the initial response content, it can perform a GET request on one or more of the alternative resources to obtain a different representation. Selection of such alternatives might be performed automatically (by the user agent) or manually (e.g., by the user selecting from a hypertext menu).
</p>

<p>
`~server$は、［
代替~list以外の初期~表現を送信しないことを選ぶ
］ことにより［
`~UA$による~reactive折衝を選好する
］ことを指示することもある。
例えば，［
`300$st ／ `406$st
］を伴う応答~内に~listされる代替は、［
利用者または~UAが~reactiveに選定を行える`表現$として可用なもの
］についての情報を内包する。
◎
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the 300 (Multiple Choices) and 406 (Not Acceptable) status codes include information about available representations so that the user or user agent can react by making a selection.
</p>

<div class="p">
<p>
~reactive折衝は、
次のときに有利になる：
◎
Reactive negotiation is advantageous＼
</p>
<ul>
	<li>
応答が、
共通的に利用される次元（型【`~MIME型$】, 言語, 符号化法 など）にわたって，様々になり得るとき。
◎
when the response would vary over commonly used dimensions (such as type, language, or encoding),＼
</li>
	<li>
生成元~serverが、
要請を精査しても，~UAに備わる能力を決定できないとき。
◎
when the origin server is unable to determine a user agent's capabilities from examining the request, and＼
</li>
	<li>
一般に［
~server負荷を分散する／~network利用度を抑制する
］ために，
公共~cacheが利用されるとき。
◎
generally when public caches are used to distribute server load and reduce network usage.
</li>
</ul>
</div>

<p>
~reactive折衝には、
代替~listを~UAへ伝送する~~手間を要する不利がある
— それは、［
~listを`~header節$~内に伝送し，代替-表現を得するために 2 度目の要請を要する
］場合に，利用者に知覚される待時間を~~増やす。
更には、
この仕様は，自動的な選定を~supportする仕組みを定義しない
— そのような仕組みを開発することも~~止めないが。
◎
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed.
</p>

		</section>
		<section id="request.content.negotiation">
<h3 title="Request Content Negotiation">12.3. 要請~内容~折衝</h3>

<p>
`~server$が応答~内に`内容~折衝$の選好を送信するとき、
~listされた選好たちは，
`要請~内容~折衝@
（ `request content negotiation^en ）と呼ばれる
— それらは、［
当の`資源$に対する後続な要請~用の`内容$として適切なもの
］の選定に波及することが意図されるので。
例えば，［
`Accept$h ／ `Accept-Encoding$h
］~headerは、
当の資源に対する後続な要請~用に選好される［
`~MIME型$／`内容~符号法$
］を指示するため，応答~内に送信され得る。
◎
When content negotiation preferences are sent in a server's response, the listed preferences are called "request content negotiation" because they intend to influence selection of an appropriate content for subsequent requests to that resource. For example, the Accept (Section 12.5.1) and Accept-Encoding (Section 12.5.3) header fields can be sent in a response to indicate preferred media types and content codings for subsequent requests to that resource.
</p>

<p>
類似に， `5789/3.1$rfc は、
`Accept-Patch$h 応答~headerを定義する
— それは、［
`PATCH$m 要請にて受容される内容~型【`~MIME型$】
］の発見を許容する。
◎
Similarly, Section 3.1 of [RFC5789] defines the "Accept-Patch" response header field, which allows discovery of which content types are accepted in PATCH requests.
</p>

		</section>
		<section id="conneg.features">
<h3 title="Content Negotiation Field Features">12.4. 内容~折衝~fieldの特能</h3>

			<section id="conneg.absent">
<h4 title="Absence">12.4.1. 選好の不在</h4>

<p>
各 内容~折衝~fieldに対し、
それを包含しない要請は，［
当の~headerが表す［
折衝の次元
］に関しては、
`送信者$の選好は無い
］ことを含意する。
◎
For each of the content negotiation fields, a request that does not contain the field implies that the sender has no preference on that dimension of negotiation.
</p>

<p>
ある内容~折衝~headerが要請~内に在って，［
対する応答~用に可用な表現のうち，その~headerに則って受容-可能と見なせるもの
］は無い場合、
`生成元~server$は，［
`406$st 応答を送信して，その~headerを尊守する
］ことも［
応答を`内容~折衝$の~subjectではないかのように扱って，その~headerを無視rする
］こともできる。
しかしながら，これ【送信者の選好は無いこと】は、［
~clientは、
その表現を利用-可能になる
］ことを含意するものではない。
◎
If a content negotiation header field is present in a request and none of the available representations for the response can be considered acceptable according to it, the origin server can either honor the header field by sending a 406 (Not Acceptable) response or disregard the header field by treating the response as if it is not subject to content negotiation for that request header field. This does not imply, however, that the client will be able to use the representation.
</p>

<p class="note">注記：
~UAが これらの~headerを送信すると、
~serverにとっては，
~UAからの要請の特性から各個人を識別することが より容易になる（ `17.13§ ）。
◎
Note: A user agent sending these header fields makes it easier for a server to identify an individual by virtue of the user agent's request characteristics (Section 17.13).
</p>

			</section>
			<section id="quality.values">
<h4 title="Quality Values">12.4.2. 品質~値</h4>

<p>
この仕様が定義する内容~折衝~用の`~field$は、［
相対的な選好の “重み” を，結付けられる内容の種類にアテガう
］ために，［
`q$c と命名される（文字大小無視な）共通な~parameter
］を利用する。
この重みは、
同じ~parameter名が，~server環境設定の中で［
`資源$用に選定され得る様々な`表現$の，相対的な品質の重み
］をアテガうために利用されることが多いため、
`品質~値@
（ `quality value^en, 略して `qvalue^en ）
と称される。
◎
The content negotiation fields defined by this specification use a common parameter, named "q" (case-insensitive), to assign a relative "weight" to the preference for that associated kind of content. This weight is referred to as a "quality value" (or "qvalue") because the same parameter name is often used within server configurations to assign a weight to the relative quality of the various representations that can be selected for a resource.
</p>

<p>
重みは、
0 以上 1 以下の実数【小数部 3 桁以下の 10 進数】に正規化される
— ここで，値［
0.001 は最も選好されない／
1 は最も選好される／
0 は “受容-可能でない”
］ことを意味する。
`q$c ~parameterが無い場合の
`既定の重み@
は 1 とする。
◎
The weight is normalized to a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means "not acceptable". If no "q" parameter is present, the default weight is 1.
</p>

<pre class="bnf">
`weight@p
	= `OWS$p ";" `OWS$p "`q@c=" `qvalue$p
`qvalue@p
	= ( "0" [ "." 0*3`DIGIT$P ] )
	/ ( "1" [ "." 0*3("0") ] )
</pre>

<p>
`送信者$が，小数点の後に`生成-$する品質値の桁~数は、
3 以下でなければナラナイ。
利用者~環境設定における これらの値も，同じ流儀で制限される~OUGHT。
◎
A sender of qvalue MUST NOT generate more than three digits after the decimal point. User configuration of these values ought to be limited in the same fashion.
</p>

			</section>
			<section id="wildcard.values">
<h4 title="Wildcard Values">12.4.3. ~wildcard値</h4>

<p>
これらの~headerのほとんどは、
指示される所では，［
未指定な値を選定するための，~wildcard値（ "`*^c" ）
］を定義する。
~wildcardは無い場合、［
~clientは、
その~field内に明示的に挙げられなかった どの値も受容-不能である
］ものと見なされる。
ただし， `Vary$h の中では、
【挙げられなかった値（~field名）に対する】変動は制限されないことを意味する。
◎
Most of these header fields, where indicated, define a wildcard value ("*") to select unspecified values. If no wildcard is present, values that are not explicitly mentioned in the field are considered unacceptable. Within Vary, the wildcard value means that the variance is unlimited.
</p>

<p class="note">注記：
実施においては、
内容~折衝に利用される~wildcardの実用的な価値は，制限される
— 例えば、
“多少を問わず，何か（何らかの特定の値）より `image/*^c を選好します”
と言っても，有用になることは滅多にないので。
~clientは、
`Accept: */*;q=0^c
を送信することにより，［
より選好される形式は可用でない場合には、
`406$st0 応答を送信する
］よう明示的に要請できるが、
それでも，他の応答を取扱える必要がある
— ~serverには、
~clientの選好を無視することも許容されるので。
◎
Note: In practice, using wildcards in content negotiation has limited practical value because it is seldom useful to say, for example, "I prefer image/* more or less than (some other specific value)". By sending Accept: */*;q=0, clients can explicitly request a 406 (Not Acceptable) response if a more preferred format is not available, but they still need to be able to handle a different response since the server is allowed to ignore their preference.
</p>

			</section>
		</section>
		<section id="conneg.fields">
<h3 title="Content Negotiation Fields">12.5. 内容~折衝~field</h3>

			<section id="field.accept">
<h4>12.5.1. `Accept^h</h4>

<p>
`~UA$は、
`Accept^h ~headerを利用して，応答の`~MIME型$に関する自身の選好を指定できる。
例えば、
要請が［
自身が欲する型たちが成す小さな集合に，特定的に制限される
］ことを指示するときに利用できる
— ~inline画像~用の要請など。
◎
The "Accept" header field can be used by user agents to specify their preferences regarding response media types. For example, Accept header fields can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.
</p>

<p>
~serverにより送信された応答~内の `Accept^h は、［
同じ`資源$に対する後続な要請
］の`内容$には［
どの内容~型が選好されるか
］についての情報を供する。
◎
When sent by a server in a response, Accept provides information about which content types are preferred in the content of a subsequent request to the same resource.
</p>

<pre class="bnf">
`Accept@p
	= #( `media-range$p [ `weight$p ] )

`media-range@p
	= ( "*/*"
	    / ( `type$p "/" "*" )
	    / ( `type$p "/" `subtype$p )
	  ) `parameters$p
</pre>

<p>
`media-range$p における文字~asterisk "`*^c" は、
`~MIME型$たちをある範囲に~group化するために利用される
⇒＃
"`*/*^c" は，すべての~MIME型を指示する／
"%type`/*^c" は，~MIME型 %type を成すすべての下位型を指示する。
◎
The asterisk "*" character is used to group media types into ranges, with "*/*" indicating all media types and "type/*" indicating all subtypes of that type.＼
</p>

<p>
各 `media-range$p は、
末尾に `parameters$p
— 0 個以上の，その範囲に入る~MIME型に適用-可能な`~MIME型~parameter$（ `parameter$p ）
（例： "`charset^c" ） —
を内包し得る。
◎
The media-range can include media type parameters that are applicable to that range.
◎
Each media-range might be followed by optional applicable media type parameters (e.g., charset),＼
</p>

<p>
各 `media-range$p には、
省略可能な（ `weight$p を成す） `q$c ~parameterが後続し得る
— これは、
相対的な重み（`品質~値$）を指示する。
◎
followed by an optional "q" parameter for indicating a relative weight (Section 12.4.2).
</p>

<p>
以前の仕様は、
`weight$p ~parameterの後に，追加的な拡張~parameter（ `accept-params^p, `accept-ext^p ）が出現することを許容していた。
この拡張~文法は、
除去された
— それは、
定義を複雑化しており，
実施において利用されておらず，
新たな~headerを通して もっと容易に配備できるので。
◎
Previous specifications allowed additional extension parameters to appear after the weight parameter. The accept extension grammar (accept-params, accept-ext) has been removed because it had a complicated definition, was not being used in practice, and is more easily deployed through new header fields.＼
</p>

<p>
【 `parameters$p は `weight$p の構文も包摂するので、】
`weight$p を利用している`送信者$は、
最後に "`q^c" を送信するベキである
（ `media-range$p を成す すべての~parameterよりも後に）。
`受信者$は、
~parameterの順序付けを問わず，
"`q^c" と命名される~parameterが在るならば `weight$p として処理するベキである。
◎
Senders using weights SHOULD send "q" last (after all media-range parameters). Recipients SHOULD process any parameter named "q" as weight, regardless of parameter ordering.
</p>

<p class="note">注記：
`内容~折衝$を制御するための~parameter名 "`q^c" の利用は、
同じ名前を伴う`~MIME型~parameter$に干渉することになる。
よって、
~MIME型~registryは，
"`q^c" と命名される~parameterを許容しない。
◎
Note: Use of the "q" parameter name to control content negotiation would interfere with any media type parameter having the same name. Hence, the media type registry disallows parameters named "q".
</p>

<div class="example">
<p>
例：
◎
The example
</p>

<pre class="lang-http">
Accept: audio/*; q=0.2, audio/basic
</pre>

<p>
これは、
次の様に解釈される
⇒
“【`既定の重み$ 1 を伴う】 `audio/basic^c を選好しますが、
無ければ［
品質を `80%^ ~~落とした上で，最良に可用な `audio^c 型
］を（もしあれば）送信してください。”
◎
is interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% markdown in quality".
</p>
</div>

<div class="example">
<p>
より込み入った例：
◎
A more elaborate example is
</p>

<pre class="lang-http">
Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
</pre>

<p>
これは、
くだけて言えば，次の様に解釈されよう
⇒
“`~MIME型$ `text/html^c と `text/x-c^c を等しく選好しますが、
無ければ `text/x-dvi^c による表現を,
それも無ければ `text/plain^c による表現を送信してください”
◎
Verbally, this would be interpreted as "text/html and text/x-c are the equally preferred media types, but if they do not exist, then send the text/x-dvi representation, and if that does not exist, send the text/plain representation".
</p>
</div>

<p>
`media-range$p は、
より特定な［
`media-range$p ／ `~MIME型$
］で上書きできる。
所与の型に，複数の `media-range$p が適用されている場合、
最も特定な参照が優先される。
◎
Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept: text/*, text/plain, text/plain;format=flowed, */*
</pre>

<p>
の優先順は：
◎
have the following precedence:
</p>
<ol ><li>`text/plain;format=flowed^c
</li><li>`text/plain^c
</li><li>`text/*^c
</li><li>`*/*^c
</li></ol>
</div>

<p>
所与の型に結付けられる`~MIME型$の品質~係数は、［
型に合致する，最も優先される `media-range$p
］を見出すことにより決定される。
◎
The media type quality factor associated with a given type is determined by finding the media range with the highest precedence that matches the type.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
        text/plain;format=fixed;q=0.4, */*;q=0.5
</pre>

<p>
に対しては、
次に挙げる値が結付けられる：
◎
would cause the following values to be associated:
</p>

<div>
<table><thead>
<tr><td>~MIME型
<td>`品質~値$
<tbody>

<tr><td>`text/plain;format=flowed^c
<td>1

<tr><td>`text/plain^c
<td>0.7

<tr><td>`text/html^c
<td>0.3

<tr><td>`image/jpeg^c
<td>0.5

<tr><td>`text/plain;format=fixed^c
<td>0.4

<tr><td>`text/html;level=3^c
<td><del>0.7</del>
<ins>0.3</ins>【`7138$errata（Verified）】
</table>
◎
Table 5
Media Type 	Quality Value

text/plain;format=flowed 	1
text/plain 	0.7
text/html 	0.3
image/jpeg 	0.5
text/plain;format=fixed 	0.4
text/html;level=3 	0.7
</div>
</div>

<p class="note">注記：
~UAは、
ある種の範囲の~media用に，既定の［
`品質~値$たちが成す集合
］を供するかもしれない。
しかしながら，~UAが［
他の具現化~agentとヤリトリし得ない閉な~system
］でない限り、
この既定の集合は，利用者により環境設定-可能になる~OUGHT。
◎
Note: A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system that cannot interact with other rendering agents, this default set ought to be configurable by the user.
</p>
			</section>
			<section id="field.accept-charset">
<h4>12.5.2. `Accept-Charset^h</h4>

<p>
`~UA$は、
`Accept-Charset^h ~headerを送信して，［
~textな［
応答の`内容$
］における`~charset$
］に対する自身の選好を指示できる。
この~fieldは、
例えば次を~UAに許容する
⇒
［
より包括的な／より特別な目的~用の
］~charsetを解する能力がある場合に、
その能力を［
そのような~charsetで情報を表現する能力がある`生成元~server$
］へ通達する。
◎
The "Accept-Charset" header field can be sent by a user agent to indicate its preferences for charsets in textual response content. For example, this field allows user agents capable of understanding more comprehensive or special-purpose charsets to signal that capability to an origin server that is capable of representing information in those charsets.
</p>

<pre class="bnf">
`Accept-Charset@p
	= #( ( `token$p / "*" ) [ `weight$p ] )
</pre>

<p>
~charset名（ `token^p ）は、
`8.3.2§ にて定義される。
`~UA$は、
各~charsetに［
利用者の選好度を指示する`品質~値$
］を結付けてもヨイ。
◎
Charset names are defined in Section 8.3.2. A user agent MAY associate a quality value with each charset to indicate the user's relative preference for that charset, as defined in Section 12.4.2.＼
</p>

<div class="example">
<p>
例えば：
◎
An example is
</p>

<pre class="lang-http">
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</pre>
</div>

<p>
`Accept-Charset^h ~headerにおける特別な値 "`*^c" は、
在るならば，その~field内に挙げられていない どの`~charset$にも合致する。
◎
The special value "*", if present in the Accept-Charset header field, matches every charset that is not mentioned elsewhere in the field.
</p>

<p class="note">注記：
`Accept-Charset^h は、
非推奨にされた。
~UTF-8がほぼアタリマエになったことに加え，
利用者が選好する~charsetたちが成す詳細な~listの送信は［
帯域幅を浪費する,
待時間を増やす,
受動的な指紋収集をずっと容易にする（ `17.13§ ）
］ので。
ほとんどの一般用~UAは、
`Accept-Charset^h を送信しない
— そうするよう特定的に環境設定されない限り。
◎
Note: Accept-Charset is deprecated because UTF-8 has become nearly ubiquitous and sending a detailed list of user-preferred charsets wastes bandwidth, increases latency, and makes passive fingerprinting far too easy (Section 17.13). Most general-purpose user agents do not send Accept-Charset unless specifically configured to do so.
</p>

			</section>
			<section id="field.accept-encoding">
<h4>12.5.3. `Accept-Encoding^h</h4>

<p>
`Accept-Encoding^h ~headerは、
`内容~符号法$に関する選好を指示するために利用できる：
◎
The "Accept-Encoding" header field can be used to indicate preferences regarding the use of content codings (Section 8.4.1).
</p>
<ul>
	<li>
`~UA$により送信された要請~内の `Accept-Encoding^h は、
対する応答において受容-可能な`内容~符号法$を指示する。
◎
When sent by a user agent in a request, Accept-Encoding indicates the content codings acceptable in a response.
</li>
	<li>
`~server$により送信された応答~内の `Accept-Encoding^h は、［
同じ`資源$に対する後続な要請
］の`内容$には［
どの`内容~符号法$が選好されるか
］についての情報を供する。
◎
When sent by a server in a response, Accept-Encoding provides information about which content codings are preferred in the content of a subsequent request to the same resource.
</li>
</ul>

<p>
"`identity@c"
~tokenは、
選好する符号化は無いことを通信するための，
“符号化しない” の同義語として利用される。
◎
An "identity" token is used as a synonym for "no encoding" in order to communicate when no encoding is preferred.
</p>

<pre class="bnf">
`Accept-Encoding@p
	= #( `codings$p [ `weight$p ] )
`codings@p
	= `content-coding$p / "`identity$c" / "*"
</pre>

<p>
各 符号法~値（ `codings$p ）には、
`品質~値$（ `weight$p ）を与えてもヨイ
— それは、
その符号化法に結付けられる選好~度を表現する。
`Accept-Encoding^h ~header内の記号~asterisk "`*^c" は、
可用な`内容~符号法$のうち［
当の~field内に明示的に~listされなかったもの
］すべてに合致する。†a
◎
Each codings value MAY be given an associated quality value (weight) representing the preference for that encoding, as defined in Section 12.4.2. The asterisk "*" symbol in an Accept-Encoding field matches any available content coding not explicitly listed in the field.
</p>

<div class="example">
<p>
いくつかの例：
◎
Examples:
</p>

<pre class="lang-http">
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</pre>
</div>


				<section id="_request.accept-encoding">
<h5>12.5.3.1. 要請~内の `Accept-Encoding^h</h5>

<p>
`~server$は、
次の規則を利用して，［
所与の`表現$用の`内容~符号法$は，`~UA$にとって受容-可能になるかどうか
］を~testする：
◎
A server tests whether a content coding for a given representation is acceptable using these rules:
</p>
<ol>
	<li>
要請~内に `Accept-Encoding^h ~headerが無い場合、
どの`内容~符号法$も受容-可能であると見なされる。†b
◎
If no Accept-Encoding header field is in the request, any content coding is considered acceptable by the user agent.
</li>
	<li>
<p>
`表現$が`内容~符号法$を有さない場合、
`Accept-Encoding^h ~headerの`~field値$が ~OR↓ を満足する場合を除き，既定で受容-可能である：†c
◎
If the representation has no content coding, then it is acceptable by default unless specifically excluded by the Accept-Encoding header field stating either＼
</p>
		<ul>
			<li>
"`identity;q=0^c" を伴う
◎
"identity;q=0" or＼
</li>
			<li>
［
"`*;q=0^c" を伴う
］~AND［
明示的な品質値を伴う `identity^c を伴わない
］
◎
"*;q=0" without a more specific entry for "identity".
</li>
		</ul>

<p class="trans-note">【
"`identity$c" も内容~符号法の一種（恒等変換）と見なして，
表現が内容~符号法を有さないことを
“表現は内容~符号法 "`identity^c" を有する”
と解釈すれば、
この規則は，次項による規則の特別な場合と見なせる。
】</p>

	</li>
	<li>
`表現$の`内容~符号法$が［
`Accept-Encoding^h の`~field値$内に~listされているもの
］である場合、
それに`品質値$ 0 が付随していない限り，受容-可能である。
（`品質値$の定義により，値 0 は “受容-可能でない”ことを意味する）。†d
◎
If the representation's content coding is one of the content codings listed in the Accept-Encoding field value, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in Section 12.4.2, a qvalue of 0 means "not acceptable".)
</li>
	<li>
同じ`表現$は、
複数の`内容~符号法$で符号化されることもある。
しかしながら，ほとんどの`内容~符号法$は、
同じ目的（例：圧縮）を成遂げる代替な仕方である。
同じ目的を成す複数の`内容~符号法$から選定するときは、
受容-可能な`内容~符号法$のうち［
最も高い`品質値$（ ~NEQ 0 ）を伴うもの
］が選好される。†e
◎
A representation could be encoded with multiple content codings. However, most content codings are alternative ways to accomplish the same purpose (e.g., data compression). When selecting between multiple content codings that have the same purpose, the acceptable content coding with the highest non-zero qvalue is preferred.
</li>
</ol>

<div class="p">
<p>
`Accept-Encoding^h ~headerの`~field値$が空である場合、［
`~UA$は、
応答~内に どの`内容~符号法$も~~望まない
］ことを含意する。†f
</p>

<p>
`生成元~server$は、
~AND↓ が満たされる場合には，
`内容~符号法$を伴わない応答を送信するベキである：†g
</p>
<ul>
	<li>
要請~内に空でない `Accept-Encoding^h ~headerが在る
</li>
	<li>
対する応答に可用な どの`表現$も
受容-可能として~listされた`内容~符号法$を有さない
</li>
	<li>
`identity^c 符号法は受容-不能として指示されていない
【上の †c に述べた条件を満たしていない】
</li>
</ul>

◎
An Accept-Encoding header field with a field value that is empty implies that the user agent does not want any content coding in response.＼
If a non-empty Accept-Encoding header field is present in a request and＼
none of the available representations for the response have a content coding that is listed as acceptable,＼
the origin server SHOULD send a response without any content coding＼
unless the identity coding is indicated as unacceptable.
</div>

<div class="trans-note">

<p>【
~serverが，選好される内容~符号法を選定する手続きは、
以下のように定式化できよう：
】</p>

<p>
尚，ここでは、
"`identity^c" も内容~符号法の一種と見なす。
また、
以下に現れる “（†…）” は，上のどの規則が反映されているかを表す。
</p>

<p>
まず、［
受容-可能と見なされる内容~符号法たち, それらの各 品質値
］を以下に従って決定する：
</p>
<ol>
	<li>
<p>
%V ~LET 要請~内に `Accept-Encoding^h ~headerは［
在るならば その`~field値$ ／
無いならば "`*^c" （†b）
］
</p>

<p>
上の規則では、
%V の中に同じ内容~符号法（ あるいは "`*^c" ）が複数回
— 異なる品質~値を伴って —
現れる場合の挙動が指定されていない
— 以降では、
この種の競合は，次に挙げるような何らかの挙動により解消されたものと見做す
⇒＃
何らかの基準に従って，それらのうち一つに絞り、残りは %V から除去する／
それらをすべて %V から除去する／
構文~errorとして，~headerは無かったかのように扱う
</p>
	</li>
	<li>
%V は空ならば
⇒
%V ~SET "`identity$c" （†f）
</li>
	<li>
%V に~listされた［
内容~符号法／ "`*^c"
］のうち，品質値を伴わないものの品質値は、
`既定の重み$ 1 と見なす。
</li>
	<li>
%V に~listされなかった内容~符号法の品質値は、
次で与えられると見なす（†a, †c, †d, †f）
⇒＃
%V の中に "`*^c" が現れるならば，その品質値 ／
他の場合は 0
</li>
	<li>
<p>
%S ~LET 次に挙げる 2 つの集合の交差集合：
</p>
		<ul>
			<li>
既知な すべての内容~符号法（ "`identity$c" も含む）のうち，品質値が 0 でないもの
（すなわち，~UAが受容-可能なもの）
たちが成す集合（†a, †c, †d）
</li>
			<li>
応答に可用なすべての表現の内容~符号法たちが成す集合
（これは，通常は常に "`identity$c" を含むと思われるが、
~serverが強制的に他の内容~符号法のみに限定することも，あるかもしれない。）
</li>
		</ul>
	</li>
</ol>

<p>
応答に最も選好される内容~符号法は：
</p>
<ul>
	<li>
%S は空でないならば、
%S 内で品質値が最~大な内容~符号法たち（†e）。
</li>
	<li>
他の場合、
受容-可能な内容~符号法は無い（†g）
— その結果，~error応答（ `406$st など）が返され得る。
</li>
</ul>
</div>

				</section>
				<section id="_response.accept-encoding">
<h5>12.5.3.2. 応答~内の `Accept-Encoding^h</h5>

<p>
`Accept-Encoding^h ~headerが応答~内に在るときは、［
当の応答が応対した要請にて，当の`資源$が受容する用意があった`内容~符号法$たち
］を指示する。
その`~field値$は、
要請~内にあるときと同じ仕方で評価される。
◎
When the Accept-Encoding header field is present in a response, it indicates what content codings the resource was willing to accept in the associated request. The field value is evaluated the same way as in a request.
</p>

<p>
この情報は、
当の応答が応対した要請に特有であることに注意。
~supportされる符号化法たちが成す集合は、
同じ~server上の他の`資源$用のそれとは異なるかもしれない。
また、
時間~越しに変化したり，要請の他の側面（`要請~method$など）に依存することもある。
◎
Note that this information is specific to the associated request; the set of supported encodings might be different for other resources on the same server and could change over time or depend on other aspects of the request (such as the request method).
</p>

<p>
所与の`内容~符号法$を~supportしないことに因り，要請に対し失敗した`~server$は、
`415$st で応答する~OUGHT。
加えて、［
当の課題が［
内容~符号法, ~MIME型
］のどちらに関係するか判別する
］ことを`~client$に許容するよう，
そのような応答には `Accept-Encoding^h ~headerを内包する~OUGHT。
~MIME型に関係する課題との混同を避けるため、
`~server$は，［
`内容~符号法$とは無関係な事由で失敗した結果，要請に対し `415$st0 で応答する
］ときは、
`Accept-Encoding^h ~headerを内包してはナラナイ。
◎
Servers that fail a request due to an unsupported content coding ought to respond with a 415 (Unsupported Media Type) status and include an Accept-Encoding header field in that response, allowing clients to distinguish between issues related to content codings and media types. In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.
</p>

<p>
`Accept-Encoding^h は、［
`~client$による`内容~符号法$の楽観的な利用に対する， `415$st 応答
］内で最も共通的に利用される。
しかしながら，この~headerは、
未来のヤリトリを最適化するために，［
`内容~符号法$が~supportされることを~clientに指示する
］ためにも利用できる。
例えば，［
要請の`内容$は，圧縮~符号法の利用を正当化するほど十分に大きかったが、
~clientは，そうすることに失敗した
］とき、
当の`資源$は， `2xx$st 応答~内に この~headerを内包するかもしれない。
◎
The most common use of Accept-Encoding is in responses with a 415 (Unsupported Media Type) status code, in response to optimistic use of a content coding by clients. However, the header field can also be used to indicate to clients that content codings are supported in order to optimize future interactions. For example, a resource might include it in a 2xx (Successful) response when the request content was big enough to justify use of a compression coding but the client failed do so.
</p>

				</section>
			</section>
			<section id="field.accept-language">
<h4>12.5.4. `Accept-Language^h</h4>

<p>
`~UA$は、
`Accept-Language^h ~headerを利用して，次を指示できる
⇒
応答にて選好される自然~言語（`言語~tag$）たちが成す集合
◎
The "Accept-Language" header field can be used by user agents to indicate the set of natural languages that are preferred in the response. Language tags are defined in Section 8.5.1.
</p>

<pre class="bnf">
`Accept-Language@p
	= #( `language-range$p [ `weight$p ] )
`language-range@p
	= &lt;language-range, `4647/2.1$rfc&gt;
</pre>

【！ Errata ID: 4734 Rejected】

<p>
各 `language-range$p には、
次を与えれる
⇒
［
それが指定する言語~範囲
］に結付けられる［
利用者の選好についての見積もり
］を表現する`品質~値$
◎
Each language-range can be given an associated quality value representing an estimate of the user's preference for the languages specified by that range, as defined in Section 12.4.2.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept-Language: da, en-gb;q=0.8, en;q=0.7
</pre>

<p>
は、
次を意味することになる
⇒
“~Danishを選好しますが，英国~英語や他~種の英語も受容します”。
◎
would mean: "I prefer Danish, but will accept British English and other types of English".
</p>
</div>

<p>
一部の`受信者$は
— 特に，等しい`品質~値$がアテガわれた`言語~tag$たちに対し —
`言語~tag$が~listされた順序を，優先度~順の指示として扱うことに注意
（どの~tagの品質値も 1 でなくなる）。
しかしながら、
この挙動には依拠できない。
多くの~UAは、
一貫性を得るため, および 相互運用能を最大化するため、
各`言語~tag$に一意な`品質~値$をアテガった上で，それらを品質の降順で~listする。
言語~優先度~listについての追加的な論点は、
`4647/2.3$rfc に見出せる。
◎
Note that some recipients treat the order in which language tags are listed as an indication of descending priority, particularly for tags that are assigned equal quality values (no value is the same as q=1). However, this behavior cannot be relied upon. For consistency and to maximize interoperability, many user agents assign each language tag a unique quality value while also listing them in order of decreasing quality. Additional discussion of language priority lists can be found in Section 2.3 of [RFC4647].
</p>

<p>
`4647/3$rfc は、
数種の照合~schemeを，照合~用に定義している。
実装は、
自身の要件に最も適切な照合~schemeを提供できる。
"Basic Filtering" ~scheme（ `4647/3.3.1$rfc ）は、
以前に［
`2616/14.4$rfc にて，~HTTP用として定義された照合~scheme
］と一致する。
◎
For matching, Section 3 of [RFC4647] defines several matching schemes. Implementations can offer the most appropriate matching scheme for their requirements. The "Basic Filtering" scheme ([RFC4647], Section 3.3.1) is identical to the matching scheme that was previously defined for HTTP in Section 14.4 of [RFC2616].
</p>

<p>
毎~要請ごとに［
完全な，利用者の言語上の選好
］を伴う `Accept-Language^h ~headerを送信するのは、
利用者が期待する~privacyに反し得る（ `17.13§ ）。
◎
It might be contrary to the privacy expectations of the user to send an Accept-Language header field with the complete linguistic preferences of the user in every request (Section 17.13).
</p>

<p>
言語の理解度は，個々の利用者に大きく依存するので、
`~UA$は，言語上の選好を制御することを利用者に許容する必要がある
（~UAの環境設定を通して, あるいは 利用者が制御できる~system設定による既定により）。
そのような制御を利用者に供さない`~UA$は、
`Accept-Language^h ~headerを送信してはナラナイ。
◎
Since intelligibility is highly dependent on the individual user, user agents need to allow user control over the linguistic preference (either through configuration of the user agent itself or by defaulting to a user controllable system setting). A user agent that does not provide such control to the user MUST NOT send an Accept-Language header field.
</p>

<p class="note">注記：
`~UA$は、
選好の設定~時に，利用者~向けの指導を供する~OUGHT
— 利用者が，上に述べた言語~照合の詳細~に~~馴染んでいることは、
稀なので。
例えば，利用者は、［
"`en-gb^c" を選定すれば、
英国~英語が可用でなくても，どの種類の英語~文書であれ~serveされるようになる
］ものと見做すかもしれない。
~UAは，そのような事例では、
照合の挙動を もっと良くするためとして，
~listに "`en^c" を追加するよう示唆できる。
◎
Note: User agents ought to provide guidance to users when setting a preference, since users are rarely familiar with the details of language matching as described above. For example, users might assume that on selecting "en-gb", they will be served any kind of English document if British English is not available. A user agent might suggest, in such a case, to add "en" to the list for better matching behavior.
</p>

			</section>
			<section id="field.vary">
<h4>12.5.5. `Vary^h</h4>

<p>
応答~内の `Vary^h ~headerは、［
~method／`~target~URI$
］の他に，応対した要請~messageを成すどの部分が［
`生成元~server$による，この応答の`内容$を選定するための処理n
］に波及し得たかを述べる。
◎
The "Vary" header field in a response describes what parts of a request message, aside from the method and target URI, might have influenced the origin server's process for selecting the content of this response.
</p>

<pre class="bnf">
`Vary@p
	= #( "*" / `field-name$p )
</pre>

<p>
`Vary^h の`~field値$は，`~listに基づく~field$であり、
それを成す各~memberは，
~wildcard "`*^c" または［
`選定用~header@
（ `selecting header field^en ）とも呼ばれる，この応答~用の`表現$を選定する役割を担い得た要請~field名
］を与える。
選定用~headerになり得るものは、
この仕様が定義する~fieldに制限されない。
◎
A Vary field value is either the wildcard member "*" or a list of request field names, known as the selecting header fields, that might have had a role in selecting the representation for this response. Potential selecting header fields are not limited to fields defined by this specification.
</p>

<p>
この~listが "`*^c" を包含する場合、
要請の他の側面
— 場合によっては、
~message構文の外側にある側面も含む
（例：~clientの~network~address） —
が，応答の`表現$を選定する役割を担い得たことを通達する。
`受信者$は、
この応答が今後の【以前の要請と一致する】要請にも適切になるかどうかを
— 要請を`生成元~server$へ回送しない限り —
決定できないことになる。
`~proxy$は、
`Vary^h の`~field値$内に "`*^c" を`生成-$してはナラナイ。
◎
A list containing the member "*" signals that other aspects of the request might have played a role in selecting the response representation, possibly including aspects outside the message syntax (e.g., the client's network address). A recipient will not be able to determine whether this response is appropriate for a later request without forwarding the request to the origin server. A proxy MUST NOT generate "*" in a Vary field value.
</p>

<div class="example">
<p>
例えば，次を包含する応答は：
◎
For example, a response that contains
</p>

<pre class="lang-http">
Vary: accept-encoding, accept-language
</pre>

<p>
次を指示する
⇒
`生成元~server$は、
この応答~用の`内容$を選ぶ決定要因として，要請の［
`Accept-Encoding$h, `Accept-Language$h
］~header（または それらの欠如）を利用したかもしれない
◎
indicates that the origin server might have used the request's Accept-Encoding and Accept-Language header fields (or lack thereof) as determining factors while choosing the content for this response.
</p>
</div>

<p>
`~field名$たちが成す~listを包含している `Vary^h ~fieldには、
次に挙げる 2 つの目的がある：
◎
A Vary field containing a list of field names has two purposes:
</p>
<ul>
	<li>
<p>
`~cache$たちに，次を伝える
⇒
この応答は、
~OR↓ が満たされない限り，
今後の要請を満足するために利用してはナラナイ：
◎
To inform cache recipients that they MUST NOT use this response to satisfy a later request unless
</p>
<ul>
	<li>
要請は、
~listされた~headerについて，元の要請と同じ値をとる
（ `CACHING$r `4.1＠~HTTPcache#caching.negotiated.responses§ ）
◎
the later request has the same values for the listed header fields as the original request (Section 4.1 of [CACHING]) or＼
</li>
	<li>
当の応答の再利用は、`生成元~server$により検証-済みである
◎
reuse of the response has been validated by the origin server.＼
</li>
</ul>

<p>
言い換えれば `Vary^h は、［
新たな要請が，格納-済みな~cache~entryに合致する
］ために要求される~cache~keyを拡げる。
◎
In other words, Vary expands the cache key required to match a new request to the stored cache entry.
</p>
	</li>
	<li>
`~UA$に，次を伝える
⇒
この応答は，`内容~折衝$の~subjectであったので、
~listされたいずれかの~header内に他の値が供される場合には，
後続な要請に対し異なる`表現$が送信され得る（`~proactive折衝$）。
◎
To inform user agent recipients that this response was subject to content negotiation (Section 12) and a different representation might be sent in a subsequent request if other values are provided in the listed header fields (proactive negotiation).
</li>
</ul>

<p>
`生成元~server$は、［
`~cache可能$な応答に対し，後続な要請~用にも選択的に再利用するよう望む
］ときは，
`Vary^h ~headerを`生成-$するベキである。
これに該当する事例は、
一般に，当の応答の`内容$が［
その`選定用~header$により表出される選好に，より良く収まる
］よう誂えられたときである
— 生成元~serverが［
要請の `Accept-Language$h ~headerに基づいて応答の言語を選定したとき
］など。
◎
An origin server SHOULD generate a Vary header field on a cacheable response when it wishes that response to be selectively reused for subsequent requests. Generally, that is the case when the response content has been tailored to better fit the preferences expressed by those selecting header fields, such as when an origin server has selected the response's language based on the request's Accept-Language header field.
</p>

<p>
`Vary^h は、
次に該当する場合には省かれるかもしれない
⇒
`生成元~server$は、［
`Vary^h による~cachingに対する処理能の影響iの方が，
内容~選定における変動より有意である
］と見なすとき
— 特に、
応答`~cache指令$により，すでに再利用が制限されているとき。
◎
Vary might be elided when an origin server considers variance in content selection to be less significant than Vary's performance impact on caching, particularly when reuse is already limited by cache response directives (Section 5.2 of [CACHING]).
</p>

<p>
`~field名$ `Authorization$h は、［
その定義により，複数~利用者にまたがる応答の再利用が禁制される
］ので， `Vary^h 内に送信する必要はない。
同様に，応答の`内容$は~network領域†により［
選定された／波及された
］が，`生成元~server$は［
`受信者$が ある領域から別の領域へ移動した場合でも，~cache済み応答が再利用される
］よう求める場合、
生成元~serverは， `Vary^h 内でそのような変動を指示する必要はない。
◎
There is no need to send the Authorization field name in Vary because reuse of that response for a different user is prohibited by the field definition (Section 11.6.2). Likewise, if the response content has been selected or influenced by network region, but the origin server wants the cached response to be reused even if recipients move from one region to another, then there is no need for the origin server to indicate such variance in Vary.
</p>

<p class="trans-note">【†
`network region^en
— 何らかの正式な定義がある用語なのかどうか，定かでない。
】</p>

			</section>
		</section>
	</section>
	<section id="conditional.requests">
<h2 title="Conditional Requests">13. 条件付き要請</h2>

<p>
`条件付き要請@
（ `conditional request^en ）とは、
1 個~以上の`条件付き要請~header$を伴う~HTTP要請である。
`条件付き要請~header@†
とは、
`事前条件$
— 要請~methodを`~target資源$に適用する前に~testされることになる条件 —
を指示する要請~headerである。
事前条件をいつ評価するか, 事前条件が複数個~在るときの それらの優先順は、
`事前条件の評価§にて定義される。
◎
A conditional request is an HTTP request with one or more request header fields that indicate a precondition to be tested before applying the request method to the target resource. Section 13.2 defines when to evaluate preconditions and their order of precedence when more than one precondition is present.
</p>

<p class="trans-note">【†
“事前条件~header” とも称される。
これら 2 つの用語は、
同義と見受けられる
（その差異は、この仕様からは読み取れない）。
】【
［
条件付き要請／条件付き~header
］は、
単に
“条件付き”
とも総称される
（文脈に応じて，どちらか適切な方を指すであろう）。
】</p>

<p>
条件付き `GET$m 要請は、
~HTTP~cache更新 `CACHING$r 用の効率的な仕組みの大部分を~~占める。
条件付きは、
“`更新喪失@”
問題
— 並列的に動作している ある~clientが，別の~clientによる成果を偶発的に上書きすること —
を防止するために，［
`PUT$m や `DELETE$m などの状態変更~method
］にも適用され得る／できる。
◎
Conditional GET requests are the most efficient mechanism for HTTP cache updates [CACHING]. Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the "lost update" problem: one client accidentally overwriting the work of another client that has been acting in parallel.
</p>

		<section id="preconditions">
<h3 title="Preconditions">13.1. 事前条件</h3>

<p>
`事前条件@
（ `precondition^en ）は、
通例的に［
一体としての`~target資源$の状態（その現在の値~集合）
］あるいは［
以前に得された`表現$において観測された状態
（その集合~内の 1 つの値）
］に関して定義される。
ある資源に現在の表現が複数あって，
それぞれが自前の観測-可能な状態を伴う場合、
事前条件は，［
各~要請から`選定される表現$への対応付けは、
時間~越しに一貫する
］ものと見做すことになる。
いずれにせよ、［
対応付けが一貫しない場合／~serverが適切な`表現$を選定-不能になった場合
］でも，［
事前条件が ~F に評価されるとき
］には結果が害になることはない。
◎
Preconditions are usually defined with respect to a state of the target resource as a whole (its current value set) or the state as observed in a previously obtained representation (one value in that set). If a resource has multiple current representations, each with its own observable state, a precondition will assume that the mapping of each request to a selected representation (Section 3.2) is consistent over time. Regardless, if the mapping is inconsistent or the server is unable to select an appropriate representation, then no harm will result when the precondition evaluates to false.
</p>

<p>
以下に定義される各種 `事前条件$は、［
先立つ［
`~target資源$の各`表現$
］から得された`検証子$たちが成す集合
］と［
`選定される表現$用の`検証子$たちの現在の状態
］との比較からなる（ `8.8§ ）。
よって，これらの事前条件は、
`~target資源$の状態が［
`~client$に既知な，所与の状態
］から変化したかどうかを評価する。
そのような評価の効果は、
`事前条件の評価§にて定義されるとおり，［
~methodの意味論, `条件付き要請~header$の選択
］に依存する。
◎
Each precondition defined below consists of a comparison between a set of validators obtained from prior representations of the target resource to the current state of validators for the selected representation (Section 8.8). Hence, these preconditions evaluate whether the state of the target resource has changed since a given state known by the client. The effect of such an evaluation depends on the method semantics and choice of conditional, as defined in Section 13.2.
</p>

<p>
他の仕様により拡張~fieldとして定義される，他の`事前条件$は、［
すべての`受信者$／
一般におけるs`~target資源$の状態／
`資源$たちが成す~group
］に対し，条件を設置することもある。
一例として， WebDAV における `If$h ~header `WEBDAV$r は、
複数の資源にわたる様々な側面
— `~lock$など —
に対し，要請を条件付きにし得る
— 受信者が当の~fieldを解する, かつ実装するならば。
◎
Other preconditions, defined by other specifications as extension fields, might place conditions on all recipients, on the state of the target resource in general, or on a group of resources. For instance, the "If" header field in WebDAV can make a request conditional on various aspects of multiple resources, such as locks, if the recipient understands and implements that field ([WEBDAV], Section 10.4).
</p>

<div class="p">
<p>
`事前条件$の拡張能がアリになるのは、
次に挙げるときに限られる：
◎
Extensibility of preconditions is only possible＼
</p>
<ul>
	<li>
【受信者は、】
当の事前条件が未知な場合には，安全に無視できる
（例： `If-Modified-Since$h ）。
◎
when the precondition can be safely ignored if unknown (like If-Modified-Since),＼
</li>
	<li>
［
所与の利用事例~用の配備は在る
］ものと見做せる。
◎
when deployment can be assumed for a given use case,＼
</li>
	<li>
`~target資源$を成す他の何らかの~propertyにより，【当の事前条件の】実装が通達される。
◎
or when implementation is signaled by some other property of the target resource.＼
</li>
</ul>
<p>
このことは、
相互に同意された共通な標準の配備に注力するよう奨励する。
◎
This encourages a focus on mutually agreed deployment of common standards.
</p>
</div>

			<section id="field.if-match">
<h4>13.1.1. `If-Match^h</h4>

<p>
`If-Match^h ~headerは、
`受信者$である`生成元~server$に対し，`要請~method$を次による条件付きにする：
◎
The "If-Match" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`~target資源$の現在の`表現$からなる集合を %S とするとき、
`~field値$に応じて：
◎
the recipient origin server either＼
</p>
		<ul class="switch" id="condition-If-Match">
			<li>
"`*^c" の場合
⇒
%S は空でない。
◎
having at least one current representation of the target resource, when the field value is "*", or＼
</li>
			<li>
`実体~tag$たちが成す~listである場合
⇒
%S 内に［
~list内の ある~memberに合致する`実体~tag$
］を有するものが在る。
◎
having a current representation of the target resource that has an entity tag matching a member of the list of entity tags provided in the field value.
</li>
		</ul>
	</li>
	<li>
`生成元~server$は、
`If-Match^h 用の`実体~tag$を比較するときには，`強い比較~関数$を利用しなければナラナイ
— `~client$が この`事前条件$に意図しているのは、［
`表現~data$に何か変化があった場合には，~methodを適用しない
］ことなので。
◎
An origin server MUST use the strong comparison function when comparing entity tags for If-Match (Section 8.8.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.
</li>
</ul>

<pre class="bnf">
`If-Match@p
	= "*" / #`entity-tag$p
</pre>

<div class="example">
<p>
いくつかの例：
◎
Examples:
</p>

<pre class="lang-http">
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
</pre>
</div>

<p>
`If-Match^h は、［
同じ`資源$に対し，複数の~UAが並列的に動作し得る
］ときの，偶発的な上書-（すなわち， “`更新喪失$” 問題）を防止するために，
状態変更~method（例：`POST$m, `PUT$m, `DELETE$m ）と伴に利用されることが最も多い。
一般に， `If-Match^h は、
`表現$の［
選定／改変
］を孕むような どの~methodと伴にも，次のために利用できる
⇒
`選定された表現$の現在の`実体~tag$が
`If-Match^h の`~field値$を成す~memberでない場合には、
当の要請を中止する
◎
If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the "lost update" problem). In general, it can be used with any method that involves the selection or modification of a representation to abort the request if the selected representation's current entity tag is not a member within the If-Match field value.
</p>

<p>
`生成元~server$は、
受信した要請が［
ある表現を選定するものであって，
`If-Match^h ~headerを内包する
］ときは
— 要請の~methodを遂行するに先立って，`事前条件の評価§に従う下で —
その~field値に与えられた`前述の条件＠#condition-If-Match$を評価しなければナラナイ
— 条件が ~F に評価された場合：
◎
When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.
◎
To evaluate a received If-Match header field:
• If the field value is "*", the condition is true if the origin server has a current representation for the target resource.
• If the field value is a list of entity tags, the condition is true if any of the listed tags match the entity tag of the selected representation.
• Otherwise, the condition is false.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false.＼
</li>
	<li>
代わりに、
`状態s~code$ `412$st で応答して，
当の条件付き要請は失敗したことを指示してもヨイ。
◎
Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code.＼
</li>
	<li>
<p>
［
当の要請は状態変更~演算であり、
`選定される表現$には，すでに適用されたように出現している場合
］には、
前項に代えて，`状態s~code$ `2xx$st で応答してもヨイ
（すなわち，~UAから要請された変更はすでに成功したが、
たぶん［
先立つ応答~messageが失われた／他の~UAにより等価な変更が為された
］ため，~UAは それに気付かなかった）。
◎
Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).
</p>

<p>
これを許容することで，多くの著作~利用事例は より効率的になるが、［
複数の~UAが，よく似るが協力的でない変更~要請を為している場合
］には，~riskも伴われる。
例えば、
複数の~UAが，共通な`資源$に対し~semaphoreとして書込んでいると（例：可分な増分）、
衝突する見込みが高く，重要な状態~遷移が失われかねない。
そのような種類の資源~用には、
厳格に［
~methodが`安全$でない場合は、
失敗した どの事前条件に対しても `412$st0 を送信する
］方が良い。
他の事例【`安全$な場合】では、
当の資源の現在の状態についての混同を排するよう，成功~応答から `ETag$h ~fieldを除外すれば、
次回の要請として `GET$m を遂行するよう~UAに奨励するかもしれない。
◎
Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. For example, multiple user agents writing to a common resource as a semaphore (e.g., a nonatomic increment) are likely to collide and potentially lose important state transitions. For those kinds of resources, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method. In other cases, excluding the ETag field from a success response might encourage the user agent to perform a GET as its next request to eliminate confusion about the resource's current state.
</p>
	</li>
</ul>

<p>
`~client$は、［
`選定された表現$が合致しない場合には， `412$st 応答を選好する
］ことを指示するためとして，
`GET$m 要請~内に `If-Match^h ~headerを送信してもヨイ。
しかしながら，これが有用になるのは、［
以前に受信した部分的な`表現$を完全~化するため，新たな表現は欲されないとき
］の`範囲~要請$に限られる。
~clientが範囲~要請にて新たな表現を受信する方を選好する場合、
`If-Range$h の方が適する。
◎
A client MAY send an If-Match header field in a GET request to indicate that it would prefer a 412 (Precondition Failed) response if the selected representation does not match. However, this is only useful in range requests (Section 14) for completing a previously received partial representation when there is no desire for a new representation. If-Range (Section 13.1.5) is better suited for range requests when the client prefers to receive a new representation.
</p>

<p>
［
`~cache$／`媒介者$
］は、
`If-Match^h ~headerを無視してもヨイ
— その相互運用能を得る特能が必要yであるのは、
`生成元~server$に限られるので。
◎
A cache or intermediary MAY ignore If-Match because its interoperability features are only necessary for an origin server.
</p>

<p>
`If-Match^h ~headerに［
"`*^c" と他の値（ "`*^c" も含む）
］を包含している~list値が伴われる場合、
構文として妥当でない（したがって、`生成-$することは許容されない）ことに加え，
相互運用可能にならない見込みが高いことに注意。
◎
Note that an If-Match header field with a list value containing "*" and other values (including other instances of "*") is syntactically invalid (therefore not allowed to be generated) and furthermore is unlikely to be interoperable.
</p>

			</section>
			<section id="field.if-none-match">
<h4>13.1.2. `If-None-Match^h</h4>

<div class="p">
<p>
`If-None-Match^h ~headerは、
`受信者$である［
`~cache$／`生成元~server$
］に対し，`要請~method$を次による条件付きにする：
◎
The "If-None-Match" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`~target資源$の現在の`表現$からなる集合を %S とするとき、
`~field値$に応じて：
◎
a recipient cache or origin server either＼
</p>
		<ul class="switch" id="condition-If-None-Match">
			<li>
"`*^c" の場合
⇒
%S は空である。
◎
not having any current representation of the target resource, when the field value is "*", or＼
</li>
			<li>
`実体~tag$たちが成す~listである場合
⇒
%S 内で`選定される表現$として［
~list内の ある~memberに合致する`実体~tag$
］を有するものはない。
◎
having a selected representation with an entity tag that does not match any of those listed in the field value.
</li>
		</ul>
	</li>
	<li>
`受信者$は、
`If-None-Match^h 用に`実体~tag$を比較するときには，
`弱い比較~関数$を利用しなければナラナイ
— `弱い検証子$である`実体~tag$は、
`表現~data$が変化したとしても，`~cache検証$に利用できるので。
◎
A recipient MUST use the weak comparison function when comparing entity tags for If-None-Match (Section 8.8.3.2), since weak entity tags can be used for cache validation even if there have been changes to the representation data.
</li>
</ul>
</div>

<pre class="bnf">
`If-None-Match@p
	= "*" / #`entity-tag$p
</pre>

<div class="example">
<p>
いくつかの例：
◎
Examples:
</p>

<pre class="lang-http">
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
</pre>
</div>

<p>
`If-None-Match^h は、
首に，条件付き `GET$m 要請にて
— ~transactionの~overheadを最小に~~抑えて，
~cache済み情報の効率的な更新を可能化するために —
利用される。
`~client$は、
1 個以上の［
`実体~tag$を有する格納-済み応答
］の更新を欲するときは，
`GET$m 要請を為すときに［
それらの`実体~tag$からなる~listを包含する，
`If-None-Match^h ~header
］を`生成-$するベキである
— これは、
`受信者$である~serverに次を許容する
⇒
それら格納-済み応答のいずれかが，`選定された表現$に合致したとき、
そのことを指示する `304$st 応答を送信する。
◎
If-None-Match is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead. When a client desires to update one or more stored responses that have entity tags, the client SHOULD generate an If-None-Match header field containing a list of those entity tags when making a GET request; this allows recipient servers to send a 304 (Not Modified) response to indicate when one of those stored responses matches the selected representation.
</p>

<p>
`If-None-Match^h は、
`安全$でない`要請~method$（例： `PUT$m ）にも，値 "`*^c" を伴わせて利用できる
— これにより，`~client$は、
`資源$が現在の`表現$を有さないものと予見できるときに，
`~target資源$の既存の表現を不作為に改変することを防止できる。
これは、［
~~複数の~clientが，`~target資源$に対する初期~表現を作成するよう試みた
］ときに発生し得る， “`更新喪失$” 問題の一種である。
◎
If-None-Match can also be used with a value of "*" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (Section 9.2.1). This is a variation on the "lost update" problem that might arise if more than one client attempts to create an initial representation for the target resource.
</p>

<p>
`生成元~server$は、
受信した要請が［
ある表現を選定するものであって，
`If-None-Match^h ~headerを内包する
］ときは
— ~methodを遂行するに先立って，`事前条件の評価§に従う下で —
その~field値に与えられた`前述の条件＠#condition-If-None-Match$を
評価しなければナラナイ
— 条件が ~F に評価された場合：
◎
When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.
◎
To evaluate a received If-None-Match header field:
• If the field value is "*", the condition is false if the origin server has a current representation for the target resource.
• If the field value is a list of entity tags, the condition is false if one of the listed tags matches the entity tag of the selected representation.
• Otherwise, the condition is true.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server that evaluates an If-None-Match condition MUST NOT perform the requested method if the condition evaluates to false;＼
</li>
	<li>
代わりに、
`要請~method$に応じて，［
`GET$m または `HEAD$m ならば `304$st ／
他の場合は `412$st
］で応答しなければナラナイ。
◎
instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.
</li>
</ul>

<p>
`~cache$が受信した `If-None-Match^h ~headerの取扱いに課される要件は、
`CACHING$r `受信した検証~要請の取扱い＠~HTTPcache#validation.received§
にて定義される。
◎
Requirements on cache handling of a received If-None-Match header field are defined in Section 4.3.2 of [CACHING].
</p>

<p>
`If-None-Match^h ~headerに［
"`*^c" と他の値（別の "`*^c" も含む）
］を包含している~list値が伴われる場合、
構文として妥当でない（したがって、`生成-$することは許容されない）ことに加え，
相互運用可能にならない見込みが高いことに注意。
◎
Note that an If-None-Match header field with a list value containing "*" and other values (including other instances of "*") is syntactically invalid (therefore not allowed to be generated) and furthermore is unlikely to be interoperable.
</p>

			</section>
			<section id="field.if-modified-since">
<h4>13.1.3. `If-Modified-Since^h</h4>

<div class="p">
<p>
`If-Modified-Since^h ~headerは、［
`GET$m ／ `HEAD$m
］要請~methodを，次による条件付きにする：
◎
The "If-Modified-Since" header field makes a GET or HEAD request method conditional on＼
</p>
<ul id="condition-If-Modified-Since">
	<li>
`選定された表現$の最後の`改変~日時$は、
`~field値$が供する日時より近過去である。
◎
the selected representation's modification date being more recent than the date provided in the field value.＼
</li>
</ul>

<p>
`選定された表現$の~dataが変更されていない場合、
その転送を避けれるようになる。
◎
Transfer of the selected representation's data is avoided if that data has not changed.
</p>
</div>

<pre class="bnf">
`If-Modified-Since@p
	= `HTTP-date$p
</pre>

<div class="example">
<p>
~fieldの例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
`受信者$は、
要請が `If-None-Match$h ~headerも包含する場合には，
`If-Modified-Since^h を無視しなければナラナイ
— `If-None-Match$h 内の条件は，
`If-Modified-Since^h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは、［
`If-None-Match$h を実装していないかもしれない旧い`媒介者$
］と相互運用するために限られる。
◎
A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.
</p>

<div class="p">
<p>
`If-Modified-Since^h ~headerの`受信者$は、
次に挙げるいずれかに該当する場合は，それを無視しなければナラナイ：
◎
A recipient MUST ignore the If-Modified-Since header field＼
</p>
<ul>
	<li>
受信した`~field値$は、
`HTTP-date$p として妥当でないか，
複数個の~memberからなる。
◎
if the received field value is not a valid HTTP-date, the field value has more than one member, or＼
</li>
	<li>
`要請~method$は `GET$m, `HEAD$m のいずれでもない。
◎
if the request method is neither GET nor HEAD.
</li>
	<li>
当の`資源$においては、
`改変~日時$は可用でない。
◎
A recipient MUST ignore the If-Modified-Since header field if the resource does not have a modification date available.
</li>
</ul>
</div>

<p>
`受信者$は、
`If-Modified-Since^h ~field値を［
`生成元~server$の`時計$における時刻印
］として解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Modified-Since field value's timestamp in terms of the origin server's clock.
</p>

<div class="p">
<p>
`If-Modified-Since^h は、
概して，次に挙げる別個な目的に利用される：
◎
If-Modified-Since is typically used for two distinct purposes:＼
</p>
<ul>
	<li>
(A)
`~cache$が［
~cache済みな`表現$のうち，`実体~tag$を有さないもの
］を効率的に更新する。
◎
1) to allow efficient updates of a cached representation that does not have an entity tag and＼
</li>
	<li>
(B)
`~UA$が~webの辿りにおいて検索取得する視野を［
近過去に変更された`資源$
］に制限する。
◎
2) to limit the scope of a web traversal to resources that have recently changed.
</li>
</ul>
</div>

<div class="p">
<p>
上の (A) に利用される場合、
`~cache$は，概して［
~cache済み~messageの `Last-Modified$h ~headerの`~field値$
］を利用して［
`If-Modified-Since^h の`~field値$を`生成-$する
］ことになる。
この挙動は、
次に挙げる事例において，最も相互運用-可能になる：
◎
When used for cache updates, a cache will typically use the value of the cached message's Last-Modified header field to generate the field value of If-Modified-Since. This behavior is most interoperable for cases＼
</p>
<ul>
	<li>
`時計$が必要十分に同期されていないとき。
◎
where clocks are poorly synchronized or＼
</li>
	<li>
`~server$が［
時刻印の正確な合致のみを尊守する
］ことを選んだとき（［
`生成元~server$の`時計$が正された
］または［
`表現$が~archiveされた~backupから復旧された
］ことにより，
`Last-Modified$h 日時が “~~過去へ戻る” ように出現する問題に因り）。
◎
when the server has chosen to only honor exact timestamp matches (due to a problem with Last-Modified dates that appear to go "back in time" when the origin server's clock is corrected or a representation is restored from an archived backup).＼
</li>
</ul>

<p>
しかしながら，`~cache$は、
ときには，他の~data
— ~cache済み~messageの `Date$h ~headerや，~messageを受信したときの`時計$の時刻など —
に基づいて，~field値を`生成-$することもある
— 特に，~cache済み~messageが `Last-Modified$h ~headerを包含しないときに。
◎
However, caches occasionally generate the field value based on other data, such as the Date header field of the cached message or the clock time at which the message was received, particularly when the cached message does not contain a Last-Modified header field.
</p>
</div>

<p>
上の (B) に利用される場合、
`~UA$は，［
自前の`時計$
］または［
先立つ応答にて~serverから受信した `Date$h ~header
］に基づいて［
`If-Modified-Since^h の`~field値$を`生成-$する
］ことになる。
`生成元~server$が［
`選定された表現$の `Last-Modified$h ~headerに基づく，時刻印の正確な合致-
］を選んだ場合、
【 `If-Modified-Since^h は，】［
~UAが~data転送を［
指定された時間枠~内で変更されたものに限る
］よう制限する
］ための助けにはならなくなる。
◎
When used for limiting the scope of retrieval to a recent time window, a user agent will generate an If-Modified-Since field value based on either its own clock or a Date header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified header field will not be able to help the user agent limit its data transfers to only those changed during the specified window.
</p>

<div class="p">
<p>
`生成元~server$は、
受信した要請が［
ある表現を選定するものであって，
`If-Modified-Since^h ~headerを内包する
］ときは
— ~methodを遂行するに先立って，`事前条件の評価§に従う下で —
その~field値に与えられた`前述の条件＠#condition-If-Modified-Since$を評価するベキである
— 条件が ~F に評価された場合：
◎
When an origin server receives a request that selects a representation and that request includes an If-Modified-Since header field without an If-None-Match header field, the origin server SHOULD evaluate the If-Modified-Since condition per Section 13.2 prior to performing the method.
◎
To evaluate a received If-Modified-Since header field:
• If the selected representation's last modification date is earlier or equal to the date provided in the field value, the condition is false.
• Otherwise, the condition is true.
</p>
<ul>
	<li>
要請された~methodを遂行するベキでない
◎
An origin server that evaluates an If-Modified-Since condition SHOULD NOT perform the requested method if the condition evaluates to false;＼
</li>
	<li>
代わりに，次のみを内包する `304$st 応答を`生成-$するベキである
⇒
【応答の受信者が】以前に~cacheした応答を［
識別する／更新する
］ために有用になる~metadata
◎
instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.
</li>
</ul>
</div>

<p>
`~cache$が受信した `If-Modified-Since^h ~headerの取扱いに課される要件は、
`CACHING$r `受信した検証~要請の取扱い＠~HTTPcache#validation.received§
にて定義される。
◎
Requirements on cache handling of a received If-Modified-Since header field are defined in Section 4.3.2 of [CACHING].
</p>

			</section>
			<section id="field.if-unmodified-since">
<h4>13.1.4. `If-Unmodified-Since^h</h4>

<div class="p">
<p>
`If-Unmodified-Since^h ~headerは、
`要請~method$を次による条件付きにする：
◎
The "If-Unmodified-Since" header field makes the request method conditional on＼
</p>
<ul id="condition-If-Unmodified-Since">
	<li>
`選定された表現$の最後の`改変~日時$は、
`~field値$が供する日時より近過去でない【！earlier than or equal to】。
◎
the selected representation's last modification date being earlier than or equal to the date provided in the field value.＼
</li>
</ul>

<p>
この~fieldは、
~UAが`表現$用の`実体~tag$を有さない所で，
`If-Match$h と同じ目的を成遂げる。
◎
This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity tag for the representation.
</p>
</div>

<pre class="bnf">
`If-Unmodified-Since@p
	= `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
`If-Unmodified-Since^h ~headerの`受信者$は、
次のいずれかに該当する場合は，それを無視しなければナラナイ：
◎
↓</p>
<ul>
	<li>
当の要請は `If-Match$h ~headerも包含している
— `If-Match$h 内の条件は，
`If-Unmodified-Since^h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは、［
`If-Match$h を実装していないかもしれない旧い`媒介者$
］と相互運用するために限られる。
◎
A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.
</li>
	<li>
その`~field値$は妥当な `HTTP-date$p でない
（~field値が日時たちが成す~listとして出現している場合も含む）。
◎
A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).
</li>
	<li>
当の`資源$においては、
`改変~日時$は可用でない。
◎
A recipient MUST ignore the If-Unmodified-Since header field if the resource does not have a modification date available.
</li>
</ul>

<p>
`受信者$は、
`If-Unmodified-Since^h ~field値の時刻印を［
`生成元~server$の`時計$における時刻印
］として解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Unmodified-Since field value's timestamp in terms of the origin server's clock.
</p>


<p>
`If-Unmodified-Since^h は、
状態変更~method（例： `POST$m, `PUT$m, `DELETE$m ）と伴に利用されることが最も多い
— ［
その`表現$に`実体~tag$を給さない`資源$
］に対し複数の~UAが並列的に動作し得るときの，
偶発的な上書-（すなわち， “`更新喪失$” 問題）を防止するために。
一般に， `If-Unmodified-Since^h は、
`表現$の［
選定／改変
］を孕むような どの~methodと伴にも，次のために利用できる
⇒
`選定された表現$の最後の`改変~日時$が
`If-Unmodified-Since^h の`~field値$にて供された日時から変化した場合には、
当の要請を中止する
◎
If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity tags with its representations (i.e., to prevent the "lost update" problem). In general, it can be used with any method that involves the selection or modification of a representation to abort the request if the selected representation's last modification date has changed since the date provided in the If-Unmodified-Since field value.
</p>

<div class="p">
<p>
`生成元~server$は、
受信した要請が［
ある表現を選定するものであって，［
`If-Unmodified-Since^h ~headerを内包する
］~AND［
`If-Match$h ~headerを伴わない
］］ときは
— ~methodを遂行するに先立って，`事前条件の評価§に従う下で —
その~field値に与えられた`前述の条件＠#condition-If-Unmodified-Since$を評価しなければナラナイ
— 条件が ~F に評価された場合：
◎
When an origin server receives a request that selects a representation and that request includes an If-Unmodified-Since header field without an If-Match header field, the origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.
◎
To evaluate a received If-Unmodified-Since header field:
• If the selected representation's last modification date is earlier than or equal to the date provided in the field value, the condition is true.
• Otherwise, the condition is false.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false.＼
</li>
	<li>
代わりに、
`状態s~code$ `412$st で応答して，
当の条件付き要請は失敗したことを指示してもヨイ。
◎
Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code.＼
</li>
	<li>
<p>
［
当の要請は状態変更~演算であり、
`選定される表現$には，すでに適用されたように出現している場合
］には、
前項に代えて，`状態s~code$ `2xx$st で応答してもヨイ
（すなわち，~UAから要請された変更はすでに成功したが、
たぶん［
先立つ応答~messageが失われた／他の~UAにより等価な変更が為された
］ため，~UAは それに気付かなかった）。
◎
Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).
</p>

<p>
これを許容することで，多くの著作~利用事例は より効率的になるが、［
複数の~UAが，よく似るが協力的でない変更~要請を為している場合
］には，~riskも伴われる。
例えば、
複数の~UAが，共通な`資源$に対し~semaphoreとして書込んでいると（例：可分な増分）、
衝突する見込みが高く，重要な状態~遷移が失われかねない。
そのような種類の資源~用には、
厳格に［
~methodが`安全$でない場合は、
失敗した どの事前条件に対しても `412$st0 を送信する
］方が良い。
◎
Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. In those cases, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method.
</p>
	</li>
</ul>
</div>

<p>
`~client$は、［
`選定された表現$が改変された場合には， `412$st 応答を選好する
］ことを指示するためとして，
`GET$m 要請~内に `If-Unmodified-Since^h ~headerを送信してもヨイ。
しかしながら，これが有用になるのは、［
以前に受信した部分的な`表現$を完全~化するため，新たな表現は欲されないとき
］の`範囲~要請$に限られる。
~clientが範囲~要請にて新たな表現を受信する方を選好する場合、
`If-Range$h の方が適する。
◎
A client MAY send an If-Unmodified-Since header field in a GET request to indicate that it would prefer a 412 (Precondition Failed) response if the selected representation has been modified. However, this is only useful in range requests (Section 14) for completing a previously received partial representation when there is no desire for a new representation. If-Range (Section 13.1.5) is better suited for range requests when the client prefers to receive a new representation.
</p>

<p>
［
`~cache$／`媒介者$
］は、
`If-Unmodified-Since^h ~headerを無視してもヨイ
— その相互運用能~用の特能が必要yであるのは、
`生成元~server$に限られるので。
◎
A cache or intermediary MAY ignore If-Unmodified-Since because its interoperability features are only necessary for an origin server.
</p>

			</section>
			<section id="field.if-range">
<h4>13.1.5. `If-Range^h</h4>

<p>
`If-Range^h ~headerは、
`If-Match$h や `If-Unmodified-Since$h に~~似るが，［
検証子が合致しない場合には， `Range$h ~headerを無視する
］よう`受信者$に指図するための［
特別な`条件付き要請$の仕組み
］を供する。
合致しない場合、
`412$st 応答の代わりに，新たな`選定された表現$が転送されることになる。
◎
The "If-Range" header field provides a special conditional request mechanism that is similar to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to ignore the Range header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a 412 (Precondition Failed) response.
</p>

<p>
`~client$は，［
`表現$の`部分的$な複製を有していて, 表現~全体の~~最新な複製を望む
］ならば、
`Range$h ~headerを，
（ `If-Unmodified-Since$h, `If-Match$h のいずれか, または両者を利用している）
条件付き `GET$m と伴に利用できる。
しかしながら，表現が改変されたために`事前条件$が失敗した場合、
~clientは，現在の表現~全体を得するために，もう一度~要請を為さなければならなくなる。
◎
If a client has a partial copy of a representation and wishes to have an up-to-date copy of the entire representation, it could use the Range header field with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the precondition fails because the representation has been modified, the client would then have to make a second request to obtain the entire current representation.
</p>

<p>
`If-Range^h ~headerは、
次回の要請を “短絡する” ことを~clientに許容する。
くだけて言えば、
次を意味する
⇒
“表現がまだ不変なら，
`Range$h にて要請している部位t（たち）を送信してください。
そうでなければ，表現~全体を送信してください。”
◎
The "If-Range" header field allows a client to "short-circuit" the second request. Informally, its meaning is as follows: if the representation is unchanged, send me the part(s) that I am requesting in Range; otherwise, send me the entire representation.
</p>

<pre class="bnf">
`If-Range@p
	= `entity-tag$p
	/ `HTTP-date$p
</pre>

<p>
妥当な［
`entity-tag^p, `HTTP-date^p
］どちらなのかは、［
最初の 3 文字について `DQUOTE$P の有無を精査する
］ことにより判別できる。
◎
A valid entity-tag can be distinguished from a valid HTTP-date by examining the first three characters for a DQUOTE.
</p>

<p>
`~client$は、
`Range$h ~headerを包含しない要請~内に，
`If-Range^h ~headerを`生成-$してはナラナイ。
`~server$は、［
`Range$h ~headerを包含しない要請~内に受信した `If-Range^h ~header
］を無視しなければナラナイ。
`生成元~server$は、［
`Range$h 要請を~supportしない`~target資源$への要請~内に受信した `If-Range^h ~header
］を無視しなければナラナイ。
◎
A client MUST NOT generate an If-Range header field in a request that does not contain a Range header field. A server MUST ignore an If-Range header field received in a request that does not contain a Range header field. An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.
</p>

<div class="p">
<p>
`~client$は、
次のいずれかを包含する `If-Range^h ~headerを`生成-$してはナラナイ：
◎
↓</p>
<ul>
	<li>
弱い（ `weak$p を伴う）`実体~tag$
◎
A client MUST NOT generate an If-Range header field containing an entity tag that is marked as weak.＼
</li>
	<li>
`HTTP-date$p
— ただし、
次が満たされる場合は除く
⇒
［
それが表す日時は `8.8.2.2§ にて定義されるイミで`強い検証子$になる
］~AND［
~clientは、
対応する`表現$用の`実体~tag$を有さない
］
◎
A client MUST NOT generate an If-Range header field containing an HTTP-date unless the client has no entity tag for the corresponding representation and the date is a strong validator in the sense defined by Section 8.8.2.2.
</li>
</ul>
</div>

<p>
`Range$h ~headerを伴う要請~内に
`If-Range^h ~headerを受信した`~server$は
— ~methodを遂行するに先立って，`事前条件の評価§に従う下で —
その条件を評価しなければナラナイ。
評価するときは、
`If-Range^h ~headerの`~field値$として供された`検証子$ %検証子 応じて：
◎
A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.
</p>
<ul class="switch">
	<li>
<p>
`HTTP-date$p である場合、［
次が満たされるならば ~T ／
~ELSE_ ~F
］になるとする
⇒
［
%検証子 は `8.8.2.2§ にて定義されるイミで`強い検証子$である
］~AND［
%検証子 と［
`選定される表現$用の `Last-Modified$h ~field値
］は正確に合致する
］
◎
To evaluate a received If-Range header field containing an HTTP-date:
• If the HTTP-date validator provided is not a strong validator in the sense defined by Section 8.8.2.2, the condition is false.
• If the HTTP-date validator provided exactly matches the Last-Modified field value for the selected representation, the condition is true.
• Otherwise, the condition is false.
</li>
	<li>
`entity-tag$p である場合、［
次が満たされるならば ~T ／
~ELSE_ ~F
］になるとする
⇒
%検証子 と［
`選定される表現$用の `ETag$h ~field値
］は、
`強い比較~関数$を利用する下で，正確に合致する
◎
To evaluate a received If-Range header field containing an entity-tag:
• If the entity-tag validator provided exactly matches the ETag field value for the selected representation using the strong comparison function (Section 8.8.3.2), the condition is true.
• Otherwise, the condition is false.
</li>
</ul>

<p>
`If-Range^h ~headerの`受信者$は、
その条件を評価した結果に応じて
⇒＃
~F ならば `Range$h ~headerを無視しなければナラナイ／
~T ならば `Range$h ~headerを要請されたとおり処理するベキである
◎
A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false. Otherwise, the recipient SHOULD process the Range header field as requested.
</p>

<p>
`If-Range^h における比較は、
`検証子$が `HTTP-date$p の場合でも，正確な合致-に基づくことに注意
— なので、
`If-Unmodified-Since$h 条件付きを評価するときの
“より近過去【！earlier than or equal to】”
に基づく比較とは相違する。
◎
Note that the If-Range comparison is by exact match, including when the validator is an HTTP-date, and so it differs from the "earlier than or equal to" comparison used when evaluating an If-Unmodified-Since conditional.
</p>

			</section>
		</section>
		<section id="evaluation">
<h3 title="Evaluation of Preconditions">13.2. 事前条件の評価</h3>

			<section id="when.to.evaluate">
<h4 title="When to Evaluate">13.2.1. いつ評価するか</h4>

<div class="p">
<p>
`受信者$である［
`~cache$／`生成元~server$
］は
— 以下により除外されるときを除いて —
［
自身による通常の要請~検査を成功裡に遂行した後
］かつ［
要請の`内容$（もし在れば）を処理するか，
`要請~method$に結付けられた動作を遂行する
］~~直前【いずれか早い方】に，
受信した要請の`事前条件$を評価しなければナラナイ。
◎
Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.＼
</p>

<p>
~serverは：
◎
＼</p>
<ul>
	<li>
<p>
次に該当する場合、
受信したすべての`事前条件$を無視しなければナラナイ
⇒
当の要請が それらの条件を伴っていなかったとするとき、
対する応答の`状態s~code$は
— 要請の`内容$の処理に先立って —
［
`2xx$st, `412$st
］以外になる
◎
A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).＼
</p>

<p>
言い換えれば，有意な処理が生じる前に検出された~redirectや失敗は、
`事前条件$の評価よりも優先される。
◎
In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.
</p>
	</li>
	<li>
［
`~target資源$用の`生成元~server$でない
］かつ［
`~target資源$への要請~用の`~cache$としても動作し得ない
］ならば、
この仕様が定義する`条件付き要請~header$を評価してはナラナイ
— 要請を回送するときは、
それらの~headerも回送しなければナラナイ。
そのような~headerを生成した~clientは、
それを評価するのは，現在の`表現$を供せる~serverであることを意図しているので。
◎
A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation.＼
</li>
	<li>
`選定される表現$の［
選定, 改変
］を孕まない`要請~method$
— `CONNECT$m, `OPTIONS$m, `TRACE$m など —
に伴って受信した`条件付き要請~header$のうち，この仕様が定義するものは、
無視しなければナラナイ。
◎
Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.
</li>
</ul>
</div>

<p>
~protocol拡張は、［
`事前条件$が どの条件の下で評価されるか／その評価の帰結
］を改変し得ることに注意。
例えば， `immutable$sdir `~cache指令$ `RFC8246$r は、［
`新鮮$な応答を保持するときは、
`条件付き要請$を回送するのを差控える
］よう，~cacheに指図する。
◎
Note that protocol extensions can modify the conditions under which preconditions are evaluated or the consequences of their evaluation. For example, the immutable cache directive (defined by [RFC8246]) instructs caches to forgo forwarding conditional requests when they hold a fresh response.
</p>

<p>
`条件付き要請~header$は，
（ `HEAD$m, `GET$m の間で意味論の整合性を保つため）
`HEAD$m ~methodと伴用できるものと定義されるが、
条件付き `HEAD$m を送信することに~~利点はない
— 何故なら，成功裡な応答は、
`304$st 応答と~~大体~同じ~sizeになり，
`412$st 応答よりも有用なので。
◎
Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a 304 (Not Modified) response and more useful than a 412 (Precondition Failed) response.
</p>

			</section>
			<section id="precedence">
<h4 title="Precedence of Preconditions">13.2.2. 事前条件の優先順</h4>

<div class="p">
<p>
要請~内に`条件付き要請~header$が~~複数~在る場合、
それらの~fieldが評価される順序が重要になる。
実施においては、
この文書にて定義される各種~fieldは、
次の~~理由から，一貫して［
ある単独の，論理的な順序
］で実装されている：
◎
When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since＼
</p>
<ul>
	<li>
“`更新喪失$” のための`事前条件$は、
`~cache検証$よりも厳密な要件を備える。
◎
"lost update" preconditions have more strict requirements than cache validation,＼
</li>
	<li>
検証された~cacheは、
`部分的な応答$よりも効率的である。
◎
a validated cache is more efficient than a partial response, and＼
</li>
	<li>
`実体~tag$は、
日時~検証子よりも正確aであると予め見做されている。
◎
entity tags are presumed to be more accurate than date validators.
</li>
</ul>
</div>

<div class="algo">
<p>
`受信者$である［
`~cache$／`生成元~server$
］は、
所与の要請 %要請 内の［
この仕様にて定義される各種`事前条件$
］を，次の順序で評価しなければナラナイ：
◎
A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order:
</p>

<p class="trans-note">【
以下における “〜で応答する” は、
そこで評価~~手続きを終えることも意味する。
】</p>
<ol>
	<li>
<p>
~IF［
~AND↓ が満たされる
］…
</p>
		<ul>
			<li>
当の`受信者$は`生成元~server$である
</li>
			<li>
<p>
~OR↓ ：
</p>
				<ul>
					<li>
%要請 には `If-Match$h が在って，その事前条件を評価した結果 ~EQ ~F
</li>
					<li>
<p>
~AND↓
</p>
						<ul>
							<li>
%要請 には `If-Match$h は無い
</li>
							<li>
%要請 には `If-Unmodified-Since$h が在って，その事前条件を評価した結果 ~EQ ~F
</li>
						</ul>
					</li>
				</ul>
			<li>
次に該当しない
⇒
%要請 は状態変更~methodであって，すでに成功したものと決定できた
（詳細は前項の各~fieldの記述を見よ）
</li>
		</ul>
<p>
…ならば
⇒
`412$st で応答する
</p>

◎
When recipient is the origin server and If-Match is present, evaluate the If-Match precondition:
• if true, continue to step 3
• if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 13.1.1)
◎
When recipient is the origin server, If-Match is not present, and If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition:
• if true, continue to step 3
• if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 13.1.4)
</li>
	<li>
<p>
%要請 の~methodに応じて：
</p>
		<dl class="switch">
			<dt>`GET$m</dt>
			<dt>`HEAD$m</dt>
			<dd>
<p>
~IF［
~OR↓ が満たされる
］…
</p>
				<ul>
					<li>
%要請 には `If-None-Match$h が在って，その事前条件を評価した結果 ~EQ ~F
</li>
					<li>
<p>
~AND↓
</p>
						<ul>
							<li>
%要請 には `If-None-Match$h は無い
</li>
							<li>
%要請 には `If-Modified-Since$h が在って，その事前条件を評価した結果 ~EQ ~F
</li>
						</ul>
					</li>
				</ul>
<p>
…ならば
⇒
`304$st で応答する
</p>

			</dd>
			<dt>その他</dt>
			<dd>
~IF［
%要請 には `If-None-Match$h が在って，その事前条件を評価した結果 ~EQ ~F
］
⇒
`412$st で応答する
</dd>
		</dl>
◎
When If-None-Match is present, evaluate the If-None-Match precondition:
• if true, continue to step 5
• if false for GET/HEAD, respond 304 (Not Modified)
• if false for other methods, respond 412 (Precondition Failed)
◎
When the method is GET or HEAD, If-None-Match is not present, and If-Modified-Since is present, evaluate the If-Modified-Since precondition:
• if true, continue to step 5
• if false, respond 304 (Not Modified)
</li>
	<li>
<p>
~IF［
~AND↓ が満たされる
］…
</p>
		<ul>
			<li>
%要請 の~methodは `GET$m である
</li>
			<li>
%要請 には `Range$h が在る
</li>
			<li>
%要請 には `If-Range$h が在る
</li>
		</ul>
<p>
…ならば：
</p>
		<ul>
			<li>
<p>
~IF［
~AND↓ が満たされる
］…
</p>
				<ul>
					<li>
`If-Range$h 事前条件を評価した結果 ~EQ ~T
</li>
					<li>
`Range$h は【 %要請 の`~target資源$用に】`選定された表現$に適用-可能である
</li>
				</ul>
<p>
…ならば
⇒
`206$st で応答する
</p>
			</li>
			<li>
~ELSE
⇒
`200$st で応答する
— `Range$h ~headerを無視して
</li>
		</ul>
◎
When the method is GET and both Range and If-Range are present, evaluate the If-Range precondition:
• if true and the Range is applicable to the selected representation, respond 206 (Partial Content)
• otherwise, ignore the Range header field and respond 200 (OK)
</li>
	<li>
要請された %要請 の~methodを遂行した上で，その［
成功／失敗
］に則って応答する
◎
Otherwise,
• perform the requested method and respond according to its success or failure.
</li>
</ol>
</div>

<p>
~HTTPに対する拡張は、
追加的な`条件付き要請~header$を定義するならば，
そのような~fieldと他の`条件付き要請~header$
— この文書にて定義されるものに加え、
実施において見出され得る他のものも含む —
を評価する順序を定義する~OUGHT。
◎
Any extension to HTTP that defines additional conditional request header fields ought to define the order for evaluating such fields in relation to those defined in this document and other conditionals that might be found in practice.
</p>

			</section>
		</section>
	</section>
	<section id="range.requests">
<h2 title="Range Requests">14. 範囲~要請</h2>

<p>
`~client$は、［
要請が取消された／接続が落とされた
］結果，~data転送の中断に遭遇することはよくある。
~clientが`部分的$な`表現$を格納したときは、
後続な要請においては，
当の表現~全体ではなく残り~~部分を転送するよう要請することが望ましい。
同様に，局所的な~storageが制限されている機器は、
大きい`表現$に対し，その一部分だけを要請-可能になることで便益を得るかもしれない
— 巨大な文書を成す ある 1 ~pageや, 埋込d画像を成す ある~~断片としてなど。
◎
Clients often encounter interrupted data transfers as a result of canceled requests or dropped connections. When a client has stored a partial representation, it is desirable to request the remainder of that representation in a subsequent request rather than transfer the entire representation. Likewise, devices with limited local storage might benefit from being able to request only a subset of a larger representation, such as a single page of a very large document, or the dimensions of an embedded image.
</p>

<p>
`範囲~要請@
（ `range request^en 【特定的には、 `Range$h ~headerを伴う要請】）は，~HTTPの`任意選択^2119な特能であり、
この特能を実装していない
（または，`~target資源$用には~supportしていない）
`受信者$が
— 相互運用能に影響iすることなく —
それが通常の `GET$m 要請であったかのように応答できるように設計されている。
対する`部分的な応答$は、
この特能を実装しないかもしれない`~cache$から全部的な応答に誤解されないよう，別個な`状態s~code$で指示される。
◎
Range requests are an OPTIONAL feature of HTTP, designed so that recipients not implementing this feature (or not supporting it for the target resource) can respond as if it is a normal GET request without impacting interoperability. Partial responses are indicated by a distinct status code to not be mistaken for full responses by caches that might not implement the feature.
</p>

		<section id="range.units">
<h3 title="Range Units">14.1. 範囲~単位</h3>

<p>
`表現~data$は、
`範囲~単位@
（ `range-unit$p ）
— その~dataの［
`内容~符号法$／`~MIME型$
］に内来的な，~address可能な構造上の単位 —
があるときには、
下位範囲に区分できる。
例えば，~octet（すなわち，~byte）境界は、
すべての`表現~data$に共通な構造上の単位であり，~dataを成す一~区分-が［
~dataの［
始端／終端
］からの~offsetによる範囲を成す~byte列
］として識別されることを許容する。
◎
Representation data can be partitioned into subranges when there are addressable structural units inherent to that data's content coding or media type. For example, octet (a.k.a. byte) boundaries are a structural unit common to all representation data, allowing partitions of the data to be identified as a range of bytes at some offset from the start or end of that data.
</p>

<p>
この一般的な`範囲~単位$の観念は、
次のために利用される：
◎
This general notion of a "range unit" is used in＼
</p>
<ul>
	<li>
`Accept-Ranges$h 応答~header内で，`範囲~要請$の~supportを広告する。
◎
the Accept-Ranges (Section 14.3) response header field to advertise support for range requests,＼
</li>
	<li>
`Range$h 要請~header内で，要請される`表現$の各~部位tが占める範囲を~~精確に~~述べる。
◎
the Range (Section 14.2) request header field to delineate the parts of a representation that are requested, and＼
</li>
	<li>
`Content-Range$h ~header内で，`表現$のどの部位tが転送されているかを述べる。
◎
the Content-Range (Section 14.4) header field to describe which part of a representation is being transferred.
</li>
</ul>

<pre class="bnf">
`range-unit@p
	= `token$p
</pre>

<p>
すべての`範囲~単位$は、
文字大小無視であり，
`16.5.1§ にて定義される
`~HTTP範囲~単位~registry$cite
の中に登録される~OUGHT。
◎
All range unit names are case-insensitive and ought to be registered within the "HTTP Range Unit Registry", as defined in Section 16.5.1.
</p>

<p>
`範囲~単位$は、
`16.5§ にて述べるとおり，拡張-可能になるものと意図されている。
◎
Range units are intended to be extensible, as described in Section 16.5.
</p>

			<section id="range.specifiers">
<h4 title="Range Specifiers">14.1.1. 範囲~指定子</h4>


<p>
範囲は、
範囲~指定子（ `range-spec$p ）たちが成す集合（ `range-set$p ）,
それと~pairにされた`範囲~単位$の用語で表出される。
範囲~単位を成す名前は、［
自前の指定子において，どの種類の `range-spec$p が適用-可能になるか
］を決定する。
よって，次に与える文法は汎用である
— 各~範囲~単位は、［
`int-range$p,
`suffix-range$p,
`other-range$p
］がいつ許容されるかに関する要件を指定するものと期待される。
◎
Ranges are expressed in terms of a range unit paired with a set of range specifiers. The range unit name determines what kinds of range-spec are applicable to its own specifiers. Hence, the following grammar is generic: each range unit is expected to specify requirements on when int-range, suffix-range, and other-range are allowed.
</p>

<p id="rule.ranges-specifier">
`範囲~要請$は、［
単独の表現の中の， 1 個以上の範囲が成す集合
］を指定できる。
◎
A range request can specify a single range or a set of ranges within a single representation.
</p>

<pre class="bnf">
`ranges-specifier@p
	= `range-unit$p "=" `range-set$p
`range-set@p
	= 1#`range-spec$p
`range-spec@p
	= `int-range$p
	/ `suffix-range$p
	/ `other-range$p
</pre>

<p class="trans-note">【
`7306$errata（Verified）：
"`=^c" と `range-set^p の合間に `OWS^p を挿入する必要がある。
】</p>

<p id="rule.int-range">
`int-range$p は、
範囲を［
2 個の負でない整数
］または［
1 個の負でない整数から`表現~data$の終端まで
］として表出する。
`範囲~単位$は、
これらの整数が何を意味するかを指定する
（例：
先頭からの単位~offset,
その~offsetも範囲に含まれるかどうか,
等々を指示することもあろう）。
◎
An int-range is a range expressed as two non-negative integers or as one non-negative integer through to the end of the representation data. The range unit specifies what the integers mean (e.g., they might indicate unit offsets from the beginning, inclusive numbered parts, etc.).
</p>

<pre class="bnf">
`int-range@p
	= `first-pos$p "-" [ `last-pos$p ]
`first-pos@p
	= 1*`DIGIT$P
`last-pos@p
	= 1*`DIGIT$P
</pre>

<p>
`int-range$p は、［
`last-pos$p 値が在って, その値は `first-pos$p 未満である
］ならば，妥当でない。
◎
An int-range is invalid if the last-pos value is present and less than the first-pos.
</p>

<p id="rule.suffix-range">
`suffix-range$p は、
`表現~data$の~~尾部を［
供された負でない（`範囲~単位$による）整数による最大~長さ
］で表出する範囲である。
言い換えれば、
表現~dataを成す最後から %N 個の単位を表す。
◎
A suffix-range is a range expressed as a suffix of the representation data with the provided non-negative integer maximum length (in range units). In other words, the last N units of the representation data.
</p>

<pre class="bnf">
`suffix-range@p
	= "-" `suffix-length$p
`suffix-length@p
	= 1*`DIGIT$P
</pre>

<p id="rule.other-range">
`other-range$p 規則の文法は、
ほぼ拘束されない
— 次を許容する拡張能を供するためにあるので
⇒＃
応用に特有な`範囲~単位$／
追加的な範囲~指定子を定義する将来の`範囲~単位$
◎
To provide for extensibility, the other-range rule is a mostly unconstrained grammar that allows application-specific or future range units to define additional range specifiers.
</p>

<pre class="bnf">
`other-range@p
	= 1*( `21-2B^X / `2D-7E^X )
	; 1*(<span class="comment" title="VCHAR excluding comma">~comma以外の `VCHAR$P</span>)
</pre>

<p>
所与の `ranges-specifier$p %指定子 に対し：
◎
↓</p>
<ul>
	<li>
%指定子 が
`妥当^dfn
であるとは、
次を満たすことをいう
⇒
%指定子 が包含する `range-spec$p は、
どれも次を満たす
⇒
%指定子 にて指示された `range-unit$p 用に定義-済みかつ妥当である
◎
A ranges-specifier is invalid if it contains any range-spec that is invalid or undefined for the indicated range-unit.
</li>
	<li>
妥当な %指定子 が
【ある`選定される表現$ %表現 に関して】
`満足可能@
（ `satisfiable^en ）であるとは、
次を満たすことをいう
⇒
%指定子 が包含する `range-spec$p のうち，どれかが次を満たす
⇒
%指定子 にて指示された `range-unit$p により定義されるとおり，
【 %表現 に関して】
`満足可能@1
である。
◎
A valid ranges-specifier is "satisfiable" if it contains at least one range-spec that is satisfiable, as defined by the indicated range-unit. Otherwise, the ranges-specifier is "unsatisfiable".
</li>
</ul>

			</section>
			<section id="byte.ranges">
<h4 title="Byte Ranges">14.1.2. ~byte範囲</h4>

<p>
`範囲~単位$
`bytes@c
は、
`~byte範囲@
— `表現~data$の~octet列を成す下位範囲 —
を表出するために利用される。
各~byte範囲は、
`表現~data$の［
先頭から ( `int-range$p ）または終端から ( `suffix-range$p ）
］の，ある~offsetを指す整数~範囲として表出される。
~byte範囲は `other-range$p 指定子を利用しない。
◎
The "bytes" range unit is used to express subranges of a representation data's octet sequence. Each byte range is expressed as an integer range at some offset, relative to either the beginning (int-range) or end (suffix-range) of the representation data. Byte ranges do not use the other-range specifier.
</p>

<p>
`bytes$c における `int-range$p を成す［
`first-pos$p 値, `last-pos$p 値
］は、
順に，範囲の［
最初の~offset, 最後の~offset
］を 0 から数えた~byte数で与える。
すなわち、
指定された~byte~~位置は範囲に含まれ，
"`0^c" は先頭~byteを~~指す。
◎
The first-pos value in a bytes int-range gives the offset of the first byte in a range. The last-pos value gives the offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.
</p>

<p>
`表現~data$に`内容~符号法$が適用されている場合、
各~byte範囲は，符号化された~byte列を~~基準に計算される
— 復号して得される下層の~byte列ではなく。
◎
If the representation data has a content coding applied, each byte range is calculated with respect to the encoded sequence of bytes, not the sequence of underlying bytes that would be obtained after decoding.
</p>

<div class="example">
<p>
~byte範囲~指定子の例：
◎
Examples of bytes range specifiers:
</p>
<ul>
	<li>
<p>
最初の 500 ~byte（ 0 〜 499 番の~byte （ 0 番が先頭~byte — 以下同様））：
◎
The first 500 bytes (byte offsets 0-499, inclusive):
</p>

<pre>
bytes=0-499
</pre>
	</li>
	<li>
<p>
2 番目の 500 ~byte（ 500 〜 999 番の~byte）：
◎
The second 500 bytes (byte offsets 500-999, inclusive):
</p>

<pre>
bytes=500-999
</pre>
	</li>
</ul>
</div>

<p>
`~client$は、
`選定される表現$の~sizeを知ることなく，
要請される~byte数を制限できる。
［
`last-pos$p 値が無い, または，その値が`表現~data$の現在の長さ以上
］の場合の`~byte範囲$は、
`表現$の `first-pos$p 以降の~~部分として解釈される
（すなわち，`~server$は、
`last-pos$p の値を
( `選定された表現$の現在の長さ − 1 )
に置換する）。
◎
A client can limit the number of bytes requested without knowing the size of the selected representation. If the last-pos value is absent, or if the value is greater than or equal to the current length of the representation data, the byte range is interpreted as the remainder of the representation (i.e., the server replaces the value of last-pos with a value that is one less than the current length of the selected representation).
</p>

<p id="rule.ranges-specifier.suffix">
`suffix-range$p を利用すれば、
`~client$は，`選定される表現$の最後の %N ~byte（ %N ~GT 0 ）を参照rできる：
`選定された表現$が指定された `suffix-length$p より短い場合、
`表現$~全体が利用される。
◎
A client can refer to the last N bytes (N &gt; 0) of the selected representation using a suffix-range. If the selected representation is shorter than the specified suffix-length, the entire representation is used.
</p>

<div class="example">
<p>
例 — ここでは，表現の長さは 10000 であるものと見做す：
◎
Additional examples, assuming a representation of length 10000:
</p>
<ul>
	<li>
<p>
最後の 500 ~byte（ 9500 〜 9999 番の~byte）：
◎
The final 500 bytes (byte offsets 9500-9999, inclusive):
</p>

<pre>
bytes=-500
</pre>

<p>
または
◎
Or:
</p>

<pre>
bytes=9500-
</pre>

</li>
	<li>
<p>
［
最初, 最後
］の~byteのみ（ 0 番, 9999 番の~byte）：
◎
The first and last bytes only (bytes 0 and 9999):
</p>

<pre>
bytes=0-0,-1
</pre>
【！ Errata ID: 4472 Rejected】

	</li>
	<li>
<p>
［
最初, 真中, 最後
］の 1000 ~byte
◎
The first, middle, and last 1000 bytes:
</p>

<pre>
bytes= 0-999, 4500-5499, -1000
</pre>

	</li>
	<li>
<p>
妥当である（が，正準的でない）， 2 番目の 500 ~byte（ 500 〜 999 番の~byte）の指定：
◎
Other valid (but not canonical) specifications of the second 500 bytes (byte offsets 500-999, inclusive):
</p>

<pre>
bytes=500-600,601-999
bytes=500-700,601-999
</pre>
	</li>
</ul>
</div>

<p>
`GET$m 要請~用には、
`bytes$c において妥当な `range-spec$p は，
~OR↓ を満たすならば`満足可能$1とされる：
◎
For a GET request, a valid bytes range-spec is satisfiable if it is either:
</p>
<ul>
	<li>
`int-range$p であって，
それを成す `first-pos$p は`選定された表現$の現在の長さ未満である
◎
an int-range with a first-pos that is less than the current length of the selected representation or
</li>
	<li>
`suffix-range$p であって，
それを成す `suffix-length$p は 0 でない
◎
a suffix-range with a non-zero suffix-length.
</li>
</ul>

<p>
`選定された表現$の長さが 0 の場合、
`GET$m 要請において`満足可能$1な形を成す `range-spec$p は，上の後者に限られる。
◎
When a selected representation has zero length, the only satisfiable form of range-spec in a GET request is a suffix-range with a non-zero suffix-length.
</p>

<p>
~byte範囲 構文における［
`first-pos$p,
`last-pos$p,
`suffix-length$p
］は、
~octet数を 10 進~数で表出する。
`内容$の長さには定義済み上限は無いので、
`受信者$は，［
~decimal数字列が巨大になり得ること, 整数~変換の桁溢れ
］を見越して，それらによる~errorを防止しなければナラナイ。
◎
In the byte-range syntax, first-pos, last-pos, and suffix-length are expressed as decimal number of octets. Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.
</p>

			</section>
		</section>
		<section id="field.range">
<h3>14.2. `Range^h</h3>

<p>
`GET$m 要請~上の `Range^h ~headerは、
当の要請を`範囲~要請$にするよう
— `選定された表現$全体ではなく，
その`表現~data$を成す 1 個~以上の下位範囲に限り転送を要請するよう —
~method意味論を改変する。
◎
The "Range" header field on a GET request modifies the method semantics to request transfer of only one or more subranges of the selected representation data (Section 8.1), rather than the entire selected representation.
</p>

<pre class="bnf">
`Range@p
	= `ranges-specifier$p
</pre>

<p>
`~server$は、
`Range^h ~headerを無視してもヨイ。
しかしながら，［
`生成元~server$／媒介~cache
］は、
アリなときは`~byte範囲$を~supportする~OUGHT
— `Range^h は［
部分的に失敗した転送の効率的な回復
］や［
巨大な`表現$の部分的な検索取得
］を~supportするので。
◎
A server MAY ignore the Range header field. However, origin servers and intermediate caches ought to support byte ranges when possible, since they support efficient recovery from partially failed transfers and partial retrieval of large representations.
</p>

<p>
`~server$は、
`要請~method$のうち［
自身が認識しないもの／
それ用の範囲の取扱いは定義されていないもの
］に伴って受信した `Range^h ~headerは，無視しなければナラナイ。
この仕様において範囲の取扱いが定義される~methodは、
`GET$m しかない。
◎
A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined. For this specification, GET is the only method for which range handling is defined.
</p>

<p>
`生成元~server$は、［
自身が解さない`範囲~単位$を包含する
`Range^h ~header
］を無視しなければナラナイ。
◎
An origin server MUST ignore a Range header field that contains a range unit it does not understand.＼
</p>

<p>
`~proxy$は、［
自身が解さない`範囲~単位$を包含する
`Range^h ~header
］を破棄してもヨイ。
◎
A proxy MAY discard a Range header field that contains a range unit it does not understand.
</p>

<p>
`範囲~要請$を~supportする`~server$は、
`Range^h ~headerが包含する `ranges-specifier$p が［
妥当でない／
他と重合する範囲を 3 個~以上~伴う†／
昇順で~listされていない多数の小~範囲を伴う
］場合には，当の~headerを無視-または却下してもヨイ
— いずれも，壊れた~client, あるいは故意な~DoS攻撃（ `17.15§ ）を指示するので。
`~client$は、［
処理nや転送が，同じ~dataを包摂する単独の範囲より内来的に非~効率的
］な複数の範囲を要請するベキでない。
【†おそらく。 3 箇所~以上で重合する／同じ箇所に重合する範囲が 3 個~以上、などの解釈も考えられなくはないが。】
◎
A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15). A client SHOULD NOT request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.
</p>

<p>
`範囲~要請$を~supportする~serverは、
`選定された表現$に`内容$が無いときには
（すなわち，表現を成す~dataの長さは 0 ），
`Range^h ~headerを無視してもヨイ。
◎
A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).
</p>

<p>
複数の範囲を要請する`~client$は、
それらの範囲を昇順による順序で~listするベキである
（概して，完全な`表現$~内にそれらが受信されることになる順序で）
— 後側の部位tをより早期に要請する必要が特にない限り。
例えば，［
一連の部位tについての内部~目録を伴う，巨大な`表現$
］を処理している~UAは、
後側の部位tを最初に要請することも必要になり得る
— 特に、
`表現$が逆~順序で格納された~pageたちからなっていて，
~UAが一度に 1 ~pageの転送を望む場合には。
◎
A client that is requesting multiple ranges SHOULD list those ranges in ascending order (the order in which they would typically be received in a complete representation) unless there is a specific need to request a later part earlier. For example, a user agent processing a large representation with an internal catalog of parts might need to request later parts first, particularly if the representation consists of pages stored in reverse order and the user agent wishes to transfer one page at a time.
</p>

<p>
`Range^h ~headerが評価されるのは、
`事前条件~header$を評価した後であり，［
`Range^h ~headerが無いときの結果が `200$st 応答になる
］場合に限られる。
言い換えれば、
条件付き `GET$m の結果が `304$st 応答になる場合には，範囲は無視される。
◎
The Range header field is evaluated after evaluating the precondition header fields defined in Section 13.1, and only if the result in absence of the Range header field would be a 200 (OK) response. In other words, Range is ignored when a conditional GET would result in a 304 (Not Modified) response.
</p>

<p>
`If-Range$h ~headerを， `Range^h ~headerを適用する際の`事前条件$として利用できる。
◎
The If-Range header field (Section 13.1.5) can be used as a precondition to applying the Range header field.
</p>

<div>
<p>
`~server$は、
範囲~要請に関して ~AND↓ が満たされるならば…
</p>
<ul>
	<li>
すべての`事前条件$は ~T に評価された
</li>
	<li>
`~target資源$に対し `Range^h ~headerを~supportする
</li>
	<li>
受信した `Range^h `~field値$は妥当な `ranges-specifier$p %指定子 を包含している
</li>
</ul>
<p>
…ならば、
対する応答として，次を送信するベキである：
</p>
◎
If all of the preconditions are true,＼
the server supports the Range header field for the target resource,＼
the received Range field-value contains a valid ranges-specifier＼
with a range-unit supported for that target resource,＼
</div>

<ul class="switch">
	<li>
<p>
%指定子 は［
`~target資源$が~supportする `range-unit$p を伴う
］かつ［
当の要請~用に`選定された表現$に関して`満足可能$である
］場合
⇒
次を包含する`内容$を伴う `206$st 応答
⇒
［
要請された `range-spec$p のうち，`満足可能$1なもの
］に対応する 1 個~以上の部分的な表現
◎
and that ranges-specifier is satisfiable with respect to the selected representation,＼
the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.
</p>

<p>
これは、
~serverが要請された範囲~すべてを送信することは含意しない。
一部の事例では、
要請された範囲のうち送信-可能になるのは，
最初は ある部位に限られる（または，そうした方が効率的になる）こともある
— ~clientが，後で残りの部位を（依然として欲するなら）要請し直すことを期待して
（ `206§st0 を見よ）。
◎
The above does not imply that a server will send all requested ranges. In some cases, it may only be possible (or efficient) to send a portion of the requested ranges first, while expecting the client to re-request the remaining portions later if they are still desired (see Section 15.3.7).
</p>
	</li>
	<li>
他の場合
⇒
`416$st 応答
◎
↑ If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier,＼
↑ and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation,＼
the server SHOULD send a 416 (Range Not Satisfiable) response.
</li>
</ul>

		</section>
		<section id="field.accept-ranges">
<h3>14.3. `Accept-Ranges^h</h3>

<p>
応答~内の `Accept-Ranges$h ~fieldは、
次を指示する
⇒
`上流$にある`~server$は、
`~target資源$に対する`範囲~要請$を~supportするかどうか。
◎
The "Accept-Ranges" field in a response indicates whether an upstream server supports range requests for the target resource.
</p>

<pre class="bnf">
`Accept-Ranges@p
	= `acceptable-ranges$p
`acceptable-ranges@p
	= 1#`range-unit$p
</pre>

<div class="example">
<p>
例えば`~server$は、
`~byte範囲$の要請を~supportするならば，次の~fieldを送信して：
◎
For example, a server that supports byte-range requests (Section 14.1.2) can send the field
</p>

<pre class="lang-http">
Accept-Ranges: bytes
</pre>

<p>
［
所与の`~target資源$に対しては，`~byte範囲$の要請を~supportする
］ことを指示することにより，［
同じ要請~経路~上の未来の`範囲~要請$【！部分的な要請】における，その利用
］を`~client$に奨励できる。
【！Range units are defined in Section 14.1.】
◎
to indicate that it supports byte range requests for that target resource, thereby encouraging its use by the client for future partial requests on the same request path. Range units are defined in Section 14.1.
</p>
</div>

<p>
`~client$は、
`Accept-Ranges^h ~fieldを受信したかどうかに関わらず，
`範囲~要請$を`生成-$してもヨイ。
この~fieldが~~伝える情報は［
処理能を改善する／不必要な~network転送を抑制する
］ための助言を供するために限られる。
◎
A client MAY generate range requests regardless of having received an Accept-Ranges field. The information only provides advice for the sake of improving performance and reducing unnecessary network transfers.
</p>

<p>
逆に，`~client$は、
`Accept-Ranges^h ~fieldを受信したとしても，［
未来の`範囲~要請$に対し，部分的な応答が返される
］ものと見做してはナラナイ。
内容は変化するかもしれないし，
`~server$は範囲~要請を［
一定の時間／一定の条件の下
］に限って~supportするかもしれないし，
ある異なる`媒介者$が次回の要請を処理するかもしれない。
◎
Conversely, a client MUST NOT assume that receiving an Accept-Ranges field means that future range requests will return partial responses. The content might change, the server might only support range requests at certain times or under certain conditions, or a different intermediary might process the next request.
</p>

<p>
`~target資源$に対し，いかなる`範囲~要請$も~supportしない`~server$は、
`none$c を送信してもヨイ：
◎
A server that does not support any kind of range request for the target resource MAY send
</p>

<pre class="lang-http">
Accept-Ranges: none
</pre>

<p>
これは、
同じ要請~経路~上で範囲~要請を試みないよう，~clientに助言する。
`範囲~単位$
`none@c
は、
この目的~用に予約される。
◎
to advise the client not to attempt a range request on the same request path. The range unit "none" is reserved for this purpose.
</p>

<p>
`Accept-Ranges^h ~fieldは、
`~trailer節$内に送信されてもヨイが，~headerとして送信される方が選好される。
何故なら、
その情報は，特に［
内容の中途で（~trailer節が受信される前に）失敗した巨大な情報~転送
］を開始し直すために有用になるので。
◎
The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).
</p>

		</section>
		<section id="field.content-range">
<h3>14.4. `Content-Range^h</h3>

<div class="p">
<p>
`Content-Range^h ~headerは、
次を［
指示する／供する
］ために送信される：
◎
The "Content-Range" header field is＼
</p>
<ul>
	<li>
単独の部位tからなる `206$st 応答において
⇒
その`~message内容$として同封された［
`選定された表現$を成す部分的な範囲
］を指示する。
◎
sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message content,＼
</li>
	<li>
`複-部位t$な `206$st 応答を成す各~部位tにおいて
⇒
その本体~部位t【！§ 14.6 → 複-部位t】の中に同封された範囲を指示する。
◎
sent in each part of a multipart 206 response to indicate the range enclosed within each body part (Section 14.6), and＼
</li>
	<li>
`416$st 応答において
⇒
`選定された表現$についての情報を供する。
◎
sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.
</li>
</ul>
</div>

<pre class="bnf">
`Content-Range@p
	= `range-unit$p `SP$P ( `range-resp$p / `unsatisfied-range$p )

`range-resp@p
	= `incl-range$p "/" ( `complete-length$p / "*" )
`incl-range@p
	= `first-pos$p "-" `last-pos$p
`unsatisfied-range@p
	= "*/" `complete-length$p

`complete-length@p
	= 1*`DIGIT$P
</pre>

<p>
`受信者$は、［
自身が解さない`範囲~単位$を伴う `Content-Range^h ~header
］を包含する`206$st 応答に対しては，
それを格納-済み表現と結合し直すよう試みてはナラナイ。
その種の~messageを受信した`~proxy$は、
それを`下流$へ回送するベキである。
◎
If a 206 (Partial Content) response contains a Content-Range header field with a range unit (Section 14.1) that the recipient does not understand, the recipient MUST NOT attempt to recombine it with a stored representation. A proxy that receives such a message SHOULD forward it downstream.
</p>

<p>
`Content-Range^h は、
`14.5§ にて述べられるとおり，［
`~client$と`生成元~server$との私的な取決めに基づいて，
部分的な `PUT$m を要請する
］ための要請~改変子として送信されることもある。
`~server$は、
受信した要請の~methodが `Content-Range^h ~headerを~supportするものと定義されていない限り，
要請~内の `Content-Range^h ~headerを無視しなければナラナイ。
◎
Content-Range might also be sent as a request modifier to request a partial PUT, as described in Section 14.5, based on private agreements between client and origin server. A server MUST ignore a Content-Range header field received in a request with a method for which Content-Range support is not defined.
</p>

<p>
`~byte範囲$に対しては、
`送信者$は，［
範囲が抽出された`表現$
］の完全な長さを指示するベキである
— その長さが未知, または それを決定するのが困難である場合は除き。
`range-resp$p における `complete-length$p に代わる ~asterisk （ "`*^c" ）は、［
この~headerが`生成-$された時点では，表現の長さは未知であった
］ことを指示する。
◎
For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine. An asterisk character ("*") in place of the complete-length indicates that the representation length was unknown when the header field was generated.
</p>

<div class="example">
<p>
`選定される表現$の完全な長さが 1234 ~byteであることが，`送信者$に既知なときの例：
◎
The following example illustrates when the complete length of the selected representation is known by the sender to be 1234 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 42-1233/1234
</pre>

<p>
完全な長さが未知であるときの例：
◎
and this second example illustrates when the complete length is unknown:
</p>

<pre class="lang-http">
Content-Range: bytes 42-1233/*
</pre>
</div>

<p>
`Content-Range^h の`~field値$は、
それが包含する `range-resp$p が次を満たす場合には，妥当でない
⇒
［
`last-pos$p 値 ~LT `first-pos$p 値
］~OR［
`complete-length$p 値 ~LTE `last-pos$p 値
］
◎
A Content-Range field value is invalid if it contains a range-resp that has a last-pos value less than its first-pos value, or a complete-length value less than or equal to its last-pos value.＼
</p>

<p>
妥当でない `Content-Range^h の`受信者$は、
受信した`内容$と格納-済みな表現を結合し直すよう試みてはナラナイ。
◎
The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.
</p>

<p>
`~server$は、
`~byte範囲$の要請に対し `416$st 応答を`生成-$するときには，［
`unsatisfied-range$p 値を伴う `Content-Range^h ~header
］を送信するベキである
— 次の例のように：
◎
A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:
</p>

<div class="example">
<pre class="lang-http">
Content-Range: bytes */1234
</pre>
</div>

<p>
`416$st 応答~内の `complete-length$p は、
`選定された表現$の現在の長さを指示する。
◎
The complete-length in a 416 response indicates the current length of the selected representation.
</p>

<p>
`Content-Range^h ~headerは、
その意味論を明示的に述べない`状態s~code$に対しては，意味を有さない。
この仕様において `Content-Range^h 用の意味を述べる`状態s~code$は、
次に挙げるものに限られる
⇒＃
`206$st,
`416$st
◎
The Content-Range header field has no meaning for status codes that do not explicitly describe its semantic. For this specification, only the 206 (Partial Content) and 416 (Range Not Satisfiable) status codes describe a meaning for Content-Range.
</p>

<div class="example">
<p>
`選定された表現$が総計 1234 ~byteを包含するときの， `Content-Range^h 値の例：
◎
The following are examples of Content-Range values in which the selected representation contains a total of 1234 bytes:
</p>
<ul>
	<li>
<p>
最初の 500 ~byte:
◎
The first 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 0-499/1234
</pre>
	</li>
	<li>
<p>
2 番目の 500 ~byte：
◎
The second 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 500-999/1234
</pre>
	</li>
	<li>
<p>
最初の 500 ~byteを除くすべて：
◎
All except for the first 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 500-1233/1234
</pre>
	</li>
	<li>
<p>
最後の 500 ~byte：
◎
The last 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 734-1233/1234
</pre>
	</li>
</ul>
</div>

		</section>
		<section id="partial.PUT">
<h3 title="Partial PUT">14.5. 部分的な `PUT^m</h3>

<p>
一部の`生成元~server$は、
`~UA$が要請~内に `Content-Range$h ~headerを送信するときには，
`表現$に対する部分的な `PUT$m 要請を~supportする。
そのような~supportは、
一貫でないので，~UAとの私的な取決めに依存するが。
それは一般に、
`~target資源$の状態を次のように更新するよう要請する
⇒
その現在の`選定される表現$の一部
— `Content-Range$h の値で指示される［
~offset, 長さ
］を成す部分 —
は、
要請に同封された`内容$で置換される
◎
Some origin servers support PUT of a partial representation when the user agent sends a Content-Range header field (Section 14.4) in the request, though such support is inconsistent and depends on private agreements with user agents. In general, it requests that the state of the target resource be partly replaced with the enclosed content at an offset and length indicated by the Content-Range value, where the offset is relative to the current selected representation.
</p>

<p>
部分的な `PUT$m を~supportしない`生成元~server$は、
【！`~target資源$への】
`PUT^m 要請~内に `Content-Range$h を受信したときは，
状態s~code `400$st で応答するベキである。
◎
An origin server SHOULD respond with a 400 (Bad Request) status code if it receives Content-Range on a PUT for a target resource that does not support partial PUT requests.
</p>

<p>
部分的な `PUT$m は、
`PUT^m の元の定義とは後方-互換でない。
したがって，要請の`内容$は、
現在の`表現$に対する完全な置換として書込まれる結果にもなり得る。
◎
Partial PUT is not backwards compatible with the original definition of PUT. It may result in the content being written as a complete replacement for the current representation.
</p>

<div class="p">
<p>
`資源$の部分的な更新は、
次のいずれかを利用してもアリになる：
</p>
<ul>
	<li>
別々に識別される資源
— その状態は［
より大きな資源の ある部位
］に重合するか それを拡張するような資源 —
を~targetにする。
</li>
	<li>
部分的な更新~用に特定的に定義された，他の~method
（例： `RFC5789$r にて定義される `PATCH$m ~method）。
</li>
</ul>
◎
Partial resource updates are also possible by targeting a separately identified resource with state that overlaps or extends a portion of the larger resource, or by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in [RFC5789]).
</div>

		</section>
		<section id="multipart.byteranges">
<h3 title="Media Type multipart/byteranges">14.6. ~MIME型 "`multipart/byteranges^c"</h3>

<p>
`206$st 応答~messageが，複数の範囲からなる内容を内包するとき、
それらの内容は，~MIME型
"`multipart/byteranges^c"
による
`複-部位t@
（ `multipart^en ）な`~message本体$の中に，
いくつかの本体~部位tとして伝送される（ `2046/5.1$rfc ）。
◎
When a 206 (Partial Content) response message includes the content of multiple ranges, they are transmitted as body parts in a multipart message body ([RFC2046], Section 5.1) with the media type of "multipart/byteranges".
</p>

<p>
~MIME型 "`multipart/byteranges^c" は、
それぞれが自前の［
`Content-Type$h, `Content-Range$h
］~fieldを伴う， 1 個~以上の本体~部位tを内包する。
要求される境界~parameter（ `boundary parameter^en ）は、
各~本体~部位tを分離するために利用される境界~文字列（ `boundary string^en ）を指定する。
◎
The "multipart/byteranges" media type includes one or more body parts, each with its own Content-Type and Content-Range fields. The required boundary parameter specifies the boundary string used to separate each body part.
</p>

<p>
実装~上の注記：
◎
Implementation Notes:
</p>
<ul>
	<li>
【各？】本体における最初の境界~文字列には、
追加的な `CRLF$P が先行するかもしれない。
◎
Additional CRLFs might precede the first boundary string in the body.
</li>
	<li>
<p>
`RFC2046$r は，
境界~文字列（ `boundary string^en †）を引用符で括ることも許可しているが、
一部の既存の実装は，
そのようにされた境界~文字列を不正に取扱う。
◎
Although [RFC2046] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.
</p>

<p class="trans-note">【†
`RFC2046$r では
“`boundary delimiter^en（境界~区切子）”
と称されている。
下の例では `--THIS_STRING_SEPARATES^c がそれに該当する。
】</p>
	</li>
	<li>
いくつもの［
~client／~server
］が， byteranges 仕様の早期の草案に合わせて~codeされており，
その~MIME型に "`multipart/x-byteranges^c" を利用していた
— それは、
この型にほぼ互換である（が，~~完全にではない）。
◎
A number of clients and servers were coded to an early draft of the byteranges specification that used a media type of "multipart/x-byteranges", which is almost (but not quite) compatible with this type.
</li>
</ul>

<p>
その名前にかかわらず、
"`multipart/byteranges$c" ~MIME型は，`~byte範囲$に制限されない。
◎
Despite the name, the "multipart/byteranges" media type is not limited to byte ranges.＼
</p>

<div class="example">
<p>
次の例は、
"`exampleunit^c" `範囲~単位$を利用する：
◎
The following example uses an "exampleunit" range unit:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--
</pre>
</div>

<p>
"`multipart/byteranges$c" ~MIME型~用の登録は、
次に挙げる情報からなる形をとる。
◎
The following information serves as the registration form for the "multipart/byteranges" media type.
</p>

<div>

<dl>
<dt>型~名
<dd>`multipart^c

<dt>下位型~名
<dd>`byteranges^c

<dt>要求される~parameter
<dd>`boundary^c

<dt>省略可能な~parameter
<dd>N/A

<dt>符号化法に対する考慮点
<dd>"`7bit^c", "`8bit^c", "`binary^c" のみ許可される

<dt>~securityの考慮点
<dd>`17§ を見よ

<dt>相互運用能の考慮点
<dd>N/A

<dt>公表される仕様
<dd>RFC 9110 【この仕様】（ `multipart/byteranges$c を見よ）

<dt>この~MIME型を利用する応用
<dd>単独の要請~内に複数の範囲を~supportする， HTTP ~component

<dt>素片~識別子に対する考慮点
<dd>N/A

<dt>追加的な情報
<dd>
	<dl>
	<dt>Deprecated alias names for this type:
	<dt>Magic number(s):
	<dt>File extension(s):
	<dt>Macintosh file type code(s):
	<dd>N/A
	</dl>

<dt>Person and email address to contact for further information:
<dd>`著作者の~address$に。

<dt>意図される用法
<dd>COMMON

<dt>用法~上の制約
<dd>N/A

<dt>著作者
<dd>`著作者の~address$に。

<dt>変更~制御者
<dd>IESG
</dl>

◎
Type name:
• multipart
Subtype name:
• byteranges
Required parameters:
• boundary
Optional parameters:
• N/A
Encoding considerations:
• only "7bit", "8bit", or "binary" are permitted
Security considerations:
• see Section 17
Interoperability considerations:
• N/A
Published specification:
• RFC 9110 (see Section 14.6)
Applications that use this media type:
• HTTP components supporting multiple ranges in a single request
Fragment identifier considerations:
• N/A
Additional information:
• Deprecated alias names for this type:
•• N/A
• Magic number(s):
•• N/A
• File extension(s):
•• N/A
• Macintosh file type code(s):
•• N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

		</section>
	</section>
	<section id="status.codes">
<h2 title="Status Codes">15. 状態s~code</h2>

<p>
応答の
`状態s~code@
は、
3 桁の整数~codeであり，要請の結果と応答の意味論を述べる
【 ~HTTP11においては `status-code＠~HTTPv1#p.status-code$p 】
— 意味論は、［
要請は成功したかどうか, および（もし在れば）どんな`内容$が同封されたか
］を含む。
妥当な状態s~codeは、
どれも，範囲 `100^st0 〜 `599^st0 に入る。
◎
The status code of a response is a three-digit integer code that describes the result of the request and the semantics of the response, including whether the request was successful and what content is enclosed (if any). All valid status codes are within the range of 100 to 599, inclusive.
</p>

<p>
応答の`状態s~code$の最初の桁は、
その
`~class@
を定義する。
下位 2 桁には、
分類上の役割はない。
`~class$には、
次に挙げる 5 種がある：
◎
The first digit of the status code defines the class of response. The last two digits do not have any categorization role. There are five values for the first digit:
</p>
<dl>
	<dt>`1xx$st</dt>
	<dd>
要請は受信され、
その処理nは継続-中にある。
◎
The request was received, continuing process
</dd>

	<dt>`2xx$st</dt>
	<dd>
要請は、
成功裡に［
受信され, 解され, 受容された
］。
◎
The request was successfully received, understood, and accepted
</dd>

	<dt>`3xx$st</dt>
	<dd>
要請を完了するためには、
更なる動作がとられる必要がある。
◎
Further action needs to be taken in order to complete the request
</dd>

	<dt>`4xx$st</dt>
	<dd>
要請は、
不良な構文を包含しているか, または履行できない。
◎
The request contains bad syntax or cannot be fulfilled
</dd>

	<dt>`5xx$st</dt>
	<dd>
要請は ~~見かけ上は妥当であるが、
`~server$はその履行-に失敗した。
◎
The server failed to fulfill an apparently valid request
</dd>
</dl>

<p>
~HTTP状態s~codeは、
拡張できる。
`~client$には、［
登録-済みな状態s~codeすべての意味を解する
］ことは要求されない
— もちろん、
解する方が望ましいが。
しかしながら，`~client$は、［
最初の桁により指示される，どの［
状態s~codeの`~class$
］］に対しても，それを解した上で，認識できない状態s~codeを［
その`~class$の状態s~code `x00^st0 に等価である
］ものとして，扱わなければナラナイ。
◎
HTTP status codes are extensible. A client is not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, a client MUST understand the class of any status code, as indicated by the first digit, and treat an unrecognized status code as being equivalent to the x00 status code of that class.
</p>

<p>
例えば，`~client$が［
認識できない状態s~code `471^st0
］を受信したときは、
その最初の桁から要請に何か~~間違いがあったことが知れ，
応答を `400$st を受信したかのように扱える。
応答~messageは、
通例的に，その状態sを説明する`表現$を包含することになる。
◎
For example, if a client receives an unrecognized status code of 471, it can see from the first digit that there was something wrong with its request and treat the response as if it had received a 400 (Bad Request) status code. The response message will usually contain a representation that explains the status.
</p>

<p>
範囲 `100^st0 〜 `599^st0 に入らない値は妥当でない。
実装は、
非~HTTP状態sの内部的な通信~用に，
この範囲に入らない 3 桁の整数~値
（すなわち， `600^st0 〜 `999^st0 ）
を利用することが多い
（例：~library~error）。
`~client$は、
受信した応答の状態s~codeが妥当でないときは，
それが `5xx$st であったかのように応答を処理するベキである。
◎
Values outside the range 100..599 are invalid. Implementations often use three-digit integer values outside of that range (i.e., 600..999) for internal communication of non-HTTP status (e.g., library errors). A client that receives a response with an invalid status code SHOULD process the response as if it had a 5xx (Server Error) status code.
</p>

<p id="final.interim">
同じ要請に対しては、
複数個の応答
— 0 個以上の`非最終-応答$, それらに後続する 1 個の`最終-応答$ —
が結付けられ得る。
`~class$ `1xx$st に属する応答は，
`非最終-応答@
（ `interim response^en †）とされ、
他の`~class$に属する応答は，
`最終-応答@
（ `final response^en ）とされる。
◎
A single request can have multiple associated responses: zero or more "interim" (non-final) responses with status codes in the "informational" (1xx) range, followed by exactly one "final" response with a status code in one of the other ranges.
</p>

<p class="trans-note">【†
`interim^en は，通例的には “~~中間”, “~~暫定” などと訳されるが、［
簡明にする／他の語（ `provisional^en など）の対訳との衝突を避ける
］ため， “~~非最終” と訳すことにする。
】【
所与の %要請 に結付けられる各~応答を指す所では、
%要請 に “対する応答” と記される。
所与の %応答 を結付けている要請を指す所では、
%応答 が “応対した要請” と記される。
】</p>

		<section id="overview.of.status.codes">
<h3 title="Overview of Status Codes">15.1. 状態s~codeの概観</h3>

<p>
以下に挙げる`状態s~code$は、
この仕様にて定義される。
括弧内に挙げる各種
`事由~句@
【~HTTP11における `reason-phrase＠~HTTPv1#p.reason-phrase$p 】
は、
推奨に過ぎない
— それらは、
局所的な等価~物に置換しても取り去っても，~protocolには影響しない。
◎
The status codes listed below are defined in this specification. The reason phrases listed here are only recommendations -- they can be replaced by local equivalents or left out altogether without affecting the protocol.
</p>

<p>
`状態s~code$のうち，`経験的に~cache可能$であると定義されたもの
— 以下において、
`既定では，経験的に~cache可能である@†
と記されるもの —
（例： この仕様では
`200$st0,
`203$st0,
`204$st0,
`206$st0,
`300$st0,
`301$st0,
`308$st0,
`404$st0,
`405$st0,
`410$st0,
`414$st0,
`501$st0
）を伴う応答は、［
~method定義／明示的な~cache制御
］から他が指示されない限り，
~cacheにより
— 経験的な失効を伴わせて —
再利用できる
（ `CACHING$r `鮮度の経験的な計算-法＠~HTTPcache#heuristic.freshness§ を見よ）。
他のすべての状態s~codeは、
`経験的に~cache可能$でない。
◎
Responses with status codes that are defined as heuristically cacheable (e.g., 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501 in this specification) can be reused by a cache with heuristic expiration unless otherwise indicated by the method definition or explicit cache controls [CACHING]; all other status codes are not heuristically cacheable.
</p>

<p class="trans-note">【†
この用語は、
それを参照している他所における上の段落と同様な記述を集約するため，この訳に導入している。
】</p>

<p>
この仕様の視野から外れる追加的な`状態s~code$も，~HTTPにおける利用~用に指定されている。
そのような状態s~codeは，すべて、
`16.2§ にて述べるとおりに，
`~HTTP状態s~code~registry$cite
の中に登録される~OUGHT。
◎
Additional status codes, outside the scope of this specification, have been specified for use in HTTP. All such status codes ought to be registered within the "Hypertext Transfer Protocol (HTTP) Status Code Registry", as described in Section 16.2.
</p>

		</section>
		<section id="status.1xx">
<h3 title="Informational 1xx">15.2. `1xx^st</h3>

<p>
`~class$ `1xx^st に属する`状態s~code$は、
`非最終-応答$を指示する
— すなわち、［
要請された動作を完了して，`最終-応答$を送信する
］に先立って，［
接続の状態s／要請の進捗状況
］を通信するためにある。
~HTTP10は，この~classの状態s~codeを定義しないので、
`~server$は，~HTTP10~clientに対しては `1xx^st0 応答を送信してはナラナイ。
◎
The 1xx (Informational) class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response. Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.
</p>

<p>
`1xx^st0 応答は、
`~header節$が終端するに伴い終了する
— それは、
`内容$も`~trailer節$も包含し得ない。
◎
A 1xx response is terminated by the end of the header section; it cannot contain content or trailers.
</p>

<p>
`~client$は、
`最終-応答$に先立って受信した［
1 個以上の `1xx^st0 応答
］を
— 自身が期待していないとしても —
構文解析-可能でなければナラナイ。
`~UA$は、
自身が期待していない `1xx^st0 応答を無視してもヨイ。
◎
A client MUST be able to parse one or more 1xx responses received prior to a final response, even if the client does not expect one. A user agent MAY ignore unexpected 1xx responses.
</p>

<p>
`~proxy$は、
自身が `1xx^st0 応答の生成を要請した場合を除き，
`1xx^st0 応答を回送しなければナラナイ。
例えば，~proxyが要請を回送するときに［
`100-continue$c `期待$を内包する `Expect$h ~header【！`Expect: 100-continue^c】
］を追加した場合には、
対応する `100^st 応答（たち）を回送する必要はない。
◎
A proxy MUST forward 1xx responses unless the proxy itself requested the generation of the 1xx response. For example, if a proxy adds an "Expect: 100-continue" header field when it forwards a request, then it need not forward the corresponding 100 (Continue) response(s).
</p>

			<section id="status.100">
<h4>15.2.1. `100^st</h4>

<p>
`状態s~code$ `100^st は、
次を指示する
⇒
要請の初期~部分が受信され、
まだ，`~server$により却下されていない。
◎
The 100 (Continue) status code indicates that the initial part of a request has been received and has not yet been rejected by the server.＼
</p>

<p>
すなわち、
~serverは次を意図している
⇒
要請を全部的に受信して, それに対し動作した後に、
`最終-応答$を送信する
◎
The server intends to send a final response after the request has been fully received and acted upon.
</p>

<p>
`100^st0 応答が応対した要請が：
◎
When the request＼
</p>
<ul>
	<li>
`100-continue$c `期待$を内包する `Expect$h ~headerを包含していた場合
⇒
`~server$は、
要請の`内容$の受信を望んでいることを指示する。
`~client$は、
この `100^st0 応答は破棄して，要請の送信を継続する~OUGHT。
◎
contains an Expect header field that includes a 100-continue expectation, the 100 response indicates that the server wishes to receive the request content, as described in Section 10.1.1.＼
The client ought to continue sending the request and discard the 100 response.
</li>
	<li>
他の場合
⇒
`~client$は、
この`非最終-応答$を単純に破棄できる。
◎
If the request did not contain an Expect header field containing the 100-continue expectation, the client can simply discard this interim response.
</li>
</ul>

			</section>
			<section id="status.101">
<h4>15.2.2. `101^st</h4>

<p>
`状態s~code$ `101^st は、
次を指示する
⇒
`~server$は、
`~client$の要請を解したことに加え，［
この接続に利用されている応用~protocolを変更する
］ために `Upgrade$h ~headerを介して要請に準拠する用意がある。
◎
The 101 (Switching Protocols) status code indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field (Section 7.8), for a change in the application protocol being used on this connection.＼
</p>

<p>
`~server$は、
`101^st0 応答においては，［
この応答の後に効果を発揮することになる~protocol（たち）
］を指示する `Upgrade$h ~headerを`生成-$しなければナラナイ。
◎
The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.
</p>

<p>
~serverが~protocolの切替に同意するのは、
その方が有利なときに限られるものと見做されている。
例えば
⇒＃
より新しい~versionの~HTTPへの切替は、旧い~versionより有利かもしれない／
~real-timeかつ同期的な~protocolへの切替は、そのような特能を利用する資源を送達するときに有利かもしれない
◎
It is assumed that the server will only agree to switch protocols when it is advantageous to do so. For example, switching to a newer version of HTTP might be advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.
</p>

			</section>
		</section>
		<section id="status.2xx">
<h3 title="Successful 2xx">15.3. `2xx^st</h3>

<p>
`~class$ `2xx^st に属する`状態s~code$は、
次を指示する
⇒
`~client$の要請は、
成功裡に，受信され, 解され, 受容された。
◎
The 2xx (Successful) class of status code indicates that the client's request was successfully received, understood, and accepted.
</p>
			<section id="status.200">
<h4>15.3.1. `200^st</h4>

<p>
`状態s~code$ `200^st は、
次を指示する
⇒
要請は成功した。
◎
The 200 (OK) status code indicates that the request has succeeded.＼
</p>

<p>
`200^st0 応答~内に送信される`内容$は、
`要請~method$に依存する。
この仕様が定義する~methodに対しては、
`内容$に意図される意味は，次の表tに要約できる：
◎
The content sent in a 200 response depends on the request method. For the methods defined by this specification, the intended meaning of the content can be summarized as:
◎
Table 6
</p>

<table><thead>
<tr><th>
要請~method
◎
Request Method
<th>
応答の`内容$は何の`表現$か
◎
Response content is a representation of:
<tbody>

<tr><th>`GET$m
<td>
`~target資源$
◎
the target resource

<tr><th>`HEAD$m
<td>
`GET$m のときと同じく，`~target資源$
— ただし、
`表現~data$は転送しない
◎
the target resource, like GET, but without transferring the representation data

<tr><th>`POST$m
<td>
動作の状態s／動作から得された結果
◎
the status of, or results obtained from, the action

<tr><th>`PUT$m, `DELETE$m
<td>
動作の状態s
◎
the status of the action

<tr><th>`OPTIONS$m
<td>
`~target資源$用の各種~通信~option
◎
communication options for the target resource

<tr><th>`TRACE$m
<td>~traceを返した`~server$が受信した時点における，要請~message
◎
the request message as received by the server returning the trace
</table>

<p>
`CONNECT$m に対する応答は別として、
`200^st0 応答は，`内容$を包含するものと期待される
— ~message~frame法が明示的に`内容$の長さは 0 であるものと指示していない限り。
要請の何らかの側面が，成功に際し無`内容$な応答の選好を指示する場合、
`生成元~server$は，代わりに `204$st 応答を送信する~OUGHT。
`CONNECT$m 用には、
`内容$は無い
— その成功裡な結果は`~tunnel$であり、
`200^st0 応答の`~header節$の直後から始まるので。
◎
Aside from responses to CONNECT, a 200 response is expected to contain message content unless the message framing explicitly indicates that the content has zero length. If some aspect of the request indicates a preference for no content upon success, the origin server ought to send a 204 (No Content) response instead. For CONNECT, there is no content because the successful result is a tunnel, which begins immediately after the 200 response header section.
</p>

<p>
`200^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 200 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

<p>
`生成元~server$は、［
`GET$m ／ `HEAD$m 
］に対する `200^st0 応答~内に，
当の`選定された表現$用に可用な`検証子~field$を（もしあれば）送信するベキである
— `強い$`実体~tag$, `Last-Modified$h 日時どちらも伴わせることが選好される。
◎
In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.
</p>

<p>
［
状態変更~methodに対する `200^st0 応答
］内に送信された`検証子~field$は、［
当の応答が応対した要請の意味論を成功裡に適用した結果として形成される，新たな`表現$
］用の現在の`検証子$を伝達する。
`PUT$m ~methodには、［
そのような検証子の送信を予め除外するかもしれない，追加的な要件
］があることに注意。
◎
In 200 responses to state-changing methods, any validator fields (Section 8.8) sent in the response convey the current validators for the new representation formed as a result of successfully applying the request semantics. Note that the PUT method (Section 9.3.4) has additional requirements that might preclude sending such validators.
</p>

			</section>
			<section id="status.201">
<h4>15.3.2. `201^st</h4>

<p>
`状態s~code$ `201^st は、
次を指示する
⇒
要請は履行され、
その結果，新たな`資源$として［
`首な資源@
が 1 個,
他の資源が 0 個以上
］作成された。
◎
The 201 (Created) status code indicates that the request has been fulfilled and has resulted in one or more new resources being created.＼
</p>

<p class="trans-note">【
例えば，［
ある~HTML文書, それが参照する何個かの下位資源
］が作成されたなら、
当の~HTML文書が`首な資源$に該当することになろう。
】</p>

<p>
要請により作成された`首な資源$は、
次により識別される
⇒＃
応答~内に `Location$h ~headerを受信したならば その値 ／
~ELSE_ `~target~URI$
◎
The primary resource created by the request is identified by either a Location header field in the response or, if no Location header field is received, by the target URI.
</p>

<p>
`201^st0 応答の`内容$は、
概して，作成された`資源$（たち）を述べると伴に, それらへ~linkする。
この応答~内に送信された`検証子~field$は、［
当の応答が応対した要請により作成された新たな`表現$
］用の現在の`検証子$を伝達する。
`PUT$m ~methodには、［
そのような検証子の送信を予め除外するかもしれない，追加的な要件
］があることに注意。
◎
The 201 response content typically describes and links to the resource(s) created. Any validator fields (Section 8.8) sent in the response convey the current validators for a new representation created by the request. Note that the PUT method (Section 9.3.4) has additional requirements that might preclude sending such validators.
</p>

			</section>
			<section id="status.202">
<h4>15.3.3. `202^st</h4>

<p>
`状態s~code$ `202^st は、
次を指示する
⇒
要請は処理~用に受容されたが、
処理はまだ完了していない。
◎
The 202 (Accepted) status code indicates that the request has been accepted for processing, but the processing has not been completed.＼
</p>

<p>
最終的に要請が動作するかどうかは、
実際の処理に入るときに許容されなくなることもあるので，~~確定していない。
~HTTPには、［
非同期的な演算から【その進捗や完了を指示する】状態s~codeを送信し直す
］ような便宜性はない。
◎
The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility in HTTP for re-sending a status code from an asynchronous operation.
</p>

<p>
`202^st0 応答は、
意図的にどっちつかず（ `noncommittal^en ）にされている。
その目的は、［
`~server$が，何らかの処理n（たぶん，日に一度だけ稼働する一括的な処理n）用の要請を
— その処理の完了まで~serverへの接続を持続するよう，`~UA$に要求することなく —
受容する
］ことを許容することにある。
この応答に伴って送信される`表現$は、
要請の現在の状態sを述べることに加え，［
要請がいつ履行されるかの見積もりを，利用者に供せる
］ような状態s監視器を指す（または埋込む）~OUGHT。
◎
The 202 response is intentionally noncommittal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The representation sent with this response ought to describe the request's current status and point to (or embed) a status monitor that can provide the user with an estimate of when the request will be fulfilled.
</p>

			</section>
			<section id="status.203">
<h4>15.3.4. `203^st</h4>

<p>
`状態s~code$ `203^st は、
次を指示する
⇒
要請は成功したが、
同封された`内容$は，ある`形式変換ng~proxy$【！7.7§】により［
`生成元~server$の `200^st 応答の`内容$
］から改変された。
◎
The 203 (Non-Authoritative Information) status code indicates that the request was successful but the enclosed content has been modified from that of the origin server's 200 (OK) response by a transforming proxy (Section 7.7).＼
</p>

<p>
この状態s~codeは、［
`形式変換$を適用した~proxyが，その旨を`受信者$たちに通知する
］ことを許容する
— その知識は、
内容に関する【受信者による】今後の裁定に影響iするかもしれない。
例えば，［
内容に対する，未来の`~cache検証~要請$
］が適用-可能になるのは、
同じ要請~経路に沿うもの（同じ~proxyたちを通して）に限られるようになり得る。
◎
This status code allows the proxy to notify recipients when a transformation has been applied, since that knowledge might impact later decisions regarding the content. For example, future cache validation requests for the content might only be applicable along the same request path (through the same proxies).
</p>

<p>
`203^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 203 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.204">
<h4>15.3.5. `204^st</h4>

<p>
`状態s~code$ `204^st は、
次を指示する
⇒
`~server$は、
要請を成功裡に履行した。
加えて、
対する応答の`内容$内に送信する追加的な内容は無い。
◎
The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response content.＼
</p>

<p>
`応答~header$内の~metadataは、
`~target資源$, および［
要請された動作が適用された後に`選定された表現$
］を指す。
◎
Metadata in the response header fields refer to the target resource and its selected representation after the requested action was applied.
</p>

<div class="example">
<p>
例えば、
`PUT$m 要請に対する応答~内に `204^st0 が受信され，応答が `ETag$h ~fieldを包含する場合、
`PUT$m は成功していて，
`ETag$h `~field値$が［
その`~target資源$の新たな`表現$用の`実体~tag$
］を包含する。
◎
For example, if a 204 status code is received in response to a PUT request and the response contains an ETag field, then the PUT was successful and the ETag field value contains the entity tag for the new representation of that target resource.
</p>
</div>

<p>
`204^st0 応答は、［
`~UA$に対し，次を指示する
］ことを`~server$に許容する
⇒
当の動作は，`~target資源$に成功裡に適用され、
そのことは［
~UAは，自身の現在の “文書~view” （もしあれば）から離れて他へ辿る必要はない
］ことも含意する。
◎終
`~server$は、［
~UAが，次を行うことになる
］ものと見做している
⇒
自身の~interfaceに則って，利用者に何らかの成功の指示を供した上で、
応答~内の［
新たな／更新された
］~metadataを［
~UAにて作動中な`表現$
］に適用する。
◎
The 204 response allows a server to indicate that the action has been successfully applied to the target resource, while implying that the user agent does not need to traverse away from its current "document view" (if any).＼
The server assumes that the user agent will provide some indication of the success to its user, in accord with its own interface, and apply any new or updated metadata in the response to its active representation.
</p>

<div class="example">
<p>
`204^st0 は、
例えば，［
“保存” 動作に対応する文書~編集~interface
］と伴に共通的に利用され，［
保存した文書が，利用者による編集~用に可用であり続ける
］ようにする。
それはまた、
分散型の~version制御~systemの中など，［
自動化された~data転送が主流になると期待される~interface
］と伴に利用されることも多い。
◎
For example, a 204 status code is commonly used with document editing interfaces corresponding to a "save" action, such that the document being saved remains available to the user for editing. It is also frequently used with interfaces that expect automated data transfers to be prevalent, such as within distributed version control systems.
</p>
</div>

<p>
`204^st0 応答は、
`~header節$が終端するに伴い終了する
— それは、
`内容$も`~trailer節$も包含し得ない。
◎
A 204 response is terminated by the end of the header section; it cannot contain content or trailers.
</p>

<p>
`204^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 204 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.205">
<h4>15.3.6. `205^st</h4>

<p>
`状態s~code$ `205^st は、
次を指示する
⇒
`~server$は、
要請を履行した。
加えて，~serverは、
`~UA$が次を行うよう欲している
⇒
要請を送信させた “文書~view” を［
`生成元~server$から受信した，その元の状態
］に設定し直す
◎
The 205 (Reset Content) status code indicates that the server has fulfilled the request and desires that the user agent reset the "document view", which caused the request to be sent, to its original state as received from the origin server.
</p>

<p>
この応答は、［
次のような共通的な~data手入力の利用事例
］を~supportすることが意図されている
⇒
［［
~data手入力（~form, ~notepad, ~canvas, 等々）を~supportする内容
］を受信した利用者が，その場で手入力したり操作した~data
］が要請にて提出されたとき、
利用者が別の入力~動作に容易に取り掛かれるよう，次回の手入力~用に，~data手入力の仕組みを設定し直す。
◎
This response is intended to support a common data entry use case where the user receives content that supports data entry (a form, notepad, canvas, etc.), enters or manipulates data in that space, causes the entered data to be submitted in a request, and then the data entry mechanism is reset for the next entry so that the user can easily initiate another input action.
</p>

<p>
状態s~code `205^st0 は，追加的な内容は供されないことを含意するので、
`~server$は， `205^st0 応答~内に`内容$を`生成-$してはナラナイ。
◎
Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate content in a 205 response.
</p>

			</section>
			<section id="status.206">
<h4>15.3.7. `206^st</h4>

<p>
`状態s~code$ `206^st
— `部分的な応答^dfn —
は、
次を指示する
⇒
`~server$は、［
`選定された表現$を成す， 1 個~以上の部位t
］を転送することにより，
`~target資源$に対する`範囲~要請$を成功裡に履行した
◎
The 206 (Partial Content) status code indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation.
</p>

<p>
`範囲~要請$【！（`14§）】を~supportする`~server$は、
通例的には要請された範囲~すべてを満足するよう試みる
— より少ない~dataを送信すると，~clientが残りを得るために別の要請を為す見込みが高いので。
しかしながら，~serverは、
自前の理由
— 一時的に可用でない, ~cache効率, 負荷分散, 等々 —
により，
要請された~dataの下位集合に限り送信するよう求めるかもしれない。
`206^st0 応答は`自己-記述的$なので、
当の応答が範囲~要請を部分的にしか満足しない場合でも，
~clientはそれを解せる。
◎
A server that supports range requests (Section 14) will usually attempt to satisfy all of the requested ranges, since sending less data will likely result in another client request for the remainder. However, a server might want to send only a subset of the data requested for reasons of its own, such as temporary unavailability, cache efficiency, load balancing, etc. Since a 206 response is self-descriptive, the client can still understand a response that only partially satisfies its range request.
</p>

<p>
`~client$は、
`206^st0 応答の［
`Content-Type$h, `Content-Range$h
］~fieldを検分して，［
どの部位tが同封されたか，および
追加的な要請は必要になるかどうか
］を決定しなければナラナイ。
◎
A client MUST inspect a 206 response's Content-Type and Content-Range field(s) to determine what parts are enclosed and whether additional requests are needed.
</p>

<p>
`~server$は，
`206^st0 応答を`生成-$するときは、
以下の下位節にて要求されるものに加えて，
次に挙げる~headerのうち［
同じ要請に対する `200$st 応答~内に送信することになるもの
］を`生成-$しなければナラナイ
⇒＃
`Date$h,
`Cache-Control$h ,
`ETag$h,
`Expires$h,
`Content-Location$h,
`Vary$h
◎
A server that generates a 206 response MUST generate the following header fields, in addition to those required in the subsections below, if the field would have been sent in a 200 (OK) response to the same request: Date, Cache-Control, ETag, Expires, Content-Location, and Vary.
</p>

<p>
`206^st0 応答~内に在る `Content-Length$h ~headerは、
当の応答の`内容$を成す~octetの個数を指示する
— それは、
通例的には，`選定された表現$の完全な長さにはならない。
各 `Content-Range$h ~headerが［
選定された表現の完全な長さについての情報
］を内包する。
◎
A Content-Length header field present in a 206 response indicates the number of octets in the content of this message, which is usually not the complete length of the selected representation. Each Content-Range header field includes information about the selected representation's complete length.
</p>

<div class="p">
<p>
`送信者$は、
`If-Range$h ~headerを伴う要請に対する応答に
◎
↓</p>
<ul>
	<li>
`206^st0 を`生成-$するときは
⇒
要求されるものを超える，他の`表現~header$は、
`生成-$するベキでない
— `~client$は、
先立つ応答として，それらの~headerを包含するものをすでに有しているので。
◎
A sender that generates a 206 response to a request with an If-Range header field SHOULD NOT generate other representation header fields beyond those required because the client already has a prior response containing those header fields.＼
</li>
	<li>
他の場合
⇒
［
同じ要請に対する `200$st 応答~内に送信することになる`表現~header$
］すべてを`生成-$しなければナラナイ。
◎
Otherwise, a sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.
</li>
</ul>
</div>

<p>
`206^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 206 response is heuristically cacheable; i.e., unless otherwise indicated by explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

				<section id="partial.single">
<h5 title="Single Part">15.3.7.1. 単独の部位t</h5>

<p>
`206^st0 応答を`生成-$している`~server$は、
単独の部位tを転送している場合には，
次を述べる `Content-Range$h ~headerを`生成-$しなければナラナイ
⇒＃
`選定された表現$を成す どの範囲が同封されたか,
当の範囲を成す`内容$
◎
If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a content consisting of the range.＼
</p>

<div class="example">

<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
</pre>
</div>

				</section>
				<section id="partial.multipart">
<h5 title="Multiple Parts">15.3.7.2. 複数の部位t</h5>

<p>
`206^st0 応答を`生成-$している`~server$は、
複数の部位tを転送している場合には，
当の応答~内に次を`生成-$しなければナラナイ：
◎
If multiple parts are being transferred, the server generating the 206 response MUST generate＼
</p>
<ul>
	<li>
`multipart/byteranges§c にて定義されるとおりの`複-部位t$な`内容$
◎
"multipart/byteranges" content, as defined in Section 14.6,＼
</li>
	<li>
次を包含する `Content-Type$h ~header
⇒＃
"`multipart/byteranges$c" ~MIME型,
前項の内容に要求される `boundary^c ~parameter
◎
and a Content-Type header field containing the "multipart/byteranges" media type and its required boundary parameter.＼
</li>
</ul>

<p>
単独の部位tからなる応答との混同を避けるため、
この応答を成す`~header節$内には， `Content-Range$h ~headerを`生成-$してはナラナイ
（この~headerは、
以下に述べるとおり，各~部位tごとに送信することになる）。
◎
To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).
</p>

<p>
`複-部位t$な`内容$内の各~本体~部位tを成す~header区画の中には、［
その本体~部位t内に同封された範囲に対応する `Content-Range$h ~header
］を`生成-$しなければナラナイ。
`選定される表現$が，［
`200$st 応答においては `Content-Type$h ~headerを有することになる
］ならば、
その同じ `Content-Type$h ~headerを，各~本体~部位tを成す~header区画~内に`生成-$するベキである。
◎
Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part.＼
</p>

<div class="example">
<p>
例えば：
【この例では、 `THIS_STRING_SEPARATES^c が各 部位tを分離する境界を成す】
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
</pre>
</div>

<p>
`~server$は、
複数の範囲が要請されたときは、
それらの範囲のうち［
重合するもの, あるいは
複数~部位tの送信による~overheadより小さな間隙で分離されるもの
］を合体してもヨイ
— 対応する `range-spec$p が，受信された `Range$h ~header内に出現する順序に関わらず。
"`multipart/byteranges$c" を成す各~部位t間の代表的な~overheadは 80 ~byte程度なので、
~~細切れにされた多数の部位tを転送するのは，`選定された表現$全体を転送するより
— `選定された表現$の~MIME型, および選ばれた `boundary^c ~parameterの長さに依存して —
非~効率的になり得る。
◎
When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field. Since the typical overhead between each part of a "multipart/byteranges" is around 80 bytes, depending on the selected representation's media type and the chosen boundary parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.
</p>

<p>
`~server$は、
単独の範囲への要請に対し，`複-部位t$な応答を`生成-$してはナラナイ
— 複数の部位tを要請しなかった`~client$は、
`複-部位t$な応答を~supportしないかもしれないので。
しかしながら，`~server$は、
複数の範囲が要請されていて, かつ［
唯一の範囲が`満足可能$1として見出された, または
合体した後に 1 個の範囲のみ残った
］ならば、
単独の本体~部位tのみを伴う
"`multipart/byteranges$c" 応答を`生成-$してもヨイ。
"`multipart/byteranges$c" 応答を処理できない`~client$は、
複数の範囲を依頼する要請を`生成-$してはナラナイ。
◎
A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a "multipart/byteranges" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a "multipart/byteranges" response MUST NOT generate a request that asks for multiple ranges.
</p>

<p>
`~server$は，`複-部位t$な応答を生成するときは、［
受信した `Range$h ~header内に出現する対応する `range-spec$p
］と同じ順序で，各~部位tを送信するベキである
— 範囲たちのうち［
`満足可能$1でないと判断される／他の範囲に合体される
］ものは除外した上で。
`複-部位t$な応答を受信した`~client$は、
各~本体~部位t内に在る `Content-Range$h ~headerを検分して，
その本体~部位t内にどの範囲が包含されているかを決定しなければナラナイ
— ~clientは、
自身が要請したものと同じ［
範囲たち／順序
］の受信に依拠できない。
◎
A server that generates a multipart response SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response MUST inspect the Content-Range header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.
</p>

				</section>
				<section id="combining.byte.ranges">
<h5 title="Combining Parts">15.3.7.3. 範囲の結合-法</h5>

<p>
応答は、［
接続が尚早に~closeされた, または
要請が 1 個~以上の `Range$h 指定を利用した
］場合に，表現の下位範囲のみを転送し得る。
その種の転送が何度か行われたなら、
`~client$は，同じ表現のいくつかの範囲を受信するかもしれない。
これらの各~範囲を安全に結合できるのは、
それらが揃って同じ`強い検証子$を有する場合に限られる。
◎
A response might transfer only a subrange of a representation if the connection closed prematurely or if the request used one or more Range specifications. After several such transfers, a client might have received several ranges of the same representation. These ranges can only be safely combined if they all have in common the same strong validator (Section 8.8.1).
</p>

<p>
`~target資源$に対する何度かの `GET$m 要請に対し，複数の`部分的$（または`不完全$）な［
`200$st ／ `206$st
］応答を受信した`~client$は、
以下に従って，［
それらのうち同じ`強い検証子$を共有するものたち
］を より大きな連続的な範囲に結合してもヨイ†。
◎
A client that has received multiple partial responses to GET requests on a target resource MAY combine those responses into a larger continuous range if they share the same strong validator.
</p>

<p class="trans-note">【†
結果の範囲が連続的にならない場合でも，以下は適用し得るように見受けられる。
】</p>

<div>
<p>
以下においては：
</p>
<ul>
	<li>
%S は、
これらの（~cacheに格納-済みな【, および現在の】）応答が成す集合を表すとする。
</li>
	<li>
%C は、
結合した結果の応答を表すとする。
</li>
	<li>
所与の %応答, %名前 に対し，
“%応答 の`~header^i( %名前 )”
という表記は、
%応答 内の［
`~field名$が %名前 に合致する~header
］を指すとする。
</li>
</ul>
◎
↓</div>

<ul class="switch">
	<li>
<p>
%S 内に `200^st0 応答が在る場合
— %R は、
それらのうち最も近過去な応答を表すとする：
</p>

<p>
%R 内の~headerの`~field名$からなる集合を成す
~EACH( %名前 )
に対し：
</p>
		<ul>
			<li>
%R の`~header^i( %名前 )
を %C の~headerとして利用する。
</li>
			<li>
%R は %S 内で最も近過去な応答でもあるならば
⇒
%S 内の %R 以外の
~EACH( %応答 )
に対し
⇒
%応答 の`~header^i( %名前 ) を
%R の`~header^i( %名前 ) で置換する
</li>
		</ul>
◎
If the most recent response is an incomplete 200 (OK) response, then the header fields of that response are used for any combined response and replace those of the matching stored responses.
◎
If the most recent response is a 206 (Partial Content) response and at least one of the matching stored responses is a 200 (OK), then the combined response header fields consist of the most recent 200 response's header fields.＼
</li>
	<li>
<p>
他の場合
（ %S 内の応答は、
どれも `206^st0 応答である）：
</p>
<p>
［
%S 内のある応答~内に在る~headerの`~field名$
］に合致するような `Content-Range$h 以外の
~EACH( %名前 )
に対し：
</p>
		<ul>
			<li>
以下における %R は、
%S 内の応答のうち［
その`~header^i( %名前 ) は空でない
］もののうち最も近過去に受信したものを表すとする。
</li>
			<li>
%R の`~header^i( %名前 )
を %C の~headerの~sourceとして利用する。
</li>
			<li>
%R は %S 内で最も近過去な応答でもあるならば
⇒
%S 内の %R 以外の
~EACH( %応答 )
に対し
⇒
%応答 の`~header^i( %名前 )
を
%R の`~header^i( %名前 )
で置換しなければナラナイ。
</li>
		</ul>

<p class="trans-note">【
%C の `Content-Range$h は、
結果の範囲を表現するように決定されることになろう。
】</p>

◎
If all of the matching stored responses are 206 responses, then the stored response with the most recent header fields is used as the source of header fields for the combined response, except that the client MUST use other header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.
</li>
</ul>

<div class="p">
<p>
%C の`内容$は、
%S を成す各 応答の`内容$
— 部分的な範囲を成すそれ —
からなる和集合になる。
`~client$は、
その和集合が：
◎
The combined response content consists of the union of partial content ranges within the new response and all of the matching stored responses. If the union consists of＼
</p>
<ul class="switch">
	<li>
表現~全体を成す場合
⇒
%C を［
`完全$な `200$st 応答であった
］かのように処理しなければナラナイ
— 完全な長さを反映する `Content-Length$h ~headerも含めて。
◎
the entire range of the representation, then the client MUST process the combined response as if it were a complete 200 (OK) response, including a Content-Length header field that reflects the complete length.＼
</li>
	<li>
<p>
他の場合、
和集合を成している各［
連続的な範囲たち
］を，次のいずれかとして処理しなければナラナイ：
◎
Otherwise, the client MUST process the set of continuous ranges as one of the following:＼
</p>
		<ul>
			<li>
%C が表現の先頭部分を成す場合に限り、
`不完全$な `200$st 応答
◎
an incomplete 200 (OK) response if the combined response is a prefix of the representation,＼
</li>
			<li>
"`multipart/byteranges$c" `内容$を包含している 1 個の `206$st 応答
◎
a single 206 (Partial Content) response containing "multipart/byteranges" content, or＼
</li>
			<li>
複数個の `206$st 応答
— それぞれが［
`Content-Range$h ~headerにより指示される 1 個の連続的な範囲
］を伴うような。
◎
multiple 206 (Partial Content) responses, each with one continuous range that is indicated by a Content-Range header field.
</li>
		</ul>
	</li>
</ul>
</div>

				</section>
			</section>
		</section>
		<section id="status.3xx">
<h3 title="Redirection 3xx">15.4. `3xx^st</h3>

<p>
`~class$ `3xx^st に属する`状態s~code$は、
次を指示する
⇒
要請が履行されるためには、
~UAは，更なる動作をとる必要がある。
◎
The 3xx (Redirection) class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.＼
</p>

<p>
~redirect【 “~directし直す” 】は、
次に挙げる種別に分けられる：
◎
There are several types of redirects:
</p>
<ul>
	<li>
［
当の`資源$は、
`Location$h ~headerが供する異なる~URIにて可用かもしれない
］ことを指示するもの
⇒＃
`301$st,
`302$st,
`307$st,
`308$st
◎
Redirects that indicate this resource might be available at a different URI, as provided by the Location header field, as in the status codes 301 (Moved Permanently), 302 (Found), 307 (Temporary Redirect), and 308 (Permanent Redirect).
</li>
	<li>
何個かの合致した`資源$からなる選択肢を提供するもの
— それぞれが当の`資源$を表現する能力を有するような
⇒
`300$st
◎
Redirection that offers a choice among matching resources capable of representing this resource, as in the 300 (Multiple Choices) status code.
</li>
	<li>
［
`Location$h ~headerにより識別され，要請に対する間接的な応答を表現し得る
］ような，異なる`資源$への~redirection
⇒
`303$st
◎
Redirection to a different resource, identified by the Location header field, that can represent an indirect response to the request, as in the 303 (See Other) status code.
</li>
	<li>
以前に格納-済みな結果への~redirection
⇒
`304$st
◎
Redirection to a previously stored result, as in the 304 (Not Modified) status code.
</li>
</ul>

<p class="note" id="308-siblings">注記：
状態s~code［
`301$st, `302$st
］は、
元々は~HTTP10において
— CERN における実装に合致するよう —
~methodを保全するものとして定義された
（ `HTTP/1.0$r `9.3＠~RFCx/rfc1945#section-9.3§ ）。
`303$st は、
~methodを `GET$m に変更する~redirection用に定義された。
しかしながら早期の~UAは、
`POST$m 要請を［
`POST^m として~redirectするもの（当時の仕様に則って），
`GET^m として~redirectするもの（異なる~siteへ~redirectされるとき，より安全な代替になる）
］に分かれる。
~~支配的な実施は、
最終的に，~methodを `GET^m に変更する方へ収束した。
後に，~methodを保全する~redirectを一義的に指示するため、［
`307$st, `308$st `RFC7538$r
］が追加され，［
`301$st, `302$st
］は［
`POST^m 要請を `GET^m として~redirectすること
］を許容するよう調整された。
◎
Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and 302 (Found) were originally defined as method-preserving ([HTTP/1.0], Section 9.3) to match their implementation at CERN; 303 (See Other) was defined for a redirection that changed its method to GET. However, early user agents split on whether to redirect POST requests as POST (according to then-current specification) or as GET (the safer alternative when redirected to a different site). Prevailing practice eventually converged on changing the method to GET. 307 (Temporary Redirect) and 308 (Permanent Redirect) [RFC7538] were later added to unambiguously indicate method-preserving redirects, and status codes 301 and 302 have been adjusted to allow a POST request to be redirected as GET.
</p>

<p>
応答に `Location$h ~headerが供されている場合、
`~UA$は
— その特定の状態s~codeを解せないときでも —
その`~field値$により参照される`~URI$へ向けて，要請を自動的に~redirectしてもヨイ。
自動的な~redirectionは、［
`安全$であると既知でない~methodに対しては、
利用者は，その~redirectを望まないこともある
］ので，~~注意して行う必要がある。
◎
If a Location header field (Section 10.2.2) is provided, the user agent MAY automatically redirect its request to the URI referenced by the Location field value, even if the specific status code is not understood. Automatic redirection needs to be done with care for methods not known to be safe, as defined in Section 9.2.1, since the user might not wish to redirect an unsafe request.
</p>

<p>
`~UA$は，~redirectされた要請に対し自動的に追従するときは、［
元の要請~messageに，次に挙げる改変を加えた結果の要請
］を送信し直すベキである：
◎
When automatically following a redirected request, the user agent SHOULD resend the original request message with the following modifications:
</p>
<ol>
	<li>
`~target~URI$を次に置換する
⇒
［
~redirection応答の `Location$h ~headerの`~field値$が参照している~URI
］を［
元の要請の`~target~URI$
］に相対的に解決した結果
◎
Replace the target URI with the URI referenced by the redirection response's Location header field value after resolving it relative to the original request's target URI.
</li>
	<li>
<p>
当の実装により自動的に生成された~headerを除去して、
それらを新たな要請に適切な，更新された値で置換する
— 次に挙げるものが含まれる：
◎
Remove header fields that were automatically generated by the implementation, replacing them with updated values as appropriate to the new request. This includes:
</p>
		<ul>
			<li>
接続に特有な~header（ `Connection§h ）
◎
Connection-specific header fields (see Section 7.6.1),
</li>
			<li>
~clientの~proxy環境設定に特有な~header
— 次に挙げるものなど
⇒＃
`Proxy-Authorization$h
◎
Header fields specific to the client's proxy configuration, including (but not limited to) Proxy-Authorization,
</li>
			<li>
生成元に特有な~header
— 次に挙げるものなど
⇒＃
`Host$h
◎
Origin-specific header fields (if any), including (but not limited to) Host,
</li>
			<li>
実装の`~cache$により追加された検証-用~header（例：
`If-None-Match$h,
`If-Modified-Since$h
）
◎
Validating header fields that were added by the implementation's cache (e.g., If-None-Match, If-Modified-Since), and
</li>
			<li>
資源に特有な~header
— 次に挙げるものなど
⇒＃
`Referer$h,
`Origin$h,
`Authorization$h,
`Cookie$h
◎
Resource-specific header fields, including (but not limited to) Referer, Origin, Authorization, and Cookie.
</li>
		</ul>
	</li>
	<li>
~securityの含意が在る所では、
実装により自動的に生成されたものでない~header
（すなわち、
~callしている文脈により要請~内に追加されたもの）
を除去することも，考慮する
— 次に挙げるものなど
⇒＃
`Authorization$h,
`Cookie$h
◎
Consider removing header fields that were not automatically generated by the implementation (i.e., those present in the request because they were added by the calling context) where there are security implications; this includes but is not limited to Authorization and Cookie.
</li>
	<li>
適用-可能なら、
~redirectしている`状態s~code$の意味論に則って，
当の`要請~method$を変更する
◎
Change the request method according to the redirecting status code's semantics, if applicable.
</li>
	<li>
当の`要請~method$を［
`GET$m ／ `HEAD$m
］に変更したならば、
`内容$に特有な~headerを除去する
— 次に挙げるものなど
⇒＃
`Content-Encoding$h,
`Content-Language$h,
`Content-Location$h,
`Content-Type$h,
`Content-Length$h,
`Digest^h,
`Last-Modified$h
◎
If the request method has been changed to GET or HEAD, remove content-specific header fields, including (but not limited to) Content-Encoding, Content-Language, Content-Location, Content-Type, Content-Length, Digest, Last-Modified. 
</li>
</ol>

<p>
`~client$は、
循環的な~redirection
（すなわち， “無限” ~redirection~loop）
を検出して，介入するベキである。
◎
A client SHOULD detect and intervene in cyclical redirections (i.e., "infinite" redirection loops).
</p>

<p class="note">注記：
この仕様の~~過去の~versionでは、
~redirection回数として最大 5 回までが推奨されていた（ `2068/10.3$rfc ）。
内容~開発者は、
そのような固定的な制限を実装する~clientもあり得ることを自覚しておく必要がある。
◎
Note: An earlier version of this specification recommended a maximum of five redirections ([RFC2068], Section 10.3). Content developers need to be aware that some clients might implement such a fixed limitation.
</p>

			<section id="status.300">
<h4>15.4.1. `300^st</h4>

<div class="p">
<p>
`状態s~code$ `300^st は、
次を指示する：
◎
The 300 (Multiple Choices) status code indicates that＼
</p>
<ul>
	<li>
`~target資源$には，複数の`表現$が有り、
それら各~表現は［
自前の，より特定な識別子
］を伴う。
◎
the target resource has more than one representation, each with its own more specific identifier,＼
</li>
	<li>
【応答の`内容$内に，】
前項を成す代替たちについての情報が供されていて、
利用者（または~UA）は，［
それらの識別子のうち 1 個以上のものへ，要請を~redirectする
］ことにより選好する表現を選定できる。
◎
and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers.＼
</li>
</ul>
</div>

<p>
言い換えれば、
`~server$は，［
`~UA$が、
`~reactive折衝$に携わって，
自身の必要性に最も適切な表現（たち）を選定する
］よう欲している。
◎
In other words, the server desires that the user agent engage in reactive negotiation to select the most appropriate representation(s) for its needs (Section 12).
</p>

<p>
`~server$は、
それらの選択肢のうち選好するものが在るならば，［
その選択肢の`~URI参照$を包含する `Location$h ~header
］を`生成-$するベキである。
`~UA$は、
その`~field値$を自動的な~redirectionに利用してもヨイ。
◎
If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference. The user agent MAY use the Location field value for automatic redirection.
</p>

<div class="p">
<p>
`要請~method$は `HEAD$m でない場合：
◎
For request methods other than HEAD,＼
</p>
<ul>
	<li>
`~server$は、
対する `300^st0 応答~内には，次を包含する`内容$を`生成-$するベキである
⇒
［
利用者／~UA
］が最も選好するものを選べるような，
`表現~metadata$と`~URI参照$（たち）からなる~list。
◎
the server SHOULD generate content in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred.＼
</li>
	<li>
`~UA$は、
【表現~metadata内に】供された`~MIME型$を解するならば，
前項の~listから自動的に選定してもヨイ。
◎
The user agent MAY make a selection from that list automatically if it understands the provided media type.＼
</li>
</ul>

<p>
この自動的な選定~用の特定の形式は、
この仕様では定義されない
— ~HTTPは、
`内容$の定義に直交的であり続けようとするので。
実施においては、
`表現$は，次のいずれかとして供される：
◎
A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its content. In practice, the representation is provided＼
</p>
<ul>
	<li>
何らかの容易に構文解析できる形式
— 共有されている［
設計や`内容~折衝$
］により決定され，~UAに受容-可能と予見されるような。
◎
in some easily parsed format believed to be acceptable to the user agent, as determined by shared design or content negotiation,＼
</li>
	<li>
何らかの共通して受容される~hypertext形式。
◎
or in some commonly accepted hypertext format.
</li>
</ul>
</div>

<p>
`300^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 300 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

<p class="note">注記：
`300^st0 用の元の提案では、
`URI^h ~headerを［［
`200$st0 ／ `300^st0 ／ `406$st0
］応答に利用でき，［
`HEAD$m ~methodに対する応答~内に転送される，代替~表現たちが成す~list
］を供するもの
］として，定義していた。
しかしながら，［
配備の欠如と，構文について合意が得られなかった
］ため、［
`URI^h,
後続な提案 `Alternates^h
］は，この仕様から落とされることになった。
配備については鶏と卵の問題であるが、
`Link$h ~header `RFC8288$r の`~field値$として
— その~memberたちに関係性 "`alternate^c" 【 “代替する” 】を伴わせて —
~listを通信することはアリである。
◎
Note: The original proposal for the 300 status code defined the URI header field as providing a list of alternative representations, such that it would be usable for 200, 300, and 406 responses and be transferred in responses to the HEAD method. However, lack of deployment and disagreement over syntax led to both URI and Alternates (a subsequent proposal) being dropped from this specification. It is possible to communicate the list as a Link header field value [RFC8288] whose members have a relationship of "alternate", though deployment is a chicken-and-egg problem.
</p>

			</section>
			<section id="status.301">
<h4>15.4.2. `301^st</h4>

<div class="p">
<p>
`状態s~code$ `301^st は、
次を指示する
⇒
`~target資源$には、
新たな恒久的~URIがアテガわれている
— この`資源$への未来の参照には、
同封された いずれかの~URIを利用する~OUGHT。
◎
The 301 (Moved Permanently) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.＼
</p>

<p>
`~server$は、
次を示唆している
⇒
~link編集~能力を備える`~UA$は、
`~target~URI$への参照を［
~serverにより送信された新たな参照のうちいずれか
］で恒久的に置換できる。
◎
The server is suggesting that a user agent with link-editing capability can permanently replace references to the target URI with one of the new references sent by the server.＼
</p>

<p>
しかしながら，この示唆は、
通例的には
— すなわち，次に該当しない限り —
無視される
⇒
`~UA$は参照を能動的に編集していて（例： 内容の著作に携わっている），
接続は`~secure化$されていて，
`生成元~server$は編集-中な内容に対し信用-済みな権限を有する。
◎
However, this suggestion is usually ignored unless the user agent is actively editing references (e.g., engaged in authoring content), the connection is secured, and the origin server is a trusted authority for the content being edited.
</p>

<p>
`~server$は、
`301^st0 応答~内には，［［
新たな恒久的~URIとして選好される，`~URI参照$
］を包含する，
`Location$h ~header
］を`生成-$するベキである。
`~UA$は、
その`~field値$を自動的な~redirectionに利用してもヨイ。
~serverからの応答の`内容$は、
通例的に，［
新たな~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the new URI(s).
</p>
</div>

<p class="note">注記：
歴史的な理由から、
~UAは，後続な要請~用の`要請~method$を
`POST$m から `GET$m へ変更してもヨイ。
この挙動が欲されない場合、
代わりに `308$st を利用できる。
◎
Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 308 (Permanent Redirect) status code can be used instead.
</p>

<p>
`301^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 301 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.302">
<h4>15.4.3. `302^st</h4>

<p>
`状態s~code$ `302^st は、
次を指示する
⇒
`~target資源$は、
一時的に，異なる~URIの下に居る。
◎
The 302 (Found) status code indicates that the target resource resides temporarily under a different URI.＼
</p>

<p>
~redirectionは，その時々で改められ得るので、
`~client$は，未来の要請には`~target~URI$を利用し続ける~OUGHT。
◎
Since the redirection might be altered on occasion, the client ought to continue to use the target URI for future requests.
</p>

<p>
`~server$は、
`302^st0 応答~内には，［［
その異なる~URI用の`~URI参照$
］を包含する，
`Location$h ~header
］を`生成-$するベキである。
`~UA$は、
その`~field値$を自動的な~redirectionに利用してもヨイ。
~serverからの応答の`内容$は、
通例的に，［
異なる~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the different URI(s).
</p>

<p class="note">注記：
歴史的な理由から、
`~UA$は，後続な要請~用の`要請~method$を
`POST$m から `GET$m へ変更してもヨイ。
この挙動が欲されない場合、
代わりに `307$st を利用できる。
◎
Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 307 (Temporary Redirect) status code can be used instead.
</p>

			</section>
			<section id="status.303">
<h4>15.4.4. `303^st</h4>

<p>
`状態s~code$ `303^st は、
次を指示する
⇒
`~server$は、［
`Location$h ~header内の~URIにより指示される，異なる`資源$
］へ，~UAを~redirectしている。
◎
The 303 (See Other) status code indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field,＼
</p>

<p>
その意図は、［
元の要請に対する間接的な応答を供する
］ことである。
`~UA$は、［
その~URIを~targetにする検索取得~要請
（~HTTPを利用しているなら `GET$m または `HEAD$m 要請）
］を遂行できる
— それは、［
元の要請に対する回答として最終的な結果を呈示する
］ために，また~redirectされ得る。
`Location$h ~header内の新たな~URIは、
`~target~URI$に等価なものとは見なされないことに注意。
◎
which is intended to provide an indirect response to the original request.＼
A user agent can perform a retrieval request targeting that URI (a GET or HEAD request if using HTTP), which might also be redirected, and present the eventual result as an answer to the original request. Note that the new URI in the Location header field is not considered equivalent to the target URI.
</p>

<p>
この状態s~codeは、
どの~HTTP~methodにも適用-可能である。
これは、
首に，［
`POST$m 動作の出力に応じて，`~UA$を異なる`資源$へ~redirectする
］ことを許容するために利用される
— そうすることで、
`POST$m 応答に対応している情報は，別々に［
識別-／~bookmark／~cache
］できる`資源$として供されるようになるので。
◎
This status code is applicable to any HTTP method. It is primarily used to allow the output of a POST action to redirect the user agent to a different resource, since doing so provides the information corresponding to the POST response as a resource that can be separately identified, bookmarked, and cached.
</p>

<div class="p">
<p>
`GET$m 要請に対する `303^st0 応答は、
次を指示する
⇒
`生成元~server$には，［
~serverにより~HTTP越しに転送できるような，`~target資源$の`表現$
］は無いが、
その `Location$h `~field値$は［
元の~target資源 %A を~~記述する`資源$ %B
］を指していて，
資源 %B への検索取得~要請を為した結果は
— 資源 %A を表現することを含意することなく —
`受信者$に有用な表現になり得る。
◎
A 303 response to a GET request indicates that the origin server does not have a representation of the target resource that can be transferred by the server over HTTP. However, the Location field value refers to a resource that is descriptive of the target resource, such that making a retrieval request on that other resource might result in a representation that is useful to recipients without implying that it represents the original target resource.＼
</p>

<p>
資源 %B が［
何を表現し得るか？ ／
どのような表現であれば必要十分になるか？ ／
何が有用な~~記述になり得るか？
］に対する回答は、
~HTTPの視野から外れることに注意。
◎
Note that answers to the questions of what can be represented, what representations are adequate, and what might be a useful description are outside the scope of HTTP.
</p>
</div>

<p>
`HEAD$m 要請に対する応答を除き，
`303^st0 応答の`表現$は、
次を包含する~OUGHT
⇒
［
`Location$h ~header内に供されたものと同じ`~URI参照$
］への~hyperlinkを伴う，短い~hypertext
◎
Except for responses to a HEAD request, the representation of a 303 response ought to contain a short hypertext note with a hyperlink to the same URI reference provided in the Location header field.
</p>

			</section>
			<section id="status.304">
<h4>15.4.5. `304^st</h4>

<p>
`状態s~code$ `304^st は、
次を指示する
⇒
条件付き［
`GET$m ／ `HEAD$m
］要請が受信されたこと，および、
仮に［
その条件が ~F に`評価-$される事実がなかった
］とするならば， `200$st で応答することになる。
◎
The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false.＼
</p>

<p>
言い換えれば、
`~server$にとっては，`~target資源$の`表現$を転送する必要はない
— 何故なら，そのような要請は、［
その要請を条件付きにした`~client$が，妥当な表現をすでに有している
］ことを指示するので。
すなわち，~serverは、［
~clientに格納-済みな その表現を，
`200$st 応答の`内容$であったかのように用立ててもらう
］べく，~clientを~redirectしている。
◎
In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the content of a 200 (OK) response.
</p>

<p>
`304^st 応答を`生成-$している~serverは、
次に挙げる~headerのうち［
同じ要請に対し `200$st 応答~内に送信されることになるもの
］すべてを`生成-$しなければナラナイ
⇒＃
`Content-Location$h,
`Date$h,
`ETag$h,
`Vary$h,
`Cache-Control$h `CACHING$r,
`Expires$h `CACHING$r
◎
The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request:
• Content-Location, Date, ETag, and Vary
• Cache-Control and Expires (see [CACHING])
</p>

<p>
`304^st0 応答の目標は，［
`受信者$がすでに 1 個以上の~cache済み`表現$を有するときに，転送する情報を最小限にする
］ことなので、
`送信者$は，上に挙げた~field以外の`表現~metadata$を`生成-$するベキでない
— その種の~metadataが~cache更新を手引きする目的で存在するのでない限り（例：
`Last-Modified$h は、
応答が `ETag$h ~fieldを有さない場合には，有用になり得る）。
◎
Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).
</p>

<p>
`304^st0 応答を受信した`~cache$に課される要件は、
`CACHING$r `検証に際しての，格納-済み応答の新鮮~化法＠~HTTPcache#freshening.responses§
にて定義される。
`条件付き要請$が`外方$にある`~client$
— 自前の~cacheを備え，共用~proxyに向けて条件付き `GET$m を送信する~UAなど —
により出生された場合、
`~proxy$は， `304^st0 応答を その~clientに向けて回送するベキである。
◎
Requirements on a cache that receives a 304 response are defined in Section 4.3.4 of [CACHING]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy SHOULD forward the 304 response to that client.
</p>

<p>
`304^st0 応答は、
`~header節$が終端するに伴い終了する
— それは、
`内容$も`~trailer節$も包含し得ない。
◎
A 304 response is terminated by the end of the header section; it cannot contain content or trailers.
</p>

			</section>
			<section id="status.305">
<h4>15.4.6. `305^st</h4>

<p>
`状態s~code$ `305^st は、
この仕様の以前の~versionにて定義されていたが，今や非推奨にされた
（ `RFC7231$r `~RFC 2616 からの変更点＠~RFC7231#appendix-B§ ）。
◎
The 305 (Use Proxy) status code was defined in a previous version of this specification and is now deprecated (Appendix B of [RFC7231]).
</p>

			</section>
			<section id="status.306">
<h4>15.4.7. `306^st0 （利用されない）</h4>

<p>
`状態s~code$ `306^st0 は、
この仕様の以前の~versionにて定義されていたが，もはや利用されない
— この~codeは予約-済みにされた。
◎
The 306 status code was defined in a previous version of this specification, is no longer used, and the code is reserved.
</p>

			</section>
			<section id="status.307">
<h4>15.4.8. `307^st</h4>

<p>
`状態s~code$ `307^st は、
次を指示する
⇒
［
`~target資源$は，一時的に異なる~URIの下に居る
］こと, および［
`~UA$は、
その~URIへの自動的な~redirectionを遂行する場合，
`要請~method$を変更してはナラナイ
］。
◎
The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI.＼
</p>

<p>
~redirectionは，時間~越しに変化し得るので、
`~client$は，未来の要請にも元の`~target~URI$を利用し続ける~OUGHT。
◎
Since the redirection can change over time, the client ought to continue using the original target URI for future requests.
</p>

<p>
`~server$は、
応答~内に，［
その異なる~URI用の`~URI参照$を包含する， `Location$h ~header
］を`生成-$するベキである。
`~UA$は、
その`~field値$を自動的な~redirectionに利用してもヨイ。
~serverからの応答の`内容$は、
通例的に，［
その異なる~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the different URI(s).
</p>

			</section>
			<section id="status.308">
<h4>15.4.9. `308^st</h4>

<div class="p">
<p>
`状態s~code$ `308^st は、
次を指示する
⇒
`~target資源$には，新たな恒久的~URIがアテガわれていて、
この`資源$への未来の参照は，同封された いずれかの~URIを利用する~OUGHT。
◎
The 308 (Permanent Redirect) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.＼
</p>

<p class="trans-note">【
`7109$errata（Verified）
— 上の段落の末尾に次を挿入する：
`~UA$は、
その~URIへの自動的な~redirectionを遂行する場合，
`要請~method$を変更してはナラナイ
】</p>

<p>
`~server$は、
次を示唆している
⇒
~link編集~能力を備える`~UA$は、
`~target~URI$への参照を［
~serverにより送信された新たな参照のうちいずれか
］で恒久的に置換できる。
◎
The server is suggesting that a user agent with link-editing capability can permanently replace references to the target URI with one of the new references sent by the server.＼
</p>

<p>
しかしながら，この示唆は、
通例的には
— すなわち，次に該当しない限り —
無視される
⇒
`~UA$は参照を能動的に編集していて（例： 内容の著作に携わっている），
接続は`~secure化$されていて，
`生成元~server$は編集されている内容に対し信用-済みな権限を有する。
◎
However, this suggestion is usually ignored unless the user agent is actively editing references (e.g., engaged in authoring content), the connection is secured, and the origin server is a trusted authority for the content being edited.
</p>
</div>

<p>
`~server$は、
応答~内に［
新たな恒久的~URI用に選好される`~URI参照$を包含している `Location$h ~header
］を`生成-$するベキである。
`~UA$は、
`Location^h `~field値$を自動的な~redirection用に利用してもヨイ。
応答の`内容$は、
通例的に［
新たな~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the new URI(s).
</p>

<p>
`308^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 308 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

<div class="note">
<p>注記：
この状態s~codeは，`~~同類の~code＠#308-siblings$よりもずっと~~若いので（ 2014 年 6 月）、
どこでも認識されるとは限らない。
配備~上の考慮点については、
`7538/4$rfc を見よ†。
◎
Note: This status code is much younger (June 2014) than its sibling codes and thus might not be recognized everywhere. See Section 4 of [RFC7538] for deployment considerations.
</p>

<details>
<summary class="trans-note">【†
便宜のため、
その節の和訳をここに与える
（この仕様と重複する記述は省略する）：
】</summary>

<p>
状態s~code `308^st0 の利用は、
~serverが［
この状態s~codeを~clientが解する~~確信があるか，
状態s~code `300^st0 の意味論へ~fallbackしても問題になり得ない
］事例に制約される。
~server実装者には、
状態s~codeを要請の特性
— `User-Agent$h ~headerなど（ “`User-Agent Sniffing^en” ） —
に基づいて変えないことを勧める。
そうすると、
通例的に~codeを保守するのも~debugするのも難しくなることに加え，
~cache法にも特別な注意（すなわち， `Vary$h 応答~headerの設定）が要求されるので。
◎
Therefore, the use of status code 308 is restricted to cases where the server has sufficient confidence in the client's understanding the new code or when a fallback to the semantics of status code 300 is not problematic. Server implementers are advised not to vary the status code based on characteristics of the request, such as the User-Agent header field ("User-Agent Sniffing") — doing so usually results in code that is both hard to maintain and hard to debug and would also require special attention to caching (i.e., setting a "Vary" response header field, as defined in Section 7.1.4 of [RFC7231]).
</p>

<p>
~HTMLに基づく既存の~UAの多くは、
~HTMLの
`&lt;meta http-equiv=refresh&gt;＠~HEmetadata#attr-meta-http-equiv-refresh$c
指令に遭遇したときに，~refreshを模倣することに注意。
これは、
別の~fallbackとして利用できる
— 例えば：
◎
Note that many existing HTML-based user agents will emulate a refresh when encountering an HTML &lt;meta&gt; refresh directive ([HTML], Section 4.2.5.3). This can be used as another fallback. For example:
</p>

<div class="example">
<p>
要請：
◎
Client request:
</p>

<pre class="lang-http">
GET / HTTP/1.1
Host: example.com
</pre>

<p>
対する応答：
◎
Server response:
</p>

<pre class="lang-http">
HTTP/1.1 308 Permanent Redirect
Content-Type: text/html; charset=UTF-8
Location: http://example.com/new
Content-Length: 356

&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;Permanent Redirect&lt;/title&gt;
      &lt;meta http-equiv="refresh" 
            content="0; url=http://example.com/new"&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;p&gt;
         The document has been moved to
         &lt;a href="http://example.com/new"
         &gt;http://example.com/new&lt;/a&gt;.
      &lt;/p&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
</details>
</div>

			</section>
		</section>
		<section id="status.4xx">
<h3 title="Client Error 4xx">15.5. `4xx^st</h3>

<p>
`~class$ `4xx^st に属する`状態s~code$は、
次を指示する
⇒
`~client$は、
~errorしたと見受けられる
◎
The 4xx (Client Error) class of status code indicates that the client seems to have erred.＼
</p>

<p>
`HEAD$m 要請に対し応答するときを除いて、
`~server$は，次を包含している`表現$を送信するベキである
⇒
当の~error状況の説明，および
その条件は［
一時的, 恒久的
］どちらなのか。
◎
Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.＼
</p>

<p>
これらの状態s~codeは、
どの`要請~method$にも適用-可能である。
`~UA$は、
当の応答に内包された`表現$があれば，それを利用者に表示するベキである。
◎
These status codes are applicable to any request method. User agents SHOULD display any included representation to the user.
</p>

			<section id="status.400">
<h4>15.5.1. `400^st</h4>

<p>
`状態s~code$ `400^st は、
次を指示する
⇒
`~server$は、
~client~errorに知覚される何かに因り，要請を処理できないか, するつもりがない
（例：
要請の構文が~~正しくない ／
要請~message~frame法が妥当でない ／
要請の~route法が~~誤認を誘うものである，など）。
◎
The 400 (Bad Request) status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).
</p>

			</section>
			<section id="status.401">
<h4>15.5.2. `401^st</h4>

<p>
`状態s~code$ `401^st は、
次を指示する
⇒
要請は、
`~target資源$用の妥当な認証用の`資格証$を欠如するため，
まだ適用されていない。
◎
The 401 (Unauthorized) status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.＼
</p>

<p>
`401^st0 応答を`生成-$している`~server$は、
次を包含する `WWW-Authenticate$h ~headerを送信しなければナラナイ
⇒
`~target資源$に適用-可能な，
1 個~以上の `challenge$p
◎
The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.
</p>

<div class="p">
<p>
要請が認証用の`資格証$を内包していた場合、
`401^st0 応答は，［
その`資格証$に対する権限付与は，拒否された
］ことを指示する。
`~UA$は，その応答に対し：
◎
If the request included authentication credentials, then the 401 response indicates that authorization has been refused for those credentials.＼
</p>
<ul>
	<li>
次を伴わせた上で，同じ要請を繰返してもヨイ
⇒
新たな, または他の値に置換された `Authorization$h ~header
◎
The user agent MAY repeat the request with a new or replaced Authorization header field (Section 11.6.2).＼
</li>
	<li>
［
その `401^st0 応答が，それに先立つ応答と同じ `challenge$p を包含する
］, かつ［
~UAは，認証をすでに 1 回は試みていた
］場合、
同封された表現を利用者に呈示するベキである
— それは、
通例的に，関連な診断用の情報を包含するので。
◎
If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user agent SHOULD present the enclosed representation to the user, since it usually contains relevant diagnostic information.
</li>
</ul>
</div>

			</section>
			<section id="status.402">
<h4>15.5.3. `402^st</h4>

<p>
`状態s~code$ `402^st は、
将来~利用のために予約-済みにされる。
◎
The 402 (Payment Required) status code is reserved for future use.
</p>

			</section>
			<section id="status.403">
<h4>15.5.4. `403^st</h4>

<p>
`状態s~code$ `403^st は、
次を指示する
⇒
`~server$は、
要請を解したが，その履行-を拒否している。
◎
The 403 (Forbidden) status code indicates that the server understood the request but refuses to fulfill it.＼
</p>

<p>
`~server$は、
要請が何故 禁止されたか 公にするよう望むならば，［
その事由を，応答の`内容$（もしあれば）内に述べる
］ことができる。
◎
A server that wishes to make public why the request has been forbidden can describe that reason in the response content (if any).
</p>

<p>
［
要請~内に認証用の`資格証$が供されていた
］場合、
~serverは，［
それは，~accessを是認するには足らない
］と見なしている。
`~client$は、［
同じ資格証を伴わせた要請
］を，自動的に繰返すベキでない。
~clientは、［
新たな／異なる
］資格証を伴わせるのであれば，要請を繰返してもヨイ。
しかしながら、
資格証に無関係な理由により，要請が禁止されることもある。
◎
If authentication credentials were provided in the request, the server considers them insufficient to grant access. The client SHOULD NOT automatically repeat the request with the same credentials. The client MAY repeat the request with new or different credentials. However, a request might be forbidden for reasons unrelated to the credentials.
</p>

<p>
`生成元~server$は、
禁止された`~target資源$の現在の存在を “隠したい” と望むときは，
代わりに `404$st で応答してもヨイ。
◎
An origin server that wishes to "hide" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).
</p>

			</section>
			<section id="status.404">
<h4>15.5.5. `404^st</h4>

<p>
`状態s~code$ `404^st は、
次を指示する
⇒
`生成元~server$は、
`~target資源$用の現在の`表現$を見出せなかったか，
それが存在するとしても それを開示する用意はない。
◎
The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.＼
</p>

<p>
`404^st0 は、
この［
表現の欠如
］は［
一時的, 恒久的
］どちらなのかは，指示しない。
`生成元~server$が，その条件は恒久的になる見込みが高いことを
— 大概は，何らかの環境設定-可能な手段を通して —
知る場合、
`404^st0 よりも `410$st が選好される。
◎
A 404 status code does not indicate whether this lack of representation is temporary or permanent; the 410 (Gone) status code is preferred over 404 if the origin server knows, presumably through some configurable means, that the condition is likely to be permanent.
</p>

<p>
`404^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 404 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.405">
<h4>15.5.6. `405^st</h4>

<p>
`状態s~code$ `405^st は、
次を指示する
⇒
【！`request-line$p 内に】
受信した~methodは、
`生成元~server$に既知ではあるが，
`~target資源$においては~supportされない。
◎
The 405 (Method Not Allowed) status code indicates that the method received in the request-line is known by the origin server but not supported by the target resource.＼
</p>

<p>
`生成元~server$は、
`405^st0 応答~内に，
次を包含する `Allow$h ~headerを`生成-$しなければナラナイ
⇒
~target資源が現在~supportしている~methodたちが成す~list
◎
The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.
</p>

<p>
`405^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 405 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.406">
<h4>15.5.7. `406^st</h4>

<p>
`状態s~code$ `406^st は、
次を指示する
⇒
`~target資源$の現在の`表現$には，［
要請~内に受信された`~proactive折衝~header$に則って，`~UA$に受容-可能になるもの
］は無いことに加え、
`~server$は，既定の表現を給する用意はない。
◎
The 406 (Not Acceptable) status code indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request (Section 12.1), and the server is unwilling to supply a default representation.
</p>

<p>
`~server$は、
次を包含する`内容$を`生成-$するベキである
⇒
［
利用者／`~UA$
］が最も適切なものを選べるような，一群の［
可用な`表現$の特性, それに対応する資源~識別子
］からなる~list
◎
The server SHOULD generate content containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate.＼
</p>

<p>
`~UA$は、
この~listから，最も適切な選択肢を自動的に選定してもヨイ。
しかしながら，状態s~code `300$st にて述べたとおり、
この仕様は，そのような自動~選定~用の標準は何も定義しない。
◎
A user agent MAY automatically select the most appropriate choice from that list. However, this specification does not define any standard for such automatic selection, as described in Section 15.4.1.
</p>

			</section>
			<section id="status.407">
<h4>15.5.8. `407^st</h4>

<p>
`状態s~code$ `407^st は、
`401$st に類似するが，次を指示する
⇒
`~client$は、
【！this】当の要請~用に`~proxy$を利用するためには，自身を認証してもらう必要がある。
◎
The 407 (Proxy Authentication Required) status code is similar to 401 (Unauthorized), but it indicates that the client needs to authenticate itself in order to use a proxy for this request.＼
</p>
<ul>
	<li>
`~proxy$は、
当の要請~用に
`Proxy-Authenticate$h ~headerを
— 自身に適用-可能な `challenge$p を包含して —
送信しなければナラナイ。
◎
The proxy MUST send a Proxy-Authenticate header field (Section 11.7.1) containing a challenge applicable to that proxy for the request.＼
</li>
	<li>
`~client$は、
次を伴わせた上で，同じ要請を繰返してもヨイ
⇒
新たな, または他の値に置換された，
`Proxy-Authorization$h ~header
◎
The client MAY repeat the request with a new or replaced Proxy-Authorization header field (Section 11.7.2).
</li>
</ul>

			</section>
			<section id="status.408">
<h4>15.5.9. `408^st</h4>

<p>
`状態s~code$ `408^st は、
次を指示する
⇒
`~server$は、
待機するよう準備された時間~内に，要請~messageを`完全$に受信しなかった。
◎
The 408 (Request Timeout) status code indicates that the server did not receive a complete request message within the time that it was prepared to wait.
</p>

<p>
`~client$は、
応答待ち要請があれば，同じ要請を繰返してもヨイ。
現在の接続は利用-不能な場合
（例：~HTTP11において，要請の区切りが失われたときなど）、
新たな接続が利用されることになる。
◎
If the client has an outstanding request in transit, it MAY repeat that request. If the current connection is not usable (e.g., as it would be in HTTP/1.1 because request delimitation is lost), a new connection will be used.
</p>

			</section>
			<section id="status.409">
<h4>15.5.10. `409^st</h4>

<p>
`状態s~code$ `409^st は、
次を指示する
⇒
`~target資源$の現在の状態との競合に因り，要請を完了できなかった。
◎
The 409 (Conflict) status code indicates that the request could not be completed due to a conflict with the current state of the target resource.＼
</p>

<p>
この~codeは、［
利用者は、
競合を解決-可能で，要請を提出し直せる
］かもしれない状況で利用される。
`~server$は、［
利用者が競合の~sourceを認識するに十分な情報
］を内包する`内容$を`生成-$するベキである。
◎
This code is used in situations where the user might be able to resolve the conflict and resubmit the request. The server SHOULD generate content that includes enough information for a user to recognize the source of the conflict.
</p>

<p>
競合は、
`PUT$m 要請に対する応答にて生じる見込みが最も高い。
例えば，`生成元~server$は、［
`資源$に~version法が利用されている下で，
`PUT$m している`表現$が［
~~以前に（第三者-主体からの）要請により為されたもの
］と競合するような［
資源に対する変更
］を含む
］場合に，［
要請を完了できないことを指示する `409^st0 応答
］を利用できる。
この事例では、
応答の`表現$は，［
改訂~履歴に基づいて，相違点を併合するために有用になる情報
］を包含することになる見込みが高い。
◎
Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the representation being PUT included changes to a resource that conflict with those made by an earlier (third-party) request, the origin server might use a 409 response to indicate that it can't complete the request. In this case, the response representation would likely contain information useful for merging the differences based on the revision history.
</p>

			</section>
			<section id="status.410">
<h4>15.5.11. `410^st</h4>

<p>
`状態s~code$ `410^st は、
次を指示する
⇒
`生成元~server$における`~target資源$への~accessは，もはや可用でなく、
その条件は恒久的になる見込みが高い。
◎
The 410 (Gone) status code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.＼
</p>

<p>
`生成元~server$は、
条件が恒久的になるかどうか判らない場合は，
代わりに `404$st を利用する~OUGHT。
◎
If the origin server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) ought to be used instead.
</p>

<p>
`410^st0 応答は、
首に，~web保守の~taskを支援するために意図されている
— それは、
当の`資源$は意図的に可用でなくされ，~server所有者は［
当の資源への~remote~linkは除去する
］よう欲していることを`受信者$に通知する。
そのような~eventは、
臨時の販促~serviceや, ［
各個人に所属する資源が，もはや `生成元~server$の~siteに結付けられなくなったとき
］に，共通的にある。
恒久的に可用でない資源すべてを［
“~~消失した” ものと~markしたり，その~markをいつまでも保つ
］ことは、
必要yでない
— それは、
~server所有者の裁量に~~委ねられる。
◎
The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer associated with the origin server's site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time -- that is left to the discretion of the server owner.
</p>

<p>
`410^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 410 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.411">
<h4>15.5.12. `411^st</h4>

<p>
`状態s~code$ `411^st は、
次を指示する
⇒
`~server$は、
`Content-Length$h が定義されてない要請の受容-を拒否した。
◎
The 411 (Length Required) status code indicates that the server refuses to accept the request without a defined Content-Length (Section 8.6).＼
</p>

<p>
`~client$は、
同じ要請を，次を追加した上で繰返してもヨイ
⇒
要請の`内容$の長さを包含している，妥当な `Content-Length$h ~header
◎
The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the request content.
</p>

			</section>
			<section id="status.412">
<h4>15.5.13. `412^st</h4>

<p>
`状態s~code$ `412^st は、
次を指示する
⇒
ある`条件付き要請~header$にて与えられた条件が，
`~server$上で~testされたときに ~F に`評価-$された。
◎
The 412 (Precondition Failed) status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server (Section 13).＼
</p>

<p>
この応答~状態s~codeは、
`~client$に次を許容する
⇒
現在の`資源$の状態（資源の現在の`表現$と~metadata）に対し，`事前条件$を設置して、
`~target資源$が期待されない状態にある場合には，`要請~method$は適用されないようにする。
◎
This response status code allows the client to place preconditions on the current resource state (its current representations and metadata) and, thus, prevent the request method from being applied if the target resource is in an unexpected state.
</p>

			</section>
			<section id="status.413">
<h4>15.5.14. `413^st</h4>

<p>
`状態s~code$ `413^st は、
次を指示する
⇒
要請の`内容$は，`~server$が［
処理-可能な／処理する用意がある
］ものより巨大なため、
~serverは，要請を処理するのを拒否している。
◎
The 413 (Content Too Large) status code indicates that the server is refusing to process a request because the request content is larger than the server is willing or able to process.＼
</p>

<p>
`~server$は
⇒＃
利用-中にある`~protocol~version$が許容するならば，要請を終了してもヨイ／
他の場合、接続を~closeしてもヨイ
◎
The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.
</p>

<p>
条件が一時的である場合，`~server$は、
`Retry-After$h ~headerを`生成-$して，次を指示するベキである
⇒
条件は一時的であること, および`~client$は いつ再び試行してよいか
◎
If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.
</p>

			</section>
			<section id="status.414">
<h4>15.5.15. `414^st</h4>

<p>
`状態s~code$ `414^st は、
次を指示する
⇒
`~target~URI$は，`~server$が解釈する用意がある~~長さより長いため、
~serverは，要請に対する~serviceを拒否している。
◎
The 414 (URI Too Long) status code indicates that the server is refusing to service the request because the target URI is longer than the server is willing to interpret.＼
</p>

<p>
この稀な条件が生じるのは、
ほぼ，次のときに限られる：
◎
This rare condition is only likely to occur＼
</p>
<ul>
	<li>
~clientが `POST$m 要請を，不適正に，長い `query$p 情報を伴う `GET$m 要請に変換した。
◎
when a client has improperly converted a POST request to a GET request with long query information,＼
</li>
	<li>
~clientが~redirectionの無限~loopに陥った
（例：~URI接頭辞の~redirect先が，接頭辞~自身に接尾辞を付加したものになっている）。
◎
when the client has descended into an infinite loop of redirection (e.g., a redirected URI prefix that points to a suffix of itself) or＼
</li>
	<li>
~clientが~~可能性がある~securityの穴を悪用するよう，~serverを攻撃している。
◎
when the server is under attack by a client attempting to exploit potential security holes.
</li>
</ul>

<p>
`414^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 414 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.415">
<h4>15.5.16. `415^st</h4>

<p>
`状態s~code$ `415^st は、
次を指示する
⇒
`~target資源$に対しては，［
要請の`内容$は，要請の~methodが~supportする形式ではない
］ため、
`生成元~server$は，要請に対する~serviceを拒否している。
◎
The 415 (Unsupported Media Type) status code indicates that the origin server is refusing to service the request because the content is in a format not supported by this method on the target resource.
</p>

<p>
形式の問題は、［
要請が指示した
`Content-Type$h ／ `Content-Encoding$h
］に因ることも, ［
要請の~dataを直に検分した結果
］に因ることもある
— 当の問題が：
◎
The format problem might be due to the request's indicated Content-Type or Content-Encoding, or as a result of inspecting the data directly.
</p>
<ul>
	<li>
~supportされない`内容~符号法$によるものである場合
⇒
`Accept-Encoding$h 応答~headerを利用して，
どの`内容~符号法$が（もし在れば）要請~内に受容されるかを指示する~OUGHT。
◎
If the problem was caused by an unsupported content coding, the Accept-Encoding response header field (Section 12.5.3) ought to be used to indicate which (if any) content codings would have been accepted in the request.
</li>
	<li>
~supportされない`~MIME型$によるものである場合
⇒
`Accept$h 応答~headerを利用して，
どの~MIME型が要請~内に受容されるかを指示できる。
◎
On the other hand, if the cause was an unsupported media type, the Accept response header field (Section 12.5.1) can be used to indicate which media types would have been accepted in the request.
</li>
</ul>

			</section>
			<section id="status.416">
<h4>15.5.17. `416^st</h4>

<p>
`状態s~code$ `416^st は、
次を指示する
⇒
要請の `Range$h ~header にて要請された範囲たちが成す集合は、
次のいずれかに該当するので却下された
⇒＃
`満足可能$1な範囲は無い／
過度に［~~細切れであるか重合している］（~DoS攻撃にもなり得る）
◎
The 416 (Range Not Satisfiable) status code indicates that the set of ranges in the request's Range header field (Section 14.2) has been rejected either because none of the requested ranges are satisfiable or because the client has requested an excessive number of small or overlapping ranges (a potential denial of service attack).
</p>

<p>
各 `範囲~単位$が、［
その単位に基づく各~範囲【！範囲~集合】が`満足可能$1になるためには何が要求されるか
］を定義する。
例えば，`~byte範囲§は、
各~byte範囲【！集合】は何をもって`満足可能$1とされるかを定義する。
◎
Each range unit defines what is required for its own range sets to be satisfiable. For example, Section 14.1.2 defines what makes a bytes range set satisfiable.
</p>

<p>
`~server$は、
この`状態s~code$を［
`~byte範囲$の要請に対する応答
］内に`生成-$するときは，［
`選定された表現$の現在の長さ
］を指定する `Content-Range$h ~headerを`生成-$するベキである。
◎
A server that generates a 416 response to a byte-range request SHOULD generate a Content-Range header field specifying the current length of the selected representation (Section 14.4).
</p>

<div class="example">

<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
</pre>
</div>

<p class="note">注記：
~serverは `Range$h を無視してかまわないので、
多くの実装は，`選定された表現$全体を伴う `200$st 応答で応答する。
その~~理由の一部は、
ほとんどの~clientが，
（たとえ~~効率が劣るとしても）
`200$st を受信して~taskを完了するように準備されているためであり、
また，~clientには［
`完全$な表現を受信するまで，妥当でない`範囲~要請$を為すのを停止しない
］ものもあるためである。
したがって，~clientは、
`416$st 応答の受信には
— それが最も適切になるときでも —
依存できない。
◎
Note: Because servers are free to ignore Range, many implementations will respond with the entire selected representation in a 200 (OK) response. That is partly because most clients are prepared to receive a 200 (OK) to complete the task (albeit less efficiently) and partly because clients might not stop making an invalid range request until they have received a complete representation. Thus, clients cannot depend on receiving a 416 (Range Not Satisfiable) response even when it is most appropriate.
</p>

			</section>
			<section id="status.417">
<h4>15.5.18. `417^st</h4>

<p>
`状態s~code$ `417^st は、
次を指示する
⇒
`内方$にある いずれかの`~server$にて，［
要請の `Expect$h ~header内に与えられた期待
］に応えられなかった。
◎
The 417 (Expectation Failed) status code indicates that the expectation given in the request's Expect header field (Section 10.1.1) could not be met by at least one of the inbound servers.
</p>

			</section>
			<section id="status.418">
<h4>15.5.19. `418^st0 （利用されない）</h4>

<p>
`RFC2324$r は、
~HTTPを濫用する様々な仕方を~~風刺した `April 1^en RFC であった。
そのような濫用の一つは、
応用に特有な `418^st0 状態s~codeの定義であった
— それは、
~jokeとして配備されていることが あまりに多いため，
将来の利用には利用-不能になっている。
◎
[RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of an application-specific 418 status code, which has been deployed as a joke often enough for the code to be unusable for any future use.
</p>

<p>
したがって，状態s~code `418^st0 は、
~IANA `~HTTP状態s~code~registry$cite にて予約-済みである。
すなわち、
現時点では，この状態s~codeには他の応用はアテガえないことを指示する。
将来の状況下で，その利用が要求された場合
（例： `4xx^st0 状態s~codeが枯渇した）、
別の利用が再びアテガわれ得る。
◎
Therefore, the 418 status code is reserved in the IANA HTTP Status Code Registry. This indicates that the status code cannot be assigned to other applications currently. If future circumstances require its use (e.g., exhaustion of 4NN status codes), it can be re-assigned to another use.
</p>

			</section>
			<section id="status.421">
<h4>15.5.20. `421^st</h4>

<p>
`状態s~code$ `421$st0 は、
次を指示する
⇒
要請の~direct先である`~server$は、
`~target~URI$に対し`権限的な応答$を生産-可能でないか, そうする用意はない。
◎
The 421 (Misdirected Request) status code indicates that the request was directed at a server that is unable or unwilling to produce an authoritative response for the target URI.＼
</p>

<p>
`生成元~server$
（または、
生成元~serverに利するよう動作している`~gateway$）
は、
次のいずれかに合致しない`~target~URI$を却下するときに，
`421^st0 を送信する
⇒＃
~serverに環境設定された`生成元$ ／
当の要請が受信された接続~文脈（ `7.4§ ）
◎
An origin server (or gateway acting on behalf of the origin server) sends 421 to reject a target URI that does not match an origin for which the server has been configured (Section 4.3.1) or does not match the connection context over which the request was received (Section 7.4).
</p>

<p>
`~client$は、
`421^st0 応答を受信したときは，要請を再試行してもヨイ
— 次を問わず
⇒＃
`要請~method$が`冪等$かどうか／
異なる接続~越しかどうか（`~target資源$の`生成元$に特有な，新鮮な接続など）／
代替な~service `ALTSVC$r を介するかどうか
◎
A client that receives a 421 (Misdirected Request) response MAY retry the request, whether or not the request method is idempotent, over a different connection, such as a fresh connection specific to the target resource's origin, or via an alternative service [ALTSVC].
</p>

<p>
`~proxy$は、
`421^st 応答を`生成-$してはナラナイ。
◎
A proxy MUST NOT generate a 421 response.
</p>

			</section>
			<section id="status.422">
<h4>15.5.21. `422^st</h4>

<p>
`状態s~code$ `422^st は、
次を指示する
⇒
［
`~server$は，要請の`内容$ %内容 の内容~型【`~MIME型$】を解した
（よって，状態s~code `415$st は適切でない）
］かつ［
%内容 の構文は正しい
］が、
%内容 が包含する指示書きは処理-不能である。
◎
The 422 (Unprocessable Content) status code indicates that the server understands the content type of the request content (hence a 415 (Unsupported Media Type) status code is inappropriate), and the syntax of the request content is correct, but it was unable to process the contained instructions.＼
</p>

<p>
この状態s~codeは、
例えば，次の場合に生じる
⇒
要請の`内容$は整形式な~XMLである（すなわち，構文上は正しい）が、
意味論的には~~誤った~XML指示書きである。
◎
For example, this status code can be sent if an XML request content contains well-formed (i.e., syntactically correct), but semantically erroneous XML instructions.
</p>

			</section>
			<section id="status.426">
<h4>15.5.22. `426^st</h4>

<p>
`状態s~code$ `426^st は、
次を指示する
⇒
`~server$は、［
現在の~protocolの下では，要請の遂行-を拒否した
］が，［
`~client$が異なる~protocolに昇格した後には，そうする用意がある
］かもしれない。
◎
The 426 (Upgrade Required) status code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.＼
</p>

<p>
`~server$は、
`426^st0 応答~内に［
要求される~protocol（たち）を指示する， `Upgrade$h ~header
］を送信しなければナラナイ。
◎
The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 7.8).
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.
【この~serviceには HTTP/3.0 ~protocolの利用が要求されます。】
</pre>
</div>

			</section>
		</section>
		<section id="status.5xx">
<h3 title="Server Error 5xx">15.6. `5xx^st</h3>

<p>
`~class$ `5xx^st に属する`状態s~code$は、
次を指示する
⇒
`~server$は、
自身の~errorを自覚したか，要請された~methodを遂行する能力を備えていない。
◎
The 5xx (Server Error) class of status code indicates that the server is aware that it has erred or is incapable of performing the requested method.＼
</p>

<p>
`HEAD$m 要請に対し応答するときを除いて、
`~server$は，次を包含している`表現$を送信するベキである
⇒
その~error状況の説明,
その条件は［
一時的, 恒久的
］のどちらなのか
◎
Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.＼
</p>

<p>
`~UA$は、
内包された表現があれば，それを利用者に表示するベキである。
◎
A user agent SHOULD display any included representation to the user.＼
</p>

<p>
これらの状態s~codeは、
どの`要請~method$にも適用-可能である。
◎
These status codes are applicable to any request method.
</p>

			<section id="status.500">
<h4>15.6.1. `500^st</h4>

<p>
`状態s~code$ `500^st は、
次を指示する
⇒
`~server$は、
予期しない条件に遭遇して，要請を履行できなくなった。
◎
The 500 (Internal Server Error) status code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.
</p>

			</section>
			<section id="status.501">
<h4>15.6.2. `501^st</h4>

<p>
`状態s~code$ `501^st は、
次を指示する
⇒
`~server$は、
要請を履行するために要求される機能性を~supportしない。
◎
The 501 (Not Implemented) status code indicates that the server does not support the functionality required to fulfill the request.＼
</p>

<p>
これは、
次のときに適切な応答になる
⇒
~serverは，当の`要請~method$を認識せず、
どの`資源$にも それを~supportする能力はない
◎
This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
</p>

<p>
`501^st0 応答は、
`既定では，経験的に~cache可能である$。
◎
A 501 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).
</p>

			</section>
			<section id="status.502">
<h4>15.6.3. `502^st</h4>

<p>
`状態s~code$ `502^st は、
次を指示する
⇒
［
`~gateway$／`~proxy$
］として動作している`~server$が、
要請を履行するよう試みているときに，
自身が~accessした`内方$にある~serverから妥当でない応答を受信した。
◎
The 502 (Bad Gateway) status code indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.
</p>

			</section>
			<section id="status.503">
<h4>15.6.4. `503^st</h4>

<p>
`状態s~code$ `503^st は、
次を指示する
⇒
`~server$は、
いくばくかの遅延~後に軽減される見込みが高い［
一時的な過負荷／~scheduleされた保守
］に因り，現在 要請を取扱えない。
◎
The 503 (Service Unavailable) status code indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.＼
</p>

<p>
`~server$は、
`Retry-After$h ~headerを送信して，次を示唆してもヨイ
⇒
`~client$が要請を再試行する前に待機する，適量な時間
◎
The server MAY send a Retry-After header field (Section 10.2.3) to suggest an appropriate amount of time for the client to wait before retrying the request.
</p>

<p class="note">注記：
状態s~code `503^st0 の存在は、［
過負荷~時には，その利用が~serverに要求される
］ことを含意するわけではない。
単純に接続を拒否する~serverもあり得る。
◎
Note: The existence of the 503 status code does not imply that a server has to use it when becoming overloaded. Some servers might simply refuse the connection.
</p>

			</section>
			<section id="status.504">
<h4>15.6.5. `504^st</h4>

<p>
`状態s~code$ `504^st は、
次を指示する
⇒
［
`~gateway$／`~proxy$
］として動作している~serverが，［
要請を完了するために~accessする必要がある，`上流$にある~server
］から適時に応答を受信できなかった。
◎
The 504 (Gateway Timeout) status code indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.
</p>

			</section>
			<section id="status.505">
<h4>15.6.6. `505^st</h4>

<p>
`状態s~code$ `505^st は、
次を指示する
⇒
`~server$は、［
要請~message内に利用された~HTTP`~major~version$
］を［
~supportしない／~supportを拒否した
］。
◎
The 505 (HTTP Version Not Supported) status code indicates that the server does not support, or refuses to support, the major version of HTTP that was used in the request message.＼
</p>

<p>
`~server$は、
`~client$と同じ`~major~version$を利用するどの要請に対しても，
この~error~message以外では［
完了できない／する用意はない
］ことを指示している（ `2.5§ を見よ）。
~serverは、
`505^st0 応答においては，次について述べる`表現$を`生成-$するベキである
⇒＃
その~versionが何故~supportされないか, および
自身が~supportする他の~protocol
◎
The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in Section 2.5, other than with this error message. The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by that server.
</p>

			</section>
		</section>
	</section>
</main></div>
