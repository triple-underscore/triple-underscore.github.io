<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSSOM View Module （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>

.atrisk::before {
	float: right;
	content: '◀ 広く実装されてない';
	white-space: pre;
	font-size: small;
	padding: 0.5em;
	text-decoration: underline;
	background: white;
	color: gray;
}

#_info-view {
	position: fixed;
	z-index:10;
	display: none;
	padding: 0;
	bottom: 0;
	right: 0;
	min-width:20em;
	background: #FEE;
	outline: ridge gray 4px;
}
#_info-view.show {
	display: block;
}


._test {
	background: #EFE;
	color: green;
	border: ridge green 2px;
	padding: 0.5em;
}

.trans-note {
	font-weight: normal;
}

.en::before {
	content: "↑";
	color: gray;
	display: block;
}

.dictionary-member {
	color: var(--text-color-3);
}

.element::before,
.element::after {
	content: none;
}

.aR::before {
	content: "（";
}
.aR::after {
	content: "）";
}
.aR {
	color: gray;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		collectParts: Util.collectParts,
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let idl_ifc = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if((indicator === '@') || (indicator === '!')){
		idl_ifc = key;
	}
	href = `#${key.toLowerCase()}`;
	break;
case 'mc':
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`;
	text = 'constructor';
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = (key === idl_ifc) ? idl_ifc : `${idl_ifc}-${key}`;
	href = `#dom-${href.toLowerCase()}`;
	break;
case 'opf':
case 'l':
	text = `"<code class="literal">${text}</code>"`
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}

</script>


<!--%testing demos -->
<script>

Util.DEFERRED.push(init2);

function init2(){
	repeat('input[data-params]', (e) => {
		const event = e.getAttribute('data-event') || 'click';
		e.addEventListener(event, display_attrs, false);
	});

	const DATA = {
		Window:{
			event_type: ['scroll', 'resize'],
			obj(){return window;},
			attrs: 'screen innerWidth innerHeight scrollX pageXOffset scrollY pageYOffset screenX screenY outerWidth outerHeight devicePixelRatio'
		},

		MediaQueryList:{
			obj(){
  const v = E('_test-mql_text').value.replace(/\'/g, '\"');
  this.src = 'window.matchMedia(\'' + v + '\')';
  return window.matchMedia(v);
},
			attrs: 'media matches'
		},

		Screen:{
			obj(){ return window.screen; },
			attrs: 'availWidth availHeight width height colorDepth pixelDepth'
		},

		'Element.scrollIntoView':{
			obj(){
				const top = E('_test-scrollIntoView-top').checked;
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= var tag_name= ..., top = ... ;
  var e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView(top);//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView(${top})
（クリックで元の位置へ復帰）`
				);
}
		},

		'Element.scrollIntoView0':{
			obj(){
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const behavior = E('_test-scrollIntoView-behavior').value;
				const block = E('_test-scrollIntoView-block').value;
				const inline = E('_test-scrollIntoView-inline').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= const tag_name= ... , behavior = ... , block = ... ;
  let e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView({
    behavior: behavior,
    block: block,
    inline: inline
  });//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView( { behavior: "${behavior}", block: "${block}" } )
（クリックで元の位置へ復帰）`
				);
}
		},

		'Window.scroll':{
			obj(){
				let x, y, e;
				e = E('_test-scroll-x');
				e.value = x = parseInt(e.value);
				e = E('_test-scroll-y');
				e.value = y = parseInt(e.value);
				
				const pos = {x: window.scrollX, y: window.scrollY};
				let method_name = '';
				repeat('input[name="_test-scroll-fn"]', (e) => {
					if(e.checked){
						method_name = e.id.slice('_test-scroll-'.length);
					}
				})
				if(!method_name) return;
//=
	window[method_name](x, y);//=

					revert_pos = pos;
					return(
`${method_name}(${x},${y})
（クリックで元の位置へ復帰）`
					);
			}
		},

		Element:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight'
		},

		HTMLElement:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'offsetParent offsetTop offsetLeft offsetWidth offsetHeight'
		},

		'Selection.getBoundingClientRect':{
			event_type: ['mousemove', 'keyup'],

// https://developer.mozilla.org/en-US/docs/DOM/Selection
// chrome はテキスト未選択時に getRangeAt がエラーを投出
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getBoundingClientRect();//=
			},
			attrs: 'top right bottom left width height'
		},

		'Selection.getClientRects':{
			event_type: ['mousemove', 'keyup'],
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getClientRects();//=
},
			attrs: 'length'
		},

		MouseEvent:{
			event_type: 'mousemove',
			obj(event){return event;},
			attrs: 'screenX screenY pageX pageY clientX clientY x y offsetX offsetY'
		},

		ClientRect:{
			event_type: 'mouseover',
			obj(event){return event.target.getBoundingClientRect();},
			attrs: 'top right bottom left width height'
		},

		getClientRects:{
			event_type: 'mouseover',
			obj(event){return event.target.getClientRects();},
			attrs: 'length'
		},

		elementFromPoint:{
			event_type: 'mousemove',
			obj(event){
  select(//=
    document.elementFromPoint(event.clientX, event.clientY)//=
  );
}
		},

		elementsFromPoint:{
			event_type: 'mousemove',
			obj(event){
				return(//=
document
  .elementsFromPoint(event.clientX, event.clientY)
  .map((e) => {return e.tagName;})
  .join(', ')//=
				);
			},
		},

		caretPositionFromPoint:{
			event_type: 'mousemove',
			obj(event){
  return document.caretPositionFromPoint(event.clientX, event.clientY);
},
			attrs: 'offsetNode offset'
		},

		NULL:{}
	};

	let revert_pos = null;
	let interface_name = null;
	let current_elem = null;

//	display_attrs = 
	function display_attrs(event){
		const key = event.currentTarget.getAttribute('data-params');
		interface_name = key;
		revert_pos = null;

		window.addEventListener('click', disable_view, true);
		if(! ('event_type' in DATA[key])) {
			show_attrs();
			interface_name = null;
			return;
		}
		switch(key){
		case 'Window':
		case 'Selection.getBoundingClientRect':
		case 'Selection.getClientRects':
			show_attrs();
		}
		enable_listener(true);
	}

	E('_test-mql_text').onfocus = () => {
		E('_test-mql_text').onfocus = null;
		const mql_options = E('_MQL_options');
		for( const mq of mql_options.firstChild.data.split(';') ){
			const option = C('option');
			option.textContent = mq.trim();
			mql_options.appendChild(option);
		};
	}

return;

//	var select = document.body.classList ? select1 : function(){};
	function select(e){
		hilight(false);
		current_elem = e;
		hilight(true);
		function hilight(h){
			if(!current_elem) return;
			// outline style はどの要素からも利用されていないものと見なす
			current_elem.style.outline = h ? 'solid red 1px' : '';
		}
	}

	function enable_listener(enable){
		let types = interface_name && DATA[interface_name].event_type;
		if(!types) return;
		if(typeof(types) === 'string'){
			types = [types];
		}
		for( const type of types){
			enable?
				window.addEventListener(type, show_attrs, false):
				window.removeEventListener(type, show_attrs, false);
		}
	}

	function disable_view(event){
		E('_info-view').className = '';
		enable_listener(false);
		window.removeEventListener('click', disable_view, true);
		select(null);
		if(revert_pos) {
			if(!event.target.onclick){
				window.scrollTo(revert_pos.x, revert_pos.y);
			}
			revert_pos = null;
		}
	}

	function show_attrs(event){
		let obj;
		const data = DATA[interface_name];
		try {
			obj = data.obj(event);
		} catch(e){
			show_text(
`次の実行に失敗：
  ${source_of(data)}`
			);
			enable_listener(false);
			return;
		}
		if(!obj) return;
		let texts = [];
		if(typeof(obj) === 'string'){
			texts[0] = obj;
		} else if('attrs' in data){
			texts = ['● オブジェクト：', source_of(data), '● 属性：'];
			let attrs = data.attrs;
			if(typeof(attrs) === 'string'){
				attrs = data.attrs = attrs.split(' ');
			}
			for( const name of attrs ){
				texts.push(
`${(name + '                     ').slice(0, 18)}:${obj[name]}`
				)
			};
		}
		if(event && (event.type === 'mouseover')){
			select(event.target);
		}
		show_text(texts.join('\n'));
	}
	
	function show_text(text){
		E('_info-box').textContent = text;
		E('_info-view').className = 'show';
	}

	function source_of(data){
		if('src' in data) return data.src;
		const s = data.obj.toString ?
			data.obj.toString() : '(ソースコードを取得できません。)';
		const m = s.match(/\/\/=([^\0]+)\/\/=|return\s([^;}]+)/);
		return data.src = ((m && (m[1] || m[2])) || s).trim();
	}

}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSSOM View Module
spec_date:2020-02-20
trans_update:2020-05-14
source_checked:180721
page_state_key:CSS
original_url:https://drafts.csswg.org/cssom-view-1/
	abbr_url:CSSOMVIEW
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2020,permissive
trans_1st_pub:2012-09-22


●●class_map
e:element
a:attr
et:event-type
mb:dictionary-member
p:property
d:descriptor
css:css
v:value
aR:aR
op:op

●●tag_map
I:code
m:code
mb:code
mc:code
et:code
e:code
a:code
p:code
d:code
css:code
c:code
v:code
V:var
aR:span
b:b
op:span

●●original_id_map

●●mdn_urls
propdef-scroll-behavior:CSS/scroll-behavior

mediaquerylist:API/MediaQueryList
mediaquerylistevent:API/MediaQueryListEvent
screen:API/Screen
caretposition:API/CaretPosition
geometryutils:API/GeometryUtils
dictdef-scrolltooptions:API/ScrollToOptions
	dictdef-scrolloptions:API/ScrollOptions
	dictdef-mediaquerylisteventinit:API/MediaQueryListEventInit
	dictdef-scrollintoviewoptions:API/ScrollIntoViewOptions
	dictdef-boxquadoptions:API/BoxQuadOptions
	dictdef-convertcoordinateoptions:API/ConvertCoordinateOptions
	enumdef-scrollbehavior:API/ScrollBehavior
	enumdef-scrolllogicalposition:API/ScrollLogicalPosition
	enumdef-cssboxtype:API/CSSBoxType
	typedefdef-geometrynode:API/GeometryNode

eventdef-window-resize:API/Window/resize_event
eventdef-document-scroll:API/Document/scroll_event
	eventdef-mediaquerylist-change:API/MediaQueryLis/change_event

●●link_map

	●IDL
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject
Replaceable:~WEBIDLjs#Replaceable
Exposed:~WEBIDLjs#Exposed

CSSOMString:~CSSOM1#cssomstring
I.ScrollBehavior:#enumdef-scrollbehavior
I.ScrollOptions:#dictdef-scrolloptions
I.ScrollToOptions:#dictdef-scrolltooptions
I.MediaQueryList:#mediaquerylist
I.MediaQueryListEvent:#mediaquerylistevent
I.MediaQueryListEventInit:#dictdef-mediaquerylisteventinit

I.ScrollLogicalPosition:#enumdef-scrolllogicalposition
I.ScrollIntoViewOptions:#dictdef-scrollintoviewoptions

I.Screen:#screen
I.CaretPosition:#caretposition
I.CSSBoxType:#enumdef-cssboxtype
I.BoxQuadOptions:#dictdef-boxquadoptions
I.ConvertCoordinateOptions:#dictdef-convertcoordinateoptions
I.GeometryUtils:#geometryutils
I.GeometryNode:#typedefdef-geometrynode

I.Window:~WINDOW#window

I.Document:~DOM4#interface-document
I.Element:~DOM4#interface-element
I.Text:~DOM4#interface-text
I.Node:~DOM4#interface-node
I.Range:~DOM4#interface-range

I.EventTarget:~DOM4#interface-eventtarget
I.EventListener:~DOM4#interface-eventtarget
	#eventlistener
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#interface-event
	#EventInit
I.HTMLElement:~HTMLdom#htmlelement
I.WindowProxy:~WINDOW#windowproxy
I.HTMLImageElement:~HEimages#htmlimageelement
I.EventHandler:~WAPI#eventhandler

I.MouseEvent:~UIEVENTS#interface-mouseevent
I.MouseEventInit:~UIEVENTS#dictdef-mouseeventinit

I.CSSPseudoElement:~CSSPSEUDO#csspseudoelement

I.DOMPoint:~GEOMETRY#dompoint
I.DOMPointInit:~GEOMETRY#dictdef-dompointinit
I.DOMRect:~GEOMETRY#domrect
I.DOMRectList:~GEOMETRY#domrectlist
I.DOMRectReadOnly:~GEOMETRY#domrectreadonly
I.DOMQuad:~GEOMETRY#domquad
I.DOMQuadInit:~GEOMETRY#dictdef-domquadinit

m.AT_TARGET:~DOM4#dom-event-at_target
	bubbles:~DOM4#
m.removeEventListener:~DOM4#dom-eventtarget-removeeventlistener
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.type:~DOM4#dom-event-type
m.isTrusted:~DOM4#dom-event-istrusted
m.startContainer:~DOM4#dom-range-startcontainer
m.startOffset:~DOM4#dom-range-startoffset
m.type:~DOM4#dom-event-type
m.open:~WINDOW#dom-window-open
m.defaultView:~WINDOW#dom-document-defaultview

mb.block:#dom-scrollintoviewoptions-block
mb.inline:#dom-scrollintoviewoptions-inline
mb.behavior:#dom-scrolloptions-behavior
mb.left:#dom-scrolltooptions-left
mb.top:#dom-scrolltooptions-top

mb.media:#dom-mediaquerylisteventinit-media
mb.matches:#dom-mediaquerylisteventinit-media
mb.box:#dom-boxquadoptions-box
mb.relativeTo:#dom-boxquadoptions-relativeto
mb.fromBox:#dom-convertcoordinateoptions-frombox
mb.toBox:#dom-convertcoordinateoptions-tobox

opf.width:#supported-open-feature-name-width
opf.height:#supported-open-feature-name-height
opf.left:#supported-open-feature-name-left
opf.top:#supported-open-feature-name-top

et.resize:#eventdef-window-resize
et.scroll:#eventdef-document-scroll

l.auto:#dom-scrollbehavior-auto
l.smooth:#dom-scrollbehavior-smooth

l.start:#dom-scrolllogicalposition-start
l.center:#dom-scrolllogicalposition-center
l.end:#dom-scrolllogicalposition-end
l.nearest:#dom-scrolllogicalposition-nearest

l.margin:#dom-cssboxtype-margin
l.border:#dom-cssboxtype-border
l.padding:#dom-cssboxtype-padding
l.content:#dom-cssboxtype-content

e.body:~HEsections#the-body-element

et.change:#eventdef-mediaquerylist-change

	●css
css.px:~CSSVAL#px

d.color:~MQ4#descdef-media-color
	#mf-colors

p.scroll-behavior:#propdef-scroll-behavior
p.position:~CSSPOS#propdef-position
p.direction:~CSSWM#propdef-direction
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.display:~CSSDISP#propdef-display
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.pointer-events:~SVGinteract#PointerEventsProperty

v.auto:#valdef-scroll-behavior-auto
v.smooth:#valdef-scroll-behavior-smooth

v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden
v.visible:~CSSOVERFLOW3#valdef-overflow-visible
v.clip:~CSSOVERFLOW3#valdef-overflow-clip

v.table:~CSSDISP#valdef-display-table
v.inline-table:~CSSDISP#valdef-display-inline-table
v.table-column:~CSSDISP#valdef-display-table-column
v.table-column-group:~CSSDISP#valdef-display-table-column-group


	●用語
同じ側:#_same-side
有効~横幅:#_effective-width
有効~縦幅:#_effective-height
文書:#_document

内容~辺:#content-edge
~padding辺:#padding-edge
~border辺:#border-edge
~margin辺:#margin-edge
開始辺:#beginning-edges
終止辺:#ending-edges
表示域:#viewport
~canvas:#canvas
根~要素:#root-element

~supportされる~open_m特能~名:#supported-open-feature-name
媒体~query~list:#media-query-list
mq.媒体:#mediaquerylist-media
mq.文書:#mediaquerylist-document
mq.合致状態:#mediaquerylist-matches-state
有限~値に正規化-:#normalize-non-finite-values
~page~zoom:#page-zoom
~pinch~zoom:#pinch-zoom

~scrollされる区画:#scrolling-area
~scrollされる~box:#scrolling-box
~scroll可能になり得る:#potentially-scrollable
~scroll可能になり得ない:#potentially-scrollable
~scroll処理待ち~list:#pending-scroll-event-targets
要素を~scrollする:#scroll-an-element
瞬時に~scrollする:#concept-instant-scroll
瞬時に:#concept-instant-scroll
滑らかに~scrollする:#concept-smooth-scroll
滑らか:#concept-smooth-scroll
滑らかな~scroll:#concept-smooth-scroll
~scrollを遂行する:#perform-a-scroll
~viewの中へ~scrollする:#scroll-an-element-into-view
文書の開始位置に~scrollする:#scroll-to-the-beginning-of-the-document
中止-:#smooth-scroll-aborted
完了-:#smooth-scroll-completed

矩形:#concept-geometry-rectangle
原点:#concept-geometry-rectangle-origin
x 座標:#concept-geometry-rectangle-x-coordinate
y 座標:#concept-geometry-rectangle-y-coordinate
横幅:#concept-geometry-rectangle-width
縦幅:#concept-geometry-rectangle-height

機器~pixel比を決定する:#determine-the-device-pixel-ratio

変形:#transforms

~layout~box:#layout-box
~CSS~layout~box:#css-layout-box
~SVG~layout~box:#svg-layout-box
	媒体~query~list ~listenerの~list:#list-of-media-query-list-listeners
	媒体~query~list :#media-query-list
~caret位置:#caret-position
~caret~node:#caret-node
~caret~offset:#caret-offset
~caret範囲:#caret-range

~overflow方向:#overflow-directions
~resizeと移動-は許容され:#allowed-to-resize-and-move

~Webに公開される~screen区画:#web-exposed-screen-area
~Webに公開される可用な~screen区画:#web-exposed-available-screen-area

~HTML~body要素:#the-html-body-element
~body要素:~HTMLdom#the-body-element-2
閲覧文脈の特能を設定しておく:#set-up-browsing-context-features

文書~用の媒体~queryを評価して変化を報告する:#evaluate-media-queries-and-report-changes
文書の~resize手続き:#run-the-resize-steps
文書の~scroll手続き:#run-the-scroll-steps

	●用語（CSS
~CSS~pixel:~CSSVAL#px

内容~区画:~CSSBOX#content-area
媒体~query~listとして構文解析する:~CSSOM1#parse-a-media-query-list

	媒体~query~listを直列化する:~CSSOM1#serialize-a-media-query-list
匿名~塊~box:~CSS2VISUREN#anonymous-block-level

塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end
塊~flow方向:~CSSWM#block-flow-direction
行内~基底~方向:~CSSWM#inline-base-direction

~box断片:~CSSBREAK#box-fragment

平坦~tree:~CSSSCOPING#flat-tree

	■補完
行内:~CSSDISP#inline
包含塊:~CSSDISP#containing-block
初期~包含塊:~CSSDISP#initial-containing-block
置換d要素:~CSSDISP#replaced-element
~box~tree:~CSSDISP#box-tree

絶対~位置決め包含塊:~CSSPOS#absolute-positioning-containing-block
固定d位置決め包含塊:~CSSPOS#fixed-positioning-containing-block
~flow外:~CSSDISP#out-of-flow

~typographic文字~単位:~CSSTEXT#typographic-character-unit
書記素~cluster:~CSSTEXT#grapheme-cluster

	●用語（外部


~map:~INFRA#ordered-map
符号単位:~INFRA#code-unit

~live:~HTMLINFRA#live
~HTML要素:~HTMLINFRA#html-elements
文字の大小は区別される:~HTMLINFRA#case-sensitive
文字大小区別:~HTMLINFRA#case-sensitive
整数として構文解析する:~HTMLcms#rules-for-parsing-integers

閲覧文脈:~BROWSERS#browsing-context
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
作動中の文書:~BROWSERS#active-document
近しい:~BROWSERS#familiar-with

結付けられている文書:~WINDOW#concept-document-window

同一-生成元:~ORIGIN#same-origin

~event~loop:~WAPI#event-loop
~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
現任の設定群~obj:~WAPI#incumbent-settings-object
担当の閲覧文脈:~WAPI#responsible-browsing-context
描画を更新する段:~WAPI#update-the-rendering

~event~listener:~DOM4#concept-event-listener
evL.type:~DOM4#event-listener-type
evL.callback:~DOM4#event-listener-callback
evL.capture:~DOM4#event-listener-capture
~event~listener~list:~DOM4#eventtarget-event-listener-list
~event~listenerを追加する:~DOM4#add-an-event-listener
~event~listenerを除去する:~DOM4#remove-an-event-listener
~eventを発火する:~DOM4#concept-event-fire
配送~flag:~DOM4#dispatch-flag
過去互換~mode:~DOM4#concept-document-quirks

包含され:~DOM4#contained
部分的に包含され:~DOM4#partially-contained
中身:~DOM4#concept-range-content
境界点:~DOM4#concept-range-bp

始端:~DOM4#concept-range-start
終端:~DOM4#concept-range-end
	文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element

閉な~shadowで隠されて:~DOM4#concept-closed-shadow-hidden

	●追加
座標から~scroll~optionsを作成する:#_create-a-new-scroll-options

dir:~HTMLLS/elements.html#the-dir-attribute

畳まれて:~DOM4#range-collapsed
~target:~DOM4#event-target

●●words_table1

open_m: <code>open()</code>


●●words_table


代用対:surrogate pair::サロゲートペア:
pixel::::ピクセル
	セット:set
		→ ON, OFF

	●CSS layout
	viewport
ascent::::アセント
descent::::ディセント
断片:fragment::~
resize::::リサイズ
col:column
	bounding ボックス:bounding box
	bounding ボーダーボックス:bounding border box
限界:bounding::~
限界域:bounds::~
要素境界:element bounding border box::~
縦組み:vertical writing mode::~
描画面:rendering surface::~
中身:content::~
横書き:horizontal writing::~
整列-:align::~
整列:alignment::~
固定d:fixed::固定

	●塗り
alpha::::アルファ
塗られ:paintされ:~
塗り:paint:~

	●scroll／UI
目的位置:position:~
bar::::バー
zoom::::ズーム
	zoom法:zooming
拡大:zoom::~
caret::::キャレット
pinch::::ピンチ
滑らか:smooth::~
倍率:scale factor:~
処理待ち:pending:~
接触判定:hit-testing::~
挿入位置指示:insertion point indicator:~
瞬時:instant::~
計量:metric:~
周期:interval:~
進行中:ongoing:~
行為:action::~

	~scrollされる〜:scrolling〜
	~scroll法:scrolling
	~~位置

	●幾何
幾何:geometry:~
地点:position:~
点:point:~
右横書き:right-to-left:~
	右横書き:RTL
横方向:horizontal::~
縦方向:vertical::~
上辺:top edge::~
下辺:bottom edge::~
左辺:left edge::~
右辺:right edge::~
上方:upward::~
下方:downward::~
左方:leftward::~
右方:rightward::~
開始辺:beginning edge::~
終止辺:ending edge::~
辺:edge::~
有効横幅:有効 width::~
有効縦幅:有効 height::~
	innermost, outermost

矩形:rectangle:~
四辺形:quadrilateral shape:~
変形:transform::~
	transforms
増大-:increase:~
比:ratio:~

	●DOM／IDL
現任の:incumbent:~
閉な:closed::閉じた
隠され:hideされ:~
shadow:
平坦:flat::~
拡張属性:extended attribute::~
補助:auxiliary:~
境界点:boundary point::~

	●仕様
utility::ユーティリティ
慣行:conventions:~
見積もり:estimation:~
網羅的:exhaustive:~
文書化-:document:~
修正点:fixes:~

	により定義される:-defined
	詳細:specifics
	に配慮する:considerations
	知られ:known to
	~~正しい:right
	~~適度な:not get too 〜
	ふりをする:masquerade

	●構文
剥いだ:stripした:~

	●未分類
assoc:associated:関連
body:
色:color:~
色域:color gamut:~
深度:depth:~
割振られ:allocateされ:割り振られ
標的:target:~
切詰める:clampする:切り詰める
書記素:grapheme::~
typographic::::タイポグラフィック
	片割れhalf
	全部的な full
合致:match::~::マッチ
合致状態:matches state::~::マッチ状態
	形:form
選択-:select:~
単位:unit:~
担当の:responsible:~
座標軸:axis::~

	magnifying
	揃え／align


●●ref_normative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 4. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/ 
[CSS-DEVICE-ADAPT]
    Rune Lillesveen; Florian Rivoal; Matt Rakow. CSS Device Adaptation Module Level 1. 29 March 2016. WD. URL: https://www.w3.org/TR/css-device-adapt-1/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 11 July 2019. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 31 July 2018. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 25 February 2019. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. CSS Scoping Module Level 1. 3 April 2014. WD. URL: https://www.w3.org/TR/css-scoping-1/ 
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. CSS Text Module Level 3. 13 November 2019. WD. URL: https://www.w3.org/TR/css-text-3/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS-VALUES]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS3-BOX]
    Elika Etemad. CSS Box Model Module Level 3. 18 December 2018. WD. URL: https://www.w3.org/TR/css-box-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[GEOMETRY-1]
    Simon Pieters; Chris Harrelson. Geometry Interfaces Module Level 1. 4 December 2018. CR. URL: https://www.w3.org/TR/geometry-1/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead; Doug Schepers. UI Events. 30 May 2019. WD. URL: https://www.w3.org/TR/uievents/ 
[WEBIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[SVG2]
    Amelia Bellamy-Royds; et al. Scalable Vector Graphics (SVG) 2. 4 October 2018. CR. URL: https://www.w3.org/TR/SVG2/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSSOM View Module</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/cssom-view-1/
編集者草案
	https://drafts.csswg.org/cssom-view/
以前のバージョン
	https://www.w3.org/TR/2016/WD-cssom-view-1-20160317/
	https://www.w3.org/TR/2013/WD-cssom-view-20131217/
	https://www.w3.org/TR/2011/WD-cssom-view-20110804/
	https://www.w3.org/TR/2009/WD-cssom-view-20090804/
	https://www.w3.org/TR/2008/WD-cssom-view-20080222/
	https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/

テスト一式
	http://test.csswg.org/suites/cssom-view-1_dev/nightly-unstable/

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/cssom-view-1">GitHub Issues</a>

編集
	<a href="mailto:simon.fraser@apple.com">Simon Fraser</a> (Apple Inc)
前任編集者
	<a href="mailto:simonp@opera.com">Simon Pieters</a> (<a href="http://www.opera.com">Opera Software AS</a>)
	<a href="http://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (<a href="http://www.cox.com">Cox Communications, Inc.</a>) <a href="mailto:glenn.adams@cos.com">glenn.adams@cos.com</a>
	<a href="https://annevankesteren.nl/">Anne van Kesteren</a> (<a href="http://www.opera.com">Opera Software ASA</a>) <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/cssom-view-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/master/cssom-view-1

旧来の課題リスト
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM%20View&amp;resolution=---">Bugzilla</a>


</script>

</head>

<body>


<!--%resource pool -->
<div id="_persisted_parts" hidden>

<div id="_dgm-Window" class="_test">
利用中のブラウザで<br><!-- ※ -->
・これらの属性の
<input value="取得を試みる" data-params="Window" type="button">
<br>
・
x:<input id="_test-scroll-x" value="0" size="5" type="text">
y:<input id="_test-scroll-y" value="0" size="5" type="text">
を入力に<br>
<label><input name="_test-scroll-fn" id="_test-scroll-scroll" type="radio"><code>scroll()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollTo" type="radio"><code>scrollTo()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollBy" checked="" type="radio"><code>scrollBy()</code></label>
<!-- 
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeTo" checked /><code >resizeTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeBy" checked /><code >resizeBy()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveTo" checked /><code >moveTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveBy" checked /><code >moveBy1()</code></label>
 -->
を
<input value="呼び出す" data-params="Window.scroll" type="button">
<br>
次の媒体クエリ：<br>
<input id="_test-mql_text" value="(orientation: landscape)" size="70" list="_MQL_options" data-event="change" data-params="MediaQueryList" type="text">
<br>
に対し，
<code>Window.matchMedia()</code>
の
<input id="_test-MediaQueryList" value="取得を試みる" data-params="MediaQueryList" type="button">
<datalist id="_MQL_options" hidden><!--
(width >= 800px);
(width <= 800px);
(height >= 600px);
(height <= 600px);
(min-device-width: 640px);
(max-device-width: 640px);
(min-device-height: 480px);
(max-device-height: 480px);
(orientation: landscape);
(orientation: portrait);
(min-aspect-ratio: 1/1);
(min-aspect-ratio: 2/1);
(min-aspect-ratio: 1/2);
(max-aspect-ratio: 1/1);
(max-aspect-ratio: 2/1);
(max-aspect-ratio: 1/2);
(color);
(min-color: 8);
(max-color: 8);
(min-color-index: 256);
(max-color-index: 256);
(monochrome);
(min-resolution: 96dpi);
(max-resolution: 96dpi);
(scan: interlace);
(scan: progressive);
(grid);
(update-frequency: none);
(update-frequency: slow);
(update-frequency: normal);
(overflow-block: none);
(overflow-block: scroll);
(overflow-block: optional-paged);
(overflow-block: paged);
(overflow-inline: none);
(overflow-inline: scroll);
(inverted-colors: none);
(inverted-colors: inverted);
(pointer: none);
(pointer: fine);
(pointer: fine);
(hover: none);
(hover: on-demand);
(hover: hover);
(any-pointer: none);
(any-pointer: coarse);
(any-pointer: fine);
(any-hover: none);
(any-hover: on-demand);
(any-hover: hover);
(light-level: dim);
(light-level: normal);
(light-level: washed);
(scripting: none);
(scripting: initial-only);
(scripting: enabled);


all;braille;embossed;handheld;print;projection;screen;speech;tty;tv;aural
--></datalist>
</div>

<div id="_dgm-Screen" class="_test">
利用中のブラウザでこれらの属性の
<input value="取得を試みる" data-params="Screen" type="button">
</div>


<div id="_dgm-Document" class="_test">
利用中のブラウザでマウス位置に対する
<br>
(1) <code>elementFromPoint()</code> の結果を
<input id="_test-elementFromPoint" value="表示する" data-params="elementFromPoint" type="button">
<br>
(1) <code>elementsFromPoint()</code> の結果を成す各 要素のタグ名の
<input id="_test-elementsFromPoint" value="取得を試みる" data-params="elementsFromPoint" type="button">
<br>
(2) <code>caretPositionFromPoint()</code> の
<input id="_test-caretPositionFromPoint" value="取得を試みる" data-params="caretPositionFromPoint" type="button">
</div>


<div id="_dgm-Element" class="_test">
利用中のブラウザで<br>
マウスが重なった要素について
<br>
・これらの属性の
<input value="取得を試みる" data-params="Element" type="button"><br>
・<code>getClientRects()</code> の
<input value="取得を試みる" data-params="getClientRects" type="button"><br>
・<code>getBoundingClientRect()</code> の
<input value="取得を試みる" data-params="ClientRect" type="button">
<br>
ランダムに選ばれた
<select size="1" id="_test-scrollIntoView-tagName"><option selected="">P</option><option>LI</option><option>H2</option><option>DT</option><option>DD</option></select>
要素に対し<br>
・<code>scrollIntoView(<label><input name="_test-SIV-top" id="_test-scrollIntoView-top" checked="" type="radio">true</label>
<label><input name="_test-SIV-top" type="radio">false</label>)</code>
を
<input id="_test-scrollIntoView" value="呼び出す" data-params="Element.scrollIntoView" type="button"><br>
・<code>scrollIntoView( {
	behavior:
<select size="1" id="_test-scrollIntoView-behavior"><option selected="">auto</option><option>smooth</option></select>
	, block:
<select size="1" id="_test-scrollIntoView-block">
	<option selected="">start</option>
	<option>center</option>
	<option>end</option>
	<option>nearest</option>
</select>
	, inline:
<select size="1" id="_test-scrollIntoView-inline">
	<option>start</option>
	<option selected="">center</option>
	<option>end</option>
	<option>nearest</option>
</select>
} )</code> を
<input id="_test-scrollIntoView0" value="呼び出す" data-params="Element.scrollIntoView0" type="button">
</div>


<div id="_dgm-HTMLElement" class="_test">
利用中のブラウザでマウスが重なった要素について，これらの属性の
<input value="取得を試みる" data-params="HTMLElement" type="button">
</div>


<div id="_dgm-Range" class="_test">
利用中のブラウザでテキスト選択に応じて，その範囲に対する<br>
(1) <code>getClientRects()</code> の
<input id="_test-Selection.getClientRects" value="取得を試みる" data-params="Selection.getClientRects" type="button">
<br>
(2) <code>getBoundingClientRect()</code> の
<input id="_test-Selection.getBoundingClientRect" value="取得を試みる" data-params="Selection.getBoundingClientRect" type="button">
</div>

<div id="_dgm-MouseEvent" class="_test">
利用中のブラウザで mousemove イベントに対する，これらの属性の
<input id="_test-MouseEvent" value="取得を試みる" data-params="MouseEvent" type="button">
</div>


</div>


<header>

	<hgroup>
<h1 id="cssom-view-module">CSSOM View Module</h1>
	</hgroup>
</header>

<div  id="MAIN" hidden>

	<section id="abstract">

~ABSTRACT

<p>
この仕様で導入される API は、作者に，文書の視覚的な~viewを調べたり, 操作するための方法を与える。
これには、［
要素の~layout~boxの位置を得る,
~scriptを通して表示域~sizeを得る,
要素の~scroll法
］なども含まれる。
◎
The APIs introduced by this specification provide authors with a way to inspect and manipulate the visual view of a document. This includes getting the position of element layout boxes, obtaining the width of the viewport through script, and also scrolling an element.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
この節では、発行時点における…
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="background">

<h2 title="Background">1. 背景</h2>

<p>
この仕様にて定義される特能の多くは、長い間~browserから~supportされてきた。
この仕様の目標は、これらの特能を，すべての~browserが相互運用可能な形に実装し得るように定義することである。
仕様では、作者にとって有用になるであろう，一組の新たな特能も定義する。
(`If they are not you can bug us^en!)
◎
Many of the features defined in this specification have been supported by browsers for a long period of time. The goal of this specification is to define these features in such a way that they can be implemented by all browsers in an interoperable manner. The specification also defines a couple of new features that will hopefully be useful to authors. (If they are not you can bug us!)
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様で用いられる用語は
`DOM$r, `CSSOM$r, `HTML$r
による。
◎
Terminology used in this specification is from DOM, CSSOM and HTML. [DOM] [CSSOM] [HTML]
</p>

<p>
`~HTML~body要素@
とは、根 `~HTML要素$ `html^e の子である，最初の `body^e `~HTML要素$ である。
◎
The HTML body element is the first body HTML element child of the root HTML element html.
</p>

<p class="trans-note">【
~HTMLが定義する`~body要素$とほぼ同義（廃用にされた `frameset^e は、ここでは除外されている）。
】</p>

<p>
`文書$の
`根~要素@
は、`文書~要素$の同義語であり， ~NULL （ “無い” ）にもなり得る。
</p>

<p class="trans-note">【
この定義は、訳者による推定（例：~HTML文書であれば `html^e 要素になる）
— 原文に現れるこの語（ `root element^en ）には、明示的な定義／参照は与えられていない。
】</p>

<p>
`内容~辺@,
`~padding辺@,
`~border辺@,
`~margin辺@,
`表示域@
（ `viewport^en ）は、~CSSにて定義される。
◎
Content edge, padding edge, border edge, margin edge, and viewport are defined by CSS.
</p>

<p class="trans-note">【
参照 —
<a href="~CSSBOX#box-model">各種~辺の定義と図式</a>,
<a href="~CSS2VISUREN#viewport">表示域</a>
】</p>

<div class="p">
<p>
次のいずれかを満たす［
要素／`表示域$
］には、
`~scrollされる~box@
が結付けられる：
</p>

<ul>
	<li>
~scroll用の仕組みを備えている
</li>
	<li>
<p>
次の両者を満たす：
</p>
		<ul>
			<li>
その内容は、その内容~区画を~overflowしている
</li>
			<li>
その［
`overflow-x$p, `overflow-y$p
］いずれかの~propの使用~値は `hidden$v である
`CSS3-OVERFLOW-3$r
【！ CSS3-BOX】
</li>
		</ul>
	</li>
</ul>
◎
Elements and viewports have an associated scrolling box if has a scrolling mechanism or it overflows its content area and the used value of the overflow-x or overflow-y property is hidden. [CSS3-BOX]
</div>

<p>
`~HTML~body要素$ %~body は、次をすべて満たすとき，
`~scroll可能になり得る@
とされる。
◎
An element body (which will be the HTML body element) is potentially scrollable if all of the following conditions are true:
</p>

<ul>
	<li>
%~body は `~CSS~layout~box$を持つ。
◎
body has an associated CSS layout box.
</li>
	<li>
%~body, %~body の`親~要素$は、どちらも次を満たす
⇒
［
`overflow-x$p,
`overflow-y$p
］~propのどちらかは次を満たす
⇒
算出d値 ~NIN { `visible$v, `clip$v }
【実際には、片方の~propがこれを満たすならば両方とも満たすことになる。】
◎
body’s parent element’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
◎
body’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
</li>
</ul>

<p class="note">注記：
`body$e 要素は、`~scroll可能になり得る$としても，`~scrollされる~box$は無いこともある。
具体的には、要素の `overflow$p の使用~値は `auto^v であるが，その内容は内容~区画を~overflowしていない場合など。
◎
Note: A body element that is potentially scrollable might not have a scrolling box. For instance, it could have a used value of overflow being auto but not have its content overflowing its content area.
</p>

<p>
［
`表示域$／要素
］の`~scrollされる~box$には、 2 つの
`~overflow方向@
— `塊-終端$, `行内-終端$ —
がある。
◎
A scrolling box of a viewport or element has two overflow directions, which are the block-end and inline-end directions for that viewport or element.
</p>

<p>
［
`表示域$／要素
］の
`~scrollされる区画@
は、その`~overflow方向$に応じて，各辺が以下に従って与えられる~boxである。
◎
The term scrolling area refers to a box of a viewport or an element that has the following edges, depending on the viewport’s or element’s scrolling box’s overflow directions.
</p>

<div>

<p>
記号 %D1 は［
上方, 下方, 左方, 右方
］いずれかの方向を表し,
%D2 は その反対~方向を表すとする。
`~overflow方向$に %D1 が含まれている（したがって %D2 は含まれていない）ならば、~boxの［
%D1, %D2
］側の辺は次で与えられる：
</p>

<table>
<thead><tr><th><th>`表示域$に対しては
<th>要素に対しては
</thead>

<tbody><tr><th>%D1 側の辺
<td>
［
`初期~包含塊$の %D1 側の辺, および
`表示域$のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺。
◎
The D1-most edge of the D1 edge of the initial containing block and the D1 margin edge of all of the viewport’s descendants' boxes.
<td>
［
要素の %D1 側の`~padding辺$, および
要素のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺
— ただし，要素の先祖を`包含塊$とするような~boxは除外する††。
◎
The D1-most edge of the element’s D1 padding edge and the D1 margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><th style="white-space:nowrap;">%D2 側の辺

<td>
`初期~包含塊$の %D2 側の辺。
◎
The D2 edge of the initial containing block.
<td>
要素の %D2 側の`~padding辺$。
◎
The element’s D2 padding edge.

</tbody></table>

<p class="trans-note">【†
この子孫は、`~box~tree$における子孫を意味する。
“表示域の子孫~box” が何を意味するのか不明だが、当の文書の~box~treeを成す~boxすべてが該当すると見受けられる。
】【††
例えば，`~flow外$にある~boxなど。
】【
この箇所は、原文の内容と等価になるように，パラメタ化により大幅に圧縮して記述している。
】</p>

<div lang="en">
<table>
<thead><tr>
<th>If the overflow directions are…
<th>For a viewport
<th>For an element
</thead>

<tbody style="white-space:pre-line;"><tr><td>rightward and downward
<td>top edge
• The top edge of the initial containing block.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left edge of the initial containing block.

<td>top edge
• The element’s top padding edge.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The element’s left padding edge.

<tr><td>leftward and downward
<td>top edge
• The top edge of the initial containing block.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The element’s top padding edge.

right edge
• The element’s right padding edge.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>leftward and upward
<td>top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The element’s right padding edge.

bottom edge
• The element’s bottom padding edge.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>rightward and upward
<td>top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left edge of the initial containing block.

<td>top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The element’s bottom padding edge.

left edge
• The element’s left padding edge.
</tbody></table></div>

</div>

<p>
`~scrollされる区画$の
`原点@
は、`表示域$の`~scrollされる区画$に対しては，`初期~包含塊$の原点に~~位置し、
他の場合は，要素の~scroll位置が既定の位置にあるときの
要素の~padding辺の左上隅に~~位置する。
x, y 座標は それぞれ右方, 下方へ増大する。
◎
The origin of a scrolling area is the origin of the initial containing block if the scrolling area is a viewport, and otherwise the top left padding edge of the element when the element has its default scroll position. The x-coordinate increases rightwards, and the y-coordinate increases downwards. 
</p>

<div class="p">
<p>
［
表示域, または［
~boxあるいは要素
］
］の［
`開始辺@
／
`終止辺@
］は、その`~overflow方向$と［
反対~方向 ／ 同じ方向
］にある辺を指す（例えば，`~overflow方向$が右方と下方ならば、開始辺は左辺および上辺, 終止辺は右辺および下辺になる, 等々）。
【ここでも、原文と等価になるように，圧縮して訳している。】
</p>

◎
The beginning edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The top and left edges.
• If the overflow directions are leftward and downward
•• The top and right edges.
• If the overflow directions are leftward and upward
•• The bottom and right edges.
• If the overflow directions are rightward and upward
•• The bottom and left edges.
◎
The ending edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The bottom and right edges.
• If the overflow directions are leftward and downward
•• The bottom and left edges.
• If the overflow directions are leftward and upward
•• The top and left edges.
• If the overflow directions are rightward and upward
•• The top and right edges.
</div>

<p>
用語
`~CSS~layout~box@
は~CSSのそれと同じとする。
この仕様の要件の目的においては、
`display$p ~propの算出d値が
`table-column$v ／ `table-column-group$v
になる要素は、（それぞれ， ~col／~col~groupの） `~CSS~layout~box$を持つと見なすモノトスル。
◎
The term CSS layout box refers to the same term in CSS. For the purpose of the requirements in this specification, elements that have a computed value of the display property that is table-column or table-column-group must be considered to have an associated CSS layout box (the column or column group, respectively).
</p>

<p>
用語
`~SVG~layout~box@
は~SVGのそれと同じとする。
◎
The term SVG layout box refers to the same term in SVG.
</p>

<p class="issue">
用語
`~CSS~layout~box$,
`~SVG~layout~box$
のいずれも，現時点では~CSSや~SVGの中で定義されていない。
◎
The terms CSS layout box and SVG layout box are not currently defined by CSS or SVG.
</p>

<p>
用語
`~layout~box@
は
`~CSS~layout~box$,
`~SVG~layout~box$
のいずれか【適切な方】を指す。
◎
The term layout box refers to either a CSS layout box or an SVG layout box. 
</p>

<p class="trans-note">【
“要素に結付けられている（ ~CSS ／ ~SVG ）`~layout~box$を指して，単に
“要素の~layout~box”
と記す。
そのような~boxが存在しない（例えば描画の対象でない要素など）ことを，
“（要素は）~layout~boxを持たない”
と記す。
】</p>

<p>
用語
`変形@
は、 ~SVG ／ ~CSS による変形（座標系変換）を指す。
`SVG11$r
`CSS-TRANSFORMS-1$r
◎
The term transforms refers to SVG transforms and CSS transforms. [SVG11] [CSS-TRANSFORMS-1]
</p>

<p>
~IDL~method／属性（以下，単に “~member” ）から別の~memberが呼ばれるときは、~UAは，~memberの内部~APIを呼出すモノトスル
— すなわち、作者は~custom ECMAScript ~propや関数で上書きして，~memberの挙動を変更することはできない。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
他が指定されない限り、文字列は`文字大小区別$で比較される。
◎
Unless otherwise stated, string comparisons are done in a case-sensitive manner.
</p>

		<section id="css-pixels">

<h3 title="CSS pixels">2.1. ~CSS~pixel</h3>

<p>
特に指定されない限り、この仕様で定義される~APIに対する，すべての座標と寸法は、`~CSS~pixel$単位とする。
`CSS-VALUES$r
【この訳では、 “`px^css 単位” と略記する。】
◎
All coordinates and dimensions for the APIs defined in this specification are in CSS pixels, unless otherwise specified. [CSS-VALUES]
</p>

<p class="note">注記：
このことは、例えば `matchMedia()^m には該当しない。
そのような所では単位は明示的に与えられる。
◎
Note: This does not apply to e.g. matchMedia() as the units are explicitly given there.
</p>

		</section>
		<section id="zooming">
<h3 title="Zooming">2.2. ~zoom法</h3>

<div>
<p>
~zoomには，次の 2 種類のものがある
`CSS-DEVICE-ADAPT$r：
</p>

<dl class="def-list">
	<dt>`~page~zoom@</dt>
	<dd>
初期 表示域の~sizeに影響する。
</dd>

	<dt>`~pinch~zoom@</dt>
	<dd>
拡大鏡のように挙動して，初期 表示域や実際の表示域には影響しない。
</dd>
	<dd class="trans-note">【
局所的な~zoom。おそらく、マルチタッチ機器の~UIで利用される，二本指で “つまんで” 拡げる~~操作に由来する呼称。
】</dd>
</dl>

◎
There are two kinds of zoom, page zoom which affects the size of the initial viewport, and pinch zoom which acts like a magnifying glass and does not affect the initial viewport or actual viewport. [CSS-DEVICE-ADAPT]
</div>

		</section>
		<section id="web-exposed-screen-information">
<h3 title="Web-exposed screen information">2.3. ~Webに公開される~screen情報</h3>

<p>
~UAは、利用者の~privacyを保護するためとして，出力~機器の~screenについての情報を隠すことを選んでもヨイ。
各種~APIにわたって一貫した方式でそうするため、この仕様は、以下の区画を表す用語を定義する。
これらの各~区画は、いずれも，［
有限な ( 横幅, 縦幅 ) がある ／
左上隅を原点にとる ／
x 座標は右方に増大する ／
y 座標は下方に増大する ／
座標の単位は `px$css
］とする：
◎
User agents may choose to hide information about the screen of the output device, in order to protect the user’s privacy. In order to do so in a consistent manner across APIs, this specification defines the following terms, each having a width and a height, the origin being the top left corner, and the x- and y-coordinates increase rightwards and downwards, respectively.
</p>

<ul>
	<li>
`~Webに公開される~screen区画@
— 次のうち，いずれかになるとする
⇒＃
出力~機器の区画／
`表示域$の区画
◎
The Web-exposed screen area is one of the following:
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
	<li>
`~Webに公開される可用な~screen区画@
— 次のうち，いずれかになるとする
⇒＃
出力~機器の描画面として可用な区画／
出力~機器の区画／
`表示域$の区画／
◎
The Web-exposed available screen area is one of the following:
• The available area of the rendering surface of the output device, in CSS pixels.
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
</ul>

		</section>
		<section id="_trans-conventions_">

<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, コレ, ~WHILE 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
加えて、記述を簡潔にするため，次の（非公式な）用語も定義する：
</p>

<ul>
	<li>
`Document$I ~interfaceを実装する~objは、単に
`文書@
と略記される。
</li>
	<li>
`表示域$の
`有効~横幅@ ／
`有効~縦幅@
とは、`表示域$に~scroll~barが描画されているときは その部分の区画は除外した，`表示域$の横幅／縦幅を表す（~scroll~barが無ければ，通常の横幅／縦幅と同じになる）。
</li>
</ul>

<p>
加えて、次の記法を用いる：
</p>

<ul>
	<li>
<p>
記法 “［ %W ｜ %H ］” （ "｜" は全角の縦棒）は、縦横それぞれの方向についての，並立的な記述を表す。
</p>

<p>
例えば：
<span class="block">
“［ x 属性 ｜ y 属性 ］ は表示域の［ 左端の x 座標 ｜ 上端の y 座標 ］ を返す”
</span>
と記されていれば、それは 2 つの記述：

<span class="block">
“x 属性 は表示域の左端の x 座標を返す”,<br>
“y 属性 は表示域の上端の y 座標を返す”
</span>

が，並立的に重ねられていることを表す。
この対応関係は，同じ~algoの中の別々の段の間でも維持される。
</p>

<small>（このような表記を導入する理由は、記述の簡約以外にも，［
縦横両方向に関する記述であって, その両方向について対称性がある
］ことを明らかにすることもある。）</small>
</li>
</ul>

		</section>
	</section>
	<section id="common-infrastructure">

<h2 title="Common Infrastructure">3. 共通基盤</h2>

<p>
この仕様は WHATWG Infra 標準に依存する。
`INFRA$r
◎
This specification depends on the WHATWG Infra standard. [INFRA]
</p>

		<section id="scrolling">
<h3 title="Scrolling">3.1. ~scroll法</h3>

<div class="algorithm">
<p>
`~scrollを遂行する@
ときは、所与の
( %~box （`~scrollされる~box$）, %目的位置, %~assoc要素, %挙動 （省略時は `auto$l ） )
に対し，次を走らす：
◎
When a user agent is to perform a scroll of a scrolling box box, to a given position position, an associated element element and optionally a scroll behavior behavior (which is "auto" if omitted), the following steps must be run:
</p>

<ol>
	<li>
~IF［
%~box において`滑らかな~scroll$は進行中である
］
⇒
それを`中止-$する
◎
Abort any ongoing smooth scroll for box.
</li>
	<li>
<p>
~IF［
~UAは， `scroll-behavior$p ~propを尊守する
］~AND［
次のいずれかが満たされる
］…：
◎
If the user agent honors the scroll-behavior property and one of the following are true:
</p>
		<ul>
			<li>
［
%挙動 ~EQ `auto$l
］~AND［
%~assoc要素 ~NEQ ~NULL
］~AND［
%~assoc要素 の `scroll-behavior$p ~propの算出d値 ~EQ `smooth$v
］
◎
behavior is "auto" and element is not null and its computed value of the scroll-behavior property is smooth
</li>
			<li>
%挙動 ~EQ `smooth$l
◎
behavior is smooth
</li>
		</ul>

<p class="trans-note">【
尊守（ `honor^en ） —
~supportしていて, かつ
その機能が（環境設定 等により）可能化されてもいる，といった含みも込められた語と見受けられる。
】</p>

<p>
…ならば
⇒
%~box を %目的位置 に`滑らかに~scrollする$
◎
...then perform a smooth scroll of box to position. Otherwise, perform an instant scroll of box to position.
</p>
	</li>
	<li>
~ELSE
⇒
%~box を %目的位置 に`瞬時に~scrollする$
◎
↑</li>
</ol>
</div>

<div class="algorithm">
<p>
`~scrollされる~box$ %~box を %目的位置 に
`滑らかに~scrollする@
ときは：
</p>

<ul>
	<li>
~UAが定義する~~速度, ~~動きにより， %~box の~scroll位置を【非同期的に】更新するモノトスル。
</li>
	<li>
~scrollの
`完了-@
時には、
%~box の~scroll位置は %目的位置 になるモノトスル。
</li>
	<li>
この~scrollは、~algoまたは利用者により
`中止-@
され得る。
</li>
</ul>
◎
When a user agent is to perform a smooth scroll of a scrolling box box to position, it must update the scroll position of box in a user-agent-defined fashion over a user-agent-defined amount of time. When the scroll is completed, the scroll position of box must be position. The scroll can also be aborted, either by an algorithm or by the user.
</div>

<div class="algorithm">
<p>
`~scrollされる~box$ %~box を %目的位置 に
`瞬時に~scrollする@
ときは、
%~box の~scroll位置を %目的位置 に更新するモノトスル。
◎
When a user agent is to perform an instant scroll of a scrolling box box to position, it must update the scroll position of box to position.
</p>
</div>

<div class="algorithm">
<p>
`文書の開始位置に~scrollする@
ときは、所与の
( 文書 %文書 )
に対し，次を走らす：
◎
To scroll to the beginning of the document for a document document, follow these steps:
</p>

<ol>
	<li>
%表示域 ~LET
%文書 に結付けられている`表示域$
◎
Let viewport be the viewport that is associated with document.
</li>
	<li>
%目的位置 ~LET
%表示域 の`開始辺$が`~scrollされる区画$の`開始辺$に整列されたときに %表示域 がとる，~scroll位置
◎
Let position be the the scroll position viewport would have by aligning the beginning edges of the scrolling area with the beginning edges of viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の~scroll位置
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as viewport’s current scroll position, and viewport does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`~scrollを遂行する$( %表示域, %目的位置, %文書 の`根~要素$ )
◎
Perform a scroll of viewport to position, and document’s root element as the associated element, if there is one, or null otherwise. 
</li>
</ol>

<p class="note">注記：
この~algoは、
`HTML$r に定義される
`#top^c <a href="~NAVI#scroll-to-fragid">素片識別子へ~navigateする</a>ときに利用される。
【すなわち，文書~内の<a href="~NAVI#the-indicated-part-of-the-document">指示された部位</a>は、文書の上端になる。】
◎
Note: This algorithm is used when navigating to the #top fragment identifier, as defined in HTML. [HTML]
</p>
</div>

		</section>
		<section id="webidl-values">

<h3 title="WebIDL values">3.2. WebIDL 値</h3>

<div class="algorithm">
<p>
所与の値 %x を
`有限~値に正規化-@
するときは、［
%x は［
特別な浮動小数点~literal値（ `Infinity^I ／ `-Infinity^c ／ `NaN^I ） `WEBIDL$r
］であるならば 0 ／
~ELSE_ %x
］を返す。
◎
When asked to normalize non-finite values for a value x, if x is one of the three special floating point literal values (Infinity, -Infinity or NaN), then x must be changed to the value 0. [WEBIDL]
</p>
</div>

<div class="algorithm">
<p>
`座標から~scroll~optionsを作成する@
ときは、所与の
( %x, %y )
に対し，次のように設定された `ScrollToOptions$I 辞書~値を返す
【！~WEBIDLjs#es-dictionary】
⇒＃
`behavior$mb ~SET `auto$l （既定~値）,
`left$mb ~SET %x を`有限~値に正規化-$した結果,
`top$mb ~SET %y を`有限~値に正規化-$した結果
</p>

<p class="trans-note">【
この~algoは、他所の記述を集約するため，この訳に導入している。
】</p>

</div>

		</section>
	</section>
	<section id="extensions-to-the-window-interface">

<h2 title="Extensions to the Window Interface">4. `Window^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollBehavior@I { `auto@l, `smooth@l };

dictionary `ScrollOptions@I {
  `ScrollBehavior$I `behavior@mb = `auto$l;
};

dictionary `ScrollToOptions@I : `ScrollOptions$I {
  unrestricted double `left@mb;
  unrestricted double `top@mb;
};
</pre>

<pre class="idl">
partial interface `Window!I {
  [`NewObject$] `MediaQueryList$I `matchMedia$m(`CSSOMString$ %query);
  [`SameObject$, `Replaceable$] readonly attribute `Screen$I `screen$m;

  // <span class="comment">閲覧文脈</span>
  void `moveTo$m(long %x, long %y);
  void `moveBy$m(long %x, long %y);
  void `resizeTo$m(long %width, long %height);
  void `resizeBy$m(long %x, long %y);

  // <span class="comment">表示域</span>
  [`Replaceable$] readonly attribute long `innerWidth$m;
  [`Replaceable$] readonly attribute long `innerHeight$m;

  // <span class="comment">表示域の~scroll法</span>
  [`Replaceable$] readonly attribute double `scrollX$m;
  [`Replaceable$] readonly attribute double `pageXOffset$m;
  [`Replaceable$] readonly attribute double `scrollY$m;
  [`Replaceable$] readonly attribute double `pageYOffset$m;
  void `scroll$m(optional `ScrollToOptions$I %options = {});
  void `scroll$m(unrestricted double %x, unrestricted double %y);
  void `scrollTo$m(optional `ScrollToOptions$I %options = {});
  void `scrollTo$m(unrestricted double %x, unrestricted double %y);
  void `scrollBy$m(optional `ScrollToOptions$I %options = {});
  void `scrollBy$m(unrestricted double %x, unrestricted double %y);

  // <span class="comment">~client~UIwindow</span>
  [`Replaceable$] readonly attribute long `screenX$m;
  [`Replaceable$] readonly attribute long `screenLeft$m;
  [`Replaceable$] readonly attribute long `screenY$m;
  [`Replaceable$] readonly attribute long `screenTop$m;
  [`Replaceable$] readonly attribute long `outerWidth$m;
  [`Replaceable$] readonly attribute long `outerHeight$m;
  [`Replaceable$] readonly attribute double `devicePixelRatio$m;
};
</pre>

`Window^dgm

<dl class="idl-def">
	<dt>`matchMedia(query)@m</dt>
	<dd>
被呼出時には、次のように設定された，新たな `MediaQueryList$I ~objを返すモノトスル
⇒＃
`媒体~query~list$ ~SET `媒体~query~listとして構文解析する$( %query ),
`文書$mq ~SET コレに`結付けられている文書$
◎
When the matchMedia(query) method is invoked these steps must be run:
◎
Let parsed media query list be the result of parsing query.
◎
Return a new MediaQueryList object, with the context object’s associated Document as the document, with parsed media query list as its associated media query list.
</dd>

	<dt>`screen@m</dt>
	<dd>
取得子は、コレに結付けられている `Screen$I ~objを返すモノトスル。
◎
The screen attribute must return the Screen object associated with the Window object.
</dd>
	<dd class="note">注記：
`WindowProxy$I ~objを通した `screen^c への~accessでは、`文書$が~navigateされたときには，異なる結果が得られ得る。
◎
Note: Accessing screen through a WindowProxy object might yield different results when the Document is navigated.
</dd>

	<dt>`moveTo(x, y)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The moveTo(x, y) method must follow these steps:
</p>
		<ol>
			<li>
任意選択で
⇒
~RET
◎
Optionally, terminate these steps.
</li>
			<li>
%target ~LET コレの`閲覧文脈$
◎
Let target be the browsing context of the context object.
</li>
			<li>
~IF［［
`現任の設定群~obj$の`担当の閲覧文脈$
］に %target の `~resizeと移動-は許容され$ていない
］
⇒
~RET
◎
Let source be the responsible browsing context of the incumbent settings object.
◎
If source is not allowed to resize and move target, terminate these steps.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の外側に~UIwindowが出ない大きさ
］に切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
			<li>
%target の~UIwindowを，その左上隅が［
出力~機器の左上隅から相対的な［
%target の `px$css 単位による座標 (%x, %y) 
］］に整列するように移動する。
ここで，各~座標軸の正方向は［
右方, 下方
］とする。
◎
Move target’s window such that the window’s top left corner is at coordinates (x, y) relative to the top left corner of the output device, measured in CSS pixels of target. The positive axes are rightward and downward. 
</li>
		</ol>
	</dd>

	<dt>`moveBy(x, y)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The moveBy(x, y) method must follow these steps:
</p>
		<ol>
			<li>
任意選択で
⇒
~RET
◎
Optionally, terminate these steps.
</li>
			<li>
%target ~LET コレの`閲覧文脈$
◎
Let target be the browsing context of the context object.
</li>
			<li>
~IF［［
`現任の設定群~obj$の`担当の閲覧文脈$
］に %target の `~resizeと移動-は許容され$ていない
］
⇒
~RET
◎
Let source be the responsible browsing context of the incumbent settings object.
◎
If source is not allowed to resize and move target, terminate these steps.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の外側に~UIwindowが出ない大きさ
］に切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
			<li>
%target の~UIwindowを，
%target の `px$css 単位で［
右方に %x, 下方に %y
］だけ移動する
◎
Move target’s window x CSS pixels of target rightward and y CSS pixels of target downward.
</li>
		</ol>
	</dd>

	<dt>`resizeTo(width, height)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The resizeTo(width, height) method must follow these steps:
</p>
		<ol>
			<li>
任意選択で
⇒
~RET
◎
Optionally, terminate these steps.
</li>
			<li>
%target ~LET コレの`閲覧文脈$
◎
Let target be the browsing context of the context object.
</li>
			<li>
~IF［［
`現任の設定群~obj$の`担当の閲覧文脈$
］に %target の `~resizeと移動-は許容され$ていない
］
⇒
~RET
◎
Let source be the responsible browsing context of the incumbent settings object.
◎
If source is not allowed to resize and move target, terminate these steps.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%width, %height
を［
可用な空間の中で~UIwindowの大きさが~~適度な上限／下限に収まる
］ように切詰める
◎
Optionally, clamp width and height in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
			<li>
%target の~UIwindowを~resizeする
— ［
%width, %height は %target の `px$css 単位の値を表す
］とする下で，次を満たすように~UIwindowの右辺と下辺を移動する
⇒
［
表示域の左辺と右辺の距離 ~EQ %width
］~AND［
表示域の上辺と下辺の距離 ~EQ %height
］
◎
Resize target’s window by moving its right and bottom edges such that the distance between the left and right edges of the viewport are width CSS pixels of target and the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%target の~UIwindowを，可用な空間をはみ出さないように移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
		</ol>
	</dd>

	<dt>`resizeBy(x, y)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The resizeBy(x, y) method must follow these steps:
</p>
		<ol>
			<li>
任意選択で
⇒
~RET
◎
Optionally, terminate these steps.
</li>
			<li>
%target ~LET コレの`閲覧文脈$
◎
Let target be the browsing context of the context object.
</li>
			<li>
~IF［［
`現任の設定群~obj$の`担当の閲覧文脈$
］に %target の `~resizeと移動-は許容され$ていない
］
⇒
~RET
◎
Let source be the responsible browsing context of the incumbent settings object.
◎
If source is not allowed to resize and move target, terminate these steps.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の中で~UIwindowの大きさが~~適度な上限／下限に収まる
］ように切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
			<li>
%target の~UIwindowを，~resizeする
— その右辺と下辺を %target の `px$css 単位で［
左辺を %x,
上辺を %y
］だけ移動する
◎
Resize target’s window by moving its right edge x CSS pixels of target rightward and its bottom edge y CSS pixels of target downward.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%target の~UIwindowを，可用な空間をはみ出さないように移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
		</ol>
	</dd>
</dl>

<p>
次の条件~すべてが満たされるとき、
`閲覧文脈$ %A には，`閲覧文脈$ %B の
`~resizeと移動-は許容され@
る：
◎
A browsing context A is allowed to resize and move a browsing context B if all the following conditions are met:
</p>

<ul>
	<li>
%B は（利用者による行為ではなく）~scriptにより作成された`補助~閲覧文脈$である。
◎
B is an auxiliary browsing context that was created by a script (as opposed to by an action of the user).
</li>
	<li>
%A は %B に`近しい$。
◎
A is familiar with B.
</li>
</ul>

<dl class="idl-def">
	<dt>`innerWidth@m ｜ `innerHeight@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
</p>

<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`表示域$の［
横幅 ｜ 縦幅
］（~scroll~barが描画されている場合はその~sizeも含める）
</li>
</ol>
◎
The innerWidth attribute must return the viewport width including the size of a rendered scroll bar (if any), or zero if there is no viewport.
</dd>
	<dd class="example">
<p>
表示域の横幅は、次の~code片で得られる：
◎
The following snippet shows how to obtain the width of the viewport:
</p>

<pre class="lang-js">var viewportWidth = innerWidth</pre>
	</dd>

	<dd class="en">
◎
The innerHeight attribute must return the viewport height including the size of a rendered scroll bar (if any), or zero if there is no viewport.
</dd>

	<dt>`scrollX@m ｜ `scrollY@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
			<li>
~RET
`初期~包含塊$の原点に相対的な，`表示域$の［
左端の x 座標 ｜ 上端の y 座標
］
</li>
		</ol>
◎
The scrollX attribute attribute must return the x-coordinate, relative to the initial containing block origin, of the left of the viewport, or zero if there is no viewport.
</dd>

	<dt>`pageXOffset@m ｜ `pageYOffset@m</dt>
	<dd>
取得子は［
`scrollX$m ｜ `scrollY$m
］属性と同じ値を返すモノトスル。
◎
The pageXOffset attribute must return the value returned by the scrollX attribute.
</dd>
	<dd class="en">
◎
The scrollY attribute attribute must return the y-coordinate, relative to the initial containing block origin, of the top of the viewport, or zero if there is no viewport.
◎
The pageYOffset attribute must return the value returned by the scrollY attribute.
</dd>

	<dt>`scroll(options)@m</dt>
	<dt>`scroll(x, y)^m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
When the scroll() method is invoked these steps must be run:
</p>
		<ol>
			<li>
<p>
~IF［
~methodは %options 引数（ `ScrollToOptions$I ）を伴って呼出された
］：
</p>
				<ol>
					<li>
%left ~LET %options[ "`left$mb" ]
</li>
					<li>
%options[ "`left$mb" ] ~SET ［
%left ~EQ ε ならば `表示域$の現在の x 軸 ~scroll位置 ／
~ELSE_ %left を`有限~値に正規化-$した結果
］
</li>
					<li>
%top ~LET %options[ "`top$mb" ]
</li>
					<li>
%options[ "`top$mb" ] ~SET ［
%top ~EQ ε ならば `表示域$の現在の y 軸 ~scroll位置 ／
~ELSE_ %top を`有限~値に正規化-$した結果
］
</li>
				</ol>
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Let x be the value of the left dictionary member of options, if present, or the viewport’s current scroll position on the x axis otherwise.
• Let y be the value of the top dictionary member of options, if present, or the viewport’s current scroll position on the y axis otherwise.
</li>
			<li>
~ELSE
⇒
%options ~LET `座標から~scroll~optionsを作成する$( %x, %y )
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
◎
Normalize non-finite values for x and y.
</li>
			<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET
◎
If there is no viewport, abort these steps.
</li>
			<li>
<p>
%座標 ~LET 次の下位手続きを走らせた結果：
</p>
				<ol>
					<li>
%~scrollされる区画 ~LET `表示域$の`~scrollされる区画$
</li>
					<li>
%符号 ~LET `表示域$の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
</li>
					<li>
%x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %x, ( %~scrollされる区画 の横幅 ~MINUS `表示域$の`有効~横幅$ )))
</li>
					<li>
%符号 ~LET `表示域$の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
</li>
					<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, ( %~scrollされる区画 の縦幅 ~MINUS `表示域$の`有効~縦幅$ )))
</li>
					<li>
~RET ( %x, %y )
</li>
				</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any.
◎
Let viewport height be the height of the viewport excluding the height of the scroll bar, if any.
◎
If the viewport has rightward overflow direction
• Let x be max(0, min(x, viewport scrolling area width - viewport width)).
◎
If the viewport has leftward overflow direction
• Let x be min(0, max(x, viewport width - viewport scrolling area width)).
◎
If the viewport has downward overflow direction
• Let y be max(0, min(y, viewport scrolling area height - viewport height)).
◎
If the viewport has upward overflow direction
• Let y be min(0, max(y, viewport height - viewport scrolling area height)).
</li>
			<li>
%目的位置 ~LET %~scrollされる区画 の座標 %座標 が`表示域$の左上隅に整列されるような，`表示域$の~scroll位置
◎
Let position be the scroll position the viewport would have by aligning the x-coordinate x of the viewport scrolling area with the left of the viewport and aligning the y-coordinate y of the viewport scrolling area with the top of the viewport.
</li>
			<li>
~IF［
%目的位置 ~EQ `表示域$の現在の~scroll位置
］~AND［
`表示域$において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as the viewport’s current scroll position, and the viewport does not have an ongoing smooth scroll, abort these steps.
</li>
			<li>
%~assoc要素 ~LET `表示域$に結付けられている`文書$の`根~要素$
◎
Let document be the viewport’s associated Document.
</li>
			<li>
`~scrollを遂行する$( `表示域$, %目的位置, %~assoc要素, %options[ "`behavior$mb" ] )
◎
Perform a scroll of the viewport to position, document’s root element as the associated element, if there is one, or null otherwise, and the scroll behavior being the value of the behavior dictionary member of options.
</li>
		</ol>
	</dd>

	<dt>`scrollTo()@m</dt>
	<dd>
被呼出時には、コレ上の `scroll()$m と同じに挙動するモノトスル。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</dd>

	<dt>`scrollBy(options)@m</dt>
	<dt>`scrollBy(x, y)^m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
		<ol>
			<li>
~IF［
~methodは %options 引数（ `ScrollToOptions$I ）を伴って呼出された
］
⇒
何もしない
◎
↓</li>
			<li>
~ELSE
⇒
%options ~LET `座標から~scroll~optionsを作成する$( %x, %y )
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
◎
Normalize non-finite values for the left and top dictionary members of options.
</li>
			<li>
~IF［
%options[ "`left$mb" ] ~NEQ ε
］
⇒
%options[ "`left$mb" ] ~INCBY コレの `scrollX$m
◎
Add the value of scrollX to the left dictionary member.
</li>
			<li>
~IF［
%options[ "`top$mb" ] ~NEQ ε
］
⇒
%options[ "`top$mb" ] ~INCBY コレの `scrollY$m
◎
Add the value of scrollY to the top dictionary member.
</li>
			<li>
コレ上の `scroll$m の手続き( %options )
◎
Act as if the scroll() method was invoked with options as the only argument.
</li>
		</ol>
	</dd>

	<dt>`screenX@m ｜ `screenY@m</dt>
	<dt>`screenLeft@m ｜ `screenTop@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
			<li>
~RET
出力~機器の`~Webに公開される~screen区画$の原点に相対的な,  `px$css 単位による，~client~UIwindow†の［
左端の x 座標 ｜ 上端の y 座標
］
</li>
		</ol>
◎
The screenX and screenLeft attributes must return the x-coordinate, relative to the origin of the Web-exposed screen area, of the left of the client window as number of CSS pixels, or zero if there is no such thing.
◎
The screenY and screenTop attributes must return the y-coordinate, relative to the origin of the screen of the Web-exposed screen area, of the top of the client window as number of CSS pixels, or zero if there is no such thing.
</dd>
	<dd class="trans-note">【
［
`screenLeft^m ｜ `screenTop^m
］は［
`screenX^m ｜ `screenY^m
］の別名。
】</dd>
	<dd class="trans-note">【†
“~client~UIwindow” がどの部分を指すのか，定義されていないが、現実の~browserのふるまいからは，外枠も含めた~UIwindow全体が占める区画を指すものと推定される。
】</dd>

	<dt>`outerWidth@m ｜ `outerHeight@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
			<li>
~RET ~client~UIwindowの［
横幅 ｜ 縦幅
］
</li>
		</ol>
◎
The outerWidth attribute must return the width of the client window. If there is no client window this attribute must return zero.
◎
The outerHeight attribute must return the height of the client window. If there is no client window this attribute must return zero.
</dd>

	<dt>`devicePixelRatio@m</dt>
	<dd>
<p>
取得子は、次に与える
`機器~pixel比を決定する@
~algoを走らすモノトスル：
◎
The devicePixelRatio attribute must return the result of the following determine the device pixel ratio algorithm:
</p>
		<ol>
			<li>
~IF［
出力~機器は無い
］
⇒
~RET 1
◎
If there is no output device, return 1 and abort these steps.
</li>
			<li>
%~CSS~pixel~size ~LET ［
現在の`~page~zoom$倍率
］, および［
`~pinch~zoom$倍率 1.0
］の下での，
1 `px$css の~size
◎
Let CSS pixel size be the size of a CSS pixel at the current page zoom scale factor and at a pinch zoom scale factor of 1.0.
</li>
			<li>
%機器~pixel~size ~LET
出力~機器の機器~pixelの縦~size
◎
Let device pixel size be the vertical size of a device pixel of the output device.
</li>
			<li>
~RET
%~CSS~pixel~size ~DIV %機器~pixel~size
◎
Return the result of dividing CSS pixel size by device pixel size.
</li>
		</ol>
	</dd>
</dl>

		<section id="the-features-argument-to-the-open()-method">
<h3 title="The features argument to the open() method">4.1. `open()^m ~methodに対する %features 引数</h3>

<p>
~HTMLは， `open()$m ~methodを定義している。
この節では、その %features 引数にて与えられる位置と~sizeの挙動を定義する。
`HTML$r
◎
HTML defines the open() method. This section defines behavior for position and size given in the features argument. [HTML]
</p>

<div class="algorithm">
<p>
`閲覧文脈の特能を設定しておく@
ときは、所与の
(
`閲覧文脈$ %target,
（ %features 引数から導出された）`~map$ %特能~map
)
に対し，次を走らす：
◎
To set up browsing context features for a browsing context target given a map tokenizedFeatures:
</p>

<ol>
	<li>
%~pixel単位 ~LET %target における `px$css 単位
◎
↓</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
%可用な~screen ~LET `~Webに公開される可用な~screen区画$
◎
↓</li>
	<li>
%~screen ~LET `~Webに公開される~screen区画$
◎
↓</li>
	<li>
%正規化-済み~map ~LET 新たな`~map$
◎
↓</li>
	<li>
<p>
~EACH( %名前 ~IN { `left$opf, `top$opf, `width$opf, `height$opf } )
に対し：
</p>
		<ol>
			<li>
%値 ~LET %特能~map[ %名前 ]
</li>
			<li>
~IF［
%値 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
%値 ~SET `整数として構文解析する$( %値 )
</li>
			<li>
~IF［
%値 ~EQ `失敗^i
］
⇒
%値 ~SET 0
</li>
			<li>
%正規化-済み~map[ %名前 ] ~SET %値
</li>
		</ol>
◎
↓</li>
	<li>
( %左端, %上端, %横幅, %縦幅 )
~LET 順に
⇒＃
%正規化-済み~map[ `left$opf ],
%正規化-済み~map[ `top$opf ],
%正規化-済み~map[ `width$opf ],
%正規化-済み~map[ `height$opf ]
◎
Let x be null.
◎
Let y be null.
◎
Let width be null.
◎
Let height be null.
</li>
	<li>
<p>
~IF［
%左端 ~NEQ ε
］：
◎
If tokenizedFeatures["left"] exists:
• Set x to the result of invoking the rules for parsing integers on tokenizedFeatures["left"].
• If x is an error, set x to 0.
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%左端 を［
%可用な~screen の外側に %~UIwindow が出ない大きさ
］に切詰める
◎
Optionally, clamp x in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による %~screen の左辺に相対的な  %~UIwindow の左辺の横方向 座標 ~EQ %左端
］になるよう，
%~UIwindow を移動する
◎
Optionally, move target’s window such that the window’s left edge is at the horizontal coordinate x relative to the left edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is rightward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%上端 ~NEQ ε
］：
◎
If tokenizedFeatures["top"] exists:
• Set y to the result of invoking the rules for parsing integers on tokenizedFeatures["top"].
• If y is an error, set y to 0.
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%上端 を［
%可用な~screen の外側に %~UIwindow が出ない大きさ
］に切詰める
◎
Optionally, clamp y in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による %~screen の上辺に相対的な %~UIwindow の上辺の縦方向 座標 ~EQ %上端
］になるよう，
%~UIwindow を移動する
◎
Optionally, move target’s window such that the window’s top edge is at the vertical coordinate y relative to the top edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is downward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%横幅 ~NIN { ε, 0 }
］：
◎
If tokenizedFeatures["width"] exists:
• Set width to the result of invoking the rules for parsing integers on tokenizedFeatures["width"].
• If width is an error, set width to 0.
• If width is not 0:
</p>
		<ol>
			<li>

任意選択で，~UA定義な方式で
⇒
%横幅 を，
%可用な~screen の中で %~UIwindow の大きさが~~適度な上限／下限に収まるように切詰める
◎
Optionally, clamp width in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による表示域の左辺と右辺の距離 ~EQ %横幅
］になるよう，
%~UIwindow の右辺を移動して， %~UIwindow の~sizeを変える
◎
Optionally, size target’s window by moving its right edge such that the distance between the left and right edges of the viewport are width CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%~UIwindow を，
%可用な~screen をはみ出さないように移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%縦幅 ~NIN { ε, 0 }
］：
◎
If tokenizedFeatures["height"] exists:
• Set height to the result of invoking the rules for parsing integers on tokenizedFeatures["height"].
• If height is an error, set height to 0.
• If height is not 0:
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%縦幅 を，
%可用な~screen の中で %~UIwindow の大きさが~~適度な上限／下限に収まるように切詰める
◎
Optionally, clamp height in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による表示域の上辺と下辺の距離 ~EQ %縦幅
］になるよう，
%~UIwindow の下辺を移動して， %~UIwindow の~sizeを変える
◎
Optionally, size target’s window by moving its bottom edge such that the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%~UIwindow を，
%可用な~screen をはみ出さないように移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
次に挙げるものが
`~supportされる~open_m特能~名@
である：
◎
A supported open() feature name is one of the following:
</p>

<dl>
	<dt>`width@opf</dt>
	<dd>
表示域の横幅
◎
The width of the viewport.
</dd>

	<dt>`height@opf</dt>
	<dd>
表示域の縦幅
◎
The height of the viewport.
</dd>

	<dt>`left@opf</dt>
	<dd>
~UIwindowの左端の位置
◎
The left position of the window.
</dd>

	<dt>`top@opf</dt>
	<dd>
~UIwindowの上端の位置
◎
The top position of the window.
</dd>

</dl>

		</section>
		<section id="the-mediaquerylist-interface">
<h3 title="The MediaQueryList Interface">4.2. `MediaQueryList^I ~interface</h3>

<p>
この節は、 `HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
`MediaQueryList$I ~objには、次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`媒体~query~list@</dt>
	<dt>`文書@mq</dt>
	<dd>
作成-時に設定される。
◎
A MediaQueryList object has an associated media query list and an associated document set on creation.
</dd>

	<dt>`媒体@mq</dt>
	<dd>
<a href="~CSSOM1#serialize-a-media-query-list">直列化-</a>された形による，`媒体~query~list$。
◎
A MediaQueryList object has an associated media which is the serialized form of the associated media query list.
</dd>

	<dt>`合致状態@mq</dt>
	<dd>
結付けられている`媒体~query~list$が［
`文書$mqの状態に合致するときは ~T ／
~ELSE_ ~F
］を返す。
◎
A MediaQueryList object has an associated matches state which is true if the associated media query list matches the state of the document, and false otherwise.
</dd>

</dl>

<div class="algorithm">
<p>
`文書~用の媒体~queryを評価して変化を報告する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to evaluate media queries and report changes for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
%文書 を`文書$mqに持つような，
~EACH( `MediaQueryList$I ~obj %target )
に対し，先に作成されたものから順に：
◎
For each MediaQueryList object target that has doc as its document, in the order they were created, oldest first, run these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
%target の`合致状態$mqは、この手続きを前回~走らせたときから変化した
］
⇒
%target に向けて，`~eventを発火する$
— `MediaQueryList!I 構築子を利用し，次のように初期化して
⇒＃
`type$m 属性 ~SET `change$et,
`isTrusted$m 属性 ~SET ~T,
`media$m 属性 ~SET %target の`媒体$mq,
`matches$m 属性 ~SET %target の`合致状態$mq
【！fingerprint】
◎
If target’s matches state has changed since the last time these steps were run, fire an event at target using the MediaQueryListEvent constructor, with its type attribute initialized to change, its isTrusted attribute initialized to true, its media attribute initialized to target’s media, and its matches attribute initialized to target’s matches state.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="example">
<p>
`表示域$の方位（ `orientation^en ）の変化を検出する単純な~code片は、次のように書かれるであろう：
◎
A simple piece of code that detects changes in the orientation of the viewport can be written as follows:
</p>

<pre class="lang-js">
function handleOrientationChange(%event) {
  if(%event.`matches$m) // landscape
    …
  else
    …
}
var %mql = <a href="#dom-window-matchmedia">`matchMedia^m</a>(`(orientation:landscape)^l);
%mql.`onchange$m = handleOrientationChange;
</pre>

</div>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryList@I : `EventTarget$I {
  readonly attribute `CSSOMString$ `media$m;
  readonly attribute boolean `matches$m;
  void `addListener$m(`EventListener$I? %callback);
  void `removeListener$m(`EventListener$I? %callback);
           attribute `EventHandler$I `onchange$m;
};
</pre>

<dl class="idl-def">
	<dt>`media@m</dt>
	<dd>
<p>
取得子は、コレに結付けられている`媒体$mqを返すモノトスル。
◎
The media attribute must return the associated media.
</dd>

	<dt>`matches@m</dt>
	<dd>
取得子は、コレに結付けられている`合致状態$mqを返すモノトスル。
【！fingerprint】
◎
The matches attribute must return the associated matches state.
</dd>

	<dt>`addListener(callback)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The addListener(callback) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`~event~listenerを追加する$( コレ, 次のようにされた`~event~listener$ )
⇒＃
`type$evL ~SET `change$et,
`callback$evL ~SET %callback
◎
Add an event listener with the context object and an event listener whose type is change, and callback is callback.
</li>
		</ol>
	</dd>

	<dt>`removeListener(callback)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The removeListener(callback) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
コレの`~event~listener~list$内に［
( `type$evL, `callback$evL, `capture$evL )
~EQ ( `change$et, %callback, ~F )
］を満たす`~event~listener$がある
］
⇒
`~event~listenerを除去する$( コレ, その~event~listener )
◎
If the context object’s event listener list contains an event listener whose type is change, callback is callback, and capture is false, then remove an event listener with the context object and that event listener.
</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
この仕様は、当初，［
`addListener()$m ／ `removeListener()$m
］による~custom~callbackの仕組みを利用していた
— その~callbackは、結付けられている`媒体~query~list$を引数に呼出されていた。
今や、通常の~eventの仕組みが代わりに利用される。
後方-互換性を得るため、［
`addListener()$m ／ `removeListener()$m
］~methodは基本的に［
`addEventListener()$m ／ `removeEventListener()$m
］の別名になり，
`change$et ~eventが `MediaQueryList$I のふりをする。
◎
Note: This specification initially had a custom callback mechanism with addListener() and removeListener(), and the callback was invoked with the associated media query list as argument. Now the normal event mechanism is used instead. For backwards compatibility, the addListener() and removeListener() methods are basically aliases for addEventListener() and removeEventListener(), respectively, and the change event masquerades as a MediaQueryList.
</p>

<p>
`MediaQueryList$I ~interfaceを実装する~objは、
`onchange@m
`~event~handler$（および，対応する`~event~handler~event型$ `change$et ）を，`~event~handler~IDL属性$として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MediaQueryList interface:
◎
Event handler｜Event handler event type
onchange｜change
</p>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryListEvent@I : `Event$I {
  `MediaQueryListEvent@mc(`CSSOMString$ %type, optional `MediaQueryListEventInit$I %eventInitDict = {});

  readonly attribute `CSSOMString$ `media$m;
  readonly attribute boolean `matches$m;
};

dictionary `MediaQueryListEventInit@I : `EventInit$I {
  `CSSOMString$ `media@mb = "";
  boolean `matches@mb = false;
};
</pre>

<!-- `MediaQueryListEvent@I -->

<dl class="idl-def">
	<dt>`media@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The media attribute must return the value it was initialized to.
</dd>

	<dt>`matches@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The matches attribute must return the value it was initialized to.
</dd>
</dl>

			<section id="mediaquerylist-event-summary">

<h4 title="Event summary">4.2.1. ~event要覧</h4>

~INFORMATIVE

<table><thead><tr><th>~event
<th>~interface
<th>~target
<th>~~説明
</thead>

<tbody><tr><td>`change@et
<td>`Event$I
<td>`MediaQueryList$I
<td>
`合致状態$mqが変化したときに `MediaQueryList$I に向けて発火される。
◎
Fired at the MediaQueryList when the matches state changes.
</tbody></table>

			</section>
		</section>
		<section id="the-screen-interface">

<h3 title="The Screen Interface">4.3. `Screen^I ~interface</h3>

<p>
その名前が示唆するように， `Screen$I ~interfaceは、出力~機器の~screenについての情報を表現する。
◎
As its name suggests, the Screen interface represents information about the screen of the output device.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Screen@I {
  readonly attribute long `availWidth$m;
  readonly attribute long `availHeight$m;
  readonly attribute long `width$m;
  readonly attribute long `height$m;
  readonly attribute unsigned long `colorDepth$m;
  readonly attribute unsigned long `pixelDepth$m;
};
</pre>

`Screen^dgm

<dl class="idl-def">
	<dt>`availWidth@m ｜ `availHeight@m</dt>
	<dd>
取得子は、`~Webに公開される可用な~screen区画$の［
横幅 ｜ 縦幅
］を返すモノトスル。
◎
The availWidth attribute must return the width of the Web-exposed available screen area.
◎
The availHeight attribute must return the height of the Web-exposed available screen area.
</dd>

	<dt>`width@m ｜ `height@m</dt>
	<dd>
取得子は、`~Webに公開される~screen区画$の［
横幅 ｜ 縦幅
］を返すモノトスル。
◎
The width attribute must return the width of the Web-exposed screen area.
◎
The height attribute must return the height of the Web-exposed screen area.
</dd>

	<dt>`colorDepth@m</dt>
	<dt>`pixelDepth@m</dt>
	<dd>
これらの属性の取得子は、出力~機器における~pixelの色に割振られている~bit数を
— その~alpha~channelは除外して —
返すべきである。
~UAがこの~bit数を知り得ない場合は、自身による最も近い見積もりを返すべきである
— 例えば、出力~機器が利用する値に最も近くなるような，［
機器に送り込まれる~frame~buffer, または何らかの内部~表現
］に利用されている~bit数など。
これらの属性は、 `color$d 媒体~特能の値の 3 倍~以上の値を返すモノトスル
— ~bit数が色~成分ごとに異なる場合、返す値は 3 倍を超えてもヨイ。
~UAは、色~深度を［
知り得ない, または~privacyに配慮するため返したくない
］場合は， 24 を返すべきである。
◎
The colorDepth and pixelDepth attributes should return the number of bits allocated to colors for a pixel in the output device, excluding the alpha channel. If the user agent is not able to return the number of bits used by the output device, it should return the closest estimation such as, for example, the number of bits used by the frame buffer sent to the display or any internal representation that would be the closest to the value the output device would use. The user agent must return a value for these attributes at least equal to the value of color media query multiplied by three. If the different color components are not represented with the same number of bits, the returned value may be greater than three times color media query. If the user agent does not know the color depth or does not want to return it for privacy considerations, it should return 24.
</dd>
	<dd class="note">注記：
互換性の理由から，両~属性とも同じ値を返す。
◎
Note: The colorDepth and pixelDepth attributes return the same value for compatibility reasons.
</dd>
	<dd class="note">注記：
一部の不適合な実装は、 24 でなく 32 を返すことが知られている。
◎
Note: Some non-conforming implementations are known to return 32 instead of 24.
</dd>
	<dd class="example">
<p>
`colorDepth^m は、他の情報
— 例えば色域 —
と組合せて SDR/HDR 【 `Standard/High Dynamic Range^en 】
を選択する文脈にて利用できる。
◎
colorDepth can be used in the context of selecting SDR/HDR in addition with other information. For example, combined with color gamut.
</p>

<pre class="lang-js">
if (screen.colorDepth &gt;= 48
   &amp;&amp; window.matchMedia('(color-gamut: p3)').matches
   &amp;&amp; /* 他の検査 */) {
  // HDR 内容を利用する
} else {
  // SDR 内容を利用する
}
</pre>

	</dd>
</dl>

		</section>
	</section>
	<section id="extensions-to-the-document-interface">

<h2 title="Extensions to the Document Interface">5. `Document^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Document!I {
  `Element$I? `elementFromPoint$m(double %x, double %y);
  sequence&lt;`Element$I&gt; `elementsFromPoint$m(double %x, double %y);
  `CaretPosition$I? `caretPositionFromPoint$m(double %x, double %y);
  readonly attribute `Element$I? `scrollingElement$m;
};
</pre>

`Document^dgm

<dl class="idl-def">
	<dt>`elementFromPoint(x, y)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The elementFromPoint(x, y) method must follow these steps:
</p>
		<ol>
			<li>
~IF［
コレに結付けられている`表示域$はない
］
⇒
~RET ~NULL
◎
↓</li>
			<li>
~IF［［［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］, かつ［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］］でない
］
⇒
~RET ~NULL
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return null and terminate these steps.
</li>
			<li>
~IF［
`表示域$の子孫に対する`変形$を適用した下で，座標 (%x, %y) の接触判定の標的になる`~layout~box$は`表示域$内にある
］
⇒
~RET それに結付けられている要素
◎
If there is a layout box in the viewport that would be a target for hit testing at coordinates x,y, when applying the transforms that apply to the descendants of the viewport, return the associated element and terminate these steps.
</li>
			<li>
~RET コレの`根~要素$
◎
If the document has a root element, return the root element and terminate these steps.
◎
Return null.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`elementFromPoint()^m ~methodは、最も手前に塗られている要素を返すとは限らない。
例えば要素は `pointer-events$p ~CSS~propの利用を通して接触判定の標的から除外され得る。
◎
Note: The elementFromPoint() method does not necessarily return the top-most painted element. For instance, an element can be excluded from being a target for hit testing by using the pointer-events CSS property.
</dd>

	<dt>`elementsFromPoint(x, y)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The elementsFromPoint(x, y) method must follow these steps:
</p>
		<ol>
			<li>
%~list ~LET 新たな~list
◎
Let sequence be a new empty sequence.
</li>
			<li>
<p>
~IF［
コレに結付けられている`表示域$はある
］~AND［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］：
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return sequence and terminate these steps.
</p>
				<ol>
					<li>
%~list に次を満たす すべての要素を付加する
— `topmost^en ~box【最も手前に塗られるもの】から順に，要素の`~layout~box$の塗り順序で
⇒
要素の`~layout~box$は、`表示域$の子孫に対する`変形$を適用した下で，`表示域$内にあって座標 (%x, %y) における接触判定の標的になる（そこに何も `overlap^en していないとしても【要素には塗られる内容がないとしても？】）
◎
For each layout box in the viewport, in paint order, starting with the topmost box, that would be a target for hit testing at coordinates x,y even if nothing would be overlapping it, when applying the transforms that apply to the descendants of the viewport, append the associated element to sequence.
</li>
					<li>
~IF［
%~list は空でない
］~AND［
コレの`根~要素$ %根 ~NIN { ~NULL, %~list の最後の~item }
］
⇒
%~list に %根 を付加する
◎
If the document has a root element, and the last item in sequence is not the root element, append the root element to sequence.
</li>
				</ol>
			</li>
			<li>
~RET %~list を表現する連列~型~obj
◎
Return sequence.
</li>
		</ol>
	</dd>

	<dt>`caretPositionFromPoint(x, y)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The caretPositionFromPoint(x, y) method must return the result of running these steps:
</p>
		<ol>
			<li>
~IF［
コレに結付けられている`表示域$はない
］
⇒
~RET ~NULL
◎
If there is no viewport associated with the document, return null.
</li>
			<li>
~IF［［［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］］でない
］
⇒
~RET ~NULL
<!-- 
引数が指す座標が`表示域$の外を指す場合、 null を返す（“表示域の外” の定義は上の <code>elementFromPoint</code> の記述と同じ）。
 -->
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), y is greater than the viewport height excluding the size of a rendered scroll bar (if any) return null.
</li>
			<li>
~IF［［
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内の座標
( %x, %y )
の所に~text挿入位置指示が挿入されることになる
］ではない
］
⇒
~RET ~NULL
◎
If at the coordinates x,y in the viewport no text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, return null.
</li>
			<li>
~IF［
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内の座標
( %x, %y )
の所に, かつ［
`置換d要素$による~text手入力~widget
］内に，~text挿入位置指示が挿入されることになる
］
⇒
~RET 次のように設定された`~caret位置$
⇒＃
`~caret範囲$ ~SET ~NULL,
`~caret~node$ ~SET ~text手入力~widgetに対応する~node,
`~caret~offset$ ~SET 左端から~text挿入位置指示が挿入される地点までにある`符号単位$の個数
◎
If at the coordinates x,y in the viewport a text insertion point indicator would have been inserted in a text entry widget which is also a replaced element, when applying the transforms that apply to the descendants of the viewport, return a caret position with its properties set as follows:
• The node corresponding to the text entry widget.
• The amount of 16-bit units to the left of where the text insertion point indicator would have inserted.
• null
</li>
			<li>
%~caret範囲 ~LET `表示域$の子孫に対する`変形$を適用した下で，~text挿入位置指示が挿入されることになる地点を指すような、`畳まれて$いる `Range$I ~obj
◎
Otherwise, return a caret position where the caret range is a collapsed Range object for the position where the text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, and＼
</li>
			<li>
~RET 次のように設定された`~caret位置$
⇒＃
`~caret範囲$ ~SET %~caret範囲,
`~caret~node$ ~SET %~caret範囲 の `startContainer$m,
`~caret~offset$ ~SET %~caret範囲 の `startOffset$m
◎
the other properties are set as follows:
• The startContainer of the caret range.
• The startOffset of the caret range.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
接触判定の詳細は、この仕様の視野~外であり，したがって
`elementFromPoint()$m
と
`caretPositionFromPoint()$m
についての正確な詳細も同様になる。
接触判定は希望的には，~CSSまたは~HTMLの将来版にて定義されることになる。
◎
Note: The specifics of hit testing are out of scope of this specification and therefore the exact details of elementFromPoint() and caretPositionFromPoint() are therefore too. Hit testing will hopefully be defined in a future revision of CSS or HTML.
</dd>

	<dt>`scrollingElement@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The scrollingElement attribute, on getting, must run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
コレは`過去互換~mode$下にある
］：
◎
If the Document is in quirks mode, follow these substeps:
</p>
				<ol>
					<li>
~IF［
`~HTML~body要素$ %~body は在る
］~AND［
%~body は`~scroll可能になり得ない$
］
⇒
~RET %~body
◎
If the HTML body element exists, and it is not potentially scrollable, return the HTML body element and abort these steps.
</li>
					<li>
~RET ~NULL
◎
Return null and abort these steps.
</li>
				</ol>
			</li>
			<li>
~RET コレの`根~要素$
◎
If there is a root element, return the root element and abort these steps.
◎
Return null.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`scrollTop^m,
`scrollLeft^m
に対し，`過去互換~mode$の挙動を常に利用する不適合~UAには、
`scrollingElement$m 属性は，常に`~HTML~body要素$（あるいは，なければ ~NULL ）を返すものと期待されている。
この~APIが存在するのは、~Web開発者が，~scroll用~APIに利用する~~正しい要素を取得できるようにするためである
— 特定0の~UAの挙動を前提にしたり，どの要素が表示域を~scrollするかを見るために~scrollを呼出す必要なく。
◎
Note: For non-conforming user agents that always use the quirks mode behavior for scrollTop and scrollLeft, the scrollingElement attribute is expected to also always return the HTML body element (or null if it does not exist). This API exists so that Web developers can use it to get the right element to use for scrolling APIs, without making assumptions about a particular user agent’s behavior or having to invoke a scroll to see which element scrolls the viewport.
</dd>
	<dd class="note">注記：
`~HTML~body要素$は、~HTMLの `document.body^m とは異なる
— 後者は `frameset^m 要素を返すこともある。
◎
Note: The HTML body element is different from HTML’s document.body in that the latter can return a frameset element.
</dd>
</dl>

		<section id="the-caretposition-interface">
<h3 title="The CaretPosition Interface">5.1. `CaretPosition^I ~interface</h3>

<p>
`~caret位置@
とは、~text挿入位置指示の位置を与えるものであり，常に［
`~caret~node@,
`~caret~offset@,
`~caret範囲@
］が結付けられる。
~caret位置は、 `CaretPosition$I ~objにより表現される。
◎
A caret position gives the position of a text insertion point indicator. It always has an associated caret node, caret offset, and caret range. It is represented by a CaretPosition object.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CaretPosition@I {
  readonly attribute `Node$I `offsetNode$m;
  readonly attribute unsigned long `offset$m;
  [`NewObject$] `DOMRect$I? `getClientRect$m();
};
</pre>

<dl class="idl-def">
	<dt>`offsetNode@m</dt>
	<dd>
取得子は、コレの`~caret~node$を返すモノトスル。
◎
The offsetNode attribute must return the caret node.
</dd>

	<dt>`offset@m</dt>
	<dd>
取得子は、コレの`~caret~offset$を返すモノトスル。
◎
The offset attribute must return the caret offset.
</dd>

	<dt>`getClientRect()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The getClientRect() method must follow these steps, aborting on the first step that returns a value:
</p>
		<ol>
			<li>
<p>
~IF［
コレの`~caret範囲$ ~NEQ ~NULL
］：
◎
If caret range is not null:
</p>
				<ol>
					  <li>
%~list ~LET
その範囲に対し
`getClientRects()^m
~methodを呼出した結果
◎
Let list be the result of invoking the getClientRects() method on the range.
</li>
					<li>
~IF［
%~list は空である
］
⇒
~RET ~NULL
◎
If list is empty, return null.
</li>
					<li>
~RET %~list 内の最初の `DOMRect$I ~obj
◎
Return the DOMRect object in list at index 0.
</li>
				</ol>
			</li>
			<li>
~IF［
コレの`~caret~node$ %node は，［
`置換d要素$による~text手入力~widgetである
］~AND［
文書~内に在る【！＊in the document】
］］
⇒
~RET 
%node とその先祖に対する`変形$を適用した下で、
%node 内の，`~caret~offset$ の値で表現される~caretに対する `DOMRect$I ~obj
◎
If caret node is a text entry widget that is a replaced element, and that is in the document, return a DOMRect object for the caret in the widget as represented by the caret offset value. The transforms that apply to the element and its ancestors are applied.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methodが返す `DOMRect$I ~objは、`~live$でない。
◎
Note: This DOMRect object is not live.
</dd>
</dl>

		</section>
	</section>
	<section id="extension-to-the-element-interface">

<h2 title="Extensions to the Element Interface">6.  `Element^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollLogicalPosition@I { `start@l, `center@l, `end@l, `nearest@l };
dictionary `ScrollIntoViewOptions@I : `ScrollOptions$I {
  `ScrollLogicalPosition$I `block@mb = `start$l;
  `ScrollLogicalPosition$I `inline@mb = `nearest$l;
};
</pre>

<pre class="idl">
partial interface `Element!I {
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();
  void `scrollIntoView$m(optional (boolean or `ScrollIntoViewOptions$I) %arg = {});
  void `scroll$m(optional `ScrollToOptions$I %options = {});
  void `scroll$m(unrestricted double %x, unrestricted double %y);
  void `scrollTo$m(optional `ScrollToOptions$I %options = {});
  void `scrollTo$m(unrestricted double %x, unrestricted double %y);
  void `scrollBy$m(optional `ScrollToOptions$I %options = {});
  void `scrollBy$m(unrestricted double %x, unrestricted double %y);
  attribute unrestricted double `scrollTop$m;
  attribute unrestricted double `scrollLeft$m;
  readonly attribute long `scrollWidth$m;
  readonly attribute long `scrollHeight$m;
  readonly attribute long `clientTop$m;
  readonly attribute long `clientLeft$m;
  readonly attribute long `clientWidth$m;
  readonly attribute long `clientHeight$m;
};
</pre>

`Element^dgm

<dl class="idl-def">
	<dt>`getClientRects()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The getClientRects() method, when invoked, must return the result of the following algorithm:
</p>
		<ol>
			<li>
~IF［
コレは`~layout~box$を持たない
］
⇒
~RET 空の `DOMRectList$I ~obj
◎
If the element on which it was invoked does not have an associated layout box return an empty DOMRectList object and stop this algorithm.
</li>
			<li>
~IF［
コレは`~SVG~layout~box$を持つ
］
⇒
~RET 次で与えられる矩形を表す 1 個の `DOMRect$I ~objからなる `DOMRectList$I ~obj
⇒
コレとその先祖に対する`変形$を適用した下で，~SVG仕様の定義に従うコレの限界~box
◎
If the element has an associated SVG layout box return a DOMRectList object containing a single DOMRect object that describes the bounding box of the element as defined by the SVG specification, applying the transforms that apply to the element and its ancestors.
</li>
			<li>
<p>
%~list ~LET
コレの`~layout~box$内の`~box断片$からなる~list
— ここで：
</p>

<ul><li>コレの `display$p ~propの算出d値
~IN { `table$v, `inline-table$v }
の場合、
table ~box と caption ~boxは ~listに含めるが，匿名~容器~boxは含めない。
</li><li>各 `匿名~塊~box$は，その子~boxたちに置換する。
匿名~塊~boxが尽きるまで，これを繰返す。
</li><li>縦幅／横幅 が 0 であっても~listから除外しない。
</li><li>~listは、内容~順による。
</li></ul>

◎
↓</li>
			<li>
<p>
~RET 
%~list 内の 各`~box断片$を，［［［
その~border区画に［
コレとその先祖に対する`変形$
］を適用して得られる図形
］を包含するような，最~小な矩形
］を表す `DOMRect$I ~obj
］に置換して得られる `DOMRectList$I ~obj
</p>

<p class="trans-note">【
原文には “最~小な矩形” という記述はないが、変形を孕んでいるので，必然的にそうなる。
】</p>
◎
Return a DOMRectList object containing DOMRect objects in content order, one for each box fragment, describing its border area (including those with a height or width of zero) with the following constraints:
• Apply the transforms that apply to the element and its ancestors.
• If the element on which the method was invoked has a computed value for the display property of table or inline-table include both the table box and the caption box, if any, but not the anonymous container box.
• Replace each anonymous block box with its child box(es) and repeat this until no anonymous block boxes are left in the final list.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methodが返す `DOMRect$I ~objは、`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</dd>

	<dt>`getBoundingClientRect()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The getBoundingClientRect() method, when invoked, must return the result of the following algorithm:
</p>
		<ol>
			<li>
%~list ~LET
コレ上で
`getClientRects()$m
を呼出した結果
◎
Let list be the result of invoking getClientRects() on the same element this method was invoked on.
</li>
			<li>
~IF［
%~list は空である
］
⇒
~RET 次のようにされた `DOMRect$I ~obj
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If the list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
			<li>
~IF［
%~list 内の どの矩形も，横幅, 縦幅ともに 0 である
］
⇒
~RET %~list 内の最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
			<li>
~RET ［
%~list 内の［
横幅, 縦幅ともに 0 でない
］すべての矩形を包含するような，最~小な矩形
］を表現する `DOMRect$I ~obj
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methodが返す `DOMRect$I ~objは、`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</dd>
	<dd class="example">
<p>
次の~code片は文書~内の最初の `div^e 要素の~sizeを取得する：
◎
The following snippet gets the dimensions of the first div element in a document:
</p>

<pre class="lang-js">
var example = document
    .getElementsByTagName("div")[0]
    .getBoundingClientRect();
var exampleWidth = example.width;
var exampleHeight = example.height;
</pre>
	</dd>

	<dt>`scrollIntoView(arg)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The scrollIntoView(arg) method must run these steps:
</p>
		<ol>
			<li>
%挙動 ~LET `auto^l
◎
Let behavior be "auto".
</li>
			<li>
%塊 ~LET `start^l
◎
Let block be "start".
</li>
			<li>
%行内 ~LET `nearest^l
◎
Let inline be "nearest".
</li>
			<li>
~IF［
%arg は `ScrollIntoViewOptions$I 辞書である
］
⇒＃
%挙動 ~SET %options[ "`behavior$mb" ],
%塊 ~SET %options[ "`block$mb" ]
%行内 ~SET  %options[ "`inline$mb" ]
◎
If arg is a ScrollIntoViewOptions dictionary, then:
• Set behavior to the behavior dictionary member of options.
• Set block to the block dictionary member of options.
• Set inline to the inline dictionary member of options.
</li>
			<li>
~ELIF［
%arg ~EQ ~F
］
⇒
%塊 ~SET `end^l
◎
Otherwise, if arg is false, then set block to "end".
</li>
			<li>
~IF［
コレは`~layout~box$を持たない
］
⇒
~RET
◎
If the element does not have any associated layout box, then return.
</li>
			<li>
コレを`~viewの中へ~scrollする$( %挙動, %塊, %行内 )
◎
Scroll the element into view with behavior, block, and inline.
</li>
			<li>
任意選択で
⇒
利用者に コレを注目してもらう何らかの動作があれば，それを遂行する
◎
Optionally perform some other action that brings the element to the user’s attention.
</li>
		</ol>
	</dd>

	<dt>`scroll(options)@m</dt>
	<dt>`scroll(x, y)^m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The scroll() method must run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
~methodは %options 引数（ `ScrollToOptions$I ）を伴って呼出された
］：
</p>
				<ol>
					<li>
%left ~LET %options[ "`left$mb" ]
</li>
					<li>
%options[ "`left$mb" ] ~SET ［
%left ~EQ ε ならば コレの現在の x 軸 ~scroll位置 ／
~ELSE_ %left を`有限~値に正規化-$した結果
］
</li>
					<li>
%top ~LET %options[ "`top$mb" ]
</li>
					<li>
%options[ "`top$mb" ] ~SET ［
%top ~EQ ε ならば コレの現在の y 軸 ~scroll位置 ／
~ELSE_ %top を`有限~値に正規化-$した結果
］
</li>
				</ol>
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
• Let x be the value of the left dictionary member of options, if present, or the element’s current scroll position on the x axis otherwise.
◎
• Let y be the value of the top dictionary member of options, if present, or the element’s current scroll position on the y axis otherwise.
</li>
			<li>
~ELSE
⇒
%options ~LET `座標から~scroll~optionsを作成する$( %x, %y )
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
			<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
			<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
			<li>
%window ~LET %文書 の `defaultView$m 属性~値
◎
Let window be the value of document’s defaultView attribute.
</li>
			<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
			<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
			<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］
⇒＃
%window 上で `scroll()^m を ( `scrollX^m, %y ) を引数に渡して呼出す；
~RET
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
</li>
			<li>
~IF［
コレは `~HTML~body要素$ である
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
⇒＃
%window 上で `scroll()^m を ( %options ) を引数に渡して呼出す；
~RET
◎
If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with options as the only argument, and terminate these steps.
</li>
			<li>
<p>
~IF［
コレは，次のいずれかを満たす
］…：
</p>

<ul><li>`~CSS~layout~box$を持たない
</li><li>`~scrollされる~box$は無い
</li><li>~overflowしていない
</li></ul>

<p>
…ならば
⇒
~RET
</p>
◎
If the element does not have any associated CSS layout box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
			<li>
`要素を~scrollする$( コレ,  ( %x, %y ), %options[ "`behavior$mb" ] )
◎
Scroll the element to x,y, with the scroll behavior being the value of the behavior dictionary member of options.
</li>
		</ol>
	</dd>

	<dt>`scrollTo()@m</dt>
	<dd>
被呼出時には、コレ上の `scroll()$m と同じに挙動するモノトスル。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</dd>

	<dt>`scrollBy(options)@m</dt>
	<dt>`scrollBy(x, y)^m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
		<ol>
			<li>
~IF［
~methodは %options 引数（ `ScrollToOptions$I ）を伴って呼出された
］
⇒
何もしない
【原文における この段の内容は，最後の `scroll()^m 手続きの中で処理されるので不要】
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
</li>
			<li>
~ELSE
⇒
%options ~LET `座標から~scroll~optionsを作成する$( %x, %y )
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
			<li>
~IF［
%options[ "`left$mb" ] ~NEQ ε
］
⇒
%options[ "`left$mb" ] ~INCBY コレの `scrollLeft$m
◎
Add the value of scrollLeft to the left dictionary member.
</li>
			<li>
~IF［
%options[ "`top$mb" ] ~NEQ ε
］
⇒
%options[ "`top$mb" ] ~INCBY コレの `scrollTop$m
◎
Add the value of scrollTop to the top dictionary member.
</li>
			<li>
コレ上の `scroll$m の手続き( %options )
◎
Act as if the scroll() method was invoked with options as the only argument.
</li>
		</ol>
	</dd>

	<dt>`scrollTop@m ｜ `scrollLeft@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The scrollTop attribute, on getting, must return the result of running these steps:
</p>
		<ol>
			<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
			<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
			<li>
%window ~LET %文書 の `defaultView$m 属性~値
◎
Let window be the value of document’s defaultView attribute.
</li>
			<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET 0
◎
If window is null, return zero and terminate these steps.
</li>
			<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET 0
◎
If the element is the root element and document is in quirks mode, return zero and terminate these steps.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

				<ul>
					<li>
コレ ~EQ %文書 の`根~要素$
</li>
					<li>
［
コレは `~HTML~body要素$である
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
				</ul>
<p>
…ならば
⇒
~RET %window 上の［
`scrollY^m ｜ `scrollX^m
］の値
</p>

◎
If the element is the root element return the value of scrollY on window.
◎
If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollY on window.
</li>
			<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated CSS layout box, return zero and terminate these steps.
</li>
			<li>
~RET
コレの`~scrollされる区画$の整列~点から相対的な，
コレの`~padding辺$の［
上端の y 座標 ｜ 左端の x 座標
］
◎
Return the y-coordinate of the scrolling area at the alignment point with the top of the padding edge of the element.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らすモノトスル：
◎
When setting the scrollTop attribute these steps must be run:
</p>
		<ol>
			<li>
%v ~LET 所与の値を`有限~値に正規化-$した結果
◎
Let y be the given value.
◎
Normalize non-finite values for y.
</li>
			<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
			<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
			<li>
%window ~LET %文書 の `defaultView$m 属性~値
◎
Let window be the value of document’s defaultView attribute.
</li>
			<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
			<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
				<ul>
					<li>
コレ ~EQ %文書 の`根~要素$
</li>
					<li>
［
コレは `~HTML~body要素$ である
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
				</ul>
<p>
…ならば：
</p>
				<ol>
					<li>
%window 上の `scroll()^m を次を引数に渡して呼出す
⇒
( ［ %window 上の `scrollX^m の値｜ %v ］, ［ %v ｜ %window 上の `scrollY^m の値 ］ )
</li>
					<li>
~RET
</li>
				</ol>
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
◎
If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with scrollX as first argument and y as second argument, and terminate these steps.
</li>
			<li>
<p>
~IF［
コレは，次のいずれかを満たす
］…：
</p>

<ul ><li>`~CSS~layout~box$を持たない
</li><li>`~scrollされる~box$は無い
</li><li>~overflowしていない
</li></ul>

<p>
…ならば
⇒
~RET
</p>

◎
If the element does not have any associated CSS layout box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
			<li>
%目的位置 ~LET ( ［
`scrollLeft$m の値 ｜ %v
］, ［
%v ｜ `scrollTop$m の値
］ )
◎
↓</li>
			<li>
`要素を~scrollする$( コレ,  %目的位置 , `auto$l )
◎
Scroll the element to scrollLeft,y, with the scroll behavior being "auto".
</li>
</ol>
			</dd>
			<dd class="en">
◎
The scrollLeft attribute, on getting, must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, return zero and terminate these steps.
• If the element is the root element and document is in quirks mode, return zero and terminate these steps.
• If the element is the root element return the value of scrollX on window.
• If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollX on window.
• If the element does not have any associated CSS layout box, return zero and terminate these steps.
• Return the x-coordinate of the scrolling area at the alignment point with the left of the padding edge of the element.
◎
When setting the scrollLeft attribute these steps must be run:
• Let x be the given value.
• Normalize non-finite values for x.
• Let document be the element’s node document.
• If document is not the active document, terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, terminate these steps.
• If the element is the root element and document is in quirks mode, terminate these steps.
• If the element is the root element invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element does not have any associated CSS layout box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
• Scroll the element to x,scrollTop, with the scroll behavior being "auto".
</dd>

	<dt>`scrollWidth@m ｜ `scrollHeight@m </dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The scrollWidth attribute must return the result of running these steps:
</p>
		<ol>
			<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
			<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

				<ul >
					<li>
［
%文書 は`過去互換~mode$下にない
］~AND［
コレ ~EQ %文書 の`根~要素$
］
</li>
					<li>
［
%文書 は`過去互換~mode$下にある
］~AND［
コレは `~HTML~body要素$である
］~AND［
コレは
`~scroll可能になり得ない$
］
</li>
				</ul>

<p>
…ならば：
</p>
				<ol>
					<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
					<li>
~RET
`max^op( `表示域$の`~scrollされる区画$の［
横幅 ｜ 縦幅
］, `表示域$の［
`有効~横幅$ ｜ `有効~縦幅$
］ )
</li>
				</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any, or zero if there is no viewport.
◎
If the element is the root element and document is not in quirks mode return max(viewport scrolling area width, viewport width).
◎
If the element is the HTML body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area width, viewport width).
</li>
			<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated CSS layout box return zero and terminate these steps.
</li>
			<li>
~RET
コレの`~scrollされる区画$の［
横幅 ｜ 縦幅
］
◎
Return the width of the element’s scrolling area.
</li>
		</ol>
	</dd>
	<dd class="en">
◎
The scrollHeight attribute must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let viewport height be the height of the viewport excluding the height of the scroll bar, if any, or zero if there is no viewport.
• If the element is the root element and document is not in quirks mode return max(viewport scrolling area height, viewport height).
• If the element is the HTML body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area height, viewport height).
• If the element does not have any associated CSS layout box return zero and terminate these steps.
• Return the height of the element’s scrolling area.
</dd>

	<dt>`clientTop@m ｜ `clientLeft@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The clientTop attribute must run these steps:
</p>
		<ol>
			<li>
~IF［
コレは `~CSS~layout~box$を持たない
］~OR［
コレの `~CSS~layout~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
</li>
			<li>
<p>
~RET 次の和：
</p>
				<ul>
					<li>
［
`border-top-width$p ｜ `border-left-width$p
］~propの算出d値
</li>
			<li>
`~padding辺$の［
上端 ｜ 左端
］と`~border辺$の［
上端 ｜ 左端
］の間に描画された~scroll~barの［
縦幅 ｜ 横幅
］
</li>
				</ul>
<p>
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</p>
◎
Return the computed value of the border-top-width property plus the height of any scrollbar rendered between the top padding edge and the top border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
		</ol>
	</dd>
	<dd class="en">
◎
The clientLeft attribute must run these steps:
• If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
• Return the computed value of the border-left-width property plus the width of any scrollbar rendered between the left padding edge and the left border edge, ignoring any transforms that apply to the element and its ancestors.
</dd>

	<dt>`clientWidth@m ｜ `clientHeight@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The clientWidth attribute must run these steps:
</p>
		<ol>
			<li>
~IF［
コレは `~CSS~layout~box$を持たない
］~OR［
コレの `~CSS~layout~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
				<ul>
					<li>
［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にない
］
</li>
					<li>
［
コレは `~HTML~body要素$ である
］~AND［
%文書 は`過去互換~mode$下にある
］
</li>
		</ul>

<p>
…ならば
⇒
~RET
`表示域$の［
`有効~横幅$ ｜ `有効~縦幅$
］
</p>
◎
If the element is the root element and the element’s node document is not in quirks mode, or if the element is the HTML body element and the element’s node document is in quirks mode, return the viewport width excluding the size of a rendered scroll bar (if any).
</li>
			<li>
<p>
~RET  `~padding辺$の［
横幅 ｜ 縦幅
］
— ここで：
</p>

<ul><li>`~padding辺$と`~border辺$の間に~scroll~barが描画されている場合は，その分の［
横幅 ｜ 縦幅
］は除外する。
</li><li>コレとその先祖に対する`変形$は適用しないとする。
</li></ul>
◎
Return the width of the padding edge excluding the width of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
		</ol>
	</dd>
	<dd class="en">
◎
The clientHeight attribute must run these steps:
• If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
• If the element is the root element and the element’s node document is not in quirks mode, or if the element is the HTML body element and the element’s node document is in quirks mode, return the viewport height excluding the size of a rendered scroll bar (if any).
• Return the height of the padding edge excluding the height of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</dd>
</dl>

		<section id="element-scrolling-members">
<h3 title="Element Scrolling Members">6.1. 要素の~scroll法</h3>

<div class="algorithm">
<p>
%要素 を
`~viewの中へ~scrollする@
ときは、所与の
⇒＃
~scrollの挙動 %挙動,
塊~flow方向~位置 %塊,
行内~基底~方向~位置 %行内
◎終
に対し，次を走らす：
</p>

<ol>
	<li>
<p>
［
%要素 の先祖~要素 または`表示域$
］のうち`~scrollされる~box$ %~box を確立している
~EACH( %S )
に対し，最も内縁の`~scrollされる~box$から順に：
</p>
		<ol>
			<li>
~IF［
( %要素 に結付けられている`文書$, %S に結付けられている`文書$ )
は `同一-生成元$でない
］
⇒
~RET
</li>
			<li>
%要素境界 ~LET ［
%要素 上で `getBoundingClientRect()$m を呼出した結果
］を表現する~box
</li>
			<li>
下に与える
“要素境界を~box内に~scrollする”
下位手続きを走らす
</li>
		</ol>
	</li>
</ol>

◎
To scroll an element into view element, with a scroll behavior behavior, a block flow direction position block, and an inline base direction position inline, means to run these steps for each ancestor element or viewport that establishes a scrolling box scrolling box, in order of innermost to outermost scrolling box:
• If the Document associated with element is not same origin with the Document associated with the element or viewport associated with box, terminate these steps.
• Let element bounding border box be the box that the return value of invoking getBoundingClientRect() on element represents.
</div>

<div class="algorithm">
<p>
上の手続きにて，要素境界を~box内に~scrollするときは：
◎
↑</p>

<ol>
	<li>
<div class="p">
<p>
この段においては：
</p>
		<ul>
			<li>
%~box の辺 %e に対する
%要素境界 の
`同じ側@
の辺とは、
%e と物理的に同じ側にある %要素境界 の辺を指すとする。
</li>
			<li>
［
`開始辺$ ／ `終止辺$ ／ 中心 ／ 距離
］は、［
%塊 に対しては`塊~flow方向$,
%行内 に対しては`行内~基底~方向$
］におけるそれを指すとする。
</li>
		</ul>
<p>
%目的位置 ~LET
( `塊~flow方向$, `行内~基底~方向$ )
成分が 順に
( %塊, %行内 )
に応じて，以下に従うように %~box を整列させる~scroll位置：
</p>
◎
Let scrolling box edge A be the beginning edge in the block flow direction of scrolling box, and let element edge A be element bounding border box’s edge on the same physical side as that of scrolling box edge A.
◎
Let scrolling box edge B be the ending edge in the block flow direction of scrolling box, and let element edge B be element bounding border box’s edge on the same physical side as that of scrolling box edge B.
◎
Let scrolling box edge C be the beginning edge in the inline base direction of scrolling box, and let element edge C be element bounding border box’s edge on the same physical side as that of scrolling box edge C.
◎
Let scrolling box edge D be the ending edge in the inline base direction of scrolling box, and let element edge D be element bounding border box’s edge on the same physical side as that of scrolling box edge D.
◎
Let element height be the distance between element edge A and element edge B.
◎
Let scrolling box height be the distance between scrolling box edge A and scrolling box edge B.
◎
Let element width be the distance between element edge C and element edge D.
◎
Let scrolling box width be the distance between scrolling box edge C and scrolling box edge D.
◎
Let position be the scroll position scrolling box would have by following these steps:
</div>
		<dl class="switch">
			<dt>`start$l</dt>
			<dd>
%~box の`開始辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
If block is "start", then align element edge A with scrolling box edge A.
</dd>

			<dt>`end$l</dt>
			<dd>
%~box の`終止辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
Otherwise, if block is "end", then align element edge B with scrolling box edge B.
</dd>

			<dt>`center$l</dt>
			<dd>
%~box の中心に， %要素境界 の中心を整列する
◎
Otherwise, if block is "center", then align the center of element bounding border box with the center of scrolling box in scrolling box’s block flow direction.
</dd>

			<dt>`nearest$l</dt>
			<dd>
				<ol>
					<li>
%要素~幅 ~LET
%~box の［`開始辺$, `終止辺$］と`同じ側$にある，
%要素境界 を成す 2 辺の距離
◎
↑</li>
					<li>
%~box幅 ~LET
%~box の`開始辺$と`終止辺$の距離
◎
↑</li>
					<li>

<p>
%~box と %要素境界 の位置関係に応じて：
◎
Otherwise, block is "nearest":
</p>

						<dl class="switch">
							<dt>
%~box の［
`開始辺$, `終止辺$
］どちらも，その外側に %要素境界 の`同じ側$の辺がある
◎
If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
</dt>
							<dd>
何もしない
【現在の~scroll位置と同じ】
◎
Do nothing.
</dd>
							<dt>
［
%~box の`開始辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~LT %~box幅
］
◎
If element edge A is outside scrolling box edge A and element height is less than scrolling box height 
</dt>

							<dt>
［
%~box の`終止辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~GT %~box幅
］
◎
If element edge B is outside scrolling box edge B and element height is greater than scrolling box width
</dt>
							<dd>
%~box の`開始辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
Align element edge A with scrolling box edge A.
</dd>

							<dt>
［
%~box の`開始辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~GT %~box幅
］
◎
If element edge A is outside scrolling box edge A and element height is greater than scrolling box width
</dt>
							<dt>
［
%~box の`終止辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~LT %~box幅
］
◎
If element edge B is outside scrolling box edge B and element height is less than scrolling box width
</dt>
							<dd>
%~box の`終止辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
Align element edge B with scrolling box edge B.
</dd>
						</dl>
					</li>
				</ol>
			</dd>
		</dl>

<div class="en">
◎
• If inline is "start", then align element edge C with scrolling box edge C.
• Otherwise, if inline is "end", then align element edge D with scrolling box edge D.
• Otherwise, if inline is "center", then align the center of element bounding border box with the center of scrolling box in scrolling box’s inline base direction.
• Otherwise, inline is "nearest":
•• If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
••• Do nothing.
•• If element edge C is outside scrolling box edge C and element width is less than scrolling box width
•• If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
••• Align element edge C with scrolling box edge C.
•• If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
•• If element edge D is outside scrolling box edge D and element width is less than scrolling box width
••• Align element edge D with scrolling box edge D.
</div>

	</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の~scroll位置
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as scrolling box’s current scroll position, and scrolling box does not have an ongoing smooth scroll, then return.
</li>
	<li>
%~assoc要素 ~LET %S に応じて
⇒
要素であるならば %S ／
`表示域$であるならば ［
%S に結付けられている`文書$の`根~要素$
］
◎
If scrolling box is associated with an element
• Let associated element be the element.
◎
If scrolling box is associated with a viewport
• Let document be the viewport’s associated Document. Let associated element be document’s root element, if there is one, or null otherwise.
</li>
	<li>
`~scrollを遂行する$( %~box, %目的位置, %~assoc要素, %挙動 )
◎
Perform a scroll of scrolling box to position, associated element as the associated element and behavior as the scroll behavior.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`要素を~scrollする@
ときは、所与の
( %要素, %目的位置, %挙動 （省略時は `auto$l ） )
に対し，次を走らす：
◎
To scroll an element element to x,y optionally with a scroll behavior behavior (which is "auto" if omitted) means to:
</p>

<ol>
	<li>
%~box ~LET %要素 の`~scrollされる~box$＊
◎
Let box be element’s associated scrolling box.
</li>
	<li>
( %x, %y ) ~SET 目的位置の ( x, y ) ~~成分
◎
↓</li>
	<li>
<p>
%x ~SET
%~box の横方向の`~overflow方向$に応じて，次で与えられる値：
◎
↓</p>
		<dl class="switch">
			<dt>右方
◎
If box has rightward overflow direction
</dt>
			<dd>
`max^op( 0, `min^op( %x, %要素 の`~scrollされる区画$の横幅 ~MINUS %要素 の`~padding辺$の横幅 ) )
◎
Let x be max(0, min(x, element scrolling area width - element padding edge width)).
</dd>

			<dt>左方
◎
If box has leftward overflow direction
</dt>

			<dd>
`min^op( 0, `max^op( %x, %要素 の`~padding辺$の横幅 ~MINUS %要素 の`~scrollされる区画$の横幅 ) )
◎
Let x be min(0, max(x, element padding edge width - element scrolling area width)).
</dd>
		</dl>
	</li>
	<li>
<p>
%y ~SET
%~box の縦方向の`~overflow方向$に応じて，次で与えられる値：
◎
↓</p>
		<dl class="switch">
			<dt>下方
◎
If box has downward overflow direction
</dt>
			<dd>
`max^op( 0, `min^op( %y, %要素 の`~scrollされる区画$の縦幅 ~MINUS %要素 の`~padding辺$の縦幅 ) )
◎
Let y be max(0, min(y, element scrolling area height - element padding edge height)).
</dd>

			<dt>上方
◎
If box has upward overflow direction
</dt>

			<dd>
`min^op( 0, `max^op( %y, %要素 の`~padding辺$の縦幅 ~MINUS %要素 の`~scrollされる区画$の縦幅 ) )
◎
Let y be min(0, max(y, element padding edge height - element scrolling area height)).
</dd>
		</dl>
	</li>
	<li>
%目的位置 ~LET
`~scrollされる区画$の座標 ( %x, %y ) は
%~box の左上隅に整列されるような， %~box の~scroll位置
◎
Let position be the scroll position box would have by aligning scrolling area x-coordinate x with the left of box and aligning scrolling area y-coordinate y with the top of box.
</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の~scroll位置
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as box’s current scroll position, and box does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`~scrollを遂行する$( %~box, %目的位置, %要素, %挙動 )
◎
Perform a scroll of box to position, element as the associated element and behavior as the scroll behavior.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="extensions-to-the-htmlelement-interface">

<h2 title="Extensions to the HTMLElement Interface">7. `HTMLElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLElement!I {
  readonly attribute `Element$I? `offsetParent$m;
  readonly attribute long `offsetTop$m;
  readonly attribute long `offsetLeft$m;
  readonly attribute long `offsetWidth$m;
  readonly attribute long `offsetHeight$m;
};
</pre>

`HTMLElement^dgm

<dl class="idl-def">
	<dt>`offsetParent@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The offsetParent attribute must return the result of running these steps:
</p>
		<ol>
			<li>
<p>
~IF［
コレは次のいずれかを満たす
］…：
◎
If any of the following holds true return null and terminate this algorithm:
</p>
				<ul>
					<li>
`~CSS~layout~box$を持たない
◎
The element does not have an associated CSS layout box.
</li>
					<li>
`根~要素$である
◎
The element is the root element.
</li>
					<li>
`~HTML~body要素$である
◎
The element is the HTML body element.
</li>
					<li>
`position$p ~propの算出d値 ~EQ `fixed^v
◎
The element’s computed value of the position property is fixed.
</li>
				</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
↑</p>

			</li>
			<li>
%先祖 ~LET コレ
◎
↓</li>
			<li>
<p>
~WHILE［
`平坦~tree$における %先祖 の親~要素 %親 はある
］：
◎
Let ancestor be the parent of the element in the flat tree and repeat these substeps:
</p>
				<ol>
					<li>
%先祖 ~SET %親
◎
↑</li>
					<li>
<p>
~IF［
%先祖 は コレからは`閉な~shadowで隠されて$いる
］
⇒
~IF［
%先祖 の `position$p ~propの算出d値 ~EQ `fixed^v
］
⇒
~RET ~NULL
◎
If ancestor is closed-shadow-hidden from the element and its computed value of the position property is fixed, terminate this algorithm and return null.
</li>
					<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
If ancestor is not closed-shadow-hidden from the element and satisfies at least one of the following, terminate this algorithm and return ancestor.
</p>
						<ul>
							<li>
コレは［
`絶対~位置決め包含塊$／`固定d位置決め包含塊$
］を確立する
◎
The element is a containing block of absolutely-positioned descendants (regardless of whether there are any absolutely-positioned descendants).
</li>
							<li>
%先祖 は `~HTML~body要素$である
◎
It is the HTML body element.
</li>
							<li>
［
コレの `position$p ~propの算出d値 ~EQ `static^v
］~AND［
%先祖 は［
`td^e, `th^e, `table^e
］いずれかの `~HTML要素$ である
］
◎
The computed value of the position property of the element is static and the ancestor is one of the following HTML elements: td, th, or table.
</li>
						</ul>
<p>
…ならば
⇒
~RET %先祖
◎
If there is no more parent of ancestor in the flat tree, terminate this algorithm and return null.
◎
Let ancestor be the parent of ancestor in the flat tree.
</p>
					</li>
				</ol>
			</li>
			<li>
~RET ~NULL
◎
↑</li>
		</ol>
	</dd>

	<dt>`offsetTop@m ｜ `offsetLeft@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The offsetTop attribute must return the result of running these steps:
</p>
		<ol>
			<li>
~IF［
コレは `~HTML~body要素$である
］~OR［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element is the HTML body element or does not have any associated CSS layout box return zero and terminate this algorithm.
</li>
			<li>
以下においては
⇒＃
どの座標も`初期~包含塊$の原点に相対的とする ／
コレとその先祖に対する`変形$は適用しないとする
◎
↓</li>
			<li>
%~border座標 ~LET コレの最初の`~CSS~layout~box$の`~border辺$の［
上端の y 座標 ｜ 左端の x 座標
］
◎
If the offsetParent of the element is null return the y-coordinate of the top border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
</li>
			<li>
~IF［
コレの `offsetParent$m ~NEQ ~NULL
］
⇒
%~border座標 ~DECBY ( コレの `offsetParent$m の最初の`~CSS~layout~box$の`~padding辺$の［
上端の y 座標 ｜ 左端の x 座標
］ )
◎
Return the result of subtracting the y-coordinate of the top padding edge of the first CSS layout box associated with the offsetParent of the element from the y-coordinate of the top border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</li>
			<li>
~RET %~border座標
◎
↑</li>
		</ol>
	</dd>
	<dd class="note">注記：
複数の行l~boxからなる`行内$要素については、その最初の `~CSS~layout~box$のみが考慮されることになる。
◎
Note: An inline element that consists of multiple line boxes will only have its first CSS layout box considered.
</dd>
	<dd class="en">
◎
The offsetLeft attribute must return the result of running these steps:
• If the element is the HTML body element or does not have any associated CSS layout box return zero and terminate this algorithm.
• If the offsetParent of the element is null return the x-coordinate of the left border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
• Return the result of subtracting the x-coordinate of the left padding edge of the first CSS layout box associated with the offsetParent of the element from the x-coordinate of the left border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</dd>

	<dt>`offsetWidth@m ｜ `offsetHeight@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The offsetWidth attribute must return the result of running these steps:
</p>
		<ol>
			<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated CSS layout box return zero and terminate this algorithm.
</li>
			<li>
~RET 
コレの最初の `~CSS~layout~box$の`~border辺$の［
横幅 ｜ 縦幅
］
— ここで、コレとその先祖に対する`変形$は適用しないとする。
◎
Return the border edge width of the first CSS layout box associated with the element, ignoring any transforms that apply to the element and its ancestors.
</li>
		</ol>
	</dd>
	<dd class="en">
◎
The offsetHeight attribute must return the result of running these steps:
• If the element does not have any associated CSS layout box return zero and terminate this algorithm.
• Return the border edge height of the first CSS layout box associated with the element, ignoring any transforms that apply to the element and its ancestors.
</dd>
</dl>

	</section>
	<section id="excensions-to-the-htmlimageelement-interface">

<h2 title="Extensions to the HTMLImageElement Interface">8. `HTMLImageElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLImageElement!I {
  readonly attribute long `x$m;
  readonly attribute long `y$m;
};
</pre>

<dl class="idl-def">
	<dt>`x@m ｜ `y@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
</li>
			<li>
~RET `初期~包含塊$の原点に相対的な［
コレの最初の `~CSS~layout~box$の`~border辺$
］の［
左端の x 座標 ｜ 上端の y 座標
］］
— ここで、コレとその先祖に対する`変形$は適用しないとする。
</li>
		</ol>
◎
The x attribute, on getting, must return the x-coordinate of the left border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no CSS layout box.
◎
The y attribute, on getting, must return the y-coordinate of the top border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no CSS layout box. 
</dd>
</dl>

	</section>
	<section id="extensions-to-the-range-interface">

<h2 title="Extensions to the Range Interface">9. `Range^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Range!I {
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();
};
</pre>

`Range^dgm

<dl class="idl-def">
	<dt>`getClientRects()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The getClientRects() method, when invoked, must＼
</p>
		<ol>
			<li>
~IF［
コレは文書~内を指していない
］
⇒
~RET 空の `DOMRectList$I ~obj
◎
return an empty DOMRectList object if the range is not in the document and＼
</li>
			<li>
<p>
~RET ［
次の拘束に合致するような `DOMRect$I ~obj
］からなる，内容~順の~listを包含する `DOMRectList$I ~obj：
◎
otherwise a DOMRectList object containing a list of DOMRect objects in content order that matches the following constraints:
</p>
				<ul>
					<li>
コレに`包含され$ている各 %要素 に対する
⇒
%要素 上の `getClientRects()^m を呼出した結果に含まれる~border区画たち
◎
For each element selected by the range, whose parent is not selected by the range, include the border areas returned by invoking getClientRects() on the element.
</li>
					<li>
<p>
コレに［
`部分的に包含され$ているか`包含され$ている†
］各 `Text$I ~node
（`始端$と`終端$が同じになるものも含まれる）に対する
⇒
（行l~box全体ではなく）選択された部分のみを囲む `DOMRect$I ~obj
◎
For each Text node selected or partially selected by the range (including when the boundary-points are identical), include a DOMRect object (for the part that is selected, not the whole line box).＼
</p>

<p class="trans-note">【†
`包含され$ている要素~内の `Text^I ~nodeも除外されないことになる。
】</p>

<p>
これらの `DOMRect$I ~objの限界域は、~font計量を用いて算出される。
したがって，横書きの下では、各~boxの
縦方向の寸法は~fontの~ascentと~descentから決定され,
横方向の寸法は~textの送り幅から決定される。
コレの`中身$が `~typographic文字~単位$ `CSS-TEXT-3$r
を部分的に含む場合（例： 代用対の片割れや書記素~clusterの一部分）、限界域を算出する目的においては，その`~typographic文字~単位$を全部的に含めるモノトスル。
要素の先祖に対する`変形$は、適用される。
◎
The bounds of these DOMRect objects are computed using font metrics; thus, for horizontal writing, the vertical dimension of each box is determined by the font ascent and descent, and the horizontal dimension by the text advance width. If the range covers a partial typographic character unit (e.g. half a surrogate pair or part of a grapheme cluster), the full typographic character unit must be included for the purpose of computing the bounds of the relevant DOMRect. [CSS-TEXT-3] The transforms that apply to the ancestors are applied.
</p>

<p class="trans-note">【
“送り幅（ `advance^en ）”
— 対象~textが描画される起点から，後続の~textが同じ行lに描画されるとするときの，その起点までの長さ
】</p>
					</li>
				</ul>
			</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methodが返す `DOMRect$I ~objは、`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</dd>

	<dt>`getBoundingClientRect@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The getBoundingClientRect() method, when invoked, must return the result of the following algorithm:
</p>
		<ol>
			<li>
%~list ~LET コレ上で
`getClientRects()$m
を呼出した結果
◎
Let list be the result of invoking getClientRects() on the same range this method was invoked on.
</li>
			<li>
~IF［
%~list は空である
］
⇒
~RET 次のようにされた `DOMRect$I ~obj
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
			<li>
~IF［
%~list 内の どの矩形も，横幅, 縦幅とも 0 である
］
⇒
~RET %~list 内の最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
			<li>
~RET ［
%~list 内の［
横幅, 縦幅とも 0 ではない
］すべての矩形を包含するような，最~小な矩形
］を表現する `DOMRect$I ~obj
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methodが返す `DOMRect$I ~objは、`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</dd>
</dl>

	</section>
	<section id="extensions-to-the-mouseevent-interface">

<h2 title="Extensions to the MouseEvent Interface">10. `MouseEvent^I ~interfaceに対する拡張</h2>

<p class="issue">
この~obj~IDL片は、一部の~memberを再定義している。
Can we resolve this somehow?【！＊】
◎
The object IDL fragment redefines some members. Can we resolve this somehow?
</p>

<pre class="idl">
partial interface `MouseEvent!I {
  readonly attribute double `screenX$m;
  readonly attribute double `screenY$m;
  readonly attribute double `pageX$m;
  readonly attribute double `pageY$m;
  readonly attribute double `clientX$m;
  readonly attribute double `clientY$m;
  readonly attribute double `x$m;
  readonly attribute double `y$m;
  readonly attribute double `offsetX$m;
  readonly attribute double `offsetY$m;
};

partial dictionary `MouseEventInit!I {
  double `screenX@m = 0.0;
  double `screenY@m = 0.0;
  double `clientX@m = 0.0;
  double `clientY@m = 0.0;
};
</pre>

`MouseEvent^dgm

<!-- `MouseEvent!I -->

<dl class="idl-def">
	<dt>`screenX@m ｜ `screenY@m</dt>
	<dd>
取得子は、`~Webに公開される~screen区画$の原点に相対的な，コレが生じた地点の［
x 座標 ｜ y 座標
］を返すモノトスル。
◎
The screenX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
◎
The screenY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
</dd>

	<dt>`pageX@m ｜ `pageY@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The pageX attribute must follow these steps:
</p>
		<ol>
			<li>
~IF［
コレの`配送~flag$ ~EQ ~T
］
⇒
~RET
`初期~包含塊$の原点に相対的な，コレが生じた地点の［
横方向 ｜ 縦方向
］の座標
◎
If the event’s dispatch flag is set, return the horizontal coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
</li>
			<li>
%offset ~SET コレに結付けられている `Window$I ~objは［
在れば その［
`scrollX^m ｜ `scrollY^m
］属性の値 ／
無ければ 0
］
◎
Let offset be the value of the scrollX attribute of the event’s associated Window object, if there is one, or zero otherwise.
</li>
			<li>
~RET ［
%offset ~PLUS ( コレの［
`clientX$m ｜ `clientY$m
］属性の値 )
］
◎
Return the sum of offset and the value of the event’s clientX attribute. 
</li>
		</ol>
	</dd>
	<dd class="en">
◎
The pageY attribute must follow these steps:
• If the event’s dispatch flag is set, return the vertical coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollY attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientY attribute. 
</dd>

	<dt>`clientX@m ｜ `clientY@m</dt>
	<dd>
取得子は、`表示域$の原点に相対的な，コレが生じた地点の［
x 座標 ｜ y 座標
］を返すモノトスル。
◎
The clientX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the viewport.
◎
The clientY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the viewport.
</dd>

	<dt>`x@m ｜ `y@m</dt>
	<dd>
取得子は、［
`clientX$m ｜ `clientY$m
］と同じ値を返すモノトスル。
◎
The x attribute must return the value of clientX.
◎
The y attribute must return the value of clientY.
</dd>

	<dt>`offsetX@m ｜ `offsetY@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The offsetX attribute must follow these steps:
</p>
		<ol>
			<li>
<p>
~IF［
コレの`配送~flag$ ~EQ ~T
］
⇒
~RET 
要素とその先祖に対する`変形$は適用しない下で，
target ~nodeの`~padding辺$の原点に相対的な，コレが生じた地点の［
x 座標 ｜ y 座標
］
◎
If the event’s dispatch flag is set, return the x-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
</p>

<p class="trans-note">【
target ~node：
コレの配送-先の~node（より明確には，~event伝播の中で `AT_TARGET$m に該当する~node）。
】</p>
			</li>
			<li>
~RET ［
`pageX$m ｜ `pageY$m
］属性の値
◎
Return the value of the event’s pageX attribute. 
</li>
		</ol>
	</dd>
	<dd class="en">
◎
The offsetY attribute must follow these steps:
• If the event’s dispatch flag is set, return the y-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
• Return the value of the event’s pageY attribute. 
</dd>
</dl>

	</section>
	<section id="geometry">

<h2 title="Geometry">11. 幾何</h2>

		<section id="the-geometryutils-interface">
<h3 title="The GeometryUtils Interface" class="atrisk">11.1. `GeometryUtils^I ~interface</h3>

<pre class="idl">
enum `CSSBoxType@I { `margin@l, `border@l, `padding@l, `content@l };
dictionary `BoxQuadOptions@I {
  `CSSBoxType$I `box@mb = `border$l;
  `GeometryNode$I `relativeTo@mb; // XXX default document (i.e. viewport)
};

dictionary `ConvertCoordinateOptions@I {
  `CSSBoxType$I `fromBox@mb = `border$l;
  `CSSBoxType$I `toBox@mb = `border$l;
};

interface mixin `GeometryUtils@I {
  sequence&lt;`DOMQuad$I&gt; `getBoxQuads$m(
      optional `BoxQuadOptions$I %options = {}
  );
  `DOMQuad$I `convertQuadFromNode$m(
      `DOMQuadInit$I %quad,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMQuad$I `convertRectFromNode$m(
      `DOMRectReadOnly$I %rect,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMPoint$I `convertPointFromNode$m(
      `DOMPointInit$I %point,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  ); // XXX z,w turns into 0
};
 
`Text$I includes `GeometryUtils$I; // like Range
`Element$I includes `GeometryUtils$I;
`CSSPseudoElement$I includes `GeometryUtils$I;
`Document$I includes `GeometryUtils$I;

typedef (`Text$I or `Element$I or `CSSPseudoElement$I or `Document$I) `GeometryNode@I;
</pre>

<dl class="idl-def">
	<dt>`getBoxQuads(options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The getBoxQuads(options) method must run the following steps:
</p>
		<ol>
			<li class="issue">
DOM order

<p>p1 = top left even in RTL</p>
<p>scale to 0 means divide by zero, return 0x0</p>
<p>cross-frames not allowed, throw WrongDocumentError?</p>
<p>points are flattened (3d transform), z=0. like getClientRect</p>
<p>test block in inline</p>
<p>pseudo-elements before/after are children of the element</p>
<p>viewport boxes are all the same</p>
			</li>
		</ol>
	</dd>

	<dt>`convertQuadFromNode(quad, from, options)@m</dt>
	<dd class="issue">
【未策定】
◎
The convertQuadFromNode(quad, from, options) method must run the following steps:
</dd>

	<dt>`convertRectFromNode(rect, from, options)@m</dt>
	<dd class="issue">
【未策定】
◎
The convertRectFromNode(rect, from, options) method must run the following steps:
</dd>

	<dt>`convertPointFromNode(point, from, options)@m</dt>
	<dd class="issue">
【未策定】
◎
The convertPointFromNode(point, from, options) method must run the following steps:
</dd>
</dl>

		</section>
	</section>

	<section id="events">
<h2 title="Events">12. ~event</h2>

		<section id="resizing-viewports">
<h3 title="Resizing viewports">12.1. 表示域の~size変更</h3>

<p>
この節は、 `HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<div class="algorithm">
<p>
`文書の~resize手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to run the resize steps for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
この手続きを最後に走らせたときから
`表示域$の横幅または縦幅は変化した†
］
⇒
%文書 に結付けられている `Window$I ~objに向けて，名前 `resize$et の`~eventを発火する$
</p>

<p>†
例えば：
</p>
<ul><li>利用者が~browserの~UIwindowを［
~resize／拡大
］したとき
</li><li>`~page~zoom$倍率が変化したとき
</li><li>`iframe^e 要素の寸法が変化したとき
</li></ul>
◎
If doc’s viewport has had its width or height changed (e.g. as a result of the user resizing the browser window, or changing the page zoom scale factor, or an iframe element’s dimensions are changed) since the last time these steps were run, fire an event named resize at the Window object associated with doc. 
</li>
</ol>
</div>

		</section>
		<section id="scrolling-events">

<h3 title="Scrolling">12.2. ~scroll法</h3>

<p>
この節は、 `HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
各 `文書$には、
`~scroll処理待ち~list@
— 処理待ちにある~scroll~event~targetたちが成す~list —
が結付けられる（初期~時は空）。
◎
Each Document has an associated list of pending scroll event targets, initially empty.
</p>

<div class="algorithm">
<p>
~UAは、`表示域$が~scrollされる度に（利用者とのヤリトリ, ~APIのどちらによるかを問わず），次を走らすモノトスル：
◎
Whenever a viewport gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
</p>

<ol>
	<li>
%文書 ~LET `表示域$に結付けられている`文書$
◎
Let doc be the viewport’s associated Document.
</li>
	<li>
~IF［
%文書 ~IN %文書 の`~scroll処理待ち~list$
］
⇒
~RET
◎
If doc is already in doc’s pending scroll event targets, abort these steps.
</li>
	<li>
%文書 の`~scroll処理待ち~list$に %文書 を付加する
◎
Append doc to doc’s pending scroll event targets.
</li>
</ol>
</div>

<div class="algorithm">
<p>
~UAは、要素が~scrollされる度に（利用者とのヤリトリ, ~APIのどちらによるかを問わず），次を走らすモノトスル：
◎
Whenever an element gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
</p>

<ol>
	<li>
%文書 ~LET 要素の`~node文書$
◎
Let doc be the element’s node document.
</li>
	<li>
~IF［
要素 ~IN %文書 の`~scroll処理待ち~list$
］
⇒
~RET
◎
If the element is already in doc’s pending scroll event targets, abort these steps.
</li>
	<li>
%文書 の`~scroll処理待ち~list$に要素を付加する
◎
Append the element to doc’s pending scroll event targets.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`文書の~scroll手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to run the scroll steps for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
%文書 の`~scroll処理待ち~list$内の
~EACH( %target )
に対し：
◎
For each item target in doc’s pending scroll event targets, in the order they were added to the list, run these substeps:
</p>
		<ol>
			<li>
~IF［
%target は`文書$である
］
⇒
%target に向けて，名前 `scroll$et の`~eventを発火する$
— 次のように初期化して
⇒
`bubbles^m ~SET ~T
◎
If target is a Document, fire an event named scroll that bubbles at target.
</li>
			<li>
~ELSE
⇒
%target に向けて，名前 `scroll$et の`~eventを発火する$
◎
Otherwise, fire an event named scroll at target.
</li>
		</ol>
	</li>
	<li>
%文書 の`~scroll処理待ち~list$を空にする
◎
Empty doc’s pending scroll event targets.
</li>
</ol>
</div>

		</section>
		<section id="event-summary">
<h4 title="Event summary">12.3. ~event要覧</h4>

~INFORMATIVE

<table class="_event-table">
<thead><tr><th>~event
<th>~interface
<th>~target
<th>~~説明
</thead>

<tbody>
<tr><td>`resize@et
<td>`Event$I
<td>`Window$I
<td>
`表示域$が~resizeされたときに `Window$I に向けて発火される。
◎
Fired at the Window when the viewport is resized.

<tr><td>`scroll@et
<td>`Event$I
<td>`文書$, 要素
<td>
［
`表示域$ ／ 要素
］が~scrollされたときに［
`文書$ ／ 要素
］に向けて発火される。
◎
Fired at the Document or element when the viewport or element is scrolled, respectively. 

</tbody></table>

		</section>
	</section>
	<section id="css-properties">

<h3 title="CSS properties">13. ~CSS~prop</h3>

<p class="issue">
この節の特能は他の仕様に移動されるべきであろう。
◎
The features in this section should be moved to some other specification.
</p>

			<section id="smooth-scrolling:-the-scroll-behavior-property">
<h2 title="Smooth Scrolling: The scroll-behavior Property">13.1. 滑らかな~scroll： `scroll-behavior^p ~prop</h2>

◎名 `scroll-behavior@p
◎値 `auto$v | `smooth$v
◎初 `auto$v
◎適 `~scrollされる~box$
◎継 されない
◎百 受容しない
◎算 指定d値
◎ア 不可【 離散的？ ~animate不可？】
◎順 文法に従う
◎表終

<p>
`scroll-behavior$p ~propは、~naviあるいは~scroll用の CSSOM ~API により~scrollされたときの，`~scrollされる~box$における挙動を指定する。
他のどの~scrollも，この~propからは影響されない
— 例えば利用者により行われるものなど。
この~propが`根~要素$に指定された場合、代わりに`表示域$に適用される。
◎
The scroll-behavior property specifies the scrolling behavior for a scrolling box, when scrolling happens due to navigation or CSSOM scrolling APIs. Any other scrolls, e.g. those that are performed by the user, are not affected by this property. When this property is specified on the root element, it applies to the viewport instead.
</p>

<p class="note">注記：
~HTML `body^e 要素の `scroll-behavior$p ~propは、表示域へは <em>伝播しない</em>。
◎
The scroll-behavior property of the HTML body element is not propagated to the viewport.
</p>

<dl>
	<dt>`auto@v</dt>
	<dd>
`~scrollされる~box$による~scrollは、`瞬時に$行われる。
◎
The scrolling box is scrolled in an instant fashion.
</dd>

	<dt>`smooth@v</dt>
	<dd>
`~scrollされる~box$による~scrollは、~UA定義な速度と動きにより，`滑らか$に行われる。
~UAは~platform慣行があればそれに従うべきである。
◎
The scrolling box is scrolled in a smooth fashion using a user-agent-defined timing function over a user-agent-defined period of time. User agents should follow platform conventions, if any.
</dd>

</dl>

<p>
~UAは、この~propを無視してもヨイ。
◎
User agents may ignore this property.
</p>

		</section>
	</section>
	<section id="change-history">

<h2 title="Change History">変更~履歴</h2>

<p>
この節では、この仕様の各発行版の間の変更点の一部を文書化する。
この節は、網羅的ではない。
~bug修正点や編集上の変更点は、一般に，挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

		<section id="changes-from-2020-01-31">
<h3 title="Changes From 31 January 2020">2020年 1月 31日 からの変更点</h3>

<ul>
	<li>
編集者に `Simon Fraser^en を追加した。
◎
Added Simon Fraser as editor
</li>
	<li>
`Window!I 上の `resizeTo()$m の引数を %width, %height に改称した。
（<a href="~CSSissue/4727">課題 #4727</a>）
◎
Renamed the arguments to resizeTo() to be width and height (4727)
</li>
</ul>

		</section>
		<section id="changes-from-2013-12-17">
<h3 title="Changes From 17 December 2013 To 31 January 2020">2013年 12月 17日 から 2020年 1月 31日 までの変更点</h3>

<ul>
	<li>
`Element!I 上の
`scrollIntoView()$m ~methodを変更して拡張した。
◎
The scrollIntoView() method on Element was changed and extended.
</li>
	<li>
`Element!I 上の［
`scrollTop$m, `scrollLeft$m
］~IDL属性は、~objをとらないようにした
— 代わりに［
`scroll()$m, `scrollTo()$m, `scrollBy()$m
］~methodを追加した。
◎
The scrollTop and scrollLeft IDL attributes on Element changed to no longer take an object; the scroll(), scrollTo() and scrollBy() methods were added instead.
</li>
	<li>
`Element!I 上の［
`scrollWidth$m,
`scrollHeight$m,
`clientTop$m,
`clientLeft$m,
`clientWidth$m 
`clientHeight$m
］~IDL属性は、整数を返す~~元のふるまいに戻した。
◎
The scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth and clientHeight IDL attributes on Element were changed back to return integers.
</li>
	<li>
`DOMRectList^I ~interfaceを除去した。
◎
The DOMRectList interface was removed.
</li>
	<li>
`Document!I 上に `scrollingElement$m ~IDL属性を追加した。
◎
The scrollingElement IDL attribute on Document was added.
</li>
	<li>
`Window$I 上の一部の読専（ readonly ）属性に、
[Replaceable] ~IDL拡張属性で注釈した。
◎
Some readonly attributes on Window were annotated with [Replaceable] IDL extended attribute.
</li>
	<li>
［
`MediaQueryList$I,
`scroll$et ~event,
`resize$et ~event
］を
— ~animation~frameに同期するよう —
~HTMLにおける`~event~loop$に統合した。
◎
MediaQueryList, scroll event and resize event are integrated with the event loop in HTML so they are synchronized with animation frames.
</li>
	<li>
`scroll-behavior$p の `instant^v 値を `auto$v に改称した。
◎
The instant value of scroll-behavior was renamed to auto.
</li>
	<li>
`Element!I 上の `scrollLeft$m の原点を（右横書き用に）変更した。
◎
The origin of scrollLeft on Element was changed (for RTL).
</li>
	<li>
`Element!I 上の `scrollIntoView()$m ~method, および
`Window!I 上の［
`scroll()$m, `scrollTo()$m, `scrollBy()$m
］~methodは、関連な辞書~型~値を最初の引数にとるようにした。
◎
The scrollIntoView() method on Element and scroll(), scrollTo() and scrollBy() methods on Window take the relevant dictionary as the first argument.
</li>
	<li>
`MediaQueryList!I ~interfaceを、定例の~event~APIを利用し，それを通して `addListener()$m を定義するように変更した。
◎
The MediaQueryList interface was changed to use regular event API and define addListener() in terms of that.
</li>
</ul>

		</section>
		<section id="changes-from-2011-08-04">
<h3 title="Changes From 4 August 2011 To 17 December 2013">2011年 8月 4日 から 2013年 12月 17日 までの変更点</h3>

<ul>
	<li>
右横書き（`行内~基底~方向$）と縦組みも取扱うようにした。
◎
The specification now handles right-to-left and vertical writing modes.
</li>
	<li>
［
`~page~zoom$, `~pinch~zoom$
］を織り込んだ。
◎
The specification is now aware of page zoom and pinch zoom.
</li>
	<li>
`scroll-behavior$p ~CSS~propを導入して、滑らかな~scrollを制御できるよう，~scroll用~APIを拡張した。
◎
The scroll-behavior CSS property is introduced and scrolling APIs are extended with a mechanism to control smooth scrolling.
</li>
	<li>
［
`moveTo()^m,
`moveBy()^m,
`resizeTo()^m,
`resizeBy()^m
］~methodを定義した。
◎
The moveTo(), moveBy(), resizeTo() and resizeBy() methods are now defined.
</li>
	<li>
`innerWidth^m, 等々は、
WebIDL 型 `long^c ではなく， `double^c を利用するようにした。
◎
innerWidth et al now use the WebIDL type double instead of long.
</li>
	<li>
`devicePixelRatio^m を定義した。
◎
devicePixelRatio is now defined.
</li>
	<li>
`window.open()^m
に対する %features 引数を定義した。
◎
The features argument to window.open() is now defined.
</li>
	<li>
`Screen$I の［
`colorDepth^m, `pixelDepth^m
］属性は、 24 を返すようにした。
◎
The colorDepth and pixelDepth attributes of Screen now always return 24.
</li>
	<li>
`Element$I に
`elementsFromPoint()^m
~methodを導入した。
◎
The elementsFromPoint() method of Element is introduced.
</li>
	<li>
`変形$を織り込んだ。
◎
The specification is now aware of transforms.
</li>
	<li>
幾何~utility~APIをいくつか導入した
— が、まだ仕様化していない。
◎
Some geometry utility APIs are introduced but are not yet specified.
</li>
	<li>
`ClientRect^I を `DOMRect^I に改称して、 Geometry 仕様 `GEOMETRY-1$r に移動した。
◎
ClientRect has been renamed to DOMRect and has moved to the Geometry specification. [GEOMETRY-1]
</li>
	<li>
［
`resize$et, `scroll$et
］~eventの発火-時機について定義した。
◎
The specification now defines when the resize and scroll events fire. 
</li>
</ul>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この文書に貢献された次の方々に感謝する：
</p>

<p lang="en-x-a0">
The editors would like to thank

Alan Stearns,
Alexey Feldgendler,
Antonio Gomes,
Björn Höhrmann,
Boris Zbarsky,
Chris Rebert,
Corey Farwell,
Dan Bates,
David Vest,
Elliott Sprehn,
Garrett Smith,
Henrik Andersson,
Hallvord R. M. Steen,
Kang-Hao Lu,
Koji Ishii,
Leif Arne Storset,
Luiz Agostini,
Maciej Stachowiak,
Michael Dyck,
Mike Wilson,
Morten Stenshorne,
Olli Pettay,
Pavel Curtis,
Peter-Paul Koch,
Rachel Kmetz,
Rick Byers,
Robert O’Callahan,
Sam Weinig,
Scott Johnson,
Sebastian Zartner,
Stewart Brodie,
Sylvain Galineau,
Tab Atkins,
Tarquin Wilton-Jones,
Thomas Moore,
Thomas Shinnick,
and
Xiaomei Ji

for their contributions to this document.
</p>

<p>
この草案にて指定された特能の多くを，Windows Internet Explorer ~browserにて最初に実装した Microsoft の人達に特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented many of the features specified in this draft, which were first widely deployed by the Windows Internet Explorer browser.
</p>

	</section>
</main></div>

<div id="_info-view">（クリックで消去）<pre id="_info-box"></pre></div>
