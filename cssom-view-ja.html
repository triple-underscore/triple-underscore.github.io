<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSSOM View Module （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<style>

#_info-view {
	position: fixed;
	z-index:10;
	display: none;
	padding: 0;
	bottom: 0;
	right: 0;
	min-width:20em;
	background: var(--sample-bg-color-1);
	outline: ridge var(--pale-color) 4px;
}

#_info-view.show {
	display: block;
}

.en::before {
	content: "↑";
	color: var(--dim-color);
}

.element::before,
.element::after {
	content: none;
}


@supports (display: grid) and (display: contents) {

#_event-table {
	min-width: 24em;
	max-width: 48em;
}

#_event-table tr {
	grid-template-areas:
		"event event event"
		". interface 標的"
		". 説明 説明"
	;
	grid-template-columns: 4em 10em 1fr;
}

#_event-table tr > *:nth-child(1) {
	grid-area: event;
	border-left-width: 0;
}

#_event-table tr > *:nth-child(2) {
	grid-area: interface;
}

#_event-table tr > *:nth-child(3) {
	grid-area: 標的;
}

#_event-table tr > *:nth-child(4) {
	grid-area: 説明;
	padding: 0.5em;
}

}

</style>

<style>
@keyframes lvmove {
	0%, 10%, 20% { top: 25%; }
	30%, 50%, 70% { top: 37.5%; }
	80%,100% { top: 25%; }
}
@keyframes vvmove {
	0%, 10% { top: 37.5%; }
	30%, 50% { top: 62.5%; }
	80%, 90% { top: 25%; }
	100% { top: 37.5%; }
}

#_vvanimation {
	border: solid thin var(--N-color);
	position: relative;
	background: var(--W-color);
	width: 20em;
	height: 28em;
}

#_vvanimation > div {
	box-sizing: border-box;
	border: solid;
	position: absolute;
}

#_vvanimation._paused > div {
	animation-play-state: paused;
}

#_lv {
	color: var(--B-color);
	width: 100%;
	height: 50%;
	left: 0;
	top: 25%;
	animation: lvmove linear 3s infinite;
}
#_vv {
	color: var(--R-color);
	width: 50%;
	height: 25%;
	left: 25%;
	top: 37.5%;
	animation: vvmove linear 3s infinite;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		populate: () => {
			const e = E('_vvanimation');
			e.onclick = () => {
				e.classList.toggle('_paused');
			};
		},
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let ctx_ifc = '';
	let ctx_ifc1 = ''; // interface for 'm1'

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if(indicator === '@'){
		ctx_ifc = key;
	} else {
		ctx_ifc1 = key;
	}
	href = `#${key.toLowerCase()}`;
	break;
case 'I0':
	ctx_ifc = key;
	return '';
	break;
case 'I1':
	ctx_ifc1 = key;
	return '';
	break;
case 'mc':
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`;
	text = 'constructor';
	break;
case 'm1':
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
		const ifc = ( klass === 'm1' ) ? ctx_ifc1: ctx_ifc
		href = `#dom-${ifc}-${key}`.toLowerCase();
	}
	break;
case 'opf':
case 'l':
	text = `"<code class="literal">${text}</code>"`
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}

</script>


<!--%testing demos -->
<script>

Util.DEFERRED.push(init2);

function init2(){
	repeat('input[data-params]', (e) => {
		const event = e.getAttribute('data-event') || 'click';
		e.addEventListener(event, display_attrs, false);
	});

	const DATA = {
		Window:{
			event_type: ['scroll', 'resize'],
			obj(){return window;},
			attrs: 'screen innerWidth innerHeight scrollX pageXOffset scrollY pageYOffset screenX screenY outerWidth outerHeight devicePixelRatio'
		},

		MediaQueryList:{
			obj(){
  const v = E('_test-mql_text').value.replace(/\'/g, '\"');
  this.src = 'window.matchMedia(\'' + v + '\')';
  return window.matchMedia(v);
},
			attrs: 'media matches'
		},

		Screen:{
			obj(){ return window.screen; },
			attrs: 'availWidth availHeight width height colorDepth pixelDepth'
		},

		'Element.scrollIntoView':{
			obj(){
				const top = E('_test-scrollIntoView-top').checked;
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= var tag_name= ..., top = ... ;
  var e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView(top);//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView(${top})
（クリックで元の位置へ復帰）`
				);
}
		},

		'Element.scrollIntoView0':{
			obj(){
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const behavior = E('_test-scrollIntoView-behavior').value;
				const block = E('_test-scrollIntoView-block').value;
				const inline = E('_test-scrollIntoView-inline').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= const tag_name= ... , behavior = ... , block = ... ;
  let e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView({
    behavior: behavior,
    block: block,
    inline: inline
  });//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView( { behavior: "${behavior}", block: "${block}" } )
（クリックで元の位置へ復帰）`
				);
}
		},

		'Window.scroll':{
			obj(){
				let x, y, e;
				e = E('_test-scroll-x');
				e.value = x = parseInt(e.value);
				e = E('_test-scroll-y');
				e.value = y = parseInt(e.value);
				
				const pos = {x: window.scrollX, y: window.scrollY};
				let method_name = '';
				repeat('input[name="_test-scroll-fn"]', (e) => {
					if(e.checked){
						method_name = e.id.slice('_test-scroll-'.length);
					}
				})
				if(!method_name) return;
//=
	window[method_name](x, y);//=

					revert_pos = pos;
					return(
`${method_name}(${x},${y})
（クリックで元の位置へ復帰）`
					);
			}
		},

		Element:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight'
		},

		HTMLElement:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'offsetParent offsetTop offsetLeft offsetWidth offsetHeight'
		},

		'Selection.getBoundingClientRect':{
			event_type: ['mousemove', 'keyup'],

// https://developer.mozilla.org/en-US/docs/DOM/Selection
// chrome はテキスト未選択時に getRangeAt がエラーを投出
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getBoundingClientRect();//=
			},
			attrs: 'top right bottom left width height'
		},

		'Selection.getClientRects':{
			event_type: ['mousemove', 'keyup'],
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getClientRects();//=
},
			attrs: 'length'
		},

		MouseEvent:{
			event_type: 'mousemove',
			obj(event){return event;},
			attrs: 'screenX screenY pageX pageY clientX clientY x y offsetX offsetY'
		},

		ClientRect:{
			event_type: 'mouseover',
			obj(event){return event.target.getBoundingClientRect();},
			attrs: 'top right bottom left width height'
		},

		getClientRects:{
			event_type: 'mouseover',
			obj(event){return event.target.getClientRects();},
			attrs: 'length'
		},

		elementFromPoint:{
			event_type: 'mousemove',
			obj(event){
  select(//=
    document.elementFromPoint(event.clientX, event.clientY)//=
  );
}
		},

		elementsFromPoint:{
			event_type: 'mousemove',
			obj(event){
				return(//=
document
  .elementsFromPoint(event.clientX, event.clientY)
  .map((e) => {return e.tagName;})
  .join(', ')//=
				);
			},
		},

		caretPositionFromPoint:{
			event_type: 'mousemove',
			obj(event){
  return document.caretPositionFromPoint(event.clientX, event.clientY);
},
			attrs: 'offsetNode offset'
		},

		NULL:{}
	};

	let revert_pos = null;
	let interface_name = null;
	let current_elem = null;

//	display_attrs = 
	function display_attrs(event){
		const key = event.currentTarget.getAttribute('data-params');
		interface_name = key;
		revert_pos = null;

		window.addEventListener('click', disable_view, true);
		if(! ('event_type' in DATA[key])) {
			show_attrs();
			interface_name = null;
			return;
		}
		switch(key){
		case 'Window':
		case 'Selection.getBoundingClientRect':
		case 'Selection.getClientRects':
			show_attrs();
		}
		enable_listener(true);
	}

	E('_test-mql_text').onfocus = () => {
		E('_test-mql_text').onfocus = null;
		const mql_options = E('_MQL_options');
		for( const mq of mql_options.firstChild.data.split(';') ){
			const option = C('option');
			option.textContent = mq.trim();
			mql_options.appendChild(option);
		};
	}

return;

//	var select = document.body.classList ? select1 : function(){};
	function select(e){
		hilight(false);
		current_elem = e;
		hilight(true);
		function hilight(h){
			if(!current_elem) return;
			// outline style はどの要素からも利用されていないものと見なす
			current_elem.style.outline = h ? 'solid red 1px' : '';
		}
	}

	function enable_listener(enable){
		let types = interface_name && DATA[interface_name].event_type;
		if(!types) return;
		if(typeof(types) === 'string'){
			types = [types];
		}
		for( const type of types){
			enable?
				window.addEventListener(type, show_attrs, false):
				window.removeEventListener(type, show_attrs, false);
		}
	}

	function disable_view(event){
		E('_info-view').className = '';
		enable_listener(false);
		window.removeEventListener('click', disable_view, true);
		select(null);
		if(revert_pos) {
			if(!event.target.onclick){
				window.scrollTo(revert_pos.x, revert_pos.y);
			}
			revert_pos = null;
		}
	}

	function show_attrs(event){
		let obj;
		const data = DATA[interface_name];
		try {
			obj = data.obj(event);
		} catch(e){
			show_text(
`次の実行に失敗：
  ${source_of(data)}`
			);
			enable_listener(false);
			return;
		}
		if(!obj) return;
		let texts = [];
		if(typeof(obj) === 'string'){
			texts[0] = obj;
		} else if('attrs' in data){
			texts = ['● オブジェクト：', source_of(data), '● 属性：'];
			let attrs = data.attrs;
			if(typeof(attrs) === 'string'){
				attrs = data.attrs = attrs.split(' ');
			}
			for( const name of attrs ){
				texts.push(
`${(name + '                     ').slice(0, 18)}:${obj[name]}`
				)
			};
		}
		if(event && (event.type === 'mouseover')){
			select(event.target);
		}
		show_text(texts.join('\n'));
	}
	
	function show_text(text){
		E('_info-box').textContent = text;
		E('_info-view').className = 'show';
	}

	function source_of(data){
		if('src' in data) return data.src;
		const s = data.obj.toString ?
			data.obj.toString() : '(ソースコードを取得できません。)';
		const m = s.match(/\/\/=([^\0]+)\/\/=|return\s([^;}]+)/);
		return data.src = ((m && (m[1] || m[2])) || s).trim();
	}

}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSSOM View Module
spec_date:2023-04-25
trans_update:2023-04-26
source_checked:220729
page_state_key:CSS
original_url:https://drafts.csswg.org/cssom-view-1/
	abbr_url:CSSOMVIEW
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2012-09-22


●●class_map
e:element
a:attr
et:event-type
p:property
d:descriptor
css:css
v:value
u:unit
op:op

●●tag_map
I:code
m:code
m1:code
mb:code
mc:code
et:code
e:code
a:code
p:code
d:code
css:code
c:code
v:code
u:code
b:b
op:span

●●original_id_map
scrolling-box:

●●mdn_urls

mediaquerylist:API/MediaQueryList
mediaquerylistevent:API/MediaQueryListEvent
screen:API/Screen
caretposition:API/CaretPosition
	geometryutils:API/GeometryUtils
dictdef-scrolltooptions:API/ScrollToOptions
	dictdef-scrolloptions:API/ScrollOptions
	dictdef-mediaquerylisteventinit:API/MediaQueryListEventInit
	dictdef-scrollintoviewoptions:API/ScrollIntoViewOptions
	dictdef-boxquadoptions:API/BoxQuadOptions
	dictdef-convertcoordinateoptions:API/ConvertCoordinateOptions
	enumdef-scrollbehavior:API/ScrollBehavior
	enumdef-scrolllogicalposition:API/ScrollLogicalPosition
	enumdef-cssboxtype:API/CSSBoxType
	typedefdef-geometrynode:API/GeometryNode

eventdef-window-resize:API/Window/resize_event
eventdef-document-scroll:API/Document/scroll_event
eventdef-document-scrollend:API/Document/scrollend_event
eventdef-mediaquerylist-change:API/MediaQueryList/change_event

●●link_map

	●IDL
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject
Replaceable:~WEBIDLjs#Replaceable
Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
double:~WEBIDL#idl-double
unsigned long:~WEBIDL#idl-unsigned-long
unrestricted double:~WEBIDL#idl-unrestricted-double
sequence:~WEBIDL#idl-sequence
CSSOMString:~CSSOM1#cssomstring

I.ScrollBehavior:#enumdef-scrollbehavior
I.ScrollOptions:#dictdef-scrolloptions
I.ScrollToOptions:#dictdef-scrolltooptions
I.MediaQueryList:#mediaquerylist
I.MediaQueryListEvent:#mediaquerylistevent
I.MediaQueryListEventInit:#dictdef-mediaquerylisteventinit

I.ScrollLogicalPosition:#enumdef-scrolllogicalposition
I.ScrollIntoViewOptions:#dictdef-scrollintoviewoptions
I.CheckVisibilityOptions:#dictdef-checkvisibilityoptions

I.VisualViewport:#visualviewport
I.Screen:#screen
I.CaretPosition:#caretposition
I.CSSBoxType:#enumdef-cssboxtype
I.BoxQuadOptions:#dictdef-boxquadoptions
I.ConvertCoordinateOptions:#dictdef-convertcoordinateoptions
I.GeometryUtils:#geometryutils
I.GeometryNode:#typedefdef-geometrynode

I.Window:~WINDOW#window

I.Document:~DOM4#document
I.Element:~DOM4#element
I.Text:~DOM4#text
I.Node:~DOM4#node
I.Range:~DOM4#range

I.EventTarget:~DOM4#eventtarget
I.EventListener:~DOM4#callbackdef-eventlistener
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.HTMLElement:~HTMLdom#htmlelement
I.WindowProxy:~HTMLWPROXY#windowproxy
I.HTMLImageElement:~HEimages#htmlimageelement
I.EventHandler:~WAPI#eventhandler

I.MouseEvent:~UIEVENTS#mouseevent
I.MouseEventInit:~UIEVENTS#dictdef-mouseeventinit

I.CSSPseudoElement:~CSSPSEUDO#csspseudoelement

I.DOMPoint:~GEOMETRY#dompoint
I.DOMPointInit:~GEOMETRY#dictdef-dompointinit
I.DOMRect:~GEOMETRY#domrect
I.DOMRectList:~GEOMETRY#domrectlist
I.DOMRectReadOnly:~GEOMETRY#domrectreadonly
I.DOMQuad:~GEOMETRY#domquad
I.DOMQuadInit:~GEOMETRY#dictdef-domquadinit

m.AT_TARGET:~DOM4#dom-event-at_target
	bubbles:~DOM4#
m.removeEventListener:~DOM4#dom-eventtarget-removeeventlistener
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.isTrusted:~DOM4#dom-event-istrusted
	m.type:~DOM4#dom-event-type
m.open:~WINDOW#dom-window-open
m.~doc-open:~HTMLdynamic#dom-document-open-window
	原文誤）m.open:~HTMLdynamic#dom-document-open
m.defaultView:~WINDOW#dom-document-defaultview


mb.block:#dom-scrollintoviewoptions-block
mb.inline:#dom-scrollintoviewoptions-inline
mb.behavior:#dom-scrolloptions-behavior
mb.left:#dom-scrolltooptions-left
mb.top:#dom-scrolltooptions-top

mb.media:#dom-mediaquerylisteventinit-media
mb.matches:#dom-mediaquerylisteventinit-media
mb.box:#dom-boxquadoptions-box
mb.relativeTo:#dom-boxquadoptions-relativeto
mb.fromBox:#dom-convertcoordinateoptions-frombox
mb.toBox:#dom-convertcoordinateoptions-tobox

mb.checkOpacity:#dom-checkvisibilityoptions-checkopacity
mb.checkVisibilityCSS:#dom-checkvisibilityoptions-checkvisibilitycss

mb.clientX:#dom-mouseeventinit-clientx
mb.clientY:#dom-mouseeventinit-clienty
mb.screenX:#dom-mouseeventinit-screenx
mb.screenY:#dom-mouseeventinit-screeny

opf.width:#supported-open-feature-name-width
opf.height:#supported-open-feature-name-height
opf.left:#supported-open-feature-name-left
opf.top:#supported-open-feature-name-top

et.resize:#eventdef-window-resize
et.scroll:#eventdef-document-scroll
et.scrollend:#eventdef-document-scrollend
et.change:#eventdef-mediaquerylist-change

l.auto:#dom-scrollbehavior-auto
l.smooth:#dom-scrollbehavior-smooth
l.instant:#dom-scrollbehavior-instant

l.start:#dom-scrolllogicalposition-start
l.center:#dom-scrolllogicalposition-center
l.end:#dom-scrolllogicalposition-end
l.nearest:#dom-scrolllogicalposition-nearest

l.margin:#dom-cssboxtype-margin
l.border:#dom-cssboxtype-border
l.padding:#dom-cssboxtype-padding
l.content:#dom-cssboxtype-content

e.body:~HEsections#the-body-element
e.rect:~SVGshapes#elementdef-rect

	●css
u.px:~CSSVAL#px

d.color:~MQ5#descdef-media-color

p.content-visibility:~CSSCONTAIN#propdef-content-visibility
p.position:~CSSPOS#propdef-position
p.direction:~CSSWM#propdef-direction
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.display:~CSSDISP#propdef-display
p.opacity:~CSSCOLOR#propdef-opacity
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.scroll-behavior:~CSSOVERFLOW3#propdef-scroll-behavior
p.pointer-events:~CSSUI#propdef-pointer-events

v.smooth:~CSSOVERFLOW3#valdef-scroll-behavior-smooth

v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden
v.visible:~CSSOVERFLOW3#valdef-overflow-visible
v.clip:~CSSOVERFLOW3#valdef-overflow-clip

v.table:~CSSDISP#valdef-display-table
v.inline-table:~CSSDISP#valdef-display-inline-table
v.table-column:~CSSDISP#valdef-display-table-column
v.table-column-group:~CSSDISP#valdef-display-table-column-group


	●用語
同じ側:#_same-side
有効~横幅:#_effective-width
有効~縦幅:#_effective-height
文書:#_document
接触判定:#_hit-testing
~scrollされる~box:#scrolling-box

~window用の~scroll手続き:#_window-scroll-steps
要素~用の~scroll手続き:#_element-scroll-steps
要素~用の限界~boxを取得する:#element-get-the-bounding-box

視覚-表示域:#visual-viewport
~layout表示域:#layout-viewport
vV.拡縮率:#scale-factor
vV.文書:#visualviewport-associated-document

開始辺:#beginning-edges
終了辺:#ending-edges

~supportされる~open_m特能~名:#supported-open-feature-name

mq.媒体~query~list:#mediaquerylist-media-query-list
mq.媒体:#mediaquerylist-media
mq.文書:#mediaquerylist-document
mq.合致-状態:#mediaquerylist-matches-state
有限~値に正規化する:#normalize-non-finite-values
~page~zoom:#page-zoom
~pinch~zoom:#pinch-zoom

~scrollされる区画:#scrolling-area
~scroll可能になり得る:#potentially-scrollable
~scroll可能になり得ない:#potentially-scrollable
処理待ち~scroll-ev~event~target群:#document-pending-scroll-event-targets
処理待ち~scrollend-ev~event~target群:#document-pending-scrollend-event-targets
要素を~scrollする:#scroll-an-element
瞬時に~scrollする:#concept-instant-scroll
滑らかに~scrollする:#concept-smooth-scroll
滑らか:#concept-smooth-scroll
滑らかな~scroll:#concept-smooth-scroll
~scrollを遂行する:#perform-a-scroll
表示域の~scrollを遂行する:#viewport-perform-a-scroll
~viewの中へ~scrollする:#scroll-a-target-into-view
文書の開始位置に~scrollする:#scroll-to-the-beginning-of-the-document
sS.中止-:#smooth-scroll-aborted
sS.完了-:#smooth-scroll-completed
完了-:#scroll-completed

原点:#scrolling-area-origin

機器~pixel比を決定する:#determine-the-device-pixel-ratio

変形:#transforms

~SVG~layout~box:#svg-layout-box
	媒体~query~list ~listenerの~list:#list-of-media-query-list-listeners
~caret位置:#caret-position
~caret~node:#caret-node
~caret~offset:#caret-offset
~caret範囲:#caret-range

~overflow方向:#overflow-directions

~Webに公開される~screen区画:#web-exposed-screen-area
~Webに公開される可用な~screen区画:#web-exposed-available-screen-area

閲覧~文脈の特能を設定しておく:#set-up-browsing-context-features

文書~用の媒体~queryを評価して変化を報告する:#evaluate-media-queries-and-report-changes
文書の~resize手続き:#document-run-the-resize-steps
文書の~scroll手続き:#document-run-the-scroll-steps

	●用語（CSS
~canvas:~CSScommon#canvas
表示域:~CSS2J#viewport

基準~pixel:~CSSVAL#reference-pixel

~padding辺:~CSSBOX#padding-edge
~margin辺:~CSSBOX#margin-edge
~border辺:~CSSBOX#border-edge
内容~区画:~CSSBOX#content-area
~border~box:~CSSBOX#border-box
媒体~query~listとして構文解析する:~CSSOM1#parse-a-media-query-list
	媒体~query~listを直列化する:~CSSOM1#serialize-a-media-query-list

~box:~CSSDISP#box
首要~box:~CSSDISP#principal-box
行内~levelの~box:~CSSDISP#inline-level-box
塊~level:~CSSDISP#block-level
匿名:~CSSDISP#anonymous
塊~box:~CSSDISP#block-box
表示~型:~CSSDISP#display-type
不可視:~CSSDISP#invisible
根~要素:~CSSDISP#root-element

塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end
塊~flow方向:~CSSWM#block-flow-direction
行内~基底~方向:~CSSWM#inline-base-direction

~box断片:~CSSBREAK#box-fragment

古典~scrollbar:~CSSOVERFLOW3#classic-scrollbars
上層~scrollbar:~CSSOVERFLOW3#overlay-scrollbars
~scroll位置:~CSSOVERFLOW3#scroll-position
初期~scroll位置:~CSSOVERFLOW3#initial-scroll-position

平坦~tree:~CSSSCOPING#flat-tree

内容-分布~prop:~CSSALIGN#content-distribution-properties

	■補完
~border区画:~CSSBOX#border-area
包含塊:~CSSDISP#containing-block
行内:~CSSDISP#inline
初期~包含塊:~CSSDISP#initial-containing-block
置換d要素:~CSSDISP#replaced-element
~box~tree:~CSSDISP#box-tree

絶対~位置決め包含塊:~CSSPOS#absolute-positioning-containing-block
固定d位置決め包含塊:~CSSPOS#fixed-positioning-containing-block
~flow外:~CSSDISP#out-of-flow

内容が飛ばされ:~CSSCONTAIN#skips-its-contents
実~値:~MQ5#real-value

~typographic文字~単位:~CSSTEXT#typographic-character-unit
書記素~cluster:~CSSTEXT#grapheme-cluster

~scroll容器:~CSSOVERFLOW3#scroll-container

	●用語（外部
~map:~INFRA#ordered-map
符号単位:~INFRA#code-unit

~live:~HTMLINFRA#live
~HTML要素:~HTMLINFRA#html-elements
一致する:~INFRA#string-is
文字大小区別:~INFRA#string-is

整数として構文解析する:~HTMLcms#rules-for-parsing-integers

~body要素:~HTMLdom#the-body-element-2

閲覧~文脈:~HTMLds#browsing-context
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
nav.作動中な文書:~HTMLds#nav-document
全部的に作動中:~HTMLds#fully-active
nav.容器~文書:~HTMLds#nav-container-document

結付けられている文書:~WINDOW#concept-document-window
対応する閲覧~文脈:~WINDOW#window-bc

同一-生成元:~ORIGIN#same-origin

~event~loop:~WAPI#event-loop
~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
関連な大域~obj:~WAPI#concept-relevant-global
描画を更新する段:~WAPI#update-the-rendering

~event~listener:~DOM4#concept-event-listener
evL.型:~DOM4#event-listener-type
evL.~callback:~DOM4#event-listener-callback
evL.捕捉するか:~DOM4#event-listener-capture
~event~listener~list:~DOM4#eventtarget-event-listener-list
~event~listenerを追加する:~DOM4#add-an-event-listener
~event~listenerを除去する:~DOM4#remove-an-event-listener
~eventを発火する:~DOM4#concept-event-fire
ev.配送-中か:~DOM4#dispatch-flag
過去互換~mode:~DOM4#concept-document-quirks
doc.生成元:~DOM4#concept-document-origin
包含され:~DOM4#contained
部分的に包含され:~DOM4#partially-contained
要素:~DOM4#concept-element
範囲o:~DOM4#concept-range
中身:~DOM4#concept-range-content
境界点:~DOM4#concept-range-bp

始端:~DOM4#concept-range-start
終端:~DOM4#concept-range-end
始端~node:~DOM4#concept-range-start-node
始端~offset:~DOM4#concept-range-start-offset

	文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element
~shadowも含めた先祖:~DOM4#concept-shadow-including-ancestor

閉な~shadowで非可視:~DOM4#concept-closed-shadow-hidden

	●補完
畳まれて:~DOM4#range-collapsed

●●words_table1

open_m: <code>open()</code>
doc-open:open
scroll-ev: <code class="event-type">scroll</code> 
scrollend-ev: <code class="event-type">scrollend</code> 


●●words_table


代用対:surrogate pair::サロゲートペア:
	セット:set
		→ ON, OFF

	●CSS layout
	viewport
ascent::::アセント
descent::::ディセント
col:column
限界:bounding::~
限界域:bounds::~
	~~限界まで来た:extent
縦組み:vertical writing mode::~
描画面:rendering surface::~
中身:content::~
横書き:horizontal writing::~
固定d:fixed::固定
固定-:fix::~
分布:distribution::~
首要:principal::主要
基準:reference:~
	~flowし直-:reflow
	幅:how large


	●塗り
alpha::::アルファ
塗られ:paintされ:~
塗り:paint:~

	最~上端:topmost

	●scroll／UI
目的位置:position:~
zoom::::ズーム
	~zoom法:zooming
拡大-:zoom in::~::ズームイン
縮小-:zoom out::~::ズームアウト
pan::::パン
caret::::キャレット
pinch::::ピンチ
	~pinch~zoom:pinch-zoom
滑らか:smooth::~
拡縮-:scale::~
拡縮率:scale factor::~
処理待ち:pending:~
接触判定:hit-testing::~
挿入位置指示:insertion point indicator:~
瞬時:instant::~
計量:metric:~
量:amount:~
周期:interval:~
touch::::タッチ
drag::::ドラッグ
	複~touch
wheel:
隠され:hideされ:~
ARIA:
終止-:end:~
留め:snap::~::スナップ
	~scroll留め:scroll-snap
並進:translation::~
判読可能に:legibleに:判読し易く
露呈-:reveal::露わに
上層:overlay::~::オーバーレイ
解放-:release:~
trackpad::::トラックパッド
選択-:select:~
virtual:
縮短-:shrink:~
差分:delta:~

	~scrollされる〜:scrolling〜
	~scroll法:scrolling
	~~位置
	倍率:magnitude
	-:magnitude
	^en:proportional
	~~拡大鏡:magnifying glass
	下へ:down by
	ぶつかる:bump up
	回す:tick
	持ち込む:bring
	押し出す:push
	あと〜までしか:room

	●幾何
x:
y:
dx:
dy:
幾何:geometry:~
地点:position:~
点:point:~
右横書き:right-to-left:~
	右横書き:RTL
横方向:horizontal::~
	~x:horizontal
縦方向:vertical::~
	~y:vertical
	縦幅:vertical dimension
	横幅:horizontal dimension
上辺:top edge::~
下辺:bottom edge::~
左辺:left edge::~
右辺:right edge::~
上方:upward::~
下方:downward::~
左方:leftward::~
右方:rightward::~
中心:center::~
開始辺:beginning edge::~
終了辺:ending edge::~
	innermost, outermost
矩形:rectangle:~
四辺形:quadrilateral shape:~
変形:transform::~
	transforms
増大-:increase:~
減少-:decrease:~
比:ratio:~

	各辺が軸に整列された:axis-aligned
	~screen外:offscreen

	●DOM／IDL
閉な:closed::閉じた
補助:auxiliary:~
境界点:boundary point::~
範囲o:range::範囲°

	●処理
割振られ:allocateされ:割り振られ
切詰める:clampする:切り詰める
分配-:distribute:~
協調-:coordinate:~

	事前に:ahead of time
	逆順に:in opposite order
	~MINUS:difference between

	%~target限界~box:target bounding border box
	%文書:doc
	%最大~x:maxX
	%最大~y:maxY
	%~x
	%~y
	%視覚-~x:visual x
	%視覚-~y:visual y
	%~dx:dx
	%~dy:dy
	%視覚-~dx:visual dx
	%視覚-~dy:visual dy
	%vv:vv

	●仕様
utility::ユーティリティ
見積もり:estimation:~
網羅的:exhaustive:~
誤り:error:~
単直:straightforward:簡単
種類:kind:~
合意-:agree:~
図画化:depiction:~

	により定義される:-defined
	詳細:specifics
	に配慮する:considerations
	知られ:known to
	~~正しい:right
	~~適度な:not get too 〜
	ふりをする:masquerade
	選んで:chooseして
	任意で選べる:opted into
	指す:refer
	称され:referred

	●構文
剥いだ:stripした:~

	●未分類
非可視:hidden:~
隠す:hideする:~
assoc:associated:関連
body:
色域:color gamut::~
深度:depth:~
書記素:grapheme::~
typographic::::タイポグラフィック
	片割れ:half
	合致-状態:matches state
担当の:responsible:~
座標軸:axis::~
量子化-:quantize:~
隠蔽-:obscure:~
display::::ディスプレイ
浮動小数点:floating point::~
広義-:inclusive:~
発-:emit:~
維持-:retain:~
携帯機:mobile::~::モバイル
静止-::pause:~

	所属:belongs to
	`一致する$かどうかにより:is
	~Web~IDL:WebIDL
	更新し終えた:finished updating
	より大きく:larger



●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-DEVICE-ADAPT]
    Rune Lillesveen; Florian Rivoal; Matt Rakow. ＜CSS Device Adaptation Module Level 1＞. URL: https://drafts.csswg.org/css-device-adapt/
[CSS-DISPLAY-4]
    CSS Display Module Level 4 URL: https://drafts.csswg.org/css-display-4/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. URL: https://drafts.csswg.org/css-pseudo-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. ＜CSS Text Module Level 3＞. URL: https://drafts.csswg.org/css-text-3/
[CSS-TEXT-4]
    Elika Etemad; et al. ＜CSS Text Module Level 4＞. URL: https://drafts.csswg.org/css-text-4/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[GEOMETRY-1]
    Simon Pieters; Chris Harrelson. ＜Geometry Interfaces Module Level 1＞. URL: https://drafts.fxtf.org/geometry/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[SVG2]
    Amelia Bellamy-Royds; et al. ＜Scalable Vector Graphics (SVG) 2＞. URL: https://svgwg.org/svg2-draft/
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. URL: https://w3c.github.io/uievents/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/
[CSSOM-VIEW-1]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSSOM View Module</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/cssom-view-1/
公表履歴
	https://www.w3.org/standards/history/cssom-view-1
旧公表バージョン
	https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/
テスト一式
	http://test.csswg.org/suites/cssom-view-1_dev/nightly-unstable/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/cssom-view-1">CSSWG Issues Repository</a>

編集
	<a href="mailto:simon.fraser@apple.com">Simon Fraser</a> (Apple Inc)
	<a href="emilio@mozilla.com">Emilio Cobos Álvarez</a> (Mozilla)
前任編集者
	<a href="mailto:simonp@opera.com">Simon Pieters</a> (<a href="http://www.opera.com">Opera Software AS</a>)
	<a href="https://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (<a href="http://www.cox.com">Cox Communications, Inc.</a>) <a href="mailto:glenn.adams@cos.com">glenn.adams@cos.com</a>
	<a href="https://annevankesteren.nl/">Anne van Kesteren</a> (<a href="http://www.opera.com">Opera Software ASA</a>) <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/cssom-view-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/cssom-view-1

旧来の課題リスト
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM%20View&amp;resolution=---">Bugzilla</a>


</script>

</head>

<body>


<!--%resource pool -->
<template id="_persisted_parts">

<div id="_dgm-Window" class="_test">
利用中のブラウザで<br><!-- ※ -->
・これらの属性の
<input value="取得を試みる" data-params="Window" type="button">
<br>
・
x:<input id="_test-scroll-x" value="0" size="5" type="text">
y:<input id="_test-scroll-y" value="0" size="5" type="text">
を入力に<br>
<label><input name="_test-scroll-fn" id="_test-scroll-scroll" type="radio"><code>scroll()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollTo" type="radio"><code>scrollTo()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollBy" checked="" type="radio"><code>scrollBy()</code></label>
<!-- 
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeTo" checked /><code >resizeTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeBy" checked /><code >resizeBy()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveTo" checked /><code >moveTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveBy" checked /><code >moveBy1()</code></label>
 -->
を
<input value="呼び出す" data-params="Window.scroll" type="button">
<br>
次の媒体クエリ：<br>
<input id="_test-mql_text" value="(orientation: landscape)" size="70" list="_MQL_options" data-event="change" data-params="MediaQueryList" type="text">
<br>
に対し，
<code>Window.matchMedia()</code>
の
<input id="_test-MediaQueryList" value="取得を試みる" data-params="MediaQueryList" type="button">
<datalist id="_MQL_options" hidden><!--
(width >= 800px);
(width <= 800px);
(height >= 600px);
(height <= 600px);
(min-device-width: 640px);
(max-device-width: 640px);
(min-device-height: 480px);
(max-device-height: 480px);
(orientation: landscape);
(orientation: portrait);
(min-aspect-ratio: 1/1);
(min-aspect-ratio: 2/1);
(min-aspect-ratio: 1/2);
(max-aspect-ratio: 1/1);
(max-aspect-ratio: 2/1);
(max-aspect-ratio: 1/2);
(color);
(min-color: 8);
(max-color: 8);
(min-color-index: 256);
(max-color-index: 256);
(monochrome);
(min-resolution: 96dpi);
(max-resolution: 96dpi);
(scan: interlace);
(scan: progressive);
(grid);
(update-frequency: none);
(update-frequency: slow);
(update-frequency: normal);
(overflow-block: none);
(overflow-block: scroll);
(overflow-block: optional-paged);
(overflow-block: paged);
(overflow-inline: none);
(overflow-inline: scroll);
(inverted-colors: none);
(inverted-colors: inverted);
(pointer: none);
(pointer: fine);
(pointer: fine);
(hover: none);
(hover: on-demand);
(hover: hover);
(any-pointer: none);
(any-pointer: coarse);
(any-pointer: fine);
(any-hover: none);
(any-hover: on-demand);
(any-hover: hover);
(light-level: dim);
(light-level: normal);
(light-level: washed);
(scripting: none);
(scripting: initial-only);
(scripting: enabled);


all;braille;embossed;handheld;print;projection;screen;speech;tty;tv;aural
--></datalist>
</div>

<div id="_dgm-Screen" class="_test">
利用中のブラウザでこれらの属性の
<input value="取得を試みる" data-params="Screen" type="button">
</div>


<div id="_dgm-Document" class="_test">
利用中のブラウザでマウス位置に対する
<br>
(1) <code>elementFromPoint()</code> の結果を
<input id="_test-elementFromPoint" value="表示する" data-params="elementFromPoint" type="button">
<br>
(1) <code>elementsFromPoint()</code> の結果を成す各 要素のタグ名の
<input id="_test-elementsFromPoint" value="取得を試みる" data-params="elementsFromPoint" type="button">
<br>
(2) <code>caretPositionFromPoint()</code> の
<input id="_test-caretPositionFromPoint" value="取得を試みる" data-params="caretPositionFromPoint" type="button">
</div>


<div id="_dgm-Element" class="_test">
利用中のブラウザで<br>
マウスが重なった要素について
<br>
・これらの属性の
<input value="取得を試みる" data-params="Element" type="button"><br>
・<code>getClientRects()</code> の
<input value="取得を試みる" data-params="getClientRects" type="button"><br>
・<code>getBoundingClientRect()</code> の
<input value="取得を試みる" data-params="ClientRect" type="button">
<br>
ランダムに選ばれた
<select size="1" id="_test-scrollIntoView-tagName"><option selected="">P</option><option>LI</option><option>H2</option><option>DT</option><option>DD</option></select>
要素に対し<br>
・<code>scrollIntoView(<label><input name="_test-SIV-top" id="_test-scrollIntoView-top" checked="" type="radio">true</label>
<label><input name="_test-SIV-top" type="radio">false</label>)</code>
を
<input id="_test-scrollIntoView" value="呼び出す" data-params="Element.scrollIntoView" type="button"><br>
・<code>scrollIntoView( {
	behavior:
<select size="1" id="_test-scrollIntoView-behavior"><option selected="">auto</option><option>smooth</option></select>
	, block:
<select size="1" id="_test-scrollIntoView-block">
	<option selected="">start</option>
	<option>center</option>
	<option>end</option>
	<option>nearest</option>
</select>
	, inline:
<select size="1" id="_test-scrollIntoView-inline">
	<option>start</option>
	<option selected="">center</option>
	<option>end</option>
	<option>nearest</option>
</select>
} )</code> を
<input id="_test-scrollIntoView0" value="呼び出す" data-params="Element.scrollIntoView0" type="button">
</div>


<div id="_dgm-HTMLElement" class="_test">
利用中のブラウザでマウスが重なった要素について，これらの属性の
<input value="取得を試みる" data-params="HTMLElement" type="button">
</div>


<div id="_dgm-Range" class="_test">
利用中のブラウザでテキスト選択に応じて，その範囲に対する<br>
(1) <code>getClientRects()</code> の
<input id="_test-Selection.getClientRects" value="取得を試みる" data-params="Selection.getClientRects" type="button">
<br>
(2) <code>getBoundingClientRect()</code> の
<input id="_test-Selection.getBoundingClientRect" value="取得を試みる" data-params="Selection.getBoundingClientRect" type="button">
</div>

<div id="_dgm-MouseEvent" class="_test">
利用中のブラウザで mousemove イベントに対する，これらの属性の
<input id="_test-MouseEvent" value="取得を試みる" data-params="MouseEvent" type="button">
</div>

</template>


<header>

	<hgroup>
<h1 id="cssom-view-module">CSSOM View Module</h1>
	</hgroup>
</header>

<div  id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様が導入する~APIは、
作者に，文書の視覚的な~viewを調べたり, 操作するための方法を与える。
これには、［
要素の~layout~boxの位置を取得する,
~scriptを通して表示域~sizeを得する,
要素の~scroll法
］なども含まれる。
◎
The APIs introduced by this specification provide authors with a way to inspect and manipulate the visual view of a document. This includes getting the position of element layout boxes, obtaining the width of the viewport through script, and also scrolling an element.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="background">
<h2 title="Background">1. 背景0</h2>

<p>
この仕様にて定義される特能の多くは、
長い間~browserから~supportされてきた。
この仕様の目標は、
これらの特能を，すべての~browserが相互運用可能な方式で実装できるように定義することである。
この仕様は、
~scrollの~custom化を許容する，新たな特能も定義する。
◎
Many of the features defined in this specification have been supported by browsers for a long period of time. The goal of this specification is to define these features in such a way that they can be implemented by all browsers in an interoperable manner. The specification also defines a some new features which allow for scroll customization.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
記述を簡潔にするため，次の（非公式な）用語も定義する：
</p>
<ul>
	<li>
`Document$I ~interfaceを実装する~objは、
単に
`文書@
と略記される。
</li>
	<li>
`表示域$の
`有効~横幅@ ／
`有効~縦幅@
とは、
`表示域$に［
縦方向／横方向
］`古典~scrollbar$†が描画されているときは その部分の区画を除外した，
`表示域$の［
横幅／縦幅
］を表す
（~scrollbarが無ければ，通常の［
横幅／縦幅
］と同じになる）。
（† `上層~scrollbar$は、
~layout用の区画を占めない。）
</li>
</ul>

<p>
“要素が`~box$を持つ”
という句は、
要素に結付けられている~boxが在る
— すなわち，要素は 1 個以上の~boxを生成する —
ことを意味する。
要素の `display$p が［
`none^v ／ `contents^v
］の場合、
要素は，~boxを生成しないので~boxを持たない。
</p>

<p>
加えて、
次の記法を用いる：
</p>
<ul>
	<li>
<p>
記法 “［ %W ｜ %H ］” （ "｜" は全角の縦棒）は、
縦横それぞれの方向についての，並立的な記述を表す。
</p>

<p>
例えば
⇒
“［ x 属性 ｜ y 属性 ］ は表示域の［ 左端の~x座標 ｜ 上端の~y座標 ］ を返す”
◎終
と記されていれば、
それは 2 つの記述
⇒＃
“x 属性 は表示域の左端の~x座標を返す”,
“y 属性 は表示域の上端の~y座標を返す”
◎終
が，並立的に重ねられていることを表す。
この対応関係は，同じ~algoの中の別々な段の間でも維持される。
</p>

<p>
<small>
（このような表記を導入する理由は、
記述の簡約以外にも，［
縦横両方向に関する記述であって, その両方向について対称性がある
］ことを明らかにすることもある。）</small>
</p>
</li>
</ul>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様に利用される用語は
`DOM$r, `CSSOM$r, `HTML$r
による。
◎
Terminology used in this specification is from DOM, CSSOM and HTML. [DOM] [CSSOM] [HTML]
</p>

<p>
所与の（ある`文書$の）`~body要素$ %~body は、
~AND↓ を満たすとき，
`~scroll可能になり得る@
とされる。
◎
An element body (which will be the body element) is potentially scrollable if all of the following conditions are true:
</p>
<ul>
	<li>
%~body は`~box$を持つ。
◎
body has an associated box.
</li>
	<li>
<p>
%~body, %~body の`親~要素$は、
どちらも次を満たす
⇒
［
`overflow-x$p,
`overflow-y$p
］~propのどちらかは次を満たす
⇒
算出d値 ~NIN { `visible$v, `clip$v }
</p>

<p class="trans-note">【
実際には、
片方の~propがこれを満たすならば，両方とも満たすことになる。
】</p>
◎
body’s parent element’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
◎
body’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
</li>
</ul>

<p class="note">注記：
`body$e 要素は、
`~scroll可能になり得る$としても，`~scrollされる~box$は無いこともある。
具体的には、
要素の `overflow$p の使用~値は `auto^v であるが，
その内容は内容~区画を~overflowしていない場合など。
◎
Note: A body element that is potentially scrollable might not have a scrolling box. For instance, it could have a used value of overflow being auto but not have its content overflowing its content area.
</p>

<p>
［
`表示域$／要素
］【が`~scroll容器$になるとき】の
`~scrollされる~box@
（ `scrolling box^en ）には、
2 つの
`~overflow方向@
— `塊-終端$, `行内-終端$ —
がある。
その`初期~scroll位置$は、
`内容-分布~prop$に依存して，`~scrollされる区画$の`原点$に整列されるとは限らないことに注意。
`CSS-ALIGN-3$r `§ ~overflowと~scroll位置＠~CSSALIGN#overflow-scroll-position$
を見よ。
◎
A scrolling box of a viewport or element has two overflow directions, which are the block-end and inline-end directions for that viewport or element. Note that the initial scroll position might not be aligned with the scrolling area origin depending on the content-distribution properties, see CSS Box Alignment 3 § 5.3 Overflow and Scroll Positions.
</p>

<p>
［
`表示域$／要素
］の
`~scrollされる区画@
（ `scrolling area^en ）は、
その`~scrollされる~box$の`~overflow方向$に応じて，各辺が以下に従って与えられる~boxである。
◎
The term scrolling area refers to a box of a viewport or an element that has the following edges, depending on the viewport’s or element’s scrolling box’s overflow directions.
</p>

<div>

<p>
記号
%D1 は［
上方, 下方, 左方, 右方
］いずれかの方向を表し，
%D2 は その反対~方向を表すとする。
`~overflow方向$に %D1 が含まれている（したがって %D2 は含まれていない）ならば、
~boxの［
%D1, %D2
］側の辺は次で与えられる：
</p>

<table><thead>
<tr><th><th>`表示域$に対しては
<th>要素に対しては
<tbody>

<tr><th>%D1 側の辺
<td>
［
`初期~包含塊$の %D1 側の辺, および
`表示域$のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺。
◎
The D1-most edge of the D1 edge of the initial containing block and the D1 margin edge of all of the viewport’s descendants' boxes.
<td>
［
要素の %D1 側の`~padding辺$, および
要素のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺
— ただし，要素の先祖を`包含塊$とするような~boxは除外する††。
◎
The D1-most edge of the element’s D1 padding edge and the D1 margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><th style="white-space:nowrap;">%D2 側の辺

<td>
`初期~包含塊$の %D2 側の辺。
◎
The D2 edge of the initial containing block.
<td>
要素の %D2 側の`~padding辺$。
◎
The element’s D2 padding edge.
</table>

<p class="trans-note">【†
この子孫は、
`~box~tree$における子孫を意味する。
“表示域の子孫~box” が何を意味するのか不明だが、
当の文書の~box~treeを成す~boxすべてが該当すると見受けられる。
】【††
例えば，`~flow外$にある~boxなど。
】【
この箇所は、
原文の内容と等価になるよう，~parameter化により大幅に圧縮して記述している。
】</p>

<div lang="en" class="_en">
<table><thead>
<tr><th>If the overflow directions are…
<th>For a viewport
<th>For an element
<tbody style="white-space:pre-line;">

<tr><td>rightward and downward
<td>top edge
• The top edge of the initial containing block.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left edge of the initial containing block.

<td>top edge
• The element’s top padding edge.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The element’s left padding edge.

<tr><td>leftward and downward
<td>top edge
• The top edge of the initial containing block.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The element’s top padding edge.

right edge
• The element’s right padding edge.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>leftward and upward
<td>top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The element’s right padding edge.

bottom edge
• The element’s bottom padding edge.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>rightward and upward
<td>top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left edge of the initial containing block.

<td>top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The element’s bottom padding edge.

left edge
• The element’s left padding edge.
</table>
</div>
</div>

<p>
`~scrollされる区画$の
`原点@
は、［
`表示域$の`~scrollされる区画$ならば，`初期~包含塊$の原点／
他の場合は，要素の`~scroll位置$が既定の位置にあるときの要素の~padding辺の左上隅
］に~~位置する。
［
~x座標は右方／~y座標は下方
］へ増大する。
◎
The origin of a scrolling area is the origin of the initial containing block if the scrolling area is a viewport, and otherwise the top left padding edge of the element when the element has its default scroll position. The x-coordinate increases rightwards, and the y-coordinate increases downwards. 
</p>

<div class="p">
<p>
［
表示域, または［
~boxあるいは要素
］］の［
`開始辺@
／
`終了辺@
］は、
その`~overflow方向$と［
反対~方向 ／ 同じ方向
］にある辺を指す
（例えば，`~overflow方向$が右方と下方ならば、
開始辺は左辺および上辺, 終了辺は右辺および下辺になる, 等々）。
【ここでも、原文と等価になるよう，圧縮して訳している。】
</p>

◎
The beginning edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The top and left edges.
• If the overflow directions are leftward and downward
•• The top and right edges.
• If the overflow directions are leftward and upward
•• The bottom and right edges.
• If the overflow directions are rightward and upward
•• The bottom and left edges.
◎
The ending edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The bottom and right edges.
• If the overflow directions are leftward and downward
•• The bottom and left edges.
• If the overflow directions are leftward and upward
•• The top and left edges.
• If the overflow directions are rightward and upward
•• The top and right edges.
</div>

<p>
`表示域$には、
`視覚-表示域@
（ `visual viewport^en ）
, 対応する
`~layout表示域@
（ `layout viewport^en ）の 2 種類がある
— 後者は、
前者の`~scrollされる区画$を成す。
◎
The visual viewport is a kind of viewport whose scrolling area is another viewport, called the layout viewport.
</p>

<p>
~scroll法に加え、
`視覚-表示域$の`~layout表示域$には，拡縮-変形も適用され得る。
この変形は、
当の視覚-表示域の`~canvas$に適用され，その内部的な~座標~空間には影響しない。
◎
In addition to scrolling, the visual viewport may also apply a scale transform to its layout viewport. This transform is applied to the canvas of the layout viewport and does not affect its internal coordinate space.
</p>

<p class="note">注記：
視覚-表示域の拡縮-変形は、
“~pinch~zoom” と称されることが多い†。
この変形は、
概念的に，~CSS`基準~pixel$の~sizeを変更するが，
~layout表示域の~sizeを
— ~pageの内容を~flowし直すことなく —
`proportional^en に変更する††。
◎
Note: The scale transform of the visual viewport is often referred to as "pinch-zoom". Conceptually, this transform changes the size of the CSS reference pixel but changes the size of the layout viewport proportionally so that it does not cause reflow of the page’s contents.
</p>

<p class="trans-note">【†
“局所的” な~zoom。
おそらく、［
複~touch機器の~UIで利用される，二本指で “つまんで” 拡げる~~操作
］に由来する呼称。
】【††
“~~拡大鏡” のように、
`~box~tree$を成す すべての`~box$にわたって，同じ倍率で。
】</p>

<p>
この拡縮-変形の倍率は、
`視覚-表示域$の
`拡縮率@vV
（ `scale factor^en ）と称される。
◎
The magnitude of the scale transform is known as the visual viewport’s scale factor.
</p>

<div class="example">
<p id="example-vvanimation">
この例は、
ある~zoomされた視覚-表示域が，
（例えば，~touch~dragを遂行している利用者により）
“~panされる” 様子を~animationで示す。
~pageは、
`~layout表示域$が`視覚-表示域$より大きくなるよう拡縮されている。
◎
This animation shows an example of a zoomed in visual viewport being "panned" around (for example, by a user performing a touch drag). The page is scaled so that the layout viewport is larger than the visual viewport.
</p>

<p>
~scroll差分は、
まず，当の`視覚-表示域$に適用される。
視覚-表示域の~~限界まで来たときは、
~scroll差分は，当の`~layout表示域$に適用されることになる。
この挙動は、
`表示域の~scrollを遂行する$手続きにより実装される。
◎
A scroll delta is applied to the visual viewport first. When the visual viewport is at its extent, scroll delta will be applied to the layout viewport. This behavior is implemented by the perform a scroll steps.
</p>

<figure>
<figcaption>
この挙動をデモる~animation
— 下の~box内のどこでも，~clickする度に［
再開-（開始-）／静止-
］される。
</figcaption>
<div id="_vvanimation" class="_paused">
文書
	<div id="_lv">~layout表示域</div>
	<div id="_vv">視覚-表示域</div>
</div>
</figure>
</div>

<p>
◎
↓↓§ VisualViewport
The VisualViewport object has an associated document, which is a Document object. It is the associated document of the owner Window of VisualViewport. The layout viewport is the owner Window's viewport.
</p>

<p>
この仕様の要件の目的においては、
`display$p ~propの算出d値が［
`table-column$v ／ `table-column-group$v
］になる要素は、
（［
~col／~col~group
］の）`~box$を持つと見なすモノトスル。
◎
For the purpose of the requirements in this specification, elements that have a computed value of the display property that is table-column or table-column-group must be considered to have an associated box (the column or column group, respectively).
</p>

<p>
用語
`~SVG~layout~box@
は
ある~SVG要素により生成される`~box$を指す
— それは、
~CSSにより定義される`表示~型$【！ `display$p 】には対応しない。
（ `rect$e 要素により生成される~boxなど。）
◎
The term SVG layout box refers to a box generated by an SVG element which does not correspond to a CSS-defined display type. (Such as the box generated by a rect element.)
</p>

<p>
用語
`変形@
は、［
~SVG／~CSS
］による変形（座標系変換）を指す。
`SVG11$r
`CSS-TRANSFORMS-1$r
◎
The term transforms refers to SVG transforms and CSS transforms. [SVG11] [CSS-TRANSFORMS-1]
</p>

<p>
［
~IDL~method／属性
］（以下，単に “~member” ）から別の~memberが呼ばれるときは、
~UAは，~memberの内部~APIを呼出すモノトスル
— すなわち、
作者は［
~custom ECMAScript ~propや関数で上書きして，~memberの挙動を変更する
］ことはできない。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
他が指定されない限り、
文字列は【！is】`一致する$かどうかにより比較される。
◎
Unless otherwise stated, all string comparisons use is.
</p>

		<section id="css-pixels">
<h3 title="CSS pixels">2.1. ~CSS~pixel</h3>

<p>
他が指定されない限り、
この仕様で定義される~API用の［
座標, 寸法
］は，すべて`~CSS~pixel＠~CSSVAL#px$単位とする。
`CSS-VALUES$r
【この訳では、 “`px$u 単位” と略記する。】
◎
All coordinates and dimensions for the APIs defined in this specification are in CSS pixels, unless otherwise specified. [CSS-VALUES]
</p>

<p class="note">注記：
このことは、
例えば `matchMedia()^m には該当しない。
そのような所では、
単位は明示的に与えられる。
◎
Note: This does not apply to e.g. matchMedia() as the units are explicitly given there.
</p>

		</section>
		<section id="zooming">
<h3 title="Zooming">2.2. ~zoom法</h3>

<p>
~zoomには 2 種類ある：
`~page~zoom@
は、
初期~表示域の~sizeに影響する
【例：文字を大きく表示させたときなど】
。
`視覚-表示域$の`拡縮率$vVは、
~~拡大鏡のように動作して，初期~表示域や実際の表示域には影響しない。
`CSS-DEVICE-ADAPT$r
◎
There are two kinds of zoom, page zoom which affects the size of the initial viewport, and the visual viewport scale factor which acts like a magnifying glass and does not affect the initial viewport or actual viewport. [CSS-DEVICE-ADAPT]
</p>

<p class="note">注記：
拡縮率は， “~pinch~zoom” と称されることが多いが、
~pinch~zoomする以外の手段を通しても影響され得る。
例：~UAは、
~focusされた入力~要素が判読可能になるよう~zoomすることもある。
◎
Note: The "scale factor" is often referred to as "pinch-zoom"; however, it can be affected through means other than pinch-zooming. e.g. The user agent may zooms in on a focused input element to make it legible.
</p>

		</section>
		<section id="web-exposed-screen-information">
<h3 title="Web-exposed screen information">2.3. ~Webに公開される~screen情報</h3>

<p>
~UAは、
利用者の~privacyを保護するためとして，［
出力~機器の~screenについての情報を隠す
］ことを選んでもヨイ。
各種~APIにわたって一貫した方式でそうするため、
この仕様は，以下の区画を表す用語を定義する。
これらの各~区画は、
いずれも［
有限な ( 横幅, 縦幅 ) がある ／
左上隅を原点にとる ／
~x座標は右方に増大する ／
~y座標は下方に増大する ／
座標の単位は `px$u
］とする：
◎
User agents may choose to hide information about the screen of the output device, in order to protect the user’s privacy. In order to do so in a consistent manner across APIs, this specification defines the following terms, each having a width and a height, the origin being the top left corner, and the x- and y-coordinates increase rightwards and downwards, respectively.
</p>

<ul>
	<li>
`~Webに公開される~screen区画@
— 次のうち，いずれかになるとする
⇒＃
出力~機器の区画／
`表示域$の区画
◎
The Web-exposed screen area is one of the following:
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
	<li>
`~Webに公開される可用な~screen区画@
— 次のうち，いずれかになるとする
⇒＃
出力~機器の描画面として可用な区画／
出力~機器の区画／
`表示域$の区画／
◎
The Web-exposed available screen area is one of the following:
• The available area of the rendering surface of the output device, in CSS pixels.
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
</ul>

		</section>
	</section>
	<section id="common-infrastructure">
<h2 title="Common Infrastructure">3. 共通基盤</h2>

<p>
この仕様は WHATWG Infra 標準に依存する。
`INFRA$r
◎
This specification depends on the WHATWG Infra standard. [INFRA]
</p>

		<section id="scrolling">
<h3 title="Scrolling">3.1. ~scroll法</h3>

<div class="algo">
<p>
`~scrollを遂行する@
ときは、
所与の
( `~scrollされる~box$ %~box, %目的位置, %~assoc要素, %挙動 （省略時は `auto$l ） )
に対し，次を走らす：
◎
When a user agent is to perform a scroll of a scrolling box box, to a given position position, an associated element element and optionally a scroll behavior behavior (which is "auto" if omitted), the following steps must be run:
</p>
<ol>
	<li>
~IF［
%~box において`滑らかな~scroll$は進行中である
］
⇒
それを`中止-$sSする
◎
Abort any ongoing smooth scroll for box.
</li>
	<li>
<p>
~IF［
~UAは， `scroll-behavior$p ~propを尊守する†
］~AND［
~OR↓
］…
◎
If the user agent honors the scroll-behavior property and one of the following are true:
</p>
		<ul>
			<li>
［
%挙動 ~EQ `auto$l
］~AND［
%~assoc要素 ~NEQ ~NULL
］~AND［
%~assoc要素 の `scroll-behavior$p ~propの算出d値 ~EQ `smooth$v
］
◎
behavior is "auto" and element is not null and its computed value of the scroll-behavior property is smooth
</li>
			<li>
%挙動 ~EQ `smooth$l
◎
behavior is smooth
</li>
		</ul>

<p class="trans-note">【†
尊守する（ `honor^en ）
— ［
当の特能は、
~UAが~supportしていて，（環境設定などにより）可能化されてもいる
］ことを意味すると見受けられる。
】</p>

<p>
…ならば
⇒＃
%~box を %目的位置 へ`滑らかに~scrollする$
◎
...then perform a smooth scroll of box to position.＼
↓Once the position has finished updating, emit the scrollend event.＼
</p>
	</li>
	<li>
~ELSE
⇒＃
%~box を %目的位置 へ`瞬時に~scrollする$
◎
Otherwise, perform an instant scroll of box to position.＼
↓After an instant scroll emit the scrollend event.
</li>
	<li>
<p>
上の段による~scrollを`完了-$したなら、
`scrollend$et ~eventを発する【ようにしておく】
◎
↑</p>

<p class="note">注記：
`behavior$mb に `instant$l を与えた場合、
この~algoにより，常に瞬時な~scrollが遂行される。
◎
Note: behavior: "instant" always performs an instant scroll by this algorithm.
</p>

<p class="note">注記：
［
利用者のヤリトリ／~program的な呼出n
］の結果，`~scroll位置$が変化せず, 適用される並進は無かった場合、
~scrollは生じないので，
`scrollend$et ~eventは発火されない。
◎
Note: If the scroll position did not change as a result of the user interaction or programmatic invocation, where no translations were applied as a result, then no scrollend event fires because no scrolling occured.
</p>
	</li>
</ol>
</div>


<div class="algo">
<p>
`表示域の~scrollを遂行する@
ときは、
所与の
( `表示域$ %表示域, 位置 %目的位置, ~scrollの挙動 %挙動 （省略時は `auto$l ） )
に対し，次の手続きにより協調された表示域~scroll
【視覚-表示域, ~layout表示域に対する協調された~scroll】
を遂行するモノトスル：
`VisualViewport^I1
◎
When a user agent is to perform a scroll of a viewport to a given position position and optionally a scroll behavior behavior (which is "auto" if omitted) it must perform a coordinated viewport scroll by following these steps:
</p>
<ol>
	<li>
%文書 ~LET %表示域 に結付けられている`文書$
◎
Let doc be the viewport’s associated Document.
</li>
	<li>
%vv ~LET 次を満たす `VisualViewport$I ~obj
【該当するものは、一つだけ在ることになる】
⇒
その`文書$vV ~EQ %文書
◎
Let vv be the VisualViewport whose associated document is doc.
</li>
	<li>
%最大~x ~LET %表示域 の`~scrollされる~box$の横幅 ~MINUS %vv の `width$m1 属性の値
◎
Let maxX be the difference between viewport’s scrolling box’s width and the value of vv’s width attribute.
</li>
	<li>
%最大~y ~LET %表示域 の`~scrollされる~box$の縦幅 ~MINUS %vv の`height$m1 属性の値
◎
Let maxY be the difference between viewport’s scrolling box’s height and the value of vv’s height attribute.
</li>
	<li>
%~dx ~LET %目的位置 の~x成分 ~MINUS %vv の `pageLeft$m1 属性の値
◎
Let dx be the horizontal component of position - the value vv’s pageLeft attribute
</li>
	<li>
%~dy ~LET %目的位置 の~y成分 ~MINUS %vv の `pageTop$m1 属性の値
◎
Let dy be the vertical component of position - the value of vv’s pageTop attribute
</li>
	<li>
%視覚-~x ~LET %vv の `offsetLeft$m1 属性の値
◎
Let visual x be the value of vv’s offsetLeft attribute.
</li>
	<li>
%視覚-~y ~LET %vv の `offsetTop$m1 属性の値
◎
Let visual y be the value of vv’s offsetTop attribute.
</li>
	<li>
%視覚-~dx ~LET `min^op( %最大~x, `max^op( 0, %視覚-~x ~PLUS %~dx )) ~MINUS %視覚-~x
◎
Let visual dx be min(maxX, max(0, visual x + dx)) - visual x.
</li>
	<li>
%視覚-~dy ~LET `min^op( %最大~y, `max^op( 0, %視覚-~y ~PLUS %~dy )) ~MINUS %視覚-~y
◎
Let visual dy be min(maxY, max(0, visual y + dy)) - visual y.
</li>
	<li>
%~layout~dx ~LET %~dx ~MINUS %視覚-~dx
◎
Let layout dx be dx - visual dx
</li>
	<li>
%~layout~dy ~LET %~dy ~MINUS %視覚-~dy
◎
Let layout dy be dy - visual dy
</li>
	<li>
%要素 ~LET %文書 の`根~要素$は［
在るならば それ／
無いならば ~NULL
］
◎
Let element be doc’s root element if there is one, null otherwise.
</li>
	<li>
`~scrollを遂行する$( ↓ )
⇒＃
%表示域 の`~scrollされる~box$,
%表示域 の`~scroll位置$ ~PLUS ( %~layout~dx, %~layout~dy ),
%要素,
%挙動
◎
Perform a scroll of the viewport’s scrolling box to its current scroll position + (layout dx, layout dy) with element as the associated element, and behavior as the scroll behavior.
</li>
	<li>
`~scrollを遂行する$( ↓ )
⇒＃
%vv の`~scrollされる~box$, 
%vv の`~scroll位置$ ~PLUS ( %視覚-~dx, %視覚-~dy ),
%要素,
%挙動
◎
Perform a scroll of vv’s scrolling box to its current scroll position + (visual dx, visual dy) with element as the associated element, and behavior as the scroll behavior.
</li>
</ol>
</div>

<p class="note">注記：
概念的には、
`視覚-表示域$は，`~layout表示域$の辺に “ぶつかる” 所まで~scrollされ、
そこから［
~layout表示域に~scroll差分を適用する
］ことにより，~layout表示域を “押し出す” 。
しかしながら，上の手続きにおける~scrollは、［
~layout表示域が視覚-表示域より前に~scrollされる
］よう，事前に算出され，逆順に適用される。
これは、
歴史的な理由により，
~scroll~eventの一貫した順序付けを確保するために行われる。
視覚的な図画化は、
`上の例＠#example-vvanimation$を見よ。
◎
Note: Conceptually, the visual viewport is scrolled until it "bumps up" against the layout viewport edge and then "pushes" the layout viewport by applying the scroll delta to the layout viewport. However, the scrolls in the steps above are computed ahead of time and applied in the opposite order so that the layout viewport is scrolled before the visual viewport. This is done for historical reasons to ensure consistent scroll event ordering. See the example above for a visual depiction.
</p>

<div class="example">
<p>
利用者は［
文書のある箇所を~pinch~zoomして，そこで~mouse~wheelを回す
］ことで［
文書を `50px^v 下へ~scrollする
］よう~UAに要請しているが，［
文書は~pinch~zoomされたので、
`視覚-表示域$は `20px^v までしか~scrollできない
］とする。
~UAは、［
視覚-表示域を `20px^v,
`~layout表示域$を `30px^v
］下へ~scrollするよう分配することになる。
◎
The user pinch-zooms into the document and ticks their mouse wheel, requesting the user agent scroll the document down by 50px. Because the document is pinch-zoomed in, the visual viewport has 20px of room to scroll. The user agent distributes the scroll by scrolling the visual viewport down by 20px and the layout viewport by 30px.
</p>
</div>

<div class="example">
<p>
携帯機~UAの利用者が，文書~内の~screen外にある~text入力~要素を~focusした結果、
~virtual~keyboardが示され，`視覚-表示域$が縮短されたとする。
~UAは、
当の要素が視覚-表示域に入るよう，要素を~viewの中へ持ち込む必要がある。
~UAは、［
要素が~viewの中で可視になるよう，`~layout表示域$を~scrollして
］から［
要素が利用者に可視になるよう，視覚-表示域を~scrollする
］ことになる。
◎
The user is viewing a document in a mobile user agent. The document focuses an offscreen text input element, showing a virtual keyboard which shrinks the visual viewport. The user agent must now bring the element into view in the visual viewport. The user agent scrolls the layout viewport so that the element is visible within it, then the visual viewport so that the element is visible to the user.
</p>
</div>

<div class="p">
<p>
~scrollが
`完了-@
したとされるのは、
次の両者が満たされる時点である：
</p>
<ul>
	<li>
<p>
処理待ちな［
`~scroll位置$の［
更新や並進
］］は無くなった。
これは、
次に挙げるものにより［
`滑らかに~scrollする$／`瞬時に~scrollする$†
］ときを含む
⇒＃
~mouse~wheel／
~keyboard／
~scroll留め~event【`参照＠~CSSSCROLLSNAP#snap-concepts$】／
`~scroll位置$を［更新する, あるいは場合によっては補間する］原因になる，他の~APIや~gesture
</p>

<p class="trans-note">【†
瞬時に~scrollすることは，
（意味論的には）同期的な処理nに見える（`完了-$の定義には不要に見える）が、
~UAが`描画を更新する段$までは， “処理待ち” になる
（対して，滑らかに~scrollするときは、
完了するまで，この段を複数回~経ることになる）。
】</p>
	</li>
	<li>
利用者による~gestureは完了した。
［
~touchにより~panする／~trackpadにより~scrollする
］様な~gestureは、
~pointerや~UIkeyが解放されるまでは完了しないとする。
</li>
</ul>
◎
Scroll is completed when the scroll position has no more pending updates or translations and the user has completed their gesture. Scroll position updates include smooth or instant mouse wheel scrolling, keyboard scrolling, scroll-snap events, or other APIs and gestures which cause the scroll position to update and possibly interpolate. User gestures like touch panning or trackpad scrolling aren’t complete until pointers or keys have released.
</div>

<div class="algo">
<p>
`~scrollされる~box$ %~box を %目的位置 へ
`滑らかに~scrollする@
ときは：
</p>

<ul>
	<li>
~UAが定義する~~速度, ~~動きにより， %~box の`~scroll位置$を更新するモノトスル。
</li>
	<li>
~scrollの
`完了-@sS
時には、
%~box の`~scroll位置$は %目的位置 になるモノトスル。
</li>
	<li>
この~scrollは、
~algoまたは利用者により
`中止-@sS
され得る。
</li>
</ul>
◎
When a user agent is to perform a smooth scroll of a scrolling box box to position, it must update the scroll position of box in a user-agent-defined fashion over a user-agent-defined amount of time. When the scroll is completed, the scroll position of box must be position. The scroll can also be aborted, either by an algorithm or by the user.
</div>

<div class="algo">
<p>
`~scrollされる~box$ %~box を %目的位置 へ
`瞬時に~scrollする@
ときは
⇒
%~box の`~scroll位置$を %目的位置 に更新する
◎
When a user agent is to perform an instant scroll of a scrolling box box to position, it must update the scroll position of box to position.
</p>
</div>

<div class="algo">
<p>
`文書の開始位置に~scrollする@
ときは、所与の
( 文書 %文書 )
に対し，次を走らす：
◎
To scroll to the beginning of the document for a document document, follow these steps:
</p>

<ol>
	<li>
%表示域 ~LET %文書 に結付けられている`表示域$
◎
Let viewport be the viewport that is associated with document.
</li>
	<li>
%目的位置 ~LET
%表示域 の`開始辺$が`~scrollされる区画$の`開始辺$に整列されたときに %表示域 がとる，`~scroll位置$
◎
Let position be the scroll position viewport would have by aligning the beginning edges of the scrolling area with the beginning edges of viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の`~scroll位置$
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as viewport’s current scroll position, and viewport does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`表示域の~scrollを遂行する$( %表示域, %目的位置 【！, document’s root element】 )
◎
Perform a scroll of viewport to position, and document’s root element as the associated element, if there is one, or null otherwise.
</li>
</ol>

<p class="note">注記：
この~algoは、
`HTML$r に定義されるとおり，
素片~識別子 `#top^c へ`~navigateする＠~HTMLnav#navigate-fragid$ときに利用される。
【すなわち，文書~内の`指示された部位＠~HTMLnav#the-indicated-part-of-the-document$は、文書の上端になる。】
◎
Note: This algorithm is used when navigating to the #top fragment identifier, as defined in HTML. [HTML]
</p>
</div>

		</section>
		<section id="webidl-values">
<h3 title="WebIDL values">3.2. ~Web~IDL値</h3>

<div class="algo">
<p>
`有限~値に正規化する@
ときは、所与の
( 値 %n )
に対し：
</p>
<ol>
	<li>
~IF［
%n は［
特別な浮動小数点~literal値（ `Infinity^I ／ `-Infinity^c ／ `NaN^I ） `WEBIDL$r
］である
］
⇒
~RET 0
</li>
	<li>
~RET %n
</li>
</ol>
◎
When asked to normalize non-finite values for a value x, if x is one of the three special floating point literal values (Infinity, -Infinity or NaN), then x must be changed to the value 0. [WEBIDL]
</div>

		</section>
	</section>
	<section id="extensions-to-the-window-interface">
<h2 title="Extensions to the Window Interface">4. `Window^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollBehavior@I { `auto@l, `instant@l, `smooth@l };

dictionary `ScrollOptions@I {
  `ScrollBehavior$I `behavior@mb = `auto$l;
};

dictionary `ScrollToOptions@I : `ScrollOptions$I {
  `unrestricted double$ `left@mb;
  `unrestricted double$ `top@mb;
};
</pre>

<pre class="idl">
partial interface `Window$I {`Window^I0
  [`NewObject$] `MediaQueryList$I `matchMedia$m(`CSSOMString$ %query);
  [`SameObject$, `Replaceable$] readonly attribute `Screen$I `screen$m;
  [`SameObject$, `Replaceable$] readonly attribute `VisualViewport$I? `visualViewport$m;

  // <span class="comment">閲覧~文脈</span>
  `undefined$ `moveTo$m(`long$ %x, `long$ %y);
  `undefined$ `moveBy$m(`long$ %x, `long$ %y);
  `undefined$ `resizeTo$m(`long$ %width, `long$ %height);
  `undefined$ `resizeBy$m(`long$ %x, `long$ %y);

  // <span class="comment">表示域</span>
  [`Replaceable$] readonly attribute `long$ `innerWidth$m;
  [`Replaceable$] readonly attribute `long$ `innerHeight$m;

  // <span class="comment">表示域の~scroll法</span>
  [`Replaceable$] readonly attribute `double$ `scrollX$m;
  [`Replaceable$] readonly attribute `double$ `pageXOffset$m;
  [`Replaceable$] readonly attribute `double$ `scrollY$m;
  [`Replaceable$] readonly attribute `double$ `pageYOffset$m;
  `undefined$ `scroll$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scroll$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollTo$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollTo$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollBy$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollBy$m(`unrestricted double$ %x, `unrestricted double$ %y);

  // <span class="comment">~client~UIwindow</span>
  [`Replaceable$] readonly attribute `long$ `screenX$m;
  [`Replaceable$] readonly attribute `long$ `screenLeft$m;
  [`Replaceable$] readonly attribute `long$ `screenY$m;
  [`Replaceable$] readonly attribute `long$ `screenTop$m;
  [`Replaceable$] readonly attribute `long$ `outerWidth$m;
  [`Replaceable$] readonly attribute `long$ `outerHeight$m;
  [`Replaceable$] readonly attribute `double$ `devicePixelRatio$m;
};
</pre>

`Window^dgm

<div class="algo">
`matchMedia(query)@m
~method手続きは
⇒
~RET 次のように設定された，新たな `MediaQueryList$I ~obj
⇒＃
`媒体~query~list$mq ~SET `媒体~query~listとして構文解析する$( %query ),
`文書$mq ~SET コレに`結付けられている文書$
◎
When the matchMedia(query) method is invoked these steps must be run:
◎
Let parsed media query list be the result of parsing query.
◎
Return a new MediaQueryList object, with this's associated Document as the document, with parsed media query list as its associated media query list.
</div>

<div class="algo">
<p>
`screen@m
取得子~手続きは
⇒
~RET コレに結付けられている `Screen$I ~obj
◎
The screen attribute must return the Screen object associated with the Window object.
</p>

<p class="note">注記：
`WindowProxy$I ~objを通した `screen^c への~accessでは、
`文書$が~navigateされたときには，異なる結果が得られ得る。
◎
Note: Accessing screen through a WindowProxy object might yield different results when the Document is navigated.
</p>
</div>

<div class="algo">
<div>
<p>
`visualViewport@m
取得子~手続きは：
</p>
<ol>
	<li>
%文書 ~LET コレに`結付けられている文書$
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 を結付けている `VisualViewport$I ~obj
</li>
</ol>

◎
If the associated document is fully active, the visualViewport attribute must return the VisualViewport object associated with the Window object’s associated document. Otherwise, it must return null.
</div>

<p class="note">注記：
`VisualViewport$I ~objが［
返される／有用になる
］のは、
%文書 が現在~呈示されている【`全部的に作動中$である】間に限られる。
`VisualViewport^I ~objへの参照が【~scriptにより】維持されていても、
%文書 は現在~呈示されていない場合，
この~obj内の値【各~member】は当の閲覧~文脈についての情報を露呈しないモノトスル
【この要件の詳細は、 `VisualViewport^I の各~member定義を見よ】。
◎
Note: the VisualViewport object is only returned and useful for a window whose Document is currently being presented. If a reference is retained to a VisualViewport whose associated Document is not being currently presented, the values in that VisualViewport must not reveal any information about the browsing context.
</p>
</div>

<div class="algo">
<p>
`moveTo(x, y)@m
~method手続きは：
◎
The moveTo(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の外側に~UIwindowが出ない大きさ
］に切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
	<li>
%target の~UIwindowを，その左上隅が［
出力~機器の左上隅から相対的な［
%target の `px$u 単位による座標 (%x, %y) 
］］に整列するよう移動する。
ここで，各~座標軸の正方向は［
右方, 下方
］とする。
◎
Move target’s window such that the window’s top left corner is at coordinates (x, y) relative to the top left corner of the output device, measured in CSS pixels of target. The positive axes are rightward and downward. 
</li>
</ol>
</div>

<div class="algo">
<p>
`moveBy(x, y)@m
~method手続きは：
◎
The moveBy(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の外側に~UIwindowが出ない大きさ
］に切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
	<li>
%target の~UIwindowを，
%target の `px$u 単位で［
右方に %x, 下方に %y
］だけ移動する
◎
Move target’s window x CSS pixels of target rightward and y CSS pixels of target downward.
</li>
</ol>
</div>

<div class="algo">
<p>
`resizeTo(width, height)@m
~method手続きは：
◎
The resizeTo(width, height) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
［
%width, %height
］を［
可用な空間の中で~UIwindowの大きさが~~適度な［
上限, 下限
］に収まる
］よう切詰める
◎
Optionally, clamp width and height in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
	<li>
%target の~UIwindowを~resizeする
— ［
%width, %height は %target の `px$u 単位の値を表す
］とする下で，~UIwindowの［
右辺, 下辺
］を次を満たすように移動する
⇒
［
表示域の左辺と右辺の距離 ~EQ %width
］~AND［
表示域の上辺と下辺の距離 ~EQ %height
］
◎
Resize target’s window by moving its right and bottom edges such that the distance between the left and right edges of the viewport are width CSS pixels of target and the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%target の~UIwindowを，可用な空間をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
</ol>
</div>

<div class="algo">
<p>
`resizeBy(x, y)@m
~method手続きは：
◎
The resizeBy(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の中で~UIwindowの大きさが~~適度な［
上限, 下限
］に収まる
］よう切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
	<li>
%target の~UIwindowを，~resizeする
— その右辺と下辺を %target の `px$u 単位で［
左辺を %x,
上辺を %y
］だけ移動する
◎
Resize target’s window by moving its right edge x CSS pixels of target rightward and its bottom edge y CSS pixels of target downward.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%target の~UIwindowを，可用な空間をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`innerWidth@m ｜ `innerHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`表示域$の［
横幅 ｜ 縦幅
］（~scrollbarが描画されている場合はその~sizeも含める）
</li>
</ol>

<div class="example">
<p>
次の~code片は、
表示域の横幅を得する方法を示す：
</p>

<pre class="lang-js">
var %viewportWidth = innerWidth
</pre>
</div>

◎
The innerWidth attribute must return the viewport width including the size of a rendered scroll bar (if any), or zero if there is no viewport.
◎
The following snippet shows how to obtain the width of the viewport:
• var viewportWidth = innerWidth
◎
The innerHeight attribute must return the viewport height including the size of a rendered scroll bar (if any), or zero if there is no viewport.
</div>

<div class="algo">
<p>
［
`scrollX@m ｜ `scrollY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`初期~包含塊$の原点に相対的な，`表示域$の［
左端の~x座標 ｜ 上端の~y座標
］
</li>
</ol>
◎
The scrollX attribute must return the x-coordinate, relative to the initial containing block origin, of the left of the viewport, or zero if there is no viewport.
◎
The pageXOffset attribute must return the value returned by the scrollX attribute.
◎
The scrollY attribute must return the y-coordinate, relative to the initial containing block origin, of the top of the viewport, or zero if there is no viewport.
◎
The pageYOffset attribute must return the value returned by the scrollY attribute.
</div>

<div class="algo">
［
`pageXOffset@m ｜ `pageYOffset@m
］取得子~手続きは、［
`scrollX$m ｜ `scrollY$m
］取得子~手続きと同じに挙動する。
◎
↑</div>

<div class="algo">
<p>
`scroll()@m
~method手続きは：
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x )
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y )
</li>
	<li>
`~window用の~scroll手続き$( コレ, %x, %y, %behavior )
</li>
</ol>
◎
When the scroll() method is invoked these steps must be run:
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Let x be the value of the left dictionary member of options, if present, or the viewport’s current scroll position on the x axis otherwise.
• Let y be the value of the top dictionary member of options, if present, or the viewport’s current scroll position on the y axis otherwise.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
◎
Normalize non-finite values for x and y.
◎
↓
</div>

<div class="algo">
<p class="trans-note">【
この訳では、
原文による `scroll()$m ~method手続きを成す引数の取扱い以外の部分を，
次に与える手続きに分離する
— それは、
複数の箇所から共通して利用されるので。
】</p>

<p>
`~window用の~scroll手続き@
は、所与の
( %window, %x, %y, %behavior )
に対し：
◎
↑</p>
<ol>
	<li>
~IF［
%window の`表示域$は無い
］
⇒
~RET
◎
If there is no viewport, abort these steps.
</li>
	<li>
%表示域 ~LET %window の`表示域$
</li>
	<li class="algo">
<p>
%座標 ~LET 次の手続きを走らせた結果：
</p>
		<ol>
			<li>
~IF［
%x ~EQ ε
］
⇒
%x ~SET `表示域$の現在の~x軸 `~scroll位置$
</li>
			<li>
~IF［
%y ~EQ ε
］
⇒
%y ~SET `表示域$の現在の~y軸 `~scroll位置$
</li>
			<li>
%~scrollされる区画 ~LET %表示域 の`~scrollされる区画$
</li>
			<li>
%符号 ~LET %表示域 の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
</li>
			<li>
%x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %x, ( %~scrollされる区画 の横幅 ~MINUS %表示域 の`有効~横幅$ )))
</li>
			<li>
%符号 ~LET %表示域 の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
</li>
			<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, ( %~scrollされる区画 の縦幅 ~MINUS %表示域 の`有効~縦幅$ )))
</li>
			<li>
~RET ( %x, %y )
</li>
		</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any.
◎
Let viewport height be the height of the viewport excluding the height of the scroll bar, if any.
◎
If the viewport has rightward overflow direction
• Let x be max(0, min(x, viewport scrolling area width - viewport width)).
◎
If the viewport has leftward overflow direction
• Let x be min(0, max(x, viewport width - viewport scrolling area width)).
◎
If the viewport has downward overflow direction
• Let y be max(0, min(y, viewport scrolling area height - viewport height)).
◎
If the viewport has upward overflow direction
• Let y be min(0, max(y, viewport height - viewport scrolling area height)).
</li>
	<li>
%目的位置 ~LET %~scrollされる区画 の座標 %座標 が %表示域 の左上隅に整列されるような， %表示域 の`~scroll位置$
◎
Let position be the scroll position the viewport would have by aligning the x-coordinate x of the viewport scrolling area with the left of the viewport and aligning the y-coordinate y of the viewport scrolling area with the top of the viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の`~scroll位置$
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as the viewport’s current scroll position, and the viewport does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
<p>
`表示域の~scrollを遂行する$( %表示域, %目的位置 【！, document】, %behavior )
◎
（不要）Let document be the viewport’s associated Document.
◎
Perform a scroll of the viewport to position, document’s root element as the associated element, if there is one, or null otherwise, and the scroll behavior being the value of the behavior dictionary member of options.
</p>

<p class="issue">
各~UAは、
これが［
`~layout表示域$の`~scrollされる~box$に対し，次のどちらを利用する
］か合意していない
⇒
`表示域$に対する（協調された）`表示域の~scrollを遂行する$／
`~scrollされる~box$に対し`~scrollを遂行する$
◎
User agents do not agree whether this uses the (coordinated) viewport perform a scroll or the scrolling box perform a scroll on the layout viewport’s scrolling box.
</p>
	</li>
</ol>
</div>

<div class="algo">
`scrollTo()@m
~method手続きは、
`scroll()$m ~method手続きと同じに挙動する。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</div>

<div class="algo">
<p>
`scrollBy()@m
~method手続きは：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x ) ~PLUS コレの `scrollX$m 取得子~手続き()
◎
Normalize non-finite values for the left and top dictionary members of options.
◎
Add the value of scrollX to the left dictionary member.
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y ) ~PLUS コレの `scrollY$m 取得子~手続き()
◎
↑
◎
Add the value of scrollY to the top dictionary member.
</li>
	<li>
`~window用の~scroll手続き$( コレ, %x, %y, %behavior )
◎
Act as if the scroll() method was invoked with options as the only argument.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`screenX@m ｜ `screenY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
	<li>
~RET
出力~機器の`~Webに公開される~screen区画$の原点に相対的な,  `px$u 単位による，~client~UIwindow†の［
左端の~x座標 ｜ 上端の~y座標
］
</li>
</ol>

<p class="trans-note">【†
“~client~UIwindow” がどの部分を指すのか，定義されていないが、
現実の~browserのふるまいからは，外枠も含めた~UIwindow全体が占める区画を指すものと推定される。
】</p>

◎
The screenX and screenLeft attributes must return the x-coordinate, relative to the origin of the Web-exposed screen area, of the left of the client window as number of CSS pixels, or zero if there is no such thing.
◎
The screenY and screenTop attributes must return the y-coordinate, relative to the origin of the screen of the Web-exposed screen area, of the top of the client window as number of CSS pixels, or zero if there is no such thing.
</div>

<div class="algo">
［
`screenLeft@m ｜ `screenTop@m
］取得子~手続きは、［
`screenX$m ｜ `screenY$m
］取得子~手続きと同じに挙動する。
◎
↑</div>

<div class="algo">
<p>
［
`outerWidth@m ｜ `outerHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
	<li>
~RET ~client~UIwindowの［
横幅 ｜ 縦幅
］
</li>
</ol>
◎
The outerWidth attribute must return the width of the client window. If there is no client window this attribute must return zero.
◎
The outerHeight attribute must return the height of the client window. If there is no client window this attribute must return zero.
</div>

<div class="algo">
`devicePixelRatio@m
取得子~手続きは
⇒
~RET `機器~pixel比を決定する$()
◎
The devicePixelRatio attribute must return the result of＼
</div>

<div class="algo">
<p>
`機器~pixel比を決定する@
ときは：
◎
the following determine the device pixel ratio algorithm:
</p>

<ol>
	<li>
~IF［
出力~機器は無い
］
⇒
~RET 1
◎
If there is no output device, return 1 and abort these steps.
</li>
	<li>
%~CSS~pixel~size ~LET 1 `px$u の~size
— 現在の`~page~zoom$の下で，`拡縮率$vV 1.0 を利用している下での
◎
Let CSS pixel size be the size of a CSS pixel at the current page zoom and using a scale factor of 1.0.
</li>
	<li>
%機器~pixel~size ~LET 出力~機器の機器~pixelの縦~size
◎
Let device pixel size be the vertical size of a device pixel of the output device.
</li>
	<li>
~RET %~CSS~pixel~size ~DIV %機器~pixel~size
◎
Return the result of dividing CSS pixel size by device pixel size.
</li>
</ol>
</div>

		<section id="the-features-argument-to-the-open()-method">
<h3 title="The features argument to the open() method">4.1. `open()^m ~methodに対する %features 引数</h3>

<p>
~HTMLは、
~windowの `open()$m ~method
【および，文書の `~doc-open()$m ~method】
を定義している。
この節では、
その %features 引数にて与えられる位置と~sizeの挙動を定義する。
`HTML$r
◎
HTML defines the open() method. This section defines behavior for position and size given in the features argument. [HTML]
</p>

<div class="algo">
<p>
`閲覧~文脈の特能を設定しておく@
ときは、所与の
(
`閲覧~文脈$ %target,
（ %features 引数から導出された）`~map$ %特能~map
)
に対し，次を走らす：
◎
To set up browsing context features for a browsing context target given a map tokenizedFeatures:
</p>

<ol>
	<li>
%~pixel単位 ~LET %target における `px$u 単位
◎
↓</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
%可用な~screen ~LET `~Webに公開される可用な~screen区画$
◎
↓</li>
	<li>
%~screen ~LET `~Webに公開される~screen区画$
◎
↓</li>
	<li>
%正規化-済み~map ~LET 新たな`~map$
◎
↓</li>
	<li>
<p>
~EACH( %名前 ~IN { `left$opf, `top$opf, `width$opf, `height$opf } )
に対し：
</p>
		<ol>
			<li>
%値 ~LET %特能~map[ %名前 ]
</li>
			<li>
~IF［
%値 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
%値 ~SET `整数として構文解析する$( %値 )
</li>
			<li>
~IF［
%値 ~EQ `失敗^i
］
⇒
%値 ~SET 0
</li>
			<li>
%正規化-済み~map[ %名前 ] ~SET %値
</li>
		</ol>
◎
↓</li>
	<li>
( %左端, %上端, %横幅, %縦幅 )
~LET 順に
⇒＃
%正規化-済み~map[ `left$opf ],
%正規化-済み~map[ `top$opf ],
%正規化-済み~map[ `width$opf ],
%正規化-済み~map[ `height$opf ]
◎
Let x be null.
◎
Let y be null.
◎
Let width be null.
◎
Let height be null.
</li>
	<li>
<p>
~IF［
%左端 ~NEQ ε
］：
◎
If tokenizedFeatures["left"] exists:
• Set x to the result of invoking the rules for parsing integers on tokenizedFeatures["left"].
• If x is an error, set x to 0.
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%左端 を［
%可用な~screen の外側に %~UIwindow が出ない大きさ
］に切詰める
◎
Optionally, clamp x in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による %~screen の左辺に相対的な  %~UIwindow の左辺の~x座標 ~EQ %左端
］になるよう，
%~UIwindow を移動する
◎
Optionally, move target’s window such that the window’s left edge is at the horizontal coordinate x relative to the left edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is rightward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%上端 ~NEQ ε
］：
◎
If tokenizedFeatures["top"] exists:
• Set y to the result of invoking the rules for parsing integers on tokenizedFeatures["top"].
• If y is an error, set y to 0.
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%上端 を［
%可用な~screen の外側に %~UIwindow が出ない大きさ
］に切詰める
◎
Optionally, clamp y in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による %~screen の上辺に相対的な %~UIwindow の上辺の ~y座標 ~EQ %上端
］になるよう，
%~UIwindow を移動する
◎
Optionally, move target’s window such that the window’s top edge is at the vertical coordinate y relative to the top edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is downward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%横幅 ~NIN { ε, 0 }
］：
◎
If tokenizedFeatures["width"] exists:
• Set width to the result of invoking the rules for parsing integers on tokenizedFeatures["width"].
• If width is an error, set width to 0.
• If width is not 0:
</p>
		<ol>
			<li>

任意選択で，~UA定義な方式で
⇒
%横幅 を，
%可用な~screen の中で %~UIwindow の大きさが~~適度な［
上限, 下限
］に収まるよう切詰める
◎
Optionally, clamp width in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による表示域の左辺と右辺の距離 ~EQ %横幅
］になるよう，
%~UIwindow の右辺を移動して， %~UIwindow の~sizeを変える
◎
Optionally, size target’s window by moving its right edge such that the distance between the left and right edges of the viewport are width CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%~UIwindow を，
%可用な~screen をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%縦幅 ~NIN { ε, 0 }
］：
◎
If tokenizedFeatures["height"] exists:
• Set height to the result of invoking the rules for parsing integers on tokenizedFeatures["height"].
• If height is an error, set height to 0.
• If height is not 0:
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%縦幅 を，
%可用な~screen の中で %~UIwindow の大きさが~~適度な［
上限, 下限
］に収まるよう切詰める
◎
Optionally, clamp height in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による表示域の上辺と下辺の距離 ~EQ %縦幅
］になるよう，
%~UIwindow の下辺を移動して， %~UIwindow の~sizeを変える
◎
Optionally, size target’s window by moving its bottom edge such that the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%~UIwindow を，
%可用な~screen をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
次に挙げるものが
`~supportされる~open_m特能~名@
である：
◎
A supported open() feature name is one of the following:
</p>

<dl>
	<dt>`width@opf</dt>
	<dd>
表示域の横幅
◎
The width of the viewport.
</dd>

	<dt>`height@opf</dt>
	<dd>
表示域の縦幅
◎
The height of the viewport.
</dd>

	<dt>`left@opf</dt>
	<dd>
~UIwindowの左端の位置
◎
The left position of the window.
</dd>

	<dt>`top@opf</dt>
	<dd>
~UIwindowの上端の位置
◎
The top position of the window.
</dd>

</dl>

		</section>
		<section id="the-mediaquerylist-interface">
<h3 title="The MediaQueryList Interface">4.2. `MediaQueryList^I ~interface</h3>

<p>
この節は、
`HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
`MediaQueryList$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`媒体~query~list@mq</dt>
	<dt>`文書@mq</dt>
	<dd>
作成-時に設定される。
◎
A MediaQueryList object has an associated media query list and an associated document set on creation.
</dd>

	<dt>`媒体@mq</dt>
	<dd>
`直列化-＠~CSSOM1#serialize-a-media-query-list$された形による，`媒体~query~list$mq。
◎
A MediaQueryList object has an associated media which is the serialized form of the associated media query list.
</dd>

	<dt>`合致-状態@mq</dt>
	<dd>
結付けられている`媒体~query~list$mqが［
`文書$mqの状態に合致するときは ~T ／
~ELSE_ ~F
］を返す。
◎
A MediaQueryList object has an associated matches state which is true if the associated media query list matches the state of the document, and false otherwise.
</dd>

</dl>

<div class="algo">
<p>
`文書~用の媒体~queryを評価して変化を報告する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to evaluate media queries and report changes for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
~EACH( `MediaQueryList$I ~obj %~target )
に対し，先に作成されたものから順に：
</p>
		<ol>
			<li>
~IF［
%~target の`文書$mq ~NEQ %文書
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%~target の`合致-状態$mqは、
この手続きを前回~走らせたときから変化していない
］
⇒
~CONTINUE
</li>
			<li>
`~eventを発火する$( %~target, `change$et, `MediaQueryList$I )
— 次のように初期化して
⇒＃
`isTrusted$m 属性 ~SET ~T,
`media$m1 属性 ~SET %~target の`媒体$mq,
`matches$m1 属性 ~SET %~target の`合致-状態$mq
【！fingerprint】
</li>
		</ol>
◎
For each MediaQueryList object target that has doc as its document, in the order they were created, oldest first, run these substeps:
• If target’s matches state has changed since the last time these steps were run, fire an event named change at target using MediaQueryListEvent, with its isTrusted attribute initialized to true, its media attribute initialized to target’s media, and its matches attribute initialized to target’s matches state.
</li>
</ol>
</div>

<div class="example">
<p>
`表示域$の方位（ `orientation^en ）の変化を検出する単純な~code片は、
次のように書かれるであろう：
◎
A simple piece of code that detects changes in the orientation of the viewport can be written as follows:
</p>

<pre class="lang-js">
function handleOrientationChange(%event) {
  if(%event.`matches$m) // landscape
    …
  else
    …
}
var %mql = `matchMedia＠#dom-window-matchmedia$m(`(orientation:landscape)^l);
%mql.`onchange$m = handleOrientationChange;
</pre>

</div>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryList@I : `EventTarget$I {
  readonly attribute `CSSOMString$ `media$m;
  readonly attribute `boolean$ `matches$m;
  `undefined$ `addListener$m(`EventListener$I? %callback);
  `undefined$ `removeListener$m(`EventListener$I? %callback);
           attribute `EventHandler$I `onchange$m;
};
</pre>

<div class="algo">
`media@m
取得子~手続きは
⇒
~RET コレに結付けられている`媒体$mq
◎
The media attribute must return the associated media.
</div>

<div class="algo">
`matches@m
取得子~手続きは
⇒
~RET コレに結付けられている`合致-状態$mq
【！fingerprint】
◎
The matches attribute must return the associated matches state.
</div>

<div class="algo">
<p>
`addListener(callback)@m
~method手続きは：
</p>
<ol>
	<li>
%~listener ~LET 新たな`~event~listener$
— その
⇒＃
`型$evL ~SET `change$et,
`~callback$evL ~SET %callback
</li>
	<li>
`~event~listenerを追加する$( コレ, %~listener )
</li>
</ol>

◎
The addListener(callback) method, when invoked, must run these steps:
• Add an event listener with this and an event listener whose type is change, and callback is callback.
</div>

<div class="algo">
<p>
`removeListener(callback)@m
~method手続きは：
◎
The removeListener(callback) method, when invoked, must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`~event~listener~list$内に［
( `型$evL, `~callback$evL, `捕捉するか$evL )
~EQ ( `change$et, %callback, ~F )
］を満たす`~event~listener$がある
］
⇒
`~event~listenerを除去する$( コレ, その~event~listener )
◎
If this’s event listener list contains an event listener whose type is change, callback is callback, and capture is false, then remove an event listener with this and that event listener.
</li>
</ol>
</div>

<p class="note">注記：
この仕様は、
当初は，［
`addListener()$m ／ `removeListener()$m
］による~custom~callbackの仕組みを利用していた
— その~callbackは、
結付けられている`媒体~query~list$mqを引数に呼出されていた。
今や、
通常の~eventの仕組みが代わりに利用される。
後方-互換性を得るため、［
`addListener()$m ／ `removeListener()$m
］~methodは基本的に［
`addEventListener()$m ／ `removeEventListener()$m
］の別名になり，
`change$et ~eventが `MediaQueryList$I のふりをする。
◎
Note: This specification initially had a custom callback mechanism with addListener() and removeListener(), and the callback was invoked with the associated media query list as argument. Now the normal event mechanism is used instead. For backwards compatibility, the addListener() and removeListener() methods are basically aliases for addEventListener() and removeEventListener(), respectively, and the change event masquerades as a MediaQueryList.
</p>

<p>
`MediaQueryList$I ~interfaceを実装する~objは、
`onchange@m
`~event~handler$（および，対応する`~event~handler~event型$ `change$et ）を，`~event~handler~IDL属性$として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MediaQueryList interface:
◎
Event handler｜Event handler event type
onchange｜change
</p>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryListEvent@I : `Event$I {
  `MediaQueryListEvent@mc(`CSSOMString$ %type, optional `MediaQueryListEventInit$I %eventInitDict = {});

  readonly attribute `CSSOMString$ `media$m;
  readonly attribute `boolean$ `matches$m;
};

dictionary `MediaQueryListEventInit@I : `EventInit$I {
  `CSSOMString$ `media@mb = "";
  `boolean$ `matches@mb = false;
};
</pre>

`MediaQueryListEvent^I0

<div class="algo">
`media@m
取得子~手続きは、
初期化-時の値を返す。
◎
The media attribute must return the value it was initialized to.
</div>

<div class="algo">
`matches@m
取得子~手続きは、
初期化-時の値を返す。
◎
The matches attribute must return the value it was initialized to.
</div>

			<section id="mediaquerylist-event-summary">
<h4 title="Event summary">4.2.1. ~event要覧</h4>

◎非規範的

<table><thead>
<tr><th>~event
<th>~interface
<th>~target
<th>記述
<tbody>

<tr><td>`change@et
<td>`MediaQueryListEvent$I
<td>`MediaQueryList$I
<td>
`合致-状態$mqが変化したとき，
`MediaQueryList$I に向けて発火される。
◎
Fired at the MediaQueryList when the matches state changes.
</table>

			</section>
		</section>
		<section id="the-screen-interface">
<h3 title="The Screen Interface">4.3. `Screen^I ~interface</h3>

<p>
その名前が示唆するとおり、
`Screen$I ~interfaceは，出力~機器の~screenについての情報を表現する。
◎
As its name suggests, the Screen interface represents information about the screen of the output device.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Screen@I {
  readonly attribute `long$ `availWidth$m;
  readonly attribute `long$ `availHeight$m;
  readonly attribute `long$ `width$m;
  readonly attribute `long$ `height$m;
  readonly attribute `unsigned long$ `colorDepth$m;
  readonly attribute `unsigned long$ `pixelDepth$m;
};
</pre>

`Screen^dgm

<div class="algo">
［
`availWidth@m ｜ `availHeight@m
］取得子~手続きは
⇒
~RET `~Webに公開される可用な~screen区画$の［
横幅 ｜ 縦幅
］
◎
The availWidth attribute must return the width of the Web-exposed available screen area.
◎
The availHeight attribute must return the height of the Web-exposed available screen area.
</div>

<div class="algo">
［
`width@m ｜ `height@m
］取得子~手続きは
⇒
~RET `~Webに公開される~screen区画$の［
横幅 ｜ 縦幅
］
◎
The width attribute must return the width of the Web-exposed screen area.
◎
The height attribute must return the height of the Web-exposed screen area.
</div>

<p>
［
`colorDepth@m
／
`pixelDepth@m
］属性の取得子は、
いずれも：
◎
The colorDepth and pixelDepth attributes＼
</p>
<ul>
	<li>
出力~機器における~pixelの色に割振られている~bit数を
— その~alpha~channelは除外して —
返すベキである。
~UAがこの~bit数を知り得ない場合は、
自身による最も近い見積もりを返すベキである
— 例えば、
出力~機器が利用する値に最も近くなるような，［
機器に送り込まれる~frame~buffer, または何らかの内部~表現
］に利用されている~bit数など。
◎
should return the number of bits allocated to colors for a pixel in the output device, excluding the alpha channel. If the user agent is not able to return the number of bits used by the output device, it should return the closest estimation such as, for example, the number of bits used by the frame buffer sent to the display or any internal representation that would be the closest to the value the output device would use.＼
</li>
	<li>
`color$d 媒体~特能の`実~値$の 3 倍~以上の値を返すモノトスル
— ~bit数が色~成分ごとに異なる場合、
返す値は 3 倍を超えてもヨイ。
~UAは、
色~深度を［
知り得ない, または~privacyに配慮するため返したくない
］場合は， 24 を返すベキである。
◎
The user agent must return a value for these attributes at least equal to the value of the color media feature multiplied by three. If the different color components are not represented with the same number of bits, the returned value may be greater than three times the value of the color media feature. If the user agent does not know the color depth or does not want to return it for privacy considerations, it should return 24.
</li>
	<li class="note">注記：
互換性の理由から，両~属性とも同じ値を返す。
◎
Note: The colorDepth and pixelDepth attributes return the same value for compatibility reasons.
</li>
	<li class="note">注記：
一部の不適合な実装は、
24 でなく 32 を返すことが知られている。
◎
Note: Some non-conforming implementations are known to return 32 instead of 24.
</li>
</ul>

		</section>
	</section>
	<section id="extensions-to-the-document-interface">
<h2 title="Extensions to the Document Interface">5. `Document^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Document$I {`Document^I0
  `Element$I? `elementFromPoint$m(`double$ %x, `double$ %y);
  `sequence$&lt;`Element$I&gt; `elementsFromPoint$m(`double$ %x, `double$ %y);
  `CaretPosition$I? `caretPositionFromPoint$m(`double$ %x, `double$ %y);
  readonly attribute `Element$I? `scrollingElement$m;
};
</pre>

`Document^dgm

<div class="algo">
<p>
`elementFromPoint(x, y)@m
~method手続きは：
◎
The elementFromPoint(x, y) method must follow these steps:
</p>
<ol>
	<li>
~IF［
コレに結付けられている`表示域$は無い
］
⇒
~RET ~NULL
◎
↓</li>
	<li>
~IF［［［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］］ではない
］
⇒
~RET ~NULL
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return null and terminate these steps.
</li>
	<li>
~IF［
`表示域$の子孫に対する`変形$を適用した下で，座標 (%x, %y) の`接触判定$の~targetになる`~box$は`表示域$内にある
］
⇒
~RET それを結付けている要素
◎
If there is a box in the viewport that would be a target for hit testing at coordinates x,y, when applying the transforms that apply to the descendants of the viewport, return the associated element and terminate these steps.
</li>
	<li>
~RET コレの`根~要素$
◎
If the document has a root element, return the root element and terminate these steps.
◎
Return null.
</li>
</ol>

<p class="note">注記：
`elementFromPoint()^m ~methodは、
最も手前に塗られている要素を返すとは限らない。
例えば、
要素は， `pointer-events$p ~CSS~propの利用を通して`接触判定$の~targetから除外され得る。
◎
Note: The elementFromPoint() method does not necessarily return the top-most painted element. For instance, an element can be excluded from being a target for hit testing by using the pointer-events CSS property.
</p>

</div>

<div class="algo">
<p>
`elementsFromPoint(x, y)@m
~method手続きは：
◎
The elementsFromPoint(x, y) method must follow these steps:
</p>
<ol>
	<li>
%~list ~LET 新たな~list
◎
Let sequence be a new empty sequence.
</li>
	<li>
<p>
~IF［
コレに結付けられている`表示域$はある
］~AND［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］：
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return sequence and terminate these steps.
</p>
		<ol>
			<li>
%~list に次を満たす すべての要素を付加する
— 最~上端な【すなわち，最も手前に塗られる】~boxから順に，要素の`~box$の塗り順序で
⇒
要素の`~box$は、
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内にあって座標 ( %x, %y ) における`接触判定$の~targetになる（そこに何も `overlap^en していないとしても【要素には塗られる内容がないとしても？】）
◎
For each box in the viewport, in paint order, starting with the topmost box, that would be a target for hit testing at coordinates x,y even if nothing would be overlapping it, when applying the transforms that apply to the descendants of the viewport, append the associated element to sequence.
</li>
			<li>
~IF［
%~list は空でない
］~AND［
コレの`根~要素$ %根 ~NIN { ~NULL, %~list の最後の~item }
］
⇒
%~list に %根 を付加する
◎
If the document has a root element, and the last item in sequence is not the root element, append the root element to sequence.
</li>
		</ol>
	</li>
	<li>
~RET %~list を表現する連列~型~obj
◎
Return sequence.
</li>
</ol>
</div>

<div class="algo">
<p>
`caretPositionFromPoint(x, y)@m
~method手続きは：
◎
The caretPositionFromPoint(x, y) method must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレに結付けられている`表示域$は無い
］
⇒
~RET ~NULL
◎
If there is no viewport associated with the document, return null.
</li>
	<li>
~IF［［［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］］でない
］
⇒
~RET ~NULL
<!-- 
引数が指す座標が`表示域$の外を指す場合、 null を返す（“表示域の外” の定義は上の <code>elementFromPoint</code> の記述と同じ）。
-->
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), y is greater than the viewport height excluding the size of a rendered scroll bar (if any) return null.
</li>
	<li>
~IF［［
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内の座標
( %x, %y )
の所に~text挿入位置指示が挿入されることになる
］ではない
］
⇒
~RET ~NULL
◎
If at the coordinates x,y in the viewport no text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, return null.
</li>
	<li>
~IF［
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内の座標
( %x, %y )
の所に, かつ［
`置換d要素$による~text手入力~widget
］内に，~text挿入位置指示が挿入されることになる
］
⇒
~RET 次のように設定された`~caret位置$
⇒＃
`~caret範囲$ ~SET ~NULL,
`~caret~node$ ~SET ~text手入力~widgetに対応する~node,
`~caret~offset$ ~SET 左端から~text挿入位置指示が挿入される地点までにある`符号単位$の個数
◎
If at the coordinates x,y in the viewport a text insertion point indicator would have been inserted in a text entry widget which is also a replaced element, when applying the transforms that apply to the descendants of the viewport, return a caret position with its properties set as follows:
• caret node
•• The node corresponding to the text entry widget.
• caret offset
•• The amount of 16-bit units to the left of where the text insertion point indicator would have inserted. 
• caret range
•• null
</li>
	<li>
%~caret範囲 ~LET ［
`表示域$の子孫に対する`変形$を適用した下で，~text挿入位置指示が挿入されることになる地点
］を指すような，`畳まれて$いる `Range$I ~obj
◎
Otherwise, return a caret position where the caret range is a collapsed Range object for the position where the text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, and＼
</li>
	<li>
~RET 次のように設定された`~caret位置$
⇒＃
`~caret範囲$ ~SET %~caret範囲,
`~caret~node$ ~SET %~caret範囲 の`始端~node$,
`~caret~offset$ ~SET %~caret範囲 の`始端~offset$
◎
the other properties are set as follows:
◎
caret node
• The start node of the caret range.
caret offset
• The start offset of the caret range. 
</li>
</ol>
</div>

<p class="note">注記：
`接触判定@
の詳細は、
この仕様の視野から外れる。
したがって［
`elementFromPoint()$m ／
`caretPositionFromPoint()$m
］の正確な詳細についても同様になる。
接触判定は、
希望的には，~CSSまたは~HTMLの将来における改訂にて定義されることになる。
◎
Note: The specifics of hit testing are out of scope of this specification and therefore the exact details of elementFromPoint() and caretPositionFromPoint() are therefore too. Hit testing will hopefully be defined in a future revision of CSS or HTML.
</p>

<div class="algo">
<p>
`scrollingElement@m
取得子~手続きは：
◎
The scrollingElement attribute, on getting, must run these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレは`過去互換~mode$下にある
］：
◎
If the Document is in quirks mode, follow these substeps:
</p>
		<ol>
			<li>
%~body ~LET コレの`~body要素$
◎
↓</li>
			<li>
<p>
~IF［
%~body ~NEQ ~NULL
］~AND［
%~body は`~scroll可能になり得ない$†
］
⇒
~RET %~body
◎
If the body element exists, and it is not potentially scrollable, return the body element and abort these steps.
</p>

<p>†
この目的においては、
%~body の `overflow$p 値が `clip^v の場合には，
%~body の親~要素の `overflow$p は `hidden^v として扱うモノトスル。
◎
For this purpose, a value of overflow:clip on the body element’s parent element must be treated as overflow:hidden.
</p>
			</li>
			<li>
~RET ~NULL
◎
Return null and abort these steps.
</li>
		</ol>
	</li>
	<li>
~RET コレの`根~要素$
◎
If there is a root element, return the root element and abort these steps.
◎
Return null.
</li>
</ol>

<p class="note">注記：
［
`scrollTop^m, `scrollLeft^m
］用には常に`過去互換~mode$の挙動を利用する，不適合な~UA用には、［
`scrollingElement$m 属性は，常に`~body要素$を返す
（ ~NULL にもなり得る）
］ものと期待されている。
この~APIが存在するのは、
~Web開発者が，~scroll用~APIに利用する~~正しい要素を取得できるようにするためである
— 特定0の~UAの挙動を前提にしたり，どの要素が表示域を~scrollするかを見るために~scrollを呼出す必要なく。
◎
Note: For non-conforming user agents that always use the quirks mode behavior for scrollTop and scrollLeft, the scrollingElement attribute is expected to also always return the body element (or null if it does not exist). This API exists so that Web developers can use it to get the right element to use for scrolling APIs, without making assumptions about a particular user agent’s behavior or having to invoke a scroll to see which element scrolls the viewport.
</p>

<p class="note">注記：
`~body要素$は、
~HTMLの `document.body^m とは異なる
— 後者は `frameset^e 要素を返すこともある。
◎
Note: the body element is different from HTML’s document.body in that the latter can return a frameset element.
</p>
</div>

		<section id="the-caretposition-interface">
<h3 title="The CaretPosition Interface">5.1. `CaretPosition^I ~interface</h3>

<p>
`~caret位置@
とは、
~text挿入位置指示の位置を与えるものであり，常に［
`~caret~node@,
`~caret~offset@,
`~caret範囲@
］が結付けられる。
~caret位置は、
`CaretPosition$I ~objにより表現される。
◎
A caret position gives the position of a text insertion point indicator. It always has an associated caret node, caret offset, and caret range. It is represented by a CaretPosition object.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CaretPosition@I {
  readonly attribute `Node$I `offsetNode$m;
  readonly attribute `unsigned long$ `offset$m;
  [`NewObject$] `DOMRect$I? `getClientRect$m();
};
</pre>

<div class="algo">
`offsetNode@m
取得子~手続きは
⇒
~RET コレの`~caret~node$
◎
The offsetNode attribute must return the caret node.
</div>

<div class="algo">
`offset@m
取得子~手続きは
⇒
~RET コレの`~caret~offset$
◎
The offset attribute must return the caret offset.
</div>

<div class="algo">
<p>
`getClientRect()@m
~method手続きは：
◎
The getClientRect() method must follow these steps, aborting on the first step that returns a value:
</p>
<ol>
	<li>
<p>
~IF［
コレの`~caret範囲$ ~NEQ ~NULL
］：
◎
If caret range is not null:
</p>
		<ol>
			<li>
%~list ~LET コレの`~caret範囲$上の 
`Range^I1 `getClientRects$m1 ~method手続き()
◎
Let list be the result of invoking the getClientRects() method on the range.
</li>
			<li>
~IF［
%~list は空である
］
⇒
~RET ~NULL
◎
If list is empty, return null.
</li>
			<li>
~RET %~list 内の最初の `DOMRect$I ~obj
◎
Return the DOMRect object in list at index 0.
</li>
		</ol>
	</li>
	<li>
~IF［
コレの`~caret~node$ %node は，［
`置換d要素$による~text手入力~widgetである
］~AND［
文書~内に在る【！＊in the document】
］］
⇒
~RET 
%node とその先祖に対する`変形$を適用した下で、
%node 内の，`~caret~offset$ の値で表現される~caretに対する `DOMRect$I ~obj
◎
If caret node is a text entry widget that is a replaced element, and that is in the document, return a DOMRect object for the caret in the widget as represented by the caret offset value. The transforms that apply to the element and its ancestors are applied.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: This DOMRect object is not live.
</p>
</div>

		</section>
	</section>
	<section id="extension-to-the-element-interface">
<h2 title="Extensions to the Element Interface">6.  `Element^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollLogicalPosition@I { `start@l, `center@l, `end@l, `nearest@l };

dictionary `ScrollIntoViewOptions@I : `ScrollOptions$I {
  `ScrollLogicalPosition$I `block@mb = `start$l;
  `ScrollLogicalPosition$I `inline@mb = `nearest$l;
};

dictionary `CheckVisibilityOptions@I {
  `boolean$ `checkOpacity@mb = false;
  `boolean$ `checkVisibilityCSS@mb = false;
};
</pre>

<pre class="idl">
partial interface `Element$I {`Element^I0
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();

  `boolean$ `checkVisibility$m(optional `CheckVisibilityOptions$I %options = {});

  `undefined$ `scrollIntoView$m(optional (`boolean$ or `ScrollIntoViewOptions$I) %arg = {});
  `undefined$ `scroll$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scroll$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollTo$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollTo$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollBy$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollBy$m(`unrestricted double$ %x, `unrestricted double$ %y);
  attribute `unrestricted double$ `scrollTop$m;
  attribute `unrestricted double$ `scrollLeft$m;
  readonly attribute `long$ `scrollWidth$m;
  readonly attribute `long$ `scrollHeight$m;
  readonly attribute `long$ `clientTop$m;
  readonly attribute `long$ `clientLeft$m;
  readonly attribute `long$ `clientWidth$m;
  readonly attribute `long$ `clientHeight$m;
};
</pre>

`Element^dgm

<div class="algo">
<p>
`getClientRects()@m
~method手続きは：
◎
The getClientRects() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
~IF［
コレは`~box$を持たない
］
⇒
~RET 空な `DOMRectList$I ~obj
◎
If the element on which it was invoked does not have an associated box return an empty DOMRectList object and stop this algorithm.
</li>
	<li>
~IF［
コレは`~SVG~layout~box$を持つ
］
⇒
~RET 次で与えられる矩形を表す 1 個の `DOMRect$I ~objからなる `DOMRectList$I ~obj
⇒
コレとその先祖に対する`変形$を適用した下で，~SVG仕様の定義に従うコレの限界~box
◎
If the element has an associated SVG layout box return a DOMRectList object containing a single DOMRect object that describes the bounding box of the element as defined by the SVG specification, applying the transforms that apply to the element and its ancestors.
</li>
	<li>
<p>
%断片~list ~LET
コレの`~box$内の`~box断片$からなる~list
— ここで：
</p>

<ul>
			<li>
コレの `display$p ~propの算出d値
~IN { `table$v, `inline-table$v }
の場合、
table ~box と caption ~boxは ~listに含めるが，匿名~容器~boxは含めない。
</li>
			<li>
各 `匿名$な`塊~box$は，その子~boxたちに置換する。
匿名な塊~boxが尽きるまで，これを繰返す。
</li>
			<li>
縦幅／横幅 が 0 であっても~listから除外しない。
</li>
			<li>
~listは、
内容~順による。
</li>
		</ul>
◎
Return a DOMRectList object containing DOMRect objects in content order, one for each box fragment, describing its border area (including those with a height or width of zero) with the following constraints:
• Apply the transforms that apply to the element and its ancestors.
• If the element on which the method was invoked has a computed value for the display property of table or inline-table include both the table box and the caption box, if any, but not the anonymous container box.
• Replace each anonymous block box with its child box(es) and repeat this until no anonymous block boxes are left in the final list.
</li>
	<li>
%矩形~list ~LET 空な~list
◎
↑</li>
	<li>
<p>
%断片~list を成す
~EACH( %断片 )
に対し
⇒
%矩形~list に次を表現する `DOMRect$I ~objを付加する
⇒
次を包含する最~小な矩形
⇒
%断片 の`~border区画$に［
コレとその先祖に対する`変形$
］を適用して得られる図形
◎
↑</p>

<p class="trans-note">【
原文には “最~小な矩形” という記述は無いが、
変形を孕んでいるので，必然的にそうなる。
】</p>
</li>
	<li>
<p>
~RET %矩形~list を表現している `DOMRectList$I ~obj
◎
↑</p>

<p class="trans-note">【
新たな~objを返すとは限らない
（前回の呼出nから何も変化していない場合、同じ~objを返すかもしれない）。
】</p>
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objたちは、
`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</p>
</div>

<div class="algo">
`getBoundingClientRect()@m
~method手続きは
⇒
~RET `要素~用の限界~boxを取得する$( コレ )
◎
The getBoundingClientRect() method, when invoked on an element element, must return the result of getting the bounding box for element.
</div>

<div class="algo">
<p>
`要素~用の限界~boxを取得する@
ときは、
所与の
( %要素 )
に対し：
◎
To get the bounding box for element, run the following steps:
</p>
<ol>
	<li>
%~list ~LET %要素 の `getClientRects$m ~method手続き()
◎
Let list be the result of invoking getClientRects() on element.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET 新たな `DOMRect$I ~obj
— その
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If the list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
	<li>
~IF［
%~list 内の矩形は，どれも［
横幅, 縦幅
］どちらかは 0
］
⇒
~RET %~list 内の最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
	<li>
~RET 次を表現する新たな `DOMRect$I ~obj
⇒
次をすべてを包含する最~小な矩形
⇒
%~list 内の［
横幅, 縦幅
］どちらかは【どちらも？】 0 でない矩形
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</p>

<div class="example">
<p>
次の~code片は文書~内の最初の `div^e 要素の~sizeを取得する：
◎
The following snippet gets the dimensions of the first div element in a document:
</p>

<pre class="lang-js">
var %example = document
    .getElementsByTagName("div")[0]
    .getBoundingClientRect();
var %exampleWidth = %example.width;
var %exampleHeight = %example.height;
</pre>
</div>
</div>

<p class="note">注記：
`checkVisibility()$m ~methodは、
要素は “可視” になり得るかどうかについて，一群の単純な検査を供する。
それは，既定では［
`~box~tree$に基づく，ごく単純かつ単直な~method
］であるが、
“可視性” を成す精確な観念として何が欲されるかに依存して，
いくつかの［
任意で選べる追加的な検査
］も許容する。
◎
Note: The checkVisibility() method provides a set of simple checks for whether an element is potentially "visible". It defaults to a very simple and straightforward method based on the box tree, but allows for several additional checks to be opted into, depending on what precise notion of "visibility" is desired.
</p>

<div class="algo">
<p>
`checkVisibility(options)@m
~method手続きは、［
~OR↓ が満たされるならば ~F ／
~ELSE_ ~T
］を返す：
◎
The checkVisibility(options) method must run these steps, when called on an element this:
</p>
<ul>
	<li>
コレは`~box$を持たない
◎
If this does not have an associated box, return false.
</li>
	<li>
コレの`~shadowも含めた先祖$であって，
`content-visibility$p が `hidden^v にされたものが在る
◎
If a shadow-including ancestor of this has content-visibility: hidden, return false.
</li>
	<li>
［
%options[ "`checkOpacity$mb" ] ~EQ ~T
］~AND［
コレの`~shadowも含めた先祖$であって，
`opacity$p が `0^v に算出されるものが在る
］
◎
If the checkOpacity dictionary member of options is true, and this, or a shadow-including ancestor of this, has a computed opacity value of 0, return false.
</li>
	<li>
［
%options[ "`checkVisibilityCSS$mb" ] ~EQ ~T
］~AND［
コレは`不可視$である
］
◎
If the checkVisibilityCSS dictionary member of options is true, and this is invisible, return false.
◎
Return true.
</li>
</ul>
</div>

<div class="algo">
<p>
`scrollIntoView(arg)@m
~method手続きは：
◎
The scrollIntoView(arg) method must run these steps:
</p>
<ol>
	<li>
%挙動 ~LET `auto^l
◎
Let behavior be "auto".
</li>
	<li>
%塊 ~LET `start^l
◎
Let block be "start".
</li>
	<li>
%行内 ~LET `nearest^l
◎
Let inline be "nearest".
</li>
	<li>
~IF［
%arg は `ScrollIntoViewOptions$I 辞書である
］
⇒＃
%挙動 ~SET %options[ "`behavior$mb" ],
%塊 ~SET %options[ "`block$mb" ]
%行内 ~SET  %options[ "`inline$mb" ]
◎
If arg is a ScrollIntoViewOptions dictionary, then:
• Set behavior to the behavior dictionary member of options.
• Set block to the block dictionary member of options.
• Set inline to the inline dictionary member of options.
</li>
	<li>
~ELIF［
%arg ~EQ ~F
］
⇒
%塊 ~SET `end^l
◎
Otherwise, if arg is false, then set block to "end".
</li>
	<li>
~IF［
コレは`~box$を持たない
］~OR［
コレは~UA特能
【例：~tab~UIkeyによる巡回】
に可用でない
【例：先祖の`内容が飛ばされ$ている場合】
］
⇒
~RET
◎
If the element does not have any associated box, or is not available to user-agent features, then return.
</li>
	<li>
コレを`~viewの中へ~scrollする$( %挙動, %塊, %行内 )
◎
Scroll the element into view with behavior, block, and inline.
</li>
	<li>
任意選択で
⇒
利用者に コレを注目してもらう何らかの動作があれば，それを遂行する
◎
Optionally perform some other action that brings the element to the user’s attention.
</li>
</ol>
</div>

<div class="algo">
<p>
`scroll()@m
~method手続きは：
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x )
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y )
</li>
	<li>
`要素~用の~scroll手続き$( コレ, %x, %y, %behavior )
</li>
</ol>

◎
The scroll() method must run these steps:
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
• Let x be the value of the left dictionary member of options, if present, or the element’s current scroll position on the x axis otherwise.
◎
• Let y be the value of the top dictionary member of options, if present, or the element’s current scroll position on the y axis otherwise.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
◎
↓</div>

<div class="algo">
<p class="trans-note">【
この訳では、［
原文による `scroll()$m ~method手続きを成す引数の取扱い
］以外の部分を，次に与える手続きに分離する
— それは、
複数の箇所から共通して利用されるので。
】</p>

<p>
`要素~用の~scroll手続き@
は、所与の
( %要素, %x, %y, %behavior )
に対し：
◎
↑</p>

<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`根~要素$
］
⇒＃
%x ~SET %window の `Window^I1 `scrollX$m1  取得子~手続き()；
`~window用の~scroll手続き$( %window, %x, %y, `auto$l )
~RET
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
%要素 は`~scroll可能になり得ない$
］
⇒＃
`~window用の~scroll手続き$( %window, %x, %y, %behavior )；
~RET
◎
If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with options as the only argument, and terminate these steps.
</li>
	<li>
~IF［
%x ~EQ ε
］
⇒
%x ~SET %要素 の現在の~x軸 `~scroll位置$
◎
↑</li>
	<li>
~IF［
%y ~EQ ε
］
⇒
%y ~SET %要素 の現在の~y軸 `~scroll位置$
◎
↑</li>
	<li>
<p>
~IF［
%要素 は ~OR↓ を満たす
］…
</p>
		<ul>
			<li>
`~box$を持たない
</li>
			<li>
`~scrollされる~box$は無い
</li>
			<li>
~overflowしていない
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>
◎
If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
	<li>
`要素を~scrollする$( %要素, ( %x, %y ), %behavior )
◎
Scroll the element to x,y, with the scroll behavior being the value of the behavior dictionary member of options.
</li>
</ol>
</div>

<div class="algo">
`scrollTo()@m
~method手続きは、
`scroll()$m ~method手続きと同じに挙動する。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</div>

<div class="algo">
<p>
`scrollBy()@m
~method手続きは：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x ) ~PLUS コレの `scrollLeft$m 取得子~手続き()
◎
Add the value of scrollLeft to the left dictionary member.
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y ) ~PLUS コレの `scrollTop$m 取得子~手続き()
◎
Add the value of scrollTop to the top dictionary member.
</li>
	<li>
`要素~用の~scroll手続き$( コレ, %x, %y, %behavior )
◎
Act as if the scroll() method was invoked with options as the only argument.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`scrollTop@m ｜ `scrollLeft@m
］取得子~手続きは：
◎
The scrollTop attribute, on getting, must return the result of running these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET 0
◎
If window is null, return zero and terminate these steps.
</li>
	<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET 0
◎
If the element is the root element and document is in quirks mode, return zero and terminate these steps.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>

		<ul>
			<li>
コレ ~EQ %文書 の`根~要素$
</li>
			<li>
［
コレ ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
		</ul>
<p>
…ならば
⇒
~RET %window の［
`scrollY^m ｜ `scrollX^m
］の値
</p>

◎
If the element is the root element return the value of scrollY on window.
◎
If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollY on window.
</li>
	<li>
~IF［
コレは`~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated box, return zero and terminate these steps.
</li>
	<li>
~RET
コレの`~scrollされる区画$の整列~点から相対的な，
コレの`~padding辺$の［
上端の~y座標 ｜ 左端の~x座標
］
◎
Return the y-coordinate of the scrolling area at the alignment point with the top of the padding edge of the element.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`scrollTop$m ｜ `scrollLeft$m
］設定子~手続きは：
◎
When setting the scrollTop attribute these steps must be run:
</p>
<ol>
	<li>
%v ~LET `有限~値に正規化する$( 所与の値 )
◎
Let y be the given value.
◎
Normalize non-finite values for y.
</li>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
	<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
コレ ~EQ %文書 の`根~要素$
</li>
			<li>
［
コレ ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
		</ul>
<p>
…ならば：
`Window^I1
</p>
		<ol>
			<li>
%x ~LET ［ %window の `scrollX$m1 取得子~手続き() ｜ %v ］
</li>
			<li>
%y ~LET ［ %v ｜ %window の `scrollY$m1 取得子~手続き() ］
</li>
			<li>
`~window用の~scroll手続き$( %window, %x, %y, `auto$l )
</li>
			<li>
~RET
</li>
		</ol>
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
◎
If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with scrollX as first argument and y as second argument, and terminate these steps.
</li>
	<li>
<p>
~IF［
コレは ~OR↓ を満たす
］…
</p>
		<ul>
			<li>
`~box$を持たない
</li>
			<li>
`~scrollされる~box$は無い
</li>
			<li>
~overflowしていない
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>

◎
If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
	<li>
%目的位置 ~LET ( ［
コレの `scrollLeft$m 取得子~手続き() ｜ %v
］, ［
%v ｜ コレの `scrollTop$m 取得子~手続き()
］ )
◎
↓</li>
	<li>
`要素を~scrollする$( コレ,  %目的位置 , `auto$l )
◎
Scroll the element to scrollLeft,y, with the scroll behavior being "auto".
</li>
</ol>
</div>

<p class="en">
◎
The scrollLeft attribute, on getting, must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, return zero and terminate these steps.
• If the element is the root element and document is in quirks mode, return zero and terminate these steps.
• If the element is the root element return the value of scrollX on window.
• If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollX on window.
• If the element does not have any associated box, return zero and terminate these steps.
• Return the x-coordinate of the scrolling area at the alignment point with the left of the padding edge of the element.
◎
When setting the scrollLeft attribute these steps must be run:
• Let x be the given value.
• Normalize non-finite values for x.
• Let document be the element’s node document.
• If document is not the active document, terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, terminate these steps.
• If the element is the root element and document is in quirks mode, terminate these steps.
• If the element is the root element invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
• Scroll the element to x,scrollTop, with the scroll behavior being "auto".
</p>

<div class="algo">
<p>
［
`scrollWidth@m ｜ `scrollHeight@m 
］取得子~手続きは：
◎
The scrollWidth attribute must return the result of running these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>

		<ul >
			<li>
［
%文書 は`過去互換~mode$下にない
］~AND［
コレ ~EQ %文書 の`根~要素$
］
</li>
			<li>
［
%文書 は`過去互換~mode$下にある
］~AND［
コレ ~EQ %文書 の`~body要素$
］~AND［
コレは
`~scroll可能になり得ない$
］
</li>
		</ul>

<p>
…ならば：
</p>
		<ol>
			<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
			<li>
~RET
`max^op( `表示域$の`~scrollされる区画$の［
横幅 ｜ 縦幅
］, `表示域$の［
`有効~横幅$ ｜ `有効~縦幅$
］ )
</li>
		</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any, or zero if there is no viewport.
◎
If the element is the root element and document is not in quirks mode return max(viewport scrolling area width, viewport width).
◎
If the element is the body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area width, viewport width).
</li>
	<li>
~IF［
コレは`~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated box return zero and terminate these steps.
</li>
	<li>
~RET
コレの`~scrollされる区画$の［
横幅 ｜ 縦幅
］
◎
Return the width of the element’s scrolling area.
</li>
</ol>
</div>

<p class="en">
◎
The scrollHeight attribute must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let viewport height be the height of the viewport excluding the height of the scroll bar, if any, or zero if there is no viewport.
• If the element is the root element and document is not in quirks mode return max(viewport scrolling area height, viewport height).
• If the element is the body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area height, viewport height).
• If the element does not have any associated box return zero and terminate these steps.
• Return the height of the element’s scrolling area.
</p>

<div class="algo">
<p>
［
`clientTop@m ｜ `clientLeft@m
］取得子~手続きは：
◎
The clientTop attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレは`~box$を持たない
］~OR［
コレの`~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated box or if the box is inline, return zero.
</li>
	<li>
<p>
~RET 次の和：
</p>
		<ul>
			<li>
［
`border-top-width$p ｜ `border-left-width$p
］~propの算出d値
</li>
	<li>
`~padding辺$の［
上端 ｜ 左端
］と`~border辺$の［
上端 ｜ 左端
］の間に描画された~scrollbarの［
縦幅 ｜ 横幅
］
</li>
		</ul>
<p>
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</p>
◎
Return the computed value of the border-top-width property plus the height of any scrollbar rendered between the top padding edge and the top border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
</ol>
</div>

<p class="en">
◎
The clientLeft attribute must run these steps:
• If the element has no associated box or if the box is inline, return zero.
• Return the computed value of the border-left-width property plus the width of any scrollbar rendered between the left padding edge and the left border edge, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
<p>
［
`clientWidth@m ｜ `clientHeight@m
］取得子~手続きは：
◎
The clientWidth attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレは`~box$を持たない
］~OR［
コレの`~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated box or if the box is inline, return zero.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にない
］
</li>
			<li>
［
コレ ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
</li>
</ul>

<p>
…ならば
⇒
~RET
`表示域$の［
`有効~横幅$ ｜ `有効~縦幅$
］
</p>
◎
If the element is the root element and the element’s node document is not in quirks mode, or if the element is the body element and the element’s node document is in quirks mode, return the viewport width excluding the size of a rendered scroll bar (if any).
</li>
	<li>
<p>
~RET  `~padding辺$の［
横幅 ｜ 縦幅
］
— ここで：
</p>
		<ul>
			<li>
`~padding辺$と`~border辺$の間に~scrollbarが描画されている場合は，その分の［
横幅 ｜ 縦幅
］は除外する。
</li>
			<li>
コレとその先祖に対する`変形$は適用しないとする。
</li>
		</ul>
◎
Return the width of the padding edge excluding the width of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
</ol>
</div>

<p class="en">
◎
The clientHeight attribute must run these steps:
• If the element has no associated box or if the box is inline, return zero.
• If the element is the root element and the element’s node document is not in quirks mode, or if the element is the body element and the element’s node document is in quirks mode, return the viewport height excluding the size of a rendered scroll bar (if any).
• Return the height of the padding edge excluding the height of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</p>

		<section id="element-scrolling-members">
<h3 title="Element Scrolling Members">6.1. 要素の~scroll法</h3>

<div class="algo">

<div>
<p>
［
`要素$／`範囲o$
］ %~target を
`~viewの中へ~scrollする@
ときは、所与の
⇒＃
~scrollの挙動 %挙動,
塊~flow方向~位置 %塊,
行内~基底~方向~位置 %行内
◎終
に対し，次を走らす：
</p>
<ol>
	<li>
%~target限界~box ~LET %~target に応じて，次の結果を表現する~box
⇒＃
`要素$であるならば %~target の `getBoundingClientRect$m ~method手続き()／
`範囲o$であるならば  %~target の `Range^I1 `getBoundingClientRect$m1 ~method手続き()
</li>
	<li>
%~target要素 ~LET %~target に応じて
⇒＃
`要素$であるならば %~target ／
`範囲o$であるならば %~target の`始端~node$
</li>
	<li>
<p>
%~target の
~EACH( 先祖`~scroll容器$ %~scroll容器 )
に対し，最も内縁なものから順に：
</p>
		<ol>
			<li>
%容器 ~LET %~scroll容器 を確立している要素または`表示域$
</li>
			<li>
%容器~要素 ~LET %容器 に応じて
⇒＃
要素であるならば %容器 ／
`表示域$であるならば それに結付けられている`文書$の`根~要素$
</li>
			<li>
<p>
~IF［
( %~target要素 の`~node文書$【！associated with target】の`生成元$doc, %容器~要素 の`~node文書$の`生成元$doc )
は`同一-生成元$でない
］
⇒
~RET
</p>

<p class="trans-note">【
例えば %容器~要素 が `iframe^e で，
%~target要素 は その中に埋込まれた文書~内にある場合、
これらの文書は異なり得る。
】</p>
			</li>
			<li>
下に定義する “要素境界を~scrollする” 下位-手続きを走らす
【それに伴い， %~target限界~box の位置は変化することになる。】
</li>
		</ol>

<p class="trans-note">【
原文では，この~loopを要素の先祖~要素に基づいて反復しているが、
この訳では，先祖`~scroll容器$に基づくよう改める。
この “先祖” は、
`先祖~navigable＠~HTMLds#ancestor-navigables$も孕む “広義な” 先祖を表すと見受けられる
— さもなければ、
同一-生成元の検査はイミを成さなくなるので。
】</p>

	</li>
</ol>

◎
To scroll a target into view target, which is an Element or Range, with a scroll behavior behavior, a block flow direction position block, and an inline base direction position inline, means to run these steps for each ancestor element or viewport that establishes a scrolling box scrolling box, in order of innermost to outermost scrolling box:
• If the Document associated with target is not same origin with the Document associated with the element or viewport associated with scrolling box, terminate these steps.
• Let target bounding border box be the box represented by the return value of invoking Element’s getBoundingClientRect(), if target is an Element, or Range’s getBoundingClientRect(), if target is a Range.
</div>

<div class="algo">
<p>
要素境界を~scrollする下位-手続きは：
◎
↑</p>
<ol>
	<li>
%~box ~LET %容器 の`~scrollされる~box$
◎
↑</li>
	<li>
<div class="p">
<p>
この段においては：
</p>
		<ul>
			<li>
%~box の辺 %e に対する
%~target限界~box の
`同じ側@
の辺とは、
%e と物理的に同じ側にある %~target限界~box の辺を指すとする。
</li>
			<li>
［
`開始辺$ ／ `終了辺$ ／ 中心 ／ 距離
］は、［
%塊 に対しては`塊~flow方向$,
%行内 に対しては`行内~基底~方向$
］におけるそれを指すとする。
</li>
		</ul>
<p>
%目的位置 ~LET
( `塊~flow方向$, `行内~基底~方向$ )
成分が 順に
( %塊, %行内 )
に応じて，以下に従うように %~box を整列させる`~scroll位置$：
</p>
◎
Let scrolling box edge A be the beginning edge in the block flow direction of scrolling box, and let element edge A be target bounding border box’s edge on the same physical side as that of scrolling box edge A.
◎
Let scrolling box edge B be the ending edge in the block flow direction of scrolling box, and let element edge B be target bounding border box’s edge on the same physical side as that of scrolling box edge B.
◎
Let scrolling box edge C be the beginning edge in the inline base direction of scrolling box, and let element edge C be target bounding border box’s edge on the same physical side as that of scrolling box edge C.
◎
Let scrolling box edge D be the ending edge in the inline base direction of scrolling box, and let element edge D be target bounding border box’s edge on the same physical side as that of scrolling box edge D.
◎
Let element height be the distance between element edge A and element edge B.
◎
Let scrolling box height be the distance between scrolling box edge A and scrolling box edge B.
◎
Let element width be the distance between element edge C and element edge D.
◎
Let scrolling box width be the distance between scrolling box edge C and scrolling box edge D.
◎
Let position be the scroll position scrolling box would have by following these steps:
</div>
		<dl class="switch">
			<dt>`start$l</dt>
			<dd>
%~box の`開始辺$に，
%~target限界~box の`同じ側$の辺を整列する
◎
If block is "start", then align element edge A with scrolling box edge A.
</dd>

			<dt>`end$l</dt>
			<dd>
%~box の`終了辺$に，
%~target限界~box の`同じ側$の辺を整列する
◎
Otherwise, if block is "end", then align element edge B with scrolling box edge B.
</dd>

			<dt>`center$l</dt>
			<dd>
%~box の中心に， %~target限界~box の中心を整列する
◎
Otherwise, if block is "center", then align the center of target bounding border box with the center of scrolling box in scrolling box’s block flow direction.
</dd>

			<dt>`nearest$l</dt>
			<dd>
				<ol>
					<li>
%~target幅 ~LET
%~box の［`開始辺$, `終了辺$］と`同じ側$にある，
%~target限界~box を成す 2 辺の距離
◎
↑</li>
					<li>
%~box幅 ~LET
%~box の`開始辺$と`終了辺$の距離
◎
↑</li>
					<li>

<p>
%~box と %~target限界~box の位置関係に応じて：
◎
Otherwise, block is "nearest":
</p>

						<dl class="switch">
							<dt>
%~box の［
`開始辺$, `終了辺$
］どちらも，その外側に %~target限界~box の`同じ側$の辺がある
◎
If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
</dt>
							<dd>
何もしない
【現在の`~scroll位置$と同じ】
◎
Do nothing.
</dd>
							<dt>
［
%~box の`開始辺$の外側に
%~target限界~box の`同じ側$の辺がある
］~AND［
%~target幅 ~LT %~box幅
］
◎
If element edge A is outside scrolling box edge A and element height is less than scrolling box height 
</dt>

							<dt>
［
%~box の`終了辺$の外側に
%~target限界~box の`同じ側$の辺がある
］~AND［
%~target幅 ~GT %~box幅
］
◎
If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
</dt>
							<dd>
%~box の`開始辺$に，
%~target限界~box の`同じ側$の辺を整列する
◎
Align element edge A with scrolling box edge A.
</dd>

							<dt>
［
%~box の`開始辺$の外側に
%~target限界~box の`同じ側$の辺がある
］~AND［
%~target幅 ~GT %~box幅
］
◎
If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
</dt>
							<dt>
［
%~box の`終了辺$の外側に
%~target限界~box の`同じ側$の辺がある
］~AND［
%~target幅 ~LT %~box幅
］
◎
If element edge B is outside scrolling box edge B and element height is less than scrolling box height
</dt>
							<dd>
%~box の`終了辺$に，
%~target限界~box の`同じ側$の辺を整列する
◎
Align element edge B with scrolling box edge B.
</dd>
						</dl>
					</li>
				</ol>
			</dd>
		</dl>

<p class="en">
◎
• If inline is "start", then align element edge C with scrolling box edge C.
• Otherwise, if inline is "end", then align element edge D with scrolling box edge D.
• Otherwise, if inline is "center", then align the center of target bounding border box with the center of scrolling box in scrolling box’s inline base direction.
• Otherwise, inline is "nearest":
•• If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
••• Do nothing.
•• If element edge C is outside scrolling box edge C and element width is less than scrolling box width
•• If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
••• Align element edge C with scrolling box edge C.
•• If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
•• If element edge D is outside scrolling box edge D and element width is less than scrolling box width
••• Align element edge D with scrolling box edge D.
</p>

	</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の`~scroll位置$
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as scrolling box’s current scroll position, and scrolling box does not have an ongoing smooth scroll, then return.
</li>
	<li>
~IF［
%容器 は要素である
］
⇒
`~scrollを遂行する$( %~box, %目的位置, %要素, %挙動 )
◎
If scrolling box is associated with an element
• Perform a scroll of the element’s scrolling box to position, with the element as the associated element and behavior as the scroll behavior.
</li>
	<li>
~ELSE（ %容器 は`表示域$である）
⇒
`表示域の~scrollを遂行する$( %容器, %目的位置, %挙動 )
◎
If scrolling box is associated with a viewport
• （不要）Let document be the viewport’s associated Document.
• （不要）Let root element be document’s root element, if there is one, or null otherwise.
• Perform a scroll of the viewport to position, with root element as the associated element and behavior as the scroll behavior.
</li>
</ol>
</div>
</div>

<div class="algo">
<p>
`要素を~scrollする@
ときは、所与の
( %要素, %目的位置, %挙動 （省略時は `auto$l ） )
に対し，次を走らす：
◎
To scroll an element element to x,y optionally with a scroll behavior behavior (which is "auto" if omitted) means to:
</p>

<ol>
	<li>
%~box ~LET %要素 の`~scrollされる~box$
◎
Let box be element’s associated scrolling box.
</li>
	<li>
( %~x, %~y ) ~SET 目的位置の ( ~x, ~y ) ~~成分
◎
↓</li>
	<li>
%符号 ~LET %~box の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
◎
↓</li>
	<li>
%~x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %~x, %要素 の`~scrollされる区画$の横幅 ~MINUS %要素 の`~padding辺$の横幅 ) )
◎
If box has rightward overflow direction
• Let x be max(0, min(x, element scrolling area width - element padding edge width)).
◎
If box has leftward overflow direction
• Let x be min(0, max(x, element padding edge width - element scrolling area width)).
</li>
			<li>
%符号 ~LET %~box の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
◎
↓</li>
	<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, %要素 の`~scrollされる区画$の縦幅 ~MINUS %要素 の`~padding辺$の縦幅 ) )
◎
If box has downward overflow direction
• Let y be max(0, min(y, element scrolling area height - element padding edge height)).
◎
If box has upward overflow direction
• Let y be min(0, max(y, element padding edge height - element scrolling area height)).
</li>
	<li>
%目的位置 ~LET
`~scrollされる区画$の座標 ( %~x, %~y ) は
%~box の左上隅に整列されるような， %~box の`~scroll位置$
◎
Let position be the scroll position box would have by aligning scrolling area x-coordinate x with the left of box and aligning scrolling area y-coordinate y with the top of box.
</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の`~scroll位置$
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as box’s current scroll position, and box does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`~scrollを遂行する$( %~box, %目的位置, %要素, %挙動 )
◎
Perform a scroll of box to position, element as the associated element and behavior as the scroll behavior.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="extensions-to-the-htmlelement-interface">
<h2 title="Extensions to the HTMLElement Interface">7. `HTMLElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLElement$I {`HTMLElement^I0
  readonly attribute `Element$I? `offsetParent$m;
  readonly attribute `long$ `offsetTop$m;
  readonly attribute `long$ `offsetLeft$m;
  readonly attribute `long$ `offsetWidth$m;
  readonly attribute `long$ `offsetHeight$m;
};
</pre>

`HTMLElement^dgm

<div class="algo">
<p>
`offsetParent@m
取得子~手続きは：
◎
The offsetParent attribute must return the result of running these steps:
</p>
<ol>
	<li>
%~body ~LET コレの`~node文書$の`~body要素$
◎
↓</li>
	<li>
<p>
~IF［
コレは ~OR↓ を満たす
］…
◎
If any of the following holds true return null and terminate this algorithm:
</p>
		<ul>
			<li>
`~box$を持たない
◎
The element does not have an associated box.
</li>
			<li>
`根~要素$である
◎
The element is the root element.
</li>
			<li>
コレ ~EQ %~body
◎
The element is the body element.
</li>
			<li>
`position$p ~propの算出d値 ~EQ `fixed^v
◎
The element’s computed value of the position property is fixed.
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
↑</p>
	</li>
	<li>
%先祖 ~LET コレ
◎
↓</li>
	<li>
<p>
~WHILE［
`平坦~tree$における %先祖 の親~要素 %親 はある
］：
◎
Let ancestor be the parent of the element in the flat tree and repeat these substeps:
</p>
		<ol>
			<li>
%先祖 ~SET %親
◎
↑</li>
			<li>
<p>
~IF［
%先祖 は コレからは`閉な~shadowで非可視$である
］
⇒
~IF［
%先祖 の `position$p ~propの算出d値 ~EQ `fixed^v
］
⇒
~RET ~NULL
◎
If ancestor is closed-shadow-hidden from the element and its computed value of the position property is fixed, terminate this algorithm and return null.
</li>
			<li>
<p>
~ELIF［
~OR↓
］…
◎
If ancestor is not closed-shadow-hidden from the element and satisfies at least one of the following, terminate this algorithm and return ancestor.
</p>
				<ul>
					<li>
コレは［
`絶対~位置決め包含塊$／`固定d位置決め包含塊$
］を確立する
◎
The element is a containing block of absolutely-positioned descendants (regardless of whether there are any absolutely-positioned descendants).
</li>
					<li>
%先祖 ~EQ %~body
◎
It is the body element.
</li>
					<li>
［
コレの `position$p ~propの算出d値 ~EQ `static^v
］~AND［
%先祖 は［
`td^e, `th^e, `table^e
］いずれかの `~HTML要素$ である
］
◎
The computed value of the position property of the element is static and the ancestor is one of the following HTML elements: td, th, or table.
</li>
				</ul>
<p>
…ならば
⇒
~RET %先祖
◎
If there is no more parent of ancestor in the flat tree, terminate this algorithm and return null.
◎
Let ancestor be the parent of ancestor in the flat tree.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
［
`offsetTop@m ｜ `offsetLeft@m
］取得子~手続きは：
◎
The offsetTop attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレ ~EQ コレの`~node文書$の`~body要素$
］~OR［
コレは`~box$を持たない
］
⇒
~RET 0
◎
If the element is the body element or does not have any associated box return zero and terminate this algorithm.
</li>
	<li>
以下においては
⇒＃
どの座標も`初期~包含塊$の原点に相対的とする ／
コレとその先祖に対する`変形$は適用しないとする
◎
↓</li>
	<li>
%~border座標 ~LET コレの最初の`~box$の`~border辺$の［
上端の~y座標 ｜ 左端の~x座標
］
◎
If the offsetParent of the element is null return the y-coordinate of the top border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
</li>
	<li>
~IF［
コレの `offsetParent$m ~NEQ ~NULL
］
⇒
%~border座標 ~DECBY ( コレの `offsetParent$m の最初の`~box$の`~padding辺$の［
上端の~y座標 ｜ 左端の~x座標
］ )
◎
Return the result of subtracting the y-coordinate of the top padding edge of the first box associated with the offsetParent of the element from the y-coordinate of the top border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</li>
	<li>
~RET %~border座標
◎
↑</li>
</ol>
<p class="note">注記：
複数の行l~boxからなる`行内$要素については、
その最初の`~box$のみが考慮されることになる。
◎
Note: An inline element that consists of multiple line boxes will only have its first box considered.
</p>
</div>

<p class="en">
◎
The offsetLeft attribute must return the result of running these steps:
• If the element is the body element or does not have any associated box return zero and terminate this algorithm.
• If the offsetParent of the element is null return the x-coordinate of the left border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
• Return the result of subtracting the x-coordinate of the left padding edge of the first box associated with the offsetParent of the element from the x-coordinate of the left border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
<p>
［
`offsetWidth@m ｜ `offsetHeight@m
］取得子~手続きは：
◎
The offsetWidth attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレは`~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated box return zero and terminate this algorithm.
</li>
	<li>
<p>
~RET ［
コレの`首要~box$により生成される各`~box断片$の`~border~box$
］すべてを囲う，［
各辺が軸に整列された限界~box
］の［
横幅 ｜ 縦幅
］
— ここで：
◎
Return the width of the axis-aligned bounding box of the border boxes of all fragments generated by the element’s principal box,＼
</p>
		<ul>
			<li>
コレとその先祖に対する`変形$は適用しないとする。
◎
ignoring any transforms that apply to the element and its ancestors.
</li>
			<li>
要素の`首要~box$が`行内~levelの~box$であって，
ある`塊~level$の子孫により “分割され” ている場合、
そのような子孫により生成される断片のうち［
横幅, 縦幅どちらも 0 でないもの
］も含めるとする。
◎
If the element’s principal box is an inline-level box which was "split" by a block-level descendant, also include fragments generated by the block-level descendants, unless they are zero width or height.
</li>
		</ul>
	</li>
</ol>
</div>

<p class="en">
◎
The offsetHeight attribute must return the result of running these steps:
• If the element does not have any associated box return zero and terminate this algorithm.
• Return the height of the axis-aligned bounding box of the border boxes of all fragments generated by the element’s principal box, ignoring any transforms that apply to the element and its ancestors.
• If the element’s principal box is an inline-level box which was "split" by a block-level descendant, also include fragments generated by the block-level descendants, unless they are zero width or height.
</p>

	</section>
	<section id="excensions-to-the-htmlimageelement-interface">
<h2 title="Extensions to the HTMLImageElement Interface">8. `HTMLImageElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLImageElement$I {`HTMLImageElement^I0
  readonly attribute `long$ `x$m;
  readonly attribute `long$ `y$m;
};
</pre>

<div class="algo">
<p>
［
`x@m ｜ `y@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレは`~box$を持たない
］
⇒
~RET 0
</li>
	<li>
~RET `初期~包含塊$の原点に相対的な［
コレの最初の`~box$の`~border辺$
］の［
左端の~x座標 ｜ 上端の~y座標
］］
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</li>
</ol>
◎
The x attribute, on getting, must return the x-coordinate of the left border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no box.
◎
The y attribute, on getting, must return the y-coordinate of the top border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no box. 
</div>

	</section>
	<section id="extensions-to-the-range-interface">
<h2 title="Extensions to the Range Interface">9. `Range^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Range$I {`Range^I0
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();
};
</pre>

`Range^dgm

<div class="algo">
<p>
`getClientRects()@m
~method手続きは：
◎
The getClientRects() method, when invoked, must＼
</p>
<ol>
	<li>
~IF［
コレは文書~内を指していない
］
⇒
~RET 空な `DOMRectList$I ~obj
◎
return an empty DOMRectList object if the range is not in the document and＼
</li>
	<li>
<p>
~RET ［
次の拘束に合致するような `DOMRect$I ~obj
］からなる，内容~順の~listを包含する `DOMRectList$I ~obj：
◎
otherwise a DOMRectList object containing a list of DOMRect objects in content order that matches the following constraints:
</p>
		<ul>
			<li>
コレに`包含され$ている各 %要素 に対する
⇒
［
%要素 の `Element^I1 `getClientRects$m1 ~method手続き()
］の結果に含まれる`~border区画$たち
◎
For each element selected by the range, whose parent is not selected by the range, include the border areas returned by invoking getClientRects() on the element.
</li>
			<li>
<p>
コレに［
`部分的に包含され$ているか`包含され$ている†
］各 `Text$I ~node
（`始端$と`終端$が同じになるものも含まれる）に対する
⇒
（行l~box全体ではなく）選択された部分のみを囲む `DOMRect$I ~obj
◎
For each Text node selected or partially selected by the range (including when the boundary-points are identical), include a DOMRect object (for the part that is selected, not the whole line box).＼
</p>

<p class="trans-note">【†
`包含され$ている要素~内の `Text^I ~nodeも除外されないことになる。
】</p>

<p>
これらの `DOMRect$I ~objの限界域は、
~font計量を利用して算出される。
したがって，横書きの下では、
各~boxの［
縦幅は~fontの~ascentと~descent／
横幅は~textの送り幅
］から決定される。
コレの`中身$が `~typographic文字~単位$ `CSS-TEXT-3$r を部分的に含む場合
（例： 代用対の片割れや書記素~clusterの一部分）、
限界域を算出する目的においては，その`~typographic文字~単位$を全部的に含めるモノトスル。
要素の先祖に対する`変形$は、
適用される。
◎
The bounds of these DOMRect objects are computed using font metrics; thus, for horizontal writing, the vertical dimension of each box is determined by the font ascent and descent, and the horizontal dimension by the text advance width. If the range covers a partial typographic character unit (e.g. half a surrogate pair or part of a grapheme cluster), the full typographic character unit must be included for the purpose of computing the bounds of the relevant DOMRect. [CSS-TEXT-3] The transforms that apply to the ancestors are applied.
</p>

<p class="trans-note">【
“送り幅（ `advance^en ）”
— 対象~textが描画される起点から，後続の~textが同じ行lに描画されるとするときの，その起点までの長さ
】</p>
			</li>
		</ul>
	</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</p>
</div>

<div class="algo">
<p>
`getBoundingClientRect()@m
~method手続きは：
◎
The getBoundingClientRect() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
%~list ~LET コレの `getClientRects$m ~method手続き()
◎
Let list be the result of invoking getClientRects() on the same range this method was invoked on.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET 新たな `DOMRect$I ~obj
— その
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
	<li>
~IF［
%~list 内の矩形は，どれも［
横幅, 縦幅
］どちらかは 0
］
⇒
~RET %~list 内の最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
	<li>
~RET 次を表現する新たな `DOMRect$I ~obj
⇒
次をすべてを包含する最~小な矩形
⇒
%~list 内の［
横幅, 縦幅
］どちらかは【どちらも？】 0 でない矩形
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</p>
</div>

	</section>
	<section id="extensions-to-the-mouseevent-interface">
<h2 title="Extensions to the MouseEvent Interface">10. `MouseEvent^I ~interfaceに対する拡張</h2>

<p class="issue">
この~IDL片は、
一部の~memberを定義し直している。
これをどうにか解決できないか？
◎
The object IDL fragment redefines some members. Can we resolve this somehow?
</p>

<pre class="idl">
partial interface `MouseEvent$I {`MouseEvent^I0
  readonly attribute `double$ `screenX$m;
  readonly attribute `double$ `screenY$m;
  readonly attribute `double$ `pageX$m;
  readonly attribute `double$ `pageY$m;
  readonly attribute `double$ `clientX$m;
  readonly attribute `double$ `clientY$m;
  readonly attribute `double$ `x$m;
  readonly attribute `double$ `y$m;
  readonly attribute `double$ `offsetX$m;
  readonly attribute `double$ `offsetY$m;
};

partial dictionary `MouseEventInit$I {
  `double$ `screenX@mb = 0.0;
  `double$ `screenY@mb = 0.0;
  `double$ `clientX@mb = 0.0;
  `double$ `clientY@mb = 0.0;
};
</pre>

`MouseEvent^dgm

`MouseEvent^I0

<div class="algo">
［
`screenX@m ｜ `screenY@m
］取得子~手続きは
⇒
~RET `~Webに公開される~screen区画$の原点に相対的な，コレが生じた地点の［
~x座標 ｜ ~y座標
］
◎
The screenX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
◎
The screenY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
</div>

<div class="algo">
<p>
［
`pageX@m ｜ `pageY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
`初期~包含塊$の原点に相対的な，コレが生じた地点の［
~x座標 ｜ ~y座標
］
</li>
	<li>
%offset ~LET 0
</li>
	<li>
~IF［
コレに結付けられている `Window$I ~obj %window 【！＊】は在る
］
⇒
%offset ~SET %window の［
`scrollX$m1 ｜ `scrollY$m1
］取得子~手続き()
</li>
	<li>
%offset ~INCBY コレの［
`clientX$m ｜ `clientY$m
］取得子~手続き()
</li>
	<li>
~RET %offset
</li>
</ol>
◎
The pageX attribute must follow these steps:
• If the event’s dispatch flag is set, return the horizontal coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollX attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientX attribute. 
◎
The pageY attribute must follow these steps:
• If the event’s dispatch flag is set, return the vertical coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollY attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientY attribute. 
</div>

<div class="algo">
［
`clientX@m ｜ `clientY@m
］取得子~手続きは
⇒
~RET `表示域$の原点に相対的な，コレが生じた地点の［
~x座標 ｜ ~y座標
］
◎
The clientX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the viewport.
◎
The clientY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the viewport.
</div>

<div class="algo">
［
`x@m ｜ `y@m
］取得子~手続きは、［
`clientX$m ｜ `clientY$m
］取得子~手続きと同じに挙動する。
◎
The x attribute must return the value of clientX.
◎
The y attribute must return the value of clientY.
</div>

<div class="algo">
<p>
［
`offsetX@m ｜ `offsetY@m
］取得子~手続きは：
◎
The offsetX attribute must follow these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET 
要素とその先祖に対する`変形$は適用しない下で，
target ~nodeの`~padding辺$の原点に相対的な，コレが生じた地点の［
~x座標 ｜ ~y座標
］
◎
If the event’s dispatch flag is set, return the x-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
</p>

<p class="trans-note">【
target ~node：
コレの配送-先の~node（より明確には，~event伝播の中で `AT_TARGET$m に該当する~node）。
】</p>
	</li>
	<li>
~RET コレの［
`pageX$m ｜ `pageY$m
］取得子~手続き()
◎
Return the value of the event’s pageX attribute. 
</li>
</ol>
</div>

<p class="en">
◎
The offsetY attribute must follow these steps:
• If the event’s dispatch flag is set, return the y-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
• Return the value of the event’s pageY attribute. 
</p>

	</section>
	<section id="geometry">
<h2 title="Geometry">11. 幾何</h2>

<p class="trans-note">【
現時点で，この節を実装している~UAは無い。
】</p>

		<section id="the-geometryutils-interface">
<h3 title="The GeometryUtils Interface">11.1. `GeometryUtils^I ~interface</h3>

<pre class="idl">
enum `CSSBoxType@I { `margin@l, `border@l, `padding@l, `content@l };
dictionary `BoxQuadOptions@I {
  `CSSBoxType$I `box@mb = `border$l;
  `GeometryNode$I `relativeTo@mb; // XXX default document (i.e. viewport)
};

dictionary `ConvertCoordinateOptions@I {
  `CSSBoxType$I `fromBox@mb = `border$l;
  `CSSBoxType$I `toBox@mb = `border$l;
};

interface mixin `GeometryUtils@I {
  `sequence$&lt;`DOMQuad$I&gt; `getBoxQuads$m(
      optional `BoxQuadOptions$I %options = {}
  );
  `DOMQuad$I `convertQuadFromNode$m(
      `DOMQuadInit$I %quad,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMQuad$I `convertRectFromNode$m(
      `DOMRectReadOnly$I %rect,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMPoint$I `convertPointFromNode$m(
      `DOMPointInit$I %point,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  ); // XXX z,w turns into 0
};
 
`Text$I includes `GeometryUtils$I; // like Range
`Element$I includes `GeometryUtils$I;
`CSSPseudoElement$I includes `GeometryUtils$I;
`Document$I includes `GeometryUtils$I;

typedef (`Text$I or `Element$I or `CSSPseudoElement$I or `Document$I) `GeometryNode@I;
</pre>

<div class="algo">
<p>
`getBoxQuads(options)@m
~method手続きは：
◎
The getBoxQuads(options) method must run the following steps:
</p>
<ol>
	<li class="issue" lang="en">
DOM order
<p>p1 = top left even in RTL
<p>scale to 0 means divide by zero, return 0x0
<p>cross-frames not allowed, throw WrongDocumentError?
<p>points are flattened (3d transform), z=0. like getClientRect
<p>test block in inline
<p>pseudo-elements before/after are children of the element
<p>viewport boxes are all the same
</li>
</ol>
</div>

<div class="algo">
`convertQuadFromNode(quad, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertQuadFromNode(quad, from, options) method must run the following steps:
</div>

<div class="algo">
`convertRectFromNode(rect, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertRectFromNode(rect, from, options) method must run the following steps:
</div>

<div class="algo">
`convertPointFromNode(point, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertPointFromNode(point, from, options) method must run the following steps:
</div>

		</section>
	</section>
	<section id="visualViewport">
<h2 title="VisualViewport">12. `VisualViewport^I</h2>

		<section id="the-visualviewport-interface">
<h3 title="The VisualViewport Interface">12.1. `VisualViewport^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `VisualViewport@I : `EventTarget$I {`VisualViewport^I0
  readonly attribute `double$ `offsetLeft$m;
  readonly attribute `double$ `offsetTop$m;

  readonly attribute `double$ `pageLeft$m;
  readonly attribute `double$ `pageTop$m;

  readonly attribute `double$ `width$m;
  readonly attribute `double$ `height$m;

  readonly attribute `double$ `scale$m;

  attribute `EventHandler$I `onresize$m;
  attribute `EventHandler$I `onscroll$m;
  attribute `EventHandler$I `onscrollend$m;
};
</pre>

<p>
`VisualViewport$I ~objは、
`視覚-表示域$を表現する。
</p>

<p>
各 `VisualViewport$I ~objには、
`文書@vV
が結付けられる
— それは、
当の `VisualViewport$I の所有者 `Window$I に`結付けられている文書$を指す。
`~layout表示域$は、
所有者 `Window$I の`表示域$になる。
</p>

<p>
以下の記述に現れる［
当の`視覚-表示域$ ／
当の`~layout表示域$
］は、［
当の~obj（コレ）が表現している`視覚-表示域$ ／
その`~layout表示域$
］を指すとする。
</p>

<p class="trans-note">【
上の 3 つの段落のうち［
2 個目は 他所からここへ移動した／
他は この訳による補完
］。
】</p>

<div class="algo">
<p>
［
`offsetLeft@m ｜ `offsetTop@m
］
取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
</li>
	<li>
~RET 当の`~layout表示域$の［
左端｜上端
］辺から当の`視覚-表示域$の［
左端｜上端
］辺までの~offset
</li>
</ol>

◎
The offsetLeft attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the left edge of the visual viewport from the left edge of the layout viewport.
◎
The offsetTop attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the top edge of the visual viewport from the top edge of the layout viewport.
</div>

<div class="algo">
<p>
［
`pageLeft@m ｜ `pageTop@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
</li>
	<li>
~RET コレの`文書$vV【！`~layout表示域$の`文書$】の`初期~包含塊$の［
左端｜上端
］辺から当の`視覚-表示域$の［
左端｜上端
］辺までの~offset
</li>
</ol>

◎
The pageLeft attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the left edge of the visual viewport from the left edge of the initial containing block of the layout viewport’s document.
◎
The pageTop attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the top edge of the visual viewport from the top edge of the initial containing block of the layout viewport’s document.
</div>

<div class="algo">
<p>
［
`width@m ｜ `height@m
］取得子~手続きは：
◎
The width attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
◎
If the visual viewport’s associated document is not fully active, return 0.
</li>
	<li>
~RET 当の`視覚-表示域$の［
`有効~横幅$｜`有効~縦幅$
］†
◎
Otherwise, return the width of the visual viewport excluding the width of any rendered vertical classic scrollbar that is fixed to the visual viewport.
</li>
</ol>

<p class="note">注記：
結果の値は，
`px$u 単位なので、［
`~page~zoom$／`拡縮率$vV
］が増大したときは，減少することになる。
◎
Note: Since this value is returned in CSS pixels, the value will decrease in magnitude if either page zoom or the scale factor is increased.
</p>

<p class="note">注記†：
この~sizeから除外される`古典~scrollbar$は、
`視覚-表示域$に “固定されて” 描画される
— すなわち、
視覚-表示域が~zoomされても~panされても，その［
~size, 所在
］は変化しない。
【この仕様は、~UAがそのように描画するものと見做している。】
この値は， `px$u 単位なので、
~UAは，~scrollbarの［
横幅／縦幅
］を除外するときは，
`px$u 単位で測定した結果を織り込むモノトスル。
すなわち、
除外される量は［
拡大するときは減少する／
縮小するときは増大する
］。
◎
Note: A scrollbar that is fixed to the visual viewport is one that does not change size or location as the visual viewport is zoomed and panned. Because this value is in CSS pixels, when excluding the scrollbar width the UA must account for how large the scrollbar is as measured in CSS pixels. That is, the amount excluded decreases when zooming in and increases when zooming out.
</p>
</div>
<p class="en">
◎
The height attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the height of the visual viewport excluding the height of any rendered horizontal classic scrollbar that is fixed to the visual viewport.
</p>

<div class="algo">
<p>
`scale@m
取得子~手続きは：
◎
The scale attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
◎
If the visual viewport’s associated document is not fully active, return 0 and abort these steps.
</li>
	<li>
~IF［
出力~機器は無い
］
⇒
~RET 1
◎
If there is no output device, return 1 and abort these steps.
</li>
	<li>
~RET 当の`視覚-表示域$の`拡縮率$vV
◎
Otherwise, return the visual viewport’s scale factor.
</li>
</ol>
</div>

<p>
`onresize@m
は、
`resize$et ~event用の`~event~handler~IDL属性$である。
◎
onresize is the event handler IDL attribute for the resize event.
</p>

<p>
`onscroll@m
は、
`scroll$et ~event用の`~event~handler~IDL属性$である。
◎
onscroll is the event handler IDL attribute for the scroll event.
</p>

<p>
`onscrollend@m
は、
`scrollend$et ~event用の`~event~handler~IDL属性$である。
◎
onscrollend is the event handler IDL attribute for the scrollend event.
</p>

		</section>
	</section>
	<section id="events">
<h2 title="Events">13. ~event</h2>

		<section id="resizing-viewports">
<h3 title="Resizing viewports">13.1. 表示域の~size変更</h3>

<p>
この節は、
`HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<div class="algo">
<p>
`文書の~resize手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to run the resize steps for a Document doc, run these steps:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である
【この段は、この訳による補完】
</li>
	<li>
<p>
~IF［
当の`表示域$の［
横幅／縦幅
］は、
この手続きを最後に走らせたときから変化した†
］
⇒
`~eventを発火する$( %文書 を結付けている `Window$I ~obj, `resize$et )
</p>

<p>†
例
⇒＃
利用者が~browserの~UIwindowを~resizeしたとき／
`~page~zoom$が変化したとき／
`iframe^e 要素の寸法が変化したとき
</p>
◎
If doc’s viewport has had its width or height changed (e.g. as a result of the user resizing the browser window, or changing page zoom, or an iframe element’s dimensions are changed) since the last time these steps were run, fire an event named resize at the Window object associated with doc.
</li>
	<li>
%視覚-表示域 ~LET %文書 が結付けられた `VisualViewport$I
◎
↓</li>
	<li>
`VisualViewport^I1
~IF［
%視覚-表示域 の［
`scale$m ／ `width$m ／ `height$m
］~propは、
この手続きを最後に走らせたときから変化した
］
⇒
`~eventを発火する$( %視覚-表示域, `resize$et )
◎
If the VisualViewport associated with doc has had its scale, width, or height properties changed since the last time these steps were run, fire an event named resize at the VisualViewport.
</li>
</ol>
</div>

		</section>
		<section id="scrolling-events">
<h3 title="Scrolling">13.2. ~scroll法</h3>

<p>
この節は、
`HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
各 `文書$には、次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`処理待ち~scroll-ev~event~target群@
⇒
~listであり，初期~時は空とする。
◎
Each Document has an associated list of pending scroll event targets, initially empty.
</li>
	<li>
`処理待ち~scrollend-ev~event~target群@
⇒
~listであり，初期~時は空とする。
◎
Each Document has an associated list of pending scrollend event targets, initially empty.
</li>
</ul>

<div class="algo">
<p>
~UAは、［
`表示域$／要素
］が~scrollされる度に
（利用者とのヤリトリ, ~APIのどちらによるかを問わず），
次を走らすモノトスル：
</p>
<ol>
	<li>
%~target ~LET ［
`表示域$を~scrollしている場合は，それに結付けられている`文書$ ／
要素を~scrollしている場合は，当の要素
］
◎
↓</li>
	<li>
%文書 ~LET %~target に応じて
⇒＃
`文書$であるならば %~target ／
要素であるならば %~target の`~node文書$
</li>
	<li>
%~target群 ~LET %文書 の`処理待ち~scroll-ev~event~target群$
</li>
	<li>
~IF［
%~target ~IN %~target群
］
⇒
~RET
</li>
	<li>
%~target群 に %文書 を付加する
</li>
</ol>

◎
Whenever a viewport gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
• Let doc be the viewport’s associated Document.
• If doc is already in doc’s pending scroll event targets, abort these steps.
• Append doc to doc’s pending scroll event targets.
◎
Whenever an element gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
• Let doc be the element’s node document.
• If the element is already in doc’s pending scroll event targets, abort these steps.
• Append the element to doc’s pending scroll event targets.
</div>

<div class="algo">
<p>
`視覚-表示域$が~scrollされたときは、
（利用者とのヤリトリ, ~APIのどちらによるかを問わず）
次を走らすモノトスル：
◎
Whenever a visual viewport gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
</p>
<ol>
	<li>
%vv ~LET ~scrollされた`視覚-表示域$を表現する `VisualViewport$I ~obj
◎
Let vv be the VisualViewport object that was scrolled.
</li>
	<li>
%~target群 ~LET %vv の`文書$vVの`処理待ち~scroll-ev~event~target群$
◎
Let doc be vv’s associated document.
◎
↓</li>
	<li>
~IF［
%vv ~IN %~target群
］
⇒
~RET
◎
If vv is already in doc’s pending scroll event targets, abort these steps.
</li>
	<li>
%~target群 に %vv を付加する
◎
Append vv to doc’s pending scroll event targets.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書の~scroll手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to run the scroll steps for a Document doc, run these steps:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である
【この段は、この訳による補完】
</li>
	<li>
<p>
%文書 の`処理待ち~scroll-ev~event~target群$を成す
~EACH( %~target )
に対し：
◎
For each item target in doc’s pending scroll event targets, in the order they were added to the list, run these substeps:
</p>
		<ol>
			<li>
~IF［
%~target は`文書$である
］
⇒
`~eventを発火する$( %~target, `scroll$et )
— 次のように初期化して
⇒
`bubbles^m 属性 ~SET ~T
◎
If target is a Document, fire an event named scroll that bubbles at target.
</li>
			<li>
~ELSE
⇒
`~eventを発火する$( %~target, `scroll$et )
◎
Otherwise, fire an event named scroll at target.
</li>
		</ol>
	</li>
	<li>
%文書 の`処理待ち~scroll-ev~event~target群$を空にする
◎
Empty doc’s pending scroll event targets.
</li>
</ol>
</div>

<div class="algo">
<p>
~scrollを`完了-$したときは、
次を走らすモノトスル：
◎
Whenever scrolling is completed, the user agent must run these steps:
</p>

<p class="issue">
`scrollend^et ~eventは、
~scrollの［
開始, 完了
］どちらに基づく順序で配送されるのか？
◎
In what order are scrollend events dispatched? Ordered based on scroll start or scroll completion?
</p>

<ol>
	<li>
<p>
~scrollされた
~EACH( `~scrollされる~box$ %~box )
に対し：
◎
For each scrolling box box that was scrolled:
</p>
		<ol>
			<li>
%~target ~LET %~box の所属に応じて
⇒＃
`表示域$であるならば %~target が結付けられた`文書$／
`視覚-表示域$であるならば %~target を表現している `VisualViewport$I ~obj／
要素であるならば %~target
◎
↓</li>
			<li>
%文書 ~LET %~target に応じて
⇒＃
`文書$であるならば %~target ／
`VisualViewport$I ~objであるならば %~target の`文書$vV／
要素であるならば %~target の`~node文書$
◎
If box belongs to a viewport, let doc be the viewport’s associated Document and target be the viewport. If box belongs to a VisualViewport, let doc be the VisualViewport's associated document and target be the VisualViewport. Otherwise, box belongs to an element and let doc be the element’s node document and target be the element.
</li>
			<li>
%~target群 ~LET %文書 の`処理待ち~scrollend-ev~event~target群$
◎
↓</li>
			<li>
~IF［
%~target ~IN %~target群
］
⇒
~RET
◎
If target is already in doc’s pending scrollend event targets, abort these steps.
</li>
			<li>
%~target群 に %~target を付加する
◎
Append target to doc’s pending scrollend event targets.
</li>
		</ol>
	</li>
	<li>
%~target群 ~LET %文書 【どの文書？】の`処理待ち~scrollend-ev~event~target群$
◎
For each item target in doc’s pending scrollend event targets,＼
</li>
	<li>
<p>
%~target群 を成す
~EACH( %~target )
に対し：
◎
in the order they were added to the list, run these substeps:
</p>
		<ol>
			<li>
~IF［
%~target は`文書$である
］
⇒
`~eventを発火する$( %~target, `scrollend$et )
— 次のように初期化して
⇒＃
`bubbles^m 属性 ~SET ~T
◎
If target is a Document, fire an event named scrollend that bubbles at target.
</li>
	<li>
~ELSE
⇒
`~eventを発火する$( %~target, `scrollend$et )
◎
Otherwise, fire an event named scrollend at target.
</li>
		</ol>
	</li>
	<li>
%~target群 を空にする
◎
Empty doc’s pending scrollend event targets.
</li>
</ol>
</div>

		</section>
		<section id="event-summary">
<h4 title="Event summary">13.3. ~event要覧</h4>

◎非規範的

<div>
<table class="grid-table" id="_event-table"><thead>
<tr><th>~event
<th>~interface
<th>~target
<th>記述
<tbody>

<tr><td>`resize@et
<td>`Event$I
<td>`Window$I, `VisualViewport$I
<td>
<p>
［
`表示域$／`視覚-表示域$
］が~resizeされたとき，
当の［
`Window$I ／ `VisualViewport$I
］に向けて発火される。
</p>
<p>
`視覚-表示域$の`~layout表示域$が拡縮されたとき，
当の `VisualViewport$I に向けて発火される。
</p>

<tr><td>`scroll@et
<td>`Event$I
<td>`VisualViewport$I, `Document$I, `Element$I
<td>
［
`視覚-表示域$／`表示域$／要素
］が~scrollされたとき，
当の［
`VisualViewport$I ／ `Document$I ／ `Element$I
］に向けて発火される。

<tr><td>`scrollend@et
<td>`Event$I
<td>`VisualViewport$I, `Document$I, `Element$I
<td>
［
`視覚-表示域$／`表示域$／要素
］が~scrollされ，`完了-$したとき
— すなわち、
~scrollが終止して，~scroll~offsetの変化が適用された後に —
当の［
`VisualViewport$I ／ `Document$I ／ `Element$I
］に向けて発火される。
</table>
◎
Event｜Interface｜Interesting targets｜Description
◎
resize｜Event｜Window, VisualViewport｜Fired at the Window when the viewport is resized. Fired at VisualViewport when the visual viewport is resized or the layout viewport is scaled.
scroll｜Event｜VisualViewport, Document, elements｜Fired at the VisualViewport, Document or element when the VisualViewport, viewport, or element is scrolled, respectively.
scrollend｜Event｜Document, elements, VisualViewport｜Fired at the VisualViewport, Document, or element when a scroll is completed: the VisualViewport, viewport, or element has been scrolled, the scroll sequence has ended and any scroll offset changes have been applied.
</div>

		</section>
	</section>
	<section id="priv-sec">
<h2 title="Security and Privacy Considerations">~securityと~privacyの考慮点</h2>

<p>
`Screen$I ~interfaceは、
利用者の~display環境設定についての情報を公開する
— それは、
指紋収集~algoの入力として利用され得る。
利用者の~privacyを保護するためとして、
~UAは，~screen~sizeや環境設定についての情報を［
隠す／量子化する
］ことを選んでもヨイ。
◎
The Screen interface exposes information about the user’s display configuration, which maybe be used as input to fingerprinting algorithms. User agents may choose to hide or quantize information about the screen size or configuration, in order to protect the user’s privacy.
</p>

<p>
`MouseEvent$I ~eventは、
~screenに相対的な座標についての情報を包含する。
利用者の~privacyを保護するためとして、
~UAは，~eventの そのような~propを［
実際の~screenに相対的な所在
］を隠蔽するような値に設定してもヨイ。
◎
MouseEvent contains information about the screen-relative coordinates of the event. User agents may set these properties to values that obscure the actual screen-relative location of the event, in order to protect the user’s privacy.
</p>
	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
この節では、
この仕様の各~公表版の間の変更点の一部を文書化する。
この節は、
網羅的ではない。
~bug修正点や編集上の変更点は、
一般に，挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

<dl>
	<dt id="changes-from-2022-07-07">
2022年 7月 7日からの変更点
◎
Changes From 07 July 2022
</dt>
	<dd>
`VisualViewport$I ~APIと関係する概念を導入した。
◎
Introduced the VisualViewport API and related concepts
</dd>
	<dd>
~pinch~zoomを`拡縮率$vVに改称した。
◎
Pinch zoom is now renamed to scale factor
</dd>

	<dt id="changes-from-2022-06-22">
2022年 6月 22日からの変更点
◎
Changes From 22 June 2022
</dt>
	<dd>
【！Adam Argyle】
`WICG overscroll-scrollend-events＠https://wicg.github.io/overscroll-scrollend-events/$
から `scrollend$et ~eventを移動した。
◎
Adam Argyle moved the scrollend event from WICG overscroll-scrollend-events to [CSSOM-VIEW-1]
</dd>

	<dt id="changes-from-2020-10-19">
2020年 10月 19日からの変更点
◎
Changes From 19 October 2020
</dt>
	<dd>
`§ ~securityと~privacyの考慮点＠#priv-sec$
を追加した。
◎
Added the "Security and Privacy Considerations" section
</dd>
	<dd>
`§ 各種用語＠#terminology$
における論理的な誤りを修正した。
◎
Fixed a logical error in the Terminology section.
</dd>
	<dd>
`scroll-behavior$p ~propを `CSS-OVERFLOW-3$r へ移動した。
◎
Moved the scroll-behavior property to [CSS-OVERFLOW-3]
</dd>

	<dt id="changes-from-2020-01-31">
2020年 1月 31日 からの変更点
◎
Changes From 31 January 2020
</dt>

	<dd>
編集者に `Simon Fraser^en を追加した。
◎
Added Simon Fraser as editor
</dd>
	<dd>
`Window$I の `resizeTo()$m1 の引数を %width, %height に改称した。
（`課題 #4727＠~CSSissue/4727$）
◎
Renamed the arguments to resizeTo() to be width and height (4727)
</dd>

	<dt id="changes-from-2013-12-17">
2013年 12月 17日 から 2020年 1月 31日 までの変更点
◎
Changes From 17 December 2013 To 31 January 2020
</dt>
	<dd>
`Element$I 上の
`scrollIntoView()$m1 ~methodを変更して拡張した。
◎
The scrollIntoView() method on Element was changed and extended.
</dd>
	<dd>
`Element$I の［
`scrollTop$m1, `scrollLeft$m1
］~IDL属性は、
~objをとらないようにした
— 代わりに［
`scroll()$m1, `scrollTo()$m1, `scrollBy()$m1
］~methodを追加した。
◎
The scrollTop and scrollLeft IDL attributes on Element changed to no longer take an object; the scroll(), scrollTo() and scrollBy() methods were added instead.
</dd>
	<dd>
`Element$I の［
`scrollWidth$m1,
`scrollHeight$m1,
`clientTop$m1,
`clientLeft$m1,
`clientWidth$m1 
`clientHeight$m1
］~IDL属性は、
整数を返す~~元のふるまいに戻した。
◎
The scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth and clientHeight IDL attributes on Element were changed back to return integers.
</dd>
	<dd>
`DOMRectList^I ~interfaceを除去した。
◎
The DOMRectList interface was removed.
</dd>
	<dd>
`Document$I に `scrollingElement$m1 ~IDL属性を追加した。
◎
The scrollingElement IDL attribute on Document was added.
</dd>
	<dd>
`Window$I 上の一部の読専（ readonly ）属性に、
[Replaceable] ~IDL拡張d属性で注釈した。
◎
Some readonly attributes on Window were annotated with [Replaceable] IDL extended attribute.
</dd>
	<dd>
［
`MediaQueryList$I,
`scroll$et ~event,
`resize$et ~event
］を
— ~animation~frameに同期するよう —
~HTMLにおける`~event~loop$に統合した。
◎
MediaQueryList, scroll event and resize event are integrated with the event loop in HTML so they are synchronized with animation frames.
</dd>
	<dd>
`scroll-behavior$p の `instant^v 値を `auto^v に改称した。
◎
The instant value of scroll-behavior was renamed to auto.
</dd>
	<dd>
`Element$I の `scrollLeft$m1 の原点を（右横書き用に）変更した。
◎
The origin of scrollLeft on Element was changed (for RTL).
</dd>
	<dd>
`Element$I の `scrollIntoView()$m1 ~method, および
`Window$I の［
`scroll()$m1, `scrollTo()$m1, `scrollBy()$m1
］~methodは、
最初の引数に関連な辞書~型~値をとるようにした。
◎
The scrollIntoView() method on Element and scroll(), scrollTo() and scrollBy() methods on Window take the relevant dictionary as the first argument.
</dd>
	<dd>
`MediaQueryList$I ~interfaceを、
定例の~event~APIを利用し，それを通して `addListener()$m1 を定義するよう変更した。
◎
The MediaQueryList interface was changed to use regular event API and define addListener() in terms of that.
</dd>

	<dt id="changes-from-2011-08-04">
2011年 8月 4日 から 2013年 12月 17日 までの変更点
◎
Changes From 4 August 2011 To 17 December 2013
</dt>
	<dd>
右横書き（`行内~基底~方向$）と縦組みも取扱うようにした。
◎
The specification now handles right-to-left and vertical writing modes.
</dd>
	<dd>
［
`~page~zoom$, ~pinch~zoom
］を織り込んだ。
◎
The specification is now aware of page zoom and pinch zoom.
</dd>
	<dd>
`scroll-behavior$p ~CSS~propを導入して、
滑らかな~scrollを制御できるよう，~scroll用~APIを拡張した。
◎
The scroll-behavior CSS property is introduced and scrolling APIs are extended with a mechanism to control smooth scrolling.
</dd>
	<dd>
`Window$I の［
`moveTo()$m1,
`moveBy()$m1,
`resizeTo()$m1,
`resizeBy()$m1
］~methodを定義した。
◎
The moveTo(), moveBy(), resizeTo() and resizeBy() methods are now defined.
</dd>
	<dd>
`Window$I の `innerWidth$m1, 等々は、
~Web~IDL型 `long^c ではなく， `double^c を利用するようにした。
◎
innerWidth et al now use the WebIDL type double instead of long.
</dd>
	<dd>
`Window$I の `devicePixelRatio$m1 を定義した。
◎
devicePixelRatio is now defined.
</dd>
	<dd>
`window.open()^m
に対する %features 引数を定義した。
◎
The features argument to window.open() is now defined.
</dd>
	<dd>
`Screen$I の［
`colorDepth$m1, `pixelDepth$m1
］属性は、
24 を返すようにした。
◎
The colorDepth and pixelDepth attributes of Screen now always return 24.
</dd>
	<dd>
`Document$I 【！`Element^I】 に
`elementsFromPoint()$m1
~methodを導入した。
◎
The elementsFromPoint() method of Element is introduced.
</dd>
	<dd>
`変形$を織り込んだ。
◎
The specification is now aware of transforms.
</dd>
	<dd>
幾何~utility~APIをいくつか導入した
— が、
まだ仕様化していない。
◎
Some geometry utility APIs are introduced but are not yet specified.
</dd>
	<dd>
`ClientRect^I を `DOMRect^I に改称して、
`GEOMETRY-1$r 仕様に移動した。
◎
ClientRect has been renamed to DOMRect and has moved to the Geometry specification. [GEOMETRY-1]
</dd>
	<dd>
［
`resize$et, `scroll$et
］~eventの発火-時機について定義した。
◎
The specification now defines when the resize and scroll events fire. 
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この文書に貢献された次の方々に感謝する：
</p>

<p lang="en">
The editors would like to thank

Alan Stearns,
Alexey Feldgendler,
Antonio Gomes,
Björn Höhrmann,
Boris Zbarsky,
Chris Rebert,
Corey Farwell,
Dan Bates,
David Vest,
Elliott Sprehn,
Garrett Smith,
Henrik Andersson,
Hallvord R. M. Steen,
Kang-Hao Lu,
Koji Ishii,
Leif Arne Storset,
Luiz Agostini,
Maciej Stachowiak,
Michael Dyck,
Mike Wilson,
Morten Stenshorne,
Olli Pettay,
Pavel Curtis,
Peter-Paul Koch,
Rachel Kmetz,
Rick Byers,
Robert O’Callahan,
Sam Weinig,
Scott Johnson,
Sebastian Zartner,
Stewart Brodie,
Sylvain Galineau,
Tab Atkins,
Tarquin Wilton-Jones,
Thomas Moore,
Thomas Shinnick,
and
Xiaomei Ji

for their contributions to this document.
</p>

<p>
この草案にて指定された特能の多くを，Windows Internet Explorer ~browserにて最初に実装した Microsoft の人達に特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented many of the features specified in this draft, which were first widely deployed by the Windows Internet Explorer browser.
</p>

	</section>
</main></div>

<div id="_info-view">（クリックで消去）<pre id="_info-box"></pre></div>

