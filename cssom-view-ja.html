<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSSOM View Module （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<style>

.atrisk::before {
	float: right;
	content: '◀ 広く実装されてない';
	white-space: pre;
	font-size: small;
	padding: 0.5em;
	text-decoration: underline;
	background: white;
	color: gray;
}

#_info-view {
	position: fixed;
	z-index:10;
	display: none;
	padding: 0;
	bottom: 0;
	right: 0;
	min-width:20em;
	background: #FEE;
	outline: ridge gray 4px;
}
#_info-view.show {
	display: block;
}


._test {
	background: #EFE;
	color: green;
	border: ridge green 2px;
	padding: 0.5em;
}

.trans-note {
	font-weight: normal;
}

.en::before {
	content: "↑";
	color: gray;
}

.dictionary-member {
	color: var(--text-color-3);
}

.element::before,
.element::after {
	content: none;
}

.aR::before {
	content: "（";
}
.aR::after {
	content: "）";
}
.aR {
	color: gray;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let ctx_ifc = '';
	let ctx_ifc1 = ''; // interface for 'm1'

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if(indicator === '@'){
		ctx_ifc = key;
	} else {
		ctx_ifc1 = key;
	}
	href = `#${key.toLowerCase()}`;
	break;
case 'I0':
	ctx_ifc = key;
	return '';
	break;
case 'I1':
	ctx_ifc1 = key;
	return '';
	break;
case 'mc':
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`;
	text = 'constructor';
	break;
case 'm1':
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
		const ifc = ( klass === 'm1' ) ? ctx_ifc1: ctx_ifc
		href = `#dom-${ifc}-${key}`.toLowerCase();
	}
	break;
case 'opf':
case 'l':
	text = `"<code class="literal">${text}</code>"`
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}

</script>


<!--%testing demos -->
<script>

Util.DEFERRED.push(init2);

function init2(){
	repeat('input[data-params]', (e) => {
		const event = e.getAttribute('data-event') || 'click';
		e.addEventListener(event, display_attrs, false);
	});

	const DATA = {
		Window:{
			event_type: ['scroll', 'resize'],
			obj(){return window;},
			attrs: 'screen innerWidth innerHeight scrollX pageXOffset scrollY pageYOffset screenX screenY outerWidth outerHeight devicePixelRatio'
		},

		MediaQueryList:{
			obj(){
  const v = E('_test-mql_text').value.replace(/\'/g, '\"');
  this.src = 'window.matchMedia(\'' + v + '\')';
  return window.matchMedia(v);
},
			attrs: 'media matches'
		},

		Screen:{
			obj(){ return window.screen; },
			attrs: 'availWidth availHeight width height colorDepth pixelDepth'
		},

		'Element.scrollIntoView':{
			obj(){
				const top = E('_test-scrollIntoView-top').checked;
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= var tag_name= ..., top = ... ;
  var e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView(top);//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView(${top})
（クリックで元の位置へ復帰）`
				);
}
		},

		'Element.scrollIntoView0':{
			obj(){
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const behavior = E('_test-scrollIntoView-behavior').value;
				const block = E('_test-scrollIntoView-block').value;
				const inline = E('_test-scrollIntoView-inline').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= const tag_name= ... , behavior = ... , block = ... ;
  let e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView({
    behavior: behavior,
    block: block,
    inline: inline
  });//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView( { behavior: "${behavior}", block: "${block}" } )
（クリックで元の位置へ復帰）`
				);
}
		},

		'Window.scroll':{
			obj(){
				let x, y, e;
				e = E('_test-scroll-x');
				e.value = x = parseInt(e.value);
				e = E('_test-scroll-y');
				e.value = y = parseInt(e.value);
				
				const pos = {x: window.scrollX, y: window.scrollY};
				let method_name = '';
				repeat('input[name="_test-scroll-fn"]', (e) => {
					if(e.checked){
						method_name = e.id.slice('_test-scroll-'.length);
					}
				})
				if(!method_name) return;
//=
	window[method_name](x, y);//=

					revert_pos = pos;
					return(
`${method_name}(${x},${y})
（クリックで元の位置へ復帰）`
					);
			}
		},

		Element:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight'
		},

		HTMLElement:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'offsetParent offsetTop offsetLeft offsetWidth offsetHeight'
		},

		'Selection.getBoundingClientRect':{
			event_type: ['mousemove', 'keyup'],

// https://developer.mozilla.org/en-US/docs/DOM/Selection
// chrome はテキスト未選択時に getRangeAt がエラーを投出
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getBoundingClientRect();//=
			},
			attrs: 'top right bottom left width height'
		},

		'Selection.getClientRects':{
			event_type: ['mousemove', 'keyup'],
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getClientRects();//=
},
			attrs: 'length'
		},

		MouseEvent:{
			event_type: 'mousemove',
			obj(event){return event;},
			attrs: 'screenX screenY pageX pageY clientX clientY x y offsetX offsetY'
		},

		ClientRect:{
			event_type: 'mouseover',
			obj(event){return event.target.getBoundingClientRect();},
			attrs: 'top right bottom left width height'
		},

		getClientRects:{
			event_type: 'mouseover',
			obj(event){return event.target.getClientRects();},
			attrs: 'length'
		},

		elementFromPoint:{
			event_type: 'mousemove',
			obj(event){
  select(//=
    document.elementFromPoint(event.clientX, event.clientY)//=
  );
}
		},

		elementsFromPoint:{
			event_type: 'mousemove',
			obj(event){
				return(//=
document
  .elementsFromPoint(event.clientX, event.clientY)
  .map((e) => {return e.tagName;})
  .join(', ')//=
				);
			},
		},

		caretPositionFromPoint:{
			event_type: 'mousemove',
			obj(event){
  return document.caretPositionFromPoint(event.clientX, event.clientY);
},
			attrs: 'offsetNode offset'
		},

		NULL:{}
	};

	let revert_pos = null;
	let interface_name = null;
	let current_elem = null;

//	display_attrs = 
	function display_attrs(event){
		const key = event.currentTarget.getAttribute('data-params');
		interface_name = key;
		revert_pos = null;

		window.addEventListener('click', disable_view, true);
		if(! ('event_type' in DATA[key])) {
			show_attrs();
			interface_name = null;
			return;
		}
		switch(key){
		case 'Window':
		case 'Selection.getBoundingClientRect':
		case 'Selection.getClientRects':
			show_attrs();
		}
		enable_listener(true);
	}

	E('_test-mql_text').onfocus = () => {
		E('_test-mql_text').onfocus = null;
		const mql_options = E('_MQL_options');
		for( const mq of mql_options.firstChild.data.split(';') ){
			const option = C('option');
			option.textContent = mq.trim();
			mql_options.appendChild(option);
		};
	}

return;

//	var select = document.body.classList ? select1 : function(){};
	function select(e){
		hilight(false);
		current_elem = e;
		hilight(true);
		function hilight(h){
			if(!current_elem) return;
			// outline style はどの要素からも利用されていないものと見なす
			current_elem.style.outline = h ? 'solid red 1px' : '';
		}
	}

	function enable_listener(enable){
		let types = interface_name && DATA[interface_name].event_type;
		if(!types) return;
		if(typeof(types) === 'string'){
			types = [types];
		}
		for( const type of types){
			enable?
				window.addEventListener(type, show_attrs, false):
				window.removeEventListener(type, show_attrs, false);
		}
	}

	function disable_view(event){
		E('_info-view').className = '';
		enable_listener(false);
		window.removeEventListener('click', disable_view, true);
		select(null);
		if(revert_pos) {
			if(!event.target.onclick){
				window.scrollTo(revert_pos.x, revert_pos.y);
			}
			revert_pos = null;
		}
	}

	function show_attrs(event){
		let obj;
		const data = DATA[interface_name];
		try {
			obj = data.obj(event);
		} catch(e){
			show_text(
`次の実行に失敗：
  ${source_of(data)}`
			);
			enable_listener(false);
			return;
		}
		if(!obj) return;
		let texts = [];
		if(typeof(obj) === 'string'){
			texts[0] = obj;
		} else if('attrs' in data){
			texts = ['● オブジェクト：', source_of(data), '● 属性：'];
			let attrs = data.attrs;
			if(typeof(attrs) === 'string'){
				attrs = data.attrs = attrs.split(' ');
			}
			for( const name of attrs ){
				texts.push(
`${(name + '                     ').slice(0, 18)}:${obj[name]}`
				)
			};
		}
		if(event && (event.type === 'mouseover')){
			select(event.target);
		}
		show_text(texts.join('\n'));
	}
	
	function show_text(text){
		E('_info-box').textContent = text;
		E('_info-view').className = 'show';
	}

	function source_of(data){
		if('src' in data) return data.src;
		const s = data.obj.toString ?
			data.obj.toString() : '(ソースコードを取得できません。)';
		const m = s.match(/\/\/=([^\0]+)\/\/=|return\s([^;}]+)/);
		return data.src = ((m && (m[1] || m[2])) || s).trim();
	}

}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSSOM View Module
spec_date:2022-02-15
trans_update:2022-02-16
source_checked:210802
page_state_key:CSS
original_url:https://drafts.csswg.org/cssom-view-1/
	abbr_url:CSSOMVIEW
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2022,permissive
trans_1st_pub:2012-09-22


●●class_map
e:element
a:attr
et:event-type
mb:dictionary-member
p:property
d:descriptor
css:css
v:value
u:unit
aR:aR
op:op

●●tag_map
I:code
m:code
m1:code
mb:code
mc:code
et:code
e:code
a:code
p:code
d:code
css:code
c:code
v:code
u:code
aR:span
b:b
op:span

●●original_id_map

●●mdn_urls

mediaquerylist:API/MediaQueryList
mediaquerylistevent:API/MediaQueryListEvent
screen:API/Screen
caretposition:API/CaretPosition
geometryutils:API/GeometryUtils
dictdef-scrolltooptions:API/ScrollToOptions
	dictdef-scrolloptions:API/ScrollOptions
	dictdef-mediaquerylisteventinit:API/MediaQueryListEventInit
	dictdef-scrollintoviewoptions:API/ScrollIntoViewOptions
	dictdef-boxquadoptions:API/BoxQuadOptions
	dictdef-convertcoordinateoptions:API/ConvertCoordinateOptions
	enumdef-scrollbehavior:API/ScrollBehavior
	enumdef-scrolllogicalposition:API/ScrollLogicalPosition
	enumdef-cssboxtype:API/CSSBoxType
	typedefdef-geometrynode:API/GeometryNode

eventdef-window-resize:API/Window/resize_event
eventdef-document-scroll:API/Document/scroll_event
	eventdef-mediaquerylist-change:API/MediaQueryLis/change_event

●●link_map

	●IDL
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject
Replaceable:~WEBIDLjs#Replaceable
Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
double:~WEBIDL#idl-double
unsigned long:~WEBIDL#idl-unsigned-long
unrestricted double:~WEBIDL#idl-unrestricted-double
sequence:~WEBIDL#idl-sequence
CSSOMString:~CSSOM1#cssomstring

I.ScrollBehavior:#enumdef-scrollbehavior
I.ScrollOptions:#dictdef-scrolloptions
I.ScrollToOptions:#dictdef-scrolltooptions
I.MediaQueryList:#mediaquerylist
I.MediaQueryListEvent:#mediaquerylistevent
I.MediaQueryListEventInit:#dictdef-mediaquerylisteventinit

I.ScrollLogicalPosition:#enumdef-scrolllogicalposition
I.ScrollIntoViewOptions:#dictdef-scrollintoviewoptions
I.IsVisibleOptions:#dictdef-isvisibleoptions

I.Screen:#screen
I.CaretPosition:#caretposition
I.CSSBoxType:#enumdef-cssboxtype
I.BoxQuadOptions:#dictdef-boxquadoptions
I.ConvertCoordinateOptions:#dictdef-convertcoordinateoptions
I.GeometryUtils:#geometryutils
I.GeometryNode:#typedefdef-geometrynode

I.Window:~WINDOW#window

I.Document:~DOM4#document
I.Element:~DOM4#element
I.Text:~DOM4#text
I.Node:~DOM4#node
I.Range:~DOM4#range

I.EventTarget:~DOM4#eventtarget
I.EventListener:~DOM4#callbackdef-eventlistener
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.HTMLElement:~HTMLdom#htmlelement
I.WindowProxy:~WINDOW#windowproxy
I.HTMLImageElement:~HEimages#htmlimageelement
I.EventHandler:~WAPI#eventhandler

I.MouseEvent:~UIEVENTS#mouseevent
I.MouseEventInit:~UIEVENTS#dictdef-mouseeventinit

I.CSSPseudoElement:~CSSPSEUDO#csspseudoelement

I.DOMPoint:~GEOMETRY#dompoint
I.DOMPointInit:~GEOMETRY#dictdef-dompointinit
I.DOMRect:~GEOMETRY#domrect
I.DOMRectList:~GEOMETRY#domrectlist
I.DOMRectReadOnly:~GEOMETRY#domrectreadonly
I.DOMQuad:~GEOMETRY#domquad
I.DOMQuadInit:~GEOMETRY#dictdef-domquadinit

m.AT_TARGET:~DOM4#dom-event-at_target
	bubbles:~DOM4#
m.removeEventListener:~DOM4#dom-eventtarget-removeeventlistener
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.isTrusted:~DOM4#dom-event-istrusted
	m.type:~DOM4#dom-event-type
m.open:~WINDOW#dom-window-open
m.~doc-open:~HTMLdynamic#dom-document-open-window
	原文誤）m.open:~HTMLdynamic#dom-document-open
m.defaultView:~WINDOW#dom-document-defaultview

mb.block:#dom-scrollintoviewoptions-block
mb.inline:#dom-scrollintoviewoptions-inline
mb.behavior:#dom-scrolloptions-behavior
mb.left:#dom-scrolltooptions-left
mb.top:#dom-scrolltooptions-top

mb.media:#dom-mediaquerylisteventinit-media
mb.matches:#dom-mediaquerylisteventinit-media
mb.box:#dom-boxquadoptions-box
mb.relativeTo:#dom-boxquadoptions-relativeto
mb.fromBox:#dom-convertcoordinateoptions-frombox
mb.toBox:#dom-convertcoordinateoptions-tobox

	mb.screenX:#dom-mouseeventinit-
	mb.screenY
	mb.clientX
	mb.clientY


opf.width:#supported-open-feature-name-width
opf.height:#supported-open-feature-name-height
opf.left:#supported-open-feature-name-left
opf.top:#supported-open-feature-name-top

et.resize:#eventdef-window-resize
et.scroll:#eventdef-document-scroll

l.auto:#dom-scrollbehavior-auto
l.smooth:#dom-scrollbehavior-smooth

l.start:#dom-scrolllogicalposition-start
l.center:#dom-scrolllogicalposition-center
l.end:#dom-scrolllogicalposition-end
l.nearest:#dom-scrolllogicalposition-nearest

l.margin:#dom-cssboxtype-margin
l.border:#dom-cssboxtype-border
l.padding:#dom-cssboxtype-padding
l.content:#dom-cssboxtype-content

e.body:~HEsections#the-body-element

et.change:#eventdef-mediaquerylist-change

	●css
u.px:~CSSVAL#px

d.color:~MQ4#descdef-media-color
	#mf-colors

p.content-visibility:~CSSCONTAIN#propdef-content-visibility
p.position:~CSSPOS#propdef-position
p.direction:~CSSWM#propdef-direction
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.display:~CSSDISP#propdef-display
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.scroll-behavior:~CSSOVERFLOW3#propdef-scroll-behavior
p.pointer-events:~CSSUI#propdef-pointer-events

v.smooth:~CSSOVERFLOW3#valdef-scroll-behavior-smooth

v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden
v.visible:~CSSOVERFLOW3#valdef-overflow-visible
v.clip:~CSSOVERFLOW3#valdef-overflow-clip

v.table:~CSSDISP#valdef-display-table
v.inline-table:~CSSDISP#valdef-display-inline-table
v.table-column:~CSSDISP#valdef-display-table-column
v.table-column-group:~CSSDISP#valdef-display-table-column-group


	●用語
同じ側:#_same-side
有効~横幅:#_effective-width
有効~縦幅:#_effective-height
文書:#_document
接触判定:#_hit-testing
~window用の~scroll手続き:#_window-scroll-steps
要素~用の~scroll手続き:#_element-scroll-steps

内容~辺:#content-edge
~padding辺:#padding-edge
~border辺:#border-edge
~margin辺:#margin-edge
表示域:#viewport
	内容~辺:~CSSBOX#content-edge
	~margin辺:~CSSBOX#margin-edge
	~border辺:~CSSBOX#border-edge
	~padding辺:~CSSBOX#padding-edge
	表示域:~CSS2VISUREN#viewport

開始辺:#beginning-edges
終了辺:#ending-edges
根~要素:#root-element

~supportされる~open_m特能~名:#supported-open-feature-name
媒体~query~list:#media-query-list
mq.媒体:#mediaquerylist-media
mq.文書:#mediaquerylist-document
mq.合致-状態:#mediaquerylist-matches-state
有限~値に正規化する:#normalize-non-finite-values
~page~zoom:#page-zoom
~pinch~zoom:#pinch-zoom

~scrollされる区画:#scrolling-area
~scrollされる~box:#scrolling-box
~scroll可能になり得る:#potentially-scrollable
~scroll可能になり得ない:#potentially-scrollable
~scroll処理待ち~list:#pending-scroll-event-targets
要素を~scrollする:#scroll-an-element
瞬時に~scrollする:#concept-instant-scroll
滑らかに~scrollする:#concept-smooth-scroll
滑らか:#concept-smooth-scroll
滑らかな~scroll:#concept-smooth-scroll
~scrollを遂行する:#perform-a-scroll
~viewの中へ~scrollする:#scroll-an-element-into-view
文書の開始位置に~scrollする:#scroll-to-the-beginning-of-the-document
中止-:#smooth-scroll-aborted
完了-:#smooth-scroll-completed

原点:#scrolling-area-origin

機器~pixel比を決定する:#determine-the-device-pixel-ratio

変形:#transforms

~layout~box:#layout-box
~CSS~layout~box:#css-layout-box
~SVG~layout~box:#svg-layout-box
	媒体~query~list ~listenerの~list:#list-of-media-query-list-listeners
	媒体~query~list :#media-query-list
~caret位置:#caret-position
~caret~node:#caret-node
~caret~offset:#caret-offset
~caret範囲:#caret-range

~overflow方向:#overflow-directions

~Webに公開される~screen区画:#web-exposed-screen-area
~Webに公開される可用な~screen区画:#web-exposed-available-screen-area

~HTML~body要素:#the-html-body-element
~body要素:~HTMLdom#the-body-element-2
閲覧文脈の特能を設定しておく:#set-up-browsing-context-features

文書~用の媒体~queryを評価して変化を報告する:#evaluate-media-queries-and-report-changes
文書の~resize手続き:#run-the-resize-steps
文書の~scroll手続き:#run-the-scroll-steps

	●用語（CSS
~CSS~pixel:~CSSVAL#px

内容~区画:~CSSBOX#content-area
~border~box:~CSSBOX#border-box
媒体~query~listとして構文解析する:~CSSOM1#parse-a-media-query-list
	媒体~query~listを直列化する:~CSSOM1#serialize-a-media-query-list

首要~box:~CSSDISP#principal-box
行内~levelの~box:~CSSDISP#inline-level-box
塊~level:~CSSDISP#block-level

塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end
塊~flow方向:~CSSWM#block-flow-direction
行内~基底~方向:~CSSWM#inline-base-direction

~box断片:~CSSBREAK#box-fragment

平坦~tree:~CSSSCOPING#flat-tree

内容-分布~prop:~CSSALIGN#content-distribution-properties


	■補完
~border区画:~CSSBOX#border-area
包含塊:~CSSDISP#containing-block
匿名:~CSSDISP#anonymous
塊~box:~CSSDISP#block-box
行内:~CSSDISP#inline
初期~包含塊:~CSSDISP#initial-containing-block
置換d要素:~CSSDISP#replaced-element
~box~tree:~CSSDISP#box-tree

絶対~位置決め包含塊:~CSSPOS#absolute-positioning-containing-block
固定d位置決め包含塊:~CSSPOS#fixed-positioning-containing-block
~flow外:~CSSDISP#out-of-flow

~typographic文字~単位:~CSSTEXT#typographic-character-unit
書記素~cluster:~CSSTEXT#grapheme-cluster

	●用語（外部


~map:~INFRA#ordered-map
符号単位:~INFRA#code-unit

~live:~HTMLINFRA#live
~HTML要素:~HTMLINFRA#html-elements
一致する:~INFRA#string-is
文字大小区別:~INFRA#string-is
整数として構文解析する:~HTMLcms#rules-for-parsing-integers

閲覧文脈:~BROWSERS#browsing-context
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
作動中の文書:~BROWSERS#active-document

結付けられている文書:~WINDOW#concept-document-window
対応する閲覧文脈:~WINDOW#window-bc

同一-生成元:~ORIGIN#same-origin

~event~loop:~WAPI#event-loop
~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
関連な大域~obj:~WAPI#concept-relevant-global
描画を更新する段:~WAPI#update-the-rendering

~event~listener:~DOM4#concept-event-listener
evL.type:~DOM4#event-listener-type
evL.callback:~DOM4#event-listener-callback
evL.capture:~DOM4#event-listener-capture
~event~listener~list:~DOM4#eventtarget-event-listener-list
~event~listenerを追加する:~DOM4#add-an-event-listener
~event~listenerを除去する:~DOM4#remove-an-event-listener
~eventを発火する:~DOM4#concept-event-fire
ev.配送-中か:~DOM4#dispatch-flag
過去互換~mode:~DOM4#concept-document-quirks

包含され:~DOM4#contained
部分的に包含され:~DOM4#partially-contained
中身:~DOM4#concept-range-content
境界点:~DOM4#concept-range-bp

始端:~DOM4#concept-range-start
終端:~DOM4#concept-range-end
始端~node:~DOM4#concept-range-start-node
始端~offset:~DOM4#concept-range-start-offset

	文書:~DOM4#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element
~shadowも含む広義-先祖:~DOM4#concept-shadow-including-inclusive-ancestor

閉な~shadowで非可視:~DOM4#concept-closed-shadow-hidden

	●追加
畳まれて:~DOM4#range-collapsed
内容が飛ばされ:~CSSCONTAIN#skips-its-contents

●●words_table1

open_m: <code>open()</code>
doc-open:open

●●words_table


代用対:surrogate pair::サロゲートペア:
	セット:set
		→ ON, OFF

	●CSS layout
	viewport
ascent::::アセント
descent::::ディセント
断片:fragment::~
col:column
限界:bounding::~
限界域:bounds::~
要素境界:element bounding border box::~
縦組み:vertical writing mode::~
描画面:rendering surface::~
中身:content::~
横書き:horizontal writing::~
整列-:align::~
整列:alignment::~
固定d:fixed::固定
分布:distribution::~
首要:principal::主要

	●塗り
alpha::::アルファ
塗られ:paintされ:~
塗り:paint:~

	最~上端:topmost

	●scroll／UI
目的位置:position:~
bar::::バー
zoom::::ズーム
	zoom法:zooming
拡大:zoom::~
caret::::キャレット
pinch::::ピンチ
滑らか:smooth::~
倍率:scale factor:~
処理待ち:pending:~
接触判定:hit-testing::~
挿入位置指示:insertion point indicator:~
瞬時:instant::~
計量:metric:~
周期:interval:~
進行中:ongoing:~
touch::::タッチ
	複~touch
	~scrollされる〜:scrolling〜
	~scroll法:scrolling
	~~位置

	●幾何
幾何:geometry:~
地点:position:~
点:point:~
右横書き:right-to-left:~
	右横書き:RTL
横方向:horizontal::~
縦方向:vertical::~
上辺:top edge::~
下辺:bottom edge::~
左辺:left edge::~
右辺:right edge::~
上方:upward::~
下方:downward::~
左方:leftward::~
右方:rightward::~
中心:center::~
開始辺:beginning edge::~
終了辺:ending edge::~
	innermost, outermost
矩形:rectangle:~
四辺形:quadrilateral shape:~
変形:transform::~
	transforms
増大-:increase:~
比:ratio:~

	各辺が軸に整列された:axis-aligned

	●DOM／IDL
現任:incumbent:~
閉な:closed::閉じた
shadow:
平坦:flat::~
拡張属性:extended attribute::~
補助:auxiliary:~
境界点:boundary point::~

	●仕様
utility::ユーティリティ
見積もり:estimation:~
網羅的:exhaustive:~
誤り:error:~

	により定義される:-defined
	詳細:specifics
	に配慮する:considerations
	知られ:known to
	~~正しい:right
	~~適度な:not get too 〜
	ふりをする:masquerade
	選んで:chooseして

	●構文
剥いだ:stripした:~

	●未分類
非可視:hidden:~
隠す:hideする:~
assoc:associated:関連
body:
色:color:~
色域:color gamut:~
深度:depth:~
割振られ:allocateされ:割り振られ
標的:target:~
切詰める:clampする:切り詰める
書記素:grapheme::~
typographic::::タイポグラフィック
	片割れ:half
	合致-状態:matches state
選択-:select:~
担当の:responsible:~
座標軸:axis::~
素片:fragment::~
量子化-:quantize:~
隠蔽-:obscure:~
display::::ディスプレイ
分割-:split:~
浮動小数点:floating point::~
広義-:inclusive:~

	magnifying
	揃え／align
	`一致する$かどうかにより:is
	~Web~IDL:WebIDL


●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. 24 December 2021. WD. URL: https://www.w3.org/TR/css-align-3/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. 21 April 2020. WD. URL: https://www.w3.org/TR/css-box-4/
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. 26 July 2021. CR. URL: https://www.w3.org/TR/css-backgrounds-3/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/
[CSS-DEVICE-ADAPT]
    Rune Lillesveen; Florian Rivoal; Matt Rakow. ＜CSS Device Adaptation Module Level 1＞. 29 March 2016. WD. URL: https://www.w3.org/TR/css-device-adapt-1/
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Display Module Level 3＞. 3 September 2021. CR. URL: https://www.w3.org/TR/css-display-3/
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 3＞. 17 December 2020. CR. URL: https://www.w3.org/TR/css-images-3/
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. 23 December 2021. WD. URL: https://www.w3.org/TR/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. 16 December 2021. WD. URL: https://www.w3.org/TR/css-position-3/
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. 31 December 2020. WD. URL: https://www.w3.org/TR/css-pseudo-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. 3 April 2014. WD. URL: https://www.w3.org/TR/css-scoping-1/
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. ＜CSS Text Module Level 3＞. 22 April 2021. CR. URL: https://www.w3.org/TR/css-text-3/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/
[CSS-VALUES]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. 16 December 2021. WD. URL: https://www.w3.org/TR/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/
[CSS3-BOX]
    Elika Etemad. ＜CSS Box Model Module Level 3＞. 22 December 2020. CR. URL: https://www.w3.org/TR/css-box-3/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. 26 August 2021. WD. URL: https://www.w3.org/TR/cssom-1/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[GEOMETRY-1]
    Simon Pieters; Chris Harrelson. ＜Geometry Interfaces Module Level 1＞. 4 December 2018. CR. URL: https://www.w3.org/TR/geometry-1/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. 20 October 2021. WD. URL: https://www.w3.org/TR/uievents/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. 16 March 2021. WD. URL: https://www.w3.org/TR/css-ui-4/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSSOM View Module</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/cssom-view-1/
公表履歴
	https://www.w3.org/standards/history/cssom-view-1
旧公表バージョン
	https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/
編集者草案
	https://drafts.csswg.org/cssom-view/
テスト一式
	http://test.csswg.org/suites/cssom-view-1_dev/nightly-unstable/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/cssom-view-1">CSSWG Issues Repository</a>

編集
	<a href="mailto:simon.fraser@apple.com">Simon Fraser</a> (Apple Inc)
	<a href="emilio@mozilla.com">Emilio Cobos Álvarez</a> (Mozilla)
前任編集者
	<a href="mailto:simonp@opera.com">Simon Pieters</a> (<a href="http://www.opera.com">Opera Software AS</a>)
	<a href="https://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (<a href="http://www.cox.com">Cox Communications, Inc.</a>) <a href="mailto:glenn.adams@cos.com">glenn.adams@cos.com</a>
	<a href="https://annevankesteren.nl/">Anne van Kesteren</a> (<a href="http://www.opera.com">Opera Software ASA</a>) <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/cssom-view-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/cssom-view-1

旧来の課題リスト
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM%20View&amp;resolution=---">Bugzilla</a>


</script>

</head>

<body>


<!--%resource pool -->
<template id="_persisted_parts">

<div id="_dgm-Window" class="_test">
利用中のブラウザで<br><!-- ※ -->
・これらの属性の
<input value="取得を試みる" data-params="Window" type="button">
<br>
・
x:<input id="_test-scroll-x" value="0" size="5" type="text">
y:<input id="_test-scroll-y" value="0" size="5" type="text">
を入力に<br>
<label><input name="_test-scroll-fn" id="_test-scroll-scroll" type="radio"><code>scroll()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollTo" type="radio"><code>scrollTo()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollBy" checked="" type="radio"><code>scrollBy()</code></label>
<!-- 
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeTo" checked /><code >resizeTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeBy" checked /><code >resizeBy()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveTo" checked /><code >moveTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveBy" checked /><code >moveBy1()</code></label>
 -->
を
<input value="呼び出す" data-params="Window.scroll" type="button">
<br>
次の媒体クエリ：<br>
<input id="_test-mql_text" value="(orientation: landscape)" size="70" list="_MQL_options" data-event="change" data-params="MediaQueryList" type="text">
<br>
に対し，
<code>Window.matchMedia()</code>
の
<input id="_test-MediaQueryList" value="取得を試みる" data-params="MediaQueryList" type="button">
<datalist id="_MQL_options" hidden><!--
(width >= 800px);
(width <= 800px);
(height >= 600px);
(height <= 600px);
(min-device-width: 640px);
(max-device-width: 640px);
(min-device-height: 480px);
(max-device-height: 480px);
(orientation: landscape);
(orientation: portrait);
(min-aspect-ratio: 1/1);
(min-aspect-ratio: 2/1);
(min-aspect-ratio: 1/2);
(max-aspect-ratio: 1/1);
(max-aspect-ratio: 2/1);
(max-aspect-ratio: 1/2);
(color);
(min-color: 8);
(max-color: 8);
(min-color-index: 256);
(max-color-index: 256);
(monochrome);
(min-resolution: 96dpi);
(max-resolution: 96dpi);
(scan: interlace);
(scan: progressive);
(grid);
(update-frequency: none);
(update-frequency: slow);
(update-frequency: normal);
(overflow-block: none);
(overflow-block: scroll);
(overflow-block: optional-paged);
(overflow-block: paged);
(overflow-inline: none);
(overflow-inline: scroll);
(inverted-colors: none);
(inverted-colors: inverted);
(pointer: none);
(pointer: fine);
(pointer: fine);
(hover: none);
(hover: on-demand);
(hover: hover);
(any-pointer: none);
(any-pointer: coarse);
(any-pointer: fine);
(any-hover: none);
(any-hover: on-demand);
(any-hover: hover);
(light-level: dim);
(light-level: normal);
(light-level: washed);
(scripting: none);
(scripting: initial-only);
(scripting: enabled);


all;braille;embossed;handheld;print;projection;screen;speech;tty;tv;aural
--></datalist>
</div>

<div id="_dgm-Screen" class="_test">
利用中のブラウザでこれらの属性の
<input value="取得を試みる" data-params="Screen" type="button">
</div>


<div id="_dgm-Document" class="_test">
利用中のブラウザでマウス位置に対する
<br>
(1) <code>elementFromPoint()</code> の結果を
<input id="_test-elementFromPoint" value="表示する" data-params="elementFromPoint" type="button">
<br>
(1) <code>elementsFromPoint()</code> の結果を成す各 要素のタグ名の
<input id="_test-elementsFromPoint" value="取得を試みる" data-params="elementsFromPoint" type="button">
<br>
(2) <code>caretPositionFromPoint()</code> の
<input id="_test-caretPositionFromPoint" value="取得を試みる" data-params="caretPositionFromPoint" type="button">
</div>


<div id="_dgm-Element" class="_test">
利用中のブラウザで<br>
マウスが重なった要素について
<br>
・これらの属性の
<input value="取得を試みる" data-params="Element" type="button"><br>
・<code>getClientRects()</code> の
<input value="取得を試みる" data-params="getClientRects" type="button"><br>
・<code>getBoundingClientRect()</code> の
<input value="取得を試みる" data-params="ClientRect" type="button">
<br>
ランダムに選ばれた
<select size="1" id="_test-scrollIntoView-tagName"><option selected="">P</option><option>LI</option><option>H2</option><option>DT</option><option>DD</option></select>
要素に対し<br>
・<code>scrollIntoView(<label><input name="_test-SIV-top" id="_test-scrollIntoView-top" checked="" type="radio">true</label>
<label><input name="_test-SIV-top" type="radio">false</label>)</code>
を
<input id="_test-scrollIntoView" value="呼び出す" data-params="Element.scrollIntoView" type="button"><br>
・<code>scrollIntoView( {
	behavior:
<select size="1" id="_test-scrollIntoView-behavior"><option selected="">auto</option><option>smooth</option></select>
	, block:
<select size="1" id="_test-scrollIntoView-block">
	<option selected="">start</option>
	<option>center</option>
	<option>end</option>
	<option>nearest</option>
</select>
	, inline:
<select size="1" id="_test-scrollIntoView-inline">
	<option>start</option>
	<option selected="">center</option>
	<option>end</option>
	<option>nearest</option>
</select>
} )</code> を
<input id="_test-scrollIntoView0" value="呼び出す" data-params="Element.scrollIntoView0" type="button">
</div>


<div id="_dgm-HTMLElement" class="_test">
利用中のブラウザでマウスが重なった要素について，これらの属性の
<input value="取得を試みる" data-params="HTMLElement" type="button">
</div>


<div id="_dgm-Range" class="_test">
利用中のブラウザでテキスト選択に応じて，その範囲に対する<br>
(1) <code>getClientRects()</code> の
<input id="_test-Selection.getClientRects" value="取得を試みる" data-params="Selection.getClientRects" type="button">
<br>
(2) <code>getBoundingClientRect()</code> の
<input id="_test-Selection.getBoundingClientRect" value="取得を試みる" data-params="Selection.getBoundingClientRect" type="button">
</div>

<div id="_dgm-MouseEvent" class="_test">
利用中のブラウザで mousemove イベントに対する，これらの属性の
<input id="_test-MouseEvent" value="取得を試みる" data-params="MouseEvent" type="button">
</div>

</template>


<header>

	<hgroup>
<h1 id="cssom-view-module">CSSOM View Module</h1>
	</hgroup>
</header>

<div  id="MAIN" hidden>

	<section id="abstract">

~ABSTRACT

<p>
この仕様が導入する~APIは、
作者に，文書の視覚的な~viewを調べたり, 操作するための方法を与える。
これには、［
要素の~layout~boxの位置を取得する,
~scriptを通して表示域~sizeを得する,
要素の~scroll法
］なども含まれる。
◎
The APIs introduced by this specification provide authors with a way to inspect and manipulate the visual view of a document. This includes getting the position of element layout boxes, obtaining the width of the viewport through script, and also scrolling an element.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="background">
<h2 title="Background">1. 背景</h2>

<p>
この仕様にて定義される特能の多くは、
長い間~browserから~supportされてきた。
この仕様の目標は、
これらの特能を，すべての~browserが相互運用可能な方式で実装できるように定義することである。
この仕様は、
~scrollの~custom化を許容する，新たな特能も定義する。
◎
Many of the features defined in this specification have been supported by browsers for a long period of time. The goal of this specification is to define these features in such a way that they can be implemented by all browsers in an interoperable manner. The specification also defines a some new features which allow for scroll customization.
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様に利用される用語は
`DOM$r, `CSSOM$r, `HTML$r
による。
◎
Terminology used in this specification is from DOM, CSSOM and HTML. [DOM] [CSSOM] [HTML]
</p>

<p>
`~HTML~body要素@
とは、
根 `~HTML要素$ `html^e の子である，最初の `body^e `~HTML要素$ である。
◎
The HTML body element is the first body HTML element child of the root HTML element html.
</p>

<p class="trans-note">【
~HTMLが定義する`~body要素$とほぼ同義
（廃用にされた `frameset^e 要素は、
ここでは除外されている）。
】</p>

<p>
`文書$の
`根~要素@
は、
`文書~要素$の同義語であり， ~NULL （ “無い” ）にもなり得る。
</p>

<p class="trans-note">【
この定義は、
訳者による推定（例：~HTML文書であれば `html^e 要素になる）
— 原文に現れるこの語（ `root element^en ）には、
明示的な定義や参照は与えられていない。
】</p>

<p>
`内容~辺@,
`~padding辺@,
`~border辺@,
`~margin辺@,
`表示域@
（ `viewport^en ）は、
~CSSにて定義される。
◎
Content edge, padding edge, border edge, margin edge, and viewport are defined by CSS.
</p>

<p class="trans-note">【
参照 —
<a href="~CSSBOX#box-model">各種~辺の定義と図式</a>,
<a href="~CSS2VISUREN#viewport">表示域</a>
】</p>

<div class="p">
<p>
次のいずれかを満たす［
要素／`表示域$
］には、
`~scrollされる~box@
（ `scrolling box^en ）が結付けられる：
◎
Elements and viewports have an associated scrolling box if＼
</p>
<ul>
	<li>
~scroll用の仕組みを備えている
◎
the element or viewport has a scrolling mechanism,＼
</li>
	<li>
<p>
次をいずれも満たす：
</p>
		<ul>
			<li>
その内容は、
その内容~区画を~overflowしている
</li>
			<li>
その［
`overflow-x$p, `overflow-y$p
］いずれかの~propの使用~値は［
`hidden$v ／ `clip$v
］でない
`CSS3-OVERFLOW-3$r
【！ CSS3-BOX】
</li>
		</ul>
◎
or it overflows its content area and the used value of the overflow-x or overflow-y property is not hidden or clip. [CSS3-BOX]
</li>
</ul>
</div>

<p>
`~HTML~body要素$ %~body は、
次をすべて満たすとき，
`~scroll可能になり得る@
とされる。
◎
An element body (which will be the HTML body element) is potentially scrollable if all of the following conditions are true:
</p>

<ul>
	<li>
%~body は `~CSS~layout~box$を持つ。
◎
body has an associated CSS layout box.
</li>
	<li>
%~body, %~body の`親~要素$は、
どちらも次を満たす
⇒
［
`overflow-x$p,
`overflow-y$p
］~propのどちらかは次を満たす
⇒
算出d値 ~NIN { `visible$v, `clip$v }
【実際には、片方の~propがこれを満たすならば両方とも満たすことになる。】
◎
body’s parent element’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
◎
body’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
</li>
</ul>

<p class="note">注記：
`body$e 要素は、
`~scroll可能になり得る$としても，`~scrollされる~box$は無いこともある。
具体的には、
要素の `overflow$p の使用~値は `auto^v であるが，
その内容は内容~区画を~overflowしていない場合など。
◎
Note: A body element that is potentially scrollable might not have a scrolling box. For instance, it could have a used value of overflow being auto but not have its content overflowing its content area.
</p>

<p>
［
`表示域$／要素
］の`~scrollされる~box$には、
2 つの
`~overflow方向@
— `塊-終端$, `行内-終端$ —
がある。
その初期~scroll位置は、
`内容-分布~prop$に依存して，`~scrollされる区画$の`原点$に整列されるとは限らないことに注意。
`CSS-ALIGN-3$r
<a href="~CSSALIGN#overflow-scroll-position">§ ~overflowと~scroll位置</a>
を見よ。
◎
A scrolling box of a viewport or element has two overflow directions, which are the block-end and inline-end directions for that viewport or element. Note that the initial scroll position might not be aligned with the scrolling area origin depending on the content-distribution properties, see CSS Box Alignment 3 § 5.3 Overflow and Scroll Positions.
</p>

<p>
［
`表示域$／要素
］の
`~scrollされる区画@
は、
その`~overflow方向$に応じて，各辺が以下に従って与えられる~boxである。
◎
The term scrolling area refers to a box of a viewport or an element that has the following edges, depending on the viewport’s or element’s scrolling box’s overflow directions.
</p>

<div>

<p>
記号
%D1 は［
上方, 下方, 左方, 右方
］いずれかの方向を表し，
%D2 は その反対~方向を表すとする。
`~overflow方向$に %D1 が含まれている（したがって %D2 は含まれていない）ならば、
~boxの［
%D1, %D2
］側の辺は次で与えられる：
</p>

<table>
<thead><tr><th><th>`表示域$に対しては
<th>要素に対しては
</thead>

<tbody><tr><th>%D1 側の辺
<td>
［
`初期~包含塊$の %D1 側の辺, および
`表示域$のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺。
◎
The D1-most edge of the D1 edge of the initial containing block and the D1 margin edge of all of the viewport’s descendants' boxes.
<td>
［
要素の %D1 側の`~padding辺$, および
要素のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺
— ただし，要素の先祖を`包含塊$とするような~boxは除外する††。
◎
The D1-most edge of the element’s D1 padding edge and the D1 margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><th style="white-space:nowrap;">%D2 側の辺

<td>
`初期~包含塊$の %D2 側の辺。
◎
The D2 edge of the initial containing block.
<td>
要素の %D2 側の`~padding辺$。
◎
The element’s D2 padding edge.

</tbody></table>

<p class="trans-note">【†
この子孫は、
`~box~tree$における子孫を意味する。
“表示域の子孫~box” が何を意味するのか不明だが、
当の文書の~box~treeを成す~boxすべてが該当すると見受けられる。
】【††
例えば，`~flow外$にある~boxなど。
】【
この箇所は、
原文の内容と等価になるよう，~parameter化により大幅に圧縮して記述している。
】</p>

<div lang="en" class="_en">
<table>
<thead><tr>
<th>If the overflow directions are…
<th>For a viewport
<th>For an element
</thead>

<tbody style="white-space:pre-line;"><tr><td>rightward and downward
<td>top edge
• The top edge of the initial containing block.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left edge of the initial containing block.

<td>top edge
• The element’s top padding edge.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The element’s left padding edge.

<tr><td>leftward and downward
<td>top edge
• The top edge of the initial containing block.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The element’s top padding edge.

right edge
• The element’s right padding edge.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>leftward and upward
<td>top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The element’s right padding edge.

bottom edge
• The element’s bottom padding edge.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>rightward and upward
<td>top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left edge of the initial containing block.

<td>top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The element’s bottom padding edge.

left edge
• The element’s left padding edge.
</tbody></table></div>

</div>

<p>
`~scrollされる区画$の
`原点@
は、［
`表示域$の`~scrollされる区画$ならば，`初期~包含塊$の原点／
他の場合は，要素の~scroll位置が既定の位置にあるときの要素の~padding辺の左上隅
］に~~位置する。
［
x ／ y
］座標は、［
右方／下方
］へ増大する。
◎
The origin of a scrolling area is the origin of the initial containing block if the scrolling area is a viewport, and otherwise the top left padding edge of the element when the element has its default scroll position. The x-coordinate increases rightwards, and the y-coordinate increases downwards. 
</p>

<div class="p">
<p>
［
表示域, または［
~boxあるいは要素
］］の［
`開始辺@
／
`終了辺@
］は、
その`~overflow方向$と［
反対~方向 ／ 同じ方向
］にある辺を指す
（例えば，`~overflow方向$が右方と下方ならば、
開始辺は左辺および上辺, 終了辺は右辺および下辺になる, 等々）。
【ここでも、原文と等価になるよう，圧縮して訳している。】
</p>

◎
The beginning edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The top and left edges.
• If the overflow directions are leftward and downward
•• The top and right edges.
• If the overflow directions are leftward and upward
•• The bottom and right edges.
• If the overflow directions are rightward and upward
•• The bottom and left edges.
◎
The ending edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The bottom and right edges.
• If the overflow directions are leftward and downward
•• The bottom and left edges.
• If the overflow directions are leftward and upward
•• The top and left edges.
• If the overflow directions are rightward and upward
•• The top and right edges.
</div>

<p>
用語
`~CSS~layout~box@
は、
~CSSのそれと同じとする。
この仕様の要件の目的においては、
`display$p ~propの算出d値が［
`table-column$v ／ `table-column-group$v
］になる要素は、
（［
~col／~col~group
］の） `~CSS~layout~box$を持つと見なすモノトスル。
◎
The term CSS layout box refers to the same term in CSS. For the purpose of the requirements in this specification, elements that have a computed value of the display property that is table-column or table-column-group must be considered to have an associated CSS layout box (the column or column group, respectively).
</p>

<p>
用語
`~SVG~layout~box@
は、
~SVGのそれと同じとする。
◎
The term SVG layout box refers to the same term in SVG.
</p>

<p class="issue">
用語
`~CSS~layout~box$,
`~SVG~layout~box$
のいずれも，現時点では~CSSや~SVGの中で定義されていない。
◎
The terms CSS layout box and SVG layout box are not currently defined by CSS or SVG.
</p>

<p>
用語
`~layout~box@
は
`~CSS~layout~box$,
`~SVG~layout~box$
のいずれか【適切な方】を指す。
◎
The term layout box refers to either a CSS layout box or an SVG layout box. 
</p>

<p class="trans-note">【
“要素に結付けられている（ ~CSS ／ ~SVG ）`~layout~box$を指して，単に
“要素の~layout~box”
と記す。
そのような~boxが存在しない（例えば描画の対象でない要素など）ことを，
“（要素は）~layout~boxを持たない”
と記す。
】</p>

<p>
用語
`変形@
は、［
~SVG／~CSS
］による変形（座標系変換）を指す。
`SVG11$r
`CSS-TRANSFORMS-1$r
◎
The term transforms refers to SVG transforms and CSS transforms. [SVG11] [CSS-TRANSFORMS-1]
</p>

<p>
［
~IDL~method／属性
］（以下，単に “~member” ）から別の~memberが呼ばれるときは、
~UAは，~memberの内部~APIを呼出すモノトスル
— すなわち、
作者は［
~custom ECMAScript ~propや関数で上書きして，~memberの挙動を変更する
］ことはできない。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
他が指定されない限り、
文字列は【！is】`一致する$かどうかにより比較される。
◎
Unless otherwise stated, all string comparisons use is.
</p>

		<section id="css-pixels">
<h3 title="CSS pixels">2.1. ~CSS~pixel</h3>

<p>
他が指定されない限り、
この仕様で定義される~API用の［
座標, 寸法
］は，すべて`~CSS~pixel$単位とする。
`CSS-VALUES$r
【この訳では、 “`px$u 単位” と略記する。】
◎
All coordinates and dimensions for the APIs defined in this specification are in CSS pixels, unless otherwise specified. [CSS-VALUES]
</p>

<p class="note">注記：
このことは、
例えば `matchMedia()^m には該当しない。
そのような所では、
単位は明示的に与えられる。
◎
Note: This does not apply to e.g. matchMedia() as the units are explicitly given there.
</p>

		</section>
		<section id="zooming">
<h3 title="Zooming">2.2. ~zoom法</h3>

<div>
<p>
~zoomには，次の 2 種類がある
`CSS-DEVICE-ADAPT$r：
</p>

<dl class="def-list">
	<dt>`~page~zoom@</dt>
	<dd>
初期 表示域の~sizeに影響する。
</dd>

	<dt>`~pinch~zoom@</dt>
	<dd>
拡大鏡のように挙動して，初期 表示域や実際の表示域には影響しない。
</dd>
	<dd class="trans-note">【
局所的な~zoom。
おそらく、
複~touch機器の~UIで利用される，二本指で “つまんで” 拡げる~~操作に由来する呼称。
】</dd>
</dl>

◎
There are two kinds of zoom, page zoom which affects the size of the initial viewport, and pinch zoom which acts like a magnifying glass and does not affect the initial viewport or actual viewport. [CSS-DEVICE-ADAPT]
</div>

		</section>
		<section id="web-exposed-screen-information">
<h3 title="Web-exposed screen information">2.3. ~Webに公開される~screen情報</h3>

<p>
~UAは、
利用者の~privacyを保護するためとして，［
出力~機器の~screenについての情報を隠す
］ことを選んでもヨイ。
各種~APIにわたって一貫した方式でそうするため、
この仕様は，以下の区画を表す用語を定義する。
これらの各~区画は、
いずれも［
有限な ( 横幅, 縦幅 ) がある ／
左上隅を原点にとる ／
x 座標は右方に増大する ／
y 座標は下方に増大する ／
座標の単位は `px$u
］とする：
◎
User agents may choose to hide information about the screen of the output device, in order to protect the user’s privacy. In order to do so in a consistent manner across APIs, this specification defines the following terms, each having a width and a height, the origin being the top left corner, and the x- and y-coordinates increase rightwards and downwards, respectively.
</p>

<ul>
	<li>
`~Webに公開される~screen区画@
— 次のうち，いずれかになるとする
⇒＃
出力~機器の区画／
`表示域$の区画
◎
The Web-exposed screen area is one of the following:
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
	<li>
`~Webに公開される可用な~screen区画@
— 次のうち，いずれかになるとする
⇒＃
出力~機器の描画面として可用な区画／
出力~機器の区画／
`表示域$の区画／
◎
The Web-exposed available screen area is one of the following:
• The available area of the rendering surface of the output device, in CSS pixels.
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
</ul>

		</section>
		<section id="_trans-conventions_">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, コレ, ~WHILE 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
加えて、
記述を簡潔にするため，次の（非公式な）用語も定義する：
</p>
<ul>
	<li>
`Document$I ~interfaceを実装する~objは、
単に
`文書@
と略記される。
</li>
	<li>
`表示域$の
`有効~横幅@ ／
`有効~縦幅@
とは、
`表示域$に~scroll~barが描画されているときは その部分の区画を除外した，
`表示域$の［
横幅／縦幅
］を表す
（~scroll~barが無ければ，通常の［
横幅／縦幅
］と同じになる）。
</li>
</ul>

<p>
加えて、
次の記法を用いる：
</p>

<ul>
	<li>
<p>
記法 “［ %W ｜ %H ］” （ "｜" は全角の縦棒）は、
縦横それぞれの方向についての，並立的な記述を表す。
</p>

<p>
例えば：
<span class="block">
“［ x 属性 ｜ y 属性 ］ は表示域の［ 左端の x 座標 ｜ 上端の y 座標 ］ を返す”
</span>
と記されていれば、
それは 2 つの記述：

<span class="block">
“x 属性 は表示域の左端の x 座標を返す”,<br>
“y 属性 は表示域の上端の y 座標を返す”
</span>

が，並立的に重ねられていることを表す。
この対応関係は，同じ~algoの中の別々の段の間でも維持される。
</p>

<p>
<small>
（このような表記を導入する理由は、
記述の簡約以外にも，［
縦横両方向に関する記述であって, その両方向について対称性がある
］ことを明らかにすることもある。）</small>
</p>
</li>
</ul>

		</section>
	</section>
	<section id="common-infrastructure">
<h2 title="Common Infrastructure">3. 共通基盤</h2>

<p>
この仕様は WHATWG Infra 標準に依存する。
`INFRA$r
◎
This specification depends on the WHATWG Infra standard. [INFRA]
</p>

		<section id="scrolling">
<h3 title="Scrolling">3.1. ~scroll法</h3>

<div class="algo">
<p>
`~scrollを遂行する@
ときは、
所与の
( %~box （`~scrollされる~box$）, %目的位置, %~assoc要素, %挙動 （省略時は `auto$l ） )
に対し，次を走らす：
◎
When a user agent is to perform a scroll of a scrolling box box, to a given position position, an associated element element and optionally a scroll behavior behavior (which is "auto" if omitted), the following steps must be run:
</p>

<ol>
	<li>
~IF［
%~box において`滑らかな~scroll$は進行中である
］
⇒
それを`中止-$する
◎
Abort any ongoing smooth scroll for box.
</li>
	<li>
<p>
~IF［
~UAは， `scroll-behavior$p ~propを尊守する
］~AND［
次のいずれかが満たされる
］…：
◎
If the user agent honors the scroll-behavior property and one of the following are true:
</p>
		<ul>
			<li>
［
%挙動 ~EQ `auto$l
］~AND［
%~assoc要素 ~NEQ ~NULL
］~AND［
%~assoc要素 の `scroll-behavior$p ~propの算出d値 ~EQ `smooth$v
］
◎
behavior is "auto" and element is not null and its computed value of the scroll-behavior property is smooth
</li>
			<li>
%挙動 ~EQ `smooth$l
◎
behavior is smooth
</li>
		</ul>

<p class="trans-note">【
尊守する（ `honor^en ） —
~supportしていて, かつ
その機能が（環境設定 等により）可能化されてもいる，といった含みもある語と見受けられる。
】</p>

<p>
…ならば
⇒
%~box を %目的位置 に`滑らかに~scrollする$
◎
...then perform a smooth scroll of box to position. Otherwise, perform an instant scroll of box to position.
</p>
	</li>
	<li>
~ELSE
⇒
%~box を %目的位置 に`瞬時に~scrollする$
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`~scrollされる~box$ %~box を %目的位置 に
`滑らかに~scrollする@
ときは：
</p>

<ul>
	<li>
~UAが定義する~~速度, ~~動きにより， %~box の~scroll位置を【非同期的に】更新するモノトスル。
</li>
	<li>
~scrollの
`完了-@
時には、
%~box の~scroll位置は %目的位置 になるモノトスル。
</li>
	<li>
この~scrollは、
~algoまたは利用者により
`中止-@
され得る。
</li>
</ul>
◎
When a user agent is to perform a smooth scroll of a scrolling box box to position, it must update the scroll position of box in a user-agent-defined fashion over a user-agent-defined amount of time. When the scroll is completed, the scroll position of box must be position. The scroll can also be aborted, either by an algorithm or by the user.
</div>

<div class="algo">
<p>
`~scrollされる~box$ %~box を %目的位置 に
`瞬時に~scrollする@
ときは、
%~box の~scroll位置を %目的位置 に更新するモノトスル。
◎
When a user agent is to perform an instant scroll of a scrolling box box to position, it must update the scroll position of box to position.
</p>
</div>

<div class="algo">
<p>
`文書の開始位置に~scrollする@
ときは、所与の
( 文書 %文書 )
に対し，次を走らす：
◎
To scroll to the beginning of the document for a document document, follow these steps:
</p>

<ol>
	<li>
%表示域 ~LET
%文書 に結付けられている`表示域$
◎
Let viewport be the viewport that is associated with document.
</li>
	<li>
%目的位置 ~LET
%表示域 の`開始辺$が`~scrollされる区画$の`開始辺$に整列されたときに %表示域 がとる，~scroll位置
◎
Let position be the scroll position viewport would have by aligning the beginning edges of the scrolling area with the beginning edges of viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の~scroll位置
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as viewport’s current scroll position, and viewport does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`~scrollを遂行する$( %表示域, %目的位置, %文書 の`根~要素$ )
◎
Perform a scroll of viewport to position, and document’s root element as the associated element, if there is one, or null otherwise. 
</li>
</ol>

<p class="note">注記：
この~algoは、
`HTML$r に定義されるとおり，
<a href="~NAVI#navigate-fragid">素片~識別子 `#top^c へ~navigateする</a>ときに利用される。
【すなわち，文書~内の<a href="~NAVI#the-indicated-part-of-the-document">指示された部位</a>は、文書の上端になる。】
◎
Note: This algorithm is used when navigating to the #top fragment identifier, as defined in HTML. [HTML]
</p>
</div>

		</section>
		<section id="webidl-values">
<h3 title="WebIDL values">3.2. ~Web~IDL値</h3>

<div class="algo">
<p>
`有限~値に正規化する@
ときは、所与の
( 値 %n )
に対し：
</p>
<ol>
	<li>
~IF［
%n は［
特別な浮動小数点~literal値（ `Infinity^I ／ `-Infinity^c ／ `NaN^I ） `WEBIDL$r
］である
］
⇒
~RET 0
</li>
	<li>
~RET %n
</li>
</ol>
◎
When asked to normalize non-finite values for a value x, if x is one of the three special floating point literal values (Infinity, -Infinity or NaN), then x must be changed to the value 0. [WEBIDL]
</div>

		</section>
	</section>
	<section id="extensions-to-the-window-interface">
<h2 title="Extensions to the Window Interface">4. `Window^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollBehavior@I { `auto@l, `smooth@l };

dictionary `ScrollOptions@I {
  `ScrollBehavior$I `behavior@mb = `auto$l;
};

dictionary `ScrollToOptions@I : `ScrollOptions$I {
  `unrestricted double$ `left@mb;
  `unrestricted double$ `top@mb;
};
</pre>

<pre class="idl">
partial interface `Window$I {`Window^I0
  [`NewObject$] `MediaQueryList$I `matchMedia$m(`CSSOMString$ %query);
  [`SameObject$, `Replaceable$] readonly attribute `Screen$I `screen$m;

  // <span class="comment">閲覧文脈</span>
  `undefined$ `moveTo$m(`long$ %x, `long$ %y);
  `undefined$ `moveBy$m(`long$ %x, `long$ %y);
  `undefined$ `resizeTo$m(`long$ %width, `long$ %height);
  `undefined$ `resizeBy$m(`long$ %x, `long$ %y);

  // <span class="comment">表示域</span>
  [`Replaceable$] readonly attribute `long$ `innerWidth$m;
  [`Replaceable$] readonly attribute `long$ `innerHeight$m;

  // <span class="comment">表示域の~scroll法</span>
  [`Replaceable$] readonly attribute `double$ `scrollX$m;
  [`Replaceable$] readonly attribute `double$ `pageXOffset$m;
  [`Replaceable$] readonly attribute `double$ `scrollY$m;
  [`Replaceable$] readonly attribute `double$ `pageYOffset$m;
  `undefined$ `scroll$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scroll$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollTo$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollTo$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollBy$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollBy$m(`unrestricted double$ %x, `unrestricted double$ %y);

  // <span class="comment">~client~UIwindow</span>
  [`Replaceable$] readonly attribute `long$ `screenX$m;
  [`Replaceable$] readonly attribute `long$ `screenLeft$m;
  [`Replaceable$] readonly attribute `long$ `screenY$m;
  [`Replaceable$] readonly attribute `long$ `screenTop$m;
  [`Replaceable$] readonly attribute `long$ `outerWidth$m;
  [`Replaceable$] readonly attribute `long$ `outerHeight$m;
  [`Replaceable$] readonly attribute `double$ `devicePixelRatio$m;
};
</pre>

`Window^dgm

<div class="algo">
`matchMedia(query)@m
~method手続きは
⇒
~RET 次のように設定された，新たな `MediaQueryList$I ~obj
⇒＃
`媒体~query~list$ ~SET `媒体~query~listとして構文解析する$( %query ),
`文書$mq ~SET コレに`結付けられている文書$
◎
When the matchMedia(query) method is invoked these steps must be run:
◎
Let parsed media query list be the result of parsing query.
◎
Return a new MediaQueryList object, with this's associated Document as the document, with parsed media query list as its associated media query list.
</div>

<div class="algo">
<p>
`screen@m
取得子~手続きは
⇒
~RET コレに結付けられている `Screen$I ~obj
◎
The screen attribute must return the Screen object associated with the Window object.
</p>

<p class="note">注記：
`WindowProxy$I ~objを通した `screen^c への~accessでは、
`文書$が~navigateされたときには，異なる結果が得られ得る。
◎
Note: Accessing screen through a WindowProxy object might yield different results when the Document is navigated.
</p>
</div>

<div class="algo">
<p>
`moveTo(x, y)@m
~method手続きは：
◎
The moveTo(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の外側に~UIwindowが出ない大きさ
］に切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
	<li>
%target の~UIwindowを，その左上隅が［
出力~機器の左上隅から相対的な［
%target の `px$u 単位による座標 (%x, %y) 
］］に整列するよう移動する。
ここで，各~座標軸の正方向は［
右方, 下方
］とする。
◎
Move target’s window such that the window’s top left corner is at coordinates (x, y) relative to the top left corner of the output device, measured in CSS pixels of target. The positive axes are rightward and downward. 
</li>
</ol>
</div>

<div class="algo">
<p>
`moveBy(x, y)@m
~method手続きは：
◎
The moveBy(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の外側に~UIwindowが出ない大きさ
］に切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
	<li>
%target の~UIwindowを，
%target の `px$u 単位で［
右方に %x, 下方に %y
］だけ移動する
◎
Move target’s window x CSS pixels of target rightward and y CSS pixels of target downward.
</li>
</ol>
</div>

<div class="algo">
<p>
`resizeTo(width, height)@m
~method手続きは：
◎
The resizeTo(width, height) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
［
%width, %height
］を［
可用な空間の中で~UIwindowの大きさが~~適度な［
上限, 下限
］に収まる
］よう切詰める
◎
Optionally, clamp width and height in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
	<li>
%target の~UIwindowを~resizeする
— ［
%width, %height は %target の `px$u 単位の値を表す
］とする下で，~UIwindowの［
右辺, 下辺
］を次を満たすように移動する
⇒
［
表示域の左辺と右辺の距離 ~EQ %width
］~AND［
表示域の上辺と下辺の距離 ~EQ %height
］
◎
Resize target’s window by moving its right and bottom edges such that the distance between the left and right edges of the viewport are width CSS pixels of target and the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%target の~UIwindowを，可用な空間をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
</ol>
</div>

<div class="algo">
<p>
`resizeBy(x, y)@m
~method手続きは：
◎
The resizeBy(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧文脈$
◎
Let target be this's relevant global object's browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%x, %y
を［
可用な空間の中で~UIwindowの大きさが~~適度な［
上限, 下限
］に収まる
］よう切詰める
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
	<li>
%target の~UIwindowを，~resizeする
— その右辺と下辺を %target の `px$u 単位で［
左辺を %x,
上辺を %y
］だけ移動する
◎
Resize target’s window by moving its right edge x CSS pixels of target rightward and its bottom edge y CSS pixels of target downward.
</li>
	<li>
任意選択で，~UA定義な方式で
⇒
%target の~UIwindowを，可用な空間をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`innerWidth@m ｜ `innerHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`表示域$の［
横幅 ｜ 縦幅
］（~scroll~barが描画されている場合はその~sizeも含める）
</li>
</ol>

<div class="example">
<p>
次の~code片は、
表示域の横幅を得する方法を示す：
</p>

<pre class="lang-js">
var %viewportWidth = innerWidth
</pre>
</div>

◎
The innerWidth attribute must return the viewport width including the size of a rendered scroll bar (if any), or zero if there is no viewport.
◎
The following snippet shows how to obtain the width of the viewport:
• var viewportWidth = innerWidth
◎
The innerHeight attribute must return the viewport height including the size of a rendered scroll bar (if any), or zero if there is no viewport.
</div>

<div class="algo">
<p>
［
`scrollX@m ｜ `scrollY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`初期~包含塊$の原点に相対的な，`表示域$の［
左端の x 座標 ｜ 上端の y 座標
］
</li>
</ol>
◎
The scrollX attribute must return the x-coordinate, relative to the initial containing block origin, of the left of the viewport, or zero if there is no viewport.
◎
The pageXOffset attribute must return the value returned by the scrollX attribute.
◎
The scrollY attribute must return the y-coordinate, relative to the initial containing block origin, of the top of the viewport, or zero if there is no viewport.
◎
The pageYOffset attribute must return the value returned by the scrollY attribute.
</div>

<div class="algo">
［
`pageXOffset@m ｜ `pageYOffset@m
］取得子~手続きは、［
`scrollX$m ｜ `scrollY$m
］取得子~手続きと同じに挙動する。
◎
↑</div>

<div class="algo">
<p>
`scroll()@m
~method手続きは：
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x )
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y )
</li>
	<li>
`~window用の~scroll手続き$( コレ, %x, %y, %behavior )
</li>
</ol>
◎
When the scroll() method is invoked these steps must be run:
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Let x be the value of the left dictionary member of options, if present, or the viewport’s current scroll position on the x axis otherwise.
• Let y be the value of the top dictionary member of options, if present, or the viewport’s current scroll position on the y axis otherwise.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
◎
Normalize non-finite values for x and y.
◎
↓
</div>

<div class="algo">
<p class="trans-note">【
この訳では、
原文による `scroll()$m ~method手続きを成す引数の取扱い以外の部分を，
次に与える手続きに分離する
— それは、
複数の箇所から共通して利用されるので。
】</p>

<p>
`~window用の~scroll手続き@
は、所与の
( %window, %x, %y, %behavior )
に対し：
◎
↑</p>
<ol>
	<li>
~IF［
%window の`表示域$は無い
］
⇒
~RET
◎
If there is no viewport, abort these steps.
</li>
	<li>
%表示域 ~LET %window の`表示域$
</li>
	<li>
<p>
%座標 ~LET 次の下位手続きを走らせた結果：
</p>
		<ol>
			<li>
~IF［
%x ~EQ ε
］
⇒
%x ~SET `表示域$の現在の x 軸 ~scroll位置
</li>
			<li>
~IF［
%y ~EQ ε
］
⇒
%y ~SET `表示域$の現在の y 軸 ~scroll位置
</li>
			<li>
%~scrollされる区画 ~LET %表示域 の`~scrollされる区画$
</li>
			<li>
%符号 ~LET %表示域 の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
</li>
			<li>
%x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %x, ( %~scrollされる区画 の横幅 ~MINUS %表示域 の`有効~横幅$ )))
</li>
			<li>
%符号 ~LET %表示域 の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
</li>
			<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, ( %~scrollされる区画 の縦幅 ~MINUS %表示域 の`有効~縦幅$ )))
</li>
			<li>
~RET ( %x, %y )
</li>
		</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any.
◎
Let viewport height be the height of the viewport excluding the height of the scroll bar, if any.
◎
If the viewport has rightward overflow direction
• Let x be max(0, min(x, viewport scrolling area width - viewport width)).
◎
If the viewport has leftward overflow direction
• Let x be min(0, max(x, viewport width - viewport scrolling area width)).
◎
If the viewport has downward overflow direction
• Let y be max(0, min(y, viewport scrolling area height - viewport height)).
◎
If the viewport has upward overflow direction
• Let y be min(0, max(y, viewport height - viewport scrolling area height)).
</li>
	<li>
%目的位置 ~LET %~scrollされる区画 の座標 %座標 が %表示域 の左上隅に整列されるような， %表示域 の~scroll位置
◎
Let position be the scroll position the viewport would have by aligning the x-coordinate x of the viewport scrolling area with the left of the viewport and aligning the y-coordinate y of the viewport scrolling area with the top of the viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の~scroll位置
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as the viewport’s current scroll position, and the viewport does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
%~assoc要素 ~LET %表示域 に結付けられている`文書$の`根~要素$
◎
Let document be the viewport’s associated Document.
</li>
	<li>
`~scrollを遂行する$( %表示域, %目的位置, %~assoc要素, %behavior )
◎
Perform a scroll of the viewport to position, document’s root element as the associated element, if there is one, or null otherwise, and the scroll behavior being the value of the behavior dictionary member of options.
</li>
</ol>
</div>

<div class="algo">
`scrollTo()@m
~method手続きは、
`scroll()$m ~method手続きと同じに挙動する。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</div>

<div class="algo">
<p>
`scrollBy()@m
~method手続きは：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x ) ~PLUS コレの `scrollX$m 取得子~手続き()
◎
Normalize non-finite values for the left and top dictionary members of options.
◎
Add the value of scrollX to the left dictionary member.
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y ) ~PLUS コレの `scrollY$m 取得子~手続き()
◎
↑
◎
Add the value of scrollY to the top dictionary member.
</li>
	<li>
`~window用の~scroll手続き$( コレ, %x, %y, %behavior )
◎
Act as if the scroll() method was invoked with options as the only argument.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`screenX@m ｜ `screenY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
	<li>
~RET
出力~機器の`~Webに公開される~screen区画$の原点に相対的な,  `px$u 単位による，~client~UIwindow†の［
左端の x 座標 ｜ 上端の y 座標
］
</li>
</ol>

<p class="trans-note">【†
“~client~UIwindow” がどの部分を指すのか，定義されていないが、
現実の~browserのふるまいからは，外枠も含めた~UIwindow全体が占める区画を指すものと推定される。
】</p>

◎
The screenX and screenLeft attributes must return the x-coordinate, relative to the origin of the Web-exposed screen area, of the left of the client window as number of CSS pixels, or zero if there is no such thing.
◎
The screenY and screenTop attributes must return the y-coordinate, relative to the origin of the screen of the Web-exposed screen area, of the top of the client window as number of CSS pixels, or zero if there is no such thing.
</div>

<div class="algo">
［
`screenLeft@m ｜ `screenTop@m
］取得子~手続きは、［
`screenX$m ｜ `screenY$m
］取得子~手続きと同じに挙動する。
◎
↑</div>

<div class="algo">
<p>
［
`outerWidth@m ｜ `outerHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
	<li>
~RET ~client~UIwindowの［
横幅 ｜ 縦幅
］
</li>
</ol>
◎
The outerWidth attribute must return the width of the client window. If there is no client window this attribute must return zero.
◎
The outerHeight attribute must return the height of the client window. If there is no client window this attribute must return zero.
</div>

<div class="algo">
`devicePixelRatio@m
取得子~手続きは
⇒
~RET `機器~pixel比を決定する$()
◎
The devicePixelRatio attribute must return the result of＼
</div>

<div class="algo">
<p>
`機器~pixel比を決定する@
ときは：
◎
the following determine the device pixel ratio algorithm:
</p>

<ol>
	<li>
~IF［
出力~機器は無い
］
⇒
~RET 1
◎
If there is no output device, return 1 and abort these steps.
</li>
	<li>
%~CSS~pixel~size ~LET ［
現在の`~page~zoom$倍率
］, および［
`~pinch~zoom$倍率 1.0
］の下での，
1 `px$u の~size
◎
Let CSS pixel size be the size of a CSS pixel at the current page zoom scale factor and at a pinch zoom scale factor of 1.0.
</li>
	<li>
%機器~pixel~size ~LET
出力~機器の機器~pixelの縦~size
◎
Let device pixel size be the vertical size of a device pixel of the output device.
</li>
	<li>
~RET
%~CSS~pixel~size ~DIV %機器~pixel~size
◎
Return the result of dividing CSS pixel size by device pixel size.
</li>
</ol>
</div>

		<section id="the-features-argument-to-the-open()-method">
<h3 title="The features argument to the open() method">4.1. `open()^m ~methodに対する %features 引数</h3>

<p>
~HTMLは、
~windowの `open()$m ~method
【および，文書の `~doc-open()$m ~method】
を定義している。
この節では、
その %features 引数にて与えられる位置と~sizeの挙動を定義する。
`HTML$r
◎
HTML defines the open() method. This section defines behavior for position and size given in the features argument. [HTML]
</p>

<div class="algo">
<p>
`閲覧文脈の特能を設定しておく@
ときは、所与の
(
`閲覧文脈$ %target,
（ %features 引数から導出された）`~map$ %特能~map
)
に対し，次を走らす：
◎
To set up browsing context features for a browsing context target given a map tokenizedFeatures:
</p>

<ol>
	<li>
%~pixel単位 ~LET %target における `px$u 単位
◎
↓</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
%可用な~screen ~LET `~Webに公開される可用な~screen区画$
◎
↓</li>
	<li>
%~screen ~LET `~Webに公開される~screen区画$
◎
↓</li>
	<li>
%正規化-済み~map ~LET 新たな`~map$
◎
↓</li>
	<li>
<p>
~EACH( %名前 ~IN { `left$opf, `top$opf, `width$opf, `height$opf } )
に対し：
</p>
		<ol>
			<li>
%値 ~LET %特能~map[ %名前 ]
</li>
			<li>
~IF［
%値 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
%値 ~SET `整数として構文解析する$( %値 )
</li>
			<li>
~IF［
%値 ~EQ `失敗^i
］
⇒
%値 ~SET 0
</li>
			<li>
%正規化-済み~map[ %名前 ] ~SET %値
</li>
		</ol>
◎
↓</li>
	<li>
( %左端, %上端, %横幅, %縦幅 )
~LET 順に
⇒＃
%正規化-済み~map[ `left$opf ],
%正規化-済み~map[ `top$opf ],
%正規化-済み~map[ `width$opf ],
%正規化-済み~map[ `height$opf ]
◎
Let x be null.
◎
Let y be null.
◎
Let width be null.
◎
Let height be null.
</li>
	<li>
<p>
~IF［
%左端 ~NEQ ε
］：
◎
If tokenizedFeatures["left"] exists:
• Set x to the result of invoking the rules for parsing integers on tokenizedFeatures["left"].
• If x is an error, set x to 0.
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%左端 を［
%可用な~screen の外側に %~UIwindow が出ない大きさ
］に切詰める
◎
Optionally, clamp x in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による %~screen の左辺に相対的な  %~UIwindow の左辺の横方向 座標 ~EQ %左端
］になるよう，
%~UIwindow を移動する
◎
Optionally, move target’s window such that the window’s left edge is at the horizontal coordinate x relative to the left edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is rightward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%上端 ~NEQ ε
］：
◎
If tokenizedFeatures["top"] exists:
• Set y to the result of invoking the rules for parsing integers on tokenizedFeatures["top"].
• If y is an error, set y to 0.
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%上端 を［
%可用な~screen の外側に %~UIwindow が出ない大きさ
］に切詰める
◎
Optionally, clamp y in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による %~screen の上辺に相対的な %~UIwindow の上辺の縦方向 座標 ~EQ %上端
］になるよう，
%~UIwindow を移動する
◎
Optionally, move target’s window such that the window’s top edge is at the vertical coordinate y relative to the top edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is downward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%横幅 ~NIN { ε, 0 }
］：
◎
If tokenizedFeatures["width"] exists:
• Set width to the result of invoking the rules for parsing integers on tokenizedFeatures["width"].
• If width is an error, set width to 0.
• If width is not 0:
</p>
		<ol>
			<li>

任意選択で，~UA定義な方式で
⇒
%横幅 を，
%可用な~screen の中で %~UIwindow の大きさが~~適度な［
上限, 下限
］に収まるよう切詰める
◎
Optionally, clamp width in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による表示域の左辺と右辺の距離 ~EQ %横幅
］になるよう，
%~UIwindow の右辺を移動して， %~UIwindow の~sizeを変える
◎
Optionally, size target’s window by moving its right edge such that the distance between the left and right edges of the viewport are width CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%~UIwindow を，
%可用な~screen をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%縦幅 ~NIN { ε, 0 }
］：
◎
If tokenizedFeatures["height"] exists:
• Set height to the result of invoking the rules for parsing integers on tokenizedFeatures["height"].
• If height is an error, set height to 0.
• If height is not 0:
</p>
		<ol>
			<li>
任意選択で，~UA定義な方式で
⇒
%縦幅 を，
%可用な~screen の中で %~UIwindow の大きさが~~適度な［
上限, 下限
］に収まるよう切詰める
◎
Optionally, clamp height in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
［
%~pixel単位 による表示域の上辺と下辺の距離 ~EQ %縦幅
］になるよう，
%~UIwindow の下辺を移動して， %~UIwindow の~sizeを変える
◎
Optionally, size target’s window by moving its bottom edge such that the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
			<li>
任意選択で，~UA定義な方式で
⇒
%~UIwindow を，
%可用な~screen をはみ出さないよう移動する
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
次に挙げるものが
`~supportされる~open_m特能~名@
である：
◎
A supported open() feature name is one of the following:
</p>

<dl>
	<dt>`width@opf</dt>
	<dd>
表示域の横幅
◎
The width of the viewport.
</dd>

	<dt>`height@opf</dt>
	<dd>
表示域の縦幅
◎
The height of the viewport.
</dd>

	<dt>`left@opf</dt>
	<dd>
~UIwindowの左端の位置
◎
The left position of the window.
</dd>

	<dt>`top@opf</dt>
	<dd>
~UIwindowの上端の位置
◎
The top position of the window.
</dd>

</dl>

		</section>
		<section id="the-mediaquerylist-interface">
<h3 title="The MediaQueryList Interface">4.2. `MediaQueryList^I ~interface</h3>

<p>
この節は、
`HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
`MediaQueryList$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`媒体~query~list@</dt>
	<dt>`文書@mq</dt>
	<dd>
作成-時に設定される。
◎
A MediaQueryList object has an associated media query list and an associated document set on creation.
</dd>

	<dt>`媒体@mq</dt>
	<dd>
<a href="~CSSOM1#serialize-a-media-query-list">直列化-</a>された形による，`媒体~query~list$。
◎
A MediaQueryList object has an associated media which is the serialized form of the associated media query list.
</dd>

	<dt>`合致-状態@mq</dt>
	<dd>
結付けられている`媒体~query~list$が［
`文書$mqの状態に合致するときは ~T ／
~ELSE_ ~F
］を返す。
◎
A MediaQueryList object has an associated matches state which is true if the associated media query list matches the state of the document, and false otherwise.
</dd>

</dl>

<div class="algo">
<p>
`文書~用の媒体~queryを評価して変化を報告する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to evaluate media queries and report changes for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
~EACH( `MediaQueryList$I ~obj %~target )
に対し，先に作成されたものから順に：
</p>
		<ol>
			<li>
~IF［
%~target の`文書$mq ~NEQ %文書
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%~target の`合致-状態$mqは、
この手続きを前回~走らせたときから変化していない
］
⇒
~CONTINUE
</li>
			<li>
`~eventを発火する$( %~target, `change$et, `MediaQueryList$I )
— 次のように初期化して
⇒＃
`isTrusted$m 属性 ~SET ~T,
`media$m1 属性 ~SET %~target の`媒体$mq,
`matches$m1 属性 ~SET %~target の`合致-状態$mq
【！fingerprint】
</li>
		</ol>
◎
For each MediaQueryList object target that has doc as its document, in the order they were created, oldest first, run these substeps:
• If target’s matches state has changed since the last time these steps were run, fire an event at target using the MediaQueryListEvent constructor, with its type attribute initialized to change, its isTrusted attribute initialized to true, its media attribute initialized to target’s media, and its matches attribute initialized to target’s matches state.
</li>
</ol>
</div>

<div class="example">
<p>
`表示域$の方位（ `orientation^en ）の変化を検出する単純な~code片は、
次のように書かれるであろう：
◎
A simple piece of code that detects changes in the orientation of the viewport can be written as follows:
</p>

<pre class="lang-js">
function handleOrientationChange(%event) {
  if(%event.`matches$m) // landscape
    …
  else
    …
}
var %mql = <a href="#dom-window-matchmedia">`matchMedia^m</a>(`(orientation:landscape)^l);
%mql.`onchange$m = handleOrientationChange;
</pre>

</div>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryList@I : `EventTarget$I {
  readonly attribute `CSSOMString$ `media$m;
  readonly attribute `boolean$ `matches$m;
  `undefined$ `addListener$m(`EventListener$I? %callback);
  `undefined$ `removeListener$m(`EventListener$I? %callback);
           attribute `EventHandler$I `onchange$m;
};
</pre>

<div class="algo">
`media@m
取得子~手続きは
⇒
~RET コレに結付けられている`媒体$mq
◎
The media attribute must return the associated media.
</div>

<div class="algo">
`matches@m
取得子~手続きは
⇒
~RET コレに結付けられている`合致-状態$mq
【！fingerprint】
◎
The matches attribute must return the associated matches state.
</div>

<div class="algo">
<p>
`addListener(callback)@m
~method手続きは：
◎
The addListener(callback) method, when invoked, must run these steps:
</p>
<ol>
	<li>
`~event~listenerを追加する$( コレ, 次のようにされた`~event~listener$ )
⇒＃
`type$evL ~SET `change$et,
`callback$evL ~SET %callback
◎
Add an event listener with this and an event listener whose type is change, and callback is callback.
</li>
</ol>
</div>

<div class="algo">
<p>
`removeListener(callback)@m
~method手続きは：
◎
The removeListener(callback) method, when invoked, must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`~event~listener~list$内に［
( `type$evL, `callback$evL, `capture$evL )
~EQ ( `change$et, %callback, ~F )
］を満たす`~event~listener$がある
］
⇒
`~event~listenerを除去する$( コレ, その~event~listener )
◎
If this’s event listener list contains an event listener whose type is change, callback is callback, and capture is false, then remove an event listener with this and that event listener.
</li>
</ol>
</div>

<p class="note">注記：
この仕様は、
当初は，［
`addListener()$m ／ `removeListener()$m
］による~custom~callbackの仕組みを利用していた
— その~callbackは、
結付けられている`媒体~query~list$を引数に呼出されていた。
今や、
通常の~eventの仕組みが代わりに利用される。
後方-互換性を得るため、［
`addListener()$m ／ `removeListener()$m
］~methodは基本的に［
`addEventListener()$m ／ `removeEventListener()$m
］の別名になり，
`change$et ~eventが `MediaQueryList$I のふりをする。
◎
Note: This specification initially had a custom callback mechanism with addListener() and removeListener(), and the callback was invoked with the associated media query list as argument. Now the normal event mechanism is used instead. For backwards compatibility, the addListener() and removeListener() methods are basically aliases for addEventListener() and removeEventListener(), respectively, and the change event masquerades as a MediaQueryList.
</p>

<p>
`MediaQueryList$I ~interfaceを実装する~objは、
`onchange@m
`~event~handler$（および，対応する`~event~handler~event型$ `change$et ）を，`~event~handler~IDL属性$として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MediaQueryList interface:
◎
Event handler｜Event handler event type
onchange｜change
</p>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryListEvent@I : `Event$I {
  `MediaQueryListEvent@mc(`CSSOMString$ %type, optional `MediaQueryListEventInit$I %eventInitDict = {});

  readonly attribute `CSSOMString$ `media$m;
  readonly attribute `boolean$ `matches$m;
};

dictionary `MediaQueryListEventInit@I : `EventInit$I {
  `CSSOMString$ `media@mb = "";
  `boolean$ `matches@mb = false;
};
</pre>

`MediaQueryListEvent^I0

<div class="algo">
`media@m
取得子~手続きは、
初期化-時の値を返す。
◎
The media attribute must return the value it was initialized to.
</div>

<div class="algo">
`matches@m
取得子~手続きは、
初期化-時の値を返す。
◎
The matches attribute must return the value it was initialized to.
</div>

			<section id="mediaquerylist-event-summary">
<h4 title="Event summary">4.2.1. ~event要覧</h4>

~INFORMATIVE

<table><thead><tr><th>~event
<th>~interface
<th>~target
<th>記述
</thead>

<tbody><tr><td>`change@et
<td>`Event$I
<td>`MediaQueryList$I
<td>
`合致-状態$mqが変化したときに `MediaQueryList$I に向けて発火される。
◎
Fired at the MediaQueryList when the matches state changes.
</tbody></table>

			</section>
		</section>
		<section id="the-screen-interface">
<h3 title="The Screen Interface">4.3. `Screen^I ~interface</h3>

<p>
その名前が示唆するとおり、
`Screen$I ~interfaceは，出力~機器の~screenについての情報を表現する。
◎
As its name suggests, the Screen interface represents information about the screen of the output device.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Screen@I {
  readonly attribute `long$ `availWidth$m;
  readonly attribute `long$ `availHeight$m;
  readonly attribute `long$ `width$m;
  readonly attribute `long$ `height$m;
  readonly attribute `unsigned long$ `colorDepth$m;
  readonly attribute `unsigned long$ `pixelDepth$m;
};
</pre>

`Screen^dgm

<div class="algo">
［
`availWidth@m ｜ `availHeight@m
］取得子~手続きは
⇒
~RET `~Webに公開される可用な~screen区画$の［
横幅 ｜ 縦幅
］
◎
The availWidth attribute must return the width of the Web-exposed available screen area.
◎
The availHeight attribute must return the height of the Web-exposed available screen area.
</div>

<div class="algo">
［
`width@m ｜ `height@m
］取得子~手続きは
⇒
~RET `~Webに公開される~screen区画$の［
横幅 ｜ 縦幅
］
◎
The width attribute must return the width of the Web-exposed screen area.
◎
The height attribute must return the height of the Web-exposed screen area.
</div>

<p>
［
`colorDepth@m
／
`pixelDepth@m
］属性の取得子は、
いずれも：
◎
The colorDepth and pixelDepth attributes＼
</p>
<ul>
	<li>
出力~機器における~pixelの色に割振られている~bit数を
— その~alpha~channelは除外して —
返すベキである。
~UAがこの~bit数を知り得ない場合は、
自身による最も近い見積もりを返すベキである
— 例えば、
出力~機器が利用する値に最も近くなるような，［
機器に送り込まれる~frame~buffer, または何らかの内部~表現
］に利用されている~bit数など。
◎
should return the number of bits allocated to colors for a pixel in the output device, excluding the alpha channel. If the user agent is not able to return the number of bits used by the output device, it should return the closest estimation such as, for example, the number of bits used by the frame buffer sent to the display or any internal representation that would be the closest to the value the output device would use.＼
</li>
	<li>
`color$d 媒体~特能の値の 3 倍~以上の値を返すモノトスル
— ~bit数が色~成分ごとに異なる場合、
返す値は 3 倍を超えてもヨイ。
~UAは、
色~深度を［
知り得ない, または~privacyに配慮するため返したくない
］場合は， 24 を返すベキである。
◎
The user agent must return a value for these attributes at least equal to the value of color media query multiplied by three. If the different color components are not represented with the same number of bits, the returned value may be greater than three times color media query. If the user agent does not know the color depth or does not want to return it for privacy considerations, it should return 24.
</li>
	<li class="note">注記：
互換性の理由から，両~属性とも同じ値を返す。
◎
Note: The colorDepth and pixelDepth attributes return the same value for compatibility reasons.
</li>
	<li class="note">注記：
一部の不適合な実装は、
24 でなく 32 を返すことが知られている。
◎
Note: Some non-conforming implementations are known to return 32 instead of 24.
</li>
</ul>

		</section>
	</section>
	<section id="extensions-to-the-document-interface">
<h2 title="Extensions to the Document Interface">5. `Document^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Document$I {`Document^I0
  `Element$I? `elementFromPoint$m(`double$ %x, `double$ %y);
  `sequence$&lt;`Element$I&gt; `elementsFromPoint$m(`double$ %x, `double$ %y);
  `CaretPosition$I? `caretPositionFromPoint$m(`double$ %x, `double$ %y);
  readonly attribute `Element$I? `scrollingElement$m;
};
</pre>

`Document^dgm

<div class="algo">
<p>
`elementFromPoint(x, y)@m
~method手続きは：
◎
The elementFromPoint(x, y) method must follow these steps:
</p>
<ol>
	<li>
~IF［
コレに結付けられている`表示域$は無い
］
⇒
~RET ~NULL
◎
↓</li>
	<li>
~IF［［［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］］ではない
］
⇒
~RET ~NULL
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return null and terminate these steps.
</li>
	<li>
~IF［
`表示域$の子孫に対する`変形$を適用した下で，座標 (%x, %y) の`接触判定$の標的になる`~layout~box$は`表示域$内にある
］
⇒
~RET それを結付けている要素
◎
If there is a layout box in the viewport that would be a target for hit testing at coordinates x,y, when applying the transforms that apply to the descendants of the viewport, return the associated element and terminate these steps.
</li>
	<li>
~RET コレの`根~要素$
◎
If the document has a root element, return the root element and terminate these steps.
◎
Return null.
</li>
</ol>

<p class="note">注記：
`elementFromPoint()^m ~methodは、
最も手前に塗られている要素を返すとは限らない。
例えば、
要素は， `pointer-events$p ~CSS~propの利用を通して`接触判定$の標的から除外され得る。
◎
Note: The elementFromPoint() method does not necessarily return the top-most painted element. For instance, an element can be excluded from being a target for hit testing by using the pointer-events CSS property.
</p>

</div>

<div class="algo">
<p>
`elementsFromPoint(x, y)@m
~method手続きは：
◎
The elementsFromPoint(x, y) method must follow these steps:
</p>
<ol>
	<li>
%~list ~LET 新たな~list
◎
Let sequence be a new empty sequence.
</li>
	<li>
<p>
~IF［
コレに結付けられている`表示域$はある
］~AND［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］：
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return sequence and terminate these steps.
</p>
		<ol>
			<li>
%~list に次を満たす すべての要素を付加する
— 最~上端な【すなわち，最も手前に塗られる】~boxから順に，要素の`~layout~box$の塗り順序で
⇒
要素の`~layout~box$は、
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内にあって座標 (%x, %y) における`接触判定$の標的になる（そこに何も `overlap^en していないとしても【要素には塗られる内容がないとしても？】）
◎
For each layout box in the viewport, in paint order, starting with the topmost box, that would be a target for hit testing at coordinates x,y even if nothing would be overlapping it, when applying the transforms that apply to the descendants of the viewport, append the associated element to sequence.
</li>
			<li>
~IF［
%~list は空でない
］~AND［
コレの`根~要素$ %根 ~NIN { ~NULL, %~list の最後の~item }
］
⇒
%~list に %根 を付加する
◎
If the document has a root element, and the last item in sequence is not the root element, append the root element to sequence.
</li>
		</ol>
	</li>
	<li>
~RET %~list を表現する連列~型~obj
◎
Return sequence.
</li>
</ol>
</div>

<div class="algo">
<p>
`caretPositionFromPoint(x, y)@m
~method手続きは：
◎
The caretPositionFromPoint(x, y) method must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレに結付けられている`表示域$は無い
］
⇒
~RET ~NULL
◎
If there is no viewport associated with the document, return null.
</li>
	<li>
~IF［［［
0 ~LTE %x ~LTE `表示域$の`有効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`有効~縦幅$
］］でない
］
⇒
~RET ~NULL
<!-- 
引数が指す座標が`表示域$の外を指す場合、 null を返す（“表示域の外” の定義は上の <code>elementFromPoint</code> の記述と同じ）。
-->
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), y is greater than the viewport height excluding the size of a rendered scroll bar (if any) return null.
</li>
	<li>
~IF［［
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内の座標
( %x, %y )
の所に~text挿入位置指示が挿入されることになる
］ではない
］
⇒
~RET ~NULL
◎
If at the coordinates x,y in the viewport no text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, return null.
</li>
	<li>
~IF［
`表示域$の子孫に対する`変形$を適用した下で，`表示域$内の座標
( %x, %y )
の所に, かつ［
`置換d要素$による~text手入力~widget
］内に，~text挿入位置指示が挿入されることになる
］
⇒
~RET 次のように設定された`~caret位置$
⇒＃
`~caret範囲$ ~SET ~NULL,
`~caret~node$ ~SET ~text手入力~widgetに対応する~node,
`~caret~offset$ ~SET 左端から~text挿入位置指示が挿入される地点までにある`符号単位$の個数
◎
If at the coordinates x,y in the viewport a text insertion point indicator would have been inserted in a text entry widget which is also a replaced element, when applying the transforms that apply to the descendants of the viewport, return a caret position with its properties set as follows:
• caret node
•• The node corresponding to the text entry widget.
• caret offset
•• The amount of 16-bit units to the left of where the text insertion point indicator would have inserted. 
• caret range
•• null
</li>
	<li>
%~caret範囲 ~LET ［
`表示域$の子孫に対する`変形$を適用した下で，~text挿入位置指示が挿入されることになる地点
］を指すような，`畳まれて$いる `Range$I ~obj
◎
Otherwise, return a caret position where the caret range is a collapsed Range object for the position where the text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, and＼
</li>
	<li>
~RET 次のように設定された`~caret位置$
⇒＃
`~caret範囲$ ~SET %~caret範囲,
`~caret~node$ ~SET %~caret範囲 の`始端~node$,
`~caret~offset$ ~SET %~caret範囲 の`始端~offset$
◎
the other properties are set as follows:
◎
caret node
• The start node of the caret range.
caret offset
• The start offset of the caret range. 
</li>
</ol>
</div>

<p class="note">注記：
`接触判定@
の詳細は、
この仕様の視野から外れる。
したがって［
`elementFromPoint()$m ／
`caretPositionFromPoint()$m
］の正確な詳細についても同様になる。
接触判定は、
希望的には，~CSSまたは~HTMLの将来における改訂にて定義されることになる。
◎
Note: The specifics of hit testing are out of scope of this specification and therefore the exact details of elementFromPoint() and caretPositionFromPoint() are therefore too. Hit testing will hopefully be defined in a future revision of CSS or HTML.
</p>

<div class="algo">
<p>
`scrollingElement@m
取得子~手続きは：
◎
The scrollingElement attribute, on getting, must run these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレは`過去互換~mode$下にある
］：
◎
If the Document is in quirks mode, follow these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
`~HTML~body要素$ %~body は在る
］~AND［
%~body は`~scroll可能になり得ない$†
］
⇒
~RET %~body
◎
If the HTML body element exists, and it is not potentially scrollable, return the HTML body element and abort these steps.
</p>

<p>†
この目的においては、
%~body の `overflow$p 値が `clip^v の場合には，
%~body の親~要素の `overflow$p は `hidden^v として扱うモノトスル。
◎
For this purpose, a value of overflow:clip on the HTML body element’s parent element must be treated as overflow:hidden.
</p>
			</li>
			<li>
~RET ~NULL
◎
Return null and abort these steps.
</li>
		</ol>
	</li>
	<li>
~RET コレの`根~要素$
◎
If there is a root element, return the root element and abort these steps.
◎
Return null.
</li>
</ol>

<p class="note">注記：
［
`scrollTop^m, `scrollLeft^m
］用には常に`過去互換~mode$の挙動を利用する，不適合な~UA用には、［
`scrollingElement$m 属性は，常に`~HTML~body要素$（あるいは，なければ ~NULL ）を返す
］ものと期待されている。
この~APIが存在するのは、
~Web開発者が，~scroll用~APIに利用する~~正しい要素を取得できるようにするためである
— 特定0の~UAの挙動を前提にしたり，どの要素が表示域を~scrollするかを見るために~scrollを呼出す必要なく。
◎
Note: For non-conforming user agents that always use the quirks mode behavior for scrollTop and scrollLeft, the scrollingElement attribute is expected to also always return the HTML body element (or null if it does not exist). This API exists so that Web developers can use it to get the right element to use for scrolling APIs, without making assumptions about a particular user agent’s behavior or having to invoke a scroll to see which element scrolls the viewport.
</p>

<p class="note">注記：
`~HTML~body要素$は、
~HTMLの `document.body^m とは異なる
— 後者は `frameset^e 要素を返すこともある。
◎
Note: The HTML body element is different from HTML’s document.body in that the latter can return a frameset element.
</p>
</div>

		<section id="the-caretposition-interface">
<h3 title="The CaretPosition Interface">5.1. `CaretPosition^I ~interface</h3>

<p>
`~caret位置@
とは、
~text挿入位置指示の位置を与えるものであり，常に［
`~caret~node@,
`~caret~offset@,
`~caret範囲@
］が結付けられる。
~caret位置は、
`CaretPosition$I ~objにより表現される。
◎
A caret position gives the position of a text insertion point indicator. It always has an associated caret node, caret offset, and caret range. It is represented by a CaretPosition object.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CaretPosition@I {
  readonly attribute `Node$I `offsetNode$m;
  readonly attribute `unsigned long$ `offset$m;
  [`NewObject$] `DOMRect$I? `getClientRect$m();
};
</pre>

<div class="algo">
`offsetNode@m
取得子~手続きは
⇒
~RET コレの`~caret~node$
◎
The offsetNode attribute must return the caret node.
</div>

<div class="algo">
`offset@m
取得子~手続きは
⇒
~RET コレの`~caret~offset$
◎
The offset attribute must return the caret offset.
</div>

<div class="algo">
<p>
`getClientRect()@m
~method手続きは：
◎
The getClientRect() method must follow these steps, aborting on the first step that returns a value:
</p>
<ol>
	<li>
<p>
~IF［
コレの`~caret範囲$ ~NEQ ~NULL
］：
◎
If caret range is not null:
</p>
		<ol>
			<li>
%~list ~LET コレの`~caret範囲$上の 
`Range^I1 `getClientRects$m1 ~method手続き()
◎
Let list be the result of invoking the getClientRects() method on the range.
</li>
			<li>
~IF［
%~list は空である
］
⇒
~RET ~NULL
◎
If list is empty, return null.
</li>
			<li>
~RET %~list 内の最初の `DOMRect$I ~obj
◎
Return the DOMRect object in list at index 0.
</li>
		</ol>
	</li>
	<li>
~IF［
コレの`~caret~node$ %node は，［
`置換d要素$による~text手入力~widgetである
］~AND［
文書~内に在る【！＊in the document】
］］
⇒
~RET 
%node とその先祖に対する`変形$を適用した下で、
%node 内の，`~caret~offset$ の値で表現される~caretに対する `DOMRect$I ~obj
◎
If caret node is a text entry widget that is a replaced element, and that is in the document, return a DOMRect object for the caret in the widget as represented by the caret offset value. The transforms that apply to the element and its ancestors are applied.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: This DOMRect object is not live.
</p>
</div>

		</section>
	</section>
	<section id="extension-to-the-element-interface">
<h2 title="Extensions to the Element Interface">6.  `Element^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollLogicalPosition@I { `start@l, `center@l, `end@l, `nearest@l };

dictionary `ScrollIntoViewOptions@I : `ScrollOptions$I {
  `ScrollLogicalPosition$I `block@mb = `start$l;
  `ScrollLogicalPosition$I `inline@mb = `nearest$l;
};

dictionary `IsVisibleOptions@I {

};
</pre>

<pre class="idl">
partial interface `Element$I {`Element^I0
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();

  `boolean$ `isVisible$m(optional `IsVisibleOptions$I = {});

  `undefined$ `scrollIntoView$m(optional (`boolean$ or `ScrollIntoViewOptions$I) %arg = {});
  `undefined$ `scroll$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scroll$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollTo$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollTo$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `undefined$ `scrollBy$m(optional `ScrollToOptions$I %options = {});
  `undefined$ `scrollBy$m(`unrestricted double$ %x, `unrestricted double$ %y);
  attribute `unrestricted double$ `scrollTop$m;
  attribute `unrestricted double$ `scrollLeft$m;
  readonly attribute `long$ `scrollWidth$m;
  readonly attribute `long$ `scrollHeight$m;
  readonly attribute `long$ `clientTop$m;
  readonly attribute `long$ `clientLeft$m;
  readonly attribute `long$ `clientWidth$m;
  readonly attribute `long$ `clientHeight$m;
};
</pre>

`Element^dgm

<div class="algo">
<p>
`getClientRects()@m
~method手続きは：
◎
The getClientRects() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
~IF［
コレは`~layout~box$を持たない
］
⇒
~RET 空な `DOMRectList$I ~obj
◎
If the element on which it was invoked does not have an associated layout box return an empty DOMRectList object and stop this algorithm.
</li>
	<li>
~IF［
コレは`~SVG~layout~box$を持つ
］
⇒
~RET 次で与えられる矩形を表す 1 個の `DOMRect$I ~objからなる `DOMRectList$I ~obj
⇒
コレとその先祖に対する`変形$を適用した下で，~SVG仕様の定義に従うコレの限界~box
◎
If the element has an associated SVG layout box return a DOMRectList object containing a single DOMRect object that describes the bounding box of the element as defined by the SVG specification, applying the transforms that apply to the element and its ancestors.
</li>
	<li>
<p>
%断片~list ~LET
コレの`~layout~box$内の`~box断片$からなる~list
— ここで：
</p>

<ul>
			<li>
コレの `display$p ~propの算出d値
~IN { `table$v, `inline-table$v }
の場合、
table ~box と caption ~boxは ~listに含めるが，匿名~容器~boxは含めない。
</li>
			<li>
各 `匿名$な`塊~box$は，その子~boxたちに置換する。
匿名な塊~boxが尽きるまで，これを繰返す。
</li>
			<li>
縦幅／横幅 が 0 であっても~listから除外しない。
</li>
			<li>
~listは、
内容~順による。
</li>
		</ul>
◎
Return a DOMRectList object containing DOMRect objects in content order, one for each box fragment, describing its border area (including those with a height or width of zero) with the following constraints:
• Apply the transforms that apply to the element and its ancestors.
• If the element on which the method was invoked has a computed value for the display property of table or inline-table include both the table box and the caption box, if any, but not the anonymous container box.
• Replace each anonymous block box with its child box(es) and repeat this until no anonymous block boxes are left in the final list.
</li>
	<li>
%矩形~list ~LET 空な~list
◎
↑</li>
	<li>
<p>
%断片~list を成す
~EACH( %断片 )
に対し
⇒
%矩形~list に次を表現する `DOMRect$I ~objを付加する
⇒
%断片 の`~border区画$に［
コレとその先祖に対する`変形$
］を適用して得られる図形
］を包含するような，最~小な矩形
◎
↑</p>

<p class="trans-note">【
原文には “最~小な矩形” という記述は無いが、
変形を孕んでいるので，必然的にそうなる。
】</p>
</li>
	<li>
<p>
~RET %矩形~list を表現している `DOMRectList$I ~obj
◎
↑</p>

<p class="trans-note">【
新たな~objを返すとは限らない
（前回の呼出nから何も変化していない場合、同じ~objを返すかもしれない）。
】</p>
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objたちは、
`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</p>
</div>

<div class="algo">
<p>
`getBoundingClientRect()@m
~method手続きは：
◎
The getBoundingClientRect() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
%~list ~LET コレの `getClientRects$m ~method手続き()
◎
Let list be the result of invoking getClientRects() on the same element this method was invoked on.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET 次のようにされた新たな `DOMRect$I ~obj
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If the list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
	<li>
~IF［
%~list 内の矩形は，どれも［
横幅, 縦幅
］どちらかは 0
］
⇒
~RET %~list 内の最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
	<li>
~RET 次を表現する新たな `DOMRect$I ~obj
⇒
%~list 内の［［
横幅, 縦幅
］どちらかは【どちらも？】 0 でない矩形
］すべてを包含する最~小な矩形
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</p>

<div class="example">
<p>
次の~code片は文書~内の最初の `div^e 要素の~sizeを取得する：
◎
The following snippet gets the dimensions of the first div element in a document:
</p>

<pre class="lang-js">
var example = document
    .getElementsByTagName("div")[0]
    .getBoundingClientRect();
var exampleWidth = example.width;
var exampleHeight = example.height;
</pre>
</div>
</div>

<div class="algo">
<p>
`isVisible(options)@m
~method手続きは：
◎
The isVisible(options) method must run these steps, when called on an element this:
</p>
<ol>
	<li>
~IF［
コレは`~layout~box$を持たない
］
⇒
~RET ~F
◎
If this does not have an associated layout box, return false.
</li>
	<li>
~IF［
コレの`~shadowも含む広義-先祖$に［
その `content-visibility$p は `hidden^v にされたもの
］は在る
］
⇒
~RET ~F
◎
If this, or a shadow-inclusive ancestor of this, has content-visibility: hidden, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`scrollIntoView(arg)@m
~method手続きは：
◎
The scrollIntoView(arg) method must run these steps:
</p>
<ol>
	<li>
%挙動 ~LET `auto^l
◎
Let behavior be "auto".
</li>
	<li>
%塊 ~LET `start^l
◎
Let block be "start".
</li>
	<li>
%行内 ~LET `nearest^l
◎
Let inline be "nearest".
</li>
	<li>
~IF［
%arg は `ScrollIntoViewOptions$I 辞書である
］
⇒＃
%挙動 ~SET %options[ "`behavior$mb" ],
%塊 ~SET %options[ "`block$mb" ]
%行内 ~SET  %options[ "`inline$mb" ]
◎
If arg is a ScrollIntoViewOptions dictionary, then:
• Set behavior to the behavior dictionary member of options.
• Set block to the block dictionary member of options.
• Set inline to the inline dictionary member of options.
</li>
	<li>
~ELIF［
%arg ~EQ ~F
］
⇒
%塊 ~SET `end^l
◎
Otherwise, if arg is false, then set block to "end".
</li>
	<li>
~IF［
コレは`~layout~box$を持たない
］~OR［
コレは~UA特能
【例：~tab~Keyによる巡回】
に可用でない
【例：先祖の`内容が飛ばされ$ている場合】
］
⇒
~RET
◎
If the element does not have any associated layout box, or is not available to user-agent features, then return.
</li>
	<li>
コレを`~viewの中へ~scrollする$( %挙動, %塊, %行内 )
◎
Scroll the element into view with behavior, block, and inline.
</li>
	<li>
任意選択で
⇒
利用者に コレを注目してもらう何らかの動作があれば，それを遂行する
◎
Optionally perform some other action that brings the element to the user’s attention.
</li>
</ol>
</div>

<div class="algo">
<p>
`scroll()@m
~method手続きは：
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x )
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y )
</li>
	<li>
`要素~用の~scroll手続き$( コレ, %x, %y, %behavior )
</li>
</ol>

◎
The scroll() method must run these steps:
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
• Let x be the value of the left dictionary member of options, if present, or the element’s current scroll position on the x axis otherwise.
◎
• Let y be the value of the top dictionary member of options, if present, or the element’s current scroll position on the y axis otherwise.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
◎
↓</div>

<div class="algo">
<p class="trans-note">【
この訳では、［
原文による `scroll()$m ~method手続きを成す引数の取扱い
］以外の部分を，次に与える手続きに分離する
— それは、
複数の箇所から共通して利用されるので。
】</p>

<p>
`要素~用の~scroll手続き@
は、所与の
( %要素, %x, %y, %behavior )
に対し：
◎
↑</p>

<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`根~要素$
］
⇒＃
%x ~SET %window の `Window^I1 `scrollX$m1  取得子~手続き()；
`~window用の~scroll手続き$( %window, %x, %y, `auto$l )
~RET
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
</li>
	<li>
~IF［
%要素 は `~HTML~body要素$ である
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
%要素 は`~scroll可能になり得ない$
］
⇒＃
`~window用の~scroll手続き$( %window, %x, %y, %behavior )；
~RET
◎
If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with options as the only argument, and terminate these steps.
</li>
	<li>
~IF［
%x ~EQ ε
］
⇒
%x ~SET %要素 の現在の x 軸 ~scroll位置
◎
↑</li>
	<li>
~IF［
%y ~EQ ε
］
⇒
%y ~SET %要素 の現在の y 軸 ~scroll位置
◎
↑</li>
	<li>
<p>
~IF［
%要素 は，次のいずれかを満たす
］…：
</p>
		<ul>
			<li>
`~CSS~layout~box$を持たない
</li>
			<li>
`~scrollされる~box$は無い
</li>
			<li>
~overflowしていない
</li>
		</ul>

<p>
…ならば
⇒
~RET
</p>
◎
If the element does not have any associated CSS layout box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
	<li>
`要素を~scrollする$( %要素, ( %x, %y ), %behavior )
◎
Scroll the element to x,y, with the scroll behavior being the value of the behavior dictionary member of options.
</li>
</ol>
</div>

<div class="algo">
`scrollTo()@m
~method手続きは、
`scroll()$m ~method手続きと同じに挙動する。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</div>

<div class="algo">
<p>
`scrollBy()@m
~method手続きは：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
<ol>
	<li>
<p>
( %x, %y, %behavior ) ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
( %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] )
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
( %x, %y, `auto$l )
</li>
		</ul>
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x ) ~PLUS コレの `scrollLeft$m 取得子~手続き()
◎
Add the value of scrollLeft to the left dictionary member.
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y ) ~PLUS コレの `scrollTop$m 取得子~手続き()
◎
Add the value of scrollTop to the top dictionary member.
</li>
	<li>
`要素~用の~scroll手続き$( コレ, %x, %y, %behavior )
◎
Act as if the scroll() method was invoked with options as the only argument.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`scrollTop@m ｜ `scrollLeft@m
］取得子~手続きは：
◎
The scrollTop attribute, on getting, must return the result of running these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET 0
◎
If window is null, return zero and terminate these steps.
</li>
	<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET 0
◎
If the element is the root element and document is in quirks mode, return zero and terminate these steps.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

		<ul>
			<li>
コレ ~EQ %文書 の`根~要素$
</li>
			<li>
［
コレは `~HTML~body要素$である
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
		</ul>
<p>
…ならば
⇒
~RET %window の［
`scrollY^m ｜ `scrollX^m
］の値
</p>

◎
If the element is the root element return the value of scrollY on window.
◎
If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollY on window.
</li>
	<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated CSS layout box, return zero and terminate these steps.
</li>
	<li>
~RET
コレの`~scrollされる区画$の整列~点から相対的な，
コレの`~padding辺$の［
上端の y 座標 ｜ 左端の x 座標
］
◎
Return the y-coordinate of the scrolling area at the alignment point with the top of the padding edge of the element.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`scrollTop$m ｜ `scrollLeft$m
］設定子~手続きは：
◎
When setting the scrollTop attribute these steps must be run:
</p>
<ol>
	<li>
%v ~LET `有限~値に正規化する$( 所与の値 )
◎
Let y be the given value.
◎
Normalize non-finite values for y.
</li>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
	<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
コレ ~EQ %文書 の`根~要素$
</li>
			<li>
［
コレは `~HTML~body要素$ である
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
		</ul>
<p>
…ならば：
`Window^I1
</p>
		<ol>
			<li>
%x ~LET ［ %window の `scrollX$m1 取得子~手続き() ｜ %v ］
</li>
			<li>
%y ~LET ［ %v ｜ %window の `scrollY$m1 取得子~手続き() ］
</li>
			<li>
`~window用の~scroll手続き$( %window, %x, %y, `auto$l )
</li>
			<li>
~RET
</li>
		</ol>
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
◎
If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with scrollX as first argument and y as second argument, and terminate these steps.
</li>
	<li>
<p>
~IF［
コレは，次のいずれかを満たす
］…：
</p>
		<ul>
			<li>
`~CSS~layout~box$を持たない
</li>
			<li>
`~scrollされる~box$は無い
</li>
			<li>
~overflowしていない
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>

◎
If the element does not have any associated CSS layout box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
	<li>
%目的位置 ~LET ( ［
コレの `scrollLeft$m 取得子~手続き() ｜ %v
］, ［
%v ｜ コレの `scrollTop$m 取得子~手続き()
］ )
◎
↓</li>
	<li>
`要素を~scrollする$( コレ,  %目的位置 , `auto$l )
◎
Scroll the element to scrollLeft,y, with the scroll behavior being "auto".
</li>
</ol>
</div>

<p class="en">
◎
The scrollLeft attribute, on getting, must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, return zero and terminate these steps.
• If the element is the root element and document is in quirks mode, return zero and terminate these steps.
• If the element is the root element return the value of scrollX on window.
• If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollX on window.
• If the element does not have any associated CSS layout box, return zero and terminate these steps.
• Return the x-coordinate of the scrolling area at the alignment point with the left of the padding edge of the element.
◎
When setting the scrollLeft attribute these steps must be run:
• Let x be the given value.
• Normalize non-finite values for x.
• Let document be the element’s node document.
• If document is not the active document, terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, terminate these steps.
• If the element is the root element and document is in quirks mode, terminate these steps.
• If the element is the root element invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element is the HTML body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element does not have any associated CSS layout box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
• Scroll the element to x,scrollTop, with the scroll behavior being "auto".
</p>

<div class="algo">
<p>
［
`scrollWidth@m ｜ `scrollHeight@m 
］取得子~手続きは：
◎
The scrollWidth attribute must return the result of running these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

		<ul >
			<li>
［
%文書 は`過去互換~mode$下にない
］~AND［
コレ ~EQ %文書 の`根~要素$
］
</li>
			<li>
［
%文書 は`過去互換~mode$下にある
］~AND［
コレは `~HTML~body要素$である
］~AND［
コレは
`~scroll可能になり得ない$
］
</li>
		</ul>

<p>
…ならば：
</p>
		<ol>
			<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
			<li>
~RET
`max^op( `表示域$の`~scrollされる区画$の［
横幅 ｜ 縦幅
］, `表示域$の［
`有効~横幅$ ｜ `有効~縦幅$
］ )
</li>
		</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any, or zero if there is no viewport.
◎
If the element is the root element and document is not in quirks mode return max(viewport scrolling area width, viewport width).
◎
If the element is the HTML body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area width, viewport width).
</li>
	<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated CSS layout box return zero and terminate these steps.
</li>
	<li>
~RET
コレの`~scrollされる区画$の［
横幅 ｜ 縦幅
］
◎
Return the width of the element’s scrolling area.
</li>
</ol>
</div>

<p class="en">
◎
The scrollHeight attribute must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let viewport height be the height of the viewport excluding the height of the scroll bar, if any, or zero if there is no viewport.
• If the element is the root element and document is not in quirks mode return max(viewport scrolling area height, viewport height).
• If the element is the HTML body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area height, viewport height).
• If the element does not have any associated CSS layout box return zero and terminate these steps.
• Return the height of the element’s scrolling area.
</p>

<div class="algo">
<p>
［
`clientTop@m ｜ `clientLeft@m
］取得子~手続きは：
◎
The clientTop attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレは `~CSS~layout~box$を持たない
］~OR［
コレの `~CSS~layout~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
</li>
	<li>
<p>
~RET 次の和：
</p>
		<ul>
			<li>
［
`border-top-width$p ｜ `border-left-width$p
］~propの算出d値
</li>
	<li>
`~padding辺$の［
上端 ｜ 左端
］と`~border辺$の［
上端 ｜ 左端
］の間に描画された~scroll~barの［
縦幅 ｜ 横幅
］
</li>
		</ul>
<p>
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</p>
◎
Return the computed value of the border-top-width property plus the height of any scrollbar rendered between the top padding edge and the top border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
</ol>
</div>

<p class="en">
◎
The clientLeft attribute must run these steps:
• If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
• Return the computed value of the border-left-width property plus the width of any scrollbar rendered between the left padding edge and the left border edge, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
<p>
［
`clientWidth@m ｜ `clientHeight@m
］取得子~手続きは：
◎
The clientWidth attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレは `~CSS~layout~box$を持たない
］~OR［
コレの `~CSS~layout~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にない
］
</li>
			<li>
［
コレは `~HTML~body要素$ である
］~AND［
%文書 は`過去互換~mode$下にある
］
</li>
</ul>

<p>
…ならば
⇒
~RET
`表示域$の［
`有効~横幅$ ｜ `有効~縦幅$
］
</p>
◎
If the element is the root element and the element’s node document is not in quirks mode, or if the element is the HTML body element and the element’s node document is in quirks mode, return the viewport width excluding the size of a rendered scroll bar (if any).
</li>
	<li>
<p>
~RET  `~padding辺$の［
横幅 ｜ 縦幅
］
— ここで：
</p>
		<ul>
			<li>
`~padding辺$と`~border辺$の間に~scroll~barが描画されている場合は，その分の［
横幅 ｜ 縦幅
］は除外する。
</li>
			<li>
コレとその先祖に対する`変形$は適用しないとする。
</li>
		</ul>
◎
Return the width of the padding edge excluding the width of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
</ol>
</div>

<p class="en">
◎
The clientHeight attribute must run these steps:
• If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.
• If the element is the root element and the element’s node document is not in quirks mode, or if the element is the HTML body element and the element’s node document is in quirks mode, return the viewport height excluding the size of a rendered scroll bar (if any).
• Return the height of the padding edge excluding the height of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</p>

		<section id="element-scrolling-members">
<h3 title="Element Scrolling Members">6.1. 要素の~scroll法</h3>

<div class="algo">
<p>
%要素 を
`~viewの中へ~scrollする@
ときは、所与の
⇒＃
~scrollの挙動 %挙動,
塊~flow方向~位置 %塊,
行内~基底~方向~位置 %行内
◎終
に対し，次を走らす：
</p>

<ol>
	<li>
<p>
［
%要素 の先祖~要素 または`表示域$
］のうち`~scrollされる~box$ %~box を確立している
~EACH( %S )
に対し，最も内縁の`~scrollされる~box$から順に：
</p>
		<ol>
			<li>
~IF［
( %要素 に結付けられている`文書$, %S に結付けられている`文書$ )
は `同一-生成元$でない
］
⇒
~RET
</li>
			<li>
%要素境界 ~LET ［
%要素 の `getBoundingClientRect$m ~method手続き()
］の結果を表現する~box
</li>
			<li>
下に与える
“要素境界を~box内に~scrollする”
下位手続きを走らす
</li>
		</ol>
	</li>
</ol>

◎
To scroll an element into view element, with a scroll behavior behavior, a block flow direction position block, and an inline base direction position inline, means to run these steps for each ancestor element or viewport that establishes a scrolling box scrolling box, in order of innermost to outermost scrolling box:
• If the Document associated with element is not same origin with the Document associated with the element or viewport associated with box, terminate these steps.
• Let element bounding border box be the box that the return value of invoking getBoundingClientRect() on element represents.
</div>

<div class="algo">
<p>
上の手続きにて，要素境界を~box内に~scrollするときは：
◎
↑</p>

<ol>
	<li>
<div class="p">
<p>
この段においては：
</p>
		<ul>
			<li>
%~box の辺 %e に対する
%要素境界 の
`同じ側@
の辺とは、
%e と物理的に同じ側にある %要素境界 の辺を指すとする。
</li>
			<li>
［
`開始辺$ ／ `終了辺$ ／ 中心 ／ 距離
］は、［
%塊 に対しては`塊~flow方向$,
%行内 に対しては`行内~基底~方向$
］におけるそれを指すとする。
</li>
		</ul>
<p>
%目的位置 ~LET
( `塊~flow方向$, `行内~基底~方向$ )
成分が 順に
( %塊, %行内 )
に応じて，以下に従うように %~box を整列させる~scroll位置：
</p>
◎
Let scrolling box edge A be the beginning edge in the block flow direction of scrolling box, and let element edge A be element bounding border box’s edge on the same physical side as that of scrolling box edge A.
◎
Let scrolling box edge B be the ending edge in the block flow direction of scrolling box, and let element edge B be element bounding border box’s edge on the same physical side as that of scrolling box edge B.
◎
Let scrolling box edge C be the beginning edge in the inline base direction of scrolling box, and let element edge C be element bounding border box’s edge on the same physical side as that of scrolling box edge C.
◎
Let scrolling box edge D be the ending edge in the inline base direction of scrolling box, and let element edge D be element bounding border box’s edge on the same physical side as that of scrolling box edge D.
◎
Let element height be the distance between element edge A and element edge B.
◎
Let scrolling box height be the distance between scrolling box edge A and scrolling box edge B.
◎
Let element width be the distance between element edge C and element edge D.
◎
Let scrolling box width be the distance between scrolling box edge C and scrolling box edge D.
◎
Let position be the scroll position scrolling box would have by following these steps:
</div>
		<dl class="switch">
			<dt>`start$l</dt>
			<dd>
%~box の`開始辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
If block is "start", then align element edge A with scrolling box edge A.
</dd>

			<dt>`end$l</dt>
			<dd>
%~box の`終了辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
Otherwise, if block is "end", then align element edge B with scrolling box edge B.
</dd>

			<dt>`center$l</dt>
			<dd>
%~box の中心に， %要素境界 の中心を整列する
◎
Otherwise, if block is "center", then align the center of element bounding border box with the center of scrolling box in scrolling box’s block flow direction.
</dd>

			<dt>`nearest$l</dt>
			<dd>
				<ol>
					<li>
%要素~幅 ~LET
%~box の［`開始辺$, `終了辺$］と`同じ側$にある，
%要素境界 を成す 2 辺の距離
◎
↑</li>
					<li>
%~box幅 ~LET
%~box の`開始辺$と`終了辺$の距離
◎
↑</li>
					<li>

<p>
%~box と %要素境界 の位置関係に応じて：
◎
Otherwise, block is "nearest":
</p>

						<dl class="switch">
							<dt>
%~box の［
`開始辺$, `終了辺$
］どちらも，その外側に %要素境界 の`同じ側$の辺がある
◎
If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
</dt>
							<dd>
何もしない
【現在の~scroll位置と同じ】
◎
Do nothing.
</dd>
							<dt>
［
%~box の`開始辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~LT %~box幅
］
◎
If element edge A is outside scrolling box edge A and element height is less than scrolling box height 
</dt>

							<dt>
［
%~box の`終了辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~GT %~box幅
］
◎
If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
</dt>
							<dd>
%~box の`開始辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
Align element edge A with scrolling box edge A.
</dd>

							<dt>
［
%~box の`開始辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~GT %~box幅
］
◎
If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
</dt>
							<dt>
［
%~box の`終了辺$の外側に
%要素境界 の`同じ側$の辺がある
］~AND［
%要素~幅 ~LT %~box幅
］
◎
If element edge B is outside scrolling box edge B and element height is less than scrolling box height
</dt>
							<dd>
%~box の`終了辺$に，
%要素境界 の`同じ側$の辺を整列する
◎
Align element edge B with scrolling box edge B.
</dd>
						</dl>
					</li>
				</ol>
			</dd>
		</dl>

<p class="en">
◎
• If inline is "start", then align element edge C with scrolling box edge C.
• Otherwise, if inline is "end", then align element edge D with scrolling box edge D.
• Otherwise, if inline is "center", then align the center of element bounding border box with the center of scrolling box in scrolling box’s inline base direction.
• Otherwise, inline is "nearest":
•• If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
••• Do nothing.
•• If element edge C is outside scrolling box edge C and element width is less than scrolling box width
•• If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
••• Align element edge C with scrolling box edge C.
•• If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
•• If element edge D is outside scrolling box edge D and element width is less than scrolling box width
••• Align element edge D with scrolling box edge D.
</p>

	</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の~scroll位置
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as scrolling box’s current scroll position, and scrolling box does not have an ongoing smooth scroll, then return.
</li>
	<li>
%~assoc要素 ~LET %S に応じて
⇒
要素であるならば %S ／
`表示域$であるならば ［
%S に結付けられている`文書$の`根~要素$
］
◎
If scrolling box is associated with an element
• Let associated element be the element.
◎
If scrolling box is associated with a viewport
• Let document be the viewport’s associated Document. Let associated element be document’s root element, if there is one, or null otherwise.
</li>
	<li>
`~scrollを遂行する$( %~box, %目的位置, %~assoc要素, %挙動 )
◎
Perform a scroll of scrolling box to position, associated element as the associated element and behavior as the scroll behavior.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素を~scrollする@
ときは、所与の
( %要素, %目的位置, %挙動 （省略時は `auto$l ） )
に対し，次を走らす：
◎
To scroll an element element to x,y optionally with a scroll behavior behavior (which is "auto" if omitted) means to:
</p>

<ol>
	<li>
%~box ~LET %要素 の`~scrollされる~box$
◎
Let box be element’s associated scrolling box.
</li>
	<li>
( %x, %y ) ~SET 目的位置の ( x, y ) ~~成分
◎
↓</li>
	<li>
%符号 ~LET %~box の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
◎
↓</li>
	<li>
%x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %x, %要素 の`~scrollされる区画$の横幅 ~MINUS %要素 の`~padding辺$の横幅 ) )
◎
If box has rightward overflow direction
• Let x be max(0, min(x, element scrolling area width - element padding edge width)).
◎
If box has leftward overflow direction
• Let x be min(0, max(x, element padding edge width - element scrolling area width)).
</li>
			<li>
%符号 ~LET %~box の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
◎
↓</li>
	<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, %要素 の`~scrollされる区画$の縦幅 ~MINUS %要素 の`~padding辺$の縦幅 ) )
◎
If box has downward overflow direction
• Let y be max(0, min(y, element scrolling area height - element padding edge height)).
◎
If box has upward overflow direction
• Let y be min(0, max(y, element padding edge height - element scrolling area height)).
</li>
	<li>
%目的位置 ~LET
`~scrollされる区画$の座標 ( %x, %y ) は
%~box の左上隅に整列されるような， %~box の~scroll位置
◎
Let position be the scroll position box would have by aligning scrolling area x-coordinate x with the left of box and aligning scrolling area y-coordinate y with the top of box.
</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の~scroll位置
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as box’s current scroll position, and box does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`~scrollを遂行する$( %~box, %目的位置, %要素, %挙動 )
◎
Perform a scroll of box to position, element as the associated element and behavior as the scroll behavior.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="extensions-to-the-htmlelement-interface">
<h2 title="Extensions to the HTMLElement Interface">7. `HTMLElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLElement$I {`HTMLElement^I0
  readonly attribute `Element$I? `offsetParent$m;
  readonly attribute `long$ `offsetTop$m;
  readonly attribute `long$ `offsetLeft$m;
  readonly attribute `long$ `offsetWidth$m;
  readonly attribute `long$ `offsetHeight$m;
};
</pre>

`HTMLElement^dgm

<div class="algo">
<p>
`offsetParent@m
取得子~手続きは：
◎
The offsetParent attribute must return the result of running these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレは次のいずれかを満たす
］…：
◎
If any of the following holds true return null and terminate this algorithm:
</p>
		<ul>
			<li>
`~CSS~layout~box$を持たない
◎
The element does not have an associated CSS layout box.
</li>
			<li>
`根~要素$である
◎
The element is the root element.
</li>
			<li>
`~HTML~body要素$である
◎
The element is the HTML body element.
</li>
			<li>
`position$p ~propの算出d値 ~EQ `fixed^v
◎
The element’s computed value of the position property is fixed.
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
↑</p>

	</li>
	<li>
%先祖 ~LET コレ
◎
↓</li>
	<li>
<p>
~WHILE［
`平坦~tree$における %先祖 の親~要素 %親 はある
］：
◎
Let ancestor be the parent of the element in the flat tree and repeat these substeps:
</p>
		<ol>
			<li>
%先祖 ~SET %親
◎
↑</li>
			<li>
<p>
~IF［
%先祖 は コレからは`閉な~shadowで非可視$である
］
⇒
~IF［
%先祖 の `position$p ~propの算出d値 ~EQ `fixed^v
］
⇒
~RET ~NULL
◎
If ancestor is closed-shadow-hidden from the element and its computed value of the position property is fixed, terminate this algorithm and return null.
</li>
			<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
If ancestor is not closed-shadow-hidden from the element and satisfies at least one of the following, terminate this algorithm and return ancestor.
</p>
				<ul>
					<li>
コレは［
`絶対~位置決め包含塊$／`固定d位置決め包含塊$
］を確立する
◎
The element is a containing block of absolutely-positioned descendants (regardless of whether there are any absolutely-positioned descendants).
</li>
					<li>
%先祖 は `~HTML~body要素$である
◎
It is the HTML body element.
</li>
					<li>
［
コレの `position$p ~propの算出d値 ~EQ `static^v
］~AND［
%先祖 は［
`td^e, `th^e, `table^e
］いずれかの `~HTML要素$ である
］
◎
The computed value of the position property of the element is static and the ancestor is one of the following HTML elements: td, th, or table.
</li>
				</ul>
<p>
…ならば
⇒
~RET %先祖
◎
If there is no more parent of ancestor in the flat tree, terminate this algorithm and return null.
◎
Let ancestor be the parent of ancestor in the flat tree.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
［
`offsetTop@m ｜ `offsetLeft@m
］取得子~手続きは：
◎
The offsetTop attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレは `~HTML~body要素$である
］~OR［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element is the HTML body element or does not have any associated CSS layout box return zero and terminate this algorithm.
</li>
	<li>
以下においては
⇒＃
どの座標も`初期~包含塊$の原点に相対的とする ／
コレとその先祖に対する`変形$は適用しないとする
◎
↓</li>
	<li>
%~border座標 ~LET コレの最初の`~CSS~layout~box$の`~border辺$の［
上端の y 座標 ｜ 左端の x 座標
］
◎
If the offsetParent of the element is null return the y-coordinate of the top border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
</li>
	<li>
~IF［
コレの `offsetParent$m ~NEQ ~NULL
］
⇒
%~border座標 ~DECBY ( コレの `offsetParent$m の最初の`~CSS~layout~box$の`~padding辺$の［
上端の y 座標 ｜ 左端の x 座標
］ )
◎
Return the result of subtracting the y-coordinate of the top padding edge of the first CSS layout box associated with the offsetParent of the element from the y-coordinate of the top border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</li>
	<li>
~RET %~border座標
◎
↑</li>
</ol>
<p class="note">注記：
複数の行l~boxからなる`行内$要素については、
その最初の`~CSS~layout~box$のみが考慮されることになる。
◎
Note: An inline element that consists of multiple line boxes will only have its first CSS layout box considered.
</p>
</div>

<p class="en">
◎
The offsetLeft attribute must return the result of running these steps:
• If the element is the HTML body element or does not have any associated CSS layout box return zero and terminate this algorithm.
• If the offsetParent of the element is null return the x-coordinate of the left border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
• Return the result of subtracting the x-coordinate of the left padding edge of the first CSS layout box associated with the offsetParent of the element from the x-coordinate of the left border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
<p>
［
`offsetWidth@m ｜ `offsetHeight@m
］取得子~手続きは：
◎
The offsetWidth attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
◎
If the element does not have any associated CSS layout box return zero and terminate this algorithm.
</li>
	<li>
<p>
~RET ［
コレの`首要~box$により生成される各`~box断片$の`~border~box$
］すべてを囲う，［
各辺が軸に整列された限界~box
］の［
横幅 ｜ 縦幅
］
— ここで：
◎
Return the width of the axis-aligned bounding box of the border boxes of all fragments generated by the element’s principal box,＼
</p>
		<ul>
			<li>
コレとその先祖に対する`変形$は適用しないとする。
◎
ignoring any transforms that apply to the element and its ancestors.
</li>
			<li>
要素の`首要~box$が`行内~levelの~box$であって，
ある`塊~level$の子孫により “分割され” ている場合、
そのような子孫により生成される断片のうち［
横幅, 縦幅どちらも 0 でないもの
］も含めるとする。
◎
If the element’s principal box is an inline-level box which was "split" by a block-level descendant, also include fragments generated by the block-level descendants, unless they are zero width or height.
</li>
		</ul>
	</li>
</ol>
</div>

<p class="en">
◎
The offsetHeight attribute must return the result of running these steps:
• If the element does not have any associated CSS layout box return zero and terminate this algorithm.
• Return the height of the axis-aligned bounding box of the border boxes of all fragments generated by the element’s principal box, ignoring any transforms that apply to the element and its ancestors.
• If the element’s principal box is an inline-level box which was "split" by a block-level descendant, also include fragments generated by the block-level descendants, unless they are zero width or height.
</p>

	</section>
	<section id="excensions-to-the-htmlimageelement-interface">
<h2 title="Extensions to the HTMLImageElement Interface">8. `HTMLImageElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLImageElement$I {`HTMLImageElement^I0
  readonly attribute `long$ `x$m;
  readonly attribute `long$ `y$m;
};
</pre>

<div class="algo">
<p>
［
`x@m ｜ `y@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレは `~CSS~layout~box$を持たない
］
⇒
~RET 0
</li>
	<li>
~RET `初期~包含塊$の原点に相対的な［
コレの最初の `~CSS~layout~box$の`~border辺$
］の［
左端の x 座標 ｜ 上端の y 座標
］］
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</li>
</ol>
◎
The x attribute, on getting, must return the x-coordinate of the left border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no CSS layout box.
◎
The y attribute, on getting, must return the y-coordinate of the top border edge of the first CSS layout box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no CSS layout box. 
</div>

	</section>
	<section id="extensions-to-the-range-interface">
<h2 title="Extensions to the Range Interface">9. `Range^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Range$I {`Range^I0
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();
};
</pre>

`Range^dgm

<div class="algo">
<p>
`getClientRects()@m
~method手続きは：
◎
The getClientRects() method, when invoked, must＼
</p>
<ol>
	<li>
~IF［
コレは文書~内を指していない
］
⇒
~RET 空な `DOMRectList$I ~obj
◎
return an empty DOMRectList object if the range is not in the document and＼
</li>
	<li>
<p>
~RET ［
次の拘束に合致するような `DOMRect$I ~obj
］からなる，内容~順の~listを包含する `DOMRectList$I ~obj：
◎
otherwise a DOMRectList object containing a list of DOMRect objects in content order that matches the following constraints:
</p>
		<ul>
			<li>
コレに`包含され$ている各 %要素 に対する
⇒
［
%要素 の `Element^I1 `getClientRects$m1 ~method手続き()
］の結果に含まれる`~border区画$たち
◎
For each element selected by the range, whose parent is not selected by the range, include the border areas returned by invoking getClientRects() on the element.
</li>
			<li>
<p>
コレに［
`部分的に包含され$ているか`包含され$ている†
］各 `Text$I ~node
（`始端$と`終端$が同じになるものも含まれる）に対する
⇒
（行l~box全体ではなく）選択された部分のみを囲む `DOMRect$I ~obj
◎
For each Text node selected or partially selected by the range (including when the boundary-points are identical), include a DOMRect object (for the part that is selected, not the whole line box).＼
</p>

<p class="trans-note">【†
`包含され$ている要素~内の `Text^I ~nodeも除外されないことになる。
】</p>

<p>
これらの `DOMRect$I ~objの限界域は、
~font計量を利用して算出される。
したがって，横書きの下では、
各~boxの
縦方向の寸法は~fontの~ascentと~descentから決定され,
横方向の寸法は~textの送り幅から決定される。
コレの`中身$が `~typographic文字~単位$ `CSS-TEXT-3$r を部分的に含む場合
（例： 代用対の片割れや書記素~clusterの一部分）、
限界域を算出する目的においては，その`~typographic文字~単位$を全部的に含めるモノトスル。
要素の先祖に対する`変形$は、
適用される。
◎
The bounds of these DOMRect objects are computed using font metrics; thus, for horizontal writing, the vertical dimension of each box is determined by the font ascent and descent, and the horizontal dimension by the text advance width. If the range covers a partial typographic character unit (e.g. half a surrogate pair or part of a grapheme cluster), the full typographic character unit must be included for the purpose of computing the bounds of the relevant DOMRect. [CSS-TEXT-3] The transforms that apply to the ancestors are applied.
</p>

<p class="trans-note">【
“送り幅（ `advance^en ）”
— 対象~textが描画される起点から，後続の~textが同じ行lに描画されるとするときの，その起点までの長さ
】</p>
			</li>
		</ul>
	</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</p>
</div>

<div class="algo">
<p>
`getBoundingClientRect@m
~method手続きは：
◎
The getBoundingClientRect() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
%~list ~LET コレの `getClientRects$m ~method手続き()
◎
Let list be the result of invoking getClientRects() on the same range this method was invoked on.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET 次のようにされた新たな `DOMRect$I ~obj
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
	<li>
~IF［
%~list 内の矩形は，どれも［
横幅, 縦幅
］どちらかは 0
］
⇒
~RET %~list 内の最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
	<li>
~RET 次を表現する新たな `DOMRect$I ~obj
⇒
%~list 内の［［
横幅, 縦幅
］どちらかは【どちらも？】 0 でない矩形
］すべてを包含する最~小な矩形
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</p>
</div>

	</section>
	<section id="extensions-to-the-mouseevent-interface">
<h2 title="Extensions to the MouseEvent Interface">10. `MouseEvent^I ~interfaceに対する拡張</h2>

<p class="issue">
この~IDL片は、
一部の~memberを定義し直している。
これをどうにか解決できないか？
◎
The object IDL fragment redefines some members. Can we resolve this somehow?
</p>

<pre class="idl">
partial interface `MouseEvent$I {`MouseEvent^I0
  readonly attribute `double$ `screenX$m;
  readonly attribute `double$ `screenY$m;
  readonly attribute `double$ `pageX$m;
  readonly attribute `double$ `pageY$m;
  readonly attribute `double$ `clientX$m;
  readonly attribute `double$ `clientY$m;
  readonly attribute `double$ `x$m;
  readonly attribute `double$ `y$m;
  readonly attribute `double$ `offsetX$m;
  readonly attribute `double$ `offsetY$m;
};

partial dictionary `MouseEventInit$I {`MouseEventInit^I0
  `double$ `screenX@m = 0.0;
  `double$ `screenY@m = 0.0;
  `double$ `clientX@m = 0.0;
  `double$ `clientY@m = 0.0;
};
</pre>

`MouseEvent^dgm

`MouseEvent^I0

<div class="algo">
［
`screenX@m ｜ `screenY@m
］取得子~手続きは
⇒
~RET `~Webに公開される~screen区画$の原点に相対的な，コレが生じた地点の［
x 座標 ｜ y 座標
］
◎
The screenX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
◎
The screenY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
</div>

<div class="algo">
<p>
［
`pageX@m ｜ `pageY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
`初期~包含塊$の原点に相対的な，コレが生じた地点の［
横方向 ｜ 縦方向
］の座標
</li>
	<li>
%offset ~LET 0
</li>
	<li>
~IF［
コレに結付けられている `Window$I ~obj %window 【！＊】は在る
］
⇒
%offset ~SET %window の［
`scrollX$m1 ｜ `scrollY$m1
］取得子~手続き()
</li>
	<li>
%offset ~INCBY コレの［
`clientX$m ｜ `clientY$m
］取得子~手続き()
</li>
	<li>
~RET %offset
</li>
</ol>
◎
The pageX attribute must follow these steps:
• If the event’s dispatch flag is set, return the horizontal coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollX attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientX attribute. 
◎
The pageY attribute must follow these steps:
• If the event’s dispatch flag is set, return the vertical coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollY attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientY attribute. 
</div>

<div class="algo">
［
`clientX@m ｜ `clientY@m
］取得子~手続きは
⇒
~RET `表示域$の原点に相対的な，コレが生じた地点の［
x 座標 ｜ y 座標
］
◎
The clientX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the viewport.
◎
The clientY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the viewport.
</div>

<div class="algo">
［
`x@m ｜ `y@m
］取得子~手続きは、［
`clientX$m ｜ `clientY$m
］取得子~手続きと同じに挙動する。
◎
The x attribute must return the value of clientX.
◎
The y attribute must return the value of clientY.
</div>

<div class="algo">
<p>
［
`offsetX@m ｜ `offsetY@m
］取得子~手続きは：
◎
The offsetX attribute must follow these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET 
要素とその先祖に対する`変形$は適用しない下で，
target ~nodeの`~padding辺$の原点に相対的な，コレが生じた地点の［
x 座標 ｜ y 座標
］
◎
If the event’s dispatch flag is set, return the x-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
</p>

<p class="trans-note">【
target ~node：
コレの配送-先の~node（より明確には，~event伝播の中で `AT_TARGET$m に該当する~node）。
】</p>
	</li>
	<li>
~RET コレの［
`pageX$m ｜ `pageY$m
］取得子~手続き()
◎
Return the value of the event’s pageX attribute. 
</li>
</ol>
</div>

<p class="en">
◎
The offsetY attribute must follow these steps:
• If the event’s dispatch flag is set, return the y-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
• Return the value of the event’s pageY attribute. 
</p>

	</section>
	<section id="geometry">
<h2 title="Geometry">11. 幾何</h2>

		<section id="the-geometryutils-interface">
<h3 title="The GeometryUtils Interface" class="atrisk">11.1. `GeometryUtils^I ~interface</h3>

<pre class="idl">
enum `CSSBoxType@I { `margin@l, `border@l, `padding@l, `content@l };
dictionary `BoxQuadOptions@I {
  `CSSBoxType$I `box@mb = `border$l;
  `GeometryNode$I `relativeTo@mb; // XXX default document (i.e. viewport)
};

dictionary `ConvertCoordinateOptions@I {
  `CSSBoxType$I `fromBox@mb = `border$l;
  `CSSBoxType$I `toBox@mb = `border$l;
};

interface mixin `GeometryUtils@I {
  `sequence$&lt;`DOMQuad$I&gt; `getBoxQuads$m(
      optional `BoxQuadOptions$I %options = {}
  );
  `DOMQuad$I `convertQuadFromNode$m(
      `DOMQuadInit$I %quad,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMQuad$I `convertRectFromNode$m(
      `DOMRectReadOnly$I %rect,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMPoint$I `convertPointFromNode$m(
      `DOMPointInit$I %point,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  ); // XXX z,w turns into 0
};
 
`Text$I includes `GeometryUtils$I; // like Range
`Element$I includes `GeometryUtils$I;
`CSSPseudoElement$I includes `GeometryUtils$I;
`Document$I includes `GeometryUtils$I;

typedef (`Text$I or `Element$I or `CSSPseudoElement$I or `Document$I) `GeometryNode@I;
</pre>

<div class="algo">
<p>
`getBoxQuads(options)@m
~method手続きは：
◎
The getBoxQuads(options) method must run the following steps:
</p>
<ol>
	<li class="issue" lang="en">
DOM order
<p>p1 = top left even in RTL
<p>scale to 0 means divide by zero, return 0x0
<p>cross-frames not allowed, throw WrongDocumentError?
<p>points are flattened (3d transform), z=0. like getClientRect
<p>test block in inline
<p>pseudo-elements before/after are children of the element
<p>viewport boxes are all the same
</li>
</ol>
</div>

<div class="algo">
`convertQuadFromNode(quad, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertQuadFromNode(quad, from, options) method must run the following steps:
</div>

<div class="algo">
`convertRectFromNode(rect, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertRectFromNode(rect, from, options) method must run the following steps:
</div>

<div class="algo">
`convertPointFromNode(point, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertPointFromNode(point, from, options) method must run the following steps:
</div>

		</section>
	</section>

	<section id="events">
<h2 title="Events">12. ~event</h2>

		<section id="resizing-viewports">
<h3 title="Resizing viewports">12.1. 表示域の~size変更</h3>

<p>
この節は、
`HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<div class="algo">
<p>
`文書の~resize手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to run the resize steps for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
この手続きを最後に走らせたときから
`表示域$の横幅または縦幅は変化した†
］
⇒
`~eventを発火する$( %文書 に結付けられている `Window$I ~obj, `resize$et )
</p>

<p>†
例えば：
</p>
		<ul>
			<li>
利用者が~browserの~UIwindowを［
~resize／拡大
］したとき
</li>
			<li>
`~page~zoom$倍率が変化したとき
</li>
			<li>
`iframe^e 要素の寸法が変化したとき
</li>
		</ul>
◎
If doc’s viewport has had its width or height changed (e.g. as a result of the user resizing the browser window, or changing the page zoom scale factor, or an iframe element’s dimensions are changed) since the last time these steps were run, fire an event named resize at the Window object associated with doc. 
</li>
</ol>
</div>

		</section>
		<section id="scrolling-events">
<h3 title="Scrolling">12.2. ~scroll法</h3>

<p>
この節は、
`HTML$r に定義される`~event~loop$【`描画を更新する段$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
各 `文書$には、
`~scroll処理待ち~list@
— 処理待ちにある~scroll~event~targetたちが成す~list —
が結付けられる（初期~時は空）。
◎
Each Document has an associated list of pending scroll event targets, initially empty.
</p>

<div class="algo">
<p>
~UAは、
`表示域$が~scrollされる度に
（利用者とのヤリトリ, ~APIのどちらによるかを問わず），
次を走らすモノトスル：
◎
Whenever a viewport gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
</p>

<ol>
	<li>
%文書 ~LET `表示域$に結付けられている`文書$
◎
Let doc be the viewport’s associated Document.
</li>
	<li>
~IF［
%文書 ~IN %文書 の`~scroll処理待ち~list$
］
⇒
~RET
◎
If doc is already in doc’s pending scroll event targets, abort these steps.
</li>
	<li>
%文書 の`~scroll処理待ち~list$に %文書 を付加する
◎
Append doc to doc’s pending scroll event targets.
</li>
</ol>
</div>

<div class="algo">
<p>
~UAは、
要素が~scrollされる度に
（利用者とのヤリトリ, ~APIのどちらによるかを問わず），
次を走らすモノトスル：
◎
Whenever an element gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
</p>

<ol>
	<li>
%文書 ~LET 要素の`~node文書$
◎
Let doc be the element’s node document.
</li>
	<li>
~IF［
要素 ~IN %文書 の`~scroll処理待ち~list$
］
⇒
~RET
◎
If the element is already in doc’s pending scroll event targets, abort these steps.
</li>
	<li>
%文書 の`~scroll処理待ち~list$に要素を付加する
◎
Append the element to doc’s pending scroll event targets.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書の~scroll手続き@
は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
When asked to run the scroll steps for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
%文書 の`~scroll処理待ち~list$内の
~EACH( %~target )
に対し：
◎
For each item target in doc’s pending scroll event targets, in the order they were added to the list, run these substeps:
</p>
		<ol>
			<li>
~IF［
%~target は`文書$である
］
⇒
`~eventを発火する$( %~target, `scroll$et )
— 次のように初期化して
⇒
`bubbles^m ~SET ~T
◎
If target is a Document, fire an event named scroll that bubbles at target.
</li>
			<li>
~ELSE
⇒
`~eventを発火する$( %~target, `scroll$et )
◎
Otherwise, fire an event named scroll at target.
</li>
		</ol>
	</li>
	<li>
%文書 の`~scroll処理待ち~list$を空にする
◎
Empty doc’s pending scroll event targets.
</li>
</ol>
</div>

		</section>
		<section id="event-summary">
<h4 title="Event summary">12.3. ~event要覧</h4>

~INFORMATIVE

<table class="_event-table">
<thead><tr><th>~event
<th>~interface
<th>~target
<th>~~説明
</thead>

<tbody>
<tr><td>`resize@et
<td>`Event$I
<td>`Window$I
<td>
`表示域$が~resizeされたときに `Window$I に向けて発火される。
◎
Fired at the Window when the viewport is resized.

<tr><td>`scroll@et
<td>`Event$I
<td>`文書$, 要素
<td>
［
`表示域$ ／ 要素
］が~scrollされたときに［
`文書$ ／ 要素
］に向けて発火される。
◎
Fired at the Document or element when the viewport or element is scrolled, respectively. 

</tbody></table>

		</section>
	</section>
	<section id="priv-sec">
<h2 title="Security and Privacy Considerations">~securityと~privacyの考慮点</h2>

<p>
`Screen$I ~interfaceは、
利用者の~display環境設定についての情報を公開する
— それは、
指紋収集~algoの入力として利用され得る。
利用者の~privacyを保護するためとして、
~UAは，~screen~sizeや環境設定についての情報を［
隠す／量子化する
］ことを選んでもヨイ。
◎
The Screen interface exposes information about the user’s display configuration, which maybe be used as input to fingerprinting algorithms. User agents may choose to hide or quantize information about the screen size or configuration, in order to protect the user’s privacy.
</p>

<p>
`MouseEvent$I ~eventは、
~screenに相対的な座標についての情報を包含する。
利用者の~privacyを保護するためとして、
~UAは，~eventの そのような~propを［
実際の~screenに相対的な所在
］を隠蔽するような値に設定してもヨイ。
◎
MouseEvent contains information about the screen-relative coordinates of the event. User agents may set these properties to values that obscure the actual screen-relative location of the event, in order to protect the user’s privacy.
</p>
	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
この節では、
この仕様の各~公表版の間の変更点の一部を文書化する。
この節は、
網羅的ではない。
~bug修正点や編集上の変更点は、
一般に，挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

<dl>
	<dt id="changes-from-2020-10-19">
2020年 10月 19日からの変更点
◎
Changes From 19 October 2020
</dt>
	<dd>
<a href="#priv-sec">§ ~securityと~privacyの考慮点</a>
を追加した。
◎
Added the "Security and Privacy Considerations" section
</dd>
	<dd>
<a href="#terminology">§ 各種用語</a>
内の論理的な誤りを修正した。
◎
Fixed a logical error in the Terminology section.
</dd>
	<dd>
`scroll-behavior$p ~propを `CSS-OVERFLOW-3$r へ移動した。
◎
Moved the scroll-behavior property to [CSS-OVERFLOW-3]
</dd>

	<dt id="changes-from-2020-01-31">
2020年 1月 31日 からの変更点
◎
Changes From 31 January 2020
</dt>

	<dd>
編集者に `Simon Fraser^en を追加した。
◎
Added Simon Fraser as editor
</dd>
	<dd>
`Window$I の `resizeTo()$m1 の引数を %width, %height に改称した。
（<a href="~CSSissue/4727">課題 #4727</a>）
◎
Renamed the arguments to resizeTo() to be width and height (4727)
</dd>

	<dt id="changes-from-2013-12-17">
2013年 12月 17日 から 2020年 1月 31日 までの変更点
◎
Changes From 17 December 2013 To 31 January 2020
</dt>
	<dd>
`Element$I 上の
`scrollIntoView()$m1 ~methodを変更して拡張した。
◎
The scrollIntoView() method on Element was changed and extended.
</dd>
	<dd>
`Element$I の［
`scrollTop$m1, `scrollLeft$m1
］~IDL属性は、
~objをとらないようにした
— 代わりに［
`scroll()$m1, `scrollTo()$m1, `scrollBy()$m1
］~methodを追加した。
◎
The scrollTop and scrollLeft IDL attributes on Element changed to no longer take an object; the scroll(), scrollTo() and scrollBy() methods were added instead.
</dd>
	<dd>
`Element$I の［
`scrollWidth$m1,
`scrollHeight$m1,
`clientTop$m1,
`clientLeft$m1,
`clientWidth$m1 
`clientHeight$m1
］~IDL属性は、
整数を返す~~元のふるまいに戻した。
◎
The scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth and clientHeight IDL attributes on Element were changed back to return integers.
</dd>
	<dd>
`DOMRectList^I ~interfaceを除去した。
◎
The DOMRectList interface was removed.
</dd>
	<dd>
`Document$I に `scrollingElement$m1 ~IDL属性を追加した。
◎
The scrollingElement IDL attribute on Document was added.
</dd>
	<dd>
`Window$I 上の一部の読専（ readonly ）属性に、
[Replaceable] ~IDL拡張属性で注釈した。
◎
Some readonly attributes on Window were annotated with [Replaceable] IDL extended attribute.
</dd>
	<dd>
［
`MediaQueryList$I,
`scroll$et ~event,
`resize$et ~event
］を
— ~animation~frameに同期するよう —
~HTMLにおける`~event~loop$に統合した。
◎
MediaQueryList, scroll event and resize event are integrated with the event loop in HTML so they are synchronized with animation frames.
</dd>
	<dd>
`scroll-behavior$p の `instant^v 値を `auto^v に改称した。
◎
The instant value of scroll-behavior was renamed to auto.
</dd>
	<dd>
`Element$I の `scrollLeft$m1 の原点を（右横書き用に）変更した。
◎
The origin of scrollLeft on Element was changed (for RTL).
</dd>
	<dd>
`Element$I の `scrollIntoView()$m1 ~method, および
`Window$I の［
`scroll()$m1, `scrollTo()$m1, `scrollBy()$m1
］~methodは、
最初の引数に関連な辞書~型~値をとるようにした。
◎
The scrollIntoView() method on Element and scroll(), scrollTo() and scrollBy() methods on Window take the relevant dictionary as the first argument.
</dd>
	<dd>
`MediaQueryList$I ~interfaceを、
定例の~event~APIを利用し，それを通して `addListener()$m1 を定義するよう変更した。
◎
The MediaQueryList interface was changed to use regular event API and define addListener() in terms of that.
</dd>

	<dt id="changes-from-2011-08-04">
2011年 8月 4日 から 2013年 12月 17日 までの変更点
◎
Changes From 4 August 2011 To 17 December 2013
</dt>
	<dd>
右横書き（`行内~基底~方向$）と縦組みも取扱うようにした。
◎
The specification now handles right-to-left and vertical writing modes.
</dd>
	<dd>
［
`~page~zoom$, `~pinch~zoom$
］を織り込んだ。
◎
The specification is now aware of page zoom and pinch zoom.
</dd>
	<dd>
`scroll-behavior$p ~CSS~propを導入して、
滑らかな~scrollを制御できるよう，~scroll用~APIを拡張した。
◎
The scroll-behavior CSS property is introduced and scrolling APIs are extended with a mechanism to control smooth scrolling.
</dd>
	<dd>
`Window$I の［
`moveTo()$m1,
`moveBy()$m1,
`resizeTo()$m1,
`resizeBy()$m1
］~methodを定義した。
◎
The moveTo(), moveBy(), resizeTo() and resizeBy() methods are now defined.
</dd>
	<dd>
`Window$I の `innerWidth$m1, 等々は、
~Web~IDL型 `long^c ではなく， `double^c を利用するようにした。
◎
innerWidth et al now use the WebIDL type double instead of long.
</dd>
	<dd>
`Window$I の `devicePixelRatio$m1 を定義した。
◎
devicePixelRatio is now defined.
</dd>
	<dd>
`window.open()^m
に対する %features 引数を定義した。
◎
The features argument to window.open() is now defined.
</dd>
	<dd>
`Screen$I の［
`colorDepth$m1, `pixelDepth$m1
］属性は、
24 を返すようにした。
◎
The colorDepth and pixelDepth attributes of Screen now always return 24.
</dd>
	<dd>
`Document$I 【！`Element^I】 に
`elementsFromPoint()$m1
~methodを導入した。
◎
The elementsFromPoint() method of Element is introduced.
</dd>
	<dd>
`変形$を織り込んだ。
◎
The specification is now aware of transforms.
</dd>
	<dd>
幾何~utility~APIをいくつか導入した
— が、
まだ仕様化していない。
◎
Some geometry utility APIs are introduced but are not yet specified.
</dd>
	<dd>
`ClientRect^I を `DOMRect^I に改称して、
`GEOMETRY-1$r 仕様に移動した。
◎
ClientRect has been renamed to DOMRect and has moved to the Geometry specification. [GEOMETRY-1]
</dd>
	<dd>
［
`resize$et, `scroll$et
］~eventの発火-時機について定義した。
◎
The specification now defines when the resize and scroll events fire. 
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この文書に貢献された次の方々に感謝する：
</p>

<p lang="en">
The editors would like to thank

Alan Stearns,
Alexey Feldgendler,
Antonio Gomes,
Björn Höhrmann,
Boris Zbarsky,
Chris Rebert,
Corey Farwell,
Dan Bates,
David Vest,
Elliott Sprehn,
Garrett Smith,
Henrik Andersson,
Hallvord R. M. Steen,
Kang-Hao Lu,
Koji Ishii,
Leif Arne Storset,
Luiz Agostini,
Maciej Stachowiak,
Michael Dyck,
Mike Wilson,
Morten Stenshorne,
Olli Pettay,
Pavel Curtis,
Peter-Paul Koch,
Rachel Kmetz,
Rick Byers,
Robert O’Callahan,
Sam Weinig,
Scott Johnson,
Sebastian Zartner,
Stewart Brodie,
Sylvain Galineau,
Tab Atkins,
Tarquin Wilton-Jones,
Thomas Moore,
Thomas Shinnick,
and
Xiaomei Ji

for their contributions to this document.
</p>

<p>
この草案にて指定された特能の多くを，Windows Internet Explorer ~browserにて最初に実装した Microsoft の人達に特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented many of the features specified in this draft, which were first widely deployed by the Windows Internet Explorer browser.
</p>

	</section>
</main></div>

<div id="_info-view">（クリックで消去）<pre id="_info-box"></pre></div>
