<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSSOM View Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<style>

#_info-view {
	position: fixed;
	z-index:10;
	display: none;
	padding: 0;
	bottom: 0;
	right: 0;
	min-width:20em;
	background: var(--sample-bg-color-1);
	outline: ridge var(--pale-color) 4px;
}

#_info-view.show {
	display: block;
}

.en::before {
	content: "↑";
	color: var(--dim-color);
}

.element::before,
.element::after {
	content: none;
}


@supports (grid-template-columns: subgrid) and (display: contents) {

#_event-table {
	min-width: 24em;
	max-width: 48em;
	grid-template-columns: 4em 10em 1fr;
	tr {
		grid-template-areas:
			"event event event"
			". interface 標的"
			". 説明 説明"
		;
		> *:nth-child(1) {
			grid-area: event;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: interface;
		}
		> *:nth-child(3) {
			grid-area: 標的;
		}
		> *:nth-child(4) {
			grid-area: 説明;
			padding: 0.5em;
		}
	}
}
}

</style>

<style>
@keyframes lvmove {
	0%, 10%, 20% { top: 25%; }
	30%, 50%, 70% { top: 37.5%; }
	80%,100% { top: 25%; }
}
@keyframes vvmove {
	0%, 10% { top: 37.5%; }
	30%, 50% { top: 62.5%; }
	80%, 90% { top: 25%; }
	100% { top: 37.5%; }
}

#_vvanimation {
	border: solid thin var(--N-color);
	position: relative;
	background: var(--W-color);
	width: 20em;
	height: 28em;

	> div {
		box-sizing: border-box;
		border: solid;
		position: absolute;
		&._lv {
			color: var(--B-color);
			width: 100%;
			height: 50%;
			left: 0;
			top: 25%;
			animation: lvmove linear 3s infinite;
		}
		&._vv {
			color: var(--R-color);
			width: 50%;
			height: 25%;
			left: 25%;
			top: 37.5%;
			animation: vvmove linear 3s infinite;
		}
	}
	&._paused > div {
		animation-play-state: paused;
	}
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		populate: () => {
			const e = E('_vvanimation');
			e.onclick = () => {
				e.classList.toggle('_paused');
			};
		},
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let ctx_ifc = '';
	let ctx_ifc1 = ''; // interface for 'm1'

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if(indicator === '@'){
		ctx_ifc = key;
	} else {
		ctx_ifc1 = key;
	}
	href = `#${key.toLowerCase()}`;
	break;
case 'I0':
	ctx_ifc = key;
	return '';
	break;
case 'I1':
	ctx_ifc1 = key;
	return '';
	break;
case 'mc':
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`;
	text = 'constructor';
	break;
case 'm1':
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
		const ifc = ( klass === 'm1' ) ? ctx_ifc1: ctx_ifc
		href = `#dom-${ifc}-${key}`.toLowerCase();
	}
	break;
case 'opf':
case 'l':
	text = `"<code class="literal">${text}</code>"`
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}

</script>


<!--%testing demos -->
<script>

Util.DEFERRED.push(init2);

function init2(){
	repeat('input[data-params]', (e) => {
		const event = e.getAttribute('data-event') || 'click';
		e.addEventListener(event, display_attrs, false);
	});

	const DATA = {
		Window:{
			event_type: ['scroll', 'resize'],
			obj(){return window;},
			attrs: 'screen innerWidth innerHeight scrollX pageXOffset scrollY pageYOffset screenX screenY outerWidth outerHeight devicePixelRatio'
		},

		MediaQueryList:{
			obj(){
  const v = E('_test-mql_text').value.replace(/\'/g, '\"');
  this.src = 'window.matchMedia(\'' + v + '\')';
  return window.matchMedia(v);
},
			attrs: 'media matches'
		},

		Screen:{
			obj(){ return window.screen; },
			attrs: 'availWidth availHeight width height colorDepth pixelDepth'
		},

		'Element.scrollIntoView':{
			obj(){
				const top = E('_test-scrollIntoView-top').checked;
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= var tag_name= ..., top = ... ;
  var e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView(top);//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView(${top})
（クリックで元の位置へ復帰）`
				);
}
		},

		'Element.scrollIntoView0':{
			obj(){
				const tag_name = E('_test-scrollIntoView-tagName').value;
				const behavior = E('_test-scrollIntoView-behavior').value;
				const block = E('_test-scrollIntoView-block').value;
				const inline = E('_test-scrollIntoView-inline').value;
				const pos = {x: window.scrollX, y: window.scrollY};
  //= const tag_name= ... , behavior = ... , block = ... ;
  let e = document.getElementsByTagName(tag_name);
  e = e.item(Math.floor(Math.random() * e.length));
  e.scrollIntoView({
    behavior: behavior,
    block: block,
    inline: inline
  });//=

				select(e);
				revert_pos = pos;
				return (
`element.scrollIntoView( { behavior: "${behavior}", block: "${block}" } )
（クリックで元の位置へ復帰）`
				);
}
		},

		'Window.scroll':{
			obj(){
				let x, y, e;
				e = E('_test-scroll-x');
				e.value = x = parseInt(e.value);
				e = E('_test-scroll-y');
				e.value = y = parseInt(e.value);
				
				const pos = {x: window.scrollX, y: window.scrollY};
				let method_name = '';
				repeat('input[name="_test-scroll-fn"]', (e) => {
					if(e.checked){
						method_name = e.id.slice('_test-scroll-'.length);
					}
				})
				if(!method_name) return;
//=
	window[method_name](x, y);//=

					revert_pos = pos;
					return(
`${method_name}(${x},${y})
（クリックで元の位置へ復帰）`
					);
			}
		},

		Element:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight'
		},

		HTMLElement:{
			event_type: 'mouseover',
			obj(event){return event.target;},
			attrs: 'scrollParent offsetParent offsetTop offsetLeft offsetWidth offsetHeight'
		},

		'Selection.getBoundingClientRect':{
			event_type: ['mousemove', 'keyup'],

// https://developer.mozilla.org/en-US/docs/DOM/Selection
// chrome はテキスト未選択時に getRangeAt がエラーを投出
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getBoundingClientRect();//=
			},
			attrs: 'x y width height top right bottom left'
		},

		'Selection.getClientRects':{
			event_type: ['mousemove', 'keyup'],
			obj(){//=
  const selection = document.getSelection();
  return selection.isCollapsed? {} :
    selection.getRangeAt(0).getClientRects();//=
},
			attrs: 'length'
		},

		MouseEvent:{
			event_type: 'mousemove',
			obj(event){return event;},
			attrs: 'screenX screenY pageX pageY clientX clientY x y offsetX offsetY'
		},

		ClientRect:{
			event_type: 'mouseover',
			obj(event){return event.target.getBoundingClientRect();},
			attrs: 'x y width height top right bottom left'
		},

		getClientRects:{
			event_type: 'mouseover',
			obj(event){return event.target.getClientRects();},
			attrs: 'length'
		},

		elementFromPoint:{
			event_type: 'mousemove',
			obj(event){
  select(//=
    document.elementFromPoint(event.clientX, event.clientY)//=
  );
}
		},

		elementsFromPoint:{
			event_type: 'mousemove',
			obj(event){
				return(//=
document
  .elementsFromPoint(event.clientX, event.clientY)
  .map((e) => {return e.tagName;})
  .join(', ')//=
				);
			},
		},

		caretPositionFromPoint:{
			event_type: 'mousemove',
			obj(event){
  return document.caretPositionFromPoint(event.clientX, event.clientY);
},
			attrs: 'offsetNode offset'
		},

		NULL:{}
	};

	let revert_pos = null;
	let interface_name = null;
	let current_elem = null;

//	display_attrs = 
	function display_attrs(event){
		const key = event.currentTarget.getAttribute('data-params');
		interface_name = key;
		revert_pos = null;

		window.addEventListener('click', disable_view, true);
		if(! ('event_type' in DATA[key])) {
			show_attrs();
			interface_name = null;
			return;
		}
		switch(key){
		case 'Window':
		case 'Selection.getBoundingClientRect':
		case 'Selection.getClientRects':
			show_attrs();
		}
		enable_listener(true);
	}

	E('_test-mql_text').onfocus = () => {
		E('_test-mql_text').onfocus = null;
		const mql_options = E('_MQL_options');
		for( const mq of mql_options.firstChild.data.split(';') ){
			const option = C('option');
			option.textContent = mq.trim();
			mql_options.appendChild(option);
		};
	}

return;

//	var select = document.body.classList ? select1 : function(){};
	function select(e){
		hilight(false);
		current_elem = e;
		hilight(true);
		function hilight(h){
			if(!current_elem) return;
			// outline style はどの要素からも利用されていないものと見なす
			current_elem.style.outline = h ? 'solid red 1px' : '';
		}
	}

	function enable_listener(enable){
		let types = interface_name && DATA[interface_name].event_type;
		if(!types) return;
		if(typeof(types) === 'string'){
			types = [types];
		}
		for( const type of types){
			enable?
				window.addEventListener(type, show_attrs, false):
				window.removeEventListener(type, show_attrs, false);
		}
	}

	function disable_view(event){
		E('_info-view').className = '';
		enable_listener(false);
		window.removeEventListener('click', disable_view, true);
		select(null);
		if(revert_pos) {
			if(!event.target.onclick){
				window.scrollTo(revert_pos.x, revert_pos.y);
			}
			revert_pos = null;
		}
	}

	function show_attrs(event){
		let obj;
		const data = DATA[interface_name];
		try {
			obj = data.obj(event);
		} catch(e){
			show_text(
`次の実行に失敗：
  ${source_of(data)}`
			);
			enable_listener(false);
			return;
		}
		if(!obj) return;
		let texts = [];
		if(typeof(obj) === 'string'){
			texts[0] = obj;
		} else if('attrs' in data){
			texts = ['● オブジェクト：', source_of(data), '● 属性：'];
			let attrs = data.attrs;
			if(typeof(attrs) === 'string'){
				attrs = data.attrs = attrs.split(' ');
			}
			for( const name of attrs ){
				texts.push(
`${(name + '                     ').slice(0, 18)}:${obj[name]}`
				)
			};
		}
		if(event && (event.type === 'mouseover')){
			select(event.target);
		}
		show_text(texts.join('\n'));
	}
	
	function show_text(text){
		E('_info-box').textContent = text;
		E('_info-view').className = 'show';
	}

	function source_of(data){
		if('src' in data) return data.src;
		const s = data.obj.toString ?
			data.obj.toString() : '(ソースコードを取得できません。)';
		const m = s.match(/\/\/=([^\0]+)\/\/=|return\s([^;}]+)/);
		return data.src = ((m && (m[1] || m[2])) || s).trim();
	}

}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSSOM View Module Level 1
spec_date:2025-10-24
trans_update:2025-10-12
source_checked:250903
page_state_key:CSS
original_url:https://drafts.csswg.org/cssom-view-1/
	abbr_url:CSSOMVIEW
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2025,permissive
trans_1st_pub:2012-09-22


●●class_map
e:element
a:attr
et:event-type
p:property
d:descriptor
css:css
v:value
jv:js-value
u:unit
op:op

●●tag_map
I:code
m:code
m1:code
mb:code
mc:code
et:code
e:code
a:code
p:code
d:code
css:code
c:code
v:code
jv:code
u:code
i:i
b:b
op:span
cite:cite

●●original_id_map
scrolling-box:

●●mdn_urls

mediaquerylist:API/MediaQueryList
mediaquerylistevent:API/MediaQueryListEvent
screen:API/Screen
caretposition:API/CaretPosition
	geometryutils:API/GeometryUtils
dictdef-scrolltooptions:API/ScrollToOptions
	dictdef-scrolloptions:API/ScrollOptions
	dictdef-mediaquerylisteventinit:API/MediaQueryListEventInit
	dictdef-scrollintoviewoptions:API/ScrollIntoViewOptions
	dictdef-boxquadoptions:API/BoxQuadOptions
	dictdef-convertcoordinateoptions:API/ConvertCoordinateOptions
	enumdef-scrollbehavior:API/ScrollBehavior
	enumdef-scrolllogicalposition:API/ScrollLogicalPosition
	enumdef-cssboxtype:API/CSSBoxType
	typedefdef-geometrynode:API/GeometryNode

eventdef-window-resize:API/Window/resize_event
eventdef-document-scroll:API/Document/scroll_event
eventdef-document-scrollend:API/Document/scrollend_event
eventdef-mediaquerylist-change:API/MediaQueryList/change_event

●●link_map

	●IDL
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject
Replaceable:~WEBIDLjs#Replaceable
Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
double:~WEBIDL#idl-double
unsigned long:~WEBIDL#idl-unsigned-long
unrestricted double:~WEBIDL#idl-unrestricted-double
sequence:~WEBIDL#idl-sequence
CSSOMString:~CSSOM1#cssomstring
Promise:~WEBIDL#idl-promise

I.ScrollBehavior:#enumdef-scrollbehavior
I.ScrollOptions:#dictdef-scrolloptions
I.ScrollToOptions:#dictdef-scrolltooptions
I.MediaQueryList:#mediaquerylist
I.MediaQueryListEvent:#mediaquerylistevent
I.MediaQueryListEventInit:#dictdef-mediaquerylisteventinit

I.ScrollLogicalPosition:#enumdef-scrolllogicalposition
I.ScrollIntoViewOptions:#dictdef-scrollintoviewoptions
I.ScrollIntoViewContainer:#enumdef-scrollintoviewcontainer
I.CheckVisibilityOptions:#dictdef-checkvisibilityoptions
I.CaretPositionFromPointOptions:#dictdef-caretpositionfrompointoptions

I.VisualViewport:#visualviewport
I.Screen:#screen
I.CaretPosition:#caretposition
I.CSSBoxType:#enumdef-cssboxtype
I.BoxQuadOptions:#dictdef-boxquadoptions
I.ConvertCoordinateOptions:#dictdef-convertcoordinateoptions
I.GeometryUtils:#geometryutils
I.GeometryNode:#typedefdef-geometrynode
I.SnapEvent:~CSSSCROLLSNAP2#snapevent

I.Window:~WINDOW#window

I.Document:~DOM4#document
I.Element:~DOM4#element
I.Text:~DOM4#text
I.Node:~DOM4#node
I.ShadowRoot:~DOM4#shadowroot
I.Range:~DOM4#range

I.EventTarget:~DOM4#eventtarget
I.EventListener:~DOM4#callbackdef-eventlistener
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.HTMLElement:~HTMLdom#htmlelement
I.WindowProxy:~HTMLWPROXY#windowproxy
I.HTMLImageElement:~HEimages#htmlimageelement
I.EventHandler:~WAPI#eventhandler

I.MouseEvent:~UIEVENTS#mouseevent
I.MouseEventInit:~UIEVENTS#dictdef-mouseeventinit
	#dictdef-mouseeventinit
I.CSSPseudoElement:~CSSPSEUDO#csspseudoelement

I.DOMPoint:~GEOMETRY#dompoint
I.DOMPointInit:~GEOMETRY#dictdef-dompointinit
I.DOMRect:~GEOMETRY#domrect
I.DOMRectList:~GEOMETRY#domrectlist
I.DOMRectReadOnly:~GEOMETRY#domrectreadonly
I.DOMQuad:~GEOMETRY#domquad
I.DOMQuadInit:~GEOMETRY#dictdef-domquadinit

	bubbles:~DOM4#
m.removeEventListener:~DOM4#dom-eventtarget-removeeventlistener
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.isTrusted:~DOM4#dom-event-istrusted
	m.type:~DOM4#dom-event-type
m.open:~WINDOW#dom-window-open
m.~doc-open:~HTMLdynamic#dom-document-open-window
	原文誤）m.open:~HTMLdynamic#dom-document-open
m.defaultView:~WINDOW#dom-document-defaultview
m.snapTargetBlock:~CSSSCROLLSNAP2#dom-snapevent-snaptargetblock
m.snapTargetInline:~CSSSCROLLSNAP2#dom-snapevent-snaptargetinline


mb.block:#dom-scrollintoviewoptions-block
mb.inline:#dom-scrollintoviewoptions-inline
mb.container:#dom-scrollintoviewoptions-container
mb.behavior:#dom-scrolloptions-behavior
mb.left:#dom-scrolltooptions-left
mb.top:#dom-scrolltooptions-top

mb.media:#dom-mediaquerylisteventinit-media
mb.matches:#dom-mediaquerylisteventinit-media
mb.box:#dom-boxquadoptions-box
mb.relativeTo:#dom-boxquadoptions-relativeto
mb.fromBox:#dom-convertcoordinateoptions-frombox
mb.toBox:#dom-convertcoordinateoptions-tobox

mb.checkOpacity:#dom-checkvisibilityoptions-checkopacity
mb.checkVisibilityCSS:#dom-checkvisibilityoptions-checkvisibilitycss
mb.contentVisibilityAuto:#dom-checkvisibilityoptions-contentvisibilityauto
mb.opacityProperty:#dom-checkvisibilityoptions-opacityproperty
mb.visibilityProperty:#dom-checkvisibilityoptions-visibilityproperty

mb.clientX:#dom-mouseeventinit-clientx
mb.clientY:#dom-mouseeventinit-clienty
mb.screenX:#dom-mouseeventinit-screenx
mb.screenY:#dom-mouseeventinit-screeny

opf.width:#supported-open-feature-name-width
opf.height:#supported-open-feature-name-height
opf.left:#supported-open-feature-name-left
opf.top:#supported-open-feature-name-top

et.resize:#eventdef-window-resize
et.scroll:#eventdef-document-scroll
et.scrollend:#eventdef-document-scrollend
et.change:#eventdef-mediaquerylist-change
et.scrollsnapchange:~CSSSCROLLSNAP2#eventdef-snapevent-scrollsnapchange
et.scrollsnapchanging:~CSSSCROLLSNAP2#eventdef-snapevent-scrollsnapchanging

l.auto:#dom-scrollbehavior-auto
l.smooth:#dom-scrollbehavior-smooth
l.instant:#dom-scrollbehavior-instant

l.start:#dom-scrolllogicalposition-start
l.center:#dom-scrolllogicalposition-center
l.end:#dom-scrolllogicalposition-end
l.nearest:#dom-scrolllogicalposition-nearest

l.margin:#dom-cssboxtype-margin
l.border:#dom-cssboxtype-border
l.padding:#dom-cssboxtype-padding
l.content:#dom-cssboxtype-content

l.all:#dom-scrollintoviewcontainer-all
l.~nearest0:#dom-scrollintoviewcontainer-nearest

e.body:~HEsections#the-body-element
e.rect:~SVGshapes#elementdef-rect

	●css
u.px:~CSSVAL#px

d.color:~MQ5#descdef-media-color

p.content-visibility:~CSSCONTAIN#propdef-content-visibility
p.position:~CSSPOS#propdef-position
p.direction:~CSSWM#propdef-direction
p.border-left-width:~CSSBORDER#propdef-border-left-width
p.border-top-width:~CSSBORDER#propdef-border-top-width
p.display:~CSSDISP#propdef-display
p.opacity:~CSSCOLOR#propdef-opacity
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.pointer-events:~CSSUI#propdef-pointer-events
p.scroll-behavior:~CSSOVERFLOW3#propdef-scroll-behavior
p.scroll-snap-align:~CSSSCROLLSNAP#propdef-scroll-snap-align
p.scroll-snap-type:~CSSSCROLLSNAP#propdef-scroll-snap-type
p.scroll-margin:~CSSSCROLLSNAP#propdef-scroll-margin
p.scroll-padding:~CSSSCROLLSNAP#propdef-scroll-padding
p.zoom:~CSSVIEWPORT#propdef-zoom

v.smooth:~CSSOVERFLOW3#valdef-scroll-behavior-smooth

v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden
v.visible:~CSSOVERFLOW3#valdef-overflow-visible
v.clip:~CSSOVERFLOW3#valdef-overflow-clip

v.table:~CSSDISP#valdef-display-table
v.inline-table:~CSSDISP#valdef-display-inline-table
v.table-column:~CSSDISP#valdef-display-table-column
v.table-column-group:~CSSDISP#valdef-display-table-column-group

v.fixed:~CSSPOS#valdef-position-fixed

	●用語
同じ側:#_same-side
実効~横幅:#_effective-width
実効~縦幅:#_effective-height
文書:#_document
~scrollされる~box:#scrolling-box

~window用の~scroll手続き:#_window-scroll-steps
要素~用の~scroll手続き:#_element-scroll-steps
要素~用の限界~boxを取得する:#element-get-the-bounding-box

視覚-表示域:#visual-viewport
~layout表示域:#layout-viewport
vV.拡縮率:#scale-factor
vV.結付けられた文書:#visualviewport-associated-document

開始辺:#beginning-edges
終了辺:#ending-edges

~supportされる~open_m特能~名:#supported-open-feature-name

mq.媒体~query~list:#mediaquerylist-media-query-list
mq.媒体:#mediaquerylist-media
mq.文書:#mediaquerylist-document
mq.合致-状態:#mediaquerylist-matches-state
有限~値に正規化する:#normalize-non-finite-values
~page~zoom:#page-zoom

~scrollされる区画:#scrolling-area
~scroll可能になり得る:#potentially-scrollable
~scroll可能になり得ない:#potentially-scrollable
doc.処理待ち~scroll~event群:#document-pending-scroll-events
要素を~scrollする:#scroll-an-element
瞬時に~scrollする:#concept-instant-scroll
滑らかに~scrollする:#concept-smooth-scroll
滑らか:#concept-smooth-scroll
滑らかな~scroll:#concept-smooth-scroll
~scrollを遂行する:#perform-a-scroll
表示域の~scrollを遂行する:#viewport-perform-a-scroll
~targetを~viewの中へ~scrollする:#scroll-a-target-into-view
~viewの中へ~scrollする位置を決定する:#determine-the-scroll-into-view-position
文書の先頭へ~scrollする:#scroll-to-the-beginning-of-the-document
sS.中止-:#smooth-scroll-aborted
sS.完了-:#smooth-scroll-completed
完了-:#scroll-completed

原点:#scrolling-area-origin

機器~pixel比を決定する:#determine-the-device-pixel-ratio

変形:#transforms

~SVG~layout~box:#svg-layout-box
	媒体~query~list ~listenerの~list:#list-of-media-query-list-listeners
~caret位置:#caret-position
~caret~node:#caret-node
~caret~offset:#caret-offset

~overflow方向:#overflow-directions

~Webに公開される~screen区画:#web-exposed-screen-area
~Webに公開される可用な~screen区画:#web-exposed-available-screen-area

閲覧~文脈の特能を設定しておく:#set-up-browsing-context-features

文書~用の媒体~queryを評価して変化を報告する:#evaluate-media-queries-and-report-changes
文書の~resize手続き:#document-run-the-resize-steps
文書の~scroll手続き:#document-run-the-scroll-steps

~layout後の状態を~snapshotする手続き:#run-snapshot-post-layout-state-steps

	●用語（CSS
~canvas:~CSScommon#canvas
表示域:~CSS2J#viewport

疑似要素:~SELECTORS4#pseudo-element
最終的な出自の要素:~SELECTORS4#ultimate-originating-element

基準~pixel:~CSSVAL#reference-pixel

~padding辺:~CSSBOX#padding-edge
~margin辺:~CSSBOX#margin-edge
~border辺:~CSSBOX#border-edge
内容~区画:~CSSBOX#content-area
~border~box:~CSSBOX#border-box
媒体~query~listとして構文解析する:~CSSOM1#parse-a-media-query-list
	媒体~query~listを直列化する:~CSSOM1#serialize-a-media-query-list

~box:~CSSDISP#box
首要~box:~CSSDISP#principal-box
行内~levelの~box:~CSSDISP#inline-level-box
塊~level:~CSSDISP#block-level
匿名:~CSSDISP#anonymous
塊~box:~CSSDISP#block-box
表示~型:~CSSDISP#display-type
不可視:~CSSDISP#invisible-box
根~要素:~CSSDISP#root-element

塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end
塊~flow方向:~CSSWM#block-flow-direction
行内~基底~方向:~CSSWM#inline-base-direction

~box断片:~CSSBREAK#box-fragment

古典~scrollbar:~CSSOVERFLOW3#classic-scrollbars
上層~scrollbar:~CSSOVERFLOW3#overlay-scrollbars

平坦~tree:~CSSSCOPING#flat-tree

内容-分布~prop:~CSSALIGN#content-distribution-properties

有拡縮:~CSSVIEWPORT#scaled
無拡縮:~CSSVIEWPORT#unscaled
実質的な~zoom:~CSSVIEWPORT#effective-zoom
実際の表示域:~CSSVIEWPORT#actual-viewport
初期~表示域:~CSSVIEWPORT#initial-viewport

接触判定:~CSSUI#hit-testing

~scroll留め容器:~CSSSCROLLSNAP#scroll-snap-container
留め位置:~CSSSCROLLSNAP#scroll-snap-position
	＠~CSSSCROLLSNAP#scroll-snap
留め位置を捕捉する:~CSSSCROLLSNAP#captures-snap-positions
最終的な留め~target:~CSSSCROLLSNAP2#eventual-snap-target
~scrollsnapchange_ev塊-軸~target:~CSSSCROLLSNAP2#scrollsnapchangetargetblock
~scrollsnapchange_ev行内-軸~target:~CSSSCROLLSNAP2#scrollsnapchangetargetinline
~scrollsnapchanging_ev塊-軸~target:~CSSSCROLLSNAP2#scrollsnapchanging-block-axis-target
~scrollsnapchanging_ev行内-軸~target:~CSSSCROLLSNAP2#scrollsnapchanging-inline-axis-target
~scrollsnapchange_ev~target群を更新する:~CSSSCROLLSNAP2#document-update-scrollsnapchange-targets
~scrollsnapchanging_ev~target群を更新する:~CSSSCROLLSNAP2#document-update-scrollsnapchanging-targets


	■補完
~border区画:~CSSBOX#border-area
包含塊:~CSSDISP#containing-block
行内:~CSSDISP#inline
初期~包含塊:~CSSDISP#initial-containing-block
置換d要素:~CSSDISP#replaced-element
~box~tree:~CSSDISP#box-tree

絶対的に位置され:~CSSPOS#absolute-position
固定的に位置され:~CSSPOS#fixed-position
絶対~位置決め包含塊:~CSSPOS#absolute-positioning-containing-block
固定d位置決め包含塊:~CSSPOS#fixed-positioning-containing-block
~flow外:~CSSDISP#out-of-flow

内容が飛ばされ:~CSSCONTAIN#skips-its-contents
実~値:~MQ5#real-value

~typographic文字~単位:~CSSTEXT#typographic-character-unit
書記素~cluster:~CSSTEXT#grapheme-cluster

~scroll容器:~CSSOVERFLOW3#scroll-container


	●用語（外部
~map:~INFRA#ordered-map
符号単位:~INFRA#code-unit
付加する:~INFRA#list-append
空にする:~INFRA#list-empty

並列的:~HTMLINFRA#in-parallel
~live:~HTMLINFRA#live
~HTML要素:~HTMLINFRA#html-elements
一致する:~INFRA#string-is
文字大小区別:~INFRA#string-is

新たな~promise:~WEBIDLjs#a-new-promise
解決される~promise:~WEBIDLjs#a-promise-resolved-with
~promiseを解決する:~WEBIDLjs#resolve
すべての~promiseを待機する:~WEBIDLjs#wait-for-all

整数として構文解析する:~HTMLcms#rules-for-parsing-integers

~body要素:~HTMLdom#the-body-element-2

閲覧~文脈:~HTMLds#browsing-context
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
nav.作動中な文書:~HTMLds#nav-document
全部的に作動中:~HTMLds#fully-active
nav.容器~文書:~HTMLds#nav-container-document

結付けられた文書:~WINDOW#concept-document-window
対応する閲覧~文脈:~WINDOW#window-bc

同一-生成元:~ORIGIN#same-origin

~event~loop:~WAPI#event-loop
~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
関連な大域~obj:~WAPI#concept-relevant-global
描画を更新する手続き:~WAPI#update-the-rendering

~event~listener:~DOM4#concept-event-listener
~target:~DOM4#event-target
evL.型:~DOM4#event-listener-type
evL.~callback:~DOM4#event-listener-callback
evL.捕捉するか:~DOM4#event-listener-capture
~event~listener~list:~DOM4#eventtarget-event-listener-list
~event~listenerを追加する:~DOM4#add-an-event-listener
~event~listenerを除去する:~DOM4#remove-an-event-listener
~eventを発火する:~DOM4#concept-event-fire
ev.配送-中か:~DOM4#dispatch-flag
過去互換~mode:~DOM4#concept-document-quirks
doc.生成元:~DOM4#concept-document-origin
包含され:~DOM4#contained
部分的に包含され:~DOM4#partially-contained

要素:~DOM4#concept-element
	文書:~DOM4#concept-document
~node:~DOM4#concept-node
~index:~DOM4#concept-tree-index
根:~DOM4#concept-tree-root
親:~DOM4#concept-tree-parent
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element
~host:~DOM4#concept-documentfragment-host
閉な~shadowで非可視:~DOM4#concept-closed-shadow-hidden
~shadow根:~DOM4#concept-shadow-root
	~TR/css-scoping-1/#shadow-root
~shadowも含めた広義-先祖:~DOM4#concept-shadow-including-inclusive-ancestor

~live範囲o:~DOM4#concept-live-range
範囲o:~DOM4#concept-range
rG.始端:~DOM4#concept-range-start
rG.終端:~DOM4#concept-range-end
中身:~DOM4#_concept-range-content
境界~点:~DOM4#concept-range-bp
bp.~node:~DOM4#boundary-point-node
bp.~offset:~DOM4#boundary-point-offset

	始端~node:~DOM4#concept-range-start-node → rG.始端
	始端~offset:~DOM4#concept-range-start-offset → rG.始端
	終端~node:~DOM4#concept-range-end-node → rG.終端
	終端~offset:~DOM4#concept-range-end-offset → rG.終端

具現化されて:~HTMLrendering#being-rendered

	●補完
限界~box:~SVGcoords#TermBoundingBox

●●words_table1

CSSVIEWPORT:https://drafts.csswg.org/css-viewport/
CSSSCROLLSNAP2:https://drafts.csswg.org/css-scroll-snap-2/

open_m: <code>open()</code>
doc-open:open
scroll_ev: <code class="event-type">scroll</code> 
scrollend_ev: <code class="event-type">scrollend</code> 
scrollsnapchanging_ev: <code class="event-type">scrollsnapchanging</code> 
scrollsnapchange_ev: <code class="event-type">scrollsnapchange</code> 
nearest0:nearest

●●words_table


代用対:surrogate pair::サロゲートペア:
	セット:set
		→ ON, OFF

	●CSS layout
	viewport
ascent::::アセント
descent::::ディセント
限界:bounding::~
限界域:bounds::~
	~~限界まで来た:extent
描画面:rendering surface::~
中身:content::~
横書き:horizontal writing::~
固定d:fixed::固定
固定的:fixed::~
固定-:fix::~
分布:distribution::~
首要:principal::主要
基準:reference:~
	~flowし直-:reflow
	幅:how large
有拡縮:scaled::~
無拡縮:unscaled::~


	●塗り
alpha::::アルファ
塗られ:paintされ:~
塗り:paint:~

	最~上端:topmost

	●scroll／UI
目的位置:position:~
zoom::::ズーム
	~zoom法:zooming
拡大-:zoom in::~::ズームイン
縮小-:zoom out::~::ズームアウト
pan::::パン
caret::::キャレット
pinch::::ピンチ
	~pinch~zoom:pinch-zoom
滑らか:smooth::~
拡縮-:scale::~
拡縮率:scale factor::~
処理待ち:pending:~
接触判定:hit-testing::~
瞬時:instant::~
計量:metric:~
量:amount:~
周期:interval:~
touch::::タッチ
drag::::ドラッグ
	複~touch
wheel::::ホイール
隠され:hideされ:~
ARIA:
終止-:end:~
留め:snap::~::スナップ
	~scroll留め:scroll-snap
	留め法:snapping
留める:snapする::~::スナップする
並進:translation::~
判読可能に:legibleに:判読し易く
露呈-:reveal::露わに
上層:overlay::~::オーバーレイ
解放-:release:~
trackpad::::トラックパッド
選択-:select:~
virtual:
縮短-:shrink:~
差分:delta:~

	~scrollされる〜:scrolling〜
	~scroll法:scrolling
	~scroll用:scrolling
	~~位置
	倍率:magnitude
	-:magnitude
	^en:proportional
	~~拡大鏡:magnifying glass
	下へ:down by
	ぶつかる:bump up
	回す:tick
	持ち込む:bring
	押し出す:push
	あと〜までしか:room

	●幾何
x:
y:
dx:
dy:
幾何:geometry:~
点:point:~
右横書き:right-to-left:~
	右横書き:RTL
横方向:horizontal::~
	~x:horizontal
縦方向:vertical::~
	~y:vertical
	縦幅:vertical dimension
	横幅:horizontal dimension
上辺:top edge::~
下辺:bottom edge::~
左辺:left edge::~
右辺:right edge::~
上方:upward::~
下方:downward::~
左方:leftward::~
右方:rightward::~
中心:center::~
開始辺:beginning edge::~
	先頭:beginning
終了辺:ending edge::~
	innermost, outermost
矩形:rectangle:~
四辺形:quadrilateral shape:~
変形:transform::~
	transforms
増大-:increase:~
減少-:decrease:~
比:ratio:~

	各辺が軸に整列された:axis-aligned
	~screen外:offscreen

	●DOM／IDL
閉な:closed::閉じた
補助:auxiliary:~
範囲o:range::範囲°
中身:内容

	●処理
割振られ:allocateされ:割り振られ
切詰める:clampする:切り詰める
分配-:distribute:~
協調-:coordinate:~
決着-:settle::~
	まだ決着していない:still in the pending state

	事前に:ahead of time
	逆順に:in opposite order
	~MINUS:difference between
	無効~化:invalidate
	その場を占める:take place
	次回の:the next
	~layout後:post-layout

	●変数
1:
2:
	%~target限界~box:target bounding border box
	%文書:doc
	%最大~x:maxX
	%最大~y:maxY
	%~x
	%~y
	%視覚-~x:visual x
	%視覚-~y:visual y
	%~dx:dx
	%~dy:dy
	%視覚-~dx:visual dx
	%視覚-~dy:visual dy
	%vv:vv
	%留め容器:snapcontainer
	-:newBlockTarget
	-:newInlineTarget
	`~node$bp:caretPositionNode
	`~offset$bp:caretPositionOffset
	%~caret位置:caretPosition
	%~caret範囲:caretRange
	%始端~node:startNode
	%始端~offset:startOffset
	%境界~点:-
	%型:type
	%塊~target:blockTarget
	%行内~target:inlineTarget
	%~scroll~promise:scrollPromise
	%~scroll~promise~1:scrollPromise1
	%~scroll~promise~2:scrollPromise2
	%先祖~promise群:ancestorPromises

	●仕様
見積もり:estimation:~
網羅的:exhaustive:~
誤り:error:~
単直:straightforward:簡単
種類:kind:~
合意-:agree:~
図画化:depiction:~
的確:right:~
尊重-:respect:~
冗長:redundant:~
参照r:refer:参照
本当の:realな:~

	により定義される:-defined
	詳細:specifics
	に配慮する:considerations
	知られ:known to
	~~適度な:not get too 〜
	ふりをする:masquerade
	選んで:chooseして
	任意で選べる:opted into
	指す:refer
	称され:referred
	調べる:see
	したがって:it follows that
	問われる:matter
	関心がある:of interest
	〜に従う下で:into
	織り込むように:now acknowledged
	区別:distinction
	転換-:turn
	前任:former:~
	各種:various
	嘘をつく:lie

	●構文
剥いだ:stripした:~

	●未分類
非可視:hidden:~
隠す:hideする:~
body:
色域:color gamut::~
深度:depth:~
書記素:grapheme::~
typographic::::タイポグラフィック
	片割れ:half
	合致-状態:matches state
担当の:responsible:~
座標軸:axis::~
量子化-:quantize:~
隠蔽-:obscure:~
display::::ディスプレイ
浮動小数点:floating point::~
発-:emit:~
維持-:retain:~
携帯機:mobile::~::モバイル
静止-::pause:~
捕捉-:capture::~
実効:effective:~
	-:component
	所属:belongs to
	`一致する$かどうかにより:is
	~Web~IDL:WebIDL
	更新し終えた:finished updating
	より大きく:larger
	最も近い:nearest

●●html_code_list

■scrollIntoView-1
<style>
    .scroller { overflow: auto; scroll-padding: 8px; }
    .slide { scroll-margin: 16px; scroll-snap-align: center; }
</style>
<div class="carousel">
    <div class="slides scroller">
        <div id="s1" class="slide">
        <div id="s2" class="slide">
        <div id="s3" class="slide">
    </div>
    <div class="markers">
        <button data-target="s1">1</button>
        <button data-target="s2">2</button>
        <button data-target="s3">3</button>
    </div>
</div>
<％script>
    document.querySelector('.markers').addEventListener('click', (%evt) => {
        const %target = document.getElementById(%evt.target.dataset.target);
        if (!%target) return;
        %target.scrollIntoView/* †1 */({
            container: 'nearest'/* †2 */,
            behavior: 'smooth'
        });
    });
<％/script>


●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-BORDERS-4]
    Elika Etemad; et al. ＜CSS Borders and Box Decorations Module Level 4＞. URL: https://drafts.csswg.org/css-borders-4/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-COLOR-4]
    Chris Lilley; Tab Atkins Jr.; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color-4/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-DEVICE-ADAPT]
    Florian Rivoal; Emilio Cobos Álvarez. ＜CSS Viewport Module Level 1＞. URL: https://drafts.csswg.org/css-viewport/
[CSS-DISPLAY-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 4＞. URL: https://drafts.csswg.org/css-display/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-PSEUDO-4]
    Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. URL: https://drafts.csswg.org/css-pseudo-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SCROLL-SNAP-1]
    Matt Rakow; et al. ＜CSS Scroll Snap Module Level 1＞. URL: https://drafts.csswg.org/css-scroll-snap-1/
[CSS-SCROLL-SNAP-2]
    Elika Etemad; Tab Atkins Jr.; Adam Argyle. ＜CSS Scroll Snap Module Level 2＞. URL: https://drafts.csswg.org/css-scroll-snap-2/
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. ＜CSS Text Module Level 3＞. URL: https://drafts.csswg.org/css-text-3/
[CSS-TEXT-4]
    Elika Etemad; et al. ＜CSS Text Module Level 4＞. URL: https://drafts.csswg.org/css-text-4/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[GEOMETRY-1]
    Simon Pieters; Chris Harrelson. ＜Geometry Interfaces Module Level 1＞. URL: https://drafts.fxtf.org/geometry/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[SVG2]
    Amelia Bellamy-Royds; et al. ＜Scalable Vector Graphics (SVG) 2＞. URL: https://svgwg.org/svg2-draft/
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. URL: https://w3c.github.io/uievents/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 3＞. URL: https://drafts.csswg.org/css-writing-modes-3/
[CSSOM-VIEW-1]
    Simon Fraser; Emilio Cobos Álvarez. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSSOM View Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/cssom-view-1/
公表履歴
	https://www.w3.org/standards/history/cssom-view-1/
旧公表バージョン
	https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/cssom-view-1">CSSWG Issues Repository</a>

編集
	<a href="mailto:simon.fraser@apple.com">Simon Fraser</a> (Apple Inc)
	<a href="emilio@mozilla.com">Emilio Cobos Álvarez</a> (Mozilla)
前任編集者
	<a href="mailto:simonp@opera.com">Simon Pieters</a> (Opera Software AS)
	<a href="https://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (Cox Communications, Inc.)
	<a href="https://annevankesteren.nl/">Anne van Kesteren</a> (Opera Software ASA)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/cssom-view-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/cssom-view-1

旧来の課題リスト
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM%20View&amp;resolution=---">Bugzilla</a>
テスト一式
	https://wpt.fyi/results/css/cssom-view/

</script>

</head>

<body>


<!--%resource pool -->
<template id="_persisted_parts">

<div id="_dgm-Window" class="_test">
<p>
利用中のブラウザで：
</p>
<ul>
	<li>
これらの属性の
<input value="取得を試みる" data-params="Window" type="button">
</li>
	<li>
x:<input id="_test-scroll-x" value="0" size="5" type="text">
y:<input id="_test-scroll-y" value="0" size="5" type="text">
を入力に
<label><input name="_test-scroll-fn" id="_test-scroll-scroll" type="radio"><code>scroll()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollTo" type="radio"><code>scrollTo()</code></label>
<label><input name="_test-scroll-fn" id="_test-scroll-scrollBy" checked="" type="radio"><code>scrollBy()</code></label>
<!-- 
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeTo" checked /><code >resizeTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-resizeBy" checked /><code >resizeBy()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveTo" checked /><code >moveTo()</code></label>
<label><input type="radio" name="_test-scroll-fn"  id="_test-scroll-moveBy" checked /><code >moveBy1()</code></label>
 -->
を
<input value="呼び出す" data-params="Window.scroll" type="button">
</li>
	<li>
次の媒体クエリ
<input id="_test-mql_text" value="(orientation: landscape)" size="70" list="_MQL_options" data-event="change" data-params="MediaQueryList" type="text">
に対し，
<code>Window.matchMedia()</code>
の
<input id="_test-MediaQueryList" value="取得を試みる" data-params="MediaQueryList" type="button">
<datalist id="_MQL_options" hidden><!--
(width >= 800px);
(width <= 800px);
(height >= 600px);
(height <= 600px);
(min-device-width: 640px);
(max-device-width: 640px);
(min-device-height: 480px);
(max-device-height: 480px);
(orientation: landscape);
(orientation: portrait);
(min-aspect-ratio: 1/1);
(min-aspect-ratio: 2/1);
(min-aspect-ratio: 1/2);
(max-aspect-ratio: 1/1);
(max-aspect-ratio: 2/1);
(max-aspect-ratio: 1/2);
(color);
(min-color: 8);
(max-color: 8);
(min-color-index: 256);
(max-color-index: 256);
(monochrome);
(min-resolution: 96dpi);
(max-resolution: 96dpi);
(scan: interlace);
(scan: progressive);
(grid);
(update-frequency: none);
(update-frequency: slow);
(update-frequency: normal);
(overflow-block: none);
(overflow-block: scroll);
(overflow-block: optional-paged);
(overflow-block: paged);
(overflow-inline: none);
(overflow-inline: scroll);
(inverted-colors: none);
(inverted-colors: inverted);
(pointer: none);
(pointer: fine);
(pointer: fine);
(hover: none);
(hover: on-demand);
(hover: hover);
(any-pointer: none);
(any-pointer: coarse);
(any-pointer: fine);
(any-hover: none);
(any-hover: on-demand);
(any-hover: hover);
(light-level: dim);
(light-level: normal);
(light-level: washed);
(scripting: none);
(scripting: initial-only);
(scripting: enabled);


all;braille;embossed;handheld;print;projection;screen;speech;tty;tv;aural
--></datalist>
	</li>
</ul>
</div>

<div id="_dgm-Screen" class="_test">
利用中のブラウザでこれらの属性の
<input value="取得を試みる" data-params="Screen" type="button">
</div>

<div id="_dgm-Document" class="_test">
<p>
利用中のブラウザで，マウス位置に対し：
</p>
<ul>
	<li>
<code>elementFromPoint()</code> の結果を
<input id="_test-elementFromPoint" value="表示する" data-params="elementFromPoint" type="button">
</li>
	<li>
<code>elementsFromPoint()</code> の結果を成す各 要素のタグ名の
<input id="_test-elementsFromPoint" value="取得を試みる" data-params="elementsFromPoint" type="button">
</li>
	<li>
<code>caretPositionFromPoint()</code> の
<input id="_test-caretPositionFromPoint" value="取得を試みる" data-params="caretPositionFromPoint" type="button">
</li>
</ul>
</div>


<div id="_dgm-Element" class="_test">
<p>
利用中のブラウザで：
</p>
<ul>
	<li>
<p>
マウスが重なった要素について：
</p>
		<ul>
			<li>
これらの属性の
<input value="取得を試みる" data-params="Element" type="button">
</li>
			<li>
<code>getClientRects()</code> の
<input value="取得を試みる" data-params="getClientRects" type="button">
</li>
			<li>
<code>getBoundingClientRect()</code> の
<input value="取得を試みる" data-params="ClientRect" type="button">
</li>
		</ul>
	</li>
	<li>
<p>
ランダムに選ばれた
<select size="1" id="_test-scrollIntoView-tagName"><option selected="">P</option><option>LI</option><option>H2</option><option>DT</option><option>DD</option></select>
要素に対し：
</p>
		<ul>
			<li>
<code>scrollIntoView(<label><input name="_test-SIV-top" id="_test-scrollIntoView-top" checked="" type="radio">true</label>
<label><input name="_test-SIV-top" type="radio">false</label>)</code>
を
<input id="_test-scrollIntoView" value="呼び出す" data-params="Element.scrollIntoView" type="button">
</li>
			<li>
<code>scrollIntoView( {
	behavior:
<select size="1" id="_test-scrollIntoView-behavior"><option selected="">auto</option><option>smooth</option></select>
	, block:
<select size="1" id="_test-scrollIntoView-block">
	<option selected="">start</option>
	<option>center</option>
	<option>end</option>
	<option>nearest</option>
</select>
	, inline:
<select size="1" id="_test-scrollIntoView-inline">
	<option>start</option>
	<option selected="">center</option>
	<option>end</option>
	<option>nearest</option>
</select>
} )</code> を
<input id="_test-scrollIntoView0" value="呼び出す" data-params="Element.scrollIntoView0" type="button">
</li>
		</ul>
	</li>
</ul>
</div>


<div id="_dgm-HTMLElement" class="_test">
利用中のブラウザでマウスが重なった要素について，これらの属性の
<input value="取得を試みる" data-params="HTMLElement" type="button">
</div>


<div id="_dgm-Range" class="_test">
<p>
利用中のブラウザで、
テキスト選択に応じて，その範囲に対し：
</p>
<ul>
	<li>
<code>getClientRects()</code> の
<input id="_test-Selection.getClientRects" value="取得を試みる" data-params="Selection.getClientRects" type="button">
</li>
	<li>
<code>getBoundingClientRect()</code> の
<input id="_test-Selection.getBoundingClientRect" value="取得を試みる" data-params="Selection.getBoundingClientRect" type="button">
</li>
</ul>
</div>

<div id="_dgm-MouseEvent" class="_test">
利用中のブラウザで mousemove イベントに対する，これらの属性の
<input id="_test-MouseEvent" value="取得を試みる" data-params="MouseEvent" type="button">
</div>

</template>


<header>

	<hgroup>
<h1 id="cssom-view-module">CSSOM View Module Level 1</h1>
	</hgroup>
</header>

<div  id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様が導入する~APIは、
作者に，文書の視覚的な~viewを調べたり, 操作するための方法を与える。
これには、［
要素の~layout~boxの位置を取得する,
~scriptを通して表示域~sizeを得する,
要素の~scroll法
］なども含まれる。
◎
The APIs introduced by this specification provide authors with a way to inspect and manipulate the visual view of a document. This includes getting the position of element layout boxes, obtaining the width of the viewport through script, and also scrolling an element.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="background">
<h2 title="Background">1. 背景0</h2>

<p>
この仕様にて定義される特能の多くは、
長い間~browserから~supportされてきた。
この仕様の目標は、
これらの特能を，すべての~browserが相互運用可能な方式で実装できるように定義することである。
この仕様は、
~scrollの~custom化を許容する，新たな特能も定義する。
◎
Many of the features defined in this specification have been supported by browsers for a long period of time. The goal of this specification is to define these features in such a way that they can be implemented by all browsers in an interoperable manner. The specification also defines a some new features which allow for scroll customization.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
簡潔に述べるため，次に挙げる（非公式な）用語も定義する：
</p>
<ul>
	<li>
`Document$I ~interfaceを実装する~objは、
単に
`文書@
と略記される。
</li>
	<li>
`表示域$の［
`実効~横幅@
／
`実効~縦幅@
］とは、
`表示域$に［
縦方向／横方向
］`古典~scrollbar$†が描画されているときは，［
それが成す区画を除外した`表示域$
］の［
横幅／縦幅
］を表す
— 他のときは，元の［
横幅／縦幅
］と同じになる。
（† `上層~scrollbar$は、
~layout用の区画を占めない。）
</li>
</ul>

<p>
“要素が`~box$を有する”
という句は、
要素に結付けられた~boxが在る
— すなわち，要素は 1 個以上の~boxを生成する —
ことを意味する。
要素の `display$p が［
`none^v ／ `contents^v
］の場合、
要素は，~boxを生成しないので~boxを有さない。
</p>

<p>
加えて、
次の記法を用いる：
</p>
<ul>
	<li>
<p>
記法 “［ %W ｜ %H ］” （ "｜" は全角の縦棒）は、
縦横それぞれの方向についての，並立的な記述を表す。
</p>

<p>
例えば
⇒
“［ x 属性 ｜ y 属性 ］ は表示域の［ 左端の~x座標 ｜ 上端の~y座標 ］ を返す”
◎終
と記されていれば、
それは 2 つの記述
⇒＃
“x 属性 は表示域の左端の~x座標を返す”,
“y 属性 は表示域の上端の~y座標を返す”
◎終
が，並立的に重ねられていることを表す。
この対応関係は，同じ~algoの中の別々な段の間でも維持される。
</p>

<p>
<small>
（このような表記を導入する理由は、
記述の簡約以外にも，［
縦横両方向に関する記述であって, その両方向について対称性がある
］ことを明らかにすることもある。）</small>
</p>
</li>
</ul>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様に利用される用語は
`DOM$r, `CSSOM$r, `HTML$r
による。
◎
Terminology used in this specification is from DOM, CSSOM and HTML. [DOM] [CSSOM] [HTML]
</p>

<p>
所与の（ある`文書$の）`~body要素$ %~body は、
~AND↓ を満たすとき，
`~scroll可能になり得る@
とされる。
◎
An element body (which will be the body element) is potentially scrollable if all of the following conditions are true:
</p>
<ul>
	<li>
%~body は`~box$を有する。
◎
body has an associated box.
</li>
	<li>
<p>
%~body, %~body の`親~要素$は、
どちらも次を満たす
⇒
［
`overflow-x$p,
`overflow-y$p
］~propのどちらかは次を満たす
⇒
算出d値 ~NIN { `visible$v, `clip$v }
</p>

<p class="trans-note">【
実際には、
片方の~propがこれを満たすならば，両方とも満たすことになる。
】</p>
◎
body’s parent element’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
◎
body’s computed value of the overflow-x or overflow-y properties is neither visible nor clip.
</li>
</ul>

<p class="note">注記：
`body$e 要素は、
`~scroll可能になり得る$としても，`~scrollされる~box$は無いこともある。
具体的には、
要素の `overflow$p の使用~値は `auto^v であるが，
その内容は内容~区画を~overflowしていない場合など。
◎
Note: A body element that is potentially scrollable might not have a scrolling box. For instance, it could have a used value of overflow being auto but not have its content overflowing its content area.
</p>

<p>
［
`表示域$／要素
］【が`~scroll容器$になるとき】の
`~scrollされる~box@
（ `scrolling box^en ）には、
2 つの
`~overflow方向@
— `塊-終端$, `行内-終端$ —
がある。
その初期~scroll位置は、
`内容-分布~prop$に依存して，`~scrollされる区画$の`原点$に整列されるとは限らないことに注意。
`CSS-ALIGN-3$r `§ 整列~overflowと~scroll容器＠~CSSALIGN#overflow-scroll-position$
を見よ。
◎
A scrolling box of a viewport or element has two overflow directions, which are the block-end and inline-end directions for that viewport or element. Note that the initial scroll position might not be aligned with the scrolling area origin depending on the content-distribution properties, see CSS Box Alignment 3 § 5.3 Alignment Overflow and Scroll Containers.
</p>

<p>
［
`表示域$／要素
］の
`~scrollされる区画@
（ `scrolling area^en ）は、
その`~scrollされる~box$の`~overflow方向$に応じて，各辺が以下に従って与えられる~boxである。
◎
The term scrolling area refers to a box of a viewport or an element that has the following edges, depending on the viewport’s or element’s scrolling box’s overflow directions.
</p>

<div>

<p>
記号
%D1 は［
上方, 下方, 左方, 右方
］いずれかの方向を表し，
%D2 は その反対~方向を表すとする。
`~overflow方向$に %D1 が含まれている（したがって %D2 は含まれていない）ならば、
~boxの［
%D1, %D2
］側の辺は次で与えられる：
</p>

<table><thead>
<tr><th><th>`表示域$に対しては
<th>要素に対しては
<tbody>

<tr><th>%D1 側の辺
<td>
［
`初期~包含塊$の %D1 側の辺, および
`表示域$のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺。
◎
The D1-most edge of the D1 edge of the initial containing block and the D1 margin edge of all of the viewport’s descendants' boxes.
<td>
［
要素の %D1 側の`~padding辺$, および
要素のすべての子孫~box†の %D1 側の`~margin辺$
］のうち，最も %D1 側の辺
— ただし，要素の先祖を`包含塊$とするような~boxは除外する††。
◎
The D1-most edge of the element’s D1 padding edge and the D1 margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><th style="white-space:nowrap;">%D2 側の辺

<td>
`初期~包含塊$の %D2 側の辺。
◎
The D2 edge of the initial containing block.
<td>
要素の %D2 側の`~padding辺$。
◎
The element’s D2 padding edge.
</table>

<p class="trans-note">【†
この子孫は、
`~box~tree$における子孫を意味する。
“表示域の子孫~box” が何を意味するのか不明だが、
当の文書の~box~treeを成す~boxすべてが該当すると見受けられる。
】【††
例えば，`~flow外$にある~boxなど。
】【
この箇所は、
原文の内容と等価になるよう，~parameter化により大幅に圧縮して記述している。
】</p>

<div lang="en" class="_en">
<table><thead>
<tr><th>If the overflow directions are…
<th>For a viewport
<th>For an element
<tbody style="white-space:pre-line;">

<tr><td>rightward and downward
<td>
top edge
• The top edge of the initial containing block.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left edge of the initial containing block.

<td>
top edge
• The element’s top padding edge.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The element’s left padding edge.

<tr><td>leftward and downward
<td>
top edge
• The top edge of the initial containing block.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom-most edge of the bottom edge of the initial containing block and the bottom margin edge of all of the viewport’s descendants' boxes.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>top edge
• The element’s top padding edge.

right edge
• The element’s right padding edge.

bottom edge
• The bottom-most edge of the element’s bottom padding edge and the bottom margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>leftward and upward
<td>
top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right edge of the initial containing block.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left-most edge of the left edge of the initial containing block and the left margin edge of all of the viewport’s descendants' boxes.

<td>
top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The element’s right padding edge.

bottom edge
• The element’s bottom padding edge.

left edge
• The left-most edge of the element’s left padding edge and the left margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

<tr><td>rightward and upward
<td>
top edge
• The top-most edge of the top edge of the initial containing block and the top margin edge of all of the viewport’s descendants' boxes.

right edge
• The right-most edge of the right edge of the initial containing block and the right margin edge of all of the viewport’s descendants' boxes.

bottom edge
• The bottom edge of the initial containing block.

left edge
• The left edge of the initial containing block.

<td>
top edge
• The top-most edge of the element’s top padding edge and the top margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

right edge
• The right-most edge of the element’s right padding edge and the right margin edge of all of the element’s descendants' boxes, excluding boxes that have an ancestor of the element as their containing block.

bottom edge
• The element’s bottom padding edge.

left edge
• The element’s left padding edge.
</table>
</div>
</div>

<p>
`~scrollされる区画$の
`原点@
は、［
`表示域$の`~scrollされる区画$ならば，`初期~包含塊$の原点／
他の場合は，要素の~scroll位置が既定の位置にあるときの要素の~padding辺の左上隅
］に~~位置する。
［
~x座標は右方／~y座標は下方
］へ増大する。
◎
The origin of a scrolling area is the origin of the initial containing block if the scrolling area is a viewport, and otherwise the top left padding edge of the element when the element has its default scroll position. The x-coordinate increases rightwards, and the y-coordinate increases downwards. 
</p>

<div class="p">
<p>
［
表示域, または［
~boxあるいは要素
］］の［
`開始辺@
／
`終了辺@
］は、
その`~overflow方向$と［
反対~方向 ／ 同じ方向
］にある辺を指す
（例えば，`~overflow方向$が右方と下方ならば、
開始辺は左辺および上辺, 終了辺は右辺および下辺になる, 等々）。
【ここでも、原文と等価になるよう，圧縮して訳している。】
</p>

◎
The beginning edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The top and left edges.
• If the overflow directions are leftward and downward
•• The top and right edges.
• If the overflow directions are leftward and upward
•• The bottom and right edges.
• If the overflow directions are rightward and upward
•• The bottom and left edges.
◎
The ending edges of a particular set of edges of a box or element are the following edges:
• If the overflow directions are rightward and downward
•• The bottom and right edges.
• If the overflow directions are leftward and downward
•• The bottom and left edges.
• If the overflow directions are leftward and upward
•• The top and left edges.
• If the overflow directions are rightward and upward
•• The top and right edges.
</div>

<p>
`表示域$には、
`視覚-表示域@
（ `visual viewport^en ）
, 対応する
`~layout表示域@
（ `layout viewport^en ）の 2 種類がある
— 後者は、
前者の`~scrollされる区画$を成す。
◎
The visual viewport is a kind of viewport whose scrolling area is another viewport, called the layout viewport.
</p>

<p>
~scroll法に加え、
`視覚-表示域$の`~layout表示域$には，拡縮-変形も適用され得る。
この変形は、
当の視覚-表示域の`~canvas$に適用され，その内部的な~座標~空間には影響しない。
◎
In addition to scrolling, the visual viewport may also apply a scale transform to its layout viewport. This transform is applied to the canvas of the layout viewport and does not affect its internal coordinate space.
</p>

<p class="note">注記：
視覚-表示域の拡縮-変形は、
“~pinch~zoom（ `pinch-zoom^en ）” と称されることが多い†。
この変形は、
概念的に，~CSS`基準~pixel$の~sizeを変更するが，
~layout表示域の~sizeを
— ~pageの内容を~flowし直すことなく —
`proportional^en に変更する††。
◎
Note: The scale transform of the visual viewport is often referred to as "pinch-zoom". Conceptually, this transform changes the size of the CSS reference pixel but changes the size of the layout viewport proportionally so that it does not cause reflow of the page’s contents.
</p>

<p class="trans-note">【†
“局所的” な~zoom。
おそらく、［
複~touch機器の~UIで利用される，二本指で “つまんで” 拡げる~~操作
］に由来する呼称。
】【††
“~~拡大鏡” のように、
`~box~tree$を成す すべての`~box$にわたって，同じ倍率で。
】</p>

<p>
この拡縮-変形の倍率は、
`視覚-表示域$の
`拡縮率@vV
（ `scale factor^en ）と称される。
◎
The magnitude of the scale transform is known as the visual viewport’s scale factor.
</p>

<div class="example">
<p id="example-vvanimation">
この例は、
ある~zoomされた視覚-表示域が，
（例えば，~touch~dragを遂行している利用者により）
“~panされる” 様子を~animationで示す。
~pageは、
`~layout表示域$が`視覚-表示域$より大きくなるよう拡縮されている。
◎
This animation shows an example of a zoomed in visual viewport being "panned" around (for example, by a user performing a touch drag). The page is scaled so that the layout viewport is larger than the visual viewport.
</p>

<p>
~scroll差分は、
まず，当の`視覚-表示域$に適用される。
視覚-表示域の~~限界まで来たときは、
~scroll差分は，当の`~layout表示域$に適用されることになる。
この挙動は、
`表示域の~scrollを遂行する$手続きにより実装される。
◎
A scroll delta is applied to the visual viewport first. When the visual viewport is at its extent, scroll delta will be applied to the layout viewport. This behavior is implemented by the perform a scroll steps.
</p>

<figure>
<figcaption>
この挙動をデモる~animation
— 下の~box内のどこでも，~clickする度に［
再開-（開始-）／静止-
］される。
</figcaption>
<div id="_vvanimation" class="_paused">
文書
	<div class="_lv">~layout表示域</div>
	<div class="_vv">視覚-表示域</div>
</div>
</figure>
</div>

<p>
◎
↓↓§ VisualViewport
The VisualViewport object has an associated document, which is a Document object. It is the associated document of the owner Window of VisualViewport. The layout viewport is the owner Window’s viewport.
</p>

<p>
この仕様の要件の目的においては、
`display$p ~propの算出d値が［
`table-column$v ／ `table-column-group$v
］になる要素は、
（［
~col／~col~group
］の）`~box$を有すると見なすモノトスル。
◎
For the purpose of the requirements in this specification, elements that have a computed value of the display property that is table-column or table-column-group must be considered to have an associated box (the column or column group, respectively).
</p>

<p>
用語
`~SVG~layout~box@
は、
ある~SVG要素により生成される`~box$を指す
— それは、
~CSSにより定義される`表示~型$【！ `display$p 】には対応しない。
（ `rect$e 要素により生成される~boxなど。）
◎
The term SVG layout box refers to a box generated by an SVG element which does not correspond to a CSS-defined display type. (Such as the box generated by a rect element.)
</p>

<p>
用語
`変形@
は、［
~SVG／~CSS
］による変形（座標系変換）を指す。
`SVG11$r
`CSS-TRANSFORMS-1$r
◎
The term transforms refers to SVG transforms and CSS transforms. [SVG11] [CSS-TRANSFORMS-1]
</p>

<p>
［
~IDL~method／属性
］（以下，単に “~member” ）から別の~memberが呼ばれるときは、
~UAは，~memberの内部~APIを呼出すモノトスル
— すなわち、
作者は［
~custom ECMAScript ~propや関数で上書きして，~memberの挙動を変更する
］ことはできない。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
他が指定されない限り、
文字列は【！is】`一致する$かどうかにより比較される。
◎
Unless otherwise stated, all string comparisons use is.
</p>

		<section id="css-pixels">
<h3 title="CSS pixels">2.1. ~CSS~pixel</h3>

<p>
他が指定されない限り、
この仕様で定義される~API用の［
座標, 寸法
］は，すべて`~CSS~pixel＠~CSSVAL#px$単位とする。
`CSS-VALUES$r
【この訳では、 “`px$u 単位” と略記する。】
◎
All coordinates and dimensions for the APIs defined in this specification are in CSS pixels, unless otherwise specified. [CSS-VALUES]
</p>

<p class="note">注記：
このことは、
例えば `matchMedia()^m には該当しない。
そのような所では、
単位は明示的に与えられる。
◎
Note: This does not apply to e.g. matchMedia() as the units are explicitly given there.
</p>

		</section>
		<section id="zooming">
<h3 title="Zooming">2.2. ~zoom法</h3>

<p>
~zoomには 2 種類ある：
`~page~zoom@
は、
`初期~表示域$の~sizeに影響する
【例：文字を大きく表示させたときなど】
。
`視覚-表示域$の`拡縮率$vVは、
~~拡大鏡のように動作して，`初期~表示域$や`実際の表示域$には影響しない。
`CSS-DEVICE-ADAPT$r
◎
There are two kinds of zoom, page zoom which affects the size of the initial viewport, and the visual viewport scale factor which acts like a magnifying glass and does not affect the initial viewport or actual viewport. [CSS-DEVICE-ADAPT]
</p>

<p class="note">注記：
拡縮率は， “~pinch~zoom” と称されることが多いが、
~pinch~zoomする以外の手段を通しても影響され得る。
例：~UAは、
~focusされた入力~要素が判読可能になるよう~zoomすることもある。
◎
Note: The "scale factor" is often referred to as "pinch-zoom"; however, it can be affected through means other than pinch-zooming. e.g. The user agent may zooms in on a focused input element to make it legible.
</p>

		</section>
		<section id="web-exposed-screen-information">
<h3 title="Web-exposed screen information">2.3. ~Webに公開される~screen情報</h3>

<p>
~UAは、
利用者の~privacyを保護するためとして，［
出力~機器の~screenについての情報を隠す
］ことを選んでもヨイ。
各種~APIにわたって一貫した方式でそうするため、
この仕様は，用語として以下に挙げる区画を定義する。
これら各~区画は、
いずれも［
有限な ( 横幅, 縦幅 ) を有する／
左上隅を原点にとる／
~x座標は右方へ増大する／
~y座標は下方へ増大する／
座標の単位は `px$u
］とする：
◎
User agents may choose to hide information about the screen of the output device, in order to protect the user’s privacy. In order to do so in a consistent manner across APIs, this specification defines the following terms, each having a width and a height, the origin being the top left corner, and the x- and y-coordinates increase rightwards and downwards, respectively.
</p>

<ul>
	<li>
`~Webに公開される~screen区画@
— 次に挙げるいずれかになるとする
⇒＃
出力~機器の区画／
`表示域$の区画
◎
The Web-exposed screen area is one of the following:
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
	<li>
`~Webに公開される可用な~screen区画@
— 次に挙げるいずれかになるとする
⇒＃
出力~機器の描画面として可用な区画／
出力~機器の区画／
`表示域$の区画／
◎
The Web-exposed available screen area is one of the following:
• The available area of the rendering surface of the output device, in CSS pixels.
• The area of the output device, in CSS pixels.
• The area of the viewport, in CSS pixels.
</li>
</ul>

		</section>
	</section>
	<section id="common-infrastructure">
<h2 title="Common Infrastructure">3. 共通基盤</h2>

<p>
この仕様は WHATWG Infra 標準に依存する。
`INFRA$r
◎
This specification depends on the WHATWG Infra standard. [INFRA]
</p>

		<section id="scrolling">
<h3 title="Scrolling">3.1. ~scroll法</h3>

<div class="algo">
<p>
`~scrollを遂行する@
~algoは、
所与の
⇒＃
`~scrollされる~box$ %~box,
位置 %目的位置,
［`要素$／`疑似要素$］ %要素,
~scrollの挙動 %挙動 ~DF `auto$l
◎終
に対し：
◎
When a user agent is to perform a scroll of a scrolling box box, to a given position position, an associated element or pseudo-element element and optionally a scroll behavior behavior (which is "auto" if omitted), the following steps must be run:
</p>
<ol>
	<li>
~IF［
%~box において`滑らかな~scroll$は進行中である
］
⇒
それを`中止-$sSする
◎
Abort any ongoing smooth scroll for box.
</li>
	<li>
<p>
%~box を伴う`~scroll容器$に対する処理待ちな~scroll~promiseたち†
を成す
~EACH( %~promise )
に対し
⇒
`~promiseを解決する$( %~promise )
</p>

<p class="trans-note">【†
［
この仕様に定義される各種~scroll~algo（この~algo自身も含まれる）
］のうち［
引数として`~scrollされる~box$をとり，~promiseを返すもの
］に対し，［
当の引数に %~box を渡して遂行されたものが返した結果
］のうち［
まだ決着していないもの
］を意味すると思われる。
】</p>
◎
Resolve all pending scroll Promises whose scroll container is box.
</li>
	<li>
%~scroll~promise ~LET `新たな~promise$
◎
Let scrollPromise be a new Promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
↓ Return scrollPromise,＼
and run the remaining steps in parallel.
</p>
		<ol>
			<li>
<p>
~IF［
~AND↓
］…
◎
If＼
</p>
		<ul>
			<li>
<p>
~UAは `scroll-behavior$p ~propを尊守する
◎
the user agent honors the scroll-behavior property and＼
</p>

<p class="trans-note">【
尊守する（ `honor^en ）とは、［
当の特能は、
~UAが~supportしていて，（環境設定などにより）可能化されてもいる
］ことを意味すると見受けられる。
】</p>
			</li>
			<li>
<p>
~OR↓：
◎
one of the following is true:
</p>
				<ul>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
%挙動 ~EQ `auto$l
◎
behavior is "auto" and＼
</li>
							<li>
%要素 ~NEQ ~NULL
◎
element is not null and＼
</li>
							<li>
%要素 の `scroll-behavior$p ~propの算出d値 ~EQ `smooth$v
◎
its computed value of the scroll-behavior property is smooth, or
</li>
						</ul>
					</li>
					<li>
%挙動 ~EQ `smooth$l
◎
behavior is smooth
</li>
				</ul>
			</li>
		</ul>
<p>
…ならば
⇒
%~box を %目的位置 へ`滑らかに~scrollする$
◎
then perform a smooth scroll of box to position;＼
</p>
			</li>
			<li>
~ELSE
⇒＃
%~box を %目的位置 へ`瞬時に~scrollする$
◎
otherwise, perform an instant scroll of box to position.
</li>
			<li>
~scroll位置の更新を完遂するか,
%~scroll~promise が解決されるまで待機する
◎
Wait until either the position has finished updating, or scrollPromise has been resolved.
</li>
			<li>
<p>
~IF［
%~scroll~promise はまだ決着していない
］：
◎
If scrollPromise is still in the pending state:
</p>
				<ol>
					<li>
~IF［
~scroll位置は，この~callの結果により変化した
］
⇒
`scrollend$et ~eventを発する
【`~eventを発火する$( %要素, `scrollend$et ) ？】
◎
If the scroll position changed as a result of this call, emit the scrollend event.
</li>
					<li>
`~promiseを解決する$( %~scroll~promise )
◎
Resolve scrollPromise.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~scroll~promise
◎
↑</li>
</ol>

<p class="note">注記：
`behavior$mb に `instant$l を与えた場合、
この~algoにより，常に瞬時な~scrollが遂行される。
◎
Note: behavior: "instant" always performs an instant scroll by this algorithm.
</p>

<p class="note">注記：
［
利用者-ヤリトリ／~program的な呼出n
］の結果，~scroll位置が変化せず, 適用される並進は無かった場合、
~scrollは生じないので，
`scrollend$et ~eventは発火されない。
◎
Note: If the scroll position did not change as a result of the user interaction or programmatic invocation, where no translations were applied as a result, then no scrollend event fires because no scrolling occurred.
</p>
</div>

<div class="algo">
<p>
`表示域の~scrollを遂行する@
~algoは、
所与の
⇒＃
`表示域$ %表示域,
位置 %目的位置,
~scrollの挙動 %挙動 ~DF `auto$l
◎終
に対し，次の手続きにより協調された表示域~scroll
【視覚-表示域, ~layout表示域に対し協調された~scroll】
を遂行するモノトスル：
`VisualViewport^I1
◎
When a user agent is to perform a scroll of a viewport to a given position position and optionally a scroll behavior behavior (which is "auto" if omitted) it must perform a coordinated viewport scroll by following these steps:
</p>
<ol>
	<li>
%文書 ~LET %表示域 に結付けられた`文書$
◎
Let doc be the viewport’s associated Document.
</li>
	<li>
%vv ~LET 次を満たす `VisualViewport$I ~obj
【該当するものは、一つだけ在ることになる】
⇒
それに`結付けられた文書$vV ~EQ %文書
◎
Let vv be the VisualViewport whose associated document is doc.
</li>
	<li>
%最大~x ~LET %表示域 の`~scrollされる~box$の横幅 ~MINUS %vv の `width$m1 属性の値
◎
Let maxX be the difference between viewport’s scrolling box’s width and the value of vv’s width attribute.
</li>
	<li>
%最大~y ~LET %表示域 の`~scrollされる~box$の縦幅 ~MINUS %vv の`height$m1 属性の値
◎
Let maxY be the difference between viewport’s scrolling box’s height and the value of vv’s height attribute.
</li>
	<li>
%~dx ~LET %目的位置 の~x成分 ~MINUS %vv の `pageLeft$m1 属性の値
◎
Let dx be the horizontal component of position - the value vv’s pageLeft attribute
</li>
	<li>
%~dy ~LET %目的位置 の~y成分 ~MINUS %vv の `pageTop$m1 属性の値
◎
Let dy be the vertical component of position - the value of vv’s pageTop attribute
</li>
	<li>
%視覚-~x ~LET %vv の `offsetLeft$m1 属性の値
◎
Let visual x be the value of vv’s offsetLeft attribute.
</li>
	<li>
%視覚-~y ~LET %vv の `offsetTop$m1 属性の値
◎
Let visual y be the value of vv’s offsetTop attribute.
</li>
	<li>
%視覚-~dx ~LET `min^op( %最大~x, `max^op( 0, %視覚-~x ~PLUS %~dx )) ~MINUS %視覚-~x
◎
Let visual dx be min(maxX, max(0, visual x + dx)) - visual x.
</li>
	<li>
%視覚-~dy ~LET `min^op( %最大~y, `max^op( 0, %視覚-~y ~PLUS %~dy )) ~MINUS %視覚-~y
◎
Let visual dy be min(maxY, max(0, visual y + dy)) - visual y.
</li>
	<li>
%~layout~dx ~LET %~dx ~MINUS %視覚-~dx
◎
Let layout dx be dx - visual dx
</li>
	<li>
%~layout~dy ~LET %~dy ~MINUS %視覚-~dy
◎
Let layout dy be dy - visual dy
</li>
	<li>
%要素 ~LET %文書 の`根~要素$は［
在るならば それ／
無いならば ~NULL
］
◎
Let element be doc’s root element if there is one, null otherwise.
</li>
	<li>
%~scroll~promise~1 ~LET `~scrollを遂行する$( ↓ )
⇒＃
%表示域 の`~scrollされる~box$,
%表示域 の~scroll位置 ~PLUS ( %~layout~dx, %~layout~dy ),
%要素,
%挙動
◎
Perform a scroll of the viewport’s scrolling box to its current scroll position + (layout dx, layout dy) with element as the associated element, and behavior as the scroll behavior. Let scrollPromise1 be the Promise returned from this step.
</li>
	<li>
%~scroll~promise~2 ~LET `~scrollを遂行する$( ↓ )
⇒＃
%vv の`~scrollされる~box$, 
%vv の~scroll位置 ~PLUS ( %視覚-~dx, %視覚-~dy ),
%要素,
%挙動
◎
Perform a scroll of vv’s scrolling box to its current scroll position + (visual dx, visual dy) with element as the associated element, and behavior as the scroll behavior. Let scrollPromise2 be the Promise returned from this step.
</li>
	<li>
%~scroll~promise ~LET `新たな~promise$
◎
Let scrollPromise be a new Promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
</p>
		<ol>
			<li>
［
%~scroll~promise~1, %~scroll~promise~2
］が どちらも決着するまで待機する
</li>
			<li>
`~promiseを解決する$( %~scroll~promise )
</li>
		</ol>
◎
↓ Return scrollPromise,＼
and run the remaining steps in parallel.
◎
Resolve scrollPromise when both scrollPromise1 and scrollPromise2 have settled.
</li>
	<li>
~RET %~scroll~promise
◎
↑</li>
</ol>
</div>

<p class="note">注記：
概念的には、
`視覚-表示域$は，`~layout表示域$の辺に “ぶつかる” 所まで~scrollされ、
そこから［
~layout表示域に~scroll差分を適用する
］ことにより，~layout表示域を “押し出す” 。
しかしながら，上の手続きにおける~scrollは、［
~layout表示域が視覚-表示域より前に~scrollされる
］よう，事前に算出され，逆順に適用される。
これは、
歴史的な理由により，
~scroll~eventの一貫した順序付けを確保するために行われる。
視覚的な図画化は、
`上の例＠#example-vvanimation$を見よ。
◎
Note: Conceptually, the visual viewport is scrolled until it "bumps up" against the layout viewport edge and then "pushes" the layout viewport by applying the scroll delta to the layout viewport. However, the scrolls in the steps above are computed ahead of time and applied in the opposite order so that the layout viewport is scrolled before the visual viewport. This is done for historical reasons to ensure consistent scroll event ordering. See the example above for a visual depiction.
</p>

<div class="example">
<p>
利用者は［
文書のある箇所を~pinch~zoomして，そこで~mouse~wheelを回す
］ことで［
文書を `50px^v 下へ~scrollする
］よう~UAに要請しているが，［
文書は~pinch~zoomされたので、
`視覚-表示域$は `20px^v までしか~scrollできない
］とする。
~UAは、［
視覚-表示域を `20px^v,
`~layout表示域$を `30px^v
］下へ~scrollするよう分配することになる。
◎
The user pinch-zooms into the document and ticks their mouse wheel, requesting the user agent scroll the document down by 50px. Because the document is pinch-zoomed in, the visual viewport has 20px of room to scroll. The user agent distributes the scroll by scrolling the visual viewport down by 20px and the layout viewport by 30px.
</p>
</div>

<div class="example">
<p>
携帯機~UAの利用者が，文書~内の~screen外にある~text入力~要素を~focusした結果、
~virtual~keyboardが示され，`視覚-表示域$が縮短されたとする。
~UAは、
当の要素が視覚-表示域に入るよう，要素を~viewの中へ持ち込む必要がある。
~UAは、［
要素が~viewの中で可視になるよう，`~layout表示域$を~scrollして
］から［
要素が利用者に可視になるよう，視覚-表示域を~scrollする
］ことになる。
◎
The user is viewing a document in a mobile user agent. The document focuses an offscreen text input element, showing a virtual keyboard which shrinks the visual viewport. The user agent must now bring the element into view in the visual viewport. The user agent scrolls the layout viewport so that the element is visible within it, then the visual viewport so that the element is visible to the user.
</p>
</div>

<p>
~scrollが
`完了-@
したとされるのは、
~AND↓ が満たされる時点である：
◎
Scroll is completed when＼
</p>
<ul>
	<li>
<p>
処理待ちな［
~scroll位置の［
更新／並進
］］は無くなった。
◎
the scroll position has no more pending updates or translations and＼
↓ the user has completed their gesture.＼
</p>

<p>
そのような更新には、
次に挙げるものにより~scrollするときが含まれる
— `滑らかに~scrollする$か`瞬時に~scrollする$†かを問わず【！smooth or instant …】
⇒＃
~mouse~wheel／
~keyboard／
~scroll留め~event【`参照＠~CSSSCROLLSNAP2#snap-events$】／
~scroll位置を［更新する, あるいは場合によっては補間する］原因になる，他の~APIや~gesture
◎
Scroll position updates include smooth or instant mouse wheel scrolling, keyboard scrolling, scroll-snap events, or other APIs and gestures which cause the scroll position to update and possibly interpolate.＼
</p>

<p class="trans-note">【†
瞬時に~scrollすることは，
（意味論的には）同期的な処理nに見える（`完了-$の定義には不要に見える）が、
~UAが`描画を更新する＠~WAPI#update-the-rendering$ときまでは， “処理待ち” になる
（対して，滑らかに~scrollするときは、
完了するまで，この段を複数回~経ることになる）。
】</p>
	</li>
	<li>
利用者による~gestureは完了した。
［
~touchにより~panする／~trackpadにより~scrollする
］様な~gestureは、
~pointerや~UIkeyが解放されるまでは完了しないとする。
◎
↑
◎
User gestures like touch panning or trackpad scrolling aren’t complete until pointers or keys have released.
</li>
</ul>

<div class="algo">
<p>
`~scrollされる~box$ %~box を %目的位置 へ
`滑らかに~scrollする@
~algoは：
</p>

<ul>
	<li>
~UAが定義する~~速度, ~~動きにより， %~box の~scroll位置を更新するモノトスル。
</li>
	<li>
~scrollの
`完了-@sS
時には、
%~box の~scroll位置は %目的位置 になるモノトスル。
</li>
	<li>
この~scrollは、
~algoまたは利用者により
`中止-@sS
され得る。
</li>
</ul>
◎
When a user agent is to perform a smooth scroll of a scrolling box box to position, it must update the scroll position of box in a user-agent-defined fashion over a user-agent-defined amount of time. When the scroll is completed, the scroll position of box must be position. The scroll can also be aborted, either by an algorithm or by the user.
</div>

<div class="algo">
<p>
`~scrollされる~box$ %~box を %目的位置 へ
`瞬時に~scrollする@
~algoは
⇒
%~box の~scroll位置を %目的位置 に更新する
◎
When a user agent is to perform an instant scroll of a scrolling box box to position, it must update the scroll position of box to position.
</p>
</div>

<div class="algo">
<p>
`文書の先頭へ~scrollする@
~algoは、
所与の
( 文書 %文書 )
に対し：
◎
To scroll to the beginning of the document for a document document, follow these steps:
</p>

<ol>
	<li>
%表示域 ~LET %文書 に結付けられた`表示域$
◎
Let viewport be the viewport that is associated with document.
</li>
	<li>
%目的位置 ~LET ［
%表示域 の`開始辺$が`~scrollされる区画$の`開始辺$に整列された
］とするときの，
%表示域 の~scroll位置
◎
Let position be the scroll position viewport would have by aligning the beginning edges of the scrolling area with the beginning edges of viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の~scroll位置
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET
◎
If position is the same as viewport’s current scroll position, and viewport does not have an ongoing smooth scroll, abort these steps.
</li>
	<li>
`表示域の~scrollを遂行する$( %表示域, %目的位置 【！, document’s root element】 )
◎
Perform a scroll of viewport to position, and document’s root element as the associated element, if there is one, or null otherwise.
</li>
</ol>

<p class="note">注記：
この~algoは、
`HTML$r に定義されるとおり，
素片~識別子 `#top^c へ`~navigateする＠~HTMLnav#navigate-fragid$ときに利用される。
【すなわち，文書~内の`指示された部位＠~HTMLnav#the-indicated-part-of-the-document$は、文書の上端になる。】
◎
Note: This algorithm is used when navigating to the #top fragment identifier, as defined in HTML. [HTML]
</p>
</div>

		</section>
		<section id="webidl-values">
<h3 title="WebIDL values">3.2. ~Web~IDL値</h3>

<div class="algo">
<p>
`有限~値に正規化する@
~algoは、
所与の
( 値 %n )
に対し：
</p>
<ol>
	<li>
~IF［
%n は［
特別な浮動小数点~literal値（ `Infinity^I ／ `-Infinity^c ／ `NaN^I ） `WEBIDL$r
］である
］
⇒
~RET 0
</li>
	<li>
~RET %n
</li>
</ol>
◎
When asked to normalize non-finite values for a value x, if x is one of the three special floating point literal values (Infinity, -Infinity or NaN), then x must be changed to the value 0. [WEBIDL]
</div>

		</section>
	</section>
	<section id="extensions-to-the-window-interface">
<h2 title="Extensions to the Window Interface">4. `Window^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollBehavior@I { `auto@l, `instant@l, `smooth@l };

dictionary `ScrollOptions@I {
  `ScrollBehavior$I `behavior@mb = `auto$l;
};

dictionary `ScrollToOptions@I : `ScrollOptions$I {
  `unrestricted double$ `left@mb;
  `unrestricted double$ `top@mb;
};
</pre>

<pre class="idl">
partial interface `Window$I {`Window^I0
  [`NewObject$] `MediaQueryList$I `matchMedia$m(`CSSOMString$ %query);
  [`SameObject$, `Replaceable$] readonly attribute `Screen$I `screen$m;
  [`SameObject$, `Replaceable$] readonly attribute `VisualViewport$I? `visualViewport$m;

  // <span class="comment">閲覧~文脈</span>
  `undefined$ `moveTo$m(`long$ %x, `long$ %y);
  `undefined$ `moveBy$m(`long$ %x, `long$ %y);
  `undefined$ `resizeTo$m(`long$ %width, `long$ %height);
  `undefined$ `resizeBy$m(`long$ %x, `long$ %y);

  // <span class="comment">表示域</span>
  [`Replaceable$] readonly attribute `long$ `innerWidth$m;
  [`Replaceable$] readonly attribute `long$ `innerHeight$m;

  // <span class="comment">表示域の~scroll法</span>
  [`Replaceable$] readonly attribute `double$ `scrollX$m;
  [`Replaceable$] readonly attribute `double$ `pageXOffset$m;
  [`Replaceable$] readonly attribute `double$ `scrollY$m;
  [`Replaceable$] readonly attribute `double$ `pageYOffset$m;

  `Promise$&lt;`undefined$&gt; `scroll$m(optional `ScrollToOptions$I %options = {});
  `Promise$&lt;`undefined$&gt; `scroll$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `Promise$&lt;`undefined$&gt; `scrollTo$m(optional `ScrollToOptions$I %options = {});
  `Promise$&lt;`undefined$&gt; `scrollTo$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `Promise$&lt;`undefined$&gt; `scrollBy$m(optional `ScrollToOptions$I %options = {});
  `Promise$&lt;`undefined$&gt; `scrollBy$m(`unrestricted double$ %x, `unrestricted double$ %y);

  // <span class="comment">~client~UIwindow</span>
  [`Replaceable$] readonly attribute `long$ `screenX$m;
  [`Replaceable$] readonly attribute `long$ `screenLeft$m;
  [`Replaceable$] readonly attribute `long$ `screenY$m;
  [`Replaceable$] readonly attribute `long$ `screenTop$m;
  [`Replaceable$] readonly attribute `long$ `outerWidth$m;
  [`Replaceable$] readonly attribute `long$ `outerHeight$m;
  [`Replaceable$] readonly attribute `double$ `devicePixelRatio$m;
};
</pre>

`Window^dgm

<p class="issue">
上の各種~scroll~methodは、
結果~objを返すべきか？
そうする場合、
それは何の情報を供するべきか？
[`12495$issue]
◎
Should the scroll methods above return a result object and if so what information should they provide? #12495
</p>

<div class="algo">
`matchMedia(query)@m
~method手続きは
⇒
~RET 次のように設定された，新たな `MediaQueryList$I ~obj
⇒＃
`媒体~query~list$mq ~SET `媒体~query~listとして構文解析する$( %query ),
`文書$mq ~SET コレに`結付けられた文書$
◎
When the matchMedia(query) method is invoked these steps must be run:
◎
Let parsed media query list be the result of parsing query.
◎
Return a new MediaQueryList object, with this’s associated Document as the document, with parsed media query list as its associated media query list.
</div>

<div class="algo">
<p>
`screen@m
取得子~手続きは
⇒
~RET コレに結付けられた `Screen$I ~obj
◎
The screen attribute must return the Screen object associated with the Window object.
</p>

<p class="note">注記：
`WindowProxy$I ~objを通した `screen^c への~accessでは、
`文書$が~navigateされたときには，異なる結果が得られ得る。
◎
Note: Accessing screen through a WindowProxy object might yield different results when the Document is navigated.
</p>
</div>

<div class="algo">
<div>
<p>
`visualViewport@m
取得子~手続きは：
</p>
<ol>
	<li>
%文書 ~LET コレに`結付けられた文書$
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 を結付けている `VisualViewport$I ~obj
</li>
</ol>

◎
If the associated document is fully active, the visualViewport attribute must return the VisualViewport object associated with the Window object’s associated document. Otherwise, it must return null.
</div>

<p class="note">注記：
`VisualViewport$I ~objが［
返される／有用になる
］のは、
%文書 が現在~呈示されている【`全部的に作動中$である】間に限られる。
`VisualViewport^I ~objへの参照が【~scriptにより】維持されていても、
%文書 は現在~呈示されていない場合，
この~obj内の値【各~member】は当の閲覧~文脈についての情報を露呈しないモノトスル
【この要件の詳細は、 `VisualViewport^I の各~member定義を見よ】。
◎
Note: the VisualViewport object is only returned and useful for a window whose Document is currently being presented. If a reference is retained to a VisualViewport whose associated Document is not being currently presented, the values in that VisualViewport must not reveal any information about the browsing context.
</p>
</div>

<div class="algo">
<p>
`moveTo(x, y)@m
~method手続きは：
◎
The moveTo(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this’s relevant global object’s browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
任意選択で
⇒
~UA定義な方式で，［
%x, %y
］を次を満たすよう切詰める
⇒
%~UIwindow が可用な空間の外側に出ない大きさになる
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
	<li>
%~UIwindow を次を満たすよう移動する
⇒
%~UIwindow の左上隅が［
出力~機器の左上隅から相対的な［
%target の `px$u 単位による座標 (%x, %y) 
］に整列する
— ここで，各~座標軸の正方向は［
右方, 下方
］とする。
◎
Move target’s window such that the window’s top left corner is at coordinates (x, y) relative to the top left corner of the output device, measured in CSS pixels of target. The positive axes are rightward and downward. 
</li>
</ol>
</div>

<div class="algo">
<p>
`moveBy(x, y)@m
~method手続きは：
◎
The moveBy(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this’s relevant global object’s browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
任意選択で
⇒
~UA定義な方式で，［
%x, %y
］を次を満たすよう切詰める
⇒
%~UIwindow が可用な空間の外側に出ない大きさになる
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not move outside the available space.
</li>
	<li>
%~UIwindow を
%target の `px$u 単位で［
右方へ %x, 下方へ %y
］だけ移動する
◎
Move target’s window x CSS pixels of target rightward and y CSS pixels of target downward.
</li>
</ol>
</div>

<div class="algo">
<p>
`resizeTo(width, height)@m
~method手続きは：
◎
The resizeTo(width, height) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this’s relevant global object’s browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
任意選択で
⇒
~UA定義な方式で，［
%width, %height
］を次を満たすよう切詰める
⇒
%~UIwindow の大きさが可用な空間の中で~~適度な［
上限, 下限
］に収まる
◎
Optionally, clamp width and height in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
	<li>
<p>
%~UIwindow の［
右辺, 下辺
］を ~AND↓ を満たすよう移動することにより，
%~UIwindow を~resizeする：
</p>
		<ul>
			<li>
%target における `px$u 単位による［
表示域の左辺と右辺の距離
］ ~EQ %width
</li>
			<li>
%target における `px$u 単位による［
表示域の上辺と下辺の距離
］ ~EQ %height
</li>
		</ul>
◎
Resize target’s window by moving its right and bottom edges such that the distance between the left and right edges of the viewport are width CSS pixels of target and the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
	<li>
任意選択で
⇒
~UA定義な方式で，
%~UIwindow を次を満たすよう移動する
⇒
可用な空間をはみ出さない
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
</ol>
</div>

<div class="algo">
<p>
`resizeBy(x, y)@m
~method手続きは：
◎
The resizeBy(x, y) method must follow these steps:
</p>
<ol>
	<li>
任意選択で
⇒
~RET
◎
Optionally, return.
</li>
	<li>
%target ~LET コレに`関連な大域~obj$に`対応する閲覧~文脈$
◎
Let target be this’s relevant global object’s browsing context.
</li>
	<li>
~IF［
%target は［
（利用者による動作ではなく）~scriptにより作成された`補助~閲覧~文脈$
］ではない
］
⇒
~RET
◎
If target is not an auxiliary browsing context that was created by a script (as opposed to by an action of the user), then return.
</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
任意選択で
⇒
~UA定義な方式で，［
%x, %y
］を次を満たすよう切詰める
⇒
%~UIwindow の大きさが可用な空間の中で~~適度な［
上限, 下限
］に収まる
◎
Optionally, clamp x and y in a user-agent-defined manner so that the window does not get too small or bigger than the available space.
</li>
	<li>
%~UIwindow の右辺と下辺を %target の `px$u 単位で［
左辺を %x,
上辺を %y
］だけ移動することにより，
%~UIwindow を~resizeする
◎
Resize target’s window by moving its right edge x CSS pixels of target rightward and its bottom edge y CSS pixels of target downward.
</li>
	<li>
任意選択で
⇒
~UA定義な方式で，
%~UIwindow を次を満たすよう移動する
⇒
可用な空間をはみ出さない
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the available space.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`innerWidth@m ｜ `innerHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`表示域$の［
横幅 ｜ 縦幅
］（~scrollbarが描画されている場合はその~sizeも含める）
</li>
</ol>

<div class="example">
<p>
次の~code片は、
表示域の横幅を得する方法を示す：
</p>

<pre class="lang-js">
var %viewportWidth = innerWidth
</pre>
</div>

◎
The innerWidth attribute must return the viewport width including the size of a rendered scroll bar (if any), or zero if there is no viewport.
◎
The following snippet shows how to obtain the width of the viewport:
• var viewportWidth = innerWidth
◎
The innerHeight attribute must return the viewport height including the size of a rendered scroll bar (if any), or zero if there is no viewport.
</div>

<div class="algo">
<p>
［
`scrollX@m ｜ `scrollY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
	<li>
~RET
`初期~包含塊$の原点に相対的な，`表示域$の［
左端の~x座標 ｜ 上端の~y座標
］
</li>
</ol>
◎
The scrollX attribute must return the x-coordinate, relative to the initial containing block origin, of the left of the viewport, or zero if there is no viewport.
◎
The pageXOffset attribute must return the value returned by the scrollX attribute.
◎
The scrollY attribute must return the y-coordinate, relative to the initial containing block origin, of the top of the viewport, or zero if there is no viewport.
◎
The pageYOffset attribute must return the value returned by the scrollY attribute.
</div>

<div class="algo">
［
`pageXOffset@m ｜ `pageYOffset@m
］取得子~手続きは、［
`scrollX$m ｜ `scrollY$m
］取得子~手続きと同じに挙動する。
◎
↑</div>

<div class="algo">
<p>
`scroll()@m
~method手続きは：
</p>
<ol>
	<li>
<p>
« %x, %y, %挙動 » ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
« %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] »
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
« %x, %y, `auto$l »
</li>
		</ul>
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x )
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y )
</li>
	<li>
~RET `~window用の~scroll手続き$( コレ, %x, %y, %挙動 )
</li>
</ol>
◎
When the scroll() method is invoked these steps must be run:
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Let x be the value of the left dictionary member of options, if present, or the viewport’s current scroll position on the x axis otherwise.
• Let y be the value of the top dictionary member of options, if present, or the viewport’s current scroll position on the y axis otherwise.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
◎
Normalize non-finite values for x and y.
◎
↓
</div>

<div class="algo">
<p class="trans-note">【
この訳では、
原文による `scroll()$m ~method手続きを成す引数の取扱い以外の部分を，
次に与える手続きに分離する
— それは、
複数の箇所から共通して利用されるので。
】</p>

<p>
`~window用の~scroll手続き@
は、
所与の
( %window, %x, %y, %挙動 )
に対し：
◎
↑</p>
<ol>
	<li>
~IF［
%window の`表示域$は無い
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If there is no viewport, return a resolved Promise and abort the remaining steps.
</li>
	<li>
%表示域 ~LET %window の`表示域$
</li>
	<li class="algo">
<p>
%座標 ~LET 次の手続きを走らせた結果：
</p>
		<ol>
			<li>
~IF［
%x ~EQ ε
］
⇒
%x ~SET `表示域$の現在の~x軸 ~scroll位置
</li>
			<li>
~IF［
%y ~EQ ε
］
⇒
%y ~SET `表示域$の現在の~y軸 ~scroll位置
</li>
			<li>
%~scrollされる区画 ~LET %表示域 の`~scrollされる区画$
</li>
			<li>
%符号 ~LET %表示域 の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
</li>
			<li>
%x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %x, ( %~scrollされる区画 の横幅 ~MINUS %表示域 の`実効~横幅$ )))
</li>
			<li>
%符号 ~LET %表示域 の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
</li>
			<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, ( %~scrollされる区画 の縦幅 ~MINUS %表示域 の`実効~縦幅$ )))
</li>
			<li>
~RET ( %x, %y )
</li>
		</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any.
◎
Let viewport height be the height of the viewport excluding the height of the scroll bar, if any.
◎
If the viewport has rightward overflow direction
• Let x be max(0, min(x, viewport scrolling area width - viewport width)).
◎
If the viewport has leftward overflow direction
• Let x be min(0, max(x, viewport width - viewport scrolling area width)).
◎
If the viewport has downward overflow direction
• Let y be max(0, min(y, viewport scrolling area height - viewport height)).
◎
If the viewport has upward overflow direction
• Let y be min(0, max(y, viewport height - viewport scrolling area height)).
</li>
	<li>
%目的位置 ~LET ［
%~scrollされる区画 の座標 %座標 が %表示域 の左上隅に整列された
］とするときの，
%表示域 の~scroll位置
◎
Let position be the scroll position the viewport would have by aligning the x-coordinate x of the viewport scrolling area with the left of the viewport and aligning the y-coordinate y of the viewport scrolling area with the top of the viewport.
</li>
	<li>
~IF［
%目的位置 ~EQ %表示域 の現在の~scroll位置
］~AND［
%表示域 において`滑らかな~scroll$は進行中でない
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If position is the same as the viewport’s current scroll position, and the viewport does not have an ongoing smooth scroll, return a resolved Promise and abort the remaining steps.
</li>
	<li>
<p>
~RET `表示域の~scrollを遂行する$( %表示域, %目的位置 【！, document】, %挙動 )
◎
（不要）Let document be the viewport’s associated Document.
◎
Perform a scroll of the viewport to position, document’s root element as the associated element, if there is one, or null otherwise, and the scroll behavior being the value of the behavior dictionary member of options. Let scrollPromise be the Promise returned from this step.
◎
Return scrollPromise.
</p>

<p class="issue">
各~UAは、
これが［
`~layout表示域$の`~scrollされる~box$に対し，次のどちらを利用する
］か合意していない
⇒
`表示域$に対する（協調された）`表示域の~scrollを遂行する$／
`~scrollされる~box$に対し`~scrollを遂行する$
◎
User agents do not agree whether this uses the (coordinated) viewport perform a scroll or the scrolling box perform a scroll on the layout viewport’s scrolling box.
</p>
	</li>
</ol>
</div>

<div class="algo">
`scrollTo()@m
~method手続きは、
`scroll()$m ~method手続きと同じに挙動する。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</div>

<div class="algo">
<p>
`scrollBy()@m
~method手続きは：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
<ol>
	<li>
<p>
« %x, %y, %挙動 » ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
« %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] »
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
« %x, %y, `auto$l »
</li>
		</ul>
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x ) ~PLUS コレの `scrollX$m 取得子~手続き()
◎
Normalize non-finite values for the left and top dictionary members of options.
◎
Add the value of scrollX to the left dictionary member.
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y ) ~PLUS コレの `scrollY$m 取得子~手続き()
◎
↑
◎
Add the value of scrollY to the top dictionary member.
</li>
	<li>
~RET `~window用の~scroll手続き$( コレ, %x, %y, %挙動 )
◎
Return the Promise returned from scroll() after the method is invoked with options as the only argument.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`screenX@m ｜ `screenY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
	<li>
~RET
出力~機器の`~Webに公開される~screen区画$の原点に相対的な,  `px$u 単位による，~client~UIwindow†の［
左端の~x座標 ｜ 上端の~y座標
］
</li>
</ol>

<p class="trans-note">【†
“~client~UIwindow” がどの部分を指すのか，定義されていないが、
現実の~browserのふるまいからは，外枠も含めた~UIwindow全体が占める区画を指すものと推定される。
】</p>

◎
The screenX and screenLeft attributes must return the x-coordinate, relative to the origin of the Web-exposed screen area, of the left of the client window as number of CSS pixels, or zero if there is no such thing.
◎
The screenY and screenTop attributes must return the y-coordinate, relative to the origin of the screen of the Web-exposed screen area, of the top of the client window as number of CSS pixels, or zero if there is no such thing.
</div>

<div class="algo">
［
`screenLeft@m ｜ `screenTop@m
］取得子~手続きは、［
`screenX$m ｜ `screenY$m
］取得子~手続きと同じに挙動する。
◎
↑</div>

<div class="algo">
<p>
［
`outerWidth@m ｜ `outerHeight@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの~client~UIwindowは無い
］
⇒
~RET 0
</li>
	<li>
~RET ~client~UIwindowの［
横幅 ｜ 縦幅
］
</li>
</ol>
◎
The outerWidth attribute must return the width of the client window. If there is no client window this attribute must return zero.
◎
The outerHeight attribute must return the height of the client window. If there is no client window this attribute must return zero.
</div>

<div class="algo">
`devicePixelRatio@m
取得子~手続きは
⇒
~RET `機器~pixel比を決定する$()
◎
The devicePixelRatio attribute must return the result of＼
</div>

<div class="algo">
<p>
`機器~pixel比を決定する@
~algoは：
◎
the following determine the device pixel ratio algorithm:
</p>
<ol>
	<li>
~IF［
出力~機器は無い
］
⇒
~RET 1
◎
If there is no output device, return 1 and abort these steps.
</li>
	<li>
%~CSS~pixel~size ~LET 1 `px$u の~size
— 現在の`~page~zoom$の下で，`拡縮率$vV 1.0 を利用している下での
◎
Let CSS pixel size be the size of a CSS pixel at the current page zoom and using a scale factor of 1.0.
</li>
	<li>
%機器~pixel~size ~LET 出力~機器の機器~pixelの縦~size
◎
Let device pixel size be the vertical size of a device pixel of the output device.
</li>
	<li>
~RET %~CSS~pixel~size ~DIV %機器~pixel~size
◎
Return the result of dividing CSS pixel size by device pixel size.
</li>
</ol>
</div>

		<section id="the-features-argument-to-the-open()-method">
<h3 title="The features argument to the open() method">4.1. `open()^m ~methodに対する %features 引数</h3>

<p>
~HTMLは、
~windowの `open()$m ~method
【および，文書の `~doc-open()$m ~method】
を定義している。
この節では、
その %features 引数にて与えられる位置と~sizeの挙動を定義する。
`HTML$r
◎
HTML defines the open() method. This section defines behavior for position and size given in the features argument. [HTML]
</p>

<div class="algo">
<p>
`閲覧~文脈の特能を設定しておく@
~algoは、
所与の
(
`閲覧~文脈$ %target,
（ %features 引数から導出された）`~map$ %特能~map
)
に対し：
◎
To set up browsing context features for a browsing context target given a map tokenizedFeatures:
</p>

<ol>
	<li>
%~pixel単位 ~LET %target における `px$u 単位
◎
↓</li>
	<li>
%~UIwindow ~LET %target の~UIwindow
◎
↓</li>
	<li>
%可用な~screen ~LET `~Webに公開される可用な~screen区画$
◎
↓</li>
	<li>
%~screen ~LET `~Webに公開される~screen区画$
◎
↓</li>
	<li>
%正規化-済み~list ~LET « »
◎
↓</li>
	<li>
<p>
« `left$opf, `top$opf, `width$opf, `height$opf »
を成す
~EACH( %~key )
に対し：
</p>
		<ol>
			<li>
%値 ~LET %特能~map[ %~key ]
</li>
			<li>
~IF［
%値 ~NEQ ε
］
⇒
%値 ~SET `整数として構文解析する$( %値 )
</li>
			<li>
%値 ~SET %値 に応じて
⇒＃
ε ならば ~NULL ／
`失敗^i ならば 0 ／
~ELSE_ %値
</li>
			<li>
%正規化-済み~list に %値 を`付加する$
</li>
		</ol>
◎
↓</li>
	<li>
« %左端, %上端, %横幅, %縦幅 » ~SET %正規化-済み~list
◎
Let x be null.
◎
Let y be null.
◎
Let width be null.
◎
Let height be null.
</li>
	<li>
<p>
~IF［
%左端 ~NEQ ~NULL
］：
◎
If tokenizedFeatures["left"] exists:
• Set x to the result of invoking the rules for parsing integers on tokenizedFeatures["left"].
• If x is an error, set x to 0.
</p>
		<ol>
			<li>
任意選択で
⇒
~UA定義な方式で， %左端 を次を満たすよう切詰める
⇒
%可用な~screen の外側に %~UIwindow が出ない大きさになる
◎
Optionally, clamp x in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
%~UIwindow を次を満たすよう移動する
⇒
%~pixel単位 による［
%~screen の左辺に相対的な %~UIwindow の左辺の~x座標
］ ~EQ %左端
◎
Optionally, move target’s window such that the window’s left edge is at the horizontal coordinate x relative to the left edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is rightward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%上端 ~NEQ ~NULL
］：
◎
If tokenizedFeatures["top"] exists:
• Set y to the result of invoking the rules for parsing integers on tokenizedFeatures["top"].
• If y is an error, set y to 0.
</p>
		<ol>
			<li>
任意選択で
⇒
~UA定義な方式で，
%上端 を次を満たすよう切詰める
⇒
%可用な~screen の外側に %~UIwindow が出ない大きさになる
◎
Optionally, clamp y in a user-agent-defined manner so that the window does not move outside the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
%~UIwindow を次を満たすよう移動する
⇒
%~pixel単位 による［
%~screen の上辺に相対的な %~UIwindow の上辺の~y座標
］ ~EQ %上端
◎
Optionally, move target’s window such that the window’s top edge is at the vertical coordinate y relative to the top edge of the Web-exposed screen area, measured in CSS pixels of target. The positive axis is downward.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%横幅 ~NIN { ~NULL, 0 }
］：
◎
If tokenizedFeatures["width"] exists:
• Set width to the result of invoking the rules for parsing integers on tokenizedFeatures["width"].
• If width is an error, set width to 0.
• If width is not 0:
</p>
		<ol>
			<li>
任意選択で
⇒
~UA定義な方式で，
%横幅 を次を満たすよう切詰める
⇒
%可用な~screen の中で %~UIwindow の大きさが~~適度な［
上限, 下限
］に収まる
◎
Optionally, clamp width in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
%~UIwindow の右辺を次を満たすよう移動することにより，
%~UIwindow を~resizeする
⇒
%~pixel単位 による［
表示域の左辺と右辺の距離
］ ~EQ %横幅
◎
Optionally, size target’s window by moving its right edge such that the distance between the left and right edges of the viewport are width CSS pixels of target.
</li>
			<li>
任意選択で
⇒
~UA定義な方式で，
%~UIwindow を次を満たすよう移動する
⇒
%可用な~screen をはみ出さない
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%縦幅 ~NIN { ~NULL, 0 }
］：
◎
If tokenizedFeatures["height"] exists:
• Set height to the result of invoking the rules for parsing integers on tokenizedFeatures["height"].
• If height is an error, set height to 0.
• If height is not 0:
</p>
		<ol>
			<li>
任意選択で
⇒
~UA定義な方式で，
%縦幅 を次を満たすよう切詰める
⇒
%可用な~screen の中で %~UIwindow の大きさが~~適度な［
上限, 下限
］に収まる
◎
Optionally, clamp height in a user-agent-defined manner so that the window does not get too small or bigger than the Web-exposed available screen area.
</li>
			<li>
任意選択で
⇒
%~UIwindow の下辺を次を満たすよう移動することにより，
%~UIwindow を~resizeする
⇒
%~pixel単位 による［
表示域の上辺と下辺の距離
］ ~EQ %縦幅
◎
Optionally, size target’s window by moving its bottom edge such that the distance between the top and bottom edges of the viewport are height CSS pixels of target.
</li>
			<li>
任意選択で
⇒
~UA定義な方式で，
%~UIwindow を次を満たすよう移動する
⇒
%可用な~screen をはみ出さない
◎
Optionally, move target’s window in a user-agent-defined manner so that it does not grow outside the Web-exposed available screen area.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
次に挙げるものが
`~supportされる~open_m特能~名@
である：
◎
A supported open() feature name is one of the following:
</p>

<dl>
	<dt>`width@opf</dt>
	<dd>
表示域の横幅
◎
The width of the viewport.
</dd>

	<dt>`height@opf</dt>
	<dd>
表示域の縦幅
◎
The height of the viewport.
</dd>

	<dt>`left@opf</dt>
	<dd>
~UIwindowの左端の位置
◎
The left position of the window.
</dd>

	<dt>`top@opf</dt>
	<dd>
~UIwindowの上端の位置
◎
The top position of the window.
</dd>

</dl>

		</section>
		<section id="the-mediaquerylist-interface">
<h3 title="The MediaQueryList Interface">4.2. `MediaQueryList^I ~interface</h3>

<p>
この節は、
`HTML$r に定義される`描画を更新する手続き$【！`~event~loop$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
`MediaQueryList$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>
`媒体~query~list@mq
◎
A MediaQueryList object has an associated media query list＼
</dt>
	<dt>
`文書@mq
◎
and an associated document＼
</dt>
	<dd>
作成-時に設定される。
◎
set on creation.
</dd>

	<dt>
`媒体@mq
◎
A MediaQueryList object has an associated media＼
</dt>
	<dd>
`直列化-＠~CSSOM1#serialize-a-media-query-list$された形による，`媒体~query~list$mq。
◎
which is the serialized form of the associated media query list.
</dd>

	<dt>
`合致-状態@mq
◎
A MediaQueryList object has an associated matches state＼
</dt>
	<dd>
結付けられた`媒体~query~list$mqが［
`文書$mqの状態に合致するときは ~T ／
~ELSE_ ~F
］を返す。
◎
which is true if the associated media query list matches the state of the document, and false otherwise.
</dd>
</dl>

<div class="algo">
<p>
`文書~用の媒体~queryを評価して変化を報告する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
When asked to evaluate media queries and report changes for a Document doc, run these steps:
</p>

<ol>
	<li>
<p>
~EACH( `MediaQueryList$I ~obj %~target )
に対し，先に作成されたものから順に：
</p>
		<ol>
			<li>
~IF［
%~target の`文書$mq ~NEQ %文書
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%~target の`合致-状態$mqは、
この手続きを前回~走らせたときから変化していない
］
⇒
~CONTINUE
</li>
			<li>
`~eventを発火する$( %~target, `change$et, `MediaQueryList$I )
— 次のように初期化して
⇒＃
`isTrusted$m 属性 ~SET ~T,
`media$m1 属性 ~SET %~target の`媒体$mq,
`matches$m1 属性 ~SET %~target の`合致-状態$mq
【！fingerprint】
</li>
		</ol>
◎
For each MediaQueryList object target that has doc as its document, in the order they were created, oldest first, run these substeps:
• If target’s matches state has changed since the last time these steps were run, fire an event named change at target using MediaQueryListEvent, with its isTrusted attribute initialized to true, its media attribute initialized to target’s media, and its matches attribute initialized to target’s matches state.
</li>
</ol>
</div>

<div class="example">
<p>
`表示域$の方位（ `orientation^en ）の変化を検出する単純な~code片は、
次のように書かれるであろう：
◎
A simple piece of code that detects changes in the orientation of the viewport can be written as follows:
</p>

<pre class="lang-js">
function handleOrientationChange(%event) {
  if(%event.`matches$m) // landscape
    …
  else
    …
}
var %mql = `matchMedia＠#dom-window-matchmedia$m(`(orientation:landscape)^l);
%mql.`onchange$m = handleOrientationChange;
</pre>

</div>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryList@I : `EventTarget$I {
  readonly attribute `CSSOMString$ `media$m;
  readonly attribute `boolean$ `matches$m;
  `undefined$ `addListener$m(`EventListener$I? %callback);
  `undefined$ `removeListener$m(`EventListener$I? %callback);
           attribute `EventHandler$I `onchange$m;
};
</pre>

<div class="algo">
`media@m
取得子~手続きは
⇒
~RET コレに結付けられた`媒体$mq
◎
The media attribute must return the associated media.
</div>

<div class="algo">
`matches@m
取得子~手続きは
⇒
~RET コレに結付けられた`合致-状態$mq
【！fingerprint】
◎
The matches attribute must return the associated matches state.
</div>

<div class="algo">
<p>
`addListener(callback)@m
~method手続きは：
</p>
<ol>
	<li>
%~listener ~LET 新たな`~event~listener$
— その
⇒＃
`型$evL ~SET `change$et,
`~callback$evL ~SET %callback
</li>
	<li>
`~event~listenerを追加する$( コレ, %~listener )
</li>
</ol>

◎
The addListener(callback) method, when invoked, must run these steps:
• Add an event listener with this and an event listener whose type is change, and callback is callback.
</div>

<div class="algo">
<p>
`removeListener(callback)@m
~method手続きは：
◎
The removeListener(callback) method, when invoked, must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`~event~listener~list$内に［
( `型$evL, `~callback$evL, `捕捉するか$evL )
~EQ ( `change$et, %callback, ~F )
］を満たす`~event~listener$がある
］
⇒
`~event~listenerを除去する$( コレ, その~event~listener )
◎
If this’s event listener list contains an event listener whose type is change, callback is callback, and capture is false, then remove an event listener with this and that event listener.
</li>
</ol>
</div>

<p class="note">注記：
この仕様は、
当初は，［
`addListener()$m ／ `removeListener()$m
］による~custom~callbackの仕組みを利用していた
— その~callbackは、
結付けられた`媒体~query~list$mqを引数に呼出されていた。
今や、
通常の~eventの仕組みが代わりに利用される。
後方-互換性を得るため、［
`addListener()$m ／ `removeListener()$m
］~methodは基本的に［
`addEventListener()$m ／ `removeEventListener()$m
］の別名になり，
`change$et ~eventが `MediaQueryList$I のふりをする。
◎
Note: This specification initially had a custom callback mechanism with addListener() and removeListener(), and the callback was invoked with the associated media query list as argument. Now the normal event mechanism is used instead. For backwards compatibility, the addListener() and removeListener() methods are basically aliases for addEventListener() and removeEventListener(), respectively, and the change event masquerades as a MediaQueryList.
</p>

<p>
`MediaQueryList$I ~interfaceを実装する~objは、
`onchange@m
`~event~handler$（および，対応する`~event~handler~event型$ `change$et ）を，`~event~handler~IDL属性$として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MediaQueryList interface:
◎
Event handler｜Event handler event type
onchange｜change
</p>

<pre class="idl">
[`Exposed$=Window]
interface `MediaQueryListEvent@I : `Event$I {
  `MediaQueryListEvent@mc(`CSSOMString$ %type, optional `MediaQueryListEventInit$I %eventInitDict = {});

  readonly attribute `CSSOMString$ `media$m;
  readonly attribute `boolean$ `matches$m;
};

dictionary `MediaQueryListEventInit@I : `EventInit$I {
  `CSSOMString$ `media@mb = "";
  `boolean$ `matches@mb = false;
};
</pre>

`MediaQueryListEvent^I0

<div class="algo">
`media@m
取得子~手続きは、
初期化-時の値を返す。
◎
The media attribute must return the value it was initialized to.
</div>

<div class="algo">
`matches@m
取得子~手続きは、
初期化-時の値を返す。
◎
The matches attribute must return the value it was initialized to.
</div>

			<section id="mediaquerylist-event-summary">
<h4 title="Event summary">4.2.1. ~event要約</h4>

◎非規範的

<div>
<table><thead>
<tr><th>~event
<th>~interface
<th>~target
<th>記述
<tbody>

<tr><td>`change@et
<td>`MediaQueryListEvent$I
<td>`MediaQueryList$I
<td>
`合致-状態$mqが変化したとき，
`MediaQueryList$I に向けて発火される。
</table>

◎
Event｜Interface｜Interesting targets｜Description
change｜MediaQueryListEvent｜MediaQueryList｜Fired at the MediaQueryList when the matches state changes.
</div>

			</section>
		</section>
		<section id="the-screen-interface">
<h3 title="The Screen Interface">4.3. `Screen^I ~interface</h3>

<p>
その名前が示唆するとおり、
`Screen$I ~interfaceは，出力~機器の~screenについての情報を表現する。
◎
As its name suggests, the Screen interface represents information about the screen of the output device.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `Screen@I {
  readonly attribute `long$ `availWidth$m;
  readonly attribute `long$ `availHeight$m;
  readonly attribute `long$ `width$m;
  readonly attribute `long$ `height$m;
  readonly attribute `unsigned long$ `colorDepth$m;
  readonly attribute `unsigned long$ `pixelDepth$m;
};
</pre>

`Screen^dgm

<div class="algo">
［
`availWidth@m ｜ `availHeight@m
］取得子~手続きは
⇒
~RET `~Webに公開される可用な~screen区画$の［
横幅 ｜ 縦幅
］
◎
The availWidth attribute must return the width of the Web-exposed available screen area.
◎
The availHeight attribute must return the height of the Web-exposed available screen area.
</div>

<div class="algo">
［
`width@m ｜ `height@m
］取得子~手続きは
⇒
~RET `~Webに公開される~screen区画$の［
横幅 ｜ 縦幅
］
◎
The width attribute must return the width of the Web-exposed screen area.
◎
The height attribute must return the height of the Web-exposed screen area.
</div>

<p>
［
`colorDepth@m
／
`pixelDepth@m
］属性の取得子は、
いずれも：
◎
The colorDepth and pixelDepth attributes＼
</p>
<ul>
	<li>
出力~機器における~pixelの色に割振られている~bit数を
— その~alpha~channelは除外して —
返すベキである。
~UAがこの~bit数を知り得ない場合は、
自身による最も近い見積もりを返すベキである
— 例えば、
出力~機器が利用する値に最も近くなるような，［
機器に送り込まれる~frame~buffer, または何らかの内部~表現
］に利用されている~bit数など。
◎
should return the number of bits allocated to colors for a pixel in the output device, excluding the alpha channel. If the user agent is not able to return the number of bits used by the output device, it should return the closest estimation such as, for example, the number of bits used by the frame buffer sent to the display or any internal representation that would be the closest to the value the output device would use.＼
</li>
	<li>
`color$d 媒体~特能の`実~値$の 3 倍~以上の値を返すモノトスル
— ~bit数が色~成分ごとに異なる場合、
返す値は 3 倍を超えてもヨイ。
~UAは、
色~深度を［
知り得ない, または~privacyに配慮するため返したくない
］場合は， 24 を返すベキである。
◎
The user agent must return a value for these attributes at least equal to the value of the color media feature multiplied by three. If the different color components are not represented with the same number of bits, the returned value may be greater than three times the value of the color media feature. If the user agent does not know the color depth or does not want to return it for privacy considerations, it should return 24.
</li>
	<li class="note">注記：
互換性の理由から，両~属性とも同じ値を返す。
◎
Note: The colorDepth and pixelDepth attributes return the same value for compatibility reasons.
</li>
	<li class="note">注記：
一部の不適合な実装は、
24 でなく 32 を返すことが知られている。
◎
Note: Some non-conforming implementations are known to return 32 instead of 24.
</li>
</ul>

		</section>
	</section>
	<section id="extensions-to-the-document-interface">
<h2 title="Extensions to the Document Interface">5. `Document^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Document$I {`Document^I0
  `Element$I? `elementFromPoint$m(`double$ %x, `double$ %y);
  `sequence$&lt;`Element$I&gt; `elementsFromPoint$m(`double$ %x, `double$ %y);
  `CaretPosition$I? `caretPositionFromPoint$m(`double$ %x, `double$ %y, optional `CaretPositionFromPointOptions$I %options = {});
  readonly attribute `Element$I? `scrollingElement$m;
};

dictionary `CaretPositionFromPointOptions@I {
  `sequence$&lt;`ShadowRoot$I&gt; `shadowRoots@m = [];
};
</pre>

`Document^I0
`Document^dgm

<div class="algo">
<p>
`elementFromPoint(x, y)@m
~method手続きは：
◎
The elementFromPoint(x, y) method must follow these steps:
</p>
<ol>
	<li>
~IF［
コレに結付けられた`表示域$は無い
］
⇒
~RET ~NULL
◎
↓</li>
	<li>
<p>
~IF［
~NOT ~AND↓
］…
</p>
		<ul>
			<li>
0 ~LTE %x ~LTE `表示域$の`実効~横幅$
</li>
			<li>
0 ~LTE %y ~LTE `表示域$の`実効~縦幅$
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return null and terminate these steps.
</li>
	<li>
~IF［
`表示域$の子孫に適用される`変形$を適用したとするとき，［
座標 (%x, %y) にて`接触判定$の~targetになる`~box$
］は`表示域$内にある
］
⇒
~RET それを結付けている要素
◎
If there is a box in the viewport that would be a target for hit testing at coordinates x,y, when applying the transforms that apply to the descendants of the viewport, return the associated element and terminate these steps.
</li>
	<li>
~RET コレの`根~要素$
◎
If the document has a root element, return the root element and terminate these steps.
◎
Return null.
</li>
</ol>

<p class="note">注記：
`elementFromPoint()^m ~methodは、
最も手前に塗られている要素を返すとは限らない。
例えば、
要素は， `pointer-events$p ~CSS~propの利用を通して`接触判定$の~targetから除外され得る。
◎
Note: The elementFromPoint() method does not necessarily return the top-most painted element. For instance, an element can be excluded from being a target for hit testing by using the pointer-events CSS property.
</p>

</div>

<div class="algo">
<p>
`elementsFromPoint(x, y)@m
~method手続きは：
◎
The elementsFromPoint(x, y) method must follow these steps:
</p>
<ol>
	<li>
%~list ~LET 新たな~list
◎
Let sequence be a new empty sequence.
</li>
	<li>
<p>
~IF［
コレに結付けられた`表示域$は在る
］~AND［
0 ~LTE %x ~LTE `表示域$の`実効~横幅$
］~AND［
0 ~LTE %y ~LTE `表示域$の`実効~縦幅$
］：
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), or y is greater than the viewport height excluding the size of a rendered scroll bar (if any), or there is no viewport associated with the document, return sequence and terminate these steps.
</p>
		<ol>
			<li>
%~list に次を満たす すべての要素を付加する
— 最~上端な【すなわち，最も手前に塗られる】~boxから順に，要素の`~box$の塗り順序で
⇒
`表示域$の子孫に適用される`変形$を適用したとするとき、
要素の`~box$は，
`表示域$内にあり, かつ座標 ( %x, %y ) にて`接触判定$の~targetになる
（そこに何も `overlap^en していないとしても【要素には塗られる内容がないとしても？】）
◎
For each box in the viewport, in paint order, starting with the topmost box, that would be a target for hit testing at coordinates x,y even if nothing would be overlapping it, when applying the transforms that apply to the descendants of the viewport, append the associated element to sequence.
</li>
			<li>
~IF［
%~list は空でない
］~AND［
コレの`根~要素$ %根 ~NIN { ~NULL, %~list の最後の~item }
］
⇒
%~list に %根 を付加する
◎
If the document has a root element, and the last item in sequence is not the root element, append the root element to sequence.
</li>
		</ol>
	</li>
	<li>
~RET %~list を表現する連列~型~obj
◎
Return sequence.
</li>
</ol>
</div>

<div class="algo">
<p>
`caretPositionFromPoint(x, y, options)@m
~method手続きは：
◎
The caretPositionFromPoint(x, y) method must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレに結付けられた`表示域$は無い
］
⇒
~RET ~NULL
◎
If there is no viewport associated with the document, return null.
</li>
	<li>
<p>
~IF［
~NOT ~AND↓
］…
</p>
		<ul>
			<li>
0 ~LTE %x ~LTE `表示域$の`実効~横幅$
</li>
			<li>
0 ~LTE %y ~LTE `表示域$の`実効~縦幅$
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>

<!-- 
引数が指す座標が`表示域$の外を指す場合、 null を返す（“表示域の外” の定義は上の <code>elementFromPoint</code> の記述と同じ）。
-->
◎
If either argument is negative, x is greater than the viewport width excluding the size of a rendered scroll bar (if any), y is greater than the viewport height excluding the size of a rendered scroll bar (if any) return null.
</li>
	<li>
<p>
`表示域$の子孫に適用される`変形$を適用したとするときの，
`表示域$内の座標 ( %x, %y ) に対し、
~text挿入~点~指示子を：
◎
↓</p>
		<ul class="switch">
			<li>
挿入できない場合
⇒
~RET ~NULL
◎
If at the coordinates x,y in the viewport no text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport, return null.
</li>
			<li>
挿入でき，そこは［
ある`置換d要素$による~text手入力~widget %~widget
］内である場合
⇒
~RET 次のように設定された`~caret位置$
⇒＃
`~caret~node$ ~SET %~widget に対応する~node,
`~caret~offset$ ~SET 左端から~text挿入~点~指示子が挿入される位置までにある`符号単位$の個数
◎
If at the coordinates x,y in the viewport a text insertion point indicator would have been inserted in a text entry widget which is also a replaced element, when applying the transforms that apply to the descendants of the viewport, return a caret position with its properties set as follows:
• caret node
•• The node corresponding to the text entry widget.
• caret offset
•• The amount of 16-bit units to the left of where the text insertion point indicator would have inserted. 
</li>
			<li>
<p>
挿入でき，そこは［
ある`境界~点$ %~caret位置
］に一致する場合：
◎
Otherwise:
• Let caretPosition be a tuple consisting of a caretPositionNode (a node) and a caretPositionOffset (a non-negative integer) for the position where the text insertion point indicator would have been inserted when applying the transforms that apply to the descendants of the viewport.
</p>
				<ol>
					<li>
%始端~node ~LET %~caret位置 の`~node$bp
◎
Let startNode be the caretPositionNode of the caretPosition,＼
</li>
					<li>
%始端~offset ~LET %~caret位置 の`~offset$bp
◎
and let startOffset be the caretPositionOffset of the caretPosition.
</li>
					<li>
<p>
~WHILE［
%始端~node ~NEQ ~NULL【！は ~DOM4#boundary-point-node である】
］：
</p>
						<ol>
							<li>
%根 ~LET %始端~node の`根$
</li>
							<li>
~IF［
%根 は`~shadow根$【！~DOM4#concept-element-shadow-root】でない
］
⇒
~BREAK
</li>
							<li>
%options[ `CaretPositionFromPointOptions^I1"`shadowRoots$m1" ] を成す
~EACH( %~shadow根 )
に対し
⇒
~IF［
%根 は %~shadow根 の`~shadowも含めた広義-先祖$である
］
⇒
~BREAK
</li>
							<li>
%始端~offset ~SET %根 の`~host$の`~index$
</li>
							<li>
%始端~node ~SET %根 の`~host$の`親$
</li>
						</ol>
◎
While startNode is a node, startNode’s root is a shadow root, and startNode’s root is not a shadow-including inclusive ancestor of any of options["shadowRoots"], repeat these steps:
• Set startOffset to index of startNode’s root’s host.
• Set startNode to startNode’s root’s host’s parent.
</li>
					<li>
~RET 次のように設定された`~caret位置$
⇒＃
`~caret~node$ ~SET %始端~node,
`~caret~offset$ ~SET %始端~offset,
◎
Return a caret position with its properties set as follows:
• caret node is set to startNode.
• caret offset is set to startOffset.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<p class="note">注記：
`~caret位置$は`~live$でない。
◎
Note: This caret position is not live.
</p>

<p class="note">注記：
`接触判定$の詳細は、
この仕様の視野から外れる。
したがって［
`elementFromPoint()$m ／
`caretPositionFromPoint()$m
］の正確な詳細についても同様になる。
接触判定は、
希望的には，~CSSまたは~HTMLの将来における改訂にて定義されることになる。
◎
Note: The specifics of hit testing are out of scope of this specification and therefore the exact details of elementFromPoint() and caretPositionFromPoint() are therefore too. Hit testing will hopefully be defined in a future revision of CSS or HTML.
</p>

<div class="algo">
<p>
`scrollingElement@m
取得子~手続きは：
◎
The scrollingElement attribute, on getting, must run these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレは`過去互換~mode$下にある
］：
◎
If the Document is in quirks mode, follow these substeps:
</p>
		<ol>
			<li>
%~body ~LET コレの`~body要素$
◎
↓</li>
			<li>
<p>
~IF［
%~body ~NEQ ~NULL
］~AND［
%~body は`~scroll可能になり得ない$†
］
⇒
~RET %~body
◎
If the body element exists, and it is not potentially scrollable, return the body element and abort these steps.
</p>

<p>†
この目的においては、
%~body の `overflow$p 値が `clip^v の場合には，
%~body の親~要素の `overflow$p は `hidden^v として扱うモノトスル。
◎
For this purpose, a value of overflow:clip on the body element’s parent element must be treated as overflow:hidden.
</p>
			</li>
			<li>
~RET ~NULL
◎
Return null and abort these steps.
</li>
		</ol>
	</li>
	<li>
~RET コレの`根~要素$
◎
If there is a root element, return the root element and abort these steps.
◎
Return null.
</li>
</ol>

<p class="note">注記：
`scrollingElement$m 属性は、
不適合な~UA
— ［
`scrollTop^m, `scrollLeft^m
］用には常に`過去互換~mode$の挙動を利用する~UA —
用には，常に`~body要素$を返す（ ~NULL にもなり得る）ものと期待されている。
この~APIは、
~Web開発者が，それを利用して［
~scroll用~APIに利用するための的確な要素
］を取得できるようにするために存在する
— ~UAの挙動について特定0の何かを前提にすることも，
どの要素が表示域を~scrollするか調べるために~scrollを呼出す必要もなく。
◎
Note: For non-conforming user agents that always use the quirks mode behavior for scrollTop and scrollLeft, the scrollingElement attribute is expected to also always return the body element (or null if it does not exist). This API exists so that Web developers can use it to get the right element to use for scrolling APIs, without making assumptions about a particular user agent’s behavior or having to invoke a scroll to see which element scrolls the viewport.
</p>

<p class="note">注記：
`~body要素$は、
~HTMLの `document.body^m とは異なる
— 後者は `frameset^e 要素を返すこともある。
◎
Note: the body element is different from HTML’s document.body in that the latter can return a frameset element.
</p>
</div>

		<section id="the-caretposition-interface">
<h3 title="The CaretPosition Interface">5.1. `CaretPosition^I ~interface</h3>

<div>
<p>
`~caret位置@
は、
~text挿入~点~指示子の位置を与える
— それは、
`CaretPosition$I ~objにより表現され，次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~caret~node@
⇒
ある`~node$
</li>
	<li>
`~caret~offset@
⇒
ある整数
</li>
</ul>

<p class="trans-note">【
挿入~点が ある~text~node内を指す場合、
それは，
`境界~点$( `~caret~node$, `~caret~offset$ )
に一致する。
】</p>
◎
A caret position gives the position of a text insertion point indicator. It always has an associated caret node and caret offset. It is represented by a CaretPosition object.
</div>

<pre class="idl">
[`Exposed$=Window]
interface `CaretPosition@I {
  readonly attribute `Node$I `offsetNode$m;
  readonly attribute `unsigned long$ `offset$m;
  [`NewObject$] `DOMRect$I? `getClientRect$m();
};
</pre>

<div class="algo">
`offsetNode@m
取得子~手続きは
⇒
~RET コレの`~caret~node$
◎
The offsetNode attribute must return the caret node.
</div>

<div class="algo">
`offset@m
取得子~手続きは
⇒
~RET コレの`~caret~offset$
◎
The offset attribute must return the caret offset.
</div>

<div class="algo">
<p>
`getClientRect()@m
~method手続きは：
◎
The getClientRect() method must follow these steps, aborting on the first step that returns a value:
</p>
<ol>
	<li>
%~node ~LET コレの`~caret~node$
◎
↓</li>
	<li>
~IF［
%~node は`置換d要素$による~text手入力~widgetである
］~AND［
%~node は文書~内に在る【！＊in the document】
］
⇒
~RET %~node とその先祖に適用される`変形$を適用したとするときの，
%~node 内の［
`~caret~offset$の値で表現される~caret
］用の`有拡縮$な `DOMRect$I ~obj
◎
If caret node is a text entry widget that is a replaced element, and that is in the document, return a scaled DOMRect object for the caret in the widget as represented by the caret offset value. The transforms that apply to the element and its ancestors are applied.
</li>
	<li>
%境界~点 ~LET `境界~点$( %始端~node, %始端~offset )
◎
↓</li>
	<li>
%~caret範囲 ~LET 新たな`~live範囲o$
— その
⇒＃
`始端$rG ~SET %境界~点,
`終端$rG ~SET %境界~点 の複製
◎
Otherwise:
• Let caretRange be a collapsed Range object whose start node and end node are set to caret node, and whose start offset and end offset are set to caret offset.
</li>
	<li>
~RET %~caret範囲 上の `Range^I1`getBoundingClientRect$m1 ~method手続き()
◎
• Return the DOMRect object which is the result of invoking the getBoundingClientRect() method on caretRange.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: This DOMRect object is not live.
</p>
</div>

		</section>
	</section>
	<section id="extension-to-the-element-interface">
<h2 title="Extensions to the Element Interface">6. `Element^I ~interfaceに対する拡張</h2>

<pre class="idl">
enum `ScrollLogicalPosition@I { `start@l, `center@l, `end@l, `nearest@l };

dictionary `ScrollIntoViewOptions@I : `ScrollOptions$I {
  `ScrollLogicalPosition$I `block@mb = `start$l;
  `ScrollLogicalPosition$I `inline@mb = `nearest$l;
  `ScrollIntoViewContainer$I `container@mb = `all$l;
};

enum `ScrollIntoViewContainer@I { `all@l, `~nearest0@l };

dictionary `CheckVisibilityOptions@I {
  `boolean$ `checkOpacity@mb = false;
  `boolean$ `checkVisibilityCSS@mb = false;
  `boolean$ `contentVisibilityAuto@mb = false;
  `boolean$ `opacityProperty@mb = false;
  `boolean$ `visibilityProperty@mb = false;
};
</pre>

<p class="note">注記：
［
`checkOpacity$mb ／ `checkVisibilityCSS$mb
］~propは，歴史的な名前であり、
それらには，新たな命名~schemeに合致する別名［
`opacityProperty$mb ／ `visibilityProperty$mb
］がある。
【！編集上の都合により下から移動】
◎
Note: The checkOpacity and checkVisibilityCSS properties are historical names. These properties have aliases that match the new naming scheme, namely opacityProperty and visibilityProperty.
</p>

<pre class="idl">
partial interface `Element$I {`Element^I0
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();

  `boolean$ `checkVisibility$m(optional `CheckVisibilityOptions$I %options = {});

  `Promise$&lt;`undefined$&gt; `scrollIntoView$m(optional (`boolean$ or `ScrollIntoViewOptions$I) %arg = {});
  `Promise$&lt;`undefined$&gt; `scroll$m(optional `ScrollToOptions$I %options = {});
  `Promise$&lt;`undefined$&gt; `scroll$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `Promise$&lt;`undefined$&gt; `scrollTo$m(optional `ScrollToOptions$I %options = {});
  `Promise$&lt;`undefined$&gt; `scrollTo$m(`unrestricted double$ %x, `unrestricted double$ %y);
  `Promise$&lt;`undefined$&gt; `scrollBy$m(optional `ScrollToOptions$I %options = {});
  `Promise$&lt;`undefined$&gt; `scrollBy$m(`unrestricted double$ %x, `unrestricted double$ %y);
  attribute `unrestricted double$ `scrollTop$m;
  attribute `unrestricted double$ `scrollLeft$m;
  readonly attribute `long$ `scrollWidth$m;
  readonly attribute `long$ `scrollHeight$m;
  readonly attribute `long$ `clientTop$m;
  readonly attribute `long$ `clientLeft$m;
  readonly attribute `long$ `clientWidth$m;
  readonly attribute `long$ `clientHeight$m;
  readonly attribute `double$ `currentCSSZoom$m;
};
</pre>

`Element^dgm

<p class="issue">
上の各種~scroll~methodは、
結果~objを返すべきか？
そうする場合、
それは何の情報を供するべきか？
[`12495$issue]
◎
Should the scroll methods above return a result object and if so what information should they provide? #12495
</p>

<div class="algo">
<p>
`getClientRects()@m
~method手続きは：
◎
The getClientRects() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
~IF［
コレは`~box$を有さない
］
⇒
~RET 空な `DOMRectList$I ~obj
◎
If the element on which it was invoked does not have an associated box return an empty DOMRectList object and stop this algorithm.
</li>
	<li>
~IF［
コレは`~SVG~layout~box$を有する
］
⇒
~RET 次で与えられる矩形を表す 1 個の `DOMRect$I ~objからなる`有拡縮$な `DOMRectList$I ~obj
⇒
コレとその先祖に適用される`変形$を適用したとするときの，
コレの`限界~box$ `SVG2$r
◎
If the element has an associated SVG layout box return a scaled DOMRectList object containing a single DOMRect object that describes the bounding box of the element as defined by the SVG specification, applying the transforms that apply to the element and its ancestors.
</li>
	<li>
<p>
%断片~list ~LET コレの`~box$内の`~box断片$たちが成す~list
— ここで：
</p>
		<ul>
			<li>
コレの `display$p ~propの算出d値
~IN { `table$v, `inline-table$v }
の場合、
table ~box と caption ~boxは ~listに含めるが，匿名~容器~boxは含めない。
</li>
			<li>
各 `匿名$な`塊~box$は，その子~boxたちに置換する。
匿名な塊~boxが尽きるまで，これを繰返す。
</li>
			<li>
縦幅／横幅 が 0 であっても~listから除外しない。
</li>
			<li>
~listは、
内容~順による。
</li>
		</ul>
◎
Return a DOMRectList object containing DOMRect objects in content order, one for each box fragment, describing its border area (including those with a height or width of zero) with the following constraints:
• Apply the transforms that apply to the element and its ancestors.
• If the element on which the method was invoked has a computed value for the display property of table or inline-table include both the table box and the caption box, if any, but not the anonymous container box.
• Replace each anonymous block box with its child box(es) and repeat this until no anonymous block boxes are left in the final list.
</li>
	<li>
%矩形~list ~LET 空な~list
◎
↑</li>
	<li>
<p>
%断片~list を成す
~EACH( %断片 )
に対し
⇒
%矩形~list に次を表現する `DOMRect$I ~objを付加する
⇒
次を包含する最~小な矩形
⇒
%断片 の`~border区画$に［
コレとその先祖に対する`変形$
］を適用して得られる図形
◎
↑</p>

<p class="trans-note">【
原文には “最~小な矩形” という記述は無いが、
変形を孕んでいるので，必然的にそうなる。
】</p>
</li>
	<li>
<p>
~RET %矩形~list を表現している `DOMRectList$I ~obj
◎
↑</p>

<p class="trans-note">【
新たな~objを返すとは限らない
（前回の呼出nから何も変化していない場合、同じ~objを返すかもしれない）。
】</p>
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objたちは、
`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</p>
</div>

<div class="algo">
`getBoundingClientRect()@m
~method手続きは
⇒
~RET `要素~用の限界~boxを取得する$( コレ )
◎
The getBoundingClientRect() method, when invoked on an element element, must return the result of getting the bounding box for element.
</div>

<div class="algo">
<p>
`要素~用の限界~boxを取得する@
~algoは、
所与の
( %要素 )
に対し：
◎
To get the bounding box for element, run the following steps:
</p>
<ol>
	<li>
%~list ~LET %要素 の `getClientRects$m ~method手続き()
◎
Let list be the result of invoking getClientRects() on element.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET 新たな `DOMRect$I ~obj
— その
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If the list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
	<li>
~IF［
%~list を成す矩形は，どれも［
横幅, 縦幅
］どちらかは 0
］
⇒
~RET %~list を成す最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
	<li>
~RET 次を表現する新たな `DOMRect$I ~obj
⇒
次をすべてを包含する最~小な矩形
⇒
%~list を成す［
横幅, 縦幅
］どちらかは【どちらも？】 0 でない矩形
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</p>

<div class="example">
<p>
次の~code片は文書~内の最初の `div^e 要素の~sizeを取得する：
◎
The following snippet gets the dimensions of the first div element in a document:
</p>

<pre class="lang-js">
var %example = document
    .getElementsByTagName("div")[0]
    .getBoundingClientRect();
var %exampleWidth = %example.width;
var %exampleHeight = %example.height;
</pre>
</div>
</div>

<p class="note">注記：
`checkVisibility()$m ~methodは、
要素は “可視” になり得るかどうかについて，一群の単純な検査を供する。
それは，既定では［
`~box~tree$に基づく，ごく単純かつ単直な~method
］であるが、
“可視性” を成す精確な観念として何が欲されるかに依存して，
いくつかの［
任意で選べる追加的な検査
］も許容する。
◎
Note: The checkVisibility() method provides a set of simple checks for whether an element is potentially "visible". It defaults to a very simple and straightforward method based on the box tree, but allows for several additional checks to be opted into, depending on what precise notion of "visibility" is desired.
</p>

<div class="algo">
<p>
`checkVisibility(options)@m
~method手続きは
⇒
~RET ~IS ~NOT ~OR↓：
◎
The checkVisibility(options) method must run these steps, when called on an element this:
</p>
<ul>
	<li>
コレは`~box$を有さない
◎
If this does not have an associated box, return false.
</li>
	<li>
`平坦~tree$におけるコレの先祖として，
`content-visibility$p が `hidden^v にされたものが在る
◎
If an ancestor of this in the flat tree has content-visibility: hidden, return false.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
［
%options[ "`opacityProperty$mb" ] ~EQ ~T
］~OR［
%options[ "`checkOpacity$mb" ] ~EQ ~T
］
</li>
			<li>
`平坦~tree$におけるコレの先祖として，
`opacity$p が `0^v に算出されるものが在る
</li>
		</ul>
◎
If either the opacityProperty or the checkOpacity dictionary members of options are true, and this, or an ancestor of this in the flat tree, has a computed opacity value of 0, return false.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
［
%options[ "`visibilityProperty$mb" ] ~EQ ~T
］~OR［
%options[ "`checkVisibilityCSS$mb" ] ~EQ ~T
］
</li>
			<li>
コレは`不可視$である
</li>
		</ul>
◎
If either the visibilityProperty or the checkVisibilityCSS dictionary members of options are true, and this is invisible, return false.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%options[ "`contentVisibilityAuto$mb" ] ~EQ ~T
</li>
			<li>
`平坦~tree$におけるコレの先祖として，
`content-visibility$p が `auto^v にされたことに因り`内容が飛ばされ$るものが在る
</li>
		</ul>
◎
If the contentVisibilityAuto dictionary member of options is true and an ancestor of this in the flat tree skips its contents due to content-visibility: auto, return false.
◎
Return true.
</li>
</ul>
</div>

<div class="algo">
<p>
`scrollIntoView(arg)@m
~method手続きは：
◎
The scrollIntoView(arg) method must run these steps:
</p>
<ol>
	<li>
%挙動 ~LET `auto^l
◎
Let behavior be "auto".
</li>
	<li>
%塊 ~LET `start^l
◎
Let block be "start".
</li>
	<li>
%行内 ~LET `nearest^l
◎
Let inline be "nearest".
</li>
	<li>
%容器 ~LET ~NULL
◎
Let container be null.
</li>
	<li>
<p>
~IF［
%arg は `ScrollIntoViewOptions$I 辞書である
］：
◎
If arg is a ScrollIntoViewOptions dictionary, then:
</p>
		<ol>
			<li>
%挙動 ~SET %options[ "`behavior$mb" ]
◎
Set behavior to the behavior dictionary member of options.
</li>
			<li>
%塊 ~SET %options[ "`block$mb" ]
◎
Set block to the block dictionary member of options.
</li>
			<li>
%行内 ~SET %options[ "`inline$mb" ]
◎
Set inline to the inline dictionary member of options.
</li>
			<li>
~IF［
%options[ "`container$mb" ] ~EQ `~nearest0$l
］
⇒
%容器 ~SET コレ
◎
If the container dictionary member of options is "nearest", set container to the element.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%arg ~EQ ~F
］
⇒
%塊 ~SET `end^l
◎
Otherwise, if arg is false, then set block to "end".
</li>
	<li>
~IF［
コレは`~box$を有さない
］~OR［
コレは~UA特能
【例：~tab~UIkeyによる巡回】
に可用でない
【例：先祖の`内容が飛ばされ$ている場合】
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If the element does not have any associated box, or is not available to user-agent features, then return a resolved Promise and abort the remaining steps.
</li>
	<li>
%~scroll~promise ~LET `~targetを~viewの中へ~scrollする$(コレ, %挙動, %塊, %行内, %容器 )
◎
Scroll the element into view with behavior, block, inline, and container. Let scrollPromise be the Promise returned from this step
</li>
	<li>
任意選択で
⇒
利用者に コレを注目してもらう何らかの動作を遂行する
◎
Optionally perform some other action that brings the element to the user’s attention.
</li>
	<li>
~RET %~scroll~promise
◎
Return scrollPromise.
</li>
</ol>
</div>

<div class="example">
<p>
`scrollIntoView()$m を利用すれば、
関心がある内容を指定された整列に従う下で~scrollできる：
◎
A component can use scrollIntoView to scroll content of interest into the specified alignment:
</p>

`scrollIntoView-1^xCode

<ul>
	<li>†1：
`scrollIntoView()^m は、
~target~itemを正しく整列する
— 当の~item（ `.slide^css ）の［
`scroll-snap-align$p, `scroll-margin$p
］および~scroll容器（ `.scroller^css ）の `scroll-padding$p を尊重する下で。
◎
scrollIntoView correctly aligns target item respecting scroll-snap-align, scroll-margin, and the scroll container’s scroll-padding.
</li>
	<li>†2：
最も近い~scroll容器に限り~scrollする。
◎
Only scroll the nearest scroll container.
</li>
</ul>
</div>

<div class="algo">
<p>
`scroll()@m
~method手続きは：
</p>
<ol>
	<li>
<p>
« %x, %y, %挙動 » ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
« %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] »
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
« %x, %y, `auto$l »
</li>
		</ul>
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x )
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y )
</li>
	<li>
~RET `要素~用の~scroll手続き$( コレ, %x, %y, %挙動 )
</li>
</ol>

◎
The scroll() method must run these steps:
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
• Let x be the value of the left dictionary member of options, if present, or the element’s current scroll position on the x axis otherwise.
◎
• Let y be the value of the top dictionary member of options, if present, or the element’s current scroll position on the y axis otherwise.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
◎
↓</div>

<div class="algo">
<p class="trans-note">【
この訳では、［
原文による `scroll()$m ~method手続きを成す引数の取扱い
］以外の部分を，次に与える手続きに分離する
— それは、
複数の箇所から共通して利用されるので。
】</p>

<p>
`要素~用の~scroll手続き@
は、
所与の
( %要素, %x, %y, %挙動 )
に対し：
◎
↑</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If document is not the active document, return a resolved Promise and abort the remaining steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If window is null, return a resolved Promise and abort the remaining steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If the element is the root element and document is in quirks mode, return a resolved Promise and abort the remaining steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`根~要素$
］
⇒＃
%x ~SET %window の `Window^I1`scrollX$m1  取得子~手続き()；
~RET `~window用の~scroll手続き$( %window, %x, %y, `auto$l )
◎
If the element is the root element, return the Promise returned by scroll() on window after the method is invoked with scrollX on window as first argument and y as second argument, and abort the remaining steps.
</li>
	<li>
~IF［
%要素 ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
%要素 は`~scroll可能になり得ない$
］
⇒
~RET `~window用の~scroll手続き$( %window, %x, %y, %挙動 )
◎
If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the Promise returned by scroll() on window after the method is invoked with options as the only argument, and abort the remaining steps.
</li>
	<li>
~IF［
%x ~EQ ε
］
⇒
%x ~SET %要素 の現在の~x軸 ~scroll位置
◎
↑</li>
	<li>
~IF［
%y ~EQ ε
］
⇒
%y ~SET %要素 の現在の~y軸 ~scroll位置
◎
↑</li>
	<li>
<p>
~IF［
%要素 は ~OR↓ を満たす
］…
</p>
		<ul>
			<li>
`~box$を有さない
</li>
			<li>
`~scrollされる~box$は無い
</li>
			<li>
~overflowしていない
</li>
		</ul>
<p>
…ならば
⇒
~RET `解決される~promise$( `undefined^jv )
</p>
◎
If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, return a resolved Promise and abort the remaining steps.
</li>
	<li>
~RET `要素を~scrollする$( %要素, ( %x, %y ), %挙動 )
◎
Scroll the element to x,y, with the scroll behavior being the value of the behavior dictionary member of options. Let scrollPromise be the Promise returned from this step.
◎
Return scrollPromise.
</li>
</ol>
</div>

<div class="algo">
`scrollTo()@m
~method手続きは、
`scroll()$m ~method手続きと同じに挙動する。
◎
When the scrollTo() method is invoked, the user agent must act as if the scroll() method was invoked with the same arguments.
</div>

<div class="algo">
<p>
`scrollBy()@m
~method手続きは：
◎
When the scrollBy() method is invoked, the user agent must run these steps:
</p>
<ol>
	<li>
<p>
« %x, %y, %挙動 » ~LET ~methodの引数に応じて：
</p>
		<ul class="switch">
			<li>
`ScrollToOptions$I %options 引数を伴って呼出された場合
⇒
« %options[ "`left$mb" ], %options[ "`top$mb" ], %options[ "`behavior$mb" ] »
</li>
			<li>
%x, %y 引数を伴って呼出された場合
⇒
« %x, %y, `auto$l »
</li>
		</ul>
◎
If invoked with one argument, follow these substeps:
• Let options be the argument.
• Normalize non-finite values for left and top dictionary members of options, if present.
◎
If invoked with two arguments, follow these substeps:
• Let options be null converted to a ScrollToOptions dictionary. [WEBIDL]
• Let x and y be the arguments, respectively.
• Normalize non-finite values for x and y.
• Let the left dictionary member of options have the value x.
• Let the top dictionary member of options have the value y.
</li>
	<li>
~IF［
%x ~NEQ ε
］
⇒
%x ~SET `有限~値に正規化する$( %x ) ~PLUS コレの `scrollLeft$m 取得子~手続き()
◎
Add the value of scrollLeft to the left dictionary member.
</li>
	<li>
~IF［
%y ~NEQ ε
］
⇒
%y ~SET `有限~値に正規化する$( %y ) ~PLUS コレの `scrollTop$m 取得子~手続き()
◎
Add the value of scrollTop to the top dictionary member.
</li>
	<li>
~RET `要素~用の~scroll手続き$( コレ, %x, %y, %挙動 )
◎
Return the Promise returned by scroll() after the method is invoked with options as the only argument.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`scrollTop@m ｜ `scrollLeft@m
］取得子~手続きは：
◎
The scrollTop attribute, on getting, must return the result of running these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET 0
◎
If window is null, return zero and terminate these steps.
</li>
	<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET 0
◎
If the element is the root element and document is in quirks mode, return zero and terminate these steps.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>

		<ul>
			<li>
コレ ~EQ %文書 の`根~要素$
</li>
			<li>
［
コレ ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
		</ul>
<p>
…ならば
⇒
~RET %window の［
`scrollY^m ｜ `scrollX^m
］の値
</p>

◎
If the element is the root element return the value of scrollY on window.
◎
If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollY on window.
</li>
	<li>
~IF［
コレは`~box$を有さない
］
⇒
~RET 0
◎
If the element does not have any associated box, return zero and terminate these steps.
</li>
	<li>
~RET
コレの`~scrollされる区画$の整列~点から相対的な，
コレの`~padding辺$の［
上端の~y座標 ｜ 左端の~x座標
］
◎
Return the y-coordinate of the scrolling area at the alignment point with the top of the padding edge of the element.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`scrollTop$m ｜ `scrollLeft$m
］設定子~手続きは：
◎
When setting the scrollTop attribute these steps must be run:
</p>
<ol>
	<li>
%v ~LET `有限~値に正規化する$( 所与の値 )
◎
Let y be the given value.
◎
Normalize non-finite values for y.
</li>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET
◎
If document is not the active document, terminate these steps.
</li>
	<li>
%window ~LET %文書 の `defaultView$m 取得子~手続き()
◎
Let window be the value of document’s defaultView attribute.
</li>
	<li>
~IF［
%window ~EQ ~NULL
］
⇒
~RET
◎
If window is null, terminate these steps.
</li>
	<li>
~IF［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
⇒
~RET
◎
If the element is the root element and document is in quirks mode, terminate these steps.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
コレ ~EQ %文書 の`根~要素$
</li>
			<li>
［
コレ ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］~AND［
コレは`~scroll可能になり得ない$
］
</li>
		</ul>
<p>
…ならば：
`Window^I1
</p>
		<ol>
			<li>
%x ~LET ［ %window の `scrollX$m1 取得子~手続き() ｜ %v ］
</li>
			<li>
%y ~LET ［ %v ｜ %window の `scrollY$m1 取得子~手続き() ］
</li>
			<li>
`~window用の~scroll手続き$( %window, %x, %y, `auto$l )
</li>
			<li>
~RET
</li>
		</ol>
◎
If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.
◎
If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with scrollX as first argument and y as second argument, and terminate these steps.
</li>
	<li>
<p>
~IF［
コレは ~OR↓ を満たす
］…
</p>
		<ul>
			<li>
`~box$を有さない
</li>
			<li>
`~scrollされる~box$は無い
</li>
			<li>
~overflowしていない
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>

◎
If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
</li>
	<li>
%目的位置 ~LET ( ［
コレの `scrollLeft$m 取得子~手続き() ｜ %v
］, ［
%v ｜ コレの `scrollTop$m 取得子~手続き()
］ )
◎
↓</li>
	<li>
`要素を~scrollする$( コレ,  %目的位置 , `auto$l )
◎
Scroll the element to scrollLeft,y, with the scroll behavior being "auto".
</li>
</ol>
</div>

<p class="en">
◎
The scrollLeft attribute, on getting, must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, return zero and terminate these steps.
• If the element is the root element and document is in quirks mode, return zero and terminate these steps.
• If the element is the root element return the value of scrollX on window.
• If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollX on window.
• If the element does not have any associated box, return zero and terminate these steps.
• Return the x-coordinate of the scrolling area at the alignment point with the left of the padding edge of the element.
◎
When setting the scrollLeft attribute these steps must be run:
• Let x be the given value.
• Normalize non-finite values for x.
• Let document be the element’s node document.
• If document is not the active document, terminate these steps.
• Let window be the value of document’s defaultView attribute.
• If window is null, terminate these steps.
• If the element is the root element and document is in quirks mode, terminate these steps.
• If the element is the root element invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.
• If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.
• Scroll the element to x,scrollTop, with the scroll behavior being "auto".
</p>

<div class="algo">
<p>
［
`scrollWidth@m ｜ `scrollHeight@m 
］取得子~手続きは：
◎
The scrollWidth attribute must return the result of running these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be the element’s node document.
</li>
	<li>
~IF［
%文書 は`作動中な文書$navでない
］
⇒
~RET 0
◎
If document is not the active document, return zero and terminate these steps.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>

		<ul >
			<li>
［
%文書 は`過去互換~mode$下にない
］~AND［
コレ ~EQ %文書 の`根~要素$
］
</li>
			<li>
［
%文書 は`過去互換~mode$下にある
］~AND［
コレ ~EQ %文書 の`~body要素$
］~AND［
コレは
`~scroll可能になり得ない$
］
</li>
		</ul>

<p>
…ならば：
</p>
		<ol>
			<li>
~IF［
コレの`表示域$は無い
］
⇒
~RET 0
</li>
			<li>
~RET
`max^op( `表示域$の`~scrollされる区画$の［
横幅 ｜ 縦幅
］, `表示域$の［
`実効~横幅$ ｜ `実効~縦幅$
］ )
</li>
		</ol>
◎
Let viewport width be the width of the viewport excluding the width of the scroll bar, if any, or zero if there is no viewport.
◎
If the element is the root element and document is not in quirks mode return max(viewport scrolling area width, viewport width).
◎
If the element is the body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area width, viewport width).
</li>
	<li>
~IF［
コレは`~box$を有さない
］
⇒
~RET 0
◎
If the element does not have any associated box return zero and terminate these steps.
</li>
	<li>
~RET
コレの`~scrollされる区画$の［
横幅 ｜ 縦幅
］
◎
Return the width of the element’s scrolling area.
</li>
</ol>
</div>

<p class="en">
◎
The scrollHeight attribute must return the result of running these steps:
• Let document be the element’s node document.
• If document is not the active document, return zero and terminate these steps.
• Let viewport height be the height of the viewport excluding the height of the scroll bar, if any, or zero if there is no viewport.
• If the element is the root element and document is not in quirks mode return max(viewport scrolling area height, viewport height).
• If the element is the body element, document is in quirks mode and the element is not potentially scrollable, return max(viewport scrolling area height, viewport height).
• If the element does not have any associated box return zero and terminate these steps.
• Return the height of the element’s scrolling area.
</p>

<div class="algo">
<p>
［
`clientTop@m ｜ `clientLeft@m
］取得子~手続きは：
◎
The clientTop attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレは`~box$を有さない
］~OR［
コレの`~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated box or if the box is inline, return zero.
</li>
	<li>
<p>
~RET 次の和：
</p>
		<ul>
			<li>
［
`border-top-width$p ｜ `border-left-width$p
］~propの`無拡縮$な算出d値
</li>
	<li>
`~padding辺$の［
上端 ｜ 左端
］と`~border辺$の［
上端 ｜ 左端
］の間に描画された~scrollbarの［
縦幅 ｜ 横幅
］
</li>
		</ul>
<p>
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</p>
◎
Return the unscaled computed value of the border-top-width property plus the height of any scrollbar rendered between the top padding edge and the top border edge, ignoring any transforms that apply to the element and its ancestors.
</li>
</ol>
</div>

<p class="en">
◎
The clientLeft attribute must run these steps:
• If the element has no associated box or if the box is inline, return zero.
• Return the unscaled computed value of the border-left-width property plus the width of any scrollbar rendered between the left padding edge and the left border edge, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
<p>
［
`clientWidth@m ｜ `clientHeight@m
］取得子~手続きは：
◎
The clientWidth attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレは`~box$を有さない
］~OR［
コレの`~box$は`行内$である
］
⇒
~RET 0
◎
If the element has no associated box or if the box is inline, return zero.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
コレ ~EQ %文書 の`根~要素$
］~AND［
%文書 は`過去互換~mode$下にない
］
</li>
			<li>
［
コレ ~EQ %文書 の`~body要素$
］~AND［
%文書 は`過去互換~mode$下にある
］
</li>
</ul>

<p>
…ならば
⇒
~RET
`表示域$の［
`実効~横幅$ ｜ `実効~縦幅$
］
</p>
◎
If the element is the root element and the element’s node document is not in quirks mode, or if the element is the body element and the element’s node document is in quirks mode, return the viewport width excluding the size of a rendered scroll bar (if any).
</li>
	<li>
<p>
~RET  `~padding辺$の`無拡縮$な［
横幅 ｜ 縦幅
］
— ここで：
</p>
		<ul>
			<li>
`~padding辺$と`~border辺$の間に~scrollbarが描画されている場合は，その分の［
横幅 ｜ 縦幅
］は除外する。
</li>
			<li>
【！or that → that】
コレとその先祖に対する`変形$は適用しないとする。
</li>
		</ul>
◎
Return the unscaled width of the padding edge excluding the width of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms or that apply to the element and its ancestors.
</li>
</ol>
</div>

<p class="en">
◎
The clientHeight attribute must run these steps:
• If the element has no associated box or if the box is inline, return zero.
• If the element is the root element and the element’s node document is not in quirks mode, or if the element is the body element and the element’s node document is in quirks mode, return the viewport height excluding the size of a rendered scroll bar (if any).
• Return the unscaled height of the padding edge excluding the height of any rendered scrollbar between the padding edge and the border edge, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
`currentCSSZoom@m
取得子~手続きは
⇒
~RET ［
コレは`具現化されて$いるならば コレの`実質的な~zoom$／
~ELSE_ 1.0
］
◎
The currentCSSZoom attribute must return the effective zoom of the element, or 1.0 if the element isn’t being rendered.
</div>

		<section id="element-scrolling-members">
<h3 title="Element Scrolling Members">6.1. 要素の~scroll法</h3>

<div class="algo">
<p>
`~viewの中へ~scrollする位置を決定する@
~algoは、
所与の
⇒＃
［`要素$／`疑似要素$／`範囲o$］ %~target,
~scrollの挙動 %挙動,
塊~flow方向~位置 %塊,
行内~基底~方向~位置 %行内
`~scrollされる~box$ %~box
◎終
に対し：
◎
To determine the scroll-into-view position of a target, which is an Element, pseudo-element, or Range, with a scroll behavior behavior, a block flow direction position block, an inline base direction position inline, and a scrolling box scrolling box, run the following steps:
</p>
<ol>
	<li>
%~target限界~box ~LET %~target に応じて，次の結果を表現する~box
⇒＃
`要素$であるならば %~target の `getBoundingClientRect$m ~method手続き()／
`範囲o$であるならば  %~target の `Range^I1`getBoundingClientRect$m1 ~method手続き()
◎
Let target bounding border box be the box represented by the return value of invoking Element’s getBoundingClientRect(), if target is an Element, or Range’s getBoundingClientRect(), if target is a Range.
</li>
	<li>
<div>
<p>
この段においては：
</p>
		<ul>
			<li>
%~box の辺 %e に対する
%~target限界~box の
`同じ側@
にある辺とは、
%~target限界~box を成す 4 辺のうち
%e と物理的に同じ側にある辺を指すとする。
</li>
			<li>
［
`開始辺$ ／ `終了辺$ ／ 中心 ／ 距離
］は、［
%塊 に関しては`塊~flow方向$,
%行内 に関しては`行内~基底~方向$
］におけるそれを指すとする。
</li>
		</ul>
◎
Let scrolling box edge A be the beginning edge in the block flow direction of scrolling box, and let element edge A be target bounding border box’s edge on the same physical side as that of scrolling box edge A.
◎
Let scrolling box edge B be the ending edge in the block flow direction of scrolling box, and let element edge B be target bounding border box’s edge on the same physical side as that of scrolling box edge B.
◎
Let scrolling box edge C be the beginning edge in the inline base direction of scrolling box, and let element edge C be target bounding border box’s edge on the same physical side as that of scrolling box edge C.
◎
Let scrolling box edge D be the ending edge in the inline base direction of scrolling box, and let element edge D be target bounding border box’s edge on the same physical side as that of scrolling box edge D.
◎
Let element height be the distance between element edge A and element edge B.
◎
Let scrolling box height be the distance between scrolling box edge A and scrolling box edge B.
◎
Let element width be the distance between element edge C and element edge D.
◎
Let scrolling box width be the distance between scrolling box edge C and scrolling box edge D.
</div>
<div>
<p>
%目的位置 ~LET %~box を［
%塊 に応じて，以下に従うように`塊~flow方向$において位置させ、
%行内 に応じて，以下に従うように`行内~基底~方向$において位置させた
］とするときの，
%~box の~scroll位置：
</p>
		<ul class="switch">
			<li>
`start$l
⇒
%~box の`開始辺$と
%~target限界~box の`同じ側$にある辺を整列する
</li>
			<li>
`end$l
⇒
%~box の`終了辺$と
%~target限界~box の`同じ側$にある辺を整列する
</li>
			<li>
`center$l
⇒
%~box の中心と
%~target限界~box の中心を整列する
</li>
			<li>
<p>
`nearest$l：
</p>
				<ol>
					<li>
%~target幅 ~LET
%~box の［`開始辺$, `終了辺$］と`同じ側$にある，
%~target限界~box を成す 2 辺の距離
</li>
					<li>
%~box幅 ~LET
%~box の`開始辺$と`終了辺$の距離
</li>
					<li>
%開始辺を過ぎるか ~LET ~IS［
%~box の`開始辺$の外側に
%~target限界~box の`同じ側$にある辺がある
］
</li>
					<li>
%終了辺を過ぎるか ~LET ~IS［
%~box の`終了辺$の外側に
%~target限界~box の`同じ側$にある辺がある
］
</li>
					<li>
<p>
%幅を超過するか ~LET ~IS［
%~target幅 ~GT %~box幅
］
</p>

<p class="trans-note">【
原文は，［
%~target幅 ~EQ %~box幅
］になる場合を一部の事例で取扱っていないので、
この訳では，［
%幅を超過するか ~EQ ~F
］になる事例に収容するよう改める。
】</p>
					</li>
					<li>
<p>
( %開始辺を過ぎるか, %終了辺を過ぎるか, %幅を超過するか )
に応じて：
</p>
						<ul class="switch">
							<li>
( ~T, ~T, ~T ) ／
( ~F, ~F, ~F )
⇒
何もしない
【現在の~scroll位置と同じ】
</li>
							<li>
( ~T, ~T, ~F ) ／
( ~F, ~F, ~T )
⇒
この事例は生じ得ない。
</li>
							<li>
( ~T, ~F, ~F ) ／
( ~F, ~T, ~T )
⇒
%~box の`開始辺$と
%~target限界~box の`同じ側$にある辺を整列する
</li>
							<li>
( ~T, ~F, ~T ) ／
( ~F, ~T, ~F )
⇒
%~box の`終了辺$と
%~target限界~box の`同じ側$にある辺を整列する
</li>
						</ul>
					</li>
				</ol>
			</li>
		</ul>
◎
Let position be the scroll position scrolling box would have by following these steps:
• If block is "start", then align element edge A with scrolling box edge A.
• Otherwise, if block is "end", then align element edge B with scrolling box edge B.
• Otherwise, if block is "center", then align the center of target bounding border box with the center of scrolling box in scrolling box’s block flow direction.
• Otherwise, block is "nearest":
• If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
•• Do nothing. 
• If element edge A is outside scrolling box edge A and element height is less than scrolling box height
• If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
•• Align element edge A with scrolling box edge A. 
• If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
• If element edge B is outside scrolling box edge B and element height is less than scrolling box height
•• Align element edge B with scrolling box edge B. 
• If inline is "start", then align element edge C with scrolling box edge C.
• Otherwise, if inline is "end", then align element edge D with scrolling box edge D.
• Otherwise, if inline is "center", then align the center of target bounding border box with the center of scrolling box in scrolling box’s inline base direction.
• Otherwise, inline is "nearest":
• If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
•• Do nothing. 
• If element edge C is outside scrolling box edge C and element width is less than scrolling box width
• If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
•• Align element edge C with scrolling box edge C. 
• If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
• If element edge D is outside scrolling box edge D and element width is less than scrolling box width
•• Align element edge D with scrolling box edge D. 
</div>
	</li>
	<li>
<p>
~IF［
%~target は`要素$である
］~AND［
%~target は何らかの`留め位置$を定義する
【 %~target の `scroll-snap-align$p は `none^v 以外をとる】
］：
◎
If target is an Element, and the target element defines some scroll snap positions, then＼
</p>
		<ol>
			<li>
%~scroll容器 ~LET %~target に最も近い`~scroll容器$
◎
↓</li>
			<li>
<p>
~IF［
%~scroll容器 は`~scroll留め容器$である
］
⇒
%目的位置 ~SET %~target のいずれかの`留め位置$に
【`留め位置の選び方＠~CSSSCROLLSNAP#choosing$に則って， %目的位置 との距離が最小になるよう】
`留める＠~CSSSCROLLSNAP#scroll-snap$ことになる位置
◎
the user agent must scroll snap the resulting position to one of that element’s scroll snap positions if its nearest scroll container is a scroll snap container.＼
</p>

<p>
~UAは、
%~scroll容器 の `scroll-snap-type$p が `none^v をとる
【すなわち， %~scroll容器 は~scroll留め容器ではない（が`留め位置を捕捉する$）】
ときでも，これを行なって`ヨイ^em。
◎
The user agent may also do this even when the scroll container has scroll-snap-type: none.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %目的位置
◎
Return position.
</li>
</ol>
</div>

<div class="algo">
<p>
`~targetを~viewの中へ~scrollする@
~algoは、
所与の
⇒＃
［`要素$／`疑似要素$／`範囲o$］ %~target,
~scrollの挙動 %挙動,
塊~flow方向~位置 %塊,
行内~基底~方向~位置 %行内,
`要素$ %容器 ~DF ~NULL <span class="note">（~scrollは %容器 に達した所で停止する。）</span>
◎終
に対し：
◎
To scroll a target into view target, which is an Element, pseudo-element, or Range, with a scroll behavior behavior, a block flow direction position block, an inline base direction position inline, and an optional containing Element to stop scrolling after reaching container, means to run these steps:
</p>
<ol>
	<li>
%先祖~promise群 ~LET « »
◎
Let ancestorPromises be an empty set of Promises.
</li>
	<li>
%~target生成元 ~LET ［
%~target に応じて，次で与えられる~node
］の`~node文書$の`生成元$doc
⇒＃
`要素$であるならば %~target ／
`疑似要素$であるならば %~target の`最終的な出自の要素$／
`範囲o$であるならば %~target の`始端$rGの`~node$bp
◎
↓</li>
	<li>
<p>
%~target の
~EACH( 先祖`~scroll容器$ %~scroll容器 )
に対し，最も内縁なものから順に：
◎
For each ancestor element or viewport that establishes a scrolling box scrolling box, in order of innermost to outermost scrolling box, run these substeps:
</p>

<p class="trans-note">【
原文では，この~loopを %~target の先祖~要素たちを反復しているが、
この訳では，先祖`~scroll容器$に基づくよう改める。
~scroll法は呈示における挙動なので，この “先祖” は~DOM~treeではなく`~box~tree$におけるそれと解釈するべきであることに加え、
以下における同一-生成元の検査がイミを成すためには，
`先祖~navigable＠~HTMLds#ancestor-navigables$も孕む “広義な” 先祖も含める必要もあると見受けられるので。
】</p>
		<ol>
			<li>
« %要素, %表示域, %~node » ~LET %~scroll容器 を確立したもの %e に応じて
⇒＃
`要素$であるならば « %e, ε, %e » ／
`表示域$であるならば « ε, %e, %e に結付けられた`文書$ »
◎
↓</li>
			<li>
<p>
~IF［
( %~target生成元, %~node の`~node文書$の`生成元$doc )
は`同一-生成元$でない
］
⇒
~BREAK
◎
If the Document associated with target is not same origin with the Document associated with the element or viewport associated with scrolling box, abort any remaining iteration of this loop.
</p>

<p class="trans-note">【
例えば %~node が `iframe^e で，
%~target は その中に埋込まれた文書~内にある場合、
これらの生成元は異なり得る。
】</p>
			</li>
			<li>
%~box ~LET %~scroll容器 の`~scrollされる~box$
◎
↓</li>
			<li>
%目的位置 ~LET `~viewの中へ~scrollする位置を決定する$( ↓ )
⇒＃
%~target,
%挙動,
%塊,
%行内,
%~box
◎
Let position be the scroll position resulting from running the steps to determine the scroll-into-view position of target with behavior as the scroll behavior, block as the block flow position, inline as the inline base direction position and scrolling box as the scrolling box.
</li>
			<li>
<p>
~IF［
%目的位置 ~NEQ %~box の現在の~scroll位置
］~OR［
%~box において`滑らかな~scroll$は進行中である
］：
◎
If position is not the same as scrolling box’s current scroll position, or scrolling box has an ongoing smooth scroll,
</p>
				<ol>
					<li>
~IF［
%要素 ~NEQ ε
］
⇒
%先祖~promise群 に次の結果を`付加する$
⇒
`~scrollを遂行する$( %~box, %目的位置, %要素, %挙動 )
◎
If scrolling box is associated with an element
• Perform a scroll of the element’s scrolling box to position, with the element as the associated element and behavior as the scroll behavior. Add the Promise retured from this step to the set ancestorPromises.
</li>
					<li>
~ELSE（ %表示域 ~NEQ ε ）
⇒
%先祖~promise群 に次の結果を`付加する$
⇒
`表示域の~scrollを遂行する$( %表示域, %目的位置, %挙動 )
◎
If scrolling box is associated with a viewport
•（不要） Let document be the viewport’s associated Document.
•（不要） Let root element be document’s root element, if there is one, or null otherwise.
• Perform a scroll of the viewport to position, with＼
（不要） root element as the associated element＼
and behavior as the scroll behavior.＼
Add the Promise retured from this step in the set ancestorPromises.
</li>
				</ol>
			</li>
			<li>
~IF［
%容器 ~NEQ ~NULL
］~AND［
%~node【！ %~box = scrolling box 】 は %容器 の`~shadowも含めた広義-先祖$である
］
⇒
~BREAK
◎
If container is not null and＼
↑ either scrolling box＼
is a shadow-including inclusive ancestor of container＼
↑ or is a viewport whose document＼
is a shadow-including inclusive ancestor of container,＼
abort any remaining iteration of this loop.
</li>
		</ol>
	</li>
	<li>
%~scroll~promise ~LET `新たな~promise$
◎
Let scrollPromise be a new Promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
</p>
		<ol>
			<li>
%先祖~promise群 を成すすべての~promiseが決着するまで待機する
</li>
			<li>
`~promiseを解決する$( %~scroll~promise )
</li>
		</ol>
◎
↓ Return scrollPromise,＼
and run the remaining steps in parallel.
◎
Resolve scrollPromise when all Promises in ancestorPromises have settled.
</li>
	<li>
~RET %~scroll~promise
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`要素を~scrollする@
~algoは、
所与の
⇒＃
［`要素$／`疑似要素$］ %要素,
位置 %目的位置,
~scrollの挙動 %挙動 ~DF `auto$l
◎終
に対し：
◎
To scroll an element (or pseudo-element) element to x,y optionally with a scroll behavior behavior (which is "auto" if omitted) means to:
</p>
<ol>
	<li>
%~box ~LET %要素 の`~scrollされる~box$
◎
Let box be element’s associated scrolling box.
</li>
	<li>
( %~x, %~y ) ~SET 目的位置の ( ~x, ~y ) ~~成分
◎
↓</li>
	<li>
%符号 ~LET %~box の横方向の`~overflow方向$に応じて
⇒＃
右方 ならば 1 ／
左方 ならば −1
◎
↓</li>
	<li>
%~x ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %~x, %要素 の`~scrollされる区画$の横幅 ~MINUS %要素 の`~padding辺$の横幅 ) )
◎
If box has rightward overflow direction
• Let x be max(0, min(x, element scrolling area width - element padding edge width)).
◎
If box has leftward overflow direction
• Let x be min(0, max(x, element padding edge width - element scrolling area width)).
</li>
			<li>
%符号 ~LET %~box の縦方向の`~overflow方向$に応じて
⇒＃
下方 ならば 1 ／
上方 ならば −1
◎
↓</li>
	<li>
%y ~SET %符号 ~MUL `max^op( 0, `min^op( %符号 ~MUL %y, %要素 の`~scrollされる区画$の縦幅 ~MINUS %要素 の`~padding辺$の縦幅 ) )
◎
If box has downward overflow direction
• Let y be max(0, min(y, element scrolling area height - element padding edge height)).
◎
If box has upward overflow direction
• Let y be min(0, max(y, element padding edge height - element scrolling area height)).
</li>
	<li>
%目的位置 ~LET ［
`~scrollされる区画$の座標 ( %~x, %~y ) が %~box の左上隅に整列された
］とするときの，
%~box の~scroll位置
◎
Let position be the scroll position box would have by aligning scrolling area x-coordinate x with the left of box and aligning scrolling area y-coordinate y with the top of box.
</li>
	<li>
~IF［
%目的位置 ~EQ %~box の現在の~scroll位置
］~AND［
%~box において`滑らかな~scroll$は進行中でない
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If position is the same as box’s current scroll position, and box does not have an ongoing smooth scroll, return a resolved Promise and abort the remaining steps.
</li>
	<li>
~RET `~scrollを遂行する$( %~box, %目的位置, %要素, %挙動 )
◎
Perform a scroll of box to position, element as the associated element and behavior as the scroll behavior. Let scrollPromise be the Promise returned from this step.
◎
Return scrollPromise.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="extensions-to-the-htmlelement-interface">
<h2 title="Extensions to the HTMLElement Interface">7. `HTMLElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLElement$I {`HTMLElement^I0
  readonly attribute `Element$I? `scrollParent$m;
  readonly attribute `Element$I? `offsetParent$m;
  readonly attribute `long$ `offsetTop$m;
  readonly attribute `long$ `offsetLeft$m;
  readonly attribute `long$ `offsetWidth$m;
  readonly attribute `long$ `offsetHeight$m;
};
</pre>

`HTMLElement^dgm

<div class="algo">
<p>
`scrollParent@m
取得子~手続きは：
◎
The scrollParent attribute must return the result of running these steps:
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following holds true, return null and terminate this algorithm:
</p>
		<ul>
			<li>
コレは`~box$を有さない
◎
The element does not have an associated box.
</li>
			<li>
コレは`根~要素$である
◎
The element is the root element.
</li>
			<li>
コレは`~body要素$である
◎
The element is the body element.
</li>
			<li>
［
コレの `position$p ~propの算出d値 ~EQ `fixed$v
］~AND［
コレの先祖として固定d位置`包含塊$【`固定d位置決め包含塊$？】を確立するものは無い
］
◎
The element’s computed value of the position property is fixed and no ancestor establishes a fixed position containing block.
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
↑</p>
	</li>
	<li>
%先祖 ~LET `平坦~tree$におけるコレの`包含塊$
◎
Let ancestor be the containing block of the element in the flat tree and＼
</li>
	<li>
<p>
~WHILE 無条件：
◎
repeat these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
%先祖 は`初期~包含塊$である
］：
</p>
				<ol>
					<li>
%要素 ~LET コレの`~node文書$【！文書】の `Document^I1`scrollingElement$m1
</li>
					<li>
~IF［
%要素 はコレからは`閉な~shadowで非可視$でない
］
⇒
~RET %要素
</li>
					<li>
~RET ~NULL
</li>
				</ol>
◎
If ancestor is the initial containing block, return the scrollingElement for the element’s document if it is not closed-shadow-hidden from the element, otherwise return null.
</li>
			<li>
~IF［
%先祖 【を確立した要素】はコレからは`閉な~shadowで非可視$でない
］~AND［
%先祖 は`~scroll容器$である
］
⇒
~RET %先祖
◎
If ancestor is not closed-shadow-hidden from the element, and is a scroll container, terminate this algorithm and return ancestor.
</li>
			<li>
~IF［
%先祖 の `position$p ~propの算出d値 ~EQ `fixed$v
］~AND［
%先祖 の先祖として固定d位置`包含塊$【`固定d位置決め包含塊$？】を確立するものは無い
］
⇒
~RET ~NULL
◎
If the computed value of the position property of ancestor is fixed, and no ancestor establishes a fixed position containing block, terminate this algorithm and return null.
</li>
			<li>
%先祖 ~LET `平坦~tree$における %先祖 の`包含塊$
◎
Let ancestor be the containing block of ancestor in the flat tree.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`offsetParent@m
取得子~手続きは：
◎
The offsetParent attribute must return the result of running these steps:
</p>
<ol>
	<li>
%~body ~LET コレの`~node文書$の`~body要素$
◎
↓</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following holds true return null and terminate this algorithm:
</p>
		<ul>
			<li>
コレは`~box$を有さない
◎
The element does not have an associated box.
</li>
			<li>
コレは`根~要素$である
◎
The element is the root element.
</li>
			<li>
コレ ~EQ %~body
◎
The element is the body element.
</li>
			<li>
［
コレの `position$p ~propの算出d値 ~EQ `fixed^v
］~AND［
コレの先祖として固定d位置`包含塊$【`固定d位置決め包含塊$？】を確立するものは無い
］
◎
The element’s computed value of the position property is fixed and no ancestor establishes a fixed position containing block.
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
↑</p>
	</li>
	<li>
%先祖 ~LET コレ
◎
↓</li>
	<li>
<p>
~WHILE［
`平坦~tree$における %先祖 の親~要素 %親 は在る
］：
◎
Let ancestor be the parent of the element in the flat tree and repeat these substeps:
</p>
		<ol>
			<li>
%先祖 ~SET %親
◎
↑</li>
			<li>
<p>
~IF［
%先祖 はコレからは`閉な~shadowで非可視$である
］
⇒
~IF［
%先祖 の `position$p ~propの算出d値 ~EQ `fixed^v
］~AND［
%先祖 の先祖として固定d位置`包含塊$【`固定d位置決め包含塊$？】を確立するものは無い
］
⇒
~RET ~NULL
◎
If ancestor is closed-shadow-hidden from the element,＼
its computed value of the position property is fixed,＼
and no ancestor establishes a fixed position containing block, terminate this algorithm and return null.
</li>
			<li>
~ELIF［
コレは固定d位置`包含塊$内にある
【コレの先祖として`固定d位置決め包含塊$を確立するものは在る？】
］
⇒
~IF［
%先祖 は`固定的に位置され$た子孫~用に`包含塊$を確立する
【`固定d位置決め包含塊$を確立する？】
］
⇒
~RET %先祖
◎
↑ If ancestor is not closed-shadow-hidden from the element＼
and satisfies at least one of the following, terminate this algorithm and return ancestor.
• The element is in a fixed position containing block,＼
and ancestor is a containing block for fixed-positioned descendants.
</li>
			<li>
<p>
~ELIF［
~OR↓
］…
◎
• ↑ The element is not in a fixed position containing block, and:
</p>
				<ul>
					<li>
%先祖 は`絶対的に位置され$た子孫~用に`包含塊$を確立する
【`絶対~位置決め包含塊$または`固定d位置決め包含塊$を確立する？】
◎
• ancestor is a containing block of absolutely-positioned descendants (regardless of whether there are any absolutely-positioned descendants).
</li>
					<li>
%先祖 ~EQ %~body
◎
• It is the body element.
</li>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
コレの `position$p ~propの算出d値 ~EQ `static^v
</li>
							<li>
%先祖 は次に挙げるいずれかの`~HTML要素$である
⇒
`td^e, `th^e, `table^e
</li>
						</ul>
◎
• The computed value of the position property of the element is static and the ancestor is one of the following HTML elements: td, th, or table.
</li>
				</ul>
<p>
…ならば
⇒
~RET %先祖
</p>
			</li>
			<li>
~ELIF［
コレの`実質的な~zoom$ ~NEQ %先祖 の`実質的な~zoom$
］
⇒
~RET %先祖
◎
• The element has a different effective zoom than ancestor.
◎
↑↑ If there is no more parent of ancestor in the flat tree, terminate this algorithm and return null.
◎
↑↑ Let ancestor be the parent of ancestor in the flat tree.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
［
`offsetTop@m ｜ `offsetLeft@m
］取得子~手続きは：
◎
The offsetTop attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレ ~EQ コレの`~node文書$の`~body要素$
］~OR［
コレは`~box$を有さない
］
⇒
~RET 0
◎
If the element is the body element or does not have any associated box return zero and terminate this algorithm.
</li>
	<li>
以下においては
⇒＃
どの座標も`初期~包含塊$の原点に相対的とする ／
コレとその先祖に対する`変形$は適用しないとする
◎
↓</li>
	<li>
%~border座標 ~LET コレの最初の`~box$の`~border辺$の`無拡縮$な［
上端の~y座標 ｜ 左端の~x座標
］
◎
If the offsetParent of the element is null return the unscaled y-coordinate of the top border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transformsthat apply to the element and its ancestors and terminate this algorithm.
</li>
	<li>
~IF［
コレの `offsetParent$m ~NEQ ~NULL
］
⇒
%~border座標 ~DECBY ( コレの `offsetParent$m の最初の`~box$の`~padding辺$の`無拡縮$な［
上端の~y座標 ｜ 左端の~x座標
］ )
◎
Return the unscaled result of subtracting the y-coordinate of the top padding edge of the first box associated with the offsetParent of the element from the y-coordinate of the top border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</li>
	<li>
~RET %~border座標
◎
↑</li>
</ol>
<p class="note">注記：
複数の行l~boxからなる`行内$要素については、
その最初の`~box$のみが考慮されることになる。
◎
Note: An inline element that consists of multiple line boxes will only have its first box considered.
</p>
</div>

<p class="en">
◎
The offsetLeft attribute must return the result of running these steps:
• If the element is the body element or does not have any associated box return zero and terminate this algorithm.
• If the offsetParent of the element is null return the unscaled x-coordinate of the left border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, and terminate this algorithm.
• Return the unscaled result of subtracting the x-coordinate of the left padding edge of the first box associated with the offsetParent of the element from the x-coordinate of the left border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors.
</p>

<div class="algo">
<p>
［
`offsetWidth@m ｜ `offsetHeight@m
］取得子~手続きは：
◎
The offsetWidth attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレは`~box$を有さない
］
⇒
~RET 0
◎
If the element does not have any associated box return zero and terminate this algorithm.
</li>
	<li>
<p>
~RET ［
コレの`首要~box$により生成される各`~box断片$の`~border~box$
］すべてを囲う，［
各辺が軸に整列された限界~box
］の`無拡縮$な［
横幅 ｜ 縦幅
］
— ここで：
◎
Return the unscaled width of the axis-aligned bounding box of the border boxes of all fragments generated by the element’s principal box,＼
</p>
		<ul>
			<li>
コレとその先祖に対する`変形$は適用しないとする。
◎
ignoring any transforms that apply to the element and its ancestors.
</li>
			<li>
要素の`首要~box$が`行内~levelの~box$であって，
ある`塊~level$の子孫により “分割され” ている場合、
そのような子孫により生成される断片のうち［
横幅, 縦幅どちらも 0 でないもの
］も含めるとする。
◎
If the element’s principal box is an inline-level box which was "split" by a block-level descendant, also include fragments generated by the block-level descendants, unless they are zero width or height.
</li>
		</ul>
	</li>
</ol>
</div>

<p class="en">
◎
The offsetHeight attribute must return the result of running these steps:
• If the element does not have any associated box return zero and terminate this algorithm.
• Return the unscaled height of the axis-aligned bounding box of the border boxes of all fragments generated by the element’s principal box, ignoring any transforms that apply to the element and its ancestors.
• If the element’s principal box is an inline-level box which was "split" by a block-level descendant, also include fragments generated by the block-level descendants, unless they are zero width or height.
</p>

	</section>
	<section id="excensions-to-the-htmlimageelement-interface">
<h2 title="Extensions to the HTMLImageElement Interface">8. `HTMLImageElement^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `HTMLImageElement$I {`HTMLImageElement^I0
  readonly attribute `long$ `x$m;
  readonly attribute `long$ `y$m;
};
</pre>

<div class="algo">
<p>
［
`x@m ｜ `y@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレは`~box$を有さない
］
⇒
~RET 0
</li>
	<li>
~RET `初期~包含塊$の原点に相対的な［
コレの最初の`~box$の`~border辺$
］の`有拡縮$な［
左端の~x座標 ｜ 上端の~y座標
］］
— ここで、
コレとその先祖に対する`変形$は適用しないとする。
</li>
</ol>
◎
The x attribute, on getting, must return the scaled x-coordinate of the left border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no box.
◎
The y attribute, on getting, must return the scaled y-coordinate of the top border edge of the first box associated with the element, relative to the initial containing block origin, ignoring any transforms that apply to the element and its ancestors, or zero if there is no box. 
</div>

	</section>
	<section id="extensions-to-the-range-interface">
<h2 title="Extensions to the Range Interface">9. `Range^I ~interfaceに対する拡張</h2>

<pre class="idl">
partial interface `Range$I {`Range^I0
  `DOMRectList$I `getClientRects$m();
  [`NewObject$] `DOMRect$I `getBoundingClientRect$m();
};
</pre>

`Range^dgm

<div class="algo">
<p>
`getClientRects()@m
~method手続きは：
◎
The getClientRects() method, when invoked, must＼
</p>
<ol>
	<li>
~IF［
コレは文書~内を指していない
］
⇒
~RET 空な `DOMRectList$I ~obj
◎
return an empty DOMRectList object if the range is not in the document and＼
</li>
	<li>
<p>
~RET ［
次の拘束に合致する `DOMRect$I ~obj
］たちが成す，内容~順の~listを包含する `DOMRectList$I ~obj：
◎
otherwise a DOMRectList object containing a list of DOMRect objects in content order that matches the following constraints:
</p>
		<ul>
			<li>
コレに`包含され$ている各 %要素 に対する
⇒
［
%要素 の `Element^I1`getClientRects$m1 ~method手続き()
］の結果に含まれる`~border区画$たち
◎
For each element selected by the range, whose parent is not selected by the range, include the border areas returned by invoking getClientRects() on the element.
</li>
			<li>
<p>
コレに［
`部分的に包含され$ているか`包含され$ている†
］各 `Text$I ~node
（`始端$rGと`終端$rGが同じになるものも含まれる）に対する
⇒
（行l~box全体ではなく）選択された部分のみを囲む`有拡縮$な `DOMRect$I ~obj
◎
For each Text node selected or partially selected by the range (including when the boundary-points are identical), include scaled DOMRect object (for the part that is selected, not the whole line box).＼
</p>

<p class="trans-note">【†
`包含され$ている要素~内の `Text^I ~nodeも除外されないことになる。
】</p>

<p>
これらの `DOMRect$I ~objの限界域は、
~font計量を利用して算出される。
したがって，横書きの下では、
各~boxの［
縦幅は~fontの~ascentと~descent／
横幅は~textの送り幅
］から決定される。
コレの`中身$が `~typographic文字~単位$ `CSS-TEXT-3$r を部分的に含む場合
（例： 代用対の片割れや書記素~clusterの一部分）、
限界域を算出する目的においては，その`~typographic文字~単位$を全部的に含めるモノトスル。
要素の先祖に対する`変形$は、
適用される。
◎
The bounds of these DOMRect objects are computed using font metrics; thus, for horizontal writing, the vertical dimension of each box is determined by the font ascent and descent, and the horizontal dimension by the text advance width. If the range covers a partial typographic character unit (e.g. half a surrogate pair or part of a grapheme cluster), the full typographic character unit must be included for the purpose of computing the bounds of the relevant DOMRect. [CSS-TEXT-3] The transforms that apply to the ancestors are applied.
</p>

<p class="trans-note">【
“送り幅（ `advance^en ）”
— 対象~textが描画される起点から，後続の~textが同じ行lに描画されるとするときの，その起点までの長さ
】</p>
			</li>
		</ul>
	</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect objects returned by getClientRects() are not live.
</p>
</div>

<div class="algo">
<p>
`getBoundingClientRect()@m
~method手続きは：
◎
The getBoundingClientRect() method, when invoked, must return the result of the following algorithm:
</p>
<ol>
	<li>
%~list ~LET コレの `getClientRects$m ~method手続き()
◎
Let list be the result of invoking getClientRects() on the same range this method was invoked on.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET 新たな `DOMRect$I ~obj
— その
⇒
［
`x^m, `y^m, `width^m, `height^m
］属性 ~SET 0
◎
If list is empty return a DOMRect object whose x, y, width and height members are zero.
</li>
	<li>
~IF［
%~list を成す矩形は，どれも［
横幅, 縦幅
］どちらかは 0
］
⇒
~RET %~list を成す最初の矩形
◎
If all rectangles in list have zero width or height, return the first rectangle in list.
</li>
	<li>
~RET 次を表現する新たな `DOMRect$I ~obj
⇒
次をすべてを包含する最~小な矩形
⇒
%~list を成す矩形のうち［
横幅, 縦幅
］どちらかは【どちらも？】 0 でないもの
◎
Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in list of which the height or width is not zero.
</li>
</ol>

<p class="note">注記：
この~methodが返す `DOMRect$I ~objは、
`~live$でない。
◎
Note: The DOMRect object returned by getBoundingClientRect() is not live.
</p>
</div>

	</section>
	<section id="extensions-to-the-mouseevent-interface">
<h2 title="Extensions to the MouseEvent Interface">10. `MouseEvent^I ~interfaceに対する拡張</h2>

<p class="issue">
この~IDL片は、
一部の~memberを定義し直している。
これをどうにか解決できないか？
◎
The object IDL fragment redefines some members. Can we resolve this somehow?
</p>

<pre class="idl">
partial interface `MouseEvent$I {`MouseEvent^I0
  readonly attribute `double$ `screenX$m;
  readonly attribute `double$ `screenY$m;
  readonly attribute `double$ `pageX$m;
  readonly attribute `double$ `pageY$m;
  readonly attribute `double$ `clientX$m;
  readonly attribute `double$ `clientY$m;
  readonly attribute `double$ `x$m;
  readonly attribute `double$ `y$m;
  readonly attribute `double$ `offsetX$m;
  readonly attribute `double$ `offsetY$m;
};

partial dictionary `MouseEventInit$I {
  `double$ `screenX@mb = 0.0;
  `double$ `screenY@mb = 0.0;
  `double$ `clientX@mb = 0.0;
  `double$ `clientY@mb = 0.0;
};
</pre>

`MouseEvent^dgm

`MouseEvent^I0

<div class="algo">
［
`screenX@m ｜ `screenY@m
］取得子~手続きは
⇒
~RET `~Webに公開される~screen区画$の原点に相対的な，コレが生じた位置の［
~x座標 ｜ ~y座標
］
◎
The screenX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
◎
The screenY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the Web-exposed screen area.
</div>

<div class="algo">
<p>
［
`pageX@m ｜ `pageY@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
`初期~包含塊$の原点に相対的な，コレが生じた位置の［
~x座標 ｜ ~y座標
］
</li>
	<li>
%offset ~LET 0
</li>
	<li>
~IF［
コレに結付けられた `Window$I ~obj %window 【！＊】は在る
］
⇒
%offset ~SET %window の［
`scrollX$m1 ｜ `scrollY$m1
］取得子~手続き()
</li>
	<li>
%offset ~INCBY コレの［
`clientX$m ｜ `clientY$m
］取得子~手続き()
</li>
	<li>
~RET %offset
</li>
</ol>
◎
The pageX attribute must follow these steps:
• If the event’s dispatch flag is set, return the horizontal coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollX attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientX attribute. 
◎
The pageY attribute must follow these steps:
• If the event’s dispatch flag is set, return the vertical coordinate of the position where the event occurred relative to the origin of the initial containing block and terminate these steps.
• Let offset be the value of the scrollY attribute of the event’s associated Window object, if there is one, or zero otherwise.
• Return the sum of offset and the value of the event’s clientY attribute. 
</div>

<div class="algo">
［
`clientX@m ｜ `clientY@m
］取得子~手続きは
⇒
~RET `表示域$の原点に相対的な，コレが生じた位置の［
~x座標 ｜ ~y座標
］
◎
The clientX attribute must return the x-coordinate of the position where the event occurred relative to the origin of the viewport.
◎
The clientY attribute must return the y-coordinate of the position where the event occurred relative to the origin of the viewport.
</div>

<div class="algo">
［
`x@m ｜ `y@m
］取得子~手続きは、［
`clientX$m ｜ `clientY$m
］取得子~手続きと同じに挙動する。
◎
The x attribute must return the value of clientX.
◎
The y attribute must return the value of clientY.
</div>

<div class="algo">
<p>
［
`offsetX@m ｜ `offsetY@m
］取得子~手続きは：
◎
The offsetX attribute must follow these steps:
</p>
<ol>
	<li>
<p>
~IF［
コレの`配送-中か$ev ~EQ ~T
］：
</p>
		<ol>
			<li>
~Assert：
コレの`~target$ ~NEQ ~NULL
</li>
			<li>
~RET 
要素とその先祖に対する`変形$は適用しない下で，
コレの`~target$の`~padding辺$の原点に相対的な，コレが生じた位置の［
~x座標 ｜ ~y座標
］
</li>
		</ol>
<p class="trans-note">【
この段おける~targetへの~linkおよび ~Assert は、
この訳による補完。
】</p>
◎
If the event’s dispatch flag is set, return the x-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
</li>
	<li>
~RET コレの［
`pageX$m ｜ `pageY$m
］取得子~手続き()
◎
Return the value of the event’s pageX attribute. 
</li>
</ol>
</div>

<p class="en">
◎
The offsetY attribute must follow these steps:
• If the event’s dispatch flag is set, return the y-coordinate of the position where the event occurred relative to the origin of the padding edge of the target node, ignoring the transforms that apply to the element and its ancestors, and terminate these steps.
• Return the value of the event’s pageY attribute. 
</p>

	</section>
	<section id="geometry">
<h2 title="Geometry">11. 幾何</h2>

<p class="trans-note">【
現時点で，この節を実装している~UAは無い。
】</p>

		<section id="the-geometryutils-interface">
<h3 title="The GeometryUtils Interface">11.1. `GeometryUtils^I ~interface</h3>

<pre class="idl">
enum `CSSBoxType@I { `margin@l, `border@l, `padding@l, `content@l };
dictionary `BoxQuadOptions@I {
  `CSSBoxType$I `box@mb = `border$l;
  `GeometryNode$I `relativeTo@mb; // XXX default document (i.e. viewport)
};

dictionary `ConvertCoordinateOptions@I {
  `CSSBoxType$I `fromBox@mb = `border$l;
  `CSSBoxType$I `toBox@mb = `border$l;
};

interface mixin `GeometryUtils@I {
  `sequence$&lt;`DOMQuad$I&gt; `getBoxQuads$m(
      optional `BoxQuadOptions$I %options = {}
  );
  `DOMQuad$I `convertQuadFromNode$m(
      `DOMQuadInit$I %quad,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMQuad$I `convertRectFromNode$m(
      `DOMRectReadOnly$I %rect,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  );
  `DOMPoint$I `convertPointFromNode$m(
      `DOMPointInit$I %point,
      `GeometryNode$I %from,
      optional `ConvertCoordinateOptions$I %options = {}
  ); // XXX z,w turns into 0
};
 
`Text$I includes `GeometryUtils$I; // like Range
`Element$I includes `GeometryUtils$I;
`CSSPseudoElement$I includes `GeometryUtils$I;
`Document$I includes `GeometryUtils$I;

typedef (`Text$I or `Element$I or `CSSPseudoElement$I or `Document$I) `GeometryNode@I;
</pre>

<div class="algo">
<p>
`getBoxQuads(options)@m
~method手続きは：
◎
The getBoxQuads(options) method must run the following steps:
</p>
<ol>
	<li class="issue" lang="en">
DOM order
<p>p1 = top left even in RTL
<p>scale to 0 means divide by zero, return 0x0
<p>cross-frames not allowed, throw WrongDocumentError?
<p>points are flattened (3d transform), z=0. like getClientRect
<p>test block in inline
<p>pseudo-elements before/after are children of the element
<p>viewport boxes are all the same
</li>
</ol>
</div>

<div class="algo">
`convertQuadFromNode(quad, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertQuadFromNode(quad, from, options) method must run the following steps:
</div>

<div class="algo">
`convertRectFromNode(rect, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertRectFromNode(rect, from, options) method must run the following steps:
</div>

<div class="algo">
`convertPointFromNode(point, from, options)@m
~method手続きは
<span class="issue">【未策定】</span>
◎
The convertPointFromNode(point, from, options) method must run the following steps:
</div>

		</section>
	</section>
	<section id="visualViewport">
<h2 title="VisualViewport">12. `VisualViewport^I</h2>

		<section id="the-visualviewport-interface">
<h3 title="The VisualViewport Interface">12.1. `VisualViewport^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `VisualViewport@I : `EventTarget$I {`VisualViewport^I0
  readonly attribute `double$ `offsetLeft$m;
  readonly attribute `double$ `offsetTop$m;

  readonly attribute `double$ `pageLeft$m;
  readonly attribute `double$ `pageTop$m;

  readonly attribute `double$ `width$m;
  readonly attribute `double$ `height$m;

  readonly attribute `double$ `scale$m;

  attribute `EventHandler$I `onresize$m;
  attribute `EventHandler$I `onscroll$m;
  attribute `EventHandler$I `onscrollend$m;
};
</pre>

<p>
`VisualViewport$I ~objは、
`視覚-表示域$を表現する。
</p>

<p>
`VisualViewport$I ~obj %O に
`結付けられた文書@vV
は、
%O に`関連な大域~obj$（ある `Window$I ）【！owner Window】に`結付けられた文書$を指す。
`~layout表示域$は、
この大域~objの`表示域$になる。
</p>

<p>
以下の記述に現れる［
当の`視覚-表示域$ ／
当の`~layout表示域$
］は、［
当の~obj（コレ）が表現している`視覚-表示域$ ／
その`~layout表示域$
］を指すとする。
</p>

<p class="trans-note">【
上の 3 つの段落のうち［
2 個目は 他所からここへ移動した／
他は この訳による補完
］。
】</p>

<div class="algo">
<p>
［
`offsetLeft@m ｜ `offsetTop@m
］
取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレに`結付けられた文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
</li>
	<li>
~RET 当の`~layout表示域$の［
左端｜上端
］辺から当の`視覚-表示域$の［
左端｜上端
］辺までの~offset
</li>
</ol>

◎
The offsetLeft attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the left edge of the visual viewport from the left edge of the layout viewport.
◎
The offsetTop attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the top edge of the visual viewport from the top edge of the layout viewport.
</div>

<div class="algo">
<p>
［
`pageLeft@m ｜ `pageTop@m
］取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレに`結付けられた文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
</li>
	<li>
~RET コレに`結付けられた文書$vV【！`~layout表示域$の`文書$】の`初期~包含塊$の［
左端｜上端
］辺から当の`視覚-表示域$の［
左端｜上端
］辺までの~offset
</li>
</ol>

◎
The pageLeft attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the left edge of the visual viewport from the left edge of the initial containing block of the layout viewport’s document.
◎
The pageTop attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the offset of the top edge of the visual viewport from the top edge of the initial containing block of the layout viewport’s document.
</div>

<div class="algo">
<p>
［
`width@m ｜ `height@m
］取得子~手続きは：
◎
The width attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`結付けられた文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
◎
If the visual viewport’s associated document is not fully active, return 0.
</li>
	<li>
~RET 当の`視覚-表示域$の［
`実効~横幅$｜`実効~縦幅$
］†
◎
Otherwise, return the width of the visual viewport excluding the width of any rendered vertical classic scrollbar that is fixed to the visual viewport.
</li>
</ol>

<p class="note">注記：
結果の値は，
`px$u 単位なので、［
`~page~zoom$／`拡縮率$vV
］が増大したときは，減少することになる。
◎
Note: Since this value is returned in CSS pixels, the value will decrease in magnitude if either page zoom or the scale factor is increased.
</p>

<p class="note">注記†：
この~sizeから除外される`古典~scrollbar$は、
`視覚-表示域$に “固定されて” 描画される
— すなわち、
視覚-表示域が~zoomされても~panされても，その［
~size, 所在
］は変化しない。
【この仕様は、~UAがそのように描画するものと見做している。】
この値は `px$u 単位なので、
~UAは，［
~scrollbarの［
横幅／縦幅
］を除外する
］ときは［
`px$u 単位で測定した結果
］を織り込むモノトスル。
すなわち、
除外される量は［
拡大するときは減少する／
縮小するときは増大する
］。
◎
Note: A scrollbar that is fixed to the visual viewport is one that does not change size or location as the visual viewport is zoomed and panned. Because this value is in CSS pixels, when excluding the scrollbar width the UA must account for how large the scrollbar is as measured in CSS pixels. That is, the amount excluded decreases when zooming in and increases when zooming out.
</p>
</div>
<p class="en">
◎
The height attribute must run these steps:
• If the visual viewport’s associated document is not fully active, return 0.
• Otherwise, return the height of the visual viewport excluding the height of any rendered horizontal classic scrollbar that is fixed to the visual viewport.
</p>

<div class="algo">
<p>
`scale@m
取得子~手続きは：
◎
The scale attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレに`結付けられた文書$vVは`全部的に作動中$でない
］
⇒
~RET 0
◎
If the visual viewport’s associated document is not fully active, return 0 and abort these steps.
</li>
	<li>
~IF［
出力~機器は無い
］
⇒
~RET 1
◎
If there is no output device, return 1 and abort these steps.
</li>
	<li>
~RET 当の`視覚-表示域$の`拡縮率$vV
◎
Otherwise, return the visual viewport’s scale factor.
</li>
</ol>
</div>

<p>
`onresize@m
は、
`resize$et ~event用の`~event~handler~IDL属性$である。
◎
onresize is the event handler IDL attribute for the resize event.
</p>

<p>
`onscroll@m
は、
`scroll$et ~event用の`~event~handler~IDL属性$である。
◎
onscroll is the event handler IDL attribute for the scroll event.
</p>

<p>
`onscrollend@m
は、
`scrollend$et ~event用の`~event~handler~IDL属性$である。
◎
onscrollend is the event handler IDL attribute for the scrollend event.
</p>

		</section>
	</section>
	<section id="events">
<h2 title="Events">13. ~event</h2>

		<section id="resizing-viewports">
<h3 title="Resizing viewports">13.1. 表示域の~size変更</h3>

<p>
この節は、
`HTML$r に定義される`描画を更新する手続き$【！`~event~loop$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<div class="algo">
<p>
`文書の~resize手続き@
は、
所与の
( `文書$ %文書 )
に対し：
◎
When asked to run the resize steps for a Document doc, run these steps:
</p>
<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
【この段は、この訳による補完。】
</li>
	<li>
<p>
~IF［
当の`表示域$の［
横幅／縦幅
］は、
この手続きを最後に走らせたときから変化した†
］
⇒
`~eventを発火する$( %文書 を結付けている `Window$I ~obj, `resize$et )
</p>

<p>†
例
⇒＃
利用者が~browserの~UIwindowを~resizeしたとき／
`~page~zoom$が変化したとき／
`iframe^e 要素の寸法が変化したとき
</p>
◎
If doc’s viewport has had its width or height changed (e.g. as a result of the user resizing the browser window, or changing page zoom, or an iframe element’s dimensions are changed) since the last time these steps were run, fire an event named resize at the Window object associated with doc.
</li>
	<li>
%視覚-表示域 ~LET %文書 が結付けられた `VisualViewport$I
◎
↓</li>
	<li>
`VisualViewport^I1
~IF［
%視覚-表示域 の［
`scale$m ／ `width$m ／ `height$m
］~propは、
この手続きを最後に走らせたときから変化した
］
⇒
`~eventを発火する$( %視覚-表示域, `resize$et )
◎
If the VisualViewport associated with doc has had its scale, width, or height properties changed since the last time these steps were run, fire an event named resize at the VisualViewport.
</li>
</ol>
</div>

		</section>
		<section id="scrolling-events">
<h3 title="Scrolling">13.2. ~scroll法</h3>

<p>
この節は、
`HTML$r に定義される`描画を更新する手続き$【！`~event~loop$】に統合されている。
◎
This section integrates with the event loop defined in HTML. [HTML]
</p>

<p>
各`文書$には、
`処理待ち~scroll~event群@doc
が結付けられる
— それは、［
( `EventTarget$I, 文字列【！DOMString】 ) が成す~pair
］たちが成す~listであり，
初期~時は空とする。
◎
Each Document has an associated list of pending scroll events, which stores pairs of (EventTarget, DOMString), initially empty.
</p>

<p class="trans-note">【
この~listを成す~itemどうしの比較は、
成分ごとに基づく（ ~IN などに影響する）。
】</p>

<div class="algo">
<p>
~UAは、［
`表示域$／要素
］が~scrollされたときは
（利用者-ヤリトリ, ~APIのどちらによるかを問わず），
次を走らすモノトスル：
</p>
<ol>
	<li>
%~target ~LET ［
表示域, 要素
］どちらを~scrollしているかに応じて
⇒＃
表示域ならば，それに結付けられた`文書$ ／
要素ならば，当の要素
</li>
	<li>
%文書 ~LET %~target の`~node文書$
</li>
	<li>
~IF［
%~target は`~scroll留め容器$である
］
⇒
`~scrollsnapchanging_ev~target群を更新する$( ↓ )
⇒＃
%~target,
塊~軸における %~target の`最終的な留め~target$,
行内~軸における %~target の`最終的な留め~target$
</li>
	<li>
%~target群 ~LET %文書 の`処理待ち~scroll~event群$doc
</li>
	<li>
~IF［
( %~target, `scroll^l† ) ~IN %~target群
］
⇒
~RET
</li>
	<li>
%~target群 に ( %~target, `scroll^l† ) を付加する
</li>
</ol>

<p class="trans-note">【†
原文は %~target が要素である場合に何も指定していないが、
`scroll^l であろう。
】</p>
◎
Whenever a viewport gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
• Let doc be the viewport’s associated Document.
• If doc is a snap container, run the steps to update scrollsnapchanging targets for doc with doc’s eventual snap target in the block axis as newBlockTarget and doc’s eventual snap target in the inline axis as newInlineTarget.
• If (doc, "scroll") is already in doc’s pending scroll events, abort these steps.
• Append (doc, "scroll") to doc’s pending scroll events.
◎
Whenever an element gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
• Let doc be the element’s node document.
• If the element is a snap container, run the steps to update scrollsnapchanging targets for the element with the element’s eventual snap target in the block axis as newBlockTarget and the element’s eventual snap target in the inline axis as newInlineTarget.
• If the element is already in doc’s pending scroll events, abort these steps.
• Append the element to doc’s pending scroll events.
</div>

<div class="algo">
<p>
~UAは、
`視覚-表示域$が~scrollされたときは
（利用者-ヤリトリ, ~APIのどちらによるかを問わず），
次を走らすモノトスル：
◎
Whenever a visual viewport gets scrolled (whether in response to user interaction or by an API), the user agent must run these steps:
</p>
<ol>
	<li>
%vv ~LET ~scrollされた`視覚-表示域$を表現する `VisualViewport$I ~obj
◎
Let vv be the VisualViewport object that was scrolled.
</li>
	<li>
%~target群 ~LET %vv に`結付けられた文書$vVの`処理待ち~scroll~event群$doc
◎
Let doc be vv’s associated document.
◎
↓</li>
	<li>
~IF［
( %vv, `scroll^l ) ~IN %~target群
］
⇒
~RET
◎
If (vv, "scroll") is already in doc’s pending scroll events, abort these steps.
</li>
	<li>
%~target群 に ( %vv, `scroll^l ) を付加する
◎
Append (vv, "scroll") to doc’s pending scroll events.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書の~scroll手続き@
は、
所与の
( `文書$ %文書 )
に対し：
◎
When asked to run the scroll steps for a Document doc, run these steps:
</p>

<p class="issue">
`scrollend^et ~eventは、
~scrollの［
開始, 完了
］どちらに基づく順序で配送されるのか？
◎
In what order are scrollend events dispatched? Ordered based on scroll start or scroll completion?
</p>

<ol>
	<li>
~Assert：
%文書 は`全部的に作動中$である。
【この段は、この訳による補完。】
</li>
	<li>
%~target群 ~LET %文書 の`処理待ち~scroll~event群$doc
◎
↓</li>
	<li>
<p>
~scrollされた
~EACH( `~scrollされる~box$ %~box )
に対し：
◎
For each scrolling box box that was scrolled:
</p>
		<ol>
			<li>
%~target ~LET %~box の所属に応じて
⇒＃
`表示域$であるならば %~target が結付けられた`文書$／
`視覚-表示域$であるならば %~target を表現している `VisualViewport$I ~obj／
要素であるならば %~target
◎
↓</li>
			<li>
%文書 ~LET %~target に応じて
⇒＃
`VisualViewport$I ~objであるならば %~target に`結付けられた文書$vV／
~ELSE_ %~target の`~node文書$
◎
If box belongs to a viewport, let doc be the viewport’s associated Document and target be the viewport. If box belongs to a VisualViewport, let doc be the VisualViewport’s associated document and target be the VisualViewport. Otherwise, box belongs to an element and let doc be the element’s node document and target be the element.
</li>
			<li>
~IF［
%~box の`~scroll留め容器$ %留め容器 は在る
］
⇒
`~scrollsnapchange_ev~target群を更新する$( %留め容器 )
◎
If box belongs to a snap container, snapcontainer, run the update scrollsnapchange targets steps for snapcontainer.
</li>
			<li>
~IF［
( %~target, `scrollend^l ) ~IN %~target群
］
⇒
~RET
◎
If (target, "scrollend") is already in doc’s pending scroll events, abort these steps.
</li>
			<li>
%~target群 に ( %~target, `scrollend^l ) を付加する
◎
Append (target, "scrollend") to doc’s pending scroll events.
</li>
		</ol>
	</li>
	<li>
<p>
%~target群 を成す
~EACH( ( %~target, %型 ) )
に対し：
【！不要：in the order they were added to the list】
◎
For each item (target, type) in doc’s pending scroll events, in the order they were added to the list, run these substeps:
</p>
		<ol>
			<li>
~IF［
%~target は`文書$である
］~AND［
%型 ~IN { `scroll^l, `scrollend^l }
］
⇒
`~eventを発火する$( %~target, %型 )
— 次のように初期化して
⇒＃
`bubbles^m 属性 ~SET ~T【！bubbles】
◎
If target is a Document, and type is "scroll" or "scrollend", fire an event named type that bubbles at target.
</li>
			<li>
<p>
~ELIF［
%型 ~EQ `scrollsnapchange^l
］：
◎
Otherwise, if type is "scrollsnapchange", then:
</p>
				<ol>
					<li>
%塊~target ~LET %~target に結付けられた`~scrollsnapchange_ev塊-軸~target$
◎
↓</li>
					<li>
%行内~target ~LET %~target に結付けられた`~scrollsnapchange_ev行内-軸~target$
◎
Let blockTarget and inlineTarget be null initially.
</li>
					<li>
~IF［
%塊~target は疑似要素である
］
⇒
%塊~target ~SET %塊~target を所有している要素【`最終的な出自の要素$（以下同様）】
◎
If the scrollsnapchangeTargetBlock associated with target is a pseudo-element, set blockTarget to the owning element of that scrollsnapchangeTargetBlock.
◎
Otherwise, set blockTarget to that scrollsnapchangeTargetBlock.
</li>
					<li>
~IF［
%行内~target は疑似要素である
］
⇒
%行内~target ~SET %行内~target を所有している要素
◎
If the scrollsnapchangeTargetInline associated with target is a pseudo-element, set inlineTarget to the owning element of that scrollsnapchangeTargetInline.
◎
Otherwise, Set inlineTarget to that scrollsnapchangeTargetInline.
</li>
					<li>
`~eventを発火する$( %~target, `scrollsnapchange$et, `SnapEvent$I )
— 次のように初期化して
⇒＃
`snapTargetBlock$m 属性 ~SET %塊~target,
`snapTargetInline$m 属性 ~SET %行内~target
◎
Fire a SnapEvent, snapevent, named scrollsnapchange at target and let snapevent’s snapTargetBlock and snapTargetInline attributes be blockTarget and inlineTarget respectively.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%型 ~EQ `scrollsnapchanging^l
］：
◎
Otherwise, if type is "scrollsnapchanging", then:
</p>
				<ol>
					<li>
%塊~target ~LET %~target に結付けられた`~scrollsnapchanging_ev塊-軸~target$
◎
↓</li>
					<li>
%行内~target ~LET %~target に結付けられた`~scrollsnapchanging_ev行内-軸~target$
◎
Let blockTarget and inlineTarget be null initially.
</li>
					<li>
~IF［
%塊~target は疑似要素である
］
⇒
%塊~target ~SET %塊~target を所有している要素
◎
If the scrollsnapchanging block-axis target associated with target is a pseudo-element, set blockTarget to the owning element of that scrollsnapchanging block-axis target.
◎
Otherwise, set blockTarget to that scrollsnapchanging block-axis target.
</li>
					<li>
~IF［
%行内~target は疑似要素である
］
⇒
%行内~target ~SET %行内~target を所有している要素
◎
If the scrollsnapchanging inline-axis target associated with target is a pseudo-element, set inlineTarget to the owning element of that scrollsnapchanging inline-axis target.
◎
Otherwise, set inlineTarget to that scrollsnapchanging inline-axis target.
</li>
					<li>
`~eventを発火する$( %~target, `scrollsnapchanging$et, `SnapEvent$I )
— 次のように初期化して
⇒＃
`snapTargetBlock$m 属性 ~SET %塊~target,
`snapTargetInline$m 属性 ~SET %行内~target
◎
Fire a SnapEvent, snapevent, named scrollsnapchanging at target and let snapevent’s snapTargetBlock and snapTargetInline attributes be blockTarget and inlineTarget, respectively.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`~eventを発火する$( %~target, %型 )
◎
Otherwise, fire an event named type at target.
</li>
		</ol>
<p class="trans-note">【
原文は，この段の中の入子な階層がきちんと~mark-upされていないので、
この訳では修正してある。
】</p>
	</li>
	<li>
%~target群 を`空にする$
◎
Empty doc’s pending scrollend event targets.
</li>
</ol>
</div>

<p>
~UAは、
~scrollを`完了-$したときは，
次の手続きを走らすモノトスル【… 以下，原文には記述が無い。】
◎
Whenever scrolling is completed, the user agent must run these steps:
</p>

		</section>
		<section id="event-summary">
<h4 title="Event summary">13.3. ~event要約</h4>

◎非規範的

<div>
<table class="grid-table" id="_event-table"><thead>
<tr><th>~event
<th>~interface
<th>~target
<th>記述
<tbody>

<tr><td>`resize@et
<td>`Event$I
<td>`Window$I, `VisualViewport$I
<td>
<p>
［
`表示域$／`視覚-表示域$
］が~resizeされたとき，
当の［
`Window$I ／ `VisualViewport$I
］に向けて発火される。
</p>
<p>
`視覚-表示域$の`~layout表示域$が拡縮されたとき，
当の `VisualViewport$I に向けて発火される。
</p>

<tr><td>`scroll@et
<td>`Event$I
<td>`VisualViewport$I, `Document$I, `Element$I
<td>
［
`視覚-表示域$／`表示域$／要素
］が~scrollされたとき，
当の［
`VisualViewport$I ／ `Document$I ／ `Element$I
］に向けて発火される。

<tr><td>`scrollend@et
<td>`Event$I
<td>`VisualViewport$I, `Document$I, `Element$I
<td>
［
`視覚-表示域$／`表示域$／要素
］が~scrollされ，`完了-$したとき
— すなわち、
~scrollが終止して，~scroll~offsetの変化が適用された後に —
当の［
`VisualViewport$I ／ `Document$I ／ `Element$I
］に向けて発火される。
</table>
◎
Event｜Interface｜Interesting targets｜Description
◎
resize｜Event｜Window, VisualViewport｜Fired at the Window when the viewport is resized. Fired at VisualViewport when the visual viewport is resized or the layout viewport is scaled.
scroll｜Event｜VisualViewport, Document, elements｜Fired at the VisualViewport, Document or element when the VisualViewport, viewport, or element is scrolled, respectively.
scrollend｜Event｜Document, elements, VisualViewport｜Fired at the VisualViewport, Document, or element when a scroll is completed: the VisualViewport, viewport, or element has been scrolled, the scroll sequence has ended and any scroll offset changes have been applied.
</div>

		</section>
	</section>
	<section id="post-layout-snapshot">
<h2 title="Post-Layout State Snapshotting">14. ~layout後の状態の~snapshot法</h2>

<p>
~scroll位置の様な一部の~CSS特能は、
次回の［
~style, ~layout
］更新に対する入力として，~layout後の状態を利用する。
◎
Some CSS features use post-layout state, like scroll position, as input to the next style and layout update.
</p>

<div class="algo">
<p>
`~layout後の状態を~snapshotする手続き@
は、
所与の
( `Document$I %文書 )
に対し：
◎
When asked to run snapshot post-layout state steps for a Document doc, run these steps:
</p>
<ol>
	<li>
~layout後の状態を~snapshotする必要がある各~CSS特能に対し
⇒
%文書 内の関連な状態の~snapshotをとる
◎
For each CSS feature that needs to snapshot post-layout state, take a snapshot of the relevant state in doc.
</li>
</ol>

<p>
どの状態が~snapshotされるかは、
他の仕様にて定義される。
この手続きは、［
他の~layout後に~snapshotする手続きが，そのような~snapshot法が起きたことを観測し得る仕方
］では［
%文書 や他の `Document$I
］【の状態？】を無効~化しないモノトスル。
したがって、
そのような各~snapshot法が その場を占める順序は，問われてはナラナイ。
◎
The state that is snapshot is defined in other specifications. These steps must not invalidate doc or any other Documents in such a way that other post-layout snapshotting steps can observe that such snapshotting happened. It follows that the order of which such snapshotting takes place must not matter.
</p>
</div>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
`Screen$I ~interfaceは、
利用者の~display環境設定についての情報を公開する
— それは、
指紋収集~algoの入力として利用され得る。
利用者の~privacyを保護するためとして、
~UAは，~screen~sizeや環境設定についての情報を［
隠す／量子化する
］ことを選んでもヨイ。
◎
The Screen interface exposes information about the user’s display configuration, which maybe be used as input to fingerprinting algorithms. User agents may choose to hide or quantize information about the screen size or configuration, in order to protect the user’s privacy.
</p>

<p>
`MouseEvent$I ~eventは、
~screenに相対的な座標についての情報を包含する。
利用者の~privacyを保護するためとして、
~UAは，~eventの そのような~propを［
実際の~screenに相対的な所在
］を隠蔽するような値に設定してもヨイ。
◎
MouseEvent contains information about the screen-relative coordinates of the event. User agents may set these properties to values that obscure the actual screen-relative location of the event, in order to protect the user’s privacy.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この仕様に対し報告された新たな~securityの考慮点は、
無い。
◎
No new security considerations have been reported on this specification.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
この節では、
この仕様の各~公表版の間の変更点の一部を文書化する。
この節は、
網羅的ではない。
~bug修正点や編集上の変更点は、
一般に，挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

<dl>
	<dt id="changes-2016-03-17">
`2016年 3月 17日 作業草案＠~TR/2016/WD-cssom-view-1-20160317/$
からの変更点
◎
Changes since the 17 March 2016 Working Draft
</dt>
	<dd>
［
`Simon Fraser^en, `Emilio Cobos Álvarez^en
］氏を現在の編集者として追加した。
`Simon Pieters^en 氏を前任~編集者へ移動した。
◎
Added Simon Fraser and Emilio Cobos Álvarez as current editors and moved Simon Pieters to former editors.
</dd>
	<dd>
`Range$I の `getClientRects()$m1 が`~typographic文字~単位$をどう取扱うかを明確化した。
◎
Clarified how getClientRects() handles typographic character units.
</dd>
	<dd>
［
`Element$I の `getBoundingClientRect()$m1,
`Range$I の `getBoundingClientRect()$m1
］が空な矩形をどう取扱うかを変更した。
◎
Changed how getBoundingClientRect() of Element and getBoundingClientRect() of Range handle empty rectangles.
</dd>
	<dd>
~shadow~DOM用の［
`HTMLElement$I の `offsetParent$m1 の定義
］を変更した。
◎
Changed definition of offsetParent for Shadow DOM.
</dd>
	<dd>
~UAが［
~privacyの理由から `Screen$I の~propたちについて嘘をつく
］ことを許容した。
【`§ ~Webに公開される~screen情報＠#web-exposed-screen-information$を見よ。】
◎
Allowed UAs to lie about Screen properties for privacy reasons.
</dd>
	<dd>
`Screen$I の［
`colorDepth$m1, `pixelDepth$m1
］を本当の値を返すよう変更した。
◎
Changed colorDepth and pixelDepth to return real values.
</dd>
	<dd>
“~CSS~pixel” は `CSS-VALUES$r を参照rするよう変更した。
◎
Changed 'CSS pixels' to refer to [CSS-VALUES].
</dd>
	<dd>
`ScrollIntoViewOptions$I の［
`block$m1 ／ `inline$m1
］~member用の既定の値を［
`start$l ／ `nearest$l
］に変更した
— それに伴い，
`Element$I の `scrollIntoView()$m1 の挙動を少し変更した。
◎
Changed default values for ScrollIntoViewOptions to start and nearest and slightly changed behavior of scrollIntoView()
</dd>
	<dd>
`Window$I に［
`screenX$m1 ／ `screenY$m1
］の別名として［
`screenLeft$m1 ／ `screenTop$m1
］を追加した。
◎
Added screenLeft and screenTop as aliases for screenX and screenY.
</dd>
	<dd>
~overflow方向を［
`塊-終端$, `行内-終端$
］に基づくよう定義した。
◎
Defined overflow directions in terms of block-end and inline-end.
</dd>
	<dd>
`Window$I の `resizeTo()$m1 の引数を［
%width, %height
］に改称した。
◎
Renamed the arguments to resizeTo() to be width and height
</dd>
	<dd>
`scroll-behavior$p により影響される~scrollたちが成す~listに，
~scriptにより誘発される`~scroll留め＠~CSSSCROLLSNAP#scroll-snap$を追加した。
◎
Added script-triggered scroll-snap to list of scrolls affected by scroll-behavior.
</dd>
	<dd>
`§ 各種用語＠#terminology$
における論理的な誤りを修正した。
◎
Fixed a logical error in the Terminology section.
</dd>
	<dd>
`§ ~security／~privacyの考慮点＠#priv-sec$
を追加した。
◎
Added the "Security and Privacy Considerations" section
</dd>
	<dd>
`scroll-behavior$p ~propを `CSS-OVERFLOW-3$r へ移動した。
◎
Moved the scroll-behavior property to [CSS-OVERFLOW-3]
</dd>
	<dd>
`HTMLElement$I の［
`offsetWidth$m1, `offsetHeight$m1
］用の~algoを調整した。
◎
Adjusted the algorithm for offsetWidth and offsetHeight.
</dd>
	<dd>
`Element$I に `checkVisibility()$m1 ~methodを追加した。
◎
Added checkVisibility() method to Element.
</dd>
	<dd>
`WICG overscroll-scrollend-events＠https://wicg.github.io/overscroll-scrollend-events/$cite から `scrollend$et ~eventを移動して，
それを取扱うための詳細を追加した。
◎
Moved the scrollend event from WICG overscroll-scrollend-events to [CSSOM-VIEW-1] and added details for handling them.
</dd>
	<dd>
`Element$I の `getBoundingClientRect()$m1 に “`要素~用の限界~boxを取得する$” ~algoを追加した。
◎
Added a "get the bounding box" algorithm to getBoundingClientRect().
</dd>
	<dd>
`VisualViewport$I ~APIと関係する概念を導入した。
◎
Introduced the VisualViewport API and related concepts.
</dd>
	<dd>
`~targetを~viewの中へ~scrollする$
~algoを`範囲o$【！`Range$I 】に対しても働くよう拡張した。
◎
Extended scroll into view algorithm to also work on Ranges.
</dd>
	<dd>
各種~APIにより返される寸法が［
`zoom$p ~propとの関係において［
`有拡縮$, `無拡縮$
］どちらになるか
］を明確化した。
◎
Clarified whether scaled or unscaled dimensions are returned by various APIs in relation to the zoom property.
</dd>
	<dd>
各種~scroll用~APIが［
~scroll留め法, ~scroll~target【`最終的な留め~target$？】
］を織り込むようにした。
◎
Took scroll snapping and scroll target into account for various scrolling APIs.
</dd>
	<dd>
`Element$I に `currentCSSZoom$m1 属性を追加した。
◎
Added currentCSSZoom attribute to Element.
</dd>
	<dd>
`Document$I の `caretPositionFromPoint()$m1 ~methodに %options ~parameterを追加した。
◎
Added options parameter to caretPositionFromPoint() method.
</dd>
	<dd>
`CaretPosition$I ~interfaceから~caret範囲の概念を除去した。
◎
Removed caret range concept from CaretPosition interface.
</dd>
	<dd>
`~layout後の~snapshot法＠#post-layout-snapshot$を定義した。
◎
Defined post-layout snapshotting.
</dd>
	<dd>
~scroll用の各種~algoが疑似要素を受容するようにした。
◎
Made the various scrolling algorithms accept a pseudo-element.
</dd>
	<dd>
`ScrollIntoViewOptions$I に `container$m1 ~optionを追加した。
◎
Added container option to ScrollIntoViewOptions.
</dd>
	<dd>
`HTMLElement$I に `scrollParent$m1 属性を追加した。
◎
Added the scrollParent attribute.
</dd>
	<dd>
~pinch~zoomを`拡縮率$vVに改称した。
◎
Pinch zoom got renamed to scale factor.
</dd>

	<dt id="changes-2013-12-17">
`2013年 12月 17日 作業草案＠~TR/2013/WD-cssom-view-20131217/$
からの変更点
◎
Changes since the 17 December 2013 Working Draft
</dt>
	<dd>
`Element$I の `scrollIntoView()$m1 ~methodを変更して拡張した。
◎
The scrollIntoView() method on Element was changed and extended.
</dd>
	<dd>
`Element$I の［
`scrollTop$m1, `scrollLeft$m1
］~IDL属性は、
~objをとらないようにした
— 代わりに［
`scroll()$m1, `scrollTo()$m1, `scrollBy()$m1
］~methodを追加した。
◎
The scrollTop and scrollLeft IDL attributes on Element changed to no longer take an object; the scroll(), scrollTo() and scrollBy() methods were added instead.
</dd>
	<dd>
`Element$I の［
`scrollWidth$m1,
`scrollHeight$m1,
`clientTop$m1,
`clientLeft$m1,
`clientWidth$m1 
`clientHeight$m1
］~IDL属性を~~元の［
整数を返すふるまい
］に戻した。
◎
The scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth and clientHeight IDL attributes on Element were changed back to return integers.
</dd>
	<dd>
`DOMRectList^I ~interfaceを除去した。
◎
The DOMRectList interface was removed.
</dd>
	<dd>
`Document$I に `scrollingElement$m1 ~IDL属性を追加した。
◎
The scrollingElement IDL attribute on Document was added.
</dd>
	<dd>
`Window$I 上の一部の読専（ readonly ）属性に、
[Replaceable] ~IDL拡張d属性で注釈した。
◎
Some readonly attributes on Window were annotated with [Replaceable] IDL extended attribute.
</dd>
	<dd>
［
`MediaQueryList$I,
`scroll$et ~event,
`resize$et ~event
］を
— ~animation~frameに同期するよう —
~HTMLにおける`~event~loop$に統合した。
◎
MediaQueryList, scroll event and resize event are integrated with the event loop in HTML so they are synchronized with animation frames.
</dd>
	<dd>
`scroll-behavior$p の `instant^v 値を `auto^v に改称した。
◎
The instant value of scroll-behavior was renamed to auto.
</dd>
	<dd>
`Element$I の `scrollLeft$m1 の原点を（右横書き用に）変更した。
◎
The origin of scrollLeft on Element was changed (for RTL).
</dd>
	<dd>
`Element$I の `scrollIntoView()$m1 ~method, および
`Window$I の［
`scroll()$m1, `scrollTo()$m1, `scrollBy()$m1
］~methodは、
最初の引数として，関連な辞書~型~値もとれるようにした。
◎
The scrollIntoView() method on Element and scroll(), scrollTo() and scrollBy() methods on Window take the relevant dictionary as the first argument.
</dd>
	<dd>
`MediaQueryList$I ~interfaceを、
定例の~event~APIを利用し，それを通して `addListener()$m1 を定義するよう変更した。
◎
The MediaQueryList interface was changed to use regular event API and define addListener() in terms of that.
</dd>
	<dd>
“変更~履歴” 節を追加した。
◎
Added "Change History" section.
</dd>
	<dd>
`Glenn Adams^en 氏を前任~編集者へ移動した。
◎
Moved Glenn Adams to former editors.
</dd>

	<dt id="changes-2011-08-04">
`2011年 8月 4日 作業草案＠~TR/2011/WD-cssom-view-20110804/$
からの変更点
◎
Changes since the 04 August 2011 Working Draft
</dt>
	<dd>
編集者として［
`Simon Pieters^en, `Glenn Adams^en
］氏を追加した。
`Anne van Kesteren^en 氏を前任~編集者へ移動した。
◎
Added Simon Pieters and Glenn Adams as editors and moved Anne van Kesteren to former editors.
</dd>
	<dd>
`scroll-behavior$p ~CSS~propを導入した。
◎
Introduced scroll-behavior CSS property.
</dd>
	<dd>
`CSS-WRITING-MODES-3$r の各種用語から［
`塊~flow方向$, `行内~基底~方向$
］を追加した。
◎
Added Block flow direction and inline base direction from [CSS-WRITING-MODES-3] to terminology.
</dd>
	<dd>
`§ ~zoom法＠#zooming$
を追加した。
◎
Added section about zooming.
</dd>
	<dd>
`Window$I に［
`moveTo()$m1,
`moveBy()$m1,
`resizeTo()$m1,
`resizeBy()$m1
］~methodを追加した。
◎
Added moveTo(), moveBy(), resizeTo(), and resizeBy() methods to Window.
</dd>
	<dd>
`Window$I に `devicePixelRatio$m1 属性を追加した。
◎
Added devicePixelRatio attribute to Window.
</dd>
	<dd>
`ScrollOptions$I 辞書を導入して，
各種~scroll用~methodに【それを継承する辞書をとる】 %options ~parameterを追加した。
◎
Introduced ScrollOptions dictionary and added an options parameter to scrolling methods.
</dd>
	<dd>
`Window$I に `devicePixelRatio$m1 属性を追加した。
◎
Added devicePixelRatio attribute to Window.
</dd>
	<dd>
`Window$I の `open()$m ~methodに %features ~parameterを追加した。
◎
Added features parameter to open() method.
</dd>
	<dd>
`Document$I に `elementsFromPoint()$m1 ~methodを追加した。
◎
Added elementsFromPoint() method to Document.
</dd>
	<dd>
`CaretPosition$I に `getClientRect()$m1 ~methodを追加した。
◎
Added getClientRect() method to CaretPosition.
</dd>
	<dd>
`GeometryUtils$I ~interfaceの初期~草案を導入した。
◎
Introduced initial draft of GeometryUtils interface.
</dd>
	<dd>
`Window$I の［
`innerWidth$m1, `innerHeight$m1, 等々
］には、
【 `long^c 型ではなく，】 `double^c 型を利用するようにした。
◎
Changed innerWidth, innerHeight, etc. to use double.
</dd>
	<dd>
~CSS`変形$を織り込むようにした。
◎
CSS transforms are now acknowledged.
</dd>
	<dd>
`ClientRect^I を `DOMRect$I に置換した。
◎
Replaced ClientRect by DOMRect.
</dd>
	<dd>
［
`scroll$et, `resize$et
］~eventを発火するときの挙動を定義した。
◎
Defined the firing behavior of scroll and resize events.
</dd>
	<dd>
`Screen$I の［
`colorDepth$m1, `pixelDepth$m1
］属性は、
常に 24 を返すよう変更した。
◎
Changed colorDepth and pixelDepth to always return 24.
</dd>

	<dt id="changes-2009-08-04">
`2009年 8月 4日 作業草案＠~TR/2009/WD-cssom-view-20090804/$
からの変更点
◎
Changes since the 04 August 2009 Working Draft
</dt>
	<dd>
冗長な［
他の仕様の各種用語を成す定義
］
— 単位（例：~CSS~pixel）や［
内容, 文書~内容
］の区別を明示的に定義していたそれ —
を除去した。
◎
Removed redundant definition of terminology of other specifications, explicitly defining units (e.g. CSS pixels) and content/document content distinction.
</dd>
	<dd>
`MediaQueryList$I ~interfaceを導入した。
◎
Introduced MediaQueryList interface.
</dd>
	<dd>
`Media^I の `matchMedium()^c ~methodを
⇒＃
`Window$I ~interfaceへ移動した，
`matchMedia()$m1 に改称した,
返り値の型を `MediaQueryList$I に変更した
◎
Moved the matchMedium() method of the Media to the Window interface, renamed it to matchMedia(), and changed its return type to MediaQueryList.
</dd>
	<dd>
［
`AbstractView^I, `Media^I
］~interfaceを除去した。
◎
Removed the AbstractView and Media interfaces.
</dd>
	<dd>
`DocumentView^I ~interfaceを除去して，［
`elementFromPoint()^m, `caretRangeFromPoint()^m
］~methodを `Document$I ~interfaceへ移動した。
◎
Removed the DocumentView interface and moved methods elementFromPoint() and caretRangeFromPoint() to the Document interface.
</dd>
	<dd>
`Document$I の `caretRangeFromPoint()^m ~methodを `caretPositionFromPoint()$m1 に改称した。
◎
Renamed the caretRangeFromPoint() method to caretPositionFromPoint().
</dd>
	<dd>
`CaretPosition$I ~interfaceを導入して，
`Document$I の `caretPositionFromPoint()$m1 の返り値の型を `CaretPosition$I に変更した。
◎
Introduced CaretPosition interface and changed the return type of caretPositionFromPoint() to CaretPosition.
</dd>
	<dd>
`Element$I ~interfaceに `scrollIntoView()$m1 ~methodを追加した。
◎
Added the scrollIntoView() method to the Element interface.
</dd>

	<dt id="changes-2008-02-22">
`2008年 2月 22日 作業草案＠~TR/2008/WD-cssom-view-20080222/$
からの変更点
◎
Changes since the 22 February 2008 Working Draft
</dt>
	<dd>
`WindowView^I ~interfaceを除去して，その各種［
属性, ~method
］を `AbstractView^I へ移動した，
および `ScreenView^I ~interfaceを継承して【？】。
◎
Removed the WindowView interface and moved its attributes and methods to an AbstractView and inheriting ScreenView interface.
</dd>
	<dd>
`AbstractView^I に
`document^m ~IDL属性を追加した。
◎
Added the document IDL attribute to AbstractView.
</dd>
	<dd>
`ScreenView^I ~interfaceに【今や `Window$I へ移動された】［
`scroll()$m1,
`scrollTo()$m1,
`scrollBy()$m1
］~methodを追加した。
◎
Added the scroll(), scrollTo(), and scrollBy() methods to the ScreenView interface.
</dd>
	<dd>
`ElementView^I ~interfaceを除去して，その各種［
属性, ~method
］を［
`Element$I, `HTMLElement$I
］~interfaceへ移動した。
◎
Removed the ElementView interface and moved its attributes and methods to the Element and HTMLElement interfaces.
</dd>
	<dd>
`DocumentView^I ~interfaceに［
`defaultView^m 属性,
`caretRangeFromPoint()^m ~method
］を追加した。
◎
Added the defaultView IDL attribute and caretRangeFromPoint() method to the DocumentView interface.
</dd>
	<dd>
`RangeView^I ~interfaceを除去した
— 代わりに `Range$I ~interfaceを直に拡張した。
◎
Removed RangeView interface and instead directly extended the Range interface.
</dd>
	<dd>
`MouseEventView^I ~interfaceを除去した
— 代わりに `MouseEvent$I ~interfaceを直に拡張した。
◎
Removed the MouseEventView interface and instead directly extended the MouseEvent interface.
</dd>
	<dd>
`TextRectangleList^I ~interfaceを `ClientRectList^I に改称して，
その `item()^m ~methodを有index取得子に転換した。
◎
Renamed the TextRectangleList interface to ClientRectList and turned the item() method into an indexed getter.
</dd>
	<dd>
`TextRectangle^I ~interfaceを `ClientRect^I に改称して，［
`width^m, `height^m
］属性を追加した。
◎
Renamed the TextRectangle interface to ClientRect and added the width and height attributes.
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この文書に貢献された次の方々に感謝する：
</p>

<p lang="en">
The editors would like to thank

Alan Stearns,
Alexey Feldgendler,
Antonio Gomes,
Björn Höhrmann,
Boris Zbarsky,
Chris Rebert,
Corey Farwell,
Dan Bates,
David Vest,
Elliott Sprehn,
Garrett Smith,
Henrik Andersson,
Hallvord R. M. Steen,
Kang-Hao Lu,
Koji Ishii,
Leif Arne Storset,
Luiz Agostini,
Maciej Stachowiak,
Michael Dyck,
Mike Wilson,
Morten Stenshorne,
Olli Pettay,
Pavel Curtis,
Peter-Paul Koch,
Rachel Kmetz,
Rick Byers,
Robert O’Callahan,
Sam Weinig,
Scott Johnson,
Sebastian Zartner,
Stewart Brodie,
Sylvain Galineau,
Tab Atkins,
Tarquin Wilton-Jones,
Thomas Moore,
Thomas Shinnick,
and
Xiaomei Ji

for their contributions to this document.
</p>

<p>
この草案にて指定された特能の多くを，Windows Internet Explorer ~browserにて最初に実装した Microsoft の人達に特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented many of the features specified in this draft, which were first widely deployed by the Windows Internet Explorer browser.
</p>

	</section>
</main></div>

<div id="_info-view">（クリックで消去）<pre id="_info-box"></pre></div>

