<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>DOM Standard 日本語訳</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>

code > dfn {
	/* for idl */
	color: black;
}

.bp-example {
	display: block;
	margin: 1em 0;
	padding-bottom: 2.5em;
	text-align: center;
	font-size: 0.8em;
	white-space: pre;
	overflow: auto;
	font-family: monospace0, monospace;
	color: #555;
}

bp-node {
	display: inline;
	position: relative;
	top: 6px;
	border-top: solid #AAA 3px;
}

.bp-text {
	border-top-color: red;
	color: red;
}

.bp-x {
	border-top-color: #0C0;
}
.bp-y {
	border-top-color: blue;
}

bp-mark {
	display: inline-block;
	top: 0;
	vertical-align: top;
}

div.trans-note {
	margin: 1em;
	border: solid green 2px;
	padding: 0.5em;
}

/*
	border-left: solid #DDD 1em;
	padding-left: 0.5em;
*/
.domTree samp {
	border: thin solid green;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%内容置換生成 -->
<script>

Util.ready = function(){
	const ifc_names = PAGE_DATA.ifc_names
	.replace(/^\w+$/mg, function(name){
		return name + ':#' + name.toLowerCase();
	});
	delete PAGE_DATA.ifc_names;

	const source_data = {
		ifc_names: Util.get_mapping(ifc_names),
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand,
		populate: populate,
	};

	Util.switchWordsInit(source_data);

/*
	repeat('dl.idl-def > dt', function(e){
		e.replaceWith(C('p'))
	});
	Util.del_j(); //
*/
}

function populate(){
// 要素複製
	const visited = Object.create(null);
	let node, e;
	// Opera requires optional args, null, null
	const itr = document.createNodeIterator(E('MAIN'), NodeFilter.SHOW_COMMENT, null, null);
	while(node = itr.nextNode()){
		const id = node.data;
		if(id.slice(0,3) !== 'cp-') continue;
		e = visited[id];
		if(!e) {
			e = E(id);
			if(e) {
				e.removeAttribute('id');
				visited[id] = e;
			} else {
				console.log('source not found: ' + id);
				continue;
			}
		}
		node.replaceWith(e.cloneNode(true));
	}
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const ifc_names = this.ifc_names;

	let in_idl = false;
	let context_ifc = ''; // prefix 省略時の既定 interface 名

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん？]+|([\^@$]@?)([\w\.]+)(\([ \w,\[\]=…"]*\))?|`(.+?)([\^@$])(\w*)|！+\n?/g,
		create_html
	);

	function create_html(match, ind0, key, args, text, ind2, klass){
		if(text){
			let href;
			key = text;

			klass = klass || '';
			switch(klass){
			case 'r':
				text = `[${text}]`;
				href = `#biblio-${key.toLowerCase()}`;
				break;
			case 'l': // literal
				text = `"<code class="literal">${text}</code>"`;
				break;
			case 'mc': // IDL 内の構築子
				href = `#dom-${text.toLowerCase()}-${text.toLowerCase()}`;
				text = 'constructor';
				break;
			case 'bpex':
				return bpGenerate(text);
				break;
			case 'en': // english words
				return `<span lang="en">${text}</span>`
				break;
			}

			const tag = tag_map[klass];
			if(tag){
				const classname = class_map[klass];
				text = classname ? (
					`<${tag} class="${classname}">${text}</${tag}>`
				):(
					`<${tag}>${text}</${tag}>`
				);
			}

			if(ind2 === '^'){
				return text;
			}
			href = link_map[klass ? klass + '.' + key : key] || href;
			if(!href){
				console.log(match);
				return match;
			}
			switch(ind2){
			case '$':
				return `<a href="${href}">${text}</a>`;
			case '@':
				return `<dfn id="${href.slice(1)}">${text}</dfn>`;
			}
			return match;
		} else if(key){
			// idl constructs
			let text = key, href;
			if(!args && ( key in ifc_names ) ){
				href = ifc_names[key];
				if(ind0.length > 1){
//				if(ind0[1] === '@'){
					context_ifc = key;//.toLowerCase();
				}
			} else {
				let ifc = context_ifc;
				const dot = key.indexOf('.');
				if(dot >=0 ){
					ifc = key.slice(0, dot);
					key = text = key.slice(dot + 1); //text
				}
				if( key === ifc ){
					text = `new ${text}`; // constructor
				}
				href = `#dom-${ifc}-${key}`.toLowerCase();
				if(args){
					text += args.replace(/(\w+)(\s=\s\w+)?/g, '<var>$1</var>$2');
				}
			}
			if(!in_idl){
				text = `<code>${text}</code>`;
			}

			switch(ind0[0]){
			case '^':
				return text;
			case '$':
				return `<a href="${href}">${text}</a>`;
			case '@':
				return `<dfn id="${href.slice(1)}">${text}</dfn>`;
			}
		} else {
			switch(match[0]){
			case '%':
				return `<var>${match.slice(1)}</var>`;
			case '！':
				in_idl = (match[1] === '！' );
				return in_idl ? '<pre class="idl"><code>' : '</code></pre>';
			default:
				return match;
			}
		}
	}

	function bpGenerate(str){
		return '<figure class="bp-example">'
		+ str.replace(/([\|\[\]\(\)])(\w?)/g, function(match, t, w){
			switch(t) {
			case '|':
				return w ? `<bp-mark>|\n<mark>${w}</mark></bp-mark>` : '|';
			case '(':
				return w ? `<bp-node class="bp-${w} bp-text">` : '<bp-node class="bp-text">';
			case '[':
				return w ? `<bp-node class="bp-${w}">` : '<bp-node>';
			case ')':
			case ']':
				return '</bp-node>';
			}
		})
		+ '</figure>';
	}

}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:DOM
spec_date:2021-11-08
trans_update:2021-11-09
source_checked:210831
spec_status:LS
original_url:https://dom.spec.whatwg.org/
	abbr_url:DOM4
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:infrastructure,uievents,html,selector
copyright:,whatwg
trans_1st_pub:2012-01-28

●●class_map
E:error
e:element
A:attr
et:event-type
prod:production
jv:js-value

●●tag_map
b:b
i:i
E:code
e:code
A:code
et:code
prod:code
m:code
c:code
jv:code
V:var
cite:cite
mk:mark

●●words_table1

DOMissue:https://github.com/whatwg/dom/issues

RA:readonly attribute

COLOR_R:<span style="color:red;">赤色区間</span>
COLOR_X:<span style="color:#0C0;">緑色区間</span>
COLOR_Y:<span style="color:blue;">青色区間</span>

TOUCHEVENTS:touch-events-ja.html
	https://www.w3.org/TR/touch-events/#touchevent-interface
DEVICEORIENTATION:deviceorientation-ja.html
CONSOLE:console-ja.html
XNLNS10:xml-names-ja.html
UIEVENTS-A:uievents-appendix-ja.html


Text: <code>Text</code> 
scope-ps: <code class="pseudo">:scope</code> 
is0:<code class="attr">is</code> 
U0020:<span class="code-point">U+0020</span> <span class="cp-name">SPACE</span>
U002A:<span class="code-point">U+002A</span> (<span class="char-symbol">*</span>)
U003A:<span class="code-point">U+003A</span> (<span class="char-symbol">:</span>)


●●words_table

XMLNS:
	●構造／node tree
shadow:
light:
open:
閉な:closed::閉じた
非可視:hidden:~
	閉な~shadowで非可視:closed-shadow-hidden
深優先前順走査:preorder, depth-first traversal:深さ優先かつ前順による走査

	前-同胞:nextSibling
	次-同胞:previousSibling
doctype:
属性o:attribute°::属性°
片:fragment:~:::フラグメント
断片:fragment::文書片::フラグメント
	~~孤立する:alone
	それだけで〜を成すすべて:alone in a

	全順序:linear
先行-:precede::~
後続-:follow::~
	のpartを成す／関与する
平坦:flat::~
	平坦~化:flatten
連続的:contiguous::~

	●data 型 ／ data 操作
数-:numeric:~
tuple:::組::タプル
未設定に:unset::~
前挿入-:pre-insert::~
前除去-:pre-remove::~
受入-:adopt::~
代入:assignment::~
消去-:clear::~::クリア
部分文字列:substring:~
分割-:split::~
classes:::class 群::クラス群
連結-:concatenate:~
worklet:
派生d:derived::派生

	上位の大域:superglobal
	除去される~node:toBeRemovedNode
	子も~cloneする:clone children
	文字列~化-:stringify
	文字列~化:stringification
	直列化-:serialization

	●一般処理
小task:microtask::小 task:小タスク
snapshot:
活動:activity:~
進行中の:ongoingな:~
続行-:proceed:~
遭遇-:encounter:~
経路:path::~
受動:passive::~
composed:
	＊構成経路:composed::
相:phase::~::フェイズ
合成な:syntheticな::~
	取消せな:uncancelable
	伝播を即時に停止する:stop immediate propagation
	伝播を停止する:stop propagation
未決着:unsettled::~
注視-:watch:~
再入的:reentrant:~
	これまでに評価された:has ever been evaluated
委譲-:delegate:~
形式変換-:transform::~
内部特能:internals::~

	通達-時:signaling
	通達-法:signaling
	~promiseを返す:promise-returning
	~targetし直す:retarget
	validation
	起動するもの:initiator
	別~thread:cross-thread
	走り終えた
	引数:parameter

	●計時
時計:clock:~
時刻起点:time origin::~
高分解能:high resolution::高分解能

	現在時:now
	差分:offset
	ミリ秒数:milliseconds
	までの細かさ:minimum
	何かが生じた:occurrence／:something has occurred
	~~発生:occurrence
	次に起きる出来事:what happens next

	●名前空間
	局所~名:local name
ns:namespace::名前空間
publicID:public ID::public 識別子
systemID:system ID::system 識別子
locate::特定
有修飾:qualified:~

	●custom
	~custom化:customize
昇格:upgrade::~::アップグレード
	定義-済み
検索-:look up::~

	●slot
slot:
割当n:assignment::あてがい
割当-:assign::あてがい
	割当-先:assigned
	割当-先:assignment
	割当n~mode:assignment
割当され:assignされ::あてがわれ
割当する:assignする::あてがう
割当した:assignした::あてがった
割当法:assigning::あてがい方
見出法:finding:見出し方

	●Range
範囲o:range°::範囲°
	~~範囲
境界点:boundary point::~
位置bp:position::位置
位置-:位置
位置:位置
	相対位置
	位置変化
	位置関係
中身:内容
交わる:intersectする:~
交わら:intersectし:~
畳まれ:collapseされ:~
畳む:collapseする:~
選択-:select:~

	基準点:this point
	この点:other point

	●collection
走査-:traverse::~::トラバース
走査:traversal::~::トラバーサル
走査器:traverser::~::トラバーサ
whatToShow:
	濾過器
	濾過する
視野ng:scoping::視野::スコーピング
合致:match::~::マッチ
bitmask::::ビットマスク

	●仕様
意味-:意味
	~~意図され:meant
	意味-:mean
	意味:meaning
制限付き:limited:~
	制限付き:limited-
	過去互換なし:no-quirks
多彩:rich:~
設計者:designer:~
所産:artifact:~
理想的:ideal:~
劇的:dramatic:~
冗長:redundant:~
中立的:neutral:~
適度な:reasonable:ほどよい
精細:granular:~
旧式:old-style:~
環境設定:configurations:~
高価:expensive:~
軽量:lightweight:~
portable::可搬::ポータブル
拡張用:extensibility:~
必須な:requiredな:~
指図-:instruct:~
計画-:plan:~
望み:wishes:~
衝突-:clash:~
保つ:keepする:~
支払う:payする:~
警告:warning:~
処する:dealする:~

	互換でない:incompatible
	な限り:as much as
	簡便:convenience
	無用の長物:useless
	problematic
	適用-可能:applicable
	出発点:starting point
	広い:broader
	~~原因:cause
	~~目的
	様子:how
	略語:short for
	言葉を代えれば:Phrased differently,
	進路:future course
	小論:essays
	報告書:reports
	本格的:fully-fledged
	手品:magic
	~~仕組:magic
	出来上がる:comes out
	十分:
	不要:
	~~的外れ:nonsensical
	~~選択:-
	名称:names
	否決:vetoed
	編集-時:editing
	事実:fact
	ほど遠い:not nearly as reliable or granular
	~~判明:proved
	~~根拠を示す:showing
	編集者:editors
	~~制御:key off
	便宜のため:For convenience
	区別:avoid confusion
	のふるまいに揃える:align with
	用途:for
	~~無視:not pay attention
	~~理由:mishap／because
	注意:notice that
	賢く:wise に
	記述
	必要:has to／
	~~強調:called out
	誤った考え:wrong ideas
	人:folks
	particular
	hairy
	何もしない:no-op／:empty
	により、:because of
	今の所:for now,
	あるとする:hypothetical
	もっぱら:exclusive
	最新:up-to-date
	するものもある:sometimes
	〜を指して:refer
	単に:For brevity

	働き続けられる:don’t stop working
	要-:require
	~~指定:flag:
	定義-法:defining
	操作-:manipulation
	~~説明:illustrate
	想定-:suppose
	内部処理用の:bookkeeping purposes
	存続-:continues to exist
	揃わせ:Aligning
	代わるもの:replacement
	不要にする:replaces the need
	~~廃する:rid of
	論を交わし:discussion
	~Fに:clear
	~~尊守され:enshrined
	知らせて:Let us know
	満たす:meet／
	気にする:worry about
	選べ:chose
	必要に応じて:according to their needs
	関心がなく:uninterested
	引き続き:remain


	●未分類
重複:duplicate:~
装着-:attach:~
XPath:
XSLT:
void:
agent:
surrounding:
multimedia::::マルチメディア
scrolling::::スクロール処理
touch:
wheel:
弱い:weakな:~
基準:reference:~
不正確:inaccurate:~
同等:equal:~
式:expression:~

	調整-済み:-adjusted
	渡-:pass
	生成元が類似な:similar-origin
	Checkbox
	Radio
	16進:hex
	起点:reference
	連続する:adjacent／a sequence of
	一致
	除外-:exclude
	処理過程:process
	処理
	並び:sequence of
	切り替える:toggle
	された:got
	-:lead
	-:controller
	すごいこと:amazing
	すごい結果:amazingResult
	何かする:doAction
	つまらない:Boring


	●指示語
最大-:max:~
現-:current:~
前-:previous:前の
次-:next:次の
旧-:old:旧
新-:new:新
広義-:inclusive:~
狭義の:exclusive:~
	内的に:inner
	内部:-
	広く:widely
	時点:
	以降:
	初回:first time
	ときには、:ocassionally
	前回:
	今度は:now
	現在:
	現時点:at the moment
	すべてまたは一部の:all or some
	唯一つ:only one
	唯一の:the sole
	すべて:all
	範囲:
	もの:thing
	上／上述:above
	一環:part of
	両方／両者／両:both
	複数:
	複数個:more than one
	隙間:
	終了:end
	逆順:reverse
	番目:
	挿入点:
	差分:
	隣接:
	個以上:
	以前:
	項目:
	列目:
	個目:
	度目:
	二番目:
	下記
	開始
	末尾側:
	末尾:
	片方:
	末端:
	各種:
	一連:
	時点:
	対象:
	該当:
	後続:
	左側:
	直前:
	直後:
	部分:
	一部:
	対応している:corresponding
	対応:correspond
	同様:
	以外:
	以下:
	自身:
	先頭:
	個数:
	最後:last
	最初:first
	任意:
	有限個:
	有限:
	箇所:
	各項:
	合間:between
	最高:
	後述:
	一種:
	一対一:
	一対一に対応:1:1 mapping
	一列:
	一個:
	本数:
	各数字:
	最下位:
	逆向:
	前述:
	一例:
	全体:
	一方:
	自体:
	場合:if
	次のように:as follows
	逆順:reverse 〜 order／reversed
	称される:known as
	およそ:viable
	何か:something／

	●訳注
	増減操作
	加減算
	次節
	部分集合
	可視化
	上下関係
	階層
	入子~階層
	無限増殖
	ループ
	反復対象
	~~未定義
	誤記
	機能上
	括弧内
	見立てて
	~~例外
	ドット
	先掲
	算出
	~~定義
	区間
	根元
	対訳
	対称
	整理統合
	慣用表現
	付記
	単純に
	忠実
	意義
	不明
	~~状態
	ブロック
	整合性
	説明用
	見通し
	変形
	否定
	図左
	カット
	相当

	簡略化
	不変
	段階
	全部的
	概念的
	開始地点
	通過-
	横線
	太字
	前順
	優先
	構成-
	関係
	固有
	表記規約
	表記
	非公式
	括弧内: 2
	未策定: 2
	総称: 2
	何故:
	仮想: 2
	訳者: 2
	実行後
	適宜
	簡潔
	最上層
	参考
	実行例: 3
	濾過: 3
	探索
	見出し
	~~厳密
	~~無視
	補足
	補完
	模式図
	縦棒
	横線
	両端
	左端
	右端
	内縁
	外縁
	地点
	直上
	直下
	記号
	赤色区間
	緑色区間
	青色区間
	原文
	意図-
	図右
	上図
	下図
	混在


●●original_id_map


dom-domtokenlist-stringifier:DOMTokenList-stringification-behavior


●●mdn_urls
abortcontroller:API/AbortController
abortsignal:API/AbortSignal
attr:API/Attr
characterdata:API/CharacterData
customevent:API/CustomEvent
	dictdef-customeventinit:API/CustomEventInit
comment:API/Comment
childnode:API/ChildNode
cdatasection:API/CDATASection
nondocumenttypechildnode:API/NonDocumentTypeChildNode
document:API/Document
documentfragment:API/DocumentFragment
shadowroot:API/ShadowRoot
	dictdef-shadowrootinit:API/ShadowRootInit
	enumdef-shadowrootmode:API/ShadowRootMode
	enumdef-slotassignmentmode:API/SlotAssignmentMode
documentorshadowroot:API/DocumentOrShadowRoot
	dictdef-getrootnodeoptions:API/GetRootNodeOptions
domimplementation:API/DOMImplementation
documenttype:API/DocumentType
element:API/Element
	dictdef-elementcreationoptions:API/ElementCreationOptions
	elements:API/Elements
event:API/Event
	dictdef-eventinit:API/EventInit
callbackdef-eventlistener:API/EventListener
eventtarget:API/EventTarget
	eventlisteneroptions:API/EventListenerOptions
	addeventlisteneroptions:API/AddEventListenerOptions
htmlcollection:API/HTMLCollection
	mutationcallback:API/MutationCallback
mutationobserver:API/MutationObserver
dictdef-mutationobserverinit:API/MutationObserverInit
mutationrecord:API/MutationRecord
namednodemap:API/NamedNodeMap
node:API/Node
callbackdef-nodefilter:API/NodeFilter
nodeiterator:API/NodeIterator
nodelist:API/NodeList
processinginstruction:API/ProcessingInstruction
range:API/Range
staticrange:API/StaticRange
	dictdef-staticrangeinit:API/StaticRangeInit
abstractrange:API/AbstractRange
parentnode:API/ParentNode
	nonelementparentnode:API/NonElementParentNode
domtokenlist:API/DOMTokenList
treewalker:API/TreeWalker
text:API/Text
xmldocument:API/XMLDocument
xpathresult:API/XPathResult
xpathexpression:API/XPathExpression
callbackdef-xpathnsresolver:API/XPathNSResolver
	xpathevaluatorbase:API/XPathEvaluatorBase
xpathevaluator:API/XPathEvaluator
xsltprocessor:API/XSLTProcessor


	（廃）
	rangeexception:API/RangeException
mutationevent:API/MutationEvent
	mutationnameevent:API/MutationNameEvent
domconfiguration:API/DOMConfiguration
domerror:API/DOMError
	domerrorhandler:API/DOMErrorHandler
domimplementationlist:API/DOMImplementationList
	domimplementationsource:API/DOMImplementationSource
domlocator:API/DOMLocator
domobject:API/DOMObject
domuserdata:API/DOMUserData
	entity:API/Entity
	entityreference:API/EntityReference
namelist:API/NameList
notation:API/Notation
typeinfo:API/TypeInfo
userdatahandler:API/UserDataHandler

eventdef-abortsignal-abort:API/AbortSignal/abort_event

●●ifc_names

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
short:~WEBIDL#idl-unsigned-short
DOMString:~WEBIDL#idl-DOMString
USVString:~WEBIDL#idl-USVString
any:~WEBIDL#idl-any
sequence:~WEBIDL#idl-sequence

AbortController
AbortSignal
Attr
CharacterData
CustomEvent
CustomEventInit:#dictdef-customeventinit
Comment
ChildNode
CDATASection
NonDocumentTypeChildNode
Document
DocumentFragment
ShadowRoot
ShadowRootInit:#dictdef-shadowrootinit
ShadowRootMode:#enumdef-shadowrootmode
SlotAssignmentMode:#enumdef-slotassignmentmode
DocumentOrShadowRoot
GetRootNodeOptions:#dictdef-getrootnodeoptions

DOMImplementation
DocumentType
Element
ElementCreationOptions:#dictdef-elementcreationoptions
Elements
Event
EventInit:#dictdef-eventinit
EventListener:#callbackdef-eventlistener
EventTarget
EventListenerOptions
AddEventListenerOptions
HTMLCollection
MutationCallback
MutationObserver
MutationObserverInit:#dictdef-mutationobserverinit
MutationRecord
NamedNodeMap
Node
NodeFilter:#callbackdef-nodefilter
NodeIterator
NodeList
ProcessingInstruction
Range
Slottable:#slotable
StaticRange
StaticRangeInit:#dictdef-staticrangeinit
AbstractRange
ParentNode
NonElementParentNode
DOMTokenList
TreeWalker
Text
XMLDocument
XPathResult
XPathExpression
XPathNSResolver:#callbackdef-xpathnsresolver
XPathEvaluatorBase
XPathEvaluator
XSLTProcessor


	●→ 廃止
RangeException
MutationEvent
MutationNameEvent
DOMConfiguration
DOMError
DOMErrorHandler
DOMImplementationList
DOMImplementationSource
DOMLocator
DOMObject
DOMUserData
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler


DOMStringList:~HTMLcdom#domstringlist
HTMLElement:~HTMLdom#htmlelement
HTMLHtmlElement:~HEmetadata#htmlhtmlelement
HTMLSlotElement:~HEscripting#htmlslotelement
HTMLUnknownElement:~HTMLdom#htmlunknownelement
ServiceWorkerGlobalScope:~SW1#serviceworkerglobalscope
Window:~WINDOW#window

BeforeUnloadEvent:~NAVI#beforeunloadevent
CompositionEvent:~UIEVENTS#compositionevent
	#interface-compositionevent
	CustomEvent
DeviceMotionEvent:~DEVICEORIENTATION#devicemotionevent
DeviceOrientationEvent:~DEVICEORIENTATION#deviceorientationevent
EventHandler:~WAPI#eventhandler
DragEvent:~HTMLdnd#dragevent
FocusEvent:~UIEVENTS#focusevent
	#interface-focusevent
	Event
HashChangeEvent:~NAVI#hashchangeevent
KeyboardEvent:~UIEVENTS#keyboardevent
MessageEvent:~HTMLcomms#messageevent
MouseEvent:~UIEVENTS#mouseevent
StorageEvent:~WEBSTORAGE#storageevent
TouchEvent:~TOUCHEVENTS#idl-def-touchevent
	TouchEvent:~TOUCHEVENTS#touchevent-interface
	#touchevent-interface
	https://w3c.github.io/touch-events/#idl-def-touchevent
UIEvent:~UIEVENTS#uievent


DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
DOMException:~WEBIDL#idl-DOMException

●●link_map

e.script:~HEscripting#the-script-element
e.input:~HEinput#the-input-element
e.title:~HEmetadata#the-title-element
e.html:~HEmetadata#the-html-element
e.head:~HEmetadata#the-head-element
e.body:~HEsections#the-body-element
e.template:~HEscripting#the-template-element
e.slot:~HEscripting#the-slot-element
e.input:~HEinput#the-input-element
e.area:~HEimages#the-area-element


l.open:#dom-shadowrootmode-open
l.closed:#dom-shadowrootmode-closed
l.manual:#dom-slotassignmentmode-manual
l.named:#dom-slotassignmentmode-named

	●IDL
CEReactions:~HEcustom#cereactions
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
Unscopable:~WEBIDLjs#Unscopable
NewObject:~WEBIDLjs#NewObject
PutForwards:~WEBIDLjs#PutForwards
Replaceable:~WEBIDLjs#Replaceable
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable
LegacyUnenumerableNamedProperties:~WEBIDLjs#LegacyUnenumerableNamedProperties
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString

any:~WEBIDL#idl-any
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
unrestricted double:~WEBIDL#idl-unrestricted-double

E.TypeError:~WEBIDL#exceptiondef-typeerror
E.AbortError:~WEBIDL#aborterror
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.InUseAttributeError:~WEBIDL#inuseattributeerror
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidCharacterError:~WEBIDL#invalidcharactererror
E.InvalidNodeTypeError:~WEBIDL#invalidnodetypeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NamespaceError:~WEBIDL#namespaceerror
E.NotFoundError:~WEBIDL#notfounderror
E.NotSupportedError:~WEBIDL#notsupportederror
E.SyntaxError:~WEBIDL#syntaxerror
E.WrongDocumentError:~WEBIDL#wrongdocumenterror

m.click():~HTMLinteraction#dom-click
m.detail:~UIEVENTS#dom-uievent-detail
m.event:#dom-window-event
m.insertAdjacentHTML():~DOM-Parsing#dom-element-insertadjacenthtml
m.createContextualFragment():~DOM-Parsing#dom-range-createcontextualfragment
m.getClientRects():~CSSOMVIEW#dom-range-getclientrects
m.getBoundingClientRect():~CSSOMVIEW#dom-range-getboundingclientrect
m.assign():~HEscripting#dom-slot-assign

最初のもの？:#_first_obj
最後のもの？:#_last_obj
最後0:#_last_obj
（旧来の）~listenerは投出したか:~INDEXEDDB#_legacyOutputDidListenersThrowFlag

適用-可能な仕様:#other-applicable-specifications

	●event
c.onabort:#abortsignal-onabort
c.onslotchange:#shadowroot-onslotchange
et.abort:#eventdef-abortsignal-abort
et.slotchange:~HTMLindex#event-slotchange

ev.初期化-済みか:#initialized-flag
ev.伝播を即時に停止するか:#stop-immediate-propagation-flag
ev.伝播を停止するか:#stop-propagation-flag
ev.取消されたか:#canceled-flag
ev.配送-中か:#dispatch-flag
ev.受動~listener内か:#in-passive-listener-flag
ev.~composedか:#composed-flag

evP.呼出n~target:#event-path-invocation-target
evP.呼出n~targetは~shadow~tree内か:#event-path-invocation-target-in-shadow-tree
evP.~shadow調整-済み~target:#event-path-shadow-adjusted-target
evP.~touch~target~list:#event-path-touch-target-list
evP.関係する~target:#event-path-relatedtarget
evP.閉な~treeの根か:#event-path-root-of-closed-tree
evP.~slotは閉な~tree内か:#event-path-slot-in-closed-tree

~event:#concept-event
~eventを作成する:#concept-event-create
~eventを内的に作成する:#inner-event-creation-steps
~eventを初期化する:#concept-event-initialize
~eventを配送する:#concept-event-dispatch
配送-:#concept-event-dispatch
~eventを発火する:#concept-event-fire

~event経路に付加する:#concept-event-path-append
~target:#event-target
~targetし直す:#retarget
~event~targetになり得るもの:#potential-event-target
関係する~target:#event-relatedtarget
~touch~target~list:#event-touch-target-list
経路:#event-path

~listenerを呼出す:#concept-event-listener-invoke
~listenerを内的に呼出す:#concept-event-listener-inner-invoke
~event~listenerを追加する:#add-an-event-listener
~event~listenerを除去する:#remove-an-event-listener
~event~listenerをすべて除去する:#remove-all-event-listeners
~event~listener~list:#eventtarget-event-listener-list
~event~listener:#concept-event-listener

evL.type:#event-listener-type
evL.callback:#event-listener-callback
evL.capture:#event-listener-capture
evL.passive:#event-listener-passive
evL.once:#event-listener-once
evL.signal:#event-listener-signal
evL.removed:#event-listener-removed

平坦~化:#concept-flatten-options
もっと平坦~化:#event-flatten-more
親~targetを取得する:#get-the-parent
~event構築子:#concept-event-constructor

作動化の挙動:#eventtarget-activation-behavior
旧来の作動化~前の挙動:#eventtarget-legacy-pre-activation-behavior
旧来の作動化~取消~時の挙動:#eventtarget-legacy-canceled-activation-behavior

~event構築-時の手続き:#concept-event-constructor-ext
取消されたかを設定する:#set-the-canceled-flag
現在の~event:#window-current-event

	●abort
aB.通達:#abortcontroller-signal
aB.中止-事由:#abortsignal-abort-reason
aB.中止された:#abortsignal-aborted
aB.中止する~algo群:#abortsignal-abort-algorithms
中止-を通達する:#abortsignal-signal-abort
通達に~algoを追加する:#abortsignal-add
通達から~algoを除去する:#abortsignal-remove
通達に追従させる:#abortsignal-follow

	●node／~tree
~node:#concept-node
親~要素:#parent-element
子:#concept-tree-child
子~群:#concept-tree-child
親:#concept-tree-parent
先祖:#concept-tree-ancestor
子孫:#concept-tree-descendant
広義-先祖:#concept-tree-inclusive-ancestor
広義-子孫:#concept-tree-inclusive-descendant
共通な広義-先祖:#_common-inclusive-ancestor

最初の子？:#concept-tree-first-child
最後の子？:#concept-tree-last-child
先行-:#concept-tree-preceding
後続-:#concept-tree-following
~index:#concept-tree-index
前-同胞？:#concept-tree-previous-sibling
次-同胞？:#concept-tree-next-sibling
関与-:#concept-tree-participate
同胞:#concept-tree-sibling
広義-同胞:#concept-tree-inclusive-sibling

~tree:#concept-tree
~node~tree:#concept-node-tree
文書~tree:#concept-document-tree
根:#concept-tree-root
~tree順序:#concept-tree-order
要素~interface:#concept-element-interface

文書~tree内:#in-a-document-tree
文書~内:#in-a-document

~nodeを受入する:#concept-node-adopt
~nodeを付加する:#concept-node-append
~nodeを子の前に挿入する:#concept-node-insert
~nodeを子の前に前挿入する:#concept-node-pre-insert
挿入できるかどうか検証する:#concept-node-ensure-pre-insertion-validity
子を前除去する:#concept-node-pre-remove
~nodeを除去する:#concept-node-remove
子を~nodeに置換する:#concept-node-replace
全~内容を~nodeで置換する:#concept-node-replace-all
全~内容を文字列に置換する:#string-replace-all
隣に~nodeを挿入する:#insert-adjacent
~nodeを~cloneする:#concept-node-clone
子~text内容:#concept-child-text-content

受入-時の手続き:#concept-node-adopt-ext
挿入-時の手続き:#concept-node-insert-ext
子~群~変更-時の手続き:#concept-node-children-changed-ext
前除去-時の手続き:#nodeiterator-pre-removing-steps
除去-時の手続き:#concept-node-remove-ext
~clone時の手続き:#concept-node-clone-ext

長さ:#concept-node-length
~node文書:#concept-node-document
node.空:#concept-node-empty
同等:#concept-node-equals

文書片:#_concept-documentfragment
文字~data~node:#_concept-cdata-node
~host:#concept-documentfragment-host
~hostも含む広義-先祖:#concept-tree-host-including-inclusive-ancestor

~ID:#concept-id


	●shadow
~light~tree:#concept-light-tree
~shadow~tree:#concept-shadow-tree
~shadow~host:#element-shadow-host
~shadow根:#concept-shadow-root
sR.~mode:#shadowroot-mode
sR.~focusを委譲するか:#shadowroot-delegates-focus
sR.要素の内部特能から可用か:#shadowroot-available-to-element-internals
sR.~slot割当n~mode:#shadowroot-slot-assignment

~shadowも含む子孫:#concept-shadow-including-descendant
~shadowも含む広義-子孫:#concept-shadow-including-inclusive-descendant
~shadowも含む先祖:#concept-shadow-including-ancestor
~shadowも含む広義-先祖:#concept-shadow-including-inclusive-ancestor
~shadowも含む~tree順序:#concept-shadow-including-tree-order
~shadowも含む深優先前順走査:#shadow-including-preorder-depth-first-traversal
接続されて:#connected
~shadowも含む根:#concept-shadow-including-root
	#in-a-shadow-including-document
閉な~shadowで非可視:#concept-closed-shadow-hidden

	●slot
~slot:#concept-slot
~slot可能:#concept-slotable
	~slot可能:#concept-slotable
~slot名:#slot-name
	＊sL.名前:#slot-name
sB.名前:#slotable-name
~slot可能~用に~slotを見出す:#find-a-slot
~slot用に~slot可能なものを見出す:#find-slotables
~slot用に平坦~化された~slot可能なものを見出す:#find-flattened-slotables
割当-先~slot:#slotable-assigned-slot
手動~割当-先~slot:#slottable-manual-slot-assignment
割当-先がある:#slotable-assigned
割当された~node群:#slot-assigned-nodes
手動で割当された~node群:~HEscripting#manually-assigned-nodes
~slot可能を~slotに割当する:#assign-a-slot
~slotに~slot可能なものを割当する:#assign-slotables
~treeに~slot可能なものを割当する:#assign-slotables-for-a-tree
通達~slot群:#signal-slot-list
~slotの変化を通達する:#signal-a-slot-change

	●文書／文書片／名前空間
文書:#concept-document
doc.符号化法:#concept-document-encoding
doc.内容~型:#concept-document-content-type
doc.~URL:#concept-document-url
doc.種別:#concept-document-type
doc.生成元:#concept-document-origin
doc.~mode:#concept-document-mode

文書~基底~URL:~HTMLurl#document-base-url
結付けられている文書:~WINDOW#concept-document-window

制限付き過去互換~mode:#concept-document-limited-quirks
過去互換なし~mode:#concept-document-no-quirks
過去互換~mode:#concept-document-quirks
~doctype:#concept-doctype
~doctype名:#concept-doctype-name
dT.名前:#concept-doctype-name
dT.~publicID:#concept-doctype-publicid
dT.~systemID:#concept-doctype-systemid


~HTML文書:#html-document
~XML文書:#xml-document

~ns接頭辞を~locateする:#locate-a-namespace-prefix
~nsを~locateする:#locate-a-namespace
内部 createElementNS 手続き:#internal-createelementns-steps


	●text node／文字列／cdata
新たな~Text~node:#_a-new-text-node

有順序~集合 構文解析器:#concept-ordered-set-parser
有順序~集合 直列化器:#concept-ordered-set-serializer

~Text~nodeを分割する:#concept-text-split
~dataを置換する:#concept-cd-replace
~data:#concept-cd-data
~dataの部分文字列:#concept-cd-substring

狭義の~Text~node:#exclusive-text-node
連続的な~Text~node列:#contiguous-text-nodes
連続的な狭義の~Text~node列:#contiguous-exclusive-text-nodes
連続的な同胞~列:#_contiguous-nodes

子孫~text内容:#concept-descendant-text-content

	●要素／属性
文書~要素:#document-element
要素:#concept-element
局所~名:#concept-element-local-name
elm.~shadow根:#concept-element-shadow-root
有修飾~名:#concept-element-qualified-name
~HTML大文字~化~有修飾~名:#element-html-uppercased-qualified-name
~ns接頭辞:#concept-element-namespace-prefix
~ns:#concept-element-namespace
有修飾~名として検証する:#validate
検証して抽出する:#validate-and-extract
属性o~list:#concept-element-attribute
有する:#concept-element-attribute-has

属性~変化を取扱う:#handle-attribute-changes
属性oを変更する:#concept-element-attributes-change
属性oを付加する:#concept-element-attributes-append
属性oを除去する:#concept-element-attributes-remove
属性oを置換する:#concept-element-attributes-replace

属性oを設定する:#concept-element-attributes-set
既存の属性o値を設定する:#set-an-existing-attribute-value
属性o値を設定する:#concept-element-attributes-set-value
属性o値を取得する:#concept-element-attributes-get-value

属性oを名前により取得する:#concept-element-attributes-get-by-name
属性oを名前により除去する:#concept-element-attributes-remove-by-name
属性oを~nsと局所~名により取得する:#concept-element-attributes-get-by-namespace
属性oを~nsと局所~名により除去する:#concept-element-attributes-remove-by-namespace

属性o:#concept-attribute
nm.属性o:#concept-named-attribute
属性o変更-時の手続き:#concept-element-attributes-change-ext
属する要素:#concept-attribute-element
a.有修飾~名:#concept-attribute-qualified-name
a.値:#concept-attribute-value
a.~ns:#concept-attribute-namespace
a.~ns接頭辞:#concept-attribute-namespace-prefix
a.局所~名:#concept-attribute-local-name

nm.要素:#concept-namednodemap-element
nm.属性o~list:#concept-namednodemap-attribute
~classes:#concept-class
~classesに含む要素の~list:#concept-getelementsbyclassname
有修飾~名に持つ要素の~list:#concept-getelementsbytagname
( ~ns, 局所~名 ) に持つ要素の~list:#concept-getelementsbytagnamens

反映する:#concept-reflect


	●custom要素
要素を作成する:#concept-create-element
定義-済み:#concept-element-defined
~custom:#concept-element-custom
~custom要素~状態:#concept-element-custom-element-state
~custom要素~定義:#concept-element-custom-element-definition
~is0値:#concept-element-is-value

cD.名前:~HEcustom#concept-custom-element-definition-name
cD.局所~名:~HEcustom#concept-custom-element-definition-local-name
cD.構築子:~HEcustom#concept-custom-element-definition-constructor
cD.~shadowを不能化するか:~HEcustom#concept-custom-element-definition-disable-shadow
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~custom要素~構築子:~HEcustom#custom-element-constructor
~custom要素~callback反応を~enqueueする:~HEcustom#enqueue-a-custom-element-callback-reaction
~custom化された組込みの要素:~HEcustom#customized-built-in-element
~custom要素~定義を検索する:~HEcustom#look-up-a-custom-element-definition
要素を昇格しようと試行する:~HEcustom#concept-try-upgrade
要素を昇格する:~HEcustom#concept-upgrade-an-element
~custom要素~昇格~反応を~enqueueする:~HEcustom#enqueue-a-custom-element-upgrade-reaction


	●変異
変異~記録を~queueする:#queue-a-mutation-record
~tree変異~記録を~queueする:#queue-a-tree-mutation-record
~node群を~nodeに変換する:#converting-nodes-into-a-node

mo.~callback:#concept-mo-callback
mo.~node~list:#mutationobserver-node-list
mo.記録~queue:#concept-mo-queue

変異~観測器の小taskは~queueされたか:#mutation-observer-compound-microtask-queued-flag
変異~観測器 小taskを~queueする:#queue-a-mutation-observer-compound-microtask
変異~観測器に通知する:#notify-mutation-observers

登録-済み観測器:#registered-observer
一時~登録-済み観測器:#transient-registered-observer
変異~観測器~群:#mutation-observer-list
登録-済み観測器~list:#registered-observer-list

ob.観測器:#registered-observer-observer
ob.~option群:#registered-observer-options
ob.~source:#transient-registered-observer-source


	●範囲
範囲o:#concept-range
~live範囲o:#concept-live-range
rg.妥当:#staticrange-valid
rg.根:#concept-range-root
rg.中身を抽出-:#concept-range-extract
rg.中身を~clone:#concept-range-clone
rg.中身に挿入-:#concept-range-insert
rg.中身として選択-:#concept-range-select
rg.中身:#_concept-range-content

境界点:#concept-range-bp
bp.~node:#boundary-point-node
bp.~offset:#concept-range-bp-offset

i.より前:#concept-range-bp-before
i.より後:#concept-range-bp-after
i.に等しい:#concept-range-bp-equal

終端~node:#concept-range-end-node
終端~offset:#concept-range-end-offset
終端:#concept-range-end
始端~node:#concept-range-start-node
始端~offset:#concept-range-start-offset
始端:#concept-range-start
畳まれて:#range-collapsed

相対的な位置bp:#concept-range-bp-position
境界点を設定する:#concept-range-bp-set

包含され:#contained
部分的に包含され:#partially-contained

	●token list

tL.~token集合:#concept-dtl-tokens
tL.~supportする~token集合:#concept-supported-tokens
tL.要素:#_dtl-element
tL.属性oの局所~名:#_dtl-localname
tL.更新~手続き:#concept-dtl-update
tL.直列化-手続き:#concept-dtl-serialize
~tokenを検証する:#concept-domtokenlist-validation
~tokenを検査する:#_dtl-check-token

	●collection／node iterator／tree walker
表現-:#represented-by-the-collection
反復子~collection:#iterator-collection
~live:#concept-collection-live
静的:#concept-collection-static
~collection:#concept-collection

cL.~filter:#_collection-filter
cL.根:#_collection-root

tV.作動中か:#concept-traversal-active
tV.~filter~callback:#concept-traversal-filter
tV.根:#concept-traversal-root
tV.~whatToShow:#concept-traversal-whattoshow
tV.現-~node:#treewalker-current
tV.起点:#nodeiterator-reference
tV.起点の直前か:#nodeiterator-pointer-before-reference

走査器の中で~nodeを~filterにかける:#concept-node-filter
子~群を走査する:#concept-traverse-children
同胞たちを走査する:#concept-traverse-siblings
反復子で走査する:#concept-nodeiterator-traverse
走査-:#concept-nodeiterator-traverse

	●PI
pI.~target:#concept-pi-target

	●INFRA
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
set.置換する:~INFRA#set-replace
~list:~INFRA#list
~item:~INFRA#list-item
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
~cloneする:~INFRA#list-clone
~size:~INFRA#list-size
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
除去する:~INFRA#list-remove
挿入する:~INFRA#list-insert
置換する:~INFRA#list-replace
包含して:~INFRA#list-contain
~queue:~INFRA#queue
~enqueueする:~INFRA#queue-enqueue
~map:~INFRA#ordered-map
構造体:~INFRA#struct
~tuple:~INFRA#tuple
	list.~EACH:~INFRA#list-iterate
	list.~CONTINUE:~INFRA#iteration-continue
	list.包含-:~INFRA#list-contain
	list.~IN:~INFRA#list-contain
	list.~NIN:~INFRA#list-contain

符号単位:~INFRA#code-unit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大文字~化する:~INFRA#ascii-uppercase
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
str.長さ:~INFRA#string-length
一致する:~INFRA#string-is
連結-:~INFRA#string-concatenate
区切子で厳密に分割する:~INFRA#strictly-split

~HTML~ns:~INFRA#html-namespace
~SVG~ns:~INFRA#svg-namespace
~XML~ns:~INFRA#xml-namespace
~XMLNS~ns:~INFRA#xmlns-namespace


	●選択子
視野の下で選択子を照合する:#scope-match-a-selectors-string
~scope-ps要素:~SELECTORS4#scope-element
選択子として構文解析する:~SELECTORS4#parse-a-selector
視野ng根:~SELECTORS4#scoping-root
~treeに対し選択子を照合する:~SELECTORS4#match-a-selector-against-a-tree
要素に対し選択子を照合する:~SELECTORS4#match-a-selector-against-an-element

	●WEBIDL
実装-:~WEBIDLjs#implements
辞書:~WEBIDL#dfn-dictionary
辞書~member:~WEBIDL#dfn-dictionary-member
識別子:~WEBIDL#dfn-identifier
	interface mixin:~WEBIDL#idl-interface-mixins

~supportする~prop~index:~WEBIDL#dfn-supported-property-indices
~supportする~prop名:~WEBIDL#dfn-supported-property-names
投出:~WEBIDL#dfn-throw
可変個引数:~WEBIDL#dfn-variadic
利用元~objの演算を~callする:~WEBIDLjs#call-a-user-objects-operation
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
変換-:~WEBIDLjs#dfn-convert-ecmascript-to-idl-value
~callback関数で構築する:~WEBIDLjs#construct-a-callback-function
属する~Realm:~WEBIDLjs#dfn-associated-realm
文字列~化の挙動:~WEBIDL#dfn-stringification-behavior

	●他
新たな~promise:~WEBIDLjs#a-new-promise
却下する:~WEBIDLjs#reject
解決する:~WEBIDLjs#resolve

~consoleに警告を報告する:~CONSOLE#report-a-warning-to-the-console

~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

utf-8:~ENCODING#utf-8
符号化法:~ENCODING#encoding
enc.名前:~ENCODING#name

prod.Char:~TR/xml/#NT-Char
prod.Name:~TR/xml/#NT-Name
prod.QName:~XNLNS10#NT-QName
prod.PrefixedName:~XNLNS10#NT-PrefixedName

~HTML構文解析器:~HTMLparsing#html-parser
並列的:~HTMLINFRA#in-parallel

例外を報告する:~WAPI#report-the-exception
関連な大域~obj:~WAPI#concept-relevant-global
現在の大域~obj:~WAPI#current-global-object
関連な~Realm:~WAPI#concept-relevant-realm
関連な~agent:~WAPI#relevant-agent
rM.大域~obj:~WAPI#concept-realm-global
小task:~WAPI#microtask
小taskを~queueする:~WAPI#queue-a-microtask
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
生成元が類似な~window~agent:~WAPI#similar-origin-window-agent

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc

~sw:~SW1#dfn-service-worker
SWG.~sw:~SW1#serviceworkerglobalscope-service-worker
取扱う~event型の集合:~SW1#dfn-set-of-event-types-to-handle
~script資源:~SW1#dfn-script-resource
これまでに評価されたか:~SW1#dfn-has-ever-been-evaluated-flag
~sw~event:~SW1#dfn-service-worker-events

~Realm:~TC39#realm
細かさを抑えた相対的な高分解能~時刻:~HRTIME#dfn-relative-high-resolution-coarse-time
時刻起点:~HRTIME#dfn-time-origin
現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
~surrounding~agent:~TC39#surrounding-agent

	:https://w3c.github.io/webcomponents/spec/shadow/
	:~HTMLselectors#selector-defined
	:#mutation-algorithms

_acks1:#_acks1
_ipr1:#_ipr1


●●ref_data
XPATH=副      ~/XML/xpath10-ja.html
CONSOLE=副    ~/console-ja.html
DEVICEORIENTATION=副    ~/deviceorientation-ja.html

●●ref_key_map

●●ref_normative

[CONSOLE]
    Dominic Farolino; Robert Kowalski; Terin Stock. ＜Console Standard＞. Living Standard. URL: https://console.spec.whatwg.org/
[DEVICE-ORIENTATION]
    Rich Tibbett; et al. ＜DeviceOrientation Event Specification＞. URL: https://w3c.github.io/deviceorientation/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[HR-TIME-3]
    Yoav Weiss; et al. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[SERVICE-WORKERS]
    Alex Russell; et al. ＜Service Workers 1＞. URL: https://w3c.github.io/ServiceWorker/
[TOUCH-EVENTS]
    Doug Schepers; et al. ＜Touch Events＞. URL: https://w3c.github.io/touch-events/
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. URL: https://w3c.github.io/uievents/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/
[XML-NAMES]
    Tim Bray; et al. ＜Namespaces in XML 1.0 (Third Edition)＞. 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/

●●ref_informative

[CSSOM-VIEW]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM-Level-3-XPath]
    Ray Whitmer. ＜Document Object Model (DOM) Level 3 XPath Specification＞. 3 November 2020. NOTE. URL: https://www.w3.org/TR/DOM-Level-3-XPath/
[DOM-Parsing]
    Travis Leithead. ＜DOM Parsing and Serialization＞. URL: https://w3c.github.io/DOM-Parsing/
[FULLSCREEN]
    Philip Jägenstedt. ＜Fullscreen API Standard＞. Living Standard. URL: https://fullscreen.spec.whatwg.org/
[INDEXEDDB]
    Nikunj Mehta; et al. ＜Indexed Database API＞. URL: https://w3c.github.io/IndexedDB/
[XPath]
    James Clark; Steven DeRose. ＜XML Path Language (XPath) Version 1.0＞. 16 November 1999. REC. URL: https://www.w3.org/TR/xpath-10/
[XSLT]
    James Clark. ＜XSL Transformations (XSLT) Version 1.0＞. 16 November 1999. REC. URL: https://www.w3.org/TR/xslt/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">DOM Standard</a>
仕様（通称 “DOM-LS”, “DOM4”, “DOM Core” ）を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/dom">GitHub whatwg/dom</a> (<a href="https://github.com/whatwg/dom/issues/new">new issue</a>, <a href="https://github.com/whatwg/dom/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/dom/commits
	<a href="https://dom.spec.whatwg.org/commit-snapshots/4ca187f9ccd4b1548d87293307ee58430ef4908b/">Snapshot as of this commit</a>
	<a href="https://twitter.com/thedomstandard">@thedomstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/dom">web-platform-tests dom/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/dom">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>
<header>
<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiIHN0cm9rZS13aWR0aD0iMTAiIGZpbGw9IiNmZmYiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIvPgo8cGF0aCBkPSJtNTAsMjV2MTVsLTE1LDEwLTEwLDE1bTEwLTE1bDEwLDE1bTUtMjVsMTUsMTAsMTAsMTVtLTEwLTE1bC0xMCwxNSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>DOM</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
~DOMは、~platformに中立的な，［
~event, ~promiseによる活動の中止-法, ~node~tree
］の~modelを定義する。
◎
DOM defines a platform-neutral model for events, aborting activities and node trees.
</p>

	</section>

<main id="MAIN0">

	<section id="infrastructure">
<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様の一部の用語は
`Encoding^cite,
`Selectors^cite,
`Web IDL^cite,
`XML^cite,
`Namespaces in XML^cite
にて定義される。
`ENCODING$r
`SELECTORS4$r
`WEBIDL$r
`XML$r
`XML-NAMES$r
◎
Some of the terms used in this specification are defined in Encoding, Selectors, Web IDL, XML, and Namespaces in XML. [ENCODING] [SELECTORS4] [WEBIDL] [XML] [XML-NAMES]
</p>

<p>
拡張が必要になったときは、それに則って~DOM標準が更新されるか，あるいは
`適用-可能な仕様@†
用に供される拡張用~hookを利用するような，新たな標準が書かれ得る。
◎
When extensions are needed, the DOM Standard can be updated accordingly, or a new standard can be written that hooks into the provided extensibility hooks for applicable specifications.
</p>

<p class="trans-note">【†
`HTML$r に定義される<a href="~HTMLINFRA#other-applicable-specifications">同じ名前の用語</a>と同様
— この仕様~自身も含まれる。
】</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳では，以下の表記が用いられる：
</p>

<ul>
	<li>
~algoや定義の記述に利用されている各種記号（ ε, ~LET, ~EQ, ~IF, ~EACH(…), ~RET, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</li>
	<li>
所与の［
有限個の~objからなる有順序~集合（例えば`~tree$や~list）の部分集合（例えば ある条件を満たすものなど）
］ %S に対し，その［
`最初のもの？@
／
`最後のもの？@
］とは、 %S が空（例えば，条件を満たす~objが存在しない）ならば ~NULL であり，そうでなければ その順序において %S の中で［
最初 ／ 最後
］に在る~objとする。
<small >（
“最初” ／ “最後” がこの意味で用いられる所（ ~NULL にもなり得る所）では、常に（ WebIDL 方式に倣って） "?" が付記される。
）</small>
</li>
	<li>
整数 %index に対する “%index 番” は 0 番から数えるとする。
</li>
</ul>

		</section>
		<section id="trees">
<h3 title="Trees">1.1. ~tree</h3>
<!-- Sorry reddit, this is not /r/trees -->

<p>
`~tree@
とは、有限かつ階層的な~tree構造である。
`~tree順序@
は、深優先前順走査に基づく。
◎
A tree is a finite hierarchical tree structure. In tree order is preorder, depth-first traversal of a tree.
</p>

<div class="trans-note" id="example-tree">
<p>【
`<a href="https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2" >深さ優先</a>^_,
`<a href="https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_%28%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%29#.E8.B5.B0.E6.9F.BB.E6.B3.95" >前順</a>^_
】：
この方式による~treeの走査-は、~HTMLや~XML文書の~source~text表現における，要素の開始~tagや~text内容（より一般には`文字~data~node$）が現れる順序を表現する（ゆえに， “文書~順序” と称されることもある）。
</p>

<p>
例えば、次の~source（単純にするため， `e^e 要素と~text内容のみからなる）から生成される~DOM~treeは：
</p>

<pre class="lang-xml">
&lt;e&gt;&lt;e&gt;&lt;/e&gt;~sourceに&lt;e&gt;現れる&lt;e&gt;順序が&lt;/e&gt;&lt;e&gt;そのまま&lt;e&gt;~tree順序に&lt;/e&gt;&lt;/e&gt;なる&lt;/e&gt;&lt;/e&gt;
</pre>

<p>
次のような模式図として可視化できる：
</p>

`[&nbsp;[&nbsp;]&nbsp;(~sourceに)&nbsp;[&nbsp;(現れる)&nbsp;[&nbsp;(順序が)&nbsp;]&nbsp;[&nbsp;(そのまま)&nbsp;[&nbsp;(~tree順序に)&nbsp;]&nbsp;]&nbsp;(なる)&nbsp;]&nbsp;]^bpex

<p>
図の左端が~sourceの先頭, 右端が末尾に対応する。
図の横線が，~treeの中の各~nodeとそれが~source内を占める~~範囲（要素の開始~tag〜終了~tag ／ 文字~dataの先頭〜末尾）を表し、それらの上下関係が~treeの階層（~nodeの入子ng階層）を表す。
図の中の各~文字は文字~dataの各~文字に対応し，それらが成す各~COLOR_Rが`文字~data~node$が占める~~範囲を表す。
~nodeの順序はこれらの横線の左端の位置から決定される。
最上層の横線がこの~treeの根~node（根元）を表し，この順序における先頭になる。
</p>
</div>

<p>
`~tree$に
`関与-@
している各~objは、
次に挙げるものを持つ：
◎
An object that participates in a tree＼
</p>
<ul>
	<li>
`親@
— ~objまたは~NULL
◎
has a parent, which is either null or an object,＼
</li>
	<li>
`子~群@
（ `children^en ）
— 0 個以上の~objからなる`有順序~集合$
◎
and has children, which is an ordered set of objects.＼
</li>
</ul>

<p>
~obj %A の`親$ %B ~NEQ ~NULL ならば、
%A は %B の`子$である。
◎
An object A whose parent is object B is a child of B.
</p>

<p class="trans-note">【
%A は %B の “子である” という句は、［
%A ~IN %B の`子~群$
］を満たすことを意味する。
】【
%B は “子を持つ” という句は、［
%B の`子~群$は`空$でない
］ことを意味する。
】【
同じ~objが同時に複数の~objの子になることはない。
】</p>

<p>
~objの
`根@
とは、［
~objの`親$ ~EQ ~NULL
］ならば~obj自身であり，他の場合は~objの`親$の`根$である。
`~tree$の`根$は、その`~tree$に`関与-$している~objであって，［
`親$ ~EQ ~NULL
］なるものである。
◎
The root of an object is itself, if its parent is null, or else it is the root of its parent. The root of a tree is any object participating in that tree whose parent is null.
</p>

<p class="trans-note">【
この定義は、`親$を順々に辿った結果は循環しない（自身には戻らない）ことも含意している。
同様に，`子$を順々に辿った結果も循環しない。
】</p>

<p>
~obj %A が~obj %B の
`子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子$である
］~OR［
%A は %B のある`子孫$の`子$である
］
◎
An object A is called a descendant of an object B, if either A is a child of B or A is a child of an object C that is a descendant of B.
</p>

<p class="trans-note">【
上述したように循環しないので、
%A 自身が %A の`子孫$になることはない。
】</p>

<p>
~obj %A が~obj %B の
`広義-子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`子孫$である
］
◎
An inclusive descendant is an object or one of its descendants.
</p>

<p class="trans-note"><small>【
“~~広義” という対訳は，よいとは言えないが、より忠実に “自身も含めた子孫” などと訳すのでは，用語として定義する意義
— 他から簡潔に参照できるようにする —
も失われる（単に “自身または子孫” と記すのと同じことになる）。
】</small></p>

<p>
~obj %A が~obj %B の
`先祖@
であるとは、次を意味する
⇒
%B は %A の`子孫$である
◎
An object A is called an ancestor of an object B if and only if B is a descendant of A.
</p>

<p>
~obj %A が~obj %B の
`広義-先祖@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`先祖$である
］
◎
An inclusive ancestor is an object or one of its ancestors.
</p>

<p>
~obj %A が~obj %B の
`同胞@
（ “兄弟” ）であるとは、次を意味する
⇒
［
%A の`親$ ~NEQ ~NULL
］~AND［
%A の`親$ ~EQ %B の`親$
］
◎
An object A is called a sibling of an object B, if and only if B and A share the same non-null parent.
</p>

<p class="trans-note">【
定義により， %A 自身も
<em>親が非~NULLならば</em>
%A の`同胞$になる。
この仕様の中では、この点について特に注意を要する箇所は（現時点では）ないが。
例えば、この同胞の定義を
“%A と %B は同じでない”
と解釈したとしても，この仕様の残りの部分には影響しない。
】</p>

<p>
~obj %A が~obj %B の
`広義-同胞@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`同胞$である
］
◎
An inclusive sibling is an object or one of its siblings.
</p>

<p class="trans-note">【
%A 自身は，親が~NULLであっても %A の広義-同胞になる点で、`同胞$の定義と異なる。
この定義は、もっぱら他の仕様~用にあり，この仕様~内では利用されない。
】</p>
【！ ~DOMissue/55 】

<p>
~obj %A が~obj %B に
`先行-@
するとは、次を意味する
⇒
［
%A と %B は同じ`~tree$に関与する
］~AND［
`~tree順序$において %A は %B より前に在る
］
◎
An object A is preceding an object B if A and B are in the same tree and A comes before B in tree order.
</p>

<p>
~obj %A が~obj %B に
`後続-@
するとは、次を意味する
⇒
［
%A と %B は同じ`~tree$に関与する
］~AND［
`~tree順序$において %A は %B より後に在る
］
◎
An object A is following an object B if A and B are in the same tree and A comes after B in tree order.
</p>

<p>
~objの
`最初の子？@
とは、~objの`子$のうち，`最初のもの？$である。
◎
The first child of an object is its first child or null if it has no children.
</p>

<p>
~objの
`最後の子？@
とは、~objの`子$のうち，`最後のもの？$である。
◎
The last child of an object is its last child or null if it has no children.
</p>

<p>
~objの
`前-同胞？@
とは、~objに`先行-$する`同胞$のうち，`最後のもの？$である。
◎
The previous sibling of an object is its first preceding sibling or null if it has no preceding sibling.
</p>

<p>
~objの
`次-同胞？@
とは、~objに`後続-$する`同胞$のうち，`最初のもの？$である。
◎
The next sibling of an object is its first following sibling or null if it has no following sibling.
</p>

<p>
~objの
`~index@
とは、~objに`先行-$する`同胞$の個数である（なければ 0 になる）。
◎
The index of an object is its number of preceding siblings, or 0 if it has none.
</p>

		</section>
		<section id="ordered-sets">
<h3 title="Ordered sets">1.2. 有順序~集合</h3>

<div class="algo">
<p>
文字列 %入力 を
`有順序~集合 構文解析器@
にかけるときは、次を走らす：
◎
The ordered set parser takes a string input and then runs these steps:
</p>
<ol>
	<li>
%入力~token列 ~LET `~ASCII空白で分割する$( %入力 )
◎
Let inputTokens be the result of splitting input on ASCII whitespace.
</li>
	<li>
%~token列 ~LET 新たな`有順序~集合$
◎
Let tokens be a new ordered set.
</li>
	<li>
%入力~token列 を成す
~EACH( %~token )
に対し
⇒
%~token列 に %~token を`付加する$set
◎
For each token in inputTokens, append token to tokens.
</li>
	<li>
~RET %~token列
◎
Return tokens.
</li>
</ol>
</div>

<div class="algo">
<p>
文字列からなる有順序~集合 %S を
`有順序~集合 直列化器@
にかけるときは、
%S を ~U0020 で`連結-$した結果を返す。
◎
The ordered set serializer takes a set and returns the concatenation of set using U+0020 SPACE.
</p>
</div>

		</section>
		<section id="selectors">
<h3 title="Selectors">1.3. 選択子</h3>

<div class="algo">
<p>
%node の
`視野の下で選択子を照合する@
ときは、所与の
( 文字列 %選択子 )
に対し，次を走らす：
◎
To scope-match a selectors string selectors against a node, run these steps:
</p>
<ol>
	<li>
%S ~LET `選択子として構文解析する$( %選択子 )
`SELECTORS4$r
◎
Let s be the result of parse a selector selectors. [SELECTORS4]
</li>
	<li>
~IF［
%S ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET
`~treeに対し選択子を照合する$( 選択子 %S, 根~要素たち { %node の`根$ }, `視野ng根$ %node )
`SELECTORS4$r
◎
Return the result of match a selector against a tree with s and node’s root using scoping root node. [SELECTORS4].
</li>
</ol>

<p class="note">注記：
選択子の中の~ns用の~supportは、計画されておらず，追加されることはない。
◎
Support for namespaces within selectors is not planned and will not be added.
</p>
</div>

		</section>
		<section id="namespaces">
<h3 title="Namespaces">1.4. ~ns</h3>

<div class="algo">
<p>
`有修飾~名として検証する@
ときは、所与の
( %名前 )
に対し，次を走らす
⇒
~IF［
%名前 は `QName$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
To validate a qualifiedName, throw an "InvalidCharacterError" DOMException if qualifiedName does not match the QName production. 
</p>
</div>

<div class="algo">
<p>
`検証して抽出する@
ときは、所与の
( %~ns, %名前 )
に対し，次を走らす：
◎
To validate and extract a namespace and qualifiedName, run these steps:
</p>
<ol>
	<li id="cp-normalize-ns">
~IF［
%~ns ~EQ 空~文字列
］
⇒
%~ns ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>
	<li>
`有修飾~名として検証する$( %名前 )
◎
Validate qualifiedName.
</li>
	<li>
%接頭辞 ~LET ~NULL
◎
Let prefix be null.
</li>
	<li>
%局所~名 ~LET %名前
◎
Let localName be qualifiedName.
</li>
	<li>
<p>
~IF［
%名前 は ~U003A を含む†
］
⇒
( %接頭辞, %局所~名 ) ~SET ( 次の結果[0], 次の結果[1] )
⇒
`区切子で厳密に分割する$( %名前, ~U003A )
◎
If qualifiedName contains a U+003A (:), then strictly split the string on it and set prefix to the part before and localName to the part after.
</p>

<p class="trans-note">【†
すなわち， %名前 は `PrefixedName$prod 生成規則に合致するので、
~U003A は 1 個だけ含まれる。
したがって、厳密に分割した結果は，正確に 2 個の文字列からなる。
】</p>

	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
↓</p>
		<ul>
			<li>
［
%~ns ~EQ ~NULL
］~AND［
%接頭辞 ~NEQ ~NULL
］
◎
If prefix is non-null and namespace is null, then throw a "NamespaceError" DOMException.
</li>
			<li>
［
%~ns ~NEQ `~XML~ns$
］~AND［
%接頭辞 ~EQ `xml^l
］
◎
If prefix is "xml" and namespace is not the XML namespace, then throw a "NamespaceError" DOMException.
</li>
			<li>
［
%~ns ~NEQ `~XMLNS~ns$
］~AND［［
%名前 ~EQ `xmlns^l
］~OR［
%接頭辞 ~EQ `xmlns^l
］］
◎
If either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace, then throw a "NamespaceError" DOMException.
</li>
			<li>
［
%~ns ~EQ `~XMLNS~ns$
］~AND［
%名前 ~NEQ `xmlns^l
］~AND［
%接頭辞 ~NEQ `xmlns^l
］
◎
If namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns", then throw a "NamespaceError" DOMException.
</li>
		</ul>

<p>
…ならば
⇒
~THROW `NamespaceError$E
◎
↑</p>

	</li>
	<li>
~RET ( %~ns, %接頭辞, %局所~名 )
◎
Return namespace, prefix, and localName.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="events">
<h2 title="Events">2. ~event</h2>

		<section id="introduction-to-dom-events">
<h3 title="Introduction to “DOM Events”">2.1. “DOM Events” 序論</h3>

<!-- ^@EventTarget -->

<p>
~web~platformを全体を通して、`~event$は
— 何かが生じたことを通達するために —
~objに向けて`配送-$される
— ~network活動や利用者とのヤリトリなど。
これらの~objは $EventTarget ~interfaceを実装し，
その $addEventListener() を~callすることにより
`~event$を観測するための`~event~listener$を追加できる：
◎
Throughout the web platform events are dispatched to objects to signal an occurrence, such as network activity or user interaction. These objects implement the EventTarget interface and can therefore add event listeners to observe events by calling addEventListener():
</p>

<div class="example">
<pre class="lang-js">
%obj.addEventListener("load", imgFetched)

function imgFetched(%ev) {
  // <span class="comment" title="great success">成功裡に load できた</span>
  …
}
</pre>

</div>

<p>
`~event~listener$は、次のいずれかにより除去できる：
◎
↓</p>
<ul>
	<li>
$removeEventListener() ~methodに $addEventListener() と同じ引数たちを渡すことにより。
◎
Event listeners can be removed by utilizing the removeEventListener() method, passing the same arguments.
</li>
	<li>
$addEventListener() に［
ある $@AbortController %controller の`通達$aB【！$AbortSignal】
］を渡して，
%controller の $abort() を~callすることにより。
◎
Alternatively, event listeners can be removed by passing an AbortSignal to addEventListener() and calling abort() on the controller owning the signal.
</li>
</ul>

<!-- ^@Event -->

<p>
`~event$もまた~objであり，
$Event ~interface（またはその派生d~interface）を実装する。
上の例では、 %ev が`~event$である。
%ev は、`~event~listener$の `callback$evL （概して上に示したような~JS Function ）に引数として渡される。
`~event~listener$は、まず，`~event$の $type 属性~値（上の例では `load^l ）をその~~制御に利用する。
`~event$の $target 属性~値は`~event$の`配送-$先の~obj（上の例の %obj ）を返す。
◎
Events are objects too and implement the Event interface (or a derived interface). In the example above ev is the event. ev is passed as an argument to the event listener’s callback (typically a JavaScript Function as shown above). Event listeners key off the event’s type attribute value ("load" in the above example). The event’s target attribute value returns the object to which the event was dispatched (obj above).
</p>

<p id="synthetic-events">
`~event$は、概して，利用者とのヤリトリや何らかの~task完了の結果，~UAにより`配送-$されるが、~app自身も，合成な~eventと共通的に称されるものを利用して`~event$を`配送-$できる：
◎
Although events are typically dispatched by the user agent as the result of user interaction or the completion of some task, applications can dispatch events themselves by using what are commonly known as synthetic events:
</p>

<div class="example">
<pre class="lang-js">
// <span class="comment" title="add an appropriate event listener">~custom~event~listenerを追加する</span>
obj.addEventListener("cat", function(%e) { process(%e.detail) })

// <span class="comment" title="create and dispatch the event">~eventを作成して配送する</span>
var %event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
%obj.dispatchEvent(%event)</pre></div>

<p>
通達-時の他にも、`~event$は，演算の中で次に起きる出来事を~appに制御させる~~目的で利用されることがある。
例えば，~form提出の一環として、 $type 属性が `submit^l にされた`~event$が`配送-$される。
この`~event$の $preventDefault() ~methodが呼出されると，~formは提出されずに終了されることになる。
~appにより`配送-$される`~event$（合成な~event）を通して，この機能性を利用する場合、 $EventTarget.dispatchEvent() ~methodの返り値も利用できる：
◎
Apart from signaling, events are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an event whose type attribute value is "submit" is dispatched. If this event’s preventDefault() method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through events dispatched by the application (synthetic events) can make use of the return value of the dispatchEvent() method:
</p>

<div class="example">

<pre class="lang-js">
if(%obj.dispatchEvent(%event)) {
  // <span class="comment" title="event was not canceled, time for some magic">~eventは取消されなかった。手品の時間だ。</span>
  …
}
</pre>

</div>

<p>
`~event$が`~tree$に`関与-$している~obj（例えば`要素$）に向けて`配送-$される場合、その~eventは，その~objの`先祖$の`~event~listener$にも到達し得る：
◎
When an event is dispatched to an object that participates in a tree (e.g., an element), it can reach event listeners on that object’s ancestors too.＼
</p>
<ol>
	<li>
まず、~objの各 `広義-先祖$に対し，`~tree順序$で
⇒
その`~event~listener$†のうち［
`capture$evLが ~T にされているもの
］が呼出される
◎
Effectively, all the object’s inclusive ancestor event listeners whose capture is true are invoked, in tree order.＼
</li>
	<li>
次に，［
`~event$の $bubbles ~EQ ~T
］ならば、~objの各 `広義-先祖$に対し，今度は`~tree順序$の逆順で
⇒
その`~event~listener$†のうち［
`capture$evLが ~F にされているもの
］が呼出される
◎
And then, if event’s bubbles is true, all the object’s inclusive ancestor event listeners whose capture is false are invoked, now in reverse tree order.
</li>
</ol>

<p class="trans-note">【†
当の広義-先祖の`~event~listener~list$内の`~event~listener$のうち，その `type$evL は `~event$の $type に合致するもの。
該当する~event~listenerが呼出される順序は、この~listが管理する。
】</p>

<div class="example">
<p>
`~event$が`~tree$内で働く様子を例で示す：
◎
Let’s look at an example of how events work in a tree:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;つまらない例&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello <mark>&lt;span id=x&gt;world&lt;/span&gt;</mark>!&lt;/p&gt;
  &lt;script&gt;
<code
>function test(%e) {
  debug(%e.target, %e.currentTarget, %e.eventPhase); // A
}
document.addEventListener("hey", test, {capture: true}); // B
document.body.addEventListener("hey", test); // C
var %ev = new Event("hey", {bubbles:true})
document.getElementById(<mark>"x"</mark>).dispatchEvent(%ev);</code>
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
`debug^c 関数（A）は 2 回~呼出されることになる。
2 回とも、`~event$の $target 属性~値は <mark>`span^c `要素$</mark> になる。
1 回目での $currentTarget 属性~値は`文書$になり（B）,
$eventPhase 属性の値が $CAPTURING_PHASE から $BUBBLING_PHASE に切り替わった後,
2 回目では `body^e `要素$になる（C）。
もし`~event~listener$が `span^e `要素$にも登録されていたなら、$eventPhase 属性の値は $AT_TARGET にも切り替わることになる。
◎
The debug function will be invoked twice. Each time the event’s target attribute value will be the span element. The first time currentTarget attribute’s value will be the document, the second time the body element. eventPhase attribute’s value switches from CAPTURING_PHASE to BUBBLING_PHASE. If an event listener was registered for the span element, eventPhase attribute’s value would have been AT_TARGET.
</p>
</div>

		</section>
		<section id="interface-event">
<h3 title="Interface CustomEvent">2.2. ^@Event ~interface</h3>

！！
[`Exposed$=(Window,Worker,AudioWorklet)]
interface @Event {
  `Event$mc($DOMString %type, optional $EventInit %eventInitDict = {});

  ~RA $DOMString $type;
  ~RA $EventTarget? $target;
  ~RA $EventTarget? $srcElement; // <span id="cp-legacy" class="comment" title="legacy">旧来</span>
  ~RA $EventTarget? $currentTarget;
  $sequence&lt;$EventTarget&gt; $composedPath();

  const `unsigned short$ $NONE = 0;
  const `unsigned short$ $CAPTURING_PHASE = 1;
  const `unsigned short$ $AT_TARGET = 2;
  const `unsigned short$ $BUBBLING_PHASE = 3;
  ~RA `unsigned short$ $eventPhase;

  $undefined $stopPropagation();
           attribute $boolean $cancelBubble; // <span class="comment" title="legacy alias of .stopPropagation()">`stopPropagation()^c の旧来の別名</span>
  $undefined $stopImmediatePropagation();

  ~RA $boolean $bubbles;
  ~RA $boolean $cancelable;
           attribute $boolean $returnValue;  // <!--cp-legacy-->
  $undefined $preventDefault();
  ~RA $boolean $defaultPrevented;
  ~RA $boolean $composed;

  [`LegacyUnforgeable$] ~RA $boolean $isTrusted;
  ~RA $DOMHighResTimeStamp $timeStamp;

  $undefined $initEvent($DOMString %type, optional $boolean %bubbles = false, optional $boolean %cancelable = false); // <!--cp-legacy-->
};

dictionary @EventInit {
  $boolean @EventInit.bubbles = false;
  $boolean @EventInit.cancelable = false;
  $boolean @EventInit.composed = false;
};
！

<p>
$Event ~objは、単に
`~event@
とも称される。
それは、何かが生じたとき，それを通達できるようにする
— 例えば、画像を~downloadが完了したときなど。
◎
An Event object is simply named an event. It allows for signaling that something has occurred, e.g., that an image has completed downloading.
</p>

<p>
`~event~targetになり得るもの@
は、［
~NULL ／ $EventTarget ~obj
］である。
◎
A potential event target is null or an EventTarget object.
</p>

<p>
各`~event$には、次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~target@</dt>
	<dd>
`~event~targetになり得るもの$。
他が言明されない限り， ~NULL とする。
◎
An event has an associated target (a potential event target). Unless stated otherwise it is null.
</dd>

	<dt>`関係する~target@</dt>
	<dd>
`~event~targetになり得るもの$。
他が言明されない限り， ~NULL とする。
◎
An event has an associated relatedTarget (a potential event target). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
他の仕様は ^relatedTarget 属性を定義するときに `関係する~target$を利用する。
`UIEVENTS$r
◎
Other specifications use relatedTarget to define a relatedTarget attribute. [UIEVENTS]
</dd>

	<dt>`~touch~target~list@</dt>
	<dd>
0 個~以上の`~event~targetになり得るもの$からなる`~list$。
他が言明されない限り，`空$とする。
◎
An event has an associated touch target list (a list of zero or more potential event targets). Unless stated otherwise it is the empty list.
</dd>
	<dd class="note">注記：
`~touch~target~list$は、もっぱら
$TouchEvent ~interfaceとそれに関係する~interfaceを定義するために利用される。
`TOUCH-EVENTS$r
◎
The touch target list is for the exclusive use of defining the TouchEvent interface and related interfaces. [TOUCH-EVENTS]
</dd>

	<dt>`経路@</dt>
	<dd>
<p>
`~list$であり、初期~時は`空$とする。
それを成す各`~item$は、次に挙げるものからなる`構造体$である：
</p>
		<ul class="def-list">
			<li>
`呼出n~target@evP
⇒
$EventTarget ~obj
</li>
			<li>
`呼出n~targetは~shadow~tree内か@evP
⇒
真偽値
</li>
			<li>
`~shadow調整-済み~target@evP
⇒
`~event~targetになり得るもの$
</li>
			<li>
`関係する~target@evP
⇒
`~event~targetになり得るもの$
</li>
			<li>
`~touch~target~list@evP
⇒
0 個以上の`~event~targetになり得るもの$からなる`~list$
</li>
			<li>
`閉な~treeの根か@evP
⇒
真偽値
</li>
			<li>
`~slotは閉な~tree内か@evP
⇒
真偽値
</li>
		</ul>

◎
An event has an associated path. A path is a list of structs. Each struct consists of an invocation target (an EventTarget object), an invocation-target-in-shadow-tree (a boolean), a shadow-adjusted target (a potential event target), a relatedTarget (a potential event target), a touch target list (a list of potential event targets), a root-of-closed-tree (a boolean), and a slot-in-closed-tree (a boolean). A path is initially the empty list.
</dd>
</dl>

<dl class="domintro">
	<dt>%event = $Event(type [, eventInitDict])</dt>
	<dd>
$type 属性~値が %type にされた，新たな %event を返す。
%eventInitDict 引数により，［
$bubbles ／ $cancelable
］属性も
— 同じ名前の~obj~memberを介して —
設定できる。
◎
Returns a new event whose type attribute value is set to type. The eventInitDict argument allows for setting the bubbles and cancelable attributes via object members of the same name.
</dd>

	<dt>%event . $type</dt>
	<dd>
%event の型を返す。
例えば
`click^l,
`hashchange^l,
`submit^l
など。
◎
Returns the type of event, e.g. "click", "hashchange", or "submit".
</dd>

	<dt>%event . $target</dt>
	<dd>
%event の`配送-$先の~obj（ %event の`~target$ ）を返す。
◎
Returns the object to which event is dispatched (its target).
</dd>

	<dt>%event . $currentTarget</dt>
	<dd>
現在~呼出されている `callback$evL を持つ`~event~listener$が登録されている~objを返す。
◎
Returns the object whose event listener’s callback is currently being invoked.
</dd>

	<dt>%event . $composedPath()</dt>
	<dd>
%event の`経路$内に在る各 `呼出n~target$evP ~obj（それ上で~listenerが呼出される~obj）からなる~listを返す
— ただし、［
`~shadow根$の`~mode$sR ~EQ `closed^l
］なる`~shadow~tree$内の`~node$であって， %event の $currentTarget からは到達できないものは、返り値から除かれる。
◎
Returns the invocation target objects of event’s path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root’s mode is "closed" that are not reachable from event’s currentTarget.
</dd>

	<dt>%event . $eventPhase</dt>
	<dd>
`~event$の相
— 次ののいずれかを返す
⇒＃
$NONE,
$CAPTURING_PHASE,
$AT_TARGET,
$BUBBLING_PHASE
◎
Returns the event’s phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.
</dd>

	<dt>%event . $stopPropagation()</dt>
	<dd>
`~tree$ 内に`配送-$されているとき、この~methodを呼出すことにより，現在の~obj以外の~objには %event が到達しないようになる。
◎
When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.
</dd>

	<dt>%event . $stopImmediatePropagation()</dt>
	<dd>
この~methodを呼出すことにより、
%event は 現在の~listenerを走り終えた後に［
それまでに登録された`~event~listener$
］には到達しなくなり、`~tree$ 内に`配送-$されたときには， %event は他のどの~objにも到達しなくなる。
◎
Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.
</dd>

	<dt>%event . $bubbles</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
%event がその`~target$の`先祖$へ`~tree順序$の逆順にも遡る場合は ~T を返す／
他の場合は~F を返す。
◎
Returns true or false depending on how event was initialized. True if event goes through its target’s ancestors in reverse tree order; otherwise false.
</dd>

	<dt>%event . $cancelable</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か ~F を返す。
その返り値は常に意味を持つとは限らないが、~T の場合，
%event が`配送-$されている間の演算は
$preventDefault() ~methodを呼出すことにより取消せることを指示し得る。
<!--  -->
◎
Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.
</dd>

	<dt>%event . $preventDefault()</dt>
	<dd>
%event の $cancelable 属性~値が ~T にされている下で，［
$AddEventListenerOptions.passive が ~F に設定された %event
］用の~listenerの実行-中に呼出された場合、
%event が取消される必要がある旨をその`配送-$ 演算に通達する。
◎
If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.
</dd>

	<dt>%event . $defaultPrevented</dt>
	<dd>
~T は、 $preventDefault() が呼出され, 成功裡に取消されたことを指示する。
他の場合は ~F を返す。
◎
Returns true if preventDefault() was invoked successfully to indicate cancelation; otherwise false.
</dd>

	<dt>%event . $composed</dt>
	<dd>
%event がどう初期化されたかに依存して［
~T ／ ~F
］を返す。
［
%event の`~target$の`根$が $ShadowRoot `~node$である
］ときに，［
その~nodeを過ぎた先†に在る~listenerも呼出す場合は ~T ／
他の場合は ~F
］になる。
◎
Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target; otherwise false.
</dd>
	<dd class="trans-note">【†
%~event の`経路$が、`~shadow根$の`~host$を通して別の`~node~tree$へつながるように，構成される。
】</dd>

	<dt>%event . $isTrusted</dt>
	<dd>
%event は~UAから`配送-$されたもの［
であるならば ~T ／
でないならば ~F
］を返す。
◎
Returns true if event was dispatched by the user agent, and false otherwise.
</dd>

	<dt>%event . $timeStamp</dt>
	<dd>
%event の時刻印を`時刻起点$からのミリ秒数で返す。
◎
Returns the event’s timestamp as the number of milliseconds measured relative to the time origin.
</dd>
</dl>

<div class="algo">
<p>
@type
取得子~手続きは、初期化-時の値を返す。
`~event$の作成-時には、この属性は空~文字列に初期化するモノトスル。
◎
The type attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

</div>

<div class="algo">
@target
取得子~手続きは
⇒
~RET コレの`~target$
◎
The target getter steps are to return this’s target.
</div>

<div class="algo">
@srcElement
取得子~手続きは
⇒
~RET コレの`~target$
◎
The srcElement getter steps are to return this’s target.
</div>

<div class="algo">
<p>
@currentTarget
取得子~手続きは、初期化-時の値を返す。
◎
The currentTarget attribute must return the value it was initialized to.＼
</p>

<p>
`~event$の作成-時には、この属性は ~NULL に初期化するモノトスル。
◎
When an event is created the attribute must be initialized to null.
</div>

<div class="algo">
<p>
@composedPath()
~method~手続きは：
◎
The composedPath() method steps are:
</p>
		<ol>
			<li>
%~composed経路 ~LET 空`~list$
◎
Let composedPath be an empty list.
</li>
			<li>
%経路 ~LET コレの`経路$
◎
Let path be this’s path.
</li>
			<li>
~IF［
%経路 は`空$である
］
⇒
~RET %~composed経路
◎
If path is empty, then return composedPath.
</li>
			<li>
%現-~target ~LET コレの $currentTarget 属性~値
◎
Let currentTarget be this’s currentTarget attribute value.
</li>
			<li>
%~composed経路 に %現-~target を`付加する$
◎
Append currentTarget to composedPath.
</li>
			<li>
%現-~target~index ~LET 0
◎
Let currentTargetIndex be 0.
</li>
			<li>
%現-~targetの非可視~下位tree~level ~LET 0
◎
Let currentTargetHiddenSubtreeLevel be 0.
</li>
			<li>
%~index ~LET %経路 の`~size$ − 1
◎
Let index be path’s size − 1.
</li>
			<li>
<p>
~WHILE［
%~index ~GTE 0
］：
◎
While index is greater than or equal to 0:
</p>
				<ol>
					<li>
~IF［
%経路[ %~index ] の`閉な~treeの根か$evP ~EQ ~T
］
⇒
%現-~targetの非可視~下位tree~level ~INCBY 1
◎
If path[index]'s root-of-closed-tree is true, then increase currentTargetHiddenSubtreeLevel by 1.
</li>
					<li>
~IF［
%経路[ %~index ] の`呼出n~target$evP ~EQ %現-~target
］
⇒＃
%現-~target~index ~SET %~index；
~BREAK
◎
If path[index]'s invocation target is currentTarget, then set currentTargetIndex to index and break.
</li>
					<li>
~IF［
%経路[ %~index ] の`~slotは閉な~tree内か$evP ~EQ ~T
］
⇒
%現-~targetの非可視~下位tree~level ~DECBY 1
◎
If path[index]'s slot-in-closed-tree is true, then decrease currentTargetHiddenSubtreeLevel by 1.
</li>
					<li>
%~index ~DECBY 1
◎
Decrease index by 1.
</li>
				</ol>
			</li>
			<li>
%現-非可視~level ~LET %現-~targetの非可視~下位tree~level
◎
↓</li>
			<li>
%最大-非可視~level ~LET %現-~targetの非可視~下位tree~level
◎
Let currentHiddenLevel and maxHiddenLevel be currentTargetHiddenSubtreeLevel.
</li>
			<li>
%~index ~SET %現-~target~index ~MINUS 1
◎
Set index to currentTargetIndex − 1.
</li>
			<li>
<p>
~WHILE［
%~index ~GTE 0
］：
◎
While index is greater than or equal to 0:
</p>
				<ol>
					<li>
~IF［
%経路[ %~index ] の`閉な~treeの根か$evP ~EQ ~T
］
⇒
%現-非可視~level ~INCBY 1
◎
If path[index]'s root-of-closed-tree is true, then increase currentHiddenLevel by 1.
</li>
					<li>
~IF［
%現-非可視~level ~LTE %最大-非可視~level
］
⇒
%~composed経路 に %経路[ %~index ] の`呼出n~target$evPを`前付加する$
◎
If currentHiddenLevel is less than or equal to maxHiddenLevel, then prepend path[index]'s invocation target to composedPath.
</li>
					<li>
<p>
~IF［
%経路[ %~index ] の`~slotは閉な~tree内か$evP ~EQ ~T
］：
◎
If path[index]'s slot-in-closed-tree is true, then:
</p>

						<ol>
							<li>
%現-非可視~level ~DECBY 1
◎
Decrease currentHiddenLevel by 1.
</li>
							<li>
~IF［
%最大-非可視~level ~GTE %現-非可視~level
］
⇒
%最大-非可視~level ~SET %現-非可視~level
◎
If currentHiddenLevel is less than maxHiddenLevel, then set maxHiddenLevel to currentHiddenLevel.
</li>
						</ol>
					</li>
					<li>
%~index ~DECBY 1
◎
Decrease index by 1.
</li>
				</ol>
			</li>
			<li>
%現-非可視~level ~SET %現-~targetの非可視~下位tree~level
◎
↓</li>
			<li>
%最大-非可視~level ~SET %現-~targetの非可視~下位tree~level
◎
Set currentHiddenLevel and maxHiddenLevel to currentTargetHiddenSubtreeLevel.
</li>
			<li>
%~index ~SET %現-~target~index ~PLUS 1
◎
Set index to currentTargetIndex + 1.
</li>
			<li>
<p>
~WHILE［
%~index ~LT %経路 の`~size$
］：
◎
While index is less than path’s size:
</p>
				<ol>
					<li>
~IF［
%経路[ %~index ] の`~slotは閉な~tree内か$evP ~EQ ~T
］
⇒
%現-非可視~level ~INCBY 1
◎
If path[index]'s slot-in-closed-tree is true, then increase currentHiddenLevel by 1.
</li>
					<li>
~IF［
%現-非可視~level ~LTE %最大-非可視~level
］
⇒
%~composed経路 に %経路[ %~index ] の`呼出n~target$evPを`付加する$
◎
If currentHiddenLevel is less than or equal to maxHiddenLevel, then append path[index]'s invocation target to composedPath.
</li>
					<li>
<p>
~IF［
%経路[ %~index ] の`閉な~treeの根か$evP ~EQ ~T
］：
◎
If path[index]'s root-of-closed-tree is true, then:
</p>
						<ol>
							<li>
%現-非可視~level ~DECBY 1
◎
Decrease currentHiddenLevel by 1.
</li>
							<li>
~IF［
%最大-非可視~level ~GTE %現-非可視~level
］
⇒
%最大-非可視~level ~SET %現-非可視~level
◎
If currentHiddenLevel is less than maxHiddenLevel, then set maxHiddenLevel to currentHiddenLevel.
</li>
						</ol>
					</li>
					<li>
%~index ~INCBY 1
◎
Increase index by 1.
</li>
				</ol>
			</li>
			<li>
~RET %~composed経路
◎
Return composedPath.
</li>
		</ol>
</div>

<div class="algo">
<p>
@eventPhase
取得子~手続きは、初期化-時の値を返す
— それは、次のいずれかをとるモノトスル（括弧内は数-値）：
◎
The eventPhase attribute must return the value it was initialized to, which must be one of the following:
</p>
<dl>
	<dt>@NONE (0)</dt>
	<dd>
まだ`配送-$されていない`~event$はこの相に属する。
◎
Events not currently dispatched are in this phase.
</dd>

	<dt>@CAPTURING_PHASE (1)</dt>
	<dd>
`~event$が`~tree$に`関与-$している~objに向けて`配送-$されるとき、~eventがその`~target$に到達するまでは，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase before it reaches its target.
</dd>

	<dt>@AT_TARGET (2)</dt>
	<dd>
`~event$が`配送-$されるとき、~eventの`~target$上では，この相に属する。
◎
When an event is dispatched it will be in this phase on its target.
</dd>

	<dt>@BUBBLING_PHASE (3)</dt>
	<dd>
`~event$が`~tree$に`関与-$している~objに向けて`配送-$されるとき、~eventがその`~target$に到達した後は，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase after it reaches its target.
</dd>
</dl>

<p>
`~event$の作成-時には、この属性は $NONE に初期化するモノトスル。
◎
Initially the attribute must be initialized to NONE.
</p>
</div>

<p>
各`~event$には、次に挙げるものが結付けられる
— いずれも真偽値をとり，初期~時は ~F とする
⇒＃
`伝播を停止するか@ev,
`伝播を即時に停止するか@ev,
`取消されたか@ev,
`受動~listener内か@ev,
`~composedか@ev,
`初期化-済みか@ev,
`配送-中か@ev
◎
Each event has the following associated flags that are all initially unset:
• stop propagation flag
• stop immediate propagation flag
• canceled flag
• in passive listener flag
• composed flag
• initialized flag
• dispatch flag
</p>

<div class="algo">
@stopPropagation()
~method~手続きは
⇒
コレの`伝播を停止するか$ev ~SET ~T
◎
The stopPropagation() method steps are to set this’s stop propagation flag.
</div>

<div class="algo">
@cancelBubble
取得子~手続きは
⇒
~RET コレの`伝播を停止するか$ev
◎
The cancelBubble getter steps are to return true if this’s stop propagation flag is set; otherwise false.
</div>

<div class="algo">
$cancelBubble 設定子~手続きは
⇒
~IF［
所与の値 ~EQ ~T
］
⇒
コレの`伝播を停止するか$ev ~SET ~T
◎
The cancelBubble setter steps are to set this’s stop propagation flag if the given value is true; otherwise do nothing.
</div>

<div class="algo">
@stopImmediatePropagation()
~method~手続きは
⇒＃
コレの`伝播を停止するか$ev ~SET ~T；
コレの`伝播を即時に停止するか$ev ~SET ~T
◎
The stopImmediatePropagation() method steps are to set this’s stop propagation flag and this’s stop immediate propagation flag.
</div>

<div class="algo">
@bubbles
取得子~手続きは、初期化-時の値を返す。
◎
The bubbles and cancelable attributes must return the values they were initialized to.
</div>

<div class="algo">
@cancelable
取得子~手続きは、初期化-時の値を返す。
◎
↑</div>

<div class="algo">
<p>
`取消されたかを設定する@
ときは、所与の
( `~event$ %~event )
に対し，次を走らすモノトスル
⇒
~IF［
%~event の $cancelable 属性~値 ~EQ ~T
］~AND［
%~event の`受動~listener内か$ev ~EQ ~F
］
⇒
%~event の`取消されたか$ev ~SET ~T
◎
To set the canceled flag, given an event event, if event’s cancelable attribute value is true and event’s in passive listener flag is unset, then set event’s canceled flag, and do nothing otherwise.
</p>
</div>

<div class="algo">
@returnValue
取得子~手続きは
⇒
~RET コレの`取消されたか$ev
◎
The returnValue getter steps are to return false if this’s canceled flag is set; otherwise true.
</div>

<div class="algo">
$returnValue 設定子~手続きは
⇒
~IF［
所与の値 ~EQ ~F
］
⇒
`取消されたかを設定する$( コレ )
◎
The returnValue setter steps are to set the canceled flag with this if the given value is false; otherwise do nothing.
</div>

<div class="algo">
<p>
@preventDefault()
~method~手続きは
⇒
`取消されたかを設定する$( コレ )
◎
The preventDefault() method steps are to set the canceled flag with this.
</p>

<p class="note">注記：
$preventDefault() を呼出しても効果がない局面もある。
~UAには、~debugを援助するため，精確な~~原因を開発者~consoleに~logすることが奨励される。
◎
There are scenarios where invoking preventDefault() has no effect. User agents are encouraged to log the precise cause in a developer console, to aid debugging.
</p>
</div>

<div class="algo">
@defaultPrevented
取得子~手続きは
⇒
~RET コレの`取消されたか$ev
◎
The defaultPrevented getter steps are to return true if this’s canceled flag is set; otherwise false.
</div>

<div class="algo">
@composed
取得子~手続きは
⇒
~RET コレの`~composedか$ev
◎
The composed getter steps are to return true if this’s composed flag is set; otherwise false.
</div>

<div class="algo">
<p>
@isTrusted
取得子~手続きは、初期化-時の値を返す。
◎
The isTrusted attribute must return the value it was initialized to.＼
</p>

<p>
`~event$の作成-時には、この属性は ~F に初期化するモノトスル。
◎
When an event is created the attribute must be initialized to false.
</p>

<p class="note">注記：
$isTrusted は、`~event$は（ $EventTarget.dispatchEvent() を利用してではなく）~UAにより`配送-$されたかどうかを簡便に指示する。
唯一の旧来の例外は `click()$m であり，~UAに`~event$を［
$isTrusted 属性は ~F に初期化-
］した上で配送させる。
◎
isTrusted is a convenience that indicates whether an event is dispatched by the user agent (as opposed to using dispatchEvent()). The sole legacy exception is click(), which causes the user agent to dispatch an event whose isTrusted attribute is initialized to false.
</p>
</div>

<div class="algo">
@timeStamp
取得子~手続きは、初期化-時の値を返す。
◎
The timeStamp attribute must return the value it was initialized to.
</div>

<div class="algo">
<p>
`~eventを初期化する@
ときは、所与の
( %event, %type, %bubbles, %cancelable )
に対し，
%event の各種~propを次のように設定するモノトスル
⇒＃
`初期化-済みか$ev ~SET ~T,
`伝播を停止するか$ev ~SET ~F,
`伝播を即時に停止するか$ev ~SET ~F,
`取消されたか$ev ~SET ~F,
$isTrusted 属性 ~SET ~F,
`~target$ ~SET ~NULL,
$type 属性 ~SET %type,
$bubbles 属性 ~SET %bubbles,
$cancelable 属性 ~SET %cancelable
◎
To initialize an event, with type, bubbles, and cancelable, run these steps:
• Set event’s initialized flag.
• Unset event’s stop propagation flag, stop immediate propagation flag, and canceled flag.
• Set event’s isTrusted attribute to false.
• Set event’s target to null.
• Set event’s type attribute to type.
• Set event’s bubbles attribute to bubbles.
• Set event’s cancelable attribute to cancelable.
</p>
</div>

<div class="algo">
<p>
@initEvent(type, bubbles, cancelable)
~method~手続きは：
◎
The initEvent(type, bubbles, cancelable) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
◎
If this’s dispatch flag is set, then return.
</li>
	<li>
`~eventを初期化する$( コレ, %type, %bubbles, %cancelable )
◎
Initialize this with type, bubbles, and cancelable.
</li>
</ol>

<p class="note">注記：
$initEvent() は、`~event$には構築子があるので冗長であり，
$composed も設定できないが、旧来の内容~用に~supportされる必要がある。
◎
initEvent() is redundant with event constructors and incapable of setting composed. It has to be supported for legacy content.
</p>
</div>

		</section>
		<section id="interface-window-extensions">
<h3 title="Legacy extensions to the Window interface">2.3. ^Window ~interfaceに対する旧来の拡張</h3>

！！
partial interface $Window {
  [`Replaceable$] ~RA ($Event or $undefined) `event$m; // <!--cp-legacy-->
};
！

<p>
各 $Window ~objには
`現在の~event@
が結付けられる。
それは，［
$undefined ／ $Event ~obj
］であり、他が言明されない限り， $undefined とする。
◎
Each Window object has an associated current event (undefined or an Event object). Unless stated otherwise it is undefined.
</p>

<div class="algo">
`event@m
取得子~手続きは
⇒
~RET コレの`現在の~event$
◎
The event getter steps are to return this’s current event.
</div>

<p class="note">注記：
~web開発者には、代わりに~event~listenerに渡される $Event ~objに依拠することが強く奨励される
— その方が、~codeは より~portableになるので。
この属性は、~workerや~worklet内では可用でなく，
`~shadow~tree$内に配送される~event用には 不正確になる。
◎
Web developers are strongly encouraged to instead rely on the Event object passed to event listeners, as that will result in more portable code. This attribute is not available in workers or worklets, and is inaccurate for events dispatched in shadow trees.
</p>

		</section>
		<section id="interface-customevent">
<h3 title="Interface CustomEvent">2.4. ^@CustomEvent ~interface</h3>

！！
[`Exposed$=(Window,Worker)]
interface @CustomEvent : $Event {
  `CustomEvent$mc($DOMString %type, optional $CustomEventInit %eventInitDict = {});

  ~RA $any $detail;

  $undefined $initCustomEvent($DOMString %type, optional $boolean %bubbles = false, optional $boolean %cancelable = false, optional $any %detail = null); // <!--cp-legacy-->
};

dictionary @CustomEventInit : $EventInit {
  $any @CustomEventInit.detail = null;
};
！

<!-- ^@CustomEvent -->
<p>
~custom~dataを運ばせる用途に，
$CustomEvent ~interfaceを利用する`~event$を利用できる。
◎
Events using the CustomEvent interface can be used to carry custom data.
</p>

<dl class="domintro">
	<dt>%event = $CustomEvent(type [, eventInitDict])</dt>
	<dd>
$Event の構築子と相似的に働く
— %eventInitDict 引数により， $detail 属性も設定できることを除いて。
◎
Works analogously to the constructor for Event except that the eventInitDict argument now allows for setting the detail attribute too.
</dd>

	<dt>%event . $detail</dt>
	<dd>
%event の作成-時に与えられた~custom~dataを返す。
概して，合成な~eventで利用される。
【！initCustomEvent is dead】
◎
Returns any custom data event was created with. Typically used for synthetic events.
</dd>
</dl>

<div class="algo">
@detail
取得子~手続きは、初期化-時の値を返す。
◎
The detail attribute must return the value it was initialized to.
</div>

<div class="algo">
<p>
@initCustomEvent(type, bubbles, cancelable, detail)
~method~手続きは：
◎
The initCustomEvent(type, bubbles, cancelable, detail) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
◎
If this’s dispatch flag is set, then return.
</li>
	<li>
`~eventを初期化する$( コレ, %type, %bubbles, %cancelable )
◎
Initialize this with type, bubbles, and cancelable.
</li>
	<li>
コレの $detail 属性 ~SET %detail
◎
Set this’s detail attribute to detail.
</li>
</ol>
</div>

		</section>
		<section id="constructing-events">
<h3 title="Constructing events">2.5. ~eventの構築-法</h3>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~event$用に
`~event構築-時の手続き@
を定義してもヨイ。
この~algoは、`~eventを内的に作成する$手続き内から，
( `~event$ %~event, $EventInit %辞書 )
を渡して呼出される。
◎
Specifications may define event constructing steps for all or some events. The algorithm is passed an event event and an EventInit eventInitDict as indicated in the inner event creation steps.
</p>

<p class="note">注記：
この構成子は、 $Event の下位classが，その初期化-用の辞書~memberと~IDL属性とが一対一に対応していない，より複階的な構造を有するときに利用できる。
◎
This construct can be used by Event subclasses that have a more complex structure than a simple 1:1 mapping between their initializing dictionary members and IDL attributes.
</p>

<div class="algo">
<p>
`~event構築子@
— ［
$Event ~interface, または それを継承する~interface
］ %~interface の構築子 —
この仕様においては
@Event.Event(type, eventInitDict),
@CustomEvent.CustomEvent(type, eventInitDict)
— は、次の手続きを走らすモノトスル：
◎
When a constructor of the Event interface, or of an interface that inherits from the Event interface, is invoked, these steps must be run, given the arguments type and eventInitDict:
</p>
<ol>
	<li>
%~event ~LET `~eventを内的に作成する$( %~interface, ~NULL, 現在時, %eventInitDict )
◎
Let event be the result of running the inner event creation steps with this interface, null, now, and eventInitDict.
</li>
	<li>
%~event の $Event.type 属性 ~SET %type に初期化する
◎
Initialize event’s type attribute to type.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>
</div>

<div class="algo">
<p>
`~eventを作成する@
ときは、所与の
⇒＃
%~event~interface （ $Event または それを継承する~interface ）,
%~realm （ `~Realm$, 省略時は ~NULL ）
◎終
に対し，次を走らす：
◎
To create an event using eventInterface, which must be either Event or an interface that inherits from it, and optionally given a Realm realm, run these steps:
• If realm is not given, then set it to null.
</p>
<ol>
	<li>
<p>
%辞書 ~LET ~JS `undefined^jv 値を［
%~event~interface の構築子が引数に受容する`辞書$型（ $EventInit またはそれを継承する辞書~型）
］に`変換-$した結果
◎
Let dictionary be the result of converting the JavaScript value undefined to the dictionary type accepted by eventInterface’s constructor. (This dictionary type will either be EventInit or a dictionary that inherits from it.)
</p>

<p class="XXX">
これは、当の辞書~型に必須な~memberが在る場合に働かない。
<a href="~DOMissue/600">課題 #600</a>
を見よ。
◎
This does not work if members are required; see whatwg/dom#600.
</p>

<p class="trans-note">【
$Event を継承する~interfaceであって，複数の構築子を宣言するものは、現時点では，おそらく無い（今後も定義されないと見込まれる）。
】</p>

	</li>
	<li>
<p>
%~event ~LET `~eventを内的に作成する$( 次に挙げる引数 )
⇒＃
%~event~interface,
%~realm,
当の~eventが通達している何かが生じた時刻†,
%辞書
◎
Let event be the result of running the inner event creation steps with eventInterface, realm, the time of the occurrence that the event is signaling, and dictionary.
</p>

<p class="note">†注記：
例えば macOS においては、入力~動作が生じた時刻は ^NSEvent ~objの ^timestamp ~propを介して可用になる。
◎
In macOS the time of the occurrence for input actions is available via the timestamp property of NSEvent objects.
</p>
	</li>
	<li>
%~event の $isTrusted 属性 ~SET ~T に初期化する
◎
Initialize event’s isTrusted attribute to true.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>

<p class="note">注記：
`~eventを作成する$手続きは、単純に`~eventを発火する$代わりに［
`~eventを作成する$, `~eventを配送する$
］手続きを別々に呼出す必要がある，他の仕様からの利用が~~意図されている。
これは、~eventの属性が既定の値に正しく初期化されることを確保する。
◎
Create an event is meant to be used by other specifications which need to separately create and dispatch events, instead of simply firing them. It ensures the event’s attributes are initialized to the correct defaults.
</p>
</div>

<div class="algo">
<p>
`~eventを内的に作成する@
ときは、所与の
( %~interface, %~realm, %時刻, %辞書 )
に対し，次を走らす：
◎
The inner event creation steps, given an interface, realm, time, and dictionary, are as follows:
</p>
<ol>
	<li>
<p>
%~event ~LET %~interface を利用する, %~realm 内の，新たな~obj
— ただし， %~realm ~EQ ~NULL の場合は Web IDL に定義される既定の挙動に従う
◎
Let event be the result of creating a new object using eventInterface. If realm is non-null, then use that Realm; otherwise, use the default behavior defined in Web IDL.
</p>

<p class="XXX">
これを書いている時点では、まだ Web IDL はこの既定の挙動を定義していない。
<a href="https://github.com/whatwg/webidl/issues/135">whatwg/webidl 課題 #135</a>
を見よ。
◎
As of the time of this writing Web IDL does not yet define any default behavior; see heycam/webidl#135.
</p>
	</li>
	<li>
%~event の`初期化-済みか$ev ~SET ~T
◎
Set event’s initialized flag.
</li>
	<li>
%~event の $Event.timeStamp 属性 ~SET
`細かさを抑えた相対的な高分解能~時刻$( %時刻, %~event に`関連な大域~obj$ )
◎
Initialize event’s timeStamp attribute to the relative high resolution coarse time given time and event’s relevant global object.
</li>
	<li>
%辞書 を成す
~EACH( %~member → %値 )
に対し
⇒
~IF［
%~event には %~member を`識別子$とする属性はある
］
⇒
その属性 ~SET %値 に初期化する
◎
For each member → value in dictionary, if event has an attribute whose identifier is member, then initialize that attribute to value.
</li>
	<li>
`~event構築-時の手続き$に
( %~event, %辞書 )
を渡して走らす
◎

Run the event constructing steps with event and dictionary.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>
</div>

		</section>
		<section id="defining-event-interfaces">
<h3 title="Defining event interfaces">2.6. ~event~interfaceの定義-法</h3>

<p>
一般に、$Event を継承する新たな~interfaceを定義する際には，常に
<a href="https://whatwg.org/">WHATWG</a>
または
<a href="https://www.w3.org/2008/webapps/">W3C WebApps WG</a>
~communityからの~feedbackを仰ぐように願う。
◎
In general, when defining a new interface that inherits from Event please always ask feedback from the WHATWG or the W3C WebApps WG community.
</p>

<p>
$CustomEvent ~interfaceはその出発点に利用できるものだが、 `init*Event()^c の類いの~methodは，構築子とかぶって冗長になるので導入しないように。
$Event ~interfaceを継承する~interfaceがその種の~methodを備えているのは、歴史的な理由に限られている。
◎
The CustomEvent interface can be used as starting point. However, do not introduce any init*Event() methods as they are redundant with constructors. Interfaces that inherit from the Event interface that have such a method only have it for historical reasons.
</p>

		</section>
		<section id="interface-eventtarget">
<h3 title="Interface EventTarget">2.7. ^@EventTarget ~interface</h3>

！！
[`Exposed$=(Window,Worker,AudioWorklet)]
interface @EventTarget {
  `EventTarget$mc();

  $undefined $addEventListener($DOMString %type, $EventListener? %callback, optional ($AddEventListenerOptions or $boolean) %options = {});
  $undefined $removeEventListener($DOMString %type, $EventListener? %callback, optional ($EventListenerOptions or $boolean) %options = {});
  $boolean $dispatchEvent($Event %event);
};

callback interface @EventListener {
  $undefined @EventListener.handleEvent($Event %event);
};

dictionary @@EventListenerOptions {
  $boolean @capture = false;
};

dictionary @@AddEventListenerOptions : $EventListenerOptions {
  $boolean @passive = false;
  $boolean @once = false;
  $AbortSignal @signal;
};
！

<p>
$@EventTarget ~objは、何かが生じたとき，`~event$を`配送-$できる~targetを表現する。
◎
An EventTarget object represents a target to which an event can be dispatched when something has occurred.
</p>

<p>（
各 $EventTarget ~objには、
`~event~listener~list@
が結付けられる
— それは、 0 個~以上の`~event~listener$からなる`~list$であり，初期~時には`空$とする。
◎
Each EventTarget object has an associated event listener list (a list of zero or more event listeners). It is initially the empty list.
</p>

<p>
`~event~listener@
を利用すれば、特定の`~event$を観測できる
— それは、次に挙げるものからなる：
◎
An event listener can be used to observe a specific event and consists of:
</p>

<ul>
	<li>
`type@evL
⇒
文字列
◎
type (a string)
</li>
	<li>
`callback@evL
⇒
~NULL ／ $EventListener ~obj
◎
callback (null or an EventListener object)
</li>
	<li>
`capture@evL
⇒
真偽値
— 初期~時は ~F とする
◎
capture (a boolean, initially false)
</li>
	<li>
`passive@evL
⇒
真偽値
— 初期~時は ~F とする
◎
passive (a boolean, initially false)
</li>
	<li>
`once@evL
⇒
真偽値
— 初期~時は ~F とする
◎
once (a boolean, initially false)
</li>
	<li>
`signal@evL
⇒
~NULL ／ $AbortSignal ~obj
◎
signal (null or an AbortSignal object)
</li>
	<li>
`removed@evL
⇒
内部処理用の真偽値
— 初期~時は ~F とする。
◎
removed (a boolean for bookkeeping purposes, initially false)
</li>
</ul>

<p class="note">注記：
`callback$evL は $EventListener ~objであるが、`~event~listener$は 上に示したように より広い概念である。
◎
Although callback is an EventListener object, an event listener is a broader concept as can be seen above.
</p>

<p>
各 $EventTarget ~objには、その
`親~targetを取得する@
~algoも結付けられる。
それは、所与の`~event$に対し，［
$EventTarget ~obj, または ~NULL
］を返す。
他から指定されない限り， ~NULL を返すとする。
◎
Each EventTarget object also has an associated get the parent algorithm, which takes an event event, and returns an EventTarget object. Unless specified otherwise it returns null.
</p>

<p class="note">注記：
［
`~node$ ／ `~shadow根$ ／ `文書$
］は、`親~targetを取得する$~algoを上書きする。
◎
Nodes, shadow roots, and documents override the get the parent algorithm.
</p>

<p class="trans-note">【
この~algoは、~eventの`配送-$時にその伝播`経路$を構築するために利用される。
】【
指定される個々の~algoには、渡された~eventを利用しないものもある（その場合、~eventは省略して記述され得る）。
】</p>

<p>
各 $EventTarget ~objには、
`作動化の挙動@
が結付けられ得る。
この~algoは、`~eventを配送する$~algo内から，
( `~event$ )
を渡して呼出される。
◎
Each EventTarget object can have an associated activation behavior algorithm. The activation behavior algorithm is passed an event, as indicated in the dispatch algorithm.
</p>

<p class="note">注記：
これが存在するのは、~UAが
ある種の $EventTarget ~objに対し，ある種の動作を遂行するためである
— 例えば `area$e 要素は、合成な $MouseEvent `~event$に呼応して，その $Event.type 属性は `click^l にされる。
それを除去することは、~Web互換性のため できない。
それはまた、今や，何らかの作動化を定義するときに~~尊守されている仕方になっている。
`HTML$r
◎
This exists because user agents perform certain actions for certain EventTarget objects, e.g., the area element, in response to synthetic MouseEvent events whose type attribute is click. Web compatibility prevented it from being removed and it is now the enshrined way of defining an activation of something. [HTML]
</p>

<p>
加えて、`作動化の挙動$を有する各 $EventTarget ~objには、［
`旧来の作動化~前の挙動@,
`旧来の作動化~取消~時の挙動@
］を備えるものもある（片方のみ備えることはない）。
◎
Each EventTarget object that has activation behavior, can additionally have both (not either) a legacy-pre-activation behavior algorithm and a legacy-canceled-activation behavior algorithm.
</p>

<p class="note">注記
これらの~algoは，［
Checkbox ／ Radio
］状態にある `input$e 要素のみに存在し、他では利用されない。
`HTML$r
◎
These algorithms only exist for checkbox and radio input elements and are not to be used for anything else. [HTML]
</p>

<dl class="domintro">
	<dt>%target = $EventTarget()</dt>
	<dd>
開発者が`~event$を`配送-$して~listenするために利用できる，新たな $EventTarget ~objを作成する。
◎
Creates a new EventTarget object, which can be used by developers to dispatch and listen for events.
</dd>

	<dt>%target . $addEventListener(type, callback [, options])</dt>
	<dd>
%target の`~event~listener~list$に［
$Event.type 属性~値が %type である`~event$用の`~event~listener$
］を付加する。
%callback 引数が，`~event$が`配送-$されたときに呼出される `callback$evL として設定される。
◎
Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
</dd>
	<dd>
%options 引数は、~listenerに特有な~optionを設定する。
互換性のため、これは真偽値もとり得る
— その場合、この~methodは，正確に［
%options の $EventListenerOptions.capture に その値が指定された
］かのように挙動する。
◎
The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture.
</dd>
	<dd>
%options の $EventListenerOptions.capture が［
~T ／ ［
~F または無い
］］ならば、
`callback$evL は，`~event$の $eventPhase 属性~値が［
$Event.BUBBLING_PHASE ／ $Event.CAPTURING_PHASE
］の間は呼出されないようになる。
いずれにせよ、`~event$の $Event.eventPhase 属性~値が $Event.AT_TARGET のときは，
`callback$evL は呼出される。
◎
When set to true, options’s capture prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
</dd>
	<dd>
%options の $AddEventListenerOptions.passive が ~T に設定されている場合、
`callback$evL は $Event.preventDefault() を呼出しても`~event$を取消さないことを指示する。
これは、
<a href="#observing-event-listeners">~event~listenerの観測-法</a>
に述べる処理能の最適化を可能化するために利用される
◎
When set to true, options’s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
</dd>

	<dd>
%options の $AddEventListenerOptions.once が ~T に設定されている場合、~callbackが呼出されるのは一度限りであり，その後には`~event~listener$は除去されることを指示する。
◎
When set to true, options’s once indicates that the callback will only be invoked once after which the event listener will be removed.
</dd>
	<dd>
%options の $AddEventListenerOptions.signal に $AbortSignal が渡された場合、その通達が中止されたとき~event~listenerは除去されることになる。
◎
If an AbortSignal is passed for options’s signal, then the event listener will be removed when signal is aborted.
</dd>
	<dd>
`~event~listener$は、重複しない
— すなわち， `type$evL, `callback$evL, `capture$evL のいずれかが異なる —
場合に限り，
%target の`~event~listener~list$に付加される。
◎
The event listener is appended to target’s event listener list and is not appended if it has the same type, callback, and capture.
</dd>

	<dt>%target . $removeEventListener(type, callback [, options])</dt>
	<dd>
引数と同じ［
`type$evL, `callback$evL, `capture$evL
］を持つ`~event~listener$を，
%target の`~event~listener~list$から除去する。
◎
Removes the event listener in target’s event listener list with the same type, callback, and options.
</dd>

	<dt>%target . $dispatchEvent(event)</dt>
	<dd>
合成な~event %event を %target に向けて`配送-$する。
<!-- ^@Event -->
［
%event の $cancelable 属性~値が ~F である ／
%event の $preventDefault() ~methodは呼出されなかった
］ならば ~T を返す。
他の場合は ~F を返す。
◎
Dispatches a synthetic event event to target and returns true if either event’s cancelable attribute value is false or its preventDefault() method was not invoked; otherwise false.
</dd>
</dl>

<!-- ^@EventTarget -->

<div class="algo">
<p>
%options を
`平坦~化@
するときは、次を走らす：
◎
To flatten options, run these steps:
</p>
<ol>
	<li>
~RET %options の型に応じて
⇒＃
$boolean ならば %options ／
`辞書$ならば %options[ "$EventListenerOptions.capture" ]
◎
If options is a boolean, then return options.
◎
Return options["capture"].
</li>
</ol>
</div>

<div class="algo">
<p>
%options を
`もっと平坦~化@
するときは、次を走らす：
◎
To flatten more options, run these steps:
</p>
<ol>
	<li>
( %capture, %passive, %once, %signal ) ~LET
( %options を`平坦~化$した結果, ~F, ~F, ε )
◎
Let capture be the result of flattening options.
◎
Let once and passive be false.
◎
Let signal be null.
</li>
	<li>
~IF［
%options は`辞書$である
］
⇒＃
%passive ~SET %options[ "$AddEventListenerOptions.passive" ]；
%once ~SET %options[ "$AddEventListenerOptions.once" ]；
%signal ~SET %options[ "$AddEventListenerOptions.signal" ]
◎
If options is a dictionary, then:
• Set passive to options["passive"] and once to options["once"].
• If options["signal"] exists, then set signal to options["signal"].
</li>
	<li>
~IF［
%signal ~EQ ε
］
⇒
%signal ~SET ~NULL
◎
↑</li>
	<li>
~RET ( %capture, %passive, %once, %signal )
◎
Return capture, passive, once, and signal.
</li>
</ol>
</div>

<div class="algo">
<p>
@EventTarget()
構築子~手続きは、何もしない。
◎
The new EventTarget() constructor steps are to do nothing.
</p>

<p class="note">注記：
他所に言明される既定により、返される $EventTarget の`親~targetを取得する$~algoは，~NULL を返すことになり、［
`作動化の挙動$,
`旧来の作動化~前の挙動$,
`旧来の作動化~取消~時の挙動$
］は無い。
◎
Because of the defaults stated elsewhere, the returned EventTarget's get the parent algorithm will return null, and it will have no activation behavior, legacy-pre-activation behavior, or legacy-canceled-activation behavior.
</p>

<p class="note">注記：
将来には、`親~targetを取得する$~custom~algoも許容され得る。
作者は、それが自身の~programに有用になるなら知らせてほしい。
今の所は、作者が作成したどの $EventTarget も，~tree構造には関与しない。
◎
In the future we could allow custom get the parent algorithms. Let us know if this would be useful for your programs. For now, all author-created EventTargets do not participate in a tree structure.
</p>
</div>

<div class="algo">
<p>
`~event~listenerを追加する@
ときは、所与の
( $EventTarget ~obj %~target, `~event~listener$ %~listener )
に対し，次を走らす：
◎
To add an event listener, given an EventTarget object eventTarget and an event listener listener, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~target は $ServiceWorkerGlobalScope ~objである
］~AND［
%~target の`~sw$SWGの`~script資源$の`これまでに評価されたか$ ~EQ ~T
］~AND［
%~listener の `type$evL は ある`~sw~event$の $type 属性~値に合致する†
］`SERVICE-WORKERS$r
⇒
`~consoleに警告を報告する$( “期待される結果を与えないであろう” )
◎
If eventTarget is a ServiceWorkerGlobalScope object, its service worker’s script resource’s has ever been evaluated flag is set, and listener’s type matches the type attribute value of any of the service worker events, then report a warning to the console that this might not give the expected results. [SERVICE-WORKERS]
</p>

<p class="trans-note">【†
そのような~eventの~instanceが在ることも要求しているかのように解釈できる条件だが、単に，~sw~eventの ^type 属性~値がとり得る値の集合に入ることを意味するのかも？
（しかしながら、`~event~listenerを除去する$ときのように，明示的な用語
“`取扱う~event型の集合$”
を利用していないので、実際にその解釈が意図されているのかもしれない。）
】</p>
	</li>
	<li>
%通達 ~LET %~listener の`signal$evL
◎
↓</li>
	<li>
~IF［
%通達 ~NEQ ~NULL
］~AND［
%通達 は`中止された$aB ~EQ ~T
］
⇒
~RET
◎
If listener’s signal is not null and is aborted, then return.
</li>
	<li>
~IF［
%~listener の`callback$evL ~EQ ~NULL
］
⇒
~RET
◎
If listener’s callback is null, then return.
</li>
	<li>
~IF［
次を満たす`~event~listener$ %L は無い
］…
⇒
［
%L ~IN %~target の`~event~listener~list$
］~AND［
%L の ( `type$evL, `callback$evL, `capture$evL )
~EQ
%~listener の ( `type$evL, `callback$evL, `capture$evL )
］
◎終
…ならば
⇒
%~target の`~event~listener~list$に %~listener を`付加する$
◎
If eventTarget’s event listener list does not contain an event listener whose type is listener’s type, callback is listener’s callback, and capture is listener’s capture, then append listener to eventTarget’s event listener list.
</li>
	<li>
~IF［
%通達 ~NEQ ~NULL
］
⇒
`通達に~algoを追加する$( %通達, 次を走らす中止-手続き )
⇒
`~event~listenerを除去する$( %~target, %~listener )
◎
If listener’s signal is not null, then add the following abort steps to it:
• Remove an event listener with eventTarget and listener.
</li>
</ol>

<p class="note">注記：
［
`~event~listenerを追加する$
］の概念は、［
`~event~handler$ `HTML$r が同じ `code path^en【！＊】
を利用する
］ことを確保するためにある。
◎
The add an event listener concept exists to ensure event handlers use the same code path. [HTML]
</p>
</div>

<div class="algo">
<p>
@addEventListener(type, callback, options)
~method~手続きは：
◎
The addEventListener(type, callback, options) method steps are:
</p>
<ol>
	<li>
( %capture, %passive, %once, %signal ) ~LET %options を`もっと平坦~化$した結果
◎
Let capture, passive, once, and signal be the result of flattening more options.
</li>
	<li>
`~event~listenerを追加する$( コレ, 次のように設定された`~event~listener$ )
⇒＃
`type$evL ~SET %type ,
`callback$evL ~SET %callback ,
`capture$evL ~SET %capture ,
`passive$evL ~SET %passive ,
`once$evL ~SET %once,
`signal$evL ~SET %signal
◎
Add an event listener with this and an event listener whose type is type, callback is callback, capture is capture, passive is passive, once is once, and signal is signal.
</li>
</ol>
</div>

<div class="algo">
<p>
`~event~listenerを除去する@
ときは、所与の
( $EventTarget ~obj %~target, `~event~listener$ %~listener )
に対し，次を走らす：
◎
To remove an event listener, given an EventTarget object eventTarget and an event listener listener, run these steps:
</p>
<ol>
	<li>
~IF［
%~target は $ServiceWorkerGlobalScope ~objである
］~AND［
%type 【 %~listener の `type$evL ？】 ~NIN %~target の`~sw$SWGが`取扱う~event型の集合$
］`SERVICE-WORKERS$r
⇒
`~consoleに警告を報告する$( “期待される結果を与えないであろう” )
◎
If eventTarget is a ServiceWorkerGlobalScope object and its service worker’s set of event types to handle contains type, then report a warning to the console that this might not give the expected results. [SERVICE-WORKERS]
</li>
	<li>
%~listener の `removed$evL ~SET ~T；
◎
Set listener’s removed to true and＼
</li>
	<li>
%~target の`~event~listener~list$から %~listener を`除去する$
◎
remove listener from eventTarget’s event listener list.
</li>
</ol>

<p class="note">注記：
~HTMLは、~event~handlerを定義するために これを必要とする。
`HTML$r
◎
HTML needs this to define event handlers. [HTML]
</p>
</div>

<div class="algo">
<p>
`~event~listenerをすべて除去する@
ときは、所与の
( $EventTarget ~obj %~target )
に対し，次を走らす
⇒
%~target の`~event~listener~list$を成す
~EACH( %~listener )
に対し
⇒
`~event~listenerを除去する$( %~target, %~listener )
◎
To remove all event listeners, given an EventTarget object eventTarget, for each listener of eventTarget’s event listener list, remove an event listener with eventTarget and listener.
</p>

<p class="note">注記：
~HTMLは、 ^document.open() を定義するために これを必要とする。
`HTML$r
◎
HTML needs this to define document.open(). [HTML]
</p>
</div>

<div class="algo">
<p>
@removeEventListener(type, callback, options)
~method~手続きは：
◎
The removeEventListener(type, callback, options) method steps are:
</p>
<ol>
	<li>
%capture ~LET %options を`平坦~化$した結果
◎
Let capture be the result of flattening options.
</li>
	<li>
~IF［
次を満たす`~event~listener$ %~listener は在る
］…
⇒
［
%~listener ~IN コレの`~event~listener~list$
］~AND［
%~listener の ( `type$evL, `callback$evL, `capture$evL )
~EQ
( %type, %callback, %capture )
］
◎終
…ならば
⇒
`~event~listenerを除去する$( コレ, %~listener )
◎
If this’s event listener list contains an event listener whose type is type, callback is callback, and capture is capture, then remove an event listener with this and that event listener.
</li>
</ol>

<p class="note">注記：
~event~listener~listが
( `type^evL, `callback^evL, `capture^evL )
が互いに等しい複数の~event~listenerを包含することはない。
それは、`~event~listenerを追加する$ときに防止される。
◎
The event listener list will not contain multiple event listeners with equal type, callback, and capture, as add an event listener prevents that.
</p>
</div>

<div class="algo">
<p>
@dispatchEvent(event)
~method~手続きは：
◎
The dispatchEvent(event) method steps are:
</p>
<ol>
	<li>
~IF［
%event の`配送-中か$ev ~EQ ~T
］~OR［
%event の`初期化-済みか$ev ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If event’s dispatch flag is set, or if its initialized flag is not set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
<!-- ^@Event -->
%event の $isTrusted 属性 ~SET ~F に初期化する
◎
Initialize event’s isTrusted attribute to false.
</li>
	<li>
~RET `~eventを配送する$( コレ, %event )
◎
Return the result of dispatching event to this.
</li>
</ol>
</div>

		</section>
		<section id="observing-event-listeners">
<h3 title="Observing event listeners">2.8. ~event~listenerの観測-法</h3>

<p>
一般に、開発者は，`~event~listener$の有無が観測-可能になるものとは予期しない。
`~event~listener$の影響iは、その `callback$evL により決定される。
すなわち開発者は、何もしない`~event~listener$を追加しても，副作用が生じるとは予期しない。
◎
In general, developers do not expect the presence of an event listener to be observable. The impact of an event listener is determined by its callback. That is, a developer adding a no-op event listener would not expect it to have any side effects.
</p>

<p>
あいにく，一部の~event~APIは、効率的に実装するためには，`~event~listener$を観測することが要求される設計になっている。
すなわち、何もしない~listenerであっても，~appの挙動における処理能に劇的に影響iし得る結果、~listenerの有無が観測-可能になっている。
例えば ~touch／~wheel ~eventの利用は、非同期~scrollingを阻むことがある。
一部の事例では、［
~eventが $cancelable になるのは， $AddEventListenerOptions.passive でない~listenerが 1 個~以上あるときに限る
］ように指定することで，この問題を軽減できる。
例えば、 $AddEventListenerOptions.passive でない $TouchEvent ~listenerは，~scrollingを阻まなければならないが、どの~listenerも $AddEventListenerOptions.passive であれば，［
$TouchEvent を（ $preventDefault() の~callは無視されるように）取消せなくすることで，~scrollingを`並列的$に開始できる
］ようになる。
~eventを配送している~codeは、そのように $AddEventListenerOptions.passive でない~listenerが無いことを観測でき，それを利用して配送-中の~eventの $cancelable ~propを ~F にできる。
◎
Unfortunately, some event APIs have been designed such that implementing them efficiently requires observing event listeners. This can make the presence of listeners observable in that even empty listeners can have a dramatic performance impact on the behavior of the application. For example, touch and wheel events which can be used to block asynchronous scrolling. In some cases this problem can be mitigated by specifying the event to be cancelable only when there is at least one non-passive listener. For example, non-passive TouchEvent listeners must block scrolling, but if all listeners are passive then scrolling can be allowed to start in parallel by making the TouchEvent uncancelable (so that calls to preventDefault() are ignored). So code dispatching an event is able to observe the absence of non-passive listeners, and use that to clear the cancelable property of the event being dispatched.
</p>

<p>
新たな~event~APIは、この~propを必要としないように定義されるのが理想的である（論を交わしたければ
<a href="https://lists.w3.org/Archives/Public/public-script-coord/">public-script-coord@<!---->w3.org</a>
を利用されたし）。
◎
Ideally, any new event APIs are defined such that they do not need this property (use public-script-coord@w3.org for discussion).
</p>

		</section>
		<section id="dispatching-events">
<h3 title="Dispatching events">2.9. ~eventの配送-法</h3>

<!-- ^@Event -->
<div class="algo">
<p>
`~eventを配送する@
ときは、所与の
( %~target, `~event$ %~event, %~targetを上書きするか ~IN { `~targetを上書きする^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To dispatch an event to a target, with an optional legacy target override flag and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>

<p class="trans-note">【
原文の~algoでは，［
Indexed Database API のみから利用される %legacyOutputDidListenersThrowFlag
］も
— 参照渡しとして —
入力に渡され得るが、この訳では，［
関連な~eventに`（旧来の）~listenerは投出したか$を結付けるよう定義する
］ことにより、この入力の受け渡しに関する記述を
<a href="#_legacyOutputDidListenersThrowFlag">簡素化している</a>。
】</p>
<p class="trans-note">【
この手続きは、
“%~target に向けて（~eventを）配送する”
のような形の句でも参照される（例えば、地の文の中で）。
】</p>


<ol>
	<li>
%~event の`配送-中か$ev ~SET ~T
◎
Set event’s dispatch flag.
</li>
	<li>
<p>
%上書きする~target ~LET %~targetを上書きするか に応じて
⇒＃
`~targetを上書きする^i ならば %~target に`結付けられている文書$ `HTML$r ／
ε ならば %~target
◎
Let targetOverride be target, if legacy target override flag is not given, and target’s associated Document otherwise. [HTML]
</p>

<p class="note">注記：
%~targetを上書きするか は，旧来の~flagであり、~HTMLからのみ, それも %~target が $Window ~objである場合に限り，非 ε にされる。
◎
legacy target override flag is only used by HTML and only when target is a Window object.
</p>
	</li>
	<li>
%作動化~target ~LET ~NULL
◎
Let activationTarget be null.
</li>
	<li>
%関係する~target ~LET %~event の`関係する~target$を %~target に向けて`~targetし直す$
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against target.
</li>
	<li>
<p>
~IF［
%~target ~NEQ %関係する~target
］~OR［
%~target ~EQ %~event の`関係する~target$
］：
◎
If target is not relatedTarget or target is event’s relatedTarget, then:
</p>
		<ol>
			<li>
%~touch~target~list ~LET 新たな`~list$
◎
Let touchTargets be a new list.
</li>
			<li>
%~event の`~touch~target~list$を成す
~EACH( %~touch~target )
に対し
⇒
%~touch~target~list に次の結果を`付加する$
⇒
%~touch~target を %~target に向けて`~targetし直す$
◎
For each touchTarget of event’s touch target list, append the result of retargeting touchTarget against target to touchTargets.
</li>
			<li>
`~event経路に付加する$( %~event, %~target, %上書きする~target, %関係する~target, %~touch~target~list, ~F )
◎
Append to an event path with event, target, targetOverride, relatedTarget, touchTargets, and false.
</li>
			<li>
%作動化~eventか ~LET［
%~event は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
$MouseEvent ~objである
］~AND［
$type 属性 ~EQ `click^l
］
◎
Let isActivationEvent be true, if event is a MouseEvent object and event’s type attribute is "click"; otherwise false.
</li>
			<li>
~IF［
%作動化~eventか ~EQ ~T
］~AND［
%~target は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %~target
◎
If isActivationEvent is true and target has activation behavior, then set activationTarget to target.
</li>
			<li>
%~slot可能 ~LET［
次が満たされるならば %~target ／
~ELSE_ ~NULL
］
⇒
［
%~target は`~slot可能$である
］~AND［
%~target の`割当-先~slot$ ~NEQ ~NULL
］
◎
Let slottable be target, if target is a slottable and is assigned, and null otherwise.
</li>
			<li>
%~slotは閉な~tree内か ~LET ~F
◎
Let slot-in-closed-tree be false.
</li>
			<li>
%親 ~LET
%~target の`親~targetを取得する$( %~event )
◎
Let parent be the result of invoking target’s get the parent with event.
</li>
			<li>
<p>
~WHILE［
%親 ~NEQ ~NULL
］：
◎
While parent is non-null:
</p>
				<ol>
					<li>
<p>
~IF［
%~slot可能 ~NEQ ~NULL
］：
◎
If slottable is non-null:
</p>
						<ol>
							<li>
~Assert：
%親 は`~slot$である
◎
Assert: parent is a slot.
</li>
							<li>
%~slot可能 ~SET ~NULL
◎
Set slottable to null.
</li>
							<li>
~IF［
%親 の`根$は［
`~shadow根$である
］~AND［
`~mode$sR ~EQ `closed^l
］を満たす
］
⇒
%~slotは閉な~tree内か ~SET ~T
◎
If parent’s root is a shadow root whose mode is "closed", then set slot-in-closed-tree to true.
</li>
						</ol>
					</li>
					<li>
~IF［
%親 は`~slot可能$である
］~AND［
%親 の`割当-先~slot$ ~NEQ ~NULL
］
⇒
%~slot可能 ~SET %親
◎
If parent is a slottable and is assigned, then set slottable to parent.
</li>
					<li>
%関係する~target ~LET %関係する~target を %親 に向けて`~targetし直す$
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against parent.
</li>
					<li>
%~touch~target~list ~LET 新たな`~list$
◎
Let touchTargets be a new list.
</li>
					<li>
%~event の`~touch~target~list$を成す
~EACH( %~touch~target )
に対し
⇒
%~touch~target~list に次の結果を`付加する$
⇒
%~touch~target を %親 に向けて`~targetし直す$
◎
For each touchTarget of event’s touch target list, append the result of retargeting touchTarget against parent to touchTargets.
</li>
					<li>
<p>
~IF［
%親 は $Window ~objである
］~OR［［
%親 は`~node$である
］~AND［
%~target の`根$ は %親 の`~shadowも含む広義-先祖$である
］］：
◎
If parent is a Window object, or parent is a node and target’s root is a shadow-including inclusive ancestor of parent, then:
</p>
						<ol>
							<li>
<p>
~IF［
%作動化~eventか ~EQ ~T
］~AND［
%~event の $bubbles 属性 ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%親 は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %親
◎
If isActivationEvent is true, event’s bubbles attribute is true, activationTarget is null, and parent has activation behavior, then set activationTarget to parent.
</li>
							<li>
`~event経路に付加する$( %~event, %親, ~NULL, %関係する~target, %~touch~target~list, %~slotは閉な~tree内か )
◎
Append to an event path with event, parent, null, relatedTarget, touchTargets, and slot-in-closed-tree.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%親 ~EQ %関係する~target
］
⇒
%親 ~SET ~NULL
◎
Otherwise, if parent is relatedTarget, then set parent to null.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
						<ol>
							<li>
%~target ~SET %親
◎
set target to parent and then:
</li>
							<li>
~IF［
%作動化~eventか ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%~target は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %~target
◎
If isActivationEvent is true, activationTarget is null, and target has activation behavior, then set activationTarget to target.
</li>
							<li>
`~event経路に付加する$( %~event, %親, %~target, %関係する~target, %~touch~target~list, %~slotは閉な~tree内か )
◎
Append to an event path with event, parent, target, relatedTarget, touchTargets, and slot-in-closed-tree.
</li>
						</ol>
					</li>
					<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
%親 ~SET %親 の`親~targetを取得する$( %~event )
◎
If parent is non-null, then set parent to the result of invoking parent’s get the parent with event.
</li>
					<li>
%~slotは閉な~tree内か ~SET ~F
◎
Set slot-in-closed-tree to false.
</li>
				</ol>
			</li>
			<li>
%~targetを消去する構造体 ~LET %~event の`経路$内の構造体のうち，［
`~shadow調整-済み~target$evP ~NEQ ~NULL
］を満たすもののうち，最後のもの
◎
Let clearTargetsStruct be the last struct in event’s path whose shadow-adjusted target is non-null.
</li>
			<li>
%~targetたちを消去するか ~LET 次を満たす`~node$ %~node は［
在るならば ~T ／
無いならば ~F
］
⇒
［
その`根$は`~shadow根$である
］~AND［
次に挙げるいずれかである
］
⇒＃
%~targetを消去する構造体 の`~shadow調整-済み~target$evP,
%~targetを消去する構造体 の`関係する~target$evP,
%~targetを消去する構造体 の`~touch~target~list$evP 内に在る
◎
Let clearTargets be true if clearTargetsStruct’s shadow-adjusted target, clearTargetsStruct’s relatedTarget, or an EventTarget object in clearTargetsStruct’s touch target list is a node and its root is a shadow root; otherwise false.
</li>
			<li>
~IF［
%作動化~target ~NEQ ~NULL
］~AND［
%作動化~target は `旧来の作動化~前の挙動$を備えている
］
⇒
その挙動を走らす
◎
If activationTarget is non-null and activationTarget has legacy-pre-activation behavior, then run activationTarget’s legacy-pre-activation behavior.
</li>
			<li>
<p>
%~event の`経路$を成す
~EACH( %構造体 )
に対し，逆順に：
◎
For each struct in event’s path, in reverse order:
</p>
				<ol>
					<li>
%~event の $eventPhase 属性 ~SET ［
%構造体 の`~shadow調整-済み~target$evP ~NEQ ~NULL ならば $AT_TARGET ／
~ELSE_ $CAPTURING_PHASE
］
◎
If struct’s shadow-adjusted target is non-null, then set event’s eventPhase attribute to AT_TARGET.
◎
Otherwise, set event’s eventPhase attribute to CAPTURING_PHASE.
</li>
					<li>
`~listenerを呼出す$( %構造体, %~event, `capturing^l )
◎
Invoke with struct, event, "capturing", and legacyOutputDidListenersThrowFlag if given.
</li>
				</ol>
			</li>
			<li>
<p>
%~event の`経路$を成す
~EACH( %構造体 )
に対し：
◎
For each struct in event’s path:
</p>
				<ol>
					<li>
~IF［
%構造体 の`~shadow調整-済み~target$evP ~NEQ ~NULL
］
⇒
%~event の $eventPhase 属性 ~SET $AT_TARGET
◎
If struct’s shadow-adjusted target is non-null, then set event’s eventPhase attribute to AT_TARGET.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
~IF［
%~event の $bubbles 属性 ~EQ ~F
］
⇒
~CONTINUE
◎
If event’s bubbles attribute is false, then continue.
</li>
							<li>
%~event の $eventPhase 属性 ~SET $BUBBLING_PHASE
◎
Set event’s eventPhase attribute to BUBBLING_PHASE.
</li>
						</ol>
					</li>
					<li>
`~listenerを呼出す$( %構造体, %~event, `bubbling^l )
◎
Invoke with struct, event, "bubbling", and legacyOutputDidListenersThrowFlag if given.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~event の $eventPhase 属性 ~SET $NONE
◎
Set event’s eventPhase attribute to NONE.
</li>
	<li>
%~event の $currentTarget 属性 ~SET ~NULL
◎
Set event’s currentTarget attribute to null.
</li>
	<li>
%~event の`経路$ ~SET 空~list
◎
Set event’s path to the empty list.
</li>
	<li>
%~event の
⇒＃
`配送-中か$ev ~SET ~F,
`伝播を停止するか$ev ~SET ~F,
`伝播を即時に停止するか$ev ~SET ~F
◎
Unset event’s dispatch flag, stop propagation flag, and stop immediate propagation flag.
</li>
	<li>
<p>
~IF［
%~targetたちを消去するか ~EQ ~T
］
⇒
%~event の
⇒＃
`~target$ ~SET ~NULL
`関係する~target$ ~SET ~NULL
`~touch~target~list$ ~SET 空~list
◎
If clearTargets, then:
• Set event’s target to null.
• Set event’s relatedTarget to null.
• Set event’s touch target list to the empty list.
</li>
	<li>
<p>
~IF［
%作動化~target ~NEQ ~NULL
］：
◎
If activationTarget is non-null, then:
</p>
		<ol>
			<li>
~IF［
%~event の`取消されたか$ev ~EQ ~F
］
⇒
%~event を渡して， %作動化~target の`作動化の挙動$を走らす
◎
If event’s canceled flag is unset, then run activationTarget’s activation behavior with event.
</li>
			<li>
~ELIF［
%作動化~target は `旧来の作動化~取消~時の挙動$を備えている
］
⇒
その挙動を走らす
◎
Otherwise, if activationTarget has legacy-canceled-activation behavior, then run activationTarget’s legacy-canceled-activation behavior.
</li>
		</ol>
	</li>
	<li>
~RET %~event の`取消されたか$ev
◎
Return false if event’s canceled flag is set; otherwise true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~event経路に付加する@
ときは、所与の
( %~event, %呼出n~target, %~shadow調整-済み~target, %関係する~target, %~touch~target~list, %~slotは閉な~tree内か )
に対し，次を走らす：
◎
To append to an event path, given an event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, and a slot-in-closed-tree, run these steps:
</p>
<ol>
	<li>
%呼出n~targetは~shadow~tree内か ~LET ［
%呼出n~target は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
`~node$である
］~AND［
その`根$は`~shadow根$である
］
◎
Let invocationTargetInShadowTree be false.
◎
If invocationTarget is a node and its root is a shadow root, then set invocationTargetInShadowTree to true.
</li>
	<li>
%閉な~treeの根か ~LET ［
%呼出n~target は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
`~shadow根$である
］~AND［
`~mode$sR ~EQ `closed^l
］
◎
Let root-of-closed-tree be false.
◎
If invocationTarget is a shadow root whose mode is "closed", then set root-of-closed-tree to true.
</li>
	<li>
%~event の`経路$に次のように設定された新たな`構造体$を`付加する$
⇒＃
`呼出n~target$evP ~SET %呼出n~target,
`呼出n~targetは~shadow~tree内か$evP ~SET %呼出n~targetは~shadow~tree内か
`~shadow調整-済み~target$evP ~SET %~shadow調整-済み~target,
`関係する~target$evP ~SET %関係する~target,
`閉な~treeの根か$evP ~SET %閉な~treeの根か,
`~touch~target~list$evP ~SET %~touch~target~list
`~slotは閉な~tree内か$evP ~SET %~slotは閉な~tree内か
◎
Append a new struct to event’s path whose invocation target is invocationTarget, invocation-target-in-shadow-tree is invocationTargetInShadowTree, shadow-adjusted target is shadowAdjustedTarget, relatedTarget is relatedTarget, touch target list is touchTargets, root-of-closed-tree is root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.
</li>
</ol>
</div>

<div class="algo">
<p>
`~listenerを呼出す@
ときは、所与の
( %構造体, %~event, %相 )
に対し，次を走らす：
◎
To invoke, given a struct, event, phase, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>
<ol>
	<li>
%~event の`~target$ ~SET ［
%~event の`経路$内の［
%構造体 または %構造体 に先行する構造体
］のうち，［
`~shadow調整-済み~target$evP ~NEQ ~NULL
］を満たすもののうち，最後の構造体
］の`~shadow調整-済み~target$evP
◎
Set event’s target to the shadow-adjusted target of the last struct in event’s path, that is either struct or preceding struct, whose shadow-adjusted target is non-null.
</li>
	<li>
%~event の`関係する~target$ ~SET %構造体 の `関係する~target$evP
◎
Set event’s relatedTarget to struct’s relatedTarget.
</li>
	<li>
%~event の`~touch~target~list$ ~SET %構造体 の`~touch~target~list$evP
◎
Set event’s touch target list to struct’s touch target list.
</li>
	<li>
~IF［
%~event の`伝播を停止するか$ev ~EQ ~T
］
⇒
~RET
◎
If event’s stop propagation flag is set, then return.
</li>
	<li>
%~event の $currentTarget 属性 ~SET %構造体 の`呼出n~target$evPに初期化する
◎
Initialize event’s currentTarget attribute to struct’s invocation target.
</li>
	<li>
<p>
%~listener~list ~LET %構造体 の`呼出n~target$evPの`~event~listener~list$を`~cloneする$
◎
Let listeners be a clone of event’s currentTarget attribute value’s event listener list.
</p>

<p class="note">注記：
これは、この時点以降に追加された~event~listenerは，走らせないようにする。
除去については、 `removed$evL ~fieldに因り，依然として効果を及ぼすことに注意。
◎
This avoids event listeners added after this point from being run. Note that removal still has an effect due to the removed field.
</p>
	</li>
	<li>
%呼出n~targetは~shadow~tree内か ~LET %構造体 の`呼出n~targetは~shadow~tree内か$evP
◎
Let invocationTargetInShadowTree be struct’s invocation-target-in-shadow-tree.
</li>
	<li>
%見出されたか ~LET `~listenerを内的に呼出す$( %~event, %~listener~list, %相, %呼出n~targetは~shadow~tree内か )
◎
Let found be the result of running inner invoke with event, listeners, phase, invocationTargetInShadowTree, and legacyOutputDidListenersThrowFlag if given.
</li>
	<li>
<p>
~IF［
%見出されたか ~EQ ~F
］~AND［
%~event の $isTrusted 属性 ~EQ ~T
］~AND［
%~event の $type 属性~値は［
下の表の 1 列目に挙げるいずれかの文字列
］に `~ASCII大小無視$で合致する
］…：
◎
If found is false and event’s isTrusted attribute is true, then:
◎
Let originalEventType be event’s type attribute value.
◎
If event’s type attribute value is a match for any of the strings in the first column in the following table, set event’s type attribute value to the string in the second column on the same row as the matching string, and return otherwise.
</p>

<table>
<thead><tr><th>~event型◎ Event type
<th>旧来の~event型◎ Legacy event type
</thead>

<tbody><tr><td>`animationend^l
<td>`webkitAnimationEnd^l

<tr><td>`animationiteration^l
<td>`webkitAnimationIteration^l

<tr><td>`animationstart^l
<td>`webkitAnimationStart^l

<tr><td>`transitionend^l
<td>`webkitTransitionEnd^l
</tbody></table>

<p>
…ならば：
</p>
		<ol>
			<li>
%元の~event型 ~LET %~event の $type 属性~値
◎
↑</li>
			<li>
%~event の $type 属性 ~SET 合致した行の 2 列目に与える文字列
◎
↑</li>
			<li>
`~listenerを内的に呼出す$( %~event, %~listener~list, %相, %呼出n~targetは~shadow~tree内か )
◎
Inner invoke with event, listeners, phase, invocationTargetInShadowTree, and legacyOutputDidListenersThrowFlag if given.
</li>
			<li>
%~event の $type 属性 ~SET %元の~event型
◎
Set event’s type attribute value to originalEventType.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~listenerを内的に呼出す@
ときは、所与の
( %~event, %~listener~list, %相, %呼出n~targetは~shadow~tree内か )
に対し，次を走らす：
◎
To inner invoke, given an event, listeners, phase, invocationTargetInShadowTree, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>
<ol>
	<li>
%見出されたか ~LET ~F
◎
Let found be false.
</li>
	<li>
<p>
%~listener~list を成す
~EACH( `~event~listener$ %~listener )
に対し：
◎
For each listener in listeners, whose removed is false:
</p>
		<ol>
			<li>
~IF［
%~listener の `removed$evL ~EQ ~T
］
⇒
~CONTINUE
◎
↑</li>
			<li>
~IF［
%~listener の `type$evL ~NEQ %~event の $type 属性~値
］
⇒
~CONTINUE
◎
If event’s type attribute value is not listener’s type, then continue.
</li>
			<li>
%見出されたか ~SET ~T
◎
Set found to true.
</li>
			<li>
~IF［
%相 ~EQ `capturing^l
］~AND［
%~listener の `capture$evL ~EQ ~F
］
⇒
~CONTINUE
◎
If phase is "capturing" and listener’s capture is false, then continue.
</li>
			<li>
~IF［
%相 ~EQ `bubbling^l
］~AND［
%~listener の `capture$evL ~EQ ~T
］
⇒
~CONTINUE
◎
If phase is "bubbling" and listener’s capture is true, then continue.
</li>
			<li>
~IF［
%~listener の `once$evL ~EQ ~T
］
⇒
%~event の $currentTarget 属性~値の`~event~listener~list$から %~listener を`除去する$
◎
If listener’s once is true, then remove listener from event’s currentTarget attribute value’s event listener list.
</li>
			<li>
%大域 ~LET %~listener の `callback$evL が`属する~Realm$の`大域~obj$rM
◎
Let global be listener callback’s associated Realm’s global object.
</li>
			<li>
%現在の~event ~LET $undefined
◎
Let currentEvent be undefined.
</li>
			<li>
<p>
~IF［
%大域 は $Window ~objである
］：
◎
If global is a Window object, then:
</p>
				<ol>
					<li>
%現在の~event ~SET %大域 の`現在の~event$
◎
Set currentEvent to global’s current event.
</li>
					<li>
~IF［
%呼出n~targetは~shadow~tree内か ~EQ ~F
］
⇒
%大域 の`現在の~event$ ~SET %~event
◎
If invocationTargetInShadowTree is false, then set global’s current event to event.
</li>
				</ol>
			</li>
			<li>
~IF［
%~listener の `passive$evL ~EQ ~T
］
⇒
%~event の`受動~listener内か$ev ~SET ~T
◎
If listener’s passive is true, then set event’s in passive listener flag.
</li>
			<li>
<p>
次を与える下で，`利用元~objの演算を~callする$
⇒＃
%~listener の `callback$evL,
`handleEvent^l,
« %~event »,
%~event の$currentTarget 属性~値
◎
Call a user object’s operation with listener’s callback, "handleEvent", « event », and event’s currentTarget attribute value.＼
</p>

<p>
~callした結果，例外が投出されたときは、~catchして：
◎
If this throws an exception, then:
</p>
				<ol>
					<li>
その`例外を報告する$
◎
Report the exception.
</li>
					<li>
<p id="_legacyOutputDidListenersThrowFlag">
~IF［
%~event には`（旧来の）~listenerは投出したか$が結付けられている
］
⇒
%~event の`（旧来の）~listenerは投出したか$ ~SET ~T
◎
Set legacyOutputDidListenersThrowFlag if given.
</p>

<p class="note">注記：
Indexed Database API `INDEXEDDB$r のみが、これを利用する。
◎
The legacyOutputDidListenersThrowFlag is only used by Indexed Database API. [INDEXEDDB]
</p>
					</li>
				</ol>
			</li>
			<li>
%~event の`受動~listener内か$ev ~SET ~F
◎
Unset event’s in passive listener flag.
</li>
			<li>
~IF［
%大域 は $Window ~objである
］
⇒
%大域 の`現在の~event$ ~SET %現在の~event
◎
If global is a Window object, then set global’s current event to currentEvent.
</li>
			<li>
~IF［
%~event の`伝播を即時に停止するか$ev ~EQ ~T
］
⇒
~RET %見出されたか
◎
If event’s stop immediate propagation flag is set, then return found.
</li>
		</ol>
	</li>
	<li>
~RET %見出されたか
◎
Return found.
</li>
</ol>
</div>

		</section>
		<section id="firing-events">
<h3 title="Firing events">2.10. ~eventの発火-法</h3>

<div class="algo">
<div class="p">
<p>
`~eventを発火する@
ときは、所与の
( %~target, 名前 %e, %~event構築子（省略時は $@Event のそれ）† )
に対し，以下の手続きを走らす
— この手続きには、次の~~入力も与えられ得る：
</p>
<ul>
	<li>
%~targetを上書きするか ~IN { `~targetを上書きする^i, ε }（省略時は ε ）
</li>
	<li>
%記述
— ［
~eventの各種~IDL属性を どう初期化するか
］についての記述（省略時は何もしない）
【これは、~IDL属性~以外の~prop（ `~composedか$ev など）を初期化する記述を含む場合もある。】
</li>
</ul>

<p class="trans-note">【†
%~event構築子 には、
（省略されない場合は）ほぼすべての事例で，単に~interfaceが渡される
— その場合、当の~interfaceの唯一の構築子として解釈する。
】</p>

<p class="trans-note">【
この手続きは、
“%~target に向けて名前 %e の~eventを発火する”
のような形の句でも参照される（例えば、地の文の中で）。
】</p>

◎
To fire an event named e at target, optionally using an eventConstructor, with a description of how IDL attributes are to be initialized, and a legacy target override flag, run these steps:
◎
If eventConstructor is not given, then let eventConstructor be Event.
</div>
<ol>
	<li>
%~event ~LET
`~eventを作成する$( %~event構築子, %~target に`関連な~Realm$ )
◎
Let event be the result of creating an event given eventConstructor, in the relevant Realm of target.
</li>
	<li>
%~event の $type 属性 ~SET %e に初期化する
◎
Initialize event’s type attribute to e.
</li>
	<li>
<p>
%~event の各種~IDL属性を %記述 に従って初期化する
◎
Initialize any other IDL attributes of event as described in the invocation of this algorithm.
</p>

<p class="note">注記：
ここでは［
$isTrusted 属性 ~SET ~F
］にすることも許容される。
◎
This also allows for the isTrusted attribute to be set to false.
</p>

	</li>
	<li>
~RET `~eventを配送する$( %~event, %~target, %~targetを上書きするか )
◎
Return the result of dispatching event at target, with legacy target override flag set if set.
</li>
</ol>

<p class="note">注記：
~DOMの文脈における
“`~eventを発火する$”
とは、`~event$を［
<a href="#concept-event-create">作成-</a>して, 初期化して, `配送-$する
］ことの略語であり，この処理nを容易に書けるようにするためにある。
◎
Fire in the context of DOM is short for creating, initializing, and dispatching an event. Fire an event makes that process easier to write down.
</p>
</div>

<div class="example" id="firing-events-example">

<p>
`~event$の［
$bubbles や $cancelable
］などの属性も初期化する必要がある場合、次のようにも書ける
⇒
`~eventを発火する$( %~target, `submit^et )
— 次のように初期化して
⇒
^cancelable 属性 ~SET ~T
◎
If the event needs its bubbles or cancelable attribute initialized, one could write "fire an event named submit at target with its cancelable attribute initialized to true".
</p>

<p>
あるいは，~customな構築子も必要なときは、次のように書く, 等々
⇒
`~eventを発火する$( %~target, `click^et, $MouseEvent )
— 次のように初期化して
⇒
`detail$m 属性 ~SET 1
◎
Or, when a custom constructor is needed, "fire an event named click at target using MouseEvent with its detail attribute initialized to 1".
</p>

<p>
ときには、返り値が重要になることもある：
◎
Occasionally the return value is important:
</p>
<ol>
	<li>
%何かするか ~LET `~eventを発火する$( %~target, `like^et )
◎
Let doAction be the result of firing an event named like at target.
	</li>
	<li>
~IF［
%何かするか ~EQ ~T
］
⇒
…
◎
If doAction is true, then …
	</li>
</ol>
</div>

		</section>
		<section id="action-versus-occurance">
<h3 title="Action versus occurrence">2.11. 動作 vs. ~~発生</h3>

<p>
`~event$は、動作（ `action^en ）ではなく，何かが生じたこと（ `occurrence^en ）をしるす（徴す／ `signify^en する）ものである。
言葉を代えれば、~algoからの通知を表現し，その~algoの進路に（例えば $preventDefault() を呼出すことを通して）波及させるために利用できるものである。
`~event$は、何らかの~algoを走らすような［
動作, あるいは動作を起動するもの
］として利用されてはナラナイ。
そのような用途にあるものではない。
◎
An event signifies an occurrence, not an action. Phrased differently, it represents a notification from an algorithm and can be used to influence the future course of that algorithm (e.g., through invoking preventDefault()). Events must not be used as actions or initiators that cause some algorithm to start running. That is not what they are for.
</p>

<p class="note">注記：
ここで特定的に~~強調している~~理由は、以前の~DOMでは，`~event$に “既定~動作” の概念が結付けられていて，人を誤った考えに~~導いていたからである。
`~event$は、動作を表現したり生じさせるものではなく，進行中の何かに波及させるために限り利用できるものである。
◎
This is called out here specifically because previous iterations of the DOM had a concept of "default actions" associated with events that gave folks all the wrong ideas. Events do not represent or cause actions, they can only be used to influence an ongoing one.
</p>

		</section>
	</section>
	<section id="aborting-ongoing-activities">
<h2 title="Aborting ongoing activities">3. 進行中の活動の中止-法</h2>

<!-- ^@AbortController -->
<p>
~promiseには，中止するための組込みの仕組みがないが、それを利用している多くの~APIは，中止-の意味論を要求している。
$AbortController には、その要件を~supportすることが~~意図されている。
それが供する $abort() ~methodは、 $AbortController に対応している $AbortSignal ~objの状態を切り替える。
中止-法を~supportしたいと望む~APIは、この~objを受容して, その状態を利用することにより，どう続行するか決定できる。
◎
Though promises do not have a built-in aborting mechanism, many APIs using them require abort semantics. AbortController is meant to support these requirements by providing an abort() method that toggles the state of a corresponding AbortSignal object. The API which wishes to support aborting can accept an AbortSignal object, and use its state to determine how to proceed.
</p>

<p>
$AbortController に依拠する~APIは、新たな `AbortError$E 例外で未決着な~promiseを却下して， $abort() に応答することが奨励される。
◎
APIs that rely upon AbortController are encouraged to respond to abort() by rejecting any unsettled promise with a new "AbortError" DOMException.
</p>

<div class="example" id="aborting-ongoing-activities-example">

<p>
~method 
`doAmazingness({ ... })^c
は、何か “すごいこと” を行うとする。
この~methodは、 $AbortSignal ~objを受容して，次のように中止-法を~supportできる：
◎
A hypothetical doAmazingness({ ... }) method could accept an AbortSignal object to support aborting as follows:
</p>

<pre class="lang-js">
const %controller = new AbortController();
const %signal = %controller.signal;

startSpinner();

doAmazingness({ ..., %signal })
  .then(%result =&gt; ...)
  .catch(%err =&gt; {
    if (%err.name == 'AbortError') return;
    showUserErrorMessage();
  })
  .then(() =&gt; stopSpinner());

// …

%controller.abort();
</pre>

<p>
^doAmazingness は、次のように実装することもできる：
◎
doAmazingness could be implemented as follows:
</p>

<pre class="lang-js">
function doAmazingness({%signal}) {
  if (%signal.aborted) {
    return Promise.reject(new DOMException('Aborted', 'AbortError'));
  }

  return new Promise((%resolve, %reject) =&gt; {
  	/* <span class="comment">
“すごいこと” を行い始め、終わったら %resolve(%result) を~callする。
また、 %signal も注視する。
◎
Begin doing amazingness, and call resolve(result) when done.
But also, watch for signals:
</span> */
    %signal.addEventListener('abort', () =&gt; {
      /* <span class="comment">
“すごいこと” を行うのを停止してから：
◎
Stop doing amazingness, and:
</span> */
      %reject(new DOMException('Aborted', 'AbortError'));
    });
  });
}
</pre>

<p>
より精細な制御を要する~APIは、必要に応じて
$AbortController, $AbortSignal
両~objを拡張することもできる。
◎
APIs that require more granular control could extend both AbortController and AbortSignal objects according to their needs.
</p>

</div>

		<section id="interface-abortcontroller">
<h3 title="Interface AbortController">3.1. ^@AbortController ~interface</h3>

！！
 `Exposed$=(Window,Worker)]
interface @AbortController {
  `AbortController$mc();
  [`SameObject$] ~RA $AbortSignal $signal;

  $undefined $abort(optional $any %reason);
};
！

<dl class="domintro">
	<dt>%controller  = $AbortController()</dt>
	<dd>
新たな %controller を，その $signal を［
新たな $AbortSignal ~obj
］に設定した上で返す。
◎
Returns a new controller whose signal is set to a newly created AbortSignal object.
</dd>

	<dt>%controller . $signal</dt>
	<dd>
この~objに結付けられている $AbortSignal ~objを返す。
◎
Returns the AbortSignal object associated with this object.
</dd>
	<dt>%controller . $abort(reason)</dt>
	<dd>
この~methodを呼出すと、
この~objの $AbortSignal の`中止-事由$aB %reason を格納した上で、
結付けられている活動が中止されることになるよう，観測器たちにも通達することになる。
%reason が ε の場合（省略したか明示的に `undefined^jv を与えた場合）、
`AbortError$E 例外が格納されることになる。
◎
Invoking this method will store reason in this object’s AbortSignal's abort reason, and signal to any observers that the associated activity is to be aborted. If reason is undefined, then an "AbortError" DOMException will be stored.
</dd>
</dl>

<p>
各 $AbortController ~objには、
`通達@aB
（ $AbortSignal ~obj）が結付けられる。
◎
An AbortController object has an associated signal (an AbortSignal object).
</p>

<div class="algo">
<p>
@AbortController()
構築子~手続きは
⇒
コレの`通達$aB ~SET 新たな $AbortSignal ~obj
◎
The new AbortController() constructor steps are:
• Let signal be a new AbortSignal object.
• Set this’s signal to signal.
</div>

<div class="algo">
@signal
取得子~手続きは
⇒
~RET コレの`通達$aB
◎
The signal getter steps are to return this’s signal.
</div>

<div class="algo">
@abort(reason)
~method~手続きは
⇒
`中止-を通達する$( コレの`通達$aB, %reason )
◎
The abort(reason) method steps are to signal abort on this’s signal with reason if it is given.
</div>

		</section>
		<section id="interface-AbortSignal">
<h3 title="Interface AbortSignal">3.2. ^@AbortSignal ~interface</h3>

！！
[`Exposed$=(Window,Worker)]
interface @AbortSignal : $EventTarget {
  [`NewObject$] static $AbortSignal $abort(optional $any %reason);

  ~RA $boolean $aborted;
  ~RA $any $reason;

  attribute $EventHandler $onabort;
};
！

<dl class="domintro">
	<dt>AbortSignal . $abort(reason)</dt>
	<dd>
$AbortSignal ~instanceを返す
— その`中止-事由$aBは［
%reason が ε の場合（省略したか明示的に `undefined^jv を与えた場合）は `AbortError$E 例外／
~ELSE_ %reason
］に設定される。
◎
Returns an AbortSignal instance whose abort reason is set to reason if not undefined; otherwise to an "AbortError" DOMException.
</dd>

	<dt>%signal . $aborted</dt>
	<dd>
この $AbortSignal の $AbortController が，中止するよう通達されて［
いれば ~T ／
いなければ ~F
］を返す。
◎
Returns true if this AbortSignal's AbortController has signaled to abort; otherwise false.
</dd>

	<dt>%signal . $reason</dt>
	<dd>
この $AbortSignal の`中止-事由$aBを返す。
◎
Returns this AbortSignal's abort reason.
</dd>
</dl>

<p>
各 $AbortSignal ~objには、次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>
`中止-事由@aB
◎
An AbortSignal object has an associated abort reason,＼
</dt>
	<dd>
~JS値。
他が指定されない限り， `undefined^jv をとるとする。
◎
which is a JavaScript value. It is undefined unless specified otherwise.
</dd>
	<dd>
$AbortSignal ~objが
`中止された@aB
とは、次が満たされることをいう
⇒
その`中止-事由$aB ~NEQ `undefined^jv
◎
An AbortSignal object is aborted when its abort reason is not undefined.
</dd>

	<dt>
`中止する~algo群@aB
◎
An AbortSignal object has associated abort algorithms,＼
</dt>
	<dd>
何個かの~algoからなる`有順序~集合$。
他が指定されない限り，`空$とする。
これらの~algoは、
当の $AbortSignal が`中止された$aBとき，実行されることになる。
◎
which is a set of algorithms which are to be executed when it is aborted. Unless specified otherwise, its value is the empty set.
</dd>
	<dd class="trans-note">【
集合なので，同じ~algoは重ねて現れ得ないことになるが、
“同じ” がどう定義されるかは，
“`通達に~algoを追加する$” を利用する他の仕様を見ないとはっきりしない
（おそらく、手続き自体は同じでも，呼出nごとに異なるものとして扱われるように思われるが）。
】</dd>
</dl>

<div class="algo">
<p>
`通達に~algoを追加する@
ときは、所与の
( $AbortSignal ~obj %通達, ~algo %~algo )
に対し，次を走らす：
◎
To add an algorithm algorithm to an AbortSignal object signal, run these steps:
</p>
<ol>
	<li>
~IF［
%通達 は`中止された$aB
］
⇒
~RET
◎
If signal is aborted, then return.
</li>
	<li>
%通達 の`中止する~algo群$aBに %~algo を`付加する$set
◎
Append algorithm to signal’s abort algorithms.
</li>
</ol>
</div>

<div class="algo">
<p>
`通達から~algoを除去する@
ときは、所与の
( $AbortSignal ~obj %通達, ~algo %A )
に対し
⇒
%通達 の`中止する~algo群$aBから %A を`除去する$
◎
To remove an algorithm algorithm from an AbortSignal signal, remove algorithm from signal’s abort algorithms.
</p>
</div>

<p class="note">注記：
`中止する~algo群$aBは、
$abort() に対し適度な仕方で反応するような，複階的な要件を伴う~APIを可能化する。
例えば，所与の~APIの`中止-事由$aBは、
~swなどの別~thread環境へ伝播される必要があるかもしれない。
◎
The abort algorithms enable APIs with complex requirements to react in a reasonable way to abort(). For example, a given API’s abort reason might need to be propagated to a cross-thread environment, such as a service worker.
</p>

<div class="algo">
<p>
静的な
@abort(reason)
~method手続きは：
◎
The static abort(reason) method steps are:
</p>
<ol>
	<li>
%通達 ~LET 新たな $AbortSignal ~obj
◎
Let signal be a new AbortSignal object.
</li>
	<li>
%通達 の`中止-事由$aB ~SET %reason に応じて
⇒＃
ε ならば新たな `AbortError$E 例外 ／
~ELSE_ %reason
◎
Set signal’s abort reason to reason if it is given; otherwise to a new "AbortError" DOMException.
</li>
	<li>
~RET %通達
◎
Return signal.
</li>
</ol>
</div>

<div class="algo">
@aborted
取得子~手続きは
⇒
~RET ［
コレは`中止された$aBならば ~T ／
~ELSE_ ~F
］
◎
The aborted getter steps are to return true if this is aborted; otherwise false.
</div>

<div class="algo">
@reason
取得子~手続きは
⇒
~RET コレの`中止-事由$aB
◎
The reason getter steps are to return this’s abort reason.
</div>

<p>
@onabort
は、
`onabort@c
`~event~handler$用の`~event~handler~IDL属性$である
— その`~event~handler~event型$は
`abort@et
とする。
◎
The onabort attribute is an event handler IDL attribute for the onabort event handler, whose event handler event type is abort.
</p>

<p class="note">注記：
$AbortSignal ~objに対する変化は，対応している $AbortController ~objの望みを表現するが、 $AbortSignal ~objを観測している~APIは，それを無視することも選べる
— 一例として、演算がすでに完了していた場合など。
◎
Changes to an AbortSignal object represent the wishes of the corresponding AbortController object, but an API observing the AbortSignal object can chose to ignore them. For instance, if the operation has already completed.
</p>

<div class="algo">
<p>
`中止-を通達する@
ときは、所与の
( $AbortSignal ~obj %通達, %事由（省略時は ε ） )
に対し，次を走らす：
◎
To signal abort, given an AbortSignal object signal and an optional reason, run these steps:
</p>
<ol>
	<li>
~IF［
%通達 は`中止された$aB
］
⇒
~RET
◎
If signal is aborted, then return.
</li>
	<li>
%通達 の`中止-事由$aB ~SET %事由 に応じて
⇒＃
ε ならば新たな `AbortError$E 例外 ／
~ELSE_ %事由
◎
Set signal’s abort reason to reason if it is given; otherwise to a new "AbortError" DOMException.
</li>
	<li>
%通達 の`中止する~algo群$aBを成す
~EACH( %~algo )
に対し
⇒
%~algo を走らす
◎
For each algorithm in signal’s abort algorithms: run algorithm.
</li>
	<li>
%通達 の`中止する~algo群$aBを`空にする$
◎
Empty signal’s abort algorithms.
</li>
	<li>
`~eventを発火する$( %通達, `abort$et )
◎
Fire an event named abort at signal.
</li>
</ol>
</div>

<div class="algo">
<p>
`通達に追従させる@
ときは、所与の
( $AbortSignal %追従する通達, $AbortSignal %親~通達 )
に対し，次の手続きを走らす：
◎
A followingSignal (an AbortSignal) is made to follow a parentSignal (an AbortSignal) by running these steps:
</p>
<ol>
	<li>
~IF［
%追従する通達 は`中止された$aB
］
⇒
~RET
◎
If followingSignal is aborted, then return.
</li>
	<li>
~IF［
%親~通達 は`中止された$aB
］
⇒＃
`中止-を通達する$( %追従する通達, %親~通達 の`中止-事由$aB )；
~RET
◎
If parentSignal is aborted, then signal abort on followingSignal with parentSignal’s abort reason.
</li>
	<li>
<p>
`通達に~algoを追加する$( %親~通達, 次に与える中止-手続き )：
◎
Otherwise, add the following abort steps to parentSignal:
</p>
		<ol>
			<li>
`中止-を通達する$( %追従する通達, %親~通達 の`中止-事由$aB )
◎
Signal abort on followingSignal with parentSignal’s abort reason.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="abortcontroller-api-integration">
<h3 title="Using AbortController and AbortSignal objects in APIs">3.3. ~APIにおける ^AbortController, ^AbortSignal ~objの利用-法</h3>

<p>
中止できる演算を表現する~promiseを利用している~web~platform~APIは、次を固守するモノトスル：
◎
Any web platform API using promises to represent operations that can be aborted must adhere to the following:
</p>

<ul>
	<li>
^signal `辞書~member$を通して， $AbortSignal ~objを受容すること。
◎
Accept AbortSignal objects through a signal dictionary member.
</li>
	<li>
演算が中止されたときは、
$AbortSignal ~objの`中止-事由$aBで~promiseを却下することにより，それを~~伝えること。
◎
Convey that the operation got aborted by rejecting the promise with AbortSignal object’s abort reason.
</li>
	<li>
<p>
$AbortSignal は`中止された$aB場合
⇒
即時に却下すること。
◎
Reject immediately if the AbortSignal is already aborted, otherwise:
</p>

<p>
他の場合
⇒
$AbortSignal ~objの変化を観測するときは、
`中止する~algo群$aBによる仕組みを，他の観測器と衝突し得ない方式で利用すること。
◎
Use the abort algorithms mechanism to observe changes to the AbortSignal object and do so in a manner that does not lead to clashes with other observers.
<p>
	</li>
</ul>

<div class="example" id="aborting-ongoing-activities-spec-example">

<p>
~promiseを返す ある~method ^doAmazingness(options) 用の~method手続きは、
次のように記すこともできる：
◎
The method steps for a promise-returning method doAmazingness(options) could be as follows:
</p>
<ol>
	<li>
%すごいこと ~LET ^doAmazingness が行う何か
◎
↓</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
%通達 ~LET %options[ "^signal" ]
◎
↓</li>
	<li>
<p>
~IF［
%通達 ~NEQ ε
］：
◎
If options["signal"] member is present, then:
</p>
		<ol>
			<li>
<p>
~IF［
%通達 は`中止された$aB
］：
</p>
				<ol>
					<li>
%通達 の`中止-事由$aBで %~promise を`却下する$
</li>
					<li>
~RET %~promise
</li>
				</ol>
◎
Let signal be options["signal"].
◎
If signal is aborted, then reject p with signal’s abort reason and return p.
</li>
			<li>
<p>
`通達に~algoを追加する$( %通達, 次に与える中止-手続き )：
◎
Add the following abort steps to signal:
</p>
				<ol>
					<li>
%すごいこと を停止する
◎
Stop doing amazing things.
</li>
					<li>
%通達 の`中止-事由$aBで %~promise を`却下する$
◎
Reject p with signal’s abort reason.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
この段は、`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%すごい結果 ~LET %すごいこと をした結果
◎
Let amazingResult be the result of doing some amazing things.
</li>
			<li>
%すごい結果 で %p を`解決する$
◎
Resolve p with amazingResult.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

</div>

<p>
~promiseを利用していない~APIであっても、アリな限り，上述を固守するべきである。
◎
APIs not using promises should still adhere to the above as much as possible.
</p>

		</section>
	</section>
	<section id="nodes">
<h2 title="Nodes">4. ~node</h2>

		<section id="introduction-to-the-dom">
<h3 title="Introduction to “The DOM”">4.1. ~DOM序論</h3>

<p>
~DOM（ “`The DOM^en（ Document Object Model ）” ）は元々，文書（特に，~HTML文書や~XML文書）に~accessして操作するための~APIを~~意味していたが、この仕様における語  “文書” は、短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更には本格的な対話的~appまでに渡る、任意の~markupに基づく資源を指すものとして利用される。
◎
In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.
</p>

<p>
そのような各~文書は、`~node~tree$として表現される。
`~tree$を成す`~node$のうち一部は 他の`~node$を`子$に持ち，他のものは葉（末端）~nodeになる。
◎
Each such document is represented as a node tree. Some of the nodes in a tree can have children, while others are always leaves.
</p>

<div class="example">
<p>
次の~HTML文書を例に~~説明する：
◎
To illustrate, consider this HTML document:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</pre>

<p>
これは次のように表現される：
◎
It is represented as follows:
</p>

<ol class="domTree"><li>`文書$
	<ol><li>`~doctype$： `DOCTYPE html^c
	</li><li>`要素$： `html^e <span>`class^c=`e^l</span>
		<ol><li>`要素$： `head^e
			<ol><li>`要素$： `title^e
				<ol><li>$Text： <samp>Aliens?</samp>
				</li></ol>
			</li></ol>
		</li><li>$Text： <samp>⏎␣</samp>
		</li><li>`要素$： `body^e
			<ol><li>$Text: <samp>Why yes.⏎</samp>
			</li></ol>
		</li></ol>
	</li></ol>
</li></ol>

</div>

<p>
`~HTML構文解析器$の~~仕組みから，すべての`~ASCII空白$が $Text `~node$にされてはいないが、一般~概念は明らかである。
~~入力の~markupから，`~node$たちが成す`~tree$が出来上がる。
【！You /can/ explain that! harharhar】
◎
Note that, due to the magic that is HTML parsing, not all ASCII whitespace were turned into Text nodes, but the general concept is clear. Markup goes in, a tree of nodes comes out.
</p>

<p class="note">注記：
さらに探求してみたければ、最高によくできている
<a href="https://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>
を利用するといい。
◎
The most excellent Live DOM Viewer can be used to explore this matter in more detail.
</p>

		</section>
		<section id="node-trees">
<h3 title="Node tree">4.2. ~node~tree</h3>

<p>
`~node@
とは、
$Node を`実装-$する~objである。
`~node$は，
`~node~tree@
と称される`~tree$に`関与-$する。
◎
Nodes are objects that implement Node. Nodes participate in a tree, which is known as the node tree.
</p>

<div class="note">

<p>注記：
実施においては、より特定な~objを処することになる。
◎
In practice you deal with more specific objects.
</p>

<p>
$Node を`実装-$する~objは、
それを継承する~interface
— 次に挙げるいずれか —
も実装する
⇒＃
$Document,
$DocumentType,
$DocumentFragment,
$Element,
$CharacterData,
$Attr
◎
Objects that implement Node also implement an inherited interface: Document, DocumentType, DocumentFragment, Element, CharacterData, or Attr.
</p>

<p>
$DocumentFragment を実装する~objには、
$ShadowRoot を実装するものもある。
◎
Objects that implement DocumentFragment sometimes implement ShadowRoot.
</p>

<p>
$Element を実装する~objは、
概して，それを継承する~interface
— $HTMLAnchorElement など —
も実装する。
◎
Objects that implement Element also typically implement an inherited interface, such as HTMLAnchorElement.
</p>

<p>
$CharacterData を実装する~objは，それを継承する~interface
— 次に挙げるいずれか —
も実装する
⇒＃
$Text,
$ProcessingInstruction,
$Comment
◎
Objects that implement CharacterData also implement an inherited interface: Text, ProcessingInstruction, or Comment.
</p>

<p>
$Text を実装する~objには、
$CDATASection を実装するものもある。
◎
Objects that implement Text sometimes implement CDATASection.
</p>
</div>

<p>
この仕様は、
$Node を継承する~interface %N を`実装-$する~objを指して，
単に %N `~node$とも称する。
◎
For brevity, this specification refers to an object that implements Node and an inherited interface NodeInterface, as a NodeInterface node.
</p>

<p id="_tree-constraints_">
`~node~tree$には、`~node$とそれに許容される`子$との関係性で表出される，次の拘束が課される：
◎
A node tree is constrained as follows, expressed as a relationship between a node and its potential children:
</p>

<dl>
	<dt>$Document</dt>
	<dd>
<p>
`~tree順序$で，次に挙げるものからなる：
◎
In tree order:
</p>
		<ol>
			<li id="cp-comments-or-PI">
0 個以上の［
$ProcessingInstruction ／ $Comment
］`~node$
◎
Zero or more ProcessingInstruction or Comment nodes.
</li>
			<li>
0 個または 1 個の $DocumentType `~node$
◎
Optionally one DocumentType node.
</li>
			<!--cp-comments-or-PI-->
			<li>
0 個または 1 個の $Element `~node$
◎
Optionally one Element node.
</li>
			<!--cp-comments-or-PI-->
		</ol>
	</dd>

	<dt>$DocumentFragment</dt>
	<dt>$Element</dt>
	<dd>
0 個以上の［
$Element ／ $CharacterData
］`~node$からなる
◎
Zero or more Element or CharacterData nodes.
</dd>

	<dt>$DocumentType</dt>
	<dt>$CharacterData</dt>
	<dt>$Attr</dt>
	<dd>
`子$を持たない
◎
None.
</dd>
</dl>

<p class="note">注記：
歴史的な理由から $Attr `~node$は`~tree$に`関与-$するが、
それは常に，`親$は ~NULL かつ`子~群$は空である
— したがって、それだけで，自身が関与する`~tree$を成すすべてになる。
◎
Attr nodes participate in a tree for historical reasons; they never have a (non-null) parent or any children and are therefore alone in a tree.
</p>

<p class="trans-note">【
$Attr `~node$が “~treeに関与するもの” を意味する語として他の仕様から利用されることは，ほぼ無い
（それらは、通例的に “内容~属性” と称される ／
$Attr 自体を参照している仕様も，ごく限られる）。
他の仕様に現れる語 “~node” は、実質的には，ほぼすべて “$Attr 以外の~node” を含意する。
】</p>

<div class="algo">
<p>
`~node$ %~node の
`長さ@
は、
%~node が`実装-$する~interfaceに応じて，次で決定される
⇒＃
$DocumentType ならば 0 ／
$Attr ならば 0 ／
$CharacterData ならば %~node の`~data$の`長さ$str ／
~ELSE_ %~node の`子~群$の`~size$
◎
To determine the length of a node node, run these steps:
• If node is a DocumentType or Attr node, then return 0.
• If node is a CharacterData node, then return node’s data’s length.
• Return the number of node’s children.
</p>
</div>

<p>
`~node$が
`空@node
であるとは、［
その`長さ$ ~EQ 0
］を意味する。
【この訳では、この用語は利用しない — ほぼ利用されておらず，単に “長さ ~EQ 0” と記せば済むので。】
◎
A node is considered empty if its length is 0.
</p>

			<section id="document-trees">
<h4 title="Document tree">4.2.1.文書~tree</h4>

<p>
`文書$を`根$とする`~node~tree$を
`文書~tree@
という。
◎
A document tree is a node tree whose root is a document.
</p>

<p>
`文書$ %文書 の
`文書~要素@
とは、`要素$であって［
`親$ ~EQ %文書
］を満たすものが［
在れば それ ／
無ければ ~NULL
］である。
◎
The document element of a document is the element whose parent is that document, if it exists; otherwise null.
</p>

<p class="note">注記：
`~node~tree$の拘束から、そのような`要素$は唯一つに決まる。
【例えば`~HTML文書$ならば `html^e 要素。】
◎
Per the node tree constraints, there can be only one such element.
</p>

<p>
`要素$は、その`根$が`文書$であるとき，
`文書~tree内@
にあるという。
◎
An element is in a document tree if its root is a document.
</p>

<p>
`文書~tree内$にある`要素$は、
`文書~内@
にあるともいう。
◎
An element is in a document if it is in a document tree.＼
</p>

<p class="note">注記：
用語 “`文書~内$” は、もはや利用されないものと想定されている。
この用語は、それを利用している標準が，まだ`~shadow~tree$を織り込むよう更新されていないことを指示する。
◎
The term in a document is no longer supposed to be used. It indicates that the standard using it has not been updated to account for shadow trees.
</p>

			</section>
			<section id="shadow-trees">
<h4 title="Shadow tree">4.2.2. ~shadow~tree</h4>

<p>
`~shadow根$を`根$とする`~node~tree$を
`~shadow~tree@
という。
◎
A shadow tree is a node tree whose root is a shadow root.
</p>

<p>
`~shadow根$は常に，その`~host$を通して別の`~node~tree$に装着される。
したがって，`~shadow~tree$が~~孤立することは決してない。
`~shadow根$の`~host$が`関与-$している`~node~tree$は、
`~light~tree@
とも呼ばれる。
◎
A shadow root is always attached to another node tree through its host. A shadow tree is therefore never alone. The node tree of a shadow root’s host is sometimes referred to as the light tree.
</p>

<p class="note">注記：
`~shadow~tree$に対応する`~light~tree$は、それ自身`~shadow~tree$になり得る。
【~shadow（ “日陰” ）と違って，~light（ “日なた” ）の定義は相対的であり、ある~node~tree~~単独で “~lightである” とは言えない。】
◎
A shadow tree’s corresponding light tree can be a shadow tree itself.
</p>

<p id="in-a-shadow-including-document">
`要素$は、その`~shadowも含む根$が`文書$であるとき，
`接続されて@
いるという。
◎
An element is connected if its shadow-including root is a document.
</p>

				<section id="shadow-tree-slots">
<h5 title="Slots">4.2.2.1. ~slot</h5>

<p>
各`~shadow~tree$は、 0 個以上の，
`~slot@
と呼ばれる`要素$を包含する。
◎
A shadow tree contains zero or more elements that are slots.
</p>

<p class="note">注記：
`~slot$を作成できるのは、~HTMLの `slot$e 要素を通す他にない。
◎
A slot can only be created through HTML’s slot element.
</p>

<p>
各 `~slot$には、
`~slot名@
が結付けられる。
それは文字列であり、他が言明されない限り，空~文字列とする。
◎
A slot has an associated name (a string). Unless stated otherwise it is the empty string.
</p>

<div class="algo">
<p>
`~slot$の`~slot名$を更新するときは、`属性o変更-時の手続き$として次を利用する
— それは、所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
Use these attribute change steps to update a slot’s name:
</p>
<ol>
	<li>
~IF［
%要素 は `~slot$でない
］~OR［
%局所~名 ~NEQ `name^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If element is a slot, localName is name, and namespace is null, then:
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%旧-値 ~EQ ~NULL
］
⇒
%旧-値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%値 ~EQ %旧-値
］
⇒
~RET
◎
If value is oldValue, then return.
◎
If value is null and oldValue is the empty string, then return.
◎
If value is the empty string and oldValue is null, then return.
</li>
	<li>
%要素 の`~slot名$ ~SET %値
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
	<li>
`~treeに~slot可能なものを割当する$( %要素 の`根$ )
◎
Run assign slottables for a tree with element’s root.
</li>
</ol>
</div>

<p class="note">注記：
`~shadow~tree$内の，［
`~slot名$ ~EQ 空~文字列
］なる`~slot$のうち，`~tree順序$で最初のものは
“既定の~slot”
と称されることもある。
◎
The first slot in a shadow tree, in tree order, whose name is the empty string, is sometimes known as the "default slot".
</p>

<p>
各 `~slot$には、
`割当された~node群@
（ `assigned nodes^en ）が結付けられる。
それは，`~slot可能$の`~list$であり、他が言明されない限り，`空$とする。
◎
A slot has an associated assigned nodes (a list of slottables). Unless stated otherwise it is empty.
</p>

				</section>
				<section id="light-tree-slotables">
<h5 title="Slottables">4.2.2.2. ~slot可能</h5>

<p>
［
$Element ／ $Text
］`~node$は、
`~slot可能@
である。
◎
Element and Text nodes are slottables.
</p>

<p class="trans-note">【
~slotは “はめ込み口”，
~slot可能（ `slottable^en ）は “はめ込めるモノ”
（名詞化された形容詞
— 形容詞としては “はめ込み可能” を表す）。
】</p>

<p class="note">注記：
`~slot$も、`~slot可能$になり得る。
◎
A slot can be a slottable.
</p>

<p>
各 `~slot可能$には、
`名前@sB
が結付けられる。
それは文字列であり、他が言明されない限り，空~文字列とする。
◎
A slottable has an associated name (a string). Unless stated otherwise it is the empty string.
</p>

<div class="algo">
<p>
`~slot可能$の`名前$sBを更新するときは、`属性o変更-時の手続き$として次を利用する
— それは、所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
Use these attribute change steps to update a slottable’s name:
</p>
<ol>
	<li>
~IF［
%局所~名 ~NEQ `slot^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If localName is slot and namespace is null, then:
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%旧-値 ~EQ ~NULL
］
⇒
%旧-値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%値 ~EQ %旧-値
］
⇒
~RET
◎
If value is oldValue, then return.
◎
If value is null and oldValue is the empty string, then return.
◎
If value is the empty string and oldValue is null, then return.
</li>
	<li>
%要素 の`名前$sB ~SET %値
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
	<li>
~IF［
%要素 の`割当-先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( その`~slot$ )
◎
If element is assigned, then run assign slottables for element’s assigned slot.
</li>
	<li>
`~slot可能を~slotに割当する$( %要素 )
◎
Run assign a slot for element.
</li>
</ol>
</div>

<p>
各 `~slot可能$には
`割当-先~slot@
（ `assigned slot^en ）が結付けられる。
それは，［
~NULL ／ `~slot$
］であり、他が言明されない限り， ~NULL とする。
【自身がどの`~slot$に割当されたかを指示する。】
◎
A slottable has an associated assigned slot (null or a slot). Unless stated otherwise it is null.＼
</p>

<p>
`割当-先~slot$が ~NULL でない`~slot可能$は、
`割当-先がある@
（ `is assigned^en ）という。
【この訳では、この用語は利用せず，直に “`割当-先~slot$ ~NEQ ~NULL ” と記す。】
◎
A slottable is assigned if its assigned slot is non-null.
</p>

<p>
各 `~slot可能$には
`手動~割当-先~slot@
（ `manual slot assignment^en, ~scriptが手動で割当した~slot）が結付けられる。
それは，［
~NULL ／ `~slot$
］であり、他が言明されない限り， ~NULL とする。
◎
A slottable has an associated manual slot assignment (null or a slot). Unless stated otherwise, it is null.
</p>

<p class="note">注記：
`~slot可能$の`手動~割当-先~slot$は、~scriptからは直に~access可能でないので，
`~slot$への弱い参照を利用して実装できる／され得る。
◎
A slottable’s manual slot assignment can be implemented using a weak reference to the slot, because this variable is not directly accessible from script.
</p>

				</section>
				<section id="finding-slots-and-slotables">
<h5 title="Finding slots and slottables">4.2.2.3. ~slot／~slot可能の見出法</h5>

<div class="algo">
<p>
`~slot可能~用に~slotを見出す@
ときは、所与の
( `~slot可能$ %~slot可能, %~openか ~IN { `~open^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To find a slot for a given slottable slottable and an optional open flag (unset unless stated otherwise), run these steps:
</p>
<ol>
	<li>
~IF［
%~slot可能 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If slottable’s parent is null, then return null.
</li>
	<li>
%~shadow ~LET %~slot可能 の`親$の`~shadow根$elm
◎
Let shadow be slottable’s parent’s shadow root.
</li>
	<li>
~IF［
%~shadow ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If shadow is null, then return null.
</li>
	<li>
~IF［
%~openか ~EQ `~open^i
］~AND［
%~shadow の`~mode$sR ~NEQ `open^l
］
⇒
~RET ~NULL
◎
If the open flag is set and shadow’s mode is not "open", then return null.
</li>
	<li>
<p>
~IF［
%~shadow の`~slot割当n~mode$sR ~EQ `manual^l
］
⇒
~RET 次を満たす %~slot は［
在るならば %~slot ／
無いならば ~NULL
］
⇒
［
 %~shadow の`子孫$である
］~AND［
`~slot$である
］~AND［
%~slot可能 ~IN %~slot に`手動で割当された~node群$
］
</p>

<p class="trans-note">【
条件を満たす %~slot は在っても一つしかないことは、
`assign()$m ~method手続きにより保証される。
】</p>
◎
If shadow’s slot assignment is "manual", then return the slot in shadow’s descendants whose manually assigned nodes contains slottable, if any; otherwise null.
</li>
	<li>
~RET 次を満たす［
%~shadow の`子孫$
］のうち，`~tree順序$で`最初のもの？$
⇒
`~slot$であって，その`~slot名$ ~EQ %~slot可能 の`名前$sB
◎
Return the first slot in tree order in shadow’s descendants whose name is slottable’s name, if any; otherwise null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~slot用に~slot可能なものを見出す@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To find slottables for a given slot slot, run these steps:
</p>
<ol>
	<li id="cp-let-result-empty-list">
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
	<li>
%根 ~LET %~slot の`根$
◎
Let root be slot’s root.
</li>
	<li>
~IF［
%根 は`~shadow根$でない
］
⇒
~RET %結果
◎
If root is not a shadow root, then return result.
</li>
	<li>
%~host ~LET %根 の`~host$
◎
Let host be root’s host.
</li>
	<li>
~IF［
%根 の`~slot割当n~mode$sR ~EQ `manual^l
］
⇒
%~slot に`手動で割当された~node群$を成す
~EACH( `~slot可能$ %~slot可能 )
に対し
⇒
~IF［
%~slot可能 の`親$ ~EQ %~host
］
⇒
%結果 に %~slot可能 を`付加する$
◎
If root’s slot assignment is "manual", then:
• Let result be « ».（不要）
• For each slottable slottable of slot’s manually assigned nodes, if slottable’s parent is host, append slottable to result.
</li>
	<li>
~ELSE
⇒
%~host の`子~群$を成す
~EACH( %子 )
に対し，`~tree順序$で
⇒
~IF［
%子 は`~slot可能$である
］~AND［
`~slot可能~用に~slotを見出す$( %子 ) ~EQ %~slot
］
⇒
%結果 に %子 を`付加する$
◎
Otherwise, for each slottable child slottable of host, in tree order:
• Let foundSlot be the result of finding a slot given slottable.
• If foundSlot is slot, then append slottable to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~slot用に平坦~化された~slot可能なものを見出す@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To find flattened slottables for a given slot slot, run these steps:
</p>
<ol>
	<!--cp-let-result-empty-list-->
	<li>
~IF［
%~slot の`根$は`~shadow根$でない
］
⇒
~RET %結果
◎
If slot’s root is not a shadow root, then return result.
</li>
	<li>
%~slot可能~list ~LET
`~slot用に~slot可能なものを見出す$( %~slot )
◎
Let slottables be the result of finding slottables given slot.
</li>
	<li>
~IF［
%~slot可能~list は`空$である
］
⇒
%~slot の`子~群$を成す
~EACH( %子 )
に対し，`~tree順序$で
⇒
~IF［
%子 は`~slot可能$である
］
⇒
%~slot可能~list に %子 を付加する
◎
If slottables is the empty list, then append each slottable child of slot, in tree order, to slottables.
</li>
	<li>
<p>
%~slot可能~list を成す
~EACH( %~node )
に対し：
◎
For each node in slottables:
</p>
		<ol>
			<li>
<p>
~IF［
%~node は`~slot$である
］~AND［
%~node の`根$は`~shadow根$である
］
⇒
［
`~slot用に平坦~化された~slot可能なものを見出す$( %~node )
］を成す
~EACH( `~slot可能$ %~slot可能 )
に対し，順に
⇒
%結果 に %~slot可能 を付加する
◎
If node is a slot whose root is a shadow root, then:
• Let temporaryResult be the result of finding flattened slottables given node.
• Append each slottable in temporaryResult, in order, to result.
</li>
			<li>
~ELSE
⇒
%結果 に %~node を付加する
◎
Otherwise, append node to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

				</section>
				<section id="assigning-slotables-and-slots">
<h5 title="Assigning slottables and slots">4.2.2.4. ~slot可能／~slotの割当法</h5>

<div class="algo">
<p>
`~slotに~slot可能なものを割当する@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To assign slottables for a slot slot, run these steps:
</p>
<ol>
	<li>
%~slot可能~list ~LET
`~slot用に~slot可能なものを見出す$( %~slot )
◎
Let slottables be the result of finding slottables for slot.
</li>
	<li>
~IF［
%~slot可能~list と %~slot に`割当された~node群$とは、一致しない
【！＊順序は関係ある？ない？】
］
⇒
`~slotの変化を通達する$( %~slot )
◎
If slottables and slot’s assigned nodes are not identical, then run signal a slot change for slot.
</li>
	<li>
%~slot に`割当された~node群$ ~SET %~slot可能~list
◎
Set slot’s assigned nodes to slottables.
</li>
	<li>
%~slot可能~list を成す
~EACH( %~slot可能 )
に対し
⇒
%~slot可能 の`割当-先~slot$ ~SET %~slot
◎
For each slottable in slottables, set slottable’s assigned slot to slot.
</li>
</ol>
</div>

<div class="algo">
<p>
`~treeに~slot可能なものを割当する@
ときは、所与の
( `~node$ %根 )
に対し，次を走らす
⇒
%根 の`広義-子孫$である
~EACH( `~slot$ %~slot )
に対し，`~tree順序$で
⇒
`~slotに~slot可能なものを割当する$( %~slot )
◎
To assign slottables for a tree, given a node root, run assign slottables for each slot slot in root’s inclusive descendants, in tree order.
</p>
</div>

<div class="algo">
<p>
`~slot可能を~slotに割当する@
ときは、所与の
( `~slot可能$ %~slot可能 )
に対し、次を走らす：
◎
To assign a slot, given a slottable slottable, run these steps:
</p>
<ol>
	<li>
%~slot ~LET `~slot可能~用に~slotを見出す$( %~slot可能 )
◎
Let slot be the result of finding a slot with slottable.
</li>
	<li>
~IF［
%~slot ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( %~slot )
◎
If slot is non-null, then run assign slottables for slot.
</li>
</ol>
</div>

				</section>
				<section id="signaling-slot-change">
<h5 title="Signaling slot change">4.2.2.5. ~slot変化の通達-法</h5>

<p>
各 `生成元が類似な~window~agent$ `HTML$r は、
`通達~slot群@
を持つ。
それは，`~slot$たちが成す`有順序~集合$であり、初期~時は空とする。
◎
Each similar-origin window agent has signal slots (a set of slots), which is initially empty. [HTML]
</p>

<div class="algo">
<p>
`~slotの変化を通達する@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To signal a slot change, for a slot slot, run these steps:
</p>
<ol>
	<li>
［
%~slot に`関連な~agent$の`通達~slot群$
］に %~slot を`付加する$set
◎
Append slot to slot’s relevant agent’s signal slots.
</li>
	<li>
`変異~観測器 小taskを~queueする$
◎
Queue a mutation observer microtask.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="mutation-algorithms">
<h4 title="Mutation algorithms">4.2.3. 変異~algo</h4>

<!--% 挿入検証 -->
<div class="algo">
<p>
%~node を %親 の中で %子 の前に
`挿入できるかどうか検証する@
ときは、次を走らす：
◎
To ensure pre-insertion validity of a node into a parent before a child, run these steps:
</p>

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->
<ol>
	<li id="cp-throw-if-chardata">
~IF［
%親 は［
$Document ／ $DocumentFragment ／ $Element
］`~node$でない
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li id="cp-throw-if-iAN">
~IF［
%~node は %親 の`~hostも含む広義-先祖$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a host-including inclusive ancestor of parent, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%子 ~NEQ ~NULL
］~AND［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child is non-null and its parent is not parent, then throw a "NotFoundError" DOMException.
</li>
	<li id="cp-throw-if-not-doc">
<p>
~IF［
%~node は［
$DocumentFragment ／ $DocumentType ／ $Element ／ $CharacterData
］`~node$でない
］
⇒
~THROW `HierarchyRequestError$E
</p>

<p class="trans-note">【
すなわち “^Document ／ ^Attr ~nodeである”（何故そのように記されない？）
】</p>

◎
If node is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li id="cp-throw-if-mismatch1">
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `HierarchyRequestError$E
：
</p>
		<ul>
			<li>
［
%~node は $Text `~node$ である
］~AND［
%親 は`文書$である
］
</li>
			<li>
［
%~node は`~doctype$である
］~AND［
%親 は`文書$でない
］
</li>
		</ul>
◎
If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
<p id="cp-throw-if-doc-etc">
~IF［
%親 は`文書$である
］~AND［
%~node が`実装-$する~interfaceに応じて，以下が満たされる
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is a document, and any of the statements below, switched on the interface node implements, are true, then throw a "HierarchyRequestError" DOMException.
</p>
		<dl class="switch">
			<dt>$DocumentFragment</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li id="cp-has-element-children">
%~node の`子~群$内に在る`要素$の個数 ~GT 1
◎
If node has more than one element child or＼
</li>
					<li id="cp-has-Text-child">
%~node の`子~群$内に $Text `~node$が在る
◎
has a Text node child.
</li>
					<li>
<p id="cp-has-an-element-and">
［
%~node の`子~群$内に在る`要素$の個数 ~EQ 1
］~AND［
次のいずれかが満たされる
］：
</p>

<ul id="cp-has-other-doctype"
	><li>%親 の`子~群$内に`要素$が在る
</li><li>%子 は`~doctype$である
</li><li>［
%子 ~NEQ ~NULL
］~AND［
%子 に`後続-$する`~doctype$が在る
］
</li></ul>
◎
Otherwise, if node has one element child and either parent has an element child, child is a doctype, or child is non-null and a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>$Element</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<!--cp-has-other-doctype-->
◎
parent has an element child, child is a doctype, or child is non-null and a doctype is following child.
			</dd>

			<dt>$DocumentType</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>

<ul>
	<li>%親 の`子~群$内に`~doctype$が在る</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%子 に`先行-$する`要素$が在る
］
</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%親 の`子~群$内に`要素$が在る
］
</li>
</ul>

◎
parent has a doctype child, child is non-null and an element is preceding child, or child is null and parent has an element child.
			</dd>
		</dl>
	</li>
</ol>
</div>

<!--% 前挿入 -->
<div class="algo">
<p>
%親 の中で
`~nodeを子の前に前挿入する@
ときは、所与の
( %~node, %子 )
に対し，次を走らす：
◎
To pre-insert a node into a parent before a child, run these steps:
</p>
<ol>
	<li>
%~node を %親 の中で %子 の前に`挿入できるかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before child.
</li>
	<li>
%基準~子 ~LET %子
◎
Let referenceChild be child.
</li>
	<li id="cp-set-next-sibling">
~IF［
%基準~子 ~EQ %~node
］
⇒
%基準~子 ~SET %~node の`次-同胞？$
◎
If referenceChild is node, then set referenceChild to node’s next sibling.
</li>
	<li>
%親 の中で`~nodeを子の前に挿入する$( %~node, %基準~子 )
◎
Insert node into parent before referenceChild.
</li>
	<li>
~RET %~node
【！technically this is post-insert】
◎
Return node.
</li>
</ol>
</div>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`挿入-時の手続き@
を定義してもヨイ。
この~algoは、`~nodeを子の前に挿入する$~algo内から，
( `~node$ )
【！＊insertedNode】
を渡して呼出される。
◎
Specifications may define insertion steps for all or some nodes. The algorithm is passed insertedNode, as indicated in the insert algorithm below.
</p>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`子~群~変更-時の手続き@
を定義してもヨイ。
この~algoは、［
`~nodeを子の前に挿入する$／
`~nodeを除去する$／
`~dataを置換する$
］~algo内から，引数なしで呼出される。
◎
Specifications may define children changed steps for all or some nodes. The algorithm is passed no argument and is called from insert, remove, and replace data.
</p>

<!--% 挿入 -->
<div class="algo">
<p>
%親 の中で
`~nodeを子の前に挿入する@
ときは、所与の
( %~node, %子, %観測器は抑止するか ~IN { `観測器は抑止する^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To insert a node into a parent before a child, with an optional suppress observers flag, run these steps:
</p>
<ol>
	<li id="cp-let-nodes">
%~node群 ~LET ［
%~node は`文書片$であるならば %~node の`子~群$【を`~cloneする$】 ／
~ELSE_ « %~node »
］
◎
Let nodes be node’s children, if node is a DocumentFragment node; otherwise « node ».
</li>
	<li>
%count ~LET %~node群 の`~size$
◎
Let count be nodes’s size.
</li>
	<li>
~IF［
%count ~EQ 0
］
⇒
~RET
◎
If count is 0, then return.
</li>
	<li>
<p>
~IF［
%~node は`文書片$である
］：
◎
If node is a DocumentFragment node, then:
</p>
		<ol>
			<li>
%~node群 を成す
~EACH( %C )
に対し【！順序は関係なし】
⇒
`~nodeを除去する$( %C, `観測器は抑止する^i )
◎
Remove its children with the suppress observers flag set.
</li>
			<li>
<p>
%~node 用に`~tree変異~記録を~queueする$( « », %~node群, ~NULL, ~NULL )
◎
Queue a tree mutation record for node with « », nodes, null, and null.
</p>

<p class="note">注記：
この段では意図的に %観測器は抑止するか を~~無視する。
◎
This step intentionally does not pay attention to the suppress observers flag.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%子 ~NEQ ~NULL
］
⇒
~EACH( `~live範囲o$ %範囲o )
に対し：
◎
If child is non-null, then:
</p>
		<ol>
			<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~GT %子 の`~index$
］
⇒
%範囲o の`始端~offset$ ~INCBY %count
◎
For each live range whose start node is parent and start offset is greater than child’s index, increase its start offset by count.
</li>
			<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~GT %子 の`~index$†
］
⇒
%範囲o の`終端~offset$ ~INCBY %count
◎
For each live range whose end node is parent and end offset is greater than child’s index, increase its end offset by count.
</li>
		</ol>

<p class="trans-note">【†
挿入される地点にちょうど一致する［
範囲oの`境界点$
］は、それが`終端$であっても，影響されないことになる
— すなわち，挿入-後は 挿入された~nodeの直前を指す。
その結果，この~algoを利用している`子を~nodeに置換する$（後述）においては、
除去される~nodeの直後または内部を指していた範囲oの境界点は，
置換-後は 新たに挿入された~nodeの直前を指すようにされる（~node~treeの［
先頭／末尾
］から相対的な範囲oの［
始端／終端
］の位置変化のふるまいが，対称でない
— 同様のことは，`~dataを置換する$~algoにも該当する）。
】</p>
	</li>
	<li>
%前-同胞 ~LET ［
%子 ~NEQ ~NULL ならば %子 の`前-同胞？$ ／
~ELSE_ %親 の`最後の子？$
］
◎
Let previousSibling be child’s previous sibling or parent’s last child if child is null.
</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し，`~tree順序$で：
◎
For each node in nodes, in tree order:
</p>
		<ol>
			<li>
%親 の`~node文書$に`~nodeを受入する$( %~node )
◎
Adopt node into parent’s node document.
</li>
			<li>
~IF［
%子 ~EQ ~NULL
］
⇒
%親 の`子~群$に %~node を`付加する$set
◎
If child is null, then append node to parent’s children.
</li>
			<li>
~ELSE
⇒
%~node を%親 の`子~群$の中で %子 の`~index$の前に`挿入する$
◎
Otherwise, insert node into parent’s children before child’s index.
</li>
			<li>
~IF［
%親 は`~shadow~host$である
］~AND［
%親 の`~shadow根$の`~slot割当n~mode$sR ~EQ `named^l
］~AND［
%~node は`~slot可能$である
］
⇒
`~slot可能を~slotに割当する$( %~node )
◎
If parent is a shadow host whose shadow root’s slot assignment is "named" and node is a slottable, then assign a slot for node.
</li>
			<li id="cp-signal-if-assigned-empty">
~IF［
%親 の`根$は`~shadow根$である
］~AND［
%親 は`~slot$である
］~AND［
%親 に`割当された~node群$は`空$である
］
⇒
`~slotの変化を通達する$( %親 )
◎
If parent’s root is a shadow root, and parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.
</li>
			<li>
`~treeに~slot可能なものを割当する$( %~node の`根$ )
◎
Run assign slottables for a tree with node’s root.
</li>
			<li>
<p>
%~node の
~EACH( `~shadowも含む広義-子孫$ %広義-子孫 )
に対し，`~shadowも含む~tree順序$で：
◎
For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order:
</p>
				<ol>
					<li>
`挿入-時の手続き$に
( %広義-子孫 )
を渡して走らす
◎
Run the insertion steps with inclusiveDescendant.
</li>
					<li>
~IF［
%広義-子孫 は`接続されて$いない
］
⇒
~CONTINUE
◎
If inclusiveDescendant is connected, then:
</li>
					<li>
~IF［
%広義-子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義-子孫,
`connectedCallback^l,
空~list
)
◎
If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant, callback name "connectedCallback", and an empty argument list.
</li>
					<li>
<p>
~ELSE
⇒
`要素を昇格しようと試行する$( %広義-子孫 )
◎
Otherwise, try to upgrade inclusiveDescendant.
</p>

<p class="note">注記：
%広義-子孫 が成功裡に昇格された場合、その ^connectedCallback は，`要素を昇格する$~algoの間に自動的に~enqueueされる。
◎
If this successfully upgrades inclusiveDescendant, its connectedCallback will be enqueued automatically during the upgrade an element algorithm.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%観測器は抑止するか ~EQ ε
］
⇒
%親 用に`~tree変異~記録を~queueする$( %~node群, « », %前-同胞, %子 )
◎
If suppress observers flag is unset, then queue a tree mutation record for parent with nodes, « », previousSibling, and child.
</li>
	<li id="cp-children-changed-steps">
%親 用に`子~群~変更-時の手続き$を走らす
◎
Run the children changed steps for parent.
</li>
</ol>
</div>

<div class="algo">
<p>
%親 に
`~nodeを付加する@
ときは、所与の
( %~node )
に対し，次を走らす
⇒
%親 の中で`~nodeを子の前に前挿入する$( %~node, ~NULL )
◎
To append a node to a parent, pre-insert node into parent before null.
</p>
</div>

<!--% 置換 -->
<div class="algo">
<p>
%親 の中で
`子を~nodeに置換する@
ときは、所与の
( %子, %~node )
に対し，次を走らす：
◎
To replace a child with node within a parent, run these steps:
</p>
<ol>
	<!--cp-throw-if-chardata-->
	<!--cp-throw-if-iAN-->
	<li id="cp-throw-if-not-parent">
~IF［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child’s parent is not parent, then throw a "NotFoundError" DOMException.
</li>
	<!--cp-throw-if-not-doc-->
	<!--cp-throw-if-mismatch1-->
	<li>
<!--cp-throw-if-doc-etc-->
		<dl class="switch">
			<dt>$DocumentFragment</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<!--cp-has-element-children-->
					<!--cp-has-Text-child-->
					<li>
						<!--cp-has-an-element-and-->
<ul id="cp-has-other-element"
	><li>%親 の`子~群$内に［ %子 以外の`要素$ ］が在る
</li><li>%子 に`後続-$する`~doctype$が在る
</li></ul>
◎
Otherwise, if node has one element child and either parent has an element child that is not child or a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>$Element</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<!--cp-has-other-element-->
◎
parent has an element child that is not child or a doctype is following child.
			</dd>

			<dt>$DocumentType</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>

<ul><li>%親 の`子~群$内に［ %子 以外の`~doctype$ ］が在る
</li><li>%子 に`先行-$する`要素$が在る
</li></ul>

◎
parent has a doctype child that is not child, or an element is preceding child.
			</dd>
		</dl>

<p class="note">注記：
この段は，`挿入できるかどうか検証する$ ~algoの似た段と異なる。
◎
The above statements differ from the pre-insert algorithm.
</p>
	</li>
	<li>
%基準~子 ~LET %子 の`次-同胞？$
◎
Let referenceChild be child’s next sibling.
</li>
	<!--cp-set-next-sibling-->
	<li>
%前-同胞 ~LET %子 の`前-同胞？$
◎
Let previousSibling be child’s previous sibling.
</li>
	<li>
%除去-済み~node群 ~LET 空~集合
◎
Let removedNodes be the empty set.
</li>
	<li>
<p>
~IF［
%子 の`親$ ~NEQ ~NULL
］：
◎
If child’s parent is non-null, then:
</p>
		<ol>
			<li>
%除去-済み~node群 ~SET « %子 »
◎
Set removedNodes to « child ».
</li>
			<li>
`~nodeを除去する$( %子, `観測器は抑止する^i )
◎
Remove child with the suppress observers flag set.
</li>
		</ol>

<p class="note">注記：
この段の~~条件は［
%子 ~EQ %~node
］の場合に限り，偽になる。
◎
The above can only be false if child is node.
</p>

	</li>
	<!--cp-let-nodes-->
	<li>
%親 の中で`~nodeを子の前に挿入する$( %~node, %基準~子, `観測器は抑止する^i )
◎
Insert node into parent before referenceChild with the suppress observers flag set.
</li>
	<li>
%親 用に`~tree変異~記録を~queueする$( %~node群, %除去-済み~node群, %前-同胞, %基準~子 )
◎
Queue a tree mutation record for parent with nodes, removedNodes, previousSibling, and referenceChild.
</li>
	<li>
~RET %子
◎
Return child.
</li>
</ol>
</div>

<!--% 全置換 -->
<div class="algo">
<p>
%親 の
`全~内容を~nodeで置換する@
ときは、所与の
( %~node )
に対し，次を走らす：
◎
To replace all with a node within a parent, run these steps:
</p>
<ol>
	<li>
%除去-済み~node群 ~LET %親 の`子~群$
◎
Let removedNodes be parent’s children.
</li>
	<li>
%追加-済み~node群 ~LET %~node に応じて，次に与える集合
⇒＃
~NULL ならば « » ／
`文書片$であるならば %~node の`子~群$【を`~cloneする$】 ／
~ELSE_ « %~node »
◎
Let addedNodes be the empty set.
◎
If node is a DocumentFragment node, then set addedNodes to node’s children.
◎
Otherwise, if node is non-null, set addedNodes to « node ».
</li>
	<li>
%親 の`子~群$を成す
~EACH( %子 )
に対し，`~tree順序$で
⇒
`~nodeを除去する$( %子, `観測器は抑止する^i )
◎
Remove all parent’s children, in tree order, with the suppress observers flag set.
</li>
	<li>
~IF［
%~node ~NEQ ~NULL
］
⇒
%親 の中で`~nodeを子の前に挿入する$( %~node, ~NULL, `観測器は抑止する^i )
◎
If node is non-null, then insert node into parent before null with the suppress observers flag set.
</li>
	<li>
~IF［
%追加-済み~node群 は`空$でない
］~OR［
%除去-済み~node群 は`空$でない
］
⇒
%親 用に`~tree変異~記録を~queueする$( %追加-済み~node群, %除去-済み~node群, ~NULL, ~NULL )
◎
If either addedNodes or removedNodes is not empty, then queue a tree mutation record for parent with addedNodes, removedNodes, null, and null.
</li>
</ol>

<p class="note">注記：
この~algoは `~node~tree$に課される拘束を検査しない。
仕様の策定者は賢く利用すること。
◎
This algorithm does not make any checks with regards to the node tree constraints. Specification authors need to use it wisely.
</p>
</div>

<div class="algo">
<p>
%親 から
`子を前除去する@
ときは、所与の
( %子 )
に対し，次を走らす：
◎
To pre-remove a child from a parent, run these steps:
</p>
<ol>
	<!--cp-throw-if-not-parent-->
	<li>
`~nodeを除去する$( %子 )
◎
Remove child.
</li>
	<li>
~RET %子
【！technically this is post-remove】
◎
Return child.
</li>
</ol>
</div>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`除去-時の手続き@
を定義してもヨイ。
この~algoは、`~nodeを除去する$ ~algo内から，
( 除去された`~node$, 旧-`親$ （省略可能） )
を渡して呼出される。
◎
Specifications may define removing steps for all or some nodes. The algorithm is passed removedNode, and optionally oldParent, as indicated in the remove algorithm below.
</p>

<!--% 除去 -->
<div class="algo">
<p>
`~nodeを除去する@
ときは、所与の
( %~node, %観測器は抑止するか ~IN { `観測器は抑止する^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To remove a node, with an optional suppress observers flag, run these steps:
</p>
<ol>
	<li>
%親 ~LET %~node の`親$
◎
Let parent be node’s parent
</li>
	<li>
~Assert：
%親 ~NEQ ~NULL
◎
Assert: parent is non-null.
</li>
	<li>
%~index ~LET %~node の`~index$
◎
Let index be node’s index.
</li>
	<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
◎
↓</p>
		<ol>
			<li>
~IF［
%範囲o の`始端~node$ は %~node の`広義-子孫$である
］
⇒＃
%範囲o の`始端~node$ ~SET %親；
%範囲o の`始端~offset$ ~SET %~index
◎
For each live range whose start node is an inclusive descendant of node, set its start to (parent, index).
</li>
			<li>
~IF［
%範囲o の`終端~node$ は %~node の`広義-子孫$である
］
⇒＃
%範囲o の`終端~node$ ~SET %親；
%範囲o の`終端~offset$ ~SET %~index
◎
For each live range whose end node is an inclusive descendant of node, set its end to (parent, index).
</li>
			<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~GT %~index
］
⇒
%範囲o の`始端~offset$ ~DECBY 1
◎
For each live range whose start node is parent and start offset is greater than index, decrease its start offset by 1.
</li>
			<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~GT %~index
］
⇒
%範囲o の`終端~offset$ ~DECBY 1
◎
For each live range whose end node is parent and end offset is greater than index, decrease its end offset by 1.
</li>
		</ol>
	</li>
	<li>
~EACH( $NodeIterator ~obj %反復子 )
に対し
⇒
~IF［
%反復子 の`根$tVの`~node文書$ ~EQ %~node の`~node文書$
］
⇒
`前除去-時の手続き$に
( %反復子, %~node )
を渡して走らす
◎
For each NodeIterator object iterator whose root’s node document is node’s node document, run the NodeIterator pre-removing steps given node and iterator.
</li>
	<li>
%前-同胞 ~LET %~node の`前-同胞？$
◎
Let oldPreviousSibling be node’s previous sibling.
</li>
	<li>
%次-同胞 ~LET %~node の`次-同胞？$
◎
Let oldNextSibling be node’s next sibling.
</li>
	<li>
%~node を %親 の`子~群$から`除去する$
◎
Remove node from its parent’s children.
</li>
	<li>
~IF［
%~node の`割当-先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( その`~slot$ )
◎
If node is assigned, then run assign slottables for node’s assigned slot.
</li>
	<!--cp-signal-if-assigned-empty-->
	<li>
<p>
~IF［［
%~node の`広義-子孫$のうち，`~slot$であるもの
］は在る
］：
◎
If node has an inclusive descendant that is a slot, then:
</p>
		<ol>
			<li>
`~treeに~slot可能なものを割当する$( %親 の`根$ )
◎
Run assign slottables for a tree with parent’s root.
</li>
			<li>
`~treeに~slot可能なものを割当する$( %~node )
◎
Run assign slottables for a tree with node.
</li>
		</ol>
	</li>
	<li>
`除去-時の手続き$に
( %~node, %親 )
を渡して走らす
◎
Run the removing steps with node and parent.
</li>
	<li>
%親は接続されているか ~LET ［
%親 は`接続されて$いるならば ~T ／
~ELSE_ ~F
］
◎
Let isParentConnected be parent’s connected.
</li>
	<li>
<p>
~IF［
%~node は`~custom$である
］~AND［
%親は接続されているか ~EQ ~T
］
⇒
`~custom要素~callback反応を~enqueueする$(
%~node,
`disconnectedCallback^l,
空~list
)
◎
If node is custom and isParentConnected is true, then enqueue a custom element callback reaction with node, callback name "disconnectedCallback", and an empty argument list.
</p>

<p class="note">注記：
今の所，`~custom$である`要素$には %親 を渡さないのは意図的であるが、将来に必要になった場合は変更され得る。
◎
It is intentional for now that custom elements do not get parent passed. This might change in the future if there is a need.
</p>
	<li>
<p>
%~node の
~EACH( `~shadowも含む子孫$ %子孫 )
に対し，`~shadowも含む~tree順序$で：
◎
For each shadow-including descendant descendant of node, in shadow-including tree order, then:
</p>
		<ol>
			<li>
`除去-時の手続き$に
( %子孫 )
を渡して走らす
◎
Run the removing steps with descendant.
</li>
			<li>
~IF［
%子孫 は`~custom$である
］~AND［
%親は接続されているか ~EQ ~T
］
⇒
`~custom要素~callback反応を~enqueueする$(
%子孫,
`disconnectedCallback^l,
空~list
)
◎
If descendant is custom and isParentConnected is true, then enqueue a custom element callback reaction with descendant, callback name "disconnectedCallback", and an empty argument list.
</li>
		</ol>
	</li>
	<li>
%親 の
~EACH( `広義-先祖$ %広義-先祖 )
に対し
⇒
%広義-先祖 の`登録-済み観測器~list$を成す
~EACH( %登録-済み )
に対し
⇒
~IF［
%登録-済み の`~option群$ob[ "$MutationObserverInit.subtree" ] ~EQ ~T
］
⇒
%~node の`登録-済み観測器~list$に 次のように設定された新たな`一時~登録-済み観測器$を`付加する$
⇒＃
`観測器$ob ~SET %登録-済み の`観測器$ob,
`~option群$ob ~SET %登録-済み の`~option群$ob,
`~source$ob ~SET %登録-済み
◎
For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of inclusiveAncestor’s registered observer list, if registered’s options["subtree"] is true, then append a new transient registered observer whose observer is registered’s observer, options is registered’s options, and source is registered to node’s registered observer list.
</li>
	<li>
~IF［
%観測器は抑止するか ~EQ ε
］
⇒
%親 用に`~tree変異~記録を~queueする$( « », « %~node », %前-同胞, %次-同胞 )
◎
If suppress observers flag is unset, then queue a tree mutation record for parent with « », « node », oldPreviousSibling, and oldNextSibling.
</li>
	<!--cp-children-changed-steps-->
</ol>
</div>

			</section>
			<section id="interface-nonelementparentnode">
<h4 title="Mixin NonElementParentNode">4.2.4. ^@NonElementParentNode ~mixin</h4>

<p class="note">注記：
~Web互換性のため、 $getElementById() ~methodは，`要素$ 上には（したがって $ParentNode 上にも）公開できない。
◎
Web compatibility prevents the getElementById() method from being exposed on elements (and therefore on ParentNode).
</p>

！！
interface mixin @NonElementParentNode {
  $Element? $getElementById($DOMString %elementId);
};
$Document includes $NonElementParentNode;
$DocumentFragment includes $NonElementParentNode;
！

<dl class="domintro">
	<dt>%node . $getElementById(elementId)</dt>
	<dd>
%node の`子孫$であって, `~ID$ ~EQ %elementId なる`要素$のうち，`最初のもの？$を返す。
◎
Returns the first element within node’s descendants whose ID is elementId.
</dd>
</dl>

<div class="algo">
@getElementById(elementId)
~method~手続きは
⇒
~RET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`子孫$である
］~AND［
`要素$である
］~AND［
`~ID$ ~EQ %elementId
］
◎
The getElementById(elementId) method steps are to return the first element, in tree order, within this’s descendants, whose ID is elementId; otherwise, if there is no such element, null.
</div>

			</section>
			<section id="mixin-documentorshadowroot">
<h4 title="Mixin DocumentOrShadowRoot">4.2.5. ^@DocumentOrShadowRoot ~mixin</h4>

！！
interface mixin @DocumentOrShadowRoot {
};

$Document includes $DocumentOrShadowRoot;
$ShadowRoot includes $DocumentOrShadowRoot;
！

<p class="note">注記：
$DocumentOrShadowRoot ~mixinは、［
`文書$, `~shadow根$
］で共有される~APIを定義したいと求める他の標準により利用されることが期待されている。
◎
The DocumentOrShadowRoot mixin is expected to be used by other standards that want to define APIs shared between documents and shadow roots.
</p>

			</section>
			<section id="interface-parentnode">
<h4 title="Mixin ParentNode">4.2.6. ^@ParentNode ~mixin</h4>

<div class="algo">
<p>
`~node群を~nodeに変換する@
手続きは、所与の
( %~node群, %文書 )
に対し，次を走らす：
◎
To convert nodes into a node, given nodes and document, run these steps:
</p>

<p class="trans-note">【
%~node群 は、~nodeと文字列が混在する引数~list。
】</p>
<ol>
	<li>
%~node群 を成す
~EACH( 文字列 %文字列 ) を
`新たな~Text~node$( %文字列, %文書 )
に置換する
◎
Let node be null.
◎
Replace each string in nodes with a new Text node whose data is the string and node document is document.
</li>
	<li>
~IF［
%~node群 は 1 個の`~node$のみからなる
］
⇒
~RET %~node群[ 0 ]
◎
If nodes contains one node, then set node to nodes[0].
</li>
	<li>
%文書片 ~LET 新たな`文書片$
◎
Otherwise, set node to a new DocumentFragment node＼
</li>
	<li>
%文書片 の`~node文書$ ~SET %文書
◎
whose node document is document, and then＼
</li>
	<li>
%~node群 を成す
~EACH( %node )
に対し
⇒
%文書片 に`~nodeを付加する$( %node )
◎
append each node in nodes, if any, to it.
</li>
	<li>
~RET %文書片
◎
Return node.
</li>
</ol>
</div>

！！
interface mixin @@ParentNode {
  [`SameObject$] ~RA $HTMLCollection $children;
  ~RA $Element? $firstElementChild;
  ~RA $Element? $lastElementChild;
  ~RA `unsigned long$ $childElementCount;

  [`CEReactions$, `Unscopable$] $undefined $prepend(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $append(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $replaceChildren(($Node or $DOMString)... %nodes);

  $Element? $querySelector($DOMString %selectors);
  [`NewObject$] $NodeList $querySelectorAll($DOMString %selectors);
};
$Document includes $ParentNode;
$DocumentFragment includes $ParentNode;
$Element includes $ParentNode;
！

<dl class="domintro">
	<dt>%collection = %node . $children</dt>
	<dd>
`子$である`要素$をすべて返す。
◎
Returns the child elements.
</dd>

	<dt>%element = %node . $firstElementChild</dt>
	<dd>
`子$である`要素$のうち，`最初のもの？$を返す。
◎
Returns the first child that is an element; otherwise null.
</dd>

	<dt>%element = %node . $lastElementChild</dt>
	<dd>
 `子$である`要素$のうち，`最後のもの？$を返す。
◎
Returns the last child that is an element; otherwise null.
</dd>

	<dt>%node . $prepend(nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の`最初の子？$の前に挿入する。
◎
Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>

<dd id="cp-throw-if-violate-tree">
`~node~tree$の拘束に反する場合、 `HierarchyRequestError$E が`投出$される。
◎
Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
</dd>

	<dt>%node . $append(nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の`最後の子？$の後に挿入する。
◎
Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->

	<dt>%node . $replaceChildren(nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%node の`子~群$すべてを %nodes で置換する。
◎
Replace all children of node with nodes, while replacing strings in nodes with equivalent Text nodes. 
</dd>
	<!--cp-throw-if-violate-tree-->

	<dt>%node . $querySelector(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する`要素$のうち，`最初のもの？$を返す。
◎
Returns the first element that is a descendant of node that matches selectors.
</dd>

	<dt>%node . $querySelectorAll(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する，すべての`要素$を返す。
◎
Returns all element descendants of node that match selectors.
</dd>
</dl>

<div class="algo">
@children
取得子~手続きは
⇒
~RET 次のように設定された $HTMLCollection `~collection$
⇒＃
`根$cL ~SET コレ,
`~filter$cLは コレの`子$である`要素$のみに合致する
◎
The children getter steps are to return an HTMLCollection collection rooted at this matching only element children.
</div>

<div class="algo">
@firstElementChild
取得子~手続きは
⇒
~RET コレの`子$である`要素$のうち，`最初のもの？$
◎
The firstElementChild getter steps are to return the first child that is an element; otherwise null.
</div>

<div class="algo">
@lastElementChild
取得子~手続きは
⇒
~RET コレの`子$である`要素$のうち，`最後のもの？$
◎
The lastElementChild getter steps are to return the last child that is an element; otherwise null.
</div>

<div class="algo">
@childElementCount
取得子~手続きは
⇒
~RET コレの`子$である`要素$の個数
◎
The childElementCount getter steps are to return the number of children of this that are elements.
</div>

<div class="algo">
<p>
@prepend(nodes)
~method~手続きは：
◎
The prepend(nodes) method steps are:
</p>
<ol>
	<li id="cp-convert-nodes">
%node ~LET
`~node群を~nodeに変換する$( %nodes, コレの`~node文書$ )
◎
Let node be the result of converting nodes into a node given nodes and this’s node document.
</li>
	<li>
コレの中で`~nodeを子の前に前挿入する$( %node, コレの`最初の子？$ )
◎
Pre-insert node into this before this’s first child.
</li>
</ol>
</div>

<div class="algo">
<p>
@append(nodes)
~method~手続きは：
◎
The append(nodes) method steps are:
</p>
<ol>
	<!--cp-convert-nodes-->
	<li>
コレに`~nodeを付加する$( %node )
◎
Append node to this.
</li>
</ol>
</div>

<div class="algo">
<p>
@replaceChildren(nodes)
~method~手続きは：
◎
The replaceChildren(nodes) method steps are:
</p>
<ol>
	<li>
%node ~LET `~node群を~nodeに変換する$( %nodes, コレの`~node文書$ )
◎
Let node be the result of converting nodes into a node given nodes and this’s node document.
</li>
	<li>
%node をコレの中で ~NULL の前に`挿入できるかどうか検証する$
◎
Ensure pre-insertion validity of node into this before null.
</li>
	<li>
コレの`全~内容を~nodeで置換する$( %node )
◎
Replace all with node within this.
</li>
</ol>
</div>

<div class="algo">
@querySelector(selectors)
~method~手続きは
⇒
~RET 次の結果を成す要素のうち，`最初のもの？$
⇒
コレの`視野の下で選択子を照合する$( %selectors )
◎
The querySelector(selectors) method steps are to return the first result of running scope-match a selectors string selectors against this, if the result is not an empty list; otherwise null.
</div>

<div class="algo">
@querySelectorAll(selectors)
~method~手続きは、次の結果を`静的$なものとして返す
⇒
コレの`視野の下で選択子を照合する$( %selectors )
◎
The querySelectorAll(selectors) method steps are to return the static result of running scope-match a selectors string selectors against this.
</div>

			</section>
			<section id="interface-nondocumenttypechildnode">
<h4 title="Mixin NonDocumentTypeChildNode">4.2.7. ^@NonDocumentTypeChildNode ~mixin</h4>

<p class="note">注記：
~Web互換性のため、
$previousElementSibling, $nextElementSibling
属性は，`~doctype$上には（したがって， $ChildNode 上にも）公開できない。
◎
Web compatibility prevents the previousElementSibling and nextElementSibling attributes from being exposed on doctypes (and therefore on ChildNode).
</p>

！！
interface mixin @NonDocumentTypeChildNode {
  ~RA $Element? $previousElementSibling;
  ~RA $Element? $nextElementSibling;
};
$Element includes $NonDocumentTypeChildNode;
$CharacterData includes $NonDocumentTypeChildNode;
！

<dl class="domintro">
	<dt>%element = %node . $previousElementSibling</dt>
	<dd>
`先行-$する`同胞$の`要素$のうち，`最後のもの？$を返す。
◎
Returns the first preceding sibling that is an element; otherwise null.
</dd>

	<dt>%element = %node . $nextElementSibling</dt>
	<dd>
`後続-$する`同胞$の`要素$のうち，`最初のもの？$を返す。
◎
Returns the first following sibling that is an element; otherwise null.
</dd>
</dl>

<div class="algo">
@previousElementSibling
取得子~手続きは
⇒
~RET 次を満たす~nodeのうち，`最後のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`先行-$する
］~AND［
`要素$である
］
◎
The previousElementSibling getter steps are to return the first preceding sibling that is an element; otherwise null.
</div>

<div class="algo">
@nextElementSibling
取得子~手続きは
⇒
~RET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`後続-$する
］~AND［
`要素$である
］
◎
The nextElementSibling getter steps are to return the first following sibling that is an element; otherwise null.
</div>

			</section>
			<section id="interface-childnode">
<h4 title="Mixin ChildNode">4.2.8. ^@ChildNode ~mixin</h4>

！！
interface mixin @ChildNode {
  [`CEReactions$, `Unscopable$] $undefined $before(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $after(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $replaceWith(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $remove();
};
$DocumentType includes $ChildNode;
$Element includes $ChildNode;
$CharacterData includes $ChildNode;
！

<dl class="domintro">
	<dt>%node . $before(...nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の直前に挿入する。
◎
Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $after(...nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の直後に挿入する。
◎
Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $replaceWith(...nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%node を %nodes に置換する。
◎
Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $remove()</dt>
	<dd>
%node を除去する。
◎
Removes node.
</dd>
</dl>

<div class="algo">
<p>
@before(nodes)
~method~手続きは：
◎
The before(nodes) method steps are:
</p>
<ol>
	<li id="cp-let-ctx-parent">
%親 ~LET コレの`親$
◎
Let parent be this’s parent.
</li>
	<li id="cp-exit-if-null-parent">
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
◎
If parent is null, then return.
</li>
	<li>
%およそ前-同胞 ~LET 次を満たす~nodeのうち，`最後のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`先行-$する
］~AND［
~node ~NIN %nodes に与えられた引数の集合
］
◎
Let viablePreviousSibling be this’s first preceding sibling not in nodes; otherwise null.
</li>
	<!--cp-convert-nodes-->
	<li>
%およそ前-同胞 ~SET %およそ前-同胞 に応じて
⇒＃
~NULL ならば %親 の`最初の子？$ ／
~ELSE_ %およそ前-同胞 の`次-同胞？$
◎
If viablePreviousSibling is null, then set it to parent’s first child; otherwise to viablePreviousSibling’s next sibling.
</li>
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %およそ前-同胞 )
◎
Pre-insert node into parent before viablePreviousSibling.
</li>
</ol>
</div>

<div class="algo">
<p>
@after(nodes)
~method~手続きは：
◎
The after(nodes) method steps are:
</p>
<ol>
	<!--cp-let-ctx-parent-->
	<!--cp-exit-if-null-parent-->
	<li id="cp-let-viableNextSibling">
%およそ次-同胞 ~LET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`後続-$する
］~AND［
~node ~NIN %nodes に与えられた引数の集合
］
◎
Let viableNextSibling be this’s first following sibling not in nodes; otherwise null.
</li>
	<!--cp-convert-nodes-->
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %およそ次-同胞 )
◎
Pre-insert node into parent before viableNextSibling.
</li>
</ol>
</div>

<div class="algo">
<p>
@replaceWith(nodes)
~method~手続きは：
◎
The replaceWith(nodes) method steps are:
</p>
<ol>
	<!--cp-let-ctx-parent-->
	<!--cp-exit-if-null-parent-->
	<!--cp-let-viableNextSibling-->
	<!--cp-convert-nodes-->
	<li>
<p>
~IF［
コレの`親$ ~EQ %親
］
⇒
%親 の中で`子を~nodeに置換する$( コレ, %node )
◎
If this’s parent is parent, replace this with node within parent.
</p>

<p class="note">注記：
コレは %node の中に挿入されていることもある。
◎
This could have been inserted into node.
</p>
	</li>
	<li>
~ELSE
⇒
%親 の中で`~nodeを子の前に前挿入する$( %node, %およそ次-同胞 )
◎
Otherwise, pre-insert node into parent before viableNextSibling.
</li>
</ol>
</div>

<div class="algo">
<p>
@remove()
~method~手続きは：
◎
The remove() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`親$ ~EQ ~NULL
］
⇒
~RET
◎
If this’s parent is null, then return.
</li>
	<li>
`~nodeを除去する$( コレ )
◎
Remove this.
</li>
</ol>
</div>

			</section>
			<section id="mixin-slotable">
<h4 title="Mixin Slottable">4.2.9. ^@Slottable ~mixin</h4>

！！
interface mixin @Slottable {
  ~RA $HTMLSlotElement? $assignedSlot;
};

$Element includes $Slottable;
$Text includes $Slottable;
！

<div class="algo">
@assignedSlot
取得子~手続きは
⇒
~RET `~slot可能~用に~slotを見出す$( コレ, `~open^i )
◎
The assignedSlot getter steps are to return the result of find a slot given this and with the open flag set.
</div>

			</section>
			<section id="old-style-collections">
<h4 title="Old-style collections: NodeList and HTMLCollection">4.2.10. 旧式な~collection： ^NodeList と ^HTMLCollection</h4>

<p>
`~collection@
は`~node$の~listを表現する~objである。
`~collection$は
`~live@
にも
`静的@
にもなり得る。
他が言明されない限り、`~collection$は`~live$になるモノトスル。
◎
A collection is an object that represents a list of nodes. A collection can be either live or static. Unless otherwise stated, a collection must be live.
</p>

<p>
`~live$である`~collection$の［
属性／~method
］は、~dataの~snapshotではなく 実際の下層~data†に対し，演算するモノトスル††。
◎
If a collection is live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

<p class="trans-note">【†
すなわち、作成-時の~data（~snapshot）ではなく，~accessされた時点における~data
】【††
従って，~collectionの走査-中に~treeを改変するときは、~collectionの無限増殖に陥いらないよう注意する必要がある。
】【
`静的$とされている場合は，逆に、~dataの~snapshotに対し演算することになる。
】</p>

<div class="p">
<p>
各 `~collection$の作成-時には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`根@cL</dt>
	<dd>
~collectionの視野を与える。
</dd>
	<dt>`~filter@cL</dt>
	<dd>
~nodeが~collectionに含められるための条件を与える。
</dd>
</dl>

◎
When a collection is created, a filter and a root are associated with it.
</div>

<p>
`~collection$は、［
その`根$cLを根とする下位treeの中で，所与の`~filter$cLに合致する`~node$
］のみを含むような~viewを
`表現-@
する。
この~viewは全順序である
— `~collection$に含められる~nodeたちは、他の要件が指定されない限り，`~tree順序$に~sortするモノトスル。
◎
The collection then represents a view of the subtree rooted at the collection’s root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the collection must be sorted in tree order.
</p>

<p class="trans-note">【
ほとんどの~collectionでは，`根$cL自身は`~filter$cLに合致しないが、
$NodeIterator の`反復子~collection$など，そうでないものもある。
】</p>

				<section id="interface-nodelist">
<h5 title="Interface NodeList">4.2.10.1. ^@NodeList ~interface</h5>

<p>
$NodeList ~objは`~node$の`~collection$である。
◎
A NodeList object is a collection of nodes.
</p>

！！
[`Exposed$=Window]
interface @NodeList {
  getter $Node? $item(`unsigned long$ %index);
  ~RA `unsigned long$ $length;
  iterable&lt;$Node&gt;;
};
！

<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`~node$の個数を返す。
◎
Returns the number of nodes in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`~tree順序$に~sortされた下で、`~collection$の中で， %index 番の`~node$を返す。
◎
Returns the node with index index from the collection. The nodes are sorted in tree order.
</dd>
</dl>

<p>
~collection %O が`~supportする~prop~index$は、
0 以上［
%O が`表現-$する~nodeの個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of nodes represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレが`表現-$する~nodeの個数
◎
The length attribute must return the number of nodes represented by the collection.
</div>

<div class="algo">
@item(index)
~method~手続きは
⇒
~RET ［
%index ~NIN { コレが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  コレの中の %index 番の`~node$
］
◎
The item(index) method must return the indexth node in the collection. If there is no indexth node in the collection, then the method must return null.
</div>

				</section>
				<section id="interface-htmlcollection">
<h5 title="Interface HTMLCollection">4.2.10.2. ^@HTMLCollection ~interface</h5>

！！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @HTMLCollection {
  ~RA `unsigned long$ $length;
  getter $Element? $item(`unsigned long$ %index);
  getter $Element? $namedItem($DOMString %name);
};
！

<p>
$HTMLCollection ~objは`要素$の`~collection$である。
◎
An HTMLCollection object is a collection of elements.
</p>

<p class="note">注記：
$HTMLCollection は、歴史的な~~理由から~~廃するわけにいかない所産である。
開発者は それを利用し続けても構わないが、新たな~API標準の設計者は それを利用しないこと（代わりに~IDL <code>$sequence&lt;%T&gt;</code> 型を利用すること）。
◎
HTMLCollection is a historical artifact we cannot rid the web of. While developers are of course welcome to keep using it, new API standard designers ought not to use it (use sequence&lt;T&gt; in IDL instead).
</p>

<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`要素$の個数を返す。
◎
Returns the number of elements in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`要素$たちを`~tree順序$に~sortした下での、`~collection$の中で %index 番の`要素$を返す。
◎
Returns the element with index index from the collection. The elements are sorted in tree order.
</dd>

	<dt>%element = %collection . $namedItem(name)</dt>
	<dt>%element = %collection[%name]</dt>
	<dd>
`~collection$の中で `~ID$ または名前が %name なる最初の`要素$を返す。
◎
Returns the first element with ID or name name from the collection.
</dd>
</dl>

<p>
`~collection$ %O が`~supportする~prop~index$は、
0 以上［
%O が`表現-$する要素の個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of elements represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレが`表現-$する~nodeの個数
◎
The length getter steps are to return the number of nodes represented by the collection.
</div>

<div class="algo">
@item(index)
~method~手続きは
⇒
~RET ［
%index ~NIN { コレが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  コレの中の %index 番の`~node$
］
◎
The item(index) method steps are to return the indexth element in the collection. If there is no indexth element in the collection, then the method must return null.
</div>

<div class="algo">
<p>
`~collection$ %O が`~supportする~prop名$たちは、次の手続きの結果で与えられる：
◎
The supported property names are the values from the list returned by these steps:
</p>
<ol>
	<li>
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
	<li>
<p>
%O が`表現-$する
~EACH( 要素 %要素 )
に対し，`~tree順序$で：
◎
For each element represented by the collection, in tree order:
</p>
		<ol>
			<li>
~IF［
%要素 は `~ID$ %id を持つ
］~AND［
%id ~NIN %結果
］
⇒
%結果 に %id を付加する
◎
If element has an ID which is not in result, append element’s ID to result.
</li>
			<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`属性o~list$内に `name^A `属性o$nmは在る
］~AND［
その属性oの`値$a %name ~NEQ 空~文字列
］~AND［
%name ~NIN %結果
］
⇒
%結果 に %name を付加する
◎
If element is in the HTML namespace and has a name attribute whose value is neither the empty string nor is in result, append element’s name attribute value to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
@namedItem(name)
~method~手続きは：
◎
The namedItem(key) method steps are:
</p>
<ol>
	<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If key is the empty string, return null.
</li>
	<li>
<p>
~RET コレが`表現-$する`要素$たちのうち，次のいずれかを満たす`最初のもの？$：
</p>

		<ul>
			<li>
`~ID$ ~EQ %name
</li>
			<li>
［
`~HTML~ns$に属する
］~AND［
`属性o~list$内に次を満たす属性oが在る
］
⇒
［
`name^A `属性o$nmである
］~AND［
`値$a ~EQ %name
］
</li>
		</ul>
◎
Return the first element in the collection for which at least one of the following is true:
• it has an ID which is key;
• it is in the HTML namespace and has a name attribute whose value is key;
◎
or null if there is no such element.
</li>
</ol>
</div>

				</section>
			</section>
		</section>
		<section id="mutation-observers">
<h3 title="Mutation observers">4.3. 変異~観測器</h3>

<div class="p">
<p>
各 `生成元が類似な~window~agent$ `HTML$r
には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`変異~観測器の小taskは~queueされたか@</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>

	<dt>`変異~観測器~群@</dt>
	<dd>
0 個以上の $MutationObserver ~objからなる`有順序~集合$
— 初期~時は`空$とする。
</dd>
</dl>

◎
Each similar-origin window agent has a mutation observer microtask queued (a boolean), which is initially false. [HTML]
◎
Each similar-origin window agent also has mutation observers (a set of zero or more MutationObserver objects), which is initially empty.
</div>

<div class="algo">
<p>
`変異~観測器 小taskを~queueする@
ときは、次を走らす：
◎
To queue a mutation observer microtask, run these steps:
</p>
<ol>
	<li>
~IF［
`~surrounding~agent$の`変異~観測器の小taskは~queueされたか$ ~EQ ~T
］
⇒
~RET
◎
If the surrounding agent’s mutation observer microtask queued is true, then return.
</li>
	<li>
`~surrounding~agent$の`変異~観測器の小taskは~queueされたか$ ~SET ~T
◎
Set the surrounding agent’s mutation observer microtask queued to true.
</li>
	<li>
次を走らす`小taskを~queueする$
⇒
`変異~観測器に通知する$
◎
Queue a microtask to notify mutation observers.
</li>
</ol>
</div>

<div class="algo">
<p>
`変異~観測器に通知する@
ときは、次を走らす：
◎
To notify mutation observers, run these steps:
</p>
<ol>
	<li>
`~surrounding~agent$の`変異~観測器の小taskは~queueされたか$ ~SET ~F
◎
Set the surrounding agent’s mutation observer microtask queued to false.
</li>
	<li>
%通知-集合 ~LET `~surrounding~agent$の`変異~観測器~群$を`~cloneする$
◎
Let notifySet be a clone of the surrounding agent’s mutation observers.
</li>
	<li>
%通達~slot集合 ~LET `~surrounding~agent$の`通達~slot群$を`~cloneする$
◎
Let signalSet be a clone of the surrounding agent’s signal slots.
</li>
	<li>
`~surrounding~agent$の`通達~slot群$を`空にする$
◎
Empty the surrounding agent’s signal slots.
</li>
	<li>
<p>
%通知-集合 を成す
~EACH( %MO )
に対し：
◎
For each mo of notifySet:
</p>
		<ol>
			<li>
%記録たち ~LET %MO の`記録~queue$moを`~cloneする$
◎
Let records be a clone of mo’s record queue.
</li>
			<li>
%MO の`記録~queue$moを`空にする$
◎
Empty mo’s record queue.
</li>
			<li>
%MO の`~node~list$moを成す
~EACH( %~node )
に対し
⇒
%~node の`登録-済み観測器~list$から 次を満たす`一時~登録-済み観測器$をすべて`除去する$
⇒
その`観測器$ob ~EQ %MO
◎
For each node of mo’s node list, remove all transient registered observers whose observer is mo from node’s registered observer list.
</li>
			<li>
~IF［
%記録たち は`空$でない
］
⇒
`~callback関数を呼出す$( %MO の`~callback$mo, « %記録たち, %MO », %MO )
⇒
例外が投出されたときは、~catchして
⇒
その`例外を報告する$
◎
If records is not empty, then invoke mo’s callback with « records, mo », and mo. If this throws an exception, catch it, and report the exception.
</li>
		</ol>
	</li>
	<li>
%通達~slot集合 を成す
~EACH( `~slot$ %~slot )
に対し
⇒
`~eventを発火する$( %~slot, `slotchange$et )
— 次のように初期化して
⇒
$Event.bubbles 属性 ~SET ~T
◎
For each slot of signalSet, fire an event named slotchange, with its bubbles attribute set to true, at slot.
</li>
</ol>
</div>

<hr>

<p>
各 `~node$には、
`登録-済み観測器~list@
が結付けられる
— それは、 0 個~以上の`登録-済み観測器$からなる`~list$であり，初期~時には`空$とする。
【この~nodeにおける変異を観測している観測器たちを表す。】
◎
Each node has a registered observer list (a list of zero or more registered observers), which is initially empty.
</p>

<div class="p">
<p>
各
`登録-済み観測器@
は、次に挙げるものからなる：
</p>

<dl class="def-list">
	<dt>`観測器@ob</dt>
	<dd>
$MutationObserver ~obj。
</dd>

	<dt>`~option群@ob</dt>
	<dd>
$MutationObserverInit 辞書。
</dd>
</dl>

◎
A registered observer consists of an observer (a MutationObserver object) and options (a MutationObserverInit dictionary).
</div>

<div class="p">
<p>
`一時~登録-済み観測器@
は、上述に加えて 次に挙げるものも持つ，`登録-済み観測器$である：
</p>

<dl class="def-list">
	<dt>`~source@ob</dt>
	<dd>
`登録-済み観測器$。
</dd>
</dl>

◎
A transient registered observer is a registered observer that also consists of a source (a registered observer).
</div>

<p class="note">注記：
`一時~登録-済み観測器$は、所与の`~node$に対し，それが除去された後も`~node$の`子孫$における変異を追跡するために利用される
— これにより、`~node$の`親$にて $MutationObserverInit.subtree が ~T に設定されているときでも，それらの変異は失われずに済む。
◎
Transient registered observers are used to track mutations within a given node’s descendants after node has been removed so they do not get lost when subtree is set to true on node’s parent.
</p>

			<section id="interface-mutationobserver">
<h4 title="Interface MutationObserver">4.3.1. ^@MutationObserver ~interface</h4>

！！
[`Exposed$=Window]
interface @MutationObserver {
  `MutationObserver$mc($MutationCallback %callback);

  $undefined $observe($Node %target, optional $MutationObserverInit %options = {});
  $undefined $disconnect();
  $sequence&lt;$MutationRecord&gt; $takeRecords();
};

callback @MutationCallback = $undefined ($sequence&lt;$MutationRecord&gt; %mutations, $MutationObserver %observer);

dictionary @@MutationObserverInit {
  $boolean @childList = false;
  $boolean @attributes;
  $boolean @characterData;
  $boolean @subtree = false;
  $boolean @attributeOldValue;
  $boolean @characterDataOldValue;
  $sequence&lt;$DOMString&gt; @attributeFilter;
};
！

<!-- ^@MutationObserver -->
<p>
$MutationObserver ~objを利用すれば、`~node$が成す`~tree$における変異を観測できる。
◎
A MutationObserver object can be used to observe mutations to the tree of nodes.
</p>

<p>
各 $MutationObserver ~objには、次の概念が結付けられる：
◎
Each MutationObserver object has these associated concepts:
</p>

<dl class="def-list">
	<dt>`~callback@mo</dt>
	<dd>
~callback関数。
~objの作成-時に設定される。
◎
A callback set on creation.
</dd>

	<dt>`~node~list@mo</dt>
	<dd>
0 個以上の`~node$からなる`~list$。
初期~時は`空$とする。
◎
A node list (a list of nodes), which is initially empty.
</dd>

	<dt>`記録~queue@mo</dt>
	<dd>
0 個以上の $MutationRecord ~objからなる`~queue$
— 初期~時は`空$とする。
◎
A record queue (a queue of zero or more MutationRecord objects), which is initially empty.
</dd>
</dl>

<dl class="domintro">
	<dt>%observer = $MutationObserver(callback)</dt>
	<dd>
$MutationObserver ~objを構築し，その`~callback$moを %callback に設定する。
%callback は、その 1 個目, 2 個目の引数に
( $MutationRecord ~objの~list, 構築された %observer )
が渡されて呼出される。
%callback は、 $observe() ~methodにより登録-済みにされた`~node$が変異したとき（した後）に，呼出される。
◎
Constructs a MutationObserver object and sets its callback to callback. The callback is invoked with a list of MutationRecord objects as first argument and the constructed MutationObserver object as second argument. It is invoked after nodes registered with the observe() method, are mutated.
</dd>

	<dt>%observer . $observe(target, options)</dt>
	<dd>
%target （ `~node$ ）を観測して，
%options （ ~obj）に与えた判定基準に基づいて変異を報告するよう、~UAに指図する。
◎
Instructs the user agent to observe a given target (a node) and report any mutations based on the criteria given by options (an object).
</dd>
	<dd>
<p>
%options 引数に与えた~objの各~memberを介して，観測させる変異についての~optionを設定できる。
利用できる~obj~memberは：
◎
The options argument allows for setting mutation observation options via object members. These are the object members that can be used:
</p>

<!-- ^@MutationObserverInit -->
		<dl>
			<dt>$childList</dt>
			<dd>
%target の`子~群$の変異を観測するときは、
~T にする。
◎
Set to true if mutations to target’s children are to be observed.
</dd>

			<dt>$attributes</dt>
			<dd>
%target の`属性o$の変異を観測するときは、
~T にする。
$attributeOldValue または $attributeFilter を指定している場合は、省略できる。
◎
Set to true if mutations to target’s attributes are to be observed. Can be omitted if attributeOldValue or attributeFilter is specified.
</dd>

			<dt>$characterData</dt>
			<dd>
%target の`~data$の変異を観測するときは、
~T にする。
$characterDataOldValue を指定している場合は、省略できる。
◎
Set to true if mutations to target’s data are to be observed. Can be omitted if characterDataOldValue is specified.
</dd>

			<dt>$subtree</dt>
			<dd>
%target のみならず，
%target の`子孫$の変異も観測するときは、
~T にする。
◎
Set to true if mutations to not just target, but also target’s descendants are to be observed.
</dd>

			<dt>$attributeOldValue</dt>
			<dd>
$attributes を~T にしているか省略していて，かつ
変異~前の %target の`属性o$ `値$aを記録しておく必要がある場合は、
~T にする。
◎
Set to true if attributes is true or omitted and target’s attribute value before the mutation needs to be recorded.
</dd>

			<dt>$characterDataOldValue</dt>
			<dd>
$characterData を~T にしているか省略していて，かつ
変異~前の %target の`~data$を記録しておく必要がある場合は、
~T にする。
◎
Set to true if characterData is set to true or omitted and target’s data before the mutation needs to be recorded.
</dd>

			<dt>$attributeFilter</dt>
			<dd>
$attributes を ~T にしているか省略していて，かつ
すべての`属性o$の変異を観測する必要はない場合は、必要な`属性o$の（`~ns$a のない）`局所~名$aの~listを与える。
◎
Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted.
</dd>

		</dl>
	</dd>

<!-- ^@MutationObserver-->

	<dt>%observer . $disconnect()</dt>
	<dd>
%observer による変異の観測を停止する。
$observe() ~methodが再び利用されるまで，
%observer の`~callback$moは呼出されないことになる。
◎
Stops observer from observing any mutations. Until the observe() method is used again, observer’s callback will not be invoked.
</dd>

	<dt>%observer . $takeRecords()</dt>
	<dd>
`記録~queue$moを空にして，空にする前の内容を返す。
◎
Empties the record queue and returns what was in there.
</dd>
</dl>

<div class="algo">
<p>
@MutationObserver(callback)
構築子~手続きは：
◎
The new MutationObserver(callback) constructor steps are:
</p>
<ol>
	<li>
コレの`~callback$mo ~SET %callback
◎
Set this’s callback to callback.
</li>
	<li>
［
コレに`関連な~agent$の`変異~観測器~群$
］にコレを`付加する$set
◎
Append this to this’s relevant agent’s mutation observers.
</li>
</ol>
</div>

<div class="algo">
<p>
@observe(target, options)
~method~手続きは：
◎
The observe(target, options) method steps are:
</p>
<!-- ^@MutationObserverInit -->
<ol>
	<li>
~IF［［
%options[ "$attributeOldValue" ] ~NEQ ε
］~OR［
%options[ "$attributeFilter" ] ~NEQ ε
］］~AND［
%options[ "$attributes" ] ~EQ ε
］
⇒
%options[ "$attributes" ] ~SET ~T
◎
If either options["attributeOldValue"] or options["attributeFilter"] exists, and options["attributes"] does not exist, then set options["attributes"] to true.
</li>
	<li>
~IF［
%options[ "$characterDataOldValue" ] ~NEQ ε
］~AND［
%options[ "$characterData" ] ~EQ ε
］
⇒
%options[ "$characterData" ] ~SET ~T
◎
If options["characterDataOldValue"] exists and options["characterData"] does not exist, then set options["characterData"] to true.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `TypeError$E ：
◎
↓</p>
		<ul>
			<li>
［
%options[ "$childList" ] ~EQ ~F
］~AND［
%options[ "$attributes" ] ~EQ ~F
］~AND［
%options[ "$characterData" ] ~EQ ~F
］
◎
If none of options["childList"], options["attributes"], and options["characterData"] is true, then throw a TypeError.
</li>
			<li>
［
%options[ "$attributeOldValue" ] ~EQ ~T
］~AND［
%options[ "$attributes" ] ~EQ ~F
］
◎
If options["attributeOldValue"] is true and options["attributes"] is false, then throw a TypeError.
</li>
			<li>
［
%options[ "$attributeFilter" ] ~NEQ ε
］~AND［
%options[ "$attributes" ] ~EQ ~F
］
◎
If options["attributeFilter"] is present and options["attributes"] is false, then throw a TypeError.
</li>
			<li>
［
%options[ "$characterDataOldValue" ] ~EQ ~T
］~AND［
%options[ "$characterData" ] ~EQ ~F
］
◎
If options["characterDataOldValue"] is true and options["characterData"] is false, then throw a TypeError.
</li>
		</ul>
	</li>
	<li>
%登録-済み~list ~LET %target の`登録-済み観測器~list$内の次を満たす`登録-済み観測器$からなる~list
⇒
その`観測器$ob ~EQ コレ
◎
For each registered of target’s registered observer list, if registered’s observer is this:
</li>
	<li>
<p>
%登録-済み~list を成す
~EACH( %登録-済み )
に対し：
◎
↑</p>
		<ol>
			<li>
コレの`~node~list$moを成す
~EACH( %~node )
に対し
⇒
%~node の`登録-済み観測器~list$から 次を満たす`一時~登録-済み観測器$をすべて`除去する$
⇒
その`~source$ob ~EQ %登録-済み
◎
For each node of this’s node list, remove all transient registered observers whose source is registered from node’s registered observer list.
</li>
			<li>
%登録-済み の`~option群$ob ~SET %options
◎
Set registered’s options to options.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%登録-済み~list は`空$である
］：
◎
Otherwise:
</p>
		<ol>
			<li>
%target の`登録-済み観測器~list$に［
次のように設定された新たな`登録-済み観測器$
］を`付加する$
⇒＃
`観測器$ob ~SET コレ,
`~option群$ob ~SET %options
◎
Append a new registered observer whose observer is this and options is options to target’s registered observer list.
</li>
			<li>
コレの`~node~list$moに %target を`付加する$
◎
Append target to this’s node list.
</li>
		</ol>
	</li>
</ol>
</div>

<!-- ^@MutationObserver -->
<div class="algo">
<p>
@disconnect()
~method~手続きは：
◎
The disconnect() method steps are:
</p>
<ol>
	<li>
コレの`~node~list$moを成す
~EACH( %~node )
に対し
⇒
%~node の`登録-済み観測器~list$から，次を満たす`登録-済み観測器$をすべて除去する
⇒
その`観測器$ob ~EQ コレ
◎
For each node of this’s node list, remove any registered observer from node’s registered observer list for which this is the observer.
</li>
	<li>
コレの`記録~queue$moを`空にする$
◎
Empty this’s record queue.
</li>
</ol>
</div>

<div class="algo">
<p>
@takeRecords()
~method~手続きは：
◎
The takeRecords() method steps are:
</p>
<ol>
	<li>
%記録たち ~LET コレの`記録~queue$moを`~cloneする$
◎
Let records be a clone of this’s record queue.
</li>
	<li>
コレの`記録~queue$moを`空にする$
◎
Empty this’s record queue.
</li>
	<li>
~RET %記録たち
◎
Return records.
</li>
</ol>
</div>

			</section>
			<section id="queueing-a-mutation-record">
<h4 title="Queuing a mutation record">4.3.2. 変異~記録を~queueする</h4>

<div class="algo">
<p>
%~target 用に ある %種別 の
`変異~記録を~queueする@
ときは、所与の
(
%名前, %~ns, %旧-値,
%追加-済み~node群, %除去-済み~node群, %前-同胞, %次-同胞
)
に対し，次を走らす：
◎
To queue a mutation record of type for target with name, namespace, oldValue, addedNodes, removedNodes, previousSibling, and nextSibling, run these steps:
</p>
<ol>
	<li>
%有関係~観測器たち ~LET 新たな`~map$
◎
Let interestedObservers be an empty map.
</li>
	<li>
%nodes ~LET %~target のすべての`広義-先祖$
◎
Let nodes be the inclusive ancestors of target.
</li>
	<li>
<p>
%nodes を成す
~EACH( %node )
に対し
【順序は？】
⇒
%node の`登録-済み観測器~list$を成す
~EACH( %登録-済み )
に対し：
◎
For each node in nodes, and then for each registered of node’s registered observer list:
</p>
		<ol>
			<li>
%options ~LET %登録-済み の`~option群$ob
◎
Let options be registered’s options.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If none of the following are true
</p>
<!-- ^@MutationObserverInit -->
				<ul>
					<li>
［
%node ~NEQ %~target
］~AND［
%options[ "$subtree" ] ~EQ ~F
］
◎
node is not target and options["subtree"] is false
</li>
					<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options[ "$attributes" ] ~NEQ ~T
］
◎
type is "attributes" and options["attributes"] either does not exist or is false
</li>
					<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options[ "$attributeFilter" ] ~NEQ ε
］~AND［［
%名前 ~NIN %options[ "$attributeFilter" ]
］~OR［
%~ns ~NEQ ~NULL
］］
◎
type is "attributes", options["attributeFilter"] exists, and options["attributeFilter"] does not contain name or namespace is non-null
</li>
					<li>
［
%種別 ~EQ `characterData^l
］~AND［
%options[ "$characterData" ] ~NEQ ~T
］
◎
type is "characterData" and options["characterData"] either does not exist or is false
</li>
					<li>
［
%種別 ~EQ `childList^l
］~AND［
%options[ "$childList" ] ~EQ ~F
］
◎
type is "childList" and options["childList"] is false 
</li>
				</ul>
<p>
…ならば
⇒
~CONTINUE
◎
then:
</p>
			</li>
			<li>
%MO ~LET %登録-済み の`観測器$ob
◎
Let mo be registered’s observer.
</li>
			<li>
~IF［
%有関係~観測器たち[ %MO ] ~EQ ε
］
⇒
%有関係~観測器たち[ %MO ] ~SET ~NULL
◎
If interestedObservers[mo] does not exist, then set interestedObservers[mo] to null.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If either＼
</p>
				<ul>
					<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options[ "$attributeOldValue" ] ~EQ ~T
］
◎

type is "attributes" and options["attributeOldValue"] is true,＼
</li>
					<li>
［
%種別 ~EQ `characterData^l
］~AND［
%options[ "$characterDataOldValue" ] ~EQ ~T
］
◎
or type is "characterData" and options["characterDataOldValue"] is true,＼
</li>
				</ul>
<p>
…ならば
⇒
%有関係~観測器たち[ %MO ] ~SET %旧-値
◎
then set interestedObservers[mo] to oldValue.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
%有関係~観測器たち を成す
~EACH( %観測器 → %~map先の旧-値 )
に対し
⇒
%観測器 の`記録~queue$moに［
次のように設定された新たな $@MutationRecord ~obj
］を`~enqueueする$
⇒＃
$type ~SET %種別,
$target ~SET %~target,
$attributeName ~SET %名前,
$attributeNamespace ~SET %~ns,
$oldValue ~SET %~map先の旧-値,
$addedNodes ~SET %追加-済み~node群,
$removedNodes ~SET %除去-済み~node群,
$previousSibling ~SET %前-同胞,
$nextSibling ~SET %次-同胞,
◎
For each observer → mappedOldValue of interestedObservers:
• Let record be a new MutationRecord object with its type set to type, target set to target, attributeName set to name, attributeNamespace set to namespace, oldValue set to mappedOldValue, addedNodes set to addedNodes, removedNodes set to removedNodes, previousSibling set to previousSibling, and nextSibling set to nextSibling.
• Enqueue record to observer’s record queue.
</li>
	<li>
`変異~観測器 小taskを~queueする$
◎
Queue a mutation observer microtask.
</li>
</ol>
</div>

<div class="algo">
<p>
%~target 用に
`~tree変異~記録を~queueする@
ときは、所与の
( %追加-済み~node群, %除去-済み~node群, %前-同胞, %次-同胞 )
に対し，次を走らす：
◎
To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and nextSibling, run these steps:
</p>
<ol>
	<li>
~Assert：
［
%追加-済み~node群 は`空$でない
］~OR［
%除去-済み~node群 は`空$でない
］
◎
Assert: either addedNodes or removedNodes is not empty.
</li>
	<li>
%~target 用に種別 `childList^l の`変異~記録を~queueする$( 次に挙げる引数 )
⇒＃
~NULL,
~NULL,
~NULL,
%追加-済み~node群,
%除去-済み~node群,
%前-同胞,
%次-同胞
◎
Queue a mutation record of "childList" for target with null, null, null, addedNodes, removedNodes, previousSibling, and nextSibling.
</li>
</ol>
</div>

			</section>
			<section id="interface-mutationrecord">
<h4 title="Interface MutationRecord">4.3.3. ^@MutationRecord ~interface</h4>

！！
[`Exposed$=Window]
interface @MutationRecord {
  ~RA $DOMString $type;
  [`SameObject$] ~RA $Node $target;
  [`SameObject$] ~RA $NodeList $addedNodes;
  [`SameObject$] ~RA $NodeList $removedNodes;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;
  ~RA $DOMString? $attributeName;
  ~RA $DOMString? $attributeNamespace;
  ~RA $DOMString? $oldValue;
};
！

<dl class="domintro">
	<dt>%record . $type</dt>
	<dd>
変異の種類に応じて，次を返す
⇒＃
`属性o$に対する変異であった場合は `attributes^l,
$CharacterData `~node$に対する変異であった場合は `characterData^l,
`~node$が成す`~tree$に対する変異であった場合は `childList^l
◎
Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to a CharacterData node. And "childList" if it was a mutation to the tree of nodes.
</dd>

	<dt>%record . $target</dt>
	<dd>
変異に影響された`~node$を返す — $type に応じて
⇒＃
`attributes^l に対しては，`属性o$が変化した`要素$ ／
`characterData^l に対しては，$CharacterData `~node$ ／
`childList^l に対しては，`子~群$が変化した`~node$
◎
Returns the node the mutation affected, depending on the type. For "attributes", it is the element whose attribute changed. For "characterData", it is the CharacterData node. For "childList", it is the node whose children changed.
</dd>

	<dt>%record . $addedNodes</dt>
	<dt>%record . $removedNodes</dt>
	<dd>
順に、［
追加-, 除去-
］された`~node$の~listを返す。
◎
Return the nodes added and removed respectively.
</dd>

	<dt>%record . $previousSibling</dt>
	<dt>%record . $nextSibling</dt>
	<dd>
順に、追加-または除去された`~node$が在れば その［
`前-同胞？$, `次-同胞？$
］を,
無ければ ~NULL を返す。
◎
Return the previous and next sibling respectively of the added or removed nodes; otherwise null.
</dd>

	<dt>%record . $attributeName</dt>
	<dd>
変化した`属性o$が在れば その`局所~名$aを,
無ければ ~NULL を返す。
◎
Returns the local name of the changed attribute; otherwise null.
</dd>

	<dt>%record . $attributeNamespace</dt>
	<dd>
変化した`属性o$が在れば その`~ns$を,
無ければ ~NULL を返す。
◎
Returns the namespace of the changed attribute; otherwise null.
</dd>

	<dt>%record . $oldValue</dt>
	<dd>
$type に応じて，次の値を返す
⇒＃
`attributes^l に対しては，変化した`属性o$の変化~前の`値$a。
`characterData^l に対しては，変化した`~node$の変化~前の`~data$。
`childList^l に対しては， ~NULL 。
◎
The return value depends on type. For "attributes", it is the value of the changed attribute before the change. For "characterData", it is the data of the changed node before the change. For "childList", it is null.
</dd>
</dl>

<div class="algo">
次に挙げる属性の取得子~手続きは、各自の初期化-時の値を返す
⇒＃
@type,
@target,
@addedNodes,
@removedNodes,
@previousSibling,
@nextSibling,
@attributeName,
@attributeNamespace,
@oldValue
◎
The type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, and oldValue attributes must return the values they were initialized to.
</div>

			</section>
			<section id="garbage-collection">
<h4 title="Garbage collection">4.3.4. ~garbage収集</h4>

<p>
所与の［
`~node$ %~node,
%~node の`登録-済み観測器~list$に含まれる各`登録-済み観測器$ %登録-済み観測器
］に対しては
⇒＃
%~node は %登録-済み観測器 への強い参照を持つ ／
%登録-済み観測器 は %~node への弱い参照を持つ
◎
Nodes have a strong reference to registered observers in their registered observer list.
◎
Registered observers in a node’s registered observer list have a weak reference to the node.
</p>

			</section>
		</section>
		<section id="interface-node">
<h3 title="Interface Node">4.4. ^@Node ~interface</h3>

！！
[`Exposed$=Window]
interface @Node : $EventTarget {
  const `unsigned short$ @ELEMENT_NODE = 1;
  const `unsigned short$ @ATTRIBUTE_NODE = 2;
  const `unsigned short$ @TEXT_NODE = 3;
  const `unsigned short$ @CDATA_SECTION_NODE = 4;
  const `unsigned short$ @ENTITY_REFERENCE_NODE = 5; // <!--cp-legacy-->
  const `unsigned short$ @ENTITY_NODE = 6; // <!--cp-legacy-->
  const `unsigned short$ @PROCESSING_INSTRUCTION_NODE = 7;
  const `unsigned short$ @COMMENT_NODE = 8;
  const `unsigned short$ @DOCUMENT_NODE = 9;
  const `unsigned short$ @DOCUMENT_TYPE_NODE = 10;
  const `unsigned short$ @DOCUMENT_FRAGMENT_NODE = 11;
  const `unsigned short$ @NOTATION_NODE = 12; // <!--cp-legacy-->
  ~RA `unsigned short$ $nodeType;
  ~RA $DOMString $nodeName;

  ~RA $USVString $baseURI;

  ~RA $boolean $isConnected;
  ~RA $Document? $ownerDocument;
  $Node $getRootNode(optional $GetRootNodeOptions %options = {});
  ~RA $Node? $parentNode;
  ~RA $Element? $parentElement;
  $boolean $hasChildNodes();
  [`SameObject$] ~RA $NodeList $childNodes;
  ~RA $Node? $firstChild;
  ~RA $Node? $lastChild;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;

  [`CEReactions$] attribute $DOMString? $nodeValue;
  [`CEReactions$] attribute $DOMString? $textContent;
  [`CEReactions$] $undefined $normalize();

  [`CEReactions$, `NewObject$] $Node $cloneNode(optional $boolean %deep = false);
  $boolean $isEqualNode($Node? %otherNode);
  $boolean $isSameNode($Node? %otherNode); // <span class="comment" title="legacy alias of ==="> `===^c 演算子の旧来の別名</span>

  const `unsigned short$ $DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const `unsigned short$ $DOCUMENT_POSITION_PRECEDING = 0x02;
  const `unsigned short$ $DOCUMENT_POSITION_FOLLOWING = 0x04;
  const `unsigned short$ $DOCUMENT_POSITION_CONTAINS = 0x08;
  const `unsigned short$ $DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const `unsigned short$ $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  `unsigned short$ $compareDocumentPosition($Node %other);
  $boolean $contains($Node? %other);

  $DOMString? $lookupPrefix($DOMString? %namespace);
  $DOMString? $lookupNamespaceURI($DOMString? %prefix);
  $boolean $isDefaultNamespace($DOMString? %namespace);

  [`CEReactions$] $Node $insertBefore($Node %node, $Node? %child);
  [`CEReactions$] $Node $appendChild($Node %node);
  [`CEReactions$] $Node $replaceChild($Node %node, $Node %child);
  [`CEReactions$] $Node $removeChild($Node %child);
};

dictionary @@GetRootNodeOptions {
  $boolean @composed = false;
};
！

<p class="note">注記：
$@Node は、すべての`~node$から利用される抽象-~interfaceであり，
その直な~instanceは取得し得ない。
◎
Node is an abstract interface that is used by all nodes. You cannot get a direct instance of it.
</p>

<div class="p">
<p>
各 `~node$には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~node文書@</dt>
	<dd>
`文書$。
作成-時に設定される。
</dd>
</dl>
◎
Each node has an associated node document, set upon creation, that is a document.
</div>

<p class="note">注記：
`~node$の`~node文書$は、`~nodeを受入する$~algoにより変更され得る。
◎
A node’s node document can be changed by the adopt algorithm.
</p>

<p class="trans-note">【
~nodeが`文書~tree内$になくても，結付けられることになる。
】</p>

<div class="algo">
<p>
`~node$ %node の`親~targetを取得する$ときは
⇒
~RET ［
%node の`割当-先~slot$ ~NEQ ~NULL ならば それ ／
~ELSE_ %node の`親$
］
◎
A node’s get the parent algorithm, given an event, returns the node’s assigned slot, if node is assigned; otherwise node’s parent.
</p>

<p class="trans-note">【
`文書$は、~nodeの`親~targetを取得する$~algoを上書きする。
】</p>
</div>

<p class="note">注記：
各`~node$は、`登録-済み観測器~list$も有する。
◎
Each node also has a registered observer list.
</p>

<hr>

<dl class="domintro">
	<dt>%node . $nodeType</dt>
	<dd>
%node の型に応じて，適切な数を返す（括弧内は数-値）
⇒＃
$Element ならば $ELEMENT_NODE (1) ／
$Attr ならば $ATTRIBUTE_NODE (2) ／
`狭義の~Text~node$ならば $TEXT_NODE (3) ／
$CDATASection ならば $CDATA_SECTION_NODE (4) ／
$ProcessingInstruction ならば $PROCESSING_INSTRUCTION_NODE (7) ／
$Comment ならば $COMMENT_NODE (8) ／
$Document ならば $DOCUMENT_NODE (9) ／
$DocumentType ならば $DOCUMENT_TYPE_NODE (10) ／
$DocumentFragment ならば $DOCUMENT_FRAGMENT_NODE (11)
◎
Returns a number appropriate for the type of node, as follows:
◎
Element
• Node . ELEMENT_NODE (1).
Attr
• Node . ATTRIBUTE_NODE (2).
An exclusive Text node
• Node . TEXT_NODE (3).
CDATASection
• Node . CDATA_SECTION_NODE (4).
ProcessingInstruction
• Node . PROCESSING_INSTRUCTION_NODE (7).
Comment
• Node . COMMENT_NODE (8).
Document
• Node . DOCUMENT_NODE (9).
DocumentType
• Node . DOCUMENT_TYPE_NODE (10).
DocumentFragment
• Node . DOCUMENT_FRAGMENT_NODE (11).
</dd>

	<dt>%node . $nodeName</dt>
	<dd>
%node の型に応じて，適切な文字列を返す
⇒＃
$Element ならば %node の`~HTML大文字~化~有修飾~名$ ／
$Attr ならば %node の`有修飾~名$a ／
`狭義の~Text~node$ならば `#text^l ／
$CDATASection ならば `#cdata-section^l ／
$ProcessingInstruction ならば %node の`~target$pI ／
$Comment ならば `#comment^l ／
$Document ならば `#document^l ／
$DocumentType ならば %node の`名前$dT ／
$DocumentFragment ならば `#document-fragment^l
◎
Returns a string appropriate for the type of node, as follows:
◎
Element
• Its HTML-uppercased qualified name.
Attr
• Its qualified name.
An exclusive Text node
• "#text".
CDATASection
• "#cdata-section".
ProcessingInstruction
• Its target.
Comment
• "#comment".
Document
• "#document".
DocumentType
• Its name.
DocumentFragment
• "#document-fragment".
</dd>
</dl>

<div class="algo">
@nodeType
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて（括弧内は数-値）
⇒＃
$Element ならば $ELEMENT_NODE (1) ／
$Attr ならば $ATTRIBUTE_NODE (2) ／
`狭義の~Text~node$ならば $TEXT_NODE (3) ／
$CDATASection ならば $CDATA_SECTION_NODE (4) ／
$ProcessingInstruction ならば $PROCESSING_INSTRUCTION_NODE (7) ／
$Comment ならば $COMMENT_NODE (8) ／
$Document ならば $DOCUMENT_NODE (9) ／
$DocumentType ならば $DOCUMENT_TYPE_NODE (10) ／
$DocumentFragment ならば $DOCUMENT_FRAGMENT_NODE (11)
◎
The nodeType getter steps are to return the first matching statement, switching on the interface this implements:
◎
Element
• ELEMENT_NODE (1) 
Attr
• ATTRIBUTE_NODE (2);
An exclusive Text node
• TEXT_NODE (3);
CDATASection
• CDATA_SECTION_NODE (4);
ProcessingInstruction
• PROCESSING_INSTRUCTION_NODE (7);
Comment
• COMMENT_NODE (8);
Document
• DOCUMENT_NODE (9);
DocumentType
• DOCUMENT_TYPE_NODE (10);
DocumentFragment
• DOCUMENT_FRAGMENT_NODE (11).
</div>

<div class="algo">
@nodeName
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて：
⇒＃
$Element ならばコレの`~HTML大文字~化~有修飾~名$ ／
$Attr ならばコレの`有修飾~名$a ／
`狭義の~Text~node$ならば `#text^l ／
$CDATASection ならば `#cdata-section^l ／
$ProcessingInstruction ならばコレの`~target$pI ／
$Comment ならば `#comment^l ／
$Document ならば `#document^l ／
$DocumentType ならばコレの`名前$dT ／
$DocumentFragment ならば `#document-fragment^l
◎
The nodeName getter steps are to return the first matching statement, switching on the interface this implements:
◎
Element
• Its HTML-uppercased qualified name.
Attr
• Its qualified name.
An exclusive Text node
• "#text".
CDATASection
• "#cdata-section".
ProcessingInstruction
• Its target.
Comment
• "#comment".
Document
• "#document".
DocumentType
• Its name.
DocumentFragment
• "#document-fragment".
</div>

<dl class="domintro">
	<dt>%node . $baseURI</dt>
	<dd>
%node の`~node文書$の`文書~基底~URL$を返す。
◎
Returns node’s node document’s document base URL.
</dd>
</dl>

<div class="algo">
@baseURI
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレの`~node文書$の`文書~基底~URL$ )
◎
The baseURI getter steps are to return this’s node document’s document base URL, serialized.
</div>

<dl class="domintro">
	<dt>%node . $isConnected</dt>
	<dd>
［
%node は`接続されて$いるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if node is connected; otherwise false.
</dd>

	<dt>%node . $ownerDocument</dt>
	<dd>
`~node文書$を返す。
`文書$に対しては ~NULL を返す。
◎
Returns the node document. Returns null for documents.
</dd>

	<dt>%node . $getRootNode()</dt>
	<dd>
%node の`根$を返す。
◎
Returns node’s root.
</dd>

	<dt>%node . $getRootNode({ composed:true })</dt>
	<dd>
%node の`~shadowも含む根$を返す。
◎
Returns node’s shadow-including root.
</dd>

	<dt>%node . $parentNode</dt>
	<dd>
`親$を返す。
◎
Returns the parent.
</dd>

	<dt>%node . $parentElement</dt>
	<dd>
`親~要素$を返す。
◎
Returns the parent element.
</dd>

	<dt>%node . $hasChildNodes()</dt>
	<dd>
%node が`子$を持つかどうかを返す。
◎
Returns whether node has children.
</dd>

	<dt>%node . $childNodes</dt>
	<dd>
`子~群$を返す。
◎
Returns the children.
</dd>

	<dt>%node . $firstChild</dt>
	<dd>
`最初の子？$を返す。
◎
Returns the first child.
</dd>

	<dt>%node . $lastChild</dt>
	<dd>
`最後の子？$を返す。
◎
Returns the last child.
</dd>

	<dt>%node . $previousSibling</dt>
	<dd>
`前-同胞？$を返す。
◎
Returns the previous sibling.
</dd>

	<dt>%node . $nextSibling</dt>
	<dd>
`次-同胞？$を返す。
◎
Returns the next sibling.
</dd>
</dl>

<div class="algo">
@isConnected
取得子~手続きは
⇒
~RET ［
コレは`接続されて$いるならば ~T ／
~ELSE_ ~F
］
◎
The isConnected getter steps are to return true, if this is connected; otherwise false.
</div>

<div class="algo">
<p>
@ownerDocument
取得子~手続きは
⇒
~RET ［
コレは`文書$である ならば ~NULL ／
~ELSE_ コレの`~node文書$
］
◎
The ownerDocument getter steps are to return null, if this is a document; otherwise this’s node document.
</p>

<p class="note">注記：
`文書$の`~node文書$は，`文書$ 自身である。
すべての`~node$は、どの時点であれ，`~node文書$を持つ。
◎
The node document of a document is that document itself. All nodes have a node document at all times.
</p>
</div>

<div class="algo">
@getRootNode(options)
~method~手続きは
⇒
~RET %options[ "$GetRootNodeOptions.composed" ] に応じて
⇒＃
~T ならば コレの`~shadowも含む根$ ／
~ELSE_ コレの`根$
◎
The getRootNode(options) method steps are to return this’s shadow-including root if options["composed"] is true; otherwise this’s root.
</div>

<div class="algo">
@parentNode
取得子~手続きは
⇒
~RET コレの`親$
◎
The parentNode getter steps are to return this’s parent.
</div>

<div class="algo">
@parentElement
取得子~手続きは
⇒
~RET コレの`親~要素$
◎
The parentElement getter steps are to return this’s parent element.
</div>

<div class="algo">
@hasChildNodes()
~method~手続きは
⇒
~RET コレは`子$を持つならば ~T ／
~ELSE_ ~F
］
◎
The hasChildNodes() method steps are to return true if this has children; otherwise false.
</div>

<div class="algo">
@childNodes
取得子~手続きは
⇒
~RET 次のように設定された $NodeList `~collection$
⇒＃
`根$cL ~SET コレ,
`~filter$cLは コレの`子$のみに合致する
◎
The childNodes getter steps are to return a NodeList rooted at this matching only children.
</div>

<div class="algo">
@firstChild
取得子~手続きは
⇒
~RET コレの`最初の子？$
◎
The firstChild getter steps are to return this’s first child.
</div>

<div class="algo">
@lastChild
取得子~手続きは
⇒
~RET コレの`最後の子？$
◎
The lastChild getter steps are to return this’s last child.
</div>

<div class="algo">
@previousSibling
取得子~手続きは
⇒
~RET コレの`前-同胞？$
◎
The previousSibling getter steps are to return this’s previous sibling.
</div>

<div class="algo">
@nextSibling
取得子~手続きは
⇒
~RET コレの`次-同胞？$
◎
The nextSibling getter steps are to return this’s next sibling.
</div>

<div class="algo">
@nodeValue
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて
⇒＃
$Attr ならばコレの`値$a／
$CharacterData ならばコレの`~data$／
~ELSE_ ~NULL
◎
The nodeValue getter steps are to return the following, switching on the interface this implements:
◎
Attr
• this’s value.
CharacterData
• this’s data.
Otherwise
• Null.
</div>

<div class="algo">
<p>
$nodeValue 設定子~手続きは：
◎
The nodeValue setter steps are to,＼
</p>
<ol>
	<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the given value is null, act as if it was the empty string instead, and then＼
</li>
	<li>
<p>
コレが`実装-$する~interfaceに応じて：
◎
do as described below, switching on the interface this implements:
</p>
		<ul class="switch">
			<li>
$Attr
⇒
`既存の属性o値を設定する$( コレ, %値 )
◎
Attr
• Set an existing attribute value with this and the given value.
</li>
			<li>
$CharacterData
⇒
コレの`~dataを置換する$( 0, コレの`長さ$, %値 )
◎
CharacterData
• Replace data with node this, offset 0, count this’s length, and data the given value.
</li>
			<li>
その他
⇒
何もしない
◎
Otherwise
• Do nothing.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
@textContent
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて
⇒＃
$DocumentFragment ならば コレの`子孫~text内容$／
$Element ならば コレの`子孫~text内容$／
$Attr ならば コレの`値$a／
$CharacterData ならば コレの`~data$／
~ELSE_ ~NULL
◎
The textContent getter steps are to return the following, switching on the interface this implements:
◎
DocumentFragment
Element
• The descendant text content of this.
Attr
• this’s value.
CharacterData
• this’s data.
Otherwise
• Null.
</div>

<div class="algo">
<p>
`~node$ %親 の
`全~内容を文字列に置換する@
ときは、所与の
( 文字列 %文字列 )
に対し，次を走らす：
◎
To string replace all with a string string within a node parent, run these steps:
</p>
<ol>
	<li>
%~node ~LET ~NULL
◎
Let node be null.
</li>
	<li>
~IF［
%文字列 ~NEQ 空~文字列
］
⇒
%~node ~SET `新たな~Text~node$( %文字列, %親 の`~node文書$ )
◎
If string is not the empty string, then set node to a new Text node whose data is string and node document is parent’s node document.
</li>
	<li>
%親 の`全~内容を~nodeで置換する$( %~node )
◎
Replace all with node within parent.
</li>
</ol>
</div>

<div class="algo">
<p>
$textContent 設定子~手続きは：
◎
The textContent setter steps are to,＼
</p>
<ol>
	<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the given value is null, act as if it was the empty string instead, and then＼
</li>
	<li>
<p>
コレが`実装-$する~interfaceに応じて：
◎
do as described below, switching on the interface this implements:
</p>
		<ul class="switch">
			<li>
$DocumentFragment ／ $Element
⇒
コレの`全~内容を文字列に置換する$( 所与の値 )
◎
DocumentFragment
Element
• String replace all with the given value within this.
</li>
			<li>
$Attr
⇒
`既存の属性o値を設定する$( コレ, 所与の値 )
◎
Attr
• Set an existing attribute value with this and the given value.
</li>
			<li>
$CharacterData
⇒
コレの`~dataを置換する$( 0, コレの`長さ$, %値 )
◎
CharacterData
• Replace data with node this, offset 0, count this’s length, and data the given value.
</li>
			<li>
その他【すなわち， $Document ／ $DocumentType 】
⇒
何もしない
◎
Otherwise
• Do nothing.
</li>
		</ul>
	</li>
</ol>
</div>

<dl class="domintro">
	<dt>%node . $normalize()</dt>
	<dd>
%node に含まれている`狭義の~Text~node$のうち［
`長さ$ ~EQ 0
］のものは除去し、`連続的な狭義の~Text~node列$に対しては，その最初の`~node$に~~後続の`~data$を連結してひとまとめにする。
◎
Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes.
</dd>
	<dd class="trans-note">【
この記述は、 “除去-” と “連結-” の順序に関し，微妙に正確aでない
— 実際の~algoでは、空な ^Text ~nodeのうち，［
最初の~node %N が空でないような`連続的な狭義の~Text~node列$
］に含まれるものは、後続の空な ^Text ~nodeより先に %N に連結される（その結果として，除去されるが）。
<!-- 
結果の~node~treeは同じでも，変異の通知-順序は異なり得る。
 -->
】</dd>
</dl>

<div class="algo">
<p>
@normalize()
~method~手続きは：
◎
The normalize() method steps are to run these steps＼
</p>
<ol>
	<li>
<p>
コレの`子孫$である
~EACH( `狭義の~Text~node$ %node )
に対し：
◎
for each descendant exclusive Text node node of this:
</p>

<p class="trans-note">【
~tree順序で。
加えて，~~厳密に言えば、このループの中で~treeから除去される ^Text ~nodeは反復対象から除外する必要もある。
】</p>
		<ol>
			<li>
%長さ ~LET %node の`長さ$
◎
Let length be node’s length.
</li>
			<li>
%長さ ~EQ 0
⇒＃
`~nodeを除去する$( %node )；
~CONTINUE
◎
If length is zero, then remove node and continue with the next exclusive Text node, if any.
</li>
			<li>
%除去対象 ~LET %node を含む`連続的な狭義の~Text~node列$から %node 自身（常に先頭になる）は除外した結果の~list
◎
↓</li>
			<li>
%data ~LET 次を`連結-$した結果
⇒
%除去対象 内のすべての~nodeの`~data$
◎
Let data be the concatenation of the data of node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
			<li>
%node の`~dataを置換する$( %長さ, 0, %data )
◎
Replace data with node node, offset length, count 0, and data data.
</li>
			<li>
<p>
%除去対象 を成す
~EACH( %text )
に対し，順に：
◎
Let currentNode be node’s next sibling.
◎
While currentNode is an exclusive Text node:
</p>
				<ol>
					<li>
<p>
~EACH( `~live範囲o$ %R )
に対し：
◎
↓</p>
						<ol>
							<li>
~IF［
%範囲o の`始端~node$ ~EQ %text
］
⇒＃
%範囲o の`始端~offset$ ~INCBY %長さ；
%範囲o の`始端~node$ ~SET %node
◎
For each live range whose start node is currentNode, add length to its start offset and set its start node to node.
</li>
							<li>
~IF［
%範囲o の`終端~node$ ~EQ %text
］
⇒＃
%範囲o の`終端~offset$ ~INCBY %長さ；
%範囲o の`終端~node$ ~SET %node
◎
For each live range whose end node is currentNode, add length to its end offset and set its end node to node.
</li>
							<li>
~IF［
%範囲o の`始端~node$ ~EQ %text の`親$
］~AND［
%範囲o の`始端~offset$ ~EQ %text の`~index$
］
⇒＃
%範囲o の`始端~node$ ~SET %node；
%範囲o の`始端~offset$ ~SET %長さ
◎
For each live range whose start node is currentNode’s parent and start offset is currentNode’s index, set its start node to node and its start offset to length.
</li>
							<li>
~IF［
%範囲o の`終端~node$ ~EQ %text の`親$
］~AND［
%範囲o の`終端~offset$ ~EQ %text の`~index$
］
⇒＃
%範囲o の`終端~node$ ~SET %node；
%範囲o の`終端~offset$ ~SET %長さ
◎
For each live range whose end node is currentNode’s parent and end offset is currentNode’s index, set its end node to node and its end offset to length.
</li>
						</ol>
					</li>
					<li>
%長さ ~INCBY %text の`長さ$
◎
Add currentNode’s length to length.
◎
Set currentNode to its next sibling.
</li>
				</ol>
			</li>
			<li>
%除去対象 を成す
~EACH( %text )
に対し，順に
⇒
`~nodeを除去する$( %text )
◎
Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
		</ol>
	</li>
</ol>
</div>

<dl class="domintro">
	<dt>%node . $cloneNode([deep = false])</dt>
	<dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>

	<dt>%node . $isEqualNode(otherNode)</dt>
	<dd>
%node と %otherNode が同じ~propを持つかどうかを返す。
◎
Returns whether node and otherNode have the same properties.
</dd>
</dl>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`~clone時の手続き@
を定義してもヨイ。
この~algoは、`~nodeを~cloneする$ ~algo内から，
( %複製, %node, %文書, %子も~cloneするか ~IN { `子も~cloneする^i, ε }（省略時は ε ） )
を渡して呼出される。
◎
Specifications may define cloning steps for all or some nodes. The algorithm is passed copy, node, document, and an optional clone children flag, as indicated in the clone algorithm.
</p>

<p class="note">注記：
~HTMLは
`script$e ／ `input$e
要素~用に`~clone時の手続き$を定義する。
~SVGもその `script^e 要素~用にも同様にされるべきだが、現時点では，呼び出すことはない。
◎
HTML defines cloning steps for script and input elements. SVG ought to do the same for its script elements, but does not call this out at the moment.
</p>

<p class="trans-note">【
同じ~node用に，そのような手続きが（例えば，複数の仕様にて）複数~定義された場合、それらを走らす順序も有意になり得るが，言及されていないので想定されていない（または有意にならない）と見受けられる。
他の “〜時の手続き” （例： `挿入-時の手続き$）も同様。
】</p>

<div class="algo">
<p>
`~nodeを~cloneする@
ときは、所与の
( %node, `文書$ %文書 （省略時は ε ）, %子も~cloneするか ~IN { `子も~cloneする^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To clone a node, with an optional document and clone children flag, run these steps:
</p>
<ol>
	<li>
~IF［
%文書 ~EQ ε
］
⇒
%文書 ~LET %node の`~node文書$
◎
If document is not given, let document be node’s node document.
</li>
	<li>
<p>
~IF［
%node は`要素$である
］：
◎
If node is an element, then:
</p>
		<ol>
			<li>
%複製 ~LET
`要素を作成する$( %文書, %node の`局所~名$, %node の`~ns$, %node の`~ns接頭辞$, %node の`~is0値$ )
◎
Let copy be the result of creating an element, given document, node’s local name, node’s namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements flag unset.
</li>
			<li>
%node の`属性o~list$を成す
~EACH( %属性o )
に対し
⇒
`属性oを付加する$( `~nodeを~cloneする$( %属性o ), %複製 )
◎
For each attribute in node’s attribute list:
• Let copyAttribute be a clone of attribute.
• Append copyAttribute to copy.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
		<ol>
			<li>
%複製 ~LET %node と同じ~interfaceを実装する新たな`~node$
◎
let copy be a node that implements the same interfaces as node, and＼
</li>
			<li>
<p>
%node が`実装-$する~interfaceに応じて，
%複製 を次に従って設定する：
◎
fulfills these additional requirements, switching on the interface node implements:
</p>
				<ul class="switch">
					<li>
$Document
⇒
%複製 の［
`符号化法$doc, `内容~型$doc, `~URL$doc, `生成元$doc, `種別$doc, `~mode$doc
］ ~SET %node のそれら
◎
Document
• Set copy’s encoding, content type, URL, origin, type, and mode to those of node.
</li>
					<li>
$DocumentType
⇒
%複製 の［
`名前$dT,
`~publicID$dT,
`~systemID$dT
］ ~SET %node のそれら
◎
DocumentType
• Set copy’s name, public ID, and system ID to those of node.
</li>
					<li>
$Attr
⇒
%複製 の［
`~ns$a,
`~ns接頭辞$a,
`局所~名$a,
`値$a
］ ~SET %node のそれら
◎
Attr
• Set copy’s namespace, namespace prefix, local name, and value to those of node.
</li>
					<li>
$Text ／
$Comment
⇒
%複製 の`~data$ ~SET %node のそれ
◎
Text
Comment
• Set copy’s data to that of node.
</li>
					<li>
$ProcessingInstruction
⇒
%複製 の［
`~target$pI,
`~data$
］ ~SET %node のそれら
◎
ProcessingInstruction
• Set copy’s target and data to those of node.
</li>
					<li>
その他【すなわち， $DocumentFragment ／ $Element 】
⇒
何もしない
◎
Otherwise
• Do nothing.
</li>
				</ul>
			</li>
		</ol>
	<li>
~IF［
%複製 は`文書$である
］
⇒
%文書 ~SET %複製
◎
↓</li>
	<li>
%複製 の`~node文書$ ~SET %文書
◎
Set copy’s node document and document to copy, if copy is a document, and set copy’s node document to document otherwise.
</li>
	<li>
~IF［
他の`適用-可能な仕様$において %node 用に定義されている`~clone時の手続き$がある
］
⇒
その手続きに
( %複製, %node, %文書, %子も~cloneするか )
を渡して走らす
◎
Run any cloning steps defined for node in other applicable specifications and pass copy, node, document and the clone children flag if set, as parameters.
</li>
	<li>
~IF［
%子も~cloneするか ~EQ `子も~cloneする^i
］
⇒
%node の`子~群$を成す
~EACH( %子 )
に対し
⇒
%複製 に次を付加する
⇒
`~nodeを~cloneする$( %子, %文書, `子も~cloneする^i )
◎
If the clone children flag is set, clone all the children of node and append them to copy, with document as specified and the clone children flag being set.
</li>
	<li>
~RET %複製
◎
Return copy.
</li>
</ol>
</div>

<div class="algo">
<p>
@cloneNode(deep)
~method~手続きは：
◎
The cloneNode(deep) method steps are:
</p>
<ol>
	<li>
~IF［
コレは`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If this is a shadow root, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~RET `~nodeを~cloneする$( コレ, ε, ［
%deep ~EQ ~T ならば `子も~cloneする^i ／
~ELSE_ ε
］ )
◎
Return a clone of this, with the clone children flag set if deep is true.
</li>
</ol>
</div>

<div class="algo">
<p>
2 つの`~node$ %A, %B は、次に挙げるすべての条件を満たすならば，
`同等@
であるとされる。
◎
A node A equals a node B if all of the following conditions are true:
</p>
<ul>
	<li>
%A, %B は同じ~interfaceを`実装-$する
◎
A and B implement the same interfaces.
</li>
	<li>
<p>
%A が`実装-$する~interfaceに応じて，次に挙げるものもすべて同等である：
◎
The following are equal, switching on the interface A implements:
</p>
		<ul class="switch">
			<li>
$DocumentType
⇒
`名前$dT,
`~publicID$dT,
`~systemID$dT
◎
DocumentType
• Its name, public ID, and system ID.
</li>
			<li>
$Element
⇒
`~ns$,
`~ns接頭辞$,
`局所~名$,
`属性o~list$の`~size$
◎
Element
• Its namespace, namespace prefix, local name, and its attribute list’s size.
</li>
			<li>
$Attr
⇒
`~ns$a,
`局所~名$a,
`値$a
◎
Attr
• Its namespace, local name, and value.
</li>
			<li>
$ProcessingInstruction
⇒
`~target$pI,
`~data$
◎
ProcessingInstruction
• Its target and data.
</li>
			<li>
$Text ／ $Comment
⇒
`~data$
◎
Text
Comment
• Its data.
</li>
			<li>
その他【すなわち， $Document, $DocumentFragment 】
⇒
なし
【すなわち，比較するものは無いので無条件（原文には “—” としか記されていないが）。】
◎
Otherwise
• —
</li>
		</ul>
	</li>
	<li>
%A が`要素$である場合に限り
⇒
%A の`属性o~list$内のどの`属性o$ %属性 に対しても
⇒
%B の`属性o~list$内に［
%属性 に`同等$である`属性o$
］が在る
◎
If A is an element, each attribute in its attribute list has an attribute that equals an attribute in B’s attribute list.
</li>
	<li>
%A と %B は同じ個数の`子$を持つ
◎
A and B have the same number of children.
</li>
	<li>
%A のどの`子$も，同じ`~index$に在る %B の`子$に`同等$である
◎
Each child of A equals the child of B at the identical index.
</li>
</ul>
</div>

<div class="algo">
@isEqualNode(otherNode)
~method~手続きは
⇒
~RET 次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%otherNode ~NEQ ~NULL
］~AND［
コレと %otherNode は`同等$である
］
◎
The isEqualNode(otherNode) method steps are to return true if otherNode is non-null and this equals otherNode; otherwise false.
</div>

<div class="algo">
@isSameNode(otherNode)
~method~手続きは
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%otherNode ~EQ コレ
◎
The isSameNode(otherNode) method steps are to return true if otherNode is this; otherwise false.
</div>

<!-- ADD %node →<code >%node</code> -->
<dl class="domintro">
	<dt>%node . $compareDocumentPosition(other)</dt>
	<dd>

<p>
%node に相対的な %other の位置を指示する~bitmaskを返す。
それを成す各~bitは、対応する条件が満たされる場合には， “1” に設定される：
◎
Returns a bitmask indicating the position of other relative to node. These are the bits that can be set:
</p>
		<dl>
			<dt>$Node . $DOCUMENT_POSITION_DISCONNECTED `(1)^i</dt>
			<dd>
%node と %other は同じ`~tree$に属さない。
◎
Set when node and other are not in the same tree.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_PRECEDING `(2)^i</dt>
			<dd>
%other は %node に`先行-$する。
◎
Set when other is preceding node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_FOLLOWING `(4)^i</dt>
			<dd>
%other は %node に`後続-$する。
◎
Set when other is following node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINS `(8)^i</dt>
			<dd>
%other は %node の`先祖$である。
◎
Set when other is an ancestor of node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINED_BY `(16)^i</dt>
			<dd>
%other は %node の`子孫$である。
◎
Set when other is a descendant of node.
</dd>
		</dl>
	</dd>

	<dt>%node . $contains(other)</dt>
	<dd>
%other が %node の`広義-子孫$［
であるならば ~T ／
でないならば ~F
］を返す。
◎
Returns true if other is an inclusive descendant of node; otherwise false.
</dd>
</dl>

<p class="idl-def">
次に挙げるものは
$compareDocumentPosition()
が~bitmaskとして返す定数である（括弧内は数-値）：
◎
These are the constants compareDocumentPosition() returns as mask:
</p>

<ul><li>@DOCUMENT_POSITION_DISCONNECTED (1)
</li><li>@DOCUMENT_POSITION_PRECEDING (2)
</li><li>@DOCUMENT_POSITION_FOLLOWING (4)
</li><li>@DOCUMENT_POSITION_CONTAINS (8)
</li><li>@DOCUMENT_POSITION_CONTAINED_BY (16 ~EQ 0x10)
</li><li>@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC (32 ~EQ 0x20)
</li></ul>

<div class="algo">
<p>
@compareDocumentPosition(other)
~method~手続きは：
◎
The compareDocumentPosition(other) method steps are:
</p>
<ol>
	<li>
~IF［
コレ ~EQ %other
］
⇒
~RET 0
◎
If this is other, then return zero.
</li>
	<li>
( %他~node, %自~node ) ~LET ( %other, コレ )
◎
Let node1 be other and node2 be this.
</li>
	<li>
( %他~属性o, %自~属性o ) ~LET ( ~NULL, ~NULL )
◎
Let attr1 and attr2 be null.
</li>
	<li>
~IF［
%他~node は`属性o$である
］
⇒＃
%他~属性o ~SET %他~node；
%他~node ~SET %他~属性o が`属する要素$
◎
If node1 is an attribute, then set attr1 to node1 and node1 to attr1’s element.
</li>
	<li>
<p>
~IF［
%自~node は`属性o$である
］：
◎
If node2 is an attribute, then:
</p>
		<ol>
			<li>
%自~属性o ~SET %自~node
◎
↓</li>
			<li>
%自~node ~SET %自~属性o が`属する要素$
◎
Set attr2 to node2 and node2 to attr2’s element.
</li>
			<li>
<p>
~IF［
%他~属性o ~NEQ ~NULL
］~AND［
%自~属性o ~NEQ ~NULL
］~AND［
%自~node ~EQ %他~node
］：
◎
If attr1 and node1 are non-null, and node2 is node1, then:
</p>
				<ol>
					<li>
<p>
%自~node の`属性o~list$を成す
~EACH( %属性o )
に対し：
◎
For each attr in node2’s attribute list:
</p>
						<ol>
							<li>
~IF［
( %属性o, %他~属性o )
は`同等$である
］
⇒
~RET 
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_PRECEDING
◎
If attr equals attr1, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.
</li>
							<li>
~IF［
( %属性o, %自~属性o )
は`同等$である
］
⇒
~RET
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_FOLLOWING
◎
If attr equals attr2, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%他~node ~EQ ~NULL
］~OR［
%自~node ~EQ ~NULL
］~OR［
%他~node の`根$ ~NEQ %自~node の`根$
］
⇒
~RET ［
$DOCUMENT_POSITION_DISCONNECTED ~PLUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS ［
$DOCUMENT_POSITION_PRECEDING または $DOCUMENT_POSITION_FOLLOWING
（ただし，いずれが~~選択されるかは一貫するものとする）］
］
◎
If node1 or node2 is null, or node1’s root is not node2’s root, then return the result of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.
</p>

<p class="note">注記：
$DOCUMENT_POSITION_PRECEDING, $DOCUMENT_POSITION_FOLLOWING
のどちらを返すかは，概して~pointer比較を介して実装される。
~JS実装においては `Math.random()^c 値を利用できる。
【理想的には、各~node~treeどうしの順序も循環しないように一貫するべきであろう。】
◎
Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is typically implemented via pointer comparison. In JavaScript implementations a cached Math.random() value can be used.
</p>

	</li>
	<li>
~IF［［
%他~node は %自~node の`先祖$である
］~AND［
%他~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%自~属性o ~NEQ ~NULL
］］
⇒
~RET $DOCUMENT_POSITION_CONTAINS ~PLUS $DOCUMENT_POSITION_PRECEDING
◎
If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
</li>
	<li>
~IF［［
%他~node は %自~node の`子孫$である
］~AND［
%自~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%他~属性o ~NEQ ~NULL
］］
⇒
~RET 
$DOCUMENT_POSITION_CONTAINED_BY ~PLUS $DOCUMENT_POSITION_FOLLOWING
◎
If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
</li>
	<li>
<p>
~IF［
%他~node は %自~node に`先行-$する
］
⇒
~RET $DOCUMENT_POSITION_PRECEDING
◎
If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
</p>

<p class="note">注記：
`属性o$は，自身が`属する要素$と同じ`~tree$には`関与-$しないが、
この~algoに因り［
属性oは，自身が属する要素の`子$に`先行-$する
］ものとされることになる。
◎
Due to the way attributes are handled in this algorithm this results in a node’s attributes counting as preceding that node’s children, despite attributes not participating in the same tree.
</p>
	</li>
	<li>
~RET $DOCUMENT_POSITION_FOLLOWING
◎
Return DOCUMENT_POSITION_FOLLOWING.
</li>
</ol>
</div>

<div class="algo">
@contains(other)
~method~手続きは
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%other はコレの`広義-子孫$である
◎
The contains(other) method steps are to return true if other is an inclusive descendant of this; otherwise false (including when other is null).
</div>

<div class="algo">
<p>
%要素 用の
`~ns接頭辞を~locateする@
ときは、所与の
( %~ns )
に対し，次を走らす：
◎
To locate a namespace prefix for an element using namespace, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 の`~ns$ ~EQ %~ns
］~AND［
%要素 の`~ns接頭辞$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~ns接頭辞$
◎
If element’s namespace is namespace and its namespace prefix is non-null, then return its namespace prefix.
</li>
	<li>
%属性o ~LET %要素 の`属性o~list$内に在る`属性o$のうち，次を満たす`最初のもの？$
⇒
［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`値$a ~EQ %~ns
］
◎
If element has an attribute whose namespace prefix is "xmlns" and value is namespace, then return element’s first such attribute’s local name.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
~RET %属性 の`局所~名$a
◎
↑</li>
	<li>
%親 ~SET %要素 の`親~要素$
◎
↓</li>
	<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
~RET %親 用の`~ns接頭辞を~locateする$( %~ns )
◎
If element’s parent element is not null, then return the result of running locate a namespace prefix on that element using namespace.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
%~node 用の
`~nsを~locateする@
ときは、所与の
( %接頭辞 )
に対し，次を走らす：
◎
To locate a namespace for a node using prefix,＼
</p>
<ol>
	<li>
<p>
~IF［
%~node は $Element を`実装-$する
］：
◎
↓↓switch on the interface node implements:
</p>
		<ol>
			<li>
~IF［
%~node の`~ns$ ~NEQ ~NULL
］~AND［
%~node の`~ns接頭辞$ ~EQ %接頭辞
］
⇒
~RET その`~ns$
◎
If its namespace is non-null and its namespace prefix is prefix, then return namespace.
</li>
			<li>
<p>
%属性o ~LET %~node の`属性o~list$内に在る`属性o$のうち［
%接頭辞 に応じて，次に与える条件
］を満たす`最初のもの？$：
</p>
				<ul class="switch">
					<li>
%接頭辞 ~NEQ ~NULL の場合
⇒
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`局所~名$a ~EQ %接頭辞
］
</li>
					<li>
%接頭辞 ~EQ ~NULL の場合
⇒
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ ~NULL
］~AND［
`局所~名$a ~EQ `xmlns^l
］
</li>
				</ul>
◎
If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is "xmlns", and local name is prefix, or if prefix is null and it has an attribute whose namespace is the XMLNS namespace, namespace prefix is null, and local name is "xmlns",＼
</li>
			<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
~RET ［
%属性o の`値$a ~NEQ 空~文字列 ならばそれ ／
~ELSE_ ~NULL
］
◎
then return its value if it is not the empty string, and null otherwise.
◎
↓If its parent element is null, then return null.
◎
↓Return the result of running locate a namespace on its parent element using prefix.
</li>
		</ol>
	</li>
	<li>
%要素 ~LET %~node が`実装-$する~interfaceに応じて
⇒＃
$Element ならば %~node の`親~要素$ ／
$Document ならば %~node の`文書~要素$ ／
$DocumentType ならば ~NULL ／
$DocumentFragment ならば ~NULL ／
$Attr ならば %~node が`属する要素$ ／
~ELSE_【すなわち， $CharacterData ならば】 %~node の`親~要素$
◎
Document
• If its document element is null, then return null.
• Return the result of running locate a namespace on its document element using prefix.
DocumentType
DocumentFragment
• Return null.
Attr
• If its element is null, then return null.
• Return the result of running locate a namespace on its element using prefix.
Otherwise
• If its parent element is null, then return null.
• Return the result of running locate a namespace on its parent element using prefix.
</li>
	<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
~RET %要素 用の`~nsを~locateする$( %接頭辞 )
◎
↑</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
@lookupPrefix(namespace)
~method~手続きは：
◎
The lookupPrefix(namespace) method steps are:
</p>
<ol>
	<li>
~IF［
%namespace ~IN { ~NULL, 空~文字列 }
］
⇒
~RET ~NULL
◎
If namespace is null or the empty string, then return null.
</li>
	<li>
%要素 ~LET コレが`実装-$する~interfaceに応じて
⇒＃
$Element ならばコレ ／
$Document ならばコレの`文書~要素$ ／
$DocumentType ならば ~NULL ／
$DocumentFragment ならば ~NULL ／
$Attr ならばコレが`属する要素$ ／
~ELSE_【すなわち， $CharacterData ならば】コレの`親~要素$
◎
Switch on the interface this implements:
◎
Element
• Return the result of locating a namespace prefix for it using namespace.
Document
• Return the result of locating a namespace prefix for its document element, if its document element is non-null; otherwise null.
DocumentType
DocumentFragment
• Return null.
Attr
• Return the result of locating a namespace prefix for its element, if its element is non-null; otherwise null.
Otherwise
• Return the result of locating a namespace prefix for its parent element, if its parent element is non-null; otherwise null.
</li>
	<li>
~IF ［
%要素 ~NEQ ~NULL
］
⇒
~RET %要素 用の`~ns接頭辞を~locateする$( %namespace )
◎
↑</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
@lookupNamespaceURI(prefix)
~method~手続きは：
◎
The lookupNamespaceURI(prefix) method steps are:
</p>
<ol>
	<li>
~IF［
%prefix ~EQ 空~文字列
］
⇒
%prefix ~SET ~NULL
◎
If prefix is the empty string, then set it to null.
</li>
	<li>
~RET コレ用の`~nsを~locateする$( %prefix )
◎
Return the result of running locate a namespace for this using prefix.
</li>
</ol>
</div>

<div class="algo">
<p>
@isDefaultNamespace(namespace)
~method~手続きは：
◎
The isDefaultNamespace(namespace) method steps are:
</p>
<ol>
	<li id="cp-normalize-ns0">
~IF［
%namespace ~EQ 空~文字列
］
⇒
%namespace ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>
	<li>
%既定~ns ~LET コレ用の`~nsを~locateする$( ~NULL )
◎
Let defaultNamespace be the result of running locate a namespace for this using null.
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%既定~ns ~EQ %namespace
◎
Return true if defaultNamespace is the same as namespace; otherwise false.
</li>
</ol>
</div>

<div class="algo">
<p>
@insertBefore(node, child)
~method~手続きは
⇒
~RET コレの中で`~nodeを子の前に前挿入する$( %node, %child )
◎
The insertBefore(node, child) method steps are to return the result of pre-inserting node into this before child.
</p>

<p class="trans-note">【
~HTMLの `br^e のような~void要素であっても（あるいは `script^e 要素であっても）、子~nodeを挿入でき，~treeの一部を成すことになる
— より一般には、文書~言語の内容~modelでは許容されなくても，`~node~tree$の拘束に反しない限り挿入できる。
~treeを改変する他の~method（次の $appendChild() など）も同様。
】</p>
</div>

<div class="algo">
@appendChild(node)
~method~手続きは
⇒
~RET コレに`~nodeを付加する$( %node )
◎
The appendChild(node) method steps are to return the result of appending node to this.
</div>

<div class="algo">
@replaceChild(node, child)
~method~手続きは
⇒
~RET コレの中で`子を~nodeに置換する$( %child, %node )
◎
The replaceChild(node, child) method steps are to return the result of replacing child with node within this.
</div>

<div class="algo">
@removeChild(child)
~method~手続きは
⇒
~RET コレから`子を前除去する$( %child )
◎
The removeChild(child) method steps are to return the result of pre-removing child from this.
</div>

<div class="algo">
<p>
`~node$ %根 用の［
%有修飾~名 を
`有修飾~名に持つ要素の~list@
］は、次のように設定された $HTMLCollection を返す：
◎
The list of elements with qualified name qualifiedName for a node root is the HTMLCollection returned by the following algorithm:
</p>

【！＊局所~名 = * の場合でも、根は除外される https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName】

<ul>
	<li>
`根$cL ~SET %根
◎
↓</li>
	<li>
<p>
`~filter$cLは［
%根 の`子孫$である`要素$ %要素 のうち，次のいずれかが満たされるもの
］に合致する：
◎
↓</p>
		<ul>
			<li>
%有修飾~名 ~EQ ~U002A
（この場合、 %要素 は無条件に合致することになる）
◎
If qualifiedName is U+002A (*), then return a HTMLCollection rooted at root, whose filter matches only descendant elements.
</li>
			<li>
<p>
［
%根 の`~node文書$は`~HTML文書$である
］~AND［
次のいずれかが満たされる
］：
◎
Otherwise, if root’s node document is an HTML document, return a HTMLCollection rooted at root, whose filter matches the following descendant elements:
</p>
				<ul>
					<li>
［
`~ns$ ~EQ `~HTML~ns$
］~AND［
%要素 の`有修飾~名$ ~EQ `~ASCII小文字~化する$( %有修飾~名 )
］
◎
Whose namespace is the HTML namespace and whose qualified name is qualifiedName, in ASCII lowercase.
</li>
						<li>
［
`~ns$ ~NEQ `~HTML~ns$
］~AND［
%要素 の`有修飾~名$ ~EQ %有修飾~名
］
◎
Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.
</li>
				</ul>
			</li>
			<li>
%要素 の`有修飾~名$ ~EQ %有修飾~名
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName.
</li>
		</ul>
	</li>
</ul>

<p>
以前の~callと同じ引数で呼出されたときは、
%根 の`~node文書$の`種別$docが変化していない限り，そのときに返したものと同じ $HTMLCollection ~objを返してもヨイ。
◎
When invoked with the same argument, and as long as root’s node document’s type has not changed, the same HTMLCollection object may be returned as returned by an earlier call.
</p>
</div>

<div class="algo">
<p>
`~node$ %根 用の［
( %~ns, %局所~名 )
を
`( ~ns, 局所~名 ) に持つ要素の~list@
］は、次のように設定された $HTMLCollection を返す：
◎
The list of elements with namespace namespace and local name localName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ul>
	<li>
`根$cL ~SET %根
◎
↓</li>
	<li>
<p>
`~filter$cLは［
%根 の`子孫$である`要素$ %要素 のうち，次の結果 ~EQ ~T になるもの
］に合致する：
</p>
		<ol>
			<li>【！cp-normalize-ns】
~IF［
%~ns ~EQ 空~文字列
］
⇒
%~ns ~SET ~NULL
</li>
			<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%~ns ~IN { ~U002A, %要素 の`~ns$ }
］~AND［
%局所~名 ~IN { ~U002A, %要素 の`局所~名$ }
］
</li>
		</ol>
<p>
（ %~ns ~EQ %局所~名 ~EQ `*^l の場合、 %要素 は無条件に合致することになる）
</p>

◎
If namespace is the empty string, then set it to null.
◎
If both namespace and localName are U+002A (*), then return a HTMLCollection rooted at root, whose filter matches descendant elements.
◎
If namespace is U+002A (*), then return a HTMLCollection rooted at root, whose filter matches descendant elements whose local name is localName.
◎
If localName is U+002A (*), then return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace.
◎
Return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace and local name is localName.
</li>
</ul>

<p id="cp-may-return-the-same">
以前の~callと同じ引数で呼出されたときは，そのときに返したものと同じ $HTMLCollection ~objを返してもヨイ。
◎
When invoked with the same argument, the same HTMLCollection object may be returned as returned by an earlier call.
</p>
</div>

<div class="algo">
<p>
`~node$ %根 用の［
%classNames を
`~classesに含む要素の~list@
］とは、次の~algoが返す $HTMLCollection である：
◎
The list of elements with class names classNames for a node root is the HTMLCollection returned by the following algorithm:
</p>
<ol>
	<li>
%~classes ~LET
%classNames を`有順序~集合 構文解析器$にかけた結果
◎
Let classes be the result of running the ordered set parser on classNames.
</li>
	<li>
~IF［
%~classes は`空$である
］
⇒
~RET 空な $HTMLCollection
◎
If classes is the empty set, return an empty HTMLCollection.
</li>
	<li>
<p>
~RET 次のように設定された $HTMLCollection `~collection$
⇒＃
`根$cL ~SET %根,
`~filter$cLは %根 の`子孫$である`要素$のうち次を満たすものに合致する ⇒
その`~classes$は %~classes を成す どの~tokenも含む
◎
Return a HTMLCollection rooted at root, whose filter matches descendant elements that have all their classes in classes.
</p>

<p>
`~classes$と %~classes の中の各~tokenの比較は、［
%根 の`~node文書$の`~mode$docが `quirks^l ならば `~ASCII大小無視$ ／
~ELSE_ `一致する$かどうか
］で行うモノトスル。
◎
The comparisons for the classes must be done in an ASCII case-insensitive manner if root’s node document’s mode is "quirks"; otherwise in an identical to manner.
</p>
	</li>
</ol>
<!--cp-may-return-the-same-->
</div>

		</section>
		<section id="interface-document">
<h3 title="Interface Document">4.5. ^@Document ~interface</h3>

！！
[`Exposed$=Window]
interface @Document : $Node {
  `Document$mc();

  [`SameObject$] ~RA $DOMImplementation $implementation;
  ~RA $USVString $URL;
  ~RA $USVString $documentURI;
  ~RA $DOMString $compatMode;
  ~RA $DOMString $characterSet;
  ~RA $DOMString $charset; // <span class="comment" id="cp-legacy-characterSet" title="legacy alias of .characterSet">$characterSet の旧来の別名</span>
  ~RA $DOMString $inputEncoding; // <!--cp-legacy-characterSet-->
  ~RA $DOMString $contentType;

  ~RA $DocumentType? $doctype;
  ~RA $Element? $documentElement;
  $HTMLCollection $getElementsByTagName($DOMString %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS($DOMString? %namespace, $DOMString %localName);
  $HTMLCollection $getElementsByClassName($DOMString %classNames);

  [`CEReactions$, `NewObject$] $Element $createElement($DOMString %localName, optional ($DOMString or $ElementCreationOptions) %options = {});
  [`CEReactions$, `NewObject$] $Element $createElementNS($DOMString? %namespace, $DOMString %qualifiedName, optional ($DOMString or $ElementCreationOptions) %options = {});
  [`NewObject$] $DocumentFragment $createDocumentFragment();
  [`NewObject$] $Text $createTextNode($DOMString %data);
  [`NewObject$] $CDATASection $createCDATASection($DOMString %data);
  [`NewObject$] $Comment $createComment($DOMString %data);
  [`NewObject$] $ProcessingInstruction $createProcessingInstruction($DOMString %target, $DOMString %data);

  [`CEReactions$, `NewObject$] $Node $importNode($Node %node, optional $boolean %deep = false);
  [`CEReactions$] $Node $adoptNode($Node %node);

  [`NewObject$] $Attr $createAttribute($DOMString %localName);
  [`NewObject$] $Attr $createAttributeNS($DOMString? %namespace, $DOMString %qualifiedName);

  [`NewObject$] $Event $createEvent($DOMString %interface); // <!--cp-legacy-->

  [`NewObject$] $Range $createRange();

  // $NodeFilter<!---->.$NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [`NewObject$] $NodeIterator $createNodeIterator($Node %root, optional `unsigned long$ %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
  [`NewObject$] $TreeWalker $createTreeWalker($Node %root, optional `unsigned long$ %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
};

[`Exposed$=Window]
interface @XMLDocument : $Document {};

dictionary @@ElementCreationOptions {
  $DOMString @is;
};
！

<p>
$@Document `~node$は、単に
`文書@
（ `document^en ）とも称される。
◎
Document nodes are simply known as documents.
</p>

<div class="p">
<p>
各 `文書$には、次に挙げるものが結付けられる
— 他が言明されない限り，括弧内に示される値をとるとする：
</p>

<dl class="def-list">
	<dt>`符号化法@doc（ `utf-8$ ）</dt>
	<dd>
`符号化法$
</dd>
	<dt>`内容~型@doc（ `application/xml^l ）</dt>
	<dd>
文字列
</dd>
	<dt>`~URL@doc（ `about:blank^l †）</dt>
	<dd>
`~URL$
</dd>
	<dd class="trans-note">【†
厳密には、 `about:blank^l が表現する `~URL$ （文字列ではないので）。
】</dd>
	<dt>`生成元@doc（ `不透明な生成元$ ）</dt>
	<dd>
`生成元$
</dd>
	<dt>`種別@doc（ `xml^l ）</dt>
	<dd>
次のいずれか
⇒＃
`xml^l,
`html^l
</dd>
	<dt>`~mode@doc（ `no-quirks^l ）</dt>
	<dd>
次のいずれか
⇒＃
`no-quirks^l,
`quirks^l,
`limited-quirks^l
</dd>
</dl>

<p>
`ENCODING$r `URL$r `HTML$r
</p>

◎
Each document has an associated encoding (an encoding), content type (a string), URL (a URL), origin (an origin), type ("xml" or "html"), and mode ("no-quirks", "quirks", or "limited-quirks"). [ENCODING] [URL] [HTML]
◎
Unless stated otherwise, a document’s encoding is the utf-8 encoding, content type is "application/xml", URL is "about:blank", origin is an opaque origin, type is "xml", and its mode is "no-quirks".
</div>

<div class="p">
<p>
`文書$は、その`種別$docに応じて：
</p>
<ul>
	<li>
`xml^l ならば
`~XML文書@
であるとされる。
</li>
	<li>
`html^l ならば
`~HTML文書@
であるとされる。
</li>
</ul>
<p>
一部の~APIの挙動は、この 2 種のどちらなのかにより，影響される。
</p>
◎
A document is said to be an XML document if its type is "xml"; otherwise an HTML document. Whether a document is an HTML document or an XML document affects the behavior of certain APIs.
</div>

<div class="p">

<p>
`文書$は、その`~mode$docに応じて：
</p>

<ul ><li>`no-quirks^l ならば
`過去互換なし~mode@
下にあるとされる。
</li><li>`quirks^l ならば
`過去互換~mode@
下にあるとされる。
</li><li>`limited-quirks^l ならば
`制限付き過去互換~mode@
下にあるとされる。
</li></ul>
◎
A document is said to be in no-quirks mode if its mode is "no-quirks", quirks mode if its mode is "quirks", and limited-quirks mode if its mode is "limited-quirks".
</div>

<p class="note">注記：
~modeが既定の~modeから変更されるのは、`文書$が，新たな`閲覧文脈$（初期の `about:blank^l ）から，［
DOCTYPE 文字列の有無, およびその値
］に基づいて `~HTML構文解析器$を通して作成される場合に限られる。
`HTML$r
◎
The mode is only ever changed from the default for documents created by the HTML parser based on the presence, absence, or value of the DOCTYPE string, and by a new browsing context (initial "about:blank"). [HTML]
</p>

<p class="note">注記：
`過去互換なし~mode$ は 元々は “標準~mode” と称され，
`制限付き過去互換~mode$ は かつては “ほぼ標準~mode” と称されていた。
それらは今や標準により定義されたので（また、それらの元々の名称が~~的外れであることから Ian Hickson が~~否決したので）、改称された。
◎
No-quirks mode was originally known as "standards mode" and limited-quirks mode was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)
</p>

<div class="algo">
<p>
`文書$ %文書 の`親~targetを取得する$ときは、所与の
( ~event %~event )
に対し：
</p>
<ol>
	<li>
~IF［
%~event の $Event.type 属性~値 ~EQ `load^l
］~OR［
%文書 が`属する閲覧文脈$ ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 に`関連な大域~obj$
</li>
</ol>

◎
A document’s get the parent algorithm, given an event, returns null if event’s type attribute value is "load" or document does not have a browsing context; otherwise the document’s relevant global object.
</div>

<hr>

<dl class="domintro">
	<dt>%document = $Document()</dt>
	<dd>
新たな`文書$を返す。
◎
Returns a new document.
</dd>

	<dt>%document . $implementation</dt>
	<dd>
%document の $DOMImplementation ~objを返す。
◎
Returns document’s DOMImplementation object.
</dd>

	<dt>%document . $URL</dt>
	<dt>%document . $documentURI</dt>
	<dd>
%document の`~URL$doc を返す。
◎
Returns document’s URL.
</dd>

	<dt>%document . $compatMode</dt>
	<dd>
%document の`~mode$docに応じて，［
`quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返す。
◎
Returns the string "BackCompat" if document’s mode is "quirks"; otherwise "CSS1Compat".
</dd>

	<dt>%document . $characterSet</dt>
	<dd>
%document の`符号化法$docを返す。
◎
Returns document’s encoding.
</dd>

	<dt>%document . $contentType</dt>
	<dd>
%document の`内容~型$docを返す。
◎
Returns document’s content type.
</dd>
</dl>

<div class="algo">
<p>
@Document()
構築子~手続きは
⇒
コレの`生成元$doc ~SET `現在の大域~obj$に`結付けられている文書$の`生成元$doc `HTML$r
◎
The new Document() constructor steps are to set this’s origin to the origin of current global object’s associated Document. [HTML]
</p>

<p class="note">注記：
$DOMImplementation.createDocument() と違って、この構築子は
$XMLDocument ~objではなく，`文書$（ $Document ~obj）を返す。
◎
Unlike createDocument(), this constructor does not return an XMLDocument object, but a document (Document object).
</p>
</div>

<div class="algo">
@implementation
取得子~手続きは
⇒
~RET コレに結付けられている $DOMImplementation ~obj
◎
The implementation getter steps are to return the DOMImplementation object that is associated with this.
</div>

<div class="algo">
<p>
@URL,
@documentURI
取得子~手続きは、いずれも
⇒
~RET `~URLを直列化する$( コレの`~URL$doc )
◎
The URL and documentURI getter steps are to return this’s URL, serialized.
</div>

<div class="algo">
@compatMode
取得子~手続きは
⇒
~RET コレの`~mode$docに応じて
⇒＃
`quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
◎
The compatMode getter steps are to return "BackCompat" if this’s mode is "quirks"; otherwise "CSS1Compat".
</div>

<div class="algo">
@characterSet,
@charset,
@inputEncoding
取得子~手続きは、いずれも
⇒
~RET コレの`符号化法$docの`名前$enc
◎
The characterSet, charset, and inputEncoding getter steps are to return this’s encoding’s name.
</div>

<div class="algo">
@contentType
取得子~手続きは
⇒
~RET コレの`内容~型$doc
◎
The contentType getter steps are to return this’s content type.
</div>

<dl class="domintro">
	<dt>%document . $doctype</dt>
	<dd>
`~doctype$が［
在ればそれ ／
無ければ~NULL
］を返す。
◎
Returns the doctype or null if there is none.
</dd>

	<dt>%document . $documentElement</dt>
	<dd>
`文書~要素$を返す。
◎
Returns the document element.
</dd>

	<dt>%collection = %document . $getElementsByTagName(qualifiedName)</dt>
	<dd>
<p>
引数に応じて，次を満たす`子孫$`要素$すべてからなる $HTMLCollection を返す：
</p>
		<ul>
			<li>
%qualifiedName ~EQ `*^l の場合：
無条件。
</li>
			<li>
<p>
他の場合、次のいずれかを満たすもの：
</p>
				<ul>
					<li>
`有修飾~名$ ~EQ %qualifiedName
</li>
					<li>
［
`~HTML文書$ 内に在る
］~AND［
`~HTML~ns$に属する
］~AND［
`有修飾~名$は %qualifiedName に~ASCII大小無視で合致する
］
</li>
				</ul>
			</li>
		</ul>
◎
If qualifiedName is "*" returns a HTMLCollection of all descendant elements.
◎
Otherwise, returns a HTMLCollection of all descendant elements whose qualified name is qualifiedName. (Matches case-insensitively against elements in the HTML namespace within an HTML document.)
</dd>

	<dt>%collection = %document . $getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
<p>
引数に応じて，次を満たす`子孫$`要素$すべてからなる $HTMLCollection を返す：
◎
↓</p>
		<ul>
			<li>
%namespace, %localName ともに `*^l の場合：
無条件。
◎
If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
</li>
			<li>
%namespace のみ `*^l の場合：
［
`局所~名$ ~EQ %localName
］なるもの。
◎
If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
</li>
			<li>
%localName のみ `*^l の場合：
［
`~ns$ ~EQ %namespace 
］なるもの。
◎
If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
</li>
			<li>
他の場合：
［
`~ns$ ~EQ %namespace
］~AND［
`局所~名$ ~EQ %localName
］なるもの。
◎
Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
</li>
		</ul>
	</dd>

	<dt>%collection = %document . $getElementsByClassName(classNames)</dt>
	<dt>%collection = %element . $Element.getElementsByClassName(classNames)</dt>
	<dd>
~methodが呼出された~obj（`文書$または`要素$）内の`要素$のうち，［
%classNames で与えられる一連の~class名をすべて持つもの
］からなる $HTMLCollection を返す。
%classNames 引数は、一連の~class名を~space等で分離した~listとして解釈される。
◎
Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes.
</dd>
</dl>

<div class="algo">
@doctype
取得子~手続きは
⇒
~RET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`子$である
］~AND［
`~doctype$である
］
◎
The doctype getter steps are to return the child of this that is a doctype; otherwise null.
</div>

<div class="algo">
@documentElement
取得子~手続きは
⇒
~RET コレの`文書~要素$
◎
The documentElement getter steps are to return this’s document element.
</div>

<div class="algo">
<p>
@getElementsByTagName(qualifiedName)
~method~手続きは
⇒
~RET コレ用の［
%qualifiedName を`有修飾~名に持つ要素の~list$
］
◎
The getElementsByTagName(qualifiedName) method steps are to return the list of elements with qualified name qualifiedName for this.
</p>

<p class="note">注記：
したがって，`~HTML文書$においては、
`document.getElementsByTagName("FOO")^c は
`~HTML~ns$に属さない `FOO^e 要素と
`~HTML~ns$に属する `foo^e 要素に合致し，
`~HTML~ns$に属する `FOO^e 要素には合致しないことになる。
◎
Thus, in an HTML document, document.getElementsByTagName("FOO") will match &lt;FOO&gt; elements that are not in the HTML namespace, and &lt;foo&gt; elements that are in the HTML namespace, but not &lt;FOO&gt; elements that are in the HTML namespace.
</p>
</div>

<div class="algo">
@getElementsByTagNameNS(namespace, localName)
~method~手続きは
⇒
~RET コレ用の［
( %namespace, %localName ) を
`( ~ns, 局所~名 ) に持つ要素の~list$
］
◎
The getElementsByTagNameNS(namespace, localName) method steps are to return the list of elements with namespace namespace and local name localName for this.
</div>

<div class="algo">
<p>
@getElementsByClassName(classNames)
~method~手続きは
⇒
~RET コレ用の［
%classNames を`~classesに含む要素の~list$
］
◎
The getElementsByClassName(classNames) method steps are to return the list of elements with class names classNames for this.
</p>

<div class="example">
<p>
次の XHTML 片が与えられたとする：
◎
Given the following XHTML fragment:
</p>

<pre class="lang-html">
&lt;div id="example"&gt;
  &lt;p id="<mark>p1</mark>" class="aaa bbb"/&gt;
  &lt;p id="<mark>p2</mark>" class="aaa ccc"/&gt;
  &lt;p id="<mark>p3</mark>" class="bbb ccc"/&gt;
&lt;/div&gt;
</pre>

<p>
<samp>document.getElementById(`example^l).getElementsByClassName(`aaa^l)</samp>
の~callは、その中の 2 個の paragraph 
<mark>p1</mark> と <mark>p2</mark> からなる
$HTMLCollection を返すことになる。
◎
A call to document.getElementById("example").getElementsByClassName("aaa") would return a HTMLCollection with the two paragraphs p1 and p2 in it.
</p>

<p>
一方で，
<samp>getElementsByClassName(`ccc&nbsp;bbb^l)</samp>
の~callは
その中の 1 個の~node <mark>p3</mark> のみを返すことになる。
<samp>document.getElementById(`example^l).getElementsByClassName(`bbb&nbsp;&nbsp;&nbsp;ccc&nbsp;^l)</samp>
の~callも同じものを返すことになる。
◎
A call to getElementsByClassName("ccc bbb") would only return one node, however, namely p3. A call to document.getElementById("example").getElementsByClassName("bbb ccc ") would return the same thing.
</p>

<p>
<samp>getElementsByClassName(`aaa,bbb^l)</samp>
の~callは 1 個の~nodeも返さない。
上のどの要素も `aaa,bbb^c ~classに属さない。
◎
A call to getElementsByClassName("aaa,bbb") would return no nodes; none of the elements above are in the aaa,bbb class.
</p>
</div>
</div>

<dl class="domintro">
	<dt>%element = %document . $createElement(localName [, options])</dt>
	<dd>
`局所~名$が %localName にされた`要素$を返す（ %document が`~HTML文書$である場合， %localName は小文字~化される）。
`要素$の`~ns$は，［
次のいずれかに該当する場合は`~HTML~ns$ ／
他の場合は ~NULL
］になる
⇒＃
%document は`~HTML文書$である ／
%document の`内容~型$doc ~EQ `application/xhtml+xml^l
◎
Returns an element with localName as local name (if document is an HTML document, localName gets lowercased). The element’s namespace is the HTML namespace when document is an HTML document or document’s content type is "application/xhtml+xml"; otherwise null.
</dd>
	<dd>
%localName が `Name$prod 生成規則に合致しない場合，
`InvalidCharacterError$E 例外が投出される。
◎
If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
</dd>
	<dd id="cp-supplied-is-mb">
%options の $ElementCreationOptions.is を利用して，`~custom化された組込みの要素$を作成できる。
◎
When supplied, options’s is can be used to create a customized built-in element.
</dd>

	<dt>%element = %document . $createElementNS(namespace, qualifiedName [, options])</dt>
	<dd>
`~ns$ %namespace に属するような，新たな`要素$を返す。
その ( `~ns接頭辞$ %接頭辞, `局所~名$ %局所~名 ) は、順に次のようにされる
⇒＃
%qualifiedName が ~U003A を含むならば それを挟んだ ( 前, 後 ) の部分 ／
他の場合は ( ~NULL, %qualifiedName )
◎
Returns an element with namespace namespace. Its namespace prefix will be everything before U+003A (:) in qualifiedName or null. Its local name will be everything after U+003A (:) in qualifiedName or qualifiedName.
</dd>
	<dd>
%qualifiedName が `QName$prod 生成規則に合致しない場合、
`InvalidCharacterError$E 例外が投出される。
◎
If qualifiedName does not match the QName production an "InvalidCharacterError" DOMException will be thrown.
</dd>
	<dd>
次のいずれかに該当する場合， `NamespaceError$E 例外が投出される
⇒＃
%namespace ~EQ 空~文字列 ~AND %接頭辞 ~NEQ ~NULL ／
%namespace ~NEQ `~XML~ns$ ~AND %接頭辞 ~EQ `xml^l ／
%namespace ~NEQ `~XMLNS~ns$ ~AND %qualifiedName ~EQ `xmlns^l ／
%namespace ~NEQ `~XMLNS~ns$ ~AND %接頭辞 ~EQ `xmlns^l ／
%namespace ~EQ `~XMLNS~ns$ ~AND %qualifiedName ~NEQ `xmlns^l ／
%namespace ~EQ `~XMLNS~ns$ ~AND %接頭辞 ~NEQ `xmlns^l
◎
If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
• Namespace prefix is not null and namespace is the empty string.
• Namespace prefix is "xml" and namespace is not the XML namespace.
• qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
• namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
</dd>
	<!--cp-supplied-is-mb-->

	<dt>%documentFragment = %document . $createDocumentFragment()</dt>
	<dd>
$DocumentFragment `~node$を返す。
◎
Returns a DocumentFragment node.
</dd>

	<dt>%text = %document . $createTextNode(data)</dt>
	<dd>
新たな $Text `~node$を返す
— その`~data$は %data にされる。
◎
Returns a Text node whose data is data.
</dd>

	<dt>%text = %document . $createCDATASection(data)</dt>
	<dd>
新たな $CDATASection `~node$を返す
— その`~data$は %data にされる。
◎
Returns a CDATASection node whose data is data.
</dd>

	<dt>%comment = %document . $createComment(data)</dt>
	<dd>
新たな $Comment `~node$を返す
— その`~data$は %data にされる。
◎
Returns a Comment node whose data is data.
</dd>

	<dt>%processingInstruction = %document . $createProcessingInstruction(target, data)</dt>
	<dd>
新たな $ProcessingInstruction `~node$を返す
— その $target は %target にされ, `~data$は %data にされる。
◎
Returns a ProcessingInstruction node whose target is target and data is data.＼
</dd>
	<dd>
次のいずれかに該当する場合，
`InvalidCharacterError$E 例外が投出される
⇒＃
%target は `Name$prod 生成規則に合致しない ／
%data は `?&gt;^l を含んでいる
◎
If target does not match the Name production an "InvalidCharacterError" DOMException will be thrown. If data contains "?&gt;" an "InvalidCharacterError" DOMException will be thrown.
</dd>
</dl>

<p>
他が言明されない限り，所与の
( 局所~名, ~ns )
用の
`要素~interface@
は、 $Element とする。
◎
The element interface for any name and namespace is Element, unless stated otherwise.
</p>

<p class="note">注記：
例えば，~HTML標準は、
( `html$e, `~HTML~ns$ )
用のそれを， $HTMLHtmlElement ~interfaceと定義している。
`HTML$r
◎
The HTML Standard will, e.g., define that for html and the HTML namespace, the HTMLHtmlElement interface is used. [HTML]
</p>

<div class="algo">
<p>
@createElement(localName, options)
~method~手続きは：
◎
The createElement(localName, options) method steps are:
</p>
<ol>
	<li>
~IF［
%localName は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName does not match the Name production, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~IF［
コレは`~HTML文書$ である
］
⇒
%localName ~SET `~ASCII小文字~化する$( %localName )
◎
If this is an HTML document, then set localName to localName in ASCII lowercase.
</li>
	<li id="cp-let-is">
%is ~LET ~NULL
◎
Let is be null.
</li>
	<li id="cp-set-is">
~IF［
%options は`辞書$である
］
⇒
%is ~SET ［
%options[ "$ElementCreationOptions.is" ] ~NEQ ε ならば その値 ／
~ELSE_ ~NULL
］
◎
If options is a dictionary and options["is"] exists, then set is to it.
</li>
	<li>
%~ns ~LET ［
次が満たされるならば `~HTML~ns$ ／
~ELSE_ ~NULL
］
⇒
［
コレは`~HTML文書$である
］~OR［
コレの`内容~型$doc ~EQ `application/xhtml+xml^l
］
◎
Let namespace be the HTML namespace, if this is an HTML document or this’s content type is "application/xhtml+xml"; otherwise null.
</li>
	<li>
~RET
`要素を作成する$( コレ, %localName, %~ns, ~NULL, %is, `同期~custom要素^i )
◎
Return the result of creating an element given this, localName, namespace, null, is, and with the synchronous custom elements flag set.
</li>
</ol>
</div>

<div class="algo">
<p>
`内部 createElementNS 手続き@
は、所与の
( %文書, %namespace, %qualifiedName, %options )
に対し，次を走らす：
◎
The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as follows:
</p>
<ol>
	<li id="cp-validate-and-extract">
( %~ns, %接頭辞, %局所~名 ) ~LET
`検証して抽出する$( %namespace, %qualifiedName )
◎
Let namespace, prefix, and localName be the result of passing namespace and qualifiedName to validate and extract.
</li>
	<!--cp-let-is-->
	<!--cp-set-is-->
	<li>
~RET
`要素を作成する$( %文書, %局所~名, %~ns, %接頭辞, %is, `同期~custom要素^i )
◎
Return the result of creating an element given document, localName, namespace, prefix, is, and with the synchronous custom elements flag set.
</li>
</ol>
</div>

<div class="algo">
<p>
@createElementNS(namespace, qualifiedName, options)
~method~手続きは
⇒
~RET `内部 createElementNS 手続き$( コレ, %namespace, %qualifiedName, %options )
◎
The createElementNS(namespace, qualifiedName, options) method steps are to return the result of running the internal createElementNS steps, given this, namespace, qualifiedName, and options.
</p>

<p class="note">注記：
~web互換性のため、［
$createElement() ／ $createElementNS()
］の %options 引数には文字列も許容される【無視されることになる】。
◎
createElement() and createElementNS()'s options parameter is allowed to be a string for web compatibility.
</p>
</div>

<div class="algo">
@createDocumentFragment()
~method~手続きは
⇒
~RET 次のように設定された新たな`文書片$
⇒
`~node文書$ ~SET コレ
◎
The createDocumentFragment() method steps are to return a new DocumentFragment node whose node document is this.
</div>

<div class="algo">
<p>
@createTextNode(data)
~method~手続きは
⇒
~RET `新たな~Text~node$( %data, コレ )
◎
The createTextNode(data) method steps are to return a new Text node whose data is data and node document is this.
</p>

<p class="note">注記：
［
%data が `Char$prod 生成規則に合致しない文字を含む
］かどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production.
</p>
</div>

<div class="algo">
<p>
@createCDATASection(data)
~method~手続きは：
◎
The createCDATASection(data) method steps are:
</p>
<ol>
	<li>
~IF［
コレは`~HTML文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If this is an HTML document, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
%data は文字列 `]]&gt;^l を包含する
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains the string "]]&gt;", then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~RET 次のように設定された新たな $CDATASection `~node$
⇒＃
`~data$ ~SET %data,
`~node文書$ ~SET コレ
◎
Return a new CDATASection node with its data set to data and node document set to this.
</li>
</ol>
</div>

<div class="algo">
<p>
@createComment(data)
~method~手続きは
⇒
~RET 次のように設定された新たな $Comment `~node$
⇒＃
`~data$ ~SET %data,
`~node文書$ ~SET コレ
◎
The createComment(data) method steps are to return a new Comment node whose data is data and node document is this.
</p>

<p class="note">注記：
%data が［
`Char$prod 生成規則に合致しない文字を含む ／
連続する 2 個の~hyphen（ "--" ）を含む ／
~hyphenで終わる
］かどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production or that it contains two adjacent hyphens or ends with a hyphen.
</p>
</div>

<div class="algo">
<p>
@createProcessingInstruction(target, data)
~method~手続きは：
◎
The createProcessingInstruction(target, data) method steps are:
</p>
<ol>
	<li>
~IF［
%target は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If target does not match the Name production, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~IF［
%data は文字列 `?&gt;^l を含む
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains the string "?&gt;", then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~RET 
次のように設定された新たな $ProcessingInstruction `~node$
⇒＃
$ProcessingInstruction.target ~SET %target,
`~data$ ~SET %data,
`~node文書$ ~SET コレ
◎
Return a new ProcessingInstruction node, with target set to target, data set to data, and node document set to this.
</li>
</ol>

<p class="note">注記：
［
%target が `xml^l または `:^l を含む ／
%data が `Char$prod 生成規則に合致しない文字を含む
］かどうかは、検査されない。
◎
No check is performed that target contains "xml" or ":", or that data contains characters that match the Char production.
</p>
</div>

<dl class="domintro">
	<dt>%clone = %document . $importNode(node [, deep = false])</dt>
	<dd>
%node の複製を返す。
%deep が ~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>
	<dd>
%node が`文書$または`~shadow根$である場合，
`NotSupportedError$E 例外が投出される。
◎
If node is a document or a shadow root, throws a "NotSupportedError" DOMException.
</dd>

	<dt>%node = %document . $adoptNode(node)</dt>
	<dd>
%node を他の`文書$から移動させた上で，それを返す。
◎
Moves node from another document and returns it.
</dd>
	<dd>
%node が`文書$である場合，
`NotSupportedError$E 例外が投出される。
%node が`~shadow根$である場合，
`HierarchyRequestError$E 例外が投出される。
◎
If node is a document, throws a "NotSupportedError" DOMException or, if node is a shadow root, throws a "HierarchyRequestError" DOMException.
</dd>
</dl>

<div class="algo">
<p>
@importNode(node, deep)
~method~手続きは：
◎
The importNode(node, deep) method steps are:
</p>
<ol>
	<li>
~IF［
%node は `文書$または`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document or shadow root, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~RET `~nodeを~cloneする$( %node, コレ, ［
%deep ~EQ ~T ならば `子も~cloneする^i ／
~ELSE_ ε
］ )
◎
Return a clone of node, with this and the clone children flag set if deep is true.
</li>
</ol>
</div>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`受入-時の手続き@
を定義してもヨイ。
この~algoは、`~nodeを受入する$~algo内から，
( `~node$, `文書$ )
を渡して呼出される。
◎
Specifications may define adopting steps for all or some nodes. The algorithm is passed node and oldDocument, as indicated in the adopt algorithm.
</p>

<div class="algo">
<p>
%文書 に
`~nodeを受入する@
ときは、所与の
( %node )
に対し，次を走らす：
◎
To adopt a node into a document, run these steps:
</p>
<ol>
	<li>
%旧-文書 ~LET %node の`~node文書$
◎
Let oldDocument be node’s node document.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
`~nodeを除去する$( %node )
◎
If node’s parent is non-null, then remove node.
</li>
	<li>
<p>
~IF［
%文書 ~NEQ %旧-文書
］：
◎
If document is not oldDocument, then:
</p>
		<ol>
			<li>
<p>
%node の
~EACH( `~shadowも含む広義-子孫$ %広義-子孫 )
に対し
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants:
</p>
				<ol>
					<li>
%広義-子孫 の`~node文書$ ~SET %文書
◎
Set inclusiveDescendant’s node document to document.
</li>
					<li>
~IF［
%広義-子孫 は`要素$である
］
⇒
%広義-子孫 の`属性o~list$を成す
~EACH( %属性o )
に対し
⇒
%属性o の`~node文書$ ~SET %文書
◎
If inclusiveDescendant is an element, then set the node document of each attribute in inclusiveDescendant’s attribute list to document.
</li>
				</ol>
			</li>
			<li>
%node の
~EACH( `~shadowも含む広義-子孫$ %広義-子孫 )
に対し
⇒
~IF［
%広義-子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義-子孫,
`adoptedCallback^l,
« %旧-文書, %文書 »
)
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants that is custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name "adoptedCallback", and an argument list containing oldDocument and document.
</li>
			<li>
%node の
~EACH( `~shadowも含む広義-子孫$ %広義-子孫 )
に対し，`~shadowも含む~tree順序$で
⇒
`受入-時の手続き$に
( %広義-子孫, %旧-文書 )
を渡して走らす
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants, in shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
@adoptNode(node)
~method~手続きは：
◎
The adoptNode(node) method steps are:
</p>
<ol>
	<li>
~IF［
%node は`文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
%node は`~shadow根$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a shadow root, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%node は`文書片$である
］~AND［
%node の`~host$ ~NEQ ~NULL
］
⇒
~RET
◎
If node is a DocumentFragment node whose host is non-null, then return.
</li>
	<li>
コレに`~nodeを受入する$( %node )
◎
Adopt node into this.
</li>
	<li>
~RET %node
◎
Return node.
</li>
</ol>
</div>

<div class="algo">
<p>
@createAttribute(localName)
~method~手続きは：
◎
The createAttribute(localName) method steps are:
</p>
<ol>
	<li>
~IF［
%localName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName does not match the Name production in XML, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~IF［
コレは`~HTML文書$である
］
⇒
%localName ~SET `~ASCII小文字~化する$( %localName )
◎
If this is an HTML document, then set localName to localName in ASCII lowercase.
</li>
	<li>
~RET 次のように設定された新たな`属性o$
⇒＃
`局所~名$a ~SET %localName,
`~node文書$ ~SET コレ
◎
Return a new attribute whose local name is localName and node document is this.
</li>
</ol>
</div>

<div class="algo">
<p>
@createAttributeNS(namespace, qualifiedName)
~method~手続きは：
◎
The createAttributeNS(namespace, qualifiedName) method steps are:
</p>
<ol>
	<!--cp-validate-and-extract-->
	<li>
~RET 次のように設定された新たな`属性o$
⇒＃
`~ns$a ~SET %~ns,
`~ns接頭辞$a ~SET %接頭辞,
`局所~名$a ~SET %局所~名,
`~node文書$ ~SET コレ
◎
Return a new attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, and node document is this.
</li>
</ol>
</div>

<div class="algo">
<p>
@createEvent(interface)
~method~手続きは：
◎
The createEvent(interface) method steps are:
</p>
<ol>
	<li>
%構築子 ~LET ~NULL
◎
Let constructor be null.
</li>
	<li>
<p>
~IF［
%interface は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］
⇒
%構築子 ~SET ［
合致した行の 2 列目の~interface
］の構築子
◎
If interface is an ASCII case-insensitive match for any of the strings in the first column in the following table, then set constructor to the interface in the second column on the same row as the matching string:
</p>

<table>
<thead><tr><th>文字列◎ String
<th>~interface◎ Interface
<th>仕様（空欄はこの仕様）◎ Notes
</thead><tbody>

<tr><td>`beforeunloadevent^l
<td>$BeforeUnloadEvent
<td>`HTML$r

<tr><td>`compositionevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`customevent^l
<td>$CustomEvent
<td>

<tr><td>`devicemotionevent^l
<td>$DeviceMotionEvent
<td>`DEVICE-ORIENTATION$r

<tr><td>`deviceorientationevent^l
<td>$DeviceOrientationEvent
<td>同上

<tr><td>`dragevent^l
<td>$DragEvent
<td>`HTML$r

<tr><td>`event^l
<td>$Event
<td>

<tr><td>`events^l
<td>同上
<td>

<tr><td>`focusevent^l
<td>$FocusEvent
<td>`UIEVENTS$r

<tr><td>`hashchangeevent^l
<td>$HashChangeEvent
<td>`HTML$r

<tr><td>`htmlevents^l
<td>$Event
<td>

<tr><td>`keyboardevent^l
<td>$KeyboardEvent
<td>`UIEVENTS$r

<tr><td>`messageevent^l
<td>$MessageEvent
<td>`HTML$r

<tr><td>`mouseevent^l
<td>$MouseEvent
<td>`UIEVENTS$r

<tr><td>`mouseevents^l
<td>同上
<td>同上

<tr><td>`storageevent^l
<td>$StorageEvent
<td>`HTML$r

<tr><td>`svgevents^l
<td>$Event
<td>

<tr><td>`textevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`touchevent^l
<td>$TouchEvent
<td>`TOUCH-EVENTS$r

<tr><td>`uievent^l
<td>$UIEvent
<td>`UIEVENTS$r

<tr><td>`uievents^l
<td>同上
<td>同上

</tbody></table>

	</li>
	<li>
~IF［
%構築子 ~EQ ~NULL
］
⇒
~THROW `NotSupportedError$E
◎
If constructor is null, then throw a "NotSupportedError" DOMException.
</li>
	<li>
<p>
~IF［
%構築子 が指示する~interfaceは，コレに`関連な大域~obj$に公開されていない
］
⇒
~THROW `NotSupportedError$E
◎
If the interface indicated by constructor is not exposed on the relevant global object of this, then throw a "NotSupportedError" DOMException.
</p>

<p class="note">注記：
概して~UAは、環境設定によっては，~touch~eventの~supportを不能化する
— その場合、この段が $TouchEvent ~interface用に誘発されることになる。
◎
Typically user agents disable support for touch events in some configurations, in which case this clause would be triggered for the interface TouchEvent.
</p>
	</li>
	<li>
%~event ~LET `~eventを作成する$( %構築子 )
◎
Let event be the result of creating an event given constructor.
</li>
	<li>
%~event の次に挙げる属性を初期化する
⇒＃
$Event.type ~SET 空~文字列,
$Event.timeStamp ~SET `現在の高分解能~時刻$( コレに`関連な大域~obj$ ),
$Event.isTrusted ~SET ~F
◎
Initialize event’s type attribute to the empty string.
◎
Initialize event’s timeStamp attribute to the result of calling current high resolution time with this’s relevant global object.
◎
Initialize event’s isTrusted attribute to false.
</li>
	<li>
%~event の`初期化-済みか$ev ~SET ~F
◎
Unset event’s initialized flag.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>

<p class="note">注記：
代わりに，`~event$構築子が利用されるべきである。
◎
Event constructors ought to be used instead.
</p>
</div>

<div class="algo">
<p>
@createRange()
~method~手続きは
⇒
~RET 次のように設定された新たな`~live範囲o$
⇒＃
`始端$ ~SET `境界点$( コレ, 0 ),
`終端$ ~SET `境界点$( コレ, 0 )
◎
The createRange() method steps are to return a new live range with (this, 0) as its start an end.
</p>

<p class="note">注記：
代わりに， $Range.Range() 構築子を利用できる。
◎
The Range() constructor can be used instead.
</p>
</div>

<div class="algo">
@createNodeIterator(root, whatToShow, filter)
~method~手続きは
⇒
~RET 次のように設定された新たな $NodeIterator ~obj
⇒＃
`根$tV ~SET %root,
`起点$tV ~SET %root,
`起点の直前か$tV ~SET ~T,
`~whatToShow$tV ~SET %whatToShow,
`~filter~callback$tV ~SET %filter
◎
The createNodeIterator(root, whatToShow, filter) method steps are:
• Let iterator be a new NodeIterator object.
• Set iterator’s root and iterator’s reference to root.
• Set iterator’s pointer before reference to true.
• Set iterator’s whatToShow to whatToShow.
• Set iterator’s filter to filter.
• Return iterator.
</div>

<div class="algo">
@createTreeWalker(root, whatToShow, filter)
~method~手続きは
⇒
~RET 次のように設定された新たな $TreeWalker ~obj
⇒＃
`根$tV ~SET %root,
`現-~node$tV ~SET %root,
`~whatToShow$tV ~SET %whatToShow,
`~filter~callback$tV ~SET %filter
◎
The createTreeWalker(root, whatToShow, filter) method steps are:
• Let walker be a new TreeWalker object.
• Set walker’s root and walker’s current to root.
• Set walker’s whatToShow to whatToShow.
• Set walker’s filter to filter.
• Return walker.
</div>

			<section id="interface-domimplementation">
<h4 title="Interface DOMImplementation">4.5.1. ^@DOMImplementation ~interface</h4>

<p>
~UAは、`文書$ %文書 が作成されるときには，
$DOMImplementation ~objを作成して %文書 にそれを結付けるモノトスル。
◎
User agents must create a DOMImplementation object whenever a document is created and associate it with that document.
</p>

！！
[`Exposed$=Window]
interface @DOMImplementation {
  [`NewObject$] $DocumentType $createDocumentType($DOMString qualifiedName, $DOMString publicId, $DOMString systemId);
  [`NewObject$] $XMLDocument $createDocument($DOMString? %namespace, [`LegacyNullToEmptyString$] $DOMString %qualifiedName, optional $DocumentType? %doctype = null);
  [`NewObject$] $Document $createHTMLDocument(optional $DOMString title);

  $boolean $hasFeature(); // <span class="comment" id="cp-useless-true" title="useless; always returns true">無用の長物 — 常に true を返す</span>
};
！

<dl class="domintro">
	<dt>%doctype = %document . $Document.implementation . $createDocumentType(qualifiedName, publicId, systemId)</dt>
	<dd>
所与の［
%qualifiedName, %publicId, %systemId
］を伴う`~doctype$を返す。
%qualifiedName が［
`Name$prod 生成規則に合致しない場合は
`InvalidCharacterError$E 例外 ／
`QName$prod 生成規則に合致しない場合は
`NamespaceError$E 例外
］が投出される。
◎
Returns a doctype, with the given qualifiedName, publicId, and systemId. If qualifiedName does not match the Name production, an "InvalidCharacterError" DOMException is thrown, and if it does not match the QName production, a "NamespaceError" DOMException is thrown.
</dd>

	<dt>%doc = %document . $Document.implementation . $createDocument(namespace, qualifiedName [, doctype = null])</dt>
	<dd>
`局所~名$が %qualifiedName で`~ns$が %namespace （ %qualifiedName が空~文字列でなければ）の`文書~要素$を伴い，
%doctype が与えられていれば`~doctype$がそれに設定された
$XMLDocument を返す。
◎
Returns an XMLDocument, with a document element whose local name is qualifiedName and whose namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is given, as its doctype.
</dd>
	<dd>
この~methodは、$Document.createElementNS() ~methodと同じ例外を，
( %namespace, %qualifiedName )
で呼出したときに投出する。
◎
This method throws the same exceptions as the createElementNS() method, when invoked with namespace and qualifiedName.
</dd>

	<dt>%doc = %document . $Document.implementation . $createHTMLDocument([title])</dt>
	<dd>
基本~構造が構築-済みの`~tree$を伴う`文書$を返す。
%title 引数が省略されていなければ `title$e 要素も含められる。
◎
Returns a document, with a basic tree already constructed including a title element, unless the title argument is omitted.
</dd>
</dl>

<div class="algo">
<p>
@createDocumentType(qualifiedName, publicId, systemId)
~method~手続きは：
◎
The createDocumentType(qualifiedName, publicId, systemId) method steps are:
</p>
<ol>
	<li>
`有修飾~名として検証する$( %qualifiedName )
◎
Validate qualifiedName.
</li>
	<li>
~RET 次のように設定された新たな`~doctype$
⇒＃
`名前$dT ~SET %qualifiedName,
`~publicID$dT ~SET %publicId,
`~systemID$dT ~SET %systemId,
`~node文書$ ~SET コレを結付けている`文書$
◎
Return a new doctype, with qualifiedName as its name, publicId as its public ID, and systemId as its system ID, and with its node document set to the associated document of this.
</li>
</ol>

<p class="note">注記：
［
%publicId を成す符号位置~並びが `PubidChar^prod 生成規則に合致しない ／
%systemId が文字 `"^l や `'^l を含む
］かどうかは、検査されない。
◎
No check is performed that publicId code points match the PubidChar production or that systemId does not contain both a '"' and a "'".
</p>
</div>

<div class="algo">
<p>
@createDocument(namespace, qualifiedName, doctype)
~method~手続きは：
◎
The createDocument(namespace, qualifiedName, doctype) method steps are:
</p>
<ol>
	<li>
%文書 ~LET 新たな $XMLDocument
◎
Let document be a new XMLDocument.
</li>
	<li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>
	<li>
~IF［
%qualifiedName ~NEQ 空~文字列
］
⇒
%要素 ~SET `内部 createElementNS 手続き$( コレ, %namespace, %qualifiedName, 空な辞書 )
◎
If qualifiedName is not the empty string, then set element to the result of running the internal createElementNS steps, given document, namespace, qualifiedName, and an empty dictionary.
</li>
	<li>
~IF［
%doctype ~NEQ ~NULL
］
⇒
%文書 に`~nodeを付加する$( %doctype )
◎
If doctype is non-null, append doctype to document.
</li>
	<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%文書 に`~nodeを付加する$( %要素 )
◎
If element is non-null, append element to document.
</li>
	<li>
%文書 の`生成元$doc ~SET コレを結付けている`文書$の`生成元$doc
◎
document’s origin is this’s associated document’s origin.
</li>
	<li>
%文書 の`内容~型$doc ~SET %namespace に応じて
⇒＃
`~HTML~ns$ならば `application/xhtml+xml^c ／
`~SVG~ns$ならば `image/svg+xml^c ／
~ELSE_ `application/xml^c
◎
document’s content type is determined by namespace:
◎
HTML namespace
• application/xhtml+xml
SVG namespace
• image/svg+xml
Any other namespace
• application/xml
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="algo">
<p>
@createHTMLDocument(title)
~method~手続きは：
◎
The createHTMLDocument(title) method steps are:
</p>
<ol>
	<li>
%文書 ~LET 次のように設定された新たな`文書$
⇒＃
`種別$doc ~SET `html^l,
`内容~型$doc ~SET `text/html^l
◎
Let doc be a new document that is an HTML document.
◎
Set doc’s content type to "text/html".
</li>
	<li>
%文書 に`~nodeを付加する$( 次のように設定された新たな`~doctype$ )
⇒＃
`名前$dT ~SET `html^l,
`~node文書$ ~SET %文書
◎
Append a new doctype, with "html" as its name and with its node document set to doc, to doc.
</li>
	<li>
`html 要素^V ~LET
`要素を作成する$( %文書, `html^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, html, and the HTML namespace, to doc.
</li>
	<li>
%文書 に`~nodeを付加する$( `html 要素^V )
◎
↑</li>
	<li>
`head 要素^V ~LET
`要素を作成する$( %文書, `head^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, head, and the HTML namespace, to the html element created earlier.
</li>
	<li>
`html 要素^V に`~nodeを付加する$( `head 要素^V )
◎
↑</li>
	<li>
<p>
~IF［
%title 引数は与えられている
］：
◎
If title is given:
</p>
		<ol>
			<li>
`title 要素^V ~LET
`要素を作成する$( %文書, `title^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, title, and the HTML namespace, to the head element created earlier.
</li>
			<li>
`head 要素^V に`~nodeを付加する$( `title 要素^V )
◎
↑</li>
			<li>
`title 要素^V に`~nodeを付加する$( `新たな~Text~node$( %title, %文書 ) )
◎
Append a new Text node, with its data set to title (which could be the empty string) and its node document set to doc, to the title element created earlier.
</li>
		</ol>
	</li>
	<li>
`html 要素^V に`~nodeを付加する$( `要素を作成する$( %文書, `body^l, `~HTML~ns$ ) )
◎
Append the result of creating an element given doc, body, and the HTML namespace, to the html element created earlier.
</li>
	<li>
%文書 の`生成元$doc ~SET コレを結付けている`文書$の`生成元$doc
`HTML$r
◎
doc’s origin is this’s associated document’s origin.
</li>
	<li>
~RET %文書
◎
Return doc.
</li>
</ol>
</div>

<div class="algo">
<p>
@hasFeature()
~method~手続きは
⇒
~RET ~T
◎
The hasFeature() method steps are to return true.
</p>

<p class="note">注記：
$hasFeature()
は元々、~UAが所与の~DOM特能の~supportを主張しているかどうかを報告するものであったが、経験から，単に欲される［
~obj／属性／~method
］が存在するかどうか検査する用途には ほど遠いことが~~判明している。
そのようなわけで，それは もはや利用されないが、古い~pageが働き続けられるよう存続している（単に ~T を返す）。
◎
hasFeature() originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it is no longer to be used, but continues to exist (and simply returns true) so that old pages don’t stop working.
</p>
</div>

			</section>
		</section>
		<section id="interface-documenttype">
<h3 title="Interface DocumentType">4.6. ^@DocumentType ~interface</h3>

！！
[`Exposed$=Window]
interface @DocumentType : $Node {
  ~RA $DOMString $name;
  ~RA $DOMString $publicId;
  ~RA $DOMString $systemId;
};
！

<p>
$DocumentType `~node$は、単に
`~doctype@
とも称される。
◎
DocumentType nodes are simply known as doctypes.
</p>

<div class="p">
<p>
各 `~doctype$には、次に挙げるものが結付けられる（いずれも，文字列）：
</p>

<dl class="def-list">
	<dt>`名前@dT</dt>
	<dd>
常に，`~doctype$の作成-時に与えられる。
</dd>

	<dt>`~publicID@dT</dt>
	<dt>`~systemID@dT</dt>
	<dd>
これらは、`~doctype$の作成-時に明示的に与えられない限り，空~文字列とする。
</dd>
</dl>

◎
Doctypes have an associated name, public ID, and system ID.
◎
When a doctype is created, its name is always given. Unless explicitly given when a doctype is created, its public ID and system ID are the empty string.
</div>

<div class="algo">
@name
取得子~手続きは
⇒
~RET コレの`名前$dT
◎
The name getter steps are to return this’s name.
</div>

<div class="algo">
@publicId
取得子~手続きは
⇒
~RET コレの`~publicID$dT
◎
The publicId getter steps are to return this’s public ID.
</div>

<div class="algo">
@systemId
取得子~手続きは
⇒
~RET コレの`~systemID$dT
◎
The systemId getter steps are to return this’s system ID.
</div>

		</section>
		<section id="interface-documentfragment">
<h3 title="Interface DocumentFragment">4.7. ^@DocumentFragment ~interface</h3>

！！
[`Exposed$=Window]
interface @DocumentFragment : $Node {
  `DocumentFragment$mc();
};
！

<p>
$DocumentFragment `~node$は、単に
`文書片@
（ `document fragment^en ）とも称される。
【これは、この訳にて導入した非公式な用語である。】
</p>

<div class="p">
<p>
各 `文書片$には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~host@</dt>
	<dd>
［
~NULL ／ 異なる`~node~tree$内に在る`要素$
］であり、他が言明されない限り，~NULL とする。
</dd>
</dl>
◎
A DocumentFragment node has an associated host (null or an element in a different node tree). It is null unless otherwise stated.
</div>

<p>
~obj %A が ~obj %B の
`~hostも含む広義-先祖@
であるとは、次のいずれかが満たされることを意味する：
◎
An object A is a host-including inclusive ancestor of an object B, if either＼
</p>

<ul>
	<li>
%A は %B の`広義-先祖$である
◎
A is an inclusive ancestor of B, or＼
</li>
	<li>
%B の`根$の`~host$を %H とするとき，次が満たされる
⇒
［
%H ~NEQ ~NULL
］~AND［
%A は %H の`~hostも含む広義-先祖$である
］
◎
if B’s root has a non-null host and A is a host-including inclusive ancestor of B’s root’s host.
</li>
</ul>

<p class="note">注記：
`文書片$の`~host$は，［
`~shadow根$, ~HTMLの `template$e 要素
］で有用になる概念であり、［
`~nodeを子の前に前挿入する$／`子を~nodeに置換する$
］~algoに影響iする。 
◎
The DocumentFragment node’s host concept is useful for HTML’s template element and for shadow roots, and impacts the pre-insert and replace algorithms.
</p>

<hr>

<dl class="domintro">
	<dt>%tree = $DocumentFragment()</dt>
	<dd>
新たな`文書片$を返す。
◎
Returns a new DocumentFragment node.
</dd>
</dl>

<div class="algo">
<p>
@DocumentFragment()
構築子~手続きは
⇒
コレの`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The new DocumentFragment() constructor steps are to set this’s node document to current global object’s associated Document.
</div>

		</section>
		<section id="interface-shadowroot">
<h3 title="Interface ShadowRoot">4.8. ^@ShadowRoot ~interface</h3>

！！
[`Exposed$=Window]
interface @ShadowRoot : $DocumentFragment {
  ~RA $ShadowRootMode $mode;
  ~RA $boolean $delegatesFocus;
  ~RA $SlotAssignmentMode $slotAssignment;
  ~RA $Element $host;
  attribute $EventHandler $onslotchange;
};

enum @ShadowRootMode { `open@l, `closed@l };
enum @SlotAssignmentMode { `manual@l, `named@l };
！

<p>
$ShadowRoot ~nodeは、単に
`~shadow根@
（ `shadow root^en ）とも称される。
◎
ShadowRoot nodes are simply known as shadow roots.
</p>

<div class="p">
<p>
各 `~shadow根$には、次に挙げるものが結付けられる：
</p>
<dl class="def-list">
	<dt>`~mode@sR</dt>
	<dd>
文字列 ~IN { `open$l, `closed$l }
</dd>

	<dt>`~focusを委譲するか@sR</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>

	<dt>`要素の内部特能から可用か@sR</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>

	<dt>`~slot割当n~mode@sR</dt>
	<dd>
文字列 ~IN { `manual$l, `named$l }
</dd>
</dl>

<p>
`~shadow根$の`~host$が ~NULL になることは決してない。
</p>
◎
Shadow roots have an associated mode ("open" or "closed").
◎
Shadow roots have an associated delegates focus. It is initially set to false.
◎
Shadow roots have an associated available to element internals. It is initially set to false.
◎
Shadow roots’s associated host is never null.
◎
Shadow roots have an associated slot assignment ("manual" or "named").
</div>

<p>
`~shadow根$ %根 の`親~targetを取得する$ときは、所与の
( ~event %~event )
に対し：
◎
A shadow root’s get the parent algorithm, given an event,＼
</p>
<ol>
	<li>
~IF［
%~event の`~composedか$ev ~EQ ~F
］~AND［
%根 ~EQ ［［［
%~event の`経路$
］内の最初の構造体
］の`呼出n~target$evP
］の`根$
］
⇒
~RET ~NULL
◎
returns null if event’s composed flag is unset and shadow root is the root of event’s path’s first struct’s invocation target;＼
</li>
	<li>
~RET %根 の`~host$
◎
otherwise shadow root’s host.
</li>
</ol>

<div class="algo">
@mode
取得子~手続きは
⇒
~RET コレの`~mode$sR
◎
The mode getter steps are to return this’s mode.
</div>

<div class="algo">
@delegatesFocus
取得子~手続きは
⇒
~RET コレの`~focusを委譲するか$sR
◎
The delegatesFocus getter steps are to return this’s delegates focus.
</div>

<div class="algo">
@slotAssignment
取得子~手続きは
⇒
~RET コレの`~slot割当n~mode$sR
◎
The slotAssignment getter steps are to return this’s slot assignment.
</div>

<div class="algo">
@host
取得子~手続きは
⇒
~RET コレの`~host$
◎
The host getter steps are to return this’s host.
</div>

<p>
@onslotchange
は、
`onslotchange@c
`~event~handler$用の`~event~handler~IDL属性$である
— その`~event~handler~event型$は `slotchange$et とする。
◎
The onslotchange attribute is an event handler IDL attribute for the onslotchange event handler, whose event handler event type is slotchange.
</p>

<hr>

<p>
`~node~tree$ %~tree における
`~shadowも含む~tree順序@
は、
`~shadowも含む深優先前順走査@
による順序であり，次に従う
⇒
%~tree に対する深優先前順走査
【すなわち，通常の~tree順序】
に従いつつ，
%~tree において［
`~shadow~host$である`要素$ %要素
］に遭遇した各所では，［［
%要素 の`~shadow根$elmを根とする`~node~tree$
］における，`~shadowも含む深優先前順走査$
］に従う。
◎
In shadow-including tree order is shadow-including preorder, depth-first traversal of a node tree. Shadow-including preorder, depth-first traversal of a node tree tree is preorder, depth-first traversal of tree, with for each shadow host encountered in tree, shadow-including preorder, depth-first traversal of that element’s shadow root’s node tree just after it is encountered.
</p>

<p>
~obj %O の
`~shadowも含む根@
とは、
%O の`根$を %根 とするとき，［
%根 は`~shadow根$であるならば %根 の`~host$の`~shadowも含む根$ ／
~ELSE_ %根
］である。
◎
The shadow-including root of an object is its root’s host’s shadow-including root, if the object’s root is a shadow root; otherwise its root.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子孫$である
］~OR［
%A の`根$は次を満たす
］
⇒
［
`~shadow根$である
］~AND［
その`~host$は %B の`~shadowも含む広義-子孫$である
］
◎
An object A is a shadow-including descendant of an object B, if A is a descendant of B, or A’s root is a shadow root and A’s root’s host is a shadow-including inclusive descendant of B.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義-子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む子孫$である
］
◎
A shadow-including inclusive descendant is an object or one of its shadow-including descendants.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む先祖@
であるとは、次を意味する
⇒
%B は %A の`~shadowも含む子孫$である
◎
An object A is a shadow-including ancestor of an object B, if and only if B is a shadow-including descendant of A.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義-先祖@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む先祖$である
］
◎
A shadow-including inclusive ancestor is an object or one of its shadow-including ancestors.
</p>

<p>
`~node$ %A が `~node$ %B からは
`閉な~shadowで非可視@
であるとは、
%A の`根$ %根 が次をすべて満たすことを意味する：
◎
A node A is closed-shadow-hidden from a node B if all of the following conditions are true:
</p>
<ul>
	<li>
%根 は`~shadow根$である
◎
A’s root is a shadow root.
</li>
	<li>
%根 は %B の`~shadowも含む広義-先祖$でない
◎
A’s root is not a shadow-including inclusive ancestor of B.
</li>
	<li>
［
%根 の`~mode$sR ~EQ `closed^l
］~OR［
%根 の`~host$は %B からは`閉な~shadowで非可視$である
］
◎
A’s root is a shadow root whose mode is "closed" or A’s root’s host is closed-shadow-hidden from B.
</li>
</ul>

<div class="algo">
<p>
~obj %A を ~obj %B に向けて
`~targetし直す@
ときは、次を走らす：
◎
To retarget an object A against an object B,＼
</p>
<ol>
	<li>
<p>
~WHILE 無条件：
◎
repeat these steps until they return an object:
</p>
		<ol>
			<li>
%根 ~LET %A の`根$
◎
↓</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following is true
</p>
				<ul>
					<li>
%A は`~node$でない
◎
A is not a node
</li>
					<li>
%根 は`~shadow根$でない
◎
A’s root is not a shadow root
</li>
					<li>
［
%B は`~node$である
］~AND［
%根 は %B の`~shadowも含む広義-先祖$である
］
◎
B is a node and A’s root is a shadow-including inclusive ancestor of B
</li>
				</ul>
<p>
…ならば
⇒
~RET %A
◎
then return A.
</p>
			</li>
			<li>
%A ~SET %根 の`~host$
◎
Set A to A’s root’s host.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
`~targetし直す$~algoは、~eventの`配送-$時, および
`FULLSCREEN$r などの他の仕様により利用される。
◎
The retargeting algorithm is used by event dispatch as well as other specifications, such as Fullscreen. [FULLSCREEN]
</p>

</div>

		</section>
		<section id="interface-element">
<h3 title="Interface Element">4.9. ^@Element ~interface</h3>

！！
[`Exposed$=Window]
interface @Element : $Node {
  ~RA $DOMString? $namespaceURI;
  ~RA $DOMString? $prefix;
  ~RA $DOMString $localName;
  ~RA $DOMString $tagName;

  [`CEReactions$] attribute $DOMString $id;
  [`CEReactions$] attribute $DOMString $className;
  [`SameObject$, `PutForwards$=$DOMTokenList.value] ~RA $DOMTokenList $classList;
  [`CEReactions$, `Unscopable$] attribute $DOMString $slot;

  $boolean $hasAttributes();
  [`SameObject$] ~RA $NamedNodeMap $attributes;
  $sequence&lt;$DOMString&gt; $getAttributeNames();
  $DOMString? $getAttribute($DOMString %qualifiedName);
  $DOMString? $getAttributeNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $undefined $setAttribute($DOMString %qualifiedName, $DOMString %value);
  [`CEReactions$] $undefined $setAttributeNS($DOMString? %namespace, $DOMString %qualifiedName, $DOMString %value);
  [`CEReactions$] $undefined $removeAttribute($DOMString %qualifiedName);
  [`CEReactions$] $undefined $removeAttributeNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $boolean $toggleAttribute($DOMString %qualifiedName, optional $boolean %force);
  $boolean $hasAttribute($DOMString %qualifiedName);
  $boolean $hasAttributeNS($DOMString? %namespace, $DOMString %localName);

  $Attr? $getAttributeNode($DOMString %qualifiedName);
  $Attr? $getAttributeNodeNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $Attr? $setAttributeNode($Attr %attr);
  [`CEReactions$] $Attr? $setAttributeNodeNS($Attr %attr);
  [`CEReactions$] $Attr $removeAttributeNode($Attr %attr);

  $ShadowRoot $attachShadow($ShadowRootInit %init);
  ~RA $ShadowRoot? $shadowRoot;

  $Element? $closest($DOMString %selectors);
  $boolean $matches($DOMString %selectors);
  $boolean $webkitMatchesSelector($DOMString %selectors); // <span class="comment" title="legacy alias of .matches">$matches の旧来の別名</span>

  $HTMLCollection $getElementsByTagName($DOMString %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS($DOMString? %namespace, $DOMString %localName);
  $HTMLCollection $getElementsByClassName($DOMString %classNames);

  [`CEReactions$] $Element? $insertAdjacentElement($DOMString %where, $Element %element); // <!--cp-legacy-->
  $undefined $insertAdjacentText($DOMString %where, $DOMString %data); // <!--cp-legacy-->
};

dictionary @@ShadowRootInit {
  required $ShadowRootMode @mode;
  boolean @delegatesFocus = false;
  $SlotAssignmentMode @slotAssignment = `named^l;
};
！

<p>
$@Element `~node$は、単に
`要素@
（ `element^en ）とも称される。
◎
Element nodes are simply known as elements.
</p>

<p>
各 `要素$には、次に挙げるものが結付けられ，いずれも`要素を作成する$ときに初期化される
⇒＃
`~ns@,
`~ns接頭辞@,
`局所~名@,
`~custom要素~状態@,
`~custom要素~定義@,
`~is0値@
◎
Elements have an associated namespace, namespace prefix, local name, custom element state, custom element definition, is value. When an element is created, all of these values are initialized.
</p>

<div class="p">
<p>
`要素$ %要素 の`~custom要素~状態$ %状態 は：
</p>

<ul>
	<li>
次のいずれかになるとする
⇒＃
`undefined^l,
`failed^l,
`uncustomized^l,
`precustomized^l,
`custom^l
</li>
	<li>
%要素 は次を満たすならば
`定義-済み@
とされる
⇒
%状態 ~IN { `uncustomized^l, `custom^l }
</li>
	<li>
%要素 は次を満たすならば
`~custom@
であるとされる
⇒
%状態 ~EQ `custom^l
</li>
</ul>
◎
An element’s custom element state is one of "undefined", "failed", "uncustomized", "precustomized", or "custom". An element whose custom element state is "uncustomized" or "custom" is said to be defined. An element whose custom element state is "custom" is said to be custom.
</div>

<p class="note">注記：
要素が`定義-済み$かどうかは、
<a href="~SELECTORS4#defined-pseudo"><code class="pseudo">:defined</code></a>
疑似類の挙動を決定するときに利用される。
要素が`~custom$であるかどうかは、
<a href="#mutation-algorithms">変異~algo</a>
の挙動を決定するときに利用される。
［
`failed^l, `precustomized^l
］状態は、`~custom要素~構築子$が初回に正しく実行するのに失敗した場合に，`要素を昇格する$ときに再び実行されないことを確保するために利用される。
◎
Whether or not an element is defined is used to determine the behavior of the :defined pseudo-class. Whether or not an element is custom is used to determine the behavior of the mutation algorithms. The "failed" and "precustomized" states are used to ensure that if a custom element constructor fails to execute correctly the first time, it is not executed again by an upgrade.
</p>

<div class="example">
<p>
要素がとり得るこれら 4 種の状態を，次の~codeで~~説明する：
◎
The following code illustrates elements in each of these four states:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  window.customElements.define(
    "sw-rey",
    class extends HTMLElement {}
  );
  window.customElements.define(
    "sw-finn",
    class extends HTMLElement {},
    { extends: "p" }
  );
  window.customElements.define(
    "sw-kylo",
    class extends HTMLElement {
      constructor() {
        /* <span class="comment">
`super()^c は、この例からは意図的に省略している。
◎
super() intentionally omitted for this example
</span> */
    }
  });
&lt;/script&gt;

&lt;!-- <span class="comment">
`undefined^l （`定義-済み$でも`~custom$でもない）
◎
"undefined" (not defined, not custom)
</span> --&gt;
&lt;sw-han&gt;&lt;/sw-han&gt;
&lt;p is="sw-luke"&gt;&lt;/p&gt;
&lt;p is="asdf"&gt;&lt;/p&gt;

&lt;!-- <span class="comment">
`failed^l （`定義-済み$でも`~custom$でもない）
◎
"failed" (not defined, not custom)
</span> --&gt;
&lt;sw-kylo&gt;&lt;/sw-kylo&gt;

&lt;!-- <span class="comment">
`uncustomized^l （`定義-済み$だが`~custom$ではない）
◎
"uncustomized" (defined, not custom)
</span> --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;asdf&gt;&lt;/asdf&gt;

&lt;!-- <span class="comment">
`custom^l （`定義-済み$かつ`~custom$である）
◎
"custom" (defined, custom)
</span> --&gt;
&lt;sw-rey&gt;&lt;/sw-rey&gt;
&lt;p is="sw-finn"&gt;&lt;/p&gt;
</pre>

</div>

<p>
各 `要素$には、
`~shadow根@elm
も結付けられる：
◎
Elements also have an associated shadow root＼
</p>

<ul>
	<li>
それは，［
~NULL ／ `~shadow根$
］であり、他が言明されない限り，~NULL とする。
◎
(null or a shadow root). It is null unless otherwise stated.＼
</li>
	<li>
~NULL でない場合、当の`要素$は
`~shadow~host@
であるとされる。
【すなわち，要素は、`~shadow根$elmを根とする ある`~shadow~tree$を~hostしている（言い換えれば、ある`~shadow根$の`~host$である）。】
◎
An element is a shadow host if its shadow root is non-null.
</li>
</ul>

<p>
`要素$ %要素 の
`有修飾~名@
は、
%要素 の`~ns接頭辞$ %接頭辞 に応じて，［
~NULL ならば %要素 の`局所~名$ ／
非 ~NULL ならば［
%接頭辞, `:^l, %要素 の`局所~名$
］の並び
］になる。
◎
An element’s qualified name is its local name if its namespace prefix is null; otherwise its namespace prefix, followed by ":", followed by its local name. 
</p>

<p>
`要素$ %要素 の
`~HTML大文字~化~有修飾~名@
は、次の手続きの結果を返す：
◎
An element’s HTML-uppercased qualified name is the return value of these steps:
</p>
<ol>
	<li>
%有修飾~名 ~LET %要素 の`有修飾~名$
◎
Let qualifiedName be this’s qualified name.
</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
~RET `~ASCII大文字~化する$( %有修飾~名 )
◎
If this is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII uppercase.
</li>
	<li>
~RET %有修飾~名
◎
Return qualifiedName.
</li>
</ol>

<p class="note">注記：
~UAは、`有修飾~名$と`~HTML大文字~化~有修飾~名$を内部~slotに格納して最適化することもできる。
◎
User agents could optimize qualified name and HTML-uppercased qualified name by storing them in internal slots.
</p>

<div class="algo">
<p>
`要素を作成する@
ときは、所与の
⇒＃
%文書,
%局所~名,
%~ns,
%接頭辞 （省略時は ~NULL ）,
%is （省略時は ~NULL ）,
%同期~custom要素~flag ~IN { `同期~custom要素^i, ε }（省略時は ε ）
◎終
に対し，次の手続きを走らす：
◎
To create an element, given a document, localName, namespace, and optional prefix, is, and synchronous custom elements flag, run these steps:
</p>
<ol>
	<li>
%結果 ~LET ~NULL
◎
If prefix was not given, let prefix be null.
◎
If is was not given, let is be null.
◎
Let result be null.
</li>
	<li>
%定義 ~LET `~custom要素~定義を検索する$( %文書, %~ns, %局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given document, namespace, localName, and is.
</li>
	<li>
<p>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`名前$cD ~NEQ %定義 の`局所~名$cD
］（すなわち，%定義 は`~custom化された組込みの要素$を表現する）：
◎
If definition is non-null, and definition’s name is not equal to its local name (i.e., definition represents a customized built-in element), then:
</p>
		<ol>
			<li>
%~interface ~LET ( %局所~名, `~HTML~ns$ ) 用の`要素~interface$
◎
Let interface be the element interface for localName and the HTML namespace.
</li>
			<li>
<p>
%結果 ~SET %~interface を実装し, 次のように設定された新たな`要素$
⇒＃
`属性o~list$ ~SET 新たな`~list$,
`~ns$ ~SET `~HTML~ns$,
`~ns接頭辞$ ~SET %接頭辞 ,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `undefined^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET %is,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to is, and node document set to document.
</li>
			<li>
<p>
~IF［
%同期~custom要素~flag ~NEQ ε
］
⇒
`要素を昇格する$( %定義, %要素 )
◎
If the synchronous custom elements flag is set, then run this step while catching any exceptions:
• Upgrade element using definition.
</p>

<p>
この段から例外が投出されたときは、~catchして：
◎
If this step threw an exception, then:
</p>
				<ol>
					<li>
その`例外を報告する$
◎
Report the exception.
</li>
					<li>
%結果 の`~custom要素~状態$ ~SET `failed^l
◎
Set result’s custom element state to "failed".
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`~custom要素~昇格~反応を~enqueueする$( %結果, %定義 )
◎
Otherwise, enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］~AND［
%同期~custom要素~flag ~NEQ ε
］：
◎
Otherwise, if definition is non-null, then:
</p>

<p>
この段から例外が投出されたときは、~catchして，下の (A) に~~移行するとする
◎
If the synchronous custom elements flag is set, then run these steps while catching any exceptions:
</p>
		<ol>
			<li>
%C ~LET %定義 の`構築子$cD
◎
Let C be definition’s constructor.
</li>
			<li>
%結果 ~SET `~callback関数で構築する$( %C, 空な引数~list )
◎
Set result to the result of constructing C, with no arguments.
</li>
			<li>
~Assert：
%結果 の［
`~custom要素~状態$, `~custom要素~定義$
］は初期化-済みである
◎
Assert: result’s custom element state and custom element definition are initialized.
</li>
			<li>
<p>
~Assert：
%結果 の`~ns$ ~EQ `~HTML~ns$
◎
Assert: result’s namespace is the HTML namespace.
</p>

<p class="note">注記：
~IDLにより， %結果 は $HTMLElement ~objになるよう施行され、そのような~objは，すべて`~HTML~ns$を利用する。
◎
IDL enforces that result is an HTMLElement object, which all use the HTML namespace.
</p>
			</li>
			<li>
<p>
~IF［
%結果 は下に挙げるいずれかを満たす
］
⇒
~THROW `NotSupportedError$E：
◎
↓</p>
				<ul>
					<li>
%結果 の`属性o~list$は`空$でない
◎
If result’s attribute list is not empty, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 は`子$を持つ
◎
If result has children, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 の`親$ ~NEQ ~NULL
◎
If result’s parent is not null, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 の`~node文書$ ~NEQ %文書
◎
If result’s node document is not document, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 の`局所~名$ ~NEQ %局所~名
◎
If result’s local name is not equal to localName, then throw a "NotSupportedError" DOMException.
</li>
				</ul>
			</li>
			<li>
%結果 の`~ns接頭辞$ ~SET %接頭辞
◎
Set result’s namespace prefix to prefix.
</li>
			<li>
%結果 の`~is0値$ ~SET ~NULL
◎
Set result’s is value to null.
</li>
		</ol>
<p>
(A)
— 上の手続きにて，例外が投出されたときは：
◎
If any of these steps threw an exception, then:
</p>
		<ol>
			<li>
その`例外を報告する$
◎
Report the exception.
</li>
			<li>
<p>
%結果 ~SET 次のように設定された新たな`要素$
⇒＃
$HTMLUnknownElement ~interfaceを実装する,
`属性o~list$ ~SET 新たな`~list$,
`~ns$ ~SET `~HTML~ns$,
`~ns接頭辞$ ~SET %接頭辞,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `failed^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET ~NULL,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements the HTMLUnknownElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "failed", custom element definition set to null, is value set to null, and node document set to document.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］：
◎
↑
◎
Otherwise:
</p>
		<ol>
			<li>
<p>
%結果 ~SET 次のように設定された新たな`要素$
⇒＃
$HTMLElement を実装する,
`属性o~list$ ~SET 新たな`~list$,
`~ns$ ~SET `~HTML~ns$,
`~ns接頭辞$ ~SET %接頭辞 ,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `undefined^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET ~NULL,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements the HTMLElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to null, and node document set to document.
</li>
			<li>
`~custom要素~昇格~反応を~enqueueする$( %結果, %定義 )
◎
Enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~interface ~LET ( %局所~名, %~ns ) 用の`要素~interface$
◎
Let interface be the element interface for localName and namespace.
</li>
			<li>
<p>
%結果 ~SET %~interface を実装し, 次のように設定された新たな`要素$
⇒＃
`属性o~list$ ~SET 新たな`~list$,
`~ns$ ~SET %~ns,
`~ns接頭辞$ ~SET %接頭辞 ,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `uncustomized^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET %is,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements interface, with no attributes, namespace set to namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "uncustomized", custom element definition set to null, is value set to is, and node document set to document.
</li>
			<li>
<p>
~IF［
次のいずれも満たされる
］…：
</p>

<ul ><li>%~ns ~EQ `~HTML~ns$
</li><li>［
%局所~名 は`妥当な~custom要素~名$である
］~OR［
%is ~NEQ ~NULL
］
</li></ul>

<p>
…ならば
⇒
%結果 の`~custom要素~状態$ ~SET `undefined^l
</p>
◎
If namespace is the HTML namespace, and either localName is a valid custom element name or is is non-null, then set result’s custom element state to "undefined".
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<p>
各`要素$は、
`属性o~list@
も持つ。
それは、`~list$であり，
$NamedNodeMap
【~objを返す $attributes 属性】
を通して公開される。
`要素$の作成-時に明示的に与えられない限り，その`属性o~list$は`空$とする。
◎
Elements also have an attribute list, which is a list exposed through a NamedNodeMap. Unless explicitly given when an element is created, its attribute list is empty.
</p>

<p>
`要素$ %要素 の`属性o~list$内に`属性o$ %属性o が在ることを，
%要素 は %属性o を
`有する@
（ `has^en ）ともいう。
◎
An element has an attribute A if its attribute list contains A.
</p>

<p class="trans-note">【
この場合、［
%属性o が`属する要素$ ~EQ %要素
］も満たすことになる
— 複数の`要素$が同じ`属性o$を`有する$ことはない（~algo内で同期的に遂行される ある瞬間を除いて）。
】【
“有する” という句は、他の仕様（主に~HTML）で利用されている。
しかしながら，この訳では、この用語を（この仕様~内では）利用せず，一律に`属性o~list$（適用-可能な所では`属する要素$）を通して述べることにする。
】</p>

<p>
`適用-可能な仕様$は、`要素$上の
`属性o変更-時の手続き@
を定義してもヨイ。
この~algoは、当の要素に加えて，
( %局所~名, %旧-値, %値, %~ns )
を渡して呼出される。
◎
This and other specifications may define attribute change steps for elements. The algorithm is passed element, localName, oldValue, value, and namespace.
</p>

<div class="algo">
<p>
`属性~変化を取扱う@
ときは、所与の
( `属性o$ %属性o, %要素, %旧-値, %新-値 )
に対し，次を走らす：
◎
To handle attribute changes for an attribute attribute with element, oldValue, and newValue, run these steps:
</p>
<ol>
	<li>
%要素 用に種別 `attributes^l の`変異~記録を~queueする$( 次に挙げる引数 )
⇒＃
%属性o の`局所~名$a,
%属性o の`~ns$a,
%旧-値,
« »,
« »,
~NULL,
~NULL
◎
Queue a mutation record of "attributes" for element with attribute’s local name, attribute’s namespace, oldValue, « », « », null, and null.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$a, %旧-値, %新-値, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, oldValue, newValue, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 の`属性o変更-時の手続き$を走らす
⇒
( %属性o の`局所~名$a, %旧-値, %新-値, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, oldValue, newValue, and attribute’s namespace.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを変更する@
ときは、所与の
( `属性o$ %属性o, %値 )
に対し，次を走らす：
◎
To change an attribute attribute to value, run these steps:
</p>
<ol>
	<li>
`属性~変化を取扱う$( %属性o, %属性o が`属する要素$, %属性o の`値$a, %値 )
◎
Handle attribute changes for attribute with attribute’s element, attribute’s value, and value.
</li>
	<li>
%属性o の`値$a ~SET %値
◎
Set attribute’s value to value.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを付加する@
ときは、所与の
( `属性o$ %属性o, `要素$ %要素 )
に対し，次を走らす：
◎
To append an attribute attribute to an element element, run these steps:
</p>
<ol>
	<li>
`属性~変化を取扱う$( %属性o, %要素, ~NULL, %属性o の`値$a )
◎
Handle attribute changes for attribute with element, null, and attribute’s value.
</li>
	<li>
%要素 の`属性o~list$に %属性o を`付加する$
◎
Append attribute to element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET %要素 
◎
Set attribute’s element to element.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを除去する@
ときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To remove an attribute attribute, run these steps:
</p>
<ol>
	<li>
`属性~変化を取扱う$( %属性o, %属性o が`属する要素$, %属性o の`値$a, ~NULL )
◎
Handle attribute changes for attribute with attribute’s element, attribute’s value, and null.
</li>
	<li>
%属性o が`属する要素$の`属性o~list$から %属性o を`除去する$
◎
Remove attribute from attribute’s element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET ~NULL
◎
Set attribute’s element to null.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを置換する@
ときは、所与の
( `属性o$ %旧-属性o, `属性o$ %新-属性o )
に対し，次を走らす：
◎
To replace an attribute oldAttr with an attribute newAttr, run these steps:
</p>
<ol>
	<li>
`属性~変化を取扱う$( %旧-属性o, %旧-属性o が`属する要素$, %旧-属性o の`値$a, %新-属性o の`値$a )
◎
Handle attribute changes for oldAttr with oldAttr’s element, oldAttr’s value, and newAttr’s value.
</li>
	<li>
%旧-属性o が`属する要素$の`属性o~list$内で，
%旧-属性o を %新-属性o に`置換する$
◎
Replace oldAttr by newAttr in oldAttr’s element’s attribute list.
</li>
	<li>
%新-属性o が`属する要素$ ~SET %旧-属性o が`属する要素$
◎
Set newAttr’s element to oldAttr’s element.
</li>
	<li>
%旧-属性o が`属する要素$ ~SET ~NULL
◎
Set oldAttr’s element to null.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを名前により取得する@
ときは、所与の
( %有修飾~名 )
に対し，次を走らす：
◎
To get an attribute by name given a qualifiedName and element element, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%有修飾~名 ~LET `~ASCII小文字~化する$( %有修飾~名 )
◎
If element is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
	<li>
~RET %要素 の`属性o~list$ 内の次を満たす`属性o$のうち，`最初のもの？$
⇒
`有修飾~名$a ~EQ %有修飾~名
◎
Return the first attribute in element’s attribute list whose qualified name is qualifiedName; otherwise null.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを~nsと局所~名により取得する@
ときは、所与の
( %~ns, %局所~名 )
に対し、次を走らす：
◎
To get an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>
<ol>
	<!--cp-normalize-ns-->
	<li>
~RET %要素 の`属性o~list$ 内の 次を満たす`属性o$のうち，`最初のもの？$
⇒
［
`~ns$a ~EQ %~ns
］~AND［
`局所~名$a ~EQ %局所~名
］
◎
Return the attribute in element’s attribute list whose namespace is namespace and local name is localName, if any; otherwise null.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性o値を取得する@
ときは、所与の
( %局所~名,  %~ns （省略時は ~NULL ） )
に対し，次を走らす：
◎
To get an attribute value given an element element, localName, and optionally a namespace (null unless stated otherwise), run these steps:
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %局所~名,  %~ns )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~RET ［
%属性o ~EQ ~NULL ならば空~文字列 ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, then return the empty string.
◎
Return attr’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを設定する@
ときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To set an attribute given an attr and element, run these steps:
</p>
<ol>
	<li>
~IF［
%属性o が`属する要素$ ~NIN { ~NULL, %要素 }
］
⇒
~THROW `InUseAttributeError$E
◎
If attr’s element is neither null nor element, throw an "InUseAttributeError" DOMException.
</li>
	<li>
%旧-属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %属性o の`~ns$a, %属性o の`局所~名$a )
◎
Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local name, and element.
</li>
	<li>
~IF［
%旧-属性o ~EQ %属性o
］
⇒
~RET %属性o
◎
If oldAttr is attr, return attr.
</li>
	<li>
~IF［
%旧-属性o ~NEQ ~NULL
］
⇒
`属性oを置換する$( %旧-属性o, %属性o )
◎
If oldAttr is non-null, then replace oldAttr with attr.
</li>
	<li>
~ELSE
⇒
`属性oを付加する$( %属性o, %要素 )
◎
Otherwise, append attr to element.
</li>
	<li>
~RET %旧-属性o
◎

Return oldAttr.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性o値を設定する@
ときは、所与の
( %局所~名, %値, %接頭辞 （省略時は ~NULL ）, %~ns （省略時は ~NULL ） )
に対し，次を走らす：
◎
To set an attribute value for an element element, using a localName and value, and an optional prefix, and namespace, run these steps:
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
If prefix is not given, set it to null.
◎
If namespace is not given, set it to null.
◎
Let attribute be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒＃
`属性oを変更する$( %属性o, %値 )；
~RET
◎
↓</li>
	<li>
`属性oを付加する$( 次のように設定された新たな`属性o$, %要素 )
⇒＃
`~ns$a ~SET %~ns,
`~ns接頭辞$a ~SET %接頭辞,
`局所~名$a ~SET %局所~名,
`値$a ~SET %値,
`~node文書$ ~SET %要素 の`~node文書$
◎
If attribute is null, create an attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, value is value, and node document is element’s node document, then append this attribute to element, and then return.
◎
Change attribute to value.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを名前により除去する@
ときは、所与の
( %有修飾~名 )
に対し，次を走らす：
◎
To remove an attribute by name given a qualifiedName and element element, run these steps:
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを名前により取得する$( %有修飾~名 )
◎
Let attr be the result of getting an attribute given qualifiedName and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
`属性oを除去する$( %属性o )
◎
If attr is non-null, then remove attr.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを~nsと局所~名により除去する@
ときは、所与の
( %~ns, %局所~名 )
に対し，次を走らす：
◎
To remove an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
`属性oを除去する$( %属性o )
◎
If attr is non-null, then remove attr.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

<hr>

<p>
`要素$には、一意な識別子である
`~ID@
が結付けられ得る。
◎
An element can have an associated unique identifier (ID)
</p>
<p class="note">注記：
歴史的に，`要素$は複数の識別子を持ち得ていた。
例えば~HTML `id^A `属性o$nmと DTD を利用して。
この仕様では
`~ID$を~DOMの概念とし，`要素$につき `id^A `属性o$nmで与えられる 1 個に限るとする。
◎
Historically elements could have multiple identifiers e.g., by using the HTML id attribute and a DTD. This specification makes ID a concept of the DOM and allows for only one per element, given by an id attribute.
</p>

<div class="algo">
<p>
`要素$の`~ID$を更新するときは、`属性o変更-時の手続き$として次を利用する
— それは、所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
Use these attribute change steps to update an element’s ID:
</p>
<ol>
	<li>
~IF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］~AND［
%値 ~IN { ~NULL, 空~文字列 }
］
⇒
%要素 の`~ID$を未設定にする
◎
If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
</li>
	<li>
~ELIF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］
⇒
%要素 の`~ID$ ~SET %値
◎
Otherwise, if localName is id, namespace is null, then set element’s ID to value.
</li>
</ol>
</div>

<p class="note">注記：
この仕様は、どの`要素$に対しても，その［
`id^A ／ `class^A ／ `slot^A
］`属性o$nm用の要件を定義しているが、これらの属性oを利用をするかどうかは，適合性の要件にしていない。
◎
While this specification defines requirements for class, id, and slot attributes on any element, it makes no claims as to whether using them is conforming or not.
</p>

<hr>

<p>
`~node$ %N の
`親~要素@
とは、［
%N の`親$が`要素$であるならば それ ／
~ELSE_ ~NULL
］である。
◎
A node’s parent of type Element is known as its parent element. If the node has a parent of a different type, its parent element is null.
</p>

<hr>

<dl class="domintro">
	<dt>%namespace = %element . $namespaceURI</dt>
	<dd>
`~ns$を返す。
◎
Returns the namespace.
</dd>

	<dt>%prefix = %element . $prefix</dt>
	<dd>
`~ns接頭辞$を返す。
◎
Returns the namespace prefix.
</dd>

	<dt>%localName = %element . $localName</dt>
	<dd>
`局所~名$を返す。
◎
Returns the local name.
</dd>

	<dt>%qualifiedName = %element . $tagName</dt>
	<dd>
`~HTML大文字~化~有修飾~名$を返す。
◎
Returns the HTML-uppercased qualified name.
</dd>
</dl>

<div class="algo">
@namespaceURI
取得子~手続きは
⇒
~RET コレの`~ns$
◎
The namespaceURI getter steps are to return this’s namespace.
</div>

<div class="algo">
@prefix
取得子~手続きは
⇒
~RET コレの`~ns接頭辞$
◎
The prefix getter steps are to return this’s namespace prefix.
</div>

<div class="algo">
@localName
取得子~手続きは
⇒
~RET コレの`局所~名$
◎
The localName getter steps are to return this’s local name.
</div>

<div class="algo">
@tagName
取得子~手続きは
⇒
~RET コレの`~HTML大文字~化~有修飾~名$
◎
The tagName getter steps are to return this’s HTML-uppercased qualified name.
</div>

<hr>

<dl class="domintro">
	<dt>%element . $id [ = %value ]</dt>
	<dd>
%element の `id^A 属性oの値を返す。
設定して変更できる。
◎
Returns the value of element’s id content attribute. Can be set to change it.
</dd>

	<dt>%element . $className [ = %value  ]</dt>
	<dd>
%element の `class^A 属性oの値を返す。
設定して変更できる。
◎
Returns the value of element’s class content attribute. Can be set to change it.
</dd>

	<dt>%element . $classList</dt>
	<dd>
%element の `class^A 属性oを，空白で分離された~tokenの集合として
— $DOMTokenList ~objを通して —
操作できるようにする。
◎
Allows for manipulation of element’s class content attribute as a set of whitespace-separated tokens through a DOMTokenList object.
</dd>

	<dt>%element . $slot [ = %value  ]</dt>
	<dd>
%element の `slot^A 属性oを返す。
設定して変更できる。
◎
Returns the value of element’s slot content attribute. Can be set to change it.
</dd>
</dl>

<div class="algo">
<p>
`要素$ %要素 上の一部の~IDL属性は、所与の %名前 の`属性o$を
`反映する@
ように定義される。
すなわち、次に従うような取得子, 設定子を持つモノトスル：
◎
IDL attributes that are defined to reflect a content attribute of a given name, must have a getter and setter that follow these steps:
</p>

<dl>
	<dt>取得子</dt>
	<dd>
~RET %要素 の`属性o値を取得する$( %名前 )
◎
Return the result of running get an attribute value given this and name.
</dd>

	<dt>設定子</dt>
	<dd>
%要素 の`属性o値を設定する$( %名前, 所与の値 )
◎
Set an attribute value for this using name and the given value.
</dd>
</dl>
</div>

<p>
@id
属性は、
`id^l 属性oを`反映する$モノトスル。
◎
The id attribute must reflect the "id" content attribute.
</p>

<p>
@className
属性は、
`class^l 属性oを`反映する$モノトスル。
◎
The className attribute must reflect the "class" content attribute.
</p>

<div class="algo">
<p>
@classList
取得子~手続きは
⇒
~RET 次のように設定された $DOMTokenList
⇒＃
`要素$tL ~SET コレ,
`属性oの局所~名$tL ~SET ^class
◎
The classList getter steps are to return a DOMTokenList object whose associated element is this and whose associated attribute’s local name is class.＼
</p>

<p>
この取得子が返す $DOMTokenList ~objの`~token集合$tLは、`要素$の
`~classes@
とも称される。
◎
The token set of this particular DOMTokenList object are also known as the element’s classes.
</p>

<p class="trans-note">【
[`SameObject$] が指定されているので、各~要素とこの~objの各~instanceは，一対一に対応する。
】</p>

</div>

<p>
@slot
属性は、
`slot^l 属性oを`反映する$モノトスル。
◎
The slot attribute must reflect the "slot" content attribute.
</p>

<p class="note">注記：
［
`id^A ／ `class^A ／ `slot^A
］`属性o$nmは、要素の~nsにかかわらず どの要素~上にも現れ得るので、実質的に，（すべての~nsより）上位の大域~属性になる。
◎
id, class, and slot are effectively superglobal attributes as they can appear on any element, regardless of that element’s namespace.
</p>

<hr>

<dl class="domintro">

	<dt>%element . $hasAttributes()</dt>
	<dd>
%element の`属性o~list$は［
`空$でないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if element has attributes; otherwise false.
</dd>

	<dt>%element . $getAttributeNames()</dt>
	<dd>
%element のすべての`属性o$の`有修飾~名$aを返す
— 重複を包含し得る。
◎
Returns the qualified names of all element’s attributes. Can contain duplicates.
</dd>

	<dt>%element . $getAttribute(qualifiedName)</dt>
	<dd>
%element の`属性o~list$内の`属性o$のうち次を満たす`最初のもの？$を返す
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Returns element’s first attribute whose qualified name is qualifiedName, and null if there is no such attribute otherwise.
</dd>

	<dt>%element . $getAttributeNS(namespace, localName)</dt>
	<dd>
%element の`属性o~list$内の`属性o$のうち次を満たす`最初のもの？$を返す
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Returns element’s attribute whose namespace is namespace and local name is localName, and null if there is no such attribute otherwise.
</dd>

	<dt>%element . $setAttribute(qualifiedName, value)</dt>
	<dd>
%element の`属性o~list$内に次を満たす`属性o$が在るならば［
それらのうち最初のもの
］の`値$aを %value に設定する
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Sets the value of element’s first attribute whose qualified name is qualifiedName to value.
</dd>

	<dt>%element . $setAttributeNS(namespace, localName, value)</dt>
	<dd>
%element の`属性o~list$内に次を満たす`属性o$が在るならば［
それらのうち最初のもの
］の`値$aを %value に設定する
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Sets the value of element’s attribute whose namespace is namespace and local name is localName to value.
</dd>

	<dt>%element . $removeAttribute(qualifiedName)</dt>
	<dd>
%element の`属性o~list$内に次を満たす`属性o$が在るならば［
それらのうち最初のもの
］を %element から除去する
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Removes element’s first attribute whose qualified name is qualifiedName.
</dd>

	<dt>%element . $removeAttributeNS(namespace, localName)</dt>
	<dd>
%element の`属性o~list$内に次を満たす`属性o$が在るならば［
それらのうち最初のもの
］を %element から除去する
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Removes element’s attribute whose namespace is namespace and local name is localName.
</dd>

	<dt>%element . $toggleAttribute(qualifiedName [, force])</dt>
	<dd>
<p>
%force に応じて：
</p>
		<ul>
			<li>
省略されているならば、
%qualifiedName の有無を “切り替える”
— すなわち，それがすでに在れば除去し，無ければ追加する。
</li>
			<li>
~T ならば、
%qualifiedName を追加する。
</li>
			<li>
~F ならば、
%qualifiedName を除去する。
</li>
		</ul>
<p>
その結果、
%qualifiedName が［
残っていれば ~T ／
無くなっていれば ~F
］を返す。
</p>

◎
If force is not given, "toggles" qualifiedName, removing it if it is present and adding it if it is not present. If force is true, adds qualifiedName. If force is false, removes qualifiedName.
◎
Returns true if qualifiedName is now present; otherwise false.
</dd>

	<dt>%element . $hasAttribute(qualifiedName)</dt>
	<dd>
%element の`属性o~list$内に次を満たす`属性o$が［
在るならば ~T ／
無いならば ~F
］を返す
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Returns true if element has an attribute whose qualified name is qualifiedName; otherwise false.
</dd>

	<dt>%element . $hasAttributeNS(namespace, localName)</dt>
	<dd>
%element の`属性o~list$内に次を満たす`属性o$が［
在るならば ~T ／
無いならば ~F
］を返す
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Returns true if element has an attribute whose namespace is namespace and local name is localName.
</dd>
</dl>

<div class="algo">
@hasAttributes()
~method~手続きは
⇒
~RET ［
コレの`属性o~list$は`空$ならば ~F ／
~ELSE_ ~T
］
◎
The hasAttributes() method steps are to return false if this’s attribute list is empty; otherwise true.
</div>

<div class="algo">
@attributes
取得子~手続きは
⇒
~RET コレに結付けられている $NamedNodeMap
◎
The attributes getter steps are to return the associated NamedNodeMap.
</div>

<div class="algo">
<p>
@getAttributeNames()
~method~手続きは
⇒
~RET コレの`属性o~list$ %~list は［
`空$でないならば［
%~list 内の各 `属性o$の`有修飾~名$a
］からなる同じ順序の`~list$ ／
~ELSE_ 新たな`~list$
］
◎
The getAttributeNames() method steps are to return the qualified names of the attributes in this’s attribute list, in order; otherwise a new list.
</p>

<p class="note">注記：
一意になることは保証されない。
◎
These are not guaranteed to be unique.
</p>
</div>

<div class="algo">
<p>
@getAttribute(qualifiedName)
~method~手続きは：
◎
The getAttribute(qualifiedName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET
コレの`属性oを名前により取得する$( %qualifiedName )
◎
Let attr be the result of getting an attribute given qualifiedName and this.
</li>
	<li>
~RET ［
%属性o ~EQ ~NULL ならば ~NULL ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, return null.
◎
Return attr’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
@getAttributeNS(namespace, localName)
~method~手続きは：
◎
The getAttributeNS(namespace, localName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET
コレの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
Let attr be the result of getting an attribute given namespace, localName, and this.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If attr is null, return null.
</li>
	<li>
~RET %属性o の`値$a
◎
Return attr’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
@setAttribute(qualifiedName, value)
~method~手続きは：
◎
The setAttribute(qualifiedName, value) method steps are:
</p>
<ol>
	<li id="cp-throw-if-non-xml-name">
~IF［
%qualifiedName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If qualifiedName does not match the Name production in XML, then throw an "InvalidCharacterError" DOMException.
</li>
	<li id="cp-to-lowercase-if-html">
~IF［
コレは`~HTML~ns$に属する
］~AND［
コレの`~node文書$は`~HTML文書$である
］
⇒
%qualifiedName ~SET `~ASCII小文字~化する$( %qualifiedName )
◎
If this is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
	<li id="cp-first-attr-with-qname">
%属性o ~LET コレの`属性o~list$内に在る`属性o$のうち，次を満たす`最初のもの？$
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Let attribute be the first attribute in this’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
`属性oを付加する$( 次のように設定された新たな`属性o$, コレ )
⇒＃
`局所~名$a ~SET %qualifiedName,
`値$a ~SET %value,
`~node文書$ ~SET コレの`~node文書$
◎
If attribute is null, create an attribute whose local name is qualifiedName, value is value, and node document is this’s node document, then append this attribute to this, and then return.
</li>
	<li>
~ELSE
⇒
`属性oを変更する$( %属性o, %value )
◎
Change attribute to value.
</li>
</ol>
</div>

<div class="algo">
<p>
@setAttributeNS(namespace, qualifiedName, value)
~method~手続きは：
◎
The setAttributeNS(namespace, qualifiedName, value) method steps are:
</p>
<ol>
	<!--cp-validate-and-extract-->
	<li>
コレの`属性o値を設定する$( %局所~名, %value, %接頭辞, %~ns )
◎
Set an attribute value for this using localName, value, and also prefix and namespace.
</li>
</ol>
</div>

<div class="algo">
@removeAttribute(qualifiedName)
~method~手続きは
⇒
コレの`属性oを名前により除去する$( %qualifiedName )
【！ ＊and then return undefined.】
◎
The removeAttribute(qualifiedName) method steps are to remove an attribute given qualifiedName and this, and then return undefined.
</div>

<div class="algo">
@removeAttributeNS(namespace, localName)
~method~手続きは
⇒
コレの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
【！＊and then return undefined.】
◎
The removeAttributeNS(namespace, localName) method steps are to remove an attribute given namespace, localName, and this, and then return undefined.
</div>

<div class="algo">
<p>
@hasAttribute(qualifiedName)
~method~手続きは：
◎
The hasAttribute(qualifiedName) method steps are:
</p>
		<ol>
			<!--cp-to-lowercase-if-html-->
			<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
コレの`属性o~list$内に次を満たす`属性o$は在る
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Return true if this has an attribute whose qualified name is qualifiedName; otherwise false.
</li>
		</ol>
</div>

<div class="algo">
<p>
@toggleAttribute(qualifiedName, force)
~method~手続きは：
◎
The toggleAttribute(qualifiedName, force) method steps are:
</p>
<ol>
	<!--cp-throw-if-non-xml-name-->
	<!--cp-to-lowercase-if-html-->
	<!--cp-first-attr-with-qname-->
	<li>
%結果 ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%force ~EQ ~T
］~OR［［
%force ~EQ ε
］~AND［
%属性o ~EQ ~NULL
］］
◎
↓</li>
	<li>
~IF［
%結果 ~EQ ~T
］~AND［
%属性o ~EQ ~NULL
］
⇒
`属性oを付加する$( 次のように設定された新たな`属性o$, コレ )
⇒＃
`局所~名$a ~SET %qualifiedName,
`値$a ~SET 空~文字列,
`~node文書$ ~SET コレの`~node文書$
◎
If attribute is null, then:
• If force is not given or is true, create an attribute whose local name is qualifiedName, value is the empty string, and node document is this’s node document, then append this attribute to this, and then return true.
• Return false.
</li>
	<li>
~ELIF［
%結果 ~EQ ~F
］~AND［
%属性o ~NEQ ~NULL
］
⇒＃
コレの`属性oを名前により除去する$( %qualifiedName )；
◎
Otherwise, if force is not given or is false, remove an attribute given qualifiedName and this, and then return false.
</li>
	<li>
~RET %結果
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
@hasAttributeNS(namespace, localName)
~method~手続きは：
◎
The hasAttributeNS(namespace, localName) method steps are:
</p>
<ol>
	<!--cp-normalize-ns0-->
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
コレの`属性o~list$内に次を満たす`属性o$が在る
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Return true if this has an attribute whose namespace is namespace and local name is localName; otherwise false.
</li>
</ol>
</div>

<div class="algo">
@getAttributeNode(qualifiedName)
~method~手続きは
⇒
~RET コレの`属性oを名前により取得する$( %qualifiedName )
◎
The getAttributeNode(qualifiedName) method steps are to return the result of getting an attribute given qualifiedName and this.
</div>

<div class="algo">
@getAttributeNodeNS(namespace, localName)
~method~手続きは
⇒
~RET コレの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getAttributeNodeNS(namespace, localName) method steps are to return the result of getting an attribute given namespace, localName, and this.
</div>

<div class="algo">
@setAttributeNode(attr),
@setAttributeNodeNS(attr)
~method~手続きは、いずれも
⇒
~RET コレの`属性oを設定する$( %attr )
◎
The setAttributeNode(attr) and setAttributeNodeNS(attr) methods steps are to return the result of setting an attribute given attr and this.
</div>

<div class="algo">
<p>
@removeAttributeNode(attr)
~method~手続きは：
◎
The removeAttributeNode(attr) method steps are:
</p>
<ol>
	<li>
~IF［
%attr ~NIN コレの`属性o~list$
］
⇒
~THROW `NotFoundError$E
◎
If this’s attribute list does not contain attr, then throw a "NotFoundError" DOMException.
</li>
	<li>
`属性oを除去する$( %attr )
◎
Remove attr.
</li>
	<li>
~RET %attr
◎
Return attr.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%shadow = %element . $attachShadow(init)</dt>
	<dd>
%element 用に`~shadow根$を作成した上で，それを返す。
◎
Creates a shadow root for element and returns it.
</dd>

	<dt>%shadow = %element . $shadowRoot</dt>
	<dd>
%element の`~shadow根$elm %~shadow は非~NULL，かつ %~shadow の［
`~mode$sR ~EQ `open^l
］ならば %~shadow を返す。
他の場合は ~NULL を返す。
◎
Returns element’s shadow root, if any, and if shadow root’s mode is "open", and null otherwise.
</dl>

<div class="algo">
<p>
@attachShadow(init)
~method~手続きは：
◎
The attachShadow(init) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`~ns$ ~NEQ `~HTML~ns$
］
⇒
~THROW `NotSupportedError$E
◎
If this’s namespace is not the HTML namespace, then throw a "NotSupportedError" DOMException.
</li>
	<li>
<p>
~IF［
コレの`局所~名$は 次に挙げるいずれでもない
］…：
◎
If this’s local name is not one of the following:
</p>
		<ul>
			<li>
`妥当な~custom要素~名$
◎
a valid custom element name
</li>
			<li>
`article^l,
`aside^l,
`blockquote^l,
`body^l,
`div^l,
`footer^l,
`h1^l,
`h2^l,
`h3^l,
`h4^l,
`h5^l,
`h6^l,
`header^l,
`main^l,
`nav^l,
`p^l,
`section^l,
`span^l
◎
"article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", or "span"
</li>
		</ul>
<p>
…ならば
⇒
~THROW `NotSupportedError$E
◎
then throw a "NotSupportedError" DOMException.
</p>
	</li>
	<li>
<p>
~IF［
コレの`局所~名$は`妥当な~custom要素~名$である
］~OR［
コレの`~is0値$ ~NEQ ~NULL
］：
◎
If this’s local name is a valid custom element name, or this’s is value is not null, then:
</p>
		<ol>
			<li>
%定義 ~LET `~custom要素~定義を検索する$( コレの`~node文書$, コレの`~ns$, コレの`局所~名$, コレの`~is0値$ )
◎
Let definition be the result of looking up a custom element definition given this’s node document, its namespace, its local name, and its is value.
</li>
		<li>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`~shadowを不能化するか$cD ~EQ ~T
］
⇒
~THROW `NotSupportedError$E
◎
If definition is not null and definition’s disable shadow is true, then throw a "NotSupportedError" DOMException.
</li>
		</ol>
	</li>
	<li>
~IF［
コレは`~shadow~host$である
］
⇒
~THROW `NotSupportedError$E
◎
If this is a shadow host, then throw an "NotSupportedError" DOMException.
</li>
	<li>
%~shadow ~LET 次のように設定された新たな`~shadow根$
⇒＃
`~node文書$ ~SET コレの`~node文書$,
`~host$ ~SET コレ,
`~mode$sR ~SET %init[ "$ShadowRootInit.mode" ]
◎
Let shadow be a new shadow root whose node document is this’s node document, host is this, and mode is init["mode"].
</li>
	<li>
%~shadow の`~focusを委譲するか$sR ~SET %init[ "$ShadowRootInit.delegatesFocus" ]
◎
Set shadow’s delegates focus to init["delegatesFocus"].
</li>
	<li>
~IF［
コレの`~custom要素~状態$ ~IN { `precustomized^l, `custom^l }
］
⇒
%~shadow の`要素の内部特能から可用か$sR ~SET ~T
◎
If this’s custom element state is "precustomized" or "custom", then set shadow’s available to element internals to true.
</li>
	<li>
%~shadow の`~slot割当n~mode$sR ~SET %init[ "$ShadowRootInit.slotAssignment" ]
◎
Set shadow’s slot assignment to init["slotAssignment"].
</li>
	<li>
コレの`~shadow根$elm ~SET %~shadow
◎
Set this’s shadow root to shadow.
</li>
	<li>
~RET %~shadow
◎
Return shadow.
</li>
</ol>
</div>

<div class="algo">
<p>
@shadowRoot
取得子~手続きは：
◎
The shadowRoot getter steps are:
</p>
<ol>
	<li>
%~shadow ~LET コレの `~shadow根$elm
◎
Let shadow be this’s shadow root.
</li>
	<li>
~IF［
%~shadow ~EQ ~NULL
］~OR［
%~shadow の`~mode$sR ~EQ `closed^l
］
⇒
~RET ~NULL
◎
If shadow is null or its mode is "closed", then return null.
</li>
	<li>
~RET %~shadow
◎
Return shadow.
</li>
</ol>
</div>

<hr>

<dl class="domintro">

	<dt>%element . $closest(selectors)</dt>
	<dd>
%element の`広義-先祖$であって, %selectors に合致するような`要素$が［
在れば，それらのうち %element に最も近いもの ／
無ければ ~NULL
］を返す。
◎
Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.
</dd>

	<dt>%element . $matches(selectors)</dt>
	<dd>
%element の`根$に対し %selectors を照合した結果，［
%element が得られるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if matching selectors against element’s root yields element; otherwise false.
</dd>
</dl>

<div class="algo">
<p>
@closest(selectors)
~method~手続きは：
◎
The closest(selectors) method steps are:
</p>
<ol>
	<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>
	<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, throw a "SyntaxError" DOMException.
</li>
	<li>
%要素 ~LET コレ
◎
↓</li>
	<li>
<p>
~WHILE［
%要素 は`要素$である
］：
</p>
		<ol>
			<li>
~IF［
`要素に対し選択子を照合する$( %要素, %選択子, `~scope-ps要素$の集合 { コレ } ) ~EQ `成功^i
`SELECTORS4$r
］
⇒
~RET %要素
</li>
			<li>
%要素 ~SET %要素 の`親$
</li>
		</ol>
◎
Let elements be this’s inclusive ancestors that are elements, in reverse tree order.
◎
For each element in elements, if match a selector against an element, using s, element, and :scope element this, returns success, return element. [SELECTORS4]
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
@matches(selectors),
@webkitMatchesSelector(selectors)
~method~手続きは、いずれも：
◎
The matches(selectors) and webkitMatchesSelector(selectors) method steps are:
</p>
<ol>
	<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>
	<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
`要素に対し選択子を照合する$( コレ, %選択子, `~scope-ps要素$の集合 { コレ } ) ~EQ `成功^i
`SELECTORS4$r
◎
If the result of match a selector against an element, using s, this, and :scope element this, returns success, then return true; otherwise, return false. [SELECTORS4]
</li>
</ol>

</div>

<div class="algo">
@getElementsByTagName(qualifiedName)
~method~手続きは
⇒
~RET コレ用の［
%qualifiedName を`有修飾~名に持つ要素の~list$
］
◎
The getElementsByTagName(qualifiedName) method steps are to return the list of elements with qualified name qualifiedName for this.
</div>

<div class="algo">
@getElementsByTagNameNS(namespace, localName)
~method~手続きは
⇒
~RET コレ用の［
( %namespace, %localName ) を
`( ~ns, 局所~名 ) に持つ要素の~list$
］
◎
The getElementsByTagNameNS(namespace, localName) method steps are to return the list of elements with namespace namespace and local name localName for this.
</div>

<div class="algo">
@getElementsByClassName(classNames)
~method~手続きは
⇒
~RET コレ用の［
%classNames を`~classesに含む要素の~list$
］
◎
The getElementsByClassName(classNames) method steps are to return the list of elements with class names classNames for this.
</div>

<hr>

<div class="algo">
<p>
`要素$ %要素 の
`隣に~nodeを挿入する@
ときは、所与の
( 文字列 %where, `~node$ %~node )
に対し，
`~ASCII小文字~化する$( %where ) の結果に応じて：
◎
To insert adjacent, given an element element, string where, and a node node, run the steps associated with the first ASCII case-insensitive match for where:
</p>

<dl class="switch">
	<dt>`beforebegin^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
			<li>
~RET
%要素 の`親$の中で`~nodeを子の前に前挿入する$( %~node, %要素 )
◎
Return the result of pre-inserting node into element’s parent before element.
</li>
		</ol>
	</dd>

	<dt>`afterbegin^l</dt>
	<dd>
		<ol>
			<li>
~RET
%要素 の中で`~nodeを子の前に前挿入する$( %~node, %要素 の`最初の子？$ )
◎
Return the result of pre-inserting node into element before element’s first child.
</li>
		</ol>
	</dd>

	<dt>`beforeend^l</dt>
	<dd>
		<ol>
			<li>
~RET
%要素 の中で`~nodeを子の前に前挿入する$( %~node, ~NULL )
◎
Return the result of pre-inserting node into element before null.
</li>
		</ol>
	</dd>

	<dt>`afterend^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
			<li>
~RET
%要素 の`親$の中で`~nodeを子の前に前挿入する$( %~node, %要素 の`次-同胞？$ )
◎
Return the result of pre-inserting node into element’s parent before element’s next sibling.
</li>
		</ol>
	</dd>

	<dt>その他</dt>
	<dd>
		<ol>
			<li>
~THROW `SyntaxError$E
◎
Throw a "SyntaxError" DOMException.
</li>
		</ol>
	</dd>
</dl>
</div>

<div class="algo">
@insertAdjacentElement(where, element)
~method~手続きは
⇒
~RET %element の`隣に~nodeを挿入する$( %where, コレ )
◎
The insertAdjacentElement(where, element) method steps are to＼
return the result of running insert adjacent, give this, where, and element.
</div>

<div class="algo">
<p>
@insertAdjacentText(where, data)
~method~手続きは：
◎
The insertAdjacentText(where, data) method steps are:
</p>
<ol>
	<li>
%text ~LET `新たな~Text~node$( %data, コレの`~node文書$ )
◎
Let text be a new Text node whose data is data and node document is this’s node document.
</li>
	<li>
コレの`隣に~nodeを挿入する$( %where, %text  )
◎
Run insert adjacent, given this, where, and text.
</li>
</ol>

<p class="note">注記：
この~methodは何も返さない
— それを設計しようとする前からすでに存在していたので。
◎
This method returns nothing because it existed before we had a chance to design it.
</p>
</div>

<p class="trans-note">【
参考：
`insertAdjacentHTML()$m `DOM-Parsing$r という同類の便利~methodもある。
】</p>

			<section id="interface-namednodemap">
<h4 title="Interface NamedNodeMap">4.9.1. ^@NamedNodeMap ~interface</h4>

！！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @NamedNodeMap {
  ~RA `unsigned long$ $length;
  getter $Attr? $item(`unsigned long$ %index);
  getter $Attr? $getNamedItem($DOMString %qualifiedName);
  $Attr? $getNamedItemNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $Attr? $setNamedItem($Attr %attr);
  [`CEReactions$] $Attr? $setNamedItemNS($Attr %attr);
  [`CEReactions$] $Attr $removeNamedItem($DOMString %qualifiedName);
  [`CEReactions$] $Attr $removeNamedItemNS($DOMString? %namespace, $DOMString %localName);
};
！

<div class="p">
<p>
各 $NamedNodeMap ~objには、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`要素@nm</dt>
	<dd>
`要素$。
</dd>
</dl>
◎
A NamedNodeMap has an associated element (an element).
</div>

<p>
$NamedNodeMap ~objの
`属性o~list@nm
とは、~objの`要素$nmの`属性o~list$である。
◎
A NamedNodeMap object’s attribute list is its element’s attribute list.
</p>

<hr>

<p>
$NamedNodeMap ~obj %O が`~supportする~prop~index$は、
0 以上［
%O の`属性o~list$nmの`~size$
］未満とする。
◎
A NamedNodeMap object’s supported property indices are the numbers in the range zero to its attribute list’s size minus one, unless the attribute list is empty, in which case there are no supported property indices.
</p>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレの`属性o~list$nmの`~size$
◎
The length getter steps are to return the attribute list’s size.
</div>

<div class="algo">
@item(index)
~method~手続きは
⇒
~RET ［
%index ~NIN { コレが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_ コレの`属性o~list$nm[ %index ]
］
◎
The item(index) method steps are:
• If index is equal to or greater than this’s attribute list’s size, then return null.
• Otherwise, return this’s attribute list[index].
</div>

<div class="algo">
<p>
$NamedNodeMap ~obj %O が`~supportする~prop名$たちは、次の手続きの結果で与えられる：
◎
A NamedNodeMap object’s supported property names are the return value of running these steps:
</p>
<ol>
	<li>
%名前~list ~LET %O の`属性o~list$nm 内の各［
`属性o$の`有修飾~名$a
］からなる，同順の~list
◎
Let names be the qualified names of the attributes in this NamedNodeMap object’s attribute list, with duplicates omitted, in order.
</li>
	<li>
%要素 ~LET %O の`要素$nm
◎
↓</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%名前~list を成す
~EACH( %名前 )
に対し
⇒
~IF［
`~ASCII小文字~化する$( %名前 ) ~NEQ %名前
］
⇒
%名前 を %名前~list から除去する
◎
If this NamedNodeMap object’s element is in the HTML namespace and its node document is an HTML document, then for each name in names:
• Let lowercaseName be name, in ASCII lowercase.
• If lowercaseName is not equal to name, remove name from names.
</li>
	<li>
~RET %名前~list
◎
Return names.
</li>
</ol>
</div>

<div class="algo">
@getNamedItem(qualifiedName)
~method~手続きは
⇒
~RET コレの`要素$nmの`属性oを名前により取得する$( %qualifiedName )
◎
The getNamedItem(qualifiedName) method steps are to return the result of getting an attribute given qualifiedName and element.
</div>

<div class="algo">
@getNamedItemNS(namespace, localName)
~method~手続きは
⇒
~RET コレの`要素$nmの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getNamedItemNS(namespace, localName) method steps are to return the result of getting an attribute given namespace, localName, and element.
</div>

<div class="algo">
@setNamedItem(attr),
@setNamedItemNS(attr)
~method~手続きは：
⇒
~RET コレの`要素$nmの`属性oを設定する$( %attr )
◎
The setNamedItem(attr) and setNamedItemNS(attr) method steps are to return the result of setting an attribute given attr and element.
</div>

<div class="algo">
<p>
@removeNamedItem(qualifiedName)
~method~手続きは：
◎
The removeNamedItem(qualifiedName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET コレの`要素$nmの`属性oを名前により除去する$( %qualifiedName )
◎
Let attr be the result of removing an attribute given qualifiedName and element.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a "NotFoundError" DOMException.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

<div class="algo">
<p>
@removeNamedItemNS(namespace, localName)
~method~手続きは：
◎
The removeNamedItemNS(namespace, localName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET
コレの`要素$nmの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
◎
Let attr be the result of removing an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a "NotFoundError" DOMException.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

			</section>
			<section id="interface-attr">
<h4 title="Interface Attr">4.9.2. ^@Attr ~interface</h4>

！！
[`Exposed$=Window]
interface @Attr : $Node {
  ~RA $DOMString? $namespaceURI;
  ~RA $DOMString? $prefix;
  ~RA $DOMString $localName;
  ~RA $DOMString $name;
  [`CEReactions$] attribute $DOMString $value;

  ~RA Element? $ownerElement;

  ~RA $boolean $specified; // <!--cp-useless-true-->
};
！

<p>
$Attr `~node$は、単に
`属性o@
（ `attribute^en ）とも称される
— ~IDL属性と区別するため、内容~属性とも称される。
【この訳では， “°” を付けて “属性o” と記すことにする。】
◎
Attr nodes are simply known as attributes. They are sometimes referred to as content attributes to avoid confusion with IDL attributes.
</p>

<div class="p">
<p>
各 `属性o$は、次に挙げるものを持つ：
</p>

<dl class="def-list">
	<dt>`~ns@a</dt>
	<dd>
~NULL ／空でない文字列
</dd>

	<dt>`~ns接頭辞@a</dt>
	<dd>
~NULL ／空でない文字列
</dd>

	<dt>`局所~名@a</dt>
	<dd>
空でない文字列
</dd>

	<dt>`値@a</dt>
	<dd>
文字列
</dd>

	<dt>`属する要素@</dt>
	<dd>
~NULL ／`要素$
【 ~NULL でないならば、属性oは要素の`属性o~list$内に在ることになる。】
</dd>
</dl>
◎
Attributes have a namespace (null or a non-empty string), namespace prefix (null or a non-empty string), local name (a non-empty string), value (a string), and element (null or an element).
</div>

<p class="note">注記：
今 設計するなら、単に［
名前, 値
］のみを持つ様にする所 ☹
◎
If designed today they would just have a name and value. ☹
</p>

<p>
`属性o$ %A の
`有修飾~名@a
は、
%A の`~ns接頭辞$a %接頭辞 に応じて［
~NULL ならば %A の`局所~名$a ／
~ELSE_ 次の並びになる
］
⇒＃
%接頭辞,
`:^l,
%A の`局所~名$a
◎
An attribute’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<p class="note">注記：
~UAは、これを内部~slotに持たせて最適化することもできる。
◎
User agents could have this as an internal slot as an optimization.
</p>

<p>
`属性o$が作成されるときは、その`局所~名$aが与えられる。
`属性o$の作成-時に明示的に与えられない限り，他のものは次のように設定される
⇒
( `~ns$a, `~ns接頭辞$a, `属する要素$, `値$a )
~SET
( ~NULL, ~NULL, ~NULL, 空~文字列 )
◎
When an attribute is created, its local name is given. Unless explicitly given when an attribute is created, its namespace, namespace prefix, and element are set to null, and its value is set to the empty string.
</p>

<p>
文字列 %A に対する
<dfn id="concept-named-attribute">%A 属性o</dfn>
という~~表記は、次を満たす `属性o$を意味する
⇒
( `局所~名$a, `~ns$a, `~ns接頭辞$a )
~EQ
( %A, ~NULL, ~NULL )
◎
An A attribute is an attribute whose local name is A and whose namespace and namespace prefix are null.
</p>

<hr>

<div class="algo">
@namespaceURI
取得子~手続きは
⇒
~RET コレの`~ns$a
◎
The namespaceURI getter steps are to return this’s namespace.
</div>

<div class="algo">
@prefix
取得子~手続きは
⇒
~RET コレの`~ns接頭辞$a
◎
The prefix getter steps are to return this’s namespace prefix.
</div>

<div class="algo">
@localName
取得子~手続きは
⇒
~RET コレの`局所~名$a
◎
The localName getter steps are to return this’s local name.
</div>

<div class="algo">
@name
取得子~手続きは
⇒
~RET コレの`有修飾~名$a
◎
The name getter steps are to return this’s qualified name.
</div>

<div class="algo">
@value
取得子~手続きは
⇒
~RET コレの`値$a
◎
The value getter steps are to return this’s value.
</div>

<div class="algo">
<p>
`既存の属性o値を設定する@
ときは、所与の
( `属性o$ %属性o, 文字列 %値 )
に対し，次を走らす：
◎
To set an existing attribute value, given an attribute attribute and string value, run these steps:
</p>
<ol>
	<li>
~IF［
%属性o が`属する要素$ ~EQ ~NULL
］
⇒
%属性o の`値$a ~SET %値
◎
If attribute’s element is null, then set attribute’s value to value.
</li>
	<li>
~ELSE
⇒
`属性oを変更する$( %属性o, %値 )
◎
Otherwise, change attribute to value.
</li>
</ol>
</div>

<div class="algo">
$value 設定子~手続きは
⇒
`既存の属性o値を設定する$( コレ, 所与の値 )
◎
The value setter steps are to set an existing attribute value with this and the given value.
</div>

<div class="algo">
@ownerElement
取得子~手続きは
⇒
~RET コレが`属する要素$
◎
The ownerElement getter steps are to return this’s element.
</div>

<div class="algo">
@specified
取得子~手続きは
⇒
~RET ~T
◎
The specified getter steps are to return true.
</div>

			</section>
		</section>
		<section id="interface-characterdata">
<h3 title="Interface CharacterData">4.10. ^@CharacterData ~interface</h3>

！！
[`Exposed$=Window]
interface @CharacterData : $Node {
  attribute [`LegacyNullToEmptyString$] $DOMString $data;
  ~RA `unsigned long$ $length;
  $DOMString $substringData(`unsigned long$ %offset, `unsigned long$ %count);
  $undefined $appendData($DOMString %data);
  $undefined $insertData(`unsigned long$ %offset, $DOMString %data);
  $undefined $deleteData(`unsigned long$ %offset, `unsigned long$ %count);
  $undefined $replaceData(`unsigned long$ %offset, `unsigned long$ %count, $DOMString %data);
};
！

<p class="note">注記：
$CharacterData は、［
$Text, $ProcessingInstruction, $Comment
］`~node$から利用される抽象-~interfaceであり，その直な~instanceは取得し得ない。
◎
CharacterData is an abstract interface. You cannot get a direct instance of it. It is used by Text, ProcessingInstruction, and Comment nodes.
</p>

<p>
この~interfaceを実装する`~node$は、
`文字~data~node@
とも称される
（すなわち， $Text （ $CDATASection も含む）, $ProcessingInstruction, $Comment ）。
</p>

<p class="trans-note">【
これは、この訳に導入した非公式な用語である。
これらの~interfaceは、（機能上は異なるものだが）多くの処理で同等に扱われるので。
】</p>

<div class="p">
<p>
各 `文字~data~node$には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~data@</dt>
	<dd>
変異-可能な文字列。
</dd>
</dl>
◎
Each node inheriting from the CharacterData interface has an associated mutable string called data.
</div>

<div class="algo">
<p>
`文字~data~node$ %node の
`~dataを置換する@
ときは、所与の
( %offset, %count, %data )
に対し，次を走らす：
◎
To replace data of node node with offset offset, count count, and data data, run these steps:
</p>
<ol>
	<li id="cp-let-node-length">
%長さ ~LET %node の`長さ$
◎
Let length be node’s length.
</li>
	<li id="cp-throw-size-err">
~IF［
%offset ~GT %長さ
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than length, then throw an "IndexSizeError" DOMException.
</li>
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~SET %長さ ~MINUS %offset
◎
If offset plus count is greater than length, then set count to length minus offset.
</li>
	<li>
%node 用に種別 `characterData^l の`変異~記録を~queueする$( 次に挙げる引数 )
⇒＃
~NULL,
~NULL,
%node の`~data$,
« »,
« »,
~NULL,
~NULL
◎
Queue a mutation record of "characterData" for node with null, null, node’s data, « », « », null, and null.
</li>
	<li>
%挿入点 ~LET %node の`~data$の中で，
%offset 個目の`符号単位$の直後を指す位置（ %offset ~EQ 0 は先頭を指す）
◎
↓</li>
	<li>
%挿入点 から末尾側に在る %count 個の`符号単位$を除去する
◎
↓</li>
	<li>
%挿入点 に %data を挿入する
◎
Insert data into node’s data after offset code units.
◎
Let delete offset be offset + data’s length.
◎
Starting from delete offset code units, remove count code units from node’s data.
</li>
	<li>
%差分 ~LET %data の`長さ$str ~MINUS %count
◎
↓</li>
	<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
		<ol>
			<li>
<p>
~IF［
%範囲o の`始端~node$ ~EQ %node
］：
</p>
				<ol>
					<li>
~IF［
%offset ~LT %範囲o の`始端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%範囲o の`始端~offset$ ~SET %offset
</li>
					<li>
~IF［
%範囲o の`始端~offset$ ~GT %offset ~PLUS %count
］
⇒
%範囲o の`始端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%範囲o の`終端~node$ ~EQ %node
］：
</p>
				<ol>
					<li>
<p>
~IF［
%offset ~LT %範囲o の`終端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%範囲o の`終端~offset$ ~SET %offset
</p>

<p class="trans-note">【
%範囲o の終端がちょうど置換される~~範囲の末尾を指している場合も，終端は置換した~~範囲の先頭に “寄せられる” ことになる。
】</p>

					</li>
					<li>
~IF［
%範囲o の`終端~offset$ ~GT %offset ~PLUS %count
］
⇒
%範囲o の`終端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
		</ol>
◎
For each live range whose start node is node and start offset is greater than offset but less than or equal to offset plus count, set its start offset to offset.
◎
For each live range whose end node is node and end offset is greater than offset but less than or equal to offset plus count, set its end offset to offset.
◎
For each live range whose start node is node and start offset is greater than offset plus count, increase its start offset by data’s length and decrease it by count.
◎
For each live range whose end node is node and end offset is greater than offset plus count, increase its end offset by data’s length and decrease it by count.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node の`親$用の`子~群~変更-時の手続き$を走らす
◎
If node’s parent is non-null, then run the children changed steps for node’s parent.
</li>
</ol>
</div>

<div class="algo">
<p>
`文字~data~node$ %node から
`~dataの部分文字列@
を得るときは、所与の
( %offset, %count )
に対し，次を走らす：
◎
To substring data with node node, offset offset, and count count, run these steps:
</p>
<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~LET %長さ ~MINUS %offset
◎
If offset plus count is greater than length, return a string whose value is the code units from the offsetth code unit to the end of node’s data, and then return.
</li>
	<li>
~RET %node の`~data$内で［
%offset 個目の`符号単位$の直後（ %offset ~EQ 0 なら先頭）から，
%count 個の`符号単位$
］並びが成す文字列
◎
Return a string whose value is the code units from the offsetth code unit to the offset+countth code unit in node’s data.
</li>
</ol>
</div>

<div class="algo">
@data
取得子~手続きは
⇒
~RET コレの`~data$
◎
The data getter steps are to return this’s data.＼
</div>

<div class="algo">
$data 設定子~手続きは：
⇒
コレの`~dataを置換する$( 0, コレの`長さ$, 所与の値 )
◎
Its setter must replace data with node this, offset 0, count this’s length, and data new value.
</div>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレの`長さ$
◎
The length getter steps are to return this’s length.
</div>

<div class="algo">
@substringData(offset, count)
~method~手続きは
⇒
~RET コレの`~dataの部分文字列$( %offset, %count )
◎
The substringData(offset, count) method steps are to return the result of running substring data with node this, offset offset, and count count.
</div>

<div class="algo">
@appendData(data)
~method~手続きは
⇒
コレの`~dataを置換する$( コレの`長さ$, 0, %data )
◎
The appendData(data) method steps are to replace data with node this, offset this’s length, count 0, and data data.
</div>

<div class="algo">
@insertData(offset, data)
~method~手続きは
⇒
コレの`~dataを置換する$( %offset, 0, %data )
◎
The insertData(offset, data) method steps are to replace data with node this, offset offset, count 0, and data data.
</div>

<div class="algo">
@deleteData(offset, count)
~method~手続きは
⇒
コレの`~dataを置換する$( %offset, %count, 空~文字列 )
◎
The deleteData(offset, count) method steps are to replace data with node this, offset offset, count count, and data the empty string.
</div>

<div class="algo">
@replaceData(offset, count, data)
~method~手続きは
⇒
コレの`~dataを置換する$( %offset, %count, %data )
◎
The replaceData(offset, count, data) method steps are to replace data with node this, offset offset, count count, and data data.
</div>

		</section>
		<section id="interface-text">
<h3 title="Interface Text">4.11. ^@Text ~interface</h3>

！！
[`Exposed$=Window]
interface @Text : $CharacterData {
  `Text$mc(optional $DOMString %data = "");
  [`NewObject$] $Text $splitText(`unsigned long$ %offset);
  ~RA $DOMString $wholeText;
};
！

<hr>

<dl class="domintro">
	<dt>%text = $Text([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a new Text node whose data is data.
</dd>

	<dt>%text . $splitText(offset)</dt>
	<dd>
所与の %offset の地点で`~data$を分割し，残りの部分を $Text `~node$として返す。
◎
Splits data at the given offset and returns the remainder as Text node.
</dd>

	<dt>%text . $wholeText</dt>
	<dd>
隣接するすべての`同胞$ $Text `~node$の`~data$を連結した結果を返す。
◎
Returns the combined data of all direct Text node siblings.
</dd>
</dl>

<hr>

<p>
`新たな~Text~node@( %文字列, %文書 )
という表記は、次のように設定された新たな $Text `~node$を意味する
⇒
( `~data$, `~node文書$ ) ~SET ( %文字列, %文書 )
</p>

<p class="trans-note">【
この表記は、簡潔に記述するため，この訳に導入したものである。
】</p>

<p>
`狭義の~Text~node@
とは、 $CDATASection `~node$でない $Text `~node$である。
◎
An exclusive Text node is a Text node that is not a CDATASection node.
</p>

<p>
`~node$ %~node を含む
`連続的な~Text~node列@
とは、条件［
$Text `~node$である
］を満たす， %~node を含む`連続的な同胞~列$である。
◎
The contiguous Text nodes of a node node are node, node’s previous sibling Text node, if any, and its contiguous Text nodes, and node’s next sibling Text node, if any, and its contiguous Text nodes, avoiding any duplicates.
</p>

<p>
`~node$ %~node を含む
`連続的な狭義の~Text~node列@
とは、条件［
`狭義の~Text~node$である
］を満たす， %~node を含む`連続的な同胞~列$である。
◎
The contiguous exclusive Text nodes of a node node are node, node’s previous sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, and node’s next sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
</p>

<p class="trans-note">【
この訳では、次の手続きを導入して，原文による “連続的な…” の（再帰的な）定義を、等価な（かつ平坦~化された平易な）定義に変形している。
】</p>

<div class="algo">
<p>
条件 %条件 を満たす， %~node を含む
`連続的な同胞~列@
は、次を走らせた結果で与えられる：
</p>
<ol>
	<li>
~Assert：
%~node は %条件 を満たす
</li>
	<li>
~WHILE［
%~node の`前-同胞？$は %条件 を満たす
］
⇒
%~node ~SET %~node の`前-同胞？$
</li>
	<li>
%~list ~LET 空~list
</li>
	<li>
<p>
~WHILE［
%~node は %条件 を満たす
］：
</p>
		<ol>
			<li>
%~list に %~node を付加する
</li>
			<li>
%~node ~SET %~node の`次-同胞？$
</li>
		</ol>
	</li>
	<li>
~RET %~list
</li>
</ol>

◎
↑</div>

<hr>

<div class="algo">
<p>
`~node$ %~node の
`子~text内容@
は、次を`連結-$した結果を返す
⇒
`~tree順序$による［
%~node の`子$のうち $Text ~nodeであるもの
］すべての`~data$
◎
The child text content of a node node is the concatenation of the data of all the Text node children of node, in tree order.
</p>
</div>

<div class="algo">
<p>
`~node$ %~node の
`子孫~text内容@
は、次を`連結-$した結果を返す
⇒
`~tree順序$による［
%~node の`子孫$のうち $Text `~node$であるもの
］すべての`~data$
◎
The descendant text content of a node node is the concatenation of the data of all the Text node descendants of node, in tree order.
</p>
</div>

<hr>

<div class="algo">
<p>
@Text(data)
構築子~手続きは
⇒＃
コレの`~data$ ~SET %data,
コレの`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The new Text(data) constructor steps are to set this’s data to data and this’s node document to current global object’s associated Document.
</div>

<div class="algo">
<p>
`~Text~nodeを分割する@
ときは、所与の
( $Text `~node$ %node, ~offset %offset )
に対し，次を走らす：
◎
To split a Text node node with offset offset, run these steps:
</p>
<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
%count ~LET %長さ ~MINUS %offset
◎
Let count be length minus offset.
</li>
	<li>
%新-~data ~LET
コレの`~dataの部分文字列$( %offset, %count )
◎
Let new data be the result of substringing data with node node, offset offset, and count count.
</li>
	<li>
%新-~node ~LET `新たな~Text~node$( %新-~data, %node の`~node文書$ )
◎
Let new node be a new Text node, with the same node document as node. Set new node’s data to new data.
</li>
	<li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
	<li>
<p>
~IF［
%親 ~NEQ ~NULL
］：
◎
If parent is not null, then:
</p>
		<ol>
			<li>
%親 の中で`~nodeを子の前に挿入する$( %新-~node, %node の`次-同胞？$ )
◎
Insert new node into parent before node’s next sibling.
</li>
			<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
◎
↓</p>
				<ol>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %node
］~AND［
%範囲o の`始端~offset$ ~GT %offset
］
⇒＃
%範囲o の`始端~node$ ~SET %新-~node；
%範囲o の`始端~offset$ ~DECBY %offset
◎
For each live range whose start node is node and start offset is greater than offset, set its start node to new node and decrease its start offset by offset.
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %node
］~AND［
%範囲o の`終端~offset$ ~GT %offset
］
⇒＃
%範囲o の`終端~node$ ~SET %新-~node；
%範囲o の`終端~offset$ ~DECBY %offset
◎
For each live range whose end node is node and end offset is greater than offset, set its end node to new node and decrease its end offset by offset.
</li>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~EQ %node の`~index$ ~PLUS 1
］
⇒
%範囲o の`始端~offset$ ~INCBY 1
◎
For each live range whose start node is parent and start offset is equal to the index of node plus 1, increase its start offset by 1.
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~EQ %node の`~index$ ~PLUS 1
］
⇒
%範囲o の`終端~offset$ ~INCBY 1
◎
For each live range whose end node is parent and end offset is equal to the index of node plus 1, increase its end offset by 1.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%node の`~dataを置換する$( %offset, %count, 空~文字列 )
◎
Replace data with node node, offset offset, count count, and data the empty string.
</li>
	<li>
~RET %新-~node
◎
Return new node.
</li>
</ol>
</div>

<div class="algo">
@splitText(offset)
~method~手続きは
⇒
~RET `~Text~nodeを分割する$( コレ, %offset )
◎
The splitText(offset) method steps are to split this with offset offset.
</div>

<div class="algo">
@wholeText
取得子~手続きは
⇒
~RET 次を`連結-$した結果
⇒
`~tree順序$による，コレを含む`連続的な~Text~node列$を成すすべての~nodeの`~data$
◎
The wholeText getter steps are to return the concatenation of the data of the contiguous Text nodes of this, in tree order.
</div>

		</section>
		<section id="interface-cdatasection">
<h3 title="Interface CDATASection">4.12. ^@CDATASection ~interface</h3>

！！
[`Exposed$=Window]
interface @CDATASection : $Text {
};
！

<!--  -->

		</section>
		<section id="interface-processinginstruction">
<h3 title="Interface ProcessingInstruction">4.13. ^@ProcessingInstruction ~interface</h3>

！！
[`Exposed$=Window]
interface @ProcessingInstruction : $CharacterData {
  ~RA $DOMString $target;
};
！

<div class="p">
<p>
各 $ProcessingInstruction `~node$には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~target@pI</dt>
	<dd>
文字列。
</dd>
</dl>
◎
ProcessingInstruction nodes have an associated target.
</div>

<div class="algo">
@target
取得子~手続きは
⇒
~RET コレの`~target$pI
◎
The target getter steps are to return this’s target.
</div>

		</section>
		<section id="interface-comment">
<h3 title="Interface Comment">4.14. ^@Comment ~interface</h3>

！！
[`Exposed$=Window]
interface @Comment : $CharacterData {
  `Comment$mc(optional $DOMString %data = "");
};
！

<dl class="domintro">
	<dt>%comment = $Comment([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a new Comment node whose data is data.
</dd>
</dl>

<div class="algo">
<p>
@Comment(data)
構築子~手続きは
⇒＃
コレの`~data$ ~SET %data,
コレの`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The new Comment(data) constructor steps are to set this’s data to data and this’s node document to current global object’s associated Document.
</div>

		</section>
	</section>
	<section id="ranges">
<h2 title="Ranges">5. 範囲o</h2>

		<section id="introduction-to-dom-ranges">
<h3 title="Introduction to “DOM Ranges”">5.1. “DOM Ranges” 序論</h3>

<p>
［
$StaticRange ／ $Range
］~obj （ `範囲o$ ）は`~node~tree$の中の連続する内容を表現する。
各 `範囲o$ は、`境界点$と呼ばれる［
( `始端$, `終端$ )
が成す`~tuple$
］を持つ。
各 `境界点$は、
( `~node$bp, `~offset$bp )
が成す`~tuple$である。
言い換えれば、`範囲o$は`~node~tree$の中の 2 つの`境界点$に挟まれる
`中身@rg
を表現する。
◎
StaticRange and Range objects (ranges) represent a sequence of content within a node tree. Each range has a start and an end which are boundary points. A boundary point is a tuple consisting of a node and an offset. So in other words, a range represents a piece of content within a node tree between two boundary points.
</p>

<p>
`範囲o$は、編集-時に内容を選択したり複製するときに よく利用される。
例えば 次の`~node~tree$が与えられたとき：
◎
Ranges are frequently used in editing for selecting and copying content.
</p>

<ol class="domTree"><li>`要素$: `p^e
	<ol><li>`要素$: `img^e,
		<span>^src=`insanity-wolf^l</span>
		<span>^alt=`Little-endian BOM; decode as big-endian!^l</span>
	</li><li>$Text:
		<samp>&nbsp;CSS 2.1 syndata is&nbsp;</samp>
	</li><li>`要素$: `em^e
		<ol><li>$Text: <samp>awesome</samp>
		</li></ol>
	</li><li>$Text: <samp>!</samp>
	</li></ol>
</li></ol>

<p>
次の様にして，
`syndata is awes^l
の並びを表現する`範囲o$が得られる（変数［
%p ／ %em
］には［
`p^e ／ `em^e
］`要素$が割当されたとする）：
◎
In the node tree above, a range can be used to represent the sequence “syndata is awes”. Assuming p is assigned to the p element, and em to the em element, this would be done as follows:
</p>

<pre class="lang-js">
var %range = new Range(),
    %text1 = %p.childNodes[1],
    %text2 = %em.firstChild
%range.setStart(%text1, 9) /* <span class="comment">
先頭の空白も数に入れる
◎
do not forget the leading space
</span> */
%range.setEnd(%text2, 4)
/* <span class="comment">
%range を<a href="#dom-range-stringifier">文字列~化</a>した結果は、今や先に示した文字列になる
◎
range now stringifies to the aforementioned quote
</span> */
</pre>

<p class="note">注記：
`範囲o$は、上の`~node~tree$の ^src や ^alt などの`属性o$は表現できない。
`範囲o$は`~node$用に限り有用になる。
◎
Attributes such as src and alt in the node tree above cannot be represented by a range. Ranges are only useful for nodes.
</p>

<p>
$StaticRange ~objと違って、
$Range ~objは，`~node~tree$に対する変異に影響される。
なので、`~live範囲o$とも称される。
その種の変異によりそれらが無効~化されることはなく，可能なら内容の同じ部分を表現するようにされる。
`~live範囲o$は、`~node~tree$に対する変異
— 自身が表現する`中身$rgの一部が変異したときなど —
に伴い，必要に応じて自身も改変され得る。
◎
Range objects, unlike StaticRange objects, are affected by mutations to the node tree. Therefore they are also known as live ranges. Such mutations will not invalidate them and will try to ensure that it still represents the same piece of content. Necessarily, a live range might itself be modified as part of the mutation to the node tree when, e.g., part of the content it represents is mutated.
</p>

<p>
詳細は、次に挙げる各種~algo／~methodを見よ
⇒＃
`~nodeを子の前に挿入する$,
`~nodeを除去する$
$Node.normalize(),
`~dataを置換する$,
`~Text~nodeを分割する$
◎
See the insert and remove algorithms, the normalize() method, and the replace data and split algorithms for details.
</p>

<p class="trans-note">【
例えば，範囲oの境界点が ある~nodeの “内部” を指していて, その~nodeが~treeから除去された場合、その境界点は “~nodeが抜けた穴” を指すようにされる（始端と終端が別々の~treeの中を指さないようにされる）。
始端と終端の両者が同じ~nodeの内部を指していたとしても、除去された~nodeの内部を指すことはなく，それらは同じ “穴” を指す様に畳まれることになる。
】</p>

<p>
`~node~tree$の変異に呼応して，`~live範囲o$を更新することは、高価になり得る。
`~node~tree$が変化するたびに、影響されるすべての $Range ~objは更新される必要がある。
~appが`~live範囲o$に関心がなくなろうが、変異が生じたときには，それらを最新に保つ~costを支払うことになる。
◎
Updating live ranges in response to node tree mutations can be expensive. For every node tree change, all affected Range objects need to be updated. Even if the application is uninterested in some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.
</p>

<p>
$StaticRange ~objは、`~node~tree$が変異しても更新されない，軽量な`範囲o$であり、したがって，
`~live範囲o$と同じ保守~costの~subjectにならない。
◎
A StaticRange object is a lightweight range that does not update when the node tree mutates. It is therefore not subject to the same maintenance cost as live ranges.
</p>

		</section>
		<section id="boundary-points">
<h3 title="Boundary points">5.2. 境界点</h3>

<p>
`境界点@
とは、［
`~node@bp
（`~node$）,
`~offset@bp
（負でない整数）
］が成す`~tuple$である。
◎
A boundary point is a tuple consisting of a node (a node) and an offset (a non-negative integer).
</p>

<p>
以下では，所与の［
`~node$ %node, `~offset$bp %offset
］で初期化された`境界点$を、
“境界点( %node, %offset )”
の様に表記する。
【この表記は、この訳による追加。】
</p>

<p class="note">注記：
正しい`境界点$の`~offset$bpは、
0 以上, `境界点$の`~node$bpの`長さ$以下になる。
◎
A correct boundary point’s offset will be between 0 and the boundary point’s node’s length, inclusive.
</p>

<div class="trans-note">
<p>【
~HTMLや~XMLの~source~textの中では，境界点は、すべての~text~data（`文字~data~node$）を “仮想の” 開始~tag, 終了~tag で括り,
すべての空~要素（~HTMLの~void要素も含む）は 開始／終了 ~tagの組に置換した上で、すべての［
~tag, および
文字~dataを成す`符号単位$たち
］それぞれを点に見立てて，~sourceに現れる順に一列に並べたときの，隣接する任意の 2 つの点の隙間を指すものと見なせる。
</p>

<p>
例えば
"<samp>&lt;b&gt;text&lt;/b&gt;</samp>"
のような~markupの中の，［
開始~tag "<samp>&lt;b&gt;</samp>"
］と［
"<samp>text</samp>" の先頭
］との隙間を指す境界点には、
"<samp>text</samp>" ~node の［
内縁（“仮想の”~tagの内縁）を指すもの, および
外縁を指すもの
］があり、また，境界点は［
"<samp>&lt;br&gt;</samp>"
のような空~tag ／
~dataが空な`文字~data~node$
］の内部も指し得る†。
</p>

<p>†
唯一の~~例外は，`~doctype$であり、境界点は~doctypeの内部は<a href="#concept-range-bp-set">指し得ない</a>ようにされている
— したがってこの~modelでは，一個の “点” になる。
</p>

<p>
文書の~node~treeの一例とそのすべての境界点を示す模式図を次に示す。
縦棒  "|" が境界点が指し得る位置を表し，ドット "." が文字~dataの各~文字を表す（
<a href="#example-tree">先掲の模式図</a>
同様，左端が文書の先頭, 右端が文書の末尾，横線は~treeの中の各 ~nodeが文書~内を占める~~範囲を表し，~COLOR_Rは`文字~data~node$を表す）：
</p>

`[|*|(|A)|[|[|B]|(|.|)|C(|.|.|)|[|(|.|)|]|[|]|(|.|.|)|[x|0(|.|)|1[|(|.|)|]|2[|(|.|.|.|)|[|(|.|)|]|]|3(|.|.|)|4]|]|(|.|.|)|]^bpex

<p>
境界点を表す縦棒の直上の横線がその境界点の~nodeを表す。
境界点の~offsetは、図の中では，その境界点を表す縦棒の直上の横線直下に在って, その縦棒より左側に在る縦棒の本数になる（境界点の~nodeが図の~COLOR_Xならば、その直下の`各数字^mkがその境界点の~offset）。
</p>

<p>
図の先頭の `*^c は`~doctype$を表す（内部に境界点は無い）。
その次の孤立した `A^mk は~dataが空な`文字~data~node$の内部を指す（唯一の）境界点を表し，その次の `B^mk は内容が空な要素の内部を指す境界点を表し，~~後続の 2 個の~COLOR_Rは 2 個の`文字~data~node$が境界点（ `C^mk ）を挟んで間を置かずに連続していることを表している。
】</p>

</div>

<div class="algo">
<p>
`境界点$ %A の［
`境界点$ %B に
`相対的な位置bp@
］が， %B ［
`より前@i ／
`に等しい@i ／
`より後@i
］のいずれかになるかは、次に従って決定される：
◎
The position of a boundary point (nodeA, offsetA) relative to a boundary point (nodeB, offsetB) is before, equal, or after, as returned by these steps:
</p>

<p class="trans-note">【
この~algoは、 2 つの境界点に対し，上に示した様な模式図における位置関係（左側が “より前” ）を算出する。
】</p>
<ol>
	<li>
( %nodeA, %offsetA, %nodeB, %offsetB )
~LET
( %A の`~node$bp, %A の`~offset$bp, %B の`~node$bp, %B の`~offset$bp )
◎
↑</li>
	<li>
~Assert：
%nodeA の`根$ ~EQ %nodeB の`根$
◎
Assert: nodeA and nodeB have the same root.
</li>
	<li>
~IF［
%nodeA ~EQ %nodeB
］
⇒
~RET ［
%offsetA ~LT %offsetB ならば `より前$i ／
%offsetA ~EQ %offsetB ならば `に等しい$i ／
%offsetA ~GT %offsetB ならば `より後$i
］
◎
If nodeA is nodeB, then return equal if offsetA is offsetB, before if offsetA is less than offsetB, and after if offsetA is greater than offsetB.
</li>
	<li>
~IF［
%nodeA は %nodeB に`後続-$する
］
⇒
~RET %B は %A ［
`より前$i ならば `より後$i ／
`より後$i ならば `より前$i
］
◎
If nodeA is following nodeB, then if the position of (nodeB, offsetB) relative to (nodeA, offsetA) is before, return after, and if it is after, return before.
</li>
	<li>
<p>
~IF［
%nodeA は %nodeB の`先祖$である
］：
◎
If nodeA is an ancestor of nodeB:
</p>
		<ol>
			<li>
%子 ~LET %nodeB
◎
Let child be nodeB.
</li>
			<li>
~WHILE［
%子 の`親$ ~NEQ %nodeA
］
⇒
%子 ~SET %子 の`親$
◎
While child is not a child of nodeA, set child to its parent.
</li>
			<li>
~IF［
%子 の`~index$ ~LT %offsetA
］
⇒
~RET `より後$i
◎
If child’s index is less than offsetA, then return after.
</li>
		</ol>
	</li>
	<li>
~RET `より前$i
◎
Return before.
</li>
</ol>
</div>

		</section>
		<section id="interface-abstractrange">
<h3 title="Interface AbstractRange">5.3. ^@AbstractRange ~interface</h3>

！！
[`Exposed$=Window]
interface @AbstractRange {<!-- ^@Range -->
  ~RA $Node $startContainer;
  ~RA `unsigned long$ $startOffset;
  ~RA $Node $endContainer;
  ~RA `unsigned long$ $endOffset;
  ~RA $boolean $collapsed;
};
！

<p>
$AbstractRange ~interfaceを実装する~objは単に
`範囲o@
とも称される。
◎
Objects implementing the AbstractRange interface are known as ranges.
</p>

<p class="trans-note">【
一般語の “~~範囲” と区別し易くするため、この訳では， “°” を付けて “範囲o” と記すことにする（
“DOM range”, “~~範囲~obj”
などの呼称もあるが）。
】</p>

<p>
各 `範囲o$には、 2 つの`境界点$
`始端@,
`終端@
が結付けられる。
◎
A range has two associated boundary points — a start and end.
</p>

<p>
便宜のため、`範囲o$の：
◎
For convenience,＼
</p>

<ul>
	<li>
(
`始端~node@,
`始端~offset@
) は、順に，`始端$の
( `~node$bp, `~offset$bp )
を指すとする。
◎
a range’s start node is its start’s node, its start offset is its start’s offset,＼
</li>
	<li>
(
`終端~node@,
`終端~offset@
) は、順に，`終端$の
( `~node$bp, `~offset$bp )
を指すとする。
◎
its end node is its end’s node, and its end offset is its end’s offset.
</li>
</ul>

<p>
所与の`範囲o$は、次を満たすとき
`畳まれて@
いるとされる
【！等bp】
⇒
［
`始端~node$ ~EQ `終端~node$
］~AND［
`始端~offset$ ~EQ `終端~offset$
］
◎
A range is collapsed if its start node is its end node and its start offset is its end offset.
</p>

<dl class="domintro">
	<dt>%node = %range . $startContainer</dt>
	<dd>
%range の`始端~node$を返す。
◎
Returns range’s start node.
</dd>

	<dt>%offset = %range . $startOffset</dt>
	<dd>
%range の`始端~offset$を返す。
◎
Returns range’s start offset.
</dd>

	<dt>%node = %range . $endContainer</dt>
	<dd>
%range の`終端~node$を返す。
◎
Returns range’s end node.
</dd>

	<dt>%offset = %range . $endOffset</dt>
	<dd>
%range の`終端~offset$を返す。
◎
Returns range’s end offset.
</dd>

	<dt>%collapsed = %range . $collapsed</dt>
	<dd>
%range は`畳まれて$［
いるならば ~T ／
いないならば ~F
］を返す。
◎
Returns true if range is collapsed; otherwise false.
</dd>
</dl>

<div class="algo">
@startContainer
取得子~手続きは
⇒
~RET コレの`始端~node$
◎
The startContainer getter steps are to return this’s start node.
</div>

<div class="algo">
@startOffset
取得子~手続きは
⇒
~RET コレの`始端~offset$
◎
The startOffset getter steps are to return this’s start offset.
</div>

<div class="algo">
@endContainer
取得子~手続きは
⇒
~RET コレの`終端~node$
◎
The endContainer getter steps are to return this’s end node.
</div>

<div class="algo">
@endOffset
取得子~手続きは
⇒
~RET コレの`終端~offset$
◎
The endOffset getter steps are to return this’s end offset.
</div>

<div class="algo">
@collapsed
取得子~手続きは
⇒
~RET ［
コレは`畳まれて$［
いるならば ~T ／
いないならば ~F
］
◎
The collapsed getter steps are to return true if this is collapsed; otherwise false.
</div>

		</section>
		<section id="interface-staticrange">
<h3 title="Interface StaticRange">5.4. ^StaticRange ~interface</h3>

！！
dictionary @@StaticRangeInit {
  required $Node @startContainer;
  required `unsigned long$ @startOffset;
  required $Node @endContainer;
  required `unsigned long$ @endOffset;
};

[`Exposed$=Window]
interface @@StaticRange : $AbstractRange {
  `StaticRange$mc($StaticRangeInit %init);
};
！

<dl class="domintro">
	<dt>%staticRange  = $StaticRange(init)</dt>
	<dd>
`~node~tree$が変異しても更新しない，新たな`範囲o$を返す。
◎
Returns a new range object that does not update when the node tree mutates.
</dd>
</dl>

<div class="algo">
<p>
@StaticRange(init)
構築子~手続きは：
<!-- ^@StaticRangeInit -->
</p>
<ol>
	<li>
%始端~node ~LET %init[ "$startContainer" ]
</li>
	<li>
%終端~node ~LET %init[ "$endContainer" ]
</li>
	<li>
~IF［
%始端~node, %終端~node いずれかは［
$DocumentType ／ $Attr
］`~node$である
］
⇒
~THROW `InvalidNodeTypeError$E
</li>
	<li>
コレの`始端$ ~SET `境界点$( %始端~node, %init[ "$startOffset" ] ),
</li>
	<li>
コレの`終端$ ~SET `境界点$( %終端~node, %init[ "$endOffset" ] )
</li>
</ol>
◎
The new StaticRange(init) constructor steps are:
• If init["startContainer"] or init["endContainer"] is a DocumentType or Attr node, then throw an "InvalidNodeTypeError" DOMException.
• Set this’s start to (init["startContainer"], init["startOffset"]) and end to (init["endContainer"], init["endOffset"]).
</div>

<p>
`範囲o$【！StaticRange】は、次をすべて満たすならば
`妥当@rg
であるとされる：
◎
A StaticRange is valid if all of the following are true:
</p>
<ul>
	<li>
`始端$, `終端$は同じ`~node~tree$内にある
◎
Its start and end are in the same node tree.
</li>
	<li>
0 ~LTE `始端~offset$ ~LTE `始端~node$の`長さ$
◎
Its start offset is between 0 and its start node’s length, inclusive.
</li>
	<li>
0 ~LTE `終端~offset$ ~LTE `終端~node$の`長さ$
◎
Its end offset is between 0 and its end node’s length, inclusive.
</li>
	<li>
`始端$は`終端$`より前$iか`終端$`に等しい$i
◎
Its start is before or equal to its end.
</li>
</ul>

		</section>
		<section id="interface-range">
<h3 title="Interface Range">5.5. ^@Range ~interface</h3>

！！
[`Exposed$=Window]
interface @Range : $AbstractRange {
  `Range$mc();

  ~RA $Node $commonAncestorContainer;

  $undefined $setStart($Node %node, `unsigned long$ %offset);
  $undefined $setEnd($Node %node, `unsigned long$ %offset);
  $undefined $setStartBefore($Node %node);
  $undefined $setStartAfter($Node %node);
  $undefined $setEndBefore($Node %node);
  $undefined $setEndAfter($Node %node);
  $undefined $collapse(optional $boolean %toStart = false);
  $undefined $selectNode($Node %node);
  $undefined $selectNodeContents($Node %node);

  const `unsigned short$ @START_TO_START = 0;
  const `unsigned short$ @START_TO_END = 1;
  const `unsigned short$ @END_TO_END = 2;
  const `unsigned short$ @END_TO_START = 3;
  $short $compareBoundaryPoints(`unsigned short$ %how, $Range %sourceRange);

  [`CEReactions$] $undefined $deleteContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $extractContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $cloneContents();
  [`CEReactions$] $undefined $insertNode($Node %node);
  [`CEReactions$] $undefined $surroundContents($Node %newParent);

  [`NewObject$] $Range $cloneRange();
  $undefined $detach();

  $boolean $isPointInRange($Node %node, `unsigned long$ %offset);
  $short $comparePoint($Node %node, `unsigned long$ %offset);

  $boolean $intersectsNode($Node %node);

  $stringifier;
};
！

<p>
$Range ~interfaceを実装する~objは単に
`~live範囲o@
とも称される。
◎
Objects implementing the Range interface are known as live ranges.
</p>

<p class="note">注記：
`~tree$を改変する~algo（特に，
`~nodeを子の前に挿入する$,
`~nodeを除去する$,
`~dataを置換する$,
`~Text~nodeを分割する$
）は、その`~tree$に結付けられている一連の`~live範囲o$も改変する。
◎
Algorithms that modify a tree (in particular the insert, remove, replace data, and split algorithms) modify live ranges associated with that tree.
</p>

<p>
`~live範囲o$の
`根@rg
とは、その`始端~node$の`根$である。
◎
The root of a live range is the root of its start node.
</p>

<p class="trans-note">【
`終端~node$の`根$と同じになる（常にそうなるように拘束される）。
各 `~live範囲o$は、その作成-時からずっと，同じある`~node~tree$に結付けられ続ける
— 言い換えれば、`根$rgは変化しない。
（仕様には明示的にそう述べられてはいないが、各種~algoの挙動から，そう結論できる。
一般の`範囲o$については、おそらく成立しない
（この仕様からは判別できないが、わざわざ，`妥当$rgかどうかについて定義されているので）。
】</p>

<p>
次をいずれも満たす`~node$ %node は、`~live範囲o$ %範囲o に
`包含され@
ているとされる：
◎
A node node is contained in a live range range if＼
</p>
<ul>
	<li>
%node の`根$ ~EQ %範囲o の`根$rg
◎
node’s root is range’s root, and ＼
</li>
	<li>
`境界点$( %node, 0 ) は %範囲o の`始端$`より後$i
◎
(node, 0) is after range’s start, and＼
</li>
	<li>
`境界点$( %node, %node の`長さ$ ) は %範囲o の`終端$`より前$i
◎
(node, node’s length) is before range’s end.
</li>
</ul>

<p>
次のいずれかを満たす`~node$ %node は、`~live範囲o$ %範囲o に
`部分的に包含され@
ているとされる：
◎
A node is partially contained in a live range if＼
</p>
<ul>
	<li>
［
%node は %範囲o の`始端~node$の`広義-先祖$である
］~AND［
%node は %範囲o の`終端~node$の`広義-先祖$でない
］
◎
it’s an inclusive ancestor of the live range’s start node but not its end node, or＼
</li>
	<li>
［
%node は %範囲o の`始端~node$の`広義-先祖$でない
］~AND［
%node は %範囲o の`終端~node$の`広義-先祖$である
］
◎
vice versa.
</li>
</ul>

<div class="trans-note">
<p>【
次の図は先掲の模式図と同様に~treeを表したものであり，図の記号 `s^mk が始端, `e^mk が終端を表すとする。
このとき、図の~COLOR_Xの~nodeが包含され, ~COLOR_Yの~node（始端／終端の一方のみを内部に含む~node）が部分的に包含される。
最上層の横線の~nodeは 内部に `s^mk, `e^mk とも含むので、~~定義により，`部分的に包含され$ることはない。
】</p>

`[|(|.|)|[|]|[y|(y|.|.|s)|]|[x|(x|.|)|]|(x|.|.|.|)|[x|]|(x|.|.|)|[y|(x|.|)|[x|(x|.|)|]|[y|(y|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]|]^bpex

</div>

<div class="note">
<p>注記：
これらの定義をより理解し易くする事実をいくつか挙げる：
◎
Some facts to better understand these definitions:
</p>

<ul>
	<li>
`~live範囲o$の`中身$rgは、`包含され$ているすべての`~node$に加えて，［［
`始端~node$ ／ `終端~node$
］の`広義-子孫$である`文字~data~node$のうち，範囲oに入るもの
］からなるものとみなせる。
◎
The content that one would think of as being within the live range consists of all contained nodes, plus possibly some of the contents of the start node and end node if those are CharacterData nodes.
</li>
	<li>
`~live範囲o$に`包含され$ている`~node$たちの集合は、`包含され$ている`~node$の`親$が常に`包含され$るとは限らないので，一般に連続的でない。
◎
The nodes that are contained in a live range will generally not be contiguous, because the parent of a contained node will not always be contained.
</li>
	<li>
しかしながら，`包含され$ている`~node$の`子孫$は`包含され$ており、 2 つの`同胞$が`包含され$ているならば，それらの間に在るどの`同胞$も`包含され$る。
◎
However, the descendants of a contained node are contained, and if two siblings are contained, so are any siblings that lie between them.
</li>
	<li>
`~live範囲o$の`始端~node$ と`終端~node$ は決して その範囲oに`包含され$ない。
◎
The start node and end node of a live range are never contained within it.
</li>
	<li>
`包含され$ている`~node$のうち、最初のもの（もし在れば）は，常に`始端~node$に`後続-$し、最後のものは，常に`終端~node$の最後の`子孫$と同じか, それに`先行-$する。
【！descendant を持たない場合は？】
◎
The first contained node (if there are any) will always be after the start node, and the last contained node will always be equal to or before the end node’s last descendant.
</li>
	<li>
部分的に包含される`~node$が存在するのは、`始端~node$ と`終端~node$ が異なるとき, そのときに限る。
◎
There exists a partially contained node if and only if the start node and end node are different.
</li>
	<li>
`始端~node$と`終端~node$の`共通な広義-先祖$は、`包含され$ることも, `部分的に包含され$ることもない。
◎
The commonAncestorContainer attribute value is neither contained nor partially contained.
</li>
	<li>
<p>
`始端~node$ %A が `終端~node$ %B の`先祖$である場合：
</p>
<ul ><li>%A が， %A, %B に`共通な広義-先祖$になる。
</li><li>%A の`子$のうち， 1 つだけ（ %C とする）が`部分的に包含され$る。
</li><li>%A の別の`子$ %C1 が`包含され$るのは、 %C1 が %C に`先行-$するとき, そのときに限る。
</li></ul>

<div class="trans-note">
<p>【
この場合の例。
前と同様，記号 `s^mk は始端, `e^mk は終端を表す。
この例では図の最上層の~nodeが共通な広義-先祖になる。
共通な広義-先祖の子のうち、~COLOR_Yの~nodeが上述の %C （共通な広義-先祖の子であってかつ部分的に包含される）に該当し，~COLOR_Xの~nodeが`包含され$る子になる。
】</p>

`[|(|.|)|s[x|(|.|)|]|(x|.|.|)|[x|(|.|.|)|]|[y|[|(|.|)|]|(|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]^bpex

</div>

<p>
%B が %A の`先祖$である場合、前述の逆になる。
【上の図で、 `s^mk と `e^mk を入れ替えて，右端から~treeの順序が開始されていると考えるとよい。】
</p>

◎
If the start node is an ancestor of the end node, the common inclusive ancestor will be the start node. Exactly one of its children will be partially contained, and a child will be contained if and only if it precedes the partially contained child. If the end node is an ancestor of the start node, the opposite holds.
</li>
	<li>
`始端~node$ %A, `終端~node$ %B とも他方の`広義-先祖$でない場合：
%A, %B の`共通な広義-先祖$ %先祖 は、 %A とも %B とも異なる。
%先祖 の`子$のうち，ちょうど 2 個が`部分的に包含され$、
%先祖 の`子$が`包含され$るのは，これら 2 個の合間に在るとき, そのときに限る。
◎
If the start node is not an inclusive ancestor of the end node, nor vice versa, the common inclusive ancestor will be distinct from both of them. Exactly two of its children will be partially contained, and a child will be contained if and only if it lies between those two.
</li>
</ul>
</div>

<hr>

<dl class="domintro">
	<dt>%range = $Range()</dt>
	<dd>
新たな`~live範囲o$を返す。
◎
Returns a new live range.
</dd>
</dl>

<div class="algo">
<p>
@Range()
構築子~手続きは：
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
</li>
	<li>
コレの`始端$ ~SET `境界点$( %文書, 0 )
</li>
	<li>
コレの`終端$ ~SET `境界点$( %文書, 0 )
</li>
</ol>
◎
The new Range() constructor steps are to set this’s start and end to (current global object’s associated Document, 0).
</div>

<dl class="domintro">
	<dt>%container = %range . $commonAncestorContainer</dt>
	<dd>
%range の［
`始端~node$, `終端~node$
］両者の`広義-先祖$であるような，最も末端の~nodeを返す。
【原文の “ancestor” （先祖）は~~厳密な記述ではない。】
◎
Returns the node, furthest away from the document, that is an ancestor of both range’s start node and end node.
</dd>
</dl>

<div class="algo">
@commonAncestorContainer
取得子~手続きは
⇒
~RET コレの
( `始端~node$, `終端~node$ )
の`共通な広義-先祖$
◎
The commonAncestorContainer getter steps are:
• Let container be start node.
• While container is not an inclusive ancestor of end node, let container be container’s parent.
• Return container.
</div>

<div class="algo">
<p>
【この訳では便宜のため，次を定義する：】
同じ~treeに`関与-$している 2 つの~node %A, %B の（最も末端の）
`共通な広義-先祖@
は、次の~algoを走らせた結果を返す：
</p>
<ol>
	<li>
~WHILE［
%A は %B の`広義-先祖$でない
］
⇒
%A ~SET %A の`親$
</li>
	<li>
~RET %A
</li>
</ol>

◎
↑</div>

<hr>

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methodは、範囲oの片方または両方の境界点を新たな地点に変更する。
片方の境界点（以下， %P ）のみを変更する~methodについては、整合性を保つため，もう片方の境界点（以下， %Q ）も必要に応じて~~正される：
すなわち， %Q が［
%P と異なる~treeの中に在る, または［
%P `より前$i（始端が変更された場合） ／
%P `より後$i（終端が変更された場合）
］に位置する
］ようになった場合、 %P と同じ地点にされる（ 範囲oは畳まれる）。
】</p>

<dl class="domintro">

	<dt>%range . $setStart(node, offset)</dt>
	<dt>%range . $setEnd(node, offset)</dt>
	<dd>
それぞれ，始端／終端を `境界点$( %node, %offset ) と同じ位置にする。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
他の場合，
%offset が %node の`長さ$を超えている場合，
`IndexSizeError$E 例外が投出される。
</dd>

	<dt>%range . $setStartBefore(node)</dt>
	<dt>%range . $setStartAfter(node)</dt>
	<dd>
それぞれ，始端を %node の外縁の［
始端（下図の `S^mk ）／終端（下図の `E^mk ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $setEndBefore(node)</dt>
	<dt>%range . $setEndAfter(node)</dt>
	<dd>
それぞれ，終端を %node の外縁の［
始端（下図の `S^mk ）／終端（下図の `E^mk ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dd class="trans-note">
（説明用の図式
— %node 引数が，図の~COLOR_Yが表す~nodeに対応しているとする。）

`[|(|.|)|[|(|.|)|S[y|s[|(|.|)|]|(|.|.|.|)|[|]|e]|E(|.|.|)|]|]^bpex

</dd>

	<dt>%range . $collapse(toStart)</dt>
	<dd>
範囲oを畳む
— すなわち、 %toStart が ~T の場合は 終端を始端と同じ地点に位置させ，他の場合は 始端を終端と同じ地点に位置させる。
</dd>

	<dt>%range . $selectNode(node)</dt>
	<dd>
%node を選択する
— すなわち、始端と終端を %node の外縁の両端（上図の `S^mk, `E^mk ）に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $selectNodeContents(node)</dt>
	<dd>
%node の内容を選択する
— すなわち、始端と終端を %node の内縁の両端（上図の `s^mk, `e^mk ）に位置させる。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
%range の始端または終端（ %how により指示される）の位置bpが，
%sourceRange の始端または終端（ %how により指示される）［
`より前$i, `に等しい$i, `より後$i
］のいずれになるかに応じて、［
−1, 0, 1
］を返す。
</dd>
</dl>

<div class="algo">
<p>
`範囲o$ %範囲o の
`境界点を設定する@
ときは、所与の
( %端 ~IN { `始端^i, `終端^i }, `~node$ %node, 負でない整数 %offset )
に対し，次を走らす：
◎
To set the start or end of a range to a boundary point (node, offset), run these steps:
</p>
<ol>
	<li id="cp-throw-if-doctype">
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
</li>
	<li id="cp-throw-if-length">
~IF［
%offset ~GT %node の`長さ$
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than node’s length, then throw an "IndexSizeError" DOMException.
</li>
	<li>
%境界点 ~LET `境界点$( %node, %offset )
◎
Let bp be the boundary point (node, offset).
</li>
	<li>
<p>
~IF［
%端 ~EQ `始端^i
］：
◎
If these steps were invoked as "set the start"
</p>
		<ol>
			<li>
~IF［
%範囲o の`根$rg ~NEQ %node の`根$
］~OR［
%境界点 は %範囲o の`終端$`より後$i
］
⇒
%範囲o の`終端$ ~SET %境界点
◎
If range’s root is not equal to node’s root, or if bp is after the range’s end, set range’s end to bp.
</li>
			<li>
%範囲o の`始端$ ~SET %境界点
◎
Set range’s start to bp.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %端 ~EQ `終端^i ）
◎
If these steps were invoked as "set the end"
</p>
		<ol>
			<li>
~IF［
%範囲o の`根$rg ~NEQ %node の`根$
］~OR［
%境界点 は %範囲o の`始端$`より前$i
］
⇒
%範囲o の`始端$ ~SET %境界点
◎
If range’s root is not equal to node’s root, or if bp is before the range’s start, set range’s start to bp.
</li>
			<li>
%範囲o の`終端$ ~SET %境界点
◎
Set range’s end to bp.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
@setStart(node, offset)
~method~手続きは
⇒
コレの`境界点を設定する$( `始端^i, %node, %offset )
◎
The setStart(node, offset) method steps are to set the start of this to boundary point (node, offset).
</div>

<div class="algo">
@setEnd(node, offset)
~method~手続きは
⇒
コレの`境界点を設定する$( `終端^i, %node, %offset )
◎
The setEnd(node, offset) method steps are to set the end of this to boundary point (node, offset).
</div>

<div class="algo">
<p>
@setStartBefore(node)
~method~手続きは：
◎
The setStartBefore(node) method steps are:
</p>
<ol>
	<li id="cp-let-parent">
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
	<li id="cp-throw-if-null">
~IF［
%親 ~EQ ~NULL
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If parent is null, then throw an "InvalidNodeTypeError" DOMException.
</li>
	<li>
コレの`境界点を設定する$( `始端^i, %親, %node の`~index$ )
◎
Set the start of this to boundary point (parent, node’s index).
</li>
</ol>
</div>

<div class="algo">
<p>
@setStartAfter(node)
~method~手続きは：
◎
The setStartAfter(node) method steps are:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
コレの`境界点を設定する$( `始端^i, %親, %node の`~index$ ~PLUS 1 )
◎
Set the start of this to boundary point (parent, node’s index plus 1).
</li>
</ol>
</div>

<div class="algo">
<p>
@setEndBefore(node)
~method~手続きは：
◎
The setEndBefore(node) method steps are:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
コレの`境界点を設定する$( `終端^i, %親, %node の`~index$ )
◎
Set the end of this to boundary point (parent, node’s index).
</li>
</ol>
</div>

<div class="algo">
<p>
@setEndAfter(node)
~method~手続きは：
◎
The setEndAfter(node) method steps are:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
コレの`境界点を設定する$( `終端^i, %親, %node の`~index$ ~PLUS 1 )
◎
Set the end of this to boundary point (parent, node’s index plus 1).
</li>
</ol>
</div>

<div class="algo">
<p>
@collapse(toStart)
~method~手続きは：
◎
The collapse(toStart) method steps are to＼
</p>
<ol>
	<li>
~IF［
%toStart ~EQ ~T
］
⇒
コレの`終端$ ~SET `境界点$( コレの`始端~node$, コレの`始端~offset$ )
◎
if toStart is true, set end to start;＼
</li>
	<li>
~ELSE
⇒
コレの`始端$ ~SET `境界点$( コレの`終端~node$, コレの`終端~offset$ )
◎
otherwise set start to end.
</li>
</ol>
</div>

<div class="algo">
<p>
`~node$ %node を，`範囲o$ %範囲o の
`中身として選択-@rg
するときは、次を走らす：
◎
To select a node node within a range range, run these steps:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
%index ~LET %node の`~index$
◎
Let index be node’s index.
</li>
	<li>
%範囲o の`始端$ ~SET `境界点$( %親, %index )
◎
Set range’s start to boundary point (parent, index).
</li>
	<li>
%範囲o の`終端$ ~SET `境界点$( %親, %index ~PLUS 1 )
◎
Set range’s end to boundary point (parent, index plus 1).
</li>
</ol>
</div>

<div class="algo">
<p>
@selectNode(node)
~method~手続きは
⇒
%node を，コレの`中身として選択-$rgする
◎
The selectNode(node) method steps are to select node within this.
</div>

<div class="algo">
<p>
@selectNodeContents(node)
~method~手続きは：
◎
The selectNodeContents(node) method steps are:
</p>
<ol>
	<li>
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, throw an "InvalidNodeTypeError" DOMException.
</li>
	<li>
%長さ ~LET %node の`長さ$
◎
Let length be the length of node.
</li>
	<li>
コレの`始端$ ~SET `境界点$( %node, 0 )
◎
Set start to the boundary point (node, 0).
</li>
	<li>
コレの`終端$ ~SET `境界点$( %node, %長さ )
◎
Set end to the boundary point (node, length).
</li>
</ol>
</div>

<div class="algo">
<p>
@compareBoundaryPoints(how, sourceRange)
~method~手続きは：
◎
The compareBoundaryPoints(how, sourceRange) method steps are:
</p>
<ol>
	<li>
~IF［
%how ~NIN {
$START_TO_START,
$START_TO_END,
$END_TO_END,
$END_TO_START
}
］
⇒
~THROW `NotSupportedError$E
◎
If how is not one of
• START_TO_START
• START_TO_END
• END_TO_END
• END_TO_START
◎
then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
コレの`根$rg ~NEQ %sourceRange の`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If this’s root is not the same as sourceRange’s root, then throw a "WrongDocumentError" DOMException.
</li>
	<li>
<p>
( %基準点, %この点 ) ~LET %how に応じて，次で与えられる 2 個の`境界点$：
◎
If how is:
</p>
		<dl class="switch">
			<dt>$START_TO_START:</dt>
			<dd>
( %sourceRange の`始端$, コレの`始端$ )
◎
Let this point be this’s start. Let other point be sourceRange’s start.
</dd>

			<dt>$START_TO_END:</dt>
			<dd>
( %sourceRange の`始端$, コレの`終端$ )
◎
Let this point be this’s end. Let other point be sourceRange’s start.
</dd>

			<dt>$END_TO_END:</dt>
			<dd>
( %sourceRange の`終端$, コレの`終端$ )
◎
Let this point be this’s end. Let other point be sourceRange’s end.
</dd>

			<dt>$END_TO_START:</dt>
			<dd>
( %sourceRange の`終端$, コレの`始端$ )
◎
Let this point be this’s start. Let other point be sourceRange’s end.
</dd>
		</dl>
	</li>
	<li>
~RET ［
%この点 は %基準点 ［
`より前$i ならば ~MINUS 1 ／
`に等しい$i ならば 0 ／
`より後$i ならば 1
］
◎
If the position of this point relative to other point is
◎
before
• Return −1.
◎
equal
• Return 0.
◎
after
• Return 1.
</li>
</ol>
</div>

<!-- ^@Range -->

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methodは、主に，範囲oの`中身$rgを操作する。
】</p>

<dl class="domintro">
	<dt>%range . $deleteContents()</dt>
	<dd>
`~live範囲o$の`中身$rgを削除した上で、範囲oの`境界点$を畳む。
</dd>
	<dd>
<p>
`deleteContents()^c の実行例。
図の記号［
`s^mk, `e^mk
］が順に範囲の［
始端, 終端
］を表すとするとき、図左の~~状態から図右の~~状態になる。
包含されている~node（図の ~COLOR_X ）, および
始端／終端~nodeの文字~dataのうち 範囲oに入る部分の文字（図の `+^c ）が除去される。
部分的に包含されている~node（図の ~COLOR_Y ）は除去されない。
この例では、始端 `s^mk が指す`文字~data~node$は，~dataは空になるが~node自体は残される。
図右の `S^mk, `E^mk が元の始端, 終端に対応する位置であるが、実行後の始端と終端は，図右の `X^mk （共通な広義-先祖の直下）を指すようにされることに注意（範囲oは畳まれる）。
始端~nodeが終端~nodeの`広義-先祖$であった場合、始端の位置は変化しない。
始端~nodeが終端~node の`広義-子孫$であった場合、全体の終端（右端）から相対的な終端の位置は変化しない。
</p>

`[|[|]|[y|(y|s+|)|]|[x|(|.|)|]|[y|(x|.|)|[y|(y|+|+|e.|)|[|]|]|(|.|)|]|] → [|[|]|[y|(y|S)|]|X[y|[y|(y|E.|)|[|]|]|(|.|)|]|]^bpex

</dd>

	<dt>%range . $extractContents()</dt>
	<dd>
`~live範囲o$の`中身$rgを~cloneした結果を返すと同時に，中身は削除する（ “カット” ）。
機能上は
$cloneContents() と $deleteContents()
の組み合わせと等価になる。
</dd>

	<dt>%range . $cloneContents()</dt>
	<dd>
`~live範囲o$の`中身を~clone$rgした結果を返す。
返される`中身$rgは、新たな`文書片$で包装される。
</dd>
	<dd>
<p>
^cloneContents() の実行例。
図左の記号［
`s^mk, `e^mk
］が順に範囲の［
始端, 終端
］を表すとするとき、その間に挟まれた部分の~cloneが図右に示すように得られる（ `S^mk, `E^mk が元の始端と終端に対応する位置）。
図の~COLOR_Yの 2 個の~nodeが，範囲に`部分的に包含され$ている子。
入れ物にあたる それらの`共通な広義-先祖$は、~cloneにおいては`文書片$（~COLOR_X）に置換される。
始端 `s^mk が属する`文字~data~node$は~dataが空になるが、~node自体は［
その親から共通な広義-先祖の子まで
］の先祖も含めて~cloneされる。
</p>

`[|[|]|[y|(|.|s)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|e.|)|[|]|]|(|.|)|]|] → [x|[y|(|S)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|E)|]|]|]^bpex

</dd>

	<dt>%range . $insertNode(node)</dt>
	<dd>
`~live範囲o$の`中身$rgの先頭に %node を挿入する（`中身に挿入-$rgする）。
</dd>

	<dt>%range . $surroundContents(newParent)</dt>
	<dd>
`~live範囲o$の`中身$rgを %newParent ~nodeで包装する。
それに伴い、範囲oの始端, 終端は， %newParent の（外縁の）両端を指すようにされる。
包装するに先立って、
%newParent の元々の子はすべて除去され，
%newParent 自身も元々の親から除去される。
</dd>
	<dd>
<p>
^surroundContents(%newParent) の実行例。
記号 `s^mk は始端, `e^mk は終端を表すとき、それらに挟まれた区間が %newParent で包装される（図の~COLOR_Y）。
`部分的に包含され$るものは `Text^c 以外は許容されないので、始端と終端は `Text^c の層を~~無視すれば同じ親の直下に在る必要がある（さもなければ例外が投出される）。
図の `e^mk の様に境界点が `Text^c ~node内に位置していた場合、その~nodeはそこで分割される。
</p>

`[|(|.|)|s[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|e.|)|] → [|(|.|)|s[y|[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|)|]|e(|.|)|]^bpex
</dd>
</dl>

<div class="algo">
<p>
@deleteContents()
~method~手続きは：
◎
The deleteContents() method steps are:
</p>
<ol>
	<li>
~IF［
コレは`畳まれて$いる
］
⇒
~RET
◎
If this is collapsed, then return.
</li>
	<li>
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に，コレの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be this’s start node, start offset, end node, and end offset, respectively.
</li>
	<li>
<p>
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node は`文字~data~node$である
］：
◎
If original start node is original end node and it is a CharacterData node, then＼
</p>
		<ol>
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string,＼
</li>
			<li>
~RET
◎
and then return.
</li>
		</ol>
	</li>
	<li>
%除去対象 ~LET ［
コレに`包含され$ている`~node$のうち，`親$もコレに`包含され$ているものは除いたもの
］からなる，`~tree順序$の~list
◎
Let nodes to remove be a list of all the nodes that are contained in this, in tree order, omitting any node whose parent is also contained in this.
</li>
	<li id="cp-let-new-if">
~IF［
%元の始端~node は %元の終端~node の`広義-先祖$である
］
⇒＃
%新-~node ~LET %元の始端~node；
%新-~offset ~LET %元の始端~offset
◎
If original start node is an inclusive ancestor of original end node, set new node to original start node and new offset to original start offset.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%新-~node ~LET
( %元の始端~node, %元の終端~node )
の`共通な広義-先祖$
</li>
			<li>
%新-~offset ~LET ［
%新-~node の`子$のうち, %元の始端~node の`広義-先祖$である`~node$ †
］の`~index$ ~PLUS 1
</li>
		</ol>

<p class="trans-note">【
見通しを良くするため、ここの訳は，原文を等価な記述に変形している。
前~段の条件の否定が成立することから † に該当する~nodeは必ず存在し， %新-~node に`部分的に包含され$ている子のうち 最初のものになる。
】</p>

◎
Otherwise:
• Let reference node equal original start node.
• While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
• Set new node to the parent of reference node, and new offset to one plus the index of reference node.
• If reference node’s parent were null, it would be the root of this, so would be an inclusive ancestor of original end node, and we could not reach this point.
</li>
	<li>
~IF［
%元の始端~node は`文字~data~node$である
］
⇒
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$ ~MINUS %元の始端~offset, 空~文字列 )
◎
If original start node is a CharacterData node, then replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, data the empty string.
</li>
	<li>
%除去対象 を成す
~EACH( %node )
に対し，`~tree順序$で
⇒
`~nodeを除去する$( %node )
◎
For each node in nodes to remove, in tree order, remove node.
</li>
	<li>
~IF［
%元の終端~node は`文字~data~node$である
］
⇒
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
If original end node is a CharacterData node, then replace data with node original end node, offset 0, count original end offset and data the empty string.
</li>
	<li>
コレの
⇒＃
`始端$ ~SET `境界点$( %新-~node, %新-~offset )；
`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set start and end to (new node, new offset).
</li>
</ol>
</div>

<div class="algo">
<p>
`~live範囲o$ %範囲o の
`中身を抽出-@rg
するときは、次を走らす：
◎
To extract a live range range, run these steps:
</p>
<ol>
	<li id="cp-new-frag">
%断片 ~LET 次のように設定された新たな`文書片$`~node$
⇒
`~node文書$ ~SET %範囲o の`始端~node$の`~node文書$
◎
Let fragment be a new DocumentFragment node whose node document is range’s start node’s node document.
</li>
	<li id="cp-ret-frag-if">
~IF［
%範囲o は`畳まれて$いる
］
⇒
~RET %断片
◎
If range is collapsed, then return fragment.
</li>
	<li id="cp-let-bp-vars">
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に， %範囲o の
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be range’s start node, start offset, end node, and end offset, respectively.
</li>
	<li>
<p id="cp-if-s-is-e-and">
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node は`文字~data~node$である
］：
◎
If original start node is original end node and it is a CharacterData node, then:
</p>
		<ol>
			<li id="cp-let-clone-s">
%clone ~LET `~nodeを~cloneする$( %元の始端~node )
◎
Let clone be a clone of original start node.
</li>
			<li id="cp-set-clone-data-1">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の終端~offset ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original end offset minus original start offset.
</li>
			<li id="cp-append-clone">
%断片 に`~nodeを付加する$( %clone )
◎
Append clone to fragment.
</li>
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string.
</li>
			<li id="cp-ret-flag">
~RET %断片
◎
Return fragment.
</li>
		</ol>
	</li>
	<li id="cp-let-common-anc">
%共通な広義-先祖 ~LET
( %元の始端~node, %元の終端~node )
の`共通な広義-先祖$
◎
Let common ancestor be original start node.
◎
While common ancestor is not an inclusive ancestor of original end node, set common ancestor to its own parent.
</li>
	<li id="cp-let-1st-pcc-null">
%部分的に包含されている最初の子 ~LET ~NULL
◎
Let first partially contained child be null.
</li>
	<li id="cp-set-1st-pcc-if">
~IF［
%元の始端~node は %元の終端~node の`広義-先祖$でない
］
⇒
%部分的に包含されている最初の子 ~SET
%範囲o に`部分的に包含され$ている［
%共通な広義-先祖 の`子$
］のうち，最初のもの
◎
If original start node is not an inclusive ancestor of original end node, set first partially contained child to the first child of common ancestor that is partially contained in range.
</li>
	<li id="cp-let-last-pcc-null">
%部分的に包含されている最後の子 ~LET ~NULL
◎
Let last partially contained child be null.
</li>
	<li id="cp-set-last-pcc-if">
		<p>
~IF［
%元の終端~node は %元の始端~node の`広義-先祖$でない
］
⇒
%部分的に包含されている最後の子 ~SET
%範囲o に`部分的に包含され$ている［
%共通な広義-先祖 の`子$
］のうち，最後のもの
◎
If original end node is not an inclusive ancestor of original start node, set last partially contained child to the last child of common ancestor that is partially contained in range.
</p>

<p class="note">注記：
これらの変数~代入は実際に常にイミを成す。
例えば， %元の始端~node が %元の終端~node の`広義-先祖$でない場合、［
%元の始端~node ~EQ %共通な広義-先祖
］にはなり得ないので［
%元の始端~node の広義-先祖であって %共通な広義-先祖 の子孫でもあるもの
］が 1 つ以上あり，それらは %範囲o に`部分的に包含され$、それらのうち %共通な広義-先祖 の子であるものが該当するものになる。
逆の場合も同様になる。
また、 2 つの子がいずれも定義されたなら，それらは決して等しくならないことにも注意。
◎
These variable assignments do actually always make sense. For instance, if original start node is not an inclusive ancestor of original end node, original start node is itself partially contained in range, and so are all its ancestors up until a child of common ancestor. common ancestor cannot be original start node, because it has to be an inclusive ancestor of original end node. The other case is similar. Also, notice that the two children will never be equal if both are defined.
</li>
	<li id="cp-let-contained">
%包含されている子~群 ~LET ［
%共通な広義-先祖 の`子$のうち， %範囲o に`包含され$ているもの
］すべてからなる，`~tree順序$による~list
◎
Let contained children be a list of all children of common ancestor that are contained in range, in tree order.
</li>
	<li id="cp-throw-if-a-doctype">
<p>
~IF［
%包含されている子~群 内に`~doctype$が在る
］
⇒
~THROW `HierarchyRequestError$E
◎
If any member of contained children is a doctype, then throw a "HierarchyRequestError" DOMException.
</p>

<p class="note">注記：
`~doctype$が`部分的に包含され$ることは決してないので、部分的に包含される~nodeを気にする必要はない。
それは 範囲o の境界点
【始端~node／終端~node】
にはなり得ず, 何かの先祖にもなり得ない。
◎
We do not have to worry about the first or last partially contained node, because a doctype can never be partially contained. It cannot be a boundary point of a range, and it cannot be the ancestor of anything.
</p>
	</li>
	<!--cp-let-new-if-->
	<li>
<p>
~ELSE
⇒＃
%新-~node ~LET %共通な広義-先祖；
%新-~offset ~LET %部分的に包含されている最初の子 の`~index$ ~PLUS 1
</p>

<p class="trans-note">【
ここの訳は、原文の記述と同じ結果を得るものに簡略化している。
】</p>

◎
Otherwise:
• Let reference node equal original start node.
• While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
• Set new node to the parent of reference node, and new offset to one plus reference node’s index.
• If reference node’s parent is null, it would be the root of range, so would be an inclusive ancestor of original end node, and we could not reach this point.
</li>
	<li>

<p id="cp-if-1st-pcc-is-cdata">
~IF［
%部分的に包含されている最初の子 は`文字~data~node$である
］：
◎
If first partially contained child is a CharacterData node, then:
</p>

<p class="note" id="cp-if-1st-pcc-is-cdata-note">
この事例では， %部分的に包含されている最初の子 は %元の始端~node である。
◎
In this case, first partially contained child is original start node.
</p>
		<ol>
			<!--cp-let-clone-s-->
			<li id="cp-set-clone-data-2">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の始端~node の`長さ$ ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original start node’s length minus original start offset.
</li>
			<!--cp-append-clone-->
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$ ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, and data the empty string.
</li>
		</ol>
	</li>
	<li>

<p id="cp-elseif-1st-pcc-not-null">
~ELIF［
%部分的に包含されている最初の子 ~NEQ ~NULL
］：
◎
Otherwise, if first partially contained child is not null:
</p>
		<ol>
			<li id="cp-let-clone-1st-pcc">
%clone ~LET `~nodeを~cloneする$( %部分的に包含されている最初の子 )
◎
Let clone be a clone of first partially contained child.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange1">
%下位-範囲o ~LET 次のように設定された新たな`~live範囲o$
⇒＃
`始端$ ~SET `境界点$( %元の始端~node, %元の始端~offset ),
`終端$ ~SET `境界点$( %部分的に包含されている最初の子, %部分的に包含されている最初の子 の`長さ$ )
◎
Let subrange be a new live range whose start is (original start node, original start offset) and whose end is (first partially contained child, first partially contained child’s length).
</li>
			<li id="cp-let-subfrag-extract">
%下位-断片 ~LET %下位-範囲o の`中身を抽出-$rgした結果
◎
Let subfragment be the result of extracting subrange.
</li>
			<li id="cp-append-subfrag">
%clone に`~nodeを付加する$( %下位-断片 )
◎
Append subfragment to clone.
</li>
		</ol>
	</li>
	<li>
%包含されている子~群 を成す
~EACH( %包含されている子 )
に対し
⇒
%断片 に`~nodeを付加する$( %包含されている子 )
◎
For each contained child in contained children, append contained child to fragment.
</li>
	<li>
<p id="cp-if-last-pcc">
~IF［
%部分的に包含されている最後の子 は`文字~data~node$である
］：
◎
If last partially contained child is a CharacterData node, then:
</p>

<p class="note" id="cp-if-last-pcc-note">注記：
この事例では， %部分的に包含されている最後の子 は %元の始端~node である。
◎
In this case, last partially contained child is original end node.
</p>
		<ol>
			<li id="cp-let-clone-end">
%clone ~LET `~nodeを~cloneする$( %元の終端~node )
◎
Let clone be a clone of original end node.
</li>
			<li id="cp-set-clone-data-3">
%clone の`~data$ ~SET
%元の終端~node の`~dataの部分文字列$( 0, %元の終端~offset )
◎
Set the data of clone to the result of substringing data with node original end node, offset 0, and count original end offset.
</li>
			<!--cp-append-clone-->
			<li>
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
Replace data with node original end node, offset 0, count original end offset, and data the empty string.
</li>
		</ol>
	</li>
	<li>
<p id="cp-elif-pcc-not-null">
~ELIF［
%部分的に包含されている最後の子 ~NEQ ~NULL
］：
◎
Otherwise, if last partially contained child is not null:
</p>
		<ol>
			<li id="cp-let-clone-last-pcc">
%clone ~LET `~nodeを~cloneする$( %部分的に包含されている最後の子 )
◎
Let clone be a clone of last partially contained child.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange2">
%下位-範囲o ~LET 次のように設定された新たな`~live範囲o$
⇒＃
`始端$ ~SET `境界点$( %部分的に包含されている最後の子, 0 ),
`終端$ ~SET `境界点$( %元の終端~node, %元の終端~offset )
◎
Let subrange be a new live range whose start is (last partially contained child, 0) and whose end is (original end node, original end offset).
</li>
			<!--cp-let-subfrag-extract-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li>
%範囲o の
⇒＃
`始端$ ~SET `境界点$( %新-~node, %新-~offset )；
`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set range’s start and end to (new node, new offset).
</li>
	<!--cp-ret-flag-->
</ol>
</div>

<div class="algo">
@extractContents()
~method~手続きは
⇒
~RET コレの`中身を抽出-$rgした結果
◎
The extractContents() method steps are to return the result of extracting this.
</div>

<div class="algo">
<p>
`~live範囲o$ %範囲o の`中身を~clone@rg
するときは、次を走らす：
◎
To clone the contents of a live range range, run these steps:
</p>
<ol>
	<!--cp-new-frag-->
	<!--cp-ret-frag-if-->
	<!--cp-let-bp-vars-->
	<li>
		<!--cp-if-s-is-e-and-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-1-->
			<!--cp-append-clone-->
			<!--cp-ret-flag-->
		</ol>
	</li>
	<!--cp-let-common-anc-->
	<!--cp-let-1st-pcc-null-->
	<!--cp-set-1st-pcc-if-->
	<!--cp-let-last-pcc-null-->
	<!--cp-set-last-pcc-if-->
	<!--cp-let-contained-->
	<!--cp-throw-if-a-doctype-->
	<li>
		<!--cp-if-1st-pcc-is-cdata-->
		<!--cp-if-1st-pcc-is-cdata-note-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-2-->
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-elseif-1st-pcc-not-null-->
		<ol>
			<!--cp-let-clone-1st-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange1-->
			<li id="cp-let-subfrag-clone">
%下位-断片 ~LET %下位-範囲o の`中身を~clone$rgした結果
◎
Let subfragment be the result of cloning the contents of subrange.
</li>
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li>
<p>
%包含されている子~群 を成す
~EACH( %包含されている子 )
に対し：
◎
For each contained child in contained children:
</p>
		<ol>
			<li>
%clone ~LET `~nodeを~cloneする$( %包含されている子, ε, `子も~cloneする^i )
◎
Let clone be a clone of contained child with the clone children flag set.
</li>
			<!--cp-append-clone-->

		</ol>
	</li>
	<li>
		<!--cp-if-last-pcc-->
		<!--cp-if-last-pcc-note-->
		<ol>
			<!--cp-let-clone-end-->
			<!--cp-set-clone-data-3-->
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-elif-pcc-not-null-->
		<ol>
			<!--cp-let-clone-last-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange2-->
			<!--cp-let-subfrag-clone-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<!--cp-ret-flag-->
</ol>
</div>

<div class="algo">
@cloneContents()
~method~手続きは
⇒
~RET コレの`中身を~clone$rgした結果
◎
The cloneContents() method steps are to return the result of cloning the contents of this.
</div>

<div class="algo">
<p>
`~node$ %node を`~live範囲o$ %範囲o の
`中身に挿入-@rg
するときは，次を走らす：
◎
To insert a node node into a live range range, run these steps:
</p>

<p class="trans-note">【
`始端$の直後に %node を挿入する。
それに伴い、終端は，末尾側からの相対位置が変化しないように適宜ずらされる（すなわち、挿入-後の 始端／終端 の，先頭／末尾 からの相対位置は不変）。
始端が`文字~data~node$の内部を指している場合、その~nodeは始端の所で 2 つに分割される。
】</p>
<ol>
	<li>
( %始端~node, %始端~offset ) ~LET %範囲o の ( `始端~node$, `始端~offset$ )
◎
↓</li>
	<li>
<p>
~IF［
%始端~node は次のいずれかを満たす
］
⇒
~THROW `HierarchyRequestError$E
：
</p>

<ul ><li>$ProcessingInstruction ~nodeである
</li><li>$Comment ~nodeである
</li><li>［
$Text `~node$である
］~AND［
`親$ ~EQ ~NULL
］
</li><li>%始端~node ~EQ %node
</li></ul>

◎
If range’s start node is a ProcessingInstruction or Comment node, is a Text node whose parent is null, or is node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
%基準~node ~LET ~NULL
◎
Let referenceNode be null.
</li>
	<li>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET %始端~node
◎
If range’s start node is a Text node, set referenceNode to that Text node.
</li>
	<li>
~ELIF［
%始端~node の`子$に［
`~index$ ~EQ %始端~offset
］なるものが在る
］
⇒
%基準~node ~SET それ
◎
Otherwise, set referenceNode to the child of start node whose index is start offset, and null if there is no such child.
</li>
	<li>
%親 ~LET ［
%基準~node ~NEQ ~NULL ならば その`親$ ／
~ELSE_ %始端~node
］
◎
Let parent be range’s start node if referenceNode is null, and referenceNode’s parent otherwise.
</li>
	<li>
%node を %親 の中で %基準~node の前に`挿入できるかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET `~Text~nodeを分割する$( %始端~node, %始端~offset )
</p>
<p class="trans-note">【
%始端~offset が 0 でも分割されることになる。
】</p>
◎
If range’s start node is a Text node, set referenceNode to the result of splitting it with offset range’s start offset.
</li>
	<li>
~IF［
%node ~EQ %基準~node
］
⇒
%基準~node ~SET %node の`次-同胞？$
◎
If node is referenceNode, set referenceNode to its next sibling.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
`~nodeを除去する$( %node )
◎
If node’s parent is non-null, then remove node.
</li>
	<li>
%新-~offset ~LET ［
%基準~node ~NEQ ~NULL ならば その`~index$ ／
~ELSE_ %親 の`長さ$
］
◎
Let newOffset be parent’s length if referenceNode is null, and referenceNode’s index otherwise.
</li>
	<li>
%新-~offset ~INCBY ［
%node は`文書片$であるならば その`長さ$ ／
~ELSE_ 1
］
◎
Increase newOffset by node’s length if node is a DocumentFragment node, and one otherwise.
</li>
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %基準~node )
◎
Pre-insert node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%範囲o は`畳まれて$いる
］
⇒
%範囲o の`終端$ ~SET `境界点$( %親, %新-~offset )
</p>

<p class="trans-note">【
畳まれていない場合の終端の位置は，`~nodeを子の前に前挿入する$（手続きの中で`~nodeを子の前に挿入する$）段階で適宜ずらされる。
】</p>

◎
If range is collapsed, then set range’s end to (parent, newOffset).
</li>
</ol>
</div>

<div class="algo">
@insertNode(node)
~method~手続きは
⇒
%node をコレの`中身に挿入-$rgする
◎
The insertNode(node) method steps are to insert node into this.
</div>

<div class="algo">
<p>
@surroundContents(newParent)
~method~手続きは：
◎
The surroundContents(newParent) method steps are:
</p>
<ol>
	<li>
~IF［
ある非 $Text `~node$がコレに`部分的に包含され$ている
］
⇒
~THROW `InvalidStateError$E
◎
If a non-Text node is partially contained in this, then throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
%newParent は
$Document, $DocumentType, $DocumentFragment `~node$
のいずれかである
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If newParent is a Document, DocumentType, or DocumentFragment node, then throw an "InvalidNodeTypeError" DOMException.
</p>

<p class="note">注記：
歴史的な理由から、`文字~data~node$に対しては、この段では検査されず，後の段にて副作用とともに例外が投出される結果になる。
◎
For historical reasons CharacterData nodes are not checked here and end up throwing later on as a side effect.
</p>
	</li>
	<li>
%断片 ~LET コレの`中身を抽出-$rgした結果
◎
Let fragment be the result of extracting this.
</li>
	<li>
~IF［
%newParent は`子$を持つ
］
⇒
%newParent の`全~内容を~nodeで置換する$( ~NULL )
◎
If newParent has children, then replace all with null within newParent.
</li>
	<li>
%newParent をコレの`中身に挿入-$rgする
◎
Insert newParent into this.
</li>
	<li>
%newParent に`~nodeを付加する$( %断片 )
◎
Append fragment to newParent.
</li>
	<li>
%newParent を，コレの`中身として選択-$rgする
◎
Select newParent within this.
</li>
</ol>
</div>

<div class="algo">
@cloneRange()
~method~手続きは
⇒
~RET 次のように設定された新たな`~live範囲o$
⇒＃
`始端$ ~SET コレの`始端$の複製,<!--  -->
`終端$ ~SET コレの`終端$の複製
◎
The cloneRange() method steps are to return a new live range with the same start and end as this.
</div>

<div class="algo">
<p>
@detach()
~method~手続きは、何もしない。
◎
The detach() method steps are to do nothing.＼
</p>

<p class="note">注記：
この機能性（ ^Range ~objを不能化する）は、除去された。
互換性のため存続はするが。
◎
Its functionality (disabling a Range object) was removed, but the method itself is preserved for compatibility.
</p>
</div>

<dl class="domintro">
<!-- 
	<dt>range . cloneRange()†</dt>

	<dt>range . detach()†</dt>
-->

	<dt>%position = %range . $isPointInRange(node, offset)</dt>
	<dd>
`境界点$( %node, %offset ) が %range 内に入る†かどうかを返す。
</dd>

	<dt>%position = %range . $comparePoint(node, offset)</dt>
	<dd>
`境界点$( %node, %offset ) が
%range より前に位置する場合は ~MINUS 1 を,
%range 内に入る†場合は 0 を,
%range より後に位置する場合は 1 を
返す。【！＊】
◎
Returns −1 if the point is before the range, 0 if the point is in the range, and 1 if the point is after the range.
</dd>

	<dd class="trans-note">【†
境界点が %range のいずれかの境界点に一致する場合も，“入る” と見なされる。
】</dd>

	<dt>%intersects = %range . $intersectsNode(node)</dt>
	<dd>
%range が %node と交わるかどうかを返す。
◎
Returns whether range intersects node.
</dd>

	<dd class="trans-note">
<p>【
%node が %range に隣接している場合（ %range の終端（始端）が %node の <em>外縁の</em> 始端（終端）を指す境界点に一致する場合）は、“交わらない”。
例えば下図で `s^mk, `e^mk が %range の境界点を表すとするとき，図の~COLOR_Yが表す %node は交わらない。
】</p>

`[|[y|(|.|)|]|s[|(|.|.|)|e[y|(|.|.|)|]|]|]^bpex

<p>【
一般に、 %node は %範囲o に
(1) `包含され$ているとき, または
(2) %範囲o の始端~node／終端~nodeいずれかの`広義-先祖$であるとき、
“交わる”。
】</p>
	</dd>

	<dt>$stringifier</dt>
	<dd>
範囲oを文字列~化した結果は、範囲oにより “選択-” されているすべての~textになる。
</dd>
</dl>

<p class="trans-note">【
上のブロックに挙げた ^isPointInRange(), ^stringifier は、原文には存在しない，この訳による補完。
】</p>

<div class="algo">
<p>
@isPointInRange(node, offset)
~method~手続きは：
◎
The isPointInRange(node, offset) method steps are:
</p>
<ol>
	<li id="cp-ret-F-if-root">
~IF［
%node の`根$ ~NEQ コレの`根$rg
］
⇒
~RET ~F
◎
If node’s root is different from this’s root, return false.
</li>
	<!--cp-throw-if-doctype-->
	<!--cp-throw-if-length-->
	<li>
~IF［
`境界点$( %node, %offset ) は［［
コレの`始端$`より前$i
］~OR［
コレの`終端$`より後$i
］］］
⇒
~RET ~F
◎
If (node, offset) is before start or after end, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
@comparePoint(node, offset)
~method~手続きは：
◎
The comparePoint(node, offset) method steps are:
</p>
<ol>
	<li>
~IF［
%node の`根$ ~NEQ コレの`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If node’s root is different from this’s root, then throw a "WrongDocumentError" DOMException.
</li>
	<!--cp-throw-if-doctype-->
	<!--cp-throw-if-length-->
	<li>
~IF［
`境界点$( %node, %offset ) は
コレの`始端$`より前$i
］
⇒
~RET ~MINUS 1
◎
If (node, offset) is before start, return −1.
</li>
	<li>
~IF［
`境界点$( %node, %offset ) は
コレの`終端$`より後$i
］
⇒
~RET 1
◎
If (node, offset) is after end, return 1.
</li>
	<li>
~RET 0
◎
Return 0.
</li>
</ol>
</div>

<div class="algo">
<p>
@intersectsNode(node)
~method~手続きは：
◎
The intersectsNode(node) method steps are:
</p>
<ol>
	<!--cp-ret-F-if-root-->
	<!--cp-let-parent-->
	<li>
~IF［
%親 ~EQ ~NULL
【！すなわち node は根】
］
⇒
~RET ~T
◎
If parent is null, return true.
</li>
	<li>
%offset ~LET %node の`~index$
◎
Let offset be node’s index.
</li>
	<li>
~IF［
`境界点$( %親, %offset ) は コレの`終端$`より前$i
］~AND［
`境界点$( %親, %offset ~PLUS 1 ) は コレの`始端$`より後$i
【！selectNode の結果】
］
⇒
~RET ~T
◎
If (parent, offset) is before end and (parent, offset plus 1) is after start, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
@stringifier
における`文字列~化の挙動$は：
◎
The stringification behavior must run these steps:
</p>
<ol>
	<li>
%s ~LET 空~文字列
◎
Let s be the empty string.
</li>
	<li>
( %始端~node, %始端~offset, %終端~node, %終端~offset ) ~LET コレの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
↓</li>
	<li>
<p>
~IF［
%始端~node は $Text `~node$である
］：
</p>
		<ol>
			<li>
~IF［
%始端~node ~EQ %終端~node
］
⇒
~RET %始端~node の`~data$内の［
%始端~offset から %終端~offset まで
］を成す部分文字列
</li>
			<li>
%s に次を付加する
⇒
%始端~node の`~data$内の［
%始端~offset から末尾まで
］を成す部分文字列
</li>
		</ol>

◎
If this’s start node is this’s end node and it is a Text node, then return the substring of that Text node’s data beginning at this’s start offset and ending at this’s end offset.
◎
If this’s start node is a Text node, then append the substring of that node’s data from this’s start offset until the end to s.
</li>
	<li>
%s に次を`連結-$した結果を付加する
⇒
`~tree順序$による，コレに`包含され$ているすべての $Text `~node$の`~data$
◎
Append the concatenation of the data of all Text nodes that are contained in this, in tree order, to s.
</li>
	<li>
~IF［
%終端~node は $Text `~node$である
］
⇒
%s に次を付加する
⇒
%終端~node の`~data$内の［
先頭から %終端~offset まで
］を成す部分文字列
◎
If this’s end node is a Text node, then append the substring of that node’s data from its start until this’s end offset to s.
</li>
	<li>
~RET %s
◎
Return s.
</li>
</ol>
</div>

<hr>

<p class="note">注記：
^Range ~interfaceに対する拡張として、他の仕様にて
`createContextualFragment()$m,
`getClientRects()$m,
`getBoundingClientRect()$m
~methodが定義されている。
`DOM-Parsing$r
`CSSOM-VIEW$r
◎
The createContextualFragment(), getClientRects(), and getBoundingClientRect() methods are defined in other specifications. [DOM-Parsing] [CSSOM-VIEW]
</p>

		</section>
	</section>
	<section id="traversal">
<h2 title="Traversal">6. 走査</h2>

<p>
［
$NodeIterator ／ $TreeWalker
］~objを利用すれば、`~node$`~tree$を~filterにかけながら走査できる。
◎
NodeIterator and TreeWalker objects can be used to filter and traverse node trees.
</p>

<div class="p">
<p>
各［
$NodeIterator ／ $TreeWalker
］~objには、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`作動中か@tV</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
再入的な呼出nを避けるためにある。
</dd>

	<dt>`根@tV</dt>
	<dd>
走査-対象にされる下位treeの根を与える，`~node$。
</dd>

	<dt>`~whatToShow@tV</dt>
	<dd>
どの型（ $Node.nodeType ）の~nodeを走査するかを指示する，整数~bitmask。
1 にされた~bitに対応する型の~nodeのみが~filterを “通過する” 。
</dd>

	<dt>`~filter~callback@tV</dt>
	<dd>
対象を更に “濾過する” ~~条件を与える~callback,
または ~NULL （濾過されない）。
</dd>
</dl>

<p class="trans-note">【
［
作動中か／値~型
］以外の各項目の~~説明は、訳者による補足。
】</p>

◎
Each NodeIterator and TreeWalker object has an associated active flag to avoid recursive invocations. It is initially unset.
◎
Each NodeIterator and TreeWalker object also has an associated root (a node), a whatToShow (a bitmask), and a filter (a callback).
</div>

<div class="algo">
<p>
`走査器の中で~nodeを~filterにかける@
ときは、所与の
(［
$NodeIterator ／ $TreeWalker
］~obj %走査器, `~node$ %node )
に対し，次を走らす：
◎
To filter a node node within a NodeIterator or TreeWalker object traverser, run these steps:
</p>
<ol>
	<li>
~IF［
%走査器 の`作動中か$tV ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If traverser’s active flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%n ~LET %node の $Node.nodeType 属性~値 ~MINUS 1
◎
Let n be node’s nodeType attribute value − 1.
</li>
	<li>
~IF［
%走査器 の`~whatToShow$tV の %n 番の~bit（ 0 番が最下位~bitとする） ~EQ 0
【！ !((1 &lt;&lt; (node.nodeType - 1)) &amp; whatToShow) 】
］
⇒
~RET $NodeFilter.FILTER_SKIP
◎
If the nth bit (where 0 is the least significant bit) of traverser’s whatToShow is not set, then return FILTER_SKIP.
</li>
	<li>
~IF［
%走査器 の`~filter~callback$tV ~EQ ~NULL
］
⇒
~RET $NodeFilter.FILTER_ACCEPT
◎
If traverser’s filter is null, then return FILTER_ACCEPT.
</li>
	<li>
%走査器 の`作動中か$tV ~SET ~T
◎
Set traverser’s active flag.
</li>
	<li>
<p>
%結果 ~LET 次を与える下で，`利用元~objの演算を~callする$
⇒＃
%走査器 の`~filter~callback$tV,
`acceptNode^l,
« %node »
</p>

<p>
~callした結果，例外が投出されたときは、~catchして
⇒＃
%走査器 の`作動中か$tV ~SET ~F；
~THROW その例外
</p>

◎
Let result be the return value of call a user object’s operation with traverser’s filter, "acceptNode", and « node ». If this throws an exception, then unset traverser’s active flag and rethrow the exception.
</li>
	<li>
%走査器 の`作動中か$tV ~SET ~F
◎
Unset traverser’s active flag.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

		<section id="interface-nodeiterator">
<h3 title="Interface NodeIterator">6.1. ^@NodeIterator ~interface</h3>

！！
[`Exposed$=Window]
interface @NodeIterator {
  [`SameObject$] ~RA $Node $root;
  ~RA $Node $referenceNode;
  ~RA $boolean $pointerBeforeReferenceNode;
  ~RA `unsigned long$ $whatToShow;
  ~RA $NodeFilter? $filter;

  $Node? $nextNode();
  $Node? $previousNode();

  $undefined $detach();
};
！

<p class="note">注記：
$NodeIterator ~objは、
$Document ~obj上の $Document.createNodeIterator() ~methodを利用して作成できる。
◎
NodeIterator objects can be created using the createNodeIterator() method on Document objects.
</p>

<div class="p">
<p>
各 $NodeIterator ~objには、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`反復子~collection@</dt>
	<dd>
次のように設定された`~collection$
⇒＃
`根$cL ~SET ~objの`根$tV,
`~filter$cLは どの`~node$にも合致する
</dd>

	<dt>`起点@tV</dt>
	<dd>
`~node$。
</dd>

	<dt>`起点の直前か@tV</dt>
	<dd>
真偽値。
</dd>
	<dd class="trans-note">【
概念的には，これと`起点$tVの組により、［
`反復子で走査する$ときに どの~nodeから探索し始めるか
］を指す，~pointerが表現される。
`起点$tV （初期~時には先頭の~nodeである`根$tVにされる）が “現在の” ~nodeを表し、`起点の直前か$tV （初期~時には ~T にされる）に応じて、~pointerは，現在の~nodeの “直前” （ ~T ）か “直後” （ ~F ）を指す（したがって、初期~時の~pointerは`根$tVの直前を指す）。
】</dd>
</dl>

◎
Each NodeIterator object has an associated iterator collection, which is a collection rooted at the NodeIterator object’s root, whose filter matches any node.
◎
Each NodeIterator object also has an associated reference (a node) and pointer before reference (a boolean).
</div>

<p>
</p>

<p class="note">注記：
前に言及したように、 $NodeIterator ~objには［
`作動中か$tV,
`根$tV,
`~whatToShow$tV,
`~filter~callback$tV
］も結付けられる。
◎
As mentioned earlier, NodeIterator objects have an associated active flag, root, whatToShow, and filter as well.
</p>

<div class="algo">
<p>
`前除去-時の手続き@
は、所与の
( $NodeIterator %反復子, `~node$ %除去される~node )
に対し，次に従う：
◎
The NodeIterator pre-removing steps given a nodeIterator and toBeRemovedNode, are as follows:
</p>
<ol>
	<li>
~IF［
%除去される~node は %反復子 の`起点$tVの`広義-先祖$でない
］~OR［
%除去される~node ~EQ %反復子 の`根$tV
］
⇒
~RET
◎
If toBeRemovedNode is not an inclusive ancestor of nodeIterator’s reference, or toBeRemovedNode is nodeIterator’s root, then return.
</li>
	<li>
<p>
~IF［
%反復子 の`起点の直前か$tV ~EQ ~T
］：
◎
If nodeIterator’s pointer before reference is true, then:
</p>
		<ol>
			<li>
<p>
%次- ~LET 次をすべて満たす`~node$のうち，`最初のもの？$：
</p>

<ul><li>%除去される~node に`後続-$する
</li><li>%反復子 の`根$tVの`広義-子孫$である
</li><li>%除去される~node の`広義-子孫$でない
</li></ul>

◎
Let next be toBeRemovedNode’s first following node that is an inclusive descendant of nodeIterator’s root and is not an inclusive descendant of toBeRemovedNode, and null if there is no such node.
</li>
			<li>
~IF［
%次- ~NEQ ~NULL
］
⇒＃
%反復子 の`起点$tV ~SET %次-；
~RET
◎
If next is non-null, then set nodeIterator’s reference to next and return.
</li>
			<li>
%反復子 の`起点の直前か$tV ~SET ~F
◎
Otherwise, set nodeIterator’s pointer before reference to false.
◎
Steps are not terminated here.
</li>
		</ol>
	</li>
	<li>
%前-同胞 ~LET %除去される~node の`前-同胞？$
◎
↓</li>
	<li>
%反復子 の`起点$tV ~SET %前-同胞 に応じて
⇒＃
~NULL ならば %除去される~node の`親$ ／
~ELSE_ %前-同胞 の`広義-子孫$のうち `最後のもの？$
◎
Set nodeIterator’s reference to toBeRemovedNode’s parent, if toBeRemovedNode’s previous sibling is null, and to the inclusive descendant of toBeRemovedNode’s previous sibling that appears last in tree order otherwise.
</li>
</ol>
</div>

<hr>

<div class="algo">
@root
取得子~手続きは
⇒
~RET コレの`根$tV
◎
The root getter steps are to return this’s root.
</div>

<div class="algo">
@referenceNode
取得子~手続きは
⇒
~RET コレの`起点$tV
◎
The referenceNode getter steps are to return this’s reference.
</div>

<div class="algo">
@pointerBeforeReferenceNode
取得子~手続きは
⇒
~RET コレの`起点の直前か$tV
◎
The pointerBeforeReferenceNode getter steps are to return this’s pointer before reference.
</div>

<div class="algo">
@whatToShow
取得子~手続きは
⇒
~RET コレの`~whatToShow$tV
◎
The whatToShow getter steps are to return this’s whatToShow.
</div>

<div class="algo">
@filter
取得子~手続きは
⇒
~RET コレの`~filter~callback$tV
◎
The filter getter steps are to return this’s filter.
</div>

<div class="algo">
<p>
`反復子で走査する@
ときは、所与の
( $NodeIterator ~obj %反復子, %方向 ~IN { `順^i, `逆^i } )
に対し，次を走らす：
◎
To traverse, given a NodeIterator object iterator and a direction direction, run these steps:
</p>
<ol>
	<li>
%node ~LET %反復子 の`起点$tV
◎
Let node be iterator’s reference.
</li>
	<li>
%直前か ~LET %反復子 の`起点の直前か$tV
◎
Let beforeNode be iterator’s pointer before reference.
</li>
	<li>
%collection ~LET %反復子 の`反復子~collection$
◎
↓</li>
	<li>
<p id="cp-repeat">
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
~IF［
%方向 ~EQ `順^i
］：
◎
Branch on direction:
◎
next
</p>
				<ol>
					<li>
<p>
~IF［
%直前か ~EQ ~F
］：
◎
If beforeNode is false, then＼
</p>
						<ol>
							<li>
%node ~SET %collection の中で %node に`後続-$する`~node$のうち，`最初のもの？$
◎
set node to the first node following node in iterator’s iterator collection.＼
</li>
							<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%直前か ~SET ~F
◎
If beforeNode is true, then set it to false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %方向 ~EQ `逆^i ）：
◎
previous
</p>
				<ol>
					<li>
<p>
~IF［
%直前か ~EQ ~T
］：
◎
If beforeNode is true, then＼
</p>
						<ol>
							<li>
%node ~SET %collection の中で %node に`先行-$する`~node$のうち，`最後のもの？$
◎
set node to the first node preceding node in iterator’s iterator collection.＼
</li>
							<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%直前か ~SET ~T
◎
If beforeNode is false, then set it to true.
</li>
				</ol>
			</li>
			<li>
~IF［
`走査器の中で~nodeを~filterにかける$( %反復子, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~BREAK
◎
Let result be the result of filtering node within iterator.
◎
If result is FILTER_ACCEPT, then break.
</li>
		</ol>
	</li>
	<li>
%反復子 の`起点$tV ~SET %node
◎
Set iterator’s reference to node.
</li>
	<li>
%反復子 の`起点の直前か$tV ~SET %直前か
◎
Set iterator’s pointer before reference to beforeNode.
</li>
	<li>
~RET %node
◎
Return node.
</li>
</ol>

<p class="trans-note">【
走査の方向が前回と逆向きに切り替わった場合、探索処理は，前回の走査による
“現在の” ~node（ `起点$tV ）から開始されることに注意（その次-／前-~nodeからではなく）。
探索した結果，`~filter$cLに合致する~nodeが見出されなかった場合、`起点$tVは変更されない。
見出された場合、
`起点$tV は，新たに見出された~nodeにされ，
`起点の直前か$tV （ “現在の” 走査-方向）は，渡された %方向 を反映するようにされる（ ~F が `順^i 方向に対応する）。
】</p>
</div>

<div class="algo">
@nextNode()
~method~手続きは
⇒
~RET `反復子で走査する$( コレ, `順^i )
◎
The nextNode() method steps are to return the result of traversing with this and next.
</div>

<div class="algo">
@previousNode()
~method~手続きは
⇒
~RET `反復子で走査する$( コレ, `逆^i )
◎
The previousNode() method steps are to return the result of traversing with this and previous.
</div>

<div class="algo">
<p>
@detach()
~method~手続きは、何もしない。
◎
The detach() method steps are to do nothing.＼
</p>

<p class="note">注記：
この機能性（ ^NodeIterator ~objを不能化する）は、除去された。
互換性のため存続はするが。
◎
Its functionality (disabling a NodeIterator object) was removed, but the method itself is preserved for compatibility.
</p>
</div>

		</section>
		<section id="interface-treewalker">
<h3 title="Interface TreeWalker">6.2. ^@TreeWalker ~interface</h3>

！！
[`Exposed$=Window]
interface @TreeWalker {
  [`SameObject$] ~RA $Node $root;
  ~RA `unsigned long$ $whatToShow;
  ~RA $NodeFilter? $filter;
           attribute $Node $currentNode;

  $Node? $parentNode();
  $Node? $firstChild();
  $Node? $lastChild();
  $Node? $previousSibling();
  $Node? $nextSibling();
  $Node? $previousNode();
  $Node? $nextNode();
};
！

<p class="note">注記：
$TreeWalker ~objは、
$Document ~obj上の $Document.createTreeWalker() ~methodを利用して作成できる。
◎
TreeWalker objects can be created using the createTreeWalker() method on Document objects.
</p>

<p>
各 $TreeWalker ~objには、
`現-~node@tV
（ `~node$ ）が結付けられる。
◎
Each TreeWalker object has an associated current (a node).
</p>

<p class="note">注記：
前に言及したように、 $TreeWalker ~objには［
`根$tV,
`~whatToShow$tV,
`~filter~callback$tV
］も結付けられる。
◎
As mentioned earlier TreeWalker objects have an associated root, whatToShow, and filter as well.
</p>

<div class="algo">
@root
取得子~手続きは
⇒
~RET コレの`根$tV
◎
The root getter steps are to return this’s root.
</div>

<div class="algo">
@whatToShow
取得子~手続きは
⇒
~RET コレの `~whatToShow$tV
◎
The whatToShow getter steps are to return this’s whatToShow.
</div>

<div class="algo">
@filter
取得子~手続きは
⇒
~RET コレの`~filter~callback$tV
◎
The filter getter steps are to return this’s filter.
</div>

<div class="algo">
@currentNode
取得子~手続きは
⇒
~RET コレの`現-~node$tV
◎
The currentNode getter steps are to return this’s current.
</div>

<div class="algo">
$currentNode 設定子~手続きは：
⇒
コレの`現-~node$tV ~SET 所与の値
◎
The currentNode setter steps are to set this’s current to the given value.
</div>

<hr>

<div class="algo">
<p>
@parentNode()
~method~手続きは：
◎
The parentNode() method steps are:
</p>
<ol>
	<li id="cp-let-current">
%node ~LET コレの`現-~node$tV
◎
Let node be this’s current.
</li>
	<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］~AND［
%node ~NEQ コレの`根$tV
］：
◎
While node is non-null and is not this’s root:
</p>
		<ol>
			<li>
%node ~SET %node の`親$
◎
Set node to node’s parent.
</li>
			<li>
~IF［
%node ~NEQ ~NULL
］~AND［
`走査器の中で~nodeを~filterにかける$( コレ, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
コレの`現-~node$tV ~SET %node；
~RET %node
◎
If node is non-null and filtering node within this returns FILTER_ACCEPT, then set this’s current to node and return node.
</li>
		</ol>
	</li>
	<li id="cp-TW-ret-null">
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`子~群を走査する@
ときは、所与の
( %walker, %向き ~IN { `最初から^i, `最後から^i } )
に対し，次を走らす：
◎
To traverse children, given a walker and type, run these steps:
</p>
<!-- 走査順序（最初からの場合）
N →
	(SKIP && N.firstChild) || 
	N0.nextSibling || N1.nextSibling || N2.nextSibling || ...
		// Nn = N(n-1).parentNode, N0 = N
-->
<ol>
	<li id="cp-let-current-tw">
%node ~LET %walker の`現-~node$tV
◎
Let node be walker’s current.
</li>
	<li>
%node ~SET %向き に応じて
⇒＃
`最初から^i ならば %node の`最初の子？$ ／
`最後から^i ならば %node の`最後の子？$
◎
Set node to node’s first child if type is first, and node’s last child if type is last.
</li>
	<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］：
◎
While node is non-null:
</p>
		<ol>
			<li id="cp-let-filter-result">
%結果 ~LET
`走査器の中で~nodeを~filterにかける$( %walker, %node )
◎
Let result be the result of filtering node within walker.
</li>
			<li id="cp-set-current-if-accept-tw">
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
%walker の`現-~node$tV ~SET %node；
~RET %node
◎
If result is FILTER_ACCEPT, then set walker’s current to node and return node.
</li>
			<li>
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_SKIP
］：
◎
If result is FILTER_SKIP, then:
</p>
				<ol>
					<li>
%子 ~LET %向き に応じて
⇒＃
`最初から^i ならば %node の`最初の子？$ ／
`最後から^i ならば %node の`最後の子？$
◎
Let child be node’s first child if type is first, and node’s last child if type is last.
</li>
					<li>
~IF［
%子 ~NEQ ~NULL
］
⇒＃
%node ~SET %子；
~CONTINUE
◎
If child is non-null, then set node to child and continue.
</li>
				</ol>
			</li>
			<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］：
◎
While node is non-null:
</p>
				<ol>
					<li>
%同胞 ~LET %向き に応じて
⇒＃
`最初から^i ならば %node の`次-同胞？$ ／
`最後から^i ならば %node の`前-同胞？$
◎
Let sibling be node’s next sibling if type is first, and node’s previous sibling if type is last.
</li>
					<li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒＃
%node ~SET %同胞；
~BREAK
◎
If sibling is non-null, then set node to sibling and break.
</li>
					<li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
					<li>
~IF［
%親 ~IN { ~NULL, %walker の`根$tV, %walker の`現-~node$tV }
］
⇒
~RET ~NULL
◎
If parent is null, walker’s root, or walker’s current, then return null.
</li>
					<li>
%node ~SET %親
◎
Set node to parent.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<!--cp-TW-ret-null-->
</ol>
</div>

<div class="algo">
@firstChild()
~method~手続きは
⇒
~RET `子~群を走査する$( コレ, `最初から^i )
◎
The firstChild() method steps are to traverse children with this and first.
</div>

<div class="algo">
@lastChild()
~method~手続きは
⇒
~RET `子~群を走査する$( コレ, `最後から^i )
◎
The lastChild() method steps are to traverse children with this and last.
</div>

<div class="algo">
<p>
`同胞たちを走査する@
ときは、所与の
( %walker, %向き ~IN { `順^i, `逆^i } )
に対し，次を走らす：
◎
To traverse siblings, given a walker and type, run these steps:
</p>
<ol>
	<!--cp-let-current-tw-->
	<li>
~IF［
%node ~EQ %walker の`根$tV
］
⇒
~RET ~NULL
◎
If node is root, then return null.
</li>
	<li>
<!--cp-repeat-->
		<ol>
			<li>
%同胞 ~LET %向き に応じて
⇒＃
`順^i ならば %node の`次-同胞？$ ／
`逆^i ならば %node の`前-同胞？$
◎
Let sibling be node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
			<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is non-null:
</p>
				<ol>
					<li>
%node ~SET %同胞
◎

Set node to sibling.
</li>
					<!--cp-let-filter-result-->
					<!--cp-set-current-if-accept-tw-->
					<li>
%同胞 ~SET %向き に応じて
⇒＃
`順^i ならば %node の`最初の子？$ ／
`逆^i ならば %node の`最後の子？$
◎
Set sibling to node’s first child if type is next, and node’s last child if type is previous.
</li>
					<li>
~IF［
%結果 ~EQ $NodeFilter.FILTER_REJECT
］~OR［
%同胞 ~EQ ~NULL
］
⇒
%同胞 ~SET %向き に応じて
⇒＃
`順^i ならば %node の`次-同胞？$ ／
`逆^i ならば %node の`前-同胞？$
◎
If result is FILTER_REJECT or sibling is null, then set sibling to node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
				</ol>
			</li>
			<li>
%node ~SET %node の`親$
◎
Set node to node’s parent.
</li>
			<li>
~IF［
%node ~IN { ~NULL, %walker の`根$tV }
］
⇒
~RET ~NULL
◎
If node is null or walker’s root, then return null.
</li>
			<li>
~IF［
`走査器の中で~nodeを~filterにかける$( コレ, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~RET ~NULL
◎
If the return value of filtering node within walker is FILTER_ACCEPT, then return null.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
@nextSibling()
~method~手続きは
⇒
~RET `同胞たちを走査する$( コレ, `順^i )
◎
The nextSibling() method steps are to traverse siblings with this and next.
</div>

<div class="algo">
@previousSibling()
~method~手続きは
⇒
~RET `同胞たちを走査する$( コレ, `逆^i )
◎
The previousSibling() method steps are to traverse siblings with this and previous.
</div>

<div class="algo">
<p>
@previousNode()
~method~手続きは：
◎
The previousNode() method steps are:
</p>
<ol>
	<!--cp-let-current-->
	<li>
<p>
~WHILE［
%node ~NEQ コレの`根$tV
］：
◎
While node is not this’s root:
</p>
		<ol>
			<li>
%同胞 ~LET %node の`前-同胞？$
◎
Let sibling be node’s previous sibling.
</li>
			<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is non-null:
</p>
				<ol>
					<li>
%node ~SET %同胞
◎
Set node to sibling.
</li>
					<li>
%結果 ~LET
`走査器の中で~nodeを~filterにかける$( コレ, %node )
◎
Let result be the result of filtering node within this.
</li>
					<li>
<p id="cp-while-not-REJECT-and-has-child">
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%node は`子$を持つ
］：
◎
While result is not FILTER_REJECT and node has a child:
</p>
						<ol>
							<li>
%node ~SET %node の`最後の子？$
◎
Set node to node’s last child.
</li>
							<li id="cp-set-filter-result">
%結果 ~SET
`走査器の中で~nodeを~filterにかける$( コレ, %node )
◎
Set result to the result of filtering node within this.
</li>
						</ol>
					</li>
					<li id="cp-set-current-if-accept">
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
コレの`現-~node$tV ~SET %node；
~RET %node
◎
If result is FILTER_ACCEPT, then set this’s current to node and return node.
</li>
					<li>
%同胞 ~SET %node の`前-同胞？$
◎
Set sibling to node’s previous sibling.
</li>
				</ol>
			</li>
			<li>
~IF［
%node ~EQ コレの`根$tV
］~OR［
%node の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is this’s root or node’s parent is null, then return null.
</li>
			<li>
%node ~SET %node の`親$
◎
Set node to node’s parent.
</li>
			<li>
~IF［
`走査器の中で~nodeを~filterにかける$( コレ, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
コレの`現-~node$tV ~SET %node；
~RET %node
◎
If the return value of filtering node within this is FILTER_ACCEPT, then set this’s current to node and return node.
</li>
		</ol>
	</li>
	<!--cp-TW-ret-null-->
</ol>
</div>

<div class="algo">
<p>
@nextNode()
~method~手続きは：
◎
The nextNode() method steps are:
</p>
<ol>
	<!--cp-let-current-->
	<li>
%結果 ~LET $NodeFilter.FILTER_ACCEPT
◎
Let result be FILTER_ACCEPT.
</li>
	<li>
<!--cp-repeat-->
		<ol>
			<li>
<!--cp-while-not-REJECT-and-has-child-->
				<ol>
					<li>
%node ~SET %node の`最初の子？$
◎
Set node to its first child.
</li>
					<!--cp-set-filter-result-->
					<!--cp-set-current-if-accept-->
				</ol>
			</li>
			<li>
%同胞 ~LET ~NULL
◎
Let sibling be null.
</li>
			<li>
%temporary ~LET %node
◎
Let temporary be node.
</li>
			<li>
<p>
~WHILE［
%temporary ~NEQ ~NULL
］：
◎
While temporary is non-null:
</p>
				<ol>
					<li>
~IF［
%temporary ~EQ コレの`根$tV
］
⇒
~RET ~NULL
◎
If temporary is this’s root, then return null.
</li>
					<li>
%同胞 ~SET %temporary の`次-同胞？$
◎
Set sibling to temporary’s next sibling.
</li>
					<li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒＃
%node ~SET %同胞；
~BREAK
◎
If sibling is non-null, then set node to sibling and break.
</li>
					<li>
%temporary ~SET %temporary の`親$
◎
Set temporary to temporary’s parent.
</li>
				</ol>
			</li>
			<!--cp-set-filter-result-->
			<!--cp-set-current-if-accept-->
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-nodefilter">
<h3 title="Interface NodeFilter">6.3. ^@NodeFilter ~interface</h3>

！！
[`Exposed$=Window]
callback interface @NodeFilter {
  // <span class="comment" title="Constants for acceptNode"
  ><code>$acceptNode()</code> 用の定数</span>
  const `unsigned short$ $FILTER_ACCEPT = 1;
  const `unsigned short$ $FILTER_REJECT = 2;
  const `unsigned short$ $FILTER_SKIP = 3;

  // <span class="comment" title="Constants for whatToShow bitmask"
  >`~whatToShow$tV 用の定数</span>
  const `unsigned long$ $SHOW_ALL = 0xFFFFFFFF;
  const `unsigned long$ $SHOW_ELEMENT = 0x1;
  const `unsigned long$ $SHOW_ATTRIBUTE = 0x2;
  const `unsigned long$ $SHOW_TEXT = 0x4;
  const `unsigned long$ $SHOW_CDATA_SECTION = 0x8;
  const `unsigned long$ @SHOW_ENTITY_REFERENCE = 0x10; // <!--cp-legacy-->
  const `unsigned long$ @SHOW_ENTITY = 0x20; // <!--cp-legacy-->
  const `unsigned long$ $SHOW_PROCESSING_INSTRUCTION = 0x40;
  const `unsigned long$ $SHOW_COMMENT = 0x80;
  const `unsigned long$ $SHOW_DOCUMENT = 0x100;
  const `unsigned long$ $SHOW_DOCUMENT_TYPE = 0x200;
  const `unsigned long$ $SHOW_DOCUMENT_FRAGMENT = 0x400;
  const `unsigned long$ @SHOW_NOTATION = 0x800; // <!--cp-legacy-->

  `unsigned short$ @acceptNode($Node %node);
};
！

<p class="note">注記：
$NodeFilter ~objは、［
$NodeIterator ／ $TreeWalker
］用の`~filter~callback$tVとして利用できる。
また、それら用の`~whatToShow$tVとして~bitmask定数を供する。
$NodeFilter ~objは、概して，~JS関数として実装される。
◎
NodeFilter objects can be used as filter for NodeIterator and TreeWalker objects and also provide constants for their whatToShow bitmask. A NodeFilter object is typically implemented as a JavaScript function.
</p>

<div>
<p>
`~filter~callback$tVの返り値には、次に挙げる定数を利用できる（括弧内は数-値）
【各~項目の~~説明は、訳者による補足】：
</p>
<ul>
	<li>
@FILTER_ACCEPT (1)
⇒
~nodeは~filterを “通過する”。
</li>
	<li>
@FILTER_REJECT (2)
⇒
$NodeIterator に利用されている下では、 $FILTER_SKIP と同じ結果になる。
$TreeWalker に利用されている下では、~nodeはその子孫も含めて “濾過される”。
</li>
	<li>
@FILTER_SKIP (3)
⇒
~node自身は “濾過される” が、その子孫は，依然として~filterの対象になり得る。
</li>
</ul>
◎
These constants can be used as filter return value:
• FILTER_ACCEPT (1);
• FILTER_REJECT (2);
• FILTER_SKIP (3).
</div>

<p>
`~whatToShow$tV用には、次に挙げる定数を利用できる（括弧内は数-値）：
◎
These constants can be used for whatToShow:
</p>

<ul><li>@SHOW_ALL (4294967295 ~EQ 0xFFFFFFFF)
<li>@SHOW_ELEMENT (1)
<li>@SHOW_ATTRIBUTE (2)
<li>@SHOW_TEXT (4)
<li>@SHOW_CDATA_SECTION (8)
<li>@SHOW_PROCESSING_INSTRUCTION (64 ~EQ 0x40)
<li>@SHOW_COMMENT (128 ~EQ 0x80)
<li>@SHOW_DOCUMENT (256 ~EQ 0x100)
<li>@SHOW_DOCUMENT_TYPE (512 ~EQ 0x200)
<li>@SHOW_DOCUMENT_FRAGMENT (1024 ~EQ 0x400)
</ul>

		</section>
	</section>
	<section id="sets">
<h2 title="Sets">7. ~token集合</h2>

<p class="note">
Yes, the name $DOMTokenList is an unfortunate legacy mishap.
</p>

		<section id="interface-domtokenlist">
<h3 title="Interface DOMTokenList">7.1. ^@DOMTokenList ~interface</h3>

！！
[`Exposed$=Window]
interface @DOMTokenList {
  ~RA `unsigned long$ $length;
  getter $DOMString? $item(`unsigned long$ %index);
  $boolean $contains($DOMString %token);
  [`CEReactions$] $undefined $add($DOMString... %tokens);
  [`CEReactions$] $undefined $remove($DOMString... %tokens);
  [`CEReactions$] $boolean $toggle($DOMString %token, optional $boolean %force);
  [`CEReactions$] $boolean $replace($DOMString %token, $DOMString %newToken);
  $boolean $supports($DOMString %token);
  [`CEReactions$] @stringifier attribute $DOMString $value;
  iterable&lt;$DOMString&gt;;
};
！

<div class="p">
<p>
各 $DOMTokenList には、次に挙げるものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~token集合@tL</dt>
	<dd>
一連の~tokenからなる`有順序~集合$
— 初期~時は`空$とする。
</dd>

	<dt>`要素@tL</dt>
	<dd>
`要素$。
</dd>
	<dt>`属性oの局所~名@tL</dt>
	<dd>
`属性o$の`局所~名$a。
</dd>
</dl>

◎
A DOMTokenList object has an associated token set (a set), which is initially empty.
◎
A DOMTokenList object also has an associated element and an attribute’s local name.
</div>

<p>
`適用-可能な仕様$は、個々の`局所~名$aに対し，それが
`~supportする~token集合@tL
を $DOMTokenList 用に定義してもヨイ
— これは、一連の~tokenからなる集合であり，特に指定されない限り ε （未定義）とする。
◎
Specifications may define supported tokens for a DOMTokenList's associated attribute’s local name.
</p>

<div class="algo">
<p>
$DOMTokenList ~obj %O 上で
`~tokenを検証する@
ときは、所与の
( %~token )
に対し，次を走らす：
◎
A DOMTokenList object’s validation steps for a given token are:
</p>
<ol>
	<li>
%~token集合 ~LET %O の`属性oの局所~名$tLが`~supportする~token集合$tL
◎
↓</li>
	<li>
~IF［
%~token集合 ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If the associated attribute’s local name does not define supported tokens, throw a TypeError.
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
`~ASCII小文字~化する$( %~token ) ~IN %~token集合
◎
Let lowercase token be a copy of token, in ASCII lowercase.
◎
If lowercase token is present in supported tokens, return true.
◎
Return false.
</li>
</ol>
</div>

<hr>

<p>
所与の $DOMTokenList ~obj %O 対し，
( %要素, %名前 )
は
( %O の`要素$tL, %O の`属性oの局所~名$tL )
とするとき：
◎
↓</p>

<ul>
	<li class="algo">
<p>
%O の
`更新~手続き@tL
は、次を走らす：
◎
A DOMTokenList object’s update steps are:
</p>
		<ol>
			<li>
~IF［
%要素 の`属性o~list$は`空$である
］~AND［
%O の`~token集合$tLは`空$である
］
⇒
~RET
◎
If the associated element does not have an associated attribute and token set is empty, then return.
</li>
			<li>
%要素 の`属性o値を設定する$( %名前, ［
%O の`~token集合$tLを`有順序~集合 直列化器$にかけた結果
］ )
◎
Set an attribute value for the associated element using associated attribute’s local name and the result of running the ordered set serializer for token set.
</li>
		</ol>
	</li>
	<li class="algo">
%O の
`直列化-手続き@tL
は、次の結果を返す
⇒
%要素 の`属性o値を取得する$( %名前 )
◎
A DOMTokenList object’s serialize steps are to return the result of running get an attribute value given the associated element and the associated attribute’s local name.
</li>
	<li class="algo">
<p>
%要素 上の`属性o変更-時の手続き$は、所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
A DOMTokenList object has these attribute change steps for its associated element:
</p>
		<ol>
			 <li>
<p>
~IF［
%局所~名 ~EQ %名前
］~AND［
%~ns ~EQ ~NULL
］：
</p>
				<ol>
					<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%O の`~token集合$tLを`空にする$
</li>
					 <li>
~ELSE
⇒
%O の`~token集合$tL ~SET %値 を`有順序~集合 構文解析器$にかけた結果
</li>
				</ol>
◎
If localName is associated attribute’s local name, namespace is null, and value is null, then empty token set.
◎
Otherwise, if localName is associated attribute’s local name, namespace is null, then set token set to value, parsed.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%O の作成-時には、次を走らす：
◎
When a DOMTokenList object is created, then:
</p>
		<ol>
			<li>
%値 ~LET %要素 の`属性o値を取得する$( %名前 )
◎
Let element be associated element.
◎
Let localName be associated attribute’s local name.
◎
Let value be the result of getting an attribute value given element and localName.
</li>
			<li>
次を渡して，
%要素 上の`属性o変更-時の手続き$を走らす
⇒
( %名前, %値, %値, ~NULL )
◎
Run the attribute change steps for element, localName, value, value, and null.
</li>
		</ol>
	</li>
</ul>

<dl class="domintro">
	<dt>%tokenlist . $length</dt>
	<dd>
~tokenの個数を返す。
◎
Returns the number of tokens.
</dd>

	<dt>%tokenlist . $item(index)</dt>
	<dt>%tokenlist[%index]</dt>
	<dd>
%index 番の~tokenを返す。
◎
Returns the token with index index.
</dd>

	<dt>%tokenlist . $contains(token)</dt>
	<dd>
%token が［
在れば ~T ／
無ければ ~F
］を返す。
◎
Returns true if token is present; otherwise false.
</dd>

	<dt>%tokenlist . $add(tokens…)</dt>
	<dd>
渡された引数のうち，まだ無いものを追加する。
◎
Adds all arguments passed, except those already present.
</dd>
	<dd>
<span id="cp-throw-if-some-token-is">
<a href="#_throw-if-token-is">下記に該当する場合</a>、例外が投出される。
</span>
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $remove(tokens…)</dt>
	<dd>
渡された引数のそれぞれを（もし在れば）除去する。
◎
Removes arguments passed, if they are present.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $toggle(token [, force])</dt>
	<dd>
<p>
%force に応じて：
</p>

		<ul>
			<li>
省略されているならば、
%token の有無を “切り替える”。
すなわち、 %token がすでに在れば除去し，無ければ追加する。
</li>
			<li>
~T ならば、 %token を追加する（ $add() と同じ）。
</li>
			<li>
~F ならば、 %token を除去する（ $remove() と同じ）。
</li>
		</ul>

<p>
その結果、 %token が［
残っていれば ~T ／
無くなっていれば ~F
］を返す。
</p>
◎
If force is not given, "toggles" token, removing it if it’s present and adding it if it’s not present. If force is true, adds token (same as add()). If force is false, removes token (same as remove()).
◎
Returns true if token is now present; otherwise false.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if token is empty.
◎
Throws an "InvalidCharacterError" DOMException if token contains any spaces.
</dd>

	<dt>%tokenlist . $replace(token, newToken)</dt>
	<dd>
	<dd>
%token を %newToken に置換する。
◎
Replaces token with newToken.
</dd>
	<dd>
%token が %newToken に［
置換されたなら ~T ／
置換されなかったなら ~F
］を返す。
◎
Returns true if token was replaced with newToken; otherwise false.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt id="_throw-if-token-is">（例外）</dt>
	<dd>
<p>
上の各種~methodに所与の文字列~引数のいずれかが，次に該当する場合、対応する例外が投出される：
</p>

		<ul id="cp-throw-if-token-B">
			<li>
空~文字列の場合：
`SyntaxError$E
</li>
			<li>
`~ASCII空白$を含む場合：
`InvalidCharacterError$E
</li>
		</ul>
◎
↑</dd>

	<dt>%tokenlist . $supports(token)</dt>
	<dd>
`属性oの局所~名$tLが`~supportする~token集合$tLに %token が含まれて［
いれば ~T ／ いなければ ~F
］を返す。
◎
Returns true if token is in the associated attribute’s supported tokens. Returns false otherwise.
</dd>
	<dd>
`~supportする~token集合$tLが定義されていない場合、
`TypeError$E が投出される。
◎
Throws a TypeError if the associated attribute has no supported tokens defined.
</dd>

	<dt>%tokenlist . $value</dt>
	<dd>
結付けられている`~token集合$tLを文字列として返す。
◎
Returns the associated set as string.
</dd>
	<dd>
設定して結付けられている属性を変更できる。
◎
Can be set, to change the associated attribute.
</dd>
</dl>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレの`~token集合$tLの`~size$
◎
The length attribute' getter must return this’s token set’s size.
</div>

<p>
$DOMTokenList ~obj %O が`~supportする~prop~index$は、
0 以上［
%O の`~token集合$tLの`~size$
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to object’s token set’s size minus one, unless token set is empty, in which case there are no supported property indices.
</p>

<div class="algo">
<p>
@item(index)
~method~手続きは：
◎
The item(index) method steps are:
</p>
<ol>
	<li>
~IF［
%index ~NIN { コレが`~supportする~prop~index$ }
］
⇒
~RET ~NULL
◎
If index is equal to or greater than this’s token set’s size, then return null.
</li>
	<li>
~RET コレの`~token集合$tL[ %index ]
◎
Return this’s token set[index].
</li>
</ol>
</div>

<div class="algo">
<p>
`~tokenを検査する@
ときは、所与の
( %token )
に対し，次を走らす：
</p>
<ol>
	<li>
~IF［
%token ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
</li>
	<li>
~IF［
%token は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
</li>
</ol>

◎
↓↓</div>

<div class="algo">
@contains(token)
~method~手続きは
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%token ~IN コレの`~token集合$tL
◎
The contains(token) method steps are to return true if this’s token set[token] exists; otherwise false.
</div>

<div class="algo">
<p>
@add(tokens…)
~method~手続きは：
◎
The add(tokens…) method steps are:
</p>
<ol>
	<li id="cp-throw-if-invalid-char">
%tokens を成す
~EACH( %token )
に対し，与えられた順に
⇒
`~tokenを検査する$( %token )
◎
For each token in tokens:
• If token is the empty string, then throw a "SyntaxError" DOMException.
• If token contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
%tokens を成す
~EACH( %token )
に対し
⇒
コレの`~token集合$tLに %token を`付加する$set
◎
For each token in tokens, append token to this’s token set.
</li>
	<li id="cp-update-TL">
コレの`更新~手続き$tLを走らす
◎
Run the update steps.
</li>
</ol>
【！追加が生じなかった場合にも更新~手続きは実行されることになる。】
</div>

<div class="algo">
<p>
@remove(tokens…)
~method~手続きは：
◎
The remove(tokens…) method steps are:
</p>
<ol>
	<!--cp-throw-if-invalid-char-->
	<li>
%tokens 内の各 %token に対し
⇒
コレの`~token集合$tLから %token を`除去する$
◎
For each token in tokens, remove token from this’s token set.
</li>
	<!--cp-update-TL-->
</ol>
</div>

<div class="algo">
<p>
@toggle(token, force)
~method~手続きは：
◎
The toggle(token, force) method steps are:
</p>
<ol>
	<li>
`~tokenを検査する$( %token )
◎
If token is the empty string, then throw a "SyntaxError" DOMException.
◎
If token contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
<p>
~IF［
%token ~IN コレの`~token集合$tL
］：
◎
If this’s token set[token] exists, then:
</p>
		<ol>
			<li>
<p>
~IF［
%force ~EQ ε
］~OR［
%force ~EQ ~F
］：
</p>
<ol ><li>コレの`~token集合$tLから %token を`除去する$
</li><li>コレの`更新~手続き$tLを走らす
</li><li>~RET ~F
</li></ol>
◎
If force is either not given or is false, then remove token from this’s token set, run the update steps and return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%force ~EQ ε
］~OR［
%force ~EQ ~T
］：
</p>

<ol ><li>コレの`~token集合$tLに %token を`付加する$set
</li><li>コレの`更新~手続き$tLを走らす
</li><li>~RET ~T
</li></ol>

◎
Otherwise, if force not given or is true, append token to this’s token set, run the update steps, and return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

<p class="note">注記：
~web互換性のため、 $toggle() に対しては，`更新~手続き$tLを常に走らすとは限らない。
◎
The update steps are not always run for toggle() for web compatibility.
</p>
</div>

<div class="algo">
<p>
@replace(token, newToken)
~method~手続きは：
◎
The replace(token, newToken) method steps are:
</p>
		<ol>
			<li>
~IF［
%token ~EQ 空~文字列
］~OR［
%newToken ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
◎
If either token or newToken is the empty string, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%token は`~ASCII空白$を含んでいる
］~OR［
%newToken は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
◎
If either token or newToken contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~IF［
%token ~NIN コレの`~token集合$tL
］
⇒
~RET ~F
◎
If this’s token set does not contain token, then return false.
</li>
			<li>
コレの`~token集合$tL内で %token を %newToken に`置換する$set
◎
Replace token in this’s token set with newToken.
</li>
			<!--cp-update-TL-->
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>

<p class="note">注記：
~web互換性のため、 $replace() に対しては，`更新~手続き$tLを常に走らすとは限らない。
◎
The update steps are not always run for replace() for web compatibility.
</p>

<p class="trans-note">【
最初と二番目の段は、
%token, %newToken の順に`~tokenを検査する$のとは，挙動が異なる。
】</p>
</div>

<div class="algo">
@supports(token)
~method~手続きは
⇒
~RET コレ上で`~tokenを検証する$( %token )
◎
The supports(token) method steps are:
• Let result be the return value of validation steps called with token.
• Return result.
</div>

<div class="algo">
@value
取得子~手続きは
⇒
~RET コレの`直列化-手続き$tLを走らせた結果
◎
The value attribute must return the result of running this’s serialize steps.
</div>

<div class="algo">
$value 設定子~手続きは
⇒
コレの`要素$tLの`属性o値を設定する$( コレの`属性oの局所~名$tL, 所与の値 )
◎
Setting the value attribute must set an attribute value for the associated element using associated attribute’s local name and the given value.
</div>

		</section>
	</section>
	<section id="xpath">
<h2 title="XPath">8. ~XPath</h2>

<p class="XXX">
`DOM Level 3 XPath^cite
は、
`XPath 1.0^cite
式を評価するための~APIを定義した。
これらの~APIは、広く実装されてはいるが，保守されていない。
各種~interface定義は、 `Web IDL^cite が変更されるに伴い更新できるよう，ここに保守される。
これらの~APIの完全な定義は、引き続き必要とされる
— そのような作業は
<a href="~DOMissue/67">課題 #67</a>
にて追跡され，そこに貢献できる／され得る。
`DOM-Level-3-XPath$r
`XPath$r
`WEBIDL$r
◎
DOM Level 3 XPath defined an API for evaluating XPath 1.0 expressions. These APIs are widely implemented, but have not been maintained. The interface definitions are maintained here so that they can be updated when Web IDL changes. Complete definitions of these APIs remain necessary and such work is tracked and can be contributed to in whatwg/dom#67. [DOM-Level-3-XPath] [XPath] [WEBIDL]
</p>

		<section id="interface-xpathresult">
<h3 title="Interface XPathResult">8.1. ^@XPathResult ~interface</h3>

！！
[`Exposed$=Window]
interface @XPathResult {
  const `unsigned short$ @ANY_TYPE = 0;
  const `unsigned short$ @NUMBER_TYPE = 1;
  const `unsigned short$ @STRING_TYPE = 2;
  const `unsigned short$ @BOOLEAN_TYPE = 3;
  const `unsigned short$ @UNORDERED_NODE_ITERATOR_TYPE = 4;
  const `unsigned short$ @ORDERED_NODE_ITERATOR_TYPE = 5;
  const `unsigned short$ @UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  const `unsigned short$ @ORDERED_NODE_SNAPSHOT_TYPE = 7;
  const `unsigned short$ @ANY_UNORDERED_NODE_TYPE = 8;
  const `unsigned short$ @FIRST_ORDERED_NODE_TYPE = 9;

  ~RA `unsigned short$ @resultType;
  ~RA `unrestricted double$ @numberValue;
  ~RA $DOMString @stringValue;
  ~RA $boolean @booleanValue;
  ~RA $Node? @singleNodeValue;
  ~RA $boolean @invalidIteratorState;
  ~RA `unsigned long$ @snapshotLength;

  $Node? @iterateNext();
  $Node? @snapshotItem(`unsigned long$ %index);
};
！

		</section>
		<section id="interface-xpathexpression">
<h3 title="Interface XPathExpression">8.2. ^@XPathExpression ~interface</h3>

！！
[`Exposed$=Window]
interface @XPathExpression {
  // XPathResult.ANY_TYPE = 0
  XPathResult @evaluate($Node %contextNode, optional `unsigned short$ %type = 0, optional $XPathResult? %result = null);
};
！

		</section>
		<section id="mixin-xpathevaluatorbase">
<h3 title="Mixin XPathEvaluatorBase">8.3. ^XPathEvaluatorBase ~mixin</h3>

！！
callback interface @@XPathNSResolver {
  $DOMString? @lookupNamespaceURI($DOMString? %prefix);
};

interface mixin @@XPathEvaluatorBase {
  [NewObject] @XPathExpression @createExpression($DOMString %expression, optional $XPathNSResolver? %resolver = null);
  $XPathNSResolver @createNSResolver($Node %nodeResolver);
  // XPathResult.ANY_TYPE = 0
  $XPathResult @evaluate($DOMString %expression, $Node %contextNode, optional $XPathNSResolver? %resolver = null, optional `unsigned short$ %type = 0, optional $XPathResult? %result = null);
};
$Document includes $XPathEvaluatorBase;
！

		</section>
		<section id="interface-xpathevaluator">
<h3 title="Interface XPathEvaluator">8.4. ^@XPathEvaluator ~interface</h3>

！！
[`Exposed$=Window]
interface @XPathEvaluator {
  `XPathEvaluator@mc();
};

$XPathEvaluator includes $XPathEvaluatorBase;
！

<p class="note">注記：
歴史的な理由から、
$XPathEvaluator を構築することも，
$Document 上で同じ~methodに~accessすることもできる。
◎
For historical reasons you can both construct XPathEvaluator and access the same methods on Document.
</p>

		</section>
	</section>
	<section id="xslt">
<h2 title="XSLT">9. ~XSLT</h2>

<p class="XXX">
~XSLT（ `XSL Transformations^cite ）は、~XML文書を他の~XML文書へ形式変換するための言語である。
この節にて定義される~APIは，広く実装されており、
`Web IDL^cite が変更されたとき更新できるよう，ここに保守される。
これらの~APIの完全な定義は、引き続き必要とされる
— そのような作業は
<a href="~DOMissue/181">課題 #181</a>
にて追跡され，そこに貢献できる／され得る。
`XSLT$r
◎
XSL Transformations (XSLT) is a language for transforming XML documents into other XML documents. The APIs defined in this section have been widely implemented, and are maintained here so that they can be updated when Web IDL changes. Complete definitions of these APIs remain necessary and such work is tracked and can be contributed to in whatwg/dom#181. [XSLT]
</p>

		<section id="interface-xsltprocessor">
<h3 title="Interface XSLTProcessor">9.1. ^@XSLTProcessor ~interface</h3>

！！
[`Exposed$=Window]
interface @XSLTProcessor {
  `XSLTProcessor@mc();
  $undefined @importStylesheet($Node %style);
  [`CEReactions$] $DocumentFragment @transformToFragment($Node %source, $Document %output);
  [`CEReactions$] $Document @transformToDocument($Node %source);
  $undefined @setParameter([`LegacyNullToEmptyString$] $DOMString %namespaceURI, $DOMString %localName, $any %value);
  $any @getParameter([`LegacyNullToEmptyString$] $DOMString %namespaceURI, $DOMString %localName);
  $undefined @removeParameter([`LegacyNullToEmptyString$] $DOMString %namespaceURI, $DOMString %localName);
  $undefined @clearParameters();
  $undefined @reset();
};
！

		</section>
	</section>
	<section id="historical">
<h2 title="Historical">10. 歴史的なもの</h2>

<p>
この標準が包含していた，いくつかの［
~interface／~interface~member
］は、除去された。
◎
This standard used to contain several interfaces and interface members that have been removed.
</p>

<p>
次に挙げる~interfaceは、除去された：
◎
These interfaces have been removed:
</p>

<ul>
<li>@DOMConfiguration
<li>@DOMError
<li>@DOMErrorHandler
<li>@DOMImplementationList
<li>@DOMImplementationSource
<li>@DOMLocator
<li>@DOMObject
<li>@DOMUserData
<li>@Entity
<li>@EntityReference
<li>@MutationEvent
<li>@MutationNameEvent
<li>@NameList
<li>@Notation
<li>@RangeException
<li>@TypeInfo
<li>@UserDataHandler
</ul>

<p>
次に挙げる~interface~memberは、除去された：
◎
And these interface members have been removed:
</p>

<dl>
<dt>$@Attr
	<dd>@schemaTypeInfo
	<dd>@isId

<dt>$@Document
	<dd>@createEntityReference()
	<dd>@xmlEncoding
	<dd>@xmlStandalone
	<dd>@xmlVersion
	<dd>@strictErrorChecking
	<dd>@domConfig
	<dd>@normalizeDocument()
	<dd>@renameNode()

<dt>$@DocumentType
	<dd>@entities
	<dd>@notations
	<dd>@internalSubset

<dt>$@DOMImplementation
	<dd>@getFeature()

<dt>$@Element
	<dd>@schemaTypeInfo
	<dd>@setIdAttribute()
	<dd>@setIdAttributeNS()
	<dd>@setIdAttributeNode()

<dt>$@Node
	<dd>@isSupported
	<dd>@getFeature()
	<dd>@getUserData()
	<dd>@setUserData()

<dt>$@NodeIterator
	<dd>@expandEntityReferences

<dt>$@Text
	<dd>@isElementContentWhitespace
	<dd>@replaceWholeText()

<dt>$@TreeWalker
	<dd>@expandEntityReferences
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、 DOM を相互運用可能にするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に，この標準の今日の姿は、多くの方々からの助力により作り上げられている。
◎
There have been a lot of people that have helped make DOM more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

Adam Klein,
Adrian Bateman,
Ahmid <i>snuggs</i>,
Alex Komoroske,
Alex Russell,
Alexey Shvayka,
Andreu Botella,
Anthony Ramine,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Benjamin Gruenbaum,
Björn Höhrmann,
Boris Zbarsky,
Brandon Payton,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
C. Scott Ananian,
Cameron McCormack,
Chris Dumez,
Chris Paris,
Chris Rebert,
Cyrille Tuzi,
Dan Burzo,
Daniel Clark,
Daniel Glazman,
Darin Fisher,
David Bruant,
David Flanagan,
David Håsäther,
David Hyatt,
Deepak Sherveghar,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Edgar Chen,
Elisée Maurer,
Elliott Sprehn,
Emilio Cobos Álvarez,
Eric Bidelman,
Erik Arvidsson,
Gary Kacmarcik,
Gavin Nicol,
Giorgio Liscio,
Glen Huang,
Glenn Adams,
Glenn Maynard,
Hajime Morrita,
Harald Alvestrand,
Hayato Ito,
Henri Sivonen,
Hongchan Choi,
Hunan Rostomyan,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald,
Jake Verbaten,
James Graham,
James Greene,
James M Snell,
James Robinson,
Jeffrey Yasskin,
Jens Lindström,
Jesse McCarthy,
Jinho Bang,
João Eiras,
Joe Kesselman,
John Atkins,
John Dai,
Jonas Sicking,
Jonathan Kingston,
Jonathan Robie,
Joris van der Wel,
Joshua Bell,
J. S. Choi,
Jungkee Song,
Justin Summerlin,
Kagami Sascha Rosylight,
<span lang="zh-tw">呂康豪</span> (Kang-Hao Lu),
<span lang="ja">田村健人</span> (Kent TAMURA),
Kevin J. Sung,
Kevin Sweeney,
Kirill Topolyan,
Koji Ishii,
Lachlan Hunt,
Lauren Wood,
Luca Casonato,
Luke Zielinski,
Magne Andersson,
Majid Valipour,
Malte Ubl,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Martijn van der Ven,
Mason Freed,
Mats Palmgren,
Mounir Lamouri,
Michael Stramel,
Michael™ Smith,
Mike Champion,
Mike Taylor,
Mike West,
Nicolás Peña Moreno,
Nidhi Jaju,
Ojan Vafai,
Oliver Nightingale,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Piers Wombwell,
Pierre-Marie Dartus,
prosody—Gab Vereable Context(,
Rafael Weinstein,
Rakina Zata Amni,
Richard Bradshaw,
Rick Byers,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Roland Steiner,
Rune <span title="Fabulous">F.</span> Halvorsen,
Russell Bicknell,
Ruud Steltenpool,
Ryosuke Niwa,
Sam Dutton,
Sam Sneddon,
Samuel Giles,
Sanket Joshi,
Sebastian Mayr,
Seo Sanghyeon,
Sergey G. Grekhov,
Shiki Okasaka,
Shinya Kawanaka,
Simon Pieters,
Stef Busking,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Takashi Sakamoto,
Takayoshi Kochi,
Theresa O’Connor,
Theodore Dubois,
<i>timeless</i>,
Timo Tijhof,
Tobie Langel,
Tom Pixley,
Travis Leithead,
Trevor Rowbotham,
<i>triple-underscore</i>,
Veli Şenol,
Vidur Apparao,
Warren He,
Xidorn Quan,
Yash Handa,
Yehuda Katz,
Yoav Weiss,
Yoichi Osato,
Yoshinori Sano,
Yu Han,
Yusuke Abe, and
Zack Weinberg

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>)
with substantial contributions from
Aryeh Gregor (<a href="mailto:ayg@aryeh.name">ayg@aryeh.name</a>)
and Ms2ger (<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).
</p>

</div>

<div lang="en" id="_ipr1">

<p>
Part of the revision history of the integration points related to <a href="#concept-element-custom">custom</a> elements can be found in <a href="https://github.com/w3c/webcomponents">the w3c/webcomponents repository</a>, which is available under the <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Software and Document License</a>.
</p>

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://dom.spec.whatwg.org/review-drafts/2021-06/">Living Standard Review Draft</a>.
</p>
</div>

</div>
