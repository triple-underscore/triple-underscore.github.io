<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>DOM Standard 日本語訳</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>

code > dfn {
	/* for idl */
	color: var(--K-color);
}

.bp-example {
	display: block;
	margin: 1em 0;
	padding-bottom: 2.5em;
	text-align: center;
	font-size: 0.8em;
	white-space: pre;
	overflow: auto;
	font-family: monospace0, monospace;
	color: var(--K-color);
}

bp-node {
	display: inline;
	position: relative;
	top: 6px;
	border-top: solid 3px var(--N-color);
}

.bp-text {
	border-top-color: var(--R-color);
	color: var(--R-color);
}

.bp-x {
	border-top-color: var(--G-color);
}
.bp-y {
	border-top-color: var(--B-color);
}

bp-mark {
	display: inline-block;
	top: 0;
	vertical-align: top;
}

div.trans-note {
	margin: 1em;
	border: solid thin currentcolor;
	padding: 0.5em;
}

.domTree samp {
	outline: thin solid currentcolor;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>
<script>

Util.ready = function(){
	const ifc_names = PAGE_DATA.ifc_names
	.replace(/^\w+$/mg, function(name){
		return name + ':#' + name.toLowerCase();
	});
	delete PAGE_DATA.ifc_names;

	const source_data = {
		ifc_names: Util.get_mapping(ifc_names),
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand,
		populate: populate,
	};

	{
		const bp_examples = Util.get_mapping(PAGE_DATA.bp_examples);
		for(const key in bp_examples){
			const ele = C('figure');
			ele.className = 'bp-example';
			ele.innerHTML = bp_examples[key]
			.replace(/([\|\[\]\(\)])(\w?)/g, (match, t, w) => {
				switch(t) {
				case '|':
					return w ? `<bp-mark>|\n<mark>${w}</mark></bp-mark>` : '|';
				case '(':
					return w ? `<bp-node class="bp-${w} bp-text">` : '<bp-node class="bp-text">';
				case '[':
					return w ? `<bp-node class="bp-${w}">` : '<bp-node>';
				case ')':
				case ']':
					return '</bp-node>';
				}
			});
			source_data.persisted_parts[`_dgm-${key}`] = ele;
		}
	}

	Util.switchWordsInit(source_data);

/*
	repeat('dl.idl-def > dt', function(e){
		e.replaceWith(C('p'))
	});
	Util.del_j(); //
*/
}

function populate(){
// 要素複製
	const visited = Object.create(null);
	let node, e;
	// Opera requires optional args, null, null
	const itr = document.createNodeIterator(E('MAIN'), NodeFilter.SHOW_COMMENT, null, null);
	while(node = itr.nextNode()){
		const id = node.data;
		if(id.slice(0,3) !== 'cp-') continue;
		e = visited[id];
		if(!e) {
			e = E(id);
			if(e) {
				e.removeAttribute('id');
				visited[id] = e;
			} else {
				console.log('source not found: ' + id);
				continue;
			}
		}
		node.replaceWith(e.cloneNode(true));
	}
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const ifc_names = this.ifc_names;

	let in_idl = false;
	let context_ifc = ''; // prefix 省略時の既定 interface 名

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん？]+|([\^@$]@?)([\w\.]+)(\([ \w,\[\]=…"]*\))?|`(.+?)([\^@$])(\w*)|！+\n?/g,
		create_html
	);

	function create_html(match, ind0, key, args, text, ind2, klass){
		if(text){
			key = text;
			let href = '';
			let href1 = '';
			{
				const n = key.indexOf('＠');
				if(n > 0) {
					href1 = key.slice(n + 1);
					key = key.slice(0, n);
					text = key;
				}
			}

			klass = klass || '';
			switch(klass){
			case 'r':
				text = `[${text}]`;
				href = `#biblio-${key.toLowerCase()}`;
				break;
			case 'l': // literal
				text = `"<code class="literal">${text}</code>"`;
				break;
			case 'U':
				text = `U+${text}`;
				break;
			case 'smb':
				text = `(<span class="char-symbol">${text}</span>)`;
				break;
			case 'mc': // IDL 内の構築子
				href = `#dom-${text.toLowerCase()}-${text.toLowerCase()}`;
				text = 'constructor';
				break;
			case 'xCode':
				return `<a id="_ex-html-${key}">＊</a>`;
				break;
			case 'dgm':
				return `<a id="_dgm-${key}">＊</a>`;
				break;
			case 'en': // english words
				return `<span lang="en">${text}</span>`
				break;
			}

			const tag = tag_map[klass];
			if(tag){
				const classname = class_map[klass];
				text = classname ? (
					`<${tag} class="${classname}">${text}</${tag}>`
				):(
					`<${tag}>${text}</${tag}>`
				);
			}

			if(ind2 === '^'){
				return text;
			}
			href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
			if(!href){
				console.log(match);
				return match;
			}
			switch(ind2){
			case '$':
				return `<a href="${href}">${text}</a>`;
			case '@':
				return `<dfn id="${href.slice(1)}">${text}</dfn>`;
			}
			return match;
		} else if(key){
			// idl constructs
			let text = key, href;
			if(!args && ( key in ifc_names ) ){
				href = ifc_names[key];
				if(ind0.length > 1){
//				if(ind0[1] === '@'){
					context_ifc = key;//.toLowerCase();
				}
			} else {
				let ifc = context_ifc;
				const dot = key.indexOf('.');
				if(dot >=0 ){
					ifc = key.slice(0, dot);
					key = text = key.slice(dot + 1); //text
				}
				if( key === ifc ){
					text = `new ${text}`; // constructor
				}
				href = `#dom-${ifc}-${key}`.toLowerCase();
				if(args){
					text += args.replace(/(\w+)(\s=\s\w+)?/g, '<var>$1</var>$2');
				}
			}
			if(!in_idl){
				text = `<code>${text}</code>`;
			}

			switch(ind0[0]){
			case '^':
				return text;
			case '$':
				return `<a href="${href}">${text}</a>`;
			case '@':
				return `<dfn id="${href.slice(1)}">${text}</dfn>`;
			}
		} else {
			switch(match[0]){
			case '%':
				return `<var>${match.slice(1)}</var>`;
			case '！':
				in_idl = (match[1] === '！' );
				return in_idl ? '<pre class="idl"><code>' : '</code></pre>';
			default:
				return match;
			}
		}
	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:DOM
spec_date:2026-01-15
trans_update:2026-01-17
source_checked:251126
spec_status:LS
original_url:https://dom.spec.whatwg.org/
	abbr_url:DOM4
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:infrastructure,uievents,html,selector
copyright:,whatwg
trans_1st_pub:2012-01-28

●●class_map
E:error
e:element
A:attr
et:event-type
prod:production
jv:js-value
U:code-point
cn:cp-name

●●tag_map
b:b
i:i
E:code
e:code
A:code
et:code
prod:code
m:code
c:code
jv:code
V:var
U:span
cn:span
cite:cite
em:em
mk:mark

●●words_table1

DOMissue:https://github.com/whatwg/dom/issues

COLOR_R:<span style="color:var(--R-color);">赤色区間</span>
COLOR_X:<span style="color:var(--G-color);">緑色区間</span>
COLOR_Y:<span style="color:var(--B-color);">青色区間</span>

CONSOLE:console-ja.html
XNLNS10:xml-names-ja.html
UIEVENTS-A:uievents-appendix-ja.html

Text: <code>Text</code> 
is0:<code class="attr">is</code> 

●●words_table

XMLNS:
	●構造／node tree
light:
open:
閉な:closed::閉じた
非可視:hidden:~
	閉な~shadowで非可視:closed-shadow-hidden
深優先前順な:preorder, depth-first:深さ優先かつ前順による
doctype:
属性o:attribute°::属性°
片:fragment::~::フラグメント
	~~孤立する:alone
	それだけで〜を成すすべて:alone in a

	全順序:linear
先行-:precede::~
後続-:follow::~
	のpartを成す／関与する
連続的:contiguous::~

	●data 型 ／ data 操作
首:primary::~
	首~interface:that implements the same interfaces as
数-:numeric:~
前挿入-:pre-insert::~
前除去-:pre-remove::~
	除去-前の:pre-remove
受入-:adopt::~
代入:assignment::~
部分文字列:substring:~
連結-:concatenate:~
worklet:
派生d:derived::派生

	上位の大域:superglobal
	除去される~node:toBeRemovedNode
	子も~cloneする:clone children
	文字列~化-:stringify
	文字列~化:stringification
	直列化-:serialization

	●一般処理
反復器:iterator::~
小task:microtask::小 task:小タスク
活動:activity:~
続行-:proceed:~
遭遇-:encounter:~
経路:path::~
受動-:passive::~
受動的:passive::~
composed:
	＊構成経路:composed::
相:phase::~::フェイズ
合成な:syntheticな::~
	取消せな:uncancelable
	伝播を即時に停止する:stop immediate propagation
	伝播を停止する:stop propagation
未決着:unsettled::~
注視-:watch:~
再入的:reentrant:~
	これまでに評価された:has ever been evaluated
形式変換-:transform::~
内部特能:internals::~
検査地点:checkpoint::~::チェックポイント
poll:
	~pollしている:polling
捕捉-:capture::~
処理待ち:pending:~
不可分:atomic::~
	不可分に:atomically

	一度限りか:once
	通達-時:signaling
	通達-法:signaling
	~promiseを返す:promise-returning
	~targetし直す:retarget
	validation
	起動するもの:initiator
	別~thread:cross-thread
	走り終えた
	引数:parameter
	順に:in order
	一括して:a batch of
	一括:batch
	`順^i:"next"
	`逆^i:"previous"
	`最初から^i:first
	`最後から^i:last
	`始端^i:"set the start"
	`終端^i:"set the end"

	●変数
	%A:A
	%A:(nodeA, offsetA)
	%B:B
	%B:(nodeB, offsetB)
	%入力:input
	%入力~token群:inputTokens
	%~token群:tokens
	%~token:-
	%~token集合:-
	%集合:set
	%node
	%~node
	%挿入される~node:node
	%~node群:nodes
	%node:-
	%nodeA:-
	%nodeB:-
	%選択子~文字列:selectors
	%選択子:selector
	%名前:qualifiedName
	%名前:name
	%名前:-
	%名前~群:names
	%属性o名:-
	%属性o名:attributeName
	%~ns:namespace
	%接頭辞:prefix
	%局所~名:localName
	%分割-結果:splitResult
	%controller:-
	%~event:event
	%~event~interface:eventInterface
	%~event構築子:eventConstructor
	%~composed経路:composedPath
	%経路:path
	%現-~target:currentTarget
	%現-~target~index:currentTargetIndex
	%現-~targetの非可視~下位tree~level:currentTargetHiddenSubtreeLevel
	%~index:index
	%現-非可視~level:currentHiddenLevel
	%最大-非可視~level:maxHiddenLevel
	%type
	%bubbles
	%cancelable
	%detail
	%辞書 eventInitDict
	%辞書 dictionary
	%辞書~型:-
	%~interface:-
	%~interface:interface
	%~realm:realm
	%時刻:time
	%~member:member
	%値:value
	%値:newValue
	%capture:capture
	%passive:passive
	%once:once
	%signal:signal
	%型
	%~target:eventTarget
	%~target:target
	%~targetを上書きするか:targetOverride
	%~target~clear用の構造体:clearTargetsStruct
	%~targetたちを~clearするか:clearTargets
	%文書:-
	%文書:document
	%文書片:-
	%文書片:fragment
	%~listener:listener
	%~listener群:listeners
	%捕捉するか:capture
	%受動的か:passive
	%一度限りか:once
	%通達:-
	%通達:signal
	%通達~群:signals
	%通達~interface:signalInterface
	%通達~slot集合:signalSet
	%L
	%大域~obj:global
	%~callback群:callbacks
	-:legacyOutputDidListenersThrowFlag
	%上書きする~target:targetOverride
	%作動化~target:activationTarget
	%関係する~target:relatedTarget
	%~touch~target群:touchTargets
	%~touch~target:touchTarget
	%作動化~eventか:isActivationEvent
	%~slot可能:slottable
	%~slot可能~群:slottables
	%~slotは閉な~tree内か:slot-in-closed-tree
	%親:parent
	%新-親:newParent
	%旧-親:oldParent
	%旧-親か~NULL:-
	%親は接続されているか:isParentConnected
	%構造体:struct
	%呼出n~target:invocationTarget
	%~shadow調整-済み~target:shadowAdjustedTarget
	%呼出n~targetは~shadow~tree内か:invocationTargetInShadowTree
	%閉な~treeの根か:root-of-closed-tree
	%相:phase
	%相:-
	%見出されたか:found
	%元の~event型:originalEventType
	%現在の~event:currentEvent
	%e
	%記述:description
	%何かするか:doAction
	%reason:reason
	%制御器:controller
	%事由:reason
	%milliseconds:milliseconds
	%~algo:algorithm
	%依存~通達:dependentSignal
	%中止する依存~通達~群:dependentSignalsToAbort
	%結果~通達:resultSignal
	%~source通達:sourceSignal
	%~promise:promise
	%すごい結果
	%p
	%N:-
	%旧-値:oldValue
	%要素:-
	%要素:element
	%要素の内部特能から可用か:-
	%~openか:open flag
	%~shadow:shadow
	%~shadow根:-
	%~shadow根~registry:shadowRootRegistry
	%現在の~shadow根:currentShadowRoot
	%~slot:-
	%~slot:slot
	%~slot可能:slottables
	%結果:result
	%結果:string
	%結果:-
	%根:root
	%根:-
	%~host:host
	%子:slottable
	%子:child
	%子孫:descendant
	%~slot割当n~mode
	%基準~子:referenceChild
	%観測器を抑止するか:suppressObservers
	%offset:offset
	%count:count 
	%data:data
	%offsetA:offsetA
	%offsetB:offsetB
	%C
	%範囲o:-
	-:copyAttribute
	%直前の同胞:previousSibling
	%広義-子孫:inclusiveDescendant
	%静的な~node~list:staticNodeList
	%除去-済み~node群:removedNodes
	%追加-済み~node群:addedNodes
	%除去された~node:removedNode
	%反復器:iterator
	%反復器:nodeIterator
	%直後の同胞:nextSibling
	%旧-直前の同胞:oldPreviousSibling
	%旧-直後の同胞:oldNextSibling
	%新-直前の同胞:newPreviousSibling
	%広義-先祖:inclusiveAncestor
	%登録-済み:registered
	%登録-済み~list:registered observer list
	%文字列:string
	%およそ直前の同胞:viablePreviousSibling
	%およそ直後の同胞:viableNextSibling
	%O:-
	%O:set
	%~ID:-
	%通知-集合:notifySet
	%記録~群:records
	%種別:type
	%有関係~観測器~群:interestedObservers
	%登録-済み:registered
	%観測器:mo
	%観測器:observer
	%~map先の旧-値:mappedOldValue
	%記録:record
	%長さ:length
	%除去-対象:-
	%除去-対象:nodesToRemove
	%~data:data
	%~data群:-
	%text:-
	%複製:copy
	%下位treeもか:subtree
	%属性o:attribute
	%属性o:attr
	%属性o:-
	%他~node:node1
	%自~node:node2
	%他~属性o:attr1
	%自~属性o:attr2
	%既定~ns:defaultNamespace
	%有修飾~名:qualifiedName
	%classNames:classNames
	%~class群:classes
	%is:is
	%旧-文書:oldDocument
	%構築子:constructor
	%interface
	%~doctype:-
	%H:-
	%~tree:-
	%状態:-
	%同期~custom要素か:synchronousCustomElements
	%定義:definition
	%C:C
	%C1:-
	%新-値:newValue
	%旧-属性o:oldAttribute
	%旧-属性o:oldAttr
	%新-属性o:newAttribute
	%新-属性o:newAttr
	%qualifiedName
	%~mode:mode
	%~clone可能か:clonable
	%~focusを委任するか:delegatesFocus
	%~shadow:shadow
	%where:where
	%差分:-
	%条件:-
	%~list:-
	%新-~data:newData
	%新-~node:newNode
	%始端~node:-
	%終端~node:-
	%先祖:-
	%P:-
	%Q:-
	%端:-
	%境界点:bp
	%index:index
	%この点:thisPoint
	%基準点:sourcePoint
	%元の始端~node:originalStartNode 
	%元の始端~offset:originalStartOffset
	%元の終端~node:originalEndNode
	%元の終端~offset:originalEndOffset
	%新-~offset:newOffset
	%clone:clone
	%共通な広義-先祖:commonAncestor
	%部分的に包含された最初の子:firstPartiallyContainedChild
	%部分的に包含された最後の子:lastPartiallyContainedChild
	%包含された子~群:containedChildren
	%下位-範囲o:subrange
	%下位-素片:subfragment
	%包含された子:contained child
	%始端~offset:start offset
	%基準~node:referenceNode
	%終端~offset:end offset
	%辿器:traverser
	%n:n
	%除去される~node:toBeRemovedNode
	%直後の:next
	%直前か:beforeNode
	%~collection:collection
	%walker:walker
	%向き:type
	%同胞:sibling
	%temporary:temporary
	-:isScriptElement
	%変換-済み~node群:-
	挿入された`~node$:insertedNode
	接続された`~node$:connectedNode
	%例外:exception
	%~registry:registry
	%~registry:-
	%文書~registry:-
	%~fallback~registry:fallbackRegistry
	%~option群:options
	%検証y-済みな値:verifiedValue
	-:deleteOffset

	●計時
時計:clock:~
高分解能:high resolution::高分解能
milli:milli-:::ミリ
	~milli秒数:number of milliseconds
	~milli秒後:in milliseconds
timeout::::タイムアウト
timer::::タイマー
粗い:coarseな:~
	現在時:now
	差分:offset
	までの細かさ:minimum
	何かが生じた:occurrence／:something has occurred
	~~発生:occurrence
	次に起きる出来事:what happens next
	〜までの間:duration

	●名前空間
	局所~名:local name
ns:namespace::名前空間
locate::特定
有修飾:qualified:~
英字:alpha::~

	●custom
	~custom化:customize
昇格:upgrade::~::アップグレード
	定義-済み
検索-:look up::~

	●slot
slot:
割当n:assignment::あてがい
割当-:assign::あてがい
	割当-先:assigned
	割当-先:assignment
	割当n~mode:assignment
割当され:assignされ::あてがわれ
割当する:assignする::あてがう
割当した:assignした::あてがった
割当法:assigning::あてがい方
見出法:finding:見出し方

	●Range
範囲o:range°::範囲°
	~~範囲
境界点:boundary point::~
位置bp:position::位置
位置-:位置
位置:位置
	相対位置
	位置変化
	位置関係
中身:内容
交わる:intersectする:~
交わら:intersectし:~
畳まれ:collapseされ:~
畳む:collapseする:~
選択-:select:~

	●collection
辿器:traverser::辿り器
whatToShow:
	濾過器
	濾過する
視野ng:scoping::視野::スコーピング
合致:match::~::マッチ
bitmask::::ビットマスク

	●仕様
制限付き:limited:~
	制限付き:limited-
	過去互換なし:no-quirks
多彩:rich:~
設計者:designer:~
所産:artifact:~
理想的:ideal:~
劇的:dramatic:~
冗長:redundant:~
中立的:neutral:~
精細:granular:~
旧式:old-style:~
環境設定:configurations:~
高価:expensive:~
軽量:lightweight:~
拡張用:extensibility:~
指図-:instruct:~
計画-:plan:~
望み:wishes:~
衝突-:clash:~
保つ:keepする:~
支払う:payする:~
警告:warning:~
処する:dealする:~
緩めら:loosenさ:~
異例:unusual:~
準拠な:compliantな:準拠する

	互換でない:incompatible
	~port可能:portable
	な限り:as much as
	簡便:convenience
	無用の長物:useless
	problematic
	適用-可能:applicable
	出発点:starting point
	広い:broader
	~~原因:cause
	~~目的
	様子:how
	略語:short for
	言葉を代えれば:Phrased differently,
	進路:course
	小論:essays
	報告書:reports
	本格的:fully-fledged
	手品:magic
	~~仕組:magic
	出来上がる:comes out
	十分:
	不要:
	~~的外れ:nonsensical
	~~選択:-
	名称:names
	否決:vetoed
	編集-時:editing
	事実:fact
	ほど遠い:not nearly as reliable or granular
	~~判明:proved
	~~根拠を示す:showing
	編集者:editors
	~~制御:key off
	便宜のため:For convenience
	区別:avoid confusion
	のふるまいに揃える:align with
	用途:for
	~~無視:not pay attention
	~~理由:mishap／because
	注意:notice that
	賢く:wise に
	記述
	必要:has to／
	~~強調:called out
	誤った考え:wrong ideas
	人:folks
	particular
	hairy
	何もしない:no-op／:empty
	により、:because of
	今の所:for now,
	あるとする:hypothetical
	もっぱら:exclusive
	最新:up-to-date
	するものもある:sometimes
	〜を指して:refer
	単に:For brevity

	働き続けられる:don’t stop working
	要-:require
	~~指定:flag:
	定義-法:defining
	操作-:manipulation
	~~説明:illustrate
	想定-:suppose
	内部処理用の:bookkeeping purposes
	存続-:continues to exist
	揃わせ:Aligning
	代わるもの:replacement
	不要にする:replaces the need
	~~廃する:rid of
	論を交わし:discussion
	~Fに:clear
	~~尊守され:enshrined
	知らせて:Let us know
	満たす:meet／
	気にする:worry about
	選べ:choose
	必要に応じて:according to their needs
	関心がなく:uninterested
	引き続き:remain
	表に出-:surface
	ようにする:opt
	とりわけ:among other things
	~~実際に:indeed
	HTML$r:HTML Standard
	主要:major
	至る:leading
	運ぶ:carry
	運ばせ:carry
	問われ:matter
	追加的にアリなもの:additional possibilities
	に倣う:aligned with
	煩わしい:annoying
	命名されてはいるが:Despite the parameter naming

	●未分類
重複:duplicate:~
付-:attach:~
XPath:
XSLT:
void:
agent:
surrounding:
multimedia::::マルチメディア
scrolling::::スクロール処理
touch:
wheel:
弱い:weakな:~
基準:reference:~
不正確:inaccurate:~
同等:equal:~
式:expression:~
body:
起点r:reference:起点
起点:origin::~
依存:dependent:~
最大-:max:~
現-:current:~
旧-:old:旧
新-:new:新
広義-:inclusive:~
狭義-:exclusive:~
給-:supply:~
正規表現:regular-expression::~

	直前の:previous
	直後の:next
	`required^c を伴う:required
	調整-済み:-adjusted
	渡-:pass
	生成元が類似な:similar-origin
	Checkbox
	Radio
	16進:hex
	連続する:adjacent／a sequence of
	一致
	除外-:exclude
	処理過程:process
	処理
	並び:sequence of
	された:got
	-:lead
	-:controller
	すごいこと:amazing
	すごい結果:amazingResult
	何かする:doAction
	つまらない:Boring
	内的に:inner
	内部:-
	広く:widely
	時点:
	以降:
	初回:first time
	ときには、:ocassionally
	前回:
	今度は:now
	現在:
	すべてまたは一部の:all or some
	唯一つ:only one
	唯一の:the sole
	すべて:all
	範囲:
	もの:thing
	上／上述:above
	一環:part of
	両方／両者／両:both
	複数:
	複数個:more than one
	隙間:
	終了:end
	逆順:reverse
	番目:
	差分:
	隣接:
	個以上:
	以前:
	項目:
	列目:
	個目:
	度目:
	二番目:
	下記
	開始
	末尾側:
	末尾:
	片方:
	末端:
	各種:
	一連:
	時点:
	対象:
	該当:
	後続:
	左側:
	直前:
	直後:
	部分:
	一部:
	対応している:corresponding
	対応:correspond
	同様:
	以外:
	以下:
	自身:
	先頭:
	個数:
	最後:last
	最初:first
	任意:
	有限個:
	有限:
	箇所:
	各項:
	合間:between
	最高:
	後述:
	一種:
	一対一:
	一対一に対応:1:1 mapping
	一列:
	一個:
	本数:
	各数字:
	最下位:
	逆向:
	前述:
	一例:
	全体:
	一方:
	自体:
	場合:if
	次のように:as follows
	逆順:reverse 〜 order／reversed
	称される:known as
	およそ:viable
	何か:something／
	0 番~以外の:subsequent code points, if any
	および:plus
	… に該当するもの:branch

	●訳注
	増減操作
	加減算
	次節
	部分集合
	可視化
	上下関係
	階層
	入子~階層
	無限増殖
	反復対象
	~~未定義
	誤記
	機能上
	括弧内
	見立てて
	~~例外
	ドット
	先掲
	算出
	~~定義
	区間
	根元
	対訳
	対称
	整理統合
	慣用表現
	付記
	単純に
	忠実
	意義
	不明
	~~状態
	整合性
	説明用
	見通し
	変形
	否定
	図左
	カット
	相当

	簡略化
	不変
	段階
	全部的
	概念的
	開始地点
	通過-
	横線
	太字
	前順
	優先
	構成-
	関係
	固有
	表記規約
	表記
	非公式
	括弧内: 2
	未策定: 2
	総称: 2
	何故:
	仮想: 2
	訳者: 2
	実行後
	適宜
	簡潔
	最上層
	参考
	実行例: 3
	濾過: 3
	探索
	見出し
	~~厳密
	~~無視
	補足
	補完
	模式図
	縦棒
	横線
	両端
	左端
	右端
	内縁
	外縁
	地点
	直上
	直下
	記号
	赤色区間
	緑色区間
	青色区間
	原文
	意図-
	図右
	上図
	下図
	混在


●●original_id_map


dom-domtokenlist-stringifier:DOMTokenList-stringification-behavior

	■旧 id
	infrastructure:dependencies
	infrastructure:terminology
	action-versus-occurrence:action-versus-occurance

●●mdn_urls
abortcontroller:API/AbortController
abortsignal:API/AbortSignal
attr:API/Attr
characterdata:API/CharacterData
customevent:API/CustomEvent
	dictdef-customeventinit:API/CustomEventInit
comment:API/Comment
childnode:API/ChildNode
cdatasection:API/CDATASection
nondocumenttypechildnode:API/NonDocumentTypeChildNode
document:API/Document
documentfragment:API/DocumentFragment
shadowroot:API/ShadowRoot
	dictdef-shadowrootinit:API/ShadowRootInit
	enumdef-shadowrootmode:API/ShadowRootMode
	enumdef-slotassignmentmode:API/SlotAssignmentMode
documentorshadowroot:API/DocumentOrShadowRoot
	dictdef-getrootnodeoptions:API/GetRootNodeOptions
domimplementation:API/DOMImplementation
documenttype:API/DocumentType
element:API/Element
	dictdef-elementcreationoptions:API/ElementCreationOptions
	elements:API/Elements
event:API/Event
	dictdef-eventinit:API/EventInit
callbackdef-eventlistener:API/EventListener
eventtarget:API/EventTarget
	eventlisteneroptions:API/EventListenerOptions
	addeventlisteneroptions:API/AddEventListenerOptions
htmlcollection:API/HTMLCollection
	mutationcallback:API/MutationCallback
mutationobserver:API/MutationObserver
dictdef-mutationobserverinit:API/MutationObserverInit
mutationrecord:API/MutationRecord
namednodemap:API/NamedNodeMap
node:API/Node
callbackdef-nodefilter:API/NodeFilter
nodeiterator:API/NodeIterator
nodelist:API/NodeList
processinginstruction:API/ProcessingInstruction
range:API/Range
staticrange:API/StaticRange
	dictdef-staticrangeinit:API/StaticRangeInit
abstractrange:API/AbstractRange
parentnode:API/ParentNode
	nonelementparentnode:API/NonElementParentNode
domtokenlist:API/DOMTokenList
treewalker:API/TreeWalker
text:API/Text
xmldocument:API/XMLDocument
xpathresult:API/XPathResult
xpathexpression:API/XPathExpression
callbackdef-xpathnsresolver:API/XPathNSResolver
	xpathevaluatorbase:API/XPathEvaluatorBase
xpathevaluator:API/XPathEvaluator
xsltprocessor:API/XSLTProcessor

	（廃）
	rangeexception:API/RangeException
mutationevent:API/MutationEvent
	mutationnameevent:API/MutationNameEvent
domconfiguration:API/DOMConfiguration
domerror:API/DOMError
	domerrorhandler:API/DOMErrorHandler
domimplementationlist:API/DOMImplementationList
	domimplementationsource:API/DOMImplementationSource
domlocator:API/DOMLocator
domobject:API/DOMObject
domuserdata:API/DOMUserData
	entity:API/Entity
	entityreference:API/EntityReference
namelist:API/NameList
notation:API/Notation
typeinfo:API/TypeInfo
userdatahandler:API/UserDataHandler

eventdef-abortsignal-abort:API/AbortSignal/abort_event
eventdef-htmlslotelement-slotchange:API/HTMLSlotElement/slotchange_event

●●ifc_names


any:~WEBIDL#idl-any
boolean:~WEBIDL#idl-boolean
sequence:~WEBIDL#idl-sequence
short:~WEBIDL#idl-unsigned-short
undefined:~WEBIDL#idl-undefined
AbortController
AbortSignal
AbstractRange
AddEventListenerOptions
Attr
CDATASection
CharacterData
ChildNode
Comment
CustomEvent
CustomEventInit:#dictdef-customeventinit
DOMImplementation
DOMString:~WEBIDL#idl-DOMString
DOMTokenList
Document
DocumentFragment
DocumentOrShadowRoot
DocumentType
Element
ElementCreationOptions:#dictdef-elementcreationoptions
Elements
Event
EventInit:#dictdef-eventinit
EventListener:#callbackdef-eventlistener
EventListenerOptions
EventTarget
GetRootNodeOptions:#dictdef-getrootnodeoptions
HTMLCollection
ImportNodeOptions:#dictdef-importnodeoptions
MutationCallback
MutationObserver
MutationObserverInit:#dictdef-mutationobserverinit
MutationRecord
NamedNodeMap
Node
NodeFilter:#callbackdef-nodefilter
NodeIterator
NodeList
NonDocumentTypeChildNode
NonElementParentNode
ParentNode
ProcessingInstruction
Range
ShadowRoot
ShadowRootInit:#dictdef-shadowrootinit
ShadowRootMode:#enumdef-shadowrootmode
SlotAssignmentMode:#enumdef-slotassignmentmode
Slottable:#slotable
StaticRange
StaticRangeInit:#dictdef-staticrangeinit
Text
TreeWalker
TrustedType:~TRUSTED-TYPES#typedefdef-trustedtype
USVString:~WEBIDL#idl-USVString
XMLDocument
XPathEvaluator
XPathEvaluatorBase
XPathExpression
XPathNSResolver:#callbackdef-xpathnsresolver
XPathResult
XSLTProcessor


	●→ 廃止
RangeException
MutationEvent
MutationNameEvent
DOMConfiguration
DOMError
DOMErrorHandler
DOMImplementationList
DOMImplementationSource
DOMLocator
DOMObject
DOMUserData
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler


DOMStringList:~HTMLcdom#domstringlist
HTMLElement:~HTMLdom#htmlelement
HTMLHtmlElement:~HEmetadata#htmlhtmlelement
HTMLSlotElement:~HEscripting#htmlslotelement
HTMLUnknownElement:~HTMLdom#htmlunknownelement
CustomElementRegistry:~HEcustom#customelementregistry
ServiceWorkerGlobalScope:~SW1#serviceworkerglobalscope
Window:~WINDOW#window
BeforeUnloadEvent:~WINDOW#beforeunloadevent
CompositionEvent:~UIEVENTS#compositionevent
TextEvent:~UIEVENTS-A#textevent
	#interface-compositionevent
	CustomEvent
DeviceMotionEvent:~DEVICEORIENTATION#devicemotionevent
DeviceOrientationEvent:~DEVICEORIENTATION#deviceorientationevent
EventHandler:~WAPI#eventhandler
DragEvent:~HTMLdnd#dragevent
FocusEvent:~UIEVENTS#focusevent
	#interface-focusevent
	Event
HashChangeEvent:~WINDOW#hashchangeevent
KeyboardEvent:~UIEVENTS#keyboardevent
MessageEvent:~HTMLcomms#messageevent
MouseEvent:~UIEVENTS#mouseevent
StorageEvent:~WEBSTORAGE#storageevent
TouchEvent:https://w3c.github.io/touch-events/#touchevent-interface
UIEvent:~UIEVENTS#uievent


DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
DOMException:~WEBIDL#idl-DOMException

●●link_map

e.script:~HEscripting#the-script-element
e.style:~HEmetadata#the-style-element
e.input:~HEinput#the-input-element
e.title:~HEmetadata#the-title-element
e.html:~HEmetadata#the-html-element
e.head:~HEmetadata#the-head-element
e.body:~HEsections#the-body-element
e.template:~HEscripting#the-template-element
e.slot:~HEscripting#the-slot-element
e.input:~HEinput#the-input-element
e.area:~HEimages#the-area-element


l.open:#dom-shadowrootmode-open
l.closed:#dom-shadowrootmode-closed
l.manual:#dom-slotassignmentmode-manual
l.named:#dom-slotassignmentmode-named

	●IDL
CEReactions:~HEcustom#cereactions
EnforceRange:~WEBIDLjs#EnforceRange
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
Unscopable:~WEBIDLjs#Unscopable
NewObject:~WEBIDLjs#NewObject
PutForwards:~WEBIDLjs#PutForwards
Replaceable:~WEBIDLjs#Replaceable
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable
LegacyUnenumerableNamedProperties:~WEBIDLjs#LegacyUnenumerableNamedProperties
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString

any:~WEBIDL#idl-any
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
unsigned long long:~WEBIDL#idl-unsigned-long-long
unrestricted double:~WEBIDL#idl-unrestricted-double

E.TypeError:~WEBIDL#exceptiondef-typeerror
E.AbortError:~WEBIDL#aborterror
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.InUseAttributeError:~WEBIDL#inuseattributeerror
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidCharacterError:~WEBIDL#invalidcharactererror
E.InvalidNodeTypeError:~WEBIDL#invalidnodetypeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NamespaceError:~WEBIDL#namespaceerror
E.NotFoundError:~WEBIDL#notfounderror
E.NotSupportedError:~WEBIDL#notsupportederror
E.SyntaxError:~WEBIDL#syntaxerror
E.TimeoutError:~WEBIDL#timeouterror
E.WrongDocumentError:~WEBIDL#wrongdocumenterror

m.detail:~UIEVENTS#dom-uievent-detail
m.event:#dom-window-event

最初のもの？:#_first_obj
最後のもの？:#_last_obj
最後0:#_last_obj
（旧来の）~listenerは投出したか:~INDEXEDDB#_legacyOutputDidListenersThrowFlag

適用-可能な仕様:#other-applicable-specifications

	●event
c.onabort:#abortsignal-onabort
c.onslotchange:#shadowroot-onslotchange
et.abort:#eventdef-abortsignal-abort
et.slotchange:#eventdef-htmlslotelement-slotchange

ev.初期化-済みか:#initialized-flag
ev.伝播を即時に停止するか:#stop-immediate-propagation-flag
ev.伝播を停止するか:#stop-propagation-flag
ev.取消されたか:#canceled-flag
ev.配送-中か:#dispatch-flag
ev.受動-~listener内か:#in-passive-listener-flag
ev.~composedか:#composed-flag

既定の受動-値:#default-passive-value

evP.呼出n~target:#event-path-invocation-target
evP.呼出n~targetは~shadow~tree内か:#event-path-invocation-target-in-shadow-tree
evP.~shadow調整-済み~target:#event-path-shadow-adjusted-target
evP.~touch~target~list:#event-path-touch-target-list
evP.関係する~target:#event-path-relatedtarget
evP.閉な~treeの根か:#event-path-root-of-closed-tree
evP.~slotは閉な~tree内か:#event-path-slot-in-closed-tree

~event:#concept-event
~eventを作成する:#concept-event-create
~eventを内的に作成する:#inner-event-creation-steps
~eventを初期化する:#concept-event-initialize
~eventを配送する:#concept-event-dispatch
配送-:#concept-event-dispatch
~eventを発火する:#concept-event-fire

~event経路に付加する:#concept-event-path-append
~target:#event-target
~targetし直す:#retarget
~event~targetになり得るもの:#potential-event-target
関係する~target:#event-relatedtarget
~touch~target~list:#event-touch-target-list
経路:#event-path

~listenerを呼出す:#concept-event-listener-invoke
~listenerを内的に呼出す:#concept-event-listener-inner-invoke
~event~listenerを追加する:#add-an-event-listener
~event~listenerを除去する:#remove-an-event-listener
~event~listenerをすべて除去する:#remove-all-event-listeners
~event~listener~list:#eventtarget-event-listener-list
~event~listener:#concept-event-listener
~sw~fetch~event~listener~callback群を得する旧来の手続き:#legacy-obtain-service-worker-fetch-event-listener-callbacks

evL.型:#event-listener-type
evL.~callback:#event-listener-callback
evL.捕捉するか:#event-listener-capture
evL.受動的か:#event-listener-passive
evL.一度限りか:#event-listener-once
evL.通達:#event-listener-signal
evL.除去-済みか:#event-listener-removed

~option群を平坦~化する:#concept-flatten-options
~option群をもっと平坦~化する:#event-flatten-more
親~targetを取得する:#get-the-parent
~event構築子:#concept-event-constructor

作動化の挙動:#eventtarget-activation-behavior
旧来の作動化~前の挙動:#eventtarget-legacy-pre-activation-behavior
旧来の作動化~取消~時の挙動:#eventtarget-legacy-canceled-activation-behavior

~event構築-時の手続き:#concept-event-constructor-ext
取消されたかを設定する:#set-the-canceled-flag
現在の~event:#window-current-event

	●abort
aC.通達:#abortcontroller-signal
aC.中止-を通達する:#abortcontroller-signal-abort
aB.中止-を通達する:#abortsignal-signal-abort
aB.中止-事由:#abortsignal-abort-reason
aB.中止-済み:#abortsignal-aborted
aB.中止する~algo群:#abortsignal-abort-algorithms
aB.依存~通達~群:#abortsignal-dependent-signals
aB.依存か:#abortsignal-dependent
aB.~source通達~群:#abortsignal-source-signals
通達に~algoを追加する:#abortsignal-add
通達から~algoを除去する:#abortsignal-remove
依存~中止-通達を作成する:#create-a-dependent-abort-signal
通達~用の中止-手続きを走らす:#run-the-abort-steps

	●node／~tree
~node:#concept-node
親~要素:#parent-element
子:#concept-tree-child
子~群:#concept-tree-child
親:#concept-tree-parent
先祖:#concept-tree-ancestor
子孫:#concept-tree-descendant
広義-先祖:#concept-tree-inclusive-ancestor
広義-子孫:#concept-tree-inclusive-descendant
共通な広義-先祖:#_common-inclusive-ancestor

最初の子？:#concept-tree-first-child
最後の子？:#concept-tree-last-child
先行-:#concept-tree-preceding
後続-:#concept-tree-following
~index:#concept-tree-index

直前の同胞？:#concept-tree-previous-sibling
直後の同胞？:#concept-tree-next-sibling
関与-:#concept-tree-participate
同胞:#concept-tree-sibling
広義-同胞:#concept-tree-inclusive-sibling

~tree:#concept-tree
~node~tree:#concept-node-tree
文書~tree:#concept-document-tree
根:#concept-tree-root
~tree順序:#concept-tree-order
要素~interface:#concept-element-interface

文書~tree内:#in-a-document-tree
文書~内:#in-a-document

~nodeを受入する:#concept-node-adopt
~nodeを付加する:#concept-node-append
~nodeを子の前に挿入する:#concept-node-insert
	i.観測器を抑止する:#insert-suppressobservers
~nodeを子の前に前挿入する:#concept-node-pre-insert
親の中で子の前に挿入できるか検証する:#concept-node-ensure-pre-insertion-validity
~nodeを移動する:#move
子を親から前除去する:#concept-node-pre-remove
~nodeを除去する:#concept-node-remove
	i.観測器を抑止する:#remove-suppressobservers
子を~nodeに置換する:#concept-node-replace
全~内容を~nodeで置換する:#concept-node-replace-all
全~内容を文字列に置換する:#string-replace-all
隣に~nodeを挿入する:#insert-adjacent
~nodeを~cloneする:#concept-node-clone
単独の~nodeを~cloneする:#clone-a-single-node
	i.文書:#clone-a-node-document
	i.下位treeか:#clone-a-node-subtree
	i.親:#clone-a-node-parent
~nodeの~text内容を取得する:#get-text-content
~nodeの~text内容を設定する:#set-text-content
子~text内容:#concept-child-text-content
~text~dataを連結する:#_concatenate-text-data
~node反復器~用の除去-前の手続き:#nodeiterator-pre-removing-steps

受入-時の手続き:#concept-node-adopt-ext
挿入-時の手続き:#concept-node-insert-ext
子~群~変更-時の手続き:#concept-node-children-changed-ext
除去-時の手続き:#concept-node-remove-ext
接続~後の手続き:#concept-node-post-connection-ext
~clone時の手続き:#concept-node-clone-ext
移動-時の手続き:#concept-node-move-ext

~node文書:#concept-node-document
node.長さ:#concept-node-length
node.空:#concept-node-empty
node.同等:#concept-node-equals

文書片:#_concept-documentfragment
文字~data~node:#_concept-cdata-node
~host:#concept-documentfragment-host
~hostも含めた広義-先祖:#concept-tree-host-including-inclusive-ancestor

~ID:#concept-id

定義された各:#_specifications-defined

	●shadow
~light~tree:#concept-light-tree
~shadow~tree:#concept-shadow-tree
~shadow~host:#element-shadow-host
妥当な~shadow~host名:#valid-shadow-host-name
~shadow根:#concept-shadow-root
sR.~mode:#shadowroot-mode
sR.~focusを委任するか:#shadowroot-delegates-focus
sR.要素の内部特能から可用か:#shadowroot-available-to-element-internals
sR.~slot割当n~mode:#shadowroot-slot-assignment
sR.~clone可能か:#shadowroot-clonable
sR.直列化-可能か:#shadowroot-serializable
sR.宣言的か:#shadowroot-declarative
sR.~custom要素~registry:#shadowroot-custom-element-registry
sR.~custom要素~registryを~NULLに保つか:#shadowroot-keep-custom-element-registry-null
~shadow根を付する:#concept-attach-a-shadow-root

~shadowも含めた子孫:#concept-shadow-including-descendant
~shadowも含めた広義-子孫:#concept-shadow-including-inclusive-descendant
~shadowも含めた先祖:#concept-shadow-including-ancestor
~shadowも含めた広義-先祖:#concept-shadow-including-inclusive-ancestor
~shadowも含めた~tree順序:#concept-shadow-including-tree-order
~shadowも含めた深優先前順な辿り:#shadow-including-preorder-depth-first-traversal
接続されて:#connected
~shadowも含めた根:#concept-shadow-including-root
	#in-a-shadow-including-document
閉な~shadowで非可視:#concept-closed-shadow-hidden

	●slot
~slot:#concept-slot
~slot可能:#concept-slotable
	~slot可能:#concept-slotable
~slot名:#slot-name
	＊sL.名前:#slot-name
sB.名前:#slotable-name
~slot可能~用に~slotを見出す:#find-a-slot
~slot用に~slot可能なものを見出す:#find-slotables
~slot用に平坦~化された~slot可能なものを見出す:#find-flattened-slotables
割当-先~slot:#slotable-assigned-slot
手動~割当-先~slot:#slottable-manual-slot-assignment
割当-先がある:#slotable-assigned
割当された~node群:#slot-assigned-nodes
手動で割当された~node群:~HEscripting#manually-assigned-nodes
~slot可能を~slotに割当する:#assign-a-slot
~slotに~slot可能なものを割当する:#assign-slotables
~treeに~slot可能なものを割当する:#assign-slotables-for-a-tree
通達~slot群:#signal-slot-list
~slotの変化を通達する:#signal-a-slot-change

	●文書／文書片／名前空間
文書:#concept-document
doc.符号化法:#concept-document-encoding
doc.内容~型:#concept-document-content-type
doc.~URL:#concept-document-url
doc.種別:#concept-document-type
doc.生成元:#concept-document-origin
doc.~mode:#concept-document-mode
doc.宣言的な~shadow根を許容するか:#document-allow-declarative-shadow-roots
doc.~custom要素~registry:#document-custom-element-registry

文書~基底~URL:~HTMLurl#document-base-url
結付けられた文書:~WINDOW#concept-document-window

制限付き過去互換~mode:#concept-document-limited-quirks
過去互換なし~mode:#concept-document-no-quirks
過去互換~mode:#concept-document-quirks
~doctype:#concept-doctype
dT.名前:#concept-doctype-name
dT.公な~ID:#concept-doctype-publicid
dT.~system~ID:#concept-doctype-systemid

~HTML文書:#html-document
~XML文書:#xml-document

~ns接頭辞を~locateする:#locate-a-namespace-prefix
~nsを~locateする:#locate-a-namespace
内部 createElementNS 手続き:#internal-createelementns-steps

妥当な~doctype名:#valid-doctype-name
妥当な~ns接頭辞:#valid-namespace-prefix
妥当な属性~局所~名:#valid-attribute-local-name
妥当な要素~局所~名:#valid-element-local-name

	●text node／文字列／cdata
新たな~Text~node:#_a-new-text-node

有順序~集合として構文解析する:#concept-ordered-set-parser
有順序~集合を直列化する:#concept-ordered-set-serializer

~Text~nodeを分割する:#concept-text-split
~dataを置換する:#concept-cd-replace
~data:#concept-cd-data
~dataの部分文字列:#concept-cd-substring

狭義-~Text~node:#exclusive-text-node
連続的な~Text~node列:#contiguous-text-nodes
連続的な狭義-~Text~node列:#contiguous-exclusive-text-nodes
連続的な同胞~列:#_contiguous-nodes

子孫~text内容:#concept-descendant-text-content

	●要素／属性
文書~要素:#document-element
要素:#concept-element
el.局所~名:#concept-element-local-name
el.~shadow根:#concept-element-shadow-root
el.~ns:#concept-element-namespace
el.~ns接頭辞:#concept-element-namespace-prefix
el.~custom要素~registry:#element-custom-element-registry
el.属性o~list:#concept-element-attribute
有修飾~名:#concept-element-qualified-name
~HTML大文字~化~有修飾~名:#element-html-uppercased-qualified-name
~nsと名前を検証して抽出する:#validate-and-extract
有する:#concept-element-attribute-has

属性o値の変化を取扱う:#handle-attribute-changes
属性o値を変更する:#concept-element-attributes-change
属性oを付加する:#concept-element-attributes-append
属性oを除去する:#concept-element-attributes-remove
属性oを置換する:#concept-element-attributes-replace
属性oを設定する:#concept-element-attributes-set
既存の属性oの値を設定する:#set-an-existing-attribute-value
属性o値を設定する:#concept-element-attributes-set-value
属性o値を取得する:#concept-element-attributes-get-value

属性oを名前により取得する:#concept-element-attributes-get-by-name
属性oを名前により除去する:#concept-element-attributes-remove-by-name
属性oを~nsと局所~名により取得する:#concept-element-attributes-get-by-namespace
属性oを~nsと局所~名により除去する:#concept-element-attributes-remove-by-namespace

属性o:#concept-attribute
nm.属性o:#concept-named-attribute
属性o変更-時の手続き:#concept-element-attributes-change-ext
属する要素:#concept-attribute-element
a.有修飾~名:#concept-attribute-qualified-name
a.値:#concept-attribute-value
a.~ns:#concept-attribute-namespace
a.~ns接頭辞:#concept-attribute-namespace-prefix
a.局所~名:#concept-attribute-local-name

nm.要素:#concept-namednodemap-element
nm.属性o~list:#concept-namednodemap-attribute
~class群:#concept-class
~class群に含む要素の~list:#concept-getelementsbyclassname
有修飾~名に持つ要素の~list:#concept-getelementsbytagname
( ~ns, 局所~名 ) に持つ要素の~list:#concept-getelementsbytagnamens

反映する:#concept-reflect


	●custom要素
要素を作成する:#concept-create-element
要素~作成~option群を平坦~化する:#flatten-element-creation-options
要素を内部的に作成する:#create-an-element-internal
定義-済み:#concept-element-defined
~custom:#concept-element-custom
ceR.大域的:#is-a-global-custom-element-registry
大域的な~custom要素~registryを取得する:#effective-global-custom-element-registry
el.~custom要素~状態:#concept-element-custom-element-state
el.~custom要素~定義:#concept-element-custom-element-definition
el.~is0値:#concept-element-is-value
cD.名前:~HEcustom#concept-custom-element-definition-name
cD.局所~名:~HEcustom#concept-custom-element-definition-local-name
cD.構築子:~HEcustom#concept-custom-element-definition-constructor
cD.~shadowを不能化するか:~HEcustom#concept-custom-element-definition-disable-shadow
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~custom要素~構築子:~HEcustom#custom-element-constructor
作動中な~custom要素~構築子~map:~HEcustom#active-custom-element-constructor-map
~custom要素~callback反応を~enqueueする:~HEcustom#enqueue-a-custom-element-callback-reaction
~custom化された組込みの要素:~HEcustom#customized-built-in-element
~custom要素~registryを検索する:~HEcustom#look-up-a-custom-element-registry
cR.視野~付きか:~HEcustom#is-scoped
cR.視野~付き文書~集合:~HEcustom#scoped-document-set
~custom要素~定義:~HEcustom#custom-element-definition
~custom要素~定義を検索する:~HEcustom#look-up-a-custom-element-definition
要素を昇格するよう試行する:~HEcustom#concept-try-upgrade
要素を昇格する:~HEcustom#concept-upgrade-an-element
~custom要素~昇格~反応を~enqueueする:~HEcustom#enqueue-a-custom-element-upgrade-reaction


	●変異
変異~記録を~queueする:#queue-a-mutation-record
~tree変異~記録を~queueする:#queue-a-tree-mutation-record
~node群を~nodeに変換する:#convert-nodes-into-a-node

mo.~callback:#concept-mo-callback
mo.~node~list:#mutationobserver-node-list
mo.記録~queue:#concept-mo-queue

変異~観測器の小taskは~queueされたか:#mutation-observer-compound-microtask-queued-flag
変異~観測器 小taskを~queueする:#queue-a-mutation-observer-compound-microtask
変異~観測器に通知する:#notify-mutation-observers

登録-済み観測器:#registered-observer
一時~登録-済み観測器:#transient-registered-observer
処理待ち変異~観測器~群:#mutation-observer-list
登録-済み観測器~list:#registered-observer-list

ob.観測器:#registered-observer-observer
ob.~option群:#registered-observer-options
ob.~source:#transient-registered-observer-source


	●範囲
範囲o:#concept-range
~live範囲o:#concept-live-range
rg.妥当:#staticrange-valid
rg.根:#concept-range-root
rg.中身:#_concept-range-content

~live範囲o用の除去-前の手続き:#live-range-pre-remove-steps
範囲oの中身を抽出する:#concept-range-extract
範囲oの中身を~cloneする:#concept-range-clone
範囲oの中へ挿入する:#concept-range-insert
範囲oの中身として選択する:#concept-range-select

境界点:#concept-range-bp
bp.~node:#boundary-point-node
bp.~offset:#concept-range-bp-offset

i.より前:#concept-range-bp-before
i.より後:#concept-range-bp-after
i.に等しい:#concept-range-bp-equal

終端~node:#concept-range-end-node
終端~offset:#concept-range-end-offset
終端:#concept-range-end
始端~node:#concept-range-start-node
始端~offset:#concept-range-start-offset
始端:#concept-range-start
畳まれて:#range-collapsed

相対的な位置bp:#concept-range-bp-position
境界点を設定する:#concept-range-bp-set

包含され:#contained
部分的に包含され:#partially-contained

	●token list

tL.~supportする~token集合:#concept-supported-tokens
tL.~token集合:#concept-dtl-tokens
tL.要素:#domtokenlist-element
tL.属性o名:#domtokenlist-attribute-name
tL.更新~手続き:#concept-dtl-update
tL.直列化-手続き:#concept-dtl-serialize
~tokenを検証する:#concept-domtokenlist-validation
~tokenを検査する:#_dtl-check-token

	●collection／node iterator／tree walker
表現-:#represented-by-the-collection
反復器~collection:#iterator-collection
~live:#concept-collection-live
静的:#concept-collection-static
~collection:#concept-collection

cL.~filter:#_collection-filter
cL.根:#_collection-root

tV.作動中か:#concept-traversal-active
tV.~filter~callback:#concept-traversal-filter
tV.根:#concept-traversal-root
tV.~whatToShow:#concept-traversal-whattoshow
tV.現-~node:#treewalker-current
tV.起点r:#nodeiterator-reference
tV.起点rの直前か:#nodeiterator-pointer-before-reference

辿器の中で~nodeを~filterにかける:#concept-node-filter
子~群を辿る:#concept-traverse-children
同胞たちを辿る:#concept-traverse-siblings
反復器で辿る:#concept-nodeiterator-traverse

	●PI
pI.~target:#concept-pi-target

	●INFRA
有順序~集合:~INFRA#ordered-set
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
set.置換する:~INFRA#set-replace
~list:~INFRA#list
~item:~INFRA#list-item
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
~cloneする:~INFRA#list-clone
~size:~INFRA#list-size
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
除去する:~INFRA#list-remove
挿入する:~INFRA#list-insert
置換する:~INFRA#list-replace
拡張する:~INFRA#list-extend
	~INFRA#list-contain
~queue:~INFRA#queue
~enqueueする:~INFRA#queue-enqueue
~map:~INFRA#ordered-map
構造体:~INFRA#struct
~tuple:~INFRA#tuple
	list.~EACH:~INFRA#list-iterate
	list.~CONTINUE:~INFRA#iteration-continue
	list.包含-:~INFRA#list-contain
	list.~IN:~INFRA#list-contain
	list.~NIN:~INFRA#list-contain

文字列:~INFRA#string
符号位置:~INFRA#code-point
符号単位:~INFRA#code-unit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大文字~化する:~INFRA#ascii-uppercase
~ASCII英字:~INFRA#ascii-alpha
~ASCII数字:~INFRA#ascii-digit
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
str.長さ:~INFRA#string-length
一致する:~INFRA#string-is
連結する:~INFRA#string-concatenate
区切子で厳密に分割する:~INFRA#strictly-split
符号単位~部分文字列:~INFRA#code-unit-substring
成す符号単位~部分文字列:~INFRA#code-unit-substring-by-positions
終端までを成す符号単位~部分文字列:~INFRA#code-unit-substring-to-the-end-of-the-string

~HTML~ns:~INFRA#html-namespace
~SVG~ns:~INFRA#svg-namespace
~XML~ns:~INFRA#xml-namespace
~XMLNS~ns:~INFRA#xmlns-namespace


	●選択子
~nodeの視野の下で選択子を照合する:#scope-match-a-selectors-string
選択子として構文解析する:~SELECTORS4#parse-a-selector
視野ng根:~SELECTORS4#scoping-root
~treeに対し選択子を照合する:~SELECTORS4#match-a-selector-against-a-tree
要素に対し選択子を照合する:~SELECTORS4#match-a-selector-against-an-element

	●WEBIDL
実装-:~WEBIDLjs#implements
新たな~obj:~WEBIDLjs#new
辞書:~WEBIDL#dfn-dictionary
辞書~member:~WEBIDL#dfn-dictionary-member
識別子:~WEBIDL#dfn-identifier
	interface mixin:~WEBIDL#idl-interface-mixins
首~interface:~WEBIDL#dfn-primary-interface

~supportする~prop~index:~WEBIDL#dfn-supported-property-indices
~supportする~prop名:~WEBIDL#dfn-supported-property-names
投出:~WEBIDL#dfn-throw
可変個引数:~WEBIDL#dfn-variadic
利用元~objの演算を~callする:~WEBIDLjs#call-a-user-objects-operation
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
~IDL値に変換する:~WEBIDLjs#dfn-convert-javascript-to-idl-value
~callback関数で構築する:~WEBIDLjs#construct-a-callback-function
属する~realm:~WEBIDLjs#dfn-associated-realm
文字列~化の挙動:~WEBIDL#dfn-stringification-behavior

	●他
新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve

信用-済みな型に準拠な属性~値を取得する:~TRUSTED-TYPES#get-trusted-type-compliant-attribute-value

~consoleに警告を報告する:~CONSOLE#report-a-warning-to-the-console

~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

utf-8:~ENCODING#utf-8
符号化法:~ENCODING#encoding
enc.名前:~ENCODING#name

prod.Name:~TR/xml/#NT-Name

~HTML構文解析器:~HTMLparsing#html-parser
~void要素:~HTMLwriting#void-elements
並列的:~HTMLINFRA#in-parallel

例外を報告する:~WAPI#report-an-exception
関連な大域~obj:~WAPI#concept-relevant-global
現在の大域~obj:~WAPI#current-global-object
関連な~realm:~WAPI#concept-relevant-realm
関連な~agent:~WAPI#relevant-agent
rM.大域~obj:~WAPI#concept-realm-global
大域~taskを~queueする:~WAPI#queue-a-global-task
小task:~WAPI#microtask
小taskを~queueする:~WAPI#queue-a-microtask
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
生成元が類似な~window~agent:~WAPI#similar-origin-window-agent
enV.時刻~起点:~WAPI#concept-settings-object-time-origin

~body要素:~HTMLdom#the-body-element-2

手続きを~timeout後に走らす:~HTMLGAPI#run-steps-after-a-timeout
~timer~task~source:~HTMLGAPI#timer-task-source

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

閲覧~文脈:~HTMLds#browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
~sw:~SW1#dfn-service-worker
SWG.~sw:~SW1#serviceworkerglobalscope-service-worker
取扱う~event型の集合:~SW1#dfn-set-of-event-types-to-handle
~script資源:~SW1#dfn-script-resource
これまでに評価されたか:~SW1#dfn-has-ever-been-evaluated-flag
~sw~event:~SW1#dfn-service-worker-events

~realm:~TC39#realm
現在の~realm:~TC39#current-realm
~surrounding~agent:~TC39#surrounding-agent

相対的な粗い高分解能~時刻:~HRTIME#dfn-relative-high-resolution-coarse-time
現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
~event~listener用に計時~報を記録する:~LONGAF#record-timing-info-for-event-listener

	:https://w3c.github.io/webcomponents/spec/shadow/
	:~HTMLselectors#selector-defined
	:#mutation-algorithms

_acks1:#_acks1
_ipr1:#_ipr1

●●html_code_list
■tree-order-1
<e><e></e>ソースに<e>現れる<e>順序が</e><e>そのまま<e>ツリー順序に</e></e>なる</e></e>

■event-1
<!doctype html>
<html>
 <head>
  <title>つまらない例</title>
 </head>
 <body>
  <p>Hello ＜<span id=x>world</span>＞!</p>
  <％script>
function test(%e) {
  debug(%e.target, %e.currentTarget, %e.eventPhase); // A
}
document.addEventListener("hey", test, {capture: true}); // B
document.body.addEventListener("hey", %test); // C
var %ev = new Event("hey", {bubbles:true})
document.getElementById(＜"x"＞).dispatchEvent(%ev);
  <％/script>
 </body>
</html>

■introduction-1
<!DOCTYPE html>
<html class=e>
 <head><title>Aliens?</title></head>
 <body>Why yes.</body>
</html>

■interface-document-1
<div id="example">
  <p id="＜p1＞" class="aaa bbb"/>
  <p id="＜p2＞" class="aaa ccc"/>
  <p id="＜p3＞" class="bbb ccc"/>
</div>


●●bp_examples
tree-order-1:[&nbsp;[&nbsp;]&nbsp;(ソースに)&nbsp;[&nbsp;(現れる)&nbsp;[&nbsp;(順序が)&nbsp;]&nbsp;[&nbsp;(そのまま)&nbsp;[&nbsp;(ツリー順序に)&nbsp;]&nbsp;]&nbsp;(なる)&nbsp;]&nbsp;]

bp-1:[|*|(|A)|[|[|B]|(|.|)|C(|.|.|)|[|(|.|)|]|[|]|(|.|.|)|[x|0(|.|)|1[|(|.|)|]|2[|(|.|.|.|)|[|(|.|)|]|]|3(|.|.|)|4]|]|(|.|.|)|]

bp-2:[|(|.|)|[|]|[y|(y|.|.|s)|]|[x|(x|.|)|]|(x|.|.|.|)|[x|]|(x|.|.|)|[y|(x|.|)|[x|(x|.|)|]|[y|(y|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]|]

bp-3:[|(|.|)|s[x|(|.|)|]|(x|.|.|)|[x|(|.|.|)|]|[y|[|(|.|)|]|(|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]

bp-4:[|(|.|)|[|(|.|)|S[y|s[|(|.|)|]|(|.|.|.|)|[|]|e]|E(|.|.|)|]|]

bp-5:[|[|]|[y|(y|s+|)|]|[x|(|.|)|]|[y|(x|.|)|[y|(y|+|+|e.|)|[|]|]|(|.|)|]|] → [|[|]|[y|(y|S)|]|X[y|[y|(y|E.|)|[|]|]|(|.|)|]|]

bp-6:[|[|]|[y|(|.|s)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|e.|)|[|]|]|(|.|)|]|] → [x|[y|(|S)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|E)|]|]|]

bp-7:[|(|.|)|s[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|e.|)|] → [|(|.|)|s[y|[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|)|]|e(|.|)|]

bp-8:[|[y|(|.|)|]|s[|(|.|.|)|e[y|(|.|.|)|]|]|]

●●ref_data
XPATH=副      ~/XML/xpath10-ja.html
CONSOLE=副    ~/console-ja.html

●●ref_key_map

●●ref_normative

[CONSOLE]
    Dominic Farolino; Robert Kowalski; Terin Stock. ＜Console Standard＞. Living Standard. URL: https://console.spec.whatwg.org/
[DEVICE-ORIENTATION]
    Reilly Grant; Marcos Caceres. ＜Device Orientation and Motion＞. URL: https://w3c.github.io/deviceorientation/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[LONG-ANIMATION-FRAMES]
    ＜Long Animation Frames API＞. Editor's Draft. URL: https://w3c.github.io/long-animation-frames/
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[SERVICE-WORKERS]
    Monica CHINTALA; Yoshisato Yanagisawa. ＜Service Workers Nightly＞. URL: https://w3c.github.io/ServiceWorker/
[TRUSTED-TYPES]
    Krzysztof Kotowicz. ＜Trusted Types＞. URL: https://w3c.github.io/trusted-types/dist/spec/
[TOUCH-EVENTS]
    Doug Schepers; et al. ＜Touch Events＞. URL: https://w3c.github.io/touch-events/
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. URL: https://w3c.github.io/uievents/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/
[XML-NAMES]
    Tim Bray; et al. ＜Namespaces in XML 1.0 (Third Edition)＞. 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/

●●ref_informative

[CSSOM-VIEW]
    Simon Fraser; Emilio Cobos Álvarez. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM-Level-3-XPath]
    Ray Whitmer. ＜Document Object Model (DOM) Level 3 XPath Specification＞. 3 November 2020. NOTE. URL: https://www.w3.org/TR/DOM-Level-3-XPath/
[DOM-Parsing]
    Travis Leithead. ＜DOM Parsing and Serialization＞. URL: https://w3c.github.io/DOM-Parsing/
[FULLSCREEN]
    Philip Jägenstedt. ＜Fullscreen API Standard＞. Living Standard. URL: https://fullscreen.spec.whatwg.org/
[INDEXEDDB]
    Nikunj Mehta; et al. ＜Indexed Database API＞. URL: https://w3c.github.io/IndexedDB/
[XPath]
    James Clark; Steven DeRose. ＜XML Path Language (XPath) Version 1.0＞. 16 November 1999. REC. URL: https://www.w3.org/TR/xpath-10/
[XSLT]
    James Clark. ＜XSL Transformations (XSLT) Version 1.0＞. 16 November 1999. REC. URL: https://www.w3.org/TR/xslt-10/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">DOM Standard</a>
仕様（通称 “DOM-LS”, “DOM4”, “DOM Core” ）を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/dom">GitHub whatwg/dom</a> (<a href="https://github.com/whatwg/dom/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/dom/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>
Commits:
	https://github.com/whatwg/dom/commits
	<a href="https://dom.spec.whatwg.org/commit-snapshots/606ca767dcdd91815b4ceeab4407c8e496fda59e/">Snapshot as of this commit</a>
	<a href="https://twitter.com/thedomstandard">@thedomstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/dom">web-platform-tests dom/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/dom">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）
	<a href="https://htmlspecs.com/dom/" hreflang="zh-hans" lang="zh-hans" rel="alternate">简体中文</a>
	<a href="https://ko.htmlspecs.com/dom/" hreflang="ko" lang="ko" rel="alternate">한국어</a>

</script>

</head>

<body>
<header>
<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiIHN0cm9rZS13aWR0aD0iMTAiIGZpbGw9IiNmZmYiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIvPgo8cGF0aCBkPSJtNTAsMjV2MTVsLTE1LDEwLTEwLDE1bTEwLTE1bDEwLDE1bTUtMjVsMTUsMTAsMTAsMTVtLTEwLTE1bC0xMCwxNSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>DOM</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
~DOMは、
~platformに中立的な，［
~event, ~promiseによる活動の中止-法, ~node~tree
］の~modelを定義する。
◎
DOM defines a platform-neutral model for events, aborting activities and node trees.
</p>

	</section>

<main id="MAIN0">

	<section id="infrastructure">
<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様の一部の用語は、
次に挙げる仕様にて定義される
⇒＃
`ENCODING$r,
`SELECTORS4$r,
`TRUSTED-TYPES$r,
`WEBIDL$r,
`XML$r,
`XML-NAMES$r
◎
Some of the terms used in this specification are defined in Encoding, Selectors, Trusted Types, Web IDL, XML, and Namespaces in XML. [ENCODING] [SELECTORS4] [TRUSTED-TYPES] [WEBIDL] [XML] [XML-NAMES]
</p>

<p>
拡張が必要になったときは、
それに則って~DOM標準が更新されるか，あるいは
`適用-可能な仕様@†
用に供される拡張用~hookを利用するような，新たな標準が書かれ得る。
◎
When extensions are needed, the DOM Standard can be updated accordingly, or a new standard can be written that hooks into the provided extensibility hooks for applicable specifications.
</p>

<p class="trans-note">【†
`HTML$r に定義される`同じ名前の用語＠~HTMLINFRA#other-applicable-specifications$と同様
— この仕様~自身も含まれる。
】</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
加えて，次に挙げる表記も利用される：
</p>
<ul>
	<li>
所与の［
順序付けられた一連の何か
］ %S 
— 例：［
`~tree$／`~list$／`有順序~集合$
］あるいは その一部
（例：ある条件を満たすものたち） —
に対し，その［
`最初のもの？@
／
`最後のもの？@
］は、［
%S は空である（例： 条件を満たすものが存在しない）ならば ~NULL ／
~ELSE_ その順序において %S の中で［
最初／最後
］に在るもの
］を返すとする。
<small >（
“最初” ／ “最後” がこの意味で用いられる所（ ~NULL にもなり得る所）では、
常に（ WebIDL 方式に倣って） "?" が付記される。
）</small>
</li>
</ul>

		</section>
		<section id="trees">
<h3 title="Trees">1.1. ~tree</h3>
<!-- Sorry reddit, this is not /r/trees -->

<p>
`~tree@
とは、
有限かつ階層的な~tree構造である。
`~tree順序@
は、
深優先前順な辿りに基づく。
◎
A tree is a finite hierarchical tree structure. In tree order is preorder, depth-first traversal of a tree.
</p>

<div class="trans-note" id="example-tree">
<p>【
`深さ優先＠https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2$,
`前順＠https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_%28%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%29#.E8.B5.B0.E6.9F.BB.E6.B3.95$
】：
この方式による~treeの辿りは、
~HTMLや~XML文書の~source~text表現における，要素の開始~tagや~text内容
（より一般には`文字~data~node$）
が現れる順序を表現する
（ゆえに， “文書~順序” と称されることもある）。
</p>

<p>
例えば、
次の~source
（単純にするため，（架空の） `e^e 要素と~text内容のみからなる）
から生成される~DOM~treeは：
</p>

`tree-order-1^xCode

<p>
次のような模式図として可視化できる：
</p>

`tree-order-1^dgm

<p>
図の左端が~sourceの先頭, 右端が末尾に対応する。
図の横線が，~treeの中の各~nodeとそれが~source内を占める~~範囲
（要素の開始~tag〜終了~tag ／ 文字~dataの先頭〜末尾）
を表し、
それらの上下関係が~treeの階層（~nodeの入子ng階層）を表す。
図の中の各~文字は文字~dataの各~文字に対応し，それらが成す各~COLOR_Rが`文字~data~node$が占める~~範囲を表す。
~nodeの順序はこれらの横線の左端の位置から決定される。
最上層の横線がこの~treeの根~node（根元）を表し，この順序における先頭になる。
</p>
</div>

<p>
`~tree$に
`関与-@
（ `participate^en ）している各~objは、
次に挙げるものを有する：
◎
An object that participates in a tree＼
</p>
<ul>
	<li>
`親@
（ `parent^en ）
⇒
~NULL／
ある~obj
◎
has a parent, which is either null or an object,＼
</li>
	<li>
`子~群@
（ `children^en ）
⇒
~objたちが成す`有順序~集合$
◎
and has children, which is an ordered set of objects.＼
</li>
</ul>

<p class="trans-note">【
`~tree順序$を定義するものは、
これら
— 親に基づく階層, 子~群における順序 —
に他ならない。
（原文には，`子~群$を反復する順序として`~tree順序$を指定する箇所が多々あるが、
それは冗長な記述になる
— この訳では、
そのような箇所における “~tree順序” を省略する。）
】</p>

<p>
~obj %A の`親$ %B ~NEQ ~NULL ならば、
%A は %B の`子$である。
◎
An object A whose parent is object B is a child of B.
</p>

<p class="trans-note">【
%A は %B の “子である” という句は、［
%A ~IN %B の`子~群$
］を満たすことをいう。
】【
%B には “子が在る” の様な句は、［
%B の`子~群$は`空$でない
］ことをいう。
】【
同じ~objが同時に複数の~objの子になることはない。
】</p>

<p>
~obj %A の
`根@
（ `root^en ）とは、［
%A の`親$ ~EQ ~NULL
］ならば %A であり，他の場合は %A の`親$の`根$である。
`~tree$の`根$は、
その`~tree$に`関与-$している~objであって，［
`親$ ~EQ ~NULL
］を満たすものである。
◎
The root of an object is itself, if its parent is null, or else it is the root of its parent. The root of a tree is any object participating in that tree whose parent is null.
</p>

<p class="trans-note">【
この定義は、
`親$を順々に辿った結果は循環しない（自身には戻らない）ことも含意している。
同様に，`子$を順々に辿った結果も循環しない。
】</p>

<p>
~obj %A が~obj %B の
`子孫@
（ `descendant^en ）であるとは、
次が満たされることをいう
⇒
［
%A は %B の`子$である
］~OR［
%A は %B のある`子孫$の`子$である
］
◎
An object A is called a descendant of an object B, if either A is a child of B or A is a child of an object C that is a descendant of B.
</p>

<p class="trans-note">【
上述したように循環しないので、
%A 自身が %A の`子孫$になることはない。
】</p>

<p>
~obj %A が~obj %B の
`広義-子孫@
（ `inclusive descendant^en ）であるとは、
次が満たされることをいう
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`子孫$である
］
◎
An inclusive descendant is an object or one of its descendants.
</p>

<p class="trans-note">【
<small>
“~~広義” という対訳は，よいとは言えないが、
より忠実に “自身も含めた子孫” などと訳すのでは，用語として定義する意義
— 他から簡潔に参照できるようにする —
も失われる（単に “自身または子孫” と記すのと同じことになる）。
</small>
】</p>

<p>
~obj %A が~obj %B の
`先祖@
（ `ancestor^en ）であるとは、
次が満たされることをいう
⇒
%B は %A の`子孫$である
◎
An object A is called an ancestor of an object B if and only if B is a descendant of A.
</p>

<p>
~obj %A が~obj %B の
`広義-先祖@
（ `inclusive ancestor^en ）であるとは、
次が満たされることをいう
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`先祖$である
］
◎
An inclusive ancestor is an object or one of its ancestors.
</p>

<p>
~obj %A が~obj %B の
`同胞@
（ `sibling^en ）であるとは、
次が満たされることをいう
⇒
［
%A の`親$ ~NEQ ~NULL
］~AND［
%A の`親$ ~EQ %B の`親$
］
◎
An object A is called a sibling of an object B, if and only if B and A share the same non-null parent.
</p>

<p class="trans-note">【
定義により， %A 自身も
`親が ~NULL でない^emならば %A の`同胞$になる。
この仕様の中では、
この点について特に注意を要する箇所は（現時点では）ないが。
例えば、
この同胞の定義を
“%A と %B は同じでない”
と解釈したとしても，この仕様の残りの部分には影響しない。
】【
<small>
“兄弟” と訳されることが多いが、
対訳として “同胞” を選んだ理由は，`包括的（中立的）な文言が選好される＠~DESIGN-PRINCIPLES#naming-inclusive$からである。
</small>
】</p>

<p>
~obj %A が~obj %B の
`広義-同胞@
（ `inclusive sibling^en ）であるとは、
次が満たされることをいう
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`同胞$である
］
◎
An inclusive sibling is an object or one of its siblings.
</p>

<p class="trans-note">【
%A 自身は，親が~NULLであっても %A の広義-同胞になる点で、
`同胞$の定義と異なる。
この定義は、
もっぱら他の仕様~用にあり，この仕様~内では利用されない。
】</p>
【！ ~DOMissue/55 】

<p>
~obj %A が~obj %B に
`先行-@
（ `precede^en ）するとは、
次が満たされることをいう
⇒
［
%A と %B は同じ`~tree$に関与する
］~AND［
`~tree順序$において %A は %B より前に在る
］
◎
An object A is preceding an object B if A and B are in the same tree and A comes before B in tree order.
</p>

<p>
~obj %A が~obj %B に
`後続-@
（ `follow^en ）するとは、
次が満たされることをいう
⇒
［
%A と %B は同じ`~tree$に関与する
］~AND［
`~tree順序$において %A は %B より後に在る
］
◎
An object A is following an object B if A and B are in the same tree and A comes after B in tree order.
</p>

<p>
~obj %A の
`最初の子？@
（ `first child^en ）とは、
%A の`子$のうち，`最初のもの？$である。
◎
The first child of an object is its first child or null if it has no children.
</p>

<p>
~obj %A の
`最後の子？@
（ `last child^en ）とは、
%A の`子$のうち，`最後のもの？$である。
◎
The last child of an object is its last child or null if it has no children.
</p>

<p>
~obj %A の
`直前の同胞？@
（ `previous sibling^en ）とは、
%A に`先行-$する`同胞$のうち，`最後のもの？$である。
◎
The previous sibling of an object is its first preceding sibling or null if it has no preceding sibling.
</p>

<p>
~obj %A の
`直後の同胞？@
（ `next sibling^en ）とは、
%A に`後続-$する`同胞$のうち，`最初のもの？$である。
◎
The next sibling of an object is its first following sibling or null if it has no following sibling.
</p>

<p>
~obj %A の
`~index@
とは、
%A に`先行-$する`同胞$の個数である
（無いならば 0 になる）。
◎
The index of an object is its number of preceding siblings, or 0 if it has none.
</p>

<p class="trans-note">【
%A の`親$ ~NEQ ~NULL ならば、［
%A ~EQ  %A の`親$の`子~群$[ %A の`~index$ ]
］が満たされることになる。
】</p>

		</section>
		<section id="ordered-sets">
<h3 title="Ordered sets">1.2. 有順序~集合</h3>

<div class="algo">
<p>
`有順序~集合として構文解析する@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
The ordered set parser takes a string input and then runs these steps:
</p>
<ol>
	<li>
%入力~token群 ~LET `~ASCII空白で分割する$( %入力 )
◎
Let inputTokens be the result of splitting input on ASCII whitespace.
</li>
	<li>
%~token群 ~LET 新たな`有順序~集合$
◎
Let tokens be a new ordered set.
</li>
	<li>
%入力~token群 を成す
~EACH( %~token )
に対し
⇒
%~token群 に %~token を`付加する$set
◎
For each token of inputTokens: append token to tokens.
</li>
	<li>
~RET %~token群
◎
Return tokens.
</li>
</ol>
</div>

<div class="algo">
<p>
`有順序~集合を直列化する@
~algoは、
所与の
( 文字列たちが成す`有順序~集合$ %集合 )
に対し
⇒
~RET %集合 を `0020^U `SPACE^cn で`連結する$
◎
The ordered set serializer takes a set and returns the concatenation of set using U+0020 SPACE.
</p>
</div>

		</section>
		<section id="selectors">
<h3 title="Selectors">1.3. 選択子</h3>

<div class="algo">
<p>
`~nodeの視野の下で選択子を照合する@
~algoは、
所与の
( 文字列 %選択子~文字列, `~node$ %~node )
に対し：
◎
To scope-match a selectors string given a string selectors against a node node:
</p>
<ol>
	<li>
%選択子 ~LET `選択子として構文解析する$( %選択子~文字列 )
`SELECTORS4$r
◎
Let selector be the result of parse a selector selectors. [SELECTORS4]
</li>
	<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If selector is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET `~treeに対し選択子を照合する$ `SELECTORS4$r
— 次を与える下で
⇒＃
`選択子^i ~SET %選択子,
`根~要素~群^i ~SET { %~node の`根$ },
`視野ng根~群^i ~SET { %~node }
◎
Return the result of match a selector against a tree with selector and node’s root using scoping root node. [SELECTORS4].
</li>
</ol>

<p class="note">注記：
選択子の中の~ns用の~supportは、
計画されておらず，追加されることはない。
◎
Support for namespaces within selectors is not planned and will not be added.
</p>
</div>

		</section>
		<section id="namespaces">
<h3 title="Name validation">1.4. 名前~検証</h3>

<p>
所与の`文字列$が
`妥当な~ns接頭辞@
であるとは、
~AND↓ を満たすことをいう：
◎
A string is a valid namespace prefix if＼
</p>
<ul>
	<li>
その`長さ$str ~GTE 1
◎
its length is at least 1＼
</li>
	<li>
それを成す各`符号位置$は次に挙げるものでない
⇒＃
`~ASCII空白$,
`0000^U `NULL^cn,
`002F^U `/^smb,
`003E^U `&gt;^smb
◎
and it does not contain ASCII whitespace, U+0000 NULL, U+002F (/), or U+003E (&gt;).
</li>
</ul>

<p>
所与の`文字列$が
`妥当な属性~局所~名@
であるとは、
~AND↓ を満たすことをいう：
◎
A string is a valid attribute local name if＼
</p>
<ul>
	<li>
その`長さ$str ~GTE 1
◎
its length is at least 1＼
</li>
	<li>
それを成す各`符号位置$は次に挙げるものでない
⇒＃
`~ASCII空白$,
`0000^U `NULL^cn,
`002F^U `/^smb,
`003D^U `=^smb,
`003E^U `&gt;^smb
◎
and it does not contain ASCII whitespace, U+0000 NULL, U+002F (/), U+003D (=), or U+003E (&gt;).
</li>
</ul>

<p>
所与の`文字列$が
`妥当な要素~局所~名@
であるとは、
~AND↓ を満たすことをいう：
◎
A string name is a valid element local name if the following steps return true:
</p>
<ul>
	<li>
その`長さ$str ~GTE 1
◎
If name’s length is 0, then return false.
</li>
	<li>
<p>
~OR↓：
</p>
		<ul>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
それを成す 0 番の`符号位置$は`~ASCII英字$である
</li>
					<li>
それを成す各`符号位置$は次に挙げるものでない
⇒＃
`~ASCII空白$,
`0000^U `NULL^cn,
`002F^U `/^smb,
`003E^U `&gt;^smb
</li>
				</ul>
◎
If name’s 0th code point is an ASCII alpha, then:
• If name contains ASCII whitespace, U+0000 NULL, U+002F (/), or U+003E (&gt;), then return false.
• Return true.
</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
それを成す 0 番の`符号位置$は次に挙げるいずれかである
⇒＃
`003A^U `:^smb,
`005F^U `_^smb,
{ `0080^U 〜 `10FFFF^U }
</li>
					<li>
それを成す各`符号位置$は次に挙げるいずれかである
⇒＃
`~ASCII英字$,
`~ASCII数字$,
`002D^U `-^smb,
`002E^U `.^smb,
前項に挙げたもの
</li>
				</ul>
◎
If name’s 0th code point is not U+003A (:), U+005F (_), or in the range U+0080 to U+10FFFF, inclusive, then return false.
◎
If name’s subsequent code points, if any, are not ASCII alphas, ASCII digits, U+002D (-), U+002E (.), U+003A (:), U+005F (_), or in the range U+0080 to U+10FFFF, inclusive, then return false.
◎
Return true.
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
この概念は、
`要素$の`局所~名$elが~DOM~APIにより構築されるときに，それを検証するために利用される。
その意図nは、［
~HTML構文解析器を利用して構築することがアリな名前
（ “0 番の`符号位置$は`~ASCII英字$…” に該当するもの）
］および［
いくつか追加的にアリなもの
］を許容することにある。
追加的にアリなものに対しては、
~ASCII範囲は歴史的な理由により制約されるが，その範囲を超えるものは許容される。
◎
This concept is used to validate element local names, when constructed by DOM APIs. The intention is to allow any name that is possible to construct using the HTML parser (the branch where the first code point is an ASCII alpha), plus some additional possibilities. For those additional possibilities, the ASCII range is restricted for historical reasons, but beyond ASCII anything is allowed.
</p>

<div class="note">
<p>注記：
~JSに互換な次の正規表現は、
`妥当な要素~局所~名$の実装を成す：
◎
The following JavaScript-compatible regular expression is an implementation of valid element local name:
</p>

<pre class="lang-js">
/^(?:[A-Za-z][^\0\t\n\f\r\u0020/&gt;]*|[:_\u0080-\u{10FFFF}][A-Za-z0-9-.:_\u0080-\u{10FFFF}]*)$/u
</pre>
</div>

<p>
所与の`文字列$が
`妥当な~doctype名@
であるとは、［
それを成す各`符号位置$は次に挙げるものでない
］ことをいう
⇒＃
`~ASCII空白$,
`0000^U `NULL^cn,
`003E^U `&gt;^smb
◎
A string is a valid doctype name if it does not contain ASCII whitespace, U+0000 NULL, or U+003E (&gt;).
</p>

<p class="note">注記：
空~文字列は`妥当な~doctype名$である。
◎
The empty string is a valid doctype name.
</p>

<div class="algo">
<p>
`~nsと名前を検証して抽出する@
~algoは、
所与の
( %~ns, %名前, %文脈 【 ~IN { `属性^i, `要素^i } 】)
に対し：
◎
To validate and extract a namespace and qualifiedName, given a context:
</p>
<ol>
	<li id="cp-normalize-ns">
~IF［
%~ns ~EQ 空~文字列
］
⇒
%~ns ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>
	<li>
%接頭辞 ~LET ~NULL
◎
Let prefix be null.
</li>
	<li>
%局所~名 ~LET %名前
◎
Let localName be qualifiedName.
</li>
	<li>
<p>
~IF［
%名前 は `003A^U `:^smb を包含する
］：
◎
If qualifiedName contains a U+003A (:):
</p>
		<ol>
			<li>
%分割-結果 ~LET `区切子で厳密に分割する$( %名前, `003A^U `:^smb )
◎
Let splitResult be the result of running strictly split given qualifiedName and U+003A (:).
</li>
			<li>
%接頭辞 ~SET %分割-結果[ 0 ]
◎
Set prefix to splitResult[0].
</li>
			<li>
%局所~名 ~SET %分割-結果[ 1 ]
◎
Set localName to splitResult[1].
</li>
			<li>
~IF［
%接頭辞 は`妥当な~ns接頭辞$でない
］
⇒
~THROW `InvalidCharacterError$E
◎
If prefix is not a valid namespace prefix, then throw an "InvalidCharacterError" DOMException.
</li>
		</ol>
<p class="trans-note">【
複数個の `003A^U `:^smb がある場合、
%分割-結果 を成す 3 個目以降の~itemは無視されることになる。
】</p>
	</li>
	<li>
~Assert：
［
%接頭辞 ~EQ ~NULL
］~OR［
%接頭辞 は`妥当な~ns接頭辞$である
］
◎
Assert: prefix is either null or a valid namespace prefix.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%文脈 ~EQ `属性^i
］~AND［
%局所~名 は`妥当な属性~局所~名$でない
］
</li>
			<li>
［
%文脈 ~EQ `要素^i
］~AND［
%局所~名 は`妥当な要素~局所~名$でない
］
</li>
		</ul>
<p>
…ならば
⇒
~THROW `InvalidCharacterError$E
</p>
◎
If context is "attribute" and localName is not a valid attribute local name, then throw an "InvalidCharacterError" DOMException.
◎
If context is "element" and localName is not a valid element local name, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%~ns ~EQ ~NULL
］~AND［
%接頭辞 ~NEQ ~NULL
］
</li>
			<li>
［
%~ns ~NEQ `~XML~ns$
］~AND［
%接頭辞 ~EQ `xml^l
］
</li>
			<li>
［
%~ns ~NEQ `~XMLNS~ns$
］~AND［［
%名前 ~EQ `xmlns^l
］~OR［
%接頭辞 ~EQ `xmlns^l
］］
</li>
			<li>
［
%~ns ~EQ `~XMLNS~ns$
］~AND［
%名前 ~NEQ `xmlns^l
］~AND［
%接頭辞 ~NEQ `xmlns^l
］
</li>
		</ul>
<p>
…ならば
⇒
~THROW `NamespaceError$E
</p>
◎
If prefix is non-null and namespace is null, then throw a "NamespaceError" DOMException.
◎
If prefix is "xml" and namespace is not the XML namespace, then throw a "NamespaceError" DOMException.
◎
If either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace, then throw a "NamespaceError" DOMException.
◎
If namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns", then throw a "NamespaceError" DOMException.
</li>
	<li>
~RET ( %~ns, %接頭辞, %局所~名 )
◎
Return (namespace, prefix, localName).
</li>
</ol>
</div>

<div class="note">
<p>注記：
この仕様における様々な~APIは、［
~ns接頭辞,
属性oの`局所~名$a,
要素の`局所~名$el,
~doctypeの`名前$dT
］を もっと厳密に
— ~XMLに関係する様々な仕様に倣う仕方で —
検証していた
（それらの仕様からの規則~すべてを施行してはいなかったが）。
◎
Various APIs in this specification used to validate namespace prefixes, attribute local names, element local names, and doctype names more strictly. This was done in a way that aligned with various XML-related specifications. (Although not all rules from the those specifications were enforced.)
</p>

<p>
このことは、
~web開発者にとって煩わしいものと見出された
— とりわけ、［
~HTML構文解析器により作成され得るが~DOM~APIにより作成され得ない名前
］も在ることを意味していたので。
なので、
検証は，上で述べたものだけになるよう緩められた。
◎
This was found to be annoying for web developers, especially since it meant there were some names that could be created by the HTML parser, but not by DOM APIs. So, the validations have been loosened to just those described above.
</p>
</div>

		</section>
	</section>
	<section id="events">
<h2 title="Events">2. ~event</h2>

		<section id="introduction-to-dom-events">
<h3 title="Introduction to “DOM Events”">2.1. “DOM Events” 序論</h3>

<!-- ^@EventTarget -->

<p>
~web~platformを全体を通して、
`~event$は
— 何かが生じたことを通達するために —
~objに向けて`配送-$される
— ~network活動や利用者-ヤリトリなど。
これらの~objは $EventTarget ~interfaceを実装し，
その $addEventListener() を~callすることにより
`~event$を観測するための`~event~listener$を追加できる：
◎
Throughout the web platform events are dispatched to objects to signal an occurrence, such as network activity or user interaction. These objects implement the EventTarget interface and can therefore add event listeners to observe events by calling addEventListener():
</p>

<div class="example">
<pre class="lang-js">
%obj.addEventListener("load", imgFetched)

function imgFetched(%ev) {
  /* <span class="comment">
成功裡に load できた
◎
great success
</span> */
  …
}
</pre>
</div>

<p>
`~event~listener$は、
次のいずれかにより除去できる：
◎
↓</p>
<ul>
	<li>
$removeEventListener() ~methodに $addEventListener() と同じ引数たちを渡すことにより。
◎
Event listeners can be removed by utilizing the removeEventListener() method, passing the same arguments.
</li>
	<li>
$addEventListener() に［
ある $@AbortController %controller の`通達$aC【！$AbortSignal】
］を渡して，
%controller の $abort() を~callすることにより。
◎
Alternatively, event listeners can be removed by passing an AbortSignal to addEventListener() and calling abort() on the controller owning the signal.
</li>
</ul>

<!-- ^@Event -->

<p>
`~event$もまた~objであり，
$Event ~interface（またはその派生d~interface）を実装する。
上の例では、
%ev が`~event$である。
%ev は、
`~event~listener$の`~callback$evL
（概して上に示したような~JS Function ）
に引数として渡される。
`~event~listener$は、
まず，`~event$の $type 属性~値（上の例では `load^l ）をその~~制御に利用する。
`~event$の $target 属性~値は`~event$の`配送-$先の~obj（上の例の %obj ）を返す。
◎
Events are objects too and implement the Event interface (or a derived interface). In the example above ev is the event. ev is passed as an argument to the event listener’s callback (typically a JavaScript Function as shown above). Event listeners key off the event’s type attribute value ("load" in the above example). The event’s target attribute value returns the object to which the event was dispatched (obj above).
</p>

<p id="synthetic-events">
`~event$は、
概して，利用者-ヤリトリや何らかの~task完了の結果，~UAにより`配送-$されるが、
~app自身も，合成な~eventと共通的に称されるものを利用して`~event$を`配送-$できる：
◎
Although events are typically dispatched by the user agent as the result of user interaction or the completion of some task, applications can dispatch events themselves by using what are commonly known as synthetic events:
</p>

<div class="example">
<pre class="lang-js">
/* <span class="comment">
~custom~event~listenerを追加する
◎
add an appropriate event listener
</span> */
obj.addEventListener("cat", function(%e) { process(%e.detail) })

/* <span class="comment">
~eventを作成して配送する
◎
create and dispatch the event
</span> */
var %event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
%obj.dispatchEvent(%event)</pre></div>

<p>
通達-時の他にも、
`~event$は，演算の中で次に起きる出来事を~appに制御させる~~目的で利用されることがある。
例えば，~form提出の一環として、
$type 属性が `submit^l にされた`~event$が`配送-$される。
この`~event$の $preventDefault() ~methodが呼出されると，~formは提出されずに終了されることになる。
~appにより`配送-$される`~event$（合成な~event）を通して，この機能性を利用する場合、
$EventTarget.dispatchEvent() ~methodの返り値も利用できる：
◎
Apart from signaling, events are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an event whose type attribute value is "submit" is dispatched. If this event’s preventDefault() method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through events dispatched by the application (synthetic events) can make use of the return value of the dispatchEvent() method:
</p>

<div class="example">

<pre class="lang-js">
if(%obj.dispatchEvent(%event)) {
  /* <span class="comment">
~eventは取消されなかった。手品の時間だ。
◎
event was not canceled, time for some magic
</span> */
  …
}
</pre>
</div>

<p>
`~event$が`~tree$に`関与-$している~obj（例えば`要素$）に向けて`配送-$される場合、
その~eventは，その~objの`先祖$の`~event~listener$にも到達し得る：
◎
When an event is dispatched to an object that participates in a tree (e.g., an element), it can reach event listeners on that object’s ancestors too.＼
</p>
<ol>
	<li>
まず、
~objの各 `広義-先祖$に対し，`~tree順序$で
⇒
その`~event~listener$†のうち［
`捕捉するか$evL ~EQ ~T
］を満たすものが呼出される
◎
Effectively, all the object’s inclusive ancestor event listeners whose capture is true are invoked, in tree order.＼
</li>
	<li>
次に，［
`~event$の $bubbles ~EQ ~T
］ならば、
~objの各 `広義-先祖$に対し，今度は`~tree順序$の逆順で
⇒
その`~event~listener$†のうち［
`捕捉するか$evL ~EQ ~F
］を満たすものが呼出される
◎
And then, if event’s bubbles is true, all the object’s inclusive ancestor event listeners whose capture is false are invoked, now in reverse tree order.
</li>
</ol>

<p class="trans-note">【†
当の広義-先祖の`~event~listener~list$内の`~event~listener$のうち，その`型$evLは `~event$の $type に合致するもの。
該当する~event~listenerが呼出される順序は、
この~listが管理する。
】</p>

<div class="example">
<p>
`~event$が`~tree$内で働く様子を例で示す：
◎
Let’s look at an example of how events work in a tree:
</p>

`event-1^xCode

<p>
`debug^c 関数（ A ）は 2 回~呼出されることになる。
2 回とも、
`~event$の $target 属性~値は <mark>`span^c `要素$</mark> になる。
1 回目での $currentTarget 属性~値は`文書$になり（ B ）,
$eventPhase 属性の値が $CAPTURING_PHASE から $BUBBLING_PHASE に切り替わった後,
2 回目では `body^e `要素$になる（ C ）。
もし`~event~listener$が `span^e `要素$にも登録されていたなら、
$eventPhase 属性の値は $AT_TARGET にも切り替わることになる。
◎
The debug function will be invoked twice. Each time the event’s target attribute value will be the span element. The first time currentTarget attribute’s value will be the document, the second time the body element. eventPhase attribute’s value switches from CAPTURING_PHASE to BUBBLING_PHASE. If an event listener was registered for the span element, eventPhase attribute’s value would have been AT_TARGET.
</p>
</div>

		</section>
		<section id="interface-event">
<h3 title="Interface Event">2.2. ^@Event ~interface</h3>

！！
[`Exposed$=*]
interface @Event {
  `Event$mc($DOMString %type, optional $EventInit %eventInitDict = {});

  readonly attribute $DOMString $type;
  readonly attribute $EventTarget? $target;
  readonly attribute $EventTarget? $srcElement; // <span id="cp-legacy" class="comment" title="legacy">旧来</span>
  readonly attribute $EventTarget? $currentTarget;
  $sequence&lt;$EventTarget&gt; $composedPath();

  const `unsigned short$ $NONE = 0;
  const `unsigned short$ $CAPTURING_PHASE = 1;
  const `unsigned short$ $AT_TARGET = 2;
  const `unsigned short$ $BUBBLING_PHASE = 3;
  readonly attribute `unsigned short$ $eventPhase;

  $undefined $stopPropagation();
           attribute $boolean $cancelBubble; // <span class="comment" title="legacy alias of .stopPropagation()">`stopPropagation()^c の旧来の別名</span>
  $undefined $stopImmediatePropagation();

  readonly attribute $boolean $bubbles;
  readonly attribute $boolean $cancelable;
           attribute $boolean $returnValue;  // <!--cp-legacy-->
  $undefined $preventDefault();
  readonly attribute $boolean $defaultPrevented;
  readonly attribute $boolean $composed;

  [`LegacyUnforgeable$] readonly attribute $boolean $isTrusted;
  readonly attribute $DOMHighResTimeStamp $timeStamp;

  $undefined $initEvent($DOMString %type, optional $boolean %bubbles = false, optional $boolean %cancelable = false); // <!--cp-legacy-->
};

dictionary @EventInit {
  $boolean @EventInit.bubbles = false;
  $boolean @EventInit.cancelable = false;
  $boolean @EventInit.composed = false;
};
！

<p>
$Event ~objは、
単に
`~event@
とも称される。
それは、
何かが生じたとき，それを通達できるようにする
— 例えば、
画像の~downloadが完了したときなど。
◎
An Event object is simply named an event. It allows for signaling that something has occurred, e.g., that an image has completed downloading.
</p>

<p>
`~event~targetになり得るもの@
は、［
~NULL ／ $EventTarget ~obj
］である。
◎
A potential event target is null or an EventTarget object.
</p>

<p>
各`~event$には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`~target@
⇒
`~event~targetになり得るもの$
— 他が言明されない限り， ~NULL とする。
◎
An event has an associated target (a potential event target). Unless stated otherwise it is null.
</li>
	<li>
<p>
`関係する~target@
⇒
`~event~targetになり得るもの$
— 他が言明されない限り， ~NULL とする。
◎
An event has an associated relatedTarget (a potential event target). Unless stated otherwise it is null.
</p>

<p class="note">注記：
他の仕様は ^relatedTarget 属性を定義するときに `関係する~target$を利用する。
`UIEVENTS$r
◎
Other specifications use relatedTarget to define a relatedTarget attribute. [UIEVENTS]
</p>
	</li>
	<li>
<p>
`~touch~target~list@
⇒
`~event~targetになり得るもの$たちが成す`~list$
— 他が言明されない限り，`空$とする。
◎
An event has an associated touch target list (a list of zero or more potential event targets). Unless stated otherwise it is the empty list.
</p>

<p class="note">注記：
`~touch~target~list$は、
もっぱら
$TouchEvent ~interfaceとそれに関係する~interfaceを定義するために利用される。
`TOUCH-EVENTS$r
◎
The touch target list is for the exclusive use of defining the TouchEvent interface and related interfaces. [TOUCH-EVENTS]
</p>
	</li>
	<li>
<p>
`経路@
⇒
`~list$
— 初期~時は`空$とする。
</p>

<p>
`経路$を成す各`~item$は、
次に挙げるものからなる`構造体$である：
</p>
		<ul>
			<li>
`呼出n~target@evP
⇒
$EventTarget ~obj
</li>
			<li>
`呼出n~targetは~shadow~tree内か@evP
⇒
真偽値
</li>
			<li>
`~shadow調整-済み~target@evP
⇒
`~event~targetになり得るもの$
</li>
			<li>
`関係する~target@evP
⇒
`~event~targetになり得るもの$
</li>
			<li>
`~touch~target~list@evP
⇒
`~event~targetになり得るもの$たちが成す`~list$
</li>
			<li>
`閉な~treeの根か@evP
⇒
真偽値
</li>
			<li>
`~slotは閉な~tree内か@evP
⇒
真偽値
</li>
		</ul>

◎
An event has an associated path.＼
A path is a list of structs. Each struct consists of＼
an invocation target (an EventTarget object),＼
an invocation-target-in-shadow-tree (a boolean),＼
a shadow-adjusted target (a potential event target),＼
a relatedTarget (a potential event target),＼
a touch target list (a list of potential event targets),＼
a root-of-closed-tree (a boolean),＼
and a slot-in-closed-tree (a boolean).＼
A path is initially the empty list.
</li>
</ul>

<dl class="domintro">
	<dt>%event = $Event(type [, eventInitDict])</dt>
	<dd>
$type 属性~値が %type にされた，新たな %event を返す。
%eventInitDict 引数により，［
$bubbles ／ $cancelable
］属性も
— 同じ名前の~obj~memberを介して —
設定できる。
◎
Returns a new event whose type attribute value is set to type. The eventInitDict argument allows for setting the bubbles and cancelable attributes via object members of the same name.
</dd>

	<dt>%event . $type</dt>
	<dd>
%event の型を返す。
例えば
`click^l,
`hashchange^l,
`submit^l
など。
◎
Returns the type of event, e.g. "click", "hashchange", or "submit".
</dd>

	<dt>%event . $target</dt>
	<dd>
%event の`配送-$先の~obj（ %event の`~target$ ）を返す。
◎
Returns the object to which event is dispatched (its target).
</dd>

	<dt>%event . $currentTarget</dt>
	<dd>
現在~呼出されている`~callback$evLを有する`~event~listener$が登録されている~objを返す。
◎
Returns the object whose event listener’s callback is currently being invoked.
</dd>

	<dt>%event . $composedPath()</dt>
	<dd>
%event の`経路$内に在る`呼出n~target$evP（それ上で~listenerが呼出される~obj）たちが成す~listを返す
— ただし、［
`~shadow根$の`~mode$sR ~EQ `closed^l
］なる`~shadow~tree$内の`~node$であって， %event の $currentTarget からは到達できないものは、
返り値から除かれる。
◎
Returns the invocation target objects of event’s path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root’s mode is "closed" that are not reachable from event’s currentTarget.
</dd>

	<dt>%event . $eventPhase</dt>
	<dd>
`~event$の相
— 次のいずれかを返す
⇒＃
$NONE,
$CAPTURING_PHASE,
$AT_TARGET,
$BUBBLING_PHASE
◎
Returns the event’s phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.
</dd>

	<dt>%event . $stopPropagation()</dt>
	<dd>
`~tree$ 内に`配送-$されているとき、
この~methodを呼出すことにより，現在の~obj以外の~objには %event が到達しないようになる。
◎
When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.
</dd>

	<dt>%event . $stopImmediatePropagation()</dt>
	<dd>
この~methodを呼出すことにより、
%event は 現在の~listenerを走り終えた後に［
それまでに登録された`~event~listener$
］には到達しなくなり、
`~tree$ 内に`配送-$されたときには， %event は他のどの~objにも到達しなくなる。
◎
Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.
</dd>

	<dt>%event . $bubbles</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
%event がその`~target$の`先祖$へ`~tree順序$の逆順にも遡る場合は ~T を返す／
他の場合は~F を返す。
◎
Returns true or false depending on how event was initialized. True if event goes through its target’s ancestors in reverse tree order; otherwise false.
</dd>

	<dt>%event . $cancelable</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か ~F を返す。
その返り値は常に意味を運ぶとは限らないが、
~T の場合，［
%event が`配送-$されている間の演算
］は［
$preventDefault() ~methodを呼出すことにより取消せる
］ことを指示し得る。
◎
Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.
</dd>

	<dt>%event . $preventDefault()</dt>
	<dd>
%event の $cancelable 属性~値が ~T にされた下で，［
$AddEventListenerOptions.passive が ~F に設定された %event
］用の~listenerの実行-中に呼出された場合、
%event が取消される必要がある旨をその`配送-$ 演算に通達する。
◎
If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.
</dd>

	<dt>%event . $defaultPrevented</dt>
	<dd>
~T は、
$preventDefault() が呼出され, 成功裡に取消されたことを指示する。
他の場合は ~F を返す。
◎
Returns true if preventDefault() was invoked successfully to indicate cancelation; otherwise false.
</dd>

	<dt>%event . $composed</dt>
	<dd>
%event がどう初期化されたかに依存して［
~T ／ ~F
］を返す。
［
%event の`~target$の`根$が $ShadowRoot `~node$である
］ときに，［
その~nodeを過ぎた先†に在る~listenerも呼出す場合は ~T ／
他の場合は ~F
］になる。
◎
Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target; otherwise false.
</dd>
	<dd class="trans-note">【†
%~event の`経路$が、
`~shadow根$の`~host$を通して別の`~node~tree$へつながるように，構成される。
】</dd>

	<dt>%event . $isTrusted</dt>
	<dd>
%event は~UAから`配送-$されたもの［
であるならば ~T ／
でないならば ~F
］を返す。
◎
Returns true if event was dispatched by the user agent, and false otherwise.
</dd>

	<dt>%event . $timeStamp</dt>
	<dd>
%event の時刻印を［
`the occurrence^en 【`時刻~起点$enV】から相対的に測定した~milli秒数
］として返す。
◎
Returns the event’s timestamp as the number of milliseconds measured relative to the occurrence.
</dd>
</dl>

<div class="algo">
<p>
@type
取得子~手続きは、
初期化-時の値を返す。
`~event$の作成-時には、
この属性は空~文字列に初期化するモノトスル。
◎
The type attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>
</div>

<div class="algo">
@target
取得子~手続きは
⇒
~RET コレの`~target$
◎
The target getter steps are to return this’s target.
</div>

<div class="algo">
@srcElement
取得子~手続きは
⇒
~RET コレの`~target$
◎
The srcElement getter steps are to return this’s target.
</div>

<div class="algo">
<p>
@currentTarget
取得子~手続きは、
初期化-時の値を返す。
◎
The currentTarget attribute must return the value it was initialized to.＼
</p>

<p>
`~event$の作成-時には、
この属性は ~NULL に初期化するモノトスル。
◎
When an event is created the attribute must be initialized to null.
</div>

<div class="algo">
<p>
@composedPath()
~method手続きは：
◎
The composedPath() method steps are:
</p>
		<ol>
			<li>
%~composed経路 ~LET « »
◎
Let composedPath be an empty list.
</li>
			<li>
%経路 ~LET コレの`経路$
◎
Let path be this’s path.
</li>
			<li>
~IF［
%経路 は`空$である
］
⇒
~RET %~composed経路
◎
If path is empty, then return composedPath.
</li>
			<li>
%現-~target ~LET コレの $currentTarget 属性~値
◎
Let currentTarget be this’s currentTarget attribute value.
</li>
			<li>
~Assert：
%現-~target は $EventTarget ~objである。
◎
Assert: currentTarget is an EventTarget object.
</li>
			<li>
%~composed経路 に %現-~target を`付加する$
◎
Append currentTarget to composedPath.
</li>
			<li>
%現-~target~index ~LET 0
◎
Let currentTargetIndex be 0.
</li>
			<li>
%現-~targetの非可視~下位tree~level ~LET 0
◎
Let currentTargetHiddenSubtreeLevel be 0.
</li>
			<li>
%~index ~LET %経路 の`~size$ − 1
◎
Let index be path’s size − 1.
</li>
			<li>
<p>
~WHILE［
%~index ~GTE 0
］：
◎
While index is greater than or equal to 0:
</p>
				<ol>
					<li>
~IF［
%経路[ %~index ] の`閉な~treeの根か$evP ~EQ ~T
］
⇒
%現-~targetの非可視~下位tree~level ~INCBY 1
◎
If path[index]'s root-of-closed-tree is true, then increase currentTargetHiddenSubtreeLevel by 1.
</li>
					<li>
~IF［
%経路[ %~index ] の`呼出n~target$evP ~EQ %現-~target
］
⇒＃
%現-~target~index ~SET %~index；
~BREAK
◎
If path[index]'s invocation target is currentTarget, then set currentTargetIndex to index and break.
</li>
					<li>
~IF［
%経路[ %~index ] の`~slotは閉な~tree内か$evP ~EQ ~T
］
⇒
%現-~targetの非可視~下位tree~level ~DECBY 1
◎
If path[index]'s slot-in-closed-tree is true, then decrease currentTargetHiddenSubtreeLevel by 1.
</li>
					<li>
%~index ~DECBY 1
◎
Decrease index by 1.
</li>
				</ol>
			</li>
			<li>
%現-非可視~level ~LET %現-~targetの非可視~下位tree~level
◎
↓</li>
			<li>
%最大-非可視~level ~LET %現-~targetの非可視~下位tree~level
◎
Let currentHiddenLevel and maxHiddenLevel be currentTargetHiddenSubtreeLevel.
</li>
			<li>
%~index ~SET %現-~target~index ~MINUS 1
◎
Set index to currentTargetIndex − 1.
</li>
			<li>
<p>
~WHILE［
%~index ~GTE 0
］：
◎
While index is greater than or equal to 0:
</p>
				<ol>
					<li>
~IF［
%経路[ %~index ] の`閉な~treeの根か$evP ~EQ ~T
］
⇒
%現-非可視~level ~INCBY 1
◎
If path[index]'s root-of-closed-tree is true, then increase currentHiddenLevel by 1.
</li>
					<li>
~IF［
%現-非可視~level ~LTE %最大-非可視~level
］
⇒
%~composed経路 に %経路[ %~index ] の`呼出n~target$evPを`前付加する$
◎
If currentHiddenLevel is less than or equal to maxHiddenLevel, then prepend path[index]'s invocation target to composedPath.
</li>
					<li>
<p>
~IF［
%経路[ %~index ] の`~slotは閉な~tree内か$evP ~EQ ~T
］：
◎
If path[index]'s slot-in-closed-tree is true:
</p>

						<ol>
							<li>
%現-非可視~level ~DECBY 1
◎
Decrease currentHiddenLevel by 1.
</li>
							<li>
~IF［
%最大-非可視~level ~GTE %現-非可視~level
］
⇒
%最大-非可視~level ~SET %現-非可視~level
◎
If currentHiddenLevel is less than maxHiddenLevel, then set maxHiddenLevel to currentHiddenLevel.
</li>
						</ol>
					</li>
					<li>
%~index ~DECBY 1
◎
Decrease index by 1.
</li>
				</ol>
			</li>
			<li>
%現-非可視~level ~SET %現-~targetの非可視~下位tree~level
◎
↓</li>
			<li>
%最大-非可視~level ~SET %現-~targetの非可視~下位tree~level
◎
Set currentHiddenLevel and maxHiddenLevel to currentTargetHiddenSubtreeLevel.
</li>
			<li>
%~index ~SET %現-~target~index ~PLUS 1
◎
Set index to currentTargetIndex + 1.
</li>
			<li>
<p>
~WHILE［
%~index ~LT %経路 の`~size$
］：
◎
While index is less than path’s size:
</p>
				<ol>
					<li>
~IF［
%経路[ %~index ] の`~slotは閉な~tree内か$evP ~EQ ~T
］
⇒
%現-非可視~level ~INCBY 1
◎
If path[index]'s slot-in-closed-tree is true, then increase currentHiddenLevel by 1.
</li>
					<li>
~IF［
%現-非可視~level ~LTE %最大-非可視~level
］
⇒
%~composed経路 に %経路[ %~index ] の`呼出n~target$evPを`付加する$
◎
If currentHiddenLevel is less than or equal to maxHiddenLevel, then append path[index]'s invocation target to composedPath.
</li>
					<li>
<p>
~IF［
%経路[ %~index ] の`閉な~treeの根か$evP ~EQ ~T
］：
◎
If path[index]'s root-of-closed-tree is true:
</p>
						<ol>
							<li>
%現-非可視~level ~DECBY 1
◎
Decrease currentHiddenLevel by 1.
</li>
							<li>
~IF［
%最大-非可視~level ~GTE %現-非可視~level
］
⇒
%最大-非可視~level ~SET %現-非可視~level
◎
If currentHiddenLevel is less than maxHiddenLevel, then set maxHiddenLevel to currentHiddenLevel.
</li>
						</ol>
					</li>
					<li>
%~index ~INCBY 1
◎
Increase index by 1.
</li>
				</ol>
			</li>
			<li>
~RET %~composed経路
◎
Return composedPath.
</li>
		</ol>
</div>

<div class="algo">
<p>
@eventPhase
取得子~手続きは、
初期化-時の値を返す
— それは、
次のいずれかをとるモノトスル（括弧内は数-値）：
◎
The eventPhase attribute must return the value it was initialized to, which must be one of the following:
</p>
<dl>
	<dt>@NONE (0)</dt>
	<dd>
まだ`配送-$されていない`~event$はこの相に属する。
◎
Events not currently dispatched are in this phase.
</dd>

	<dt>@CAPTURING_PHASE (1)</dt>
	<dd>
`~event$が`~tree$に`関与-$している~objに向けて`配送-$されるとき、
~eventがその`~target$に到達するまでは，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase before it reaches its target.
</dd>

	<dt>@AT_TARGET (2)</dt>
	<dd>
`~event$が`配送-$されるとき、
~eventの`~target$上では，この相に属する。
◎
When an event is dispatched it will be in this phase on its target.
</dd>

	<dt>@BUBBLING_PHASE (3)</dt>
	<dd>
`~event$が`~tree$に`関与-$している~objに向けて`配送-$されるとき、
~eventがその`~target$に到達した後は，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase after it reaches its target.
</dd>
</dl>

<p>
`~event$の作成-時には、
この属性は $NONE に初期化するモノトスル。
◎
Initially the attribute must be initialized to NONE.
</p>
</div>

<p>
各`~event$には、
次に挙げるものが結付けられる
— いずれも真偽値をとり，初期~時は ~F とする
⇒＃
`伝播を停止するか@ev,
`伝播を即時に停止するか@ev,
`取消されたか@ev,
`受動-~listener内か@ev,
`~composedか@ev,
`初期化-済みか@ev,
`配送-中か@ev
◎
Each event has the following associated flags that are all initially unset:
• stop propagation flag
• stop immediate propagation flag
• canceled flag
• in passive listener flag
• composed flag
• initialized flag
• dispatch flag
</p>

<div class="algo">
@stopPropagation()
~method手続きは
⇒
コレの`伝播を停止するか$ev ~SET ~T
◎
The stopPropagation() method steps are to set this’s stop propagation flag.
</div>

<div class="algo">
@cancelBubble
取得子~手続きは
⇒
~RET コレの`伝播を停止するか$ev
◎
The cancelBubble getter steps are to return true if this’s stop propagation flag is set; otherwise false.
</div>

<div class="algo">
$cancelBubble 設定子~手続きは
⇒
~IF［
所与の値 ~EQ ~T
］
⇒
コレの`伝播を停止するか$ev ~SET ~T
◎
The cancelBubble setter steps are to set this’s stop propagation flag if the given value is true; otherwise do nothing.
</div>

<div class="algo">
@stopImmediatePropagation()
~method手続きは
⇒＃
コレの`伝播を停止するか$ev ~SET ~T；
コレの`伝播を即時に停止するか$ev ~SET ~T
◎
The stopImmediatePropagation() method steps are to set this’s stop propagation flag and this’s stop immediate propagation flag.
</div>

<div class="algo">
@bubbles
取得子~手続きは、
初期化-時の値を返す。
◎
The bubbles and cancelable attributes must return the values they were initialized to.
</div>

<div class="algo">
@cancelable
取得子~手続きは、
初期化-時の値を返す。
◎
↑</div>

<div class="algo">
<p>
`取消されたかを設定する@
~algoは、
所与の
( `~event$ %~event )
に対し
⇒
~IF［
%~event の $cancelable 属性~値 ~EQ ~T
］~AND［
%~event の`受動-~listener内か$ev ~EQ ~F
］
⇒
%~event の`取消されたか$ev ~SET ~T
◎
To set the canceled flag, given an event event, if event’s cancelable attribute value is true and event’s in passive listener flag is unset, then set event’s canceled flag, and do nothing otherwise.
</p>
</div>

<div class="algo">
@returnValue
取得子~手続きは
⇒
~RET コレの`取消されたか$ev
◎
The returnValue getter steps are to return false if this’s canceled flag is set; otherwise true.
</div>

<div class="algo">
$returnValue 設定子~手続きは
⇒
~IF［
所与の値 ~EQ ~F
］
⇒
`取消されたかを設定する$( コレ )
◎
The returnValue setter steps are to set the canceled flag with this if the given value is false; otherwise do nothing.
</div>

<div class="algo">
<p>
@preventDefault()
~method手続きは
⇒
`取消されたかを設定する$( コレ )
◎
The preventDefault() method steps are to set the canceled flag with this.
</p>

<p class="note">注記：
$preventDefault() を呼出しても効果がない局面もある。
~UAには、
~debugを援助するため，精確な~~原因を開発者~consoleに~logすることが奨励される。
◎
There are scenarios where invoking preventDefault() has no effect. User agents are encouraged to log the precise cause in a developer console, to aid debugging.
</p>
</div>

<div class="algo">
@defaultPrevented
取得子~手続きは
⇒
~RET コレの`取消されたか$ev
◎
The defaultPrevented getter steps are to return true if this’s canceled flag is set; otherwise false.
</div>

<div class="algo">
@composed
取得子~手続きは
⇒
~RET コレの`~composedか$ev
◎
The composed getter steps are to return true if this’s composed flag is set; otherwise false.
</div>

<div class="algo">
<p>
@isTrusted
取得子~手続きは、
初期化-時の値を返す。
◎
The isTrusted attribute must return the value it was initialized to.＼
</p>

<p>
`~event$の作成-時には、
この属性は ~F に初期化するモノトスル。
◎
When an event is created the attribute must be initialized to false.
</p>

<p class="note">注記：
$isTrusted は、
`~event$は
（ $EventTarget.dispatchEvent() を利用してではなく）
~UAにより`配送-$されたかどうかを簡便に指示する。
唯一の旧来の例外は `click()＠~HTMLinteraction#dom-click$c であり，~UAに`~event$を［
$isTrusted 属性は ~F に初期化-
］した上で配送させる。
◎
isTrusted is a convenience that indicates whether an event is dispatched by the user agent (as opposed to using dispatchEvent()). The sole legacy exception is click(), which causes the user agent to dispatch an event whose isTrusted attribute is initialized to false.
</p>
</div>

<div class="algo">
@timeStamp
取得子~手続きは、
初期化-時の値を返す。
◎
The timeStamp attribute must return the value it was initialized to.
</div>

<div class="algo">
<p>
`~eventを初期化する@
~algoは、
所与の
( %event, %type, %bubbles, %cancelable )
に対し：
</p>
<ol>
	<li>
%event の
⇒＃
`初期化-済みか$ev ~SET ~T,
`伝播を停止するか$ev ~SET ~F,
`伝播を即時に停止するか$ev ~SET ~F,
`取消されたか$ev ~SET ~F,
`~target$ ~SET ~NULL,
</li>
	<li>
%event の各種~属性を次に従って初期化する
⇒＃
$isTrusted ~SET ~F,
$type ~SET %type,
$bubbles ~SET %bubbles,
$cancelable ~SET %cancelable
</li>
</ol>
◎
To initialize an event, with type, bubbles, and cancelable, run these steps:
• Set event’s initialized flag.
• Unset event’s stop propagation flag, stop immediate propagation flag, and canceled flag.
• Set event’s isTrusted attribute to false.
• Set event’s target to null.
• Set event’s type attribute to type.
• Set event’s bubbles attribute to bubbles.
• Set event’s cancelable attribute to cancelable.
</div>

<div class="algo">
<p>
@initEvent(type, bubbles, cancelable)
~method手続きは：
◎
The initEvent(type, bubbles, cancelable) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
◎
If this’s dispatch flag is set, then return.
</li>
	<li>
`~eventを初期化する$( コレ, %type, %bubbles, %cancelable )
◎
Initialize this with type, bubbles, and cancelable.
</li>
</ol>

<p class="note">注記：
$initEvent() は、
`~event$には構築子があるので冗長であり，
$composed も設定できないが、
旧来の内容~用に~supportされる必要がある。
◎
initEvent() is redundant with event constructors and incapable of setting composed. It has to be supported for legacy content.
</p>
</div>

		</section>
		<section id="interface-window-extensions">
<h3 title="Legacy extensions to the Window interface">2.3. ^Window ~interfaceに対する旧来の拡張</h3>

！！
partial interface $Window {
  [`Replaceable$] readonly attribute ($Event or $undefined) `event$m; // <!--cp-legacy-->
};
！

<p>
各 $Window ~objには
`現在の~event@
が結付けられる。
それは，［
$undefined ／ $Event ~obj
］であり、
他が言明されない限り， $undefined とする。
◎
Each Window object has an associated current event (undefined or an Event object). Unless stated otherwise it is undefined.
</p>

<div class="algo">
`event@m
取得子~手続きは
⇒
~RET コレの`現在の~event$
◎
The event getter steps are to return this’s current event.
</div>

<p class="note">注記：
~web開発者には、
代わりに~event~listenerに渡される $Event ~objに依拠することが強く奨励される
— その方が、
~codeは より~port可能になるので。
この属性は、
~workerや~worklet内では可用でなく，
`~shadow~tree$内に配送される~event用には 不正確になる。
◎
Web developers are strongly encouraged to instead rely on the Event object passed to event listeners, as that will result in more portable code. This attribute is not available in workers or worklets, and is inaccurate for events dispatched in shadow trees.
</p>

		</section>
		<section id="interface-customevent">
<h3 title="Interface CustomEvent">2.4. ^@CustomEvent ~interface</h3>

！！
[`Exposed$=*]
interface @CustomEvent : $Event {
  `CustomEvent$mc($DOMString %type, optional $CustomEventInit %eventInitDict = {});

  readonly attribute $any $detail;

  $undefined $initCustomEvent($DOMString %type, optional $boolean %bubbles = false, optional $boolean %cancelable = false, optional $any %detail = null); // <!--cp-legacy-->
};

dictionary @CustomEventInit : $EventInit {
  $any @CustomEventInit.detail = null;
};
！

<!-- ^@CustomEvent -->
<p>
~custom~dataを運ばせる用途に，
$CustomEvent ~interfaceを利用する`~event$を利用できる。
◎
Events using the CustomEvent interface can be used to carry custom data.
</p>

<dl class="domintro">
	<dt>%event = $CustomEvent(type [, eventInitDict])</dt>
	<dd>
$Event の構築子と相似的に働く
— %eventInitDict 引数により， $detail 属性も設定できることを除いて。
◎
Works analogously to the constructor for Event except that the eventInitDict argument now allows for setting the detail attribute too.
</dd>

	<dt>%event . $detail</dt>
	<dd>
%event の作成-時に与えられた~custom~dataを返す。
概して，合成な~eventで利用される。
【！initCustomEvent is dead】
◎
Returns any custom data event was created with. Typically used for synthetic events.
</dd>
</dl>

<div class="algo">
@detail
取得子~手続きは、
初期化-時の値を返す。
◎
The detail attribute must return the value it was initialized to.
</div>

<div class="algo">
<p>
@initCustomEvent(type, bubbles, cancelable, detail)
~method手続きは：
◎
The initCustomEvent(type, bubbles, cancelable, detail) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~T
］
⇒
~RET
◎
If this’s dispatch flag is set, then return.
</li>
	<li>
`~eventを初期化する$( コレ, %type, %bubbles, %cancelable )
◎
Initialize this with type, bubbles, and cancelable.
</li>
	<li>
コレの $detail 属性 ~SET %detail
◎
Set this’s detail attribute to detail.
</li>
</ol>
</div>

		</section>
		<section id="constructing-events">
<h3 title="Constructing events">2.5. ~eventの構築-法</h3>

<p>
`適用-可能な仕様$は、
すべてまたは一部の`~event$用に
`~event構築-時の手続き@
を定義してもヨイ。
この~algoは、
`~eventを内的に作成する$手続き内から，
( 当の`~event$, $EventInit %辞書 )
を渡して呼出される。
◎
Specifications may define event constructing steps for all or some events. The algorithm is passed an event event and an EventInit eventInitDict as indicated in the inner event creation steps.
</p>

<p class="note">注記：
この構成子は、
$Event の下位classが［
その初期化-用の辞書~memberと~IDL属性が一対一に対応していない，より複階的な構造
］を有するときに利用できる。
◎
This construct can be used by Event subclasses that have a more complex structure than a simple 1:1 mapping between their initializing dictionary members and IDL attributes.
</p>

<div class="algo">
<p>
［
$Event ~interface, それを継承する各~interface
］の構築子は、
`~event構築子@
と総称され，この仕様においては
@Event.Event(type, eventInitDict),
@CustomEvent.CustomEvent(type, eventInitDict)
が該当する。
そのような~interface %~interface の`~event構築子$は、
次の手続きを走らすモノトスル：
◎
When a constructor of the Event interface, or of an interface that inherits from the Event interface, is invoked, these steps must be run, given the arguments type and eventInitDict:
</p>
<ol>
	<li>
%~event ~LET `~eventを内的に作成する$( %~interface, ~NULL, 現在時, %eventInitDict )
◎
Let event be the result of running the inner event creation steps with this interface, null, now, and eventInitDict.
</li>
	<li>
%~event の $Event.type 属性 ~SET %type に初期化する
◎
Initialize event’s type attribute to type.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>
</div>

<div class="algo">
<p>
`~eventを作成する@
~algoは、
所与の
⇒＃
$Event または それを継承する~interface %~event~interface,
`~realm$ %~realm ~DF ~NULL
◎終
に対し：
◎
To create an event using eventInterface, which must be either Event or an interface that inherits from it, and optionally given a realm realm, run these steps:
• If realm is not given, then set it to null.
</p>
<ol>
	<li>
<p>
%辞書~型 ~LET %~event~interface の構築子が引数に受容する`辞書$型
（ $EventInit またはそれを継承する辞書~型）
</p>

<p class="trans-note">【
$Event を継承する~interfaceであって，複数の構築子を宣言するものは、
現時点では，おそらく無い（今後も定義されないと見込まれる）。
】</p>
◎
↓</li>
	<li>
<p>
%辞書 ~LET `~IDL値に変換する$( ~JS `undefined^jv 値, %辞書~型 )
◎
Let dictionary be the result of converting the JavaScript value undefined to the dictionary type accepted by eventInterface’s constructor. (This dictionary type will either be EventInit or a dictionary that inherits from it.)
</p>

<p class="XXX">
これは、
%辞書~型 に `required^c を伴う~memberが在る場合に働かない。
`課題 #600＠~DOMissue/600$
を見よ。
◎
This does not work if members are required; see whatwg/dom#600.
</p>
	</li>
	<li>
<p>
%~event ~LET `~eventを内的に作成する$( ↓ )
⇒＃
%~event~interface,
%~realm,
当の~eventが通達している何かが生じた時刻†,
%辞書
◎
Let event be the result of running the inner event creation steps with eventInterface, realm, the time of the occurrence that the event is signaling, and dictionary.
</p>

<p class="note">†注記：
例えば macOS においては、
入力~動作が生じた時刻は ^NSEvent ~objの ^timestamp ~propを介して可用になる。
◎
In macOS the time of the occurrence for input actions is available via the timestamp property of NSEvent objects.
</p>
	</li>
	<li>
%~event の $Event.isTrusted 属性 ~SET ~T に初期化する
◎
Initialize event’s isTrusted attribute to true.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>

<p class="note">注記：
`~eventを作成する$手続きは、
単純に`~eventを発火する$代わりに［
`~eventを作成する$, `~eventを配送する$
］手続きを別々に呼出す必要がある，他の仕様からの利用が意味される。
これは、
~eventの属性が既定の値に正しく初期化されることを確保する。
◎
Create an event is meant to be used by other specifications which need to separately create and dispatch events, instead of simply firing them. It ensures the event’s attributes are initialized to the correct defaults.
</p>
</div>

<div class="algo">
<p>
`~eventを内的に作成する@
~algoは、
所与の
( %~event~interface, %~realm, %時刻, %辞書 )
に対し：
◎
The inner event creation steps, given an eventInterface, realm, time, and dictionary, are as follows:
</p>
<ol>
	<li>
<p>
%~event ~LET `新たな~obj$( %~event~interface, %~realm )
— ただし， %~realm ~EQ ~NULL の場合は Web IDL に定義される既定の挙動に従う
◎
Let event be the result of creating a new object using eventInterface. If realm is non-null, then use that realm; otherwise, use the default behavior defined in Web IDL.
</p>

<p class="XXX">
これを書いている時点では、
~Web~IDLは，まだこの既定の挙動を定義していない。
`whatwg/webidl 課題 #135＠https://github.com/whatwg/webidl/issues/135$
を見よ。
◎
As of the time of this writing Web IDL does not yet define any default behavior; see whatwg/webidl#135.
</p>
	</li>
	<li>
%~event の`初期化-済みか$ev ~SET ~T
◎
Set event’s initialized flag.
</li>
	<li>
%~event の $Event.timeStamp 属性 ~SET
`相対的な粗い高分解能~時刻$( %時刻, %~event に`関連な大域~obj$ )
◎
Initialize event’s timeStamp attribute to the relative high resolution coarse time given time and event’s relevant global object.
</li>
	<li>
%辞書 を成す
~EACH( %~member → %値 )
に対し
⇒
~IF［
%~event には %~member を`識別子$とする属性はある
］
⇒
その属性 ~SET %値 に初期化する
◎
For each member → value of dictionary:＼
if event has an attribute whose identifier is member, then initialize that attribute to value.
</li>
	<li>
`適用-可能な仕様$にて %~event 用に`定義された各$( `~event構築-時の手続き$ %手続き )
に対し
⇒
%手続き( %~event, %辞書 )
◎

Run the event constructing steps with event and dictionary.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>
</div>

		</section>
		<section id="defining-event-interfaces">
<h3 title="Defining event interfaces">2.6. ~event~interfaceの定義-法</h3>

<p>
一般に、
$Event を継承する新たな~interfaceを定義する際には，常に
`WHATWG＠https://whatwg.org/$cite
または
`W3C WebApps WG＠https://www.w3.org/2008/webapps/$cite
~communityからの~feedbackを依頼されたし。
◎
In general, when defining a new interface that inherits from Event please always ask feedback from the WHATWG or the W3C WebApps WG community.
</p>

<p>
$CustomEvent ~interfaceはその出発点に利用できるものだが、
`init*Event()^c の類いの~methodは，構築子とかぶって冗長になるので導入しないように。
$Event ~interfaceを継承する~interfaceがその種の~methodを備えているのは、
歴史的な理由に限られている。
◎
The CustomEvent interface can be used as starting point. However, do not introduce any init*Event() methods as they are redundant with constructors. Interfaces that inherit from the Event interface that have such a method only have it for historical reasons.
</p>

		</section>
		<section id="interface-eventtarget">
<h3 title="Interface EventTarget">2.7. ^@EventTarget ~interface</h3>

！！
[`Exposed$=*]
interface @EventTarget {
  `EventTarget$mc();

  $undefined $addEventListener($DOMString %type, $EventListener? %callback, optional ($AddEventListenerOptions or $boolean) %options = {});
  $undefined $removeEventListener($DOMString %type, $EventListener? %callback, optional ($EventListenerOptions or $boolean) %options = {});
  $boolean $dispatchEvent($Event %event);
};

callback interface @EventListener {
  $undefined @EventListener.handleEvent($Event %event);
};

dictionary @@EventListenerOptions {
  $boolean @capture = false;
};

dictionary @@AddEventListenerOptions : $EventListenerOptions {
  $boolean @passive;
  $boolean @once = false;
  $AbortSignal @signal;
};
！

<p>
$@EventTarget ~objは、
何かが生じたとき，`~event$を`配送-$できる~targetを表現する。
◎
An EventTarget object represents a target to which an event can be dispatched when something has occurred.
</p>

<p>
各 $EventTarget ~objには、
`~event~listener~list@
が結付けられる
— それは、
`~event~listener$たちが成す`~list$であり，初期~時は`空$とする。
◎
Each EventTarget object has an associated event listener list (a list of zero or more event listeners). It is initially the empty list.
</p>

<p>
`~event~listener@
を利用すれば、
特定の`~event$を観測できる
— それは、
次に挙げるものからなる：
◎
An event listener can be used to observe a specific event and consists of:
</p>

<ul>
	<li>
`型@evL
⇒
文字列
◎
type (a string)
</li>
	<li>
`~callback@evL
⇒
~NULL ／ $EventListener ~obj
◎
callback (null or an EventListener object)
</li>
	<li>
`捕捉するか@evL
⇒
真偽値
— 初期~時は ~F とする
◎
capture (a boolean, initially false)
</li>
	<li>
`受動的か@evL
⇒
~NULL ／ 真偽値
— 初期~時は ~NULL とする
【実質的には真偽値（ `~event~listenerを追加する$とき，真偽値に設定される。）】
◎
passive (null or a boolean, initially null)
</li>
	<li>
`一度限りか@evL
⇒
真偽値
— 初期~時は ~F とする
◎
once (a boolean, initially false)
</li>
	<li>
`通達@evL
⇒
~NULL ／ $AbortSignal ~obj
◎
signal (null or an AbortSignal object)
</li>
	<li>
`除去-済みか@evL
⇒
内部処理用の真偽値
— 初期~時は ~F とする。
◎
removed (a boolean for bookkeeping purposes, initially false)
</li>
</ul>

<p class="note">注記：
`~callback$evLは $EventListener ~objであるが、
`~event~listener$は 上に示したように より広い概念である。
◎
Although callback is an EventListener object, an event listener is a broader concept as can be seen above.
</p>

<p>
各 $EventTarget ~objには、
その
`親~targetを取得する@
~algoも結付けられる。
それは：
◎
Each EventTarget object also has an associated get the parent algorithm, which＼
</p>
<ul>
	<li>
所与の`~event$に対し，［
$EventTarget ~obj／ ~NULL
］を返す。
◎
takes an event event, and returns an EventTarget object.＼
</li>
	<li>
他が指定されない限り，［
常に ~NULL を返す~algo
］になるとする。
◎
Unless specified otherwise it returns null.
</li>
</ul>

<p class="note">注記：
`~node$は、
`親~targetを取得する$~algoを上書きする。
［
`~shadow根$／`文書$
］は、
それをさらに上書きする。
◎
Nodes, shadow roots, and documents override the get the parent algorithm.
</p>

<p class="trans-note">【
この~algoは、
~eventの`配送-$時にその伝播`経路$を構築するために利用される。
】【
指定される個々の~algoには、
渡された~eventを利用しないものもある
（その場合、
~eventを省略して記述され得る）。
】</p>

<p>
各 $EventTarget ~objには、
`作動化の挙動@
が結付けられ得る。
この~algoは、
`~eventを配送する$~algo内から，
( `~event$ )
を渡して呼出される。
◎
Each EventTarget object can have an associated activation behavior algorithm. The activation behavior algorithm is passed an event, as indicated in the dispatch algorithm.
</p>

<p class="note">注記：
これが存在するのは、
~UAが
ある種の $EventTarget ~objに対し，ある種の動作を遂行するためである
— 例えば `area$e 要素は、
合成な $MouseEvent `~event$に呼応して，その $Event.type 属性は `click^l にされる。
それを除去することは、
~Web互換性のため できない。
それはまた、
今や，何らかの作動化を定義するときに~~尊守される仕方になっている。
`HTML$r
◎
This exists because user agents perform certain actions for certain EventTarget objects, e.g., the area element, in response to synthetic MouseEvent events whose type attribute is click. Web compatibility prevented it from being removed and it is now the enshrined way of defining an activation of something. [HTML]
</p>

<p>
加えて、
`作動化の挙動$が有る $EventTarget ~objには、［
`旧来の作動化~前の挙動@,
`旧来の作動化~取消~時の挙動@
］が有るものもある
（片方のみ有ることはない）。
◎
Each EventTarget object that has activation behavior, can additionally have both (not either) a legacy-pre-activation behavior algorithm and a legacy-canceled-activation behavior algorithm.
</p>

<p class="note">注記
これらの~algoは，［
Checkbox ／ Radio
］状態にある `input$e 要素のみに存在し、
他では利用されない。
`HTML$r
◎
These algorithms only exist for checkbox and radio input elements and are not to be used for anything else. [HTML]
</p>

<dl class="domintro">
	<dt>%target = $EventTarget()</dt>
	<dd>
開発者が`~event$を`配送-$して~listenするために利用できる，新たな $EventTarget ~objを作成する。
◎
Creates a new EventTarget object, which can be used by developers to dispatch and listen for events.
</dd>

	<dt>%target . $addEventListener(type, callback [, options])</dt>
	<dd>
%target の`~event~listener~list$に［
$Event.type 属性~値が %type である`~event$用の`~event~listener$
］を付加する。
%callback 引数が，`~event$が`配送-$されたときに呼出される`~callback$evLとして設定される。
◎
Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
</dd>
	<dd>
%options 引数は、
~listenerに特有な~optionを設定する。
互換性のため、
これは真偽値もとり得る
— その場合、
この~methodは，正確に［
%options の $EventListenerOptions.capture に その値が指定された
］かのように挙動する。
◎
The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture.
</dd>
	<dd>
%options の $EventListenerOptions.capture が［
~T ／ ［
~F または無い
］］ならば、
`~callback$evLは，`~event$の $eventPhase 属性~値が［
$Event.BUBBLING_PHASE ／ $Event.CAPTURING_PHASE
］の間は呼出されないようになる。
いずれにせよ、
`~event$の $Event.eventPhase 属性~値が $Event.AT_TARGET のときは，
`~callback$evLは呼出される。
◎
When set to true, options’s capture prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
</dd>
	<dd>
%options の $AddEventListenerOptions.passive が ~T に設定された場合、
`~callback$evLは $Event.preventDefault() を呼出しても`~event$を取消さないことを指示する。
これは、
`§ ~event~listenerの観測-法＠#observing-event-listeners$に述べる処理能の最適化を可能化するために利用される
◎
When set to true, options’s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
</dd>

	<dd>
%options の $AddEventListenerOptions.once が ~T に設定された場合、
~callbackが呼出されるのは一度限りであり，その後には`~event~listener$は除去されることを指示する。
◎
When set to true, options’s once indicates that the callback will only be invoked once after which the event listener will be removed.
</dd>
	<dd>
%options の $AddEventListenerOptions.signal に $AbortSignal が渡された場合、
その通達が中止されたとき~event~listenerは除去されることになる。
◎
If an AbortSignal is passed for options’s signal, then the event listener will be removed when signal is aborted.
</dd>
	<dd>
`~event~listener$は、
重複しない
— すなわち、［
`型$evL, `~callback$evL, `捕捉するか$evL
］のうちいずれかが既存のものと異なる —
場合に限り，
%target の`~event~listener~list$に付加される。
◎
The event listener is appended to target’s event listener list and is not appended if it has the same type, callback, and capture.
</dd>

	<dt>%target . $removeEventListener(type, callback [, options])</dt>
	<dd>
引数と同じ［
`型$evL, `~callback$evL, `捕捉するか$evL
］を伴う`~event~listener$を，
%target の`~event~listener~list$から除去する。
◎
Removes the event listener in target’s event listener list with the same type, callback, and options.
</dd>

	<dt>%target . $dispatchEvent(event)</dt>
	<dd>
合成な~event %event を %target に向けて`配送-$する。
<!-- ^@Event -->
［
%event の $cancelable 属性~値が ~F である ／
%event の $preventDefault() ~methodは呼出されなかった
］ならば ~T を返す。
他の場合は ~F を返す。
◎
Dispatches a synthetic event event to target and returns true if either event’s cancelable attribute value is false or its preventDefault() method was not invoked; otherwise false.
</dd>
</dl>

<!-- ^@EventTarget -->

<div class="algo">
<p>
`~option群を平坦~化する@
~algoは、
所与の
( %~option群 )
に対し：
◎
To flatten options, run these steps:
</p>
<ol>
	<li>
~RET %~option群 の型に応じて
⇒＃
$boolean ならば %~option群 ／
`辞書$ならば %~option群[ "$EventListenerOptions.capture" ]
◎
If options is a boolean, then return options.
◎
Return options["capture"].
</li>
</ol>
</div>

<div class="algo">
<p>
`~option群をもっと平坦~化する@
~algoは、
所与の
( %~option群 )
に対し：
◎
To flatten more options, run these steps:
</p>
<ol>
	<li>
( %capture, %passive, %once, %signal ) ~LET
( `~option群を平坦~化する$( %~option群 ), ε, ~F, ε )
◎
Let capture be the result of flattening options.
◎
Let once be false.
◎
Let passive and signal be null.
</li>
	<li>
~IF［
%~option群 は`辞書$である
］
⇒＃
%passive ~SET %~option群[ "$AddEventListenerOptions.passive" ]；
%once ~SET %~option群[ "$AddEventListenerOptions.once" ]；
%signal ~SET %~option群[ "$AddEventListenerOptions.signal" ]
◎
If options is a dictionary:
• Set once to options["once"].
• If options["passive"] exists, then set passive to options["passive"].
• If options["signal"] exists, then set signal to options["signal"].
</li>
	<li>
~IF［
%passive ~EQ ε
］
⇒
%passive ~SET ~NULL
◎
↑</li>
	<li>
~IF［
%signal ~EQ ε
］
⇒
%signal ~SET ~NULL
◎
↑</li>
	<li>
~RET ( %capture, %passive, %once, %signal )
◎
Return capture, passive, once, and signal.
</li>
</ol>
</div>

<div class="algo">
<p>
@EventTarget()
構築子~手続きは、
何もしない。
◎
The new EventTarget() constructor steps are to do nothing.
</p>

<p class="note">注記：
他所に言明される既定により、
返される $EventTarget の`親~targetを取得する$~algoは，~NULL を返すことになり、［
`作動化の挙動$,
`旧来の作動化~前の挙動$,
`旧来の作動化~取消~時の挙動$
］は無い。
◎
Because of the defaults stated elsewhere, the returned EventTarget’s get the parent algorithm will return null, and it will have no activation behavior, legacy-pre-activation behavior, or legacy-canceled-activation behavior.
</p>

<p class="note">注記：
将来には、
`親~targetを取得する$~custom~algoも許容され得る。
作者は、
それが自身の~programに有用になるなら知らせてほしい。
今の所は、
作者が作成したどの $EventTarget も，~tree構造には関与しない。
◎
In the future we could allow custom get the parent algorithms. Let us know if this would be useful for your programs. For now, all author-created EventTargets do not participate in a tree structure.
</p>
</div>

<div class="algo">
<p>
`既定の受動-値@
は、
所与の
( ~event型 %型, $EventTarget ~obj %~target )
に対し：
</p>
<ol>
	<li>
%文書 ~LET %~target の`~node文書$
	</li>
	<li>
<p>
~RET ~IS［
~AND↓
］：
</p>
		<ul>
			<li>
%型 ~IN { `touchstart^l, `touchmove^l, `wheel^l, `mousewheel^l }
`TOUCH-EVENTS$r
`UIEVENTS$r
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
%~target は $Window ~objである
</li>
					<li>
［
%~target は`~node$である
］~AND［
%~target ~IN { %文書, %文書 の`文書~要素$, %文書 の`~body要素$ }
］
`HTML$r
</li>
				</ul>
			</li>
		</ul>
	</li>
</ol>
◎
The default passive value, given an event type type and an EventTarget eventTarget, is determined as follows:
• Return true if all of the following are true:
•• type is one of "touchstart", "touchmove", "wheel", or "mousewheel". [TOUCH-EVENTS] [UIEVENTS]
•• eventTarget is a Window object, or is a node whose node document is eventTarget, or is a node whose node document’s document element is eventTarget, or is a node whose node document’s body element is eventTarget. [HTML]
• Return false.
</div>

<div class="algo">
<p>
`~event~listenerを追加する@
~algoは、
所与の
( $EventTarget ~obj %~target, `~event~listener$ %~listener )
に対し：
◎
To add an event listener, given an EventTarget object eventTarget and an event listener listener, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~target は $ServiceWorkerGlobalScope ~objである
］~AND［
%~target の`~sw$SWGの`~script資源$の`これまでに評価されたか$ ~EQ ~T
］~AND［
%~listener の`型$evLは ある`~sw~event$の $type 属性~値に合致する†
］`SERVICE-WORKERS$r
⇒
`~consoleに警告を報告する$( “期待される結果を与えないであろう” )
◎
If eventTarget is a ServiceWorkerGlobalScope object, its service worker’s script resource’s has ever been evaluated flag is set, and listener’s type matches the type attribute value of any of the service worker events, then report a warning to the console that this might not give the expected results. [SERVICE-WORKERS]
</p>

<p class="trans-note">【†
そのような~eventの~instanceが在ることも要求しているかのように解釈できる条件だが、
単に，~sw~eventの ^type 属性~値がとり得る値たちが成す集合に入ることを意味するのかも？
（しかしながら、
`~event~listenerを除去する$ときのように，明示的な用語
“`取扱う~event型の集合$”
を利用していないので、
実際にその解釈が意図されているのかもしれない。）
】</p>
	</li>
	<li>
%通達 ~LET %~listener の`通達$evL
◎
↓</li>
	<li>
~IF［
%通達 ~NEQ ~NULL
］~AND［
%通達 は`中止-済み$aBである
］
⇒
~RET
◎
If listener’s signal is non-null and is aborted, then return.
</li>
	<li>
~IF［
%~listener の`~callback$evL ~EQ ~NULL
］
⇒
~RET
◎
If listener’s callback is null, then return.
</li>
	<li>
~IF［
%~listener の`受動的か$evL ~EQ ~NULL
］
⇒
%~listener の`受動的か$evL ~SET `既定の受動-値$( %~listener の`型$evL, %~target )
◎
If listener’s passive is null, then set it to the default passive value given listener’s type and eventTarget.
</li>
	<li>
~IF［
次を満たす`~event~listener$ %L は無い
］…
⇒
［
%L ~IN %~target の`~event~listener~list$
］~AND［
%L の ( `型$evL, `~callback$evL, `捕捉するか$evL )
~EQ
%~listener の ( `型$evL, `~callback$evL, `捕捉するか$evL )
］
◎終
…ならば
⇒
%~target の`~event~listener~list$に %~listener を`付加する$
◎
If eventTarget’s event listener list does not contain an event listener whose type is listener’s type, callback is listener’s callback, and capture is listener’s capture, then append listener to eventTarget’s event listener list.
</li>
	<li>
<p>
~IF［
%通達 ~NEQ ~NULL
］
⇒
`通達に~algoを追加する$( %通達, 次の手続き )
◎
If listener’s signal is non-null, then add the following abort steps to it:
</p>

<div class="algo">
手続きは
⇒
`~event~listenerを除去する$( %~target, %~listener )
◎
• Remove an event listener with eventTarget and listener.
</div>
	</li>
</ol>

<p class="note">注記：
［
`~event~listenerを追加する$
］の概念は、［
`~event~handler$ `HTML$r が同じ `code path^en【！＊】を利用する
］ことを確保するためにある。
◎
The add an event listener concept exists to ensure event handlers use the same code path. [HTML]
</p>
</div>

<div class="algo">
<p>
@addEventListener(type, callback, options)
~method手続きは：
◎
The addEventListener(type, callback, options) method steps are:
</p>
<ol>
	<li>
( %捕捉するか, %受動的か, %一度限りか, %通達 ) ~LET `~option群をもっと平坦~化する$( %options )
◎
Let capture, passive, once, and signal be the result of flattening more options.
</li>
	<li>
%~listener ~LET 新たな`~event~listener$
— その
⇒＃
`型$evL ~SET %type ,
`~callback$evL ~SET %callback ,
`捕捉するか$evL ~SET %捕捉するか ,
`受動的か$evL ~SET %受動的か ,
`一度限りか$evL ~SET %一度限りか,
`通達$evL ~SET %通達
◎
Add an event listener with this and an event listener whose type is type, callback is callback, capture is capture, passive is passive, once is once, and signal is signal.
</li>
	<li>
`~event~listenerを追加する$( コレ, %~listener )
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`~event~listenerを除去する@
~algoは、
所与の
( $EventTarget ~obj %~target, `~event~listener$ %~listener )
に対し：
◎
To remove an event listener, given an EventTarget object eventTarget and an event listener listener, run these steps:
</p>
<ol>
	<li>
~IF［
%~target は $ServiceWorkerGlobalScope ~objである
］~AND［
%~listener の`型$evL ~IN %~target の`~sw$SWGが`取扱う~event型の集合$
］`SERVICE-WORKERS$r
⇒
`~consoleに警告を報告する$( “期待される結果を与えないであろう” )
◎
If eventTarget is a ServiceWorkerGlobalScope object and its service worker’s set of event types to handle contains listener’s type, then report a warning to the console that this might not give the expected results. [SERVICE-WORKERS]
</li>
	<li>
%~listener の`除去-済みか$evL ~SET ~T
◎
Set listener’s removed to true and＼
</li>
	<li>
%~target の`~event~listener~list$から %~listener を`除去する$
◎
remove listener from eventTarget’s event listener list.
</li>
</ol>

<p class="note">注記：
~HTMLは、
~event~handlerを定義するために これを必要とする。
`HTML$r
◎
HTML needs this to define event handlers. [HTML]
</p>
</div>

<div class="algo">
<p>
`~event~listenerをすべて除去する@
~algoは、
所与の
( $EventTarget ~obj %~target )
に対し
⇒
%~target の`~event~listener~list$を成す
~EACH( %~listener )
に対し
⇒
`~event~listenerを除去する$( %~target, %~listener )
◎
To remove all event listeners, given an EventTarget object eventTarget:＼
for each listener of eventTarget’s event listener list:＼
remove an event listener with eventTarget and listener.
</p>

<p class="note">注記：
~HTMLは、
^document.open() を定義するために これを必要とする。
`HTML$r
◎
HTML needs this to define document.open(). [HTML]
</p>
</div>

<div class="algo">
<p>
@removeEventListener(type, callback, options)
~method手続きは：
◎
The removeEventListener(type, callback, options) method steps are:
</p>
<ol>
	<li>
%capture ~LET `~option群を平坦~化する$( %options )
◎
Let capture be the result of flattening options.
</li>
	<li>
~IF［
次を満たす`~event~listener$ %~listener は在る
］…
⇒
［
%~listener ~IN コレの`~event~listener~list$
］~AND［
%~listener の ( `型$evL, `~callback$evL, `捕捉するか$evL )
~EQ
( %type, %callback, %capture )
］
◎終
…ならば
⇒
`~event~listenerを除去する$( コレ, %~listener )
◎
If this’s event listener list contains an event listener whose type is type, callback is callback, and capture is capture, then remove an event listener with this and that event listener.
</li>
</ol>

<p class="note">注記：
~event~listener~listが
( `type^evL, `callback^evL, `capture^evL )
が互いに等しい複数の~event~listenerを包含することはない。
それは、
`~event~listenerを追加する$ときに防止される。
◎
The event listener list will not contain multiple event listeners with equal type, callback, and capture, as add an event listener prevents that.
</p>
</div>

<div class="algo">
<p>
@dispatchEvent(event)
~method手続きは：
◎
The dispatchEvent(event) method steps are:
</p>
<ol>
	<li>
~IF［
%event の`配送-中か$ev ~EQ ~T
］~OR［
%event の`初期化-済みか$ev ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If event’s dispatch flag is set, or if its initialized flag is not set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
<!-- ^@Event -->
%event の $isTrusted 属性 ~SET ~F に初期化する
◎
Initialize event’s isTrusted attribute to false.
</li>
	<li>
~RET `~eventを配送する$( コレ, %event )
◎
Return the result of dispatching event to this.
</li>
</ol>
</div>

		</section>
		<section id="observing-event-listeners">
<h3 title="Observing event listeners">2.8. ~event~listenerの観測-法</h3>

<p>
一般に、
開発者は，`~event~listener$の有無が観測-可能になるものとは予期しない。
`~event~listener$の影響iは、
その`~callback$evLにより決定される。
すなわち開発者は、
何もしない`~event~listener$を追加しても，副作用が生じるとは予期しない。
◎
In general, developers do not expect the presence of an event listener to be observable. The impact of an event listener is determined by its callback. That is, a developer adding a no-op event listener would not expect it to have any side effects.
</p>

<p>
あいにく，一部の~event~APIは、
効率的に実装するためには，`~event~listener$を観測することが要求される設計になっている。
すなわち、
何もしない~listenerであっても，~appの挙動における処理能に劇的に影響iし得る結果、
~listenerの有無が観測-可能になっている。
例えば ~touch／~wheel ~eventの利用は、
非同期~scrollingを阻むことがある。
一部の事例では、［
~eventが $cancelable になるのは， $AddEventListenerOptions.passive でない~listenerが 1 個~以上あるときに限る
］ように指定することで，この問題を軽減できる。
例えば、
$AddEventListenerOptions.passive でない $TouchEvent ~listenerは，~scrollingを阻まなければならないが、
どの~listenerも $AddEventListenerOptions.passive であれば，［
$TouchEvent を（ $preventDefault() の~callは無視されるように）取消せなくすることで，~scrollingを`並列的$に開始できる
］ようになる。
~eventを配送している~codeは、
そのように $AddEventListenerOptions.passive でない~listenerが無いことを観測でき，それを利用して配送している~eventの $cancelable ~propを ~F にできる。
◎
Unfortunately, some event APIs have been designed such that implementing them efficiently requires observing event listeners. This can make the presence of listeners observable in that even empty listeners can have a dramatic performance impact on the behavior of the application. For example, touch and wheel events which can be used to block asynchronous scrolling. In some cases this problem can be mitigated by specifying the event to be cancelable only when there is at least one non-passive listener. For example, non-passive TouchEvent listeners must block scrolling, but if all listeners are passive then scrolling can be allowed to start in parallel by making the TouchEvent uncancelable (so that calls to preventDefault() are ignored). So code dispatching an event is able to observe the absence of non-passive listeners, and use that to clear the cancelable property of the event being dispatched.
</p>

<p>
新たな~event~APIは、
この~propを必要としないように定義されるのが理想的である
（論を交わしたければ、
`whatwg/dom＠https://github.com/whatwg/dom/issues$
を利用されたし）。
◎
Ideally, any new event APIs are defined such that they do not need this property. (Use whatwg/dom for discussion.)
</p>

<div class="algo">
<p>
`~sw~fetch~event~listener~callback群を得する旧来の手続き@
は、
所与の
( $ServiceWorkerGlobalScope %大域~obj )
に対し，［
$EventListener ~objたちが成す`~list$
］を返す：
◎
To legacy-obtain service worker fetch event listener callbacks given a ServiceWorkerGlobalScope global, run these steps. They return a list of EventListener objects.
</p>
<ol>
	<li>
%~callback群 ~LET « »
◎
Let callbacks be « ».
</li>
	<li>
%大域~obj の`~event~listener~list$を成す
~EACH( %~listener )
に対し
⇒
~IF［
%~listener の`型$evL ~EQ `fetch^l
］~AND［
%~listener の`~callback$evL ~NEQ ~NULL
］
⇒
%~callback群 に %~listener の`~callback$evLを`付加する$
◎
For each listener of global’s event listener list:＼
if listener’s type is "fetch" and listener’s callback is non-null, then append listener’s callback to callbacks.
</li>
	<li>
~RET %~callback群
◎
Return callbacks.
</li>
</ol>
</div>

		</section>
		<section id="dispatching-events">
<h3 title="Dispatching events">2.9. ~eventの配送-法</h3>

<!-- ^@Event -->
<div class="algo">
<p>
`~eventを配送する@
~algoは、
所与の
( %~target, `~event$ %~event, %~targetを上書きするか ~IN { `~targetを上書きする^i, ε } ~DF ε )
に対し：
◎
To dispatch an event to a target, with an optional legacy target override flag and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>

<p class="trans-note">【
この手続きは、
“%~target に向けて（~eventを）配送する”
のような形の句でも参照される
（例えば，地の文の中で）。
】</p>

<p class="trans-note">【
原文では，省略可能な引数として［
`INDEXEDDB$r のみから利用される %legacyOutputDidListenersThrowFlag
］も
— 参照渡しとして —
とるが、
この訳では，［
その仕様に定義される関連な~eventに`（旧来の）~listenerは投出したか$を結付ける
］よう定義することにより［
この引数の受け渡しに関する記述
］を`簡素化する＠#_legacyOutputDidListenersThrowFlag$。
】</p>

<ol>
	<li>
%~event の`配送-中か$ev ~SET ~T
◎
Set event’s dispatch flag.
</li>
	<li>
<p>
%上書きする~target ~LET %~targetを上書きするか に応じて
⇒＃
`~targetを上書きする^i ならば %~target に`結付けられた文書$ `HTML$r ／
ε ならば %~target
◎
Let targetOverride be target, if legacy target override flag is not given, and target’s associated Document otherwise. [HTML]
</p>

<p class="note">注記：
%~targetを上書きするか は，旧来の~flagであり、
~HTMLからのみ, それも %~target が $Window ~objである場合に限り，非 ε にされる。
◎
legacy target override flag is only used by HTML and only when target is a Window object.
</p>
	</li>
	<li>
%作動化~target ~LET ~NULL
◎
Let activationTarget be null.
</li>
	<li>
%関係する~target ~LET %~event の`関係する~target$を %~target に向けて`~targetし直す$
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against target.
</li>
	<li>
%~targetたちを~clearするか ~LET ~F
◎
Let clearTargets be false.
</li>
	<li>
<p>
~IF［
%~target ~NEQ %関係する~target
］~OR［
%~target ~EQ %~event の`関係する~target$
］：
◎
If target is not relatedTarget or target is event’s relatedTarget:
</p>
		<ol>
			<li>
%~touch~target群 ~LET « »
◎
Let touchTargets be a new list.
</li>
			<li>
%~event の`~touch~target~list$を成す
~EACH( %~touch~target )
に対し
⇒
%~touch~target群 に次の結果を`付加する$
⇒
%~touch~target を %~target に向けて`~targetし直す$
◎
For each touchTarget of event’s touch target list:＼
append the result of retargeting touchTarget against target to touchTargets.
</li>
			<li>
`~event経路に付加する$( ↓ )
⇒＃
%~event,
%~target,
%上書きする~target,
%関係する~target,
%~touch~target群,
~F
◎
Append to an event path with event, target, targetOverride, relatedTarget, touchTargets, and false.
</li>
			<li>
%作動化~eventか ~LET ~IS［
%~event は $MouseEvent ~objである
］~AND［
%~event の $type 属性 ~EQ `click^l
］
◎
Let isActivationEvent be true, if event is a MouseEvent object and event’s type attribute is "click"; otherwise false.
</li>
			<li>
~IF［
%作動化~eventか ~EQ ~T
］~AND［
%~target には`作動化の挙動$が有る
］
⇒
%作動化~target ~SET %~target
◎
If isActivationEvent is true and target has activation behavior, then set activationTarget to target.
</li>
			<li>
%~slot可能 ~LET［
次が満たされるならば %~target ／
~ELSE_ ~NULL
］
⇒
［
%~target は`~slot可能$である
］~AND［
%~target の`割当-先~slot$ ~NEQ ~NULL
］
◎
Let slottable be target, if target is a slottable and is assigned, and null otherwise.
</li>
			<li>
%~slotは閉な~tree内か ~LET ~F
◎
Let slot-in-closed-tree be false.
</li>
			<li>
%親 ~LET
%~target の`親~targetを取得する$( %~event )
◎
Let parent be the result of invoking target’s get the parent with event.
</li>
			<li>
<p>
~WHILE［
%親 ~NEQ ~NULL
］：
◎
While parent is non-null:
</p>
				<ol>
					<li>
<p>
~IF［
%~slot可能 ~NEQ ~NULL
］：
◎
If slottable is non-null:
</p>
						<ol>
							<li>
~Assert：
%親 は`~slot$である
◎
Assert: parent is a slot.
</li>
							<li>
%~slot可能 ~SET ~NULL
◎
Set slottable to null.
</li>
							<li>
~IF［
%親 の`根$は［
`~shadow根$である
］~AND［
`~mode$sR ~EQ `closed^l
］を満たす
］
⇒
%~slotは閉な~tree内か ~SET ~T
◎
If parent’s root is a shadow root whose mode is "closed", then set slot-in-closed-tree to true.
</li>
						</ol>
					</li>
					<li>
~IF［
%親 は`~slot可能$である
］~AND［
%親 の`割当-先~slot$ ~NEQ ~NULL
］
⇒
%~slot可能 ~SET %親
◎
If parent is a slottable and is assigned, then set slottable to parent.
</li>
					<li>
%関係する~target ~LET %関係する~target を %親 に向けて`~targetし直す$
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against parent.
</li>
					<li>
%~touch~target群 ~LET « »
◎
Let touchTargets be a new list.
</li>
					<li>
%~event の`~touch~target~list$を成す
~EACH( %~touch~target )
に対し
⇒
%~touch~target群 に次の結果を`付加する$
⇒
%~touch~target を %親 に向けて`~targetし直す$
◎
For each touchTarget of event’s touch target list:＼
append the result of retargeting touchTarget against parent to touchTargets.
</li>
					<li>
<p>
~IF［
%親 は $Window ~objである
］~OR［［
%親 は`~node$である
］~AND［
%~target の`根$ は %親 の`~shadowも含めた広義-先祖$である
］］：
◎
If parent is a Window object, or parent is a node and target’s root is a shadow-including inclusive ancestor of parent:
</p>
						<ol>
							<li>
<p>
~IF［
%作動化~eventか ~EQ ~T
］~AND［
%~event の $bubbles 属性 ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%親 には`作動化の挙動$が有る
］
⇒
%作動化~target ~SET %親
◎
If isActivationEvent is true, event’s bubbles attribute is true, activationTarget is null, and parent has activation behavior, then set activationTarget to parent.
</li>
							<li>
`~event経路に付加する$( ↓ )
⇒＃
%~event,
%親,
~NULL,
%関係する~target,
%~touch~target群,
%~slotは閉な~tree内か
◎
Append to an event path with event, parent, null, relatedTarget, touchTargets, and slot-in-closed-tree.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%親 ~EQ %関係する~target
］
⇒
%親 ~SET ~NULL
◎
Otherwise, if parent is relatedTarget, then set parent to null.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
%~target ~SET %親
◎
Set target to parent.
</li>
							<li>
~IF［
%作動化~eventか ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%~target には`作動化の挙動$が有る
］
⇒
%作動化~target ~SET %~target
◎
If isActivationEvent is true, activationTarget is null, and target has activation behavior, then set activationTarget to target.
</li>
							<li>
`~event経路に付加する$( ↓ )
⇒＃
%~event,
%親,
%~target,
%関係する~target,
%~touch~target群,
%~slotは閉な~tree内か
◎
Append to an event path with event, parent, target, relatedTarget, touchTargets, and slot-in-closed-tree.
</li>
						</ol>
					</li>
					<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
%親 ~SET %親 の`親~targetを取得する$( %~event )
◎
If parent is non-null, then set parent to the result of invoking parent’s get the parent with event.
</li>
					<li>
%~slotは閉な~tree内か ~SET ~F
◎
Set slot-in-closed-tree to false.
</li>
				</ol>
			</li>
			<li>
%~target~clear用の構造体 ~LET %~event の`経路$を成す~itemのうち，次を満たす`最後のもの？$
⇒
`~shadow調整-済み~target$evP ~NEQ ~NULL
◎
Let clearTargetsStruct be the last struct in event’s path whose shadow-adjusted target is non-null.
</li>
			<li>
~Assert：
%~target~clear用の構造体 ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
			<li>
<p>
~IF［
~AND↓ を満たす`~node$ %~node は在る
］…
</p>
				<ul>
					<li>
%~node の`根$は`~shadow根$である
</li>
					<li>
<p>
~OR↓
</p>
						<ul>
							<li>
%~node ~EQ %~target~clear用の構造体 の`~shadow調整-済み~target$evP
</li>
							<li>
%~node ~EQ %~target~clear用の構造体 の`関係する~target$evP
</li>
							<li>
%~node ~IN %~target~clear用の構造体 の`~touch~target~list$evP
</li>
						</ul>
					</li>
				</ul>
<p>
…ならば
⇒
%~targetたちを~clearするか ~SET ~T
</p>
◎
If clearTargetsStruct’s shadow-adjusted target, clearTargetsStruct’s relatedTarget, or an EventTarget object in clearTargetsStruct’s touch target list is a node whose root is a shadow root: set clearTargets to true.
</li>
			<li>
~IF［
%作動化~target ~NEQ ~NULL
］~AND［
%作動化~target には`旧来の作動化~前の挙動$が有る
］
⇒
その挙動を走らす
◎
If activationTarget is non-null and activationTarget has legacy-pre-activation behavior, then run activationTarget’s legacy-pre-activation behavior.
</li>
			<li>
<p>
%~event の`経路$を成す
~EACH( %構造体 )
に対し，逆順に：
◎
For each struct of event’s path, in reverse order:
</p>
				<ol>
					<li>
%~event の $eventPhase 属性 ~SET ［
%構造体 の`~shadow調整-済み~target$evP ~NEQ ~NULL ならば $AT_TARGET ／
~ELSE_ $CAPTURING_PHASE
］
◎
If struct’s shadow-adjusted target is non-null, then set event’s eventPhase attribute to AT_TARGET.
◎
Otherwise, set event’s eventPhase attribute to CAPTURING_PHASE.
</li>
					<li>
`~listenerを呼出す$( %構造体, %~event, `capturing^l )
◎
Invoke with struct, event, "capturing", and legacyOutputDidListenersThrowFlag if given.
</li>
				</ol>
			</li>
			<li>
<p>
%~event の`経路$を成す
~EACH( %構造体 )
に対し：
◎
For each struct of event’s path:
</p>
				<ol>
					<li>
~IF［
%構造体 の`~shadow調整-済み~target$evP ~NEQ ~NULL
］
⇒
%~event の $eventPhase 属性 ~SET $AT_TARGET
◎
If struct’s shadow-adjusted target is non-null, then set event’s eventPhase attribute to AT_TARGET.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
~IF［
%~event の $bubbles 属性 ~EQ ~F
］
⇒
~CONTINUE
◎
If event’s bubbles attribute is false, then continue.
</li>
							<li>
%~event の $eventPhase 属性 ~SET $BUBBLING_PHASE
◎
Set event’s eventPhase attribute to BUBBLING_PHASE.
</li>
						</ol>
					</li>
					<li>
`~listenerを呼出す$( %構造体, %~event, `bubbling^l )
◎
Invoke with struct, event, "bubbling", and legacyOutputDidListenersThrowFlag if given.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~event の $eventPhase 属性 ~SET $NONE
◎
Set event’s eventPhase attribute to NONE.
</li>
	<li>
%~event の $currentTarget 属性 ~SET ~NULL
◎
Set event’s currentTarget attribute to null.
</li>
	<li>
%~event の`経路$ ~SET « »
◎
Set event’s path to the empty list.
</li>
	<li>
%~event の
⇒＃
`配送-中か$ev ~SET ~F,
`伝播を停止するか$ev ~SET ~F,
`伝播を即時に停止するか$ev ~SET ~F
◎
Unset event’s dispatch flag, stop propagation flag, and stop immediate propagation flag.
</li>
	<li>
<p>
~IF［
%~targetたちを~clearするか ~EQ ~T
］
⇒
%~event の
⇒＃
`~target$ ~SET ~NULL
`関係する~target$ ~SET ~NULL
`~touch~target~list$ ~SET « »
◎
If clearTargets is true:
• Set event’s target to null.
• Set event’s relatedTarget to null.
• Set event’s touch target list to the empty list.
</li>
	<li>
<p>
~IF［
%作動化~target ~NEQ ~NULL
］：
◎
If activationTarget is non-null:
</p>
		<ol>
			<li>
~IF［
%~event の`取消されたか$ev ~EQ ~F
］
⇒
%作動化~target の`作動化の挙動$( %~event )
◎
If event’s canceled flag is unset, then run activationTarget’s activation behavior with event.
</li>
			<li>
~ELIF［
%作動化~target には`旧来の作動化~取消~時の挙動$が有る
］
⇒
その挙動を走らす
◎
Otherwise, if activationTarget has legacy-canceled-activation behavior, then run activationTarget’s legacy-canceled-activation behavior.
</li>
		</ol>
	</li>
	<li>
~RET ~IS［
%~event の`取消されたか$ev ~EQ ~F
］
◎
Return false if event’s canceled flag is set; otherwise true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~event経路に付加する@
~algoは、
所与の
⇒＃
%~event,
%呼出n~target,
%~shadow調整-済み~target,
%関係する~target,
%~touch~target群,
%~slotは閉な~tree内か
◎終
に対し：
◎
To append to an event path, given an event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, and a slot-in-closed-tree, run these steps:
</p>
<ol>
	<li>
%呼出n~targetは~shadow~tree内か ~LET ~IS［
%呼出n~target は`~node$である
］~AND［
%呼出n~target の`根$は`~shadow根$である
］
◎
Let invocationTargetInShadowTree be false.
◎
If invocationTarget is a node and its root is a shadow root, then set invocationTargetInShadowTree to true.
</li>
	<li>
%閉な~treeの根か ~LET ~IS［
%呼出n~target は`~shadow根$である
］~AND［
%呼出n~target の`~mode$sR ~EQ `closed^l
］
◎
Let root-of-closed-tree be false.
◎
If invocationTarget is a shadow root whose mode is "closed", then set root-of-closed-tree to true.
</li>
	<li>
%~event の`経路$に次を`付加する$
⇒
新たな`構造体$
— その
⇒＃
`呼出n~target$evP ~SET %呼出n~target,
`呼出n~targetは~shadow~tree内か$evP ~SET %呼出n~targetは~shadow~tree内か
`~shadow調整-済み~target$evP ~SET %~shadow調整-済み~target,
`関係する~target$evP ~SET %関係する~target,
`閉な~treeの根か$evP ~SET %閉な~treeの根か,
`~touch~target~list$evP ~SET %~touch~target群
`~slotは閉な~tree内か$evP ~SET %~slotは閉な~tree内か
◎
Append a new struct to event’s path whose invocation target is invocationTarget, invocation-target-in-shadow-tree is invocationTargetInShadowTree, shadow-adjusted target is shadowAdjustedTarget, relatedTarget is relatedTarget, touch target list is touchTargets, root-of-closed-tree is root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.
</li>
</ol>
</div>

<div class="algo">
<p>
`~listenerを呼出す@
~algoは、
所与の
( %構造体, %~event, %相 )
に対し：
◎
To invoke, given a struct, event, phase, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>
<ol>
	<li>
%~event の`~target$ ~SET ［
%~event の`経路$内の［
%構造体 または %構造体 に先行する構造体
］のうち，［
`~shadow調整-済み~target$evP ~NEQ ~NULL
］を満たすもののうち，最後の構造体
］の`~shadow調整-済み~target$evP
◎
Set event’s target to the shadow-adjusted target of the last struct in event’s path, that is either struct or preceding struct, whose shadow-adjusted target is non-null.
</li>
	<li>
%~event の`関係する~target$ ~SET %構造体 の`関係する~target$evP
◎
Set event’s relatedTarget to struct’s relatedTarget.
</li>
	<li>
%~event の`~touch~target~list$ ~SET %構造体 の`~touch~target~list$evP
◎
Set event’s touch target list to struct’s touch target list.
</li>
	<li>
~IF［
%~event の`伝播を停止するか$ev ~EQ ~T
］
⇒
~RET
◎
If event’s stop propagation flag is set, then return.
</li>
	<li>
%~event の $currentTarget 属性 ~SET %構造体 の`呼出n~target$evPに初期化する
◎
Initialize event’s currentTarget attribute to struct’s invocation target.
</li>
	<li>
<p>
%~listener群 ~LET %構造体 の`呼出n~target$evPの`~event~listener~list$を`~cloneする$
◎
Let listeners be a clone of event’s currentTarget attribute value’s event listener list.
</p>

<p class="note">注記：
これは、
この時点以降に追加された~event~listenerは，走らせないようにする。
除去については、
`除去-済みか$evL ~fieldに因り，依然として効果を及ぼすことに注意。
◎
This avoids event listeners added after this point from being run. Note that removal still has an effect due to the removed field.
</p>
	</li>
	<li>
%呼出n~targetは~shadow~tree内か ~LET %構造体 の`呼出n~targetは~shadow~tree内か$evP
◎
Let invocationTargetInShadowTree be struct’s invocation-target-in-shadow-tree.
</li>
	<li>
%見出されたか ~LET `~listenerを内的に呼出す$( ↓ )
⇒＃
%~event,
%~listener群,
%相,
%呼出n~targetは~shadow~tree内か
◎
Let found be the result of running inner invoke with event, listeners, phase, invocationTargetInShadowTree, and legacyOutputDidListenersThrowFlag if given.
</li>
	<li>
<p>
~IF［
%見出されたか ~EQ ~F
］~AND［
%~event の $isTrusted 属性 ~EQ ~T
］~AND［
%~event の $type 属性~値は［
下の表tの 1 列目に挙げるいずれかの文字列
］に `~ASCII大小無視$で合致する
］…
◎
If found is false and event’s isTrusted attribute is true:
◎
Let originalEventType be event’s type attribute value.
◎
If event’s type attribute value is a match for any of the strings in the first column in the following table, set event’s type attribute value to the string in the second column on the same row as the matching string, and return otherwise.
</p>

<table><thead>
<tr><th>
~event型
◎
Event type
<th>
旧来の~event型
◎
Legacy event type
<tbody>

<tr><td>`animationend^l
<td>`webkitAnimationEnd^l

<tr><td>`animationiteration^l
<td>`webkitAnimationIteration^l

<tr><td>`animationstart^l
<td>`webkitAnimationStart^l

<tr><td>`transitionend^l
<td>`webkitTransitionEnd^l
</table>

<p>
…ならば：
</p>
		<ol>
			<li>
%元の~event型 ~LET %~event の $type 属性~値
◎
↑</li>
			<li>
%~event の $type 属性 ~SET 合致した行の 2 列目に与える文字列
◎
↑</li>
			<li>
`~listenerを内的に呼出す$( ↓ )
⇒＃
%~event,
%~listener群,
%相,
%呼出n~targetは~shadow~tree内か
◎
Inner invoke with event, listeners, phase, invocationTargetInShadowTree, and legacyOutputDidListenersThrowFlag if given.
</li>
			<li>
%~event の $type 属性 ~SET %元の~event型
◎
Set event’s type attribute value to originalEventType.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~listenerを内的に呼出す@
~algoは、
所与の
⇒＃
%~event,
%~listener群,
%相,
%呼出n~targetは~shadow~tree内か
◎終
に対し：
◎
To inner invoke, given an event, listeners, phase, invocationTargetInShadowTree, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>
<ol>
	<li>
%見出されたか ~LET ~F
◎
Let found be false.
</li>
	<li>
<p>
%~listener群 を成す
~EACH( `~event~listener$ %~listener )
に対し：
◎
For each listener of listeners, whose removed is false:
</p>
		<ol>
			<li>
~IF［
%~listener の`除去-済みか$evL ~EQ ~T
］
⇒
~CONTINUE
◎
↑</li>
			<li>
~IF［
%~listener の`型$evL ~NEQ %~event の $type 属性~値
］
⇒
~CONTINUE
◎
If event’s type attribute value is not listener’s type, then continue.
</li>
			<li>
%見出されたか ~SET ~T
◎
Set found to true.
</li>
			<li>
~IF［
%相 ~EQ `capturing^l
］~AND［
%~listener の`捕捉するか$evL ~EQ ~F
］
⇒
~CONTINUE
◎
If phase is "capturing" and listener’s capture is false, then continue.
</li>
			<li>
~IF［
%相 ~EQ `bubbling^l
］~AND［
%~listener の`捕捉するか$evL ~EQ ~T
］
⇒
~CONTINUE
◎
If phase is "bubbling" and listener’s capture is true, then continue.
</li>
			<li>
~IF［
%~listener の`一度限りか$evL ~EQ ~T
］
⇒
`~event~listenerを除去する$( %~event の $currentTarget 属性~値, %~listener )
◎
If listener’s once is true, then remove an event listener given event’s currentTarget attribute value and listener.
</li>
			<li>
%大域~obj ~LET %~listener の`~callback$evLが`属する~realm$の`大域~obj$rM
◎
Let global be listener callback’s associated realm’s global object.
</li>
			<li>
%現在の~event ~LET $undefined
◎
Let currentEvent be undefined.
</li>
			<li>
<p>
~IF［
%大域~obj は $Window ~objである
］：
◎
If global is a Window object:
</p>
				<ol>
					<li>
%現在の~event ~SET %大域~obj の`現在の~event$
◎
Set currentEvent to global’s current event.
</li>
					<li>
~IF［
%呼出n~targetは~shadow~tree内か ~EQ ~F
］
⇒
%大域~obj の`現在の~event$ ~SET %~event
◎
If invocationTargetInShadowTree is false, then set global’s current event to event.
</li>
				</ol>
			</li>
			<li>
~IF［
%~listener の`受動的か$evL ~EQ ~T
］
⇒
%~event の`受動-~listener内か$ev ~SET ~T
◎
If listener’s passive is true, then set event’s in passive listener flag.
</li>
			<li>
~IF［
%大域~obj は $Window ~objである
］
⇒
`~event~listener用に計時~報を記録する$( %~event, %~listener )
◎
If global is a Window object, then record timing info for event listener given event and listener.
</li>
			<li>
<p>
`利用元~objの演算を~callする$( ↓ )
⇒＃
%~listener の`~callback$evL,
`handleEvent^l,
« %~event »,
%~event の$currentTarget 属性~値
◎
Call a user object’s operation with listener’s callback, "handleEvent", « event », and event’s currentTarget attribute value.＼
</p>

<p>
例外 %例外 が投出されたときは、
~catchして：
◎
If this throws an exception exception:
</p>
				<ol>
					<li>
`例外を報告する$( %例外, %~listener の`~callback$evLに対応する~JS~objが`属する~realm$の`大域~obj$rM )
◎
Report exception for listener’s callback’s corresponding JavaScript object’s associated realm’s global object.
</li>
					<li>
<p id="_legacyOutputDidListenersThrowFlag">
~IF［
%~event には`（旧来の）~listenerは投出したか$が結付けられている
］
⇒
%~event の`（旧来の）~listenerは投出したか$ ~SET ~T
◎
Set legacyOutputDidListenersThrowFlag if given.
</p>

<p class="note">注記：
`INDEXEDDB$r のみが、
これを利用する。
◎
The legacyOutputDidListenersThrowFlag is only used by Indexed Database API. [INDEXEDDB]
</p>
					</li>
				</ol>
			</li>
			<li>
%~event の`受動-~listener内か$ev ~SET ~F
◎
Unset event’s in passive listener flag.
</li>
			<li>
~IF［
%大域~obj は $Window ~objである
］
⇒
%大域~obj の`現在の~event$ ~SET %現在の~event
◎
If global is a Window object, then set global’s current event to currentEvent.
</li>
			<li>
~IF［
%~event の`伝播を即時に停止するか$ev ~EQ ~T
］
⇒
~BREAK
◎
If event’s stop immediate propagation flag is set, then break.
</li>
		</ol>
	</li>
	<li>
~RET %見出されたか
◎
Return found.
</li>
</ol>
</div>

		</section>
		<section id="firing-events">
<h3 title="Firing events">2.10. ~eventの発火-法</h3>

<div class="algo">
<div class="p">
<p>
`~eventを発火する@
~algoは、
所与の
( %~target, 名前 %e, %~event構築子 ~DF $@Event のそれ† )
および所与の…
</p>
<ul>
	<li>
%~targetを上書きするか ~IN { `~targetを上書きする^i, ε } ~DF ε 
</li>
	<li>
<p>
%記述
— ［
~eventの各~IDL属性を どう初期化するか
］についての記述（省略時は何もしない）
</p>

<p class="trans-note">【
これは、
~IDL属性~以外の~prop（例： `~composedか$ev ）を初期化する記述を含む場合もある。
】</p>
</li>
</ul>

<p class="trans-note">【†
%~event構築子 には、
（省略されない場合は）ほぼすべての事例で，単に~interfaceが渡される
— その場合、
当の~interfaceの唯一の構築子として解釈する。
】</p>

<p class="trans-note">【
この手続きは、
“%~target に向けて名前 %e の~eventを発火する”
のような形の句でも参照される
（例えば、
地の文の中で）。
】</p>

<p>
…に対し：
</p>
◎
To fire an event named e at target, optionally using an eventConstructor, with a description of how IDL attributes are to be initialized, and a legacy target override flag, run these steps:
• If eventConstructor is not given, then let eventConstructor be Event.
</div>
<ol>
	<li>
%~event ~LET
`~eventを作成する$( %~event構築子, %~target に`関連な~realm$ )
◎
Let event be the result of creating an event given eventConstructor, in the relevant realm of target.
</li>
	<li>
%~event の $type 属性 ~SET %e に初期化する
◎
Initialize event’s type attribute to e.
</li>
	<li>
<p>
%~event の各種~IDL属性を %記述 に従って初期化する
◎
Initialize any other IDL attributes of event as described in the invocation of this algorithm.
</p>

<p class="note">注記：
ここでは［
$isTrusted 属性 ~SET ~F
］にすることも許容される。
◎
This also allows for the isTrusted attribute to be set to false.
</p>
	</li>
	<li>
~RET `~eventを配送する$( %~target, %~event, %~targetを上書きするか )
◎
Return the result of dispatching event at target, with legacy target override flag set if set.
</li>
</ol>

<p class="note">注記：
~DOMの文脈における
“`~eventを発火する$”
とは、
`~event$を［
`作成-＠#concept-event-create$して, 初期化して, `配送-$する
］ことの略語であり，この処理nを容易に書けるようにするためにある。
◎
Fire in the context of DOM is short for creating, initializing, and dispatching an event. Fire an event makes that process easier to write down.
</p>
</div>

<div class="example" id="firing-events-example">

<p>
`~event$の［
$bubbles や $cancelable
］などの属性も初期化する必要がある場合、
次のようにも書ける
⇒
`~eventを発火する$( %~target, `submit^et )
— 次のように初期化して
⇒
^cancelable 属性 ~SET ~T
◎
If the event needs its bubbles or cancelable attribute initialized, one could write "fire an event named submit at target with its cancelable attribute initialized to true".
</p>

<p>
あるいは，~customな構築子も必要なときは、
次のように書く, 等々
⇒
`~eventを発火する$( %~target, `click^et, $MouseEvent )
— 次のように初期化して
⇒
`detail$m 属性 ~SET 1
◎
Or, when a custom constructor is needed, "fire an event named click at target using MouseEvent with its detail attribute initialized to 1".
</p>

<p>
ときには、
返り値が重要になることもある：
◎
Occasionally the return value is important:
</p>
<ol>
	<li>
%何かするか ~LET `~eventを発火する$( %~target, `like^et )
◎
Let doAction be the result of firing an event named like at target.
	</li>
	<li>
~IF［
%何かするか ~EQ ~T
］
⇒
…
◎
If doAction is true, then …
	</li>
</ol>
</div>

		</section>
		<section id="action-versus-occurrence">
<h3 title="Action versus occurrence">2.11. 動作 vs. ~~発生</h3>

<p>
`~event$は、
動作（ `action^en ）ではなく，
何かが生じたこと（ `occurrence^en ）をしるす（徴す／ `signify^en する）ものである。
言葉を代えれば、
ある~algoからの通知を表現し，その~algoの未来の進路に
（例えば $preventDefault() を呼出すことを通して）
波及させるために利用できるものである。
`~event$は、
何らかの~algoを走らすような［
動作, あるいは動作を起動するもの
］として利用されてはナラナイ。
そのような用途にあるものではない。
◎
An event signifies an occurrence, not an action. Phrased differently, it represents a notification from an algorithm and can be used to influence the future course of that algorithm (e.g., through invoking preventDefault()). Events must not be used as actions or initiators that cause some algorithm to start running. That is not what they are for.
</p>

<p class="note">注記：
ここで特定的に~~強調している~~理由は、
以前の~DOMでは，`~event$に “既定~動作” の概念が結付けられていて，人を誤った考えに~~導いていたからである。
`~event$は、
動作を表現したり生じさせるものではなく，進行中な何かに波及させるために限り利用できるものである。
◎
This is called out here specifically because previous iterations of the DOM had a concept of "default actions" associated with events that gave folks all the wrong ideas. Events do not represent or cause actions, they can only be used to influence an ongoing one.
</p>

		</section>
	</section>
	<section id="aborting-ongoing-activities">
<h2 title="Aborting ongoing activities">3. 進行中な活動の中止-法</h2>

<!-- ^@AbortController -->
<p>
~promiseには，中止するための組込みの仕組みがないが、
それを利用している多くの~APIは，中止-の意味論を要求している。
$AbortController には、
その要件を~supportすることが意味される。
それが供する $abort() ~methodは、
$AbortController に対応している $AbortSignal ~objの状態を~toggleする。
中止-法を~supportするよう望む~APIは、
この~objを受容して, その状態を利用することにより，どう続行するか決定できる。
◎
Though promises do not have a built-in aborting mechanism, many APIs using them require abort semantics. AbortController is meant to support these requirements by providing an abort() method that toggles the state of a corresponding AbortSignal object. The API which wishes to support aborting can accept an AbortSignal object, and use its state to determine how to proceed.
</p>

<p>
$AbortController に依拠する~APIは、［
$AbortSignal の`中止-事由$aBで未決着な~promiseを却下する
］ことにより，
$abort() に応答することが奨励される。
◎
APIs that rely upon AbortController are encouraged to respond to abort() by rejecting any unsettled promise with the AbortSignal’s abort reason.
</p>

<div class="example" id="aborting-ongoing-activities-example">
<p>
~method 
`doAmazingness({ ... })^c
は、
何か “すごいこと” を行うとする。
この~methodは、
$AbortSignal ~objを受容して，次のように中止-法を~supportできる：
◎
A hypothetical doAmazingness({ ... }) method could accept an AbortSignal object to support aborting as follows:
</p>

<pre class="lang-js">
const %controller = new AbortController();
const %signal = %controller.signal;

startSpinner();

doAmazingness({ ..., %signal })
  .then(%result =&gt; ...)
  .catch(%err =&gt; {
    if (%err.name == 'AbortError') return;
    showUserErrorMessage();
  })
  .then(() =&gt; stopSpinner());

// …

%controller.abort();
</pre>

<p>
^doAmazingness は、
次のように実装することもできる：
◎
doAmazingness could be implemented as follows:
</p>

<pre class="lang-js">
function doAmazingness({%signal}) {
  return new Promise((%resolve, %reject) =&gt; {
    %signal.throwIfAborted();

    /* <span class="comment">
“すごいこと” を行うのを始める
— 済んだなら %resolve(%result) を~callする。
加えて、
%signal も注視する。
◎
Begin doing amazingness, and call resolve(result) when done.
But also, watch for signals:
</span> */
    %signal.addEventListener('abort', () =&gt; {
      /* <span class="comment">
“すごいこと” を行うのを停止してから：
◎
Stop doing amazingness, and:
</span> */
      %reject(%signal.reason);
    });
  });
}
</pre>
</div>

<p>
~promiseを返さない【が非同期な挙動を伴う】~APIは、
次のいずれかにし得る：
◎
APIs that do not return promises can either＼
</p>
<ul>
	<li>
【~promiseを返す~versionと】
等価な方式で反応する。
◎
react in an equivalent manner＼
</li>
	<li>
$AbortSignal の`中止-事由$aBをまったく表に出さないようにする
— $EventTarget.addEventListener() は、
こうする方がイミを成す~APIの例である。
◎
or opt to not surface the AbortSignal’s abort reason at all.＼
addEventListener() is an example of an API where the latter made sense.
</li>
</ul>

<p>
より精細な制御を要する~APIは、
必要に応じて［
$AbortController, $AbortSignal
］両~objを拡張することもできる。
◎
APIs that require more granular control could extend both AbortController and AbortSignal objects according to their needs.
</p>

		<section id="interface-abortcontroller">
<h3 title="Interface AbortController">3.1. ^@AbortController ~interface</h3>

！！
 `Exposed$=*]
interface @AbortController {
  `AbortController$mc();
  [`SameObject$] readonly attribute $AbortSignal $signal;

  $undefined $abort(optional $any %reason);
};
！

<dl class="domintro">
	<dt>%controller  = $AbortController()</dt>
	<dd>
新たな %controller を，その $signal を［
新たな $AbortSignal ~obj
］に設定した上で返す。
◎
Returns a new controller whose signal is set to a newly created AbortSignal object.
</dd>

	<dt>%controller . $signal</dt>
	<dd>
この~objに結付けられた $AbortSignal ~objを返す。
◎
Returns the AbortSignal object associated with this object.
</dd>
	<dt>%controller . $abort(reason)</dt>
	<dd>
この~methodを呼出すと、
この~objの $AbortSignal の`中止-事由$aB %reason を格納した上で、
結付けられた活動が中止されることになるよう，観測器たちにも通達することになる。
%reason が ε の場合（省略したか明示的に `undefined^jv を与えた場合）、
`AbortError$E 例外が格納されることになる。
◎
Invoking this method will store reason in this object’s AbortSignal’s abort reason, and signal to any observers that the associated activity is to be aborted. If reason is undefined, then an "AbortError" DOMException will be stored.
</dd>
</dl>

<p>
各 $AbortController ~objには、
`通達@aC
（ $AbortSignal ~obj）が結付けられる。
◎
An AbortController object has an associated signal (an AbortSignal object).
</p>

<div class="algo">
<p>
@AbortController()
構築子~手続きは
⇒
コレの`通達$aC ~SET `新たな~obj$( $AbortSignal )
◎
The new AbortController() constructor steps are:
• Let signal be a new AbortSignal object.
• Set this’s signal to signal.
</div>

<div class="algo">
@signal
取得子~手続きは
⇒
~RET コレの`通達$aC
◎
The signal getter steps are to return this’s signal.
</div>

<div class="algo">
@abort(reason)
~method手続きは
⇒
`中止-を通達する$aC( コレ, %reason )
◎
The abort(reason) method steps are to signal abort on this with reason if it is given.
</div>

<div class="algo">
<p>
`中止-を通達する@aC
~algoは、
所与の
( $AbortController %制御器, %事由 ~DF ε )
に対し
⇒
`中止-を通達する$aB( %制御器 の`通達$aC, %事由 )
◎
To signal abort on an AbortController controller with an optional reason, signal abort on controller’s signal with reason if it is given.
</p>
</div>


		</section>
		<section id="interface-AbortSignal">
<h3 title="Interface AbortSignal">3.2. ^@AbortSignal ~interface</h3>

！！
[`Exposed$=*]
interface @AbortSignal : $EventTarget {
  [`NewObject$] static $AbortSignal $abort(optional $any %reason);
  [`Exposed$=(Window,Worker), `NewObject$] static $AbortSignal $timeout([`EnforceRange$] `unsigned long long$ %milliseconds);
  [`NewObject$] static $AbortSignal `_any＠#dom-abortsignal-any$($sequence&lt;$AbortSignal&gt; %signals);

  readonly attribute $boolean $aborted;
  readonly attribute $any $reason;
  $undefined $throwIfAborted();

  attribute $EventHandler $onabort;
};
！

<dl class="domintro">
	<dt>AbortSignal . $abort(reason)</dt>
	<dd>
$AbortSignal ~instanceを返す
— その`中止-事由$aBは［
%reason が ε の場合（省略したか明示的に `undefined^jv を与えた場合）は `AbortError$E 例外／
~ELSE_ %reason
］に設定される。
◎
Returns an AbortSignal instance whose abort reason is set to reason if not undefined; otherwise to an "AbortError" DOMException.
</dd>

	<dt>AbortSignal . $any(signals)</dt>
	<dd>
$AbortSignal ~instanceを返す
— %signals を成す いずれかの $AbortSignal ~instanceが中止されたなら中止されるような。
その`中止-事由$aBは、
中止された $AbortSignal の`中止-事由$aBに設定されることになる。
◎
Returns an AbortSignal instance which will be aborted once any of signals is aborted. Its abort reason will be set to whichever one of signals caused it to be aborted.
</dd>

	<dt>AbortSignal . $timeout(milliseconds)</dt>
	<dd>
$AbortSignal ~instanceを返す
— それは、
%milliseconds ~milli秒後に中止され，
その`中止-事由$aBは `TimeoutError$E 例外に設定されることになる。
◎
Returns an AbortSignal instance which will be aborted in milliseconds milliseconds. Its abort reason will be set to a "TimeoutError" DOMException.
</dd>

	<dt>%signal . $aborted</dt>
	<dd>
%signal の $AbortController が中止するよう通達されて［
いれば ~T ／
いなければ ~F
］を返す。
◎
Returns true if signal’s AbortController has signaled to abort; otherwise false.
</dd>

	<dt>%signal . $reason</dt>
	<dd>
%signal の`中止-事由$aBを返す。
◎
Returns signal’s abort reason.
</dd>

	<dt>%signal . $throwIfAborted()</dt>
	<dd>
%signal の $AbortController が中止するよう通達された場合、
%signal の`中止-事由$aBを投出する
— 他の場合は何もしない。
◎
Throws signal’s abort reason, if signal’s AbortController has signaled to abort; otherwise, does nothing.
</dd>
</dl>

<p>
各 $AbortSignal ~obj %通達 には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`中止-事由@aB
⇒
~JS値
— 初期~時は `undefined^jv とする。
【通例的には、中止-時に例外~objに設定される。】
◎
An AbortSignal object has an associated abort reason (a JavaScript value), which is initially undefined.
</li>
	<li>
<p>
`中止する~algo群@aB
⇒
~algoたちが成す`有順序~集合$
— 初期~時は`空$とする。
これらの~algoは、
%通達 が`中止-済み$aBになるとき，実行されることになる。
◎
An AbortSignal object has associated abort algorithms, (a set of algorithms which are to be executed when it is aborted), which is initially empty.
</p>

<p class="trans-note">【
集合なので，同じ~algoは重ねて現れ得ないことになるが、
“同じ” がどう定義されるかは，
“`通達に~algoを追加する$” を利用する他の仕様を見ないとはっきりしない
（おそらく、
手続き自体は同じでも，呼出nごとに異なるものとして扱われるように思われるが）。
】</p>

<p class="note">注記：
`中止する~algo群$aBは、
複階的な要件を伴う~APIが，
$abort() に対し適度な仕方で反応することを可能化する。
例えば，所与の~APIの`中止-事由$aBは、
~swなどの別~thread環境へ伝播する必要があるかもしれない。
◎
The abort algorithms enable APIs with complex requirements to react in a reasonable way to abort(). For example, a given API’s abort reason might need to be propagated to a cross-thread environment, such as a service worker.
</p>
	</li>
	<li>
<p>
`依存か@aB
⇒
真偽値
— 初期~時は ~F とする。
</p>

<p class="trans-note">【
~T ならば、
%通達 が “依存して” いる他の $AbortSignal ~objがあり得る
（それでも、無い場合はあり得る）
— すなわち、
後者が中止されるに伴い， %通達 も中止される。
】</p>

◎
An AbortSignal object has a dependent (a boolean), which is initially false.
</li>
	<li>
`~source通達~群@aB
⇒
［
`中止-済み$aBな状態に関して， %通達 が依存している $AbortSignal ~obj
］たちが成す弱い`集合$†
— 初期~時は空とする。
◎
An AbortSignal object has associated source signals (a weak set of AbortSignal objects that the object is dependent on for its aborted state), which is initially empty.
</li>
	<li>
`依存~通達~群@aB
⇒
［
`中止-済み$aBな状態に関して，
%通達 に依存している $AbortSignal ~obj
］たちが成す弱い`集合$†
— 初期~時は空とする。
◎
An AbortSignal object has associated dependent signals (a weak set of AbortSignal objects that are dependent on the object for their aborted state), which is initially empty.
</li>
</ul>

<p class="trans-note">【†
“弱い集合（ `weak set^en ）” とは、
その名前から，~JSの `WeakSet^c
（`参考＠https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WeakSet$）
の意味論に従うことが意図されていると思われる。
弱い集合~内の~objは、
~garbage収集されるに伴い，当の集合から自動的に除去される
（ことになろう
— 以下に定義される仕様~levelの各~algoにおいて、
これらの集合に付加する演算は現れるが，除去する演算は現れないので）。
】</p>

<hr>

<div class="algo">
<p>
静的な
@abort(reason)
~method手続きは：
◎
The static abort(reason) method steps are:
</p>
<ol>
	<li>
%通達 ~LET `新たな~obj$( $AbortSignal )
◎
Let signal be a new AbortSignal object.
</li>
	<li>
%通達 の`中止-事由$aB ~SET %reason に応じて
⇒＃
ε ならば新たな `AbortError$E 例外 ／
~ELSE_ %reason
◎
Set signal’s abort reason to reason if it is given; otherwise to a new "AbortError" DOMException.
</li>
	<li>
~RET %通達
◎
Return signal.
</li>
</ol>
</div>

<div class="algo">
<p>
静的な
@timeout(milliseconds)
~method手続きは：
◎
The static timeout(milliseconds) method steps are:
</p>
<ol>
	<li>
%通達 ~LET `新たな~obj$( $AbortSignal )
◎
Let signal be a new AbortSignal object.
</li>
	<li>
%大域~obj ~LET %通達 に`関連な大域~obj$
◎
Let global be signal’s relevant global object.
</li>
	<li>
<p>
`手続きを~timeout後に走らす$( %大域~obj, `AbortSignal-timeout^l, %milliseconds, 次の手続き )
◎
Run steps after a timeout given global, "AbortSignal-timeout", milliseconds, and the following step:
</p>

<div class="algo">
<p>
手続きは
⇒
`大域~taskを~queueする$( `~timer~task~source$, %大域~obj, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`中止-を通達する$aB( %通達, 新たな `TimeoutError$E 例外 )
</div>
◎
• Queue a global task on the timer task source given global to signal abort given signal and a new "TimeoutError" DOMException.
</div>

<p>
この~timeoutまでの間は、
%通達 の `abort$et ~event用に~event~listenerが登録されている限り，
%大域~obj から %通達 への強い参照があるモノトスル。
◎
For the duration of this timeout, if signal has any event listeners registered for its abort event, there must be a strong reference from global to signal.
</p>
	</li>
	<li>
~RET %通達
◎
Return signal.
</li>
</ol>
</div>

<div class="algo">
<p>
静的な
@any(signals)
~method手続きは
⇒
~RET `依存~中止-通達を作成する$( %signals, $AbortSignal, `現在の~realm$ )
◎
The static any(signals) method steps are to return the result of creating a dependent abort signal from signals using AbortSignal and the current realm.
</p>
</div>

<div class="algo">
@aborted
取得子~手続きは
⇒
~RET ~IS［
コレは`中止-済み$aBである
］
◎
The aborted getter steps are to return true if this is aborted; otherwise false.
</div>

<div class="algo">
@reason
取得子~手続きは
⇒
~RET コレの`中止-事由$aB
◎
The reason getter steps are to return this’s abort reason.
</div>

<div class="algo">
<p>
@throwIfAborted()
~method手続きは
⇒
~IF［
コレは`中止-済み$aBである
］
⇒
コレの`中止-事由$aBを投出する
◎
The throwIfAborted() method steps are to throw this’s abort reason, if this is aborted.
</p>

<div class="example">
<p>
この~methodが首に有用になるのは、［
$AbortSignal を受容している関数が，
特定の検査地点で例外を投出する
（または、
却下された~promiseを返す）
］よう求まれるときである
— 当の $AbortSignal を他の~methodに渡す代わりに。
例えば，次の関数は、
条件を~pollする各~試みの間に中止することを許容する。
これは、
実際の非同期な演算（すなわち， `await func()^c ）が $AbortSignal を受容しない場合でも，
~pollしている処理nを中止する機会を与える。
◎
This method is primarily useful for when functions accepting AbortSignals want to throw (or return a rejected promise) at specific checkpoints, instead of passing along the AbortSignal to other methods. For example, the following function allows aborting in between each attempt to poll for a condition. This gives opportunities to abort the polling process, even though the actual asynchronous operation (i.e., await func()) does not accept an AbortSignal.
</p>

<pre class="lang-js">
async function waitForCondition(%func, %targetValue, { %signal } = {}) {
  while (true) {
    %signal?.throwIfAborted();

    const %result = await %func();
    if (%result === %targetValue) {
      return;
    }
  }
}
</pre>
</div>
</div>

<p>
@onabort
は、
`onabort@c
`~event~handler$用の`~event~handler~IDL属性$である
— その`~event~handler~event型$は
`abort@et
とする。
◎
The onabort attribute is an event handler IDL attribute for the onabort event handler, whose event handler event type is abort.
</p>

<p class="note">注記：
$AbortSignal ~objに対する変化は，対応している $AbortController ~objの望みを表現するが、
$AbortSignal ~objを観測している~APIは，それを無視することも選べる
— 一例として、
演算がすでに完了していた場合など。
◎
Changes to an AbortSignal object represent the wishes of the corresponding AbortController object, but an API observing the AbortSignal object can choose to ignore them. For instance, if the operation has already completed.
</p>

<p>
$AbortSignal ~objが
`中止-済み@aB
であるとは、
次が満たされることをいう
⇒
その`中止-事由$aB ~NEQ `undefined^jv
◎
An AbortSignal object is aborted when its abort reason is not undefined.
</p>

<div class="algo">
<p>
`通達に~algoを追加する@
~algoは、
所与の
( $AbortSignal ~obj %通達, ~algo %~algo )
に対し：
◎
To add an algorithm algorithm to an AbortSignal object signal:
</p>
<ol>
	<li>
~IF［
%通達 は`中止-済み$aBである
］
⇒
~RET
◎
If signal is aborted, then return.
</li>
	<li>
%通達 の`中止する~algo群$aBに %~algo を`付加する$set
◎
Append algorithm to signal’s abort algorithms.
</li>
</ol>
</div>

<div class="algo">
<p>
`通達から~algoを除去する@
~algoは、
所与の
( $AbortSignal ~obj %通達, ~algo %A )
に対し
⇒
%通達 の`中止する~algo群$aBから %A を`除去する$
◎
To remove an algorithm algorithm from an AbortSignal signal, remove algorithm from signal’s abort algorithms.
</p>
</div>

<div class="algo">
<p>
`中止-を通達する@aB
~algoは、
所与の
( $AbortSignal ~obj %通達, %事由 ~DF ε )
に対し：
◎
To signal abort, given an AbortSignal object signal and an optional reason:
</p>
<ol>
	<li>
~IF［
%通達 は`中止-済み$aBである
］
⇒
~RET
◎
If signal is aborted, then return.
</li>
	<li>
~Assert：
%事由 ~NEQ `undefined^jv
【この段は、この訳による補完。】
</li>
	<li>
%通達 の`中止-事由$aB ~SET %事由 に応じて
⇒＃
ε ならば新たな `AbortError$E 例外 ／
~ELSE_ %事由
◎
Set signal’s abort reason to reason if it is given; otherwise to a new "AbortError" DOMException.
</li>
	<li>
%中止する依存~通達~群 ~LET 新たな`~list$
◎
Let dependentSignalsToAbort be a new list.
</li>
	<li>
<p>
%通達 の`依存~通達~群$aBを成す
~EACH( %依存~通達 )
に対し：
◎
For each dependentSignal of signal’s dependent signals:
</p>
		<ol>
			<li>
<p>
~IF［
%依存~通達 は`中止-済み$aBでない
］：
◎
If dependentSignal is not aborted:
</p>
				<ol>
					<li>
%依存~通達 の`中止-事由$aB ~SET %通達 の`中止-事由$aB
◎
Set dependentSignal’s abort reason to signal’s abort reason.
</li>
					<li>
%中止する依存~通達~群 に %依存~通達 を`付加する$
◎
Append dependentSignal to dependentSignalsToAbort.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`通達~用の中止-手続きを走らす$( %通達 )
◎
Run the abort steps for signal.
</li>
	<li>
%中止する依存~通達~群 を成す
~EACH( %依存~通達 )
に対し
⇒
`通達~用の中止-手続きを走らす$( %依存~通達 )
◎
For each dependentSignal of dependentSignalsToAbort, run the abort steps for dependentSignal.
</li>
</ol>
</div>

<div class="algo">
<p>
`通達~用の中止-手続きを走らす@
~algoは、
所与の
( $AbortSignal ~obj %通達 )
に対し：
◎
To run the abort steps for an AbortSignal signal:
</p>
<ol>
	<li>
%通達 の`中止する~algo群$aBを成す
~EACH( %~algo )
に対し
⇒
%~algo を走らす
◎
For each algorithm of signal’s abort algorithms:＼
run algorithm.
</li>
	<li>
%通達 の`中止する~algo群$aBを`空にする$
◎
Empty signal’s abort algorithms.
</li>
	<li>
`~eventを発火する$( %通達, `abort$et )
◎
Fire an event named abort at signal.
</li>
</ol>
</div>

<div class="algo">
<p>
`依存~中止-通達を作成する@
~algoは、
所与の
( %通達~群, %通達~interface, %~realm )
に対し：
◎
To create a dependent abort signal from a list of AbortSignal objects signals, using signalInterface, which must be either AbortSignal or an interface that inherits from it, and a realm:
</p>
<ol>
	<li>
~Assert
⇒＃
%通達~群 は $AbortSignal ~objたちが成す~listである。
%通達~interface は $AbortSignal ~interfaceか それを継承する~interfaceである。
◎
↑</li>
	<li>
%結果~通達 ~LET `新たな~obj$( %通達~interface, %~realm )
◎
Let resultSignal be a new object implementing signalInterface using realm.
</li>
	<li>
%通達~群 を成す
~EACH( %通達 )
に対し
⇒
~IF［
%通達 は`中止-済み$aBである
］
⇒＃
%結果~通達 の`中止-事由$aB ~SET %通達 の`中止-事由$aB；
~RET %結果~通達 
◎
For each signal of signals:＼
if signal is aborted, then set resultSignal’s abort reason to signal’s abort reason and return resultSignal.
</li>
	<li>
%結果~通達 の`依存か$aB ~SET ~T
◎
Set resultSignal’s dependent to true.
</li>
	<li>
<p>
%通達~群 を成す
~EACH( %通達 )
に対し：
◎
For each signal of signals:
</p>
		<ol>
			<li>
<p>
~IF［
%通達 の`依存か$aB ~EQ ~F
］：
◎
If signal’s dependent is false:
</p>
				<ol>
					<li>
%結果~通達 の`~source通達~群$aBに %通達 を`付加する$set
◎
Append signal to resultSignal’s source signals.
</li>
					<li>
%通達 の`依存~通達~群$aBに %結果~通達 を`付加する$set
◎
Append resultSignal to signal’s dependent signals.
</li>
					<li>
~CONTINUE
◎
↓</li>
				</ol>
			</li>
			<li>
<p>
%通達 の`~source通達~群$aBを成す
~EACH( %~source通達 )
に対し：
◎
Otherwise, for each sourceSignal of signal’s source signals:
</p>
				<ol>
					<li>
~Assert：
%~source通達 は次を満たす
⇒
［
`中止-済み$aBでない
］~AND［
`依存か$aB ~EQ ~F
］
◎
Assert: sourceSignal is not aborted and not dependent.
</li>
					<li>
%結果~通達 の`~source通達~群$aBに %~source通達 を`付加する$set
◎
Append sourceSignal to resultSignal’s source signals.
</li>
					<li>
%~source通達 の`依存~通達~群$aBに %結果~通達 を`付加する$set
◎
Append resultSignal to sourceSignal’s dependent signals.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果~通達
◎
Return resultSignal.
</li>
</ol>
</div>

			<section id="abort-signal-garbage-collection">
<h4 title="Garbage collection">3.2.1. ~garbage収集</h4>

<div>
<p>
$AbortSignal ~objは、
~AND↓ を満たす間は，~garbage収集しないモノトスル：
</p>
<ul>
	<li>
`中止-済み$aBでない
</li>
	<li>
その`依存か$aB ~EQ ~T
</li>
	<li>
その`~source通達~群$aBは空でない
</li>
	<li>
<p>
~OR↓：
</p>
		<ul>
			<li>
`abort$et ~event用に登録された~event~listenerが在る
【すなわち、その`~event~listener~list$内に `型$evL ~EQ `abort^l を満たすものが在る】
</li>
			<li>
その`中止する~algo群$aBは空でない
</li>
		</ul>
	</li>
</ul>
◎
A non-aborted dependent AbortSignal object must not be garbage collected while its source signals is non-empty and it has registered event listeners for its abort event or its abort algorithms is non-empty.
</div>

			</section>
		</section>
		<section id="abortcontroller-api-integration">
<h3 title="Using AbortController and AbortSignal objects in APIs">3.3. ~APIにおける ^AbortController, ^AbortSignal ~objの利用-法</h3>

<p>
~web~platform~APIは、
中止できる演算を表現する~promiseを利用するときには，
次を固守するモノトスル：
◎
Any web platform API using promises to represent operations that can be aborted must adhere to the following:
</p>

<ul>
	<li>
^signal `辞書~member$を通して， $AbortSignal ~objを受容すること。
◎
Accept AbortSignal objects through a signal dictionary member.
</li>
	<li>
演算が中止されたときは、［
$AbortSignal ~objの`中止-事由$aB
］で~promiseを却下することにより，それを~~伝えること。
◎
Convey that the operation got aborted by rejecting the promise with AbortSignal object’s abort reason.
</li>
	<li>
<p>
$AbortSignal は`中止-済み$aBである場合
⇒
即時に却下すること。
◎
Reject immediately if the AbortSignal is already aborted, otherwise:
</p>

<p>
他の場合
⇒
$AbortSignal ~objの変化を観測するときは、
`中止する~algo群$aBによる仕組みを，他の観測器と衝突し得ない方式で利用すること。
◎
Use the abort algorithms mechanism to observe changes to the AbortSignal object and do so in a manner that does not lead to clashes with other observers.
<p>
	</li>
</ul>

<div class="example" id="aborting-ongoing-activities-spec-example">

<p>
~promiseを返す ある~method ^doAmazingness(options) 用の~method手続きは、
次のように記すこともできる：
◎
The method steps for a promise-returning method doAmazingness(options) could be as follows:
</p>
<ol>
	<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
Let global be this’s relevant global object.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
%通達 ~LET %options[ "^signal" ]
◎
↓</li>
	<li>
<p>
~IF［
%通達 ~NEQ ε
］：
◎
If options["signal"] exists:
</p>
		<ol>
			<li>
<p>
~IF［
%通達 は`中止-済み$aBである
］：
</p>
				<ol>
					<li>
`~promiseを却下する$( %~promise, %通達 の`中止-事由$aB )
</li>
					<li>
~RET %~promise
</li>
				</ol>
◎
Let signal be options["signal"].
◎
If signal is aborted, then reject p with signal’s abort reason and return p.
</li>
			<li>
<p>
`通達に~algoを追加する$( %通達, 次の手続き )
◎
Add the following abort steps to signal:
</p>

<div class="algo">
<p>
手続きは：
◎
</p>
				<ol>
					<li>
（下に定義される）
“すごいこと” 行う手続きを停止する
◎
Stop doing amazing things.
</li>
					<li>
`~promiseを却下する$( %~promise , %通達 の`中止-事由$aB )
◎
Reject p with signal’s abort reason.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li class="algo">
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%すごい結果 ~LET 何かすごいことを行う
【完遂するまで待機する】
◎
Let amazingResult be the result of doing some amazing things.
</li>
			<li>
<p>
`大域~taskを~queueする$( すごい~task~source, %大域~obj, 次の手続き )
◎
Queue a global task on the amazing task source given global to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %p, %すごい結果 )
◎
resolve p with amazingResult.
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>

<p>
~promiseを利用していない~APIであっても、
アリな限り，上述を固守するべきである。
◎
APIs not using promises should still adhere to the above as much as possible.
</p>

		</section>
	</section>
	<section id="nodes">
<h2 title="Nodes">4. ~node</h2>

		<section id="introduction-to-the-dom">
<h3 title="Introduction to “The DOM”">4.1. ~DOM序論</h3>

<p>
~DOM（ “`The DOM^en（ Document Object Model ）” ）は、
その元のイミにおいては，
文書（特に，~HTML文書や~XML文書）に~accessして操作するための~APIである。
この仕様における用語 “文書” は，［
短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更にはヤリトリありな本格的な~app
］までに渡る［
任意の~markupに基づく資源
］を指すものとして利用される。
◎
In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.
</p>

<p>
そのような各~文書は、
`~node~tree$として表現される。
`~tree$を成す`~node$のうち一部は，他の`~node$を`子$として有する一方で、
他のものは葉（子が無い~node）になる。
◎
Each such document is represented as a node tree. Some of the nodes in a tree can have children, while others are always leaves.
</p>

<div class="example">
<p>
次の~HTML文書を例に~~説明する：
◎
To illustrate, consider this HTML document:
</p>

`introduction-1^xCode

<p>
これは次のように表現される：
◎
It is represented as follows:
</p>

<ol class="domTree"><li>`文書$
	<ol><li>`~doctype$： `DOCTYPE html^c
	</li><li>`要素$： `html^e <span>`class^c=`e^l</span>
		<ol><li>`要素$： `head^e
			<ol><li>`要素$： `title^e
				<ol><li>$Text： <samp>Aliens?</samp>
				</li></ol>
			</li></ol>
		</li><li>$Text： <samp>⏎␣</samp>
		</li><li>`要素$： `body^e
			<ol><li>$Text: <samp>Why yes.⏎</samp>
			</li></ol>
		</li></ol>
	</li></ol>
</li></ol>
</div>

<p>
`~HTML構文解析器$の~~仕組みから，
一部の`~ASCII空白$は $Text `~node$にならないが、
一般~概念は明らかである。
~~入力の~markupから，`~node$たちが成す`~tree$が出来上がる。
【！You /can/ explain that! harharhar】
◎
Note that, due to the magic that is HTML parsing, not all ASCII whitespace were turned into Text nodes, but the general concept is clear. Markup goes in, a tree of nodes comes out.
</p>

<p class="note">注記：
さらに探求したければ、
最高によくできている
`Live DOM Viewer＠https://software.hixie.ch/utilities/js/live-dom-viewer/$
を利用できる。
◎
The most excellent Live DOM Viewer can be used to explore this matter in more detail.
</p>

		</section>
		<section id="node-trees">
<h3 title="Node tree">4.2. ~node~tree</h3>

<p>
`~node@
とは、
$Node を`実装-$する~objである。
各`~node$は、
`~node~tree@
と称される`~tree$に`関与-$する。
◎
Nodes are objects that implement Node. Nodes participate in a tree, which is known as the node tree.
</p>

<div class="note">

<p>注記：
実施においては、
より特定な~objを処することになる。
◎
In practice you deal with more specific objects.
</p>

<p>
$Node を`実装-$する~objは、
それを継承する~interface
— 次に挙げるいずれか —
も実装する
⇒＃
$Document,
$DocumentType,
$DocumentFragment,
$Element,
$CharacterData,
$Attr
◎
Objects that implement Node also implement an inherited interface: Document, DocumentType, DocumentFragment, Element, CharacterData, or Attr.
</p>

<p>
$DocumentFragment を実装する~objには、
$ShadowRoot を実装するものもある。
◎
Objects that implement DocumentFragment sometimes implement ShadowRoot.
</p>

<p>
$Element を実装する~objは、
概して，それを継承する~interface
— $HTMLAnchorElement など —
も実装する。
◎
Objects that implement Element also typically implement an inherited interface, such as HTMLAnchorElement.
</p>

<p>
$CharacterData を実装する~objは，それを継承する~interface
— 次に挙げるいずれか —
も実装する
⇒＃
$Text,
$ProcessingInstruction,
$Comment
◎
Objects that implement CharacterData also implement an inherited interface: Text, ProcessingInstruction, or Comment.
</p>

<p>
$Text を実装する~objには、
$CDATASection を実装するものもある。
◎
Objects that implement Text sometimes implement CDATASection.
</p>

<p>
したがって、
`~node$の`首~interface$は，次に挙げるいずれかになる
⇒＃
$Document,
$DocumentType,
$DocumentFragment,
$ShadowRoot,
$Element,
$Element を継承する~interface,
$Attr,
$Text,
$CDATASection,
$ProcessingInstruction,
$Comment
◎
Thus, every node’s primary interface is one of: Document, DocumentType, DocumentFragment, ShadowRoot, Element or an inherited interface of Element, Attr, Text, CDATASection, ProcessingInstruction, or Comment.
</p>
</div>

<p>
この仕様は、
$Node を継承する~interface %N を`実装-$する~objを指して，
単に %N `~node$とも称する。
◎
For brevity, this specification refers to an object that implements Node and an inherited interface NodeInterface, as a NodeInterface node.
</p>

<p id="_tree-constraints_">
`~node~tree$は、
次に従うよう拘束される
— これらの拘束は、
`~node$とそれに許容される`子$の関係性として表出される：
◎
A node tree is constrained as follows, expressed as a relationship between a node and its potential children:
</p>

<dl>
	<dt>$Document</dt>
	<dd>
<p>
`~tree順序$で，次に挙げるものからなる：
◎
In tree order:
</p>
		<ol>
			<li id="cp-comments-or-PI">
0 個以上の［
$ProcessingInstruction ／ $Comment
］`~node$
◎
Zero or more ProcessingInstruction or Comment nodes.
</li>
			<li>
0 個または 1 個の $DocumentType `~node$
◎
Optionally one DocumentType node.
</li>
			<!--cp-comments-or-PI-->
			<li>
0 個または 1 個の $Element `~node$
◎
Optionally one Element node.
</li>
			<!--cp-comments-or-PI-->
		</ol>
	</dd>

	<dt>$DocumentFragment</dt>
	<dt>$Element</dt>
	<dd>
0 個以上の［
$Element ／ $CharacterData
］`~node$からなる
◎
Zero or more Element or CharacterData nodes.
</dd>

	<dt>$DocumentType</dt>
	<dt>$CharacterData</dt>
	<dt>$Attr</dt>
	<dd>
`子$は無い
◎
No children.
</dd>
</dl>

<p class="note">注記：
歴史的な理由から $Attr `~node$は`~tree$に`関与-$するが、
それは常に，`親$は ~NULL かつ`子~群$は空である
— したがって、
それだけで，自身が関与する`~tree$を成すすべてになる。
◎
Attr nodes participate in a tree for historical reasons; they never have a (non-null) parent or any children and are therefore alone in a tree.
</p>

<p class="trans-note">【
$Attr `~node$が “~treeに関与するもの” を意味する語として他の仕様から利用されることは，ほぼ無い
（それらは、
通例的に “内容~属性” と称される ／
$Attr 自体を参照している仕様も，ごく限られる）。
他の仕様に現れる語 “~node” は、
実質的には，ほぼすべて “$Attr 以外の~node” を含意する。
】</p>

<div class="algo">
<p>
`~node$ %~node の
`長さ@node
は、
%~node が`実装-$する~interfaceに応じて，次で決定される
⇒＃
$DocumentType ならば 0 ／
$Attr ならば 0 ／
$CharacterData ならば %~node の`~data$の`長さ$str ／
~ELSE_ %~node の`子~群$の`~size$
◎
To determine the length of a node node, run these steps:
• If node is a DocumentType or Attr node, then return 0.
• If node is a CharacterData node, then return node’s data’s length.
• Return the number of node’s children.
</p>
</div>

<p>
`~node$が
`空@node
であるとは、
次を満たすことをいう
⇒
その`長さ$node ~EQ 0
◎
A node is considered empty if its length is 0.
</p>

			<section id="document-trees">
<h4 title="Document tree">4.2.1.文書~tree</h4>

<p>
`文書$を`根$とする`~node~tree$を
`文書~tree@
という。
◎
A document tree is a node tree whose root is a document.
</p>

<p>
`文書$ %文書 の
`文書~要素@
とは、
次を満たす`要素$は［
在るならば それ ／
無いならば ~NULL
］である
⇒
その`親$ ~EQ %文書
◎
The document element of a document is the element whose parent is that document, if it exists; otherwise null.
</p>

<p class="note">注記：
`~node~tree$に対する拘束から、
そのような`要素$は唯一つに決まる。
【例えば`~HTML文書$ならば `html^e 要素。】
◎
Per the node tree constraints, there can be only one such element.
</p>

<p>
`~node$は
`文書~tree内@
にあるとは、
次を満たすことをいう
⇒
その`根$は`文書$である
◎
A node is in a document tree if its root is a document.
</p>

<p>
`文書~tree内$にある`~node$は、
`文書~内@
にあるともいう。
◎
A node is in a document if it is in a document tree.＼
</p>

<p class="note">注記：
用語 “`文書~内$” は、
もはや利用されないものと想定されている。
この用語は、
それを利用している標準が，まだ`~shadow~tree$を織り込むよう更新されていないことを指示する。
◎
The term in a document is no longer supposed to be used. It indicates that the standard using it has not been updated to account for shadow trees.
</p>

			</section>
			<section id="shadow-trees">
<h4 title="Shadow tree">4.2.2. ~shadow~tree</h4>

<p>
`~shadow根$を`根$とする`~node~tree$を
`~shadow~tree@
という。
◎
A shadow tree is a node tree whose root is a shadow root.
</p>

<p>
`~shadow根$は常に，その`~host$を通して別の`~node~tree$に付される。
したがって，`~shadow~tree$が~~孤立することは決してない。
`~shadow根$の`~host$が`関与-$している`~node~tree$は、
`~light~tree@
とも呼ばれる。
◎
A shadow root is always attached to another node tree through its host. A shadow tree is therefore never alone. The node tree of a shadow root’s host is sometimes referred to as the light tree.
</p>

<p class="note">注記：
`~shadow~tree$に対応する`~light~tree$は、
それ自身`~shadow~tree$になり得る。
◎
A shadow tree’s corresponding light tree can be a shadow tree itself.
</p>

<p class="trans-note">【
~shadow（ “日陰” ）と違って，~light（ “日なた” ）の定義は相対的であり、
ある~node~treeだけで “~lightである” とは言えない。
】</p>

<p id="in-a-shadow-including-document">
`~node$は
`接続されて@
いるとは、
次を満たすことをいう
⇒
その`~shadowも含めた根$は`文書$である
◎
A node is connected if its shadow-including root is a document.
</p>

<p class="trans-note">【
`文書$も指示する必要がある所では、
“~nodeは（所与の）文書に`接続されて$いる” ／
“（所与の）~nodeが`接続されて$いる文書”
のような形の句でも表記される。
】</p>

				<section id="shadow-tree-slots">
<h5 title="Slots">4.2.2.1. ~slot</h5>

<p>
各`~shadow~tree$は、
0 個以上の，
`~slot@
と呼ばれる`要素$を包含する。
◎
A shadow tree contains zero or more elements that are slots.
</p>

<p class="note">注記：
`~slot$を作成できるのは、
~HTMLの `slot$e 要素を通す他にない。
◎
A slot can only be created through HTML’s slot element.
</p>

<p>
各 `~slot$には、
`~slot名@
が結付けられる。
それは文字列であり、
他が言明されない限り，空~文字列とする。
◎
A slot has an associated name (a string). Unless stated otherwise it is the empty string.
</p>

<div class="algo">
<p>
`~slot$の`~slot名$を更新するときは、
%要素 用の`属性o変更-時の手続き$として次を利用する
— それは、
所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
Use these attribute change steps to update a slot’s name:
</p>
<ol>
	<li>
~IF［
%要素 は `~slot$でない
］~OR［
%局所~名 ~NEQ `name^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If element is a slot, localName is name, and namespace is null:
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%旧-値 ~EQ ~NULL
］
⇒
%旧-値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%値 ~EQ %旧-値
］
⇒
~RET
◎
• If value is oldValue, then return.
◎
• If value is null and oldValue is the empty string, then return.
◎
• If value is the empty string and oldValue is null, then return.
</li>
	<li>
%要素 の`~slot名$ ~SET %値
◎
• If value is null or the empty string, then set element’s name to the empty string.
◎
• Otherwise, set element’s name to value.
</li>
	<li>
`~treeに~slot可能なものを割当する$( %要素 の`根$ )
◎
• Run assign slottables for a tree with element’s root.
</li>
</ol>
</div>

<p class="note">注記：
`~shadow~tree$内の，［
`~slot名$ ~EQ 空~文字列
］なる`~slot$のうち，`~tree順序$で最初のものは
“既定の~slot”
と称されることもある。
◎
The first slot in a shadow tree, in tree order, whose name is the empty string, is sometimes known as the "default slot".
</p>

<p>
各 `~slot$には、
`割当された~node群@
（ `assigned nodes^en ）が結付けられる。
それは，`~slot可能$たちが成す`~list$であり、
他が言明されない限り，`空$とする。
◎
A slot has an associated assigned nodes (a list of slottables). Unless stated otherwise it is empty.
</p>

				</section>
				<section id="light-tree-slotables">
<h5 title="Slottables">4.2.2.2. ~slot可能</h5>

<p>
［
$Element ／ $Text
］`~node$は、
`~slot可能@
である。
◎
Element and Text nodes are slottables.
</p>

<p class="trans-note">【
~slotは “はめ込み口”，
~slot可能（ `slottable^en ）は “はめ込めるモノ”
（名詞化された形容詞
— 形容詞としては “はめ込み可能な” を意味する）。
】</p>

<p class="note">注記：
`~slot$も、
`~slot可能$になり得る。
◎
A slot can be a slottable.
</p>

<p>
各 `~slot可能$には、
`名前@sB
が結付けられる。
それは文字列であり、
他が言明されない限り，空~文字列とする。
◎
A slottable has an associated name (a string). Unless stated otherwise it is the empty string.
</p>

<div class="algo">
<p>
`~slot可能$な %要素 の`名前$sBを更新するときは、
%要素 用の`属性o変更-時の手続き$として次を利用する
— それは、
所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
Use these attribute change steps to update a slottable’s name:
</p>
<ol>
	<li>
~IF［
%局所~名 ~NEQ `slot^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If localName is slot and namespace is null:
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%旧-値 ~EQ ~NULL
］
⇒
%旧-値 ~SET 空~文字列
◎
↓</li>
	<li>
~IF［
%値 ~EQ %旧-値
］
⇒
~RET
◎
• If value is oldValue, then return.
◎
• If value is null and oldValue is the empty string, then return.
◎
• If value is the empty string and oldValue is null, then return.
</li>
	<li>
%要素 の`名前$sB ~SET %値
◎
• If value is null or the empty string, then set element’s name to the empty string.
◎
• Otherwise, set element’s name to value.
</li>
	<li>
~IF［
%要素 の`割当-先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( その`~slot$ )
◎
• If element is assigned, then run assign slottables for element’s assigned slot.
</li>
	<li>
`~slot可能を~slotに割当する$( %要素 )
◎
• Run assign a slot for element.
</li>
</ol>
</div>

<p>
各 `~slot可能$には
`割当-先~slot@
（ `assigned slot^en ）が結付けられる。
それは，［
~NULL ／ `~slot$
］であり、
他が言明されない限り， ~NULL とする。
【自身がどの`~slot$に割当されたかを指示する。】
◎
A slottable has an associated assigned slot (null or a slot). Unless stated otherwise it is null.＼
</p>

<p>
`割当-先~slot$が ~NULL でない`~slot可能$は、
`割当-先がある@
（ `is assigned^en ）という。
【この訳では、この用語は利用せず，直に “`割当-先~slot$ ~NEQ ~NULL ” と記す。】
◎
A slottable is assigned if its assigned slot is non-null.
</p>

<p>
各 `~slot可能$には
`手動~割当-先~slot@
（ `manual slot assignment^en, ~scriptが手動で割当した~slot）が結付けられる。
それは，［
~NULL ／ `~slot$
］であり、
他が言明されない限り， ~NULL とする。
◎
A slottable has an associated manual slot assignment (null or a slot). Unless stated otherwise, it is null.
</p>

<p class="note">注記：
`~slot可能$の`手動~割当-先~slot$は、
~scriptからは直に~access可能でないので，
`~slot$への弱い参照を利用して実装できる／され得る。
◎
A slottable’s manual slot assignment can be implemented using a weak reference to the slot, because this variable is not directly accessible from script.
</p>

				</section>
				<section id="finding-slots-and-slotables">
<h5 title="Finding slots and slottables">4.2.2.3. ~slot／~slot可能の見出法</h5>

<div class="algo">
<p>
`~slot可能~用に~slotを見出す@
~algoは、
所与の
( `~slot可能$ %~slot可能, %~openか ~IN { `~open^i, ε } ~DF ε )
に対し：
◎
To find a slot for a given slottable slottable and an optional boolean open (default false):
</p>
<ol>
	<li>
~IF［
%~slot可能 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If slottable’s parent is null, then return null.
</li>
	<li>
%~shadow ~LET %~slot可能 の`親$の`~shadow根$el
◎
Let shadow be slottable’s parent’s shadow root.
</li>
	<li>
~IF［
%~shadow ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If shadow is null, then return null.
</li>
	<li>
~IF［
%~openか ~EQ `~open^i
］~AND［
%~shadow の`~mode$sR ~NEQ `open^l
］
⇒
~RET ~NULL
◎
If open is true and shadow’s mode is not "open", then return null.
</li>
	<li>
<p>
~IF［
%~shadow の`~slot割当n~mode$sR ~EQ `manual^l
］
⇒
~RET 次を満たす %~slot は［
在るならば %~slot ／
無いならば ~NULL
］
⇒
［
 %~shadow の`子孫$である
］~AND［
`~slot$である
］~AND［
%~slot可能 ~IN %~slot に`手動で割当された~node群$
］
</p>

<p class="trans-note">【
条件を満たす %~slot は在っても一つしかないことは、
`assign()＠~HEscripting#dom-slot-assign$c ~method手続きにより保証される。
】</p>
◎
If shadow’s slot assignment is "manual", then return the slot in shadow’s descendants whose manually assigned nodes contains slottable, if any; otherwise null.
</li>
	<li>
~RET 次を満たすもののうち，`~tree順序$で`最初のもの？$
⇒
［
%~shadow の`子孫$である
］~AND［
`~slot$である
］~AND［
その`~slot名$ ~EQ %~slot可能 の`名前$sB
］
◎
Return the first slot in tree order in shadow’s descendants whose name is slottable’s name, if any; otherwise null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~slot用に~slot可能なものを見出す@
~algoは、
所与の
( `~slot$ %~slot )
に対し：
◎
To find slottables for a given slot slot:
</p>
<ol>
	<li id="cp-let-result-empty-list">
%結果 ~LET « »
◎
Let result be « ».
</li>
	<li>
%根 ~LET %~slot の`根$
◎
Let root be slot’s root.
</li>
	<li>
~IF［
%根 は`~shadow根$でない
］
⇒
~RET %結果
◎
If root is not a shadow root, then return result.
</li>
	<li>
%~host ~LET %根 の`~host$
◎
Let host be root’s host.
</li>
	<li>
~IF［
%根 の`~slot割当n~mode$sR ~EQ `manual^l
］
⇒
%~slot に`手動で割当された~node群$を成す
~EACH( `~slot可能$ %~slot可能 )
に対し
⇒
~IF［
%~slot可能 の`親$ ~EQ %~host
］
⇒
%結果 に %~slot可能 を`付加する$
◎
If root’s slot assignment is "manual":
• For each slottable slottable of slot’s manually assigned nodes, if slottable’s parent is host, append slottable to result.
</li>
	<li>
~ELSE
⇒
%~host の`子~群$を成す
~EACH( %子 )
に対し【！`~tree順序$で】
⇒
~IF［
%子 は`~slot可能$である
］~AND［
`~slot可能~用に~slotを見出す$( %子 ) ~EQ %~slot
］
⇒
%結果 に %子 を`付加する$
◎
Otherwise, for each slottable child slottable of host, in tree order:
• Let foundSlot be the result of finding a slot given slottable.
• If foundSlot is slot, then append slottable to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~slot用に平坦~化された~slot可能なものを見出す@
~algoは、
所与の
( `~slot$ %~slot )
に対し：
◎
To find flattened slottables for a given slot slot:
</p>
<ol>
	<!--cp-let-result-empty-list-->
	<li>
~IF［
%~slot の`根$は`~shadow根$でない
］
⇒
~RET %結果
◎
If slot’s root is not a shadow root, then return result.
</li>
	<li>
%~slot可能~群 ~LET `~slot用に~slot可能なものを見出す$( %~slot )
◎
Let slottables be the result of finding slottables given slot.
</li>
	<li>
~IF［
%~slot可能~群 は`空$である
］
⇒
%~slot の`子~群$を成す
~EACH( %子 )
に対し【！`~tree順序$で】
⇒
~IF［
%子 は`~slot可能$である
］
⇒
%~slot可能~群 に %子 を`付加する$
◎
If slottables is the empty list, then append each slottable child of slot, in tree order, to slottables.
</li>
	<li>
<p>
%~slot可能~群 を成す
~EACH( %~node )
に対し：
◎
For each node of slottables:
</p>
		<ol>
			<li>
<p>
~IF［
%~node は`~slot$である
］~AND［
%~node の`根$は`~shadow根$である
］
⇒
%結果 を次の結果で`拡張する$
⇒
`~slot用に平坦~化された~slot可能なものを見出す$( %~node )
◎
If node is a slot whose root is a shadow root:
• Let temporaryResult be the result of finding flattened slottables given node.
• Append each slottable in temporaryResult, in order, to result.
</li>
			<li>
~ELSE
⇒
%結果 に %~node を`付加する$
◎
Otherwise, append node to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

				</section>
				<section id="assigning-slotables-and-slots">
<h5 title="Assigning slottables and slots">4.2.2.4. ~slot可能／~slotの割当法</h5>

<div class="algo">
<p>
`~slotに~slot可能なものを割当する@
~algoは、
所与の
( `~slot$ %~slot )
に対し：
◎
To assign slottables for a slot slot:
</p>
<ol>
	<li>
%~slot可能~群 ~LET
`~slot用に~slot可能なものを見出す$( %~slot )
◎
Let slottables be the result of finding slottables for slot.
</li>
	<li>
~IF［
%~slot可能~群 と %~slot に`割当された~node群$とは、
一致しない
【！＊順序は関係ある？ない？】
］
⇒
`~slotの変化を通達する$( %~slot )
◎
If slottables and slot’s assigned nodes are not identical, then run signal a slot change for slot.
</li>
	<li>
%~slot に`割当された~node群$ ~SET %~slot可能~群
◎
Set slot’s assigned nodes to slottables.
</li>
	<li>
%~slot可能~群 を成す
~EACH( %~slot可能 )
に対し
⇒
%~slot可能 の`割当-先~slot$ ~SET %~slot
◎
For each slottable of slottables:＼
set slottable’s assigned slot to slot.
</li>
</ol>
</div>

<div class="algo">
<p>
`~treeに~slot可能なものを割当する@
~algoは、
所与の
( `~node$ %根 )
に対し
⇒
%根 の`広義-子孫$たちを成す
~EACH( `~slot$ %~slot )
に対し，`~tree順序$で
⇒
`~slotに~slot可能なものを割当する$( %~slot )
◎
To assign slottables for a tree, given a node root, run assign slottables for each slot of root’s inclusive descendants, in tree order.
</p>
</div>

<div class="algo">
<p>
`~slot可能を~slotに割当する@
~algoは、
所与の
( `~slot可能$ %~slot可能 )
に対し：
◎
To assign a slot, given a slottable slottable:
</p>
<ol>
	<li>
%~slot ~LET `~slot可能~用に~slotを見出す$( %~slot可能 )
◎
Let slot be the result of finding a slot with slottable.
</li>
	<li>
~IF［
%~slot ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( %~slot )
◎
If slot is non-null, then run assign slottables for slot.
</li>
</ol>
</div>

				</section>
				<section id="signaling-slot-change">
<h5 title="Signaling slot change">4.2.2.5. ~slot変化の通達-法</h5>

<p>
各 `生成元が類似な~window~agent$ `HTML$r は、
`通達~slot群@
を有する。
それは，`~slot$たちが成す`有順序~集合$であり、
初期~時は空とする。
◎
Each similar-origin window agent has signal slots (a set of slots), which is initially empty. [HTML]
</p>

<div class="algo">
<p>
`~slotの変化を通達する@
~algoは、
所与の
( `~slot$ %~slot )
に対し：
◎
To signal a slot change, for a slot slot:
</p>
<ol>
	<li>
［
%~slot に`関連な~agent$の`通達~slot群$
］に %~slot を`付加する$set
◎
Append slot to slot’s relevant agent’s signal slots.
</li>
	<li>
`変異~観測器 小taskを~queueする$
◎
Queue a mutation observer microtask.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="mutation-algorithms">
<h4 title="Mutation algorithms">4.2.3. 変異~algo</h4>

<!--% 挿入検証 -->
<div class="algo">
<p>
`親の中で子の前に挿入できるか検証する@
~algoは、
所与の
( `~node$ %~node, `~node$ %親, ［
~NULL ／`~node$
］ %子 )
に対し：
◎
To ensure pre-insert validity of a node node into a node parent before null or a node child:
</p>
<ol>
	<li id="cp-throw-if-chardata">
~IF［
%親 は［
$Document ／ $DocumentFragment ／ $Element
］`~node$でない
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li id="cp-throw-if-iAN">
~IF［
%~node は %親 の`~hostも含めた広義-先祖$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a host-including inclusive ancestor of parent, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%子 ~NEQ ~NULL
］~AND［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child is non-null and its parent is not parent, then throw a "NotFoundError" DOMException.
</li>
	<li id="cp-throw-if-not-doc">
<p>
~IF［
%~node は［
$DocumentFragment ／ $DocumentType ／ $Element ／ $CharacterData
］`~node$でない
］
⇒
~THROW `HierarchyRequestError$E
</p>

<p class="trans-note">【
すなわち “^Document ／ ^Attr ~nodeである”
（何故そのように記されない？）
】</p>

◎
If node is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li id="cp-throw-if-mismatch1">
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%~node は $Text `~node$ である
］~AND［
%親 は`文書$である
］
</li>
			<li>
［
%~node は`~doctype$である
］~AND［
%親 は`文書$でない
］
</li>
		</ul>
<p>
…ならば
⇒
~THROW `HierarchyRequestError$E
</p>
◎
If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
<p id="cp-throw-if-doc-etc">
~IF［
%親 は`文書$である
］~AND［
%~node が`実装-$する~interfaceに応じて，以下が満たされる
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is a document, and any of the statements below, switched on the interface node implements, are true, then throw a "HierarchyRequestError" DOMException.
</p>
		<dl class="switch">
			<dt>$DocumentFragment</dt>
			<dd>
<p>
~OR↓：
</p>
				<ul>
					<li id="cp-has-element-children">
%~node の`子~群$を成す`要素$の個数 ~GT 1
◎
If node has more than one element child or＼
</li>
					<li id="cp-has-Text-child">
%~node の`子~群$内に $Text `~node$が在る
◎
has a Text node child.
</li>
					<li>
<p id="cp-has-an-element-and">
［
%~node の`子~群$を成す`要素$の個数 ~EQ 1
］~AND［
~OR↓
］：
</p>
						<ul id="cp-has-other-doctype">
							<li>
%親 の`子~群$内に`要素$が在る
</li>
							<li>
%子 は`~doctype$である
</li>
							<li>
［
%子 ~NEQ ~NULL
］~AND［
%子 に`後続-$する`~doctype$が在る
］
</li>
						</ul>
◎
Otherwise, if node has one element child and either parent has an element child, child is a doctype, or child is non-null and a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>$Element</dt>
			<dd>
<p>
~OR↓：
</p>
				<!--cp-has-other-doctype-->
◎
parent has an element child, child is a doctype, or child is non-null and a doctype is following child.
			</dd>

			<dt>$DocumentType</dt>
			<dd>
<p>
~OR↓：
</p>
				<ul>
					<li>
%親 の`子~群$内に`~doctype$が在る
</li>
					<li>
［
%子 ~EQ ~NULL
］~AND［
%子 に`先行-$する`要素$が在る
］
</li>
					<li>
［
%子 ~EQ ~NULL
］~AND［
%親 の`子~群$内に`要素$が在る
］
</li>
				</ul>
◎
parent has a doctype child, child is non-null and an element is preceding child, or child is null and parent has an element child.
			</dd>
		</dl>
	</li>
</ol>
</div>

<!--% 前挿入 -->
<div class="algo">
<p>
%親 の中で
`~nodeを子の前に前挿入する@
~algoは、
所与の
( `~node$ %~node, ［
~NULL ／`~node$
］ %子 )
に対し：
◎
To pre-insert a node node into a node parent before null or node child:
</p>
<ol>
	<li>
`親の中で子の前に挿入できるか検証する$( %~node, %親, %子 )
◎
Ensure pre-insert validity of node into parent before child.
</li>
	<li>
%基準~子 ~LET %子
◎
Let referenceChild be child.
</li>
	<li id="cp-set-next-sibling">
~IF［
%基準~子 ~EQ %~node
］
⇒
%基準~子 ~SET %~node の`直後の同胞？$
◎
If referenceChild is node, then set referenceChild to node’s next sibling.
</li>
	<li>
%親 の中で`~nodeを子の前に挿入する$( %~node, %基準~子 )
◎
Insert node into parent before referenceChild.
</li>
	<li>
~RET %~node
【！technically this is post-insert】
◎
Return node.
</li>
</ol>
</div>

<div>
<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`挿入-時の手続き@
を定義してもヨイ。
この~algoは、
`~nodeを子の前に挿入する$~algo内から，
( 挿入された`~node$【！insertedNode】 )
を渡して呼出される。
この手続きは：
</p>
<ul>
	<li>
次を【同期的に】行ってはナラナイ
⇒＃
挿入された~nodeが`関与-$する`~node~tree$を改変する／
`閲覧~文脈$作成する／
`~eventを発火する$／
その他，~JSを実行する【~JSの同期的な実行を伴い得る何らかの動作】
</li>
	<li>
が、
次を行ってもヨイ
⇒
前項に挙げたものを非同期に行うための`大域~taskを~queueする$
</li>
</ul>
◎
Specifications may define insertion steps for all or some nodes. The algorithm is passed insertedNode, as indicated in the insert algorithm below. These steps must not modify the node tree that insertedNode participates in, create browsing contexts, fire events, or otherwise execute JavaScript. These steps may queue tasks to do these things asynchronously, however.
</div>

<div class="example">
<p>
`挿入-時の手続き$は，とりわけ~JSを実行し得ないが、
その帰結が~~実際に~scriptから観測-可能になることもある。
次の例を考える：
◎
While the insertion steps cannot execute JavaScript (among other things), they will indeed have script-observable consequences. Consider the below example:
</p>

<pre class="lang-js">
const %h1 = document.querySelector('h1');

const %fragment = new DocumentFragment();
const %script = %fragment.appendChild(document.createElement('script'));
const %style = %fragment.appendChild(document.createElement('style'));

%script.innerText= 'console.log(getComputedStyle(%h1).color)'; /* <span class="comment">
これは '`rgb(255, 0, 0)^c' を~logする
◎
Logs 'rgb(255, 0, 0)'
</span> */
%style.innerText = 'h1 {color: rgb(255, 0, 0);}';

document.body.append(%fragment);
</pre>

<p>
この例における %script は、
'`rgb(255, 0, 0)^c' を~logする
— 次が順に起こるので：
◎
The script in the above example logs 'rgb(255, 0, 0)' because the following happen in order:
</p>
<ol>
	<li>
<p>
`~nodeを子の前に挿入する$~algoを走らす。
これは、
当の［
`script$e, `style$e
］要素を順に挿入することになる。
その結果、
`HTML$r においては：
◎
The insert algorithm runs, which will insert the script and style elements in order.
</p>
		<ol>
			<li>
`script$e 要素~用に`挿入-時の手続き$を走らす。
これは、
何もしない。
◎
The HTML Standard’s insertion steps run for the script element; they do nothing. [HTML]
</li>
			<li>
`style$e 要素~用に`挿入-時の手続き$を走らす。
これは、
即時に，その~style規則を文書に適用する。
◎
The HTML Standard’s insertion steps run for the style element; they immediately apply its style rules to the document. [HTML]
</li>
			<li>
`script$e 要素~用に`接続~後の手続き$を走らす。
これは、
当の~scriptを走らす
— ~scriptは、
前~段で適用された~style規則を即時に観測する。
◎
The HTML Standard’s post-connection steps run for the script element; they run the script, which immediately observes the style rules that were applied in the above step. [HTML]
</li>
		</ol>
	</li>
</ol>
</div>

<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`接続~後の手続き@
を定義してもヨイ。
この~algoは、
`~nodeを子の前に挿入する$~algo内から，
( 接続された`~node$【！%connectedNode 】 )
を渡して呼出される。
◎
Specifications may also define post-connection steps for all or some nodes. The algorithm is passed connectedNode, as indicated in the insert algorithm below.
</p>

<p class="note">注記：
`接続~後の手続き$の目的は、
`~node$用に［
接続に関係する演算を遂行する機会
］を供することにある
— ［
`接続され＠#connected$た`~node$が`関与-$している`~node~tree$を改変する／
`閲覧~文脈$を作成する／
その他，~JSを実行する
］ために。
この手続きは、
`~node$たちが一括して`不可分^emに`挿入される＠#concept-node-insert$ことを許容する
— ~scriptに関する主要な副作用~すべてが，`~node~tree$の中への一括~挿入が`完了した後^emに生じるよう。
これは、［
処理待ちな`~node~tree$への挿入
］すべてが［
さらなる挿入が生じ得る前に完全に完遂する
］ことを確保する。
◎
The purpose of the post-connection steps is to provide an opportunity for nodes to perform any connection-related operations that modify the node tree that connectedNode participates in, create browsing contexts, or otherwise execute JavaScript. These steps allow a batch of nodes to be inserted atomically with respect to script, with all major side effects occurring after the batch insertions into the node tree is complete. This ensures that all pending node tree insertions completely finish before more insertions can occur.
</p>

<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`子~群~変更-時の手続き@
を定義してもヨイ。
この~algoは、［
`~nodeを子の前に挿入する$／
`~nodeを除去する$／
`~dataを置換する$
］~algo内から，引数なしで呼出される。
◎
Specifications may define children changed steps for all or some nodes. The algorithm is passed no argument and is called from insert, remove, and replace data.
</p>

<p class="trans-note">【
そのような手続き
（通例的に， “〜時の手続き” と称される）
が（例えば，複数の仕様にて）
`複数~定義された＠#_specifications-defined@
場合
（例えば，`属性o変更-時の手続き$は、この仕様, ~HTML仕様の各所にて定義される）、
それらを走らす順序も有意になり得るが，言及されていない
（順序は有意にならないことが暗黙的に想定されているかもしれないが、
はっきりしない）。
】</p>

<!--% 挿入 -->
<div class="algo">
<p>
%親 の中で
`~nodeを子の前に挿入する@
~algoは、
所与の
( `~node$ %挿入される~node【！node】, ［
~NULL ／`~node$
］ %子, %観測器を抑止するか ~IN { `観測器を抑止する^i, ε } ~DF ε )
に対し：
◎
To insert a node node into a node parent before null or a node child, with an optional boolean suppressObservers (default false):
</p>
<ol>
	<li id="cp-let-nodes">
%~node群 ~LET %挿入される~node に応じて
⇒＃
`文書片$であるならば %挿入される~node の`子~群$【を`~cloneする$】 ／
~ELSE_ « %挿入される~node »
◎
Let nodes be node’s children, if node is a DocumentFragment node; otherwise « node ».
</li>
	<li>
%count ~LET %~node群 の`~size$
◎
Let count be nodes’s size.
</li>
	<li>
~IF［
%count ~EQ 0
］
⇒
~RET
◎
If count is 0, then return.
</li>
	<li>
<p>
~IF［
%挿入される~node は`文書片$である
］：
◎
If node is a DocumentFragment node:
</p>
		<ol>
			<li>
%~node群 を成す
~EACH( %~node )
に対し
⇒
`~nodeを除去する$( %~node, `観測器を抑止する^i )
◎
Remove its children with suppressObservers set to true.
</li>
			<li>
<p>
%挿入される~node 用に`~tree変異~記録を~queueする$( « », %~node群, ~NULL, ~NULL )
◎
Queue a tree mutation record for node with « », nodes, null, and null.
</p>

<p class="note">注記：
この段では意図的に %観測器を抑止するか を~~無視する。
◎
This step intentionally does not pay attention to suppressObservers.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%子 ~NEQ ~NULL
］：
◎
If child is non-null:
</p>
		<ol>
			<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
				<ol>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~GT %子 の`~index$
］
⇒
%範囲o の`始端~offset$ ~INCBY %count
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~GT %子 の`~index$†
］
⇒
%範囲o の`終端~offset$ ~INCBY %count
</li>
				</ol>

<p class="trans-note">【†
挿入される地点にちょうど一致する［
範囲oの`境界点$
］は、
それが`終端$であっても，影響されないことになる
— すなわち，挿入-後は 挿入された~nodeの直前を指す。
その結果，この~algoを利用している`子を~nodeに置換する$（後述）においては、
除去される~nodeの直後または内部を指していた範囲oの境界点は，
置換-後には 新たに挿入された~nodeの直前を指すようになる
（~node~treeの［
先頭／末尾
］から相対的な範囲oの［
始端／終端
］の位置変化のふるまいが，対称でない
— 同様のことは，`~dataを置換する$~algoにも該当する）。
】</p>
			</li>
		</ol>
◎
For each live range whose start node is parent and start offset is greater than child’s index:＼
increase its start offset by count.
◎
For each live range whose end node is parent and end offset is greater than child’s index:＼
increase its end offset by count.
</li>
	<li>
%直前の同胞 ~LET ［
%子 ~NEQ ~NULL ならば %子 の`直前の同胞？$ ／
~ELSE_ %親 の`最後の子？$
］
◎
Let previousSibling be child’s previous sibling or parent’s last child if child is null.
</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し【！`~tree順序$で】：
◎
For each node in nodes, in tree order:
</p>
		<ol>
			<li>
%親 の`~node文書$に`~nodeを受入する$( %~node )
◎
Adopt node into parent’s node document.
</li>
			<li>
~IF［
%子 ~EQ ~NULL
］
⇒
%親 の`子~群$に %~node を`付加する$set
◎
If child is null, then append node to parent’s children.
</li>
			<li>
~ELSE
⇒
%~node を%親 の`子~群$の中へ %子 の`~index$の前に`挿入する$
◎
Otherwise, insert node into parent’s children before child’s index.
</li>
			<li>
~IF［
%親 は`~shadow~host$である
］~AND［
%親 の`~shadow根$の`~slot割当n~mode$sR ~EQ `named^l
］~AND［
%~node は`~slot可能$である
］
⇒
`~slot可能を~slotに割当する$( %~node )
◎
If parent is a shadow host whose shadow root’s slot assignment is "named" and node is a slottable, then assign a slot for node.
</li>
			<li id="cp-signal-if-assigned-empty">
~IF［
%親 の`根$は`~shadow根$である
］~AND［
%親 は`~slot$である
］~AND［
%親 に`割当された~node群$は`空$である
］
⇒
`~slotの変化を通達する$( %親 )
◎
If parent’s root is a shadow root, and parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.
</li>
			<li>
`~treeに~slot可能なものを割当する$( %~node の`根$ )
◎
Run assign slottables for a tree with node’s root.
</li>
			<li>
<p>
%~node の`~shadowも含めた広義-子孫$たちを成す
~EACH( %広義-子孫 )
に対し，`~shadowも含めた~tree順序$で：
◎
For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order:
</p>
				<ol>
					<li>
`適用-可能な仕様$にて %広義-子孫 用に`定義された各$( `挿入-時の手続き$ %手続き )
に対し
⇒
%手続き( %広義-子孫 )
◎
Run the insertion steps with inclusiveDescendant.
</li>
					<li>
~IF［
%広義-子孫 は`接続されて$いない
］
⇒
~CONTINUE
◎
If inclusiveDescendant is not connected, then continue.
</li>
					<li>
<p>
~IF［
%広義-子孫 は`要素$である
］：
◎
If inclusiveDescendant is an element＼
</p>
						<ol>
							<li>
%~registry ~LET %広義-子孫 の`~custom要素~registry$el
◎
↓</li>
							<li>
~IF［
%~registry ~EQ ~NULL
］
⇒
~CONTINUE
◎
and inclusiveDescendant’s custom element registry is non-null:
</li>
							<li>
~IF［
%~registry の`視野~付きか$cR ~EQ ~T
］
⇒
%~registry の`視野~付き文書~集合$cRに %広義-子孫 の`~node文書$を`付加する$set
◎
If inclusiveDescendant’s custom element registry’s is scoped is true, then append inclusiveDescendant’s node document to inclusiveDescendant’s custom element registry’s scoped document set.
</li>
							<li>
~IF［
%広義-子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義-子孫,
`connectedCallback^l,
« »
)
◎
If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant, callback name "connectedCallback", and « ».
</li>
							<li>
<p>
~ELSE
⇒
`要素を昇格するよう試行する$( %広義-子孫 )
◎
Otherwise, try to upgrade inclusiveDescendant.
</p>

<p class="note">注記：
%広義-子孫 が成功裡に昇格された場合、
その ^connectedCallback は，`要素を昇格する$~algoの間に自動的に~enqueueされる。
◎
If this successfully upgrades inclusiveDescendant, its connectedCallback will be enqueued automatically during the upgrade an element algorithm.
</p>
							</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%広義-子孫 は`~shadow根$である
］：
◎
Otherwise, if inclusiveDescendant is a shadow root,＼
</p>
						<ol>
							<li>
%~registry ~LET %広義-子孫 の`~custom要素~registry$sR
◎
↓</li>
							<li>
~IF［
%~registry ~EQ ~NULL
］
⇒
~CONTINUE
◎
inclusiveDescendant’s custom element registry is non-null,＼
</li>
							<li>
~IF［
%~registry の`視野~付きか$cR ~EQ ~T
］
⇒
%~registry の`視野~付き文書~集合$cRに %広義-子孫 の`~node文書$を`付加する$set
◎
and inclusiveDescendant’s custom element registry’s is scoped is true, then append inclusiveDescendant’s node document to inclusiveDescendant’s custom element registry’s scoped document set.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%観測器を抑止するか ~EQ ε
］
⇒
%親 用に`~tree変異~記録を~queueする$( %~node群, « », %直前の同胞, %子 )
◎
If suppressObservers is false, then queue a tree mutation record for parent with nodes, « », previousSibling, and child.
</li>
	<li id="cp-children-changed-steps">
`適用-可能な仕様$にて %親 用に`定義された各$( `子~群~変更-時の手続き$ %手続き )
に対し
⇒
%手続き()
◎
Run the children changed steps for parent.
</li>
	<li>
<p>
%静的な~node~list ~LET 新たな`~list$
◎
Let staticNodeList be a list of nodes, initially « ».
</p>

<p class="note">注記：
以下では、
`接続~後の手続き$を~callする`前^emに，その対象になる`~node$すべてを収集する
— `~node~tree$を辿って`いる間^emに`接続~後の手続き$を~callする代わりに。
`接続~後の手続き$は，~treeの構造を改変し得るので、
~liveな辿りは安全でない
— そうすると、
場合によっては，同じ`~node$に対し`接続~後の手続き$が複数回~callされる結果に至る。
◎
We collect all nodes before calling the post-connection steps on any one of them, instead of calling the post-connection steps while we’re traversing the node tree. This is because the post-connection steps can modify the tree’s structure, making live traversal unsafe, possibly leading to the post-connection steps being called multiple times on the same node.
</p>
	</li>
	<li>
<p>
%~node群 を成す
~EACH( %~node )
に対し【！`~tree順序$で】
⇒
%~node の`~shadowも含めた広義-子孫$たちを成す
~EACH( %広義-子孫 )
に対し，`~shadowも含めた~tree順序$で
⇒
%静的な~node~list に %広義-子孫 を`付加する$
</p>

<p class="trans-note">【
%~node群 を成す~nodeどうしは，
互いに先祖, 子孫の関係にないので、
同じ~nodeが重複して収集されることはない。
】</p>
◎
For each node of nodes, in tree order:
• For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order:＼
append inclusiveDescendant to staticNodeList.
</li>
	<li>
%静的な~node~list を成す
~EACH( %~node )
に対し
⇒
~IF［
%~node は`接続されて$いる
］
⇒
`適用-可能な仕様$にて %~node 用に`定義された各$( `接続~後の手続き$ %手続き )
に対し
⇒
%手続き( %~node )
◎
For each node of staticNodeList:＼
if node is connected, then run the post-connection steps with node.
</li>
</ol>
</div>

<div class="algo">
<p>
%親 に
`~nodeを付加する@
~algoは、
所与の
( `~node$ %~node )
に対し
⇒
%親 の中で`~nodeを子の前に前挿入する$( %~node, ~NULL )
◎
To append a node node to a node parent: pre-insert node into parent before null.
</p>
</div>

<div>
<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`移動-時の手続き@
を定義してもヨイ。
この~algoは、
`~nodeを移動する$~algo内から，
( 移動された`~node$【！movedNode】, ［
旧-親である`~node$／~NULL
］【！oldParent】 )
を渡して呼出される。
`挿入-時の手続き$と同様に，この手続きは：
</p>
<ul>
	<li>
次を【同期的に】行ってはナラナイ
⇒＃
移動された~nodeが`関与-$する`~node~tree$を改変する／
`閲覧~文脈$作成する／
`~eventを発火する$／
その他，~JSを実行する【~JSの同期的な実行を伴い得る何らかの動作】
</li>
	<li>
が、
次を行ってもヨイ
⇒
前項に挙げたものを非同期に行うための`大域~taskを~queueする$
</li>
</ul>
◎
Specifications may define moving steps for all or some nodes. The algorithm is passed a node movedNode, and a node-or-null oldParent as indicated in the move algorithm below. Like the insertion steps, these steps must not modify the node tree that movedNode participates in, create browsing contexts, fire events, or otherwise execute JavaScript. These steps may queue tasks to do these things asynchronously, however.
</div>

<!--% 移動 -->
<div class="algo">
<p>
`~nodeを移動する@
~algoは、
所与の
( `~node$ %~node, `~node$ %新-親, ［
~NULL ／`~node$
］ %子 )
に対し：
◎
To move a node node into a node newParent before null or a node child:
</p>
<ol>
	<li>
<p>
~IF［
%新-親 の`~shadowも含めた根$ ~NEQ %~node の`~shadowも含めた根$
］
⇒
~THROW `HierarchyRequestError$E
◎
If newParent’s shadow-including root is not the same as node’s shadow-including root, then throw a "HierarchyRequestError" DOMException.
</p>

<p class="note">注記：
これには、［
移動-が遂行されるのは，次が満たされる場合に限られる
］ことを確保する副作用がある
⇒
%新-親 が`接続されて$いる文書 ~EQ %~node が`接続されて$いる文書
◎
This has the side effect of ensuring that a move is only performed if newParent’s connected is node’s connected.
</p>
	</li>
	<li>
~IF［
%~node は %新-親 の`~hostも含めた広義-先祖$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a host-including inclusive ancestor of newParent, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%子 ~NEQ ~NULL
］~AND［
%子 の`親$ ~NEQ %新-親
］
⇒
~THROW `NotFoundError$E
◎
If child is non-null and its parent is not newParent, then throw a "NotFoundError" DOMException.
</li>
	<li>
~IF［
%~node は［
`要素$／`文字~data~node$
］でない
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is not an Element or a CharacterData node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%~node は $Text `~node$である
］~AND［
%新-親 は`文書$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a Text node and newParent is a document, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
<p>
~IF［
~AND↓
］…
</p>
		<ul>
			<li>
%新-親 は`文書$である
</li>
			<li>
%~node は`要素$である
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
［
%新-親 の`子~群$内には`要素$が在る
］~AND［
%子 は`~doctype$である
］
</li>
					<li>
［
%子 ~NEQ ~NULL
］~AND［
%子 に`後続-$している`~doctype$がある
］
</li>
				</ul>
			</li>
		</ul>
<p>
…ならば
⇒
~THROW `HierarchyRequestError$E
</p>
◎
If newParent is a document, node is an Element node, and either newParent has an element child, child is a doctype, or child is non-null and a doctype is following child then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
%旧-親 ~LET %~node の`親$
◎
Let oldParent be node’s parent.
</li>
	<li>
~Assert：
%旧-親 ~NEQ ~NULL
◎
Assert: oldParent is non-null.
</li>
	<li>
`~live範囲o用の除去-前の手続き$( %~node )
◎
Run the live range pre-remove steps, given node.
</li>
	<li>
~EACH( $NodeIterator ~obj %反復器 )
に対し
⇒
~IF［
%反復器 の`根$tVの`~node文書$ ~EQ %~node の`~node文書$
］
⇒
`~node反復器~用の除去-前の手続き$( %~node, %反復器 )
◎
For each NodeIterator object iterator whose root’s node document is node’s node document:＼
run the NodeIterator pre-remove steps given node and iterator.
</li>
	<li>
%旧-直前の同胞 ~LET %~node の`直前の同胞？$
◎
Let oldPreviousSibling be node’s previous sibling.
</li>
	<li>
%旧-直後の同胞 ~LET %~node の`直後の同胞？$
◎
Let oldNextSibling be node’s next sibling.
</li>
	<li>
%旧-親 の`子~群$から %~node を`除去する$
◎
Remove node from oldParent’s children.
</li>
	<li>
~IF［
%~node の`割当-先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( その`~slot$ )
◎
If node is assigned, then run assign slottables for node’s assigned slot.
</li>
	<li>
~IF［
%旧-親 の`根$は`~shadow根$である
］~AND［
%旧-親 は`~slot$である
］~AND［
%旧-親 に`割当された~node群$は`空$である
］
⇒
`~slotの変化を通達する$( %旧-親 )
◎
If oldParent’s root is a shadow root, and oldParent is a slot whose assigned nodes is empty, then run signal a slot change for oldParent.
</li>
	<li>
<p>
~IF［
%~node のある`広義-子孫$は`~slot$である
］：
◎
If node has an inclusive descendant that is a slot:
</p>
		<ol>
			<li>
`~treeに~slot可能なものを割当する$( %旧-親 の`根$ )
◎
Run assign slottables for a tree with oldParent’s root.
</li>
			<li>
`~treeに~slot可能なものを割当する$( %~node )
◎
Run assign slottables for a tree with node.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%子 ~NEQ ~NULL
］：
◎
If child is non-null:
</p>
		<ol>
			<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
				<ol>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %新-親 
］~AND［
%範囲o の`始端~offset$ ~GT %子 の`~index$
］
⇒
%範囲o の`始端~offset$ ~INCBY 1
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %新-親 
］~AND［
%範囲o の`終端~offset$ ~GT %子 の`~index$
］
⇒
%範囲o の`終端~offset$ ~INCBY 1
</li>
				</ol>
◎
For each live range whose start node is newParent and start offset is greater than child’s index:＼
increase its start offset by 1.
◎
For each live range whose end node is newParent and end offset is greater than child’s index:＼
increase its end offset by 1.
</li>
		</ol>
	</li>
	<li>
%新-直前の同胞 ~LET ［
%子 ~NEQ ~NULL ならば %子 の`直前の同胞？$／
~ELSE_%新-親 の`最後の子？$
］
◎
Let newPreviousSibling be child’s previous sibling if child is non-null, and newParent’s last child otherwise.
</li>
	<li>
~IF［
%子 ~EQ ~NULL
］
⇒
%新-親 の`子~群$に %~node を`付加する$set
◎
If child is null, then append node to newParent’s children.
</li>
	<li>
~ELSE
⇒
%新-親 の`子~群$の中へ %~node を %子 の`~index$の前に`挿入する$
◎
Otherwise, insert node into newParent’s children before child’s index.
</li>
	<li>
~IF［
%新-親 は`~shadow~host$である
］~AND［
%新-親 の`~shadow根$の`~slot割当n~mode$sR ~EQ `named^l
］~AND［
%~node は`~slot可能$である
］
⇒
`~slot可能を~slotに割当する$( %~node )
◎
If newParent is a shadow host whose shadow root’s slot assignment is "named" and node is a slottable, then assign a slot for node.
</li>
	<li>
~IF［
%新-親 の`根$は`~shadow根$である
］~AND［
%新-親 は`~slot$である
］~AND［
%新-親 に`割当された~node群$は`空$である
］
⇒
`~slotの変化を通達する$( %新-親 )
◎
If newParent’s root is a shadow root, and newParent is a slot whose assigned nodes is empty, then run signal a slot change for newParent.
</li>
	<li>
`~treeに~slot可能なものを割当する$( %~node の`根$ )
◎
Run assign slottables for a tree with node’s root.
</li>
	<li>
<p>
%~node の`~shadowも含めた広義-子孫$たちを成す
~EACH( %広義-子孫 )
に対し，`~shadowも含めた~tree順序$で：
◎
For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order:
</p>
		<ol>
			<li>
%旧-親か~NULL ~LET ［
%広義-子孫 ~EQ %~node ならば %旧-親 ／
~ELSE_ ~NULL
］
◎
↓</li>
			<li>
<p>
`適用-可能な仕様$にて %広義-子孫 用に`定義された各$( `移動-時の手続き$ %手続き )
に対し
⇒
%手続き( %広義-子孫, %旧-親か~NULL )
◎
If inclusiveDescendant is node, then run the moving steps with inclusiveDescendant and oldParent.＼
Otherwise, run the moving steps with inclusiveDescendant and null.
</p>

<p class="note">注記：
`~nodeを移動する$~algoは、［
`~nodeを子の前に挿入する$, `~nodeを除去する$
］とは別々な~primitiveなので，
%広義-子孫 用に伝統的な［
`挿入-時の手続き$／`除去-時の手続き$
］を呼出さない。
◎
Because the move algorithm is a separate primitive from insert and remove, it does not invoke the traditional insertion steps or removing steps for inclusiveDescendant.
</p>
			</li>
			<li>
~IF［
%広義-子孫 は`~custom$である
］~AND［
%新-親 は`接続されて$いる
］~AND［
%新-親 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義-子孫,
`connectedMoveCallback^l,
« »
)
◎
If inclusiveDescendant is custom and newParent is connected, then enqueue a custom element callback reaction with inclusiveDescendant, callback name "connectedMoveCallback", and « ».
</li>
		</ol>
	</li>
	<li>
%旧-親 用に`~tree変異~記録を~queueする$( « », « %~node », %旧-直前の同胞,
%旧-直後の同胞 )
◎
Queue a tree mutation record for oldParent with « », « node », oldPreviousSibling, and oldNextSibling.
</li>
	<li>
%新-親 用に`~tree変異~記録を~queueする$( « %~node », « », %新-直前の同胞, %子 )
◎
Queue a tree mutation record for newParent with « node », « », newPreviousSibling, and child.
</li>
</ol>
</div>

<!--% 置換 -->
<div class="algo">
<p>
`~node$ %親 の中で
`子を~nodeに置換する@
~algoは、
所与の
( `~node$ %子, `~node$ %~node )
に対し：
◎
To replace a node child with a node node within a node parent:
</p>
<ol>
	<!--cp-throw-if-chardata-->
	<!--cp-throw-if-iAN-->
	<li>
~IF［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child’s parent is not parent, then throw a "NotFoundError" DOMException.
</li>
	<!--cp-throw-if-not-doc-->
	<!--cp-throw-if-mismatch1-->
	<li>
<!--cp-throw-if-doc-etc-->
		<dl class="switch">
			<dt>$DocumentFragment</dt>
			<dd>
<p>
~OR↓：
</p>
				<ul>
					<!--cp-has-element-children-->
					<!--cp-has-Text-child-->
					<li>
						<!--cp-has-an-element-and-->
						<ul id="cp-has-other-element">
							<li>
%親 の`子~群$内に［ %子 以外の`要素$ ］が在る
</li>
							<li>
%子 に`後続-$する`~doctype$が在る
</li>
						</ul>
◎
Otherwise, if node has one element child and either parent has an element child that is not child or a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>$Element</dt>
			<dd>
<p>
~OR↓：
</p>
				<!--cp-has-other-element-->
◎
parent has an element child that is not child or a doctype is following child.
			</dd>

			<dt>$DocumentType</dt>
			<dd>
<p>
~OR↓：
</p>
				<ul>
					<li>
%親 の`子~群$内に［ %子 以外の`~doctype$ ］が在る
</li>
					<li>
%子 に`先行-$する`要素$が在る
</li>
				</ul>
◎
parent has a doctype child that is not child, or an element is preceding child.
			</dd>
		</dl>

<p class="note">注記：
この段は，`親の中で子の前に挿入できるか検証する$ ~algoの似た段と異なる。
◎
The above statements differ from the pre-insert algorithm.
</p>
	</li>
	<li>
%基準~子 ~LET %子 の`直後の同胞？$
◎
Let referenceChild be child’s next sibling.
</li>
	<!--cp-set-next-sibling-->
	<li>
%直前の同胞 ~LET %子 の`直前の同胞？$
◎
Let previousSibling be child’s previous sibling.
</li>
	<li>
%除去-済み~node群 ~LET 空~集合
◎
Let removedNodes be the empty set.
</li>
	<li>
<p>
~IF［
%子 の`親$ ~NEQ ~NULL
］：
◎
If child’s parent is non-null:
</p>
		<ol>
			<li>
%除去-済み~node群 ~SET « %子 »
◎
Set removedNodes to « child ».
</li>
			<li>
`~nodeを除去する$( %子, `観測器を抑止する^i )
◎
Remove child with suppressObservers set to true.
</li>
		</ol>

<p class="note">注記：
この段の~~条件が満たされないのは、［
%子 ~EQ %~node
］の場合に限られる。
◎
The above can only be false if child is node.
</p>

	</li>
	<!--cp-let-nodes-->
	<li>
%親 の中で`~nodeを子の前に挿入する$( %~node, %基準~子, `観測器を抑止する^i )
◎
Insert node into parent before referenceChild with suppressObservers set to true.
</li>
	<li>
%親 用に`~tree変異~記録を~queueする$( %~node群, %除去-済み~node群, %直前の同胞, %基準~子 )
◎
Queue a tree mutation record for parent with nodes, removedNodes, previousSibling, and referenceChild.
</li>
	<li>
~RET %子
◎
Return child.
</li>
</ol>
</div>

<!--% 全置換 -->
<div class="algo">
<p>
`~node$ %親 の
`全~内容を~nodeで置換する@
~algoは、
所与の
( ［
~NULL ／`~node$
］ %~node )
に対し：
◎
To replace all with a node or null node within a node parent:
</p>
<ol>
	<li>
%除去-済み~node群 ~LET %親 の`子~群$【を`~cloneする$】
◎
Let removedNodes be parent’s children.
</li>
	<li>
%追加-済み~node群 ~LET %~node に応じて，次に与える集合
⇒＃
~NULL ならば « » ／
`文書片$であるならば %~node の`子~群$【を`~cloneする$】 ／
~ELSE_ « %~node »
◎
Let addedNodes be the empty set.
◎
If node is a DocumentFragment node, then set addedNodes to node’s children.
◎
Otherwise, if node is non-null, set addedNodes to « node ».
</li>
	<li>
%除去-済み~node群 を成す
~EACH( %子 )
に対し【！`~tree順序$で】
⇒
`~nodeを除去する$( %子, `観測器を抑止する^i )
◎
Remove all parent’s children, in tree order, with suppressObservers set to true.
</li>
	<li>
~IF［
%~node ~NEQ ~NULL
］
⇒
%親 の中で`~nodeを子の前に挿入する$( %~node, ~NULL, `観測器を抑止する^i )
◎
If node is non-null, then insert node into parent before null with suppressObservers set to true.
</li>
	<li>
~IF［
%追加-済み~node群 は`空$でない
］~OR［
%除去-済み~node群 は`空$でない
］
⇒
%親 用に`~tree変異~記録を~queueする$( %追加-済み~node群, %除去-済み~node群, ~NULL, ~NULL )
◎
If either addedNodes or removedNodes is not empty, then queue a tree mutation record for parent with addedNodes, removedNodes, null, and null.
</li>
</ol>

<p class="note">注記：
この~algoは `~node~tree$に対する拘束を検査しない。
仕様の策定者は賢く利用すること。
◎
This algorithm does not make any checks with regards to the node tree constraints. Specification authors need to use it wisely.
</p>
</div>

<div class="algo">
<p>
`子を親から前除去する@
~algoは…
</p>

<p class="trans-note">【
以下，この~algoを成す内容は、
この~algoを利用する唯一の~method $Node.removeChild の中へ移動した。
】</p>
◎
To pre-remove a node child from a node parent:
• If child’s parent is not parent, then throw a "NotFoundError" DOMException.
• Remove child.
• Return child.
</div>

<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`除去-時の手続き@
を定義してもヨイ。
この~algoには、
`~nodeを除去する$ ~algoにて指示されるとおり，
( `~node$ %除去された~node, ［
`~node$／ ~NULL
］ %旧-親 )
が渡される。
◎
Specifications may define removing steps for all or some nodes. The algorithm is passed a node removedNode and a node-or-null oldParent, as indicated in the remove algorithm below.
</p>

<!--% 除去 -->
<div class="algo">
<p>
`~nodeを除去する@
~algoは、
所与の
( `~node$ %~node, %観測器を抑止するか ~IN { `観測器を抑止する^i, ε } ~DF ε )
に対し：
◎
To remove a node node, with an optional boolean suppressObservers (default false):
</p>
<ol>
	<li>
%親 ~LET %~node の`親$
◎
Let parent be node’s parent.
</li>
	<li>
~Assert：
%親 ~NEQ ~NULL
◎
Assert: parent is non-null.
</li>
	<li>
`~live範囲o用の除去-前の手続き$( %~node )
◎
Run the live range pre-remove steps, given node.
</li>
	<li>
~EACH( $NodeIterator ~obj %反復器 )
に対し
⇒
~IF［
%反復器 の`根$tVの`~node文書$ ~EQ %~node の`~node文書$
］
⇒
`~node反復器~用の除去-前の手続き$( %反復器, %~node )
◎
For each NodeIterator object iterator whose root’s node document is node’s node document:＼
run the NodeIterator pre-remove steps given node and iterator.
</li>
	<li>
%旧-直前の同胞 ~LET %~node の`直前の同胞？$
◎
Let oldPreviousSibling be node’s previous sibling.
</li>
	<li>
%旧-直後の同胞 ~LET %~node の`直後の同胞？$
◎
Let oldNextSibling be node’s next sibling.
</li>
	<li>
%~node を %親 の`子~群$から`除去する$
◎
Remove node from its parent’s children.
</li>
	<li>
~IF［
%~node の`割当-先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slot可能なものを割当する$( その`~slot$ )
◎
If node is assigned, then run assign slottables for node’s assigned slot.
</li>
	<!--cp-signal-if-assigned-empty-->
	<li>
<p>
~IF［［
%~node の`広義-子孫$のうち，`~slot$であるもの
］は在る
］：
◎
If node has an inclusive descendant that is a slot:
</p>
		<ol>
			<li>
`~treeに~slot可能なものを割当する$( %親 の`根$ )
◎
Run assign slottables for a tree with parent’s root.
</li>
			<li>
`~treeに~slot可能なものを割当する$( %~node )
◎
Run assign slottables for a tree with node.
</li>
		</ol>
	</li>
	<li>
`適用-可能な仕様$にて %~node 用に`定義された各$( `除去-時の手続き$ %手続き )
に対し
⇒
%手続き( %~node, %親 )
◎
Run the removing steps with node and parent.
</li>
	<li>
%親は接続されているか ~LET ~IS［
%親 は`接続されて$いる
］
◎
Let isParentConnected be parent’s connected.
</li>
	<li>
<p>
~IF［
%~node は`~custom$である
］~AND［
%親は接続されているか ~EQ ~T
］
⇒
`~custom要素~callback反応を~enqueueする$(
%~node,
`disconnectedCallback^l,
« »
)
◎
If node is custom and isParentConnected is true, then enqueue a custom element callback reaction with node, callback name "disconnectedCallback", and « ».
</p>

<p class="note">注記：
今の所，`~custom$である`要素$には %親 を渡さないのは意図的であるが、
将来に必要になった場合は変更され得る。
◎
It is intentional for now that custom elements do not get parent passed. This might change in the future if there is a need.
</p>
	<li>
<p>
%~node の`~shadowも含めた子孫$たちを成す
~EACH( %子孫 )
に対し，`~shadowも含めた~tree順序$で：
◎
For each shadow-including descendant descendant of node, in shadow-including tree order:
</p>
		<ol>
			<li>
`適用-可能な仕様$にて %子孫 用に`定義された各$( `除去-時の手続き$ %手続き )
に対し
⇒
%手続き( %子孫, ~NULL )
◎
Run the removing steps with descendant and null.
</li>
			<li>
~IF［
%子孫 は`~custom$である
］~AND［
%親は接続されているか ~EQ ~T
］
⇒
`~custom要素~callback反応を~enqueueする$(
%子孫,
`disconnectedCallback^l,
« »
)
◎
If descendant is custom and isParentConnected is true, then enqueue a custom element callback reaction with descendant, callback name "disconnectedCallback", and « ».
</li>
		</ol>
	</li>
	<li>
%親 の
~EACH( `広義-先祖$ %広義-先祖 )
に対し
⇒
%広義-先祖 の`登録-済み観測器~list$を成す
~EACH( %登録-済み )
に対し
⇒
~IF［
%登録-済み の`~option群$ob[ "$MutationObserverInit.subtree" ] ~EQ ~T
］
⇒
%~node の`登録-済み観測器~list$に 次を`付加する$
⇒
新たな`一時~登録-済み観測器$
— その
⇒＃
`観測器$ob ~SET %登録-済み の`観測器$ob,
`~option群$ob ~SET %登録-済み の`~option群$ob,
`~source$ob ~SET %登録-済み
◎
For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of inclusiveAncestor’s registered observer list, if registered’s options["subtree"] is true, then append a new transient registered observer whose observer is registered’s observer, options is registered’s options, and source is registered to node’s registered observer list.
</li>
	<li>
~IF［
%観測器を抑止するか ~EQ ε
］
⇒
%親 用に`~tree変異~記録を~queueする$( « », « %~node », %旧-直前の同胞, %旧-直後の同胞 )
◎
If suppressObservers is false, then queue a tree mutation record for parent with « », « node », oldPreviousSibling, and oldNextSibling.
</li>
	<!--cp-children-changed-steps-->
</ol>
</div>

			</section>
			<section id="interface-nonelementparentnode">
<h4 title="Mixin NonElementParentNode">4.2.4. ^@NonElementParentNode ~mixin</h4>

<p class="note">注記：
~Web互換性のため、
$getElementById() ~methodは，`要素$ 上には（したがって $ParentNode 上にも）公開できない。
◎
Web compatibility prevents the getElementById() method from being exposed on elements (and therefore on ParentNode).
</p>

！！
interface mixin @NonElementParentNode {
  $Element? $getElementById($DOMString %elementId);
};
$Document includes $NonElementParentNode;
$DocumentFragment includes $NonElementParentNode;
！

<dl class="domintro">
	<dt>%node . $getElementById(elementId)</dt>
	<dd>
%node の`子孫$である`要素$のうち［
`~ID$ ~EQ %elementId
］を満たす`最初のもの？$を返す。
◎
Returns the first element within node’s descendants whose ID is elementId.
</dd>
</dl>

<div class="algo">
@getElementById(elementId)
~method手続きは
⇒
~RET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`子孫$である
］~AND［
`要素$である
］~AND［
`~ID$（ ~NEQ ε ） ~EQ %elementId
］
◎
The getElementById(elementId) method steps are to return the first element, in tree order, within this’s descendants, whose ID is elementId; otherwise, if there is no such element, null.
</div>

			</section>
			<section id="mixin-documentorshadowroot">
<h4 title="Mixin DocumentOrShadowRoot">4.2.5. ^@DocumentOrShadowRoot ~mixin</h4>

！！
interface mixin @DocumentOrShadowRoot {
  readonly attribute $CustomElementRegistry? $customElementRegistry;
};

$Document includes $DocumentOrShadowRoot;
$ShadowRoot includes $DocumentOrShadowRoot;
！

<dl class="domintro">
	<dt>%registry  = %documentOrShadowRoot . $customElementRegistry</dt>
	<dd>
%documentOrShadowRoot は $CustomElementRegistry ~objを［
有するならば それ／
有さないならば ~NULL
］を返す。
◎
Returns documentOrShadowRoot’s CustomElementRegistry object, if any; otherwise null.
</dd>
</dl>

<div class="algo">
<p>
@customElementRegistry
取得子~手続きは：
◎
The customElementRegistry getter steps are:
</p>
<ol>
	<li>
~IF［
コレは`文書$である
］
⇒
~RET コレの`~custom要素~registry$doc
◎
If this is a document, then return this’s custom element registry.
</li>
	<li>
~Assert：
コレは`~shadow根$【！ShadowRoot node】である。
◎
Assert: this is a ShadowRoot node.
</li>
	<li>
~RET コレの`~custom要素~registry$sR
◎
Return this’s custom element registry.
</li>
</ol>
</div>

<p class="note">注記：
$DocumentOrShadowRoot ~mixinは、［
`文書$, `~shadow根$
］で共有される~APIを定義するよう求める他の標準により利用されることも期待されている。
◎
The DocumentOrShadowRoot mixin is also expected to be used by other standards that want to define APIs shared between documents and shadow roots.
</p>

			</section>
			<section id="interface-parentnode">
<h4 title="Mixin ParentNode">4.2.6. ^@ParentNode ~mixin</h4>

<div class="algo">
<p>
`~node群を~nodeに変換する@
~algoは、
所与の
( ［
`~node$／文字列
］たちが成す`~list$ %~node群, `文書$ %文書 )
に対し：
◎
To convert nodes into a node, given a list of nodes and strings nodes, and document document:
</p>

<ol>
	<li>
%変換-済み~node群 ~LET « »
◎
↓</li>
	<li>
<p>
%~node群 を成す
~EACH( %~item )
に対し：
</p>
		<ol>
			<li>
~IF［
%~item は文字列である
］
⇒
%~item ~SET `新たな~Text~node$( %~item, %文書 )
</li>
			<li>
%変換-済み~node群 に %~item を`付加する$
</li>
		</ol>
◎
Replace each string of nodes with a new Text node whose data is the string and node document is document.
</li>
	<li>
~IF［
%変換-済み~node群 の`~size$ ~EQ 1
］
⇒
~RET %変換-済み~node群[ 0 ]
◎
If nodes’s size is 1, then return nodes[0].
</li>
	<li>
%文書片 ~LET 新たな`文書片$
— その
⇒＃
`~node文書$ ~SET %文書
◎
Let fragment be a new DocumentFragment node whose node document is document.
</li>
	<li>
%変換-済み~node群 を成す
~EACH( %~node )
に対し
⇒
%文書片 に`~nodeを付加する$( %~node )
◎
For each node of nodes:＼
append node to fragment.
</li>
	<li>
~RET %文書片
◎
Return fragment.
</li>
</ol>
</div>

！！
interface mixin @@ParentNode {
  [`SameObject$] readonly attribute $HTMLCollection $children;
  readonly attribute $Element? $firstElementChild;
  readonly attribute $Element? $lastElementChild;
  readonly attribute `unsigned long$ $childElementCount;

  [`CEReactions$, `Unscopable$] $undefined $prepend(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $append(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $replaceChildren(($Node or $DOMString)... %nodes);
  [`CEReactions$] $undefined $moveBefore($Node %node, $Node? %child);

  $Element? $querySelector($DOMString %selectors);
  [`NewObject$] $NodeList $querySelectorAll($DOMString %selectors);
};
$Document includes $ParentNode;
$DocumentFragment includes $ParentNode;
$Element includes $ParentNode;
！

<dl class="domintro">
	<dt>%collection = %node . $children</dt>
	<dd>
`子$である`要素$をすべて返す。
◎
Returns the child elements.
</dd>

	<dt>%element = %node . $firstElementChild</dt>
	<dd>
`子$である`要素$のうち，`最初のもの？$を返す。
◎
Returns the first child that is an element; otherwise null.
</dd>

	<dt>%element = %node . $lastElementChild</dt>
	<dd>
 `子$である`要素$のうち，`最後のもの？$を返す。
◎
Returns the last child that is an element; otherwise null.
</dd>

	<dt>%node . $prepend(nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の`最初の子？$の前に挿入する。
◎
Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>

<dd id="cp-throw-if-violate-tree">
`~node~tree$に対する拘束に違反する場合、
`HierarchyRequestError$E が`投出$される。
◎
Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
</dd>

	<dt>%node . $append(nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の`最後の子？$の後に挿入する。
◎
Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->

	<dt>%node . $replaceChildren(nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%node の`子~群$すべてを %nodes で置換する。
◎
Replace all children of node with nodes, while replacing strings in nodes with equivalent Text nodes. 
</dd>
	<!--cp-throw-if-violate-tree-->

	<dt>%node . $moveBefore(movedNode, child)</dt>
	<dd>
%movedNode を
— まず除去することを伴わずに（ `without first removing^en ）【これは何を意味する？】 —
%node の中へ［
%child ~NEQ ~NULL ならば %child の直後【直前？】／
他の場合 %node の`最後の子？$の直後
］に移動する。
この~methodは、
%movedNode に結付けられた状態を保全する。
◎
Moves, without first removing, movedNode into node after child if child is non-null; otherwise after the last child of node. This method preserves state associated with movedNode.
</dd>
	<dd>
次のいずれかに該当する場合、
`HierarchyRequestError$E が`投出$される
⇒＃
`~node~tree$に対する拘束に違反する／
~the移動される~nodeに結付けられ~with~the状態を保全できない
◎
Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated, or the state associated with the moved node cannot be preserved.
</dd>

	<dt>%node . $querySelector(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する`要素$のうち，`最初のもの？$を返す。
◎
Returns the first element that is a descendant of node that matches selectors.
</dd>

	<dt>%node . $querySelectorAll(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する，すべての`要素$を返す。
◎
Returns all element descendants of node that match selectors.
</dd>
</dl>

<div class="algo">
@children
取得子~手続きは
⇒
~RET 次のように設定された $HTMLCollection `~collection$
⇒＃
`根$cL ~SET コレ,
`~filter$cLは コレの`子$である`要素$のみに合致する
◎
The children getter steps are to return an HTMLCollection collection rooted at this matching only element children.
</div>

<div class="algo">
@firstElementChild
取得子~手続きは
⇒
~RET コレの`子$である`要素$のうち，`最初のもの？$
◎
The firstElementChild getter steps are to return the first child that is an element; otherwise null.
</div>

<div class="algo">
@lastElementChild
取得子~手続きは
⇒
~RET コレの`子$である`要素$のうち，`最後のもの？$
◎
The lastElementChild getter steps are to return the last child that is an element; otherwise null.
</div>

<div class="algo">
@childElementCount
取得子~手続きは
⇒
~RET コレの`子$である`要素$の個数
◎
The childElementCount getter steps are to return the number of children of this that are elements.
</div>

<div class="algo">
<p>
@prepend(nodes)
~method手続きは：
◎
The prepend(nodes) method steps are:
</p>
<ol>
	<li id="cp-convert-nodes">
%~node ~LET `~node群を~nodeに変換する$( %nodes, コレの`~node文書$ )
◎
Let node be the result of converting nodes into a node given nodes and this’s node document.
</li>
	<li>
コレの中で`~nodeを子の前に前挿入する$( %~node, コレの`最初の子？$ )
◎
Pre-insert node into this before this’s first child.
</li>
</ol>
</div>

<div class="algo">
<p>
@append(nodes)
~method手続きは：
◎
The append(nodes) method steps are:
</p>
<ol>
	<!--cp-convert-nodes-->
	<li>
コレに`~nodeを付加する$( %~node )
◎
Append node to this.
</li>
</ol>
</div>

<div class="algo">
<p>
@replaceChildren(nodes)
~method手続きは：
◎
The replaceChildren(nodes) method steps are:
</p>
<ol>
	<!--cp-convert-nodes-->
	<li>
`親の中で子の前に挿入できるか検証する$( %~node, コレ, ~NULL )
◎
Ensure pre-insert validity of node into this before null.
</li>
	<li>
コレの`全~内容を~nodeで置換する$( %~node )
◎
Replace all with node within this.
</li>
</ol>
</div>

<div class="algo">
<p>
@moveBefore(node, child )
~method手続きは：
◎
The moveBefore(node, child) method steps are:
</p>
<ol>
	<li>
%基準~子 ~LET %child
◎
Let referenceChild be child.
</li>
	<li>
~IF［
%基準~子 ~EQ %node
］
⇒
%基準~子 ~SET %node の`直後の同胞？$
◎
If referenceChild is node, then set referenceChild to node’s next sibling.
</li>
	<li>
`~nodeを移動する$( %node, コレ, %基準~子 )
◎
Move node into this before referenceChild.
</li>
</ol>
</div>

<div class="algo">
@querySelector(selectors)
~method手続きは
⇒
~RET 次の結果を成す要素のうち，`最初のもの？$
⇒
`~nodeの視野の下で選択子を照合する$( %selectors, コレ )
◎
The querySelector(selectors) method steps are to return the first result of running scope-match a selectors string selectors against this, if the result is not an empty list; otherwise null.
</div>

<div class="algo">
@querySelectorAll(selectors)
~method手続きは、
次の結果を`静的$なものとして返す
⇒
`~nodeの視野の下で選択子を照合する$( %selectors, コレ )
◎
The querySelectorAll(selectors) method steps are to return the static result of running scope-match a selectors string selectors against this.
</div>

			</section>
			<section id="interface-nondocumenttypechildnode">
<h4 title="Mixin NonDocumentTypeChildNode">4.2.7. ^@NonDocumentTypeChildNode ~mixin</h4>

<p class="note">注記：
~Web互換性のため、
$previousElementSibling, $nextElementSibling
属性は，`~doctype$上には（したがって， $ChildNode 上にも）公開できない。
◎
Web compatibility prevents the previousElementSibling and nextElementSibling attributes from being exposed on doctypes (and therefore on ChildNode).
</p>

！！
interface mixin @NonDocumentTypeChildNode {
  readonly attribute $Element? $previousElementSibling;
  readonly attribute $Element? $nextElementSibling;
};
$Element includes $NonDocumentTypeChildNode;
$CharacterData includes $NonDocumentTypeChildNode;
！

<dl class="domintro">
	<dt>%element = %node . $previousElementSibling</dt>
	<dd>
`先行-$する`同胞$である`要素$のうち，`最後のもの？$を返す。
◎
Returns the first preceding sibling that is an element; otherwise null.
</dd>

	<dt>%element = %node . $nextElementSibling</dt>
	<dd>
`後続-$する`同胞$である`要素$のうち，`最初のもの？$を返す。
◎
Returns the first following sibling that is an element; otherwise null.
</dd>
</dl>

<div class="algo">
@previousElementSibling
取得子~手続きは
⇒
~RET 次を満たす~nodeのうち，`最後のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`先行-$する
］~AND［
`要素$である
］
◎
The previousElementSibling getter steps are to return the first preceding sibling that is an element; otherwise null.
</div>

<div class="algo">
@nextElementSibling
取得子~手続きは
⇒
~RET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`後続-$する
］~AND［
`要素$である
］
◎
The nextElementSibling getter steps are to return the first following sibling that is an element; otherwise null.
</div>

			</section>
			<section id="interface-childnode">
<h4 title="Mixin ChildNode">4.2.8. ^@ChildNode ~mixin</h4>

！！
interface mixin @ChildNode {
  [`CEReactions$, `Unscopable$] $undefined $before(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $after(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $replaceWith(($Node or $DOMString)... %nodes);
  [`CEReactions$, `Unscopable$] $undefined $remove();
};
$DocumentType includes $ChildNode;
$Element includes $ChildNode;
$CharacterData includes $ChildNode;
！

<dl class="domintro">
	<dt>%node . $before(...nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の直前に挿入する。
◎
Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $after(...nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%nodes を %node の直後に挿入する。
◎
Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $replaceWith(...nodes)</dt>
	<dd>
%nodes 内の各 文字列は等価な $Text `~node$に置換した上で、
%node を %nodes に置換する。
◎
Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $remove()</dt>
	<dd>
%node を除去する。
◎
Removes node.
</dd>
</dl>

<div class="algo">
<p>
@before(nodes)
~method手続きは：
◎
The before(nodes) method steps are:
</p>
<ol>
	<li id="cp-let-ctx-parent">
%親 ~LET コレの`親$
◎
Let parent be this’s parent.
</li>
	<li id="cp-exit-if-null-parent">
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
◎
If parent is null, then return.
</li>
	<li>
%およそ直前の同胞 ~LET 次を満たす~nodeのうち，`最後のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`先行-$する
］~AND［
~node ~NIN %nodes
］
◎
Let viablePreviousSibling be this’s first preceding sibling not in nodes; otherwise null.
</li>
	<li id="cp-convert-nodes-with-parent">
%~node ~LET `~node群を~nodeに変換する$( %nodes, コレの`~node文書$ )
◎
Let node be the result of converting nodes into a node, given nodes and this’s node document.
</li>
	<li>
%およそ直前の同胞 ~SET %およそ直前の同胞 に応じて
⇒＃
~NULL ならば %親 の`最初の子？$ ／
~ELSE_ %およそ直前の同胞 の`直後の同胞？$
◎
If viablePreviousSibling is null, then set it to parent’s first child; otherwise to viablePreviousSibling’s next sibling.
</li>
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %~node, %およそ直前の同胞 )
◎
Pre-insert node into parent before viablePreviousSibling.
</li>
</ol>
</div>

<div class="algo">
<p>
@after(nodes)
~method手続きは：
◎
The after(nodes) method steps are:
</p>
<ol>
	<!--cp-let-ctx-parent-->
	<!--cp-exit-if-null-parent-->
	<li id="cp-let-viableNextSibling">
%およそ直後の同胞 ~LET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`同胞$である
］~AND［
コレに`後続-$する
］~AND［
~node ~NIN %nodes
］
◎
Let viableNextSibling be this’s first following sibling not in nodes; otherwise null.
</li>
	<!--cp-convert-nodes-with-parent-->
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %~node, %およそ直後の同胞 )
◎
Pre-insert node into parent before viableNextSibling.
</li>
</ol>
</div>

<div class="algo">
<p>
@replaceWith(nodes)
~method手続きは：
◎
The replaceWith(nodes) method steps are:
</p>
<ol>
	<!--cp-let-ctx-parent-->
	<!--cp-exit-if-null-parent-->
	<!--cp-let-viableNextSibling-->
	<!--cp-convert-nodes-with-parent-->
	<li>
<p>
~IF［
コレの`親$ ~EQ %親
］
⇒
%親 の中で`子を~nodeに置換する$( コレ, %~node )
◎
If this’s parent is parent, replace this with node within parent.
</p>

<p class="note">注記：
コレは %~node の中へ挿入-済みなこともある。
◎
This could have been inserted into node.
</p>
	</li>
	<li>
~ELSE
⇒
%親 の中で`~nodeを子の前に前挿入する$( %~node, %およそ直後の同胞 )
◎
Otherwise, pre-insert node into parent before viableNextSibling.
</li>
</ol>
</div>

<div class="algo">
<p>
@remove()
~method手続きは：
◎
The remove() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`親$ ~EQ ~NULL
］
⇒
~RET
◎
If this’s parent is null, then return.
</li>
	<li>
`~nodeを除去する$( コレ )
◎
Remove this.
</li>
</ol>
</div>

			</section>
			<section id="mixin-slotable">
<h4 title="Mixin Slottable">4.2.9. ^@Slottable ~mixin</h4>

！！
interface mixin @Slottable {
  readonly attribute $HTMLSlotElement? $assignedSlot;
};

$Element includes $Slottable;
$Text includes $Slottable;
！

<div class="algo">
@assignedSlot
取得子~手続きは
⇒
~RET `~slot可能~用に~slotを見出す$( コレ, `~open^i )
◎
The assignedSlot getter steps are to return the result of find a slot given this and true.
</div>

			</section>
			<section id="old-style-collections">
<h4 title="Old-style collections: NodeList and HTMLCollection">4.2.10. 旧式な~collection： ^NodeList と ^HTMLCollection</h4>

<p>
`~collection@
は、
`~node$たちが成す~listを表現する~objである。
`~collection$は
`~live@
にも
`静的@
にもなり得る。
他が言明されない限り、
`~collection$は`~live$になるモノトスル。
◎
A collection is an object that represents a list of nodes. A collection can be either live or static. Unless otherwise stated, a collection must be live.
</p>

<p>
`~live$である`~collection$の［
属性／~method
］は、
~dataの~snapshotではなく 実際の下層~data†に対し，演算するモノトスル††。
◎
If a collection is live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

<p class="trans-note">【†
すなわち、
作成-時の~data（~snapshot）ではなく，~accessされた時点における~data
】【††
したがって，~collectionを辿っている間に~treeを改変するときは、
~collectionの無限増殖に陥いらないよう注意する必要がある。
】【
`静的$とされている場合は，逆に、
~dataの~snapshotに対し演算することになる。
】</p>

<div class="p">
<p>
各 `~collection$の作成-時には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`根@cL
⇒
~collectionの視野を与える。
</li>
	<li>
`~filter@cL
⇒
~nodeが~collectionに含められるための条件を与える。
</li>
</ul>
◎
When a collection is created, a filter and a root are associated with it.
</div>

<p>
`~collection$は、
その`根$cLを根とする下位treeの中で［
所与の`~filter$cLに合致する`~node$のみ
］を包含するような~viewを
`表現-@
する。
この~viewは全順序である
— `~collection$に含められる~nodeたちは、
他の要件が指定されない限り，`~tree順序$で~sortするモノトスル。
◎
The collection then represents a view of the subtree rooted at the collection’s root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the collection must be sorted in tree order.
</p>

<p class="trans-note">【
ほとんどの~collectionでは，`根$cL自身は`~filter$cLに合致しないが、
$NodeIterator の`反復器~collection$など，そうでないものもある。
】</p>

				<section id="interface-nodelist">
<h5 title="Interface NodeList">4.2.10.1. ^@NodeList ~interface</h5>

<p>
$NodeList ~objは`~node$の`~collection$である。
◎
A NodeList object is a collection of nodes.
</p>

！！
[`Exposed$=Window]
interface @NodeList {
  getter $Node? $item(`unsigned long$ %index);
  readonly attribute `unsigned long$ $length;
  iterable&lt;$Node&gt;;
};
！

<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`~node$の個数を返す。
◎
Returns the number of nodes in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`~tree順序$に~sortされた下で、
`~collection$の中で， %index 番の`~node$を返す。
◎
Returns the node with index index from the collection. The nodes are sorted in tree order.
</dd>
</dl>

<p>
~collection %O が`~supportする~prop~index$は、
0 以上［
%O が`表現-$する~nodeの個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of nodes represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレが`表現-$する~nodeの個数
◎
The length attribute must return the number of nodes represented by the collection.
</div>

<div class="algo">
@item(index)
~method手続きは
⇒
~RET ［
%index ~NIN { コレが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  コレの中の %index 番の`~node$
］
◎
The item(index) method must return the indexth node in the collection. If there is no indexth node in the collection, then the method must return null.
</div>

				</section>
				<section id="interface-htmlcollection">
<h5 title="Interface HTMLCollection">4.2.10.2. ^@HTMLCollection ~interface</h5>

！！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @HTMLCollection {
  readonly attribute `unsigned long$ $length;
  getter $Element? $item(`unsigned long$ %index);
  getter $Element? $namedItem($DOMString %name);
};
！

<p>
$HTMLCollection ~objは`要素$の`~collection$である。
◎
An HTMLCollection object is a collection of elements.
</p>

<p class="note">注記：
$HTMLCollection は、
歴史的な~~理由から~~廃するわけにいかない所産である。
開発者は，それを利用し続けても構わないが、
新たな~API標準の設計者は，それを利用しないこと
（代わりに~IDL`連列~型＠~WEBIDL#idl-sequence$を利用すること）。
◎
HTMLCollection is a historical artifact we cannot rid the web of. While developers are of course welcome to keep using it, new API standard designers ought not to use it (use sequence&lt;T&gt; in IDL instead).
</p>

<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`要素$の個数を返す。
◎
Returns the number of elements in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`要素$たちを`~tree順序$に~sortした下での、
`~collection$の中で %index 番の`要素$を返す。
◎
Returns the element with index index from the collection. The elements are sorted in tree order.
</dd>

	<dt>%element = %collection . $namedItem(name)</dt>
	<dt>%element = %collection[%name]</dt>
	<dd>
`~collection$の中で［
`~ID$または名前
］が %name に一致する最初の`要素$を返す。
◎
Returns the first element with ID or name name from the collection.
</dd>
</dl>

<p>
`~collection$ %O が`~supportする~prop~index$は、
0 以上［
%O が`表現-$する要素の個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of elements represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレが`表現-$する~nodeの個数
◎
The length getter steps are to return the number of nodes represented by the collection.
</div>

<div class="algo">
@item(index)
~method手続きは
⇒
~RET ［
%index ~NIN { コレが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  コレの中の %index 番の`~node$
］
◎
The item(index) method steps are to return the indexth element in the collection. If there is no indexth element in the collection, then the method must return null.
</div>

<div class="algo">
<p>
`~collection$ %O が`~supportする~prop名$たちは、
次の手続きの結果で与えられる：
◎
The supported property names are the values from the list returned by these steps:
</p>
<ol>
	<li>
%結果 ~LET « »
◎
Let result be an empty list.
</li>
	<li>
<p>
%O が`表現-$する
~EACH( 要素 %要素 )
に対し，`~tree順序$で：
◎
For each element represented by the collection, in tree order:
</p>
		<ol>
			<li>
%~ID ~LET %要素 の`~ID$
◎
↓</li>
			<li>
~IF［
%~ID ~NEQ ε
］~AND［
%~ID ~NIN %結果
］
⇒
%結果 に %~ID を付加する
◎
If element has an ID which is not in result, append element’s ID to result.
</li>
			<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`属性o~list$el内に `name^A `属性o$nmは在る
］~AND［
その属性oの`値$a %name ~NEQ 空~文字列
］~AND［
%name ~NIN %結果
］
⇒
%結果 に %name を付加する
◎
If element is in the HTML namespace and has a name attribute whose value is neither the empty string nor is in result, append element’s name attribute value to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
@namedItem(name)
~method手続きは：
◎
The namedItem(key) method steps are:
</p>
<ol>
	<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If key is the empty string, return null.
</li>
	<li>
<p>
~RET コレが`表現-$する`要素$たちのうち，
~OR↓ を満たす`最初のもの？$：
</p>
		<ul>
			<li>
`~ID$（ ~NEQ ε ） ~EQ %name
</li>
			<li>
［
`~HTML~ns$に属する
］~AND［
`属性o~list$el内に，次を満たす`属性o$は在る
］
⇒
［
`name^A `属性o$nmである
］~AND［
`値$a ~EQ %name
］
</li>
		</ul>
◎
Return the first element in the collection for which at least one of the following is true:
• it has an ID which is key;
• it is in the HTML namespace and has a name attribute whose value is key;
◎
or null if there is no such element.
</li>
</ol>
</div>

				</section>
			</section>
		</section>
		<section id="mutation-observers">
<h3 title="Mutation observers">4.3. 変異~観測器</h3>

<p>
各 `生成元が類似な~window~agent$ `HTML$r
には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`変異~観測器の小taskは~queueされたか@
⇒
真偽値
— 初期~時は ~F とする。
◎
Each similar-origin window agent has a mutation observer microtask queued (a boolean), which is initially false. [HTML]
</li>
	<li>
`処理待ち変異~観測器~群@
⇒
$MutationObserver ~objたちが成す`有順序~集合$
— 初期~時は`空$とする。
◎
Each similar-origin window agent also has pending mutation observers (a set of zero or more MutationObserver objects), which is initially empty.
</li>
</ul>

<div class="algo">
<p>
`変異~観測器 小taskを~queueする@
~algoは：
◎
To queue a mutation observer microtask:
</p>
<ol>
	<li>
~IF［
`~surrounding~agent$の`変異~観測器の小taskは~queueされたか$ ~EQ ~T
］
⇒
~RET
◎
If the surrounding agent’s mutation observer microtask queued is true, then return.
</li>
	<li>
`~surrounding~agent$の`変異~観測器の小taskは~queueされたか$ ~SET ~T
◎
Set the surrounding agent’s mutation observer microtask queued to true.
</li>
	<li>
`小taskを~queueする$( `変異~観測器に通知する$手続き )
◎
Queue a microtask to notify mutation observers.
</li>
</ol>
</div>

<div class="algo">
<p>
`変異~観測器に通知する@
~algoは：
◎
To notify mutation observers, run these steps:
</p>
<ol>
	<li>
`~surrounding~agent$の`変異~観測器の小taskは~queueされたか$ ~SET ~F
◎
Set the surrounding agent’s mutation observer microtask queued to false.
</li>
	<li>
%通知-集合 ~LET `~surrounding~agent$の`処理待ち変異~観測器~群$を`~cloneする$
◎
Let notifySet be a clone of the surrounding agent’s pending mutation observers.
</li>
	<li>
`~surrounding~agent$の`処理待ち変異~観測器~群$を`空にする$
◎
Empty the surrounding agent’s pending mutation observers.
</li>
	<li>
%通達~slot集合 ~LET `~surrounding~agent$の`通達~slot群$を`~cloneする$
◎
Let signalSet be a clone of the surrounding agent’s signal slots.
</li>
	<li>
`~surrounding~agent$の`通達~slot群$を`空にする$
◎
Empty the surrounding agent’s signal slots.
</li>
	<li>
<p>
%通知-集合 を成す
~EACH( %観測器 )
に対し：
◎
For each mo of notifySet:
</p>
		<ol>
			<li>
%記録~群 ~LET %観測器 の`記録~queue$moを`~cloneする$
◎
Let records be a clone of mo’s record queue.
</li>
			<li>
%観測器 の`記録~queue$moを`空にする$
◎
Empty mo’s record queue.
</li>
			<li>
%観測器 の`~node~list$moを成す
~EACH( %~node )
に対し
⇒
%~node の`登録-済み観測器~list$から 次を満たす`一時~登録-済み観測器$をすべて`除去する$
⇒
その`観測器$ob ~EQ %観測器
◎
For each node of mo’s node list:＼
remove all transient registered observers whose observer is mo from node’s registered observer list.
</li>
			<li>
~IF［
%記録~群 は`空$でない
］
⇒
`~callback関数を呼出す$( %観測器 の`~callback$mo, « %記録~群, %観測器 », `報告する^i, %観測器 )
◎
If records is not empty, then invoke mo’s callback with « records, mo » and "report", and with callback this value mo.
</li>
		</ol>
	</li>
	<li>
%通達~slot集合 を成す
~EACH( `~slot$ %~slot )
に対し
⇒
`~eventを発火する$( %~slot,
`slotchange@et
)
— 次のように初期化して
⇒
$Event.bubbles 属性 ~SET ~T
◎
For each slot of signalSet:＼
fire an event named slotchange, with its bubbles attribute set to true, at slot.
</li>
</ol>
</div>

<hr>

<p>
各 `~node$には、
`登録-済み観測器~list@
が結付けられる
— それは、
`登録-済み観測器$たちが成す`~list$であり，初期~時は`空$とする。
【この~nodeにおける変異を観測している観測器たちを表す。】
◎
Each node has a registered observer list (a list of zero or more registered observers), which is initially empty.
</p>

<div class="p">
<p>
各
`登録-済み観測器@
は、
次に挙げるものからなる：
</p>
<ul>
	<li>
`観測器@ob
⇒
$MutationObserver ~obj
</li>
	<li>
`~option群@ob
⇒
$MutationObserverInit 辞書
</li>
</ul>
◎
A registered observer consists of an observer (a MutationObserver object) and options (a MutationObserverInit dictionary).
</div>

<div class="p">
<p>
`一時~登録-済み観測器@
は、
上述に加えて 次に挙げるものも有する，`登録-済み観測器$である：
</p>
<ul>
	<li>
`~source@ob
⇒
`登録-済み観測器$
</li>
</ul>
◎
A transient registered observer is a registered observer that also consists of a source (a registered observer).
</div>

<p class="note">注記：
`一時~登録-済み観測器$は、
所与の`~node$に対し，それが除去された後も`~node$の`子孫$における変異を追跡するために利用される
— これにより、
`~node$の`親$にて $MutationObserverInit.subtree が ~T に設定されたときでも，それらの変異は失われずに済む。
◎
Transient registered observers are used to track mutations within a given node’s descendants after node has been removed so they do not get lost when subtree is set to true on node’s parent.
</p>

			<section id="interface-mutationobserver">
<h4 title="Interface MutationObserver">4.3.1. ^@MutationObserver ~interface</h4>

！！
[`Exposed$=Window]
interface @MutationObserver {
  `MutationObserver$mc($MutationCallback %callback);

  $undefined $observe($Node %target, optional $MutationObserverInit %options = {});
  $undefined $disconnect();
  $sequence&lt;$MutationRecord&gt; $takeRecords();
};

callback @MutationCallback = $undefined ($sequence&lt;$MutationRecord&gt; %mutations, $MutationObserver %observer);

dictionary @@MutationObserverInit {
  $boolean @childList = false;
  $boolean @attributes;
  $boolean @characterData;
  $boolean @subtree = false;
  $boolean @attributeOldValue;
  $boolean @characterDataOldValue;
  $sequence&lt;$DOMString&gt; @attributeFilter;
};
！

<!-- ^@MutationObserver -->
<p>
$MutationObserver ~objを利用すれば、
`~node$が成す`~tree$における変異を観測できる。
◎
A MutationObserver object can be used to observe mutations to the tree of nodes.
</p>

<p>
各 $MutationObserver ~objには、
次に挙げる概念が結付けられる：
◎
Each MutationObserver object has these associated concepts:
</p>
<ul>
	<li>
`~callback@mo
⇒
~callback関数。
~objの作成-時に設定される。
◎
A callback set on creation.
</li>
	<li>
`~node~list@mo
⇒
［
`~node$への弱い参照
］たちが成す`~list$
— 初期~時は`空$とする。
◎
A node list (a list of weak references to nodes), which is initially empty.
</li>
	<li>
`記録~queue@mo
⇒
$MutationRecord ~objたちが成す`~queue$
— 初期~時は`空$とする。
◎
A record queue (a queue of zero or more MutationRecord objects), which is initially empty.
</li>
</ul>

<dl class="domintro">
	<dt>%observer = $MutationObserver(callback)</dt>
	<dd>
$MutationObserver ~objを構築し，その`~callback$moを %callback に設定する。
%callback は、
その 1 個目, 2 個目の引数に
( $MutationRecord ~objたちが成す~list, 構築された %observer )
が渡されて呼出される。
%callback は、
$observe() ~methodにより登録-済みにされた`~node$が変異したとき（した後）に，呼出される。
◎
Constructs a MutationObserver object and sets its callback to callback. The callback is invoked with a list of MutationRecord objects as first argument and the constructed MutationObserver object as second argument. It is invoked after nodes registered with the observe() method, are mutated.
</dd>

	<dt>%observer . $observe(target, options)</dt>
	<dd>
%target （ `~node$ ）を観測して，
%options （ ~obj）に与えた判定基準に基づいて変異を報告するよう、
~UAに指図する。
◎
Instructs the user agent to observe a given target (a node) and report any mutations based on the criteria given by options (an object).
</dd>
	<dd>
<p>
%options 引数に与えた~objの各~memberを介して，観測させる変異についての~optionを設定できる。
利用できる~obj~memberは：
◎
The options argument allows for setting mutation observation options via object members. These are the object members that can be used:
</p>

<!-- ^@MutationObserverInit -->
		<dl>
			<dt>$childList</dt>
			<dd>
%target の`子~群$の変異を観測するときは、
~T にする。
◎
Set to true if mutations to target’s children are to be observed.
</dd>

			<dt>$attributes</dt>
			<dd>
%target の`属性o$の変異を観測するときは、
~T にする。
$attributeOldValue または $attributeFilter を指定している場合は、
省略できる。
◎
Set to true if mutations to target’s attributes are to be observed. Can be omitted if attributeOldValue or attributeFilter is specified.
</dd>

			<dt>$characterData</dt>
			<dd>
%target の`~data$の変異を観測するときは、
~T にする。
$characterDataOldValue を指定している場合は、
省略できる。
◎
Set to true if mutations to target’s data are to be observed. Can be omitted if characterDataOldValue is specified.
</dd>

			<dt>$subtree</dt>
			<dd>
%target のみならず，
%target の`子孫$の変異も観測するときは、
~T にする。
◎
Set to true if mutations to not just target, but also target’s descendants are to be observed.
</dd>

			<dt>$attributeOldValue</dt>
			<dd>
$attributes を~T にしているか省略していて，かつ
変異~前の %target の`属性o$ `値$aを記録しておく必要がある場合は、
~T にする。
◎
Set to true if attributes is true or omitted and target’s attribute value before the mutation needs to be recorded.
</dd>

			<dt>$characterDataOldValue</dt>
			<dd>
$characterData を~T にしているか省略していて，かつ
変異~前の %target の`~data$を記録しておく必要がある場合は、
~T にする。
◎
Set to true if characterData is set to true or omitted and target’s data before the mutation needs to be recorded.
</dd>

			<dt>$attributeFilter</dt>
			<dd>
$attributes を ~T にしているか省略していて，かつ
すべての`属性o$の変異を観測する必要はない場合は、
必要な`属性o$の（`~ns$a のない）`局所~名$aたちが成す~listを与える。
◎
Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted.
</dd>

		</dl>
	</dd>

<!-- ^@MutationObserver-->

	<dt>%observer . $disconnect()</dt>
	<dd>
%observer による変異の観測を停止する。
$observe() ~methodが再び利用されるまで，
%observer の`~callback$moは呼出されないことになる。
◎
Stops observer from observing any mutations. Until the observe() method is used again, observer’s callback will not be invoked.
</dd>

	<dt>%observer . $takeRecords()</dt>
	<dd>
`記録~queue$moを空にして，空にする前の内容を返す。
◎
Empties the record queue and returns what was in there.
</dd>
</dl>

<div class="algo">
<p>
@MutationObserver(callback)
構築子~手続きは
⇒
コレの`~callback$mo ~SET %callback
◎
The new MutationObserver(callback) constructor steps are to set this’s callback to callback.
</p>
</div>

<div class="algo">
<p>
@observe(target, options)
~method手続きは：
◎
The observe(target, options) method steps are:
</p>
<!-- ^@MutationObserverInit -->
<ol>
	<li>
~IF［［
%options[ "$attributeOldValue" ] ~NEQ ε
］~OR［
%options[ "$attributeFilter" ] ~NEQ ε
］］~AND［
%options[ "$attributes" ] ~EQ ε
］
⇒
%options[ "$attributes" ] ~SET ~T
◎
If either options["attributeOldValue"] or options["attributeFilter"] exists, and options["attributes"] does not exist, then set options["attributes"] to true.
</li>
	<li>
~IF［
%options[ "$characterDataOldValue" ] ~NEQ ε
］~AND［
%options[ "$characterData" ] ~EQ ε
］
⇒
%options[ "$characterData" ] ~SET ~T
◎
If options["characterDataOldValue"] exists and options["characterData"] does not exist, then set options["characterData"] to true.
</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
↓</p>
		<ul>
			<li>
［
%options[ "$childList" ] ~EQ ~F
］~AND［
%options[ "$attributes" ] ~EQ ~F
］~AND［
%options[ "$characterData" ] ~EQ ~F
］
◎
If none of options["childList"], options["attributes"], and options["characterData"] is true, then throw a TypeError.
</li>
			<li>
［
%options[ "$attributeOldValue" ] ~EQ ~T
］~AND［
%options[ "$attributes" ] ~EQ ~F
］
◎
If options["attributeOldValue"] is true and options["attributes"] is false, then throw a TypeError.
</li>
			<li>
［
%options[ "$attributeFilter" ] ~NEQ ε
］~AND［
%options[ "$attributes" ] ~EQ ~F
］
◎
If options["attributeFilter"] is present and options["attributes"] is false, then throw a TypeError.
</li>
			<li>
［
%options[ "$characterDataOldValue" ] ~EQ ~T
］~AND［
%options[ "$characterData" ] ~EQ ~F
］
◎
If options["characterDataOldValue"] is true and options["characterData"] is false, then throw a TypeError.
</li>
		</ul>
<p>
…ならば
⇒
~THROW `TypeError$E
◎
↑</p>
	</li>
	<li>
%登録-済み~list ~LET %target の`登録-済み観測器~list$内の次を満たす`登録-済み観測器$たちが成す~list
⇒
その`観測器$ob ~EQ コレ
◎
↓</li>
	<li>
<p>
%登録-済み~list を成す
~EACH( %登録-済み )
に対し：
◎
For each registered of target’s registered observer list:＼
if registered’s observer is this:
</p>
		<ol>
			<li>
コレの`~node~list$moを成す
~EACH( %~node )
に対し
⇒
%~node の`登録-済み観測器~list$から 次を満たす`一時~登録-済み観測器$をすべて`除去する$
⇒
その`~source$ob ~EQ %登録-済み
◎
For each node of this’s node list:＼
remove all transient registered observers whose source is registered from node’s registered observer list.
</li>
			<li>
%登録-済み の`~option群$ob ~SET %options
◎
Set registered’s options to options.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%登録-済み~list は`空$である
］：
◎
Otherwise:
</p>
		<ol>
			<li>
%target の`登録-済み観測器~list$に次を`付加する$
⇒
新たな`登録-済み観測器$
— その
⇒＃
`観測器$ob ~SET コレ,
`~option群$ob ~SET %options
◎
Append a new registered observer whose observer is this and options is options to target’s registered observer list.
</li>
			<li>
コレの`~node~list$moに［
%target への弱い参照
］を`付加する$
◎
Append a weak reference to target to this’s node list.
</li>
		</ol>
	</li>
</ol>
</div>

<!-- ^@MutationObserver -->
<div class="algo">
<p>
@disconnect()
~method手続きは：
◎
The disconnect() method steps are:
</p>
<ol>
	<li>
コレの`~node~list$moを成す
~EACH( %~node )
に対し
⇒
%~node の`登録-済み観測器~list$から，次を満たす`登録-済み観測器$をすべて除去する
⇒
その`観測器$ob ~EQ コレ
◎
For each node of this’s node list:＼
remove any registered observer from node’s registered observer list for which this is the observer.
</li>
	<li>
コレの`記録~queue$moを`空にする$
◎
Empty this’s record queue.
</li>
</ol>
</div>

<div class="algo">
<p>
@takeRecords()
~method手続きは：
◎
The takeRecords() method steps are:
</p>
<ol>
	<li>
%記録~群 ~LET コレの`記録~queue$moを`~cloneする$
◎
Let records be a clone of this’s record queue.
</li>
	<li>
コレの`記録~queue$moを`空にする$
◎
Empty this’s record queue.
</li>
	<li>
~RET %記録~群
◎
Return records.
</li>
</ol>
</div>

			</section>
			<section id="queueing-a-mutation-record">
<h4 title="Queuing a mutation record">4.3.2. 変異~記録の~queue法</h4>

<div class="algo">
<p>
%~target 用に ある %種別 の
`変異~記録を~queueする@
~algoは、
所与の
(
%名前, %~ns, %旧-値,
%追加-済み~node群, %除去-済み~node群, %直前の同胞, %直後の同胞
)
に対し：
◎
To queue a mutation record of type for target with name, namespace, oldValue, addedNodes, removedNodes, previousSibling, and nextSibling:
</p>
<ol>
	<li>
%有関係~観測器~群 ~LET 新たな`~map$
◎
Let interestedObservers be an empty map.
</li>
	<li>
<p>
%~target の`広義-先祖$たちを成す
~EACH( %~node )
に対し【順序は？】：
◎
Let nodes be the inclusive ancestors of target.
◎
For each node of nodes,＼
</p>
		<ol>
			<li>
<p>
%~node の`登録-済み観測器~list$を成す
~EACH( %登録-済み )
に対し：
◎
and then for each registered of node’s registered observer list:
</p>
				<ol>
					<li>
%options ~LET %登録-済み の`~option群$ob
◎
Let options be registered’s options.
</li>
					<li>
<p>
~IF［
~OR↓
］…
◎
If none of the following are true
</p>
<!-- ^@MutationObserverInit -->
						<ul>
							<li>
［
%~node ~NEQ %~target
］~AND［
%options[ "$subtree" ] ~EQ ~F
］
◎
node is not target and options["subtree"] is false
</li>
							<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options[ "$attributes" ] ~NEQ ~T
］
◎
type is "attributes" and options["attributes"] either does not exist or is false
</li>
							<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options[ "$attributeFilter" ] ~NEQ ε
］~AND［［
%名前 ~NIN %options[ "$attributeFilter" ]
］~OR［
%~ns ~NEQ ~NULL
］］
◎
type is "attributes", options["attributeFilter"] exists, and options["attributeFilter"] does not contain name or namespace is non-null
</li>
							<li>
［
%種別 ~EQ `characterData^l
］~AND［
%options[ "$characterData" ] ~NEQ ~T
］
◎
type is "characterData" and options["characterData"] either does not exist or is false
</li>
							<li>
［
%種別 ~EQ `childList^l
］~AND［
%options[ "$childList" ] ~EQ ~F
］
◎
type is "childList" and options["childList"] is false 
</li>
						</ul>
<p>
…ならば
⇒
~CONTINUE
◎
then:
</p>
					</li>
					<li>
%観測器 ~LET %登録-済み の`観測器$ob
◎
Let mo be registered’s observer.
</li>
					<li>
~IF［
%有関係~観測器~群[ %観測器 ] ~EQ ε
］
⇒
%有関係~観測器~群[ %観測器 ] ~SET ~NULL
◎
If interestedObservers[mo] does not exist, then set interestedObservers[mo] to null.
</li>
					<li>
<p>
~IF［
~OR↓
］…
◎
If either＼
</p>
						<ul>
							<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options[ "$attributeOldValue" ] ~EQ ~T
］
◎

type is "attributes" and options["attributeOldValue"] is true,＼
</li>
							<li>
［
%種別 ~EQ `characterData^l
］~AND［
%options[ "$characterDataOldValue" ] ~EQ ~T
］
◎
or type is "characterData" and options["characterDataOldValue"] is true,＼
</li>
						</ul>
<p>
…ならば
⇒
%有関係~観測器~群[ %観測器 ] ~SET %旧-値
◎
then set interestedObservers[mo] to oldValue.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%有関係~観測器~群 を成す
~EACH( %観測器 → %~map先の旧-値 )
に対し：
◎
For each observer → mappedOldValue of interestedObservers:
</p>
		<ol>
			<li>
%記録 ~LET `新たな~obj$( $@MutationRecord )
— その
⇒＃
$type ~SET %種別,
$target ~SET %~target,
$attributeName ~SET %名前,
$attributeNamespace ~SET %~ns,
$oldValue ~SET %~map先の旧-値,
$addedNodes ~SET %追加-済み~node群,
$removedNodes ~SET %除去-済み~node群,
$previousSibling ~SET %直前の同胞,
$nextSibling ~SET %直後の同胞,
◎
Let record be a new MutationRecord object with its type set to type, target set to target, attributeName set to name, attributeNamespace set to namespace, oldValue set to mappedOldValue, addedNodes set to addedNodes, removedNodes set to removedNodes, previousSibling set to previousSibling, and nextSibling set to nextSibling.
</li>
			<li>
%観測器 の`記録~queue$moに %記録 を`~enqueueする$
◎
Enqueue record to observer’s record queue.
</li>
			<li>
`~surrounding~agent$の`処理待ち変異~観測器~群$に %観測器 を`付加する$set
◎
Append observer to the surrounding agent’s pending mutation observers.
</li>
		</ol>
	</li>
	<li>
`変異~観測器 小taskを~queueする$
◎
Queue a mutation observer microtask.
</li>
</ol>
</div>

<div class="algo">
<p>
%~target 用に
`~tree変異~記録を~queueする@
~algoは、
所与の
( %追加-済み~node群, %除去-済み~node群, %直前の同胞, %直後の同胞 )
に対し：
◎
To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and nextSibling:
</p>
<ol>
	<li>
~Assert：
［
%追加-済み~node群 は`空$でない
］~OR［
%除去-済み~node群 は`空$でない
］
◎
Assert: either addedNodes or removedNodes is not empty.
</li>
	<li>
%~target 用に種別 `childList^l の`変異~記録を~queueする$( ↓ )
⇒＃
~NULL,
~NULL,
~NULL,
%追加-済み~node群,
%除去-済み~node群,
%直前の同胞,
%直後の同胞
◎
Queue a mutation record of "childList" for target with null, null, null, addedNodes, removedNodes, previousSibling, and nextSibling.
</li>
</ol>
</div>

			</section>
			<section id="interface-mutationrecord">
<h4 title="Interface MutationRecord">4.3.3. ^@MutationRecord ~interface</h4>

！！
[`Exposed$=Window]
interface @MutationRecord {
  readonly attribute $DOMString $type;
  [`SameObject$] readonly attribute $Node $target;
  [`SameObject$] readonly attribute $NodeList $addedNodes;
  [`SameObject$] readonly attribute $NodeList $removedNodes;
  readonly attribute $Node? $previousSibling;
  readonly attribute $Node? $nextSibling;
  readonly attribute $DOMString? $attributeName;
  readonly attribute $DOMString? $attributeNamespace;
  readonly attribute $DOMString? $oldValue;
};
！

<dl class="domintro">
	<dt>%record . $type</dt>
	<dd>
変異の種類に応じて，次を返す
⇒＃
`属性o$に対する変異であった場合は `attributes^l,
$CharacterData `~node$に対する変異であった場合は `characterData^l,
`~node$が成す`~tree$に対する変異であった場合は `childList^l
◎
Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to a CharacterData node. And "childList" if it was a mutation to the tree of nodes.
</dd>

	<dt>%record . $target</dt>
	<dd>
変異に影響された`~node$を返す — $type に応じて
⇒＃
`attributes^l に対しては，`属性o$が変化した`要素$ ／
`characterData^l に対しては，$CharacterData `~node$ ／
`childList^l に対しては，`子~群$が変化した`~node$
◎
Returns the node the mutation affected, depending on the type. For "attributes", it is the element whose attribute changed. For "characterData", it is the CharacterData node. For "childList", it is the node whose children changed.
</dd>

	<dt>%record . $addedNodes</dt>
	<dt>%record . $removedNodes</dt>
	<dd>
順に，［
追加された, 除去された
］`~node$たちが成す~listを返す。
◎
Return the nodes added and removed respectively.
</dd>

	<dt>%record . $previousSibling</dt>
	<dt>%record . $nextSibling</dt>
	<dd>
［
追加されたまたは除去された
］`~node$が［
在るならば，順に［
その`直前の同胞？$, その`直後の同胞？$
］／
無いならば ~NULL
］を返す。。
◎
Return the previous and next sibling respectively of the added or removed nodes; otherwise null.
</dd>

	<dt>%record . $attributeName</dt>
	<dd>
変化した`属性o$が［
在るならば その`局所~名$a／
無いならば ~NULL
］を返す。
◎
Returns the local name of the changed attribute; otherwise null.
</dd>

	<dt>%record . $attributeNamespace</dt>
	<dd>
変化した`属性o$が［
在るならば その`~ns$el／
無いならば ~NULL
］を返す。
◎
Returns the namespace of the changed attribute; otherwise null.
</dd>

	<dt>%record . $oldValue</dt>
	<dd>
$type に応じて，次に与える値を返す
⇒＃
`attributes^l ならば，変化した`属性o$の変化~前の`値$a／
`characterData^l ならば，変化した`~node$の変化~前の`~data$／
`childList^l ならば， ~NULL
◎
The return value depends on type. For "attributes", it is the value of the changed attribute before the change. For "characterData", it is the data of the changed node before the change. For "childList", it is null.
</dd>
</dl>

<div class="algo">
次に挙げる属性の取得子~手続きは、
各自の初期化-時の値を返す
⇒＃
@type,
@target,
@addedNodes,
@removedNodes,
@previousSibling,
@nextSibling,
@attributeName,
@attributeNamespace,
@oldValue
◎
The type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, and oldValue attributes must return the values they were initialized to.
</div>

			</section>
		</section>
		<section id="interface-node">
<h3 title="Interface Node">4.4. ^@Node ~interface</h3>

！！
[`Exposed$=Window]
interface @Node : $EventTarget {
  const `unsigned short$ @ELEMENT_NODE = 1;
  const `unsigned short$ @ATTRIBUTE_NODE = 2;
  const `unsigned short$ @TEXT_NODE = 3;
  const `unsigned short$ @CDATA_SECTION_NODE = 4;
  const `unsigned short$ @ENTITY_REFERENCE_NODE = 5; // <!--cp-legacy-->
  const `unsigned short$ @ENTITY_NODE = 6; // <!--cp-legacy-->
  const `unsigned short$ @PROCESSING_INSTRUCTION_NODE = 7;
  const `unsigned short$ @COMMENT_NODE = 8;
  const `unsigned short$ @DOCUMENT_NODE = 9;
  const `unsigned short$ @DOCUMENT_TYPE_NODE = 10;
  const `unsigned short$ @DOCUMENT_FRAGMENT_NODE = 11;
  const `unsigned short$ @NOTATION_NODE = 12; // <!--cp-legacy-->
  readonly attribute `unsigned short$ $nodeType;
  readonly attribute $DOMString $nodeName;

  readonly attribute $USVString $baseURI;

  readonly attribute $boolean $isConnected;
  readonly attribute $Document? $ownerDocument;
  $Node $getRootNode(optional $GetRootNodeOptions %options = {});
  readonly attribute $Node? $parentNode;
  readonly attribute $Element? $parentElement;
  $boolean $hasChildNodes();
  [`SameObject$] readonly attribute $NodeList $childNodes;
  readonly attribute $Node? $firstChild;
  readonly attribute $Node? $lastChild;
  readonly attribute $Node? $previousSibling;
  readonly attribute $Node? $nextSibling;

  [`CEReactions$] attribute $DOMString? $nodeValue;
  [`CEReactions$] attribute $DOMString? $textContent;
  [`CEReactions$] $undefined $normalize();

  [`CEReactions$, `NewObject$] $Node $cloneNode(optional $boolean %subtree = false);
  $boolean $isEqualNode($Node? %otherNode);
  $boolean $isSameNode($Node? %otherNode); // <span class="comment" title="legacy alias of ===">`===^c 演算子の旧来の別名</span>

  const `unsigned short$ $DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const `unsigned short$ $DOCUMENT_POSITION_PRECEDING = 0x02;
  const `unsigned short$ $DOCUMENT_POSITION_FOLLOWING = 0x04;
  const `unsigned short$ $DOCUMENT_POSITION_CONTAINS = 0x08;
  const `unsigned short$ $DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const `unsigned short$ $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  `unsigned short$ $compareDocumentPosition($Node %other);
  $boolean $contains($Node? %other);

  $DOMString? $lookupPrefix($DOMString? %namespace);
  $DOMString? $lookupNamespaceURI($DOMString? %prefix);
  $boolean $isDefaultNamespace($DOMString? %namespace);

  [`CEReactions$] $Node $insertBefore($Node %node, $Node? %child);
  [`CEReactions$] $Node $appendChild($Node %node);
  [`CEReactions$] $Node $replaceChild($Node %node, $Node %child);
  [`CEReactions$] $Node $removeChild($Node %child);
};

dictionary @@GetRootNodeOptions {
  $boolean @composed = false;
};
！

<p class="note">注記：
$@Node は、
すべての`~node$から利用される抽象-~interfaceであり，
その直な~instanceは取得し得ない。
◎
Node is an abstract interface that is used by all nodes. You cannot get a direct instance of it.
</p>

<div class="p">
<p>
各`~node$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~node文書@
⇒
ある`文書$
— 作成-時に設定される。
【`文書~tree内$にない~nodeであっても，設定される。】
</li>
</ul>
◎
Each node has an associated node document, set upon creation, that is a document.
</div>

<p class="note">注記：
`~node$の`~node文書$は、
`~nodeを受入する$~algoにより変更され得る。
◎
A node’s node document can be changed by the adopt algorithm.
</p>

<div class="algo">
<p>
`~node$ %~node の`親~targetを取得する$ときは
⇒
~RET ［
%~node の`割当-先~slot$ ~NEQ ~NULL ならば それ ／
~ELSE_ %~node の`親$
］
◎
A node’s get the parent algorithm, given an event, returns the node’s assigned slot, if node is assigned; otherwise node’s parent.
</p>

<p class="trans-note">【
［
`~shadow根$／`文書$
］は、
これをさらに上書きする。
】</p>
</div>

<p class="note">注記：
各`~node$は、
`登録-済み観測器~list$も有する。
◎
Each node also has a registered observer list.
</p>

<hr>

<dl class="domintro">
	<dt>%node . $nodeType</dt>
	<dd>
%node の型に応じて，適切な数を返す（括弧内は数-値）
⇒＃
$Element ならば $ELEMENT_NODE (1) ／
$Attr ならば $ATTRIBUTE_NODE (2) ／
`狭義-~Text~node$ならば $TEXT_NODE (3) ／
$CDATASection ならば $CDATA_SECTION_NODE (4) ／
$ProcessingInstruction ならば $PROCESSING_INSTRUCTION_NODE (7) ／
$Comment ならば $COMMENT_NODE (8) ／
$Document ならば $DOCUMENT_NODE (9) ／
$DocumentType ならば $DOCUMENT_TYPE_NODE (10) ／
$DocumentFragment ならば $DOCUMENT_FRAGMENT_NODE (11)
◎
Returns a number appropriate for the type of node, as follows:
◎
Element
• Node . ELEMENT_NODE (1).
Attr
• Node . ATTRIBUTE_NODE (2).
An exclusive Text node
• Node . TEXT_NODE (3).
CDATASection
• Node . CDATA_SECTION_NODE (4).
ProcessingInstruction
• Node . PROCESSING_INSTRUCTION_NODE (7).
Comment
• Node . COMMENT_NODE (8).
Document
• Node . DOCUMENT_NODE (9).
DocumentType
• Node . DOCUMENT_TYPE_NODE (10).
DocumentFragment
• Node . DOCUMENT_FRAGMENT_NODE (11).
</dd>

	<dt>%node . $nodeName</dt>
	<dd>
%node の型に応じて，適切な文字列を返す
⇒＃
$Element ならば %node の`~HTML大文字~化~有修飾~名$ ／
$Attr ならば %node の`有修飾~名$a ／
`狭義-~Text~node$ならば `#text^l ／
$CDATASection ならば `#cdata-section^l ／
$ProcessingInstruction ならば %node の`~target$pI ／
$Comment ならば `#comment^l ／
$Document ならば `#document^l ／
$DocumentType ならば %node の`名前$dT ／
$DocumentFragment ならば `#document-fragment^l
◎
Returns a string appropriate for the type of node, as follows:
◎
Element
• Its HTML-uppercased qualified name.
Attr
• Its qualified name.
An exclusive Text node
• "#text".
CDATASection
• "#cdata-section".
ProcessingInstruction
• Its target.
Comment
• "#comment".
Document
• "#document".
DocumentType
• Its name.
DocumentFragment
• "#document-fragment".
</dd>
</dl>

<div class="algo">
@nodeType
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて（括弧内は数-値）
⇒＃
$Element ならば $ELEMENT_NODE (1) ／
$Attr ならば $ATTRIBUTE_NODE (2) ／
`狭義-~Text~node$ならば $TEXT_NODE (3) ／
$CDATASection ならば $CDATA_SECTION_NODE (4) ／
$ProcessingInstruction ならば $PROCESSING_INSTRUCTION_NODE (7) ／
$Comment ならば $COMMENT_NODE (8) ／
$Document ならば $DOCUMENT_NODE (9) ／
$DocumentType ならば $DOCUMENT_TYPE_NODE (10) ／
$DocumentFragment ならば $DOCUMENT_FRAGMENT_NODE (11)
◎
The nodeType getter steps are to return the first matching statement, switching on the interface this implements:
◎
Element
• ELEMENT_NODE (1) 
Attr
• ATTRIBUTE_NODE (2);
An exclusive Text node
• TEXT_NODE (3);
CDATASection
• CDATA_SECTION_NODE (4);
ProcessingInstruction
• PROCESSING_INSTRUCTION_NODE (7);
Comment
• COMMENT_NODE (8);
Document
• DOCUMENT_NODE (9);
DocumentType
• DOCUMENT_TYPE_NODE (10);
DocumentFragment
• DOCUMENT_FRAGMENT_NODE (11).
</div>

<div class="algo">
@nodeName
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて：
⇒＃
$Element ならばコレの`~HTML大文字~化~有修飾~名$ ／
$Attr ならばコレの`有修飾~名$a ／
`狭義-~Text~node$ならば `#text^l ／
$CDATASection ならば `#cdata-section^l ／
$ProcessingInstruction ならばコレの`~target$pI ／
$Comment ならば `#comment^l ／
$Document ならば `#document^l ／
$DocumentType ならばコレの`名前$dT ／
$DocumentFragment ならば `#document-fragment^l
◎
The nodeName getter steps are to return the first matching statement, switching on the interface this implements:
◎
Element
• Its HTML-uppercased qualified name.
Attr
• Its qualified name.
An exclusive Text node
• "#text".
CDATASection
• "#cdata-section".
ProcessingInstruction
• Its target.
Comment
• "#comment".
Document
• "#document".
DocumentType
• Its name.
DocumentFragment
• "#document-fragment".
</div>

<dl class="domintro">
	<dt>%node . $baseURI</dt>
	<dd>
%node の`~node文書$用の`文書~基底~URL$を返す。
◎
Returns node’s node document’s document base URL.
</dd>
</dl>

<div class="algo">
@baseURI
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレの`~node文書$の`文書~基底~URL$ )
◎
The baseURI getter steps are to return this’s node document’s document base URL, serialized.
</div>

<dl class="domintro">
	<dt>%node . $isConnected</dt>
	<dd>
%node は`接続されて$［
いるならば ~T ／
いないならば ~F
］を返す。
◎
Returns true if node is connected; otherwise false.
</dd>

	<dt>%node . $ownerDocument</dt>
	<dd>
`~node文書$を返す。
`文書$に対しては ~NULL を返す。
◎
Returns the node document. Returns null for documents.
</dd>

	<dt>%node . $getRootNode()</dt>
	<dd>
%node の`根$を返す。
◎
Returns node’s root.
</dd>

	<dt>%node . $getRootNode({ composed:true })</dt>
	<dd>
%node の`~shadowも含めた根$を返す。
◎
Returns node’s shadow-including root.
</dd>

	<dt>%node . $parentNode</dt>
	<dd>
`親$を返す。
◎
Returns the parent.
</dd>

	<dt>%node . $parentElement</dt>
	<dd>
`親~要素$を返す。
◎
Returns the parent element.
</dd>

	<dt>%node . $hasChildNodes()</dt>
	<dd>
%node の`子~群$は`空$でないかどうかを返す。
◎
Returns whether node has children.
</dd>

	<dt>%node . $childNodes</dt>
	<dd>
`子~群$を返す。
◎
Returns the children.
</dd>

	<dt>%node . $firstChild</dt>
	<dd>
`最初の子？$を返す。
◎
Returns the first child.
</dd>

	<dt>%node . $lastChild</dt>
	<dd>
`最後の子？$を返す。
◎
Returns the last child.
</dd>

	<dt>%node . $previousSibling</dt>
	<dd>
`直前の同胞？$を返す。
◎
Returns the previous sibling.
</dd>

	<dt>%node . $nextSibling</dt>
	<dd>
`直後の同胞？$を返す。
◎
Returns the next sibling.
</dd>
</dl>

<div class="algo">
@isConnected
取得子~手続きは
⇒
~RET ~IS［
コレは`接続されて$いる
］
◎
The isConnected getter steps are to return true, if this is connected; otherwise false.
</div>

<div class="algo">
<p>
@ownerDocument
取得子~手続きは
⇒
~RET ［
コレは`文書$である ならば ~NULL ／
~ELSE_ コレの`~node文書$
］
◎
The ownerDocument getter steps are to return null, if this is a document; otherwise this’s node document.
</p>

<p class="note">注記：
`文書$の`~node文書$は，`文書$自身である。
すべての`~node$は、
どの時点であれ，`~node文書$を有する。
◎
The node document of a document is that document itself. All nodes have a node document at all times.
</p>
</div>

<div class="algo">
@getRootNode(options)
~method手続きは
⇒
~RET %options[ "$GetRootNodeOptions.composed" ] に応じて
⇒＃
~T ならば コレの`~shadowも含めた根$ ／
~ELSE_ コレの`根$
◎
The getRootNode(options) method steps are to return this’s shadow-including root if options["composed"] is true; otherwise this’s root.
</div>

<div class="algo">
@parentNode
取得子~手続きは
⇒
~RET コレの`親$
◎
The parentNode getter steps are to return this’s parent.
</div>

<div class="algo">
@parentElement
取得子~手続きは
⇒
~RET コレの`親~要素$
◎
The parentElement getter steps are to return this’s parent element.
</div>

<div class="algo">
@hasChildNodes()
~method手続きは
⇒
~RET ~IS［
コレの`子~群$は`空$でない
］
◎
The hasChildNodes() method steps are to return true if this has children; otherwise false.
</div>

<div class="algo">
@childNodes
取得子~手続きは
⇒
~RET 次のように設定された $NodeList `~collection$
⇒＃
`根$cL ~SET コレ,
`~filter$cLは コレの`子$のみに合致する
◎
The childNodes getter steps are to return a NodeList rooted at this matching only children.
</div>

<div class="algo">
@firstChild
取得子~手続きは
⇒
~RET コレの`最初の子？$
◎
The firstChild getter steps are to return this’s first child.
</div>

<div class="algo">
@lastChild
取得子~手続きは
⇒
~RET コレの`最後の子？$
◎
The lastChild getter steps are to return this’s last child.
</div>

<div class="algo">
@previousSibling
取得子~手続きは
⇒
~RET コレの`直前の同胞？$
◎
The previousSibling getter steps are to return this’s previous sibling.
</div>

<div class="algo">
@nextSibling
取得子~手続きは
⇒
~RET コレの`直後の同胞？$
◎
The nextSibling getter steps are to return this’s next sibling.
</div>

<div class="algo">
@nodeValue
取得子~手続きは
⇒
~RET コレが`実装-$する~interfaceに応じて
⇒＃
$Attr ならばコレの`値$a／
$CharacterData ならばコレの`~data$／
~ELSE_ ~NULL
◎
The nodeValue getter steps are to return the following, switching on the interface this implements:
◎
Attr
• this’s value.
CharacterData
• this’s data.
Otherwise
• Null.
</div>

<div class="algo">
<p>
$nodeValue 設定子~手続きは：
◎
The nodeValue setter steps are to,＼
</p>
<ol>
	<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the given value is null, act as if it was the empty string instead, and then＼
</li>
	<li>
<p>
コレが`実装-$する~interfaceに応じて：
◎
do as described below, switching on the interface this implements:
</p>
		<ul class="switch">
			<li>
$Attr
⇒
`既存の属性oの値を設定する$( コレ, %値 )
◎
Attr
• Set an existing attribute value with this and the given value.
</li>
			<li>
$CharacterData
⇒
コレの`~dataを置換する$( 0, コレの`長さ$node, %値 )
◎
CharacterData
• Replace data of this with 0, this’s length, and the given value.
</li>
			<li>
その他
⇒
何もしない
◎
Otherwise
• Do nothing.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
`~nodeの~text内容を取得する@
~algoは、
所与の
( `~node$ %~node )
に対し
⇒
~RET %~node が`実装-$する~interfaceに応じて
⇒＃
$DocumentFragment ならば %~node の`子孫~text内容$／
$Element ならば %~node の`子孫~text内容$／
$Attr ならば %~node の`値$a／
$CharacterData ならば %~node の`~data$／
~ELSE_ ~NULL
◎
To get text content with a node node, return the following, switching on the interface node implements:
◎
DocumentFragment
Element
• The descendant text content of node. 
Attr
• node’s value.
CharacterData
• node’s data.
Otherwise
• Null.
</div>

<div class="algo">
@textContent
取得子~手続きは
⇒
~RET `~nodeの~text内容を取得する$( コレ )
◎
The textContent getter steps are to return the result of running get text content with this.
</div>

<div class="algo">
<p>
`~node$ %親 の
`全~内容を文字列に置換する@
~algoは、
所与の
( 文字列 %文字列 )
に対し：
◎
To string replace all with a string string within a node parent, run these steps:
</p>
<ol>
	<li>
%~node ~LET ~NULL
◎
Let node be null.
</li>
	<li>
~IF［
%文字列 ~NEQ 空~文字列
］
⇒
%~node ~SET `新たな~Text~node$( %文字列, %親 の`~node文書$ )
◎
If string is not the empty string, then set node to a new Text node whose data is string and node document is parent’s node document.
</li>
	<li>
%親 の`全~内容を~nodeで置換する$( %~node )
◎
Replace all with node within parent.
</li>
</ol>
</div>

<div class="algo">
<p>
`~nodeの~text内容を設定する@
~algoは、
所与の
( `~node$ %~node, 文字列 %値 )
に対し，
%~node が`実装-$する~interfaceに応じて：
◎
To set text content with a node node and a string value, do as defined below, switching on the interface node implements:
</p>
<ul class="switch">
	<li>
$DocumentFragment ／ $Element
⇒
コレの`全~内容を文字列に置換する$( %値 )
◎
DocumentFragment
Element
• String replace all with value within node.
</li>
	<li>
$Attr
⇒
`既存の属性oの値を設定する$( コレ, %値 )
◎
Attr
• Set an existing attribute value with node and value.
</li>
	<li>
$CharacterData
⇒
コレの`~dataを置換する$( 0, コレの`長さ$node, %値 )
◎
CharacterData
• Replace data of node with 0, node’s length, and value.
</li>
	<li>
その他【すなわち， $Document ／ $DocumentType 】
⇒
何もしない
◎
Otherwise
• Do nothing.
</li>
</ul>
</div>

<div class="algo">
<p>
$textContent 設定子~手続きは：
◎
The textContent setter steps are to,＼
</p>
<ol>
	<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば %値 ／
~ELSE_ 空~文字列
］
◎
if the given value is null, act as if it was the empty string instead, and then＼
</li>
	<li>
`~nodeの~text内容を設定する$( コレ, %値 )
◎
run set text content with this and the given value.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%node . $normalize()</dt>
	<dd>
%node に含まれている`狭義-~Text~node$のうち`空$nodeであるものは除去し、
`連続的な狭義-~Text~node列$に対しては，その最初の`~node$に~~後続の`~data$を連結してひとまとめにする。
◎
Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes.
</dd>
	<dd class="trans-note">【
この記述は、
“除去-” と “連結-” の順序に関し，微妙に正確aでない
— 実際の~algoでは、
空な ^Text ~nodeのうち，［
最初の~node %N が空でない`連続的な狭義-~Text~node列$
］に含まれるものは、
後続の空な ^Text ~nodeより先に %N に連結される（その結果として，除去されるが）。
<!-- 
結果の~node~treeは同じでも，変異の通知-順序は異なり得る。
 -->
】</dd>
</dl>

<div class="algo">
<p>
@normalize()
~method手続きは：
◎
The normalize() method steps are to run these steps＼
</p>
<ol>
	<li>
<p>
コレの`子孫$たちを成す
~EACH( `狭義-~Text~node$ %~node )
に対し：
◎
for each descendant exclusive Text node node of this:
</p>

<p class="trans-note">【
~tree順序で。
加えて、
この~loopの中で~treeから除去される ^Text ~nodeに対する反復は，
飛ばす必要もある。
】</p>
		<ol>
			<li>
%長さ ~LET %~node の`長さ$node
◎
Let length be node’s length.
</li>
			<li>
%長さ ~EQ 0
⇒＃
`~nodeを除去する$( %~node )；
~CONTINUE
◎
If length is zero, then remove node and continue with the next exclusive Text node, if any.
</li>
			<li>
%除去-対象 ~LET %~node を含む`連続的な狭義-~Text~node列$
◎
↓</li>
			<li>
%除去-対象 から %~node （常に先頭に在る）を`除去する$
◎
↓</li>
			<li>
%~data ~LET `~text~dataを連結する$( %除去-対象 )
◎
Let data be the concatenation of the data of node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
			<li>
%~node の`~dataを置換する$( %長さ, 0, %~data )
◎
Replace data of node with length, 0, and data.
</li>
			<li>
<p>
%除去-対象 を成す
~EACH( %text )
に対し：
◎
Let currentNode be node’s next sibling.
◎
While currentNode is an exclusive Text node:
</p>
				<ol>
					<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
						<ol>
							<li>
~IF［
%範囲o の`始端~node$ ~EQ %text
］
⇒＃
%範囲o の`始端~offset$ ~INCBY %長さ；
%範囲o の`始端~node$ ~SET %~node
</li>
							<li>
~IF［
%範囲o の`終端~node$ ~EQ %text
］
⇒＃
%範囲o の`終端~offset$ ~INCBY %長さ；
%範囲o の`終端~node$ ~SET %~node
</li>
							<li>
~IF［
%範囲o の`始端~node$ ~EQ %text の`親$
］~AND［
%範囲o の`始端~offset$ ~EQ %text の`~index$
］
⇒＃
%範囲o の`始端~node$ ~SET %~node；
%範囲o の`始端~offset$ ~SET %長さ
</li>
							<li>
~IF［
%範囲o の`終端~node$ ~EQ %text の`親$
］~AND［
%範囲o の`終端~offset$ ~EQ %text の`~index$
］
⇒＃
%範囲o の`終端~node$ ~SET %~node；
%範囲o の`終端~offset$ ~SET %長さ
</li>
						</ol>
◎
For each live range whose start node is currentNode:＼
add length to its start offset and set its start node to node.
◎
For each live range whose end node is currentNode:＼
add length to its end offset and set its end node to node.
◎
For each live range whose start node is currentNode’s parent and start offset is currentNode’s index:＼
set its start node to node and its start offset to length.
◎
For each live range whose end node is currentNode’s parent and end offset is currentNode’s index:＼
set its end node to node and its end offset to length.
</li>
					<li>
%長さ ~INCBY %text の`長さ$node
◎
Add currentNode’s length to length.
◎
Set currentNode to its next sibling.
</li>
				</ol>
			</li>
			<li>
%除去-対象 を成す
~EACH( %text )
に対し，順に
⇒
`~nodeを除去する$( %text )
◎
Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
		</ol>
	</li>
</ol>
</div>

<dl class="domintro">
	<dt>%node . $cloneNode([subtree = false])</dt>
	<dd>
%node の複製を返す。
%subtree が~T の場合、
複製は %node の`子孫$も含む。
◎
Returns a copy of node. If subtree is true, the copy also includes the node’s descendants.
</dd>

	<dt>%node . $isEqualNode(otherNode)</dt>
	<dd>
%node と %otherNode が同じ~propを有するかどうかを返す。
◎
Returns whether node and otherNode have the same properties.
</dd>
</dl>

<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`~clone時の手続き@
を定義してもヨイ。
この~algoは、
`~nodeを~cloneする$ ~algo内から，
( %~node, %複製, %下位treeもか )
を渡して呼出される。
◎
Specifications may define cloning steps for all or some nodes. The algorithm is passed node, copy, and subtree as indicated in the clone a node algorithm.
</p>

<p class="note">注記：
~HTMLは、
いくつかの要素
— `script$e, `input$e, `template$e など —
用に`~clone時の手続き$を定義する。
~SVGの `script^e 要素~用にも同じことが行われるべきだが、
行われない。
◎
HTML defines cloning steps for several elements, such as input, script, and template. SVG ought to do the same for its script elements, but does not.
</p>

<div class="algo">
<p>
`~nodeを~cloneする@
~algoは、
所与の
⇒＃
`~node$ %~node,
真偽値 %下位treeもか ~DF ~F,
`文書$ %文書 ~DF %~node の`~node文書$,
`~node$ %親 ~DF ~NULL,
$CustomElementRegistry ~obj %~fallback~registry ~DF ~NULL
◎終
に対し：
◎
To clone a node given a node node and an optional document document (default node’s node document), boolean subtree (default false), node-or-null parent (default null), and null or a CustomElementRegistry object fallbackRegistry (default null):
</p>
<ol>
	<li>
~Assert：
［
%~node は`文書$でない
］~OR［
%~node ~EQ %文書
］
◎
Assert: node is not a document or node is document.
</li>
	<li>
%複製 ~LET `単独の~nodeを~cloneする$( %~node, %文書, %~fallback~registry )
◎
Let copy be the result of cloning a single node given node, document, and fallbackRegistry.
</li>
	<li>
`適用-可能な仕様$にて %~node 用に`定義された各$( `~clone時の手続き$ %手続き )
に対し
⇒
%手続き( %~node, %複製, %下位treeもか )
◎
Run any cloning steps defined for node in other applicable specifications and pass node, copy, and subtree as parameters.
</li>
	<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
%親 に`~nodeを付加する$( %複製 )
◎
If parent is non-null, then append copy to parent.
</li>
	<li>
~IF［
%下位treeもか ~EQ ~T
］
⇒
%~node の`子~群$を成す
~EACH( %子 )
に対し【！`~tree順序$で】
⇒
`~nodeを~cloneする$( %子, %下位treeもか, %文書, %複製, %~fallback~registry )
◎
If subtree is true, then for each child of node’s children, in tree order:＼
clone a node given child with document set to document, subtree set to subtree, parent set to copy, and fallbackRegistry set to fallbackRegistry.
</li>
	<li>
%~shadow根 ~LET %~node の`~shadow根$el
◎
↓</li>
	<li>
<p>
~IF［
%~node は`要素$である
］~AND［
%~shadow根 ~NEQ ~NULL【！%~node は`~shadow~host$である】
］~AND［
%~shadow根 の`~clone可能か$sR ~EQ ~T
］：
◎
If node is an element, node is a shadow host, and node’s shadow root’s clonable is true:
</p>
		<ol>
			<li>
~Assert：
%複製 は`~shadow~host$でない。
◎
Assert: copy is not a shadow host.
</li>
			<li>
%~shadow根~registry ~LET %~shadow根 の`~custom要素~registry$sR
◎
Let shadowRootRegistry be node’s shadow root’s custom element registry.
</li>
			<li>
~IF［
%~shadow根~registry は`大域的$ceRである
］
⇒
%~shadow根~registry ~SET `大域的な~custom要素~registryを取得する$( %文書 )
◎
If shadowRootRegistry is a global custom element registry, then set shadowRootRegistry to document’s effective global custom element registry.
</li>
			<li>
`~shadow根を付する$( ↓ )
⇒＃
%複製,
%~shadow根 の`~mode$sR,
~T,
%~shadow根 の`直列化-可能か$sR,
%~shadow根 の`~focusを委任するか$sR,
%~shadow根 の`~slot割当n~mode$sR,
%~shadow根~registry
◎
Attach a shadow root with copy, node’s shadow root’s mode, true, node’s shadow root’s serializable, node’s shadow root’s delegates focus, node’s shadow root’s slot assignment, and shadowRootRegistry.
</li>
			<li>
%複製 の`~shadow根$elの
⇒＃
`宣言的か$sR ~SET %~shadow根 の`宣言的か$sR,
`~custom要素~registryを~NULLに保つか$sR ~SET %~shadow根 の`~custom要素~registryを~NULLに保つか$sR
◎
Set copy’s shadow root’s declarative to node’s shadow root’s declarative.
◎
Set copy’s shadow root’s keep custom element registry null to node’s shadow root’s keep custom element registry null.
</li>
			<li>
<p>
%~shadow根 の`子~群$を成す
~EACH( %子 )
に対し【！`~tree順序$で】
⇒
`~nodeを~cloneする$( %子, %下位treeもか, %文書, %複製 の`~shadow根$el )
◎
For each child of node’s shadow root’s children, in tree order:＼
clone a node given child with document set to document, subtree set to subtree, and parent set to copy’s shadow root.
</p>

<p class="note">注記：
ここでは、
`~fallback~registry^i 引数を意図的に渡さない。
◎
This intentionally does not pass the fallbackRegistry argument.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %複製
◎
Return copy.
</li>
</ol>
</div>

<div class="algo">
<p>
`単独の~nodeを~cloneする@
~algoは、
所与の
( `~node$ %~node, `文書$ %文書, ［ ~NULL／ $CustomElementRegistry ~obj ］ %~fallback~registry )
に対し：
◎
To clone a single node given a node node, document document, and null or a CustomElementRegistry object fallbackRegistry:
</p>
<ol>
	<li>
%複製 ~LET ~NULL
◎
Let copy be null.
</li>
	<li>
<p>
~IF［
%~node は`要素$である
］：
◎
If node is an element:
</p>
		<ol>
			<li>
%~registry ~LET %~node の`~custom要素~registry$el
◎
Let registry be node’s custom element registry.
</li>
			<li>
~IF［
%~registry ~EQ ~NULL
］
⇒
%~registry ~SET %~fallback~registry
◎
If registry is null, then set registry to fallbackRegistry.
</li>
			<li>
~IF［
%~registry は`大域的$ceRである
］
⇒
%~registry ~SET `大域的な~custom要素~registryを取得する$( %文書 )
◎
If registry is a global custom element registry, then set registry to document’s effective global custom element registry.
</li>
			<li>
%複製 ~SET `要素を作成する$( ↓ )
⇒＃
%文書,
%~node の`局所~名$el,
%~node の`~ns$el,
%~node の`~ns接頭辞$el,
%~node の`~is0値$el,
~F,
%~registry
◎
Set copy to the result of creating an element, given document, node’s local name, node’s namespace, node’s namespace prefix, node’s is value, false, and registry.
</li>
			<li>
%~node の`属性o~list$elを成す
~EACH( %属性o )
に対し
⇒
`属性oを付加する$( 次の結果, %複製 )
⇒
`単独の~nodeを~cloneする$( %属性o, %文書, ~NULL )
◎
For each attribute of node’s attribute list:
• Let copyAttribute be the result of cloning a single node given attribute, document, and null.
• Append copyAttribute to copy.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
		<ol>
			<li>
%複製 ~SET `新たな~obj$( %~node の`首~interface$ )
◎
set copy to a node that implements the same interfaces as node, and＼
</li>
			<li>
<p>
%~node が`実装-$する~interfaceに応じて：
◎
fulfills these additional requirements, switching on the interface node implements:
</p>
				<ul class="switch">
					<li>
<p>
$Document：
◎
Document
</p>
						<ol>
							<li>
%複製 の
⇒＃
`符号化法$doc ~SET %~node の`符号化法$doc,
`内容~型$doc ~SET %~node の`内容~型$doc,
`~URL$doc ~SET %~node の`~URL$doc,
`生成元$doc ~SET %~node の`生成元$doc,
`種別$doc ~SET %~node の`種別$doc,
`~mode$doc ~SET %~node の`~mode$doc,
`宣言的な~shadow根を許容するか$doc ~SET %~node の`宣言的な~shadow根を許容するか$doc,
◎
Set copy’s encoding, content type, URL, origin, type, mode, and allow declarative shadow roots, to those of node.
</li>
							<li>
~IF［
%~node の`~custom要素~registry$docの`視野~付きか$cR ~EQ ~T
］
⇒
%複製 の`~custom要素~registry$doc ~SET %~node の`~custom要素~registry$doc
◎
If node’s custom element registry’s is scoped is true, then set copy’s custom element registry to node’s custom element registry.
</li>
						</ol>
					</li>
					<li>
$DocumentType
⇒
%複製 の
⇒＃
`名前$dT ~SET %~node の`名前$dT,
`公な~ID$dT ~SET %~node の`公な~ID$dT,
`~system~ID$dT ~SET %~node の`~system~ID$dT
◎
DocumentType
• Set copy’s name, public ID, and system ID to those of node.
</li>
					<li>
$Attr
⇒
%複製 の
⇒＃
`~ns$a ~SET %~node の`~ns$a,
`~ns接頭辞$a ~SET %~node の`~ns接頭辞$a,
`局所~名$a ~SET %~node の`局所~名$a,
`値$a ~SET %~node の`値$a
◎
Attr
• Set copy’s namespace, namespace prefix, local name, and value to those of node.
</li>
					<li>
$Text ／
$Comment
⇒
%複製 の`~data$ ~SET %~node の`~data$
◎
Text
Comment
• Set copy’s data to that of node.
</li>
					<li>
$ProcessingInstruction
⇒
%複製 の
⇒＃
`~target$pI ~SET %~node の`~target$pI,
`~data$ ~SET %~node の`~data$
◎
ProcessingInstruction
• Set copy’s target and data to those of node.
</li>
					<li>
その他【すなわち， $DocumentFragment 】
⇒
何もしない
◎
Otherwise
• Do nothing.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~Assert：
%複製 は`~node$である。
◎
Assert: copy is a node.
</li>
	<li>
%複製 の`~node文書$ ~SET %複製 に応じて
⇒＃
`文書$であるならば %複製 ／
~ELSE_ %文書
◎
If node is a document, then set document to copy.
◎
Set copy’s node document to document.
</li>
	<li>
~RET %複製
◎
Return copy.
</li>
</ol>
</div>

<div class="algo">
<p>
@cloneNode(subtree)
~method手続きは：
◎
The cloneNode(subtree) method steps are:
</p>
<ol>
	<li>
~IF［
コレは`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If this is a shadow root, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~RET `~nodeを~cloneする$( コレ, %subtree )
◎
Return the result of cloning a node given this with subtree set to subtree.
</li>
</ol>
</div>

<div class="algo">
<p>
2 つの`~node$ %A, %B が
`同等@node
であるとは、
~AND↓ を満たすことをいう：
◎
A node A equals a node B if all of the following conditions are true:
</p>
<ul>
	<li>
%A, %B は同じ~interfaceを`実装-$する
◎
A and B implement the same interfaces.
</li>
	<li>
<p>
%A が`実装-$する~interfaceに応じて，次に挙げるものもすべて同等である：
◎
The following are equal, switching on the interface A implements:
</p>
		<ul class="switch">
			<li>
$DocumentType
⇒＃
`名前$dT,
`公な~ID$dT,
`~system~ID$dT
◎
DocumentType
• Its name, public ID, and system ID.
</li>
			<li>
$Element
⇒＃
`~ns$el,
`~ns接頭辞$el,
`局所~名$el,
`属性o~list$elの`~size$
◎
Element
• Its namespace, namespace prefix, local name, and its attribute list’s size.
</li>
			<li>
$Attr
⇒＃
`~ns$a,
`局所~名$a,
`値$a
◎
Attr
• Its namespace, local name, and value.
</li>
			<li>
$ProcessingInstruction
⇒＃
`~target$pI,
`~data$
◎
ProcessingInstruction
• Its target and data.
</li>
			<li>
$CharacterData【！$Text ／ $Comment】
⇒＃
`~data$
◎
Text
Comment
• Its data.
</li>
			<li>
その他【すなわち， $Document, $DocumentFragment 】
⇒
なし
【すなわち，比較するものは無いので無条件（原文には “—” としか記されていないが）。】
◎
Otherwise
• —
</li>
		</ul>
	</li>
	<li>
%A は`要素$であるならば、
次が満たされる
⇒
%A の`属性o~list$elを成す どの`属性o$も，［
%B の`属性o~list$elを成す ある`属性o$
］と`同等$nodeである
◎
If A is an element, each attribute in its attribute list equals an attribute in B’s attribute list.
</li>
	<li>
%A の`子~群$の`~size$ ~EQ %B の`子~群$の`~size$
◎
A and B have the same number of children.
</li>
	<li>
各 %~index ~IN { 0 〜 %A の`子~群$の`~size$ ~MINUS 1 }
に対し
⇒
( %A の`子~群$[ %~index ], %B の`子~群$[ %~index ] )
は`同等$nodeである
◎
Each child of A equals the child of B at the identical index.
</li>
</ul>
</div>

<div class="algo">
@isEqualNode(otherNode)
~method手続きは
⇒
~RET ~IS［
%otherNode ~NEQ ~NULL
］~AND［
( コレ, %otherNode )
は`同等$nodeである
］
◎
The isEqualNode(otherNode) method steps are to return true if otherNode is non-null and this equals otherNode; otherwise false.
</div>

<div class="algo">
@isSameNode(otherNode)
~method手続きは
⇒
~RET ~IS［
%otherNode ~EQ コレ
］
◎
The isSameNode(otherNode) method steps are to return true if otherNode is this; otherwise false.
</div>

<!-- ADD %node →<code >%node</code> -->
<dl class="domintro">
	<dt>%node . $compareDocumentPosition(other)</dt>
	<dd>

<p>
%node に相対的な %other の位置を指示する~bitmaskを返す。
それを成す各~bitは、
対応する条件が満たされる場合には， “1” に設定される：
◎
Returns a bitmask indicating the position of other relative to node. These are the bits that can be set:
</p>
		<dl>
			<dt>$Node . $DOCUMENT_POSITION_DISCONNECTED `(1)^i</dt>
			<dd>
%node と %other は同じ`~tree$に属さない。
◎
Set when node and other are not in the same tree.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_PRECEDING `(2)^i</dt>
			<dd>
%other は %node に`先行-$する。
◎
Set when other is preceding node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_FOLLOWING `(4)^i</dt>
			<dd>
%other は %node に`後続-$する。
◎
Set when other is following node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINS `(8)^i</dt>
			<dd>
%other は %node の`先祖$である。
◎
Set when other is an ancestor of node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINED_BY `(16)^i</dt>
			<dd>
%other は %node の`子孫$である。
◎
Set when other is a descendant of node.
</dd>
		</dl>
	</dd>

	<dt>%node . $contains(other)</dt>
	<dd>
%other が %node の`広義-子孫$［
であるならば ~T ／
でないならば ~F
］を返す。
◎
Returns true if other is an inclusive descendant of node; otherwise false.
</dd>
</dl>

<p class="idl-def">
次に挙げるものは
$compareDocumentPosition()
が~bitmaskとして返す定数である（括弧内は数-値）：
◎
These are the constants compareDocumentPosition() returns as mask:
</p>

<ul>
	<li>
@DOCUMENT_POSITION_DISCONNECTED (1)
</li>
	<li>
@DOCUMENT_POSITION_PRECEDING (2)
</li>
	<li>
@DOCUMENT_POSITION_FOLLOWING (4)
</li>
	<li>
@DOCUMENT_POSITION_CONTAINS (8)
</li>
	<li>
@DOCUMENT_POSITION_CONTAINED_BY (16 ~EQ 0x10)
</li>
	<li>
@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC (32 ~EQ 0x20)
</li>
</ul>

<div class="algo">
<p>
@compareDocumentPosition(other)
~method手続きは：
◎
The compareDocumentPosition(other) method steps are:
</p>
<ol>
	<li>
~IF［
コレ ~EQ %other
］
⇒
~RET 0
◎
If this is other, then return zero.
</li>
	<li>
( %他~node, %自~node ) ~LET ( %other, コレ )
◎
Let node1 be other and node2 be this.
</li>
	<li>
( %他~属性o, %自~属性o ) ~LET ( ~NULL, ~NULL )
◎
Let attr1 and attr2 be null.
</li>
	<li>
~IF［
%他~node は`属性o$である
］
⇒＃
%他~属性o ~SET %他~node；
%他~node ~SET %他~属性o が`属する要素$
◎
If node1 is an attribute, then set attr1 to node1 and node1 to attr1’s element.
</li>
	<li>
<p>
~IF［
%自~node は`属性o$である
］：
◎
If node2 is an attribute:
</p>
		<ol>
			<li>
%自~属性o ~SET %自~node
◎
↓</li>
			<li>
%自~node ~SET %自~属性o が`属する要素$
◎
Set attr2 to node2 and node2 to attr2’s element.
</li>
			<li>
<p>
~IF［
%他~属性o ~NEQ ~NULL
］~AND［
%自~属性o ~NEQ ~NULL
］~AND［
%自~node ~EQ %他~node
］：
◎
If attr1 and node1 are non-null, and node2 is node1:
</p>
				<ol>
					<li>
<p>
%自~node の`属性o~list$elを成す
~EACH( %属性o )
に対し：
◎
For each attr of node2’s attribute list:
</p>
						<ol>
							<li>
~IF［
( %属性o, %他~属性o )
は`同等$nodeである
］
⇒
~RET 
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_PRECEDING
◎
If attr equals attr1, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.
</li>
							<li>
~IF［
( %属性o, %自~属性o )
は`同等$nodeである
］
⇒
~RET
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_FOLLOWING
◎
If attr equals attr2, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%他~node ~EQ ~NULL
］~OR［
%自~node ~EQ ~NULL
］~OR［
%他~node の`根$ ~NEQ %自~node の`根$
］
⇒
~RET ［
$DOCUMENT_POSITION_DISCONNECTED ~PLUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS ［
$DOCUMENT_POSITION_PRECEDING または $DOCUMENT_POSITION_FOLLOWING
（ただし，いずれが~~選択されるかは一貫するものとする）］
］
◎
If node1 or node2 is null, or node1’s root is not node2’s root, then return the result of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.
</p>

<p class="note">注記：
$DOCUMENT_POSITION_PRECEDING, $DOCUMENT_POSITION_FOLLOWING
のどちらを返すかは，概して~pointer比較を介して実装される。
~JS実装においては `Math.random()^c 値を利用できる。
【理想的には、各~node~treeどうしの順序も循環しないように一貫するべきであろう。】
◎
Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is typically implemented via pointer comparison. In JavaScript implementations a cached Math.random() value can be used.
</p>

	</li>
	<li>
~IF［［
%他~node は %自~node の`先祖$である
］~AND［
%他~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%自~属性o ~NEQ ~NULL
］］
⇒
~RET $DOCUMENT_POSITION_CONTAINS ~PLUS $DOCUMENT_POSITION_PRECEDING
◎
If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
</li>
	<li>
~IF［［
%他~node は %自~node の`子孫$である
］~AND［
%自~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%他~属性o ~NEQ ~NULL
］］
⇒
~RET 
$DOCUMENT_POSITION_CONTAINED_BY ~PLUS $DOCUMENT_POSITION_FOLLOWING
◎
If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
</li>
	<li>
<p>
~IF［
%他~node は %自~node に`先行-$する
］
⇒
~RET $DOCUMENT_POSITION_PRECEDING
◎
If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
</p>

<p class="note">注記：
`属性o$は，自身が`属する要素$と同じ`~tree$には`関与-$しないが、
この~algoに因り［
属性oは，自身が属する要素の`子$に`先行-$する
］ものとされることになる。
◎
Due to the way attributes are handled in this algorithm this results in a node’s attributes counting as preceding that node’s children, despite attributes not participating in the same tree.
</p>
	</li>
	<li>
~RET $DOCUMENT_POSITION_FOLLOWING
◎
Return DOCUMENT_POSITION_FOLLOWING.
</li>
</ol>
</div>

<div class="algo">
@contains(other)
~method手続きは
⇒
~RET ~IS［
%other はコレの`広義-子孫$である
］
◎
The contains(other) method steps are to return true if other is an inclusive descendant of this; otherwise false (including when other is null).
</div>

<div class="algo">
<p>
%要素 用の
`~ns接頭辞を~locateする@
~algoは、
所与の
( %~ns )
に対し：
◎
To locate a namespace prefix for an element using namespace, run these steps:
</p>
<ol>
	<li>
~IF［
%要素 の`~ns$el ~EQ %~ns
］~AND［
%要素 の`~ns接頭辞$el ~NEQ ~NULL
］
⇒
~RET %要素 の`~ns接頭辞$el
◎
If element’s namespace is namespace and its namespace prefix is non-null, then return its namespace prefix.
</li>
	<li>
%属性o ~LET %要素 の`属性o~list$elを成す`属性o$のうち，次を満たす`最初のもの？$
⇒
［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`値$a ~EQ %~ns
］
◎
If element has an attribute whose namespace prefix is "xmlns" and value is namespace, then return element’s first such attribute’s local name.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
~RET %属性o の`局所~名$a
◎
↑</li>
	<li>
%親 ~SET %要素 の`親~要素$
◎
↓</li>
	<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
~RET %親 用の`~ns接頭辞を~locateする$( %~ns )
◎
If element’s parent element is non-null, then return the result of running locate a namespace prefix on that element using namespace.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
%~node 用の
`~nsを~locateする@
~algoは、
所与の
( %接頭辞 )
に対し：
◎
To locate a namespace for a node using prefix,＼
↓switch on the interface node implements:
</p>
<ol>
	<li>
<p>
~IF［
%~node は $Element を`実装-$する
］：
◎
Element
</p>
		<ol>
			<li>
~IF［
%接頭辞 ~EQ `xml^l
］
⇒
~RET `~XML~ns$
◎
If prefix is "xml", then return the XML namespace.
</li>
			<li>
~IF［
%接頭辞 ~EQ `xmlns^l
］
⇒
~RET `~XMLNS~ns$
◎
If prefix is "xmlns", then return the XMLNS namespace.
</li>
			<li>
~IF［
%~node の`~ns$el ~NEQ ~NULL
］~AND［
%~node の`~ns接頭辞$el ~EQ %接頭辞
］
⇒
~RET その`~ns$el
◎
If its namespace is non-null and its namespace prefix is prefix, then return namespace.
</li>
			<li>
<p>
%属性o ~LET %~node の`属性o~list$elを成す`属性o$のうち，［
%接頭辞 に応じて，次に与える条件
］を満たす`最初のもの？$：
</p>
				<ul class="switch">
					<li>
%接頭辞 ~NEQ ~NULL の場合
⇒
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`局所~名$a ~EQ %接頭辞
］
</li>
					<li>
%接頭辞 ~EQ ~NULL の場合
⇒
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ ~NULL
］~AND［
`局所~名$a ~EQ `xmlns^l
］
</li>
				</ul>
◎
If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is "xmlns", and local name is prefix, or if prefix is null and it has an attribute whose namespace is the XMLNS namespace, namespace prefix is null, and local name is "xmlns",＼
</li>
			<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
~RET ［
%属性o の`値$a ~NEQ 空~文字列 ならばそれ ／
~ELSE_ ~NULL
］
◎
then return its value if it is not the empty string, and null otherwise.
◎
↓If its parent element is null, then return null.
◎
↓Return the result of running locate a namespace on its parent element using prefix.
</li>
		</ol>
	</li>
	<li>
%要素 ~LET %~node が`実装-$する~interfaceに応じて
⇒＃
$Element ならば %~node の`親~要素$ ／
$Document ならば %~node の`文書~要素$ ／
$DocumentType ならば ~NULL ／
$DocumentFragment ならば ~NULL ／
$Attr ならば %~node が`属する要素$ ／
~ELSE_【すなわち， $CharacterData ならば】 %~node の`親~要素$
◎
Document
• If its document element is null, then return null.
• Return the result of running locate a namespace on its document element using prefix.
DocumentType
DocumentFragment
• Return null.
Attr
• If its element is null, then return null.
• Return the result of running locate a namespace on its element using prefix.
Otherwise
• If its parent element is null, then return null.
• Return the result of running locate a namespace on its parent element using prefix.
</li>
	<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
~RET %要素 用の`~nsを~locateする$( %接頭辞 )
◎
↑</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
@lookupPrefix(namespace)
~method手続きは：
◎
The lookupPrefix(namespace) method steps are:
</p>
<ol>
	<li>
~IF［
%namespace ~IN { ~NULL, 空~文字列 }
］
⇒
~RET ~NULL
◎
If namespace is null or the empty string, then return null.
</li>
	<li>
%要素 ~LET コレが`実装-$する~interfaceに応じて
⇒＃
$Element ならばコレ ／
$Document ならばコレの`文書~要素$ ／
$DocumentType ならば ~NULL ／
$DocumentFragment ならば ~NULL ／
$Attr ならばコレが`属する要素$ ／
~ELSE_【すなわち， $CharacterData ならば】コレの`親~要素$
◎
Switch on the interface this implements:
◎
↓</li>
	<li>
~IF ［
%要素 ~NEQ ~NULL
］
⇒
~RET %要素 用の`~ns接頭辞を~locateする$( %namespace )
◎
• Element
•• Return the result of locating a namespace prefix for this using namespace.
◎
• Document
•• If this’s document element is null, then return null.
•• Return the result of locating a namespace prefix for this’s document element using namespace.
◎
• DocumentType
• DocumentFragment
•• Return null.
◎
• Attr
•• If this’s element is null, then return null.
•• Return the result of locating a namespace prefix for this’s element using namespace.
◎
• Otherwise
•• If this’s parent element is null, then return null.
•• Return the result of locating a namespace prefix for this’s parent element using namespace.
</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
@lookupNamespaceURI(prefix)
~method手続きは：
◎
The lookupNamespaceURI(prefix) method steps are:
</p>
<ol>
	<li>
~IF［
%prefix ~EQ 空~文字列
］
⇒
%prefix ~SET ~NULL
◎
If prefix is the empty string, then set it to null.
</li>
	<li>
~RET コレ用の`~nsを~locateする$( %prefix )
◎
Return the result of running locate a namespace for this using prefix.
</li>
</ol>
</div>

<div class="algo">
<p>
@isDefaultNamespace(namespace)
~method手続きは：
◎
The isDefaultNamespace(namespace) method steps are:
</p>
<ol>
	<li id="cp-normalize-ns0">
~IF［
%namespace ~EQ 空~文字列
］
⇒
%namespace ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>
	<li>
%既定~ns ~LET コレ用の`~nsを~locateする$( ~NULL )
◎
Let defaultNamespace be the result of running locate a namespace for this using null.
</li>
	<li>
~RET ~IS［
%既定~ns ~EQ %namespace
］
◎
Return true if defaultNamespace is the same as namespace; otherwise false.
</li>
</ol>
</div>

<div class="algo">
<p>
@insertBefore(node, child)
~method手続きは
⇒
~RET コレの中で`~nodeを子の前に前挿入する$( %node, %child )
◎
The insertBefore(node, child) method steps are to return the result of pre-inserting node into this before child.
</p>
</div>

<div class="algo">
@appendChild(node)
~method手続きは
⇒
~RET コレに`~nodeを付加する$( %node )
◎
The appendChild(node) method steps are to return the result of appending node to this.
</div>

<div class="algo">
@replaceChild(node, child)
~method手続きは
⇒
~RET コレの中で`子を~nodeに置換する$( %child, %node )
◎
The replaceChild(node, child) method steps are to return the result of replacing child with node within this.
</div>

<div class="algo">
<p>
@removeChild(child)
~method手続きは：
【！~RET `子を親から前除去する$( %child, コレ )】
</p>
<ol>
	<li>
~IF［
%child の`親$ ~NEQ コレ
］
⇒
~THROW `NotFoundError$E
</li>
	<li>
`~nodeを除去する$( %child )
</li>
	<li>
~RET %child
</li>
</ol>
◎
The removeChild(child) method steps are to return the result of pre-removing child from this.
</div>

<p class="trans-note">【
上で定義された $insertBefore 以下の~treeを改変する各種~methodは、
改変した結果が文書~言語の内容~modelに反することになる場合でも，指定されたとおり遂行され、
`~node~tree$に対する拘束に反しない限り，~treeを改変することになる
（例：~HTMLの `script$e 要素に子~要素を挿入したり，`~void要素$に子~nodeを挿入するなど）。
】</p>

<div class="algo">
<p>
`~node$ %根 用の［
%有修飾~名 を
`有修飾~名に持つ要素の~list@
］は、
次のように設定された $HTMLCollection を返す：
◎
The list of elements with qualified name qualifiedName for a node root is the HTMLCollection returned by the following algorithm:
</p>

【！＊局所~名 = * の場合でも、根は除外される https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName】

<ul>
	<li>
`根$cL ~SET %根
◎
↓</li>
	<li>
<p>
`~filter$cLは［
%根 の`子孫$である`要素$ %要素 のうち［
~OR↓
］が満たされるもの
］に合致する：
◎
↓</p>
		<ul>
			<li>
%有修飾~名 ~EQ `002A^U `*^smb
（この場合、
%要素 に関する条件は問われない）
◎
If qualifiedName is U+002A (*), then return an HTMLCollection rooted at root, whose filter matches only descendant elements.
</li>
			<li>
<p>
［
%根 の`~node文書$は`~HTML文書$である
］~AND［
~OR↓
］：
◎
Otherwise, if root’s node document is an HTML document, return an HTMLCollection rooted at root, whose filter matches the following descendant elements:
</p>
				<ul>
					<li>
［
`~ns$el ~EQ `~HTML~ns$
］~AND［
%要素 の`有修飾~名$ ~EQ `~ASCII小文字~化する$( %有修飾~名 )
］
◎
Whose namespace is the HTML namespace and whose qualified name is qualifiedName, in ASCII lowercase.
</li>
						<li>
［
`~ns$el ~NEQ `~HTML~ns$
］~AND［
%要素 の`有修飾~名$ ~EQ %有修飾~名
］
◎
Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.
</li>
				</ul>
			</li>
			<li>
%要素 の`有修飾~名$ ~EQ %有修飾~名
◎
Otherwise, return an HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName.
</li>
		</ul>
	</li>
</ul>

<p>
以前の~callと同じ引数で呼出されたときは、
%根 の`~node文書$の`種別$docが変化していない限り，そのときに返したものと同じ $HTMLCollection ~objを返してもヨイ。
◎
When invoked with the same argument, and as long as root’s node document’s type has not changed, the same HTMLCollection object may be returned as returned by an earlier call.
</p>
</div>

<div class="algo">
<p>
`~node$ %根 用の［
( %~ns, %局所~名 )
を
`( ~ns, 局所~名 ) に持つ要素の~list@
］は、
次のように設定された $HTMLCollection を返す：
◎
The list of elements with namespace namespace and local name localName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ul>
	<li>
`根$cL ~SET %根
◎
↓</li>
	<li>
<p>
`~filter$cLは［
%根 の`子孫$である`要素$ %要素 のうち，次の結果 ~EQ ~T になるもの
］に合致する：
</p>
		<ol>
			<li>【！cp-normalize-ns】
~IF［
%~ns ~EQ 空~文字列
］
⇒
%~ns ~SET ~NULL
</li>
			<li>
~RET ~IS［
%~ns ~IN { `002A^U `*^smb, %要素 の`~ns$el }
］~AND［
%局所~名 ~IN { `002A^U `*^smb, %要素 の`局所~名$el }
］
</li>
		</ol>
<p>
（ %~ns ~EQ %局所~名 ~EQ `*^l の場合、
%要素 は~~無条件に合致することになる）
</p>

◎
If namespace is the empty string, then set it to null.
◎
If both namespace and localName are U+002A (*), then return an HTMLCollection rooted at root, whose filter matches descendant elements.
◎
If namespace is U+002A (*), then return an HTMLCollection rooted at root, whose filter matches descendant elements whose local name is localName.
◎
If localName is U+002A (*), then return an HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace.
◎
Return an HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace and local name is localName.
</li>
</ul>

<p id="cp-may-return-the-same">
以前の~callと同じ引数で呼出されたときは、
そのときに返したものと同じ $HTMLCollection ~objを返してもヨイ。
◎
When invoked with the same argument, the same HTMLCollection object may be returned as returned by an earlier call.
</p>
</div>

<div class="algo">
<p>
`~node$ %根 用の［
%classNames を
`~class群に含む要素の~list@
］とは、
次の~algoが返す $HTMLCollection である：
◎
The list of elements with class names classNames for a node root is the HTMLCollection returned by the following algorithm:
</p>
<ol>
	<li>
%~class群 ~LET `有順序~集合として構文解析する$( %classNames )
◎
Let classes be the result of running the ordered set parser on classNames.
</li>
	<li>
~IF［
%~class群 は`空$である
］
⇒
~RET 空な $HTMLCollection
◎
If classes is the empty set, return an empty HTMLCollection.
</li>
	<li>
<p>
~RET 次のように設定された $HTMLCollection `~collection$
⇒＃
`根$cL ~SET %根,
`~filter$cLは %根 の`子孫$である`要素$のうち次を満たすものに合致する ⇒
その`~class群$は %~class群 を成す どの~tokenも含む
◎
Return an HTMLCollection rooted at root, whose filter matches descendant elements that have all their classes in classes.
</p>

<p>
`~class群$と %~class群 の中の各~tokenの比較は、［
%根 の`~node文書$の`~mode$docが `quirks^l ならば `~ASCII大小無視$ ／
~ELSE_ `一致する$かどうか
］で行うモノトスル。
◎
The comparisons for the classes must be done in an ASCII case-insensitive manner if root’s node document’s mode is "quirks"; otherwise in an identical to manner.
</p>
	</li>
</ol>
<!--cp-may-return-the-same-->
</div>

		</section>
		<section id="interface-document">
<h3 title="Interface Document">4.5. ^@Document ~interface</h3>

！！
[`Exposed$=Window]
interface @Document : $Node {
  `Document$mc();

  [`SameObject$] readonly attribute $DOMImplementation $implementation;
  readonly attribute $USVString $URL;
  readonly attribute $USVString $documentURI;
  readonly attribute $DOMString $compatMode;
  readonly attribute $DOMString $characterSet;
  readonly attribute $DOMString $charset; // <span class="comment" id="cp-legacy-characterSet" title="legacy alias of .characterSet">$characterSet の旧来の別名</span>
  readonly attribute $DOMString $inputEncoding; // <!--cp-legacy-characterSet-->
  readonly attribute $DOMString $contentType;

  readonly attribute $DocumentType? $doctype;
  readonly attribute $Element? $documentElement;
  $HTMLCollection $getElementsByTagName($DOMString %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS($DOMString? %namespace, $DOMString %localName);
  $HTMLCollection $getElementsByClassName($DOMString %classNames);

  [`CEReactions$, `NewObject$] $Element $createElement($DOMString %localName, optional ($DOMString or $ElementCreationOptions) %options = {});
  [`CEReactions$, `NewObject$] $Element $createElementNS($DOMString? %namespace, $DOMString %qualifiedName, optional ($DOMString or $ElementCreationOptions) %options = {});
  [`NewObject$] $DocumentFragment $createDocumentFragment();
  [`NewObject$] $Text $createTextNode($DOMString %data);
  [`NewObject$] $CDATASection $createCDATASection($DOMString %data);
  [`NewObject$] $Comment $createComment($DOMString %data);
  [`NewObject$] $ProcessingInstruction $createProcessingInstruction($DOMString %target, $DOMString %data);

  [`CEReactions$, `NewObject$] $Node $importNode($Node %node, optional ($boolean or $ImportNodeOptions) %options = false);
  [`CEReactions$] $Node $adoptNode($Node %node);

  [`NewObject$] $Attr $createAttribute($DOMString %localName);
  [`NewObject$] $Attr $createAttributeNS($DOMString? %namespace, $DOMString %qualifiedName);

  [`NewObject$] $Event $createEvent($DOMString %interface); // <!--cp-legacy-->

  [`NewObject$] $Range $createRange();

  // $NodeFilter<!---->.$NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [`NewObject$] $NodeIterator $createNodeIterator($Node %root, optional `unsigned long$ %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
  [`NewObject$] $TreeWalker $createTreeWalker($Node %root, optional `unsigned long$ %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
};

[`Exposed$=Window]
interface @XMLDocument : $Document {};

dictionary @@ElementCreationOptions {
  $CustomElementRegistry? @customElementRegistry;
  $DOMString @is;
};

dictionary @@ImportNodeOptions {
  $CustomElementRegistry @customElementRegistry;
  $boolean @selfOnly = false;
};
！

<p>
$@Document `~node$は、
単に
`文書@
（ `document^en ）とも称される。
◎
Document nodes are simply known as documents.
</p>

<p>
`文書$の`~node文書$は、
それ自身とする。
◎
A document’s node document is itself. 
</p>

<div class="p">
<p>
各 `文書$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`符号化法@doc
⇒
`符号化法$
— 初期~時は `utf-8$ とする。
</li>
	<li>
`内容~型@doc
⇒
文字列
— 初期~時は `application/xml^l とする。
</li>
	<li>
`~URL@doc
⇒
`~URL$
— 初期~時は `about:blank^l 【が表現する`~URL$】とする。
</li>
	<li>
`生成元@doc
⇒
`生成元$
— 初期~時は `不透明な生成元$ とする。
</li>
	<li>
`種別@doc
⇒
`xml^l ／ `html^l
— 初期~時は `xml^l とする。
</li>
	<li>
`~mode@doc
⇒
`no-quirks^l ／
`quirks^l ／
`limited-quirks^l
— 初期~時は `no-quirks^l とする。
</li>
	<li>
`宣言的な~shadow根を許容するか@doc
⇒
真偽値
— 初期~時は ~F とする。
</li>
	<li>
`~custom要素~registry@doc
⇒
~NULL ／ $CustomElementRegistry ~obj
— 初期~時は ~NULL とする。
</li>
</ul>

<p>
`ENCODING$r `URL$r `HTML$r
</p>
◎
Each document has an associated encoding (an encoding), content type (a string), URL (a URL), origin (an origin), type ("xml" or "html"), mode ("no-quirks", "quirks", or "limited-quirks"), allow declarative shadow roots (a boolean), and custom element registry (null or a CustomElementRegistry object). [ENCODING] [URL] [HTML]
◎
Unless stated otherwise, a document’s encoding is the utf-8 encoding, content type is "application/xml", URL is "about:blank", origin is an opaque origin, type is "xml", mode is "no-quirks", allow declarative shadow roots is false, and custom element registry is null. 
</div>

<div class="p">
<p>
`文書$は、
その`種別$docに応じて：
</p>
<ul>
	<li>
`xml^l ならば
`~XML文書@
であるとされる。
</li>
	<li>
`html^l ならば
`~HTML文書@
であるとされる。
</li>
</ul>
<p>
一部の~APIの挙動は、
この 2 種のどちらなのかにより，影響される。
</p>
◎
A document is said to be an XML document if its type is "xml"; otherwise an HTML document. Whether a document is an HTML document or an XML document affects the behavior of certain APIs.
</div>

<div class="p">
<p>
`文書$は、
その`~mode$docに応じて：
</p>
<ul>
	<li>
`no-quirks^l ならば
`過去互換なし~mode@
下にあるとされる。
</li>
	<li>
`quirks^l ならば
`過去互換~mode@
下にあるとされる。
</li>
	<li>
`limited-quirks^l ならば
`制限付き過去互換~mode@
下にあるとされる。
</li>
</ul>
◎
A document is said to be in no-quirks mode if its mode is "no-quirks", quirks mode if its mode is "quirks", and limited-quirks mode if its mode is "limited-quirks".
</div>

<p class="note">注記：
~modeが既定の~modeから変更されるのは、
`文書$が，新たな`閲覧~文脈$（初期の `about:blank^l ）から，［
DOCTYPE 文字列の有無, およびその値
］に基づいて `~HTML構文解析器$を通して作成される場合に限られる。
`HTML$r
◎
The mode is only ever changed from the default for documents created by the HTML parser based on the presence, absence, or value of the DOCTYPE string, and by a new browsing context (initial "about:blank"). [HTML]
</p>

<p class="note">注記：
`過去互換なし~mode$ は，元々は “標準~mode” と称され，
`制限付き過去互換~mode$ は，かつては “ほぼ標準~mode” と称されていた。
それらは，今や標準により定義されたので
（また、
それらの元の名前が~~的外れであることから `Ian Hickson^en が~~否決したので）、
改称された。
◎
No-quirks mode was originally known as "standards mode" and limited-quirks mode was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)
</p>

<div class="algo">
<p>
`文書$ %文書 の`親~targetを取得する$ときは、
所与の
( ~event %~event )
に対し：
</p>
<ol>
	<li>
~IF［
%~event の $Event.type 属性~値 ~EQ `load^l
］~OR［
%文書 が`属する閲覧~文脈$ ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 に`関連な大域~obj$
</li>
</ol>

◎
A document’s get the parent algorithm, given an event, returns null if event’s type attribute value is "load" or document does not have a browsing context; otherwise the document’s relevant global object.
</div>

<hr>

<dl class="domintro">
	<dt>%document = $Document()</dt>
	<dd>
新たな`文書$を返す。
◎
Returns a new document.
</dd>

	<dt>%document . $implementation</dt>
	<dd>
%document の $DOMImplementation ~objを返す。
◎
Returns document’s DOMImplementation object.
</dd>

	<dt>%document . $URL</dt>
	<dt>%document . $documentURI</dt>
	<dd>
%document の`~URL$doc を返す。
◎
Returns document’s URL.
</dd>

	<dt>%document . $compatMode</dt>
	<dd>
%document の`~mode$docに応じて，［
`quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返す。
◎
Returns the string "BackCompat" if document’s mode is "quirks"; otherwise "CSS1Compat".
</dd>

	<dt>%document . $characterSet</dt>
	<dd>
%document の`符号化法$docを返す。
◎
Returns document’s encoding.
</dd>

	<dt>%document . $contentType</dt>
	<dd>
%document の`内容~型$docを返す。
◎
Returns document’s content type.
</dd>
</dl>

<div class="algo">
<p>
@Document()
構築子~手続きは
⇒
コレの`生成元$doc ~SET `現在の大域~obj$に`結付けられた文書$の`生成元$doc `HTML$r
◎
The new Document() constructor steps are to set this’s origin to the origin of current global object’s associated Document. [HTML]
</p>

<p class="note">注記：
$DOMImplementation.createDocument() と違って、
この構築子は
$XMLDocument ~objではなく，`文書$（ $Document ~obj）を返す。
◎
Unlike createDocument(), this constructor does not return an XMLDocument object, but a document (Document object).
</p>
</div>

<div class="algo">
@implementation
取得子~手続きは
⇒
~RET コレに結付けられた $DOMImplementation ~obj
◎
The implementation getter steps are to return the DOMImplementation object that is associated with this.
</div>

<div class="algo">
<p>
@URL,
@documentURI
取得子~手続きは、
いずれも
⇒
~RET `~URLを直列化する$( コレの`~URL$doc )
◎
The URL and documentURI getter steps are to return this’s URL, serialized.
</div>

<div class="algo">
@compatMode
取得子~手続きは
⇒
~RET コレの`~mode$docに応じて
⇒＃
`quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
◎
The compatMode getter steps are to return "BackCompat" if this’s mode is "quirks"; otherwise "CSS1Compat".
</div>

<div class="algo">
@characterSet,
@charset,
@inputEncoding
取得子~手続きは、
いずれも
⇒
~RET コレの`符号化法$docの`名前$enc
◎
The characterSet, charset, and inputEncoding getter steps are to return this’s encoding’s name.
</div>

<div class="algo">
@contentType
取得子~手続きは
⇒
~RET コレの`内容~型$doc
◎
The contentType getter steps are to return this’s content type.
</div>

<dl class="domintro">
	<dt>%document . $doctype</dt>
	<dd>
`~doctype$が［
在るならばそれ ／
無いならば ~NULL
］を返す。
◎
Returns the doctype or null if there is none.
</dd>

	<dt>%document . $documentElement</dt>
	<dd>
`文書~要素$を返す。
◎
Returns the document element.
</dd>

	<dt>%collection = %document . $getElementsByTagName(qualifiedName)</dt>
	<dd>
<p>
引数に応じて，次を満たす`子孫$`要素$すべてからなる $HTMLCollection を返す：
</p>
		<ul>
			<li>
%qualifiedName ~EQ `*^l の場合
⇒
無条件。
</li>
			<li>
<p>
他の場合、
~OR↓ を満たすもの：
</p>
				<ul>
					<li>
`有修飾~名$ ~EQ %qualifiedName
</li>
					<li>
［
`~HTML文書$ 内に在る
］~AND［
`~HTML~ns$に属する
］~AND［
`有修飾~名$は %qualifiedName に~ASCII大小無視で合致する
］
</li>
				</ul>
			</li>
		</ul>
◎
If qualifiedName is "*" returns an HTMLCollection of all descendant elements.
◎
Otherwise, returns an HTMLCollection of all descendant elements whose qualified name is qualifiedName. (Matches case-insensitively against elements in the HTML namespace within an HTML document.)
</dd>

	<dt>%collection = %document . $getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
<p>
引数に応じて，次を満たす`子孫$`要素$すべてからなる $HTMLCollection を返す：
◎
↓</p>
		<ul>
			<li>
%namespace, %localName ともに `*^l の場合：
無条件。
◎
If namespace and localName are "*", returns an HTMLCollection of all descendant elements.
</li>
			<li>
%namespace のみ `*^l の場合：
［
`局所~名$el ~EQ %localName
］なるもの。
◎
If only namespace is "*", returns an HTMLCollection of all descendant elements whose local name is localName.
</li>
			<li>
%localName のみ `*^l の場合：
［
`~ns$el ~EQ %namespace 
］なるもの。
◎
If only localName is "*", returns an HTMLCollection of all descendant elements whose namespace is namespace.
</li>
			<li>
他の場合：
［
`~ns$el ~EQ %namespace
］~AND［
`局所~名$el ~EQ %localName
］なるもの。
◎
Otherwise, returns an HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
</li>
		</ul>
	</dd>

	<dt>%collection = %document . $getElementsByClassName(classNames)</dt>
	<dt>%collection = %element . $Element.getElementsByClassName(classNames)</dt>
	<dd>
~methodが呼出された~obj（`文書$または`要素$）内の`要素$のうち，［
%classNames で与えられる一連の~class名をすべて有するもの
］からなる $HTMLCollection を返す。
%classNames 引数は、
一連の~class名を~space等で分離した~listとして解釈される。
◎
Returns an HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes.
</dd>
</dl>

<div class="algo">
@doctype
取得子~手続きは
⇒
~RET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
コレの`子$である
］~AND［
`~doctype$である
］
◎
The doctype getter steps are to return the child of this that is a doctype; otherwise null.
</div>

<div class="algo">
@documentElement
取得子~手続きは
⇒
~RET コレの`文書~要素$
◎
The documentElement getter steps are to return this’s document element.
</div>

<div class="algo">
<p>
@getElementsByTagName(qualifiedName)
~method手続きは
⇒
~RET コレ用の［
%qualifiedName を`有修飾~名に持つ要素の~list$
］
◎
The getElementsByTagName(qualifiedName) method steps are to return the list of elements with qualified name qualifiedName for this.
</p>

<p class="note">注記：
したがって，`~HTML文書$においては、
`document.getElementsByTagName("FOO")^c は
`~HTML~ns$に属さない `FOO^e 要素と
`~HTML~ns$に属する `foo^e 要素に合致し，
`~HTML~ns$に属する `FOO^e 要素には合致しないことになる。
◎
Thus, in an HTML document, document.getElementsByTagName("FOO") will match &lt;FOO&gt; elements that are not in the HTML namespace, and &lt;foo&gt; elements that are in the HTML namespace, but not &lt;FOO&gt; elements that are in the HTML namespace.
</p>
</div>

<div class="algo">
@getElementsByTagNameNS(namespace, localName)
~method手続きは
⇒
~RET コレ用の［
( %namespace, %localName ) を
`( ~ns, 局所~名 ) に持つ要素の~list$
］
◎
The getElementsByTagNameNS(namespace, localName) method steps are to return the list of elements with namespace namespace and local name localName for this.
</div>

<div class="algo">
<p>
@getElementsByClassName(classNames)
~method手続きは
⇒
~RET コレ用の［
%classNames を`~class群に含む要素の~list$
］
◎
The getElementsByClassName(classNames) method steps are to return the list of elements with class names classNames for this.
</p>

<div class="example">
<p>
次の XHTML 片が与えられたとする：
◎
Given the following XHTML fragment:
</p>

`interface-document-1^xCode

<p>
<samp>document.getElementById(`example^l).getElementsByClassName(`aaa^l)</samp>
の~callは、
その中の 2 個の段落
<mark>p1</mark> と <mark>p2</mark>
からなる $HTMLCollection を返すことになる。
◎
A call to document.getElementById("example").getElementsByClassName("aaa") would return an HTMLCollection with the two paragraphs p1 and p2 in it.
</p>

<p>
一方で，
<samp>getElementsByClassName(`ccc&nbsp;bbb^l)</samp>
の~callは
その中の 1 個の~node <mark>p3</mark> のみを返すことになる。
<samp>document.getElementById(`example^l).getElementsByClassName(`bbb&nbsp;&nbsp;&nbsp;ccc&nbsp;^l)</samp>
の~callも同じものを返すことになる。
◎
A call to getElementsByClassName("ccc bbb") would only return one node, however, namely p3. A call to document.getElementById("example").getElementsByClassName("bbb ccc ") would return the same thing.
</p>

<p>
<samp>getElementsByClassName(`aaa,bbb^l)</samp>
の~callは 1 個の~nodeも返さない。
上のどの要素も `aaa,bbb^c ~classに属さない。
◎
A call to getElementsByClassName("aaa,bbb") would return no nodes; none of the elements above are in the aaa,bbb class.
</p>
</div>
</div>

<dl class="domintro">
	<dt>%element = %document . $createElement(localName [, options])</dt>
	<dd>
`局所~名$elが %localName にされた`要素$を返す
（ %document が`~HTML文書$である場合， %localName は小文字~化される）。
`要素$の`~ns$elは，［
次のいずれかに該当する場合は`~HTML~ns$ ／
他の場合は ~NULL
］になる
⇒＃
%document は`~HTML文書$である ／
%document の`内容~型$doc ~EQ `application/xhtml+xml^l
◎
Returns an element with localName as local name (if document is an HTML document, localName gets lowercased). The element’s namespace is the HTML namespace when document is an HTML document or document’s content type is "application/xhtml+xml"; otherwise null.
</dd>
	<dd id="cp-supplied-customElementRegistry-mb">
%options の $ElementCreationOptions.customElementRegistry を利用して，
$CustomElementRegistry を設定できる。
◎
When supplied, options’s customElementRegistry can be used to set the CustomElementRegistry.
</dd>
	<dd id="cp-supplied-is-mb">
%options の $ElementCreationOptions.is を利用して，
`~custom化された組込みの要素$を作成できる。
◎
When supplied, options’s is can be used to create a customized built-in element.
</dd>
	<dd>
%localName が`妥当な要素~局所~名$でない場合、
`InvalidCharacterError$E 例外が投出される。
◎
If localName is not a valid element local name an "InvalidCharacterError" DOMException will be thrown.
</dd>
	<dd id="cp-supplied-both-mb">
%options の［
$ElementCreationOptions.customElementRegistry, $ElementCreationOptions.is
］どちらも給されたときは、
`NotSupportedError$E 例外が投出される。
◎
When both options’s customElementRegistry and options’s is are supplied, a "NotSupportedError" DOMException will be thrown.
</dd>

	<dt>%element = %document . $createElementNS(namespace, qualifiedName [, options])</dt>
	<dd>
`~ns$el %namespace に属する新たな`要素$を返す。
その ( `~ns接頭辞$el %接頭辞, `局所~名$el %局所~名 ) は、
順に次のようにされる
⇒＃
%qualifiedName が `003A^U `:^smb を含むならば それを挟んだ ( 前, 後 ) の部分 ／
他の場合は ( ~NULL, %qualifiedName )
◎
Returns an element with namespace namespace. Its namespace prefix will be everything before U+003A (:) in qualifiedName or null. Its local name will be everything after U+003A (:) in qualifiedName or qualifiedName.
</dd>
	<!--cp-supplied-customElementRegistry-mb-->
	<!--cp-supplied-is-mb-->
	<dd>
%qualifiedName が（場合によっては接頭辞を伴う）`妥当な要素~局所~名$でない場合、
`InvalidCharacterError$E 例外が投出される。
◎
If qualifiedName is not a (possibly-prefixed) valid element local name an "InvalidCharacterError" DOMException will be thrown.
</dd>
	<dd>
次のいずれかに該当する場合， `NamespaceError$E 例外が投出される
⇒＃
%namespace ~EQ 空~文字列 ~AND %接頭辞 ~NEQ ~NULL ／
%namespace ~NEQ `~XML~ns$ ~AND %接頭辞 ~EQ `xml^l ／
%namespace ~NEQ `~XMLNS~ns$ ~AND %qualifiedName ~EQ `xmlns^l ／
%namespace ~NEQ `~XMLNS~ns$ ~AND %接頭辞 ~EQ `xmlns^l ／
%namespace ~EQ `~XMLNS~ns$ ~AND %qualifiedName ~NEQ `xmlns^l ／
%namespace ~EQ `~XMLNS~ns$ ~AND %接頭辞 ~NEQ `xmlns^l
◎
If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
• Namespace prefix is non-null and namespace is the empty string.
• Namespace prefix is "xml" and namespace is not the XML namespace.
• qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
• namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
</dd>
	<!--cp-supplied-both-mb-->

	<dt>%documentFragment = %document . $createDocumentFragment()</dt>
	<dd>
$DocumentFragment `~node$を返す。
◎
Returns a DocumentFragment node.
</dd>

	<dt>%text = %document . $createTextNode(data)</dt>
	<dd>
新たな $Text `~node$を返す
— その`~data$は %data にされる。
◎
Returns a Text node whose data is data.
</dd>

	<dt>%text = %document . $createCDATASection(data)</dt>
	<dd>
新たな $CDATASection `~node$を返す
— その`~data$は %data にされる。
◎
Returns a CDATASection node whose data is data.
</dd>

	<dt>%comment = %document . $createComment(data)</dt>
	<dd>
新たな $Comment `~node$を返す
— その`~data$は %data にされる。
◎
Returns a Comment node whose data is data.
</dd>

	<dt>%processingInstruction = %document . $createProcessingInstruction(target, data)</dt>
	<dd>
新たな $ProcessingInstruction `~node$を返す
— その $target は %target にされ, `~data$は %data にされる。
◎
Returns a ProcessingInstruction node whose target is target and data is data.＼
</dd>
	<dd>
次のいずれかに該当する場合，
`InvalidCharacterError$E 例外が投出される
⇒＃
%target は `Name$prod 生成規則に合致しない ／
%data は `?&gt;^l を含んでいる
◎
If target does not match the Name production an "InvalidCharacterError" DOMException will be thrown. If data contains "?&gt;" an "InvalidCharacterError" DOMException will be thrown.
</dd>
</dl>

<p>
他が言明されない限り，所与の
( 局所~名, ~ns )
用の
`要素~interface@
は、
$Element とする。
◎
The element interface for any name and namespace is Element, unless stated otherwise.
</p>

<p class="note">注記：
例えば，~HTML標準は、
( `html$e, `~HTML~ns$ )
用のそれを， $HTMLHtmlElement ~interfaceと定義している。
`HTML$r
◎
The HTML Standard will, e.g., define that for html and the HTML namespace, the HTMLHtmlElement interface is used. [HTML]
</p>

<div class="algo">
<p>
@createElement(localName, options)
~method手続きは：
◎
The createElement(localName, options) method steps are:
</p>
<ol>
	<li>
~IF［
%localName は`妥当な要素~局所~名$でない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName is not a valid element local name, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~IF［
コレは`~HTML文書$ である
］
⇒
%localName ~SET `~ASCII小文字~化する$( %localName )
◎
If this is an HTML document, then set localName to localName in ASCII lowercase.
</li>
	<li id="cp-let-registry-is">
( %~registry, %is ) ~LET `要素~作成~option群を平坦~化する$( %options, コレ )
◎
Let registry and is be the result of flattening element creation options given options and this.
</li>
	<li>
%~ns ~LET ［
次が満たされるならば `~HTML~ns$ ／
~ELSE_ ~NULL
］
⇒
［
コレは`~HTML文書$である
］~OR［
コレの`内容~型$doc ~EQ `application/xhtml+xml^l
］
◎
Let namespace be the HTML namespace, if this is an HTML document or this’s content type is "application/xhtml+xml"; otherwise null.
</li>
	<li>
~RET `要素を作成する$( ↓ )
⇒＃
コレ,
%localName,
%~ns,
~NULL,
%is,
~T,
%~registry
◎
Return the result of creating an element given this, localName, namespace, null, is, true, and registry.
</li>
</ol>
</div>

<div class="algo">
<p>
`内部 createElementNS 手続き@
は、
所与の
( %文書, %namespace, %qualifiedName, %options )
に対し：
◎
The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as follows:
</p>
<ol>
	<li>
( %~ns, %接頭辞, %局所~名 ) ~LET `~nsと名前を検証して抽出する$( %namespace, %qualifiedName, `要素^i )
◎
Let (namespace, prefix, localName) be the result of validating and extracting namespace and qualifiedName given "element".
</li>
	<!--cp-let-registry-is-->
	<li>
~RET `要素を作成する$( ↓ )
⇒＃
%文書,
%局所~名,
%~ns,
%接頭辞,
%is,
~T,
%~registry
◎
Return the result of creating an element given document, localName, namespace, prefix, is, true, and registry.
</li>
</ol>
</div>

<div class="algo">
@createElementNS(namespace, qualifiedName, options)
~method手続きは
⇒
~RET `内部 createElementNS 手続き$( コレ, %namespace, %qualifiedName, %options )
◎
The createElementNS(namespace, qualifiedName, options) method steps are to return the result of running the internal createElementNS steps, given this, namespace, qualifiedName, and options.
</div>

<div class="algo">
<p>
`要素~作成~option群を平坦~化する@
~algoは、
所与の
( ［ 文字列／ $ElementCreationOptions 辞書 ］ %~option群, `文書$ %文書 )
に対し：
◎
To flatten element creation options, given a string or ElementCreationOptions dictionary options and a document document:
</p>
<ol>
	<li>
%文書~registry ~LET %文書 の`~custom要素~registry$doc
【！`~custom要素~registryを検索する$( %文書 )】
◎
Let registry be the result of looking up a custom element registry given document.
</li>
	<li>
~IF［
%~option群 は文字列である
］
⇒
~RET ( %文書~registry, ~NULL )
◎
↓</li>
	<li>
%is ~LET %~option群[ "$ElementCreationOptions.is" ] ~DF ~NULL
◎
Let is be null.
◎
If options is a dictionary:
◎
• If options["is"] exists, then set is to it.
</li>
	<li>
%~registry ~SET %~option群[ "$ElementCreationOptions.customElementRegistry" ] ~DF ~NULL
◎
↓</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%~registry ~EQ ~NULL
］~AND［
%is ~NEQ ~NULL
］
</li>
			<li>
［
%~registry ~NIN { ~NULL, %文書~registry }
］~AND［
%~registry の`視野~付きか$cR ~EQ ~F
］
</li>
		</ul>
<p>
…ならば
⇒
~THROW `NotSupportedError$E
</p>
◎
• If options["customElementRegistry"] exists:
•• If is is non-null, then throw a "NotSupportedError" DOMException.
•• Set registry to options["customElementRegistry"].
• If registry is non-null, registry’s is scoped is false, and registry is not document’s custom element registry, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
%~registry ~EQ ~NULL
］
⇒
%~registry ~SET %文書~registry
◎
↑</li>
	<li>
~RET ( %~registry, %is )
◎
Return registry and is.
</li>
</ol>
</div>

<p class="note">注記：
~web互換性のため、［
$createElement() ／ $createElementNS()
］の %options 引数には文字列も許容される。
◎
createElement() and createElementNS()’s options parameter is allowed to be a string for web compatibility.
</p>

<div class="algo">
@createDocumentFragment()
~method手続きは
⇒
~RET 新たな`文書片$
— その
⇒
`~node文書$ ~SET コレ
◎
The createDocumentFragment() method steps are to return a new DocumentFragment node whose node document is this.
</div>

<div class="algo">
@createTextNode(data)
~method手続きは
⇒
~RET `新たな~Text~node$( %data, コレ )
◎
The createTextNode(data) method steps are to return a new Text node whose data is data and node document is this.
</div>

<div class="algo">
<p>
@createCDATASection(data)
~method手続きは：
◎
The createCDATASection(data) method steps are:
</p>
<ol>
	<li>
~IF［
コレは`~HTML文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If this is an HTML document, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
%data は文字列 `]]&gt;^l を包含する
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains the string "]]&gt;", then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~RET `新たな~obj$( $CDATASection )
— その
⇒＃
`~data$ ~SET %data,
`~node文書$ ~SET コレ
◎
Return a new CDATASection node with its data set to data and node document set to this.
</li>
</ol>
</div>

<div class="algo">
@createComment(data)
~method手続きは
⇒
~RET `新たな~obj$( $Comment )
— その
⇒＃
`~data$ ~SET %data,
`~node文書$ ~SET コレ
◎
The createComment(data) method steps are to return a new Comment node whose data is data and node document is this.
</div>

<div class="algo">
<p>
@createProcessingInstruction(target, data)
~method手続きは：
◎
The createProcessingInstruction(target, data) method steps are:
</p>
<ol>
	<li>
~IF［
%target は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If target does not match the Name production, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~IF［
%data は文字列 `?&gt;^l を含む
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains the string "?&gt;", then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~RET `新たな~obj$( $ProcessingInstruction )
— その
⇒＃
`~target$pI【！$ProcessingInstruction.target】 ~SET %target,
`~data$ ~SET %data,
`~node文書$ ~SET コレ
◎
Return a new ProcessingInstruction node, with target set to target, data set to data, and node document set to this.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%clone = %document . $importNode(node [, options = false])</dt>
	<dd>
%node の複製を返す。
◎
Returns a copy of node.＼
</dd>
	<dd>
<p>
%options が ~OR↓ を満たす場合、
複製には %node の`子孫$も含められる。
</p>
		<ul>
			<li>
%options ~EQ ~T
</li>
			<li>
［
%options は辞書である
］~AND［
%options の $ImportNodeOptions.selfOnly ~EQ ~F
］
</li>
		</ul>
◎
If options is true or options is a dictionary whose selfOnly is false, the copy also includes the node’s descendants.
</dd>
	<dd>
%options の $ImportNodeOptions.customElementRegistry を利用して，
各~要素の $CustomElementRegistry を
— 要素が それを有さないならば —
設定できる。
◎
options’s customElementRegistry can be used to set the CustomElementRegistry of elements that have none.
</dd>
	<dd>
%node が［
`文書$／`~shadow根$
］である場合，
`NotSupportedError$E 例外が投出される。
◎
If node is a document or a shadow root, throws a "NotSupportedError" DOMException.
</dd>

	<dt>%node = %document . $adoptNode(node)</dt>
	<dd>
%node を他の`文書$から移動させた上で，それを返す。
◎
Moves node from another document and returns it.
</dd>
	<dd>
%node が`文書$である場合，
`NotSupportedError$E 例外が投出される。
◎
If node is a document, throws a "NotSupportedError" DOMException or,＼
</dd>
	<dd>
%node が`~shadow根$である場合，
`HierarchyRequestError$E 例外が投出される。
◎
if node is a shadow root, throws a "HierarchyRequestError" DOMException.
</dd>
</dl>

<div class="algo">
<p>
@importNode(node, options)
~method手続きは：
◎
The importNode(node, options) method steps are:
</p>
<ol>
	<li>
~IF［
%node は［
`文書$／`~shadow根$
］である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document or shadow root, then throw a "NotSupportedError" DOMException.
</li>
	<li>
%下位treeもか ~LET ~F
◎
Let subtree be false.
</li>
	<li>
%~registry ~LET ~NULL
◎
Let registry be null.
</li>
	<li>
~IF［
%options は真偽値である
］
⇒
%下位treeもか ~SET %options
◎
If options is a boolean, then set subtree to options.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%下位treeもか ~SET ~IS［
%options[ "$ImportNodeOptions.selfOnly" ] ~EQ ~F
］
◎
Set subtree to the negation of options["selfOnly"].
</li>
			<li>
%~registry ~SET %~option群[ "$ImportNodeOptions.customElementRegistry" ] ~DF ~NULL
◎
If options["customElementRegistry"] exists, then set registry to it.
</li>
			<li>
~IF［
%~registry の`視野~付きか$cR ~EQ ~F
］~AND［
%~registry ~NEQ コレの`~custom要素~registry$doc
］
⇒
~THROW `NotSupportedError$E
◎
If registry’s is scoped is false and registry is not this’s custom element registry, then throw a "NotSupportedError" DOMException.
</li>
		</ol>
	</li>
	<li>
~IF［
%~registry ~EQ ~NULL
］
⇒
%~registry ~SET `~custom要素~registryを検索する$( コレ )
◎
If registry is null, then set registry to the result of looking up a custom element registry given this.
</li>
	<li>
~RET `~nodeを~cloneする$( %node, %下位treeもか, コレ, ~NULL, %~registry )
◎
Return the result of cloning a node given node with document set to this, subtree set to subtree, and fallbackRegistry set to registry.
</li>
</ol>
</div>

<p>
`適用-可能な仕様$は、
すべてまたは一部の`~node$用に
`受入-時の手続き@
を定義してもヨイ。
この~algoは、
`~nodeを受入する$~algo内から，
( `~node$, `文書$ )
を渡して呼出される。
◎
Specifications may define adopting steps for all or some nodes. The algorithm is passed node and oldDocument, as indicated in the adopt algorithm.
</p>

<div class="algo">
<p>
`文書$ %文書 に
`~nodeを受入する@
~algoは、
所与の
( `~node$ %~node )
に対し：
◎
To adopt a node node into a document document:
</p>
<ol>
	<li>
%旧-文書 ~LET %~node の`~node文書$
◎
Let oldDocument be node’s node document.
</li>
	<li>
~IF［
%~node の`親$ ~NEQ ~NULL
］
⇒
`~nodeを除去する$( %~node )
◎
If node’s parent is non-null, then remove node.
</li>
	<li>
~IF［
%文書 ~EQ %旧-文書
］
⇒
~RET
◎
If document is not oldDocument:
</li>
	<li>
<p>
%~node の`~shadowも含めた広義-子孫$たちを成す
~EACH( %広義-子孫 )
に対し，`~shadowも含めた~tree順序$で
◎
For each inclusiveDescendant of node’s shadow-including inclusive descendants, in shadow-including tree order:
</p>
		<ol>
			<li>
%広義-子孫 の`~node文書$ ~SET %文書
◎
Set inclusiveDescendant’s node document to document.
</li>
			<li>
<p>
~IF［
%広義-子孫 は`~shadow根$である
］：
◎
If inclusiveDescendant is a shadow root and＼
</p>
				<ol>
					<li>
%~registry ~LET %広義-子孫 の`~custom要素~registry$sR
◎
↓</li>
					<li>
<p>
~IF［
~OR↓
］…
◎
• if any of the following are true:
</p>
						<ul>
							<li>
［
%~registry ~EQ ~NULL
］~AND［
%広義-子孫 の`~custom要素~registryを~NULLに保つか$sR ~EQ ~F
］
◎
• inclusiveDescendant’s custom element registry is null and inclusiveDescendant’s keep custom element registry null is false; or
</li>
							<li>
%~registry は`大域的$ceRである
◎
• inclusiveDescendant’s custom element registry is a global custom element registry,
</li>
						</ul>
<p>
…ならば
⇒
%広義-子孫 の`~custom要素~registry$sR ~SET `大域的な~custom要素~registryを取得する$( %文書 )
◎
• then set inclusiveDescendant’s custom element registry to document’s effective global custom element registry.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%広義-子孫 は`要素$である
］：
◎
• Otherwise, if inclusiveDescendant is an element:
</p>
				<ol>
					<li>
%~registry ~LET %広義-子孫 の`~custom要素~registry$el
◎
↓</li>
					<li>
%広義-子孫 の`属性o~list$elを成す
~EACH( %属性o )
に対し
⇒
%属性o の`~node文書$ ~SET %文書
◎
• Set the node document of each attribute in inclusiveDescendant’s attribute list to document.
</li>
					<li>
~IF［
%~registry ~EQ ~NULL
］~OR［
%~registry の`視野~付きか$cR ~EQ ~F
］
⇒
%広義-子孫 の`~custom要素~registry$el ~SET `大域的な~custom要素~registryを取得する$( %文書 )
◎
• If inclusiveDescendant’s custom element registry is null or inclusiveDescendant’s custom element registry’s is scoped is false, then set inclusiveDescendant’s custom element registry to document’s effective global custom element registry.
</li>
				</ol>
			</li> 
		</ol>
	</li>
	<li>
%~node の`~shadowも含めた広義-子孫$たちを成す
~EACH( %広義-子孫 )
に対し，`~shadowも含めた~tree順序$で
⇒
~IF［
%広義-子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義-子孫,
`adoptedCallback^l,
« %旧-文書, %文書 »
)
◎
• For each inclusiveDescendant of node’s shadow-including inclusive descendants that is custom, in shadow-including tree order:＼
enqueue a custom element callback reaction with inclusiveDescendant, callback name "adoptedCallback", and « oldDocument, document ».
</li>
	<li>
%~node の`~shadowも含めた広義-子孫$たちを成す
~EACH( %広義-子孫 )
に対し，`~shadowも含めた~tree順序$で
⇒
`適用-可能な仕様$にて %広義-子孫 用に`定義された各$( `受入-時の手続き$ %手続き )
に対し
⇒
%手続き( %広義-子孫, %旧-文書 )
◎
• For each inclusiveDescendant of node’s shadow-including inclusive descendants, in shadow-including tree order:＼
run the adopting steps with inclusiveDescendant and oldDocument.
</li>
</ol>
</div>

<div class="algo">
<p>
@adoptNode(node)
~method手続きは：
◎
The adoptNode(node) method steps are:
</p>
<ol>
	<li>
~IF［
%node は`文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
%node は`~shadow根$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a shadow root, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%node は`文書片$である
］~AND［
%node の`~host$ ~NEQ ~NULL
］
⇒
~RET
◎
If node is a DocumentFragment node whose host is non-null, then return.
</li>
	<li>
コレに`~nodeを受入する$( %node )
◎
Adopt node into this.
</li>
	<li>
~RET %node
◎
Return node.
</li>
</ol>
</div>

<hr>

<p>
所与の［
~NULL ／ $CustomElementRegistry ~obj
］ %~registry が
`大域的@ceR
（な~custom要素~registry）であるとは，次を満たすことをいう
⇒
［
%~registry ~NEQ ~NULL
］~AND［
%~registry の`視野~付きか$cR ~EQ ~F
］
◎
Null or a CustomElementRegistry object registry is a global custom element registry if registry is non-null and registry’s is scoped is false.
</p>

<p class="trans-note">【
この用語は、
~NULL にも適用-可能であることに注意。
】</p>

<div class="algo">
`大域的な~custom要素~registryを取得する@
~algoは、
所与の
( `文書$ %文書 )
に対し
⇒
~RET ［
%文書 の`~custom要素~registry$docは`大域的$ceRであるならば それ／
~ELSE_ ~NULL
］
◎
A document document’s effective global custom element registry is:
• If document’s custom element registry is a global custom element registry, then return document’s custom element registry.
• Return null.
</div>

<div class="algo">
<p>
@createAttribute(localName)
~method手続きは：
◎
The createAttribute(localName) method steps are:
</p>
<ol>
	<li>
~IF［
%localName は`妥当な属性~局所~名$でない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName is not a valid attribute local name, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~IF［
コレは`~HTML文書$である
］
⇒
%localName ~SET `~ASCII小文字~化する$( %localName )
◎
If this is an HTML document, then set localName to localName in ASCII lowercase.
</li>
	<li>
~RET 新たな`属性o$
— その
⇒＃
`局所~名$a ~SET %localName,
`~node文書$ ~SET コレ
◎
Return a new attribute whose local name is localName and node document is this.
</li>
</ol>
</div>

<div class="algo">
<p>
@createAttributeNS(namespace, qualifiedName)
~method手続きは：
◎
The createAttributeNS(namespace, qualifiedName) method steps are:
</p>
<ol>
	<li id="cp-validate-and-extract">
( %~ns, %接頭辞, %局所~名 ) ~LET `~nsと名前を検証して抽出する$( %namespace, %qualifiedName, `属性^i )
◎
Let (namespace, prefix, localName) be the result of validating and extracting namespace and qualifiedName given "attribute".
</li>
	<li>
~RET 新たな`属性o$
— その
⇒＃
`~ns$a ~SET %~ns,
`~ns接頭辞$a ~SET %接頭辞,
`局所~名$a ~SET %局所~名,
`~node文書$ ~SET コレ
◎
Return a new attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, and node document is this.
</li>
</ol>
</div>

<div class="algo">
<p>
@createEvent(interface)
~method手続きは：
◎
The createEvent(interface) method steps are:
</p>
<ol>
	<li>
%構築子 ~LET ~NULL
◎
Let constructor be null.
</li>
	<li>
<p>
~IF［
%interface は［
下の表tのいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］
⇒
%構築子 ~SET ［
合致した行の 2 列目の~interface
］の構築子
◎
If interface is an ASCII case-insensitive match for any of the strings in the first column in the following table, then set constructor to the interface in the second column on the same row as the matching string:
</p>

<table><thead>
<tr><th>
文字列
◎
String
<th>
~interface
◎
Interface
<th>
仕様（空欄はこの仕様）
◎
Notes
<tbody>

<tr><td>`beforeunloadevent^l
<td>$BeforeUnloadEvent
<td>`HTML$r

<tr><td>`compositionevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`customevent^l
<td>$CustomEvent
<td>

<tr><td>`devicemotionevent^l
<td>$DeviceMotionEvent
<td>`DEVICE-ORIENTATION$r

<tr><td>`deviceorientationevent^l
<td>$DeviceOrientationEvent
<td>同上

<tr><td>`dragevent^l
<td>$DragEvent
<td>`HTML$r

<tr><td>`event^l
<td>$Event
<td>

<tr><td>`events^l
<td>同上
<td>

<tr><td>`focusevent^l
<td>$FocusEvent
<td>`UIEVENTS$r

<tr><td>`hashchangeevent^l
<td>$HashChangeEvent
<td>`HTML$r

<tr><td>`htmlevents^l
<td>$Event
<td>

<tr><td>`keyboardevent^l
<td>$KeyboardEvent
<td>`UIEVENTS$r

<tr><td>`messageevent^l
<td>$MessageEvent
<td>`HTML$r

<tr><td>`mouseevent^l
<td>$MouseEvent
<td>`UIEVENTS$r

<tr><td>`mouseevents^l
<td>同上
<td>同上

<tr><td>`storageevent^l
<td>$StorageEvent
<td>`HTML$r

<tr><td>`svgevents^l
<td>$Event
<td>

<tr><td>`textevent^l
<td>$TextEvent
<td>`UIEVENTS$r

<tr><td>`touchevent^l
<td>$TouchEvent
<td>`TOUCH-EVENTS$r

<tr><td>`uievent^l
<td>$UIEvent
<td>`UIEVENTS$r

<tr><td>`uievents^l
<td>同上
<td>同上
</table>

	</li>
	<li>
~IF［
%構築子 ~EQ ~NULL
］
⇒
~THROW `NotSupportedError$E
◎
If constructor is null, then throw a "NotSupportedError" DOMException.
</li>
	<li>
<p>
~IF［
%構築子 が指示する~interfaceは，コレに`関連な大域~obj$に公開されていない
］
⇒
~THROW `NotSupportedError$E
◎
If the interface indicated by constructor is not exposed on the relevant global object of this, then throw a "NotSupportedError" DOMException.
</p>

<p class="note">注記：
概して~UAは、
環境設定によっては，~touch~eventの~supportを不能化する
— その場合、
この段が $TouchEvent ~interface用に誘発されることになる。
◎
Typically user agents disable support for touch events in some configurations, in which case this clause would be triggered for the interface TouchEvent.
</p>
	</li>
	<li>
%~event ~LET `~eventを作成する$( %構築子 )
◎
Let event be the result of creating an event given constructor.
</li>
	<li>
%~event の次に挙げる属性を初期化する
⇒＃
$Event.type ~SET 空~文字列,
$Event.timeStamp ~SET `現在の高分解能~時刻$( コレに`関連な大域~obj$ ),
$Event.isTrusted ~SET ~F
◎
Initialize event’s type attribute to the empty string.
◎
Initialize event’s timeStamp attribute to the result of calling current high resolution time with this’s relevant global object.
◎
Initialize event’s isTrusted attribute to false.
</li>
	<li>
%~event の`初期化-済みか$ev ~SET ~F
◎
Unset event’s initialized flag.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>

<p class="note">注記：
代わりに，`~event$構築子が利用されるべきである。
◎
Event constructors ought to be used instead.
</p>
</div>

<div class="algo">
<p>
@createRange()
~method手続きは
⇒
~RET 新たな`~live範囲o$
— その
⇒＃
`始端$ ~SET `境界点$( コレ, 0 ),
`終端$ ~SET `境界点$( コレ, 0 )
◎
The createRange() method steps are to return a new live range with (this, 0) as its start an end.
</p>

<p class="note">注記：
代わりに， $Range.Range() 構築子を利用できる。
◎
The Range() constructor can be used instead.
</p>
</div>

<div class="algo">
@createNodeIterator(root, whatToShow, filter)
~method手続きは
⇒
~RET `新たな~obj$( $NodeIterator )
— その
⇒＃
`根$tV ~SET %root,
`起点r$tV ~SET %root,
`起点rの直前か$tV ~SET ~T,
`~whatToShow$tV ~SET %whatToShow,
`~filter~callback$tV ~SET %filter
◎
The createNodeIterator(root, whatToShow, filter) method steps are:
• Let iterator be a new NodeIterator object.
• Set iterator’s root and iterator’s reference to root.
• Set iterator’s pointer before reference to true.
• Set iterator’s whatToShow to whatToShow.
• Set iterator’s filter to filter.
• Return iterator.
</div>

<div class="algo">
@createTreeWalker(root, whatToShow, filter)
~method手続きは
⇒
~RET `新たな~obj$( $TreeWalker )
— その
⇒＃
`根$tV ~SET %root,
`現-~node$tV ~SET %root,
`~whatToShow$tV ~SET %whatToShow,
`~filter~callback$tV ~SET %filter
◎
The createTreeWalker(root, whatToShow, filter) method steps are:
• Let walker be a new TreeWalker object.
• Set walker’s root and walker’s current to root.
• Set walker’s whatToShow to whatToShow.
• Set walker’s filter to filter.
• Return walker.
</div>

			<section id="interface-domimplementation">
<h4 title="Interface DOMImplementation">4.5.1. ^@DOMImplementation ~interface</h4>

<p>
~UAは、
`文書$ %文書 が作成されるときには，
$DOMImplementation ~objを作成して %文書 にそれを結付けるモノトスル。
◎
User agents must create a DOMImplementation object whenever a document is created and associate it with that document.
</p>

！！
[`Exposed$=Window]
interface @DOMImplementation {
  [`NewObject$] $DocumentType $createDocumentType($DOMString %name, $DOMString %publicId, $DOMString %systemId);
  [`NewObject$] $XMLDocument $createDocument($DOMString? %namespace, [`LegacyNullToEmptyString$] $DOMString %qualifiedName, optional $DocumentType? %doctype = null);
  [`NewObject$] $Document $createHTMLDocument(optional $DOMString title);

  $boolean $hasFeature(); // <span class="comment" id="cp-useless-true" title="useless; always returns true">無用の長物 — 常に ~T を返す</span>
};
！

<dl class="domintro">
	<dt>%doctype = %document . $Document.implementation . $createDocumentType(name, publicId, systemId)</dt>
	<dd>
所与の［
%name, %publicId, %systemId
］を伴う`~doctype$を返す。
◎
Returns a doctype, with the given name, publicId, and systemId.
</dd>
	<dd>
%name が`妥当な~doctype名$でない場合、
`InvalidCharacterError$E 例外が投出される。
◎
If name is not a valid doctype name, an "InvalidCharacterError" DOMException is thrown.
</dd>

	<dt>%doc = %document . $Document.implementation . $createDocument(namespace, qualifiedName [, doctype = null])</dt>
	<dd>
`局所~名$elが %qualifiedName で`~ns$elが %namespace
（ %qualifiedName が空~文字列でなければ）
の`文書~要素$を伴い，
%doctype が与えられていれば`~doctype$がそれに設定された
$XMLDocument を返す。
◎
Returns an XMLDocument, with a document element whose local name is qualifiedName and whose namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is given, as its doctype.
</dd>
	<dd>
この~methodは、
$Document.createElementNS() ~methodと同じ例外を，
( %namespace, %qualifiedName )
で呼出したときに投出する。
◎
This method throws the same exceptions as the createElementNS() method, when invoked with namespace and qualifiedName.
</dd>

	<dt>%doc = %document . $Document.implementation . $createHTMLDocument([title])</dt>
	<dd>
基本~構造が構築-済みな`~tree$を伴う`文書$を返す。
%title 引数が省略されていなければ `title$e 要素も含められる。
◎
Returns a document, with a basic tree already constructed including a title element, unless the title argument is omitted.
</dd>
</dl>

<div class="algo">
<p>
@createDocumentType(name, publicId, systemId)
~method手続きは：
◎
The createDocumentType(name, publicId, systemId) method steps are:
</p>
<ol>
	<li>
~IF［
%name は`妥当な~doctype名$でない
］
⇒
~THROW `InvalidCharacterError$E
◎
If name is not a valid doctype name, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
~RET 新たな`~doctype$
— その
⇒＃
`名前$dT ~SET %name,
`公な~ID$dT ~SET %publicId,
`~system~ID$dT ~SET %systemId,
`~node文書$ ~SET コレを結付けている`文書$
◎
Return a new doctype, with name as its name, publicId as its public ID, and systemId as its system ID, and with its node document set to the associated document of this.
</li>
</ol>
</div>

<div class="algo">
<p>
@createDocument(namespace, qualifiedName, doctype)
~method手続きは：
◎
The createDocument(namespace, qualifiedName, doctype) method steps are:
</p>
<ol>
	<li>
%文書 ~LET `新たな~obj$( $XMLDocument )
◎
Let document be a new XMLDocument.
</li>
	<li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>
	<li>
~IF［
%qualifiedName ~NEQ 空~文字列
］
⇒
%要素 ~SET `内部 createElementNS 手続き$( コレ, %namespace, %qualifiedName, 空な辞書 )
◎
If qualifiedName is not the empty string, then set element to the result of running the internal createElementNS steps, given document, namespace, qualifiedName, and an empty dictionary.
</li>
	<li>
~IF［
%doctype ~NEQ ~NULL
］
⇒
%文書 に`~nodeを付加する$( %doctype )
◎
If doctype is non-null, append doctype to document.
</li>
	<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%文書 に`~nodeを付加する$( %要素 )
◎
If element is non-null, append element to document.
</li>
	<li>
%文書 の`生成元$doc ~SET コレを結付けている`文書$の`生成元$doc
◎
document’s origin is this’s associated document’s origin.
</li>
	<li>
%文書 の`内容~型$doc ~SET %namespace に応じて
⇒＃
`~HTML~ns$ならば `application/xhtml+xml^c ／
`~SVG~ns$ならば `image/svg+xml^c ／
~ELSE_ `application/xml^c
◎
document’s content type is determined by namespace:
◎
HTML namespace
• application/xhtml+xml
SVG namespace
• image/svg+xml
Any other namespace
• application/xml
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="algo">
<p>
@createHTMLDocument(title)
~method手続きは：
◎
The createHTMLDocument(title) method steps are:
</p>
<ol>
	<li>
%文書 ~LET 新たな`文書$
— その
⇒＃
`種別$doc ~SET `html^l,
`内容~型$doc ~SET `text/html^l
◎
Let doc be a new document that is an HTML document.
◎
Set doc’s content type to "text/html".
</li>
	<li>
%~doctype ~LET 新たな`~doctype$
— その
⇒＃
`名前$dT ~SET `html^l,
`~node文書$ ~SET %文書
◎
Append a new doctype, with "html" as its name and with its node document set to doc, to doc.
</li>
	<li>
%文書 に`~nodeを付加する$( %~doctype )
◎
↑</li>
	<li>
`html 要素^V ~LET `要素を作成する$( %文書, `html^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, "html", and the HTML namespace, to doc.
</li>
	<li>
%文書 に`~nodeを付加する$( `html 要素^V )
◎
↑</li>
	<li>
`head 要素^V ~LET `要素を作成する$( %文書, `head^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, "head", and the HTML namespace, to the html element created earlier.
</li>
	<li>
`html 要素^V に`~nodeを付加する$( `head 要素^V )
◎
↑</li>
	<li>
<p>
~IF［
%title ~NEQ ε
］：
◎
If title is given:
</p>
		<ol>
			<li>
`title 要素^V ~LET `要素を作成する$( %文書, `title^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, "title", and the HTML namespace, to the head element created earlier.
</li>
			<li>
`head 要素^V に`~nodeを付加する$( `title 要素^V )
◎
↑</li>
			<li>
`title 要素^V に`~nodeを付加する$( `新たな~Text~node$( %title, %文書 ) )
◎
Append a new Text node, with its data set to title (which could be the empty string) and its node document set to doc, to the title element created earlier.
</li>
		</ol>
	</li>
	<li>
`html 要素^V に`~nodeを付加する$( `要素を作成する$( %文書, `body^l, `~HTML~ns$ ) )
◎
Append the result of creating an element given doc, "body", and the HTML namespace, to the html element created earlier.
</li>
	<li>
%文書 の`生成元$doc ~SET コレを結付けている`文書$の`生成元$doc
`HTML$r
◎
doc’s origin is this’s associated document’s origin.
</li>
	<li>
~RET %文書
◎
Return doc.
</li>
</ol>
</div>

<div class="algo">
<p>
@hasFeature()
~method手続きは
⇒
~RET ~T
◎
The hasFeature() method steps are to return true.
</p>

<p class="note">注記：
$hasFeature() は、
元々は，~UAが所与の~DOM特能の~supportを主張しているかどうかを報告するものであったが、
経験から，単に欲される［
~obj／属性／~method
］が存在するかどうか検査する用途には ほど遠いことが~~判明している。
そのようなわけで，それは もはや利用されないが、
古い~pageが働き続けられるよう存続している
（単に ~T を返す）。
◎
hasFeature() originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it is no longer to be used, but continues to exist (and simply returns true) so that old pages don’t stop working.
</p>
</div>

			</section>
		</section>
		<section id="interface-documenttype">
<h3 title="Interface DocumentType">4.6. ^@DocumentType ~interface</h3>

！！
[`Exposed$=Window]
interface @DocumentType : $Node {
  readonly attribute $DOMString $name;
  readonly attribute $DOMString $publicId;
  readonly attribute $DOMString $systemId;
};
！

<p>
$DocumentType `~node$は、
単に
`~doctype@
とも称される。
◎
DocumentType nodes are simply known as doctypes.
</p>

<div class="p">
<p>
各`~doctype$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`名前@dT
⇒
文字列
— 常に，`~doctype$の作成-時に与えられる。
</li>
	<li>
`公な~ID@dT
⇒
文字列
— `~doctype$の作成-時に明示的に与えられない限り，空~文字列とする。
</li>
	<li>
`~system~ID@dT
⇒
文字列
— `~doctype$の作成-時に明示的に与えられない限り，空~文字列とする。
</li>
</ul>

<p class="trans-note">【
“作成-時に…”
— 言い換えれば、
作成されて以降は変化しない。
】</p>

◎
Doctypes have an associated name, public ID, and system ID.
◎
When a doctype is created, its name is always given. Unless explicitly given when a doctype is created, its public ID and system ID are the empty string.
</div>

<div class="algo">
@name
取得子~手続きは
⇒
~RET コレの`名前$dT
◎
The name getter steps are to return this’s name.
</div>

<div class="algo">
@publicId
取得子~手続きは
⇒
~RET コレの`公な~ID$dT
◎
The publicId getter steps are to return this’s public ID.
</div>

<div class="algo">
@systemId
取得子~手続きは
⇒
~RET コレの`~system~ID$dT
◎
The systemId getter steps are to return this’s system ID.
</div>

		</section>
		<section id="interface-documentfragment">
<h3 title="Interface DocumentFragment">4.7. ^@DocumentFragment ~interface</h3>

！！
[`Exposed$=Window]
interface @DocumentFragment : $Node {
  `DocumentFragment$mc();
};
！

<p>
$DocumentFragment `~node$は、
単に
`文書片@
（ `document fragment^en ）とも称される。
【これは、この訳にて導入した非公式な用語である。】
</p>

<div class="p">
<p>
各`文書片$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~host@
⇒
~NULL ／ 異なる`~node~tree$内に在る`要素$
— 他が言明されない限り，~NULL とする。
</li>
</ul>
◎
A DocumentFragment node has an associated host (null or an element in a different node tree). It is null unless otherwise stated.
</div>

<p>
~obj %A が ~obj %B の
`~hostも含めた広義-先祖@
であるとは、［
~OR↓
］が満たされることをいう：
◎
An object A is a host-including inclusive ancestor of an object B, if either＼
</p>

<ul>
	<li>
%A は %B の`広義-先祖$である
◎
A is an inclusive ancestor of B, or＼
</li>
	<li>
%B の`根$の`~host$を %H とするとき，次が満たされる
⇒
［
%H ~NEQ ~NULL
］~AND［
%A は %H の`~hostも含めた広義-先祖$である
］
◎
if B’s root has a non-null host and A is a host-including inclusive ancestor of B’s root’s host.
</li>
</ul>

<p class="note">注記：
`文書片$の`~host$は，［
`~shadow根$, ~HTMLの `template$e 要素
］で有用になる概念であり、［
`~nodeを子の前に前挿入する$／`子を~nodeに置換する$
］~algoに影響iする。 
◎
The DocumentFragment node’s host concept is useful for HTML’s template element and for shadow roots, and impacts the pre-insert and replace algorithms.
</p>

<hr>

<dl class="domintro">
	<dt>%tree = $DocumentFragment()</dt>
	<dd>
新たな`文書片$を返す。
◎
Returns a new DocumentFragment node.
</dd>
</dl>

<div class="algo">
<p>
@DocumentFragment()
構築子~手続きは
⇒
コレの`~node文書$ ~SET `現在の大域~obj$に`結付けられた文書$
◎
The new DocumentFragment() constructor steps are to set this’s node document to current global object’s associated Document.
</div>

		</section>
		<section id="interface-shadowroot">
<h3 title="Interface ShadowRoot">4.8. ^@ShadowRoot ~interface</h3>

！！
[`Exposed$=Window]
interface @ShadowRoot : $DocumentFragment {
  readonly attribute $ShadowRootMode $mode;
  readonly attribute $boolean $delegatesFocus;
  readonly attribute $SlotAssignmentMode $slotAssignment;
  readonly attribute $boolean $clonable;
  readonly attribute $boolean $serializable;
  readonly attribute $Element $host;
  attribute $EventHandler $onslotchange;
};

enum @ShadowRootMode { `open@l, `closed@l };
enum @SlotAssignmentMode { `manual@l, `named@l };
！

<p>
$ShadowRoot ~nodeは、
単に
`~shadow根@
（ `shadow root^en ）とも称される。
◎
ShadowRoot nodes are simply known as shadow roots.
</p>

<p>
`~shadow根$の`~host$が ~NULL になることは決してない。
◎
Shadow roots’s associated host is never null.
</p>

<p>
各`~shadow根$には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`~mode@sR
⇒
$ShadowRootMode 値【！"open" or "closed"】
◎
Shadow roots have an associated mode ("open" or "closed").
</li>
	<li>
`~focusを委任するか@sR
⇒
真偽値
— 初期~時は ~F とする。
◎
Shadow roots have an associated delegates focus (a boolean). It is initially set to false.
</li>
	<li>
`要素の内部特能から可用か@sR
⇒
真偽値
— 初期~時は ~F とする。
◎
Shadow roots have an associated available to element internals (a boolean). It is initially set to false.
</li>
	<li>
`宣言的か@sR
⇒
真偽値
— 初期~時は ~F とする。
◎
Shadow roots have an associated declarative (a boolean). It is initially set to false.
</li>
	<li>
`~slot割当n~mode@sR
⇒
$SlotAssignmentMode 値【！("manual" or "named")】
◎
Shadow roots have an associated slot assignment ("manual" or "named").
</li>
	<li>
`~clone可能か@sR
⇒
真偽値
— 初期~時は ~F とする。
◎
Shadow roots have an associated clonable (a boolean). It is initially set to false.
</li>
	<li>
`直列化-可能か@sR
⇒
真偽値
— 初期~時は ~F とする。
◎
Shadow roots have an associated serializable (a boolean). It is initially set to false.
</li>
	<li>
`~custom要素~registry@sR
⇒
~NULL／ $CustomElementRegistry ~obj
— 初期~時は~NULLとする。
◎
Shadow roots have an associated custom element registry (null or a CustomElementRegistry object). It is initially null.
</li>
	<li>
<p>
`~custom要素~registryを~NULLに保つか@sR
⇒
真偽値
— 初期~時は ~F とする。
◎
Shadow roots have an associated keep custom element registry null (a boolean). It is initially false.
</p>

<p class="note">注記：
これが ~T をとり得るのは、
宣言的な~shadow根との組合nに限られる。
それが問われるのは、
`~shadow根$の`~custom要素~registry$sRが ~NULL をとる間に限られる。
◎
This can only ever be true in combination with declarative shadow roots. And it only matters for as long as the shadow root’s custom element registry is null.
</p>
	</li>
</ul>

<hr>

<div class="algo">
<p>
`~shadow根$ %根 の`親~targetを取得する$ときは、
所与の
( ~event %~event )
に対し：
◎
A shadow root’s get the parent algorithm, given an event,＼
</p>
<ol>
	<li>
~IF［
%~event の`~composedか$ev ~EQ ~F
］~AND［
%根 ~EQ ［［［
%~event の`経路$
］内の最初の構造体
］の`呼出n~target$evP
］の`根$
］
⇒
~RET ~NULL
◎
returns null if event’s composed flag is unset and shadow root is the root of event’s path’s first struct’s invocation target;＼
</li>
	<li>
~RET %根 の`~host$
◎
otherwise shadow root’s host.
</li>
</ol>
</div>

<hr>

<div class="algo">
@mode
取得子~手続きは
⇒
~RET コレの`~mode$sR
◎
The mode getter steps are to return this’s mode.
</div>

<div class="algo">
@delegatesFocus
取得子~手続きは
⇒
~RET コレの`~focusを委任するか$sR
◎
The delegatesFocus getter steps are to return this’s delegates focus.
</div>

<div class="algo">
@slotAssignment
取得子~手続きは
⇒
~RET コレの`~slot割当n~mode$sR
◎
The slotAssignment getter steps are to return this’s slot assignment.
</div>

<div class="algo">
@clonable
取得子~手続きは
⇒
~RET コレの`~clone可能か$sR
◎
The clonable getter steps are to return this’s clonable.
</div>

<div class="algo">
@serializable
取得子~手続きは
⇒
~RET コレの`直列化-可能か$sR
◎
The serializable getter steps are to return this’s serializable.
</div>

<div class="algo">
@host
取得子~手続きは
⇒
~RET コレの`~host$
◎
The host getter steps are to return this’s host.
</div>

<hr>

<p>
@onslotchange
は、
`onslotchange@c
`~event~handler$用の`~event~handler~IDL属性$である
— その`~event~handler~event型$は `slotchange$et とする。
◎
The onslotchange attribute is an event handler IDL attribute for the onslotchange event handler, whose event handler event type is slotchange.
</p>

<hr>

<p>
`~node~tree$ %~tree における
`~shadowも含めた~tree順序@
は、
`~shadowも含めた深優先前順な辿り@
による順序であり，次に従う
⇒
%~tree に対する深優先前順な辿り
【すなわち，通常の~tree順序】
に従いつつ，
%~tree において［
`~shadow~host$である`要素$ %要素
］に遭遇した各所では，［［
%要素 の`~shadow根$elを根とする`~node~tree$
］における，`~shadowも含めた深優先前順な辿り$
］に従う。
◎
In shadow-including tree order is shadow-including preorder, depth-first traversal of a node tree. Shadow-including preorder, depth-first traversal of a node tree tree is preorder, depth-first traversal of tree, with for each shadow host encountered in tree, shadow-including preorder, depth-first traversal of that element’s shadow root’s node tree just after it is encountered.
</p>

<p>
~obj %O の
`~shadowも含めた根@
とは、
%O の`根$を %根 とするとき，［
%根 は`~shadow根$であるならば %根 の`~host$の`~shadowも含めた根$ ／
~ELSE_ %根
］である。
◎
The shadow-including root of an object is its root’s host’s shadow-including root, if the object’s root is a shadow root; otherwise its root.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含めた子孫@
であるとは、
次が満たされることをいう
⇒
［
%A は %B の`子孫$である
］~OR［
%A の`根$は次を満たす
］
⇒
［
`~shadow根$である
］~AND［
その`~host$は %B の`~shadowも含めた広義-子孫$である
］
◎
An object A is a shadow-including descendant of an object B, if A is a descendant of B, or A’s root is a shadow root and A’s root’s host is a shadow-including inclusive descendant of B.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含めた広義-子孫@
であるとは、
次が満たされることをいう
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含めた子孫$である
］
◎
A shadow-including inclusive descendant is an object or one of its shadow-including descendants.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含めた先祖@
であるとは、
次が満たされることをいう
⇒
%B は %A の`~shadowも含めた子孫$である
◎
An object A is a shadow-including ancestor of an object B, if and only if B is a shadow-including descendant of A.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含めた広義-先祖@
であるとは、
次が満たされることをいう
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含めた先祖$である
］
◎
A shadow-including inclusive ancestor is an object or one of its shadow-including ancestors.
</p>

<p>
`~node$ %A が `~node$ %B からは
`閉な~shadowで非可視@
であるとは、
%A の`根$ %根 が ~AND↓ を満たすことをいう：
◎
A node A is closed-shadow-hidden from a node B if all of the following conditions are true:
</p>
<ul>
	<li>
%根 は`~shadow根$である
◎
A’s root is a shadow root.
</li>
	<li>
%根 は %B の`~shadowも含めた広義-先祖$でない
◎
A’s root is not a shadow-including inclusive ancestor of B.
</li>
	<li>
［
%根 の`~mode$sR ~EQ `closed^l
］~OR［
%根 の`~host$は %B からは`閉な~shadowで非可視$である
］
◎
A’s root is a shadow root whose mode is "closed" or A’s root’s host is closed-shadow-hidden from B.
</li>
</ul>

<div class="algo">
<p>
~obj %A を ~obj %B に向けて
`~targetし直す@
~algoは：
◎
To retarget an object A against an object B,＼
</p>
<ol>
	<li>
<p>
~WHILE 無条件：
◎
repeat these steps until they return an object:
</p>
		<ol>
			<li>
%根 ~LET %A の`根$
◎
↓</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
If one of the following is true
</p>
				<ul>
					<li>
%A は`~node$でない
◎
A is not a node
</li>
					<li>
%根 は`~shadow根$でない
◎
A’s root is not a shadow root
</li>
					<li>
［
%B は`~node$である
］~AND［
%根 は %B の`~shadowも含めた広義-先祖$である
］
◎
B is a node and A’s root is a shadow-including inclusive ancestor of B
</li>
				</ul>
<p>
…ならば
⇒
~RET %A
◎
then return A.
</p>
			</li>
			<li>
%A ~SET %根 の`~host$
◎
Set A to A’s root’s host.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
`~targetし直す$~algoは、
~eventの`配送-$時, および
`FULLSCREEN$r などの他の仕様により利用される。
◎
The retargeting algorithm is used by event dispatch as well as other specifications, such as Fullscreen. [FULLSCREEN]
</p>
</div>

		</section>
		<section id="interface-element">
<h3 title="Interface Element">4.9. ^@Element ~interface</h3>

！！
[`Exposed$=Window]
interface @Element : $Node {
  readonly attribute $DOMString? $namespaceURI;
  readonly attribute $DOMString? $prefix;
  readonly attribute $DOMString $localName;
  readonly attribute $DOMString $tagName;

  [`CEReactions$] attribute $DOMString $id;
  [`CEReactions$] attribute $DOMString $className;
  [`SameObject$, `PutForwards$=$DOMTokenList.value] readonly attribute $DOMTokenList $classList;
  [`CEReactions$, `Unscopable$] attribute $DOMString $slot;

  $boolean $hasAttributes();
  [`SameObject$] readonly attribute $NamedNodeMap $attributes;
  $sequence&lt;$DOMString&gt; $getAttributeNames();
  $DOMString? $getAttribute($DOMString %qualifiedName);
  $DOMString? $getAttributeNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $undefined $setAttribute($DOMString %qualifiedName, ($TrustedType or $DOMString) %value);
  [`CEReactions$] $undefined $setAttributeNS($DOMString? %namespace, $DOMString %qualifiedName, ($TrustedType or $DOMString) %value);
  [`CEReactions$] $undefined $removeAttribute($DOMString %qualifiedName);
  [`CEReactions$] $undefined $removeAttributeNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $boolean $toggleAttribute($DOMString %qualifiedName, optional $boolean %force);
  $boolean $hasAttribute($DOMString %qualifiedName);
  $boolean $hasAttributeNS($DOMString? %namespace, $DOMString %localName);

  $Attr? $getAttributeNode($DOMString %qualifiedName);
  $Attr? $getAttributeNodeNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $Attr? $setAttributeNode($Attr %attr);
  [`CEReactions$] $Attr? $setAttributeNodeNS($Attr %attr);
  [`CEReactions$] $Attr $removeAttributeNode($Attr %attr);

  $ShadowRoot $attachShadow($ShadowRootInit %init);
  readonly attribute $ShadowRoot? $shadowRoot;

  readonly attribute $CustomElementRegistry? $customElementRegistry;

  $Element? $closest($DOMString %selectors);
  $boolean $matches($DOMString %selectors);
  $boolean $webkitMatchesSelector($DOMString %selectors); // <span class="comment" title="legacy alias of .matches">$matches の旧来の別名</span>

  $HTMLCollection $getElementsByTagName($DOMString %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS($DOMString? %namespace, $DOMString %localName);
  $HTMLCollection $getElementsByClassName($DOMString %classNames);

  [`CEReactions$] $Element? $insertAdjacentElement($DOMString %where, $Element %element); // <!--cp-legacy-->
  $undefined $insertAdjacentText($DOMString %where, $DOMString %data); // <!--cp-legacy-->
};

dictionary @@ShadowRootInit {
  required $ShadowRootMode @mode;
  boolean @delegatesFocus = false;
  $SlotAssignmentMode @slotAssignment = `named^l;
  $boolean @clonable = false;
  $boolean @serializable = false;
  $CustomElementRegistry? @customElementRegistry;
};
！

<p class="note">注記：
$ShadowRootInit は、
いくぶん異例に，その $customElementRegistry ~memberに［
`undefined^jv, `null^jv
］どちらを渡すことも許容する
— ［
$Element.attachShadow() に【この】辞書の代わりに $ShadowRoot ~nodeを渡すこと
］も~web開発者に許容するため。
◎
ShadowRootInit somewhat unusually allows both undefined and null to be passed to its customElementRegistry member to allow web developers to pass a ShadowRoot node instead of a dictionary to attachShadow().
</p>

<p>
$@Element `~node$は、
単に
`要素@
（ `element^en ）とも称される。
◎
Element nodes are simply known as elements.
</p>

<p>
各`要素$には、
次に挙げるものが結付けられる
— いずれも，`要素を作成する$ときに初期化される：
◎
Elements have an associated:
</p>
<ul>
	<li>
`~ns@el
⇒
~NULL ／空でない文字列
◎
namespace
• Null or a non-empty string.
</li>
	<li>
`~ns接頭辞@el
⇒
~NULL ／空でない文字列
◎
namespace prefix
• Null or a non-empty string.
</li>
	<li>
`局所~名@el
⇒
空でない文字列
◎
local name
• A non-empty string.
</li>
	<li>
`~custom要素~registry@el
⇒
~NULL ／ $CustomElementRegistry ~obj
◎
custom element registry
• Null or a CustomElementRegistry object.
</li>
	<li>
`~custom要素~状態@el
⇒
次に挙げるいずれか
⇒＃
`undefined^l,
`failed^l,
`uncustomized^l,
`precustomized^l,
`custom^l
◎
custom element state
• "undefined", "failed", "uncustomized", "precustomized", or "custom".
</li>
	<li>
`~custom要素~定義@el
⇒
~NULL ／`~custom要素~定義$
◎
custom element definition
• Null or a custom element definition.
</li>
	<li>
`~is0値@el
⇒
~NULL／`妥当な~custom要素~名$
◎
is value
• Null or a valid custom element name.
◎
↑ When an element is created, all of these values are initialized.
</li>
</ul>

<div class="p">
<p>
所与の`要素$ %要素 に対し：
</p>
<ul>
	<li>
%要素 は
`定義-済み@
であるとは、
次が満たされることをいう
⇒
%要素 の`~custom要素~状態$el ~IN { `uncustomized^l, `custom^l }
</li>
	<li>
%要素 は
`~custom@
であるとは、
次が満たされることをいう
⇒
%要素 の`~custom要素~状態$el ~EQ `custom^l
</li>
</ul>
◎
An element whose custom element state is "uncustomized" or "custom" is said to be defined. An element whose custom element state is "custom" is said to be custom.
</div>

<p class="note">注記：
要素が`定義-済み$かどうかは、
`<code class="pseudo">:defined</code>＠~SELECTORS4#defined-pseudo$ 疑似類の挙動を決定するときに利用される。
要素が`~custom$かどうかは、
`変異~algo＠#mutation-algorithms$の挙動を決定するときに利用される。
状態［
`failed^l, `precustomized^l
］は、
`~custom要素~構築子$が［
初回に正しく実行することに失敗した場合
］に［
`要素を昇格する$とき，再び実行されない
］ことを確保するために利用される。
◎
Whether or not an element is defined is used to determine the behavior of the :defined pseudo-class. Whether or not an element is custom is used to determine the behavior of the mutation algorithms. The "failed" and "precustomized" states are used to ensure that if a custom element constructor fails to execute correctly the first time, it is not executed again by an upgrade.
</p>

<div class="example">
<p>
要素がとり得るこれら 4 種の状態を，次の~codeで~~説明する：
◎
The following code illustrates elements in each of these four states:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  window.customElements.define(
    "sw-rey",
    class extends HTMLElement {}
  );
  window.customElements.define(
    "sw-finn",
    class extends HTMLElement {},
    { extends: "p" }
  );
  window.customElements.define(
    "sw-kylo",
    class extends HTMLElement {
      constructor() {
        /* <span class="comment">
`super()^c は、
この例からは意図的に省略している。
◎
super() intentionally omitted for this example
</span> */
    }
  });
&lt;/script&gt;

&lt;!-- <span class="comment">
`undefined^l
（`定義-済み$でも`~custom$でもない）
◎
"undefined" (not defined, not custom)
</span> --&gt;
&lt;sw-han&gt;&lt;/sw-han&gt;
&lt;p is="sw-luke"&gt;&lt;/p&gt;
&lt;p is="asdf"&gt;&lt;/p&gt;

&lt;!-- <span class="comment">
`failed^l
（`定義-済み$でも`~custom$でもない）
◎
"failed" (not defined, not custom)
</span> --&gt;
&lt;sw-kylo&gt;&lt;/sw-kylo&gt;

&lt;!-- <span class="comment">
`uncustomized^l
（`定義-済み$だが`~custom$ではない）
◎
"uncustomized" (defined, not custom)
</span> --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;asdf&gt;&lt;/asdf&gt;

&lt;!-- <span class="comment">
`custom^l
（`定義-済み$かつ`~custom$である）
◎
"custom" (defined, custom)
</span> --&gt;
&lt;sw-rey&gt;&lt;/sw-rey&gt;
&lt;p is="sw-finn"&gt;&lt;/p&gt;
</pre>
</div>

<p>
各 `要素$には、
`~shadow根@el
も結付けられる：
◎
Elements also have an associated shadow root＼
</p>

<ul>
	<li>
それは，［
~NULL ／ `~shadow根$
］であり、
他が言明されない限り，~NULL とする。
◎
(null or a shadow root). It is null unless otherwise stated.＼
</li>
	<li>
<p>
~NULL でない場合、
当の`要素$は
`~shadow~host@
であるとされる。
</p>

<p class="trans-note">【
すなわち，要素は、［
`~shadow根$elを根とする ある`~shadow~tree$
］を~hostしている
— 言い換えれば、
ある`~shadow根$の`~host$である。
】</p>
◎
An element is a shadow host if its shadow root is non-null.
</li>
</ul>

<div class="algo">
<p>
`要素$ %要素 の
`有修飾~名@
は、
次の手続きの結果を返す：
</p>
<ol>
	<li>
%接頭辞 ~LET %要素 の`~ns接頭辞$el
</li>
	<li>
%局所~名 ~LET %要素 の`局所~名$el
</li>
	<li>
~IF［
%接頭辞 ~EQ ~NULL
］
⇒
~RET %局所~名
</li>
	<li>
~RET 次を順に`連結する$
⇒＃
%接頭辞,
`:^l,
%局所~名
</li>
</ol>
◎
An element’s qualified name is its local name if its namespace prefix is null; otherwise its namespace prefix, followed by ":", followed by its local name. 
</div>

<div class="algo">
<p>
`要素$ %要素 の
`~HTML大文字~化~有修飾~名@
は、
次の手続きの結果を返す：
◎
An element’s HTML-uppercased qualified name is the return value of these steps:
</p>
<ol>
	<li>
%有修飾~名 ~LET %要素 の`有修飾~名$
◎
Let qualifiedName be this’s qualified name.
</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
~RET `~ASCII大文字~化する$( %有修飾~名 )
◎
If this is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII uppercase.
</li>
	<li>
~RET %有修飾~名
◎
Return qualifiedName.
</li>
</ol>

<p class="note">注記：
~UAは、
`有修飾~名$と`~HTML大文字~化~有修飾~名$を内部~slotに格納して最適化することもできる。
◎
User agents could optimize qualified name and HTML-uppercased qualified name by storing them in internal slots.
</p>
</div>

<div class="algo">
<p>
`要素を作成する@
~algoは、
所与の
⇒＃
`文書$ %文書,
文字列 %局所~名,
［ ~NULL ／文字列 ］ %~ns,
文字列 %接頭辞 ~DF ~NULL,
文字列 %is ~DF ~NULL,
真偽値 %同期~custom要素か ~DF ~F,
［ ~NULL ／ $CustomElementRegistry ~obj ］ %~registry ~DF `default^l
◎終
に対し：
◎
To create an element, given a document document, string localName, string-or-null namespace, and optionally a string-or-null prefix (default null), string-or-null is (default null), boolean synchronousCustomElements (default false), and "default", null, or a CustomElementRegistry object registry (default "default"): 
</p>
<ol>
	<li>
%結果 ~LET ~NULL
◎
Let result be null.
</li>
	<li>
~IF［
%~registry ~EQ `default^l
］
⇒
%~registry ~SET `~custom要素~registryを検索する$( %文書 )
◎
If registry is "default", then set registry to the result of looking up a custom element registry given document.
</li>
	<li>
%定義 ~LET `~custom要素~定義を検索する$( %~registry, %~ns, %局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given registry, namespace, localName, and is.
</li>
	<li>
<p>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`名前$cD ~NEQ %定義 の`局所~名$cD
］（すなわち，%定義 は`~custom化された組込みの要素$を表現する）：
◎
If definition is non-null, and definition’s name is not equal to its local name (i.e., definition represents a customized built-in element):
</p>
		<ol>
			<li>
%~interface ~LET ( %局所~名, `~HTML~ns$ ) 用の`要素~interface$
◎
Let interface be the element interface for localName and the HTML namespace.
</li>
			<li>
%結果 ~SET `要素を内部的に作成する$( ↓ )
⇒＃
%文書,
%~interface,
%局所~名,
`~HTML~ns$,
%接頭辞,
`undefined^l,
%is,
%~registry
◎
Set result to the result of creating an element internal given document, interface, localName, the HTML namespace, prefix, "undefined", is, and registry.
</li>
			<li>
<p>
~IF［
%同期~custom要素か ~EQ ~T
］
⇒
`要素を昇格する$( %定義, %結果 )
◎
If synchronousCustomElements is true, then run this step while catching any exceptions:
• Upgrade result using definition.
</p>

<p>
この段から例外 %例外 が投出されたときは、
~catchして：
◎
If this step threw an exception exception:
</p>
				<ol>
					<li>
`例外を報告する$( %例外, %定義 の`構築子$cDに対応する~JS~objが`属する~realm$の`大域~obj$rM )
◎
Report exception for definition’s constructor’s corresponding JavaScript object’s associated realm’s global object.
</li>
					<li>
%結果 の`~custom要素~状態$el ~SET `failed^l
◎
Set result’s custom element state to "failed".
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`~custom要素~昇格~反応を~enqueueする$( %結果, %定義 )
◎
Otherwise, enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］~AND［
%同期~custom要素か ~EQ ~T
］：
◎
Otherwise, if definition is non-null:
• If synchronousCustomElements is true:
</p>
		<ol>
			<li>
%C ~LET %定義 の`構築子$cD
◎
Let C be definition’s constructor.
</li>
			<li>
`~surrounding~agent$にて`作動中な~custom要素~構築子~map$[ %C ] ~SET %~registry 
◎
Set the surrounding agent’s active custom element constructor map[C] to registry.
</li>
			<li>
<p>
この段から例外が投出されたときは、
~catchして，下の (A) に~~移行するとする：
◎
Run these steps while catching any exceptions:
</p>
				<ol>
					<li>
%結果 ~SET `~callback関数で構築する$( %C, 空な引数~list )
◎
Set result to the result of constructing C, with no arguments.
</li>
					<li>
~Assert：
%結果 の［
`~custom要素~状態$el, `~custom要素~定義$el
］は初期化-済みである
◎
Assert: result’s custom element state and custom element definition are initialized.
</li>
					<li>
<p>
~Assert：
%結果 の`~ns$el ~EQ `~HTML~ns$
◎
Assert: result’s namespace is the HTML namespace.
</p>

<p class="note">注記：
~IDLにより， %結果 は $HTMLElement ~objになるよう施行され、
そのような~objは，すべて`~HTML~ns$を利用する。
◎
IDL enforces that result is an HTMLElement object, which all use the HTML namespace.
</p>
					</li>
					<li>
<p>
~IF［
~OR↓
］…
</p>
						<ul>
							<li>
%結果 の`属性o~list$elは`空$でない
</li>
							<li>
%結果 の`子~群$は`空$でない
</li>
							<li>
%結果 の`親$ ~NEQ ~NULL
</li>
							<li>
%結果 の`~node文書$ ~NEQ %文書
</li>
							<li>
%結果 の`局所~名$el ~NEQ %局所~名
</li>
						</ul>
<p>
…ならば
⇒
~THROW `NotSupportedError$E
</p>
◎
If result’s attribute list is not empty, then throw a "NotSupportedError" DOMException.
◎
If result has children, then throw a "NotSupportedError" DOMException.
◎
If result’s parent is non-null, then throw a "NotSupportedError" DOMException.
◎
If result’s node document is not document, then throw a "NotSupportedError" DOMException.
◎
If result’s local name is not equal to localName, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 の
⇒＃
`~ns接頭辞$el ~SET %接頭辞,
`~is0値$el ~SET ~NULL,
`~custom要素~registry$el ~SET %~registry
◎
Set result’s namespace prefix to prefix.
◎
Set result’s is value to null.
◎
Set result’s custom element registry to registry.
</li>
				</ol>
<p>
(A)
— 上の手続きにて，例外 %例外 が投出されたときは：
◎
If any of these steps threw an exception exception:
</p>
				<ol>
					<li>
`例外を報告する$( %例外, %定義 の`構築子$cDに対応する~JS~objが`属する~realm$の`大域~obj$rM )
◎
Report exception for definition’s constructor’s corresponding JavaScript object’s associated realm’s global object.
</li>
					<li>
%結果 ~SET `要素を内部的に作成する$( ↓ )
⇒＃
%文書,
$HTMLUnknownElement,
%局所~名,
`~HTML~ns$,
%接頭辞, 
`failed^l,
~NULL,
%~registry
◎
Set result to the result of creating an element internal given document, HTMLUnknownElement, localName, the HTML namespace, prefix, "failed", null, and registry.
</li>
				</ol>
			</li>
			<li>
<p>
`~surrounding~agent$にて`作動中な~custom要素~構築子~map$[ %C ] ~SET ε
◎
Remove the surrounding agent’s active custom element constructor map[C].
</p>

<p class="note">注記：
通常の状況下では、
この~entryは，この時点ですでに除去-済み（ ε ）である。
◎
Under normal circumstances it will already have been removed at this point.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］：
◎
↑
◎
Otherwise:
</p>
		<ol>
			<li>
%結果 ~SET `要素を内部的に作成する$( ↓ )
⇒＃
%文書,
$HTMLElement,
%局所~名,
`~HTML~ns$,
%接頭辞,
`undefined^l,
~NULL,
%~registry
◎
Set result to the result of creating an element internal given document, HTMLElement, localName, the HTML namespace, prefix, "undefined", null, and registry.
</li>
			<li>
`~custom要素~昇格~反応を~enqueueする$( %結果, %定義 )
◎
Enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~interface ~LET ( %局所~名, %~ns ) 用の`要素~interface$
◎
Let interface be the element interface for localName and namespace.
</li>
			<li>
%結果 ~SET `要素を内部的に作成する$( ↓ )
⇒＃
%文書,
%~interface,
%局所~名,
%~ns,
%接頭辞,
`uncustomized^l,
%is,
%~registry
◎
Set result to the result of creating an element internal given document, interface, localName, namespace, prefix, "uncustomized", is, and registry.
</li>
			<li>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%~ns ~EQ `~HTML~ns$
</li>
					<li>
［
%局所~名 は`妥当な~custom要素~名$である
］~OR［
%is ~NEQ ~NULL
］
</li>
				</ul>
<p>
…ならば
⇒
%結果 の`~custom要素~状態$el ~SET `undefined^l
</p>
◎
If namespace is the HTML namespace, and either localName is a valid custom element name or is is non-null, then set result’s custom element state to "undefined".
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素を内部的に作成する@
~algoは、
所与の
⇒＃
`文書$ %文書,
要素~interface %~interface,
文字列 %局所~名,
［ ~NULL／ 文字列 ］ %~ns,
［ ~NULL／ 文字列 ］ %接頭辞,
文字列 %状態,
［ ~NULL／ 文字列 ］ %is,
［ ~NULL／ $CustomElementRegistry ~obj ］ %~registry
◎終
に対し：
◎
To create an element internal given a document document, an interface interface a string localName, a string-or-null namespace, a string-or-null prefix, a string state, a string-or-null is, and null or a CustomElementRegistry object registry:
</p>
<ol>
	<li>
%要素 ~LET `新たな~obj$( %~interface )
— その
⇒＃
`~ns$el ~SET %~ns,
`~ns接頭辞$el ~SET %接頭辞,
`局所~名$el ~SET %局所~名 ,
`~custom要素~registry$el ~SET %~registry ,
`~custom要素~状態$el ~SET %状態 ,
`~custom要素~定義$el ~SET ~NULL,
`~is0値$el ~SET %is,
`~node文書$ ~SET %文書
◎
Let element be a new element that implements interface, with namespace set to namespace, namespace prefix set to prefix, local name set to localName, custom element registry set to registry, custom element state set to state, custom element definition set to null, is value set to is, and node document set to document.
</li>
	<li>
~Assert：
%要素 の`属性o~list$elは`空$である
◎
Assert: element’s attribute list is empty.
</li>
	<li>
~RET %要素
◎
Return element.
</li>
</ol>
</div>

<p>
各`要素$は、
`属性o~list@el
も有する。
それは、
`~list$であり，
$NamedNodeMap
【~objを返す $attributes 属性】
を通して公開される。
`要素$の作成-時に明示的に与えられない限り，その`属性o~list$elは`空$とする。
◎
Elements also have an attribute list, which is a list exposed through a NamedNodeMap. Unless explicitly given when an element is created, its attribute list is empty.
</p>

<p>
`要素$ %要素 の`属性o~list$el内に`属性o$ %属性o が在ることを，
%要素 は %属性o を
`有する@
（ `has^en ）ともいう。
◎
An element has an attribute A if its attribute list contains A.
</p>

<p class="trans-note">【
この場合、［
%属性o が`属する要素$ ~EQ %要素
］も満たすことになる
— 複数の`要素$が同じ`属性o$を`有する$ことはない
（~algo内で同期的に遂行される ある瞬間を除いて）。
】【
“有する” という句は、
他の仕様（主に~HTML）で利用されている。
しかしながら，この訳では、
この用語を（この仕様~内では）利用せず，一律に`属性o~list$el（適用-可能な所では`属する要素$）を通して述べることにする。
】</p>

<p>
`適用-可能な仕様$は、
`要素$用に
`属性o変更-時の手続き@
を定義してもヨイ。
この~algoは、
当の要素に加えて，
( %局所~名, %旧-値, %値, %~ns )
を渡して呼出される。
◎
This and other specifications may define attribute change steps for elements. The algorithm is passed element, localName, oldValue, value, and namespace.
</p>

<div class="algo">
<p>
`属性o値の変化を取扱う@
~algoは、
所与の
( `属性o$ %属性o, %要素, %旧-値, %新-値 )
に対し：
◎
To handle attribute changes for an attribute attribute with element, oldValue, and newValue, run these steps:
</p>
<ol>
	<li>
%要素 用に種別 `attributes^l の`変異~記録を~queueする$( ↓ )
⇒＃
%属性o の`局所~名$a,
%属性o の`~ns$a,
%旧-値,
« »,
« »,
~NULL,
~NULL
◎
Queue a mutation record of "attributes" for element with attribute’s local name, attribute’s namespace, oldValue, « », « », null, and null.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$a, %旧-値, %新-値, %属性o の`~ns$a »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and « attribute’s local name, oldValue, newValue, attribute’s namespace ».
</li>
	<li>
`適用-可能な仕様$にて %要素 用に`定義された各$( `属性o変更-時の手続き$ %手続き )
に対し
⇒
%手続き( %属性o の`局所~名$a, %旧-値, %新-値, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, oldValue, newValue, and attribute’s namespace.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性o値を変更する@
~algoは、
所与の
( `属性o$ %属性o, %値 )
に対し：
◎
To change an attribute attribute to value, run these steps:
</p>
<ol>
	<li>
%旧-値 ~LET %属性o の`値$a
◎
Let oldValue be attribute’s value.
</li>
	<li>
%属性o の`値$a ~SET %値
◎
Set attribute’s value to value.
</li>
	<li>
`属性o値の変化を取扱う$( %属性o, %属性o が`属する要素$, %旧-値, %値 )
◎
Handle attribute changes for attribute with attribute’s element, oldValue, and value.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを付加する@
~algoは、
所与の
( `属性o$ %属性o, `要素$ %要素 )
に対し：
◎
To append an attribute attribute to an element element, run these steps:
</p>
<ol>
	<li>
%要素 の`属性o~list$elに %属性o を`付加する$
◎
Append attribute to element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET %要素
◎
Set attribute’s element to element.
</li>
	<li>
%属性o の`~node文書$ ~SET %要素 の`~node文書$
◎
Set attribute’s node document to element’s node document.
</li>
	<li>
`属性o値の変化を取扱う$( %属性o, %要素, ~NULL, %属性o の`値$a )
◎
Handle attribute changes for attribute with element, null, and attribute’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを除去する@
~algoは、
所与の
( `属性o$ %属性o )
に対し：
◎
To remove an attribute attribute, run these steps:
</p>
<ol>
	<li>
%要素 ~LET %属性o が`属する要素$
◎
Let element be attribute’s element.
</li>
	<li>
%要素 の`属性o~list$elから %属性o を`除去する$
◎
Remove attribute from element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET ~NULL
◎
Set attribute’s element to null.
</li>
	<li>
`属性o値の変化を取扱う$( %属性o, %要素, %属性o の`値$a, ~NULL )
◎
Handle attribute changes for attribute with element, attribute’s value, and null.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性oを置換する@
~algoは、
所与の
( `属性o$ %旧-属性o, `属性o$ %新-属性o )
に対し：
◎
To replace an attribute oldAttribute with an attribute newAttribute:
</p>
<ol>
	<li>
%要素 ~LET %旧-属性o が`属する要素$
◎
Let element be oldAttribute’s element.
</li>
	<li>
%要素 の`属性o~list$el内で，
%旧-属性o を %新-属性o に`置換する$
◎
Replace oldAttribute by newAttribute in element’s attribute list.
</li>
	<li>
%新-属性o が`属する要素$ ~SET %要素
◎
Set newAttribute’s element to element.
</li>
	<li>
%新-属性o の`~node文書$ ~SET %要素 の`~node文書$
◎
Set newAttribute’s node document to element’s node document.
</li>
	<li>
%旧-属性o が`属する要素$ ~SET ~NULL
◎
Set oldAttribute’s element to null.
</li>
	<li>
`属性o値の変化を取扱う$( %旧-属性o, %要素, %旧-属性o の`値$a, %新-属性o の`値$a )
◎
Handle attribute changes for oldAttribute with element, oldAttribute’s value, and newAttribute’s value.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを名前により取得する@
~algoは、
所与の
( 文字列 %有修飾~名 )
に対し：
◎
To get an attribute by name given a string qualifiedName and an element element:
</p>
<ol>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%有修飾~名 ~SET `~ASCII小文字~化する$( %有修飾~名 )
◎
If element is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
	<li>
~RET %要素 の`属性o~list$elを成す`属性o$のうち，次を満たす`最初のもの？$
⇒
`有修飾~名$a ~EQ %有修飾~名
◎
Return the first attribute in element’s attribute list whose qualified name is qualifiedName; otherwise null.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを~nsと局所~名により取得する@
~algoは、
所与の
( ［ 文字列 ／ ~NULL ］ %~ns, 文字列 %局所~名 )
に対し：
◎
To get an attribute by namespace and local name given null or a string namespace, a string localName, and an element element:
</p>
<ol>
	<!--cp-normalize-ns-->
	<li>
~RET %要素 の`属性o~list$elを成す`属性o$のうち，次を満たす`最初のもの？$
⇒
［
`~ns$a ~EQ %~ns
］~AND［
`局所~名$a ~EQ %局所~名
］
◎
Return the attribute in element’s attribute list whose namespace is namespace and local name is localName, if any; otherwise null.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性o値を取得する@
~algoは、
所与の
( 文字列 %局所~名, 文字列 %~ns ~DF ~NULL )
に対し：
◎
To get an attribute value given an element element, a string localName, and an optional null or string namespace (default null):
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %局所~名,  %~ns )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~RET ［
%属性o ~EQ ~NULL ならば空~文字列 ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, then return the empty string.
◎
Return attr’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを設定する@
~algoは、
所与の
( `属性o$ %属性o )
に対し：
◎
To set an attribute given an attribute attr and an element element:
</p>
<ol>
	<li>
%検証y-済みな値 ~LET `信用-済みな型に準拠な属性~値を取得する$( ↓ )
`TRUSTED-TYPES$r
⇒＃
%属性o の`局所~名$a,
%属性o の`~ns$a,
%要素,
%属性o の`値$a
◎
Let verifiedValue be the result of calling get trusted type compliant attribute value with attr’s local name, attr’s namespace, element, and attr’s value. [TRUSTED-TYPES]
</li>
	<li>
~IF［
%属性o が`属する要素$ ~NIN { ~NULL, %要素 }
］
⇒
~THROW `InUseAttributeError$E
◎
If attr’s element is neither null nor element, throw an "InUseAttributeError" DOMException.
</li>
	<li>
%旧-属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %属性o の`~ns$a, %属性o の`局所~名$a )
◎
Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local name, and element.
</li>
	<li>
~IF［
%旧-属性o ~EQ %属性o
］
⇒
~RET %属性o
◎
If oldAttr is attr, return attr.
</li>
	<li>
%属性o の`値$a ~SET %検証y-済みな値
◎
Set attr’s value to verifiedValue.
</li>
	<li>
~IF［
%旧-属性o ~NEQ ~NULL
］
⇒
`属性oを置換する$( %旧-属性o, %属性o )
◎
If oldAttr is non-null, then replace oldAttr with attr.
</li>
	<li>
~ELSE
⇒
`属性oを付加する$( %属性o, %要素 )
◎
Otherwise, append attr to element.
</li>
	<li>
~RET %旧-属性o
◎

Return oldAttr.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性o値を設定する@
~algoは、
所与の
⇒＃
文字列 %局所~名,
文字列 %値,
文字列 %接頭辞 ~DF ~NULL,
文字列 %~ns ~DF ~NULL
◎終
に対し：
◎
To set an attribute value given an element element, a string localName, a string value, an optional null or string prefix (default null), and an optional null or string namespace (default null):
</p>
<ol>
	<li>
%属性o ~LET %要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
Let attribute be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
<p>
~IF［
%属性o ~EQ ~NULL
］：
◎
If attribute is null,＼
</p>
		<ol>
			<li>
%属性o ~LET 新たな`属性o$
— その
⇒＃
`~ns$a ~SET %~ns,
`~ns接頭辞$a ~SET %接頭辞,
`局所~名$a ~SET %局所~名,
`値$a ~SET %値,
`~node文書$ ~SET %要素 の`~node文書$
◎
create an attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, value is value, and node document is element’s node document,＼
</li>
			<li>
`属性oを付加する$( %属性o, %要素 )
◎
then append this attribute to element,＼
</li>
			<li>
~RET
◎
and then return.
</li>
		</ol>
	</li>
	<li>
`属性o値を変更する$( %属性o, %値 )
◎
Change attribute to value.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを名前により除去する@
~algoは、
所与の
( 文字列 %有修飾~名 )
に対し：
◎
To remove an attribute by name given a string qualifiedName and an element element:
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを名前により取得する$( %有修飾~名 )
◎
Let attr be the result of getting an attribute given qualifiedName and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
`属性oを除去する$( %属性o )
◎
If attr is non-null, then remove attr.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素$ %要素 の
`属性oを~nsと局所~名により除去する@
~algoは、
所与の
( ［ 文字列 ／ ~NULL ］ %~ns, 文字列 %局所~名 )
に対し：
◎
To remove an attribute by namespace and local name given null or a string namespace, a string localName, and an element element:
</p>
<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
`属性oを除去する$( %属性o )
◎
If attr is non-null, then remove attr.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

<hr>

<p>
各 `要素$には、
`~ID@
が結付けられる
— それは、［
一意†な識別子を与える文字列 ／ ε ††
］であり，初期~時は ε とする。
◎
An element can have an associated unique identifier (ID)
</p>

<p class="trans-note">【†
この “一意” は、
文書~内で一意を意味する。
これは、
適合性の目的において，そう要求されることを意味する
— 不適合な文書においては、
複数個の要素が同じ`~ID$（ ~NEQ ε ）を伴い得る。
】【††
特定的には、
要素が `id^A `属性o$nmを有さないとき ε になる
（原文では， “~IDは無い”, “~IDを未設定にする” の様な句で表現されているが、
この訳では ε で表現する）。
】</p>

<p class="note">注記：
歴史的に，`要素$は複数個の識別子を有することもできていた
— 例えば、
~HTML `id^A `属性o$nmと DTD を利用して。
この仕様では、
`~ID$を~DOMの概念とし，
各`要素$に対し `id^A `属性o$nmで与えられる 1 個に限るとする。
◎
Historically elements could have multiple identifiers e.g., by using the HTML id attribute and a DTD. This specification makes ID a concept of the DOM and allows for only one per element, given by an id attribute.
</p>

<div class="algo">
<p>
`要素$ %要素 の`~ID$を更新するときは、
%要素 用の`属性o変更-時の手続き$として次を利用する
— それは、
所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
</p>
<ol>
	<li>
~IF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］
⇒
%要素 の`~ID$ ~SET ［
%値 ~IN { ~NULL, 空~文字列 } ならば ε ／
~ELSE_ %値
］
</li>
</ol>
◎
Use these attribute change steps to update an element’s ID:
• If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
• Otherwise, if localName is id, namespace is null, then set element’s ID to value.
</div>

<p class="note">注記：
この仕様は、
どの`要素$に対しても，その［
`id^A ／ `class^A ／ `slot^A
］`属性o$nm用の要件を定義しているが、
これらの属性oを利用をするかどうかは，適合性の要件にしていない。
◎
While this specification defines requirements for class, id, and slot attributes on any element, it makes no claims as to whether using them is conforming or not.
</p>

<hr>

<p>
`~node$ %N の
`親~要素@
とは、［
%N の`親$は`要素$であるならば それ ／
~ELSE_ ~NULL
］である。
◎
A node’s parent of type Element is known as its parent element. If the node has a parent of a different type, its parent element is null.
</p>

<hr>

<dl class="domintro">
	<dt>%namespace = %element . $namespaceURI</dt>
	<dd>
`~ns$elを返す。
◎
Returns the namespace.
</dd>

	<dt>%prefix = %element . $prefix</dt>
	<dd>
`~ns接頭辞$elを返す。
◎
Returns the namespace prefix.
</dd>

	<dt>%localName = %element . $localName</dt>
	<dd>
`局所~名$elを返す。
◎
Returns the local name.
</dd>

	<dt>%qualifiedName = %element . $tagName</dt>
	<dd>
`~HTML大文字~化~有修飾~名$を返す。
◎
Returns the HTML-uppercased qualified name.
</dd>
</dl>

<div class="algo">
@namespaceURI
取得子~手続きは
⇒
~RET コレの`~ns$el
◎
The namespaceURI getter steps are to return this’s namespace.
</div>

<div class="algo">
@prefix
取得子~手続きは
⇒
~RET コレの`~ns接頭辞$el
◎
The prefix getter steps are to return this’s namespace prefix.
</div>

<div class="algo">
@localName
取得子~手続きは
⇒
~RET コレの`局所~名$el
◎
The localName getter steps are to return this’s local name.
</div>

<div class="algo">
@tagName
取得子~手続きは
⇒
~RET コレの`~HTML大文字~化~有修飾~名$
◎
The tagName getter steps are to return this’s HTML-uppercased qualified name.
</div>

<hr>

<dl class="domintro">
	<dt>%element . $id [ = %value ]</dt>
	<dd>
%element の `id^A 属性oの値を返す。
設定して変更できる。
◎
Returns the value of element’s id content attribute. Can be set to change it.
</dd>

	<dt>%element . $className [ = %value  ]</dt>
	<dd>
%element の `class^A 属性oの値を返す。
設定して変更できる。
◎
Returns the value of element’s class content attribute. Can be set to change it.
</dd>

	<dt>%element . $classList</dt>
	<dd>
%element の `class^A 属性oを，空白で分離された~tokenたちが成す集合として
— $DOMTokenList ~objを通して —
操作できるようにする。
◎
Allows for manipulation of element’s class content attribute as a set of whitespace-separated tokens through a DOMTokenList object.
</dd>

	<dt>%element . $slot [ = %value  ]</dt>
	<dd>
%element の `slot^A 属性oを返す。
設定して変更できる。
◎
Returns the value of element’s slot content attribute. Can be set to change it.
</dd>
</dl>

<p>
所与の文字列 %名前 を
`反映する@
ように定義される~IDL属性は、
次の［
取得子~手続き, 設定子~手続き
］を有するモノトスル：
◎
IDL attributes that are defined to reflect a string name, must have these getter and setter steps:
</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレの`属性o値を取得する$( %名前 )
◎
getter steps
• Return the result of running get an attribute value given this and name.
</li>
	<li class="algo">
設定子~手続きは
⇒
コレの`属性o値を設定する$( %名前, 所与の値 )
◎
setter steps
• Set an attribute value for this using name and the given value.
</li>
</ul>

<p>
@id
属性は、
`id^l を`反映する$モノトスル。
◎
The id attribute must reflect "id".
</p>

<p>
@className
属性は、
`class^l を`反映する$モノトスル。
◎
The className attribute must reflect "class".
</p>

<div class="algo">
<p>
@classList
取得子~手続きは
⇒
~RET $DOMTokenList
— その
⇒＃
`要素$tL ~SET コレ,
`属性o名$tL ~SET ^class
◎
The classList getter steps are to return a DOMTokenList object whose associated element is this and whose associated attribute’s local name is class.＼
</p>

<p>
この取得子が返す $DOMTokenList ~objの`~token集合$tLは、
当の`要素$の
`~class群@
とも称される。
◎
The token set of this particular DOMTokenList object are also known as the element’s classes.
</p>

<p class="trans-note">【
[`SameObject$] が指定されているので、
各~要素と $DOMTokenList の各~instanceは，一対一に対応する。
】</p>
</div>

<p>
@slot
属性は、
`slot^l を`反映する$モノトスル。
◎
The slot attribute must reflect "slot".
</p>

<p class="note">注記：
［
`id^A ／ `class^A ／ `slot^A
］`属性o$nmは、
要素の~nsにかかわらず どの要素~上にも現れ得るので、
実質的に，（すべての~nsより）上位の大域~属性になる。
◎
id, class, and slot are effectively superglobal attributes as they can appear on any element, regardless of that element’s namespace.
</p>

<hr>

<dl class="domintro">
	<dt>%element . $hasAttributes()</dt>
	<dd>
［
%element の`属性o~list$elは`空$でないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if element has attributes; otherwise false.
</dd>

	<dt>%element . $getAttributeNames()</dt>
	<dd>
%element のすべての`属性o$の`有修飾~名$aを返す
— 重複を包含し得る。
◎
Returns the qualified names of all element’s attributes. Can contain duplicates.
</dd>

	<dt>%element . $getAttribute(qualifiedName)</dt>
	<dd>
%element の`属性o~list$elを成す`属性o$のうち，次を満たす`最初のもの？$を返す
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Returns element’s first attribute whose qualified name is qualifiedName, and null if there is no such attribute otherwise.
</dd>

	<dt>%element . $getAttributeNS(namespace, localName)</dt>
	<dd>
%element の`属性o~list$elを成す`属性o$のうち，次を満たす`最初のもの？$を返す
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Returns element’s attribute whose namespace is namespace and local name is localName, and null if there is no such attribute otherwise.
</dd>

	<dt>%element . $setAttribute(qualifiedName, value)</dt>
	<dd>
%element の`属性o~list$el内に次を満たす`属性o$は在るならば［
それらのうち最初のもの
］の`値$aを %value に設定する
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Sets the value of element’s first attribute whose qualified name is qualifiedName to value.
</dd>

	<dt>%element . $setAttributeNS(namespace, localName, value)</dt>
	<dd>
%element の`属性o~list$el内に次を満たす`属性o$は在るならば［
それらのうち最初のもの
］の`値$aを %value に設定する
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Sets the value of element’s attribute whose namespace is namespace and local name is localName to value.
</dd>

	<dt>%element . $removeAttribute(qualifiedName)</dt>
	<dd>
%element の`属性o~list$el内に次を満たす`属性o$は在るならば［
それらのうち最初のもの
］を %element から除去する
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Removes element’s first attribute whose qualified name is qualifiedName.
</dd>

	<dt>%element . $removeAttributeNS(namespace, localName)</dt>
	<dd>
%element の`属性o~list$el内に次を満たす`属性o$は在るならば［
それらのうち最初のもの
］を %element から除去する
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Removes element’s attribute whose namespace is namespace and local name is localName.
</dd>

	<dt>%element . $toggleAttribute(qualifiedName [, force])</dt>
	<dd>
<p>
%force に応じて：
</p>
		<ul>
			<li>
省略されているならば、
%qualifiedName の有無を “~toggleする”
— すなわち，それがすでに在るならば除去し，無いならば追加する。
</li>
			<li>
~T ならば、
%qualifiedName を追加する。
</li>
			<li>
~F ならば、
%qualifiedName を除去する。
</li>
		</ul>
<p>
その結果、
%qualifiedName が［
残っていれば ~T ／
無くなっていれば ~F
］を返す。
</p>

◎
If force is not given, "toggles" qualifiedName, removing it if it is present and adding it if it is not present. If force is true, adds qualifiedName. If force is false, removes qualifiedName.
◎
Returns true if qualifiedName is now present; otherwise false.
</dd>

	<dt>%element . $hasAttribute(qualifiedName)</dt>
	<dd>
%element の`属性o~list$el内に次を満たす`属性o$は［
在るならば ~T ／
無いならば ~F
］を返す
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Returns true if element has an attribute whose qualified name is qualifiedName; otherwise false.
</dd>

	<dt>%element . $hasAttributeNS(namespace, localName)</dt>
	<dd>
%element の`属性o~list$el内に次を満たす`属性o$は［
在るならば ~T ／
無いならば ~F
］を返す
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Returns true if element has an attribute whose namespace is namespace and local name is localName.
</dd>
</dl>

<div class="algo">
@hasAttributes()
~method手続きは
⇒
~RET ~IS［
コレの`属性o~list$elは`空$でない
］
◎
The hasAttributes() method steps are to return false if this’s attribute list is empty; otherwise true.
</div>

<div class="algo">
@attributes
取得子~手続きは
⇒
~RET コレに結付けられた $NamedNodeMap
◎
The attributes getter steps are to return the associated NamedNodeMap.
</div>

<div class="algo">
<p>
@getAttributeNames()
~method手続きは：
</p>
<ol>
	<li>
%結果 ~LET « »
</li>
	<li>
コレの`属性o~list$elを成す
~EACH( %属性o )
に対し
⇒
%結果 に %属性o の`有修飾~名$aを`付加する$
</li>
	<li>
~RET %結果
</li>
</ol>

<p class="note">注記：
名前が %結果 内で一意になることは保証されない。
</p>
◎
The getAttributeNames() method steps are to return the qualified names of the attributes in this’s attribute list, in order; otherwise a new list.
◎
These are not guaranteed to be unique.
</div>

<div class="algo">
<p>
@getAttribute(qualifiedName)
~method手続きは：
◎
The getAttribute(qualifiedName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET
コレの`属性oを名前により取得する$( %qualifiedName )
◎
Let attr be the result of getting an attribute given qualifiedName and this.
</li>
	<li>
~RET ［
%属性o ~EQ ~NULL ならば ~NULL ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, return null.
◎
Return attr’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
@getAttributeNS(namespace, localName)
~method手続きは：
◎
The getAttributeNS(namespace, localName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET
コレの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
Let attr be the result of getting an attribute given namespace, localName, and this.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If attr is null, return null.
</li>
	<li>
~RET %属性o の`値$a
◎
Return attr’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
@setAttribute(qualifiedName, value)
~method手続きは：
◎
The setAttribute(qualifiedName, value) method steps are:
</p>
<ol>
	<li>
<p id="cp-throw-if-non-xml-name">
~IF［
%qualifiedName は`妥当な属性~局所~名$でない
］
⇒
~THROW `InvalidCharacterError$E
◎
If qualifiedName is not a valid attribute local name, then throw an "InvalidCharacterError" DOMException.
</p>

<p class="note" id="node-setAttribute-qualifiedName">注記：
%qualifiedName と命名されてはいるが、
それは［
それを`有修飾~名$aに伴う`属性o$が すでに存在する場合
］に限り有修飾~名として利用される。
他の場合、
新たな属性oの`局所~名$aとして利用される。
それを検証する必要は、
後者の事例に限られる。
◎
Despite the parameter naming, qualifiedName is only used as a qualified name if an attribute already exists with that qualified name. Otherwise, it is used as the local name of the new attribute. We only need to validate it for the latter case.
</p>
	</li>
	<li id="cp-to-lowercase-if-html">
~IF［
コレは`~HTML~ns$に属する
］~AND［
コレの`~node文書$は`~HTML文書$である
］
⇒
%qualifiedName ~SET `~ASCII小文字~化する$( %qualifiedName )
◎
If this is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
	<li>
%検証y-済みな値 ~LET `信用-済みな型に準拠な属性~値を取得する$( ↓ )
`TRUSTED-TYPES$r
⇒＃
%qualifiedName,
~NULL,
コレ,
%値
◎
Let verifiedValue be the result of calling get trusted type compliant attribute value with qualifiedName, null, this, and value. [TRUSTED-TYPES]
</li>
	<li id="cp-first-attr-with-qname">
%属性o ~LET コレの`属性o~list$elを成す`属性o$のうち，次を満たす`最初のもの？$
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Let attribute be the first attribute in this’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒＃
`属性o値を変更する$( %属性o, %検証y-済みな値 )；
~RET
◎
If attribute is non-null, then change attribute to verifiedValue and return.
</li>
	<li>
%属性o ~LET 新たな`属性o$
— その
⇒＃
`局所~名$a ~SET %qualifiedName,
`値$a ~SET %検証y-済みな値,
`~node文書$ ~SET コレの`~node文書$
◎
Set attribute to a new attribute whose local name is qualifiedName, value is verifiedValue, and node document is this’s node document.
</li>
	<li>
`属性oを付加する$( %属性o, コレ )
◎
Append attribute to this.
</li>
</ol>
</div>

<div class="algo">
<p>
@setAttributeNS(namespace, qualifiedName, value)
~method手続きは：
◎
The setAttributeNS(namespace, qualifiedName, value) method steps are:
</p>
<ol>
	<!--cp-validate-and-extract-->
	<li>
%検証y-済みな値 ~LET `信用-済みな型に準拠な属性~値を取得する$( ↓ )
`TRUSTED-TYPES$r
⇒＃
%局所~名,
%~ns,
コレ,
%value
◎
Let verifiedValue be the result of calling get trusted type compliant attribute value with localName, namespace, this, and value. [TRUSTED-TYPES]
</li>
	<li>
コレの`属性o値を設定する$( %局所~名, %検証y-済みな値, %接頭辞, %~ns )
◎
Set an attribute value for this using localName, verifiedValue, prefix, and namespace.
</li>
</ol>
</div>

<div class="algo">
@removeAttribute(qualifiedName)
~method手続きは
⇒
コレの`属性oを名前により除去する$( %qualifiedName )
【！ ＊and then return undefined.】
◎
The removeAttribute(qualifiedName) method steps are to remove an attribute given qualifiedName and this, and then return undefined.
</div>

<div class="algo">
@removeAttributeNS(namespace, localName)
~method手続きは
⇒
コレの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
【！＊and then return undefined.】
◎
The removeAttributeNS(namespace, localName) method steps are to remove an attribute given namespace, localName, and this, and then return undefined.
</div>

<div class="algo">
<p>
@hasAttribute(qualifiedName)
~method手続きは：
◎
The hasAttribute(qualifiedName) method steps are:
</p>
		<ol>
			<!--cp-to-lowercase-if-html-->
			<li>
~RET ~IS［
コレの`属性o~list$el内に次を満たす`属性o$は在る
］
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Return true if this has an attribute whose qualified name is qualifiedName; otherwise false.
</li>
		</ol>
</div>

<div class="algo">
<p>
@toggleAttribute(qualifiedName, force)
~method手続きは：
◎
The toggleAttribute(qualifiedName, force) method steps are:
</p>
<ol>
	<li>
<!--cp-throw-if-non-xml-name-->

<p class="note">注記：
なぜ %qualifiedName を［
有修飾~名ではなく局所~名
］として検証するかについては、
`上の論点＠#node-setAttribute-qualifiedName$
を見よ。
◎
See the discussion above about why we validate it as a local name, instead of a qualified name.
</p>
	</li>
	<!--cp-to-lowercase-if-html-->
	<!--cp-first-attr-with-qname-->
	<li>
%結果 ~LET ~IS［
%force ~EQ ~T
］~OR［［
%force ~EQ ε
］~AND［
%属性o ~EQ ~NULL
］］
◎
↓</li>
	<li>
<p>
~IF［
%結果 ~EQ ~T
］~AND［
%属性o ~EQ ~NULL
］：
◎
If attribute is null:
</p>
		<ol>
			<li>
%属性o ~LET 新たな`属性o$
— その
⇒＃
`局所~名$a ~SET %qualifiedName,
`値$a ~SET 空~文字列,
`~node文書$ ~SET コレの`~node文書$
◎
↑If force is not given or is true,＼
create an attribute whose local name is qualifiedName, value is the empty string, and node document is this’s node document,＼
</li>
			<li>
`属性oを付加する$( %属性o, コレ )
◎
then append this attribute to this,＼
↓and then return true.
◎
↓Return false.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%結果 ~EQ ~F
］~AND［
%属性o ~NEQ ~NULL
］
⇒＃
コレの`属性oを名前により除去する$( %qualifiedName )；
◎
Otherwise, if force is not given or is false, remove an attribute given qualifiedName and this,＼
↓and then return false.
</li>
	<li>
~RET %結果
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
@hasAttributeNS(namespace, localName)
~method手続きは：
◎
The hasAttributeNS(namespace, localName) method steps are:
</p>
<ol>
	<!--cp-normalize-ns0-->
	<li>
~RET ~IS［
コレの`属性o~list$el内に次を満たす`属性o$は在る
］
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName
］
◎
Return true if this has an attribute whose namespace is namespace and local name is localName; otherwise false.
</li>
</ol>
</div>

<div class="algo">
@getAttributeNode(qualifiedName)
~method手続きは
⇒
~RET コレの`属性oを名前により取得する$( %qualifiedName )
◎
The getAttributeNode(qualifiedName) method steps are to return the result of getting an attribute given qualifiedName and this.
</div>

<div class="algo">
@getAttributeNodeNS(namespace, localName)
~method手続きは
⇒
~RET コレの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getAttributeNodeNS(namespace, localName) method steps are to return the result of getting an attribute given namespace, localName, and this.
</div>

<div class="algo">
@setAttributeNode(attr),
@setAttributeNodeNS(attr)
~method手続きは、
いずれも
⇒
~RET コレの`属性oを設定する$( %attr )
◎
The setAttributeNode(attr) and setAttributeNodeNS(attr) methods steps are to return the result of setting an attribute given attr and this.
</div>

<div class="algo">
<p>
@removeAttributeNode(attr)
~method手続きは：
◎
The removeAttributeNode(attr) method steps are:
</p>
<ol>
	<li>
~IF［
%attr ~NIN コレの`属性o~list$el
］
⇒
~THROW `NotFoundError$E
◎
If this’s attribute list does not contain attr, then throw a "NotFoundError" DOMException.
</li>
	<li>
`属性oを除去する$( %attr )
◎
Remove attr.
</li>
	<li>
~RET %attr
◎
Return attr.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%shadow = %element . $attachShadow(init)</dt>
	<dd>
%element 用に`~shadow根$を作成した上で，それを返す。
◎
Creates a shadow root for element and returns it.
</dd>

	<dt>%shadow = %element . $shadowRoot</dt>
	<dd>
%element の`~shadow根$el %~shadow は非~NULL，かつ %shadow の［
`~mode$sR ~EQ `open^l
］ならば %shadow を返す。
他の場合は ~NULL を返す。
◎
Returns element’s shadow root, if any, and if shadow root’s mode is "open"; otherwise null.
</dl>

<p>
次に挙げるものが，
`妥当な~shadow~host名@
であるとされる：
◎
A valid shadow host name is:
</p>
<ul>
	<li>
`妥当な~custom要素~名$
◎
a valid custom element name
</li>
	<li>
`article^l,
`aside^l,
`blockquote^l,
`body^l,
`div^l,
`footer^l,
`h1^l,
`h2^l,
`h3^l,
`h4^l,
`h5^l,
`h6^l,
`header^l,
`main^l,
`nav^l,
`p^l,
`section^l,
`span^l
◎
"article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", or "span"
</li>
</ul>

<div class="algo">
<p>
@attachShadow(init)
~method手続きは：
◎
The attachShadow(init) method steps are:
</p>
<ol>
	<li>
%文書~registry ~LET コレの`~node文書$の`~custom要素~registry$doc
◎
Let registry be this’s node document’s custom element registry.
</li>
	<li>
%~registry ~LET %init[ "$ShadowRootInit.customElementRegistry" ] ~DF %文書~registry
◎
If init["customElementRegistry"] exists, then set registry to it.
</li>
	<li>
~IF［
%~registry ~NIN { ~NULL, %文書~registry }
］~AND［
%~registry の`視野~付きか$cR ~EQ ~F
］
⇒
~THROW `NotSupportedError$E
◎
If registry is non-null, registry’s is scoped is false, and registry is not this’s node document’s custom element registry, then throw a "NotSupportedError" DOMException.
</li>
	<li>
`~shadow根を付する$( ↓ )
⇒＃
コレ,
%init[ "$ShadowRootInit.mode" ],
%init[ "$ShadowRootInit.clonable" ],
%init[ "$ShadowRootInit.serializable" ],
%init[ "$ShadowRootInit.delegatesFocus" ],
%init[ "$ShadowRootInit.slotAssignment" ],
%~registry
◎
Run attach a shadow root with this, init["mode"], init["clonable"], init["serializable"], init["delegatesFocus"], init["slotAssignment"], and registry.
</li>
	<li>
~RET コレの`~shadow根$el
◎
Return this’s shadow root.
</li>
</ol>
</div>

<div class="algo">
<p>
`~shadow根を付する@
~algoは、
所与の
⇒＃
`要素$ %要素,
文字列 %~mode,
真偽値 %~clone可能か,
真偽値 %直列化-可能か,
真偽値 %~focusを委任するか,
$SlotAssignmentMode 値【！文字列】 %~slot割当n~mode,
［ ~NULL／ $CustomElementRegistry ~obj ］ %~fallback~registry
◎終
に対し：
◎
To attach a shadow root, given an element element, a string mode, a boolean clonable, a boolean serializable, a boolean delegatesFocus, a string slotAssignment, and null or a CustomElementRegistry object registry:
</p>
<ol>
	<li>
~IF［
%要素 の`~ns$el ~NEQ `~HTML~ns$
］
⇒
~THROW `NotSupportedError$E
◎
If element’s namespace is not the HTML namespace, then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
%要素 の`局所~名$elは`妥当な~shadow~host名$でない
］
⇒
~THROW `NotSupportedError$E
◎
If element’s local name is not a valid shadow host name, then throw a "NotSupportedError" DOMException.
</li>
	<li>
<p>
~IF［
%要素 の`局所~名$elは`妥当な~custom要素~名$である
］~OR［
%要素 の`~is0値$el ~NEQ ~NULL
］：
◎
If element’s local name is a valid custom element name, or element’s is value is non-null:
</p>
		<ol>
			<li>
%定義 ~LET `~custom要素~定義を検索する$( ↓ )
⇒＃
%要素 の`~custom要素~registry$el,
%要素 の`~ns$el,
%要素 の`局所~名$el,
%要素 の`~is0値$el
◎
Let definition be the result of looking up a custom element definition given element’s custom element registry, its namespace, its local name, and its is value.
</li>
		<li>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`~shadowを不能化するか$cD ~EQ ~T
］
⇒
~THROW `NotSupportedError$E
◎
If definition is non-null and definition’s disable shadow is true, then throw a "NotSupportedError" DOMException.
</li>
		</ol>
	</li>
	<li>
%現在の~shadow根 ~LET %要素 の`~shadow根$el
◎
↓</li>
	<li>
<p>
~IF［
%現在の~shadow根 ~NEQ ~NULL【！`~shadow~host$である】
］：
◎
If element is a shadow host:
• Let currentShadowRoot be element’s shadow root.
</p>
		<ol>
			<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following are true:
</p>
				<ul>
					<li>
%現在の~shadow根 の`宣言的か$sR ~EQ ~F
◎
currentShadowRoot’s declarative is false; or
</li>
					<li>
%現在の~shadow根 の`~mode$sR ~NEQ %~mode
◎
currentShadowRoot’s mode is not mode,
</li>
				</ul>
<p>
…ならば
⇒
~THROW `NotSupportedError$E
◎
then throw a "NotSupportedError" DOMException.
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%現在の~shadow根 の`子~群$を成す
~EACH( %子 )
に対し【！`~tree順序$で】
⇒
`~nodeを除去する$( %子 )
◎
Remove all of currentShadowRoot’s children, in tree order.
</li>
					<li>
%現在の~shadow根 の`宣言的か$sR ~SET ~F
◎
Set currentShadowRoot’s declarative to false.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%要素の内部特能から可用か ~LET ~IS［
%要素 の`~custom要素~状態$el ~IN { `precustomized^l, `custom^l }
］
◎
↓</li>
	<li>
%要素 の`~shadow根$el ~SET `新たな~obj$( $ShadowRoot )
— その
⇒＃
`~node文書$ ~SET %要素 の`~node文書$,
`~host$ ~SET %要素,
`~mode$sR ~SET %~mode,
`~focusを委任するか$sR ~SET %~focusを委任するか,
`要素の内部特能から可用か$sR ~SET %要素の内部特能から可用か,
`~slot割当n~mode$sR ~SET %~slot割当n~mode,
`宣言的か$sR ~SET ~F,
`~clone可能か$sR ~SET %~clone可能か,
`直列化-可能か$sR ~SET %直列化-可能か,
`~custom要素~registry$sR ~SET %~registry
◎
Let shadow be a new shadow root whose node document is element’s node document, host is element, and mode is mode.
◎
Set shadow’s delegates focus to delegatesFocus.
◎
If element’s custom element state is "precustomized" or "custom", then set shadow’s available to element internals to true.
◎
Set shadow’s slot assignment to slotAssignment.
◎
Set shadow’s declarative to false.
◎
Set shadow’s clonable to clonable.
◎
Set shadow’s serializable to serializable.
◎
Set shadow’s custom element registry to registry.
◎
Set element’s shadow root to shadow.
</li>
</ol>
</div>

<div class="algo">
<p>
@shadowRoot
取得子~手続きは：
◎
The shadowRoot getter steps are:
</p>
<ol>
	<li>
%~shadow ~LET コレの`~shadow根$el
◎
Let shadow be this’s shadow root.
</li>
	<li>
~IF［
%~shadow ~EQ ~NULL
］~OR［
%~shadow の`~mode$sR ~EQ `closed^l
］
⇒
~RET ~NULL
◎
If shadow is null or its mode is "closed", then return null.
</li>
	<li>
~RET %~shadow
◎
Return shadow.
</li>
</ol>
</div>

<hr>

<dl class="domintro">
	<dt>%registry = %element . $customElementRegistry</dt>
	<dd>
%要素 は $CustomElementRegistry ~objを［
有するならば それ ／
有さないならば ~NULL
］を返す。
◎
Returns element’s CustomElementRegistry object, if any; otherwise null.
</dd>
</dl>

<div class="algo">
@customElementRegistry
取得子~手続きは
⇒
~RET コレの`~custom要素~registry$el
◎
The customElementRegistry getter steps are to return this’s custom element registry.
</div>

<hr>

<dl class="domintro">
	<dt>%element . $closest(selectors)</dt>
	<dd>
%element の`広義-先祖$のうち, %selectors に合致する`要素$は［
在るならば，それらのうち %element に最も近いもの／
無いならば ~NULL
］を返す。
◎
Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.
</dd>

	<dt>%element . $matches(selectors)</dt>
	<dd>
%element の`根$に対し %selectors を照合した結果，［
%element が得られるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if matching selectors against element’s root yields element; otherwise false.
</dd>
</dl>

<div class="algo">
<p>
@closest(selectors)
~method手続きは：
◎
The closest(selectors) method steps are:
</p>
<ol>
	<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let selector be the result of parse a selector from selectors. [SELECTORS4]
</li>
	<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If selector is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
%要素 ~LET コレ
◎
↓</li>
	<li>
<p>
~WHILE［
%要素 は`要素$である
］：
</p>
		<ol>
			<li>
~IF［
`要素に対し選択子を照合する$( %要素, %選択子, `視野ng根$たちが成す集合 { コレ } ) ~EQ `成功^i
`SELECTORS4$r
］
⇒
~RET %要素
</li>
			<li>
%要素 ~SET %要素 の`親$
</li>
		</ol>
◎
Let elements be this’s inclusive ancestors that are elements, in reverse tree order.
◎
For each element of elements:＼
if match a selector against an element, using selector, element, and scoping root this, returns success, return element. [SELECTORS4]
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
@matches(selectors)
~method手続きは：
◎
The matches(selectors) and webkitMatchesSelector(selectors) method steps are:
</p>
<ol>
	<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let selector be the result of parse a selector from selectors. [SELECTORS4]
</li>
	<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If selector is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET ~IS［
次の結果 ~EQ `成功^i
］
⇒
`要素に対し選択子を照合する$( コレ, %選択子, `視野ng根$たちが成す集合 { コレ } )
`SELECTORS4$r
◎
If the result of match a selector against an element, using selector, this, and scoping root this, returns success, then return true; otherwise, return false. [SELECTORS4]
</li>
</ol>
</div>

<p>
@webkitMatchesSelector(selectors)
~method手続きは、
$matches() ~method手続きと同じにふるまう。
◎
↑</p>

<div class="algo">
@getElementsByTagName(qualifiedName)
~method手続きは
⇒
~RET コレ用の［
%qualifiedName を`有修飾~名に持つ要素の~list$
］
◎
The getElementsByTagName(qualifiedName) method steps are to return the list of elements with qualified name qualifiedName for this.
</div>

<div class="algo">
@getElementsByTagNameNS(namespace, localName)
~method手続きは
⇒
~RET コレ用の［
( %namespace, %localName ) を
`( ~ns, 局所~名 ) に持つ要素の~list$
］
◎
The getElementsByTagNameNS(namespace, localName) method steps are to return the list of elements with namespace namespace and local name localName for this.
</div>

<div class="algo">
@getElementsByClassName(classNames)
~method手続きは
⇒
~RET コレ用の［
%classNames を`~class群に含む要素の~list$
］
◎
The getElementsByClassName(classNames) method steps are to return the list of elements with class names classNames for this.
</div>

<hr>

<div class="algo">
<p>
`要素$ %要素 の
`隣に~nodeを挿入する@
~algoは、
所与の
( 文字列 %where, `~node$ %~node )
に対し：
◎
To insert adjacent, given an element element, string where, and a node node,＼
</p>
<ol>
	<li>
%where ~SET `~ASCII小文字~化する$( %where )
◎
↓</li>
	<li>
<p>
%where に応じて：
◎
run the steps associated with the first ASCII case-insensitive match for where:
</p>
		<ul class="switch">
			<li>
<p>
`beforebegin^l
⇒
◎
"beforebegin"
</p>
				<ol>
					<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
					<li>
~RET
%要素 の`親$の中で`~nodeを子の前に前挿入する$( %~node, %要素 )
◎
Return the result of pre-inserting node into element’s parent before element.
</li>
				</ol>
			</li>

			<li>
`afterbegin^l
⇒
~RET
%要素 の中で`~nodeを子の前に前挿入する$( %~node, %要素 の`最初の子？$ )
◎
"afterbegin"
• Return the result of pre-inserting node into element before element’s first child.
</li>
			<li>
`beforeend^l
⇒
~RET
%要素 の中で`~nodeを子の前に前挿入する$( %~node, ~NULL )
◎
"beforeend"
• Return the result of pre-inserting node into element before null.
</li>
			<li>
<p>
`afterend^l：
◎
"afterend"
</p>
				<ol>
					<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
					<li>
~RET
%要素 の`親$の中で`~nodeを子の前に前挿入する$( %~node, %要素 の`直後の同胞？$ )
◎
Return the result of pre-inserting node into element’s parent before element’s next sibling.
</li>
				</ol>
			</li>
			<li>
その他
⇒
~THROW `SyntaxError$E
◎
Otherwise
• Throw a "SyntaxError" DOMException.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
@insertAdjacentElement(where, element)
~method手続きは
⇒
~RET %element の`隣に~nodeを挿入する$( %where, コレ )
◎
The insertAdjacentElement(where, element) method steps are to＼
return the result of running insert adjacent, give this, where, and element.
</div>

<div class="algo">
<p>
@insertAdjacentText(where, data)
~method手続きは：
◎
The insertAdjacentText(where, data) method steps are:
</p>
<ol>
	<li>
%text ~LET `新たな~Text~node$( %data, コレの`~node文書$ )
◎
Let text be a new Text node whose data is data and node document is this’s node document.
</li>
	<li>
コレの`隣に~nodeを挿入する$( %where, %text  )
◎
Run insert adjacent, given this, where, and text.
</li>
</ol>

<p class="note">注記：
この~methodは何も返さない
— それを設計する機会cを得る前からすでに存在していたので。
◎
This method returns nothing because it existed before we had a chance to design it.
</p>
</div>

<p class="trans-note">【
参考：
`insertAdjacentHTML()＠~HTMLdynamic#dom-element-insertadjacenthtml$m という類似な便利~methodもある。
】</p>

			<section id="interface-namednodemap">
<h4 title="Interface NamedNodeMap">4.9.1. ^@NamedNodeMap ~interface</h4>

！！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @NamedNodeMap {
  readonly attribute `unsigned long$ $length;
  getter $Attr? $item(`unsigned long$ %index);
  getter $Attr? $getNamedItem($DOMString %qualifiedName);
  $Attr? $getNamedItemNS($DOMString? %namespace, $DOMString %localName);
  [`CEReactions$] $Attr? $setNamedItem($Attr %attr);
  [`CEReactions$] $Attr? $setNamedItemNS($Attr %attr);
  [`CEReactions$] $Attr $removeNamedItem($DOMString %qualifiedName);
  [`CEReactions$] $Attr $removeNamedItemNS($DOMString? %namespace, $DOMString %localName);
};
！

<div class="p">
<p>
各 $NamedNodeMap ~objには、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`要素@nm
⇒
`要素$。
</li>
</ul>
◎
A NamedNodeMap has an associated element (an element).
</div>

<p>
$NamedNodeMap ~obj %O の
`属性o~list@nm
は、
%O の`要素$nmの`属性o~list$elを指す。
◎
A NamedNodeMap object’s attribute list is its element’s attribute list.
</p>

<hr>

<p>
$NamedNodeMap ~obj %O が`~supportする~prop~index$は、
0 以上［
%O の`属性o~list$nmの`~size$
］未満とする。
◎
A NamedNodeMap object’s supported property indices are the numbers in the range zero to its attribute list’s size − 1, unless the attribute list is empty, in which case there are no supported property indices.
</p>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレの`属性o~list$nmの`~size$
◎
The length getter steps are to return the attribute list’s size.
</div>

<div class="algo">
@item(index)
~method手続きは
⇒
~RET ［
%index ~NIN { コレが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_ コレの`属性o~list$nm[ %index ]
］
◎
The item(index) method steps are:
• If index is equal to or greater than this’s attribute list’s size, then return null.
• Otherwise, return this’s attribute list[index].
</div>

<div class="algo">
<p>
$NamedNodeMap ~obj %O が`~supportする~prop名$たちは、
次の手続きの結果で与えられる：
◎
A NamedNodeMap object’s supported property names are the return value of running these steps:
</p>
<ol>
	<li>
%名前~群 ~LET %O の`属性o~list$nm 内の各［
`属性o$の`有修飾~名$a
］たちが成す，同順の~list
◎
Let names be the qualified names of the attributes in this NamedNodeMap object’s attribute list, with duplicates omitted, in order.
</li>
	<li>
%要素 ~LET %O の`要素$nm
◎
↓</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%名前~群 を成す
~EACH( %名前 )
に対し
⇒
~IF［
`~ASCII小文字~化する$( %名前 ) ~NEQ %名前
］
⇒
%名前 を %名前~群 から除去する
◎
If this NamedNodeMap object’s element is in the HTML namespace and its node document is an HTML document, then for each name of names:
• Let lowercaseName be name, in ASCII lowercase.
• If lowercaseName is not equal to name, remove name from names.
</li>
	<li>
~RET %名前~群
◎
Return names.
</li>
</ol>
</div>

<div class="algo">
@getNamedItem(qualifiedName)
~method手続きは
⇒
~RET コレの`要素$nmの`属性oを名前により取得する$( %qualifiedName )
◎
The getNamedItem(qualifiedName) method steps are to return the result of getting an attribute given qualifiedName and element.
</div>

<div class="algo">
@getNamedItemNS(namespace, localName)
~method手続きは
⇒
~RET コレの`要素$nmの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getNamedItemNS(namespace, localName) method steps are to return the result of getting an attribute given namespace, localName, and element.
</div>

<div class="algo">
@setNamedItem(attr),
@setNamedItemNS(attr)
~method手続きは：
⇒
~RET コレの`要素$nmの`属性oを設定する$( %attr )
◎
The setNamedItem(attr) and setNamedItemNS(attr) method steps are to return the result of setting an attribute given attr and element.
</div>

<div class="algo">
<p>
@removeNamedItem(qualifiedName)
~method手続きは：
◎
The removeNamedItem(qualifiedName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET コレの`要素$nmの`属性oを名前により除去する$( %qualifiedName )
◎
Let attr be the result of removing an attribute given qualifiedName and element.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a "NotFoundError" DOMException.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

<div class="algo">
<p>
@removeNamedItemNS(namespace, localName)
~method手続きは：
◎
The removeNamedItemNS(namespace, localName) method steps are:
</p>
<ol>
	<li>
%属性o ~LET
コレの`要素$nmの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
◎
Let attr be the result of removing an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a "NotFoundError" DOMException.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>
</div>

			</section>
			<section id="interface-attr">
<h4 title="Interface Attr">4.9.2. ^@Attr ~interface</h4>

！！
[`Exposed$=Window]
interface @Attr : $Node {
  readonly attribute $DOMString? $namespaceURI;
  readonly attribute $DOMString? $prefix;
  readonly attribute $DOMString $localName;
  readonly attribute $DOMString $name;
  [`CEReactions$] attribute $DOMString $value;

  readonly attribute Element? $ownerElement;

  readonly attribute $boolean $specified; // <!--cp-useless-true-->
};
！

<p>
$Attr `~node$は、
単に
`属性o@
（ `attribute^en ）とも称される
— ~IDL属性と区別するため、
内容~属性とも称される。
【この訳では， “°” を付けて “属性o” と記すことにする。】
◎
Attr nodes are simply known as attributes. They are sometimes referred to as content attributes to avoid confusion with IDL attributes.
</p>

<div class="p">
<p>
各`属性o$は、
次に挙げるものを有する：
</p>
<ul>
	<li>
`~ns@a
⇒
~NULL ／空でない文字列
</li>
	<li>
`~ns接頭辞@a
⇒
~NULL ／空でない文字列
</li>
	<li>
`局所~名@a
⇒
空でない文字列
</li>
	<li>
`値@a
⇒
文字列
</li>
	<li>
<p>
`属する要素@
⇒
~NULL ／`要素$
</p>
<p class="trans-note">【
~NULL でないならば、
当の属性oは要素の`属性o~list$el内に在ることになる。
】</p>
	</li>
</ul>
◎
Attributes have a namespace (null or a non-empty string), namespace prefix (null or a non-empty string), local name (a non-empty string), value (a string), and element (null or an element).
</div>

<p class="note">注記：
今 設計するなら、［
名前, 値
］だけを有するようにする所 ☹
◎
If designed today they would just have a name and value. ☹
</p>

<p>
`属性o$ %属性o の
`有修飾~名@a
は、
%属性o の`~ns接頭辞$a %接頭辞 に応じて［
~NULL ならば %属性o の`局所~名$a ／
~ELSE_ 次の並びになる
］
⇒＃
%接頭辞,
`:^l,
%属性o の`局所~名$a
◎
An attribute’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<p class="note">注記：
~UAは、
これを内部~slotに持たせて最適化することもできる。
◎
User agents could have this as an internal slot as an optimization.
</p>

<p>
`属性o$の`局所~名$aは、
当の属性oの作成-時に与えられる。
他のものは、
当の属性oの作成-時に明示的に与えられない限り，次のように設定される
⇒＃
`~ns$a ~SET ~NULL,
`~ns接頭辞$a ~SET ~NULL,
`属する要素$ ~SET ~NULL,
`値$a ~SET 空~文字列
◎
When an attribute is created, its local name is given. Unless explicitly given when an attribute is created, its namespace, namespace prefix, and element are set to null, and its value is set to the empty string.
</p>

<p>
%A
`属性o@nm
という~~表記は、
所与の文字列 %A に対し，次を満たす`属性o$であることをいう
⇒
( `局所~名$a, `~ns$a, `~ns接頭辞$a )
~EQ
( %A, ~NULL, ~NULL )
◎
An A attribute is an attribute whose local name is A and whose namespace and namespace prefix are null.
</p>

<hr>

<div class="algo">
@namespaceURI
取得子~手続きは
⇒
~RET コレの`~ns$a
◎
The namespaceURI getter steps are to return this’s namespace.
</div>

<div class="algo">
@prefix
取得子~手続きは
⇒
~RET コレの`~ns接頭辞$a
◎
The prefix getter steps are to return this’s namespace prefix.
</div>

<div class="algo">
@localName
取得子~手続きは
⇒
~RET コレの`局所~名$a
◎
The localName getter steps are to return this’s local name.
</div>

<div class="algo">
@name
取得子~手続きは
⇒
~RET コレの`有修飾~名$a
◎
The name getter steps are to return this’s qualified name.
</div>

<div class="algo">
@value
取得子~手続きは
⇒
~RET コレの`値$a
◎
The value getter steps are to return this’s value.
</div>

<div class="algo">
<p>
`既存の属性oの値を設定する@
~algoは、
所与の
( `属性o$ %属性o, 文字列 %値 )
に対し：
◎
To set an existing attribute value, given an attribute attribute and string value, run these steps:
</p>
<ol>
	<li>
%要素 ~LET %属性o が`属する要素$
◎
↓</li>
	<li>
~IF［
%要素 ~EQ ~NULL
］
⇒＃
%属性o の`値$a ~SET %値；
~RET
◎
If attribute’s element is null, then set attribute’s value to value and return.
◎
↑ Let element be attribute’s element.
</li>
	<li>
%検証y-済みな値 ~LET `信用-済みな型に準拠な属性~値を取得する$( ↓ )
`TRUSTED-TYPES$r
⇒＃
%属性o の`局所~名$a,
%属性o の`~ns$a,
%要素,
%値
◎
Let verifiedValue be the result of calling get trusted type compliant attribute value with attribute’s local name, attribute’s namespace, element, and value. [TRUSTED-TYPES]
</li>
	<li>
<p>
~IF［
%要素 ~EQ ~NULL
］
⇒＃
%属性o の`値$a ~SET %検証y-済みな値；
~RET
</p>

<p class="trans-note">【
この段は不要に思われる
（すでに［
%要素 ~NEQ ~NULL
］は満たされている）。
】</p>
◎
If attribute’s element is null, then set attribute’s value to verifiedValue and return.
</li>
	<li>
`属性o値を変更する$( %属性o, %検証y-済みな値 )
◎
Change attribute to verifiedValue.
</li>
</ol>
</div>

<div class="algo">
$value 設定子~手続きは
⇒
`既存の属性oの値を設定する$( コレ, 所与の値 )
◎
The value setter steps are to set an existing attribute value with this and the given value.
</div>

<div class="algo">
@ownerElement
取得子~手続きは
⇒
~RET コレが`属する要素$
◎
The ownerElement getter steps are to return this’s element.
</div>

<div class="algo">
@specified
取得子~手続きは
⇒
~RET ~T
◎
The specified getter steps are to return true.
</div>

			</section>
		</section>
		<section id="interface-characterdata">
<h3 title="Interface CharacterData">4.10. ^@CharacterData ~interface</h3>

！！
[`Exposed$=Window]
interface @CharacterData : $Node {
  attribute [`LegacyNullToEmptyString$] $DOMString $data;
  readonly attribute `unsigned long$ $length;
  $DOMString $substringData(`unsigned long$ %offset, `unsigned long$ %count);
  $undefined $appendData($DOMString %data);
  $undefined $insertData(`unsigned long$ %offset, $DOMString %data);
  $undefined $deleteData(`unsigned long$ %offset, `unsigned long$ %count);
  $undefined $replaceData(`unsigned long$ %offset, `unsigned long$ %count, $DOMString %data);
};
！

<p class="note">注記：
$CharacterData は、［
$Text, $ProcessingInstruction, $Comment
］`~node$から利用される抽象-~interfaceであり，その直な~instanceは取得し得ない。
◎
CharacterData is an abstract interface. You cannot get a direct instance of it. It is used by Text, ProcessingInstruction, and Comment nodes.
</p>

<p>
この~interfaceを実装する`~node$は、
`文字~data~node@
とも称される
（すなわち， $Text （ $CDATASection も含む）, $ProcessingInstruction, $Comment ）。
</p>

<p class="trans-note">【
`文字~data~node$は、
これらの~interfaceを簡潔に総称するために この訳に導入した，非公式な用語である。
これらは、
（機能上は異なるものだが）多くの処理で同等に扱われるので。
】</p>

<div class="p">
<p>
各`文字~data~node$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~data@
⇒
文字列
— 【当の~nodeの作成-時に設定され，それ以降も】変異-可能。
</li>
</ul>
◎
Each node inheriting from the CharacterData interface has an associated mutable string called data.
</div>

<div class="algo">
<p>
`文字~data~node$ %~node の
`~dataを置換する@
~algoは、
所与の
( 整数 %offset, 整数 %count, 文字列 %data )
に対し：
◎
To replace data of a node node with an integer offset, integer count, and string data:
</p>
<ol>
	<li id="cp-let-node-length">
%長さ ~LET %~node の`長さ$node
◎
Let length be node’s length.
</li>
	<li id="cp-throw-size-err">
~IF［
%offset ~GT %長さ
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than length, then throw an "IndexSizeError" DOMException.
</li>
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~SET %長さ ~MINUS %offset
◎
If offset + count is greater than length, then set count to length − offset.
</li>
	<li>
%~node 用に種別 `characterData^l の`変異~記録を~queueする$( ↓ )
⇒＃
~NULL,
~NULL,
%~node の`~data$,
« »,
« »,
~NULL,
~NULL
◎
Queue a mutation record of "characterData" for node with null, null, node’s data, « », « », null, and null.
</li>
	<li>
%~node の`~data$ ~SET 次を順に`連結する$
⇒＃
%~node の`~data$の中の 0 から %offset までを`成す符号単位~部分文字列$,
%data,
%~node の`~data$の中の ( %offset ~PLUS %count ) から`終端までを成す符号単位~部分文字列$
◎
Insert data into node’s data after offset code units.
◎
Let deleteOffset be offset + data’s length.
◎
Starting from deleteOffset code units, remove count code units from node’s data.
</li>
	<li>
%差分 ~LET %data の`長さ$str ~MINUS %count
◎
↓</li>
	<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
		<ol>
			<li>
<p>
~IF［
%範囲o の`始端~node$ ~EQ %~node
］：
</p>
				<ol>
					<li>
~IF［
%offset ~LT %範囲o の`始端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%範囲o の`始端~offset$ ~SET %offset
</li>
					<li>
~IF［
%範囲o の`始端~offset$ ~GT %offset ~PLUS %count
］
⇒
%範囲o の`始端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%範囲o の`終端~node$ ~EQ %~node
］：
</p>
				<ol>
					<li>
<p>
~IF［
%offset ~LT %範囲o の`終端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%範囲o の`終端~offset$ ~SET %offset
</p>

<p class="trans-note">【
%範囲o の終端がちょうど置換される~~範囲の末尾を指している場合も，終端は置換した~~範囲の先頭に “寄せられる” ことになる。
】</p>

					</li>
					<li>
~IF［
%範囲o の`終端~offset$ ~GT %offset ~PLUS %count
］
⇒
%範囲o の`終端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
		</ol>
◎
For each live range whose start node is node and start offset is greater than offset but less than or equal to offset + count:＼
set its start offset to offset.
◎
For each live range whose end node is node and end offset is greater than offset but less than or equal to offset + count:＼
set its end offset to offset.
◎
For each live range whose start node is node and start offset is greater than offset + count:＼
increase its start offset by data’s length and decrease it by count.
◎
For each live range whose end node is node and end offset is greater than offset + count:＼
increase its end offset by data’s length and decrease it by count.
</li>
	<li>
~IF［
%~node の`親$ ~NEQ ~NULL
］
⇒
`適用-可能な仕様$にて %~node の`親$用に`定義された各$( `子~群~変更-時の手続き$ %手続き )
に対し
⇒
%手続き()
◎
If node’s parent is non-null, then run the children changed steps for node’s parent.
</li>
</ol>
</div>

<div class="algo">
<p>
`文字~data~node$ %~node の
`~dataの部分文字列@
を得る~algoは、
所与の
( 整数 %offset, 整数 %count )
に対し：
◎
To substring data of a node node with an integer offset and integer count: 
</p>
<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~LET %長さ ~MINUS %offset
◎
If offset + count is greater than length, then return a string whose value is the code units from the offsetth code unit to the end of node’s data.
</li>
	<li>
~RET `符号単位~部分文字列$( %~node の`~data$, %offset, %count )
◎
Return a string whose value is the code units from the offsetth code unit to the offset+countth code unit in node’s data.
</li>
</ol>
</div>

<div class="algo">
@data
取得子~手続きは
⇒
~RET コレの`~data$
◎
The data getter steps are to return this’s data.＼
</div>

<div class="algo">
$data 設定子~手続きは：
⇒
コレの`~dataを置換する$( 0, コレの`長さ$node, 所与の値 )
◎
Its setter steps are to replace data of this with 0, this’s length, and the given value.
</div>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレの`長さ$node
◎
The length getter steps are to return this’s length.
</div>

<div class="algo">
@substringData(offset, count)
~method手続きは
⇒
~RET コレの`~dataの部分文字列$( %offset, %count )
◎
The substringData(offset, count) method steps are to return the result of substringing data of this with offset and count.
</div>

<div class="algo">
@appendData(data)
~method手続きは
⇒
コレの`~dataを置換する$( コレの`長さ$node, 0, %data )
◎
The appendData(data) method steps are to replace data of this with this’s length, 0, and data.
</div>

<div class="algo">
@insertData(offset, data)
~method手続きは
⇒
コレの`~dataを置換する$( %offset, 0, %data )
◎
The insertData(offset, data) method steps are to replace data of this with offset, 0, and data.
</div>

<div class="algo">
@deleteData(offset, count)
~method手続きは
⇒
コレの`~dataを置換する$( %offset, %count, 空~文字列 )
◎
The deleteData(offset, count) method steps are to replace data of this with offset, count, and the empty string.
</div>

<div class="algo">
@replaceData(offset, count, data)
~method手続きは
⇒
コレの`~dataを置換する$( %offset, %count, %data )
◎
The replaceData(offset, count, data) method steps are to replace data of this with offset, count, and data.
</div>

		</section>
		<section id="interface-text">
<h3 title="Interface Text">4.11. ^@Text ~interface</h3>

！！
[`Exposed$=Window]
interface @Text : $CharacterData {
  `Text$mc(optional $DOMString %data = "");
  [`NewObject$] $Text $splitText(`unsigned long$ %offset);
  readonly attribute $DOMString $wholeText;
};
！

<hr>

<dl class="domintro">
	<dt>%text = $Text([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a new Text node whose data is data.
</dd>

	<dt>%text . $splitText(offset)</dt>
	<dd>
所与の %offset の地点で`~data$を分割し，残りの部分を $Text `~node$として返す。
◎
Splits data at the given offset and returns the remainder as Text node.
</dd>

	<dt>%text . $wholeText</dt>
	<dd>
%text を含む`連続的な~Text~node列$【！direct】を成すすべての $Text `~node$の`~data$を連結した結果を返す。
◎
Returns the combined data of all direct Text node siblings.
</dd>
</dl>

<hr>

<div class="algo">
<p>
`新たな~Text~node@
は、
所与の
( %文字列, %文書 )
に対し
⇒
~RET `新たな~obj$( $Text )
— その
⇒＃
`~data$ ~SET %文字列,
`~node文書$ ~SET %文書
</p>

<p class="trans-note">【
この手続きは、
他所を簡潔に述べるための，この訳による追加。
】</p>
</div>

<p>
`狭義-~Text~node@
とは、
$CDATASection `~node$でない $Text `~node$である。
◎
An exclusive Text node is a Text node that is not a CDATASection node.
</p>

<div class="algo">
`~node$ %~node を含む
`連続的な~Text~node列@
を得る~algoは
⇒
~RET 条件［
$Text `~node$である
］を満たす， %~node を含む`連続的な同胞~列$
◎
The contiguous Text nodes of a node node are node, node’s previous sibling Text node, if any, and its contiguous Text nodes, and node’s next sibling Text node, if any, and its contiguous Text nodes, avoiding any duplicates.
</div>

<div class="algo">
`~node$ %~node を含む
`連続的な狭義-~Text~node列@
を得る~algoは
⇒
~RET 条件［
`狭義-~Text~node$である
］を満たす， %~node を含む`連続的な同胞~列$
◎
The contiguous exclusive Text nodes of a node node are node, node’s previous sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, and node’s next sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
</div>

<div class="algo">
<p>
条件 %条件 を満たす， %~node を含む
`連続的な同胞~列@
を得る~algoは：
</p>
<ol>
	<li>
~Assert：
%~node は %条件 を満たす
</li>
	<li>
~WHILE［
%~node の`直前の同胞？$は %条件 を満たす
］
⇒
%~node ~SET %~node の`直前の同胞？$
</li>
	<li>
%~list ~LET « »
</li>
	<li>
<p>
~WHILE［
%~node は %条件 を満たす
］：
</p>
		<ol>
			<li>
%~list に %~node を`付加する$
</li>
			<li>
%~node ~SET %~node の`直後の同胞？$
</li>
		</ol>
	</li>
	<li>
~RET %~list
</li>
</ol>

<p class="trans-note">【
この手続きは、
原文による “連続的な…” の（再帰的な）定義を等価な（かつ平坦~化された平易な）定義に変形したものである。
】</p>
◎
↑</div>

<hr>

<div class="algo">
<p>
`~node$ %~node の
`子~text内容@
を得る~algoは：
</p>
<ol>
	<li>
%~list ~LET %~node の`子$のうち $Text `~node$であるものたちが成す`~tree順序$による`~list$
</li>
	<li>
~RET `~text~dataを連結する$( %~list )
</li>
</ol>
◎
The child text content of a node node is the concatenation of the data of all the Text node children of node, in tree order.
</div>

<div class="algo">
<p>
`~node$ %~node の
`子孫~text内容@
を得る~algoは：
</p>
<ol>
	<li>
%~list ~LET %~node の`子孫$のうち $Text `~node$であるものたちが成す`~tree順序$による`~list$
</li>
	<li>
~RET `~text~dataを連結する$( %~list )
</li>
</ol>
◎
The descendant text content of a node node is the concatenation of the data of all the Text node descendants of node, in tree order.
</div>

<div class="algo">
<p>
`~text~dataを連結する@
~algoは、
所与の
( $Text `~node$たちが成す`~list$ %~list )
に対し：
</p>
<ol>
	<li>
%~data群 ~LET « »
</li>
	<li>
%~list を成す
~EACH( %text )
に対し
⇒
%~data群 に %text の`~data$を`付加する$
</li>
	<li>
~RET %~data群 を`連結する$
</li>
</ol>

<p class="trans-note">【
この手続きは、
他所を簡潔に述べるための，この訳による追加。
】</p>
◎
</div>

<hr>

<div class="algo">
<p>
@Text(data)
構築子~手続きは
⇒＃
コレの`~data$ ~SET %data,
コレの`~node文書$ ~SET `現在の大域~obj$に`結付けられた文書$
◎
The new Text(data) constructor steps are to set this’s data to data and this’s node document to current global object’s associated Document.
</div>

<div class="algo">
<p>
`~Text~nodeを分割する@
~algoは、
所与の
( $Text `~node$ %~node, 整数 %offset )
に対し：
◎
To split a Text node node with integer offset:
</p>
<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
%count ~LET %長さ ~MINUS %offset
◎
Let count be length − offset.
</li>
	<li>
%新-~data ~LET
コレの`~dataの部分文字列$( %offset, %count )
◎
Let newData be the result of substringing data of node with offset and count.
</li>
	<li>
%新-~node ~LET `新たな~Text~node$( %新-~data, %~node の`~node文書$ )
◎
Let newNode be a new Text node whose node document is node’s node document and data is newData.
</li>
	<li>
%親 ~LET %~node の`親$
◎
Let parent be node’s parent.
</li>
	<li>
<p>
~IF［
%親 ~NEQ ~NULL
］：
◎
If parent is non-null:
</p>
		<ol>
			<li>
%親 の中で`~nodeを子の前に挿入する$( %新-~node, %~node の`直後の同胞？$ )
◎
Insert newNode into parent before node’s next sibling.
</li>
			<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
				<ol>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %~node
］~AND［
%範囲o の`始端~offset$ ~GT %offset
］
⇒＃
%範囲o の`始端~node$ ~SET %新-~node；
%範囲o の`始端~offset$ ~DECBY %offset
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %~node
］~AND［
%範囲o の`終端~offset$ ~GT %offset
］
⇒＃
%範囲o の`終端~node$ ~SET %新-~node；
%範囲o の`終端~offset$ ~DECBY %offset
</li>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~EQ %~node の`~index$ ~PLUS 1
］
⇒
%範囲o の`始端~offset$ ~INCBY 1
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~EQ %~node の`~index$ ~PLUS 1
］
⇒
%範囲o の`終端~offset$ ~INCBY 1
</li>
				</ol>
◎
For each live range whose start node is node and start offset is greater than offset, set its start node to newNode and decrease its start offset by offset.
◎
For each live range whose end node is node and end offset is greater than offset, set its end node to newNode and decrease its end offset by offset.
◎
For each live range whose start node is parent and start offset is equal to the index of node plus 1, increase its start offset by 1.
◎
For each live range whose end node is parent and end offset is equal to the index of node plus 1, increase its end offset by 1.
</li>
		</ol>
	</li>
	<li>
%~node の`~dataを置換する$( %offset, %count, 空~文字列 )
◎
Replace data of node with offset, count, and the empty string.
</li>
	<li>
~RET %新-~node
◎
Return newNode.
</li>
</ol>
</div>

<div class="algo">
@splitText(offset)
~method手続きは
⇒
~RET `~Text~nodeを分割する$( コレ, %offset )
◎
The splitText(offset) method steps are to split this with offset offset.
</div>

<div class="algo">
@wholeText
取得子~手続きは
⇒
~RET `~text~dataを連結する$( コレを含む`連続的な~Text~node列$ )
◎
The wholeText getter steps are to return the concatenation of the data of the contiguous Text nodes of this, in tree order.
</div>

		</section>
		<section id="interface-cdatasection">
<h3 title="Interface CDATASection">4.12. ^@CDATASection ~interface</h3>

！！
[`Exposed$=Window]
interface @CDATASection : $Text {
};
！

<!--  -->

		</section>
		<section id="interface-processinginstruction">
<h3 title="Interface ProcessingInstruction">4.13. ^@ProcessingInstruction ~interface</h3>

！！
[`Exposed$=Window]
interface @ProcessingInstruction : $CharacterData {
  readonly attribute $DOMString $target;
};
！

<div class="p">
<p>
各 $ProcessingInstruction `~node$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~target@pI
⇒
文字列
【— 作成-時に与えられる。】
</li>
</ul>
◎
ProcessingInstruction nodes have an associated target.
</div>

<div class="algo">
@target
取得子~手続きは
⇒
~RET コレの`~target$pI
◎
The target getter steps are to return this’s target.
</div>

		</section>
		<section id="interface-comment">
<h3 title="Interface Comment">4.14. ^@Comment ~interface</h3>

！！
[`Exposed$=Window]
interface @Comment : $CharacterData {
  `Comment$mc(optional $DOMString %data = "");
};
！

<dl class="domintro">
	<dt>%comment = $Comment([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a new Comment node whose data is data.
</dd>
</dl>

<div class="algo">
<p>
@Comment(data)
構築子~手続きは
⇒＃
コレの`~data$ ~SET %data,
コレの`~node文書$ ~SET `現在の大域~obj$に`結付けられた文書$
◎
The new Comment(data) constructor steps are to set this’s data to data and this’s node document to current global object’s associated Document.
</div>

		</section>
	</section>
	<section id="ranges">
<h2 title="Ranges">5. 範囲o</h2>

		<section id="introduction-to-dom-ranges">
<h3 title="Introduction to “DOM Ranges”">5.1. “DOM Ranges” 序論</h3>

<p>
［
$StaticRange ／ $Range
］~obj （ `範囲o$ ）は`~node~tree$の中の連続する内容を表現する。
各`範囲o$には、［
`始端$, `終端$
］がある
— これらは、
`範囲o$の`境界点$と総称される。
各`境界点$は、
( `~node$bp, `~offset$bp )
が成す`~tuple$である。
言い換えれば、
`範囲o$は`~node~tree$の中の 2 つの`境界点$に挟まれる
`中身@rg
を表現する。
◎
StaticRange and Range objects (ranges) represent a sequence of content within a node tree. Each range has a start and an end which are boundary points. A boundary point is a tuple consisting of a node and an offset. So in other words, a range represents a piece of content within a node tree between two boundary points.
</p>

<p>
`範囲o$は、
編集-時に内容を［
選択する／複製する
］ときに，よく利用される。
例えば，次の`~node~tree$が与えられたとき：
◎
Ranges are frequently used in editing for selecting and copying content.
</p>

<ol class="domTree"><li>`要素$: `p^e
	<ol><li>`要素$: `img^e,
		<span>^src=`insanity-wolf^l</span>
		<span>^alt=`Little-endian BOM; decode as big-endian!^l</span>
	</li><li>$Text:
		<samp>&nbsp;CSS 2.1 syndata is&nbsp;</samp>
	</li><li>`要素$: `em^e
		<ol><li>$Text: <samp>awesome</samp>
		</li></ol>
	</li><li>$Text: <samp>!</samp>
	</li></ol>
</li></ol>

<p>
次の様にして，並び `syndata is awes^l を表現する`範囲o$が得られる
（変数［
%p ／ %em
］には［
`p^e ／ `em^e
］`要素$がアテガわれたとする）：
◎
In the node tree above, a range can be used to represent the sequence “syndata is awes”. Assuming p is assigned to the p element, and em to the em element, this would be done as follows:
</p>

<pre class="lang-js">
var %range = new Range(),
    %firstText = %p.childNodes[1],
    %secondText = %em.firstChild
%range.setStart(%firstText, 9) /* <span class="comment">
先頭の空白も数に入れる
◎
do not forget the leading space
</span> */
%range.setEnd(%secondText, 4)
/* <span class="comment">
%range を`文字列~化＠#dom-range-stringifier$した結果は、
今や先に示した文字列になる
◎
range now stringifies to the aforementioned quote
</span> */
</pre>

<p class="note">注記：
`範囲o$は、
上の`~node~tree$の ^src や ^alt などの`属性o$は表現できない。
`範囲o$は`~node$用に限り有用になる。
◎
Attributes such as src and alt in the node tree above cannot be represented by a range. Ranges are only useful for nodes.
</p>

<p>
$StaticRange ~objと違って、
$Range ~objは，`~node~tree$に対する変異に影響される。
なので、
`~live範囲o$とも称される。
その種の変異によりそれらが無効~化されることはなく，可能なら内容の同じ部分を表現するようになる。
`~live範囲o$は、
`~node~tree$に対する変異
— 自身が表現する`中身$rgの一部が変異したときなど —
に伴い，必要に応じて自身も改変され得る。
◎
Range objects, unlike StaticRange objects, are affected by mutations to the node tree. Therefore they are also known as live ranges. Such mutations will not invalidate them and will try to ensure that it still represents the same piece of content. Necessarily, a live range might itself be modified as part of the mutation to the node tree when, e.g., part of the content it represents is mutated.
</p>

<p>
詳細は、
次に挙げる各種~algo／~methodを見よ
⇒＃
`~nodeを子の前に挿入する$,
`~nodeを除去する$
$Node.normalize(),
`~dataを置換する$,
`~Text~nodeを分割する$
◎
See the insert and remove algorithms, the normalize() method, and the replace data and split algorithms for details.
</p>

<p class="trans-note">【
例えば，範囲oの境界点が ある~nodeの “内側” を指していて, その~nodeが~treeから除去された場合、
その境界点は “~nodeが抜けた穴” を指すようにされる
（始端と終端が別々な~treeの中を指さないよう）。
始端と終端の両者が同じ~nodeの内側を指していたとしても、
除去された~nodeの内側を指すことはなく，それらは同じ “穴” を指すよう畳まれることになる。
】</p>

<p>
`~node~tree$の変異に呼応して，`~live範囲o$を更新することは、
高価になり得る。
`~node~tree$が変化するたびに、
影響されるすべての $Range ~objは更新される必要がある。
~appが`~live範囲o$に関心がなくなろうが、
変異が生じたときには，それらを最新に保つ~costを支払うことになる。
◎
Updating live ranges in response to node tree mutations can be expensive. For every node tree change, all affected Range objects need to be updated. Even if the application is uninterested in some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.
</p>

<p>
$StaticRange ~objは、
`~node~tree$が変異しても更新されない，軽量な`範囲o$であり、
したがって，
`~live範囲o$と同じ保守~costの~subjectにならない。
◎
A StaticRange object is a lightweight range that does not update when the node tree mutates. It is therefore not subject to the same maintenance cost as live ranges.
</p>

		</section>
		<section id="boundary-points">
<h3 title="Boundary points">5.2. 境界点</h3>

<p>
`境界点@
とは、
( ある`~node$
`~node@bp
,
負でない整数
`~offset@bp
)
が成す`~tuple$である。
◎
A boundary point is a tuple consisting of a node (a node) and an offset (a non-negative integer).
</p>

<p>
所与の
( `~node$ %node, 負でない整数 %offset )
に対し，
`境界点$( %node, %offset )
と記された所では、
( `~node$bp, `~offset$bp )
として
( %node, %offset )
を伴う`境界点$を表すとする。
【この表記は、この訳による追加。】
</p>

<p class="note">注記：
正しい`境界点$の`~offset$bpは、
0 以上, `境界点$の`~node$bpの`長さ$node以下になる。
◎
A correct boundary point’s offset will be between 0 and the boundary point’s node’s length, inclusive.
</p>

<div class="trans-note">
<p>【
~HTMLや~XMLの~source~textの中では，境界点は、
すべての~text~data（`文字~data~node$）を “仮想の” 開始~tag, 終了~tag で括り,
すべての空~要素（~HTMLの`~void要素$も含む）は［
開始~tag, 終了~tag
］の組に置換した上で、
すべての［
~tag, および
文字~dataを成す`符号単位$たち
］それぞれを点に見立てて，~sourceに現れる順に一列に並べたときの，隣接する任意の 2 つの点の隙間を指すものと見なせる。
</p>

<p>
例えば
"<samp>&lt;b&gt;text&lt;/b&gt;</samp>"
のような~markupの中の，［
開始~tag "<samp>&lt;b&gt;</samp>"
］と［
"<samp>text</samp>" の先頭
］との隙間を指す境界点には、
"<samp>text</samp>" ~node の［
内縁（ “仮想の” ~tagの内縁）を指すもの, および
外縁を指すもの
］があり、
また，境界点は［
"<samp>&lt;br&gt;</samp>"
のような空~tag ／
~dataが空な`文字~data~node$
］の内部も指し得る†。
</p>

<p>†
唯一の~~例外は，`~doctype$であり、
境界点は~doctypeの内部は`指し得ない＠#concept-range-bp-set$ようにされている
— したがってこの~modelでは，一個の “点” になる。
</p>

<p>
文書の~node~treeの一例とそのすべての境界点を表す模式図を次に示す。
縦棒  "|" が境界点が指し得る位置を表し，ドット "." が文字~dataを成す各~文字を表す
（`先掲の模式図＠#example-tree$と同様に、
左端が文書の先頭, 右端が文書の末尾，横線は~treeの中の各~nodeが文書~内を占める~~範囲を表し，~COLOR_Rは`文字~data~node$を表す）：
</p>

`bp-1^dgm

<p>
境界点を表す縦棒の直上の横線がその境界点の~nodeを表す。
境界点の~offsetは、
図の中では，その境界点を表す縦棒の直上の横線直下に在って, その縦棒より左側に在る縦棒の本数になる
（境界点の~nodeが図の~COLOR_Xならば、
その直下の`各数字^mkがその境界点の~offset）。
</p>

<p>
図の先頭の `*^c は`~doctype$を表す
（内部に境界点は無い）。
その次の孤立した `A^mk は~dataが空な`文字~data~node$の内部を指す（唯一の）境界点を表し，その次の `B^mk は内容が空な要素の内部を指す境界点を表し，~~後続の 2 個の~COLOR_Rは 2 個の`文字~data~node$が境界点（ `C^mk ）を挟んで間を置かずに連続していることを表している。
】</p>
</div>

<div class="algo">
<p>
`境界点$ %A の［
`境界点$ %B に
`相対的な位置bp@
］が， %B ［
`より前@i ／
`に等しい@i ／
`より後@i
］のいずれかになるかは、
次に従って決定される：
◎
The position of a boundary point (nodeA, offsetA) relative to a boundary point (nodeB, offsetB) is before, equal, or after, as returned by these steps:
</p>

<p class="trans-note">【
この~algoは、
2 つの境界点に対し，上に示した様な模式図における位置関係（左側が “より前” ）を算出する。
】</p>
<ol>
	<li>
( %nodeA, %offsetA, %nodeB, %offsetB )
~LET
( %A の`~node$bp, %A の`~offset$bp, %B の`~node$bp, %B の`~offset$bp )
◎
↑</li>
	<li>
~Assert：
%nodeA の`根$ ~EQ %nodeB の`根$
◎
Assert: nodeA and nodeB have the same root.
</li>
	<li>
~IF［
%nodeA ~EQ %nodeB
］
⇒
~RET ［
%offsetA ~LT %offsetB ならば `より前$i ／
%offsetA ~EQ %offsetB ならば `に等しい$i ／
%offsetA ~GT %offsetB ならば `より後$i
］
◎
If nodeA is nodeB, then return equal if offsetA is offsetB, before if offsetA is less than offsetB, and after if offsetA is greater than offsetB.
</li>
	<li>
~IF［
%nodeA は %nodeB に`後続-$する
］
⇒
~RET %B は %A ［
`より前$i ならば `より後$i ／
`より後$i ならば `より前$i
］
◎
If nodeA is following nodeB, then if the position of (nodeB, offsetB) relative to (nodeA, offsetA) is before, return after, and if it is after, return before.
</li>
	<li>
<p>
~IF［
%nodeA は %nodeB の`先祖$である
］：
◎
If nodeA is an ancestor of nodeB:
</p>
		<ol>
			<li>
%子 ~LET %nodeB
◎
Let child be nodeB.
</li>
			<li>
~WHILE［
%子 の`親$ ~NEQ %nodeA
］
⇒
%子 ~SET %子 の`親$
◎
While child is not a child of nodeA, set child to its parent.
</li>
			<li>
~IF［
%子 の`~index$ ~LT %offsetA
］
⇒
~RET `より後$i
◎
If child’s index is less than offsetA, then return after.
</li>
		</ol>
	</li>
	<li>
~RET `より前$i
◎
Return before.
</li>
</ol>
</div>

		</section>
		<section id="interface-abstractrange">
<h3 title="Interface AbstractRange">5.3. ^@AbstractRange ~interface</h3>

！！
[`Exposed$=Window]
interface @AbstractRange {<!-- ^@Range -->
  readonly attribute $Node $startContainer;
  readonly attribute `unsigned long$ $startOffset;
  readonly attribute $Node $endContainer;
  readonly attribute `unsigned long$ $endOffset;
  readonly attribute $boolean $collapsed;
};
！

<p>
$AbstractRange ~interfaceを実装する~objは、
単に
`範囲o@
とも称される。
◎
Objects implementing the AbstractRange interface are known as ranges.
</p>

<p class="trans-note">【
一般語の “~~範囲” と区別し易くするため、
この訳では， “°” を付けて “範囲o” と記すことにする
（ “DOM range”, “~~範囲~obj” などの呼称もあるが）。
】</p>

<p>
各 `範囲o$には、
2 つの`境界点$
`始端@,
`終端@
が結付けられる。
◎
A range has two associated boundary points — a start and end.
</p>

<p>
便宜のため、
`範囲o$の：
◎
For convenience,＼
</p>

<ul>
	<li>
(
`始端~node@,
`始端~offset@
) は、
順に，`始端$の
( `~node$bp, `~offset$bp )
を指すとする。
◎
a range’s start node is its start’s node, its start offset is its start’s offset,＼
</li>
	<li>
(
`終端~node@,
`終端~offset@
) は、
順に，`終端$の
( `~node$bp, `~offset$bp )
を指すとする。
◎
its end node is its end’s node, and its end offset is its end’s offset.
</li>
</ul>

<div class="algo">
所与の`範囲o$が
`畳まれて@
いるとは、
次を満たすことをいう
⇒
［
その`始端~node$ ~EQ その`終端~node$
］~AND［
その`始端~offset$ ~EQ その`終端~offset$
］
◎
A range is collapsed if its start node is its end node and its start offset is its end offset.
</div>

<dl class="domintro">
	<dt>%node = %range . $startContainer</dt>
	<dd>
%range の`始端~node$を返す。
◎
Returns range’s start node.
</dd>

	<dt>%offset = %range . $startOffset</dt>
	<dd>
%range の`始端~offset$を返す。
◎
Returns range’s start offset.
</dd>

	<dt>%node = %range . $endContainer</dt>
	<dd>
%range の`終端~node$を返す。
◎
Returns range’s end node.
</dd>

	<dt>%offset = %range . $endOffset</dt>
	<dd>
%range の`終端~offset$を返す。
◎
Returns range’s end offset.
</dd>

	<dt>%collapsed = %range . $collapsed</dt>
	<dd>
%range は`畳まれて$［
いるならば ~T ／
いないならば ~F
］を返す。
◎
Returns true if range is collapsed; otherwise false.
</dd>
</dl>

<div class="algo">
@startContainer
取得子~手続きは
⇒
~RET コレの`始端~node$
◎
The startContainer getter steps are to return this’s start node.
</div>

<div class="algo">
@startOffset
取得子~手続きは
⇒
~RET コレの`始端~offset$
◎
The startOffset getter steps are to return this’s start offset.
</div>

<div class="algo">
@endContainer
取得子~手続きは
⇒
~RET コレの`終端~node$
◎
The endContainer getter steps are to return this’s end node.
</div>

<div class="algo">
@endOffset
取得子~手続きは
⇒
~RET コレの`終端~offset$
◎
The endOffset getter steps are to return this’s end offset.
</div>

<div class="algo">
@collapsed
取得子~手続きは
⇒
~RET ~IS［
コレは`畳まれて$いる
］
◎
The collapsed getter steps are to return true if this is collapsed; otherwise false.
</div>

		</section>
		<section id="interface-staticrange">
<h3 title="Interface StaticRange">5.4. ^StaticRange ~interface</h3>

！！
dictionary @@StaticRangeInit {
  required $Node @startContainer;
  required `unsigned long$ @startOffset;
  required $Node @endContainer;
  required `unsigned long$ @endOffset;
};

[`Exposed$=Window]
interface @@StaticRange : $AbstractRange {
  `StaticRange$mc($StaticRangeInit %init);
};
！

<dl class="domintro">
	<dt>%staticRange  = $StaticRange(init)</dt>
	<dd>
`~node~tree$が変異しても更新しない，新たな`範囲o$を返す。
◎
Returns a new range object that does not update when the node tree mutates.
</dd>
</dl>

<div class="algo">
<p>
@StaticRange(init)
構築子~手続きは：
<!-- ^@StaticRangeInit -->
</p>
<ol>
	<li>
%始端~node ~LET %init[ "$startContainer" ]
</li>
	<li>
%終端~node ~LET %init[ "$endContainer" ]
</li>
	<li>
~IF［
%始端~node, %終端~node いずれかは［
$DocumentType ／ $Attr
］`~node$である
］
⇒
~THROW `InvalidNodeTypeError$E
</li>
	<li>
コレの`始端$ ~SET `境界点$( %始端~node, %init[ "$startOffset" ] ),
</li>
	<li>
コレの`終端$ ~SET `境界点$( %終端~node, %init[ "$endOffset" ] )
</li>
</ol>
◎
The new StaticRange(init) constructor steps are:
• If init["startContainer"] or init["endContainer"] is a DocumentType or Attr node, then throw an "InvalidNodeTypeError" DOMException.
• Set this’s start to (init["startContainer"], init["startOffset"]) and end to (init["endContainer"], init["endOffset"]).
</div>

<p>
`範囲o$【！StaticRange】は、
~AND↓ を満たすならば
`妥当@rg
であるとされる：
◎
A StaticRange is valid if all of the following are true:
</p>
<ul>
	<li>
`始端$, `終端$は同じ`~node~tree$内にある
◎
Its start and end are in the same node tree.
</li>
	<li>
0 ~LTE `始端~offset$ ~LTE `始端~node$の`長さ$node
◎
Its start offset is between 0 and its start node’s length, inclusive.
</li>
	<li>
0 ~LTE `終端~offset$ ~LTE `終端~node$の`長さ$node
◎
Its end offset is between 0 and its end node’s length, inclusive.
</li>
	<li>
`始端$は`終端$`より前$iか`終端$`に等しい$i
◎
Its start is before or equal to its end.
</li>
</ul>

<p class="trans-note">【
この用語は、
他の仕様から利用するためにある
— この仕様が主に取扱う`~live範囲o$に対する演算は、
常に，結果が`妥当$rgになるように施行されるので。
】</p>

		</section>
		<section id="interface-range">
<h3 title="Interface Range">5.5. ^@Range ~interface</h3>

！！
[`Exposed$=Window]
interface @Range : $AbstractRange {
  `Range$mc();

  readonly attribute $Node $commonAncestorContainer;

  $undefined $setStart($Node %node, `unsigned long$ %offset);
  $undefined $setEnd($Node %node, `unsigned long$ %offset);
  $undefined $setStartBefore($Node %node);
  $undefined $setStartAfter($Node %node);
  $undefined $setEndBefore($Node %node);
  $undefined $setEndAfter($Node %node);
  $undefined $collapse(optional $boolean %toStart = false);
  $undefined $selectNode($Node %node);
  $undefined $selectNodeContents($Node %node);

  const `unsigned short$ @START_TO_START = 0;
  const `unsigned short$ @START_TO_END = 1;
  const `unsigned short$ @END_TO_END = 2;
  const `unsigned short$ @END_TO_START = 3;
  $short $compareBoundaryPoints(`unsigned short$ %how, $Range %sourceRange);

  [`CEReactions$] $undefined $deleteContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $extractContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $cloneContents();
  [`CEReactions$] $undefined $insertNode($Node %node);
  [`CEReactions$] $undefined $surroundContents($Node %newParent);

  [`NewObject$] $Range $cloneRange();
  $undefined $detach();

  $boolean $isPointInRange($Node %node, `unsigned long$ %offset);
  $short $comparePoint($Node %node, `unsigned long$ %offset);

  $boolean $intersectsNode($Node %node);

  $stringifier;
};
！

<p>
$Range ~interfaceを実装する~objは単に
`~live範囲o@
とも称される。
◎
Objects implementing the Range interface are known as live ranges.
</p>

<p class="note">注記：
`~tree$を改変する~algo
（特に，
`~nodeを子の前に挿入する$,
`~nodeを除去する$,
`~nodeを移動する$,
`~dataを置換する$,
`~Text~nodeを分割する$）
は、
その`~tree$に結付けられた一連の`~live範囲o$も改変する。
◎
Algorithms that modify a tree (in particular the insert, remove, move, replace data, and split algorithms) modify live ranges associated with that tree.
</p>

<p>
`~live範囲o$の
`根@rg
とは、
その`始端~node$の`根$である。
◎
The root of a live range is the root of its start node.
</p>

<p class="trans-note">【
`終端~node$の`根$と同じになる
（常にそうなるように拘束される）。
各 `~live範囲o$は、
その作成-時からずっと，同じある`~node~tree$に結付けられ続ける
— 言い換えれば、
`根$rgは変化しない。
（仕様には明示的にそう述べられてはいないが、
各種~algoの挙動から，そう結論できる。
一般な`範囲o$は、
そのように拘束されない。
】</p>

<p>
`~node$ %node が`~live範囲o$ %範囲o に
`包含され@
ているとは、
~AND↓ が満たされることをいう：
◎
A node node is contained in a live range range if＼
</p>
<ul>
	<li>
%node の`根$ ~EQ %範囲o の`根$rg
◎
node’s root is range’s root, and ＼
</li>
	<li>
`境界点$( %node, 0 ) は %範囲o の`始端$`より後$i
◎
(node, 0) is after range’s start, and＼
</li>
	<li>
`境界点$( %node, %node の`長さ$node ) は %範囲o の`終端$`より前$i
◎
(node, node’s length) is before range’s end.
</li>
</ul>

<p>
`~node$ %node が`~live範囲o$ %範囲o に
`部分的に包含され@
ているとは、
~OR↓ が満たされることをいう：
◎
A node is partially contained in a live range if＼
</p>
<ul>
	<li>
［
%node は %範囲o の`始端~node$の`広義-先祖$である
］~AND［
%node は %範囲o の`終端~node$の`広義-先祖$でない
］
◎
it’s an inclusive ancestor of the live range’s start node but not its end node, or＼
</li>
	<li>
［
%node は %範囲o の`始端~node$の`広義-先祖$でない
］~AND［
%node は %範囲o の`終端~node$の`広義-先祖$である
］
◎
vice versa.
</li>
</ul>

<div class="trans-note">
<p>【
次の図は先掲の模式図と同様に~treeを表したものであり，図の記号 `s^mk が始端, `e^mk が終端を表すとする。
このとき、
図の~COLOR_Xの~nodeが包含され, ~COLOR_Yの~node（始端／終端の一方のみを内部に含む~node）が部分的に包含される。
最上層の横線の~nodeは 内部に `s^mk, `e^mk とも含むので、
~~定義により，`部分的に包含され$ることはない。
】</p>

`bp-2^dgm
</div>

<div class="note">
<p>注記：
これらの定義をより理解し易くする事実をいくつか挙げる：
◎
Some facts to better understand these definitions:
</p>

<ul>
	<li>
`~live範囲o$の`中身$rgは、
`包含され$ているすべての`~node$に加えて，［［
`始端~node$ ／ `終端~node$
］の`広義-子孫$である`文字~data~node$のうち，範囲oに入るもの
］からなるものとみなせる。
◎
The content that one would think of as being within the live range consists of all contained nodes, plus possibly some of the contents of the start node and end node if those are CharacterData nodes.
</li>
	<li>
`~live範囲o$に`包含され$ている`~node$たちが成す集合は、
`包含され$ている`~node$の`親$が常に`包含され$るとは限らないので，一般に連続的でない。
◎
The nodes that are contained in a live range will generally not be contiguous, because the parent of a contained node will not always be contained.
</li>
	<li>
しかしながら，`包含され$ている`~node$の`子孫$は`包含され$ており、
2 つの`同胞$が`包含され$ているならば，それらの間に在るどの`同胞$も`包含され$る。
◎
However, the descendants of a contained node are contained, and if two siblings are contained, so are any siblings that lie between them.
</li>
	<li>
`~live範囲o$の`始端~node$ と`終端~node$ は決して その範囲oに`包含され$ない。
◎
The start node and end node of a live range are never contained within it.
</li>
	<li>
`包含され$ている`~node$のうち、
最初のもの（もし在れば）は，常に`始端~node$に`後続-$し、
最後のものは，常に`終端~node$の最後の`子孫$と同じか, それに`先行-$する。
【！descendant を持たない場合は？】
◎
The first contained node (if there are any) will always be after the start node, and the last contained node will always be equal to or before the end node’s last descendant.
</li>
	<li>
部分的に包含される`~node$が存在するのは、
`始端~node$ と`終端~node$ が異なるとき, そのときに限る。
◎
There exists a partially contained node if and only if the start node and end node are different.
</li>
	<li>
`始端~node$と`終端~node$の`共通な広義-先祖$は、
`包含され$ることも, `部分的に包含され$ることもない。
◎
The commonAncestorContainer attribute value is neither contained nor partially contained.
</li>
	<li>
<p>
`始端~node$ %A が `終端~node$ %B の`先祖$である場合：
</p>
		<ul>
			<li>
%A が， %A, %B に`共通な広義-先祖$になる。
</li>
			<li>
%A の`子$のうち， 1 つだけ（ %C とする）が`部分的に包含され$る。
</li>
			<li>
%A の別の`子$ %C1 が`包含され$るのは、
%C1 が %C に`先行-$するとき, そのときに限る。
</li>
		</ul>

<div class="trans-note">
<p>【
この場合の例。
前と同様，記号 `s^mk は始端, `e^mk は終端を表す。
この例では図の最上層の~nodeが共通な広義-先祖になる。
共通な広義-先祖の子のうち、
~COLOR_Yの~nodeが上述の %C （共通な広義-先祖の子であってかつ部分的に包含される）に該当し，~COLOR_Xの~nodeが`包含され$る子になる。
】</p>

`bp-3^dgm
</div>

<p>
%B が %A の`先祖$である場合、
前述の逆になる。
【上の図で、 `s^mk と `e^mk を入れ替えて，右端から~treeの順序が開始されていると考えるとよい。】
</p>

◎
If the start node is an ancestor of the end node, the common inclusive ancestor will be the start node. Exactly one of its children will be partially contained, and a child will be contained if and only if it precedes the partially contained child. If the end node is an ancestor of the start node, the opposite holds.
</li>
	<li>
`始端~node$ %A, `終端~node$ %B とも他方の`広義-先祖$でない場合：
%A, %B の`共通な広義-先祖$ %先祖 は、
%A とも %B とも異なる。
%先祖 の`子$のうち，ちょうど 2 個が`部分的に包含され$、
%先祖 の`子$が`包含され$るのは，これら 2 個の合間に在るとき, そのときに限る。
◎
If the start node is not an inclusive ancestor of the end node, nor vice versa, the common inclusive ancestor will be distinct from both of them. Exactly two of its children will be partially contained, and a child will be contained if and only if it lies between those two.
</li>
</ul>
</div>

<div class="algo">
<p>
`~live範囲o用の除去-前の手続き@
は、
所与の
( `~node$ %~node )
に対し：
◎
The live range pre-remove steps given a node node, are:
</p>
<ol>
	<li>
%親 ~LET %~node の`親$
◎
Let parent be node’s parent.
</li>
	<li>
~Assert：
%親 ~NEQ ~NULL
◎
Assert: parent is non-null.
</li>
	<li>
%~index ~LET %~node の`~index$
◎
Let index be node’s index.
</li>
	<li>
<p>
~EACH( `~live範囲o$ %範囲o )
に対し：
</p>
		<ol>
			<li>
~IF［
%範囲o の`始端~node$ は %~node の`広義-子孫$である
］
⇒＃
%範囲o の`始端~node$ ~SET %親；
%範囲o の`始端~offset$ ~SET %~index
</li>
			<li>
~IF［
%範囲o の`終端~node$ は %~node の`広義-子孫$である
］
⇒＃
%範囲o の`終端~node$ ~SET %親；
%範囲o の`終端~offset$ ~SET %~index
</li>
			<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~GT %~index
］
⇒
%範囲o の`始端~offset$ ~DECBY 1
</li>
			<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~GT %~index
］
⇒
%範囲o の`終端~offset$ ~DECBY 1
</li>
		</ol>
◎
For each live range whose start node is an inclusive descendant of node, set its start to (parent, index).
◎
For each live range whose end node is an inclusive descendant of node, set its end to (parent, index).
◎
For each live range whose start node is parent and start offset is greater than index, decrease its start offset by 1.
◎
For each live range whose end node is parent and end offset is greater than index, decrease its end offset by 1.
</li>
</ol>
</div>

<hr>

<dl class="domintro">
	<dt>%range = $Range()</dt>
	<dd>
新たな`~live範囲o$を返す。
◎
Returns a new live range.
</dd>
</dl>

<div class="algo">
<p>
@Range()
構築子~手続きは：
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられた文書$
</li>
	<li>
コレの`始端$ ~SET `境界点$( %文書, 0 )
</li>
	<li>
コレの`終端$ ~SET `境界点$( %文書, 0 )
</li>
</ol>
◎
The new Range() constructor steps are to set this’s start and end to (current global object’s associated Document, 0).
</div>

<dl class="domintro">
	<dt>%container = %range . $commonAncestorContainer</dt>
	<dd>
%range の［
`始端~node$, `終端~node$
］両者の`広義-先祖$であるような，最も末端の~nodeを返す。
【原文の “ancestor” （先祖）は~~厳密な記述ではない。】
◎
Returns the node, furthest away from the document, that is an ancestor of both range’s start node and end node.
</dd>
</dl>

<div class="algo">
@commonAncestorContainer
取得子~手続きは
⇒
~RET コレの
( `始端~node$, `終端~node$ )
の`共通な広義-先祖$
◎
The commonAncestorContainer getter steps are:
• Let container be start node.
• While container is not an inclusive ancestor of end node:＼
set container to container’s parent.
• Return container.
</div>

<div class="algo">
<p>
同じ~treeに`関与-$している
( `~node$ %A, `~node$ %B )
の（最も末端の）
`共通な広義-先祖@
を得る~algoは：
</p>
<ol>
	<li>
~WHILE［
%A は %B の`広義-先祖$でない
］
⇒
%A ~SET %A の`親$
</li>
	<li>
~RET %A
</li>
</ol>

<p class="trans-note">【
この~algoは、
他所を簡潔に述べるための，この訳による追加。
】</p>
◎
↑</div>

<hr>

<p class="trans-note">【
次の~blockは、
原文には存在しない，この訳による補完。
~blockにて挙げる各種~methodは、
範囲oの片方または両方の境界点を新たな地点に変更する。
片方の境界点（以下， %P ）のみを変更する~methodについては、
`妥当$rg性を保つため，もう片方の境界点（以下， %Q ）も必要に応じて~~正される：
すなわち， %Q が［
%P と異なる~treeの中に在る, または［
%P `より前$i（始端が変更された場合） ／
%P `より後$i（終端が変更された場合）
］に位置する
］ようになった場合、
%P と同じ地点にされる（ 範囲oは畳まれる）。
】</p>

<dl class="domintro">
	<dt>%range . $setStart(node, offset)</dt>
	<dt>%range . $setEnd(node, offset)</dt>
	<dd>
それぞれ，始端／終端を `境界点$( %node, %offset ) と同じ位置にする。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
他の場合，
%offset が %node の`長さ$nodeを超えている場合，
`IndexSizeError$E 例外が投出される。
</dd>

	<dt>%range . $setStartBefore(node)</dt>
	<dt>%range . $setStartAfter(node)</dt>
	<dd>
それぞれ，始端を %node の外縁な［
始端（下図の `S^mk ）／終端（下図の `E^mk ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $setEndBefore(node)</dt>
	<dt>%range . $setEndAfter(node)</dt>
	<dd>
それぞれ，終端を %node の外縁な［
始端（下図の `S^mk ）／終端（下図の `E^mk ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dd class="trans-note">
<p>
（説明用の図式
— %node 引数が，図の~COLOR_Yが表す~nodeに対応しているとする。）
</p>

`bp-4^dgm
</dd>

	<dt>%range . $collapse(toStart)</dt>
	<dd>
範囲oを畳む
— すなわち、
%toStart が ~T の場合は 終端を始端と同じ地点に位置させ，他の場合は 始端を終端と同じ地点に位置させる。
</dd>

	<dt>%range . $selectNode(node)</dt>
	<dd>
%node を選択する
— すなわち、
始端と終端を %node の外縁な両端（上図の `S^mk, `E^mk ）に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $selectNodeContents(node)</dt>
	<dd>
%node の内容を選択する
— すなわち、
始端と終端を %node の内縁な両端（上図の `s^mk, `e^mk ）に位置させる。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
%range の始端または終端（ %how により指示される）の位置bpが，
%sourceRange の始端または終端（ %how により指示される）［
`より前$i, `に等しい$i, `より後$i
］のいずれになるかに応じて、［
−1, 0, 1
］を返す。
</dd>
</dl>

<div class="algo">
<p>
`範囲o$ %範囲o の
`境界点を設定する@
~algoは、
所与の
( %端 ~IN { `始端^i, `終端^i }, `~node$ %node, 負でない整数 %offset )
に対し：
◎
To set the start or end of a range to a boundary point (node, offset):
</p>
<ol>
	<li id="cp-throw-if-doctype">
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
</li>
	<li id="cp-throw-if-length">
~IF［
%offset ~GT %node の`長さ$node
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than node’s length, then throw an "IndexSizeError" DOMException.
</li>
	<li>
%境界点 ~LET `境界点$( %node, %offset )
◎
Let boundaryPoint be the boundary point (node, offset).
</li>
	<li>
<p>
~IF［
%端 ~EQ `始端^i
］：
◎
If these steps were invoked as "set the start"
</p>
		<ol>
			<li>
~IF［
%範囲o の`根$rg ~NEQ %node の`根$
］~OR［
%境界点 は %範囲o の`終端$`より後$i
］
⇒
%範囲o の`終端$ ~SET %境界点
◎
If range’s root is not node’s root or boundaryPoint is after range’s end, then set range’s end to boundaryPoint.
</li>
			<li>
%範囲o の`始端$ ~SET %境界点
◎
Set range’s start to boundaryPoint.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %端 ~EQ `終端^i ）
◎
If these steps were invoked as "set the end"
</p>
		<ol>
			<li>
~IF［
%範囲o の`根$rg ~NEQ %node の`根$
］~OR［
%境界点 は %範囲o の`始端$`より前$i
］
⇒
%範囲o の`始端$ ~SET %境界点
◎
If range’s root is not node’s root or boundaryPoint is before range’s start, then set range’s start to boundaryPoint.
</li>
			<li>
%範囲o の`終端$ ~SET %境界点
◎
Set range’s end to boundaryPoint.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
@setStart(node, offset)
~method手続きは
⇒
コレの`境界点を設定する$( `始端^i, %node, %offset )
◎
The setStart(node, offset) method steps are to set the start of this to boundary point (node, offset).
</div>

<div class="algo">
@setEnd(node, offset)
~method手続きは
⇒
コレの`境界点を設定する$( `終端^i, %node, %offset )
◎
The setEnd(node, offset) method steps are to set the end of this to boundary point (node, offset).
</div>

<div class="algo">
<p>
@setStartBefore(node)
~method手続きは：
◎
The setStartBefore(node) method steps are:
</p>
<ol>
	<li id="cp-let-parent">
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
	<li id="cp-throw-if-null">
~IF［
%親 ~EQ ~NULL
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If parent is null, then throw an "InvalidNodeTypeError" DOMException.
</li>
	<li>
コレの`境界点を設定する$( `始端^i, %親, %node の`~index$ )
◎
Set the start of this to boundary point (parent, node’s index).
</li>
</ol>
</div>

<div class="algo">
<p>
@setStartAfter(node)
~method手続きは：
◎
The setStartAfter(node) method steps are:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
コレの`境界点を設定する$( `始端^i, %親, %node の`~index$ ~PLUS 1 )
◎
Set the start of this to boundary point (parent, node’s index plus 1).
</li>
</ol>
</div>

<div class="algo">
<p>
@setEndBefore(node)
~method手続きは：
◎
The setEndBefore(node) method steps are:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
コレの`境界点を設定する$( `終端^i, %親, %node の`~index$ )
◎
Set the end of this to boundary point (parent, node’s index).
</li>
</ol>
</div>

<div class="algo">
<p>
@setEndAfter(node)
~method手続きは：
◎
The setEndAfter(node) method steps are:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
コレの`境界点を設定する$( `終端^i, %親, %node の`~index$ ~PLUS 1 )
◎
Set the end of this to boundary point (parent, node’s index plus 1).
</li>
</ol>
</div>

<div class="algo">
<p>
@collapse(toStart)
~method手続きは：
◎
The collapse(toStart) method steps are to,＼
</p>
<ol>
	<li>
~IF［
%toStart ~EQ ~T
］
⇒
コレの`終端$ ~SET `境界点$( コレの`始端~node$, コレの`始端~offset$ )
◎
if toStart is true, set end to start;＼
</li>
	<li>
~ELSE
⇒
コレの`始端$ ~SET `境界点$( コレの`終端~node$, コレの`終端~offset$ )
◎
otherwise set start to end.
</li>
</ol>
</div>

<div class="algo">
<p>
`範囲oの中身として選択する@
~algoは、
所与の
( `範囲o$ %範囲o, `~node$ %node )
に対し：
◎
To select a node node within a range range:
</p>
<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
%index ~LET %node の`~index$
◎
Let index be node’s index.
</li>
	<li>
%範囲o の`始端$ ~SET `境界点$( %親, %index )
◎
Set range’s start to boundary point (parent, index).
</li>
	<li>
%範囲o の`終端$ ~SET `境界点$( %親, %index ~PLUS 1 )
◎
Set range’s end to boundary point (parent, index plus 1).
</li>
</ol>
</div>

<div class="algo">
<p>
@selectNode(node)
~method手続きは
⇒
`範囲oの中身として選択する$( コレ, %node )
◎
The selectNode(node) method steps are to select node within this.
</div>

<div class="algo">
<p>
@selectNodeContents(node)
~method手続きは：
◎
The selectNodeContents(node) method steps are:
</p>
<ol>
	<!--cp-throw-if-doctype-->
	<li>
%長さ ~LET %node の`長さ$node
◎
Let length be the length of node.
</li>
	<li>
コレの`始端$ ~SET `境界点$( %node, 0 )
◎
Set start to the boundary point (node, 0).
</li>
	<li>
コレの`終端$ ~SET `境界点$( %node, %長さ )
◎
Set end to the boundary point (node, length).
</li>
</ol>
</div>

<div class="algo">
<p>
@compareBoundaryPoints(how, sourceRange)
~method手続きは：
◎
The compareBoundaryPoints(how, sourceRange) method steps are:
</p>
<ol>
	<li>
~IF［
%how ~NIN {
$START_TO_START,
$START_TO_END,
$END_TO_END,
$END_TO_START
}
］
⇒
~THROW `NotSupportedError$E
◎
If how is not one of
• START_TO_START
• START_TO_END
• END_TO_END
• END_TO_START
◎
then throw a "NotSupportedError" DOMException.
</li>
	<li>
~IF［
コレの`根$rg ~NEQ %sourceRange の`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If this’s root is not sourceRange’s root, then throw a "WrongDocumentError" DOMException.
</li>
	<li>
<p>
( %この点, %~source点 ) ~LET %how に応じて：
◎
Let thisPoint and sourcePoint be null.
◎
Switch on how:
</p>
		<ul class="switch">
			<li>
$START_TO_START
⇒
( コレの`始端$, %sourceRange の`始端$ )
◎
START_TO_START:
• Set thisPoint to this’s start and sourcePoint to sourceRange’s start.
</li>
			<li>
$START_TO_END
⇒
( コレの`終端$, %sourceRange の`始端$ )
◎
START_TO_END:
• Set thisPoint to this’s end and sourcePoint to sourceRange’s start.
</li>
			<li>
$END_TO_END
⇒
( コレの`終端$, %sourceRange の`終端$ )
◎
END_TO_END:
• Set thisPoint to this’s end and sourcePoint to sourceRange’s end.
</li>
			<li>
$END_TO_START
⇒
( コレの`始端$, %sourceRange の`終端$ )
◎
END_TO_START:
• Set thisPoint to this’s start and sourcePoint to sourceRange’s end.
</li>
		</ul>
	</li>
	<li>
~RET ［
%この点 は %~source点 ［
`より前$i ならば −1 ／
`に等しい$i ならば 0 ／
`より後$i ならば 1
］
◎
Switch on the position of thisPoint relative to sourcePoint:
◎
before
• Return −1.
◎
equal
• Return 0.
◎
after
• Return 1.
</li>
</ol>
</div>

<!-- ^@Range -->

<p class="trans-note">【
次の~blockは、
原文には存在しない，この訳による補完。
~blockにて挙げる各種~methodは、
主に，範囲oの`中身$rgを操作する。
】</p>

<dl class="domintro">
	<dt>%range . $deleteContents()</dt>
	<dd>
この範囲oの`中身$rgを削除した上で、
範囲oの`境界点$を畳む。
</dd>
	<dd>
<p>
`deleteContents()^c の実行例。
図の記号［
`s^mk, `e^mk
］が順に範囲oの［
始端, 終端
］を表すとするとき、
図左の~~状態から図右の~~状態になる。
包含されている~node（図の ~COLOR_X ）, および
始端／終端~nodeの文字~dataのうち 範囲oに入る部分の文字（図の `+^c ）が除去される。
部分的に包含されている~node（図の ~COLOR_Y ）は除去されない。
この例では、
始端 `s^mk が指す`文字~data~node$は，~dataは空になるが~node自体は残される。
図右の `S^mk, `E^mk が元の始端, 終端に対応する位置であるが、
実行後の始端と終端は，図右の `X^mk （共通な広義-先祖の直下）を指すようになることに注意（範囲oは畳まれる）。
始端~nodeが終端~nodeの`広義-先祖$であった場合、
始端の位置は変化しない。
始端~nodeが終端~node の`広義-子孫$であった場合、
全体の終端（右端）から相対的な終端の位置は変化しない。
</p>

`bp-5^dgm
</dd>

	<dt>%range . $extractContents()</dt>
	<dd>
この範囲oの`中身$rgを~cloneした結果を返すと同時に，当の中身を削除する（ “カット” ）。
機能上は
$cloneContents() と $deleteContents()
の組み合わせと等価になる。
</dd>

	<dt>%range . $cloneContents()</dt>
	<dd>
この範囲oの`中身$rgを~cloneした結果を返す。
返される`中身$rgは、
新たな`文書片$で包装される。
</dd>
	<dd>
<p>
^cloneContents() の実行例。
図左の記号［
`s^mk, `e^mk
］が順に範囲の［
始端, 終端
］を表すとするとき、
その間に挟まれた部分の~cloneが図右に示すように得られる
（ `S^mk, `E^mk が元の始端と終端に対応する位置）。
図の~COLOR_Yの 2 個の~nodeが，範囲に`部分的に包含され$ている子。
入れ物にあたる それらの`共通な広義-先祖$は、
~cloneにおいては`文書片$（~COLOR_X）に置換される。
始端 `s^mk が属する`文字~data~node$は~dataが空になるが、
~node自体は［
その親から共通な広義-先祖の子まで
］の先祖も含めて~cloneされる。
</p>

`bp-6^dgm
</dd>

	<dt>%range . $insertNode(node)</dt>
	<dd>
この範囲oの`中身$rgの先頭に %node を挿入する（`範囲oの中へ挿入する$）。
</dd>

	<dt>%range . $surroundContents(newParent)</dt>
	<dd>
この範囲oの`中身$rgを %newParent ~nodeで包装する。
それに伴い、
範囲oの始端, 終端は， %newParent の（外縁な）両端を指すようになる。
包装するに先立って、
%newParent の元々の子はすべて除去され，
%newParent 自身も元々の親から除去される。
</dd>
	<dd>
<p>
^surroundContents(%newParent) の実行例。
記号 `s^mk は始端, `e^mk は終端を表すとき、
それらに挟まれた区間が %newParent で包装される（図の~COLOR_Y）。
`部分的に包含され$るものは `Text^c 以外は許容されないので、
始端と終端は `Text^c の層を~~無視すれば同じ親の直下に在る必要がある
（さもなければ例外が投出される）。
図の `e^mk の様に境界点が `Text^c ~node内に位置していた場合、
その~nodeはそこで分割される。
</p>

`bp-7^dgm
</dd>
</dl>

<div class="algo">
<p>
@deleteContents()
~method手続きは：
◎
The deleteContents() method steps are:
</p>
<ol>
	<li>
~IF［
コレは`畳まれて$いる
］
⇒
~RET
◎
If this is collapsed, then return.
</li>
	<li>
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に，コレの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let originalStartNode, originalStartOffset, originalEndNode, and originalEndOffset be this’s start node, start offset, end node, and end offset, respectively.
</li>
	<li>
<p>
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node は`文字~data~node$である
］：
◎
If originalStartNode is originalEndNode and it is a CharacterData node: 
</p>
		<ol>
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data of originalStartNode with originalStartOffset, originalEndOffset − originalStartOffset, and the empty string.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%除去-対象 ~LET 次を満たす`~node$たちが成す，`~tree順序$による~list
⇒
［
コレに`包含され$ている
］~AND［
その`親$はコレに`包含され$ていない
］
◎
Let nodesToRemove be a list of all the nodes that are contained in this, in tree order, omitting any node whose parent is also contained in this.
</li>
	<li id="cp-let-new-node-new-offset">
( %新-~node, %新-~offset ) ~LET ( ~NULL, ~NULL )
◎
Let newNode and newOffset be null.
</li>
	<li id="cp-let-new-if">
~IF［
%元の始端~node は %元の終端~node の`広義-先祖$である
］
⇒＃
%新-~node ~SET %元の始端~node；
%新-~offset ~SET %元の始端~offset
◎
If originalStartNode is an inclusive ancestor of originalEndNode, then set newNode to originalStartNode and newOffset to originalStartOffset.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%新-~node ~SET
( %元の始端~node, %元の終端~node )
の`共通な広義-先祖$
</li>
			<li>
%新-~offset ~SET ［
%新-~node の`子$のうち, %元の始端~node の`広義-先祖$である`~node$ †
］の`~index$ ~PLUS 1
</li>
		</ol>

<p class="trans-note">【
見通しを良くするため、
ここの訳は，原文を等価な記述に変形している。
前~段の条件の否定が成立することから † に該当する~nodeは必ず在り，
%新-~node に`部分的に包含され$ている子のうち 最初のものになる。
】</p>

◎
Otherwise:
• Let referenceNode be originalStartNode.
• While referenceNode’s parent is non-null and is not an inclusive ancestor of originalEndNode:＼
set referenceNode to its parent.
• Set newNode to referenceNode’s parent and newOffset to referenceNode’s index + 1.
• If referenceNode’s parent were null, it would be the root of this. And then it would be an inclusive ancestor of originalEndNode and we could not reach this point.
</li>
	<li>
~IF［
%元の始端~node は`文字~data~node$である
］
⇒
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$node ~MINUS %元の始端~offset, 空~文字列 )
◎
If originalStartNode is a CharacterData node, then replace data of originalStartNode with originalStartOffset, originalStartNode’s length − originalStartOffset, and the empty string.
</li>
	<li>
%除去-対象 を成す
~EACH( %node )
に対し【！`~tree順序$で】
⇒
`~nodeを除去する$( %node )
◎
For each node of nodesToRemove, in tree order:＼
remove node.
</li>
	<li>
~IF［
%元の終端~node は`文字~data~node$である
］
⇒
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
If originalEndNode is a CharacterData node, then replace data of originalEndNode with 0, originalEndOffset, and the empty string.
</li>
	<li>
コレの
⇒＃
`始端$ ~SET `境界点$( %新-~node, %新-~offset )；
`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set start and end to (newNode, newOffset).
</li>
</ol>
</div>

<div class="algo">
<p>
`範囲oの中身を抽出する@
~algoは、
所与の
( `~live範囲o$ %範囲o )
に対し：
◎
To extract a live range range:
</p>
<ol>
	<li id="cp-new-frag">
%文書片 ~LET 新たな`文書片$
— その
⇒
`~node文書$ ~SET %範囲o の`始端~node$の`~node文書$
◎
Let fragment be a new DocumentFragment node whose node document is range’s start node’s node document.
</li>
	<li id="cp-ret-frag-if">
~IF［
%範囲o は`畳まれて$いる
］
⇒
~RET %文書片
◎
If range is collapsed, then return fragment.
</li>
	<li id="cp-let-bp-vars">
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に， %範囲o の
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let originalStartNode, originalStartOffset, originalEndNode, and originalEndOffset be range’s start node, start offset, end node, and end offset, respectively.
</li>
	<li>
<p id="cp-if-s-is-e-and">
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node は`文字~data~node$である
］：
◎
If originalStartNode is originalEndNode and it is a CharacterData node:
</p>
		<ol>
			<li id="cp-let-clone-s">
%clone ~LET `~nodeを~cloneする$( %元の始端~node )
◎
Let clone be a clone of originalStartNode.
</li>
			<li id="cp-set-clone-data-1">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の終端~offset ~MINUS %元の始端~offset ) )
◎
Set clone’s data to the result of substringing data of originalStartNode with originalStartOffset and originalEndOffset − originalStartOffset.
</li>
			<li id="cp-append-clone">
%文書片 に`~nodeを付加する$( %clone )
◎
Append clone to fragment.
</li>
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data of originalStartNode with originalStartOffset, originalEndOffset − originalStartOffset, and the empty string.
</li>
			<li id="cp-ret-flag">
~RET %文書片
◎
Return fragment.
</li>
		</ol>
	</li>
	<li id="cp-let-common-anc">
%共通な広義-先祖 ~LET
( %元の始端~node, %元の終端~node )
の`共通な広義-先祖$
◎
Let commonAncestor be originalStartNode.
◎
While commonAncestor is not an inclusive ancestor of originalEndNode:＼
set commonAncestor to its own parent.
</li>
	<li id="cp-let-1st-pcc-null">
%部分的に包含された最初の子 ~LET ~NULL
◎
Let firstPartiallyContainedChild be null.
</li>
	<li id="cp-set-1st-pcc-if">
~IF［
%元の始端~node は %元の終端~node の`広義-先祖$でない
］
⇒
%部分的に包含された最初の子 ~SET
%範囲o に`部分的に包含され$ている［
%共通な広義-先祖 の`子$
］のうち，最初のもの
◎
If originalStartNode is not an inclusive ancestor of originalEndNode, then set firstPartiallyContainedChild to the first child of commonAncestor that is partially contained in range.
</li>
	<li id="cp-let-last-pcc-null">
%部分的に包含された最後の子 ~LET ~NULL
◎
Let lastPartiallyContainedChild be null.
</li>
	<li id="cp-set-last-pcc-if">
		<p>
~IF［
%元の終端~node は %元の始端~node の`広義-先祖$でない
］
⇒
%部分的に包含された最後の子 ~SET
%範囲o に`部分的に包含され$ている［
%共通な広義-先祖 の`子$
］のうち，最後のもの
◎
If originalEndNode is not an inclusive ancestor of originalStartNode, then set lastPartiallyContainedChild to the last child of commonAncestor that is partially contained in range.
</p>

<p class="note">注記：
これらの変数~代入は実際に常にイミを成す。
例えば， %元の始端~node が %元の終端~node の`広義-先祖$でない場合、［
%元の始端~node ~EQ %共通な広義-先祖
］にはなり得ないので［
%元の始端~node の広義-先祖であって %共通な広義-先祖 の子孫でもあるもの
］が 1 つ以上あり，それらは %範囲o に`部分的に包含され$、
それらのうち %共通な広義-先祖 の子であるものが該当するものになる。
逆の場合も同様になる。
また、
2 つの子がいずれも定義されたなら，それらは決して等しくならないことにも注意。
◎
These variable assignments do actually always make sense. For instance, if originalStartNode is not an inclusive ancestor of originalEndNode, originalStartNode is itself partially contained in range, and so are all its ancestors up until a child of commonAncestor. commonAncestor cannot be originalStartNode, because it has to be an inclusive ancestor of originalEndNode. The other case is similar. Also, notice that the two children will never be equal if both are defined.
</li>
	<li id="cp-let-contained">
%包含された子~群 ~LET 次を満たす`~node$たちが成す，`~tree順序$による~list
⇒
［
%共通な広義-先祖 の`子$である
］~AND
%範囲o に`包含され$ている
］
◎
Let containedChildren be a list of all children of commonAncestor that are contained in range, in tree order.
</li>
	<li id="cp-throw-if-a-doctype">
<p>
~IF［
%包含された子~群 内に`~doctype$が在る
］
⇒
~THROW `HierarchyRequestError$E
◎
If any member of containedChildren is a doctype, then throw a "HierarchyRequestError" DOMException.
</p>

<p class="note">注記：
`~doctype$が`部分的に包含され$ることは決してないので、
部分的に包含される~nodeを気にする必要はない。
それは 範囲o の境界点
【始端~node／終端~node】
にはなり得ず, 何かの先祖にもなり得ない。
◎
We do not have to worry about the first or last partially contained node, because a doctype can never be partially contained. It cannot be a boundary point of a range, and it cannot be the ancestor of anything.
</p>
	</li>
	<!--cp-let-new-node-new-offset-->
	<!--cp-let-new-if-->
	<li>
<p>
~ELSE
⇒＃
%新-~node ~SET %共通な広義-先祖；
%新-~offset ~SET %部分的に包含された最初の子 の`~index$ ~PLUS 1
</p>

<p class="trans-note">【
ここの訳は、
原文の記述と同じ結果を得るものに簡略化している。
】</p>

◎
Otherwise:
• Let referenceNode be originalStartNode.
• While referenceNode’s parent is non-null and is not an inclusive ancestor of originalEndNode:＼
set referenceNode to its parent.
• Set newNode to the parent of referenceNode, and newOffset to referenceNode’s index + 1.
• If referenceNode’s parent is null, it would be the root of range. And then it would be an inclusive ancestor of originalEndNode and we could not reach this point.
</li>
	<li>
<p id="cp-if-1st-pcc-is-cdata">
~IF［
%部分的に包含された最初の子 は`文字~data~node$である
］：
◎
If firstPartiallyContainedChild is a CharacterData node:
</p>

<p class="note" id="cp-if-1st-pcc-is-cdata-note">
この事例では， %部分的に包含された最初の子 は %元の始端~node である。
◎
In this case, firstPartiallyContainedChild is originalStartNode.
</p>
		<ol>
			<!--cp-let-clone-s-->
			<li id="cp-set-clone-data-2">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の始端~node の`長さ$node ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data of originalStartNode with originalStartOffset and originalStartNode’s length − originalStartOffset.
</li>
			<!--cp-append-clone-->
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$node ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data of originalStartNode with originalStartOffset, originalStartNode’s length − originalStartOffset, and the empty string.
</li>
		</ol>
	</li>
	<li>
<p id="cp-elseif-1st-pcc-not-null">
~ELIF［
%部分的に包含された最初の子 ~NEQ ~NULL
］：
◎
Otherwise, if firstPartiallyContainedChild is non-null:
</p>
		<ol>
			<li id="cp-let-clone-1st-pcc">
%clone ~LET `~nodeを~cloneする$( %部分的に包含された最初の子 )
◎
Let clone be a clone of firstPartiallyContainedChild.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange1">
%下位-範囲o ~LET 新たな`~live範囲o$
— その
⇒＃
`始端$ ~SET `境界点$( %元の始端~node, %元の始端~offset ),
`終端$ ~SET `境界点$( %部分的に包含された最初の子, %部分的に包含された最初の子 の`長さ$node )
◎
Let subrange be a new live range whose start is (originalStartNode, originalStartOffset) and whose end is (firstPartiallyContainedChild, firstPartiallyContainedChild’s length).
</li>
			<li id="cp-let-subfrag-extract">
%下位-素片 ~LET `範囲oの中身を抽出する$( %下位-範囲o )
◎
Let subfragment be the result of extracting subrange.
</li>
			<li id="cp-append-subfrag">
%clone に`~nodeを付加する$( %下位-素片 )
◎
Append subfragment to clone.
</li>
		</ol>
	</li>
	<li>
%包含された子~群 を成す
~EACH( %包含された子 )
に対し
⇒
%文書片 に`~nodeを付加する$( %包含された子 )
◎
For each contained child of containedChildren:＼
append contained child to fragment.
</li>
	<li>
<p id="cp-if-last-pcc">
~IF［
%部分的に包含された最後の子 は`文字~data~node$である
］：
◎
If lastPartiallyContainedChild is a CharacterData node:
</p>

<p class="note" id="cp-if-last-pcc-note">注記：
この事例では， %部分的に包含された最後の子 は %元の始端~node である。
◎
In this case, lastPartiallyContainedChild is originalEndNode.
</p>
		<ol>
			<li id="cp-let-clone-end">
%clone ~LET `~nodeを~cloneする$( %元の終端~node )
◎
Let clone be a clone of originalEndNode.
</li>
			<li id="cp-set-clone-data-3">
%clone の`~data$ ~SET
%元の終端~node の`~dataの部分文字列$( 0, %元の終端~offset )
◎
Set clone’s data to the result of substringing data of originalEndNode with 0 and originalEndOffset.
</li>
			<!--cp-append-clone-->
			<li>
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
Replace data of originalEndNode with 0, originalEndOffset, and the empty string.
</li>
		</ol>
	</li>
	<li>
<p id="cp-elif-pcc-not-null">
~ELIF［
%部分的に包含された最後の子 ~NEQ ~NULL
］：
◎
Otherwise, if lastPartiallyContainedChild is non-null:
</p>
		<ol>
			<li id="cp-let-clone-last-pcc">
%clone ~LET `~nodeを~cloneする$( %部分的に包含された最後の子 )
◎
Let clone be a clone of lastPartiallyContainedChild.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange2">
%下位-範囲o ~LET 新たな`~live範囲o$
— その
⇒＃
`始端$ ~SET `境界点$( %部分的に包含された最後の子, 0 ),
`終端$ ~SET `境界点$( %元の終端~node, %元の終端~offset )
◎
Let subrange be a new live range whose start is (lastPartiallyContainedChild, 0) and whose end is (originalEndNode, originalEndOffset).
</li>
			<!--cp-let-subfrag-extract-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li>
%範囲o の
⇒＃
`始端$ ~SET `境界点$( %新-~node, %新-~offset )；
`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set range’s start and end to (newNode, newOffset).
</li>
	<!--cp-ret-flag-->
</ol>
</div>

<div class="algo">
@extractContents()
~method手続きは
⇒
~RET `範囲oの中身を抽出する$( コレ )
◎
The extractContents() method steps are to return the result of extracting this.
</div>

<div class="algo">
<p>
`範囲oの中身を~cloneする@
~algoは、
所与の
( `~live範囲o$ %範囲o )
に対し：
◎
To clone the contents of a live range range:
</p>
<ol>
	<!--cp-new-frag-->
	<!--cp-ret-frag-if-->
	<!--cp-let-bp-vars-->
	<li>
		<!--cp-if-s-is-e-and-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-1-->
			<!--cp-append-clone-->
			<!--cp-ret-flag-->
		</ol>
	</li>
	<!--cp-let-common-anc-->
	<!--cp-let-1st-pcc-null-->
	<!--cp-set-1st-pcc-if-->
	<!--cp-let-last-pcc-null-->
	<!--cp-set-last-pcc-if-->
	<!--cp-let-contained-->
	<!--cp-throw-if-a-doctype-->
	<li>
		<!--cp-if-1st-pcc-is-cdata-->
		<!--cp-if-1st-pcc-is-cdata-note-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-2-->
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-elseif-1st-pcc-not-null-->
		<ol>
			<!--cp-let-clone-1st-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange1-->

			<li id="cp-let-subfrag-clone">
%下位-素片 ~LET `範囲oの中身を~cloneする$( %下位-範囲o )
◎
Let subfragment be the result of cloning the contents of subrange.
</li>
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li>
<p>
%包含された子~群 を成す
~EACH( %包含された子 )
に対し：
◎
For each contained child of containedChildren:
</p>
		<ol>
			<li>
%clone ~LET `~nodeを~cloneする$( %包含された子, ~T )
◎
Let clone be a clone of contained child with subtree set to true.
</li>
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-if-last-pcc-->
		<!--cp-if-last-pcc-note-->
		<ol>
			<!--cp-let-clone-end-->
			<!--cp-set-clone-data-3-->
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-elif-pcc-not-null-->
		<ol>
			<!--cp-let-clone-last-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange2-->
			<!--cp-let-subfrag-clone-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<!--cp-ret-flag-->
</ol>
</div>

<div class="algo">
@cloneContents()
~method手続きは
⇒
~RET `範囲oの中身を~cloneする$( コレ )
◎
The cloneContents() method steps are to return the result of cloning the contents of this.
</div>

<div class="algo">
<p>
`範囲oの中へ挿入する@
~algoは、
所与の
( `~live範囲o$ %範囲o, `~node$ %node )
に対し：
◎
To insert a node node into a live range range:
</p>

<p class="trans-note">【
`始端$の直後に %node を挿入する。
それに伴い、
終端は，末尾側からの相対位置が変化しないように適宜ずらされる
（すなわち、［
始端／終端
］は，挿入-後においても［
先頭／末尾
］からの相対位置は不変）。
始端が`文字~data~node$の内部を指している場合、
その~nodeは始端の所で 2 つに分割される。
】</p>
<ol>
	<li>
( %始端~node, %始端~offset ) ~LET %範囲o の ( `始端~node$, `始端~offset$ )
◎
↓</li>
	<li>
<p>
~IF［
%始端~node は ~OR↓ を満たす
］…
</p>
		<ul>
			<li>
$ProcessingInstruction ~nodeである
</li>
			<li>
$Comment ~nodeである
</li>
			<li>
［
$Text `~node$である
］~AND［
その`親$ ~EQ ~NULL
］
</li>
			<li>
%始端~node ~EQ %node
</li>
		</ul>
<p>
…ならば
⇒
~THROW `HierarchyRequestError$E
</p>
◎
If range’s start node is a ProcessingInstruction or Comment node, is a Text node whose parent is null, or is node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
%基準~node ~LET ~NULL
◎
Let referenceNode be null.
</li>
	<li>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET %始端~node
◎
If range’s start node is a Text node, then set referenceNode to that Text node.
</li>
	<li>
~ELIF［
%始端~node の`子$に［
`~index$ ~EQ %始端~offset
］なるものが在る
］
⇒
%基準~node ~SET それ
◎
Otherwise, set referenceNode to the child of range’s start node whose index is range’s start offset if there is such a child; otherwise null.
</li>
	<li>
%親 ~LET ［
%基準~node ~NEQ ~NULL ならば その`親$ ／
~ELSE_ %始端~node
］
◎
Let parent be range’s start node if referenceNode is null; otherwise referenceNode’s parent.
</li>
	<li>
`親の中で子の前に挿入できるか検証する$( %node, %親, %基準~node )
◎
Ensure pre-insert validity of node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET `~Text~nodeを分割する$( %始端~node, %始端~offset )
</p>
<p class="trans-note">【
%始端~offset が 0 でも分割されることになる。
】</p>
◎
If range’s start node is a Text node, then set referenceNode to the result of splitting it with offset range’s start offset.
</li>
	<li>
~IF［
%node ~EQ %基準~node
］
⇒
%基準~node ~SET %node の`直後の同胞？$
◎
If node is referenceNode, then set referenceNode to its next sibling.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
`~nodeを除去する$( %node )
◎
If node’s parent is non-null, then remove node.
</li>
	<li>
%新-~offset ~LET ［
%基準~node ~NEQ ~NULL ならば その`~index$ ／
~ELSE_ %親 の`長さ$node
］
◎
Let newOffset be parent’s length if referenceNode is null; otherwise referenceNode’s index.
</li>
	<li>
%新-~offset ~INCBY ［
%node は`文書片$であるならば その`長さ$node ／
~ELSE_ 1
］
◎
Increase newOffset by node’s length if node is a DocumentFragment node; otherwise 1.
</li>
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %基準~node )
◎
Pre-insert node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%範囲o は`畳まれて$いる
］
⇒
%範囲o の`終端$ ~SET `境界点$( %親, %新-~offset )
</p>

<p class="trans-note">【
畳まれていない場合の終端の位置は，`~nodeを子の前に前挿入する$（手続きの中で`~nodeを子の前に挿入する$）段階で適宜ずらされる。
】</p>

◎
If range is collapsed, then set range’s end to (parent, newOffset).
</li>
</ol>
</div>

<div class="algo">
@insertNode(node)
~method手続きは
⇒
`範囲oの中へ挿入する$( コレ, %node )
◎
The insertNode(node) method steps are to insert node into this.
</div>

<div class="algo">
<p>
@surroundContents(newParent)
~method手続きは：
◎
The surroundContents(newParent) method steps are:
</p>
<ol>
	<li>
~IF［
ある非 $Text `~node$がコレに`部分的に包含され$ている
］
⇒
~THROW `InvalidStateError$E
◎
If a non-Text node is partially contained in this, then throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
%newParent は
$Document, $DocumentType, $DocumentFragment `~node$
のいずれかである
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If newParent is a Document, DocumentType, or DocumentFragment node, then throw an "InvalidNodeTypeError" DOMException.
</p>

<p class="note">注記：
歴史的な理由から、
`文字~data~node$に対しては、
この段では検査されず，後の段にて副作用とともに例外が投出される結果になる。
◎
For historical reasons CharacterData nodes are not checked here and end up throwing later on as a side effect.
</p>
	</li>
	<li>
%文書片 ~LET `範囲oの中身を抽出する$( コレ )
◎
Let fragment be the result of extracting this.
</li>
	<li>
~IF［
%newParent の`子~群$は`空$でない
］
⇒
%newParent の`全~内容を~nodeで置換する$( ~NULL )
◎
If newParent has children, then replace all with null within newParent.
</li>
	<li>
`範囲oの中へ挿入する$( コレ, %newParent )
◎
Insert newParent into this.
</li>
	<li>
%newParent に`~nodeを付加する$( %文書片 )
◎
Append fragment to newParent.
</li>
	<li>
`範囲oの中身として選択する$( コレ, %newParent )
◎
Select newParent within this.
</li>
</ol>
</div>

<div class="algo">
@cloneRange()
~method手続きは
⇒
~RET 新たな`~live範囲o$
— その
⇒＃
`始端$ ~SET コレの`始端$の複製,<!--  -->
`終端$ ~SET コレの`終端$の複製
◎
The cloneRange() method steps are to return a new live range with the same start and end as this.
</div>

<div class="algo">
<p>
@detach()
~method手続きは、
何もしない。
◎
The detach() method steps are to do nothing.＼
</p>

<p class="note">注記：
この機能性（ ^Range ~objを不能化する）は、
除去された。
互換性のため存続はするが。
◎
Its functionality (disabling a Range object) was removed, but the method itself is preserved for compatibility.
</p>
</div>

<dl class="domintro">
<!-- 
	<dt>range . cloneRange()†</dt>

	<dt>range . detach()†</dt>
-->

	<dt>%position = %range . $isPointInRange(node, offset)</dt>
	<dd>
`境界点$( %node, %offset ) が %range 内に入る†かどうかを返す。
</dd>

	<dt>%position = %range . $comparePoint(node, offset)</dt>
	<dd>
`境界点$( %node, %offset ) が
⇒＃
%range より前に位置する場合は −1 を返す／
%range 内に入る†場合は 0 を返す／
%range より後に位置する場合は 1 を返す
◎
Returns −1 if the point is before the range, 0 if the point is in the range, and 1 if the point is after the range.
</dd>

	<dd class="trans-note">【†
境界点が %range のいずれかの境界点に一致する場合も，“入る” と見なされる。
】</dd>

	<dt>%intersects = %range . $intersectsNode(node)</dt>
	<dd>
%range が %node と交わるかどうかを返す。
◎
Returns whether range intersects node.
</dd>

	<dd class="trans-note">
<p>【
%node が %range に隣接している場合
（ %range の終端（始端）が %node の `外縁な^em 始端（終端）を指す境界点に一致する場合）は、
“交わらない”。
例えば下図で `s^mk, `e^mk が %range の境界点を表すとするとき，図の~COLOR_Yが表す %node は交わらない。
】</p>

`bp-8^dgm

<p>【
一般に、
%node は %範囲o に
(1) `包含され$ているとき, または
(2) %範囲o の始端~node／終端~nodeいずれかの`広義-先祖$であるとき、
“交わる”。
】</p>
	</dd>

	<dt>$stringifier</dt>
	<dd>
範囲oを文字列~化した結果は、
範囲oにより “選択-” されているすべての~textになる。
</dd>
</dl>

<p class="trans-note">【
上の~blockに挙げた ^isPointInRange(), ^stringifier は、
原文には存在しない，この訳による補完。
】</p>

<div class="algo">
<p>
@isPointInRange(node, offset)
~method手続きは：
◎
The isPointInRange(node, offset) method steps are:
</p>
<ol>
	<li id="cp-ret-F-if-root">
~IF［
%node の`根$ ~NEQ コレの`根$rg
］
⇒
~RET ~F
◎
If node’s root is not this’s root, then return false.
</li>
	<!--cp-throw-if-doctype-->
	<!--cp-throw-if-length-->
	<li>
~IF［
`境界点$( %node, %offset ) は［［
コレの`始端$`より前$i
］~OR［
コレの`終端$`より後$i
］］］
⇒
~RET ~F
◎
If (node, offset) is before start or after end, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
@comparePoint(node, offset)
~method手続きは：
◎
The comparePoint(node, offset) method steps are:
</p>
<ol>
	<li>
~IF［
%node の`根$ ~NEQ コレの`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If node’s root is not this’s root, then throw a "WrongDocumentError" DOMException.
</li>
	<!--cp-throw-if-doctype-->
	<!--cp-throw-if-length-->
	<li>
~IF［
`境界点$( %node, %offset ) は
コレの`始端$`より前$i
］
⇒
~RET −1
◎
If (node, offset) is before start, then return −1.
</li>
	<li>
~IF［
`境界点$( %node, %offset ) は
コレの`終端$`より後$i
］
⇒
~RET 1
◎
If (node, offset) is after end, then return 1.
</li>
	<li>
~RET 0
◎
Return 0.
</li>
</ol>
</div>

<div class="algo">
<p>
@intersectsNode(node)
~method手続きは：
◎
The intersectsNode(node) method steps are:
</p>
<ol>
	<!--cp-ret-F-if-root-->
	<!--cp-let-parent-->
	<li>
~IF［
%親 ~EQ ~NULL
【！すなわち node は根】
］
⇒
~RET ~T
◎
If parent is null, then return true.
</li>
	<li>
%offset ~LET %node の`~index$
◎
Let offset be node’s index.
</li>
	<li>
~IF［
`境界点$( %親, %offset ) は コレの`終端$`より前$i
］~AND［
`境界点$( %親, %offset ~PLUS 1 ) は コレの`始端$`より後$i
【！selectNode の結果】
］
⇒
~RET ~T
◎
If (parent, offset) is before end and (parent, offset + 1) is after start, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
@stringifier
における`文字列~化の挙動$は：
◎
The stringification behavior must run these steps:
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let string be the empty string.
</li>
	<li>
( %始端~node, %始端~offset, %終端~node, %終端~offset ) ~LET コレの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
↓</li>
	<li>
<p>
~IF［
%始端~node は $Text `~node$である
］：
</p>
		<ol>
			<li>
~IF［
%始端~node ~EQ %終端~node
］
⇒
~RET %始端~node の`~data$の中の %始端~offset から %終端~offset までを`成す符号単位~部分文字列$
</li>
			<li>
%結果 に次を付加する
⇒
%始端~node の`~data$の中の %始端~offset から`終端までを成す符号単位~部分文字列$
</li>
		</ol>
◎
If this’s start node is this’s end node and it is a Text node, then return the substring of that Text node’s data beginning at this’s start offset and ending at this’s end offset.
◎
If this’s start node is a Text node, then append the substring of that node’s data from this’s start offset until the end to string.
</li>
	<li>
コレに`包含され$ている
~EACH( $Text `~node$ %~node )
に対し，`~tree順序$で
⇒
%結果 に %~node の`~data$を付加する
◎
Append the concatenation of the data of all Text nodes that are contained in this, in tree order, to string.
</li>
	<li>
~IF［
%終端~node は $Text `~node$である
］
⇒
%結果 に次を付加する
⇒
%終端~node の`~data$の中の 0 から %終端~offset までを`成す符号単位~部分文字列$
◎
If this’s end node is a Text node, then append the substring of that node’s data from its start until this’s end offset to string.
</li>
	<li>
~RET %結果
◎
Return string.
</li>
</ol>
</div>

<hr>

<p class="note">注記：
^Range ~interfaceに対する拡張として、
他の仕様にて次に挙げる~methodが定義されている
⇒＃
`createContextualFragment()＠~HTMLdynamic#dom-range-createcontextualfragment$c <del>`DOM-Parsing$r</del><ins>`HTML$r</ins>,
`getClientRects()＠~CSSOMVIEW#dom-range-getclientrects$c,
`getBoundingClientRect()＠~CSSOMVIEW#dom-range-getboundingclientrect$c `CSSOM-VIEW$r
◎
The createContextualFragment(), getClientRects(), and getBoundingClientRect() methods are defined in other specifications. [DOM-Parsing] [CSSOM-VIEW]
</p>

		</section>
	</section>
	<section id="traversal">
<h2 title="Traversal">6. 辿り</h2>

<p>
［
$NodeIterator ／ $TreeWalker
］~objを利用すれば、
`~node$`~tree$を~filterにかけながら辿れる。
◎
NodeIterator and TreeWalker objects can be used to filter and traverse node trees.
</p>

<div class="p">
<p>
各［
$NodeIterator ／ $TreeWalker
］~objには、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`作動中か@tV
⇒
真偽値
— 初期~時は ~F とする。
再入的な呼出nを避けるためにある。
</li>
	<li>
`根@tV
⇒
`~node$
— 辿られる下位treeの根を与える。
</li>
	<li>
`~whatToShow@tV
⇒
~bitmaskを成す整数
— どの型（ $Node.nodeType ）の~nodeを辿るかを指示する。
1 にされた~bitに対応する型の~nodeのみが~filterを “通過する” 。
</li>
	<li>
`~filter~callback@tV
⇒
~callback ／ ~NULL
— ~callbackは、
対象を更に “濾過する” ~~条件を与える。
</li>
</ul>

<p class="trans-note">【
`作動中か$tV以外の各項の記述は、
値~型を除いて，この訳による補完。
】</p>

◎
Each NodeIterator and TreeWalker object has an associated boolean is active to avoid recursive invocations. It is initially false.
◎
Each NodeIterator and TreeWalker object also has an associated root (a node), a whatToShow (a bitmask), and a filter (a callback).
</div>

<div class="algo">
<p>
`辿器の中で~nodeを~filterにかける@
~algoは、
所与の
(［
$NodeIterator ／ $TreeWalker
］~obj %辿器, `~node$ %~node )
に対し：
◎
To filter a node node within a NodeIterator or TreeWalker object traverser:
</p>
<ol>
	<li>
~IF［
%辿器 の`作動中か$tV ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If traverser’s is active is true, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%n ~LET %~node の $Node.nodeType 属性~値 ~MINUS 1
◎
Let n be node’s nodeType attribute value − 1.
</li>
	<li>
~IF［
%辿器 の`~whatToShow$tV の %n 番の~bit（ 0 番が最下位~bitとする） ~EQ 0
【！ !((1 &lt;&lt; (node.nodeType - 1)) &amp; whatToShow) 】
］
⇒
~RET $NodeFilter.FILTER_SKIP
◎
If the nth bit (where 0 is the least significant bit) of traverser’s whatToShow is not set, then return FILTER_SKIP.
</li>
	<li>
~IF［
%辿器 の`~filter~callback$tV ~EQ ~NULL
］
⇒
~RET $NodeFilter.FILTER_ACCEPT
◎
If traverser’s filter is null, then return FILTER_ACCEPT.
</li>
	<li>
%辿器 の`作動中か$tV ~SET ~T
◎
Set traverser’s is active to true.
</li>
	<li>
<p>
%結果 ~LET `利用元~objの演算を~callする$( ↓ )
⇒＃
%辿器 の`~filter~callback$tV,
`acceptNode^l,
« %~node »
◎
Let result be the return value of call a user object’s operation with traverser’s filter, "acceptNode", and « node ».＼
</p>

<p>
例外 %e が投出されたときは、
~catchして
⇒＃
%辿器 の`作動中か$tV ~SET ~F；
~THROW %e
◎
If this throws an exception, then set traverser’s is active to false and rethrow the exception.
</p>
	</li>
	<li>
%辿器 の`作動中か$tV ~SET ~F
◎
Set traverser’s is active to false.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

		<section id="interface-nodeiterator">
<h3 title="Interface NodeIterator">6.1. ^@NodeIterator ~interface</h3>

！！
[`Exposed$=Window]
interface @NodeIterator {
  [`SameObject$] readonly attribute $Node $root;
  readonly attribute $Node $referenceNode;
  readonly attribute $boolean $pointerBeforeReferenceNode;
  readonly attribute `unsigned long$ $whatToShow;
  readonly attribute $NodeFilter? $filter;

  $Node? $nextNode();
  $Node? $previousNode();

  $undefined $detach();
};
！

<p class="note">注記：
$NodeIterator ~objは、
$Document ~obj上の $Document.createNodeIterator() ~methodを利用して作成できる。
◎
NodeIterator objects can be created using the createNodeIterator() method on Document objects.
</p>

<div class="p">
<p>
各 $NodeIterator ~objには、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`反復器~collection@
⇒
次のように設定された`~collection$
⇒＃
`根$cL ~SET ~objの`根$tV,
`~filter$cLは どの`~node$にも合致する
</li>
	<li>
`起点r@tV
⇒
`~node$
</li>
	<li>
`起点rの直前か@tV
⇒
真偽値
	</li>
</ul>

<p class="trans-note">【
( `起点r$tV, `起点rの直前か$tV )
が成す組は、［
`反復器で辿る$とき，どの~nodeから探索し始めるか
］を指す~pointerを表現する。
`起点r$tV（初期~時は先頭の~nodeである`根$tVにされる）は、
“現在の” ~nodeを表す。
~pointerは、
`起点rの直前か$tV （初期~時は ~T ）に応じて，
現在の~nodeの “直前” （ ~T ）か “直後” （ ~F ）を指す
（したがって、
初期~時の~pointerは`根$tVの直前を指す）。
】</p>

◎
Each NodeIterator object has an associated iterator collection, which is a collection rooted at the NodeIterator object’s root, whose filter matches any node.
◎
Each NodeIterator object also has an associated reference (a node) and pointer before reference (a boolean).
</div>

<p>
</p>

<p class="note">注記：
前に言及したとおり、
$NodeIterator ~objには［
`作動中か$tV,
`根$tV,
`~whatToShow$tV,
`~filter~callback$tV
］も結付けられる。
◎
As mentioned earlier, NodeIterator objects have an associated is active, root, whatToShow, and filter as well.
</p>

<div class="algo">
<p>
`~node反復器~用の除去-前の手続き@
は、
所与の
( $NodeIterator ~obj %反復器, `~node$ %除去される~node )
に対し：
◎
The NodeIterator pre-remove steps given a NodeIterator object nodeIterator and node toBeRemovedNode, are:
</p>
<ol>
	<li>
~IF［
%除去される~node は %反復器 の`起点r$tVの`広義-先祖$でない
］~OR［
%除去される~node ~EQ %反復器 の`根$tV
］
⇒
~RET
◎
If toBeRemovedNode is not an inclusive ancestor of nodeIterator’s reference, or toBeRemovedNode is nodeIterator’s root, then return.
</li>
	<li>
<p>
~IF［
%反復器 の`起点rの直前か$tV ~EQ ~T
］：
◎
If nodeIterator’s pointer before reference is true:
</p>
		<ol>
			<li>
<p>
%直後の ~LET ~AND↓ を満たす`~node$のうち，`最初のもの？$：
</p>

				<ul>
					<li>
%除去される~node に`後続-$する
</li>
					<li>
%反復器 の`根$tVの`広義-子孫$である
</li>
					<li>
%除去される~node の`広義-子孫$でない
</li>
				</ul>
◎
Let next be toBeRemovedNode’s first following node that is an inclusive descendant of nodeIterator’s root and is not an inclusive descendant of toBeRemovedNode, if there is such a node; otherwise null.
</li>
			<li>
~IF［
%直後の ~NEQ ~NULL
］
⇒＃
%反復器 の`起点r$tV ~SET %直後の；
~RET
◎
If next is non-null, then set nodeIterator’s reference to next and return.
</li>
			<li>
%反復器 の`起点rの直前か$tV ~SET ~F
◎
Set nodeIterator’s pointer before reference to false.
</li>
		</ol>
	</li>
	<li>
%直前の同胞 ~LET %除去される~node の`直前の同胞？$
◎
↓</li>
	<li>
%反復器 の`起点r$tV ~SET %直前の同胞 に応じて
⇒＃
~NULL ならば %除去される~node の`親$ ／
~ELSE_ %直前の同胞 の`広義-子孫$のうち `最後のもの？$
◎
Set nodeIterator’s reference to toBeRemovedNode’s parent, if toBeRemovedNode’s previous sibling is null, and to the inclusive descendant of toBeRemovedNode’s previous sibling that appears last in tree order otherwise.
</li>
</ol>
</div>

<hr>

<div class="algo">
@root
取得子~手続きは
⇒
~RET コレの`根$tV
◎
The root getter steps are to return this’s root.
</div>

<div class="algo">
@referenceNode
取得子~手続きは
⇒
~RET コレの`起点r$tV
◎
The referenceNode getter steps are to return this’s reference.
</div>

<div class="algo">
@pointerBeforeReferenceNode
取得子~手続きは
⇒
~RET コレの`起点rの直前か$tV
◎
The pointerBeforeReferenceNode getter steps are to return this’s pointer before reference.
</div>

<div class="algo">
@whatToShow
取得子~手続きは
⇒
~RET コレの`~whatToShow$tV
◎
The whatToShow getter steps are to return this’s whatToShow.
</div>

<div class="algo">
@filter
取得子~手続きは
⇒
~RET コレの`~filter~callback$tV
◎
The filter getter steps are to return this’s filter.
</div>

<div class="algo">
<p>
`反復器で辿る@
~algoは、
所与の
( $NodeIterator ~obj %反復器, %向き ~IN { `順^i, `逆^i } )
に対し：
◎
To traverse, given a NodeIterator object iterator and "next" or "previous" type:
</p>
<ol>
	<li>
%~node ~LET %反復器 の`起点r$tV
◎
Let node be iterator’s reference.
</li>
	<li>
%直前か ~LET %反復器 の`起点rの直前か$tV
◎
Let beforeNode be iterator’s pointer before reference.
</li>
	<li>
%~collection ~LET %反復器 の`反復器~collection$
◎
↓</li>
	<li>
<p id="cp-repeat">
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
~IF［
%向き ~EQ `順^i
］：
◎
If type is next":
</p>
				<ol>
					<li>
<p>
~IF［
%直前か ~EQ ~F
］：
◎
If beforeNode is false, then＼
</p>
						<ol>
							<li>
%~node ~SET %~collection の中で %~node に`後続-$する`~node$のうち，`最初のもの？$
◎
set node to the first node following node in iterator’s iterator collection.＼
</li>
							<li>
~IF［
%~node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%直前か ~SET ~F
◎
If beforeNode is true, then set it to false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %向き ~EQ `逆^i ）：
◎
Otherwise:
</p>
				<ol>
					<li>
<p>
~IF［
%直前か ~EQ ~T
］：
◎
If beforeNode is true, then＼
</p>
						<ol>
							<li>
%~node ~SET %~collection の中で %~node に`先行-$する`~node$のうち，`最後のもの？$
◎
set node to the first node preceding node in iterator’s iterator collection.＼
</li>
							<li>
~IF［
%~node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%直前か ~SET ~T
◎
If beforeNode is false, then set it to true.
</li>
				</ol>
			</li>
			<li>
~IF［
`辿器の中で~nodeを~filterにかける$( %反復器, %~node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~BREAK
◎
Let result be the result of filtering node within iterator.
◎
If result is FILTER_ACCEPT, then break.
</li>
		</ol>
	</li>
	<li>
%反復器 の`起点r$tV ~SET %~node
◎
Set iterator’s reference to node.
</li>
	<li>
%反復器 の`起点rの直前か$tV ~SET %直前か
◎
Set iterator’s pointer before reference to beforeNode.
</li>
	<li>
~RET %~node
◎
Return node.
</li>
</ol>

<p class="trans-note">【
辿り方向が前回と逆向きに切り替わった場合、
探索処理は，前回の辿りによる
“現在の” ~node（ `起点r$tV ）から開始されることに注意（その直後の／直前の~nodeからではなく）。
探索した結果，`~filter$cLに合致する~nodeが見出されなかった場合、
`起点r$tVは変更されない。
見出された場合、
`起点r$tVは，新たに見出された~nodeになり、
`起点rの直前か$tV（ “現在の” 辿り方向）は，渡された %向き を反映するようになる
（ ~F が `順^i 方向に対応する）。
】</p>
</div>

<div class="algo">
@nextNode()
~method手続きは
⇒
~RET `反復器で辿る$( コレ, `順^i )
◎
The nextNode() method steps are to return the result of traversing with this and "next".
</div>

<div class="algo">
@previousNode()
~method手続きは
⇒
~RET `反復器で辿る$( コレ, `逆^i )
◎
The previousNode() method steps are to return the result of traversing with this and "previous".
</div>

<div class="algo">
<p>
@detach()
~method手続きは、
何もしない。
◎
The detach() method steps are to do nothing.＼
</p>

<p class="note">注記：
この機能性（ ^NodeIterator ~objを不能化する）は、
除去された。
互換性のため存続はするが。
◎
Its functionality (disabling a NodeIterator object) was removed, but the method itself is preserved for compatibility.
</p>
</div>

		</section>
		<section id="interface-treewalker">
<h3 title="Interface TreeWalker">6.2. ^@TreeWalker ~interface</h3>

！！
[`Exposed$=Window]
interface @TreeWalker {
  [`SameObject$] readonly attribute $Node $root;
  readonly attribute `unsigned long$ $whatToShow;
  readonly attribute $NodeFilter? $filter;
           attribute $Node $currentNode;

  $Node? $parentNode();
  $Node? $firstChild();
  $Node? $lastChild();
  $Node? $previousSibling();
  $Node? $nextSibling();
  $Node? $previousNode();
  $Node? $nextNode();
};
！

<p class="note">注記：
$TreeWalker ~objは、
$Document ~obj上の $Document.createTreeWalker() ~methodを利用して作成できる。
◎
TreeWalker objects can be created using the createTreeWalker() method on Document objects.
</p>

<p>
各 $TreeWalker ~objには、
`現-~node@tV
（ `~node$ ）が結付けられる。
◎
Each TreeWalker object has an associated current (a node).
</p>

<p class="note">注記：
前に言及したとおり、
$TreeWalker ~objには［
`根$tV,
`~whatToShow$tV,
`~filter~callback$tV
］も結付けられる。
◎
As mentioned earlier TreeWalker objects have an associated root, whatToShow, and filter as well.
</p>

<div class="algo">
@root
取得子~手続きは
⇒
~RET コレの`根$tV
◎
The root getter steps are to return this’s root.
</div>

<div class="algo">
@whatToShow
取得子~手続きは
⇒
~RET コレの`~whatToShow$tV
◎
The whatToShow getter steps are to return this’s whatToShow.
</div>

<div class="algo">
@filter
取得子~手続きは
⇒
~RET コレの`~filter~callback$tV
◎
The filter getter steps are to return this’s filter.
</div>

<div class="algo">
@currentNode
取得子~手続きは
⇒
~RET コレの`現-~node$tV
◎
The currentNode getter steps are to return this’s current.
</div>

<div class="algo">
$currentNode 設定子~手続きは
⇒
コレの`現-~node$tV ~SET 所与の値
◎
The currentNode setter steps are to set this’s current to the given value.
</div>

<hr>

<div class="algo">
<p>
@parentNode()
~method手続きは：
◎
The parentNode() method steps are:
</p>
<ol>
	<li id="cp-let-current">
%~node ~LET コレの`現-~node$tV
◎
Let node be this’s current.
</li>
	<li>
<p>
~WHILE［
%~node の`親$ ~NEQ ~NULL
］~AND［
%~node ~NEQ コレの`根$tV
］：
</p>
		<ol>
			<li>
%~node ~SET %~node の`親$
</li>
			<li>
%結果 ~LET `辿器の中で~nodeを~filterにかける$( コレ, %~node )
</li>
			<li>
~IF［
%結果 ~NEQ $NodeFilter.FILTER_ACCEPT
］
⇒
~CONTINUE
</li>
			<li>
コレの`現-~node$tV ~SET %~node
</li>
			<li>
~RET %~node
</li>
		</ol>
◎
While node is non-null and is not this’s root:
• Set node to node’s parent.
• If node is non-null and＼
filtering node within this returns FILTER_ACCEPT, then set this’s current to node and return node.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`子~群を辿る@
~algoは、
所与の
( %walker, %向き ~IN { `最初から^i, `最後から^i } )
に対し：
◎
To traverse children, given a walker and type, run these steps:
</p>
<ol>
	<li id="cp-let-current-tw">
%~node ~LET %walker の`現-~node$tV
◎
Let node be walker’s current.
</li>
	<li>
%~node ~SET %向き に応じて
⇒＃
`最初から^i ならば %~node の`最初の子？$ ／
`最後から^i ならば %~node の`最後の子？$
◎
Set node to node’s first child if type is first, and node’s last child if type is last.
</li>
	<li>
<p>
~WHILE［
%~node ~NEQ ~NULL
］：
◎
While node is non-null:
</p>
		<ol>
			<li id="cp-let-filter-result">
%結果 ~LET
`辿器の中で~nodeを~filterにかける$( %walker, %~node )
◎
Let result be the result of filtering node within walker.
</li>
			<li id="cp-set-current-if-accept-tw">
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
%walker の`現-~node$tV ~SET %~node；
~RET %~node
◎
If result is FILTER_ACCEPT, then set walker’s current to node and return node.
</li>
			<li>
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_SKIP
］：
◎
If result is FILTER_SKIP:
</p>
				<ol>
					<li>
%子 ~LET %向き に応じて
⇒＃
`最初から^i ならば %~node の`最初の子？$ ／
`最後から^i ならば %~node の`最後の子？$
◎
Let child be node’s first child if type is first, and node’s last child if type is last.
</li>
					<li>
~IF［
%子 ~NEQ ~NULL
］
⇒＃
%~node ~SET %子；
~CONTINUE
◎
If child is non-null, then set node to child and continue.
</li>
				</ol>
			</li>
			<li>
<p>
~WHILE［
%~node ~NEQ ~NULL
］：
◎
While node is non-null:
</p>
				<ol>
					<li>
%同胞 ~LET %向き に応じて
⇒＃
`最初から^i ならば %~node の`直後の同胞？$ ／
`最後から^i ならば %~node の`直前の同胞？$
◎
Let sibling be node’s next sibling if type is first, and node’s previous sibling if type is last.
</li>
					<li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒＃
%~node ~SET %同胞；
~BREAK
◎
If sibling is non-null, then set node to sibling and break.
</li>
					<li>
%親 ~LET %~node の`親$
◎
Let parent be node’s parent.
</li>
					<li>
~IF［
%親 ~IN { ~NULL, %walker の`根$tV, %walker の`現-~node$tV }
］
⇒
~RET ~NULL
◎
If parent is null, walker’s root, or walker’s current, then return null.
</li>
					<li>
%~node ~SET %親
◎
Set node to parent.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
@firstChild()
~method手続きは
⇒
~RET `子~群を辿る$( コレ, `最初から^i )
◎
The firstChild() method steps are to traverse children with this and first.
</div>

<div class="algo">
@lastChild()
~method手続きは
⇒
~RET `子~群を辿る$( コレ, `最後から^i )
◎
The lastChild() method steps are to traverse children with this and last.
</div>

<div class="algo">
<p>
`同胞たちを辿る@
~algoは、
所与の
( %walker, %向き ~IN { `順^i, `逆^i } )
に対し：
◎
To traverse siblings, given a walker and type, run these steps:
</p>
<ol>
	<!--cp-let-current-tw-->
	<li>
~IF［
%~node ~EQ %walker の`根$tV
］
⇒
~RET ~NULL
◎
If node is root, then return null.
</li>
	<li>
<!--cp-repeat-->
		<ol>
			<li>
%同胞 ~LET %向き に応じて
⇒＃
`順^i ならば %~node の`直後の同胞？$ ／
`逆^i ならば %~node の`直前の同胞？$
◎
Let sibling be node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
			<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is non-null:
</p>
				<ol>
					<li>
%~node ~SET %同胞
◎

Set node to sibling.
</li>
					<!--cp-let-filter-result-->
					<!--cp-set-current-if-accept-tw-->
					<li>
%同胞 ~SET %向き に応じて
⇒＃
`順^i ならば %~node の`最初の子？$ ／
`逆^i ならば %~node の`最後の子？$
◎
Set sibling to node’s first child if type is next, and node’s last child if type is previous.
</li>
					<li>
~IF［
%結果 ~EQ $NodeFilter.FILTER_REJECT
］~OR［
%同胞 ~EQ ~NULL
］
⇒
%同胞 ~SET %向き に応じて
⇒＃
`順^i ならば %~node の`直後の同胞？$ ／
`逆^i ならば %~node の`直前の同胞？$
◎
If result is FILTER_REJECT or sibling is null, then set sibling to node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
				</ol>
			</li>
			<li>
%~node ~SET %~node の`親$
◎
Set node to node’s parent.
</li>
			<li>
~IF［
%~node ~IN { ~NULL, %walker の`根$tV }
］
⇒
~RET ~NULL
◎
If node is null or walker’s root, then return null.
</li>
			<li>
~IF［
`辿器の中で~nodeを~filterにかける$( コレ, %~node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~RET ~NULL
◎
If the return value of filtering node within walker is FILTER_ACCEPT, then return null.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
@nextSibling()
~method手続きは
⇒
~RET `同胞たちを辿る$( コレ, `順^i )
◎
The nextSibling() method steps are to traverse siblings with this and next.
</div>

<div class="algo">
@previousSibling()
~method手続きは
⇒
~RET `同胞たちを辿る$( コレ, `逆^i )
◎
The previousSibling() method steps are to traverse siblings with this and previous.
</div>

<div class="algo">
<p>
@previousNode()
~method手続きは：
◎
The previousNode() method steps are:
</p>
<ol>
	<!--cp-let-current-->
	<li>
<p>
~WHILE［
%~node ~NEQ コレの`根$tV
］：
◎
While node is not this’s root:
</p>
		<ol>
			<li>
%同胞 ~LET %~node の`直前の同胞？$
◎
Let sibling be node’s previous sibling.
</li>
			<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is non-null:
</p>
				<ol>
					<li>
%~node ~SET %同胞
◎
Set node to sibling.
</li>
					<li>
%結果 ~LET
`辿器の中で~nodeを~filterにかける$( コレ, %~node )
◎
Let result be the result of filtering node within this.
</li>
					<li>
<p id="cp-while-not-REJECT-and-has-child">
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%~node の`子~群$は`空$でない
］：
◎
While result is not FILTER_REJECT and node has a child:
</p>
						<ol>
							<li>
%~node ~SET %~node の`最後の子？$
◎
Set node to node’s last child.
</li>
							<li id="cp-set-filter-result">
%結果 ~SET `辿器の中で~nodeを~filterにかける$( コレ, %~node )
◎
Set result to the result of filtering node within this.
</li>
						</ol>
					</li>
					<li id="cp-set-current-if-accept">
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
コレの`現-~node$tV ~SET %~node；
~RET %~node
◎
If result is FILTER_ACCEPT, then set this’s current to node and return node.
</li>
					<li>
%同胞 ~SET %~node の`直前の同胞？$
◎
Set sibling to node’s previous sibling.
</li>
				</ol>
			</li>
			<li>
~IF［
%~node ~EQ コレの`根$tV
］~OR［
%~node の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is this’s root or node’s parent is null, then return null.
</li>
			<li>
%~node ~SET %~node の`親$
◎
Set node to node’s parent.
</li>
			<li>
%結果 ~LET `辿器の中で~nodeを~filterにかける$( コレ, %~node )
◎
↓</li>
			<li>
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
コレの`現-~node$tV ~SET %~node；
~RET %~node
◎
If the return value of filtering node within this is FILTER_ACCEPT, then set this’s current to node and return node.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
@nextNode()
~method手続きは：
◎
The nextNode() method steps are:
</p>
<ol>
	<!--cp-let-current-->
	<li>
%結果 ~LET $NodeFilter.FILTER_ACCEPT
◎
Let result be FILTER_ACCEPT.
</li>
	<li>
<!--cp-repeat-->
		<ol>
			<li>
<!--cp-while-not-REJECT-and-has-child-->
				<ol>
					<li>
%~node ~SET %~node の`最初の子？$
◎
Set node to its first child.
</li>
					<!--cp-set-filter-result-->
					<!--cp-set-current-if-accept-->
				</ol>
			</li>
			<li>
%同胞 ~LET ~NULL
◎
Let sibling be null.
</li>
			<li>
%temporary ~LET %~node
◎
Let temporary be node.
</li>
			<li>
<p>
~WHILE［
%temporary ~NEQ ~NULL
］：
◎
While temporary is non-null:
</p>
				<ol>
					<li>
~IF［
%temporary ~EQ コレの`根$tV
］
⇒
~RET ~NULL
◎
If temporary is this’s root, then return null.
</li>
					<li>
%同胞 ~SET %temporary の`直後の同胞？$
◎
Set sibling to temporary’s next sibling.
</li>
					<li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒＃
%~node ~SET %同胞；
~BREAK
◎
If sibling is non-null, then set node to sibling and break.
</li>
					<li>
%temporary ~SET %temporary の`親$
◎
Set temporary to temporary’s parent.
</li>
				</ol>
			</li>
			<!--cp-set-filter-result-->
			<!--cp-set-current-if-accept-->
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="interface-nodefilter">
<h3 title="Interface NodeFilter">6.3. ^@NodeFilter ~interface</h3>

！！
[`Exposed$=Window]
callback interface @NodeFilter {
  /* <span class="comment">
$acceptNode() 用の定数
◎
Constants for acceptNode()
</span> */
  const `unsigned short$ $FILTER_ACCEPT = 1;
  const `unsigned short$ $FILTER_REJECT = 2;
  const `unsigned short$ $FILTER_SKIP = 3;

  /* <span class="comment">
`~whatToShow$tV 用の定数
◎
Constants for whatToShow
</span> */
  const `unsigned long$ $SHOW_ALL = 0xFFFFFFFF;
  const `unsigned long$ $SHOW_ELEMENT = 0x1;
  const `unsigned long$ $SHOW_ATTRIBUTE = 0x2;
  const `unsigned long$ $SHOW_TEXT = 0x4;
  const `unsigned long$ $SHOW_CDATA_SECTION = 0x8;
  const `unsigned long$ @SHOW_ENTITY_REFERENCE = 0x10; // <!--cp-legacy-->
  const `unsigned long$ @SHOW_ENTITY = 0x20; // <!--cp-legacy-->
  const `unsigned long$ $SHOW_PROCESSING_INSTRUCTION = 0x40;
  const `unsigned long$ $SHOW_COMMENT = 0x80;
  const `unsigned long$ $SHOW_DOCUMENT = 0x100;
  const `unsigned long$ $SHOW_DOCUMENT_TYPE = 0x200;
  const `unsigned long$ $SHOW_DOCUMENT_FRAGMENT = 0x400;
  const `unsigned long$ @SHOW_NOTATION = 0x800; // <!--cp-legacy-->

  `unsigned short$ @acceptNode($Node %node);
};
！

<p class="note">注記：
$NodeFilter ~objは、［
$NodeIterator ／ $TreeWalker
］用の`~filter~callback$tVとして利用できる。
また、
それら用の`~whatToShow$tVとして~bitmask定数を供する。
$NodeFilter ~objは、
概して，~JS関数として実装される。
◎
NodeFilter objects can be used as filter for NodeIterator and TreeWalker objects and also provide constants for their whatToShow bitmask. A NodeFilter object is typically implemented as a JavaScript function.
</p>

<p>
`~filter~callback$tVの返り値には、
次に挙げる定数を利用できる（括弧内は数-値）
⇒＃
@FILTER_ACCEPT (1),
@FILTER_REJECT (2),
@FILTER_SKIP (3)
◎
These constants can be used as filter return value:
• FILTER_ACCEPT (1);
• FILTER_REJECT (2);
• FILTER_SKIP (3).
</p>

<div class="trans-note">
<p>【
これらの定数の意味は：
】</p>
<ul>
	<li>
$FILTER_ACCEPT
⇒
~nodeは~filterを “通過する”。
</li>
	<li>
$FILTER_REJECT
⇒
$NodeIterator に利用されている下では、
$FILTER_SKIP と同じ結果になる。
$TreeWalker に利用されている下では、
~nodeはその子孫も含めて “濾過される”。
</li>
	<li>
$FILTER_SKIP
⇒
~node自身は “濾過される” が、
その子孫は，依然として~filterの対象になり得る。
</li>
</ul>
</div>

<p>
`~whatToShow$tV用には、
次に挙げる定数を利用できる（括弧内は数-値）：
◎
These constants can be used for whatToShow:
</p>

<ul><li>@SHOW_ALL (4294967295 ~EQ 0xFFFFFFFF)
<li>@SHOW_ELEMENT (1)
<li>@SHOW_ATTRIBUTE (2)
<li>@SHOW_TEXT (4)
<li>@SHOW_CDATA_SECTION (8)
<li>@SHOW_PROCESSING_INSTRUCTION (64 ~EQ 0x40)
<li>@SHOW_COMMENT (128 ~EQ 0x80)
<li>@SHOW_DOCUMENT (256 ~EQ 0x100)
<li>@SHOW_DOCUMENT_TYPE (512 ~EQ 0x200)
<li>@SHOW_DOCUMENT_FRAGMENT (1024 ~EQ 0x400)
</ul>

		</section>
	</section>
	<section id="sets">
<h2 title="Sets">7. ~token集合</h2>

<p class="note">
Yes, the name $DOMTokenList is an unfortunate legacy mishap.
</p>

		<section id="interface-domtokenlist">
<h3 title="Interface DOMTokenList">7.1. ^@DOMTokenList ~interface</h3>

！！
[`Exposed$=Window]
interface @DOMTokenList {
  readonly attribute `unsigned long$ $length;
  getter $DOMString? $item(`unsigned long$ %index);
  $boolean $contains($DOMString %token);
  [`CEReactions$] $undefined $add($DOMString<!-- -->... %tokens);
  [`CEReactions$] $undefined $remove($DOMString<!-- -->... %tokens);
  [`CEReactions$] $boolean $toggle($DOMString %token, optional $boolean %force);
  [`CEReactions$] $boolean $replace($DOMString %token, $DOMString %newToken);
  $boolean $supports($DOMString %token);
  [`CEReactions$] @stringifier attribute $DOMString $value;
  iterable&lt;$DOMString&gt;;
};
！

<div class="p">
<p>
各 $DOMTokenList には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~token集合@tL
⇒
~tokenたちが成す`有順序~集合$
— 初期~時は`空$とする。
</li>
	<li>
`要素@tL
⇒
ある`要素$
</li>
	<li>
`属性o名@tL
⇒
ある［
`属性o$の`局所~名$a
］
</li>
</ul>
◎
A DOMTokenList object has an associated token set (a set), which is initially empty.
◎
A DOMTokenList object also has an associated element (an element) and an attribute name (an attribute’s local name).
</div>

<p>
`適用-可能な仕様$は、
$DOMTokenList の
( `要素$tL, `属性o名$tL )
用に
`~supportする~token集合@tL
を定義してもヨイ
— これは、［
ε ／~tokenたちが成す集合
］であり，他が指定されない限り ε （未定義）とする。
◎
Specifications may define supported tokens for a DOMTokenList’s element and attribute name.
</p>

<p class="trans-note">【
もっと精確に述べるなら、
所与の
( `要素$ %要素, %要素 が有し得る属性oの`局所~名$a %属性o名 )
に対し， $DOMTokenList のうち［
その`要素$tL ~EQ %要素,
その`属性o名$tL ~EQ %属性o名
］を満たすもの用に`~supportする~token集合$tL。
これは、
関連な要素が文脈から明白な所では，
単に “%属性o名 が`~supportする~token集合$tLは” のような句で記されることが多い。
】</p>

<p>
所与の $DOMTokenList ~obj %O 対しては、
以下が定義される
— 以下，
( %要素, %属性o名 )
は
( %O の`要素$tL, %O の`属性o名$tL )
を指すとする：
◎
↓</p>
<ul>
	<li class="algo">
<p>
%O 上で
`~tokenを検証する@
~algoは、
所与の
( %~token )
に対し：
◎
A DOMTokenList object set’s validation steps for a given token are:
</p>
		<ol>
			<li>
%~token集合 ~LET ( %要素, %属性o名 ) 用に %O が`~supportする~token集合$tL
◎
↓</li>
			<li>
~IF［
%~token集合 ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If set’s element and attribute name does not define supported tokens, then throw a TypeError.
</li>
			<li>
~RET ~IS［
`~ASCII小文字~化する$( %~token ) ~IN %~token集合
］
◎
Let lowercaseToken be token, in ASCII lowercase.
◎
If lowercaseToken is present in the supported tokens of set’s element and attribute name, then return true.
◎
Return false.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%O の
`更新~手続き@tL
は：
◎
A DOMTokenList object set’s update steps are:
</p>
		<ol>
			<li>
~IF［
%要素 の`属性oを~nsと局所~名により取得する$( %属性o名, ~NULL ) ~EQ ~NULL
］~AND［
%O の`~token集合$tLは`空$である
］
⇒
~RET
◎
If get an attribute by namespace and local name given null, set’s attribute name, and set’s element returns null and set’s token set is empty, then return.
</li>
			<li>
%値 ~LET `有順序~集合を直列化する$( %O の`~token集合$tL )
◎
↓</li>
			<li>
%要素 の`属性o値を設定する$( %属性o名, %値 )
◎
Set an attribute value given set’s element, set’s attribute name, and the result of running the ordered set serializer for set’s token set.
</li>
		</ol>
	</li>
	<li class="algo">
%O の
`直列化-手続き@tL
は
⇒
~RET %要素 の`属性o値を取得する$( %属性o名 )
◎
A DOMTokenList object set’s serialize steps are to return the result of running get an attribute value given set’s element and set’s attribute name.
</li>
	<li class="algo">
<p>
%要素 用の`属性o変更-時の手続き$は、
所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
A DOMTokenList object set has these attribute change steps for set’s element:
</p>
		<ol>
			 <li>
<p>
~IF［
%局所~名 ~EQ %属性o名
］~AND［
%~ns ~EQ ~NULL
］：
</p>
				<ol>
					<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%O の`~token集合$tLを`空にする$
</li>
					 <li>
~ELSE
⇒
%O の`~token集合$tL ~SET `有順序~集合として構文解析する$( %値 )
</li>
				</ol>
◎
If localName is set’s attribute name, namespace is null, and value is null, then empty token set.
◎
Otherwise, if localName is set’s attribute name and namespace is null, then set set’s token set to value, parsed.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%O の作成-時には、
次を走らす：
◎
When a DOMTokenList object set is created:
</p>
		<ol>
			<li>
%値 ~LET %要素 の`属性o値を取得する$( %属性o名 )
◎
Let element be set’s element.
◎
Let attributeName be set’s attribute name.
◎
Let value be the result of getting an attribute value given element and attributeName.
</li>
			<li>
`適用-可能な仕様$にて %要素 用に`定義された各$( `属性o変更-時の手続き$ %手続き )
に対し
⇒
%手続き( %属性o名, %値, %値, ~NULL )
◎
Run the attribute change steps for element, attributeName, value, value, and null.
</li>
		</ol>
	</li>
</ul>

<dl class="domintro">
	<dt>%tokenlist . $length</dt>
	<dd>
~tokenの個数を返す。
◎
Returns the number of tokens.
</dd>

	<dt>%tokenlist . $item(index)</dt>
	<dt>%tokenlist[%index]</dt>
	<dd>
%index 番の~tokenを返す。
◎
Returns the token with index index.
</dd>

	<dt>%tokenlist . $contains(token)</dt>
	<dd>
%token が［
在るならば ~T ／
無いならば ~F
］を返す。
◎
Returns true if token is present; otherwise false.
</dd>

	<dt>%tokenlist . $add(tokens…)</dt>
	<dd>
渡された引数のうち，まだ無いものを追加する。
◎
Adds all arguments passed, except those already present.
</dd>
	<dd>
<span id="cp-throw-if-some-token-is">
`下記に該当する場合＠#_throw-if-token-is$、
例外が投出される。
</span>
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $remove(tokens…)</dt>
	<dd>
渡された引数のそれぞれを（もし在れば）除去する。
◎
Removes arguments passed, if they are present.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $toggle(token [, force])</dt>
	<dd>
<p>
%force に応じて：
</p>
		<ul>
			<li>
省略されているならば、
%token の有無を “~toggleする”。
すなわち、
%token がすでに在るならば除去し，無いならば追加する。
</li>
			<li>
~T ならば、
%token を追加する
（ $add() と同じ）。
</li>
			<li>
~F ならば、
%token を除去する
（ $remove() と同じ）。
</li>
		</ul>

<p>
その結果、
%token が［
残っていれば ~T ／
無くなっていれば ~F
］を返す。
</p>
◎
If force is not given, "toggles" token, removing it if it’s present and adding it if it’s not present. If force is true, adds token (same as add()). If force is false, removes token (same as remove()).
◎
Returns true if token is now present; otherwise false.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if token is empty.
◎
Throws an "InvalidCharacterError" DOMException if token contains any spaces.
</dd>

	<dt>%tokenlist . $replace(token, newToken)</dt>
	<dd>
	<dd>
%token を %newToken に置換する。
◎
Replaces token with newToken.
</dd>
	<dd>
%token が %newToken に［
置換されたなら ~T ／
置換されなかったなら ~F
］を返す。
◎
Returns true if token was replaced with newToken; otherwise false.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt id="_throw-if-token-is">（例外）</dt>
	<dd>
<p>
上の各種~methodに渡された文字列~引数のいずれかが，次に該当する場合、
対応する例外が投出される：
</p>
		<ul id="cp-throw-if-token-B">
			<li>
空~文字列の場合：
`SyntaxError$E
</li>
			<li>
`~ASCII空白$を含む場合：
`InvalidCharacterError$E
</li>
		</ul>
◎
↑</dd>

	<dt>%tokenlist . $supports(token)</dt>
	<dd>
`属性o名$tLが`~supportする~token集合$tLに %token が含まれて［
いれば ~T ／ いなければ ~F
］を返す。
◎
Returns true if token is in the associated attribute’s supported tokens. Returns false otherwise.
</dd>
	<dd>
`~supportする~token集合$tLが定義されていない場合、
`TypeError$E が投出される。
◎
Throws a TypeError if the associated attribute has no supported tokens defined.
</dd>

	<dt>%tokenlist . $value</dt>
	<dd>
結付けられた`~token集合$tLを文字列として返す。
◎
Returns the associated set as string.
</dd>
	<dd>
設定して結付けられた属性を変更できる。
◎
Can be set, to change the associated attribute.
</dd>
</dl>

<div class="algo">
@length
取得子~手続きは
⇒
~RET コレの`~token集合$tLの`~size$
◎
The length getter steps are to return this’s token set’s size.
</div>

<p>
$DOMTokenList ~obj %O が`~supportする~prop~index$は、
0 以上［
%O の`~token集合$tLの`~size$
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to object’s token set’s size − 1, unless token set is empty, in which case there are no supported property indices.
</p>

<div class="algo">
<p>
@item(index)
~method手続きは：
◎
The item(index) method steps are:
</p>
<ol>
	<li>
~IF［
%index ~NIN { コレが`~supportする~prop~index$ }
］
⇒
~RET ~NULL
◎
If index is equal to or greater than this’s token set’s size, then return null.
</li>
	<li>
~RET コレの`~token集合$tL[ %index ]
◎
Return this’s token set[index].
</li>
</ol>
</div>

<div class="algo">
<p>
`~tokenを検査する@
~algoは、
所与の
( %token )
に対し：
</p>
<ol>
	<li>
~IF［
%token ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
</li>
	<li>
~IF［
%token は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
</li>
</ol>

◎
↓↓</div>

<div class="algo">
@contains(token)
~method手続きは
⇒
~RET ~IS［
%token ~IN コレの`~token集合$tL
］
◎
The contains(token) method steps are to return true if this’s token set[token] exists; otherwise false.
</div>

<div class="algo">
<p>
@add(tokens…)
~method手続きは：
◎
The add(tokens…) method steps are:
</p>
<ol>
	<li id="cp-throw-if-invalid-char">
%tokens を成す
~EACH( %token )
に対し，与えられた順に
⇒
`~tokenを検査する$( %token )
◎
For each token of tokens:
• If token is the empty string, then throw a "SyntaxError" DOMException.
• If token contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
%tokens を成す
~EACH( %token )
に対し
⇒
コレの`~token集合$tLに %token を`付加する$set
◎
For each token of tokens:＼
append token to this’s token set.
</li>
	<li id="cp-update-TL">
コレの`更新~手続き$tL()
◎
Run the update steps.
</li>
</ol>
【！追加が生じなかった場合にも更新~手続きは実行されることになる。】
</div>

<div class="algo">
<p>
@remove(tokens…)
~method手続きは：
◎
The remove(tokens…) method steps are:
</p>
<ol>
	<!--cp-throw-if-invalid-char-->
	<li>
%tokens を成す
~EACH( %token )
に対し
⇒
コレの`~token集合$tLから %token を`除去する$
◎
For each token of tokens:＼
remove token from this’s token set.
</li>
	<!--cp-update-TL-->
</ol>
</div>

<div class="algo">
<p>
@toggle(token, force)
~method手続きは：
◎
The toggle(token, force) method steps are:
</p>
<ol>
	<li>
`~tokenを検査する$( %token )
◎
If token is the empty string, then throw a "SyntaxError" DOMException.
◎
If token contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
	<li>
<p>
~IF［
%token ~IN コレの`~token集合$tL
］：
◎
If this’s token set[token] exists:
</p>
		<ol>
			<li>
<p>
~IF［
%force ~EQ ε
］~OR［
%force ~EQ ~F
］：
</p>
				<ol>
					<li>
コレの`~token集合$tLから %token を`除去する$
</li>
					<li>
コレの`更新~手続き$tL()
</li>
					<li>
~RET ~F
</li>
				</ol>
◎
If force is either not given or is false, then remove token from this’s token set, run the update steps and return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%force ~EQ ε
］~OR［
%force ~EQ ~T
］：
</p>
		<ol>
			<li>
コレの`~token集合$tLに %token を`付加する$set
</li>
			<li>
コレの`更新~手続き$tL()
</li>
			<li>
~RET ~T
</li>
		</ol>
◎
Otherwise, if force not given or is true, append token to this’s token set, run the update steps, and return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

<p class="note">注記：
~web互換性のため、
$toggle() に対しては，`更新~手続き$tLを常に走らすとは限らない。
◎
The update steps are not always run for toggle() for web compatibility.
</p>
</div>

<div class="algo">
<p>
@replace(token, newToken)
~method手続きは：
◎
The replace(token, newToken) method steps are:
</p>
		<ol>
			<li>
~IF［
%token ~EQ 空~文字列
］~OR［
%newToken ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
◎
If either token or newToken is the empty string, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%token は`~ASCII空白$を含んでいる
］~OR［
%newToken は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
◎
If either token or newToken contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~IF［
%token ~NIN コレの`~token集合$tL
］
⇒
~RET ~F
◎
If this’s token set does not contain token, then return false.
</li>
			<li>
コレの`~token集合$tL内で %token を %newToken に`置換する$set
◎
Replace token in this’s token set with newToken.
</li>
			<!--cp-update-TL-->
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>

<p class="note">注記：
~web互換性のため、
$replace() に対しては，`更新~手続き$tLを常に走らすとは限らない。
◎
The update steps are not always run for replace() for web compatibility.
</p>

<p class="trans-note">【
最初と二番目の段は、
%token, %newToken の順に`~tokenを検査する$のとは，挙動が異なる。
】</p>
</div>

<div class="algo">
@supports(token)
~method手続きは
⇒
~RET コレ上で`~tokenを検証する$( %token )
◎
The supports(token) method steps are:
• Let result be the return value of validation steps called with token.
• Return result.
</div>

<div class="algo">
@value
取得子~手続きは
⇒
~RET コレの`直列化-手続き$tL()
◎
The value getter steps are to return the result of running this’s serialize steps.
</div>

<div class="algo">
$value 設定子~手続きは
⇒
コレの`要素$tLの`属性o値を設定する$( コレの`属性o名$tL, 所与の値 )
◎
The value setter steps are to set an attribute value for this’s element using this’s attribute name and the given value.
</div>

		</section>
	</section>
	<section id="xpath">
<h2 title="XPath">8. ~XPath</h2>

<p class="XXX">
`DOM Level 3 XPath^cite は、
`XPath 1.0^cite 式を評価するための~APIを定義した。
これらの~APIは、
広く実装されてはいるが，保守されていない。
各種~interface定義は、
`Web IDL^cite が変更されるに伴い更新できるよう，ここに保守される。
これらの~APIの完全な定義は、
引き続き必要yである
— そのような作業は、
`課題 #67＠~DOMissue/67$にて追跡され，そこに貢献できる／され得る。
`DOM-Level-3-XPath$r
`XPath$r
`WEBIDL$r
◎
DOM Level 3 XPath defined an API for evaluating XPath 1.0 expressions. These APIs are widely implemented, but have not been maintained. The interface definitions are maintained here so that they can be updated when Web IDL changes. Complete definitions of these APIs remain necessary and such work is tracked and can be contributed to in whatwg/dom#67. [DOM-Level-3-XPath] [XPath] [WEBIDL]
</p>

		<section id="interface-xpathresult">
<h3 title="Interface XPathResult">8.1. ^@XPathResult ~interface</h3>

！！
[`Exposed$=Window]
interface @XPathResult {
  const `unsigned short$ @ANY_TYPE = 0;
  const `unsigned short$ @NUMBER_TYPE = 1;
  const `unsigned short$ @STRING_TYPE = 2;
  const `unsigned short$ @BOOLEAN_TYPE = 3;
  const `unsigned short$ @UNORDERED_NODE_ITERATOR_TYPE = 4;
  const `unsigned short$ @ORDERED_NODE_ITERATOR_TYPE = 5;
  const `unsigned short$ @UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  const `unsigned short$ @ORDERED_NODE_SNAPSHOT_TYPE = 7;
  const `unsigned short$ @ANY_UNORDERED_NODE_TYPE = 8;
  const `unsigned short$ @FIRST_ORDERED_NODE_TYPE = 9;

  readonly attribute `unsigned short$ @resultType;
  readonly attribute `unrestricted double$ @numberValue;
  readonly attribute $DOMString @stringValue;
  readonly attribute $boolean @booleanValue;
  readonly attribute $Node? @singleNodeValue;
  readonly attribute $boolean @invalidIteratorState;
  readonly attribute `unsigned long$ @snapshotLength;

  $Node? @iterateNext();
  $Node? @snapshotItem(`unsigned long$ %index);
};
！

		</section>
		<section id="interface-xpathexpression">
<h3 title="Interface XPathExpression">8.2. ^@XPathExpression ~interface</h3>

！！
[`Exposed$=Window]
interface @XPathExpression {
  // XPathResult.ANY_TYPE = 0
  XPathResult @evaluate($Node %contextNode, optional `unsigned short$ %type = 0, optional $XPathResult? %result = null);
};
！

		</section>
		<section id="mixin-xpathevaluatorbase">
<h3 title="Mixin XPathEvaluatorBase">8.3. ^XPathEvaluatorBase ~mixin</h3>

！！
callback interface @@XPathNSResolver {
  $DOMString? @lookupNamespaceURI($DOMString? %prefix);
};

interface mixin @@XPathEvaluatorBase {
  [NewObject] @XPathExpression @createExpression($DOMString %expression, optional $XPathNSResolver? %resolver = null);
  $Node $createNSResolver($Node %nodeResolver); // <!--cp-legacy-->

  // XPathResult.ANY_TYPE = 0
  $XPathResult @evaluate($DOMString %expression, $Node %contextNode, optional $XPathNSResolver? %resolver = null, optional `unsigned short$ %type = 0, optional $XPathResult? %result = null);
};
$Document includes $XPathEvaluatorBase;
！

<p>
@createNSResolver(nodeResolver)
~method手続きは
⇒
~RET %nodeResolver
◎
The createNSResolver(nodeResolver) method steps are to return nodeResolver.
</p>

<p class="note">注記：
この~methodは、
歴史的な理由に限り，存在する。
◎
This method exists only for historical reasons.
</p>

		</section>
		<section id="interface-xpathevaluator">
<h3 title="Interface XPathEvaluator">8.4. ^@XPathEvaluator ~interface</h3>

！！
[`Exposed$=Window]
interface @XPathEvaluator {
  `XPathEvaluator@mc();
};

$XPathEvaluator includes $XPathEvaluatorBase;
！

<p class="note">注記：
歴史的な理由から、
$XPathEvaluator を構築することも，
$Document 上で同じ~methodに~accessすることもできる。
◎
For historical reasons you can both construct XPathEvaluator and access the same methods on Document.
</p>

		</section>
	</section>
	<section id="xslt">
<h2 title="XSLT">9. ~XSLT</h2>

<p class="XXX">
~XSLT（ `XSL Transformations^cite ）は、
~XML文書を他の~XML文書へ形式変換するための言語である。
この節にて定義される~APIは，広く実装されており、
`Web IDL^cite が変更されたとき更新できるよう，ここに保守される。
これらの~APIの完全な定義は、
引き続き必要yである
— そのような作業は
`課題 #181＠~DOMissue/181$
にて追跡され，そこに貢献できる／され得る。
`XSLT$r
◎
XSL Transformations (XSLT) is a language for transforming XML documents into other XML documents. The APIs defined in this section have been widely implemented, and are maintained here so that they can be updated when Web IDL changes. Complete definitions of these APIs remain necessary and such work is tracked and can be contributed to in whatwg/dom#181. [XSLT]
</p>

		<section id="interface-xsltprocessor">
<h3 title="Interface XSLTProcessor">9.1. ^@XSLTProcessor ~interface</h3>

！！
[`Exposed$=Window]
interface @XSLTProcessor {
  `XSLTProcessor@mc();
  $undefined @importStylesheet($Node %style);
  [`CEReactions$] $DocumentFragment @transformToFragment($Node %source, $Document %output);
  [`CEReactions$] $Document @transformToDocument($Node %source);
  $undefined @setParameter([`LegacyNullToEmptyString$] $DOMString %namespaceURI, $DOMString %localName, $any %value);
  $any @getParameter([`LegacyNullToEmptyString$] $DOMString %namespaceURI, $DOMString %localName);
  $undefined @removeParameter([`LegacyNullToEmptyString$] $DOMString %namespaceURI, $DOMString %localName);
  $undefined @clearParameters();
  $undefined @reset();
};
！

		</section>
	</section>
	<section id="security-and-privacy">
<h2 title="Security and privacy considerations">10. ~security／~privacyの考慮点</h2>

<p>
この標準には、
既知な［
~security／~privacy
］の考慮点は無い。
◎
There are no known security or privacy considerations for this standard.
</p>

	</section>
	<section id="historical">
<h2 title="Historical">11. 歴史的なもの</h2>

<p>
この標準が包含していた，いくつかの［
~interface／~interface~member
］は、
除去された。
◎
This standard used to contain several interfaces and interface members that have been removed.
</p>

<p>
次に挙げる~interfaceは、
除去された：
◎
These interfaces have been removed:
</p>

<ul>
<li>@DOMConfiguration
<li>@DOMError
<li>@DOMErrorHandler
<li>@DOMImplementationList
<li>@DOMImplementationSource
<li>@DOMLocator
<li>@DOMObject
<li>@DOMUserData
<li>@Entity
<li>@EntityReference
<li>@MutationEvent
<li>@MutationNameEvent
<li>@NameList
<li>@Notation
<li>@RangeException
<li>@TypeInfo
<li>@UserDataHandler
</ul>

<p>
次に挙げる~interface~memberは、
除去された：
◎
And these interface members have been removed:
</p>

<dl>
<dt>$@Attr
	<dd>@schemaTypeInfo
	<dd>@isId

<dt>$@Document
	<dd>@createEntityReference()
	<dd>@xmlEncoding
	<dd>@xmlStandalone
	<dd>@xmlVersion
	<dd>@strictErrorChecking
	<dd>@domConfig
	<dd>@normalizeDocument()
	<dd>@renameNode()

<dt>$@DocumentType
	<dd>@entities
	<dd>@notations
	<dd>@internalSubset

<dt>$@DOMImplementation
	<dd>@getFeature()

<dt>$@Element
	<dd>@schemaTypeInfo
	<dd>@setIdAttribute()
	<dd>@setIdAttributeNS()
	<dd>@setIdAttributeNode()

<dt>$@Node
	<dd>@isSupported
	<dd>@getFeature()
	<dd>@getUserData()
	<dd>@setUserData()

<dt>$@NodeIterator
	<dd>@expandEntityReferences

<dt>$@Text
	<dd>@isElementContentWhitespace
	<dd>@replaceWholeText()

<dt>$@TreeWalker
	<dd>@expandEntityReferences
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、
~DOMを相互運用可能にするために，たくさんの方々が助力され、
この標準の目標へ近付けてきた。
同様に，この標準の今日の姿は、
多くの方々からの助力により作り上げられている。
◎
There have been a lot of people that have helped make DOM more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">
<p>
With that, many thanks to

Adam Klein,
Adrian Bateman,
Ahmid <i>snuggs</i>,
Alex Komoroske,
Alex Russell,
Alexey Shvayka,
Andreas Kling,
Andreu Botella,
Anthony Ramine,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Benjamin Gruenbaum,
Björn Höhrmann,
Boris Zbarsky,
Brandon Payton,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
C. Scott Ananian,
Cameron McCormack,
Chris Dumez,
Chris Paris,
Chris Rebert,
Cyrille Tuzi,
Dan Burzo,
Daniel Clark,
Daniel Glazman,
Darien Maillet Valentine,
Darin Fisher,
David Baron,
David Bruant,
David Flanagan,
David Håsäther,
David Hyatt,
Deepak Sherveghar,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Edgar Chen,
Elisée Maurer,
Elliott Sprehn,
Emilio Cobos Álvarez,
Eric Bidelman,
Erik Arvidsson,
Evgeny Kapun,
François Daoust,
François Remy,
Gary Kacmarcik,
Gavin Nicol,
Giorgio Liscio,
Glen Huang,
Glenn Adams,
Glenn Maynard,
Hajime Morrita,
Harald Alvestrand,
Hayato Ito,
Henri Sivonen,
Hongchan Choi,
Hunan Rostomyan,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald,
Jake Verbaten,
James Graham,
James Greene,
James M Snell,
James Robinson,
Jayson Chen,
Jeffrey Yasskin,
Jens Lindström,
Jeremy Davis,
Jesse McCarthy,
Jinho Bang,
João Eiras,
Joe Kesselman,
John Atkins,
John Dai,
Jonas Sicking,
Jonathan Kingston,
Jonathan Robie,
Joris van der Wel,
Joshua Bell,
J. S. Choi,
Jungkee Song,
Justin Summerlin,
Kagami Sascha Rosylight,
<span lang="zh-tw">呂康豪</span> (Kang-Hao Lu),
<span lang="ja">田村健人</span> (Kent TAMURA),
Kevin J. Sung,
Kevin Sweeney,
Kirill Topolyan,
Koji Ishii,
Lachlan Hunt,
Lauren Wood,
Luca Casonato,
Luke Zielinski,
Magne Andersson,
Majid Valipour,
Malte Ubl,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Martijn van der Ven,
Mason Freed,
Mats Palmgren,
Mounir Lamouri,
Michael Stramel,
Michael™ Smith,
Mike Champion,
Mike Taylor,
Mike West,
Nicolás Peña Moreno,
Nidhi Jaju,
Ojan Vafai,
Oliver Nightingale,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Piers Wombwell,
Pierre-Marie Dartus,
prosody—Gab Vereable Context(,
Rafael Weinstein,
Rakina Zata Amni,
Richard Bradshaw,
Rick Byers,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Roland Steiner,
Rune <span title="Fabulous">F.</span> Halvorsen,
Russell Bicknell,
Ruud Steltenpool,
Ryosuke Niwa,
Sam Dutton,
Sam Sneddon,
Samuel Giles,
Sanket Joshi,
Scott Haseley,
Sebastian Mayr,
Seo Sanghyeon,
Sergey G. Grekhov,
Shiki Okasaka,
Shinya Kawanaka,
Simon Pieters,
Simon Wülker,
Stef Busking,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Takashi Sakamoto,
Takayoshi Kochi,
Theresa O’Connor,
Theodore Dubois,
<i>timeless</i>,
Timo Tijhof,
Tobie Langel,
Tom Pixley,
Travis Leithead,
Trevor Rowbotham,
<i>triple-underscore</i>,
Tristan Fraipont,
Veli Şenol,
Vidur Apparao,
Warren He,
Xidorn Quan,
Yash Handa,
Yehuda Katz,
Yoav Weiss,
Yoichi Osato,
Yoshinori Sano,
Yu Han,
Yusuke Abe, and
Zack Weinberg

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>)
with substantial contributions from
Aryeh Gregor (<a href="mailto:ayg@aryeh.name">ayg@aryeh.name</a>)
and Ms2ger (<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).
</p>
</div>

<div lang="en" id="_ipr1">

<p>
Part of the revision history of the integration points related to <a href="#concept-element-custom">custom</a> elements can be found in <a href="https://github.com/w3c/webcomponents">the w3c/webcomponents repository</a>, which is available under the <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Software and Document License</a>.
</p>

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://dom.spec.whatwg.org/review-drafts/2025-12/">Living Standard Review Draft</a>.
</p>
</div>
</div>
