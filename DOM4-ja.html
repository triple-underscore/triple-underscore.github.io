<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>DOM Standard 日本語訳</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>

i.i {
	color: purple;
	font-weight: bold;
	font-family: serif0, serif;
}
.flag {
	
}

var {
	font-family: serif0, serif;
}

.bp-example {
	text-align: center;
	font-size: 14px;
	white-space: pre;
	overflow: auto;
	font-family: monospace0, monospace;
	padding-bottom: 3em;
	color: #555;
}
.bp-example * {
	font-family: monospace0, monospace;
	font-style:normal;
	position:relative;
	top: 6px;
	border-top: solid #AAA 3px;
}
.bp-example i {
	border-top-color: red;
	color: red;
}
.bp-example .x {
	border-top-color: #0C0;
}
.bp-example .y {
	border-top-color: blue;
}
.bp-example .m {
	border: none;
	top: 0;
	display: inline-block;
	vertical-align: top;
}


div.trans-note {
	margin: 1em;
	border: solid green 2px;
	padding: 0.5em;
}

/*
	border-left: solid #DDD 1em;
	padding-left: 0.5em;
*/
.domTree samp {
	border: 1px solid green;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<!--%内容置換生成 -->
<script>


Util.ready = function(){
	var ifc_names = PAGE_DATA.ifc_names
	.replace(/^\w+$/mg, function(name){
		return name + ':#' + name.toLowerCase();
	});
	delete PAGE_DATA.ifc_names;

	var source_data = {
		ifc_names: Util.get_mapping(ifc_names),
		toc_main: 'MAIN0',
		generate: expand,
		populate: populate,
	};

	Util.switchWordsInit(source_data);

/*
	repeat('dl.idl-def > dt', function(e){
		e.parentNode.replaceChild(C('p'), e)
	});
	Util.del_j(); // checked: 180329 spec
*/
}

function populate(){
// 要素複製
	var visited = Object.create(null), node, e;
	// Opera requires optional args, null, null
	var it = document.createNodeIterator(E('MAIN'), NodeFilter.SHOW_COMMENT, null, null);
	while(node = it.nextNode()){
		var id = node.data;
		if(id.slice(0,3) !== 'cp-') continue;
		e = visited[id];
		if(!e) {
			e = E(id);
			if(e) {
				e.removeAttribute('id');
				visited[id] = e;
			} else {
				console.log('source undefined:' + id);
				continue;
			}
		}
		node.parentNode.replaceChild(e.cloneNode(true), node);
	}
}

function expand(){

	var link_map = this.link_map;
	var ifc_names = this.ifc_names;

	var in_idl = false;
	var context_ifc = ''; // prefix 省略時の既定 interface 名

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん？]+|([\^@$]@?)([\w\.]+)(\([ \w,\[\]=…]*\))?|`(.+?)([\^@$])(\w*)|！+/g,
		create_html
	);

	function create_html(match, ind0, key, args, text, ind2, suffix){
		if(text){
			var href;
			var key = text;
			suffix = suffix || '';
			switch(suffix){
			case 'r':
				return (
'<a href="#biblio-' + text.toLowerCase() + '">[' +  text  + ']</a>'
				);
				break;
			case 'b': // 
				return '<b>' + text + '</b>';
				break;
			case 'i': // 
				text = '<i>' + text + '</i>';
				break;
			case 'l': // literal
				text = '"<code class="literal">' + text + '</code>"';
				break;
			case 'E':
				text = '<code class="error">' + text + '</code>';
				break;
			case 'e': // element tag
				text = '<code class="element">' + text + '</code>';
				break;
			case 'A': // attr name
				text = '<code class="attr">' + text + '</code>';
				break;
			case 'et': // event type
				text = '<code class="event-type">' + text + '</code>';
				break;
			case 'prod': // 生成規則
				text = '<code class="production">' + text + '</code>';
				break;
			case 'm': // idl member (external)
			case 'c': // codes
				text = '<code>' + text + '</code>';
				break;
			case 'V': // var
				text = '<var>' + text + '</var>';
				break;
			case 'f': // flags
				text = '<i class="flag">' + text + '~flag</i>';
				break;
			case 'bpex':
				return bpGenerate(text);
				break;
			case 'cite':
				return '<cite>' + text + '</cite>';
				break;
			case 'en': // english words
				return '<span lang="en-x-a0">' + key + '</span>'
				break;
			default:
				break;
			}
			if(ind2 === '^'){
				return text;
			}
			href = link_map[suffix ? key + '.' + suffix : key];
			if(!href){
				console.log(text);
				return match;
			}
			switch(ind2){
			case '$': 
				return '<a href="' + href + '">' + text + '</a>';
			case '@':
				return '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
			}
			return match;
		} else if(key){
			// idl contructs
			var text = key, href;
			if(!args && ( key in ifc_names ) ){
				href = ifc_names[key];
				if(ind0.length > 1){
//				if(ind0[1] === '@'){
					context_ifc = key;//.toLowerCase();
				}
			} else {
				var ifc = context_ifc;
				var dot = key.indexOf('.');
				if(dot >=0 ){
					ifc = key.slice(0, dot);
					key = text = key.slice(dot + 1); //text
				}
				href = (
					'#dom-' + ifc + '-' + (
						(key === 'Constructor') ? ifc : key
					)
				).toLowerCase();
				if(args){
text += args.replace(/(\w+)(\s=\s\w+)?/g, '<var>$1</var>$2');
				}
			}
			if(!in_idl){
				text = '<code>' + text + '</code>';
			}

			switch(ind0[0]){
			case '^':
				return text;
			case '$':
				return '<a href="' + href + '" >' + text + '</a>';
			case '@':
				return '<dfn id="' + href.slice(1) + '" >' + text + '</dfn>';
			}
		} else {
			switch(match[0]){
			case '%':
				return '<var>' + match.slice(1) + '</var>';
			case '！':
				in_idl = (match !== '！' );//！\n
				return in_idl ? '<pre class="idl">' : '</pre>';
			default: // 
				return match;
			}
		}
	}


	function bpGenerate(str){
		return '<div class="bp-example">'
		+ str.replace(/([\|\[\]\(\)])(\w?)/g, function(match, t, w){
			switch(t) {
			case '|':
				return w ? '<span class="m">|<br>' + w + '</span>' : '|';
			case '(':
				return w ? '<i class="' + w + '">' : '<i>';
			case '[':
				return w ? '<b class="' + w + '">' : '<b>';
			case ')':
				return '</i>';
			case ']':
				return '</b>';
			}
		})
		+ '</div>';
	}

}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:DOM
spec_date:2018-05-29
trans_update:2018-05-30
spec_status:LS
original_url:https://dom.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:infrastructure,uievents,html,selector
copyright:2018,whatwg
trans_1st_pub:2012-01-28


●●words_table1


US:unsigned short
B:boolean
CUS:const unsigned short
CUL:const unsigned long
UL:unsigned long
DS:DOMString
RA:readonly attribute

COLOR_R:<span style="color:red;">赤色区間</span>
COLOR_X:<span style="color:#0C0;">緑色区間</span>
COLOR_Y:<span style="color:blue;">青色区間</span>

TOUCHEVENTS:touch-events-ja.html
	https://www.w3.org/TR/touch-events/#touchevent-interface
Text: <code>Text</code> 
scope-ps: <code class="pseudo">:scope</code> 
SPECBUGS:https://www.w3.org/Bugs/Public/show_bug.cgi

is0:<code class="attr">is</code> 


●●words_table



HTML:
SVG:
XML:
XMLNS:
ID:
DOM:
Unicode:
	●node tree
木:tree::~:ツリー
部分木:subtree::~:部分ツリー:サブツリー
node::::ノード
shadow:
closed:
hidden:
light:
	~closed~shadow~hidden:closed-shadow-hidden
深優先前順走査:preorder, depth-first traversal:深さ優先かつ前順による走査
根:root::~::ルート
先祖:ancestor::~
子孫:descendant::~
	広義:inclusive::~
広義先祖:inclusive ancestor::~
広義子孫:inclusive descendant::~
親:parent::~
子:child::~
同胞:sibling::~
広義同胞:inclusive sibling::~
	前-同胞:nextSibling
	次-同胞:previousSibling
文書:document::~
文書片:document fragment::~::文書フラグメント
URL:
基底:base:~
断片:fragment::文書片::フラグメント
doctype:
要素:element::~
属性o:attribute°::属性°

片:fragment:~:::フラグメント
指数:index::~::インデックス
接続-:connect:~
	~~孤立する:alone

	●動詞
走らす:run する:~
走らせ:run し:~
	走り終えた
実行-:execute:~
遂行-:perform:~

先行-:precede::~
後続-:follow::~
関与-:participate:~
	のpartを成す／関与する
受入-:adopt::~
前挿入-:pre-insert:~
挿入-:insert:挿入
挿入:insertion:挿入
前除去-:pre-remove:~
除去-:remove:~
除去:removal:~
	除去される~node:toBeRemovedNode
置換-:replace:~
付加-:append:~
前付加-:prepend:~
設定-:set:~
未設定に:unset:~
取得-:get:~
変更-:change:~
変更:change:~
変化:change:~
改変-:modify:~
移動-:move:~
追加-:add:追加
	追加:addition:~
反映-:reflect:~
検証-:validate:~
	validation
無効化-:invalidate:~
妥当:valid:~
抽出-:extract:~
選択-:select:~
選択:selecting:~

連結-:concatenate:~
連結:concatenation:~
複製:copy::~
符号化法:encoding:~:::エンコーディング
	符号化:encode:~:::エンコード
	復号:decode:~:::デコード
clone::::クローン
	子も~cloneする:clone children
整列-:sort:~
内容:content:~
遭遇-:encounter:~


	●IDL ／ js ／ data 型
IDL:
JS:JavaScript
Realm:
realm:
大域:global::~::グローバル
	上位の大域:superglobal
field::::フィールド
member::::メンバ
meth:method:::メソッド
mixin:
ifc:interface:::インタフェース
catch:
	::::キャッチ
obj:object::::オブジェクト
下位class:subclass::下位 class:下位クラス
取得子:getter::~::ゲッタ
設定子:setter::~::セッタ
反復器:iterator::~::イテレータ
演算-:operate:~
演算:operation:~
属性:attribute::~

値:value::~
真偽値:boolean::~
数値:numeric value::~

引数:argument::~
	引数:parameter
返値:return value::返り値
返され:return され:~
返す:return する:~
返さ:return し:~
返し:return し:~

呼出す:invoke する:呼び出す
呼出-:invoke:呼び出
	呼出され／呼出して／呼出した
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
callback:
	::::コールバック
	呼戻
call:
	::::コール
index:
options::option 集::オプション集
list::::リスト
size::::サイズ
queue::::キュー
	~queue済み:queued
enqueue::::エンキュー
map::::マップ
tuple:::組::タプル
集合:set::~
構造体:struct::~
文字列化-:stringify:~
文字列化の:stringification:~
構築子:constructor::~::コンストラクタ
型:type:~
種別:type:~

例外:exception::~
投出:throw::~
	再投出:re-throw::再 throw:再投出
辞書:dictionary::~::ディクショナリ
継承-:inherit:~
派生:derived:~
初期化-:initialize:~
	初期化-済み:initialized
初期化:initializing:~
初期:initial:~
	初期~時:initially
関数:function::~
識別子:identifier:~
定数:constant:~
抽象:abstract::~
作成-:create:~
作成:creation:~
prop:property:::プロパティ
静的:static::~
live:
利用元:user::~::ユーザ

	在る:present する:在る
	有無:presence:~
	不在:not present:~
	~~不在:absence:~


	●文字 data
符号単位:code unit::~
ASCII:
大小区別:case-sensitive::文字大小区別
大小無視:case-insensitive::~
文字:character:~
文字列:string:~
部分文字列:substring:~
空:empty:~
空白:whitespace:~
space::::スペース
区切り:-separated:~
分割-:split::~
大文字:uppercase:~
小文字:lowercase:~
token::::トークン
長さ:length:~

class::::クラス
classes:::class 列::クラス列

連続的:contiguous::~
count:::::カウント
符号位置:code point:~


構文解析-:parse::~::パース
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
直列化器:serializer::~::シリアライザ

	●event
event::::イベント
listener::::リスナ
handler::::ハンドラ
listen::::リッスン
target:
	~targetし直す:retarget
item::::アイテム

経路:path::~
発火-:fire::~
	発火-法:firing
配送-:dispatch::~::ディスパッチ
	配送-法:dispatching
関係d:related::関係
受動:passive::~
composed:
	＊構成経路:composed::
取消:cancel::~::キャンセル
取消d:canceled::取消::キャンセル
取消せ:cancel でき::~::キャンセルでき
	取消せな uncancelable
取消さな:cancel しな::~::キャンセルしな
伝播-:propagate::~
伝播:propagation::~
伝播即停止:stop immediate propagation::~
伝播停止:stop propagation::~
停止-:stop:~
相:phase::~::フェイズ
合成:synthetic::~

task::::タスク
	下位~task
小task:microtask::小 task:小タスク
並列的:parallel:~

通達-:signal::~
通達:signal::~
	通達-時:signaling
	通達-法:signaling
複合:compound::~
作動化:activation::~::アクティブ化
作動化の:activation::~::アクティブ化

	●中止
中止-:abort::~
	中止-済み:aborted
	中止-法:aborting
promise:
	~promiseを返す:promise-returning
応答-:respond:~
却下-:reject::~
解決-::resolve::~
即時:immediate:~
未決着の:unsettled::~
注視-:watch:~
続行-:proceed:~

	●名前空間
局所:local::~::ローカル
	局所~名:local name
ns:namespace::名前空間
	名前空間接頭辞:namespace prefix::~
接頭辞:prefix::~
publicID:public ID::public 識別子
systemID:system ID::system 識別子
locate::特定
有修飾:qualified:~

生成規則:production::~
mode::::モード

	●変異
変異:mutation::~
変異-:mutate::~
	変異-可能:mutable
記録:record::~::レコード
観測-:observe::~::オブザーブ
観測:observing::~::オブザービング
	観測-法:observing
	観測-可能:observable
	観測器:observer::~:オブザーバ
ob:observer::観測器:オブザーバ
	~obは抑止する:suppress observers

登録-:register::~
	登録済み:registered
一時:transient:~
	追加-済み~nodeたち:addedNodes
	除去-済み~nodeたち:removedNodes
報告-:report:~
通知-:notify:~
通知:notification:~
有関係:interested:関係する
除去対象:nodes to remove:~

	●custom
custom::::カスタム
	~custom化:customize
反応-:react::~::リアクト
反応:reaction::~::リアクション
昇格:upgrade::~::アップグレード
	定義-済み
組込みの:built-in::組み込みの
検索-:look up::~

	●slot
slot:
slotable:
割当先:assign 先::あてがい先
割当され:assign され::あてがわれ
割当する:assign する::あてがう
割当法:assigning::あてがい方
見出す:find する:~
見出-:find:~
見出法:finding:見出し方
平坦化-:flatten:~

	●Range
範囲o:range°::範囲°
	~~範囲
offset:::::オフセット
境界点:boundary point::~
位置bp:position::位置

始端:start::~
終端:end::~
元の:original:~
包含-:contain:~
部分的:partial:~
中身:内容
交わる:intersect する:~
交わら:intersect し:~
畳まれ:collapse され:~
畳む:collapse する:~
	基準点:this point
	この点:other point

	●collection
走査-:traverse::~::トラバース
走査:traversal::~::トラバーサル
走査器:traverser::~::トラバーサ
collection::::コレクション
filter::::フィルタ
whatToShow:
	濾過器
	濾過する
選択子:selector::~::セレクタ
評価-:evaluate::~

視野根:scoping root::~::スコーピングルート
視野:scope::~::スコープ

合致:match:~:::マッチ
合致-:match:~:::マッチ
照合-:match:~:::マッチ
bitmask::::ビットマスク

作動中:active::~::アクティブ

	●仕様
API:
algo:algorithm:::アルゴリズム
app:application:::アプリ
UA:user agent:UA:::ユーザエージェント
Web:
web:
platform::::プラットフォーム
community:::コミュニティ
model::::モデル
console::::コンソール
proprietary::::プロプライエタリ
option::::オプション
version::::バージョン
仕様:spec:~
特色機能:feature::~::フィーチャ
適用-:apply:~
	適用-可能な:applicable
段:step:~:::ステップ
手続き:steps:~

support::::サポート
download:::ダウンロード
feedback:::フィードバック
markup::::マークアップ
debug::::デバッグ
log::::ログ
適合性:conformance:~
適合-:conform:~

旧来の:legacy な:~
別名:alias:~
歴史上:historical:~
歴史上の:historical な:~
歴史的:historical:~
理由:reason:~
判定基準:criteria:~
標準:standard:~
対話的:interactive:~
対話:interaction:~::やりとり
多彩:rich:~
明示的:explicit:~
暗黙的:implicit:~
互換性:compatibility:~
互換:compatible:~
	互換でない:incompatible
過去互換:quirks::~
限定的互換:limited-quirks::~
非過去互換:no-quirks::非 過去互換
設計者:designer:~
目標:goals:~
概念:concept:~
更新:update:~
資源:resource:::リソース
概して:typical に:~
一般:general:~
一般の:general な:~
共通的に:common に:よく
共通の:common::~
一貫する:consistent になる:~
一貫させ:consistent にす:~
特定の:specific:~
特有の:-specific な:~
	特に:specific／specifically
所産:artifact:~
局面:scenario:~
効率的:efficient:~
問題:problem:~
	problematic
理想的:ideal:~
劇的:dramatic:~
将来:future:~
実際:actual:~
実際の:actual:~
同義語:synonymous:~
自動的:automatic:~
冗長:redundant:~
正しく:correct に:~
正しい:correct な:~
重要:important:~
基本:basic:~
単純:simple:~
	単純~化:simplify
副作用:side effect:~
効果:effect:~
実質的:effective:~
有用:useful:~
	無用の長物:useless
詳細:details:~
一義的:unambiguous:~
program::::プログラム
強く:strong に:~
可用:available:~
中立的:neutral:~
仕組み:mechanism:~
意味論:semantics:~
適度な:reasonable:ほどよい
仕方:way:~
方式:manner:~
精細:granular:~
複雑:complex:~
旧式の:old-style:~
環境設定:configurations:~
事例:case:~

	●仕様（動詞
拡張-:extend:~
拡張:extension:~
拡張用:extensibility:~
hook::::フック
実装:implementation:~
実装-:implement:~
利用者:user:~:::ユーザ
省略-:omit:~
省略可:optional::~
	省略時
設計:design:~
要求-:require:~
	要-:require
要件:requirements:~
必須の:required:~
言明-:state:~
解釈-:interpret:~
許容-:allow:~
導入-:introduce:~
	再~導入:reintroduce
予期-:expect:~
期待-:expect:~
変更点:changes:~
指定-:specify:~
	~~指定:flag:
未定義:undefined:~
定義-:define:~
定義:definition:~
	定義-法:defining
指示-:indicate:~
	~~指示:instruct
供-:provide:~
意図的:intentional:~
	~~意図され:meant
機能性:functionality:~
結付けら:associate さ:結び付けら
結付け:associate し:結び付け
既存の:existing:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
制御:control:~
最適化:optimization:~
最適化-:optimize:~
処理能:performance:~
奨励-:encourage:~
開発者:developer:~
軽減-:mitigate:~
援助-:aid:~
成功裡:successful:~
影響-:affect:~
影響0:impact:影響
拘束:constraints:~
拘束-:constrain:~
保障-:guarantee:~
無視-:ignore:~
改訂:revision:~
	説明-:explain:~
確保-:ensure:~
収束-:converge:~
	想定-:suppose
受容-:accept:~
保全-:preserve:~
依存-:depend:~
経験:experience:~
理解-:understand:~
操作-:manipulate:~
	操作-:manipulation
計画-:plan:~
策定者:author:~
作者:author:~
推奨-:recommend:~
推奨:recommendation:~
望み:wishes:~
望む:wish する:~
欲され:desire され:~
依拠-:rely:~
固守-:adhere:~
衝突-:clash:~
避ける:avoid する:~
取除かれ:remove され:取り除かれ
廃用に:obsolete:~
波及-:influence:~
働かな:work しな:~
働く:work する:~
	働き続けられる:don’t stop working
言及-:mention:~

	相互運用可能:interoperable:~
	助力:help:~
	内部処理用の:bookkeeping purposes


	●未分類（動詞
	抑止-:suppress:~
試行-:try:~
可能化-:enable:~
不能化-:disable:~
不能化:disabling:~
代入-:assign:~
代入:assignment:~
消去-:clear::~::クリア
変換-:convert:~
検査-:check:~
検査:check:~
構築-:construct:~
	構築-法:constructing
構成子:construct:~
比較:comparison:~
比較-:compare:~
決定-:determine:~
非決定的:non-deterministic:~
経過-:pass:~
表現-:represent:~
追跡-:track:~
公開-:expose:~
進行中の:ongoing:~
重複:duplicate:~
到達-:reach:~
阻む:block する:~:::ブロックする
阻まな:block しな:~:::ブロックしな
動作:action:~
活動:activity:~
関係-:relate:~
関係性:relationship:~
添付けら:attach さ:添え付けら
上書き:override:~
共有-:share:~
入力:input:~
名:name:~
名前:name:~
改称-:rename:~
完了-:complete:~
完了:completion:~
	所与の:given
追従-:flollw:~
列挙-:enumerate:~
格納-:store:~
	格納-法:storing
起動-:initiate:~
	起動するもの:initiator
	渡-:pass

	●未分類
thread::::スレッド
	別~thread:cross-thread
snapshot:
	Checkbox
	Radio
関連する:relevant な:~
失敗:failure:~
失敗-:fail:~
成功:success:~
疑似類:pseudo-class::疑似 class:疑似クラス
状態:state::~
brand:
open:
access::::アクセス
bit::::ビット
code::::コード
data::::データ
flag::::フラグ
form::::フォーム
提出:submission::~
提出-:submit::~
garbage-collection:garbage collection::garbage 収集:ガーベジ収集:ガーベジコレクション
	16進:hex
host::::ホスト
hyphen::::ハイフン
instance::::インスタンス
level::::レベル
multimedia::::マルチメディア
network::::ネットワーク
page:::ページ
pointer::::ポインタ
scrolling::::スクロール処理
script::::スクリプト
sw:service worker
source::::ソース
tag::::タグ
text::::テキスト
touch:
view::::ビュー
wheel:
一意:unique:~
同期:synchronous::~
非同期:asynchronous::~
変数:variable:~
実体参照:entity reference::~
整数:integer:~
文脈:context:~
方向:direction:~
既定:default:~:::デフォルト
既定の:default:~:::デフォルト
強い:strong な:~
弱い:weak な:~
基準:reference:~
参照:reference:~

時計:clock:~
時刻:time:~
時間差:time:~
時刻印:timestamp:~
	現在時:now
	差分:offset
時刻起点:time origin:~
	マイクロ秒:microseconds
	ミリ秒数:milliseconds
分解能:resolution:~
高分解能な:high resolution:高分解能な
	までの細かさ:minimum
	生じ:occur／occurrence／
換算-:translate:~
調整-:adjust:~
精度:precision:~

順序:order:~
	全順序:linear
有順序:ordered:~
条件:condition:~

構造:structure:~
正確:exact:~
精確:precise:~
閲覧文脈:browsing context::~
生成元:origin::~::オリジン
不透明な:opaque::~
画像:image:~
相対的:relative:~
等価:equivalent:~
同等:equal:~
階層的:hierarchical:~
環境:environment:~
再帰的:recursive:~
	一致する:identical
	起点:reference

	●指示語
下位:sub:~
下層:underlying:~
内的:internal:内部
	内部的に:inner
	内部:-
新たな:new:~
現在の:current:~
現-:current:~
前-:previous:前の
次-:next:次の
旧-:old:旧
新-:new:新
	広義:inclusive
	狭義:exclusive
	時点:
	以降:
	初回:first time
	ときには、:ocassionally
	すでに:already
	初めて:very first
	永遠に:forever
	前回:
	最早:
	今度:
	現在:
	現時点:
	
	ある種の:certain
	すべてまたは一部の:all or some
	唯一つ:
	唯一の:the sole
	すべて:all
	範囲:
	この:this
	これらの:these
	その:that
	それらの:their
	それらを:them
	もの:thing
	上／上述:above
	多くの:many
	一環:part of
	他所:elsewhere
	他の:other
	他の場合:otherwise
	両方／両者／両:both
	複数:
	複数個:more than one
	隙間:
	開始-:start
	終了:end
	逆順:reverse
	番目:
	挿入点:
	差分:
	隣接:
	個以上:
	以前:
	項目:
	列目:
	個目:
	度目:
	二番目:
	下記
	開始
	末尾側:
	末尾:
	片方:
	末端:
	各種:
	一連:
	時点:
	対象:
	該当:
	後続:
	左側:
	直前:
	直後:
	部分:
	一部:
	対応している:corresponding
	対応:correspond
	同様:
	以外:
	以下:
	下位:
	自身:
	先頭:
	個数:
	最後:last
	最初:first
	任意:
	有限個:
	有限:
	箇所:
	各:each
	各項:
	合間:between
	最高:
	後述:
	一種:
	一対一:
	一対一に対応:1:1 mapping
	一列:
	一個:
	本数:
	各数字:
	最下位:
	逆向:
	前述:
	一例:
	全体:
	一方:
	自体:
	場合:if
	次のように:as follows
	次の:following
	結果:result
	通して:through
	逆順:reverse 〜 order／reversed
	称される:known as
	およそ:viable


●●original_id_map


dom-domtokenlist-stringifier:DOMTokenList-stringification-behavior


●●ifc_names

AbortController
AbortSignal
Attr
CharacterData
CustomEvent
CustomEventInit:#dictdef-customeventinit
Comment
ChildNode
CDATASection
NonDocumentTypeChildNode
Document
DocumentFragment
ShadowRoot
ShadowRootInit:#dictdef-shadowrootinit
ShadowRootMode:#enumdef-shadowrootmode
DocumentOrShadowRoot
GetRootNodeOptions:#dictdef-getrootnodeoptions

DOMImplementation
DocumentType
Element
ElementCreationOptions:#dictdef-elementcreationoptions
Elements
Event
EventInit:#dictdef-eventinit
EventListener:#callbackdef-eventlistener
EventTarget
EventListenerOptions
AddEventListenerOptions
HTMLCollection
MutationCallback
MutationObserver
MutationObserverInit:#dictdef-mutationobserverinit
MutationRecord
NamedNodeMap
Node
NodeFilter:#callbackdef-nodefilter
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
AbstractRange
ParentNode
NonElementParentNode
DOMTokenList
TreeWalker
Text
XMLDocument

	●→ 廃止
RangeException
MutationEvent
MutationNameEvent

DOMConfiguration
DOMError
DOMErrorHandler
DOMImplementationList
DOMImplementationSource
DOMLocator
DOMObject
DOMStringList:~HTMLcdom#domstringlist
DOMUserData
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler


HTMLElement:~HTMLdom#htmlelement
HTMLHtmlElement:~HEmetadata#htmlhtmlelement
HTMLSlotElement:~HEscripting#htmlslotelement
HTMLUnknownElement:~HTMLdom#htmlunknownelement
ServiceWorkerGlobalScope:~SW#serviceworkerglobalscope
Window:~WINDOW#window

BeforeUnloadEvent:~NAVI#beforeunloadevent
CompositionEvent:~UIEVENTS#compositionevent
	#interface-compositionevent
	CustomEvent
DeviceMotionEvent:https://w3c.github.io/deviceorientation/spec-source-orientation.html#devicemotion
DeviceOrientationEvent:https://w3c.github.io/deviceorientation/spec-source-orientation.html#devicemotion
EventHandler:~WAPI#eventhandler
DragEvent:~HTMLdnd#dragevent
FocusEvent:~UIEVENTS#focusevent
	#interface-focusevent
	Event
HashChangeEvent:~NAVI#hashchangeevent
KeyboardEvent:~UIEVENTS#keyboardevent
	~UIEVENTS#keyboardevent-keyboardevent
	~UIEVENTS#interface-keyboardevent
MessageEvent:~HTMLcomms#messageevent
MouseEvent:~UIEVENTS#mouseevent
	~UIEVENTS#interface-mouseevent
StorageEvent:~WEBSTORAGE#storageevent
TouchEvent:~TOUCHEVENTS#idl-def-touchevent
	TouchEvent:~TOUCHEVENTS#touchevent-interface
	#touchevent-interface
	https://w3c.github.io/touch-events/#idl-def-touchevent
UIEvent:~UIEVENTS#uievent
	~UIEVENTS#interface-uievent
	~UIEVENTS#uievent-uievent


DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
DOMTimeStamp:~WEBIDL#DOMTimeStamp
DOMString:~WEBIDL#idl-domstring
DOMException:~WEBIDL#idl-DOMException


●●link_map



script.e:~HEscripting#the-script-element
input.e:~HEinput#the-input-element
title.e:~HEmetadata#the-title-element
html.e:~HEmetadata#the-html-element
head.e:~HEmetadata#the-head-element
body.e:~HEsections#the-body-element
template.e:~HEscripting#the-template-element
slot.e:~HEscripting#the-slot-element
input.e:~HEinput#the-input-element
area.e:~HEimages#the-area-element

open.l:#dom-shadowrootmode-open
closed.l:#dom-shadowrootmode-closed

CEReactions:~HEcustom#cereactions
Exposed:~WEBIDL#Exposed
Unforgeable:~WEBIDL#Unforgeable
SameObject:~WEBIDL#SameObject
Unscopable:~WEBIDL#Unscopable
NewObject:~WEBIDL#NewObject
LegacyUnenumerableNamedProperties:~WEBIDL#LegacyUnenumerableNamedProperties
TreatNullAs:~WEBIDL#TreatNullAs
PutForwards:~WEBIDL#PutForwards

TypeError.E:~WEBIDL#exceptiondef-typeerror
AbortError.E:~WEBIDL#aborterror
HierarchyRequestError.E:~WEBIDL#hierarchyrequesterror
InUseAttributeError.E:~WEBIDL#inuseattributeerror
IndexSizeError.E:~WEBIDL#indexsizeerror
InvalidCharacterError.E:~WEBIDL#invalidcharactererror
InvalidNodeTypeError.E:~WEBIDL#invalidnodetypeerror
InvalidStateError.E:~WEBIDL#invalidstateerror
NamespaceError.E:~WEBIDL#namespaceerror
NotFoundError.E:~WEBIDL#notfounderror
NotSupportedError.E:~WEBIDL#notsupportederror
SyntaxError.E:~WEBIDL#syntaxerror
WrongDocumentError.E:~WEBIDL#wrongdocumenterror

click().m:~HTMLinteraction#dom-click
detail.m:~UIEVENTS#dom-uievent-detail
insertAdjacentHTML().m:~DOM-Parsing#dom-element-insertadjacenthtml
createContextualFragment().m:~DOM-Parsing#dfn-createcontextualfragment-fragment
getClientRects().m:~CSSOMVIEW#dom-range-getclientrects
getBoundingClientRect().m:~CSSOMVIEW#dom-range-getboundingclientrect

最初のもの？:#_first_obj
最後のもの？:#_last_obj
最後0:#_last_obj
旧来の（~listenerは投出したか？）~flag.V:#_legacyOutputDidListenersThrowFlag

文脈~obj:#context-object
	＊投出:#concept-throw
適用-可能な仕様:#other-applicable-specifications
閲覧文脈~群.V:#_unit-of-related-similar-origin-browsing-contexts

	●event
初期化-済み.f:#initialized-flag
伝播即停止.f:#stop-immediate-propagation-flag
伝播停止.f:#stop-propagation-flag
取消d.f:#canceled-flag
配送-.f:#dispatch-flag
受動~listener内.f:#in-passive-listener-flag
~composed.f:#composed-flag

~item.evP:#event-path-item
~target.evP:#event-path-target
~touch~target~list.evP:#event-path-touch-target-list
関係d~target.evP:#event-path-relatedtarget
~closed木の根？.evP:#event-path-root-of-closed-tree
~slotは~closed木~内？.evP:#event-path-slot-in-closed-tree

~event:#concept-event
~eventを作成する:#concept-event-create
~eventを内部的に作成する:#inner-event-creation-steps
~eventを初期化する:#concept-event-initialize
~event経路に付加する:#concept-event-path-append
~targetし直す:#retarget

~event~targetになり得るもの:#potential-event-target
~target:#event-target
関係d~target:#event-relatedtarget
~touch~target~list:#event-touch-target-list
経路:#event-path
配送-:#concept-event-dispatch
~eventを発火する:#concept-event-fire

~listenerを呼出す:#concept-event-listener-invoke
~listenerを内部的に呼出す:#concept-event-listener-inner-invoke
~event~listenerを追加する:#add-an-event-listener
~event~listenerを除去する:#remove-an-event-listener
~event~listenerをすべて除去する:#remove-all-event-listeners
~event~listener~list:#eventtarget-event-listener-list
~event~listener:#concept-event-listener

type.evL:#event-listener-type
callback.evL:#event-listener-callback
capture.evL:#event-listener-capture
passive.evL:#event-listener-passive
once.evL:#event-listener-once
removed.evL:#event-listener-removed

平坦化-:#concept-flatten-options
もっと平坦化-:#event-flatten-more
親~targetを取得する:#get-the-parent
~event構築子:#concept-event-constructor

作動化の挙動:#eventtarget-activation-behavior
旧来の作動化~前の挙動:#eventtarget-legacy-pre-activation-behavior
旧来の作動化~取消~時の挙動:#eventtarget-legacy-canceled-activation-behavior

~event構築-時の手続き:#concept-event-constructor-ext
取消d~flagを設定する:#set-the-canceled-flag

	●abort
通達.aB:#abortcontroller-signal
中止する~algoたち.aB:#abortsignal-abort-algorithms
中止-済み~flag.aB:#abortsignal-aborted-flag
中止-を通達する:#abortsignal-signal-abort
通達に~algoを追加する:#abortsignal-add
通達から~algoを除去する:#abortsignal-remove
通達に追従させる:#abortsignal-follow

	●node／木
~node:#concept-node
親~要素:#parent-element
子:#concept-tree-child
子たち:#concept-tree-child
親:#concept-tree-parent
先祖:#concept-tree-ancestor
子孫:#concept-tree-descendant
広義先祖:#concept-tree-inclusive-ancestor
広義子孫:#concept-tree-inclusive-descendant
共通の広義先祖:#_common-inclusive-ancestor

最初の子？:#concept-tree-first-child
最後の子？:#concept-tree-last-child
先行-:#concept-tree-preceding
後続-:#concept-tree-following
指数:#concept-tree-index
前-同胞？:#concept-tree-previous-sibling
次-同胞？:#concept-tree-next-sibling
関与して:#concept-tree-participate
関与-:#concept-tree-participate
同胞:#concept-tree-sibling
広義同胞:#concept-tree-inclusive-sibling

木:#concept-tree
~node木:#concept-node-tree
文書~木:#concept-document-tree
根:#concept-tree-root
木~順序:#concept-tree-order
要素~ifc:#concept-element-interface

文書~木~内:#in-a-document-tree
文書~内:#in-a-document

~nodeを受入する:#concept-node-adopt
受入-時の手続き:#concept-node-adopt-ext
~nodeを付加する:#concept-node-append
~nodeを子の前に挿入する:#concept-node-insert
挿入-時の手続き:#concept-node-insert-ext
~nodeを子の前に前挿入する:#concept-node-pre-insert
挿入できるかどうか検証する:#concept-node-ensure-pre-insertion-validity

子を前除去する:#concept-node-pre-remove
前除去-時の手続き:#nodeiterator-pre-removing-steps
子を除去する:#concept-node-remove
除去-時の手続き:#concept-node-remove-ext
子を~nodeに置換する:#concept-node-replace
全~内容を~nodeで置換する:#concept-node-replace-all
隣に~nodeを挿入する:#insert-adjacent

~nodeを~cloneする:#concept-node-clone
~clone時の手続き:#concept-node-clone-ext

子~text内容~変更-時の手続き:#concept-node-text-change-ext
子~text内容:#concept-child-text-content

長さ:#concept-node-length
~node文書:#concept-node-document
空.node:#concept-node-empty
同等:#concept-node-equals

文書片:#_concept-documentfragment
文字~data~node:#_concept-cdata-node
~host:#concept-documentfragment-host
~hostも含む広義先祖:#concept-tree-host-including-inclusive-ancestor

~ID:#concept-id


	●shadow
~light木:#concept-light-tree
~shadow木:#concept-shadow-tree
~shadow~host:#element-shadow-host
~shadow根:#concept-shadow-root
~mode.sR:#shadowroot-mode
~shadowも含む子孫:#concept-shadow-including-descendant
~shadowも含む広義子孫:#concept-shadow-including-inclusive-descendant
~shadowも含む先祖:#concept-shadow-including-ancestor
~shadowも含む広義先祖:#concept-shadow-including-inclusive-ancestor
~shadowも含む木~順序:#concept-shadow-including-tree-order
~shadowも含む深優先前順走査:#shadow-including-preorder-depth-first-traversal
接続されて:#connected
~shadowも含む根:#concept-shadow-including-root
	#in-a-shadow-including-document
~closed~shadow~hidden:#concept-closed-shadow-hidden

	●slot
~slot:#concept-slot
~slotable:#concept-slotable
~slot名:#slot-name
~slotable名:#slotable-name
	＊名前.sL:#slot-name
	＊名前.sB:#slotable-name
~slotable用に~slotを見出す:#find-a-slot
~slot用に~slotableたちを見出す:#find-slotables
~slot用に平坦化された~slotableたちを見出す:#find-flattened-slotables
割当先~slot:#slotable-assigned-slot
割当先がある:#slotable-assigned
割当されている~nodeたち:#slot-assigned-nodes
~slotableを~slotに割当する:#assign-a-slot
~slotに~slotableたちを割当する:#assign-slotables
木に~slotableたちを割当する:#assign-slotables-for-a-tree
通達~slot~list:#signal-slot-list
~slotの変化を通達する:#signal-a-slot-change

	●文書／文書片／名前空間
文書:#concept-document
符号化法.doc:#concept-document-encoding
内容~型.doc:#concept-document-content-type
~URL.doc:#concept-document-url
種別.doc:#concept-document-type
生成元.doc:#concept-document-origin
~mode.doc:#concept-document-mode

文書~基底~URL:~HTMLurl#document-base-url
結付けられている文書:~WINDOW#concept-document-window

限定的互換~mode:#concept-document-limited-quirks
非過去互換~mode:#concept-document-no-quirks
過去互換~mode:#concept-document-quirks
~doctype:#concept-doctype
~doctype名:#concept-doctype-name
名前.dT:#concept-doctype-name
~publicID.dT:#concept-doctype-publicid
~systemID.dT:#concept-doctype-systemid


~HTML文書:#html-document
~XML文書:#xml-document

~HTML~ns:~INFRA#html-namespace
~SVG~ns:~INFRA#svg-namespace
~XML~ns:~INFRA#xml-namespace
~XMLNS~ns:~INFRA#xmlns-namespace

~ns接頭辞を~locateする:#locate-a-namespace-prefix
~nsを~locateする:#locate-a-namespace
内的 createElementNS 手続き:#internal-createelementns-steps


	●text node／文字列／cdata
新たな~Text~node:#_a-new-text-node

符号単位:~INFRA#code-unit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大文字~化する:~INFRA#ascii-uppercase
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
長さ.jStr:~INFRA#javascript-string-length

大小区別:~HTMLINFRA#case-sensitive

有順序~集合 構文解析器:#concept-ordered-set-parser
有順序~集合 直列化器:#concept-ordered-set-serializer

~Text~nodeを分割する:#concept-text-split
~dataを置換する:#concept-cd-replace
~data:#concept-cd-data
~dataの部分文字列:#concept-cd-substring

狭義の~Text~node:#exclusive-text-node
連続的な~Text~node列:#contiguous-text-nodes
連続的な狭義の~Text~node列:#contiguous-exclusive-text-nodes
連続的な同胞~列:#_contiguous-nodes

	●要素／属性
文書~要素:#document-element
要素:#concept-element
局所~名:#concept-element-local-name
~shadow根.elm:#concept-element-shadow-root
有修飾~名:#concept-element-qualified-name
~HTML大文字~化~有修飾~名:#element-html-uppercased-qualified-name
~ns接頭辞:#concept-element-namespace-prefix
~ns:#concept-element-namespace
有修飾~名として検証する:#validate
検証して抽出する:#validate-and-extract
属性o~list:#concept-element-attribute
有する:#concept-element-attribute-has
有して:#concept-element-attribute-has
有さない:#concept-element-attribute-has

属性oを設定する:#concept-element-attributes-set
属性oを付加する:#concept-element-attributes-append
属性oを除去する:#concept-element-attributes-remove
属性oを変更する:#concept-element-attributes-change
属性oを置換する:#concept-element-attributes-replace

既存の属性o値を設定する:#set-an-existing-attribute-value
属性o値を設定する:#concept-element-attributes-set-value
属性o値を取得する:#concept-element-attributes-get-value

属性oを名前により取得する:#concept-element-attributes-get-by-name
属性oを名前により除去する:#concept-element-attributes-remove-by-name
属性oを~nsと局所~名により取得する:#concept-element-attributes-get-by-namespace
属性oを~nsと局所~名により除去する:#concept-element-attributes-remove-by-namespace

属性o:#concept-attribute
属性o.nm:#concept-named-attribute
属性oを変更する手続き:#concept-element-attributes-change-ext
属する要素:#concept-attribute-element
有修飾~名.a:#concept-attribute-qualified-name
値.a:#concept-attribute-value
~ns.a:#concept-attribute-namespace
~ns接頭辞.a:#concept-attribute-namespace-prefix
局所~名.a:#concept-attribute-local-name

要素.nm:#concept-namednodemap-element
属性o~list.nm:#concept-namednodemap-attribute
~classes:#concept-class
~classesに含む要素の~list:#concept-getelementsbyclassname
有修飾~名に持つ要素の~list:#concept-getelementsbytagname
( ~ns, 局所~名 ) に持つ要素の~list:#concept-getelementsbytagnamens

反映-:#concept-reflect


	●custom要素
要素を作成する:#concept-create-element
定義-済み:#concept-element-defined
~custom:#concept-element-custom
~custom要素~状態:#concept-element-custom-element-state
~custom要素~定義:#concept-element-custom-element-definition
~is0値:#concept-element-is-value

名前.cD:~HEcustom#concept-custom-element-definition-name
局所~名.cD:~HEcustom#concept-custom-element-definition-local-name
構築子.cD:~HEcustom#concept-custom-element-definition-constructor
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~custom要素~構築子:~HEcustom#custom-element-constructor
~custom要素~callback反応を~enqueueする:~HEcustom#enqueue-a-custom-element-callback-reaction
~custom化された組込みの要素:~HEcustom#customized-built-in-element
~custom要素~定義を検索する:~HEcustom#look-up-a-custom-element-definition
要素を昇格しようと試行する:~HEcustom#concept-try-upgrade
要素を昇格する:~HEcustom#concept-upgrade-an-element
~custom要素~昇格~反応を~enqueueする:~HEcustom#enqueue-a-custom-element-upgrade-reaction


	●変異
変異~記録を~queueする:#queue-a-mutation-record
木~変異~記録を~queueする:#queue-a-tree-mutation-record
属性~変異~記録を~queueする:#queue-an-attribute-mutation-record
~nodeたちを~nodeに変換する:#converting-nodes-into-a-node

~callback.mo:#concept-mo-callback
~node~list.mo:#mutationobserver-node-list
記録~queue.mo:#concept-mo-queue

変異~ob 複合~小task~queue済み.f:#mutation-observer-compound-microtask-queued-flag
変異~ob 複合~小taskを~queueする:#queue-a-mutation-observer-compound-microtask
変異~obに通知する:#notify-mutation-observers

登録-済み~ob:#registered-observer
一時~登録-済み~ob:#transient-registered-observer
変異~ob~list:#mutation-observer-list
登録-済み~ob~list:#registered-observer-list
	抑止ob.f:#_suppress-observers-flag
~ob.ob:#registered-observer-observer
~options.ob:#registered-observer-options
~source.ob:#transient-registered-observer-source


	●範囲
範囲o:#concept-range
~live範囲o:#concept-live-range
根.rg:#concept-range-root
中身を抽出-.rg:#concept-range-extract
中身を~clone.rg:#concept-range-clone
中身に挿入-.rg:#concept-range-insert
中身として選択-.rg:#concept-range-select
中身.rg:#_concept-range-content

境界点:#concept-range-bp
~node.bp:#boundary-point-node
~offset.bp:#concept-range-bp-offset

より前.i:#concept-range-bp-before
より後.i:#concept-range-bp-after
に等しい.i:#concept-range-bp-equal

終端~node:#concept-range-end-node
終端~offset:#concept-range-end-offset
終端:#concept-range-end
始端~node:#concept-range-start-node
始端~offset:#concept-range-start-offset
始端:#concept-range-start
畳まれて:#range-collapsed

相対的な位置bp:#concept-range-bp-position
境界点を設定する:#concept-range-bp-set

包含され:#contained
部分的に包含され:#partially-contained

	●token list
~token集合:#concept-dtl-tokens
~supportする~token集合.dtl:#concept-supported-tokens
更新~手続き:#concept-dtl-update
直列化-手続き:#concept-dtl-serialize
~tokenを検証する:#concept-domtokenlist-validation
要素.dtl:#_dtl-element
属性oの局所~名.dtl:#_dtl-localname
~tokenを検査する:#_dtl-check-token

	●collection／node iterator／tree walker
表現-:#represented-by-the-collection
反復器~collection:#iterator-collection
~live:#concept-collection-live
静的:#concept-collection-static
~collection:#concept-collection

~filter.cL:#_collection-filter
根.cL:#_collection-root

作動中~flag.tV:#concept-traversal-active
~filter~callback.tV:#concept-traversal-filter
根.tV:#concept-traversal-root
~whatToShow.tV:#concept-traversal-whattoshow
現-~node.tV:#treewalker-current
起点.tV:#nodeiterator-reference
起点の直前？.tV:#nodeiterator-pointer-before-reference

走査器の中で~nodeを~filterにかける:#concept-node-filter
子たちを走査する:#concept-traverse-children
同胞たちを走査する:#concept-traverse-siblings
反復器で走査する:#concept-nodeiterator-traverse
走査-:#concept-nodeiterator-traverse

	●PI
~target.pI:#concept-pi-target

	●INFRA
有順序~集合:~INFRA#ordered-set
付加する.set:~INFRA#set-append
置換する.set:~INFRA#set-replace
~list:~INFRA#list
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
~cloneする:~INFRA#list-clone
~size:~INFRA#list-size
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
除去する:~INFRA#list-remove
挿入する:~INFRA#list-insert
置換する:~INFRA#list-replace
包含して:~INFRA#list-contain
連結-:~INFRA#string-concatenate
~queue:~INFRA#queue
~enqueueする:~INFRA#queue-enqueue
~map:~INFRA#ordered-map
構造体:~INFRA#struct
~tuple:~INFRA#tuple
	~EACH.list:~INFRA#list-iterate
	~CONTINUE.list:~INFRA#iteration-continue
	包含-.list:~INFRA#list-contain
	~IN.list:~INFRA#list-contain
	~NIN.list:~INFRA#list-contain

	●選択子
視野の下で選択子を照合する:#scope-match-a-selectors-string
~scope-ps要素:~SELECTORS4#scope-element
選択子として構文解析する:~SELECTORS4#parse-a-selector
視野根:~SELECTORS4#scoping-root
木に対し選択子を照合する:~SELECTORS4#match-a-selector-against-a-tree
要素に対し選択子を照合する:~SELECTORS4#match-a-selector-against-an-element

	●WEBIDL
辞書:~WEBIDL#dfn-dictionary
辞書~member:~WEBIDL#dfn-dictionary-member
識別子:~WEBIDL#dfn-identifier
	interface mixin:~WEBIDL#idl-interface-mixins

~supportする~prop~index:~WEBIDL#dfn-supported-property-indices
~supportする~prop名:~WEBIDL#dfn-supported-property-names
投出:~WEBIDL#dfn-throw
可変個引数:~WEBIDL#dfn-variadic
利用元~objの演算を~callする:~WEBIDL#call-a-user-objects-operation
~callback関数を呼出す:~WEBIDL#invoke-a-callback-function
変換-:~WEBIDL#dfn-convert-ecmascript-to-idl-value
~callback関数で構築する:~WEBIDL#construct-a-callback-function

	●他
新たな~promise:~PROMISES#a-new-promise
却下する:~PROMISES#reject-promise
解決する:~PROMISES#resolve-promise

~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

utf-8:~ENCODING#utf-8
符号化法:~ENCODING#encoding
名前.enc:~ENCODING#name

Char.prod:~TR/xml/#NT-Char
Name.prod:~TR/xml/#NT-Name
QName.prod:~TR/xml-names/#NT-QName
PrefixedName.prod:~TR/xml-names/#NT-PrefixedName

~HTML構文解析器:~HTMLparsing#html-parser
並列的:~HTMLINFRA#in-parallel

その例外を報告する:~WAPI#report-the-exception
関連する大域~obj:~WAPI#concept-relevant-global
現在の大域~obj:~WAPI#current-global-object
関連する~Realm:~WAPI#concept-relevant-realm
複合~小task下位~taskを実行する:~WAPI#execute-a-compound-microtask-subtask
複合~小task:~WAPI#compound-microtask
小taskを~queueする:~WAPI#queue-a-microtask
~event~handler:~WAPI#event-handlers

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

閲覧文脈:~BROWSERS#browsing-context
互いに関係するかつ生成元も類似する閲覧文脈~群:~BROWSERS#unit-of-related-similar-origin-browsing-contexts
属する閲覧文脈:~BROWSERS#concept-document-bc

~sw:~SW#dfn-service-worker
~script資源:~SW#dfn-script-resource
評価されたことがある~flag:~SW#dfn-has-ever-been-evaluated-flag

~Realm:~TC39#realm
時刻起点:~HRTIME#dfn-time-origin

	:https://w3c.github.io/webcomponents/spec/shadow/
	:~HTMLselectors#selector-defined
	:#mutation-algorithms


●●ref_normative

[DEVICE-ORIENTATION]
    Rich Tibbett; et al. DeviceOrientation Event Specification. URL: https://w3c.github.io/deviceorientation/spec-source-orientation.html 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[HR-TIME]
    Jatinder Mann. High Resolution Time. 17 December 2012. REC. URL: https://www.w3.org/TR/hr-time/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. URL: https://drafts.csswg.org/selectors 
[SERVICE-WORKERS]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 
[TOUCH-EVENTS]
    Doug Schepers; et al. Touch Events. URL: https://w3c.github.io/touch-events/ 
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. UI Events. URL: https://w3c.github.io/uievents/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml/ 
[XML-NAMES]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/ 

●●ref_informative

[CSSOM-VIEW]
    Simon Pieters. CSSOM View Module. URL: https://drafts.csswg.org/cssom-view/ 
[DOM-Level-2-Traversal-Range]
    Joseph Kesselman; et al. Document Object Model (DOM) Level 2 Traversal and Range Specification. 13 November 2000. REC. URL: https://www.w3.org/TR/DOM-Level-2-Traversal-Range/ 
[DOM-Level-3-Core]
    Arnaud Le Hors; et al. Document Object Model (DOM) Level 3 Core Specification. 7 April 2004. REC. URL: https://www.w3.org/TR/DOM-Level-3-Core/ 
[DOM-Parsing]
    Travis Leithead. DOM Parsing and Serialization. URL: https://w3c.github.io/DOM-Parsing/ 
[ELEMENTTRAVERSAL]
    Doug Schepers; Robin Berjon. Element Traversal Specification. 22 December 2008. REC. URL: https://www.w3.org/TR/ElementTraversal/ 
[INDEXEDDB]
    Nikunj Mehta; et al. Indexed Database API. URL: http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html 
[FULLSCREEN]
    Philip Jägenstedt. Fullscreen API Standard. Living Standard. URL: https://fullscreen.spec.whatwg.org/ 
[PROMISES-GUIDE]
    Domenic Denicola. Writing Promise-Using Specifications. 16 February 2016. Finding of the W3C TAG. URL: https://www.w3.org/2001/tag/doc/promises-guide 
[SELECTORS-API2]
    Lachlan Hunt. Selectors API Level 2. URL: http://dev.w3.org/2006/webapi/selectors-api2/ 
[UIEVENTS-20031107]
    Philippe Le Hégaret; Tim Pixley. Document Object Model (DOM) Level 3 Events Specification. URL: https://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107 


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">DOM Standard</a>
仕様（通称 “DOM-LS”, “DOM4”, “DOM Core” ）を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/dom">GitHub whatwg/dom</a> (<a href="https://github.com/whatwg/dom/issues/new">new issue</a>, <a href="https://github.com/whatwg/dom/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/dom/commits
	<a href="https://dom.spec.whatwg.org/commit-snapshots/eb0db13154aebd27cf7d832b5d0d760bdbb13a95/">Snapshot as of this commit</a>
	<a href="https://twitter.com/thedomstandard">@thedomstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/dom">web-platform-tests dom/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/dom">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）


</script>


</head>

<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiIHN0cm9rZS13aWR0aD0iMTAiIGZpbGw9IiNmZmYiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIvPgo8cGF0aCBkPSJtNTAsMjV2MTVsLTE1LDEwLTEwLDE1bTEwLTE1bDEwLDE1bTUtMjVsMTUsMTAsMTAsMTVtLTEwLTE1bC0xMCwxNSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>DOM</h1>
	</hgroup>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
~DOMは、~platformに中立的な，［
~event, ~promiseによる活動の中止-法, ~node木
］の~modelを定義する。
◎
DOM defines a platform-neutral model for events, aborting activities and node trees.
</p>

	</section>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
この仕様は~DOMを標準~化する。
次を行うことにより：
◎
This specification standardizes the DOM. It does so as follows:
</p>

<ol>
	<li>
<div class="p">
<p>
次に挙げる仕様を整理統合して：
</p>

<ul ><li>`DOM Level 3 Core^cite `DOM-Level-3-Core$r
</li><li>`Element Traversal^cite `ELEMENTTRAVERSAL$r
</li><li>`Selectors API Level 2^cite `SELECTORS-API2$r
</li><li>`DOM Level 3 Events^cite `uievents-20031107$r
の "DOM Event Architecture" 章と "Basic Event Interfaces" 章
（特定の型の~eventは~DOM標準には属さない）
</li><li>`DOM Level 2 Traversal and Range^cite `DOM-Level-2-Traversal-Range$r
</li></ul>

<p>
それらを：
</p>

◎
By consolidating DOM Level 3 Core [DOM-Level-3-Core], Element Traversal [ELEMENTTRAVERSAL], Selectors API Level 2 [SELECTORS-API2], the "DOM Event Architecture" and "Basic Event Interfaces" chapters of DOM Level 3 Events [uievents-20031107] (specific types of events do not belong in the DOM Standard), and DOM Level 2 Traversal and Range [DOM-Level-2-Traversal-Range], and:
</div>

		<ul>
			<li>
可能な所では~JS ecosystem に合わせ，
◎
Aligning them with the JavaScript ecosystem where possible.
</li>
			<li>
既存の実装に揃わせ，
◎
Aligning them with existing implementations.
</li>
			<li>
可能な限り単純~化する。
◎
Simplifying them as much as possible.
</li>
		</ul>
	</li>
	<li>
~HTML標準 `HTML$r から，この~DOM標準の一部として指定されるべき特色機能を移行させる。
◎
By moving features from the HTML Standard [HTML] that make more sense to be specified as part of the DOM Standard.
</li>
	<li>

<p>
`DOM Level 3 Events^cite
`uievents-20031107$r
の，問題のあった古い~modelの "Mutation Events" 章と "Mutation Name Event Types" 章に代わるものを定義する。
◎
By defining a replacement for the "Mutation Events" and "Mutation Name Event Types" chapters of DOM Level 3 Events [uievents-20031107] as the old model was problematic.
</p>

<p class="note">注記：
この結果、古い~modelは実装から除去されることが期待されている。
◎
The old model is expected to be removed from implementations in due course.
</li>
<li>
新たな特色機能を定義して、共通の~DOM演算を単純~化する。
◎
By defining new features that simplify common DOM operations.
</li>
</ol>

	</section>
	<section id="infrastructure">
<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様の一部の用語は
`Encoding^cite,
`Selectors^cite,
`Web IDL^cite,
`XML^cite,
`Namespaces in XML^cite
にて定義される。
`ENCODING$r
`SELECTORS4$r
`WEBIDL$r
`XML$r
`XML-NAMES$r
◎
Some of the terms used in this specification are defined in Encoding, Selectors, Web IDL, XML, and Namespaces in XML. [ENCODING] [SELECTORS4] [WEBIDL] [XML] [XML-NAMES]
</p>

<p>
語
`文脈~obj@
とは、論の対象の［
~algo／属性~取得子／属性~設定子／~meth
］が~callされた~objを指す。
【この訳では、より簡潔に，太字で “此れ” と記す。】
◎
The term context object means the object on which the algorithm, attribute getter, attribute setter, or method being discussed was called.
</p>

<p>
拡張が必要になったときは、それに則って~DOM標準が更新されるか，あるいは
`適用-可能な仕様@†
用に供される拡張用~hookを利用するような，新たな標準が書かれ得る。
◎
When extensions are needed, the DOM Standard can be updated accordingly, or a new standard can be written that hooks into the provided extensibility hooks for applicable specifications.
</p>

<p class="trans-note">【†
`HTML$r に定義される<a href="~HTMLINFRA#other-applicable-specifications">同じ名前の用語</a>と同様
— この仕様~自身も含まれる。
】</p>


		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳では，以下の表記が用いられる：
</p>

<ul>
	<li>
この仕様を通して，よく用いられる［
“結付けられる”,
“初期化される”,
“新たな … ” 
］等々の句については、
<a href="index.html#common-wording">~~共通の慣用表現</a>を~~参照されたし。
</li>
	<li>
~algoや定義の記述に利用されている各種記号（ ε, ~LET, ~EQ, ~IF, ~EACH (…), ~RET, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</li>
	<li>
太字の “此れ” は，`文脈~obj$を意味する。
</li>
	<li>
所与の［
有限個の~objからなる有順序~集合（例えば`木$や~list）の部分集合（例えば ある条件を満たすものなど）
］ %S に対し，その［
`最初のもの？@
／
`最後のもの？@
］とは、 %S が空（例えば，条件を満たす~objが存在しない）ならば ~NULL であり，そうでなければ その順序において %S の中で［
最初 ／ 最後
］に在る~objとする。
<small >（
“最初” ／ “最後” がこの意味で用いられる所（ ~NULL にもなり得る所）では、常に（ WebIDL 方式に倣って） "?" が付記される。
）</small>
</li>
	<li>
整数 %index に対する “%index 番” は 0 番から数えるものとする。
</li>
</ul>

		</section>
		<section id="trees">
<h3 title="Trees">1.1. 木</h3>
<!-- Sorry reddit, this is not /r/trees -->

<p>
`木@
とは、有限の階層的な木~構造を意味する。
`木~順序@
は、深優先前順走査に基づく。
◎
A tree is a finite hierarchical tree structure. In tree order is preorder, depth-first traversal of a tree.
</p>

<div class="trans-note" id="example-tree">
<p>【
`<a href="https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2" >深さ優先</a>^_,
`<a href="https://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_%28%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%29#.E8.B5.B0.E6.9F.BB.E6.B3.95" >前順</a>^_
】：
この方式による木の走査-は、~HTMLや~XML文書の~source~text表現における，要素の開始~tagや~text内容（より一般には`文字~data~node$）が現れる順序を表現する（ゆえに， “文書~順序” と称されることもある）。
この順序を反映するように木の一例を可視化した模式図を下に示す。
図の 左端／右端 が~sourceの 先頭／末尾 に対応する。
図の横線が，木の中の各~nodeとそれが~source内を占める~~範囲（要素の開始~tag〜終了~tag, あるいは文字~dataの先頭〜末尾）を表し、それらの上下関係が木の階層（~nodeの入子~階層）を表す。
図の中の各~文字は文字~dataの各~文字に対応し，それらがなす各~COLOR_Rが`文字~data~node$が占める~~範囲を表す。
~nodeの順序はこれらの横線の左端の位置から決定される。
最上層の横線がこの木の根~node（根元）を表し，この順序における先頭になる。
</p>

`[&nbsp;[&nbsp;]&nbsp;(~sourceに)&nbsp;[&nbsp;(現れる)&nbsp;[&nbsp;(順序が)&nbsp;]&nbsp;[&nbsp;(そのまま)&nbsp;[&nbsp;(木~順序に)&nbsp;]&nbsp;]&nbsp;(なる)&nbsp;]&nbsp;]^bpex

<p>
この図に対応する~sourceは次の様になる（簡単にするため，`e^e 要素と~text内容のみから構成されている）：
</p>

<pre>
&lt;e&gt;&lt;e&gt;&lt;/e&gt;~sourceに&lt;e&gt;現れる&lt;e&gt;順序が&lt;/e&gt;&lt;e&gt;そのまま&lt;e&gt;木~順序に&lt;/e&gt;&lt;/e&gt;なる&lt;/e&gt;&lt;/e&gt;
</pre>

</div>


<p>
`木$に
`関与して@
いる各~objは、~objまたは~NULL をとる
`親@
を持ち，
0 個以上の~objからなる`有順序~集合$を成す
`子たち@
を持つ。
~obj %A の`親$ %B ~NEQ ~NULL ならば， %A は %B の`子$である。
◎
An object that participates in a tree has a parent, which is either null or an object, and has children, which is an ordered set of objects. An object A whose parent is object B is a child of B.
</p>

<p class="trans-note">【
%A は %B の “子である” という句は、［
%A ~IN %B の`子たち$
］を意味する。
】【
%B は “子を持つ” という句は、［
%B の`子たち$は`空$でない
］ことを意味する。
】【
同じ~objが同時に複数の~objの子になることはない。
】</p>

<p>
~objの
`根@
とは、［
~objの`親$ ~EQ ~NULL
］ならば~obj自身であり，他の場合は~objの`親$の`根$である。
`木$の`根$は、その`木$に`関与して$いる~objであって，［
`親$ ~EQ ~NULL
］なるものである。
◎
The root of an object is itself, if its parent is null, or else it is the root of its parent. The root of a tree is any object participating in that tree whose parent is null.
</p>

<p class="trans-note">【
この定義は、`親$を順々に辿った結果は循環しない（自身には戻らない）ことも含意している。
同様に，`子$を順々に辿った結果も循環しない。
】</p>

<p>
~obj %A が~obj %B の
`子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子$である
］~OR［
%A は %B のある`子孫$の`子$である
］
◎
An object A is called a descendant of an object B, if either A is a child of B or A is a child of an object C that is a descendant of B.
</p>

<p class="trans-note">【
上述したように循環しないので、
%A 自身が %A の`子孫$になることはない。
】</p>

<p>
~obj %A が~obj %B の
`広義子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`子孫$である
］
◎
An inclusive descendant is an object or one of its descendants.
</p>

<p class="trans-note"><small>【
“広義” という対訳は，よいとは言えないが、より忠実に “自身も含めた子孫” などと訳すのでは，用語として定義する意義
— 他から簡潔に参照できるようにする —
も失われる（単に “自身または子孫” と記すのと同じことになる）。
】</small></p>

<p>
~obj %A が~obj %B の
`先祖@
であるとは、次を意味する
⇒
%B は %A の`子孫$である
◎
An object A is called an ancestor of an object B if and only if B is a descendant of A.
</p>

<p>
~obj %A が~obj %B の
`広義先祖@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`先祖$である
］
◎
An inclusive ancestor is an object or one of its ancestors.
</p>

<p>
~obj %A が~obj %B の
`同胞@
（ “兄弟” ）であるとは、次を意味する
⇒
［
%A の`親$ ~NEQ ~NULL
］~AND［
%A の`親$ ~EQ %B の`親$
］
◎
An object A is called a sibling of an object B, if and only if B and A share the same non-null parent.
</p>

<p class="trans-note">【
定義により， %A 自身も
<em>親が非~NULLならば</em>
%A の`同胞$になる。
この仕様の中では、この点について特に注意を要する箇所は（現時点では）ないが。
例えば、この同胞の定義を
“%A と %B は同じでない”
と解釈したとしても，この仕様の残りの部分には影響しない。
】</p>

<p>
~obj %A が~obj %B の
`広義同胞@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`同胞$である
］
◎
An inclusive sibling is an object or one of its siblings.
</p>

<p class="trans-note">【
%A 自身は，親が~NULLであっても %A の広義同胞になる点で、`同胞$の定義と異なる。
この定義は、もっぱら他の仕様~用にあり，この仕様~内では利用されない。
】</p>
<!-- https://github.com/whatwg/dom/issues/55 -->

<p>
~obj %A が~obj %B に
`先行-@
するとは、次を意味する
⇒
［
%A と %B は同じ`木$に関与する
］~AND［
`木~順序$において %A は %B より前に在る
］
<!-- * A ≺ B -->
◎
An object A is preceding an object B if A and B are in the same tree and A comes before B in tree order.
</p>

<p>
~obj %A が~obj %B に
`後続-@
するとは、次を意味する
⇒
［
%A と %B は同じ`木$に関与する
］~AND［
`木~順序$において %A は %B より後に在る
］
<!-- * A ≻ B -->
◎
An object A is following an object B if A and B are in the same tree and A comes after B in tree order.
</p>

<p>
~objの
`最初の子？@
とは、~objの`子$のうち，`最初のもの？$である。
◎
The first child of an object is its first child or null if it has no children.
</p>

<p>
~objの
`最後の子？@
とは、~objの`子$のうち，`最後のもの？$である。
◎
The last child of an object is its last child or null if it has no children.
</p>

<p>
~objの
`前-同胞？@
とは、~objに`先行-$する`同胞$のうち，`最後のもの？$である。
◎
The previous sibling of an object is its first preceding sibling or null if it has no preceding sibling.
</p>

<p>
~objの
`次-同胞？@
とは、~objに`後続-$する`同胞$のうち，`最初のもの？$である。
◎
The next sibling of an object is its first following sibling or null if it has no following sibling.
</p>

<p>
~objの
`指数@
とは、~objに`先行-$する`同胞$の個数である（なければ 0 になる）。
◎
The index of an object is its number of preceding siblings, or 0 if it has none. 
</p>




		</section>
		<section id="ordered-sets">
<h3 title="Ordered sets">1.2. 有順序~集合</h3>

<p class="algo-head">
文字列 %入力 を
`有順序~集合 構文解析器@
にかけるときは、次を走らす：
◎
The ordered set parser takes a string input and then runs these steps:
</p>

<ol>
	<li>
%入力~token列 ~LET `~ASCII空白で分割する$( %入力 )
◎
Let inputTokens be the result of splitting input on ASCII whitespace.
</li>
	<li>
%~token列 ~LET 新たな`有順序~集合$ 
◎
Let tokens be a new ordered set.
</li>
	<li>
%入力~token列 内の~EACH ( %~token ) に対し
⇒
%~token列 に %~token を`付加する$set
◎
For each token in inputTokens, append token to tokens.
</li>
	<li>
~RET %~token列
◎
Return tokens.
</li>
</ol>

<p class="algo-head">
文字列からなる有順序~集合 %S を
`有順序~集合 直列化器@
にかけるときは、
%S を U+0020 で`連結-$した結果を返す。
◎
The ordered set serializer takes a set and returns the concatenation of set using U+0020 SPACE.
</p>

		</section>
		<section id="selectors">
<h3 title="Selectors">1.3. 選択子</h3>


<p class="algo-head">
%node の
`視野の下で選択子を照合する@
ときは、所与の
( 文字列 %選択子 )
に対し，次を走らす：
◎
To scope-match a selectors string selectors against a node, run these steps:
</p>

<ol>
	<li>
%S ~LET `選択子として構文解析する$( %選択子 )
`SELECTORS4$r
◎
Let s be the result of parse a selector selectors. [SELECTORS4]
</li>
	<li>
~IF［
%S ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET
`木に対し選択子を照合する$( 選択子 %S, 根~要素たち %node の`根$, `視野根$ %node )
`SELECTORS4$r
◎
Return the result of match a selector against a tree with s and node’s root using scoping root node. [SELECTORS4].
</li>
</ol>

<p class="note">注記：
選択子の中の~nsに対する~supportは、計画されておらず，追加されることはない。
◎
Support for namespaces within selectors is not planned and will not be added.
</p>

		</section>
		<section id="namespaces">
<h3 title="Namespaces">1.4. ~ns</h3>

<p class="algo-head">
`有修飾~名として検証する@
ときは、所与の
( %名前 )
に対し，次を走らす
⇒
~IF［
%名前 は `Name$prod 生成規則にも `QName$prod 生成規則にも合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
To validate a qualifiedName, throw an "InvalidCharacterError" DOMException if qualifiedName does not match the Name or QName production.
</p>

<p class="algo-head">
`検証して抽出する@
ときは、所与の
( %~ns, %名前 )
に対し，次を走らす：
◎
To validate and extract a namespace and qualifiedName, run these steps:
</p>

<ol>
	<li id="cp-normalize-ns">
~IF［
%~ns ~EQ 空~文字列
］
⇒
%~ns ~SET ~NULL
◎
If namespace is the empty string, set it to null.
</li>
	<li>
`有修飾~名として検証する$( %名前 )
◎
Validate qualifiedName.
</li>
	<li>
%接頭辞 ~LET ~NULL
◎
Let prefix be null.
</li>
	<li>
%局所~名 ~LET %名前
◎
Let localName be qualifiedName.
</li>
	<li>
~IF［
%名前 は `:^l (U+003A) を含む
【 `PrefixedName$prod 生成規則に合致】
］
⇒
( %接頭辞, %局所~名 ) ~SET
%名前 をそこで分割して得られる ( 前の部分, 後の部分 )
◎
If qualifiedName contains a ":" (U+003E), then split the string on it and set prefix to the part before and localName to the part after.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
↓</p>

		<ul>
			<li>
［
%~ns ~EQ ~NULL
］~AND［
%接頭辞 ~NEQ ~NULL
］
◎
If prefix is non-null and namespace is null, then throw a "NamespaceError" DOMException.
</li>
			<li>
［
%~ns ~NEQ `~XML~ns$
］~AND［
%接頭辞 ~EQ `xml^l
］
◎
If prefix is "xml" and namespace is not the XML namespace, then throw a "NamespaceError" DOMException.
</li>
			<li>
［
%~ns ~NEQ `~XMLNS~ns$
］~AND［［
%名前 ~EQ `xmlns^l
］~OR［
%接頭辞 ~EQ `xmlns^l
］］
◎
If either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace, then throw a "NamespaceError" DOMException.
</li>
			<li>
［
%~ns ~EQ `~XMLNS~ns$
］~AND［
%名前 ~NEQ `xmlns^l
］~AND［
%接頭辞 ~NEQ `xmlns^l
］
◎
If namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns", then throw a "NamespaceError" DOMException.
</li>
		</ul>

<p>
…ならば
⇒
~THROW `NamespaceError$E
◎
↑</p>

	</li>
	<li>
~RET ( %~ns, %接頭辞, %局所~名 )
◎
Return namespace, prefix, and localName.
</li>
</ol>


		</section>
	</section>
	<section id="events">
<h2 title="Events">2. ~event</h2>

		<section id="introduction-to-dom-events">
<h3 title="Introduction to “DOM Events”">2.1. “DOM Events” 序論</h3>

<!-- ^@EventTarget -->

<p>
Web ~platformを全体を通して，`~event$は、~network活動や利用者との対話など，何かが生じた際に通達するために，~objに向けて`配送-$される。
これらの~objは $EventTarget ~ifcを実装し，
その $addEventListener() を~callすることにより
`~event$を観測するための`~event~listener$を追加できる：
◎
Throughout the web platform events are dispatched to objects to signal an occurrence, such as network activity or user interaction. These objects implement the EventTarget interface and can therefore add event listeners to observe events by calling addEventListener():
</p>

<div class="example">
<pre class="js-code">
%obj.addEventListener("load", imgFetched)

function imgFetched(%ev) {
  // <span class="comment" title="great success">成功裡に load できた</span>
  …
}</pre>

</div>

<p>
`~event~listener$は、
$removeEventListener()
~methに同じ引数を渡すことにより除去できる。
◎
Event listeners can be removed by utilizing the removeEventListener() method, passing the same arguments.
</p>

<!-- ^@Event -->

<p>
`~event$もまた~objであり，
$Event ~ifc（またはその派生~ifc）を実装する。
上の例では、 %ev が`~event$である。
それは `~event~listener$の `callback$evL （概して上に示したような~JS Function ）に引数として渡される。
`~event~listener$は、まず，`~event$の $type 属性~値（上の例では `load^l ）をその~~制御に利用する。
`~event$の $target 属性~値は`~event$の`配送-$先の~obj（上の例の %obj ）を返す。
◎
Events are objects too and implement the Event interface (or a derived interface). In the example above ev is the event. It is passed as argument to event listener’s callback (typically a JavaScript Function as shown above). Event listeners key off the event’s type attribute value ("load" in the above example). The event’s target attribute value returns the object to which the event was dispatched (obj above).
</p>

<p id="synthetic-events">
概して、`~event$は，利用者との対話や何らかの~task完了の結果，~UAにより`配送-$されるものであるが、~app自身も`~event$を`配送-$できる（合成~eventと共通的に称されている）：
◎
Now while typically events are dispatched by the user agent as the result of user interaction or the completion of some task, applications can dispatch events themselves, commonly known as synthetic events:
</p>

<div class="example"><pre>// <span class="comment" title="add an appropriate event listener">~custom~event~listenerを追加する</span>
obj.addEventListener("cat", function(%e) { process(%e.detail) })

// <span class="comment" title="create and dispatch the event">~eventを作成して配送する</span>
var %event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
%obj.dispatchEvent(%event)</pre></div>

<p>
通達-時の他にも、`~event$は，演算の中で次に起きる出来事を~appに制御させる~~目的で利用されることがある。
例えば，~form提出の一環として、 $type 属性が `submit^l にされた`~event$が`配送-$される。
この`~event$の $preventDefault() ~methが呼出されると，~formは提出されずに終了されることになる。
~appにより`配送-$される`~event$（合成~event）を通して，この機能性を利用する場合、 $EventTarget.dispatchEvent() ~methの返値も利用できる：
◎
Apart from signaling, events are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an event whose type attribute value is "submit" is dispatched. If this event’s preventDefault() method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through events dispatched by the application (synthetic events) can make use of the return value of the dispatchEvent() method:
</p>

<div class="example">

<pre class="js-code">
if(%obj.dispatchEvent(%event)) {
  // <span class="comment" title="event was not canceled, time for some magic">~eventは取消されなかった。手品の時間だ。</span>
  …
}</pre>

</div>

<p>
`~event$が`木$に`関与して$いる~obj（例えば`要素$）に向けて`配送-$される場合、その~eventは，その~objの`先祖$ 上の`~event~listener$にも到達し得る：
◎
When an event is dispatched to an object that participates in a tree (e.g. an element), it can reach event listeners on that object’s ancestors too.＼
</p>

<ol>
	<li>
最初は、~objの各 `先祖$に対し，
`capture$evL 変数が ~T にされている`~event~listener$が`木~順序$で呼出される。
◎
First all object’s ancestor event listeners whose capture variable is set to true are invoked, in tree order.＼
</li>
	<li>
次に、~obj自身の`~event~listener$が呼出される。
◎
Second, object’s own event listeners are invoked.＼
</li>
	<li>
最後に、`~event$の $bubbles 属性~値が true のときにのみ，~objの各 `先祖$に対し
【 `capture$evL 変数が ~F にされている】
`~event~listener$が，今度は`木~順序$の逆順に呼出される。
◎
And finally, and only if event’s bubbles attribute value is true, object’s ancestor event listeners are invoked again, but now in reverse tree order.
</li>
</ol>

<div class="example">
<p>
`~event$が`木$内で働く様子を例で示す：
◎
Lets look at an example of how events work in a tree:
</p>

<pre class="html-code">
&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;つまらない例&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello <mark>&lt;span id=x&gt;world&lt;/span&gt;</mark>!&lt;/p&gt;
  &lt;script&gt;
<code
>function test(%e) {
  debug(%e.target, %e.currentTarget, %e.eventPhase); // A
}
document.addEventListener("hey", test, {capture: true}); // B
document.body.addEventListener("hey", test); // C
var %ev = new Event("hey", {bubbles:true})
document.getElementById(<mark>"x"</mark>).dispatchEvent(%ev);</code>
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
`debug^c 関数（A）は 2 回~呼出されることになる。
2 回とも、`~event$の $target 属性~値は <mark>`span^c `要素$</mark> になる。
1 回目での $currentTarget 属性~値は`文書$になり（B）,
$eventPhase 属性の値が $CAPTURING_PHASE から $BUBBLING_PHASE に切り替わった後,
2 回目では `body^e `要素$になる（C）。
もし`~event~listener$が `span^e `要素$にも登録されていたなら、$eventPhase 属性の値は $AT_TARGET にも切り替わることになる。
◎
The debug function will be invoked twice. Each time the event’s target attribute value will be the span element. The first time currentTarget attribute’s value will be the document, the second time the body element. eventPhase attribute’s value switches from CAPTURING_PHASE to BUBBLING_PHASE. If an event listener was registered for the span element, eventPhase attribute’s value would have been AT_TARGET.
</p>
</div>

		</section>
		<section id="interface-event">
<h3>2.2. ~ifc ^@Event</h3>

！！
[$Constructor(~DS %type, optional $EventInit %eventInitDict),
 `Exposed$=(Window,Worker,AudioWorklet)]
interface @Event {
  ~RA ~DS $type;
  ~RA $EventTarget? $target;
  ~RA $EventTarget? $srcElement; // <span id="cp-histroic" class="comment" title="historical">歴史上</span>
  ~RA $EventTarget? $currentTarget;
  sequence&lt;$EventTarget&gt; $composedPath();

  ~CUS $NONE = 0;
  ~CUS $CAPTURING_PHASE = 1;
  ~CUS $AT_TARGET = 2;
  ~CUS $BUBBLING_PHASE = 3;
  ~RA ~US $eventPhase;

  void $stopPropagation();
           attribute ~B $cancelBubble; // <span class="comment" title="historical alias of .stopPropagation">`stopPropagation()^c の歴史上の別名</span>
  void $stopImmediatePropagation();

  ~RA ~B $bubbles;
  ~RA ~B $cancelable;
           attribute ~B $returnValue;  // <!--cp-histroic-->
  void $preventDefault();
  ~RA ~B $defaultPrevented;
  ~RA ~B $composed;

  [`Unforgeable$] ~RA ~B $isTrusted;
  ~RA $DOMHighResTimeStamp $timeStamp;

  void $initEvent(~DS %type, optional ~B %bubbles = false, optional ~B %cancelable = false); // <!--cp-histroic-->
};

dictionary @EventInit {
  ~B @EventInit.bubbles = false;
  ~B @EventInit.cancelable = false;
  ~B @EventInit.composed = false;
};
！


<p>
$Event ~objは、単に
`~event@
とも称される。
それは、何かが生じたときにそれが通達されるようにする
— 例えば，画像を~downloadし終えたときなど。
◎
An Event object is simply named an event. It allows for signaling that something has occurred, e.g., that an image has completed downloading.
</p>

<p>
`~event~targetになり得るもの@
は、 ~NULL または $EventTarget ~objである。
◎
A potential event target is null or an EventTarget object. 
</p>

<p>
各`~event$には、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~target@</dt>
	<dd>
`~event~targetになり得るもの$。
他が言明されない限り， ~NULL とする。
◎
An event has an associated target (a potential event target). Unless stated otherwise it is null.
</dd>

	<dt>`関係d~target@</dt>
	<dd>
`~event~targetになり得るもの$。
他が言明されない限り， ~NULL とする。
◎
An event has an associated relatedTarget (a potential event target). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
他の仕様は ^relatedTarget 属性を定義するときに `関係d~target$を利用する。
`UIEVENTS$r
◎
Other specifications use relatedTarget to define a relatedTarget attribute. [UIEVENTS]
</dd>

	<dt>`~touch~target~list@</dt>
	<dd>
0 個~以上の`~event~targetになり得るもの$からなる`~list$。
他が言明されない限り，空~listとする。
◎
An event has an associated touch target list (a list of zero or more potential event targets). Unless stated otherwise it is the empty list.
</dd>
	<dd class="note">注記：
`~touch~target~list$は、もっぱら
$TouchEvent ~ifcとそれに関係する~ifcを定義するために利用される。
`TOUCH-EVENTS$r
◎
The touch target list is for the exclusive use of defining the TouchEvent interface and related interfaces. [TOUCH-EVENTS] 
</dd>

	<dt>`経路@</dt>
	<dd>
<p>
0 個~以上の`構造体$
【 “~tuple（ `tuple^en  ）” とも称される】
からなる`~list$であり、初期~時は空とする。
それを成す各 `構造体$は次のものからなる：
</p>
		<dl class="def-list">
			<dt>`~item@evP</dt>
			<dd>
$EventTarget ~obj。
</dd>

			<dt>`~target@evP</dt>
			<dd>
`~event~targetになり得るもの$
</dd>

			<dt>`関係d~target@evP</dt>
			<dd>
`~event~targetになり得るもの$
</dd>

			<dt>`~touch~target~list@evP</dt>
			<dd>
0 個以上の`~event~targetになり得るもの$からなる`~list$
</dd>

			<dt>`~closed木の根？@evP</dt>
			<dd>
真偽値。
</dd>

			<dt>`~slotは~closed木~内？@evP</dt>
			<dd>
真偽値。
</dd>
		</dl>

◎
An event has an associated path. A path is a list of structs. Each struct consists of an item (an EventTarget object), target (a potential event target), a relatedTarget (a potential event target), a touch target list (a list of potential event targets), a root-of-closed-tree (a boolean), and a slot-in-closed-tree (a boolean). A path is initially the empty list.
</dd>
</dl>


<dl class="domintro">
	<dt>%event = new $Event(type [, eventInitDict])</dt>
	<dd>
$type 属性~値が %type にされた，新たな %event を返す。
%eventInitDict 引数（省略可）により，~objの同じ名前の~memberを通して
$bubbles と $cancelable 属性も設定し得る。
◎
Returns a new event whose type attribute value is set to type. The optional eventInitDict argument allows for setting the bubbles and cancelable attributes via object members of the same name.
</dd>

	<dt>%event . $type</dt>
	<dd>
%event の型を返す。
例えば
`click^l,
`hashchange^l,
`submit^l
など。
◎
Returns the type of event, e.g. "click", "hashchange", or "submit".
</dd>


	<dt>%event . $target</dt>
	<dd>
%event の`配送-$先の~obj（ %event の`~target$ ）を返す。
◎
Returns the object to which event is dispatched (its target).
</dd>

	<dt>%event . $currentTarget</dt>
	<dd>
現在~呼出されている `callback$evL を持つ`~event~listener$が登録されている~objを返す。
◎
Returns the object whose event listener’s callback is currently being invoked.
</dd>

	<dt>%event . $composedPath()</dt>
	<dd>
%event の`経路$内にある各 `~item$evP ~obj（それ上で~listenerが呼出される~obj）からなる~listを返す
— ただし、［
`~shadow根$の`~mode$sR ~EQ `closed^l
］なる`~shadow木$内の`~node$であって， %event の $currentTarget からは到達できないものは、返値から除かれる。
◎
Returns the item objects of event’s path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root’s mode is "closed" that are not reachable from event’s currentTarget.
</dd>

	<dt>%event . $eventPhase</dt>
	<dd>
`~event$の相：
$NONE, $CAPTURING_PHASE, $AT_TARGET, $BUBBLING_PHASE 
のいずれかを返す。
◎
Returns the event’s phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.
</dd>

	<dt>%event . $stopPropagation()</dt>
	<dd>
`木$ 内に`配送-$されているとき、この~methを呼出すことにより，現在の~obj以外の~objには %event が到達しないようになる。
◎
When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.
</dd>

	<dt>%event . $stopImmediatePropagation()</dt>
	<dd>
この~methを呼出すことにより、
%event は 現在の~listenerを走り終えた後に［
それまでに登録された`~event~listener$
］には到達しなくなり、`木$ 内に`配送-$されたときには， %event は他のどの~objにも到達しなくなる。
◎
Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.
</dd>

	<dt>%event . $bubbles</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
%event がその`~target$の`先祖$へ`木~順序$の逆順にも遡る場合は ~T を返し,
他の場合は~F を返す。
◎
Returns true or false depending on how event was initialized. True if event goes through its target’s ancestors in reverse tree order, and false otherwise.
</dd>

	<dt>%event . $cancelable</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
その返値は常に意味を持つとは限らないが、~T の場合，
%event が`配送-$されている間の演算は
$preventDefault() ~methを呼出すことにより取消せることを指示し得る。
<!--  -->
◎
Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.
</dd>

	<dt>%event . $preventDefault()</dt>
	<dd>
%event の $cancelable 属性~値が ~T にされている下で，［
$AddEventListenerOptions.passive 属性が ~F に設定された %event
］用の~listenerの実行-中に呼出された場合、
%event が取消される必要がある旨をその`配送-$ 演算に通達する。
◎
If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.
</dd>

	<dt>%event . $defaultPrevented</dt>
	<dd>
~T は、 $preventDefault() が呼出され, 成功裡に取消されたことを指示する。
他の場合は~F を返す。
◎
Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise.
</dd>

	<dt>%event . $composed</dt>
	<dd>
%event がどう初期化されたかに依存して ~T か ~F を返す。
［
%event の`~target$の`根$が $ShadowRoot `~node$である
］ときに，その~nodeを過ぎた先†にある~listenerも呼出す場合は ~T になり、他の場合は~F になる。
◎
Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.
</dd>
	<dd>【†
%~event の`経路$が、`~shadow根$の`~host$を通して別の`~node木$へつながるように，構成される。
】</dd>

	<dt>%event . $isTrusted</dt>
	<dd>
%event が~UA から`配送-$されたものである場合は~T を,
他の場合は~F を返す。
◎
Returns true if event was dispatched by the user agent, and false otherwise.
</dd>

	<dt>%event . $timeStamp</dt>
	<dd>
%event の時刻印を`時刻起点$からのミリ秒数で返す。
◎
Returns the event’s timestamp as the number of milliseconds measured relative to the time origin.
</dd>

</dl>

<dl class="idl-def">
	<dt>@type</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The type attribute must return the value it was initialized to.＼
</dd>
	<dd>
`~event$の作成-時には、この属性は空~文字列に初期化され~MUST。
◎
When an event is created the attribute must be initialized to the empty string.
</dd>

	<dt>@target</dt>
	<dd>
取得子は、此れの`~target$を返さ~MUST。
◎
The target attribute’s getter, when invoked, must return the context object’s target.
</dd>

	<dt>@srcElement</dt>
	<dd>
取得子は、此れの`~target$を返さ~MUST。
◎
The srcElement attribute’s getter, when invoked, must return the context object’s target.
</dd>

	<dt>@currentTarget</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The currentTarget attribute must return the value it was initialized to.＼
</dd>
	<dd>
`~event$の作成-時には、この属性は ~NULL に初期化され~MUST。
◎
When an event is created the attribute must be initialized to null. 
</dd>

	<dt>@composedPath()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The composedPath() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%~composed経路 ~LET 空`~list$
◎
Let reversedComposedPath be an empty list.
</li>
			<li>
%~hidden部分木~level ~LET 0
◎
Let hiddenSubtreeLevel be 0.
</li>
			<li>
%現-~targetに出会った ~LET ~F
◎
Let hasSeenCurrentTarget be false.
</li>
			<li>
%現-~target ~LET 此れの $currentTarget 属性~値
◎
Let currentTarget be the context object’s currentTarget attribute value.
</li>
			<li>
<p>
此れの`経路$ 内の~EACH( %構造体 ) に対し，<em>逆順に</em>：
◎
Let reversedPath be the context object’s path, in reverse order.
◎
For each struct in reversedPath:
</p>
				<ol>
					<li>
~IF［
%構造体 の`~item$evP ~EQ %現-~target
］
⇒
%現-~targetに出会った ~SET ~T
◎
If struct’s item is currentTarget, then set hasSeenCurrentTarget to true.
</li>
					<li>
~ELIF［
%現-~targetに出会った ~EQ ~T
］~AND［
%構造体 の`~closed木の根？$evP ~EQ ~T
］
⇒
%~hidden部分木~level ~INCBY 1
◎
Otherwise, if hasSeenCurrentTarget is true and struct’s root-of-closed-tree is true, then increase hiddenSubtreeLevel by
</li>
					<li>
~IF［
%~hidden部分木~level ~EQ 0
］
⇒
%~composed経路 に %構造体 の`~item$evPを`前付加する$
◎
If hiddenSubtreeLevel is 0, then append struct’s item to reversedComposedPath.
</li>
					<li>
~IF［
%構造体 の`~slotは~closed木~内？$evP~EQ ~T
］~AND［
%~hidden部分木~level ~GT 0
］
⇒
%~hidden部分木~level ~DECBY 1
◎
If struct’s slot-in-closed-tree is true and hiddenSubtreeLevel is greater than 0, then decrease hiddenSubtreeLevel by
</li>
				</ol>
			</li>
			<li>
~RET %~composed経路
◎
Return reversedComposedPath, in reverse order.
</li>
		</ol>

【この訳では、`前付加する$を利用して，記述を簡約している。】
	</dd>

	<dt>@eventPhase</dt>
	<dd>
<p>
取得子は、初期化-時の値を返さ~MUST。
値は、次のいずれかで~MUST（括弧内は数値）：
◎
The eventPhase attribute must return the value it was initialized to, which must be one of the following:
</p>

		<dl>
			<dt>@NONE (0)</dt>
			<dd>
まだ`配送-$されていない`~event$はこの相に属する。
◎
Events not currently dispatched are in this phase.
</dd>

			<dt>@CAPTURING_PHASE (1)</dt>
<!-- * numeric value -->
			<dd>
`~event$が`木$に`関与して$いる~objに向けて`配送-$されるとき、~eventがその`~target$に到達するまでは，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase before it reaches its target.
</dd>

			<dt>@AT_TARGET (2)</dt>
			<dd>
`~event$が`配送-$されるとき、~eventの`~target$上では，この相に属する。
◎
When an event is dispatched it will be in this phase on its target.
</dd>

			<dt>@BUBBLING_PHASE (3)</dt>
			<dd>
`~event$が`木$に`関与して$いる~objに向けて`配送-$されるとき、~eventがその`~target$に到達した後は，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase after it reaches its target.
</dd>
		</dl>
	</dd>
	<dd>
<!-- Initially -->
`~event$の作成-時には、この属性は $NONE に初期化され~MUST。
◎
Initially the attribute must be initialized to NONE.
</dd>
</dl>

<p>
各`~event$には、次に挙げる~flagが結付けられる
— いずれも初期~時は ~OFF とする
⇒＃
`伝播停止@f,
`伝播即停止@f,
`取消d@f,
`受動~listener内@f,
`~composed@f,
`初期化-済み@f,
`配送-@f
◎
Each event has the following associated flags that are all initially unset:
• stop propagation flag
• stop immediate propagation flag
• canceled flag
• in passive listener flag
• composed flag
• initialized flag
• dispatch flag
</p>


<dl class="idl-def">
	<dt>@stopPropagation()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`伝播停止$f ~SET ~ON
◎
The stopPropagation() method, when invoked, must set the context object’s stop propagation flag.
</dd>

	<dt>@cancelBubble</dt>
	<dd>
取得子は、此れの`伝播停止$fに応じて，次を返さ~MUST
⇒＃
~ON ならば ~T ／
~OFF ならば ~F
◎
The cancelBubble attribute’s getter, when invoked, must return true if the context object’s stop propagation flag is set, and false otherwise.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
~IF［
所与の値 ~EQ ~T
］
⇒
此れの`伝播停止$f ~SET ~ON
◎
The cancelBubble attribute’s setter, when invoked, must set the context object’s stop propagation flag if the given value is true, and do nothing otherwise.
</dd>

	<dt>@stopImmediatePropagation()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの ( `伝播停止$f, `伝播即停止$f ) ~SET ( ~ON, ~ON )
◎
The stopImmediatePropagation() method, when invoked, must set the context object’s stop propagation flag and the context object’s stop immediate propagation flag.
</dd>

	<dt>@bubbles</dt>
	<dt>@cancelable</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
◎
The bubbles and cancelable attributes must return the values they were initialized to.
</dd>

</dl>

<p class="algo-head">
`取消d~flagを設定する@
ときは、所与の
( `~event$ %~event )
に対し，次を走らせ~MUST
⇒
~IF［
%~event の $cancelable 属性~値 ~EQ ~T
］~AND［
%~event の`受動~listener内$f ~EQ ~OFF
］
⇒
%~event の`取消d$f ~SET ~ON
◎
To set the canceled flag, given an event event, if event’s cancelable attribute value is true and event’s in passive listener flag is unset, then set event’s canceled flag, and do nothing otherwise.
</p>

<dl class="idl-def">
	<dt>@returnValue</dt>
	<dd>
取得子は、此れの`取消d$fに応じて，次を返さ~MUST
⇒＃
~ON ならば ~T ／
~OFF ならば ~F
◎
The returnValue attribute’s getter, when invoked, must return false if context object’s canceled flag is set, and true otherwise.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
~IF［
所与の値 ~EQ ~F
］
⇒
`取消d~flagを設定する$( 此れ )
◎
The returnValue attribute’s setter, when invoked, must set the canceled flag with the context object if the given value is false, and do nothing otherwise.
</dd>

	<dt>@preventDefault()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
`取消d~flagを設定する$( 此れ )
◎
The preventDefault() method, when invoked, must set the canceled flag with the context object. 
</dd>
	<dd class="note">注記：
$preventDefault() を呼出しても効果がない局面もある。
~UAには、~debugを援助するため，精確な~~原因を開発者~consoleに~logすることが奨励される。
◎
There are scenarios where invoking preventDefault() has no effect. User agents are encouraged to log the precise cause in a developer console, to aid debugging.
</dd>

	<dt>@defaultPrevented</dt>
	<dd>
取得子は、此れの`取消d$f に応じて，次を返さ~MUST
⇒＃
~ON ならば ~T ／
~OFF ならば ~F
◎
The defaultPrevented attribute’s getter, when invoked, must return true if the context object’s canceled flag is set, and false otherwise.
</dd>

	<dt>@composed</dt>
	<dd>
取得子は、此れの`~composed$f に応じて，次を返さ~MUST
⇒＃
~ON ならば ~T ／
~OFF ならば ~F
◎
The composed attribute’s getter, when invoked, must return true if the context object’s composed flag is set, and false otherwise.
</dd>

	<dt>@isTrusted</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The isTrusted attribute must return the value it was initialized to.＼
</dd>
	<dd>
`~event$の作成-時には、この属性は~F に初期化され~MUST。
◎
When an event is created the attribute must be initialized to false.
</dd>
	<dd class="note">注記：
$isTrusted は、`~event$は（ $EventTarget.dispatchEvent() を利用してではなく）~UAにより`配送-$されたかどうかを簡便に指示する。
唯一の旧来の例外は `click()$m であり，~UAに`~event$を［
$isTrusted 属性は ~F に初期化-
］した上で配送させる。
◎
isTrusted is a convenience that indicates whether an event is dispatched by the user agent (as opposed to using dispatchEvent()). The sole legacy exception is click(), which causes the user agent to dispatch an event whose isTrusted attribute is initialized to false.
</dd>

	<dt>@timeStamp</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The timeStamp attribute must return the value it was initialized to.
</dd>
</dl>


<p class="algo-head">
`~eventを初期化する@
ときは、所与の
( %event, %type, %bubbles, %cancelable )
に対し，
%event の各種~propを次のように設定し~MUST
⇒＃
`初期化-済み$f ~SET ~ON,
`伝播停止$f ~SET ~OFF,
`伝播即停止$f ~SET ~OFF,
`取消d$f ~SET ~OFF,
$isTrusted 属性 ~SET ~F,
`~target$ ~SET ~NULL,
$type 属性 ~SET %type,
$bubbles 属性 ~SET %bubbles,
$cancelable 属性 ~SET %cancelable
◎
To initialize an event, with type, bubbles, and cancelable, run these steps:
• Set event’s initialized flag.
• Unset event’s stop propagation flag, stop immediate propagation flag, and canceled flag.
• Set event’s isTrusted attribute to false.
• Set event’s target to null.
• Set event’s type attribute to type.
• Set event’s bubbles attribute to bubbles.
• Set event’s cancelable attribute to cancelable.
</p>


<dl class="idl-def">
	<dt>@initEvent(type, bubbles, cancelable)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The initEvent(type, bubbles, cancelable) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`配送-$f ~EQ ~ON
］
⇒
~RET
◎
If the context object’s dispatch flag is set, then return.
</li>
			<li>
`~eventを初期化する$( 此れ, %type, %bubbles, %cancelable )
◎
Initialize the context object with type, bubbles, and cancelable. 
</li>
		</ol>
	</dd>
	<dd class="note">注記：
$initEvent() は、`~event$には構築子があるので冗長であり，また $composed も設定できないが、旧来の内容~用に~supportされる必要がある。
◎
As events have constructors initEvent() is redundant and incapable of setting composed. It has to be supported for legacy content.
</dd>
</dl>


		</section>
		<section id="interface-customevent">
<h3>2.3. ~ifc ^@CustomEvent</h3>

！！
[$Constructor(~DS %type, optional $CustomEventInit %eventInitDict),
 `Exposed$=(Window,Worker)]
interface @CustomEvent : $Event {
  ~RA any $detail;

  void $initCustomEvent(~DS %type, optional ~B %bubbles = false, optional ~B %cancelable = false, optional any %detail = null);
};

dictionary @CustomEventInit : $EventInit {
  any @CustomEventInit.detail = null;
};
！

<!-- ^@CustomEvent -->
<p>
~custom~dataを運ばせる用途に，
$CustomEvent ~ifcを利用する`~event$を利用できる。
◎
Events using the CustomEvent interface can be used to carry custom data.
</p>

<dl class="domintro">
	<dt>%event = new $CustomEvent(type [, eventInitDict])</dt>
	<dd>
%eventInitDict 引数（省略可）により，
$detail 属性も設定できることを除き、
$Event の構築子と同様にふるまう。
◎
Works analogously to the constructor for Event except that the optional eventInitDict argument now allows for setting the detail attribute too.
</dd>

	<dt>%event . $detail</dt>
	<dd>
%event の作成-時に与えられた~custom~dataを返す。
概して，合成~eventで利用される。
<!-- initCustomEvent is dead -->
◎
Returns any custom data event was created with. Typically used for synthetic events.
</dd>

</dl>

<dl class="idl-def">
	<dt>@detail</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The detail attribute must return the value it was initialized to.
</dd>

	<dt>@initCustomEvent(type, bubbles, cancelable, detail)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The initCustomEvent(type, bubbles, cancelable, detail) method must, when invoked, run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`配送-$f ~EQ ~ON
］
⇒
~RET
◎
If the context object’s dispatch flag is set, then return.
</li>
			<li>
`~eventを初期化する$( 此れ, %type, %bubbles, %cancelable )
◎
Initialize the context object with type, bubbles, and cancelable.
</li>
			<li>
此れの $detail 属性 ~SET %detail
◎
Set the context object’s detail attribute to detail.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="constructing-events">
<h3 title="Constructing events">2.4. ~eventの構築-法</h3>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~event$用に
`~event構築-時の手続き@
を定義しても~MAY。
この~algoは、`~eventを内部的に作成する$手続き内から，
( `~event$ )
を渡して呼出される。
◎
Specifications may define event constructing steps for all or some events. The algorithm is passed an event as indicated in the inner event creation steps.
</p>


<p class="note">注記：
この構成子は、 $Event 下位classが，その初期化-用の辞書~memberと~IDL属性とが一対一に対応していない，より複雑な構造を備えるときに利用できる。
◎
This construct can be used by Event subclasses that have a more complex structure than a simple 1:1 mapping between their initializing dictionary members and IDL attributes.
</p>

<dl class="idl-def">
	<dt>@Event.Event(type, eventInitDict)</dt>
	<dt>@CustomEvent.CustomEvent(type, eventInitDict)</dt>
	<dd>
<p>
`~event構築子@
— すなわち，［
$Event ~ifc, または それを継承する~ifc
］ %~ifc の構築子 —
は、次を走らせ~MUST：
◎
When a constructor of the Event interface, or of an interface that inherits from the Event interface, is invoked, these steps must be run, given the arguments type and eventInitDict: 
</p>
		<ol>
			<li>
%~event ~LET `~eventを内部的に作成する$( %~ifc, ~NULL, 現在時, %eventInitDict )
◎
Let event be the result of running the inner event creation steps with this interface, null, now, and eventInitDict.
</li>
			<li>
%~event の $Event.type 属性 ~SET %type に初期化する
◎
Initialize event’s type attribute to type.
</li>
			<li>
~RET %~event
◎
Return event.
</li>
		</ol>
	</dd>
</dl>


<p class="algo-head">
`~eventを作成する@
ときは、所与の
⇒＃
%~event~ifc （ $Event または それを継承する~ifc ）,
%~realm （ `~Realm$, 省略時は ~NULL ）
◎終
に対し，次を走らす：
◎
To create an event using eventInterface, which must be either Event or an interface that inherits from it, and optionally given a Realm realm, run these steps:
• If realm is not given, then set it to null.
</p>

<ol>
	<li>
<p>
%辞書 ~LET ~JS `undefined^c 値を［
%~event~ifc の構築子が引数に受容する`辞書$型（ $EventInit またはそれを継承する辞書~型）
］に`変換-$した結果
◎
Let dictionary be the result of converting the JavaScript value undefined to the dictionary type accepted by eventInterface’s constructor. (This dictionary type will either be EventInit or a dictionary that inherits from it.)
</p>

<p class="XXX">
これは、当の辞書~型に必須の~memberがある場合に働かない。
<a href="https://github.com/whatwg/dom/issues/600">whatwg/dom#600</a>
を見よ。
◎
This does not work if members are required; see whatwg/dom#600.
</p>
	</li>
	<li>
%今 ~LET ~eventを通達している時点の時刻
◎
↓</li>
	<li>
<p>
%~event ~LET `~eventを内部的に作成する$( %~event~ifc, %~realm, %今, %辞書~値 )
◎
Let event be the result of running the inner event creation steps with eventInterface, realm, the time of the occurrence that the event is signaling, and dictionary.
</p>

<p class="note">注記：
例えば macOS においては、入力~動作が生じた時刻は ^NSEvent ~objの ^timestamp ~propを介して可用になる。
◎
In macOS the time of the occurrence for input actions is available via the timestamp property of NSEvent objects.
</p>
	</li>
	<li>
%~event の $isTrusted 属性 ~SET ~T に初期化する
◎
Initialize event’s isTrusted attribute to true.
</li>
	<li>
~RET %~event 
◎
Return event.
</li>
</ol>

<p class="note">注記：
`~eventを作成する$手続きは、単純に`~eventを発火する$代わりに［
`~eventを作成する$, ~eventを`配送-$する
］手続きを別々に呼出す必要がある，他の仕様からの利用が~~意図されている。
これは、~eventの属性が既定の値に正しく初期化されることを確保する。
◎
Create an event is meant to be used by other specifications which need to separately create and dispatch events, instead of simply firing them. It ensures the event’s attributes are initialized to the correct defaults.
</p>

<p>
`~eventを内部的に作成する@
ときは、所与の
( %~ifc, %~realm, %時刻, %辞書 )
に対し，次を走らす：
◎
The inner event creation steps, given an interface, realm, time, and dictionary, are as follows:
</p>

<ol>
	<li>
<p>
%~event ~LET %~ifc を利用する, %~realm 内の，新たな~obj
— ただし， %~realm ~EQ ε の場合は Web IDL に定義される既定の挙動に従う
◎
Let event be the result of creating a new object using eventInterface. If realm is non-null, then use that Realm; otherwise, use the default behavior defined in Web IDL.
</p>

<p class="XXX">
これを書いている時点では、まだ Web IDL はこの既定の挙動を定義していない。
<a href="https://github.com/heycam/webidl/issues/135">heycam/webidl#135</a>
を見よ。
◎
As of the time of this writing Web IDL does not yet define any default behavior; see heycam/webidl#135.
</p>
	</li>
	<li>
%~event の`初期化-済み$f ~SET ~ON
◎
Set event’s initialized flag.
</li>
	<li>
<p>
%~event の $Event.timeStamp 属性 ~SET ［
`時刻起点$から %時刻 までの高分解能な時間差
］を表現している $DOMHighResTimeStamp 値に初期化する
◎
Initialize event’s timeStamp attribute to a DOMHighResTimeStamp representing the high resolution time from the time origin to time.
</p>

<p class="warning">
既存の<a href="~HRTIME#clock-resolution">時計~分解能の推奨</a>
に従って、~UAは， $Event.timeStamp 属性を 5 マイクロ秒までの分解能に設定するべきである。
`HR-TIME$r
【現在のその仕様では、この推奨は，具体的な数値に代えて別の形で述べられている。】
◎
User agents should set a minimum resolution of event’s timeStamp attribute to 5 microseconds following the existing clock resolution recommendation. [HR-TIME]
</p>
	</li>
	<li>
%辞書 内の~EACH ( %~member → %値 ) に対し
⇒
~IF［
%~event には %~member を`識別子$とする属性はある
］
⇒
その属性 ~SET %値 に初期化する
◎
For each member → value in dictionary, if event has an attribute whose identifier is member, then initialize that attribute to value.
</li>
	<li>
`~event構築-時の手続き$に
( %~event )
を渡して走らす
◎
Run the event constructing steps with event.
</li>
	<li>
~RET %~event
◎
Return event.
</li>
</ol>


		</section>
		<section id="defining-event-interfaces">
<h3 title="Defining event interfaces">2.5. ~event~ifcの定義-法</h3>

<p>
一般に、$Event を継承する新たな~ifcを定義する際には，常に
<a href="https://whatwg.org/">WHATWG</a>
または
<a href="https://www.w3.org/2008/webapps/">W3C WebApps WG</a>
~communityからの~feedbackを仰ぐように願う。
◎
In general, when defining a new interface that inherits from Event please always ask feedback from the WHATWG or the W3C WebApps WG community.
</p>

<p>
$CustomEvent ~ifcはその出発点に利用できるものだが、 `init*Event()^c の類いの~methは，構築子とかぶって冗長になるので導入しないように。
$Event ~ifcを継承する~ifcがその種の~methを備えているのは、歴史上の理由に限られている。
◎
The CustomEvent interface can be used as starting point. However, do not introduce any init*Event() methods as they are redundant with constructors. Interfaces that inherit from the Event interface that have such a method only have it for historical reasons.
</p>

		</section>
		<section id="interface-eventtarget">
<h3>2.6. ~ifc ^@EventTarget</h3>

！！
[$Constructor,
 `Exposed$=(Window,Worker,AudioWorklet)]
interface @EventTarget {
  void $addEventListener(~DS %type, $EventListener? %callback, optional ($AddEventListenerOptions or ~B) %options);
  void $removeEventListener(~DS %type, $EventListener? %callback, optional ($EventListenerOptions or ~B) %options);
  ~B $dispatchEvent($Event %event);
};

callback interface @EventListener {
  void @EventListener.handleEvent($Event %event);
};

dictionary @@EventListenerOptions {
  boolean @capture = false;
};

dictionary @@AddEventListenerOptions : $EventListenerOptions {
  boolean @passive = false;
  boolean @once = false;
};
！

<p>
$@EventTarget ~objは、何かが起きた時に`~event$を`配送-$できる~targetを表現する。
◎
An EventTarget object represents a target to which an event can be dispatched when something has occurred.
</p>

<p>（
各 $EventTarget ~objには、
`~event~listener~list@
が結付けられる
— それは、 0 個~以上の`~event~listener$からなる`~list$であり，初期~時には空とする。
◎
Each EventTarget object has an associated event listener list (a list of zero or more event listeners). It is initially the empty list. 
</p>

<p>
`~event~listener@
を利用すれば、特定の`~event$を観測できる
— それは、次のものからなる：
◎
An event listener can be used to observe a specific event and consists of:
</p>

<ul>
	<li>
`type@evL
— 文字列
◎
type (a string)
</li>
	<li>
`callback@evL
— ~NULL, または $EventListener ~obj
◎
callback (null or an EventListener object)
</li>
	<li>
`capture@evL
— 真偽値,
初期~時は ~F とする。
◎
capture (a boolean, initially false)
</li>
	<li>
`passive@evL
— 真偽値,
初期~時は ~F とする。
◎
passive (a boolean, initially false)
</li>
	<li>
`once@evL
— 真偽値,
初期~時は ~F とする。
◎
once (a boolean, initially false)
</li>
	<li>
`removed@evL
— 内部処理用の真偽値,
初期~時は ~F とする。
◎
removed (a boolean for bookkeeping purposes, initially false) 
</li>
</ul>


<p class="note">注記：
`callback$evL は $EventListener ~objであるが、`~event~listener$は 上に示したように より広い概念である。
◎
Although callback is an EventListener object, an event listener is a broader concept as can be seen above.
</p>

<p>
各 $EventTarget ~objには、その
`親~targetを取得する@
~algoも結付けられる。
それは、所与の`~event$に対し，［
$EventTarget ~obj, または ~NULL
］を返す。
他から指定されない限り， ~NULL を返すとする。
◎
Each EventTarget object also has an associated get the parent algorithm, which takes an event event, and returns an EventTarget object. Unless specified otherwise it returns null.
</p>

<p class="note">注記：
［
`~node$ ／ `~shadow根$ ／ `文書$
］は、`親~targetを取得する$~algoを上書きする。
◎
Nodes, shadow roots, and documents override the get the parent algorithm.
</p>

<p class="trans-note">【
この~algoは、~eventの`配送-$時にその伝播`経路$を構築するために利用される。
】【
指定される個々の~algoには、渡された~eventを利用しないものもある（その場合、~eventは省略して記述され得る）。
】</p>

<p>
各 $EventTarget ~objには、
`作動化の挙動@
が結付けられ得る。
この~algoは、`配送-$する~algo内から，
( `~event$ )
を渡して呼出される。
◎
Each EventTarget object can have an associated activation behavior algorithm. The activation behavior algorithm is passed an event, as indicated in the dispatch algorithm.
</p>

<p class="note">注記：
これが存在するのは、~UAが
ある種の $EventTarget ~objに対し，ある種の動作を遂行するためである
— 例えば `area$e 要素は、合成 $MouseEvent `~event$に呼応して，その $Event.type 属性は `click^l にされる。
それを除去することは、~Web互換性のため できない。
それはまた、今や，何らかの作動化を定義するときに~~尊守されている仕方になっている。
`HTML$r
◎
This exists because user agents perform certain actions for certain EventTarget objects, e.g., the area element, in response to synthetic MouseEvent events whose type attribute is click. Web compatibility prevented it from being removed and it is now the enshrined way of defining an activation of something. [HTML]
</p>

<p>
加えて、`作動化の挙動$を有する各 $EventTarget ~objには、［
`旧来の作動化~前の挙動@,
`旧来の作動化~取消~時の挙動@
］を備えるものもある（片方のみ備えることはない）。
◎
Each EventTarget object that has activation behavior, can additionally have both (not either) a legacy-pre-activation behavior algorithm and a legacy-canceled-activation behavior algorithm. 
</p>

<p class="note">注記
これらの~algoは，［
Checkbox ／ Radio
］状態にある `input$e 要素のみに存在し、他では利用されない。
`HTML$r
◎
These algorithms only exist for checkbox and radio input elements and are not to be used for anything else. [HTML]
</p>

<dl class="domintro">
	<dt>%target = new $EventTarget();</dt>
	<dd>
開発者が`~event$を`配送-$して~listenするために利用できる，新たな $EventTarget ~objを作成する。
◎
Creates a new EventTarget object, which can be used by developers to dispatch and listen for events. 
</dd>

	<dt>%target . $addEventListener(type, callback [, options])</dt>
	<dd>
%target の`~event~listener~list$に［
$Event.type 属性~値が %type である`~event$用の`~event~listener$
］を付加する。
%callback 引数が，`~event$が`配送-$されたときに呼出される `callback$evL として設定される。
◎
Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
</dd>
	<dd>
%options 引数は、~listener特有の~optionを設定する。
互換性のため、これは真偽値もとり得る
— その場合、この~methは，正確に［
%options の $EventListenerOptions.capture に その値が指定された
］かのように挙動する。
◎
The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture.
</dd>
	<dd>
%options の $EventListenerOptions.capture が［
~T ／ ［
~F または無い
］］ならば、
`callback$evL は，［
`~event$の $eventPhase 属性~値が［
$Event.BUBBLING_PHASE ／ $Event.CAPTURING_PHASE 
］の間は，呼出されない
］ようになる。
いずれにせよ、`~event$の $Event.eventPhase 属性~値が $Event.AT_TARGET のときは，
`callback$evL は呼出される。
◎
When set to true, options’s capture prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
</dd>
	<dd>
%options の $AddEventListenerOptions.passive が ~T に設定されている場合、
`callback$evL は $Event.preventDefault() を呼出しても`~event$を取消さないことを指示する。
これは、
<a href="#observing-event-listeners">~event~listenerの観測-法</a>
に述べる処理能の最適化を可能化するために利用される
◎
When set to true, options’s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in §2.7 Observing event listeners.
</dd>

	<dd>
%options の $AddEventListenerOptions.once が ~T に設定されている場合、~callbackが呼出されるのは一度限りであり，その後には`~event~listener$は除去されることを指示する。
◎
When set to true, options’s once indicates that the callback will only be invoked once after which the event listener will be removed.
</dd>
	<dd>
`~event~listener$は、重複しない
— すなわち， `type$evL, `callback$evL, `capture$evL のいずれかが異なる — 
場合に限り，
%target の`~event~listener~list$に付加される。
◎
The event listener is appended to target’s event listener list and is not appended if it has the same type, callback, and capture. 
</dd>

	<dt>%target . $removeEventListener(type, callback [, options])</dt>
	<dd>
引数と同じ［
`type$evL, `callback$evL, `capture$evL
］を持つ`~event~listener$を，
%target の`~event~listener~list$から除去する。
◎
Removes the event listener in target’s event listener list with the same type, callback, and options.
</dd>

	<dt>%target . $dispatchEvent(event)</dt>
	<dd>
合成~event %event を %target に向けて`配送-$する。
［
	<!-- ^@Event -->
%event の $cancelable 属性~値が ~F であるか, または
%event の $preventDefault() ~methが呼出されていないとき
］は~T，他の場合は~F を返す。
◎
Dispatches a synthetic event event to target and returns true if either event’s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
</dd>

</dl>

	<!-- ^@EventTarget -->


<p class="algo-head">
%options を
`平坦化-@
するときは、次を走らす：
◎
To flatten options, run these steps:
</p>

<ol>
	<li>
~IF［
%options は ~B 型である
］
⇒
~RET %options
◎
If options is a boolean, then return options.
</li>
	<li>
~RET %options の $EventListenerOptions.capture ~member値
◎
Return options’s capture.
</li>
</ol>


<p class="algo-head">
%options を
`もっと平坦化-@
するときは、次を走らす：
◎
To flatten more options, run these steps:
</p>

<ol>
	<li id="cp-let-capture-flatten">
%capture ~LET
%options を `平坦化-$した結果
◎
Let capture be the result of flattening options.
</li>
	<li>
( %once, %passive ) ~LET ( ~F, ~F )
◎
Let once and passive be false.
</li>
	<li>
~IF［
%options は`辞書$である
］
⇒
( %passive, %once ) ~SET
%options の
( $AddEventListenerOptions.passive, $AddEventListenerOptions.once )
~member値
◎
If options is a dictionary, then set passive to options’s passive and once to options’s once.
</li>
	<li>
~RET
( %capture, %passive, %once )
◎
Return capture, passive, and once.
</li>
</ol>

<dl class="idl-def">
	<dt>@EventTarget()</dt>
	<dd>
この構築子の被呼出時には、新たな $EventTarget を返さ~MUST。
◎
The EventTarget() constructor, when invoked, must return a new EventTarget.
</dd>
	<dd class="note">注記：
他所に言明される既定により、返される $EventTarget の`親~targetを取得する$~algoは，~NULL を返すことになり、［
`作動化の挙動$,
`旧来の作動化~前の挙動$,
`旧来の作動化~取消~時の挙動$
］は無い。
◎
Because of the defaults stated elsewhere, the returned EventTarget's get the parent algorithm will return null, and it will have no activation behavior, legacy-pre-activation behavior, or legacy-canceled-activation behavior.
</dd>
	<dd class="note">注記：
将来には、`親~targetを取得する$~custom~algoも許容され得る。
作者は、それが自身の~programに有用になるなら知らせてほしい。
今の所は、作者が作成したどの $EventTarget も，木~構造には関与しない。
◎
In the future we could allow custom get the parent algorithms. Let us know if this would be useful for your programs. For now, all author-created EventTargets do not participate in a tree structure.
</dd>
</dl>

<p class="algo-head">
`~event~listenerを追加する@
ときは、所与の
( $EventTarget ~obj %~target, `~event~listener$ %~listener )
に対し，次を走らす：
◎
To add an event listener given an EventTarget object eventTarget and an event listener listener, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~target に`関連する大域~obj$ %G は $ServiceWorkerGlobalScope ~objである
］~AND［
%G に結付けられている`~sw$の`~script資源$の，`評価されたことがある~flag$ ~EQ ~ON
］`SERVICE-WORKERS$r
⇒
~THROW `TypeError$E
◎
If eventTarget’s relevant global object is a ServiceWorkerGlobalScope object and its associated service worker’s script resource’s has ever been evaluated flag is set, then throw a TypeError. [SERVICE-WORKERS]
</p>

<p class="note">注記：
［
当の~sw用に許容される~event型の格納-法を最適化する
］ため, および［
~event~listenerに対する非決定的な変更を避ける
］ため、この【手続きを利用する】~methの呼出が許容されるのは，~sw~scriptが初めて評価される間に限られる。
◎
To optimize storing the event types allowed for the service worker and to avoid non-deterministic changes to the event listeners, invocation of the method is allowed only during the very first evaluation of the service worker script.
</p>
	</li>
	<li>
~IF［
%~listener の`callback$evL ~EQ ~NULL
］
⇒
~RET
◎
If listener’s callback is null, then return.
</li>
	<li>
~IF［
ある［
`~event~listener$ ~IN %~target の`~event~listener~list$
］が在って，［
( `type$evL, `callback$evL, `capture$evL )
~EQ
%~listener の ( `type$evL, `callback$evL, `capture$evL )
］を満たす
］
⇒
~RET
◎
If eventTarget’s event listener list does not contain an event listener whose type is listener’s type, callback is listener’s callback, and capture is listener’s capture, then＼
</li>
	<li>
%~target の`~event~listener~list$に %~listener を`付加する$
◎
append listener to eventTarget’s event listener list.
</li>
</ol>

<p class="note">注記：
［
`~event~listenerを追加する$
］の概念は、［
`~event~handler$ `HTML$r が同じ `code path^en <!-- ＊ -->を利用する
］ことを確保するためにある。
◎
The add an event listener concept exists to ensure event handlers use the same code path. [HTML] 
</p>


<dl class="idl-def">
	<dt>@addEventListener(type, callback, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The addEventListener(type, callback, options) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
( %capture, %passive, %once ) ~LET %options を`もっと平坦化-$した結果
◎
Let capture, passive, and once be the result of flattening more options.
</li>
			<li>
`~event~listenerを追加する$( 此れ, 次のようにされた`~event~listener$ )
⇒＃
`type$evL ~SET %type ,
`callback$evL ~SET %callback ,
`capture$evL ~SET %capture ,
`passive$evL ~SET %passive ,
`once$evL ~SET %once
◎
Add an event listener with the context object and an event listener whose type is type, callback is callback, capture is capture, passive is passive, and once is once.
</li>
		</ol>
	</dd>
</dl>


<p class="algo-head">
`~event~listenerを除去する@
ときは、所与の
( $EventTarget ~obj %~target, `~event~listener$ %~listener )
に対し，次を走らす
⇒＃
%~listener の `removed$evL ~SET ~T；
%~target の`~event~listener~list$から %~listener を`除去する$
◎
To remove an event listener, given an EventTarget object eventTarget and an event listener listener, set listener’s removed to true and remove listener from eventTarget’s event listener list.
</p>

<p>
`~event~listenerをすべて除去する@
ときは、所与の
( $EventTarget ~obj %~target )
に対し，次を走らす
⇒
%~target の`~event~listener~list$内の
~EACH( %~listener )
に対し
⇒
`~event~listenerを除去する$( %~target, %~listener )
◎
To remove all event listeners, given an EventTarget object eventTarget, for each listener of eventTarget’s event listener list, remove an event listener with eventTarget and listener.
</p>


<p class="note">注記：
~HTMLは、 ^document.open() を定義するために これを必要とする。
`HTML$r
◎
HTML needs this to define document.open(). [HTML]
</p>


<dl class="idl-def">

	<dt>@removeEventListener(type, callback, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeEventListener(type, callback, options) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れに`関連する大域~obj$ %G は $ServiceWorkerGlobalScope ~objである
］~AND［
%G に結付けられている`~sw$の`~script資源$の，`評価されたことがある~flag$ ~EQ ~ON
］`SERVICE-WORKERS$r
⇒
~THROW `TypeError$E
◎
If the context object’s relevant global object is a ServiceWorkerGlobalScope object and its associated service worker’s script resource’s has ever been evaluated flag is set, then throw a TypeError. [SERVICE-WORKERS]
</li>
			<!--cp-let-capture-flatten-->
			<li>
~IF［
ある［
`~event~listener$ %~listener ~IN 此れの`~event~listener~list$
］が在って，［
( `type$evL, `callback$evL, `capture$evL )
~EQ
( %type, %callback, %capture )
］を満たす
］
⇒
`~event~listenerを除去する$( 此れ, %~listener )
◎
If the context object’s event listener list contains an event listener whose type is type, callback is callback, and capture is capture, then remove an event listener with the context object and that event listener.
</li>
		</ol>
	</dd>

	<dt>@dispatchEvent(event)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The dispatchEvent(event) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%event の`配送-$f ~EQ ~ON
］~OR［
%event の`初期化-済み$f ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If event’s dispatch flag is set, or if its initialized flag is not set, then throw an "InvalidStateError" DOMException.
</li>
			<li>
			<!-- ^@Event -->
%event の $isTrusted 属性 ~SET ~F に初期化する
◎
Initialize event’s isTrusted attribute to false.
</li>
			<li>
~RET 此れに向けて %event を`配送-$した結果
◎
Return the result of dispatching event to the context object.
</li>
		</ol>
	</dd>
</dl>


		</section>
		<section id="observing-event-listeners">
<h3 title="Observing event listeners">2.7. ~event~listenerの観測-法</h3>

<p>
一般に、開発者は，`~event~listener$の有無が観測-可能になるものとは予期しない。
`~event~listener$の影響0は、その `callback$evL により決定される。
すなわち開発者は、何もしない`~event~listener$を追加しても，副作用が生じるとは予期しない。
◎
In general, developers do not expect the presence of an event listener to be observable. The impact of an event listener is determined by its callback. That is, a developer adding a no-op event listener would not expect it to have any side effects.
</p>

<p>
あいにく，一部の~event~APIは、効率的に実装するためには，`~event~listener$を観測することが要求される設計になっている。
すなわち、何もしない~listenerであっても，~appの挙動における処理能に劇的に影響0し得る結果、~listenerの有無が観測-可能になっている。
例えば ~touch／~wheel ~eventの利用は、非同期~scrollingを阻むことがある。
一部の事例では、［
~eventが $cancelable になるのは， $AddEventListenerOptions.passive でない~listenerが 1 個~以上あるときに限る
］ように指定することで，この問題を軽減できる。
例えば、 $AddEventListenerOptions.passive でない $TouchEvent ~listenerは，~scrollingを阻まなければならないが、どの~listenerも $AddEventListenerOptions.passive であれば，［
$TouchEvent を（ $preventDefault() の~callは無視されるように）取消せなくすることで，~scrollingを`並列的$に開始できる
］ようになる。
~eventを配送している~codeは、そのように $AddEventListenerOptions.passive でない~listenerの~~不在を観測でき，それを利用して配送-中の~eventの $cancelable ~propを ~F にできる。
◎
Unfortunately, some event APIs have been designed such that implementing them efficiently requires observing event listeners. This can make the presence of listeners observable in that even empty listeners can have a dramatic performance impact on the behavior of the application. For example, touch and wheel events which can be used to block asynchronous scrolling. In some cases this problem can be mitigated by specifying the event to be cancelable only when there is at least one non-passive listener. For example, non-passive TouchEvent listeners must block scrolling, but if all listeners are passive then scrolling can be allowed to start in parallel by making the TouchEvent uncancelable (so that calls to preventDefault() are ignored). So code dispatching an event is able to observe the absence of non-passive listeners, and use that to clear the cancelable property of the event being dispatched.
</p>

<p>
新たな~event~APIは、この~propを必要としないように定義されるのが理想的である（論を交わしたければ
<a href="https://lists.w3.org/Archives/Public/public-script-coord/">public-script-coord@<!---->w3.org</a>
を利用されたし）。
◎
Ideally, any new event APIs are defined such that they do not need this property (use public-script-coord@w3.org for discussion).
</p>


		</section>
		<section id="dispatching-events">
<h3 title="Dispatching events">2.8. ~eventの配送-法</h3>

<!-- ^@Event -->
<div class="p">
<p class="algo-head">
%target に向けて，`~event$ %~event を
`配送-@
するときは、次を走らす
— この手続きには，次も与えられ得る：
</p>

<ul ><li>%旧来の~targetを上書きする~flag ~IN { `~targetを上書きする^i, ε }（省略時は ε ）
</li><li>`旧来の（~listenerは投出したか？）~flag@V
— この~flagは参照渡しであり、加えられた改変は~call元に伝播する（与えられている場合に限り）。
また、（この手続きが間接的に呼出す）`~listenerを内部的に呼出す$ 手続きまで暗黙的に渡されるとする。
【これは、 Indexed Database API のみから利用される。原文は，この~flagの受け渡しをいちいち記述していて煩雑なので、この訳ではこの一文に集約する。】
</li></ul>
◎
To dispatch an event to a target, with an optional legacy target override flag and an optional legacyOutputDidListenersThrowFlag, run these steps: 
</div>

<ol>
	<li>
%~event の`配送-$f ~SET ~ON
◎
Set event’s dispatch flag.
</li>
	<li>
<p>
%上書きする~target ~LET ［
%旧来の~targetを上書きする~flag ~EQ ε ならば %target ／
~ELSE_ %target に`結付けられている文書$ `HTML$r
］
◎
Let targetOverride be target, if legacy target override flag is not given, and target’s associated Document otherwise. [HTML]
</p>

<p class="note">注記：
%旧来の~targetを上書きする~flag は、~HTMLからのみ, それも %target が $Window ~objである場合に限り，非 ε にされる。
◎
legacy target override flag is only used by HTML and only when target is a Window object.
</p>
	</li>
	<li>
%作動化~target ~LET ~NULL
◎
Let activationTarget be null.
</li>
	<li>
%関係d~target ~LET %~event の`関係d~target$を %target に向けて`~targetし直す$
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against target.
</li>
	<li>
<p>
~IF［
%target ~NEQ %関係d~target 
］~OR［
%target ~EQ %~event の`関係d~target$
］：
◎
If target is not relatedTarget or target is event’s relatedTarget, then:
</p>
		<ol>
			<li>
%~touch~target~list ~LET 新たな`~list$
◎
Let touchTargets be a new list.
</li>
			<li>
%~event の`~touch~target~list$内の~EACH( %~touch~target ) に対し
⇒
%~touch~target~list に次の結果を`付加する$
⇒
%~touch~target を %~target に向けて`~targetし直す$
◎
For each touchTarget of event’s touch target list, append the result of retargeting touchTarget against target to touchTargets.
</li>
			<li>
`~event経路に付加する$( %~event, %target, %上書きする~target, %関係d~target, %~touch~target~list, ~F )
◎
Append to an event path with event, target, targetOverride, relatedTarget, touchTargets, and false.
</li>
			<li>
%作動化~eventか？ ~LET［
%~event は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
$MouseEvent ~objである
］~AND［
$type 属性 ~EQ `click^l
］
◎
Let isActivationEvent be true, if event is a MouseEvent object and event’s type attribute is "click", and false otherwise.
</li>
			<li>
~IF［
%作動化~eventか？ ~EQ ~T
］~AND［
%target は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %target
◎
If isActivationEvent is true and target has activation behavior, then set activationTarget to target.
</li>
			<li>
%~slotable ~LET［
次が満たされるならば %~target ／
~ELSE_ ~NULL
］
⇒
［
%~target は`~slotable$である
］~AND［
%~target の`割当先~slot$ ~NEQ ~NULL
］
◎
Let slotable be target, if target is a slotable and is assigned, and null otherwise.
</li>
			<li>
%~slotは~closed木~内？ ~LET ~F
◎
Let slot-in-closed-tree be false.
</li>
			<li>
%親 ~LET
%target の`親~targetを取得する$( %~event )
◎
Let parent be the result of invoking target’s get the parent with event.
</li>
			<li>
<p>
~WHILE［
%親 ~NEQ ~NULL
］：
◎
While parent is non-null:
</p>
				<ol>
					<li>
<p>
~IF［
%~slotable ~NEQ ~NULL
］：
◎
If slotable is non-null:
</p>
						<ol>
							<li>
~Assert：
%親 は`~slot$である
◎
Assert: parent is a slot.
</li>
							<li>
%~slotable ~SET ~NULL
◎
Set slotable to null.
</li>
							<li>
~IF［
%親 の`根$は［
`~shadow根$である
］~AND［
`~mode$sR ~EQ `closed^l
］を満たす
］
⇒
%~slotは~closed木~内？ ~SET ~T
◎
If parent’s root is a shadow root whose mode is "closed", then set slot-in-closed-tree to true.
</li>
						</ol>
					</li>
					<li>
~IF［
%親 は`~slotable$である
］~AND［
%親 の`割当先~slot$ ~NEQ ~NULL
］
⇒
%~slotable ~SET %親
◎
If parent is a slotable and is assigned, then set slotable to parent.
</li>
					<li>
%関係d~target ~LET %関係d~target を %親 に向けて`~targetし直す$
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against parent.
</li>
					<li>
%~touch~target~list ~LET 新たな`~list$
◎
Let touchTargets be a new list.
</li>
					<li>
%~event の`~touch~target~list$内の~EACH( %~touch~target ) に対し
⇒
%~touch~target~list に次の結果を`付加する$
⇒
%~touch~target を %親 に向けて`~targetし直す$
◎
For each touchTarget of event’s touch target list, append the result of retargeting touchTarget against parent to touchTargets.
</li>
					<li>
<p>
~IF［
%親 は`~node$である
］~AND［
%target の`根$ は %親 の`~shadowも含む広義先祖$である
］：
◎
If parent is a node and target’s root is a shadow-including inclusive ancestor of parent, then:
</p>
						<ol>
							<li>
<p>
~IF［
%作動化~eventか？ ~EQ ~T
］~AND［
%~event  の $bubbles 属性 ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%親 は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %親 
◎
If isActivationEvent is true, event’s bubbles attribute is true, activationTarget is null, and parent has activation behavior, then set activationTarget to parent.
</li>
							<li>
`~event経路に付加する$( %~event, %親, ~NULL, %関係d~target, %~touch~target~list, %~slotは~closed木~内？ )
◎
Append to an event path with event, parent, null, relatedTarget, touchTargets, and slot-in-closed-tree.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%親 ~EQ %関係d~target
］
⇒
%親 ~SET ~NULL
◎
Otherwise, if parent is relatedTarget, then set parent to null.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
						<ol>
							<li>
%target ~SET %親
◎
set target to parent and then:
</li>
							<li>
~IF［
%作動化~eventか？ ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%target は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %target 
◎
If isActivationEvent is true, activationTarget is null, and target has activation behavior, then set activationTarget to target.
</li>
							<li>
`~event経路に付加する$( %~event, %親, %target, %関係d~target, %~touch~target~list, %~slotは~closed木~内？ )
◎
Append to an event path with event, parent, target, relatedTarget, touchTargets, and slot-in-closed-tree.
</li>
						</ol>
					</li>
					<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
%親 ~SET %親 の`親~targetを取得する$( %~event )
◎
If parent is non-null, then set parent to the result of invoking parent’s get the parent with event.
</li>
					<li>
%~slotは~closed木~内？ ~SET ~F
◎
Set slot-in-closed-tree to false.
</li>
				</ol>
			</li>
			<li>
%~targetを消去する~tuple ~LET %~event の`経路$内の~tupleのうち，［
`~target$evP ~NEQ ~NULL
］を満たすもののうち，最後のもの
◎
Let clearTargetsTuple be the last tuple in event’s path whose target is non-null.
</li>
			<li>
%~targetたちを消去する ~LET 次を満たす`~node$ %~node は［
在るならば ~T ／
無いならば ~F
］
⇒
［
%~node の`根$は`~shadow根$である
］~AND［
%~node は次に挙げるいずれかである
］
⇒＃
%~targetを消去する~tuple の`~target$evP,
%~targetを消去する~tuple の`関係d~target$evP,
%~targetを消去する~tuple の`~touch~target~list$evP 内にあるもの
◎
Let clearTargets be true if clearTargetsTuple’s target, clearTargetsTuple’s relatedTarget, or an EventTarget object in clearTargetsTuple’s touch target list is a node and its root is a shadow root, and false otherwise.
</li>
			<li>
%~event の $eventPhase 属性 ~SET $CAPTURING_PHASE
◎
Set event’s eventPhase attribute to CAPTURING_PHASE.
</li>
			<li>
~IF［
%作動化~target ~NEQ ~NULL
］~AND［
%作動化~target は `旧来の作動化~前の挙動$を備えている
］
⇒
その挙動を走らす
◎
If activationTarget is non-null and activationTarget has legacy-pre-activation behavior, then run activationTarget’s legacy-pre-activation behavior.
</li>
			<li>
%~event の`経路$内の~EACH ( %~tuple ) に対し，逆順に
⇒
~IF［
%~tuple の `~target$evP ~EQ ~NULL
］
⇒
`~listenerを呼出す$( %~tuple, %~event )
◎
For each tuple in event’s path, in reverse order:
• If tuple’s target is null, then invoke with tuple, event, and legacyOutputDidListenersThrowFlag if given.
</li>
			<li>
<p>
%~event の`経路$内の~EACH ( %~tuple ) に対し，順に：
◎
For each tuple in event’s path, in order:
</p>
				<ol>
					<li>
%~listenerを呼出す ~LET ~T
◎
↓</li>
					<li>
~IF［
%~tuple の `~target$evP ~NEQ ~NULL
］
⇒
%~event の $eventPhase 属性 ~SET $AT_TARGET
◎
If tuple’s target is non-null, then set event’s eventPhase attribute to AT_TARGET.
</li>
					<li>
~ELSE
⇒＃
%~event の $eventPhase 属性 ~SET $BUBBLING_PHASE；
%~listenerを呼出す ~SET %~event の $bubbles 属性
◎
Otherwise, set event’s eventPhase attribute to BUBBLING_PHASE.
◎
↓</li>
					<li>
~IF［
%~listenerを呼出す ~EQ ~T
］
⇒
`~listenerを呼出す$( %~tuple, %~event )
◎
If either event’s eventPhase attribute is BUBBLING_PHASE and event’s bubbles attribute is true or event’s eventPhase attribute is AT_TARGET, then invoke with tuple, event, and legacyOutputDidListenersThrowFlag if given.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~event の $eventPhase 属性 ~SET $NONE
◎
Set event’s eventPhase attribute to NONE.
</li>
	<li>
%~event の $currentTarget 属性 ~SET ~NULL
◎
Set event’s currentTarget attribute to null.
</li>
	<li>
%~event の`経路$ ~SET 空~list
◎
Set event’s path to the empty list.
</li>
	<li>
%~event の
⇒＃
`配送-$f ~SET ~OFF,
`伝播停止$f ~SET ~OFF,
`伝播即停止$f ~SET ~OFF
◎
Unset event’s dispatch flag, stop propagation flag, and stop immediate propagation flag.
</li>
	<li>
<p>
~IF［
%~targetたちを消去する ~EQ ~T
］
⇒
%~event の
⇒＃
`~target$ ~SET ~NULL
`関係d~target$ ~SET ~NULL
`~touch~target~list$ ~SET 空~list
◎
If clearTargets, then:
• Set event’s target to null.
• Set event’s relatedTarget to null.
• Set event’s touch target list to the empty list.
</li>
	<li>
<p>
~IF［
%作動化~target ~NEQ ~NULL
］：
◎
If activationTarget is non-null, then:
</p>
		<ol>
			<li>
~IF［
%~event の`取消d$f ~EQ ~OFF
］
⇒
%~event を渡して， %作動化~target の`作動化の挙動$を走らす
◎
If event’s canceled flag is unset, then run activationTarget’s activation behavior with event.
</li>
			<li>
~ELIF［
%作動化~target は `旧来の作動化~取消~時の挙動$を備えている
］
⇒
その挙動を走らす
◎
Otherwise, if activationTarget has legacy-canceled-activation behavior, then run activationTarget’s legacy-canceled-activation behavior.
</li>
		</ol>
	</li>
	<li>
~RET %~event の`取消d$f に応じて
⇒＃
~ON ならば ~T ／
~OFF ならば ~F
◎
Return false if event’s canceled flag is set, and true otherwise.
</li>
</ol>

<p class="algo-head">
`~event経路に付加する@
ときは、所与の
( %~event, %~target, %上書きする~target, %関係d~target, %~touch~target~list, %~slotは~closed木~内？ )
に対し，次を走らす：
◎
To append to an event path, given an event, target, targetOverride, relatedTarget, touchTargets, and a slot-in-closed-tree, run these steps:
</p>

<ol>
	<li>
%~closed木の根？ ~LET ［
%~target は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
`~shadow根$である
］~AND［
`~mode$sR ~EQ `closed^l
］
◎
Let root-of-closed-tree be false.
◎
If target is a shadow root whose mode is "closed", then set root-of-closed-tree to true.
</li>
	<li>
%~event の`経路$に次のようにされた新たな`構造体$を`付加する$
⇒＃
`~item$evP ~SET %~target,
`~target$evP ~SET %上書きする~target,
`関係d~target$evP ~SET %関係d~target,
`~closed木の根？$evP ~SET %~closed木の根？,
`~touch~target~list$evP ~SET %~touch~target~list
`~slotは~closed木~内？$evP ~SET %~slotは~closed木~内？
◎
Append a new struct to event’s path whose item is target, target is targetOverride, relatedTarget is relatedTarget, touch target list is touchTargets, root-of-closed-tree is root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.
</li>
</ol>

<p class="algo-head">
`~listenerを呼出す@
ときは、所与の
( %~tuple, `~event$ %~event )
に対し，次を走らす：
◎
To invoke, given a tuple, event, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>

<ol>
	<li>
%~event の`~target$ ~SET ［
%~event の`経路$内の［
%~tuple または %~tuple に先行する~tuple
］のうち，［
`~target$evP ~NEQ ~NULL
］を満たすもののうち，最後の~tuple
］の`~target$evP
◎
Set event’s target to the target of the last tuple in event’s path, that is either tuple or preceding tuple, whose target is non-null.
</li>
	<li>
%~event の`関係d~target$ ~SET %~tuple の `関係d~target$evP
◎
Set event’s relatedTarget to tuple’s relatedTarget.
</li>
	<li>
%~event の`~touch~target~list$ ~SET %~tuple の`~touch~target~list$evP
◎
Set event’s touch target list to tuple’s touch target list.
</li>
	<li>
~IF［
%~event の`伝播停止$f ~EQ ~ON
］
⇒
~RET
◎
If event’s stop propagation flag is set, then return.
</li>
	<li>
%~obj ~LET %~tuple の`~item$evP
◎
Let object be tuple’s item.
</li>
	<li>
<p>
%~listener~list ~LET 
%~obj の`~event~listener~list$を`~cloneする$
◎
Let listeners be a clone of object’s event listener list.
</p>

<p class="note">注記：
これは、この時点以降に追加された~event~listenerは，走らせないようにする。
除去については、 `removed$evL ~fieldに因り，依然として効果を及ぼすことに注意。
◎
This avoids event listeners added after this point from being run. Note that removal still has an effect due to the removed field.
</p>
	</li>
	<li>
%~event の $currentTarget 属性 ~SET %~obj に初期化する
◎
Initialize event’s currentTarget attribute to object.
</li>
	<li>
%見出された？ ~LET `~listenerを内部的に呼出す$( %~event, %~listener~list )
◎
Let found be the result of running inner invoke with event, listeners, and legacyOutputDidListenersThrowFlag if given.
</li>
	<li>
<p>
~IF［
%見出された？ ~EQ ~F
］~AND［
%~event の $isTrusted 属性 ~EQ ~T
］~AND［
%~event の $type 属性~値は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］…：
◎
If found is false and event’s isTrusted attribute is true, then:
◎
Let originalEventType be event’s type attribute value.
◎
If event’s type attribute value is a match for any of the strings in the first column in the following table, set event’s type attribute value to the string in the second column on the same row as the matching string, and return otherwise.
</p>

<table>
<thead><tr><th>~event型◎ Event type
<th>旧来の~event型◎ Legacy event type
</thead>

<tbody><tr><td>`animationend^l
<td>`webkitAnimationEnd^l 

<tr><td>`animationiteration^l
<td>`webkitAnimationIteration^l 

<tr><td>`animationstart^l
<td>`webkitAnimationStart^l 

<tr><td>`transitionend^l
<td>`webkitTransitionEnd^l 
</tbody></table>

<p>
…ならば：
</p>
		<ol>
			<li>
%元~event型 ~LET %~event の $type 属性~値
◎
↑</li>
			<li>
%~event の $type 属性~値 ~SET 同じ行の 2 列目の文字列
◎
↑</li>
			<li>
`~listenerを内部的に呼出す$( %~event, %~listener~list )
◎
Inner invoke with event, listeners, and legacyOutputDidListenersThrowFlag if given.
</li>
			<li>
%~event の $type 属性~値 ~SET %元~event型
◎
Set event’s type attribute value to originalEventType.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
`~listenerを内部的に呼出す@
ときは、所与の
( %~event, %~listener~list )
に対し，次を走らす：
◎
To inner invoke, given an event, listeners, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>

<ol>
	<li>
%見出された？ ~LET ~F
◎
Let found be false.
</li>
	<li>
<p>
%~listener~list 内の~EACH ( `~event~listener$ %~listener ) に対し：
◎
For each listener in listeners, whose removed is false:
</p>
		<ol>
			<li>
~IF［
%~listener の `removed$evL ~EQ ~T
］
⇒
~CONTINUE
◎
↑</li>
			<li>
~IF［
%~listener の `type$evL ~NEQ %~event の $type 属性~値
］
⇒
~CONTINUE
◎
If event’s type attribute value is not listener’s type, then continue.
</li>
			<li>
%見出された？ ~SET ~T
◎
Set found to true.
</li>
			<li>
~IF［
%~listener の `capture$evL ~EQ ~F
］~AND［
%~event の $eventPhase 属性~値 ~EQ $CAPTURING_PHASE
］
⇒
~CONTINUE
◎
If event’s eventPhase attribute value is CAPTURING_PHASE and listener’s capture is false, then continue.
</li>
			<li>
~IF［
%~listener の `capture$evL ~EQ ~T
］~AND［
%~event の $eventPhase 属性~値 ~EQ $BUBBLING_PHASE
］
⇒
~CONTINUE
◎
If event’s eventPhase attribute value is BUBBLING_PHASE and listener’s capture is true, then continue.
</li>
			<li>
~IF［
%~listener の `once$evL ~EQ ~T
］
⇒
%~event の $currentTarget 属性~値の`~event~listener~list$から %~listener を`除去する$
◎
If listener’s once is true, then remove listener from event’s currentTarget attribute value’s event listener list.
</li>
			<li>
~IF［
%~listener の `passive$evL ~EQ ~T
］
⇒
%~event の`受動~listener内$f ~SET ~ON
◎
If listener’s passive is true, then set event’s in passive listener flag.
</li>
			<li>
<p>
次を与える下で，`利用元~objの演算を~callする$
⇒＃
%~listener の `callback$evL,
`handleEvent^l,
« %~event »,
%~event の$currentTarget 属性~値
◎
Call a user object’s operation with listener’s callback, "handleEvent", « event », and event’s currentTarget attribute value.＼
</p>

<p>
~callした結果，例外が投出されたときは、~catchして：
◎
If this throws an exception, then:
</p>
				<ol>
					<li>
`その例外を報告する$
◎
Report the exception.
</li>
					<li>
~IF［
この手続きを呼出した`配送-$手続きにて
`旧来の（~listenerは投出したか？）~flag$V
は与えられている
］
⇒
`旧来の（~listenerは投出したか？）~flag$V ~SET ~ON
◎
Set legacyOutputDidListenersThrowFlag if given. 
</li>
				</ol>
<p class="note">注記：
この~flagは、 Indexed Database API `INDEXEDDB$r のみに利用される。
◎
The legacyOutputDidListenersThrowFlag is only used by Indexed Database API. [INDEXEDDB]
</p>
			</li>
			<li>
%~event の`受動~listener内$f ~SET ~OFF
◎
Unset event’s in passive listener flag.
</li>
			<li>
~IF［
%~event の`伝播即停止$f ~EQ ~ON
］
⇒
~RET %見出された？
◎
If event’s stop immediate propagation flag is set, then return found.
</li>
		</ol>
	</li>
	<li>
~RET %見出された？
◎
Return found.
</li>
</ol>


		</section>
		<section id="firing-events">
<h3 title="Firing events">2.9. ~eventの発火-法</h3>

<div class="p">
<p class="algo-head">
%~target に向けて，名前 %e の
`~eventを発火する@
ときは、以下の手続きを走らす
— この手続きには、次の~~入力も与えられ得る：
</p>

<ul ><li>%旧来の~targetを上書きする~flag ~IN { `~targetを上書きする^i, ε }（省略時は ε ）
</li><li>%~event構築子 （省略時は $@Event のそれ）
</li><li>%記述
— ~eventの各種~IDL属性を どう初期化するか，についての記述 （省略時は何もしない）
</li></ul>

◎
To fire an event named e at target, optionally using an eventConstructor, with a description of how IDL attributes are to be initialized, and a legacy target override flag, run these steps:
◎
If eventConstructor is not given, then let eventConstructor be Event.
</div>

<ol>
	<li>
%~event ~LET
`~eventを作成する$( %~event構築子, %~target に`関連する~Realm$ )
◎
Let event be the result of creating an event given eventConstructor, in the relevant Realm of target.
</li>
	<li>
%~event の $type 属性 ~SET %e に初期化する
◎
Initialize event’s type attribute to e.
</li>
	<li>
<p>
%~event の各種~IDL属性を %記述 に従って初期化する
◎
Initialize any other IDL attributes of event as described in the invocation of this algorithm.
</p>

<p class="note">注記：
ここでは［
$isTrusted 属性 ~SET ~F
］にすることも許容される。
◎
This also allows for the isTrusted attribute to be set to false.
</p>

<p class="trans-note">【
この手続きを利用している他の仕様には、~IDL属性の他にも，~eventの各種~flag（ `~composed$f など）を初期化する記述を含んでいるものもある。
】</p>

	</li>
	<li>
~RET %~event を%~target に向けて`配送-$する( %旧来の~targetを上書きする~flag )
◎
Return the result of dispatching event at target, with legacy target override flag set if set.
</li>
</ol>

<p class="note">注記：
~DOMの文脈における “`~eventを発火する$” とは、`~event$を［
<a href="#concept-event-create">作成-</a>して, 初期化して, `配送-$する
］ことの略語であり，この処理過程を記述し易くするものである。
◎
Fire in the context of DOM is short for creating, initializing, and dispatching an event. Fire an event makes that process easier to write down.
</p>

<div class="example" id="firing-events-example">

<p>
`~event$の［
$bubbles や $cancelable
］属性も初期化する記述も必要な場合は、次のように記述することもできる
⇒
%~target に向けて，名前 `submit^et の`~eventを発火する$
— 次のように初期化して
⇒
^cancelable 属性 ~SET ~T
◎
If the event needs its bubbles or cancelable attribute initialized, one could write "fire an event named submit at target with its cancelable attribute initialized to true".
</p>

<p>
あるいは，~custom構築子も必要なときは、次のように記述する等々
⇒
%~target に向けて，名前 `click^et の`~eventを発火する$
— $MouseEvent を利用し，次のように初期化して
⇒
`detail$m 属性 ~SET 1
◎
Or, when a custom constructor is needed, "fire an event named click at target using MouseEvent with its detail attribute initialized to 1".
</p>

<p>
ときには、返値が重要になることもある：
◎
Occasionally the return value is important:
</p>

<ol>
	<li>
%何かする ~LET %~target に向けて，名前 `like^et の`~eventを発火する$
◎
Let doAction be the result of firing an event named like at target.
	</li>
	<li>
~IF［
%何かする ~EQ ~T
］
⇒
…
◎
If doAction is true, then …
	</li>
</ol>
</div>


		</section>
		<section id="action-versus-occurance">
<h3 title="Action versus occurrence">2.10. 動作 vs. 発生</h3>

<p>
`~event$は、動作（ `action^en ）ではなく，発生（ `occurrence^en ）をしるす（ `signify^en する）ものである。
言葉を代えれば、~algoからの通知を表現し，その~algoの進路に（例えば $preventDefault() を呼出すことを通して）波及させるために利用できるものである。
`~event$は、何らかの~algoを走らすような［
動作, あるいは動作を起動するもの
］として利用されては~MUST_NOT。
そのような用途のためのものではない。
◎
An event signifies an occurrence, not an action. Phrased differently, it represents a notification from an algorithm and can be used to influence the future course of that algorithm (e.g., through invoking preventDefault()). Events must not be used as actions or initiators that cause some algorithm to start running. That is not what they are for.
</p>

<p class="note">注記：
ここで特に~~強調している~~理由は、以前の~DOMでは，`~event$に “既定~動作” の概念が結付けられていて，人を誤った考えに~~導いていたからである。
`~event$は、動作を表現したり, 生じさせるものではなく，進行中の何かに波及させるために限り利用できるものである。
【<a href="~SPECBUGS?id=12230">参考</a>】
◎
This is called out here specifically because previous iterations of the DOM had a concept of "default actions" associated with events that gave folks all the wrong ideas. Events do not represent or cause actions, they can only be used to influence an ongoing one.
</p>

		</section>
	</section>
	<section id="aborting-ongoing-activities">
<h2 title="Aborting ongoing activities">3. 進行中の活動の中止-法</h2>

<!-- ^@AbortController -->
<p>
~promiseには，中止するための組込みの仕組みがないが、それを利用している多くの~APIは，中止-の意味論を要求している。
$AbortController には、その要件を~supportすることが~~意図されている。
それが供する $abort() ~methは、 $AbortController に対応している $AbortSignal ~objの状態を切り替える。
中止-法を~supportしたいと望む~APIは、この~objを受容して, その状態を利用することにより，どう続行するか決定できる。
◎
Though promises do not have a built-in aborting mechanism, many APIs using them require abort semantics. AbortController is meant to support these requirements by providing an abort() method that toggles the state of a corresponding AbortSignal object. The API which wishes to support aborting can accept an AbortSignal object, and use its state to determine how to proceed.
</p>

<p>
$AbortController に依拠する~APIは、新たな `AbortError$E 例外で未決着の~promiseを却下して， $abort() に応答することが奨励される。
◎
APIs that rely upon AbortController are encouraged to respond to abort() by rejecting any unsettled promise with a new "AbortError" DOMException. 
</p>

<div class="example" id="aborting-ongoing-activities-example">

<p>
~meth 
`doAmazingness({ ... })^c
は、何か “すごいこと” を行うとする。
この~methは、 $AbortSignal ~objを受容して，次のように中止-法を~supportできる：
◎
A hypothetical doAmazingness({ ... }) method could accept an AbortSignal object in order to support aborting as follows:
</p>

<pre class="js-code">
const %controller = new AbortController();
const %signal = %controller.signal;

startSpinner();

doAmazingness({ ..., %signal })
  .then(%result =&gt; ...)
  .catch(%err =&gt; {
    if (%err.name == 'AbortError') return;
    showUserErrorMessage();
  })
  .then(() =&gt; stopSpinner());

// …

%controller.abort();
</pre>

<p>
^doAmazingness は、次のように実装することもできる：
◎
doAmazingness could be implemented as follows:
</p>

<pre class="js-code">
function doAmazingness({%signal}) {
  if (%signal.aborted) {
    return Promise.reject(new DOMException('Aborted', 'AbortError'));
  }

  return new Promise((%resolve, %reject) =&gt; {
  	/* <span class="comment">
“すごいこと” を行い始め、終わったら %resolve(%result) を~callする。
また、 %signal も注視する。
◎
Begin doing amazingness, and call resolve(result) when done.
But also, watch for signals:
</span> */
    %signal.addEventListener('abort', () =&gt; {
      /* <span class="comment">
“すごいこと” を行うのを停止してから：
◎
Stop doing amazingness, and:
</span> */
      %reject(new DOMException('Aborted', 'AbortError'));
    });
  });
}
</pre>

<p>
より精細な制御を要する~APIは、必要に応じて
$AbortController, $AbortSignal
両~objを拡張することもできる。
◎
APIs that require more granular control could extend both AbortController and AbortSignal objects according to their needs.
</p>

</div>


		<section id="interface-abortcontroller">
<h3 title="Interface AbortController">3.1. ~ifc ^@AbortController</h3>

！！
$Constructor,
 `Exposed$=(Window,Worker)]
interface @AbortController {
  [`SameObject$] readonly attribute $AbortSignal $signal;

  void $abort();
};
！

<dl class="domintro">
	<dt>%controller  = new $AbortController()</dt>
	<dd>
新たな %controller を，その $signal を［
新たな $AbortSignal ~obj
］に設定した上で返す。
◎
Returns a new controller whose signal is set to a newly created AbortSignal object.
</dd>

	<dt>%controller . $signal</dt>
	<dd>
この~objに結付けられている $AbortSignal ~objを返す。
◎
Returns the AbortSignal object associated with this object.
</dd>
	<dt>%controller . $abort()</dt>
	<dd>
この~methを呼出すと、この~objの $AbortSignal の`中止-済み~flag$aBを設定した上で、結付けられている活動が中止されることになるよう，~obたちにも通達することになる。
◎
Invoking this method will set this object’s AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.
</dd>
</dl>

<p>
各 $AbortController ~objには、
`通達@aB
（ $AbortSignal ~obj）が結付けられる。
◎
An AbortController object has an associated signal (an AbortSignal object).
</p>

<dl class="idl-def">
	<dt>@AbortController()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた，新たな $AbortController ~objを返さ~MUST
⇒
`通達$aB ~SET 新たな $AbortSignal ~obj
◎
The AbortController() constructor, when invoked, must run these steps:
• Let signal be a new AbortSignal object.
• Let controller be a new AbortController object whose signal is signal.
• Return controller.
</dd>

	<dt>@signal</dt>
	<dd>
取得子は、此れの`通達$aBを返さ~MUST。
◎
The signal attribute’s getter, when invoked, must return the context object’s signal.
</dd>

	<dt>@abort()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
`中止-を通達する$( 此れの`通達$aB )
◎
The abort() method, when invoked, must signal abort on the context object’s signal.
</dd>
</dl>


		</section>
		<section id="interface-AbortSignal">
<h3 title="Interface AbortSignal">3.2. ~ifc ^@AbortSignal</h3>

！！
[`Exposed$=(Window,Worker)]
interface @AbortSignal : $EventTarget {
  readonly attribute ~B $aborted;

  attribute $EventHandler @onabort;
};
！

<dl class="domintro">
	<dt>%signal . $aborted</dt>
	<dd>
この $AbortSignal の $AbortController が，中止するよう通達されて［
いれば ~T ／
いなければ ~F
］を返す。
◎
Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise.
</dd>
</dl>

<p>
各 $AbortSignal ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`中止-済み~flag@aB</dt>
	<dd>
他が指定されない限り， ~OFF とする。
◎
An AbortSignal object has an associated aborted flag. It is unset unless specified otherwise.
</dd>

	<dt>`中止する~algoたち@aB</dt>
	<dd>
何個かの~algoからなる`有順序~集合$。
他が指定されない限り，空とする。
これらの~algoは、［
`中止-済み~flag$aB ~SET ~ON
］にされたとき，実行されることになる。
◎
An AbortSignal object has associated abort algorithms, which is a set of algorithms which are to be executed when its aborted flag is set. Unless specified otherwise, its value is the empty set.
</dd>
	<dd class="trans-note">【
集合なので，同じ~algoは重ねて現れ得ないことになるが、 “同じ” がどう定義されるかは， “`通達に~algoを追加する$” を利用する他の仕様を見ないとはっきりしない。
】</dd>
</dl>

<p class="algo-head">
`通達に~algoを追加する@
ときは、所与の
( $AbortSignal ~obj %通達, ~algo %~algo )
に対し，次を走らす：
◎
To add an algorithm algorithm to an AbortSignal object signal, run these steps:
</p>

<ol>
	<li>
~IF［
%通達 の`中止-済み~flag$aB ~EQ ~ON
］
⇒
~RET
◎
If signal’s aborted flag is set, then return.
</li>
	<li>
%通達 の`中止する~algoたち$aBに %~algo を`付加する$set
◎
Append algorithm to signal’s abort algorithms.
</li>
</ol>

<p class="algo-head">
`通達から~algoを除去する@
ときは、所与の
( $AbortSignal ~obj %通達, ~algo %A )
に対し
⇒
%通達 の`中止する~algoたち$aBから %A を`除去する$
◎
To remove an algorithm algorithm from an AbortSignal signal, remove algorithm from signal’s abort algorithms.
</p>

<p class="note">注記：
`中止する~algoたち$aBは、
$abort() に対し適度な仕方で反応するような，複雑な要件を伴う~APIを可能化する。
例えば，所与の~APIの`中止-済み~flag$aBは、~swなどの別~thread環境へ伝播される必要があるかもしれない。
◎
The abort algorithms enable APIs with complex requirements to react in a reasonable way to abort(). For example, a given API’s aborted flag might need to be propagated to a cross-thread environment, such as a service worker.
</p>


<dl class="idl-def">
	<dt>@aborted</dt>
	<dd>
取得子は、此れの`中止-済み~flag$aBに応じて，次を返さ~MUST
⇒＃
~ON ならば ~T ／
~OFF ならば ~F
◎
The aborted attribute’s getter, when invoked, must return true if the context object’s aborted flag is set, and false otherwise.
</dd>
</dl>

<p class="note">注記：
$AbortSignal ~objに対する変化は，対応している $AbortController ~objの望みを表現するが、 $AbortSignal ~objを観測している~APIは，それを無視することも選べる
— 具体例として、演算がすでに完了していた場合など。
◎
Changes to an AbortSignal object represent the wishes of the corresponding AbortController object, but an API observing the AbortSignal object can chose to ignore them. For instance, if the operation has already completed.
</p>

<p class="algo-head">
`中止-を通達する@
ときは、所与の
( $AbortSignal ~obj %通達 )
に対し，次を走らす：
◎
To signal abort, given a AbortSignal object signal, run these steps:
</p>

<ol>
	<li>
~IF［
%通達 の`中止-済み~flag$aB ~EQ ~ON
］
⇒
~RET
◎
If signal’s aborted flag is set, then return.
</li>
	<li>
%通達 の`中止-済み~flag$aB ~SET ~ON
◎
Set signal’s aborted flag.
</li>
	<li>
%通達 の`中止する~algoたち$aB内の ~EACH( %~algo ) に対し
⇒
%~algo を走らす
◎
For each algorithm in signal’s abort algorithms: run algorithm.
</li>
	<li>
%通達 の`中止する~algoたち$aBを`空にする$
◎
Empty signal’s abort algorithms.
</li>
	<li>
%通達 に向けて名前 `abort^et の`~eventを発火する$
◎
Fire an event named abort at signal.
</li>
</ol>

<p class="algo-head">
`通達に追従させる@
ときは、所与の
( $AbortSignal %追従する通達, $AbortSignal %親~通達 )
に対し，次の手続きを走らす：
◎
A followingSignal (an AbortSignal) is made to follow a parentSignal (an AbortSignal) by running these steps:
</p>

<ol>
	<li>
~IF［
%追従する通達 の`中止-済み~flag$aB ~EQ ~ON
］
⇒
~RET
◎
If followingSignal’s aborted flag is set, then return.
</li>
	<li>
~IF［
%親~通達 の`中止-済み~flag$aB ~EQ ~ON
］
⇒＃
`中止-を通達する$( %追従する通達 )；
~RET
◎
If parentSignal’s aborted flag is set, then signal abort on followingSignal.
</li>
	<li>
<p>
`通達に~algoを追加する$( %親~通達, 次に与える中止-手続き )：
◎
Otherwise, add the following abort steps to parentSignal:
</p>
		<ol>
			<li>
`中止-を通達する$( %追従する通達 )
◎
Signal abort on followingSignal.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="abortcontroller-api-integration">
<h3 title="Using AbortController and AbortSignal objects in APIs">3.3. ~APIにおける ^AbortController, ^AbortSignal ~objの用法</h3>

<p>
中止できる演算を表現する~promiseを利用している~web~platform~APIは、次を固守し~MUST：
◎
Any web platform API using promises to represent operations that can be aborted must adhere to the following:
</p>

<ul>
	<li>
^signal `辞書~member$を通して， $AbortSignal ~objを受容すること。
◎
Accept AbortSignal objects through a signal dictionary member.
</li>
	<li>
演算が中止されたときは、 `AbortError$E 例外で~promiseを却下することにより，それを~~伝えること。
◎
Convey that the operation got aborted by rejecting the promise with an "AbortError" DOMException.
</li>
	<li>
<p>
$AbortSignal の`中止-済み~flag$aBに応じて：
</p>
		<ul>
			<li>
すでに ~ON の場合：
即時に却下すること。
◎
Reject immediately if the AbortSignal's aborted flag is already set, otherwise:
</li>
			<li>
他の場合：
$AbortSignal ~objの変化を観測するときは、`中止する~algoたち$aBによる仕組みを，他の~obと衝突し得ない方式で利用すること。
◎
Use the abort algorithms mechanism to observe changes to the AbortSignal object and do so in a manner that does not lead to clashes with other observers.
</li>
		</ul>
	</li>
</ul>

<div class="example" id="aborting-ongoing-activities-spec-example">

<p>
~promiseを返す ある~meth ^doAmazingness(options) 用の手続きは、次のように記すこともできる：
◎
The steps for a promise-returning method doAmazingness(options) could be as follows:
</p>

<ol>
	<li>
%すごいこと ~LET ^doAmazingness が行う何か
◎
↓</li>
	<li>
%p ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
<p>
~IF［
%options に ^signal ~memberは在る
］：
◎
If options’ signal member is present, then:
</p>
		<ol>
			<li>
<p>
~IF［
%options の ^signal の`中止-済み~flag$aB ~EQ ~ON
］：
</p>
				<ol>
					<li>
`AbortError$E 例外で %p を`却下する$
</li>
					<li>
~RET %p
</li>
				</ol>
◎
If options’ signal’s aborted flag is set, then reject p with an "AbortError" DOMException and return p.
</li>
			<li>
<p>
`通達に~algoを追加する$( %options の ^signal, 次に与える中止-手続き )：
◎
Add the following abort steps to options’ signal:
</p>
				<ol>
					<li>
%すごいこと を停止する
◎
Stop doing amazing things.
</li>
					<li>
`AbortError$E 例外で %p を`却下する$
◎
Reject p with an "AbortError" DOMException.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
この段は、`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%すごい結果 ~LET %すごいこと をした結果
◎
Let amazingResult be the result of doing some amazing things.
</li>
			<li>
%すごい結果 で %p を`解決する$
◎
Resolve p with amazingResult.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

</div>

<p>
~promiseを利用していない~APIであっても、可能な限り，上述を固守するべきである。
◎
APIs not using promises should still adhere to the above as much as possible.
</p>

		</section>
	</section>
	<section id="nodes">
<h2 title="Nodes">4. ~node</h2>

		<section id="introduction-to-the-dom">
<h3 title="Introduction to “The DOM”">4.1. ~DOM序論</h3>


<p>
~DOM（ “The DOM（ Document Object Model ）” ）は元々，文書（特に，~HTML文書や~XML文書）に~accessして操作するための~APIを意味するものであったが、この仕様における語  “文書” は、短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更には本格的な対話的~appまでに渡る、任意の~markupに基づく資源を指すものとして用いられる。
◎
In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.
</p>

<p>
そのような各~文書は、`~node木$として表現される。
`木$を成す`~node$のうち一部は 他の`~node$を`子$に持ち，他のものは葉（末端）~nodeになる。
◎
Each such document is represented as a node tree. Some of the nodes in a tree can have children, while others are always leaves.
</p>

<div class="example">
<p>
次の~HTML文書を例に~~説明する：
◎
To illustrate, consider this HTML document:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</pre>

<p>
これは次のように表現される：
◎
It is represented as follows:
</p>

<ol class="domTree"><li>`文書$
	<ol><li>`~doctype$： `DOCTYPE html^c
	</li><li>`要素$： `html^e <span>`class^c=`e^l</span>
		<ol><li>`要素$： `head^e
			<ol><li>`要素$： `title^e
				<ol><li>$Text： <samp>Aliens?</samp>
				</li></ol>
			</li></ol>
		</li><li>$Text： <samp>⏎␣</samp>
		</li><li>`要素$： `body^e
			<ol><li>$Text: <samp>Why yes.⏎</samp>
			</li></ol>
		</li></ol>
	</li></ol>
</li></ol>

</div>

<p>
`~HTML構文解析器$の~~仕組みから，すべての`~ASCII空白$が $Text `~node$にされてはいないが、一般~概念は明らかである。
~~入力の~markupから，`~node$たちが成す`木$が出来上がる。
<!-- You /can/ explain that! harharhar --> 
◎
Note that, due to the magic that is HTML parsing, not all ASCII whitespace were turned into Text nodes, but the general concept is clear. Markup goes in, a tree of nodes comes out.
</p>

<p class="note">注記：
さらに探求してみたければ、最高によくできている
<a href="https://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>
を利用するといい。
◎
The most excellent Live DOM Viewer can be used to explore this matter in more detail.
</p>

		</section>
		<section id="node-trees">
<h3 title="Node tree">4.2. ~node木</h3>

<div class="p">
<p>
次に挙げる~ifcを実装する~objが、`木$に`関与-$する
⇒＃
$Document,
$DocumentType,
$DocumentFragment,
$Element,
$Text,
$ProcessingInstruction,
$Comment
</p>

<p>
これらは総称して、単に
`~node@
と呼ばれる。
また、これらが成す`木$は，
`~node木@
と称される。
</p>

◎
Document, DocumentType, DocumentFragment, Element, Text, ProcessingInstruction, and Comment objects (simply called nodes) participate in a tree, simply named the node tree.
</div>


<p id="_tree-constraints_">
`~node木$には、`~node$の型とそれに許容される`子$との関係性で表される，次の拘束が課される：
◎
A node tree is constrained as follows, expressed as a relationship between the type of node and its allowed children:
</p>

<dl>
	<dt>$Document</dt>
	<dd>

<p>
`木~順序$において，次からなる：
◎
In tree order:
</p>
		<ol>
			<li id="cp-comments-or-PI">
それぞれが $ProcessingInstruction または $Comment である， 0 個以上の~node
◎
Zero or more nodes each of which is ProcessingInstruction or Comment.
</li>
			<li>
0 個または 1 個の $DocumentType ~node
◎
Optionally one DocumentType node.
</li>
			<!--cp-comments-or-PI-->
			<li>
0 個または 1 個の $Element ~node
◎
Optionally one Element node.
</li>
			<!--cp-comments-or-PI-->
		</ol>
	</dd>

	<dt>$DocumentFragment</dt>
	<dt>$Element</dt>
	<dd>
それぞれが $Element, $ProcessingInstruction, $Comment, $Text のいずれかである， 0 個以上の~nodeからなる
◎
Zero or more nodes each of which is Element, Text, ProcessingInstruction, or Comment.
</dd>

	<dt>$DocumentType</dt>
	<dt>$Text</dt>
	<dt>$ProcessingInstruction</dt>
	<dt>$Comment</dt>
	<dd>
子を持たない
◎
None.
</dd>
</dl>

<p class="algo-head">
`~node$ %node の
`長さ@
とは、 %node に応じて，次で与えられる整数である：
◎
To determine the length of a node node, switch on node: 
</p>

<dl class="switch">

	<dt>$DocumentType</dt>
	<dd>
0
◎
Zero.
</dd>

	<dt>
`文字~data~node$
◎
Text, ProcessingInstruction, Comment
</dt>
	<dd>
その`~data$の`長さ$jStr
◎
Its data’s length.
</dd>

<!-- 他の~node -->
	<dt>$Document</dt>
	<dt>$DocumentFragment</dt>
	<dt>$Element</dt>
	<dd>
その`子$の個数
◎
Its number of children.
</dd>

</dl>

<p>
`~node$が
`空@node
であるとは、［
その`長さ$ ~EQ 0
］を意味する。
【この訳では、この用語は利用しない — ほぼ利用されておらず，単に “長さ ~EQ 0” と記せば済むので。】
◎
A node is considered empty if its length is zero.
</p>


			<section id="document-trees">
<h4 title="Document tree">4.2.1.文書~木</h4>

<p>
`根$が`文書$であるような`~node木$を
`文書~木@
という。
◎
A document tree is a node tree whose root is a document.
</p>

<p>
`文書$ %D の
`文書~要素@
とは、［
%D を`親$とするような`要素$があれば それ ／
~ELSE_ ~NULL
］である。
◎
The document element of a document is the element whose parent is that document, if it exists, and null otherwise.
</p>

<p class="note">注記：
`~node木$の拘束から、そのような`要素$は唯一つに決まる。
【例えば`~HTML文書$ならば `html^e 要素。】
◎
Per the node tree constraints, there can be only one such element.
</p>

<p>
`要素$は、その`根$が`文書$であるとき，
`文書~木~内@
にあるとされる。
◎
An element is in a document tree if its root is a document.
</p>

<p>
`文書~木~内$にある`要素$は、
`文書~内@
にあるともいう。
<span class="note">注記：
用語 “`文書~内$” は、もはや利用されないものと想定されている。
この用語は、それを利用している標準が，まだ`~shadow木$を織り込むよう更新されていないことを指示する。
</span>
◎
An element is in a document if it is in a document tree. The term in a document is no longer supposed to be used. It indicates that the standard using it has not been updated to account for shadow trees.
</p>


			</section>
			<section id="shadow-trees">
<h4 title="Shadow tree">4.2.2. ~shadow木</h4>

<p>
`根$が`~shadow根$であるような`~node木$は
`~shadow木@
という。
◎
A shadow tree is a node tree whose root is a shadow root.
</p>

<p>
`~shadow根$は常に，その`~host$を通して別の`~node木$に添付けられる。
したがって，`~shadow木$が~~孤立することは決してない。
`~shadow根$の`~host$が`関与して$いる`~node木$は、
`~light木@
と呼ばれることもある。
◎
A shadow root is always attached to another node tree through its host. A shadow tree is therefore never alone. The node tree of a shadow root’s host is sometimes referred to as the light tree.
</p>

<p class="note">注記：
`~shadow木$に対応する`~light木$は、それ自身`~shadow木$になり得る。
【~shadow（ “日陰” ）と違って，~light（ “日なた” ）の定義は相対的であり、ある~node木~~単独で “~lightである” とは言えない。】
◎
A shadow tree’s corresponding light tree can be a shadow tree itself.
</p>

<p id="in-a-shadow-including-document">
`要素$は、その`~shadowも含む根$が`文書$であるとき，
`接続されて@
いるという。
◎
An element is connected if its shadow-including root is a document.
</p>


				<section id="shadow-tree-slots">
<h5 title="Slots">4.2.2.1. ~slot</h5>

<p>
各`~shadow木$は、 0 個以上の，
`~slot@
と呼ばれる`要素$を包含する。
◎
A shadow tree contains zero or more elements that are slots.
</p>

<p class="note">注記：
`~slot$は HTML の `slot$e 要素を通してのみ作成される。
◎
A slot can only be created through HTML’s slot element.
</p>

<div class="p">
<p>
各 `~slot$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~slot名@</dt>
	<dd>
文字列。
他が言明されない限り，空~文字列とする。
</dd>
</dl>
◎
A slot has an associated name (a string). Unless stated otherwise it is the empty string.
</div>


<p class="algo-head">
`~slot$の`~slot名$の更新~時に利用する，`属性oを変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update a slot’s name:
</p>

<ol>
	<li>
~IF［
%要素 は `~slot$でない
］~OR［
%局所~名 ~NEQ `name^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If element is a slot, localName is name, and namespace is null, then:
</li>
	<li id="cp-ret-if-nochange">
<p>
~IF［
( %値, %旧-値 ) は、次のいずれかを満たす
］…：
</p>

<ul ><li>%値 ~EQ %旧-値
</li><li>［
%値 ~IN { ~NULL, 空~文字列 }
］~AND［
%旧-値 ~IN { ~NULL, 空~文字列 }
］
</li></ul>

<p>
…ならば
⇒
~RET
</p>
◎
If value is oldValue, then return.
◎
If value is null and oldValue is the empty string, then return.
◎
If value is the empty string and oldValue is null, then return.
</li>
	<li>
%要素 の`~slot名$ ~SET［
%値 ~IN { ~NULL, 空~文字列 } ならば 空~文字列 ／
~ELSE_ %値
］
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
	<li>
`木に~slotableたちを割当する$( %要素 の`根$ )
◎
Run assign slotables for a tree with element’s root.
</li>
</ol>


<p class="note">注記：
`~shadow木$内の，［
`~slot名$ ~EQ 空~文字列
］なる`~slot$のうち，`木~順序$で最初のものは
“既定の~slot”
と称されることもある。
◎
The first slot in a shadow tree, in tree order, whose name is the empty string, is sometimes known as the "default slot".
</p>

<div class="p">
<p>
各 `~slot$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`割当されている~nodeたち@ （ `assigned nodes^en ）</dt>
	<dd>
`~slotable$の~list。
他が言明されない限り，空とする。
</dd>
</dl>
◎
A slot has an associated assigned nodes (a list of slotables). Unless stated otherwise it is empty.
</div>

				</section>
				<section id="light-tree-slotables">
<h5 title="Slotables">4.2.2.2. ~slotable</h5>

<p>
［
$Element ／ $Text
］`~node$は、
`~slotable@
である。
◎
Element and Text nodes are slotables.
</p>

<p class="note">注記：
`~slot$も、`~slotable$になり得る。
◎
A slot can be a slotable.
</p>

<p class="trans-note">【
~slotは “はめ込み口”，
~slotableは “はめ込める物”。
】</p>

<div class="p">
<p>
各 `~slotable$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~slotable名@</dt>
	<dd>
文字列。
他が言明されない限り，空~文字列とする。
</dd>
</dl>
◎
A slotable has an associated name (a string). Unless stated otherwise it is the empty string.
</div>

<p class="algo-head">
`~slotable$の`~slotable名$の更新~時に利用する，`属性oを変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update a slotable’s name:
</p>

<ol>
	<li>
~IF［
%局所~名 ~NEQ `slot^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If localName is slot and namespace is null, then:
</li>
	<!--cp-ret-if-nochange-->
	<li>
%要素 の`~slotable名$ ~SET［
%値 ~IN { ~NULL, 空~文字列 } ならば 空~文字列 ／
~ELSE_ %値
］
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
	<li>
~IF［
%要素 の`割当先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slotableたちを割当する$( その`~slot$ )
◎
If element is assigned, then run assign slotables for element’s assigned slot.
</li>
	<li>
`~slotableを~slotに割当する$( %要素 )
◎
Run assign a slot for element.
</li>
</ol>


<div class="p">
<p>
各 `~slotable$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`割当先~slot@ （ `assigned slot^en ）</dt>
	<dd>
`~slot$, または ~NULL 。
他が言明されない限り，~NULL とする。
</dd>
	<dd class="trans-note">【
自身がどの`~slot$に割当されているかを指示する。
】</dd>
	<dd>
`割当先~slot$が ~NULL でない`~slotable$は、
`割当先がある@
（ `is assigned^en ）という。
【この訳では、この用語は利用せず，直接的に［ `割当先~slot$ ~NEQ ~NULL ］と記す。】
</dd>

</dl>

◎
A slotable has an associated assigned slot (null or a slot). Unless stated otherwise it is null. A slotable is assigned if its assigned slot is non-null.
</div>



				</section>
				<section id="finding-slots-and-slotables">
<h5 title="Finding slots and slotables">4.2.2.3. ~slot ／ ~slotableの見出法</h5>

<p class="algo-head">
`~slotable用に~slotを見出す@
ときは、所与の
( `~slotable$ %~slotable, %~open~flag ~IN { `~open^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To find a slot for a given slotable slotable and an optional open flag (unset unless stated otherwise), run these steps:
</p>

<ol>
	<li>
~IF［
%~slotable の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If slotable’s parent is null, then return null.
</li>
	<li>
%~shadow ~LET %~slotable の`親$の`~shadow根$elm
◎
Let shadow be slotable’s parent’s shadow root.
</li>
	<li>
~IF［
%~shadow ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If shadow is null, then return null.
</li>
	<li>
~IF［
%~open~flag ~NEQ ε
］~AND［
%~shadow の`~mode$sR ~NEQ `open^l
］
⇒
~RET ~NULL
◎
If the open flag is set and shadow’s mode is not "open", then return null.
</li>
	<li>
~RET 次を満たす［
%~shadow の`子孫$
］のうち，`木~順序$で`最初のもの？$
⇒
`~slot$であって，その`~slot名$ ~EQ %~slotable の`~slotable名$
◎
Return the first slot in tree order in shadow’s descendants whose name is slotable’s name, if any, and null otherwise.
</li>
</ol>

<p class="algo-head">
`~slot用に~slotableたちを見出す@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To find slotables for a given slot slot, run these steps:
</p>

<ol>
	<li id="cp-let-result-empty-list">
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
	<li id="cp-if-not-shadow-root">
~IF［
%~slot の`根$は`~shadow根$でない
］
⇒
~RET %結果
◎
If slot’s root is not a shadow root, then return result.
</li>
	<li>
<p>
%~slot の`根$の`~host$の~EACH ( `~slotable$である`子$ %~slotable ) に対し，`木~順序$で：
◎
Let host be slot’s root’s host.
◎
For each slotable child of host, slotable, in tree order:
</p>
		<ol>
			<li>
~IF［
`~slotable用に~slotを見出す$( %~slotable ) ~EQ %~slot
］
⇒
%結果 に %~slotable を付加する
◎
Let foundSlot be the result of finding a slot given slotable.
◎
If foundSlot is slot, then append slotable to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="algo-head">
`~slot用に平坦化された~slotableたちを見出す@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To find flattened slotables for a given slot slot, run these steps:
</p>

<ol>
	<!--cp-let-result-empty-list-->
	<!--cp-if-not-shadow-root-->
	<li>
%~slotable~list ~LET
`~slot用に~slotableたちを見出す$( %~slot )
◎
Let slotables be the result of finding slotables given slot.
</li>
	<li>
~IF［
%~slotable~list は空である
］
⇒
%~slot の~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
~IF［
%子 は`~slotable$である
］
⇒
%~slotable~list に %子 を付加する
◎
If slotables is the empty list, then append each slotable child of slot, in tree order, to slotables.
</li>
	<li>
<p>
%~slotable~list 内の~EACH ( %~node ) に対し：
◎
For each node in slotables:
</p>
		<ol>
			<li>
<p>
~IF［
%~node は`~slot$である
］~AND［
%~node の`根$は`~shadow根$である
］
⇒
［
`~slot用に平坦化された~slotableたちを見出す$( %~node )
］内の~EACH ( `~slotable$ %~slotable ) に対し，順に
⇒
%結果 に %~slotable を付加する
◎
If node is a slot whose root is a shadow root, then:
• Let temporaryResult be the result of finding flattened slotables given node.
• Append each slotable in temporaryResult, in order, to result.
</li>
			<li>
~ELSE
⇒
%結果 に %~node を付加する
◎
Otherwise, append node to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

				</section>
				<section id="assigning-slotables-and-slots">
<h5 title="Assigning slotables and slots">4.2.2.4. ~slotableたち／~slotの割当法</h5>

<p class="algo-head">
`~slotに~slotableたちを割当する@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To assign slotables for a slot slot, run these steps: 
</p>


<ol>
	<li>
%~slotable~list ~LET
`~slot用に~slotableたちを見出す$( %~slot )
◎
Let slotables be the result of finding slotables for slot.
</li>
	<li>
~IF［
%~slotable~list と %~slot に`割当されている~nodeたち$とは、一致しない
<!-- ＊
順序は関係ある？ない？
-->
］
⇒
`~slotの変化を通達する$( %~slot )
◎
If slotables and slot’s assigned nodes are not identical, then run signal a slot change for slot.
</li>
	<li>
%~slot に`割当されている~nodeたち$ ~SET %~slotable~list
◎
Set slot’s assigned nodes to slotables.
</li>
	<li>
%~slotable~list 内の~EACH ( %~slotable ) に対し
⇒
%~slotable の`割当先~slot$ ~SET %~slot
◎
For each slotable in slotables, set slotable’s assigned slot to slot.
</li>
</ol>

<p class="algo-head">
`木に~slotableたちを割当する@
ときは、所与の
( `~node$ %根 )
に対し，次を走らす
⇒
%根 の`広義子孫$である~EACH ( `~slot$ %~slot ) に対し，`木~順序$で
⇒
`~slotに~slotableたちを割当する$( %~slot )
◎
To assign slotables for a tree, given a node root, run assign slotables for each slot slot in root’s inclusive descendants, in tree order. 
</p>

<p class="algo-head">
`~slotableを~slotに割当する@
ときは、所与の
( `~slotable$ %~slotable )
に対し、次を走らす：
◎
To assign a slot, given a slotable slotable, run these steps:
</p>

<ol>
	<li>
%~slot ~LET `~slotable用に~slotを見出す$( %~slotable )
◎
Let slot be the result of finding a slot with slotable.
</li>
	<li>
~IF［
%~slot ~NEQ ~NULL
］
⇒
`~slotに~slotableたちを割当する$( %~slot )
◎
If slot is non-null, then run assign slotables for slot.
</li>
</ol>

				</section>
				<section id="signaling-slot-change">
<h5 title="Signaling slot change">4.2.2.5. ~slot変化の通達-法</h5>
<p>
各
`互いに関係するかつ生成元も類似する閲覧文脈~群$
`HTML$r
%閲覧文脈~群
は、
`通達~slot~list@
を持つ。
それは，`~slot$たちからなる~listであり、他が言明されない限り，空とする。
◎
Each unit of related similar-origin browsing contexts has a signal slot list (a list of slots). Unless stated otherwise it is empty. [HTML]
</p>

<p class="algo-head">
`~slotの変化を通達する@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To signal a slot change, for a slot slot, run these steps:
</p>
<ol>
	<li>
~IF［
%~slot ~NIN %閲覧文脈~群 の`通達~slot~list$
］
⇒
%閲覧文脈~群 の`通達~slot~list$に %~slot を付加する
◎
If slot is not in unit of related similar-origin browsing contexts' signal slot list, append slot to unit of related similar-origin browsing contexts' signal slot list.
</li>
	<li>
`変異~ob 複合~小taskを~queueする$
◎
Queue a mutation observer compound microtask.
</li>
</ol>
				</section>
			</section>
			<section id="mutation-algorithms">
<h4 title="Mutation algorithms">4.2.3. 変異~algo</h4>

<!--% 挿入検証 -->
<p class="algo-head">
%node を %親 の中で %子 の前に
`挿入できるかどうか検証する@
ときは、次を走らす：
◎
To ensure pre-insertion validity of a node into a parent before a child, run these steps:
</p>

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->

<ol>
	<li id="cp-throw-if-chardata">
~IF［
%親 は
$Document, $DocumentFragment, $Element `~node$のいずれでもない
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is not a Document, DocumentFragment, or Element node, throw a "HierarchyRequestError" DOMException.
</li>
	<li id="cp-throw-if-iAN">
~IF［
%node は %親 の`~hostも含む広義先祖$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a host-including inclusive ancestor of parent, throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~IF［
%子 ~NEQ ~NULL
］~AND［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child is not null and its parent is not parent, then throw a "NotFoundError" DOMException.
</li>
	<li id="cp-throw-if-not-doc">
<p>
~IF［
%node は
$DocumentFragment, $DocumentType, $Element, $Text, $ProcessingInstruction, $Comment `~node$
のいずれでもない
］
⇒
~THROW `HierarchyRequestError$E
</p>

<p class="trans-note">【
すなわち “^Document ~nodeである”（何故そのように記されない？）
】</p>

◎
If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or Comment node, throw a "HierarchyRequestError" DOMException.
</li>
	<li id="cp-throw-if-mismatch1">
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `HierarchyRequestError$E
：
</p>
		<ul>
			<li>
［
%node は $Text `~node$ である
］~AND［
%親 は`文書$である
］
</li>
			<li>
［
%node は`~doctype$である
］~AND［
%親 は`文書$でない
］
</li>
		</ul>
◎
If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, throw a "HierarchyRequestError" DOMException.
</li>
	<li>
<p id="cp-throw-if-doc-etc">
~IF［
%親 は`文書$である
］~AND［
%node に応じて，以下が満たされる
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is a document, and any of the statements below, switched on node, are true, throw a "HierarchyRequestError" DOMException.
</p>

		<dl class="switch">
			<dt>`文書片$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li id="cp-has-element-children">
%node の`子たち$内にある`要素$の個数 ~GT 1
◎
If node has more than one element child or＼
</li>
					<li id="cp-has-Text-child">
%node の`子たち$内に $Text `~node$がある
◎
has a Text node child.
</li>
					<li>
<p id="cp-has-an-element-and">
［
%node の`子たち$内にある`要素$の個数 ~EQ 1
］~AND［
次のいずれかが満たされる
］：
</p>
<!-- "inclusively following" -->
<ul id="cp-has-other-doctype"
	><li>%親 の`子たち$内に`要素$がある
</li><li>%子 は`~doctype$である
</li><li>［
%子 ~NEQ ~NULL
］~AND［
%子 に`後続-$する`~doctype$が在る
］
</li></ul>

◎
Otherwise, if node has one element child and either parent has an element child, child is a doctype, or child is not null and a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>`要素$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<!--cp-has-other-doctype-->
<!-- "inclusively following" -->
◎
parent has an element child, child is a doctype, or child is not null and a doctype is following child.
			</dd>

			<dt>`~doctype$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>

<ul>
	<li>%親 の`子たち$内に`~doctype$がある</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%子 に`先行-$する`要素$が在る
］
</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%親 の`子たち$内に`要素$がある
］
</li>
</ul>

◎
parent has a doctype child, child is non-null and an element is preceding child, or child is null and parent has an element child.
			</dd>
		</dl>
	</li>
</ol>

<!--% 前挿入 -->
<p class="algo-head">
%親 の中で
`~nodeを子の前に前挿入する@
ときは、所与の
( %node, %子 )
に対し，次を走らす：
◎
To pre-insert a node into a parent before a child, run these steps:
</p>

<ol>
	<li>
%node を %親 の中で %子 の前に`挿入できるかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before child.
</li>
	<li>
%基準~子 ~LET %子
◎
Let reference child be child.
</li>
	<li id="cp-set-next-sibling">
~IF［
%基準~子 ~EQ %node
］
⇒
%基準~子 ~SET %node の`次-同胞？$
◎
If reference child is node, set it to node’s next sibling.
</li>
<!-- 
【 "If reference child is a node"？】
 -->

	<li id="cp-adopt">
%親 の`~node文書$に`~nodeを受入する$( %node )
◎
Adopt node into parent’s node document.
</li>
	<li>
%親 の中で`~nodeを子の前に挿入する$( %node, %基準~子 )
◎
Insert node into parent before reference child.
</li>
	<li>
~RET %node
<!-- technically this is post-insert -->
◎
Return node.
</li>
</ol>


<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`挿入-時の手続き@
を定義しても~MAY。
この~algoは、`~nodeを子の前に挿入する$~algo内から，
( `~node$ )<!-- ＊inclusiveDescendant -->
を渡して呼出される。
◎
Specifications may define insertion steps for all or some nodes. The algorithm is passed insertedNode, as indicated in the insert algorithm below.
</p>


<!--% 挿入 -->
<p class="algo-head">
%親 の中で
`~nodeを子の前に挿入する@
ときは、所与の
( %node, %子, %~obは抑止する~flag ~IN { `~obは抑止する^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To insert a node into a parent before a child, with an optional suppress observers flag, run these steps:
</p>

<ol>
	<li>
%count ~LET ［
%node は`文書片$であるならば %node の`子$の個数 ／
~ELSE_ 1
］
◎
Let count be the number of children of node if it is a DocumentFragment node, and one otherwise.
</li>
	<li>
<p>
~IF［
%子 ~NEQ ~NULL
］
⇒
~EACH ( `~live範囲o$ %範囲o ) に対し：
◎
If child is non-null, then:
</p>
		<ol>
			<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~GT %子 の`指数$
］
⇒
%範囲o の`始端~offset$ ~INCBY %count
◎
For each live range whose start node is parent and start offset is greater than child’s index, increase its start offset by count.
</li>
			<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~GT %子 の`指数$†
］
⇒
%範囲o の`終端~offset$ ~INCBY %count
◎
For each live range whose end node is parent and end offset is greater than child’s index, increase its end offset by count.
</li>
		</ol>

<p class="trans-note">【†
挿入される地点にちょうど一致する［
範囲oの`境界点$
］は、それが`終端$であっても，影響されないことになる
— すなわち，挿入-後は 挿入された~nodeの直前を指す。
その結果，この~algoを利用している後述の`子を~nodeに置換する$
においては、除去される~nodeの直後または内部を指していた範囲oの境界点は，置換-後は 新たに挿入された~nodeの直前を指すようにされる（~node木の先頭／末尾から相対的な範囲oの始端／終端の位置変化のふるまいが，対称でない — 同様のことは，`~dataを置換する$~algoにも該当する）。
】</p>
	</li>
	<li id="cp-let-nodes">
%nodes ~LET ［
%node は`文書片$であるならば %node のすべての`子$ ／
~ELSE_ %node のみ
］からなる 【木~順序の】
~list
◎
Let nodes be node’s children if node is a DocumentFragment node, and a list containing solely node otherwise.
</li>
	<li>
~IF［
%node は`文書片$である
］
⇒
%node の~EACH ( `子$ %C ) に対し<!-- 順序は関係なし -->
⇒
%node から`子を除去する$( %C, `~obは抑止する^i )
◎
If node is a DocumentFragment node, remove its children with the suppress observers flag set.
</li>
	<li>

<p>
~IF［
%node は`文書片$である
］
⇒
%node 用に`木~変異~記録を~queueする$( « », %nodes, ~NULL, ~NULL )
◎
If node is a DocumentFragment node, then queue a tree mutation record for node with « », nodes, null, and null.
</p>

<p class="note">注記：
この段では意図的に %~obは抑止する~flag を~~無視する。
◎
This step intentionally does not pay attention to the suppress observers flag.
</p>
	</li>
	<li>
%前-同胞 ~LET ［
%子 ~NEQ ~NULL ならば %子 の`前-同胞？$ ／
~ELSE_ %親 の`最後の子？$
］
◎
Let previousSibling be child’s previous sibling or parent’s last child if child is null.
</li>
	<li>
<p>
%nodes 内の~EACH ( %node ) に対し，`木~順序$で：
◎
For each node in nodes, in tree order:
</p>
		<ol>
			<li>
~IF［
%子 ~EQ ~NULL
］
⇒
%親 の`子たち$に %node を`付加する$set
◎
If child is null, then append node to parent’s children.
</li>
			<li>
~ELSE
⇒
%node を%親 の`子たち$の中で %子 の`指数$の前に`挿入する$
◎
Otherwise, insert node into parent’s children before child’s index.
</li>
			<li>
~IF［
%親 は`~shadow~host$である
］~AND［
%~node は`~slotable$である
］
⇒
`~slotableを~slotに割当する$( %~node )
◎
If parent is a shadow host and node is a slotable, then assign a slot for node.
</li>
			<li id="cp-child-text-content-change-steps-if">
~IF［
%~node は $Text ~nodeである
］
⇒
%親 用の`子~text内容~変更-時の手続き$を走らす
◎
If node is a Text node, run the child text content change steps for parent.
</li>
			<li id="cp-signal-if-assigned-empty">
~IF［
%親 の`根$は`~shadow根$である
］~AND［
%親 は`~slot$である
］~AND［
%親 に`割当されている~nodeたち$は 空~listである
］
⇒
`~slotの変化を通達する$( %親 )
◎
If parent’s root is a shadow root, and parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.
</li>
			<li id="cp-assign-slotables-for-tree">
`木に~slotableたちを割当する$( %~node の`根$ )
◎
Run assign slotables for a tree with node’s root.
</li>
			<li>
<p>
%~node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し，`~shadowも含む木~順序$で：
◎
For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order:
</p>
				<ol>
					<li>
`挿入-時の手続き$に
( %広義子孫 )
を渡して走らす
◎
Run the insertion steps with inclusiveDescendant.
</li>
					<li>
~IF［
%広義子孫 は`接続されて$いない
］
⇒
~CONTINUE
◎
If inclusiveDescendant is connected, then:
</li>
					<li>
~IF［
%広義子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義子孫,
`connectedCallback^l,
空~list
)
◎
If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant, callback name "connectedCallback", and an empty argument list.
</li>
					<li>
<p>
~ELSE
⇒
`要素を昇格しようと試行する$( %広義子孫 )
◎
Otherwise, try to upgrade inclusiveDescendant.
</p>

<p class="note">注記：
%広義子孫 が成功裡に昇格された場合、その ^connectedCallback は，`要素を昇格する$~algoの間に自動的に~enqueueされる。
◎
If this successfully upgrades inclusiveDescendant, its connectedCallback will be enqueued automatically during the upgrade an element algorithm.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~obは抑止する~flag ~NEQ ε
］
⇒
%親 用に`木~変異~記録を~queueする$( %nodes, « », %前-同胞, %子 )
◎
If suppress observers flag is unset, then queue a tree mutation record for parent with nodes, « », previousSibling, and child.
</li>
</ol>



<p class="algo-head">
%親 に
`~nodeを付加する@
ときは、所与の
( %node )
に対し，次を走らす
⇒
%親 の中で`~nodeを子の前に前挿入する$( %node, ~NULL )
◎
To append a node to a parent, pre-insert node into parent before null.
</p>


<!--% 置換 -->
<p class="algo-head">
%親 の中で
`子を~nodeに置換する@
ときは、所与の
( %子, %node )
に対し，次を走らす：
◎
To replace a child with node within a parent, run these steps:
</p>

<ol>
	<!--cp-throw-if-chardata-->
	<!--cp-throw-if-iAN-->
	<!-- 原文誤記 "inclusive ancestor *of* parent" →-->
	<li>
<p id="cp-throw-if-not-parent">
~IF［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child’s parent is not parent, then throw a "NotFoundError" DOMException.
</p>
	</li>
	<!--cp-throw-if-not-doc-->
	<!--cp-throw-if-mismatch1-->
	<li>
<!--cp-throw-if-doc-etc-->
		<dl class="switch">
			<dt>`文書片$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<!--cp-has-element-children-->
					<!--cp-has-Text-child-->
					<li>
						<!--cp-has-an-element-and-->
<ul id="cp-has-other-element"
	><li>%親 の`子たち$内に［ %子 でない`要素$ ］がある
</li><li>%子 に`後続-$する`~doctype$が在る
</li></ul>
◎
Otherwise, if node has one element child and either parent has an element child that is not child or a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>`要素$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<!--cp-has-other-element-->
◎
parent has an element child that is not child or a doctype is following child.
			</dd>

			<dt>`~doctype$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>

<ul><li>%親 の`子たち$内に［ %子 でない`~doctype$ ］がある
</li><li>%子 に`先行-$する`要素$が在る
</li></ul>

◎
parent has a doctype child that is not child, or an element is preceding child.
			</dd>

		</dl>

<p class="note">注記：
この段は，`挿入できるかどうか検証する$ ~algoの似た段と異なる。
◎
The above statements differ from the pre-insert algorithm.
</p>
	</li>
	<li>
%基準~子 ~LET %子 の`次-同胞？$
◎
Let reference child be child’s next sibling.
</li>
	<!--cp-set-next-sibling-->
	<li>
%前-同胞 ~LET %子 の`前-同胞？$
◎
Let previousSibling be child’s previous sibling.
</li>
	<!--cp-adopt-->
	<li>
%除去-済み~nodeたち ~LET 空~list
◎
Let removedNodes be the empty list.
</li>
	<li>
<p>
~IF［
%子 の`親$ ~NEQ ~NULL
］：
◎
If child’s parent is not null, then:
</p>
		<ol>
			<li>
%除去-済み~nodeたち ~SET « %子 »
◎
Set removedNodes to a list solely containing child.
</li>
			<li>
%親 から`子を除去する$( %子, `~obは抑止する^i )
◎
Remove child from its parent with the suppress observers flag set.
</li>
		</ol>

<p class="note">注記：
この段の~~条件は［
%子 ~EQ %node
］の場合に限り，偽になる。
◎
The above can only be false if child is node.
</p>

	</li>
	<!--cp-let-nodes-->
	<li>
%親 の中で`~nodeを子の前に挿入する$( %node, %基準~子, `~obは抑止する^i )
◎
Insert node into parent before reference child with the suppress observers flag set.
</li>
	<li>
%親 用に`木~変異~記録を~queueする$( %nodes, %除去-済み~nodeたち, %前-同胞, %基準~子 )
◎
Queue a tree mutation record for parent with nodes, removedNodes, previousSibling, and reference child.
</li>
	<li>
~RET %子
◎
Return child.
</li>
</ol>

<!--% 全置換 -->
<p class="algo-head">
%親 の
`全~内容を~nodeで置換する@
ときは、所与の
( %node )
に対し，次を走らす：
◎
To replace all with a node within a parent, run these steps:
</p>

<ol>
	<li>
~IF［
%node ~NEQ ~NULL
］
⇒
%親 の`~node文書$に`~nodeを受入する$( %node )
◎
If node is not null, adopt node into parent’s node document.
</li>
	<li>
%除去-済み~nodeたち ~LET %親 のすべての`子$
◎
Let removedNodes be parent’s children.
</li>
	<li>
%追加-済み~nodeたち ~LET ［
%node に応じて，次に与える新たな`~list$
］
⇒＃
~NULL ならば « » ／
`文書片$であるならば %node の`子たち$が成す~list ／
~ELSE_ « %node »
◎
Let addedNodes be the empty list if node is null, node’s children if node is a DocumentFragment node, and a list containing node otherwise.
</li>
	<li>
%親 の~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
%親 から`子を除去する$( %子, `~obは抑止する^i )
◎
Remove all parent’s children, in tree order, with the suppress observers flag set.
</li>
	<li>
~IF［
%node ~NEQ ~NULL
］
⇒
%親 の中で`~nodeを子の前に挿入する$( %node, ~NULL, `~obは抑止する^i )
◎
If node is not null, then insert node into parent before null with the suppress observers flag set.
</li>
	<li>
%親 用に`木~変異~記録を~queueする$( %追加-済み~nodeたち, %除去-済み~nodeたち, ~NULL, ~NULL )
◎
Queue a tree mutation record for parent with addedNodes, removedNodes, null, and null.
</li>
</ol>

<p class="note">注記：
この~algoは `~node木$に課される拘束を検査しない。
仕様の策定者は賢く用いること。
◎
This algorithm does not make any checks with regards to the node tree constraints. Specification authors need to use it wisely.
</p>

<p class="algo-head">
%親 から
`子を前除去する@
ときは、所与の
( %子 )
に対し，次を走らす：
◎
To pre-remove a child from a parent, run these steps:
</p>

<ol>
	<li><!--cp-throw-if-not-parent--></li>
	<li>
%親 から`子を除去する$( %子 )
◎
Remove child from parent.
</li>
	<li>
~RET %子
	<!-- technically this is post-remove -->
◎
Return child.
</li>
</ol>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`除去-時の手続き@
を定義しても~MAY。
この~algoは、`子を除去する$ ~algo内から，
( 除去された`~node$, 旧-`親$ （省略可） )
を渡して呼出される。
◎
Specifications may define removing steps for all or some nodes. The algorithm is passed removedNode, and optionally oldParent, as indicated in the remove algorithm below.
</p>

<!--% 除去 -->
<p class="algo-head">
%親 から`子を除去する@
ときは、所与の
( %~node, %~obは抑止する~flag ~IN { `~obは抑止する^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To remove a node from a parent, with an optional suppress observers flag, run these steps:
</p>

<ol>
	<li>
%指数 ~LET %~node の`指数$
◎
Let index be node’s index.
</li>
	<li>
<p>
~EACH ( `~live範囲o$ %範囲o ) に対し：
◎
↓</p>
		<ol>
			<li>
~IF［
%範囲o の`始端~node$ は %~node の`広義子孫$である
］
⇒＃
%範囲o の`始端~node$ ~SET %親；
%範囲o の`始端~offset$ ~SET %指数
◎
For each live range whose start node is an inclusive descendant of node, set its start to (parent, index).
</li>
			<li>
~IF［
%範囲o の`終端~node$ は %~node の`広義子孫$である
］
⇒＃
%範囲o の`終端~node$ ~SET %親；
%範囲o の`終端~offset$ ~SET %指数
◎
For each live range whose end node is an inclusive descendant of node, set its end to (parent, index).
</li>
			<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~GT %指数
］
⇒
%範囲o の`始端~offset$ ~DECBY 1
◎
For each live range whose start node is parent and start offset is greater than index, decrease its start offset by 1.
</li>
			<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~GT %指数
］
⇒
%範囲o の`終端~offset$ ~DECBY 1
◎
For each live range whose end node is parent and end offset is greater than index, decrease its end offset by 1.
</li>
		</ol>
	</li>
	<li>
［
%反復器 の`根$tVの`~node文書$ ~EQ %~node `~node文書$
］なる，~EACH ( $NodeIterator ~obj  %反復器 ) に対し
⇒
`前除去-時の手続き$に
( %反復器, %~node )
を渡して走らす
◎
For each NodeIterator object iterator whose root’s node document is node’s node document, run the NodeIterator pre-removing steps given node and iterator.
</li>
	<li>
%前-同胞 ~LET %~node の`前-同胞？$
◎
Let oldPreviousSibling be node’s previous sibling.
</li>
	<li>
%次-同胞 ~LET %~node の`次-同胞？$
◎
Let oldNextSibling be node’s next sibling.
</li>
	<li>
%~node を %親 の`子たち$から`除去する$
◎
Remove node from its parent’s children.
</li>
	<li>
~IF［
%~node の`割当先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slotableたちを割当する$( その`~slot$ )
◎
If node is assigned, then run assign slotables for node’s assigned slot.
</li>
			<!--cp-signal-if-assigned-empty-->
	<li>
<p>
~IF［［
%~node の`広義子孫$のうち，`~slot$であるもの
］は在る
］：
◎
If node has an inclusive descendant that is a slot, then:
</p>
		<ol>
			<li>
`木に~slotableたちを割当する$( %親 の`根$ )
◎
Run assign slotables for a tree with parent’s root.
</li>
			<!--cp-assign-slotables-for-tree-->
		</ol>
	</li>
	<li>
`除去-時の手続き$に
( %~node, %親 )
を渡して走らす
◎
Run the removing steps with node and parent.
</li>
	<li>
<p>
~IF［
%~node は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%~node,
`disconnectedCallback^l,
空~list
)
◎
If node is custom, then enqueue a custom element callback reaction with node, callback name "disconnectedCallback", and an empty argument list.
</p>

<p class="note">注記：
今の所，`~custom$である`要素$には %親 を渡さないのは意図的であるが、将来に必要になった場合は変更され得る。
◎
It is intentional for now that custom elements do not get parent passed. This might change in the future if there is a need.
</p>

	<li>
<p>
%~node の~EACH ( `~shadowも含む子孫$ %子孫 ) に対し，`~shadowも含む木~順序$で：
◎
For each shadow-including descendant descendant of node, in shadow-including tree order, then:
</p>
		<ol>
			<li>
`除去-時の手続き$に
( %子孫 )
を渡して走らす
◎
Run the removing steps with descendant.
</li>
			<li>
~IF［
%子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%子孫,
`disconnectedCallback^l,
空~list
)
◎
If descendant is custom, then enqueue a custom element callback reaction with descendant, callback name "disconnectedCallback", and an empty argument list.
</li>
		</ol>
	</li>
	<li>
%親 の~EACH ( `広義先祖$ %広義先祖 ) に対し
⇒
%広義先祖 の`登録-済み~ob~list$内の~EACH ( %登録-済み ) に対し
⇒
~IF［
%登録-済み の`~options$obの $MutationObserverInit.subtree ~EQ ~T
］
⇒
%~node の`登録-済み~ob~list$に 次のようにされた新たな`一時~登録-済み~ob$を`付加する$
⇒＃
`~ob$ob ~SET %登録-済み の`~ob$ob,
`~options$ob ~SET %登録-済み の`~options$ob,
`~source$ob ~SET %登録-済み
◎
For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of inclusiveAncestor’s registered observer list, if registered’s options’s subtree is true, then append a new transient registered observer whose observer is registered’s observer, options is registered’s options, and source is registered to node’s registered observer list.
</li>
	<li>
~IF［
%~obは抑止する~flag ~NEQ ε
］
⇒
%親 用に`木~変異~記録を~queueする$( « », « %~node », %前-同胞, %次-同胞 )
◎
If suppress observers flag is unset, then queue a tree mutation record for parent with « », « node », oldPreviousSibling, and oldNextSibling.
</li>
	<!--cp-child-text-content-change-steps-if-->
</ol>


			</section>
			<section id="interface-nonelementparentnode">
<h4>4.2.4. ~mixin ^@NonElementParentNode</h4>

<p class="note">注記：
~Web互換性のため、 $getElementById() ~methは，`要素$ 上には（したがって $ParentNode 上にも）公開できない。
◎
Web compatibility prevents the getElementById() method from being exposed on elements (and therefore on ParentNode).
</p>

！！
interface mixin @NonElementParentNode {
  $Element? $getElementById(~DS %elementId);
};
$Document includes $NonElementParentNode;
$DocumentFragment includes $NonElementParentNode;
！

<dl class="domintro">
	<dt>%node . $getElementById(elementId)</dt>
	<dd>
%node の`子孫$であって, `~ID$ ~EQ %elementId なる`要素$のうち，`最初のもの？$を返す。
◎
Returns the first element within node’s descendants whose ID is elementId.
</dd>

</dl>

<dl class="idl-def">
	<dt>@getElementById(elementId)</dt>
	<dd>
被呼出時には、此れの`子孫$のうち，［
`~ID$ ~EQ %elementId
］なる`要素$のうち，`最初のもの？$を返さ~MUST。
◎
The getElementById(elementId) method, when invoked, must return the first element, in tree order, within the context object’s descendants, whose ID is elementId, and null if there is no such element otherwise.
</dd>
</dl>
			</section>
			<section id="mixin-documentorshadowroot">
<h4>4.2.5. ~mixin ^@DocumentOrShadowRoot</h4>

！！
interface mixin @DocumentOrShadowRoot {
};

$Document includes $DocumentOrShadowRoot;
$ShadowRoot includes $DocumentOrShadowRoot;
！


<p class="note">注記：
$DocumentOrShadowRoot ~mixinは、［
`文書$, `~shadow根$
］で共有される~APIを定義したいと求める他の標準により利用されることが期待されている。
◎
The DocumentOrShadowRoot mixin is expected to be used by other standards that want to define APIs shared between documents and shadow roots.
</p>

			</section>
			<section id="interface-parentnode">
<h4>4.2.6. ~mixin ^@ParentNode</h4>

<p class="algo-head">
`~nodeたちを~nodeに変換する@
手続きは、所与の
( %nodes, %文書 )
に対し，次を走らす：
◎
To convert nodes into a node, given nodes and document, run these steps:
</p>

<p class="trans-note">【
%nodes は、~nodeと文字列が混在する引数~list。
】</p>

<ol>
	<li>
%nodes 内の~EACH ( 文字列 %文字列 ) を
`新たな~Text~node$( %文字列, %文書 )
に置換する
◎
Let node be null.
◎
Replace each string in nodes with a new Text node whose data is the string and node document is document.
</li>
	<li>
~IF［
%nodes に含まれる`~node$は 1 個だけ
］
⇒
~RET その`~node$
◎
If nodes contains one node, set node to that node.
</li>
	<li>
%文書片 ~LET 新たな`文書片$
◎
Otherwise, set node to a new DocumentFragment＼
</li>
	<li>
%文書片 の`~node文書$ ~SET %文書
◎
whose node document is document, and then＼
</li>
	<li>
%nodes 内の~EACH ( %node ) に対し
⇒
%文書片 に`~nodeを付加する$( %node )
◎
append each node in nodes, if any, to it.
</li>
	<li>
~RET %文書片
◎
Return node.
</li>
</ol>

！！
interface mixin @@ParentNode {
  [`SameObject$] ~RA $HTMLCollection $children;
  ~RA $Element? $firstElementChild;
  ~RA $Element? $lastElementChild;
  ~RA ~UL $childElementCount;

  [`CEReactions$, `Unscopable$] void $prepend((Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $append((Node or ~DS)... %nodes);

  $Element? $querySelector(~DS %selectors);
  [`NewObject$] $NodeList $querySelectorAll(~DS %selectors);
};
$Document includes $ParentNode;
$DocumentFragment includes $ParentNode;
$Element includes $ParentNode;
！

<dl class="domintro">
	<dt>%collection = %node . $children</dt>
	<dd>
`子$である`要素$をすべて返す。
◎
Returns the child elements.
</dd>

	<dt>%element = %node . $firstElementChild</dt>
	<dd>
`子$である`要素$のうち，`最初のもの？$を返す。
◎
Returns the first child that is an element, and null otherwise.
</dd>

	<dt>%element = %node . $lastElementChild</dt>
	<dd>
 `子$である`要素$のうち，`最後のもの？$を返す。
◎
Returns the last child that is an element, and null otherwise.
</dd>

	<dt>%node . $prepend(nodes)</dt>
	<dd>
%nodes 引数の中の文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の`最初の子？$の前に挿入する。
◎
Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>

<dd id="cp-throw-if-violate-tree">
`~node木$の拘束に反する場合、 `HierarchyRequestError$E が`投出$される。
◎
Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
</dd>

	<dt>%node . $append(nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の`最後の子？$の後に挿入する。
◎
Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $querySelector(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する`要素$のうち，`最初のもの？$を返す。
◎
Returns the first element that is a descendant of node that matches selectors.
</dd>

	<dt>%node . $querySelectorAll(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する，すべての`要素$を返す。
◎
Returns all element descendants of node that match selectors.
</dd>

</dl>

<dl class="idl-def">
	<dt>@children</dt>
	<dd>
取得子は、次のようにされた $HTMLCollection `~collection$を返さ~MUST
⇒＃
`根$cL ~SET 此れ,
`~filter$cLは 此れの`子$である`要素$のみに合致する
◎
The children attribute’s getter must return an HTMLCollection collection rooted at context object matching only element children.
</dd>

	<dt>@firstElementChild</dt>
	<dd>
取得子は、此れの`子$である`要素$のうち，`最初のもの？$を返さ~MUST。
◎
The firstElementChild attribute’s getter must return the first child that is an element, and null otherwise.
</dd>

	<dt>@lastElementChild</dt>
	<dd>
取得子は、此れの`子$である`要素$のうち，`最後のもの？$を返さ~MUST。
◎
The lastElementChild attribute’s getter must return the last child that is an element, and null otherwise.
</dd>

	<dt>@childElementCount</dt>
	<dd>
取得子は、此れの`子$である`要素$の個数を返さ~MUST。
◎
The childElementCount attribute’s getter must return the number of children of context object that are elements.
</dd>

	<dt>@prepend(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The prepend(nodes) method, when invoked, must run these steps: 
</p>
		<ol>
			<li id="cp-convert-nodes">
%node ~LET
`~nodeたちを~nodeに変換する$( %nodes, 此れの`~node文書$ )
◎
Let node be the result of converting nodes into a node, given nodes and context object’s node document.
</li>
			<li>
此れの中で`~nodeを子の前に前挿入する$( %node, 此れの`最初の子？$ )
◎
Pre-insert node into context object before the context object’s first child.
</li>
		</ol>
	</dd>

	<dt>@append(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The append(nodes) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-convert-nodes-->
			<li>
此れに`~nodeを付加する$( %node )
◎
Append node to context object.
</li>
		</ol>
	</dd>

	<dt>@querySelector(selectors)</dt>
	<dd>
被呼出時には、次の結果~内の要素のうち，`最初のもの？$を返さ~MUST
⇒
此れの`視野の下で選択子を照合する$( %selectors )
◎
The querySelector(selectors) method, when invoked, must return the first result of running scope-match a selectors string selectors against context object, if the result is not an empty list, and null otherwise.
</dd>

	<dt>@querySelectorAll(selectors)</dt>
	<dd>
被呼出時には、此れの`視野の下で選択子を照合する$( %selectors )
の結果を，`静的$なものとして 返さ~MUST。
◎
The querySelectorAll(selectors) method, when invoked, must return the static result of running scope-match a selectors string selectors against context object.
</dd>
</dl>
			</section>
			<section id="interface-nondocumenttypechildnode">
<h4>4.2.7. ~mixin ^@NonDocumentTypeChildNode</h4>

<p class="note">注記：
~Web互換性のため、
$previousElementSibling, $nextElementSibling
属性は，`~doctype$上には（したがって， $ChildNode 上にも）公開できない。
◎
Web compatibility prevents the previousElementSibling and nextElementSibling attributes from being exposed on doctypes (and therefore on ChildNode).
</p>

！！
interface mixin @NonDocumentTypeChildNode {
  ~RA $Element? $previousElementSibling;
  ~RA $Element? $nextElementSibling;
};
$Element includes $NonDocumentTypeChildNode;
$CharacterData includes $NonDocumentTypeChildNode;
！

<dl class="domintro">
	<dt>%element = %node . $previousElementSibling</dt>
	<dd>
`先行-$する`同胞$の`要素$のうち，`最後のもの？$を返す。
◎
Returns the first preceding sibling that is an element, and null otherwise.
</dd>

	<dt>%element = %node . $nextElementSibling</dt>
	<dd>
`後続-$する`同胞$の`要素$のうち，`最初のもの？$を返す。
◎
Returns the first following sibling that is an element, and null otherwise.
</dd>
</dl>

<dl class="idl-def">
	<dt>@previousElementSibling</dt>
	<dd>
取得子は、次を満たす~nodeのうち，`最後のもの？$を返さ~MUST
⇒
［
此れの`同胞$である
］~AND［
此れに`先行-$する
］~AND［
`要素$である
］
◎
The previousElementSibling attribute’s getter must return the first preceding sibling that is an element, and null otherwise.
</dd>

	<dt>@nextElementSibling</dt>
	<dd>
取得子は、次を満たす~nodeのうち，`最初のもの？$を返さ~MUST
⇒
［
此れの`同胞$である
］~AND［
此れに`後続-$する
］~AND［
`要素$である
］
◎
The nextElementSibling attribute’s getter must return the first following sibling that is an element, and null otherwise.
</dd>
</dl>

			</section>
			<section id="interface-childnode">
<h4>4.2.8. ~mixin ^@ChildNode</h4>

！！
interface mixin @ChildNode {
  [`CEReactions$, `Unscopable$] void $before(($Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $after(($Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $replaceWith(($Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $remove();
};
$DocumentType includes $ChildNode;
$Element includes $ChildNode;
$CharacterData includes $ChildNode;
！

<dl class="domintro">
	<dt>%node . $before(...nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の直前に挿入する。
◎
Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $after(...nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の直後に挿入する。
◎
Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $replaceWith(...nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%node を %nodes に置換する。
◎
Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $remove()</dt>
	<dd>
%node を除去する。
◎
Removes node.
</dd>

</dl>

<dl class="idl-def">
	<dt>@before(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The before(nodes) method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-let-ctx-parent">
%親 ~LET 此れの`親$
◎
Let parent be context object’s parent.
</li>
			<li id="cp-exit-if-null-parent">
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
◎
If parent is null, then return.
</li>
			<li>
%およそ前-同胞 ~LET 次を満たす~nodeのうち，`最後のもの？$
⇒
［
此れの`同胞$である
］~AND［
此れに`先行-$する
］~AND［
~node ~NIN %nodes に与えられた引数の集合
］
◎
Let viablePreviousSibling be context object’s first preceding sibling not in nodes, and null otherwise.
</li>
			<!--cp-convert-nodes-->
			<li>
%およそ前-同胞 ~SET ［
%およそ前-同胞 ~EQ ~NULL ならば %親 の`最初の子？$ ／
~ELSE_ %およそ前-同胞 の`次-同胞？$
］
◎
If viablePreviousSibling is null, set it to parent’s first child, and to viablePreviousSibling’s next sibling otherwise.
</li>
			<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %およそ前-同胞 )
◎
Pre-insert node into parent before viablePreviousSibling.
</li>
		</ol>
	</dd>

	<dt>@after(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The after(nodes) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-ctx-parent-->
			<!--cp-exit-if-null-parent-->
			<li id="cp-let-viableNextSibling">
%およそ次-同胞 ~LET 次を満たす~nodeのうち，`最初のもの？$
⇒
［
此れの`同胞$である
］~AND［
此れに`後続-$する
］~AND［
~node ~NIN %nodes に与えられた引数の集合
］
◎
Let viableNextSibling be context object’s first following sibling not in nodes, and null otherwise.
</li>
			<!--cp-convert-nodes-->
			<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %およそ次-同胞 )
◎
Pre-insert node into parent before viableNextSibling.
</li>
		</ol>
	</dd>

	<dt>@replaceWith(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The replaceWith(nodes) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-ctx-parent-->
			<!--cp-exit-if-null-parent-->
			<!--cp-let-viableNextSibling-->
			<!--cp-convert-nodes-->
			<li>
<p>
~IF［
此れの`親$ ~EQ %親
］
⇒
%親 の中で`子を~nodeに置換する$( 此れ, %node )
◎
If context object’s parent is parent, replace the context object with node within parent.
</p>

<p class="note">注記：
此れは %node の中に挿入されていることもある。
◎
Context object could have been inserted into node.
</p>
			</li>
			<li>
~ELSE
⇒
%親 の中で`~nodeを子の前に前挿入する$( %node, %およそ次-同胞 )
◎
Otherwise, pre-insert node into parent before viableNextSibling.
</li>
		</ol>
	</dd>

	<dt>@remove()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`親$ ~EQ ~NULL
］
⇒
~RET
◎
If context object’s parent is null, then return.
</li>
			<li>
此れの`親$から`子を除去する$( 此れ )
◎
Remove the context object from context object’s parent.
</li>
		</ol>
	</dd>
</dl>


			</section>
			<section id="mixin-slotable">
<h4 title="Mixin Slotable">4.2.9. ~mixin ^@Slotable</h4>

！！
interface mixin @Slotable {
  ~RA $HTMLSlotElement? $assignedSlot;
};

$Element includes $Slotable;
$Text includes $Slotable;
！


<dl class="idl-def">
	<dt>@assignedSlot</dt>
	<dd>
取得子は、次を走らせ~MUST
⇒
`~slotable用に~slotを見出す$( 此れ, `~open^i )
◎
The assignedSlot attribute’s getter must return the result of find a slot given context object and with the open flag set.
</dd>
</dl>



			</section>
			<section id="old-style-collections">
<h4 title="Old-style collections: NodeList and HTMLCollection">4.2.10. 旧式の~collection： ^NodeList と ^HTMLCollection</h4>

<p>
`~collection@
は`~node$の~listを表現する~objである。
`~collection$は
`~live@
にも
`静的@
にもなり得る。
他が言明されない限り、`~collection$は`~live$で~MUST。
◎
A collection is an object that represents a list of nodes. A collection can be either live or static. Unless otherwise stated, a collection must be live.
</p>

<p>
`~live$である`~collection$の［
属性／~meth
］は、~dataの~snapshotではなく 実際の下層~data†に対し，演算し~MUST††。
◎
If a collection is live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

<p class="trans-note">【†
すなわち、作成-時の~data（~snapshot）ではなく，~accessされた時点における~data
】【††
従って，~collectionの走査-中に木を改変するときは、~collectionの無限増殖に陥いらないよう注意する必要がある。
】【
`静的$とされている場合は，逆に、~dataの~snapshotに対し演算することになる。
】</p>

<div class="p">
<p>
各 `~collection$の作成-時には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`根@cL</dt>
	<dd>
~collectionの視野を与える。
</dd>
	<dt>`~filter@cL</dt>
	<dd>
~nodeが~collectionに含められるための条件を与える。
</dd>
</dl>

◎
When a collection is created, a filter and a root are associated with it.
</div>

<p>
`~collection$は、［
その`根$cLを根とする部分木の中で，所与の`~filter$cLに合致する`~node$
］のみを含むような~viewを
`表現-@
する。
この~viewは全順序である
— `~collection$に含められる~nodeたちは、他の要件が指定されない限り，`木~順序$に整列され~MUST。
◎
The collection then represents a view of the subtree rooted at the collection’s root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the collection must be sorted in tree order.
</p>

<p class="trans-note">【
ほとんどの~collectionでは，`根$cL自身は`~filter$cLに合致しないが、
$NodeIterator の`反復器~collection$など，そうでないものもある。
】</p>

				<section id="interface-nodelist">
<h5>4.2.10.1. ~ifc ^@NodeList</h5>

<p>
$NodeList ~objは`~node$の`~collection$である。
◎
A NodeList object is a collection of nodes.
</p>

！！
[`Exposed$=Window]
interface @NodeList {
  getter $Node? $item(~UL %index);
  ~RA ~UL $length;
  iterable&lt;$Node&gt;;
};
！


<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`~node$の個数を返す。
◎
Returns the number of nodes in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`木~順序$に整列された下で、`~collection$の中で， %index 番の`~node$を返す。
◎
Returns the node with index index from the collection. The nodes are sorted in tree order.
</dd>
</dl>

<p>
~collection %O が`~supportする~prop~index$は、
0 以上［
%O が`表現-$する~nodeの個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of nodes represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れが`表現-$する~nodeの個数を返さ~MUST。
◎
The length attribute must return the number of nodes represented by the collection.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
%index ~NIN { 此れが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  此れの中の %index 番の`~node$
］を返さ~MUST。
◎
The item(index) method must return the indexth node in the collection. If there is no indexth node in the collection, then the method must return null.
</dd>
</dl>

				</section>
				<section id="interface-htmlcollection">
<h5>4.2.10.2. ~ifc ^@HTMLCollection</h5>

！！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @HTMLCollection {
  ~RA ~UL $length;
  getter $Element? $item(~UL %index);
  getter $Element? $namedItem(~DS %name);
};
！

<p>
$HTMLCollection ~objは`要素$の`~collection$である。
◎
An HTMLCollection object is a collection of elements.
</p>

<p class="note">注記：
$HTMLCollection は、歴史上の~~理由から~~廃するわけにいかない所産である。
開発者は それを利用し続けても構わないが、新たな~API標準の設計者は それを利用しないこと（代わりに~IDL <code >sequence&lt;%T&gt;</code> 型を利用すること）。
◎
HTMLCollection is a historical artifact we cannot rid the web of. While developers are of course welcome to keep using it, new API standard designers ought not to use it (use sequence&lt;T&gt; in IDL instead).
</p>

<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`要素$の個数を返す。
◎
Returns the number of elements in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`要素$たちを`木~順序$に整列した下での、`~collection$の中で %index 番の`要素$を返す。
◎
Returns the element with index index from the collection. The elements are sorted in tree order.
</dd>

	<dt>%element = %collection . $namedItem(name)</dt>
	<dt>%element = %collection[%name]</dt>
	<dd>
`~collection$の中で `~ID$ または名前が %name なる最初の`要素$を返す。
◎
Returns the first element with ID or name name from the collection.
</dd>

</dl>



<p>
`~collection$ %O が`~supportする~prop~index$は、
0 以上［
%O が`表現-$する要素の個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of elements represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れが`表現-$する~nodeの個数を返さ~MUST。
◎
The length attribute’s getter must return the number of nodes represented by the collection.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
%index ~NIN { 此れが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  此れの中の %index 番の`~node$
］を返さ~MUST。
◎
The item(index) method, when invoked, must return the indexth element in the collection. If there is no indexth element in the collection, then the method must return null.
</dd>
</dl>

<p class="algo-head">
`~collection$ %O が`~supportする~prop名$たちは、次の手続きの結果で与えられる：
◎
The supported property names are the values from the list returned by these steps:
</p>

<ol>
	<li>
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
	<li>
<p>
%O が`表現-$する~EACH ( 要素 %要素 ) に対し，`木~順序$で：
◎
For each element represented by the collection, in tree order:
</p>
		<ol>
			<li>
~IF［
%要素 は `~ID$ %id を持つ
］~AND［
%id ~NIN %結果
］
⇒
%結果 に %id を付加する
◎
If element has an ID which is not in result, append element’s ID to result.
</li>
			<li>
<p>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 は `name^A `属性o$nmを`有する$
］：
</p>
				<ol>
					<li>
%名前 ~LET その `name^A `属性o$nmの値
</li>
					<li>
~IF［
%名前 ~NIN { 空~文字列, %結果 }
］
⇒
%結果 に %名前 を付加する
</li>
				</ol>
◎
If element is in the HTML namespace and has a name attribute whose value is neither the empty string nor is in result, append element’s name attribute value to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<dl class="idl-def">
	<dt>@namedItem(name)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The namedItem(key) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If key is the empty string, return null.
</li>
			<li>
<p>
~RET 此れが`表現-$する`要素$たちのうち，次のいずれかを満たす`最初のもの？$：
</p>

				<ul>
					<li>
`~ID$ ~EQ %name
</li>
					<li>
［
`~HTML~ns$に属する
］~AND［
次を満たす属性oを`有する$
］
⇒
［
`name^A `属性o$nmである
］~AND［
`値$a ~EQ %name
］
</li>
				</ul>
◎
Return the first element in the collection for which at least one of the following is true:
• it has an ID which is key;
• it is in the HTML namespace and has a name attribute whose value is key;
◎
or null if there is no such element.
</li>
		</ol>
	</dd>
</dl>

				</section>
			</section>
		</section>
		<section id="mutation-observers">
<h3 title="Mutation observers">4.3. 変異~ob</h3>

<div class="p">
<p>
各 `互いに関係するかつ生成元も類似する閲覧文脈~群$ `HTML$r
— 以下，この節では単に
`閲覧文脈~群@V
と記す —
には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`変異~ob 複合~小task~queue済み@f</dt>
	<dd>
~flag値
— 初期~時は ~OFF とする。
</dd>

	<dt>`変異~ob~list@</dt>
	<dd>
0 個以上の $MutationObserver ~objからなる`~list$
— 初期~時は空とする。
</dd>
</dl>

◎
Each unit of related similar-origin browsing contexts has a mutation observer compound microtask queued flag, which is initially unset. [HTML]
◎
Each unit of related similar-origin browsing contexts also has a mutation observer list (a list of zero or more MutationObserver objects), which is initially empty.
</div>


<p class="algo-head">
`変異~ob 複合~小taskを~queueする@
ときは、次を走らす：
◎
To queue a mutation observer compound microtask, run these steps:
</p>

<ol>
	<li>
~IF［
`変異~ob 複合~小task~queue済み$f ~EQ ~ON
］
⇒
~RET
◎
If mutation observer compound microtask queued flag is set, then return.
</li>
	<li>
`変異~ob 複合~小task~queue済み$f ~SET ~ON
◎
Set mutation observer compound microtask queued flag.
</li>
	<li>
次に与える`小taskを~queueする$
⇒
次を走らす`複合~小task$
⇒
`変異~obに通知する$
◎
Queue a compound microtask to notify mutation observers.
</li>
</ol>


<p class="algo-head">
`変異~obに通知する@
ときは、次を走らす：
◎
To notify mutation observers, run these steps:
</p>

<ol>
	<li>
`変異~ob 複合~小task~queue済み$f ← ~OFF
◎
Unset mutation observer compound microtask queued flag.
</li>
	<li>
%通知-~list ~LET `閲覧文脈~群$V の`変異~ob~list$を`~cloneする$
◎
Let notifyList be a clone of unit of related similar-origin browsing contexts' mutation observer list.
</li>
	<li>
%通達~slot~list ~LET
`閲覧文脈~群$V の`通達~slot~list$を`~cloneする$
◎
Let signalList be a clone of unit of related similar-origin browsing contexts' signal slot list.
</li>
	<li>
`閲覧文脈~群$V の`通達~slot~list$を`空にする$
◎
Empty unit of related similar-origin browsing contexts' signal slot list.
</li>
	<li>
<p>
%通知-~list 内の~EACH ( %MO ) に対し
⇒
次の手続きを走らす
`複合~小task下位~taskを実行する$
`HTML$r
：
◎
For each mo of notifyList, execute a compound microtask subtask to run these steps: [HTML]
</p>
		<ol>
			<li>
%記録たち ~LET %MO の`記録~queue$moを`~cloneする$
◎
Let records be a clone of mo’s record queue.
</li>
			<li>
%MO の`記録~queue$moを`空にする$
◎
Empty mo’s record queue.
</li>
			<li>
%MO の`~node~list$mo内の~EACH ( %~node ) に対し
⇒
%~node の`登録-済み~ob~list$から 次を満たす`一時~登録-済み~ob$をすべて`除去する$
⇒
その`~ob$ob ~EQ %MO
◎
For each node of mo’s node list, remove all transient registered observers whose observer is mo from node’s registered observer list.
</li>
			<li>
~IF［
%記録たち は`空$でない
］
⇒
`~callback関数を呼出す$( %MO の`~callback$mo, « %記録たち, %MO », %MO )
⇒
例外が投出されたときは、~catchして
⇒
`その例外を報告する$
◎
If records is not empty, then invoke mo’s callback with « records, mo », and mo. If this throws an exception, then report the exception.
</li>
		</ol>
	</li>
	<li>
%通達~slot~list 内の~EACH ( `~slot$ %~slot ) に対し
⇒
%~slot に向けて名前 `slotchange^et の, 次のように初期化される`~eventを発火する$
⇒
$Event.bubbles 属性 ~SET ~T
◎
For each slot of signalList, fire an event named slotchange, with its bubbles attribute set to true, at slot.
</li>
</ol>

<hr>

<p>
各 `~node$には、
`登録-済み~ob~list@
が結付けられる
— それは、 0 個~以上の`登録-済み~ob$からなる`~list$であり，初期~時には空とする。
【この~nodeにおける変異を観測している~obたちを表す。】
◎
Each node has a registered observer list (a list of zero or more registered observers), which is initially empty.
</p>

<div class="p">
<p>
各
`登録-済み~ob@
は、次のものからなる：
</p>

<dl class="def-list">
	<dt>`~ob@ob</dt>
	<dd>
$MutationObserver ~obj。
</dd>

	<dt>`~options@ob</dt>
	<dd>
$MutationObserverInit 辞書。
</dd>
</dl>

◎
A registered observer consists of an observer (a MutationObserver object) and options (a MutationObserverInit dictionary).
</div>

<div class="p">
<p>
`一時~登録-済み~ob@
は、上述に加えて 次のものも持つ，`登録-済み~ob$である：
</p>

<dl class="def-list">
	<dt>`~source@ob</dt>
	<dd>
`登録-済み~ob$。
</dd>
</dl>

◎
A transient registered observer is a registered observer that also consists of a source (a registered observer).
</div>

<p class="note">注記：
`一時~登録-済み~ob$は、所与の`~node$に対し，それが除去された後も`~node$の`子孫$における変異を追跡するために利用される
— これにより、`~node$の`親$にて $MutationObserverInit.subtree が ~T に設定されているときでも，それらの変異は失われずに済む。
◎
Transient registered observers are used to track mutations within a given node’s descendants after node has been removed so they do not get lost when subtree is set to true on node’s parent.
</p>

			<section id="interface-mutationobserver">
<h4>4.3.1. ~ifc ^@MutationObserver</h4>

！！
[$Constructor($MutationCallback %callback),
 `Exposed$=Window]
interface @MutationObserver {
  void $observe($Node %target, optional $MutationObserverInit %options);
  void $disconnect();
  sequence&lt;$MutationRecord&gt; $takeRecords();
};

callback @MutationCallback = void (sequence&lt;$MutationRecord&gt; %mutations, $MutationObserver %observer);

dictionary @@MutationObserverInit {
  ~B @childList = false;
  ~B @attributes;
  ~B @characterData;
  ~B @subtree = false;
  ~B @attributeOldValue;
  ~B @characterDataOldValue;
  sequence&lt;~DS&gt; @attributeFilter;
};
！

<!-- ^@MutationObserver -->
<p>
$MutationObserver ~objを利用すれば、`~node$が成す`木$における変異を観測できる。
◎
A MutationObserver object can be used to observe mutations to the tree of nodes.
</p>

<p>
各 $MutationObserver ~objには、次の概念が結付けられる： 
◎
Each MutationObserver object has these associated concepts:
</p>

<dl class="def-list">
	<dt>`~callback@mo</dt>
	<dd>
~callback関数。
~objの作成-時に設定される。
◎
A callback set on creation.
</dd>

	<dt>`~node~list@mo</dt>
	<dd>
0 個以上の`~node$からなる`~list$。
初期~時は空とする。
◎
A node list (a list of nodes), which is initially empty.
</dd>

	<dt>`記録~queue@mo</dt>
	<dd>
0 個以上の $MutationRecord ~objからなる`~queue$
— 初期~時は空とする。
◎
A record queue (a queue of zero or more MutationRecord objects), which is initially empty. 
</dd>
</dl>

<dl class="domintro">
	<dt>%observer = new $MutationObserver(callback)</dt>
	<dd>
$MutationObserver ~objを構築し，その
`~callback$moを %callback にする。
%callback が呼出されるときは、その 1 〜 2 個目の引数に
( $MutationRecord ~objの~list, 構築された $MutationObserver ~obj )
が渡される。
%callback は、 $observe() ~methにより登録-済みにされた`~node$が変異したとき（した後）に，呼出される。
◎
Constructs a MutationObserver object and sets its callback to callback. The callback is invoked with a list of MutationRecord objects as first argument and the constructed MutationObserver object as second argument. It is invoked after nodes registered with the observe() method, are mutated.
</dd>

	<dt>%observer . $observe(target, options)</dt>
	<dd>
%target （ `~node$ ）を観測して，
%options （ ~obj）に与えた判定基準に基づいて変異を報告するように、~UA に~~指示する。
◎
Instructs the user agent to observe a given target (a node) and report any mutations based on the criteria given by options (an object).
</dd>
	<dd>
<p>
%options 引数により、 ~obj~memberを通して，観測させる変異についての~optionを設定できる。
利用できる~obj~memberは：
◎
The options argument allows for setting mutation observation options via object members. These are the object members that can be used:
</p>

<!-- ^@MutationObserverInit -->
		<dl>
			<dt>$childList</dt>
			<dd>
%target の`子$の変異を観測するときは ~T にする。
◎
Set to true if mutations to target’s children are to be observed.
</dd>

			<dt>$attributes</dt>
			<dd>
%target の`属性o$の変異を観測するときは ~T にする。
$attributeOldValue または $attributeFilter を指定している場合は、省略できる。
◎
Set to true if mutations to target’s attributes are to be observed. Can be omitted if attributeOldValue or attributeFilter is specified. 
</dd>

			<dt>$characterData</dt>
			<dd>
%target の`~data$の変異を観測するときは ~T にする。
$characterDataOldValue を指定している場合は、省略できる。
◎
Set to true if mutations to target’s data are to be observed. Can be omitted if characterDataOldValue is specified.
</dd>

			<dt>$subtree</dt>
			<dd>
%target のみならず，
%target の`子孫$の変異も観測するときは ~T にする。
◎
Set to true if mutations to not just target, but also target’s descendants are to be observed.
</dd>

			<dt>$attributeOldValue</dt>
			<dd>
$attributes を~T にしているか省略していて，かつ
変異~前の %target の`属性o$ `値$aを記録しておく必要がある場合は ~T にする。
◎
Set to true if attributes is true or omitted and target’s attribute value before the mutation needs to be recorded.
</dd>

			<dt>$characterDataOldValue</dt>
			<dd>
$characterData を~T にしているか省略していて，かつ
変異~前の %target の`~data$を記録しておく必要がある場合は ~T にする。
◎
Set to true if characterData is set to true or omitted and target’s data before the mutation needs to be recorded.
</dd>

			<dt>$attributeFilter</dt>
			<dd>
$attributes を ~T にしているか省略していて，かつ
すべての`属性o$の変異を観測する必要はない場合は，必要な`属性o$の（`~ns$a のない）`局所~名$aの~listにする。
◎
Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted.
</dd>

		</dl>
	</dd>

<!-- ^@MutationObserver-->

	<dt>%observer . $disconnect()</dt>
	<dd>
%observer による変異の観測を停止する。
$observe() ~methが再び用いられるまで，
%observer の`~callback$moは呼出されないことになる。
◎
Stops observer from observing any mutations. Until the observe() method is used again, observer’s callback will not be invoked.
</dd>

	<dt>%observer . $takeRecords()</dt>
	<dd>
`記録~queue$moを空にして，空にする前の内容を返す。
◎
Empties the record queue and returns what was in there.
</dd>

</dl>

<dl class="idl-def">
	<dt>@MutationObserver(callback)</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The MutationObserver(callback) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%MO ~LET 次のようにされた，新たな $MutationObserver ~obj
⇒
`~callback$mo ~SET %callback
◎
Let mo be a new MutationObserver object whose callback is callback.
</li>
			<li>
`閲覧文脈~群$V の`変異~ob~list$に %MO を付加する
◎
Append mo to unit of related similar-origin browsing contexts' mutation observer list.
</li>
			<li>
~RET %MO
◎
Return mo.
</li>
		</ol>
	</dd>

	<dt>@observe(target, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The observe(target, options) method, when invoked, must run these steps:
</p>
<!-- ^@MutationObserverInit -->
		<ol>
			<li>
<p>
~IF［［
%options の $attributeOldValue は在る
］~OR［
%options の $attributeFilter は在る
］］~AND［
%options の $attributes は無い
］
⇒
%options の $attributes ~SET ~T
</p>

<p class="trans-note">【
在る／無い（ `is present / is omitted^en ）
—
<a href="~WEBIDL#dfn-present">present / not present</a>
（ Web IDL ）
】</p>

◎
If either options’s attributeOldValue or attributeFilter is present and options’s attributes is omitted, then set options’s attributes to true.
</li>
			<li>
~IF［
%options の $characterDataOldValue は在る
］~AND［
%options の $characterData は無い
］
⇒
%options の $characterData ~SET ~T
◎
If options’s characterDataOldValue is present and options’s characterData is omitted, then set options’s characterData to true.
</li>
			<li>
<p>
~IF［
%options の~memberたちについて，次のいずれかが満たされる
］
⇒
~THROW `TypeError$E ：
◎
↓</p>
				<ul>
					<li>
［
$childList ~EQ ~F
］~AND［
$attributes ~EQ ~F
］~AND［
$characterData ~EQ ~F
］
◎
If none of options’s childList, attributes, and characterData is true, then throw a TypeError.
</li>
					<li>
［
$attributeOldValue ~EQ ~T
］~AND［
$attributes ~EQ ~F
］
◎
If options’s attributeOldValue is true and options’s attributes is false, then throw a TypeError.
</li>
					<li>
［
$attributeFilter は在る
］~AND［
$attributes ~EQ ~F
］
◎
If options’s attributeFilter is present and options’s attributes is false, then throw a TypeError.
</li>
					<li>
［
$characterDataOldValue ~EQ ~T
］~AND［
$characterData ~EQ ~F
］
◎
If options’s characterDataOldValue is true and options’s characterData is false, then throw a TypeError.
</li>
				</ul>
			</li>
			<li>
%登録-済み~list ~LET %target の`登録-済み~ob~list$内の次を満たす`登録-済み~ob$からなる~list
⇒
その`~ob$ob ~EQ 此れ
◎
For each registered of target’s registered observer list, if registered’s observer is the context object:
</li>
			<li>
<p>
%登録-済み~list 内の~EACH ( %登録-済み ) に対し：
◎
↑</p>
				<ol>
					<li>
此れの`~node~list$mo内の~EACH ( %~node ) に対し
⇒
%~node の`登録-済み~ob~list$から 次を満たす`一時~登録-済み~ob$をすべて`除去する$
⇒
その`~source$ob ~EQ %登録-済み
◎
For each node of the context object’s node list, remove all transient registered observers whose source is registered from node’s registered observer list.
</li>
					<li>
%登録-済み の`~options$ob ~SET %options
◎
Set registered’s options to options.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%登録-済み~list は空である
］：
◎
Otherwise:
</p>
				<ol>
					<li>
%target の`登録-済み~ob~list$に［
次のようにされた 新たな`登録-済み~ob$
］を`付加する$
⇒＃
`~ob$ob ~SET 此れ,
`~options$ob ~SET %options
◎
Append a new registered observer whose observer is the context object and options is options to target’s registered observer list.
</li>
					<li>
此れの`~node~list$moに %target を`付加する$
◎
Append target to the context object’s node list.
</li>
				</ol>
			</li>
		</ol>
	</dd>
<!-- ^@MutationObserver -->
	<dt>@disconnect()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The disconnect() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
此れの`~node~list$mo内の~EACH ( %~node ) に対し
⇒
%~node の`登録-済み~ob~list$から，次を満たす`登録-済み~ob$をすべて除去する
⇒
その`~ob$ob ~EQ 此れ
◎
For each node of the context object’s node list, remove any registered observer from node’s registered observer list for which the context object is the observer.
</li>
			<li>
此れの`記録~queue$moを`空にする$
◎
Empty the context object’s record queue.
</li>
		</ol>
	</dd>

	<dt>@takeRecords()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The takeRecords() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%記録たち ~LET 此れの`記録~queue$moを`~cloneする$
◎
Let records be a clone of the context object’s record queue.
</li>
			<li>
此れの`記録~queue$moを`空にする$
◎
Empty the context object’s record queue.
</li>
			<li>
~RET %記録たち
◎
Return records.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="queueing-a-mutation-record">
<h4 title="Queuing a mutation record">4.3.2. 変異~記録を~queueする</h4>


<p class="algo-head">
%~target 用にある %種別 の
`変異~記録を~queueする@
ときは、所与の
(
%名前, %~ns, %旧-値,
%追加-済み~nodeたち, %除去-済み~nodeたち, %前-同胞, %次-同胞
)
に対し，次を走らす：
◎
To queue a mutation record of type for target with name, namespace, oldValue, addedNodes, removedNodes, previousSibling, and nextSibling, run these steps:
</p>

<ol>
	<li>
%有関係~obたち ~LET 新たな`~map$
◎
Let interestedObservers be an empty map.
</li>
	<li>
%nodes ~LET %~target のすべての`広義先祖$
◎
Let nodes be the inclusive ancestors of target.
</li>
	<li>
<p>
%nodes 内の~EACH ( %node ) に対し
【順序は？】
⇒
%node の`登録-済み~ob~list$内の~EACH ( %登録-済み ) に対し：
◎
For each node in nodes, and then for each registered of node’s registered observer list:
</p>
		<ol>
			<li>
%options ~LET %登録-済み の`~options$ob
◎
Let options be registered’s options.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~CONTINUE：
◎
If none of the following are true
</p>
<!-- ^@MutationObserverInit -->
				<ul>
					<li>
［
%node ~NEQ %~target
］~AND［
%options の $subtree ~EQ ~F
］
◎
node is not target and options’s subtree is false
</li>
					<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options の $attributes ~NEQ ~T
］
◎
type is "attributes" and options’s attributes is not true
</li>
					<li>
次がすべて満たされる：

<ul ><li>%種別 ~EQ `attributes^l
</li><li>%options に $attributeFilter は在る
</li><li>［
%名前 ~NIN %options の $attributeFilter
］~OR［
%~ns ~NEQ ~NULL
］
</li></ul>
◎
type is "attributes", options’s attributeFilter is present, and options’s attributeFilter does not contain name or namespace is non-null
</li>
					<li>
［
%種別 ~EQ `characterData^l
］~AND［
%options の $characterData ~NEQ ~T
］
◎
type is "characterData" and options’s characterData is not true
</li>
					<li>
［
%種別 ~EQ `childList^l
］~AND［
%options の $childList ~EQ ~F
］
◎
type is "childList" and options’s childList is false
</li>
				</ul>
			</li>
			<li>
%MO ~LET %登録-済み の`~ob$ob
◎
then:
◎
Let mo be registered’s observer.
</li>
			<li>
~IF［
%有関係~obたち[ %MO ] ~EQ ε
］
⇒
%有関係~obたち[ %MO ] ~SET ~NULL
◎
If interestedObservers[mo] does not exist, then set interestedObservers[mo] to null.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If either＼
</p>
				<ul>
					<li>
［
%種別 ~EQ `attributes^l
］~AND［
%options の $attributeOldValue ~EQ ~T
］
◎
type is "attributes" and options’s attributeOldValue is true, or＼
</li>
					<li>
［
%種別 ~EQ `characterData^l
］~AND［
%options の $characterDataOldValue ~EQ ~T
］
◎
type is "characterData" and options’s characterDataOldValue is true,＼
</li>
				</ul>
<p>
…ならば
⇒
%有関係~obたち[ %MO ] ~SET %旧-値
◎
then set interestedObservers[mo] to oldValue.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
%有関係~obたち を成す~EACH ( %~ob → %~map先の旧-値 ) に対し
⇒
%~ob の`記録~queue$moに［
次のように設定された新たな $@MutationRecord ~obj
］を`~enqueueする$
⇒＃
$type ~SET %種別,
$target ~SET %~target,
$attributeName ~SET %名前,
$attributeNamespace ~SET %~ns,
$oldValue ~SET %~map先の旧-値,
$addedNodes ~SET %追加-済み~nodeたち,
$removedNodes ~SET %除去-済み~nodeたち,
$previousSibling ~SET %前-同胞,
$nextSibling ~SET %次-同胞,
◎
For each observer → mappedOldValue of interestedObservers:
• Let record be a new MutationRecord object with its type set to type, target set to target, attributeName set to name, attributeNamespace set to namespace, oldValue set to mappedOldValue, addedNodes set to addedNodes, removedNodes set to removedNodes, previousSibling set to previousSibling, and nextSibling set to nextSibling.
• Enqueue record to observer’s record queue.
</li>
	<li>
`変異~ob 複合~小taskを~queueする$
◎
Queue a mutation observer compound microtask.
</li>
</ol>

<p class="algo-head">
%~target 用に
`木~変異~記録を~queueする@
ときは、所与の
( %追加-済み~nodeたち, %除去-済み~nodeたち, %前-同胞, %次-同胞 )
に対し
⇒
%~target 用に種別 `childList^l の`変異~記録を~queueする$(
~NULL, ~NULL, ~NULL,
%追加-済み~nodeたち, %除去-済み~nodeたち, %前-同胞, %次-同胞
)
◎
To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and nextSibling, queue a mutation record of "childList" for target with null, null, null, addedNodes, removedNodes, previousSibling, and nextSibling.
</p>

<p class="algo-head">
%~target 用に
`属性~変異~記録を~queueする@
ときは、所与の
( %名前, %~ns, %旧-値 )
に対し
⇒
%~target 用に種別 `attributes^l の`変異~記録を~queueする$(
%名前, %~ns, %旧-値,
« », « », ~NULL, ~NULL
)
◎
To queue an attribute mutation record for target with name, namespace, and oldValue, queue a mutation record of "attributes" for target with name, namespace, oldValue, « », « », null, and null. 
</p>

			</section>
			<section id="interface-mutationrecord">
<h4>4.3.3. ~ifc ^@MutationRecord</h4>


！！
[`Exposed$=Window]
interface @MutationRecord {
  ~RA ~DS $type;
  [`SameObject$] ~RA $Node $target;
  [`SameObject$] ~RA $NodeList $addedNodes;
  [`SameObject$] ~RA $NodeList $removedNodes;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;
  ~RA ~DS? $attributeName;
  ~RA ~DS? $attributeNamespace;
  ~RA ~DS? $oldValue;
};
！

<dl class="domintro">
	<dt>%record . $type</dt>
	<dd>
変異の種類に応じて，次を返す
⇒＃
`属性o$に対する変異であった場合は `attributes^l,
$CharacterData `~node$に対する 変異であった場合は `characterData^l,
`~node$が成す`木$に対する変異であった場合は `childList^l
◎
Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to a CharacterData node. And "childList" if it was a mutation to the tree of nodes.
</dd>

	<dt>%record . $target</dt>
	<dd>
変異に影響された`~node$を返す — $type に応じて
⇒＃
`attributes^l に対しては，`属性o$が変化した`要素$。
`characterData^l に対しては，$CharacterData `~node$。
`childList^l に対しては，`子$の~listが変化した`~node$。
◎
Returns the node the mutation affected, depending on the type. For "attributes", it is the element whose attribute changed. For "characterData", it is the CharacterData node. For "childList", it is the node whose children changed.
</dd>

	<dt>%record . $addedNodes</dt>
	<dt>%record . $removedNodes</dt>
	<dd>
順に、［
追加-, 除去-
］された`~node$の~listを返す。
◎
Return the nodes added and removed respectively.
</dd>

	<dt>%record . $previousSibling</dt>
	<dt>%record . $nextSibling</dt>
	<dd>
順に、追加-または除去された`~node$が在れば その［
`前-同胞？$, `次-同胞？$
］を,
無ければ ~NULL を返す。
◎
Return the previous and next sibling respectively of the added or removed nodes, and null otherwise.
</dd>

	<dt>%record . $attributeName</dt>
	<dd>
変化した`属性o$が在れば その`局所~名$aを,
無ければ ~NULL を返す。
◎
Returns the local name of the changed attribute, and null otherwise.
</dd>

	<dt>%record . $attributeNamespace</dt>
	<dd>
変化した`属性o$が在れば その`~ns$を,
無ければ ~NULL を返す。
◎
Returns the namespace of the changed attribute, and null otherwise.
</dd>

	<dt>%record . $oldValue</dt>
	<dd>
$type に応じて，次の値を返す
⇒＃
`attributes^l に対しては，変化した`属性o$の変化~前の`値$a。
`characterData^l に対しては，変化した`~node$の変化~前の`~data$。
`childList^l に対しては， ~NULL 。
◎
The return value depends on type. For "attributes", it is the value of the changed attribute before the change. For "characterData", it is the data of the changed node before the change. For "childList", it is null.
</dd>

</dl>

<dl class="idl-def">
	<dt>@type</dt>
	<dt>@target</dt>
	<dt>@addedNodes</dt>
	<dt>@removedNodes</dt>
	<dt>@previousSibling</dt>
	<dt>@nextSibling</dt>
	<dt>@attributeName</dt>
	<dt>@attributeNamespace</dt>
	<dt>@oldValue</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
◎
The type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, and oldValue attributes must return the values they were initialized to.
</dd>
</dl>

			</section>
			<section id="garbage-collection">
<h4 title="Garbage collection">4.3.4. ~garbage-collection</h4>

<p>
所与の［
`~node$ %~node,
%~node の`登録-済み~ob~list$に含まれる各`登録-済み~ob$ %登録-済み~ob
］に対しては
⇒＃
%~node は %登録-済み~ob への強い参照を持つ ／
%登録-済み~ob は %~node への弱い参照を持つ
◎
Nodes have a strong reference to registered observers in their registered observer list.
◎
Registered observers in a node’s registered observer list have a weak reference to the node.
</p>

			</section>
		</section>
		<section id="interface-node">
<h3>4.4. ~ifc ^@Node</h3>

！！
[`Exposed$=Window]
interface @Node : $EventTarget {
  ~CUS $ELEMENT_NODE = 1;
  ~CUS $ATTRIBUTE_NODE = 2;
  ~CUS $TEXT_NODE = 3;
  ~CUS $CDATA_SECTION_NODE = 4;
  ~CUS @ENTITY_REFERENCE_NODE = 5; // <!--cp-histroic-->
  ~CUS @ENTITY_NODE = 6; // <!--cp-histroic-->
  ~CUS $PROCESSING_INSTRUCTION_NODE = 7;
  ~CUS $COMMENT_NODE = 8;
  ~CUS $DOCUMENT_NODE = 9;
  ~CUS $DOCUMENT_TYPE_NODE = 10;
  ~CUS $DOCUMENT_FRAGMENT_NODE = 11;
  ~CUS @NOTATION_NODE = 12; // <!--cp-histroic-->
  ~RA ~US $nodeType;<!-- NodeExodus

  ~ RA ~ DS N.namespaceURI;
  ~ RA ~ DS N.prefix;
  ~ RA ~ DS N.localName;-->
  ~RA ~DS $nodeName;

  ~RA USVString $baseURI;

  ~RA ~B $isConnected;
  ~RA $Document? $ownerDocument;
  $Node $getRootNode(optional $GetRootNodeOptions %options);
  ~RA $Node? $parentNode;
  ~RA $Element? $parentElement;
  ~B $hasChildNodes();
  [`SameObject$] ~RA $NodeList $childNodes;
  ~RA $Node? $firstChild;
  ~RA $Node? $lastChild;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;

  [`CEReactions$] attribute ~DS? $nodeValue;
  [`CEReactions$] attribute ~DS? $textContent;
  [`CEReactions$] void $normalize();

  [`CEReactions$, `NewObject$] $Node $cloneNode(optional ~B %deep = false);
  ~B $isEqualNode($Node? %otherNode);
  ~B $isSameNode($Node? %otherNode); // <span class="comment" title="historical alias of ==="
  > `===^c 演算子の歴史上の別名</span>

  ~CUS $DOCUMENT_POSITION_DISCONNECTED = 0x01;
  ~CUS $DOCUMENT_POSITION_PRECEDING = 0x02;
  ~CUS $DOCUMENT_POSITION_FOLLOWING = 0x04;
  ~CUS $DOCUMENT_POSITION_CONTAINS = 0x08;
  ~CUS $DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  ~CUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  ~US $compareDocumentPosition($Node %other);
  ~B $contains($Node? %other);

  ~DS? $lookupPrefix(~DS? %namespace);
  ~DS? $lookupNamespaceURI(~DS? %prefix);
  ~B $isDefaultNamespace(~DS? %namespace);

  [`CEReactions$] $Node $insertBefore($Node %node, $Node? %child);
  [`CEReactions$] $Node $appendChild($Node %node);
  [`CEReactions$] $Node $replaceChild($Node %node, $Node %child);
  [`CEReactions$] $Node $removeChild($Node %child);
};

dictionary @@GetRootNodeOptions {
  boolean @composed = false;
};
！

<p class="note">注記：
$@Node は抽象~ifcであり，`~node$として存在することはない。
それは、すべての`~node$（
$Document,
$DocumentType,
$DocumentFragment,
$Element,
$Text,
$ProcessingInstruction,
$Comment
）から利用される。
◎
Node is an abstract interface and does not exist as node. It is used by all nodes (Document, DocumentType, DocumentFragment, Element, Text, ProcessingInstruction, and Comment).
</p>

<p class="trans-note">【
$Attr も $Node を継承しているが、定義により，木には`関与-$しないことに注意。
（ “^Attr `~node$” という語も何箇所かに現れていて紛らわしいが。）
】</p>

<div class="p">
<p>
各 `~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~node文書@</dt>
	<dd>
`文書$。
作成-時に設定される。
</dd>
</dl>
◎
Each node has an associated node document, set upon creation, that is a document.
</div>


<p class="note">注記：
`~node$の`~node文書$は、`~nodeを受入する$~algoにより変更され得る。
◎
A node’s node document can be changed by the adopt algorithm.
</p>

<p class="trans-note">【
~nodeが`文書~木~内$になくても，結付けられることになる。
】</p>

<p class="algo-head">
`~node$ %node の`親~targetを取得する$ときは、［
%node の`割当先~slot$ ~NEQ ~NULL ならば それ ／
~ELSE_ %node の`親$
］を返す。
◎
A node’s get the parent algorithm, given an event, returns the node’s assigned slot, if node is assigned, and node’s parent otherwise.
</p>

<p class="trans-note">【
`文書$は、~nodeの`親~targetを取得する$~algoを上書きする。
】</p>

<hr>

<dl class="domintro">
	<dt>%node . $nodeType</dt>
	<dd>
<p>
次に挙げる数で表現される,
%node の型を返す：
◎
Returns the type of node, represented by a number from the following list:
</p>

		<dl>
			<dt>$Node . $ELEMENT_NODE `(1)^i</dt>
			<dd>
%node は`要素$である。
◎
node is an element.
</dd>

			<dt>$Node . $TEXT_NODE `(3)^i</dt>
			<dd>
%node は $Text `~node$である。
◎
node is a Text node.
</dd>

			<dt>$Node . $CDATA_SECTION_NODE `(4)^i</dt>
			<dd>
%node は $CDATASection `~node$である。
◎
node is a CDATASection node.
</dd>

			<dt>$Node . $PROCESSING_INSTRUCTION_NODE `(7)^i</dt>
			<dd>
%node は $ProcessingInstruction `~node$である。
◎
node is a ProcessingInstruction node.
</dd>

			<dt>$Node . $COMMENT_NODE `(8)^i</dt>
			<dd>
%node は $Comment `~node$である。
◎
node is a Comment node.
</dd>

			<dt>$Node . $DOCUMENT_NODE `(9)^i</dt>
			<dd>
%node は`文書$である。
◎
node is a document.
</dd>

			<dt>$Node . $DOCUMENT_TYPE_NODE `(10)^i</dt>
			<dd>
%node は`~doctype$である。
◎
node is a doctype.
</dd>

			<dt>$Node . $DOCUMENT_FRAGMENT_NODE `(11)^i</dt>
			<dd>
%node は`文書片$である。
◎
node is a DocumentFragment node.
</dd>
		</dl>
	</dd>

	<dt>%node . $nodeName</dt>
	<dd>
<p>
%node に応じて，次の文字列を返す：
◎
Returns a string appropriate for the type of node, as follows:
</p>
		<dl>
			<dt>$Element</dt>
			<dd>
その`~HTML大文字~化~有修飾~名$
◎
Its HTML-uppercased qualified name. 
</dd>

			<dt>$Attr</dt>
			<dd>
その`有修飾~名$a
◎
Its qualified name.
</dd>

			<dt>$Text</dt>
			<dd>
`#text^l
◎
"#text".
</dd>

			<dt>$CDATASection</dt>
			<dd>
`#cdata-section^l
◎
"#cdata-section".
</dd>

			<dt>$ProcessingInstruction</dt>
			<dd>
その $target
◎
Its target.
</dd>

			<dt>$Comment</dt>
			<dd>
`#comment^l
◎
"#comment".
</dd>

			<dt>$Document</dt>
			<dd>
`#document^l
◎
"#document".
</dd>

			<dt>$DocumentType</dt>
			<dd>
その`名前$dT
◎
Its name.
</dd>

			<dt>$DocumentFragment</dt>
			<dd>
`#document-fragment^l
◎
"#document-fragment".
</dd>
		</dl>
	</dd>
</dl>

<dl class="idl-def">
	<dt>@nodeType</dt>
	<dd>
<p>
取得子は、此れに応じて，次を返さ~MUST（括弧内は数値）：
◎
The nodeType attribute’s getter, when invoked, must return the first matching statement, switching on the context object:
</p>


<dl class="switch"><dt>$Element
</dt><dd>@ELEMENT_NODE (1)

</dd><dt>$Attr
</dt><dd>@ATTRIBUTE_NODE (2)

</dd><dt>$Text
</dt><dd>@TEXT_NODE (3)

</dd><dt>$CDATASection
</dt><dd>@CDATA_SECTION_NODE (4)

</dd><dt>$ProcessingInstruction
</dt><dd>@PROCESSING_INSTRUCTION_NODE (7)

</dd><dt>$Comment
</dt><dd>@COMMENT_NODE (8)

</dd><dt>$Document
</dt><dd>@DOCUMENT_NODE (9)

</dd><dt>$DocumentType
</dt><dd>@DOCUMENT_TYPE_NODE (10)

</dd><dt>$DocumentFragment
</dt><dd>@DOCUMENT_FRAGMENT_NODE (11)

</dd></dl>

	<dt>@nodeName</dt>
	<dd>
<p>
取得子は、此れに応じて，次を返さ~MUST：
◎
The nodeName attribute’s getter, when invoked, must return the first matching statement, switching on the context object:
</p>
<!-- copy* -->
<dl class="switch">
	<dt>$Element</dt>
	<dd>
此れの`~HTML大文字~化~有修飾~名$
◎
Its HTML-uppercased qualified name. 
</dd>

	<dt>$Attr</dt>
	<dd>
此れの`有修飾~名$a
◎
Its qualified name.
</dd>

	<dt>$Text</dt>
	<dd>
`#text^l
◎
"#text".
</dd>

	<dt>$CDATASection</dt>
	<dd>
`#cdata-section^l
◎
"#cdata-section".
</dd>

	<dt>$ProcessingInstruction</dt>
	<dd>
此れの`~target$pI
◎
Its target.
</dd>

	<dt>$Comment</dt>
	<dd>
`#comment^l
◎
"#comment".
</dd>

	<dt>$Document</dt>
	<dd>
`#document^l
◎
"#document".
</dd>

	<dt>$DocumentType</dt>
	<dd>
此れの`名前$dT
◎
Its name.
</dd>

	<dt>$DocumentFragment</dt>
	<dd>
`#document-fragment^l
◎
"#document-fragment".
</dd>
</dl>

	</dd>
</dl>


<dl class="domintro">
	<dt>%node . $baseURI</dt>
	<dd>
%node の`~node文書$の`文書~基底~URL$を返す。
◎
Returns node’s node document’s document base URL.
</dd>

</dl>

<dl class="idl-def">
	<dt>@baseURI</dt>
	<dd>
取得子は、次を走らせた結果を返さ~MUST
⇒
`~URLを直列化する$( 此れの`~node文書$の`文書~基底~URL$ )
◎
The baseURI attribute’s getter must return node document’s document base URL, serialized.
</dd>
</dl>


<dl class="domintro">
	<dt>%node . $isConnected</dt>
	<dd>
［
%node は`接続されて$いるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if node is connected and false otherwise.
</dd>

	<dt>%node . $ownerDocument</dt>
	<dd>
`~node文書$を返す。
`文書$に対しては ~NULL を返す。
◎
Returns the node document. Returns null for documents.
</dd>

	<dt>%node . $getRootNode()</dt>
	<dd>
%node の`根$を返す。
◎
Returns node’s root.
</dd>

	<dt>%node . $getRootNode({ composed:true })</dt>
	<dd>
%node の`~shadowも含む根$を返す。
◎
Returns node’s shadow-including root.
</dd>

	<dt>%node . $parentNode</dt>
	<dd>
`親$を返す。
◎
Returns the parent.
</dd>

	<dt>%node . $parentElement</dt>
	<dd>
`親~要素$を返す。
◎
Returns the parent element.
</dd>

	<dt>%node . $hasChildNodes()</dt>
	<dd>
%node が`子$を持っているかどうかを返す。
◎
Returns whether node has children.
</dd>

	<dt>%node . $childNodes</dt>
	<dd>
すべての`子$を返す。
◎
Returns the children.
</dd>

	<dt>%node . $firstChild</dt>
	<dd>
`最初の子？$を返す。
◎
Returns the first child.
</dd>

	<dt>%node . $lastChild</dt>
	<dd>
`最後の子？$を返す。
◎
Returns the last child.
</dd>

	<dt>%node . $previousSibling</dt>
	<dd>
`前-同胞？$を返す。
◎
Returns the previous sibling.
</dd>

	<dt>%node . $nextSibling</dt>
	<dd>
`次-同胞？$を返す。
◎
Returns the next sibling.
</dd>
</dl>

<dl class="idl-def">
	<dt>@isConnected</dt>
	<dd>
取得子は、［
此れは次を満たすならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
`接続されて$いる
◎
The isConnected attribute’s getter must return true, if context object is connected, and false otherwise.
</dd>

	<dt>@ownerDocument</dt>
	<dd>
取得子は、［
此れは`文書$である ならば ~NULL ／
~ELSE_ 此れの`~node文書$
］を返さ~MUST。
◎
The ownerDocument attribute’s getter must return null, if the context object is a document, and the context object’s node document otherwise.
</dd>
	<dd class="note">注記：
`文書$の`~node文書$は，`文書$ 自身である。
すべての`~node$は、どの時点であれ，`~node文書$を持つ。
◎
The node document of a document is that document itself. All nodes have a node document at all times.
</dd>

	<dt>@getRootNode(options)</dt>
	<dd>
被呼出時には、［［
%options の $GetRootNodeOptions.composed ~EQ ~T
］ならば 此れの`~shadowも含む根$ ／
~ELSE_ 此れの`根$
］を返さ~MUST。
◎
The getRootNode(options) method, when invoked, must return context object’s shadow-including root if options’s composed is true, and context object’s root otherwise.
</dd>

	<dt>@parentNode</dt>
	<dd>
取得子は、此れの`親$を返さ~MUST。
◎
The parentNode attribute’s getter must return the context object’s parent.
</dd>
	<dd class="note">注記：
$Attr `~node$には親はない。
◎
An Attr node has no parent.
</dd>

	<dt>@parentElement</dt>
	<dd>
取得子は、此れの`親~要素$を返さ~MUST。
◎
The parentElement attribute’s getter must return the context object’s parent element.
</dd>

	<dt>@hasChildNodes()</dt>
	<dd>
被呼出時には、［
此れは次を満たすならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
`子$を持つ
◎
The hasChildNodes() method, when invoked, must return true if the context object has children, and false otherwise.
</dd>

	<dt>@childNodes</dt>
	<dd>
取得子は、次のようにされた $NodeList `~collection$を返さ~MUST
⇒＃
`根$cL ~SET 此れ,
`~filter$cLは 此れの`子$のみに合致する
◎
The childNodes attribute’s getter must return a NodeList rooted at the context object matching only children.
</dd>

	<dt>@firstChild</dt>
	<dd>
取得子は、此れの`最初の子？$を返さ~MUST。
◎
The firstChild attribute’s getter must return the context object’s first child.
</dd>

	<dt>@lastChild</dt>
	<dd>
取得子は、此れの`最後の子？$を返さ~MUST。
◎
The lastChild attribute’s getter must return the context object’s last child.
</dd>

	<dt>@previousSibling</dt>
	<dd>
取得子は、此れの`前-同胞？$を返さ~MUST。
◎
The previousSibling attribute’s getter must return the context object’s previous sibling.
</dd>
	<dd class="note">注記：
$Attr `~node$には`同胞$はない。
◎
An Attr node has no siblings.
</dd>

	<dt>@nextSibling</dt>
	<dd>
取得子は、此れの`次-同胞？$を返さ~MUST。
◎
The nextSibling attribute’s getter must return the context object’s next sibling.
</dd>

	<dt>@nodeValue</dt>
	<dd>
<p>
取得子は、此れに応じて，次を返さ~MUST：
◎
The nodeValue attribute must return the following, depending on the context object:
</p>

		<dl class="switch">
			<dt>$Attr</dt>
			<dd>
此れの`値$a
◎
Context object’s value.
</dd>

			<dt>
`文字~data~node$
◎
Text, ProcessingInstruction, Comment
</dt>
			<dd>
此れの`~data$
◎
Context object’s data.
</dd>

			<dt>他の~node</dt>
			<dd>
~NULL
</dd>
		</dl>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The nodeValue attribute must, on setting,＼
</p>
		<ol>
			<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the new value is null, act as if it was the empty string instead, and then＼
</li>
			<li>
<p>
此れに応じて：
◎
do as described below, depending on the context object:
</p>

				<dl class="switch">
					<dt>$Attr</dt>
					<dd>
`既存の属性o値を設定する$( 此れ, %値 )
◎
Set an existing attribute value with context object and new value.
</dd>

					<dt>
`文字~data~node$
◎
Text, ProcessingInstruction, Comment
</dt>
					<dd>
此れの`~dataを置換する$( 0, 此れの`長さ$, %値 )
◎
Replace data with node context object, offset 0, count context object’s length, and data new value.
</dd>

					<dt>他の~node</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>
				</dl>
			</li>
		</ol>
	</dd>

	<dt>@textContent</dt>
	<dd>
<p>
取得子は、此れに応じて，次を返さ~MUST：
◎
The textContent attribute’s getter must return the following, switching on context object:
</p>

		<dl class="switch">
			<dt>$DocumentFragment</dt>
			<dt>$Element</dt>
			<dd>
次を`連結-$した結果
⇒
`木~順序$による，此れのすべての $Text `~node$`子孫$の`~data$
◎
The concatenation of data of all the Text node descendants of the context object, in tree order.
</dd>

			<dt>$Attr</dt>
			<dd>
此れの`値$a
◎
Context object’s value.
</dd>

			<dt>
`文字~data~node$
◎
Text, ProcessingInstruction, Comment
</dt>
			<dd>
此れの`~data$
◎
Context object’s data.
</dd>

<!-- 他の~node -->
			<dt>$Document</dt>
			<dt>$DocumentType</dt>
			<dd>
~NULL
◎
Null.
</dd>
		</dl>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The textContent attribute’s setter must,＼
</p>
		<ol>
			<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the given value is null, act as if it was the empty string instead, and then＼
</li>
			<li>
<p>
此れに応じて：
◎
do as described below, switching on context object:
</p>

				<dl class="switch">

					<dt>$DocumentFragment</dt>
					<dt>$Element</dt>
					<dd>
						<ol>
							<li>
%node ~LET ~NULL
◎
Let node be null.
</li>
							<li>
~IF［
%値 ~NEQ 空~文字列
］
⇒
%node ~SET `新たな~Text~node$( %値, 此れの`~node文書$ )
◎
If the given value is not the empty string, set node to a new Text node whose data is the given value and node document is context object’s node document.
</li>
							<li>
此れの`全~内容を~nodeで置換する$( %node )
◎
Replace all with node within the context object.
</li>
						</ol>
					</dd>

					<dt>$Attr</dt>
					<dd>
`既存の属性o値を設定する$( 此れ, 所与の値 )
◎
Set an existing attribute value with context object and new value.
</dd>

					<dt>
`文字~data~node$
◎
Text, ProcessingInstruction, Comment
</dt>
					<dd>
此れの`~dataを置換する$( 0, 此れの`長さ$, %値 )
◎
Replace data with node context object, offset 0, count context object’s length, and data the given value.
</dd>

<!-- 他の~node -->
					<dt>$Document</dt>
					<dt>$DocumentType</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>

				</dl>
			</li>
		</ol>
	</dd>
</dl>


<dl class="domintro">
	<dt>%node . $normalize()</dt>
	<dd>
%node に含まれている`狭義の~Text~node$のうち［
`長さ$ ~EQ 0
］のものは除去し、`連続的な狭義の~Text~node列$に対しては，その最初の`~node$に~~後続の`~data$を連結してひとまとめにする。
◎
Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes.
</dd>
	<dd class="trans-note">【
この記述は、 “除去-” と “連結-” の順序に関し，微妙に正確でない
— 実際の~algoでは、空 ^Text ~nodeのうち，［
最初の~node %N が空でないような`連続的な狭義の~Text~node列$
］に含まれるものは、後続の空 ^Text ~nodeより先に %N に連結される（その結果として，除去されるが）。
<!-- 
結果の~node木は同じでも，変異の通知-順序は異なり得る。
 -->
】</dd>

</dl>


<dl class="idl-def">
	<dt>@normalize()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The normalize() method, when invoked, must run these steps＼
</p>
		<ol>
			<li>
<p>
此れの`子孫$である~EACH ( `狭義の~Text~node$ %node ) に対し：
◎
for each descendant exclusive Text node node of context object:
</p>

<p class="trans-note">【
木~順序で。
加えて，~~厳密に言えば、このループの中で木から除去される ^Text ~nodeは反復対象から除外する必要もある。
】</p>
				<ol>
					<li>
%長さ ~LET %node の`長さ$
◎
Let length be node’s length.
</li>
					<li>
%長さ ~EQ 0
⇒＃
%node の`親$から`子を除去する$( %node )；
~CONTINUE
◎
If length is zero, then remove node and continue with the next exclusive Text node, if any.
</li>
					<li>
%除去対象 ~LET %node を含む`連続的な狭義の~Text~node列$から %node 自身（常に先頭になる）は除外した結果の~list
◎
↓</li>
					<li>
%data ~LET 次を`連結-$した結果
⇒
%除去対象 内のすべての~nodeの`~data$
◎
Let data be the concatenation of the data of node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
					<li>
%node の`~dataを置換する$( %長さ, 0, %data )
◎
Replace data with node node, offset length, count 0, and data data.
</li>
					<li>
<p>
%除去対象 内の~EACH ( %text ) に対し，順に：
◎
Let currentNode be node’s next sibling.
◎
While currentNode is an exclusive Text node:
</p>
						<ol>
							<li>
<p>
~EACH ( `~live範囲o$ %R ) に対し：
◎
↓</p>
								<ol>
									<li>
~IF［
%範囲o の`始端~node$ ~EQ %text
］
⇒＃
%範囲o の`始端~offset$ ~INCBY %長さ；
%範囲o の`始端~node$ ~SET %node
◎
For each live range whose start node is currentNode, add length to its start offset and set its start node to node.
</li>
									<li>
~IF［
%範囲o の`終端~node$ ~EQ %text
］
⇒＃
%範囲o の`終端~offset$ ~INCBY %長さ；
%範囲o の`終端~node$ ~SET %node
◎
For each live range whose end node is currentNode, add length to its end offset and set its end node to node.
</li>
									<li>
~IF［
%範囲o の`始端~node$ ~EQ %text の`親$
］~AND［
%範囲o の`始端~offset$ ~EQ %text の`指数$
］
⇒＃
%範囲o の`始端~node$ ~SET %node；
%範囲o の`始端~offset$ ~SET %長さ
◎
For each live range whose start node is currentNode’s parent and start offset is currentNode’s index, set its start node to node and its start offset to length.
</li>
									<li>
~IF［
%範囲o の`終端~node$ ~EQ %text の`親$
］~AND［
%範囲o の`終端~offset$ ~EQ %text の`指数$
］
⇒＃
%範囲o の`終端~node$ ~SET %node；
%範囲o の`終端~offset$ ~SET %長さ
◎
For each live range whose end node is currentNode’s parent and end offset is currentNode’s index, set its end node to node and its end offset to length.
</li>
								</ol>
							</li>
							<li>
%長さ ~INCBY %text の`長さ$
◎
Add currentNode’s length to length.
◎
Set currentNode to its next sibling.
</li>
						</ol>
					</li>
					<li>
%除去対象 内の~EACH ( %text ) に対し，順に
⇒
%text の`親$から`子を除去する$( %text )
◎
Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
				</ol>
			</li>
		</ol>
	</dd>
	<dd class="note">注記：
$normalize() は`子~text内容~変更-時の手続き$を走らす必要はない。
それは $Text ~nodeたちを弄り倒すが，`子~text内容$は特に保全するように行うので。
◎
normalize() does not need to run any child text content change steps, since although it messes with Text nodes extensively, it does so specifically in a way that preserves the child text content.
</dd>
</dl>


<dl class="domintro">
	<dt>%node . $cloneNode([deep = false])</dt>
	<dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>

	<dt>%node . $isEqualNode(otherNode)</dt>
	<dd>
%node と %otherNode が同じ~propを持つかどうかを返す。
◎
Returns whether node and otherNode have the same properties.
</dd>
</dl>


<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`~clone時の手続き@
を定義しても~MAY。
この~algoは、`~nodeを~cloneする$ ~algo内から，
( %複製, %node, %文書, %子も~cloneする~flag ~IN { `子も~cloneする^i, ε }（省略時は ε ） )
を渡して呼出される。
◎
Specifications may define cloning steps for all or some nodes. The algorithm is passed copy, node, document, and an optional clone children flag, as indicated in the clone algorithm.
</p>

<p class="note">注記：
~HTMLは
`script$e ／ `input$e
要素~用に`~clone時の手続き$を定義する。
~SVGもその `script^e 要素~用にも同様にされるべきだが、現時点では，呼び出すことはない。
◎
HTML defines cloning steps for script and input elements. SVG ought to do the same for its script elements, but does not call this out at the moment.
</p>

<p class="trans-note">【
同じ~node用に，そのような手続きが（例えば，複数の仕様にて）複数~定義された場合、それらを走らす順序も有意になり得るが，言及されていないので想定されていないと思われる。
】</p>

<p class="algo-head">
`~nodeを~cloneする@
ときは、所与の
( %node, `文書$ %文書 （省略時は ε ）, %子も~cloneする~flag ~IN { `子も~cloneする^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To clone a node, with an optional document and clone children flag, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 ~EQ ε
］
⇒
%文書 ~LET %node の`~node文書$
◎
If document is not given, let document be node’s node document.
</li>
	<li>
<p>
~IF［
%node は`要素$である
］：
◎
If node is an element, then:
</p>
		<ol>
			<li>
%複製 ~LET
`要素を作成する$( %文書, %node の`局所~名$, %node の`~ns$, %node の`~ns接頭辞$, %node の`~is0値$ )
◎
Let copy be the result of creating an element, given document, node’s local name, node’s namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements flag unset. 
</li>
			<li>
%node の`属性o~list$内の~EACH ( %属性o ) に対し
⇒
%複製 に`属性oを付加する$( `~nodeを~cloneする$( %属性o ) )
◎
For each attribute in node’s attribute list:
• Let copyAttribute be a clone of attribute.
• Append copyAttribute to copy.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
		<ol>
			<li>
%複製 ~LET %node と同じ~ifcを実装する新たな`~node$
◎
let copy be a node that implements the same interfaces as node, and＼
</li>
			<li>
<p>
%node に応じて， %複製 を次に従って設定する：
◎
fulfills these additional requirements, switching on node:
</p>
				<dl class="switch">
					<dt>$Document</dt>
					<dd>
%複製 の［
`符号化法$doc, `内容~型$doc, `~URL$doc, `生成元$doc, `種別$doc, `~mode$doc
］ ~SET %node のそれら
◎
Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.
</dd>

					<dt>$DocumentType</dt>
					<dd>
%複製 の［
`名前$dT,
`~publicID$dT,
`~systemID$dT
］ ~SET %node のそれら
◎
Set copy’s name, public ID, and system ID, to those of node.
</dd>

					<dt>$Attr</dt>
					<dd>
%複製 の［
`~ns$a,
`~ns接頭辞$a,
`局所~名$a,
`値$a
］ ~SET %node のそれら
◎
Set copy’s namespace, namespace prefix, local name, and value, to those of node.
</dd>

					<dt>$Text</dt>
					<dt>$Comment</dt>
					<dd>
%複製 の`~data$ ~SET %node のそれ
◎
Set copy’s data, to that of node.
</dd>

					<dt>$ProcessingInstruction</dt>
					<dd>
%複製 の［
`~target$pI,
`~data$
］ ~SET %node のそれら
◎
Set copy’s target and data to those of node.
</dd>

					<dt>他の~node</dt>
					<dd>
—
</dd>
					<dd class="trans-note">【
すなわち， $DocumentFragment （ $ShadowRoot ）が該当するが、［
これらに対しこの~algoが呼出されることはない
］ことを意味すると思われる。
】</dd>
				</dl>
			</li>
		</ol>
	<li>
~IF［
%複製 は`文書$である
］
⇒
%文書 ~SET %複製
◎
↓</li>
	<li>
%複製 の`~node文書$ ~SET %文書
◎
Set copy’s node document and document to copy, if copy is a document, and set copy’s node document to document otherwise.
</li>
	<li>
~IF［
他の`適用-可能な仕様$において %node 用に定義されている`~clone時の手続き$がある
］
⇒
その手続きに
( %複製, %node, %文書, `子も~cloneする^i )
を渡して走らす
◎
Run any cloning steps defined for node in other applicable specifications and pass copy, node, document and the clone children flag if set, as parameters.
</li>
	<li>
~IF［
%子も~cloneする~flag ~NEQ ε
］
⇒
%node の~EACH ( `子$ %子 ) に対し
【木~順序で】
⇒
%複製 に次を付加する
⇒
`~nodeを~cloneする$( %子, %文書, `子も~cloneする^i )
◎
If the clone children flag is set, clone all the children of node and append them to copy, with document as specified and the clone children flag being set.
</li>
	<li>
~RET %複製
◎
Return copy.
</li>
</ol>


<dl class="idl-def">
	<dt>@cloneNode(deep)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The cloneNode(deep) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れは`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If context object is a shadow root, then throw a "NotSupportedError" DOMException.
</li>
			<li>
~RET `~nodeを~cloneする$( 此れ, ε, ［
%deep ~EQ ~T ならば `子も~cloneする^i ／
~ELSE_ ε
］ )
◎
Return a clone of the context object, with the clone children flag set if deep is true.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
2 つの`~node$ %A, %B は、次に挙げるすべての条件を満たすならば，
`同等@
であるとされる。
◎
A node A equals a node B if all of the following conditions are true:
</p>

<ul>
	<li>
%A と %B の $nodeType 属性~値は一致する。
◎
A and B’s nodeType attribute value is identical.
</li>
	<li>
<p>
%A に応じて，次も同等：
◎
The following are also equal, depending on A:
</p>

		<dl class="switch">
			<dt>$DocumentType</dt>
			<dd>
`名前$dT,
`~publicID$dT,
`~systemID$dT
◎
Its name, public ID, and system ID.
</dd>

			<dt>$Element</dt>
			<dd>
`~ns$,
`~ns接頭辞$,
`局所~名$,
`属性o~list$の`~size$
◎
Its namespace, namespace prefix, local name, and its attribute list’s size.
</dd>

			<dt>$Attr</dt>
			<dd>
`~ns$a,
`局所~名$a,
`値$a
◎
Its namespace, local name, and value.
</dd>

			<dt>$ProcessingInstruction</dt>
			<dd>
`~target$pI,
`~data$
◎
Its target and data.
</dd>

			<dt>$Text</dt>
			<dt>$Comment</dt>
			<dd>
`~data$
◎
Its data.
</dd>

<!-- 他の~node -->
			<dt>その他</dt>
			<dd>
—
</dd>
	<dd class="trans-note">【
すなわち，［
$Document, $DocumentFragment （ $ShadowRoot ）
］が該当するが、［
これらに対しこの~algoが呼出されることはない
］ことを意味すると思われる。
<!-- ＊ isEqualNode -->
】</dd>

		</dl>
	</li>
	<li>
%A が`要素$である場合に限り
⇒
%A が`有する$どの`属性o$ %属性 に対しても
⇒
%B は［
%属性 に`同等$である`属性o$
］を`有する$
◎
If A is an element, each attribute in its attribute list has an attribute that equals an attribute in B’s attribute list.
</li>
<li>
%A と %B は同じ個数の`子$を持つ
◎
A and B have the same number of children.
</li>
<li>
%A のどの`子$も，同じ`指数$に位置する %B の`子$に`同等$である
◎
Each child of A equals the child of B at the identical index.
</li>
</ul>


<dl class="idl-def">
	<dt>@isEqualNode(otherNode)</dt>
	<dd>
被呼出時には、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
［
%otherNode ~NEQ ~NULL
］~AND［
此れと %otherNode は`同等$である
］
◎
The isEqualNode(otherNode) method, when invoked, must return true if otherNode is non-null and context object equals otherNode, and false otherwise.
</dd>

	<dt>@isSameNode(otherNode)</dt>
	<dd>
被呼出時には、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
%otherNode ~EQ 此れ
◎
The isSameNode(otherNode) method, when invoked, must return true if otherNode is context object, and false otherwise.
</dd>

</dl>


<!-- ADD %node →<code >%node</code> -->
<dl class="domintro">
	<dt>%node . $compareDocumentPosition(other)</dt>
	<dd>

<p>
%node に相対的な %other の位置を指示する~bitmaskを返す。
それを成す各~bitは、対応する条件が満たされる場合には， “1” に設定される：
◎
Returns a bitmask indicating the position of other relative to node. These are the bits that can be set:
</p>

		<dl>
			<dt>$Node . $DOCUMENT_POSITION_DISCONNECTED `(1)^i</dt>
			<dd>
%node と %other は同じ`木$に属さない。
◎
Set when node and other are not in the same tree.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_PRECEDING `(2)^i</dt>
			<dd>
%other は %node に`先行-$する。
◎
Set when other is preceding node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_FOLLOWING `(4)^i</dt>
			<dd>
%other は %node に`後続-$する。
◎
Set when other is following node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINS `(8)^i</dt>
			<dd>
%other は %node の`先祖$である。
◎
Set when other is an ancestor of node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINED_BY `(16)^i</dt>
			<dd>
%other は %node の`子孫$である。
◎
Set when other is a descendant of node.
</dd>
		</dl>
	</dd>

	<dt>%node . $contains(other)</dt>
	<dd>
%other が %node の`広義子孫$ならば ~T,
他の場合は~F を返す。
◎
Returns true if other is an inclusive descendant of node, and false otherwise.
</dd>
</dl>

<p class="idl-def">
次のものは
$compareDocumentPosition()
が~bitmaskとして返す定数である（括弧内は数値）：
◎
These are the constants compareDocumentPosition() returns as mask:
</p>

<ul><li>@DOCUMENT_POSITION_DISCONNECTED (1)
</li><li>@DOCUMENT_POSITION_PRECEDING (2)
</li><li>@DOCUMENT_POSITION_FOLLOWING (4)
</li><li>@DOCUMENT_POSITION_CONTAINS (8)
</li><li>@DOCUMENT_POSITION_CONTAINED_BY (16 ~EQ 0x10)
</li><li>@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC (32 ~EQ 0x20)
</li></ul>


<dl class="idl-def">
	<dt>@compareDocumentPosition(other)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The compareDocumentPosition(other) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れ ~EQ %other
］
⇒
~RET 0
◎
If context object is other, then return zero.
</li>
			<li>
( %他~node, %自~node ) ~LET ( %other, 此れ )
◎
Let node1 be other and node2 be context object.
</li>
			<li>
( %他~属性o, %自~属性o ) ~LET ( ~NULL, ~NULL )
◎
Let attr1 and attr2 be null.
</li>
			<li>
~IF［
%他~node は`属性o$である
］
⇒＃
%他~属性o ~SET %他~node；
%他~node ~SET %他~属性o が`属する要素$
◎
If node1 is an attribute, then set attr1 to node1 and node1 to attr1’s element.
</li>
			<li>
<p>
~IF［
%自~node は`属性o$である
］：
◎
If node2 is an attribute, then:
</p>
				<ol>
					<li>
%自~属性o ~SET %自~node
◎
↓</li>
					<li>
%自~node ~SET %自~属性o が`属する要素$
◎
Set attr2 to node2 and node2 to attr2’s element.
</li>
					<li>
<p>
~IF［
%他~属性o ~NEQ ~NULL
］~AND［
%自~属性o ~NEQ ~NULL
］~AND［
%自~node ~EQ %他~node
］：
◎
If attr1 and node1 are non-null, and node2 is node1, then:
</p>
						<ol>
							<li>
<p>
%自~node の`属性o~list$内の ~EACH ( %属性o ) に対し：
◎
For each attr in node2’s attribute list:
</p>
								<ol>
									<li>
~IF［
( %属性o, %他~属性o )
は`同等$である
］
⇒
~RET 
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_PRECEDING
◎
If attr equals attr1, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.
</li>
									<li>
~IF［
( %属性o, %自~属性o )
は`同等$である
］
⇒
~RET
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_FOLLOWING
◎
If attr equals attr2, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%他~node ~EQ ~NULL
］~OR［
%自~node ~EQ ~NULL
］~OR［
%他~node の`根$ ~NEQ %自~node の`根$
］
⇒
~RET ［
$DOCUMENT_POSITION_DISCONNECTED ~PLUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS ［
$DOCUMENT_POSITION_PRECEDING または $DOCUMENT_POSITION_FOLLOWING
（ただし，いずれが~~選択されるかは一貫するものとする）］
］
◎
If node1 or node2 is null, or node1’s root is not node2’s root, then return the result of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.
</p>

<p class="note">注記：
$DOCUMENT_POSITION_PRECEDING, $DOCUMENT_POSITION_FOLLOWING
のいずれを返値に用いるかは，概して~pointer比較により行われる。
~JS実装においては `Math.random()^c 値を利用できる。
【理想的には、各~node木どうしの順序も循環しないように一貫するべきであろう。】
◎
Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is typically implemented via pointer comparison. In JavaScript implementations a cached Math.random() value can be used.
</p>

			</li>
			<li>
~IF［［
%他~node は %自~node の`先祖$である
］~AND［
%他~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%自~属性o ~NEQ ~NULL
］］
⇒
~RET $DOCUMENT_POSITION_CONTAINS ~PLUS $DOCUMENT_POSITION_PRECEDING
◎
If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
</li>
			<li>
~IF［［
%他~node は %自~node の`子孫$である
］~AND［
%自~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%他~属性o ~NEQ ~NULL
］］
⇒
~RET 
$DOCUMENT_POSITION_CONTAINED_BY ~PLUS $DOCUMENT_POSITION_FOLLOWING
◎
If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
</li>
			<li>
<p>
~IF［
%他~node は %自~node に`先行-$する
］
⇒
~RET $DOCUMENT_POSITION_PRECEDING
◎
If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
</p>

<p class="note">
`属性o$は`木$に`関与-$しないが、この~algoに因り、`属性o$は，［
それを有する`要素$
］の`子$に`先行-$するものとされることになる。
◎
Due to the way attributes are handled in this algorithm this results in a node’s attributes counting as preceding that node’s children, despite attributes not participating in a tree.
</p>
			</li>
			<li>
~RET $DOCUMENT_POSITION_FOLLOWING
◎
Return DOCUMENT_POSITION_FOLLOWING.
</li>
		</ol>
	</dd>

	<dt>@contains(other)</dt>
	<dd>
被呼出時には、［
%other は此れの`広義子孫$であるならば ~T ／
~ELSE_（ %other ~EQ ~NULL の場合も含む） ~F
］を返さ~MUST。
◎
The contains(other) method, when invoked, must return true if other is an inclusive descendant of context object, and false otherwise (including when other is null).
</dd>
</dl>

<p class="algo-head">
%要素 用の
`~ns接頭辞を~locateする@
ときは、所与の
( %~ns )
に対し，次を走らす：
◎
To locate a namespace prefix for an element using namespace, run these steps:
</p>

<ol>
	<li>
~IF［
%要素 の`~ns$ ~EQ %~ns
］~AND［
%要素 の`~ns接頭辞$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~ns接頭辞$
◎
If element’s namespace is namespace and its namespace prefix is not null, then return its namespace prefix.
</li>
	<li>
%属性o ~LET %要素 が`有する$`属性o$のうち，次を満たす`最初のもの？$
⇒
［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`値$a ~EQ %~ns
］
◎
If element has an attribute whose namespace prefix is "xmlns" and value is namespace, then return element’s first such attribute’s local name.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
~RET %属性 の`局所~名$a
◎
↑</li>
	<li>
%親 ~SET %要素 の`親~要素$
◎
↓</li>
	<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
~RET %親 用の`~ns接頭辞を~locateする$( %~ns )
◎
If element’s parent element is not null, then return the result of running locate a namespace prefix on that element using namespace.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="algo-head">
%node 用の
`~nsを~locateする@
ときは、所与の
( %接頭辞 )
に対し，次を走らす：
◎
To locate a namespace for a node using prefix,＼
</p>

<ol>
	<li>
		<p>
%node に応じて：
◎
switch on node:
</p>

		<dl class="switch">
			<dt>$Element</dt><dd>
				<ol>
					<li>
~IF［
%node の`~ns$ ~NEQ ~NULL
］~AND［
%node の`~ns接頭辞$ ~EQ %接頭辞
］
⇒
~RET その`~ns$
◎
If its namespace is not null and its namespace prefix is prefix, then return namespace.
</li>
					<li>
<p>
%属性o ~LET %要素 が`有する$`属性o$のうち［
%接頭辞 に応じて，次に与える条件
］を満たす`最初のもの？$：
</p>

						<ul class="switch">
							<li>
%接頭辞 ~NEQ ~NULL の場合
⇒
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`局所~名$a ~EQ %接頭辞
］
</li>
							<li>
%接頭辞 ~EQ ~NULL の場合
⇒
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ ~NULL
］~AND［
`局所~名$a ~EQ `xmlns^l
］
</li>
						</ul>
◎
If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is "xmlns", and local name is prefix, or if prefix is null and it has an attribute whose namespace is the XMLNS namespace, namespace prefix is null, and local name is "xmlns",＼
</li>
					<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
~RET ［
%属性o の`値$a ~NEQ 空~文字列 ならばそれ ／
~ELSE_ ~NULL
］
◎
then return its value if it is not the empty string, and null otherwise.
</li>
					<li>
<p id="cp-ret-locate-ns">
%要素 ~LET %node の`親~要素$
◎
If its parent element is null, then return null.
◎
Return the result of running locate a namespace on its parent element using prefix.
</p>
					</li>
				</ol>
			</dd>

			<dt>$Document</dt>
			<dd>
%要素 ~LET %node の`文書~要素$
◎
If its document element is null, then return null.
◎
Return the result of running locate a namespace on its document element using prefix.
</dd>

			<dt>$DocumentType</dt>
			<dt>$DocumentFragment</dt>
			<dd>
~RET ~NULL
◎
Return null.
</dd>

			<dt>$Attr</dt>
			<dd>
%要素 ~LET %node が`属する要素$
◎
If its element is null, then return null.
◎
Return the result of running locate a namespace on its element using prefix.
</dd>

			<dt>
他の~node（`文字~data~node$）
◎
Any other node
</dt>
			<dd><!--cp-ret-locate-ns--></dd>
		</dl>
	</li>
	<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
~RET %要素 用の`~nsを~locateする$( %接頭辞 )
◎
↑</li>
	<li>
~RET ~NULL
◎
↑</li>
</ol>


<dl class="idl-def">
	<dt>@lookupPrefix(namespace)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The lookupPrefix(namespace) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%namespace ~IN { ~NULL, 空~文字列 }
］
⇒
~RET ~NULL
◎
If namespace is null or the empty string, then return null.
</li>
			<li>
<p>
%要素 ~LET 此れに応じて，次で与えられる［
要素, または ~NULL
］：
◎
Switch on the context object:
</p>
				<dl class="switch">
					<dt>$Element</dt>
					<dd>
此れ
◎
Return the result of locating a namespace prefix for it using namespace.
</dd>

					<dt>$Document</dt>
					<dd>
此れの`文書~要素$
◎
Return the result of locating a namespace prefix for its document element, if its document element is non-null, and null otherwise.
</dd>

					<dt>$DocumentType</dt>
					<dt>$DocumentFragment</dt>
					<dd>
~NULL
◎
Return null.
</dd>

					<dt>$Attr</dt>
					<dd>
此れが`属する要素$
◎
Return the result of locating a namespace prefix for its element, if its element is non-null, and null otherwise.
</dd>

					<dt>
他の~node（`文字~data~node$）
◎
Any other node
</dt>
					<dd>
此れの`親~要素$
◎
Return the result of locating a namespace prefix for its parent element, if its parent element is non-null, and null otherwise.
</dd>

				</dl>
			</li>
			<li>
~IF ［
%要素 ~NEQ ~NULL
］
⇒
~RET %要素 用の`~ns接頭辞を~locateする$( %namespace )
◎
↑</li>
			<li>
~RET ~NULL
◎
↑</li>
		</ol>
	</dd>

	<dt>@lookupNamespaceURI(prefix)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The lookupNamespaceURI(prefix) method, when invoked, must run these steps: 
</p>
		<ol>
			<li>
~IF［
%prefix ~EQ 空~文字列
］
⇒
%prefix ~SET ~NULL
◎
If prefix is the empty string, then set it to null.
</li>
			<li>
~RET 此れ用の`~nsを~locateする$( %prefix )
◎
Return the result of running locate a namespace for the context object using prefix.
</li>
		</ol>
	</dd>

	<dt>@isDefaultNamespace(namespace)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The isDefaultNamespace(namespace) method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-normalize-ns0">
~IF［
%namespace ~EQ 空~文字列
］
⇒
%namespace ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>
			<li>
%既定~ns ~LET 此れ用の`~nsを~locateする$( ~NULL )
◎
Let defaultNamespace be the result of running locate a namespace for context object using null.
</li>
			<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%既定~ns ~EQ %namespace
◎
Return true if defaultNamespace is the same as namespace, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>@insertBefore(node, child)</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
此れの中で`~nodeを子の前に前挿入する$( %node, %child )
◎
The insertBefore(node, child) method, when invoked, must return the result of pre-inserting node into context object before child.
</dd>
	<dd class="trans-note">【
~HTMLの `br^e のような空~要素であっても（あるいは `script^e 要素であっても）、子~nodeを挿入でき, 木の一部を成すことになる。
次の $appendChild() も同様。
】</dd>

	<dt>@appendChild(node)</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
此れに`~nodeを付加する$( %node )
◎
The appendChild(node) method, when invoked, must return the result of appending node to context object.
</dd>

	<dt>@replaceChild(node, child)</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
此れの中で`子を~nodeに置換する$( %child, %node )
◎
The replaceChild(node, child) method, when invoked, must return the result of replacing child with node within context object.
</dd>

	<dt>@removeChild(child)</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
此れから`子を前除去する$( %child )
◎
The removeChild(child) method, when invoked, must return the result of pre-removing child from context object.
</dd>
</dl>


<p class="algo-head">
`~node$ %根 に対する， %有修飾~名 を
`有修飾~名に持つ要素の~list@
とは、次のようにされた $HTMLCollection である
⇒＃
`根$cL ~SET %根,
`~filter$cLは［ %根 の`子孫$である`要素$ %要素 のうち，次を走らせた結果 ~EQ ~T になるもの ］に合致する：
◎
The list of elements with qualified name qualifiedName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<!-- ＊
局所~名 = * の場合でも、根は除外される
https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
-->

<ol>
	<li>
~IF［
%有修飾~名 ~EQ `*^l (U+002A)
］
⇒
~RET ~T
◎
If qualifiedName is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches only descendant elements.
</li>
	<li>
<p>
~IF［
%根 の`~node文書$は`~HTML文書$である
］
⇒
~RET［
%要素 は次のいずれかを満たすならば ~T ／
~ELSE_ ~F
］：
◎
Otherwise, if root’s node document is an HTML document, return a HTMLCollection rooted at root, whose filter matches the following descendant elements:
</p>
		<ul>
			<li>
［
`~ns$ ~EQ `~HTML~ns$
］~AND［
`有修飾~名$ ~EQ `~ASCII小文字~化する$( %有修飾~名 )
］
◎
Whose namespace is the HTML namespace and whose qualified name is qualifiedName, in ASCII lowercase.
</li>
				<li>
［
`~ns$ ~NEQ `~HTML~ns$
］~AND［
`有修飾~名$ ~EQ %有修飾~名
］
◎
Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.
</li>
		</ul>
	</li>
	<li>
~RET［
%要素 は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
`有修飾~名$ ~EQ %有修飾~名
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName.
</li>
</ol>

<p>
以前の~callと同じ引数で呼出されたときは、
%根 の`~node文書$の`種別$docが変化していない限り，そのときに返したものと同じ $HTMLCollection ~objを返してもよい。
◎
When invoked with the same argument, and as long as root’s node document’s type has not changed, the same HTMLCollection object may be returned as returned by an earlier call.
</p>

<p class="algo-head">
`~node$ %根 に対する，
( %~ns, %局所~名 )
を
`( ~ns, 局所~名 ) に持つ要素の~list@
とは、次のようにされた $HTMLCollection である
⇒＃
`根$cL ~SET %根,
`~filter$cLは［ %根 の`子孫$である`要素$ %要素 のうち，次を走らせた結果 ~EQ ~T になるもの ］に合致する：
◎
The list of elements with namespace namespace and local name localName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ol>
	<!--cp-normalize-ns-->
	<li>
%C ~LET `*^l (U+002A)
◎
↓</li>
	<li>
~IF［
%~ns ~EQ %C
］~AND［
%局所~名 ~EQ %C
］
⇒
~RET ~T
◎
If both namespace and localName are "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements.
</li>
	<li>
~IF［
%~ns ~EQ %C
］
⇒
~RET［
%要素 は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
`局所~名$ ~EQ %局所~名
◎
Otherwise, if namespace is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements whose local name is localName.
</li>
	<li>
~IF［
%局所~名 ~EQ %C
］
⇒
~RET［
%要素 は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
`~ns$ ~EQ %~ns
◎
Otherwise, if localName is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace.
</li>
	<li>
~RET［
%要素 は次を満たすならば ~T ／
~ELSE_ ~F
］
⇒
［
`~ns$ ~EQ %~ns
］~AND［
`局所~名$ ~EQ %局所~名
］
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace and local name is localName.
</li>
</ol>

<p id="cp-may-return-the-same">
以前の~callと同じ引数で呼出されたときは，そのときに返したものと同じ $HTMLCollection ~objを返してもよい。
◎
When invoked with the same argument, the same HTMLCollection object may be returned as returned by an earlier call.
</p>

<p class="algo-head">
`~node$ %根 に対する，
%classNames を
`~classesに含む要素の~list@
とは、次の~algoが返す $HTMLCollection である：
◎
The list of elements with class names classNames for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ol>
	<li>
%~classes ~LET
%classNames を`有順序~集合 構文解析器$にかけた結果
◎
Let classes be the result of running the ordered set parser on classNames.
</li>
	<li>
~IF［
%~classes は空である
］
⇒
~RET 空の $HTMLCollection
◎
If classes is the empty set, return an empty HTMLCollection.
</li>
	<li>
<p>
~RET 次のようにされた $HTMLCollection `~collection$
⇒
`根$cL ~SET %根,
`~filter$cLは［
%根 の`子孫$ %子孫 のうち，次を満たすもの
］に合致する
⇒
［
%子孫 は`要素$である
］~AND［
%子孫 の`~classes$は %~classes に含まれるすべての~tokenを含む
］
◎
Return a HTMLCollection rooted at root, whose filter matches descendant elements that have all their classes in classes.
</p>

<p>
`~classes$と %~classes の中の各~tokenの比較は、［
%根 の`~node文書$の`~mode$docが `quirks^l ならば `~ASCII大小無視$ ／
~ELSE_ `大小区別$
］で行われ~MUST。
◎
The comparisons for the classes must be done in an ASCII case-insensitive manner if root’s node document’s mode is "quirks", and in a case-sensitive manner otherwise.
</p>
	</li>
</ol>

<!--cp-may-return-the-same-->
		</section>
		<section id="interface-document">
<h3>4.5. ~ifc ^@Document</h3>

！！
[$Constructor,
 `Exposed$=Window]
interface @Document : $Node {
  [`SameObject$] ~RA $DOMImplementation $implementation;
  ~RA USVString $URL;
  ~RA USVString $documentURI;
  ~RA USVString $origin;
  ~RA ~DS $compatMode;
  ~RA ~DS $characterSet;
  ~RA ~DS $charset; // <span class="comment" id="cp-legacy-characterSet" title="historical alias of .characterSet">$characterSet の歴史上の別名</span>
  ~RA ~DS $inputEncoding; // <!--cp-legacy-characterSet-->
  ~RA ~DS $contentType;

  ~RA $DocumentType? $doctype;
  ~RA $Element? $documentElement;
  $HTMLCollection $getElementsByTagName(~DS %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS(~DS? %namespace, ~DS %localName);
  $HTMLCollection $getElementsByClassName(~DS %classNames);

  [`CEReactions$, `NewObject$] $Element $createElement(~DS %localName, optional (~DS or $ElementCreationOptions) %options);
  [`CEReactions$, `NewObject$] $Element $createElementNS(~DS? %namespace, ~DS %qualifiedName, optional (~DS or $ElementCreationOptions) %options);
  [`NewObject$] $DocumentFragment $createDocumentFragment();
  [`NewObject$] $Text $createTextNode(~DS %data);
  [`NewObject$] $CDATASection $createCDATASection(~DS %data);
  [`NewObject$] $Comment $createComment(~DS %data);
  [`NewObject$] $ProcessingInstruction $createProcessingInstruction(~DS %target, ~DS %data);

  [`CEReactions$, `NewObject$] $Node $importNode($Node %node, optional ~B %deep = false);
  [`CEReactions$] $Node $adoptNode($Node %node);

  [`NewObject$] $Attr $createAttribute(~DS %localName);
  [`NewObject$] $Attr $createAttributeNS(~DS? %namespace, ~DS %qualifiedName);

  [`NewObject$] $Event $createEvent(~DS %interface);

  [`NewObject$] $Range $createRange();

  // $NodeFilter<!---->.$NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [`NewObject$] $NodeIterator $createNodeIterator($Node %root, optional ~UL %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
  [`NewObject$] $TreeWalker $createTreeWalker($Node %root, optional ~UL %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
};

[`Exposed$=Window]
interface @XMLDocument : $Document {};

dictionary @@ElementCreationOptions {
  DOMString @is;
};
！

<!-- 
ElementCreationOptions:dictdef-elementcreationoptions
is:#dom-elementcreationoptions-is

 -->
<p>
$@Document `~node$は、単に
`文書@
（ `document^en ）とも称される。
◎
Document nodes are simply known as documents.
</p>


<div class="p">
<p>
各 `文書$には、次のものが結付けられる
— 他が言明されない限り，括弧内に示される値をとるとする：
</p>

<dl class="def-list">
	<dt>`符号化法@doc（ `utf-8$ ）</dt>
	<dd>
`符号化法$
</dd>
	<dt>`内容~型@doc（ `application/xml^l ）</dt>
	<dd>
文字列
</dd>
	<dt>`~URL@doc（ `about:blank^l †）</dt>
	<dd>
`~URL$
</dd>
	<dd class="trans-note">【†
厳密には、 `about:blank^l が表現する `~URL$ （文字列ではないので）。
】</dd>
	<dt>`生成元@doc（ `不透明な生成元$ ）</dt>
	<dd>
`生成元$
</dd>
	<dt>`種別@doc（ `xml^l ）</dt>
	<dd>
次のいずれか
⇒＃
`xml^l,
`html^l
</dd>
	<dt>`~mode@doc（ `no-quirks^l ）</dt>
	<dd>
次のいずれか
⇒＃
`no-quirks^l,
`quirks^l,
`limited-quirks^l
</dd>

</dl>

<p>
`ENCODING$r `URL$r `HTML$r
</p>

◎
Each document has an associated encoding (an encoding), content type (a string), URL (a URL), origin (an origin), type ("xml" or "html"), and mode ("no-quirks", "quirks", or "limited-quirks"). [ENCODING] [URL] [HTML]
◎
Unless stated otherwise, a document’s encoding is the utf-8 encoding, content type is "application/xml", URL is "about:blank", origin is an opaque origin, type is "xml", and its mode is "no-quirks".
</div>


<div class="p">
<p>
`文書$は、その`種別$docに応じて：
</p>

<ul><li>`xml^l ならば
`~XML文書@
であるとされる。
</li><li>`html^l ならば
`~HTML文書@
であるとされる。
</li></ul>

<p>
一部の~APIの挙動は、この 2 種のいずれであるかにより，影響される。
</p>
◎
A document is said to be an XML document if its type is "xml", and an HTML document otherwise. Whether a document is an HTML document or an XML document affects the behavior of certain APIs.
</div>



<div class="p">

<p>
`文書$は、その`~mode$docに応じて：
</p>

<ul ><li>`no-quirks^l ならば
`非過去互換~mode@
下にあるとされる。
</li><li>`quirks^l ならば
`過去互換~mode@
下にあるとされる。
</li><li>`limited-quirks^l ならば
`限定的互換~mode@
下にあるとされる。
</li></ul>
◎
A document is said to be in no-quirks mode if its mode is "no-quirks", quirks mode if its mode is "quirks", and limited-quirks mode if its mode is "limited-quirks".
</div>

<p class="note">注記：
~modeが既定の~modeから変更されるのは、`文書$が，新たな`閲覧文脈$（初期の `about:blank^l ）から，［
DOCTYPE 文字列の有無, およびその値
］に基づいて `~HTML構文解析器$を通して作成される場合に限られる。
`HTML$r
◎
The mode is only ever changed from the default for documents created by the HTML parser based on the presence, absence, or value of the DOCTYPE string, and by a new browsing context (initial "about:blank"). [HTML]
</p>

<p class="note">注記：
`非過去互換~mode$ は 元々 “標準~mode” と称され，
`限定的互換~mode$ は かつては “ほぼ標準~mode” と称されていた。
それらは今や標準により定義されたので（また、それらの元々の名称が的外れであることから Ian Hickson が否決したので）、改称された。
◎
No-quirks mode was originally known as "standards mode" and limited-quirks mode was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)
</p>

<div class="p">
<p class="algo-head">
`文書$ %文書 の`親~targetを取得する$ときは、所与の~event %~event に対し：
</p>

<ol>
	<li>
~IF［
%~event の $Event.type 属性~値 ~EQ `load^l
］~OR［
%文書 が`属する閲覧文脈$ ~EQ ε
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 に`関連する大域~obj$
</li>
</ol>

◎
A document’s get the parent algorithm, given an event, returns null if event’s type attribute value is "load" or document does not have a browsing context, and the document’s relevant global object otherwise. 
</div>

<hr>

<dl class="domintro">
	<dt>%document = new $Document()</dt>
	<dd>
新たな`文書$を返す。
◎
Returns a new document.
</dd>

	<dt>%document . $implementation</dt>
	<dd>
%document の $DOMImplementation ~objを返す。
◎
Returns document’s DOMImplementation object.
</dd>

	<dt>%document . $URL</dt>
	<dt>%document . $documentURI</dt>
	<dd>
%document の`~URL$doc を返す。
◎
Returns document’s URL.
</dd>


	<dt>%document . $origin</dt>
	<dd>
%document の`生成元$docを返す。
◎
Returns document’s origin.
</dd>

	<dt>%document . $compatMode</dt>
	<dd>
%document の`~mode$docが［
`quirks^l ならば文字列 `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返す。
◎
Returns the string "BackCompat" if document’s mode is "quirks", and "CSS1Compat" otherwise.
</dd>

	<dt>%document . $characterSet</dt>
	<dd>
%document の`符号化法$docを返す。
◎
Returns document’s encoding.
</dd>

	<dt>%document . $contentType</dt>
	<dd>
%document の`内容~型$docを返す。
◎
Returns document’s content type.
</dd>
</dl>





<dl class="idl-def">
	<dt>@Document()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた，新たな`文書$を返さ~MUST
⇒
`生成元$doc ~SET `現在の大域~obj$に`結付けられている文書$の`生成元$doc `HTML$r
◎
The Document() constructor, when invoked, must return a new document whose origin is the origin of current global object’s associated Document. [HTML]
</dd>

	<dd class="note">注記：
$DOMImplementation.createDocument() と違って、この構築子は
$XMLDocument ~objではなく，`文書$（ $Document ~obj）を返す。
◎
Unlike createDocument(), this constructor does not return an XMLDocument object, but a document (Document object).
</dd>

	<dt>@implementation</dt>
	<dd>
取得子は、此れ（`文書$）に結付けられている
$DOMImplementation ~objを返さ~MUST。
◎
The implementation attribute’s getter must return the DOMImplementation object that is associated with the document.
</dd>

	<dt>@URL</dt>
	<dt>@documentURI</dt>
	<dd>
これらのいずれも，取得子は、次を走らせた結果を返さ~MUST
⇒
`~URLを直列化する$( 此れの`~URL$doc )
◎
The URL attribute’s getter and documentURI attribute’s getter must return the URL, serialized.
</dd>

	<dt>@origin</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`生成元を直列化する$( 此れの`生成元$doc )
◎
The origin attribute’s getter must return the serialization of context object’s origin.
</dd>

	<dt>@compatMode</dt>
	<dd>
取得子は、此れの`~mode$docに応じて，次を返さ~MUST
⇒＃
`quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
◎
The compatMode attribute’s getter must return "BackCompat" if context object’s mode is "quirks", and "CSS1Compat" otherwise.
</dd>

	<dt>@characterSet</dt>
	<dt>@charset</dt>
	<dt>@inputEncoding</dt>
	<dd>
これらのいずれも，取得子は、此れの`符号化法$docの`名前$encを返さ~MUST。
◎
The characterSet attribute’s getter, charset attribute’s getter, and inputEncoding attribute’s getter, must return context object’s encoding’s name.
</dd>

	<dt>@contentType</dt>
	<dd>
取得子は、此れの`内容~型$docを返さ~MUST。
◎
The contentType attribute’s getter must return the content type.
</dd>
</dl>


<dl class="domintro">
	<dt>%document . $doctype</dt>
	<dd>
`~doctype$が［
在ればそれ ／
無ければ~NULL
］を返す。
◎
Returns the doctype or null if there is none.
</dd>

	<dt>%document . $documentElement</dt>
	<dd>
`文書~要素$を返す。
◎
Returns the document element.
</dd>

	<dt>%collection = %document . $getElementsByTagName(qualifiedName)</dt>
	<dd>
<p>
引数に応じて，次を満たす`子孫$`要素$すべてからなる $HTMLCollection を返す：
</p>
		<ul>
			<li>
%qualifiedName ~EQ `*^l の場合：
無条件。
</li>
			<li>
<p>
他の場合、次のいずれかを満たすもの：
</p>
				<ul>
					<li>
`有修飾~名$ ~EQ %qualifiedName
</li>
					<li>
［
`~HTML文書$ 内にある
］~AND［
`~HTML~ns$に属する
］~AND［
`有修飾~名$は %qualifiedName に~ASCII大小無視で合致する
］
</li>
				</ul>
			</li>
		</ul>
◎
If qualifiedName is "*" returns a HTMLCollection of all descendant elements.
◎
Otherwise, returns a HTMLCollection of all descendant elements whose qualified name is qualifiedName. (Matches case-insensitively against elements in the HTML namespace within an HTML document.)
</dd>

	<dt>%collection = %document . $getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
<p>
引数に応じて，次を満たす`子孫$`要素$すべてからなる $HTMLCollection を返す：
◎
↓</p>
		<ul>
			<li>
%namespace, %localName ともに `*^l の場合：
無条件。
◎
If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
</li>
			<li>
%namespace のみ `*^l の場合：
［
`局所~名$ ~EQ %localName
］なるもの。
◎
If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
</li>
			<li>
%localName のみ `*^l の場合：
［
`~ns$ ~EQ %namespace 
］なるもの。
◎
If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
</li>
			<li>
他の場合：
［
`~ns$ ~EQ %namespace
］~AND［
`局所~名$ ~EQ %localName
］なるもの。
◎
Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
</li>
		</ul>
	</dd>

	<dt>%collection = %document . $getElementsByClassName(classNames)</dt>
	<dt>%collection = %element . $Element.getElementsByClassName(classNames)</dt>
	<dd>
~methが呼出された~obj（`文書$または`要素$）内の`要素$のうち，［
%classNames で与えられる一連の~class名をすべて持つもの
］からなる $HTMLCollection を返す。
%classNames 引数は一連の~class名の~space区切り~listとして解釈される。
◎
Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes.
</dd>

</dl>


<dl class="idl-def">
	<dt>@doctype</dt>
	<dd>
取得子は、次を満たす~nodeのうち，`最初のもの？$を返さ~MUST
⇒
［
此れの`子$である
］~AND［
`~doctype$である
］
◎
The doctype attribute’s getter must return the child of the document that is a doctype, and null otherwise.
</dd>

	<dt>@documentElement</dt>
	<dd>
取得子は、此れの`文書~要素$を返さ~MUST。
◎
The documentElement attribute’s getter must return the document element.
</dd>

	<dt>@getElementsByTagName(qualifiedName)</dt>
	<dd>
被呼出時には、此れに対する， %qualifiedName を`有修飾~名に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagName(qualifiedName) method, when invoked, must return the list of elements with qualified name qualifiedName for the context object.
</dd>
	<dd class="note">注記：
したがって，`~HTML文書$においては、
`document.getElementsByTagName("FOO")^c は
`~HTML~ns$に属さない `FOO^e 要素と
`~HTML~ns$に属する `foo^e 要素に合致し，
`~HTML~ns$に属する `FOO^e 要素には合致しないことになる。
◎
Thus, in an HTML document, document.getElementsByTagName("FOO") will match &lt;FOO&gt; elements that are not in the HTML namespace, and &lt;foo&gt; elements that are in the HTML namespace, but not &lt;FOO&gt; elements that are in the HTML namespace.
</dd>

	<dt>@getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
被呼出時には、此れに対する，
( %namespace, %localName ) を
`( ~ns, 局所~名 ) に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagNameNS(namespace, localName) method, when invoked, must return the list of elements with namespace namespace and local name localName for the context object.
</dd>

	<dt>@getElementsByClassName(classNames)</dt>
	<dd>
被呼出時には、此れに対する，
%classNames を`~classesに含む要素の~list$を返さ~MUST。
◎
The getElementsByClassName(classNames) method, when invoked, must return the list of elements with class names classNames for the context object.
	</dd>
	<dd class="example">
<p>
次の XHTML 片が与えられたとする：
◎
Given the following XHTML fragment:
</p>

<pre class="html-code">
&lt;div id="example"&gt;
  &lt;p id="<mark>p1</mark>" class="aaa bbb"/&gt;
  &lt;p id="<mark>p2</mark>" class="aaa ccc"/&gt;
  &lt;p id="<mark>p3</mark>" class="bbb ccc"/&gt;
&lt;/div&gt;
</pre>

<p>
<samp>document.getElementById(`example^l).getElementsByClassName(`aaa^l)</samp>
の~callは、その中の 2 個の paragraph 
<mark>p1</mark> と <mark>p2</mark> からなる
$HTMLCollection を返すことになる。
◎
A call to document.getElementById("example").getElementsByClassName("aaa") would return a HTMLCollection with the two paragraphs p1 and p2 in it.
</p>

<p>
一方で，
<samp>getElementsByClassName(`ccc&nbsp;bbb^l)</samp>
の~callは
その中の 1 個の~node <mark>p3</mark> のみを返すことになる。
<samp>document.getElementById(`example^l).getElementsByClassName(`bbb&nbsp;&nbsp;&nbsp;ccc&nbsp;^l)</samp>
の~callも同じものを返すことになる。
◎
A call to getElementsByClassName("ccc bbb") would only return one node, however, namely p3. A call to document.getElementById("example").getElementsByClassName("bbb ccc ") would return the same thing.
</p>

<p>
<samp>getElementsByClassName(`aaa,bbb^l)</samp>
の~callは 1 個の~nodeも返さない。
上のどの要素も `aaa,bbb^c ~classに属さない。
◎
A call to getElementsByClassName("aaa,bbb") would return no nodes; none of the elements above are in the aaa,bbb class.
</p>
	</dd>
</dl>


<dl class="domintro">
	<dt>%element = %document . $createElement(localName [, options])</dt>
	<dd>
`局所~名$が %localName であるような，`要素$を返す（ %document が`~HTML文書$である場合， %localName は小文字~化される）。
`要素$の`~ns$は，［
次のいずれかに該当する場合は`~HTML~ns$ ／
他の場合は ~NULL
］になる
⇒＃
%document は`~HTML文書$である ／
%document の`内容~型$doc ~EQ `application/xhtml+xml^l
◎
Returns an element with localName as local name (if document is an HTML document, localName gets lowercased). The element’s namespace is the HTML namespace when document is an HTML document or document’s content type is "application/xhtml+xml", and null otherwise.
</dd>
	<dd>
%localName が `Name$prod 生成規則に合致しない場合，
`InvalidCharacterError$E 例外が投出される。
◎
If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
</dd>
	<dd id="cp-supplied-is-mb">
%options の $ElementCreationOptions.is を利用して，`~custom化された組込みの要素$を作成できる。
◎
When supplied, options’s is can be used to create a customized built-in element.
</dd>

	<dt>%element = %document . $createElementNS(namespace, qualifiedName [, options])</dt>
	<dd>
`~ns$ %namespace に属するような，新たな`要素$を返す。
その ( `~ns接頭辞$, `局所~名$ ) は、順に次のようにされる
⇒＃
%qualifiedName が `:^l (U+003A) を含むならば それを挟んだ ( 前, 後 ) の部分 ／
他の場合は ( ~NULL, %qualifiedName )
◎
Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
</dd>
	<dd>
%qualifiedName が `Name$prod 生成規則に合致しない場合，
`InvalidCharacterError$E 例外が投出される。
◎
If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
</dd>

<!-- *localName -->
	<dd>
次のいずれかに該当する場合，
`NamespaceError$E 例外が投出される
⇒＃
%localName は `QName$prod 生成規則に合致しない ／
%namespace は空~文字列であるのに，`~ns接頭辞$は~NULL でない ／
%namespace は`~XML~ns$でないのに，`~ns接頭辞$は `xml^l である ／
%namespace は`~XMLNS~ns$でないのに， %qualifiedName または`~ns接頭辞$は `xmlns^l である ／
%namespace は`~XMLNS~ns$であるのに， %qualifiedName も`~ns接頭辞$も `xmlns^l でない
◎
If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
◎
localName does not match the QName production.
◎
Namespace prefix is not null and namespace is the empty string.
◎
Namespace prefix is "xml" and namespace is not the XML namespace.
◎
qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
◎
namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
</dd>
	<!--cp-supplied-is-mb-->

	<dt>%documentFragment = %document . $createDocumentFragment()</dt>
	<dd>
$DocumentFragment `~node$を返す。
◎
Returns a DocumentFragment node.
</dd>

	<dt>%text = %document . $createTextNode(data)</dt>
	<dd>
新たな $Text `~node$を返す
— その`~data$は %data にされる。
◎
Returns a Text node whose data is data.
</dd>

	<dt>%text = %document . $createCDATASection(data)</dt>
	<dd>
新たな $CDATASection `~node$を返す
— その`~data$は %data にされる。
◎
Returns a CDATASection node whose data is data.
</dd>

	<dt>%comment = %document . $createComment(data)</dt>
	<dd>
新たな $Comment `~node$を返す
— その`~data$は %data にされる。
◎
Returns a Comment node whose data is data.
</dd>


	<dt>%processingInstruction = %document . $createProcessingInstruction(target, data)</dt>
	<dd>
新たな $ProcessingInstruction `~node$を返す
— その $target は %target にされ, `~data$は %data にされる。
◎
Returns a ProcessingInstruction node whose target is target and data is data.＼
</dd>
	<dd>
次のいずれかに該当する場合，
`InvalidCharacterError$E 例外が投出される
⇒＃
%target は `Name$prod 生成規則に合致しない ／
%data は `?&gt;^l を含んでいる
◎
If target does not match the Name production an "InvalidCharacterError" DOMException will be thrown. If data contains "?&gt;" an "InvalidCharacterError" DOMException will be thrown.
</dd>
</dl>

<p>
他が言明されない限り，所与の
( 局所~名, ~ns )
用の
`要素~ifc@
は、 $Element とする。
◎
The element interface for any name and namespace is Element, unless stated otherwise.
</p>

<p class="note">注記：
例えば，~HTML標準は、
( `html$e, `~HTML~ns$ )
用のそれを， $HTMLHtmlElement ~ifcと定義している。
`HTML$r
◎
The HTML Standard will e.g. define that for html and the HTML namespace, the HTMLHtmlElement interface is used. [HTML] 
</p>


<dl class="idl-def">
	<dt>@createElement(localName, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createElement(localName, options) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%localName は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName does not match the Name production, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~IF［
此れは`~HTML文書$ である
］
⇒
%localName ~SET `~ASCII小文字~化する$( %localName )
◎
If the context object is an HTML document, then set localName to localName in ASCII lowercase.
</li>
			<li id="cp-let-is">
%is ~LET ［［
%options は`辞書$である
］~AND［
%options に $ElementCreationOptions.is ~memberは在る
］ならば その~memberの値 ／
~ELSE_ ~NULL
］
◎
Let is be null.
◎
If options is a dictionary and options’s is is present, then set is to it.
</li>
			<li>
%~ns ~LET ［
次が満たされるならば `~HTML~ns$ ／
~ELSE_ ~NULL
］
⇒
［
此れは`~HTML文書$である
］~OR［
此れの`内容~型$doc ~EQ `application/xhtml+xml^l
］
◎
Let namespace be the HTML namespace, if the context object is an HTML document or context object’s content type is "application/xhtml+xml", and null otherwise.
</li>
			<li>
~RET
`要素を作成する$( 此れ, %localName, %~ns, ~NULL, %is, `同期~custom要素^i )
◎
Return the result of creating an element given the context object, localName, namespace, null, is, and with the synchronous custom elements flag set.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`内的 createElementNS 手続き@
は、所与の
( %文書, %namespace, %qualifiedName, %options )
に対し，次を走らす：
◎
The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as follows:
</p>

<ol>
	<li id="cp-validate-and-extract">
( %~ns, %接頭辞, %局所~名 ) ~LET
`検証して抽出する$( %namespace, %qualifiedName )
◎
Let namespace, prefix, and localName be the result of passing namespace and qualifiedName to validate and extract.
</li>
	<!--cp-let-is-->
	<li>
~RET
`要素を作成する$( %文書, %局所~名, %~ns, %接頭辞, %is, `同期~custom要素^i )
◎
Return the result of creating an element given document, localName, namespace, prefix, is, and with the synchronous custom elements flag set.
</li>
</ol>


<dl class="idl-def">
	<dt>@createElementNS(namespace, qualifiedName, options)</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
`内的 createElementNS 手続き$( 此れ, %namespace, %qualifiedName, %options )
◎
The createElementNS(namespace, qualifiedName, options) method, when invoked, must return the result of running the internal createElementNS steps, given context object, namespace, qualifiedName, and options.
</dd>
	<dd class="note">注記：
~web互換性のため、［
$createElement() ／ $createElementNS()
］の %options 引数には文字列も許容される【無視されることになる】。
◎
createElement() and createElementNS()'s options parameter is allowed to be a string for web compatibility.
</dd>

	<dt>@createDocumentFragment()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`文書片$を返さ~MUST
⇒
`~node文書$ ~SET 此れ
◎
The createDocumentFragment() method, when invoked, must return a new DocumentFragment node with its node document set to the context object.
</dd>

	<dt>@createTextNode(data)</dt>
	<dd>
被呼出時には、
`新たな~Text~node$( %data, 此れ )
を返さ~MUST
◎
The createTextNode(data) method, when invoked, must return a new Text node with its data set to data and node document set to the context object.
</dd>
	<dd class="note">注記：
［
%data が `Char$prod 生成規則に合致しない文字を含む
］かどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production.
</dd>

	<dt>@createCDATASection(data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createCDATASection(data) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れは`~HTML文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If context object is an HTML document, then throw a "NotSupportedError" DOMException.
</li>
			<li>
~IF［
%data は文字列 `]]&gt;^l を包含する
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains the string "]]&gt;", then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~RET 次のようにされた，新たな $CDATASection `~node$
⇒
( `~data$, `~node文書$ ) ~SET ( %data, 此れ )
◎
Return a new CDATASection node with its data set to data and node document set to the context object.
</li>
		</ol>
	</dd>

	<dt>@createComment(data)</dt>
	<dd>
被呼出時には、次のように設定された 新たな $Comment `~node$を返さ~MUST
⇒
( `~data$, `~node文書$ ) ~SET ( %data, 此れ )
◎
The createComment(data) method, when invoked, must return a new Comment node with its data set to data and node document set to the context object.
	</dd>
	<dd class="note">注記：
%data が［
`Char$prod 生成規則に合致しない文字を含む ／
連続する 2 個の~hyphen（ "--" ）を含む ／
~hyphenで終わる
］かどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production or that it contains two adjacent hyphens or ends with a hyphen.
</dd>

	<dt>@createProcessingInstruction(target, data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createProcessingInstruction(target, data) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%target は
<!--<code data-anolis-spec=xml>PITarget</code>-->
`Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
<!-- DOM3 does not check for "xml" -->
◎
If target does not match the Name production, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~IF［
%data は文字列 `?&gt;^l を含む
］
⇒
~THROW `InvalidCharacterError$E
<!-- Gecko does this. -->
◎
If data contains the string "?&gt;", then throw an "InvalidCharacterError" DOMException.
</li>
<!--<li>
<p>If <var title>target</var> contains a U+003A COLON (":")
 character, <span data-anolis-spec=webidl>throw</span> a
<code title>NamespaceError</code> exception.-->
<!-- DOM3 didn’t check this -->
			<li>
~RET 
次のように設定された 新たな $ProcessingInstruction `~node$
⇒
( $ProcessingInstruction.target, `~data$, `~node文書$ )
~SET
( %target, %data, 此れ )
◎
Return a new ProcessingInstruction node, with target set to target, data set to data, and node document set to the context object.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
［
%target が `xml^l または `:^l を含む ／
%data が `Char$prod 生成規則に合致しない文字を含む
］かどうかは、検査されない。
◎
No check is performed that target contains "xml" or ":", or that data contains characters that match the Char production.
</dd>
</dl>


<dl class="domintro">
	<dt>%clone = %document . $importNode(node [, deep = false])</dt>
	<dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>
	<dd>
%node が`文書$または`~shadow根$である場合，
`NotSupportedError$E 例外が投出される。
◎
If node is a document or a shadow root, throws a "NotSupportedError" DOMException.
</dd>

	<dt>%node = %document . $adoptNode(node)</dt>
	<dd>
%node を他の`文書$から移動させた上で，それを返す。
◎
Moves node from another document and returns it.
</dd>
	<dd>
%node が`文書$である場合，
`NotSupportedError$E 例外が投出される。
%node が`~shadow根$である場合，
`HierarchyRequestError$E 例外が投出される。
◎
If node is a document, throws a "NotSupportedError" DOMException or, if node is a shadow root, throws a "HierarchyRequestError" DOMException.
</dd>
</dl>

<dl class="idl-def">
	<dt>@importNode(node, deep)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The importNode(node, deep) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node は `文書$または`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document or shadow root, then throw a "NotSupportedError" DOMException.
</li>
			<li>
~RET `~nodeを~cloneする$( %node, 此れ, ［
%deep ~EQ ~T ならば `子も~cloneする^i ／
~ELSE_ ε
］ )
◎
Return a clone of node, with context object and the clone children flag set if deep is true.
</li>
		</ol>
	</dd>
</dl>

<p>
`適用-可能な仕様$は、すべてまたは一部の`~node$用に
`受入-時の手続き@
を定義しても~MAY。
この~algoは、`~nodeを受入する$~algo内から，
( `~node$, `文書$ )
を渡して呼出される。
◎
Specifications may define adopting steps for all or some nodes. The algorithm is passed node and oldDocument, as indicated in the adopt algorithm.
</p>

<p class="algo-head">
%文書 に
`~nodeを受入する@
ときは、所与の
( %node )
に対し，次を走らす：
◎
To adopt a node into a document, run these steps:
</p>

<ol>
	<li>
%旧-文書 ~LET %node の`~node文書$
◎
Let oldDocument be node’s node document.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node の`親$から`子を除去する$( %node )
◎
If node’s parent is not null, remove node from its parent.
</li>
	<li>
<p>
~IF［
%文書 ~NEQ %旧-文書
］：
◎
If document is not oldDocument, then:
</p>
		<ol>
			<li>
<p>
%node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants:
</p>
				<ol>
					<li>
%広義子孫 の`~node文書$ ~SET %文書
◎
Set inclusiveDescendant’s node document to document.
</li>
					<li>
~IF［
%広義子孫 は`要素$である
］
⇒
%広義子孫 の`属性o~list$内の~EACH ( %属性o ) に対し
⇒
%属性o の`~node文書$ ~SET %文書
◎
If inclusiveDescendant is an element, then set the node document of each attribute in inclusiveDescendant’s attribute list to document.
</li>
				</ol>
			</li>
			<li>
%node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し
⇒
~IF［
%広義子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%広義子孫,
`adoptedCallback^l,
« %旧-文書, %文書 »
)
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants that is custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name "adoptedCallback", and an argument list containing oldDocument and document.
</li>
			<li>
%node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し，`~shadowも含む木~順序$で
⇒
`受入-時の手続き$に
( %広義子孫, %旧-文書 )
を渡して走らす
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants, in shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@adoptNode(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The adoptNode(node) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node は`文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document, then throw a "NotSupportedError" DOMException.
</li>
			<li>
~IF［
%node は`~shadow根$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a shadow root, then throw a "HierarchyRequestError" DOMException.
</li>
			<li>
此れに`~nodeを受入する$( %node )
◎
Adopt node into the context object.
</li>
			<li>
~RET %node
◎
Return node.
</li>
		</ol>
	</dd>

	<dt>@createAttribute(localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createAttribute(localName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%localName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName does not match the Name production in XML, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~IF［
此れは`~HTML文書$である
］
⇒
%localName ~SET `~ASCII小文字~化する$( %localName )
◎
If the context object is an HTML document, then set localName to localName in ASCII lowercase.
</li>
			<li>
~RET 次のように設定された 新たな`属性o$
⇒＃
`局所~名$a ~SET %localName,
`~node文書$ ~SET 此れ
◎
Return a new attribute whose local name is localName and node document is context object.
</li>
		</ol>
	</dd>

	<dt>@createAttributeNS(namespace, qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createAttributeNS(namespace, qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-validate-and-extract-->
			<li>
~RET 次のように設定された 新たな`属性o$
⇒＃
`~ns$a ~SET %~ns,
`~ns接頭辞$a ~SET %接頭辞,
`局所~名$a ~SET %局所~名,
`~node文書$ ~SET 此れ
◎
Return a new attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, and node document is context object.
</li>
		</ol>
	</dd>

	<dt>@createEvent(interface)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createEvent(interface) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%構築子 ~LET ~NULL
◎
Let constructor be null.
</li>
			<li>
<p>
~IF［
%interface は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］
⇒
%構築子 ~SET ［
合致した行の 2 列目の~ifc
］の構築子
◎
If interface is an ASCII case-insensitive match for any of the strings in the first column in the following table, then set constructor to the interface in the second column on the same row as the matching string:
</p>

<table>
<thead><tr><th>文字列◎ String
<th>~ifc◎ Interface
<th>仕様（空欄はこの仕様）◎ Notes
</thead><tbody>

<tr><td>`beforeunloadevent^l
<td>$BeforeUnloadEvent
<td>`HTML$r

<tr><td>`compositionevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`customevent^l
<td>$CustomEvent
<td>

<tr><td>`devicemotionevent^l
<td>$DeviceMotionEvent
<td>`DEVICE-ORIENTATION$r

<tr><td>`deviceorientationevent^l
<td>$DeviceOrientationEvent
<td>同上

<tr><td>`dragevent^l
<td>$DragEvent
<td>`HTML$r

<tr><td>`event^l
<td>$Event
<td>

<tr><td>`events^l
<td>同上
<td>

<tr><td>`focusevent^l
<td>$FocusEvent
<td>`UIEVENTS$r

<tr><td>`hashchangeevent^l
<td>$HashChangeEvent
<td>`HTML$r

<tr><td>`htmlevents^l
<td>$Event
<td>

<tr><td>`keyboardevent^l
<td>$KeyboardEvent
<td>`UIEVENTS$r

<tr><td>`messageevent^l
<td>$MessageEvent
<td>`HTML$r

<tr><td>`mouseevent^l
<td>$MouseEvent
<td>`UIEVENTS$r

<tr><td>`mouseevents^l
<td>同上
<td>同上

<tr><td>`storageevent^l
<td>$StorageEvent
<td>`HTML$r

<tr><td>`svgevents^l
<td>$Event
<td>

<tr><td>`textevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`touchevent^l
<td>$TouchEvent
<td>`TOUCH-EVENTS$r

<tr><td>`uievent^l
<td>$UIEvent
<td>`UIEVENTS$r

<tr><td>`uievents^l
<td>同上
<td>同上

</tbody></table>

			</li>
			<li>
~IF［
%構築子 ~EQ ~NULL
］
⇒
~THROW `NotSupportedError$E
◎
If constructor is null, then throw a "NotSupportedError" DOMException.
</li>
			<li>
<p>
~IF［
%構築子 が指示する~ifcは，此れに`関連する大域~obj$に公開されていない
］
⇒
~THROW `NotSupportedError$E
◎
If the interface indicated by constructor is not exposed on the relevant global object of the context object, then throw a "NotSupportedError" DOMException.
</p>

<p class="note">注記：
概して~UAは、環境設定によっては，~touch~eventの~supportを不能化する
— その場合、この段が $TouchEvent ~ifc用に誘発されることになる。
◎
Typically user agents disable support for touch events in some configurations, in which case this clause would be triggered for the interface TouchEvent.
</p>
			</li>
			<li>
%~event ~LET `~eventを作成する$( %構築子 )
◎
Let event be the result of creating an event given constructor.
</li>
			<li>
%~event の $Event.type 属性 ~SET 空~文字列に初期化する
◎
Initialize event’s type attribute to the empty string.
</li>
			<li>
%~event の $Event.timeStamp 属性 ~SET ［
`時刻起点$から現在時までの高分解能な時間差
］を表現している $DOMHighResTimeStamp 値に初期化する
◎
Initialize event’s timeStamp attribute to a DOMHighResTimeStamp representing the high resolution time from the time origin to now.
</li>
			<li>
%event の $Event.isTrusted 属性 ~SET ~F に初期化する
◎
Initialize event’s isTrusted attribute to false.
</li>
			<li>
%~event の`初期化-済み$f ~SET ~OFF
◎
Unset event’s initialized flag.
</li>
			<li>
~RET %~event
◎
Return event.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
代わりに，`~event$構築子が利用されるべきである。
◎
Event constructors ought to be used instead.
</dd>

	<dt>@createRange()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`~live範囲o$を返さ~MUST
⇒＃
`始端$ ~SET `境界点$(此れ, 0) ,
`終端$ ~SET `境界点$(此れ, 0)
◎
The createRange() method, when invoked, must return a new live range with (context object, 0) as its start and end.
	</dd>
	<dd class="note">注記：
代わりに， $Range.Range() 構築子を利用できる。
◎
The Range() constructor can be used instead.
</dd>

	<dt>@createNodeIterator(root, whatToShow, filter)</dt>
	<dd>
被呼出時には、次のように設定された 新たな $NodeIterator ~objを返さ~MUST
⇒＃
`根$tV ~SET %root,
`起点$tV ~SET %root,
`起点の直前？$tV ~SET ~T,
`~whatToShow$tV ~SET %whatToShow,
`~filter~callback$tV ~SET %filter
◎
The createNodeIterator(root, whatToShow, filter) method, when invoked, must run these steps:
• Let iterator be a new NodeIterator object.
• Set iterator’s root and iterator’s reference to root.
• Set iterator’s pointer before reference to true.
• Set iterator’s whatToShow to whatToShow.
• Set iterator’s filter to filter.
• Return iterator.
</dd>

	<dt>@createTreeWalker(root, whatToShow, filter)</dt>
	<dd>
被呼出時には、次のように設定された 新たな $TreeWalker ~objを返さ~MUST
⇒＃
`根$tV ~SET %root,
`現-~node$tV ~SET %root,
`~whatToShow$tV ~SET %whatToShow,
`~filter~callback$tV ~SET %filter
◎
The createTreeWalker(root, whatToShow, filter) method, when invoked, must run these steps:
• Let walker be a new TreeWalker object.
• Set walker’s root and walker’s current to root.
• Set walker’s whatToShow to whatToShow.
• Set walker’s filter to filter.
• Return walker.
</dd>
</dl>
			<section id="interface-domimplementation">
<h4>4.5.1. ~ifc ^@DOMImplementation</h4>

<p>
~UA は、`文書$が作成された際には，
$DOMImplementation ~objを作成して, `文書$にそれを結付け~MUST。
◎
User agents must create a DOMImplementation object whenever a document is created and associate it with that document.
</p>

！！
[`Exposed$=Window]
interface @DOMImplementation {
  [`NewObject$] $DocumentType $createDocumentType(~DS qualifiedName, ~DS publicId, ~DS systemId);
  [`NewObject$] $XMLDocument $createDocument(~DS? %namespace, [`TreatNullAs$=EmptyString] ~DS %qualifiedName, optional $DocumentType? %doctype = null);
  [`NewObject$] $Document $createHTMLDocument(optional ~DS title);

  ~B $hasFeature(); // <span class="comment" id="cp-useless-true" title="useless; always returns true">無用の長物 — 常に true を返す</span>
};
！

<dl class="domintro">
	<dt>%doctype = %document . $Document.implementation . $createDocumentType(qualifiedName, publicId, systemId)</dt>
	<dd>
所与の［
%qualifiedName, %publicId, %systemId
］を伴う`~doctype$を返す。
%qualifiedName が［
`Name$prod 生成規則に合致しない場合は
`InvalidCharacterError$E 例外 ／
`QName$prod 生成規則に合致しない場合は
`NamespaceError$E 例外
］が投出される。
◎
Returns a doctype, with the given qualifiedName, publicId, and systemId. If qualifiedName does not match the Name production, an "InvalidCharacterError" DOMException is thrown, and if it does not match the QName production, a "NamespaceError" DOMException is thrown.
</dd>

	<dt>%doc = %document . $Document.implementation . $createDocument(namespace, qualifiedName [, doctype = null])</dt>
	<dd>
`局所~名$が %qualifiedName で`~ns$が %namespace （ %qualifiedName が空~文字列でなければ）の`文書~要素$を伴い，
%doctype が与えられていれば`~doctype$がそれに設定された
$XMLDocument を返す。
◎
Returns an XMLDocument, with a document element whose local name is qualifiedName and whose namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is given, as its doctype.
</dd>
	<dd>
この~methは、$Document.createElementNS() ~methと同じ例外を，
( %namespace, %qualifiedName )
で呼出したときに投出する。
◎
This method throws the same exceptions as the createElementNS() method, when invoked with namespace and qualifiedName.
</dd>

	<dt>%doc = %document . $Document.implementation . $createHTMLDocument([title])</dt>
	<dd>
基本~構造が構築-済みの`木$を伴う`文書$を返す。
%title 引数が省略されていなければ `title$e 要素も含められる。
◎
Returns a document, with a basic tree already constructed including a title element, unless the title argument is omitted.
</dd>
</dl>


<dl class="idl-def">
	<dt>@createDocumentType(qualifiedName, publicId, systemId)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createDocumentType(qualifiedName, publicId, systemId) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`有修飾~名として検証する$( %qualifiedName )
◎
Validate qualifiedName.
</li>
			<li>
~RET 次のように設定された 新たな`~doctype$
⇒＃
`名前$dT ~SET %qualifiedName,
`~publicID$dT ~SET %publicId,
`~systemID$dT ~SET %systemId,
`~node文書$ ~SET 此れに結付けられている`文書$
◎
Return a new doctype, with qualifiedName as its name, publicId as its public ID, and systemId as its system ID, and with its node document set to the associated document of the context object.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
［
%publicId を成す符号位置~並びが `PubidChar^prod 生成規則に合致しない ／
%systemId が文字 `"^l や `'^l を含む
］かどうかは、検査されない。
◎
No check is performed that publicId code points match the PubidChar production or that systemId does not contain both a '"' and a "'".
</dd>

	<dt>@createDocument(namespace, qualifiedName, doctype)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createDocument(namespace, qualifiedName, doctype) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%文書 ~LET 新たな $XMLDocument
◎
Let document be a new XMLDocument.
</li>
			<li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>
			<li>
~IF［
%qualifiedName ~NEQ 空~文字列
］
⇒
%要素 ~SET `内的 createElementNS 手続き$( 此れ, %namespace, %qualifiedName, 空~辞書 )
◎
If qualifiedName is not the empty string, then set element to the result of running the internal createElementNS steps, given document, namespace, qualifiedName, and an empty dictionary.
</li>
			<li>
~IF［
%doctype ~NEQ ~NULL
］
⇒
%文書 に`~nodeを付加する$( %doctype )
◎
If doctype is non-null, append doctype to document.
</li>
			<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%文書 に`~nodeを付加する$( %要素 )
◎
If element is non-null, append element to document.
</li>
			<li>
%文書 の`生成元$doc ~SET 此れに結付けられている`文書$の`生成元$doc
◎
document’s origin is context object’s associated document’s origin.
</li>
			<li>
<p>
%文書 の`内容~型$doc ~SET %~ns に応じて，次で与えられる値：
◎
document’s content type is determined by namespace:
</p>

<dl class="switch"
	><dt>`~HTML~ns$
</dt><dd>`application/xhtml+xml^c
</dd><dt>`~SVG~ns$
</dt><dd>`image/svg+xml^c
</dd><dt>他の~ns◎ Any other namespace
</dt><dd>`application/xml^c
</dd></dl>

			</li>
			<li>
~RET %文書
◎
Return document.
</li>
		</ol>
	</dd>

	<dt>@createHTMLDocument(title)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createHTMLDocument(title) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%文書 ~LET 次のように設定された，新たな`文書$
⇒＃
`種別$doc ~SET `html^l,
`内容~型$doc ~SET `text/html^l
◎
Let doc be a new document that is an HTML document.
◎
Set doc’s content type to "text/html".
</li>
			<li>
%文書 に`~nodeを付加する$( 次のように設定された 新たな`~doctype$ )
⇒＃
`名前$dT ~SET `html^l,
`~node文書$ ~SET %文書
◎
Append a new doctype, with "html" as its name and with its node document set to doc, to doc.
</li>
			<li>
`html 要素^V ~LET
`要素を作成する$( %文書, `html^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, html, and the HTML namespace, to doc.
</li>
			<li>
%文書 に`~nodeを付加する$( `html 要素^V )
◎
↑</li>
			<li>
`head 要素^V ~LET
`要素を作成する$( %文書, `head^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, head, and the HTML namespace, to the html element created earlier.
</li>
			<li>
`html 要素^V に`~nodeを付加する$( `head 要素^V )
◎
↑</li>
			<li>
<p>
~IF［
%title 引数は与えられている
］：
◎
If title is given:
</p>
				<ol>
					<li>
`title 要素^V ~LET
`要素を作成する$( %文書, `title^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, title, and the HTML namespace, to the head element created earlier.
</li>
					<li>
`head 要素^V に`~nodeを付加する$( `title 要素^V )
◎
↑</li>
					<li>
`title 要素^V に`~nodeを付加する$( `新たな~Text~node$( %title, %文書 ) )
◎
Append a new Text node, with its data set to title (which could be the empty string) and its node document set to doc, to the title element created earlier.
</li>
				</ol>
			</li>
			<li>
`html 要素^V に`~nodeを付加する$( `要素を作成する$( %文書, `body^l, `~HTML~ns$ ) )
◎
Append the result of creating an element given doc, body, and the HTML namespace, to the html element created earlier.
</li>
			<li><!-- cp* -->
%文書 の`生成元$doc ~SET 此れに結付けられている`文書$の`生成元$doc
`HTML$r
◎
doc’s origin is context object’s associated document’s origin.
</li>
			<li>
~RET %文書
◎
Return doc.
</li>
		</ol>
	</dd>

	<dt>@hasFeature()</dt>
	<dd>
被呼出時には、 ~T を返さ~MUST：
◎
The hasFeature() method, when invoked, must return true.
	</dd>
	<dd class="note">注記：
$hasFeature()
は元々、~UAが所与の~DOM特色機能の~supportを~~言明しているかどうかを報告するものであったが、経験から，単に欲される［
~obj／属性／~meth
］が存在するかどうか検査する用途にはほど遠いことが~~判明している。
そのようなわけで，それは最早~利用されないが、古い~pageが働き続けられるようにするために存続している（単に ~T を返す）。
◎
hasFeature() originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it is no longer to be used, but continues to exist (and simply returns true) so that old pages don’t stop working.
</dd>
</dl>

			</section>
		</section>
		<section id="interface-documenttype">
<h3>4.6. ~ifc ^@DocumentType</h3>

！！
[`Exposed$=Window]
interface @DocumentType : $Node {
  ~RA ~DS $name;
  ~RA ~DS $publicId;
  ~RA ~DS $systemId;
};
！


<p>
$DocumentType `~node$は、単に
`~doctype@
とも称される。
◎
DocumentType nodes are simply known as doctypes.
</p>


<div class="p">
<p>
各 `~doctype$には、次のものが結付けられる（いずれも，文字列）：
</p>

<dl class="def-list">
	<dt>`名前@dT</dt>
	<dd>
常に，`~doctype$の作成-時に与えられる。
</dd>

	<dt>`~publicID@dT</dt>
	<dt>`~systemID@dT</dt>
	<dd>
これらは、`~doctype$の作成-時に明示的に与えられない限り，空~文字列とする。
</dd>

</dl>

◎
Doctypes have an associated name, public ID, and system ID.
◎
When a doctype is created, its name is always given. Unless explicitly given when a doctype is created, its public ID and system ID are the empty string.
</div>



<dl class="idl-def">
	<dt>@name</dt>
	<dd>
取得子は、此れの`名前$dTを返さ~MUST。
◎
The name attribute’s getter must return the context object’s name.
</dd>

	<dt>@publicId</dt>
	<dd>
取得子は、此れの`~publicID$dTを返さ~MUST。
◎
The publicId attribute’s getter must return the context object’s public ID.
</dd>

	<dt>@systemId</dt>
	<dd>
取得子は、此れの`~systemID$dTを返さ~MUST。
◎
The systemId attribute’s getter must return the context object’s system ID.
</dd>
</dl>

		</section>
		<section id="interface-documentfragment">
<h3>4.7. ~ifc ^@DocumentFragment</h3>

！！
[$Constructor,
 `Exposed$=Window]
interface @DocumentFragment : $Node {
};
！

<p>
$DocumentFragment `~node$は、単に
`文書片@
（ `document fragment^en ）とも称される。
【これは、この訳にて導入した非公式な用語である。】
</p>

<div class="p">
<p>
各 `文書片$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~host@</dt>
	<dd>
［
~NULL, 異なる`~node木$内にある`要素$
］のいずれかであり、他が言明されない限り，~NULL とする。
</dd>
</dl>
◎
A DocumentFragment node has an associated host (null or an element in a different node tree). It is null unless otherwise stated.
</div>

<p>
~obj %A が ~obj %B の
`~hostも含む広義先祖@
であるとは、次のいずれかが満たされることを意味する：
◎
An object A is a host-including inclusive ancestor of an object B, if either＼
</p>

<ul>
	<li>
%A は %B の`広義先祖$である
◎
A is an inclusive ancestor of B, or＼
</li>
	<li>
%B の`根$の`~host$を %H とするとき，次が満たされる
⇒
［
%H ~NEQ ~NULL
］~AND［
%A は %H の`~hostも含む広義先祖$である
］
◎
if B’s root has a non-null host and A is a host-including inclusive ancestor of B’s root’s host.
</li>
</ul>

<p class="note">注記：
`文書片$の`~host$は，［
`~shadow根$, ~HTMLの `template$e 要素
］で有用になる概念であり、［
`~nodeを子の前に前挿入する$／`子を~nodeに置換する$
］~algoに影響0する。 
◎
The DocumentFragment node’s host concept is useful for HTML’s template element and for shadow roots, and impacts the pre-insert and replace algorithms.
</p>

<hr>

<dl class="domintro">
	<dt>%tree = new $DocumentFragment()</dt>
	<dd>
新たな`文書片$を返す。
◎
Returns a new DocumentFragment node.
</dd>
</dl>

<dl class="idl-def">
	<dt>@DocumentFragment()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた新たな`文書片$を返さ~MUST
⇒
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The DocumentFragment() constructor, when invoked, must return a new DocumentFragment node whose node document is current global object’s associated Document.
</dd>
</dl>

		</section>
		<section id="interface-shadowroot">
<h3>4.8. ~ifc ^@ShadowRoot</h3>

！！
[`Exposed$=Window]
interface @ShadowRoot : $DocumentFragment {
  ~RA $ShadowRootMode $mode;
  ~RA $Element $host;
};

enum @ShadowRootMode { `open@l, `closed@l };
！


<p>
$ShadowRoot ~nodeは、単に
`~shadow根@
（ `shadow root^en ）とも称される。
◎
ShadowRoot nodes are simply known as shadow roots.
</p>

<div class="p">
<p>
各 `~shadow根$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~mode@sR</dt>
	<dd>
［
`open^l, `closed^l
］のいずれか。
</dd>
</dl>
◎
Shadow roots have an associated mode("open" or "closed").
</div>

<p>
`~shadow根$の`~host$が ~NULL になることは決してない。
◎
Shadow roots’s associated host is never null.
</p>

<p>
`~shadow根$ %根 の`親~targetを取得する$ときは、所与の~event %~event に対し，次を走らす：
◎
A shadow root’s get the parent algorithm, given an event,＼
</p>

<ol>
	<li>
~IF［
%~event の`~composed$f ~EQ ~OFF
］~AND［
%根 ~EQ ［［［
%~event の`経路$
］内の最初の~tuple
］の `~item$evP
］の`根$
］
⇒
~RET ~NULL
◎
returns null if event’s composed flag is unset and shadow root is the root of event’s path’s first tuple’s item, and＼
</li>
	<li>
~RET %根 の`~host$
◎
shadow root’s host otherwise.
</li>
</ol>


<dl class="idl-def">
	<dt>@mode</dt>
	<dd>
取得子は、此れの`~mode$sRを返さ~MUST。
◎
The mode attribute’s getter must return the context object’s mode.
</dd>

	<dt>@host</dt>
	<dd>
取得子は、此れの`~host$を返さ~MUST。
◎
The host attribute’s getter must return the context object’s host.
</dd>
</dl>

<hr>

<p>
`~node木$ %木 に対する
`~shadowも含む木~順序@
は、
`~shadowも含む深優先前順走査@
と称される，次に従う順序である
⇒
%木 に対する深優先前順走査
【すなわち，通常の木~順序】
に従いつつ，
%木 において［
`~shadow~host$である`要素$ %要素
］に遭遇した各所では，［［
%要素 の`~shadow根$elmを根とする`~node木$
］に対する，`~shadowも含む深優先前順走査$
］に従う。
◎
In shadow-including tree order, is shadow-including preorder, depth-first traversal of a node tree. shadow-including preorder, depth-first traversal of a node tree tree is preorder, depth-first traversal of tree, with for each shadow host encountered in tree, shadow-including preorder, depth-first traversal of that element’s shadow root’s node tree just after it is encountered.
</p>

<p>
~obj %O の
`~shadowも含む根@
とは、
%O の`根$を %根 とするとき，［
%根 は`~shadow根$であるならば %根 の`~host$の`~shadowも含む根$ ／
~ELSE_ %根
］である。
◎
The shadow-including root of an object is its root’s host’s shadow-including root, if the object’s root is a shadow root, and its root otherwise.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子孫$である
］~OR［
%A の`根$は次を満たす
］
⇒
［
`~shadow根$である
］~AND［
その`~host$は %B の`~shadowも含む広義子孫$である
］
◎
An object A is a shadow-including descendant of an object B, if A is a descendant of B, or A’s root is a shadow root and A’s root’s host is a shadow-including inclusive descendant of B.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む子孫$である
］
◎
A shadow-including inclusive descendant is an object or one of its shadow-including descendants.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む先祖@
であるとは、次を意味する
⇒
%B は %A の`~shadowも含む子孫$である
◎
An object A is a shadow-including ancestor of an object B, if and only if B is a shadow-including descendant of A.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義先祖@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む先祖$である
］
◎
A shadow-including inclusive ancestor is an object or one of its shadow-including ancestors.
</p>

<p>
`~node$ %A が `~node$ %B から
`~closed~shadow~hidden@
であるとは、 %A の`根$ %根 が次のすべてを満たすことを意味する：
◎
A node A is closed-shadow-hidden from a node B if all of the following conditions are true:
</p>

<ul>
	<li>
%根 は`~shadow根$である
◎
A’s root is a shadow root.
</li>
	<li>
%根 は %B の`~shadowも含む広義先祖$でない
◎
A’s root is not a shadow-including inclusive ancestor of B.
</li>
	<li>
［
%根 の`~mode$sR ~EQ `closed^l
］~OR［
%根 の`~host$は %B から`~closed~shadow~hidden$である
］
◎
A’s root is a shadow root whose mode is "closed" or A’s root’s host is closed-shadow-hidden from B.
</li>
</ul>

<p class="algo-head">
~obj %A を ~obj %B に向けて
`~targetし直す@
ときは、次を走らす：
◎
To retarget an object A against an object B,＼
</p>

<ol>
	<li>
<p>
~WHILE 無条件：
◎
repeat these steps until they return an object:
</p>
		<ol>
			<li>
%根 ~LET %A の`根$
◎
↓</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following is true
</p>
				<ul>
					<li>
%A は`~node$でない
◎
A is not a node
</li>
					<li>
%根 は`~shadow根$でない
◎
A’s root is not a shadow root
</li>
					<li>
［
%B は`~node$である
］~AND［
%根 は %B の`~shadowも含む広義先祖$である
］
◎
B is a node and A’s root is a shadow-including inclusive ancestor of B
</li>
				</ul>
<p>
…ならば
⇒
~RET %A
◎
then return A.
</p>
			</li>
			<li>
%A ~SET %根 の`~host$
◎
Set A to A’s root’s host.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
`~targetし直す$~algoは、~eventの`配送-$時, および
`FULLSCREEN$r などの他の仕様により利用される。
◎
The retargeting algorithm is used by event dispatch as well as other specifications, such as Fullscreen. [FULLSCREEN]
</p>

		</section>
		<section id="interface-element">
<h3>4.9. ~ifc ^@Element</h3>

！！
[`Exposed$=Window]
interface @Element : $Node {
  ~RA ~DS? $namespaceURI;
  ~RA ~DS? $prefix;
  ~RA ~DS $localName;
  ~RA ~DS $tagName;

  [`CEReactions$] attribute ~DS $id;
  [`CEReactions$] attribute ~DS $className;
  [`SameObject$, `PutForwards$=$DOMTokenList.value] ~RA $DOMTokenList $classList;
  [`CEReactions$, `Unscopable$] attribute ~DS $slot;

  boolean $hasAttributes();
  [`SameObject$] ~RA $NamedNodeMap $attributes;
  sequence&lt;~DS&gt; $getAttributeNames();
  ~DS? $getAttribute(~DS %qualifiedName);
  ~DS? $getAttributeNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] void $setAttribute(~DS %qualifiedName, ~DS %value);
  [`CEReactions$] void $setAttributeNS(~DS? %namespace, ~DS %qualifiedName, ~DS %value);
  [`CEReactions$] void $removeAttribute(~DS %qualifiedName);
  [`CEReactions$] void $removeAttributeNS(~DS? %namespace, ~DS %localName);
  ~B $hasAttribute(~DS %qualifiedName);
  ~B $hasAttributeNS(~DS? %namespace, ~DS %localName);

  $Attr? $getAttributeNode(~DS %qualifiedName);
  $Attr? $getAttributeNodeNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] $Attr? $setAttributeNode($Attr %attr);
  [`CEReactions$] $Attr? $setAttributeNodeNS($Attr %attr);
  [`CEReactions$] $Attr $removeAttributeNode($Attr %attr);

  $ShadowRoot $attachShadow($ShadowRootInit %init);
  ~RA $ShadowRoot? $shadowRoot;

  $Element? $closest(~DS %selectors);
  ~B $matches(~DS %selectors);
  ~B $webkitMatchesSelector(~DS %selectors); // <span class="comment" title="historical alias of .characterSet">$matches の歴史上の別名</span>

  $HTMLCollection $getElementsByTagName(~DS %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS(~DS? %namespace, ~DS %localName);
  $HTMLCollection $getElementsByClassName(~DS %classNames);

  [`CEReactions$] $Element? $insertAdjacentElement(~DS %where, $Element %element); // <!--cp-histroic-->
  void $insertAdjacentText(~DS %where, ~DS %data); // <!--cp-histroic-->
};

dictionary @@ShadowRootInit {
  required $ShadowRootMode @mode;
};
！

<p>
$@Element `~node$は、単に
`要素@
（ `element^en ）とも称される。
◎
Element nodes are simply known as elements.
</p>

<p>
各 `要素$には、次のものが結付けられ，いずれも`要素を作成する$ときに初期化される
⇒＃
`~ns@,
`~ns接頭辞@,
`局所~名@,
`~custom要素~状態@,
`~custom要素~定義@,
`~is0値@
◎
Elements have an associated namespace, namespace prefix, local name, custom element state, custom element definition, is value. When an element is created, all of these values are initialized.
</p>

<div class="p">
<p>
`要素$ %要素 の`~custom要素~状態$ %状態 は：
</p>

<ul>
	<li>
次のいずれかになるとする
⇒＃
`undefined^l,
`failed^l,
`uncustomized^l,
`custom^l
</li>
	<li>
%要素 は次を満たすならば
`定義-済み@
とされる
⇒
%状態 ~IN { `uncustomized^l, `custom^l }
</li>
	<li>
%要素 は次を満たすならば
`~custom@
であるとされる
⇒
%状態 ~EQ `custom^l
</li>
</ul>
◎
An element’s custom element state is one of "undefined", "failed", "uncustomized", or "custom". An element whose custom element state is "uncustomized" or "custom" is said to be defined. An element whose custom element state is "custom" is said to be custom.
</div>


<p class="note">注記：
要素が`定義-済み$かどうかは、
<a href="~HTMLselectors#selector-defined"><code class="pseudo">:defined</code></a>
疑似類の挙動を決定するときに利用される。
要素が`~custom$であるかどうかは、
<a href="#mutation-algorithms">変異~algo</a>
の挙動を決定するときに利用される。
`failed^l 状態は、`~custom要素~構築子$が初回に正しく実行するのに失敗した場合に，`要素を昇格する$ときに再び実行されないことを確保するために利用される。
◎
Whether or not an element is defined is used to determine the behavior of the :defined pseudo-class. Whether or not an element is custom is used to determine the behavior of the mutation algorithms. The "failed" state is used to ensure that if a custom element constructor fails to execute correctly the first time, it is not executed again by an upgrade.
</p>

<div class="example">
<p>
要素がとり得るこれら 4 種の状態を，次の~codeで~~説明する：
◎
The following code illustrates elements in each of these four states:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  window.customElements.define(
    "sw-rey",
    class extends HTMLElement {}
  );
  window.customElements.define(
    "sw-finn",
    class extends HTMLElement {},
    { extends: "p" }
  );
  window.customElements.define(
    "sw-kylo",
    class extends HTMLElement {
      constructor() {
        /* <span class="comment">
`super()^c は、この例からは意図的に省略している。
◎
super() intentionally omitted for this example
</span> */
    }
  });
&lt;/script&gt;

&lt;!-- <span class="comment">
`undefined^l （`定義-済み$でも`~custom$でもない）
◎
"undefined" (not defined, not custom)
</span> --&gt;
&lt;sw-han&gt;&lt;/sw-han&gt;
&lt;p is="sw-luke"&gt;&lt;/p&gt;
&lt;p is="asdf"&gt;&lt;/p&gt;

&lt;!-- <span class="comment">
`failed^l （`定義-済み$でも`~custom$でもない）
◎
"failed" (not defined, not custom)
</span> --&gt;
&lt;sw-kylo&gt;&lt;/sw-kylo&gt;

&lt;!-- <span class="comment">
`uncustomized^l （`定義-済み$だが`~custom$ではない）
◎
"uncustomized" (defined, not custom)
</span> --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;asdf&gt;&lt;/asdf&gt;

&lt;!-- <span class="comment">
`custom^l （`定義-済み$かつ`~custom$である）
◎
"custom" (defined, custom)
</span> --&gt;
&lt;sw-rey&gt;&lt;/sw-rey&gt;
&lt;p is="sw-finn"&gt;&lt;/p&gt;
</pre>

</div>

<div class="p">
<p>
各 `要素$には、次のものも結付けられる：
</p>

<dl class="def-list">
	<dt >`~shadow根@elm</dt>
	<dd>
~NULL, または `~shadow根$。
</dd>
	<dd>
他が言明されない限り，~NULL とする。
</dd>
	<dd>
~NULL でない場合、当の`要素$は
`~shadow~host@
であるとされる†。
</dd>
	<dd class="trans-note">【†
— すなわち，要素は、`~shadow根$elmを根とする，ある`~shadow木$を~hostしている（要素は、ある`~shadow根$の`~host$である）。
】</dd>
</dl>

◎
Elements also have an associated shadow root (null or a shadow root). It is null unless otherwise stated. An element is a shadow host if its shadow root is non-null.
</div>

<p>
`要素$ %要素 の
`有修飾~名@
は、 %要素 の`~ns接頭辞$ %接頭辞 に応じて，［
~NULL ならば %要素 の`局所~名$ ／
非 ~NULL ならば［
%接頭辞, `:^l, %要素 の`局所~名$
］の並び
］になる。
◎
An element’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<p>
`要素$ %要素 の
`~HTML大文字~化~有修飾~名@
は、次の手続きの結果を返す：
◎
An element’s HTML-uppercased qualified name is the return value of these steps: 
</p>
<ol>
	<li>
%有修飾~名 ~LET %要素 の`有修飾~名$
◎
Let qualifiedName be context object’s qualified name.
</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
~RET `~ASCII大文字~化する$( %有修飾~名 )
◎
If the context object is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII uppercase.
</li>
	<li>
~RET %有修飾~名
◎
Return qualifiedName.
</li>
</ol>

<p class="note">注記：
~UAは、`有修飾~名$と`~HTML大文字~化~有修飾~名$を内的~slotに格納して最適化することもできる。
◎
User agents could optimize qualified name and HTML-uppercased qualified name by storing them in internal slots. 
</p>


<p class="algo-head">
`要素を作成する@
ときは、所与の
⇒＃
%文書,
%局所~名,
%~ns,
%接頭辞 （省略時は ~NULL ）,
%is （省略時は ~NULL ）,
%同期~custom要素~flag ~IN { `同期~custom要素^i, ε }（省略時は ε ）
◎終
に対し，次の手続きを走らす：
◎
To create an element, given a document, localName, namespace, and optional prefix, is, and synchronous custom elements flag, run these steps: 
</p>

<ol>
	<li>
%結果 ~LET ~NULL
◎
If prefix was not given, let prefix be null.
◎
If is was not given, let is be null.
◎
Let result be null.
</li>
	<li>
%定義 ~LET `~custom要素~定義を検索する$( %文書, %~ns, %局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given document, namespace, localName, and is.
</li>
	<li>
<p>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`名前$cD ~NEQ %定義 の`局所~名$cD
］（すなわち，%定義 は`~custom化された組込みの要素$を表現する）：
◎
If definition is non-null, and definition’s name is not equal to its local name (i.e., definition represents a customized built-in element), then:
</p>
		<ol>
			<li>
%~ifc ~LET ( %局所~名, `~HTML~ns$ ) 用の`要素~ifc$
◎
Let interface be the element interface for localName and the HTML namespace.
</li>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$
⇒＃
%~ifc を実装する,
`属性o$は有さない,
`~ns$ ~SET `~HTML~ns$,
`~ns接頭辞$ ~SET %接頭辞 ,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `undefined^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET %is,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to is, and node document set to document.
</li>
			<li>
~IF［
%同期~custom要素~flag ~NEQ ε
］
⇒
`要素を昇格する$( %定義, %要素 )
◎
If the synchronous custom elements flag is set, upgrade element using definition.
</li>
			<li>
~ELSE
⇒
`~custom要素~昇格~反応を~enqueueする$( %結果, %定義 )
◎
Otherwise, enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］~AND［
%同期~custom要素~flag ~NEQ ε
］：
◎
Otherwise, if definition is non-null, then:
</p>

<p>
この段から例外が投出されたときは、~catchして，下の (A) に~~移行するとする
◎
If the synchronous custom elements flag is set, then run these steps while catching any exceptions:
</p>
		<ol>
			<li>
%C ~LET %定義 の`構築子$cD
◎
Let C be definition’s constructor.
</li>
			<li>
%結果 ~SET `~callback関数で構築する$( %C, 空の引数~list )
◎
Set result to the result of constructing C, with no arguments.
</li>
			<li>
<p>
~IF［
%結果 は $HTMLElement ~ifcを実装しない
］
⇒
~THROW `TypeError$E
◎
If result does not implement the HTMLElement interface, then throw a TypeError.
</p>

<div class="note">
<p>注記：
これは、［
当の~objが~HTML要素~構築子により割り当てられること
］を確保するための，~brand検査である。
より精確に知りたければ、
<a href="https://github.com/heycam/webidl/issues/97">webidl #97</a>
を見よ。
◎
This is meant to be a brand check to ensure that the object was allocated by the HTML element constructor. See webidl #97 about making this more precise.
</p>

<p>
この検査に合格したなら、 %結果 の［
`~custom要素~状態$, `~custom要素~定義$
］はすでに初期化されていることになる。
◎
If this check passes, then result will already have its custom element state and custom element definition initialized. 
</p>
</div>
			</li>
			<li>
<p>
~IF［
%結果 は下に挙げるいずれかを満たす
］
⇒
~THROW `NotSupportedError$E：
◎
↓</p>

				<ul>
					<li>
%結果 の`属性o~list$は`空$でない
◎
If result’s attribute list is not empty, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 は`子$を持つ
◎
If result has children, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 の`親$ ~NEQ ~NULL
◎
If result’s parent is not null, then throw a "NotSupportedError" DOMException.
</li>
					<li>
%結果 の`~node文書$ ~NEQ %文書
◎
If result’s node document is not document, then throw a "NotSupportedError" DOMException.
</li>
					<li>
<p>
%結果 の`~ns$ ~NEQ `~HTML~ns$
◎
If result’s namespace is not the HTML namespace, then throw a "NotSupportedError" DOMException.
</p>

<p class="note">注記：
これを書いている時点では、
$HTMLElement ~ifcを実装するどの要素も~HTML~nsに属するので、上の~brand検査から，この検査は冗長であるが、永遠に保障されるわけではない
— 例えば、~SVGと~HTMLのある種の~ifcが収束するような，仕様の変更に直面したときなど。
◎
As of the time of this writing, every element that implements the HTMLElement interface is also in the HTML namespace, so this check is currently redundant with the above brand check. However, this is not guaranteed to be true forever in the face of potential specification changes, such as converging certain SVG and HTML interfaces.
</p>
					</li>
					<li>
%結果 の`局所~名$ ~NEQ %局所~名
◎
If result’s local name is not equal to localName, then throw a "NotSupportedError" DOMException.
</li>
				</ul>
			</li>
			<li>
%結果 の`~ns接頭辞$ ~SET %接頭辞
◎
Set result’s namespace prefix to prefix.
</li>
			<li>
%結果 の`~is0値$ ~SET ~NULL
◎
Set result’s is value to null.
</li>
		</ol>
<p>
(A)
— 上の手続きにて，例外が投出されたときは：
◎
If any of these steps threw an exception, then:
</p>
		<ol>
			<li>
`その例外を報告する$
◎
Report the exception.
</li>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$
⇒＃
$HTMLUnknownElement ~ifcを実装する,
属性oは有さない,
`~ns$ ~SET `~HTML~ns$,
`~ns接頭辞$ ~SET %接頭辞,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `failed^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET ~NULL,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements the HTMLUnknownElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "failed", custom element definition set to null, is value set to null, and node document set to document.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］：
◎
↑
◎
Otherwise:
</p>
		<ol>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$
⇒＃
$HTMLElement を実装する,
`属性o$は有さない,
`~ns$ ~SET `~HTML~ns$,
`~ns接頭辞$ ~SET %接頭辞 ,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `undefined^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET ~NULL,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements the HTMLElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to null, and node document set to document.
</li>
			<li>
`~custom要素~昇格~反応を~enqueueする$( %結果, %定義 )
◎
Enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~ifc ~LET ( %局所~名, %~ns ) 用の`要素~ifc$
◎
Let interface be the element interface for localName and namespace.
</li>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$
⇒＃
%~ifc を実装する,
`属性o$は有さない,
`~ns$ ~SET %~ns,
`~ns接頭辞$ ~SET %接頭辞 ,
`局所~名$ ~SET %局所~名,
`~custom要素~状態$ ~SET `uncustomized^l,
`~custom要素~定義$ ~SET ~NULL,
`~is0値$ ~SET %is,
`~node文書$ ~SET %文書
◎
Set result to a new element that implements interface, with no attributes, namespace set to namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "uncustomized", custom element definition set to null, is value set to is, and node document set to document.
</li>
			<li>
<p>
~IF［
次のいずれも満たされる
］…：
</p>

<ul ><li>%~ns ~EQ `~HTML~ns$
</li><li>［
%局所~名 は`妥当な~custom要素~名$である
］~OR［
%is ~NEQ ~NULL
］
</li></ul>

<p>
…ならば
⇒
%結果 の`~custom要素~状態$ ~SET `undefined^l
</p>
◎
If namespace is the HTML namespace, and either localName is a valid custom element name or is is non-null, then set result’s custom element state to "undefined".
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


<p>
各`要素$は、
`属性o~list@
も持つ。
それは、`~list$であり，
$NamedNodeMap
【~objを返す $attributes 属性】
を通して公開される。
`要素$の作成-時に明示的に与えられない限り，その`属性o~list$は`空$とする。
◎
Elements also have an attribute list, which is a list exposed through a NamedNodeMap. Unless explicitly given when an element is created, its attribute list is empty.
</p>

<p>
`要素$ %要素 が`属性o$ %A を
`有する@
とは、［
%A ~IN %要素 の`属性o~list$
］を意味する。
◎
An element has an attribute A if its attribute list contains A. 
</p>

<p class="trans-note">【
この場合、［
%A が`属する要素$ ~EQ %要素
］も満たすことになる
— 複数の`要素$が同じ`属性o$を`有する$ことはない（手続き内のある同期的な瞬間を除いて）。
】</p>

<p>
`適用-可能な仕様$は、`要素$上の
`属性oを変更する手続き@
を定義しても~MAY。
この~algoは、当の要素に加えて，
( %局所~名, %旧-値, %値, %~ns )
を渡して呼出される。
◎
This and other specifications may define attribute change steps for elements. The algorithm is passed element, localName, oldValue, value, and namespace.
</p>

<p class="algo-head">
`要素$ %要素 の
`属性oを変更する@
ときは、所与の
( `属性o$ %属性o, 文字列 %値  )
に対し，次を走らす：
◎
To change an attribute attribute from an element element to value, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %属性o を`有する$
【この段は、この訳による補完】
</li>
	<li>
%要素 用に`属性~変異~記録を~queueする$( %属性o の`局所~名$a, %属性o の`~ns$, %属性o の`値$a )
◎
Queue an attribute mutation record for element with attribute’s local name, attribute’s namespace, and attribute’s value.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$, %属性o の`値$a, %値, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, attribute’s value, value, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %属性o の`局所~名$a, %属性o の`値$a, %値, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, attribute’s value, value, and attribute’s namespace.
</li>
	<li>
%属性o の`値$a ~SET %値
◎
Set attribute’s value to value.
</li>
</ol>



<p class="algo-head">
`要素$ %要素 に
`属性oを付加する@
ときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To append an attribute attribute to an element element, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %属性o を`有さない$
【この段は、この訳による補完】
</li>
	<li>
%要素 用に`属性~変異~記録を~queueする$( %属性o の`局所~名$a, %属性o の`~ns$, ~NULL )
◎
Queue an attribute mutation record for element with attribute’s local name, attribute’s namespace, and null.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$, ~NULL, %属性o の`値$a, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, null, attribute’s value, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %属性o の`局所~名$a, ~NULL, %属性o の`値$a, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, null, attribute’s value, and attribute’s namespace.
</li>
	<li>
%要素 の`属性o~list$に %属性o を`付加する$
◎
Append attribute to element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET %要素
◎
Set attribute’s element to element.
</li>
</ol>


<p class="algo-head">
`要素$ %要素 から
`属性oを除去する@
ときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To remove an attribute attribute from an element element, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %属性o を`有する$
【この段は、この訳による補完】
</li>
	<li>
%要素 用に`属性~変異~記録を~queueする$( %属性o の`局所~名$a, %属性o の`~ns$, %属性o の`値$a )
◎
Queue an attribute mutation record for element with attribute’s local name, attribute’s namespace, and attribute’s value.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$, %属性o の`値$a, ~NULL, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, attribute’s value, null, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %属性o の`局所~名$a, %属性o の`値$a, ~NULL, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, attribute’s value, null, and attribute’s namespace.
</li>
	<li>
%要素 の`属性o~list$から %属性o を`除去する$
◎
Remove attribute from element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET ~NULL
◎
Set attribute’s element to null.
</li>
</ol>

<hr>

<p class="algo-head">
`要素$ %要素 の
`属性oを置換する@
ときは、所与の
( `属性o$ %旧-属性o, `属性o$ %新-属性o )
に対し，次を走らす：
◎
To replace an attribute oldAttr by an attribute newAttr in an element element, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %旧-属性o を`有する$
【この段は、この訳による補完】
</li>
	<li>
%要素 用に`属性~変異~記録を~queueする$( %旧-属性o の`局所~名$a, %旧-属性o の`~ns$a, %旧-属性o の`値$a )
◎
Queue an attribute mutation record for element with oldAttr’s local name, oldAttr’s namespace, and oldAttr’s value.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を~enqueueする$(
%要素,
`attributeChangedCallback^l,
« %旧-属性o の`局所~名$, %旧-属性o の`値$a, %新-属性o の`値$a, %旧-属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing oldAttr’s local name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %旧-属性o の`局所~名$a, %旧-属性o の`値$a, %新-属性o の`値$a, %旧-属性o の`~ns$a )
◎
Run the attribute change steps with element, oldAttr’s local name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
</li>
	<li>
%要素 の`属性o~list$内の %旧-属性o を %新-属性o に`置換する$
◎
Replace oldAttr by newAttr in element’s attribute list.
</li>
	<li>
%旧-属性o が`属する要素$ ~SET ~NULL
◎
Set oldAttr’s element to null.
</li>
	<li>
%新-属性o が`属する要素$ ~SET %要素
◎
Set newAttr’s element to element.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを名前により取得する@
ときは、所与の
( %有修飾~名 )
に対し，次を走らす：
◎
To get an attribute by name given a qualifiedName and element element, run these steps:
</p>

<ol>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%有修飾~名 ~LET `~ASCII小文字~化する$( %有修飾~名 )
◎
If element is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
	<li>
~RET %要素 の`属性o~list$ 内の次を満たす`属性o$のうち，`最初のもの？$
⇒
`有修飾~名$a ~EQ %有修飾~名
◎
Return the first attribute in element’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを~nsと局所~名により取得する@
ときは、所与の
( %~ns, %局所~名 )
に対し、次を走らす：
◎
To get an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>

<ol>
	<!--cp-normalize-ns-->
	<li>
~RET %要素 の`属性o~list$ 内の 次を満たす`属性o$のうち，`最初のもの？$
⇒
［
`~ns$a ~EQ %~ns
］~AND［
`局所~名$a ~EQ %局所~名
］
◎
Return the attribute in element’s attribute list whose namespace is namespace and local name is localName, if any, and null otherwise.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性o値を取得する@
ときは、所与の
( %局所~名,  %~ns （省略時は ~NULL ） )
に対し，次を走らす：
◎
To get an attribute value given an element element, localName, and optionally a namespace (null unless stated otherwise), run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %局所~名,  %~ns )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~RET ［
%属性o ~EQ ~NULL ならば空~文字列 ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, then return the empty string.
◎
Return attr’s value.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを設定する@
するときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To set an attribute given an attr and element, run these steps:
</p>

<ol>
	<li>
~IF［
%属性o が`属する要素$ ~NIN { ~NULL, %要素 }
］
⇒
~THROW `InUseAttributeError$E
◎
If attr’s element is neither null nor element, throw an "InUseAttributeError" DOMException.
</li>
	<li>
%旧-属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %属性o の`~ns$a, %属性o の`局所~名$a )
◎
Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local name, and element.
</li>
	<li>
~IF［
%旧-属性o ~EQ %属性o
］
⇒
~RET %属性o
◎
If oldAttr is attr, return attr.
</li>
	<li>
~IF［
%旧-属性o ~NEQ ~NULL
］
⇒
%要素 の`属性oを置換する$( %旧-属性o, %属性o )
◎
If oldAttr is non-null, replace it by attr in element.
</li>
	<li>
~ELSE
⇒
%要素 に`属性oを付加する$( %属性o )
◎
Otherwise, append attr to element.
</li>
	<li>
~RET %旧-属性o
◎

Return oldAttr.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性o値を設定する@
ときは、所与の
( %局所~名, %値, %接頭辞 （省略時は ~NULL ）, %~ns （省略時は ~NULL ） )
に対し，次を走らす：
◎
To set an attribute value for an element element using a localName and value, and an optional prefix, and namespace, run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
If prefix is not given, set it to null.
◎
If namespace is not given, set it to null.
◎
Let attribute be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒＃
%要素 の`属性oを変更する$( %属性o, %値 )；
~RET
◎
↓</li>
	<li>
%要素 に`属性oを付加する$( 次のように設定された 新たな`属性o$ )
⇒＃
`~ns$a ~SET %~ns,
`~ns接頭辞$a ~SET %接頭辞,
`局所~名$a ~SET %局所~名,
`値$a ~SET %値,
`~node文書$ ~SET %要素 の`~node文書$
◎
If attribute is null, create an attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, value is value, and node document is element’s node document, then append this attribute to element, and then return.
◎
Change attribute from element to value.
	</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを名前により除去する@
ときは、所与の
( %有修飾~名 )
に対し，次を走らす：
◎
To remove an attribute by name given a qualifiedName and element element, run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを名前により取得する$( %有修飾~名 )
◎
Let attr be the result of getting an attribute given qualifiedName and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
%要素 から`属性oを除去する$( %属性o )
◎
If attr is non-null, remove it from element.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを~nsと局所~名により除去する@
ときは、所与の
( %~ns, %局所~名 )
に対し，次を走らす：
◎
To remove an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
%要素 から`属性oを除去する$( %属性o )
◎
If attr is non-null, remove it from element.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>

<hr>

<p>
`要素$には、一意な識別子である
`~ID@
が結付けられ得る。
◎
An element can have an associated unique identifier (ID)
</p>
<p class="note">注記：
歴史的に，`要素$は複数の識別子を持ち得ていた。
例えば~HTML `id^A `属性o$nmと DTD を利用して。
この仕様では
`~ID$を~DOMの概念とし，`要素$につき `id^A `属性o$nmで与えられる 1 個に限るとする。
◎
Historically elements could have multiple identifiers e.g., by using the HTML id attribute and a DTD. This specification makes ID a concept of the DOM and allows for only one per element, given by an id attribute.
</p>

<p class="algo-head">
`要素$の`~ID$の更新~時に利用する，`属性oを変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update an element’s ID:
</p>

<ol>
	<li>
~IF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］~AND［
%値 ~IN { ~NULL, 空~文字列 }
］
⇒
%要素 の`~ID$を未設定にする
◎
If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
</li>
	<li>
~ELIF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］
⇒
%要素 の`~ID$ ~SET %値
◎
Otherwise, if localName is id, namespace is null, then set element’s ID to value.
</li>
</ol>


<p class="note">注記：
この仕様は、どの`要素$に対しても，その［
^class, ^id, ^slot
］`属性o$nmに対する要件を定義しているが、これらの属性oを利用をするかどうかは，適合性の要件にしていない。
◎
While this specification defines requirements for class, id, and slot attributes on any element, it makes no claims as to whether using them is conforming or not.
</p>

<hr>

<p>
`~node$ %N の
`親~要素@
とは、［
%N の`親$が`要素$であるならば それ ／
~ELSE_ ~NULL
］である。
◎
A node’s parent of type Element is known as a parent element. If the node has a parent of a different type, its parent element is null.
</p>

<hr>

<dl class="domintro">
	<dt>%namespace = %element . $namespaceURI</dt>
	<dd>
`~ns$を返す。
◎
Returns the namespace.
</dd>

	<dt>%prefix = %element . $prefix</dt>
	<dd>
`~ns接頭辞$を返す。
◎
Returns the namespace prefix.
</dd>

	<dt>%localName = %element . $localName</dt>
	<dd>
`局所~名$を返す。
◎
Returns the local name.
</dd>

	<dt>%qualifiedName = %element . $tagName</dt>
	<dd>
`~HTML大文字~化~有修飾~名$を返す。
◎
Returns the HTML-uppercased qualified name. 
</dd>
</dl>


<dl class="idl-def">
	<dt>@namespaceURI</dt>
	<dd>
取得子は、此れの`~ns$を返さ~MUST。
◎
The namespaceURI attribute’s getter must return the context object’s namespace.
</dd>

	<dt>@prefix</dt>
	<dd>
取得子は、此れの`~ns接頭辞$を返さ~MUST。
◎
The prefix attribute’s getter must return the context object’s namespace prefix.
</dd>

	<dt>@localName</dt>
	<dd>
取得子は、此れの`局所~名$を返さ~MUST。
◎
The localName attribute’s getter must return the context object’s local name.
</dd>

	<dt>@tagName</dt>
	<dd>
取得子は、此れの`~HTML大文字~化~有修飾~名$を返さ~MUST。
◎
The tagName attribute’s getter must return the context object’s HTML-uppercased qualified name.
</dd>
</dl>

<hr>

<dl class="domintro">
	<dt>%element . $id [ = %value ]</dt>
	<dd>
%element の `id^A 属性oの値を返す。
設定して変更できる。
◎
Returns the value of element’s id content attribute. Can be set to change it.
</dd>

	<dt>%element . $className [ = %value  ]</dt>
	<dd>
%element の `class^A 属性oの値を返す。
設定して変更できる。
◎
Returns the value of element’s class content attribute. Can be set to change it.
</dd>

	<dt>%element . $classList</dt>
	<dd>
%element の `class^A 属性oを，空白~区切り~tokenの集合として
— $DOMTokenList ~objを通して —
操作できるようにする。
◎
Allows for manipulation of element’s class content attribute as a set of whitespace-separated tokens through a DOMTokenList object.
</dd>

	<dt>%element . $slot [ = %value  ]</dt>
	<dd>
%element の `slot^A 属性oを返す。
設定して変更できる。
◎
Returns the value of element’s slot content attribute. Can be set to change it.
</dd>
</dl>


<p class="algo-head">
`要素$ %要素 上の一部の~IDL属性は、所与の %名前 の`属性o$を
`反映-@
するように定義される。
すなわち、次に従うような取得子, 設定子を持た~MUST：
◎
IDL attributes that are defined to reflect a content attribute of a given name, must have a getter and setter that follow these steps:
</p>

<dl>
	<dt>取得子</dt>
	<dd>
~RET %要素 の`属性o値を取得する$( %名前 )
◎
Return the result of running get an attribute value given context object and name.
</dd>

	<dt>設定子</dt>
	<dd>
%要素 の`属性o値を設定する$( %名前, 所与の値 )
◎
Set an attribute value for the context object using name and the given value.
</dd>
</dl>


<dl class="idl-def">
	<dt>@id</dt>
	<dd>
`id^l 属性oを`反映-$し~MUST。
◎
The id attribute must reflect the "id" content attribute.
</dd>

	<dt>@className</dt>
	<dd>
`class^l 属性oを`反映-$し~MUST。
◎
The className attribute must reflect the "class" content attribute.
</dd>

	<dt>@classList</dt>
	<dd>
取得子は、次のようにされた $DOMTokenList を返さ~MUST
⇒＃
`要素$dtl ~SET 此れ,
`属性oの局所~名$dtl ~SET ^class
◎
↓</dd>
	<dd>
この属性が返す $DOMTokenList ~objの`~token集合$は、`要素$の
`~classes@
とも称される。
◎
The classList attribute’s getter must return a DOMTokenList object whose associated element is the context object and whose associated attribute’s local name is class. The token set of this particular DOMTokenList object are also known as the element’s classes.
</dd>
	<dd class="trans-note">【
[`SameObject$] が指定されているので、各~要素とこの~objの各~instanceは，一対一に対応する。
】</dd>

	<dt>@slot</dt>
	<dd>
`slot^l 属性oを`反映-$し~MUST。
◎
The slot attribute must reflect the "slot" content attribute.
</dd>
	<dd class="note">注記：
［
^id, ^class, ^slot
］`属性o$nmは、要素の~nsにかかわらず どの要素~上にも現れ得るので、実質的に，（すべての~nsより）上位の大域~属性になる。
◎
id, class, and slot are effectively superglobal attributes as they can appear on any element, regardless of that element’s namespace.
</dd>
</dl>

<hr>

<dl class="domintro">

	<dt>%element . $hasAttributes()</dt>
	<dd>
%element は属性oを 1 つでも［
有するならば ~T ／
有さないならば ~F
］を返す。
◎
Returns true if element has attributes, and false otherwise.
</dd>

	<dt>%element . $getAttributeNames()</dt>
	<dd>
%element のすべての`属性o$の`有修飾~名$aを返す
— 重複を包含し得る。
◎
Returns the qualified names of all element’s attributes. Can contain duplicates.
</dd>

	<dt>%element . $getAttribute(%qualifiedName )</dt>
	<dd>
%element は次を満たす`属性o$を［
有するならば それらのうち最初のもの／
有さないならば ~NULL
］を返す
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Returns element’s first attribute whose qualified name is qualifiedName, and null if there is no such attribute otherwise.
</dd>

	<dt>%element . $getAttributeNS(%namespace , %localName )</dt>
	<dd>
%element は次を満たす`属性o$を［
有するならば それらのうち最初のもの／
有さないならば ~NULL
］を返す
⇒
［
`~ns$a ~EQ %namespace 
］~AND［
`局所~名$a ~EQ %localName 
］
◎
Returns element’s attribute whose namespace is namespace and local name is localName, and null if there is no such attribute otherwise.
</dd>

	<dt>%element . $setAttribute(%qualifiedName , %value )</dt>
	<dd>
%element は次を満たす`属性o$を有するならば［
それらのうち最初のもの
］の`値$aを %value に設定する
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Sets the value of element’s first attribute whose qualified name is qualifiedName to value.
</dd>

	<dt>%element . $setAttributeNS(%namespace , %localName , %value )</dt>
	<dd>
%element は次を満たす`属性o$を有するならば［
それらのうち最初のもの
］の`値$aを %value に設定する
⇒
［
`~ns$a ~EQ %namespace 
］~AND［
`局所~名$a ~EQ %localName 
］
◎
Sets the value of element’s attribute whose namespace is namespace and local name is localName to value.
</dd>

	<dt>%element . $removeAttribute(%qualifiedName )</dt>
	<dd>
%element は次を満たす`属性o$を有するならば［
それらのうち最初のもの
］を %element から除去する
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Removes element’s first attribute whose qualified name is qualifiedName.
</dd>

	<dt>%element . $removeAttributeNS(%namespace , %localName )</dt>
	<dd>
%element は次を満たす`属性o$を有するならば［
それらのうち最初のもの
］を %element から除去する
⇒
［
`~ns$a ~EQ %namespace 
］~AND［
`局所~名$a ~EQ %localName 
］
◎
Removes element’s attribute whose namespace is namespace and local name is localName.
</dd>

	<dt>%element . $hasAttribute(%qualifiedName )</dt>
	<dd>
%element は次を満たす`属性o$を［
有するならば ~T ／
有さないならば ~F
］を返す
⇒
`有修飾~名$a ~EQ %qualifiedName 
◎
Returns true if element has an attribute whose qualified name is qualifiedName, and false otherwise.
</dd>

	<dt>%element . $hasAttributeNS(%namespace , %localName )</dt>
	<dd>
%element は次を満たす`属性o$を［
有するならば ~T ／
有さないならば ~F
］を返す
⇒
［
`~ns$a ~EQ %namespace 
］~AND［
`局所~名$a ~EQ %localName 
］
◎
Returns true if element has an attribute whose namespace is namespace and local name is localName.
</dd>
</dl>


<dl class="idl-def">
	<dt>@hasAttributes()</dt>
	<dd>
被呼出時には、［
此れの`属性o~list$は`空$ならば ~F ／
~ELSE_ ~T
］を返さ~MUST。
◎
The hasAttributes() method, when invoked, must return false if context object’s attribute list is empty, and true otherwise.
</dd>

	<dt>@attributes</dt>
	<dd>
取得子は、此れに結付けられている $NamedNodeMap を返さ~MUST。
◎
The attributes attribute’s getter must return the associated NamedNodeMap.
</dd>

	<dt>@getAttributeNames()</dt>
	<dd>
被呼出時には、此れの`属性o~list$ %~list は［
`空$でないならば［
%~list 内の各 `属性o$の`有修飾~名$a
］からなる同じ順序の`~list$ ／
~ELSE_ 新たな`~list$
］を返さ~MUST 
◎
The getAttributeNames() method, when invoked, must return the qualified names of the attributes in context object’s attribute list, in order, and a new list otherwise.
</dd>
	<dd class="note">注記：
一意になることは保障されない。
◎
These are not guaranteed to be unique.
</dd>

	<dt>@getAttribute(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAttribute(qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%属性o ~LET
此れの`属性oを名前により取得する$( %qualifiedName )
◎
Let attr be the result of getting an attribute given qualifiedName and the context object.
</li>
			<li>
~RET ［
%属性o ~EQ ~NULL ならば ~NULL ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, return null.
◎
Return attr’s value.
</li>
		</ol>
	</dd>

	<dt>@getAttributeNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAttributeNS(namespace, localName) method, when invoked, must these steps:
</p>
		<ol>
			<li>
%属性o ~LET
此れの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
Let attr be the result of getting an attribute given namespace, localName, and the context object.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If attr is null, return null.
</li>
			<li>
~RET %属性o の`値$a
◎
Return attr’s value.
</li>
		</ol>
	</dd>

	<dt>@setAttribute(qualifiedName, value)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setAttribute(qualifiedName, value) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%qualifiedName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If qualifiedName does not match the Name production in XML, then throw an "InvalidCharacterError" DOMException.
</li>
			<li id="cp-to-lowercase-if-html">
~IF［
此れは`~HTML~ns$に属する
］~AND［
此れの`~node文書$は`~HTML文書$である
］
⇒
%qualifiedName ~SET `~ASCII小文字~化する$( %qualifiedName )
◎
If the context object is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
			<li>
%属性o ~LET 此れの`属性o~list$内の［
`有修飾~名$a ~EQ %qualifiedName
］なる`属性o$のうち，`最初のもの？$
◎
Let attribute be the first attribute in context object’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
此れに`属性oを付加する$( 次のように設定された 新たな`属性o$ )
⇒＃
`局所~名$a ~SET %qualifiedName,
`値$a ~SET %value,
`~node文書$ ~SET 此れの`~node文書$
◎
If attribute is null, create an attribute whose local name is qualifiedName, value is value, and node document is context object’s node document, then append this attribute to context object, and then return.
</li>
			<li>
~ELSE
⇒
此れの`属性oを変更する$( %属性o, %value )
◎
Change attribute from context object to value.
</li>
		</ol>
	</dd>

	<dt>@setAttributeNS(namespace, qualifiedName, value)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setAttributeNS(namespace, qualifiedName, value) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-validate-and-extract-->
			<li>
此れの`属性o値を設定する$( %局所~名, %value, %接頭辞, %~ns )
◎
Set an attribute value for the context object using localName, value, and also prefix and namespace.
</li>
		</ol>
	</dd>

	<dt>@removeAttribute(qualifiedName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`属性oを名前により除去する$( %qualifiedName )
<!-- ＊
and then return undefined.
 -->
◎
The removeAttribute(qualifiedName) method, when invoked, must remove an attribute given qualifiedName and the context object, and then return undefined.
</dd>

	<dt>@removeAttributeNS(namespace, localName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
<!-- ＊
and then return undefined.
-->
◎
The removeAttributeNS(namespace, localName) method, when invoked, must remove an attribute given namespace, localName, and context object, and then return undefined.
</dd>

	<dt>@hasAttribute(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The hasAttribute(qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-to-lowercase-if-html-->
			<li>
~RET ［
此れは次を満たす`属性o$を`有する$ならば ~T ／
~ELSE_ ~F
］
⇒
`有修飾~名$a ~EQ %qualifiedName
◎
Return true if the context object has an attribute whose qualified name is qualifiedName, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>@hasAttributeNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The hasAttributeNS(namespace, localName) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-normalize-ns0-->
			<li>
~RET ［
此れは次を満たす`属性o$を`有する$ならば ~T ／
~ELSE_ ~F
］
⇒
［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName 
］
◎
Return true if the context object has an attribute whose namespace is namespace and local name is localName, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>@getAttributeNode(qualifiedName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを名前により取得する$( %qualifiedName )
◎
The getAttributeNode(qualifiedName) method, when invoked, must return the result of getting an attribute given qualifiedName and context object.
</dd>

	<dt>@getAttributeNodeNS(namespace, localName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getAttributeNodeNS(namespace, localName) method, when invoked, must return the result of getting an attribute given namespace, localName, and the context object.
</dd>

	<dt>@setAttributeNode(attr)</dt>
	<dt>@setAttributeNodeNS(attr)</dt>
	<dd>
これらのいずれも，被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを設定する$( %attr )
◎
The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when invoked, must return the result of setting an attribute given attr and the context object.
</dd>

	<dt>@removeAttributeNode(attr)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeAttributeNode(attr) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%attr ~NIN 此れの`属性o~list$
］
⇒
~THROW `NotFoundError$E
◎
If context object’s attribute list does not contain attr, then throw a "NotFoundError" DOMException.
</li>
			<li>
此れから`属性oを除去する$( %attr )
◎
Remove attr from context object.
</li>
			<li>
~RET %attr
◎
Return attr.
</li>
		</ol>
	</dd>
</dl>

<dl class="domintro">

	<dt>%shadow = %element . $attachShadow(init)</dt>
	<dd>
%element 用に`~shadow根$を作成した上で，それを返す。
◎
Creates a shadow root for element and returns it.
</dd>

	<dt>%shadow = %element . $shadowRoot</dt>
	<dd>
%element の`~shadow根$elm %~shadow は非~NULL，かつ %~shadow の［
`~mode$sR ~EQ `open^l
］ならば %~shadow を返す。
他の場合は ~NULL を返す。
◎
Returns element’s shadow root, if any, and if shadow root’s mode is "open", and null otherwise.
</dl>

<dl class="idl-def">
	<dt>@attachShadow(init)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The attachShadow(init) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`~ns$ ~NEQ `~HTML~ns$
］
⇒
~THROW `NotSupportedError$E
◎
If context object’s namespace is not the HTML namespace, then throw a "NotSupportedError" DOMException.
</li>
			<li>
<p>
~IF［
此れの`局所~名$は 次のいずれにも該当しない
］
⇒
~THROW `NotSupportedError$E：
</p>

<ul ><li>`妥当な~custom要素~名$
</li><li>
`article^l,
`aside^l,
`blockquote^l,
`body^l,
`div^l,
`footer^l,
`h1^l,
`h2^l,
`h3^l,
`h4^l,
`h5^l,
`h6^l,
`header^l,
`nav^l,
`nav^l,
`p^l,
`section^l,
`span^l
</li></ul>

◎
If context object’s local name is not a valid custom element name, "article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main" "nav", "p", "section", or "span", then throw a "NotSupportedError" DOMException.
</li>
			<li>
~IF［
此れは`~shadow~host$である
］
⇒
~THROW `InvalidStateError$E
◎
If context object is a shadow host, then throw an "InvalidStateError" DOMException.
</li>
			<li>
%~shadow ~LET 次のようにされた，新たな`~shadow根$
⇒＃
`~node文書$ ~SET 此れの`~node文書$,
`~host$ ~SET 此れ,
`~mode$sR ~SET %init の $ShadowRootInit.mode
◎
Let shadow be a new shadow root whose node document is context object’s node document, host is context object, and mode is init’s mode.
</li>
			<li>
此れの`~shadow根$elm ~SET %~shadow
◎
Set context object’s shadow root to shadow.
</li>
			<li>
~RET %~shadow
◎
Return shadow.
</li>
		</ol>
	</dd>

	<dt>@shadowRoot</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The shadowRoot attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%~shadow ~LET 此れの `~shadow根$elm
◎
Let shadow be context object’s shadow root.
</li>
			<li>
~IF［
%~shadow ~EQ ~NULL
］~OR［
%~shadow の`~mode$sR ~EQ `closed^l
］
⇒
~RET ~NULL
◎
If shadow is null or its mode is "closed", then return null.
</li>
			<li>
~RET %~shadow
◎
Return shadow.
</li>
		</ol>
	</dd>
</dl>

<hr>

<dl class="domintro">

	<dt>%element . $closest(selectors)</dt>
	<dd>
%element の`広義先祖$であって,  %selectors に合致するような`要素$が［
在れば，それらのうち %element に最も近いもの ／
無ければ ~NULL
］を返す。
◎
Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.
</dd>

	<dt>%element . $matches(selectors)</dt>
	<dd>
%element の`根$に対し %selectors を照合した結果，［
%element が得られるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if matching selectors against element’s root yields element, and false otherwise.
</dd>

</dl>


<dl class="idl-def">
	<dt>@closest(selectors)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The closest(selectors) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>
			<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, throw a "SyntaxError" DOMException.
</li>
			<li>
%要素 ~LET 此れ
◎
↓</li>
			<li>
<p>
~WHILE［
%要素 は`要素$である
］：
</p>
				<ol>
					<li>
~IF［
`要素に対し選択子を照合する$( %要素, %選択子, 此れのみからなる`~scope-ps要素$の集合 ) ~EQ `成功^i
］
⇒
~RET %要素
</li>
					<li>
%要素 ~SET %要素 の`親$
</li>
				</ol>
`SELECTORS4$r

◎
Let elements be context object’s inclusive ancestors that are elements, in reverse tree order.
◎
For each element in elements, if match a selector against an element, using s, element, and :scope element context object, returns success, return element. [SELECTORS4]
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>

	<dt>@matches(selectors)</dt>
	<dt>@webkitMatchesSelector(selectors)</dt>
	<dd>
<p>
これらのいずれも，被呼出時には、次を走らせ~MUST：
◎
The matches(selectors) and webkitMatchesSelector(selectors) methods, when invoked, must run these steps:
</p>
		<ol>
			<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>
			<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, throw a "SyntaxError" DOMException.
</li>
			<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
`要素に対し選択子を照合する$( 此れ†, %選択子, 此れのみからなる`~scope-ps要素$の集合 ) ~EQ `成功^i
`SELECTORS4$r
◎
Return true if the result of match a selector against an element, using s, element, and :scope element context object, returns success, and false otherwise. [SELECTORS4] 
</li>
		</ol>

<p class="trans-note">【†<!-- ＊ -->
原文は 2 個目の“此れ” の代わりに~~未定義の変数 “%element” が記されているが、誤記と見られる。
】</p>

	</dd>

	<dt>@getElementsByTagName(qualifiedName)</dt>
	<dd>
被呼出時には、此れに対する， %qualifiedName を`有修飾~名に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagName(qualifiedName) method, when invoked, must return the list of elements with qualified name qualifiedName for context object.
</dd>

	<dt>@getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
被呼出時には、此れに対する，
( %namespace, %localName )
を
`( ~ns, 局所~名 ) に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagNameNS(namespace, localName) method, when invoked, must return the list of elements with namespace namespace and local name localName for context object.
</dd>

	<dt>@getElementsByClassName(classNames)</dt>
	<dd>
被呼出時には、此れに対する，
%classNames を`~classesに含む要素の~list$を返さ~MUST。
◎
The getElementsByClassName(classNames) method, when invoked, must return the list of elements with class names classNames for context object.
</dd>
</dl>

<hr>

<p class="algo-head">
`要素$ %要素 の
`隣に~nodeを挿入する@
ときは、所与の
( 文字列 %where, `~node$ %~node )
に対し，
`~ASCII小文字~化する$( %where ) の結果に応じて：
◎
To insert adjacent, given an element element, string where, and a node node, run the steps associated with the first ASCII case-insensitive match for where:
</p>

<dl class="switch">
	<dt>`beforebegin^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
			<li>
~RET
%要素 の`親$の中で`~nodeを子の前に前挿入する$( %~node, %要素 )
◎
Return the result of pre-inserting node into element’s parent before element.
</li>
		</ol>
	</dd>

	<dt>`afterbegin^l</dt>
	<dd>
		<ol>
			<li>
~RET
%要素 の中で`~nodeを子の前に前挿入する$( %~node, %要素 の`最初の子？$ )
◎
Return the result of pre-inserting node into element before element’s first child.
</li>
		</ol>
	</dd>

	<dt>`beforeend^l</dt>
	<dd>
		<ol>
			<li>
~RET
%要素 の中で`~nodeを子の前に前挿入する$( %~node, ~NULL )
◎
Return the result of pre-inserting node into element before null.
</li>
		</ol>
	</dd>

	<dt>`afterend^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
			<li>
~RET
%要素 の`親$の中で`~nodeを子の前に前挿入する$( %~node, %要素 の`次-同胞？$ )
◎
Return the result of pre-inserting node into element’s parent before element’s next sibling.
</li>
		</ol>
	</dd>

	<dt>その他</dt>
	<dd>
		<ol>
			<li>
~THROW `SyntaxError$E
◎
Throw a "SyntaxError" DOMException.
</li>
		</ol>
	</dd>
</dl>


<dl class="idl-def">
	<dt>@insertAdjacentElement(where, element)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertAdjacentElement(where, element) method, when invoked, must＼
</p>
		<ol>
			<li>
~RET
%element の`隣に~nodeを挿入する$( %where, 此れ )
◎
return the result of running insert adjacent, given context object, where, and element.
</li>
		</ol>
	</dd>

	<dt>@insertAdjacentText(where, data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertAdjacentText(where, data) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%text ~LET `新たな~Text~node$( %data, 此れの`~node文書$ )
◎
Let text be a new Text node whose data is data and node document is context object’s node document.
</li>
			<li>
此れの`隣に~nodeを挿入する$( %where, %text  )
◎
Run insert adjacent, given context object, where, and text.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methは何も返さない
— それを設計しようとする前からすでに存在していたので。
◎
This method returns nothing because it existed before we had a chance to design it.
</dd>
</dl>

<p class="trans-note">【
参考：
`insertAdjacentHTML()$m `DOM-Parsing$r という同類の便利~methもある。
】</p>


			<section id="interface-namednodemap">
<h4>4.9.1 ~ifc ^@NamedNodeMap</h4>

！！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @NamedNodeMap {
  ~RA ~UL $length;
  getter $Attr? $item(~UL %index);
  getter $Attr? $getNamedItem(~DS %qualifiedName);
  $Attr? $getNamedItemNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] $Attr? $setNamedItem($Attr %attr);
  [`CEReactions$] $Attr? $setNamedItemNS($Attr %attr);
  [`CEReactions$] $Attr $removeNamedItem(~DS %qualifiedName);
  [`CEReactions$] $Attr $removeNamedItemNS(~DS? %namespace, ~DS %localName);
};
！

<div class="p">
<p>
各 $NamedNodeMap ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`要素@nm</dt>
	<dd>
`要素$。
</dd>
</dl>
◎
A NamedNodeMap has an associated element (an element).
</div>

<p>
$NamedNodeMap ~objの
`属性o~list@nm
とは、~objの`要素$nmの`属性o~list$である。
◎
A NamedNodeMap object’s attribute list is its element’s attribute list.
</p>

<hr>

<p>
$NamedNodeMap ~obj %O が`~supportする~prop~index$は、
0 以上［
%O の`属性o~list$nmの`~size$
］未満とする。
◎
A NamedNodeMap object’s supported property indices are the numbers in the range zero to its attribute list’s size minus one, unless the attribute list is empty, in which case there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れの`属性o~list$nmの`~size$を返さ~MUST。
◎
The length attribute’s getter must return the attribute list’s size.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
%index ~NIN { 此れが`~supportする~prop~index$ } ならば~NULL ／
~ELSE_  此れの`属性o~list$nm[ %index ]
］を返さ~MUST。
◎
The item(index) method, when invoked, must run these steps:
• If index is equal to or greater than context object’s attribute list’s size, then return null.
• Otherwise, return context object’s attribute list[index].
</dd>
</dl>

<p>
$NamedNodeMap ~obj %O が`~supportする~prop名$たちは、次の手続きの結果で与えられる：
◎
A NamedNodeMap object’s supported property names are the return value of running these steps:
</p>

<ol>
	<li>
%名前~list ~LET %O の`属性o~list$nm 内の各［
`属性o$の`有修飾~名$a
］からなる，同順の~list
◎
Let names be the qualified names of the attributes in this NamedNodeMap object’s attribute list, with duplicates omitted, in order.
</li>
	<li>
%要素 ~LET %O の`要素$nm
◎
↓</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%名前~list 内の~EACH ( %名前 ) に対し
⇒
~IF［
`~ASCII小文字~化する$( %名前 ) ~NEQ %名前
］
⇒
%名前 を %名前~list から除去する
◎
If this NamedNodeMap object’s element is in the HTML namespace and its node document is an HTML document, then for each name in names:
• Let lowercaseName be name, in ASCII lowercase.
• If lowercaseName is not equal to name, remove name from names.
</li>
	<li>
~RET %名前~list
◎
Return names.
</li>
</ol>


<dl class="idl-def">
	<dt>@getNamedItem(qualifiedName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`要素$nmの`属性oを名前により取得する$( %qualifiedName )
◎
The getNamedItem(qualifiedName) method, when invoked, must return the result of getting an attribute given qualifiedName and element.
</dd>

	<dt>@getNamedItemNS(namespace, localName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`要素$nmの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getNamedItemNS(namespace, localName) method, when invoked, must return the result of getting an attribute given namespace, localName, and element.
</dd>

	<dt>@setNamedItem(attr)</dt>
	<dt>@setNamedItemNS(attr)</dt>
	<dd>
これらのいずれも，被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`要素$nmの`属性oを設定する$( %attr )
◎
The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked, must return the result of setting an attribute given attr and element.
</dd>

	<dt>@removeNamedItem(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeNamedItem(qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%属性o ~LET 此れの`要素$nmの`属性oを名前により除去する$( %qualifiedName )
◎
Let attr be the result of removing an attribute given qualifiedName and element.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a "NotFoundError" DOMException.
</li>
			<li>
~RET %属性o
◎
Return attr.
</li>
		</ol>
	</dd>

	<dt>@removeNamedItemNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeNamedItemNS(namespace, localName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%属性o ~LET
此れの`要素$nmの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
◎
Let attr be the result of removing an attribute given namespace, localName, and element.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a "NotFoundError" DOMException.
</li>
			<li>
~RET %属性o
◎
Return attr.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="interface-attr">
<h4>4.9.2. ~ifc ^@Attr</h4>

！！
[`Exposed$=Window]
interface @Attr : $Node {
  ~RA ~DS? $namespaceURI;
  ~RA ~DS? $prefix;
  ~RA ~DS $localName;
  ~RA ~DS $name;
  [`CEReactions$] attribute ~DS $value;

  ~RA Element? $ownerElement;

  ~RA ~B $specified; // <!--cp-useless-true-->
};
！

<p>
$Attr `~node$は、単に
`属性o@
（ `attribute^en ）とも称される
— ~IDL属性と区別するため、内容~属性とも称される。
【この訳では， “°” を付けて “属性o” と記すことにする。】
◎
Attr nodes are simply known as attributes. They are sometimes referred to as content attributes to avoid confusion with IDL attributes.
</p>


<div class="p">
<p>
各 `属性o$は、次に挙げるものを持つ：
</p>

<dl class="def-list">
	<dt>`~ns@a</dt>
	<dd>
~NULL または 空でない文字列
</dd>

	<dt>`~ns接頭辞@a</dt>
	<dd>
~NULL  または 空でない文字列
</dd>

	<dt>`局所~名@a</dt>
	<dd>
空でない文字列
</dd>

	<dt>`値@a</dt>
	<dd>
文字列
</dd>

	<dt>`属する要素@</dt>
	<dd>
~NULL または`要素$
</dd>
</dl>
◎
Attributes have a namespace (null or a non-empty string), namespace prefix (null or a non-empty string), local name (a non-empty string), value (a string), and element (null or an element).
</div>

<p class="note">注記：
今 設計するなら、単に［
名前, 値
］のみを持つ様にする所 ☹
◎
If designed today they would just have a name and value. ☹
</p>

<p>
`属性o$ %A の
`有修飾~名@a
は、 %A の`~ns接頭辞$a %接頭辞 に応じて，［
~NULL ならば %A の`局所~名$a ／
非 ~NULL ならば［
%接頭辞, `:^l, %A の`局所~名$a
］の並び
］になる。
◎
An attribute’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>


<p class="note">注記：
~UAは、これを内的~slotに持たせて最適化することもできる。
◎
User agents could have this as an internal slot as an optimization.
</p>

<p>
`属性o$が作成されるときは、その`局所~名$aが与えられる。
`属性o$の作成-時に明示的に与えられない限り，他のものは次のように設定される
⇒
( `~ns$a, `~ns接頭辞$a, `属する要素$, `値$a )
~SET
( ~NULL, ~NULL, ~NULL, 空~文字列 )
◎
When an attribute is created, its local name is given. Unless explicitly given when an attribute is created, its namespace, namespace prefix, and element are set to null, and its value is set to the empty string.
</p>

<p>
文字列 %A に対する
<dfn id="concept-named-attribute">%A 属性o</dfn>
という~~表記は、次を満たす `属性o$を意味する
⇒
( `局所~名$a, `~ns$a, `~ns接頭辞$a )
~EQ
( %A, ~NULL, ~NULL )
◎
An A attribute is an attribute whose local name is A and whose namespace and namespace prefix are null.
</p>

<hr>

<dl class="idl-def">
	<dt>@namespaceURI</dt>
	<dd>
取得子は、此れの`~ns$aを返さ~MUST。
◎
The namespaceURI attribute’s getter must return the namespace.
</dd>

	<dt>@prefix</dt>
	<dd>
取得子は、此れの`~ns接頭辞$aを返さ~MUST。
◎
The prefix attribute’s getter must return the namespace prefix.
</dd>

	<dt>@localName</dt>
	<dd>
取得子は、此れの`局所~名$aを返さ~MUST。
◎
The localName attribute’s getter must return the local name.
</dd>

	<dt>@name</dt>
	<dd>
取得子は、此れの`有修飾~名$aを返さ~MUST。
◎
The name attribute’s getter must return the qualified name.
</dd>
</dl>


<p class="algo-head">
`既存の属性o値を設定する@
ときは、所与の
( `属性o$ %属性o, 文字列 %値 )
に対し，次を走らす：
◎
The value attribute’s getter must return the value.
◎
To set an existing attribute value, given an attribute attribute and string value, run these steps:
</p>

<ol>
	<li>
~IF［
%属性o が`属する要素$ ~EQ ~NULL
］
⇒
%属性o の`値$a ~SET %値
◎
If attribute’s element is null, then set attribute’s value to value.
</li>
	<li>
~ELSE
⇒
%属性o が`属する要素$の`属性oを変更する$( %属性o, %値 )
◎
Otherwise, change attribute from attribute’s element to value. 
</li>
</ol>

<dl class="idl-def">
	<dt>@value</dt>
	<dd>
取得子は、此れの`値$aを返さ~MUST。
◎
↑↑</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
`既存の属性o値を設定する$( 此れ, 所与の値 )
◎
The value attribute’s setter must set an existing attribute value with context object and the given value.
</dd>

	<dt>@ownerElement</dt>
	<dd>
取得子は、此れが`属する要素$を返さ~MUST。
◎
The ownerElement attribute’s getter must return context object’s element.
</dd>

	<dt>@specified</dt>
	<dd>
取得子は、~T を返さ~MUST。
◎
The specified attribute’s getter must return true.
</dd>
</dl>

			</section>
		</section>
		<section id="interface-characterdata">
<h3>4.10. ~ifc ^@CharacterData</h3>

！！
[`Exposed$=Window]
interface @CharacterData : $Node {
  attribute [`TreatNullAs$=EmptyString] ~DS $data;
  ~RA ~UL $length;
  ~DS $substringData(~UL %offset, ~UL %count);
  void $appendData(~DS %data);
  void $insertData(~UL %offset, ~DS %data);
  void $deleteData(~UL %offset, ~UL %count);
  void $replaceData(~UL %offset, ~UL %count, ~DS %data);
};
！

<p class="note">注記：
$CharacterData は抽象~ifcであり，`~node$として存在するものではない。
それは［
$Text, $ProcessingInstruction, $Comment
］`~node$から利用される。
◎
CharacterData is an abstract interface and does not exist as node. It is used by Text, ProcessingInstruction, and Comment nodes.
</p>

<p>
この~ifcを継承する~ifcを実装する`~node$を総称して，
`文字~data~node@
という（すなわち，
$Text （ $CDATASection も含む）, $ProcessingInstruction, $Comment
）。
</p>

<p class="trans-note">【
この用語は、簡潔に記述するために，この訳に導入した非公式な用語である。
（機能上は異なるものだが）多くの処理で，これらは同等に扱われるので。
】</p>

<div class="p">
<p>
各 `文字~data~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~data@</dt>
	<dd>
変異-可能な文字列。
</dd>
</dl>
◎
Each node inheriting from the CharacterData interface has an associated mutable string called data.
</div>


<p class="algo-head">
`文字~data~node$ %node の
`~dataを置換する@
ときは、所与の
( %offset, %count, %data )
に対し，次を走らす：
◎
To replace data of node node with offset offset, count count, and data data, run these steps:
</p>

<ol>
	<li id="cp-let-node-length">
%長さ ~LET %node の`長さ$
◎
Let length be node’s length.
</li>
	<li id="cp-throw-size-err">
~IF［
%offset ~GT %長さ
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than length, then throw an "IndexSizeError" DOMException.
</li>
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~SET %長さ ~MINUS %offset
◎
If offset plus count is greater than length, then set count to length minus offset.
</li>
	<li>
%node 用に種別 `characterData^l の`変異~記録を~queueする$( ~NULL, ~NULL, %node の`~data$, « », « », ~NULL, ~NULL )
◎
Queue a mutation record of "characterData" for node with null, null, node’s data, « », « », null, and null.
</li>
	<li>
%挿入点 ~LET %node の`~data$の中の， %offset 個目の`符号単位$の直後を指す位置（ %offset ~EQ 0 は先頭を指す）
◎
↓</li>
	<li>
%挿入点 から末尾側に在る %count 個の`符号単位$を除去する
◎
↓</li>
	<li>
%挿入点 に %data を挿入する
◎
Insert data into node’s data after offset code units.
◎
Let delete offset be offset + data’s length.
◎
Starting from delete offset code units, remove count code units from node’s data.
</li>
	<li>
%差分 ~LET %data の`長さ$jStr ~MINUS %count
◎
↓</li>
	<li>
<p>
~EACH ( `~live範囲o$ %範囲o ) に対し：
</p>
		<ol>
			<li>
<p>
~IF［
%範囲o の`始端~node$ ~EQ %node
］：
</p>
				<ol>
					<li>
~IF［
%offset ~LT %範囲o の`始端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%範囲o の`始端~offset$ ~SET %offset
</li>
					<li>
~IF［
%範囲o の`始端~offset$ ~GT %offset ~PLUS %count
］
⇒
%範囲o の`始端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%範囲o の`終端~node$ ~EQ %node
］：
</p>
				<ol>
					<li>
<p>
~IF［
%offset ~LT %範囲o の`終端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%範囲o の`終端~offset$ ~SET %offset
</p>

<p class="trans-note">【
%範囲o の終端がちょうど置換される~~範囲の末尾を指している場合も，終端は置換した~~範囲の先頭に “寄せられる” ことになる。
】</p>

					</li>
					<li>
~IF［
%範囲o の`終端~offset$ ~GT %offset ~PLUS %count
］
⇒
%範囲o の`終端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
		</ol>
◎
For each live range whose start node is node and start offset is greater than offset but less than or equal to offset plus count, set its start offset to offset.
◎
For each live range whose end node is node and end offset is greater than offset but less than or equal to offset plus count, set its end offset to offset.
◎
For each live range whose start node is node and start offset is greater than offset plus count, increase its start offset by data’s length and decrease it by count.
◎
For each live range whose end node is node and end offset is greater than offset plus count, increase its end offset by data’s length and decrease it by count.
</li>
	<li>
~IF［
%node は $Text ~nodeである
］~AND［
%node の`親$ ~NEQ ~NULL
］
⇒
%node の`親$用の`子~text内容~変更-時の手続き$を走らす
◎
If node is a Text node and its parent is not null, run the child text content change steps for node’s parent.
</li>
</ol>

<p class="algo-head">
`文字~data~node$ %node から
`~dataの部分文字列@
を得るときは、所与の
( %offset, %count )
に対し，次を走らす：
◎
To substring data with node node, offset offset, and count count, run these steps:
</p>

<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~LET %長さ ~MINUS %offset
◎
If offset plus count is greater than length, return a string whose value is the code units from the offsetth code unit to the end of node’s data, and then return.
</li>
	<li>
~RET 
%node の`~data$の［
%offset 個目の`符号単位$の直後（ %offset ~EQ 0 なら先頭）から，
%count 個の`符号単位$
］並びからなる文字列
◎
Return a string whose value is the code units from the offsetth code unit to the offset+countth code unit in node’s data.
</li>
</ol>

<dl class="idl-def">
	<dt>@data</dt>
	<dd>
取得子は、此れの`~data$を返さ~MUST。
◎
The data attribute’s getter must return context object’s data.＼
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
此れの`~dataを置換する$( 0, 此れの`長さ$, 所与の値 )
◎
Its setter must replace data with node context object, offset 0, count context object’s length, and data new value.
</dd>

	<dt>@length</dt>
	<dd>
取得子は、此れの`長さ$を返さ~MUST。
◎
The length attribute’s getter must return context object’s length.
</dd>

	<dt>@substringData(offset, count)</dt>
	<dd>
被呼出時には、此れの`~dataの部分文字列$( %offset, %count )
を返さ~MUST
◎
The substringData(offset, count) method, when invoked, must return the result of running substring data with node context object, offset offset, and count count.
</dd>

	<dt>@appendData(data)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( 此れの`長さ$, 0, %data )
◎
The appendData(data) method, when invoked, must replace data with node context object, offset context object’s length, count 0, and data data.
</dd>

	<dt>@insertData(offset, data)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( %offset, 0, %data )
◎
The insertData(offset, data) method, when invoked, must replace data with node context object, offset offset, count 0, and data data.
</dd>

	<dt>@deleteData(offset, count)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( %offset, %count, 空~文字列 )
◎
The deleteData(offset, count) method, when invoked, must replace data with node context object, offset offset, count count, and data the empty string.
</dd>

	<dt>@replaceData(offset, count, data)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( %offset, %count, %data )
◎
The replaceData(offset, count, data) method, when invoked, must replace data with node context object, offset offset, count count, and data data.
</dd>
</dl>

		</section>
		<section id="interface-text">
<h3>4.11. ~ifc ^@Text</h3>

！！
[$Constructor(optional ~DS %data = ""),
 `Exposed$=Window]
interface @Text : $CharacterData {
  [`NewObject$] $Text $splitText(~UL %offset);
  ~RA ~DS $wholeText;
};
！

<hr>

<dl class="domintro">
	<dt>%text = new $Text([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a new Text node whose data is data.
</dd>

	<dt>%text . $splitText(offset)</dt>
	<dd>
所与の %offset の地点で`~data$を分割し，残りの部分を $Text `~node$として返す。
◎
Splits data at the given offset and returns the remainder as Text node.
</dd>

	<dt>%text . $wholeText</dt>
	<dd>
隣接するすべての`同胞$ $Text `~node$の`~data$を連結した結果を返す。
◎
Returns the combined data of all direct Text node siblings.
</dd>

</dl>

<hr>

<p>
`新たな~Text~node@( %文字列, %文書 )
という表記は、次のように設定された 新たな $Text `~node$を意味する
⇒
( `~data$, `~node文書$ ) ~SET ( %文字列, %文書 )
</p>

<p class="trans-note">【
この表記は、簡潔に記述するため，この訳に導入したものである。
】</p>

<p>
`狭義の~Text~node@
とは、 $CDATASection `~node$でない $Text `~node$である。
◎
An exclusive Text node is a Text node that is not a CDATASection node.
</p>

<p>
~node %~node を含む
`連続的な~Text~node列@
とは、条件［
$Text `~node$である
］を満たす， %~node を含む`連続的な同胞~列$である。
◎
The contiguous Text nodes of a node node are node, node’s previous sibling Text node, if any, and its contiguous Text nodes, and node’s next sibling Text node, if any, and its contiguous Text nodes, avoiding any duplicates.
</p>

<p>
~node %~node を含む
`連続的な狭義の~Text~node列@
とは、条件［
`狭義の~Text~node$である
］を満たす， %~node を含む`連続的な同胞~列$である。
◎
The contiguous exclusive Text nodes of a node node are node, node’s previous sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, and node’s next sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
</p>

<p class="trans-note">【
この訳では、次の手続きを導入して，原文による “連続的な…” の（再帰的な）定義を、等価な（かつ平坦化された平易な）定義に変形している。
】</p>

<div>

<p class="algo-head">
条件 %条件 を満たす， %~node を含む
`連続的な同胞~列@
は、次を走らせた結果で与えられる：
</p>

<ol>
	<li>
~Assert：
%~node は %条件 を満たす
</li>
	<li>
~WHILE［
%~node の`前-同胞？$は %条件 を満たす
］
⇒
%~node ~SET %~node の`前-同胞？$
</li>
	<li>
%~list ~LET 空~list
</li>
	<li>
<p>
~WHILE［
%~node は %条件 を満たす
］：
</p>
		<ol>
			<li>
%~list に %~node を付加する
</li>
			<li>
%~node ~SET %~node の`次-同胞？$
</li>
		</ol>
	</li>
	<li>
~RET %~list
</li>
</ol>

◎
↑</div>

<p class="algo-head">
`~node$ %~node の
`子~text内容@
は、次を`連結-$した結果である
⇒
`木~順序$による，［
%~node の`子$のうち $Text ~nodeであるもの
］すべての`~data$
◎
The child text content of a node node is the concatenation of the data of all the Text node children of node, in tree order. 
</p>

<p>
`適用-可能な仕様$は、`~node$用に
`子~text内容~変更-時の手続き@
を定義しても~MAY。
◎
This and other specifications may define child text content change steps for nodes. 
</p>

<hr>

<dl class="idl-def">
	<dt>@Text(data)</dt>
	<dd>
この構築子の被呼出時には、`新たな~Text~node$( %data, `現在の大域~obj$に`結付けられている文書$ )
を返さ~MUST
◎
The Text(data) constructor, when invoked, must return a new Text node whose data is data and node document is current global object’s associated Document.
</dd>
</dl>

<p class="algo-head">
`~Text~nodeを分割する@
ときは、所与の
( $Text `~node$ %node, ~offset %offset )
に対し，次を走らす：
◎
To split a Text node node with offset offset, run these steps:
</p>

<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
%count ~LET %長さ ~MINUS %offset
◎
Let count be length minus offset.
</li>
	<li>
%新-~data ~LET
此れの`~dataの部分文字列$( %offset, %count )
◎
Let new data be the result of substringing data with node node, offset offset, and count count.
</li>
	<li>
%新-~node ~LET `新たな~Text~node$( %新-~data, %node の`~node文書$ )
◎
Let new node be a new Text node, with the same node document as node. Set new node’s data to new data.
</li>
	<li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
	<li>
<p>
~IF［
%親 ~NEQ ~NULL
］：
◎
If parent is not null, then:
</p>
		<ol>
			<li>
%親 の中で`~nodeを子の前に挿入する$( %新-~node, %node の`次-同胞？$ )
◎
Insert new node into parent before node’s next sibling.
</li>
			<li>
<p>
~EACH ( `~live範囲o$ %範囲o ) に対し：
◎
↓</p>
				<ol>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %node
］~AND［
%範囲o の`始端~offset$ ~GT %offset
］
⇒＃
%範囲o の`始端~node$ ~SET %新-~node；
%範囲o の`始端~offset$ ~DECBY %offset
◎
For each live range whose start node is node and start offset is greater than offset, set its start node to new node and decrease its start offset by offset.
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %node
］~AND［
%範囲o の`終端~offset$ ~GT %offset
］
⇒＃
%範囲o の`終端~node$ ~SET %新-~node；
%範囲o の`終端~offset$ ~DECBY %offset
◎
For each live range whose end node is node and end offset is greater than offset, set its end node to new node and decrease its end offset by offset.
</li>
					<li>
~IF［
%範囲o の`始端~node$ ~EQ %親
］~AND［
%範囲o の`始端~offset$ ~EQ %node の`指数$ ~PLUS 1
］
⇒
%範囲o の`始端~offset$ ~INCBY 1
◎
For each live range whose start node is parent and start offset is equal to the index of node plus 1, increase its start offset by 1.
</li>
					<li>
~IF［
%範囲o の`終端~node$ ~EQ %親
］~AND［
%範囲o の`終端~offset$ ~EQ %node の`指数$ ~PLUS 1
］
⇒
%範囲o の`終端~offset$ ~INCBY 1
◎
For each live range whose end node is parent and end offset is equal to the index of node plus 1, increase its end offset by 1.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%node の`~dataを置換する$( %offset, %count, 空~文字列 )
◎
Replace data with node node, offset offset, count count, and data the empty string.
</li>
	<li>
~RET %新-~node
◎
Return new node.
</li>
</ol>

<dl class="idl-def">
	<dt>@splitText(offset)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET `~Text~nodeを分割する$( 此れ, %offset )
◎
The splitText(offset) method, when invoked, must split context object with offset offset.
</dd>

	<dt>@wholeText</dt>
	<dd>
取得子は、次を`連結-$した結果を返さ~MUST
⇒
`木~順序$による，此れを含む`連続的な~Text~node列$を成すすべての~nodeの`~data$。
◎
The wholeText attribute’s getter must return the concatenation of the data of the contiguous Text nodes of the context object, in tree order.
</dd>
</dl>
		</section>
		<section id="interface-cdatasection">
<h3>4.12. ~ifc ^@CDATASection</h3>

！！
[`Exposed$=Window]
interface @CDATASection : $Text {
};
！

<!--  -->

		</section>
		<section id="interface-processinginstruction">
<h3>4.13. ~ifc ^@ProcessingInstruction</h3>

！！
[`Exposed$=Window]
interface @ProcessingInstruction : $CharacterData {
  ~RA ~DS $target;
};
！

<div class="p">
<p>
各 $ProcessingInstruction `~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~target@pI</dt>
	<dd>
文字列。
</dd>
</dl>
◎
ProcessingInstruction nodes have an associated target.
</div>


<dl class="idl-def">
	<dt>@target</dt>
	<dd>
取得子は、此れの`~target$pIを返さ~MUST。
◎
The target attribute must return the target.
</dd>
</dl>

		</section>
		<section id="interface-comment">
<h3>4.14. ~ifc ^@Comment</h3>

！！
[$Constructor(optional ~DS %data = ""),
 `Exposed$=Window]
interface @Comment : $CharacterData {
};
！

<dl class="domintro">
	<dt>%comment = new $Comment([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a new Comment node whose data is data.
</dd>
</dl>

<dl class="idl-def">
	<dt>@Comment(data)</dt>
	<dd>
この構築子の被呼出時には、次のように設定された 新たな $Comment `~node$を返さ~MUST
⇒＃
`~data$ ~SET %data,
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The Comment(data) constructor, when invoked, must return a new Comment node whose data is data and node document is current global object’s associated Document.
</dd>
</dl>

		</section>
	</section>
	<section id="ranges">
<h2 title="Ranges">5. 範囲o</h2>

		<section id="introduction-to-dom-ranges">
<h3 title="Introduction to “DOM Ranges”">5.1. “DOM Ranges” 序論</h3>

<p>
［
$StaticRange ／ $Range
］~obj （ `範囲o$ ）は`~node木$の中の連続する内容を表現する。
各 `範囲o$ は、`境界点$と呼ばれる［
( `始端$, `終端$ )
が成す`~tuple$
］を持つ。
各 `境界点$は、
( `~node$bp, `~offset$bp )
が成す`~tuple$である。
言い換えれば、`範囲o$は`~node木$の中の 2 つの`境界点$に挟まれる
`中身@rg
を表現する。
◎
StaticRange and Range objects (ranges) represent a sequence of content within a node tree. Each range has a start and an end which are boundary points. A boundary point is a tuple consisting of a node and an offset. So in other words, a range represents a piece of content within a node tree between two boundary points.
</p>

<p>
`範囲o$は、編集における 内容の選択や複製に よく利用される。
例えば 次の`~node木$が与えられたとき：
◎
Ranges are frequently used in editing for selecting and copying content.
</p>

<ol class="domTree"><li>`要素$: `p^e
	<ol><li>`要素$: `img^e,
		<span>^src=`insanity-wolf^l</span>
		<span>^alt=`Little-endian BOM; decode as big-endian!^l</span>
	</li><li>$Text:
		<samp>&nbsp;CSS 2.1 syndata is&nbsp;</samp>
	</li><li>`要素$: `em^e
		<ol><li>$Text: <samp>awesome</samp>
		</li></ol>
	</li><li>$Text: <samp>!</samp>
	</li></ol>
</li></ol>

<p>
次の様にして，
`syndata is awes^l
の並びを表現する`範囲o$が得られる（変数［
%p ／ %em
］には［
`p^e ／ `em^e
］`要素$が割当されているとする）：
◎
In the node tree above, a range can be used to represent the sequence “syndata is awes”. Assuming p is assigned to the p element, and em to the em element, this would be done as follows:
</p>

<pre class="js-code">
var %range = new Range(),
    %text1 = %p.childNodes[1],
    %text2 = %em.firstChild
%range.setStart(%text1, 9) /* <span class="comment">
先頭の空白も数に入れる
◎
do not forget the leading space
</span> */
%range.setEnd(%text2, 4)
/* <span class="comment">
%range を<a href="#dom-range-stringifier">文字列化-</a>した結果は、今や先に示した文字列になる
◎
range now stringifies to the aforementioned quote
</span> */
</pre>

<p class="note">注記：
`範囲o$は、上の`~node木$の ^src や ^alt などの`属性o$は表現できない。
`範囲o$は`~node$用に限り有用になる。
◎
Attributes such as src and alt in the node tree above cannot be represented by a range. Ranges are only useful for nodes.
</p>

<p>
$StaticRange ~objと違って、
$Range ~objは，`~node木$に対する変異に影響される。
なので、`~live範囲o$とも称される。
その種の変異によりそれらが無効化されることはなく，可能なら内容の同じ部分を表現するようにされる。
`~live範囲o$は、`~node木$に対する変異
— 自身が表現する`中身$rgの一部が変異したときなど —
に伴い，必要に応じて自身も改変され得る。
◎
Range objects, unlike StaticRange objects, are affected by mutations to the node tree. Therefore they are also known as live ranges. Such mutations will not invalidate them and will try to ensure that it still represents the same piece of content. Necessarily, a live range might itself be modified as part of the mutation to the node tree when, e.g., part of the content it represents is mutated.
</p>

<p>
詳細は、次に挙げる各種~algo／~methを見よ
⇒＃
`~nodeを子の前に挿入する$,
`子を除去する$
$Node.normalize(),
`~dataを置換する$,
`~Text~nodeを分割する$
◎
See the insert and remove algorithms, the normalize() method, and the replace data and split algorithms for the hairy details.
</p>

<p class="trans-note">【
例えば，範囲oの境界点が ある~nodeの “内部” を指していて, その~nodeが木から除去された場合、その境界点は “~nodeが抜けた穴” を指すようにされる（始端と終端が別々の木の中を指さないようにされる）。
始端と終端の両者が同じ~nodeの内部を指していたとしても、除去された~nodeの内部を指すことはなく，それらは同じ “穴” を指す様に畳まれることになる。
】</p>

		</section>
		<section id="boundary-points">
<h3 title="Boundary points">5.2. 境界点</h3>

<p>
`境界点@
とは、［
`~node@bp
（`~node$）,
`~offset@bp
（非負~整数）
］が成す`~tuple$である。
◎
A boundary point is a tuple consisting of a node (a node) and an offset (a non-negative integer).
</p>

<p class="trans-note">【
以下では，所与の［
`~node$ %node, `~offset$bp %offset
］で初期化された`境界点$を、
“境界点( %node, %offset )”
の様に表記する。
】</p>

<p class="note">注記：
正しい`境界点$の`~offset$bpは、
0 以上, `境界点$の`~node$bpの`長さ$以下になる。
◎
A correct boundary point’s offset will be between 0 and the boundary point’s node’s length, inclusive.
</p>



<div class="trans-note">
<p>【
~HTMLや~XMLの~source~textの中では，境界点は、すべての~text~data（`文字~data~node$）を “仮想の” 開始~tag, 終了~tag で括り,
すべての空~要素は 開始／終了 ~tagの組に置換した上で，すべての［
~tag, および
文字~dataを成す`符号単位$たち
］それぞれを点に見立てて，~sourceに現れる順に一列に並べたときの，隣接する任意の 2 つの点の隙間を指すものと見なせる。
</p>

<p>
例えば
"<samp>&lt;b&gt;text&lt;/b&gt;</samp>"
のような~markupの中の，［
開始~tag "<samp>&lt;b&gt;</samp>"
］と［
"<samp>text</samp>" の先頭
］との隙間を指す境界点には、
"<samp>text</samp>" ~node の［
内縁（“仮想の”~tagの内縁）を指すもの, および
外縁を指すもの
］があり、また，境界点は［
"<samp>&lt;br&gt;</samp>"
のような空~tag ／
~dataが空の`文字~data~node$
］の内部も指し得る†。
</p>

<p>†
唯一の~~例外は，`~doctype$であり、境界点は~doctypeの内部は<a href="#concept-range-bp-set">指し得ない</a>ようにされている
— したがってこの~modelでは，一個の “点” になる。
</p>

<p>
文書の~node木の一例とそのすべての境界点を示す模式図を次に示す。
縦棒  "|" が境界点が指し得る位置を表し，ドット "." が文字~dataの各~文字を表す（
<a href="#example-tree">先掲の模式図</a>
同様，左端が文書の先頭, 右端が文書の末尾，横線は木の中の各 ~nodeが文書~内を占める~~範囲を表し，~COLOR_Rは`文字~data~node$を表す）：
</p>

`[|*|(|A)|[|[|B]|(|.|)|C(|.|.|)|[|(|.|)|]|[|]|(|.|.|)|[x|0(|.|)|1[|(|.|)|]|2[|(|.|.|.|)|[|(|.|)|]|]|3(|.|.|)|4]|]|(|.|.|)|]^bpex

<p>
境界点を表す縦棒の直上の横線がその境界点の~nodeを表す。
境界点の~offsetは、図の中では，その境界点を表す縦棒の直上の横線直下にあって, その縦棒より左側に位置する縦棒の本数になる（境界点の~nodeが図の~COLOR_Xならば、その直下の各数字がその境界点の~offset）。
</p>

<p>
図の先頭の `*^c は`~doctype$を表す（内部に境界点は無い）。
その次の孤立した `A^c は~dataが空の`文字~data~node$の内部を指す（唯一の）境界点を表し，その次の `B^c は内容が空の要素の内部を指す境界点を表し，~~後続の 2 個の~COLOR_Rは 2 個の`文字~data~node$が境界点（ `C^c ）を挟んで間を置かずに連続していることを表している。
】</p>

</div>


<p class="algo-head">
`境界点$ %A の［
`境界点$ %B に
`相対的な位置bp@
］が， %B ［
`より前@i ／
`に等しい@i ／
`より後@i
］のいずれかになるかは、次に従って決定される：
◎
The position of a boundary point (nodeA, offsetA) relative to a boundary point (nodeB, offsetB) is before, equal, or after, as returned by these steps:
</p>

<p class="trans-note">【
この~algoは、 2 つの境界点に対し，上に示した様な模式図における位置関係（左側が “より前” ）を算出する。
】</p>

<ol>
	<li>
( %nodeA, %offsetA, %nodeB, %offsetB )
~LET
( %A の`~node$bp, %A の`~offset$bp, %B の`~node$bp, %B の`~offset$bp )
◎
↑</li>
	<li>
~Assert：
%nodeA の`根$ ~EQ %nodeB の`根$
◎
Assert: nodeA and nodeB have the same root.
</li>
	<li>
~IF［
%nodeA ~EQ %nodeB
］
⇒
~RET ［
%offsetA ~LT %offsetB ならば `より前$i ／
%offsetA ~EQ %offsetB ならば `に等しい$i ／
%offsetA ~GT %offsetB ならば `より後$i
］
◎
If nodeA is nodeB, then return equal if offsetA is offsetB, before if offsetA is less than offsetB, and after if offsetA is greater than offsetB.
</li>
	<li>
~IF［
%nodeA は %nodeB に`後続-$する
］
⇒
~RET 
%B は %A ［
`より前$i ならば `より後$i ／
`より後$i ならば `より前$i
］
<!-- に等しい にはならない -->
◎
If nodeA is following nodeB, then if the position of (nodeB, offsetB) relative to (nodeA, offsetA) is before, return after, and if it is after, return before.
</li>
	<li>
<p>
~IF［
%nodeA は %nodeB の`先祖$である
］：
◎
If nodeA is an ancestor of nodeB:
</p>
		<ol>
			<li>
%子 ~LET %nodeB
◎
Let child be nodeB.
</li>
			<li>
~WHILE［
%子 の`親$ ~NEQ %nodeA
］
⇒
%子 ~SET %子 の`親$
◎
While child is not a child of nodeA, set child to its parent.
</li>
			<li>
~IF［
%子 の`指数$ ~LT %offsetA
］
⇒
~RET `より後$i
◎
If child’s index is less than offsetA, then return after.
</li>
		</ol>
	</li>
	<li>
~RET `より前$i
◎
Return before.
</li>
</ol>

		</section>
		<section id="interface-abstractrange">
<h3>5.3. ~ifc ^@AbstractRange</h3>

！！
[`Exposed$=Window]
interface @AbstractRange {<!-- ^@Range -->
  ~RA $Node $startContainer;
  ~RA ~UL $startOffset;
  ~RA $Node $endContainer;
  ~RA ~UL $endOffset;
  ~RA ~B $collapsed;
};
！

<p>
$AbstractRange ~ifcを実装する~objは単に
`範囲o@
とも称される。
◎
Objects implementing the AbstractRange interface are known as ranges.
</p>

<p class="trans-note">【
一般語の “~~範囲” と区別し易くするため、この訳では， “°” を付けて “範囲o” と記すことにする（
“DOM range”, “~~範囲~obj”
などの呼称もあるが）。
】</p>

<p>
各 `範囲o$には、 2 つの`境界点$
`始端@,
`終端@
が結付けられる。
◎
A range has two associated boundary points — a start and end.
</p>

<p>
便宜のため、`範囲o$の：
◎
For convenience,＼
</p>

<ul>
	<li>
(
`始端~node@,
`始端~offset@
) は、順に，`始端$の
( `~node$bp, `~offset$bp )
を指すとする。
◎
a range’s start node is its start’s node, its start offset is its start’s offset,＼
</li>
	<li>
(
`終端~node@,
`終端~offset@
) は、順に，`終端$の
( `~node$bp, `~offset$bp )
を指すとする。
◎
its end node is its end’s node, and its end offset is its end’s offset.
</li>
</ul>

<p>
所与の`範囲o$は、次を満たすとき
`畳まれて@
いるとされる
<!-- 等bp -->
⇒
［
`始端~node$ ~EQ `終端~node$
］~AND［
`始端~offset$ ~EQ `終端~offset$
］
◎
A range is collapsed if its start node is its end node and its start offset is its end offset.
</p>

<dl class="domintro">
	<dt>%node = %range . $startContainer</dt>
	<dd>
%range の`始端~node$を返す。
◎
Returns range’s start node.
</dd>

	<dt>%offset = %range . $startOffset</dt>
	<dd>
%range の`始端~offset$を返す。
◎
Returns range’s start offset.
</dd>

	<dt>%node = %range . $endContainer</dt>
	<dd>
%range の`終端~node$を返す。
◎
Returns range’s end node.
</dd>

	<dt>%offset = %range . $endOffset</dt>
	<dd>
%range の`終端~offset$を返す。
◎
Returns range’s end offset.
</dd>

	<dt>%collapsed = %range . $collapsed</dt>
	<dd>
%range は`畳まれて$いるならば ~T を,
他の場合は~F を返す。
◎
Returns true if range is collapsed, and false otherwise.
</dd>
</dl>


<dl class="idl-def">
	<dt>@startContainer</dt>
	<dd>
取得子は、此れの`始端~node$を返さ~MUST。
◎
The startContainer attribute’s getter must return the context object’s start node.
</dd>

	<dt>@startOffset</dt>
	<dd>
取得子は、此れの`始端~offset$を返さ~MUST。
◎
The startOffset attribute’s getter must return the context object’s start offset.
</dd>

	<dt>@endContainer</dt>
	<dd>
取得子は、此れの`終端~node$を返さ~MUST。
◎
The endContainer attribute’s getter must return the context object’s end node.
</dd>

	<dt>@endOffset</dt>
	<dd>
取得子は、此れの`終端~offset$を返さ~MUST。
◎
The endOffset attribute’s getter must return the context object’s end offset.
</dd>

	<dt>@collapsed</dt>
	<dd>
取得子は、［
此れは次を満たすならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
`畳まれて$いる
◎
The collapsed attribute’s getter must return true if the context object is collapsed, and false otherwise.
</dd>
</dl>

		</section>
		<section id="interface-staticrange">
<h3>5.4. ~ifc ^@StaticRange</h3>

！！
[`Exposed$=Window]
interface @StaticRange : $AbstractRange {
};
！

<p class="note">
将来~versionの ^StaticRange ~ifcは、例外を投出しない構築子を供することになる。
◎
A future version of the StaticRange interface will provide a non-throwing constructor.
</p>

		</section>
		<section id="interface-range">
<h3>5.5. ~ifc ^@Range</h3>

！！
[$Constructor,
 `Exposed$=Window]
interface @Range : $AbstractRange {
  ~RA $Node $commonAncestorContainer;

  void $setStart($Node %node, ~UL %offset);
  void $setEnd($Node %node, ~UL %offset);
  void $setStartBefore($Node %node);
  void $setStartAfter($Node %node);
  void $setEndBefore($Node %node);
  void $setEndAfter($Node %node);
  void $collapse(optional ~B %toStart = false);
  void $selectNode($Node %node);
  void $selectNodeContents($Node %node);

  ~CUS @START_TO_START = 0;
  ~CUS @START_TO_END = 1;
  ~CUS @END_TO_END = 2;
  ~CUS @END_TO_START = 3;
  short $compareBoundaryPoints(~US %how, $Range %sourceRange);

  [`CEReactions$] void $deleteContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $extractContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $cloneContents();
  [`CEReactions$] void $insertNode($Node %node);
  [`CEReactions$] void $surroundContents($Node %newParent);

  [`NewObject$] $Range $cloneRange();
  void $detach();

  ~B $isPointInRange($Node %node, ~UL %offset);
  short $comparePoint($Node %node, ~UL %offset);

  ~B $intersectsNode($Node %node);

  $stringifier;
};
！

<p>
$Range ~ifcを実装する~objは単に
`~live範囲o@
とも称される。
◎
Objects implementing the Range interface are known as live ranges.
</p>


<p class="note">注記：
`木$を改変する~algo（特に，
`~nodeを子の前に挿入する$,
`子を除去する$,
`~dataを置換する$,
`~Text~nodeを分割する$
）は、その`木$に結付けられている一連の`~live範囲o$も改変する。
◎
Algorithms that modify a tree (in particular the insert, remove, replace data, and split algorithms) modify live ranges associated with that tree.
</p>

<p>
`~live範囲o$の
`根@rg
とは、その`始端~node$の`根$である。
◎
The root of a live range is the root of its start node.
</p>

<p class="trans-note">【
`終端~node$の`根$と同じになる（常にそうなるように拘束される）。
各 `~live範囲o$は、その作成-時からずっと，同じある`~node木$に結付けられ続ける
— 言い換えれば、`根$rgは変化しない。
（仕様には明示的にそう述べられてはいないが、各種~algoの挙動から，そう結論できる。
一般の`範囲o$についても同じことが言えるかどうかは、はっきりしない。）
】</p>

<p>
次をいずれも満たす`~node$ %node は、`~live範囲o$ %範囲o に
`包含され@
ているとされる：
◎
A node node is contained in a live range range if＼
</p>
<ul>
	<li>
%node の`根$ ~EQ %範囲o の`根$rg
◎
node’s root is range’s root, and ＼
</li>
	<li>
`境界点$( %node, 0 ) は %範囲o の`始端$`より後$i
◎
(node, 0) is after range’s start, and＼
</li>
	<li>
`境界点$( %node, %node の`長さ$ ) は %範囲o の`終端$`より前$i
◎
(node, node’s length) is before range’s end.
</li>
</ul>

<p>
次のいずれかを満たす`~node$ %node は、`~live範囲o$ %範囲o に
`部分的に包含され@
ているとされる：
◎
A node is partially contained in a live range if＼
</p>
<ul>
	<li>
［
%node は %範囲o の`始端~node$の`広義先祖$である
］~AND［
%node は %範囲o の`終端~node$の`広義先祖$でない
］
◎
it’s an inclusive ancestor of the live range’s start node but not its end node, or＼
</li>
	<li>
［
%node は %範囲o の`始端~node$の`広義先祖$でない
］~AND［
%node は %範囲o の`終端~node$の`広義先祖$である
］
◎
vice versa.
</li>
</ul>

<div class="trans-note">
<p>【
次の図は先掲の模式図と同様に木を表したものであり，図の記号 `s^c が始端, `e^c が終端を表すとする。
このとき、図の~COLOR_Xの~nodeが包含され, ~COLOR_Yの~node（始端／終端の一方のみを内部に含む~node）が部分的に包含される。
最上層の横線の~nodeは 内部に `s^c, `e^c とも含むので、~~定義により，`部分的に包含され$ることはない。
】</p>

`[|(|.|)|[|]|[y|(y|.|.|s)|]|[x|(x|.|)|]|(x|.|.|.|)|[x|]|(x|.|.|)|[y|(x|.|)|[x|(x|.|)|]|[y|(y|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]|]^bpex

</div>

<div class="note">
<p>注記：
これらの定義をより理解し易くする事実をいくつか挙げる：
◎
Some facts to better understand these definitions:
</p>

<ul>
	<li>
`~live範囲o$の`中身$rgは、`包含され$ているすべての`~node$に加えて，［
`文字~data~node$であるような［［
`始端~node$ ／ `終端~node$
］の`広義子孫$
］のうち，範囲oに入る部分
］からなるものとみなせる。
◎
The content that one would think of as being within the live range consists of all contained nodes, plus possibly some of the contents of the start node and end node if those are Text, ProcessingInstruction, or Comment nodes.
</li>
	<li>
`~live範囲o$に`包含され$ている`~node$たちの集合は、`包含され$ている`~node$の`親$が常に`包含され$るとは限らないので，一般に連続的でない。
◎
The nodes that are contained in a live range will generally not be contiguous, because the parent of a contained node will not always be contained.
</li>
	<li>
しかしながら，`包含され$ている`~node$の`子孫$は`包含され$ており、 2 つの`同胞$が`包含され$ているならば，それらの間に位置するどの`同胞$も`包含され$る。
◎
However, the descendants of a contained node are contained, and if two siblings are contained, so are any siblings that lie between them.
</li>
	<li>
`~live範囲o$の`始端~node$ と`終端~node$ は決して その範囲oに`包含され$ない。
◎
The start node and end node of a live range are never contained within it.
</li>
	<li>
`包含され$ている`~node$のうち、最初のもの（もし在れば）は，常に`始端~node$に`後続-$し、最後のものは，常に`終端~node$の最後の`子孫$と同じか, それに`先行-$する。
<!-- descendant を持たない場合は？ -->
◎
The first contained node (if there are any) will always be after the start node, and the last contained node will always be equal to or before the end node’s last descendant.
</li>
	<li>
部分的に包含される`~node$が存在するのは、`始端~node$ と`終端~node$ が異なるとき, そのときに限る。
◎
There exists a partially contained node if and only if the start node and end node are different.
</li>
	<li>
`始端~node$と`終端~node$の`共通の広義先祖$は、`包含され$ることも, `部分的に包含され$ることもない。
◎
The commonAncestorContainer attribute value is neither contained nor partially contained.
</li>
	<li>
<p>
`始端~node$ %A が `終端~node$ %B の`先祖$である場合：
</p>
<ul ><li>%A が， %A, %B に`共通の広義先祖$になる。
</li><li>%A の`子$のうち， 1 つだけ（ %C とする）が`部分的に包含され$る。
</li><li>%A の別の`子$ %C1 が`包含され$るのは、 %C1 が %C に`先行-$するとき, そのときに限る。
</li></ul>

<div class="trans-note">
<p>【
この場合の例。
前と同様，記号 `s^c は始端, `e^c は終端を表す。
この例では図の最上層の~nodeが共通の広義先祖になる。
共通の広義先祖の子のうち、~COLOR_Yの~nodeが上述の %C （共通の広義先祖の子であってかつ部分的に包含される）に該当し，~COLOR_Xの~nodeが`包含され$る子になる。
】</p>

`[|(|.|)|s[x|(|.|)|]|(x|.|.|)|[x|(|.|.|)|]|[y|[|(|.|)|]|(|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]^bpex

</div>

<p>
%B が %A の`先祖$である場合、前述の逆になる。
【上の図で、 `s^c と `e^c を入れ替えて，右端から木の順序が開始されていると考えるとよい。】
</p>

◎
If the start node is an ancestor of the end node, the common inclusive ancestor will be the start node. Exactly one of its children will be partially contained, and a child will be contained if and only if it precedes the partially contained child. If the end node is an ancestor of the start node, the opposite holds.
</li>
	<li>
`始端~node$ %A, `終端~node$ %B とも他方の`広義先祖$でない場合：
%A, %B の`共通の広義先祖$ %先祖 は、 %A とも %B とも異なる。
%先祖 の`子$のうち，ちょうど 2 個が`部分的に包含され$、
%先祖 の`子$が`包含され$るのは，これら 2 個の合間にあるとき, そのときに限る。
◎
If the start node is not an inclusive ancestor of the end node, nor vice versa, the common inclusive ancestor will be distinct from both of them. Exactly two of its children will be partially contained, and a child will be contained if and only if it lies between those two.
</li>
</ul>
</div>

<hr>

<dl class="domintro">
	<dt>%range = new $Range()</dt>
	<dd>
新たな`~live範囲o$を返す。
◎
Returns a new live range.
</dd>
</dl>

<dl class="idl-def">
	<dt>@Range()</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
</li>
			<li>
~RET 次のように設定された 新たな $Range
⇒＃
`始端$ ~SET `境界点$( %文書, 0 ) ,
`終端$ ~SET `境界点$( %文書, 0 )
</li>
		</ol>
◎
The Range() constructor, when invoked, must return a new live range with (current global object’s associated Document, 0) as its start and end.
</dd>
</dl>


<dl class="domintro">
	<dt>%container = %range . $commonAncestorContainer</dt>
	<dd>
%range の`始端~node$と`終端~node$の両方の`広義先祖$であるような，最も末端の~nodeを返す。
【原文の “ancestor” （先祖）は~~厳密な記述ではない。】
◎
Returns the node, furthest away from the document, that is an ancestor of both range’s start node and end node.
</dd>
</dl>

<dl class="idl-def">

	<dt>@commonAncestorContainer</dt>
	<dd>
取得子は、此れの
( `始端~node$, `終端~node$ )
の`共通の広義先祖$を返さ~MUST。
◎
The commonAncestorContainer attribute’s getter must run these steps: 
• Let container be start node.
• While container is not an inclusive ancestor of end node, let container be container’s parent.
• Return container.
</dd>
</dl>

<div>
<p class="algo-head">
【この訳では便宜のため，次を定義する：】
同じ木に`関与して$いる 2 つの~node %A, %B の（最も末端の）
`共通の広義先祖@
とは、次の~algoを走らせた結果である：
</p>

<ol>
	<li>
~WHILE［
%A は %B の`広義先祖$でない
］
⇒
%A ~SET %A の`親$
</li>
	<li>
~RET %A
</li>
</ol>

◎
↑</div>

<hr>

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methは、範囲oの片方または両方の境界点を新たな地点に変更する。
片方の境界点（以下， %P ）のみを変更する~methについては、整合性を保つため，もう片方の境界点（以下， %Q ）も必要に応じて~~正される：
すなわち， %Q が［
%P と異なる木の中に在る, または［
%P `より前$i（始端が変更された場合） ／
%P `より後$i（終端が変更された場合）
］に位置する
］ようになった場合、 %P と同じ地点にされる（ 範囲oは畳まれる）。
】</p>

<dl class="domintro">

	<dt>%range . $setStart(node, offset)</dt>
	<dt>%range . $setEnd(node, offset)</dt>
	<dd>
それぞれ，始端／終端を `境界点$( %node, %offset ) と同じ位置にする。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
他の場合，
%offset が %node の`長さ$を超えている場合，
`IndexSizeError$E 例外が投出される。
</dd>

	<dt>%range . $setStartBefore(node)</dt>
	<dt>%range . $setStartAfter(node)</dt>
	<dd>
それぞれ，始端を %node の外縁の［
始端（下図の `S^c ）／終端（下図の `E^c ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $setEndBefore(node)</dt>
	<dt>%range . $setEndAfter(node)</dt>
	<dd>
それぞれ，終端を %node の外縁の［
始端（下図の `S^c ）／終端（下図の `E^c ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dd class="trans-note">
（説明用の図式
— %node 引数が，図の~COLOR_Yが表す~nodeに対応しているとする。）


`[|(|.|)|[|(|.|)|S[y|s[|(|.|)|]|(|.|.|.|)|[|]|e]|E(|.|.|)|]|]^bpex

</dd>

	<dt>%range . $collapse(toStart)</dt>
	<dd>
範囲oを畳む
— すなわち、 %toStart が ~T の場合は 終端を始端と同じ地点に位置させ，他の場合は 始端を終端と同じ地点に位置させる。
</dd>

	<dt>%range . $selectNode(node)</dt>
	<dd>
%node を選択する
— すなわち、始端と終端を %node の外縁の両端（上図の `S^c, `E^c ）に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $selectNodeContents(node)</dt>
	<dd>
%node の内容を選択する
— すなわち、始端と終端を %node の内縁の両端（上図の `s^c, `e^c ）に位置させる。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
%range の始端または終端（ %how により指示される）の位置bpが，
%sourceRange の始端または終端（ %how により指示される）［
`より前$i, `に等しい$i, `より後$i
］のいずれになるかに応じて、［
−1, 0, 1
］を返す。
</dd>

	<dd lang="en"><!-- for del_j --></dd>
</dl>


<p class="algo-head">
`~live範囲o$ %範囲o の
`境界点を設定する@
ときは、所与の
( %端 ~IN { `始端^i, `終端^i }, `~node$ %node, 非負~整数 %offset )
に対し，次を走らす：
◎
To set the start or end of a range to a boundary point (node, offset), run these steps:
</p>

<ol>
	<li id="cp-throw-if-doctype">
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
</li>
	<li id="cp-throw-if-length">
~IF［
%offset ~GT %node の`長さ$
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than node’s length, then throw an "IndexSizeError" DOMException.
</li>
	<li>
%境界点 ~LET `境界点$( %node, %offset )
◎
Let bp be the boundary point (node, offset).
</li>
	<li>
<p>
~IF［
%端 ~EQ `始端^i
］：
◎
If these steps were invoked as "set the start"
</p>
		<ol>
			<li>
~IF［
%境界点 は %範囲o の`終端$`より後$i
］~OR［
%範囲o の`根$rg ~NEQ %node の`根$
］
⇒
%範囲o の`終端$ ~SET %境界点
◎
If bp is after the range’s end, or if range’s root is not equal to node’s root, set range’s end to bp.
</li>
			<li>
%範囲o の`始端$ ~SET %境界点
◎
Set range’s start to bp.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %端 ~EQ `終端^i ）
◎
If these steps were invoked as "set the end"
</p>
		<ol>
			<li>
~IF［
%境界点 は %範囲o の`始端$`より前$i
］~OR［
%範囲o の`根$rg ~NEQ %node の`根$
］
⇒
%範囲o の`始端$ ~SET %境界点
◎
If bp is before the range’s start, or if range’s root is not equal to node’s root, set range’s start to bp.
</li>
			<li>
%範囲o の`終端$ ~SET %境界点
◎
Set range’s end to bp.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@setStart(node, offset)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`境界点を設定する$( `始端^i, %node, %offset )
◎
The setStart(node, offset) method, when invoked, must set the start of context object to boundary point (node, offset).
</dd>

	<dt>@setEnd(node, offset)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`境界点を設定する$( `終端^i, %node, %offset )
◎
The setEnd(node, offset) method, when invoked, must set the end of context object to boundary point (node, offset).
</dd>

	<dt>@setStartBefore(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setStartBefore(node) method, when invoked, must run these steps: 
</p>
		<ol>
			<li id="cp-let-parent">
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
			<li id="cp-throw-if-null">
~IF［
%親 ~EQ ~NULL
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If parent is null, then throw an "InvalidNodeTypeError" DOMException.
</li>
			<li>
此れの`境界点を設定する$( `始端^i, %親, %node の`指数$ )
◎
Set the start of the context object to boundary point (parent, node’s index).
</li>
		</ol>
	</dd>

	<dt>@setStartAfter(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setStartAfter(node) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-parent-->
			<!--cp-throw-if-null-->
			<li>
此れの`境界点を設定する$( `始端^i, %親, %node の`指数$ ~PLUS 1 )
◎
Set the start of the context object to boundary point (parent, node’s index plus 1).
</li>
		</ol>
	</dd>

	<dt>@setEndBefore(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setEndBefore(node), when invoked, method must run these steps:
</p>
		<ol>
			<!--cp-let-parent-->
			<!--cp-throw-if-null-->
			<li>
此れの`境界点を設定する$( `終端^i, %親, %node の`指数$ )
◎
Set the end of the context object to boundary point (parent, node’s index).
</li>
		</ol>
	</dd>

	<dt>@setEndAfter(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setEndAfter(node) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-parent-->
			<!--cp-throw-if-null-->
			<li>
此れの`境界点を設定する$( `終端^i, %親, %node の`指数$ ~PLUS 1 )
◎
Set the end of the context object to boundary point (parent, node’s index plus 1).
</li>
		</ol>
	</dd>

	<dt>@collapse(toStart)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The collapse(toStart) method, when invoked, must＼
</p>
		<ol>
			<li>
~IF［
%toStart ~EQ ~T
］
⇒
此れの`終端$ ~SET `境界点$( 此れの`始端~node$, 此れの`始端~offset$ )
◎
if toStart is true, set end to start, and＼
</li>
			<li>
~ELSE
⇒
此れの`始端$ ~SET `境界点$( 此れの`終端~node$, 此れの`終端~offset$ )
◎
set start to end otherwise.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`~node$ %node を，`範囲o$ %範囲o の
`中身として選択-@rg
するときは、次を走らす：
◎
To select a node node within a range range, run these steps:
</p>

<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
%index ~LET %node の`指数$
◎
Let index be node’s index.
</li>
	<li>
%範囲o の`始端$ ~SET `境界点$( %親, %index )
◎
Set range’s start to boundary point (parent, index).
</li>
	<li>
%範囲o の`終端$ ~SET `境界点$( %親, %index ~PLUS 1 )
◎
Set range’s end to boundary point (parent, index plus 1).
</li>
</ol>

<dl class="idl-def">
	<dt>@selectNode(node)</dt>
	<dd>
被呼出時には、 %node を，此れの`中身として選択-$rgし~MUST。
◎
The selectNode(node) method, when invoked, must select node within context object.
</dd>

	<dt>@selectNodeContents(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The selectNodeContents(node) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, throw an "InvalidNodeTypeError" DOMException.
</li>
			<li>
%長さ ~LET %node の`長さ$
◎
Let length be the length of node.
</li>
			<li>
此れの`始端$ ~SET `境界点$( %node, 0 )
◎
Set start to the boundary point (node, 0).
</li>
			<li>
此れの`終端$ ~SET `境界点$( %node, %長さ )
◎
Set end to the boundary point (node, length).
</li>
		</ol>
	</dd>

	<dt>@compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The compareBoundaryPoints(how, sourceRange) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%how ~NIN {
$START_TO_START,
$START_TO_END,
$END_TO_END,
$END_TO_START
}
］
⇒
~THROW `NotSupportedError$E
◎
If how is not one of
• START_TO_START
• START_TO_END
• END_TO_END
• END_TO_START
◎
then throw a "NotSupportedError" DOMException.
</li>
			<li>
~IF［
此れの`根$rg ~NEQ %sourceRange の`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If context object’s root is not the same as sourceRange’s root, then throw a "WrongDocumentError" DOMException.
</li>
			<li>
<p>
( %基準点, %この点 ) ~LET %how に応じて，次で与えられる 2 個の`境界点$：
◎
If how is:
</p>
				<dl class="switch">
					<dt>$START_TO_START:</dt>
					<dd>
( %sourceRange の`始端$, 此れの`始端$ )
◎
Let this point be the context object’s start. Let other point be sourceRange’s start.
</dd>

					<dt>$START_TO_END:</dt>
					<dd>
( %sourceRange の`始端$, 此れの`終端$ )
◎
Let this point be the context object’s end. Let other point be sourceRange’s start.
</dd>

					<dt>$END_TO_END:</dt>
					<dd>
( %sourceRange の`終端$, 此れの`終端$ )
◎
Let this point be the context object’s end. Let other point be sourceRange’s end.
</dd>

					<dt>$END_TO_START:</dt>
					<dd>
( %sourceRange の`終端$, 此れの`始端$ )
◎
Let this point be the context object’s start. Let other point be sourceRange’s end.
</dd>
				</dl>
			</li>
			<li>
~RET ［
%この点 は %基準点 ［
`より前$i ならば ~MINUS 1 ／
`に等しい$i ならば 0 ／
`より後$i ならば 1
］
◎
If the position of this point relative to other point is
◎
before
• Return −1.
◎
equal
• Return 0.
◎
after
• Return 1.
</li>
		</ol>
	</dd>
</dl>

<!-- ^@Range -->

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methは、主に，範囲oの`中身$rgを操作する。
】</p>

<dl class="domintro">
	<dt>%range . $deleteContents()</dt>
	<dd>
`~live範囲o$の`中身$rgを削除した上で、範囲oの`境界点$を畳む。
</dd>
	<dd>
<p>
`deleteContents()^c の実行例。
図の記号［
`s^c, `e^c
］が順に範囲の［
始端, 終端
］を表すとするとき、図左の~~状態から図右の~~状態になる。
包含されている~node（図の ~COLOR_X ）, および
始端／終端~nodeの文字~dataのうち 範囲oに入る部分の文字（図の `+^c ）が除去される。
部分的に包含されている~node（図の ~COLOR_Y ）は除去されない。
この例では、始端 `s^c が指す`文字~data~node$は，~dataは空になるが~node自体は残される。
図右の `S^c, `E^c が元の始端, 終端に対応する位置であるが、実行後の始端と終端は，図右の `X^c （共通の広義先祖の直下）を指すようにされることに注意（範囲oは畳まれる）。
始端~nodeが終端~nodeの`広義先祖$であった場合、始端の位置は変化しない。
始端~nodeが終端~node の`広義子孫$であった場合、全体の終端（右端）から相対的な終端の位置は変化しない。
</p>

`[|[|]|[y|(y|s+|)|]|[x|(|.|)|]|[y|(x|.|)|[y|(y|+|+|e.|)|[|]|]|(|.|)|]|] → [|[|]|[y|(y|S)|]|X[y|[y|(y|E.|)|[|]|]|(|.|)|]|]^bpex

</dd>

	<dt>%range . $extractContents()</dt>
	<dd>
`~live範囲o$の`中身$rgを~cloneした結果を返すと同時に，中身は削除する（ “カット” ）。
機能上は
$cloneContents() と $deleteContents()
の組み合わせと等価になる。
</dd>

	<dt>%range . $cloneContents()</dt>
	<dd>
`~live範囲o$の`中身を~clone$rgした結果を返す。
返される`中身$rgは、新たな`文書片$で包装される。
</dd>
	<dd>
<p>
^cloneContents() の実行例。
図左の記号［
`s^c, `e^c
］が順に範囲の［
始端, 終端
］を表すとするとき、その間に挟まれた部分の~cloneが図右に示すように得られる（ `S^c, `E^c が元の始端と終端に対応する位置）。
図の~COLOR_Yの 2 個の~nodeが，範囲に`部分的に包含され$ている子。
入れ物にあたる それらの`共通の広義先祖$は、~cloneにおいては`文書片$（~COLOR_X）に置換される。
始端 `s^c が属する`文字~data~node$は~dataが空にされるが、~node自体は［
その親から共通の広義先祖の子まで
］の先祖も含めて~cloneされる。
</p>

`[|[|]|[y|(|.|s)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|e.|)|[|]|]|(|.|)|]|] → [x|[y|(|S)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|E)|]|]|]^bpex

</dd>

	<dt>%range . $insertNode(node)</dt>
	<dd>
`~live範囲o$の`中身$rgの先頭に %node を挿入する（`中身に挿入-$rgする）。
</dd>

	<dt>%range . $surroundContents(%newParent)</dt>
	<dd>
`~live範囲o$の`中身$rgを %newParent ~nodeで包装する。
それに伴い、範囲oの始端, 終端は， %newParent の（外縁の）両端を指すようにされる。
包装するに先立って、
%newParent の元々の子はすべて除去され，
%newParent 自身も元々の親から除去される。
</dd>
	<dd>
<p>
^surroundContents(%newParent) の実行例。
記号 `s^c は始端, `e^c は終端を表すとき、それらに挟まれた区間が %newParent で包装される（図の~COLOR_Y）。
`部分的に包含され$るものは `Text^c 以外に許容されないので、始端と終端は `Text^c の層を~~無視すれば同じ親の直下に位置する必要がある（さもなければ例外が投出される）。
図の様に境界点が `Text^c ~node内に位置する場合、その~nodeはそこで分割される。
</p>

`[|(|.|)|s[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|e.|)|] → [|(|.|)|s[y|[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|)|]|e(|.|)|]^bpex

</dd>

	<dd lang="en"><!-- for del_j --></dd>
</dl>


<dl class="idl-def">
	<dt>@deleteContents()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteContents() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れは`畳まれて$いる
］
⇒
~RET
◎
If the context object is collapsed, then return.
</li>
			<li>
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に，此れの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be the context object’s start node, start offset, end node, and end offset, respectively.
</li>
			<li>
<p>
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node は`文字~data~node$である
］：
◎
If original start node and original end node are the same, and they are a Text, ProcessingInstruction, or Comment node,＼
</p>
				<ol>
					<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string,＼
</li>
					<li>
~RET
◎
and then return.
</li>
				</ol>
			</li>
			<li>
%除去対象 ~LET ［
此れに`包含され$ている`~node$のうち，`親$も此れに`包含され$ているものは除いたもの
］からなる，`木~順序$の~list
◎
Let nodes to remove be a list of all the nodes that are contained in the context object, in tree order, omitting any node whose parent is also contained in the context object.
</li>
			<li id="cp-let-new-if">
~IF［
%元の始端~node は %元の終端~node の`広義先祖$である
］
⇒＃
%新-~node ~LET %元の始端~node；
%新-~offset ~LET %元の始端~offset
◎
If original start node is an inclusive ancestor of original end node, set new node to original start node and new offset to original start offset.
</li>
			<li><!-- cp-new-node-offset -->
<p>
~ELSE：
</p>
		<ol>
			<li>
%新-~node ~LET
( %元の始端~node, %元の終端~node )
の`共通の広義先祖$
</li>
			<li>
%新-~offset ~LET ［
%新-~node の`子$のうち, %元の始端~node の`広義先祖$である`~node$ †
］の`指数$ ~PLUS 1
</li>
				</ol>

<p class="trans-note">【
見通しを良くするため、ここの訳は，原文を等価な記述に変形している。
前~段の条件の否定が成立することから † に該当する~nodeは必ず存在し， %新-~node に`部分的に包含され$ている子のうち 最初のものになる。
】</p>

◎
Otherwise:
• Let reference node equal original start node.
• While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
• Set new node to the parent of reference node, and new offset to one plus the index of reference node.
• If reference node’s parent were null, it would be the root of the context object, so would be an inclusive ancestor of original end node, and we could not reach this point.
</li>
			<li>
~IF［
%元の始端~node は`文字~data~node$である
］
⇒
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$ ~MINUS %元の始端~offset, 空~文字列 )
◎
If original start node is a Text, ProcessingInstruction, or Comment node, replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, data the empty string.
</li>
			<li>
%除去対象 内の~EACH ( %node ) に対し，`木~順序$で
⇒
%node の`親$から`子を除去する$( %node )
◎
For each node in nodes to remove, in tree order, remove node from its parent.
</li>
			<li>
~IF［
%元の終端~node は`文字~data~node$である
］
⇒
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
If original end node is a Text, ProcessingInstruction, or Comment node, replace data with node original end node, offset 0, count original end offset and data the empty string.
</li>
			<li>
此れの`始端$ ~SET `境界点$( %新-~node, %新-~offset )；<br>
此れの`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set start and end to (new node, new offset).
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`~live範囲o$ %範囲o の
`中身を抽出-@rg
するときは、次を走らす：
◎
To extract a live range range, run these steps:
</p>

<ol>
	<li id="cp-new-frag">
%断片 ~LET 次のように設定された 新たな`文書片$`~node$
⇒
`~node文書$ ~SET %範囲o の`始端~node$の`~node文書$
◎
Let fragment be a new DocumentFragment node whose node document is range’s start node’s node document.
</li>
	<li id="cp-ret-frag-if">
~IF［
%範囲o は`畳まれて$いる
］
⇒
~RET %断片
◎
If range is collapsed, then return fragment.
</li>
	<li id="cp-let-bp-vars">
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に， %範囲o の
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be range’s start node, start offset, end node, and end offset, respectively.
</li>
	<li>
<p id="cp-if-s-is-e-and">
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node は`文字~data~node$である
］：
◎
If original start node is original end node, and they are a Text, ProcessingInstruction, or Comment node:
</p>
		<ol>
			<li id="cp-let-clone-s">
%clone ~LET `~nodeを~cloneする$( %元の始端~node )
◎
Let clone be a clone of original start node.
</li>
			<li id="cp-set-clone-data-1">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の終端~offset ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original end offset minus original start offset.
</li>
			<li id="cp-append-clone">
%断片 に`~nodeを付加する$( %clone )
◎
Append clone to fragment.
</li>
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string.
</li>
			<li id="cp-ret-flag">
~RET %断片
◎
Return fragment.
</li>
		</ol>
	</li>
	<li id="cp-let-common-anc">
%共通の広義先祖 ~LET
( %元の始端~node, %元の終端~node )
の`共通の広義先祖$
◎
Let common ancestor be original start node.
◎
While common ancestor is not an inclusive ancestor of original end node, set common ancestor to its own parent.
</li>
	<li id="cp-let-1st-pcc-null">
%最初の部分的に包含されている子 ~LET ~NULL
◎
Let first partially contained child be null.
</li>
	<li id="cp-set-1st-pcc-if">
~IF［
%元の始端~node は %元の終端~node の`広義先祖$でない
］
⇒
%最初の部分的に包含されている子 ~SET
%範囲o に`部分的に包含され$ている［
%共通の広義先祖 の`子$
］のうち，最初のもの
◎
If original start node is not an inclusive ancestor of original end node, set first partially contained child to the first child of common ancestor that is partially contained in range.
</li>
	<li id="cp-let-last-pcc-null">
%最後の部分的に包含されている子 ~LET ~NULL
◎
Let last partially contained child be null.
</li>
	<li id="cp-set-last-pcc-if">
		<p>
~IF［
%元の終端~node は %元の始端~node の`広義先祖$でない
］
⇒
%最後の部分的に包含されている子 ~SET
%範囲o に`部分的に包含され$ている［
%共通の広義先祖 の`子$
］のうち，最後のもの
◎
If original end node is not an inclusive ancestor of original start node, set last partially contained child to the last child of common ancestor that is partially contained in range.
</p>

<p class="note">注記：
これらの変数~代入は実際に常に~~意味を成す。
例えば， %元の始端~node が %元の終端~node の`広義先祖$でない場合、［
%元の始端~node ~EQ %共通の広義先祖
］にはなり得ないので［
%元の始端~node の広義先祖であって %共通の広義先祖 の子孫でもあるもの
］が 1 つ以上あり，それらは %範囲o に`部分的に包含され$、それらのうち %共通の広義先祖 の子であるものが該当するものになる。
逆の場合も同様になる。
また、 2 つの子がいずれも定義されたなら，それらは決して等しくならないことにも注意。
◎
These variable assignments do actually always make sense. For instance, if original start node is not an inclusive ancestor of original end node, original start node is itself partially contained in range, and so are all its ancestors up until a child of common ancestor. common ancestor cannot be original start node, because it has to be an inclusive ancestor of original end node. The other case is similar. Also, notice that the two children will never be equal if both are defined.
</li>
	<li id="cp-let-contained">
%包含されている子たち ~LET
%共通の広義先祖 の`子$のうち， %範囲o に`包含され$ているものすべてからなる
`木~順序$による~list
◎
Let contained children be a list of all children of common ancestor that are contained in range, in tree order.
</li>
	<li id="cp-throw-if-a-doctype">
<p>
~IF［
%包含されている子たち 内に`~doctype$がある
］
⇒
~THROW `HierarchyRequestError$E
◎
If any member of contained children is a doctype, then throw a "HierarchyRequestError" DOMException.
</p>

<p class="note">注記：
`~doctype$が`部分的に包含され$ることは決してないので、部分的に包含される~nodeを気にする必要はない。
それは 範囲o の境界点
【始端~node／終端~node】
にはなり得ず, 何かの先祖にもなり得ない。
◎
We do not have to worry about the first or last partially contained node, because a doctype can never be partially contained. It cannot be a boundary point of a range, and it cannot be the ancestor of anything.
</p>
	</li>
	<!--cp-let-new-if-->
	<li>
<p>
~ELSE
⇒＃
%新-~node ~LET %共通の広義先祖；
%新-~offset ~LET %最初の部分的に包含されている子 の`指数$ ~PLUS 1
</p>

<p class="trans-note">【
ここの訳は、原文の記述と同じ結果を得るものに簡略化している。
】</p>

◎
Otherwise:
• Let reference node equal original start node.
• While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
• Set new node to the parent of reference node, and new offset to one plus reference node’s index.
• If reference node’s parent is null, it would be the root of range, so would be an inclusive ancestor of original end node, and we could not reach this point.
</li>
	<li>

<p id="cp-if-1st-pcc-is-cdata">
~IF［
%最初の部分的に包含されている子 は`文字~data~node$である
］：
◎
If first partially contained child is a Text, ProcessingInstruction, or Comment node:
</p>

<p class="note" id="cp-if-1st-pcc-is-cdata-note">
この事例では， %最初の部分的に包含されている子 は %元の始端~node である。
◎
In this case, first partially contained child is original start node.
</p>
		<ol>
			<!--cp-let-clone-s-->
			<li id="cp-set-clone-data-2">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の始端~node の`長さ$ ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original start node’s length minus original start offset.
</li>
			<!--cp-append-clone-->
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$ ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, and data the empty string.
</li>
		</ol>
	</li>
	<li>

<p id="cp-elseif-1st-pcc-not-null">
~ELIF［
%最初の部分的に包含されている子 ~NEQ ~NULL
］：
◎
Otherwise, if first partially contained child is not null:
</p>
		<ol>
			<li id="cp-let-clone-1st-pcc">
%clone ~LET `~nodeを~cloneする$( %最初の部分的に包含されている子 )
◎
Let clone be a clone of first partially contained child.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange1">
%下位~範囲o ~LET 次のように設定された 新たな`~live範囲o$
⇒＃
`始端$ ~SET `境界点$( %元の始端~node, %元の始端~offset ),
`終端$ ~SET `境界点$( %最初の部分的に包含されている子, %最初の部分的に包含されている子 の`長さ$ )
◎
Let subrange be a new live range whose start is (original start node, original start offset) and whose end is (first partially contained child, first partially contained child’s length).
</li>
			<li id="cp-let-subfrag-extract">
%下位~断片 ~LET %下位~範囲o の`中身を抽出-$rgした結果
◎
Let subfragment be the result of extracting subrange.
</li>
			<li id="cp-append-subfrag">
%clone に`~nodeを付加する$( %下位~断片 )
◎
Append subfragment to clone.
</li>
		</ol>
	</li>
	<li>
%包含されている子たち 内の~EACH ( %包含されている子 ) に対し
⇒
%断片 に`~nodeを付加する$( %包含されている子 )
◎
For each contained child in contained children, append contained child to fragment.
</li>
	<li>
<p id="cp-if-last-pcc">
~IF［
%最後の部分的に包含されている子 は`文字~data~node$である
］：
◎
If last partially contained child is a Text, ProcessingInstruction, or Comment node:
</p>

<p class="note" id="cp-if-last-pcc-note">注記：
この事例では， %最後の部分的に包含されている子 は %元の始端~node である。
◎
In this case, last partially contained child is original end node.
</p>
		<ol>
			<li id="cp-let-clone-end">
%clone ~LET `~nodeを~cloneする$( %元の終端~node )
◎
Let clone be a clone of original end node.
</li>
			<li id="cp-set-clone-data-3">
%clone の`~data$ ~SET
%元の終端~node の`~dataの部分文字列$( 0, %元の終端~offset )
◎
Set the data of clone to the result of substringing data with node original end node, offset 0, and count original end offset.
</li>
			<!--cp-append-clone-->
			<li>
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
Replace data with node original end node, offset 0, count original end offset, and data the empty string.
</li>
		</ol>
	</li>
	<li>
<p id="cp-elif-pcc-not-null">
~ELIF［
%最後の部分的に包含されている子 ~NEQ ~NULL
］：
◎
Otherwise, if last partially contained child is not null:
</p>
		<ol>
			<li id="cp-let-clone-last-pcc">
%clone ~LET `~nodeを~cloneする$( %最後の部分的に包含されている子 )
◎
Let clone be a clone of last partially contained child.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange2">
%下位~範囲o ~LET 次のように設定された 新たな`~live範囲o$
⇒＃
`始端$ ~SET `境界点$( %最後の部分的に包含されている子, 0 ),
`終端$ ~SET `境界点$( %元の終端~node, %元の終端~offset )
◎
Let subrange be a new live range whose start is (last partially contained child, 0) and whose end is (original end node, original end offset).
</li>
			<!--cp-let-subfrag-extract-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li><!--copy* -->
%範囲o の`始端$ ~SET `境界点$( %新-~node, %新-~offset )；<br>
%範囲o の`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set range’s start and end to (new node, new offset).
</li>
	<!--cp-ret-flag-->
</ol>

<dl class="idl-def">
	<dt>@extractContents()</dt>
	<dd>
被呼出時には、此れの`中身を抽出-$rgした結果を返さ~MUST。
◎
The extractContents() method, when invoked, must return the result of extracting the context object.
</dd>
</dl>

<p class="algo-head">
`~live範囲o$ %範囲o の`中身を~clone@rg
するときは、次を走らす：
◎
To clone the contents of a live range range, run these steps:
</p>

<ol>
	<!--cp-new-frag-->
	<!--cp-ret-frag-if-->
	<!--cp-let-bp-vars-->
	<li>
		<!--cp-if-s-is-e-and-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-1-->
			<!--cp-append-clone-->
			<!--cp-ret-flag-->
		</ol>
	</li>
	<!--cp-let-common-anc-->
	<!--cp-let-1st-pcc-null-->
	<!--cp-set-1st-pcc-if-->
	<!--cp-let-last-pcc-null-->
	<!--cp-set-last-pcc-if-->
	<!--cp-let-contained-->
	<!--cp-throw-if-a-doctype-->
	<li>
		<!--cp-if-1st-pcc-is-cdata-->
		<!--cp-if-1st-pcc-is-cdata-note-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-2-->
			<!--cp-append-clone--> 
		</ol>
	</li>
	<li>
		<!--cp-elseif-1st-pcc-not-null-->
		<ol>
			<!--cp-let-clone-1st-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange1-->
			<li id="cp-let-subfrag-clone">
%下位~断片 ~LET %下位~範囲o の`中身を~clone$rgした結果
◎
Let subfragment be the result of cloning the contents of subrange.
</li>
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li>
<p>
%包含されている子たち 内の~EACH ( %包含されている子 ) に対し：
◎
For each contained child in contained children:
</p>
		<ol>
			<li>
%clone ~LET `~nodeを~cloneする$( %包含されている子, ε, `子も~cloneする^i )
◎
Let clone be a clone of contained child with the clone children flag set.
</li>
			<!--cp-append-clone--> 

		</ol>
	</li>
	<li>
		<!--cp-if-last-pcc-->
		<!--cp-if-last-pcc-note-->
		<ol>
			<!--cp-let-clone-end-->
			<!--cp-set-clone-data-3-->
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-elif-pcc-not-null-->
		<ol>
			<!--cp-let-clone-last-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange2-->
			<!--cp-let-subfrag-clone-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<!--cp-ret-flag-->
</ol>

<dl class="idl-def">
	<dt>@cloneContents()</dt>
	<dd>
被呼出時には、此れの`中身を~clone$rgした結果を返さ~MUST。
◎
The cloneContents() method, when invoked, must return the result of cloning the contents of the context object.
</dd>
</dl>

<p class="algo-head">
`~node$ %node を`~live範囲o$ %範囲o の
`中身に挿入-@rg
するときは，次を走らす：
◎
To insert a node node into a live range range, run these steps:
</p>

<p class="trans-note">【
`始端$の直後に %node を挿入する。
それに伴い、終端は，末尾側からの相対位置が変化しないように適宜ずらされる（すなわち、挿入-後の 始端／終端 の，先頭／末尾 からの相対位置は不変）。
始端が`文字~data~node$の内部を指している場合、その~nodeは始端の所で 2 つに分割される。
】</p>

<ol>
	<li>
( %始端~node, %始端~offset ) ~LET %範囲o の ( `始端~node$, `始端~offset$ )
◎
↓</li>
	<li>
<p>
~IF［
%始端~node は次のいずれかを満たす
］
⇒
~THROW `HierarchyRequestError$E
：
</p>

<ul ><li>$ProcessingInstruction ~nodeである
</li><li>$Comment ~nodeである
</li><li>［
$Text `~node$である
］~AND［
`親$ ~EQ ~NULL
］
</li><li>%始端~node ~EQ %node
</li></ul>

◎
If range’s start node is a ProcessingInstruction or Comment node, is a Text node whose parent is null, or is node, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
%基準~node ~LET ~NULL
◎
Let referenceNode be null.
</li>
	<li>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET %始端~node
◎
If range’s start node is a Text node, set referenceNode to that Text node.
</li>
	<li>
~ELIF［
%始端~node の`子$に［
`指数$ ~EQ %始端~offset
］なるものが在る
］
⇒
%基準~node ~SET それ
◎
Otherwise, set referenceNode to the child of start node whose index is start offset, and null if there is no such child.
</li>
	<li>
%親 ~LET ［
%基準~node ~NEQ ~NULL ならば その`親$ ／
~ELSE_ %始端~node
］
◎
Let parent be range’s start node if referenceNode is null, and referenceNode’s parent otherwise.
</li>
	<li>
%node を %親 の中で %基準~node の前に`挿入できるかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET `~Text~nodeを分割する$( %始端~node, %始端~offset )
</p>
<p class="trans-note">【
%始端~offset が 0 でも分割されることになる。
】</p>
◎
If range’s start node is a Text node, set referenceNode to the result of splitting it with offset range’s start offset.
</li>
	<li>
~IF［
%node ~EQ %基準~node
］
⇒
%基準~node ~SET %node の`次-同胞？$
◎
If node is referenceNode, set referenceNode to its next sibling.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node の`親$から`子を除去する$( %node )
◎
If node’s parent is not null, remove node from its parent.
</li>
	<li>
%新-~offset ~LET ［
%基準~node ~NEQ ~NULL ならば その`指数$ ／
~ELSE_ %親 の`長さ$
］
◎
Let newOffset be parent’s length if referenceNode is null, and referenceNode’s index otherwise.
</li>
	<li>
%新-~offset ~INCBY ［
%node は`文書片$であるならば その`長さ$ ／
~ELSE_ 1
］
◎
Increase newOffset by node’s length if node is a DocumentFragment node, and one otherwise.
</li>
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %node, %基準~node )
◎
Pre-insert node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%範囲o は`畳まれて$いる
］
⇒
%範囲o の`終端$ ~SET `境界点$( %親, %新-~offset )
</p>

<p class="trans-note">【
畳まれていない場合の終端の位置は，`~nodeを子の前に前挿入する$（手続きの中で`~nodeを子の前に挿入する$）段階で適宜ずらされる。
】</p>

◎
If range is collapsed, then set range’s end to (parent, newOffset).
</li>
</ol>

<dl class="idl-def">
	<dt>@insertNode(node)</dt>
	<dd>
被呼出時には、
%node を此れの`中身に挿入-$rgし~MUST。
◎
The insertNode(node) method, when invoked, must insert node into the context object.
</dd>

	<dt>@surroundContents(newParent)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The surroundContents(newParent) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
ある非 $Text `~node$が此れに`部分的に包含され$ている
］
⇒
~THROW `InvalidStateError$E
◎
If a non-Text node is partially contained in the context object, then throw an "InvalidStateError" DOMException.
</li>
			<li>
<p>
~IF［
%newParent は
$Document, $DocumentType, $DocumentFragment `~node$
のいずれかである
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If newParent is a Document, DocumentType, or DocumentFragment node, then throw an "InvalidNodeTypeError" DOMException.
</p>

<p class="note">注記：
歴史上の理由から、`文字~data~node$に対しては、この段では検査されず，後の段にて副作用とともに例外が投出される結果になる。
◎
For historical reasons Text, ProcessingInstruction, and Comment nodes are not checked here and end up throwing later on as a side effect.
</p>
			</li>
			<li>
%断片 ~LET 此れの`中身を抽出-$rgした結果
◎
Let fragment be the result of extracting the context object.
</li>
			<li>
~IF［
%newParent は`子$を持つ
］
⇒
%newParent の`全~内容を~nodeで置換する$( ~NULL )
◎
If newParent has children, then replace all with null within newParent.
</li>
			<li>
%newParent を此れの`中身に挿入-$rgする
◎
Insert newParent into the context object.
</li>
			<li>
%newParent に`~nodeを付加する$( %断片 )
◎
Append fragment to newParent.
</li>
			<li>
%newParent を，此れの`中身として選択-$rgする
◎
Select newParent within the context object.
</li>
		</ol>
	</dd>

	<dt>@cloneRange()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`~live範囲o$を返さ~MUST
⇒＃
`始端$ ~SET 此れの`始端$の複製,<!--  -->
`終端$ ~SET 此れの`終端$の複製
◎
The cloneRange() method, when invoked, must return a new live range with the same start and end as the context object.
</dd>

	<dt>@detach()</dt>
	<dd>
被呼出時には、何もしては~MUST_NOT。
◎
The detach() method, when invoked, must do nothing.＼
</dd>
	<dd class="note">注記：
この機能性（ ^Range ~objの不能化）は、取除かれた。
互換性のため存続はするが。
◎
Its functionality (disabling a Range object) was removed, but the method itself is preserved for compatibility.
</dd>
</dl>


<dl class="domintro">
<!-- 
	<dt>range . cloneRange()†</dt>

	<dt>range . detach()†</dt>
-->

	<dt>%position = %range . $isPointInRange(node, offset)</dt>
	<dd>
`境界点$( %node, %offset ) が %range 内に入る†かどうかを返す。
</dd>

	<dt>%position = %range . $comparePoint(node, offset)</dt>
	<dd>
`境界点$( %node, %offset ) が
%range より前に位置する場合は ~MINUS 1 を,
%range 内に入る†場合は 0 を,
%range より後に位置する場合は 1 を
返す。<!-- * -->
◎
Returns −1 if the point is before the range, 0 if the point is in the range, and 1 if the point is after the range.
</dd>

	<dd class="trans-note">【†
境界点が %range のいずれかの境界点に一致する場合も，“入る” と見なされる。
】</dd>

	<dt>%intersects = %range . $intersectsNode(node)</dt>
	<dd>
%range が %node と交わるかどうかを返す。
◎
Returns whether range intersects node.
</dd>

	<dd class="trans-note">
<p>【
%node が %range に隣接している場合（ %range の終端（始端）が %node の <em>外縁の</em> 始端（終端）を指す境界点に一致する場合）は、“交わらない”。
例えば下図で `s^c, `e^c が %range の境界点を表すとするとき，図の~COLOR_Yが表す %node は交わらない。
】</p>

`[|[y|(|.|)|]|s[|(|.|.|)|e[y|(|.|.|)|]|]|]^bpex

<p>【
一般に、 %node は %範囲o に
(1) `包含され$ているとき, または
(2) %範囲o の始端~node／終端~nodeいずれかの`広義先祖$であるとき、
“交わる”。
】</p>
	</dd>

	<dt>$stringifier</dt>
	<dd>
範囲oを文字列化した結果は、範囲oにより “選択-” されているすべての~textになる。
</dd>
</dl>

<p class="trans-note">【
上のブロックに挙げた ^isPointInRange(), ^stringifier は、原文には存在しない，この訳による補完。
】</p>


<dl class="idl-def">
	<dt>@isPointInRange(node, offset)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The isPointInRange(node, offset) method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-ret-F-if-root">
~IF［
%node の`根$ ~NEQ 此れの`根$rg
］
⇒
~RET ~F
◎
If node’s root is different from the context object’s root, return false.
</li>
			<!--cp-throw-if-doctype-->
			<!--cp-throw-if-length-->
			<li>
~IF［
`境界点$( %node, %offset ) は［［
此れの`始端$`より前$i
］~OR［
此れの`終端$`より後$i
］］］
⇒
~RET ~F
◎
If (node, offset) is before start or after end, return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>

	<dt>@comparePoint(node, offset)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The comparePoint(node, offset) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node の`根$ ~NEQ 此れの`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If node’s root is different from the context object’s root, then throw a "WrongDocumentError" DOMException.
</li>
			<!--cp-throw-if-doctype-->
			<!--cp-throw-if-length-->
			<li>
~IF［
`境界点$( %node, %offset ) は
此れの`始端$`より前$i
］
⇒
~RET ~MINUS 1
◎
If (node, offset) is before start, return −1.
</li>
			<li> 
~IF［
`境界点$( %node, %offset ) は
此れの`終端$`より後$i
］
⇒
~RET 1
◎
If (node, offset) is after end, return 1.
</li>
			<li>
~RET 0
◎
Return 0.
</li>
		</ol>
	</dd>

	<dt>@intersectsNode(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The intersectsNode(node) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-ret-F-if-root-->
			<!--cp-let-parent-->
			<li>
~IF［
%親 ~EQ ~NULL
<!-- すなわち node は根 -->
］
⇒
~RET ~T
◎
If parent is null, return true.
</li>
			<li>
%offset ~LET %node の`指数$
◎
Let offset be node’s index.
</li>
			<li>
~IF［
`境界点$( %親, %offset ) は 此れの`終端$`より前$i
］~AND［
`境界点$( %親, %offset ~PLUS 1 ) は 此れの`始端$`より後$i
<!-- selectNode の結果 -->
］
⇒
~RET ~T
◎
If (parent, offset) is before end and (parent, offset plus 1) is after start, return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</dd>

	<dt>@stringifier</dt>
	<dd>
<p>
文字列化の挙動は、次を走らせ~MUST：
◎
The stringification behavior must run these steps:
</p>
		<ol>
			<li>
%s ~LET 空~文字列
◎
Let s be the empty string.
</li>
			<li>
( %始端~node, %始端~offset, %終端~node, %終端~offset ) ~LET 此れの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
↓</li>
			<li>
<p>
~IF［
%始端~node は $Text `~node$である
］：
</p>
				<ol>
					<li>
~IF［
%始端~node ~EQ %終端~node
］
⇒
~RET %始端~node の`~data$の［
%始端~offset から %終端~offset までの部分文字列
］
</li>
					<li>
%s に次を付加する
⇒
%始端~node の`~data$の［
%始端~offset から末尾までの部分文字列
］
</li>
				</ol>

◎
If the context object’s start node is the context object’s end node and it is a Text node, then return the substring of that Text node’s data beginning at the context object’s start offset and ending at the context object’s end offset.
◎
If the context object’s start node is a Text node, then append the substring of that node’s data from the context object’s start offset until the end to s.
</li>
			<li>
%s に次を`連結-$した結果を付加する
⇒
`木~順序$による，此れに`包含され$ているすべての $Text `~node$の`~data$
◎
Append the concatenation of the data of all Text nodes that are contained in the context object, in tree order, to s.
</li>
			<li>
~IF［
%終端~node は $Text `~node$である
］
⇒
%s に次を付加する
⇒
%終端~node の`~data$の［
先頭から %終端~offset までの部分文字列
］
◎
If the context object’s end node is a Text node, then append the substring of that node’s data from its start until the context object’s end offset to s.
</li>
			<li>
~RET %s
◎
Return s.
</li>
		</ol>
	</dd>
</dl>

<hr>

<p class="note">注記：
^Range ~ifcに対する拡張として、他の仕様にて
`createContextualFragment()$m,
`getClientRects()$m,
`getBoundingClientRect()$m
~methが定義されている。
`DOM-Parsing$r
`CSSOM-VIEW$r
◎
The createContextualFragment(), getClientRects(), and getBoundingClientRect() methods are defined in other specifications. [DOM-Parsing] [CSSOM-VIEW]
</p>


		</section>
	</section>
	<section id="traversal">
<h2 title="Traversal">6. 走査</h2>

<p>
$NodeIterator ／ $TreeWalker ~objを利用すれば、`~node$`木$を~filterにかけながら走査できる。
◎
NodeIterator and TreeWalker objects can be used to filter and traverse node trees.
</p>

<div class="p">
<p>
各 $NodeIterator ／ $TreeWalker ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`作動中~flag@tV</dt>
	<dd>
再帰的な呼出を避けるためにある。
初期~時は ~OFF 。
</dd>

	<dt>`根@tV</dt>
	<dd>
走査-対象にされる部分木の根を与える，`~node$。
</dd>

	<dt>`~whatToShow@tV</dt>
	<dd>
どの型（ $Node.nodeType ）の~nodeを走査するかを指示する，整数~bitmask。
1 にされた~bitに対応する型の~nodeのみが~filterを “通過する” 。
</dd>

	<dt>`~filter~callback@tV</dt>
	<dd>
対象を更に “濾過する” ~~条件を与える~callback,
または ~NULL （濾過されない）。
</dd>

</dl>

<p class="trans-note">【
［
作動中~flag／値~型
］以外の各項目の説明は、訳者による補足。
】</p>

◎
Each NodeIterator and TreeWalker object has an associated active flag to avoid recursive invocations. It is initially unset.
◎
Each NodeIterator and TreeWalker object also has an associated root (a node), a whatToShow (a bitmask), and a filter (a callback).
</div>

<p class="algo-head">
`走査器の中で~nodeを~filterにかける@
ときは、所与の
(［
$NodeIterator ／ $TreeWalker
］~obj %走査器, `~node$ %node )
に対し，次を走らす：
◎
To filter a node node within a NodeIterator or TreeWalker object traverser, run these steps: 
</p>

<ol>
	<li>
~IF［
%走査器 の`作動中~flag$tV ~EQ ~ON
］
⇒
~THROW `InvalidStateError$E
◎
If traverser’s active flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%n ~LET %node の $Node.nodeType 属性~値 ~MINUS 1
◎
Let n be node’s nodeType attribute value − 1.
</li>
	<li>
~IF［
%走査器 の`~whatToShow$tV の %n 番の~bit（ 0 番が最下位~bitとする） ~EQ 0
］
⇒
~RET $NodeFilter.FILTER_SKIP
	<!-- !((1 << (node.nodeType - 1)) & whatToShow) -->
◎
If the nth bit (where 0 is the least significant bit) of traverser’s whatToShow is not set, then return FILTER_SKIP.
</li>
	<li>
~IF［
%走査器 の`~filter~callback$tV ~EQ ~NULL
］
⇒
~RET $NodeFilter.FILTER_ACCEPT
◎
If traverser’s filter is null, then return FILTER_ACCEPT.
</li>
	<li>
%走査器 の`作動中~flag$tV ~SET ~ON
◎
Set traverser’s active flag.
</li>
	<li>
<p>
%結果 ~LET 次を与える下で，`利用元~objの演算を~callする$
⇒＃
%走査器 の`~filter~callback$tV,
`acceptNode^l,
« %node »
</p>

<p>
~callした結果，例外が投出されたときは、~catchして
⇒＃
%走査器 の`作動中~flag$tV ~SET ~OFF；
~THROW その例外
</p>

◎
Let result be the return value of call a user object’s operation with traverser’s filter, "acceptNode", and « node ». If this throws an exception, then unset traverser’s active flag and rethrow the exception.
</li>
	<li>
%走査器 の`作動中~flag$tV ~SET ~OFF
◎
Unset traverser’s active flag.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

		<section id="interface-nodeiterator">
<h3>6.1. ~ifc ^@NodeIterator</h3>

！！
[`Exposed$=Window]
interface @NodeIterator {
  [`SameObject$] ~RA $Node $root;
  ~RA $Node $referenceNode;
  ~RA ~B $pointerBeforeReferenceNode;
  ~RA ~UL $whatToShow;
  ~RA $NodeFilter? $filter;

  $Node? $nextNode();
  $Node? $previousNode();

  void $detach();
};
！

<p class="note">注記：
$NodeIterator ~objは、
$Document ~obj上の $Document.createNodeIterator() ~methを利用して作成できる。
◎
NodeIterator objects can be created using the createNodeIterator() method on Document objects.
</p>

<div class="p">
<p>
各 $NodeIterator ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`反復器~collection@</dt>
	<dd>
次のようにされた`~collection$
⇒＃
`根$cL ~SET ~objの`根$tV,
`~filter$cLは どの`~node$にも合致する
</dd>

	<dt>`起点@tV</dt>
	<dd>
`~node$
</dd>

	<dt>`起点の直前？@tV</dt>
	<dd>
真偽値。
</dd>
	<dd class="trans-note">【
概念的には，これと`起点$tVの組により、［
`反復器で走査する$ときに どの~nodeから探索し始めるか
］を指す，~pointerが表現される。
`起点$tV （初期~時には先頭の~nodeである`根$tVにされる）が “現在の” ~nodeを表し、`起点の直前？$tV （初期~時には ~T にされる）に従って、~pointerは，現在の~nodeの “直前” （ ~T ）または “直後” （ ~F ）を指す（すなわち、初期~時の~pointerは`根$tVの直前を指している）。
】</dd>

</dl>

◎
Each NodeIterator object has an associated iterator collection, which is a collection rooted at the NodeIterator object’s root, whose filter matches any node.
◎
Each NodeIterator object also has an associated reference (a node) and pointer before reference (a boolean).
</div>

<p>
</p>

<p class="note">注記：
前に言及したように、 $NodeIterator ~objには［
`作動中~flag$tV,
`根$tV,
`~whatToShow$tV,
`~filter~callback$tV
］も結付けられる。
◎
As mentioned earlier, NodeIterator objects have an associated active flag, root, whatToShow, and filter as well.
</p>

<p class="algo-head">
`前除去-時の手続き@
は、所与の
( $NodeIterator %反復器, `~node$ %除去される~node )
に対し，次に従う：
◎
The NodeIterator pre-removing steps given a nodeIterator and toBeRemovedNode, are as follows:
</p>

<ol>
	<li>
~IF［
%除去される~node は %反復器 の`起点$tVの`広義先祖$でない
］~OR［
%除去される~node ~EQ %反復器 の`根$tV
］
⇒
~RET
◎
If toBeRemovedNode is not an inclusive ancestor of nodeIterator’s reference, or toBeRemovedNode is nodeIterator’s root, then return.
</li>
	<li>
<p>
~IF［
%反復器 の`起点の直前？$tV ~EQ ~T
］：
◎
If nodeIterator’s pointer before reference is true, then:
</p>
		<ol>
			<li>
<p>
%次- ~LET 次をすべて満たす`~node$のうち，`最初のもの？$：
</p>

<ul><li>%除去される~node に`後続-$する
</li><li>%反復器 の`根$tVの`広義子孫$である
</li><li>%除去される~node の`広義子孫$でない
</li></ul>

◎
Let next be toBeRemovedNode’s first following node that is an inclusive descendant of nodeIterator’s root and is not an inclusive descendant of toBeRemovedNode, and null if there is no such node.
</li>
			<li>
~IF［
%次- ~NEQ ~NULL
］
⇒＃
%反復器 の`起点$tV ~SET %次-；
~RET
◎
If next is non-null, then set nodeIterator’s reference to next and return.
</li>
			<li>
%反復器 の`起点の直前？$tV ~SET ~F
◎
Otherwise, set nodeIterator’s pointer before reference to false.
◎
Steps are not terminated here.
</li>
		</ol>
	</li>
	<li>
%前-同胞 ~LET %除去される~node の`前-同胞？$
◎
↓</li>
	<li>
%反復器 の`起点$tV ~SET %前-同胞 に応じて
⇒＃
~NULL ならば %除去される~node の`親$ ／
~ELSE_ %前-同胞 の`広義子孫$のうち `最後のもの？$
◎
Set nodeIterator’s reference to toBeRemovedNode’s parent, if toBeRemovedNode’s previous sibling is null, and to the inclusive descendant of toBeRemovedNode’s previous sibling that appears last in tree order otherwise.
</li>
</ol>

<hr>

<dl class="idl-def">
	<dt>@root</dt>
	<dd>
取得子は、此れの`根$tVを返さ~MUST。
◎
The root attribute’s getter, when invoked, must return the context object’s root.
</dd>

	<dt>@referenceNode</dt>
	<dd>
取得子は、此れの`起点$tVを返さ~MUST。
◎
The referenceNode attribute’s getter, when invoked, must return the context object’s reference.
to.
</dd>

	<dt>@pointerBeforeReferenceNode</dt>
	<dd>
取得子は、此れの`起点の直前？$tVを返さ~MUST。
◎
The pointerBeforeReferenceNode attribute’s getter, when invoked, must return the context object’s pointer before reference.
</dd>

	<dt>@whatToShow</dt>
	<dd>
取得子は、此れの`~whatToShow$tVを返さ~MUST。
◎
The whatToShow attribute’s getter, when invoked, must return the context object’s whatToShow.
</dd>

	<dt>@filter</dt>
	<dd>
取得子は、此れの`~filter~callback$tVを返さ~MUST。
◎
The filter attribute’s getter, when invoked, must return the context object’s filter.
</dd>
</dl>


<p class="algo-head">
`反復器で走査する@
ときは、所与の
( $NodeIterator ~obj %反復器, %方向 ~IN { `順^i, `逆^i } )
に対し，次を走らす：
◎
To traverse, given a NodeIterator object iterator and a direction direction, run these steps:
</p>

<ol>
	<li>
%node ~LET %反復器 の`起点$tV
◎
Let node be iterator’s reference.
</li>
	<li>
%直前？ ~LET %反復器 の`起点の直前？$tV
◎
Let beforeNode be iterator’s pointer before reference.
</li>
	<li>
%collection ~LET %反復器 の`反復器~collection$
◎
↓</li>
	<li>
<p id="cp-repeat">
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
~IF［
%方向 ~EQ `順^i
］：
◎
Branch on direction:
◎
next
</p>
				<ol>
					<li>
<p>
~IF［
%直前？ ~EQ ~F
］：
◎
If beforeNode is false, then＼
</p>
						<ol>
							<li>
%node ~SET %collection の中で %node に`後続-$する`~node$のうち，`最初のもの？$
◎
set node to the first node following node in iterator’s iterator collection.＼
</li>
							<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%直前？ ~SET ~F
◎
If beforeNode is true, then set it to false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %方向 ~EQ `逆^i ）：
◎
previous
</p>
				<ol>
					<li>
<p>
~IF［
%直前？ ~EQ ~T
］：
◎
If beforeNode is true, then＼
</p>
						<ol>
							<li>
%node ~SET %collection の中で %node に`先行-$する`~node$のうち，`最後のもの？$
◎
set node to the first node preceding node in iterator’s iterator collection.＼
</li>
							<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%直前？ ~SET ~T
◎
If beforeNode is false, then set it to true.
</li>
				</ol>
			</li>
			<li>
~IF［
`走査器の中で~nodeを~filterにかける$( %反復器, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~BREAK
◎
Let result be the result of filtering node within iterator.
◎
If result is FILTER_ACCEPT, then break.
</li>
		</ol>
	</li>
	<li>
%反復器 の`起点$tV ~SET %node
◎
Set iterator’s reference to node.
</li>
	<li>
%反復器 の`起点の直前？$tV ~SET %直前？
◎
Set iterator’s pointer before reference to beforeNode.
</li>
	<li>
~RET %node
◎
Return node.
</li>
</ol>

<p class="trans-note">【
走査の方向が前回と逆向きに切り替わった場合、探索は，前回の走査による
“現在の” ~node（ `起点$tV ）から開始されることに注意（その次-／前-~nodeからではなく）。
探索の結果，`~filter$cLに合致する~nodeが見出されなかった場合、`起点$tVは変更されない。
見出された場合、
`起点$tV は，新たに見出された~nodeにされ，
`起点の直前？$tV （ “現在の” 走査-方向）は，渡された %方向 を反映するようにされる（ ~F が `順^i 方向に対応する）。
】</p>

<dl class="idl-def">
	<dt>@nextNode()</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
`反復器で走査する$( 此れ, `順^i )
◎
The nextNode() method, when invoked, must return the result of traversing with the context object and next.
</dd>

	<dt>@previousNode()</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
`反復器で走査する$( 此れ, `逆^i )
◎
The previousNode() method, when invoked, must return the result of traversing with the context object and previous.
</dd>

	<dt>@detach()</dt>
	<dd>
被呼出時には、何もしては~MUST_NOT。
◎
The detach() method, when invoked, must do nothing.＼
</dd>
	<dd class="note">注記：
この機能性（ ^NodeIterator ~objの不能化）は、取除かれた。
互換性のため存続はするが。
◎
Its functionality (disabling a NodeIterator object) was removed, but the method itself is preserved for compatibility.
</dd>

</dl>


		</section>
		<section id="interface-treewalker">
<h3>6.2. ~ifc ^@TreeWalker</h3>

！！
[`Exposed$=Window]
interface @TreeWalker {
  [`SameObject$] ~RA $Node $root;
  ~RA ~UL $whatToShow;
  ~RA $NodeFilter? $filter;
           attribute $Node $currentNode;

  $Node? $parentNode();
  $Node? $firstChild();
  $Node? $lastChild();
  $Node? $previousSibling();
  $Node? $nextSibling();
  $Node? $previousNode();
  $Node? $nextNode();
};
！

<p class="note">注記：
$TreeWalker ~objは、
$Document ~obj上の $Document.createTreeWalker() ~methを利用して作成できる。
◎
TreeWalker objects can be created using the createTreeWalker() method on Document objects.
</p>

<p>
各 $TreeWalker ~objには、
`現-~node@tV
（ `~node$ ）が結付けられる。
◎
Each TreeWalker object has an associated current (a node).
</p>

<p class="note">注記：
前に言及したように、 $TreeWalker ~objには［
`根$tV,
`~whatToShow$tV,
`~filter~callback$tV
］も結付けられる。
◎
As mentioned earlier TreeWalker objects have an associated root, whatToShow, and filter as well.
</p>

<dl class="idl-def">
	<dt>@root</dt>
	<dd>
取得子は、此れの`根$tVを返さ~MUST。
◎
The root attribute’s getter, when invoked, must return the context object’s root.
</dd>

	<dt>@whatToShow</dt>
	<dd>
取得子は、此れの `~whatToShow$tV を返さ~MUST。
◎
The whatToShow attribute’s getter, when invoked, must return the context object’s whatToShow.
</dd>

	<dt>@filter</dt>
	<dd>
取得子は、此れの`~filter~callback$tVを返さ~MUST。
◎
The filter attribute’s getter, when invoked, must return the context object’s filter.
</dd>

	<dt>@currentNode</dt>
	<dd>
取得子は、此れの`現-~node$tVを返さ~MUST。
◎
The currentNode attribute’s getter, when invoked, must return the context object’s current.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
此れの`現-~node$tV ~SET 所与の値
◎
The currentNode attribute’s setter, when invoked, must set the context object’s current to the given value.
</dd>

<!-- <hr> -->

	<dt>@parentNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The parentNode() method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-let-current">
%node ~LET 此れの`現-~node$tV
◎
Let node be the context object’s current.
</li>
			<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］~AND［
%node ~NEQ 此れの`根$tV
］：
◎
While node is non-null and is not the context object’s root:
</p>
				<ol>
					<li>
%node ~SET %node の`親$
◎
Set node to node’s parent.
</li>
					<li>
~IF［
%node ~NEQ ~NULL
］~AND［
`走査器の中で~nodeを~filterにかける$( 此れ, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
此れの`現-~node$tV ~SET %node；
~RET %node
◎
If node is non-null and filtering node within the context object returns FILTER_ACCEPT, then set the context object’s current to node and return node.
</li>
				</ol>
			</li>
			<li id="cp-TW-ret-null">
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`子たちを走査する@
ときは、所与の
( %walker, %向き ~IN { `最初から^i, `最後から^i } )
に対し，次を走らす：
◎
To traverse children, given a walker and type, run these steps:
</p>
<!-- 走査順序（最初からの場合）
N →
	(SKIP && N.firstChild) || 
	N0.nextSibling || N1.nextSibling || N2.nextSibling || ...
		// Nn = N(n-1).parentNode, N0 = N
-->
<ol>
	<li id="cp-let-current-tw">
%node ~LET %walker の`現-~node$tV
◎
Let node be walker’s current.
</li>
	<li>
%node ~SET %向き に応じて
⇒＃
`最初から^i ならば %node の`最初の子？$ ／
`最後から^i ならば %node の`最後の子？$
◎
Set node to node’s first child if type is first, and node’s last child if type is last.

</li>
	<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］：
◎
While node is non-null:
</p>
		<ol>
			<li id="cp-let-filter-result">
%結果 ~LET
`走査器の中で~nodeを~filterにかける$( %walker, %node )
◎
Let result be the result of filtering node within walker.
</li>
			<li id="cp-set-current-if-accept-tw">
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
%walker の`現-~node$tV ~SET %node；
~RET %node
◎
If result is FILTER_ACCEPT, then set walker’s current to node and return node.
</li>
			<li>
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_SKIP
］：
◎
If result is FILTER_SKIP, then:
</p>
				<ol>
					<li>
%子 ~LET %向き に応じて
⇒＃
`最初から^i ならば %node の`最初の子？$ ／
`最後から^i ならば %node の`最後の子？$
◎
Let child be node’s first child if type is first, and node’s last child if type is last.
</li>
					<li>
~IF［
%子 ~NEQ ~NULL
］
⇒＃
%node ~SET %子；
~CONTINUE
◎
If child is non-null, then set node to child and continue.
</li>
				</ol>
			</li>
			<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］：
◎
While node is non-null:
</p>
				<ol>
					<li>
%同胞 ~LET %向き に応じて
⇒＃
`最初から^i ならば %node の`次-同胞？$ ／
`最後から^i ならば %node の`前-同胞？$
◎
Let sibling be node’s next sibling if type is first, and node’s previous sibling if type is last.
</li>
					<li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒＃
%node ~SET %同胞；
~BREAK
◎
If sibling is non-null, then set node to sibling and break.
</li>
					<li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
					<li>
~IF［
%親 ~IN { ~NULL, %walker の`根$tV, %walker の`現-~node$tV }
］
⇒
~RET ~NULL
◎
If parent is null, walker’s root, or walker’s current, then return null.
</li>
					<li>
%node ~SET %親
◎
Set node to parent.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<!--cp-TW-ret-null-->
</ol>

<dl class="idl-def">
	<dt>@firstChild()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET `子たちを走査する$( 此れ, `最初から^i )
◎
The firstChild() method, when invoked, must traverse children with the context object and first.
</dd>

	<dt>@lastChild()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET `子たちを走査する$( 此れ, `最後から^i )
◎
The lastChild() method, when invoked, must traverse children with the context object and last.
</dd>
</dl>


<p class="algo-head">
`同胞たちを走査する@
ときは、所与の
( %walker, %向き ~IN { `順^i, `逆^i } )
に対し，次を走らす：
◎
To traverse siblings, given a walker and type, run these steps:
</p>

<ol>
	<!--cp-let-current-tw-->
	<li>
~IF［
%node ~EQ %walker の`根$tV
］
⇒
~RET ~NULL
◎
If node is root, then return null.
</li>
	<li>
<!--cp-repeat-->
		<ol>
			<li>
%同胞 ~LET %向き に応じて
⇒＃
`順^i ならば %node の`次-同胞？$ ／
`逆^i ならば %node の`前-同胞？$
◎
Let sibling be node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
			<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is non-null:
</p>
				<ol>
					<li>
%node ~SET %同胞
◎

Set node to sibling.
</li>
					<!--cp-let-filter-result-->
					<!--cp-set-current-if-accept-tw-->
					<li>
%同胞 ~SET %向き に応じて
⇒＃
`順^i ならば %node の`最初の子？$ ／
`逆^i ならば %node の`最後の子？$
◎
Set sibling to node’s first child if type is next, and node’s last child if type is previous.
</li>
					<li>
~IF［
%結果 ~EQ $NodeFilter.FILTER_REJECT
］~OR［
%同胞 ~EQ ~NULL
］
⇒
%同胞 ~SET %向き に応じて
⇒＃
`順^i ならば %node の`次-同胞？$ ／
`逆^i ならば %node の`前-同胞？$
◎
If result is FILTER_REJECT or sibling is null, then set sibling to node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
				</ol>
			</li>
			<li>
%node ~SET %node の`親$
◎
Set node to node’s parent.
</li>
			<li>
~IF［
%node ~IN { ~NULL, %walker の`根$tV }
］
⇒
~RET ~NULL
◎
If node is null or walker’s root, then return null.
</li>
			<li>
~IF［
`走査器の中で~nodeを~filterにかける$( 此れ, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~RET ~NULL
◎
If the return value of filtering node within walker is FILTER_ACCEPT, then return null.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@nextSibling()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET `同胞たちを走査する$( 此れ, `順^i )
◎
The nextSibling() method, when invoked, must traverse siblings with the context object and next.
</dd>

	<dt>@previousSibling()</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET `同胞たちを走査する$( 此れ, `逆^i )
◎
The previousSibling() method, when invoked, must traverse siblings with the context object and previous.
</dd>

	<dt>@previousNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The previousNode() method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-current-->
			<li>
<p>
~WHILE［
%node ~NEQ 此れの`根$tV
］：
◎
While node is not the context object’s root:
</p>
				<ol>
					<li>
%同胞 ~LET %node の`前-同胞？$
◎
Let sibling be node’s previous sibling.
</li>
					<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL 
］：
◎
While sibling is non-null:
</p>
						<ol>
							<li>
%node ~SET %同胞
◎
Set node to sibling.
</li>
							<li>
%結果 ~LET
`走査器の中で~nodeを~filterにかける$( 此れ, %node )
◎
Let result be the result of filtering node within the context object.
</li>
							<li>
<p id="cp-while-not-REJECT-and-has-child">
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%node は`子$を持つ
］：
◎
While result is not FILTER_REJECT and node has a child:
</p>
								<ol>
									<li>
%node ~SET %node の`最後の子？$
◎
Set node to node’s last child.
</li>
									<li id="cp-set-filter-result">
%結果 ~SET
`走査器の中で~nodeを~filterにかける$( 此れ, %node )
◎
Set result to the result of filtering node within the context object.
</li>
								</ol>
							</li>
							<li id="cp-set-current-if-accept">
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
此れの`現-~node$tV ~SET %node；
~RET %node
◎
If result is FILTER_ACCEPT, then set the context object’s current to node and return node.
</li>
							<li>
%同胞 ~SET %node の`前-同胞？$
◎
Set sibling to node’s previous sibling.
</li>
						</ol>
					</li>
					<li>
~IF［
%node ~EQ 此れの`根$tV
］~OR［
%node の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is the context object’s root or node’s parent is null, then return null.
</li>
					<li>
%node ~SET %node の`親$
◎
Set node to node’s parent.
</li>
					<li>
~IF［
`走査器の中で~nodeを~filterにかける$( 此れ, %node ) ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
此れの`現-~node$tV ~SET %node；
~RET %node
◎
If the return value of filtering node within the context object is FILTER_ACCEPT, then set the context object’s current to node and return node.
</li>
				</ol>
			</li>
			<!--cp-TW-ret-null-->
		</ol>
	</dd>

	<dt>@nextNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The nextNode() method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-current-->
			<li>
%結果 ~LET $NodeFilter.FILTER_ACCEPT
◎
Let result be FILTER_ACCEPT.
</li>
			<li>
<!--cp-repeat-->
				<ol>
					<li>
<!--cp-while-not-REJECT-and-has-child-->
						<ol>
							<li>
%node ~SET %node の`最初の子？$
◎
Set node to its first child.
</li>
							<!--cp-set-filter-result-->
							<!--cp-set-current-if-accept-->
						</ol>
					</li>
					<li>
%同胞 ~LET ~NULL
◎
Let sibling be null.
</li>
					<li>
%temporary ~LET %node
◎
Let temporary be node.
</li>
					<li>
<p>
~WHILE［
%temporary ~NEQ ~NULL
］：
◎
While temporary is non-null:
</p>
						<ol>
							<li>
~IF［
%temporary ~EQ 此れの`根$tV
］
⇒
~RET ~NULL
◎
If temporary is the context object’s root, then return null.
</li>
							<li>
%同胞 ~SET %temporary の`次-同胞？$
◎
Set sibling to temporary’s next sibling.
</li>
							<li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒
~BREAK
◎
If sibling is non-null, then break.
</li>
							<li>
%temporary ~SET %temporary の`親$
◎
Set temporary to temporary’s parent.
</li>
						</ol>
					</li>
					<li>
【次の段を行う前に “ %node ~SET %同胞 ” が必要では？】
</li>
					<!--cp-set-filter-result-->
					<!--cp-set-current-if-accept-->
				</ol>
			</li>
		</ol>
	</dd>
</dl>


		</section>
		<section id="interface-nodefilter">
<h3>6.3. ~ifc ^@NodeFilter</h3>

！！
[`Exposed$=Window]
callback interface @NodeFilter {
  // <span class="comment" title="Constants for acceptNode"
  ><code>$acceptNode()</code> 用の定数</span>
  ~CUS $FILTER_ACCEPT = 1;
  ~CUS $FILTER_REJECT = 2;
  ~CUS $FILTER_SKIP = 3;

  // <span class="comment" title="Constants for whatToShow bitmask"
  >`~whatToShow$tV 用の定数</span>
  ~CUL $SHOW_ALL = 0xFFFFFFFF;
  ~CUL $SHOW_ELEMENT = 0x1;
  ~CUL $SHOW_ATTRIBUTE = 0x2;
  ~CUL $SHOW_TEXT = 0x4;
  ~CUL $SHOW_CDATA_SECTION = 0x8;
  ~CUL @SHOW_ENTITY_REFERENCE = 0x10; // <!--cp-histroic-->
  ~CUL @SHOW_ENTITY = 0x20; // <!--cp-histroic-->
  ~CUL $SHOW_PROCESSING_INSTRUCTION = 0x40;
  ~CUL $SHOW_COMMENT = 0x80;
  ~CUL $SHOW_DOCUMENT = 0x100;
  ~CUL $SHOW_DOCUMENT_TYPE = 0x200;
  ~CUL $SHOW_DOCUMENT_FRAGMENT = 0x400;
  ~CUL @SHOW_NOTATION = 0x800; // <!--cp-histroic-->

  ~US @acceptNode($Node %node);
};
！

<p class="note">注記：
$NodeFilter ~objは、［
$NodeIterator ／ $TreeWalker
］用の`~filter~callback$tVとして利用できる。
また、それら用の`~whatToShow$tVとして~bitmask定数を供する。
$NodeFilter ~objは、概して，~JS関数として実装される。
◎
NodeFilter objects can be used as filter for NodeIterator and TreeWalker objects and also provide constants for their whatToShow bitmask. A NodeFilter object is typically implemented as a JavaScript function.
</p>

<p class="idl-def">
`~filter~callback$tVの返値には、次の定数を利用できる（括弧内は数値）
【各~項目の説明は、訳者による補足】：
◎
These constants can be used as filter return value:
</p>

<dl>
	<dt>@FILTER_ACCEPT (1)</dt>
	<dd>
~nodeは~filterを “通過する”。
</dd>

	<dt>@FILTER_REJECT (2)</dt>
	<dd>
$NodeIterator に利用されている下では、 $FILTER_SKIP と同じ結果になる。
</dd>
	<dd>
$TreeWalker に利用されている下では、~nodeはその子孫も含めて “濾過される”。
</dd>

	<dt>@FILTER_SKIP (3)</dt>
	<dd>
~node自身は “濾過される” が、その子孫は，依然として~filterの対象になり得る。
</dd>
</dl>


<p class="idl-def">
`~whatToShow$tV用には、次の定数を利用できる（括弧内は数値）：
◎
These constants can be used for whatToShow:
</p>

<ul><li>@SHOW_ALL (4294967295 ~EQ 0xFFFFFFFF)
</li><li>@SHOW_ELEMENT (1)
</li><li>@SHOW_ATTRIBUTE (2)
</li><li>@SHOW_TEXT (4)
</li><li>@SHOW_CDATA_SECTION (8)
</li><li>@SHOW_PROCESSING_INSTRUCTION (64 ~EQ 0x40)
</li><li>@SHOW_COMMENT (128 ~EQ 0x80)
</li><li>@SHOW_DOCUMENT (256 ~EQ 0x100)
</li><li>@SHOW_DOCUMENT_TYPE (512 ~EQ 0x200)
</li><li>@SHOW_DOCUMENT_FRAGMENT (1024 ~EQ 0x400)
</li></ul>


		</section>
	</section>
	<section id="sets">
<h2 title="Sets">7. ~token集合</h2>

<p class="note">
Yes, the name $DOMTokenList is an unfortunate legacy mishap.
</p>

		<section id="interface-domtokenlist">
<h3>7.1. ~ifc ^@DOMTokenList</h3>

！！
[`Exposed$=Window]
interface @DOMTokenList {
  ~RA ~UL $length;
  getter ~DS? $item(~UL %index);
  ~B $contains(~DS %token);
  [`CEReactions$] void $add(~DS... %tokens);
  [`CEReactions$] void $remove(~DS... %tokens);
  [`CEReactions$] ~B $toggle(~DS %token, optional ~B %force);
  [`CEReactions$] ~B $replace(~DS %token, ~DS %newToken);
  ~B $supports(~DS %token);
  [`CEReactions$] @stringifier attribute ~DS $value;
  iterable&lt;~DS&gt;;
};
！


<div class="p">
<p>
各 $DOMTokenList には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~token集合@</dt>
	<dd>
一連の~tokenからなる`有順序~集合$
— 初期~時は空とする。
</dd>

	<dt>`要素@dtl</dt>
	<dd>
`要素$。
</dd>
	<dt>`属性oの局所~名@dtl</dt>
	<dd>
`属性o$の`局所~名$a。
</dd>
</dl>

◎
A DOMTokenList object has an associated token set (a set), which is initially empty.
◎
A DOMTokenList object also has an associated element and an attribute’s local name.
</div>

<p>
`適用-可能な仕様$は、個々の`局所~名$aに対し，それが
`~supportする~token集合@dtl
を $DOMTokenList 用に定義しても~MAY
— これは、一連の~tokenからなる集合であり，特に指定されない限り ε （未定義）とする。
◎
Specifications may define supported tokens for a DOMTokenList's associated attribute’s local name.
</p>

<p class="algo-head">
$DOMTokenList ~obj %O 上で
`~tokenを検証する@
ときは、所与の
( %~token )
に対し，次を走らす：
◎
A DOMTokenList object’s validation steps for a given token are:
</p>

<ul>
	<li>
%~token集合 ~LET %O の`属性oの局所~名$dtlが`~supportする~token集合$dtl
◎
↓</li>
	<li>
~IF［
%~token集合 ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If the associated attribute’s local name does not define supported tokens, throw a TypeError.
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
`~ASCII小文字~化する$( %~token ) ~IN %~token集合
◎
Let lowercase token be a copy of token, in ASCII lowercase.
◎
If lowercase token is present in supported tokens, return true.
◎
Return false.
</li>
</ul>

<hr>


<p class="algo-head">
所与の $DOMTokenList ~obj %O 対し，
( %要素, %名前 )
は
( %O の`要素$dtl, %O の`属性oの局所~名$dtl )
とするとき：
◎
↓</p>

<ul>
	<li>
<p>
%O の
`更新~手続き@
は、次を走らす：
◎
A DOMTokenList object’s update steps are:
</p>
		<ol>
			<li>
~IF［
%要素 の`属性o~list$は空である
］~AND［
%O の`~token集合$は空である
］
⇒
~RET
◎
If the associated element does not have an associated attribute and token set is empty, then return.
</li>
			<li>
%要素 の`属性o値を設定する$( %名前, ［
%O の`~token集合$を`有順序~集合 直列化器$にかけた結果
］ )
◎
Set an attribute value for the associated element using associated attribute’s local name and the result of running the ordered set serializer for token set.
</li>
		</ol>
	</li>
	<li>
%O の
`直列化-手続き@
は、次を返す
⇒
%要素 の`属性o値を取得する$( %名前 )
◎
A DOMTokenList object’s serialize steps are to return the result of running get an attribute value given the associated element and the associated attribute’s local name.
</li>
	<li>
<p>
%要素 上の`属性oを変更する手続き$は、次で与えられる：
◎
A DOMTokenList object has these attribute change steps for its associated element:
</p>
		<ol>
			 <li>
<p>
~IF［
%局所~名 ~EQ %名前
］~AND［
%~ns ~EQ ~NULL
］：
</p>
				<ol>
					<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%O の`~token集合$を`空にする$
</li>
					 <li>
~ELSE
⇒
%O の`~token集合$ ~SET %値 を`有順序~集合 構文解析器$にかけた結果
</li>
				</ol>
◎
If localName is associated attribute’s local name, namespace is null, and value is null, then empty token set.
◎
Otherwise, if localName is associated attribute’s local name, namespace is null, then set token set to value, parsed.
</li>
		</ol>
	</li>
	<li>
<p>
%O の作成-時には、次を走らす：
◎
When a DOMTokenList object is created, then:
</p>

<ol>
	<li>
%値 ~LET ［
%要素 の`属性oを~nsと局所~名により取得する$( %名前, ~NULL )
］の`値$a
◎
Let element be associated element.
◎
Let localName be associated attribute’s local name.
◎
Let value be the result of getting an attribute given null, localName, and element.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %名前, %値, %値, ~NULL )
◎
Run the attribute change steps for element, localName, value, value, and null.
</li>
</ol>
	</li>
</ul>


<dl class="domintro">
	<dt>%tokenlist . $length</dt>
	<dd>
~tokenの個数を返す。
◎
Returns the number of tokens.
</dd>

	<dt>%tokenlist . $item(index)</dt>
	<dt>%tokenlist[%index]</dt>
	<dd>
%index 番の~tokenを返す。
◎
Returns the token with index index.
</dd>

	<dt>%tokenlist . $contains(token)</dt>
	<dd>
%token が在れば~T を, 無ければ~F を返す。
◎
Returns true if token is present, and false otherwise.
</dd>

	<dt>%tokenlist . $add(tokens…)</dt>
	<dd>
渡された引数のうち，まだ無いものを追加する。
◎
Adds all arguments passed, except those already present.
</dd>
	<dd>
<span id="cp-throw-if-some-token-is">
<a href="#_throw-if-token-is">下記に該当する場合</a>、例外が投出される。
</span>
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $remove(tokens…)</dt>
	<dd>
渡された引数のそれぞれを（もし在れば）除去する。
◎
Removes arguments passed, if they are present.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $toggle(token [, force])</dt>
	<dd>
<p>
%force に応じて：
</p>

<ul>
	<li>
%force が省略されている場合、
%token の有無を “切り替える”。
すなわち、 %token がすでに在れば除去し，無ければ追加する。
</li>
	<li>
%force ~EQ ~T の場合、 %token を追加する（ $add() と同じ）。
</li>
	<li>
%force ~EQ ~F の場合、 %token を除去する（ $remove() と同じ）。
</li>
</ul>

<p>
その結果、 %token が残っていれば ~T を, 無くなっていれば ~F を返す。
</p>
◎
If force is not given, "toggles" token, removing it if it’s present and adding it if it’s not present. If force is true, adds token (same as add()). If force is false, removes token (same as remove()).
◎
Returns true if token is now present, and false otherwise.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if token is empty.
◎
Throws an "InvalidCharacterError" DOMException if token contains any spaces.
</dd>

	<dt>%tokenlist . $replace(token, newToken)</dt>
	<dd>
	<dd>
%token を %newToken に置換する。
◎
Replaces token with newToken.
</dd>
	<dd>
%token が %newToken に置換されたなら ~T,
置換されなかったなら ~F を返す。
◎
Returns true if token was replaced with newToken, and false otherwise. 
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
◎
Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
</dd>

	<dt id="_throw-if-token-is">（例外）</dt>
	<dd>
<p>
上の各種~methに所与の文字列~引数のいずれかが，次に該当する場合、対応する例外が投出される：
</p>

		<ul id="cp-throw-if-token-B">
			<li>
空~文字列の場合：
`SyntaxError$E
</li>
			<li>
`~ASCII空白$を含む場合：
`InvalidCharacterError$E
</li>
		</ul>
◎
↑</dd>


	<dt>%tokenlist . $supports(token)</dt>
	<dd>
`属性oの局所~名$dtlが`~supportする~token集合$dtlに %token が含まれて［
いれば ~T ／ いなければ ~F
］を返す。
◎
Returns true if token is in the associated attribute’s supported tokens. Returns false otherwise.
</dd>
	<dd>
`~supportする~token集合$dtlが定義されていない場合、
`TypeError$E が投出される。
◎
Throws a TypeError if the associated attribute has no supported tokens defined.
</dd>

	<dt>%tokenlist . $value</dt>
	<dd>
結付けられている`~token集合$を文字列として返す。
◎
Returns the associated set as string.
</dd>
	<dd>
設定して結付けられている属性を変更できる。
◎
Can be set, to change the associated attribute.
</dd>

</dl>


<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、［
此れの`~token集合$の`~size$
］を返さ~MUST。
◎
The length attribute' getter must return context object’s token set’s size.
</dd>
</dl>

<p>
$DOMTokenList ~obj %O が`~supportする~prop~index$は、
0 以上［
%O の`~token集合$の`~size$
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to object’s token set’s size minus one, unless token set is empty, in which case there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@item(index)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The item(index) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%index ~NIN { 此れが`~supportする~prop~index$ }
］
⇒
~RET ~NULL
◎
If index is equal to or greater than context object’s token set’s size, then return null.
</li>
			<li>
~RET 此れの`~token集合$[ %index ]
◎
Return context object’s token set[index].
</li>
		</ol>
	</dd>
</dl>


<div>
<p class="algo-head">
`~tokenを検査する@
ときは、所与の
( %token )
に対し，次を走らす：
</p>

<ol>
	<li>
~IF［
%token ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
</li>
	<li>
~IF［
%token は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
</li>
</ol>

◎
↓↓</div>


<dl class="idl-def">
	<dt>@contains(token)</dt>
	<dd>
被呼出時には、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
%token ~IN 此れの`~token集合$
◎
The contains(token) method, when invoked, must return true if context object’s token set[token] exists, and false otherwise.
</dd>

	<dt>@add(tokens…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The add(tokens…) method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-throw-if-invalid-char">
%tokens 内の~EACH ( %token ) に対し，与えられた順に
⇒
`~tokenを検査する$( %token )
◎
For each token in tokens:
• If token is the empty string, then throw a "SyntaxError" DOMException.
• If token contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
%tokens 内の~EACH ( %token ) に対し
⇒
此れの`~token集合$に %token を`付加する$set
◎
For each token in tokens, append token to context object’s token set.
</li>
			<li id="cp-update-TL">
此れの`更新~手続き$を走らす
◎
Run the update steps.
</li>
<!-- 
追加が生じなかった場合にも更新~手続きは実行されることになる。
 -->
		</ol>
	</dd>

	<dt>@remove(tokens…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove(tokens…) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-throw-if-invalid-char-->
			<li>
%tokens 内の各 %token に対し
⇒
此れの`~token集合$から %token を`除去する$
◎
For each token in tokens, remove token from context object’s token set.
</li>
			<!--cp-update-TL-->
		</ol>
	</dd>

	<dt>@toggle(token, force)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The toggle(token, force) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`~tokenを検査する$( %token )
◎
If token is the empty string, then throw a "SyntaxError" DOMException.
◎
If token contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
<p>
~IF［
%token ~IN 此れの`~token集合$
］：
◎
If context object’s token set[token] exists, then:
</p>
				<ol>
					<li>
<p>
~IF［
%force は与えられてない
］~OR［
%force ~EQ ~F
］：
</p>
<ol ><li>此れの`~token集合$から %token を`除去する$
</li><li>此れの`更新~手続き$を走らす
</li><li>~RET ~F
</li></ol>
◎
If force is either not given or is false, then remove token from context object’s token set, run the update steps and return false.
</li>
					<li>
~ELSE
⇒
~RET ~T
◎
Otherwise, return true.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%force は与えられてない
］~OR［
%force ~EQ ~T
］：
</p>

<ol ><li>此れの`~token集合$に %token を`付加する$set
</li><li>此れの`更新~手続き$を走らす
</li><li>~RET ~T
</li></ol>

◎
Otherwise, if force not given or is true, append token to context object’s token set, run the update steps, and return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
~web互換性のため、 $toggle() に対しては，`更新~手続き$を常に走らすとは限らない。
◎
The update steps are not always run for toggle() for web compatibility.
</dd>

	<dt>@replace(token, newToken)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The replace(token, newToken) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%token ~EQ 空~文字列
］~OR［
%newToken ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
◎
If either token or newToken is the empty string, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%token は`~ASCII空白$を含んでいる
］~OR［
%newToken は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
◎
If either token or newToken contains any ASCII whitespace, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~IF［
%token ~NIN 此れの`~token集合$
］
⇒
~RET ~F
◎
If context object’s token set does not contain token, then return false.
</li>
			<li>
此れの`~token集合$内で %token を %newToken に`置換する$setする
◎
Replace token in context object’s token set with newToken.
</li>
			<!--cp-update-TL-->
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
~web互換性のため、 $replace() に対しては，`更新~手続き$を常に走らすとは限らない。
◎
The update steps are not always run for replace() for web compatibility.
</dd>
	<dd class="trans-note">【
最初と二番目の段は、
%token, %newToken の順に`~tokenを検査する$のとは，挙動が異なる。
】</dd>

	<dt>@supports(token)</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
此れ上で`~tokenを検証する$( %token )
◎
The supports(token) method, when invoked, must run these steps:
• Let result be the return value of validation steps called with token.
• Return result.
</dd>

	<dt>@value</dt>
	<dd>
取得子は、此れの`直列化-手続き$を走らせた結果を返さ~MUST。
◎
The value attribute must return the result of running context object’s serialize steps.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
此れの`要素$dtlの`属性o値を設定する$( 此れの`属性oの局所~名$dtl, 所与の値 )
◎
Setting the value attribute must set an attribute value for the associated element using associated attribute’s local name and the given value.
</dd>

</dl>

		</section>
	</section>
	<section id="historical">
<h2 title="Historical">8. 歴史上のもの</h2>

<p>
<a href="#goals">目標</a>
にて説明したように，この標準は廃用にされた各種~DOM仕様の大きな改訂である。
この節では互換でない変更点を列挙する。
◎
As explained in goals this standard is a significant revision of various obsolete DOM specifications. This section enumerates the incompatible changes.
</p>

		<section id="dom-events-changes">
<h3>8.1. DOM Events （~event）</h3>

<p>
以下は
`DOM Level 3 Events^cite
の［
"DOM Event Architecture",
"Basic Event Interfaces",
"Mutation Events",
"Mutation Name Event Types"
］各~章に述べられた特色機能に加えられた変更点である。
他の章は
`UI Events^cite 仕様 `UIEVENTS$r
に移行されるものと期待されている。
◎
These are the changes made to the features described in the "DOM Event Architecture", "Basic Event Interfaces", "Mutation Events", and "Mutation Name Event Types" chapters of DOM Level 3 Events. The other chapters are defined by the UI Events specification. [UIEVENTS]
</p>

<ul>
	<li>
@MutationEvent,
@MutationNameEvent
は除去された。
◎
Removes MutationEvent and MutationNameEvent.
</li>
	<li>
発火-（ `fire^en ）は今や配送-（ `dispatch^en ）の同義語ではなく，~eventの初期化も含む。
◎
Fire is no longer synonymous with dispatch, but includes initializing an event.
</li>
	<li>
`伝播停止$f（`伝播即停止$f）と`取消d$fは、配送-後ではなく，
$Event.initEvent()
を呼出した時に~OFF にされる。
◎
The propagation and canceled flags are unset when invoking initEvent() rather than after dispatch.
</li>
	<li>
$Event の $Event.timeStamp 属性は、
$DOMTimeStamp 型ではなく， $DOMHighResTimeStamp 型にされた。
◎
Event's timeStamp attribute is a DOMHighResTimeStamp rather than a DOMTimeStamp.
</li>
</ul>


		</section>
		<section id="dom-core-changes">
<h3>8.2. DOM Core</h3>

<p>
以下は
`DOM Level 3 Core^cite
で述べられた特色機能に加えられた変更点である。
◎
These are the changes made to the features described in DOM Level 3 Core.
</p>

<p>
$DOMString,
$DOMException,
$DOMTimeStamp
は、今や Web IDL にて定義される。
◎
DOMString, DOMException, and DOMTimeStamp are now defined in Web IDL.
</p>

<p>
$DOMStringList は、今や~HTMLにて定義される。
◎
DOMStringList is now defined in HTML.
</p>

<p>
<!-- @@Node -->
@hasAttributes(),
@attributes
は、
$Node から $Element へ移動された。
◎
hasAttributes() and attributes moved from Node to Element.
</p>

<p>
@namespaceURI,
@prefix,
@localName
は、
$Node から $Element, $Attr へ移動された。
◎
namespaceURI, prefix, and localName moved from Node to Element and Attr.
</p>

<p>
この節に挙げる，残りの~ifcと~ifc~memberは、~web~platformを単純~化するために取除かれた。
この仕様に適合する実装は、それらを~supportしないことになる。
◎
The remainder of interfaces and interface members listed in this section were removed to simplify the web platform. Implementations conforming to this specification will not support them.
</p>

<p>
~ifc：
◎
Interfaces:
</p>

<ul ><li>@DOMConfiguration
</li><li>@DOMError
</li><li>@DOMErrorHandler
</li><li>@DOMImplementationList
</li><li>@DOMImplementationSource
</li><li>@DOMLocator
</li><li>@DOMObject
</li><li>@DOMUserData
</li><li>@Entity
</li><li>@EntityReference
</li><li>@NameList
</li><li>@Notation
</li><li>@TypeInfo
</li><li>@UserDataHandler
</li></ul>

<p>
~ifc~member：
◎
Interface members:
</p>

<dl>
	<dt>$@Node</dt>
	<dd>
<ul><li>@isSupported
</li><li>@getFeature()
</li><li>@getUserData()
</li><li>@setUserData()
</li></ul>

	</dd>
	<dt>$@Document</dt>
	<dd>
<ul><li>@createEntityReference()
</li><li>@xmlEncoding
</li><li>@xmlStandalone
</li><li>@xmlVersion
</li><li>@strictErrorChecking
</li><li>@domConfig
</li><li>@normalizeDocument()
</li><li>@renameNode()
</li></ul>

	</dd>
	<dt>$@DOMImplementation</dt>
	<dd>
		<ul>
<li>@getFeature()</li>
		</ul>

	</dd>
	<dt>$@Attr</dt>
	<dd>
<ul><li>@schemaTypeInfo
</li><li>@isId
</li></ul>
	</dd>

	<dt>$@Element</dt>
	<dd>
<ul><li>@schemaTypeInfo
</li><li>@setIdAttribute()
</li><li>@setIdAttributeNS()
</li><li>@setIdAttributeNode()
</li></ul>
	</dd>
	<dt>$@DocumentType</dt>
	<dd>
<ul><li>@entities
</li><li>@notations
</li><li>@internalSubset
</li></ul>

	</dd>
	<dt>$@Text</dt>
	<dd>
<ul><li>@isElementContentWhitespace
</li><li>@replaceWholeText()
</li></ul>
	</dd>
</dl>

		</section>
		<section id="dom-range-changes">
<h3>8.3. DOM Ranges （範囲o）</h3>

<p>
以下は
`DOM Level 2 Traversal and Range^cite.
の "Document Object Model Range"
章にて述べられている特色機能に加えられた変更点である。
◎
These are the changes made to the features described in the "Document Object Model Range" chapter of DOM Level 2 Traversal and Range.
</p>

<ul>
	<li>
@RangeException
は取除かれた。
◎
RangeException has been removed.
</li>
	<li>
$detach は今や何もしない。
◎
detach() is now a no-op.
</li>
</ul>

		</section>
		<section id="dom-traversal-changes">
<h3>8.4. DOM Traversal （走査）</h3>

<p>
以下は
`DOM Level 2 Traversal and Range^cite
の "Document Object Model Traversal" 章にて述べられている
特色機能に加えられた変更点である。
◎
These are the changes made to the features described in the "Document Object Model Traversal" chapter of DOM Level 2 Traversal and Range.
</p>

<ul>
	<li>
$@Document の
$createNodeIterator(),
$createTreeWalker()
は、今や省略可の引数をとり，最早~DOMには決して取り込まれない実体参照を与える 4 個目の引数は除かれた。
◎
createNodeIterator() and createTreeWalker() now have optional arguments and lack a fourth argument which is no longer relevant given entity references never made it into the DOM.
</li>
	<li>
前述の理由により，
@NodeIterator.expandEntityReferences
属性は $NodeIterator および $TreeWalker ~ifcから除去された。
◎
The expandEntityReferences attribute has been removed from the NodeIterator and TreeWalker interfaces for the aforementioned reason.
</li>
	<li>
~UAのふるまいに揃えるため、
$nextNode() と $previousNode() は今や
$NodeFilter から呼出されたときに例外を投出し得る。
◎
nextNode() and previousNode() now throw when invoked from a NodeFilter to align with user agents.
</li>
	<li>
$detach は今や何もしない。
◎
detach() is now a no-op.
</li>
</ul>

		</section>
	</section>
</main></div>
<!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、 DOM を相互運用可能にするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に，この標準の今日の姿は、多くの方々からの助力により作り上げられている。
<span lang="en">
There have been a lot of people that have helped make DOM more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<div lang="en-x-a0">

<p>
With that, many thanks to

Adam Klein,
Adrian Bateman,
Aleksey Shvayka,
Alex Komoroske,
Alex Russell,
Anthony Ramine,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Björn Höhrmann,
Boris Zbarsky,
Brandon Payton,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
Cameron McCormack,
Chris Dumez,
Chris Paris,
Chris Rebert,
Cyrille Tuzi,
Daniel Glazman,
Darin Fisher,
David Bruant,
David Flanagan,
David Håsäther,
David Hyatt,
Deepak Sherveghar,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Edgar Chen,
Elisée Maurer,
Elliott Sprehn,
Eric Bidelman,
Erik Arvidsson,
Gary Kacmarcik,
Gavin Nicol,
Geoffrey Sneddon,
Giorgio Liscio,
Glen Huang,
Glenn Adams,
Glenn Maynard,
Hajime Morrita,
Harald Alvestrand,
Hayato Ito,
Henri Sivonen,
Hongchan Choi,
Hunan Rostomyan,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald,
Jake Verbaten,
James Graham,
James Greene,
James Robinson,
Jeffrey Yasskin,
Jens Lindström,
Jesse McCarthy,
Jinho Bang,
João Eiras,
Joe Kesselman,
John Atkins,
John Dai,
Jonas Sicking,
Jonathan Robie,
Joris van der Wel,
Joshua Bell,
Jungkee Song,
Justin Summerlin,
<span lang="zh-tw">呂康豪</span> (Kang-Hao Lu),
Kevin Sweeney,
Kirill Topolyan,
Koji Ishii,
Lachlan Hunt,
Lauren Wood,
Magne Andersson,
Majid Valipour,
Malte Ubl,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Martijn van der Ven,
Mats Palmgren,
Mounir Lamouri,
Michael™ Smith,
Mike Champion,
Mike Taylor,
Mike West,
Ojan Vafai,
Oliver Nightingale,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Ra’Shaun Stovall (Snuggs),
Rafael Weinstein,
Richard Bradshaw,
Rick Byers,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Roland Steiner,
Rune <span title="Fabulous">F.</span> Halvorsen,
Russell Bicknell,
Ruud Steltenpool,
Ryosuke Niwa,
Sam Dutton,
Samuel Giles,
Sebastian Mayr,
Seo Sanghyeon,
Sergey G. Grekhov,
Shiki Okasaka,
Shinya Kawanaka,
Simon Pieters,
Stef Busking,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Takashi Sakamoto,
Takayoshi Kochi,
Theresa O’Connor,
Theodore Dubois,
<i>timeless</i>,
Timo Tijhof,
Tobie Langel,
Tom Pixley,
Travis Leithead,
<i>triple-underscore</i>,
Veli Şenol,
Vidur Apparao,
Warren He,
Xidorn Quan,
Yehuda Katz,
Yoav Weiss,
Yoichi Osato,
Yoshinori Sano, and
Zack Weinberg

for being awesome!
</p>

<p>
This standard is written by
<a href="//annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>)
with substantial contributions from
Aryeh Gregor (<a href="mailto:ayg@aryeh.name">ayg@aryeh.name</a>)
and Ms2ger (<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).
</p>

<p>
Part of the revision history of the integration points related to <a href="#concept-element-custom">custom</a> elements can be
found in <a href="https://github.com/w3c/webcomponents">the w3c/webcomponents repository</a>, which
is available under the <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Permissive Document License</a>.
</p>

<p>
Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

</div>

	</section>



<!--% 他の語

	●仕様
出発点:starting point
広い:broader
謝辞:
~~原因:cause
~~目的:
様子:
略語:
言葉を代えれば:Phrased differently,
進路:future course
小論:essays
報告書:reports
本格的:fully-fledged
手品:magic
~~仕組:magic
出来上がる:comes out
十分:
不要:
類似:
的外れ:nonsensical
~~選択:-
名称:names
否決:vetoed
探求-:explore:~
編集:editing:~
事実:fact
~~言明:claim
ほど遠い:not nearly as reliable or granular
~~判明:proved
~~根拠を示す:showing
編集者:editors
~~制御:key off
便宜のため:For convenience 
簡便:convenience
区別:avoid confusion
非負:non-negative
のふるまいに揃える:align with
移行:moving
用語:term:~
用途
依然として:still:
存続-:continues to exist
発生:occurrence
次に起きる出来事:what happens next
~~無視:not pay attention
序論:introduction to
理由:mishap／because 
注意:Note that／notice that
賢く:wise に
記述
必要:need／has to／
注記:Note
意味-:mean
意味:meaning
揃わせ:Aligning
代わるもの:replacement
特に:in particular
節:section:~
~~特に:specificalに
~~強調:called out
誤った考え:wrong ideas
人:folks
particular
不要にするreplaces the need
~~廃する:rid of
	あいにく:Unfortunately,
hairy
	何もしない:no-op／:empty
論を交わしたければ:discussion
~F に:clear
割り当てられる:allocate
ごく限られた~~状況:very specific circumstances.
直面:in the face of
呼応して:in response to
尊守され:enshrined
弄り倒す:messes with 〜 extensively
により、:because of
今の所:for now,
知らせて:Let us know
満たす:meet／
気にする:worry about
あるとする:hypothetical
可能:possible／
可能な限り:as much as possible
例:example
選べ:chose
~~伝える:convey
用法:using
則って:accordingly
必要に応じて:according to their needs
べき:should
具体例として:for instance
利用-:use
もっぱら:exclusive

	●訳注
増減操作
加減算
次節
部分集合
可視化
上下関係
階層
入子~階層
位置変化
無限増殖
ループ
反復対象
~~未定義
誤記
機能上
括弧内
見立てて
~~例外
ドット
先掲
位置関係
算出
~~定義
区間
根元
対訳
対称
整理統合
慣用表現
付記
簡単に
忠実
意義
不明
~~状態
ブロック
整合性
説明用
見通し
変形
否定
図左
カット
相当
削除-:delete:~
簡略化
不変
段階
全部的
概念的
開始地点
通過-
横線
太字
前順
優先
構成-
関係
固有
表記規約
表記
非公式
括弧内: 2
未策定: 2
総称: 2
何故:
仮想: 2
訳者: 2
実行後
相対位置
適宜
簡潔
最上層
参考
実行例: 3
濾過: 3
探索
見出し
~~厳密
~~無視
補足
補完
模式図
縦棒
横線
両端
左端
右端
内縁
外縁
地点
直上
直下
記号
赤色区間
緑色区間
青色区間
原文
意図-
図右
上図
下図


	●未分類
混在:
連続する:adjacent／a sequence of
一致
／除外-:exclude
存在-:exist:~
処理過程
処理
中身:内容
位置
表され:express
並び:sequence of
切り替える:toggle
された:got
-:lead
-:controller
すごいこと:amazing
すごい結果:amazingResult
何かする:doAction
つまらない:Boring

-->

