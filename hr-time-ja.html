<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>High Resolution Time（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'test': // tests
	href = `https://wpt.fyi/hr-time/${key}.html`;
	text = '【~test】';
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2021-10-12
trans_update:2021-10-13
source_checked:210212
page_state_key:TIMING
original_url:https://w3c.github.io/hr-time/
	abbr_url:HRTIME
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2020,permissive
trans_1st_pub:2015-07-22


●●class_map
E:dom-error

●●tag_map
I:code
m:code
d:code
c:code
E:code
v:var
b:b
i:i
cite:cite

●●original_id_map

●●mdn_urls
dom-domhighrestimestamp:API/DOMHighResTimeStamp
dom-performance:API/Performance
dom-windoworworkerglobalscope-performance:API/Window/performance
	dom-windoworworkerglobalscope-performance:API/WorkerGlobalScope/performance
dom-performance-now:API/Performance/now
dom-performance-timeorigin:API/Performance/timeOrigin
dom-performance-tojson:API/Performance/toJSON

●●link_map


Replaceable:~WEBIDLjs#Replaceable
Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default

unsigned long long:~WEBIDL#idl-unsigned-long-long
double:~WEBIDL#idl-double
object:~WEBIDL#idl-object

I.DOMHighResTimeStamp:#dom-domhighrestimestamp
I.Performance:#dom-performance
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
	#dom-windoworworkerglobalscope-windoworworkerglobalscope
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.EpochTimeStamp:#dom-epochtimestamp

I.Window:~WINDOW#window
I.Worker:~WORKERS#worker
I.SharedWorker:~WORKERS#sharedworker
I.EventTarget:~DOM4#eventtarget
I.BroadcastChannel:~HTMLcomms#broadcastchannel

m.performance:#dom-windoworworkerglobalscope-performance
m.now():#dom-performance-now
m.timeOrigin:#dom-performance-timeorigin
m.toJSON():#dom-performance-tojson

c.Date:~TC39#sec-date-objects
c.Date.now():~TC39#sec-date.now

	●用語
外的な時計~調整:#_clock-adjustments
時刻起点:#dfn-time-origin
時刻起点~時刻印を取得する:#dfn-get-time-origin-timestamp
時刻起点~時刻印:#dfn-get-time-origin-timestamp
細かさを抑えた時刻:#dfn-coarsen-time
相対的な高分解能~時刻:#dfn-relative-high-resolution-time
細かさを抑えた相対的な高分解能~時刻:#dfn-relative-high-resolution-coarse-time
現在の高分解能~時刻:#dfn-current-high-resolution-time
単調増加~時計:#dfn-monotonic-clock
共有される単調増加~時計:#dfn-shared-monotonic-clock
細かさを抑えた共有される現在の時刻:#dfn-coarsened-shared-current-time
安全でない共有される現在の時刻:#dfn-unsafe-shared-current-time
~epochに相対的な時刻印:#dfn-epoch-relative-timestamp

	●用語（外部
実装定義:~INFRA#implementation-defined

公式的な作成~時点:~WORKERS#official-moment-of-creation
対応する閲覧文脈:~WINDOW#window-bc
	作成され:~BROWSERS#creating-a-new-browsing-context
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
大域~obj:~WAPI#global-object
rM.大域~obj:~WAPI#concept-realm-global
enV.非同一-生成元~能力は隔離-済みか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

結付けられている文書:~WINDOW#concept-document-window
~navi:~NAVI#navigate
~unloadを~promptする:~NAVI#prompt-to-unload-a-document

既定の~toJSON手続き:~WEBIDLjs#default-tojson-steps

~JS時刻:#_js-time
	~JS時刻:~TC39#sec-time-values-and-time-range

cite.User Timing:~USER-TIMING#user-timing-ja.html


●●words_table1

USER-TIMING:user-timing-ja.html

●●words_table


	●計時
zero::::ゼロ
時系列順:chronological::~
	計時~側からの:timing side-channel
計測-:instrument:~
	時間~差:time 差
	現~時刻:present time
時刻起点:time origin::~
分解能:resolution::~
高分解能:high resolution::~
時計:clock::~::クロック
	従来の時計:time-of-day
日時:date-time::~
milli:milli-:::ミリ
micro:micro-:::マイクロ
	~milli秒:milliseconds
	~milli秒数:in milliseconds
	~milli秒数:the number of milliseconds
	~milli秒より細かい:sub-millisecond
	~micro秒:microseconds
	秒:seconds
単調増加:monotonic::~
単調増加-:monotonic に increase::~
減少-:decrease::~
rate::::レート
費やさ:elapseさ:~
暦:calendar::~
	時間~差:duration
epoch:
周期的:periodic:~
周期:interval:~
定期的:regular:~
カクつき:jank:~
閏秒:leap second:~

	絞る:throttle
	挿入:cue
	skew:::スキュー
	長時間:longer time period
	確度
	高:high
	正確aさに抑える:inaccurate
	正確aさ:accurate to
	ゆらぎを加える:Added jitter
	任意選択で ゆらぎも加える:and potentially jitter 
	細かさを〜より抑えた:coarsen 〜 not exceed
	細かさを抑えた:coarsen

	●処理
稼働時の:runtime::~
再起動:restart:~
安定的:stable::~
main::::メイン
	各~開始:restart
	作成~時点:moment of creation
	合計:total

	●保安
schedule::::スケジュール
timer::::タイマー
統計的:statistical:~
活動:activity:~
速度:speed:~
露呈-:reveal:~
応答性:responsiveness:~
協調-:coordinate:~
退歩:regressions:~
分析:analysis:~
分析-:analyze:~
音:sound:~
見積もり:estimate:~
機密的:confidential:~
TCP:
entropy::::エントロピー
drift:::同期ずれ
縛られ:tieされ:~
分別-:differentiate:~
低層:lower-layer:~
濫用:abuse:~
抑制:reduction:~
process::::プロセス
無関係な:unrelatedな:~
推定-:infer:~
背景:background:~
決定的:critical:~
不可能:impossible:~
	~~基盤:primitives
	側からの:side channel
	担当する:responsible
	可能にする:enables
	につながる:associated

	●仕様
生粋:genuine:純粋
実用上の:practicalな:~
助け:help:~
確認-:confirm:~
確認:confirmation:~
未解決:unsolved:~
発展途上な:evolve している:~
	:evolving
事実調査:research:~
分野:area:~
産業界:industry:~
業界:industry:~
総意:consensus:~
権威ある:definitiveな:~
満足され:satisfyされ:満たされ
捕える:catchする:~
歪めら:distortさ:~
無用:useless:~
関心:interest:~
完璧:perfect:~
統一-:unify:~
推測-:guess:~

	~~可能性がある:potentially
	にもなり得る:potential
	ことにする:choose
	義務付けるもの:mandatory part of
	化す:render
	事実:fact
	起因-:stem
	周りで:revolves around
	〜を~~自前で:in-the-wild
	早期:early
	〜にとって〜が問われる:talk
	次に挙げるもの:a few different

	●未分類（動詞
unload:
prompt:
閲覧:browsing:~
換算-:translate:~
交換-:exchange:~
	集めて:gather
	%G:global

	●未分類
typedef:
タブ:tab::~
toJSON:
cue:

	文書~navi:navigating to a Document
	細かさに:minimum 
	~~背後に回され:backgrounded
	量:amount
	point
	using
	-:assert
	基準:with respect to
	across
	incognito
	過去現在未来:past, present, and future,
	より長い:longer
	:in place#1
	against
	変わり:vary
	●指示語
	以前:previously
	, :both
	最後に:finally
	短い:short


●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMA-262]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.es/ecma262/multipage/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[SPECTRE]
    Spectre Attacks: Exploiting Speculative Execution. Paul Kocher; Jann Horn; Anders Fogh; Daniel Genkin; Daniel Gruss; Werner Haas; Mike Hamburg; Moritz Lipp; Stefan Mangard; Thomas Prescher; Michael Schwarz; Yuval Yarom. January 2018. URL: https://spectreattack.com/spectre.pdf
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CACHE-ATTACKS]
    The Spy in the Sandbox - Practical Cache Attacks in Javascript. Yossef Oren; Vasileios P. Kemerlis; Simha Sethumadhavan; Angelos D. Keromytis. 1 March 2015. URL: https://arxiv.org/abs/1502.07373


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより
編集者草案として公開された
<a href="~SPEC_URL">High Resolution Time</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/hr-time-3/
編集者草案
	https://w3c.github.io/hr-time/

テスト一式
	https://wpt.live/hr-time/
実装報告
	https://wpt.fyi/hr-time/

編集
	<a href="yoav@yoav.ws">Yoav Weiss</a> (Google LLC)
前任編集者
	<a href="mailto:igrgiroik@gmail.com">Ilya Grigorik</a> (Google LLC) - Until 01 March 2021
	<a href="mailto:simonjam@google.com">James Simonsen</a> (Google LLC) - Until 01 January 2015
	<a href="mailto:jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) - Until 01 February 2014
Participate
	<a href="https://github.com/w3c/hr-time/">GitHub w3c/hr-time</a>
	<a href="https://github.com/w3c/hr-time/issues/">File a bug</a>
	<a href="https://github.com/w3c/hr-time/commits/gh-pages">Commit history</a>
	<a href="https://github.com/w3c/hr-time/pulls/">Pull requests</a>

ブラウザサポート
	https://caniuse.com/high-resolution-time
発行者
	<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
</script>

</head>
<body>

<header>

	<hgroup>
<h1>高分解能な計時 — High Resolution Time</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、分解能が~milli秒より細かい（ `sub-millisecond^en ）†, かつ
`外的な時計~調整$の~subjectにされない［
`時刻起点$／現在の時刻
］を供する~APIを定義する。
【†<a href="#desired-resolution" >具体的な精度は決まっていない</a>。】
◎
This specification defines an API that provides the time origin, and current time in sub-millisecond resolution, such that it is not subject to system clock skew or adjustments.
</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
この節では、発行時点における…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status">W3C 日本語訳 共通~page</a>／冒頭の仕様~metadataに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<ul>
	<li>
この訳の~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IF, ~THROW 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</li>
	<li>
`外的な時計~調整@
— この訳では、原文の
“`system clock adjustments^en”, “`system clock skew^en”
の総称として，この語を利用する
— この仕様が定義する~modelにおいては、これらを区別する必要はないので。
原文には説明されていないが、
`system clock adjustments^en は、 NTP などの外部の基準~時計と~system時計とのずれを
— 自動的に，場合によっては利用者が —
調整することを意味するようだ。
`clock skew^en は、 Wikipedia によれば［
熱などの物理的な要因／回路構成などの機械的な要因
］による，~system内の複数箇所の間の~driftを意味するようだが、この語の用法から，それに対処するために~system時計を調整することを表すと見受けられる。
</li>
	<li>
`~JS時刻@
は、
`ECMA-262$r に定義される
<a href="~TC39#sec-time-values-and-time-range">時刻</a>
を指す（単に “時刻（ `time^en ）” では汎用に過ぎるので、この訳では，このように言い換える）。
~JS時刻は、過去には（公式的な定義がない）
<a href="https://en.wikipedia.org/wiki/Unix_time">Unix 時刻</a>
と称されていた。
</li>
</ul>

	</section>
	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
ECMAScript 言語~仕様 `ECMA-262$r は、
1970 年 1 月 1 日 UTC からの~milli秒数による時間を表現する時刻~値として，
`Date$c ~objを定義する。
この値は， 1970 年 1 月 1 日 UTC から約 285616 年間のどの時刻も~milli秒数で表現でき、ほとんどの目的においては，この定義で足りる。
◎
The ECMAScript Language specification [ECMA-262] defines the Date object as a time value representing time in milliseconds since 01 January, 1970 UTC. For most purposes, this definition of time is sufficient as these values represent time to millisecond precision for any instant that is within approximately 285,616 years from 01 January, 1970 UTC.
</p>

<p>
これらの定義による時刻は、実施においては，`外的な時計~調整$の~subjectにもなる。
時刻~値は常に単調増加するとは限らず，後続の値は減少したり, 同じままになることもある。
◎
In practice, these definitions of time are subject to both clock skew and adjustment of the system clock. The value of time may not always be monotonically increasing and subsequent values may either decrease or remain the same.
</p>

<div class="example">
<p>
例えば 次の~scriptは、
%duration の計算結果として［
正な値, 負な値, 0
］いずれも記録し得る。
◎
For example, the following script may record a positive number, negative number, or zero for computed duration:
◎
Example 1
</p>

<pre class="lang-js">
var %mark_start = Date.now();
doTask(); // <span class="comment">何らかの~task</span>
var %duration = Date.now() - %mark_start;
</pre>

</div>

<p>
この定義による時刻は、ある種の~taskには不足になろう
— ［
安定的な`単調増加~時計$を成さず，`外的な時計~調整$の~subjectになる／
~milli秒より細かい分解能を供さない
］ので。
◎
For certain tasks this definition of time may not be sufficient as it:
• Does not have a stable monotonic clock, and as a result, it is subject to system clock skew.
• Does not provide sub-millisecond time resolution.
</p>

<p>
この仕様は、 `Date.now()$c `ECMA-262$r の挙動を変更するよう提案するものではない。
それは、［
暦における現在の時刻~値を決定すること
］においては生粋に有用であり，長い利用の歴史がある。
上に挙げた課題は、
`DOMHighResTimeStamp$I 型と `Performance$I の［
`now()$m  ~method／
`timeOrigin$m 属性
］が［
単調増加する, 分解能が~milli秒より細かい時刻~値
］を供することにより，解決される。
◎
This specification does not propose changing the behavior of Date.now() [ECMA-262] as it is genuinely useful in determining the current value of the calendar time and has a long history of usage. The DOMHighResTimeStamp type, Performance.now() method, and Performance.timeOrigin attributes of the Performance interface resolve the above issues by providing monotonically increasing time values with sub-millisecond resolution.
</p>

<p class="note">注記：
この仕様は、~milli秒より細かい分解能を供するよう，義務付けるものではない。
~privacyと~securityの理由から，実装は、自身が公開する~timerの分解能を制限して，~milli秒より細かい~timerは公開しないことにしてもヨイ。
それが起きた下では、~milli秒より細かい分解能に依拠する利用事例は，満足されないであろう。
◎
Note

Providing sub-millisecond resolution is not a mandatory part of this specification. Implementations may choose to limit the timer resolution they expose for privacy and security reasons, and not expose sub-millisecond timers. Use-cases that rely on sub-millisecond resolution may not be satisfied when that happens.
</p>

		<section id="use-cases">
<h3 title="Use-cases">1.1. 利用事例</h3>

~INFORMATIVE

<p>
この仕様は、次に挙げる能力を伴う時計を定義して，それに基づいて時刻印を供する：
⇒＃
安定的,
単調増加,
異なる文脈で比較-可能,
~milli秒より細かい分解能にもなり得る
◎
This specification defines a few different capabilities: it provides timestamps based on a stable, monotonic clock, comparable across contexts, with potential sub-millisecond resolution.
</p>

<p>
処理能の測定にとって，安定的に単調増加する時計の必要性が問われるのは、当の測定が無関係な`外的な時計~調整$により歪められ，無用に化す事実があることに起因する。
例えば，［
文書~navi, 資源の~fetching, ~scriptの実行
］などに費やされた時間を正確aに測定しようと試みるとき、単調増加する, かつ分解能が~milli秒より細かい時計が欲される。
◎
The need for a stable monotonic clock when talking about performance measurements stems from the fact that unrelated clock skew can distort measurements and render them useless. For example, when attempting to accurately measure the elapsed time of navigating to a Document, fetching of resources or execution of script, a monotonically increasing clock with sub-millisecond resolution is desired.
</p>

<p>
異なる文脈で得られた時刻印を比較することは，例えば、次のときに本質的になる
⇒
`Worker$I と~main~threadの間で作業を同期するとき／
そのような作業を計測して，~event時列線の統一された~viewを作成するとき
◎
Comparing timestamps between contexts is essential e.g. when synchronizing work between a Worker and the main thread or when instrumenting such work in order to create a unified view of the event timeline.
</p>

<p>
最後に，~milli秒より細かい~timerは、次に挙げる利用事例の周りで必要になる：
◎
Finally, the need for sub-millisecond timers revolves around the following use-cases:
</p>
<ul>
	<li>
~milli秒より細かい周期で作業を~scheduleする能。
それは、利用者から可視になるカクつきを避けるため，特に~main~threadで重要になる
— そこでの作業は、［
短い周期で定期的に起きる必要がある，~frameの描画
］に干渉し得る。
◎
Ability to schedule work in sub-millisecond intervals. That is particularly important on the main thread, where work can interfere with frame rendering which needs to happen in short and regular intervals, to avoid user-visible jank.
</li>
	<li>
~scriptに基づく~animationの~frame~rateを計算するとき、~animationが 60 FPS で描画されているかどうか決定するためには，~milli秒より細かい分解能が必要になる。
~milli秒より細かくなければ、開発者は 58.8 FPS と 62.5 FPS を区別するのが限界になる（ 1 ~frameあたり前者が 1/58.8 = 約 0.017 秒, 後者は 0.016 秒）。
◎
When calculating the frame rate of a script-based animation, developers will need sub-millisecond resolution in order to determine if an animation is drawing at 60 FPS. Without sub-millisecond resolution, a developer can only determine if an animation is drawing at 58.8 FPS (1000ms / 16) or 62.5 FPS (1000ms / 17).
</li>
	<li>
開発者は，~JS~codeの測定を~~自前で収集するとき（例：`User Timing$cite を利用して）、自身の関数に対し~milli秒より細かい計時を集めて，退歩を早期に捕えることにも関心があろう。
◎
When collecting in-the-wild measurements of JS code (e.g. using User-Timing), developers may be interested in gathering sub-milliseconds timing of their functions, to catch regressions early.
</li>
	<li>
~animation内の特定の時点に音声を~cueしようと試みるときや,
音声と~animationが完璧に同期するのを確保するためには、開発者は，時間の~~長さを正確aに測定する必要がある。
◎
When attempting to cue audio to a specific point in an animation or ensure that the audio and animation are perfectly synchronized, developers will need to accurately measure the amount of time elapsed.
</li>
</ul>

		</section>
		<section id="examples">
<h3 title="Examples">1.2. 例</h3>

~INFORMATIVE

<p>
開発者は、自身の~app全体にわたり，`時刻起点$が異なる［
`Worker$I や `SharedWorker$I
］からの~eventも含むような時列線（ `timeline^en ）†を構築したいと望むこともあろう。
`timeOrigin$m 属性の助けを借りて 各~eventの `DOMHighResTimeStamp$I 値を換算すれば、~appは，そのような~eventたちを同じ時列線~上に表示できる。
◎
A developer may wish to construct a timeline of their entire application, including events from Worker or SharedWorker, which have different time origins. To display such events on the same timeline, the application can translate the DOMHighResTimeStamps with the help of the Performance.timeOrigin attribute.
</p>

<p class="trans-note">【†
生じた~eventをその時刻とともに時系列順に記録するもの（無数の時刻~値からなる昇順の並びが成す線）。
】</p>

<div class="example">

<pre class="lang-js">
// ---- worker.js -----------------------------
/* <span class="comment">
`SharedWorker$I 内の~script
◎
Shared worker script
</span> */
onconnect = function(%e) {
  var %port = %e.ports[0];
  %port.onmessage = function(%e) {
    /* <span class="comment">
~worker内での計時~task
◎
Time execution in worker
</span> */
    var %task_start = performance.now();
    %result = runSomeWorkerTask();
    var %task_end = performance.now();
  }

  /* <span class="comment">
結果と, および~epochに相対的な時刻印を，別の文脈へ送信する
◎
Send results and epoch-relative timestamps to another context
</span> */
  %port.postMessage({
     'task': 'Some worker task',
     'start_time': %task_start + performance.timeOrigin,
     'end_time': %task_end + performance.timeOrigin,
     'result': %result
  });
}

// ---- application.js ------------------------
/* <span class="comment">
文書~内での計時~task
◎
Timing tasks in the document
</span> */
var %task_start = performance.now();
runSomeApplicationTask();
var %task_end = performance.now();

/* <span class="comment">
稼働時の処理能~dataを~uploadするために開発者が供した~method
◎
developer provided method to upload runtime performance data
</span> */
reportEventToAnalytics({
  'task': 'Some document task',
  'start_time': %task_start,
  'duration': %task_end - %task_start
});

/* <span class="comment">
~workerの時刻印を文書の`時刻起点$に換算する
◎
Translating worker timestamps into document's time origin
</span> */
var %worker = new SharedWorker('worker.js');
%worker.port.onmessage = function (%event) {
  var %msg = %event.data;

  /* <span class="comment">
~epochに相対的な時刻印を文書の`時刻起点$に換算する
◎
translate epoch-relative timestamps into document's time origin
</span> */
  %msg.start_time = %msg.start_time - performance.timeOrigin;
  %msg.end_time = %msg.end_time - performance.timeOrigin;

  reportEventToAnalytics(%msg);
}
</pre>

</div>

		</section>
	</section>
	<section id="sec-time-origin">
<h2 title="Time Origin">2. 時刻起点</h2>

<p>
`時刻起点@
（ `time origin^en ）とは、時間を測定する起点であり，所与の`大域~obj$rM %G に応じて，次で定義される時点になるモノトスル：
◎
The time origin is the time value from which time is measured:
</p>

<ul class="switch">
	<li>
<p>
%G は `Window$I ~objである場合：
◎
If the global object is a Window object, the time origin MUST be equal to: 
</p>
		<ol>
			<li>
前の文書がない場合
⇒
%G に`対応する閲覧文脈$が最初に<a href="~BROWSERS#creating-a-new-browsing-context">作成され</a>た時点
◎
the time when the browsing context is first created if there is no previous document;
</li>
			<li>
前の文書が存在していて, それが`~unloadを~promptする$間に利用者に確認~dialogが表示された場合
⇒
利用者が~naviを確認した時点
◎
otherwise, the time of the user confirming the navigation during the previous document's prompt to unload algorithm, if a previous document exists and if the confirmation dialog was displayed; 
</li>
			<li>
他の場合
⇒
%G に`結付けられている文書$の読込ngを担当する`~navi$を開始した時点
◎
otherwise, the time of starting the navigation responsible for loading the Window object's newest Document object.
</li>
		</ol>
	</li>
	<li>
%G は`WorkerGlobalScope$I ~objである場合
⇒
%G の`公式的な作成~時点$。
◎
If the global object is a WorkerGlobalScope object, the time origin MUST be equal to the official moment of creation of the worker.
</li>
	<li>
他の場合
⇒
未定義とする。
◎
Otherwise, the time origin is undefined.
</li>
</ul>

<div class="algo">
<p>
`時刻起点~時刻印を取得する@
ときは、所与の
( `大域~obj$rM %G )
に対し，次の手続きを走らす：
◎
To get time origin timestamp, given a global object global, runs the following steps:
</p>
<ol>
	<li>
~Assert：
%G の`時刻起点$は未定義でない。
◎
Assert: global's time origin is not undefined.
</li>
	<li>
<p>
~RET `細かさを抑えた時刻$( 次の 2 つの合計, %G に`関連な設定群~obj$の`非同一-生成元~能力は隔離-済みか？$enV )：
</p>
		<ul>
			<li>
［
`共有される単調増加~時計$が時刻 0 を指す時点
］を高分解能な時刻【絶対的な時刻（`~JS時刻$）】で表現している `DOMHighResTimeStamp$I 値
</li>
			<li>
［
`共有される単調増加~時計$が %G の`時刻起点$を指す時点
］を高分解能な時刻で表現している `DOMHighResTimeStamp$I 値
</li>
		</ul>

◎
Let t1 be the DOMHighResTimeStamp representing the high resolution time at which the shared monotonic clock is zero.
◎
Let t2 be the DOMHighResTimeStamp representing the high resolution time value of the shared monotonic clock at global's time origin.
◎
Let total be the sum of t1 and t2.
◎
Return the result of calling coarsen time with total and global's relevant settings object's cross-origin isolated capability.
</li>
</ol>

<p class="note">注記：
この~algoが返す値は、`時刻起点$が 0 を指すときの高分解能な時刻~値である。
それは、［
`外的な時計~調整$の~subjectでない`共有される単調増加~時計$
］を基準に記録されるので，［
`Date.now()$c を “0 時刻”
【すなわち、時刻起点】に実行したときの結果
］と相違し得る
— <a href="#sec-monotonic-clock">§ 単調増加~時計</a>
を見よ。
◎
Note

The value returned by get time origin timestamp is the high resolution time value at which time origin is zero. It may differ from the value returned by Date.now() executed at "zero time", because the former is recorded with respect to a shared monotonic clock that is not subject to system and user clock adjustments, clock skew, and so on — see § 7 Monotonic Clock.
</p>
</div>

<div class="algo">
<p>
`細かさを抑えた時刻@
（ `coarsen time^en ）は、所与の
( `DOMHighResTimeStamp$I 値 %時刻印, 真偽値 %非同一-生成元~能力は隔離-済みか （省略時は ~F ） )
に対し，次の手続きを走らす：
◎
The coarsen time algorithm, given a DOMHighResTimeStamp timestamp and an optional boolean crossOriginIsolatedCapability (default false), runs the following steps:
</p>
<ol>
	<li>
%時間~分解能 ~LET %非同一-生成元~能力は隔離-済みか に応じて
⇒＃
~F ならば `実装定義$な 100 ~micro秒 以上の値 ／
~T ならば `実装定義$な 5 ~micro秒 以上の値
◎
Let time resolution be 100 microseconds, or a higher implementation-defined value.
◎
If crossOriginIsolatedCapability is true, set time resolution to be 5 microseconds, or a higher implementation-defined value.
</li>
	<li>
`実装定義$な方式で、
%時刻印 に対し，その分解能の細かさを %時間~分解能 より抑えた上で，任意選択で ゆらぎも加える
【この段は、複数回の~callにわたって互いに関連する制御になろう。<a href="#clock-resolution">§ 時計の分解能</a>を見よ。】
◎
In an implementation-defined manner, coarsen and potentially jitter timestamp such that its resolution will not exceed time resolution.
</li>
	<li>
~RET %時刻印
◎
Return timestamp.
</li>
</ol>
</div>

<div class="algo">
`相対的な高分解能~時刻@
は、所与の
( `DOMHighResTimeStamp$I 値 %時刻, `大域~obj$rM %G )
に対し，次の結果を返す
⇒
`細かさを抑えた相対的な高分解能~時刻$( 次の結果, %G )
⇒
`細かさを抑えた時刻$( %時刻, %G に`関連な設定群~obj$の`非同一-生成元~能力は隔離-済みか？$enV )
◎
The relative high resolution time given a DOMHighResTimeStamp time and a global object global, is the result of the following steps:
• Let coarse time be the result of calling coarsen time with time and global's relevant settings object's cross-origin isolated capability.
• Return the relative high resolution coarse time for coarse time and global.
</div>

<div class="algo">
`細かさを抑えた相対的な高分解能~時刻@
は、所与の
( `DOMHighResTimeStamp$I 値 %細かさを抑えた時刻, `大域~obj$rM %G )
に対し，次の結果を返す
⇒
%細かさを抑えた時刻 ~MINUS `時刻起点~時刻印を取得する$( %G )
◎
The relative high resolution coarse time given a DOMHighResTimeStamp coarseTime and a global object global, is the difference between coarseTime and the result of calling get time origin timestamp with global.
</div>

<div class="algo">
<p>
`現在の高分解能~時刻@
は、所与の
( `大域~obj$ %G )
に対し，次の結果を返す
⇒
`相対的な高分解能~時刻$( `安全でない共有される現在の時刻$, %G )
◎
The current high resolution time given a global object current global must return the result of relative high resolution time given unsafe shared current time and current global.
</p>

<p class="trans-note">【
他の仕様は、この手続きを %G を省略して呼出すことが多い
— その場合、文脈から暗黙的に決定されることになる（例えば，~APIを定義する手続きの中から呼出された場合、 %G はコレに`関連な大域~obj$になろう）。
】</p>
</div>

<div class="algo">
`細かさを抑えた共有される現在の時刻@
は、所与の
( 真偽値 %非同一-生成元~能力は隔離-済みか （省略時は ~F ） )
に対し，次の結果を返すモノトスル
⇒
`細かさを抑えた時刻$( `安全でない共有される現在の時刻$, %非同一-生成元~能力は隔離-済みか )
◎
The coarsened shared current time given an optional boolean crossOriginIsolatedCapability (default false), must return the result of calling coarsen time with the unsafe shared current time and crossOriginIsolatedCapability.
</div>

<div class="algo">
`安全でない共有される現在の時刻@
は、`共有される単調増加~時計$の現在の値を返すモノトスル。
◎
The unsafe shared current time must return the current value of the shared monotonic clock.
</div>

<div class="algo">
<p>
`~epochに相対的な時刻印@
は、所与の
( 日時 %時刻 （省略時は現在の時刻） )
に対し：
◎
To get an epoch-relative timestamp, optionally with a date-time time:
• If time was not passed, set time to the current time.
</p>
<ol>
	<li>
%~epoch ~LET 1 `January 1970 00:00:00 UTC^ 【 1970 年 1 月 1 日】
◎
↓</li>
	<li>
~Assert：
%時刻 ~GTE %~epoch
【 “%時刻 は %~epoch より過去でない” 】
◎
Assert: time is greater than or equal to 1 January 1970 00:00:00 UTC.
</li>
	<li>
~RET %~epoch から %時刻 までの~milli秒数
— ここでは、 1 日は 86400秒, 1 秒は 1000 ~milli秒からなるとする
（すなわち、閏秒は織り込まないとする）
◎
Return the number of milliseconds from 1 January 1970 00:00:00 UTC to time: where each day is comprised of 86,400 seconds, each of which is 1000 milliseconds long (i.e., don't account for leap seconds).
</li>
</ol>

<p class="trans-note">【
%時刻 の型 “日時（ `date-time^en ）” には特定の型は指定されていないが、
~JS `Date$c と整合するように定義される何かと解釈すればよいであろう
（例： “現在の時刻” は `Date.now()$c に一致する）
— いずれにせよ，結果は負でない整数になる
（ <a href="#the-epochtimestamp-typedef">§ `EpochTimeStamp^I ~typedef</a>を見よ）。
】</p>
</div>

	</section>
	<section id="sec-domhighrestimestamp">
<h2 title="The DOMHighResTimeStamp typedef">3. `DOMHighResTimeStamp^I ~typedef</h2>

<div class="p">
<p>
`DOMHighResTimeStamp$I
型は、次のいずれかを表現する，~milli秒数による値を格納するために利用される：
</p>

<ul ><li>`時刻起点$から相対的に測定された時刻
</li><li>`共有される単調増加~時計$から相対的に測定された時刻
</li><li>2 つの `DOMHighResTimeStamp$I 値の時間~差
</li></ul>
◎
The DOMHighResTimeStamp type is used to store a time value in milliseconds, measured relative from the time origin, shared monotonic clock, or a time value that represents a duration between two DOMHighResTimeStamps.
</div>

<pre class="idl">
typedef `double$ `DOMHighResTimeStamp@I;
</pre>

<p id="desired-resolution">
`DOMHighResTimeStamp$I 値は、~milli秒数による時間を，［
測定には十分, かつ計時~攻撃は防止する
］正確aさで表現するベキである。
追加的な考慮点については、
<a href="#clock-resolution">§ 時計の分解能</a>
を見よ。
◎
A DOMHighResTimeStamp SHOULD represent a time in milliseconds accurate enough to allow measurement while preventing timing attacks - see § 8.1 Clock resolution for additional considerations.
</p>

	</section>
	<section id="the-epochtimestamp-typedef">
<h2 title="The EpochTimeStamp typedef">4. `EpochTimeStamp^I ~typedef</h2>

<pre class="idl">
typedef `unsigned long long$ `EpochTimeStamp@I;
</pre>

<p class="note">注記：
`EpochTimeStamp$I は、
旧来の~platform特能であり，以前まで `DOMTimeStamp^I として知られていた。
`EpochTimeStamp^I の利用は、忌避される
— アリなときは、代わりに `DOMHighResTimeStamp$I を利用すること。
◎
Note: Legacy platform feature

The use of EpochTimeStamp, known previously as DOMTimeStamp, is discouraged. Wherever possible use DOMHighResTimeStamp instead.
</p>

<p>
`EpochTimeStamp$I は、
`01 January, 1970 00:00:00 UTC^ から
所与の時刻までの，閏秒を除外した~milli秒数を表現する。
この~milli秒数がどう解釈されるかは、
この型を利用する仕様が定義することになる。
`EpochTimeStamp$I は、
`~epochに相対的な時刻印$を引数を伴わずに~callすることにより初期化され，
既定では現在の時刻になる。
異なる相対的な時刻を要求する仕様は、
必要なら，引数に日時を伴わせて`~epochに相対的な時刻印$を~callできる。
◎
A EpochTimeStamp represents the number of milliseconds from a given time to 01 January, 1970 00:00:00 UTC, excluding leap seconds. Specifications that use this type define how the number of milliseconds are interpreted. An EpochTimeStamp is initialized by calling epoch-relative timestamp with no arguments, which defaults to the current time. Specifications that require a different relative time can call epoch-relative timestamp with a date-time as an argument, if needed.
</p>

	</section>
	<section id="sec-performance">
<h2 title="The Performance interface">5. `Performance^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `Performance@I : `EventTarget$I {
    `DOMHighResTimeStamp$I `now()$m;
    readonly attribute `DOMHighResTimeStamp$I `timeOrigin$m;
    [`Default$] `object$ `toJSON()$m;
};
</pre>

<div class="algo" id="now-method">
`now()@m
~method~手続きは、`現在の高分解能~時刻$を返す。
`basic.any$test
`basic.any.worker$test
◎
§ 5.1 now() method
◎
The now() method MUST return the current high resolution time.
</div>

<div class="algo" id="timeorigin-attribute">
`timeOrigin@m
取得子~手続きは、次の結果を返す
⇒
`時刻起点~時刻印を取得する$( コレに`関連な大域~obj$ )
`timeOrigin$test
`window-worker-timeOrigin.window$test
◎
§ 5.2 timeOrigin attribute
◎
The timeOrigin attribute MUST return the value returned by get time origin timestamp for the relevant global object of this.
</div>

<div class="algo" id="tojson-method">
`toJSON()@m
~method~手続きは、`既定の~toJSON手続き$ `WEBIDL$r で与えられる。
`performance-tojson$test
◎
§ 5.3 toJSON() method
◎
When toJSON() is called, run [WEBIDL]'s default toJSON steps.
</div>

	</section>
	<section id="extensions-to-windoworworkerglobalscope-mixin">
<h2 title="Extensions to WindowOrWorkerGlobalScope mixin">6. `WindowOrWorkerGlobalScope^I ~mixinに対する拡張</h2>

<p id="the-performance-attribute">
`WindowOrWorkerGlobalScope$I の
`performance@m
属性は、`大域~obj$rMからの［
処理能に関係する属性や~method
］へ~accessできるようにする。
◎
5.1 The performance attribute
◎
The performance attribute on the interface mixin WindowOrWorkerGlobalScope allows access to performance related attributes and methods from the global object.
</p>

<pre class="idl">
partial interface mixin `WindowOrWorkerGlobalScope$I {
    [`Replaceable$] readonly attribute `Performance$I `performance$m;
};
</pre>

	</section>
	<section id="sec-monotonic-clock">
<h2 title="Monotonic Clock">7. 単調増加~時計</h2>

<div class="p">
<p>
［
同じ`時刻起点$を共有する，各 `Performance$I ~obj
］の `now()$m ~methodが返す時刻~値は、同じ`単調増加~時計$を利用するモノトスル。
同じ `Performance$I ~objの `now()$m ~methodが返す，時系列順に記録された 2 つの時刻~値の差は、決して負にならないモノトスル。
</p>

<p class="trans-note">【
どの `Performance$I ~objたちが同じ`時刻起点$を共有するものとされるかは、この仕様には述べられていない。
】</p>

<p>
`単調増加~時計@
とは、［
`外的な時計~調整$の~subjectにされることなく，単調増加する
］ような時計である。
`monotonic-clock.any$test
`monotonic-clock.any.worker$test
</p>

◎
The time values returned when calling the now() method on Performance objects with the same time origin MUST use the same monotonic clock that is monotonically increasing and not subject to system clock adjustments or system clock skew. The difference between any two chronologically recorded time values returned from the now() method MUST never be negative if the two time values have the same time origin.
</div>

<div class="p">
<p>
`timeOrigin$m が返す時刻~値には、同じ`共有される単調増加~時計$を利用するモノトスル†。
`共有される単調増加~時計@
とは、`~JS時刻$を基準にする`単調増加~時計$であり，いくつかの`時刻起点$から共有される。
<a href="#sec-privacy-security">~privacyと~security</a>
を見よ。
`test_cross_frame_start$test
</p>

<p class="trans-note">【
どの`時刻起点$
— 言い換えれば、`大域~obj$rM —
たちが同じこの時計を共有するものとされるかは，この仕様には定義されていないが、下の注記に見られるように，互いに情報をやりとりできる`大域~obj$rMどうしは共有することになろう。
】【†
この要件をより詳細に述べるなら、
“2 つの`大域~obj$rM %G1, %G2 が同じ`共有される単調増加~時計$を共有するならば、
%G1, %G2 の［
`performance$m 属性が返す `Performance$I ~objの `timeOrigin$m が返す時刻~値
］には，その時計を利用するモノトスル”
となるであろう。
】</p>

◎
The time values returned when getting Performance.timeOrigin MUST use the same shared monotonic clock that is shared by time origins, is monotonically increasing and not subject to system clock adjustments or system clock skew, and whose reference point is the [ECMA-262] time definition - see § 8. Privacy and Security.
</div>

<p class="note">注記：
~UAは、［
~browserの各~再起動 ／
他から隔離された閲覧~session（例：~~私的（ `incognito or similar^en ）閲覧~mode）の各~開始
］ごとに，自身の`共有される単調増加~時計$を設定し直せる。
そのため，開発者は、［［
過去現在未来すべての文脈にわたり，単調増加するような~prop
］を保持する，絶対的な時刻
］には，共有される時刻印を利用するベキでない。
実施において，単調増加する~propを適用できる用途は、［
供されている~message法の仕組み
— 例： `postMessage()^m, `BroadcastChannel$I, 等々 —
を介して~messageを交換することにより，互いに他へ到達できるような文脈
］に限られる。
◎
Note

The user agent can reset its shared monotonic clock across browser restarts, or whenever starting an isolated browsing session—e.g. incognito or similar browsing mode. As a result, developers should not use shared timestamps as absolute time that holds its monotonic properties across all past, present, and future contexts; in practice, the monotonic properties only apply for contexts that can reach each other by exchanging messages via one of the provided messaging mechanisms - e.g. postMessage, BroadcastChannel, etc.
</p>

<p class="note">注記：
ある種の局面においては（例：タブが~~背後に回されているとき）、~UAは，その文脈においては［
~callbackを周期的に走らす~~頻度を~~抑えるよう，~timerを絞る
］ことにする，あるいは まるごと凍結することさえあろう。
そのようにしたときでも、単調増加~時計が返す時刻の分解能や正確aさには影響するベキでない。
◎
Note

In certain scenarios (e.g. when a tab is backgrounded), the user agent may choose to throttle timers and periodic callbacks run in that context or even freeze them entirely. Any such throttling should not affect the resolution or accuracy of the time returned by the monotonic clock.
</p>

	</section>
	<section id="sec-privacy-security">
<h2 title="Privacy and Security">8. ~privacyと~security</h2>

		<section id="clock-resolution">
<h3 title="Clock resolution">8.1. 時計の分解能</h3>

<p>
正確aな計時~情報への~accessは、測定と~schedule法の両~目的において，多くの~appに共通な要件である。
例えば，［
~animation, 音, その他の~page上の活動
］を協調して，より良い利用者~体験を供するためには、高分解能な時間への~accessを要する。
同様に，測定により、開発者は，~codeの決定的な部位における処理能を追跡したり, 退歩を検出する, 等々
が可能になる。
◎
Access to accurate timing information, both for measurement and scheduling purposes, is a common requirement for many applications. For example, coordinating animations, sound, and other activity on the page requires access to high-resolution time to provide a good user experience. Similarly, measurement enables developers to track the performance of critical code components, detect regressions, and so on.
</p>

<p>
しかしながら，その同じ正確aな計時~情報への~accessは、さもなければ攻撃者が見たり~accessできない~dataを推測して推定するような，悪意的な攻撃~目的にも利用され得る。
例えば［
~cache攻撃／
統計的な指紋収集（ `statistical fingerprinting^en ）／
CPU ~architectureに乗じる攻撃（ `micro-architectural attack^en ）
］は、悪意的な~web~siteが［
利用者たちを分別する／
特定0の利用者を識別する ／
同一-~process内の無関係な利用者~dataを露呈する
］ために［
~browserや~appから起動される様々な演算による，高分解能な計時~data
］を利用し得る所における［
~privacy／~security
］（順不同）の懸念である
— さらなる背景は `CACHE-ATTACKS$r, `SPECTRE$r を見よ。
◎
However, access to the same accurate timing information can sometimes be also used for malicious purposes by an attacker to guess and infer data that they can't see or access otherwise. For example, cache attacks, statistical fingerprinting and micro-architectural attacks are a privacy and security concern where a malicious web site may use high resolution timing data of various browser or application-initiated operations to differentiate between subset of users, identify a particular user or reveal unrelated but same-process user data - see [CACHE-ATTACKS] and [SPECTRE] for more background.
</p>

<p>
この仕様は、これまで `EpochTimeStamp$I に公開され可用であった~milli秒の分解能より正確aな，より細かい時間~分解能を供する~APIを定義する。
しかしながら，この新たな~APIがなくとも、攻撃者は，~~反復~実行と統計的な分析を通して，高分解能な見積もりを得することはできる。
`timing-attack$test
◎
This specification defines an API that provides sub-millisecond time resolution, which is more accurate than the previously available millisecond resolution exposed by EpochTimeStamp. However, even without this new API an attacker may be able to obtain high-resolution estimates through repeat execution and statistical analysis.
</p>

<p>
新たな~APIにより，そのような攻撃の正確度や速度が有意に向上されないことを確保するため、
`DOMHighResTimeStamp$I 型の分解能は，攻撃を防止するに十分な正確aさに抑えるベキである。
◎
To ensure that the new API does not significantly improve the accuracy or speed of such attacks, the minimum resolution of the DOMHighResTimeStamp type should be inaccurate enough to prevent attacks.
</p>

<p>
~UAは、~architectureや~softwareにおける拘束, その他の考慮点に因り，~privacyと~securityの懸念に取組むため必要とされる所では、`細かさを抑えた時刻$の処理~modelにおいて
%時間~分解能 に設定する値をもっと高くする【すなわち粗くする】ベキである。
◎
Where necessary, the user agent should set higher resolution values to time resolution in coarsen time's processing model, to address privacy and security concerns due to architecture or software constraints, or other considerations.
</p>

<p>
~UAは、そのような攻撃を軽減するために必要と判断される技法があれば，配備してもヨイ。
そのような技法の配備は、次に挙げるものに基づいて変わり得る
⇒＃
~browserの~architecture,
利用者の機器,
内容,
内容が非同一-生成元~dataを悪意的に読取る能,
その他の実用上の考慮点
◎
In order to mitigate such attacks user agents may deploy any technique they deem necessary. Deployment of those techniques may vary based on the browser's architecture, the user's device, the content and its ability to maliciously read cross-origin data, or other practical considerations.
</p>

<p>
これらの技法には、次も含まれよう
⇒＃
分解能の抑制／
ゆらぎを加える／
濫用を検出して~API~callを絞る
◎
These techniques may include:
• Resolution reduction.
• Added jitter.
• Abuse detection and/or API call throttling.
</p>

<p>
そのような計時~側からの攻撃を まるごと軽減するのは、実用的には不可能である：
そのためには，［
すべての演算の実行~時間は，機密的な情報の値に応じて変わらないようにする
］か［
~appを，時間に関係するあらゆる~~基盤（時計, ~timer, ~counter, 等々）から隔離する
］必要があるが、どちらも，［［
~browser／~app
］開発者にとっての複階性
］および［
~appの［
処理能, 応答性
］に対する負な効果
］につながることに因り，実用的でない。
◎
Mitigating such timing side-channel attacks entirely is practically impossible: either all operations would have to execute in a time that does not vary based on the value of any confidential information, or the application would need to be isolated from any time-related primitives (clock, timers, counters, etc). Neither is practical due to the associated complexity for the browser and application developers and the associated negative effects on performance and responsiveness of applications.
</p>

<p class="note">注記：
時計の分解能は、未解決かつ発展途上な事実調査の分野であり，すべての~browserに適用される既存の［
業界~総意／権威ある推奨
］は無い。
<a href="https://github.com/w3c/hr-time/issues/79">課題 #79</a>
にて，論点を追跡できる。
◎
Note

Clock resolution is an unsolved and evolving area of research, with no existing industry consensus or definitive set of recommendations that applies to all browsers. To track the discussion, refer to Issue 79.
</p>

		</section>
		<section id="clock-drift">
<h3 title="Clock drift">8.2. 時計の~drift</h3>

<p>
この仕様は、［
分解能が~milli秒より細かい`時刻起点~時刻印$
］を供する~APIも定義する。
~APIには［
すべての~browser文脈にわたって共有されなければナラナイ，`共有される単調増加~時計$
］が要求され，それを~appに公開する。
この時計は，物理的な時刻に縛られる必要はないが、新たな［
利用者についての指紋収集-
］~entropyを公開するのを避けるため，`~JS時刻$を基準に設定することが推奨される。
~JS時刻は，すでに~appにより容易に得される一方で、新たな論理-時計を公開するのは，新たな情報を供するに等しいので。
◎
This specification also defines an API that provides sub-millisecond time resolution of the zero time of the time origin, which requires and exposes a shared monotonic clock to the application, and that must be shared across all the browser contexts. The shared monotonic clock does not need to be tied to physical time, but is recommended to be set with respect to the [ECMA-262] definition of time to avoid exposing new fingerprint entropy about the user — e.g. this time can already be easily obtained by the application, whereas exposing a new logical clock provides new information.
</p>

<p>
しかしながら，上述した仕組みの下でも、`共有される単調増加~時計$は，
<a href="https://en.wikipedia.org/wiki/Clock_drift">時計の~drift</a>
（ `clock drift^en, “遅れ／進み” ）に関する分解能も供し得る。
今日の~appは、同じ文脈の中の複数の時点で，［
従来の時計による時刻印, 単調増加~時計による時刻印
］を（順に， `Date.now()$c, `now()$m を介して）得て，それらの間の~drift
— 例えば`外的な時計~調整$に因るそれ —
を観測できる。
攻撃者はまた、
`timeOrigin$m 属性から得られる［
`共有される単調増加~時計$から報告される`時刻起点~時刻印$
］と, 従来の時計により［
`共有される単調増加~時計$が 0 を指すと現在~見積もられる時刻
］（すなわち，
`Date.now()^c − `performance.now()^c
）とを，長時間にわたり比較して、これらの時計どうしの~driftを観測できる~~可能性がある。
◎
However, even with the above mechanism in place, the shared monotonic clock may provide additional clock drift resolution. Today, the application can timestamp the time-of-day and monotonic time values (via Date.now() and now()) at multiple points within the same context and observe drift between them—e.g. due to automatic or user clock adjustments. With the timeOrigin attribute, the attacker can also compare the time at which time origin is zero, as reported by the shared monotonic clock, against the current time-of-day estimate of when it is zero (i.e. the difference between Date.now() - performance.now() and performance.timeOrigin) and potentially observe clock drift between these clocks over a longer time period.
</p>

<p class="trans-note">【
例えば暗号処理を考える。
その処理の重さ（計算量）に因る CPU 熱は、`外的な時計~調整$（この事例では `clock skew^en ）をもたらす結果，時計の~driftに反映され得る。
攻撃者は、いくつかの入力とその計算量との相関関係を分析して，ある程度の情報を推定できるかもしれない。
】</p>

<p>
実施においては、~appは，同じ時刻~driftを複数回の~naviにわたり観測できる：
~appは、各~文脈における論理-時刻を記録し，
~client／~server
時刻~同期法の仕組みを利用して、利用者の時計における変化を推定できる。
同様に~TCP時刻印などの低層の仕組みは、複数回の訪問を要することなく，同じ高分解能な情報を~serverに露呈し得る。
そのようなわけで，この~APIにより供される情報は、有意な, あるいは以前までは可用でなかった，利用者についての~entropyを公開するベキでない。
◎
In practice, the same time drift can be observed by an application across multiple navigations: the application can record the logical time in each context and use a client or server time synchronization mechanism to infer changes in the user's clock. Similarly, lower-layer mechanisms such as TCP timestamps may reveal the same high-resolution information to the server without the need for multiple visits. As such, the information provided by this API should not expose any significant or previously unavailable entropy about the user.
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕事に貢献された次の方々に感謝する：
</p>

<p lang="en">
Thanks to Arvind Jain, Angelos D. Keromytis, Boris Zbarsky, Jason Weber, Karen Anderson, Nat Duca, Philippe Le Hegaret, Ryosuke Niwa, Simha Sethumadhavan, Todd Reifsteck, Tony Gentilcore, Vasileios P. Kemerlis, Yoav Weiss, and Yossef Oren for their contributions to this work.
</p>

	</section>
</main></div>
