<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>MIME Sniffing （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<style>
.hex-seq {
	font-family: sans-serif0, sans-serif;
}
.hex-seq > abbr {
	font-style: italic;
}

@supports (grid-template-columns: subgrid) and (display: contents) {

.patterns {
	grid-template-columns: 12em 12em 8em 1fr;
	min-width: 40em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"pattern mask 無視 MIME"
			"注記 注記 注記 注記"
		;
		> *:nth-child(1) {
			grid-area: pattern;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: mask;
		}
		> *:nth-child(3) {
			grid-area: 無視;
		}
		> *:nth-child(4) {
			grid-area: MIME;
		}
		> *:nth-child(5) {
			grid-area: 注記;
		}
	}
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	});
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'lX': // literal hex seq
	text = key.replace(/&(lt|gt|amp);|./g, function(s, s1){
		if(s1) {
			s = {lt:'<', gt: '>', amp:'&'}[s1];
		}
		return s.charCodeAt(0).toString(16) + ' ';
	}).toUpperCase();
	return `<span class="hex-seq">0x${text}</span>( \`<code class="literal">${key}</code>\` )`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl': // byte literal
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'U': // code point
	text = `<span class="code-point">U+${key}</span> (<span class="char-symbol">&#x${key};</span>)`;
	break;
case 'U0': // code point
	text = `<span class="code-point">U+${key}</span>`;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-07-24
trans_update:2024-07-25
source_checked:230717
spec_status:LS
original_url:https://mimesniff.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:,whatwg
trans_1st_pub:2018-02-18
site_nav:security,network


●●class_map
P:production
h:header
X:hex-seq
e:element
a:attr
mt:mime-type

●●tag_map
mt:code
c:code
e:code
a:code
P:code
h:code
X:span
i:i
V:var

●●link_map

a.type:~HEscripting#attr-script-type
e.script:~HEscripting#the-script-element

h.Content-Type:~HTTPsem#field.content-type

~HTTP引用符付き文字列~token符号位置:#http-quoted-string-token-code-point
~HTTP~token符号位置:#http-token-code-point

~MIME型:#mime-type
~MIME型~record:#mime-type

画像~MIME型:#image-mime-type
音声動画~MIME型:#audio-or-video-mime-type
~font~MIME型:#font-mime-type
~ZIPに基づく~MIME型:#zip-based-mime-type
~archive~MIME型:#archive-mime-type
~XML~MIME型:#xml-mime-type
~HTML~MIME型:#html-mime-type
~script可能~MIME型:#scriptable-mime-type
~JS~MIME型:#javascript-mime-type
~JS~MIME型に~essence合致-:#javascript-mime-type-essence-match
~JSON~MIME型:#json-mime-type

給された~MIME型:#supplied-mime-type
~binary~data~byte:#binary-data-byte
算出される~MIME型:#computed-mime-type
妥当な~MIME型~文字列:#valid-mime-type
~parameterを伴わない妥当な~MIME型~文字列:#valid-mime-type-with-no-parameters

~byte列から~MIME型を構文解析する:#parse-a-mime-type-from-bytes
~MIME型を~byte列に直列化する:#serialize-a-mime-type-to-bytes
~supportされる~MIME型を最小~化する:#minimize-a-supported-mime-type

~MIME型を直列化する:#serialize-a-mime-type
~MIME型を~sniffする~algo:#mime-type-sniffing-algorithm
文脈に特有な~sniffする~algo:#context-specific-sniffing-algorithm
画像を特定的に~sniffするための規則:#rules-for-sniffing-images-specifically
音声や動画を特定的に~sniffするための規則:#rules-for-sniffing-audio-and-video-specifically
~fontを特定的に~sniffするための規則:#rules-for-sniffing-fonts-specifically
~plugin文脈~内で~sniffするための規則:#rules-for-sniffing-in-a-plugin-context
~style文脈~内で~sniffするための規則:#rules-for-sniffing-in-a-style-context
~script文脈~内で~sniffするための規則:#rules-for-sniffing-in-a-script-context

~mp3~frameを構文解析する:#parse-an-mp3-frame
~MIME型を構文解析する:#parse-a-mime-type
可変長整数を構文解析する:#parse-a-vint

~pattern~mask:#pattern-mask
~byte~pattern:#byte-pattern

~pattern照合~algo:#pattern-matching-algorithm
~archive型~pattern照合~algo:#archive-type-pattern-matching-algorithm
音声動画~型~pattern照合~algo:#audio-or-video-type-pattern-matching-algorithm
~font型~pattern照合~algo:#font-type-pattern-matching-algorithm
画像~型~pattern照合~algo:#image-type-pattern-matching-algorithm
~mp3~headerに合致する:#match-an-mp3-header
~ID3なしの~MP3用の符丁に合致する:#matches-the-signature-for-mp3-without-id3
~MP4用の符丁に合致する:#matches-the-signature-for-mp4
~WebM用の符丁に合致する:#matches-the-signature-for-webm
~matching~a~padded連列:#matching-a-padded-sequence

~Apache~bugを検査するか:#check-for-apache-bug-flag
文脈:#context
~essence:#mime-type-essence
~mp3~frame~sizeを算出する:#compute-an-mp3-frame-size
~sniffなしか:#no-sniff-flag
~parameter群:#parameters

資源:#resource
資源~headerを読取る:#read-the-resource-header
資源~header:#resource-header

資源は~textか~binaryかを判別する規則:#rules-for-text-or-binary
未知な~MIME型を識別する規則:#rules-for-identifying-an-unknown-mime-type
V.~script可否を~sniffするか:#sniff-scriptable-flag
下位型:#subtype
給された~MIME型を検出する~algo:#supplied-mime-type-detection-algorithm
~UAにより~supportされて:#supported-by-the-user-agent
~tag-terminating~byte:#tag-terminating-byte
型:#type
	＊`type:#type
空白~byte:#whitespace-byte

	~RFCx/rfc7230, ~RFCx/rfc7231 → ~HTTPinfra, ~HTTPsem
P.token:~HTTPinfra#p.token
P.quoted-string:~HTTPinfra#p.quoted-string
P.media-type:~HTTPsem#p.media-type
P.parameters:~HTTPinfra#p.parameters

	~bug:https://issues.apache.org/bugzilla/show_bug.cgi?id=13986
	w3c/preload~#113:https://github.com/w3c/preload/issues/113

部分~byte列:#_subbytes
+〜:#_subbytes

~EACH:~INFRA#map-iterate
~BREAK:~INFRA#iteration-break
~IN:~INFRA#list-contain
~CONTINUE:~INFRA#iteration-continue

~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII文字列:~INFRA#ascii-string
~ASCII空白:~INFRA#ascii-whitespace
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
~ASCII大小無視:~INFRA#ascii-case-insensitive

~byte:~INFRA#byte
byte.長さ:~INFRA#byte-sequence-length
~byte列:~INFRA#byte-sequence

文字列:~INFRA#string
符号位置:~INFRA#code-point
同型に復号する:~INFRA#isomorphic-decode
同型に符号化する:~INFRA#isomorphic-encode
位置~変数:~INFRA#string-position-variable
集合:~INFRA#ordered-set

map.~key:~INFRA#map-key
map.値:~INFRA#map-value
有順序~map:~INFRA#ordered-map
	~EQ ε:~INFRA#map-exists
	~SET:~INFRA#map-set

~fetch:~FETCH#concept-fetch
~HTTP空白:~FETCH#http-whitespace
~HTTP引用符付き文字列を収集する:~FETCH#collect-an-http-quoted-string

内容:~HTTPinfra#message-content

_acks1:#_acks1
_ipr1:#_ipr1

●●words_table1

tagT:<abbr>TT</abbr>

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 

Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>


●●words_table

	●signature
	AIFF
	Web Open Font Format
	GIF
	GZIP archive
	AVI:
	Windows Icon
	Windows Cursor
	JPEG Start of Image
	MIDI
	ID3v2-tagged MP3
	Ogg container
	PDF
	PNG
	RAR archive
	PostScript
	OpenType
	Embedded OpenType
	TrueType
	TrueType Collection
	WAVE
	ZIP archive


	●MIME
template::::テンプレート
essence:
ZIP:
ID3:
MP3:
MP4:
WebM:
manifest::::マニフェスト
Apache:
FTP:
mp2:
mp3:
archive::::アーカイブ
text-track:text track:::テキストトラック
	~script可能:scriptable
	scripting
符丁:signature::~
音声動画:audio or video::音声／動画
拡張子:extension::~
下位型:subtype::~

	●sniff／構文解析
mask::::マスク
sniff:
sniffing:::sniff 処理
	~sniffなし:no-sniff
	~script可否を~sniffする:sniff-scriptable
BOM:
UTF-16BE:
UTF-16LE:
	TAB
	BEL
	BMP
	SPACE
	CR
	EOT
	ETX
	NUL
	LF
	SUB
	BS
	VT
	SO
	FS
	US
	~header:header field
rate::::レート
sample::::サンプル
tag-terminating::tag 終了::タグ終了
給-:supply:~
誤label:mislabel:::誤ラベル
	照合-用の:matched against
	-:parsed
引用符付き:quoted::~
番号:number:~

	空でない:non-empty
	~byte列:sequence
連結:concatenation:~
同型:isomorphic::~
	を飛ばす:skips past
読飛ばす:skipする:読み飛ばす
書込n:write::書き込み
	書込n法:writing
	読取n法:reading
	どこかで失敗-:have not been entirely successful
可変長整数:vint:~
	= Variable size Integer
	~Apache~bug用~検査:check-for-apache-bug

	●保安
XSS:cross-site scripting:XSS
認証:authentication:~
特権:privilege::~
	特権を有する:privileged
低特権:low-privilege::~
特権拡大:privilege escalation::~
厳しく:severeに:~
善意的:benign:~
正直:honest:~
盗んで:stealして:~
仕掛ける:mountする:~

	抑える:as little 〜 as

	●仕様
Web::::~

有意度:significance:~
適度:reasonable:~
必要不可欠:critical:~
計測情報:metrics:~
理想的:ideal:~
opt-out:opt out
	任意選択で外す
供与-:contribute:~
強いら:forceさ:~
決定的:deterministic:~
略称-:abbreviate:~
免除-:exempt:~
分岐-:diverge:~
分岐:divergents:~
想定-:suppose:~
事実調査:research:~
主導-:conduct:~

	無論:of course
	課され:impose され
	普及している:popular な
	にもなり得る:potentially
	必然的に:inevitably
	多方面:extensive
	そのほか:miscellaneous
	-:special
	-:incarnations
	備わる:present
	認識できない:unrecognized
	依拠できない:unreliable
	~error検査-用:error-checking
	称され:referred
	~~追認-:tolerate
	端を発し:originated from
	保ち続け:keep track
	-:installation
	価する:worth

	●未分類
経過-:elapse:~
無符号:unsigned:~
row:行
database::::データベース
big-endian:
payload::::ペイロード

低速:slow:~
	一定範囲の:certain subset of
厳密比較で:strictに:~
	strictly
量:amount:~

	内容:contain
	天秤にかける:balance
	満たされ:met
	変わる:varies:
	かもしれない:might
	属する:belong
	^en:reverse-engineer

	そのような:these
	その種の:such
	そこに:therein
	以前:previous
	終端-:end
	頭部:leading
	尾部を成す:trailing
	最大:max
	〜間:among
	最も:most
	古い:older
	大方の:majority
	に代えて:in place of
	一回:once
	相当数の:sizable number
	冒頭部:beginning

	次に与える／次の:the following
	を成す符号位置に〜でないものがある:does not solely contain
	を成すどの〜も〜である:solely contains 〜
	を成すどの〜も〜でない:contains no 〜
	〜場合の結果は、〜になる:end up
	なし:None

	●演算
	-:bitwise
	-:inverse
	-:mathematical
	-:operator
	-:equation
	+〜:starting
	~IN:exactly equal to one of
	~BREAK:exit
	~NEQ ε:is not past the end of input
	~WHILE:enter loop 〜
	~INCBY:advance／increment 〜 by
	~GTE:greater than or equal to
	~GTE:greater or equal than
	~LT:is less than
	~GT:greater than
	~MOD:modulo
	の`長さ$byte:the number of bytes in 

	●変数名
	%~parameter名:parameterName
	%~parameter値:parameterValue
	残り~byte数:bytes remaining
	%~MIME型:mimeType
	%~MIME型:supplied MIME type
	%~box~size:box-size
	%給された型:supplied-type
	%合致した画像~型:image-type-matched
	-:stringSerialization
	%読取った~byte数:bytes-read
	-:maskedData
	%合致した~font型:font-type-matched
	%合致した音声動画~型:audio-or-video-type-matched
	%合致した型:matched-type
	%合致した型:matchedType
	%~patternに合致したか:patternMatched

●●ref_key_map
KEYWORDS:RFC2119
HTTPSEMANTICS:RFC9110
MEDIAQUERIES:MEDIAQUERIES4

●●ref_normative

[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTTP-SEMANTICS]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. ＜HTTP Semantics＞. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9110.html
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[KEYWORDS]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[MIMETYPE]
    N. Freed; N. Borenstein. ＜Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types＞. November 1996. Draft Standard. URL: https://www.rfc-editor.org/rfc/rfc2046

●●ref_informative

[FTP]
    J. Postel; J. Reynolds. ＜File Transfer Protocol＞. October 1985. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc959
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[MEDIAQUERIES]
    Florian Rivoal; Tab Atkins Jr.. ＜Media Queries Level 4＞. URL: https://drafts.csswg.org/mediaqueries-4/
[RFC7303]
    H. Thompson; C. Lilley. ＜XML Media Types＞. July 2014. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7303
[RFC8081]
    C. Lilley. ＜The "font" Top-Level Media Type＞. February 2017. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8081
[SECCONTSNIFF]
    Adam Barth; Juan Caballero; Dawn Song. ＜Secure Content Sniffing for Web Browsers, or How to Stop Papers from Reviewing Themselves＞. May 2009. URL: https://www.adambarth.com/papers/2009/barth-caballero-song.pdf


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://mimesniff.spec.whatwg.org/">MIME Sniffing</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/mimesniff">GitHub whatwg/mimesniff</a> (<a href="https://github.com/whatwg/mimesniff/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/mimesniff/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	<a href="https://github.com/whatwg/mimesniff/commits">GitHub whatwg/mimesniff/commits</a>
	<a href="https://mimesniff.spec.whatwg.org/commit-snapshots/4b489c0978ed897ef6973d6562759e2bbe0465df/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/mimesniff">@mimesniff</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/mimesniff">web-platform-tests mimesniff/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/mimesniff">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）
	<a href="https://htmlspecs.com/mimesniff/" hreflang="zh-hans" lang="zh-hans" rel="alternate">简体中文</a>

</script>

</head>

<body>

<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0ibTE1LDV2OTBoNzB2LTc1bC0xNS0xNXoiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZT0iIzNjNzkwYSIgZmlsbD0iI2ZmZiIvPgo8cGF0aCBkPSJtMzgsMzhjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iIzNjNzkwYSIvPgo8L3N2Zz4K"
></a>
<!-- logo-mime.svg -->

	<hgroup>
<h1>MIME 型の sniff 法 — MIME Sniffing</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
MIME Sniffing 標準は、
資源の~sniff法を定義する。
【~sniffの原義は “（においを）嗅ぐ（嗅ぎ分ける）” 】
◎
The MIME Sniffing standard defines sniffing resources.
</p>
	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP `Content-Type$h ~headerは、
~HTTP応答の~MIME型を指示するために意図されている。
しかしながら，多くの~HTTP~serverは、
応答の実際の内容に合致しない値を
`Content-Type$h ~headerに給する。
歴史的に，~web~browserは、
そのような~serverを~~追認してきた
— 応答の実質的な~MIME型を決定するために，
`Content-Type$h ~headerに加えて, ~HTTP応答の内容を精査することにより。
◎
The HTTP Content-Type header field is intended to indicate the MIME type of an HTTP response. However, many HTTP servers supply a Content-Type header field value that does not match the actual contents of the response. Historically, web browsers have tolerated these servers by examining the content of HTTP responses in addition to the Content-Type header field in order to determine the effective MIME type of the response.
</p>

<p>
~MIME型をどう “~sniffする” かを与える明瞭な仕様がなければ、
各~UAは，［
相互運用能を保守するために，他の~UAの~algoから逆算する（ `reverse-engineer^en する）
］ことを強いられる。
必然的に、
これらの労はどこかで失敗し，~UA間の挙動が分岐する。
一部の事例では、
このような挙動の分岐には ~security上の含意がある
— ~UAは、
~HTTP応答の~MIME型を~serverが意図したものとは異なるものと解釈し得るので。
◎
Without a clear specification for how to "sniff" the MIME type, each user agent has been forced to reverse-engineer the algorithms of other user agents in order to maintain interoperability. Inevitably, these efforts have not been entirely successful, resulting in divergent behaviors among user agents. In some cases, these divergent behaviors have had security implications, as a user agent could interpret an HTTP response as a different MIME type than the server intended.
</p>

<p>
これらの~security上の課題は、［
“正直” な~serverが、［
悪意的にもなり得る利用者が，自前の~fileを~uploadする
］のを許容していて，そのような~fileの内容を 低特権な~MIME型として~serveする
］ときに最も厳しくなる。
例えば、
~serverは［
~clientは、
供与された~fileを画像として扱うことになる
（したがって，それを善意的として扱う）
］ものと予見している一方で，~UAは［
その内容を~HTMLである
（したがって，~scriptを実行する特権を有する）
］ものと予見している場合、
攻撃者は，［
利用者の認証~資格証を盗んで，他の~XSS攻撃を仕掛ける
］ことも可能になり得る。
（無論、
悪意的な~serverは，
`Content-Type$h ~headerに任意な~MIME型を指定できる。）
◎
These security issues are most severe when an "honest" server allows potentially malicious users to upload their own files and then serves the contents of those files with a low-privilege MIME type. For example, if a server believes that the client will treat a contributed file as an image (and thus treat it as benign), but a user agent believes the content to be HTML (and thus privileged to execute any scripts contained therein), an attacker might be able to steal the user’s authentication credentials and mount other cross-site scripting attacks. (Malicious servers, of course, can specify an arbitrary MIME type in the Content-Type header field.)
</p>

<p>
この文書は、
内容を~sniffする~algoを述べる
— それは、［
~UAの互換性の必要性
］と［
既存の~web内容により課される~security拘束
］とを，注意深く天秤にかける。
この~algoは、［
`Adam Barth^en, `juan Caballero^en, `Dawn Song^en
］各氏により主導された事実調査に端を発し，［
普及している~UAに備わる，内容を~sniffする~algo ／
既存の~web内容の多方面にわたる~database ／
相当数の利用者~向けに配備された実装から収集された計測情報
］に基づく。
`SECCONTSNIFF$r
◎
This document describes a content sniffing algorithm that carefully balances the compatibility needs of user agent with the security constraints imposed by existing web content. The algorithm originated from research conducted by Adam Barth, Juan Caballero, and Dawn Song, based on content sniffing algorithms present in popular user agents, an extensive database of existing web content, and metrics collected from implementations deployed to a sizable number of users. [SECCONTSNIFF]
</p>

	</section>
	<section id="conformance-requirements">
<h2 title="Conformance requirements">2. 適合性~要件</h2>

<p class="trans-note">【
この節の内容は省略する。
`INFRA$r <a href="~INFRA#conformance">§ 適合性</a>
を見よ。
】</p>


	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は、
Infra Standard に依存する。
`INFRA$r
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
次に挙げる`符号位置$は、
`~HTTP~token符号位置@
とされる
⇒＃
`0021^U,
`0023^U,
`0024^U,
`0025^U,
`0026^U,
`0027^U,
`002A^U,
`002B^U,
`002D^U,
`002E^U,
`005E^U,
`005F^U,
`0060^U,
`007C^U,
`007E^U,
`~ASCII英数字$
◎
An HTTP token code point is U+0021 (!), U+0023 (#), U+0024 ($), U+0025 (%), U+0026 (&amp;), U+0027 ('), U+002A (*), U+002B (+), U+002D (-), U+002E (.), U+005E (^), U+005F (_), U+0060 (`), U+007C (|), U+007E (~), or an ASCII alphanumeric.
</p>

<p class="note">注記：
これは
`quoted-string$P ~token生成規則が成す値~空間に合致する。
`HTTP-SEMANTICS$r
◎
This matches the value space of the token token production. [HTTP-SEMANTICS]
</p>

<p>
次に挙げる`符号位置$は、
`~HTTP引用符付き文字列~token符号位置@
とされる
⇒＃
`0009^U0 TAB,
`0020^U0 SPACE 〜 `007E^U,
`0080^U0 〜 `00FF^U
◎
An HTTP quoted-string token code point is U+0009 TAB, a code point in the range U+0020 SPACE to U+007E (~), inclusive, or a code point in the range U+0080 through U+00FF (ÿ), inclusive.
</p>

<p class="note">注記：
これは
`quoted-string$P ~token生成規則が成す
実質的な値~空間に合致する。
定義により、
それは
`~HTTP~token符号位置$の上位集合になる。
`HTTP-SEMANTICS$r
◎
This matches the effective value space of the quoted-string token production. By definition it is a superset of the HTTP token code points. [HTTP-SEMANTICS] 
</p>

<p>
次に挙げる`~byte$は、
`~binary~data~byte@
とされる
⇒
範囲 { `00^X 〜 `1F^X } に入る`~byte$のうち，［
`空白~byte$,
`1B^X (ESCAPE)
］以外のもの
【！ 0x00 〜 0x08 (NUL 〜 BS), 0x0B (VT), 0x0E 〜 0x1A (SO 〜 SUB), 0x1C 〜 0x1F ( FS 〜 US) 】
◎
A binary data byte is a byte in the range 0x00 to 0x08 (NUL to BS), the byte 0x0B (VT), a byte in the range 0x0E to 0x1A (SO to SUB), or a byte in the range 0x1C to 0x1F (FS to US).
</p>

<p>
次に挙げる`~byte$は、
`空白~byte@
とされる
【！ （ <abbr>0xWS</abbr> とも略称される）＊未利用 】
⇒＃
`09^X (HT),
`0A^X (LF),
`0C^X (FF),
`0D^X (CR),
`20^X (SP)
◎
A whitespace byte (abbreviated 0xWS) is any one of the following bytes: 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP).
</p>

<p>
次に挙げる`~byte$は、
`~tag-terminating~byte@
とされる
— これらは `~tagT^X とも略称される
⇒＃
`20^X (SP),
`&gt;^lX
◎
A tag-terminating byte (abbreviated 0xTT) is any one of the following bytes: 0x20 (SP), 0x3E ("&gt;").
</p>

<p>
各種 算術~演算に利用される記号（~bAND, ~Rshift, ~MOD, 等々）は
`ENCODING$r にて定義されるそれらと同様とする
【<a href="~ENCODING#terminology">参照</a>】
。
【！ bitwise NOT は減算で代用 】
◎
Equations are using the mathematical operators as defined in [ENCODING]. In addition, the bitwise NOT is represented by ~.
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
16進~byte列は、
先頭に "0x" を付与して表記される
— 例えば： `00 01 02^X 
（後続する各~byteに対しては、
"0x" は省略される）。
</p>

<div class="algo">
<p>
%~byte列[ %m `+〜@ %個数 ]
と記された所では、
所与の
( `~byte列$ %~byte列, 負でない整数 %m, 負でない整数 %個数 )
に対し，次に従って得られる %~byte列 の部分~byte列を返す：
</p>

<ol>
	<li>
~IF［
%m ~GTE %~byte列 の`長さ$byte
］
⇒
~RET 空~byte列
</li>
	<li>
~RET %~byte列 を成す，［
0 から数えて %m 番の~byte
］から %個数  個まで（ %個数 に満たない場合は %~byte列 の末尾まで）の~byteが成す，同順の`~byte列$
</li>
</ol>
</div>

<div class="example">
<p>
例えば［
%~byte列 ~EQ `abc^bl
］ならば
⇒＃
%~byte列[ 1 `+〜$ 1 ] は `b^bl になる ／
%~byte列[ 1 `+〜$ 2 ] は `bc^bl になる ／
%~byte列[ 1 `+〜$ 4 ] も `bc^bl になる ／
%~byte列[ 1 `+〜$ 0 ] は 空~byte列になる
</p>
</div>

<p>
%~byte列[ %m ]
と記された所では、
所与の
( `~byte列$ %~byte列, 整数 %m )
に対し，［
0 ~LTE %m ~LT %~byte列 の`長さ$byteならば %~byte列[ %m `+〜$ 1 ] ／
~ELSE_ ε
］を返す。
</p>

		</section>
	</section>
	<section id="understanding-mime-types">
<h2 title="MIME types">4. ~MIME型</h2>

		<section id="mime-type-representation">
<h3 title="MIME type representation">4.1. ~MIME型の表現</h3>

<p>
`~MIME型@
は、
`MIMETYPE$r に定義される `internet media type^en を表現する。
それは、
`~MIME型~record$と称されることもある。
◎
A MIME type represents an internet media type as defined by Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. It can also be referred to as a MIME type record. [MIMETYPE]
</p>

<p class="note">注記：
`MEDIAQUERIES$r にて述べられる 媒体~型（ `media type^i ）との混同を避けるため、
標準には，用語`~MIME型$を一貫して利用することが奨励される。
◎
Standards are encouraged to consistently use the term MIME type to avoid confusion with the use of media type as described in Media Queries. [MEDIAQUERIES]
</p>

<p>
各 `~MIME型$は、
次に挙げるものからなる：
</p>
<ul>
	<li>
`型@
⇒
空でない`~ASCII文字列$。
◎
A MIME type’s type is a non-empty ASCII string.
</li>
	<li>
`下位型@
⇒
空でない`~ASCII文字列$。
◎
A MIME type’s subtype is a non-empty ASCII string.
</li>
	<li>
<p>
`~parameter群@
⇒
`有順序~map$
— 初期~時は空とする。
</p>

<p>
各~entryの：
</p>
		<ul>
			<li>
`~key$mapは、
`~ASCII文字列$を与える。
</li>
			<li>
`値$mapは、
`~HTTP引用符付き文字列~token符号位置$に制限される`文字列$を与える。
</li>
		</ul>
◎
A MIME type’s parameters is an ordered map whose keys are ASCII strings and values are strings limited to HTTP quoted-string token code points. It is initially empty.
</li>
</ul>

		</section>
		<section id="mime-type-miscellaneous">
<h3 title="MIME type miscellaneous">4.2. ~MIME型そのほか</h3>

<div class="algo">
<p>
`~MIME型$ %~MIME型 の
`~essence@
は、
次の連結を返す
⇒＃
%~MIME型 の`型$,
`002F^U,
%~MIME型 の`下位型$
◎
The essence of a MIME type mimeType is mimeType’s type, followed by U+002F (/), followed by mimeType’s subtype.
</p>
</div>

<p>
`~MIME型$
は、
次が満たされるならば
`~UAにより~supportされて@
いるとされる
⇒
~UAは［
その`~MIME型$の`資源$を解釈して，それを利用者に呈示する
］能力を備える。
◎
A MIME type is supported by the user agent if the user agent has the capability to interpret a resource of that MIME type and present it to the user.
</p>

<p class="XXX">
理想的には、
これは，もっと精確にする必要がある。
<a href="https://github.com/w3c/preload/issues/113">w3c/preload #113</a>
を見よ。
◎
Ideally this would be more precise. See w3c/preload #113.
</p>

<div class="algo">
<p>
`~supportされる~MIME型を最小~化する@
~algoは、
所与の
( `~MIME型$ %~MIME型 )
に対し，`~ASCII文字列$を返す：
◎
To minimize a supported MIME type given a MIME type mimeType, run these steps. They return an ASCII string.
</p>
<ol>
	<li>
~IF［
%~MIME型 は`~JS~MIME型$である
］
⇒
~RET `text/javascript^l
◎
If mimeType is a JavaScript MIME type, then return "text/javascript".
</li>
	<li>
~IF［
%~MIME型 は`~JSON~MIME型$である
］
⇒
~RET `application/json^l
◎
If mimeType is a JSON MIME type, then return "application/json".
</li>
	<li>
<p>
~IF［
%~MIME型 の`~essence$ ~EQ `image/svg+xml^l
］
⇒
~RET `image/svg+xml^l
◎
If mimeType’s essence is "image/svg+xml", then return "image/svg+xml".
</p>

<p class="note">注記：
~SVGは、
他の`~XML~MIME型$と判別するに価する。
◎
SVG is worth distinguishing from other XML MIME types.
</p>
	</li>
	<li>
~IF［
%~MIME型 は`~XML~MIME型$である
］
⇒
~RET `application/xml^l
◎
If mimeType is an XML MIME type, then return "application/xml".
</li>
	<li>
~IF［
%~MIME型 は`~UAにより~supportされて$いる
］
⇒
~RET %~MIME型 の`~essence$
◎
If mimeType is supported by the user agent, then return mimeType’s essence.
</li>
	<li>
~RET 空~文字列
◎
Return the empty string.
</li>
</ol>

<p class="note">注記：
この~algoの目標は、［
異なる処理~model
— GIF や PNG 用のそれなど —
を伴う~MIME型どうし
］を~call元が判別することを許容する一方で，［
それ以外に供する情報は，アリな限り抑える
］ことにある。
◎
The goal of this algorithm is to allow the caller to distinguish MIME types with different processing models, such as those for GIF and PNG, but otherwise provide as little information as possible.
</p>
</div>

		</section>
		<section id="mime-type-writing">
<h3 title="MIME type writing">4.3. ~MIME型の書込n法</h3>

<p>
`妥当な~MIME型~文字列@
は、
`media-type$P ~token生成規則に合致する文字列である。
特に，`妥当な~MIME型~文字列$は、
`~parameter群$ 【 `parameters$P 】を含んでもヨイ／含み得る。
`HTTP-SEMANTICS$r
◎
A valid MIME type string is a string that matches the media-type token production. In particular, a valid MIME type string may include parameters. [HTTP-SEMANTICS]
</p>

<p class="note">注記：
`妥当な~MIME型~文字列$を利用するのは、
適合性~検査器に限られるものと想定されている。
◎
A valid MIME type string is supposed to be used for conformance checkers only.
</p>

<div class="example">
<p>
`text/html^l は`妥当な~MIME型~文字列$である。
◎
"text/html" is a valid MIME type string.
</p>

<p>
`text/html;^l は`妥当な~MIME型~文字列$でない
— それに`~MIME型を構文解析する$を適用した結果の`~MIME型~record$は、
`text/html^l に適用した結果と一致するが。
◎
"text/html;" is not a valid MIME type string, though parse a MIME type returns a MIME type record for it identical to if the input had been "text/html".
</p>
</div>

<p>
`~parameterを伴わない妥当な~MIME型~文字列@
は、
`003B^U を包含しない
`妥当な~MIME型~文字列$である。
◎
A valid MIME type string with no parameters is a valid MIME type string that does not contain U+003B (;).
</p>

		</section>
		<section id="parsing-a-mime-type">
<h3 title="Parsing a MIME type">4.4. ~MIME型の構文解析-法</h3>

<div class="algo">
<p>
`~MIME型を構文解析する@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
To parse a MIME type, given a string input, run these steps:
</p>

<ol>
	<li>
%入力 から頭部, 尾部を成す`~HTTP空白$並びを除去する
◎
Remove any leading and trailing HTTP whitespace from input.
</li>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%型 ~LET 
%入力 内の %位置 から `002F^U 以外の`符号位置~並びを収集する$
◎
Let type be the result of collecting a sequence of code points that are not U+002F (/) from input, given position.
</li>
	<li>
~IF［
%型 ~EQ 空~文字列
］~OR［
%型 を成す符号位置に`~HTTP~token符号位置$でないものがある
］
⇒
~RET `失敗^i
◎
If type is the empty string or does not solely contain HTTP token code points, then return failure.
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET `失敗^i
◎
If position is past the end of input, then return failure.
</li>
	<li>
%位置 ~INCBY 1
（これは `002F^U を飛ばす。）
◎
Advance position by 1. (This skips past U+002F (/).)
</li>
	<li>
%下位型 ~LET
%入力 内の %位置 から`003B^U 以外の`符号位置~並びを収集する$
◎
Let subtype be the result of collecting a sequence of code points that are not U+003B (;) from input, given position.
</li>
	<li>
%下位型 から尾部を成す`~HTTP空白$並びを除去する
◎
Remove any trailing HTTP whitespace from subtype.
</li>
	<li>
~IF［
%下位型 ~EQ 空~文字列
］~OR［
%下位型 を成す符号位置に`~HTTP~token符号位置$でないものがある
］
⇒
~RET `失敗^i
◎
If subtype is the empty string or does not solely contain HTTP token code points, then return failure.
</li>
	<li>
%~MIME型 ~LET 新たな`~MIME型~record$
— その
⇒＃
`型$ ~SET `~ASCII小文字~化する$( %型 ),
`下位型$ ~SET `~ASCII小文字~化する$( %下位型 )
◎
Let mimeType be a new MIME type record whose type is type, in ASCII lowercase, and subtype is subtype, in ASCII lowercase.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%位置 ~INCBY 1
（これは `003B^U を飛ばす。）
◎
Advance position by 1. (This skips past U+003B (;).)
</li>
			<li>
<p>
%入力 内の %位置 から`~HTTP空白$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are HTTP whitespace from input given position.
</p>

<p class="note">注記：
これは、
`~ASCII空白$に代えて`~HTTP空白$が利用されることを除いて，`~ASCII空白を読飛ばす$のと概ね等価になる。
◎
This is roughly equivalent to skip ASCII whitespace, except that HTTP whitespace is used rather than ASCII whitespace.
</p>
			</li>
			<li>
%~parameter名 ~LET 
%入力 内の %位置 から
{ `003B^U, `003D^U }
以外の`符号位置~並びを収集する$
◎
Let parameterName be the result of collecting a sequence of code points that are not U+003B (;) or U+003D (=) from input, given position.
</li>
			<li>
%~parameter名 ~SET `~ASCII小文字~化する$( %~parameter名 )
◎
Set parameterName to parameterName, in ASCII lowercase.
◎
If position is not past the end of input, then:
</li>
			<li>
~IF［
%位置↗ ~EQ `003B^U
］
⇒
~CONTINUE
◎
If the code point at position within input is U+003B (;), then continue.
</li>
			<li>
%位置 ~INCBY 1
（これは `003D^U を飛ばす。）
◎
Advance position by 1. (This skips past U+003D (=).)
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~BREAK
◎
If position is past the end of input, then break.
</li>
			<li>
%~parameter値 ~LET ~NULL
◎
Let parameterValue be null.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `0022^U
］：
◎
If the code point at position within input is U+0022 ("), then:
</p>
				<ol>
					<li>
%~parameter値 ~SET `~HTTP引用符付き文字列を収集する$( %入力, %位置, `値を抽出する^i )
◎
Set parameterValue to the result of collecting an HTTP quoted string from input, given position and true.
</li>
					<li>
<p>
%入力 内の %位置 から
`003B^U 以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not U+003B (;) from input, given position.
</p>

<p class="example">
`text/html;charset="shift_jis"iso-2022-jp^mt
が与えられた場合の結果は、
`text/html;charset=shift_jis^mt
になる。
◎
Given text/html;charset="shift_jis"iso-2022-jp you end up with text/html;charset=shift_jis.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~parameter値 ~SET 
%入力 内の %位置 から `003B^U 以外の`符号位置~並びを収集する$
◎
Set parameterValue to the result of collecting a sequence of code points that are not U+003B (;) from input, given position.
</li>
					<li>
%~parameter値 から尾部を成す`~HTTP空白$並びを除去する
◎
Remove any trailing HTTP whitespace from parameterValue.
</li>
					<li>
~IF［
%~parameter値 ~EQ 空~文字列
］
⇒
~CONTINUE
◎
If parameterValue is the empty string, then continue.
</li>

				</ol>
			</li>
			<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true
</p>
				<ul class="brief">
					<li>
%~parameter名 ~NEQ 空~文字列
◎
parameterName is not the empty string
</li>
					<li>
%~parameter名 を成すどの符号位置も`~HTTP~token符号位置$である
◎
parameterName solely contains HTTP token code points
</li>
					<li>
%~parameter値 を成すどの符号位置も`~HTTP引用符付き文字列~token符号位置$である
◎
parameterValue solely contains HTTP quoted-string token code points
</li>
					<li>
%~MIME型 の`~parameter群$[ %~parameter名 ] ~EQ  ε
◎
mimeType’s parameters[parameterName] does not exist
</li>
				</ul>
<p>
…ならば
⇒
%~MIME型 の`~parameter群$[ %~parameter名 ] ~SET %~parameter値
◎
then set mimeType’s parameters[parameterName] to parameterValue.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %~MIME型
◎
Return mimeType.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~byte列から~MIME型を構文解析する@
~algoは、
所与の
( `~byte列$ %入力 )
に対し：
◎
To parse a MIME type from bytes, given a byte sequence input, run these steps:
</p>

<ol>
	<li>
%文字列 ~LET `同型に復号する$( %入力 )
◎
Let string be input, isomorphic decoded.
</li>
	<li>
~RET `~MIME型を構文解析する$( %文字列 )
◎
Return the result of parse a MIME type with string.
</li>
</ol>
</div>

		</section>
		<section id="serializing-a-mime-type">
<h3 title="Serializing a MIME type">4.5. ~MIME型の直列化-法</h3>

<div class="algo">
<p>
`~MIME型を直列化する@
~algoは、
所与の
( `~MIME型$ %~MIME型 )
に対し：
◎
To serialize a MIME type, given a MIME type mimeType, run these steps:
</p>

<ol>
	<li>
%直列化 ~LET 空~文字列
◎
↓</li>
	<li>
%直列化 に次を順に付加する
⇒＃
%~MIME型 の`型$,
`002F^U,
%~MIME型 の`下位型$
◎
Let serialization be the concatenation of mimeType’s type, U+002F (/), and mimeType’s subtype.
</li>
	<li>
<p>
%~MIME型 の`~parameter群$を成す
~EACH( %名 → %値 )
に対し：
◎
For each name → value of mimeType’s parameters:
</p>
		<ol>
			<li>
%直列化 に次を順に付加する
⇒＃
`003B^U,
%名,
`003D^U
◎
Append U+003B (;) to serialization.
◎
Append name to serialization.
◎
Append U+003D (=) to serialization.
</li>
			<li>
<p>
~IF［
%値 を成す符号位置に`~HTTP~token符号位置$でないものがある
］~OR［
%値 ~EQ 空~文字列
］：
</p>
				<ol>
					<li>
%直列化 に `0022^U を付加する
</li>
					<li>
<p>
%値 を成す
~EACH( 符号位置 %C )
に対し，順に：
</p>
						<ol>
							<li>
~IF［
%C ~IN { `0022^U, `005C^U }
］
⇒
%直列化 に `005C^U を付加する
</li>
							<li>
%直列化 に %C を付加する
</li>
						</ol>
					</li>
					<li>
%直列化 に `0022^U を付加する
</li>
				</ol>
◎
If value does not solely contain HTTP token code points or value is the empty string, then: 
• Precede each occurrence of U+0022 (") or U+005C (\) in value with U+005C (\).
• Prepend U+0022 (") to value.
• Append U+0022 (") to value.
</li>
			<li>
~ELSE
⇒
%直列化 に %値 を付加する
◎
Append value to serialization.
</li>
		</ol>
	</li>
	<li>
~RET %直列化
◎
Return serialization.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~MIME型を~byte列に直列化する@
~algoは、
所与の
( `~MIME型$ %~MIME型 )
に対し
⇒
~RET `同型に符号化する$( `~MIME型を直列化する$( %~MIME型 ) )
◎
To serialize a MIME type to bytes, given a MIME type mimeType, run these steps:
• Let stringSerialization be the result of serialize a MIME type with mimeType.
• Return stringSerialization, isomorphic encoded.
</p>
</div>

		</section>
		<section id="mime-type-groups">
<h3 title="MIME type groups">4.6. ~MIME型の~group分け</h3>

<p>
次を満たす`~MIME型$は、
`画像~MIME型@
とされる
⇒
`型$ ~EQ `image^l
◎
An image MIME type is a MIME type whose type is "image".
</p>

<p>
次を満たす`~MIME型$は、
`音声動画~MIME型@
とされる
⇒
［
`型$ ~IN { `audio^l, `video^l }
］~OR［
`~essence$ ~EQ `application/ogg^l
］
◎
An audio or video MIME type is any MIME type whose type is "audio" or "video", or whose essence is "application/ogg".
</p>

<p>
次を満たす`~MIME型$は、
`~font~MIME型@
とされる
⇒
［
`型$ ~EQ `font^l
］~OR［
`~essence$ ~IN { 次に挙げる文字列 } `RFC8081$r
］
◎
A font MIME type is any MIME type whose type is "font", or whose essence is one of the following: [RFC8081]
</p>

<ul><li>`application/font-cff^l
</li><li>`application/font-off^l
</li><li>`application/font-sfnt^l
</li><li>`application/font-ttf^l
</li><li>`application/font-woff^l
</li><li>`application/vnd.ms-fontobject^l
</li><li>`application/vnd.ms-opentype^l
</li></ul>

<p>
次を満たす`~MIME型$は、
`~ZIPに基づく~MIME型@
とされる
⇒
［
`下位型$は `+zip^l で終端する
］~OR［
`~essence$ ~IN { 次に挙げる文字列 }
］
◎
A ZIP-based MIME type is any MIME type whose subtype ends in "+zip" or whose essence is one of the following:
</p>

<ul class="XXX">
<li>`application/zip^l
</li></ul>

<p>
次を満たす`~MIME型$は、
`~archive~MIME型@
とされる
⇒
`~essence$ ~IN { 次に挙げる文字列 }
◎
An archive MIME type is any MIME type whose essence is one of the following:
</p>

<ul><li>`application/x-rar-compressed^l
</li><li>`application/zip^l
</li><li>`application/x-gzip^l
</li></ul>

<p>
次を満たす`~MIME型$は、
`~XML~MIME型@
とされる
⇒
［
`下位型$は `+xml^l で終端する
］~OR［
`~essence$ ~IN { `text/xml^l, `application/xml^l } `RFC7303$r
］
◎
An XML MIME type is any MIME type whose subtype ends in "+xml" or whose essence is "text/xml" or "application/xml". [RFC7303]
</p>

<p>
次を満たす`~MIME型$は、
`~HTML~MIME型@
とされる
⇒
`~essence$ ~EQ `text/html^l
◎
An HTML MIME type is any MIME type whose essence is "text/html".
</p>

<p>
次を満たす`~MIME型$は、
`~script可能~MIME型@
とされる
⇒
［
`~XML~MIME型$である
］~OR［
`~HTML~MIME型$である
］~OR［
`~essence$ ~EQ `application/pdf^l
］
◎
A scriptable MIME type is an XML MIME type, HTML MIME type, or any MIME type whose essence is "application/pdf".
</p>

<p>
次を満たす`~MIME型$は、
`~JS~MIME型@
とされる
⇒
`~essence$ ~IN { 次に挙げる文字列 }
◎
A JavaScript MIME type is any MIME type whose essence is one of the following:
</p>

<ul ><li>`application/ecmascript^l
</li><li>`application/javascript^l
</li><li>`application/x-ecmascript^l
</li><li>`application/x-javascript^l
</li><li>`text/ecmascript^l
</li><li>`text/javascript^l
</li><li>`text/javascript1.0^l
</li><li>`text/javascript1.1^l
</li><li>`text/javascript1.2^l
</li><li>`text/javascript1.3^l
</li><li>`text/javascript1.4^l
</li><li>`text/javascript1.5^l
</li><li>`text/jscript^l
</li><li>`text/livescript^l
</li><li>`text/x-ecmascript^l
</li><li>`text/x-javascript^l
</li></ul>

<p>
次を満たす`文字列$は
`~JS~MIME型に~essence合致-@
するとされる
⇒
上に挙げた`~JS~MIME型$用の~essence文字列のいずれかに`~ASCII大小無視$で合致する
◎
A string is a JavaScript MIME type essence match if it is an ASCII case-insensitive match for one of the JavaScript MIME type essence strings.
</p>

<p class="note">注記：
この~hookは、
`script$e 要素の `type$a 属性により利用される。
`HTML$r
◎
This hook is used by the type attribute of script elements. [HTML]
</p>

<p>
次を満たす`~MIME型$は、
`~JSON~MIME型@
とされる
⇒
［
`下位型$は `+json^l で終端する
］~OR［
`~essence$ ~IN { `application/json^l, `text/json^l }
］
◎
A JSON MIME type is any MIME type whose subtype ends in "+json" or whose essence is "application/json" or "text/json". 
</p>

		</section>
	</section>
	<section id="handling-a-resource">
<h2 title="Handling a resource">5. 資源の取扱い</h2>

<p class="XXX">
`資源@
とは…
【この仕様の文脈においては、概ね，~HTTP応答の`内容$と考えればよいであろう。】
◎
A resource is ….
</p>

<p>
~UAは，自身が取扱う各`資源$に対し、
次に挙げる~metadataを結付けた上で，保ち続けるモノトスル：
◎
For each resource it handles, the user agent must keep track of the following associated metadata:
</p>
<ul>
	<li>
`給された~MIME型@
⇒
ε ／`~MIME型$
— `給された~MIME型を検出する~algo$により決定される。
◎
A supplied MIME type, the MIME type determined by the supplied MIME type detection algorithm.
</li>
	<li>
`~Apache~bugを検査するか@
⇒
真偽値
— 既定では ~F とする。
◎
A check-for-apache-bug flag, which defaults to unset.
</li>
	<li>
<p>
`~sniffなしか@
⇒
真偽値
— ~UAが`資源$に対する~sniffingを遂行したいと望まない場合，
既定では ~T になり、
他の場合，~F になる。
◎
A no-sniff flag, which defaults to set if the user agent does not wish to perform sniffing on the resource and unset otherwise.
</p>

<p class="note">注記：
~UAは、［
特定0の`資源$に対し，~sniffingを~opt-outする【任意選択で外す】かどうか
］を決定する際に［
~siteにおける以前の経験など，外側の情報
］を利用することも選べる。
~UAは、
すべての`資源$に対し~sniffingを~opt-outすることも選べる。
しかしながら，~sniffingを~opt-outしても、
~UAは，`~MIME型を~sniffする~algo$を利用することから免除されるわけではない。

◎
The user agent can choose to use outside information, such as previous experience with a site, to determine whether to opt out of sniffing for a particular resource. The user agent can also choose to opt out of sniffing for all resources. However, opting out of sniffing does not exempt the user agent from using the MIME type sniffing algorithm.
</p>
	</li>
	<li>
`算出される~MIME型@
⇒
`~MIME型を~sniffする~algo$により決定される`~MIME型$。
◎
A computed MIME type, the MIME type determined by the MIME type sniffing algorithm.
</li>
</ul>

		<section id="interpreting-the-resource-metadata">
<h3 title="Interpreting the resource metadata">5.1. 資源~metadataの解釈-法</h3>

<p>
`資源$ %資源 に`給された~MIME型$は、
%資源 に結付けられた外部の~sourceから~UAに供される。
この情報を得する手法は、
%資源 がどう検索取得されたかに依存して変わる。
◎
The supplied MIME type of a resource is provided to the user agent by an external source associated with that resource. The method of obtaining this information varies depending upon how the resource is retrieved.
</p>

<p>
~UAは、
`給された~MIME型$を［
`給された~MIME型を検出する~algo$
］を利用して決定するモノトスル。
◎
↓</p>

<div class="algo">
<p>
`給された~MIME型を検出する~algo@
は、
所与の
( `資源$ %資源 )
に対し，［
`~MIME型$／ ε（未定義）
］を返す：
◎
To determine the supplied MIME type of a resource, user agents must use the following supplied MIME type detection algorithm:
</p>

<ol>
	<li>
%給された型 ~LET ε 【！ ＊~NULL 】
◎
Let supplied-type be null.
</li>
	<li>
<p>
~IF［
%資源 は~HTTPを介して検索取得された
］：
◎
If the resource is retrieved via HTTP, execute the following steps:
</p>
		<ol>
			<li>
<p>
~IF［
%資源 には 1 個~以上の `Content-Type$h ~headerが結付けられている
］：
◎
If one or more Content-Type headers are associated with the resource, execute the following steps:
</p>
				<ol>
					<li>
<p>
%給された型 ~SET  %資源 に結付けられた最後の `Content-Type$h ~headerの値
◎
Set supplied-type to the value of the last Content-Type header associated with the resource.
</p>

<p class="note">注記：
~file拡張子は、
~HTTPを介して検索取得された %資源 に`給された~MIME型$を決定するときには，利用されない
— 容易に偽装されるので、
それらには依拠できない。
◎
File extensions are not used to determine the supplied MIME type of a resource retrieved via HTTP because they are unreliable and easily spoofed.
</p>
					</li>
					<li>
<p>
~IF［
%給された型 ~IN { 次に挙げる値 }
］…
◎
Set the check-for-apache-bug flag if supplied-type is exactly equal to one of the values in the following table:
</p>

<div >
<ul ><li>`text/plain^lX
</li><li>`text/plain; charset=ISO-8859-1^lX
</li><li>`text/plain; charset=iso-8859-1^lX
</li><li>`text/plain; charset=UTF-8^lX
</li></ul>

<p>
…ならば
⇒
`~Apache~bugを検査するか$ ~SET ~T
</p>

◎
Bytes in Hexadecimal 	Bytes in ASCII
◎
74 65 78 74 2F 70 6C 61 69 6E 	text/plain
◎
74 65 78 74 2F 70 6C 61 69 6E
3B 20 63 68 61 72 73 65 74 3D
49 53 4F 2D 38 38 35 39 2D 31 	text/plain; charset=ISO-8859-1
◎
74 65 78 74 2F 70 6C 61 69 6E
3B 20 63 68 61 72 73 65 74 3D
69 73 6F 2D 38 38 35 39 2D 31 	text/plain; charset=iso-8859-1
◎
74 65 78 74 2F 70 6C 61 69 6E
3B 20 63 68 61 72 73 65 74 3D
55 54 46 2D 38 	text/plain; charset=UTF-8
</div>

<p class="note">注記：
`給された~MIME型を検出する~algo$は、
これらに正確に一致する`~byte列$を検出する
— 一部の古い~Apacheには
<a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=13986">~bugがあり</a>、
`~MIME型$を認識できない~fileを~serveするときに、
これらいずれかの `Content-Type$h ~headerを給するので。
◎
The supplied MIME type detection algorithm detects these exact byte sequences because some older installations of Apache contain a bug that causes them to supply one of these Content-Type headers when serving files with unrecognized MIME types.
</p>
					</li>
				</ol>
			</li>
		</ol>

<p>
`HTTP-SEMANTICS$r
◎
[HTTP-SEMANTICS]
</p>
	</li>
	<li>
~IF［
%資源 は ~file~systemから直に検索取得された
］
⇒
%給された型 ~SET ~file~systemにより供される`~MIME型$
◎
If the resource is retrieved directly from the file system, set supplied-type to the MIME type provided by the file system.
</li>
	<li>
~IF［
%資源 は 別の~protocol（~FTP `FTP$r など）を介して検索取得された
］~AND［
その~protocolにより決定される`~MIME型$ %型 はある
］
⇒
%給された型 ~SET %型
◎
If the resource is retrieved via another protocol (such as FTP), set supplied-type to the MIME type as determined by that protocol, if any.
[FTP]
</li>
	<li>
~IF［
%給された型 は`~MIME型$でない
］
⇒
~RET ε （“未定義”）
◎
If supplied-type is not a MIME type, the supplied MIME type is undefined.
◎
Abort these steps.
</li>
	<li>
~RET %給された型
◎
The supplied MIME type is supplied-type.
</li>
</ol>
</div>

		</section>
		<section id="reading-the-resource-header">
<h3 title="Reading the resource header">5.2. 資源~headerの読取n法</h3>

<p>
`資源~header@
は、
`資源~headerを読取る$ことにより決定される，`資源$の冒頭部を成す`~byte列$である。
◎
A resource header is the byte sequence at the beginning of a resource, as determined by reading the resource header.
</p>

<div class="algo">
<p>
`資源~headerを読取る@
~algoは：
◎
To read the resource header, perform the following steps:
</p>
<ol>
	<li>
%~buffer ~LET 空`~byte列$
◎
Let buffer be a byte sequence.
</li>
	<li>
<p>
次のいずれかの条件が満たされるまで、
`資源$を成す`~byte列$を %~buffer の中に読取る：
◎
Read bytes of the resource into buffer until one of the following conditions is met:
</p>
		<ul>
			<li>
`資源$の終端まで達した
◎
the end of the resource is reached.
</li>
			<li>
%~buffer の`長さ$byte ~GTE 1445
◎
the number of bytes in buffer is greater than or equal to 1445.
</li>
			<li>
~UAにより決定される適度な量の時間が経過した
◎
a reasonable amount of time has elapsed, as determined by the user agent.
</li>
		</ul>
<p class="note">注記：
［
%~buffer の`長さ$byte ~GTE 1445
］の場合、
`~MIME型を~sniffする~algo$は，大方の事例において決定的になる。
しかしながら，ある種の要因（低速な接続など）により、
~UAは適度な量の時間~内に 1445 `~byte$を読取れないこともある。
◎
If the number of bytes in buffer is greater than or equal to 1445, the MIME type sniffing algorithm will be deterministic for the majority of cases.
◎
However, certain factors (such as a slow connection) may prevent the user agent from reading 1445 bytes in a reasonable amount of time.
</p>
	</li>
	<li>
~RET %~buffer
◎
The resource header is buffer.
</li>
</ol>

<p class="note">注記：
`資源~header$を決定する必要があるのは、
`資源$ごとに一回に限られる。
◎
The resource header need only be determined once per resource.
</p>
</div>

		</section>
	</section>
	<section id="matching-a-mime-type-pattern">
<h2 title="Matching a MIME type pattern">6. ~MIME型~patternとの照合-法</h2>

<p>
`~byte~pattern@
は、
`~byte列$であり，
`~pattern照合~algo$において［
照合-用の~template
］として利用される。
◎
A byte pattern is a byte sequence used as a template to be matched against in the pattern matching algorithm.
</p>

<p>
`~pattern~mask@
は、
`~byte列$であり，`~pattern照合~algo$において［
ある`~byte~pattern$と比較されている`~byte列$
］の有意度を決定するために利用される。
◎
A pattern mask is a byte sequence used to determine the significance of bytes being compared against a byte pattern in the pattern matching algorithm.
</p>

<p class="note">注記：
`~pattern~mask$における［
`FF^X は，`~byte$は厳密比較で有意である／
`DF^X は，`~byte$は~ASCII大小無視で有意である／
`00^X は，`~byte$は有意でない
］ことを指示する。
◎
In a pattern mask, 0xFF indicates the byte is strictly significant, 0xDF indicates that the byte is significant in an ASCII case-insensitive way, and 0x00 indicates that the byte is not significant.
</p>

<div class="algo">
<p>
次に与える
`~pattern照合~algo@
は、［
所与の`~byte列$が，特定0の`~byte~pattern$に合致するかどうか
］を決定するときに利用される
— それは、
所与の
⇒＃
`~byte列$ %入力,
`~byte~pattern$ %~pattern,
`~pattern~mask$ %~mask,
`~byte$の`集合$ %無視される集合
◎終
に対し，真偽値【！true or false】を返す：
◎
To determine whether a byte sequence matches a particular byte pattern, use the following pattern matching algorithm. It is given a byte sequence input, a byte pattern pattern, a pattern mask mask, and a set of bytes to be ignored ignored, and returns true or false.
</p>

<ol>
	<li>
%L ~LET %~pattern の`長さ$byte
◎
↓</li>
	<li>
~Assert：
%L ~EQ %~mask の`長さ$byte
◎
Assert: pattern’s length is equal to mask’s length.
◎
↓↓If input’s length is less than pattern’s length, return false.
</li>
	<li>
%s ~LET  0
◎
Let s be 0.
</li>
	<li>
<p>
~WHILE［
%s ~LT %入力 の`長さ$byte
］：
◎
While s &lt; input’s length:
</p>
		<ol>
			<li>
~IF［
%入力[ %s ] ~NIN %無視される
］
⇒
~BREAK
◎
If ignored does not contain input[s], break.
</li>
			<li>
%s ~INCBY 1
◎
Set s to s + 1.
</li>
		</ol>
	</li>
	<li>
%入力 ~SET %入力[ %s `+〜$ %L ]
◎
↓</li>
	<li>
<p>
~IF［
%入力 の`長さ$byte ~LT %L
］
⇒
~RET ~F
</p>
【原文は，この段に相当する検査を上の ~WHILE 段の前に行なっているが、明らかにおかしいので~algoを修正している。】
◎
↑↑</li>
	<li>
~RET ~IS［
どの整数 %p ~IN { 0 〜 %L ~MINUS 1 } に対しても，次が満たされる
］
⇒
( %入力[ %p ] ~bAND %~mask[ %p ] ) ~EQ %~pattern[ %p ]
◎
Let p be 0.
◎
While p &lt; pattern’s length:
• Let maskedData be the result of applying the bitwise AND operator to input[s] and mask[p].
• If maskedData is not equal to pattern[p], return false.
• Set s to s + 1.
• Set p to p + 1.
◎
Return true.
</li>
</ol>
</div>

		<section id="matching-an-image-type-pattern">
<h3 title="Matching an image type pattern">6.1. 画像~型~patternとの照合</h3>

<div class="algo">
<p>
次に与える
`画像~型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`画像~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which image MIME type byte pattern a byte sequence input matches, if any, use the following image type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表t内の
~EACH( ~row %~row )
に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致したか ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致したか ~EQ ~T
］
⇒
~RET %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>

<table class="grid-table patterns"><thead>
<tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`画像~MIME型$
<th class="note">注記
<tbody>

<tr><td>`00 00 01 00^X
<td>`FF FF FF FF^X
<td>なし
<td>`image/x-icon^mt
<td class="note">
`Windows Icon^i 符丁
◎
A Windows Icon signature.

<tr><td>`00 00 02 00^X
<td>`FF FF FF FF^X
<td>なし
<td>`image/x-icon^mt
<td class="note">
`Windows Cursor^i 符丁
◎
A Windows Cursor signature.

<tr><td>`42 4D^X
<td>`FF FF^X
<td>なし
<td>`image/bmp^mt
<td class="note">
`BMP^i 符丁を表す， `BM^l
◎
The string "BM", a BMP signature.

<tr><td>`47 49 46 38 37 61^X
<td>`FF FF FF FF FF FF^X
<td>なし
<td>`image/gif^mt
<td class="note">
`GIF^i 符丁を表す， `GIF87a^bl
◎
The string "GIF87a", a GIF signature.

<tr><td>`47 49 46 38 39 61^X
<td>`FF FF FF FF FF FF^X
<td>なし
<td>`image/gif^mt
<td class="note">
`GIF^i 符丁を表す， `GIF89a^bl
◎
The string "GIF89a", a GIF signature.

<tr><td>`52 49 46 46 00 00 00 00 57 45 42 50 56 50^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF FF FF^X
<td>なし
<td>`image/webp^mt
<td class="note">
次の連結
⇒＃
`RIFF^bl,
4 個の`~byte$,
`WEBPVP^bl
◎
The string "RIFF" followed by four bytes followed by the string "WEBPVP".

<tr><td>`89 50 4E 47 0D 0A 1A 0A^X
<td>`FF FF FF FF FF FF FF FF^X
<td>なし
<td>`image/png^mt
<td class="note">
`PNG^i 符丁を表す，次の連結
⇒＃
1 個の~error検査-用`~byte$,
`PNG^bl,
`CR^smb,
`LF^smb,
`SUB^smb,
`LF^smb
◎
An error-checking byte followed by the string "PNG" followed by CR LF SUB LF, the PNG signature.

<tr><td>`FF D8 FF^X
<td>`FF FF FF^X
<td>なし
<td>`image/jpeg^mt
<td class="note">
次の連結
⇒＃
`JPEG Start of Image^i ~marker,
別の~markerの指示子を成す 1 個の`~byte$
◎
The JPEG Start of Image marker followed by the indicator byte of another marker.
</table>
	</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>
</div>

		</section>
		<section id="matching-an-audio-or-video-type-pattern">
<h3 title="Matching an audio or video type pattern">6.2. 音声動画~型~patternとの照合</h3>

<div class="algo">
<p>
次に与える
`音声動画~型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`音声動画~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which audio or video MIME type byte pattern a byte sequence input matches, if any, use the following audio or video type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表t内の
~EACH( ~row %~row )
に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致したか ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致したか ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>

<table class="grid-table patterns"><thead>
<tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$
<th>`音声動画~MIME型$
<th class="note">注記
<tbody>

<tr><td>`46 4F 52 4D 00 00 00 00 41 49 46 46^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF^X
<td>なし
<td>`audio/aiff^mt
<td class="note">
`AIFF^i 符丁を表す，次の連結
⇒＃
`FORM^bl
4 個の`~byte$,
`AIFF^bl
◎
The string "FORM" followed by four bytes followed by the string "AIFF", the AIFF signature.

<tr><td>`49 44 33^X
<td>`FF FF FF^X
<td>なし
<td>`audio/mpeg^mt
<td class="note">
`ID3v2-tagged MP3^i 符丁を表す， `ID3^bl
◎
The string "ID3", the ID3v2-tagged MP3 signature.

<tr><td>`4F 67 67 53 00^X
<td>`FF FF FF FF FF^X
<td>なし
<td>`application/ogg^mt
<td class="note">
`Ogg container^i 符丁を表す，次の連結
⇒＃
`OggS^bl,
`NUL^smb
◎
The string "OggS" followed by NUL, the Ogg container signature.

<tr><td>`4D 54 68 64 00 00 00 06^X
<td>`FF FF FF FF FF FF FF FF^X
<td>なし
<td>`audio/midi^mt
<td class="note">
`MIDI^i 符丁を表す，次の連結
⇒＃
`MThd^bl,
32 ~bit（~big-endian）で数 6 を表現している 4 個の`~byte$
◎
The string "MThd" followed by four bytes representing the number 6 in 32 bits (big-endian), the MIDI signature.

<tr><td>`52 49 46 46 00 00 00 00 41 56 49 20^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF^X
<td>なし
<td>`video/avi^mt
<td class="note">
`AVI^i 符丁を表す，次の連結
⇒＃
`RIFF^bl,
4 個の`~byte$,
`AVI ^bl
◎
The string "RIFF" followed by four bytes followed by the string "AVI ", the AVI signature.

<tr><td>`52 49 46 46 00 00 00 00 57 41 56 45^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF^X
<td>なし
<td>`audio/wave^mt
<td class="note">
`WAVE^i 符丁を表す，次の連結
⇒＃
`RIFF^bl,
4 個の`~byte$,
`WAVE^bl
◎
The string "RIFF" followed by four bytes followed by the string "WAVE", the WAVE signature.
</table>

	</li>
	<li>
~IF［
%入力 は`~MP4用の符丁に合致する$
］
⇒
~RET  `video/mp4^l
◎
If input matches the signature for MP4, return "video/mp4".
</li>
	<li>
~IF［
%入力 は`~WebM用の符丁に合致する$
］
⇒
~RET  `video/webm^l
◎
If input matches the signature for WebM, return "video/webm".
</li>
	<li>
~IF［
%入力 は`~ID3なしの~MP3用の符丁に合致する$
］
⇒
~RET  `audio/mpeg^l
◎
If input matches the signature for MP3 without ID3, return "audio/mpeg".
</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>
</div>

			</section>
			<section id="signature-for-mp4">
<h4 title="Signature for MP4">6.2.1. ~MP4用の符丁</h4>

<div class="algo">
<p>
`~MP4用の符丁に合致する@
かどうか決定するときは、
所与の
( `~byte列$ %~byte列 )
に対し，次の手続きを利用する：
◎
To determine whether a byte sequence matches the signature for MP4, use the following steps:
• Let sequence be the byte sequence to be matched, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<ol>
	<li>
%長さ ~LET %~byte列 の`長さ$byte
◎
Let length be the number of bytes in sequence.
</li>
	<li>
~IF［
%長さ ~LT 12
］
⇒
~RET ~F
◎
If length is less than 12, return false.
</li>
	<li>
%~box~size ~LET
%~byte列[ 0 `+〜$ 4 ]
を~big-endianによる無符号 32-bit 整数に解釈した結果
◎
Let box-size be the four bytes from sequence[0] to sequence[3], interpreted as a 32-bit unsigned big-endian integer.
</li>
	<li>
~IF［
%長さ ~LT %~box~size
］~OR［
%~box~size ~MOD 4  ~NEQ 0
］
⇒
~RET ~F
◎
If length is less than box-size or if box-size modulo 4 is not equal to 0, return false.
</li>
	<li>
~IF［
%~byte列[ 4 `+〜$ 4 ] ~NEQ `ftyp^lX
］
⇒
~RET ~F
◎
If the four bytes from sequence[4] to sequence[7] are not equal to 0x66 0x74 0x79 0x70 ("ftyp"), return false.
</li>
	<li>
~IF［
%~byte列[ 8 `+〜$ 3 ] ~EQ `mp4^lX
］
⇒
~RET ~T
◎
If the three bytes from sequence[8] to sequence[10] are equal to 0x6D 0x70 0x34 ("mp4"), return true.
</li>
	<li>
<p>
%読取った~byte数 ~LET  16
◎
Let bytes-read be 16.
</p>

<p class="note">注記：
これは、
“`major brand^en” を成す~version番号に対応する 4 個の `~byte$を無視する。
◎
This ignores the four bytes that correspond to the version number of the "major brand".
</p>
	</li>
	<li>
<p>
~WHILE［
%読取った~byte数 ~LT %~box~size
］：
◎
While bytes-read is less than box-size, continuously loop through these steps:
</p>
		<ol>
			<li>
~IF［
%~byte列[ %読取った~byte数 `+〜$ 3 ] ~EQ `mp4^lX
］
⇒
~RET ~T
◎
If the three bytes from sequence[bytes-read] to sequence[bytes-read + 2] are equal to 0x6D 0x70 0x34 ("mp4"), return true.
</li>
			<li>
%読取った~byte数 ~INCBY 4
◎
Increment bytes-read by 4.
</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

			</section>
			<section id="signature-for-webm">
<h4 title="Signature for WebM">6.2.2. ~WebM用の符丁</h4>

<div class="algo">
<p>
`~WebM用の符丁に合致する@
かどうか決定するときは、
所与の
( `~byte列$ %~byte列 )
に対し，次の手続きを利用する：
◎
To determine whether a byte sequence matches the signature for WebM, use the following steps:
• Let sequence be the byte sequence to be matched, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<p class="trans-note">【
以下，この~algoの内容は、
未訳。
】</p>
</div>

			</section>
			<section id="signature-for-mp3-without-id3">
<h4 title="Signature for MP3 without ID3">6.2.3. ~ID3なしの~MP3用の符丁</h4>

<div class="algo">
<p>
`~ID3なしの~MP3用の符丁に合致する@
かどうか決定するときは、
所与の
( `~byte列$ %~byte列 )
に対し，次の手続きを利用する：
◎
To determine whether a byte sequence matches the signature for MP3 without ID3, use the following steps:
• Let sequence be the byte sequence to be matched, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<p class="trans-note">【
以下，この~algoの内容は、
未訳。
】</p>
</div>

		</section>
		<section id="matching-a-font-type-pattern">
<h3 title="Matching a font type pattern">6.3. ~font型~patternとの照合</h3>

<div class="algo">
<p>
次に与える
`~font型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`~font~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which font MIME type byte pattern a byte sequence input matches, if any, use the following font type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表t内の
~EACH( ~row %~row )
に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致したか ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致したか ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table class="grid-table patterns"><thead>
<tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`~font~MIME型$
<th class="note">注記
<tbody>

<tr><td>`00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4C 50^X
<td>`00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FF FF^X
<td>なし
<td>`application/vnd.ms-fontobject^mt
<td class="note">
`Embedded OpenType^i 符丁を表す，次の連結
⇒＃
34 個の`~byte$,
`LP^bl 
◎
34 bytes followed by the string "LP", the Embedded OpenType signature.

<tr><td>`00 01 00 00^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/ttf^mt
<td class="note">
`TrueType^i 符丁を表す，~version番号 1.0 を表現している 4 個の`~byte$
◎
4 bytes representing the version number 1.0, a TrueType signature.

<tr><td>`4F 54 54 4F^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/otf^mt
<td class="note">
`OpenType^i 符丁を表す， `OTTO^bl
◎
The string "OTTO", the OpenType signature.

<tr><td>`74 74 63 66^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/collection^mt
<td class="note">
`TrueType Collection^i 符丁を表す， `ttcf^bl
◎
The string "ttcf", the TrueType Collection signature.

<tr><td>`77 4F 46 46^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/woff^mt
<td class="note">
`Web Open Font Format 1.0^i 符丁を表す， `wOFF^bl
◎
The string "wOFF", the Web Open Font Format 1.0 signature. 

<tr><td>`77 4F 46 32^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/woff2^mt
<td class="note">
`Web Open Font Format 2.0^i 符丁を表す， `wOF2^bl
◎
The string "wOF2", the Web Open Font Format 2.0 signature. 
</table>

	</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>
</div>

		</section>
		<section id="matching-an-archive-type-pattern">
<h3 title="Matching an archive type pattern">6.4. ~archive型~patternとの照合</h3>

<div class="algo">
<p>
次に与える
`~archive型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`~archive~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which archive MIME type byte pattern a byte sequence input matches, if any, use the following archive type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表t内の
~EACH( ~row %~row )
に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致したか ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致したか ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table class="grid-table patterns"><thead>
<tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`~archive~MIME型$
<th class="note">注記
<tbody>

<tr><td>`1F 8B 08^X
<td>`FF FF FF^X
<td>なし
<td>`application/x-gzip^mt
<td class="note">
`GZIP^i ~archive符丁
◎
The GZIP archive signature.

<tr><td>`50 4B 03 04^X
<td>`FF FF FF FF^X
<td>なし
<td>`application/zip^mt
<td class="note">
`ZIP^i ~archive符丁を表す，次の連結
⇒＃
`PK^bl,
`ETX^smb,
`EOT^smb
◎
The string "PK" followed by ETX EOT, the ZIP archive signature.

<tr><td>`52 61 72 21 1A 07 00^X
<td>`FF FF FF FF FF FF FF^X
<td>なし
<td>`application/x-rar-compressed^mt
<td class="note">
`RAR 4.x^i ~archive符丁を表す，次の連結
⇒＃
`Rar!^bl,
`SUB^smb,
`BEL^smb,
`NUL^smb
◎
The string "Rar!" followed by SUB BEL NUL, the RAR 4.x archive signature.
</table>
	</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="determining-the-computed-mime-type-of-a-resource">
<h2 title="Determining the computed MIME type of a resource">7. 資源に算出される~MIME型の決定-法</h2>

<div class="algo">
<p>
［
`資源$に`算出される~MIME型$
］を決定するときには、
次に与える
`~MIME型を~sniffする~algo@
を利用するモノトスル：
◎
To determine the computed MIME type of a resource, user agents must use the following MIME type sniffing algorithm:
</p>

<ol>
	<li>
%資源~header ~LET `資源~header$
◎
↓↓</li>
	<li>
%~MIME型 ~LET `給された~MIME型$
◎
↓↓</li>
	<li>
%~script可否を~sniffするか ~LET ~IS［
`~sniffなしか$ ~EQ ~F
］
◎
↓</li>
	<li>
~IF［
%~MIME型 は［
`~XML~MIME型$／`~HTML~MIME型$
］である
］
⇒
~RET %~MIME型
◎
If the supplied MIME type is an XML MIME type or HTML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
~IF［
%~MIME型 ~EQ ε
］~OR［
%~MIME型 の`~essence$ ~IN
{ `unknown/unknown^l , `application/unknown^l ,`*/*^l }
］
⇒
~RET `未知な~MIME型を識別する規則$( %資源~header, %~script可否を~sniffするか )
◎
If the supplied MIME type is undefined or if the supplied MIME type’s essence is "unknown/unknown", "application/unknown", or "*/*", execute the rules for identifying an unknown MIME type with the sniff-scriptable flag equal to the inverse of the no-sniff flag and abort these steps.
</li>
	<li>
~IF［
`~sniffなしか$ ~EQ ~T
］
⇒
~RET %~MIME型
◎
If the no-sniff flag is set, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
~IF［
`~Apache~bugを検査するか$ ~EQ ~T
］
⇒
~RET `資源は~textか~binaryかを判別する規則$( %資源~header )
◎
If the check-for-apache-bug flag is set, execute the rules for distinguishing if a resource is text or binary and abort these steps.
</li>
	<li>
~IF［
%~MIME型 は `~UAにより~supportされて$いる`画像~MIME型$である
］
⇒
%合致した型 ~LET `画像~型~pattern照合~algo$( %資源~header )
◎
If the supplied MIME type is an image MIME type supported by the user agent, let matched-type be the result of executing the image type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matched-type is not undefined, the computed MIME type is matched-type.
◎
Abort these steps.
</li>
	<li>
~IF［
%~MIME型 は `~UAにより~supportされて$いる`音声動画~MIME型$である
］
⇒
%合致した型 ~LET `音声動画~型~pattern照合~algo$( %資源~header )
◎
If the supplied MIME type is an audio or video MIME type supported by the user agent, let matched-type be the result of executing the audio or video type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matched-type is not undefined, the computed MIME type is matched-type.
◎
Abort these steps.
</li>
	<li>
~RET %~MIME型
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		<section id="identifying-a-resource-with-an-unknown-mime-type">
<h3 title="Identifying a resource with an unknown MIME type">7.1. 未知な~MIME型を伴う資源の識別-法</h3>

<div class="algo">
<p>
次に与える
`未知な~MIME型を識別する規則@
は、［
未知な`~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
所与の
( `資源~header$ %資源~header,
真偽値
`~script可否を~sniffするか@V
 ~DF ~F )
に対し，`~MIME型$を返す
（ %~script可否を~sniffするか は、
`~script可能~MIME型$用に~sniffするかどうか決定するために利用される）：
◎
The sniff-scriptable flag is used by the rules for identifying an unknown MIME type to determine whether to sniff for scriptable MIME types.
◎
If the setting of the sniff-scriptable flag is not specified when calling the rules for identifying an unknown MIME type, the sniff-scriptable flag must default to unset.
◎
To determine the computed MIME type of a resource resource with an unknown MIME type, execute the following rules for identifying an unknown MIME type:
</p>

<ol>
	<li>
<p>
~IF［
`~script可否を~sniffするか$V ~EQ ~T
］
⇒
下に与える表t内の
~EACH( ~row %~row )
に対し：
◎
If the sniff-scriptable flag is set, execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致したか ~LET
`~pattern照合~algo$( %資源~header, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given resource’s resource header, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致したか ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table class="grid-table patterns"><thead>
<tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`算出される~MIME型$
<th class="note">注記
<tbody>

<tr><td>`3C 21 44 4F 43 54 59 50 45 20 48 54 4D 4C ~tagT^X
<td>`FF FF DF DF DF DF DF DF DF FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;!DOCTYPE HTML^bl ,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;!DOCTYPE HTML" followed by a tag-terminating byte.

<tr><td>`3C 48 54 4D 4C ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;HTML^bl ,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;HTML" followed by a tag-terminating byte.

<tr><td>`3C 48 45 41 44 ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;HEAD^bl ,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;HEAD" followed by a tag-terminating byte.

<tr><td>`3C 53 43 52 49 50 54 ~tagT^X
<td>`FF DF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;SCRIPT^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;SCRIPT" followed by a tag-terminating byte.

<tr><td>`3C 49 46 52 41 4D 45 ~tagT^X
<td>`FF DF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;IFRAME^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;IFRAME" followed by a tag-terminating byte.

<tr><td>`3C 48 31 ~tagT^X
<td>`FF DF FF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;H1^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;H1" followed by a tag-terminating byte.

<tr><td>`3C 44 49 56 ~tagT^X
<td>`FF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;DIV^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;DIV" followed by a tag-terminating byte.

<tr><td>`3C 46 4F 4E 54 ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;FONT^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;FONT" followed by a tag-terminating byte.

<tr><td>`3C 54 41 42 4C 45 ~tagT^X
<td>`FF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;TABLE^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;TABLE" followed by a tag-terminating byte.

<tr><td>`3C 41 ~tagT^X
<td>`FF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;A^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;A" followed by a tag-terminating byte.

<tr><td>`3C 53 54 59 4C 45 ~tagT^X
<td>`FF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;STYLE^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;STYLE" followed by a tag-terminating byte.

<tr><td>`3C 54 49 54 4C 45 ~tagT^X
<td>`FF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;TITLE^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;TITLE" followed by a tag-terminating byte.

<tr><td>`3C 42 ~tagT^X
<td>`FF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;B^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;B" followed by a tag-terminating byte.

<tr><td>`3C 42 4F 44 59 ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;BODY^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;BODY" followed by a tag-terminating byte.

<tr><td>`3C 42 52 ~tagT^X
<td>`FF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;BR^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;BR" followed by a tag-terminating byte.

<tr><td>`3C 50 ~tagT^X
<td>`FF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
大小無視 `&lt;P^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;P" followed by a tag-terminating byte.

<tr><td>`3C 21 2D 2D ~tagT^X
<td>`FF FF FF FF FF^X
<td>`空白~byte$
<td>`text/html^mt
<td class="note">
次の連結
⇒＃
`&lt;!--^bl,
`~tag-terminating~byte$
◎
The string "&lt;!--" followed by a tag-terminating byte.

<tr><td>`3C 3F 78 6D 6C^X
<td>`FF FF FF FF FF^X
<td>`空白~byte$
<td>`text/xml^mt
<td class="note">
`&lt;?xml^bl 
◎
The string "&lt;?xml".

<tr><td>`25 50 44 46 2D^X
<td>`FF FF FF FF FF^X
<td>なし
<td>`application/pdf^mt
<td class="note">
`PDF^i 符丁を表す， `%PDF-^bl
◎
The string "%PDF-", the PDF signature.
</table>
	</li>
	<li>
<p>
下に与える表t内の
~EACH( ~row %~row )
に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致したか ~LET
`~pattern照合~algo$( %資源~header, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given resource’s resource header, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致したか ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table class="grid-table patterns"><thead>
<tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`算出される~MIME型$
<th class="note">注記
<tbody>

<tr><td>`25 21 50 53 2D 41 64 6F 62 65 2D^X
<td>`FF FF FF FF FF FF FF FF FF FF FF^X
<td>なし
<td>`application/postscript^mt
<td class="note">
`PostScript^i 符丁を表す， `%!PS-Adobe-^bl
◎
The string "%!PS-Adobe-", the PostScript signature.

<tr><td>`FE FF 00 00^X
<td>`FF FF 00 00^X
<td>なし
<td>`text/plain^mt
<td class="note">
~UTF-16BE~BOM
◎
UTF-16BE BOM

<tr><td>`FF FE 00 00^X
<td>`FF FF 00 00^X
<td>なし
<td>`text/plain^mt
<td class="note">
~UTF-16LE~BOM
◎
UTF-16LE BOM

<tr><td>`EF BB BF 00^X
<td>`FF FF FF 00^X
<td>なし
<td>`text/plain^mt
<td class="note">
~UTF-8~BOM
◎
UTF-8 BOM
</table>

<p>
~UAは、
追加的な`~MIME型$を~supportするためとして，この表tを暗黙的に拡張してもヨイ。
◎
User agents may implicitly extend this table to support additional MIME types.
</p>

<p>
しかしながら，~UAは、［
この表t内にすでに在る，`算出される~MIME型$
］用に追加的な`~byte~pattern$を含ませて，この表tを暗黙的に拡張するベキでない
— そうすると、
特権拡大の脆弱性が導入されかねないので。
◎
However, user agents should not implicitly extend this table to include additional byte patterns for any computed MIME type already present in this table, as doing so could introduce privilege escalation vulnerabilities.
</p>

<p>
~UAは、
この表tを拡張するときには，いかなる特権拡大の脆弱性も導入してはナラナイ。
◎
User agents must not introduce any privilege escalation vulnerabilities when extending this table.
</p>

	</li>
	<li>
%合致した型 ~LET 
`画像~型~pattern照合~algo$( %資源~header )
◎
Let matchedType be the result of executing the image type pattern matching algorithm given resource’s resource header.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matchedType is not undefined, return matchedType.
</li>
	<li>
%合致した型 ~SET 
`音声動画~型~pattern照合~algo$( %資源~header )
◎
Set matchedType to the result of executing the audio or video type pattern matching algorithm given resource’s resource header.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET 
%合致した型

◎
If matchedType is not undefined, return matchedType.
</li>
	<li>
%合致した型 ~SET `~archive型~pattern照合~algo$( %資源~header )
◎
Set matchedType to the result of executing the archive type pattern matching algorithm given resource’s resource header.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matchedType is not undefined, return matchedType.
</li>
	<li>
~IF［
%資源~header を成すどの~byteも`~binary~data~byte$でない
］
⇒
~RET `text/plain^l 
◎
If resource’s resource header contains no binary data bytes, return "text/plain".
</li>
	<li>
~RET `application/octet-stream^l 
◎
Return "application/octet-stream".
</li>
</ol>
</div>

		</section>
		<section id="sniffing-a-mislabeled-binary-resource">
<h3 title="Sniffing a mislabeled binary resource">7.2. 誤labelされた~binary資源の~sniff法</h3>

<div class="algo">
<p>
次に与える
`資源は~textか~binaryかを判別する規則@
は、［
~binary`資源$は素な~textとして誤labelされたかどうか
］を決定するときに利用される
— それは、
所与の
( `~byte列$ %資源~header )
に対し，`~MIME型$を返す：
◎
To determine whether a binary resource has been mislabeled as plain text, execute the following rules for distinguishing if a resource is text or binary:
• Let length be the number of bytes in the resource header.
</p>

<ol>
	<li>
<p>
~RET［
~OR↓ が満たされるならば `text/plain^l ／
~ELSE_ `application/octet-stream^l
］：
◎
↓</p>
		<ul>
			<li>
%資源~header[ 0 `+〜$ 2 ] ~IN
{ `FE FF^X （ ~UTF-16BE~BOM）, `FF FE^X （ ~UTF-16LE~BOM ） }
◎
If length is greater than or equal to 2 and the first 2 bytes of the resource header are equal to 0xFE 0xFF (UTF-16BE BOM) or 0xFF 0xFE (UTF-16LE BOM), the computed MIME type is "text/plain".
• Abort these steps.
</li>
	<li>
%資源~header[ 0 `+〜$ 3 ] ~EQ `EF BB BF^X （ ~UTF-8~BOM ）
◎
If length is greater than or equal to 3 and the first 3 bytes of the resource header are equal to 0xEF 0xBB 0xBF (UTF-8 BOM), the computed MIME type is "text/plain".
• Abort these steps.
</li>
	<li>
%資源~header を成すどの~byteも`~binary~data~byte$でない
◎
If the resource header contains no binary data bytes, the computed MIME type is "text/plain".
• Abort these steps.
◎
The computed MIME type is "application/octet-stream".
</li>
		</ul>

<p class="warning">
`資源は~textか~binaryかを判別する規則$は、
決して［
`算出される~MIME型$は，`~script可能~MIME型$であるものと決定しない
］ことが必要不可欠である
— そうすることは、
特権拡大~攻撃を許容することになり得るので。
◎
It is critical that the rules for distinguishing if a resource is text or binary never determine the computed MIME type to be a scriptable MIME type, as this could allow a privilege escalation attack.
</p>
	</li>
</ol>
</div>

		</section>
	</section>
	<section id="context-specific-sniffing">
<h2 title="Context-specific sniffing">8. 文脈に特有な~sniff法</h2>

<p class="XXX">
`文脈@
とは…
◎
A context is ….
</p>

<p>
ある種の`文脈$においては、
一定範囲の`~MIME型$に属する`資源$のみを識別することが有用になる。
◎
In certain contexts, it is only useful to identify resources that belong to a certain subset of MIME types.
</p>

<p>
その種の`文脈$において`資源$に`算出される~MIME型$を決定するときは、
`~MIME型を~sniffする~algo$に代えて，`文脈に特有な~sniffする~algo$を利用することが適切になる。
◎
In such contexts, it is appropriate to use a context-specific sniffing algorithm in place of the MIME type sniffing algorithm in order to determine the computed MIME type of a resource.
</p>

<p>
`文脈に特有な~sniffする~algo@
は、
【この節の各~下位~節に与える各種~algoの総称であり，】
所与の`資源$の`~MIME型$が 特定0の`文脈$に関連な場合に限り，当の`資源$に`算出される~MIME型$を決定する。
◎
A context-specific sniffing algorithm determines the computed MIME type of a resource only if the resource is a MIME type relevant to a particular context.
</p>

		<section id="sniffing-in-a-browsing-context">
<h3 title="Sniffing in a browsing context">8.1. 閲覧~文脈における~sniff法</h3>

<p class="XXX">
`~MIME型を~sniffする~algo$を利用する。
◎
Use the MIME type sniffing algorithm.
</p>

		</section>
		<section id="sniffing-in-an-image-context">
<h3 title="Sniffing in an image context">8.2. 画像~文脈における~sniff法</h3>

<div class="algo">
<p>
次に与える
`画像を特定的に~sniffするための規則@
は、［
`画像~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
`~MIME型$を返す：
◎
To determine the computed MIME type of a resource with an image MIME type, execute the following rules for sniffing images specifically:
</p>

<ol>

<li>
~IF［
`給された~MIME型$は`~XML~MIME型$である
］
⇒
~RET `給された~MIME型$
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
%合致した画像~型 ~LET `画像~型~pattern照合~algo$( `資源~header$ )
◎
Let image-type-matched be the result of executing the image type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した画像~型 ~NEQ ε
］
⇒
~RET %合致した画像~型
◎
If image-type-matched is not undefined, the computed MIME type is image-type-matched.
◎
Abort these steps.
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		</section>
		<section id="sniffing-in-an-audio-or-video-context">
<h3 title="Sniffing in an audio or video context">8.3. 音声動画~文脈における~sniff法</h3>

<div class="algo">
<p>
次に与える
`音声や動画を特定的に~sniffするための規則@
は、［
`音声動画~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
`~MIME型$を返す：
◎
To determine the computed MIME type of a resource with an audio or video MIME type, execute the following rules for sniffing audio and video specifically:
</p>

<ol>
	<li>
~IF［
`給された~MIME型$は`~XML~MIME型$である
］
⇒
~RET `給された~MIME型$
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
%合致した音声動画~型 ~LET 
`音声動画~型~pattern照合~algo$( `資源~header$ )
◎
Let audio-or-video-type-matched be the result of executing the audio or video type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した音声動画~型 ~NEQ ε
］
⇒
~RET %合致した音声動画~型
◎
If audio-or-video-type-matched is not undefined, the computed MIME type is audio-or-video-type-matched.
◎
Abort these steps.
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		</section>
		<section id="sniffing-in-a-plugin-context">
<h3 title="Sniffing in a plugin context">8.4. ~plugin文脈における~sniff法</h3>

<div class="algo">
<p>
次に与える
`~plugin文脈~内で~sniffするための規則@
は、
~plugin文脈~内で，［
`~fetch$された`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
`~MIME型$を返す：
◎
To determine the computed MIME type of a resource fetched in a plugin context, execute the following rules for sniffing in a plugin context:
</p>

<ol>
	<li class="XXX">
~IF［
`給された~MIME型$ ~EQ ε
］
⇒
~RET `application/octet-stream^l
◎
If the supplied MIME type is undefined, the computed MIME type is "application/octet-stream".
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		</section>
		<section id="sniffing-in-a-style-context">
<h3 title="Sniffing in a style context">8.5. ~style文脈における~sniff法</h3>

<div class="algo">
<p>
次に与える
`~style文脈~内で~sniffするための規則@
は、
~style文脈~内で，［
`~fetch$された`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
`~MIME型$を返す：
◎
To determine the computed MIME type of a resource fetched in a style context, execute the following rules for sniffing in a style context:
</p>

<ol>
	<li class="XXX">
~IF［
`給された~MIME型$ ~EQ ε
］
⇒
…
◎
If the supplied MIME type is undefined, ….
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		</section>
		<section id="sniffing-in-a-script-context">
<h3 title="Sniffing in a script context">8.6. ~script文脈における~sniff法</h3>

<div class="algo">
<p>
次に与える
`~script文脈~内で~sniffするための規則@
は、
~script文脈~内で，［
`~fetch$された`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
`~MIME型$を返す：
◎
To determine the computed MIME type of a resource fetched in a script context, execute the following rules for sniffing in a script context:
</p>

<ol>
	<li class="XXX">
~IF［
`給された~MIME型$ ~EQ ε
］
⇒
…
◎
If the supplied MIME type is undefined, ….
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		</section>
		<section id="sniffing-in-a-font-context">
<h3 title="Sniffing in a font context">8.7. ~font文脈における~sniff法</h3>

<div class="algo">
<p>
次に与える
`~fontを特定的に~sniffするための規則@
は、［
`~font~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、
`~MIME型$を返す：
◎
To determine the computed MIME type of a resource with a font MIME type, execute the following rules for sniffing fonts specifically:
</p>

<ol>
	<li>
~IF［
`給された~MIME型$は`~XML~MIME型$である
］
⇒
~RET `給された~MIME型$
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
%合致した~font型 ~LET 
`~font型~pattern照合~algo$( `資源~header$ )
◎
Let font-type-matched be the result of executing the font type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した~font型 ~NEQ ε
］
⇒
~RET %合致した~font型
◎
If font-type-matched is not undefined, the computed MIME type is font-type-matched.
◎
Abort these steps.
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>
</div>

		</section>
		<section id="sniffing-in-a-text-track-context">
<h3 title="Sniffing in a text track context">8.8. ~text-track文脈における~sniff法</h3>

<p class="XXX">
`算出される~MIME型$は `text/vtt^l とする。
◎
The computed MIME type is "text/vtt".
</p>

		</section>
		<section id="sniffing-in-a-cache-manifest-context">
<h3 title="Sniffing in a cache manifest context">8.9. ~cache~manifest文脈における~sniff法</h3>

<p class="XXX">
`算出される~MIME型$は `text/cache-manifest^l とする。
◎
The computed MIME type is "text/cache-manifest".
</p>

<p class="trans-note">【
`text/cache-manifest^l は~HTMLの~app~cache用であったが、
その特能は廃用にされたので，この節は今や用を為さない。
】</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">

<p>
Special thanks to Adam Barth and Ian Hickson for maintaining previous incarnations of this document.
</p>

<p>
Thanks also to
 Alfred Hönes,
 Andreu Botella,
 Anne van Kesteren,
 Ben Eidson,
 Boris Zbarsky,
 Darien Maillet Valentine,
 David Singer,
 Domenic Denicola,
 Henri Sivonen,
 Jean-Yves Avenard,
 Jonathan Neal,
 Joshua Cranmer,
 Larry Masinter,
 罗泽轩,
 Mariko Kosaka,
 Mark Pilgrim,
 Paul Adenot,
 Peter Occil,
 Rob Buis,
 Russ Cox,
 Simon Pieters, and
 triple-underscore
 for their invaluable contributions.
 </p>

<p>
This standard is written by <a href="https://gphemsley.org/">Gordon P. Hemsley</a> (<a href="mailto:me@gphemsley.org">me@gphemsley.org</a>).
</p>

</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://mimesniff.spec.whatwg.org/review-drafts/2025-07/">Living Standard Review Draft</a>.
</p>
</div>

</div>
