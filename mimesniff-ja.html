<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>MIME Sniffing （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<style>
.hex-seq {
	font-family: sans-serif0, sans-serif;
}
.hex-seq > abbr {
	font-style: italic;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		collectParts: Util.collectParts,
		toc_main: 'MAIN0',
		generate: expand
	});
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return '<var>' + match.slice(1) + '</var>'
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'lX': // literal hex seq
	return (
'<span class="hex-seq">0x'
+ key.replace(/&(lt|gt|amp);|./g, function(s, s1){
	if(s1) {
		s = {lt:'<', gt: '>', amp:'&'}[s1];
	}
	return s.charCodeAt(0).toString(16)+ ' ';
}).toUpperCase()
+ '</span>( `<code class="literal">' + key + '</code>` )'
	);
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // byte literal
	text = '`<code class="literal">' + text + '</code>`';
	break;
case 'U': // code point
	text =
'<span class="code-point">U+' + key + '</span>'
+ ' (<span class="char-symbol">&#x' + key + ';</span>)'
	;
	break;
case 'U0': // code point
	text =
'<span class="code-point">U+' + key + '</span>'
	;
	break;
case 'X':
	text = '0x' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-05-29
trans_update:2018-04-21
source_checked:180216
spec_status:LS
original_url:https://mimesniff.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:2018,whatwg
trans_1st_pub:2018-02-18
site_nav:security,network


●●class_map
P:production
h:header
X:hex-seq
e:element
a:attr
mt:mime-type

●●tag_map
mt:code
c:code
e:code
a:code
P:code
h:code
X:span
i:i

●●link_map

a.type:~HEscripting#attr-script-type
e.script:~HEscripting#the-script-element

~HTTP引用符付き文字列~token符号位置:#http-quoted-string-token-code-point
~HTTP~token符号位置:#http-token-code-point

~MIME型:#mime-type
~MIME型~record:#mime-type

画像~MIME型:#image-mime-type
音声動画~MIME型:#audio-or-video-mime-type
~font~MIME型:#font-mime-type
~ZIPに基づく~MIME型:#zip-based-mime-type
~archive~MIME型:#archive-mime-type
~XML~MIME型:#xml-mime-type
~HTML~MIME型:#html-mime-type
~script可能~MIME型:#scriptable-mime-type
~JS~MIME型:#javascript-mime-type
~JS~MIME型に~essence合致-:#javascript-mime-type-essence-match
~JSON~MIME型:#json-mime-type

給された~MIME型:#supplied-mime-type
~binary~data~byte:#binary-data-byte
算出される~MIME型:#computed-mime-type
妥当な~MIME型~文字列:#valid-mime-type
~parameterを伴わない妥当な~MIME型~文字列:#valid-mime-type-with-no-parameters

~byte列から~MIME型を構文解析する:#parse-a-mime-type-from-bytes
~MIME型を~byte列に直列化する:#serialize-a-mime-type-to-bytes



~MIME型を直列化する:#serialize-a-mime-type
~MIME型を~sniffする~algo:#mime-type-sniffing-algorithm
文脈に特有の~sniffする~algo:#context-specific-sniffing-algorithm
特に画像を~sniffするための規則:#rules-for-sniffing-images-specifically
特に音声や動画を~sniffするための規則:#rules-for-sniffing-audio-and-video-specifically
特に~fontを~sniffするための規則:#rules-for-sniffing-fonts-specifically
~plugin文脈~内で~sniffするための規則:#rules-for-sniffing-in-a-plugin-context
~style文脈~内で~sniffするための規則:#rules-for-sniffing-in-a-style-context
~script文脈~内で~sniffするための規則:#rules-for-sniffing-in-a-script-context

~mp3~frameを構文解析する:#parse-an-mp3-frame
~MIME型を構文解析する:#parse-a-mime-type
可変長整数を構文解析する:#parse-a-vint

~pattern~mask:#pattern-mask
~byte~pattern:#byte-pattern

~pattern照合~algo:#pattern-matching-algorithm
~archive型~pattern照合~algo:#archive-type-pattern-matching-algorithm
音声動画~型~pattern照合~algo:#audio-or-video-type-pattern-matching-algorithm
~font型~pattern照合~algo:#font-type-pattern-matching-algorithm
画像~型~pattern照合~algo:#image-type-pattern-matching-algorithm
~mp3~headerに合致する:#match-an-mp3-header
~ID3なしの~MP3用の符丁に合致する:#matches-the-signature-for-mp3-without-id3
~MP4用の符丁に合致する:#matches-the-signature-for-mp4
~WebM用の符丁に合致する:#matches-the-signature-for-webm
~matching~a~padded連列:#matching-a-padded-sequence

~Apache~bug用~検査~flag:#check-for-apache-bug-flag
文脈:#context
~essence:#mime-type-essence
~mp3~frame~sizeを算出する:#compute-an-mp3-frame-size
~sniffなし~flag:#no-sniff-flag
~parameter~map:#parameters

資源:#resource
資源~headerを読取る:#read-the-resource-header
資源~header:#resource-header

資源は~feedか~HTMLかを判別する規則:#rules-for-distinguishing-if-a-resource-is-a-feed-or-html
資源は~textか~binaryかを判別する規則:#rules-for-text-or-binary
未知の~MIME型を識別する規則:#rules-for-identifying-an-unknown-mime-type
~script可否を~sniffする~flag:#sniff-scriptable-flag
下位型:#subtype
給された~MIME型を検出する~algo:#supplied-mime-type-detection-algorithm
~UAにより~supportされて:#supported-by-the-user-agent
~tag-terminating~byte:#tag-terminating-byte
型:#type
	＊`type:#type
空白~byte:#whitespace-byte

P.token:~RFC7230#section-3.2.6
P.quoted-string:~RFC7230#section-3.2.6
P.media-type:~RFC7231#section-3.1.1.1
~fetch:~FETCH#concept-fetch

	~bug:https://issues.apache.org/bugzilla/show_bug.cgi?id=13986
	w3c/preload~#113:https://github.com/w3c/preload/issues/113

部分~byte列:#_subbytes
+〜:#_subbytes

~EACH:~INFRA#map-iterate
~BREAK:~INFRA#iteration-break
~IN:~INFRA#list-contain
~CONTINUE:~INFRA#iteration-continue

~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII文字列:~INFRA#ascii-string
~ASCII空白:~INFRA#ascii-whitespace
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
~ASCII大小無視:~INFRA#ascii-case-insensitive

~byte:~INFRA#byte
byte.長さ:~INFRA#byte-sequence-length
~byte列:~INFRA#byte-sequence

文字列:~INFRA#string
符号位置:~INFRA#code-point
同型に復号する:~INFRA#isomorphic-decode
同型に符号化する:~INFRA#isomorphic-encode
位置~変数:~INFRA#string-position-variable
集合:~INFRA#ordered-set

map.~key:~INFRA#map-key
map.値:~INFRA#map-value
有順序~map:~INFRA#ordered-map
	~EQ ε:~INFRA#map-exists
	~SET:~INFRA#map-set


●●words_table1

tagT:<abbr>TT</abbr>

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 

Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>


●●words_table

	●signature
	AIFF
	Web Open Font Format
	GIF
	GZIP archive
	AVI:
	Windows Icon
	Windows Cursor
	JPEG Start of Image
	MIDI
	ID3v2-tagged MP3
	Ogg container
	PDF
	PNG
	RAR archive
	PostScript
	OpenType
	Embedded OpenType
	TrueType
	TrueType Collection
	WAVE
	ZIP archive


	●MIME
template::::テンプレート
MIME:
essence:
feed:
ZIP:
ID3:
MP3:
MP4:
WebM:
XML:
manifest::::マニフェスト
plugin::::プラグイン
style::::スタイル
frame::::フレーム
size::::サイズ
version::::バージョン
Apache:
FTP:
mime:
mp2:
mp3:
archive::::アーカイブ
HTML:
font::::フォント
text-track:text track:::テキストトラック
script::::スクリプト
	~script可能:scriptable
	scripting
parameter::::パラメタ
符丁:signature::~
素の:plain::~
資源:resource::~:リソース
媒体:media::~::メディア
画像:image::~
音声:audio::~
動画:video::~
音声動画:audio or video::音声／動画
拡張子:extension::~
型:type::~
下位型:subtype::~
値:value:~
名:name:~

	●sniff／構文解析
mask::::マスク
offset::::オフセット
sniff:
sniffing:::sniff 処理
	~sniffなし:no-sniff
	~script可否を~sniffする:sniff-scriptable
BOM:
UTF-16BE:
UTF-16LE:
UTF-8:
	TAB
	BEL
	BMP
	SPACE
	CR
	EOT
	ETX
	NUL
	LF
	SUB
	BS
	VT
	SO
	FS
	US
ASCII:
flag::::フラグ
binary::::バイナリ
bit::::ビット
box::::ボックス
buffer::::バッファ
byte::::バイト
	~parameter~map:parameters
pattern::::パタン
header::::ヘッダ
	~header:header field
field::::フィールド
group::::グループ
rate::::レート
sample::::サンプル
key:
tag-terminating::tag 終了::タグ終了
終了-:terminate:~
	terminating
給-:supply:~
誤label:mislabel:::誤ラベル
token::::トークン
入力:input::~
付加-:append::~
前付加-:prepend:~
収集-:collect:~
妥当:valid::~
合致-:match::~
照合:matching::~
照合-:match::~
	照合-用の:matched against
構文解析-:parse::~::パース
	構文解析-法:parsing
	-:parsed
大小無視:case-insensitive::~
小文字:lowercase::~
生成規則:production::~
規則:rule::~
整数:integer::~
符号位置:code point::~
文字:character::~
文字列:string::~
引用符付き:quoted::~
空白:whitespace::~
番号:number:~
	数:number:~
空:empty::~
	空でない:non-empty
範囲:range:~
連列:sequence:~
	~byte列:sequence
連結:concatenation:~
長さ:length::~
比較-:compare:~
演算:operation:~
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
符号化法:encoding::~::エンコーディング
符号化-:encode::~::エンコード
復号-:decode::~::デコード
同型:isomorphic::~
算出-:compute:~
算出:computation:~
除去-:remove::~
飛ばす:skip する:~
	を飛ばす:skips past
読飛ばす:skip する:読み飛ばす
書込法:writing::書き込み法
読取法:reading::読み取り法
読取る:read する::読取る
読取れな:read できな::読み取れな
読取った:read した::読み取った
失敗:failure::~
	どこかで失敗-:have not been entirely successful
無視-:ignore:~
識別-:identify:~
可変長整数:vint:~
	= Variable size Integer
	~Apache~bug用~検査:check-for-apache-bug
変数:variable:~

	●保安
XSS:cross-site scripting:XSS
security::::セキュリティ
資格証:credentials::資格証明情報::クレデンシャル
脆弱性:vulnerabilities:~
悪意的:malicious:~
偽装-:spoof:~
攻撃:attack:~
攻撃者:attacker:~
認証:authentication:~
特権を有する:privileged:~
低特権の:low-privilege::~
特権拡大:privilege escalation::~
厳しく:severe に:~
無害:benign:~
正直:honest:~
盗んで:stealして:~
仕掛ける:mount する:~

	●仕様
UA:user agent:UA
Web::::~
algo:algorithm:::アルゴリズム
bug::::バグ
system::::システム
web:
明瞭:clear:~
事例:case:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
作業:work:~
効率的:efficient:~
各種用語:terminology:~
含意:implications:~
基本的:basic:~
実質的:effective:~
実際:actual:~
	必要:need:~
手続き:steps:~
有意:significant:~
有意度:significance:~
有用:useful:~
標準:standard:~
正確:exact:~
正確に:exactly:~
注意深く:careful:~
	用いて:using:~
用語:term:~
直に:direct に:~
相互運用性:interoperability:~
経験:experience:~
能力:capability:~
要件:requirements:~
要因:factor:~
課題:issue:~
適切:appropriate:~
適度:reasonable:~
関連する:relevant な:~
容易:easy:~
	容易に~easily
歴史的:historic:~
一貫して:consistentに:~
労力:effort:~
必要不可欠:critical:~
計測情報:metrics:~
	しかしながら，:however
	したがって:thus
	べき:should
	例:example
	無論:of course
	課され:impose され
	普及している:popular な
	にもなり得る:potentially
	必然的に:inevitably
	~~広範な:extensive
	決して:never
	そのほか:miscellaneous
	に加えて:in addition to
	追加の:additional

	■謝辞
	acknowledgements
	-:special
	-:incarnations

	●仕様（動詞
support::::サポート
opt-out:opt out
	任意選択で外す
供与-:contribute:~
供-:provide:~
依存-:depend:~
保守-:maintain:~
利用-:use:~
利用者:user:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
導入-:introduce:~
序論:introduction:~
強いら:force さ:~
情報:information:~
意図-:intend:~
拘束:constraints:~
拡張-:extend:~
指定-:specify:~
指示-:indicate:~
指示子:indicator:~
挙動:behavior:ふるまい
	備わる／在る:present
呈示-:present:~
暗黙的:implicit:~
望まな:wish しな:~
未定義:undefined:~
	ε:undefined:~
条件:condition:~
検出-:detect:~
精査-:examine:~
検査器:checker:~
検査:check:~
error::::エラー
	~error検査-用:error-checking
決定-:determine:~
決定的:deterministic:~
混同:confusion:~
特有の:specific な:~
略称-:abbreviate:~
解釈-:interpret:~
述べる:describe する:~
許容-:allow:~
遂行-:perform:~
適合性:conformance:~
適用-:apply:~
	選ぶ:choose:~
避ける:avoid する:~
	なくなる:prevent:~
述べら:describe さ:~
免除-:exempt:~
予見-:believe:~
分岐-:diverge:~
分岐:divergents:~
認識-:recognize:~
	認識できない:unrecognized
想定-:suppose:~
依拠-:rely:~
	依拠できない:unreliable
調査:research:~
主導-:conduct:~
判別-:distinguish:~
	称され:referred
	~~追認-:tolerate
	端を発し:originated from
	〜に基づく:based
	保ち続け:keep track
	扱う:treat:~
	見よ:see:~
	得方:method of obtaining
	-:installation

	●未分類（動詞
包含-:contain:~
内容:content:~
	内容:contain

実行-:execute:~
実行:execution:~
応答:response:~
接続:connection:~
検索取得-:retrieve:~

結付けら:associate さ:結び付けら
結付けた:associate した:結び付けた
表現-:represent:~
表現:representation:~
達-:reach:~
配備-:deploy:~
	返す:return:~
	含-:include:~
	対応-:correspond:~
	得-:obtain:~
	等し:equal:~

	天秤にかける:balance
閲覧文脈:browsing context::~
経過-:elapse:~
無符号:unsigned:~
	満たされ:met
	変わる:varies:
	かもしれない:might
	属する:belong
	^en:reverse-engineer


	●未分類
JS:JavaScript
JSON:
metadata::::メタデータ
file::::ファイル
hook::::フック
row:行
HTTP:
browser::::ブラウザ
cache::::キャッシュ
call:
data::::データ
database::::データベース
fetch:
index:
map::::マップ
集合:set::~
entry:
key:
record::::レコード
marker::::マーカ
protocol::::プロトコル
server::::サーバ
serve::::サーブ
site::::サイト
源:source::~::ソース
text::::テキスト
upload::::アップロード
client::::クライアント
big-endian:
table::::テーブル


低速:slow:~
上位集合:superset::~
	一定範囲の:certain subset of
並列:parallel::~
位置:position::~
初期:initial:~
	初期~時には:initially
厳密比較で:strict に:~
	strictly
名前:name:~
文書:document:~
文脈:context:~
	時間:amount of time

空間:space:~
量:amount:~
順序:order:~
有順序:ordered:~
要素:element:~
属性:attribute:~

	●指示語
新たな:new:~
外側:outside:~
外部の:external:~
特定0の:particular:ある特定の
既存の:existing:~
既定の:default:~
未知の:unknown:~
自前の:own:~
	すべての:all
	この:this
	これらの／そのような:these
	そのような／その種の:such
	ある種の:certain
	その:that
	それらの:their
	それらの:those
	それらを:them
	そこに:therein
	すでに:already
	一致:identical
	介:via
	他の:other
	他の場合:otherwise
	以前:previous
	別の:another
	各:each
	同じ:same
	多くの:many
	新たな:new
	最初の:first
	最後の:last
	特に:in-particular
	異なる:different
	結果:result
	結果の:resulting
	任意の:arbitrary
	所与の:given
	終端:end
	終端-:end
	頭部:leading
	尾部を成す:trailing
	最大:max
	〜間:among
	一部の:some
	最も:most
	古い:older
	大方の:majority
	に代えて:in place of
	個の:one ／four
	0:zero
	一回:once
	まで:until
	相当数の:sizable number
	冒頭部:beginning
	より:more

	次に与える／次の:the following
	を成す符号位置に〜でないものがある:does not solely contain
	を成すどの〜も〜である:solely contains 〜
	を成すどの〜も〜でない:contains no 〜
	〜場合の結果は、〜になる:end up
	なし:None

	●演算
	-:bitwise
	-:inverse
	-:mathematical
	-:operator
	-:equation
	+〜:starting
	~IN:exactly equal to one of
	~BREAK:exit
	~NEQ ε:is not past the end of input
	~WHILE:enter loop 〜
	~INCBY:advance／increment 〜 by
	~GTE:greater than or equal to
	~GTE:greater or equal than
	~LT:is less than
	~GT:greater than
	~MOD:modulo
	の`長さ$byte:the number of bytes in 

	●変数名
iter:
index:
	~parameter名:parameterName
	~parameter値:parameterValue
	残り~byte数:bytes remaining
	~mime型:mimeType
	~box~size:~box-size
	給された型:supplied-type
	合致した画像~型:image-type-matched
	~parameter名:parameterName
	~parameter値:parameterValue
	文字列~直列化:stringSerialization
	読取る~byte数:~bytes-read
	~mask済み~data:maskedData
	合致した~font型:font-type-matched
	合致した音声動画~型:audio-or-video-type-matched
	合致した型:matched-type
	合致した:matched:#2
	~patternに合致した:patternMatched
	合致した型:matchedType

●●ref_normative

[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FTP]
    J. Postel; J. Reynolds. File Transfer Protocol. October 1985. Internet Standard. URL: https://tools.ietf.org/html/rfc959 
[HTTP]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7230 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMETYPE]
    N. Freed; N. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. November 1996. Draft Standard. URL: https://tools.ietf.org/html/rfc2046 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC7231]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231 
[RFC7303]
    H. Thompson; C. Lilley. XML Media Types. July 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7303 
[RFC8081]
    C. Lilley. The "font" Top-Level Media Type. February 2017. Proposed Standard. URL: https://tools.ietf.org/html/rfc8081 
[SECCONTSNIFF]
    Adam Barth; Juan Caballero; Dawn Song. Secure Content Sniffing for Web Browsers, or How to Stop Papers from Reviewing Themselves. URL: https://www.adambarth.com/papers/2009/barth-caballero-song.pdf 


●●ref_informative

[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[MEDIAQUERIES]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. URL: https://drafts.csswg.org/mediaqueries-4/ 


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://mimesniff.spec.whatwg.org/">MIME Sniffing</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/mimesniff">GitHub whatwg/mimesniff</a> (<a href="https://github.com/whatwg/mimesniff/issues/new">new issue</a>, <a href="https://github.com/whatwg/mimesniff/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=MIME&amp;resolution=---">legacy open bugs</a>

Commits:
	<a href="https://github.com/whatwg/mimesniff/commits">GitHub whatwg/mimesniff/commits</a>
	<a href="https://mimesniff.spec.whatwg.org/commit-snapshots/a5848c708a83c6094eb7677c9cd801c903fdf4a1/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/mimesniff">@mimesniff</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/mimesniff">web-platform-tests mimesniff/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/mimesniff">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0ibTE1LDV2OTBoNzB2LTc1bC0xNS0xNXoiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZT0iIzNjNzkwYSIgZmlsbD0iI2ZmZiIvPgo8cGF0aCBkPSJtMzgsMzhjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iIzNjNzkwYSIvPgo8L3N2Zz4K"
></a>
<!-- logo-mime.svg -->

	<hgroup>
<h1 id="title">MIME 型の sniff 法 — <span lang="en-x-a0">MIME Sniffing</span></h1>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
MIME Sniffing 標準は、資源の~sniff法を定義する。
【~sniffの原義は “（においを）嗅ぐ（嗅ぎ分ける）” 】
◎
The MIME Sniffing standard defines sniffing resources.
</p>
	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP `Content-Type^h ~headerは、~HTTP応答の~MIME型を指示するために意図されている。
しかしながら，多くの~HTTP~serverは、応答の実際の内容に合致しない値を
`Content-Type^h ~headerに給する。
歴史的に，~web~browserは、そのような~serverを~~追認してきた
— 応答の実質的な~MIME型を決定するために，
`Content-Type^h ~headerに加えて, ~HTTP応答の内容を精査することにより。
◎
The HTTP Content-Type header field is intended to indicate the MIME type of an HTTP response. However, many HTTP servers supply a Content-Type header field value that does not match the actual contents of the response. Historically, web browsers have tolerated these servers by examining the content of HTTP responses in addition to the Content-Type header field in order to determine the effective MIME type of the response.
</p>

<p>
~MIME型をどう “~sniffする” かを与える明瞭な仕様がなければ、各~UAは，［
相互運用性を保守するために，他の~UAの~algoから逆算する（ `reverse-engineer^en ）
］ことを強いられる。
必然的に、これらの労力はどこかで失敗し，~UA間の挙動が分岐する。
一部の事例では、このような挙動の分岐には ~security上の含意がある
— ~UAは、~HTTP応答を~serverが意図したものと異なる~MIME型として解釈し得るので。
◎
Without a clear specification for how to "sniff" the MIME type, each user agent has been forced to reverse-engineer the algorithms of other user agents in order to maintain interoperability. Inevitably, these efforts have not been entirely successful, resulting in divergent behaviors among user agents. In some cases, these divergent behaviors have had security implications, as a user agent could interpret an HTTP response as a different MIME type than the server intended.
</p>

<p>
これらの~security上の課題は、［
“正直” な~serverが、［
悪意的にもなり得る利用者が，自前の~fileを~uploadする
］のを許容していて，そのような~fileの内容を 低特権の~MIME型として~serveする
］ときに最も厳しくなる。
例えば、~serverは［
~clientは、供与された~fileを画像として扱うことになる（したがって，それを無害として扱う）
］ものと予見している一方で、~UAは その内容を~HTMLである（したがって，~scriptを実行する特権を有する）ものと予見する場合、攻撃者は，利用者の認証~資格証を盗んで 他の~XSS攻撃を仕掛けることも可能になり得る。
（無論、悪意的な~serverは， `Content-Type^h ~headerに任意の~MIME型を指定できる。）
◎
These security issues are most severe when an "honest" server allows potentially malicious users to upload their own files and then serves the contents of those files with a low-privilege MIME type. For example, if a server believes that the client will treat a contributed file as an image (and thus treat it as benign), but a user agent believes the content to be HTML (and thus privileged to execute any scripts contained therein), an attacker might be able to steal the user’s authentication credentials and mount other cross-site scripting attacks. (Malicious servers, of course, can specify an arbitrary MIME type in the Content-Type header field.)
</p>

<p>
この文書は、内容を~sniffする~algoを述べる
— それは、~UAの互換性の必要と, 既存の~web内容により課される~security拘束とを，注意深く天秤にかける。
この~algoは、［
`Adam Barth, juan Caballero, Dawn Song^en
］氏により主導された調査に端を発し，［
普及している~UAに備わる，内容を~sniffする~algo ／
既存の~web内容の~~広範な~database ／
相当数の利用者~向けに配備された実装から収集された計測情報
］に基づく。
`SECCONTSNIFF$r
◎
This document describes a content sniffing algorithm that carefully balances the compatibility needs of user agent with the security constraints imposed by existing web content. The algorithm originated from research conducted by Adam Barth, Juan Caballero, and Dawn Song, based on content sniffing algorithms present in popular user agents, an extensive database of existing web content, and metrics collected from implementations deployed to a sizable number of users. [SECCONTSNIFF]
</p>


	</section>
	<section id="conformance-requirements">
<h2 title="Conformance requirements">2. 適合性~要件</h2>

【省略】


	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>


<p>
この仕様は、
Infra Standard に依存する。
`INFRA$r
◎
This specification depends on the Infra Standard. [INFRA]
</p>


<p>
次に挙げる`符号位置$は、
`~HTTP~token符号位置@
とされる
⇒＃
`0021^U,
`0023^U,
`0024^U,
`0025^U,
`0026^U,
`0027^U,
`002A^U,
`002B^U,
`002D^U,
`002E^U,
`005E^U,
`005F^U,
`0060^U,
`007C^U,
`007E^U,
`~ASCII英数字$
◎
An HTTP token code point is U+0021 (!), U+0023 (#), U+0024 ($), U+0025 (%), U+0026 (&amp;), U+0027 ('), U+002A (*), U+002B (+), U+002D (-), U+002E (.), U+005E (^), U+005F (_), U+0060 (`), U+007C (|), U+007E (~), or an ASCII alphanumeric.
</p>


<p class="note">注記：
これは
`quoted-string$P ~token生成規則が成す値~空間に合致する。
`HTTP$r
◎
This matches the value space of the token token production. [HTTP]
</p>

<p>
次に挙げる`符号位置$は、
`~HTTP引用符付き文字列~token符号位置@
とされる
⇒＃
`0009^U0 TAB,
`0020^U0 SPACE 〜 `007E^U,
`0080^U0 〜 `00FF^U
◎
An HTTP quoted-string token code point is U+0009 TAB, a code point in the range U+0020 SPACE to U+007E (~), inclusive, or a code point in the range U+0080 through U+00FF (ÿ), inclusive.
</p>


<p class="note">注記：
これは
`quoted-string$P ~token生成規則が成す
実質的~値~空間に合致する。
定義により、それは
`~HTTP~token符号位置$の上位集合になる。
`HTTP$r
◎
This matches the effective value space of the quoted-string token production. By definition it is a superset of the HTTP token code points. [HTTP]
</p>

<p>
次に挙げる`~byte$は、
`~binary~data~byte@
とされる
⇒
範囲 { `00^X 〜 `1F^X } に入る`~byte$のうち，［
`空白~byte$,
`1B^X (ESCAPE)
］以外のもの
<!-- 
0x00 〜 0x08 (NUL 〜 BS),
0x0B (VT),
0x0E 〜 0x1A (SO 〜 SUB),
0x1C 〜 0x1F ( FS 〜 US)
 -->
◎
A binary data byte is a byte in the range 0x00 to 0x08 (NUL to BS), the byte 0x0B (VT), a byte in the range 0x0E to 0x1A (SO to SUB), or a byte in the range 0x1C to 0x1F (FS to US).
</p>

<p>
次に挙げる`~byte$は、
`空白~byte@
とされる
<!-- （ <abbr>0xWS</abbr> とも略称される）＊未利用  -->
⇒
`09^X (HT),
`0A^X (LF),
`0C^X (FF),
`0D^X (CR),
`20^X (SP)
◎
A whitespace byte (abbreviated 0xWS) is any one of the following bytes: 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP).
</p>

<p>
次に挙げる`~byte$は、
`~tag-terminating~byte@
とされる
— これらは `~tagT^X とも略称される
⇒
`20^X (SP),
`&gt;^lX
◎
A tag-terminating byte (abbreviated 0xTT) is any one of the following bytes: 0x20 (SP), 0x3E ("&gt;").
</p>

<p>
各種 算術~演算に利用される記号（~bAND, ~Rshift, ~MOD, 等々）は
`ENCODING$r にて定義されるそれらと同様とする
【<a href="~ENCODING#terminology">参照</a>】
。
<!-- bitwise NOT は減算で代用 -->
◎
Equations are using the mathematical operators as defined in [ENCODING]. In addition, the bitwise NOT is represented by ~.
</p>


		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（此れ, ~LET, ~ON, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
16進~byte列は、先頭に "0x" を付与して表記される
— 例えば： `00 01 02^X 
（後続する各~byteに対しては、 "0x" は省略される）。
</p>

<p>
%~byte列[ %m `+〜@ %個数 ]
と記された所では、所与の
( `~byte列$ %~byte列, 負でない整数 %m, 負でない整数 %個数 )
に対し，次に従って得られる %~byte列 の部分~byte列を返す：
</p>

<ol>
	<li>
~IF［
%m ~GTE %~byte列 の`長さ$byte
］
⇒
~RET 空~byte列
</li>
	<li>
~RET %~byte列 を成す，［
0 から数えて %m 番の~byte
］から %個数  個まで（ %個数 に満たない場合は %~byte列 の末尾まで）の~byteが成す，同順の`~byte列$
</li>
</ol>

<div class="example">
<p>
例えば［
%~byte列 ~EQ `abc^bl
］ならば
⇒＃
%~byte列[ 1 `+〜$ 1 ] は `b^bl になる ／
%~byte列[ 1 `+〜$ 2 ] は `bc^bl になる ／
%~byte列[ 1 `+〜$ 4 ] も `bc^bl になる ／
%~byte列[ 1 `+〜$ 0 ] は 空~byte列になる
</p>
</div>

<p>
%~byte列[ %m ]
と記された所では、所与の
( `~byte列$ %~byte列, 整数 %m )
に対し，［
0 ~LTE %m ~LT %~byte列 の`長さ$byteならば %~byte列[ %m `+〜$ 1 ] ／
~ELSE_ ε
］を返す。
</p>

		</section>

	</section>
	<section id="understanding-mime-types">
<h2 title="MIME types">4. ~MIME型</h2>

		<section id="mime-type-representation">
<h3 title="MIME type representation">4.1. ~MIME型の表現</h3>

<p>
`~MIME型@
は、
`MIMETYPE$r に定義される `internet media type^en を表現する。
それは、`~MIME型~record$と称されることもある。
◎
A MIME type represents an internet media type as defined by Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. It can also be referred to as a MIME type record. [MIMETYPE]
</p>


<p class="note">注記：
`MEDIAQUERIES$r にて述べられる 媒体~型（ `media type^i ）との混同を避けるため、標準には，用語`~MIME型$を一貫して利用することが奨励される。
◎
Standards are encouraged to consistently use the term MIME type to avoid confusion with the use of media type as described in Media Queries. [MEDIAQUERIES]
</p>

<p>
各 `~MIME型$は、次のものからなる：
</p>

<dl class="def-list">
	<dt>`型@</dt>
	<dd>
空でない`~ASCII文字列$。
◎
A MIME type’s type is a non-empty ASCII string.
</dd>

	<dt>`下位型@</dt>
	<dd>
空でない`~ASCII文字列$。
◎
A MIME type’s subtype is a non-empty ASCII string.
</dd>

	<dt>`~parameter~map@</dt>
	<dd>
`有順序~map$
— その各~entryの［
`~key$map, `値$map
］とも`~ASCII文字列$で与えられる。
初期~時には空とする。
◎
A MIME type’s parameters is an ordered map whose keys and values are ASCII strings. It is initially empty.
</dd>
</dl>

		</section>
		<section id="mime-type-miscellaneous">
<h3 title="MIME type miscellaneous">4.2. ~MIME型そのほか</h3>

<p>
`~MIME型$ %~mime型 の
`~essence@
は、次の連結を返す
⇒＃
%~mime型 の`型$,
`002F^U,
%~mime型 の`下位型$
◎
The essence of a MIME type mimeType is mimeType’s type, followed by U+002F (/), followed by mimeType’s subtype.
</p>

<p>
`~MIME型$
は、次が満たされるならば
`~UAにより~supportされて@
いるとされる
⇒
~UAは［
その`~MIME型$の`資源$を解釈して，それを利用者に呈示する
］能力を備える。
◎
A MIME type is supported by the user agent if the user agent has the capability to interpret a resource of that MIME type and present it to the user.
</p>


<p class="XXX">
これにはもっと作業が必要である。
<a href="https://github.com/w3c/preload/issues/113">w3c/preload #113</a>
を見よ。
◎
This needs more work. See w3c/preload #113.
</p>



		</section>
		<section id="mime-type-writing">
<h3 title="MIME type writing">4.3. ~MIME型の書込法</h3>


<p>
`妥当な~MIME型~文字列@
は、 `media-type$P ~token生成規則に合致する文字列である。
特に，`妥当な~MIME型~文字列$は、`~parameter~map$を含んで~MAY／含み得る。
`RFC7231$r
◎
A valid MIME type string is a string that matches the media-type token production. In particular, a valid MIME type string may include parameters. [RFC7231]
</p>


<p class="note">注記：
`妥当な~MIME型~文字列$を利用するのは、適合性~検査器に限られるものと想定されている。
◎
A valid MIME type string is supposed to be used for conformance checkers only.
</p>

<div class="example">
<p>
`text/html^l は`妥当な~MIME型~文字列$である。
◎
"text/html" is a valid MIME type string.
</p>

<p>
`text/html;^l は`妥当な~MIME型~文字列$でない
— それに`~MIME型を構文解析する$を適用した結果の`~MIME型~record$は、
`text/html^l に適用した結果と一致するが。
◎
"text/html;" is not a valid MIME type string, though parse a MIME type returns a MIME type record for it identical to if the input had been "text/html".
</p>
</div>

<p>
`~parameterを伴わない妥当な~MIME型~文字列@
は、`003B^U を包含しない
`妥当な~MIME型~文字列$である。
◎
A valid MIME type string with no parameters is a valid MIME type string that does not contain U+003B (;).
</p>



		</section>
		<section id="parsing-a-mime-type">
<h3 title="Parsing a MIME type">4.4. ~MIME型の構文解析-法</h3>


<p class="algo-head">
`~MIME型を構文解析する@
ときは、所与の
( 文字列 %入力 )
に対し，次の手続きを走らす：
◎
To parse a MIME type, given a string input, run these steps:
</p>

<ol>
	<li>
%入力 から頭部, 尾部を成す`~ASCII空白$並びを除去する
◎
Remove any leading and trailing ASCII whitespace from input.
</li>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%型 ~LET 
%入力 内の %位置 から `002F^U 以外の`符号位置~並びを収集する$
◎
Let type be the result of collecting a sequence of code points that are not U+002F (/) from input, given position.
</li>
	<li>
~IF［
%型 ~EQ 空~文字列
］~OR［
%型 を成す符号位置に`~HTTP~token符号位置$でないものがある
］
⇒
~RET `失敗^i
◎
If type is the empty string or does not solely contain HTTP token code points, then return failure.
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET `失敗^i
◎
If position is past the end of input, then return failure.
</li>
	<li>
%位置 ~INCBY 1
（これは `002F^U を飛ばす。）
◎
Advance position to the next code point in input. (This skips past U+002F (/).)
</li>
	<li>
%下位型 ~LET
%入力 内の %位置 から`003B^U 以外の`符号位置~並びを収集する$
◎
Let subtype be the result of collecting a sequence of code points that are not U+003B (;) from input, given position.
</li>
	<li>
%下位型 から尾部を成す`~ASCII空白$並びを除去する
◎
Remove any trailing ASCII whitespace from subtype.
</li>
	<li>
~IF［
%下位型 ~EQ 空~文字列
］~OR［
%下位型 を成す符号位置に`~HTTP~token符号位置$でないものがある
］
⇒
~RET `失敗^i
◎
If subtype is the empty string or does not solely contain HTTP token code points, then return failure.
</li>
	<li>
%~mime型 ~LET 次のようにされた新たな`~MIME型~record$
⇒＃
`型$ ~SET `~ASCII小文字~化する$( %型 ),
`下位型$ ~SET `~ASCII小文字~化する$( %下位型 )
◎
Let mimeType be a new MIME type record whose type is type, in ASCII lowercase, and subtype is subtype, in ASCII lowercase.
</li>
	<li>
<p>
~WHILE［
%位置 ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%位置 ~INCBY 1
（これは `003B^U  を飛ばす。）
◎
Advance position to the next code point in input. (This skips past U+003B (;).)
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
			<li>
%~parameter名 ~LET 
%入力 内の %位置 から
{ `003B^U, `003D^U }
以外の`符号位置~並びを収集する$
◎
Let parameterName be the result of collecting a sequence of code points that are not U+003B (;) or U+003D (=) from input, given position.
</li>
			<li>
%~parameter名 ~SET `~ASCII小文字~化する$( %~parameter名 )
◎
Set parameterName to parameterName, in ASCII lowercase.
◎
If position is not past the end of input, then:
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~BREAK
◎
↓↓</li>
			<li>
~IF［
%位置↗ ~EQ `003B^U
］
⇒
~CONTINUE
◎
If the code point at position within input is U+003B (;), then continue.
</li>
			<li>
%位置 ~INCBY 1
（これは `003D^U を飛ばす。）
◎
Advance position to the next code point in input. (This skips past U+003D (=).)
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~BREAK
◎
↓↓</li>
			<li>
%~parameter値 ~LET 空~文字列
◎
Let parameterValue be the empty string.
◎
If position is not past the end of input, then:
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `0022^U
］：
◎
If the code point at position within input is U+0022 ("), then:
</p>
				<ol>
					<li>
<p>
~WHILE 無条件：
</p>
						<ol>
							<li>
%位置 ~INCBY 1
</li>
							<li>
%~parameter値 に次の結果を付加する
⇒
%入力 内の %位置 から
{ `0022^U, `005C^U }
以外の`符号位置~並びを収集する$
</li>
							<li>
~IF［
%位置↗ ~NEQ `005C^U
］
⇒
~BREAK
</li>
							<li>
%位置 ~INCBY 1
</li>
							<li>
<p>
~IF［
%位置↗ ~EQ ε
］
⇒＃
%~parameter値 に `005C^U を付加する；
~BREAK
</li>
							<li>
%~parameter値 に %位置↗ を付加する
</li>
						</ol>
◎
Advance position to the next code point in input.
◎
While true:
• Append the result of collecting a sequence of code points that are not U+0022 (") or U+005C (\) from input, given position, to parameterValue.
• If position is not past the end of input and the code point at position within input is U+005C (\), then:
• Advance position to the next code point in input.
• If position is not past the end of input, then:
•• Append the code point at position within input to parameterValue.
•• Advance position to the next code point in input.
•• Continue.
• Otherwise, append U+005C (\) to parameterValue and break.
• Otherwise, break.
</li>
					<li>
<p>
%入力 内の %位置 から
`003B^U 以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not U+003B (;) from input, given position.
</p>

<p class="example">
`text/html;charset="shift_jis"iso-2022-jp^mt
が与えられた場合の結果は、
`text/html;charset=shift_jis^mt
になる。
◎
Given text/html;charset="shift_jis"iso-2022-jp you end up with text/html;charset=shift_jis.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~parameter値 ~SET 
%入力 内の %位置 から `003B^U 以外の`符号位置~並びを収集する$
◎
Set parameterValue to the result of collecting a sequence of code points that are not U+003B (;) from input, given position.
</li>
					<li>
%~parameter値 から尾部を成す`~ASCII空白$並びを除去する
◎
Remove any trailing ASCII whitespace from parameterValue.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
次のすべてが満たされる
］…：
◎
If all of the following are true
</p>
				<ul class="brief">
					<li>
%~parameter名 ~NEQ 空~文字列
◎
parameterName is not the empty string
</li>
					<li>
%~parameter値 ~NEQ 空~文字列
◎
parameterValue is not the empty string
</li>
					<li>
%~parameter名 を成すどの符号位置も`~HTTP~token符号位置$である
◎
parameterName solely contains HTTP token code points
</li>
					<li>
%~parameter値 を成すどの符号位置も`~HTTP引用符付き文字列~token符号位置$である
◎
parameterValue solely contains HTTP quoted-string token code points
</li>
					<li>
%~mime型 の`~parameter~map$[ %~parameter名 ] ~EQ  ε
◎
mimeType’s parameters[parameterName] does not exist
</li>
				</ul>
<p>
…ならば
⇒
%~mime型 の`~parameter~map$[ %~parameter名 ] ~SET %~parameter値
◎
then set mimeType’s parameters[parameterName] to parameterValue.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %~mime型
◎
Return mimeType.
</li>
</ol>


<hr>

<p class="algo-head">
`~byte列から~MIME型を構文解析する@
ときは、所与の
( `~byte列$ %入力 )
に対し，次の手続きを走らす：
◎
To parse a MIME type from bytes, given a byte sequence input, run these steps:
</p>

<ol>
	<li>
%文字列 ~LET `同型に復号する$( %入力 )
◎
Let string be input, isomorphic decoded.
</li>
	<li>
~RET `~MIME型を構文解析する$( %文字列 )
◎
Return the result of parse a MIME type with string.
</li>
</ol>

		</section>
		<section id="serializing-a-mime-type">
<h3 title="Serializing a MIME type">4.5. ~MIME型の直列化-法</h3>

<p class="algo-head">
`~MIME型を直列化する@
ときは、所与の
( `~MIME型$ %~mime型 )
に対し，次の手続きを走らす：
◎
To serialize a MIME type, given a MIME type mimeType, run these steps:
</p>

<ol>
	<li>
%直列化 ~LET 空~文字列
◎
↓</li>
	<li>
%直列化 に次を順に付加する
⇒＃
%~mime型 の`型$,
`002F^U,
%~mime型 の`下位型$
◎
Let serialization be the concatenation of mimeType’s type, U+002F (/), and mimeType’s subtype.
</li>
	<li>
<p>
%~mime型 の`~parameter~map$を成す~EACH( %名 → %値 ) に対し：
◎
For each name → value of mimeType’s parameters:
</p>
		<ol>
			<li>
%直列化 に次を順に付加する
⇒＃
`003B^U,
%名,
`003D^U
◎
Append U+003B (;) to serialization.
◎
Append name to serialization.
◎
Append U+003D (=) to serialization.
</li>
			<li>
<p>
~IF［
%値 を成す符号位置に`~HTTP~token符号位置$でないものがある
］：
</p>
				<ol>
					<li>
%直列化 に `0022^U を付加する
</li>
					<li>
<p>
%値 を成す ~EACH( 符号位置 %C ) に対し，順に：
</p>
						<ol>
							<li>
~IF［
%C ~IN { `0022^U, `005C^U }
］
⇒
%直列化 に `005C^U を付加する
<!-- ＊原文誤 005A  -->
</li>
							<li>
%直列化 に %C を付加する
</li>
						</ol>
					</li>
					<li>
%直列化 に `0022^U を付加する
</li>
				</ol>
◎
If value does not solely contain HTTP token code points:
• Precede each occurence of U+0022 (") or U+005C (\) in value with U+005A (\).
• Prepend U+0022 (") to value.
• Append U+0022 (") to value.
</li>
			<li>
~ELSE
⇒
%直列化 に %値 を付加する
◎
Append value to serialization.
</li>
		</ol>
	</li>
	<li>
~RET %直列化
◎
Return serialization.
</li>
</ol>

<hr>

<p class="algo-head">
`~MIME型を~byte列に直列化する@
ときは、所与の
( `~MIME型$ %~mime型 )
に対し，次の結果を返す
⇒
`同型に符号化する$( `~MIME型を直列化する$( %~mime型 ) )
◎
To serialize a MIME type to bytes, given a MIME type mimeType, run these steps:
• Let stringSerialization be the result of serialize a MIME type with mimeType.
• Return stringSerialization, isomorphic encoded.
</p>

		</section>
		<section id="mime-type-groups">
<h3 title="MIME type groups">4.6. ~MIME型の~group分け</h3>

<p>
次を満たす`~MIME型$は、
`画像~MIME型@
とされる
⇒
`型$ ~EQ `image^l
◎
An image MIME type is a MIME type whose type is "image".
</p>

<p>
次のいずれかを満たす`~MIME型$は、
`音声動画~MIME型@
とされる
⇒＃
`型$ ~IN { `audio^l, `video^l } ／
`~essence$ ~EQ `application/ogg^l
◎
An audio or video MIME type is any MIME type whose type is "audio" or "video", or whose essence is "application/ogg".
</p>


<p>
次を満たす`~MIME型$は、
`~font~MIME型@
とされる
⇒
［
`型$ ~EQ `font^l
］~OR［
`~essence$ ~IN { 次に挙げる文字列 } `RFC8081$r
］
◎
A font MIME type is any MIME type whose type is "font", or whose essence is one of the following: [RFC8081]
</p>

<ul><li>`application/font-cff^l
</li><li>`application/font-off^l
</li><li>`application/font-sfnt^l
</li><li>`application/font-ttf^l
</li><li>`application/font-woff^l
</li><li>`application/vnd.ms-fontobject^l
</li><li>`application/vnd.ms-opentype^l
</li></ul>

<p>
次のいずれかを満たす`~MIME型$は、
`~ZIPに基づく~MIME型@
とされる
⇒＃
`下位型$は `+zip^l で終端する ／
`~essence$ ~IN { 次に挙げる文字列 }
◎
A ZIP-based MIME type is any MIME type whose subtype ends in "+zip" or whose essence is one of the following:
</p>

<ul class="XXX">
<li>`application/zip^l
</li></ul>


<p>
次を満たす`~MIME型$は、
`~archive~MIME型@
とされる
⇒
`~essence$ ~IN { 次に挙げる文字列 }
◎
An archive MIME type is any MIME type whose essence is one of the following:
</p>

<ul><li>`application/x-rar-compressed^l
</li><li>`application/zip^l
</li><li>`application/x-gzip^l
</li></ul>

<p>
次のいずれかを満たす`~MIME型$は、
`~XML~MIME型@
とされる
⇒＃
`下位型$は `+xml^l で終端する ／
`~essence$ ~IN { `text/xml^l, `application/xml^l } `RFC7303$r
◎
An XML MIME type is any MIME type whose subtype ends in "+xml" or whose essence is "text/xml" or "application/xml". [RFC7303]
</p>


<p>
次を満たす`~MIME型$は、
`~HTML~MIME型@
とされる
⇒
`~essence$ ~EQ `text/html^l
◎
An HTML MIME type is any MIME type whose essence is "text/html".
</p>

<p>
次のいずれかを満たす`~MIME型$は、
`~script可能~MIME型@
とされる
⇒＃
`~XML~MIME型$である ／
`~HTML~MIME型$である ／
`~essence$ ~EQ `application/pdf^l
◎
A scriptable MIME type is an XML MIME type, HTML MIME type, or any MIME type whose essence is "application/pdf".
</p>

<p>
次を満たす`~MIME型$は、
`~JS~MIME型@
とされる
⇒
`~essence$ ~IN { 次に挙げる文字列 }
◎
A JavaScript MIME type is any MIME type whose essence is one of the following:
</p>

<ul ><li>`application/ecmascript^l
</li><li>`application/javascript^l
</li><li>`application/x-ecmascript^l
</li><li>`application/x-javascript^l
</li><li>`text/ecmascript^l
</li><li>`text/javascript^l
</li><li>`text/javascript1.0^l
</li><li>`text/javascript1.1^l
</li><li>`text/javascript1.2^l
</li><li>`text/javascript1.3^l
</li><li>`text/javascript1.4^l
</li><li>`text/javascript1.5^l
</li><li>`text/jscript^l
</li><li>`text/livescript^l
</li><li>`text/x-ecmascript^l
</li><li>`text/x-javascript^l
</li></ul>


<p>
次を満たす`文字列$は
`~JS~MIME型に~essence合致-@
するとされる
⇒
上に挙げた`~JS~MIME型$用の~essence文字列のいずれかに`~ASCII大小無視$で合致する
◎
A string is a JavaScript MIME type essence match if it is an ASCII case-insensitive match for one of the JavaScript MIME type essence strings.
</p>


<p class="note">注記：
この~hookは、 `script$e 要素の `type$a 属性により利用される。
◎
This hook is used by the type attribute of script elements.
</p>

<p>
次のいずれかを満たす`~MIME型$は、
`~JSON~MIME型@
とされる
⇒＃
`下位型$は ~EQ `+json^l で終端する／
`~essence$ ~IN { `application/json^l, `text/json^l }
◎
A JSON MIME type is any MIME type whose subtype ends in "+json" or whose essence is "application/json" or "text/json". 
</p>


		</section>
	</section>
	<section id="handling-a-resource">
<h2 title="Handling a resource">5. 資源の取扱い</h2>


<p class="XXX">
`資源@
とは…
【この仕様の文脈においては、概ね，~HTTP応答の本体と考えればよいであろう。】
◎
A resource is ….
</p>

<p>
~UAは，自身が取扱う各 `資源$に対し、次に挙げる~metadataを結付けた上で，保ち続け~MUST：
◎
For each resource it handles, the user agent must keep track of the following associated metadata:
</p>

<dl>
	<dt>`給された~MIME型@</dt>
	<dd>
`給された~MIME型を検出する~algo$により決定される`~MIME型$。
◎
A supplied MIME type, the MIME type determined by the supplied MIME type detection algorithm.
</dd>

	<dt>`~Apache~bug用~検査~flag@</dt>
	<dd>
既定では ~OFF とする。
◎
A check-for-apache-bug flag, which defaults to unset.
</dd>

	<dt>`~sniffなし~flag@</dt>
	<dd>
~UAが`資源$に対する~sniffingを遂行したいと望まない場合、既定で ~ON になる。
他の場合、~OFF になる。
◎
A no-sniff flag, which defaults to set if the user agent does not wish to perform sniffing on the resource and unset otherwise.
</dd>
	<dd class="note">注記：
~UAは、［
特定0の`資源$に対し，~sniffingを~opt-outする【任意選択で外す】かどうか
］を決定する際に［
~siteにおける以前の経験など，外側の情報
］を利用することも選べる。
~UAは、すべての`資源$に対し~sniffingを~opt-outすることも選べる。
しかしながら，~sniffingを~opt-outしても、~UAは，`~MIME型を~sniffする~algo$を利用することから免除されるわけではない。
◎
The user agent can choose to use outside information, such as previous experience with a site, to determine whether to opt out of sniffing for a particular resource. The user agent can also choose to opt out of sniffing for all resources. However, opting out of sniffing does not exempt the user agent from using the MIME type sniffing algorithm.
</dd>

	<dt>`算出される~MIME型@</dt>
	<dd>
`~MIME型を~sniffする~algo$により決定される`~MIME型$。
◎
A computed MIME type, the MIME type determined by the MIME type sniffing algorithm.
</dd>
</dl>


		<section id="interpreting-the-resource-metadata">
<h3 title="Interpreting the resource metadata">5.1. 資源~metadataの解釈-法</h3>

<p>
`資源$ %資源 に`給された~MIME型$は、
%資源 に結付けられている外部の源から~UAに供される。
この情報の得方は、 %資源 がどう検索取得されたかに依存して変わる。
◎
The supplied MIME type of a resource is provided to the user agent by an external source associated with that resource. The method of obtaining this information varies depending upon how the resource is retrieved.
</p>

<p class="algo-head">
~UAは，`資源$ %資源 に`給された~MIME型$を決定するときは、次に与える
`給された~MIME型を検出する~algo@
を利用し~MUST
— それは［
`~MIME型$, ε（未定義）
］のいずれかを返す：
◎
To determine the supplied MIME type of a resource, user agents must use the following supplied MIME type detection algorithm:
</p>

<ol>
	<li>
%給された型 ~LET ε <!-- ＊~NULL -->
◎
Let supplied-type be null.
</li>
	<li>
<p>
~IF［
%資源 は~HTTPを介して検索取得された
］：
◎
If the resource is retrieved via HTTP, execute the following steps:
</p>
		<ol>
			<li>
<p>
~IF［
%資源 には 1 個~以上の `Content-Type^h ~headerが結付けられている
］：
◎
If one or more Content-Type headers are associated with the resource, execute the following steps:
</p>
				<ol>
					<li>
<p>
%給された型 ~SET  %資源 に結付けられている最後の `Content-Type^h ~headerの値
◎
Set supplied-type to the value of the last Content-Type header associated with the resource.
</p>

<p class="note">注記：
~file拡張子は、~HTTPを介して検索取得された %資源 に`給された~MIME型$を決定するときには，利用されない
— 容易に偽装されるので、それらには依拠できない。
◎
File extensions are not used to determine the supplied MIME type of a resource retrieved via HTTP because they are unreliable and easily spoofed.
</p>
					</li>
					<li>
<p>
~IF［
%給された型 ~IN { 次に挙げる値 }
］…：
◎
Set the check-for-apache-bug flag if supplied-type is exactly equal to one of the values in the following table:
</p>

<div >
<ul ><li>`text/plain^lX
</li><li>`text/plain; charset=ISO-8859-1^lX
</li><li>`text/plain; charset=iso-8859-1^lX
</li><li>`text/plain; charset=UTF-8^lX
</li></ul>

<p>
…ならば
⇒
`~Apache~bug用~検査~flag$ ~SET ~ON
</p>

◎
Bytes in Hexadecimal 	Bytes in ASCII
◎
74 65 78 74 2F 70 6C 61 69 6E 	text/plain
◎
74 65 78 74 2F 70 6C 61 69 6E
3B 20 63 68 61 72 73 65 74 3D
49 53 4F 2D 38 38 35 39 2D 31 	text/plain; charset=ISO-8859-1
◎
74 65 78 74 2F 70 6C 61 69 6E
3B 20 63 68 61 72 73 65 74 3D
69 73 6F 2D 38 38 35 39 2D 31 	text/plain; charset=iso-8859-1
◎
74 65 78 74 2F 70 6C 61 69 6E
3B 20 63 68 61 72 73 65 74 3D
55 54 46 2D 38 	text/plain; charset=UTF-8
</div>


<p class="note">注記：
`給された~MIME型を検出する~algo$は、これらに正確に一致する`~byte列$を検出する
— 一部の古い~Apacheには
<a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=13986">~bugがあり</a>、
`~MIME型$を認識できない~fileを~serveするときに、これらいずれかの `Content-Type^h ~headerを給するので。
◎
The supplied MIME type detection algorithm detects these exact byte sequences because some older installations of Apache contain a bug that causes them to supply one of these Content-Type headers when serving files with unrecognized MIME types.
</p>
					</li>
				</ol>
			</li>
		</ol>

<p>
`HTTP$r
◎
[HTTP]
</p>
	</li>
	<li>
~IF［
%資源 は ~file~systemから直に検索取得された
］
⇒
%給された型 ~SET ~file~systemにより供される`~MIME型$
◎
If the resource is retrieved directly from the file system, set supplied-type to the MIME type provided by the file system.
</li>
	<li>
~IF［
%資源 は 別の~protocol（~FTP `FTP$r など）を介して検索取得された
］~AND［
その~protocolにより決定される`~MIME型$ %型 はある
］
⇒
%給された型 ~SET %型
◎
If the resource is retrieved via another protocol (such as FTP), set supplied-type to the MIME type as determined by that protocol, if any.
[FTP]
</li>
	<li>
~IF［
%給された型 は`~MIME型$でない
］
⇒
~RET ε （“未定義”）
◎
If supplied-type is not a MIME type, the supplied MIME type is undefined.
◎
Abort these steps.
</li>
	<li>
~RET %給された型
◎
The supplied MIME type is supplied-type.
</li>
</ol>



		</section>
		<section id="reading-the-resource-header">
<h3 title="Reading the resource header">5.2. 資源~headerの読取法</h3>


<p>
`資源~header@
は、`資源~headerを読取る$ことにより決定される，`資源$の冒頭部を成す`~byte列$である。
◎
A resource header is the byte sequence at the beginning of a resource, as determined by reading the resource header.
</p>

<p class="algo-head">
`資源~headerを読取る@
ときは、次の手続きを遂行する：
◎
To read the resource header, perform the following steps:
</p>

<ol>
	<li>
%~buffer ~LET 空`~byte列$
◎
Let buffer be a byte sequence.
</li>
	<li>
<p>
次のいずれかの条件が満たされるまで、`資源$を成す`~byte列$を %~buffer の中に読取る：
◎
Read bytes of the resource into buffer until one of the following conditions is met:
</p>

		<ul>
			<li>
`資源$の終端まで達した
◎
the end of the resource is reached.
</li>
			<li>
%~buffer の`長さ$byte ~GTE 1445
◎
the number of bytes in buffer is greater than or equal to 1445.
</li>
			<li>
~UAにより決定される適度な時間だけ経過した
◎
a reasonable amount of time has elapsed, as determined by the user agent.
</li>
		</ul>
<p class="note">注記：
［
%~buffer の`長さ$byte ~GTE 1445
］の場合、`~MIME型を~sniffする~algo$は，大方の事例において決定的になる。
しかしながら，ある種の要因（低速な接続など）により、~UAは適度な時間~内に 1445 `~byte$を読取れないこともある。
◎
If the number of bytes in buffer is greater than or equal to 1445, the MIME type sniffing algorithm will be deterministic for the majority of cases.
◎
However, certain factors (such as a slow connection) may prevent the user agent from reading 1445 bytes in a reasonable amount of time.
</p>
	</li>
	<li>
~RET %~buffer
◎
The resource header is buffer.
</li>
</ol>

<p class="note">注記：
`資源~header$を決定する必要があるのは、`資源$ごとに一回に限られる。
◎
The resource header need only be determined once per resource.
</p>

		</section>
	</section>
	<section id="matching-a-mime-type-pattern">
<h2 title="Matching a MIME type pattern">6. ~MIME型~patternとの照合</h2>

<p>
`~byte~pattern@
は、`~pattern照合~algo$内で，照合-用の~templateとして利用される`~byte列$である。
◎
A byte pattern is a byte sequence used as a template to be matched against in the pattern matching algorithm.
</p>


<p>
`~pattern~mask@
は、［
`~pattern照合~algo$内である`~byte~pattern$と比較されている`~byte列$
］の有意度を決定するために利用される`~byte列$である
◎
A pattern mask is a byte sequence used to determine the significance of bytes being compared against a byte pattern in the pattern matching algorithm.
</p>


<p class="note">注記：
`~pattern~mask$における［
`FF^X は `~byte$は 厳密比較で有意である／
`DF^X は `~byte$は ~ASCII大小無視で有意である／
`00^X は `~byte$は 有意でない
］ことを指示する。
◎
In a pattern mask, 0xFF indicates the byte is strictly significant, 0xDF indicates that the byte is significant in an ASCII case-insensitive way, and 0x00 indicates that the byte is not significant.
</p>

<p class="algo-head">
次に与える
`~pattern照合~algo@
は、［
所与の`~byte列$が，特定0の`~byte~pattern$に合致するかどうか
］を決定するときに利用される
— それは、所与の (
`~byte列$ %入力,
`~byte~pattern$ %~pattern,
`~pattern~mask$ %~mask,
`~byte$の`集合$ %無視される集合
) に対し，［
~T ／ ~F
］を返す：
◎
To determine whether a byte sequence matches a particular byte pattern, use the following pattern matching algorithm. It is given a byte sequence input, a byte pattern pattern, a pattern mask mask, and a set of bytes to be ignored ignored, and returns true or false.
</p>

<ol>
	<li>
%L ~LET %~pattern の`長さ$byte
◎
↓</li>
	<li>
~Assert：
%L ~EQ %~mask の`長さ$byte
◎
Assert: pattern’s length is equal to mask’s length.
◎
↓↓If input’s length is less than pattern’s length, return false.
</li>
	<li>
%s ~LET  0
◎
Let s be 0.
</li>
	<li>
<p>
~WHILE［
%s ~LT %入力 の`長さ$byte
］：
◎
While s &lt; input’s length:
</p>
		<ol>
			<li>
~IF［
%入力[ %s ] ~NIN %無視される
］
⇒
~BREAK
◎
If ignored does not contain input[s], break.
</li>
			<li>
%s ~INCBY 1
◎
Set s to s + 1.
</li>
		</ol>
	</li>
	<li>
%入力 ~SET %入力[ %s `+〜$ %L ]
◎
↓</li>
	<li>
<p>
~IF［
%入力 の`長さ$byte ~LT %L
］
⇒
~RET ~F
</p>
【原文は、この段に相当する検査を上の ~WHILE 段の前に行なっているが，明らかにおかしいので~algoを修正している。】
◎
↑↑</li>
	<li>
~RET ［
どの整数 %p ~IN { 0 〜 %L ~MINUS 1 } に対しても 次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
( %入力[ %p ] ~bAND %~mask[ %p ] ) ~EQ %~pattern[ %p ]
◎
Let p be 0.
◎
While p &lt; pattern’s length:
• Let maskedData be the result of applying the bitwise AND operator to input[s] and mask[p].
• If maskedData is not equal to pattern[p], return false.
• Set s to s + 1.
• Set p to p + 1.
◎
Return true.
</li>
</ol>

		<section id="matching-an-image-type-pattern">
<h3 title="Matching an image type pattern">6.1. 画像~型~patternとの照合</h3>

<p class="algo-head">
次に与える
`画像~型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`画像~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which image MIME type byte pattern a byte sequence input matches, if any, use the following image type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表内の~EACH( ~row %~row ) に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致した ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致した ~EQ ~T
］
⇒
~RET %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>

<table><thead><tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`画像~MIME型$
<tr><th class="note" colspan="4">注記
</thead><tbody>

<tr><td>`00 00 01 00^X
<td>`FF FF FF FF^X
<td>なし
<td>`image/x-icon^mt
<tr><td class="note" colspan="4">
`Windows Icon^i 符丁
◎
A Windows Icon signature.

<tr><td>`00 00 02 00^X
<td>`FF FF FF FF^X
<td>なし
<td>`image/x-icon^mt
<tr><td class="note" colspan="4">
`Windows Cursor^i 符丁
◎
A Windows Cursor signature.

<tr><td>`42 4D^X
<td>`FF FF^X
<td>なし
<td>`image/bmp^mt
<tr><td class="note" colspan="4">
`BMP^i 符丁を表す， `BM^l
◎
The string "BM", a BMP signature.

<tr><td>`47 49 46 38 37 61^X
<td>`FF FF FF FF FF FF^X
<td>なし
<td>`image/gif^mt
<tr><td class="note" colspan="4">
`GIF^i 符丁を表す， `GIF87a^bl
◎
The string "GIF87a", a GIF signature.

<tr><td>`47 49 46 38 39 61^X
<td>`FF FF FF FF FF FF^X
<td>なし
<td>`image/gif^mt
<tr><td class="note" colspan="4">
`GIF^i 符丁を表す， `GIF89a^bl
◎
The string "GIF89a", a GIF signature.

<tr><td>`52 49 46 46 00 00 00 00 57 45 42 50 56 50^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF FF FF^X
<td>なし
<td>`image/webp^mt
<tr><td class="note" colspan="4">
次の連結：
`RIFF^bl,
4 個の`~byte$,
`WEBPVP^bl
◎
The string "RIFF" followed by four bytes followed by the string "WEBPVP".

<tr><td>`89 50 4E 47 0D 0A 1A 0A^X
<td>`FF FF FF FF FF FF FF FF^X
<td>なし
<td>`image/png^mt
<tr><td class="note" colspan="4">
`PNG^i 符丁を表す，次の連結：
1 個の~error検査-用`~byte$,
`PNG^bl,
`CR^smb,
`LF^smb,
`SUB^smb,
`LF^smb
◎
An error-checking byte followed by the string "PNG" followed by CR LF SUB LF, the PNG signature.

<tr><td>`FF D8 FF^X
<td>`FF FF FF^X
<td>なし
<td>`image/jpeg^mt
<tr><td class="note" colspan="4">
次の連結：
`JPEG Start of Image^i ~marker,
別の~markerの指示子を成す 1 個の`~byte$
◎
The JPEG Start of Image marker followed by the indicator byte of another marker.
</tbody></table></li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>



		</section>
		<section id="matching-an-audio-or-video-type-pattern">
<h3 title="Matching an audio or video type pattern">6.2. 音声動画~型~patternとの照合</h3>


<p class="algo-head">
次に与える
`音声動画~型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`音声動画~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which audio or video MIME type byte pattern a byte sequence input matches, if any, use the following audio or video type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表内の~EACH( ~row %~row ) に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致した ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致した ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>

<table><thead><tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$
<th>`音声動画~MIME型$
<tr><th class="note" colspan="4">注記
</thead><tbody>

<tr><td>`2E 73 6E 64^X
<td>`FF FF FF FF^X
<td>なし
<td>`audio/basic^mt
<tr><td class="note" colspan="4">
基本的な音声符丁を表す， `.snd^bl
◎
The string ".snd", the basic audio signature.

<tr><td>`46 4F 52 4D 00 00 00 00 41 49 46 46^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF^X
<td>なし
<td>`audio/aiff^mt
<tr><td class="note" colspan="4">
`AIFF^i 符丁を表す，次の連結：
`FORM^bl
4 個の`~byte$,
`AIFF^bl
◎
The string "FORM" followed by four bytes followed by the string "AIFF", the AIFF signature.

<tr><td>`49 44 33^X
<td>`FF FF FF^X
<td>なし
<td>`audio/mpeg^mt
<tr><td class="note" colspan="4">
`ID3v2-tagged MP3^i 符丁を表す， `ID3^bl
◎
The string "ID3", the ID3v2-tagged MP3 signature.

<tr><td>`4F 67 67 53 00^X
<td>`FF FF FF FF FF^X
<td>なし
<td>`application/ogg^mt
<tr><td class="note" colspan="4">
`Ogg container^i 符丁を表す，次の連結：
`OggS^bl,
`NUL^smb
◎
The string "OggS" followed by NUL, the Ogg container signature.

<tr><td>`4D 54 68 64 00 00 00 06^X
<td>`FF FF FF FF FF FF FF FF^X
<td>なし
<td>`audio/midi^mt
<tr><td class="note" colspan="4">
`MIDI^i 符丁を表す，次の連結：
`MThd^bl,
32 ~bit（~big-endian）で数 6 を表現している 4 個の`~byte$
◎
The string "MThd" followed by four bytes representing the number 6 in 32 bits (big-endian), the MIDI signature.

<tr><td>`52 49 46 46 00 00 00 00 41 56 49 20^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF^X
<td>なし
<td>`video/avi^mt
<tr><td class="note" colspan="4">
`AVI^i 符丁を表す，次の連結：
`RIFF^bl,
4 個の`~byte$,
`AVI ^bl
◎
The string "RIFF" followed by four bytes followed by the string "AVI ", the AVI signature.

<tr><td>`52 49 46 46 00 00 00 00 57 41 56 45^X
<td>`FF FF FF FF 00 00 00 00 FF FF FF FF^X
<td>なし
<td>`audio/wave^mt
<tr><td class="note" colspan="4">
`WAVE^i 符丁を表す，次の連結：
`RIFF^bl,
4 個の`~byte$,
`WAVE^bl
◎
The string "RIFF" followed by four bytes followed by the string "WAVE", the WAVE signature.
</tbody></table>

	</li>
	<li>
~IF［
%入力 は`~MP4用の符丁に合致する$
］
⇒
~RET  `video/mp4^l
◎
If input matches the signature for MP4, return "video/mp4".
</li>
	<li>
~IF［
%入力 は`~WebM用の符丁に合致する$
］
⇒
~RET  `video/webm^l
◎
If input matches the signature for WebM, return "video/webm".
</li>
	<li>
~IF［
%入力 は`~ID3なしの~MP3用の符丁に合致する$
］
⇒
~RET  `audio/mpeg^l
◎
If input matches the signature for MP3 without ID3, return "audio/mpeg".
</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>



			</section>
			<section id="signature-for-mp4">
<h4 title="Signature for MP4">6.2.1. ~MP4用の符丁</h4>


<p class="algo-head">
`~MP4用の符丁に合致する@
かどうか決定するときは、所与の
( `~byte列$ %~byte列 )
に対し，次の手続きを利用する：
◎
To determine whether a byte sequence matches the signature for MP4, use the following steps:
• Let sequence be the byte sequence to be matched, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<ol>
	<li>
%長さ ~LET %~byte列 の`長さ$byte
◎
Let length be the number of bytes in sequence.
</li>
	<li>
~IF［
%長さ ~LT 12
］
⇒
~RET ~F
◎
If length is less than 12, return false.
</li>
	<li>
%~box~size ~LET
%~byte列[ 0 `+〜$ 3 ]
を~big-endianによる無符号 32-bit 整数に解釈した結果
◎
Let box-size be the four bytes from sequence[0] to sequence[3], interpreted as a 32-bit unsigned big-endian integer.
</li>
	<li>
~IF［
%長さ ~LT %~box~size
］~OR［
%~box~size ~MOD 4  ~NEQ 0
］
⇒
~RET ~F
◎
If length is less than box-size or if box-size modulo 4 is not equal to 0, return false.
</li>
	<li>
~IF［
%~byte列[ 4 `+〜$ 4 ] ~NEQ `ftyp^lX
］
⇒
~RET ~F
◎
If the four bytes from sequence[4] to sequence[7] are not equal to 0x66 0x74 0x79 0x70 ("ftyp"), return false.
</li>
	<li>
~IF［
%~byte列[ 8 `+〜$ 3 ] ~EQ `mp4^lX
］
⇒
~RET ~T
◎
If the three bytes from sequence[8] to sequence[10] are equal to 0x6D 0x70 0x34 ("mp4"), return true.
</li>
	<li>
<p>
%読取った~byte数 ~LET  16
◎
Let bytes-read be 16.
</p>

<p class="note">注記：
これは、
“`major brand^en” を成す~version番号に対応する 4 個の `~byte$を無視する。
◎
This ignores the four bytes that correspond to the version number of the "major brand".
</p>
	</li>
	<li>
<p>
~WHILE［
%読取った~byte数 ~LT %~box~size
］：
◎
While bytes-read is less than box-size, continuously loop through these steps:
</p>
		<ol>
			<li>
~IF［
%~byte列[ %読取った~byte数 `+〜$ 3 ] ~EQ `mp4^lX
］
⇒
~RET ~T
◎
If the three bytes from sequence[bytes-read] to sequence[bytes-read + 2] are equal to 0x6D 0x70 0x34 ("mp4"), return true.
</li>
			<li>
%読取った~byte数 ~INCBY 4
◎
Increment bytes-read by 4.
</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

			</section>
			<section id="signature-for-webm">
<h4 title="Signature for WebM">6.2.2. ~WebM用の符丁</h4>

<p class="algo-head">
`~WebM用の符丁に合致する@
かどうか決定するときは、所与の
( `~byte列$ %~byte列 )
に対し，次の手続きを利用する：
◎
To determine whether a byte sequence matches the signature for WebM, use the following steps:
• Let sequence be the byte sequence to be matched, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<p class="trans-note">【
以下，この~algoの内容は、未訳。
】</p>

			</section>
			<section id="signature-for-mp3-without-id3">
<h4 title="Signature for MP3 without ID3">6.2.3. ~ID3なしの~MP3用の符丁</h4>

<p class="algo-head">
`~ID3なしの~MP3用の符丁に合致する@
かどうか決定するときは、所与の
( `~byte列$ %~byte列 )
に対し，次の手続きを利用する：
◎
To determine whether a byte sequence matches the signature for MP3 without ID3, use the following steps:
• Let sequence be the byte sequence to be matched, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<p class="trans-note">【
以下，この~algoの内容は、未訳。
】</p>


		</section>
		<section id="matching-a-font-type-pattern">
<h3 title="Matching a font type pattern">6.3. ~font型~patternとの照合</h3>


<p class="algo-head">
次に与える
`~font型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`~font~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which font MIME type byte pattern a byte sequence input matches, if any, use the following font type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表内の~EACH( ~row %~row ) に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致した ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致した ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table><thead><tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`~font~MIME型$
<tr><th class="note" colspan="4">注記
</thead><tbody>

<tr><td>`00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4C 50^X
<td>`00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FF FF^X
<td>なし
<td>`application/vnd.ms-fontobject^mt
<tr><td class="note" colspan="4">
`Embedded OpenType^i 符丁を表す，次の連結：
34 個の`~byte$,
`LP^bl 
◎
34 bytes followed by the string "LP", the Embedded OpenType signature.

<tr><td>`00 01 00 00^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/ttf^mt
<tr><td class="note" colspan="4">
`TrueType^i 符丁を表す，~version番号 1.0 を表現している 4 個の`~byte$
◎
4 bytes representing the version number 1.0, a TrueType signature.

<tr><td>`4F 54 54 4F^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/otf^mt
<tr><td class="note" colspan="4">
`OpenType^i 符丁を表す， `OTTO^bl
◎
The string "OTTO", the OpenType signature.

<tr><td>`74 74 63 66^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/collection^mt
<tr><td class="note" colspan="4">
`TrueType Collection^i 符丁を表す， `ttcf^bl
◎
The string "ttcf", the TrueType Collection signature.

<tr><td>`77 4F 46 46^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/woff^mt
<tr><td class="note" colspan="4">
`Web Open Font Format 1.0^i 符丁を表す， `wOFF^bl
◎
The string "wOFF", the Web Open Font Format 1.0 signature. 

<tr><td>`77 4F 46 32^X
<td>`FF FF FF FF^X
<td>なし
<td>`font/woff2^mt
<tr><td class="note" colspan="4">
`Web Open Font Format 2.0^i 符丁を表す， `wOF2^bl
◎
The string "wOF2", the Web Open Font Format 2.0 signature. 

</tbody></table>

	</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>



		</section>
		<section id="matching-an-archive-type-pattern">
<h3 title="Matching an archive type pattern">6.4. ~archive型~patternとの照合</h3>


<p class="algo-head">
次に与える
`~archive型~pattern照合~algo@
は、［
所与の
( `~byte列$ %入力 )
が，どの`~archive~MIME型$ `~byte~pattern$に合致するか
］を決定するときに利用される：
◎
To determine which archive MIME type byte pattern a byte sequence input matches, if any, use the following archive type pattern matching algorithm:
</p>

<ol>
	<li>
<p>
下に与える表内の~EACH( ~row %~row ) に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致した ~LET
`~pattern照合~algo$( %入力, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given input, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致した ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table><thead><tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`~archive~MIME型$
<tr><th class="note" colspan="4">注記
</thead><tbody>

<tr><td>`1F 8B 08^X
<td>`FF FF FF^X
<td>なし
<td>`application/x-gzip^mt
<tr><td class="note" colspan="4">
`GZIP^i ~archive符丁
◎
The GZIP archive signature.

<tr><td>`50 4B 03 04^X
<td>`FF FF FF FF^X
<td>なし
<td>`application/zip^mt
<tr><td class="note" colspan="4">
`ZIP^i ~archive符丁を表す，次の連結：
`PK^bl, `ETX^smb, `EOT^smb
◎
The string "PK" followed by ETX EOT, the ZIP archive signature.

<tr><td>`52 61 72 20 1A 07 00^X
<td>`FF FF FF FF FF FF FF^X
<td>なし
<td>`application/x-rar-compressed^mt
<tr><td class="note" colspan="4">
`RAR^i ~archive符丁を表す，次の連結：
`Rar ^bl, `SUB^smb, `BEL^smb, `NUL^smb
◎
The string "Rar " followed by SUB BEL NUL, the RAR archive signature.
</tbody></table>
	</li>
	<li>
~RET ε （“未定義”）
◎
Return undefined.
</li>
</ol>



		</section>
	</section>
	<section id="determining-the-computed-mime-type-of-a-resource">
<h2 title="Determining the computed MIME type of a resource">7. 資源に算出される~MIME型の決定-法</h2>

<p class="algo-head">
次に与える
`~MIME型を~sniffする~algo@
は、［
`資源$に`算出される~MIME型$
］を決定するときに利用され~MUST：
◎
To determine the computed MIME type of a resource, user agents must use the following MIME type sniffing algorithm:
</p>

<ol>
	<li>
%資源~header ~LET `資源~header$
◎
↓↓</li>
	<li>
%~MIME型 ~LET `給された~MIME型$
◎
↓↓</li>
	<li>
%~script可否を~sniffする~flag ~LET `~sniffなし~flag$に応じて
⇒
~ON ならば ~OFF ／
~OFF ならば ~ON
◎
↓</li>
	<li>
~IF［
%~MIME型 ~EQ ε
］~OR［
%~MIME型 の`~essence$ ~IN
{ `unknown/unknown^l , `application/unknown^l ,`*/*^l }
］
⇒
~RET `未知の~MIME型を識別する規則$( %資源~header, %~script可否を~sniffする~flag )
◎
If the supplied MIME type is undefined or if the supplied MIME type’s essence is "unknown/unknown", "application/unknown", or "*/*", execute the rules for identifying an unknown MIME type with the sniff-scriptable flag equal to the inverse of the no-sniff flag and abort these steps.
</li>
	<li>
~IF［
`~sniffなし~flag$ ~EQ ~ON
］
⇒
~RET %~MIME型
◎
If the no-sniff flag is set, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
~IF［
`~Apache~bug用~検査~flag$ ~EQ ~ON
］
⇒
~RET `資源は~textか~binaryかを判別する規則$( %資源~header )
◎
If the check-for-apache-bug flag is set, execute the rules for distinguishing if a resource is text or binary and abort these steps.
</li>
	<li>
~IF［
%~MIME型 は`~XML~MIME型$である
］
⇒
~RET %~MIME型
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
~IF［
%~MIME型 の`~essence$ ~EQ `text/html^l
］
⇒
~RET `資源は~feedか~HTMLかを判別する規則$( %資源~header )
◎
If the supplied MIME type’s essence is "text/html", execute the rules for distinguishing if a resource is a feed or HTML and abort these steps.
</li>
	<li>
~IF［
%~MIME型 は `~UAにより~supportされて$いる`画像~MIME型$である
］
⇒
%合致した型 ~LET `画像~型~pattern照合~algo$( %資源~header )
◎
If the supplied MIME type is an image MIME type supported by the user agent, let matched-type be the result of executing the image type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matched-type is not undefined, the computed MIME type is matched-type.
◎
Abort these steps.
</li>
	<li>
~IF［
%~MIME型 は `~UAにより~supportされて$いる`音声動画~MIME型$である
］
⇒
%合致した型 ~LET `音声動画~型~pattern照合~algo$( %資源~header )
◎
If the supplied MIME type is an audio or video MIME type supported by the user agent, let matched-type be the result of executing the audio or video type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matched-type is not undefined, the computed MIME type is matched-type.
◎
Abort these steps.
</li>
	<li>
~RET %~MIME型
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>



		<section id="identifying-a-resource-with-an-unknown-mime-type">
<h3 title="Identifying a resource with an unknown MIME type">7.1. 未知の~MIME型を伴う資源の識別-法</h3>

<p class="algo-head">
次に与える
`未知の~MIME型を識別する規則@
は、［
未知の`~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、所与の
( `資源~header$ %資源~header,
`~script可否を~sniffする~flag@ （省略時は ~OFF
— この~flagは、`~script可能~MIME型$用に~sniffするかどうか決定するために利用される） )
に対し，`~MIME型$を返す：
◎
The sniff-scriptable flag is used by the rules for identifying an unknown MIME type to determine whether to sniff for scriptable MIME types.
◎
If the setting of the sniff-scriptable flag is not specified when calling the rules for identifying an unknown MIME type, the sniff-scriptable flag must default to unset.
◎
To determine the computed MIME type of a resource resource with an unknown MIME type, execute the following rules for identifying an unknown MIME type:
</p>

<ol>
	<li>
<p>
~IF［
`~script可否を~sniffする~flag$ ~EQ ~ON
］
⇒
下に与える表内の~EACH( ~row %~row ) に対し：
◎
If the sniff-scriptable flag is set, execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致した ~LET
`~pattern照合~algo$( %資源~header, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given resource’s resource header, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致した ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table><thead><tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`算出される~MIME型$
<tr><th class="note" colspan="4">注記
</thead><tbody>

<tr><td>`3C 21 44 4F 43 54 59 50 45 20 48 54 4D 4C ~tagT^X
<td>`FF FF DF DF DF DF DF DF DF FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;!DOCTYPE HTML^bl ,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;!DOCTYPE HTML" followed by a tag-terminating byte.

<tr><td>`3C 48 54 4D 4C ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;HTML^bl ,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;HTML" followed by a tag-terminating byte.

<tr><td>`3C 48 45 41 44 ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;HEAD^bl ,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;HEAD" followed by a tag-terminating byte.

<tr><td>`3C 53 43 52 49 50 54 ~tagT^X
<td>`FF DF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;SCRIPT^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;SCRIPT" followed by a tag-terminating byte.

<tr><td>`3C 49 46 52 41 4D 45 ~tagT^X
<td>`FF DF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;IFRAME^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;IFRAME" followed by a tag-terminating byte.

<tr><td>`3C 48 31 ~tagT^X
<td>`FF DF FF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;H1^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;H1" followed by a tag-terminating byte.

<tr><td>`3C 44 49 56 ~tagT^X
<td>`FF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;DIV^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;DIV" followed by a tag-terminating byte.

<tr><td>`3C 46 4F 4E 54 ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;FONT^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;FONT" followed by a tag-terminating byte.

<tr><td>`3C 54 41 42 4C 45 ~tagT^X
<td>`FF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;TABLE^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;TABLE" followed by a tag-terminating byte.

<tr><td>`3C 41 ~tagT^X
<td>`FF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;A^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;A" followed by a tag-terminating byte.

<tr><td>`3C 53 54 59 4C 45 ~tagT^X
<td>`FF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;STYLE^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;STYLE" followed by a tag-terminating byte.

<tr><td>`3C 54 49 54 4C 45 ~tagT^X
<td>`FF DF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;TITLE^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;TITLE" followed by a tag-terminating byte.

<tr><td>`3C 42 ~tagT^X
<td>`FF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;B^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;B" followed by a tag-terminating byte.

<tr><td>`3C 42 4F 44 59 ~tagT^X
<td>`FF DF DF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;BODY^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;BODY" followed by a tag-terminating byte.

<tr><td>`3C 42 52 ~tagT^X
<td>`FF DF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;BR^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;BR" followed by a tag-terminating byte.

<tr><td>`3C 50 ~tagT^X
<td>`FF DF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
大小無視 `&lt;P^bl,
`~tag-terminating~byte$
◎
The case-insensitive string "&lt;P" followed by a tag-terminating byte.

<tr><td>`3C 21 2D 2D ~tagT^X
<td>`FF FF FF FF FF^X
<td>`空白~byte$
<td>`text/html^mt
<tr><td class="note" colspan="4">
次の連結：
`&lt;!--^bl,
`~tag-terminating~byte$
◎
The string "&lt;!--" followed by a tag-terminating byte.

<tr><td>`3C 3F 78 6D 6C^X
<td>`FF FF FF FF FF^X
<td>`空白~byte$
<td>`text/xml^mt
<tr><td class="note" colspan="4">
`&lt;?xml^bl 
◎
The string "&lt;?xml".

<tr><td>`25 50 44 46 2D^X
<td>`FF FF FF FF FF^X
<td>なし
<td>`application/pdf^mt
<tr><td class="note" colspan="4">
`PDF^i 符丁を表す， `%PDF-^bl
◎
The string "%PDF-", the PDF signature.
</tbody></table>


<p class="XXX">
~feedについてはどうなのか？
◎
What about feeds?
</p>

	</li>
	<li>
<p>
下に与える表内の~EACH( ~row %~row ) に対し：
◎
Execute the following steps for each row row in the following table:
</p>
		<ol>
			<li>
%~patternに合致した ~LET
`~pattern照合~algo$( %資源~header, %~row を成す 1, 2, 3 列目の値 )
◎
Let patternMatched be the result of the pattern matching algorithm given resource’s resource header, the value in the first column of row, the value in the second column of row, and the value in the third column of row.
</li>
			<li>
~IF［
%~patternに合致した ~EQ ~T
］
⇒
~RET  %~row を成す 4 列目の値
◎
If patternMatched is true, return the value in the fourth column of row.
</li>
		</ol>
<table><thead><tr><th>`~byte~pattern$
<th>`~pattern~mask$
<th>無視される頭部`~byte$たち
<th>`算出される~MIME型$
<tr><th class="note" colspan="4">注記
</thead><tbody>

<tr><td>`25 21 50 53 2D 41 64 6F 62 65 2D^X
<td>`FF FF FF FF FF FF FF FF FF FF FF^X
<td>なし
<td>`application/postscript^mt
<tr><td class="note" colspan="4">
`PostScript^i 符丁を表す， `%!PS-Adobe-^bl
◎
The string "%!PS-Adobe-", the PostScript signature.

<tr><td>`FE FF 00 00^X
<td>`FF FF 00 00^X
<td>なし
<td>`text/plain^mt
<tr><td class="note" colspan="4">
~UTF-16BE~BOM
◎
UTF-16BE BOM

<tr><td>`FF FE 00 00^X
<td>`FF FF 00 00^X
<td>なし
<td>`text/plain^mt
<tr><td class="note" colspan="4">
~UTF-16LE~BOM
◎
UTF-16LE BOM

<tr><td>`EF BB BF 00^X
<td>`FF FF FF 00^X
<td>なし
<td>`text/plain^mt
<tr><td class="note" colspan="4">
~UTF-8~BOM
◎
UTF-8 BOM
</tbody></table>


<p>
~UAは、追加の`~MIME型$を~supportするためとして，この表を暗黙的に拡張しても~MAY。
◎
User agents may implicitly extend this table to support additional MIME types.
</p>

<p>
しかしながら，~UAは、［
この表~内にすでに在る，`算出される~MIME型$
］用に追加の`~byte~pattern$を含ませて，この表を暗黙的に拡張する~SHOULDでない
— そうすると、特権拡大の脆弱性が導入されかねないので。
◎
However, user agents should not implicitly extend this table to include additional byte patterns for any computed MIME type already present in this table, as doing so could introduce privilege escalation vulnerabilities.
</p>

<p>
~UAは、この表を拡張するときには，いかなる特権拡大の脆弱性も導入しては~MUST_NOT。
◎
User agents must not introduce any privilege escalation vulnerabilities when extending this table.
</p>

	</li>
	<li>
%合致した型 ~LET 
`画像~型~pattern照合~algo$( %資源~header )
◎
Let matchedType be the result of executing the image type pattern matching algorithm given resource’s resource header.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matchedType is not undefined, return matchedType.
</li>
	<li>
%合致した型 ~SET 
`音声動画~型~pattern照合~algo$( %資源~header )
◎
Set matchedType to the result of executing the audio or video type pattern matching algorithm given resource’s resource header.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET 
%合致した型

◎
If matchedType is not undefined, return matchedType.
</li>
	<li>
%合致した型 ~SET `~archive型~pattern照合~algo$( %資源~header )
◎
Set matchedType to the result of executing the archive type pattern matching algorithm given resource’s resource header.
</li>
	<li>
~IF［
%合致した型 ~NEQ ε
］
⇒
~RET %合致した型
◎
If matchedType is not undefined, return matchedType.
</li>
	<li>
~IF［
%資源~header を成すどの~byteも`~binary~data~byte$でない
］
⇒
~RET `text/plain^l 
◎
If resource’s resource header contains no binary data bytes, return "text/plain".
</li>
	<li>
~RET `application/octet-stream^l 
◎
Return "application/octet-stream".
</li>
</ol>

		</section>
		<section id="sniffing-a-mislabeled-binary-resource">
<h3 title="Sniffing a mislabeled binary resource">7.2. 誤labelされた~binary資源の~sniff法</h3>

<p class="algo-head">
次に与える
`資源は~textか~binaryかを判別する規則@
は、［
~binary`資源$は素の~textとして誤labelされたかどうか
］を決定するときに利用される
— それは、所与の
( `~byte列$ %資源~header )
に対し，`~MIME型$を返す：
◎
To determine whether a binary resource has been mislabeled as plain text, execute the following rules for distinguishing if a resource is text or binary:
• Let length be the number of bytes in the resource header.
</p>

<ol>
	<li>
<p>
~RET［
次のいずれかが満たされるならば `text/plain^l ／
~ELSE_ `application/octet-stream^l
］：
◎
↓</p>
		<ul>
			<li>
%資源~header[ 0 `+〜$ 2 ] ~IN
{ `FE FF^X （ ~UTF-16BE~BOM）, `FF FE^X （ ~UTF-16LE~BOM ） }
◎
If length is greater than or equal to 2 and the first 2 bytes of the resource header are equal to 0xFE 0xFF (UTF-16BE BOM) or 0xFF 0xFE (UTF-16LE BOM), the computed MIME type is "text/plain".
• Abort these steps.
</li>
	<li>
%資源~header[ 0 `+〜$ 3 ] ~EQ `EF BB BF^X （ ~UTF-8~BOM ）
◎
If length is greater than or equal to 3 and the first 3 bytes of the resource header are equal to 0xEF 0xBB 0xBF (UTF-8 BOM), the computed MIME type is "text/plain".
• Abort these steps.
</li>
	<li>
%資源~header を成すどの~byteも`~binary~data~byte$でない
◎
If the resource header contains no binary data bytes, the computed MIME type is "text/plain".
• Abort these steps.
◎
The computed MIME type is "application/octet-stream".
</li>
		</ul>

<p class="warning">
`資源は~textか~binaryかを判別する規則$は、決して［
`算出される~MIME型$は，`~script可能~MIME型$であるものと決定しない
］ことが必要不可欠である
— そうすることは、特権拡大~攻撃を許容することになり得るので。
◎
It is critical that the rules for distinguishing if a resource is text or binary never determine the computed MIME type to be a scriptable MIME type, as this could allow a privilege escalation attack.
</p>
	</li>
</ol>

		</section>
		<section id="sniffing-a-mislabeled-feed">
<h3 title="Sniffing a mislabeled feed">7.3. 誤labelされた~feedの~sniff法</h3>

<p class="algo-head">
次に与える
`資源は~feedか~HTMLかを判別する規則@
は、［
~feedが~HTMLとして誤labelされたかどうか
］を決定するときに利用される
— それは、所与の
( `資源~header$ %~byte列 )
に対し，`~MIME型$を返す：
◎
To determine whether a feed has been mislabeled as HTML, execute the following rules for distinguishing if a resource is a feed or HTML:
• Let sequence be the resource header, where sequence[s] is byte s in sequence and sequence[0] is the first byte in sequence.
</p>

<ol>
	<li>
%長さ ~LET %~byte列 の`長さ$byte
◎
Let length be the number of bytes in sequence.
</li>
	<li>
%s ~LET 0
◎
Initialize s to 0.
</li>
	<li>
~IF［
%~byte列[ 0 `+〜$ 3 ] ~EQ `EF BB BF^X （ ~UTF-8~BOM ）
］
⇒
%s ~INCBY 3
◎
If length is greater than or equal to 3 and the three bytes from sequence[0] to sequence[2] are equal to 0xEF 0xBB 0xBF (UTF-8 BOM), increment s by 3.
</li>
	<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
While s is less than length, continuously loop through these steps:
</p>
		<ol>
			<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
Enter loop L:
◎
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
				<ol>
					<li>
~IF［
%~byte列[ %s ] ~EQ `&lt;^lX
］
⇒＃
%s ~INCBY 1；
~BREAK
◎
If sequence[s] is equal to 0x3C ("&lt;"), increment s by 1 and exit loop L.
</li>
					<li>
~IF［
%~byte列[ %s ] は`空白~byte$でない
］
⇒
~RET `給された~MIME型$
◎
If sequence[s] is not a whitespace byte, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
					<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~byte列[ %s `+〜$ 3 ] ~EQ `!--^lX
］：
◎
Enter loop L:
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
◎
If length is greater than or equal to s + 3 and the three bytes from sequence[s] to sequence[s + 2] are equal to 0x21 0x2D 0x2D ("!--"),＼
</p>
				<ol>
					<li>
%s ~INCBY 3
◎
increment s by 3 and＼
</li>
					<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
enter loop M:
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
						<ol>
							<li>
~IF［
%~byte列[ %s `+〜$ 3 ] ~EQ `--&gt;^lX
］
⇒＃
%s ~INCBY 3；
~BREAK
◎
If length is greater than or equal to s + 3 and the three bytes from sequence[s] to sequence[s + 2] are equal to 0x2D 0x2D 0x3E ("--&gt;"), increment s by 3 and exit loops M and L.
</li>
							<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
						</ol>
					</li>
					<li>
~CONTINUE
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~byte列[ %s ] ~EQ `!^lX
］
⇒
◎
If length is greater than or equal to s + 1 and sequence[s] is equal to 0x21 ("!"),＼
</p>
				<ol>
					<li>
%s ~INCBY 1
◎
increment s by 1 and＼
</li>
					<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
enter loop M:
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
						<ol>
							<li>
~IF［
%~byte列[ %s ] ~EQ `&gt;^lX
］
⇒＃
%s ~INCBY 1；
~BREAK
◎
If length is greater than or equal to s + 1 and sequence[s] is equal to 0x3E ("&gt;"), increment s by 1 and exit loops M and L.
</li>
							<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
						</ol>
					</li>
					<li>
~CONTINUE
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~byte列[ %s ] ~EQ `?^lX
］：
◎
If length is greater than or equal to s + 1 and sequence[s] is equal to 0x3F ("?"),＼
</p>
				<ol>
					<li>
%s ~INCBY 1
◎
increment s by 1 and＼
</li>
					<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
enter loop M:
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
						<ol>
							<li>
~IF［
%~byte列[ %s `+〜$ 2 ] ~EQ `?&gt;^lX
］
⇒＃
%s ~INCBY 2；
~BREAK
◎
If length is greater than or equal to s + 2 and the two bytes from sequence[s] to sequence[s + 1] are equal to 0x3F 0x3E ("?&gt;"), increment s by 2 and exit loops M and L.
</li>
							<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
						</ol>
					</li>
					<li>
~CONTINUE
◎
↑</li>
				</ol>
			</li>
			<li>
~IF［
%~byte列[ %s `+〜$ 3 ] ~EQ `rss^lX
］
⇒
~RET `application/rss+xml^l
◎
If length is greater than or equal to s + 3 and the three bytes from sequence[s] to sequence[s + 2] are equal to 0x72 0x73 0x73 ("rss"), the computed MIME type is "application/rss+xml".
◎
Abort these steps.
</li>
			<li>
~IF［
%~byte列[ %s `+〜$ 4 ] ~EQ `feed^lX
］
⇒
~RET `application/atom+xml^l
◎
If length is greater than or equal to s + 4 and the four bytes from sequence[s] to sequence[s + 3] are equal to 0x66 0x65 0x65 0x64 ("feed"), the computed MIME type is "application/atom+xml".
◎
Abort these steps.
</li>
			<li>
<p>
~IF［
%~byte列[ %s `+〜$ 7 ] ~EQ `rdf:RDF^lX
］
⇒
◎
If length is greater than or equal to s + 7 and the seven bytes from sequence[s] to sequence[s + 6] are equal to 0x72 0x64 0x66 0x3A 0x52 0x44 0x46 ("rdf:RDF"),＼
</p>
				<ol>
					<li>
%s ~INCBY 7
◎
increment s by 7 and＼
</li>
					<li>
%RSS10 ~LET `http://purl.org/rss/1.0/^lX
◎
↓</li>
					<li>
%RDF ~LET `http://www.w3.org/1999/02/22-rdf-syntax-ns#^lX
◎
↓</li>
					<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
enter loop M:
◎
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
						<ol>
							<li>
<p>
~IF［
%~byte列[ %s `+〜$ 24 ] ~EQ %RSS10
］：
◎
If length is greater than or equal to s + 24 and the twenty-four bytes from sequence[s] to sequence[s + 23] are equal to 0x68 0x74 0x74 0x70 0x3A 0x2F 0x2F 0x70 0x75 0x72 0x6C 0x2E 0x6F 0x72 0x67 0x2F 0x72 0x73 0x73 0x2F 0x31 0x2E 0x30 0x2F ("http://purl.org/rss/1.0/"),＼
</p>
								<ol>
									<li>
%s ~INCBY 24
◎
increment s by 24 and＼
</li>
									<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
enter loop N:
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
										<ol>
											<li>
~IF［
%~byte列[ %s `+〜$ 43 ] ~EQ %RDF
］
⇒
~RET `application/rss+xml^l
◎
If length is greater than or equal to s + 43 and the forty-three bytes from sequence[s] to sequence[s + 42] are equal to 0x68 0x74 0x74 0x70 0x3A 0x2F 0x2F 0x77 0x77 0x77 0x2E 0x77 0x33 0x2E 0x6F 0x72 0x67 0x2F 0x31 0x39 0x39 0x39 0x2F 0x30 0x32 0x2F 0x32 0x32 0x2D 0x72 0x64 0x66 0x2D 0x73 0x79 0x6E 0x74 0x61 0x78 0x2D 0x6E 0x73 0x23 ("http://www.w3.org/1999/02/22-rdf-syntax-ns#"), the computed MIME type is "application/rss+xml".
◎
Abort these steps.
</li>
											<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
<p>
~IF［
%~byte列[ %s `+〜$ 43 ] ~EQ %RDF
<!-- 原文誤 24 -->
］：
◎
If length is greater than or equal to s + 24 and the twenty-four bytes from sequence[s] to sequence[s + 23] are equal to 0x68 0x74 0x74 0x70 0x3A 0x2F 0x2F 0x77 0x77 0x77 0x2E 0x77 0x33 0x2E 0x6F 0x72 0x67 0x2F 0x31 0x39 0x39 0x39 0x2F 0x30 0x32 0x2F 0x32 0x32 0x2D 0x72 0x64 0x66 0x2D 0x73 0x79 0x6E 0x74 0x61 0x78 0x2D 0x6E 0x73 0x23 ("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),＼
</p>
								<ol>
									<li>
%s ~INCBY 43
<!-- 原文誤 24 -->
◎
increment s by 24 and＼
</li>
									<li>
<p>
~WHILE［
%s ~LT %長さ
］：
◎
enter loop N:
• If sequence[s] is undefined, the computed MIME type is the supplied MIME type.
•• Abort these steps.
</p>
										<ol>
											<li>
~IF［
%~byte列[ %s `+〜$ 24 ] ~EQ %RSS10
<!-- 原文誤 43 -->
］
⇒
~RET `application/rss+xml^l
◎
If length is greater than or equal to s + 43 and the forty-three bytes from sequence[s] to sequence[s + 42] are equal to 0x68 0x74 0x74 0x70 0x3A 0x2F 0x2F 0x70 0x75 0x72 0x6C 0x2E 0x6F 0x72 0x67 0x2F 0x72 0x73 0x73 0x2F 0x31 0x2E 0x30 0x2F ("http://purl.org/rss/1.0/"), the computed MIME type is "application/rss+xml".
◎
Abort these steps.
</li>
											<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
%s ~INCBY 1
◎
Increment s by 1.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~BREAK
◎
The computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
		</ol>
	</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>


<p class="note">注記：
~UAにとっては
`資源は~feedか~HTMLかを判別する規則$を，自身による［
~HTML文書の文字~符号化法を検出する~algo
］と並列に実装する方が、より効率的になるかもしれない。
◎
It might be more efficient for the user agent to implement the rules for distinguishing if a resource is a feed or HTML in parallel with its algorithm for detecting the character encoding of an HTML document.
</p>

		</section>
	</section>
	<section id="context-specific-sniffing">
<h2 title="Context-specific sniffing">8. 文脈に特有の~sniff法</h2>

<p class="XXX">
`文脈@
とは…
◎
A context is ….
</p>

<p>
ある種の`文脈$においては、一定範囲の`~MIME型$に属する`資源$のみを識別することが有用になる。
◎
In certain contexts, it is only useful to identify resources that belong to a certain subset of MIME types.
</p>

<p>
その種の`文脈$において`資源$に`算出される~MIME型$を決定するときは、`~MIME型を~sniffする~algo$に代えて，`文脈に特有の~sniffする~algo$を利用することが適切になる。
◎
In such contexts, it is appropriate to use a context-specific sniffing algorithm in place of the MIME type sniffing algorithm in order to determine the computed MIME type of a resource.
</p>

<p>
`文脈に特有の~sniffする~algo@
は、【この節の下位~節に与える各種~algoの総称であり，】
所与の`資源$の`~MIME型$が 特定0の`文脈$に関連する場合に限り，当の`資源$に`算出される~MIME型$を決定する。
◎
A context-specific sniffing algorithm determines the computed MIME type of a resource only if the resource is a MIME type relevant to a particular context.
</p>



		<section id="sniffing-in-a-browsing-context">
<h3 title="Sniffing in a browsing context">8.1. 閲覧文脈における~sniff法</h3>

<p class="XXX">
`~MIME型を~sniffする~algo$を利用する。
◎
Use the MIME type sniffing algorithm.
</p>

		</section>
		<section id="sniffing-in-an-image-context">
<h3 title="Sniffing in an image context">8.2. 画像~文脈における~sniff法</h3>

<p class="algo-head">
次に与える
`特に画像を~sniffするための規則@
は、［
`画像~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、`~MIME型$を返す：
◎
To determine the computed MIME type of a resource with an image MIME type, execute the following rules for sniffing images specifically:
</p>

<ol>

<li>
~IF［
`給された~MIME型$は`~XML~MIME型$である
］
⇒
~RET `給された~MIME型$
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
%合致した画像~型 ~LET `画像~型~pattern照合~algo$( `資源~header$ )
◎
Let image-type-matched be the result of executing the image type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した画像~型 ~NEQ ε
］
⇒
~RET %合致した画像~型
◎
If image-type-matched is not undefined, the computed MIME type is image-type-matched.
◎
Abort these steps.
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>



		</section>
		<section id="sniffing-in-an-audio-or-video-context">
<h3 title="Sniffing in an audio or video context">8.3. 音声動画~文脈における~sniff法</h3>


<p class="algo-head">
次に与える
`特に音声や動画を~sniffするための規則@
は、［
`音声動画~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、`~MIME型$を返す：
◎
To determine the computed MIME type of a resource with an audio or video MIME type, execute the following rules for sniffing audio and video specifically:
</p>

<ol>

<li>
~IF［
`給された~MIME型$は`~XML~MIME型$である
］
⇒
~RET `給された~MIME型$
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
%合致した音声動画~型 ~LET 
`音声動画~型~pattern照合~algo$( `資源~header$ )
◎
Let audio-or-video-type-matched be the result of executing the audio or video type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した音声動画~型 ~NEQ ε
］
⇒
~RET %合致した音声動画~型
◎
If audio-or-video-type-matched is not undefined, the computed MIME type is audio-or-video-type-matched.
◎
Abort these steps.
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>


		</section>
		<section id="sniffing-in-a-plugin-context">
<h3 title="Sniffing in a plugin context">8.4. ~plugin文脈における~sniff法</h3>


<p class="algo-head">
次に与える
`~plugin文脈~内で~sniffするための規則@
は、~plugin文脈~内で，［
`~fetch$された`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、`~MIME型$を返す：
◎
To determine the computed MIME type of a resource fetched in a plugin context, execute the following rules for sniffing in a plugin context:
</p>

<ol>
	<li class="XXX">
~IF［
`給された~MIME型$ ~EQ ε
］
⇒
~RET `application/octet-stream^l
◎
If the supplied MIME type is undefined, the computed MIME type is "application/octet-stream".
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>



		</section>
		<section id="sniffing-in-a-style-context">
<h3 title="Sniffing in a style context">8.5. ~style文脈における~sniff法</h3>


<p class="algo-head">
次に与える
`~style文脈~内で~sniffするための規則@
は、~style文脈~内で，［
`~fetch$された`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、`~MIME型$を返す：
◎
To determine the computed MIME type of a resource fetched in a style context, execute the following rules for sniffing in a style context:
</p>

<ol>
	<li class="XXX">
~IF［
`給された~MIME型$ ~EQ ε
］
⇒
…
◎
If the supplied MIME type is undefined, ….
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>

		</section>
		<section id="sniffing-in-a-script-context">
<h3 title="Sniffing in a script context">8.6. ~script文脈における~sniff法</h3>

<p class="algo-head">
次に与える
`~script文脈~内で~sniffするための規則@
は、~script文脈~内で，［
`~fetch$された`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、`~MIME型$を返す：
◎
To determine the computed MIME type of a resource fetched in a script context, execute the following rules for sniffing in a script context:
</p>

<ol>
	<li class="XXX">
~IF［
`給された~MIME型$ ~EQ ε
］
⇒
…
◎
If the supplied MIME type is undefined, ….
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>

		</section>
		<section id="sniffing-in-a-font-context">
<h3 title="Sniffing in a font context">8.7. ~font文脈における~sniff法</h3>


<p class="algo-head">
次に与える
`特に~fontを~sniffするための規則@
は、［
`~font~MIME型$を伴う`資源$に`算出される~MIME型$
］を決定するときに利用される
— それは、`~MIME型$を返す：
◎
To determine the computed MIME type of a resource with a font MIME type, execute the following rules for sniffing fonts specifically:
</p>

<ol>
	<li>
~IF［
`給された~MIME型$は`~XML~MIME型$である
］
⇒
~RET `給された~MIME型$
◎
If the supplied MIME type is an XML MIME type, the computed MIME type is the supplied MIME type.
◎
Abort these steps.
</li>
	<li>
%合致した~font型 ~LET 
`~font型~pattern照合~algo$( `資源~header$ )
◎
Let font-type-matched be the result of executing the font type pattern matching algorithm with the resource header as the byte sequence to be matched.
</li>
	<li>
~IF［
%合致した~font型 ~NEQ ε
］
⇒
~RET %合致した~font型
◎
If font-type-matched is not undefined, the computed MIME type is font-type-matched.
◎
Abort these steps.
</li>
	<li>
~RET `給された~MIME型$
◎
The computed MIME type is the supplied MIME type.
</li>
</ol>



		</section>
		<section id="sniffing-in-a-text-track-context">
<h3 title="Sniffing in a text track context">8.8. ~text-track文脈における~sniff法</h3>


<p class="XXX">
`算出される~MIME型$は `text/vtt^l とする。
◎
The computed MIME type is "text/vtt".
</p>

		</section>
		<section id="sniffing-in-a-cache-manifest-context">
<h3 title="Sniffing in a cache manifest context">8.9. ~cache~manifest文脈における~sniff法</h3>

<p class="XXX">
`算出される~MIME型$は `text/cache-manifest^l  とする。
◎
The computed MIME type is "text/cache-manifest".
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<div lang="en-x-a0">

<p>
Special thanks to Adam Barth and Ian Hickson for maintaining previous incarnations of this document.
</p>

<p>
Thanks also to
 Alfred Hönes,
 Anne van Kesteren,
 Boris Zbarsky,
 David Singer,
 Domenic Denicola,
 Henri Sivonen,
 Jonathan Neal,
 Joshua Cranmer,
 Larry Masinter,
 罗泽轩,
 Mariko Kosaka,
 Mark Pilgrim,
 Paul Adenot,
 Peter Occil,
 Russ Cox,
 Simon Pieters, and
 triple-underscore
 for their invaluable contributions.
 </p>

<p>
This standard is written by <a href="https://gphemsley.org/">Gordon P. Hemsley</a> (<a href="mailto:me@gphemsley.org">me@gphemsley.org</a>).
</p>

<p>
Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

</div>

	</section>

</main></div>
