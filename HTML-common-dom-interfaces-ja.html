<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Common DOM interfaces（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'common-dom-interfaces',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {// '%'
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'I':
	break;
case 'm':
case 'sL': 
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = key.replace(/_/, ':');
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'jI': // JS intrinsic
	text = `%${key}%`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2024-07-12
trans_update:2024-03-28
source_checked:220610
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/common-dom-interfaces.html
nav_prev:HTMLurl
nav_next:HTMLcloning
trans_1st_pub:2016-01-28


●●class_map
e:element
a:attr
st:attr-state
et:event-type
sc:scheme
ps:pseudo
p:production
dir:directive
v:value
E:error
js:js-other
jA:abstract
t:type
U:code-point
cn:cp-name

●●tag_map
I:code
m:code
sL:code
E:code
c:code
e:code
a:code
st:i
sc:code
et:code
v:code
p:code
ps:code
dir:code
js:span
jA:span
V:var
t:var
mark:mark
dfn:dfn
i:i
U:span
cn:span
cite:cite

●●original_id_map

●●mdn_urls
htmlformcontrolscollection:API/HTMLFormControlsCollection
htmloptionscollection:API/HTMLOptionsCollection
radionodelist:API/RadioNodeList
domstringlist:API/DOMStringList

●●link_map

	●idl
CEReactions:~HEcustom#cereactions
FrozenArray:~WEBIDL#idl-frozen-array
I.boolean:~WEBIDL#idl-boolean
I.double:~WEBIDL#idl-double
I.long:~WEBIDL#idl-long
I.unsigned long:~WEBIDL#idl-unsigned-long
I.unrestricted double:~WEBIDL#idl-unrestricted-double
I.DOMString:~WEBIDL#idl-DOMString
I.USVString:~WEBIDL#idl-USVString
I.HTMLElement:~HTMLdom#htmlelement
I.Comment:~DOM4#comment
I.DOMTokenList:~DOM4#interface-domtokenlist
I.DocumentFragment:~DOM4#interface-documentfragment
I.Element:~DOM4#interface-element
I.NodeList:~DOM4#interface-nodelist
I.HTMLCollection:~DOM4#interface-htmlcollection

I.ElementInternals:~HEcustom#elementinternals
I.HTMLFormControlsCollection:#htmlformcontrolscollection
I.HTMLOptGroupElement:~HEforms#htmloptgroupelement
I.HTMLOptionElement:~HEforms#htmloptionelement
I.HTMLOptionsCollection:#htmloptionscollection
I.RadioNodeList:#radionodelist
I.HTMLAllCollection:~HTMLLS/common-dom-interfaces.html#htmlallcollection
I.DOMStringList:#domstringlist
	I.DOMException:~WEBIDL#idl-DOMException

E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.NotFoundError:~WEBIDL#notfounderror
E.IndexSizeError:~WEBIDL#indexsizeerror


	●idl member
■member

sL.item:#dom-domstringlist-item
sL.length:#dom-domstringlist-length
sL.contains:#dom-domstringlist-contains

m.~length0:~DOM4#dom-htmlcollection-length
m.~namedItem0:~DOM4#dom-htmlcollection-nameditem
m.item:~DOM4#dom-htmlcollection-item

m.value:#dom-radionodelist-value
m.add:#dom-htmloptionscollection-add
m.length:#dom-htmloptionscollection-length
m.namedItem:#dom-htmlformcontrolscollection-nameditem
m.remove:#dom-htmloptionscollection-remove
m.selectedIndex:#dom-htmloptionscollection-selectedindex
m.setter:#dom-htmloptionscollection-setter
c.document.all:~HTMLLS/obsolete.html#dom-document-all

m.crossOrigin:~HEscripting#dom-script-crossorigin
m.~selectedIndex0:~HEforms#dom-select-selectedindex


	●element
e.form:~HEforms#the-form-element
e.input:~HEinput#the-input-element
e.optgroup:~HEforms#the-optgroup-element
e.option:~HEforms#the-option-element
e.select:~HEforms#the-select-element

	●attr
a.name:#_attr-*-name
	a.name:~HTMLforms#attr-fe-name
	a.name:~HTMLobs#attr-option-name
a.type:~HEinput#attr-input-type
a.value:~HEinput#attr-input-value
a.id:~HTMLdom#the-id-attribute

st.Radio:~HEinput#radio-button-state-(type=radio)

	●反映

反映:#reflect
反映-:#reflect
反映する:#reflect
既定の値:#default-value

V.~IDL属性:#_reflected-idl-attr
V.~target:#_reflected-target
V.内容~属性~名:#_reflected-content-attr-name
V.既定~値:#_idl-attr-default-value

内容~属性を削除する:#delete-the-content-attribute
内容~属性を取得する:#get-the-content-attribute
要素を取得する:#get-the-element
反映される内容~属性~名:#reflected-content-attribute-name
反映される~IDL属性:#reflected-idl-attribute
反映される~target:#reflected-target
内容~属性を設定する:#set-the-content-attribute
eI.~supportする:#support-elementinternals

既知な値のみに制限され:#limited-to-only-known-values
負でない整数のみに制限され:#limited-to-only-non-negative-numbers
正な整数のみに制限され:#limited-to-only-non-negative-numbers-greater-than-zero
~fallbackありの下で正な整数のみに制限され:#limited-to-only-non-negative-numbers-greater-than-zero-with-fallback
正な数のみに制限され:#limited-to-numbers-greater-than-zero

範囲に切詰められ:#clamped-to-the-range

明示的に設定された要素:#explicitly-set-attr-element
結付けられた要素を取得する~algo:#attr-associated-element
明示的に設定された要素~群:#explicitly-set-attr-elements
~cacheした要素~群:#cached-attr-associated-elements
~cacheした要素~群~obj:#cached-attr-associated-elements-object
結付けられた要素~群を取得する~algo:#attr-associated-elements

新たな空option:#_new-blank-option
~IDか名前が一致する要素~群:#_matches-id-or-name
~supportする~prop名を収集する:#_collect-supported-property-names

状態から~keywordを得る:#_choose-a-keyword-from-state

文字列~list:#_string-list

	●用語 HTML
~live:~HTMLINFRA#live

列挙d属性:~HTMLcms#enumerated-attribute
正準的な~keyword:~HTMLcms#canonical-keyword
真偽-内容~属性:~HTMLcms#boolean-attribute
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
妥当な整数:~HTMLcms#valid-integer
妥当な負でない整数:~HTMLcms#valid-non-negative-integer
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
浮動小数点数として最良な表現:~HTMLcms#best-representation-of-the-number-as-a-floating-point-number
浮動小数点数として構文解析する:~HTMLcms#rules-for-parsing-floating-point-number-values
負でない整数として構文解析する:~HTMLcms#rules-for-parsing-non-negative-integers

~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
	~HTMLurl#encoding-parsing-and-serializing-a-url → ~HTMLurl#encoding-parsing-a-url, ~URL1#concept-url-serializer

内部~内容~属性~map:~HEcustom#internal-content-attribute-map
iN.~target要素:~HEcustom#internals-target

fe.~check有りか:~HTMLforms#concept-fe-checked
~listされる要素:~HEforms#category-listed

	●DOM
~ID:~DOM4#concept-id
~collection:~DOM4#concept-collection
~node~tree:~DOM4#concept-node-tree
~node文書:~DOM4#concept-node-document
~nodeを付加する:~DOM4#concept-node-append
~nodeを子の前に前挿入する:~DOM4#concept-node-pre-insert
前挿入-:~DOM4#concept-node-pre-insert
~tree順序:~DOM4#concept-tree-order
子を~nodeに置換する:~DOM4#concept-node-replace
属性~変更-時の手続き:~DOM4#concept-element-attributes-change-ext
表現され:~DOM4#represented-by-the-collection
el.~ID:~DOM4#concept-id
根:~DOM4#concept-tree-root
子孫:~DOM4#concept-tree-descendant
子~群:~DOM4#concept-tree-child
~shadowも含めた先祖:~DOM4#concept-shadow-including-ancestor
属性を名前空間と局所~名により取得する:~DOM4#concept-element-attributes-get-by-namespace
attr.値:~DOM4#concept-attribute-value
属性~値を設定する:~DOM4#concept-element-attributes-set-value
属性を名前空間と局所~名により除去する:~DOM4#concept-element-attributes-remove-by-namespace
attr.名前空間:~DOM4#concept-attribute-namespace
attr.局所~名:~DOM4#concept-attribute-local-name


	●他
~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

~list:~INFRA#list
付加する:~INFRA#list-append
~index群:~INFRA#list-get-the-indices
~size:~INFRA#list-size
	包含-:~INFRA#list-contain
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
	~map内に存在する:~INFRA#map-exists
	値を設定する:~INFRA#map-set
	~entryを除去する:~INFRA#map-remove

~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace

所与の値:~WEBIDL#the-given-value
識別子:~WEBIDL#dfn-identifier
実装-:~WEBIDLjs#implements
~IDL型に変換する:~WEBIDLjs#dfn-convert-javascript-to-idl-value
	~IDL型に変換する:~WEBIDLjs#js-type-mapping
	変換する:~INFRA#javascript-string-convert → ~IDL型に変換する

新たな有index~propを設定する手続き:~WEBIDL#dfn-set-the-value-of-a-new-indexed-property
既存の有index~propを設定する手続き:~WEBIDL#dfn-set-the-value-of-an-existing-indexed-property
~supportする~prop~index:~WEBIDL#dfn-supported-property-indices
~supportする~prop名:~WEBIDL#dfn-supported-property-names


●●words_table1

namedItem0:namedItem
length0:length
selectedIndex0:selectedIndex


●●words_table

	●IDL／データ／構造／操作
弱い:weakな:~
実数:number::~
浮動小数点数:floating-point number::~
	正な数:non-negative numbers greater than zero
	正な整数のみ:only non-negative numbers greater than zero

前挿入-:pre-insert::~
切詰めら:clampさ::切り詰めら
切詰めた:clampした::切り詰めた

派生-:derive::~
切落す:truncateする:切り落とす

	●一般処理
隠蔽-:shadow::~
	渡され
	渡して
	条件
	~cacheしている:caching

旧-:old:~
候補:candidate:~
	%値:value
	%要素:element
	`~target$V:element
	%属性:attribute
	`~target$V:elementInternals
	%eI:elementInternals
	%結果:-
	%~URL~record:urlString
	%~IDL属性~要素:-
	%~IDL属性~要素~群:-
	%内容~属性~値:contentAttributeValue
	%属性~定義:attributeDefinition
	%構文解析した値:parsedValue
	%最小:minimum
	%最大:maximum
	その最小:clampedMin
	その最大:clampedMax
	%新たな値:newValue
	当の~IDL属性:attr
	%~target:reflectedTarget
	%候補:candidate
	%局所~名:localName
	%旧-値:oldValue
	%名前空間:namespace
	%要素~群:elements
	%~IDL属性~要素:attrElement
	%~token群:tokens
	%~ID:id
	%凍結d配列としての要素~群:elementsAsFrozenArray
	%個数差:current
	%個数差:n

	●仕様
冗長:redundant:~
真実:truth:~
	昔風の:non-fashionable retro
	集約-
	築くための部品:building block
	それでも:nevertheless
	誤り難く:less error-prone
	選ばれ:chosen
	ものと指定され得る:optionally／can be
	〜にとっての易しさ:ergonomics

	●未分類
選択-:select:~
選択:selection:~
check::::チェック
	~check有りか:checkedness
radio::::ラジオ
空option:blank option:空 option
余分:extra:~

	現れる:appearする
	起こ:happen
	対応-:correspond
	扱い
	各種記号
	応じて
	数え
	指す
	下限
	数
	有-
	満たす:meets the following criteria
	他所:Other parts of
	旧-:old
	最大
	最小
	最短
	未満
	末尾
	示し
	複数
	関して
	一致する
	最終的:ultimate
	有無:presence
	上層:on top

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Common DOM interfaces</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — 共通 DOM インタフェース</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="common-dom-interfaces">
<h3 title="Common DOM interfaces">2.6. 共通~DOM~interface</h3>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

			</section>
			<section id="reflecting-content-attributes-in-idl-attributes">
<h4 title="Reflecting content attributes in IDL attributes">2.6.1. ~IDL属性における内容~属性の反映-法</h4>

<p>
次に挙げるものが，反映-法を築くための部品を成す：
◎
The building blocks for reflecting are as follows:
</p>
<dl class="def-list">
	<dt>
`反映される~target@
◎
A reflected target＼
</dt>
	<dd>
要素／ `ElementInternals$I ~obj
</dd>
	<dd>
これは、
概して，文脈から明瞭になる。
これが実装する~interfaceは、
概して，`反映される~IDL属性$を有するそれに一致する
— `ElementInternals$I ~objである場合、
常に一致する。
◎
is an element or ElementInternals object. It is typically clear from context and typically identical to the interface of the reflected IDL attribute. It is always identical to that interface when it is an ElementInternals object.
</dd>

	<dt>
`反映される~IDL属性@
◎
A reflected IDL attribute＼
</dt>
	<dd>
ある~interfaceの，ある属性~member。
◎
is an attribute interface member.
</dd>

	<dt>
`反映される内容~属性~名@
◎
A reflected content attribute name＼
</dt>
	<dd>
文字列。
◎
is a string.＼
</dd>
	<dd>
<p>
これは、
`反映される~target$に応じて，次を表現する：
</p>
		<ul class="switch">
			<li>
要素
⇒
ある内容~属性であって［
その`名前空間$attr ~EQ ~NULL
］を満たすものの`局所~名$attr
</li>
			<li>
`ElementInternals$I ~obj
⇒
`反映される~target$の`~target要素$iNの`内部~内容~属性~map$を成す，ある~key
</li>
		</ul>
◎
When the reflected target is an element, it represents the local name of a content attribute whose namespace is null. When the reflected target is an ElementInternals object, it represents a key of the reflected target's target element's internal content attribute map.
</dd>
</dl>

<p>
`反映される~IDL属性$は、
`反映される~target$の`反映される内容~属性~名$を
`反映する@
ものと定義され得る。
このことは、
一般に，次を意味する：
◎
A reflected IDL attribute can be defined to reflect a reflected content attribute name of a reflected target. In general this means that＼
</p>
<ul>
	<li>
当の~IDL属性の取得子は、
当の内容~属性の現在の値を返す。
◎
the IDL attribute getter returns the current value of the content attribute,＼
</li>
	<li>
当の~IDL属性の設定子は、
当の内容~属性の値を所与の値†に変更する。
◎
and the setter changes the value of the content attribute to the given value.
</li>
</ul>

<p class="trans-note">【†
`所与の値$は、
正式には~Web~IDLに定義される
— 設定子に渡された値を当の~IDL属性の型に変換した結果を意味する。
】</p>

<p>
`反映される~target$が要素である場合、
`反映される~IDL属性$は，追加的に `ElementInternals$I を
`~supportする@eI
ものと宣言し得る。
このことは、
次を意味する
⇒
`ElementInternals$I ~interfaceも，［
`反映される~IDL属性$として［
同じ`識別子$を伴う
］かつ［
同じ`反映される内容~属性~名$を`反映する$
］ものを有する
◎
If the reflected target is an element, then the reflected IDL attribute can additionally declare to support ElementInternals. This means that the ElementInternals interface also has a reflected IDL attribute, with the same identifier, and that reflected IDL attribute reflects the same reflected content attribute name.
</p>

<p class="example" id="example-reflect-incantation">
反映を指示する例
⇒
`fooBar^m ~IDL属性は、
`foobar^a 内容~属性を`反映する$ことに加えて，
`ElementInternals$I を`~supportする$eIモノトスル。
◎
The fooBar IDL attribute must reflect the foobar content attribute and support ElementInternals.
</p>

<div>
<p>
以下，この節を通して：
</p>
<ul>
	<li>
所与の`反映される~IDL属性$
`~IDL属性@V
は，ある`反映される~target$
`~target@V
の`反映される内容~属性~名$
`内容~属性~名@V
を`反映-$しているとする。
</li>
	<li>
`既定~値@V
は、
`~IDL属性$V に
`既定の値@
は定義されて［
いるならば それ ／
いないならば ε
］とする
（定義されるのは、［
`long$I ／ `unsigned long$I ／ `double$I
］型の~IDL属性に限られる）。
</li>
</ul>
◎
↓↓
</div>

<p>
`~target$V には、
次に挙げる~algoが結付けられる：
◎
Reflected targets have these associated algorithms:
</p>
<ul>
	<li>
`要素を取得する@
⇒
引数をとらず，要素を返す。
◎
get the element: takes no arguments; returns an element.
</li>
	<li>
`内容~属性を取得する@
⇒
引数をとらず，［
~NULL ／文字列
］を返す。
◎
get the content attribute: takes no arguments; returns null or a string.
</li>
	<li>
`内容~属性を設定する@
⇒
文字列を引数にとり，何も返さない。
◎
set the content attribute: takes a string value; returns nothing.
</li>
	<li>
`内容~属性を削除する@
⇒
引数をとらず，何も返さない。
◎
delete the content attribute: takes no arguments; returns nothing.
</li>
</ul>

<p>
これらは、
`~target$V に応じて，
以下に従うものと定義される：
</p>
<ul class="switch">
	<li>
<p>
要素である場合：
◎
For a reflected target that is an element element, these are defined as follows:
</p>
		<ul>
			<li class="algo">
`要素を取得する$ときは
⇒
~RET `~target$V
◎
get the element
• Return element.
</li>
			<li class="algo">
<p>
`内容~属性を取得する$ときは：
◎
get the content attribute
</p>
				<ol>
					<li>
%属性 ~LET `属性を名前空間と局所~名により取得する$( ~NULL, `内容~属性~名$V, `~target$V )
◎
Let attribute be the result of running get an attribute by namespace and local name given null, the reflected content attribute name, and element.
</li>
					<li>
~IF［
%属性 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If attribute is null, then return null.
</li>
					<li>
~RET %属性 の`値$attr
◎
Return attribute's value.
</li>
				</ol>
			</li>
			<li class="algo">
`内容~属性を設定する$ときは、
所与の
( 文字列 %値 )
に対し
⇒
`属性~値を設定する$( `~target$V, `内容~属性~名$V, %値 )
◎
set the content attribute with a string value
• Set an attribute value given element, the reflected content attribute name, and value.
</li>
			<li class="algo">
`内容~属性を削除する$ときは
⇒
`属性を名前空間と局所~名により除去する$( ~NULL, `内容~属性~名$V, `~target$V )
◎
delete the content attribute
• Remove an attribute by namespace and local name given null, the reflected content attribute name, and element.
</li>
</ul>

	</li>
	<li>
<p>
`ElementInternals$I ~objである場合：
◎
For a reflected target that is an ElementInternals object elementInternals, they are defined as follows:
</p>
		<ul>
			<li class="algo">
`要素を取得する$ときは
⇒
~RET `~target$V の`~target要素$iN
◎
get the element
• Return elementInternals's target element.
</li>
			<li class="algo">
<p>
`内容~属性を取得する$ときは：
◎
get the content attribute
</p>
				<ol>
					<li>
%結果 ~LET `~target$V の`~target要素$iNの`内部~内容~属性~map$[ `内容~属性~名$V ]
◎
↓</li>
					<li>
~RET %結果 に応じて
⇒＃
ε ならば ~NULL ／
~ELSE_ %結果
◎
If elementInternals's target element's internal content attribute map[the reflected content attribute name] does not exist, then return null.
◎
Return elementInternals's target element's internal content attribute map[the reflected content attribute name].
</li>
				</ol>
			</li>
			<li class="algo">
`内容~属性を設定する$ときは、
所与の
( 文字列 %値 )
に対し
⇒
`~target$V の`~target要素$iNの`内部~内容~属性~map$[ `内容~属性~名$V] ~SET %値
◎
set the content attribute with a string value
• Set elementInternals's target element's internal content attribute map[the reflected content attribute name] to value.
</li>
			<li class="algo">
`内容~属性を削除する$ときは
⇒
`~target$V の`~target要素$iNの`内部~内容~属性~map$[ `内容~属性~名$V ] ~SET ε
◎
delete the content attribute
• Remove elementInternals's target element's internal content attribute map[the reflected content attribute name].
</li>
</ul>

<p class="note">注記：
この結果、
`ElementInternals$I ~obj用の~data構造は，いくぶん冗長になる
— その`~target要素$iNの`内部~内容~属性~map$は，直に操作し得ず、
そのような反映は，単-方向に限り起こるので。
それでも，この~approachが選ばれたのは、［
`反映される~target$たちから共有される~IDL属性を定義するとき，誤り難くなるようにするため
］および［
共通な~API意味論からの便益を得るため
］である。
◎
This results in somewhat redundant data structures for ElementInternals objects as their target element's internal content attribute map cannot be directly manipulated and as such reflection is only happening in a single direction. This approach was nevertheless chosen to make it less error-prone to define IDL attributes that are shared between reflected targets and benefit from common API semantics.
</p>
	</li>
</ul>

<hr>

<p>
`~IDL属性$V が［
`DOMString$I ／ `DOMString?^I
］型であって，ある`列挙d属性$を`反映-$している場合、
`~IDL属性$V は，
`既知な値のみに制限され@
るものと指定され得る
— その場合， `~IDL属性$V 用の取得子が返す結果は、
以下に与える処理~modelにより，［
当の列挙d属性~用の~keyword／空~文字列／ ~NULL
］に限られることになる。
◎
IDL attributes of type DOMString or DOMString? that reflect enumerated content attributes can be limited to only known values. Per the processing models below, those will cause the getters for such IDL attributes to only return keywords for those enumerated attributes, or the empty string or null.
</p>

<p>
`~IDL属性$V は `DOMString$I 型である場合：
◎
If a reflected IDL attribute has the type DOMString:
</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%要素 ~LET コレの`要素を取得する$()
◎
Let element be the result of running this's get the element.
</li>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
%属性~定義 ~LET ［
%要素 の次を満たす内容~属性
］の定義
⇒
［
その`名前空間$attr ~EQ ~NULL
］~AND［
その`局所~名$attr ~EQ `内容~属性~名$V
］
◎
Let attributeDefinition be the attribute definition of element's content attribute whose namespace is null and local name is the reflected content attribute name.
</li>
			<li>
<p>
~IF［
%属性~定義 は［
当の内容~属性は`列挙d属性$である
］ことを指示する
］~AND［
`~IDL属性$V は`既知な値のみに制限され$ている
］：
</p>
				<ol>
					<li>
%状態 ~LET %属性~定義 に定義された，
%内容~属性~値 に対応する状態
</li>
					<li>
<p>
~IF［
%状態 ~EQ ε
］
⇒
~RET 空~文字列
</p>

<p>
（例：［
%内容~属性~値 ~EQ ~NULL
］~AND［
%属性~定義 の`欠落~値~用の既定の状態$ ~EQ ε
］の場合）
</p>
					</li>
					<li>
%~keyword ~LET %状態 用の`正準的な~keyword$
</li>
					<li>
~RET %~keyword に応じて
⇒＃
ε ならば 空~文字列 ／
~ELSE_ %~keyword
</li>
				</ol>
◎
If attributeDefinition indicates it is an enumerated attribute and the reflected IDL attribute is defined to be limited to only known values:
• If contentAttributeValue does not correspond to any state of attributeDefinition (e.g., it is null and there is no missing value default), or if it is in a state of attributeDefinition with no associated keyword value, then return the empty string.
• Return the canonical keyword for the state of attributeDefinition that contentAttributeValue corresponds to.
</li>
			<li>
~RET %内容~属性~値 に応じて
⇒＃
~NULL ならば 空~文字列／
~ELSE_ %内容~属性~値
◎
If contentAttributeValue is null, then return the empty string.
◎
Return contentAttributeValue.
</li>
		</ol>
	</li>
	<li class="algo">
設定子~手続きは
⇒
コレの`内容~属性を設定する$( 所与の値 )
◎
The setter steps are to run this's set the content attribute with the given value.
</li>
</ul>

<p>
`~IDL属性$V は `DOMString?^I 型である場合：
◎
If a reflected IDL attribute has the type DOMString?:
</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%要素 ~LET コレの`要素を取得する$()
◎
Let element be the result of running this's get the element.
</li>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
%属性~定義 ~LET ［
%要素 の次を満たす内容~属性
］の定義
⇒
［
その`名前空間$attr ~EQ ~NULL
］~AND［
その`局所~名$attr ~EQ `内容~属性~名$V
］
◎
Let attributeDefinition be the attribute definition of element's content attribute whose namespace is null and local name is the reflected content attribute name.
</li>
			<li>
~Assert：
%属性~定義 は［
当の内容~属性は`列挙d属性$である
］ことを指示する。
◎
Assert: attributeDefinition indicates it is an enumerated attribute.
</li>
			<li>
~Assert：
`~IDL属性$V は`既知な値のみに制限され$ている。
◎
Assert: the reflected IDL attribute is limited to only known values.
</li>
			<li>
%状態 ~LET %属性~定義 に定義された，
%内容~属性~値 に対応する状態
◎
↓</li>
			<li>
~Assert：
%状態 ~NEQ ε
◎
Assert: contentAttributeValue corresponds to a state of attributeDefinition.
</li>
			<li>
%~keyword ~LET %状態 用の`正準的な~keyword$
◎
↓</li>
			<li>
~RET %~keyword に応じて
⇒＃
ε ならば ~NULL ／
~ELSE_ %~keyword
◎
If contentAttributeValue corresponds to a state of attributeDefinition with no associated keyword value, then return null.
◎
Return the canonical keyword for the state of attributeDefinition that contentAttributeValue corresponds to.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
~IF［
所与の値 ~EQ ~NULL
］
⇒
コレの`内容~属性を削除する$()
◎
If the given value is null, then run this's delete the content attribute.
</li>
			<li>
~ELSE
⇒
コレの`内容~属性を設定する$( 所与の値 )
◎
Otherwise, run this's set the content attribute with the given value.
</li>
		</ol>
	</li>
</ul>

<p>
`~IDL属性$V は `USVString$I 型である場合：
◎
If a reflected IDL attribute has the type USVString:
</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%要素 ~LET コレの`要素を取得する$()
◎
Let element be the result of running this's get the element.
</li>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
%属性~定義 ~LET ［
%要素 の次を満たす内容~属性
］の定義
⇒
［
その`名前空間$attr ~EQ ~NULL
］~AND［
その`局所~名$attr ~EQ `内容~属性~名$V
］
◎
Let attributeDefinition be the attribute definition of element's content attribute whose namespace is null and local name is the reflected content attribute name.
</li>
			<li>
<p>
~IF［
%属性~定義 は［
当の内容~属性は`~URL$を包含する
］ことを指示する
］：
◎
If attributeDefinition indicates it contains a URL:
</p>
				<ol>
					<li>
~IF［
%内容~属性~値 ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If contentAttributeValue is null, then return the empty string.
</li>
					<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %内容~属性~値, %要素 の`~node文書$ )
【！#encoding-parsing-and-serializing-a-url】
◎
Let urlString be the result of encoding-parsing-and-serializing a URL given contentAttributeValue, relative to element's node document.
</li>
					<li>
~IF［
%~URL~record ~NEQ `失敗^i
］
⇒
~RET `~URLを直列化する$( %~URL~record )
◎
If urlString is not failure, then return urlString.
</li>
				</ol>
			</li>
			<li>
~RET `~IDL型に変換する$( %内容~属性~値, `USVString$I )
◎
Return contentAttributeValue, converted to a scalar value string.
</li>
		</ol>
	</li>
	<li class="algo">
設定子~手続きは
⇒
コレの`内容~属性を設定する$( 所与の値 )
◎
The setter steps are to run this's set the content attribute with the given value.
</li>
</ul>

<p>
`~IDL属性$V は `boolean$I 型である場合：
◎
If a reflected IDL attribute has the type boolean:
</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
~IF［
%内容~属性~値 ~EQ ~NULL
］
⇒
~RET ~F
◎
If contentAttributeValue is null, then return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
~IF［
所与の値 ~EQ ~F
］
⇒
コレの`内容~属性を削除する$()
◎
If the given value is false, then run this's delete the content attribute.
</li>
			<li>
~IF［
所与の値 ~EQ ~T
］
⇒
コレの`内容~属性を設定する$( 空~文字列 )
◎
If the given value is true, then run this's set the content attribute with the empty string.
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
これは、
`真偽-内容~属性$の規則に対応する。
◎
This corresponds to the rules for boolean content attributes.
</p>

<p>
`~IDL属性$V は `long$I 型である場合：
◎
If a reflected IDL attribute has the type long,＼
</p>
<ul>
	<li>
`負でない整数のみに制限され@
るものと指定され得る。
◎
optionally limited to only non-negative numbers＼
and optionally with a default value defaultValue:
</li>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
<p>
~IF［
%内容~属性~値 ~NEQ ~NULL
］：
◎
If contentAttributeValue is not null:
</p>
				<ol>
					<li>
%構文解析した値 ~LET `~IDL属性$V に応じて
⇒＃
`負でない整数のみに制限され$ていないならば`整数として構文解析する$( %内容~属性~値 )
~ELSE_ `負でない整数として構文解析する$( %内容~属性~値 )
◎
Let parsedValue be the result of integer parsing contentAttributeValue if the reflected IDL attribute is not limited to only non-negative numbers; otherwise the result of non-negative integer parsing contentAttributeValue.
</li>
					<li>
~IF［
%構文解析した値 ~NEQ `失敗^i
］~AND［
%構文解析した値 ~IN `long$I 型がとり得る範囲
］
⇒
~RET %構文解析した値
◎
If parsedValue is not an error and is within the long range, then return parsedValue.
</li>
				</ol>
			</li>
			<li>
~RET ［
`既定~値$V ~NEQ ε ならば `既定~値$V ／
~ELSE_ `~IDL属性$V は`負でない整数のみに制限され$ているならば −1 ／
~ELSE_ 0
］
◎
If the reflected IDL attribute has a default value, then return defaultValue.
◎
If the reflected IDL attribute is limited to only non-negative numbers, then return −1.
◎
Return 0.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
~IF［
`~IDL属性$V は`負でない整数のみに制限され$ている
］~AND［
所与の値 ~LT 0
］
⇒
~THROW `IndexSizeError$E
◎
If the reflected IDL attribute is limited to only non-negative numbers and the given value is negative, then throw an "IndexSizeError" DOMException.
</li>
			<li>
コレの`内容~属性を設定する$( 所与の値を表現する`妥当な整数$のうち，アリな限り最短な文字列 )
◎
Run this's set the content attribute with the given value converted to the shortest possible string representing the number as a valid integer.
</li>
		</ol>
	</li>
</ul>

<p>
`~IDL属性$V は `unsigned long$I 型である場合：
◎
If a reflected IDL attribute has the type unsigned long,＼
</p>
<ul>
	<li>
<p>
次に挙げるいずれか【一つ】が指定され得る：
</p>
		<ul>
			<li>
`正な整数のみに制限され@
る
</li>
			<li>
`~fallbackありの下で正な整数のみに制限され@
る
</li>
			<li>
ある最小, 最大による
`範囲に切詰められ@
る
</li>
	</ul>
◎
optionally limited to only positive numbers, limited to only positive numbers with fallback, or clamped to the range [clampedMin, clampedMax],＼
and optionally with a default value defaultValue:
</li>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
%最小 ~LET ［
次が満たされるならば 1 ／
~ELSE_ 0
］
⇒
［
`~IDL属性$V は`正な整数のみに制限され$ている
］~OR［
`~IDL属性$V は`~fallbackありの下で正な整数のみに制限され$ている
］
◎
Let minimum be 0.
◎
If the reflected IDL attribute is limited to only positive numbers or limited to only positive numbers with fallback, then set minimum to 1.
</li>
			<li>
%最大 ~LET 2147483647
◎
↓</li>
			<li>
~IF［
`~IDL属性$V は，ある最小, 最大による`範囲に切詰められ$ている
］
⇒＃
( %最小, %最大 ) ~SET ( その最小, その最大 )
◎
If the reflected IDL attribute is clamped to the range, then set minimum to clampedMin.
◎
Let maximum be 2147483647 if the reflected IDL attribute is not clamped to the range; otherwise clampedMax.
</li>
			<li>
<p>
~IF［
%内容~属性~値 ~NEQ ~NULL
］：
◎
If contentAttributeValue is not null:
</p>
				<ol>
					<li>
%構文解析した値 ~LET `負でない整数として構文解析する$( %内容~属性~値 )
◎
Let parsedValue be the result of non-negative integer parsing contentAttributeValue.
</li>
					<li>
<p>
~IF［
%構文解析した値 ~NEQ `失敗^i
］：
</p>
						<ol>
							<li>
~IF［
%構文解析した値 ~IN { %最小 〜 %最大 }
］
⇒
~RET %構文解析した値
</li>
							<li>
~IF［
`~IDL属性$V は`範囲に切詰められ$ている
］
⇒
~RET ［
%構文解析した値 ~LT %最小 ならば %最小 ／
~ELSE_ %最大
］
</li>
						</ol>
◎
If parsedValue is not an error and is in the range minimum to maximum, inclusive, then return parsedValue.
◎
If parsedValue is not an error and the reflected IDL attribute is clamped to the range:
• If parsedValue is less than minimum, then return minimum.
• Return maximum.
</li>
				</ol>
			</li>
			<li>
~RET `既定~値$V に応じて
⇒＃
ε ならば %最小 ／
~ELSE_ `既定~値$V
◎
If the reflected IDL attribute has a default value, then return defaultValue.
◎
Return minimum.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
~IF［
`~IDL属性$V は`正な整数のみに制限され$ている
］~AND［
所与の値 ~EQ 0
］
⇒
~THROW `IndexSizeError$E
◎
If the reflected IDL attribute is limited to only positive numbers and the given value is 0, then throw an "IndexSizeError" DOMException.
</li>
			<li>
%最小 ~LET ［
次が満たされるならば 1 ／
~ELSE_ 0
］
⇒
［
`~IDL属性$V は`正な整数のみに制限され$ている
］~OR［
`~IDL属性$V は`~fallbackありの下で正な整数のみに制限され$ている
］
◎
Let minimum be 0.
◎
If the reflected IDL attribute is limited to only positive numbers or limited to only positive numbers with fallback, then set minimum to 1.
</li>
			<li>
%新たな値 ~LET ［
所与の値 ~IN { %最小 〜 2147483647 } ならば所与の値／
~ELSE_ `既定~値$V ~NEQ ε ならば `既定~値$V ／
~ELSE_ %最小
］
◎
Let newValue be minimum.
◎
If the reflected IDL attribute has a default value, then set newValue to defaultValue.
◎
If the given value is in the range minimum to 2147483647, inclusive, then set newValue to it.
</li>
			<li>
コレの`内容~属性を設定する$( %新たな値 を表現する`妥当な負でない整数$のうち，アリな限り最短な文字列 )
◎
Run this's set the content attribute with newValue converted to the shortest possible string representing the number as a valid non-negative integer.
</li>
		</ol>

<p class="note">注記：
`範囲に切詰められ$ていても，
設定子~手続きに対する効果は無い。
◎
Clamped to the range has no effect on the setter steps.
</p>
	</li>
</ul>

<p>
`~IDL属性$V は `double$I 型である場合：
◎
If a reflected IDL attribute has the type double,＼
</p>
<ul>
	<li>
<p>
`正な数のみに制限され@
るものと指定され得る。
</p>

<p class="trans-note">【
この用語は，
原文では “`正な整数のみに制限され$る” と集約されたが、
この訳では，意図的に別個な用語のまま保つ。
】</p>
◎
optionally limited to only positive numbers＼
and optionally with a default value defaultValue:
</li>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%内容~属性~値 ~LET コレの`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running this's get the content attribute.
</li>
			<li>
<p>
~IF［
%内容~属性~値 ~NEQ ~NULL
］：
◎
If contentAttributeValue is not null:
</p>
				<ol>
					<li>
%構文解析した値 ~LET `浮動小数点数として構文解析する$( %内容~属性~値 )
◎
Let parsedValue be the result of floating-point number parsing contentAttributeValue.
</li>
					<li>
~IF［
%構文解析した値 ~NEQ `失敗^i
］
⇒
~IF［
%構文解析した値 ~GT 0
］~OR［
`~IDL属性$V は`正な数のみに制限され$ていない
］
⇒
~RET %構文解析した値
◎
If parsedValue is not an error and is greater than 0, then return parsedValue.
◎
If parsedValue is not an error and the reflected IDL attribute is not limited to only positive numbers, then return parsedValue.
</li>
				</ol>
			</li>
			<li>
~RET `既定~値$V に応じて
⇒＃
ε ならば 0 ／
~ELSE_ `既定~値$V
◎
If the reflected IDL attribute has a default value, then return defaultValue.
◎
Return 0.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
~IF［
`~IDL属性$V は`正な数のみに制限され$ている
］~AND［
所与の値 ~LTE 0
］
⇒
~RET
◎
If the reflected IDL attribute is limited to only positive numbers and the given value is not greater than 0, then return.
</li>
			<li>
コレの`内容~属性を設定する$( `浮動小数点数として最良な表現$( 所与の値 ) )
◎
Run this's set the content attribute with the given value, converted to the best representation of the number as a floating-point number.
</li>
		</ol>

<p class="note">注記：
`WEBIDL$r にて定義されるとおり、
設定子に対する値 Infinity, NaN（ `Not-a-Number^en ）は，
例外を投出させる。
◎
The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in Web IDL. [WEBIDL]
</p>
	</li>
</ul>

<p>
`~IDL属性$V は `DOMTokenList$I 型である場合：
◎
If a reflected IDL attribute has the type DOMTokenList, then＼
</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは、
次を満たす `DOMTokenList$I ~obj %O を返す：
</p>
		<ul>
			<li>
%O の `内容~属性~名$V に`結付けられた要素を取得する~algo＠~DOM4#_dtl-element$() ~EQ コレ
</li>
			<li>
%O に結付けられた`属性の局所~名＠~DOM4#_dtl-localname$ ~EQ `内容~属性~名$V
</li>
		</ul>
◎
its getter steps are to return a DOMTokenList object whose associated element is this and associated attribute's local name is the reflected content attribute name.＼
</li>
	<li>
仕様~策定者は、
この型の~IDL属性~用には，［
`ElementInternals$I を`~supportする$eI
］を利用し得ない。
◎
Specification authors cannot use support ElementInternals for IDL attributes of this type.
</li>
</ul>

<p>
`~IDL属性$V は
<code>%T?</code> 型で，
%T は `Element$I または それを継承する~interfaceである場合：
◎
If a reflected IDL attribute has the type T?, where T is either Element or an interface that inherits from Element, then with attr being the reflected content attribute name:
</p>
<ul>
	<li>
<p>
`~target$V は、
次に挙げるものを有する：
</p>
		<ul>
			<li>
`内容~属性~名$V 用に
`明示的に設定された要素@
⇒
ある要素への弱い参照／ ~NULL
— 初期~時は ~NULL とする。
◎
Its reflected target has an explicitly set attr-element, which is a weak reference to an element or null. It is initially null.
</li>
			<li class="algo">
<p>
`内容~属性~名$V に
`結付けられた要素を取得する~algo@
：
◎
Its reflected target reflectedTarget has a get the attr-associated element algorithm, that runs these steps:
</p>
				<ol>
					<li>
%要素 ~LET `~target$V の`要素を取得する$()
◎
Let element be the result of running reflectedTarget's get the element.
</li>
					<li>
%内容~属性~値 ~LET `~target$V の`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running reflectedTarget's get the content attribute.
</li>
					<li>
%~IDL属性~要素 ~LET `~target$V の `内容~属性~名$V 用に`明示的に設定された要素$
◎
↓</li>
					<li>
~IF［
%~IDL属性~要素 ~NEQ ~NULL
］
⇒
~RET ［
次が満たされるならば %~IDL属性~要素 ／
~ELSE_ ~NULL
］
⇒
%~IDL属性~要素 は、
%要素 の ある`~shadowも含めた先祖$の`子孫$である
◎
If reflectedTarget's explicitly set attr-element is not null:
• If reflectedTarget's explicitly set attr-element is a descendant of any of element's shadow-including ancestors, then return reflectedTarget's explicitly set attr-element.
• Return null.
</li>
					<li>
~IF［
%内容~属性~値 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
↓</li>
					<li>
~RET 次を満たす要素は［
在るならば それらのうち`~tree順序$で最初のもの ／
無いならば ~NULL
］
⇒
［
その`根$ ~EQ %要素 の`根$
］~AND［
その`~ID$ ~EQ %内容~属性~値
］~AND［
%T を`実装-$する
］
◎
Otherwise, if contentAttributeValue is not null, return the first element candidate, in tree order, that meets the following criteria:
• candidate's root is the same as element's root;
• candidate's ID is contentAttributeValue; and
• candidate implements T.
◎
If no such element exists, then return null.
◎
Return null.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li class="algo">
取得子~手続きは
⇒
~RET コレの `内容~属性~名$V に`結付けられた要素を取得する~algo$()
◎
The getter steps are to return the result of running this's get the attr-associated element.
</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
<p>
~IF［
所与の値 ~EQ ~NULL
］：
◎
If the given value is null, then:
</p>
				<ol>
					<li>
コレの `内容~属性~名$V 用に`明示的に設定された要素$ ~SET ~NULL
◎
Set this's explicitly set attr-element to null.
</li>
					<li>
コレの`内容~属性を削除する$()
◎
Run this's delete the content attribute.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
コレの`内容~属性を設定する$( 空~文字列 )
◎
Run this's set the content attribute with the empty string.
</li>
			<li>
コレの `内容~属性~名$V 用に`明示的に設定された要素$ ~SET 所与の値への弱い参照
◎
Set this's explicitly set attr-element to a weak reference to the given value.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
`~target$V が要素である場合に限り、
内容~属性と~IDL属性を同期するため，
`~target$V 用の`属性~変更-時の手続き$が利用される
— それは、
所与の
( %局所~名, %旧-値, %値, %名前空間 )
に対し：
◎
For element reflected targets only: the following attribute change steps, given element, localName, oldValue, value, and namespace, are used to synchronize between the content attribute and the IDL attribute:
</p>
		<ol>
			<li>
~IF［
%局所~名 ~NEQ `内容~属性~名$V
］~OR［
%名前空間 ~NEQ ~NULL
］
⇒
~RET
◎
If localName is not attr or namespace is not null, then return.
</li>
			<li>
`~target$V の `内容~属性~名$V 用に`明示的に設定された要素$ ~SET ~NULL
◎
Set element's explicitly set attr-element to null.
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
一貫性を得るため、
この型の`反映される~IDL属性$の識別子は，
`Element^l で終端することが強く奨励される。
◎
Reflected IDL attributes of this type are strongly encouraged to have their identifier end in "Element" for consistency.
</p>

<p>
`~IDL属性$V は
<code>`FrozenArray$&lt;%T&gt;?</code> 型で，
%T は `Element$I または それを継承する~interfaceである場合：
◎
If a reflected IDL attribute has the type FrozenArray&lt;T&gt;?, where T is either Element or an interface that inherits from Element, then with attr being the reflected content attribute name:
</p>
<ul>
	<li>
<p>
`~target$V は、
次に挙げるものを有する：
◎
↓</p>
		<ul>
			<li>
`内容~属性~名$V 用に
`明示的に設定された要素~群@
⇒
［
要素への弱い参照
］たちが成す`~list$ ／
~NULL
— 初期~時は ~NULL とする。
◎
Its reflected target has an explicitly set attr-elements, which is either a list of weak references to elements or null. It is initially null.
</li>
			<li>
`内容~属性~名$V 用に
`~cacheした要素~群@
⇒
要素たちが成す`~list$
— 初期~時は空とする。
◎
Its reflected target has a cached attr-associated elements, which is a list of elements. It is initially « ».
</li>
			<li>
`内容~属性~名$V 用に
`~cacheした要素~群~obj@
⇒
<code>`FrozenArray$&lt;%T&gt;?</code> 型の値 ／ ~NULL
— 初期~時は ~NULL とする。
◎
Its reflected target has a cached attr-associated elements object, which is a FrozenArray&lt;T&gt;?. It is initially null.
</li>
			<li class="algo">
<p>
`内容~属性~名$V に
`結付けられた要素~群を取得する~algo@
◎
Its reflected target reflectedTarget has a get the attr-associated elements algorithm, which runs these steps:
</p>
				<ol>
					<li>
%要素~群 ~LET 新たな`~list$
◎
Let elements be an empty list.
</li>
					<li>
%要素 ~LET `~target$V の`要素を取得する$()
◎
Let element be the result of running reflectedTarget's get the element.
</li>
					<li>
%~IDL属性~要素~群 ~LET `~target$V の `内容~属性~名$V 用に`明示的に設定された要素~群$
◎
↓</li>
					<li>
~IF［
%~IDL属性~要素~群 ~NEQ ~NULL
］
⇒
%~IDL属性~要素~群 を成す
~EACH( %~IDL属性~要素 )
に対し
⇒
~IF［
%~IDL属性~要素 は，
%要素 の ある`~shadowも含めた先祖$の`子孫$である
］
⇒
%要素~群 に %~IDL属性~要素 を`付加する$
◎
If reflectedTarget's explicitly set attr-elements is not null:
• For each attrElement in reflectedTarget's explicitly set attr-elements:
•• If attrElement is not a descendant of any of element's shadow-including ancestors, then continue.
•• Append attrElement to elements.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
%内容~属性~値 ~LET `~target$V の`内容~属性を取得する$()
◎
Let contentAttributeValue be the result of running reflectedTarget's get the content attribute.
</li>
							<li>
~IF［
%内容~属性~値 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If contentAttributeValue is null, then return null.
</li>
							<li>
%~token群 ~LET `~ASCII空白で分割する$( %内容~属性~値 )
◎
Let tokens be contentAttributeValue, split on ASCII whitespace.
</li>
							<li>
<p>
%~token群 を成す
~EACH( %~ID )
に対し：
◎
For each id of tokens:
</p>
								<ol>
									<li>
%候補 ~LET 次を満たす要素は［
在るならば それらのうち`~tree順序$で最初のもの ／
無いならば ~NULL
］
⇒
［
その`根$ ~EQ %要素 の`根$
］~AND［
その`~ID$ ~EQ %~ID
］~AND［
%T を`実装-$する
］
◎
Let candidate be the first element, in tree order, that meets the following criteria:
• candidate's root is the same as element's root;
• candidate's ID is id; and
• candidate implements T.
</li>
									<li>
~IF［
%候補 ~NEQ ~NULL
］
⇒
%要素~群 に %候補 を`付加する$
◎
If no such element exists, then continue.
◎
Append candidate to elements.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
~RET %要素~群
◎
Return elements.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li class="algo">
<p>
取得子~手続きは：
◎
The getter steps are:
</p>
		<ol>
			<li>
%要素~群 ~LET コレの `内容~属性~名$V に`結付けられた要素~群を取得する~algo$()
◎
Let elements be the result of running this's get the attr-associated elements.
</li>
			<li>
~IF［
%要素~群 の内容と
コレの `内容~属性~名$V 用に`~cacheした要素~群$の内容は
等しい【順序を問わず，同じ要素たちからなる】
］
⇒
~RET コレの `内容~属性~名$V 用に`~cacheした要素~群~obj$
◎
If the contents of elements is equal to the contents of this's cached attr-associated elements, then return this's cached attr-associated elements object.
</li>
			<li>
%凍結d配列としての要素~群 ~LET `~IDL型に変換する$( %要素~群, <code>`FrozenArray$&lt;%T&gt;?</code> )
◎
Let elementsAsFrozenArray be elements, converted to a FrozenArray&lt;T&gt;?.
</li>
			<li>
コレの `内容~属性~名$V 用に`~cacheした要素~群$ ~SET %要素~群
◎
Set this's cached attr-associated elements to elements.
</li>
			<li>
コレの `内容~属性~名$V 用に`~cacheした要素~群~obj$ ~SET %凍結d配列としての要素~群
◎
Set this's cached attr-associated elements object to elementsAsFrozenArray.
</li>
			<li>
~RET %凍結d配列としての要素~群
◎
Return elementsAsFrozenArray.
</li>
		</ol>

<p class="note">注記：
この余分な~cacheしている層は、
`element.reflectedElements === element.reflectedElements^c
を満たす不変則を保全するために必要yである。
◎
This extra caching layer is necessary to preserve the invariant that element.reflectedElements === element.reflectedElements.
</p>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
The setter steps are:
</p>
		<ol>
			<li>
<p>
~IF［
所与の値 ~EQ ~NULL
］：
◎
If the given value is null:
</p>
				<ol>
					<li>
コレの `内容~属性~名$V 用に`明示的に設定された要素~群$ ~SET ~NULL
◎
Set this's explicitly set attr-elements to null.
</li>
					<li>
コレの`内容~属性を削除する$()
◎
Run this's delete the content attribute.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
コレの`内容~属性を設定する$( 空~文字列 )
◎
Run this's set the content attribute with the empty string.
</li>
			<li>
%要素~群 ~LET 新たな`~list$
◎
Let elements be an empty list.
</li>
			<li>
所与の値を成す
~EACH( %要素 )
に対し
⇒
%要素~群 に %要素 への弱い参照を`付加する$
◎
For each element in the given value:
• Append a weak reference to element to elements.
</li>
			<li>
コレの `内容~属性~名$V 用に`明示的に設定された要素~群$ ~SET %要素~群
◎
Set this's explicitly set attr-elements to elements.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
`~target$V が要素である場合に限り、
内容~属性と~IDL属性を同期するため，
`~target$V 用の`属性~変更-時の手続き$が利用される
— それは、
所与の
( %局所~名, %旧-値, %値, %名前空間 )
に対し：
◎
For element reflected targets only: the following attribute change steps, given element, localName, oldValue, value, and namespace, are used to synchronize between the content attribute and the IDL attribute:
</p>
		<ol>
			<li>
~IF［
%局所~名 ~NEQ `内容~属性~名$V
］~OR［
%名前空間 ~NEQ ~NULL
］
⇒
~RET
◎
If localName is not attr or namespace is not null, then return.
</li>
			<li>
`~target$V の `内容~属性~名$V 用に`明示的に設定された要素~群$ ~SET ~NULL
◎
Set element's explicitly set attr-elements to null.
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
一貫性を得るため、
この型の`反映される~IDL属性$の識別子は，
`Elements^l で終端することが強く奨励される。
◎
Reflected IDL attributes of this type are strongly encouraged to have their identifier end in "Elements" for consistency.
</p>

			</section>
			<section id="using-reflect-in-specifications">
<h4 title="Using reflect in specifications">2.6.2. 仕様における反映-の利用-法</h4>

<p>
`反映$は、［
`反映される~IDL属性$を通して内容~属性への有型~accessを与える
］ことにより，
首に［
~web開発者にとっての易しさを改善する
］ためにある。
真実を成す最終的な~sourceは，内容~属性であり、
~web~platformは，それに基づいて築かれる。
すなわち、
仕様~策定者は，`反映される~IDL属性$を［
取得子~手続き／設定子~手続き
］に利用してはナラナイ
— 代わりに
当の内容~属性の有無と値
（または、
`列挙d属性$の状態など，その上層にある抽象-化）
を利用しなければナラナイ。
◎
Reflection is primarily about improving web developer ergonomics by giving them typed access to content attributes through reflected IDL attributes. The ultimate source of truth, which the web platform builds upon, is the content attributes themselves. That is, specification authors must not use the reflected IDL attribute getter or setter steps, but instead must use the content attribute presence and value. (Or an abstraction on top, such as the state of an enumerated attribute.)
</p>

<p>
これには、
2 つの重要な例外
— `反映される~IDL属性$が次に挙げるいずれかの型である場合 —
がある：
◎
Two important exceptions to this are reflected IDL attributes whose type is one of the following:
</p>
<ul>
	<li>
<code>%T?</code> 型で，
%T は `Element$I または それを継承する~interfaceである
◎
T?, where T is either Element or an interface that inherits from Element
</li>
	<li>
<code>`FrozenArray$&lt;%T&gt;?</code> 型で，
%T は `Element$I または それを継承する~interfaceである
◎
FrozenArray&lt;T&gt;?, where T is either Element or an interface that inherits from Element
</li>
</ul>

<p>
これらに対しては、
仕様~策定者は，`反映される~target$の［
`内容~属性~名$V に［
`結付けられた要素を取得する~algo$／
`結付けられた要素~群を取得する~algo$
］
~algo
］（同順）を利用しなければナラナイ。
当の内容~属性の有無と値は、
当の`反映される~IDL属性$と全部的には同期し得ないので，利用してはナラナイ。
◎
For those, specification authors must use the reflected target's attr-associated element and attr-associated elements, respectively. The content attribute presence and value must not be used as they cannot be fully synchronized with the reflected IDL attribute.
</p>

<p>
`反映される~target$の［
`内容~属性~名$V 用に［
`明示的に設定された要素$,
`明示的に設定された要素~群$,
`~cacheした要素~群$
］］は、
実装の内部的な詳細として扱われる
— 【~web~platformが，】それらに基づいて築かれることはない。
◎
A reflected target's explicitly set attr-element, explicitly set attr-elements, and cached attr-associated elements are to be treated as internal implementation details and not to be built upon.
</p>

			</section>
			<section id="collections">
<h4 title="Collections">2.6.3. ~collection</h4>

<p>
［
`HTMLFormControlsCollection$I ／
`HTMLOptionsCollection$I
］~interfaceは、
`HTMLCollection$I ~interfaceから派生した`~collection$である。
`HTMLAllCollection$I ~interfaceは、
`~collection$であるが，そのように派生されるものではない。
◎
The HTMLFormControlsCollection and HTMLOptionsCollection interfaces are collections derived from the HTMLCollection interface. The HTMLAllCollection interface is a collection, but is not so derived.
</p>

				<section id="_collections-common-defs">
<h5 class="trans-note">2.6.3.X. 共通な定義</h5>

<p class="trans-note">【
この節は、
共通な記述を集約するために，この訳に導入している。
】</p>

<p>
所与の［
`HTMLFormControlsCollection$I ／
`HTMLOptionsCollection$I
］~obj %C に対し：
</p>

<ul>
	<li>
“%N 番” という表記は、
%C により`表現され$る要素のうち，`~tree順序$で
( %N ~PLUS 1 )
個目にある~nodeを指す。
</li>
	<li class="algo">
<p>
所与の文字列 %name に
`~IDか名前が一致する要素~群@
は
⇒
~RET ［
%C により`表現され$る要素のうち ~OR↓ を満たすもの
］たちが成す`~tree順序$による~list：
</p>
		<ul>
			<li>
`id$a 属性を有していて その値 ~EQ %name
</li>
			<li>
`name$a 属性を有していて その値 ~EQ %name
</li>
		</ul>
	</li>
	<li class="algo">
<p>
%C が
`~supportする~prop名を収集する@
ときは、
次を走らす：
</p>
		<ol>
			<li>
%名前~群 ~LET 新たな`有順序~集合$
</li>
			<li>
<p>
%C により`表現され$る ~EACH ( %要素 ) に対し，`~tree順序$で：
</p>
				<ol>
					<li>
~IF［
%要素 は `id$a 属性を有する
］~AND［
その値 %V ~NEQ 空~文字列
］
⇒
%名前~群 に %V を`付加する$set
</li>
					<li>
~IF［
%要素 は `name$a 属性を有する
］~AND［
その値 %V ~NEQ 空~文字列
］
⇒
%名前~群 に %V を`付加する$set
</li>
				</ol>
			</li>
			<li>
~RET %名前~群
</li>
		</ol>
	</li>
</ul>

<p>
`name@a
属性は、［
`option$e 要素に対しては，その `name＠~HTMLobs#attr-option-name$a 属性 ／
他の要素に対しては，その `name＠~HTMLforms#attr-fe-name$a 属性
］を指すとする。
</p>

<p>
`新たな空option@
とは、
新たに作成される `option$e 要素であって，属性も子~nodeも伴わないものとする。
</p>

				</section>
				<section id="the-htmlallcollection-interface">
<h5 title="The HTMLAllCollection interface">2.6.3.1. `HTMLAllCollection^I ~interface</h5>

<p class="trans-note">【
この節
（旧来の特能 `document.all$c ~~専用の~interface）は、
未訳。
】</p>

				</section>
				<section id="the-htmlformcontrolscollection-interface">
<h5 title="The HTMLFormControlsCollection interface">2.6.3.2. `HTMLFormControlsCollection^I ~interface</h5>

<p>
`HTMLFormControlsCollection$I ~interfaceは `form$e 要素~内に`~listされる要素$たちが成す`~collection$に利用される。
◎
The HTMLFormControlsCollection interface is used for collections of listed elements in form elements.
</p>

<pre class="idl">
[Exposed=Window]
interface `HTMLFormControlsCollection@I : `HTMLCollection$I {
  // <span class="comment">`~length0$m, `item()$m を継承する</span>
  getter (`RadioNodeList$I or `Element$I)? `namedItem$m(DOMString name); // <span class="comment">継承された `~namedItem0()$m を隠蔽する</span>
};

[Exposed=Window]
interface `RadioNodeList@I : `NodeList$I {
  attribute DOMString `value$m;
};</pre>

<dl class="domintro">

	<dt>%collection.`length$m</dt>
	<dd>
%collection 内の要素の個数を返す。
◎
Returns the number of elements in collection.
</dd>

	<dt>%element = %collection.`item(index)$m</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
%collection 内の %index 番の~itemを返す。
~itemたちは、
`~tree順序$で~sortされる。
◎
Returns the item at index index in collection. The items are sorted in tree order.
</dd>

	<dt>%element = %collection.`namedItem(name)$m</dt>
	<dt>%radioNodeList = %collection.`namedItem(name)$m</dt>
	<dt>%element = %collection[%name]</dt>
	<dt>%radioNodeList = %collection[%name]</dt>
	<dd>
%collection 内の %name に`~IDか名前が一致する要素~群$を返す。
◎
Returns the item with ID or name name from collection.
</dd>
	<dd>
合致する要素が複数ある場合、
それらすべてからなる `RadioNodeList$I ~objが返される。
◎
If there are multiple matching items, then a RadioNodeList object containing all those elements is returned.
</dd>

	<dt>%radioNodeList.`value$m</dt>
	<dd>
［
%radioNodeList により表現される各~radio~buttonのうち，
~checkされているもののうち，
最初のもの
］の値を返す。
◎
Returns the value of the first checked radio button represented by radioNodeList.
</dd>

	<dt>%radioNodeList.`value$m = %value</dt>
	<dd>
［
%radioNodeList により表現される各~radio~buttonのうち，
【`value$a の】値に %value を伴うもののうち，
最初のもの
］を~checkする。
◎
Checks the first radio button represented by radioNodeList that has value value.
</dd>
</dl>

<p>
`HTMLFormControlsCollection$I ~obj %C に対しては：
</p>

<ul>
	<li>
%C が`~supportする~prop~index$は、
`HTMLCollection$I ~obj用に定義されるそれになる。
◎
The object's supported property indices are as defined for HTMLCollection objects.
</li>
	<li>
%C が`~supportする~prop名$は、
その時点における次の結果として定義される
⇒
%C が`~supportする~prop名を収集する$()
◎
The supported property names consist of the non-empty values of all the id and name attributes of all the elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.
</li>
</ul>

<div class="algo">
<p>
`namedItem(name)@m
~method手続きは：
◎
The namedItem(name) method must act according to the following algorithm:
</p>
<ol>
	<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If name is the empty string, return null and stop the algorithm.
</li>
	<li>
%要素~群 ~LET コレ内の %name に`~IDか名前が一致する要素~群$
◎
↓</li>
	<li>
~RET %要素~群 の`~size$に応じて
⇒＃
0 ならば ~NULL ／
1 ならば %要素~群[ 0 ]
2 以上ならば %要素~群 の~viewを表現する，新たな`~live$な `RadioNodeList$I ~obj
◎
If, at the time the method is called, there is exactly one node in the collection that has either an id attribute or a name attribute equal to name, then return that node and stop the algorithm.
◎
Otherwise, if there are no nodes in the collection that have either an id attribute or a name attribute equal to name, then return null and stop the algorithm.
◎
Otherwise, create a new RadioNodeList object representing a live view of the HTMLFormControlsCollection object, further filtered so that the only nodes in the RadioNodeList object are those that have either an id attribute or a name attribute equal to name. The nodes in the RadioNodeList object must be sorted in tree order.
◎
Return that RadioNodeList object.
</li>
</ol>
</div>

<hr>

<p>
`RadioNodeList$I ~interfaceが `NodeList$I ~interfaceから継承する~memberは、
`NodeList$I ~obj上にあるかのように挙動するモノトスル。
◎
Members of the RadioNodeList interface inherited from the NodeList interface must behave as they would on a NodeList object.
</p>

<div>
<p>
`value$m ~IDL属性の目的においては、
次が定義される：
</p>
<ul>
	<li class="algo">
<p>
所与の
( 要素に関する条件 %条件 )
の下で， `RadioNodeList$I ~obj %O 内の
`要素を見出す^i
ときは：
</p>
		<ol>
			<li>
<p>
~IF［
%O により`表現され$る要素のうち ~AND↓ を満たすものは在る
］…
</p>
				<ul>
					<li>
`input$e 要素である
</li>
					<li>
`type$a 属性は `Radio$st 状態にある
</li>
					<li>
%条件 を満たす
</li>
				</ul>
<p>
…ならば
⇒
~RET 該当する要素のうち，`~tree順序$で最初の要素
</p>
			</li>
			<li>
~RET ε
</li>
		</ol>
	</li>
	<li class="algo">
所与の要素の `value^i は
⇒
~RET 要素は `value$a 内容~属性を［
有するならば その値 ／
有さないならば文字列 `on^l
］
</li>
</ul>

<p class="trans-note">【
これらの定義は、
以下を簡潔に表現するために，この訳に導入している。
】</p>
◎
↓</div>

<div class="algo">
<p>
`value@m 取得子~手続きは：
◎
The value IDL attribute on the RadioNodeList object, on getting, must return the value returned by running the following steps:
</p>
<ol>
	<li>
%要素 ~LET 次の条件の下で，コレ内の`要素を見出す^i
⇒
要素の`~check有りか$fe ~EQ ~T
◎
Let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose checkedness is true. Otherwise, let it be null.
</li>
	<li>
~IF［
%要素 ~EQ ε
］
⇒
~RET ~NULL
◎
If element is null, return the empty string.
</li>
	<li>
~RET %要素 の `value^i
◎
If element is an element with no value attribute, return the string "on".
◎
Otherwise, return the value of element's value attribute.
</li>
</ol>
</div>

<div class="algo">
<p>
`value$m 設定子~手続きは：
◎
On setting, the value IDL attribute must run the following steps:
</p>
<ol>
	<li>
%要素 ~LET 次の条件の下で，コレ内の`要素を見出す^i
⇒
要素の `value^i ~EQ 所与の値
◎
If the new value is the string "on": let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose value content attribute is either absent, or present and equal to the new value, if any. If no such element exists, then instead let element be null.
◎
Otherwise: let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose value content attribute is present and equal to the new value, if any. If no such element exists, then instead let element be null.
</li>
	<li>
~IF［
%要素 ~NEQ ε
］
⇒
%要素 の `~check有りか$fe ~SET ~T
◎
If element is not null, then set its checkedness to true.
</li>
</ol>
</div>

				</section>
				<section id="the-htmloptionscollection-interface">
<h5 title="The HTMLOptionsCollection interface">2.6.3.3. `HTMLOptionsCollection^I ~interface</h5>

<p>
`HTMLOptionsCollection$I ~interfaceは、
`option$e 要素たちが成す`~collection$に利用される。
その根は，常に `select$e 要素になり、
その子孫を操作する属性や~methodを備える。
◎
The HTMLOptionsCollection interface is used for collections of option elements. It is always rooted on a select element and has attributes and methods that manipulate that element's descendants.
</p>

<pre class="idl">
[Exposed=Window]
interface `HTMLOptionsCollection@I : `HTMLCollection$I {
  // <span class="comment">`item()$m, `~namedItem0()$m を継承する</span>
  [`CEReactions$] attribute unsigned long `length$m; // <span class="comment">継承された `~length0$m を隠蔽する</span>
  [`CEReactions$] `setter$m undefined (unsigned long index, `HTMLOptionElement$I? option);
  [`CEReactions$] undefined `add$m((`HTMLOptionElement$I or `HTMLOptGroupElement$I) element, optional (`HTMLElement$I or long)? before = null);
  [`CEReactions$] undefined `remove$m(long index);
  attribute long `selectedIndex$m;
};</pre>

<dl class="domintro">

	<dt>%collection.`length$m</dt>
	<dd>
%collection 内の要素の個数を返す。
◎
Returns the number of elements in collection.
</dd>

	<dt>%collection.`length$m = %value</dt>
	<dd>
<p>
%N を
( %value ~MINUS %collection 内の要素の個数 )
とするとき：
◎
↓</p>
		<ul>
			<li>
%N ~LT 0 の場合、
%collection の根~内から最後の ( − %N ) 個の `option$e 要素を切落す。
◎
When set to a smaller number than the existing length, truncates the number of option elements in the container corresponding to collection.
</li>
			<li>
%N ~GT 0 の場合、
%N ~LTE 100000 ならば，
%collection の根~内に %N 個の`新たな空option$を追加する。
◎
When set to a greater number than the existing length, if that number is less than or equal to 100000, adds new blank option elements to the container corresponding to collection.
</li>
		</ul>
	</dd>

	<dt>%element = %collection.`item(index)$m</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
%collection を成す %index 番の~itemを返す。
~itemたちは、
`~tree順序$で~sortされる。
◎
Returns the item at index index in collection. The items are sorted in tree order.
</dd>

	<dt>%collection[%index] = %element</dt>
	<dd>
%index ~GT ( %collection を成す~itemの個数 )
の場合、
%collection の根~内に`新たな空option$を追加する。
◎
When index is a greater number than the number of items in collection, adds new blank option elements in the corresponding container.
</dd>
	<dd>
%element ~EQ ~NULL の場合、
%collection から %index 番の~itemを除去する。
◎
When set to null, removes the item at index index from collection.
</dd>
	<dd>
%element が `option$e 要素である場合、
%element を %collection の %index 番の~item［
として %element を追加する／
を %element に置換する
］。
◎
When set to an option element, adds or replaces it at index index in collection.
</dd>

	<dt>%element = %collection.`namedItem(name)$m</dt>
	<dt>%element = %collection[%name]</dt>
	<dd>
［
%collection 内の %name に`~IDか名前が一致する要素~群$
］を成す最初の要素を返す。
◎
Returns the item with ID or name name from collection.
◎
If there are multiple matching items, then the first is returned.
</dd>

	<dt>%collection.`add(element [, before ] )$m</dt>
	<dd>
<p>
%before 引数が指す~nodeの前に %element を挿入する
— %element は、
%before に応じて，次に与える箇所に挿入される：
</p>
		<ul class="switch">
			<li>
数の場合
⇒
%collection 内の %before 番の~itemの前
</li>
			<li>
%collection 内の要素である場合
⇒
その要素の前
</li>
			<li>
［
省略されている ／ ~NULL ／ 範囲~外の数である
］場合
⇒
%collection を成す~listの末尾
</li>
		</ul>
◎
Inserts element before the node given by before.
◎
The before argument can be a number, in which case element is inserted before the item with that number, or＼
◎
an element from collection, in which case element is inserted before that element.
◎
If before is omitted, null, or a number out of range, then element will be added at the end of the list.
</dd>
	<dd>
%element が 挿入-先の要素（ %collection の根）の先祖である場合、
`HierarchyRequestError$E を投出する。
◎
Throws a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.
</dd>
	<dd class="trans-note">【
%before が %collection 内に無い要素である場合、
`NotFoundError$E を投出する。
】</dd>

	<dt>%collection.`remove(index)$m</dt>
	<dd>
%collection から %index 番の~itemを除去する。
◎
Removes the item with index index from collection.
</dd>

	<dt>%collection.`selectedIndex$m</dt>
	<dd>
選択されている~itemは［
在るならば それらのうち最初の~itemの~index ／
無いならば −1
］を返す。
◎
Returns the index of the first selected item, if any, or −1 if there is no selected item.
</dd>

	<dt>%collection.`selectedIndex$m = %index</dt>
	<dd>
選択を［
%collection の %index 番の `option$e 要素
］に変更する。
◎
Changes the selection to the option element at index index in collection.
</dd>
</dl>

<p>
`HTMLOptionsCollection$I ~objが`~supportする~prop~index$は、
`HTMLCollection$I ~objに対し定義されるそれになる。
◎
The object's supported property indices are as defined for HTMLCollection objects.
</p>

<div class="algo">
`length@m
取得子~手続きは
⇒
~RET コレにより`表現され$る~nodeの個数
◎
The length getter steps are to return the number of nodes represented by the collection.
</div>

<div class="algo">
<p>
`length$m 設定子~手続きは：
◎
The length setter steps are:
</p>
<ol>
	<li>
%個数差 ~LET 所与の値 ~MINUS ( コレにより`表現され$る~nodeの個数 )
◎
Let current be the number of nodes represented by the collection.
</li>
	<li>
<p>
~IF［
%個数差 ~GT 0
］：
◎
If the given value is greater than current, then:
</p>
		<ol>
			<li>
~IF［
所与の値 ~GT 100000
］
⇒
~RET
◎
If the given value is greater than 100,000, then return.
</li>
			<li>
コレの根である `select$e 要素に［
%個数差 個の`新たな空option$
］を付加した上で、［
これらの空optionを包含する `DocumentFragment$I
］が挿入されたかのように，変異~eventを発火する
◎
↑↑Let n be value − current.
◎
Append n new option elements with no attributes and no child nodes to the select element on which this is rooted. Mutation events must be fired as if a DocumentFragment containing the new option elements had been inserted.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%個数差 ~LT 0
］
⇒
コレにより`表現され$る~nodeのうち，最後の（ − %個数差 ）個を各自の親~nodeから除去する
◎
If the given value is less than current, then:
• ↑↑Let n be current − value.
• Remove the last n nodes in the collection from their parent nodes.
</ol>

<p class="note">注記：
`optgroup$e 要素に関しては、
`length$m に何かを設定しても，（根である `select$e 要素~内で）［
それが除去される ／ それが追加される ／ それに新たな子が追加される
］ことは決してない（それの子は除去され得るが）。
◎
Setting length never removes or adds any optgroup elements, and never adds new children to existing optgroup elements (though it can remove children from them).
</p>
</div>

<p>
`HTMLOptionsCollection$I ~obj %C が`~supportする~prop名$は、
その時点における次の結果として定義される
⇒
%C が`~supportする~prop名を収集する$()
◎
The supported property names consist of the non-empty values of all the id and name attributes of all the elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.
</p>

<div class="algo">
<p id="dom-htmloptionscollection-setter">
`HTMLOptionsCollection$I ~obj %C 用の［
`新たな有index~propを設定する手続き$ ／
`既存の有index~propを設定する手続き$
］は、
所与の
( 負でない整数 %~index, 新たな値 %値 )
に対し，次を走らすモノトスル：
◎
When the user agent is to set the value of a new indexed property or set the value of an existing indexed property for a given property index index to a new value value, it must run the following algorithm:
</p>
<ol>
	<li>
<p>
~IF［
%値 ~EQ ~NULL
］
⇒＃
%C 上の `remove$m ~method手続き( %~index )；
~RET
◎
If value is null, invoke the steps for the remove method with index as the argument, and return.
</li>
	<li>
%select ~LET %C の根である `select$e 要素
◎
↓</li>
	<li>
%n ~LET %~index ~MINUS ( %C により`表現され$る~nodeの個数 )
◎
Let length be the number of nodes represented by the collection.
◎
Let n be index minus length.
</li>
	<li>
<p>
~IF［
%n ~GT 0
］：
</p>
		<ol>
			<li>
%文書片 ~LET 新たな `DocumentFragment$I
</li>
			<li>
%文書片 の`子~群$ ~SET ( %n ~MINUS 1 ) 個の`新たな空option$たちが成す集合
</li>
			<li>
%select に`~nodeを付加する$( %文書片 )
</li>
		</ol>
◎
If n is greater than zero, then append a DocumentFragment consisting of n-1 new option elements with no attributes and no child nodes to the select element on which the HTMLOptionsCollection is rooted.
</li>
	<li>
~IF［
%n ~GTE 0
］
⇒
%select に`~nodeを付加する$( %値 )
◎
If n is greater than or equal to zero, append value to the select element.＼
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%要素 ~LET %C 内の %~index 番の要素
</li>
			<li>
%親 ~LET %要素 の親
</li>
			<li>
%親 の中で`子を~nodeに置換する$( %要素, %値 )
</li>
		</ol>

<p class="trans-note">【
原文は %親 として何を与えるか述べられていない
（ %親 は %select, `optgroup$e どちらもあり得る）。
】</p>

◎
Otherwise, replace the indexth element in the collection by value.
</li>
</ol>
</div>

<div class="algo">
<p>
`add(element, before)@m
~method手続きは：
◎
The add(element, before) method must act according to the following algorithm:
</p>
<ol>
	<li>
%select ~LET コレの根である `select$e 要素
◎
↓</li>
	<li>
~IF［
%element は %select の先祖である
］
⇒
~THROW `HierarchyRequestError$E
◎
If element is an ancestor of the select element on which the HTMLOptionsCollection is rooted, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
<p>
~IF［
%before は要素である
］：
◎
If before is an element,＼
</p>
		<ol>
			<li>
~IF［
%before は %select の子孫でない
］
⇒
~THROW `NotFoundError$E
◎
but that element isn't a descendant of the select element on which the HTMLOptionsCollection is rooted, then throw a "NotFoundError" DOMException.
</li>
			<li>
~IF［
%element ~EQ %before
］
⇒
~RET
◎
If element and before are the same element, then return.
</li>
		</ol>
	</li>
	<li>
~ELSE（ %before は整数である）
⇒
%before ~SET ［
コレ内に %before 番の~nodeは在るならば それ ／
~ELSE_ ~NULL
］
◎
If before is a node, then let reference be that node. Otherwise, if before is an integer, and there is a beforeth node in the collection, let reference be that node. Otherwise, let reference be null.
</li>
	<li>
%親 ~LET［
%before ~NEQ ~NULL ならば %before の親~node ／
~ELSE_ %select
］
◎
If reference is not null, let parent be the parent node of reference. Otherwise, let parent be the select element on which the HTMLOptionsCollection is rooted.
</li>
	<li>
%親 の中で`~nodeを子の前に前挿入する$( %element, %before )
◎
Pre-insert element into parent node before reference.
</li>
</ol>
</div>

<div class="algo">
`remove(index)@m
~method手続きは
⇒
~IF［
0 ~LTE %index ~LT ( コレにより`表現され$る~nodeの個数 )
］
⇒
コレ内の %index 番の要素をその親から除去する
◎
The remove(index) method must act according to the following algorithm:
• If the number of nodes represented by the collection is zero, return.
• If index is not a number greater than or equal to 0 and less than the number of nodes represented by the collection, return.
• Let element be the indexth element in the collection.
• Remove element from its parent node.
</div>

<div class="algo">
`selectedIndex@m
取得子~手続きは
⇒
~RET コレの根である `select$e 要素~上の
`~selectedIndex0$m 取得子~手続き()
◎
The selectedIndex IDL attribute must act like the identically named attribute on the select element on which the HTMLOptionsCollection is rooted
</div>

				</section>
			</section>
			<section id="the-domstringlist-interface">
<h4 title="The DOMStringList interface">2.6.3. `DOMStringList^I ~interface</h4>

<p>
`DOMStringList$I ~interfaceは、
文字列の~listを昔風の仕方で表現する。
◎
The DOMStringList interface is a non-fashionable retro way of representing a list of strings.
</p>

<pre class="idl">
[Exposed=(Window,Worker)]
interface `DOMStringList@I {
  readonly attribute unsigned long `length$sL;
  getter DOMString? `item$sL(unsigned long %index);
  boolean `contains$sL(DOMString %string);
};</pre>

<p class="warning">
新たな~APIは、
`DOMStringList$I ではなく，
`sequence&lt;DOMString&gt;^c または それに等価なものを利用しなければナラナイ。
◎
New APIs must use sequence&lt;DOMString&gt; or equivalent rather than DOMStringList.
</p>

<dl class="domintro">
	<dt>%strings.`length$sL</dt>
	<dd>
%strings が包含している文字列の個数を返す。
◎
Returns the number of strings in strings.
</dd>

	<dt>%strings[%index]</dt>

	<dt>%strings.`item(index)$sL</dt>
	<dd>
%strings 内の~index %index 番の文字列を返す。
◎
Returns the string with index index from strings.
</dd>

	<dt>%strings.`contains(string)$sL</dt>
	<dd>
%strings が %string を［
包含するならば ~T ／
~ELSE_ ~F
］を返す
◎
Returns true if strings contains string, and false otherwise.
</dd>
</dl>

<p>
各 `DOMStringList$I ~objには、
`文字列~list@
が結付けられる
— それは、
文字列たちが成す`~list$である。
◎
Each DOMStringList object has an associated list.
</p>

<p>
`DOMStringList$I ~obj %O が所与の時点で`~supportする~prop~index$は、
%O の`文字列~list$の`~index群$とする。
◎
The DOMStringList interface supports indexed properties. The supported property indices are the indices of this's associated list.
</p>

<div class="algo">
`length@sL
取得子~手続きは
⇒
~RET コレの`文字列~list$の`~size$
◎
The length getter steps are to return this's associated list's size.
</div>

<div class="algo">
<p>
`item(index)@sL
~method手続きは：
</p>
<ol>
	<li>
~IF［
%index ~LT コレの`文字列~list$の`~size$
］
⇒
~RET ~NULL
</li>
	<li>
~RET コレの`文字列~list$[ %index ]
</li>
</ol>
◎
The item(index) method steps are to return the indexth item in this's associated list, or null if index plus one is greater than this's associated list's size.
</div>

<div class="algo">
`contains(string)@sL
~method手続きは
⇒
~RET ~IS［
%string ~IN コレの`文字列~list$
］
◎
The contains(string) method steps are to return true if this's associated list contains string, and false otherwise.
</div>

			 </section>
		</section>
</main>
