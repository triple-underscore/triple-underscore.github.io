<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 9112 — HTTP/1.1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP/1.1
	spec_date:2022-06-06
trans_update:2022-06-10
source_checked:220606
page_state_key:HTTP
original_url:https://httpwg.org/specs/rfc9112.html
abbr_url:HTTPv1
spec_status:IETFSTD
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●mdn_urls
field.transfer-encoding:HTTP/Headers/Transfer-Encoding
compatibility.with.http.1.0.persistent.connections:HTTP/Headers/Keep-Alive
	mime-version:HTTP/Headers/MIME-Version

●●link_map

h.MIME-Version:#mime-version
h.Keep-Alive:#compatibility.with.http.1.0.persistent.connections
	h.Proxy-Connection:#compatibility.with.http.1.0.persistent.connections
h.Content-Transfer-Encoding:~RFCx/rfc2045#section-6
	h.Close:#field.close

c.close:#close-connection-option
c.1.1:#version-1.1
c.trailers:~HTTPsem#_trailers-token
c.keep-alive:~HTTPv1#compatibility.with.http.1.0.persistent.connections
c.message/http:~HTTPv1#media.type.message.http
c.application/http:~HTTPv1#media.type.application.http

p.Connection:~HTTPsem#p.Connection

p.HTTP-message:~HTTPv1#p.HTTP-message
p.HTTP-name:~HTTPv1#p.HTTP-name
p.HTTP-version:~HTTPv1#p.HTTP-version
p.Transfer-Encoding:~HTTPv1#p.Transfer-Encoding
p.absolute-form:~HTTPv1#p.absolute-form
p.asterisk-form:~HTTPv1#p.asterisk-form
p.authority-form:~HTTPv1#p.authority-form
p.chunk:~HTTPv1#p.chunk
p.chunk-data:~HTTPv1#p.chunk-data
p.chunk-ext:~HTTPv1#p.chunk-ext
p.chunk-ext-name:~HTTPv1#p.chunk-ext-name
p.chunk-ext-val:~HTTPv1#p.chunk-ext-val
p.chunk-size:~HTTPv1#p.chunk-size
p.chunked-body:~HTTPv1#p.chunked-body
p.field-line:~HTTPv1#p.field-line
p.last-chunk:~HTTPv1#p.last-chunk
p.message-body:~HTTPv1#p.message-body
p.method:~HTTPv1#p.method
p.obs-fold:~HTTPv1#p.obs-fold
p.origin-form:~HTTPv1#p.origin-form
p.reason-phrase:~HTTPv1#p.reason-phrase
p.request-line:~HTTPv1#p.request-line
p.request-target:~HTTPv1#p.request-target
p.start-line:~HTTPv1#p.start-line
p.status-code:~HTTPv1#p.status-code
p.status-line:~HTTPv1#p.status-line
p.trailer-section:~HTTPv1#p.trailer-section


空~行l:~HTTPv1#empty-line
応答待ち要請:~HTTPv1#outstanding-request

~message本体:#message-body
~message本体の長さ:~HTTPv1#message.body.length

~chunked:~HTTPv1#chunked.encoding
~chunked転送~符号法:~HTTPv1#chunked.encoding
~chunk拡張:~HTTPv1#chunked.extension
~version:~HTTPv1#http.version
~protocol~version:~HTTPv1#http.version

	圧縮~符号法:~HTTPv1#compression.codings

持続的な接続:~HTTPv1#persistent.connections
最終-転送~符号法:~HTTPv1#final-transfer-coding
転送~符号法の名前:~HTTPv1#transfer-coding-name
本体~長さ:~HTTPv1#body-length
応答~分割:~HTTPv1#response.splitting
要請~密入:~HTTPv1#request.smuggling

接続~option:~HTTPsem#connection-option

権限的:~HTTPinfra#authoritative

	●§
~messageの構文解析-法:#message.parsing

1:#introduction
1.1:#requirements.notation
1.2:#notation
2:#http.message
2.1:#message.format
2.2:#message.parsing
2.3:#http.version
3:#request.line
3.1:#request.method
3.2:#request.target
3.2.1:#origin-form
3.2.2:#absolute-form
3.2.3:#authority-form
3.2.4:#asterisk-form
3.3:#reconstructing.target.uri
4:#status.line
5:#header.field.syntax
5.1:#field.parsing
5.2:#line.folding
6:#message.body
6.1:#field.transfer-encoding
6.2:#body.content-length
6.3:#message.body.length
7:#transfer.codings
7.1:#chunked.encoding
7.1.1:#chunked.extension
7.1.2:#chunked.trailer.section
7.1.3:#decoding.chunked
7.2:#compression.codings
7.3:#transfer.coding.registry
7.4:transfer.coding.negotiation
8:#incomplete.messages
9:#connection.management
9.1:#persistent.establishment
9.2:#associating.response.to.request
9.3:#persistent.connections
9.3.1:#persistent.retrying.requests
9.3.2:#pipelining
9.4:#persistent.concurrency
9.5:#persistent.failures
9.6:#persistent.tear-down
9.7:#tls.connection.initiation
9.8:#tls.connection.closure
10:#enclosing.messages
10.1:#media.type.message.http
10.2:#media.type.application.http
11:#security.considerations
11.1:#response.splitting
11.2:#request.smuggling
11.3:#message.integrity
11.4:#message.confidentiality
12:#IANA.considerations
12.1:#field.name.registration
12.2:#media.type.http
12.3:#transfer.coding.registration
12.4:#upgrade.token.registration
13:#rfc.references

A:#collected.abnf
B:#differences.between.http.and.mime
B.1:#mime-version
B.2:#conversion.to.canonical.form
B.3:#conversion.of.date.formats
B.4:#conversion.of.content-encoding
B.5:#conversion.of.content-transfer-encoding
B.6:#mhtml.line.length
C:#changes
C.1:#changes.from.0.9
C.2:#changes.from.1.0
C.2.1:#changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses
C.2.2:#compatibility.with.http.1.0.persistent.connections
C.2.3:#introduction.of.transfer-encoding
C.3:#changes.from.rfc.7230

著作者の~address:#rfc.authors

cite.~HTTP転送~符号法~registry:~IANA-a/http-parameters#transfer-coding
	:~IANA-a/http-parameters/

	既定の~TCP~port
	p.userinfo:3986#section-3.2.1

●●section_map

	rfc.abstract
	rfc.authors
	rfc.copyrightnotice
	rfc.index
	rfc.note.1
	rfc.status



●●words_table1

●●words_table

	●仕様
場当的:ad hoc:場当たり的
仮想:virtual::~
公正:fair:~
寛容:lenient:~
精査:examination:~
悪化-:exacerbate:~
普及-:prevalent:~
正当化:justify:~
濫用的:abusive:~
細工:craft:~
確立法:establishment::~
順位:rank:~
免除-:exempt:~
流儀:fashion:~
超越-:transcend:~
古代の:ancientな:~
際どい:edge:~
実効性:effectiveness:~
性向:nature:~
誤解釈-:misinterpret:~
見合う:reasonableな:~
取戻せ:reclaimでき:取り戻せ
自由度:freedom:~
	自由度を高める:greater freedom
頻繁:frequent:~
移行:transition::~
収まる:fitする:~
収容-:accommodate:~
過度:excessive:~
認知-:acknowledge:~
	認知されてない:unacknowledged
	認知-:acknowledgement of

	望ましくない:not desirable
	分野:areas
	~~確立:making
	備えておく:prepare
	用意はない:unwilling to
	疑いを示すもの:call into question
	目を向け:regard
	最低でも:at a minimum
	~~由来:out of deference to
	称され:referred to as
	見え難い:obscure
	見せかけ:look like／apparent
	読み易く:consistent readability
	適度に確かめられ:reasonably certain
	見込み:likelihood
	〜準拠な:-compliant
	に特有なそれ:specifics of
	超える:transcend
	失われ:lost
	目的をもって:purposefully
	照らし合わせて:in light of

	●保安
密入:smuggling::~
薬剤相互作用:drug interaction:薬の飲み合わせ
被害:damage:~
迂回-:bypass:~
checksum::::チェックサム
分割:splitting:~

	晒され:expose
	信じ込ませる:believing

	●network
IP:
	HTTP/1.x
ALPN:
pipeline::::パイプライン
	~pipeline化:pipeline
	~pipeline化:pipelining
alert:
	相手の端点:peer
reset::::リセット
handshake::::ハンドシェイク
再符号され:recode::符号し直され::コードし直され
制限時間:timeout::~
梱包-:package:~
流れる:flowする:~
混雑-:congest:~
混雑:congestion:~
	混雑していない〜にも:otherwise uncongested
相互通信:interaction::~
解体:tear-down:~
	^en:head-of-line blocking
起動:initiation:~
到着-:arrive:~
応答待ち:outstanding::~
通過中:transit 中:~

	^i:ClientHello
	入って来る:incoming

	●構文
転化-:translate::~
不正形な:malformedな:不正な形の
US-ASCII:
終了子:terminator::~
	~~改行:line-ending
改行:line break:~
切落され:truncateされ:切り落とされ
	切落され:truncation
	桁:digit
数字列:numerals:~
折返さな:foldしな::~
折返し:folding::~

	前後:around
	前後:preface or follow
	0 個以上の:optional leading
	0 個以上の:optional trailing
	`CRLF$P の一部を成さない:bare

	●未分類
export:
MHTML:
UNIX:
digital::::デジタル
hung::::ハング
locale::::ロケール
multihomed:
multibyte::::マルチバイト
上位集合:superset::~::スーパーセット
	~~欠陥がある:faulty
付番方式:numbering scheme:~
保って:keepして:~
再整形:reformatting:~
医療:medical:~
幾千:thousands:~
後続-:follow:~
復唱:echo:~
一対一:one-to-one:~
数的:numeric:~
scale::::スケール
	~scaleが巨大:large-scale
識別情報:identity:~
破損-:corrupt:~
書込n:write::書き込み
書込め:writeでき::書き込め
符号変換:transcoding::~::トランスコーディング
集成-:aggregate:~
視る:viewする:~
発行-:issue:~

	base64
	sprintf

	●他の語（言い換え
	自動的に正して:autocorrect
	~frame法:framing
	内包する:inclusion
	抽出する:extraction
	文字大小無視:case-insensitively
	受容-可能でない:unacceptable
	回復-不能:unrecoverable
	圧縮-済み:compressed
	他にアテガって:reassign
	符号化-済み:encoded
	直近:immediate
	導入し直:reintroduce
	構築し直:reconstruct
	伝送し直:retransmit
	解釈し直:reinterpret
	格納-:storage
	書込n側のみ~close:half-close
	場合:potential
	可能性:potential
	終了させる:terminal
	〜なら無かった:would not have been present
	に対する:regarding
	他の場合:when the specific code is unrecognized

	●他の語
	一度:once
	増えて:increase
	それぞれに異なる:each has its own unique
	head-of-line blocking
	long polling
	~~上限:ceiling
	:concatenating
	以上の~version:or later
	欠損なく:intact
	まちまち:varying ways
	内包しない:missing
	締めくくる:conclude
	重い処理を要する:takes significant 〜 processing
	それ以上:no further
	~~各部:portions
	前もって:in advance
	半分:half
	より多数な:larger number of
	より少数な:fewer
	互いに:mutually
	のみ:alone
	こともある:occasionally
	突き止め:locate
	一連の:series of
	旧い:older

●●ref_key_map
TLS13:RFC8446
HTTP10:RFC1945

●●ref_normative
[CACHING]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Caching＞, STD 98, ~RFC9111, June 2022
    URL: https://httpwg.org/specs/rfc9111.html
[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
    URL: https://httpwg.org/specs/rfc9110.html
[RFC1950]
    Deutsch, P. and J-L. Gailly, ＜ZLIB Compressed Data Format Specification version 3.3＞, ~RFC1950, May 1996
[RFC1951]
    Deutsch, P., ＜DEFLATE Compressed Data Format Specification version 1.3＞, ~RFC1951, May 1996
[RFC1952]
    Deutsch, P., ＜GZIP file format specification version 4.3＞, ~RFC1952, May 1996
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC5234]
    Crocker, D., Ed. and P. Overell, ＜Augmented BNF for Syntax Specifications: ABNF＞, STD 68, ~RFC5234, January 2008
[RFC7405]
    Kyzivat, P., ＜Case-Sensitive String Support in ABNF＞, ~RFC7405, December 2014
[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[TLS13]
    Rescorla, E., ＜The Transport Layer Security (TLS) Protocol Version 1.3＞, ~RFC8446, August 2018
[URI]
    Berners-Lee, T., Fielding, R., and L. Masinter, ＜Uniform Resource Identifier (URI): Generic Syntax＞, STD 66, ~RFC3986, January 2005
[USASCII]
    American National Standards Institute, ＜Coded Character Set -- 7-bit American Standard Code for Information Interchange＞, ANSI X3.4, 1986.
[Welch]
    Welch, T., ＜A Technique for High-Performance Data Compression＞, IEEE Computer 17(6), June 1984
    URL: https://ieeexplore.ieee.org/document/1659158/

●●ref_informative
[HTTP/1.0]
    Berners-Lee, T., Fielding, R., and H. Frystyk, ＜Hypertext Transfer Protocol -- HTTP/1.0＞, ~RFC1945, May 1996
[Klein]
    Klein, A., ＜Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics＞, March 2004, URL: https://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf
[Linhart]
    Linhart, C., Klein, A., Heled, R., and S. Orrin, ＜HTTP Request Smuggling＞, June 2005, URL: https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf
[RFC2045]
    Freed, N. and N. Borenstein, ＜Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies＞, ~RFC2045, November 1996
[RFC2046]
    Freed, N. and N. Borenstein, ＜Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types＞, ~RFC2046, November 1996
[RFC2049]
    Freed, N. and N. Borenstein, ＜Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples＞, ~RFC2049, November 1996
[RFC2068]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T. Berners-Lee, ＜Hypertext Transfer Protocol -- HTTP/1.1＞, ~RFC2068, January 1997
[RFC2557]
    Palme, J., Hopmann, A., and N. Shelness, ＜MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)＞, ~RFC2557, March 1999
[RFC5322]
    Resnick, P., Ed., ~RFC5322, October 2008
[RFC7230]
    Fielding, R., Ed. and J. Reschke, Ed., ＜Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing＞, ~RFC7230, June 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, ＜Guidelines for Writing an IANA Considerations Section in RFCs＞, BCP 26, ~RFC8126, June 2017

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet Standard として公表された，
<a href="~SPEC_URL">HTTP/1.1</a>（RFC 9112）
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

公表者
	Internet Engineering Task Force (IETF)
RFC
	9112
廃用
	<a href="#RFC7230">7230</a>
分類
	Standards Track
日付
	2022 年 6 月
編集
	R. Fielding (Adobe)
	M. Nottingham (Fastly)
	J. Reschke (greenbytes)
履歴
	https://datatracker.ietf.org/doc/rfc9112/
現在の位置付け, 正誤表, フィードバックの方法
	https://www.rfc-editor.org/info/rfc9112
	（この訳には 2023-09-08 時点までの正誤表の内容（ Rejected 以外）も含めている）
</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP/1.1</h1>
<p>RFC 9112 — HTTP/1.1</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="rfc.abstract">
◎要約

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、
分散型の協調的な~hypertext情報~system用の，`~stateless$な応用~levelの~protocolである。
この文書は、
`~HTTP11$における［
~message構文, 構文解析, 接続の管理, 関係する~securityの懸念
］を指定する。
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document specifies the HTTP/1.1 message syntax, message parsing, connection management, and related security concerns.
</p>

<p>
この文書は、
~RFC 7230 を成す~~各部を廃用にする。
◎
This document obsoletes portions of RFC 7230.
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status$に移譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、［
~networkに基づく，~hypertext情報~system
］と柔軟にヤリトリするために［
拡張-可能な意味論, および自己-記述的な~message
］を利用する，`~stateless$な応用~levelの［
要請, 応答
］~protocolである。
`~HTTP11$は、
次により定義される
⇒＃
この文書,
`~HTTP意味論＠~HTTPinfra$ `HTTP$r,
`~HTTP~cache法＠~HTTPcache$ `CACHING$r,
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive messages for flexible interaction with network-based hypertext information systems. HTTP/1.1 is defined by:
• This document
• "HTTP Semantics" [HTTP]
• "HTTP Caching" [CACHING]
</p>

<p>
この文書は、
`~HTTP11$の［
~message構文, ~frame法, 接続~管理
］の仕組みを利用して，~HTTP意味論が どう伝達されるかを指定する。
その目標は、
~HTTP11~message［
の構文解析器／を回送している`媒介者$
］用の要件を成す完全な集合を定義することである。
◎
This document specifies how HTTP semantics are conveyed using the HTTP/1.1 message syntax, framing, and connection management mechanisms. Its goal is to define the complete set of requirements for HTTP/1.1 message parsers and message-forwarding intermediaries.
</p>

<p>
この文書は、
`RFC7230$r を成す［
~HTTP11~message法と接続~管理に関係する部位
］を廃用にする
— その変更点は、
`C.3§ に要約されている。
`RFC7230$r を成す他の各部は、
“~HTTP意味論” `HTTP$r により廃用にされた。
◎
This document obsoletes the portions of RFC 7230 related to HTTP/1.1 messaging and connection management, with the changes being summarized in Appendix C.3. The other parts of RFC 7230 are obsoleted by "HTTP Semantics" [HTTP].
</p>

		<section id="requirements.notation">
<h3 title="Requirements Notation">1.1. 要件の表記法</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
適合性の判定基準, ~errorの取扱いに関する考慮点は、
`HTTP$r `適合性§にて定義される。
◎
Conformance criteria and considerations regarding error handling are defined in Section 2 of [HTTP].
</p>

		</section>
		<section id="notation">
<h3 title="Syntax Notation">1.2. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
`~HTTP日本語訳 共通~page＠~HTTPcommon#syntax-notation$
に移譲。
】</p>

<p>
`A§ にて、
すべての~list演算子を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].
◎
It also uses a list extension, defined in Section 5.6.1 of [HTTP], that allows for compact definition of comma-separated lists using a "#" operator (similar to how the "*" operator indicates repetition).＼
◎
Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.
◎
As a convention, ABNF rule names prefixed with "obs-" denote obsolete grammar rules that appear for historical reasons.
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).
</p>

<p id="imported.rules">
次に挙げる規則は `HTTP$r にて定義される
⇒＃
`BWS$p,
`OWS$p,
`RWS$p,
`absolute-path$p,
`field-name$p,
`field-value$p,
`obs-text$p,
`quoted-string$p,
`token$p,
`transfer-coding$p
◎
The rules below are defined in [HTTP]:
• BWS           = &lt;BWS, see [HTTP], Section 5.6.3&gt;
• OWS           = &lt;OWS, see [HTTP], Section 5.6.3&gt;
• RWS           = &lt;RWS, see [HTTP], Section 5.6.3&gt;
• absolute-path = &lt;absolute-path, see [HTTP], Section 4.1&gt;
• field-name    = &lt;field-name, see [HTTP], Section 5.1&gt;
• field-value   = &lt;field-value, see [HTTP], Section 5.5&gt;
• obs-text      = &lt;obs-text, see [HTTP], Section 5.6.4&gt;
• quoted-string = &lt;quoted-string, see [HTTP], Section 5.6.4&gt;
• token         = &lt;token, see [HTTP], Section 5.6.2&gt;
• transfer-coding = &lt;transfer-coding, see [HTTP], Section 10.1.4&gt;
</p>

<p id="imported.uri.rules">
次に挙げる規則は `URI$r にて定義される
⇒＃
`absolute-URI$p,
`authority$p,
`uri-host$p,
`port$p,
`query$p
◎
The rules below are defined in [URI]:
• absolute-URI  = &lt;absolute-URI, see [URI], Section 4.3&gt;
• authority     = &lt;authority, see [URI], Section 3.2&gt;
• uri-host      = &lt;host, see [URI], Section 3.2.2&gt;
• port          = &lt;port, see [URI], Section 3.2.3&gt;
• query         = &lt;query, see [URI], Section 3.4&gt;
</p>

		</section>
	</section>
	<section id="http.message">
<h2 title="Message">2. ~message</h2>

<p>
~HTTP11［
`~client$, `~server$
］は、
~messageを送信することにより通信する。
~HTTPの一般的な各種用語と中核~概念は、
`HTTP$r `3＠~HTTPinfra#terminology§ を見よ。
◎
HTTP/1.1 clients and servers communicate by sending messages. See Section 3 of [HTTP] for the general terminology and core concepts of HTTP.
</p>

		<section id="message.format">
<h3 title="Message Format">2.1. ~message形式</h3>

<div class="p">
<p>
`~HTTP11$~messageは、
順に［
`start-line$p, `CRLF$P, ある~octet列
］からなる。
この~octet列は，
`Internet Message Format^cite `RFC5322$r に類似な形式であり、
次の並びからなる：
◎
An HTTP/1.1 message consists of a start-line followed by a CRLF and a sequence of octets in a format similar to the Internet Message Format [RFC5322]:＼
</p>
<ol>
	<li>
0 個以上の~header`~field行l$（総集的に`~header節$と称される）
◎
zero or more header field lines (collectively referred to as the "headers" or the "header section"),＼
</li>
	<li>
`~header節$の終端を指示する`空~行l$
◎
an empty line indicating the end of the header section, and＼
</li>
	<li>
省略可能な`~message本体$
◎
an optional message body.
</li>
</ol>
</div>

<pre class="bnf">
`HTTP-message@p
	= `start-line$p `CRLF$P
	  *( `field-line$p `CRLF$P )
	  <dfn id="empty-line">CRLF</dfn>
	  [ `message-body$p ]
</pre>

<div class="p">
<p>
~messageは、［
`~client$から`~server$へ流れる要請
］か［
`~server$から`~client$へ流れる応答
］のいずれかになる。
この 2 つの型の~messageは、
次に挙げるものに限り相違する：
◎
A message can be either a request from client to server or a response from server to client. Syntactically, the two types of messages differ only in＼
</p>
<ul>
	<li>
`start-line$p の構文は［
要請~用には `request-line$p ／
応答~用には `status-line$p
］になる。
◎
the start-line, which is either a request-line (for requests) or＼
</li>
	<li>
`~message本体$の長さを決定する~algo。
◎
a status-line (for responses), and in the algorithm for determining the length of the message body (Section 6).
</li>
</ul>
</div>

<pre class="bnf">
`start-line@p
	= `request-line$p
	/ `status-line$p
</pre>

<p class="trans-note">【
これは、
~messageの “最初の行l（ `first line^en ）” とも称される。
】</p>

<p>
理論~上は、
`~client$も要請を受信でき, `~server$も応答を受信できる
— それらは `start-line$p 形式の相違から判別できるので。
実施においては、
~serverは，要請のみを期待するように実装され
（応答は，未知または妥当でない`要請~method$と解釈される）、
~clientは，応答のみを期待するように実装されている。
◎
In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats. In practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method), and clients are implemented to only expect a response.
</p>

<p>
~HTTPは `RFC2045$r に類似な いくつかの~protocol要素を用立てる。
~HTTPと~MIME~messageとの相違点は `B§ を見よ。
◎
HTTP makes use of some protocol elements similar to the Multipurpose Internet Mail Extensions (MIME) [RFC2045]. See Appendix B for the differences between HTTP and MIME messages.
</p>

		</section>
		<section id="message.parsing">
<h3 title="Message Parsing">2.2. ~messageの構文解析-法</h3>

<div class="p">
<p>
~HTTP~messageを構文解析するための通常の手続-は、
次のようになる：
◎
The normal procedure for parsing an HTTP message is to＼
</p>
<ol>
	<li>
`start-line$p の構造を読取る。
◎
read the start-line into a structure,＼
</li>
	<li>
`空~行l$に遭遇するまで，各~header`~field行l$を［
`~field名$を~keyとする~hash~table
］に読取る。
◎
read each header field line into a hash table by field name until the empty line, and then＼
</li>
	<li>
前段までに構文解析された~dataを利用して、［
`~message本体$が期待されるかどうか
］を決定する。
◎
use the parsed data to determine if a message body is expected.＼
</li>
	<li>
`~message本体$が在ることが指示された場合、
それを~octetの~streamとして，［
`~message本体の長さ$に等しい量だけ読取るか, 接続が~closeされる
］まで，読取る。
◎
If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.
</li>
</ol>
</div>

<p>
`受信者$は、
~HTTP~messageを，［
~US-ASCII `USASCII$r の上位集合である符号化法による，~octet列
］として構文解析しなければナラナイ。
特定の符号化法について目を向けずに，~HTTP~messageを［
~Unicode文字たちが成す~streamとして構文解析する
］ことは、
~securityの脆弱性をもたらす
— それは、［
~octet `LF$P を包含する，妥当でない~multibyte文字~並び
］の取扱いが、
文字列~処理~libraryにより，まちまちなことに因る。
文字列に基づく構文解析器を ~protocol要素の中で安全に利用できるのは、
その要素が~messageから抽出された後に限られる
— ~messageを構文解析して，個々の`~field行l$を取り出した後の~header`~field値$の中など。
◎
A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field line value after message parsing has delineated the individual field lines.
</p>

<p>
［
`start-line$p ／各`~field$
］用の行l終了子は， `CRLF$P ~octet並びであるが、
`受信者$は，［
1 個の `LF$P ~octet
］を行l終了子として認識して, 先行する `CR$P を無視してもヨイ。
◎
Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.
</p>

<p>
`送信者$は、
`内容$以外のどの~protocol要素の中にも，
`CRLF$P の一部を成さない `CR$P を`生成-$してはナラナイ。
そのような `CR$P の`受信者$は、
当の要素を妥当でないと見なすか，そのような各 `CR$P を［
当の要素を処理する／当の~messageを回送する
］前に `SP$P に置換しなければナラナイ。
◎
A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content. A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.
</p>

<p>
早期の~server応用には，［
~~改行で終了されていない`~message本体$
］の内容を読取るのに失敗するものもあるため、
旧い~HTTP10~UA実装は，その対処法として［
`POST$m 要請の後に余分な `CRLF$P を送信する
］ことがある。
`~HTTP11$`~UA$は、
要請の前後に `CRLF$P を付け足してはナラナイ。
`~UA$は、
~~改行で終了する要請~message本体が欲される場合には，
その~~改行を成す `CRLF$P ~octetたちの分も`~message本体の長さ$に数えなければナラナイ。
◎
Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.
</p>

<p>
堅牢性の~~観点からは、［
`request-line$p を受信して, 構文解析する
］ことを期待している`~server$は、［
`request-line$p に先立って受信した空~行l
］を少なくとも 1 行l以上は無視するベキである。
◎
In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.
</p>

<p>
`送信者$は、［
`start-line$p と最初の`~header$の合間
］に`空白$を送信してはナラナイ。
◎
A sender MUST NOT send whitespace between the start-line and the first header field.
</p>

<div class="p">
<p>
`受信者$は、［
`start-line$p と最初の`~header$の合間
］に`空白$を受信したときは，次のいずれかを行わなければナラナイ。
◎
A recipient that receives whitespace between the start-line and the first header field MUST either＼
</p>
<ul>
	<li>
当の~messageを妥当でないものとして却下する。
◎
reject the message as invalid or＼
</li>
	<li>
空白が先行する各~行lを，それ以上~処理せずに消費する
（すなわち、［
適正に形成された~headerを受信するか，`~header節$が終了する
］まで，後続な［
空白が先行する各~行l
］をすべて無視する）。
◎
consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).＼
</li>
</ul>
<p>
妥当でない［
空白が先行する行l
］に対する却下あるいは除去は、［
`要請~密入$／`応答~分割$
］攻撃に対し脆弱かもしれない`下流$の`受信者$により誤解釈されるのを防止するために必要yである。
◎
Rejection or removal of invalid whitespace-preceded lines is necessary to prevent their misinterpretation by downstream recipients that might be vulnerable to request smuggling (Section 11.2) or response splitting (Section 11.1) attacks.
</p>
</div>

<p>
`~server$は、［
~HTTP要請~messageのみを~listenしている
］とき, あるいは［［
`start-line$p から出現するものが，~HTTP要請~messageになるかどうか
］を処理している
］ときに，［
`HTTP-message$p 文法に合致しない~octet列
］を受信したときには、
上に挙げた堅牢性の例外を除き，
`400$st 応答で応答した上で接続を~closeするベキである。
◎
When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.
</p>

		</section>
		<section id="http.version">
<h3 title="HTTP Version">2.3. ~HTTP~version</h3>

<p>
~HTTPは、
~protocolの各 `~version^dfn を指示するために，
"<code class="grammar">&lt;%~major&gt;.&lt;%~minor&gt;</code>"
による付番方式を利用する。
この仕様が定義する~version番号は、
"`1.1@c"
である。
~HTTP~version番号の意味論は、
`HTTP$r `~protocol~version＠~HTTPinfra#protocol.version§ にて指定される。
◎
HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol. This specification defines version "1.1". Section 2.5 of [HTTP] specifies the semantics of HTTP version numbers.
</p>

<p>
HTTP/1.x ~messageの~versionは、［
`start-line$p 内の `HTTP-version$p ~field
］により指示される。
`HTTP-version$p は文字大小区別である。
◎
The version of an HTTP/1.x message is indicated by an HTTP-version field in the start-line. HTTP-version is case-sensitive.
</p>

<pre class="bnf">
`HTTP-version@p
	= `HTTP-name$p "/" `DIGIT$P "." `DIGIT$P
`HTTP-name@p
	= ~Ps"HTTP"
</pre>

<p>
~versionが［
~HTTP10 `HTTP/1.0$r あるいは未知
］の`受信者$に向けて送信される`~HTTP11$~messageは、［
より新たな特能すべてが無視されたなら，妥当な~HTTP10~messageとして解釈できる
］ように構築される。
この仕様は、
一部の新たな特能に対し，次が守られるように［
受信者~versionの要件
］を設置する
⇒
`送信者$は、
自身が当の特能に適合するとしても，［
環境設定や, ~messageの受領を通して，受信者が~HTTP11を~supportする
］ことを決定するまでは、
互換な特能のみを利用する。
◎
When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [HTTP/1.0] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored. This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.
</p>

<p>
`媒介者$は、
~HTTP~messageを処理する（すなわち，`~tunnel$として動作していない）ときは，
自身が回送する~message内に［
自前の `HTTP-version$p
］を送信しなければナラナイ
— `上流$における課題への対処法として，目的をもって降格されていない限り。
言い換えれば，`媒介者$には、
~messageの［
受信, 送信
］の両者において，［
その~message内の~protocol~versionが，自身が適合する~versionに合致する
］ことが確保されない限り，［
`start-line$p を盲目的に回送する
］ことは許容されない。
仮に， `HTTP-version$p を書換えないまま~HTTP~messageが回送された場合、
`下流$の`受信者$が［
その`送信者$の~versionを利用して，［
~message送信者との今後の通信~用に安全に利用できる特能
］を決定している
］ときに，通信~errorになるかもしれない。
◎
Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages, unless it is purposefully downgraded as a workaround for an upstream issue. In other words, an intermediary is not allowed to blindly forward the start-line without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.
</p>

<div class="p">
<p>
`~server$は、
`~client$による~HTTP11要請に対し，［
その~clientは、
~HTTP仕様を不正に実装していて，後継~versionの応答を正しく処理できない
］ことが［
既知である／疑わしい
］ならば、
~HTTP10応答を送信してもヨイ
— 例えば、
次が既知であるときなど：
◎
A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as＼
</p>
<ul>
	<li>
`~client$が、［
~version番号を正しく構文解析する
］ことに失敗する。
◎
when a client fails to parse the version number correctly or＼
</li>
	<li>
`媒介者$が、
所与の［
~protocolの`~minor~version$
］に自身が適合しないときにも，
`HTTP-version$p を盲目的に回送する。
◎
when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.＼
</li>
</ul>

<p>
そのような［
~protocolの降格
］は、
特定の~client属性により誘発されない限り，遂行されるベキでない
— 例えば、
要請~内の 1 個~以上の~header（例： `User-Agent$h ）【の値たちが成す組】が［
~errorにあることが既知な，ある~client
【~client実装~version】
が送信する値
］に一意に合致するときなど。
◎
Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.
</p>
</div>

		</section>
	</section>
	<section id="request.line">
<h2 title="Request Line">3. `request-line^p</h2>

<p>
`request-line$p の構文は、
次で与えられる：
◎
A request-line begins with a method token, followed by a single space (SP), the request-target, and another single space (SP), and ends with the protocol version.
</p>

<pre class="bnf">
`request-line@p
	= `method$p `SP$P `request-target$p `SP$P `HTTP-version$p
</pre>

<p>
文法~規則 `request-line$p は，［
各~成分~要素どうしが 1 個の `SP$P ~octetで分離される
］ことを要求しているが、
`受信者$は，代わりに
空白で分離される単語~境界を構文解析した上で
— 行l終了子の `CRLF$P は別として —
頭部／尾部を成す空白は無視して，他のどの形による空白も `SP$P 分離子として扱ってもヨイ
— そのような空白は、
1 個~以上の，次に挙げる~octetからなり得る
⇒＃
`SP$P,
`HTAB$P,
`VT^P (`0B^X),
`FF^P (`0C^X), ［
`CRLF$P の一部を成さない `CR$P
◎
Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.＼
</p>

<p>
しかしながら，そのような寛容な構文解析-法は、［
~messageに対し複数の`受信者$が居て、
堅牢性のための解釈が，それぞれに異なる場合
］に，~securityの脆弱性になり得る（`要請~密入§を見よ）。
◎
However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).
</p>

<div class="p">
<p>
~HTTPは、
`HTTP$r `長さ要件＠~HTTPinfra#length.requirements§ にて述べたとおり，
`request-line$p の長さに対する定義済み制限は設置しない。
`~server$は：
◎
HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.3 of [HTTP].＼
</p>
<ul>
	<li>
［
自身が実装するよりも長い `method$p
］を受信したときは、
`501$st で応答するベキである。
◎
A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code.＼
</li>
	<li>
［
自身が望んで構文解析する どの`~URI$よりも長い `request-target$p
］を受信したときは、
`414$st で応答しなければナラナイ。
◎
A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).
</li>
</ul>
</div>

<p>
実施においては、
`request-line$p の長さには，様々な場当的な制限が見出される。
すべての~HTTP［
`送信者$／`受信者$
］は、
この長さとして，~octet数で最低でも 8000 以上を~supportすることが`推奨される^2119。
◎
Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.
</p>

		<section id="request.method">
<h3 title="Method">3.1. ~method</h3>

<p>
`method$p `token^p は、［
`~target資源$上で遂行される`要請~method$
］を指示する。
要請~methodは、
文字大小区別である。
◎
The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.
</p>

<pre class="bnf">
`method@p
	= `token$p
</pre>

<p>
要請~methodは、
次も含め，`要請~method§ `HTTP$r に定義される
⇒＃
~HTTP~method~registryに関する情報,
新たな~methodを定義する際の考慮点
◎
The request methods defined by this specification can be found in Section 9 of [HTTP], along with information regarding the HTTP method registry and considerations for defining new methods.
</p>

		</section>
		<section id="request.target">
<h3 title="Request Target">3.2. 要請~target</h3>

<p>
`request-target$p 【`要請~target$】は、
要請を どの~target資源に適用するかを識別する。
`~client$は、
欲される`~target~URI$から `request-target$p を導出する。
`request-target$p には、［
要請される~method, 要請は`~proxy$向けかどうか
］の両者に依存して，次に挙げる 4 種の別個な形式がある：
◎
The request-target identifies the target resource upon which to apply the request. The client derives a request-target from its desired target URI. There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.
</p>

<pre class="bnf">
`request-target@p
	= `origin-form$p
	/ `absolute-form$p
	/ `authority-form$p
	/ `asterisk-form$p
</pre>

<p>
`request-target$p 内には、
空白は許容されない。
あいにく，一部の`~UA$は、［
~hypertext参照に見出される空白
］を適正に［
符号化する／除外する
］ことに失敗する
— その結果、
許容されない それらの文字が，
不正形な `request-line$p 内に `request-target$p として送信されることになる。
◎
No whitespace is allowed in the request-target. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent as the request-target in a malformed request-line.
</p>

<div class="p">
<p>
`受信者$は、
妥当でない `request-line$p に対しては：
◎
Recipients of an invalid request-line＼
</p>
<ul>
	<li>
<p>
次のいずれかで応答するベキである：
◎
SHOULD respond with either＼
</p>
		<ul>
			<li>
`400$st ~error
◎
a 400 (Bad Request) error or＼
</li>
			<li>
［
適正に符号化された `request-target$p
］を伴う `301$st ~redirect
◎
a 301 (Moved Permanently) redirect with the request-target properly encoded.＼
</li>
		</ul>
	</li>
	<li>
~redirectせずに，要請を自動的に正して処理しようと試みるベキでない
— 妥当でない `request-line$p は、
要請の`連鎖$沿いにある~security~filterを迂回するために，
故意に細工された可能性もあるので。
◎
A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.
</li>
</ul>
</div>

<div class="p">
<p>
`~client$は、
どの［
`~HTTP11$要請~message
］にも，
`Host$h ~headerを送信しなければナラナイ
— その`~field値$には［
`~target~URI$が `authority$p 成分を内包するかどうか
］に応じて，次を与えた上で：
◎
A client MUST send a Host header field (Section 7.2 of [HTTP]) in all HTTP/1.1 request messages.＼
</p>
<ul>
	<li>
内包する場合
⇒
`authority$p 成分から［
`userinfo$p 下位成分と その "`@^c" 区切子
］（もしあれば）を除外した結果。
◎
If the target URI includes an authority component, then a client MUST send a field value for Host that is identical to that authority component, excluding any userinfo subcomponent and its "@" delimiter (Section 4.2 of [HTTP]).＼
</li>
	<li>
内包しない（または未定義な）場合
⇒
空。
◎
If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field value.
</li>
</ul>
</div>

<div class="p">
<p>
`~server$は、
次のいずれかに該当するどの要請~messageに対しても，
`状態s~code$ `400$st で応答しなければナラナイ：
◎
A server MUST respond with a 400 (Bad Request) status code＼
</p>
<ul>
	<li>
`~HTTP11$~messageであって， `Host$h ~headerを欠如するもの。
◎
to any HTTP/1.1 request message that lacks a Host header field and＼
</li>
	<li>
複数個の `Host$h ~header`~field行l$を包含するもの。
◎
to any request message that contains more than one Host header field line or＼
</li>
	<li>
包含する `Host$h ~headerの`~field値$が妥当でないもの。
◎
a Host header field with an invalid field value.
</li>
</ul>
</div>

			<section id="origin-form">
<h4 title="origin-form">3.2.1. `origin-form^p</h4>

<p>
`request-target$p の最も共通的な形は、
`origin-form$p である：
◎
The most common form of request-target is the "origin-form".
</p>

<pre class="bnf">
`origin-form@p
	= `absolute-path$p [ "?" `query$p ]
</pre>

<div class="p">
<p>
`~client$は、［
`CONNECT$m ／`~server-wide$な `OPTIONS$m
］（詳細は後述）以外の要請を`生成元~server$へ直に為すときは：
◎
When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client＼
</p>
<ul>
	<li>
`request-target$p として，`~target~URI$の［
`absolute-path$p, `query$p
］成分のみを送信しなければナラナイ。
◎
MUST send only the absolute path and query components of the target URI as the request-target.＼
</li>
	<li>
`~target~URI$の `path$p 成分が空な場合、［
`request-target$p を成す `origin-form$p の中の `path$p
］として，
"`/^c"
を送信しなければナラナイ。
◎
If the target URI's path component is empty, the client MUST send "/" as the path within the origin-form of request-target.＼
</li>
	<li>
また、
`Host$h ~headerも，その定義に従って送信することになる。
◎
A Host header field is also sent, as defined in Section 7.2 of [HTTP].
</li>
</ul>
</div>

<div class="example">

<p>
例えば、
~clientが［
次で識別される`資源$
］の`表現$を検索取得したいと望むときは：
◎
For example, a client wishing to retrieve a representation of the resource identified as
</p>

<pre>
http://www.example.org/where?q=now
</pre>

<p>
［
~host "`www.example.org^c" の~port 80
］への~TCP接続を，`生成元~server$から直に~openして（または再利用して）、
次の 2 行l：
◎
directly from the origin server would open (or reuse) a TCP connection to port 80 of the host "www.example.org" and send the lines:
</p>

<pre class="lang-http">
GET /where?q=now HTTP/1.1
Host: www.example.org
</pre>

<p>
および，後続して要請~messageを成す残りの部分を送信することになろう。
◎
followed by the remainder of the request message.
</p>
</div>

			</section>
			<section id="absolute-form">
<h4 title="absolute-form">3.2.2. `absolute-form^p</h4>

<p>
`~client$は、［
`CONNECT$m ／`~server-wide$な `OPTIONS$m
］（詳細は後述）以外の要請を，`~proxy$へ向けて為すときは、
`request-target$p として，
`absolute-form$p による`~target~URI$を送信しなければナラナイ。
◎
When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in "absolute-form" as the request-target.
</p>

<pre class="bnf">
`absolute-form@p
	= `absolute-URI$p
</pre>

<p>
要請を受けた`~proxy$は、［
アリなら，それに対し有効な`~cache$で~serviceする
］か, あるいは，
~clientに利するため［
`内方$にある次の~proxy~serverへ向けて
］または［
`request-target$p が指示する`生成元~server$へ向けて，直に
］同じ要請を為す。
そのような~messageの “回送-法” に課される要件は、
`HTTP$r `~messageの回送-法＠~HTTPsem#message.forwarding§にて定義される。
◎
The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf either to the next inbound proxy server or directly to the origin server indicated by the request-target. Requirements on such "forwarding" of messages are defined in Section 7.6 of [HTTP].
</p>

<div class="example">

<p>
`absolute-form$p による `request-target$p を伴う `request-line$p の例：
◎
An example absolute-form of request-line would be:
</p>

<pre class="lang-http">
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</pre>
</div>

<p>
`~client$は、
`request-target$p が `absolute-form$p であっても，
`~HTTP11$要請においては `Host$h ~headerを送信しなければナラナイ。
これにより、
`Host^h 情報を［
`Host^h を実装していない古代の~HTTP10~proxy
］を通して回送することも可能になるので。
◎
A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.
</p>

<div class="p">
<p>
`~proxy$は、
受信した要請の `request-target$p が `absolute-form$p である場合には，
要請~内に `Host$h ~headerを受信したとしても：
◎
When a proxy receives a request with an absolute-form of request-target,＼
</p>
<ul>
	<li>
`Host^h ~headerは無視して、
代わりにそれを［
`request-target$p を成す `host$p 情報
］に置換しなければナラナイ。
【例えば、自身が使役する~cache用に】
◎
the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target.＼
</li>
	<li>
その要請を回送するときは、
`Host^h ~headerの`~field値$は，そのまま回送せずに、
受信した `request-target$p に基づいて，
`Host^h 用の新たな`~field値$を`生成-$しなければナラナイ。
◎
A proxy that forwards such a request MUST generate a new Host field value based on the received request-target rather than forward the received Host field value.
</li>
</ul>
</div>

<p>
`生成元~server$は、
受信した要請の `request-target$p が `absolute-form$p である場合は，
要請~内に `Host$h ~headerを受信したとしても無視して，
代わりに `request-target$p を成す `host$p 情報を利用しなければナラナイ。
この事例では、
`request-target$p に `authority$p 成分が無い場合，
空な `Host$h ~headerが送信されることになることに注意。
◎
When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target. Note that if the request-target does not have an authority component, an empty Host header field will be sent in this case.
</p>

<p>
`~server$は、
要請~内の `absolute-form$p を受容しなければナラナイ
— ほとんどの~HTTP11~clientは、
`absolute-form$p を`~proxy$向けの要請~内に限って送信するとしても。
◎
A server MUST accept the absolute-form in requests even though most HTTP/1.1 clients will only send the absolute-form to a proxy.
</p>

			</section>
			<section id="authority-form">
<h4 title="authority-form">3.2.3. `authority-form^p</h4>

<p>
`authority-form$p による `request-target$p が利用されるのは、
`CONNECT$m 要請に限られる。
それは、
`~tunnel$の行先を成す［
~colon（ "`:^c" ）で分離された
`uri-host$p と `port$p 番号
］のみからなる：
◎
The "authority-form" of request-target is only used for CONNECT requests (Section 9.3.6 of [HTTP]). It consists of only the uri-host and port number of the tunnel destination, separated by a colon (":").
</p>

<pre class="bnf">
`authority-form@p
	= `uri-host$p ":" `port$p
</pre>

<p>
`~client$は，［
1 個~以上の`~proxy$を通した`~tunnel$を確立するために，
`CONNECT$m 要請を為すとき
］は、
`request-target$p として，当の~tunnelの行先を成す［
`host$p, `port$p
］のみを送信しなければナラナイ。
`~client$は，`~target~URI$の `authority$p 成分から［
`host$p, `port$p
］を得することになるが、
~target~URIの `port$p が省かれていた場合でも，
その~scheme用の既定の~portを送信することになる。
◎
When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the host and port of the tunnel destination as the request-target. The client obtains the host and port from the target URI's authority component, except that it sends the scheme's default port if the target URI elides the port.＼
</p>

<div class="example">
<p>
例えば，
"`http://www.example.com^c"
へ向けた `CONNECT$m 要請は、
次の様になる：
◎
For example, a CONNECT request to "http://www.example.com" looks like the following:
</p>

<pre class="lang-http">
CONNECT www.example.com:80 HTTP/1.1
Host: www.example.com
</pre>
</div>

			</section>
			<section id="asterisk-form">
<h4 title="asterisk-form">3.2.4. `asterisk-form^p</h4>

<p>
`asterisk-form$p による `request-target$p が利用されるのは、
`~server-wide$な `OPTIONS$m 要請に限られる。
◎
The "asterisk-form" of request-target is only used for a server-wide OPTIONS request (Section 9.3.7 of [HTTP]).
</p>

<pre class="bnf">
`asterisk-form@p
	= "*"
</pre>

<p>
`~client$は，`~server$に対し
— その~serverにおける特定の名前の`資源$を~~指すことなく —
`~server-wide$な `OPTIONS$m のみを要請したいと望むときは、
`request-target$p として，
"`*^c" (`2A^X）のみを送信しなければナラナイ。
◎
When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only "*" (%x2A) as the request-target. For example,
</p>

<div class="example">
<p>
`asterisk-form$p による `request-target$p を伴う `request-line$p の例：
</p>

<pre class="lang-http">
OPTIONS * HTTP/1.1
</pre>
</div>

<p>
`OPTIONS$m 要請を受信した`~proxy$は，［
要請の `request-target$p は［
`path$p は空, かつ `query$p 成分は無い`~URI$
］を与える `absolute-form$p
］であって［
自身が要請の`連鎖$上にある最後の`~proxy$である
］ならば、
その要請を指示された`生成元~server$へ向けて回送するときに，
`request-target$p として
"`*^c" を送信しなければナラナイ。
【自身が最後の~proxyであるかどうかは、どう決定される？】
◎
If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of "*" when it forwards the request to the indicated origin server.
</p>

<div class="example">
<p>
例えば、
次の要請は：
◎
For example, the request
</p>

<pre class="lang-http">
OPTIONS http://www.example.org:8001 HTTP/1.1
</pre>

<p>
最終-`~proxy$においては、［
~host "`www.example.org^c" の~port 8001
］へ接続した後，次のように回送することになろう：
◎
would be forwarded by the final proxy as
</p>

<pre class="lang-http">
OPTIONS * HTTP/1.1
Host: www.example.org:8001
</pre>

<p>
—
◎
after connecting to port 8001 of host "www.example.org".
</p>
</div>

			</section>
		</section>
		<section id="reconstructing.target.uri">
<h3 title="Reconstructing the Target URI">3.3. ~target~URIの再構築-法</h3>

<p>
`~server$は、
`~target資源$を識別するために，要請から`~target~URI$を得ることになる。
それは、
要請の `request-target$p 【`要請~target$】
— 以下， %要請~target と記す —
が `absolute-form$p である場合は %要請~target になる
— この事例では，~serverは、
更に評価するために，この~URIを汎用な各~成分に構文解析することになる。
◎
The target URI is the request-target when the request-target is in absolute-form. In that case, a server will parse the URI into its generic components for further evaluation.
</p>

<p>
他の場合，`~server$は、
接続~文脈と要請~messageを成す様々な各部から，
以下に従って`~target~URI$を構築し直す：
◎
Otherwise, the server reconstructs the target URI from the connection context and various parts of the request message in order to identify the target resource (Section 7.1 of [HTTP]):
</p>
<ul>
	<li>
<p>
その `scheme$p 成分は：
◎
↓</p>
		<ol>
			<li>
`~server$の環境設定が固定的な~URI~schemeを供しているならば
⇒
その~scheme
◎
If the server's configuration provides for a fixed URI scheme,＼
</li>
			<li>
<p>
他の場合，信用-済みな`外方$にある`~gateway$から~schemeが供されているならば
⇒
その~scheme
◎
or a scheme is provided by a trusted outbound gateway, that scheme is used for the target URI.＼
</p>

<p>
これは、
~scaleが巨大な配備に共通的にある
— ~gateway~serverは、
`~client$の接続~文脈を受信して，
それを`内方$にある~serverへ自前の接続で置換することになるので。
◎
This is common in large-scale deployments because a gateway server will receive the client's connection context and replace that with their own connection to the inbound server.＼
</p>
			</li>
			<li>
他の場合，要請は`~secure化$された接続~越しに受信されたならば
⇒
"`https$c"
◎
Otherwise, if the request is received over a secured connection, the target URI's scheme is "https";＼
</li>
			<li>
他の場合
⇒
"`http$c"
◎
if not, the scheme is "http".
</li>
		</ol>
	</li>
	<li>
<p>
その `authority$p 成分は：
</p>
		<ol>
			<li>
%要請~target は `authority-form$p であるならば
⇒
%要請~target
</li>
			<li>
他の場合，要請には `Host$h ~headerが在って，その`~field値$は［
空でない, かつ妥当である
］ならば
⇒
その~field値
</li>
			<li>
他の場合
⇒
空
</li>
		</ol>
◎
If the request-target is in authority-form, the target URI's authority component is the request-target. Otherwise, the target URI's authority component is the field value of the Host header field. If there is no Host header field or if its field value is empty or invalid, the target URI's authority component is empty.
</li>
	<li>
<p>
その結合された［
`path$p, `query$p
］成分は：
</p>
		<ol>
			<li>
%要請~target は［
`authority-form$p ／ `asterisk-form$p
］であるならば
⇒
空
</li>
			<li>
他の場合【すなわち， %要請~target は `origin-form$p 】
⇒
%要請~target
</li>
		</ol>
◎
If the request-target is in authority-form or asterisk-form, the target URI's combined path and query component is empty. Otherwise, the target URI's combined path and query component is the request-target.
</li>
	<li>
構築し直された`~target~URI$は、
上で決定した各~成分（および文字列 "`://^c" ）を
次の順に結合し直した結果の `absolute-URI$p 【 `absolute-form$p 】になる
⇒＃
`scheme$p,
"`://^c",
`authority$p,
結合された［ `path$p, `query$p ］成分
◎
The components of a reconstructed target URI, once determined as above, can be recombined into absolute-URI form by concatenating the scheme, "://", authority, and combined path and query component.
</li>
</ul>

<div class="example">
<p>
~secureな接続~越しに，次の~messageを受信したなら：
◎
Example 1: The following message received over a secure connection
</p>

<pre class="lang-http">
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org
</pre>

<p>
`~target~URI$は：
◎
has a target URI of
</p>

<pre class="lang-http">
https://www.example.org/pub/WWW/TheProject.html
</pre>
</div>

<div class="example">
<p>
~secureでない接続~越しに，次の~messageを受信したなら：
◎
Example 2: The following message received over an insecure connection
</p>

<pre class="lang-http">
OPTIONS * HTTP/1.1
Host: www.example.org:8080
</pre>

<p>
`~target~URI$は：
◎
has a target URI of
</p>

<pre class="lang-http">
http://www.example.org:8080
</pre>
</div>

<p>
`~target~URI$の `scheme$p 用には空でない `authority$p が要求されるが
（ "`http$c" ／ "`https$c" の事例は、これに該当する），
その `authority^p 成分は空な場合、
`~server$は，当の要請を却下できる
— あるいは、［
入って来る接続の文脈に整合な，環境設定された既定
］を適用するかどうか決定することもできる。
文脈は、［
~addressや~portの様な接続の詳細／
~securityとして何が適用されたか／
当の~serverの環境設定に特有な，局所的に定義された情報
］を含むこともある。
空な `authority$p は、
要請を更に処理する前に，環境設定された既定で置換される。
◎
If the target URI's authority component is empty and its URI scheme requires a non-empty authority (as is the case for "http" and "https"), the server can reject the request or determine whether a configured default applies that is consistent with the incoming connection's context. Context might include connection details like address and port, what security has been applied, and locally defined information specific to that server's configuration. An empty authority is replaced with the configured default before further processing of the request.
</p>

<p>
`~secure化$された接続の文脈の中で，
`authority$p 用に既定の名前を給することは、［
~UAが意図した `authority$p が既定と相違する
］かもしれない機会cがある場合には，内来的に安全でない。
`~server$は、［
この~riskを伴わずに，要請~文脈から `authority$p を一意に識別できる
］ならば，その識別情報を既定として利用してもヨイ。
別法として、
当の要請を［
新たな`~client$を得する【~client~softwareを更新する？】方法を説明する安全な`資源$
］へ~redirectする方が良いこともある。
◎
Supplying a default name for authority within the context of a secured connection is inherently unsafe if there is any chance that the user agent's intended authority might differ from the default. A server that can uniquely identify an authority from the request context MAY use that identity as a default without this risk. Alternatively, it might be better to redirect the request to a safe resource that explains how to obtain a new client.
</p>

<p>
`~client$の`~target~URI$を構築し直すことは、
`~target資源$を識別する処理nの半分しか成さないことに注意。
もう半分は、
当の~target~URIは［
`~server$が応答を送信する用意がある, かつ送信-可能な資源
］を識別するかどうか決定することであり，
`HTTP$r `誤って~directされた要請の却下-法＠~HTTPsem#routing.reject§ にて定義される。
◎
Note that reconstructing the client's target URI is only half of the process for identifying a target resource. The other half is determining whether that target URI identifies a resource for which the server is willing and able to send a response, as defined in Section 7.4 of [HTTP].
</p>

		</section>
	</section>
	<section id="status.line">
<h2 title="Status Line">4. 状態s行l</h2>

<p>
応答~messageの最初の行lは，状態s行l（ `status-line$p ）と呼ばれ、
次の順による並びからなる
⇒＃
`~protocol~version$,
1 個の `SP$P,
`状態s~code$,
1 個の `SP$P,
状態s~codeについて述べる，`省略可能^2119な~textな句
◎
The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, and another space and ending with an OPTIONAL textual phrase describing the status code.
</p>

<pre class="bnf">
`status-line@p
	= `HTTP-version$p `SP$P `status-code$p `SP$P [ `reason-phrase$p ]
</pre>

<p>
文法~規則 `status-line$p は，［
各種~成分~要素どうしが 1 個の `SP$P ~octetで分離される
］ことを要求しているが、
`受信者$は，代わりに空白で区切られる単語~境界を構文解析した上で
— 行l終了子の `CRLF$P は別として —
頭部／尾部を成す空白は無視して，他のどの形による空白も `SP$P 分離子と扱ってヨイ
— そのような空白は、
1 個~以上の，次に挙げる~octetからなり得る
⇒＃
`SP$P,
`HTAB$P,
`VT^P (`0B^X),
`FF^P (`0C^X),
`CRLF$P の一部を成さない `CR$P
◎
Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.＼
</p>

<p>
しかしながら，寛容な構文解析-法は、［
~messageに対し複数の`受信者$が居て，堅牢性を得るための解釈が それぞれに異なる
］場合に~securityの脆弱性になり得る
— `応答~分割§を見よ。
◎
However, lenient parsing can result in response splitting security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.1).
</p>

<div class="p">
<p>
`status-code$p 要素は、
3 桁の整数~codeであり，応答の`状態s~code$を与える：
</p>

<pre class="bnf">
`status-code@p
	= 3`DIGIT$P
</pre>

<p>
`状態s~code$は、
`~server$が［
当の応答が応対した`~client$からの要請
］を解して, それを満足しようと試みた結果を述べる。
応答の`受信者$は、
~messageを成す残りの部分を構文解析して，それを解釈する
⇒＃
自身が当の状態s~codeを認識する場合は，その状態s~code用に定義された意味論に照らし合わせて／
他の場合は，状態s~codeの`~class$に則って
</p>
◎
The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request. A recipient parses and interprets the remainder of the response message in light of the semantics defined for that status code, if the status code is recognized by that recipient, or in accordance with the class of that status code when the specific code is unrecognized.
◎
status-code = 3DIGIT
</div>

<p>
~HTTPの中核を成す`状態s~code$は、
`HTTP$r `状態s~code＠~HTTPsem#status.codes§にて，その`~class$とともに定義される。
`HTTP$r は、
他にも次を与える【 `HTTP$r `状態s~codeの拡張能＠~HTTPinfra#status.code.extensibility§ 】
⇒＃
新たな状態s~codeを定義する際の考慮点,
そのような定義を収集するための~IANA~registry
◎
HTTP's core status codes are defined in Section 15 of [HTTP], along with the classes of status codes, considerations for the definition of new status codes, and the IANA registry for collecting such definitions.
</p>

<p>
`reason-phrase$p 要素は、
もっぱら［
数的な`状態s~code$に結付けられた，~textな記述
］を供する目的で存在する（空でもよい）
— そのほとんどは、［
ヤリトリありな~text~clientにより より頻繁に利用されていた，早期の~Internet応用~protocol
］に~~由来している。
◎
The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients.
</p>

<pre class="bnf">
`reason-phrase@p
	= 1*( `HTAB$P / `SP$P / `VCHAR$P / `obs-text$p )
</pre>

<p>
`~client$は、
`reason-phrase$p の内容を無視するベキである
— それは、
情報~用の~channelとして依拠-可能でないので
（それは、［
所与の~localeに翻訳される／
`媒介者$により上書きされる／
他の~HTTP~versionを介して~messageが回送されるときに破棄される
］こともある）。
`~server$は、
`reason-phrase$p が無い場合でも，
それを `status-code$p から分離する~spaceは送信しなければナラナイ
（その場合、
`status-line$p は~spaceで終端することになる）。
◎
A client SHOULD ignore the reason-phrase content because it is not a reliable channel for information (it might be translated for a given locale, overwritten by intermediaries, or discarded when the message is forwarded via other versions of HTTP). A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).
</p>


	</section>
	<section id="header.field.syntax">
<h2 title="Field Syntax">5. ~fieldの構文</h2>

<p>
各 `~field行l$（ `field-line^p ）の構文は、
次の順の並びからなる
⇒＃
文字大小無視な`~field名$（ `field-name^p ）,
1 個の~colon（ "`:^c" ）,
0 個以上の空白,
`~field行l値$（ `field-value^p ）,
0 個以上の空白
◎
Each field line consists of a case-insensitive field name followed by a colon (":"), optional leading whitespace, the field line value, and optional trailing whitespace.
</p>

<pre class="bnf">
`field-line@p
	= `field-name$p ":" `OWS$p `field-value$p `OWS$p
</pre>

<p>
`~field値$の中を構文解析するための規則は、
`HTTP$r `~field値＠~HTTPinfra#fields.values§にて定義される。
この節は、
~headerを~HTTP11~message［
の中に内包する／から抽出する
］ための汎用~構文を受持つ。
◎
Rules for parsing within field values are defined in Section 5.5 of [HTTP]. This section covers the generic syntax for header field inclusion within, and extraction from, HTTP/1.1 messages.
<p>

		<section id="field.parsing">
<h3 title="Field Line Parsing">5.1. ~field行lの構文解析-法</h3>

<p>
~messageは、［
個々の`~field名$に依存しない，汎用~algo
］を利用して構文解析される。
所与の`~field行l値$の内容は、
~message解釈の今後の段階まで
（通例的に，~messageの【当の`~field行l$を包含している】`~field節$全体が処理された後になる），
構文解析されない。
◎
Messages are parsed using a generic algorithm, independent of the individual field names. The contents within a given field line value are not parsed until a later stage of message interpretation (usually after the message's entire field section has been processed).
</p>

<p>
`~field名$と~colonの合間には，`空白$は許容されない。
過去においては，［
そのような空白の取扱いにおける相違点
］から、［
要請の~route法／応答の取扱い
］に~securityの脆弱性が導かれていた。
`~server$は、［
受信した要請~messageにおいて，ある~headerがそのような空白を内包する場合
］には，状態s~code `400$st で応答して それを却下しなければナラナイ。
`~proxy$は、
~messageを`下流$に回送する前に，
応答~messageから そのような空白すべてを除去しなければナラナイ。
◎
No whitespace is allowed between the field name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon. A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.
</p>

<p>
`~field行l値$の前後には、
省略可能な空白（ `OWS$p ）が［
先行する／後続する
］こともある
— ヒトから読み易くするため、
`~field行l値$には， 1 個の `SP$P を先行させることが選好される。
`~field行l値$ 自体は、
そのような［
頭部／尾部
］を成す`空白$を内包しない：
`~field行l値$の［
最初の非~空白~octetより前 ／ 最後の非~空白~octetより後
］に生じる `OWS$p は、
`~field行l$から`~field行l値$を抽出するときには，構文解析器により除外される。
◎
A field line value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field line value is preferred for consistent readability by humans. The field line value does not include that leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field line value, or after the last non-whitespace octet of the field line value, is excluded by parsers when extracting the field line value from a field line.
</p>

		</section>
		<section id="line.folding">
<h3 title="Obsolete Line Folding">5.2. 廃用にされた行l折返し</h3>

<p>
歴史的に， HTTP/1.x における`~field値$は、
複数~行lに渡るよう拡張することもできた
— 2 行l~目 以降の各~行lに， 1 個~以上の［
`SP$P ／ `HTAB$P
］を先行させること（ `obs-fold$p ）により。
この仕様は、
`~MIME型$ "`message/http$c" の中を除いて，
そのような行l折返しを非推奨にする。
◎
Historically, HTTP/1.x field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the "message/http" media type (Section 10.1).
</p>

<pre class="bnf">
`obs-fold@p
	= `OWS$p `CRLF$P `RWS$p
	; <span class="comment">廃用にされた行l折返し
◎
obsolete line folding
</span>
</pre>

<p>
`送信者$は、
行l折返しを内包する
（すなわち， `obs-fold$p 規則に合致するものを包含する`~field行l値$がある）
~messageを
— `~MIME型$ "`message/http$c" の中に梱包するものと意図するときを除き —
`生成-$してはナラナイ。
◎
A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the "message/http" media type.
</p>

<p>
［
"`message/http$c" ~containerの中でない要請~message内
］に `obs-fold$p を受信したときは：
◎
↓</p>
<ul>
	<li>
<p>
`~server$は、
次のいずれかを行わなければナラナイ：
◎
A server that receives an obs-fold in a request message that is not within a "message/http" container MUST either＼
</p>

		<ul>
			<li>
`400$st を送信して，~messageを却下する — それには，［［
廃用にされた行l折返しは，受容-可能でない
］ことを説明する`表現$
］が伴われることが好ましい。
◎
reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or＼
</li>
			<li>
［
`~field値$を解釈する／
~messageを`下流$へ回送する
］に先立って、
受信した各 `obs-fold$p を 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
</li>
		</ul>
	</li>
	<li>
<p>
［
`~proxy$／`~gateway$
］は、
次のいずれかを行わなければナラナイ：
◎
A proxy or gateway that receives an obs-fold in a response message that is not within a "message/http" container MUST either＼
</p>

		<ul>
			<li>
~messageを破棄して， `502$st 応答に置換する — それには，［［
受容-可能でない行l折返しを受信したこと
］を説明する`表現$
］が伴われることが好ましい。
◎
discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or＼
</li>
			<li>
［
`~field値$を解釈したり, ~messageを`下流$へ回送する
］に先立って、
受信した各 `obs-fold$p を 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
</li>
		</ul>
	</li>
	<li>
<p>
`~UA$は、
次を行わなければナラナイ：
◎
A user agent that receives an obs-fold in a response message that is not within a "message/http" container MUST＼
</p>
		<ul>
			<li>
［
`~field値$を解釈する
］に先立って、
受信した各 `obs-fold$p を 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value.
</li>
		</ul>
	</li>
</ul>

		</section>
	</section>
	<section id="message.body">
<h2 title="Message Body">6. ~message本体</h2>

<p>
~HTTP11~messageの
`~message本体@
は、
（もし在れば）当の［
要請／応答
］の`内容$を運ぶために利用される。
`Transfer-Encoding$h に述べるように，`転送~符号法$が適用されていない限り、
~message本体は，`内容$に一致する。
◎
The message body (if any) of an HTTP/1.1 message is used to carry content (Section 6.4 of [HTTP]) for the request or response. The message body is identical to the content unless a transfer coding has been applied, as described in Section 6.1.
</p>

<p class="trans-note">【
すなわち、
~message本体は，伝送路~上に実際に現れる~dataを意味する一方で、
`内容$は，`転送~符号法$による符号化を復号した後の~dataを意味する。
】</p>

<pre class="bnf">
`message-body@p
	= *`OCTET$P
</pre>

<p>
~HTTP11~message内に~message本体が在るかどうかを決定する規則は、
要請と応答で相違する。
◎
The rules for determining when a message body is present in an HTTP/1.1 message differ for requests and responses.
</p>

<p>
要請に~message本体が在ることは、［
`Content-Length$h または `Transfer-Encoding$h 
］~headerにより通達される。
要請~messageの~frame法が，`~method$の意味論に依存することはない。
◎
The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field. Request message framing is independent of method semantics.
</p>

<p>
応答における~message本体の有無は、
`6.3§ にて詳細されるとおり，［
当の応答が応対した要請の`~method$,
当の応答の`状態s~code$
］の両者に依存する。
これは、
応答の`内容$がいつ~HTTP意味論により許容されるか
（ `HTTP$r `内容の意味論＠~HTTPinfra#content.semantics§ ）
に対応する。
◎
The presence of a message body in a response, as detailed in Section 6.3, depends on both the request method to which it is responding and the response status code. This corresponds to when response content is allowed by HTTP semantics (Section 6.4.1 of [HTTP]).
</p>

		<section id="field.transfer-encoding">
<h3 title="Transfer-Encoding">6.1. `Transfer-Encoding^h</h3>

<p>
`Transfer-Encoding$h ~headerは、
一連の［
`~message本体$を形成するために，`内容$に適用された（または適用されることになる）`転送~符号法$
］に対応する，一連の`転送~符号法の名前$を~listする：
◎
The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the content in order to form the message body. Transfer codings are defined in Section 7.
</p>

<pre class="bnf">
`Transfer-Encoding@p
	= #`transfer-coding$p
	; <span class="comment">`HTTP$r `TE§h にて定義される。
◎
defined in [HTTP], Section 10.1.4
</span>
</pre>

<p>
`Transfer-Encoding$h は、［
~binary~dataの安全な~transportを 7-bit ~transport~service越しに可能化する
］ために設計された，
~MIMEの `Content-Transfer-Encoding$h ~field `RFC2045$r
に相似的である。
しかしながら，安全な~transportは、
転送~protocolを `8bit-clean^en にするという，異なる面に力点を置いている。
~HTTPにおける `Transfer-Encoding$h には、
首に，動的に`生成-$される`内容$を正確aに区切ることが意図されている。
それはまた、［
符号化法は、
【`媒介者$を】通過中に限り適用されたものであり，`選定された表現$の特性でないこと
］を判別するものとしても~serveする。
◎
Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol.＼
In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content.＼
It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.
</p>

<div class="p">
<p>
`受信者$は、
`~chunked転送~符号法$を構文解析できなければナラナイ
— それは、［
`内容$の~sizeが前もって既知でない下で，~messageを~frame化するとき
］に，不可欠な役割を担うので。
◎
A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.＼
</p>

<p>
`送信者$は：
◎
＼</p>
<ul>
	<li>
`~message本体$に対し，`~chunked転送~符号法$を複数回 適用してはナラナイ
（すなわち，すでに~chunk化された~messageを更に~chunk化することは許容されない）。
◎
A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).＼
</li>
	<li>
`~chunked$以外の`転送~符号法$が，要請の`内容$に適用された場合、［
~messageが適正に~frame化される
］ことを確保するために，~chunkedを
`最終-転送~符号法@
として適用しなければナラナイ。
◎
If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.＼
</li>
	<li>
`~chunked$以外の`転送~符号法$が，応答の`内容$に適用された場合、［
~chunkedを`最終-転送~符号法$として適用する
］か, または［
接続を~closeして~messageを終了させ
］なければナラナイ。
◎
If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.
</li>
</ul>
</div>

<div class="example">

<p>
例えば、
次のものは：
◎
For example,
</p>

<pre class="lang-http">
Transfer-Encoding: gzip, chunked
</pre>

<p>
`内容$は、
`~message本体$を形成する際に［
"`gzip$c" 符号法を利用して圧縮された上で，
~chunked符号法を利用して~chunk化されている
］ことを指示する。
◎
indicates that the content has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.
</p>
</div>

<p>
`Content-Encoding$h による`内容~符号法$と違って、
`Transfer-Encoding$h は，~messageの~propertyである
— `表現$のそれではなく。
［
要請／応答
］の`連鎖$沿いにある どの`受信者$も［
受信した`転送~符号法$（たち）を復号してもヨイ／
`~message本体$に追加的な`転送~符号法$（たち）を適用してもヨイ
］
— `Transfer-Encoding$h の`~field値$にも対応する変更を加えた上で。
［
符号化~parameterについての追加的な情報
］も［
この仕様で定義されない他の~header
］にて供され得る。
◎
Unlike Content-Encoding (Section 8.4.1 of [HTTP]), Transfer-Encoding is a property of the message, not of the representation. Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>

<p>
`Transfer-Encoding$h は、［
`HEAD$m 要請に対する応答 ／
`GET$m 要請に対する `304$st 応答
］内に送信してもヨイ。
どちらの応答も，`~message本体$を内包しない
— それは、［
要請が条件付き~でない `GET$m であったとするとき，
`生成元~server$が~message本体に適用することになる`転送~符号法$
］を指示する。
しかしながら、
この指示は，要求されてはいない
— 応答の`連鎖$上にある どの`受信者$も（`生成元~server$も含む）、
不要になり次第，転送~符号法を除去できるので。
◎
Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.
</p>

<div class="p">
<p>
`~server$は、
次に挙げるどの応答にも，
`Transfer-Encoding$h ~headerを送信してはナラナイ：
◎
A server MUST NOT send a Transfer-Encoding header field in＼
</p>
<ul>
	<li>
状態s~codeに［
`1xx$st ／ `204$st 
］を伴う応答
◎
any response with a status code of 1xx (Informational) or 204 (No Content).＼
</li>
	<li>
`CONNECT$m 要請に対する `2xx$st 応答
◎
A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).
</li>
</ul>
</div>

<p>
`~server$は、［
自身が解さない`転送~符号法$を伴う要請~message
］を受信したときには， `501$st で応答するベキである。
◎
A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).
</p>

<p>
`Transfer-Encoding$h は、
`~HTTP11$にて追加された。
［
~HTTP10の~supportのみを広告している実装
］は、
一般に，転送~符号化-済みな`内容$を処理する方法を解さないものと見做されている
— `Transfer-Encoding$h を伴って受信された~HTTP10~messageは、
【~HTTP10媒介者を】通過中に`~chunked転送~符号法$を適正に取扱うことなく回送された見込みが高い。
◎
Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process transfer-encoded content, and that an HTTP/1.0 message received with a Transfer-Encoding is likely to have been forwarded without proper handling of the chunked transfer coding in transit.
</p>

<div class="p">
<p>
`~client$は、［
`~server$が~HTTP11（以上の`~minor~version$【！revisions】の）要請を取扱える
］ことを知っていない限り，［
`Transfer-Encoding$h を包含している要請
］を送信してはナラナイ
— そのような知識は、［
特定の利用者~環境設定
］や［
先に受信した応答の`~version$を記憶する
］形をとるであろう。
◎
A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.＼
</p>

<p>
`~server$は、
応対した要請が~HTTP11（以上の`~minor~version$【！revisions】）を指示していない限り，
［
`Transfer-Encoding$h を包含している応答
］を送信してはナラナイ。
◎
A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).
</p>
</div>

<p>
`Transfer-Encoding$h の早期の実装は、［
~message~frame法のための`~chunked転送~符号法$
］, ［
進捗-~barに利用するために見積もられた `Content-Length$h ~header
］の両方を送信することもある。
このことが、
`Transfer-Encoding$h が `Content-Length$h を
— これらが互いに非~互換とされることなく —
上書きするものと定義された~~理由である。
あいにく，そのような~messageを回送すると、
`下流$の受信者のうちいずれかが
— 特に，~HTTP10しか実装していないそれが —
当の~messageを この仕様に則って構文解析するのに失敗する場合に，［
`要請~密入$／`応答~分割$
］攻撃に対する脆弱性を導き得る。
◎
Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.
</p>

<div class="p">
<p>
`~server$は、［
`Content-Length$h, `Transfer-Encoding$h
］両者を包含する要請に対しては：
</p>
<ul>
	<li>
却下しても，あるいは
`Transfer-Encoding$h のみに則って処理してもヨイ。
</li>
	<li>
いずれにせよ，攻撃の可能性を避けるため、
当の要請に対し応答した後には，接続を~closeしなければナラナイ。
</li>
</ul>
◎
A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone. Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.
</div>

<p>
［
`~server$／`~client$
］は，受信した~HTTP10~messageが `Transfer-Encoding$h ~headerを包含している場合には、
`Content-Length$h が在る場合でも，［
~messageの~frame法には~~欠陥がある
］かのように扱った上で，
~messageを処理した後に接続を~closeしなければナラナイ。
~messageの`送信者$は、［
接続を更に利用すると誤解釈され得るような，~messageを成すある部位
］を~buffer内に維持しているかもしれないので。
◎
A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message. The message sender might have retained a portion of the message, in buffer, that could be misinterpreted by further use of the connection.
</p>

		</section>
		<section id="body.content-length">
<h3 title="Content-Length">6.2. `Content-Length^h</h3>

<div class="p">
<p>
~messageに `Transfer-Encoding$h ~headerが無いときは、
`Content-Length$h ~headerにより，［
`内容$に見越される，~octet数による~size
］を~decimal~~表現で供せる。
`Content-Length$h `~field値$は、
~messageが`内容$を内包するかどうかに応じて：
◎
When a message does not have a Transfer-Encoding header field, a Content-Length header field (Section 8.6 of [HTTP]) can provide the anticipated size, as a decimal number of octets, for potential content.＼
</p>
<ul class="switch">
	<li>
内包する場合
⇒
`内容$（および~message）がどこで終端するかを決定するために必要yな，~frame法~情報を供する。
◎
For messages that do include content, the Content-Length field value provides the framing information necessary for determining where the data (and message) ends.＼
</li>
	<li>
内包しない場合
⇒
`選定された表現$の~size（ `Content-Length§h ）を指示する。
◎
For messages that do not include content, the Content-Length indicates the size of the selected representation (Section 8.6 of [HTTP]).
</li>
</ul>
</div>

<p>
`送信者$は、
`Transfer-Encoding$h ~headerを包含する どの~messageにも，
`Content-Length$h ~headerを送信してはナラナイ。
◎
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
</p>

<p class="note">注記：
~HTTPにおける［
~message~frame法のための `Content-Length$h の利用
］は、［
~MIMEにおける同じ~fieldの利用
］から有意に相違する
— そこでの `Content-Length^h は、
省略可能な~fieldであり，
`~MIME型$ "`message/external-body^c" の中でしか利用されない。
◎
Note: HTTP's use of Content-Length for message framing differs significantly from the same field's use in MIME, where it is an optional field used only within the "message/external-body" media-type.
</p>

		</section>
		<section id="message.body.length">
<h3 title="Message Body Length">6.3. ~message本体の長さ</h3>

<p>
`~message本体$の長さ（以下，
`本体~長さ@
）は、［
以下に挙げる各~項のうち，当の~messageが該当する~~最初の項
］に対応する記述に従って決定される：
◎
The length of a message body is determined by one of the following (in order of precedence):
</p>

<dl class="switch">
	<dt>
`HEAD$m 要請に対する応答である
◎
Any response to a HEAD request and＼
</dt>
	<dt>
［
`1xx$st ／ `204$st／ `304$st
］応答である
◎
any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code＼
</dt>
	<dd>
~message内にどのような~headerが在るかに関わらず，常に［
一連の~headerの後の最初の`空~行l$
］で終了される。
従って，`~message本体$も`~trailer節$も包含し得ない。
◎
is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body or trailer section.
</dd>

	<dt>
`CONNECT$m 要請に対する， `2xx$st 応答である
◎
Any 2xx (Successful) response to a CONNECT request＼
</dt>
	<dd>
これは，接続が、［
`~header節$を締めくくる`空~行l$の直後から，`~tunnel$になる
］ことを含意する。
`~client$は、
そのような~message内に受信した どの［
`Content-Length$h ／ `Transfer-Encoding$h
］~headerも，無視しなければナラナイ。
◎
implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.
</dd>

	<dt>
`Transfer-Encoding$h ~headerが在る
◎
↓</dt>
	<dd>
<p>
受信した~messageに `Content-Length$h ~headerも在る場合、
`Transfer-Encoding$h が `Content-Length$h を上書きする。
そのような~messageは［
`要請~密入$や`応答~分割$
］を遂行する試みを指示しているかもしれないので、
~errorとして取扱われる~OUGHT。
`媒介者$は，そのような~messageを`下流$へ回送することを選ぶ場合は、
それに先立って，まず受信した `Content-Length$h ~headerを除去してから，
`Transfer-Encoding^h を（下に述べるとおりに）処理しなければナラナイ。
◎
If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream.
</p>

		<ul class="switch">
			<li>
`最終-転送~符号法$は`~chunked$である場合
⇒
`本体~長さ$は、
~chunk化された~dataを［
その転送~符号法により，~dataの完了が指示される
］まで読取って復号することにより，決定される。
◎
If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding,＼
the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.
</li>
			<li>
他の場合、
~messageは応答であるならば
⇒
`本体~長さ$は、
`~server$により~closeされるまで接続を読取ることにより，決定される。
◎
If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding,＼
the message body length is determined by reading the connection until it is closed by the server.
</li>
			<li>
他の場合（~messageは要請である）
⇒
`本体~長さ$は、
依拠-可能に決定し得ない
— `~server$は、
状態s~code `400$st で応答した上で，接続を~closeしなければナラナイ。
◎
If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding,＼
the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.
</li>
		</ul>
	</dd>

	<dt>
妥当でない `Content-Length$h ~headerが在る
◎
If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then＼
</dt>
	<dd>
<p>
~message~frame法は妥当でない。
その`~field値$が［
~commaで分離された~list（ `HTTP$r `~list＠~HTTPinfra#abnf.extension§）として成功裡に構文解析でき、
~list内のすべての値は，妥当かつ互いに同じである場合
（その事例では、
当の~messageは，［
`Content-Length$h `~field値$として，その値が 1 個だけ利用された
］ものとして処理される）
］†を除き…
◎
the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).＼
</p>

<p class="trans-note">【†
`Content-Length$h は`単数~field$であるが、
ここでは特別に取扱われている。
加えて、
この条件を満たす場合でも，~messageを却下することは
`許容されている＠~HTTPsem#invalid-Content-Length$。
】【†
同じ数を表現する異なる値（ `012^c と `12^c など）が，同じと見なされるかどうかは、
はっきりしない。
】</p>

<p>
…を除き，`受信者$は、
それを回復-不能な~errorとして扱った上で，次に従って動作しなければナラナイ
— 当の~errorが：
◎
↑
◎
If the unrecoverable error is＼
</p>
		<ul class="switch">
			<li>
要請~内にある場合
⇒
`~server$は、
状態s~code `400$st で応答した上で，接続を~closeする。
◎
in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.＼
</li>
			<li>
`~proxy$が受信した応答~内にある場合
⇒
`~proxy$は、
`~server$への接続を~closeし,
受信した応答を破棄した上で，`~client$に向けて［
`502$st 応答
］を送信する。
◎
If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client.＼
</li>
			<li>
`~UA$が受信した応答~内にある場合
⇒
`~UA$は、
`~server$への接続を~closeした上で，受信した応答を破棄する。
◎
If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response.
</li>
		</ul>
	</dd>

	<dt>
妥当な `Content-Length$h ~headerが在る
◎
</dt>
	<dd>
その~decimal値【その`~field値$を~decimal数として解釈した結果】が、
~octet数による，期待される`本体~長さ$を定義する。
［
送信者が接続を~closeした
］または［
受信者が指示された~octet数を受信する前に，制限時間を超えた
］場合、
`受信者$は，~messageが`不完全$であると見なして接続を~closeしなければナラナイ。
◎
If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.
</dd>

	<dt>
要請である
◎
</dt>
	<dd>
`本体~長さ$は 0 である（~message本体は無い）。
◎
If this is a request message and none of the above are true, then the message body length is zero (no message body is present).
</dd>

	<dt>
その他の場合
— すなわち，`本体~長さ$が宣言されていない応答~messageである
◎
Otherwise, this is a response message without a declared message body length, so＼
</dt>
	<dd>
`本体~長さ$は［
`~server$が接続を~closeするに先立って受信した~octet数
］により決定される。
◎
the message body length is determined by the number of octets received prior to the server closing the connection.
</dd>
</dl>

<p>
応答~messageが［
成功裡に完了し，~closeで区切られたもの
］なのか,［
~network失敗により中断され，部分的に受信されたもの
］なのかを判別する仕方はないので、
`~server$は，アリな所では、
自身が`生成-$する~messageを［
符号化法または長さ
【 `Transfer-Encoding$h または `Content-Length$h 】
］で区切るベキである。
~closeで区切る特能は、
首に［
~HTTP10との後方-互換性
］用に存在する。
◎
Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.
</p>

<p class="note">注記：
要請~messageが~closeで区切られることは決してない。
それらは常に、
長さまたは`転送~符号法$で明示的に~frame化され，どちらも無いことは［
当の要請は`~header節$の直後で終端する
］ことを含意するので。
◎
Note: Request messages are never close-delimited because they are always explicitly framed by length or transfer coding, with the absence of both implying the request ends immediately after the header section.
</p>

<p>
`~server$は、［
`~message本体$は包含するが
`Content-Length$h は包含しない
］要請に対し，
`411$st で応答して却下してもヨイ。
◎
A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).
</p>

<p>
~chunked以外の`転送~符号法$が適用されていない限り，［
`~message本体$を包含している要請
］を送信する`~client$は、
その`本体~長さ$が前もって既知であるときは，［
`~chunked転送~符号法$
］ではなく［
妥当な `Content-Length$h ~header
］を利用するベキである
— 一部の既存の~serviceは、
`~chunked転送~符号法$を解するにも関わらず，
~chunkedに対し状態s~code `411$st で応答するので。
これは概して、
そのような~serviceが［
呼び出される手前の所に，`内容$の長さを要求する`~gateway$を介する
］ように実装されていて，~serverが［
要請~全体を処理する前に，~bufferできないか そうする用意がない
］ためである。
◎
Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content length in advance of being called, and the server is unable or unwilling to buffer the entire request before processing.
</p>

<p>
`~UA$は、［
`~message本体$を包含する要請
］を送信するときは，妥当な `Content-Length$h ~headerを送信するか`~chunked転送~符号法$を利用しなければナラナイ。
`~client$は、［
`~server$が`~HTTP11$（以上の~version）の要請を取扱える
］ことを知っている場合を除き，`~chunked転送~符号法$を利用してはナラナイ
— そのような知識は、
特定の利用者~環境設定や, ~~直前に受信した応答の`~version$を記憶する形をとるであろう。
◎
A user agent that sends a request that contains a message body MUST send either a valid Content-Length header field or use the chunked transfer coding. A client MUST NOT use the chunked transfer coding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.
</p>

<div class="p">
<p>
接続~上の最後の要請に対する`最終-応答$を`完全$に受信したが，
読取る追加的な~dataが残っている場合
【実際に受信した~dataは、上で決定された`本体~長さ$より長かった場合】、
`~UA$は，次のいずれかを~~行ってもヨイ：
◎
If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY＼
</p>
<ul>
	<li>
残っている~dataを破棄する。
◎
discard the remaining data or＼
</li>
	<li>
その~dataが~~直前の`~message本体$の一部を成すかどうか，決定しようと試みる
— これには、
~~直前の~messageの `Content-Length$h 値が不正である事例が該当し得る。
◎
attempt to determine if that data belongs as part of the prior message body, which might be the case if the prior message's Content-Length value is incorrect.＼
</li>
</ul>
<p>
`~client$は、
そのような余分な~dataを，別々な応答として［
処理-／~cache／回送-
］してはナラナイ
— そのような挙動は、
~cache汚染に対し脆弱になるので。
◎
A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.
</p>
</div>

		</section>
	</section>
	<section id="transfer.codings">
<h2 title="Transfer Codings">7. 転送~符号法</h2>

<p>
`転送~符号法^dfn（ `transfer-coding$p ）は、［
~networkを通した “安全な~transport” を確保するために，~messageの`内容$に適用-［
された／
され得る／
する必要が~~生じ得る
］ような，符号化法の形式変換
］を指示するために利用される。
転送~符号法は、
~messageの~propertyである点で，［
転送されている`表現$の~propertyである，`内容~符号法$
］から相違する。
◎
Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a message's content in order to ensure "safe transport" through the network. This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.
</p>

<p>
`transfer-coding$p を成す先頭の `token$p が
`転送~符号法の名前@
を与える。
`転送~符号法の名前$は、
すべて文字大小無視である。
それらは、
`7.3§ に定義されるとおり，
`~HTTP転送~符号法~registry$citeに登録される~OUGHT。
それらは、［
`Transfer-Encoding$h ／ `TE$h
］~header内で利用される
（後者は `transfer-coding^p の文法も定義する）。
◎
All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 7.3. They are used in the Transfer-Encoding (Section 6.1) and TE (Section 10.1.4 of [HTTP]) header fields (the latter also defining the "transfer-coding" grammar).
</p>

		<section id="chunked.encoding">
<h3 title="Chunked Transfer Coding">7.1. ~chunked転送~符号法</h3>

<div class="p">
<p>
`~chunked転送~符号法^dfn
（ "`chunked^c" `転送~符号法$）は、
`内容$を，次の並びとして転送するために包装する：
◎
The chunked transfer coding wraps content in order to transfer it as＼
</p>
<ol>
	<li>
一連の~chunk
— 各~chunkは、
自前の~size指示子（ `chunk-size$p ）を~serveする。
◎
a series of chunks, each with its own size indicator,＼
</li>
	<li>
`省略可能^2119な，何個かの`~trailer$を包含する`~trailer節$。
◎
followed by an OPTIONAL trailer section containing trailer fields.＼
</li>
</ol>

<p>
~chunkedは、［
~sizeが未知な内容~stream
］を［
長さで区切られる，一連の~buffer
］として転送することを可能化する。
それは、［
送信者が接続の持続性を維持しつつ、
受信者は，いつ~message全体が受信されたかを知る
］ことを可能化する。
◎
Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.
</p>
</div>

<pre class="bnf">
`chunked-body@p
	= *`chunk$p `last-chunk$p `trailer-section$p `CRLF$P
`chunk@p
	= `chunk-size$p [ `chunk-ext$p ] `CRLF$P `chunk-data$p `CRLF$P
`chunk-size@p
	= 1*`HEXDIG$P
`last-chunk@p
	= 1*("0") [ `chunk-ext$p ] `CRLF$P
`chunk-data@p
	= 1*OCTET
	; <span class="comment">~~長さ `chunk-size^p の~octet列
◎
a sequence of chunk-size octets
</span>
</pre>

<p>
`chunk-size$p ~fieldは、
1 個以上の~hex数字からなる文字列であり，
~octet数による `chunk-data$p の~sizeを指示する。
~chunked転送~符号法が完了するのは、［
`chunk-size$p が 0 にされた~chunk
— 場合によっては`~trailer節$も後続する —
が受信され，最後に空~行lにより終了された
］ときである。
◎
The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer section, and finally terminated by an empty line.
</p>

<p>
`受信者$は、
~chunked転送~符号法を構文解析して復号できなければナラナイ。
◎
A recipient MUST be able to parse and decode the chunked transfer coding.
</p>

<p>
`~HTTP11$は、
~chunk化された応答の~sizeを［
`媒介者$が応答~全体を~bufferできることが確約される
］ように制限する手段を，何ら定義しない。
加えて，~chunk~sizeが巨大~過ぎる場合、
受信している実装が~sizeを正確aに表現できないと，桁溢れや精度の損失が生じ得る。
したがって，`受信者$は、［
~hexadecimalを成す数字列が巨大になり得ること／
整数~変換の桁溢れ／
整数~変換に因る精度~損失
］を見越して，それらによる~errorを防止しなければナラナイ
◎
HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response. Additionally, very large chunk sizes may cause overflows or loss of precision if their values are not represented accurately in a receiving implementation. Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.
</p>

<p>
~chunked符号法に定義される~parameterは無い。
~parameterが在っても、
~errorに扱われるベキではない。
◎
The chunked coding does not define any parameters. Their presence SHOULD be treated as an error.
</p>

			<section id="chunked.extension">
<h4 title="Chunk Extensions">7.1.1. ~chunk拡張</h4>

<p>
`~chunked$符号法は、［
各~chunk（ `chunk$p ）が
`chunk-size$p の直後に【！zero or more】
`~chunk拡張^dfn
（ `chunk-ext$p ）を内包する
］ことを許容する
— その~~目的は、
次を給することである
⇒＃
~chunkごとの~metadata（署名や~hashなど）,
~messageの中途を制御する情報,
`~message本体$~sizeの~random化
◎
The chunked coding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size.
</p>

<pre class="bnf">
`chunk-ext@p
	= *( `BWS$p ";" `BWS$p `chunk-ext-name$p [ `BWS$p "=" `BWS$p `chunk-ext-val$p ] )
`chunk-ext-name@p
	= `token$p
`chunk-ext-val@p
	= `token$p
	/ `quoted-string$p
</pre>

<p>
`~chunked$符号法は，接続ごとに特有であり、［
より高~levelな応用が，それらの拡張を検分する機会cを得る
］より前に，`受信者$たち（`媒介者$も含む）により，除去されたり再符号される見込みが高い。
よって，`~chunk拡張$の利用は、
一般に，特化された~HTTP~serviceに制限される
— 例えば：［
“`long polling^en” （~clientと~serverは，~chunk拡張の利用に関する期待を共有する）／
`端点間$の`~secure化$された接続の中での~padding
］用など。
◎
The chunked coding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, the use of chunk extensions is generally limited to specialized HTTP services such as "long polling" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.
</p>

<p>
`受信者$は、［
自身が認識しない`~chunk拡張$
］を無視しなければナラナイ。
`~server$は、［
要請~内に受信される~chunk拡張の総~長さ
］を［
供される~serviceに見合う量
］に制限する~OUGHT
— ［
~messageの他の各部に適用される，長さ制限や制限時間
］と同じ仕方で、かつ，その量を超過したときは［
適切な `4xx$st 応答
］を`生成-$することにより。
◎
A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.
</p>

			</section>
			<section id="chunked.trailer.section">
<h4 title="Chunked Trailer Section">7.1.2. ~chunked~trailer節</h4>

<p>
`~trailer節$（ `trailer-section$p ）は、［
`内容$が送信される間に，動的に`生成-$され得る~metadata
— ~message完全性~検査, ~digital署名, 後処理~状態sなど —
を給する
］ために［
~chunk化された~messageの末尾に追加的な`~field$を内包する
］ことを`送信者$に許容する。
`~trailer$の適正な利用と制限は、
`HTTP$r `~trailer＠~HTTPinfra#trailer.fields§にて定義される。
◎
A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the content is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 6.5 of [HTTP].
</p>

<pre class="bnf">
`trailer-section@p
	= *( `field-line$p `CRLF$P )
</pre>

<p>
`受信者$は、
~messageから`~chunked$符号法を除去するときは，
受信した各`~trailer$を選択的に維持しても破棄してもヨイ。
受信者は、
受信した~trailerを維持する場合は，それを
受信した~headerとは別々に［
格納する／回送する
］か，`~header節$の中へ併合しなければナラナイ
— ただし，併合するのは、［
当の~trailerに対応する~field【！~header】定義が、
そうすることを明示的に許可していて，
その`~field値$をどう安全に併合するか指図している場合
］に限らなければナラナイ。
◎
A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.＼
A recipient that retains a received trailer field MUST either store/forward the trailer field separately from the received header fields or merge the received trailer field into the header section.＼
A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.
</p>

			</section>
			<section id="decoding.chunked">
<h4 title="Decoding Chunked">7.1.3. ~chunkedの復号-法</h4>

<p>
`~chunked転送~符号法$を復号する処理nは、
次の疑似~codeで表現できる：
◎
A process for decoding the chunked transfer coding can be represented in pseudo-code as:
</p>

<div class="p">
<ol>
	<li>
%長さ ~LET 0
</li>
	<li>
%内容 ~LET 空
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
［
`chunk-size$p, `chunk-ext$p （もしあれば）, `CRLF$P
］を読取る
</li>
			<li>
~IF［
`chunk-size$p ~EQ 0
］
⇒
~BREAK
</li>
			<li>
［
`chunk-data$p, `CRLF$P
］を読取る
</li>
			<li>
%内容 に `chunk-data$p を付加する
</li>
			<li>
%長さ ~INCBY `chunk-size$p
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%~trailer ~LET 次の`~trailer$を読取った結果
</li>
			<li>
~IF［
%~trailer は空である
］
⇒
~BREAK
</li>
			<li>
~IF［
%~trailer は別々に［
格納する／回送する
］ことが許容されている
］
⇒
既存の`~trailer節$に %~trailer を付加する
</li>
			<li>
~ELIF［
受信者は %~trailer を解する，かつ %~trailer は併合-可能であるものと定義されている
］
⇒
既存の`~header節$に %~trailer を併合する
</li>
			<li>
~ELSE
⇒
%~trailer を破棄する
</li>
		</ol>

<p class="trans-note">【
この段の~logicは、
前節に述べた要件と違って，裁量の余地が無いかのように記されている。
（“疑似~code” なので、規範的ではない？）
】</p>

	</li>
	<li>
`Content-Length$h の`~field値$ ~SET %長さ
</li>
	<li>
`Transfer-Encoding$h から "`chunked$c" を除去する
</li>
	<li>
~RET %内容
</li>
</ol>

<pre lang="en" class="_en">
length := 0
read chunk-size, chunk-ext (if any), and CRLF
while (chunk-size &gt; 0) {
   read chunk-data and CRLF
   append chunk-data to content
   length := length + chunk-size
   read chunk-size, chunk-ext (if any), and CRLF
}
read trailer field
while (trailer field is not empty) {
   if (trailer fields are stored/forwarded separately) {
       append trailer field to existing trailer fields
   }
   else if (trailer field is understood and defined as mergeable) {
       merge trailer field with existing header fields
   }
   else {
       discard trailer field
   }
   read trailer field
}
Content-Length := length
Remove "chunked" from Transfer-Encoding
</pre>
</div>

			</section>
		</section>
		<section id="compression.codings">
<h3 title="Transfer Codings for Compression">7.2. 圧縮~用の転送~符号法</h3>

<p>
次に挙げる圧縮~用の`転送~符号法の名前$は、
対応する`内容~符号法の名前$と同じ~algoにより定義される
⇒＃
`compress$c （および `x-compress^c ）,
`deflate$c,
`gzip$c （および `x-gzip^c ）
◎
The following transfer coding names for compression are defined by the same algorithm as their corresponding content coding:
◎
compress (and x-compress)
• See Section 8.4.1.1 of [HTTP].
deflate
• See Section 8.4.1.2 of [HTTP].
gzip (and x-gzip)
• See Section 8.4.1.3 of [HTTP].
</p>

<p>
これらの圧縮~符号法に定義される~parameterは無い。
これらの圧縮~符号法に~parameterが在る場合、
~errorとして扱われるベキである。
◎
The compression codings do not define any parameters. The presence of parameters with any of these compression codings SHOULD be treated as an error.
</p>

		</section>
		<section id="transfer.coding.registry">
<h3 title="Transfer Coding Registry">7.3. 転送~符号法~registry</h3>

<p>
`転送~符号法の名前$用の名前空間は、
`~HTTP転送~符号法~registry$cite
にて保守され，定義される。
◎
The "HTTP Transfer Coding Registry" defines the namespace for transfer coding names. It is maintained at &lt;https://www.iana.org/assignments/http-parameters&gt;.
</p>

<p>
各~登録は、
次に挙げる~fieldを含んでいなければナラナイ
⇒＃
名前,
記述,
仕様~textへの~pointer
◎
Registrations MUST include the following fields:
• Name
• Description
• Pointer to specification text
</p>

<p>
各 `転送~符号法の名前$は、
`内容~符号法の名前$ `HTTP$r と重合してはナラナイ
— 符号化法の形式変換
（`内容~符号法§にて定義される各種 圧縮~符号法など）
が一致している場合を除き。
◎
Names of transfer codings MUST NOT overlap with names of content codings (Section 8.4.1 of [HTTP]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.
</p>

<p>
`TE$h ~headerは、
複数の転送~符号法が受容-可能なときに，
順位~値として名前 "`q^c" の疑似~parameterを利用する。
多義性を避けるため、
将来における転送~符号法の登録は，
"`q^c" （文字大小無視）と呼ばれる~parameterを定義するベキでない。
◎
The TE header field (Section 10.1.4 of [HTTP]) uses a pseudo-parameter named "q" as the rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called "q" (case-insensitively) in order to avoid ambiguities.
</p>

<p>
この名前空間に追加される値は、
`~IETFによる考査$が要求され，［
この仕様にて定義される`転送~符号法$の目的
］に適合しなければナラナイ。
◎
Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.
</p>

<p>
~program名は、
符号化~形式の識別~用には望ましくないので，
将来の符号化法には利用しないことが奨励される。
◎
Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
</p>

		</section>
		<section id="transfer.coding.negotiation">
<h3 title="Negotiating Transfer Codings">7.4. 転送~符号法の折衝-法</h3>

<p>
~HTTP11にて利用される `TE$h ~fieldは、
次を指示する
⇒＃
~clientは、`~chunked$の他に，どの`転送~符号法$を応答~内に受容する用意があるか／
~clientは、`~chunked転送~符号法$にて`~trailer$を保全する用意があるかどうか
◎
The TE field (Section 10.1.4 of [HTTP]) is used in HTTP/1.1 to indicate what transfer codings, besides chunked, the client is willing to accept in the response and whether the client is willing to preserve trailer fields in a chunked transfer coding.
</p>

<p>
`~client$は、
`TE$h 内に，`転送~符号法の名前$として "`chunked$c" を送信してはナラナイ
— `~HTTP11$`受信者$に対しては、
`~chunked$は常に受容-可能なので。
◎
A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.
</p>

<div class="example">
<p>
`TE$h の利用を示す 3 つの例：
◎
Three examples of TE use are below.
</p>

<pre class="lang-http">
TE: deflate
TE:
TE: trailers, deflate;q=0.5
</pre>
</div>

<p>
`~client$は，複数の`転送~符号法$が受容-可能なときは、
文字大小無視な "`q=^c" ~parameterを利用して，
それらの符号法の選好を順位~付けてもヨイ。
この “順位” 値は、
0 以上 1 以下の実数であり，値が大きいほど選好される
（`内容~折衝$~fieldにて利用される`品質値$（ “`qvalue^en” ）に類似する）
⇒＃
`0.001^c は、最も選好されないことを表す【小数部は 3 桁までなので】／
`1^c は、最も選好されることを表す／
`0^c は、 “受容-可能でない” ことを意味する
◎
When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive "q" parameter (similar to the qvalues used in content negotiation fields; see Section 12.4.2 of [HTTP]).＼
The rank value is a real number in the range 0 through 1, where＼
0.001 is the least preferred and＼
1 is the most preferred;＼
a value of 0 means "not acceptable".
</p>

<p>
［
`TE$h の`~field値$が空, または
`TE$h ~header【！~field】は無い
］場合、
受容-可能な`転送~符号法$は "`chunked$c" に限られる。
転送~符号法を伴わない~messageは、
常に受容-可能である。
◎
If the TE field value is empty or if no TE field is present, the only acceptable transfer coding is chunked. A message with no transfer coding is always acceptable.
</p>

<p>
~keyword "`trailers$c" は、
送信者は`~trailer$を破棄しないことを指示する
（ `HTTP$r `~trailer＠~HTTPinfra#trailer.fields§ ）。
◎
The keyword "trailers" indicates that the sender will not discard trailer fields, as described in Section 6.5 of [HTTP].
</p>

<p>
`TE$h ~headerは，直近への接続に限り適用されるので、
`TE$h の`送信者$は
— ［
`TE$h の意味論を~supportしない`媒介者$による `TE$h ~headerの回送
］を防止するため —
`Connection$h ~headerの中に "`TE^c" `接続~option$も送信しなければナラナイ。
◎
Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a "TE" connection option within the Connection header field (Section 7.6.1 of [HTTP]) in order to prevent the TE header field from being forwarded by intermediaries that do not support its semantics.
</p>

		</section>
	</section>
	<section id="incomplete.messages">
<h2 title="Handling Incomplete Messages">8. 不完全な~messageの取扱い</h2>

<p>
`不完全$な要請~messageを受信した`~server$は、
接続を~closeするに先立って，~error応答を送信してもヨイ。
そのような要請は、
通例的に［
要請が取消された／制限時間による例外が誘発された
］ことに因る。
◎
A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.
</p>

<p>
`不完全$な応答~messageを受信した`~client$は、
その~messageを不完全なものと記録しなければナラナイ。
そのような応答は、［
接続が尚早に~closeされた／
`~chunked転送~符号法$と思しきものの復号に失敗した
］ときに生じ得る。
不完全な応答~用の`~cache$に対する要件は、
`CACHING$r `不完全な応答の格納-法＠~HTTPcache#incomplete.responses§にて定義される。
◎
A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3.3 of [CACHING].
</p>

<p>
応答が［
`~header節$の中途で（すなわち，`空~行l$が受信される前に）終了した
］かつ［
その`状態s~code$は、
応答の全部的な意味を~headerに依拠して伝達することもある
］場合、
`~client$は，その意味が伝達されたものと見做せないので、
次にとる動作を決定するために，要請を繰返す必要が~~生じ得る。
◎
If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.
</p>

<div class="p">
<p>
次のどちらにも該当しない~messageは、
`不完全$とされる：
</p>
<ul>
	<li>
`~message本体$の`転送~符号法$に`~chunked$が利用されていて、
符号化を終了させる［
~size 0 の~chunk
］は，すでに受信した。
</li>
	<li>
妥当な `Content-Length$h が利用されていて、
その`~field値$は，受信した`~message本体$の（~octet数による）~size以下である。
</li>
</ul>
◎
A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received. A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length.＼
</div>

<p>
`~chunked転送~符号法$も `Content-Length$h も伴わない応答は，
接続の~closureにより終了されるので、
`~header節$を欠損なく受信した場合には，`完全$と見なされる
— 下層の接続により~errorが指示されない限り
（例： ~TLSにおける “不完全な~close” は、
`9.8§ にて述べるとおり，応答を不完全なままにする）。
◎
A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, if the header section was received intact, is considered complete unless an error was indicated by the underlying connection (e.g., an "incomplete close" in TLS would leave the response incomplete, as described in Section 9.8).
</p>

	</section>
	<section id="connection.management">
<h2 title="Connection Management">9. 接続の管理</h2>

<p>
~HTTP~message法は、
下層の［
~transport／~session
］層における接続~protocolたちには，依存しない。
~HTTPは、［［
各~要請の順序~通りの送達と，それらに対応する各~応答の順序~通りの送達
］による~transportに依拠-可能である
］ことのみを~~前提にする。
~HTTP［
要請／応答
］の構造から［
下層~transport~protocolの~data単位
］への対応付けは、
この仕様の視野から外れる。
◎
HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s). HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses. The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.
</p>

<p>
~HTTPのヤリトリに利用される［
特定の接続~protocol
］は、
`HTTP$r `内方への要請の~route法＠~HTTPsem#routing.inbound§にて述べたとおり，［
`~client$の環境設定, および`~target~URI$
］により決定される。
例えば，
"`http$c" ~URI~schemeは［
~IP越しの~TCPとして，既定の~TCP~port 80を伴う既定の接続
］を指示するが、
~clientは［
他の何らかの［
接続 ／ ~port ／ ~protocol
］を介した`~proxy$
］を利用するようにも環境設定され得る。
◎
As described in Section 7.3 of [HTTP], the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI. For example, the "http" URI scheme (Section 4.2.1 of [HTTP]) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.
</p>

<div class="p">
<p>
~HTTP実装には、
接続の管理に参加することが期待されている
— それには，次が含まれる：
◎
HTTP implementations are expected to engage in connection management, which includes＼
</p>
<ul>
	<li>
現在の接続の状態を保守する。
◎
maintaining the state of current connections,＼
</li>
	<li>
新たな接続を確立したり, 既存の接続を再利用する。
◎
establishing a new connection or reusing an existing connection,＼
</li>
	<li>
接続~上にて受信した~messageを処理する。
◎
processing messages received on a connection,＼
</li>
	<li>
接続の失敗を検出する。
◎
detecting connection failures,＼
</li>
	<li>
各~接続を~closeする。
◎
and closing each connection.＼
</li>
</ul>

<p>
ほとんどの`~client$は、
複数の接続
— 同じ~server`端点$に対する複数個の接続も含む —
を並列的に保守する。
ほとんどの`~server$は、［
公正な利用は可能化しつつ，~DoS攻撃を検出する
］ために，［
要請の~queueを制御しながら, 幾千もの同時並行な接続を保守する
］ように設計されている。
◎
Most clients maintain multiple connections in parallel, including more than one connection per server endpoint. Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.
</p>
</div>

		<section id="persistent.establishment">
<h3 title="Establishment">9.1. 確立法</h3>

<p>
接続が，様々な［
~transport／~session
］層の~protocolを介して確立される方法について述べることは、
この仕様の視野を超える。
各~HTTP~接続は、
1 個の下層の~transport接続に対応付けられる。
◎
It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols. Each HTTP connection maps to one underlying transport connection.
</p>

		</section>
		<section id="associating.response.to.request">
<h3 title="Associating a Response to a Request">9.2. 応答から要請への結付け</h3>

<p>
~HTTP11には、［
所与の要請~message
］を［
1 個~以上の，対応する応答~message
］に結付けるような要請~識別子は，ない。
よって，その結付けは［
同じ接続~上で要請が為された順序が，応答が到着した順序に正確に対応する
］ことに依拠する。
1 個の要請に対し複数個の応答~messageが生じるのは、［
同じ要請に対する`最終-応答$に，
1 個~以上の`非最終-応答$（ `1xx$st 応答）が先行するとき
］に限られる。
◎
HTTP/1.1 does not include a request identifier for associating a given request message with its corresponding one or more response messages. Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection. More than one response message per request only occurs when one or more informational responses (1xx; see Section 15.2 of [HTTP]) precede a final response to the same request.
</p>

<p>
`~client$は、
接続~上に
`応答待ち要請@
— まだ`最終-応答$（非 `1xx$st 応答）が受信されていない要請 —
が複数個あるときには、
次に従わなければナラナイ
⇒
それらの要請からなる，送信した順序による~listを保守した上で、
その接続~上で応答~messageを受信したときは、
~listから最初の応答待ち要請を抜き取って，受信した応答に結付ける。
◎
A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the first outstanding request that has not yet received a final (non-1xx) response.
</p>

<p>
`~client$は、
`応答待ち要請$が無い接続~上で~dataを受信したとしても，妥当な応答と見なしてはナラナイ。
`~client$は、
そのような接続を~closeするベキである
— ~messageの区切りは、
今や多義的なので
（当の~dataが，`~messageの構文解析-法§により破棄できる何個かの `CRLF$P のみからなる場合は別として）。
◎
If a client receives data on a connection that doesn't have outstanding requests, the client MUST NOT consider that data to be a valid response; the client SHOULD close the connection, since message delimitation is now ambiguous, unless the data consists only of one or more CRLF (which can be discarded per Section 2.2).
</p>

		</section>
		<section id="persistent.connections">
<h3 title="Persistence">9.3. 持続性</h3>

<p>
`~HTTP11$では、
`持続的な接続^dfn
は，既定で利用できる
— これは、
単独の接続~越しに，複数の［
要請や応答
］を運べるようにする。
~HTTP実装は、
`持続的な接続$を~supportするベキである。
◎
HTTP/1.1 defaults to the use of "persistent connections", allowing multiple requests and responses to be carried over a single connection. HTTP implementations SHOULD support persistent connections.
</p>

<p>
`受信者$は、［
最も近過去に受信した~message
］内の［
`~protocol~version$, および［
在るならば `Connection$h ~header
］］に基づいて，［
接続が現在の応答の後にも持続することになるかどうか
【！ or not based on = or not, based on 】
］を決定する：
◎
A recipient determines whether a connection is persistent or not based on the protocol version and Connection header field (Section 7.6.1 of [HTTP]) in the most recently received message, if any:
</p>
<ol>
	<li>
"`close$c" `接続~option$が在るならば、
持続しない。
◎
If the "close" connection option is present (Section 9.6), the connection will not persist after the current response; else,
</li>
	<li>
他の場合，
受信した~protocolは`~HTTP11$（以上の~version）ならば、
持続する。
◎
If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,
</li>
	<li>
<p>
他の場合， ~AND↓ が満たされるならば、
持続する：
</p>
		<ul>
			<li>
受信した~protocolは~HTTP10である。
</li>
			<li>
"`keep-alive$c" `接続~option$が在る。
</li>
			<li>
受信者は~proxyでない, または~messageは応答である。
</li>
			<li>
受信者は［
~HTTP10による "`keep-alive$c" の仕組み
］を尊守するよう望んでいる。
</li>
		</ul>
◎
If the received protocol is HTTP/1.0, the "keep-alive" connection option is present, either the recipient is not a proxy or the message is a response, and the recipient wishes to honor the HTTP/1.0 "keep-alive" mechanism, the connection will persist after the current response; otherwise,
</li>
	<li>
他の場合，持続しない。
◎
The connection will close after the current response.
</li>
</ol>

<p>
`持続的な接続$を~supportしない`~client$は、
各~要請~messageごとに，
"`close$c" `接続~option$を送信しなければナラナイ。
◎
A client that does not support persistent connections MUST send the "close" connection option in every request message.
</p>

<p>
`持続的な接続$を~supportしない`~server$は、
各［
`最終-応答$を成す~message
］ごとに，
"`close$c" `接続~option$を送信しなければナラナイ。
◎
A server that does not support persistent connections MUST send the "close" connection option in every response message that does not have a 1xx (Informational) status code.
</p>

<p>
`~client$は、
自身が［
"`close$c" `接続~option$を送信するか受信する
］または［
"`keep-alive$c" `接続~option$を伴わない~HTTP10応答を受信する
］まで、
`持続的な接続$上に，追加的な要請を送信してもヨイ。
◎
A client MAY send additional requests on a persistent connection until it sends or receives a "close" connection option or receives an HTTP/1.0 response without a "keep-alive" connection option.
</p>

<p>
持続的であり続けるためには、
接続~上の どの~messageも
— `~message本体§に述べたように —
その長さが~message自身により定義される必要がある
（すなわち，長さは接続の~closureにより定義されるものではない）。
`~server$は、［
要請の`~message本体$全体を読取る
］または［
自身が応答を送信した後に接続を~closeする
］のいずれかをしなければナラナイ
— さもなければ、［
`持続的な接続$上に残っている~data
］が［
その次の要請として誤解釈される
］ことになる。
同様に，`~client$は、［
後続な要請に同じ接続を再利用する
］ことを意図するならば，［
応答の`~message本体$全体
］を読取らなければナラナイ。
◎
In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 6. A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.
</p>

<p>
`~proxy$~serverは、
~HTTP10`~client$と伴に `持続的な接続$を保守してはナラナイ
（多くの~HTTP10~clientにより実装されている `Keep-Alive$h ~headerに伴われる問題の情報, 論点については、
`Keep-Alive§h を見よ）。
◎
A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Appendix C.2.2 for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).
</p>

<p>
~HTTP10~clientに対する後方-互換性についての更なる情報は、
`Keep-Alive§h を見よ。
◎
See Appendix C.2.2 for more information on backwards compatibility with HTTP/1.0 clients.
</p>

			<section id="persistent.retrying.requests">
<h4 title="Retrying Requests">9.3.1. 要請の再試行-法</h4>

<p>
意図nの有無を問わず、
接続は，いつでも~closeできる。
実装は、［
非同期的な~close~eventから回復する必要があるかどうか
］を見越しておく~OUGHT。
どの条件の下で，`~client$が一連の`応答待ち要請$を自動的に再試行できるかは、
`HTTP$r `冪等~method＠~HTTPsem#idempotent.methods§にて定義される。
◎
Connections can be closed at any time, with or without intention. Implementations ought to anticipate the need to recover from asynchronous close events. The conditions under which a client can automatically retry a sequence of outstanding requests are defined in Section 9.2.2 of [HTTP].
</p>

			</section>
			<section id="pipelining">
<h4 title="Pipelining">9.3.2. ~pipeline法</h4>

<p>
［
`持続的な接続$を~supportする`~client$
］は、
自身の要請を
`~pipeline化^dfn
してもヨイ
（すなわち、
各~応答を待機せずに，複数の要請を送信する）。
`~server$は、［
~pipeline化された一連の要請
］を［
それらすべてが`安全$な~methodを伴う
］ならば，並列的に処理してもヨイ
— その際には、
要請を受信した順序と同じ順序で，対応する応答を送信しなければナラナイ。
◎
A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 9.2.1 of [HTTP]), but it MUST send the corresponding responses in the same order that the requests were received.
</p>

<p>
要請を~pipeline化する`~client$は、［
対応する応答~すべてを受信する前に接続が~closeされた
］場合は，未~回答な要請を再試行するベキである。
接続が失敗した（接続が，~serverによる最後の完全な応答により明示的に~closeされていない）後に［
要請の~pipeline化を再試行する
］ときは、
`~client$は，［
接続が確立された直後
］に~pipeline化してはナラナイ
— ［
先の~pipelineに残っている要請のうち，~~最初のもの
］が~error応答の原因になったかもしれず、［
複数の要請が［
尚早に~closeされた接続
］に対し送信される
］場合に再び失われ得るので（ `9.6§ にて述べる~TCP~reset問題を見よ）。
◎
A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 9.6).
</p>

<p>
`冪等$な~methodは、
~pipeline化において有意である
— それらは、
接続~失敗に際しても自動的に再試行できるので。
`~UA$は，要請の~methodが`冪等$でない場合、
対する`最終-応答$【！final response status code for that method】が受信されるまでは，要請を~pipeline化するベキでない
— ただし，`~UA$が［
~pipeline化された一連の要請を孕んでいる部分的な失敗~条件
］を［
検出して，それを回復する手段
］を備えている場合は除く。
◎
Idempotent methods (Section 9.2.2 of [HTTP]) are significant to pipelining because they can be automatically retried after a connection failure. A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.
</p>

<div class="p">
<p>
~pipeline化された要請たちを受信した`媒介者$は、
それらを`内方$へ回送するときに，~pipeline化してもヨイ
— 要請たちを安全に~pipeline化できるかどうかは、
`外方$にある~UA（たち）に依拠して決定できるので。
~pipeline化している`媒介者$は、
いずれかの要請に対する応答を受信する前に，`内方$への接続が失敗した場合には：
◎
An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined. If the inbound connection fails before receiving a response, the pipelining intermediary＼
</p>
<ul>
	<li>
どの要請も，その~methodは`冪等$ならば、［
対する応答を まだ受信していない要請
］を再試行しようと試みてもヨイ。
◎
MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods;＼
</li>
	<li>
他の場合、
受信した応答は すべて回送してから，対応する`外方$への接続（たち）を~closeするベキである
— `外方$にある~UA（たち）が，それに則って回復できるよう。
◎
otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.
</li>
</ul>
</div>

			</section>
		</section>
		<section id="persistent.concurrency">
<h3 title="Concurrency">9.4. 同時並行性</h3>

<p>
`~client$は、
所与の`~server$に対し保守する［
同時~open接続~数
］を制限する~OUGHT。
◎
A client ought to limit the number of simultaneous open connections that it maintains to a given server.
</p>

<p>
~HTTPの以前の改訂では，接続~数に特定の~~上限を設けていたが、
これは，多くの応用にとり実用的でないことが判っている。
そのため，この仕様は、
特定0の最大~接続~数を義務付けない
— 代わりに、
~clientが複数の接続を~openするにあたっては，保守的になることを奨励する。
◎
Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.
</p>

<p>
複数~接続は、
概して， “`head-of-line blocking^en” 問題
— ［
`~server$側に重い処理を要したり, 巨大な`内容$を転送する
］ような要請が、
同じ接続~上の後続な要請を阻むこと —
を避けるために利用される。
しかしながら、
接続のそれぞれが~server資源を消費する。
◎
Multiple connections are typically used to avoid the "head-of-line blocking" problem, wherein a request that takes significant server-side processing and/or transfers very large content would block subsequent requests on the same connection. However, each connection consumes server resources.
</p>

<p>
更には，複数~接続が利用された場合、
混雑した~networkに望ましくない副作用をもたらし得る。
より多数な接続が利用された場合、
混雑していない~networkにも副作用をもたらし得る
— それらを集成した，初期~時には同期された送信による挙動は、
より少数な並列的な接続が利用されていたなら無かった混雑の原因になり得るので。
◎
Furthermore, using multiple connections can cause undesirable side effects in congested networks. Using larger numbers of connections can also cause side effects in otherwise uncongested networks, because their aggregate and initially synchronized sending behavior can cause congestion that would not have been present if fewer parallel connections had been used.
</p>

<p>
`~server$は、
単独の~clientからの過度な~open接続~数など，［
濫用的あるいは, ~DoS攻撃の特性を有している
］と判断した流通を却下することもあることに注意。
◎
Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.
</p>

		</section>
		<section id="persistent.failures">
<h3 title="Failures and Timeouts">9.5. 失敗と制限時間</h3>

<p>
`~server$は、
通例的に，何らかの制限時間~値を持つ
— 作動中でない接続が それを超過したときは、
もはや保守しなくなるような。
~proxy~serverは、
この値をより高くすることもある
— `~client$は、
同じ~proxy~serverを通して，更なる接続を~~確立する見込みが高いので。
`持続的な接続$の利用は、［
`~client$／`~server$
］どちらに対しても［
この制限時間の長さ（または その有無）
］に要件を設置しない。
◎
Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.
</p>

<p>
制限時間を望む［
`~client$／`~server$
］は、
接続~上に上品な~closeを発行するベキである。
実装は、［
~open接続にて受信される~closure通達
］を常時~監視して，それに対し適切に応答するベキである
— 接続の両~側に向けて~closureを促すことで，割振られた~system資源を取戻せるようになるので。
◎
A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.
</p>

<p>
［
`~client$／`~server$／`~proxy$
］は、
~transport接続をいつでも~closeしてもヨイ。
例えば、
~serverが “遊休~中” の接続を~closeすると裁定したと同時に，
~clientが新たな要請の送信を開始することもあり得る
— その場合、
~server視点からは，遊休~中に接続が~closeされているように見える一方で、
~client視点からは，要請は進捗~中に見えることになる。
◎
A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the "idle" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.
</p>

<p>
`~server$は、
アリなときは，`持続的な接続$を維持させ, ［
一時的な過負荷は、
下層~transportの~flow制御の仕組みにより解決できる
］ようにするベキである
— `~client$が再試行する期待に基づいて，接続を終了させる技法は、［
~network混雑／~server負荷
］を悪化させ得るので。
◎
A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion or server load.
</p>

<p>
`~message本体$を送信している`~client$は、
要請を伝送している間，~error応答に関して~network接続を監視するベキである。
【すなわち，】~clientは、
応答から［
`~server$は、
`~message本体$を受信することを望まず，接続を~closeしている
］ことが指示された場合には，［
本体の伝送処理を即時に止めた上で，自身の側の接続を~closeする
］ベキである。
◎
A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.
</p>

		</section>
		<section id="persistent.tear-down">
<h3 title="Tear-down">9.6. 解体</h3>

<p>
"`close@c"
`接続~option$は、［
`送信者$は、
応答の完了~後に，この接続を~closeすることになる
］ことの通達として定義される。
`送信者$は、
接続を~closeするよう意図するときは，
"`close$c" `接続~option$を包含している `Connection$h ~headerを送信するベキである。
◎
The "close" connection option is defined as a signal that the sender will close this connection after completion of the response. A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the "close" connection option when it intends to close a connection.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Connection: close
</pre>

<p>
この~headerは、
要請においては，［
当の~messageは、
~clientが この接続に対し送信する最後の要請である
］ことを指示する一方で、
応答においては，［
~serverは、
当の~messageを完了した後に，この接続を~closeしようとしている
］ことを指示する。
◎
as a request header field indicates that this is the last request that the client will send on this connection, while in a response, the same field indicates that the server is going to close this connection after the response message is complete.
</p>

</div>

<p id="field.close">
`~field名$ `Close^h は、
予約-済みであることに注意
— その名前を~headerとして利用すると、
"`close$c" `接続~option$と競合するかもしれないので。
◎
Note that the field name "Close" is reserved, since using that name as a header field might conflict with the "close" connection option.
</p>

<div class="p">
<p>
"`close$c" `接続~option$を伴う要請を送信した`~client$は：
◎
A client that sends a "close" connection option＼
</p>
<ul>
	<li>
当の接続に対し更なる要請を送信してはナラナイ。
◎
MUST NOT send further requests on that connection (after the one containing the "close") and＼
</li>
	<li>
この要請に対応する`最終-応答$を成す~messageを読取ったときは，当の接続を~closeしなければナラナイ。
◎
MUST close the connection after reading the final response message corresponding to this request.
</li>
</ul>
</div>

<div class="p">
<p>
"`close$c" `接続~option$を伴う要請を受信した`~server$は：
◎
A server that receives a "close" connection option＼
</p>
<ul>
	<li>
その要請に対する`最終-応答$を送信した後に，当の接続の~closure（下を見よ）を起動しなければナラナイ。
◎
MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the "close" connection option.＼
</li>
	<li>
前項の`最終-応答$内には［
"`close$c" `接続~option$
］を送信するベキである。
◎
The server SHOULD send a "close" connection option in its final response on that connection.＼
</li>
	<li>
当の接続から更なる要請を受信しても、
処理してはナラナイ。
◎
The server MUST NOT process any further requests received on that connection.
</li>
</ul>
</div>

<div class="p">
<p>
"`close$c" `接続~option$を伴う応答を送信した`~server$は：
◎
A server that sends a "close" connection option＼
</p>
<ul>
	<li>
その後に，当の接続の~closure（下を見よ）を起動しなければナラナイ。
◎
MUST initiate closure of the connection (see below) after it sends the response containing the "close" connection option.＼
</li>
	<li>
当の接続から更なる要請を受信しても、
処理してはナラナイ。
◎
The server MUST NOT process any further requests received on that connection.
</li>
</ul>
</div>

<div class="p">
<p>
"`close$c" `接続~option$を伴う応答~messageを受信した`~client$は：
◎
A client that receives a "close" connection option＼
</p>
<ul>
	<li>
当の接続に対する要請の送信を止めた上で、
その応答を読取った後に，当の接続を~closeしなければナラナイ
◎
MUST cease sending requests on that connection and close the connection after reading the response message containing the "close" connection option;＼
</li>
	<li>
当の接続に対し，［
~pipeline化された追加的な要請
］を送信していた場合、［
それらが`~server$により処理される
］ものと見做すベキでない。
◎
if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.
</li>
</ul>
</div>

<p>
`~server$が，~TCP接続の~closeを即時に遂行した場合、［
`~client$が最後の~HTTP応答を読取れなくなる
］有意な~riskがある：
~server【側の~TCP~stack】が，［
全部的に~closeされた接続
］上で［
~clientから追加的な~data
］を受信した場合
— 例えば、
~clientが，~serverの応答を受信する前に送信した 別の要請など —
~serverの~TCP~stackは、
~clientへ向けて，~reset~packetを送信することになる。
が、
あいにく，~reset~packet【を受け取った~client側の~TCP~stack】は、
~clientの~HTTP構文解析器が［
~clientからは認知されてない入力~buffer
］を読取って解釈する前に，
~bufferを消去し得る。
◎
If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response. If the server receives additional data from the client on a fully closed connection, such as another request sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.
</p>

<div class="p">
<p>
~TCP~reset問題を避けるため、
`~server$は概して，次の段階を踏んで接続を~closeする：
◎
To avoid the TCP reset problem, servers typically close a connection in stages.＼
</p>
<ol>
	<li>
［
読取n, 書込n
］接続のうち，書込n側のみ~closeする。
◎
First, the server performs a half-close by closing only the write side of the read/write connection.＼
</li>
	<li>
<p>
次のいずれかの時点まで，接続からの読取りを継続する：
◎
The server then continues to read from the connection＼
</p>
		<ul>
			<li>
`~client$による，対応する~closeを受信したとき。
◎
until it receives a corresponding close by the client, or＼
</li>
			<li>
~serverが［
その自前の~TCP~stackが次について受信した
］ことを適度に確かめられたとき
⇒
`~client$は、
`~server$の最後の応答を包含している~packet（たち）を認知した
◎
until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response.＼
</li>
		</ul>
	</li>
	<li>
接続を全部的に~closeする。
◎
Finally, the server fully closes the connection.
</li>
</ol>
</div>

<p>
~reset問題が［
~TCPに固有なのか，他の~transport接続~protocolにも見出され得るのか
］は、
未知である。
◎
It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.
</p>

<p>
~clientから書込n側のみ~closeされた~TCP接続は、［
要請~messageを区切る
］ことも［
~clientは応答に関心を~~失ったことを含意する
］こともないことに注意。
一般に，際どい事例を通達する際には、
~transportによる通達には依拠し得ない
— ~HTTP11は、
~transportからは独立なので。
◎
Note that a TCP connection that is half-closed by the client does not delimit a request message, nor does it imply that the client is no longer interested in a response. In general, transport signals cannot be relied upon to signal edge cases, since HTTP/1.1 is independent of transport.
</p>

		</section>
		<section id="tls.connection.initiation">
<h3 title="TLS Connection Initiation">9.7. ~TLS接続の起動</h3>

<p>
概念的に，~TLS越しの~HTTPは、
単純に，~HTTP~messageを［
~TLS `TLS13$r を介して`~secure化$された接続
］越しに送信する。
◎
Conceptually, HTTP/TLS is simply sending HTTP messages over a connection secured via TLS [TLS13].
</p>

<p>
~HTTP~clientは、
~TLS~clientとしても動作する。
`~client$は、
適切な~port上で`~server$への接続を起動して，~TLS~handshakeを始めるために~TLS `ClientHello^i を送信する。
~TLS~handshakeが完遂したとき、
~clientは，最初の~HTTP要請を起動できる。
すべての~HTTP~dataは，~TLS “応用~data” として送信されなければナラナイが、
他の~~点では，~HTTP用の通常の接続の様に扱われる
（`持続的な接続$として再利用される場合も含めて）。
◎
The HTTP client also acts as the TLS client. It initiates a connection to the server on the appropriate port and sends the TLS ClientHello to begin the TLS handshake. When the TLS handshake has finished, the client may then initiate the first HTTP request. All HTTP data MUST be sent as TLS "application data" but is otherwise treated like a normal connection for HTTP (including potential reuse as a persistent connection).
</p>

		</section>
		<section id="tls.connection.closure">
<h3 title="TLS Connection Closure">9.8. ~TLS接続の~closure</h3>

<p>
~TLSは、［
（~errorでない）接続を~closeするに先立って，~closure~alertの交換-を利用する
］ことで，~secureな接続の~closureを供する
— `TLS13$r `6.1＠~RFCx/rfc8446.html#section-6.1§ を見よ。
妥当な~closure~alertを受信した実装は、
その接続~上では，それ以上~dataは受信されないことを確約できる。
◎
TLS uses an exchange of closure alerts prior to (non-error) connection closure to provide secure connection closure; see Section 6.1 of [TLS13]. When a valid closure alert is received, an implementation can be assured that no further data will be received on that connection.
</p>

<p>
実装は、
自身が~careする~message~dataすべてを［
送信した／受信した
］ものと
— 概して，~HTTP~message境界を検出することにより —
知れたとき、
~closure~alertを送信してから
— 相手の端点【！~peer】から~closure~alertが送信されてくるのを待機することなく —
接続を~closeすることにより，
“不完全な~close” を生成するかもしれない。
◎
When an implementation knows that it has sent or received all the message data that it cares about, typically by detecting HTTP message boundaries, it might generate an "incomplete close" by sending a closure alert and then closing the connection without waiting to receive the corresponding closure alert from its peer.
</p>

<p>
不完全な~closeは、
すでに受信した~dataの~securityについて疑いを示すものではないが，
後続な~dataは切落されたかもしれないことを指示することもある。
~TLSは，~HTTP~message~frame法を直に自覚しないので、
~HTTP~data自体を精査して，~messageは完全であるかどうか決定することが必要yである。
不完全な~messageの取扱いは、
`8§ にて定義される。
◎
An incomplete close does not call into question the security of the data already received, but it could indicate that subsequent data might have been truncated. As TLS is not directly aware of HTTP message framing, it is necessary to examine the HTTP data itself to determine whether messages are complete. Handling of incomplete messages is defined in Section 8.
</p>

<p>
不完全な~closeに遭遇した`~client$は、
次のいずれかに該当するときは，すべての要請は完了したものと扱うベキである：
◎
When encountering an incomplete close, a client SHOULD treat as completed all requests for which it has received either
</p>
<ul>
	<li>
`Content-Length$h ~headerに指定された分の~dataを受信した
◎
as much data as specified in the Content-Length header field or
</li>
	<li>
`~chunked転送~符号法$【！Transfer-Encoding of chunked】が利用されていて，それを終了させる長さ 0 の~chunkを受信した
◎
the terminal zero-length chunk (when Transfer-Encoding of chunked is used).
</li>
</ul>

<p>
`~chunked転送~符号法$も `Content-Length$h も伴わない応答が`完全$になるのは、
妥当な~closure~alertを受信した場合に限られる。
不完全な~messageを完全なものとして扱う実装は、攻撃に晒され得る。
◎
A response that has neither chunked transfer coding nor Content-Length is complete only if a valid closure alert has been received. Treating an incomplete message as complete could expose implementations to attack.
</p>

<p>
不完全な~closeを検出した`~client$は、
それを上品に回復するベキである。
◎
A client detecting an incomplete close SHOULD recover gracefully.
</p>

<p>
`~client$は、
接続を~closeする前に，~closure~alertを送信しなければナラナイ。
~clientは、
それ以上の~dataを受信するものと期待しないならば，［
`~server$の~closure~alertを待機することなく，単純に接続を~closeする
］ことを選んでもヨイ
— それは、
~server側にとって不完全な~closeを生成することになる。
◎
Clients MUST send a closure alert before closing the connection. Clients that do not expect to receive any more data MAY choose not to wait for the server's closure alert and simply close the connection, thus generating an incomplete close on the server side.
</p>

<p>
`~server$は、
`~client$から不完全な~closeを受信することに備えておくベキである
— ~clientは、
~serverからの~dataが どこで終端するか突き止めれることが多いので。
◎
Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.
</p>

<p>
`~server$は、
接続を~closeする前に，
`~client$との~closure~alertの交換を起動しようと試みなければナラナイ。
~closure~alertを送信した~serverは、
接続を~closeしてもヨイ
— それは、
~client側にとって不完全な~closeを生成することになる。
◎
Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.
</p>

		</section>
	</section>
	<section id="enclosing.messages">
<h2 title="Enclosing Messages as Data">10. ~messageを~dataとして同封するとき</h2>

		<section id="media.type.message.http">
<h3 title="Media Type message/http">10.1. ~MIME型 `message/http^c</h3>

<p>
`~MIME型$ "`message/http^c" は、
単独の~HTTP［
要請／応答
］~messageを同封するために利用できる
— それが、
すべての "message" 型に対し，~MIMEによる［
行lの長さと符号化法に関する制約
］を順守する限りにおいて。
"`message/http^c" の中の`~field値$には行lの長さに制限があるので、
`~field値$を複数~行lに連ねて伝達するためとして
— `5.2§ にて述べたとおり —
行l折返し（ `obs-fold$p ）の利用も許容される。
"`message/http^c" ~dataの`受信者$は、
当の~messageを消費するときには，［
そのような廃用にされた各 行l折返し
］を 1 個以上の `SP$P で置換しなければナラナイ。
◎
The "message/http" media type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all "message" types regarding line length and encodings. Because of the line length limitations, field values within "message/http" are allowed to use line folding (obs-fold), as described in Section 5.2, to convey the field value over multiple lines. A recipient of "message/http" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.
</p>

<div>
<dl>
<dt>型~名
<dd>`message^c

<dt>下位型~名
<dd>`http^c

<dt>要求される~parameter
<dd>N/A

<dt>省略可能な~parameter
<dd>%version, %msgtype
	<dl>
	<dt>%version
	<dd>
同封された~messageの `HTTP-version$p 番号（例： "`1.1^c" ）。
無い場合の`~version$は、
本体の最初の行lから決定し得る。
	<dt>%msgtype
	<dd>
~message型
— "`request^c" または "`response^c" 。
無い場合の型は、
本体の最初の行lから決定し得る。
	</dl></dd>

<dt>符号化法の考慮点
<dd>"`7bit^c", "`8bit^c", "`binary^c" のみ許可される

<dt>~securityの考慮点
<dd>`11§ を見よ

<dt>相互運用能の考慮点
<dd>N/A

<dt>公表した仕様
<dd>~RFC 9112 （ `10.1§ を見よ）

<dt>この`~MIME型$を利用する応用
<dd>N/A

<dt>素片~識別子（ `fragment$p ）に対する考慮点
<dd>N/A

<dt>追加的な情報
<dd><dl>
	<dt>Magic number(s):
	<dt>Deprecated alias names for this type:
	<dt>File extension(s):
	<dt>Macintosh file type code(s):
	<dd>N/A
	</dl></dd>

<dt>Person and email address to contact for further information:
<dd>`著作者の~address§に。

<dt>意図される用法
<dd>COMMON

<dt>用法~上の制約
<dd>N/A

<dt>著作者
<dd>`著作者の~address§に。

<dt>変更~制御者
<dd>IESG
</dl>

◎
Type name:
• message
Subtype name:
• http
Required parameters:
• N/A
Optional parameters:
• version, msgtype
•• version:
••• The HTTP-version number of the enclosed message (e.g., "1.1"). If not present, the version can be determined from the first line of the body. 
•• msgtype:
••• The message type -- "request" or "response". If not present, the type can be determined from the first line of the body. 

Encoding considerations:
• only "7bit", "8bit", or "binary" are permitted
Security considerations:
• see Section 11 
Interoperability considerations:
• N/A
Published specification:
• RFC 9112 (see Section 10.1).
Applications that use this media type:
• N/A
Fragment identifier considerations:
• N/A
Additional information:
•• Magic number(s):
•••  N/A
•• Deprecated alias names for this type:
•••  N/A
•• File extension(s):
•••  N/A
•• Macintosh file type code(s):
•••  N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

		</section>
		<section id="media.type.application.http">
<h3 title="Media Type application/http">10.2. ~MIME型 `application/http^c</h3>

<p>
`~MIME型$ "`application/http^c" は、
~pipeline化された 1 個~以上の~HTTP［
要請~messageのみ／応答~messageのみ
］を同封するときに利用できる。
◎
The "application/http" media type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).
</p>

<div>

<p>
次に挙げる各項以外は、
"`message/http^c" と同じ：
</p>

<dl>
<dt>型~名
<dd>`application^c
<dt>符号化法の考慮点
<dd>
この型により同封された［
一連の~HTTP~message
］は、
"`binary^c" 形式になる
— ~emailを介して伝送されるときは、
適切な `Content-Transfer-Encoding$h の利用が要求される。
<dt>公表した仕様
<dd>~RFC 9112 （ `10.2§ を見よ）
</dl>

◎
Type name:
• application
Subtype name:
• http
Required parameters:
• N/A
Optional parameters:
• version, msgtype
•• version:
••• The HTTP-version number of the enclosed messages (e.g., "1.1"). If not present, the version can be determined from the first line of the body. 
•• msgtype:
••• The message type -- "request" or "response". If not present, the type can be determined from the first line of the body. 

Encoding considerations:
• HTTP messages enclosed by this type are in "binary" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email.
Security considerations:
• see Section 11 
Interoperability considerations:
• N/A
Published specification:
• RFC 9112 (see Section 10.2).
Applications that use this media type:
• N/A
Fragment identifier considerations:
• N/A
Additional information:
•• Deprecated alias names for this type:
••• N/A
•• Magic number(s):
••• N/A
•• File extension(s):
••• N/A
•• Macintosh file type code(s):
••• N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

		</section>
	</section>
	<section id="security.considerations">
<h2 title="Security Considerations">11. ~securityの考慮点</h2>

<p>
この節は、［
開発者, 情報~provider, 利用者
］に，~HTTP~messageの［
構文／構文解析
］に関連な，既知な~securityの考慮点について伝えることが意味される。
~HTTPの［
意味論／`内容$／~route法
］についての，~securityの考慮点は、
`HTTP$r にて取組まれる。
◎
This section is meant to inform developers, information providers, and users about known security considerations relevant to HTTP message syntax and parsing. Security considerations about HTTP semantics, content, and routing are addressed in [HTTP].
</p>

		<section id="response.splitting">
<h3 title="Response Splitting">11.1. 応答~分割</h3>

<p>
`応答~分割^dfn
（ `response splitting^en ）
（いわゆる `CRLF$P 注入）は、
~Web利用eに対する様々な攻撃にて共通的に利用される技法であり，［
~HTTP~message~frame法の，行lに基づく資質
］と［
`持続的な接続$における，要請から応答への順序~付けられた結付け
］を悪用する
`Klein$r
。
この技法は，特に、
要請が`共用~cache$を通して渡されるとき，被害を大きくし得る。
◎
Response splitting (a.k.a. CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]. This technique can be particularly damaging when the requests pass through a shared cache.
</p>

<p>
応答~分割は、［
要請の何らかの~parameter
— 後に，復号され, 応答の何らかの~headerの中に 復唱されるような~parameter —
の中に，攻撃者が符号化-済み~dataを送信できる
］ような，`~server$における脆弱性（通例的に応用~serverの中）を悪用する。
~dataが，［
それを復号した結果が，応答が終端され, 後続な応答が始まる
］ように見せかけて細工されていた場合、
応答は分割され，［
2 番目であるように見せかけた応答
］の内容が攻撃者により制御される。
しかる後，攻撃者は、［
同じ`持続的な接続$ 上に，他の何らかの要請を為して
］，`受信者$（`媒介者$も含む）に［
分割-の~~後半部分が， 2 番目の要請に対する`権限的$な回答である
］と信じ込ませることも可能になる。
◎
Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response. If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split, and the content within the apparent second response is controlled by the attacker. The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.
</p>

<p>
例えば，
`request-target$p の中の~parameterは、［
応用~serverにより読取られ, ~redirectの中で再利用される
］結果，応答の `Location$h ~header内に同じ~parameterが復唱され得る。
応用により復号された~parameterが［
応答~header内に置かれるとき，適正に符号化されない
］場合、
攻撃者は，［
符号化-済みな `CRLF$P ~octetその他の内容
］を送信して，応用による 1 個の応答を 2 個~以上の応答に見せかけられるようになる。
◎
For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response. If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses.
</p>

<p>
応答~分割に抗する共通的な防御策は、
要請の中の［
符号化-済みな `CR$P `LF$P 並びに見せかけた~data
］を~filterするものであるが、
それは［
応用~serverが~URIの復号しか遂行していない
］ことを前提にしており，より見え難い~data形式変換
— ~charset符号変換, ~XML実体~翻訳, base64 復号, sprintf 再整形, 等々 —
は~~考慮されていない。
それより，［
~serverの中核~protocol~library
］以外のどこであれ［
`~header節$の中に `CR$P や `LF$P を送信する
］のを防止する方が、
効果的な軽減策になる
— それは、
~headerの出力を［
不良~octetを~filterする~API
］に制約して，［
応用~serverが~protocol~streamへ直に書込む
］ことを許容しないことを意味する。
◎
A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., "%0D" and "%0A"). However, that assumes the application server is only performing URI decoding rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc. A more effective mitigation is to prevent anything other than the server's core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream.
</p>

		</section>
		<section id="request.smuggling">
<h3 title="Request Smuggling">11.2. 要請~密入</h3>

<p>
`要請~密入^dfn
（ `request smuggling^en ） `Linhart$r は、［
様々な受信者~間での，~protocol構文解析-法における相違点
］を悪用して，［
無害に見せかけた要請
］の中に［
（さもなければ施策により阻止されるか不能化されるような）追加的な要請
］を隠す技法である。
`応答~分割$と同様に、
要請~密入は，~HTTP利用eにおいて種々の攻撃を導き得る。
◎
Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request. Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.
</p>

<p>
この仕様は、
要請~密入の実効性を抑制するため，
`~message本体の長さ§にて
— 特に，~message~frame法に関して —
要請の構文解析に課される新たな要件を導入した。
◎
This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 6.3, to reduce the effectiveness of request smuggling.
</p>

		</section>
		<section id="message.integrity">
<h3 title="Message Integrity">11.3. ~messageの完全性</h3>

<p>
~HTTPは、［
~messageの完全性を確保するための，特定の仕組み
］は定義しない。
代わりに，［
下層~transport~protocolの~error検出~能
］および［
完全かどうかを検出するための［
長さ／~chunkで区切られる~frame法
］の利用
］に依拠する。
歴史的に、［
単一な，完全性の仕組み
］の欠如は，［
ほとんどの~HTTP通信が正式でない性向にあること
］を根拠に正当化されていた。
しかしながら、［
情報~accessの仕組みとしての~HTTP
］が普及した結果，［
~message完全性の検証yが不可欠な環境
］下での利用は増えている。
◎
HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness. Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication. However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial.
</p>

<p>
"`https$c" ~schemeで供される仕組みは、
認証された暗号化など，~messageの改変に抗する保護を供する。
しかしながら，［
接続の~closureが利用されても，~messageは切落され得ない
］ことを確保するよう~careする必要がある（ `9.8§ を見よ）。
`~UA$は、
不完全な~messageに対し，［
受容するのを拒否する／特別に扱う
］かもしれない。
例えば，［
医療~履歴や薬剤相互作用についての情報
］を視るために利用されている~browserは、［
そのような情報が転送の間に［
不完全である／失効した／破損した
］ことが~protocolにより検出された
］ことを，利用者に指示できることが必要yである。
そのような仕組みは、［
~UA拡張や, 応答~内に~message完全性~metadataが在ること
］を介して，選択的に可能化できるであろう。
◎
The mechanisms provided with the "https" scheme, such as authenticated encryption, provide protection against modification of messages. Care is needed, however, to ensure that connection closure cannot be used to truncate messages (see Section 9.8). User agents might refuse to accept incomplete messages or treat them specially. For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer. Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response.
</p>

<p>
"`http$c" ~schemeは、
~messageに対する［
偶発的／悪意的
］な改変に抗する保護は，供さない。
◎
The "http" scheme provides no protection against accidental or malicious modification of messages.
</p>

<p>
"`https$c" ~schemeが利用されているときでも、［
`媒介者$による，~messageに対する求まれない改変
］の~riskを軽減するために，~protocolに対する拡張が利用されるかもしれない。
完全性は、
拡張-可能な~metadata~fieldを介して~messageに選択的に追加された［
~message認証~code／~digital署名
］を利用して確約されることもあろう。
◎
Extensions to the protocol might be used to mitigate the risk of unwanted modification of messages by intermediaries, even when the "https" scheme is used. Integrity might be assured by using message authentication codes or digital signatures that are selectively added to messages via extensible metadata fields.
</p>

		</section>
		<section id="message.confidentiality">
<h3 title="Message Confidentiality">11.4. ~messageの機密性</h3>

<p>
~HTTPは、［
~messageの機密性が欲されるときに，それを供する
］にあたり，下層の~transport~protocolに依拠する。
~HTTPは、［
多くの形をとる，暗号化された接続
］にも利用し得るように，［
~transport~protocolに依存しない
］ように特定的に設計されてきた。
そのような~transportの選定は、［
選ばれた~URI~schemeや, ~UA環境設定
］により識別されている。
◎
HTTP relies on underlying transport protocols to provide message confidentiality when that is desired. HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.
</p>

<p>
機密的~接続を要求する`資源$を識別するためには、
"`https$c" ~schemeを利用できる。
◎
The "https" scheme can be used to identify resources that require a confidential connection, as described in Section 4.2.2 of [HTTP].
</p>

		</section>
	</section>
	<section id="IANA.considerations">
<h2 title="IANA Considerations">12. ~IANA考慮点</h2>

<p>
以下に挙げる登録の変更~制御者は、
“~IETF（ iesg@ietf.org, `Internet Engineering Task Force^en ）”
である。
◎
The change controller for the following registrations is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</p>

		<section id="field.name.registration">
<h3 title="Field Name Registration">12.1. ~field名の登録</h3>

<p>
~IANAは、
次の表tに挙げる~field名を
— `HTTP$r `18.4＠~HTTPinfra#field.name.registration§に従って —
`~HTTP~field名~registry＠~IANA-a/http-fields$cite
（ `Hypertext Transfer Protocol (HTTP) Field Name Registry^en ）
に追加した：
◎
IANA has added the following field names to the "Hypertext Transfer Protocol (HTTP) Field Name Registry" at &lt;https://www.iana.org/assignments/http-fields&gt;, as described in Section 18.4 of [HTTP].
</p>

<div>
<table id="iana.header.registration.table"><thead>
<tr><th>~field名
<th>位置付け
<th>§
<th>~comment
<tbody>

<tr><td>`Close^h
<td>`恒久的^i
<td>`9.6§
<td>（予約-済み）

<tr><td>`MIME-Version^h
<td>`恒久的^i
<td>`B.1§
<td>

<tr><td>`Transfer-Encoding^h
<td>`恒久的^i
<td>`6.1§
<td>
</table>
◎
Table 1
Field Name｜Status｜Section｜Comments
Close｜permanent｜9.6 ｜(reserved)
MIME-Version｜permanent｜B.1 ｜
Transfer-Encoding｜permanent｜6.1 ｜
</div>

		</section>
		<section id="media.type.http">
<h3 title="Media Type Registration">12.2. ~MIME型の登録</h3>

<p>
~IANAは、
`~MIME型~registry＠~IANA-a/media-types$cite
（ `Media Types registry^en ）
を［
`~MIME型$［
`message/http$c, `message/http$c
］用の登録~情報
］を伴うよう更新した。
◎
IANA has updated the "Media Types" registry at &lt;https://www.iana.org/assignments/media-types&gt; with the registration information in Sections 10.1 and 10.2 for the media types "message/http" and "application/http", respectively.
</p>

		</section>
		<section id="transfer.coding.registration">
<h3 title="Transfer Coding Registration">12.3. 転送~符号法の登録</h3>

<p>
~IANAは、
`~HTTP転送~符号法~registry$cite
（ `HTTP Transfer Coding Registry^en ）
を更新した
— `7.3§ の登録~手続-に従って，
次の表tに要約される【！内容~符号法】`転送~符号法の名前$を伴うよう：
◎
IANA has updated the "HTTP Transfer Coding Registry" at &lt;https://www.iana.org/assignments/http-parameters/&gt; with the registration procedure of Section 7.3 and the content coding names summarized in the table below.
</p>

<div>
<table id="iana.transfer.coding.registration.table"><thead>
<tr><th>名前
<th>記述
<th style="min-width:7em;">§
<tbody>

<tr><td>`chunked$c
<td>一連の~chunk内に転送する
<td>`7.1§

<tr><td>`compress$c
<td>~UNIX "compress" ~data形式 `Welch$r
<td>`7.2§

<tr><td>`deflate$c
<td>"zlib" ~data形式 `RFC1950$r の内側にある，
"deflate" で圧縮された~data `RFC1951$r
<td>`7.2§

<tr><td>`gzip$c
<td>GZIP ~file形式 `RFC1952$r
<td>`7.3§

<tr><td>`trailers^c
<td>(予約-済み)
<td>`12.3§

<tr><td>`x-compress^c
<td>非推奨d（ `compress$c 用の別名）
<td>`7.2§

<tr><td>`x-gzip^c
<td>非推奨d（ `gzip$c 用の別名）
<td>`7.2§
</table>
◎
Table 2
Name｜Description｜Section
chunked｜Transfer in a series of chunks｜7.1
compress｜UNIX "compress" data format [Welch] ｜7.2
deflate｜"deflate" compressed data ([RFC1951]) inside the "zlib" data format ([RFC1950])｜7.2
gzip｜GZIP file format [RFC1952] ｜7.2
trailers｜(reserved)｜12.3
x-compress｜Deprecated (alias for compress)｜7.2
x-gzip｜Deprecated (alias for gzip)｜7.2
</div>

<p class="note">注記：
符号法の名前 "`trailers^c" は、
予約される
— その利用は、
`TE$h ~headerにおける ~keyword "`trailers$c" と競合することになるので。
◎
Note: the coding name "trailers" is reserved because its use would conflict with the keyword "trailers" in the TE header field (Section 10.1.4 of [HTTP]).
</p>

		</section>
		<section id="alpn.registration">
<h3 title="ALPN Protocol ID Registration">12.4. ~ALPN~protocol~IDの登録</h3>

<p>
~IANAは、
`~ALPN~protocol~ID~registry＠~IANA-a/tls-extensiontype-values/$cite
（ `TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs^en ）
を更新した
— 次の登録を伴うよう：
◎
IANA has updated the "TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs" registry at &lt;https://www.iana.org/assignments/tls-extensiontype-values/&gt; with the registration below:
</p>

<div>
<table><thead>
<tr><th>~protocol
<th>識別~連列
<th>参照
<tbody>

<tr><td>HTTP/1.1
<td>0x68 0x74 0x74 0x70 0x2f 0x31 0x2e 0x31 （ "`http/1.1^c" ）
<td>~RFC 9112
</table>
◎
Table 3
Protocol｜Identification Sequence｜Reference
HTTP/1.1｜0x68 0x74 0x74 0x70 0x2f 0x31 0x2e 0x31 ("http/1.1")｜RFC 9112
</div>

		</section>
	</section>
	<section id="collected.abnf">
<h2 title="Collected ABNF">付録 A. 総集的~ABNF</h2>

【この節は未訳。】

	</section>
	<section id="differences.between.http.and.mime">
<h2 title="Differences between HTTP and MIME">付録 B. ~HTTPと~MIMEの相違点</h2>

<div class="p">
<p>
`~HTTP11$は、［
`Internet Message Format^cite `RFC5322$r,
~MIME（ `Multipurpose Internet Mail Extensions^cite ） `RFC2045$r
］用に定義された構成子の多くを利用して，
`~message本体$を［
拡張-可能な`~field$と伴に，~openかつ多種多様な`表現$により伝送する
］ことを許容する。
しかしながら，これらの構成子のうち一部は、［
ヤリトリありな通信の必要性に より良く収まる
］よう解釈し直され，［
~MIME構成子が~HTTPの中で どう利用されるか
］における相違点へ導く。
これらの相違点は、
次のために注意深く選ばれている：
◎
HTTP/1.1 uses many of the constructs defined for the Internet Message Format [RFC5322] and Multipurpose Internet Mail Extensions (MIME) [RFC2045] to allow a message body to be transmitted in an open variety of representations and with extensible fields. However, some of these constructs have been reinterpreted to better fit the needs of interactive communication, leading to some differences in how MIME constructs are used within HTTP. These differences were carefully chosen to＼
</p>
<ul>
	<li>
~binary接続の処理能を最適化する
◎
optimize performance over binary connections,＼
</li>
	<li>
新たな`~MIME型$の利用における自由度を高める
◎
allow greater freedom in the use of new media types,＼
</li>
	<li>
日時の比較を容易にする
◎
ease date comparisons, and＼
</li>
	<li>
共通的な実装を収容する
◎
accommodate common implementations.
</li>
</ul>
</div>

<p>
この付録は、［
~HTTPが~MIMEから相違する，特定の分野
］について述べる。
厳密な~MIME環境 への／からの `~gateway$や`~proxy$は、
これらの相違点を自覚した上で，必要yな所では 適切な変換を供する必要がある。
◎
This appendix describes specific areas where HTTP differs from MIME. Proxies and gateways to and from strict MIME environments need to be aware of these differences and provide the appropriate conversions where necessary.
</p>

		<section id="mime-version">
<h3 title="MIME-Version">B.1. `MIME-Version^h</h3>

<p>
~HTTPは、
~MIME準拠な~protocolではない。
しかしながら，~messageを構築するときに［
単独の `MIME-Version^h ~header
］を内包することで、［
~MIME~protocolの どの~versionが利用されたか
］を指示できる。
`MIME-Version^h ~headerの利用は、［
~messageが（ `RFC2045$r にて定義されるとおり）~MIME~protocolに全部的に適合している
］ことを指示する。
`送信者$は、［
~HTTP~messageを厳密な~MIME環境に~exportする
］ときには（アリな所では）全部的な適合性を確保する責を負う。
◎
HTTP is not a MIME-compliant protocol. However, messages can include a single MIME-Version header field to indicate what version of the MIME protocol was used to construct the message. Use of the MIME-Version header field indicates that the message is in full conformance with the MIME protocol (as defined in [RFC2045]). Senders are responsible for ensuring full conformance (where possible) when exporting HTTP messages to strict MIME environments.
</p>

		</section>
		<section id="conversion.to.canonical.form">
<h3 title="Conversion to Canonical Form">B.2. 正準-形への変換</h3>

<p>
~MIMEは、
`2049/4$rfc にて述べられるとおり，転送に先立って，［
~Internet~mail本体 部分
］を正準-形に変換するよう要求する。
`RFC2046$r は，
"`text^c" 型の内容においては、
改行を `CRLF$P として表現することも要求し，他所における［
`CR$P ／ `LF$P
］の利用を禁止する。
対照的に，~HTTPは、
`内容$の中の改行が［
`CRLF$P, `CR$P, `LF$P
］のどれを利用して指示されようが，~careしない。
◎
MIME requires that an Internet mail body part be converted to canonical form prior to being transferred, as described in Section 4 of [RFC2049], and that content with a type of "text" represents line breaks as CRLF, forbidding the use of CR or LF outside of line break sequences [RFC2046]. In contrast, HTTP does not care whether CRLF, bare CR, or bare LF are used to indicate a line break within content.
</p>

<p>
~HTTPから厳密な~MIME環境への［
`~proxy$／`~gateway$
］は、［
~text`~MIME型$の中のすべての改行
］を［
`RFC2049$r による正準-形 `CRLF$P
］に転化する~OUGHT。
しかしながら，これは、［
`Content-Encoding$h が在ること
］, および［
~HTTPが［［
`CR$P ／ `LF$P
］を表現する~octet［
13 ／ 10
］を利用しない，一部の`~charset$
］の利用を許容する事実
］により，複雑化することもあることに注意。
◎
A proxy or gateway from HTTP to a strict MIME environment ought to translate all line breaks within text media types to the RFC 2049 canonical form of CRLF. Note, however, this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some charsets that do not use octets 13 and 10 to represent CR and LF, respectively.
</p>

<p>
変換は、［
内容が~~元々正準-形である場合
］を除き，［
元の内容に適用された暗号用の~checksum
］を［
それが何であれ非互換化する
］ことになる。
したがって、［
~HTTPにおいて，そのような~checksumを利用する内容
］には，正準-形が推奨される。
◎
Conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such checksums in HTTP.
</p>

		</section>
		<section id="conversion.of.date.formats">
<h3 title="Conversion of Date Formats">B.3. 日時~形式の変換</h3>

<p>
`~HTTP11$は、
日時の比較~処理nを単純~化するために，
制約された日時~形式たちが成す集合（ `HTTP$r `日付時刻の形式＠~HTTPinfra#http.date§）を利用する。
他の~protocolからの［
`~proxy$／`~gateway$
］は、［
~message内に在るどの `Date$h ~headerも，いずれかの~HTTP11形式に適合する
］ことを
— 必要yなら，日時を書換えて —
確保する~OUGHT。
◎
HTTP/1.1 uses a restricted set of date formats (Section 5.6.7 of [HTTP]) to simplify the process of date comparison. Proxies and gateways from other protocols ought to ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.
</p>

		</section>
		<section id="conversion.of.content-encoding">
<h3 title="Conversion of Content-Encoding">B.4. `Content-Encoding^h の変換</h3>

<p>
~MIMEは、
~HTTPの `Content-Encoding$h ~headerに等価な概念を含まない。
これは，`~MIME型$の改変子として動作するので、
~HTTPから~MIME準拠な~protocolへの［
`~proxy$／`~gateway$
］は，~messageを回送する前に［
`Content-Type$h ~headerの値を変更する
］か［
`表現$を復号する
］~OUGHT。
（~Internet~mail用の `Content-Type$h の試験的な応用には、
`Content-Encoding$h と等価な機能を遂行するために，
`media-type$p ~parameterに
"`;conversions=&lt;content-coding&gt;^c"
を利用しているものもある。
しかしながら，この~parameterは、
~MIME標準の一部ではない）。
◎
MIME does not include any concept equivalent to HTTP's Content-Encoding header field. Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols ought to either change the value of the Content-Type header field or decode the representation before forwarding the message. (Some experimental applications of Content-Type for Internet mail have used a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform a function equivalent to Content-Encoding. However, this parameter is not part of the MIME standards.)
</p>

		</section>
		<section id="conversion.of.content-transfer-encoding">
<h3 title="Conversion of Content-Transfer-Encoding">B.5. `Content-Transfer-Encoding^h の変換</h3>

<p>
~HTTPは、［
~MIMEの `Content-Transfer-Encoding$h ~field
］を利用しない。
~MIME準拠な~protocolから~HTTPへの［
`~proxy$／`~gateway$
］は、
応答~messageを~HTTP~clientへ送達するに先立って，
すべての `Content-Transfer-Encoding^h を除去する必要がある。
◎
HTTP does not use the Content-Transfer-Encoding field of MIME. Proxies and gateways from MIME-compliant protocols to HTTP need to remove any Content-Transfer-Encoding prior to delivering the response message to an HTTP client.
</p>

<p>
~HTTPから~MIME準拠な~protocolへの［
`~proxy$／`~gateway$
］は、
~messageが［
当の~protocol上で安全に~transportされる，正しい［
形式, 符号化法
］である
］ことを確保する責を負う
— ここでの “安全な~transport” は、
利用される~protocolによる制限により定義される。
そのような［
~proxy／~gateway
］は、
当の~dataを［
形式変換して，適切な `Content-Transfer-Encoding$h で~labelする
］~OUGHT
— そうすることで［
行先~protocol越しの~transportが安全になる見込み
］が改善される場合には。
◎
Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where "safe transport" is defined by the limitations of the protocol being used. Such a proxy or gateway ought to transform and label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.
</p>

		</section>
		<section id="mhtml.line.length">
<h3 title="MHTML and Line Length Limitations">B.6. ~MHTMLと行l長さ制限</h3>

<p>
~MHTML `RFC2557$r 実装と~codeを共有する~HTTP実装は、
~MIMEにおける行l長さ制限を自覚しておく必要がある。
この制限は~HTTPには無いので、
~HTTPは長い行lを折返さない。
［
~HTTPにより~transportされている~MHTML~message
］は、
行lの［
長さ制限, 折返し, 正準-化, 等々
］を含め，~MHTMLのすべての規約に従う
— ~HTTPは、
`~message本体$を改変を伴わずに転送し，
"`multipart/byteranges$c" 型は別として，そこに包含され得るどの［
内容／~MIME~header行l
］も解釈しないので。
◎
HTTP implementations that share code with MHTML [RFC2557] implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transfers message-bodies without modification and, aside from the "multipart/byteranges" type (Section 14.6 of [HTTP]), does not interpret the content or any MIME header lines that might be contained therein.
</p>

		</section>
	</section>
	<section id="changes">
<h2 title="Changes from Previous RFCs">付録 C. 以前の~RFCからの変更点</h2>

		<section id="changes.from.0.9">
<h3 title="Changes from HTTP/0.9">C.1. ~HTTP09からの変更点</h3>

<p>
~HTTP09は，要請~内の~headerを~supportしなかったので、［
名前に基づく仮想~host（ `Host$h ~headerの検分による`資源$の選定）
］を~supportするための仕組みも無かった。
［
名前に基づく仮想~host
］を実装する どの`~server$も，~HTTP09の~supportを不能化する~OUGHT。
事実，~HTTP09として出現するほとんどの要請は、
`request-target$p を適正に符号化できない~clientにより，
不良に構築された HTTP/1.x 要請である。
◎
Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field). Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.
</p>

		</section>
		<section id="changes.from.1.0">
<h3 title="Changes from HTTP/1.0">C.2. ~HTTP10からの変更点</h3>

			<section id="changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses">
<h4 title="Multihomed Web Servers">C.2.1. ~multihomed~web~server</h4>

<div class="p">
<p>
次に挙げる要件は、
~HTTP11により定義された中でも最も重要な変更点である：
</p>
<ul>
	<li>
［
`~client$, `~server$
］は、
`Host$h ~headerを~supportすることに加え，
~HTTP11要請に それが欠落なときは~errorを報告する。
</li>
	<li>
絶対~URI（ `absolute-form$p ）を受容する。
</li>
</ul>
◎
The requirements that clients and servers support the Host header field (Section 7.2 of [HTTP]), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 3.2) are among the most important changes defined by HTTP/1.1.
</div>

<p>
旧い~HTTP10~clientは、［
~IP~addressと~serverとの関係性が一対一である
］ものと見做していた
— ［
要請に意図された~server
］を判別するために確立された仕組みは、
要請が~directする~IP~addressの他に無かった。
`Host$h ~headerは、
~HTTP11の開発~中に導入され，ほとんどの~HTTP10~browserに すぐに実装されたが、
完全な採用を確保するため，すべての~HTTP11要請に 追加的な要件が設置された。
これが書かれた時点では、
~HTTPに基づく~serviceは，
ほとんどが `Host$h ~headerに依存して要請を~targetしている。
◎
Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no established mechanism for distinguishing the intended server of a request other than the IP address to which that request was directed. The Host header field was introduced during the development of HTTP/1.1 and, though it was quickly implemented by most HTTP/1.0 browsers, additional requirements were placed on all HTTP/1.1 requests in order to ensure complete adoption. At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests.
</p>

			</section>
			<section id="compatibility.with.http.1.0.persistent.connections">
<h4 title="Keep-Alive Connections">C.2.2. `Keep-Alive^h 接続</h4>

<p>
~HTTP10における各~接続は、
要請に先立って`~client$により確立され，
`~server$により応答が送信された後に~closeされていた。
しかしながら，一部の実装は、
`持続的な接続$の［
`2068/19.7.1$rfc による，明示的に折衝される~version（ `Keep-Alive^h ）
］を実装している。
◎
In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. However, some implementations implement the explicitly negotiated ("Keep-Alive") version of persistent connections described in Section 19.7.1 of [RFC2068].
</p>

<p>
一部の［
`~client$／`~server$
］は、［
これらの以前の~approachが，`持続的な接続$と互換になる
］ことを望むかもしれない
— それらに対し、［
"`Connection: keep-alive^c" 要請~headerにより，明示的に折衝する
］ことにより。
しかしながら，~HTTP10`持続的な接続$の試験的な実装には、
~~欠陥があるものもある
— 例えば，~HTTP10~proxy~serverが `Connection$h を解さない場合、
その~headerを`内方$にある次の~serverへ誤って回送することになる結果，
接続を~hungさせることになろう。
◎
Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a "Connection: keep-alive" request header field. However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.
</p>

<p>
解決策の一つとして、［
特定的に~proxyを~targetにする， `Proxy-Connection^h ~header
］の導入も試みられた。
実施においては、
これも~~機能しなかった。
何故なら、
~proxyは複数~層にて配備されていることが多いため，
上に論じたのと同じ問題を持ち込むので。
◎
One attempted solution was the introduction of a Proxy-Connection header field, targeted specifically at proxies. In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above.
</p>

<p>
そのため、
`~client$には，［
どの要請にも `Proxy-Connection^h ~headerは送信しない
］ことが奨励される。
◎
As a result, clients are encouraged not to send the Proxy-Connection header field in any requests.
</p>

<p>
`~client$には、［
要請における
"<code>`Connection$p: keep-alive</code>"
の利用について，注意深く考慮する
］ことも奨励される
— それは，~HTTP10~serverとの`持続的な接続$を可能化できるが、
それを利用する~clientは， “~hung” した要請について接続を監視する必要がある
（そのような~hungは、［
~clientが~headerの送信を停止する~OUGHT
］ことを指示する）
— したがって，~proxyを利用している~clientは、
この仕組みを まったく利用しない~OUGHT。
◎
Clients are also encouraged to consider the use of "Connection: keep-alive" in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for "hung" requests (which indicate that the client ought to stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.
</p>

			</section>
			<section id="introduction.of.transfer-encoding">
<h4 title="Introduction of Transfer-Encoding">C.2.3. `Transfer-Encoding^h の導入</h4>

<p>
~HTTP11は、
`転送~符号法$用に `Transfer-Encoding$h ~headerを導入する。
それは、［
~MIME準拠な~protocol越しに~HTTP~messageを回送する
］に先立って，復号される必要がある。
◎
HTTP/1.1 introduces the Transfer-Encoding header field (Section 6.1). Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.
</p>

			</section>
		</section>
		<section id="changes.from.rfc.7230">
<h3 title="Changes from RFC 7230">C.3. RFC 7230 からの変更点</h3>

<p>
~HTTPの［
設計~目標／
歴史／
~architecture／
適合性~判定基準／
~protocol~version法／
~URI／
~message~route法／
`~field値$
］を導入している ほとんどの節は、
`HTTP$r に移動された。
この文書は、
~HTTP11に特有な［
~message法の構文, 接続~管理
］用の要件に抑制された。
◎
Most of the sections introducing HTTP's design goals, history, architecture, conformance criteria, protocol versioning, URIs, message routing, and header fields have been moved to [HTTP]. This document has been reduced to just the messaging syntax and connection management requirements specific to HTTP/1.1.
</p>

<p>
`内容$の外側における［
`CRLF$P の一部を成さない `CR$P
］を禁制した。
（`~messageの構文解析-法§）
◎
Bare CRs have been prohibited outside of content. (Section 2.2)
</p>

<p>
`authority-form$p の~ABNF定義を［
~URIを成す より一般的な（ `port$p を省略可能な） `authority$p 成分
］から［
`CONNECT$m により要求される，より特定な `host:port^c 形式
］に変更した。
（ `3.2.3§ ）
◎
The ABNF definition of authority-form has changed from the more general authority component of a URI (in which port is optional) to the specific host:port format that is required by CONNECT. (Section 3.2.3)
</p>

<p>
多義的な~message~frame法を処理するときは、［
`応答~分割$／`要請~密入$
］攻撃を避けることを`受信者$に要求した。
（ `Transfer-Encoding§h ）
◎
Recipients are required to avoid smuggling/splitting attacks when processing an ambiguous message framing. (Section 6.1)
</p>

<p>
`~chunk拡張$用の~ABNFにおいて、［
"`;^c" ／ "`=^c"
］の前後における（不良）`空白$を導入し直した。
その空白は `RFC7230$r において除去されたが、
その変更は既存の実装を非互換化することが見出されたので。
（`~chunk拡張§）
◎
In the ABNF for chunked extensions, (bad) whitespace around ";" and "=" has been reintroduced. Whitespace was removed in [RFC7230], but that change was found to break existing implementations. (Section 7.1.1)
</p>

<p>
`~trailer$の意味論は、
今や，`~chunked転送~符号法$に特有なそれを超越する。
~chunked用の復号~algo（ `7.1.3§ ）は、
`~trailer$を`~header節$とは別々に［
格納する／回送する
］ことを奨励するため，更新された
— `~trailer$を`~header節$の中へ併合するのが許容されるのは、［
対応する~header定義において，併合する方法が定義されていて, そうすることが許可されている
］ことを受信者が知っている場合に限られ、
他の場合は併合することなく破棄するように。
`trailer part^en は、
今や `trailer section^en（ `~trailer節$ ）と呼ばれる
— より `header section^en（ `~header節$ ）と一貫するよう, かつ `body part^en とは別個になるよう。
（ `7.1.2§ ）
◎
Trailer field semantics now transcend the specifics of chunked transfer coding. The decoding algorithm for chunked (Section 7.1.3) has been updated to encourage storage/forwarding of trailer fields separately from the header section, to only allow merging into the header section if the recipient knows the corresponding field definition permits and defines how to merge, and otherwise to discard the trailer fields instead of merging. The trailer part is now called the trailer section to be more consistent with the header section and more distinct from a body part. (Section 7.1.2)
</p>

<p>
"`q^c" と呼ばれる転送~符号法~parameterは、
許容しないようにした
— `TE$h ~headerにおける `weight$p 【 `RFC7230$r においては `rank^p 】の利用と競合するのを避けるため。
（ `7.3§ ）
◎
Transfer coding parameters called "q" are disallowed in order to avoid conflicts with the use of ranks in the TE header field. (Section 7.3)
</p>

		</section>
	</section>
	<section id="acks">
<h2 title="Acknowledgements">謝辞</h2>

<p>
`HTTP$r `謝辞＠~HTTPinfra#acks§を見よ
— それは、
この文書にも適用される。
◎
See Appendix "Acknowledgements" of [HTTP], which applies to this document as well.
</p>

	</section>
	<section id="rfc.authors">
<h2 title="Authors' Addresses">著作者の~address</h2>

<p>
`HTTP$r のそれと同じ
【なので、この訳では省略する。】
</p>

	</section>
</main></div>
