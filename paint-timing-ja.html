<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Paint Timing（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w一-鿆~あ-ん\-]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){


if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	key = key.replace(/\(.+/, '');
	text = key + text.replace(/^[^\(]+/, '').replace(/\w+/g, '<var>$&</var>' );
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options
spec_title:Paint Timing
spec_date:2025-05-17
trans_update:2025-05-24
source_checked:240112
page_state_key:TIMING
original_url:https://w3c.github.io/paint-timing/
	abbr_url:
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2025,permissive
trans_1st_pub:2018-05-12


●●class_map
e:element
a:attr
p:property
t:type
v:value
st:attr-state

●●tag_map
I:code
m:code
e:code
a:code
st:span
p:code
v:code
i:i
t:var

●●original_id_map

●●mdn_urls
performancepainttiming:API/PerformancePaintTiming

●●link_map

Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default
object:~WEBIDL#idl-object

I.PaintTimingMixin:#painttimingmixin
I.PerformancePaintTiming:#performancepainttiming
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.PerformanceEntry:~TIMELINE#dom-performanceentry
I.SVGImageElement:~SVGembedded#InterfaceSVGImageElement
I.HTMLImageElement:~HEimages#htmlimageelement
I.HTMLVideoElement:~HEmedia#htmlvideoelement
I.Text:~DOM4#text
	I.Element:~DOM4#element → 要素
	I.Document:~DOM4#document → 文書

m.paintTime:#dom-painttimingmixin-painttime
m.presentationTime:#dom-painttimingmixin-presentationtime

m.toJSON:#dom-performancepainttiming-tojson

m.duration:~TIMELINE#dom-performanceentry-duration
m.entryType:~TIMELINE#dom-performanceentry-entrytype
m.name:~TIMELINE#dom-performanceentry-name
m.startTime:~TIMELINE#dom-performanceentry-starttime
m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes

m.getBoundingClientRect:~CSSOMVIEW#dom-element-getboundingclientrect


p.background-image:~CSSBG#propdef-background-image
p.background-size:~CSSBG#propdef-background-size
	p.background-size:~TR/css-backgrounds-3/#background-size
p.visibility:~CSSDISP#propdef-visibility
p.opacity:~CSSCOLOR#propdef-opacity
	~TR/css-color-3#opacity
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.display:~CSSDISP#propdef-display

t.image:~CSSIMAGE#typedef-image
t.url:~CSSVAL#url-value

e.canvas:~HEcanvas#the-canvas-element
	~canvas:~HEcanvas#canvas
e.video:~HEmedia#the-video-element
e.input:~HEinput#the-input-element
e.img:~HEimages#the-img-element
e.image:~SVGembedded#elementdef-image
e.svg:~SVGstruct#elementdef-svg

a.value:~HEinput#attr-input-value

	●用語
塗り:#paint
塗り計時に適格:#paint-timing-eligible
最初の塗り:#first-paint
最初の有内容な塗り:#first-contentful-paint
最初の有内容な塗りを報告するべき:#should-report-first-contentful-paint

有内容:#contentful
有内容な画像:#contentful-image
塗り可能な限界~矩形:#paintable-bounding-rect
塗り可能:#paintable
塗り可能な疑似要素:#paintable-pseudo-element

塗り計時を報告する:#report-paint-timing
塗り計時を刻む:#mark-paint-timing

計時に適格:#timing-eligible
結付けられた画像~要請:#associated-image-request
結付けられた背景~画像~要請~群:#associated-background-image-requests
処理待ち画像~記録:#pending-image-record
piR.要素:#pending-image-record-element
piR.要請:#pending-image-record-request
piR.読込n時刻:#pending-image-record-loadtime
所有する~text~node群:#set-of-owned-text-nodes
以前に報告した塗り群:#set-of-previously-reported-paints
描画~処理待ち画像~群:#images-pending-rendering
描画された~textを伴う要素~群:#set-of-elements-with-rendered-text
読込ngを完遂した画像を処理する:#process-an-image-that-finished-loading
塗り計時~用に公開されて:#exposed-for-paint-timing

ptM.塗り計時~報:#painttimingmixin-paint-timing-info
塗り計時~報:#paint-timing-info
ptI.描画~更新~終了~時刻:#paint-timing-info-rendering-update-end-time
ptI.実装定義な呈示~時刻:#paint-timing-info-implementation-defined-presentation-time
既定の塗り時刻印:#default-paint-timestamp

空でない~text:#non-empty

	●用語（外部
新たな~obj:~WEBIDLjs#new
実装-:~WEBIDLjs#implements
内包-:~WEBIDL#include
既定の~toJSON手続き:~WEBIDLjs#default-tojson-steps

文字列:~INFRA#string
有順序~集合:~INFRA#ordered-set
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
~list:~INFRA#list
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append

並列的:~HTMLINFRA#in-parallel

url.~scheme:~URL1#concept-url-scheme

処理能~時列線~task~source:~TIMELINE#dfn-performance-timeline-task-source
処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
要素の計時を報告する:https://wicg.github.io/element-timing/#report-element-timing
最~大な有内容な塗りを報告する:https://w3c.github.io/largest-contentful-paint/#report-largest-contentful-paint

doc.現在の~frame計時~報:~LONGAF#current-frame-timing-info
長い~animation~frame~entryを~queueする:~LONGAF#queue-a-long-animation-frame-entry

要素:~DOM4#concept-element
子孫:~DOM4#concept-tree-descendant
根:~DOM4#concept-tree-root
接続されて:~DOM4#connected
文書:~DOM4#concept-document
子孫~text内容:~DOM4#concept-descendant-text-content
~text内容:~HTMLdom#text-content

表現-:~HTMLdom#represents
画像~要請:~HEimages#image-request
状態:~HEimages#img-req-state
st.完全に可用:~HEimages#img-all
st.部分的に可用:~HEimages#img-inc
具現化されて:~HTMLrendering#being-rendered
画像:~HEimages#images
~canvas文脈~mode:~HEcanvas#concept-canvas-context-mode
可用:~HEimages#img-available
可用な画像:~HEimages#img-available
~poster~frame:~HEmedia#poster-frame

入子な閲覧~文脈:~BROWSERS#nested-browsing-context
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
閲覧~文脈:~HTMLds#browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
全部的に作動中:~HTMLds#fully-active
対応する閲覧~文脈:~WINDOW#window-bc
結付けられた文書:~WINDOW#concept-document-window

描画を更新する手続き:~WAPI#update-the-rendering
	:~WAPI#event-loop-processing-model
~event~loop処理~model:~WAPI#event-loop-processing-model
関連な設定群~obj:~WAPI#relevant-settings-object
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
rM.大域~obj:~WAPI#concept-realm-global
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
大域~taskを~queueする:~WAPI#queue-a-global-task

~box:~CSSDISP#box
包含塊:~CSSDISP#containing-block
置換d要素:~CSSDISP#replaced-element
~text~node:~CSSDISP#text-nodes
使用~値:~CASCADE#used-value
	使用~値:~CASCADE#used
~scroll用~区画:~CSSOMVIEW#scrolling-area
空白:~CSSTEXT#white-space
出自の要素:~SELECTORS4#originating-element
阻み期間:~CSSFONT#font-block-period


●●words_table1


●●words_table

	●呈示／CSS
iframe:
封入-:enclose:~
知覚-:perceive::~
切取る:clipする::切り取る
切取られ:clipされ::切り取られ
拡縮-:scale::~
限界:bounding::~
矩形:rectangle::~
	矩形:rect／Rect
zoom::::ズーム
出自の:originating::~
poster::::ポスター
typographic::::タイポグラフィック
	typographicな:typographical
不透明度:opacity::~
書体:face::~::フェース

	●計時／塗り／perf
阻み:block::~::ブロック
期間:period:~
高分解能:high resolution::~
計量:metric::~
捕捉-:capture::~
	~page読込:pageload
刻む:markする::~
刻まな:markしな::~
有内容:contentful::~
塗り:paint::~
塗る:paintする::~
塗られ:paintされ::~
	塗るために:painting
	塗り可能:paintable
	最初の有内容な塗り:first contentful paint／:FCP
	最初の塗り:first paint／:FP
	最初の塗りと最初の有内容な塗り:First Paint and First Contentful Paint
	塗りの種別:minimal frame attribution
	塗り計時:paint-timing／paint timing
milli::::ミリ
	~milli秒数で:millisecond
粗化-:coarsen:粗く
粗く:coarseに:~
	より粗く:coarser
長い:long::~

	処理能~entryを~queueする:Add the PerformanceEntry
	-:record
	~~記録可能:able to note
	報告-法:reporting
	時点:moments
	時点:the point
	時点:time when
	時点:the time at which
	時点:the points
	時点:when
	時点:when the point
	起こる:happen
	整数倍になるよう切り上げ:the next multiple

	●処理一般
pipeline:
	何もしない:do nothing
処理待ち:pending:~
書出す:flushする::書き出す
toJSON:
	-:ctx
	%限界~矩形:boundingRect
	%要素:element
	%画像~要請:imageRequest
	%根:root
	%今:now
	%記録:record
	%塗り計時~報:paintTimingInfo
	%~frame計時~報:frameTimingInfo
	%時刻印:-
	%文書:document
	%塗られた画像~群:paintedImages
	%塗られた~text~node群:paintedTextNodes
	%塗り計時~群を書出す:flushPaintTimings
	%文書:doc
	%報告-済み塗り群:reportedPaints
	%~text:text
	%大域~obj:-

	●仕様

問い:question:~
答える:answerする:~
主要な:key:~
適格:eligible:~
基礎的:fundamental:~
土台:foundation:~
	土台になる:foundational
文言:language:~
翻訳-:translate:~
統一化-:unify:~
厳格:rigorous:~
為す:makeする:~

	関知する:aware of
	対照的に:By contrast
	とても:very
	導いた:lead した
	~~意見:input
	満たす:apply
	注記-:note

	●未分類
解析:analytics:~
白紙:blank:~
露呈-:reveal:露わに
main:
内包-:include::~

	含まれない:exclude
	文字列:DOMString
	後続する:followed by
	既定でない:non-default
	最善な労の下で:best effort
	-:docs
	-:instance
	-:possible
	-:target
	転換-:turn into
	初期~時:initiallize
	満たす:apply
	-:choose
	-:know
	含める:includeする
	始まる:begin
	指して:point
	漠然と:vague
	初回:first time
	一連の:a series of
	何であれ:anything
	-:何かを
	直後:immediately after
	前に:prior to
	あったもの:what was
	互いの:and vice versa
	最新の:latest
	〜以外の:excluding
	〜個以上は:at least
	〜の他に:in addition to
	少なくとも，:at the very least

●●ref_normative

[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. ＜CSS Color Module Level 3＞. URL: https://drafts.csswg.org/css-color-3/
[CSS-DISPLAY-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 4＞. URL: https://drafts.csswg.org/css-display/
[CSS-FONTS-4]
    Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-TEXT-4]
    Elika Etemad; et al. ＜CSS Text Module Level 4＞. URL: https://drafts.csswg.org/css-text-4/
[CSSOM-VIEW-1]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ELEMENT-TIMING]
    ＜Element Timing API＞. Editor's Draft. URL: https://w3c.github.io/element-timing/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PERFORMANCE-TIMELINE]
    Nicolas Pena Moreno. ＜Performance Timeline＞. URL: https://w3c.github.io/performance-timeline/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[SVG2]
    Amelia Bellamy-Royds; et al. ＜Scalable Vector Graphics (SVG) 2＞. URL: https://svgwg.org/svg2-draft/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Paint Timing</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/paint-timing/
公表履歴
	https://www.w3.org/standards/history/paint-timing/

フィードバック
	<a href="https://github.com/w3c/paint-timing/issues/">GitHub</a>
編集
	<a href="mailto:iclelland@chromium.org">Ian Clelland</a> (Google)
	<a href="mailto:noam@webkit.org">Noam Rosenthal</a> (Invited Expert)
前任編集者
	<a href="mailto:panicker@google.com">Shubhie Panicker</a> (Google)
	<a href="mailto:npm@chromium.org">Nicolás Peña Moreno</a> (Google)
commit 履歴
	https://github.com/w3c/paint-timing/commits/main/
公表者
	<a href="https://www.w3.org/groups/wg/webperf">Web Performance WG</a>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>塗りの計時 — Paint Timing</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、
次を捕捉するために利用できる~APIを定義する
⇒
開発者が~page読込nの間に~careする，一連の主要な時点（`最初の塗り$, `最初の有内容な塗り$）
◎
This document defines an API that can be used to capture a series of key moments (first paint, first contentful paint) during pageload which developers care about.
</p>


	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
利用者~用に［
~HTML, ~CSS, 画像
］資源を~screen上の画素~群に翻訳することは、
~web~browserの目的のかなりを占める。
~web~pageの処理能を測定することは、
これらの［
~textや画像などの内容を~screenへ描画する~task
］を遂行するためにかかった時間を測定することを孕むことが多い。
この計時を［
~pageの処理能／
読込ngの利用者~体験
］について言明を為すために利用する仕方には，様々なものがあるが、
どの仕方でも，基礎的には［
時間を測定するための共通な手段
］で始まる。
◎
Much of the purpose of a web browser is to translate HTML, CSS and image resources into pixels on a screen for users. Measuring the performance of a web page often involves measuring the time it takes to perform these tasks - to render content, whether text or image, to the screen. There are many different ways to use this timing to make statemements about the performance of a page, or about the user experience of loading, but fundamentally all of those ways begin with a common means of measuring time.
</p>

<p>
これは、
塗り計時を測定する方法を一般~目的な仕組みとして指定する土台になる文書である。
その土台は、
`最初の塗りと最初の有内容な塗りの計量＠#first-paint-and-first-contentful-paint$を定義するために利用される。
他の文書も、
塗りの測定を成す他の特定の~instanceを指定し得る。
◎
This is a foundational document which specifies how to measure paint timing as a general-purpose mechanism. That foundation is then used to define the First Paint and First Contentful Paint metrics. Other specific instances of paint measurement may be specified in other documents.
</p>

<p>
この仕様が特定的に受持つものは：
◎
Specifically, this specification covers:
</p>
<ul>
	<li>
画像が復号され，塗るために準備済みになった時刻を測定する。
◎
Measuring the time when images are decoded and ready for painting
</li>
	<li>
要素が塗られた時刻を測定する。
◎
Measuring the time when elements are painted
</li>
	<li>
塗られた要素の~sizeを測定する。
◎
Measuring the size of the painted elements
</li>
	<li>
塗られた要素が可視な内容を包含するか否かを決定する。
◎
Determining whether a painted element contains any visible content.
</li>
</ul>

		<section id="first-paint-and-first-contentful-paint">
<h3 title="First Paint and First Contentful Paint">1.1. 最初の塗りと最初の有内容な塗り</h3>

<p>
~pageの読込nは、
~~時間軸における単独の時点ではない
— それは、
ある 1 つの計量で全部的に捕捉できる体験ではない。
読込n体験の間には、［
利用者が “速い”, “遅い” どちらに知覚するか
］に影響し得る複数の時点がある。
◎
Load is not a single moment in time — it’s an experience that no one metric can fully capture. There are multiple moments during the load experience that can affect whether a user perceives it as "fast" or "slow".
</p>

<p>
`最初の塗り$は，これらの主要な時点のうち最初のものであり、
`最初の有内容な塗り$が，それに後続する。
これらの計量は、
~browserが所与の文書を描画する時点を刻む。
これは、
“起きているのか？” の問いに答えるので，利用者にとって重要になる。
◎
First paint (FP) is the first of these key moments, followed by first contentful paint (FCP). These metrics mark the points in time when the browser renders a given document. This is important to the user because it answers the question: is it happening?
</p>

<p>
2 つの計量の首な相違は：
`最初の塗り$は、［
~browserが所与の文書~用に初めて何かを描画する時点
］を刻む。
対照的に，`最初の有内容な塗り$は、［
~browserが~DOMからの画像や~text内容を成す最初の~bitを描画する時点
］を刻む。
◎
The primary difference between the two metrics is FP marks the first time the browser renders anything for a given document. By contrast, FCP marks the time when the browser renders the first bit of image or text content from the DOM.
</p>

		</section>
		<section id="example">
<h3 title="Usage example">1.2. 用法~例</h3>

<pre class="example lang-js">
const %observer = new PerformanceObserver(function(%list) {
    var %perfEntries = %list.getEntries();
    for (const %perfEntry of %perfEntries) {
        /* <span class="comment">
解析と監視~用に，~entryたちを処理して報告する…
◎
Process entries report back for analytics and monitoring ...
</span> */
    }
});

/* <span class="comment">
塗り計時の通知~用に観測器を登録する
◎
register observer for paint timing notifications
</span> */
%observer.observe({entryTypes: ["paint"]});
</pre>

		</section>
	</section>
	<section id="sec-terminology">
<h2 title="Terminology">2. 各種用語</h2>

<dl>
	<dt>
`塗り@
（ `paint^en ）
◎
Paint:
</dt>
	<dd>
~UAが描画-~treeを~screen上の画素に変換したときに遂行した “塗り” （あるいは “描画-” ）。
正式には、
`描画を更新する手続き$ `HTML$r を遂行したとき，~UAは文書を “描画した” と見なされる。
◎
the user agent has performed a "paint" (or "render") when it has converted the render tree to pixels on the screen. Formally, we consider the user agent to have "rendered" a document when it has performed the update the rendering steps of the event loop.
</dd>
	<dd class="note">注記：
描画~pipelineは とても複階的なので、
そのときを指す時刻印は，~UAが この~pipelineにおいて~~記録可能な最新の時刻印になるべきである（最善な労の下で）。
この~API用には、
概して，表示-用の~frameが~OSに提出される時点が推奨される。
◎
NOTE: The rendering pipeline is very complex, and the timestamp should be the latest timestamp the user agent is able to note in this pipeline (best effort). Typically the time at which the frame is submitted to the OS for display is recommended for this API.
</dd>

	<dt>
`塗り可能な疑似要素@
（ `paintable pseudo-element^en ）
◎
A generated content pseudo-element is a paintable pseudo-element＼
</dt>
	<dd>
<p>
`生成d内容~疑似要素＠~CSSPSEUDO#generated-content$であって，次に挙げるすべてを満たすもの：
◎
when all of the following apply:
</p>
		<ul>
			<li>
`visibility$p の`使用~値$ ~EQ `visible^v
◎
The pseudo-element’s used visibility is visible.
</li>
			<li>
`opacity$p の`使用~値$ ~GT 0
◎
The pseudo-element’s used opacity is greater than zero.
</li>
			<li>
空でない`~box$を生成する
◎
The pseudo-element generates a non-empty box.
</li>
		</ul>
	</dd>

	<dt>
`有内容な画像@
（ `contentful image^en ）
◎
A CSS image img is a contentful image＼
</dt>
	<dd>
<p>
`image$t による~CSS画像であって，次に挙げるすべてを満たすもの：
◎
when all of the following apply:
</p>

		<ul>
			<li>
`image$t は `url$t である
◎
img is url valued.
</li>
			<li>
`可用な画像$を表現している
◎
img is available.
</li>
		</ul>
	</dd>

	<dt>
`空でない~text@
</dt>
	<dd>
1 個~以上の`空白$でない文字を包含する文字列【！DOMString】。
◎
A DOMString is non-empty if it contains at least one character excluding document white space characters.
</dd>

	<dt>
`有内容@
（ `contentful^en ）な要素
◎
An element target is contentful＼
</dt>
	<dd>
<p>
~OR↓ を満たす`要素$：
◎
when one or more of the following apply:
</p>
		<ul>
			<li>
<p>
次を満たす`~text~node$が子に在る
⇒
［
`空でない~text$を表現している
］~AND［
`opacity$p の`使用~値$ ~GT 0 †
］
◎
target has a text node child, representing non-empty text, and the node’s used opacity is greater than zero.
</p>

<p class="note">注記：†
これは、
ある
`~typographicな疑似要素＠~CSSPSEUDO#typographic-pseudos$が，
この~text~nodeの不透明度を上書きする事例を受持つ。
◎
NOTE: this covers the case where a typographical pseudo-element would override the opacity of the text node.
</p>
			</li>
			<li>
`可用な画像$【！`画像$】を表現している`置換d要素$である
◎
target is a replaced element representing an available image.
</li>
			<li>
［
`background-image$p は`有内容な画像$である
］~AND［
`background-size$p の`使用~値$の横幅, 縦幅とも 0 でない
］
◎
target has a background-image which is a contentful image, and its used background-size has non-zero width and height values.
</li>
			<li>
次を満たす `canvas$e 要素である
⇒
`~canvas文脈~mode$ ~NEQ `none^v
◎
target is a canvas with its context mode set to any value other than none.
</li>
			<li>
次を満たす `video$e 要素である
⇒
その［
`~poster~frame$／最初の動画~frame
］を`表現-$していて，当の~frameは可用である
◎
target is a video element that represents its poster frame or the first video frame and the frame is available.
</li>
			<li>
次を満たす `svg$e 要素である
⇒
`描画される子孫がある＠~SVGrender#Rendered-vs-NonRendered$
◎
target is an svg element with rendered descendants.
</li>
			<li>
次を満たす `input$e 要素である
⇒
`value$a 属性を有していて, その値は`空でない~text$である
◎
target is an input element with a non-empty value attribute.
</li>
			<li>
［
次のいずれかを表現する`塗り可能な疑似要素$
］の`出自の要素$である
⇒＃
`有内容な画像$／
`空でない~text$
◎
target is an originating element for a paintable pseudo-element that represents a contentful image or non-empty text.
</li>
		</ul>
	</dd>
	<dd class="trans-note">【
語義的には，［
子孫に`有内容$な要素が在る要素も`有内容$である
］と見なしたくなる所だが、
上の定義はそうなっていない。
とはいえ，そのように定義を改めても結果は同じになる（現時点では, および この仕様に限るなら）。
】</dd>

	<dt>
`計時に適格@
（ `timing-eligible^en ）
な要素
◎
An element is timing-eligible＼
</dt>
	<dd>
<p>
~OR↓ を満たす`要素$：
◎
if it is one of the following:
</p>
		<ul>
			<li>
`img$e 要素である
◎
an img element.
</li>
			<li>
次を満たす `image$e 要素である
⇒
`svg$e 要素の内側にある
◎
an image element inside an svg element.
</li>
			<li>
次を満たす `video$e 要素である
⇒
その`~poster~frame$ ~NEQ ε
◎
a video element with a poster frame.
</li>
			<li>
その `background-image$p ~propは`有内容な画像$を与えている
◎
an element with a contentful background-image.
</li>
			<li>
~text~nodeである
【`子孫~text内容$は`空でない~text$である？】
◎
a text node.
</li>
		</ul>
	</dd>

	<dt>
`塗り可能な限界~矩形@
（ `paintable bounding rect^en ）
◎
＼
</dt>
	<dd class="algo">
<p>
`要素$ %要素 の`塗り可能な限界~矩形$を算出する
~algoは：
◎
To compute the paintable bounding rect of element target, run the following steps:
</p>
		<ol>
			<li>
%限界~矩形 ~LET %要素 上の `getBoundingClientRect$m ~method手続き()
◎
Let boundingRect be the result of running the getBoundingClientRect() on target.
</li>
			<li>
%限界~矩形 を`文書$の`~scroll用~区画$で切取る
◎
Clip boundingRect with the document’s scrolling area.
</li>
			<li>
~RET %限界~矩形
◎
Return boundingRect.
</li>
</ol>

<p class="note">注記：
要素が［
`overflow$p が［
`scroll^v ／ `hidden^v
］にされた~box
］に包含されている場合、
`塗り可能な限界~矩形$は切取られない
— 両~事例とも，`要素$を~scrollすることで可視になり得るので。
◎
NOTE: elements contained by boxes with overflow: scroll or overflow: hidden don’t have their paintable bounding rect clipped, as in both cases the element can become visible by scrolling.
</p>

	</dd>

	<dt>
`塗り可能@
（ `paintable^en ）な要素
◎
An element el is paintable＼
</dt>
	<dd>
<p>
次に挙げるすべてを満たす`要素$
◎
when all of the following apply:
</p>
		<ul>
			<li>
`具現化されて$いる
◎
el is being rendered.
</li>
			<li>
`visibility$p の`使用~値$ ~EQ `visible^v
◎
el’s used visibility is visible.
</li>
			<li>
<p>
自身, および そのどの先祖も，次を満たす
⇒
`opacity$p の`使用~値$ ~GT 0
◎
el and all of its ancestors' used opacity is greater than zero.
</p>

<p class="note">注記：
例えば，~textがその背景と同じ色である事例など、
塗り可能な`要素$が利用者から可視にならない事例もある。
それらの要素は、
`最初の有内容な塗り$を算出する目的においては，依然として塗り可能と見なされる。
◎
NOTE: there could be cases where a paintable element would not be visible to the user, for example in the case of text that has the same color as its background. Those elements would still considered as paintable for the purpose of computing first contentful paint.
</p>
			</li>
			<li>
<p>
その`塗り可能な限界~矩形$は、
`文書$の`~scroll用~区画$と交差する
◎
el’s paintable bounding rect intersects with the scrolling area of the document.
</p>

<p class="note">注記：
これは、
次に挙げるような，内容【区画】が空な矩形に解決される事例を受持つ
⇒＃
要素は~size 0 に拡縮される／
`display$p は `none^v または `contents^v
◎
NOTE: This covers the cases where the element is scaled to zero size, has display: none, or display: contents where the contents resolve to an empty rect.
</p>

<p class="note">注記：
一般~規則として，`要素$は、
表示域の中にあるか［
~scrollする／~zoomする
］ことでそうなり得るならば塗り可能である。
◎
NOTE: As a general rule, an element is paintable if it is within the viewport, or can potentially be in the viewport as a result of scrolling or zooming.
</p>
			</li>
		</ul>
	</dd>

	<dt>
`最初の塗り@
（ `first paint^en ／ <abbr>FP</abbr> ）
◎
First paint
</dt>
	<dd>
これに対応する~entryは、
`DOMHighResTimeStamp$I 値を包含する
— それは、
~UAが~navi後に最初に何かを描画した時点を報告する。
これには、
既定の背景~塗りは含まれないが，［
既定でない背景 ／ ~iframeを封入している~box
］の塗りは含まれる。
これは、
開発者が~pageの読込nについて~careする最初の主要な時点
— ~UAが~pageの描画を開始したとき —
を表す。
◎
entry contains a DOMHighResTimeStamp reporting the time when the user agent first rendered after navigation. This excludes the default background paint, but includes non-default background paint and the enclosing box of an iframe. This is the first key moment developers care about in page load – when the user agent has started to render the page.
</dd>

	<dt>
`塗り計時に適格@
（ `paint-timing eligible^en ）
◎
↓</dt>
	<dd>
<p>
所与の`閲覧~文脈$が`塗り計時に適格$であるとは、
~OR↓ を満たすことをいう：
◎
A browsing context ctx is paint-timing eligible when one of the following apply:
</p>
		<ul>
			<li>
`~top-level閲覧~文脈$である
◎
ctx is a top-level browsing context.
</li>
			<li>
<p>
［
`入子な閲覧~文脈$である
］~AND［
~UAは、［
この閲覧~文脈が塗り計時を報告する
］よう環境設定されている
］
◎
ctx is a nested browsing context, and the user agent has configured ctx to report paint timing.
</p>

<p class="note">注記：
これは、［
~main~frameの他に，塗り計時を可能化する~frameは、
一部に限る
］ことを~UAに許容する。
例えば，~UAは、
非同一-生成元に属する~iframe用には，
塗り計時を不能化するよう裁定してもヨイ
— 一部の局面においては、
それらの塗り計時は［
~main~frameについての情報を露呈する
］かもしれないので。
◎
NOTE: this allows user agents to enable paint-timing only for some of the frames, in addition to the main frame, if they so choose. For example, a user agent may decide to disable paint-timing for cross-origin iframes, as in some scenarios their paint-timing might reveal information about the main frame.
</p>
			</li>
		</ul>
	</dd>
</dl>

		<section id="sec-PaintTimingMixin">
<h3 title="The PaintTimingMixin interface">3. `PaintTimingMixin^I ~interface~mixin</h3>

<pre class="idl">
[`Exposed$=Window]
interface mixin `PaintTimingMixin@I {
    readonly attribute `DOMHighResTimeStamp$I `paintTime@m;
    readonly attribute `DOMHighResTimeStamp$I? `presentationTime@m;
};
</pre>

<p>
`PaintTimingMixin$I ~interface~mixinを`内包-$【する~interfaceを`実装-$】している各~objには、
`塗り計時~報@ptM
が結付けられる
— それは、［
~NULL ／ある`塗り計時~報$
］である。
◎
Objects including the PaintTimingMixin interface mixin have an associated paint timing info (null or a paint timing info).
</p>

<p>
`塗り計時~報@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
paint timing info is a struct. It has the following items:
</p>
<ul>
	<li>
`描画~更新~終了~時刻@ptI
⇒
ある `DOMHighResTimeStamp$I
◎
rendering update end time
• A DOMHighResTimeStamp
</li>
	<li>
`実装定義な呈示~時刻@ptI
⇒
~NULL ／ ある `DOMHighResTimeStamp$I
◎
implementation-defined presentation time
• Null or a DOMHighResTimeStamp
</li>
</ul>

<div class="algo">
`paintTime$m 取得子~手続きは
⇒
~RET コレの`塗り計時~報$ptM†の`描画~更新~終了~時刻$ptI
◎
The paintTime attribute’s getter step is to return this’s paint timing info’s rendering update end time.
</div>

<div class="algo">
`presentationTime$m
取得子~手続きは
⇒
【！if exists,】
~RET コレの`塗り計時~報$ptM†の`実装定義な呈示~時刻$ptI
◎
The presentationTime attribute’s getter step, if exists, is to return this’s paint timing info’s implementation-defined presentation time.
</div>

<p class="trans-note">【†
`塗り計時~報$ptM ~EQ ~NULL の場合にどうなるか指定されていないが、
この仕様が定義する~interface（ `PerformancePaintTiming$I ）においては， ~NULL をとり得ない。
】</p>

<div class="algo">
<p>
`既定の塗り時刻印@
は、
所与の
( `塗り計時~報$ %塗り計時~報 )
に対し：
</p>
<ol>
	<li>
%時刻印 ~LET %塗り計時~報 の`実装定義な呈示~時刻$ptI
</li>
	<li>
~IF［
%時刻印 ~NEQ ~NULL
］
⇒
~RET %時刻印
</li>
	<li>
~RET %塗り計時~報 の`描画~更新~終了~時刻$ptI
</li>
</ol>
◎
To get the default paint timestamp for a paint timing info paintTimingInfo, return paintTimingInfo’s implementation-defined presentation time if it is non-null, otherwise paintTimingInfo’s rendering update end time.
</div>

		</section>
	</section>
	<section id="sec-PerformancePaintTiming">
<h2 title="The PerformancePaintTiming interface">4. `PerformancePaintTiming^I ~interface</h2>

<pre class="idl">
[`Exposed$=Window]
interface `PerformancePaintTiming@I : `PerformanceEntry$I {
    [`Default$] `object$ `toJSON()$m;
};

`PerformancePaintTiming$I includes `PaintTimingMixin$I;
</pre>

<p>
`PerformancePaintTiming$I は、
`PerformanceEntry$I ~interfaceの以下に挙げる属性を拡張する：
◎
PerformancePaintTiming extends the following attributes of PerformanceEntry interface:
</p>

<ul>
	<li class="algo">
`name$m 取得子~手続きは
⇒
~RET 生じた塗りの種別に応じて，次に与える文字列
⇒＃
`最初の塗り$用には `first-paint^l ／
`最初の有内容な塗り$用には `first-contentful-paint^l
◎
The name attribute’s getter must return a DOMString for minimal frame attribution. Possible values of name are:
• "first-paint": for first paint
• "first-contentful-paint": for first contentful paint
</li>
	<li class="algo">
`entryType$m 取得子~手続きは
⇒
~RET `paint^l
◎
The entryType attribute’s getter must return "paint".
</li>
	<li class="algo">
`startTime$m 取得子~手続きは
⇒
~RET 塗りが生じた時点を表す `DOMHighResTimeStamp$I 値
◎
The startTime attribute’s getter must return a DOMHighResTimeStamp of when the paint occured.
</li>
	<li class="algo">
`duration$m 取得子~手続きは
⇒
~RET 0
◎
The duration attribute’s getter must return 0.
</li>
	<li>
`toJSON()@m
は、
`PerformancePaintTiming$I 用の`既定の~toJSON手続き$に従う。
◎
When toJSON is called, run the default toJSON steps for PerformancePaintTiming.
</li>
</ul>

<p class="note">注記：
`PerformancePaintTiming$I を実装している~UAは、
`大域~obj$rMのうち［
それに`対応する閲覧~文脈$は`塗り計時に適格$であるもの
］には，その `supportedEntryTypes$m 内に `paint^l を含める必要がある。
これは、［
特定0の`閲覧~文脈$に対し塗り計時~用の~supportを検出すること
］を，開発者に許容する。
◎
NOTE: A user agent implementing PerformancePaintTiming would need to include "paint" in supportedEntryTypes of a global object whose browsing context is paint-timing eligible. This allows developers to detect support for paint timing for a particular browsing context.
</p>

	</section>
	<section id="sec-processing-model">
<h2 title="Processing model">5. 処理~model</h2>

		<section id="sec-associated-image-requests">
<h3 title="Associated Image Requests">5.1. 要素に結付けられた画像~要請</h3>

<p>
各`要素$には，それに
`結付けられた画像~要請@
がある
— それは、［
`画像~要請$／~NULL
］であり，
初期~時は ~NULL とする。
◎
Each Element has an associated image request which is an image request or null, initially null.
</p>

<div class="algo">
［
`HTMLImageElement$I ／ `SVGImageElement$I ／ `HTMLVideoElement$I
］型の`要素$ %要素 用の処理~modelが新たな画像~資源 %資源
（例： 画像や~poster画像として表示されるもの）
を作成したときは、
次を走らすとする
⇒
%要素 に`結付けられた画像~要請$ ~SET %資源 の`画像~要請$
◎
When the processing model for an Element element of type HTMLImageElement, SVGImageElement, or HTMLVideoElement creates a new image resource (e.g., to be displayed as an image or poster image), element’s associated image request is set to the image request of the created image resource.
</div>

<p class="note">注記：
画像~資源が［
`~scheme$urlが `data^l に等しい~URL
］から得されたものである場合，ある`画像~要請$が結付けられる
— それは、
~fetchされないが，それでも読込む必要がある。
この要請は、
`要素$に`結付けられた画像~要請$になり得る。
◎
Note: Every image resource that is obtained from a URL whose scheme is equal to "data" has an associated image request which is not fetched but still needs to be loaded. This request can be the associated image request of an Element.
</p>

<p class="note">注記：
現在の文言は、
特定の~algoを指しておらず，漠然としている。
これは、
対応する処理~modelが より統一化されるに伴い，より厳格にされ得る。
◎
Note: The current language is vague since it does not point to specific algorithms. This can be made more rigorous when the corresponding processing models have a more unified processing model.
</p>

<p>
各`要素$ %要素 には、
それに
`結付けられた背景~画像~要請~群@
がある
— それは、
`画像~要請$たちが成す`~list$【！配列】であり，初期~時は空とする。
◎
Every Element has a list of associated background image requests which is initially an empty array.＼
</p>

<div class="algo">
%要素 の~style用の処理~modelにより新たな画像~資源 %資源 が要求される
（背景~画像として表示されることになる）
に伴い、
次を走らすとする
⇒
%要素 に`結付けられた背景~画像~要請~群$に %資源 により作成された`画像~要請$を`付加する$
◎
When the processing model for the Element element’s style requires a new image resource (to be displayed as background image), the image request created by the new resource is appended to element’s associated background image requests.
</div>

<p class="note">注記：
`要素$が有する`画像~要請$は複数個あり得る
— 例： その `background-image$p ~propが複数個の画像を与えている場合。
一例として、
次の例では，単独の `background-image$p ~propが 4 個の `画像~要請$を生産する
— 各~要請は、
以下の~algoにより記録され報告されることになる。
◎
NOTE: An Element can have several image requests, e.g. if its background-image property has multiple values. For instance, in the following example, a single background-image property produces four image requests, each of which will be recorded and reported by the algorithms below.
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
div {
  background-image: url(https://images.example/background1.png),
                    url(https://images.example/background2.png);
}
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
</pre>

		</section>
		<section id="sec-recording-paint-timing">
<h3 title="Recording paint timing">5.2. 塗り計時の記録-法</h3>

<p>
`処理待ち画像~記録@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A pending image record is a struct with the following items:
</p>
<ul>
	<li>
`要素@piR
⇒
ある`要素$
◎
element, an Element
</li>
	<li>
`要請@piR
⇒
ある`画像~要請$
◎
request, an image request
</li>
	<li>
`読込n時刻@piR
⇒
ある `DOMHighResTimeStamp$I
◎
loadTime, a DOMHighResTimeStamp
</li>
</ul>

<p>
各`要素$には、
それが
`所有する~text~node群@
がある
— それは、
`Text$I ~nodeたちが成す`有順序~集合$であり，
初期~時は空とする。
◎
Each Element has a set of owned text nodes, which is an ordered set of Text nodes, initially empty.
</p>

<p>
各`文書$は、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`以前に報告した塗り群@
⇒
`文字列$たちが成す`有順序~集合$
— 初期~時は空とする。
◎
Each Document has a set of previously reported paints, which is an ordered set of strings, initially empty.
</li>
	<li>
`描画~処理待ち画像~群@
⇒
`処理待ち画像~記録$たちが成す`~list$
— 初期~時は空とする。
◎
Each Document has an images pending rendering, which is a list of pending image records, initally empty.
</li>
	<li>
`描画された~textを伴う要素~群@
⇒
`要素$たちが成す`~list$
— 初期~時は空とする。
◎
Each Document has a set of elements with rendered text, which is an ordered set of Elements, initially empty.
</li>
</ul>

			<section id="sec-modifications-CSS">
<h4 title="Modifications to the CSS specification">5.2.1. ~CSS仕様に対する改変</h4>

<div class="algo">
`要素$ %要素 に`結付けられた背景~画像~要請~群$を成すある`画像~要請$ %要請 に対し，［
%要請 の`状態$ ~EQ `完全に可用$st
］になったときは、
次を走らすとする
⇒
`読込ngを完遂した画像を処理する$( %要素, %要請 )
◎
Whenever an image request in an Element element’s associated background image requests becomes completely available, run the algorithm to process an image that finished loading with element and image request as inputs.
</div>

			</section>
			<section id="sec-modifications-dom">
<h4 title="Modifications to the HTML specification">5.2.2. ~HTML仕様に対する改変</h4>

<div class="algo">
［
`要素$ %要素 に`結付けられた画像~要請$ %要請 の`状態$ ~EQ `完全に可用$st
］になったときには、
次を走らすとする
⇒
`読込ngを完遂した画像を処理する$( %要素, %要請 )
◎
When an Element element’s associated image request has become completely available, run the algorithm to process an image that finished loading passing in element and its associated image request as inputs.
</div>


<div class="algo">
<p>
~UAは、
`Text$I node %~text を初回に塗るときは，
次の手続きを実行するベキである：
◎
When the user agent paints a Text node text for the first time, it should execute the following steps:
</p>
<ol>
	<li>
~IF［
%~text は、
それに利用される~font書体が`阻み期間$にあることに因り，塗られない
］
⇒
~RET
◎
If text will not be painted due to the font face being in its font block period, then return.
</li>
	<li>
［
%~text の`包含塊$を確立している【！determine】`要素$
］が`所有する~text~node群$に %~text を`付加する$set
◎
Let element be the Element which determines the containing block of text.
◎
Append text to element’s set of owned text nodes.
</li>
</ol>
</div>

			</section>
			<section id="process-image-that-finished-loading">
<h4 title="Process image that finished loading">5.2.3. 読込ngを完遂した画像を処理する</h4>

<div class="algo">
<p>
`読込ngを完遂した画像を処理する@
~algoは、
所与の
( `要素$ %要素, `画像~要請$ %画像~要請 )
に対し：
◎
To process an image that finished loading given an Element element and an image request imageRequest:
</p>
<ol>
	<li>
%根 ~LET %要素 の`根$
◎
Let root be element’s root.
</li>
	<li>
~IF［
%根 は`文書$でない
］
⇒
~RET
◎
If root is not a Document, return.
</li>
	<li>
%今 ~LET `現在の高分解能~時刻$( %要素 に`関連な大域~obj$ )
◎
Let now be the current high resolution time given element’s relevant global object.
</li>
	<li>
%記録 ~LET 新たな`処理待ち画像~記録$
— その
⇒＃
`要素$piR ~SET %要素,
`要請$piR ~SET %画像~要請,
`読込n時刻$piR ~SET %今
◎
Let record be a pending image record with element element, request imageRequest and loadTime now.
</li>
	<li>
%根 の`描画~処理待ち画像~群$に %記録 を`付加する$【！add】
◎
Add record to root’s images pending rendering.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="sec-reporting-paint-timing">
<h3 title="Reporting paint timing">5.3. 塗り計時の報告-法</h3>

			<section id="first-contentful-paint">
<h4 title="First Contentful Paint">5.3.1. 最初の有内容な塗り</h4>

<p>
次を満たす`文書$ %文書 は
`最初の有内容な塗りを報告するべき@
であるとされる
⇒
［
`first-contentful-paint^l ~NIN %文書 の`以前に報告した塗り群$
］~AND［
%文書 は`塗り可能$かつ`有内容$な`要素$を 1 個は包含する
］
◎
To know whether Document document should report first contentful paint, perform the following steps:
• If document’s set of previously reported paints contains "first-contentful-paint", then return false.
• If document contains at least one element that is both paintable and contentful, then return true.
• Otherwise, return false.
</p>

			</section>
			<section id="mark-paint-timing">
<h4 title="Mark paint timing">5.3.2. 塗り計時を刻む</h4>

<div class="algo">
<p>
`塗り計時を刻む$ときは、
所与の
( `文書$ %文書 )
に対し，次の手続きを遂行する：
◎
When asked to mark paint timing given a Document document as input, perform the following steps:
</p>

<ol>
	<li>
~IF［
%文書 が`属する閲覧~文脈$は`塗り計時に適格$でない
］
⇒
~RET
◎
If the document’s browsing context is not paint-timing eligible, return.
</li>
	<li>
%大域~obj ~LET %文書 に`関連な大域~obj$
◎
↓</li>
	<li>
%塗り計時~報 ~LET 新たな`塗り計時~報$
— その
⇒＃
`描画~更新~終了~時刻$ptI ~SET `現在の高分解能~時刻$( %大域~obj ),
【`実装定義な呈示~時刻$ptI ~SET ~NULL】
◎
Let paintTimingInfo be a new paint timing info, whose rendering update end time is the current high resolution time given document’s relevant global object.
</li>
	<li>
%塗られた画像~群 ~LET 新たな`有順序~集合$
◎
Let paintedImages be a new ordered set
</li>
	<li>
%塗られた~text~node群 ~LET 新たな`有順序~集合$
◎
Let paintedTextNodes be a new ordered set
</li>
	<li>
<p>
%文書【！doc】 の`描画~処理待ち画像~群$を成す
~EACH( %記録 )
に対し：
◎
For each record in doc’s images pending rendering list:
</p>
		<ol>
			<li>
<p>
~IF［
%記録 の`要請$piRは`可用$である
【 %記録 の`状態$ ~IN { `完全に可用$st, `部分的に可用$st } 】
］~AND［
塗るために準備済みである
］：
◎
If record’s request is available and ready to be painted, then run the following steps:
</p>
				<ol>
					<li>
%塗られた画像~群 に %記録 を付加する
◎
Append record to paintedImages.
</li>
					<li>
%文書 の`描画~処理待ち画像~群$から %記録 を除去する
◎
Remove record from doc’s images pending rendering list.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%文書 の`子孫$たちを成す
~EACH( `要素$ %要素 )
に対し：
◎
For each Element element in doc’s descendants:
</p>
		<ol>
			<li>
~IF［
%要素 ~IN %文書 の`描画された~textを伴う要素~群$
］
⇒
~CONTINUE
◎
If element is contained in doc’s set of elements with rendered text, continue.
</li>
			<li>
~IF［
%要素 が`所有する~text~node群$は空である
］
⇒
~CONTINUE
◎
If element’s set of owned text nodes is empty, continue.
</li>
			<li>
%文書 の`描画された~textを伴う要素~群$に %要素 を`付加する$set
◎
Append element to doc’s set of elements with rendered text.
</li>
			<li>
%塗られた~text~node群 に %要素 を`付加する$set
◎
Append element to paintedTextNodes.
</li>
		</ol>
	</li>
	<li>
%報告-済み塗り群 ~LET %文書 の`以前に報告した塗り群$
◎
Let reportedPaints be the document’s set of previously reported paints.
</li>
	<li>
%~frame計時~報 ~LET %文書 の`現在の~frame計時~報$doc
◎
Let frameTimingInfo be document’s current frame timing info.
</li>
	<li>
%文書 の`現在の~frame計時~報$doc ~SET ~NULL
◎
Set document’s current frame timing info to null.
</li>
	<li class="algo">
<p>
%塗り計時~群を書出す ~LET 次を遂行する手続き：
◎
Let flushPaintTimings be the following steps:
</p>
		<ol>
			<li>
<p>
~IF［
`first-paint^l ~NIN %報告-済み塗り群
］~AND［
~UAは`最初の塗り$を刻むよう環境設定されている
］
⇒
`塗り計時を報告する$( %文書, `first-paint^l, %塗り計時~報 )
◎
If reportedPaints does not contain "first-paint", and the user agent is configured to mark first paint, then report paint timing given document, "first-paint", and paintTimingInfo.
</p>

<p class="note">注記：
`最初の塗り$には、
既定の背景~塗りは含まれないが，既定でない背景~塗りは含まれる。
◎
NOTE: First paint excludes the default background paint, but includes non-default background paint.
</p>

<p class="issue">
これは、
規範的な注記に転換されるベキである。
◎
This should be turned into a normative note.
</p>
			</li>
			<li>
<p>
~IF［
%文書 は`最初の有内容な塗りを報告するべき$である
］
⇒
`塗り計時を報告する$( %文書, `first-contentful-paint^l, %塗り計時~報 )
◎
If document should report first contentful paint, then:
• Report paint timing given document, "first-contentful-paint", and paintTimingInfo.
</p>

<p class="note">注記：
親~frameと子~iframeは、
互いの塗り~eventに関知するべきでない。
したがって，ある~frameが包含している~iframeは、
~frameに対し（~iframeを封入している~boxがあることに因り）`最初の塗り$は生じさせ得るが，
`最初の有内容な塗り$を生じさせることはない。
◎
NOTE: A parent frame should not be aware of the paint events from its child iframes, and vice versa. This means that a frame that contains just iframes will have first paint (due to the enclosing boxes of the iframes) but no first contentful paint.
</p>

<p class="note">注記：
`文書$が［
`first-paint^l ／ `first-contentful-paint^l
］を刻むことは保証されない。
完全に白紙な`文書$は、
`最初の塗り$を決して刻まないであろう。
`有内容$でない要素しか包含しない`文書$は、
`最初の有内容な塗り$を決して刻まないであろう。
◎
NOTE: A document is not guaranteed to mark "first-paint" or "first-contentful-paint". A completely blank document may never mark first paint, and a document containing only elements that are not contentful may never mark first contentful paint.
</p>

<p class="note">注記：
`最初の塗り$を刻むことは、
任意選択である。
塗り計時を実装している~UAは、
少なくとも，`最初の有内容な塗り$を刻むベキである。
◎
NOTE: The marking of first paint is optional. User-agents implementing paint timing should at the very least mark first contentful paint.
</p>
			</li>
			<li>
`最~大な有内容な塗りを報告する$( %文書, %塗り計時~報, %塗られた画像~群, %塗られた~text~node群 )
◎
Report largest contentful paint given document, paintTimingInfo, paintedImages and paintedTextNodes.
</li>
			<li>
`要素の計時を報告する$( %文書, %塗り計時~報, %塗られた画像~群, %塗られた~text~node群 )
◎
Report element timing given document, paintTimingInfo, paintedImages and paintedTextNodes.
</li>
			<li>
~IF［
%~frame計時~報 ~NEQ ~NULL
］
⇒
`長い~animation~frame~entryを~queueする$( %文書, %~frame計時~報, %塗り計時~報 )
◎
If frameTimingInfo is not null, then queue a long animation frame entry given document, frameTimingInfo, and paintTimingInfo.
</li>
		</ol>
	</li>
	<li>
~IF［
~UAは`実装定義な呈示~時刻$ptIを~supportしない
］
⇒＃
%塗り計時~群を書出す()；
~RET
◎
If the user-agent does not support implementation-defined presentation times, call flushPaintTimings and return.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps In parallel:
</p>
		<ol>
			<li>
実装定義な時刻
— 現在の~frameが利用者へ呈示されるとき —
まで待機する
◎
Wait until an implementation-defined time when the current frame has been presented to the user.
</li>
			<li>
%呈示~時刻 ~LET `現在の高分解能~時刻$( %大域~obj )
◎
Set paintTimingInfo’s implementation-defined presentation time to the current high resolution time given document’s relevant global object.
</li>
			<li>
<p>
~IF［
%文書 の`非同一-生成元~能力は隔離されるか？$enV ~EQ ~F
］：
◎
If document’s cross-origin isolated capability is false, then:
</p>
				<ol>
					<li>
<p>
%呈示~時刻 ~SET %呈示~時刻 を次のように粗化した結果
⇒
~milli秒数で
4 の整数倍になる
— または，それより粗くなる† —
よう切り上げる
</p>

<p class="trans-note">【†
［
4 以上の数
］の整数倍なのか［
4 の倍数
］の整数倍なのか明瞭でない。
】</p>
◎
Coarsen paintTimingInfo’s implementation-defined presentation time to the next multiple of 4 milliseconds, or coarser.
</li>
					<li>
`現在の高分解能~時刻$( %大域~obj ) が %呈示~時刻 になるまで待機する
◎
Wait until the current high resolution time is paintTimingInfo’s implementation-defined presentation time.
</li>
				</ol>
			</li>
			<li>
%塗り計時~報 の`実装定義な呈示~時刻$ptI ~SET %呈示~時刻
◎
↑</li>
			<li>
`大域~taskを~queueする$( `処理能~時列線~task~source$, %大域~obj, %塗り計時~群を書出す )
◎
Queue a global task on the performance timeline task source given document’s relevant global object to run flushPaintTimings.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="report-paint-timing">
<h4 title="Report paint timing">5.3.3. 塗り計時を報告する</h4>

<div class="algo">
<p>
`塗り計時を報告する$ときは、
所与の
( %文書, %塗り種別, `塗り計時~報$ %塗り計時~報 )
に対し，次の手続きを遂行する：
◎
To report paint timing given document, paintType, and a paint timing info paintTimingInfo as arguments, perform the following steps: 
</p>
<ol>
	<li>
%新たな~entry ~LET `新たな~obj$( `PerformancePaintTiming$I, %文書 に`関連な~realm$ )
◎
Create a new PerformancePaintTiming object newEntry with document’s relevant realm and＼
</li>
	<li>
%新たな~entryの
⇒＃
`name$m 属性 ~SET %塗り種別,
`entryType$m 属性 ~SET `paint^l,
`startTime$m 属性 ~SET `既定の塗り時刻印$( %塗り計時~報 ),
`duration$m 属性 ~SET 0
◎
and set its attributes as follows:
• Set newEntry’s name attribute to paintType.
• Set newEntry’s entryType attribute to "paint".
• Set newEntry’s startTime attribute to the default paint timestamp given paintTimingInfo.
• Set newEntry’s duration attribute to 0.
</li>
	<li>
%新たな~entry の`塗り計時~報$ptM ~SET %塗り計時~報
◎
Set newEntry’s paint timing info to paintTimingInfo.
</li>
	<li>
`処理能~entryを~queueする$( %新たな~entry )【！余計：in document’s relevant realm】
◎
Queue newEntry in document’s relevant realm.
</li>
	<li>
%文書 の`以前に報告した塗り群$に %塗り種別 を`付加する$
◎
Append paintType to document’s set of previously reported paints.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="sec-common-algorithms">
<h3 title="Common algorithms">5.4. 共通な~algo</h3>

			<section id="exposed-for-paint-timing">
<h4 data-dfn-type="dfn" data-export="" title="Exposed for paint timing">5.4.1. 塗り計時~用に公開されているか</h4>

<div class="algo">
<p>
所与の`要素$ %要素 は，
所与の`文書$ %文書
— 省略時は %要素 に`関連な設定群~obj$に`関連な大域~obj$に`結付けられた文書$ —
において
`塗り計時~用に公開されて@
いるとは、
~AND↓ が満たされることをいう：
◎
To determine whether an Element element is exposed for paint timing, given a Document or null document, perform the following steps:
</p>
<ul>
	<li>
%要素 は`接続されて$いる
◎
If element is not connected, return false.
◎
↑↑ If document is null, let document be element’s relevant settings object’s relevant global object’s associated document.
</li>
	<li>
%文書 は`全部的に作動中$である
◎
If document is not fully active, return false.
</li>
	<li>
%要素 の`根$ ~EQ %文書
◎
If element’s root is not equal to document, return false.
◎
↑↑ Return true.
</li>
</ul>
</div>

			</section>
		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
技術的な~~意見, 示唆を寄せられ、
この仕様を改善へ導いた`すべての貢献者＠https://github.com/w3c/paint-timing/graphs/contributors$に，特別な謝意を。
◎
Special thanks to all the contributors for their technical input and suggestions that led to improvements to this specification.
</p>

	</section>
</main></div>
