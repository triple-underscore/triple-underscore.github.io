<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Lists and Counters Module Level 3 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>

#counter-nesting-example .ol { background: rgba(0,0,0,.1); margin: .5em 0; padding: .2em .5em; }
#counter-nesting-example .li > .ol { margin: 0 0 0 1em; }
#counter-nesting-example .li { list-style: none; margin-left: 1em;}

pre.ex-rendering {
	padding: 0;
	border: solid silver 1px;
	background: white;
	width: fit-content;
}

.ex-marker-side {
	max-width: 12em;
}
.ex-marker-side > div {
	white-space: nowrap;
}
.ex-marker-side > div > span {
	direction: rtl;
	unicode-bidi: isolate-override;
}


.ex-counter-tree {}

/* force instatiate
.ex-counter-tree::before {
	content: counter(N);
	visibility: hidden;
	display: block;
	height: 0;
}
*/

.ex-counter-tree * {
	display: block;
	border-left: groove #EEE 1em;
}
.ex-counter-tree *::before {
	content: "(" counters(N, ".") ") = ";
	/* display: block; */
	color: red;
}
.ex-counter-tree .x-reset {
	counter-reset: N;
}
.ex-counter-tree .x-increment {
	counter-increment: N;
}
.ex-counter-tree .x-set {
	counter-set: N 10;
}
.ex-counter-tree .x-none {
	display: none;
}
</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	let counter_tree = C('div');
	counter_tree.className = 'ex-counter-tree';
	counter_tree.onclick = populate;

	let counter_prop_flags = 0x3;
	let use_counter_set = C('input');
	use_counter_set.type = 'checkbox';
	use_counter_set.onchange = (e) => {
		counter_prop_flags = e.target.checked ? 0x7 : 0x3;
		// 既定では counter-set (0x4) は除外
		populate();
	};

	let source_data = {
		persisted_parts: {
			'ex-counter-tree': counter_tree,
			'use-counter-set': use_counter_set,
		},
		generate: expand,
		populate: populate,
	};

	Util.switchWordsInit(source_data);

	return;

	function populate(){
		try{
			counter_tree.innerHTML = create_counter_tree(20);
		} catch(e){
			console.log(e.message);
		}
	}

	function create_counter_tree(n){
		// n 個の node からなる tree をランダムに生成
		const tree = [[]]; // tree[0] が root node
		for(let i = 0; i < n; i++ ){ // >
			tree.push(rnd(i));
		}
		for(let i = 1; i < tree.length; i++){ // >
			let node = [];
			tree[tree[i]].push(node);
			tree[i] = node;
		}
		const tree_str = JSON
			.stringify(tree[0])
			.replace(/[^\[\]]/g, '')
			.slice(1,-1)
		; // 出力例：[[[[][[]][[][]][][]]]][[][][]][][[]][[]]

		let node_id = 1; // 現在の node

		const node_stack = []; // root から現在の node までのパス
		const created = []; // counter を作成した，先行する最も近い同胞
		let level = 0; // 現在の tree nesting level
		let none_level = Infinity; // display: none にされた level

		// 入れ子にされた counter の list
		const counters = [];

		function rnd(i){
			return Math.floor(Math.random() * i );
		}

		return tree_str.replace(/[\[\]]/g, (t) => {
			if(t === ']'){
				node_stack.length = level;
				level--;
				if( none_level === level){ none_level = Infinity; }
				return '</div>';
			}

			// inherit counters
			const prev_sibling = node_stack[level] || 0;
			const counter_source = prev_sibling || node_stack[level - 1] || 0
			if(counter_source) {
				for(let i = counters.length - 1; i >= 0; i--){
					if(counter_source >= counters[i].node ) break;
					counters.pop();
				}
			}

			let text = '';
			let classes = [];

			let props = rnd(8) & counter_prop_flags;
			if(node_id === 1){
				props = props | 0x01; // force reset at root
			}
			if(props & 0x1){
				classes.push('reset');
			}
			if(props & 0x2){
				classes.push('increment');
			}
			if(props & 0x4){
				classes.push('set');
			}

			if(level > none_level){
				// descendant of display: none 
			} else if( level > 0 && rnd(7) === 1 ){
				// display: none
				classes.push('none');
				none_level = level;
			} else {
				if( ( counters.length === 0 ) || (props & 0x1) ){
					// instantiate a counter
					if(created[level]){
//	assert: counters.length > 0
//	assert: created[level] === counters[counters.length - 1].node
						counters.pop();
					}
					counters.push({ node: node_id, value: 0 });
					created[level] = node_id;
				}
				const counter = counters[counters.length - 1];
				if(props & 0x1){ // reset
					counter.value = 0x0;
				}
				if(props & 0x2){ // increment
					counter.value += 0x1;
				}
				if(props & 0x4){ // set
					counter.value = 0x0A;
				}
				const values = counters.map(counter => counter.value);
				text = `(${values.join('.')}) ${classes.join(' ')}`;
			}

			node_stack[level] = node_id;
			node_id++;
			level++;
			created[level] = 0;

			let class_str = '';
			if(classes.length > 0){
				class_str = ` class="${classes.join(' ').replace(/\w+/g, 'x-$&')}"`;
			}
			return `\n<div${class_str}>${text}`;
		});
	}
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let context_prop = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);


	function create_html(match, key, indicator, klass){
if(!indicator) {
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	if( indicator === '@') {
		context_prop = `#valdef-${key}-`;
	}
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'tp':
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	klass = 'p';
	break;
case 'vt':
	text = `&lt;${key}&gt;`;
	href = context_prop + key;
	break;
case 'v':
	if(key === 'none') {
		href = context_prop + key;
	}
	break;
case 'f':
	text = `${key}()`;
	break;
case 'item':
	text = `<code class="value">item</code><sub>${key}</sub>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
	break;
case 'issue': // css values
	href = `~CSSissue/${key}`;
	text = `issue#${key}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`
	break;
}


let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2019-08-05
trans_update:2019-08-06
source_checked:190731
page_state_key:CSS
original_url:https://drafts.csswg.org/css-lists-3/
	abbr_url:CSSLIST
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-gnerated,css
conformance:css
copyright:2019,permissive
trans_1st_pub:2019-04-26


●●class_map
r:ref
p:property
d:descriptor
css:css
pe:pseudo
f:func
e:element
a:attr
v:value
v2:value
t:type
vt:type

●●tag_map
p:code
d:code
t:var
vt:var
css:code
pe:code
e:code
a:code
f:code
v:code
v2:code
c:code
i:i
em:em

●●original_id_map


●●link_map

	●prop
p.list-style-image:#propdef-list-style-image
p.list-style-type:#propdef-list-style-type
p.list-style-position:#propdef-list-style-position
p.list-style:#propdef-list-style
p.marker-side:#propdef-marker-side
p.counter-reset:#propdef-counter-reset
p.counter-set:#propdef-counter-set
p.counter-increment:#propdef-counter-increment
p.counter-*:#counter-properties
	~counter~prop:#auto-numbering
p.content:~CSSCONTENT#propdef-content
p.display:~CSSDISP#propdef-display
p.position:~CSSPOS#propdef-position
p.visibility:~CSS2VISUFX#propdef-visibility
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.order:~CSSFLEX#propdef-order

	●疑似要素
pe.marker:~CSSPSEUDO#selectordef-marker
pe.after:~CSSPSEUDO#selectordef-after
pe.before:~CSSPSEUDO#selectordef-before

	●値型
t.counter:#typedef-counter
t.counter-prefix:#typedef-counter-prefix
t.counter-suffix:#typedef-counter-suffix

t.counter-style:~CSSCOUNTER#typedef-counter-style
t.custom-ident:~CSSVAL#identifier-value
t.counter-name:#typedef-counter-name

t.image:~CSSIMAGE#typedef-image
t.integer:~CSSVAL#integer-value
t.string:~CSSVAL#string-value


	vt.image:#valdef-list-style-image-image
	vt.counter-style:#valdef-list-style-type-counter-style
	vt.string:#valdef-list-style-type-string

d.suffix:~CSSCOUNTER#descdef-counter-style-suffix
d.prefix:~CSSCOUNTER#descdef-counter-style-prefix

	●値

v.outside:#list-style-position-outside
v.inside:#valdef-list-style-position-inside
v.list-item:#valdef-counter-increment-list-item
v.list-container:#valdef-marker-side-list-container
v.match-self:#valdef-marker-side-match-self
v.match-parent:#valdef-marker-side-match-parent

	v.none:#valdef-counter-reset-none
	v.none:#valdef-counter-set-counter-increment-none
	<counter-name> <integer>?:#valdef-counter-reset-counter-name-integer
	<counter-name> <integer>?:#valdef-counter-set-counter-increment-counter-name-integer

	v.none:#valdef-list-style-image-none
	v.none:#valdef-list-style-type-none

v2.normal:~CSSCONTENT#valdef-content-normal
v2.none:~CSSCONTENT#valdef-content-none
v2.list-item:~CSSDISP#valdef-display-list-item
v.inline:~CSSDISP#valdef-display-inline
v.visible:~CSSOVERFLOW3#valdef-overflow-visible
	v.none:~CSSDISP#valdef-display-none

v.upper-roman:~CSSCOUNTER#upper-roman
v.lower-alpha:~CSSCOUNTER#lower-alpha
v.decimal:~CSSCOUNTER#decimal


	●func

f.calc:~CSSVAL#funcdef-calc
f.counter:#funcdef-counter
t.counter():#funcdef-counter
f.counters:#funcdef-counters
t.counters():#funcdef-counters
	f.toggle:~CSSVAL#funcdef-toggle

	●要素
e.li:~HEgrouping#the-li-element
e.ol:~HEgrouping#the-ol-element
e.ul:~HEgrouping#the-ul-element
e.option:~HEforms#the-option-element

e.rect:~SVGshapes#elementdef-rect

a.reversed:~HEgrouping#attr-ol-reversed

	●用語
~marker:#marker
~marker~box:#marker
~marker画像:#marker-image
~marker文字列:#marker-string

~list~item:#list-item
~list~item用の既定の増分:#default-list-item-increment
	~list~item:`list-item^v
~counter:#counter
~counter~prop:#counter-properties

~counterを継承する:#inherit-counters
継承-:#inherit-counters
~counterを~instance化する:#instantiate-counter
~instance化:#instantiate-counter

視野:#counter-scope
~counter集合:#css-counters-set
	~CSS~counter集合:#css-counters-set
cT.名前:#_counter-name
cT.出自の要素:#_counter-originating-element
cT.値:#_counter-value
~counter値:#_counter-value
最内縁:#innermost

ex-counter-tree:#ex-counter-tree
use-counter-set:#use-counter-set

	§:#counter-functions
	§:#counter-reset
	§:#counters-without-boxes
	§:#creating-counters
	§:#increment-set
	§:#inheriting-counters
	§:#instantiating-counters
	§:#list-item-counter
	§:#nested-counters

	●用語外部
関数記法:~CSSVAL#functional-notation

行l~box:~CSS2VISUREN#line-box

表示~型:~CSSDISP#display-type
首要~box:~CSSDISP#principal-box
塊~box:~CSSDISP#block-box
塊:~CSSDISP#block
行内:~CSSDISP#inline
行内~level:~CSSDISP#inline-level
行内~始端:~CSSWM#inline-start
行内~box:~CSSDISP#inline-box
匿名:~CSSDISP#anonymous
置換され:~CSSDISP#replaced-element
~text連なり:~CSSDISP#text-run
塊~容器:~CSSDISP#block-container

出自の要素:~SELECTORS4#originating-element

書字mode:~CSSWM#writing-mode

~counter~style:~CSSCOUNTER#counter-style
~counter表現を生成-:~CSSCOUNTER#generate-a-counter
妥当な画像:~CSSIMAGE4#invalid-image
~custom~prop:~CSSVAR#custom-property
無効:~CSSSYN#css-invalid

~cascade法:~CASCADE#cascading
~CSS継承:~CASCADE#inheritance
指定d値:~CASCADE#specified-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value

親:~DOM4#concept-tree-parent
	根~要素:~DOM4#concept-tree-root
~tree順序:~DOM4#concept-tree-order
根:~DOM4#concept-tree-root
前の同胞:~DOM4#concept-tree-previous-sibling

連結する:~INFRA#string-concatenate
有順序~集合:~INFRA#ordered-set
~list:~INFRA#list
~tuple:~INFRA#tuple
文字列:~INFRA#string
包含する:~INFRA#list-contain
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append
除去する:~INFRA#list-remove
連結する:~INFRA#string-concatenate


●●words_table1

HTMLSEMANTICS:https://html.spec.whatwg.org/multipage/semantics.html

none0:none

●●words_table

	●構造
逆順の:reversed:~
出自の:originating:~
深さ:depth:~
	深さ:deep
最内縁:innermost::~
平坦:flat::~
	平坦~化された flattened

	後続する:following
	先行する:earlier
	同じ名前の~counterを入子に:self-nesting
	直前:immediately
	~instance化:instantiation
	~instance化:instantiate

	~~階層的:tiered
	子たち:children
	~self-nesting:self-nesting
	-:sort
	-:outermost
	-:outermost-first
	-:joined
	-:collection

	●counter／marker
丸括弧:parentheses:~
交替的:alternate:~
付番-:number:~
付番:numbering:~
	付番された:numbered
増分:increment:~
増減-:increment:~
	incrementing
	増やされ:increaseする
	減らして:count down
丸:circle:~
加算-:add:~
	操作-法:manipulating
	生成-法:generating
序数:ordinal::~
bullet::::ビュレット
marker::::マーカ
記号:symbol::~
変形:transform::~
	多段に:stacking up
挿入点:insertion point:~
	数える:count
数量的:numerical:~
数量-:numeric:~
追跡子:tracker:~
切詰める:clampする:切り詰める
連続な:consecutiveな:連続する
連続的:consecutive:~

	出る:push the value outside of
	~list~item:`list-item^v

	●layout
浮動体:float::~
	表示~型:display type
位置決め:positioning::~
始端:start::~
終端:end::~
整列-:align::~
整列:alignment::~
包装-:wrap::~
	包装する要素:wrapper element around
首要:principal::主要
書字mode:writing mode::書字 mode:書字モード
側:side:~
側溝:gutter:~
埋めら:fillさ:~
埋める:fillする:~
連なり:run::~
	置く:lie
	固定され:fixed with respect to

	●塗り／描画／呈示
見出し:heading:~
ベタ:filled:~
印刷ng:printing:印刷
塗ng:painting::塗り
隠す:hideする:~
隠して:hideして:~
	“星印”:"star" character

	●構文
	宣言-法:declaring
最大:maximum:~
最小:minimum:~
space::::スペース

	●CSS
CSS-2:CSS2
関数記法:functional notation:~
詳細度:specificity::~
	~cascade法:cascading
	~style付け:styling
	継承されない:Non-inherited
	継承-法:inheriting

	●仕様
冗長:verbose:~
適度:reasonable:~
復帰させ:revertする:~
指名:designate:~
許容:allowance:~
規定-:dictate:~
尊重-:respect:~
確約-:assure:~
前処理器:preprocessor::~::プリプロセッサ
慣行:conventions:~
文書化-:document:~
文書化:documentation:~
類似な:similarな:~
不可能:impossible:~
不用意:inadvertent:~
無条件:unconditional:~

	省略されたもの:omissions
	役立った:useful
	似た:similar
	よく似る:very similar
	うのみに書き写しただけ:handwavey nonsense
	真の:real な
	方々:people
	今日では:today
	別法もある:Alternatively, 〜 could
	ごく:very
	ちょっとぶかっこう:*little bit* clumsy
	いくつか明確化-:made some clarifications
	~~課された:inflict
	課す:imply
	応じて:depend
	変えない:remain unchanged
	-:notation
	-:Alternately
	注意:care
	:come
	表す／表記-:denote
	示す:illustrate
	なり得る:potentially
	~note
	~~切る:turn off
	手による:wrote
	面倒を見る:takes care of
	限られて:limit
	整備-:tightened up
	書き直し:rewrote
	築き上げ:built up
	助けになる:help
	取り込:pull
	-:method
	欠く:lack of
	気にかける:worry
	-:involve
	-:prevent
	-:turn into
	-:turns 〜 into
	-:possibly
	少し:bit
	作者:one
	など:such as 〜 etc
	ちょうど:exactly
	付与され:mention
	記して:write
	関しては:respect
	同様:like
	用を:address

	●未分類
連結-:concatenate:~
方向性:directionality:~
素の:plainな:~
隠蔽-:obscure:~

	揃う:line up
	揃う:align
	変わる:vary
	設定しておく:set up
	操作-:set, reset, or increment
	記され:referred
	複数~段を経て:multi-step
	開始~tag:start tag
	属-:belong

	●指示語

	現時点:currently
	章:chapter
	現れる:appear
	少し:bit
	後の:later
	真の:real
	次:next
	様々な:various
	三行:3 lines
	複数の／複数個:multiple
	全体を通して:throughout
	~CSSの中でも:among other things
	主な:main
	~~先行する／以前の／前にある:previous
	助:help
	単に:simply
	-:outside
	一定:fixed
	大部分:most
	直:immediate
	先頭:beginning
	直前の:immediately preceding
	一体としての:as a whole
	一連の:successive／in sequence
	より新たな:newer
	旧:old
	いない部分がある:fully
	ほぼ:mostly
	個別:individual
	先頭に:prefixed
	末尾に:followed
	と同時に:at the same time
	時点で:at the same time
	同時に:and
	両側に／-:around
	~~地点:spot
	方の:whichever of
	-:sort
	それを作成した:creator
	同じ名前の:identically-named
	-:starting
	最後に:latest
	先行する
	遭遇-:encounter:~
	~~累積される:increments will compound
</pre>

	●counter
	-:immediately set
	-:fragment
	-:existing
	呈示-:produce

●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-CONTENT-3]
    Elika Etemad; Dave Cramer. CSS Generated Content Module Level 3. 2 August 2019. WD. URL: https://www.w3.org/TR/css-content-3/ 
[CSS-COUNTER-STYLES-3]
    Tab Atkins Jr.. CSS Counter Styles Level 3. 14 December 2017. CR. URL: https://www.w3.org/TR/css-counter-styles-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 11 July 2019. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. CSS Flexible Box Layout Module Level 1. 19 November 2018. CR. URL: https://www.w3.org/TR/css-flexbox-1/ 
[CSS-IMAGES-4]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Image Values and Replaced Content Module Level 4. 13 April 2017. WD. URL: https://www.w3.org/TR/css-images-4/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 31 July 2018. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 25 February 2019. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 
[SVG2]
    Amelia Bellamy-Royds; et al. Scalable Vector Graphics (SVG) 2. 4 October 2018. CR. URL: https://www.w3.org/TR/SVG2/ 

●●
ref_informative


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-lists-3/ 
以前のバージョン
	https://www.w3.org/TR/2019/WD-css-lists-3-20190425/ 
	https://www.w3.org/TR/2014/WD-css-lists-3-20140320/ 
	https://www.w3.org/TR/2011/WD-css3-lists-20110524/ 

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-lists-3">GitHub Issues</a>
編集
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="http://xanthir.com/contact/">Tab Atkins</a> (Google)

前任編集者
	<a href="mailto:ian@hixie.ch">Ian Hickson</a> (Google)
	<a href="mailto:tantekc@microsoft.com">Tantek Çelı̇k</a> (Formerly of Microsoft)

Suggest an Edit for this Spec:
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-lists-3/Overview.bs">GitHub Editor</a>

貢献者
	Simon Montagu, AOL-TW/Netscape, <a href="mailto:smontagu@netscape.com">smontagu@netscape.com</a>
	Daniel Yacob, <a href="mailto:yacob@geez.org">yacob@geez.org</a>
	Christopher Hoess, <a href="mailto:choess@stwing.upenn.edu">choess@stwing.upenn.edu</a>
	Daniel Glazman, AOL-TW/Netscape, <a href="mailto:glazman@netscape.com">glazman@netscape.com</a>


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Lists and Counters Module Level 3</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS Lists and Counters Module Level 3</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~moduleは、~list~counterに関係する~CSS特能
— それらの~style付け, 位置決め, 値の操作-法 —
を包含する。
◎
This module contains CSS features related to list counters: styling them, positioning them, and manipulating their value.
</p>

~CSSisaLANG

	</section>
	<section id="status">
~STATUSofTHIS

<p>
これは編集者草案の公の複製です…
【以下，この節の他の内容は<a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>／冒頭の仕様メタデータに委譲】
</p>
	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<div class="p">
<p>
この仕様は、次のものを定義する：
</p>
<ul>
	<li>
`marker$pe 疑似要素。
</li>
	<li>
~markerを生成するための`表示~型$ `list-item$v2 。
</li>
	<li>
~markerの配置と~style付けを制御するためのいくつかの~prop。
</li>
</ul>

◎
This specification defines the ::marker pseudo-element, the list-item display type that generates markers, and several properties controlling the placement and styling of markers.
</div>

<p>
また、`~counter$も定義する。
それは、特別な数量的~objであり，~markerの既定の内容を生成するために利用されることが多い。
◎
It also defines counters, which are special numerical objects often used to generate the default contents of markers.
</p>

<div class="example">
<p>
付番された各~list~itemに対し、~marker（ `marker$pe ）を利用して，両側に丸括弧を追加する方法を，次に例示する：
◎
For instance, the following example illustrates how markers can be used to add parentheses around each numbered list item:
</p>

<pre class="lang-html">
&lt;style&gt;
li::marker { content: "(" counter(list-item, lower-roman) ")"; }
li { display: list-item; }
&lt;/style&gt;
&lt;ol&gt;
  &lt;li&gt;これは一個目の~item。
  &lt;li&gt;これは二個目の~item。
  &lt;li&gt;これは三個目の~item。
&lt;/ol&gt;
</pre>
<!-- 
  &lt;li&gt;This is the first item.
  &lt;li&gt;This is the second item.
  &lt;li&gt;This is the third item.
-->
<p>
これは、次の様に呈示されるべきである：
◎
It should produce something like this:
</p>

<pre class="ex-rendering">
  (i) これは一個目の~item。
 (ii) これは二個目の~item。
(iii) これは三個目の~item。
</pre>

<p class="note">注記：
この例は、~HTMLにて通例的に必要とされるものより ずっと冗長である
— ~UAの既定の~stylesheetは，必要とされる~style付けの大部分について面倒を見るので。
◎
Note: Note that this example is far more verbose than is usually needed in HTML, as the UA default style sheet takes care of most of the necessary styling.
</p>

</div>

<p>
子孫~選択子と子~選択子を用いれば、~listが埋込まれた深さに応じて，異なる型の~markerを指定することもアリになる。
◎
With descendant selectors and child selectors, it’s possible to specify different marker types depending on the depth of embedded lists.
</p>

	</section>
	<section id="declaring-a-list-item">
<h2 title="Declaring a List Item">2. ~list~itemの宣言-法</h2>

<p>
`~list~item@
とは、 `display$p ~propが `list-item$v2 に設定された要素である。
各`~list~item$は、他の要素にはない `marker$pe 疑似要素を生成する。
加えて，`~list~item$は、暗黙の名前 `list-item$v の`~counter$を自動的に増減する（増やす／減らす
<a href="#list-item-counter">§ 暗黙的な `list-item^v ~counter</a>
を見よ）。
◎
A list item is any element with its display property set to list-item. List items generate ::marker pseudo-elements; no other elements do. Additionally, list items automatically increment an implied list-item counter (see § 4.6 The Implicit list-item Counter).
</p>

	</section>
	<section id="markers">
<h2 title="Markers">3. ~marker</h2>

<p>
`~marker@
（~marker~box）は、`~list~item$`表示~型$を定義する特能であり、~list内の各 `~list~item$の先頭を表す助けになる記号や序数を与える。
~CSS~layout~modelにおいては、`~marker$は，各`~list~item$に結付けられた`~marker~box$により表現される。
この`~marker$の内容は、当の`~list~item$上の［
`list-style-type$p, `list-style-image$p
］~propで, および
`marker$pe 疑似要素に【適用-可能な】各種~propをアテガうことにより，制御できる。
◎
The defining feature of the list item display type is its marker, a symbol or ordinal that helps denote the beginning of each list item in a list. In the CSS layout model, list item markers are represented by a marker box associated with each list item. The contents of this marker can be controlled with the list-style-type and list-style-image properties on the list item and by assigning properties to its ::marker pseudo-element.
</p>

		<section id="marker-pseudo">
<h3 title="The ::marker Pseudo-Element">3.1. `marker^pe 疑似要素</h3>

<p>
`~marker~box$は、`~list~item$の `marker$pe 疑似要素により，`~list~item$の最初の子として生成される
— 要素~上に `before$pe 疑似要素も存在するならば，その前に。
それは、
<a href="#content-property">§ ~marker内容の生成-法</a>
にて定義されるように内容で埋められる。
◎
The marker box is generated by the ::marker pseudo-element of a list item as the list item’s first child, before the ::before pseudo-element (if it exists on the element). It is filled with content as defined in § 3.2 Generating Marker Contents.
</p>

<p>
`~marker$は、`~list~item$用に限り存在する。
他の要素~上では、 `marker$pe 疑似要素の `content$p ~propは `none$v2 に算出されるモノトスル
— それは、~markerの作成を抑止する。
◎
Marker boxes only exist for list items: on any other element, the ::marker pseudo-element’s content property must compute to none, which suppresses its creation.
</p>

<p>
`marker$pe 疑似要素に利用できる~propは限られている
— この~listは、 `CSS-PSEUDO-4$r の
<a href="~CSSPSEUDO#marker-pseudo">§ ~list~marker</a>
にて定義される。
◎
Only a limited set of properties can be used on the ::marker pseudo-element. This list is defined in CSS Pseudo-Elements 4 §4.2 List Markers: the ::marker pseudo-element.
</p>

<div class="example">
<p>
この例では、~markerを利用して，
“Note” と指名されている段落を付番する：
◎
In this example, markers are used to number paragraphs that are designated as "notes":
</p>

<pre class="lang-css">
&lt;style&gt;
p { margin-left: 12 em; }
p.note {
  display: list-item;
  counter-increment: note-counter;
}
p.note::marker {
  content: "Note " counter(note-counter) ":";
}
&lt;/style&gt;
&lt;p&gt;これは文書~内の最初の段落。
&lt;p class="note"&gt;これはとても短い段落。
&lt;p&gt;ここが末尾。
</pre>

<!-- 
<p>This is the first paragraph in this document.
<p class="note">This is a very short document.
<p>This is the end.
-->
<p>
次の様に描画されるべきである：
◎
It should render something like this:
</p>

<pre class="ex-rendering">
          これは文書~内の最初の段落。

Note 1:   これはとても短い段落。

          ここが末尾。
</pre>

</div>

<div class="example">
<p>
`marker$pe 疑似要素を利用すれば、~listの~markerを~list~item自身の~textとは独立に~styleできる：
◎
By using the ::marker pseudo-element, a list’s markers can be styled independently from the text of the list item itself:
</p>

<pre class="lang-html">
&lt;style&gt;
p { margin-left: 8em } /* <span class="comment">
~counter用に空間を作る
◎
Make space for counters
</span> */
li { list-style-type: lower-roman; }
li::marker { color: blue; font-weight:bold; }
&lt;/style&gt;
&lt;p&gt;これは先行する長い段落 ...
&lt;ol&gt;
  &lt;li&gt;これは一個目の~item
  &lt;li&gt;これは二個目の~item
  &lt;li&gt;これは三個目の~item
&lt;/ol&gt;
&lt;p&gt;これは後続する長い段落 ...
</pre>
<!-- 
<p>This is a long preceding paragraph ...
<li>This is the first item.
<li>This is the second item.
<li>This is the third item.
<p>This is a long following paragraph ...
-->
<p>
前掲の文書は、次の様に描画されるべきである：
◎
The preceding document should render something like this:
</p>

<pre class="ex-rendering">
       これは先行する長い段落 ...

  <span style="color:blue;font-weight:bold;">i.</span>   これは一個目の~item
 <span style="color:blue;font-weight:bold;">ii.</span>   これは二個目の~item
<span style="color:blue;font-weight:bold;">iii.</span>   これは三個目の~item

       これは後続する長い段落 ...
</pre>

<p>
以前までは、~markerを~styleする仕方は，継承を通す他になかった。
欲される~marker~styleを~list~itemにあてがった上で、~list~itemの実際の内容を要素で包装して，その要素~上で~~元の~styleに復帰させる必要があった。
◎
Previously the only way to style a marker was through inheritance; one had to put the desired marker styling on the list item, and then revert that on a wrapper element around the list item’s actual contents.
</p>

</div>

		</section>
		<section id="content-property">
<h3 title="Generating Marker Contents">3.2. ~marker内容の生成-法</h3>

<p>
`~marker~box$の内容は、次に挙げる条件のうち最初に満たされるものにより決定される：
◎
The contents of a marker box are determined by the first of these conditions that is true:
</p>

<dl class="switch">
	<dt>
`marker$pe 自身の `content$p は `normal$v2 でない場合：
◎
content on the ::marker itself is not normal
</dt>
	<dd>
内容は
— `before$pe に対するとき正確に同じに —
`content$p ~propに定義されるように決定される。
◎
The contents of the marker box are determined as defined by the content property, exactly as for ::before.
</dd>

	<dt>
`出自の要素$上の `list-style-image$p が`~marker画像$を定義する場合：
◎
list-style-image on the originating element defines a marker image
</dt>
	<dd>
<p>
内容は、次の順の並びからなる：
</p>
		<ul>
			<li>
指定された`~marker画像$を表現している，`匿名$かつ`行内$の`置換され$る要素
</li>
			<li>
1 個の~space（
<span class="code-point">U+0020</span> <span class="cp-name">SPACE</span>
）のみからなる`~text連なり$
</li>
		</ul>
◎
The 'marker box contains an anonymous inline replaced element representing the specified marker image, followed by a text run consisting of a single space (U+0020 SPACE).
</dd>

	<dt>
`出自の要素$上の `list-style-type$p が`~marker文字列$を定義する場合：
◎
list-style-type on the originating element defines a marker string
</dt>
	<dd>
内容は、指定された`~marker文字列$からなる`~text連なり$になる。
◎
The marker box contains a text run consisting of the specified marker string.
</dd>

	<dt>
他の場合：
◎
otherwise
</dt>
	<dd>
内容は無い
— `marker$pe は~boxを生成しない。
◎
The marker box has no contents and ::marker does not generate a box.
</dd>
</dl>

		</section>
		<section id="image-markers">
<h3 title="Image Markers: the list-style-image property">3.3. 画像~marker： `list-style-image^p ~prop</h3>

◎名 `list-style-image@p
◎値 `image$vt | `none$v
◎初 `none^v
◎適 `~list~item$
◎継 される
◎百 受容しない
◎算 ~keyword `none$v ／算出d `image$t
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`~marker画像@
を指定する。
それは、`~list~item$の`~marker$を埋めるときに
— ~list~itemの `content$p が `normal$v2 のときに限り —
利用される。
各種 値は、次に従う：
◎
Specifies the marker image, which is used to fill the list item’s marker when its content is normal. The values are as follows:
</p>

<dl class="valdef">
	<dt id="valdef-list-style-image-image">`image$t</dt>
	<dd>
`image$t が`妥当な画像$を表現する場合、それが要素の`~marker画像$を指定する。
他の場合、要素には`~marker画像$は無い。
◎
If the &lt;image&gt; represents a valid image, specifies the element’s marker image as the &lt;image&gt;. Otherwise, the element has no marker image.
</dd>

	<dt>`none@v</dt>
	<dd>
要素には`~marker画像$は無い。
◎
The element has no marker image.
</dd>
</dl>

<div class="example">
<p>
各~list~itemの先頭に，画像 "`ellipse.png^c" による~markerを設定する例：
◎
The following example sets the marker at the beginning of each list item to be the image "ellipse.png".
</p>

<pre class="lang-css">
li { list-style-image: url("http://www.example.com/ellipse.png") }
</pre>

</div>
		</section>
		<section id="text-markers">
<h3 title="Text-based Markers: the list-style-type property">3.4. ~textに基づく~marker： `list-style-type^p ~prop</h3>

◎名 `list-style-type@p
◎値 `counter-style$vt | `string$vt | `none$v
◎初 `disc^v
◎適 `~list~item$
◎継 される
◎百 受容しない
◎算 指定d値
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`~marker文字列@
を指定する。
それは、`~list~item$の`~marker$を埋めるときに
— ~list~itemの `content$p が `normal$v2 , かつ`~marker画像$は無いときに限り —
利用される。
各種 値は、次に従う：
◎
Specifies the marker string, which is used to fill the list item’s marker when its content value is normal and there is no marker image. The values are as follows:
</p>

<dl class="valdef">
	<dt id="valdef-list-style-type-counter-style">`counter-style$t</dt>
	<dd>
要素の`~marker文字列$を［
指定された `counter-style$t を利用して表現される `list-item$v ~counterの値
］として指定する
◎
Specifies the element’s marker string as the value of the list-item counter represented using the specified &lt;counter-style&gt;.
</dd>
	<dd>
特定的には，`~marker文字列$は、［
指定された `counter-style$t を利用して
`list-item$v ~counter値~用の`~counter表現を生成-$した結果
］の先頭に `counter-style$t の `prefix$d を,
末尾に `counter-style$t の `suffix$d を付け加えたものになる。
指定された `counter-style$t が存在しない場合、 `decimal$v と見做される。
◎
Specifically, the marker string is the result of generating a counter representation of the list-item counter value using the specified &lt;counter-style&gt;, prefixed by the prefix of the &lt;counter-style&gt;, and followed by the suffix of the &lt;counter-style&gt;. If the specified &lt;counter-style&gt; does not exist, decimal is assumed.
</dd>

	<dt id="valdef-list-style-type-string">`string$t</dt>
	<dd>
要素の`~marker文字列$は、指定された `string$t になる。
◎
The element’s marker string is the specified &lt;string&gt;.
</dd>

	<dt>`none@v</dt>
	<dd>
要素には`~marker文字列$は無い。
◎
The element has no marker string.
</dd>
</dl>

<div class="example">
<p>
~markerを様々な値に設定する方法を，次の例に示す：
◎
The following examples illustrate how to set markers to various values:
</p>

<pre class="lang-css">
ul { list-style-type: "★"; }
/* <span class="comment">
~markerを “星印” に設定する
◎
Sets the marker to a "star" character
</span> */

p.note {
  display: list-item;
  list-style-type: "注記：";
  list-style-position: inside;
}
/* <span class="comment">
注記~段落に，文字列 "注記：" による~markerを与える
◎
Gives note paragraphs a marker consisting of the string "Note: "
</span> */

ol { list-style-type: upper-roman; }
/* <span class="comment">
すべての有順序~listは、`~counter~style$として `upper-roman$v を利用するよう設定する
`CSS-COUNTER-STYLES$r 
◎
Sets all ordered lists to use the upper-roman counter-style (defined in the Counter Styles specification [[CSS-COUNTER-STYLES]])
</span> */

ul { list-style-type: symbols(cyclic '○' '●'); }
/* <span class="comment">
すべての無順序~list~itemの~markerに［
~~中空の丸, ベタの丸
］を交替的に設定する。
◎
Sets all unordered list items to alternate between empty and filled circles for their markers.
</span> */

ul { list-style-type: none; }
/* <span class="comment">
~markerをまるごと抑止する
— `list-style-image^p に`妥当な画像$が指定されていない限り。
◎
Suppresses the marker entirely, unless list-style-image is specified with a valid image.
</span> */
</pre>

</div>

		</section>
		<section id="list-style-position-property">
<h3 title="Positioning Markers: The list-style-position property">3.5. ~markerの位置決め： `list-style-position^p ~prop</h3>

◎名 `list-style-position@p
◎値 `inside$v | `outside$v
◎初 `outside$v
◎適 `~list~item$
◎継 される
◎百 受容しない
◎算 指定された~keyword（ただし注釈文を見よ）
◎順 文法に従う
◎ア 離散的
◎表終

<p>
この~propは、［
`marker$pe を行内に描画するか，`~list~item$のすぐ外側に位置するか
］を規定する。
各種 値は、次に従う：
◎
This property dictates whether the ::marker is rendered inline, or positioned just outside of the list item. The values are as follows:
</p>

<dl class="valdef">
	<dt>`inside@v</dt>
	<dd>
特別な効果はない（ `marker$pe は、`~list~item$の内容の始端にある行内~要素になる）。
◎
No special effect. (The ::marker is an inline element at the start of the list item’s contents.) 
</dd>

	<dt>`outside@v</dt>
	<dd>
`~list~item$は`塊~容器$である場合：
~marker~boxは、`塊~box$を成す`首要~box$の外側に置かれる。
しかしながら，浮動体に隣接する~list~item~markerの位置は、定義されない。
~CSSは、~marker~boxの［
精確な所在 ／ 塗ng順序
］は指定しないが、［［
`marker-side$p が指示する~box
］の`書字mode$を利用して，~boxの`行内~始端$側に配置する
］ことを要求する。
~marker~boxは、`首要~box$の~borderに固定され，首要~boxの内容ともに~scrollすることはない。
~UAは、当の要素の `overflow$p が `visible$v 以外ならば，~markerを隠してもヨイ（この許容は、将来に変更され得る）。
~marker~boxの~sizeや内容は、［
`首要~box$や その最初の`行l~box$
］の縦幅に影響したり，一部の事例では新たな行l~boxを作成させることもある
— この相互作用もまた、定義されない。
◎
If the list item is a block container: the marker box is outside the principal block box; however, the position of the list-item marker adjacent to floats is undefined. CSS does not specify the precise location of the marker box or its position in the painting order, but does require that it be placed on the inline-start side of the box, using the writing mode of the box indicated by marker-side. The marker box is fixed with respect to the principal block box’s border and does not scroll with the principal box’s content. A UA may hide the marker if the element’s overflow is other than visible. (This allowance may change in the future.) The size or contents of the marker box may affect the height of the principal block box and/or the height of its first line box, and in some cases may cause the creation of a new line box; this interaction is also not defined.
</dd>
	<dd class="issue">
これは，~CSS-2をうのみに書き写しただけであり、真の定義が必要である。
◎
This is handwavey nonsense from CSS2, and needs a real definition.
</dd>
	<dd>
`~list~item$は`行内~box$である場合：
この値は `inside$v と等価になる。
◎
If the list item is an inline box: this value is equivalent to inside.
</dd>
	<dd class="issue">
別法として、~markerを，行内~boxを成す首要~boxの前にある同胞として~lay-outする~~案もある。
◎
Alternatively, outside could lay out the marker as a previous sibling of the principal inline box.
</dd>
</dl>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-html">
&lt;style&gt;
  ul.compact { list-style: inside; }
  ul         { list-style: outside; }
&lt;/style&gt;
&lt;ul class=compact&gt;
  &lt;li&gt;一個目の "inside" ~list~item
  &lt;li&gt;二個目の "inside" ~list~item
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
  &lt;li&gt;一個目の "outside" ~list~item
  &lt;li&gt;二個目の "outside" ~list~item
&lt;/ul&gt;
</pre>
<!-- 
<ul class=compact>
  <li>first "inside" list item comes first
  <li>second "inside" list item comes first
</ul>
<hr>
<ul>
  <li>first "outside" list item comes first
  <li>second "outside" list item comes first
</ul>
-->

<p>
上の例は、次のように整形されるであろう：
◎
The above example may be formatted as:
</p>

<pre class="ex-rendering">
  * 一個目の "inside" ~list~item
  * 二個目の "inside" ~list~item

========================

* 一個目の "outside" ~list~item
* 二個目の "outside" ~list~item
</pre>

<!-- 
  * first "inside" list
  item comes first
  * second "inside" list
  item comes second

========================

* first "outside" list
  item comes first
* second "outside" list
  item comes second
  -->
</div>

		</section>
		<section id="list-style-property">
<h3 title="Styling Markers: the list-style shorthand property">3.6. ~markerの~style付け： `list-style^p 略式~prop</h3>

◎名 `list-style@p
◎値
`list-style-position$tp || `list-style-image$tp || `list-style-type$tp
◎初 個々の~propを見よ
◎適 `~list~item$
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 個々の~propを見よ
◎表終

<p>
`list-style$p ~propは、 3 種の~prop［
`list-style-type$p,
`list-style-image$p,
`list-style-position$p
］を，~stylesheetの同じ所でまとめて設定する略式である。
◎
The list-style property is a shorthand notation for setting the three properties list-style-type, list-style-image, and list-style-position at the same place in the style sheet.
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-css">
UL { list-style: upper-roman inside }  /* <span class="comment">
すべての `UL^e
◎
Any UL
</span> */
UL UL { list-style: circle outside } /* <span class="comment">
`UL^e の子孫である，すべての `UL^e
◎
Any UL child of a UL
</span> */
</pre>
   </div>

<p>
略式における値 `none^v の利用は、多義的にもなり得る
— `none^v は、 `list-style-image$p, `list-style-type$p どちらにも妥当な値なので。
この多義性を解決するため、略式における値 `none^v は，［
2 つの~propのうち，この略式で `none^v 以外が設定されていない方の~prop
］に適用するモノトスル。
◎
Using a value of none in the shorthand is potentially ambiguous, as none is a valid value for both list-style-image and list-style-type. To resolve this ambiguity, a value of none in the shorthand must be applied to whichever of the two properties aren’t otherwise set by the shorthand.
</p>

<div class="example">

<pre class="lang-css">
list-style: none disc;
/* <span class="comment">
画像を `none^v, 型を `disc^v に設定する。
◎
Sets the image to "none" and the type to "disc".
</span> */

list-style: none url(bullet.png);
/* <span class="comment">
画像を `url(bullet.png)^v, 型を `none^v に設定する。
◎
Sets the image to "url(bullet.png)" and the type to "none".
</span> */

list-style: none;
/* <span class="comment">
画像, 型の両方とも `none^v に設定する。
◎
Sets both image and type to "none".
</span> */

list-style: none disc url(bullet.png);
/* <span class="comment">
構文~error
◎
Syntax error
</span> */
</pre>
   </div>

<div class="example">
<p>
作者は、~list~item要素（例：~HTMLにおける `li$e ）に `list-style$p 情報を直に指定できるが、そうするときは注意するべきである。
次の規則を考える：
◎
Although authors may specify list-style information directly on list item elements (e.g., li in HTML), they should do so with care. Consider the following rules:
</p>

<pre class="lang-css">
ol.alpha li { list-style: lower-alpha; }
ul li       { list-style: disc; }
</pre>

<p>
上の規則は、期待されるように働かない。
`ul$e を
`ol class=alpha^e
の中に入子にした場合、最初の規則の詳細度が高いので，
`ul$e の各~list~itemは `lower-alpha^v ~styleを利用するようになる。
次のようにすれば、意図されるように働く：
◎
The above won’t work as expected. If you nest a ul into an ol class=alpha, the first rule’s specificity will make the ul’s list items use the lower-alpha style.
</p>

<pre class="lang-css">
ol.alpha &gt; li { list-style: lower-alpha; }
ul &gt; li       { list-style: disc; }
</pre>

<p>
次のようにすれば、もっと良く働く：
◎
These work as intended.
</p>

<pre class="lang-css">
ol.alpha { list-style: lower-alpha; }
ul       { list-style: disc; }
</pre>

<p>
これらの `list-style$p 値は、継承により，~list~itemたちへ転送されることになるので。
◎
These are even better, since inheritance will transfer the list-style value to the list items.
</p>

</div>

		</section>
		<section id="marker-side">
<h3 title="The marker-side property">3.7. `marker-side^p ~prop</h3>

◎名 `marker-side@p
◎値 `match-self$v | `match-parent$v
◎初 `match-self^v
◎適 `~list~item$
◎継 される
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`marker-side$p ~propは、 `marker$pe が［
~list~item自身（すなわち，`出自の要素$）, ~list容器（すなわち，`出自の要素$の親）
］どちらの方向性に基づいて位置するかを指定する。
前者の事例では、~markerの位置は，同じ~list内の各~list~itemごとに個別にアテガわれた方向性に基づいて変わり得る。
後者の事例では、一体としての~listにアテガわれた方向性により決定され，すべての~itemは同じ側に整列することになる。
◎
The marker-side property specifies whether the ::marker is positioned based on the directionality of the list item itself (i.e. its originating element) or the directionality of the list container (i.e. the originating element’s parent). In the first case, the position of the marker can vary across items in the same list, based on the directionality assigned to each list item individually; in the second case they will all align on the same side, as determined by the directionality assigned to the list as a whole.
</p>

<dl class="valdef">
	<dt>`match-self@v</dt>
	<dd>
`marker$pe 疑似要素は、その`出自の要素$の方向性を利用して位置される。
◎
The ::marker pseudo-element is positioned using the directionality of the ::marker’s originating element. 
</dd>

	<dt>`match-parent@v</dt>
	<dd>
`marker$pe 疑似要素は、その`出自の要素$の親~要素の方向性を利用して位置される。
◎
The ::marker pseudo-element is positioned using the directionality of the ::marker’s originating element’s parent element.
</dd>
</dl>

<div class="example">

<p>
［
要素 ／ `marker$pe 疑似要素
］は、既定では，その~list~itemの方向性に則って自身を位置する。
しかしながら，同じ~group内の~list~itemたちの方向性がまちまちな場合（例えば、~HTMLの `ol^e 内に 異なる `dir^a 属性~値を伴う複数個の `li^e がある場合）、すべての~markerを同じ側に整列した方が有用なこともある
— 作者が、すべての~markerが置かれる “側溝” をその側に作るよう指定することで、~markerが可視になるのを確約できるよう。
◎
By default, elements or ::marker pseudo-elements position themselves according to their list item’s directionality. However, if the list item is grouped with several other list items which may have different directionality (for example, multiple &lt;li&gt;s with different "dir" attributes in an &lt;ol&gt; in HTML), it is sometimes more useful to have all the markers line up on one side, so the author can specify a single "gutter" on that side and be assured that all the markers will lie in that gutter and be visible.
</p>

<p>
下に示す両~描画とも，次の~HTML例から生成されているが、~list上の `marker-side$p 値に限り相違がある：
◎
Both of the following example renderings are generated from the following HTML, with the only difference being the value of marker-side on the list:
</p>

<pre class="lang-html">
&lt;ul&gt;
  &lt;li&gt;左横書きの内容
  &lt;li&gt;&lt;bdo dir="rtl"&gt;右横書きの内容&lt;/bdo&gt;
  &lt;li&gt;左横書きの内容
  &lt;li&gt;&lt;bdo dir="rtl"&gt;右横書きの内容&lt;/bdo&gt;
&lt;/ul&gt;
</pre>
<!-- 
<ul>
  <li>english one
  <li dir=rtl>OWT WERBEH
  <li>english three
  <li dir=rtl>RUOF WERBEH
</ul>
-->
<table class="data">
<thead><tr><th>`match-self$v
</th><th>`match-parent$v
</th></tr></thead><tbody>
<tr>
<td style="border-right: thin solid">

<figure><div class="ex-marker-side">
<div>• 左横書きの内容</div>
<div>　　　　<bdo dir="rtl">右横書きの内容</bdo> •</div>
<div>• 左横書きの内容</div>
<div>　　　　<bdo dir="rtl">右横書きの内容</bdo> •</div>
</div></figure>

<!-- 
<pre class="ex-rendering">
* english one
     OWT WERBEH *
* english three
    RUOF WERBEH *</pre>
 -->

</td><td>

<figure><div class="ex-marker-side">
<div>• 左横書きの内容</div>
<div>•　　　　<bdo dir="rtl">右横書きの内容</bdo></div>
<div>• 左横書きの内容</div>
<div>•　　　　<bdo dir="rtl">右横書きの内容</bdo></div>
</div></figure>

<!-- 

<pre class="ex-rendering">
* english one
*    OWT WERBEH
* english three
*   RUOF WERBEH</pre>
 -->

</tbody></table>

</div>

		</section>
	</section>
	<section id="auto-numbering">
<h2 title="Automatic Numbering With Counters">4. ~counterによる自動的な付番</h2>

<p>
`~counter@
は、~CSSの中でも特別な数量-追跡子であり，~CSSにおいて~list~itemを自動的に付番するときに利用される。
どの要素にも 0 個以上の~counterがあり、文書~treeを通して，~prop値が継承されるのと類似な仕方で継承される。
各~counterには，［
それを作成した要素, 名前
【`出自の要素$cT, `名前$cT】
］があり、個々の~counterは それらにより識別される。
また、要素ごとに整数~値をとる。
それらは、各種
`~counter~prop@
— `counter-increment$p, `counter-set$p, `counter-reset$p —
で作成され，操作される。
その結果は、［
`counter$f ／ `counters$f
］`関数記法$から利用される。
◎
A counter is a special numeric tracker used, among other things, to automatically number list items in CSS. Every element has a collection of zero or more counters, which are inherited through the document tree in a way similar to inherited property values. Counters have a name and creator element, which identify the counter, and an integer value per element. They are created and manipulated with the counter properties counter-increment, counter-set and counter-reset, and used with the counter() and counters() functional notations.
</p>

<p>
~counterは、~CSS構文においては
`counter-name@t
型として記され，その名前を `custom-ident$t として表現する。
`counter-name$t は、~keyword `none^v には合致し得ない
— そのような識別子は、 `counter-name$t としては`無効$になる。
◎
Counters are referred to in CSS syntax using the &lt;counter-name&gt; type, which represents their name as a &lt;custom-ident&gt;. A &lt;counter-name&gt; name cannot match the keyword none; such an identifier is invalid as a &lt;counter-name&gt;.
</p>

<p>
所与の要素~上の`~counter$の値は、複数~段を経て解決される：
◎
Resolving counter values on a given element is a multi-step process:
</p>

<ol>
	<li>
~~先行する要素から既存の`~counterを継承する$。
◎
Existing counters are inherited from previous elements.
</li>
	<li>
新たな`~counterを~instance化する$（ `counter-reset$p ）。
◎
New counters are instantiated (counter-reset).
</li>
	<li>
`~counter値$を増減する（ `counter-increment$p ）。
◎
Counter values are incremented (counter-increment).
</li>
	<li>
`~counter値$を明示的に設定する（ `counter-set$p ）。
◎
Counter values are explicitly set (counter-set).
</li>
	<li>
`~counter値$を利用する（ `counter$f ／ `counters$f ）。
◎
Counter values are used (counter()/counters()).
</li>
</ol>

<p>
~UAは、`~counter値$を，実装に特有な［
最大／最小
］で制限してもヨイ。
`~counter$が［
`~instance化$／増減-／設定-
【！reset／set／increment】
］されて，値がこの範囲から出た場合、この範囲に切詰めるモノトスル。
◎
UAs may have implementation-specific limits on the maximum or minimum value of a counter. If a counter reset, set, or increment would push the value outside of that range, the value must be clamped to that range.
</p>

<p class="trans-note">【
明示的に述べられていないが，この節における “要素” は、一般に［
`before^pe ／ `after^pe
］疑似要素も含む。
】</p>

		<section id="counter-reset">
<h3 title="Creating Counters: the counter-reset property">4.1. ~counterの作成-法： `counter-reset^p ~prop</h3>

◎名 `counter-reset@p
◎値 [ `counter-name$t `integer$t? ]+ | `none$v
◎初 `none$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算
~keyword `none^v ／
各~itemが識別子と整数の~pairである~list
◎
the keyword none or a list, each item an identifier paired with an integer
◎順 文法に従う
◎ア 算出された値~型による
◎表終

<p class="all-media">
~UAには、視覚的でないものも含む すべての媒体に対し，この~propを~supportすることが期待される。
◎
User Agents are expected to support this property on all media, including non-visual ones.
</p>

<p>
`counter-reset$p ~propは、要素~上で新たな`~counter$（たち）を`~instance化$して，指定された整数~値に設定する。
値は、次に従って定義される：
◎
The counter-reset property instantiates new counters on an element and sets them to the specified integer values. Its values are defined as follows:
</p>

<dl class="valdef">
	<dt>`none@v</dt>
	<dd>
要素は、新たな~counterを作成しない。
◎
This element does not create any new counters.
</dd>

	<dt id="valdef-counter-reset-counter-name-integer">`counter-name$t `integer$t?</dt>
	<dd>
所与の
( `counter-name$t, `integer$t )
を
( `名前$cT, `値$cT )
に伴う`~counterを~instance化する$。
`integer$t が省略された場合の既定の~counter値は `0^v になるとする。
◎
Instantiates a counter of the given &lt;counter-name&gt; with a starting value of the given &lt;integer&gt;, defaulting to 0.
</dd>
</dl>

<div class="example">

<p>
`~counter~prop$は、`~cascade法$による規則に通常通り従うことに注意。
したがって、例えば次の~stylesheetは：
◎
Note that counter properties follow the cascading rules as normal. Thus, due to cascading, the following style sheet:
</p>

<pre class="lang-css">
h1 { counter-reset: section -1 }
h1 { counter-reset: imagenum 99 }
</pre>

<p>
`imagenum^v のみを設定し直すことになる。
両~counterとも設定し直すためには、一緒に指定される必要がある：
◎
will only reset imagenum. To reset both counters, they have to be specified together:
</p>

<pre class="lang-css">
H1 { counter-reset: section -1 imagenum 99 }
</pre>

<p>
同じ原則は［
`counter-set$p ／ `counter-increment$p
］~propにも適用される。
`css-cascade-4$r を見よ。
◎
The same principles apply to the counter-set and counter-increment properties. See [css-cascade-4].
</p>

</div>

<p>
`counter-reset$p の値に同じ `counter-name$t が複数回~生じた場合、最後のもののみ尊守される。
◎
If multiple instances of the same &lt;counter-name&gt; occur in the property value, only the last one is honored.
</p>

		</section>
		<section id="increment-set">
<h3 title="Manipulating Counter Values: the counter-increment and counter-set properties">4.2. ~counter値の操作-法： `counter-increment^p, `counter-set^p ~prop</h3>

◎名 `counter-increment@p, `counter-set@p
◎表終

<p>
他の欄は、 `counter-set$p と同じ【なので、この訳では省略する】。
◎
Name: 	counter-increment
Value: 	[ &lt;counter-name&gt; &lt;integer&gt;? ]+ | none
Initial: 	none
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	the keyword none or a list, each item an identifier paired with an integer
Canonical order: 	per grammar
Animation type: 	by computed value type
◎
User Agents are expected to support this property on all media, including non-visual ones.
◎
Name: 	counter-set
Value: 	[ &lt;counter-name&gt; &lt;integer&gt;? ]+ | none
Initial: 	none
Applies to: 	all elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	the keyword none or a list, each item an identifier paired with an integer
Canonical order: 	per grammar
Animation type: 	by computed value type
</p>

<p class="all-media">
~UAには、視覚的でないものも含む すべての媒体に対し，これらの~propを~supportすることが期待される。
◎
User Agents are expected to support this property on all media, including non-visual ones. 
</p>

<p>
［
`counter-increment$p ／ `counter-set$p
］~propは、既存の`~counter$（たち）の値を操作する。
それに先立って、要素~上に所与の`名前$cTの~counterが無い場合に限り，その名前の`~counterを~instance化する$。
値は、次に従って定義される：
◎
The counter-increment and counter-set properties manipulate the value of existing counters. They only instantiate new counters if there is no counter of the given name on the element yet. Their values are defined as follows:
</p>

<dl class="valdef">
	<dt id="valdef-counter-set-counter-increment-none">`none^v</dt>
	<dd>
要素は、どの~counterの値も改めない。
◎
This element does not alter the value of any counters.
</dd>

	<dt id="valdef-counter-set-counter-increment-counter-name-integer">`counter-name$t `integer$t?</dt>
	<dd>
要素~上の`名前$cT `counter-name$t の~counterの値を［
`counter-set$p の場合は 指定された `integer$t に設定する ／
`counter-increment$p の場合は 指定された `integer$t で増減する
］。
`integer$t が省略された場合の既定は、［
`counter-increment^p 用には `1^v ／
`counter-set^p 用には `0^v
］になるとする。
◎
Sets (for counter-set) or increments (for counter-increment) the value of the named counter on the element to/by the specified &lt;integer&gt;. If the &lt;integer&gt; is omitted, it defaults to 1 (for counter-increment) or 0 (for counter-set).
</dd>
	<dd>
要素~上に所与の名前の~counterが無い場合、~counterの値を［
設定する／増減する
］に先立って，新たな`~counterを~instance化する$( その名前, 要素, 0 ) 。
◎
If there is not currently a counter of the given name on the element, the element instantiates a new counter of the given name with a starting value of 0 before setting or incrementing its value.
</dd>
</dl>

<div class="example">

<p>
次の例に、各 章／節を
"第 1 章. ", "1.1 節. ", "1.2 節. ",
等々のように付番する仕方を示す。
◎
This example shows a way to number chapters and sections with "Chapter 1", "1.1", "1.2", etc.
</p>

<pre class="lang-css">
h1::before {
    content: "第 " counter(章) " 章. ";
    counter-increment: 章;  /* <span class="comment">
章 に 1 を加算する
◎
Add 1 to chapter
</span> */
    counter-reset: 節;      /* <span class="comment">
節 を 0 に設定する
◎
Set section to 0
</span> */
}
h2::before {
    content: counter(章) "." counter(節) " 節. ";
    counter-increment: 節;
}
</pre>
</div>

<p>
~propの値に同じ `counter-name$t が複数回~生じた場合、それらは，現れた順に処理される
— すなわち
⇒＃
`counter-increment$p に対しては，~~累積される／
`counter-set$p に対しては，最後のもののみが効果を発揮する
◎
If multiple instances of the same &lt;counter-name&gt; occur in the property value, they are all processed, in order. Thus increments will compound, but only the last set value will take effect.
</p>

		</section>
		<section id="nested-counters">
<h3 title="Nested Counters and Scope">4.3. 入子の~counterと視野</h3>

<p>
~counterは、同じ名前の~counterを入子にし得る。
ある要素~上で新たな`~counterを~instance化する$とき，要素が同じ名前の`~counter$を親から継承している場合には、その名前の新たな~counterを作成して，既存の~counterの内側に入子にする。
これは、~HTMLにおける~listの様な状況~用に重要になる。
~listは他の~listたちを任意な深さまで入子にし得るので、各~level間で名前が一意な~counterを定義するのは不可能になる。
`counter$f 関数は，［
要素の【`~counter集合$内で】所与の`名前$cTを伴う~counter
］のうち`最内縁$なものだけ検索取得する一方で、
`counters$f 関数は，それらすべてを利用する。
【！that contain the element】
◎
Counters are “self-nesting”; instantiating a new counter on an element which inherited an identically-named counter from its parent creates a new counter of the same name, nested inside the existing counter. This is important for situations like lists in HTML, where lists can be nested inside lists to arbitrary depth: it would be impossible to define uniquely named counters for each level. The counter() function only retrieves the innermost counter of a given name on the element, whereas the counters() function uses all counters of a given name that contain the element.
</p>

<p>
したがって，所与の`~counter$の
`視野@
は、その~counterを最初に`~instance化$した要素【すなわち，`出自の要素$cT】から開始し，その［
子孫, 後続する同胞たち, それらの子孫
］を含むが、［
後続する同胞~上の `counter-reset$p により作成された，同じ名前を伴う~counter
］の視野に入る要素は含まない
— そのように明示的に`~counterを~instance化する$ことで、先行する同胞の~counterを隠蔽できることになる。
◎
The scope of a counter therefore starts at the first element in the document that instantiates that counter and includes the element’s descendants and its following siblings with their descendants. However, it does not include any elements in the scope of a counter with the same name created by a counter-reset on a later sibling of the element, allowing such explicit counter instantiations to obscure those earlier siblings.
</p>

<p>
各~counterとその値の視野を統治する正確な規則については、
<a href="#creating-counters">§ ~counterの作成-法と継承-法</a>
を見よ。
◎
See § 4.4 Creating and Inheriting Counters for the exact rules governing the scope of counters and their values.
</p>

<div class="example" id="counter-nesting-example">

<p>
次の~codeは、入子の~list~itemたちを付番する。
その結果は、［
`li$e 要素~上に
<code class="css">`display^p: `list-item^v; `list-style$p: `inside^v</code>
を設定したとき
］の付番とよく似る：
◎
The following code numbers nested list items. The result is very similar to that of setting display:list-item and list-style: inside on the LI element:
</p>

<pre class="lang-css">
ol { counter-reset: item }
li { display: block }
li::before { content: counter(item) ". "; counter-increment: item }
</pre>

<p>
この例では、各 `ol$e は~counterを作成し， `ol^e のすべての子は その~counterを指すことになる。
◎
In this example, an ol will create a counter, and all children of the ol will refer to that counter.
</p>

<p>
%n 番目（ 0 から数える）に`~instance化$される名前 `item^v の~counterを
`<var>n</var>^item
と表記するならば、次の~HTML片は，各箇所に指示される~counterを利用することになる。
◎
If we denote the nth instance of the item counter by itemn, then the following HTML fragment will use the indicated counters.
</p>

<div>
 <div class="ol">`ol^e `0^item が作成され, 0 に設定される
  <div class="li">`li^e `0^item は 1 に増やされる</div>
  <div class="li">`li^e `0^item は 2 に増やされる
   <div class="ol">`ol^e `1^item が作成され, 0 に設定され, `0^item 内に入子にされる
    <div class="li">`li^e `1^item は 1 に増やされる</div>
    <div class="li">`li^e `1^item は 2 に増やされる</div>
    <div class="li">`li^e `1^item は 3 に増やされる
     <div class="ol">`ol^e `2^item が作成され, 0 に設定され, `1^item 内に入子にされる
      <div class="li">`li^e `2^item は 1 に増やされる</div>
     `/ol^e
     </div>
    </div>
    <div class="li">`li^e `1^item は 4 に増やされる
     <div class="ol">`ol^e `3^item が作成され, 0 に設定される, `1^item 内に入子にされる
      <div class="li">`li^e `3^item は 1 に増やされる</div>
     `/ol^e
     </div>
    </div>
    <div class="li">`li^e `1^item は 5 に増やされる</div>
   `/ol^e
   </div>
  </div>
  <div class="li">`li^e `0^item は 3 に増やされる</div>
  <div class="li">`li^e `0^item は 4 に増やされる</div>
 `/ol^e
 </div>
 <div class="ol">`ol^e `4^item が作成され, 0 に設定される
  <div class="li">`li^e `4^item は 1 に増やされる</div>
  <div class="li">`li^e `4^item は 2 に増やされる</div>
 `/ol^e
 </div>
</div>

<!-- 

&lt;ol&gt; item0 is created, set to 0
&lt;li&gt; item0 is incremented to 1
&lt;li&gt; item0 is incremented to 2
&lt;ol&gt; item1 is created, set to 0, nested in item0
&lt;li&gt; item1 is incremented to 1
&lt;li&gt; item1 is incremented to 2
&lt;li&gt; item1 is incremented to 3
&lt;ol&gt; item2 is created, set to 0, nested in item1
&lt;li&gt; item2 is incremented to 1
&lt;/ol&gt;
&lt;li&gt; item1 is incremented to 4
&lt;ol&gt; item3 is created, set to 0, nested in item1
&lt;li&gt; item3 is incremented to 1
&lt;/ol&gt;
&lt;li&gt; item1 is incremented to 5
&lt;/ol&gt;
&lt;li&gt; item0 is incremented to 3
&lt;li&gt; item0 is incremented to 4
&lt;/ol&gt;
&lt;ol&gt; item4 is created, set to 0
&lt;li&gt; item4 is incremented to 1
&lt;li&gt; item4 is incremented to 2
&lt;/ol&gt;

-->

</div>

		</section>
		<section id="creating-counters">
<h3 title="Creating and Inheriting Counters">4.4. ~counterの作成-法と継承-法</h3>

<p class="trans-note">【
この節に定義される~modelにおいては、［
`before^pe ／ `after^pe
］疑似要素は，その`出自の要素$の［
最初の子／最後の子
］であると見做す必要があると思われる。
（~counterは~box~tree上で演算するべきとも示唆されている： `674$issue ）
】</p>

<p>
文書~内の各［
要素／疑似要素
］は
— 先行する要素から継承するか, 要素~上で直に~instance化することを通して —
その要素を`視野$に入れる`~counter$の集合を持つ（空にもなり得る）。
これらの~counterは、`有順序~集合$†を成す
`~counter集合@
（ `CSS counters set^en ）として表現される。
この集合を成す各~itemは、
( `文字列$, 要素, 整数 )
からなる`~tuple$であり，~counterの
( 
`名前@cT,
`出自の要素@cT,
`値@cT
)
を順に表現する。
所与の名前 %N に対し，この集合~内の~itemのうち［
`名前$cT ~EQ %N
］を満たす最後のものが，名前 %N の
`最内縁@
な~counterを表現する。
◎
Each element or pseudo-element in a document has a (possibly empty) set of counters in the scope of that element, either through inheritance from another element or through instantiation on the element directly. These counters are represented as a CSS counters set, which is a set whose values are each a tuple of: a string (representing a counter’s name), an element (representing the counter’s originating element), and an integer (representing the counter’s value). The latest counter of a given name in that set represents the innermost counter of that name.
</p>

<p class="trans-note">【†
同等性の検査を要する箇所は無いので`~list$でも十分になる（各~itemは，常に別の個を成す
— それらの同等性が~tupleを成す成分ごとの比較に基づくわけではない）。
】</p>

			<section id="inheriting-counters">
<h4 title="Inheriting Counters">4.4.1. ~counterの継承-法</h4>

<p>
要素は、自身の初期~counter集合を，［
要素に`前の同胞$が在るならば それ ／
無いならば 要素の親
］から`継承-$する。
次に，それらの~counter用の値を［
`~tree順序$で要素の直前の要素（前述の要素か，前の同胞の子孫）
］上の，名前が合致している~counterから値を得る。
◎
An element inherits its initial set of counters from its preceding sibling, or from its parent if it has none. It then takes the values for those counters from the values of the matching counters on its preceding element in tree order (which might be its parent, its preceding sibling, or a descendant of its previous sibling).＼
</p>

<div class="algorithm">

<p>
所与の %要素 の中へ
`~counterを継承する@
ときは：
◎
To inherit counters into an element:
</p>

<ol>
	<li>
%要素 の`~counter集合$ ~SET 新たな`有順序~集合$
◎
Let element counters be an initially empty CSS counters set representing element’s own CSS counters set.
</li>
	<li>
~IF［
%要素 は`~tree順序$で最初の要素である
］
⇒
~RET
（ %要素 は根~要素であり，何も継承しないので、`~counter集合$は空になる）
◎
If element is the root of its document tree, return. (The element has an initially-empty counter map and inherits nothing.)
</li>
	<li>
%~counter~source ~LET ［
%要素 の`前の同胞$ ~NEQ ~NULL ならば それ／
~ELSE_ %要素 の`親$
］の`~counter集合$
◎
Let counter source be the CSS counters set of element’s preceding sibling, if it has one, or else of element’s parent if it does not.
</li>
	<li>
%値~source ~LET ［
`~tree順序$で %要素 の直前の要素
］の`~counter集合$
◎
Let value source be the CSS counters set of the element immediately preceding element in tree order.
</li>
	<li>
%値~source を成す
~EACH( `~counter$ %~counter )
に対し
⇒
~IF［
%~counter~source 内に［［
`名前$cT, `出自の要素$cT
］とも %~counter のそれらに一致する`~counter$は在る
］
⇒
%要素 の`~counter集合$に %~counter の複製を`付加する$set
◎
For each (name, originating element, value) of value source:
• If counter source also contains a counter with the same name and originating element, then append a copy of value source’s counter (name, originating element, value) to element counters.
</li>
</ol>
</div>

<div class="example" id="counter-inheritance-example">
<p>
例として，次の~codeを~~考える：
◎
Take the following code as an example:
</p>

<pre>
&lt;ul style="counter-reset: example 0;"&gt;
  &lt;li id="`foo^css" style="counter-increment: example;"&gt;
    foo
    &lt;div id="`bar^css" style="counter-increment: example;"&gt;bar&lt;/div&gt;
  &lt;/li&gt;
  &lt;li id="`baz^css"&gt;
    baz
  &lt;/li&gt;
&lt;/ul&gt;
</pre>

<!-- 
転換-:turn into
~come
~next
読取る:readする:~
遭遇-:encounter:~
~recall
`~tree順序$は文書~treeを有順序~listに転換する。
そこでは、要素は自身の子より前に, 子は次の同胞より前に来る。
言い換えれば，~HTMLの様な言語において、その構文解析器が文書を読取るに伴い開始~tagに遭遇する順序になる。
-->

<p>
ここでは、
`ul$e 要素 %ul は，名前 `example^v を伴う新たな~counterを確立してから，その値を 0 に設定する。
要素 `#foo^css は、%ul の最初の子なので， %ul の~counterを継承する。
`~tree順序$で直前にある要素も %ul なので、~counterの値として %ul のそれ（ 0 ）を同時に継承し，その値を即時に増減する結果、値は 1 になる。
◎
Recall that tree order turns a document tree into an ordered list, where an element comes before its children, and its children come before its next sibling. In other words, for a language like HTML, it’s the order in which the parser encounters start tags as it reads the document.
◎
In here, the ul element establishes a new counter named example, and sets its value to 0. The #foo element, being the first child of the ul, inherits this counter. Its parent is also its immediately preceding element in tree order, so it inherits the value 0 with it, and then immediately increments the value to 1.
</p>

<p>
同じことは、要素 `#bar^css にも起こる。
`#bar^css は、 `#foo^css から名前 `example^v ~counterを継承すると同時に，値 1 も継承して、それを増減する結果、値は 2 になる。。
◎
The same happens with the #bar element. It inherits the example counter from #foo, and inherits the value 1 from it as well and increments it to 2.
</p>

<p>
しかしながら，要素 `#baz^css は少し異なる。
それは、名前 `example^v の~counterを前の同胞 `#foo^css から継承するが、値は，
`#foo^css からは継承せず，`~tree順序$で直前の要素である `#bar^css から継承する。
◎
However, the #baz element is a bit different. It inherits the example counter from the #foo element, its previous sibling. However, rather than inheriting the value 1 from #foo along with the counter, in inherits the value 2 from #bar, the previous element in tree order.
</p>

<p>
この挙動により、作者は，単独の~counterを［
文書~全体を通して，継続的に増減する
］ために利用できるようになる
— 入子にされた文書~構造について気にかけることなく。
◎
This behavior allows a single counter to be used throughout a document, continuously incrementing, without the author having to worry about the nested structure of their document.
</p>

</div>

<p class="note">注記：
~counterの継承は、定例の`~CSS継承$の様に，
`DOM$r の文脈における
“平坦~化された要素~tree”
【<a href="~CSSSCOPING#flat-tree">参照</a>】
に対し演算する。
◎
Note: Counter inheritance, like regular CSS inheritance, operates on the “flattened element tree” in the context of the [DOM].
</p>

			</section>
			<section id="instantiating-counters">
<h4 title="Instantiating Counters">4.4.2. ~counterの~instance化</h4>

<div class="p">
<p>
所与の`名前$cTを伴う`~counter$は、次のいずれかに該当する要素~上で`~instance化$される：
</p>

<ul>
	<li>
`counter-reset$p にて，その名前が与えられている。
</li>
	<li>
［
`counter-increment$p ／ `counter-set$p
］~propにて, あるいは［
`counter$f ／ `counters$f
］関数記法にて，その名前が与えられたが、当の要素~上に，その名前の~counterは無いとき。
</li>
</ul>

<p>
（新たに`~instance化$された`~counter$は、［
`名前$cTが一致する, かつ先行する同胞を`出自の要素$とする`~counter$
］を置換する（もし在れば）一方で、［
`名前$cTが一致する, かつ先祖~要素を`出自の要素$とする`~counter$
］に加えて追加される（もし在れば）。
<a href="#nested-counters">§ 入子の~counterと視野</a>
を見よ。）
</p>

<p class="trans-note">【
すべての要素の`~counter集合$を成す~itemのうち，同じ［
`名前$cT, `出自の要素$cT
］を共有するものが成す集合が， 1 つの［
~counterの~instance
］
— 言い換えれば， 1 つの`視野$ —
を形成する。
】</p>

◎
Counters are instantiated when named in counter-reset, and also when not otherwise present if named in counter-increment, counter-set, or the counter() or counters() notations. (Newly instantiated counters replace identically-named counters originating from previous siblings, but are added in addition to identically-named counters originating from ancestor elements, see § 4.3 Nested Counters and Scope.)＼
</div>

<div class="algorithm">
<p>
`~counterを~instance化する@
ときは、所与の
( %名前, %要素, %値 )
に対し：
◎
To instantiate a counter of a given name on an element with a starting value:
</p>

<ol>
	<li>
%~counter集合 ~LET %要素 の`~counter集合$
◎
Let counters be element’s CSS counters set.
</li>
	<li>
%最内縁な~counter ~LET %~counter集合 内の`名前$cT %名前 を伴う`最内縁$な~counter
◎
Let innermost counter be the last counter in counters with the name name.＼
</li>
	<li>
~IF［
%最内縁な~counter の`出自の要素$cTは %要素 に先行するある同胞である
【！ a previous sibling = one of preceding siblings ≠ the previous sibling 】
【すなわち，その同胞がこの~counterを`~instance化$した】
］
⇒
%~counter集合 から %最内縁な~counter を`除去する$
◎
If innermost counter’s originating element is element or a previous sibling of element, remove innermost counter from counters.
</li>
	<li>
%~counter集合 に
新たな`~counter$( %名前, %要素, %値 )
を`付加する$set
◎
Append a new counter to counters with name name, originating element element, and initial value value
</li>
</ol>

</div>

			</section>
			<section id="_live-example-of-counters">
<h4>4.4.X. ~counterの生きた例</h4>

<p class="trans-note">【
この節は、この訳による追加。
】</p>

<div class="example">

<p>
次の図式に、この仕様の~algoを要素~treeに適用して生成される，ある固定的な`名前$cTを伴う~counterの挙動を示す（図式のどこでも，~clickすれば、~tree構造をランダムに組み替えれる）：
</p>

<p>
（ <label>`use-counter-set@ `counter-set^p も利用する場合はチェック</label>）
</p>

`ex-counter-tree@


<p>
この図式の呈示には、次の~styleが利用されている（
`#root^css は容器の id ／
%N は~counterの名前
）：
</p>

<pre class="lang-css">
#root * {
  display: block;
  border-left: groove #EEE 1em; /* 入子ng深さを表す “字下げ” */
}
#root *::before {
  content: "(" counters(%N, ".") ") = ";
  color: red;
}
#root *.reset     { counter-reset: %N; }
#root *.increment { counter-increment: %N; }
#root *.set       { counter-set: %N 10; }
</pre>

<p>
この図式の見方は：
</p>

<ul>
	<li>
図式を成す各~行が 1 個の子孫に対応し，入子ng~levelに応じて字下げされている。
</li>
	<li>
行頭に赤く呈示される括弧で括られた整数~列は，
`counters$f 関数の出力であり、利用-中の~UAが実際に要素にあてがっている，~counter値の~list
— 要素の`~counter集合$内の，名前 %N を伴う~counterたちの`値$cTからなる同順の~list —
を反映する。
</li>
	<li>
その次に “=” を挟んで示される，括弧で括られた整数~列は、この仕様の~modelから導出される，~counter値の~listを表す。
~UAの実装が~modelに正確に従うならば、前項の整数~列とこの整数~列は，一致するはずである。
</li>
	<li>
<p>
行末に示される文字列［
"reset" ／ "increment" ／ "set"
］は、同じ名前の~class名を通して，当の要素に`名前$cT %N を伴う~counterを操作する［
`counter-reset$p ／ `counter-increment$p ／ `counter-set$p
］~propがあてがわれていることを表す
⇒＃
`counter-reset$p が設定する値は、常に 0 （既定~値）／
`counter-increment$p による増減は、常に 1 （既定~値）
`counter-set$p が設定する値は、常に 10
</p>

<p>
ただし，既定では、 `counter-set$p は利用されない
— 現時点では、~supportする~UAが限られているので（図式~直前のチェックボックスで切り替えられる）。
</p>
	</li>
</ul>

<p>
最初の子~要素には、常に `counter-reset$p が設定される
— 呈示に利用している［
`before^pe 疑似要素~上の `couters^f 関数
］の~~存在による，暗黙的な`~instance化$の副作用により、挙動が不規則な見かけになるのを避けるため。
</p>

</div>

			</section>
		</section>
		<section id="counters-without-boxes">
<h3 title="Counters in elements that do not generate boxes">4.5. ~boxを生成しない要素における~counter</h3>

<p>
~boxを生成しない要素（例：
`display$p が
<a href="~CSSDISP#valdef-display-none">`none^v</a>
に設定された要素 ／
`content$p が `none$v2 に設定された疑似要素）は、`~counter$を操作できない
— `~counter~prop$は、そのような要素でも依然として妥当であるが，それらによる効果はないモノトスル。
◎
An element that does not generate a box (for example, an element with display set to none, or a pseudo-element with content set to none) cannot set, reset, or increment a counter. The counter properties are still valid on such an element, but they must have no effect.
</p>

<div class="example">
<p>
例えば次の~stylesheetでは、 `secret^css ~classのどの `h2^e も， `count2^v を増減しなくなる。
◎
For example, with the following style sheet, H2s with class "secret" do not increment count2.
</p>

<pre class="lang-css">
h2 { counter-increment: count2; }
h2.secret { display: none; }
</pre>

</div>

<p>
`visibility$p を `hidden^v に設定するなどの，要素を “隠す” だけのものは、要素に~boxを生成させるので，このことは適用されない。
◎
Other methods of “hiding” elements, such as setting visibility to hidden, still cause the element to generate a box, and so do not apply here.
</p>

<p>
`置換され$る子孫（例： ~HTMLの `option$e ／ ~SVGの `rect$e ）が~counterを操作できるかどうかは、未定義である。
【！set, reset, or increment】
］
◎
Whether a replaced element’s descendants (such as HTML option, or SVG rect) can set, reset, or increment a counter is undefined.
</p>

<p class="note">注記：
`置換され$る子孫~要素の挙動は、各~実装~間の相互運用能を欠くことに因り，現時点では未定義である。
◎
Note: The behavior on replaced element descendants is currently undefined due to a lack of interoperability across implementations.
</p>

		</section>
		<section id="list-item-counter">
<h3 title="The Implicit list-item Counter">4.6. 暗黙的な `list-item^v ~counter</h3>

<p>
作者が~style内に明示的に記して定義された`~counter$に加えて、`~list~item$は，特別な
`list-item@v
~counter
— `名前$cT `list-item^v を伴う`~counter$ —
を自動的に増分する。
それは、`~list~item$上の既定の`~marker文字列$を生成するために利用される（ `list-style-type$p を見よ）。
◎
In addition to any explicitly defined counters that authors write in their styles, list items automatically increment a special list-item counter, which is used when generating the default marker string on list items (see list-style-type).
</p>

<p>
特定的には
— `counter-increment$p ~propにて， `list-item$v ~counter用に異なる増分が明示的に指定されない限り —
各`~list~item$ごとに，`~counter$が通常に増分される時点で，
`~list~item用の既定の増分@
（既定では 1 になる）だけ増分されるモノトスル（ちょうど，`~list~item$の `counter-increment$p の値に `list-item 1^v が付加されていたかのように
— 場合によっては、新たな`~counter$を`~instance化$するなどの副作用も伴う）。
これは、 `counter-increment$p の［
`指定d値$／`算出d値$
］には影響しない。
◎
Specifically, unless the counter-increment property explicitly specifies a different increment for the list-item counter, it must be incremented by the default list-item increment (which is 1 by default) on every list item, at the same time that counters are normally incremented (exactly as if the list item had list-item 1 appended to their counter-increment value, including side-effects such as possibly instantiating a new counter, etc). This does not affect the specified or computed values of counter-increment.
</p>

<p>
~host言語の意味論は、この自動的な~counter増分に異なる値を課し得る。
その事例では、`~list~item用の既定の増分$が，それを反映するモノトスル。
（例えば，~HTMLにおいては、 `ol$e 要素が `reversed$a 属性を有する場合には，その~list上の `list-item$v ~counterを代わりに`減らしていく^emことを課すので、そのような~list内の `li$e 用の`~list~item用の既定の増分$は −1 になる。
<a href="#ua-stylesheet">§ ~HTML用の見本~stylesheet</a>
【！#ua-stylsheet】
を見よ。
◎
The host language’s semantics can imply different values for this automatic counter-increment. In that case, the default list-item increment must instead reflect the host language’s semantics. (For example, in HTML &lt;ol reversed&gt; implies that list-item counts down on that list, so the default list-item increment is -1 for lis in such lists. See, e.g. .
</p>

<div class="example">

<p>
各`~list~item$は，`list-item$v ~counterを自動的に 1 ずつ増分するので、連続な［
数量- `list-style-type$p を伴う【すなわち， `counter-style$t が指定されている】`~list~item$
］たちは，既定では連続的に付番されることになる
— 作者が `counter-increment$p に `list-item^v を設定していなくても，あるいは `none^v を設定していようが。
【！another value = `list-item^v 以外】
これは、他の`名前$cTの~counter用を意図した宣言が，【 `list-item^v を欠くことにより】自動的な `list-item^v ~counterを不用意に上書きしないよう保護する。
◎
Because each list item automatically increments the list-item counter by 1, consecutive list items with a numeric list-style-type will be consecutively numbered by default—even if the author sets counter-increment to another value such as counter-increment: itemnumber or even none. This protects the automatic list-item counter from inadvertently being overridden by declarations intended to address other counters.
</p>

<p>
しかしながら，この `list-item$v に対する自動的な増分は、当の`~list~item$上の `counter-increment$p に `list-item$v が明示的に付与されている場合には，`起こらない^emので、例えば
<code class="css">li { `counter-increment^p: `list-item 2^v; }</code>
は，指定されたとおり `list-item^v を 2 だけ増分することになる
— 無条件に `list-item 1^v を付加したとするときの 3 ではなく。
◎
However, since the automatic list-item increment does not happen if the list item’s counter-increment explicitly mentions the list-item counter, li { counter-increment: list-item 2; } will increment list-item by 2 as specified, not by 3 as would happen if list-item 1 were unconditionally appended.
</p>

<p>
これにより、 `list-item$v ~counterの自動的な増分を切ることも可能になる
—
<code class="css">`counter-increment$p: `list-item 0^v;</code>
のように明示的に上書きして。
◎
This also allows to turn off the automatic list-item counter increment, by overriding it explicitly, e.g. counter-increment: list-item 0;.
</p>
</div>

<p>
他のすべてに関しては、 `list-item$v `~counter$は，他の`~counter$と同様に挙動する。
作者は、その~styleを調整する その他の目的に，`~list~item$を利用したり操作できる。
◎
In all other respects, the list-item counter behaves like any other counter and can be used and manipulated by authors to adjust list item styling or for other purposes.
</p>

<div class="example">

<p>
次の例では、~listは 2 ずつ数えるよう改変されている：
◎
In the following example, the list is modified to count by twos:
</p>

<pre class="lang-css">
ol.evens > li { counter-increment: list-item 2; }
</pre>

<p>
~listが 3 個の~itemからなるなら、次のように描画されることになる：
◎
A three-item list would be rendered as
</p>

<pre class="ex-rendering">
2. 一個目の~item
4. 二個目の~item
6. 三個目の~item
</pre>
<!-- 
2. First Item
4. Second Item
6. Third Item
 -->
</div>

<div class="example">

<p>
次の例では、 `content$p ~propを利用して `list-item$v ~counterの中へ~hookする~~階層的な付番を作成する
— したがって~HTMLを通して~~課された付番~変更
【すなわち， `value^a, `start^a, `reversed^a 属性】
があれば それを尊重する：
◎
In the following example, the content property is used to create tiered numbering that hooks into the list-item counter, and thus respects any numbering changes inflicted through HTML:
</p>

<pre class="lang-css">
ol &gt; li::marker { content: counters(list-item,'.') '.'; }
</pre>

<p>
この規則を利用している入子の~listは、次の様に描画されることになる：
◎
Nested lists using this rule would be rendered like
</p>

<pre class="ex-rendering">
1. 一個目の第一~level~item
5. 二個目の第一~level~item（ value=5 ）
   5.3. 一個目の第二~level~item（~listの start=3 ）
   5.4. 二個目の第二~level~item（~listの start=3 ）
        5.4.4. reversed ~list内の一個目の第三~level~item
        5.4.3. reversed ~list内の二個目の第三~level~item
        5.4.2. reversed ~list内の三個目の第三~level~item
        5.4.1. reversed ~list内の四個目の第三~level~item
   5.5. 三個目の第二~level~item（~listの start=3 ）
6. 三個目の第一~level~item
</pre>

<p>
次のような~markupが与えられたときには：
◎
given markup such as
</p>

<pre class="lang-html">
&lt;ol&gt;
  &lt;li&gt;一個目の第一~level~item
  &lt;li value=5&gt;二個目の第一~level~item（ value=5 ）
    &lt;ol start=3&gt;
      &lt;li&gt;一個目の第二~level~item（~listの start=3 ）
      &lt;li&gt;二個目の第二~level~item（~listの start=3 ）
         &lt;ol reversed&gt;
           &lt;li&gt;reversed ~list内の一個目の第三~level~item
           &lt;li&gt;reversed ~list内の二個目の第三~level~item
           &lt;li&gt;reversed ~list内の三個目の第三~level~item
           &lt;li&gt;reversed ~list内の四個目の第三~level~item
         &lt;/ol&gt;
      &lt;li&gt;三個目の第二~level~item（~listの start=3 ）
    &lt;/ol&gt;
  &lt;li&gt;三個目の第一~level~item
&lt;/ol&gt;
&lt;ol&gt;
</pre>

<!-- 

1. First top-level item
5. Second top-level item, value=5
   5.3. First second-level item, list start=3
   5.4. Second second-level item, list start=3
        5.4.4. First third-level item in reversed list
        5.4.3. Second third-level item in reversed list
        5.4.2. Third third-level item in reversed list
        5.4.1. Fourth third-level item in reversed list
   5.5. Third second-level item, list start=3
6. Third top-level item

<ol>
  <li>First top-level item
  <li value=5>Second top-level item, value=5
    <ol start=3>
      <li>First second-level item, list start=3
      <li>Second second-level item, list start=3
        <ol reversed>
          <li>First third-level item in reversed list
          <li>Second third-level item in reversed list
          <li>Third third-level item in reversed list
          <li>Fourth third-level item in reversed list
        </ol>
    </ol>
  <li>Third second-level item, list start=3
  <li>Third top-level item
</ol>

 -->
</div>

		</section>
		<section id="counter-functions">
<h3 title="Outputting Counters: the counter() and counters() functions">4.7. ~counterの出力-法： `counter^f, `counters^f 関数</h3>

<p>
`~counter$それ自体は可視~効果を伴わないが、それらの値は［
`counter$f ／ `counters$f
］関数で利用できる
— その`使用~値$は、`~counter値$を文字列や画像として表現し，次に従って定義される：
◎
Counters have no visible effect by themselves, but their values can be used with the counter() and counters() functions, whose used values represent counter values as strings or images. They are defined as follows:
</p>

<pre class="prod">
`counter@t
    = `counter()$t | `counters()$t
`counter@f
    = counter( `counter-name$t, `counter-style$t? )
`counters@f
    = counters( `counter-name$t, `string$t, `counter-style$t? )
</pre>

<p>
ここで `counter-style$t は、`~counter表現を生成-$するための`~counter~style$を指定する。
`css-counter-styles-3$r
◎
where &lt;counter-style&gt; specifies the counter style for generating a representation of the named counter(s) as defined in [css-counter-styles-3] and
</p>

<dl>
	<dt>`counter^f</dt>
	<dd>
`counter-style$t を利用して，［
要素の`~counter集合$内の名前 `counter-name$t の`最内縁$な`~counter$の`値$cT
］用の`~counter表現を生成-$した結果を表現する。
◎
Represents the value of the innermost counter in the element’s CSS counters set named &lt;counter-name&gt; using the counter style named &lt;counter-style&gt;.
</dd>

	<dt>`counters^f</dt>
	<dd>
<p>
次を走らせた結果を表現する：
</p>
		<ol>
			<li>
%L ~LET 新たな~list
</li>
			<li>
要素の`~counter集合$内の
~EACH( 名前 `counter-name$t の`~counter$ %~counter )
に対し
⇒
%L に次の結果を`付加する$
⇒
`counter-style$t を利用して［
%~counter の`値$cT
］用の`~counter表現を生成-$する
</li>
			<li>
~RET %L を `string$t で`連結する$
</li>
		</ol>
◎
Represents the values of all the counters in the element’s CSS counters set named &lt;counter-name&gt; using the counter style named &lt;counter-style&gt;, sorted in outermost-first to innermost-last order and joined by the specified &lt;string&gt;.
</dd>
</dl>

<p>
両~事例とも，`counter-style$t 引数が省略された場合、
`decimal$v が既定になる。
◎
In both cases, if the &lt;counter-style&gt; argument is omitted it defaults to decimal.
</p>

<p>
［
`counter$f ／ `counters$f
］が利用された所で，要素の`~counter集合$内に名前 `counter-name$t の`~counter$は存在しない場合、次を遂行しておく
⇒
`~counterを~instance化する$( その名前, 要素, `0^v )
◎
If no counter named &lt;counter-name&gt; exists on an element where counter() or counters() is used, one is first instantiated with a starting value of 0.
</p>

<div class="example">

<pre class="lang-css">
H1::before        { content: counter(章, upper-latin) ". " }
/* <span class="comment">
"A. A History of Discontent"
の様な見出しを生成する。
◎
Generates headings like "A. A History of Discontent"
</span> */

H2::before        { content: counter(節, upper-roman) " - " }
/* <span class="comment">
"II - The Discontent Part"
の様な見出しを生成する。
◎
Generates headings like "II - The Discontent Part"
</span> */

BLOCKQUOTE::after { content: " [" counter(引用, decimal) "]" }
/* <span class="comment">
"... [3]"
で終端する様な引用~塊を生成する
◎
Generates blockquotes that end like "... [3]"
</span> */

DIV.note::before  { content: counter(notecntr, disc) " " }
/* <span class="comment">
単純に，どの `div.note^css の前にも~bulletを生成する
◎
Simply generates a bullet before every div.note
</span> */

P::before         { content: counter(p, none) }
/* <span class="comment">
何も挿入しない
◎
inserts nothing
</span> */
</pre>
</div>

<div class="example">
<p>
`counters$f 関数の単純な利用を次の例に示す：
◎
The following example shows a simple use of the counters() function:
</p>

<pre class="lang-html">
&lt;ul&gt;
  &lt;li&gt;一&lt;/li&gt;
  &lt;li&gt;二
    &lt;ul&gt;
      &lt;li&gt;入子の一&lt;/li&gt;
      &lt;li&gt;入子の二&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;三&lt;/li&gt;
&lt;/ul&gt;
&lt;style&gt;
li::marker { content: '(' counters(list-item,'.') ') '; }
&lt;/style&gt;
</pre>

<p>
前掲の文書は、次の様に描画されるべきである：
◎
The preceding document should render something like this:
</p>

<pre class="ex-rendering">
(1) 一
(2) 二
   (2.1) 入子の一
   (2.2) 入子の二
(3) 三
</pre>

<!-- 
(1) one
(2) two
   (2.1) nested one
   (2.2) nested two
(3) three
-->

</div>

<div class="example">
<p>
各~counterは、後続の同胞に継承されるので，入子の~~関係にない見出しと下位~見出しを付番するときにも利用できる。
あいにく，これは、 `counters$f には利用できない
— 同胞たちの~counterは入子にされないので。
代わりに，複数の~counter名を手動で連結することで可能になる：
◎
Because counters inherit to siblings as well, they can be used to number headings and subheadings, which aren’t nested within each other. Unfortunately, this prevents the use of counters() as counters from siblings don’t nest, but one can create multiple counters and manually concatenate them instead:
</p>

<pre class="lang-html">
&lt;h1&gt;一個目の H1&lt;/h1&gt;
...
&lt;h2&gt;H1 の中の一個目の H2&lt;/h2&gt;
...
&lt;h2&gt;H1 の中の二個目の H2&lt;/h2&gt;
...
&lt;h3&gt;H2 の中の一個目の H3&lt;/h3&gt;
...
&lt;h1&gt;二個目の H1&lt;/h1&gt;
...
&lt;h2&gt;一個目の H2&lt;/h2&gt;
...
&lt;style&gt;
body { counter-reset: h1 h2 h3; }
h1   { counter-increment: h1; counter-reset: h2 h3;}
h2   { counter-increment: h2; counter-reset:    h3; }
h3   { counter-increment: h3; }
h1::before { content: counter(h1,upper-alpha) '. '; }
h2::before { content: counter(h1,upper-alpha) '.'
                      counter(h2,decimal) '. '; }
h3::before { content: counter(h1,upper-alpha) '.'
                      counter(h2,decimal) '.'
                      counter(h3,lower-roman) '. '; }
&lt;/style&gt;
</pre>
<!-- 
 <h1>First H1</h1>
...
 <h2>First H2 in H1</h2>
...
 <h2>Second H2 in H1</h2>
...
 <h3>First H3 in H2</h3>
...
 <h1>Second H1</h1>
...
 <h2>First H2 in H1</h2>
...
-->

<p>
前掲の文書は、次の様に描画されるべきである：
◎
The preceding document should render something like this:
</p>

<pre class="ex-rendering">
A. 一個目の H1
...
A.1. H1 の中の一個目の H2
...
A.2. H1 の中の二個目の H2
...
A.2.i. H2 の中の一個目の H3
...
B. 二個目の H1
...
B.1. H1 の中の一個目の H2
...
</pre>

<!-- 
A First H1
...
A.1 First H2 in H1
...
A.2 Second H2 in H1
...
A.2.i First H3 in H2
...
B Second H1
...
B.1 First H2 in H1
...
-->
</div>

<div class="issue">
<p>
~counterは、印刷ng~marker以外のものにもときどき有用になる。
それは一般に，一連の要素を付番する能を供し、他の~propを参照するときにも有用になり得る。
例えば `order$p を利用して，要素を他の 2 つの特定の要素の合間に置くためには、現在では，欲される挿入点の前／後にある要素ごとに `order$p を明示的に与えることが要求される。
どの `order$p 値にも~counterを設定できれば、より容易に，要素を 任意な他の 2 つの合間の~~地点に挿入できる。
◎
Counters are sometimes useful for things other than printing markers. In general, they provide the ability to number elements in sequence, which can be useful for other properties to reference. For example, using order to put an element between two other specific elements currently requires you to explicitly put order on every element before and/or after the desired insertion point. If you can set the order value of everything to a counter, tho, you can more easily insert an element into an arbitrary spot between two others.
</p>

<p>
他にも、入子にされた, あるいは同胞どうしの要素に，少しずつ異なる変形を与える利用-事例がある。
今日、これを適度な仕方で行うためには，前処理器を利用する必要があるが、~counterを使えば “素の” ~CSSでも上手く働くようになる。
◎
Other use-cases involve nested or sibling elements with transforms that are meant to be slightly different from each other. Today you have to use a preprocessor to do this in a reasonable way, but a counter would make it work well in "plain" CSS.
</p>

<p>
（入子にされた事例については、今日では，`~custom~prop$と多段に入子にされた `calc$f を利用すれば，一連の値を築けるが、これはちょっとぶかっこうになる。また、同胞に対しては働かない。）
◎
(You can built up successive values in the nested case today by using custom properties and stacking up nested calc()s, but this is a *little bit* clumsy, and doesn’t work for siblings.)
</p>

<p>
有名~counterの値を文字列ではなく整数として返す
<code class="value">counter-value(`counter-name$t)</code>
関数の追加が示唆されている。
◎
Suggestion is to add a counter-value(&lt;counter-name&gt;) function, which returns the value of the named counter as an integer, rather than returning a string.
</p>

<p>
`1026$issue
を見よ。
◎
See Issue 1026.
</p>

</div>

		</section>
	</section>
	<section id="ua-stylesheet">
<h2 title="Sample style sheet for HTML">5. ~HTML用の見本~stylesheet</h2>

~INFORMATIVE

<p>
`HTML$r の具現化~節は
<a href="~HTMLrendering#lists">~HTML~listに適用される既定の~prop</a>
を規範的に定義する。
◎
The [HTML] Rendering chapter defines the normative default properties that apply to HTML lists.
</p>

<pre class="lang-css">
/* <span class="comment">
~list~itemたちを設定しておく
◎
Set up list items
</span> */
li {
  display: list-item;
  /* <span class="comment">これは、
<code class="css">`counter-increment^p: `list-item^v;</code>
も課す
◎
implies 'counter-increment: list-item'
</span> */
}

/* <span class="comment">
`list-item^v ~counterが `ol^e ／ `ul^e の視野に入るよう設定しておく
◎
Set up ol and ul so that they scope the list-item counter
</span> */
ol, ul {
  counter-reset: list-item;
}

/* <span class="comment">
~list用の既定の~list~style型
◎
Default list style types for lists
</span> */
ol { list-style-type: decimal; }
ul { list-style-type: toggle(disc, circle, square); }

/* <span class="comment">
`ol^e ／ `ul^e 要素~上の `type^a 属性 
◎
The type attribute on ol and ul elements
</span> */
ul[type="disc"] { list-style-type: disc; }
ul[type="circle"] { list-style-type: circle; }
ul[type="square"] { list-style-type: square; }
ol[type="1"] { list-style-type: decimal; }
ol[type="a"] { list-style-type: lower-alpha; }
ol[type="A"] { list-style-type: upper-alpha; }
ol[type="i"] { list-style-type: lower-roman; }
ol[type="I"] { list-style-type: upper-roman; }

/* <span class="comment">
`ol^e 要素~上の `start^a 属性
◎
The start attribute on ol elements
</span> */
ol[start] {
  counter-reset: list-item calc(attr(start integer, 1) - 1);
}

/* <span class="comment">
`li^e 要素~上の `value^a 属性
◎
The value attribute on li elements
</span> */
li[value] {
  counter-set: list-item attr(value integer, 1);
}

/* <span class="comment">
逆順の~listの取扱い
◎
Handling reversed lists
</span> */
ol[reversed] {
  counter-reset: list-item calc(attr(start integer, %magic) + 1);
  /* <span class="comment">
ここでの %magic は、子 `li^e 要素の個数。
◎
Where **magic** is the number of child &lt;li&gt; elements.
</span> */
}
ol[reversed] > li {
  /* <span class="comment">
~HTMLは、
<code class="css">`counter-increment^p: `list-item -1^v;</code>
も課す
◎
HTML implies 'counter-increment: list-item -1'
</span> */
}

/* <span class="comment">
~box~model規則
◎
Box Model Rules
</span> */
ol, ul {
  display: block;
  margin-block: 1em;
  marker-side: match-parent;
  padding-inline-start: 40px;
}
ol ol, ol ul, ul ul, ul ol {
  margin-block: 0;
}

li {
  text-align: match-parent;
}

li::marker {
  unicode-bidi: isolate;
  font-variant-numeric: tabular-nums;
}
</pre>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々に。
彼らの手による文書化は、付番~systemを定義するときにとても役立った：
</p>

<div lang="en-x-a0">
The following people and documentation they wrote were very useful for defining the numbering systems: Alexander Savenkov, Arron Eicholz, Aryeh Gregor, Frank Tang, Jonathan Rosenne, Karl Ove Hufthammer, Musheg Arakelyan, Nariné Renard Karapetyan, Randall Bart, Richard Ishida, Simon Montagu (Mozilla, smontagu@smontagu.org)
</div>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
この節では、以前の発行版からの変更点を文書化する。
◎
This section documents the changes since previous publications.
</p>

		<section id="changes-20190425">
<h3>2019年 4月 25日 作業草案からの変更点</h3>

<ul>
	<li>
<a href="#auto-numbering">§ ~counterによる自動的な付番</a>
を書き直した
— より精確に, CSS2 と一致するよう, 編集上の明確化。
◎
Rewrite the § 4 Automatic Numbering With Counters section for better precision, editorial clarity, and synchronization with CSS2.
</li>
</ul>

		</section>
		<section id="changes-20140320">
<h3 title="Changes since the 20 March 2014 WD">2014年 3月 20日 WD からの変更点</h3>

<ul>
	<li>
~counter名には `custom-ident$t 【現在は `counter-name$t 】を一貫して利用するようにした。
◎
Use &lt;custom-ident&gt; consistently for counter names.
</li>
	<li>
`position$p を落とした（~markerの位置決めは、今や，~CSS-2と同じく ほぼ定義されない）。
◎
Dropped position: marker (marker positioning is now mostly undefined, as in CSS2).
</li>
	<li>
~marker用の節を完全に書き直した：
それを整備し，現在の期待に揃うようにし，編集上の改善を施した。
◎
Completely rewrote chapter on markers to tighten it up, align with current expectations, and make editorial improvements.
</li>
	<li>
`list-item$v ~counter定義を自前の節の中に取り込み，いくつか例を追加し，いくつか明確化した。
◎
Pulled the list-item counter definition into its own section, added examples, and made some clarifications.
</li>
	<li>
`marker-side$p の値を［
~box／~text
］整列における慣行に合致するよう改称した。
◎
Renamed values of marker-side to match conventions from box/text alignment.
</li>
	<li>
`counter-set$p は `counter-increment$p より後に適用するものと定義した
— より前ではなく。
（ `3810$issue ）
◎
Defined that counter-set is applied after counter-increment rather than before. (Issue 3810)
</li>
	<li>
`list-style$p 直列化の正準的な順序を
— `list-style-type$p が最後になるよう —
確立した。
（ `2624$issue ）
◎
Established the canonical order of list-style serialization to put &lt;'list-style-type'&gt; last. (Issue 2624)
</li>
</ul>

		</section>
		<section id="changes-from-css2">
<h3 title="Changes From CSS Level 2">~CSS~level 2 からの変更点</h3>

<p>
序論~節にて述べたように、この~moduleには，
CSS2.1 に比して有意な変更点がある：
◎
As described in the introduction section, there are significant changes in this module when compared to CSS2.1.
</p>

<ul>
	<li>
~list~markerに直に~styleできるようにするため、
`marker$pe 疑似要素が導入された。
◎
The ::marker pseudo-element has been introduced to allow styling of the list marker directly.
</li>
	<li>
`list-style-type$p は、今や，
`string$t, および
`css-counter-styles-3$r により拡張された `counter-style$t 値を受容する。
◎
list-style-type now accepts a &lt;string&gt; as well as the extended &lt;counter-style&gt; values from [css-counter-styles-3]..
</li>
	<li>
定義済み~counter識別子として `list-item^v が導入された。
◎
The list-item predefined counter identifier has been introduced.
</li>
	<li>
`counter-set$p ~propが追加された。
◎
The counter-set property has been added.
</li>
	<li>
`css-display-3$r に導入された`行内~level$の`~list~item$を許容した。
◎
Allowed for inline-level list items, as introduced in [css-display-3]. 
</ul>

		</section>
	</section>
</main></div>
