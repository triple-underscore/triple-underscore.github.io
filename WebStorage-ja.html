<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Web Storage（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'webstorage',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm': // IDL member
case 'mE':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2020-05-18
trans_update:2019-08-11
source_checked:191126
page_state_key:HTML
original_url:https://html.spec.whatwg.org/multipage/webstorage.html
	abbr_url:WEBSTORAGE
spec_status:LS
site_nav:storage,html
nav_prev:WORKERS
nav_next:HTMLwriting


●●class_map
e:element
a:attr
E:error
et:event-type
h:header

●●tag_map
I:code
m:code
mE:code
E:code
c:code
s:samp
e:code
a:code
et:code
h:code
v:var
i:i
em:em

●●original_id_map


references:
item-list:
item:
key:
value:

●●mdn_urls
storage-2:API/Storage
storageevent:API/StorageEvent
	storageeventinit:API/StorageEventInit
windowsessionstorage:API/WindowSessionStorage
windowlocalstorage:API/WindowLocalStorage

●●link_map


~item~list:#item-list
~item:#item
~key:#key
~value:#value

I.Window:~WINDOW#window
I.Document:~HTMLdom#document
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
	I.Node:~DOM4#node
I.Storage:#storage-2
I.StorageEvent:#storageevent
I.StorageEventInit:#storageeventinit
I.WindowSessionStorage:#windowsessionstorage
I.WindowLocalStorage:#windowlocalstorage

E.QuotaExceededError:~WEBIDL#quotaexceedederror
E.SecurityError:~WEBIDL#securityerror

m.initEvent:~DOM4#dom-event-initevent
m.localStorage:#dom-localstorage
m.sessionStorage:#dom-sessionstorage
	Storage
m.length:#dom-storage-length
m.key:#dom-storage-key
m.getItem:#dom-storage-getitem
m.setItem:#dom-storage-setitem
m.removeItem:#dom-storage-removeitem
m.clear:#dom-storage-clear

	StorageEvent
mE.key:#dom-storageevent-key
mE.oldValue:#dom-storageevent-oldvalue
mE.newValue:#dom-storageevent-newvalue
mE.url:#dom-storageevent-url
mE.storageArea:#dom-storageevent-storagearea
mE.initStorageEvent:#dom-storageevent-initstorageevent

c.delete:~TC39#sec-delete-operator

et.storage:~HTMLindex#event-storage

文書:~HTMLdom#the-document-object
~window:~WINDOW#the-window-object
結付けられている文書:~WINDOW#concept-document-window
	結付けている~window:#concept-document-window

~storage通知を送信する:#send-a-storage-notification

~DOM操作~task源:~WAPI#dom-manipulation-task-source
~event~loop:~WAPI#event-loop
~taskを~queueする:~WAPI#queue-a-task
~task源:~WAPI#task-source
関連な大域~obj:~WAPI#concept-relevant-global

閲覧文脈:~BROWSERS#browsing-context
全部的に作動中:~BROWSERS#fully-active
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
作動中の文書:~BROWSERS#active-document
新たな補助~閲覧文脈を作成する:~BROWSERS#creating-a-new-auxiliary-browsing-context
	属する閲覧文脈:~BROWSERS#concept-document-bc
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque

e.iframe:~HEembed#the-iframe-element
~supportする~prop名:~WEBIDL#dfn-supported-property-names
~eventを発火する:~DOM4#concept-event-fire
doc.~URL:~DOM4#concept-document-url


	:#localStorageEvent
	:#localStorageMutex
	:#sessionStorageEvent


●●words_table1


●●words_table



	●storage／環境
storage::::ストレージ
local::::ローカル
quota::::クォータ
	割当分
	~access不能:inaccessible
transaction::::トランザクション
disk::::ディスク
容量:space::~::スペース
持続的:persistent::~
持続-:persist::~
	格納-済み:stored
存続期間:lifetime:~
	複数~pageを同時に処理する:multiprocess

補助:auxiliary::~
	:::ウィンドウ
破壊的:disastrous:~
復帰:resuming:~
再起動:restart:~
	あてがう:allocate／have

	●network
pathname::::パス名

	●IDL／型／構造
value:

	●処理
不可分:atomic::~

	呼出-:invocation
	初期化-時
	成功-:successful

	●保安
TLS:
DNS:
cross-directory::::クロスディレクトリ
	敏感~性:sensitivity
profile::::プロファイル


証明書:certificate::~
失効-:expire:~
失効:expiration:~
主体:entity::~::エンティティ
spoofing:::なりすまし
超過-:exceed:~

漏洩:leakage:~
阻止list:blocklist::阻止 list:阻止リスト:ブロックリスト
安全list:safe-listing::安全 list:安全リスト
	safelisting

訪問者:visitor:~
関心:interests:~
流布-:distribute:~
広告主:advertiser:~
広告:advertising:~
	~~高度な:highly
	絞り込み:targeted
電子商取引:e-commerce:~
認証情報:authenticated credentials::~
認証-:authenticate::~
不当な:oppressive:~
団体:group:~
	精度:greater accuracy

標的に:target:~
本当の:real:~
身元:identity:~
有用性:usefulness:~
打破-:defeat:~
	
	迂回-:circumventing
	迂回-:bypass
転用-:repurpose:~
被害者:victim:~
危険:dangerous:~
自明:trivial:~
作業中の:work-in-progress:~
文書作成:word-processing:~
秘匿文書:confidential documents:~
競合企業:competing company:~
wishlist::::購入希望リスト
	予測-可能にする:predictability
枯渇-:exhaust:~
防護-:guard
	上限:limit
無圧縮時の:uncompressed:~
読取り:read:読み取り
読取る:readする:読み取る
読取っ:readし:読み取っ
書込まれ:writeされ:書き込まれ
書込んだ:writeした:書き込んだ
書込み:write:書き込み
書戻す:write backする:書き戻す
上書-:overwrite::上書き
	もたらす~~影響:implications
閉じた:closeした:~
冗長backup:redundant backup:冗長 backup::冗長バックアップ
	許可:authorize/denying/white-
	~~材料:informed
	~~協同:act together
個人識別情報:identifying information:~
	（名前, カード番号, 住所など） (names, credit card numbers, addresses
協力-:cooperate:~
協力:cooperation:~
遡及的:retroactive:~
	なり得る:potential

	確証sure
	利する:on behalf of
	差し障りない:innocuousな
log-in::::ログイン
	購入予約:making a purchase
提携:affiliated:~
想定-:suppose:~
	for:~~想定
首尾一貫した:coherentな:~
消去-:clear:~
	築き上げ:build

	●仕様

	●例
main::::メイン
checkbox::::チェックボックス
check::::チェック
mailbox::::メールボックス

	購入 buy
	~~閲覧:click

	●未分類
scripting::::スクリプティング

megabyte::::メガバイト
出自に:originate:~
開かれ:openされ:~
	在る／無い:exist
	増やして:increment
	促して prompt
	似た〜:similarly-

	●指示語
	別個:separate


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Web Storage</a>
を日本語に翻訳したものです。
（公開：<time>2013-04-20</time> （ W3C 版））
</p>

</script>

<body>

<header>
	<hgroup>
<h1>Web Storage</h1>

	</hgroup>

</header>

<main id="MAIN" hidden>

<section id="webstorage">
<h1>11. Web Storage</h1>

	<section id="introduction-15">

<h2 title="Introduction">11.1. 序論</h2>

~INFORMATIVE

<p>
この仕様は、 HTTP ~session~cookie `COOKIES$r に類似な，~client側に
( 名前, 値 )
が成す~pairたちを格納するための，関係する 2 つの仕組みを導入する。
◎
This specification introduces two related mechanisms, similar to HTTP session cookies, for storing name-value pairs on the client side. [COOKIES]
</p>

<p>
1 つ目の仕組みは、利用者が単独の~transactionで~dataをやりとりする局面を~~想定して設計されているが、異なる~window間で並行する複数の~transactionでやりとりすることもできる。
◎
The first is designed for scenarios where the user is carrying out a single transaction, but could be carrying out multiple transactions in different windows at the same time.
</p>

<p>
~cookieは、この事例を上手く取扱えない。
例えば利用者は、同じ~siteの 2 つの異なる~windowで航空機の搭乗券の購入を検討するかもしれない。
~siteが，購入中の搭乗券の情報を~cookieに保ち続けている場合、利用者が両方の~windowで~pageから~pageへ~~閲覧を続けたときに，それらの搭乗券の情報が一方の~windowから他方へ “漏れ出す” 結果、同じ便の搭乗券を気付かないうちに重複して購入する羽目に陥り得る。
◎
Cookies don't really handle this case well. For example, a user could be buying plane tickets in two different windows, using the same site. If the site used cookies to keep track of which ticket the user was buying, then as the user clicked from page to page in both windows, the ticket currently being purchased would "leak" from one window to the other, potentially causing the user to buy two tickets for the same flight without really noticing.
</p>

<p>
これに取組むため、この仕様は， `sessionStorage$m ~IDL属性を導入する。
~siteは~session~storageに~dataを追加でき，同じ~siteで開かれているどの~pageからも~access可能になる。
◎
To address this, this specification introduces the sessionStorage IDL attribute. Sites can add data to the session storage, and it will be accessible to any page from the same site opened in that window.
</p> 

<div class="example">

<p>
例えば~pageは、利用者が保険を希望する旨を指示する~checkboxを持つこともある：
◎
For example, a page could have a checkbox that the user ticks to indicate that they want insurance:
</p>

<pre class="lang-html">
&lt;label&gt;
 &lt;input
   type="checkbox"
   onchange="sessionStorage.insurance = checked ? 'true' : ''"
 &gt;
 <span class="comment">
この旅行に保険を掛ける
◎
I want insurance on this trip.
</span>
&lt;/label&gt;
</pre>

<p>
その~pageは、後で，利用者が~checkboxを~checkしたかどうか ~scriptから調べることもできる：
◎
A later page could then check, from script, whether the user had checked the checkbox or not:
</p>

<pre class="lang-js">
if (sessionStorage.insurance) { ... }
</pre>

<p>
利用者がその~site上で複数の~windowを開いたとき、それぞれの~windowは，自前の~session~storage~objの複製を持つ。
◎
If the user had multiple windows opened on the site, each one would have its own individual copy of the session storage object.
</p>

</div>


<p>
~storageの 2 つ目の仕組みは、複数の~window, 複数の~sessionに渡って残り続ける~storage用に設計されている。
~Web~appは、特に，~megabyte~~単位の利用者~data
— 例えば 利用者が作成した文書~全体や, 利用者の~mailboxなど —
に対しては，処理能の理由から~client側に保存するよう望むこともある。
◎
The second storage mechanism is designed for storage that spans multiple windows, and lasts beyond the current session. In particular, Web applications might wish to store megabytes of user data, such as entire user-authored documents or a user's mailbox, on the client side for performance reasons.
</p>

<p>
ここでも~cookieは、要請の度に伝送されるので，この用途には適さない。
◎
Again, cookies do not handle this case well, because they are transmitted with every request.
</p>

<p>
`localStorage$m ~IDL属性は、~pageの~local~storage区画への~accessに利用される。
◎
The localStorage IDL attribute is used to access a page's local storage area.
</p>

<div class="example">

<p>
`example.com^s の~siteは、~pageの末尾に次のような~codeを置いて，利用者が~pageを読込んだ回数を表示できる：
◎
The site at example.com can display a count of how many times the user has loaded its page by putting the following at the bottom of its page:
</p>

<pre class="lang-html">
&lt;p&gt;
  あなたがこのページを見たのは
  &lt;span id="count"&gt;〜&lt;/span&gt;回目です。
&lt;/p&gt;
&lt;script&gt;
  if (!localStorage.pageLoadCount)
    localStorage.pageLoadCount = 0;
  localStorage.pageLoadCount
      = parseInt(localStorage.pageLoadCount) + 1;
  document.getElementById('count').textContent
      = localStorage.pageLoadCount;
&lt;/script&gt;
</pre>

</div>

<p>
各~siteには，それぞれに自前の~storage区画があてがわれる。
◎
Each site has its own separate storage area.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="storage">
<h2 title="The API">11.2. ~API</h2>

		<section id="the-storage-interface">
<h3 title="The Storage interface">11.2.1. `Storage^I ~interface</h3>

<pre class="idl">
[Exposed=Window]
interface `Storage@I {
  readonly attribute unsigned long `length$m;
  DOMString? `key$m(unsigned long %index);
  getter DOMString? `getItem$m(DOMString %key);
  setter void `setItem$m(DOMString %key, DOMString %value);
  deleter void `removeItem$m(DOMString %key);
  void `clear$m();
};
</pre>

<p>
各 `Storage$I ~objは、
`~item~list@
への~accessを供する：
◎
Each Storage object provides access to a list of key/value pairs,＼
</p>

<ul>
	<li>
`~item~list$は、いくつかの
`~item@
からなる~listである。
各`~item$は ［
`~key@
とそれに対応する
`~value@
］が成す~pairである。
`~key$, `~value$とも，文字列である
— どのような文字列も（空~文字列も含め），妥当な値になる。
◎
which are sometimes called items. Keys are strings. Any string (including the empty string) is a valid key. Values are similarly strings.
</li>
	<li>
`~item~list$は、 `Storage$I ~objの作成-時に結付けられる（~~詳細は
`sessionStorage$m, `localStorage$m
各~属性にて定義される）。
同じ`~item~list$が、 `Storage$I  ~interfaceを実装する複数の別個の~objに，同時に結付けられ得る。
◎
Each Storage object is associated with a list of key/value pairs when it is created, as defined in the sections on the sessionStorage and localStorage attributes. Multiple separate objects implementing the Storage interface can all be associated with the same list of key/value pairs simultaneously.
</li>
</ul>

<dl class="domintro">
	<dt>%storage . `length$m</dt>
	<dd>
`~item~list$内に現在ある`~item$たちの総数を返す。
◎
Returns the number of key/value pairs currently present in the list associated with the object.
</dd>

	<dt>%storage . `key(index)$m</dt>
	<dd>
`~item~list$内の %index 番の`~key$を返す
— ただし、 %index が`~item~list$内の`~item$の総数~以上の場合は， ~NULL を返す。
◎
Returns the name of the nth key in the list, or null if n is greater than or equal to the number of key/value pairs in the object.
</dd>

	<dt>%value = %storage . `getItem(key)$m</dt>
	<dt>%value = %storage[%key]</dt>
	<dd>
`~item~list$内に［
%key を`~key$とする`~item$
］が［
在るならば その現在の`~value$／
無いならば ~NULL
］を返す。
◎
Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
</dd>

	<dt>%storage . `setItem(key, value)$m</dt>
	<dt>%storage[%key] = %value</dt>
	<dd>
`~item~list$内の［
%key を`~key$とする`~item$
］の`~value$を
— そのような`~item$は無いならば，新たな`~item$を作成した上で —
%value に設定する。
◎
Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
</dd>
	<dd>
新たな値を設定できなかった場合、
`QuotaExceededError$E 例外を投出する（例えば、利用者が当の~site用の~storageを不能化していた場合や, ~quotaを超過した場合）。
◎
Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
</dd>

	<dt>%storage . `removeItem( key )$m</dt>
	<dt>`delete$c %storage[%key]</dt>
	<dd>
`~item~list$内に［
%key を`~key$とする`~item$
］が在るならば、それを除去する。
◎
Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.
</dd>

	<dt>%storage . `clear$m()</dt>
	<dd>
~objの`~item~list$を空にする
◎
Empties the list associated with the object of all key/value pairs, if there are any.
</dd>
</dl>


<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
取得子は、現在の`~item~list$内の`~item$の総数を返すモノトスル。
◎
The length attribute must return the number of key/value pairs currently present in the list associated with the object.
</dd>

	<dt>`key(index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
</p>

		<ol>
			<li>
~IF［
%index ~GTE ~list内の`~item$の総数
］
⇒
~RET ~NULL
</li>
			<li>
~RET `~item~list$の %index 番の~itemの`~key$
【 0 番が最初の~item】
</li>
		</ol>

<p>
【この~methodの目的における】
`~item$の順序は，~UAにより定義されるが、`~item$の総数が変化しない限り，返される結果は~objにおいて一定になるモノトスル（したがって，`~item$の順序は、
<a href="#dom-storage-setitem">追加-</a>／
<a href="#dom-storage-removeitem">除去-</a>
されたときは変化し得るが，既存の`~item$の`~value$が変更されたときは変化しないモノトスル）。
</p>

<p class="trans-note">【
この順序に関しては，他に要件は述べられていないので、~itemを追加したり除去した後で，全体の順序がまるっきり変わることもあり得ることになる。
】</p>

◎
The key(n) method must return the name of the nth key in the list. The order of keys is user-agent defined, but must be consistent within an object so long as the number of keys doesn't change. (Thus, adding or removing a key may change the order of the keys, but merely changing the value of an existing key must not.) If n is greater than or equal to the number of key/value pairs in the object, then this method must return null.
</dd>
</dl>


<div>
<p>
`Storage$I ~objが`~supportする~prop名$は、次で与えられる【有順序】集合として定義される：
</p>
		<ul>
			<li>
~accessされた時点で，その`~item~list$内に在る`~item$すべての`~key$からなる。
</li>
			<li>
順序は、当の~storage区画に`~key$が追加された順による。
</li>
		</ul>
◎
The supported property names on a Storage object are the keys of each key/value pair currently present in the list associated with the object, in the order that the keys were last added to the storage area.
</div>


<dl class="idl-def">

	<dt>`getItem(key)@m</dt>
	<dd>
被呼出時には、次を返すモノトスル
⇒
`~item~list$内に［
`~key$ ~EQ %key
］なる`~item$は［
在るならば その現在の`~value$ ／
無いならば ~NULL
］
◎
The getItem(key) method must return the current value associated with the given key. If the given key does not exist in the list associated with the object then this method must return null.
</dd>

	<dt>`setItem(key, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The setItem(key, value) method must＼
</p>

		<ol>
			<li>
%~item ~LET `~item~list$内に［
`~key$ ~EQ %key
］なる`~item$は［
在るならば それ ／
無いならば ε
］
◎
first check if a key/value pair with the given key already exists in the list associated with the object.
</li>
			<li>
~IF［
%~item ~EQ ε
］
⇒
`~item~list$に 次のようにされた新たな`~item$を追加する
⇒
( `~key$, `~value$ ) ~SET ( %key, %value )
◎
If it does not, then a new key/value pair must be added to the list, with the given key and with its value set to value.
</li>
			<li>
~ELIF［
%item の`~value$ ~NEQ %value
］
⇒
%item の`~value$ ~SET %value
◎
If the given key does exist in the list, and its value is not equal to value, then it must have its value updated to value.＼
</li>
			<li>
~ELSE
⇒
何もしないモノトスル
【下の注記を見よ】
◎
If its previous value is equal to value, then the method must do nothing.
</li>
		</ol>
	</dd>
	<dd>
新たな`~value$を設定できなかった場合、この~methodは `QuotaExceededError$E 例外を投出するモノトスル。
◎
If it couldn't set the new value, the method must throw a "QuotaExceededError" DOMException exception.
</dd>
	<dd>
この~methodは、 `removeItem()$m と同様に，失敗に関して不可分になるモノトスル。
◎
↓</dd>

	<dt>`removeItem(key)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
</p>

		<ol>
			<li>
~IF［
`~item~list$内に［
`~key$ ~EQ %key
］なる`~item$は在る
］
⇒
その`~item$を`~item~list$から除去する
</li>
			<li>
~ELSE
⇒
何もしないモノトスル
【下の注記を見よ】
</li>
		</ol>

◎
The removeItem(key) method must cause the key/value pair with the given key to be removed from the list associated with the object, if it exists. If no item with that key exists, the method must do nothing.
</dd>
	<dd>
`setItem()$m に加え，この~methodも、失敗に関して不可分になるモノトスル。
失敗する場合、これらの~methodは何もしない。
すなわち，~data~storage区画に対する変更は、［
成功するか, 全く変更されないか
］のいずれかになるモノトスル。
◎
The setItem() and removeItem() methods must be atomic with respect to failure. In the case of failure, the method does nothing. That is, changes to the data storage area must either be successful, or the data storage area must not be changed at all.
</dd>

	<dt>`clear()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
</p>

		<ol>
			<li>
~IF［
`~item~list$は空でない
］
⇒
`~item~list$を空にする
</li>
			<li>
~ELSE
⇒
何もしないモノトスル
【下の注記を見よ】
</li>
		</ol>
◎
The clear() method must atomically cause the list associated with the object to be emptied of all key/value pairs, if there are any. If there are none, then the method must do nothing.
</dd>
</dl>


<p class="note">注記：
［
`setItem()$m ／
`removeItem()$m ／
`clear()$m
］~methodが呼出されたときは、
【~storage区画に変更が加えられた場合に限り】
［［
新たに格納-または除去された~data
］に~access可能な，他の`文書$
］に`関連な大域~obj$に向けて，~eventが発火される（~~詳細は［
`sessionStorage$m, `localStorage$m
］属性の節にて定義される）。
◎
When the setItem(), removeItem(), and clear() methods are invoked, events are fired on the relevant global objects of other Document objects that can access the newly stored or removed data, as defined in the sections on the sessionStorage and localStorage attributes.
</p>

<p class="note">注記：
この仕様は、上述の~methodが，~dataが物理的に~diskに書込まれるまで待機することを要求しない。
同じ下層の`~item~list$へ~accessする 異なる~script間で、整合性が保たれることのみが要求される。
◎
This specification does not require that the above methods wait until the data has been physically written to disk. Only consistency in what different scripts accessing the same underlying list of key/value pairs see is required.
</p>

		</section>
		<section id="the-sessionstorage-attribute">
<h3 title="The sessionStorage attribute">11.2.2. `sessionStorage^m 属性</h3>

<pre class="idl">
interface mixin `WindowSessionStorage@I {
  readonly attribute `Storage$I `sessionStorage$m;
};
`Window$I includes `WindowSessionStorage$I;
</pre>

<p>
`sessionStorage@m
属性は、現在の`~top-level閲覧文脈$に特有な，~storage区画の集合を表現する。
◎
The sessionStorage attribute represents the set of storage areas specific to the current top-level browsing context.
</p>


<dl class="domintro">
	<dt>%window . `sessionStorage$m</dt>
	<dd>
その生成元†に属する~session~storage区画に結付けられている `Storage$I ~objを返す。
【† より明確には、 %window に`結付けられている文書$の`生成元$であろう。】
◎
Returns the Storage object associated with that origin's session storage area.
</dd>
</dl>

<p>
それぞれの`~top-level閲覧文脈$は、各`生成元$ごとに，別々の~session~storage区画をあてがう。
◎
Each top-level browsing context has a unique set of session storage areas, one for each origin.
</p>

<p>
~UAは，閲覧文脈の~session~storage区画の~dataが失効しないようにするベキであるが、次に挙げるいずれかに該当する場合は，失効させてもヨイ：
◎
User agents should not expire data from a browsing context's session storage areas, but may do so when＼
</p>

<ul >
	<li>
利用者からその種の~dataを削除するよう要請されたとき。
◎
the user requests that such data be deleted, or＼
</li>
	<li>
~UAが~storage容量の上限を検出したとき。
◎
when the UA detects that it has limited storage space, or＼
</li>
	<li>
~security上の理由があるとき。
◎
for security reasons.＼
</li>
</ul>

<p>
~UAは、また~session~storage区画に格納されている~dataに対し：
◎
User agents＼
</p>

<ul>
	<li>
~dataに~accessし得る~scriptを走らせている間は，失効させないベキである。
◎
should always avoid deleting data while a script that could access that data is running.＼
</li>
	<li>
`~top-level閲覧文脈$が破壊されたときは（したがって，それ以降~利用者からは~access不能になる），破棄できる
— この仕様に述べる~APIは、後続して当の~dataを検索取得する仕方を供さないので。
◎
When a top-level browsing context is destroyed (and therefore permanently inaccessible to the user) the data stored in its session storage areas can be discarded with it, as the API described in this specification provides no way for that data to ever be subsequently retrieved.
</li>
</ul>

<p class="note">注記：
~UAは，再起動~後の~sessionの復帰を~supportできるので、閲覧文脈の存続期間と, ~UAによる実際の その処理-の存続期間とは，必ずしも一致しない。
◎
The lifetime of a browsing context can be unrelated to the lifetime of the actual user agent process itself, as the user agent can support resuming sessions after a restart.
</p>

<p>
~UAは、新たな`文書$ %文書 を作成したときは、 %文書 が属する`閲覧文脈$の
`~top-level閲覧文脈$ %T があるならば，次で与えられる~session~storage区画を %文書 にアテガうモノトスル：
◎
When a new Document is created in a browsing context which has a top-level browsing context, the user agent must check to see＼
</p>

<ul >
	<li>%T が［
%文書 の`生成元$ %O
］用の~session~storage区画をすでに有しているならば、それ。
◎
if that top-level browsing context has a session storage area for that document's origin. If it does, then that is the Document's assigned session storage area.＼
</li>
	<li>
他の場合、 %O 用の新たな~storage区画を作成した結果。
◎
If it does not, a new storage area for that document's origin must be created, and then that is the Document's assigned session storage area.＼
</li>
</ul>

<p>
%文書 が存続する限り、 %文書 に他の~storage区画がアテガわれることはない。
◎
A Document's assigned storage area does not change during the lifetime of a Document.
</p>


<p class="note">注記：
`iframe$e が他の`文書$下に移動された場合、
`iframe$e が`入子にしている閲覧文脈$は破壊され，新たなものが作成される。
◎
In the case of an iframe being moved to another Document, its nested browsing context is destroyed and a new one created.
</p>

<p class="idl-def">
`sessionStorage$m 属性の取得子は、［
`文書$にアテガわれている ~session~storage区画
］に属する `Storage$I ~objを返すモノトスル。
各 `文書$は、それぞれが別個の，それに`関連な大域~obj$の `sessionStorage$m 属性に対応する~objを持つモノトスル。
◎
The sessionStorage attribute must return a Storage object associated with the Document's assigned session storage area. Each Document object must have a separate object for its relevant global object's sessionStorage attribute.
</p>

<p>
~session~storage区画は、`新たな補助~閲覧文脈を作成する$ときに，
<a href="~BROWSERS#copy-session-storage">複製される</a>。
◎
While creating a new auxiliary browsing context, the session storage area is copied over.
</p>

<p id="sessionStorageEvent">
~session~storage区画 %A に属する
`Storage$I ~obj %S に対し［
`setItem()$m ／ `removeItem()$m ／ `clear()$m
］~methodが呼出されたときは、その~methodにおいて［
例外が投出された, あるいは上述の “何もしないモノトスル” と定義されている
］ときを除き
⇒
次を満たすような各 `文書$ %文書 に向けて，`~storage通知を送信する$
⇒
［［
%文書 に`関連な大域~obj$の `sessionStorage$m 属性
］が返す `Storage$I ~obj
］は、［
%A に属する, かつ %S でない
］
<!-- 実際の~eventの配送先は Window -->
◎
When the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a session storage area, if the methods did not throw an exception or "do nothing" as defined above, then for every Document object whose relevant global object's sessionStorage attribute's Storage object is associated with the same storage area, other than x, send a storage notification.
</p>

		</section>
		<section id="the-localstorage-attribute">
<h3 title="The localStorage attribute">11.2.3. `localStorage^m 属性</h3>

<pre class="idl">
interface mixin `WindowLocalStorage@I {
  readonly attribute `Storage$I `localStorage$m;
};
`Window$I includes `WindowLocalStorage$I;
</pre>

<p>
~FINGERPRINTING
`localStorage@m
~objは、各 `生成元$ごとに `Storage$I ~objを供する。
◎
(This is a tracking vector.)
The localStorage object provides a Storage object for an origin.
</p>

<dl class="domintro">
	<dt>%window . `localStorage$m</dt>
	<dd>
その生成元†に属する~local~storage区画に結付けられている `Storage$I ~objを返す。
【† より明確には、 %window に`結付けられている文書$の`生成元$であろう。】
◎
Returns the Storage object associated with that origin's local storage area.
</dd>
	<dd>
次の場合、 `SecurityError$E 例外を投出する
⇒
`Document$I の`生成元$は`不透明な生成元$である ／
その要請は施策~裁定に違反する（例：~UAは、~pageが~dataを持続するのを許容しないよう，環境設定されている）
◎
Throws a "SecurityError" DOMException if the Document's origin is an opaque origin or if the request violates a policy decision (e.g. if the user agent is configured to not allow the page to persist data).
</dd>
</dl>


<p>
~UAは、各 `生成元$ごとに，専属の~local~storage区画をあてがうモノトスル。
◎
User agents must have a set of local storage areas, one for each origin.
</p>

<p>
~UAが~local~storage区画の~dataを失効させるのは、~security上の理由があるか, または利用者から要請された場合に限られるベキである。
~UAは、~dataに~accessし得る~scriptが走らせている間は，~dataを失効させないベキである。
◎
User agents should expire data from the local storage areas only for security reasons or when requested to do so by the user. User agents should always avoid deleting data while a script that could access that data is running.
</p>

<p class="idl-def">
`localStorage$m 属性に~accessされた際には、~UAは，以下に与える
<dfn id="storage-object-initialisation-steps">`Storage^I ~objの初期化~手続き</dfn>
を走らすモノトスル：
◎
When the localStorage attribute is accessed, the user agent must run the following steps, which are known as the Storage object initialization steps:
</p> 

<ol>
	<li>
任意選択で
⇒
~IF［
その要請は施策~裁定に違反している（例えば~UAの環境設定により、その~pageが~dataを持続するのは許容されていないなど）
］
⇒
~THROW `SecurityError$E
◎
If the request violates a policy decision (e.g. if the user agent is configured to not allow the page to persist data), the user agent may throw a "SecurityError" DOMException instead of returning a Storage object
</li>
	<li>
%O ~LET 属性が~accessされている`~window$に`結付けられている文書$の`生成元$
◎
↓</li>
	<li>
~IF［
%O は`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
◎
If the Document's origin is an opaque origin, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
%O には，~local~storage区画はあてがわれていない
］
⇒
新たな~storage区画を作成した上で，それを %O にあてがう
◎
Check to see if the user agent has allocated a local storage area for the origin of the associated Document of the Window object on which the attribute was accessed. If it has not, create a new storage area for that origin.
</li>
	<li>
~RET ［
%O にあてがわれている~local~storage区画
］に属する `Storage$I ~obj
— 各 `文書$は、それぞれ別個に，自身に`関連な大域~obj$の `localStorage$m 属性~用に `Storage$I ~objを持つモノトスル。
◎
Return the Storage object associated with that origin's local storage area. Each Document object must have a separate object for its relevant global object's localStorage attribute.
</li>
</ol>

<p id="localStorageEvent">
~local~storage区画 %A に属する
`Storage$I ~obj %S に対し［
`setItem()$m ／ `removeItem()$m ／ `clear()$m
］~methodが呼出されたときは、その~methodにおいて［
例外が投出された, あるいは上述の “何もしないモノトスル” と定義されている
］ときを除き
⇒
次を満たすような各 `文書$ %文書 に向けて，`~storage通知を送信する$
⇒
［［
%文書 に`関連な大域~obj$の `sessionStorage$m 属性
］が返す `Storage$I ~obj
］は、［
%A に属する, かつ %S でない
］。
◎
When the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a local storage area, if the methods did not throw an exception or "do nothing" as defined above, then for every Document object whose relevant global object's localStorage attribute's Storage object is associated with the same storage area, other than x, send a storage notification.
</p>

<p id="localStorageMutex">
`localStorage$m 属性は、共有されている状態への~accessを供する。
この仕様は、複数の閲覧文脈を同時に処理する~UAにおける，閲覧文脈~間の相互作用は定義しない。
よって，作者には、~lockする類の仕組みはないものと見做すことが奨励される。
一例として，~siteは、ある`~key$に対する`~value$を読取って, それを増やしてから，当の~session用の一意な識別子として書戻すこともできるが、これが 2 つの~windowで同時に行われた場合、両~session用に同じ “一意な” 識別子を利用する結果，破壊的な効果をもたらし得ることになる。
◎
The localStorage attribute provides access to shared state. This specification does not define the interaction with other browsing contexts in a multiprocess user agent, and authors are encouraged to assume that there is no locking mechanism. A site could, for instance, try to read the value of a key, increment its value, then write it back out, using the new value as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.
</p>

		</section>
		<section id="the-storage-event">
<h3 title="The storage event">11.2.4. `storage^et ~event</h3>

<p>
<a href="#sessionStorageEvent">§ ~session~storage</a>,
<a href="#localStorageEvent">§ ~local~storage</a>
に述べたように，~storage区画【の内容】が変化した際には、以下に述べるように，当の`文書$に`関連な大域~obj$に向けて `storage$et ~eventが発火されることになる。
◎
The storage event is fired on a Document object's relevant global object when a storage area changes, as described in the previous two sections (for session storage, for local storage).
</p>

<p>
~UAは，`文書$ %文書 に向けて
`~storage通知を送信する@
ときは、`~DOM操作~task源$から，次を走らす`~taskを~queueする$モノトスル
⇒
%文書 に`関連な大域~obj$に向けて，名前 `storage$et の`~eventを発火する$
— `StorageEvent$I ~interfaceを利用して
◎
When a user agent is to send a storage notification for a Document, the user agent must queue a task to fire an event named storage at the Document object's relevant global object, using StorageEvent.
</p>

<p class="note">注記：
%文書 が`全部的に作動中$であることは必要とされないが，そうでないときに発火された~eventは、
%文書 が再び`全部的に作動中$になるまでは，`~event~loop$からは無視される。
◎
Such a Document object is not necessarily fully active, but events fired on such objects are ignored by the event loop until the Document becomes fully active again.
◎
The task source for these tasks is the DOM manipulation task source.
</p>

<p>
この~eventが、次のいずれかの動作に応じて発火された場合
⇒
［［
`setItem()$m ／ `setItem()$m ／ `removeItem()$m
］~methodが呼出されて，`~item$ %~item が［
新たに追加された／更新された／除去された
］］, あるいは［
`clear()$m ~methodが呼出されて，`~item~list$が空にされた
］
◎終
~UAは、~eventの属性を，次に従って初期化するモノトスル：
◎
If the event is being fired due to an invocation of the setItem() or removeItem() methods,＼
</p>

<ul>
	<li>
<p>
［
`key$mE, `oldValue$mE, `newValue$mE
］属性は、次の表に従って初期化する：
</p>

<table><tbody><tr><td>動作
<td>`key$mE
<td>`oldValue$mE
<td>`newValue$mE

<tr><th>新たに追加された
<td>%~item の`~key$
<td>~NULL
<td>%~item の新たな`~value$

<tr><th>更新された
<td>%~item の`~key$
<td>%~item の~~元の`~value$
<td>%~item の新たな`~value$

<tr><th>除去された
<td>%~item の`~key$
<td>%~item の`~value$
<td>~NULL

<tr><th>空にされた
<td>~NULL
<td>~NULL
<td>~NULL

</tbody></table>

◎
the event must have its key attribute initialized to the name of the key in question, its oldValue attribute initialized to the old value of the key in question, or null if the key is newly added, and its newValue attribute initialized to the new value of the key in question, or null if the key was removed.
◎
Otherwise, if the event is being fired due to an invocation of the clear() method, the event must have its key, oldValue, and newValue attributes initialized to null.
</li>
	<li>
`url$mE 属性 ~SET ［
影響された `Storage$I ~objが属する文書
］の`~URL$doc【を文字列に直列化した結果】
◎
In addition, the event must have＼
◎
its url attribute initialized to the URL of the document whose Storage object was affected;＼
</li>
	<li>
`storageArea$mE 属性 ~SET ［
対象の`文書$に`関連な大域~obj$のそれと同種の（すなわち~sessionか~localか） `Storage$I 区画を表現する `Storage$I ~obj
］
◎
and its storageArea attribute initialized to the Storage object from the relevant global object of the target Document that represents the same kind of Storage area as was affected (i.e. session or local).
</li>
</ul>

<p class="trans-note">【
呼出された回数だけ~eventが配送されることになるが、例えば同じ`~item$の`~value$が続けて複数回~更新された場合に 1 個の~eventに集約されることは，あるかも？
】</p>


			<section id="the-storageevent-interface">
<h4 title="The StorageEvent interface">11.2.4.1. `StorageEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `StorageEvent@I : `Event$I {
  constructor(DOMString %type, optional `StorageEventInit$I %eventInitDict = {});

  readonly attribute DOMString? `key$mE;
  readonly attribute DOMString? `oldValue$mE;
  readonly attribute DOMString? `newValue$mE;
  readonly attribute USVString `url$mE;
  readonly attribute `Storage$I? `storageArea$mE;

  void `initStorageEvent$mE(DOMString %type, optional boolean %bubbles = false, optional boolean %cancelable = false, optional DOMString? %key = null, optional DOMString? %oldValue = null, optional DOMString? %newValue = null, optional USVString %url = "", optional Storage? %storageArea = null);
};

dictionary `StorageEventInit@I : `EventInit$I {
  DOMString? key = null;
  DOMString? oldValue = null;
  DOMString? newValue = null;
  USVString url = "";
  `Storage$I? storageArea = null;
};
</pre>

<dl class="domintro">
	<dt>%event . `key$mE</dt>
	<dd>
変更された`~item$の`~key$を返す。
◎
Returns the key of the storage item being changed.
</dd>

	<dt>%event . `oldValue$mE</dt>
	<dd>
変更された`~item$の前の`~value$を返す。
◎
Returns the old value of the key of the storage item whose value is being changed.
</dd>

	<dt>%event . `newValue$mE</dt>
	<dd>
変更された`~item$の新たな`~value$を返す。
◎
Returns the new value of the key of the storage item whose value is being changed.
</dd>

	<dt>%event . `url$mE</dt>
	<dd>
変更された`~item$を持つ~storageが属する文書の`~URL$doc【を文字列に直列化した結果】を返す。
◎
Returns the URL of the document whose storage item changed.
</dd>

	<dt>%event . `storageArea$mE</dt>
	<dd>
影響された `Storage$I ~objを返す。
◎
Returns the Storage object that was affected.
</dd>
</dl>


<dl class="idl-def">
	<dt>`key@mE</dt>
	<dt>`oldValue@mE</dt>
	<dt>`newValue@mE</dt>
	<dt>`url@mE</dt>
	<dt>`storageArea@mE</dt>
	<dd>
いずれも，取得子は、初期化-時の値を返すモノトスル。
◎
The key, oldValue, newValue, url, and storageArea attributes must return the values they were initialized to.
</dd>

	<dt>`initStorageEvent()@mE</dt>
	<dd>
被呼出時には、似た名前の `initEvent()$m ~methodと相似的な方式で，~eventを初期化するモノトスル。
`DOM$r
【構築子と機能が重複する旧来の~method】
◎
The initStorageEvent() method must initialize the event in a manner analogous to the similarly-named initEvent() method. [DOM]
</dd>
</dl>

			</section>
		</section>
	</section>
	<section id="disk-space-2">
<h2 title="Disk space">11.3. ~disk容量</h2>

<p>
~UAは、~storage区画に許容される総量を制限するベキである。
さもなければ、敵対的~作者は［
この特能を利用して，利用者の~disk容量を枯渇させる
］こともできてしまうので。
◎
User agents should limit the total amount of space allowed for storage areas, because hostile authors could otherwise use this feature to exhaust the user's available disk space.
</p>

<p>
~UAは、［
~siteが，その生成元の他の提携~siteの下で~dataを格納する
］ことからも，利用者を防護するベキである。
さもなければ、例えば
`a1.example.com^s,
`a2.example.com^s,
`a3.example.com^s,
等々 に許容される限界まで~dataを格納することにより，~mainの
`example.com^s
の~storage制限を迂回することが可能になるので。
◎
User agents should guard against sites storing data under their origin's other affiliated sites, e.g. storing up to the limit in a1.example.com, a2.example.com, a3.example.com, etc, circumventing the main example.com storage limit.
</p>

<p>
~UAは、~quotaの~~上限に到達した際には，より多くの容量を~siteにあてがうよう 利用者を促してもヨイ。
これにより，~siteは、一例として，利用者が作成した多数の文書~dataを 利用者の~computerに格納できるようになる。
◎
User agents may prompt the user when quotas are reached, allowing the user to grant a site more space. This enables sites to store many user-created documents on the user's computer, for instance.
</p>

<p>
~UAは、各~domainが占めている容量を，利用者が見れるようにするベキである。
◎
User agents should allow users to see how much space each domain is using.
</p>

  

<p>
`生成元$ごとに， 5 ~megabyte程度を上限にすることが示唆される。
この~~容量は，ほぼ恣意的なので、実装からの~feedbackを歓迎する。
その際には、この示唆は将来に更新されることになる。
◎
A mostly arbitrary limit of five megabytes per origin is suggested. Implementation feedback is welcome and will be used to update this suggestion in the future.
</p>

<p>
予測-可能にするため、~quotaは，格納-済み~dataの無圧縮時の~sizeに基づくベキである。
◎
For predictability, quotas should be based on the uncompressed size of data stored.
</p>


	</section>
	<section id="privacy">
<h2 title="Privacy">11.4. ~privacy</h2>

		<section id="user-tracking">
<h3 title="User tracking">11.4.1. 利用者の追跡</h3>

<p>
第三者主体の広告主（あるいは，複数の~siteに内容を流布し得る任意の主体）は、利用者の関心~profileを築き上げ，より~~高度な絞り込み広告を可能にする~~目的で、~local~storage区画に一意な識別子を格納することにより，複数の~sessionに渡って利用者を追跡し得る。
利用者の本当の身元を知っている~site（例えば認証情報を要する電子商取引~site）と~~連携した場合、不当な団体が，匿名な~Web用法よりも高い精度で個人を標的にすることも許容されてしまう。
◎
A third-party advertiser (or any entity capable of getting content distributed to multiple sites) could use a unique identifier stored in its local storage area to track a user across multiple sessions, building a profile of the user's interests to allow for highly targeted advertising. In conjunction with a site that is aware of the user's real identity (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous Web usage.
</p>

<p>
利用者~追跡の~riskを軽減するために利用できる、いくつかの技法がある：
◎
There are a number of techniques that can be used to mitigate the risk of user tracking:
</p>

<dl>
	<dt>
第三者主体による~storage~~利用を阻止する
◎
Blocking third-party storage
</dt>
	<dd>
~UAは、 `localStorage$m ~objへの~accessを，`~top-level閲覧文脈$にて`作動中の文書$の~domainを出自にしている~scriptに制約してもヨイ。
一例として、［
`iframe$e の中で走らせている 他の~domainからの~page
］に対しては，~APIへの~accessを否認するなど。
◎
User agents may restrict access to the localStorage objects to scripts originating at the domain of the active document of the top-level browsing context, for instance denying access to the API for pages from other domains running in iframes.
</dd>

	<dt>
格納-済み~dataを失効させる
◎
Expiring stored data
</dt>
	<dd>
~UAは、
— 場合によっては、利用者が環境設定する方式で —
一定期間を経過した格納-済み~dataは，自動的に削除されるようにしてもヨイ。
◎
User agents may, possibly in a manner configured by the user, automatically delete stored data after a period of time.
</dd>
	<dd>
例えば~UAは、第三者主体による~local~storage区画を~session用途のみと扱って，［
利用者が［
その~storageへ~accessし得るすべての`閲覧文脈$
］を閉じた時点で，~dataは削除される
］ように環境設定することもできる。
◎
For example, a user agent could be configured to treat third-party local storage areas as session-only storage, deleting the data once the user had closed all the browsing contexts that could access it.
</dd>
	<dd>
これにより，［
~siteが複数の~sessionに渡って利用者を追跡-可能になるのは、利用者が~site自身にて認証される場合（例えば購入予約や~serviceへの~log-inなど）に限られる
］ことになるので、~siteが利用者を追跡する能を制約できるようになる。
◎
This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when they authenticate with the site itself (e.g. by making a purchase or logging in to a service).
</dd>
	<dd>
しかしながら、持続的~storageの仕組みから得られる~APIの有用性も抑制する。
また、利用者が~dataの失効がもたらす~~影響について全部的に理解していない場合に，利用者の~dataを~riskにさらすことになる。
◎
However, this also reduces the usefulness of the API as a long-term storage mechanism. It can also put the user's data at risk, if the user does not fully understand the implications of data expiration.
</dd>

	<dt>
持続的~storageを~cookie同様に扱う
◎
Treating persistent storage as cookies
</dt>
	<dd>
利用者が［
~local~storage区画に格納されている~dataは残しつつ，~cookieを消去する
］ことで，自身の~privacyを保護する試みに対しては、~site側は［
両~特能を利用して相互に冗長backupする
］ことで打破できる。
~UAは、［
利用者が，この可能性について理解することを助ける仕方
］で［
持続的~storage特能における~dataすべてが，同時に削除されることが確保される
］ようにする~UIを呈示するベキである。
`COOKIES$r
◎
If users attempt to protect their privacy by clearing cookies without also clearing data stored in the local storage area, sites can defeat those attempts by using the two features as redundant backup for each other. User agents should present the interfaces for clearing these in a way that helps users to understand this possibility and enables them to delete data in all persistent storage features simultaneously. [COOKIES]
</dd>

	<dt>
~local~storageに~accessするための~site別 安全list
◎
Site-specific safelisting of access to local storage areas
</dt>
	<dd>
~UAは、~siteによる~session~storage区画への~accessは制約しない方式で，~local~storage区画への~accessについては 利用者からの~~許可を要するようにしてもヨイ。
◎
User agents may allow sites to access session storage areas in an unrestricted manner, but require the user to authorize access to local storage areas.
</dd>

	<dt>
格納-済み~dataからの生成元の追跡
◎
Origin-tracking of stored data
</dt>
	<dd>
~UAは、~dataを格納させた第三者主体の生成元からの内容を含んでいる~siteの`生成元$を記録してヨイ。
◎
User agents may record the origins of sites that contained content from third-party origins that caused data to be stored.
</dd>
	<dd>
この情報を利用して，持続的~storage内の現在の~dataについての~viewを呈示すれば、利用者にとって，持続的~storageのどの部分を取り除くか裁定を下す~~材料になる。
阻止listと併用すれば（
“この~dataを削除して、この~domainが再び~dataを格納しないようにする”
等）、利用者は，持続的~storageの利用を 信用できる~siteのみに制約できるようになる。
◎
If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that they trust.
</dd>

	<dt>
阻止listの共有-
◎
Shared blocklists
</dt>
	<dd>
~UAは、利用者~間で持続的~storageに関する~domainの阻止listを共有できるようにしてもヨイ。
◎
User agents may allow users to share their persistent storage domain blocklists.
</dd>
	<dd>
これにより、~communityは~privacy保護に向けて~~協同できるようになる。
◎
This would allow communities to act together to protect their privacy.
</dd>
</dl>

<p>
これらの示唆は、この~APIによる利用者~追跡~用の自明な利用は防止するが，まとめて阻止するものではない。
~siteは、単独の~domain内では，~sessionに渡って利用者を追跡し続けることができ、その情報を~siteが得した個人識別情報（~~名前, カード番号, 住所など）と伴に第三者主体に渡すこともあり得る。
第三者主体が，複数の~siteと協力してその種の情報を得したなら、依然として，~profileは作成され得る。
◎
While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.
</p>

<p>
しかしながら，利用者~追跡は、~UAからの協力が一切なくても，ある~~範囲までアリになる
— 一例として，~URL内に~session識別子を利用するなど。
この技法は、差し障りない目的で すでに共通的に利用されているが、利用者~追跡にも容易に（遡及的にすら）転用できる。
しかる後，この情報は、他~siteと共有され得る
— 訪問者の IP ~addressその他の，利用者に特有な~data（例： `User-Agent^h ~headerや環境設定）を利用して、別々の~sessionを首尾一貫した利用者~profileを成すように組合せることにより。
◎
However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.
</p>

		</section>
		<section id="sensitivity-of-data">
<h3 title="Sensitivity of data">11.4.2. ~dataの敏感~性</h3>

<p>
~UAは、持続的に格納された~dataを，敏感になり得るものと扱うベキである。
この仕組みを通して，［
メール, 予定表, 診断記録, その他の秘匿文書
］が格納されることは、ごく~~普通にあり得る。
◎
User agents should treat persistently stored data as potentially sensitive; it's quite possible for e-mails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.
</p>

<p>
最後に，~UAは、~dataを削除する際には，下層の~storageからも~~即座に削除されることを確保するベキである。
◎
To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.
</p>

		</section>
	</section>
	<section id="security-storage">
<h2 title="Security">11.5. ~security</h2>

		<section id="dns-spoofing-attacks">
<h3 title="DNS spoofing attacks">11.5.1. ~DNS偽装~攻撃</h3>

<p>
~DNS偽装~攻撃の下では、一定の~domainに属すると主張する~hostが本当にその~domainからのものであるかどうか，保証できなくなる可能性がある。
~TLSを利用すれば，これを軽減できる。
~TLSを利用する~pageは、［［
利用者, 利用者に利する~software, ［
証明書を伴う~TLSを利用していて, 同じ~domainからであるものと識別される，他の~page
］］のみが，それらの~storage区画に~access可能である
］ことの確証を得られる。
◎
Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use TLS. Pages using TLS can be sure that only the user, software working on behalf of the user, and other pages using TLS that have certificates identifying them as being from the same domain, can access their storage areas.
</p>

		</section>
		<section id="cross-directory-attacks">
<h3 title="Cross-directory attacks">11.5.2. ~cross-directory攻撃</h3>

<p>
同じ~host名を共有している作者たちは（例えば（今や~~機能しなくなったが） `geocities.com^s で内容を~hostしている作者たちなど）、全員が同じ~local~storage~objを共有することになる。
~pathnameにより~accessを制約する特能はないので、彼らのうち誰もが他の作者の~dataを読取ったり, 上書することが可能になる。
したがって，他者と~hostを共有している作者には、これらの特能の利用を避けることが督促される。
◎
Different authors sharing one host name, for example users hosting content on the now defunct geocities.com, all share one local storage object. There is no feature to restrict the access by pathname. Authors on shared hosts are therefore urged to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.
</p>

<p class="note">注記：
仮に~path制約の特能が可用にされたとしても、通例的な~DOM~scripting ~security~modelから、この保護を迂回して，任意の~pathからの~dataへ~accessすることは自明になる。
◎
Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this protection and access the data from any path.
</p>

		</section>
		<section id="implementation-risks">
<h3 title="Implementation risks">11.5.3. 実装における~risk</h3>

<p>
これらの持続的な~storage特能を実装するにあたっては、 2 つの首な~riskがある：
◎
The two primary risks when implementing these persistent storage features are＼
</p>

<ul>
	<li>
敵対的~siteが，他の~domainの情報を読取る~risk
◎
letting hostile sites read information from other domains, and＼
</li>
	<li>
敵対的~siteが情報を書込んだ後，他の~siteがその情報を読取る~risk
◎
letting hostile sites write information that is then read from other domains.
</li>
</ul>

<p>
第三者主体~siteの~domainからの読取りは想定されていない~dataに，そのような読取りを許した場合、`情報~漏洩^emになる。
例えば，ある~domainの利用者の~wishlistは、他の~domainによる絞り込み広告に利用され得る。
あるいは文書作成~siteにより格納された，利用者の作業中の秘匿文書が、競合企業の~siteに読まれてしまうなど。
◎
Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user's shopping wishlist on one domain could be used by another domain for targeted advertising; or a user's work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.
</p>

<p>
第三者主体~siteに，他の~domainの持続的~storageへの~dataの書込みを許した場合、同等に危険な，`情報~spoofing^emが生じる。
例えば、敵対的~siteが利用者の~wishlistに “item” を付け加えるなど。
あるいは，敵対的~siteにより利用者の~session識別子が既知な~IDに設定された場合、その~IDは被害者~siteにおける利用者の追跡に利用され得る。
◎
Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add items to a user's wishlist; or a hostile site could set a user's session identifier to a known ID that the hostile site can then use to track the user's actions on the victim site.
</p>

<p>
したがって，この仕様に述べた`生成元$~modelに厳密に従うことは、利用者の~securityにとり重要になる。
◎
Thus, strictly following the origin model described in this specification is important for user security.
</p>


		</section>
	</section>
</section>

</main>
