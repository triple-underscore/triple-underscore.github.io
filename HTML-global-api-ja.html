<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Web application APIs（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style type="text/css">

.arg-list {
	display: block;
	padding-left: 2em;
	white-space: pre-line;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		jA: 'abstract',
		sl: 'js-slot',
		h: 'header',
		E: 'error',
		U: 'code-point',
	};

	var tag_map = {
		I: 'code',
		E: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		s: 'samp',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		jA: 'span',
		U: 'span',
		sl: 'span',
		V: 'var',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'sl': // JS internal slot
	text = '[[' + text + ']]';
	break;
case 'U':
	text = 'U+' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-01-29
trans_update:2018-01-30
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/webappapis.html
nav_prev:WAPI
nav_next:HTMLnavigator
trans_1st_pub:2016-07-23

●●original_urls
dynamic-markup-insertion:https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html
timers:https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html
user-prompts:https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html
system-state-and-capabilities:https://html.spec.whatwg.org/multipage/system-state.html
images-2:https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html
animation-frames:https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html

●●original_id_map


dom-window-alert:dom-alert
dom-window-confirm:dom-confirm
dom-window-print:dom-print
dom-window-prompt:dom-prompt


●●link_map




	●IDL
Serializable:~HTMLcloning#serializable
Transferable:~HTMLcloning#transferable

I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
I.Function:~WEBIDL#Function
I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WindowOrWorkerGlobalScope:#windoworworkerglobalscope
I.TimerHandler:#timerhandler
I.DOMException:~WEBIDL#idl-DOMException

E.InvalidCharacterError:~WEBIDL#invalidcharactererror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SecurityError:~WEBIDL#securityerror
E.RangeError:~TC39#sec-native-error-types-used-in-this-standard-rangeerror

jA.HostEnsureCanCompileStrings:~WAPI#hostensurecancompilestrings(callerrealm,-calleerealm)
jA.IsDetachedBuffer:~TC39#sec-isdetachedbuffer

et.afterprint:~HTMLindex#event-afterprint
et.beforeprint:~HTMLindex#event-beforeprint

m.alert:#dom-window-alert
m.confirm:#dom-window-confirm
m.print:#dom-window-print
m.prompt:#dom-window-prompt

m.cancelAnimationFrame:#dom-window-cancelanimationframe
m.requestAnimationFrame:#dom-window-requestanimationframe

m.atob:#dom-atob
m.btoa:#dom-btoa

m.clearInterval:#dom-clearinterval
m.clearTimeout:#dom-cleartimeout
m.setInterval:#dom-setinterval
m.setTimeout:#dom-settimeout

m.origin:#dom-origin
m.self.origin:#dom-origin

m.document.close:~HTMLLS/dynamic-markup-insertion.html#dom-document-close
m.document.open:~HTMLLS/dynamic-markup-insertion.html#dom-document-open
m.document.write:~HTMLLS/dynamic-markup-insertion.html#dom-document-write

	■ImageBitmap
I.Blob:~FILEAPI#blob
I.CanvasImageSource:~HEcanvas#canvasimagesource
I.ColorSpaceConversion:#colorspaceconversion
I.ImageBitmap:#imagebitmap
I.ImageBitmapOptions:#imagebitmapoptions
I.ImageBitmapSource:#imagebitmapsource
I.ImageData:~HEcanvas#imagedata
I.ImageOrientation:#imageorientation
I.PremultiplyAlpha:#premultiplyalpha
I.ResizeQuality:#resizequality

m.NETWORK_EMPTY:~HEmedia#dom-media-network_empty
m.close:#dom-imagebitmap-close
m.colorSpaceConversion:#dom-imagebitmapoptions-colorspaceconversion
m.createImageBitmap:#dom-createimagebitmap
m.data:~HEcanvas#dom-imagedata-data
m.height:#dom-imagebitmap-height
m.imageOrientation:#dom-imagebitmapoptions-imageorientation
m.networkState:~HEmedia#dom-media-networkstate
m.premultiplyAlpha:#dom-imagebitmapoptions-premultiplyalpha
m.resizeWidth:#dom-imagebitmapoptions-resizewidth
m.resizeHeight:#dom-imagebitmapoptions-resizeheight
m.resizeQuality:#dom-imagebitmapoptions-resizequality
m.type:~FILEAPI#dfn-type
m.width:#dom-imagebitmap-width

e.canvas:~HEcanvas#the-canvas-element
e.img:~HEimages#the-img-element
e.video:~HEmedia#the-video-element
e.script:~HEscripting#the-script-element

l.default:#dom-premultiplyalpha-default
l.flipY:#dom-imageorientation-flipy
l.high:#dom-resizequality-high
l.low:#dom-resizequality-low
l.medium:#dom-resizequality-medium
l.pixelated:#dom-resizequality-pixelated
l.premultiply:#dom-premultiplyalpha-premultiply
l.~default0:#dom-colorspaceconversion-default
l.~none0:#dom-colorspaceconversion-none
l.~none1:#dom-imageorientation-none
l.none:#dom-premultiplyalpha-none

V.~resize横幅:#_resizewidth
V.~resize縦幅:#_resizeheight



	●
~forgiving-base64復号する:~INFRA#forgiving-base64-decode
~forgiving-base64符号化する:~INFRA#forgiving-base64-encode
同型に符号化する:~INFRA#isomorphic-encode

並列的:~HTMLINFRA#in-parallel

~animation~frame~callback識別子:#animation-frame-callback-identifier

~promptを示すかどうか決定する:#_determine-to-show-modal-prompt

作動中の~timer~list:#list-of-active-timers
~animation~frame~callback~list:#list-of-animation-frame-callbacks
文字列を任意選択で短縮する:#optionally-truncate-a-simple-dialog-string
読込み時に印刷する~flag:#print-when-loaded
印刷-時の手続き:#printing-steps
~animation~frame~callbackたちを走らす:#run-the-animation-frame-callbacks
~timer初期化~手続き:#timer-initialisation-steps
~timerの入子~level:#timer-nesting-level
~timer~task源:#timer-task-source

~task源:~WAPI#task-source
~task:~WAPI#concept-task
関連する設定群~obj:~WAPI#relevant-settings-object
入口~設定群~obj:~WAPI#entry-settings-object
一時停止-:~WAPI#pause
~queueする:~WAPI#queue-a-task
~classic~scriptを走らす:~WAPI#run-a-classic-script
~classic~scriptを作成する:~WAPI#creating-a-classic-script
環境~設定群~obj:~WAPI#environment-settings-object
小task:~WAPI#microtask
例外を報告する:~WAPI#report-the-exception
~event-loop:~WAPI#event-loop
enV.生成元:~WAPI#concept-settings-object-origin
~module~script:~WAPI#module-script
作動中の~script:~WAPI#active-script
~script~fetch~options:~WAPI#script-fetch-options
sC.基底~URL:~WAPI#concept-script-base-url
sC.~fetch~options:#concept-script-script-fetch-options
sfO.暗号用~nonce:~WAPI#concept-script-fetch-options-nonce
sfO.完全性~metadata:~WAPI#concept-script-fetch-options-integrity
sfO.構文解析器~metadata:~WAPI#concept-script-fetch-options-parser
sfO.資格証~mode:~WAPI#concept-script-fetch-options-credentials
sfO.~referrer施策:~WAPI#concept-script-fetch-options-referrer-policy



閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
	属する~閲覧文脈:~WINDOW#concept-document-window
全部的に作動中:~BROWSERS#fully-active
入子の閲覧文脈:~BROWSERS#nested-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
作動中の文書:~BROWSERS#active-document

結付けられている文書:~WINDOW#concept-document-window
結付けている~window:~WINDOW#concept-document-window

作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
~sandbox化( ~modal )~flag:~ORIGIN#sandboxed-modals-flag
生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

~media~data:~HEmedia#media-data
~media要素:~HEmedia#media-element

物理形を得る:~HTMLrendering#obtain-a-physical-form

js.現在の~Realm~Record:~TC39#current-realm
js.~JS~realm:~TC39#sec-code-realms
c.eval():~TC39#sec-eval-x
c.import():https://tc39.github.io/proposal-dynamic-import/#sec-import-calls

x.呼出す:~WEBIDL#es-invoking-callback-functions
x.~callback this 値:~WEBIDL#dfn-callback-this-value


終了の入子~level:~NAVI#termination-nesting-level
読込み後~taskは準備済み:~HTMLparsing#ready-for-post-load-tasks

	●dynamic markup
動的~markup挿入-時には投出する~counter:#throw-on-dynamic-markup-insertion-counter
~unload中の~openは無視する~counter:#ignore-opens-during-unload-counter
破壊的書込は無視する~counter:#ignore-destructive-writes-counter

~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
~HTML構文解析器:~HTMLparsing#html-parser
~XML構文解析器:~HTMLxml#xml-parser
~tokenから要素を作成-:~HTMLparsing#create-an-element-for-the-token
~custom要素~構築子:~HEcustom#custom-element-constructor
~unload:~NAVI#unload-a-document

	●ImageBitmap
~bitmap~dataを取得する:#_get-a-bitmap-data-from-image
代表する~bitmap~data:#_get-a-bitmap-data-from-animated-image

~bitmap~data:#concept-imagebitmap-bitmap-data
~source矩形に切抜いて整形する:#cropped-to-the-source-rectangle-with-formatting
全部的に復号-可能:#concept-imagebitmap-good

~CORS非同一生成元:~HTMLurl#cors-cross-origin
~CSS~pixel:~CSSVAL#px
透明な黒:~CSSCOLOR#transparent-black

転送-可能:~HTMLcloning#transferable-objects
直列化-可能:~HTMLcloning#serializable-objects
sl.Detached:~HTMLcloning#detached

~SVG-image:~SVG11/struct.html#ImageElement
現在の再生位置:~HEmedia#current-playback-position
	:~HTMLdep#file-error-read
画像~sniff時の規則:~MIMESNIFF#rules-for-sniffing-images-specifically
内在的~寸法:~CSS2CONFORM#intrinsic
	https://drafts.csswg.org/css2/conform.html#intrinsic
内在的~横幅:~CSS2CONFORM#intrinsic
	~HTMLdep#intrinsic-width
内在的~縦幅:~CSS2CONFORM#intrinsic
	~HTMLdep#intrinsic-height

video.内在的~縦幅:~HEmedia#concept-video-intrinsic-height
video.内在的~横幅:~HEmedia#concept-video-intrinsic-width
	
~media資源:~HEmedia#media-resource
生成元clean~flag:~HEcanvas#concept-canvas-origin-clean


~eventを発火-:~DOM4#concept-event-fire

解決する:~PROMISES#resolve-promise
却下する:~PROMISES#reject-promise
新たな~promise:~PROMISES#a-new-promise
却下される~promise:~PROMISES#a-promise-rejected-with

転送-手続き:~HTMLcloning#transfer-steps
転送-受信-時の手続き:~HTMLcloning#transfer-receiving-steps
直列化~手続き:~HTMLcloning#serialization-steps
逆直列化~手続き:~HTMLcloning#deserialization-steps


●●words_table1


none0:none
none1:none
default0:default
this:<b>this</b>
SVG-image:SVG <code class="element">image</code>


●●words_table



	●JS／event／IDL／task／script／大域
window:
JS:JavaScript
Realm:
Record:
event::::イベント
event-loop:event loop:::イベントループ
task::::タスク
小task:microtask::小 task:小タスク
call:
	~call元:caller
	~call先:callee
catch:
callback:
入口:entry::~
entry::::エントリ
mixin:
script::::スクリプト
obj:object:::オブジェクト
realm:
worker::::
code::::コード
classic::::クラシック
module::::モジュール
compile::::コンパイル
	compilation
method::::メソッド

取得子:getter:~
呼出し:invocation:呼び出し
呼出せな:invoke できな:呼び出せな
呼出した:invoke した:呼び出した
呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
設定-:set:~
設定群:settings:~
投出:throw:~
発火-:fire:~
被呼出時:被 invoke 時:~
走らす:run する:~
走って:run して:~
遂行-:perform:~
完了-:complete:~
実行-:execute:~
報告-:report::~
閲覧文脈:browsing context::~
源:source::~::ソース
並列的:parallel:~
例外:exception:~
大域:global::~::グローバル
引数:argument:~
現在の:current:~
現在:currently:~
現在は:currently:~
環境:environment:~
関連する:relevant な:~
文脈:context:~
停滞-:stall:~
準備済み:ready:~
一時停止-:pause::~::ポーズ
中止-:abort:~
queue::::キュー
待機-:wait:~

	●btoa
Unicode:::
base64:
forgiving-base64:
binary::::バイナリ
bit::::ビット
byte::::バイト
octet::::オクテット
data::::データ
文字:character:~
文字列:string:~
出力:output:~
入力:input:~
空:empty:~
符号位置:code point:~
復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
同型:isomorphic::~
変換-:convert:~
変換:conversion:~
変形-:transform:変換
範囲:range:~
	範囲~外:out-of-range
妥当:valid:~
空白:whitespace:~
ASCII:
英数字:alphanumerics:~
	語呂的には:mnemonic purposess
失敗:failure:~

	●prompt／印刷
PDF:::
alert:
prompt:
	Cancel
	Click
	OK
modal::::モーダル
message::::メッセージ
阻止-:block::~::ブロック
control::::コントロール
dialog::::ダイアログ
訊ねる:ask する:~
退ける:dismiss する:~
sandbox::::サンドボックス
click::::クリック
clear::::
選択肢:option:~
	肯定か否定:positive／negative／negatively／positively
任意選択:option:~
kiosk:
短縮-:truncate:~
省かれ:elide され:~
黙って:silent に:~
保存:save:~
	何段階かにわたる手続きを踏むthrough the steps of applying for a home loan

印刷:print::~::プリント
印刷-:print::~::プリント
	印刷-法／印刷-用:printing
	印刷-後の:post-printing
印刷機:printer::~::プリンタ
取消す:cancel する::取り消す::キャンセルする
取消した:cancel した::取り消した::キャンセルした
機会:opportunity:~
機器:device:~
復帰-:revert:~
応答-:respond:~
応答:response:~
手入力-:enter:~
注釈:annotation:~
	注釈を加える:annotate

	進める:advance
	部位:portion:~
物理形:physical form:~
	-:earlier
辞退-:decline:~



	●timer/animation
animation::::アニメーション
schedule::::スケジュール
	:time
timeout::::タイムアウト
timer::::タイマー
interval:
時刻印:timestamp::~::タイムスタンプ
milli::::ミリ
	milli秒:millisecond
	過ぎる:pass:~
	開始-:start:~
前回handle:previous handle:前回の handle
節電:low-power:~
電力消費:power usage:~
mode::::モード
入子:nesting:入れ子
入子に:nest:入れ子に
入子の:nested:入れ子の
負荷:load:~
	~UIに応じる余裕を与える:yielding back to avoid starving the user interface
	時間を得る:hogging
	強制終了:kill
延期:delay:~
休止-:suspend:~
連続的:consecutively:~
識別子:identifier:~

	時間:length of time.
	~~延長 pad
	時点を過ぎて~pointを~past
	なることはない not 〜 one way or the other
	存続する限り:lifetime
繰返:repeat::繰り返し
繰返しの:repeating::繰り返し続ける
	遅める＊ slow down
	間断なくback to back
	予め~schedule:preschedule
予期-:expect:~


	●仕様
API:
algo:algorithm:::アルゴリズム
UA:user agent:UA
UI:
model::::モデル
support::::サポート
下位手続き:substeps:~
不自然:unnatural:~
理由:reason:~
仕方:way:~
作者:author:~
依存-:depend:~
依拠-:rely:~
	依拠-可能:reliable
	依然として:still:~
保証:guarantee:~
仕事:work:~
	利用-:use:~
利用者:user:~
制限-:limit:~
受容-:accept:~
	受容-可能:acceptable
問題0:matter:問題
奨励-:encourage:~
定義-:define:~
実施:practice:~
実装-:implement:~
	易く:easy
強く:strong に:~
強制-:force:~
	必然:necessarily:~
	必要-:need:~
手続き:steps:~
技術的:technical:~
抑える:reduce する:~
拡張-:extend:~
供-:provide:~
提供-:offer:~
既定の:default:~
	defaulted:~
標準:standard:~
最適化-:optimize:~
正確0:accurate:正確
正確:exact:~
歴史的:historical:~
段:step:~
導出-:derive:~
有用:useful:~
濫用-:abuse:~
特定0の:particular:ある特定の
粒度:granularity:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付けた:associate した:結び付けた
結付けて:associate して:結び付けて
能力:capabilities:~
自動的:automatic:~
詳細:details:~
適切:appropriate:~
適用-:apply:~
	-:avoid
開発者:developer:~
	考える:Imagine
	考えられ:consider
	主に:primarily
	ある-:contain:~
	~~可能性:potential
	具体例として:for instance
	ちっぽけな:rather silly
	したがって:thus

	■ImageBitmap
一般:general:~
義務付けな:mandate しな:~
要求-:require:~
解釈-:interpret:~
許容-:allow:~
特有:-specific:~
特定の:specific な:~
予期-:expect:~
仕様:spec:~
判定:judgement:~
判断-:deem:~
実装:implementation:~
実装者:implementer:~
実際:actual:~
意味-:mean:~
指定-:specify:~
	指定されていない:unspecified:~
指示-:indicate:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
最適:optimal:~
比較的:relative に:~
単純:simple:~
効果:effect:~
確保-:ensure:~

	●未分類（動詞

初期:initial:~
初期化:initialization:~
決定-:determine:~
処理-:process:~
処理:processing:~
参照-:reference:~
反復:iteration:~
付加-:append:~
作成-:create:~
公開-:expose:~
存在:existence:~
	認める:acknowledge:~
指示子:indicator:~
挿入-:insert:~
挿入:insertion:~
	挿入-時:insertion
改変:modification:~
改変-:modify:~
検出-:detect:~
無視-:ignore:~
無視r:disregard:無視することに
終了の:termination:~
	混在する:combination
	継続-:continue:~
置換-:replace:~
表現-:represent:~
表現:representation:~
表示-:display:~
読込み:load:読み込み
	読込み後:post-load:~
読込んで:load して:読み込んで
読込まれ:load され:読み込まれ
識別-:identify:~
追加-:add:~
除去-:remove:~
継続-:continue:~
起動元:initiating::~
検査-:check:~

	●未分類

referrer::::リファラ
nonce::::ナンス
暗号用:cryptographic::~
完全性:integrity::~
資格証:credentials::資格証明情報::クレデンシャル
施策:policy::~:ポリシー

URL:
基底:base::~
fetch:
options:::option 集

	CPU
	Show More
browser::::ブラウザ
flag::::フラグ
frame::::フレーム
level::::レベル
list::::リスト
logic::::ロジック
markup::::マークアップ
media::::メディア
mobile:::携帯
platform::::プラットフォーム
processor::::プロセッサ
proxy::::プロキシ
source::::ソース
system::::システム
text::::テキスト
	0:zero
保安:security::~:セキュリティ

生成元:origin::~::オリジン
生成元clean:origin-clean::~::オリジン-clean
非同一生成元:cross-origin::~::クロスオリジン
同一生成元:same-origin::~::同一オリジン

要素:element:~
集合:set:~
子孫:descendant:~
一意:unique:~
値:value:~
全部的:full:~
内容:content:~
	再度:again:~
名:name:~
名前:name:~
安全:safe:~
属性:attribute:~
	後:after:~
整数:integer:~
文書:document:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ

状態:state:~
複製:copy:~
頁:page:::ページ
等価:equivalent:~
在する:present する:在る

	order
	now:
	setting:設定
	consisting
	:indeed
	:lot
	:part
	:past
	:point
	:potential
	:shorter
	踏んで:walking
	べき:should
	もっともらしい:trustworthy-looking
	所与の:given
	与-:give
	中略して:replace the middle of
	巨大:large
	戻-:back
	数:number
	求め:want
	渡-:pass
	用の便利:utility
	示す:show
	種:type
	起こる:happen
	近くに:in the vicinity
	返す:return

	●dynamic markup
open:
動的:dynamic:~
内部:internal:~
外部:external:~
構文解析器:parser::~::パーサ
相互作用-:interact::~
HTML:
XML:
counter::::カウンタ
token::::トークン
custom::::カスタム
unload:
直接的:direct:~
間接的:indirect:~
暗黙的:implicit:~
破壊的書込:destructive-writes:破壊的な書き込み
	吹き飛ばすblow away
	併用:used in conjunction with
	変わる:varies

	●ImageBitmap
CORS:
CSS:
	EXIF
	GPU
	Lanczos
MIME:
	RAM
access::::アクセス
alpha::::アルファ
animated::::アニメート化
bitmap::::ビットマップ
canvas:
	cell:
channel::::チャンネル
	計算量:computationally
	壊れている:corrupted
切抜いて:crop して:切り抜いて
切抜かれ:crop され:切り抜かれ

disk::::ディスク
error::::エラー
file::::ファイル
graphic::::グラフィック
local::::ローカル
member::::メンバ
metadata::::メタデータ
native::::ネイティブ
network::::ネットワーク
option::::オプション
pixel::::ピクセル
画素:pixel:~:::ピクセル
profile::::プロファイル
size::::サイズ
resize::::リサイズ
sniff::::
sprite-sheet:sprite sheet:::スプライトシート

promise::::
slot::::スロット
vector::::ベクター
worker::::
logic::::ロジック
規則:rule:~
完全:complete:~
可用:available:~
資源:resource::~:リソース
動画:video::~::ビデオ
整形-:format:~
	復号-可能:decodable
転送-:transfer::~
	転送-可能:transferable
受信-:receive::~
直列化-:serialize::~::シリアル化
直列形:serialized::~::シリアル形
直列化:serialization::~::シリアル化
	直列化-可能:serializable
逆直列化:deserialization::~::逆シリアル化
保持体:holder::~::ホルダ

透明:transparent:~
黒:black:~
再生位置:playback position:~
下層の:underlying:~
不能化-:disable:~
位置:position:~
内在的:intrinsic:~
原点:origin:~
列挙型:enumeration:~
	占める:occupy する
却下-:reject:~
双三次:bicubic:~
双線形:bilinear:~
	上端:top:~
	右端:right:~
	左端:left:~
品質:quality:~
型:type:~
埋込まれ:embed され:埋め込まれ
塗れる:paint できる:~
	:transform
変更-:change:~
変化-:change:~
外観:appearance:~
	中間:medium:~
寸法:dimension:~
将来的:future:~
平面:plane:~
座標:coordinate:~
形式:format:~
成分:component:~
成功裡:successful:~
拡縮-:scale:~
拡縮:scaling:~
描く:draw する:~
描画-:render:~
新たな:new:~
方位:orientation:~
	:grid
構築-:construct::~
構築子:constructor::~::コンストラクタ
縦幅:height:~
横幅:width:~
	縦向き:vertically
	:horizontal
縦横比:aspect-ratio:~
準備-:prepare:~
無限の:infinite:~
生産-:produce:~
画像:image:~
矩形:rectangle:~
除算-:divide:~
乗算-:multiply:~
乗算済み:premultiplied:~
	乗算済みにするかどうかpremultiplication behavior
空間:space:~
	:place
色:color:~
表示:display:~
補正:correction:~
補間:interpolation:~
解放-:release:~
解決-:resolve:~
読取る:read する:読み取る
読取った:read した:読み取った
読取り:read:読み取り
遅延:latency:~
過度の:undue:~
選好:preference:~
高速:fast:~
裏返す:flip する:~

	無い:missing
阻む:block する:~
公式的な:official:~
滑らか:smooth:~
	滑らかに補間する-smoothing
	終えるまで他を阻む:blocking
	選ばれ:chosen
	clip
	何もしない:no extra step is required
	fatal way
	giving
	increasing
	~point
	事前に切り分けて:precut:
	染まって:tainted
	taken
	左上隅:top-left corner
	ε:unset
	efficient

	隅:corner:~
	多くexpensive:~
	異なる:different:~
	できるだけ保つ:maximize:~
	委ねられ:left up to
	一方で:whereas
	あり得る:possible
	指す:pointing at
	基づいて:guide
	利用時:making use
	おそらく:probably
	しかしながら，:however
	例:example
	得る:obtain
	色:color
	表す:express
	高:high

	●指示語
	〜の代わりに:instead
	個目:second／third
	0:zero
	4:four
	:one
	:two
	いくつかの:several
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	それらの:their
	両者:both
	他の:other
	以降の:subsequent
	後:after
	前:before
	前者:former
	各:each
	同じ:same
	対応-:correspond
	:follow
	後者:latter
	更なる:further
	最初の:first
	次回の:next
	終端:end
	結果:result
	自身:itself
	通:through
	別の:another
	より低:lower
	より高:higher
	上:above
	低:low
	元の:original
	各:each
	常に:always
	介して:via



●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">Web application APIs</a>
章の一部の節を日本語に翻訳したものです。
この翻訳の正確性は保証されません。
~PUB
</p>

</script>



</head>
<body>

<header id="head">
	<hgroup>
<h1>Web application APIs</h1>

	</hgroup>
</header>

<main id="MAIN" style="display:none;">


		<section id="scripting">
<h2 title="Scripting">8.1. Scripting</h2>

<p class="trans-note">【
この節の和訳は、
<a href="~WAPI#scripting">別ページ</a>
にて。
】</p>
		</section>
		<section id="windoworworkerglobalscope-mixin">
<h2 title="The WindowOrWorkerGlobalScope mixin">8.2. `WindowOrWorkerGlobalScope^I ~mixin</h2>

<p>
`WindowOrWorkerGlobalScope$I ~mixinは、
`Window$I, `WorkerGlobalScope$I
両~obj上に公開されることになる~APIを利用するためにある。
◎
The WindowOrWorkerGlobalScope mixin is for use of APIs that are to be exposed on Window and WorkerGlobalScope objects.
</p>


<p class="note">注記：
他の標準は、
<code>partial interface `WindowOrWorkerGlobalScope$I { … };</code>
を利用して，適切な参照-とともに更に拡張することが奨励される。
◎
Other standards are encouraged to further extend it using partial interface WindowOrWorkerGlobalScope { … }; along with an appropriate reference.
</p>

<pre class="idl">
typedef (DOMString or `Function$I) `TimerHandler@I;

interface mixin `WindowOrWorkerGlobalScope@I {
  [Replaceable] readonly attribute USVString `origin$m;

  // base64 utility methods
  DOMString `btoa$m(DOMString %data);
  ByteString `atob$m(DOMString %data);

  // timers
  long `setTimeout$m(
      `TimerHandler$I %handler,
      optional long %timeout = 0,
      any... %arguments
  );
  void `clearTimeout$m(optional long %handle = 0);
  long `setInterval$m(
      `TimerHandler$I %handler,
      optional long %timeout = 0,
      any... %arguments
  );
  void `clearInterval$m(optional long %handle = 0);

  // ImageBitmap
  Promise&lt;`ImageBitmap$I&gt; `createImageBitmap$m(
      `ImageBitmapSource$I %image,
      optional `ImageBitmapOptions$I %options
  );
  Promise&lt;`ImageBitmap$I&gt; `createImageBitmap$m(
      `ImageBitmapSource$I %image,
      long %sx, long %sy, long %sw, long %sh,
      optional `ImageBitmapOptions$I %options
  );
};
`Window$I includes `WindowOrWorkerGlobalScope$I;
`WorkerGlobalScope$I includes `WindowOrWorkerGlobalScope$I;
</pre>

<dl class="domintro">
	<dt>%origin = self . `origin$m</dt>
	<dd>
当の大域~objの`生成元$を文字列に直列化した結果を返す。
◎
Returns the global object's origin, serialized as string.
</dd>
</dl>


<div class="example">
<p>
開発者には `location.origin^m より `self.origin$m を利用することが強く奨励される。
`self.origin^m は 環境の`生成元$を返す一方で、前者は 環境の~URLのそれを返す。
`https://stargate.example/^c 上の文書~内にて実行している次の~scriptを考える：
◎
Developers are strongly encouraged to use self.origin over location.origin. The former returns the origin of the environment, the latter of the URL of the environment. Imagine the following script executing in a document on https://stargate.example/:
</p>

<pre>
var %frame = document.createElement("iframe")
%frame.onload = function() {
  var %frameWin = %frame.contentWindow
  console.log(%frameWin.location.origin) // "null"
  console.log(%frameWin.origin) // "https://stargate.example"
}
document.body.appendChild(%frame)
</pre>


<p>
`self.origin$m は、より依拠-可能な保安~指示子である。
◎
self.origin is a more reliable security indicator.
</p>

</div>

<dl class="idl-def">
	<dt>`origin@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`生成元を直列化する$( 此れに`関連する設定群~obj$の`生成元$enV )
◎
The origin attribute's getter must return this object's relevant settings object's origin, serialized.
</dd>
</dl>


		</section>
		<section id="atob">
<h2 title="Base64 utility methods">8.3. ~base64用の便利~method</h2>

<p>
`atob()$m ／ `btoa()$m
~methodにより、内容~dataと~base64符号化方式との間で相互に変形できるようになる。
◎
The atob() and btoa() methods allow developers to transform content to and from the base64 encoding.
</p>


<p class="note">注記：
これらの~method名は、語呂的には "b" は "binary", "a" は "ASCII" を表すと考えられるが、主に歴史的~理由から，実施においては入力, 出力のいずれも ~Unicode文字列である。
【 `atob()^m が返す値は `ByteString^I 型に改められたが（過去には `DOMString^I 型だった）、いずれにせよ，~JS側においては文字列になる。】
◎
In these APIs, for mnemonic purposes, the "b" can be considered to stand for "binary", and the "a" for "ASCII". In practice, though, for primarily historical reasons, both the input and output of these functions are Unicode strings.
</p>

<dl class="domintro">
	<dt>%result = self . `btoa( data )$m</dt>
	<dd>
各 文字が［
範囲 { 0x00 〜 0xFF } の同じ値をとる~binary~byte
］を表現しているような，~Unicode文字列の形をとる［
範囲 { `0000^U 〜 `00FF^U } の文字のみからなる入力~data
］を，その~base64表現に変換した結果を返す。
◎
Takes the input data, in the form of a Unicode string containing only characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, and converts it to its base64 representation, which it returns.
</dd>
	<dd>
入力~文字列~内に範囲~外の文字がある場合、
`InvalidCharacterError$E 例外が投出される。
◎
Throws an "InvalidCharacterError" DOMException exception if the input string contains any out-of-range characters.
</dd>

	<dt>%result = self . `atob( data )$m</dt>
	<dd>
~Unicode文字列の形をとる［
~base64に符号化された ~binary~data
］を包含する入力を，［
範囲 { `0000^U 〜 `00FF^U } の文字のみからなる~Unicode文字列
］に復号した結果を返す
— 各 文字が［
範囲 { 0x00 〜 0xFF } の同じ値をとる~binary~byte
］を表現しているような。
◎
Takes the input data, in the form of a Unicode string containing base64-encoded binary data, decodes it, and returns a string consisting of characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, corresponding to that binary data.
</dd>
	<dd>
入力~文字列が妥当な~base64~dataでない場合、
`InvalidCharacterError$E 例外が投出される。
◎
Throws an "InvalidCharacterError" DOMException if the input string is not valid base64 data.
</dd>
</dl>


<dl class="idl-def">
	<dt>`btoa(data)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The btoa(data) method must＼
</p>

		<ol>
			<li>
~IF［
%data 内に［
符号位置 ~GT `00FF^U
］なる文字がある
］
⇒
~THROW `InvalidCharacterError$E
◎
throw an "InvalidCharacterError" DOMException if data contains any character whose code point is greater than U+00FF.＼
</li>
			<li>
~RET `~forgiving-base64符号化する$( `同型に符号化する$( %data ) )
◎
Otherwise, the user agent must convert data to a byte sequence whose nth byte is the eight-bit representation of the nth code point of data, and then must apply forgiving-base64 encode to that byte sequence and return the result.
</li>
		</ol>
	</dd>

	<dt>`atob(data)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The atob(data) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
%結果 ~LET `~forgiving-base64復号する$( %data )
◎
Let decodedData be the result of running forgiving-base64 decode on data.
</li>
			<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒
~THROW `InvalidCharacterError$E
◎
If decodedData is failure, then throw an "InvalidCharacterError" DOMException.
</li>
			<li>
~RET %結果
◎
Return decodedData.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="dynamic-markup-insertion">
<h2 title="Dynamic markup insertion">8.4. 動的~markup挿入</h2>

<p class="note">注記：
~markupを文書の中へ動的に挿入するための~APIは、構文解析器と相互作用するので，それらの挙動は［
`~HTML文書$（および`~HTML構文解析器$）,
`~XML文書$（および`~XML構文解析器$）
］のいずれに利用されるかに依存して，変わる。
◎
APIs for dynamically inserting markup into the document interact with the parser, and thus their behavior varies depending on whether they are used with HTML documents (and the HTML parser) or XML documents (and the XML parser).
</p>

<p>
各 `文書$は、次の各種~counterを持つ
— いずれも、初期~時には 0 に設定され~MUST
【これらは、 0 でないとき，効果を発揮する】
：
◎
↓</p>

<dl class="def-list">
	<dt>`動的~markup挿入-時には投出する~counter@</dt>
	<dd>
`~tokenから要素を作成-$する~algoと併用され、文書の構文解析器から呼出された`~custom要素~構築子$が，［
`document.open()$m,
`document.close()$m,
`document.write()$m
］を利用できなくするためにある。
◎
Document objects have a throw-on-dynamic-markup-insertion counter, which is used in conjunction with the create an element for the token algorithm to prevent custom element constructors from being able to use document.open(), document.close(), and document.write() when they are invoked by the parser. Initially, the counter must be set to zero.
</dd>

	<dt>`~unload中の~openは無視する~counter@</dt>
	<dd>
文書を`~unload$している間に，~scriptが `document.open()$m ~methodを（直接的にも間接的にも）呼出せなくするためにある。
◎
Document objects have an ignore-opens-during-unload counter, which is used to prevent scripts from invoking the document.open() method (directly or indirectly) while the document is being unloaded. Initially, the counter must be set to zero.
</dd>

	<dt>`破壊的書込は無視する~counter@</dt>
	<dd>
`script$e 要素の処理と併用され、外部~scriptが `document.write()$m を用いて暗黙的に `document.open()$m を~callすることにより文書を吹き飛ばすのを，防ぐためにある。
◎
Document objects have an ignore-destructive-writes counter, which is used in conjunction with the processing of script elements to prevent external scripts from being able to use document.write() to blow away the document by implicitly calling document.open(). Initially, the counter must be set to zero.
</dd>
</dl>

<p class="trans-note">【
以下，この節の他の内容（~APIとその処理~model）は、未訳。
（<a href="https://momdo.github.io/html/dynamic-markup-insertion.html#dynamic-markup-insertion">他サイト訳</a>）
】</p>


		</section>
		<section id="timers">
<h2 title="Timers">8.5. ~timer</h2>

  
<p>
`setTimeout()$m ／
`setInterval()$m
~methodにより、作者は，~timerに基づく~callbackを~scheduleできるようになる。
◎
The setTimeout() and setInterval() methods allow authors to schedule timer-based callbacks.
</p>

<dl class="domintro">
	<dt>%handle = self . `setTimeout( handler [, timeout [, arguments... ] ] )$m</dt>
	<dd>
%timeout ~milli秒~後に
%handler を走らす~timeoutを~scheduleする。
%arguments は そのまま %handler に渡される。
◎
Schedules a timeout to run handler after timeout milliseconds. Any arguments are passed straight through to the handler.
</dd>

	<dt>%handle = self . `setTimeout( code [, timeout ] )$m</dt>
	<dd>
%timeout ~milli秒~後に
%code を~compileして走らす~timeoutを~scheduleする
◎
Schedules a timeout to compile and run code after timeout milliseconds.
</dd>
	<dt>self . `clearTimeout( handle )$m</dt>
	<dd>
［
`setTimeout()$m ／ `setInterval()$m
により設定された~timeout
］のうち， %handle で識別されるものを取消す。
◎
Cancels the timeout set with setTimeout() or setInterval() identified by handle.
</dd>

	<dt>%handle = self . `setInterval( handler [, timeout [, arguments... ] ] )$m</dt>
	<dd>
%timeout ~milli秒ごとに
%handler を走らす~timeoutを~scheduleする。
%arguments は そのまま %handler に渡される。
◎
Schedules a timeout to run handler every timeout milliseconds. Any arguments are passed straight through to the handler.
</dd>

	<dt>%handle = self . `setInterval( code [, timeout ] )$m</dt>
	<dd>
%timeout ~milli秒ごとに
%code を~compileしてを走らす~timeoutを~scheduleする。
◎
Schedules a timeout to compile and run code every timeout milliseconds.
</dd>

	<dt>self . `clearInterval( handle )$m</dt>
	<dd>
［
`setTimeout()$m ／ `setInterval()$m
により設定された~timeout
］のうち， %handle で識別されるものを取消す。
◎
Cancels the timeout set with setInterval() or setTimeout() identified by handle.
</dd>
</dl>

<p class="note">注記：
~timerは、入子にできる。
ただし、そのような入子にされた~timerが 5 個を超えて以降は，~intervalは、 4 ~milli秒~以上に強制される。
◎
Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.
</p>

<p class="note">注記：
この~APIは、~timerが正確に~schedule通りに走らすことは保証しない。
CPU 負荷, 他の~task, 等々に因る延期が予期される。
◎
This API does not guarantee that timers will run exactly on schedule. Delays due to CPU load, other tasks, etc, are to be expected.
</p>

<p>
`WindowOrWorkerGlobalScope$I
~mixinを実装する~objは、
`作動中の~timer~list@
を持つ。
この~list内の各~entryは、
数で識別される。
それらの数は、~objが存続する限り，~listの中で一意で~MUST。
◎
Objects that implement the WindowOrWorkerGlobalScope mixin have a list of active timers. Each entry in this lists is identified by a number, which must be unique within the list for the lifetime of the object that implements the WindowOrWorkerGlobalScope mixin.
</p>

<hr>

<dl class="idl-def">
	<dt>`setTimeout()@m</dt>
<!-- 
handler, timeout, arguments
 -->
	<dd>
被呼出時には、［
次を与える下で，`~timer初期化~手続き$から返される値
］を返さ~MUST
⇒＃
%~method引数~list ~SET この~methodに渡された引数たち,
%~method文脈 ~SET 此れ,
%繰返~flag ~SET ~OFF
◎
The setTimeout() method must return the value returned by the timer initialization steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to false.
</dd>

	<dt>`setInterval()@m</dt>
	<dd>
被呼出時には、［
次を与える下で，`~timer初期化~手続き$から返される値
］を返さ~MUST
⇒＃
%~method引数~list ~SET この~methodに渡された引数たち,
%~method文脈 ~SET 此れ,
%繰返~flag ~SET ~ON
◎
The setInterval() method must return the value returned by the timer initialization steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to true.
</dd>

	<dt>`clearTimeout(handle)@m</dt>
	<dt>`clearInterval(handle)@m</dt>
	<dd>
これらのいずれも，被呼出時には、此れの`作動中の~timer~list$内に
%handle により識別される~entryがあれば、それを~clearし~MUST
（なければ何もしない）。
◎
The clearTimeout() and clearInterval() methods must clear the entry identified as handle from the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, if any, where handle is the argument passed to the method. (If handle does not identify an entry in the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, the method does nothing.)
</dd>
	<dd class="note">注記：
両~methodとも，同じ~listに属する~entryを~clearするので、いずれも
`setTimeout()$m ／ `setInterval()$m
で作成された~timerを~clearするのに利用できる。
◎
Because clearTimeout() and clearInterval() clear entries from the same list, either method can be used to clear timers created by setTimeout() or setInterval().
</dd>
</dl>

<hr>


<p class="algo-head">
`~timer初期化~手続き@
は、所与の
⇒＃
%~method引数~list,
%~method文脈,
%繰返~flag,
%前回handle（省略時は ε，非 ε にされるのは %繰返~flag ~EQ ~ON の場合に限られる）
◎終
に対し，次を走らす：
◎
The timer initialization steps, which are invoked with some method arguments, a method context, a repeat flag which can be true or false, and optionally (and only if the repeat flag is true) a previous handle, are as follows:
</p>

<ol>
	<li>
%~method文脈~proxy ~LET %~method文脈 に応じて
⇒＃
`WorkerGlobalScope$I ~objであるならば %~method文脈 ／
`Window$I ~objであるならば %~method文脈 に対応する `WindowProxy$I ~obj
◎
Let method context proxy be method context if that is a WorkerGlobalScope object, or else the WindowProxy that corresponds to method context.
</li>
	<li>
%handle ~LET %前回handle
◎
↓</li>
	<li>
<p>
~IF［
%handle ~EQ ε
］：
</p>
		<ol>
			<li>
%handle ~SET
~UA により定義される正~整数であって，この~callにより`作動中の~timer~list$に設定される~timeoutを識別するもの
</li>
			<li>
`作動中の~timer~list$に %handle 用の~entryを追加する
</li>
		</ol>
◎
If previous handle was provided, let handle be previous handle; otherwise, let handle be a user-agent-defined integer that is greater than zero that will identify the timeout to be set by this call in the list of active timers.
◎
If previous handle was not provided, add an entry to the list of active timers for handle.
</li>
	<li>
( %~call元~Realm, %~call先~Realm ) ~LET
( `現在の~Realm~Record$js, %~method文脈 の`~JS~realm$js )
◎
Let callerRealm be the current Realm Record, and calleeRealm be method context's JavaScript realm.
</li>
	<li>
%起動元~script~LET `作動中の~script$
◎
Let initiating script be the active script.
</li>
	<li>
~Assert：
%起動元~script ~NEQ ~NULL
— この~algoの~call元は，常に何らかの~scriptなので。
◎
Assert: initiating script is not null, since this algorithm is always called from some script.
</li>
	<li>
<p>
%~task ~LET 次の下位手続きを走らす`~task$：
◎
Let task be a task that runs the following substeps:
</p>
		<ol>
			<li>
~IF［
`作動中の~timer~list$内に
%handle に対応する~entryはない
］
⇒
~RET
◎
If the entry for handle in the list of active timers has been cleared, then abort these steps.
</li>
			<li>
%S ~LET %~method引数~list の最初の引数
◎
Run the appropriate set of steps from the following list:
</li>
			<li>
~IF［
%S は `Function$I である
］
⇒
次を与える下で %S を`呼出す$x
⇒＃
引数~list： %~method引数~list の 3 個目~以降の引数（空にもなり得る）,
`~callback this 値$x： %~method文脈~proxy
◎
If the first method argument is a Function
• Invoke the Function. Use the third and subsequent method arguments (if any) as the arguments for invoking the Function. Use method context proxy as the callback this value.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise
</p>
				<ol>
					<li>
`HostEnsureCanCompileStrings$jA( %~call元~Realm, %~call先~Realm )
を遂行する
⇒
例外が投出されたときは、~catchして
⇒＃
その`例外を報告する$；
~RET
◎
Perform HostEnsureCanCompileStrings(callerRealm, calleeRealm). If this throws an exception, catch it, report the exception, and abort these steps.
</li>
					<li>
%設定群~obj~LET %~method文脈 の`環境~設定群~obj$
◎
Let script source be the first method argument.
◎
Let settings object be method context's environment settings object.
</li>
					<li>
%基底~URL~LET %起動元~script の`基底~URL$sC
◎
Let base URL be initiating script's base URL.
</li>
					<li>
<p>
%~fetch~options ~LET 次のようにされた`~script~fetch~options$
⇒＃
`暗号用~nonce$sfO ~SET %起動元~script の`~fetch~options$sC の`暗号用~nonce$sfO,
`完全性~metadata$sfO ~SET 空~文字列,
`構文解析器~metadata$sfO ~SET `not-parser-inserted^l,
`資格証~mode$sfO ~SET %起動元~script の`~fetch~options$sC の`資格証~mode$sfO,
`~referrer施策$sfO ~SET %起動元~script の`~fetch~options$sC の`~referrer施策$sfO
◎
Let fetch options be a script fetch options whose cryptographic nonce is initiating script's fetch options's cryptographic nonce, integrity metadata is the empty string, parser metadata is "not-parser-inserted", credentials mode is initiating script's fetch options's credentials mode, and referrer policy is initiating script's fetch options's referrer policy.
</p>

<p class="note">
これらの~optionsによる効果は、［
`setTimeout()$m ／ `setInterval()$m
］が文字列を~compileするときの挙動は，
`eval()$c によるそれと等価になることを確保する。
すなわち、 `import()$c 介して~fetchする【される？】`~module~script$は，両~文脈において同じに挙動することになる。
◎
The effect of these options ensures that the string compilation done by setTimeout() and setInterval() behaves equivalently to that done by eval(). That is, module script fetches via import() will behave the same in both contexts.
</p>
					</li>
					<li>
%~script~LET `~classic~scriptを作成する$(
%S,
%設定群~obj,
%基底~URL,
%~fetch~options
)
◎
Let script be the result of creating a classic script given script source, settings object, base URL, and fetch options.
</li>
					<li>
`~classic~scriptを走らす$( %~script )
◎
Run the classic script script.
</li>
				</ol>
			</li>
			<li>
~IF［
%繰返~flag ~EQ ~ON
］
⇒
次を与える下で，`~timer初期化~手続き$を再度~callする
⇒＃
%~method引数~list ~SET %~method引数~list,
%~method文脈 ~SET %~method文脈,
%繰返~flag ~SET ~ON,
%前回handle ~SET %handle<!-- ＊handler 誤記 -->
◎
If the repeat flag is true, then call timer initialization steps again, passing them the same method arguments, the same method context, with the repeat flag still set to true, and with the previous handle set to handler.
</li>
		</ol>
	</li>
	<li>
%timeout ~LET  %~method引数~list の 2 個目の引数
◎
Let timeout be the second method argument.
</li>
	<li>
<p>
%入子~level ~LET ［
現在~走っている`~task$は，この~algoにより作成された`~task$ならば
その~taskの`~timerの入子~level$ ／
~ELSE_ 0
］
◎
If the currently running task is a task that was created by this algorithm, then let nesting level be the task's timer nesting level. Otherwise, let nesting level be zero.
</p>

<p class="note">注記：
~taskの`~timerの入子~level$は、［
`setTimeout()$m に対する入子の~call，
`setInterval()$m により作成される繰返しの~timer
］のいずれに対しても利用される（この 2 つが混在する入子もあり得る）。
言い換えれば、特定0の~methodではなく，この~algoの入子の呼出しを表現する。
◎
The task's timer nesting level is used both for nested calls to setTimeout(), and for the repeating timers created by setInterval(). (Or, indeed, for any combination of the two.) In other words, it represents nested invocations of this algorithm, not of a particular method.
</p>
	</li>
	<li>
~IF［
%timeout ~LT 0
］
⇒
%timeout ~SET 0
◎
If timeout is less than 0, then set timeout to 0.
</li>
	<li>
~IF［
%入子~level ~GT 5
］~AND［
%timeout ~LT 4
］
⇒
%timeout ~SET 4
◎
If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.
</li>
	<li>
%入子~level ~INCBY 1
◎
Increment nesting level by one.
</li>
	<li>
%~task の`~timerの入子~level@
~LET %入子~level
◎
Let task's timer nesting level be nesting level.
</li>
	<li>
~RET %handle
— ただし、この~algoの以降も`並列的$に走らせる
◎
Return handle, and then continue running this algorithm in parallel.
</li>
	<li>
<p>
%~method文脈 に応じて：
</p>
		<dl class="switch">
			<dt>`Window$I ~objである場合：</dt>
			<dd>
%~method文脈 に`結付けられている文書$が`全部的に作動中$になるまで
更に %timeout ~milli秒~待機する（連続的でなくともよい 【？】 ）。
</dd>

			<dt>`WorkerGlobalScope$I ~objである場合：</dt>
			<dd>
~workerを休止せずに %timeout ~milli秒~待機する（連続的でなくともよい）。
</dd>
		</dl>

◎
If method context is a Window object, wait until the Document associated with method context has been fully active for a further timeout milliseconds (not necessarily consecutively).
◎
Otherwise, method context is a WorkerGlobalScope object; wait until timeout milliseconds have passed with the worker not suspended (not necessarily consecutively).
</li>
	<li>
<div class="p">
<p>
この~algoのこの呼出し %A とは別の，この~algoの呼出し %B のうち，次をすべて満たすものがあれば，それらが完了するまで待機する：
</p>

<ul ><li>%B は完了していない
</li><li>( %B における %~method文脈 ) ~EQ ( %A における %~method文脈 )
</li><li>%B は %A より先に呼出された
</li><li>( %B における %timeout ) ~LTE ( %A における %timeout ) †
</li></ul>

<p class="trans-note">【†
例えば ( %A, %B ) における %timeout が ( 1, 2 ) の場合、
%B が %A の 100 ~milli秒~先に呼出されていても，
%A から先に実行される余地があることになる。
（ひょっとして、この段の %timeout は時間長そのままではなく，それが指す時点を意図している？）
】</p>

◎
Wait until any invocations of this algorithm that had the same method context, that started before this one, and whose timeout is equal to or less than this one's, have completed.
</div>


<p class="note">注記：
Web IDL に定義されるように、引数の変換は，この~algoが呼出される前に Web IDL にて定義される~algo内で起こる
— 例えば、最初の引数として渡された ~obj上の `toString()^m ~methodを呼出すような：
◎
Argument conversion as defined by Web IDL (for example, invoking toString() methods on objects passed as the first argument) happens in the algorithms defined in Web IDL, before this algorithm is invoked.
</p>


<div class="example">

<p>
例えば、次のちっぽけな~codeによる結果の %log は
`ONE&nbsp;TWO&nbsp;^l
になる：
◎
So for example, the following rather silly code will result in the log containing "ONE TWO ":
</p>


<pre>
var %log = '';
function logger(%s) { %log += %s + ' '; }

setTimeout({ toString: function () {
  setTimeout("logger('ONE')", 100);
  return "logger('TWO')";
} }, 100);
</pre>

</div>

	</li>
	<li>
<p>
~UAの任意選択で
⇒
~UAにより定義される時間だけ待機する。
◎
Optionally, wait a further user-agent defined length of time.
</p>

<p class="note">注記：
この段が意図する所は、~UAが機器の電力消費を最適化する必要に応じて，~timeoutを~~延長できるようにするためである。
例えば、~timerの粒度を抑えるような節電~modeを有する~processorも中にはあり、そのような~platform上では，~UAは，より正確0な非~節電~modeを利用することを要求する代わりに，この~scheduleに見合うように~timerを遅めれる。
◎
This is intended to allow user agents to pad timeouts as needed to optimize the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.
</p>

	</li>
	<li>
<p>
`~task$ %~task を`~queueする$
◎
Queue the task task.
</p>

<p class="note">注記：
［
%繰返~flag ~EQ ~OFF
］の下では、~taskの処理-後に，`作動中の~timer~list$から %handle に対応する~entryを除去しても安全である（この時点を過ぎて以降，~entryの存在を検出する仕方はないので、技術的に問題0になることはない）。
◎
Once the task has been processed, if the repeat flag is false, it is safe to remove the entry for handle from the list of active timers (there is no way for the entry's existence to be detected past this point, so it does not technically matter one way or the other).
</p>
	</li>
</ol>
<p>
これらの`~task$の`~task源$は、
`~timer~task源@
とする。
◎
The task source for these tasks is the timer task source.
</p>

<div class="example">

<p>
数~milli秒かかる~taskを間断なく延期なしに走らせつつ，~browserにも~UIに応じる余裕を与える（および，~browserが CPU 時間を得るために~scriptを強制終了しないようにする）ためには、単純に仕事を遂行する前に次回の~timerを~queueする：
◎
To run tasks of several milliseconds back to back without any delay, while still yielding back to the browser to avoid starving the user interface (and to avoid the browser killing the script for hogging the CPU), simply queue the next timer before performing work:
</p>

<pre>
function doExpensiveWork() {
  var %done = false;
  // ...
  /* <span class="comment">
この部分は、 %done を ~T に設定するまでに数~milli秒かかる
◎
this part of the function takes up to five milliseconds set done to true if we're done
</span> */
  // ...

  return %done;
}

function rescheduleWork() {
  var %handle = setTimeout(rescheduleWork, 0); /*
      <span class="comment">
次回の反復を予め~scheduleしておく
◎
preschedule next iteration
</span> */
  if (doExpensiveWork())
    clearTimeout(%handle); /*
      <span class="comment">
用済みになったら~timeoutを~clearする
◎
clear the timeout if we don't need it
</span> */
}

function scheduleWork() {
  setTimeout(rescheduleWork, 0);
}

scheduleWork(); /*
  <span class="comment">
たくさんの仕事を行う~taskを~queueする
◎
queues a task to do lots of work
</span> */
</pre>

</div>



		</section>
		<section id="user-prompts">
<h2 title="User prompts">8.6. 利用者~向けの~prompt</h2>


			<section id="simple-dialogs">
<h3 title="Simple dialogs">8.6.1. 単純な~dialog</h3>

  <dl class="domintro">
	<dt>%window . `alert(message)$m</dt>
	<dd>
所与の~messageを伴う~modal~alertを表示した上で、利用者がそれを退けるまで待機する。
◎
Displays a modal alert with the given message, and waits for the user to dismiss it.
</dd>

	<dt>%result = %window . `confirm(message)$m</dt>
	<dd>
所与の~messageを伴う［
OK ／ Cancel
］~modal~promptを表示して、利用者が退けるまで待機する。
利用者が［
OK を~clickしたなら ~T ／
Cancel を~clickしたなら ~F
］を返す。
◎
Displays a modal OK/Cancel prompt with the given message, waits for the user to dismiss it, and returns true if the user clicks OK and false if the user clicks Cancel.
</dd>

	<dt>%result = %window . `prompt(message [, default] )$m</dt>
	<dd>
~text~control, および所与の~messageを伴う~modal~promptを表示して、利用者がそれを退けるまで待機する。
利用者が［
~promptを取消したなら ~NULL ／
~ELSE_ 利用者が手入力した値
］を返す。
%default 引数が在する場合、その値が既定の~~入力として利用される。
◎
Displays a modal text control prompt with the given message, waits for the user to dismiss it, and returns the value that the user entered. If the user cancels the prompt, then returns null instead. If the second argument is present, then the given value is used as a default.
</dd>

</dl>

<p class="note">注記：
これらの~methodが呼出された場合、`~media~data$を読込んでいる`~media要素$などの
`~task$ ／ `小task$
に依存する~logicは停滞する。
◎
Logic that depends on tasks or microtasks, such as media elements loading their media data, are stalled when these methods are invoked.
</p>

<p class="algo-head">
`文字列を任意選択で短縮する@
ときは、所与の
( 文字列 %s )
に対し，［
%s そのままか，または %s から導出されるより短い何らかの文字列
］を返す。
~UAは、 %s から省かれた部位を表示するための ~UIは供するべきでない
— そうすると
“保安に関する重要事項です。次を~clickして全部的な詳細を読んで下さい。”
のような類の~dialogを簡単に作成できてしまい，濫用され易くなるので。
◎
To optionally truncate a simple dialog string s, return either s itself or some string derived from s that is shorter. User agents should not provide UI for displaying the elided portion of s, as this makes it too easy for abusers to create dialogs of the form "Important security alert! Click 'Show More' for full details!".
</p>

<p class="note">注記：
例えば~UAは、~messageの最初の 100 文字だけ表示したり，文字列を "…" で中略するよう求めるかもしれない。
この種の改変は、不自然に巨大な, もっともらしい~system~dialogに濫用される~~可能性を制限するのに有用になり得る。
◎
For example, a user agent might want to only display the first 100 characters of a message. Or, a user agent might replace the middle of the string with "…". These types of modifications can be useful in limiting the abuse potential of unnaturally large, trustworthy-looking system dialogs.
</p>

<div >
<p class="algo-head">
`~promptを示すかどうか決定する@
ときは、所与の
( %window )
に対し，次を走らす：
</p>

<p class="trans-note">【
この手続きは、この訳により，この節の各種~methodに共通するふるまいを抜き出して集約したものである。
】</p>

<ol>
	<li>
%文書 ~LET %window に`結付けられている文書$
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$の`~event-loop$の`終了の入子~level$ ~NEQ 0
］
⇒
~UAの任意選択で
⇒
~RET `示さない^i
</li>
	<li>
~IF［
`~sandbox化( ~modal )~flag$ ~IN ［
%文書 にて`作動中の~sandbox法~flag集合$
］］
⇒
~RET `示さない^i
</li>
	<li>
<p>
~UAの任意選択で
⇒
~RET `示さない^i
</p>
<p>
（例えば，~UAは、利用者に，以降の~alert／~promptすべてを無視する選択肢を与えることもできる
— 利用者がその選択肢を選んだ場合、この手続きを呼出した~methodは，それ以降 呼出される度に，この段で中止されることになる。）
</p>
	</li>
	<li>
~RET `示す^i
</li>
</ol>


◎
↓</div>


<dl class="idl-def">
	<dt>`alert(message)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The alert(message) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
`~promptを示すかどうか決定する$( 此れ ) ~EQ `示さない^i
］
⇒
~RET
◎
If the event loop's termination nesting level is nonzero, optionally return.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.
◎
Optionally, return. (For example, the user agent might give the user the option to ignore all alerts, and would thus abort at this step whenever the method was invoked.)
</li>
			<li>
~IF［
%message は与えられていない
］
⇒
%message ~SET 空~文字列
◎
If the method was invoked with no arguments, then let message be the empty string; otherwise, let message be the method's first argument.
</li>
			<li>
%message ~SET `文字列を任意選択で短縮する$( %message )
◎
Set message to the result of optionally truncating message.
</li>
			<li>
%message を利用者に示す
◎
Show message to the user.
</li>
			<li>
~UAの任意選択で
⇒
利用者が~messageを認めるまで`一時停止-$する
◎
Optionally, pause while waiting for the user to acknowledge the message.
</li>
		</ol>
	</dd>

	<dt>`confirm(message)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The confirm(message) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
`~promptを示すかどうか決定する$( 此れ ) ~EQ `示さない^i
］
⇒
~RET ~F
◎
If the event loop's termination nesting level is nonzero, optionally return false.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.
◎
Optionally, return false. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)
</li>
			<li>
%message ~SET `文字列を任意選択で短縮する$( %message )
◎
Set message to the result of optionally truncating message.
</li>
			<li>
%message を利用者に示して，利用者に肯定か否定か訊ねる
◎
Show message to the user, and ask the user to respond with a positive or negative response.
</li>
			<li>
利用者が応答するまで`一時停止-$する
◎
Pause until the user responds either positively or negatively.
</li>
			<li>
~RET 利用者の応答に応じて
⇒
肯定ならば ~T ／ 否定ならば ~F
◎
If the user responded positively, return true; otherwise, the user responded negatively: return false.
</li>
		</ol>
	</dd>

	<dt>`prompt(message, default)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The prompt(message, default) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
`~promptを示すかどうか決定する$( 此れ ) ~EQ `示さない^i
］
⇒
~RET ~NULL
◎
If the event loop's termination nesting level is nonzero, optionally return null.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.
◎
Optionally, return null. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)
</li>
			<li>
%message ~SET `文字列を任意選択で短縮する$( %message )
◎
Set message to the result of optionally truncating message.
</li>
			<li>
%default ~SET `文字列を任意選択で短縮する$( %default )
◎
Set default to the result of optionally truncating default.
</li>
			<li>
%message を利用者に示し、既定の応答を %default 値にする下で，利用者に 文字列~値で応答するか中止するか訊ねる
◎
Show message to the user, and ask the user to either respond with a string value or abort. The response must be defaulted to the value given by default.
</li>
			<li>
利用者が応答するまで`一時停止-$する
◎
Pause while waiting for the user's response.
</li>
			<li>
~RET［
利用者が中止したならば ~NULL ／
~ELSE_  利用者が応答した文字列
］
◎
If the user aborts, then return null; otherwise, return the string that the user responded with.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="printing">
<h3 title="Printing">8.6.2. 印刷-法</h3>

<dl class="domintro">
	<dt>%window . `print()$m</dt>
	<dd>
利用者に頁を印刷する旨を~promptする。
◎
Prompts the user to print the page.
</dd>

</dl>


<dl class="idl-def">
	<dt>`print()@m</dt>
	<dd>
<p>
被呼出時には次を走らせ~MUST：
</p>

		<ol>
			<li>
%文書 ~LET 此れに`結付けられている文書$
</li>
			<li>
~IF［
%文書 の`読込み後~taskは準備済み$である
］
⇒
%文書 の`印刷-時の手続き$を`並列的$に走らす
</li>
			<li>
~ELSE
⇒
%文書 の
`読込み時に印刷する~flag@
~SET ~ON
</li>
		</ol>

◎
When the print() method is invoked, if the Document is ready for post-load tasks, then the user agent must run the printing steps in parallel. Otherwise, the user agent must only set the print when loaded flag on the Document.
</dd>
</dl>




<p>
~UAは、利用者から文書 %文書 の`物理形を得る$（例：印刷, あるいは ~PDF などの物理形の表現も含む）機会を請われたときも、`印刷-時の手続き$を走らすべきである。
◎
User agents should also run the printing steps whenever the user asks for the opportunity to obtain a physical form (e.g. printed copy), or the representation of a physical form (e.g. PDF copy), of a document.
</p>

<p>
所与の %文書 の
`印刷-時の手続き@
は、次に従う：
◎
The printing steps are as follows:
</p>

<ol>
	<li>
<p>
~UAの任意選択で、次のいずれかまたは両方を行う：
◎
The user agent may display a message to the user or return (or both).
</p>

<ul ><li>利用者に~messageを表示する
</li><li>~RET
</li></ul>

<p class="example">
具体例として，~kiosk~browserは、
`print()$m ~methodに対する呼出し すべてを黙って無視することもできる。
◎
For instance, a kiosk browser could silently ignore any invocations of the print() method.
</p>

<p class="example">
具体例として，~mobile機器~上の~browserは、近くに印刷機がないことを検出したなら，
“~PDFに保存”
の選択肢を提供するに先立って その旨を述べる~messageを表示することもできる。
◎
For instance, a browser on a mobile device could detect that there are no printers in the vicinity and display a message saying so before continuing to offer a "save to PDF" option.
</p>
	</li>
	<li>
<p>
~IF［
`~sandbox化( ~modal )~flag$ ~IN
%文書 にて`作動中の~sandbox法~flag集合$
］
⇒
~RET
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.
</p>

<p class="note">注記：
印刷-用~dialogが %文書 の~sandboxで阻止された場合、
`beforeprint$et ／ `afterprint$et
~eventは発火されない。
◎
If the printing dialog is blocked by a Document's sandbox, then neither the beforeprint nor afterprint events will be fired.
</p>
	</li>
	<li>
%文書~list ~LET  %文書, および［
%文書 の`子孫~閲覧文脈~list$内の各 `閲覧文脈$にて`作動中の文書$
］からなる~list
◎
↓</li>
	<li>
<p>
%文書~list 内の ~EACH ( %D ) に対し
⇒
%D を`結付けている~window$に向けて，名前 `beforeprint$et の`~eventを発火-$する
◎
The user agent must fire an event named beforeprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.
</p>

<p class="example">
`beforeprint$et ~eventは、
印刷される複製に注釈を加えるときに利用できる
— 具体例として，印刷した時刻を追加するなど。
◎
The beforeprint event can be used to annotate the printed copy, for instance adding the time at which the document was printed.
</p>

	</li>
	<li>
<p>
~UAは、利用者に %文書 の`物理形を得る$（または その表現を得る）機会を提供するべきである
— そうする場合
⇒
利用者が受容するか辞退するまで待機してよい
— そうする場合
⇒
待機-中は`一時停止-$し~MUST。
◎
The user agent should offer the user the opportunity to obtain a physical form (or the representation of a physical form) of the document. The user agent may wait for the user to either accept or decline before returning; if so, the user agent must pause while the method is waiting.＼
</p>

<p>
待機するかどうかにかかわらず、当の物理形には，この~algoのこの時点における %文書 の状態を利用し~MUST。
◎
Even if the user agent doesn't wait at this point, the user agent must use the state of the relevant documents as they are at this point in the algorithm if and when it eventually creates the alternate form.
</p>
	</li>
	<li>
<p>
%文書~list 内の ~EACH ( %D ) に対し
⇒
%D を`結付けている~window$に向けて，名前 `afterprint$et の`~eventを発火-$する
◎
The user agent must fire an event named afterprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.
</p>

<p class="example">
`afterprint$et ~eventは、 `beforeprint$et ~event時に追加された注釈を復帰するため, あるいは 印刷-後の~UIを示すためにも利用できる。
後者の具体例としては、利用者に 何段階かにわたる手続きを踏んでもらう頁があるとき、~scriptは，印刷-後に 自動的に次の段階へ進めることもできる。
◎
The afterprint event can be used to revert annotations added in the earlier event, as well as showing post-printing UI. For instance, if a page is walking the user through the steps of applying for a home loan, the script could automatically advance to the next step after having printed a form or other.
</p>

	</li>
</ol>



			</section>
		</section>
		<section id="system-state-and-capabilities">
<h2 title="System state and capabilities">8.7. ~systemの状態と能力</h2>

<p class="trans-note">【
この節の内容の和訳は、
<a href="~HTMLnavigator">別ページ</a>
にて。
】</p>

		</section>
		<section id="images-2">
<h2 title="Images">8.8. 画像</h2>

<pre class="idl">
[Exposed=(Window,Worker), `Serializable$, `Transferable$]
interface `ImageBitmap@I {
  readonly attribute unsigned long `width$m;
  readonly attribute unsigned long `height$m;
  void `close$m();
};

typedef (`CanvasImageSource$I or
         `Blob$I or
         `ImageData$I) `ImageBitmapSource@I;

enum `ImageOrientation@I { `~none1$l, `flipY$l };
enum `PremultiplyAlpha@I { `none$l, `premultiply$l, `default$l };
enum `ColorSpaceConversion@I { `~none0$l, `~default0$l };
enum `ResizeQuality@I { `pixelated$l, `low$l, `medium$l, `high$l };

dictionary `ImageBitmapOptions@I {
  `ImageOrientation$I `imageOrientation$m = `~none1$l;
  `PremultiplyAlpha$I `premultiplyAlpha$m = `default$l;
  `ColorSpaceConversion$I `colorSpaceConversion$m = `~default0$l;
  [EnforceRange] unsigned long `resizeWidth$m;
  [EnforceRange] unsigned long `resizeHeight$m;
  `ResizeQuality$I `resizeQuality$m = `low$l;
};
</pre>

 
<p>
`ImageBitmap$I ~objは、過度の遅延なく~canvasに塗れるような，~bitmap画像を表現する。
◎
An ImageBitmap object represents a bitmap image that can be painted to a canvas without undue latency.
</p>

 
<p class="note">注記：
何を以って過度の遅延とするかの正確な判定は実装者に委ねられるが、一般に，~bitmapの利用~時に
~network I/O, や~local~disk I/O を要するならば，遅延はおそらく過度になる。
一方で，他を阻むのは GPU や~system RAM からの読取りに限られるならば、遅延はおそらく受容-可能になる。
◎
The exact judgement of what is undue latency of this is left up to the implementer, but in general if making use of the bitmap requires network I/O, or even local disk I/O, then the latency is probably undue; whereas if it only requires a blocking read from a GPU or system RAM, the latency is probably acceptable.
</p>

<dl class="domintro">

	<dt>%promise = self . `createImageBitmap$m(%image [, %options ])</dt>
	<dt>%promise = self . `createImageBitmap$m(%image, %sx, %sy, %sw, %sh [, %options ])</dt>
	<dd>
所与の %image から新たな `ImageBitmap$I が作成された時点で解決される，~promiseを返す
— %image は次のいずれかをとり得る
⇒
`img$e 要素 ／
`~SVG-image$ 要素 ／
`video$e 要素 ／
`canvas$e 要素 ／
`Blob$I ~obj ／
`ImageData$I ~obj ／
別の `ImageBitmap$I ~obj
◎
Takes image, which can be an img element, an SVG image element, a video element, a canvas element, a Blob object, an ImageData object, or another ImageBitmap object, and returns a promise that is resolved when a new ImageBitmap is created.
</dd>
	<dd>
`ImageBitmap$I ~objを構築できなかった場合
— 例えば、供された %image ~dataが実際には画像でなかったなど —
~promiseは却下される。
◎
If no ImageBitmap object can be constructed, for example because the provided image data is not actually an image, then the promise is rejected instead.
</dd>
	<dd>
%sx, %sy, %sw, %sh
引数が供された場合、~source画像は，それらが成す矩形に切抜かれる
— 元の画像に無い画素は、`透明な黒$に置換される。<!-- ＊ clip？ -->
これらの座標は、~source画像の~pixel座標~空間であり，`~CSS~pixel$単位<em>ではない</em>。
◎
If sx, sy, sw, and sh arguments are provided, the source image is cropped to the given pixels, with any pixels missing in the original replaced by transparent black. These coordinates are in the source image's pixel coordinate space, not in CSS pixels.
</dd>
	<dd>
%options が供された場合、
`ImageBitmap$I ~objの~bitmap~dataは， %options に則って改変される。
例えば［
%options の `premultiplyAlpha$m ~option ~EQ `premultiply$l
］ならば、`~bitmap~data$ の各~色~channelは その~alpha~channelにより乗算済みにされる。
◎
If options is provided, the ImageBitmap object's bitmap data is modified according to options. For example, if the premultiplyAlpha option is set to "premultiply", the bitmap data's color channels are premultiplied by its alpha channel.
</dd>
	<dd>
<p>
~source画像の状態が妥当でない場合、~promiseは `InvalidStateError$E で却下される
— 例えば：
</p>

<ul ><li>成功裡に読込まれなかった `img$e 要素
</li><li>`ImageBitmap$I ~objであって［
`Detached$sl 内部~slot値 ~EQ ~T
］なるもの
</li><li>`ImageData$I ~objであって［
`data$m 属性~値の `ViewedArrayBuffer^sl 内部~slotは detached
【  `IsDetachedBuffer$jA( 内部~slotの値 ) ~EQ ~T 】
］なるもの
</li><li>`Blob$I であって その~dataを~bitmap画像に解釈できないもの
</li></ul>

◎
Rejects the promise with an "InvalidStateError" DOMException if the source image is not in a valid state (e.g., an img element that hasn't loaded successfully, an ImageBitmap object whose [[Detached]] internal slot value is true, an ImageData object whose data attribute value's [[ViewedArrayBuffer]] internal slot is detached, or a Blob whose data cannot be interpreted as a bitmap image).
</dd>
	<dd>
~scriptから~source画像の画像~dataへの~accessは許容されない場合、
~promiseは `SecurityError$E `DOMException$I で却下される（例：
`~CORS非同一生成元$の `video$e ／
別の`生成元$からの~worker内の~scriptにより描かれている `canvas$e
）。
◎
Rejects the promise with a "SecurityError" DOMException if the script is not allowed to access the image data of the source image (e.g. a video that is CORS-cross-origin, or a canvas being drawn on by a script in a worker from another origin).
</dd>

	<dt>%imageBitmap . `close$m()</dt>
	<dd>
%imageBitmap の下層の`~bitmap~data$を解放する。
◎
Releases imageBitmap's underlying bitmap data.
</dd>

	<dt>%imageBitmap . `width$m</dt>
	<dd>
画像の`内在的~横幅$を`~CSS~pixel$単位で返す。
◎
Returns the intrinsic width of the image, in CSS pixels.
</dd>

	<dt>%imageBitmap . `height$m</dt>
	<dd>
画像の`内在的~縦幅$を`~CSS~pixel$単位で返す。
◎
Returns the intrinsic height of the image, in CSS pixels.
</dd>

</dl>

<p>
各 `ImageBitmap$I %O は：
◎
↓</p>

<ul>
	<li>
［
%O の `Detached$sl 内部~slot値 ~EQ ~F
］ならば、常に
横幅, 縦幅を伴う
`~bitmap~data@
が結付けられる
【~T にされたときは、この~dataは解放される（ ε にされる）】
。
しかしながら、この~dataは壊れていることもあり得る。
`ImageBitmap$I ~objは、その~media~dataが~errorなしに復号できるならば，
`全部的に復号-可能@
と呼ばれる。
◎
An ImageBitmap object whose [[Detached]] internal slot value is false always has associated bitmap data, with a width and a height. However, it is possible for this data to be corrupted. If an ImageBitmap object's media data can be decoded without errors, it is said to be fully decodable.
</li>
<li>
%O の~bitmapは、`生成元clean~flag$を持つ
— それは、［
~bitmapが，異なる`生成元$からの内容に染まっている（ tainted ）かどうか
］を指示する。
この~flagは、初期~時には ~T に設定され（染まっていない），
`createImageBitmap()$m の手続きにより ~F に変化し得る。
◎
An ImageBitmap object's bitmap has an origin-clean flag, which indicates whether the bitmap is tainted by content from a different origin. The flag is initially set to true and may be changed to false by the steps of createImageBitmap().
</li>
</ul>

<p>
各 `ImageBitmap$I は、`直列化-可能$／`転送-可能$である：
◎
ImageBitmap objects are serializable objects and transferable objects.
</p>

<ul>
	<li>
<p>
その`直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their serialization steps, given value and serialized, are:
</p>
		<ol>
			<li>
%直列形 . `BitmapData^sl ~SET %値 の`~bitmap~data$の複製
◎
Set serialized.[[BitmapData]] to a copy of value's bitmap data.
</li>
			<li>
%直列形 . `OriginClean^sl ~SET %値 の`生成元clean~flag$
◎
Set serialized.[[OriginClean]] to true if value's origin-clean flag is set, and false otherwise.
</li>
		</ol>
	</li>
	<li>
<p>
その`逆直列化~手続き$は、所与の
( %直列形, %値 )
に対し，次を走らす：
◎
Their deserialization steps, given serialized and value, are:
</p>
		<ol>
			<li>
%値 の`~bitmap~data$ ~SET  %直列形 . `BitmapData^sl
◎
Set value's bitmap data to serialized.[[BitmapData]].
</li>
			<li>
~IF［
%直列形 . `OriginClean^sl ~EQ ~T
］
⇒
%値 の`生成元clean~flag$ ~SET ~T
◎
If serialized.[[OriginClean]] is true, set value's origin-clean flag.
</li>
		</ol>
	</li>
	<li>
<p>
その`転送-手続き$は、所与の
( %値, %~data保持体 )
に対し，次を走らす：
◎
Their transfer steps, given value and dataHolder, are:
</p>
		<ol>
			<li>
%~data保持体 . `BitmapData^sl ~SET %値 の`~bitmap~data$
◎
Set dataHolder.[[BitmapData]] to value's bitmap data.
</li>
			<li>
%~data保持体 . `OriginClean^sl  ~SET %値 の`生成元clean~flag$
◎
Set dataHolder.[[OriginClean]] to true if value's origin-clean flag is set, and false otherwise.
</li>
			<li>
%値 の`~bitmap~data$ ~SET ε
◎
Unset value's bitmap data.
</li>
		</ol>
	</li>
	<li>
<p>
その`転送-受信-時の手続き$は、所与の
( %~data保持体, %値 )
に対し，次を走らす：
◎
Their transfer-receiving steps, given dataHolder and value, are:
</p>

		<ol>
			<li>
%値 の`~bitmap~data$ ~SET %~data保持体 . `BitmapData^sl
◎
Set value's bitmap data to dataHolder.[[BitmapData]].
</li>
			<li>
~IF［
%~data保持体 . `OriginClean^sl ~EQ ~T
］
⇒
%値 の`生成元clean~flag$ ~SET ~T
◎
If dataHolder.[[OriginClean]] is true, set value's origin-clean flag.
</li>
		</ol>
	</li>
</ul>

<hr>

<dl class="idl-def">
	<dt>`createImageBitmap(image, options)@m</dt>
	<dt>`createImageBitmap(image, sx, sy, sw, sh, options)^m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createImageBitmap(image, options) and createImageBitmap(image sx, sy, sw, sh, options) methods, when invoked, must run these steps:
</p>
		<ol>
			<li>
%promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li>
%xywh ~LET ［
%sx, %sy, %sw, %sh 引数は指定されているならば ~T ／
~ELSE_ ~F
］
◎
↓</li>
			<li>
~IF［
%xywh ~EQ ~T
］
⇒
~IF［
%sw ~EQ 0
］~OR［
%sh ~EQ 0
］
⇒＃
`RangeError$E で %promise を`却下する$；
~RET %promise
◎
If either sw or sh is given and is 0, then return p rejected with a RangeError.
</li>
			<li>
`~resize横幅@V ~LET ［
%options に
`resizeWidth@m
は在するならば その値 ／
~ELSE_  ε
］
◎
↓</li>
			<li>
`~resize縦幅@V ~LET ［
%options に
`resizeHeight@m
は在するならば その値 ／
~ELSE_  ε
］
◎
↓</li>
			<li>
~IF［
`~resize横幅$V ~EQ 0
］~OR［
`~resize横幅$V ~EQ 0
］
⇒＃
`InvalidStateError$E で %promise を`却下する$；
~RET %promise
◎
If either options's resizeWidth or options's resizeHeight is present and is 0, then return p rejected with an "InvalidStateError" DOMException.
</li>
			<li>
<a href="~HEcanvas#check-the-usability-of-the-image-argument">%image 引数は利用~可能か検査する</a>
⇒
~IF［
例外が投出された／結果は `bad^i
］
⇒＃
`InvalidStateError$E で %promise を`却下する$；
~RET %promise
◎
Check the usability of the image argument. If this throws an exception or returns bad, then return p rejected with an "InvalidStateError" DOMException.
</li>
			<li>
<p>
%~bitmapを得る手続き ~LET 次を走らす下位手続き：
</p>
				<ol>
					<li>
( %~bitmap~data, %生成元clean ) ~LET
%image から`~bitmap~dataを取得する$
</li>
					<li>
~IF［
%~bitmap~data ~EQ ε
］
⇒＃
`InvalidStateError$E 例外で %promise を`却下する$；
~RET ε
 </li>
					<li>
%O ~LET 新たな `ImageBitmap$I ~obj
</li>
					<li>
%O の`~bitmap~data$ ~SET %~bitmap~data を`~source矩形に切抜いて整形する$
</li>
					<li>
%O の~bitmapの`生成元clean~flag$ ~SET %生成元clean
</li>
					<li>
~RET %O
</li>
				</ol>
◎
↓</li>
			<li>
<p>
~IF［
%image は `Blob$I ~objである
］
⇒
次を`並列的$に走らす：
</p>
				<ol>
					<li>
%~bitmap ~LET %~bitmapを得る手続き を走らせた結果
</li>
					<li>
~IF［
%~bitmap ~NEQ ε
］
⇒
%~bitmap で %promise を`解決する$
</li>
				</ol>
◎
↓</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%~bitmap ~LET %~bitmapを得る手続き を走らせた結果
</li>
					<li>
~IF［
%~bitmap ~NEQ ε
］
⇒
次を`並列的$に走らす
⇒
%~bitmap で %promise を`解決する$
</li>
				</ol>
◎
↓</li>
			<li>
~RET %promise
◎
↓</li>
		</ol>
	</dd>
	<dd class="trans-note">【
この訳では、原文の~algoを再構成している
— その重複する~logicを上の手続きに集約し，重複しない部分は次の “`~bitmap~dataを取得する$” に抜き出している。
】</dd>
</dl>


<p class="algo-head">
上の手続きにて %image から
`~bitmap~dataを取得する@
ときは、 %image に応じて，次を走らす：
◎
Let imageBitmap be a new ImageBitmap object.
◎
Switch on image:
</p>

<dl class="switch">
	<dt>`img$e</dt>
	<dt>`~SVG-image$</dt>
	<dd>
		<ol>
			<li>
%寸法 ~LET %image の~media~dataの`内在的~寸法$
◎
↓</li>
			<li>
<p>
~IF［
%寸法 ~EQ ε（例：
内容~sizeが指定されていない~vector~graphic）
］：
</p>
				<ol>
					<li>
~IF［
`~resize横幅$V ~EQ ε
］~OR［
`~resize縦幅$V ~EQ ε
］
⇒
~RET ( ε, ε )
</li>
					<li>
~UAは、 %image を~size
( `~resize横幅$V, `~resize縦幅$V )
の~bitmapに描画するべきである 【 “べき” とは？】
</li>
				</ol>

◎
If image's media data has no intrinsic dimensions (e.g., it's a vector graphic with no specified content size) and either options's resizeWidth or options's resizeHeight is not present, then return p rejected with an "InvalidStateError" DOMException.
◎
If image's media data has no intrinsic dimensions (e.g., it's a vector graphics with no specified content size), it should be rendered to a bitmap of the size specified by the resizeWidth and the resizeHeight options.
</li>
			<li>
%~bitmap~data ~LET %image の~media~dataを`代表する~bitmap~data$の複製
◎
Set imageBitmap's bitmap data to a copy of image's media data, cropped to the source rectangle with formatting. If this is an animated image, imageBitmap's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.
</li>
			<li>
%生成元clean ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
( %image の画像の`生成元$, `入口~設定群~obj$により指定される`生成元$enV )
は`同一生成元$である
◎
If the origin of image's image is not same origin with entry settings object's origin, then set the origin-clean flag of imageBitmap's bitmap to false.
</li>
			<li>
~RET ( %~bitmap~data, %生成元clean )
◎
Run this step in parallel:
• Resolve p with imageBitmap.
</li>
		</ol>
	</dd>

	<dt>`video$e</dt>
	<dd>
		<ol>
			<li>
~IF［
%image の `networkState$m 属性~値 ~EQ `NETWORK_EMPTY$m
］
⇒
~RET ( ε, ε )：
◎
If image's networkState attribute is NETWORK_EMPTY, then return p rejected with an "InvalidStateError" DOMException.
</li>
			<li>
%~bitmap~data ~LET `現在の再生位置$にある~frameの複製
— その~sizeは
`~media資源$の
( `内在的~横幅$video, `内在的~縦幅$video ) 
とする（すなわち，縦横比による補正は適用-済み）
◎
Set imageBitmap's bitmap data to a copy of the frame at the current playback position, at the media resource's intrinsic width and intrinsic height (i.e., after any aspect-ratio correction has been applied), cropped to the source rectangle with formatting.
</li>
			<li>
%生成元clean ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
( %image の動画の`生成元$, `入口~設定群~obj$により指定される`生成元$enV )
は`同一生成元$である
◎
If the origin of image's video is not same origin with entry settings object's origin, then set the origin-clean flag of imageBitmap's bitmap to false.
</li>
			<li>
~RET ( %~bitmap~data, %生成元clean )
◎
Run this step in parallel:
• Resolve p with imageBitmap.
</li>
		</ol>
	</dd>

	<dt>`canvas$e</dt>
	<dd>
		<ol>
			<li>
~RET ( %image の`~bitmap~data$の複製, %image の~bitmapの`生成元clean~flag$ )
◎
Set imageBitmap's bitmap data to a copy of image's bitmap data, cropped to the source rectangle with formatting.
◎
Set the origin-clean flag of the imageBitmap's bitmap to the same value as the origin-clean flag of image's bitmap.
◎
Run this step in parallel:
• Resolve p with imageBitmap.
</li>
		</ol>
	</dd>

	<dt>
`Blob$I ~obj
◎
If image is a Blob object
</dt>
	<dd>
		<ol>
			<li>
%画像~data ~LET %image から~dataを読取る
【<a href="~FILEAPI#readOperationSection">読取り演算</a>により？】
⇒
<a href="~FILEAPI#file-error-read">読取る間に~errorが生じた</a>ときは
⇒
~RET ( ε, ε )
◎
Run these step in parallel:
◎
Let imageData be the result of reading image's data. If an error occurs during reading of the object, then reject p with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%画像~data の公式的な型 ~LET ［
%image の `type$m 属性で与えられる~MIME型
］を与える下で，`画像~sniff時の規則$を適用して、
%画像~data の~file形式を決定した結果
◎
Apply the image sniffing rules to determine the file format of imageData, with MIME type of image (as given by image's type attribute) giving the official type.
</li>
			<li>
<p >
~IF［
次のいずれかが満たされる
］
⇒
~RET ( ε, ε )：
</p>

<ul ><li>%画像~data の公式的な型は~supportされる画像~file形式でない（例：画像でない）
</li><li>%画像~data は壊れている
</li><li>%画像~data から寸法を得られない（例： 内在的~sizeを伴わない~vector~graphic）
</li></ul>

◎
If imageData is not in a supported image file format (e.g., it's not an image at all), or if imageData is corrupted in some fatal way such that the image dimensions cannot be obtained (e.g., a vector graphic with no intrinsic size), then reject p with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%~bitmap~data ~LET %画像~data を`代表する~bitmap~data$
◎
Set imageBitmap's bitmap data to imageData, cropped to the source rectangle with formatting. If this is an animated image, imageBitmap's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.
</li>
			<li>
~RET ( %~bitmap~data, ~T )
◎
Resolve p with imageBitmap.
</li>
		</ol>
	</dd>

	<dt>`ImageData$I</dt>
	<dd>

		<ol>
			<li>
~IF［
`IsDetachedBuffer$jA( %image の `data$m 属性~値の `ViewedArrayBuffer^sl 内部~slot値 ) ~EQ ~T
］
⇒
~RET ( ε, ε )
◎
Let buffer be image's data attribute value's [[ViewedArrayBuffer]] internal slot.
◎
If IsDetachedBuffer(buffer) is true, then return p rejected with an "InvalidStateError" DOMException.
</li>
			<li>
~RET ( %image が与える画像~data, ~T )
◎
Set imageBitmap's bitmap data to image's image data, cropped to the source rectangle with formatting.
◎
Run this step in parallel:
• Resolve p with imageBitmap.
</li>
		</ol>
	</dd>

	<dt>`ImageBitmap$I</dt>
	<dd>
		<ol>
			<li>
~RET ( %image の`~bitmap~data$の複製, %image の~bitmapの`生成元clean~flag$ )
◎
Set imageBitmap's bitmap data to a copy of image's bitmap data, cropped to the source rectangle with formatting.
◎
Set the origin-clean flag of imageBitmap's bitmap to the same value as the origin-clean flag of image's bitmap.
◎
Run this step in parallel:
• Resolve p with imageBitmap.
</li>
		</ol>
	</dd>
</dl>

<p>
◎
↑↑Return p.
</p>

<div >
<p class="algo-head">
所与の %画像~data を
`代表する~bitmap~data@
は、次の結果を返す：
</p>

<ol>
	<li>
~IF［
%画像~data は~animated画像でない
］
⇒
~RET %画像~data
</li>
	<li>
~RET ［
%画像~data の形式にて［
~animationが ~supportされないか不能化されている
］ときに利用するものと定義されている既定の画像
］が［
あれば それ ／
なければ~animationの最初の~frame
］
</li>
</ol>

◎
↑</div>



<p class="algo-head">
上の手続きにて，`~bitmap~data$ %入力 を
`~source矩形に切抜いて整形する@
ときは、次の手続きを走らす：
◎
When the steps above require that the user agent crop bitmap data to the source rectangle with formatting, the user agent must run the following steps:
• Let input be the bitmap data being transformed.
</p>

<ol>
	<li>
<p >
%~source矩形 ~LET
( 左端, 上端, 右端, 下端 ) が次で与えられる矩形：
</p>

		<dl class="switch">
			<dt>%xywh ~EQ ~T の場合</dt>
			<dd>

<ul ><li>左端： max( min( %sx, %sx + %sw ), 0)
</li><li>上端： max( min( %sy, %sy + %sh ), 0)
</li><li>右端： min( max( %sx, %sx + %sw ), %入力 の横幅 )
</li><li>下端： min( max( %sy, %sy + %sh ), %入力 の縦幅 )
</li></ul>

<!-- 
［
%sw ／ %sh
］が負ならば、この矩形の左上隅は，点 ( %sx, %sy ) の 左／上になる。
-->

			</dd>

			<dt>他の場合</dt>
			<dd>
( 0, 0, %入力 の横幅, %入力 の縦幅 )
</dd>
		</dl>

◎
If sx, sy, sw and sh are specified, let sourceRectangle be a rectangle whose corners are the four points (sx, sy), (sx+sw, sy),(sx+sw, sy+sh), (sx,sy+sh). Otherwise let sourceRectangle be a rectangle whose corners are the four points (0,0), (width of input, 0), (width of input, height of input), (0, height of input).
◎
If either sw or sh are negative, then the top-left corner of this rectangle will be to the left or above the (sx, sy) point.
◎
Clip sourceRectangle to the dimensions of input.
</li>
	<li>
( %横幅, %縦幅 ) ~LET %~source矩形 の ( 横幅, 縦幅 )
</li>
	<li>

<p>
( %出力~横幅, %出力~縦幅 ) ~LET
(`~resize横幅$V, `~resize縦幅$V )
に応じて，次の表で与えられる値を整数に切り上げた結果：
</p>

<table>
<thead><tr><th>`~resize横幅$V
<th>`~resize縦幅$V
<th>%出力~横幅
<th>%出力~縦幅
</thead>

<tbody><tr><td>非ε
<td>非ε
<td>`~resize横幅$V
<td>`~resize縦幅$V

<tr><td>非ε
<td>ε
<td>`~resize横幅$V
<td>%縦幅 × `~resize横幅$V ÷ %横幅

<tr><td>ε
<td>非ε
<td>%横幅 × `~resize縦幅$V ÷ %縦幅
<td>`~resize縦幅$V

<tr><td>ε
<td>ε
<td>%横幅
<td>%縦幅

</tbody></table>


◎
Let outputWidth be determined as follows:
• If the resizeWidth member of options is specified
•• the value of the resizeWidth member of options
• If the resizeWidth member of options is not specified, but the resizeHeight member is specified
•• the width of sourceRectangle, times the value of the resizeHeight member of options, divided by the height of sourceRectangle, rounded up to the nearest integer
• If neither resizeWidth nor resizeHeight are specified
•• the width of sourceRectangle

Let outputHeight be determined as follows:
• If the resizeHeight member of options is specified
•• the value of the resizeHeight member of options
• If the resizeHeight member of options is not specified, but the resizeWidth member is specified
•• the height of sourceRectangle, times the value of the resizeWidth member of options, divided by the width of sourceRectangle, rounded up to the nearest integer
• If neither resizeWidth nor resizeHeight are specified
•• the height of sourceRectangle
</li>
	<li>
%平面 ~LET 
( x 軸は右向き, y 軸は下向き ) にされた, 広さ無限の, `透明な黒$の平面
◎
↓</li>
	<li>
<p >
%入力 を，次に従うように %平面 に~~合成する：
</p>

<ul ><li>%入力 の左上隅は、 %平面 の原点に位置させる。
</li><li>%入力 画像~data内の各~画素は、 %平面 において 1 × 1 の正方形を占めるとする。
</li></ul>

◎
Place input on an infinite transparent black grid plane, positioned so that its top left corner is at the origin of the plane, with the x-coordinate increasing to the right, and the y-coordinate increasing down, and with each pixel in the input image data occupying a cell on the plane's grid.
</li>
	<li>
%出力 ~LET 
%平面 上の %~source矩形 が占める矩形~内の画像を，~size
( %出力~横幅, %出力~縦幅 )
に拡縮した結果
⇒
この拡縮に用いる~algoは、 `resizeQuality$m ~optionの値に基づくべきである
◎
Let output be the rectangle on the plane denoted by sourceRectangle.
◎
Scale output to the size specified by outputWidth and outputHeight. The user agent should use the value of the resizeQuality option to guide the choice of scaling algorithm.
</li>
	<li>
<p>
%options の
`imageOrientation@m
~memberの値に応じて：
</p>

		<dl class="switch">
			<dt>`flipY@l</dt>
			<dd>
%出力 を縦向きに裏返す
— ~sourceの画像~方位~metadata（ `EXIF$r ~metadataなど）があっても無視rする
◎
If the value of the imageOrientation member of options is "flipY", output must be flipped vertically, disregarding any image orientation metadata of the source (such as EXIF metadata), if any. [EXIF]
</dd>

			<dt>`~none1@l</dt>
			<dd>
何もしない
◎
If the value is "none", no extra step is required.
</dd>

		</dl>
	</li>
	<li>
<p>
~IF［
%image は `img$e 要素または `Blob$I ~objである
］
⇒
`colorSpaceConversion@m
~memberの値に応じて：
◎
If image is an img element or a Blob object, let val be the value of the colorSpaceConversion member of options, and then run these substeps:
</p>

		<dl class="switch">
			<dt>`~default0@l</dt>
			<dd>
色~空間の変換の挙動は，実装~特有である
— 実装は、画像を~canvasに描く際に利用する色~空間に則って選ぶべきである。
◎
If val is "default", the color space conversion behavior is implementation-specific, and should be chosen according to the color space that the implementation uses for drawing images onto the canvas.
</dd>

			<dt>`~none0@l</dt>
			<dd>
%出力 は、色~空間の変換を遂行することなく復号され~MUST。
これは、
画像を復号する~algoは［
~source~data内に埋込まれている色~profile~metadata,
表示~機器の色~profile
］のいずれも無視し~MUSTことを意味する。
◎
If val is "none", output must be decoded without performing any color space conversions. This means that the image decoding algorithm must ignore color profile metadata embedded in the source data as well as the display device color profile.
</dd>
			<dd class="note">注記：
~canvasの~native色~空間は、現在は指定されていないが、将来的には変更されることが予期されている。
◎
The native color space of canvas is currently unspecified, but this is expected to change in the future.
</dd>

		</dl>
	</li>
	<li>
<p>
%options の
`premultiplyAlpha@m
~memberの値に応じて：
◎
Let val be the value of premultiplyAlpha member of options, and then run these substeps:
</p>

		<dl class="switch">
			<dt>`default@l</dt>
			<dd>
%出力 を~alphaにより乗算済みにするかどうかは、実装~特有である
— 実装は、画像を~canvasに描くために最適と判断されるものに則って選ぶべきである。
◎
If val is "default", the alpha premultiplication behavior is implementation-specific, and should be chosen according to implementation deems optimal for drawing images onto the canvas.
</dd>

			<dt>`premultiply@l</dt>
			<dd>
~IF［
%出力 は~alphaにより乗算済みでない
］
⇒
%出力 のすべての 色~成分を~alphaで乗算する
◎
If val is "premultiply", the output that is not premultiplied by alpha must have its color components multiplied by alpha and that is premultiplied by alpha must be left untouched.
</dd>

			<dt>`none@l</dt>
			<dd>
~IF［
%出力 は~alphaにより乗算済みである
］
⇒
%出力 のすべての色~成分を~alphaで除算する
◎
If val is "none", the output that is not premultiplied by alpha must be left untouched and that is premultiplied by alpha must have its color components divided by alpha.
</dd>
		</dl>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>



<dl class="idl-def">
	<dt>`close()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the close() method is called, the user agent must run these steps:
</p>

		<ol>
			<li>
此れの `Detached$sl 内部~slot値 ~SET ~T
◎
Set this ImageBitmap object's [[Detached]] internal slot value to true.
</li>
			<li>
此れの`~bitmap~data$ ~SET ε
◎
Unset this ImageBitmap object's bitmap data.
</li>
		</ol>
	</dd>

	<dt>`width@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The width attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの `Detached$sl 内部~slotの値 ~EQ ~T
］
⇒
~RET 0
◎
If this ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.
</li>
			<li>
~RET `~CSS~pixel$単位による，此れの横幅
◎
Return this ImageBitmap object's width, in CSS pixels.
</li>
		</ol>
	 </dd>

	<dt>`height@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The height attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの `Detached$sl 内部~slotの値 ~EQ ~T
］
⇒
~RET 0
◎
If this ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.
</li>
			<li>
~RET `~CSS~pixel$単位による，此れの縦幅
◎
Return this ImageBitmap object's height, in CSS pixels.
</li>
		</ol>
	</dd>
</dl>

<p class="idl-def">
`ResizeQuality$I 列挙型の値
`resizeQuality@m
は、画像の拡縮-時に利用する補間~品質の選好を表すために利用される
— とり得る値の意味は：
◎
The ResizeQuality enumeration is used to express a preference for the interpolation quality to use when scaling images.
</p>

<dl class="switch">
	<dt>`pixelated@l</dt>
	<dd>
画像の外観をできるだけ保つような選好を指示する。
双線形~補間など、色を “滑らかに” 拡縮する~algoは，受容-可能である。
◎
The "pixelated" value indicates a preference to scale the image that maximizes the appearance. Scaling algorithms that "smooth" colors are acceptable, such as bilinear interpolation.
</dd>

	<dt>`low@l</dt>
	<dd>
低~品質な画像~補間の選好を指示する。
計算量は `high$l より少なく済み得る。
◎
The "low" value indicates a preference for a low level of image interpolation quality. Low-quality image interpolation may be more computationally efficient than higher settings.
</dd>

	<dt>`medium@l</dt>
	<dd>
中間~品質の画像~補間の選好を指示する。
◎
The "medium" value indicates a preference for a medium level of image interpolation quality.
</dd>

	<dt>`high@l</dt>
	<dd>
高~品質な画像~補間の選好を指示する。
計算量は `low$l より多くなり得る。
◎
The "high" value indicates a preference for a high level of image interpolation quality. High-quality image interpolation may be more computationally expensive than lower settings.
</dd>

</dl>


<p class="note">注記：
双線形~拡縮は、比較的~高速で，より低~品質な画像を滑らかに補間する~algoの例である。
双三次 ／ Lanczos
拡縮は、より高~品質な出力を生産する画像~拡縮~algoの例である。
この仕様は、値 `pixelated$l を除いて，特定の補間~algoの利用を義務付けない。
◎
Bilinear scaling is an example of a relatively fast, lower-quality image-smoothing algorithm. Bicubic or Lanczos scaling are examples of image-scaling algorithms that produce higher-quality output. This specification does not mandate that specific interpolation algorithms be used unless the value is "pixelated".
</p>



<div class="example">
<p>
この~APIを利用して、~sprite-sheetを事前に切り分けて準備する例：
◎
Using this API, a sprite sheet can be precut and prepared:
</p>

<pre>var %sprites = {};
function loadMySprites() {
  var %image = new Image();
  %image.src = 'mysprites.png';
  var %resolver;
  var %promise = new Promise(function (%arg) { %resolver = %arg });
  %image.onload = function () {
    %resolver(Promise.all([
      createImageBitmap(%image,  0,  0, 40, 40)
        .then(function (%image) { %sprites.person = %image }),
      createImageBitmap(%image, 40,  0, 40, 40)
        .then(function (%image) { %sprites.grass   = %image }),
      createImageBitmap(%image, 80,  0, 40, 40)
        .then(function (%image) { %sprites.tree  = %image }),
      createImageBitmap(%image,  0, 40, 40, 40)
        .then(function (%image) { %sprites.hut   = %image }),
      createImageBitmap(%image, 40, 40, 40, 40)
        .then(function (%image) { %sprites.apple = %image }),
      createImageBitmap(%image, 80, 40, 40, 40)
        .then(function (%image) { %sprites.snake = %image })
    ]));
  };
  return %promise;
}

function runDemo() {
  var %canvas = document.querySelector('canvas#demo');
  var %context = %canvas.getContext('2d');
  %context.drawImage(%sprites.tree, 30, 10);
  %context.drawImage(%sprites.snake, 70, 10);
}

loadMySprites().then(runDemo);
</pre>

</div>

		</section>
		<section id="animation-frames">
<h2 title="Animation frames">8.9. ~animation~frame</h2>

<div class="p">
<p>
各 `文書$は、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~animation~frame~callback~list@</dt>
	<dd>
初期~時は空。
</dd>

	<dt>`~animation~frame~callback識別子@</dt>
	<dd>
整数（初期~時は 0 ）。
</dd>
</dl>
◎
Each Document has a list of animation frame callbacks, which must be initially empty, and an animation frame callback identifier, which is a number which must initially be zero.
</div>


<dl class="idl-def">
	<dt>`requestAnimationFrame(callback)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the requestAnimationFrame() method is called, the user agent must run the following steps:
</p>

		<ol>
			<li>
%文書 ~LET 此れに`結付けられている文書$
◎
Let document be this Window object's associated Document.
</li>
			<li>
%文書 の`~animation~frame~callback識別子$ ~INCBY 1
</li>
			<li>
%識別子 ~LET %文書 の`~animation~frame~callback識別子$
◎
Increment document's animation frame callback identifier by one.
</li>
			<li>
%callback に %識別子 を結付ける
◎
↓</li>
			<li>
%文書 の`~animation~frame~callback~list$に %callback を付加する
◎
Append the method's argument to document's list of animation frame callbacks, associated with document's animation frame callback identifier's current value.
</li>
			<li>
~RET %識別子
◎
Return document's animation frame callback identifier's current value.
</li>
		</ol>
	</dd>

	<dt>`cancelAnimationFrame(handle)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the cancelAnimationFrame() method is called, the user agent must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れに`結付けられている文書$の`~animation~frame~callback~list$内に
%handle を結付けている~callbackはある
］
⇒
%文書 の`~animation~frame~callback~list$から その~callbackを除去する
◎
Let document be this Window object's associated Document.
◎
Find the entry in document's list of animation frame callbacks that is associated with the value given by the method's argument.
◎
If there is such an entry, remove it from document's list of animation frame callbacks.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
~UAは，
`~animation~frame~callbackたちを走らす@
ときは、所与の
( `文書$ %文書, 時刻印 %now )
に対し，次を走らせ~MUST：
◎
When the user agent is to run the animation frame callbacks for a Document doc with a timestamp now, it must run the following steps:
</p>

<ol>
	<li>
%~callback~list ~LET %文書 の`~animation~frame~callback~list$の複製
◎
Let callbacks be a list of the entries in doc's list of animation frame callbacks, in the order in which they were added to the list.
</li>
	<li>
%文書 の`~animation~frame~callback~list$を空にする
◎
Set doc's list of animation frame callbacks to the empty list.
</li>
	<li>
%~callback~list 内の~EACH ( %~callback ) に対し
⇒
%now を引数に渡して %~callback を`呼出す$x
`WEBIDL$r
⇒
例外が投出されたときは、~catchして
⇒
その`例外を報告する$
◎
For each entry in callbacks, in order: invoke the callback, passing now as the only argument, and if an exception is thrown, report the exception. [WEBIDL]
</li>
</ol>


		</section>
</main>
