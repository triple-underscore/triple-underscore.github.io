<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>BCP56 — Building Protocols with HTTP（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:
spec_date:2021-03-18
trans_update:2021-03-29
source_checked:210114
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-bcp56bis.html
	abbr_url:BCP56
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2021-01-19

●●original_id_map

references:
normative:
informative:

●●mdn_urls

●●link_map

sdir.no-store:~HTTPcache#cache-response-directive.no-store
sdir.max-age:~HTTPcache#cache-response-directive.max-age
sdir.no-cache:~HTTPcache#cache-response-directive.no-cache
sdir.must-revalidate:~HTTPcache#cache-response-directive.must-revalidate
sdir.public:~HTTPcache#cache-response-directive.public

h.Content-Security-Policy:~CSP3#header-content-security-policy
h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
h.X-Content-Type-Options:~FETCH#http-x-content-type-options
	h.Cookie:~HTTPcookie#sane-cookie

c.HttpOnly:~HTTPcookie#attribute-httponly


新鮮:~HTTPcache#fresh
非新鮮:~HTTPcache#stale
鮮度~維持期間:~HTTPcache#freshness-lifetime

~MIME型:~HTTPsem#media-type

有構造~header:~HEADER-STRUCTURE#structured-header

~link関係:~HTTPweblink#links
~link関係~型:~HTTPweblink#_link-relation-types

~secureな文脈:~SECURE-CONTEXT#secure-contexts
	enV.~secureな文脈:~WAPI#secure-context

cite.~HTTP~method~registry:~IANA-a/http-methods

~CORS~protocol:~FETCH#cors-protocol

	●§
~method~registry:~HTTPinfra#method.registry
新たな~fieldに対する考慮点:~HTTPinfra#considerations.for.new.fields
証明書の検証y:~HTTPinfra#https.verify
鮮度の経験的な計算-法:~HTTPcache#heuristic.freshness
~cache内への応答の格納-法:~HTTPcache#response.cacheability
非新鮮な応答の~serve法:~HTTPcache#serving.stale.responses
齢の計算-法:~HTTPcache#age.calculations

1:#introduction
1.1:#notational-conventions
2:#used
2.1:#non-http-protocols
3:#overview
3.1:#generic-semantics
3.2:#links
3.3:#rich-functionality
4:#bp
4.1:#specifying-the-use-of-http
4.2:#resource
4.3:#clients
4.4:#specifying-urls
4.4.1:#discovering-an-applications-urls
4.4.2:#scheme
4.4.3:#transport-ports
4.5:#using-http-methods
4.5.1:#get
4.5.2:#options
4.6:#using-http-status-codes
4.6.1:#redirects
4.7:#headers
4.8:#content
4.9:#caching
4.9.1:#freshness
4.9.2:#stale-responses
4.9.3:#caching-and-application-semantics
4.9.4:#varying-content-based-upon-the-request
4.10:#state
4.12:#client-auth
4.13:#browser
4.14:#other-apps
4.15:#server-push
4.16:#versioning
5:#iana-considerations
6:#security-considerations
6.1:#privacy-considerations
A:#changes-from-rfc-3205


●●words_table1
HTTPcookie:http-cookie-ext-ja.html

●●words_table

	●略称
IETF:
HSTS:
IP:
REST:
WebDAV:
CDN:
	CDN:Content Delivery Network
ALPN:
HTTP1:HTTP/1
HTTP2:HTTP/2
HTTP3:HTTP/3
CBOR:
CSRF:
	~CSRF:cross-site request forgery
XSS:
	^en:cross-site scripting
	Cross-Site Scripting
Basic:
Digest:

	●cache
維持期間:lifetime::~
	新鮮に:freshly
新鮮化-:refresh::~
差分:delta:~
齢:age:~
私用:private::~::プライベート
再検証-:revalidate::~
有効期間:validity period:~

	●network
hostname::::ホスト名
多重化-:multiplex::~
	多重化-法:multiplexing
輻輳:congestion::~
切断-:disconnect:~
探査-:probe:~
ticket::::チケット
	^en:captive portal
発行i-:issue:発行
優先度:priority::~
	優先度をどう選ぶか:how 〜 chooses to prioritize

	●保安
ambient:
証明書:certificate:~
能動的:active:~
分解能:resolution::~
悪用s:exploits:悪用

	~~指標:marker
	誘い込まれ／誘い込む:coax

	●仕様
発展-:evolve:~
価値:value:~
共存-:coexist:~
多彩:rich:~
発展:evolution:~
誂える:tailorする:~
念頭:mind:~
発生-:arise:~
場当的:ad-hoc:場当たり的
読者:reader:~
消費:consumption:~
文言:language:~
流儀:fashion:~
抑制:reduction:~
注記-:note:~
	述べられ:note
単直:straightforward:簡単
高価:expensive:~
枯渇-:exhaust:~
利点:advantage:~
注力-:focus:~
策:strategy:~
直面-:face:~
運用能:operability:~
捕捉-:capture:~
著しく:substantialに:~
指摘-:point out:~
自由度:freedom:~
活用-:leverage:~
不安定:brittle:~
強奪-:usurp:~
出発点:starting point:~
仕様策定者:specifier:~
管理者:administrator:~
馴染み:familiar:~
	馴染み易さ:familiarity
木目細か:fine-grained:~
	より木目細か:finer-grained
行詰まり:dead end:行き詰まり
現実の:realな:~
特例:special case:~
	特例~化:special-casing
機会:opportunity:~
固定的:fixed:~
入口:entry point:~
衝突-:collide:~
衝突:collision:~
概略的:brief:~
限定-:confine:~
個別:individual:~
粒度:granularity:~
大規模:pervasive:~
陥穽:pitfall:落とし穴
希薄:tenuous:~
稼働時の:runtime:~
普遍的:universal:~
副次的:secondary:~
創出-:mint:~
調査-:survey:~
機能:function:~
信頼性:reliability:~
節約-:save:~
解法:solution:~
努める:striveする:~
逸脱-:diverge:~
多岐:diverse:~
	~~多岐に渡る:vary widely
基底層:substrate:~
設計者:designer:~
帰属:attribution:~
	誤った帰属:misattribution
profile::::プロファイル
tradeoff::::トレードオフ
周知:well-known:~
注意事項:caveat:~
特質:properties:~
発見:discovery:~
歩調:pace:~
破る:breakする:~
異質:disparate:~
適応-:accommodate:~
人工物:artefact:~
競合:contention::~
一式:suite:~
排他的:exclusive:~
優遇-:favour:~
協調-:coordinate:~
	協調しない:uncoordinated

	●仕様（他
	自覚しない:unaware
	に反して:despite
	書き手:writer
	良い:good
	〜が無い:〜 free
	独り占め:squatting
	望ましい:desirable
	可用でない:unavailable
	指定し直す:re-specify
	失う:lose
	もたらす:bring
	失われ:lost
	分けること:split
	定義し直-:re-define
	予め除外-:preclude
	好ましい:preferably
	近付ける:align 〜 as closely as
	感じる:feel
	早期:early
	疑わしい:in doubt
	好ましい:preferable
	指定し直-:re-specify
	後方-互換でない:backwards-incompatible
	勧める:advised to
	避けれない:unavoidable
	意図されない:unintended
	容易さ:ease
	相応しくないもの:unsuitable
	人々:people
	〜しがち:often tempting to
	用立てる:utilise
	標準でない:non-standard
	強制される:in force
	見かける:seen
	知る:know
	今や:now
	独り占め:squatting
	それでも:nevertheless
	手に余る:unwieldy
	かなり:considerably
	でしかないのに:even though 〜 at best
	転じて:in turn
	~version付け:versioning
	念頭に置く:keep in mind
	改変されない限り:unmodified
	見込みが高い／見込まれ:likely
	“§ ~securityの考慮点” :Security Considerations
	見通しは立たない't be 〜 foreseeable future
	より良い:better
	起こる:happenする
	〜に基づく:is how
	誤り難く:less error-prone
	現在の最善な実施:Best Current Practice／best current practice
	要は、:importantly,
	標準~化:standard 〜
	選ばれ:chosen
	書く:writing
	体を成すもの:body of 
	~~具体的には:namely
	にもかかわらず:when in fact
	特にとりあげる:highlight
	複数の〜引き合わせる:mix and match
	混ぜ合わせ:mixed together
	称されることもある:sometimes referred
	限られた:limited
	支え続ける:sustain
	多大な:great
	綿密に調べる:scrutinise
	大きな~~理由は:largely because
	と見做す下で:with an assumption that
	見做して:make assumptions
	きちんと:wellに
	該当する事例は〜にも多い:as is often the case
	〜下:under
	多様な:variety of
	~~多岐に渡る:vary widely
	またがり:span
	変わり得る／変わる:vary
	なり得る／され得る／あり得る:potentially
	応用を配備し得る〜:potential
	それにより:thereby
	ここに与える:herein
	~~判断した:think
	すでに:readily
	〜に伴い，その周りに:around
	のみならず:not just
	〜しないだけ:just not
	これら一群:group
	ようになる:now
	二点:two ways
	したがって:As a result
	変え方:varying
	ある文脈~下に置く:contextualise
	一握り:small sample
	見かけ:look
	は別として:besides
	あまりに多過ぎる:too numerous
	ずっと:much more
	多くは〜占める:much of
	共存-法:co-existing
	書かれ:written
	~~明白でない:less obvious
	間口が広い:generous
	いつの日か:future
	誤った方へ導き:misled
	至る:lead
	幅広い:broad
	呼び出す:call out
	〜について述べる:contain／convey
	認識共有／^en:mindshare
	特有:highly specific
	成り行き:outcome
	原因:cause

	●例
Widget:
scale::::スケール
	~scale能:scalability
拡散:fanout:~
publish:
subscribe:
interception:

	●言い換え
	~script:scripting languages
	層を重ね:overlay
	~~下層にある:underly
	名前空間:name-space
	静的に:statically
	所在を得る:locate
	所在が得られ:locate
	~~関連性:link
	~log取り:logging
	~secureでない:insecure
	内容~符号法:content-coding
	~cache制御:cache-control
	~~関連付ける:connect
	~clientを惑わし:confusion
	~HTTP:the protocol
	~HTTP~method~registry:HTTP Method Registry
	~cookie:Cookie
	~URI~template:URI Template
	為すとき:making

	●未分類
最低:minimum:~
最高:maximum:~
繰返ly:repeatedly:繰り返し
識別情報:identity::~
一対一:one-to-one:~
差挟まれ:interpose:差し挟まれ
	~MIME型:media type
mobile::::モバイル
収まる:fitする:~
発する:emitする:~
patch::::パッチ
timer::::タイマー
	周知な:Well-Known
chat::::チャット
	~chat的:chatty
横断-:traverse:~
拡げら:expandさ:~
template::::テンプレート
失効:expiry:~
構成-:compose:~

	^en:laundry list
	^en:fork
	視野-法:scoping
	増える:increase
	逆~proxy:reverse proxy
	場所:place
	秒:seconds
	後続の:subsequent
	もの:thing
	~~高頻度:high rate
	項:term
	短い／短く:short
	し始める:begin
	以前より:previously
	各部:parts
	一部分／部位:portion
	いくつ／:how many
	の挙動:that of
	ときには:sometimes
	またがる:across
	〜番台の:series of
	表:table
	高-:high-
	少数の:one or a few
	年代初頭:early
	集められ:gather
	生成元~~全般:origin-wide
	へばりつく:sticky

●●ref_key_map
IDIETFHTTPBISSEMANTICS:SEMANTICS
IDIETFHTTPBISCACHE:CACHING
IDIETFHTTPBISMESSAGING:MESSAGING
SECCTXT:SECURECONTEXTS

●●ref_data
IDIETFHTTPBISHEADERSTRUCTURE=副  ~/http-header-structure-ja.html
IDIETFHTTPBISRFC6265BIS=副       ~/http-cookie-ext-ja.html

●●ref_normative

[I-D.ietf-httpbis-semantics]
    Fielding, R. T., Nottingham, M., and J. Reschke, "HTTP Semantics", Work in Progress, Internet-Draft, draft-ietf-httpbis-semantics-14, 12 January 2021, URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics-14.txt
[RFC2119]
    Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, ~RFC2119, March 1997.
[RFC8174]
    Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, ~RFC8174, May 2017.
[RFC7301]
    Friedl, S., Popov, A., Langley, A., and E. Stephan, "Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension", ~RFC7301, July 2014.
[RFC8820]
    Nottingham, M., "URI Design and Ownership", BCP 190, ~RFC8820, June 2020.
[RFC6838]
    Freed, N., Klensin, J., and T. Hansen, "Media Type Specifications and Registration Procedures", BCP 13, ~RFC6838, January 2013.
[RFC8288]
    Nottingham, M., "Web Linking", ~RFC8288, October 2017.
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, ~RFC3986, January 2005.
[RFC8615]
    Nottingham, M., "Well-Known Uniform Resource Identifiers (URIs)", ~RFC8615, May 2019.
[RFC6454]
    Barth, A., "The Web Origin Concept", ~RFC6454, December 2011.
[RFC6648]
    Saint-Andre, P., Crocker, D., and M. Nottingham, "Deprecating the "X-" Prefix and Similar Constructs in Application Protocols", BCP 178, ~RFC6648, June 2012.

●●ref_informative

[HTML]
    WHATWG, "HTML - Living Standard", n.d., URL: https://html.spec.whatwg.org
[FETCH]
    WHATWG, "Fetch - Living Standard", n.d., URL: https://fetch.spec.whatwg.org
[RFC8259]
    Bray, T., Ed., "The JavaScript Object Notation (JSON) Data Interchange Format", STD 90, ~RFC8259, December 2017.
[RFC6570]
    Gregorio, J., Fielding, R., Hadley, M., Nottingham, M., and D. Orchard, "URI Template", ~RFC6570, March 2012.
[I-D.ietf-httpbis-rfc6265bis]
    West, M. and J. Wilander, "Cookies: HTTP State Management Mechanism", Work in Progress, Internet-Draft, draft-ietf-httpbis-rfc6265bis-07, 7 December 2020, URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-07.txt
[RFC7258]
    Farrell, S. and H. Tschofenig, "Pervasive Monitoring Is an Attack", BCP 188, ~RFC7258, May 2014.
[I-D.ietf-httpbis-cache]
    Fielding, R. T., Nottingham, M., and J. Reschke, "HTTP Caching", Internet-Draft draft-ietf-httpbis-cache-14, 12 January 2021, URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cache-14.txt
[RFC6797]
    Hodges, J., Jackson, C., and A. Barth, "HTTP Strict Transport Security (HSTS)", ~RFC6797, November 2012.
[SECCTXT]
    West, M., "Secure Contexts", World Wide Web Consortium CR CR-secure-contexts-20160915, September 2016, URL: https://www.w3.org/TR/2016/CR-secure-contexts-20160915
[RFC7595]
    Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines and Registration Procedures for URI Schemes", BCP 35, ~RFC7595, June 2015.
[RFC7605]
    Touch, J., "Recommendations on Using Assigned Transport Port Numbers", BCP 165, ~RFC7605, August 2015.
[RFC4791]
    Daboo, C., Desruisseaux, B., and L. Dusseault, "Calendaring Extensions to WebDAV (CalDAV)", ~RFC4791, March 2007.
[RFC4918]
    Dusseault, L., Ed., "HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)", ~RFC4918, June 2007.
[RFC6415]
    Hammer-Lahav, E., Ed. and B. Cook, "Web Host Metadata", ~RFC6415, October 2011.
[RFC7807]
    Nottingham, M. and E. Wilde, "Problem Details for HTTP APIs", ~RFC7807, March 2016. 
[RFC7540]
    Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext Transfer Protocol Version 2 (HTTP/2)", ~RFC7540, May 2015.
[RFC8941]
    Nottingham, M. and P-H. Kamp, "Structured Field Values for HTTP", ~RFC8941, February 2021.
[XML]
    Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, "Extensible Markup Language (XML) 1.0 (Fifth Edition)", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, URL: https://www.w3.org/TR/2008/REC-xml-20081126
[RFC7049]
    Bormann, C. and P. Hoffman, "Concise Binary Object Representation (CBOR)", ~RFC7049, October 2013.
[RFC5861]
    Nottingham, M., "HTTP Cache-Control Extensions for Stale Content", ~RFC5861, May 2010.
[I-D.ietf-httpbis-priority]
    Oku, K. and L. Pardue, "Extensible Prioritization Scheme for HTTP", Work in Progress, Internet-Draft, draft-ietf-httpbis-priority-03, 11 January 2021, URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-priority-03.txt
[RFC7617]
    Reschke, J., "The 'Basic' HTTP Authentication Scheme", ~RFC7617, September 2015.
[RFC7616]
    Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, "HTTP Digest Access Authentication", ~RFC7616, September 2015.
[RFC5246]
    Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.2", ~RFC5246, August 2008.
[CSP]
    West, M., "Content Security Policy Level 3", World Wide Web Consortium WD WD-CSP3-20160913, 13 September 2016, URL: https://www.w3.org/TR/2016/WD-CSP3-20160913
[REFERRER-POLICY]
    Eisinger, J. and E. Stark, "Referrer Policy", World Wide Web Consortium CR CR-referrer-policy-20170126, January 2017, URL: https://www.w3.org/TR/2017/CR-referrer-policy-20170126
[RFC8297]
    Oku, K., "An HTTP Status Code for Indicating Hints", ~RFC8297, December 2017.
[RFC3205]
    Moore, K., "On the use of HTTP as a Substrate", BCP 56, ~RFC3205, February 2002.

●●
Author's Address

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として発行された，
<a href="~SPEC_URL">Building Protocols with HTTP</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

発行者
	<a href="http://httpwg.github.io/">HTTP Working Group</a>
位置付け
	Internet-Draft
意図される位置付け
	Best Current Practice（現在の最善な実施）
廃用
	<a href="https://datatracker.ietf.org/doc/html/rfc3205">3205</a>（認可されたならば）
著作者
	M. Nottingham

論点（ HTTP WG mailing list ）
	ietf-http-wg@w3.org ( <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a> )
ソースコード／課題リスト
	https://github.com/httpwg/http-extensions/labels/bcp56bis
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-bcp56bis.md

著作者のアドレス
	Mark Nottingham, made in Prahran VIC Australia, EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a>, URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a>

</script>

</head>
<body>


<header>
	<hgroup>
<h1>HTTP に基づくプロトコルの築き方</h1>
<h2>BCP 56 — Building Protocols with HTTP</h2>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
~HTTPは、~HTTPに基づく~APIを作成するための，他の応用~protocol用の基底層として利用されることが多い。
この文書は、新たな応用~protocolを定義するために~HTTPを利用する仕様を書くための最善な実施（ `best practice^en ）を指定する
— とりわけ，それらが［
多岐な実装や幅広い配備
］用に定義されるとき（例：標準~化への労（ `standards efforts^en ）において）。
◎
HTTP is often used as a substrate for other application protocols to create HTTP-based APIs. This document specifies best practices for writing specifications that use HTTP to define new application protocols, especially when they are defined for diverse implementation and broad deployment (e.g., in standards efforts).
</p>

	</section>
	<section id="name-note-to-readers">
<h2 title="Note to Readers">読者~向けの注記</h2>

<p>
`この節は、発行~前に除去されることになる^em
【以下，この節の他の内容は、冒頭の仕様~metadataに移譲。】
◎
RFC EDITOR: please remove this section before publication
◎
Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at https://lists.w3.org/Archives/Public/ietf-http-wg/.
◎
Working Group information can be found at http://httpwg.github.io/; source code and issues list for this draft can be found at https://github.com/httpwg/http-extensions/labels/bcp56bis.
</p>

	</section>
	<section id="name-status-of-this-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>／冒頭の仕様~metadata
に委譲。
】</p>

	</section>
	<section id="name-copyright-notice">

<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en-x-a0">
Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に委譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP `I-D.ietf-httpbis-semantics$r は、~Web閲覧~以外の応用~用の基底層として利用されることが多い。
これは、［
“~HTTPに基づく~API” ／
“~REST~API” ／
単に “~HTTP~API”
］を作成すること，と称されることもある。
これが行われるのには、多様な理由がある
— 例えば：
◎
HTTP [I-D.ietf-httpbis-semantics] is often used as a substrate for applications other than Web browsing; this is sometimes referred to as creating "HTTP-based APIs", "REST APIs" or just "HTTP APIs". This is done for a variety of reasons, including:
</p>
<ul>
	<li>
［
実装者／仕様策定者／管理者／開発者／利用者
］にとっての馴染み易さ
◎
familiarity by implementers, specifiers, administrators, developers and users,
</li>
	<li>
多様な［
`~client$, `~server$, `~proxy$
］実装の可用性
◎
availability of a variety of client, server and proxy implementations,
</li>
	<li>
利用の容易さ
◎
ease of use,
</li>
	<li>
~Web~browserの可用性
◎
availability of Web browsers,
</li>
	<li>
認証や暗号化の様な，既存の仕組みの再利用
◎
reuse of existing mechanisms like authentication and encryption,
</li>
	<li>
~target配備に~HTTP［
`~server$, `~client$
］が在ること
◎
presence of HTTP servers and clients in target deployments, and
</li>
	<li>
~firewallを横断する，その能。
◎
its ability to traverse firewalls.
</li>
</ul>

<p>
そのような応用~protocolは、［
少数の`~server$による配備,
限られた`~client$による消費
］用にしか意図されず，場当的になることが多い。
その結果、上に挙げた条件を優遇するような ~HTTPに基づく~APIを定義することに伴い，その周りに［
実施／~tool
］の体を成すものたちが発生した。
◎
These protocols are often ad hoc; they are intended for only deployment by one or a few servers, and consumption by a limited set of clients. As a result, a body of practices and tools has arisen around defining HTTP-based APIs that favours these conditions.
</p>

<p>
しかしながら，そのような応用に複数の別々な実装があって，互いに協調しない複数の`~server$で配備され，多岐な`~client$により消費されるとき（該当する事例は、標準~化への労により定義される~HTTP~APIにも多い）、限られた配備~用に意図される~toolや実施は，相応しくないものになり得る。
◎
However, when such an application has multiple, separate implementations, is deployed on multiple uncoordinated servers, and is consumed by diverse clients -- as is often the case for HTTP APIs defined by standards efforts -- tools and practices intended for limited deployment can become unsuitable.
</p>

<p>
その大きな~~理由は、（`~client$, `~server$どちらも）実装が【応用を】実装して発展する歩調が それぞれに異なるからである
— また、可用な［
特能／~version
］も，配備に応じて異なることが多いからである。
したがって，そのような~HTTPに基づく~APIの設計者は、その~serviceの拡張能がどう取扱われ，異なる配備~要件に どう適応することになるかについて、もっと注意深く考慮する必要がある。
◎
This is largely because implementations (both client and server) will implement and evolve at different paces, and because deployments will often have different features and versions available. As a result, the designers of such an HTTP-based API will need to more carefully consider how extensibility of the service will be handled and how different deployment requirements will be accommodated.
</p>

<p>
より一般には、~HTTPを利用している応用~protocolは，その設計にあたって
— 次に挙げるものなど —
いくつかの裁定に直面する：
◎
More generally, an application protocol using HTTP faces a number of design decisions, including:
</p>
<ul>
	<li>
新たな~URI~schemeを定義するべきか？
新たな~portを利用するか？
◎
Should it define a new URI scheme? Use new ports?
</li>
	<li>
標準な~HTTP［
`~method$／`状態s~code$
］を利用するべきか？
新たなものを定義するべきか？
◎
Should it use standard HTTP methods and status codes, or define new ones?
</li>
	<li>
~HTTPの利用から，最大な価値をどう抽出できるか？
◎
How can the maximum value be extracted from the use of HTTP?
</li>
	<li>
~HTTPの他の利用
— とりわけ~Web閲覧 —
とどう共存するか？
◎
How does it coexist with other uses of HTTP -- especially Web browsing?
</li>
	<li>
相互運用能の問題と “~protocolの行詰まり” をどう避けれるか？
◎
How can interoperability problems and "protocol dead ends" be avoided?
</li>
</ul>

<p>
この文書は、そのような応用の仕様~用に，現在の最善な実施について述べる【！包含する】
⇒＃
`2$sec は、それが いつ適用されるかを定義する。
`3$sec は、~HTTPに備わる特質のうち，保全することが重要なものについて調査する。
`4$sec は、それらを指定するための最善な実施について述べる【！伝達する】。
◎
This document contains best current practices for the specification of such applications. Section 2 defines when it applies; Section 3 surveys the properties of HTTP that are important to preserve, and Section 4 conveys best practices for the specifying them.
</p>

<p>
この文書は首に，~Internetへの配備~用に［
~HTTPを利用している応用~protocol
］を定義する~IETFの労を手引きするために書かれたが、他の状況においても適用-可能かもしれない。
ここに与える要件は、汎用な~HTTP拡張の開発には，適用されるとは限らないことに注意。
◎
It is written primarily to guide IETF efforts to define application protocols using HTTP for deployment on the Internet, but might be applicable in other situations. Note that the requirements herein do not necessarily apply to the development of generic HTTP extensions.
</p>

		<section id="notational-conventions">
<h3 title="Notational Conventions">1.1. 表記規約</h3>

<p>
~keyword "MUST" …
【以下、この段落の内容（ `RFC2119$r, `RFC8174$r ）は<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>に委譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

		</section>
	</section>
	<section id="used">
<h2 title="Is HTTP Being Used?">2. ~HTTPは利用されているか？</h2>

<p>
応用が~HTTPを利用する目標は、それぞれに異なる。
この文書における要件は、仕様が，次のいずれかに該当する応用を定義するときに適用される：
◎
Different applications have different goals when using HTTP. The requirements in this document apply when a specification defines an application that:
</p>
<ul>
	<li>
~transport~portに［
80 ／ 443
］【すなわち，~HTTP／~HTTPS用の既定の~port】を利用するもの。
◎
uses the transport port 80 or 443, or
</li>
	<li>
~URI~schemeに［
"`http$c" ／ "`https$c"
］を利用するもの。
◎
uses the URI scheme "http" or "https", or
</li>
	<li>
~HTTPを汎用に識別する，
~ALPN~protocol~ID `RFC7301$r
（例： `http/1.1^c, `h2^c, `h2c^c ）を利用するもの。
◎
uses an ALPN protocol ID [RFC7301] that generically identifies HTTP (e.g., "http/1.1", "h2", "h2c"), or
</li>
	<li>
~HTTP用に定義される~IANA~registryを［
更新する／改変する
］もの。
◎
updates or modifies the IANA registries defined for HTTP.
</li>
</ul>

<p>
加えて，仕様が~HTTPを利用する所では、［
~HTTP~protocol一式を成す，すべての要件
］が強制される（特に，
`I-D.ietf-httpbis-semantics$r
— 他の適切な仕様も）。
◎
Additionally, when a specification is using HTTP, all of the requirements of the HTTP protocol suite are in force (in particular, [I-D.ietf-httpbis-semantics], but also other specifications as appropriate).
</p>

<p>
この文書は、~HTTPに対する汎用な拡張ではなく，応用に適用するものと意図されていることに注意
— 汎用な拡張は、関連な仕様における要件に従う。
この文書はまた、~IETF仕様により定義される応用~用に意図される
— 他の組織による標準も，この文書の要件を固守することが奨励されるが。
◎
Note that this document is intended to apply to applications, not generic extensions to HTTP, which follow the requirements in the relevant specification. Furthermore, it is intended for applications defined by IETF specifications, although other standards organisations are encouraged to adhere to its requirements.
</p>

		<section id="non-http-protocols">
<h3 title="Non-HTTP Protocols">2.1. 非~HTTP~protocol</h3>

<p>
ある仕様は、~HTTPを上の判定基準に則って利用しない一方で，依然として何らかの方式で~HTTPに依拠する応用を定義するかもしれない。
例えば，ある応用は、~message形式を成す各部を指定し直すのは避けたいが，［
~protocolの運用を成す他の側面は変更したいと望む,
あるいは、異なる`~method$の集合を利用したいと求める
］かもしれない。
◎
A specification might not use HTTP according to the criteria above and still define an application that relies upon HTTP in some manner. For example, an application might wish to avoid re-specifying parts of the message format, but change other aspects of the protocol's operation; or, it might want to use a different set of methods.
</p>

<p>
そうすることは，~protocol運用を改変する自由度をさらにもたらすが、上に要旨した便益の少なくとも一部分は失われる
— ほとんどの~HTTP実装は，そのような変更を容易には採用-可能でなく、~protocolが~HTTPから逸脱するに伴い，~~認識共有（ `mindshare^en ）による便益は失われることになるので。
◎
Doing so brings more freedom to modify protocol operations, but loses at least a portion of the benefits outlined above, as most HTTP implementations won't be easily adaptable to these changes, and as the protocol diverges from HTTP, the benefit of mindshare will be lost.
</p>

<p>
そのような仕様は、~HTTPの［
~URI~scheme／
~transport~port／
~ALPN~protocol~ID／
~IANA~registry
］を利用してはナラナイ
— それらには、自前のものを確立することが奨励される。
◎
Such specifications MUST NOT use HTTP's URI schemes, transport ports, ALPN protocol IDs or IANA registries; rather, they are encouraged to establish their own.
</p>

		</section>
	</section>
	<section id="overview">
<h2 title="What's Important About HTTP">3. ~HTTPについて何が重要か</h2>

<p>
この節では、~HTTP~protocolの特性のうち，~HTTPを利用している応用~protocolを定義するにあたって，何を考慮するのが重要かを精査する。
◎
This section examines the characteristics of the HTTP protocol that are important to consider when using HTTP to define an application protocol.

</p>

		<section id="generic-semantics">
<h3 title="Generic Semantics">3.1. 汎用な意味論</h3>

<p>
~HTTPの価値の多くは、その汎用な意味論が占める
— すなわち，~HTTPにより定義される~protocol要素は、特定0の文脈に特有ではなく，どの`資源$にも適用-可能になり得る。
応用に特有な意味論は、`~message$の［
`内容$／`~header$
］内に表出されるのが最善である
— ［
`状態s~code$／`~method$
］ではなく（これらにも，応用の状態に関係する汎用な意味論はあるが）。
◎
Much of the value of HTTP is in its generic semantics -- that is, the protocol elements defined by HTTP are potentially applicable to every resource, not specific to a particular context. Application-specific semantics are best expressed in message content and in header fields, not status codes or methods -- although the latter do have generic semantics that relate to application state.
</p>

<p>
このように［
汎用なもの, 応用に特有なもの
］に分けることは、~software（例：
~HTTP［
`~server$／`中継者$／`~client$
］の実装, および`~cache$）が［
特定の応用を解することなく，~HTTP`~message$を取扱う
］ことを許容する。
それはまた、人々が
— 特定0の応用に対し，それら【その応用に利用される汎用なもの】を特例~化することなく —
~HTTP意味論に関する自身の知識を活用することも許容する。
◎
This generic/application-specific split allows a HTTP message to be handled by software (e.g., HTTP servers, intermediaries, client implementations, and caches) without understanding the specific application. It also allows people to leverage their knowledge of HTTP semantics without special-casing them for a particular application.
</p>

<p>
したがって，~HTTPを利用する応用は、汎用な~protocol要素
— `~method$, `状態s~code$, 既存の`~header$など —
の意味論を定義し直したり, 精緻化したり, その上に層を重ねてはナラナイ。
代わりに応用は、自身の仕様において，自身に特有な~protocol要素
— ~~具体的には，自身の~HTTP`資源$ —
に対し注力するべきである。
◎
Therefore, applications that use HTTP MUST NOT re-define, refine or overlay the semantics of generic protocol elements such as methods, status codes or existing header fields. Instead, they should focus their specifications on protocol elements that are specific to that application; namely their HTTP resources.
</p>

<p>
仕様を書くときは、~HTTPが正確にどう［
実装され, ~supportされ, 利用されるか
］を指定しがちである。
しかしながら，これは、意図されない［
~HTTPの挙動を成す~profile
］へ容易に導く。
例えば、次の様な文言が記された仕様は，共通的に見かける
⇒
“`POST^m 要請による結果は `201$st 応答でなければナラナイ”。
◎
When writing a specification, it's often tempting to specify exactly how HTTP is to be implemented, supported and used. However, this can easily lead to an unintended profile of HTTP's behaviour. For example, it's common to see specifications with language like this:
• A `POST` request MUST result in a `201 Created` response.
</p>

<p>
これは，［
`~client$において，応答は常に `201$st になる
］という期待を形成する
— 現実の配備において`状態s~code$が なぜ相違し得るかには，いくつか理由があるにもかかわらず：
例えば，［
認証を要求する`~proxy$／~server側の~error【 `5xx$st0 】／~redirection【 `3xx$st0 】
］があるかもしれない。
`~client$が これを見越さない場合、応用の配備は不安定になる。
◎
This forms an expectation in the client that the response will always be 201 Created, when in fact there are a number of reasons why the status code might differ in a real deployment; for example, there might be a proxy that requires authentication, or a server-side error, or a redirection. If the client does not anticipate this, the application's deployment is brittle.
</p>

<p>
より詳細は、 `4.2$sec を見よ。
◎
See Section 4.2 for more details.
</p>

		</section>
		<section id="links">
<h3 title="Links">3.2. ~link</h3>

<p>
別の共通的な実施は、~HTTP`~server$の名前空間（または，その一部分）を［
単独の応用の利用~用に排他的である
］と見做すことである。
これは，実質的に、その空間の上に特別な，応用に特有な意味論の層を重ねる
— その結果，他の応用がそれを利用するのを予め除外する。
◎
Another common practice is assuming that the HTTP server's name space (or a portion thereof) is exclusively for the use of a single application. This effectively overlays special, application-specific semantics onto that space, precludes other applications from using it.
</p>

<p>
`RFC8820$r にて説明されるように，［
ある標準による，~URL空間の一部に対する そのような “独り占め”
］は、`~server$の自前の`資源$に対する権限を強奪する
— したがって，配備における課題をもたらし得る —
ので，標準における不良な実施である。
◎
As explained in [RFC8820], such "squatting" on a part of the URL space by a standard usurps the server's authority over its own resources, can cause deployment issues, and is therefore bad practice in standards.
</p>

<p>
~HTTPを利用している応用には、~pathの様な~URI成分を静的に定義する代わりに，［
配備における柔軟性を許容するよう，~linkを定義して利用する
］ことが`推奨される^2119。
◎
Instead of statically defining URI components like paths, it is RECOMMENDED that applications using HTTP define and use links, to allow flexibility in deployment.
</p>

<p>
この流儀で稼働時の~linkを利用することには、他にも便益がいくつかある
— とりわけ，応用に複数の実装や配備があるときに（該当する事例は、標準~化されたものにも多い）。
◎
Using runtime links in this fashion has a number of other benefits -- especially when an application is to have multiple implementations and/or deployments (as is often the case for those that are standardised).
</p>

<p>
例えば，~linkで~navigateすることは、要請が，~redirectionの~overheadを伴わずに異なる`~server$へ~routeされることを許容する
— それにより、複数の~machineにまたがる配備も，きちんと~supportする。
◎
For example, navigating with a link allows a request to be routed to a different server without the overhead of a redirection, thereby supporting deployment across machines well.
</p>

<p>
また、当の~linkを包含している文書【`内容$】は，その~targetについての情報も包含できるので、次もアリになる
⇒＃
同じ`~server$上で異なる複数の応用を “引き合わせる” ／
［拡張能, ~version付け, 能力］の管理~用に自然な仕組みを提供する
◎
It also becomes possible to "mix and match" different applications on the same server, and offers a natural mechanism for extensibility, versioning and capability management, since the document containing the links can also contain information about their targets.
</p>

<p>
また，~linkを利用することは、~Webにて見かける形の［
~cacheの無効化
］を提供する。
ある`資源$の状態が変化したとき、応用は，常に新鮮な複製が~fetchされるよう，自身の~linkをそれへ変更できる。
◎
Using links also offers a form of cache invalidation that's seen on the Web; when a resource's state changes, the application can change its link to it so that a fresh copy is always fetched.
</p>

		</section>
		<section id="rich-functionality">
<h3 title="Rich Functionality">3.3. 多彩な機能性</h3>

<p>
~HTTPは
— 次に挙げるものなど —
いくつかの特能を応用に提供する：
◎
HTTP offers a number of features to applications, such as:
</p>
<ul>
	<li>
~message~frame法
◎
Message framing
</li>
	<li>
（~HTTP2における）多重化-法
◎
Multiplexing (in HTTP/2)
</li>
	<li>
~TLSとの統合
◎
Integration with TLS
</li>
	<li>
`中継者$（`~proxy$, `~gateway$, ~CDN（ `Content Delivery Network^en ））用の~support
◎
Support for intermediaries (proxies, gateways, Content Delivery Networks)
</li>
	<li>
~client認証
◎
Client authentication
</li>
	<li>
［
形式, 言語, その他
］の特能~用の`内容~折衝$
◎
Content negotiation for format, language, and other features
</li>
	<li>
［
`~server$の~scale能,
待時間と帯域幅の抑制,
信頼性
］を得るための~caching
◎
Caching for server scalability, latency and bandwidth reduction, and reliability
</li>
	<li>
~access制御の粒度（~URLの多彩な空間の利用を通して）
◎
Granularity of access control (through use of a rich space of URLs)
</li>
	<li>
応答【の`表現~data$】の一部を選択的に要請するための，部分的な内容【`範囲~要請$】
◎
Partial content to selectively request part of a response
</li>
	<li>
応用が~Web~browserを利用して容易にヤリトリする能
◎
The ability to interact with the application easily using a Web browser
</li>
</ul>

<p>
~HTTPを利用する応用には、~HTTPが提供する様々な特能を用立てることが奨励される
— ［
その利用者が，~HTTPから最大な便益を受取れる
］よう，および［
応用が多様な状況で配備されるのを許容する
］よう。
この文書は、特定の特能を利用するよう要求することはない
— 設計における適切な~tradeoffは、所与の状況に特有なので。
しかしながら， `4$sec に与える実施に従うことは、良い出発点になる。
◎
Applications that use HTTP are encouraged to utilise the various features that the protocol offers, so that their users receive the maximum benefit from it, and to allow it to be deployed in a variety of situations. This document does not require specific features to be used, since the appropriate design tradeoffs are highly specific to a given situation. However, following the practices in Section 4 is a good starting point.
</p>

		</section>
	</section>
	<section id="bp">
<h2 title="Best Practices for Specifying the Use of HTTP">4. ~HTTPの利用を指定するための最善な実施</h2>

<p>
この節は、応用による~HTTPの利用を指定するための最善な実施を述べる【！包含する】
— 特定の~HTTP~protocol要素~用の実施を含め。
◎
This section contains best practices for specifying the use of HTTP by applications, including practices for specific HTTP protocol elements.
</p>

		<section id="specifying-the-use-of-http">
<h3 title="Specifying the Use of HTTP">4.1. ~HTTPの利用の指定-法</h3>

<p>
~HTTPの利用を指定するときは、応用は，
`I-D.ietf-httpbis-semantics$r
を首な参照として利用するべきである。
応用は、特有な理由が無い限り（例：特定0の特能を呼び出すなど），［
~HTTP一式を成す すべての仕様
］を参照することは必要とされない。
◎
When specifying the use of HTTP, an application should use [I-D.ietf-httpbis-semantics] as the primary reference; it is not necessary to reference all of the specifications in the HTTP suite unless there are specific reasons to do so (e.g., a particular feature is called out).
</p>

<p>
~HTTP接続は、`隣点間$な~protocolなので，当の応用により制御されない実装
— 例： `~proxy$, ~CDN, ~firewall, 等々 —
からも取扱われ得る。
~HTTPの特定0の~versionを要求することは、これらの状況における利用を困難にすることに加え，相互運用能を害する。
したがって，~HTTPを利用している応用は、利用する~HTTPの最低~versionを指定しないことが`推奨される^2119。
◎
Because it is a hop-by-hop protocol, a HTTP connection can be handled by implementations that are not controlled by the application; for example, proxies, CDNs, firewalls and so on. Requiring a particular version of HTTP makes it difficult to use in these situations, and harms interoperability. Therefore, it is RECOMMENDED that applications using HTTP not specify a minimum version of HTTP to be used.
</p>

<p>
しかしながら，応用の配備が特定0の~HTTP~versionの利用から便益を得ることになる場合（例：~HTTP2による多重化-法）、それについて注記される~OUGHT。
◎
However, if an application's deployment would benefit from the use of a particular version of HTTP (for example, HTTP/2's multiplexing), this ought be noted.
</p>

<p>
~HTTPが発展する能を保全するため、~HTTPを利用している応用は，最高~versionを指定してはナラナイ。
◎
Applications using HTTP MUST NOT specify a maximum version, to preserve the protocol's ability to evolve.
</p>

<p>
応用は、~protocolにおけるヤリトリの例を指定するときは，［
要請, 応答
］両~messageとも，完全な`~header節$を伴うように文書化するべきである
— そうするときは、~HTTP11形式が好ましい。

◎
When specifying examples of protocol interactions, applications should document both the request and response messages, with complete header sections, preferably in HTTP/1.1 format.＼
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
GET /thing HTTP/1.1
Host: example.com
Accept: application/things+json
User-Agent: Foo/1.0

</pre>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/things+json
Content-Length: 500
Server: Bar/2.2

[内容]
</pre>
</div>
		</section>
		<section id="resource">
<h3 title="Specifying Server Behaviour">4.2. ~serverの挙動の指定-法</h3>

<p>
応用の`~server$側における~HTTPの挙動は、次に挙げる~protocol要素の用語で指定するのが，最も効果的な仕方になる：
◎
The most effective way to specify an application's server-side HTTP behaviours is in terms of the following protocol elements:
</p>
<ul>
	<li>
`~MIME型$ `RFC6838$r
— ~JSON `RFC8259$r などの形式~規約に基づくものが多い。
◎
Media types [RFC6838], often based upon a format convention such as JSON [RFC8259],
</li>
	<li>
~HTTP~header
— `4.7$sec に従って。
◎
HTTP header fields, as per Section 4.7, and
</li>
	<li>
`~link関係$ `RFC8288$r により識別される`資源$の挙動。
◎
The behaviour of resources, as identified by link relations [RFC8288].
</li>
</ul>

<p>
これらの~protocol要素で構成することにより、応用は，`資源$の集合を［
`~link関係$により識別され，指定された挙動を実装する
］ように定義できる
— 次に挙げるものを含め：
◎
By composing these protocol elements, an application can define a set of resources, identified by link relations, that implement specified behaviours, including:
</p>
<ul>
	<li>
`GET$m 要請を利用して，資源の状態を［
`~MIME型$により識別される， 1 つ以上の形式
］で検索取得する。
◎
retrieval of their state using GET, in one or more formats identified by media type;
</li>
	<li>
［
`POST$m ／ `PUT$m
］要請を その［
`内容$の形式
］が適切に識別されるように利用して，資源を作成したり更新する。
◎
resource creation or update using POST or PUT, with an appropriately identified request content format;
</li>
	<li>
`POST$m 要請と対する応答, および それらに識別される［
`内容$の形式
］を利用して，~dataを処理する。
◎
data processing using POST and identified request and response content format(s); and
</li>
	<li>
`DELETE$m 要請を利用して，資源を削除する。
◎
Resource deletion using DELETE.
</li>
</ul>

<div class="example">
<p>
例えば、応用は，次を指定するかもしれない：
◎
For example, an application might specify:
</p>
<ul>
	<li>
`資源$のうち`~link関係~型$ "`example-widget^c" を伴って~linkされたものは、~Widgetである。
~Widgetの状態は、
"`application/example-widget+json^c"
形式において，~fetchでき，同じ~linkへ向けた `PUT$m で更新できる。
~Widget資源は、削除できる。
◎
Resources linked to with the "example-widget" link relation type are Widgets. The state of a Widget can be fetched in the "application/example-widget+json" format, and can be updated by PUT to the same link. Widget resources can be deleted.
</li>
	<li>
~Widget表現に対する `Example-Count^h 応答~headerは、`送信者$が~Widgetをいくつ保持するかを指示する。
◎
The "Example-Count" response header field on Widget representations indicates how many Widgets are held by the sender.
</li>
	<li>
"`application/example-widget+json^c"
形式は、
~JSON `RFC8259$r 形式であり，~Widgetの状態を表現する。
それは、関係する情報への~linkを，
`Link$h ~headerの`~field値$の［
`~link関係~型$ "`example-other-info^c" で指示される~link
］内に包含する。
◎
The "application/example-widget+json" format is a JSON [RFC8259] format representing the state of a Widget. It contains links to related information in the link indicated by the Link header field value with the "example-other-info" link relation type.
</li>
</ul>
</div>

<p>
応用は、`~URI~template^cite `RFC6570$r の利用も指定できる
— それは、稼働時の~dataに基づいて~URLを生成することを，`~client$に許容する。
◎
Applications can also specify the use of URI Templates [RFC6570] to allow clients to generate URLs based upon runtime data.
</p>

		</section>
		<section id="clients">
<h3 title="Specifying Client Behaviour">4.3. ~clientの挙動の指定-法</h3>

<p>
一般に，~HTTPを利用している応用は、利用-時における相互運用能の課題を避けるため，
`~client$の挙動に対する期待をアリな限り~Web~browserの挙動に近付ける~OUGHT。
◎
In general, applications using HTTP ought to align their expectations for client behaviour as closely as possible with that of Web browsers, to avoid interoperability issues when they are used.
</p>

<p>
これを行う仕方の一つは、
`FETCH$r の用語でそれを定義することである
— それが、~browserが~HTTP用に利用する抽象化なので。
◎
One way to do this is to define it in terms of [FETCH], since that is the abstraction that browsers use for HTTP.
</p>

<p>
［
`~client$の挙動（例： 自動的な~redirectの取扱い）／
拡張（例： ~cookie）
］のうち一部のものは、~HTTPには要求されないが、それでも，ごく共通にある。
~HTTPを利用している応用が，それらの利用を明示的に指定していない場合、［
~clientを惑わす問題／相互運用能の問題
］が生じ得る。
~HTTPを利用している応用は、特に：
◎
Some client behaviours (e.g., automatic redirect handling) and extensions (e.g., Cookies) are not required by HTTP, but nevertheless have become very common. If their use is not explicitly specified by applications using HTTP, there may be confusion and interoperability problems. In particular:
</p>

<ul>
	<li>
~redirectの取扱い
⇒
~redirectを どう取扱うよう期待するかを指定する必要がある
— `4.6.1$sec を見よ。
◎
Redirect handling - Applications need to specify how redirects are expected to be handled; see Section 4.6.1.
</li>
	<li>
~cookie
⇒
要求される場合には、~cookie仕様 `I-D.ietf-httpbis-rfc6265bis$r を明示的に参照するべきである。
◎
Cookies - Applications using HTTP should explicitly reference the Cookie specification [I-D.ietf-httpbis-rfc6265bis] if they are required.
</li>
	<li>
証明書
⇒
~HTTPSを利用する場合、［
`I-D.ietf-httpbis-semantics$r,
`証明書の検証y$sec
に則って，~TLS証明書が検査されること
］を指定するべきである。
◎
Certificates - Applications using HTTP should specify that TLS certificates are to be checked according to [I-D.ietf-httpbis-semantics], Section 4.3.4 when HTTPS is used.
</li>
</ul>

<p>
~HTTPを利用している応用は、［
~HTTP特能のうち，通例的に折衝されることになるもの
］を`~client$が~supportするよう静的に要求するべきではない。
例えば、~clientに対し，ある種の`内容~符号法$（ `Content-Encoding$h ）を伴う応答を［
そのために（ `Accept-Encoding$h により）折衝することなく，~supportするよう要求する
］ことは、他では適合tな~clientが当の応用と相互運用できなくなることを意味する。
応用は、そのような特能の実装を奨励することはできるが。
◎
Applications using HTTP should not statically require HTTP features that are usually negotiated to be supported by clients. For example, requiring that clients support responses with a certain content-coding ([I-D.ietf-httpbis-semantics], Section 8.4.1) instead of negotiating for it ([I-D.ietf-httpbis-semantics], Section 12.5.3) means that otherwise conformant clients cannot interoperate with the application. Applications can encourage the implementation of such features, though.
</p>

		</section>
		<section id="specifying-urls">
<h3 title="Specifying URLs">4.4. ~URLの指定-法</h3>

<p>
~HTTPにおいては、`~client$がヤリトリする~server資源は，~URL `RFC3986$r で識別される。
`RFC8820$r が説明するとおり，~URLの各部は、配備における柔軟性を`~server$に与えるため，当の~serverの所有者の制御~下にあるよう設計されている（~serverの “権限（ `authority^en ）” としても知られる）。
◎
In HTTP, the server resources that clients interact with are identified with URLs [RFC3986]. As [RFC8820] explains, parts of the URL are designed to be under the control of the owner (also known as the "authority") of that server, to give them the flexibility in deployment.
</p>

<p>
このことは、~HTTPを利用する応用~用の仕様は、ほとんどの事例では，応用の~URLを包含しないことを意味する。
ある単独~配備な~API用の ある仕様が（例えば）~path接頭辞 "`/app/v1^c" を指定するような実施は共通的にあるが、~IETF仕様において そうすることは，不適切である。
◎
This means that in most cases, specifications for applications that use HTTP won't contain its URLs; while it is common practice for a specification of a single-deployment API to specify the path prefix "/app/v1" (for example), doing so in an IETF specification is inappropriate.
</p>

<p>
したがって，仕様の書き手は、応用の~URLの発見を`~client$に許容するような，何らかの仕組みが必要になる。
加えて，応用は、利用されるべき~URL~scheme（たち）, および［
専用な~port,
~HTTP用の既定の~port【！reuse HTTP's port(s)】
］どちらを利用するかも指定する必要がある。
◎
Therefore, the specification writer needs some mechanism to allow clients to discovery an application's URLs. Additionally, they need to specify what URL scheme(s) the application should be used with, and whether to use a dedicated port, or reuse HTTP's port(s).
</p>

			<section id="discovering-an-applications-urls">
<h4 title="Discovering an Application's URLs">4.4.1. 応用の~URLの発見-法</h4>

<p>
一般に，`~client$は、所与の応用で`~server$とヤリトリし始める前に，［
応用の特定0の配備についての情報を包含する，初期~文書
］を要請することになる
— それには、関連な他の`資源$への~linkも含まれ得る。
そうすることは、［
配備がアリな限り柔軟になること（複数の~serverにも またがり得る）,
発展を許容すること
］を確約することに加え，~client向けの “発見~文書” を誂える機会も応用に与える。
◎
Generally, a client will begin interacting with a given application server by requesting an initial document that contains information about that particular deployment, potentially including links to other relevant resources. Doing so assures that the deployment is as flexible as possible (potentially spanning multiple servers), allows evolution, and also gives the application the opportunity to tailor the 'discovery document' to the client.
</p>

<p>
初期~URLを発見するための少数の共通的な~patternがある。
◎
There are a few common patterns for discovering that initial URL.
</p>

<p>
~URL発見~用の最も単直な仕組みは、`~client$を全部的な~URLで環境設定する（あるいは，それを~clientに伝達する）ことである。
これは、ある環境設定~文書~内で，あるいは別の発見の仕組みを通して行われることもあろう。
◎
The most straightforward mechanism for URL discovery is to configure the client with (or otherwise convey to it) a full URL. This might be done in a configuration document, or through another discovery mechanism.
</p>

<p>
しかしながら，`~client$が`~server$の~hostnameと応用の識別情報しか知らない場合、その情報から初期~URLを導出する何らかの仕方が必要になる。
◎
However, if the client only knows the server's hostname and the identity of the application, there needs to be some way to derive the initial URL from that information.
</p>

<p>
応用は、自身の~URL~path用に固定的な接頭辞を定義することはできない
— `RFC8820$r を見よ。
代わりに，そのような応用~用の仕様は、次に挙げる策のうち いずれかを利用できる：
◎
An application cannot define a fixed prefix for its URL paths; see [RFC8820]. Instead, a specification for such an application can use one of the following strategies:
</p>
<ul>
	<li>
応用~用の入口として`周知な~URI^cite【 "`/.well-known/^c" 】（ `Well-Known URI^en ） `RFC8615$r を登録する。
これは、その応用を配備し得る どの`~server$に対しても，他の応用と衝突しない固定的な~pathを供する。
◎
Register a Well-Known URI [RFC8615] as an entry point for that application. This provides a fixed path on every potential server that will not collide with other applications.
</li>
	<li>
入口~用に~URLを生成するための［
`~URI~template^cite `RFC6570$r または類似な仕組み
］を伝達するような`~server$権限を可能化する。
例えば，これは、［
環境設定~文書／他の人工物
］内で行われることもあろう。
◎
Enable the server authority to convey a URL Template [RFC6570] or similar mechanism for generating a URL for an entry point. For example, this might be done in a configuration document or other artefact.
</li>
</ul>

<p>
発見~文書の所在が得られたなら、~fetchでき，（その~metadataにより許容されるなら）後で再利用するために~cacheでき，応用に関連な他の`資源$の所在を得るために利用できる
— ［
全部的な~URI／
`~URI~template^cite `RFC6570$r
］を利用して。
◎
Once the discovery document is located, it can be fetched, cached for later reuse (if allowed by its metadata), and used to locate other resources that are relevant to the application, using full URIs or URL Templates.
</p>

<p>
応用は、一部の事例では，そのような発見~文書を利用したいと望まないこともあろう
— 例えば，通信は【発見~文書を介するのは大袈裟か不便になるほどに】ごく概略的であるとき／
待時間の懸念から，発見~文書の利用は予め除外されるとき。
これらの状況は、応用の`資源$を成すすべてを周知な所在【 "`/.well-known/^c" 】の下に配置することにより，取組める。
◎
In some cases, an application may not wish to use such a discovery document; for example, when communication is very brief, or when the latency concerns of doing so precludes the use of a discovery document. These situations can be addressed by placing all of the application's resources under a well-known location.
</p>

			</section>
			<section id="scheme">
<h4 title="Considering URI Schemes">4.4.2. ~URI~schemeを考慮するとき</h4>

<p>
~HTTPを利用する応用は，概して、~URI~schemeに［
"`http^c" や "`https^c"
］を使役することになる。
［
認証, 完全性, 機密性
］を供する, および
大規模な監視~攻撃を軽減するには、
"`https^c" が`推奨される^2119
`RFC7258$r 
。
◎
Applications that use HTTP will typically employ the "http" and/or "https" URI schemes. "https" is RECOMMENDED to provide authentication, integrity and confidentiality, as well as mitigate pervasive monitoring attacks [RFC7258].
</p>

<p>
しかしながら，応用に特有な~schemeも定義できる。
~HTTPを利用している応用~用に~URI~schemeを定義するときには、いくつかの~tradeoffと注意事項を念頭に置くべきである：
◎
However, application-specific schemes can also be defined. When defining an URI scheme for an application using HTTP, there are a number of tradeoffs and caveats to keep in mind:
</p>
<ul>
	<li>
~Web~browserは、改変されない限り，新たな~schemeを~supportしない。
~Web~browserで新たな~URI~schemeを登録することはアリであるが（例：`HTML$r における `registerProtocolHandler()^c, あるいは いくつかの~proprietaryな~approachで）、
これらの仕組み用の~supportは、すべての~browserから共有されるとは限らず，それらの能力は~browserごとに変わり得る。
◎
Unmodified Web browsers will not support the new scheme. While it is possible to register new URI schemes with Web browsers (e.g. registerProtocolHandler() in [HTML], as well as several proprietary approaches), support for these mechanisms is not shared by all browsers, and their capabilities vary.
</li>
	<li>
既存の［
非~browser`~client$, `中継者$, `~server$
］, および これらに結付けられる~softwareは、新たな~schemeを認識しないことになる。
例えば
⇒＃
ある~client~libraryは、要請を配送するのに失敗するかもしれない／
ある`~cache$は、応答を格納するのを拒否するかもしれない／
ある`~proxy$は、要請を回送するのに失敗するかもしれない
◎
Existing non-browser clients, intermediaries, servers and associated software will not recognise the new scheme. For example, a client library might fail to dispatch the request; a cache might refuse to store the response, and a proxy might fail to forward the request.
</li>
	<li>
~URLは、~HTTPによる人工物~内で共通的に生じたり，自動的に（例： `Location$h 応答~header内で）生成されることが多いので、新たな~schemeが一貫して利用されるよう確約するのは，困難にもなり得る。
◎
Because URLs occur in HTTP artefacts commonly, often being generated automatically (e.g., in the Location response header field), it can be difficult to assure that the new scheme is used consistently.
</li>
	<li>
新たな~schemeにより識別される`資源$は、依然として，［
"`http^c" ／ "`https^c"
］~URLを利用しても可用になる。
それらの~URLは、［
~security／運用能
］の課題が在り得るような利用に “漏洩し得る”。
例えば，新たな~schemeを利用しても、［
要請が “通常の” ~Web~siteへは送信されない
］ことを確約するのは，失敗する見込みが高い。
◎
The resources identified by the new scheme will still be available using "http" and/or "https" URLs. Those URLs can "leak" into use, which can present security and operability issues. For example, using a new scheme to assure that requests don't get sent to a "normal" Web site is likely to fail.
</li>
	<li>
特能のうち［
~Webの同一-生成元~施策など，~URLの生成元 `RFC6454$r に依拠するもの
］は、~schemeの変更に影響iされることになる。
◎
Features that rely upon the URL's origin [RFC6454], such as the Web's same-origin policy, will be impacted by a change of scheme.
</li>
	<li>
~HTTPに特有な特能
— ［
~cookie `I-D.ietf-httpbis-rfc6265bis$r,
認証 `I-D.ietf-httpbis-semantics$r,
~cache法 `I-D.ietf-httpbis-cache$r,
~HSTS `RFC6797$r,
~CORS `FETCH$r
］など —
が正しく働くかどうかは、それらがどう定義され, どう実装されるかに依存する。
一般に，それらは、~URLは常に［
"`http^c" ／ "`https^c"
］であると見做す下で設計され, 実装される。
◎
HTTP-specific features such as cookies [I-D.ietf-httpbis-rfc6265bis], authentication [I-D.ietf-httpbis-semantics], caching [I-D.ietf-httpbis-cache], HSTS [RFC6797], and CORS [FETCH] might or might not work correctly, depending on how they are defined and implemented. Generally, they are designed and implemented with an assumption that the URL will always be "http" or "https".
</li>
	<li>
~web特能のうち，`~secureな文脈$ `SECCTXT$r を要求するものは、新たな~schemeを~secureでないものと扱う見込みが高い。
◎
Web features that require a secure context [SECCTXT] will likely treat a new scheme as insecure.
</li>
</ul>

<p>
新たな~URI~schemeの創出-法についての，さらなる情報は、
`RFC7595$r を見よ。
◎
See [RFC7595] for more information about minting new URI schemes.
</p>

			</section>
			<section id="transport-ports">
<h4 title="Transport Ports">4.4.3. ~transport用の~port</h4>

<p>
応用は、適用-可能な既定の~port（~HTTP 用には 80, ~HTTPS用には 443 ）を利用できる
— あるいは、他の~portにも配備できる。
この裁定は、配備~時点に下されることもあれば，応用の仕様により奨励されることもあろう（例：ある~portを，その応用~用として登録することにより）。
◎
Applications can use the applicable default port (80 for HTTP, 443 for HTTPS), or they can be deployed upon other ports. This decision can be made at deployment time, or might be encouraged by the application's specification (e.g., by registering a port for that application).
</p>

<p>
既定でない~portが利用される場合、その`資源$用のすべての~URLの権限【 `authority$p 】内に反映される必要がある。
既定の~portを変更するための仕組みは、~URI~schemeを変更する他にない（ `4.4.2$sec を見よ）。
◎
If a non-default port is used, it needs to be reflected in the authority of all URLs for that resource; the only mechanism for changing a default port is changing the URI scheme (see Section 4.4.2).
</p>

<p>
既定の以外の~portを利用することには、~privacyの含意がある（すなわち、当の~protocolは他の流通から判別できるようになる）ことに加え、運用能の懸念がある（一部の~networkは、そのような~portを阻止したり干渉することもあるので）。
~privacyの含意は、
“§ ~securityの考慮点”
にて文書化されるべきである。
◎
Using a port other than the default has privacy implications (i.e., the protocol can now be distinguished from other traffic), as well as operability concerns (as some networks might block or otherwise interfere with it). Privacy implications should be documented in Security Considerations.
</p>

<p>
更なる指導は、
`RFC7605$r を見よ。
◎
See [RFC7605] for further guidance.
</p>

			</section>
		</section>
		<section id="using-http-methods">

<h3 title="Using HTTP Methods">4.5. ~HTTP~methodの利用-法</h3>

<p>
~HTTPを利用する応用は、利用する~HTTP`~method$を登録-済みなものに限定しなければナラナイ
— 次に挙げるものなど
⇒
`GET$m,
`POST$m,
`PUT$m,
`DELETE$m,
`PATCH$m
◎
Applications that use HTTP MUST confine themselves to using registered HTTP methods such as GET, POST, PUT, DELETE, and PATCH.
</p>

<p>
新たな~HTTP~methodは稀である。
それらは、
`IETF による考査$の下で
`~HTTP~method~registry$cite
内に登録することが要求され（ `I-D.ietf-httpbis-semantics$r `~method~registry$sec ），汎用であることも要求される。
すなわち，`~method$は、一つの応用における`資源$のみならず，すべての資源に適用-可能になり得る必要がある。
◎
New HTTP methods are rare; they are required to be registered in the HTTP Method Registry with IETF Review (see [I-D.ietf-httpbis-semantics]), and are also required to be generic. That means that they need to be potentially applicable to all resources, not just those of one application.
</p>

<p>
歴史的に，一部の応用（例： `RFC4791$r ）は汎用でない~methodを定義したが、
`I-D.ietf-httpbis-semantics$r は，今やこれを禁止する。
◎
While historically some applications (e.g., [RFC4791]) have defined non-generic methods, [I-D.ietf-httpbis-semantics] now forbids this.
</p>

<p>
策定者は，新たな`~method$が要求されると予見するときは、~HTTP~communityに早期に携わって，自身による提案を
— 応用の仕様を成す一部としてではなく —
別々な~HTTP拡張として文書化することが奨励される。
◎
When authors believe that a new method is required, they are encouraged to engage with the HTTP community early, and document their proposal as a separate HTTP extension, rather than as part of an application's specification.
</p>

			<section id="get">
<h4 title="GET">4.5.1. `GET^m</h4>

<p>
`GET$m は、最も共通的な, かつ有用な~HTTP~methodである。
その検索取得の意味論は、~cachingと副作用が無い~link法を許容する
— ~HTTPを利用する便益の多くは，それが~~下層にある。
◎
GET is the most common and useful HTTP method; its retrieval semantics allow caching, side-effect free linking and underlies many of the benefits of using HTTP.
</p>

<p>
`GET$m は、~queryを遂行するために共通的に利用される（~URLの~query成分を利用することが多い）。
これは，~Web閲覧において馴染みな~patternであり、その結果は~cacheできるので，高価になることが多い処理nの効率性を改善する。
◎
A common use of GET is to perform queries, often using the query component of the URL; this is a familiar pattern from Web browsing, and the results can be cached, improving efficiency of an often expensive process.
</p>

<p>
しかしながら，~URIの構文は制限されているので、
`GET$m で~queryを表出するのは手に余る事例もあるかもしれない
— 特に，~queryを成すある項が~binary~dataで形成される場合、~URI構文に適合するよう符号化する必要がある。
◎
In some cases, however, GET might be unwieldy for expressing queries, because of the limited syntax of the URI; in particular, if binary data forms part of the query terms, it needs to be encoded to conform to URI syntax.
</p>

<p>
これは，~queryが短いならば課題にならないが、［
巨大な~query項がある／~~高頻度な要請を支え続ける必要がある
］場合，そうなり得る。
加えて，一部の~HTTP実装は、~supportする~URLの~sizeを制限する
— 現代の~HTTP~softwareにおける制限sは、以前よりは ずっと間口が広いが（
`I-D.ietf-httpbis-semantics$r により 8000 ~octet以上が要求され、概して，それをかなり超える）。
◎
While this is not an issue for short queries, it can become one for larger query terms, or ones which need to sustain a high rate of requests. Additionally, some HTTP implementations limit the size of URLs they support -- although modern HTTP software has much more generous limits than previously (typically, considerably more than 8000 octets, as required by [I-D.ietf-httpbis-semantics].
</p>

<p>
これらの事例では、~HTTPを利用している応用は、
`POST$m を利用して，要請の`内容$内で~queryを表出することを考慮するかもしれない
— そうすれば、［
符号化法の~overhead／実装における~URL長さ制限s
］は，避けれる。
しかしながら，そうすると、
`GET$m の便益
— ~queryの結果を~cacheしたり，~linkするなど —
も失われることにも注意。
したがって，~HTTPを利用している応用は、
`POST$m による~queryを許容する必要があると感じるなら，両~methodとも許容することを考慮する~OUGHT。
◎
In these cases, an application using HTTP might consider using POST to express queries in the request's content; doing so avoids encoding overhead and URL length limits in implementations. However, in doing so it should be noted that the benefits of GET such as caching and linking to query results are lost. Therefore, applications using HTTP that feel a need to allow POST queries ought consider allowing both methods.
</p>

<p>
応用は、
`GET^m に対し，自身の状態を変更するその他の［
`~client$にとって有意になり得るような副作用が生じる
］べきでない
— 実装は、失敗した `GET$m 要請を再試行でき，それを行うので。
これは、~log取りや それに類似な機能は含まないことに注意
— `安全$な~methodを見よ。
◎
Applications should not change their state or have other side effects that might be significant to the client, since implementations can and do retry HTTP GET requests that fail. Note that this does not include logging and similar functions; see [I-D.ietf-httpbis-semantics], Section 9.2.1.
</p>

<p>
最後に、~HTTPは，構文上は `GET$m 要請にも`内容$を許容するが、そうなっているのは，構文解析器が汎用であることを許容するためでしかないことに注意。
`GET$m の`内容$には意味は無く，汎用な~HTTP~softwareはそれを無視するか却下することになる。
◎
Finally, note that while HTTP allows GET requests to have content syntactically, this is done only to allow parsers to be generic; as per [I-D.ietf-httpbis-semantics], Section 9.3.1, content on a GET has no meaning, and will be either ignored or rejected by generic HTTP software.
</p>

			</section>
			<section id="options">
<h4 title="OPTIONS">4.5.2. `OPTIONS^m</h4>

<p>
`OPTIONS$m ~methodは、~metadataの検索取得~用に定義され，
~WebDAV `RFC4918$r,
~CORS `FETCH$r
どちらからも利用される。
~HTTPに基づく~APIは，`資源$についての~metadataを検索取得する必要があることが多いので、
`OPTIONS^m は，そのような~APIの利用-用と見なされることが多い。
◎
The OPTIONS method was defined for metadata retrieval, and is used both by WebDAV [RFC4918] and CORS [FETCH]. Because HTTP-based APIs often need to retrieve metadata about resources, it is often considered for their use.
</p>

<p>
しかしながら，
`OPTIONS$m には有意な制限がある：
◎
However, OPTIONS does have significant limitations:
</p>
<ul>
	<li>
単純な~URLで~metadataへ~linkすることはアリでない
— `OPTIONS$m は、 “既定の `GET$m ~method” ではないので。
◎
It isn't possible to link to the metadata with a simple URL, because OPTIONS is not the default GET method.
</li>
	<li>
`OPTIONS$m に対する応答は、`~cache可能$でない
— ~HTTP`~cache$が演算する対象は、`資源$の`表現$（すなわち `GET$m ／ `HEAD$m ）なので。
`OPTIONS$m に対する応答を【~HTTP~cacheとは】別々に~cacheする場合，~HTTP~cacheにおける［
失効,
副次的な~key,
その他の仕組み
］との相互作用を考慮する必要がある。
◎
OPTIONS responses are not cacheable, because HTTP caches operate on representations of the resource (i.e., GET and HEAD). If OPTIONS responses are cached separately, their interaction with HTTP cache expiry, secondary keys and other mechanisms needs to be considered.
</li>
	<li>
`OPTIONS$m は “~chat的” である
— ~metadataを常に別々な要請に分離すると、応用とヤリトリするために必要な要請の個数は増える。
◎
OPTIONS is "chatty" - always separating metadata out into a separate request increases the number of requests needed to interact with the application.
</li>
	<li>
`OPTIONS$m 用の実装~supportは、普遍的ではない
— 一部の`~server$は、有意な労なくしては，
`OPTIONS$m 要請に対し応答する能を公開しない。
◎
Implementation support for OPTIONS is not universal; some servers do not expose the ability to respond to OPTIONS requests without significant effort.
</li>
</ul>

<p>
`OPTIONS$m に代えて，より適切になる代替な~approachとしては、次が挙げられよう：
◎
Instead of OPTIONS, one of these alternative approaches might be more appropriate:
</p>
<ul>
	<li>
~server-wide~metadata用に、`周知な~URI^cite【 "`/.well-known/^c" 】 `RFC8615$r を作成するか，適切になる場合は既存のものを利用する（例： HostMeta `RFC6415$r ）。
◎
For server-wide metadata, create a well-known URI [RFC8615], or using an already existing one if it's appropriate (e.g., HostMeta [RFC6415]).
</li>
	<li>
特定の`資源$についての~metadata用には、別々な資源を作成した上で，［
`Link$h 応答~header／応答の`内容$の中
］に直列化された~linkを利用して，そこへ~linkする。
`RFC8288$r を見よ
。
`Link$h ~headerは、
`HEAD$m 応答においても可用なことに注意
— それは、`~client$が，`資源$とヤリトリする前に その能力を発見したいと求める場合に有用になる。
◎
For metadata about a specific resource, create a separate resource and link to it using a Link response header field or a link serialised into the response's content. See [RFC8288]. Note that the Link header field is available on HEAD responses, which is useful if the client wants to discover a resource's capabilities before they interact with it.
</li>
</ul>

			</section>
		</section>
		<section id="using-http-status-codes">
<h3 title="Using HTTP Status Codes">4.6. ~HTTP状態s~codeの利用-法</h3>

<p>
`状態s~code$は、汎用な~HTTP~component
— `~cache$, `中継者$, `~client$など —
の便益, および応用~自身のために意味論を伝達する。
しかしながら，応用は、それらの利用において，いくつかの陥穽に遭遇し得る。
◎
HTTP status codes convey semantics both for the benefit of generic HTTP components -- such as caches, intermediaries, and clients -- and applications themselves. However, applications can encounter a number of pitfalls in their use.
</p>

<p>
まず，`状態s~code$は、応用~自身~以外の~componentにより生成されることが多い。
これが起こり得るのは、例えば［
~network~errorに遭遇した／
［
`captive portal^en 【~interception~proxy】／`~proxy$／~CDN
］が在る ／
~serverが［
過負荷になった／攻撃に晒されている
］と~~判断した
］ときが挙げられる。
それらは、汎用な~client~softwareにより
— ある種の~error条件に遭遇したとき —
生成されることすらある。
その結果、ある応用が，そのような状態s~codeに自身に特有な意味論をアテガった場合、`~client$は，応用の状態について誤った方へ導かれ得る
— 当の状態s~codeを生成したのは、応用ではなく，ある汎用な~componentなので。
◎
First, status codes are often generated by components other the the application itself. This can happen, for example, when network errors are encountered, a captive portal, proxy or Content Delivery Network is present, when a server is overloaded, or it thinks it is under attack. They can even be generated by generic client software when certain error conditions are encountered. As a result, if an application assigns specific semantics to one of these status codes, a client can be misled about its state, because the status code was generated by a generic component, not the application itself.
</p>

<p>
更には，応用が自身の~errorを個別な`状態s~code$に一対一に対応付けた場合、適用-可能な状態s~codeの有限な空間が枯渇する状況に至ることが多い。
これは転じて，例えば次のような不良な実施へ導く
⇒＃
新たな，応用に特有な状態s~codeを創出すること／
既存の状態s~codeを，その意味論と当の応用の意味論との~~関連性が希薄でしかないのに利用すること
◎
Furthermore, mapping application errors to individual HTTP status codes one-to-one often leads to a situation where the finite space of applicable HTTP status codes is exhausted. This, in turn, leads to a number of bad practices -- including minting new, application-specific status codes, or using existing status codes even though the link between their semantics and the application's is tenuous at best.
</p>

<p>
代わりに，~HTTPを利用している応用は、自身の~errorを最も適用-可能な`状態s~code$を利用するように定義するべきである
— 疑わしいときは、一般~用の状態s~code（ `200$st0, `400$st0, `500$st0 ）の間口が広い利用を為すようにして。
要は、応用は
— 上に要旨した枯渇の課題を避けるよう —
状態s~codeと応用の~errorの間に一対一な関係性を指定しないべきである。
◎
Instead, applications using HTTP should define their errors to use the most applicable status code, making generous use of the general status codes (200, 400 and 500) when in doubt. Importantly, they should not specify a one-to-one relationship between status codes and application errors, thereby avoiding the exhaustion issue outlined above.
</p>

<p>
複数の~error条件が同じ`状態s~code$に対応付けられる場合に それらを判別するため，および上に要旨した誤った帰属の課題を避けるため、~HTTPを利用している応用は，より木目細かな~error情報を応答の［
`内容$／`~header$
］内に伝達するべきである。
`RFC7807$r は、そうするための仕方の一つを供する。
◎
To distinguish between multiple error conditions that are mapped to the same status code, and to avoid the misattribution issue outlined above, applications using HTTP should convey finer-grained error information in the response's message content and/or header fields. [RFC7807] provides one way to do so.
</p>

<p>
登録-済みな`状態s~code$が成す集合は，拡げられ得るので、~HTTPを利用している応用は，［
`~client$は、適用-可能なすべての状態s~codeを，上品に取扱える~OUGHT†
］ことを明示的に指摘するべきである（†
すなわち，所与の状態s~codeの意味論は汎用な `n00^st0 に~fall-backする
— 例えば `499^st0 を認識しない`~client$は、それを `400$st0 として安全に取扱える）。
これは、あり得る状態s~codeの “~~対処~list（ `laundry list^en ）” を作成するよりも好ましい
— そのような~listが，いつの日か完全になる見通しは立たないので。
◎
Because the set of registered HTTP status codes can expand, applications using HTTP should explicitly point out that clients ought to be able to handle all applicable status codes gracefully (i.e., falling back to the generic n00 semantics of a given status code; e.g., 499 can be safely handled as 400 by clients that don't recognise it). This is preferable to creating a "laundry list" of potential status codes, since such a list won't be complete in the foreseeable future.
</p>

<p>
~HTTPを利用している応用は、`状態s~code$の意味論を指定し直してはナラナイ
— それらの定義をただ複製するだけであっても。
応用には、【自身に特有な意味論を表出するために必要なら，】特有な`事由~句$を利用するよう要求することが`推奨される^2119
— ~HTTPにおいては，事由~句の機能は無いので、実装が それを保全することは保証されないことに加え、~HTTP2 `RFC7540$r の~message形式においては，まったく運ばれない。
◎
Applications using HTTP MUST NOT re-specify the semantics of HTTP status codes, even if it is only by copying their definition. It is RECOMMENDED they require specific reason phrases to be used; the reason phrase has no function in HTTP, is not guaranteed to be preserved by implementations, and is not carried at all in the HTTP/2 [RFC7540] message format.
</p>

<p>
`~method$と同じく、応用は，登録-済みな`状態s~code$に限り利用しなければナラナイ。
新たな状態s~codeは稀であり，
`IETF による考査$の下で登録することが（
`I-D.ietf-httpbis-semantics$r により
）要求される。
`状態s~code$も類似に汎用であり、一つの応用のみならず，すべての`資源$に適用-可能になり得ることが要求される（ `I-D.ietf-httpbis-semantics$r ）。
◎
Applications MUST only use registered HTTP status codes. As with methods, new HTTP status codes are rare, and required (by [I-D.ietf-httpbis-semantics]) to be registered with IETF Review. Similarly, HTTP status codes are generic; they are required (by [I-D.ietf-httpbis-semantics]) to be potentially applicable to all resources, not just to those of one application.
</p>

<p>
新たな状態s~codeが要求されると予見する策定者は、~HTTP~communityに早期に携わって，自身の提案を
— 応用の仕様の一部としてではなく —
別々な~HTTP拡張として文書化することが奨励される。
◎
When authors believe that a new status code is required, they are encouraged to engage with the HTTP community early, and document their proposal as a separate HTTP extension, rather than as part of an application's specification.
</p>

			<section id="redirects">
<h4 title="Redirection">4.6.1. ~redirection</h4>

<p>
`3xx$st0 番台の`状態s~code$は、当の要請を満足するため，別の`資源$へ~UAを~directする。
最も共通的なものは，［
`301$st0, `302$st0, `307$st0, `308$st0
］であり、いずれも，
`Location$h 応答~headerを利用して［
`~client$は、要請をどこへ送信するべきか
］を指示する。
◎
The 3xx series of status codes specified in [I-D.ietf-httpbis-semantics], Section 15.4 direct the user agent to another resource to satisfy the request. The most common of these are 301, 302, 307 and 308, all of which use the Location response header field to indicate where the client should send the request to.
</p>

<p>
これら一群の`状態s~code$は、次の二点で相違する：
◎
There are two ways that this group of status codes differ:
</p>
<ul>
	<li>
［
恒久的, 一時的
］どちらなのか。
恒久的な~redirectは、`~client$内に格納された~link（例：~bookmark）を更新するために利用できる一方で，一時的なものは，できない。
これによる~HTTP~cache法に対する効果は無いことに注意
— それは、完全に別々である。
◎
Whether they are permanent or temporary. Permanent redirects can be used to update links stored in the client (e.g., bookmarks), whereas temporary ones can not. Note that this has no effect on HTTP caching; it is completely separate.
</li>
	<li>
~redirectされた要請の~methodを `POST$m から `GET$m に変更するのを許容するかどうか。
~Web~browserは、一般に，［
`301$st0, `302$st0
］に対しては `POST$m を `GET$m に変更する。
そのことから、~methodを変更しない~redirectionを許容するために［
`308$st0, `307$st0
］が作成された。
◎
Whether they allow the redirected request to change the request method from POST to GET. Web browsers generally do change POST to GET for 301 and 302; therefore, 308 and 307 were created to allow redirection without changing the method.
</li>
</ul>

<p>
次の表に、これらの関係性を要約する：
◎
This table summarises their relationships:
</p>

<div>
<table><thead><tr><td><th>恒久的<th>一時的
</thead><tbody>
<tr><td>`POST^m から `GET^m への変更を許容する
<td>`301^st0
<td>`302^st0

<tr><td>`POST^m から `GET^m への変更を許容しない
<td>`308^st0
<td>`307^st0
</tbody></table>
◎
｜Permanent｜Temporary
Allows changing the request method from POST to GET｜301｜302
Does not allow changing the request method｜308｜307
</div>

<p>
`I-D.ietf-httpbis-semantics$r § `3xx$st0 に述べられるように、~UAには，
`Location$h 応答~headerを伴う `3xx^st0 ~redirectを
— 特定の`状態s~code$の意味論を解さない場合でも —
自動的に追従することが許容される。
しかしながら，そうするよう要求されてはいないので、~HTTPを利用している応用は，~redirectを自動的に追従するよう欲する場合には，どの状況下で それが要求されるかを明示的に指定する必要がある。
◎
As noted in [I-D.ietf-httpbis-semantics], a user agent is allowed to automatically follow a 3xx redirect that has a Location response header field, even if they don't understand the semantics of the specific status code. However, they aren't required to do so; therefore, if an application using HTTP desires redirects to be automatically followed, it needs to explicitly specify the circumstances when this is required.
</p>

<p>
~redirectは、（適切な~cache指令が在るときは）~cacheされ得るが，それを超えて “へばりつく” ことはない
— すなわち，~URIの~redirectionは、類似な~URI（例：~query~parameterだけ異なるなど）に対しても~clientを~redirectするものとは見做されない。
◎
Redirects can be cached (when appropriate cache directives are present), but beyond that they are not 'sticky' -- i.e., redirection of a URI will not result in the client assuming that similar URIs (e.g., with different query parameters) will also be redirected.
</p>

<p>
~HTTPを利用している応用は、~browserと互換になるよう，［
`301$st0 ／ `302$st0
］応答に対する後続の要請~methodを `POST$m から `GET$m （他の~methodは不可）へ変更するよう指定することが奨励される。
◎
Applications using HTTP are encouraged to specify that 301 and 302 responses change the subsequent request method from POST (but no other method) to GET, to be compatible with browsers.＼
</p>

<p>
一般に，~redirectされた要請が為されるとき、その各~headerは，元の要請から複製される。
しかしながら，それらは、様々な仕組みにより改変され得る。
例えば，送信される［
`Authorization$h ／ `Cookie$h
］~headerは、要請【`要請~target$】の生成元（および, ときには~path）が変更された場合には変化することになる。
~HTTPを利用している応用は、自身が定義する各~要請~headerに対し，~redirectに際して それを［
改変する／除去する
］必要があるかどうかを指定するべきである。
しかしながら，この挙動には依拠し得ない
— （~browserの様な）汎用な`~client$は、そのような要件を自覚しないので。
◎
Generally, when a redirected request is made, its header fields are copied from the original request's. However, they can be modified by various mechanisms; e.g., sent Authorization ([I-D.ietf-httpbis-semantics]) and Cookie ([I-D.ietf-httpbis-rfc6265bis]) header fields will change if the origin (and sometimes path) of the request changes. An application using HTTP should specify if any request header fields that it defines need to be modified or removed upon a redirect; however, this behaviour cannot be relied upon, since a generic client (like a browser) will be unaware of such requirements.
</p>

			</section>
		</section>
		<section id="headers">
<h3 title="Specifying HTTP Header Fields">4.7. ~HTTP~headerの指定-法</h3>

<p>
応用は、新たな~HTTP~headerを定義することが多い。
新たな~HTTP~headerの利用は、概して，次に挙げるような少数の状況において適切になる：
◎
Applications often define new HTTP header fields. Typically, using HTTP header fields is appropriate in a few different situations:
</p>
<ul>
	<li>
当の~fieldは、`中継者$にとって有用である（中継者は、`内容$の構文解析を避けたいと望むことが多い）。
◎
The field is useful to intermediaries (who often wish to avoid parsing message content), and/or
</li>
	<li>
当の~fieldは、汎用な~HTTP~software（例： `~client$, `~server$）にとって有用である。
◎
The field is useful to generic HTTP software (e.g., clients, servers), and/or
</li>
	<li>
その値を~messageの`内容$内に含めるのはアリでない（通例的には、その形式がそれを許容しないため）。
◎
It is not possible to include their values in the message content (usually because a format does not allow it).
It 
</li>
</ul>

<p>
上のどの条件にも該当しないときは、応用に特有な情報を他の場所
— 例：~messageの`内容$や~URL~query文字列 —
で伝達する方が，通例的には良い。
◎
When the conditions above are not met, it is usually better to convey application-specific information in other places; e.g., the message content or the URL query string.
</p>

<p>
新たな~headerは、
`I-D.ietf-httpbis-semantics$r に従って登録されなければナラナイ。
◎
New header fields MUST be registered, as per [I-D.ietf-httpbis-semantics].
</p>

<p>
新たな~headerを創出するときに考慮する指針は、
`I-D.ietf-httpbis-semantics$r `新たな~fieldに対する考慮点$sec を見よ。
`有構造~header$ `RFC8941$r は、新たな~header用の共通な構造を供して，それらの構文解析と取扱いにおける多くの課題を避ける
— 新たな~headerは、それを利用することが`推奨される^2119。
◎
See [I-D.ietf-httpbis-semantics], Section 16.3.2 for guidelines to consider when minting new header fields. [RFC8941] provides a common structure for new header fields, and avoids many issues in their parsing and handling; it is RECOMMENDED that new header fields use it.
</p>

<p>
~headerの名前は、短くしつつ（~field圧縮が利用されていても、そこには~overheadがある）、適切な，より特定的な名前にすることが`推奨される^2119。
特に，ある~headerが応用に特有な場合、その応用~用の識別子は，~headerの名前の［
"`-^c" で分離された接頭辞
］を形成し得る。
◎
It is RECOMMENDED that header field names be short (even when field compression is used, there is an overhead) but appropriately specific. In particular, if a header field is specific to an application, an identifier for that application can form a prefix to the header field name, separated by a "-".
</p>

<p>
例えば，ある “example” と称される応用が 3 個の~headerを作成する必要がある場合、［
`example-foo^h, `example-bar^h, `example-baz^h
］のようにもなろう。
ここでの首な動機は、名前空間のある部位を応用~用に予約することではなく，より汎用な`~field名$を消費するのを避けることなのに注意。
関係する考慮点については `RFC6648$r を見よ。
◎
For example, if the "example" application needs to create three header fields, they might be called "example-foo", "example-bar" and "example-baz". Note that the primary motivation here is to avoid consuming more generic field names, not to reserve a portion of the namespace for the application; see [RFC6648] for related considerations.
</p>

<p>
既存の~HTTP~headerの意味論を，［
その登録を更新する／
それに対する拡張を定義する
］（かつ，それが許容される）ことなく定義し直してはナラナイ。
例えば，~HTTPを利用している応用は、
`Location$h ~headerを［
ある種の文脈においては、特別な意味がある
］ものとは指定できない。
◎
The semantics of existing HTTP header fields MUST NOT be re-defined without updating their registration or defining an extension to them (if allowed). For example, an application using HTTP cannot specify that the Location header field has a special meaning in a certain context.
</p>

<p>
~headerと~HTTP~cache法の相互作用については、 `4.9$sec を見よ。
特に，［
要請~headerのうち，応答を “選定する” ために利用されるもの
］は、それに影響iがあり，注意深く考慮する必要がある。
◎
See Section 4.9 for the interaction between header fields and HTTP caching; in particular, request header fields that are used to "select" a response have impact there, and need to be carefully considered.
</p>

<p>
~headerのうち，応用の状態を運ぶもの（例：`Cookie$h ）に関する考慮点は、
`4.10$sec を見よ。
◎
See Section 4.10 for considerations regarding header fields that carry application state (e.g., Cookie).
</p>

		</section>
		<section id="content">
<h3 title="Defining Message Content">4.8. ~message内容の定義-法</h3>

<p>
~message`内容$用の共通的な構文上の規約には、［
~JSON `RFC8259$r,
~XML `XML$r,
~CBOR `RFC7049$r
］が挙げられる。
これらを利用する場合の最善な実施は、この文書の視野から外れる。
◎
Common syntactic conventions for message contents include JSON [RFC8259], XML [XML], and CBOR [RFC7049]. Best practices for their use are out of scope for this document.
</p>

<p>
応用は、自身が定義する各~形式ごとに，別個な`~MIME型$を登録するべきである。
そうすれば、それらは一義的に識別され，それらを利用するために折衝するのもアリになる。
更なる情報は、 `RFC6838$r を見よ。
◎
Applications should register distinct media types for each format they define; this makes it possible to identify them unambiguously and negotiate for their use. See [RFC6838] for more information.
</p>

		</section>
		<section id="caching">
<h3 title="Leveraging HTTP Caching">4.9. ~HTTP~cache法の活用-法</h3>

<p>
~HTTP~cache法
`I-D.ietf-httpbis-cache$r
は、応用にとって，~HTTPを利用する首な便益の一つであり、［
~scale能を供する／
待時間を抑制する／
信頼性を改善する
］。
更には，~HTTP`~cache$は、次に挙げるものにも，すでに可用である
⇒＃
~browserその他の`~client$／
回送-~proxyや逆~proxyとしての~network／
~CDN／
~server~softwareの一部として
◎
HTTP caching [I-D.ietf-httpbis-cache] is one of the primary benefits of using HTTP for applications; it provides scalability, reduces latency and improves reliability. Furthermore, HTTP caches are readily available in browsers and other clients, networks as forward and reverse proxies, Content Delivery Networks and as part of server software.
</p>

<p>
~HTTPを利用している応用は、~cache法の利点を得ようと設計されていないときでも、`~cache$が応答をどう取扱うかを考慮する必要はある
— （~network, `~server$, `~client$, 介在している基盤の）どこかに~cachingが差し挟まれても，正しい挙動を保全するため。
◎
Even when an application using HTTP isn't designed to take advantage of caching, it needs to consider how caches will handle its responses, to preserve correct behaviour when one is interposed (whether in the network, server, client, or intervening infrastructure).
</p>

			<section id="freshness">
<h4 title="Freshness">4.9.1. 鮮度</h4>

<p>
`鮮度~維持期間$をアテガうことは、それが短くても（例： 5 秒），［
複数の`~client$からの要請を満足するために応答を再利用すること／
単独の~clientが同じ要請を繰返ly為すこと
］を許容する。
一般に，再利用しても安全な何かに対しては、鮮度~維持期間をアテガうことを考慮すること。
◎
Assigning even a short freshness lifetime ([I-D.ietf-httpbis-cache], Section 4.2) -- e.g., 5 seconds -- allows a response to be reused to satisfy multiple clients, and/or a single client making the same request repeatedly. In general, if it is safe to reuse something, consider assigning a freshness lifetime.
</p>

<p>
鮮度を指定するための最も共通的な手法は、
`max-age$sdir 応答~指令である。
`Expires$h ~headerも利用できるが，必要とされてはいない
— 現代の~cache実装は，どれも `Cache-Control$h を~supportすることに加え、鮮度を差分【 `delta-seconds$p 】として指定する方が，通例的には より簡便かつ誤り難くなるので。
◎
The most common method for specifying freshness is the max-age response directive ([I-D.ietf-httpbis-cache], Section 5.2.2.1). The Expires header field ([I-D.ietf-httpbis-cache], Section 5.3) can also be used, but it is not necessary; all modern cache implementations support Cache-Control, and specifying freshness as a delta is usually more convenient and less error-prone.
</p>

<p>
ほとんどの応答に対しては、それを~cacheするために `public$sdir 応答~指令を追加することは，必要とされない
— 必要とされるのは、認証された応答を格納するのが望ましいときに限られる。
◎
It is not necessary to add the public response directive ([I-D.ietf-httpbis-cache], Section 5.2.2.9) to cache most responses; it is only necessary when it's desirable to store an authenticated response.
</p>

<p>
一部の状況では、明示的な［
鮮度~用の~cache指令
］を伴わない応答は，経験的な`鮮度~維持期間$を利用して格納された上で~serveされることになる
— `I-D.ietf-httpbis-cache$r `鮮度の経験的な計算-法$secを見よ。
応用は，経験的なそれを制御できないので、一般に，［
明示的な`鮮度~維持期間$を設定するか，応答を明示的に~cache不能にする
］方が好ましい。
◎
In some situations, responses without explicit cache freshness directives will be stored and served using a heuristic freshness lifetime; see [I-D.ietf-httpbis-cache], Section 4.2.2. As the heuristic is not under control of the application, it is generally preferable to set an explicit freshness lifetime, or make the response explicitly uncacheable.
</p>

<p>
応答の~cachingが欲されない場合に適切になる応答~指令は、
<code>`Cache-Control$h: `no-store$sdir</code>
である。
他の指令は必要とされないことに加え、
`no-store$sdir を送信する必要があるのは，応答が~cacheされ得る状況に限られる
— `I-D.ietf-httpbis-cache$r `~cache内への応答の格納-法$sec を見よ。
その一方，
<code>`Cache-Control$h: `no-cache$sdir</code>
は、応答を格納すること自体は許容することに注意
— それは、~cacheが検証を伴わずに応答を再利用することを許容しないだけであり，（その名に反して）~cachingを防止しない。
◎
If caching of a response is not desired, the appropriate response directive is "Cache-Control: no-store". Other directives are not necessary, and no-store only need be sent in situations where the response might be cached; see [I-D.ietf-httpbis-cache], Section 3. Note that "Cache-Control: no-cache" allows a response to be stored, just not reused by a cache without validation; it does not prevent caching (despite its name).
</p>

<div class="example">
<p>
例えば、`~cache$は，次の応答を［
格納できない／再利用できない
］：
◎
For example, this response cannot be stored or reused by a cache:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/example+xml
Cache-Control: no-store

[内容]
</pre>
</div>

			</section>
			<section id="stale-responses">
<h4 title="Stale Responses">4.9.2. 非新鮮な応答</h4>

<p>
策定者は、`~cache$は，`生成元~server$から切断されたときには`非新鮮$な応答（例：
<code>`Cache-Control$h: `max-age$sdir=0</code>
を伴うもの）を再利用できることを理解するべきである。
それは、~networkの課題を取扱うために有用になり得る。
◎
Authors should understand that stale responses (e.g., with "Cache-Control: max-age=0") can be reused by caches when disconnected from the origin server; this can be useful for handling network issues.
</p>

<p>
所与の応答に対し，そうするのは相応しくない場合、`生成元~server$【！~the生成元】は，
<code>`Cache-Control$h: `must-revalidate$sdir</code>
を利用するべきである。
`I-D.ietf-httpbis-cache$r `非新鮮な応答の~serve法$sec を見よ。
また、`非新鮮$な内容に対する追加的な制御は `RFC5861$r を見よ。
◎
If doing so is not suitable for a given response, the origin should use "Cache-Control: must-revalidate". See [I-D.ietf-httpbis-cache], Section 4.2.4, and also [RFC5861] for additional controls over stale content.
</p>

<p>
`非新鮮$な応答は、`検証子$をアテガうことにより新鮮化できる
— そうすれば、巨大な応答に対し，転送~帯域幅も待時間も節約する。
`I-D.ietf-httpbis-semantics$r を見よ。
◎
Stale responses can be refreshed by assigning a validator, saving both transfer bandwidth and latency for large responses; see [I-D.ietf-httpbis-semantics].
</p>

			</section>
			<section id="caching-and-application-semantics">
<h4 title="Caching and Application Semantics">4.9.3. ~cachingと応用の意味論</h4>

<p>
応用は，`鮮度~維持期間$とは別々な維持期間を表出する必要がある場合、それは，応答の［
`内容$／別々な`~header$
］内に別々に伝達されるべきである。
これが起きるときは、そのような維持期間と~HTTP~cache法との関係性を注意深く考慮する必要がある
— 応答は、`新鮮$であると見なされる限り，再利用される【！利用される】ことになるので。
◎
When an application has a need to express a lifetime that's separate from the freshness lifetime, this should be conveyed separately, either in the response's content or in a separate header field. When this happens, the relationship between HTTP caching and that lifetime need to be carefully considered, since the response will be used as long as it is considered fresh.
</p>

<p>
特に，応用の策定者は、応答が`生成元~server$から`新鮮$に得されたものでない場合に，それをどう取扱うべきかを考慮する必要がある
— それに有効期間の様な概念がある場合、応答の齢（
`I-D.ietf-httpbis-cache$r `齢の計算-法$secを見よ
）を考慮する下で計算する必要がある。
◎
In particular, application authors need to consider how responses that are not freshly obtained from the origin server should be handled; if they have a concept like a validity period, this will need to be calculated considering the age of the response (see [I-D.ietf-httpbis-cache], Section 4.2.3).
</p>

<p>
これに取組む仕方の一つは、すべての応答は，利用-時には`新鮮$であるよう明示的に指定することである。
◎
One way to address this is to explicitly specify that all responses be fresh upon use.
</p>

			</section>
			<section id="varying-content-based-upon-the-request">
<h4 title="Varying Content Based Upon the Request">4.9.4. 内容を要請に基づいて変えるとき</h4>

<p>
ある応用が，ある要請~headerを応答の［
`~header$／`内容$
］を変更するために利用する場合、策定者は，それには~cache法に対する含意があることを指摘するべきである、
一般に，そのような`資源$においては、その資源からの応答を~cache不能にするか（例： `no-store$sdir ~cache制御~指令），その資源からのすべての応答（ “既定の” 応答も含む）に `Vary$h 応答~headerを伴わせて送信することが必要になる。
◎
If an application uses a request header field to change the response's header fields or content, authors should point out that this has implications for caching; in general, such resources need to either make their responses uncacheable (e.g., with the "no-store" cache-control directive defined in [I-D.ietf-httpbis-cache], Section 5.2.2.3) or send the Vary response header field ([I-D.ietf-httpbis-semantics], Section 12.5.5) on all responses from that resource (including the "default" response).
</p>

<div class="example">
<p>
例えば、次の応答は：
◎
For example, this response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/example+xml
Cache-Control: max-age=60
ETag: "sa0f8wf20fs0f"
Vary: Accept-Encoding

[内容]
</pre>

<p>
…は
⇒＃
~cacheにより【！`私用~cache$, `共用~cache$どちらも】 60 秒は格納できる ／
`If-None-Match$h で再検証できる／
【その`内容~符号法$は】要請の `Accept-Encoding$h ~headerに応じて変わる
◎
can be stored for 60 seconds by both private and shared caches, can be revalidated with If-None-Match, and varies on the Accept-Encoding request header field.
</p>
</div>

			</section>
		</section>
		<section id="state">
<h3 title="Handling Application State">4.10. 応用~状態の取扱い</h3>

<p>
応用は、［
`~client$を識別する／
要請を ある文脈~下に置くよう，~clientに特有な~dataを格納する
］ためとして，~statefulな~cookie `I-D.ietf-httpbis-rfc6265bis$r を利用できる。
◎
Applications can use stateful cookies [I-D.ietf-httpbis-rfc6265bis] to identify a client and/or store client-specific data to contextualise requests.
</p>

<p>
~cookieを利用するときは、その視野-法と利用を注意深く指定することが重要になる。
応用が敏感な~dataや能力を公開した場合、悪用sがアリになる（例：~ambient権限として動作することにより）。
その軽減策としては、要請に特有な~tokenを利用して`~client$の意図を確約することが挙げられる。
◎
When used, it is important to carefully specify the scoping and use of cookies; if the application exposes sensitive data or capabilities (e.g., by acting as an ambient authority), exploits are possible. Mitigations include using a request-specific token to assure the intent of the client.
</p>

		</section>
		<section id="multiplex">
<h3 title="Making Multiple Requests">4.11. 複数の要請を為すとき</h3>

<p>
`~client$は、ある~taskを遂行するために複数個の要請を送信する必要があることが多い。
◎
Clients often need to send multiple requests to perform a task.
</p>

<p>
並列的な要請は、~HTTP1においては，複数個の接続を~openすることで~supportされることが最も多い。
同時に利用される接続が多過ぎる場合、応用の処理能に影響iし得る
— それらの接続の輻輳~制御は協調されないので。
さらには，応用にとっては、所与の要請を発行iするために［
どの接続を利用するか選定すること／いつそれを利用するか裁定すること
］は困難なこともあり，それも処理能に影響iする。
◎
In HTTP/1, parallel requests are most often supported by opening multiple connections. Application performance can be impacted when too many simultaneous connections are used, because connections' congestion control will not be coordinated. Furthermore, it can be difficult for applications to decide when and to select which connection to use to issue a given request, further impacting performance.
</p>

<p>
［
~HTTP2／~HTTP3
］は、応用に多重化-法を提供して，複数個の接続を利用する必要を除去する。
しかしながら，それでも、応用の処理能は，~serverが応答の優先度をどう選ぶかに有意に影響され得る。
［
応答の優先度を~serverが決定する／
~clientが応答の優先度について~serverに~hintする
］のうち，どちらが最善になるかは、応用に依存する（例：
`I-D.ietf-httpbis-priority$r
を見よ）。
◎
HTTP/2 and HTTP/3 offer multiplexing to applications, removing the need to use multiple connections. However, application performance can still be significantly affected by how the server chooses to prioritize responses. Depending on the application, it might be best for the server to determine the priority of responses, or for the client to hint its priorities to the server (see, e.g., [I-D.ietf-httpbis-priority]).
</p>

<p>
~HTTP~versionを問わず、各~要請は，独立に為される
— 複数個の要請の相対-順序に依拠して，処理~順序を保証することはできない。
何故なら、それらは［
`中継者$により多重化された~protocol越しに送信される／
異なる`生成元~server$へ送信される
］こともあり，当の~serverは異なる順序で処理することすらあるかもしれないので。
2 個の要請に対し厳密な順序付けが必要な場合に，その成り行きを確約するための依拠-可能な仕方は、
1 個目の要請に対する`最終-応答$が始まってから，
2 個目の要請を発行iする他にない。
◎
In all versions of HTTP, requests are made independently -- you can't rely on the relative order of two requests to guarantee processing order. This is because they might be sent over a multiplexed protocol by an intermediary, sent to different origin servers, or the server might even perform processing in a different order. If two requests need strict ordering, the only reliable way to assure the outcome is to issue the second request when the final response to the first has begun.
</p>

<p>
応用は、同じ~transport接続~上の別々な要請に対し，何か関係性があると見做してはナラナイ。
そうすることは、~HTTPの`~stateless$な~protocolとしての前提の多くを破ることに加え，［
相互運用能／~security／運用能／発展
］における問題の原因になるので。
◎
Applications MUST NOT make assumptions about the relationship between separate requests on a single transport connection; doing so breaks many of the assumptions of HTTP as a stateless protocol, and will cause problems in interoperability, security, operability and evolution.
</p>

		</section>
		<section id="client-auth">
<h3 title="Client Authentication">4.12. ~client認証</h3>

<p>
応用は、~HTTP認証 `I-D.ietf-httpbis-semantics$r を利用して，`~client$を識別できる。
~Basic認証~scheme `RFC7617$r
は、下層の~transportが
（例： “HTTPS” ~URI~scheme／別の~TLSを利用して供されるもの）［
認証-済み, かつ完全性が保護され, かつ機密的
］である場合を除き，利用してはナラナイ。
~Digest認証~scheme `RFC7616$r
は、［
下層の~transportが類似に~secureであるか，
"`MD5^c" 以外の~hash~algoが選ばれている
］場合を除き，利用してはナラナイ。
◎
Applications can use HTTP authentication [I-D.ietf-httpbis-semantics] to identify clients. The Basic authentication scheme [RFC7617] MUST NOT be used unless the underlying transport is authenticated, integrity-protected and confidential (e.g., as provided the "HTTPS" URI scheme, or another using TLS). The Digest scheme [RFC7616] MUST NOT be used unless the underlying transport is similarly secure, or the chosen hash algorithm is not "MD5".
</p>

<p>
~HTTPSでは、`~client$は，証明書を利用して認証されることもある
`RFC5246$r
。
◎
With HTTPS, clients might also be authenticated using certificates [RFC5246].
</p>

<p>
利用されるときは、認証の視野-法と利用を注意深く指定することが重要になる。
応用が敏感な~dataや能力を公開した場合、悪用sがアリになるので（例：~ambient権限として動作することにより）。
軽減策として、要請に特有な~tokenを利用して`~client$の意図を確約することが挙げられる。
◎
When used, it is important to carefully specify the scoping and use of authentication; if the application exposes sensitive data or capabilities (e.g., by acting as an ambient authority), exploits are possible. Mitigations include using a request-specific token to assure the intent of the client.
</p>

		</section>
		<section id="browser">
<h3 title="Co-Existing with Web Browsing">4.13. ~web閲覧との共存-法</h3>

<p>
応用には，~Web~browserから利用される意図は無いとしても、その`資源$は，~browserその他の~HTTP`~client$には可用であり続けることになる。
◎
Even if there is not an intent for an application to be used with a Web browser, its resources will remain available to browsers and other HTTP clients.
</p>

<p>
このことは、そのような［
~HTTPを利用する すべての応用
］は，［
~browserが，応用と どうヤリトリすることになるか
］を
— 特に~securityに関して —
考慮する必要があることを意味する。
◎
This means that all such applications that use HTTP need to consider how browsers will interact with them, particularly regarding security.
</p>

<p>
例えば，応用の状態を `POST$m 要請を利用して変更できる場合、
~Web~browserは，任意な~Web~siteからの~CSRF（ `cross-site request forgery^en ）へ容易に誘い込まれ得る。
◎
For example, if an application's state can be changed using a POST request, a Web browser can easily be coaxed into cross-site request forgery (CSRF) from arbitrary Web sites.
</p>

<p>
あるいは，応用の`資源$から返される内容が攻撃者の制御~下にある場合（例：
要請の一部が応答~内に反映される場合／
応答は攻撃者の制御~下にあるかもしれない，外部な情報を包含する場合）、~XSS（ `cross-site scripting^en ）攻撃がアリになる
— それにより，攻撃者は、~browserの中に~codeを注入して，その生成元に属する~dataや能力に~accessできるようになる。
◎
Or, if content returned from the application's resources is under control of an attacker (for example, part of the request is reflected in the response, or the response contains external information that might be under the control of the attacker), a cross-site scripting (XSS) attack is possible, whereby an attacker can inject code into the browser and access data and capabilities on that origin.
</p>

<p>
これは、~HTTPを利用している応用が考慮しなければならない課題のうち，一握りの種類でしかない。
一般に，最善な~approachは、当の応用は実際に~Web応用であると見なす下で，その~secureな開発~用の最善な実施に従うことである。
◎
This is only a small sample of the kinds of issues that applications using HTTP must consider. Generally, the best approach is to consider the application actually as a Web application, and to follow best practices for their secure development.
</p>

<p>
そのような実施の完全な列挙は，この文書の視野から外れるが、次に挙げる考慮点が含まれる：
◎
A complete enumeration of such practices is out of scope for this document, but some considerations include:
</p>
<ul>
	<li>
`Content-Type$h ~header内で，応用に特有な`~MIME型$を利用するよう~~定めた上で、利用されていない場合には失敗するよう，`~client$に要求する。
◎
Using an application-specific media type in the Content-Type header field, and requiring clients to fail if it is not used.
</li>
	<li>
<code>`X-Content-Type-Options$h: `nosniff^v</code>
`FETCH$r を利用して、攻撃者の制御-下にある内容は，［
能動的な内容として解釈するよう~Web~browserを誘い込むもの
］にはなり得ないことを確約する。
◎
Using X-Content-Type-Options: nosniff [FETCH] to assure that content under attacker control can't be coaxed into a form that is interpreted as active content by a Web browser.
</li>
	<li>
`Content-Security-Policy$h `CSP$r を利用して，能動的な内容（~HTML `HTML$r など）の能力を拘束して、それにより~XSS攻撃を軽減する。
◎
Using Content-Security-Policy [CSP] to constrain the capabilities of active content (such as HTML [HTML]), thereby mitigating Cross-Site Scripting attacks.
</li>
	<li>
`Referrer-Policy$h `REFERRER-POLICY$r を利用して，
~URL内の敏感な~dataが `Referer$h 要請~header内に漏洩されるのを防止する。
◎
Using Referrer-Policy [REFERRER-POLICY] to prevent sensitive data in URLs from being leaked in the Referer request header field.
</li>
	<li>
~cookieに対し
`HttpOnly$c 属性【！flag】 `I-D.ietf-httpbis-rfc6265bis$r
を利用して，~cookieは~browserの~scriptには公開されないことを確約する。
◎
Using the 'HttpOnly' flag on Cookies to assure that cookies are not exposed to browser scripting languages [I-D.ietf-httpbis-rfc6265bis].
</li>
	<li>
敏感な情報（例： 認証~token, ~password）に対しては、圧縮の利用を避ける。
~Web~browserが提供する~scripting環境は、圧縮~空間【圧縮~用の辞書】を繰返ly探査することを攻撃者に許容する
— 攻撃者が通信の経路への~accessを有する場合、この能力を利用して，その情報を回復できるので。
◎
Avoiding use of compression on any sensitive information (e.g., authentication tokens, passwords), as the scripting environment offered by Web browsers allows an attacker to repeatedly probe the compression space; if the attacker has access to the path of the communication, they can use this capability to recover that information.
</li>
</ul>

<p>
~HTTPを利用している応用~用の仕様は、どう配備されるものと意図されるかに依存して，これらの仕組みを自身に特有な仕方で利用するよう要求することもあれば，
“§ ~securityの考慮点” において単に指摘するだけかもしれない。
◎
Depending on how they are intended to be deployed, specifications for applications using HTTP might require the use of these mechanisms in specific ways, or might merely point them out in Security Considerations.
</p>

<div class="example">

<p>
応用からの~HTTP応答が［
その`内容$は~browserからは能動的なものと扱われる
］ものと意図されない例は、次の様な見かけになろう：
◎
An example of a HTTP response from an application that does not intend for its content to be treated as active by browsers might look like this:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/example+json
X-Content-Type-Options: nosniff
Content-Security-Policy: default-src 'none'
Cache-Control: max-age=3600
Referrer-Policy: no-referrer

[内容]
</pre>
</div>

<p>
~browserとの互換性を目標に置く応用は、`~client$とのヤリトリを `FETCH$r の用語で定義する~OUGHT
— それが、~browserが~HTTP用に利用する抽象化であり，これらの最善な実施の多くを施行するので。
◎
If an application has browser compatibility as a goal, client interaction ought to be defined in terms of [FETCH], since that is the abstraction that browsers use for HTTP; it enforces many of these best practices.
</p>

		</section>
		<section id="other-apps">
<h3 title="Maintaining Application Boundaries">4.14. 応用~境界の保守-法</h3>

<p>
多くの~HTTP能力は，生成元 `RFC6454$r に基づいて その視野が絞られるので、応用は，自身の配備が同じ生成元に属する他の応用（~Web閲覧も含む）とどう相互作用し得るか考慮する必要もある。
◎
Because the origin [RFC6454] is how many HTTP capabilities are scoped, applications also need to consider how deployments might interact with other applications (including Web browsing) on the same origin.
</p>

<p>
例えば，応用の状態が
`Cookie$h `I-D.ietf-httpbis-rfc6265bis$r
を利用して運ばれる場合、その~cookieは
— 既定では，~pathにより視野が絞られていない限り —
生成元へ送信される どの要請にも伴われることになり、応用は，当の生成元に属する他の応用からも~cookieを受信するかもしれない。
これは、~securityの課題に加え，~cookie名の衝突も導き得る。
◎
For example, if Cookies [I-D.ietf-httpbis-rfc6265bis] are used to carry application state, they will be sent with all requests to the origin by default, unless scoped by path, and the application might receive cookies from other applications on the origin. This can lead to security issues, as well as collision in cookie names.
</p>

<p>
これらの課題に対する解法の一つは、応用に対し専用な~hostnameを要求して，応用が一意な生成元を有するようにすることである。
しかしながら，単独の~hostnameに対し複数の応用を配備するのを許容する方が望ましいことも多い
— そうすることは、配備における柔軟性を最も供することに加え，それらの “混ぜ合わせ” を可能化する（詳細は `RFC8820$r を見よ）。
したがって，~HTTPを利用している応用は、複数の応用が同じ生成元に属するのを許容するよう，努めるべきである。
◎
One solution to these issues is to require a dedicated hostname for the application, so that it has a unique origin. However, it is often desirable to allow multiple applications to be deployed on a single hostname; doing so provides the most deployment flexibility and enables them to be "mixed" together (See [RFC8820] for details). Therefore, applications using HTTP should strive to allow multiple applications on an origin.
</p>

<p>
これを可能化するため，~HTTPを利用している応用は、［
`Cookie$h ／
~HTTP認証~realm `I-D.ietf-httpbis-semantics$r ／
他の，生成元~~全般な~HTTPの仕組み
］の利用を指定するときに，特定0の名前の利用を義務付けるべきではなく、代わりに各~配備に応用を環境設定してもらうようにするべきである。
［
応用に指定された仕組みを利用して，応用の視野を当の生成元の一部に絞ること
］に関する考慮点を与えるべきである。
◎
To enable this, when specifying the use of Cookies, HTTP authentication realms [I-D.ietf-httpbis-semantics], or other origin-wide HTTP mechanisms, applications using HTTP should not mandate the use of a particular name, but instead let deployments configure them. Consideration should be given to scoping them to part of the origin, using their specified mechanisms for doing so.
</p>

<p>
現代の~Web~browserは、私用な情報が漏洩されるのを避けるため，ある生成元に属する内容が別の生成元に属する`資源$へ~accessする能を拘束する。
したがって，非同一-生成元に属する~dataを~browserに公開したいと望む応用は、`~CORS~protocol$ `FETCH$r を実装する必要がある。
◎
Modern Web browsers constrain the ability of content from one origin to access resources from another, to avoid leaking private information. As a result, applications that wish to expose cross-origin data to browsers will need to implement the CORS protocol; see [FETCH].
</p>

		</section>
		<section id="server-push">
<h3 title="Using Server Push">4.15. ~server~pushの利用-法</h3>

<p>
~HTTP2は、
`RFC7540/8.2$sec にて
`~server$が要請/応答~pairを`~client$に “~pushする” 能を追加する。
~server~pushは、多くの共通的な応用~意味論（例： “拡散” や ~publish/~subscribe）に自然に収まる様に見受けられるが，少数の注意事項がある：
◎
HTTP/2 adds the ability for servers to "push" request/response pairs to clients in [RFC7540], Section 8.2. While server push seems like a natural fit for many common application semantics (e.g., "fanout" and publish/subscribe), a few caveats should be noted:
</p>

<ul>
	<li>
~server~pushは`隣点間$であり、`中継者$は，それを自動的に回送しない。
その結果、［
`~proxy$／逆~proxy／~CDN
］がある下では容易に（あるいは まったく）働かないかもしれない。
◎
Server push is hop-by-hop; that is, it is not automatically forwarded by intermediaries. As a result, it might not work easily (or at all) with proxies, reverse proxies, and Content Delivery Networks.
</li>
	<li>
~server~pushは、不正に利用されると，~HTTPにおける処理能に負な影響iをもたらし得る
— 特に，`~client$から実際に要請された`資源$において競合がある場合。
◎
Server push can have negative performance impact on HTTP when used incorrectly; in particular, if there is contention with resources that have actually been requested by the client.
</li>
	<li>
`~client$における~server~pushの実装は、~clientに応じて
— とりわけ、~HTTP~cache法との相互作用に関して —
異なり，その能力も変わるかもしれない。
◎
Server push is implemented differently in different clients, especially regarding interaction with HTTP caching, and capabilities might vary.
</li>
	<li>
現時点では，~server~push用の~APIは、一部の実装では可用でなく，他の実装においても~~多岐に渡る。
特に，現在の~browserには、そのような~APIは無い。
◎
APIs for server push are currently unavailable in some implementations, and vary widely in others. In particular, there is no current browser API for it.
</li>
	<li>
~server~pushは、［
~HTTP11／~HTTP10
］においては~supportされない。
◎
Server push is not supported in HTTP/1.1 or HTTP/1.0.
</li>
	<li>
~server~pushは、~HTTP “中核” 意味論の一部を形成しないので、~HTTPの将来~versionにおいては~supportされないかもしれない。
◎
Server push does not form part of the "core" semantics of HTTP, and therefore might not be supported by future versions of the protocol.
</li>
</ul>

<p>
応用は、`~client$が［
要請に関係する作業
］を［
応答が全部的に可用になる前
］に遂行できる事例（例：【応答の】中に包含されると見込まれるもの用に~linkを~fetchするなど）を最適化したいと望むなら，状態s~code `103$st を利用することで便益を得られるかもしれない
— `RFC8297$r を見よ。
◎
Applications wishing to optimise cases where the client can perform work related to requests before the full response is available (e.g., fetching links for things likely to be contained within) might benefit from using the 103 (Early Hints) status code; see [RFC8297].
</p>

<p>
~server~pushを直に利用している応用は、非同一-生成元~push攻撃を避けるため，
`RFC7540/8.2$sec における権限に関する要件を施行する必要がある。
◎
Applications using server push directly need to enforce the requirements regarding authority in [RFC7540], Section 8.2, to avoid cross-origin push attacks.
</p>

		</section>
		<section id="versioning">
<h3 title="Allowing Versioning and Evolution">4.16. ~version付けと発展の許容-法</h3>

<p>
応用~protocolの中に新たな特能を導入したり，既存の特能を変更することが必要とされることは多い。
◎
It's often necessary to introduce new features into application protocols, and change existing ones.
</p>

<p>
~HTTPにおいては、後方-互換でない変更は，いくつかの仕組みを利用してアリになる：
◎
In HTTP, backwards-incompatible changes are possible using a number of mechanisms:
</p>
<ul>
	<li>
別個な`~link関係~型$ `RFC8288$r を利用して，新たな機能性を実装する`資源$用の~URLを識別する。
◎
Using a distinct link relation type [RFC8288] to identify a URL for a resource that implements the new functionality.
</li>
	<li>
別個な`~MIME型$ `RFC6838$r を利用して，新たな機能性を可能化する形式を識別する。
◎
Using a distinct media type [RFC6838] to identify formats that enable the new functionality.
</li>
	<li>
別個な~HTTP~headerを利用して，~messageの`内容$の外側に新たな機能性を実装する。
◎
Using a distinct HTTP header field to implement new functionality outside the message content.
</li>
</ul>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">5. ~IANA考慮点</h2>

<p>
この文書には、~IANA用の要件は無い。
◎
This document has no requirements for IANA.
</p>

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">6. ~securityの考慮点</h2>

<p>
`4.10$sec は、~HTTPにおいて~statefulな仕組みを~ambient権限として利用することによる影響iを論じることに加え，それに対する軽減策を示唆する。
◎
Section 4.10 discusses the impact of using stateful mechanisms in the protocol as ambient authority, and suggests a mitigation.
</p>

<p>
`4.4.2$sec
は、［
認証, 完全性, 機密性
］を供するため, および
大規模な監視~攻撃を軽減するため、
`https^c ~URL用の~supportを要求することに加え，
`http^c ~URLの利用を忌避する。
◎
Section 4.4.2 requires support for 'https' URLs, and discourages the use of 'http' URLs, to provide authentication, integrity and confidentiality, as well as mitigate pervasive monitoring attacks.
</p>

<p>
`4.13$sec
は、~HTTPを利用する応用に対する~Web~browserの能力による含意を特にとりあげる。
◎
Section 4.13 highlights the implications of Web browsers' capabilities on applications that use HTTP.
</p>

<p>
`4.14$sec
は、応用が~Web~site（および他の応用)と同じ生成元~上で配備されるときに発生する課題について論じる。
◎
Section 4.14 discusses the issues that arise when applications are deployed on the same origin as Web sites (and other applications).
</p>

<p>
`4.15$sec
は、~HTTP2~server~pushを指定された以外の方式で利用することによる~riskを特にとりあげる。
◎
Section 4.15 highlights risks of using HTTP/2 server push in a manner other than specified.
</p>

<p>
応用が，実装の改変を孕む方式で~HTTPを利用する場合
— 例えば，［
新たな~URI~scheme／標準でない`~method$
］用の~supportを要求するなど — 
それらの実装が親~HTTP実装から “~~枝分かれ（ `fork^en ）” する結果，［
上流に組入れられた~patchその他による~securityの改善
］から便益を得られなくなるなどの~riskがある。
◎
Applications that use HTTP in a manner that involves modification of implementations -- for example, requiring support for a new URI scheme, or a non-standard method -- risk having those implementations "fork" from their parent HTTP implementations, with the possible result that they do not benefit from patches and other security improvements incorporated upstream.
</p>

		</section>
		<section id="privacy-considerations">
<h3 title="Privacy Considerations">6.1. ~privacyの考慮点</h3>

<p>
~HTTP`~client$は、多様な情報を`~server$に公開し得る。
応用の運用の一部として明示的に送信される情報（例えば，利用者が手入力した，名前~その他の~data）, および
“伝送路~上の” 情報（それが、 `4.4.2$sec にて `https^c が推奨される理由の一つである）は別として、他の情報も~~明白でない手段（利用者が接続する活動を，時経過にわたり収集するものが多い）を通して集められ得る。
◎
HTTP clients can expose a variety of information to servers. Besides information that's explicitly sent as part of an application's operation (for example, names and other user-entered data), and "on the wire" (which is one of the reasons https is recommended in Section 4.4.2), other information can be gathered through less obvious means -- often by connecting activities of a user over time.
</p>

<p>
これには、［
~session情報,
指紋収集を通した`~client$の追跡,
~mobile~code†
］も含まれる。
◎
This includes session information, tracking the client through fingerprinting, and mobile code.
</p>

<p class="trans-note">【†
“移動-可能な~code”
— ~web~platformにおける~JSなど，他所から~downloadして実行される~program
】</p>

<p>
~session情報は、［
`~client$の~IP~addressの様なもの,
~TLS~session~ticket,
~cookie,
~clientの~cache内に格納された `ETag$h,
その他の~statefulな仕組み
］を含む。
応用は、運用にあたって［
避けれない／必要とされる
］場合を除き，~sessionの仕組みを利用するのは避けるよう勧める
— そのような事例では、これらの~riskが文書化される必要がある。
それらが利用されたときは，［
そのような状態を~clearすることを許容する
］よう、実装に奨励するべきである。
◎
Session information includes things like the IP address of the client, TLS session tickets, Cookies, ETags stored in the client's cache, and other stateful mechanisms. Applications are advised to avoid using session mechanisms unless they are unavoidable or necessary for operation, in which case these risks needs to be documented. When they are used, implementations should be encouraged to allow clearing such state.
</p>

<p>
指紋収集は、［
`~client$からの~message, ~clientの挙動
］における一意な側面を利用して，異質な［
要請どうし, 接続どうし
］を~~関連付ける。
例えば，［
`User-Agent$h ／ `Accept-Language$h
］要請~headerは、［
実装に特有な情報／利用者が選好する言語
］を伝達する。
そのような~~指標のうち いくつかの組合nは、~clientを一意に識別するために利用され得る
— それは、その【何の？】~dataに対する その制御に影響iがある。
したがって，応用には、［
~clientが要請~内に発する情報は、応用が機能するために必要なものに限るべきである
］ものと指定するよう勧める。
◎
Fingerprinting uses unique aspects of a client's messages and behaviours to connect disparate requests and connections. For example, the User-Agent request header field conveys specific information about the implementation; the Accept-Language request header field conveys the users' preferred language. In combination, a number of these markers can be used to uniquely identify a client, impacting its control over its data. As a result, applications are advised to specify that clients should only emit the information they need to function in requests.
</p>

<p>
最後に，ある応用が~mobile~codeを走らす能を公開する場合、多大な~careが必要になる
— その環境を観測する どの能も，［
`~client$を指紋収集する, および
私用な~data（~session情報も含む）を［
得する／操作する
］］ために利用され得る機会を与えるので。
例えば，高-分解能な~timerへの~accessは（間接的であっても）、［
下層の~hardwareを~profileする／
当の~system用に一意な識別子を作成する
］ために利用され得る。
応用には、アリな所では~mobile~codeの利用を許容するのを避けるよう勧める
— 避けれない場合、結果の~systemに備わる~securityの特質を，注意深く綿密に調べる必要がある。
◎
Finally, if an application exposes the ability to run mobile code, great care needs to be taken, since any ability to observe its environment can be used as an opportunity to both fingerprint the client and to obtain and manipulate private data (including session information). For example, access to high-resolution timers (even indirectly) can be used to profile the underlying hardware, creating a unique identifier for the system. Applications are advised to avoid allowing the use of mobile code where possible; when it cannot be avoided, the resulting system's security properties need be carefully scrutinised.
</p>

	</section>
	<section id="changes-from-rfc-3205">
<h2 title="Appendix A. Changes from RFC 3205">付録 A. ~RFC 3205 からの変更点</h2>

<p>
`RFC3205$r は、
2000 年代初頭に~protocol設計者が直面していた懸念に基づいて，その時点における現在の最善な実施を捕捉した。
~HTTPの利用は，その頃からかなり変化したため、この文書は著しく異なる結果になった。
その結果、変更点は，個別に挙げるには あまりに多過ぎる。
◎
[RFC3205] captured the Best Current Practice in the early 2000’s, based on the concerns facing protocol designers at the time. Use of HTTP has changed considerably since then, and as a result this document is substantially different. As a result, the changes are too numerous to list individually.
</p>

	</section>
</main></div>
