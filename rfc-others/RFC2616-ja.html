<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>ハイパーテキスト転送プロトコル -- HTTP/1.1</title>

<meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- 
href="#Sec([\d\.]+)" → href="#section-$1"
id="Sec([\d\.]+)" → id="section-$1"
href="#Ref(\d+)" → href="#ref-$1"
id="Ref(\d+)" → id="ref-$1"
-->

<meta charset="utf-8" />

<!-- 
<link rel="Stylesheet" href="rfc_ja.css" type="text/css" />
<link rel="Contents" href="http://www.studyinghttp.net/rfc_ja/" />
 -->

<style type="text/css">

/**
 * rfc_ja.css/20100325
 * for RFC-Translations
 */

 h1 {
	 clear:both;
	 text-align:center;
 }
 h2 {
	 margin:0.5em 0.1em;
	 text-align:left;
 }
 address {
	 font-size:0.9em;
	 font-style:normal;
	 text-align:right;
 }
 address a {
	 font-family:"Georgia", "Times New Roman", "Times", serif;
	 font-size:1.1em;
	 font-weight:bold;
 }
 p {
	 line-height:1.3em;
	 margin:0.5em 0.5em 0.5em 3em;
	 text-indent:1em;
 }
 pre {
	 line-height:1.3em;
	 margin:1em 1em 1em 5em;
 }
 dfn {
	 font-size:1.1em;
	 font-style:normal;
	 font-weight:bold;
 }
 code {
	 font:normal normal 1.1em monospace;
 }
 samp {
	 font-family:monospace;
	 margin:0 0.1em;
 }
 cite:before, cite:after {
	 content:'"';
 }
 em {
	 font-style:normal;
	 font-weight:bold;
 }
 blockquote {
	 margin-left:5em;
	 margin-right:4em;
 }
 a:hover, a:focus {
	 background-color:#bafecd;
 }
 hr {
	 clear:both;
 }

 ol {
	 list-style-type:decimal;
	 line-height:1.5em;
	 margin:0.5em 1em 0.5em 4em;
 }
 ol.ABC {
	 list-style-type:upper-alpha;
 }
 ol.abc {
	 list-style-type:lower-alpha;
 }
 ul {
	 list-style:disc;
	 line-height:1.5em;
	 margin:0.5em 1em 0.5em 4em;
 }
 ol p, ul p {
	 margin-left:0.5em;
 }
 li ol, li ul {
	 margin:0 0 0 1%;
 }

 dl { /* Definition List */
	 line-height:1.5em;
	 margin:1.2em 1em 0 4em;
 }
 dt {
	 font-weight:bold;
 }
 dd {
	 margin:0.2em 1em 0.7em;
 }

 table {
	 margin:1em 1em 1em 5em;
 }
 td dl, td pre {
	 margin:0.5em 0em;
 }

/* --- Original Class --- */

 .note {
	 font-size:0.9em;
	 margin-left:4em;
 }
 .references dt:before {
	 content:"[";
 }
 .references dt:after {
	 content:"]";
 }

 #NUMBER {
	 border:none;
	 float:left;
	 margin:0.5em;
	 white-space:pre;
 }
 #AUTHOR {
	 border:none;
	 float:right;
	 margin:0.5em;
	 white-space:pre;
 }
 #CONTENTS dt {
	 margin:0.5em 0 0;
 }
 #CONTENTS dd {
	 margin:0 0 0 2em;
 }
 #CONTENTS dd dl, #CONTENTS dd dt {
	 margin:0;
	 font-weight: normal;
 }
 #NOTICE {
	 border:0.2em #999 solid;
	 margin:1em 5%;
	 padding:0.5em;
 }
</style>

<style>
aside {
	font-size: small;
	border: double #BB3333 6px;
	padding: 0.5em 1em;
	margin-bottom: 1em;
}

aside > p,
aside > ul {
	margin: 1em;
}
</style>

</head>

<body>

<aside class="trans-meta">

<h1>RFC2616 日本語訳の複製</h1>
<p>
<a href="https://triple-underscore.github.io/rfc-others/RFC2616-ja.html">このページ</a>
は、 IETF による
<cite><a href="https://www.rfc-editor.org/rfc/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a></cite>
（ RFC 2616 ）の，橋本英彦 氏による
<a href="http://www.studyinghttp.net/rfc_ja/rfc2616">日本語訳</a>
†を、内容に手を加えずに，転載したものです††。
</p>

<ul>
	<li>†
2014 年 3 月 頃のもの。
現在はリンク切れ — リンク先サイト（ http://www.studyinghttp.net/ ）は 2014 年 5 月 頃 〜 2014 年 7 月 13 日 現在まで，アクセスできなくなっています。
</li>
	<li>††
転載 公開日： <time>2014-07-14</time> — 明示的に許諾は得てはいません。
下記ヘッダのリンク先に（上述と同じ頃に）記載されていた 取り扱い規約に従い，改変を加えずに配布するものです。
ただし、一部マークアップを変更しています（ DOCTYPE など）。
また、要素 id の命名方式を RFC 原文と同じものに戻しています。
</li>
</ul>

<p>
<strong>注意：
この RFC 2616 （および 関連の一部 RFC ）は、
現在では古くなっています
</strong>。
それを置換する HTTP1.1 の改訂が、
<a href="https://httpwg.org/specs/rfc7230.html">RFC 7230</a>,
<a href="https://httpwg.org/specs/rfc7231.html">RFC 7231</a>,
<a href="https://httpwg.org/specs/rfc7232.html">RFC 7232</a>,
<a href="https://httpwg.org/specs/rfc7233.html">RFC 7233</a>,
<a href="https://httpwg.org/specs/rfc7234.html">RFC 7234</a>,
<a href="https://httpwg.org/specs/rfc7235.html">RFC 7235</a>
に分割されて公表されています
（<a href="https://triple-underscore.github.io/RFC723X-ja.html">日本語訳</a>）。
これらも、現在は，
<a href="https://httpwg.org/specs/rfc9110.html">RFC 9110</a>,
<a href="https://httpwg.org/specs/rfc9111.html">RFC 9111</a>,
<a href="https://httpwg.org/specs/rfc9112.html">RFC 9112</a>
に置換されてます
（<a href="https://triple-underscore.github.io/http-common-ja.html">日本語訳</a>）。
</p>

</aside>


<div id="TOP">
<a href="http://www.studyinghttp.net/">Studying HTTP</a> &gt;
<a href="http://www.studyinghttp.net/rfc_ja/">RFC-Translations related HTTP</a>

<p id="NOTICE">
この文書は、
<cite>R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, T. Berners-Lee: <a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a> (RFC 2616), June 1999.</cite>
を 橋本英彦 が日本語訳した物です。
この文書の取り扱いについては、<a href="http://www.studyinghttp.net/rfc_ja/#Notice">[Studying HTTP] の RFC 日本語訳を利用するにあたって</a>に従って下さい。
</p>

</div>
<hr />

<pre id="NUMBER">Network Working Group
Request for Comments: 2616
Obsoletes: 2068
Category: Standards Track
</pre>
<pre id="AUTHOR">    R. Fielding
      UC Irvine
      J. Gettys
     Compaq/W3C
       J. Mogul
         Compaq
     H. Frystyk
        W3C/MIT
    L. Masinter
          Xerox
       P. Leach
      Microsoft
 T. Berners-Lee
        W3C/MIT
      June 1999
</pre>

<h1>ハイパーテキスト転送プロトコル -- HTTP/1.1</h1>

<h2>この文書の位置付け</h2>

<p>
この文書は、インターネットコミュニティにおけるインターネット標準化過程プロトコルを規定し、改良のために議論と提案を求めるものである。
このプロトコルの標準化状態と状況については、&quot;Internet Official Protocol Standards&quot; (STD 1) の最新版を参照していただきたい。
この文書の配布に制限は無い。
</p>

<h2>著作権表示</h2>

<p>
Copyright &copy; The Internet Society (1999).  All Rights Reserved.
</p>

<h2>概要</h2>

<p>
ハイパーテキスト転送プロトコル (HTTP) は、分散・共同体ハイパーメディア情報システムのアプリケーションレベルプロトコルである。
このプロトコルは、リクエストメソッド、エラーコード、ヘッダ等の拡張を経て、ネームサーバや分散オブジェクト管理システム等、ハイパーテキストのために使う以上に多くの作業のために用いる事ができる、一般的でステートレスなプロトコルである <a href="#ref-47">[47]</a>。
HTTP の特徴として、データ表現のタイプ付け、及びネゴシエーションがあり、これによって転送されるデータの独立性が確立されるようなシステムが構築できる。
</p>

<p>
HTTP は、World-Wide Web グローバル情報利用の先進として、1990 年から使われている。
この仕様書は、&quot;HTTP/1.1&quot; と呼ばれるプロトコルを定義し、RFC 2068 <a href="#ref-33">[33]</a> を更新するものである。
</p>

<h2>目次</h2>

<dl id="CONTENTS">

<dt>1 <a href="#section-1">導入</a></dt>
<dd>1.1 <a href="#section-1.1">目的</a></dd>
<dd>1.2 <a href="#section-1.2">必要条件</a></dd>
<dd>1.3 <a href="#section-1.3">専門用語</a></dd>
<dd>1.4 <a href="#section-1.4">全体の動作</a></dd>

<dt>2 <a href="#section-2">表記の慣習と一般文法</a></dt>
<dd>2.1 <a href="#section-2.1">拡張 BNF</a></dd>
<dd>2.2 <a href="#section-2.2">基本的な規定</a></dd>

<dt>3 <a href="#section-3">プロトコルパラメータ</a></dt>
<dd>3.1 <a href="#section-3.1">HTTP のバージョン</a></dd>
<dd><dl>
<dt>3.2 <a href="#section-3.2">Uniform Resource Identifiers</a></dt>
<dd>3.2.1 <a href="#section-3.2.1">一般構文</a></dd>
<dd>3.2.2 <a href="#section-3.2.2">http URL</a></dd>
<dd>3.2.3 <a href="#section-3.2.3">URI の比較</a></dd>
</dl></dd>
<dd><dl>
<dt>3.3 <a href="#section-3.3">日付/時刻フォーマット</a></dt>
<dd>3.3.1 <a href="#section-3.3.1">完全な日付</a></dd>
<dd>3.3.2 <a href="#section-3.3.2">秒差</a></dd>
</dl></dd>
<dd><dl>
<dt>3.4 <a href="#section-3.4">文字セット</a></dt>
<dd>3.4.1 <a href="#section-3.4.1">Charset の誤り</a></dd>
</dl></dd>
<dd>3.5 <a href="#section-3.5">内容コーディング</a></dd>
<dd><dl>
<dt>3.6 <a href="#section-3.6">転送コーディング</a></dt>
<dd>3.6.1 <a href="#section-3.6.1">チャンク形式転送コーディング</a></dd>
</dl></dd>
<dd><dl>
<dt>3.7 <a href="#section-3.7">メディアタイプ</a></dt>
<dd>3.7.1 <a href="#section-3.7.1">公式化とテキストの既定</a></dd>
<dd>3.7.2 <a href="#section-3.7.2">マルチパートタイプ</a></dd>
</dl></dd>
<dd>3.8 <a href="#section-3.8">製品トークン</a></dd>
<dd>3.9 <a href="#section-3.9">品質値</a></dd>
<dd>3.10 <a href="#section-3.10">言語タグ</a></dd>
<dd>3.11 <a href="#section-3.11">エンティティタグ</a></dd>
<dd>3.12 <a href="#section-3.12">レンジ単位</a></dd>

<dt>4 <a href="#section-4">HTTP のメッセージ</a></dt>
<dd>4.1 <a href="#section-4.1">メッセージタイプ</a></dd>
<dd>4.2 <a href="#section-4.2">メッセージヘッダ</a></dd>
<dd>4.3 <a href="#section-4.3">メッセージボディ</a></dd>
<dd>4.4 <a href="#section-4.4">メッセージの長さ</a></dd>
<dd>4.5 <a href="#section-4.5">一般ヘッダフィールド</a></dd>

<dt>5 <a href="#section-5">リクエスト</a></dt>
<dd><dl>
<dt>5.1 <a href="#section-5.1">リクエストライン</a></dt>
<dd>5.1.1 <a href="#section-5.1.1">メソッド</a></dd>
<dd>5.1.2 <a href="#section-5.1.2"> Request-URI</a></dd>
</dl></dd>
<dd>5.2 <a href="#section-5.2">リクエストによるリソースの識別</a></dd>
<dd>5.3 <a href="#section-5.3">リクエストヘッダフィールド</a></dd>

<dt>6 <a href="#section-6">レスポンス</a></dt>
<dd><dl>
<dt>6.1 <a href="#section-6.1">ステータスライン</a></dt>
<dd>6.1.1 <a href="#section-6.1.1">ステータスコードと説明句</a></dd>
</dl></dd>
<dd>6.2 <a href="#section-6.2">レスポンスヘッダフィールド</a></dd>

<dt>7 <a href="#section-7">エンティティ</a></dt>
<dd>7.1 <a href="#section-7.1">エンティティヘッダフィールド</a></dd>
<dd><dl>
<dt>7.2 <a href="#section-7.2">エンティティボディ</a></dt>
<dd>7.2.1 <a href="#section-7.2.1">タイプ</a></dd>
<dd>7.2.2 <a href="#section-7.2.2">エンティティの長さ</a></dd>
</dl></dd>

<dt>8 <a href="#section-8">接続</a></dt>
<dd><dl>
<dt>8.1 <a href="#section-8.1">持続的接続</a></dt>
<dd>8.1.1 <a href="#section-8.1.1">目的</a></dd>
<dd>8.1.2 <a href="#section-8.1.2">全体の動作</a></dd>
<dd>8.1.3 <a href="#section-8.1.3">プロクシサーバ</a></dd>
<dd>8.1.4 <a href="#section-8.1.4">現実的な考察</a></dd>
</dl></dd>
<dd><dl>
<dt>8.2 <a href="#section-8.2">メッセージ転送の必要条件</a></dt>
<dd>8.2.1 <a href="#section-8.2.1">持続的接続とフローコントロール</a></dd>
<dd>8.2.2 <a href="#section-8.2.2">エラーステータスメッセージのための接続のモニタリング</a></dd>
<dd>8.2.3 <a href="#section-8.2.3">100 (Continue) ステータスの使用</a></dd>
<dd>8.2.4 <a href="#section-8.2.4">サーバが早まって接続を閉じた場合のクライアントの振る舞い</a></dd>
</dl></dd>

<dt>9 <a href="#section-9">メソッドの定義</a></dt>
<dd><dl>
<dt>9.1 <a href="#section-9.1">安全{safe} なメソッドと冪等{idempotent} なメソッド</a></dt>
<dd>9.1.1 <a href="#section-9.1.1">安全{safe} なメソッド</a></dd>
<dd>9.1.2 <a href="#section-9.1.2">冪等{idempotent} なメソッド</a></dd>
</dl></dd>
<dd>9.2 <a href="#section-9.2">OPTIONS</a></dd>
<dd>9.3 <a href="#section-9.3">GET</a></dd>
<dd>9.4 <a href="#section-9.4">HEAD</a></dd>
<dd>9.5 <a href="#section-9.5">POST</a></dd>
<dd>9.6 <a href="#section-9.6">PUT</a></dd>
<dd>9.7 <a href="#section-9.7">DELETE</a></dd>
<dd>9.8 <a href="#section-9.8">TRACE</a></dd>
<dd>9.9 <a href="#section-9.9">CONNECT</a></dd>

<dt>10 <a href="#section-10">ステータスコードの定義</a></dt>
<dd><dl>
<dt>10.1 <a href="#section-10.1">Informational 1xx</a></dt>
<dd>10.1.1<a href="#section-10.1.1">100 Continue</a></dd>
<dd>10.1.2 <a href="#section-10.1.2">101 Switching Protocols</a></dd>
</dl></dd>
<dd><dl>
<dt>10.2 <a href="#section-10.2">Successful 2xx</a></dt>
<dd>10.2.1 <a href="#section-10.2.1">200 OK</a></dd>
<dd>10.2.2 <a href="#section-10.2.2">201 Created</a></dd>
<dd>10.2.3 <a href="#section-10.2.3">202 Accepted</a></dd>
<dd>10.2.4 <a href="#section-10.2.4">203 Non-Authoritative Information</a></dd>
<dd>10.2.5 <a href="#section-10.2.5">204 No Content</a></dd>
<dd>10.2.6 <a href="#section-10.2.6">205 Reset Content</a></dd>
<dd>10.2.7 <a href="#section-10.2.7">206 Partial Content</a></dd>
</dl></dd>
<dd><dl>
<dt>10.3 <a href="#section-10.3">Redirection 3xx</a></dt>
<dd>10.3.1 <a href="#section-10.3.1">300 Multiple Choices</a></dd>
<dd>10.3.2 <a href="#section-10.3.2">301 Moved Permanently</a></dd>
<dd>10.3.3 <a href="#section-10.3.3">302 Found</a></dd>
<dd>10.3.4 <a href="#section-10.3.4">303 See Other</a></dd>
<dd>10.3.5 <a href="#section-10.3.5">304 Not Modified</a></dd>
<dd>10.3.6 <a href="#section-10.3.6">305 Use Proxy</a></dd>
<dd>10.3.7 <a href="#section-10.3.7">306 (Unused)</a></dd>
<dd>10.3.8 <a href="#section-10.3.8">307 Temporary Redirect</a></dd>
</dl></dd>
<dd><dl>
<dt>10.4 <a href="#section-10.4">Client Error 4xx</a></dt>
<dd>10.4.1 <a href="#section-10.4.1">400 Bad Request</a></dd>
<dd>10.4.2 <a href="#section-10.4.2">401 Unauthorized</a></dd>
<dd>10.4.3 <a href="#section-10.4.3">402 Payment Required</a></dd>
<dd>10.4.4 <a href="#section-10.4.4">403 Forbidden</a></dd>
<dd>10.4.5 <a href="#section-10.4.5">404 Not Found</a></dd>
<dd>10.4.6 <a href="#section-10.4.6">405 Method Not Allowed</a></dd>
<dd>10.4.7 <a href="#section-10.4.7">406 Not Acceptable</a></dd>
<dd>10.4.8 <a href="#section-10.4.8">407 Proxy Authentication Required</a></dd>
<dd>10.4.9 <a href="#section-10.4.9">408 Request Timeout</a></dd>
<dd>10.4.10 <a href="#section-10.4.10">409 Conflict</a></dd>
<dd>10.4.11 <a href="#section-10.4.11">410 Gone</a></dd>
<dd>10.4.12 <a href="#section-10.4.12">411 Length Required</a></dd>
<dd>10.4.13 <a href="#section-10.4.13">412 Precondition Failed</a></dd>
<dd>10.4.14 <a href="#section-10.4.14">413 Request Entity Too Large</a></dd>
<dd>10.4.15 <a href="#section-10.4.15">414 Request-URI Too Long</a></dd>
<dd>10.4.16 <a href="#section-10.4.16">415 Unsupported Media Type</a></dd>
<dd>10.4.17 <a href="#section-10.4.17">416 Requested Range Not Satisfiable</a></dd>
<dd>10.4.18 <a href="#section-10.4.18">417 Expectation Failed</a></dd>
</dl></dd>
<dd><dl>
<dt>10.5 <a href="#section-10.5">Server Error 5xx</a></dt>
<dd>10.5.1 <a href="#section-10.5.1">500 Internal Server Error</a></dd>
<dd>10.5.2 <a href="#section-10.5.2">501 Not Implemented</a></dd>
<dd>10.5.3 <a href="#section-10.5.3">502 Bad Gateway</a></dd>
<dd>10.5.4 <a href="#section-10.5.4">503 Service Unavailable</a></dd>
<dd>10.5.5 <a href="#section-10.5.5">504 Gateway Timeout</a></dd>
<dd>10.5.6 <a href="#section-10.5.6">505 HTTP Version Not Supported</a></dd>
</dl></dd>

<dt>11 <a href="#section-11">アクセス認証</a></dt>

<dt>12 <a href="#section-12">内容ネゴシエーション</a></dt>
<dd>12.1 <a href="#section-12.1">サーバ駆動型ネゴシエーション</a></dd>
<dd>12.2 <a href="#section-12.2">エージェント駆動型ネゴシエーション</a></dd>
<dd>12.3 <a href="#section-12.3">透過的ネゴシエーション</a></dd>

<dt>13 <a href="#section-13">HTTP におけるキャッシング</a></dt>
<dd><dl>
<dd>13.1.1 <a href="#section-13.1.1">キャッシュの正当性</a></dd>
<dd>13.1.2 <a href="#section-13.1.2">警告</a></dd>
<dd>13.1.3 <a href="#section-13.1.3">キャッシュコントロールメカニズム</a></dd>
<dd>13.1.4 <a href="#section-13.1.4">明示的なユーザエージェントの警告</a></dd>
<dd>13.1.5 <a href="#section-13.1.5">規則と警告の例外</a></dd>
<dd>13.1.6 <a href="#section-13.1.6">クライアントにコントロールされた振る舞い</a></dd>
</dl></dd>
<dd><dl>
<dt>13.2 <a href="#section-13.2">期限{Expiration} モデル</a></dt>
<dd>13.2.1 <a href="#section-13.2.1">サーバが指定した期限</a></dd>
<dd>13.2.2 <a href="#section-13.2.2">帰納的有効期限</a></dd>
<dd>13.2.3 <a href="#section-13.2.3">経過時間の計算</a></dd>
<dd>13.2.4 <a href="#section-13.2.4">期限の計算</a></dd>
<dd>13.2.5 <a href="#section-13.2.5">期限値を曖昧にしない事</a></dd>
<dd>13.2.6 <a href="#section-13.2.6">複数のレスポンスを曖昧にしない事</a></dd>
</dl></dd>
<dd><dl>
<dt>13.3 <a href="#section-13.3">検証{Validation} モデル</a></dt>
<dd>13.3.1 <a href="#section-13.3.1">Last-Modified の日付</a></dd>
<dd>13.3.2 <a href="#section-13.3.2">エンティティタグのキャッシュバリディタ</a></dd>
<dd>13.3.3 <a href="#section-13.3.3">弱いバリディタと強いバリディタ</a></dd>
<dd>13.3.4 <a href="#section-13.3.4">エンティティタグや Last-Modified の日付を使う場合の規定</a></dd>
<dd>13.3.5 <a href="#section-13.3.5">非検証条件</a></dd>
</dl></dd>
<dd>13.4 <a href="#section-13.4">レスポンスのキャッシュ可能性</a></dd>
<dd><dl>
<dt>13.5 <a href="#section-13.5">キャッシュから構築したレスポンス</a></dt>
<dd>13.5.1 <a href="#section-13.5.1">エンドトゥエンドヘッダとホップバイホップヘッダ</a></dd>
<dd>13.5.2 <a href="#section-13.5.2">修正できないヘッダ</a></dd>
<dd>13.5.3 <a href="#section-13.5.3">ヘッダの連結</a></dd>
<dd>13.5.4 <a href="#section-13.5.4">バイトレンジの連結</a></dd>
</dl></dd>
<dd>13.6 <a href="#section-13.6">ネゴシエートされたレスポンスのキャッシング</a></dd>
<dd>13.7 <a href="#section-13.7">共有キャッシュと非共有キャッシュ</a></dd>
<dd>13.8 <a href="#section-13.8">エラーや不完全なレスポンスのキャッシュの振る舞い</a></dd>
<dd>13.9 <a href="#section-13.9">GET と HEAD の副作用</a></dd>
<dd>13.10 <a href="#section-13.10">更新や削除後の無効化</a></dd>
<dd>13.11 <a href="#section-13.11">Write-Through の強制</a></dd>
<dd>13.12 <a href="#section-13.12">キャッシュの代替</a></dd>
<dd>13.13 <a href="#section-13.13">履歴表</a></dd>

<dt>14 <a href="#section-14">ヘッダフィールドの定義</a></dt>
<dd>14.1 <a href="#section-14.1">Accept</a></dd>
<dd>14.2 <a href="#section-14.2">Accept-Charset</a></dd>
<dd>14.3 <a href="#section-14.3">Accept-Encoding</a></dd>
<dd>14.4 <a href="#section-14.4">Accept-Language</a></dd>
<dd>14.5 <a href="#section-14.5">Accept-Ranges</a></dd>
<dd>14.6 <a href="#section-14.6">Age</a></dd>
<dd>14.7 <a href="#section-14.7">Allow</a></dd>
<dd>14.8 <a href="#section-14.8">Authorization</a></dd>
<dd><dl>
<dt>14.9 <a href="#section-14.9">Cache-Control</a></dt>
<dd>14.9.1 <a href="#section-14.9.1">キャッシュ可能とは何か</a></dd>
<dd>14.9.2 <a href="#section-14.9.2">キャッシュによって保存されるものは何か</a></dd>
<dd>14.9.3 <a href="#section-14.9.3">基本的な期限のメカニズムの修正</a></dd>
<dd>14.9.4 <a href="#section-14.9.4">キャッシュの再検証とリロードコントロール</a></dd>
<dd>14.9.5 <a href="#section-14.9.5">No-Transform 指示子</a></dd>
<dd>14.9.6 <a href="#section-14.9.6">キャッシュコントロールの拡張</a></dd>
</dl></dd>
<dd>14.10 <a href="#section-14.10">Connection</a></dd>
<dd>14.11 <a href="#section-14.11">Content-Encoding</a></dd>
<dd>14.12 <a href="#section-14.12">Content-Language</a></dd>
<dd>14.13 <a href="#section-14.13">Content-Length</a></dd>
<dd>14.14 <a href="#section-14.14">Content-Location</a></dd>
<dd>14.15 <a href="#section-14.15">Content-MD5</a></dd>
<dd>14.16 <a href="#section-14.16">Content-Range</a></dd>
<dd>14.17 <a href="#section-14.17">Content-Type</a></dd>
<dd><dl>
<dt>14.18 <a href="#section-14.18">Date</a></dt>
<dd>14.18.1 <a href="#section-14.18.1">時計の無いサーバの動作</a></dd>
</dl></dd>
<dd>14.19 <a href="#section-14.19">ETag</a></dd>
<dd>14.20 <a href="#section-14.20">Expect</a></dd>
<dd>14.21 <a href="#section-14.21">Expires</a></dd>
<dd>14.22 <a href="#section-14.22">From</a></dd>
<dd>14.23 <a href="#section-14.23">Host</a></dd>
<dd>14.24 <a href="#section-14.24">If-Match</a></dd>
<dd>14.25 <a href="#section-14.25">If-Modified-Since</a></dd>
<dd>14.26 <a href="#section-14.26">If-None-Match</a></dd>
<dd>14.27 <a href="#section-14.27">If-Range</a></dd>
<dd>14.28 <a href="#section-14.28">If-Unmodified-Since</a></dd>
<dd>14.29 <a href="#section-14.29">Last-Modified</a></dd>
<dd>14.30 <a href="#section-14.30">Location</a></dd>
<dd>14.31 <a href="#section-14.31">Max-Forwards</a></dd>
<dd>14.32 <a href="#section-14.32">Pragma</a></dd>
<dd>14.33 <a href="#section-14.33">Proxy-Authenticate</a></dd>
<dd>14.34 <a href="#section-14.34">Proxy-Authorization</a></dd>
<dd><dl>
<dt>14.35 <a href="#section-14.35">Range</a></dt>
<dd>14.35.1 <a href="#section-14.35.1">バイトレンジ</a></dd>
<dd>14.35.2 <a href="#section-14.35.2">レンジ更新リクエスト</a></dd>
</dl></dd>
<dd>14.36 <a href="#section-14.36">Referer</a></dd>
<dd>14.37 <a href="#section-14.37">Retry-After</a></dd>
<dd>14.38 <a href="#section-14.38">Server</a></dd>
<dd>14.39 <a href="#section-14.39">TE</a></dd>
<dd>14.40 <a href="#section-14.40">Trailer</a></dd>
<dd>14.41 <a href="#section-14.41">Transfer-Encoding</a></dd>
<dd>14.42 <a href="#section-14.42">Upgrade</a></dd>
<dd>14.43 <a href="#section-14.43">User-Agent</a></dd>
<dd>14.44 <a href="#section-14.44">Vary</a></dd>
<dd>14.45 <a href="#section-14.45">Via</a></dd>
<dd>14.46 <a href="#section-14.46">Warning</a></dd>
<dd>14.47 <a href="#section-14.47">WWW-Authenticate</a></dd>

<dt>15 <a href="#section-15">セキュリティについての考察</a></dt>
<dd><dl>
<dt>15.1 <a href="#section-15.1">個人情報</a></dt>
<dd>15.1.1 <a href="#section-15.1.1">サーバログ情報の乱用</a></dd>
<dd>15.1.2 <a href="#section-15.1.2">機密性の高い情報の転送</a></dd>
<dd>15.1.3 <a href="#section-15.1.3">URI での機密性の高い情報のエンコード</a></dd>
<dd>15.1.4 <a href="#section-15.1.4">Accept ヘッダに関連するプライバシーの問題</a></dd>
</dl></dd>
<dd>15.2 <a href="#section-15.2">ファイル名やパス名に基づく攻撃</a></dd>
<dd>15.3 <a href="#section-15.3">DNS スプーフィング</a></dd>
<dd>15.4 <a href="#section-15.4">Location ヘッダとスプーフィング</a></dd>
<dd>15.5 <a href="#section-15.5">Content-Disposition 問題</a></dd>
<dd>15.6 <a href="#section-15.6">認証用証明書{credentials} と無配慮なクライアント</a></dd>
<dd><dl>
<dt>15.7 <a href="#section-15.7">プロクシとキャッシング</a></dt>
<dd>15.7.1<a href="#section-15.7.1">プロクシを使ったサービス拒否攻撃</a></dd>
</dl></dd>

<dt>16 <a href="#section-16">謝辞</a></dt>

<dt>17 <a href="#section-17">参照文献</a></dt>

<dt>18 <a href="#section-18">筆者のアドレス</a></dt>

<dt>19 <a href="#section-19">付録</a></dt>
<dd>19.1 <a href="#section-19.1">インターネットメディアタイプ message/http と application/http</a></dd>
<dd>19.2 <a href="#section-19.2">インターネットメディアタイプ multipart/byteranges</a></dd>
<dd>19.3 <a href="#section-19.3">寛容なアプリケーション</a></dd>
<dd><dl>
<dt>19.4 <a href="#section-19.4">HTTP のエンティティと RFC 2045 のエンティティとの違い</a></dt>
<dd>19.4.1 <a href="#section-19.4.1">MIME-Version</a></dd>
<dd>19.4.2 <a href="#section-19.4.2">公式形式への変換</a></dd>
<dd>19.4.3 <a href="#section-19.4.3">日付フォーマットの変換</a></dd>
<dd>19.4.4 <a href="#section-19.4.4">内容コーディングの導入</a></dd>
<dd>19.4.5 <a href="#section-19.4.5">No Content-Transfer-Encoding</a></dd>
<dd>19.4.6 <a href="#section-19.4.6">転送エンコーディングの導入</a></dd>
<dd>19.4.7 <a href="#section-19.4.7">MHTML と 行末制限</a></dd>
</dl></dd>
<dd><dl>
<dt>19.5 <a href="#section-19.5">追加機能</a></dt>
<dd>19.5.1 <a href="#section-19.5.1">Content-Disposition</a></dd>
</dl></dd>
<dd><dl>
<dt>19.6 <a href="#section-19.6">前バージョンとの互換性</a></dt>
<dd>19.6.1 <a href="#section-19.6.1">HTTP/1.0 からの変更点</a></dd>
<dd>19.6.2 <a href="#section-19.6.2">HTTP/1.0 持続的接続との互換性</a></dd>
<dd>19.6.3 <a href="#section-19.6.3">RFC 2068 からの変更点</a></dd>
</dl></dd>

<dt>20 <a href="#section-20">索引</a></dt>

<dt>21 <a href="#section-21">著作権表示全文</a></dt>

</dl>

<h2 id="section-1">1 導入</h2>

<h3 id="section-1.1">1.1 目的</h3>

<p>
ハイパーテキスト転送プロトコル (HTTP) は、分散・共同体ハイパーメディア情報システムのアプリケーションレベルプロトコルである。
HTTP は、World-Wide Web グローバル情報利用の先進として、1990 年から使われている。
HTTP の最初のバージョンは、HTTP/0.9 と呼ばれ、インターネットを通じて未加工のデータを転送するための単純なプロトコルであった。
HTTP/1.0 は、RFC 1945 <a href="#ref-6">[6]</a> にて定義され、転送されるデータに関する外部情報とリクエスト/レスポンス意味論{semantics} の修飾子を含んだ MIME のようなメッセージ形式のメッセージを付加する事によってプロトコルを改良した。
しかし、HTTP/1.0 ではプロクシやキャッシングの階層構造、持続的接続の必要性、仮想ホストへの考慮が十分になされていなかった。
さらに、実装が不完全なのに自身を &quot;HTTP/1.0&quot; だと称するアプリケーションの増加で、互いの通信アプリケーションが互いに真の能力を決定するために、プロトコルバージョンを変更する必要性が出てきた。
</p>

<p>
この仕様書では、&quot;HTTP/1.1&quot; と呼ばれるプロトコルを定義している。
このプロトコルはそれらの特徴の確実な実装を保証するため HTTP/1.0 よりも厳格な要求を含んでいる。
</p>

<p>
実際の情報システムは、検索、フロントエンドの更新、注釈等を含む、単純なリソースの回収よりもより多くの機能性を必要としている。
HTTP はリクエストの目的を示すためのメソッドやヘッダの open-ended セットを認めている <a href="#ref-47">[47]</a>。
これは、メソッドが適用されるリソースを示すための location (URL) <a href="#ref-4">[4]</a>や name (URN) <a href="#ref-20">[20]</a>としての Uniform Resource Identifier (URI) <a href="#ref-3">[3]</a>によって供給される参照の規律に基づいている。
メッセージは Multipurpose Internet Mail Extensions (MIME) <a href="#ref-7">[7]</a>にて定義される、インターネットメール <a href="#ref-9">[9]</a>により使用されている物に似たフォーマットで渡される。
</p>

<p>
また HTTP は、ユーザエージェントと SMTP <a href="#ref-16">[16]</a>, NNTP <a href="#ref-13">[13]</a>, FTP <a href="#ref-18">[18]</a>, Gopher <a href="#ref-2">[2]</a>, WAIS <a href="#ref-10">[10]</a>プロトコルをサポートするものを含む、別の情報システムのプロクシ/ゲートウェイ間の通信用の、一般的なプロトコルとしても使用される。
これによって、HTTP は様々なアプリケーションから利用できるリソースへの基本的なハイパーメディアアクセスを可能にする。
</p>

<h3 id="section-1.2">1.2 必要条件</h3>

<p>
この文書中における &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, &quot;OPTIONAL&quot; という各キーワードは、RFC 2119 <a href="#ref-34">[34]</a>にて記述されるように解釈される。
</p>

<p>
もし、ある実装が、そのプロトコルの MUST あるいは REQUIRED レベルの要求の一つ以上を満足できないのならば、その実装は従順なものではない。
もし、ある実装がそのプロトコルのすべての MUST あるいは REQUIRED レベルと、すべての SHOULD レベルの要求を満足していれば、その実装は &quot;無条件に従順&quot; と呼ぶ。
そして、すべての MUST レベルの要求は満たしているが、一つでも SHOULD 要求を満たしていないものは &quot;条件付きで従順&quot; と呼ばれる。
</p>

<h3 id="section-1.3">1.3 専門用語</h3>

<p>
この仕様書では、HTTP 通信に参加する人間、あるいは物を参照するための専門用語をいくつか使用する。
</p>

<dl>

<dt>コネクション {connection}</dt>
<dd>
通信の目的で二つのプログラム間に確立されるトランスポート層の仮想通信路。
</dd>

<dt>メッセージ {message}</dt>
<dd>
section <a href="#section-4">4</a> にて定義される構文を持ち構造化されたオクテットシーケンスから成り、接続を介して転送される、HTTP 通信での基本単位。
</dd>

<dt>リクエスト {request}</dt>
<dd>
section <a href="#section-5">5</a> にあるような、HTTP リクエストメッセージ。
</dd>

<dt>レスポンス {response}</dt>
<dd>
section <a href="#section-6">6</a> にあるような、HTTP レスポンスメッセージ。
</dd>

<dt>リソース {resource}</dt>
<dd>
section <a href="#section-3.2">3.2</a> にて定義されるような、URI によって判別されるネットワークデータオブジェクト、あるいはサービス。
リソースは複数の表現 (例えば、複数の言語、データフォーマット、サイズ、解像度等) で利用したり、別の方法で変更したりできる。
</dd>

<dt>エンティティ {entity}</dt>
<dd>
リクエストやレスポンスの付加物{payload} として転送される情報。
エンティティは、section <a href="#section-7">7</a> で記述されるように、エンティティヘッダフィールドという形での外部情報と、エンティティボディという形での内容から成る。
</dd>

<dt>表現 {representation}</dt>
<dd>
section <a href="#section-12">12</a> にて記述されているような内容ネゴシエーションに従ったレスポンスを含むエンティティ。特定のレスポンスステータスには、関連する複数の表現が存在する事がある。
</dd>

<dt>内容ネゴシエーション {content negotiation}</dt>
<dd>
section <a href="#section-12">12</a> で記述されているように、リクエストを処理する時、適切な表現を選択するためのメカニズム。
エラーレスポンスも含めた、どんなレスポンスにおいてもエンティティの表現はサーバと交渉 {negotiate} される。
</dd>

<dt>バリアント {variant}</dt>
<dd>
リソースはどの瞬間においても一つ、あるいは一つ以上、それに関連付けられた表現を持っている。
それらの表現のそれぞれを `バリアント' と呼ぶ。
`バリアント' という語の使用が、そのリソースが内容ネゴシエーションされているという事を意図するわけではない。
</dd>

<dt>クライアント {client}</dt>
<dd>
リクエストを送信する目的でコネクションを確立するプログラム。
</dd>

<dt>ユーザエージェント {user agent}</dt>
<dd>
リクエストを発行するクライアント。
これらはしばしば、ブラウザ、エディタ、スパイダ (web ロボット)、あるいはその他のエンドユーザツールである。
</dd>

<dt>サーバ {server}</dt>
<dd>
レスポンスを送り返す事で、リクエストを処理するためのコネクションを受け入れるようなアプリケーションプログラム。
プログラムの中にはクライアントとサーバの両方の機能を持つものがある; しかし、ここではこの用語を、一般的なプログラムの機能というよりむしろ、特定のコネクションについてプログラムによって果たされる役割のみのために使用する。
同様に、各リクエストの性質に応じてその振る舞いを、オリジンサーバ、プロクシ、ゲートウェイ、トンネルと切り換えるサーバもある。
</dd>

<dt>オリジンサーバ {origin server}</dt>
<dd>
指定されるリソースが存在するか、あるいは生成されるサーバ。
</dd>

<dt>プロクシ {proxy}</dt>
<dd>
他のクライアントの代わりとしてリクエストを行うためにサーバとクライアントの両方の役割を果たす中継プログラム。
リクエストは、可能な変換をもって、内部で処理されるか、あるいは他のサーバに渡される。
プロクシは、この仕様書が要求するクライアントとサーバの両方の機能を実装し<em>なければならない</em>。
&quot;透過的プロクシ&quot; とは、プロクシへの認証やクライアント自身の証明が要求されるようなもの以外のリクエストやレスポンスを修正しないようなプロクシである。
&quot;透過的でないプロクシ&quot; とは、ユーザエージェントに、ある種の翻訳、メディアタイプの変形、使用プロトコルの制限、匿名性向上のためのフィルタリング等のような、追加的サービスを提供するためにリクエストやレスポンスを修正するようなプロクシである。
その振る舞いが透過的であるか無いかが明言されている部分を除けば、それぞれのプロクシは HTTP プロクシとして必要な要素を共に持ち合わせている。
</dd>

<dt>ゲートウェイ {gateway}</dt>
<dd>
他のサーバを中継するサーバ。
プロクシとは違い、ゲートウェイはまるでリクエストされたリソースのオリジンサーバのように、リクエストを受ける。
リクエストしたクライアントは、それをゲートウェイと通信しているという事を気付かないかもしれない。
</dd>

<dt>トンネル {tunnel}</dt>
<dd>
二つの接続の間をまるで目隠しリレーを行う様に振る舞う中継プログラム。
一度起動したら、それが HTTP リクエストによるものであっても、トンネル自身は HTTP 通信における当事者とみなさない。
トンネルは中継する両端の通信が終了した時、終了する。
</dd>

<dt>キャッシュ {cache}</dt>
<dd>
プログラムがレスポンスメッセージをローカルに記録しておく場所であり、それらメッセージの保存、検索、削除を管理するサブシステムを指す。
キャッシュは、同様のリクエストが起きた際にレスポンス時間やネットワーク帯域幅の消費の軽減のために、キャッシュ可能なレスポンスを保存する。
どのようなクライアントもサーバもキャッシュを持つ事は出来るが、トンネルとして振る舞っているサーバはキャッシュを使用できない。
</dd>

<dt>キャッシュ可能 {cacheable}</dt>
<dd>
レスポンスは、もしキャッシュが後続のリクエストに答えるという目的での使用のために、レスポンスメッセージのコピーを保存する事が許されるならばキャッシュ可能であるという。
HTTP レスポンスのキャッシュ使用の決定の決まりは section 13 にて定義されている。
例えリソースがキャッシュ可能でも、キャッシュは特定のリクエストのためにキャッシュされたコピーを使うかどうかについて制限を受ける可能性がある。
</dd>

<dt>ファーストハンド {first-hand}</dt>
<dd>
レスポンスが、オリジンサーバ、あるいは一つ以上経由したプロクシから不必要な遅れ無しに届くならば、それをファーストハンドであるという。
また、オリジンサーバで有効性を直接チェックされたレスポンスもファーストハンドであるという。
</dd>

<dt>明示的有効期限 {explicit expiration time}</dt>
<dd>
オリジンサーバが、エンティティの有効性の再確認無しにキャッシュを返すべきではないとしている時刻。
</dd>

<dt>帰納的有効期限 {heuristic expiration time}</dt>
<dd>
有効期限が指定されていない時に、キャッシュによって指定される有効期限。
</dd>

<dt>経過時間 {age}</dt>
<dd>
レスポンスの経過時間とは、それがオリジンサーバから送られてから、あるいはオリジンサーバによって十分に有効性が確認された時からの時間を指す。
</dd>

<dt>有効期間 {freshness lifetime}</dt>
<dd>
レスポンスが生成されてから有効期限までの時間の長さ。
</dd>

<dt>新鮮である {fresh}</dt>
<dd>
その経過時間がその有効期間を経過していなければ、レスポンスは新鮮であるという。
</dd>

<dt>新鮮でない {stale}</dt>
<dd>
その経過時間がその有効期間を経過していなければ、レスポンスは新鮮であるという。
</dd>

<dt>意味的に透過である {semantically transparent}</dt>
<dd>
キャッシュは、パフォーマンスの向上以外に、リクエストしたクライアントにもオリジンサーバにも影響が無い時、特定のレスポンス関して、意味的に透過な方法で振る舞う。
キャッシュが意味的に透過な時、クライアントはオリジンサーバから直接処理された時に受け取るであろうリクエストと全く同じレスポンスを受け取る。(ホップバイホップヘッダを除く)
</dd>

<dt>バリディタ {validator}</dt>
<dd>
キャッシュ内にあるリソースが、エンティティのコピーと同等かどうかがわかるとされている (例えば、エンティティタグや <span class="Header">Last-Modified</span> 時刻等の) プロトコルエレメント。
</dd>

<dt>アップストリーム/ダウンストリーム {upstream/downstream}</dt>
<dd>
アップストリームとダウンストリームとは、メッセージの流れを表す。
すべてのメッセージは、上流{upstream} から下流{downstream} へと流れる。
</dd>

<dt>インバウンド/アウトバウンド {inbound/outbound}</dt>
<dd>
インバウンドとアウトバウンドは、メッセージを送るためのリクエストとレスポンスの道のりに従う。
&quot;インバウンド&quot; とは &quot;オリジンサーバに向かって行く事&quot; を、&quot;アウトバウンド&quot; とは &quot;ユーザエージェントに向かって行く事&quot; を、それぞれ意味する。
</dd>

</dl>

<h3 id="section-1.4">1.4 全体の動作</h3>

<p>
HTTP プロトコルはリクエスト/レスポンスプロトコルである。
クライアントは、サーバへの接続上で、リクエストメソッド、URI、そしてプロトコルバージョン、その後にリクエスト修飾子、クライアント情報、可能であれば内容本体を含んだ MIME のようなメッセージ形式をサーバにリクエストとして送る。
サーバは、メッセージのプロトコルバージョンと成功か失敗を表すコードを含むステータス行に続き、サーバ情報、エンティティメタ情報、可能であればエンティティボディの内容を含む MIME のようなメッセージで応答する。
HTTP と MIME の関係は、付録 <a href="#section-19.4">19.4</a> に記述されている。
</p>

<p>
多くの HTTP 接続は、ユーザエージェントによって開始され、あるオリジン
サーバ上のリソースに適用するためのリクエストから成り立つ。この最も簡
単な場合、ユーザエージェント (UA) とオリジンサーバ (O) との間の単一接
続経由 (v) で成し遂げられるだろう。
</p>

<pre>    request chain ------------------------&gt;
 UA -------------------v------------------- O
    &lt;----------------------- response chain
</pre>

<p>
リクエスト/レスポンス連鎖中に一つ以上の中継者が現れると、状況はより複雑になる。
一般的な中継者には、プロクシ、ゲートウェイ、トンネルの三つが存在する。
プロクシは、その絶対形式の URI のリクエストを受け取り、メッセージのすべてもしくは一部を書き換え、URI によって識別されるサーバに再フォーマットされたリクエストを転送する転送エージェントである。
ゲートウェイは、ある別のサーバ (群) の上の層として動作し、もし必要ならリクエストを根底にあるサーバのプロトコルに変換するための受信エージェントである。
トンネルは、メッセージを変更する事なく二つの接続間の中継点として動作する。
トンネルは通信が (ファイアウォールのような) 中継者を通して伝えられる必要がある時、さらに中継者がメッセージの内容を理解できない時に使用される。
</p>

<pre>    request chain --------------------------------------&gt;
 UA -----v----- A -----v----- B -----v----- C -----v----- O
    &lt;------------------------------------- response chain
</pre>

<p>
上図は、ユーザエージェントとオリジンサーバの間の三中継者 (A, B, C) を表している。
リクエストやレスポンスのメッセージが移動する全体の連鎖は四つに分ける事ができるであろう。
HTTP 通信オプションによっては、適用できる範囲が、隣の接続にのみだったり、トンネルではない隣接接続だったり、連鎖の終末のみだったり、あるいは連鎖上のすべての接続に適用できたりするので、この区別は重要である。
図形では線形であるが、それぞれが複数に、また同時に通信を行う事ができる。例えば、B は A からのリクエストを処理すると同時に、A 以外の多くのクライアントからリクエストを受信しているかもしれないし、あるいは C 以外のサーバにリクエストを転送しているかもしれない。
</p>

<p>
トンネルとして動作していない通信のすべてのパーティは、内部的なキャッシュやリクエスト処理に使用できる。
キャッシュの効果とは、もし連鎖上に連なるある一つがそのリクエストに適用できるキャッシュされたレスポンスを持っているなら、リクエスト/レスポンス連鎖を短縮する事である。
以下では、もし B が、UA や A がキャッシュしていないリクエストに対する O からの (C を経由した) 以前のレスポンスのキャッシュされたコピーを持っている場合の結果となる連鎖を説明している。
</p>

<pre>    request chain ----------&gt;
 UA -----v----- A -----v----- B - - - - - - C - - - - - - O
    &lt;--------- response chain
</pre>

<p>
すべてのレスポンスがキャッシュ可能であるわけではなく、いくつかのリクエストではキャッシュの動作への特別な要求を行う修飾子を含む事ができる。
キャッシュの動作やキャッシュ可能なレスポンスに対する HTTP の要求は section <a href="#section-13">13</a> で定義されている。
</p>

<p>
事実、現在 World Wide Web 上にて実験され、設置されているキャッシュとプロクシには幅広い種類のアーキテクチャやコンフィギュレーションがある。
これらのシステムには、海を渡るような通信{transoceanic} のバンド幅を節約するためにプロクシキャッシュを全国的な組織が階層的に管理するもの{national hierarchies} や、エントリしているキャッシュを放送するためのシステムや、CD-ROM を使ってキャッシュされたデータのサブセットを配布する組織等も含む。
HTTP システムは、高バンド幅通信上の社内イントラネットでも、そして非力なラジオ通信や断続的な接続を使う PDA 経由でアクセスするためにも使用される。
HTTP/1.1 が目指すものは、高い信頼性と、もし失敗するとしても少なくとも確実な徴候が要求されるウェブアプリケーションを作る人間のニーズに合ったプロトコル構造を取り入れていく一方で、既に設置されている幅広い多様なコンフィギュレーションをサポートする事である。
</p>

<p>
HTTP 通信は、普通 TCP/IP 接続上で行う。
既定ポートは TCP 80 であるが、他のポートを使用する事もできる <a href="#ref-19">[19]</a>。
これは、インターネットや他のネットワーク上の別のプロトコルの最上部として、HTTP を実装する事を排除しない。
HTTP は確実な転送のみを前提し、そのような保証を供給するどんなプロトコルでも使用できる。
問題においてプロトコルのデータ転送ユニット上の HTTP/1.1 リクエストとレスポンス構造のマッピングはこの仕様書の範疇を超える。
</p>

<p>
HTTP/1.0 では、ほとんどの実装はそれぞれのリクエスト/レスポンスを交換するために新しい接続を使用していた。
HTTP/1.1 では、接続は一つ以上のリクエスト/レスポンス交換に使用できるが、レスポンスの種類によっては接続が切断されるかもしれない (section <a href="#section-8.1">8.1</a> 参照)。
</p>

<h2 id="section-2">2 表記の慣習と一般文法</h2>

<h3 id="section-2.1">2.1 拡張 BNF</h3>

<p>
この文書において詳述されるメカニズムのすべては、単調 Backus-Naur Form (BNF) と、RFC 822 <a href="#ref-9">[9]</a> で使用されているものに似た拡張 BNF との両方で記述されている。
実装者は、この仕様書を理解するためにこの表記法に精通している必要があるだろう。
拡張 BNF は以下の構造を含んでいる。
</p>

<dl>
<dt>name = definition</dt>
<dd>
name とは、(&quot;&lt;&quot; と &quot;&gt;&quot;で囲まれているものを除き) 単純にそれ自身の名前であり、その定義とは等号 &quot;=&quot; 文字によって分割されている。
空白は、二行以上に渡る規定の定義を示すために使われる連続行の行頭空白においてのみ意味を持つ。
特定の基本的な規定は SP, LWS, HT, CRLF, DIGIT, ALPHA 等のように大文字である。
角括弧は、それらの存在が規定名の使用の理解を容易にするであろうときに定義の中に使用される。
</dd>

<dt>&quot;literal&quot;</dt>
<dd>
クォーテーション記号はリテラルテキストを囲む。
もし特に明言されなければ、テキストは大文字・小文字を区別しない。
</dd>

<dt>rule1 | rule2</dt>
<dd>
バー (&quot;|&quot;) で区切られた要素は二者択一である。例えば &quot;yes | no&quot; は
yes か no を受け入れるだろう。
</dd>

<dt>(rule1 rule2)</dt>
<dd>
括弧で囲まれた要素は単一の要素として扱われる。
従って、&quot;(elem (foo | bar) elem)&quot; は、トークンシーケンス &quot;elem foo elem&quot; と &quot;elem bar elem&quot; を認める。
</dd>

<dt>*rule</dt>
<dd>
要素の前にある &quot;*&quot; 文字は繰り返しを意味する。
完全な形式は &quot;&lt;n&gt;*&lt;m&gt;element&quot; で、これは element 出現が最低&lt;n&gt;、最大&lt;m&gt;である事を示している。
既定値は 0 と無限なので、&quot;*(element)&quot; はゼロを含むどんな回数も可能であり、&quot;1*element&quot; は最低一つ、&quot;1*2element&quot; は一つか二つが可能である。
</dd>

<dt>[rule]</dt>
<dd>
角括弧は省略可能な要素を囲む。
すなわち、&quot;[foo bar]&quot; は &quot;*1(foo bar)&quot; と同等である。
</dd>

<dt>N rule</dt>
<dd>
具体的な繰り返し。
&quot;&lt;n&gt;(element)&quot; は &quot;&lt;n&gt;*&lt;n&gt;(element)&quot; と同等である。
これは、(element) の出現が確実に &lt;n&gt; 存在する。
従って 2DIGIT は二文字の数字であり、3ALPHA は三文字のアルファベット文字の文字列である。
</dd>

<dt>#rule</dt>
<dd>
&quot;#&quot; 構造は、&quot;*&quot; と似て、要素のリストを定義するために定義されている。
完全な形式は &quot;&lt;n&gt;#&lt;m&gt;element&quot; で、これは element が最低 &lt;n&gt;、最大 &lt;m&gt; の存在を示していて、それぞれは一つ以上のコンマ（&quot;,&quot;）と<em>省略可能な</em>連続空白（LWS）で区切られる。
これによって、通常のリスト形式をとても簡単にできる。例えば、<br />
 <samp>( *LWS element *( *LWS &quot;,&quot; *LWS element ))</samp><br />
という規定は<br />
 <samp>1#element</samp><br />
として表す事ができる。
この構造が使用されているどこでも、null 要素が許されるが、存在する要素の数に影響しない。
つまり、&quot;(element),, (element)&quot; は許されるが、二つの要素として数えられる。
それゆえに、最低一つの要素が必要な所では、最低一つの null でない要素が与えられ<em>なければならない</em>。
既定値は 0 と無限であるので、&quot;#element&quot; はゼロを含むどんな数も認め、&quot;1#element&quot; は最低一つを必要とし、&quot;1#2element&quot; は一つか二つを認めている。
</dd>

<dt>; comment</dt>
<dd>
規定文の右からいくらか距離を置いて始まるセミコロンは、行末まで続くコメントの始まりである。
これは、この仕様書と共に有益な記述を含めるための簡単な方法である。
</dd>

<dt>黙示的 *LWS</dt>
<dd>
この仕様書によって記述される文法は、単語に基づいている。その他の方法で明記していなければ、連続した空白(LWS) は、フィールドの解釈を変える事無く、二つの隣接した言葉 (トークンや引用符で囲まれた文字列) の間や隣接したトークンとデリミタ (LWS かセパレータ) の間に含む事ができる。
二つのトークンの間には、最低一つのデリミタ (LWS かセパレータ) が、それらが単一のトークンとして解釈されないように存在し<em>なければならない</em>。
</dd>
</dl>

<h3 id="section-2.2">2.2 基本的な規定</h3>

<p>
以下の規定は、基本的な構造概念を記述するためにこの仕様書全体に渡って使用される。
文字セットとしてコード化された US-ASCII は ANSI X3.4-1986 <a href="#ref-21">[21]</a> にて定義されている。
</p>

<pre> OCTET           = &lt;8-bit のデータシーケンス&gt;
 CHAR            = &lt;US-ASCII 文字 (0 - 127 オクテット)&gt;
 UPALPHA         = &lt;US-ASCII 大文字 &quot;A&quot;..&quot;Z&quot;&gt;
 LOALPHA         = &lt;US-ASCII 小文字 &quot;a&quot;..&quot;z&quot;&gt;
 ALPHA           = UPALPHA | LOALPHA
 DIGIT           = &lt;US-ASCII 数字 &quot;0&quot;..&quot;9&quot;&gt;
 CTL             = &lt;US-ASCII 制御文字
                   (0 - 31 オクテット) と DEL (127)&gt;
 CR              = &lt;US-ASCII CR, キャリッジリターン (13)&gt;
 LF              = &lt;US-ASCII LF, ラインフィード (10)&gt;
 SP              = &lt;US-ASCII SP, スペース (32)&gt;
 HT              = &lt;US-ASCII HT, 水平タブ (9)&gt;
 &lt;&quot;&gt;             = &lt;US-ASCII ダブルクォート記号 (34)&gt;
</pre>

<p>
HTTP/1.1 は、エンティティボディ以外のすべてのプロトコル要素のための行末の印として CR LF というシーケンスを定義している (寛容なアプリケーションのためには、付録 section <a href="#section-19.3">19.3</a> 参照)。
エンティティボディ内の行末の印は、section <a href="#section-3.7">3.7</a> で記述されているように、その関連するメディアタイプによって定義される。
</p>

<pre> CRLF           = CR LF
</pre>

<p>
HTTP/1.1 ヘッダフィールドの値は、もし続く行が空白か水平タブで始まっているならば複数行にまたがって折り返す事ができる。
すべての連続空白は、折り返しているものを含め、SP と同じ意味を持つ。
受信者は、フィールドの値を解釈したり、メッセージを下層{downstream} に流す前に、すべての連続空白を１つの SP に置きかえた方が<em>よい</em> 。
</p>

<pre> LWS            = [CRLF] 1*( SP | HT )
</pre>

<p>
TEXT 規定は、メッセージパーサによって解釈される事を望まないフィールドの内容と値の説明にのみ使用される。
*TEXT の言葉は、RFC 2047 <a href="#ref-14">[14]</a> の規定に従ってエンコードされた時にのみ、ISO-8859-1 <a href="#ref-22">[22]</a> 以外の文字セットの文字を含む事が<em>できる</em> 。
</p>

<pre> TEXT           = &lt;CTL を除き、LWS を含むすべての OCTET&gt;
</pre>

<p>
CRLF は、ヘッダフィールドの連続行の一部として使う時のみ、TEXT の定義に含まれる。
折り返し LWS は TEXT の値を解釈する前に１つの SP に置きかえるであろう事が予想される。
</p>

<p>
16 進数文字は様々なプロトコル要素において使用される。
</p>

<pre> HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT
</pre>

<p>
多くの HTTP/1.1 ヘッダフィールドの値は、LWS か特別な文字によって区切られた言葉から成る。
これらの特別な文字がパラメータ値内で使用されるためには (section <a href="#section-3.6">3.6</a> で定義される様に) 引用された文字列内に存在し<em>なければならない</em>。
</p>

<pre> token          = 1*&lt;CTL や separators を除いたあらゆる CHAR&gt;
 separators     = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;
                | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;
                | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                | &quot;{&quot; | &quot;}&quot; | SP | HT
</pre>

<p>
コメントは、いくつかの HTTP ヘッダ内でコメント文字を括弧で囲む事により含む事ができる。
コメントは、それらのフィールド値定義の一部として &quot;comment&quot; を含んでいるフィールドにおいてのみ許される。
その他のすべてのフィールドにおいては、括弧はフィールド値の一部とみなされる。
</p>

<pre> comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
 ctext          = &lt;&quot;(&quot; と &quot;)&quot; を除いたあらゆる TEXT&gt;
</pre>

<p>
テキストの文字列は、ダブルクォート記号を使って引用されているなら、単一の言葉として解析される。
</p>

<pre> quoted-string  = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )
 qdtext         = &lt;&lt;&quot;&gt; を除いたあらゆる TEXT&gt;
</pre>

<p>
バックスラッシュ文字 (&quot;\&quot;) は、quoted-string と comment 構造内でのみ単一文字引用メカニズムとして使用する事が<em>できる</em>。
</p>

<pre> quoted-pair    = &quot;\&quot; CHAR</pre>

<h2 id="section-3">3 プロトコルパラメータ</h2>

<h3 id="section-3.1">3.1 HTTP のバージョン</h3>

<p>
HTTP では、プロトコルのバージョンを示すために &quot;&lt;メジャーバージョン&gt;.&lt;マイナーバージョン&gt;&quot; と番号づける。プロトコルバージョンのつけ方の方針としては、その通信で得られたものの特徴を伝えるというよりも、送信者がメッセージのフォーマットや将来的な HTTP 通信においての理解能力を表すために使わせようとするものである。
通信の振る舞いが影響を受けないメッセージの構成要素が追加されたり、拡張可能なフィールドの値が追加されるような場合ではバージョン番号は変更されない。
&lt;マイナー&gt; バージョンは、その変更が、一般的なメッセージ解析アルゴリズムを変えるものではないが、メッセージ意味論を付け加え、送信者の機能に追加があった事を意図する時に、上がる。
&lt;メジャー&gt; バージョンは、プロトコル内のメッセージのフォーマットが変更される時に、上がる。完全なる解説を必要とする場合は RFC 2145 <a href="#ref-36">[36]</a> 参照。
</p>

<p>
HTTP メッセージのバージョンは、メッセージの最初の行の HTTP-Version フィールドで示される。
</p>

<pre> HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT
</pre>

<p>
メジャー番号とマイナー番号は、分割された整数値として扱われ<em>なければならない</em> ので、メジャー番号とマイナー番号はそれぞれ一桁以上に増やしても<em>よい</em>という事に注意せよ。
従って、HTTP/2.4 は HTTP/2.13 よりも下のバージョンで、さらにそれらは HTTP/12.3 よりも下となる。
先行するゼロは受け取り側によって無視され<em>なければならない</em>し、また送られ<em>てはならない</em>。
</p>

<p>
&quot;HTTP/1.1&quot; という HTTP-Version を含むリクエストやレスポンスメッセージを送るアプリケーションは、少なくとも条件付きでこの仕様書に準じてい<em>なければならない</em>。
少なくとも条件付きでこの仕様書に準じているアプリケーションならば、送信するメッセージに &quot;HTTP/1.1&quot; という HTTP-Version を含める<em>べきであり</em>、HTTP/1.0 と互換性の無い全てのメッセージには、必ず含め<em>なければならない</em>。
特定の HTTP-Version を送る時についての詳細は、RFC 2145 <a href="#ref-36">[36]</a> 参照。
</p>

<p>
アプリケーションの HTTP バージョンとは、そのアプリケーションが少なくとも条件付きで準じている最も高い HTTP バージョンの事である。
</p>

<p>
プロクシやゲートウェイなどのアプリケーションは、プロトコルにおけるアプリケーションのバージョンの違うメッセージを転送する時に注意する必要がある。
プロトコルバージョンは送り手のプロトコル能力を示すので、プロクシ/ゲートウェイは、決して自身の実際のバージョンよりも大きなバージョン指標が付いたメッセージを送っ<em>てはならない</em>。
もし、より高いバージョンのリクエストを受けたならば、プロクシ/ゲートウェイはリクエストのバージョンを下げるか、エラーを返すか、トンネル動作にスイッチするかのいずれかを行わ<em>なければならない</em>。
</p>

<p>
RFC 2068 <a href="#ref-33">[33]</a> の発行以降に HTTP/1.0 プロクシの通信上の問題が発見された事を受けて、キャッシュするプロクシは、必ずサポートする最新のバージョンにアップグレードし<em>なければならない</em>。
ゲートウェイは、可能であればアップグレードしても<em>よい</em>。
またトンネルは、アップグレードし<em>てはならない</em>。
そのリクエストのプロクシ/ゲートウェイのレスポンスは、リクエストと同じメジャーバージョンでなければならない。
</p>

<p class="note">
注: HTTP のバージョン間の変換は、含まれるバージョンによって要求される、あるいは禁止されるヘッダフィールドの修正を含んでいてもよい。
</p>

<h3 id="section-3.2">3.2 Uniform Resource Identifiers</h3>

<p>
URIとは、既に多くの名前で、例えば WWW address, Universal Document Identifier, Universal Resource Identifier <a href="#ref-3">[3]</a>, そして、最終的に Universal Resource Locator (URL) <a href="#ref-4">[4]</a> と Name (URN) <a href="#ref-20">[20]</a> という名で知られている。
HTTP に限って言えば、Uniform Resource Identifier とはリソースを名前や場所、その他の特徴で識別する簡潔に書式化された文字列の事である。
</p>

<h4 id="section-3.2.1">3.2.1 一般構文</h4>

<p>
HTTP における URI は、絶対形式か、それが使われている状況に依存する、ある既知の基底 URI <a href="#ref-11">[11]</a> からの相対形式で表される。
この二つの形式は、絶対 URI は常にコロンを後に持つスキーム名から開始しているという事から区別される。
URL 構文や意味論の定義についての情報については、(RFC 1738 <a href="#ref-4">[4]</a> と RFC 1808 <a href="#ref-11">[11]</a> を置き換えた) &quot;Uniform Resource Identifiers (URI): Generic Syntax and Semantics,&quot; RFC 2396 <a href="#ref-42">[42]</a> を参照。
この規格書では、その規格書にある、&quot;URI-reference&quot;, &quot;absoluteURI&quot;, &quot;relativeURI&quot;, &quot;port&quot;, &quot;host&quot;, &quot;abs_path&quot;, &quot;rel_path&quot;, &quot;authority&quot; の定義を採用する。
</p>

<p>
HTTP プロトコルでは、URI の長さにどんな制限も設けていない。
サーバは、自身が持つどんなリソースの URI も扱え<em>なければならない</em>し、もしそのような URI を生成する GET ベースのフォームを用意するなら、無制限の長さの URI を扱える<em>べきである</em>。
もし、その URI がサーバが処理できるものよりも長ければ、サーバは 414 (Request-URI Too Long) ステータスを返す<em>べきである</em> (section <a href="#section-10.4.15">10.4.15</a> 参照)。
</p>

<p class="note">
注: いくつかの古いクライアントやプロクシ実装は 255 バイトを超える長さを持つ URI を適切にサポートしていないかもしれないので、サーバはそのような URI に頼る場合は注意を払うべきである。
</p>

<h4 id="section-3.2.2">3.2.2 http URL</h4>

<p>
&quot;http&quot; スキームは HTTP プロトコル経由でネットワークリソースの位置を指すために使われる。
この節では http URL について、スキーム特有の構文と意味論を定義する。
</p>

<pre> http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]
</pre>

<p>
もし、port が空かあるいは与えられていなければ、ポート 80 が仮定される。
その意味論は、識別されるリソースはそのホストのそのポートで TCP 接続のためのリスニングをしているサーバ上にあり、リソースに対する Request-URI は、abs_path である (section <a href="#section-5.1.2">5.1.2</a>)。
できれば、URL での IP アドレスの使用は避ける<em>べきである</em> (RFC 1900 <a href="#ref-24">[24]</a> 参照)。
もし、abs_path が URL で与えられていなければ、そのリソースへの Request-URI として使われる時に、&quot;/&quot; が与えられなければならない (section <a href="#section-5.1.2">5.1.2</a>)。
もし、プロクシが fully qualified domain name ではない ホストネームを受けとったならば、プロクシは自分のドメインにそのホストネームを追加する事が<em>できる</em>。
もし、プロクシが fully qualified domain name を受けとったならば、プロクシは絶対にホストネームを書き換え<em>てはならない</em>。
</p>

<h4 id="section-3.2.3">3.2.3 URI の比較</h4>

<p>
二つの URI が一致しているかどうかを決めるために比較する時、クライアントは URI 全体で大文字・小文字を区別したオクテット同士の比較をす<em>べきである</em>が、以下は例外とする。
</p>

<ul>
<li>ポートが空、あるいは与えられていない場合は、その URI の既定ポートと等価である。</li>
<li>ホスト名の比較は、大文字・小文字を区別し<em>てはならない</em>。</li>
<li>スキーム名の比較は、大文字・小文字を区別し<em>てはならない</em>。</li>
<li>空の abs_path は、&quot;/&quot; の abs_path と等価である。</li>
</ul>

<p>
&quot;reserved&quot; あるいは &quot;unsafe&quot; セット (RFC 2396 <a href="#ref-42">[42]</a> 参照) 以外の全ての文字は、それらを &quot;&quot;%&quot; HEX HEX&quot; エンコーディングしたものと等しい。 (※)
</p>

<p class="note">
(※訳注) &quot;unsafe&quot; セットは、RFC 2396 中には存在しない。
</p>

<p>
例えば、以下の三つの URI は等価である。
</p>

<pre><samp> http://abc.com:80/~smith/home.html
 http://ABC.com/%7Esmith/home.html
 http://ABC.com:/%7esmith/home.html</samp>
</pre>

<h3 id="section-3.3">3.3 日付/時刻フォーマット</h3>

<h4 id="section-3.3.1">3.3.1 完全な日付</h4>

<p>
HTTP アプリケーションは、歴史的に日付/時刻スタンプの表現のために三つの異なるフォーマットが許されている。
</p>

<pre> Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
 Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
 Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
</pre>

<p>
最初のフォーマットはインターネット標準としてより好まれ、RFC 1123 <a href="#ref-8">[8]</a> (RFC 822 <a href="#ref-9">[9]</a> の改定) にて定義される固定長サブセットを表す。
第二のフォーマットは一般的に使用されているが、既に使用されていない{obsolete} な RFC 850 <a href="#ref-12">[12]</a> 日付フォーマットに基づいており、四桁年号が欠落している。
日付の値を解析する HTTP/1.1 クライアントとサーバは (HTTP/1.0 との互換性のために) 三つすべてのフォーマットを受け入れ<em>なければならない</em>が、ヘッダフィールドにおいて HTTP-date 値を表す時は RFC 1123 フォーマットのみを生成し<em>なければならない</em>。
更なる情報については、section <a href="#section-19.3">19.3</a> 参照。
</p>

<p class="note">
注: 日付の値の受取人は、時々 SMTP や NNTP のプロクシ/ゲートウェイを経由してメッセージが回収されたり送信されたりするような場合の時に、非 HTTP アプリケーションによって送られるであろう日付の値を受け入れる程に強固である事が推奨される。
</p>

<p>
全ての HTTP 日付/時刻スタンプは、例外なくグリニッジ標準時刻 (GMT) で表され<em>なければならない</em>。
HTTP の用途では、GMT は UTC (Coordinated Universal Time) と正確に一致する。
これは、タイムゾーンを表す三文字略として &quot;GMT&quot; の含める事によって最初の二つのフォーマットの中で示され、asctime フォーマットを解釈する時には仮定され<em>なければならない</em>。
HTTP-date は大文字・小文字を区別するが、文法書中の SP のように、含まれる特定のもの以上の追加的 LWS を含んでは<em>ならない</em>。
</p>

<pre> HTTP-date    = rfc1123-date | rfc850-date | asctime-date
 rfc1123-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
 rfc850-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
 asctime-date = wkday SP date3 SP time SP 4DIGIT
 date1        = 2DIGIT SP month SP 4DIGIT
                ; day month year (e.g., 02 Jun 1982)
 date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                ; day-month-year (e.g., 02-Jun-82)
 date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                ; month day (e.g., Jun  2)
 time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                ; 00:00:00 - 23:59:59
 wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
              | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
 weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
              | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;
 month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
              | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
              | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;
</pre>

<p class="note">
注: この日付/時刻スタンプフォーマットの HTTP 的要求は、プロトコルストリーム内での使用にのみ適用される。
クライアントやサーバは、これらのフォーマットをユーザ提示やログイン要求などのために使用する必要はない。
</p>

<h4 id="section-3.3.2">3.3.2 秒差</h4>

<p>
ある HTTP ヘッダフィールドでは、メッセージが受信されてからの時間を、10 進数で表される整数の秒数値で、表す事が出来る。
</p>

<pre> delta-seconds  = 1*DIGIT
</pre>

<h3 id="section-3.4">3.4 文字セット</h3>

<p>
HTTP では、&quot;文字セット&quot; という用語を MIME で表現される場合と同じ定義で使用する。
</p>

<p>
この文書中では &quot;文字セット&quot; という用語を、一つ以上のテーブルを使ってオクテットシーケンスを文字シーケンスに変換するための方法を述べるために使う。
与えられた文字セットですべての文字が利用できるわけではなかったり、文字セットがある特定の文字を表すために二つ以上のオクテットシーケンスを供給する場合でも、別の指示による無条件な変換が必要でないは事に注意せよ。
この定義は、US-ASCII のような簡単な単一テーブルマッピングから、ISO-2022 の技術を使うような複雑なテーブルをスイッチする
方法まで、さまざまな種類の文字エンコーディングを認めようとするものである。
しかし、MIME 文字セット名に関係付けられる定義は、1 オクテットから文字へと実行される写像{mapping} を完全に規定し<em>なければならない</em>。
特に、正確な写像を決定するために外部プロフィール情報を使用する事は許されない。
</p>

<p class="note">
注: ここで使われる &quot;文字セット&quot; という用語は、より一般的には &quot;文字エンコーディング&quot; という語で述べられる。
しかし、HTTP と MIME とで同じ登録を共有しているので、用語もまた共有される事は重要な事である。
</p>

<p>
HTTP 文字セットは大文字・小文字を区別しないトークンによって識別される。
トークンの完全なセットは、IANA の文字セット登録機構 <a href="#ref-19">[19]</a> によって定義される。
</p>

<pre> charset = token</pre>

<p>
HTTP では、文字セットの値として独自のトークンを使用する事を認めているが、IANA の文字セット登録機構 <a href="#ref-19">[19]</a> によって定義済みであるトークンは、すべてその登録機構で定義された文字セットを表さ<em>なければならない</em>。
アプリケーションは、使用する文字セットを IANA の登録機構によって定義されたものに制限す<em>べきである</em>。
</p>

<p>
HTTP アプリケーションの開発者は、IETF の文字セット要求を認識す<em>べきである</em> <a href="#ref-38">[38]</a> <a href="#ref-41">[41]</a>。
</p>

<h4 id="section-3.4.1">3.4.1 Charset の誤り</h4>

<p>
いくつかの HTTP/1.0 ソフトウェアは、&quot;受信者が推測すべき&quot; という意図で、文字セットの無い Content-Type ヘッダを不正確に解釈している。
この振る舞いをやめさせたい送信者は、例え文字セットが ISO-8859-1 の時でも文字セットパラメータを含む事が<em>できる</em>し、受信者が混乱する事が無いであろうという事がわかっていれば、それを含む<em>べきである</em>。
</p>

<p>
不幸な事に、いくつかの古い HTTP/1.0 クライアントでは、明示的文字コードパラメータを適切に扱えなかった。
HTTP/1.1 の受信者は、送信者によって供給される文字セットラベルを尊重し<em>なければならない</em>。
そして、文字コードを &quot;推測&quot; する機能を持つユーザエージェントは、もしその文字セットをサポートしていれば、始めに文書を表示する時に、受信者が好むものよりも content-type フィールドにある文字セットを使わ<em>なければならない</em>。
section <a href="#section-3.7.1">3.7.1</a> 参照。
</p>

<h3 id="section-3.5">3.5 内容コーディング</h3>

<p>
内容コーディング値は、エンティティに適用されている、もしくは適用できるエンコーディング変換を示す。
内容コーディングは、文書をその根本的なメディアタイプのアイデンティティを失ったり、情報の欠落する事が無いように、圧縮したり、他の有用な変換が行われる事を許可するために、主に使用される。
しばしば、エンティティはコード化された形態で保存され、直接転送され、受け取り側によってのみデコードされる。
</p>

<pre> content-coding   = token</pre>

<p>
すべての content-coding 値は、大文字・小文字を区別しない。
HTTP/1.1 では、content-coding 値を Accept-Encoding (section <a href="#section-14.3">14.3</a>) と Content-Encoding (section <a href="#section-14.11">14.11</a>) ヘッダフィールドで使用する。
その値は content-coding で表されるけれども、そのエンコーディングを解読するためにはどんなデコーディングメカニズムが必要であるかを示す事は、より重要な事である。
</p>

<p>
Internet Assigned Numbers Authority (IANA) は、content-coding 値トークンに対する登録を行なっている。
初めに登録されているものには、以下のトークンが含まれる:
</p>

<dl>
<dt>gzip</dt>
<dd>
RFC 1952 <a href="#ref-25">[25]</a> に記述されているファイル圧縮プログラム &quot;gzip&quot; (GNU zip) によって作られるエンコーディングフォーマット。
このフォーマットは32 bit CRC 付きの Lempel-Ziv コーディング (LZ77) である。
</dd>
<dt>compress</dt>
<dd>
一般的な UNIX ファイル圧縮プログラム &quot;compress&quot; で作られるエンコーディングフォーマット。
このフォーマットは Lempel-Ziv-Welch コーディング (LZW) に適合している。
</dd>
<dd>
エンコーディングフォーマットの確認のためにプログラム名を使用する事は望ましくなく、将来的なエンコーディングを妨害する。ここでのこれらの使用は歴史的な慣例であり、決して良い方法ではない。
HTTP の過去の実装への互換性のため、アプリケーションは &quot;x-gzip&quot; と &quot;x-compress&quot; をそれぞれ &quot;gzip&quot; と &quot;compress&quot; に等価であるとみなす<em>べきである</em>。
</dd>
<dt>deflate</dt>
<dd>
RFC 1951 <a href="#ref-29">[29]</a> に記述されている &quot;deflate&quot; 圧縮メカニズムと結合した、RFC 1950 <a href="#ref-31">[31]</a> にて定義されている &quot;zlib&quot; フォーマット。
</dd>
<dt>identity</dt>
<dd>
既定のエンコーディング、つまり圧縮・変形をしない場合に使う。
この content-coding 値は、Accept-Encoding ヘッダでのみ使用し、Content-Encoding ヘッダでは使用す<em>べきではない</em>。
</dd>
</dl>

<p>
新しい content-coding 値トークンは登録される<em>べきである</em>。
すなわち、クライアントとサーバとの間での内部操作性を認めるため、新しい値を実装する必要のある内容コーディングアルゴリズムの仕様は、広く利用できて、独立した実装に適し、そしてこの章で定義された内容コーディングの目的に従う<em>べきである</em>。
</p>

<h3 id="section-3.6">3.6 転送コーディング</h3>

<p>
転送コーディング値は、ネットワークを通して &quot;安全な転送&quot; を保証するために、エンティティボディに適用されている、する事のできる、する必要のあるエンコーディング変換を示すために使われる。
転送コーディングは、元のエンティティではなくメッセージの特性である、という点で内容コーディングとは異なる。
</p>

<pre> transfer-coding         = &quot;chunked&quot; | transfer-extension
 transfer-extension      = token *( &quot;;&quot; parameter )
</pre>

<p>
パラメータは、attribute/value ペアの形態を為す。
</p>

<pre> parameter               = attribute &quot;=&quot; value
 attribute               = token
 value                   = token | quoted-string
</pre>

<p>
すべての transfer-encoding 値は、大文字・小文字を区別しない。
HTTP/1.1 では、TE ヘッダフィールド (section <a href="#section-14.39">14.39</a>) と Transfer-Encoding ヘッダフィールド (section <a href="#section-14.41">14.41</a>) で転送コーディング値を使用している。
</p>

<p>
接続を閉じる事でメッセージの終了を示す場合以外に、転送コーディングがメッセージボディに適用される時は常に、転送コーディングのセットは &quot;chunked&quot; を含んでい<em>なければならない</em>。
&quot;chunked&quot; 転送コーディングが使われた時は、メッセージボディに適用される最後の転送コーディングにし<em>なければならない</em>。
&quot;chunked&quot; 転送コーディングは、一度メッセージボディに適用したら、それ以上適用し<em>てはならない</em>。
これらの規定によって、受信者はメッセージの転送長さ (section <a href="#section-4.4">4.4</a>) を決定できる。
</p>

<p>
転送エンコーディングは、MIME の Content-Transfer-Encoding 値 <a href="#ref-7">[7]</a> と似ていて、7-bit 転送サービス上でのバイナリデータの安全な転送を可能にするために設計されている。
しかし、完全な 8bit 転送プロトコルにおける安全な転送とは異なる焦点を持つ。
HTTP では、メッセージボディに特有の危険さは、明確なボディ長 (section <a href="#section-7.2.2">7.2.2</a>) を決定する事が困難な事や、共有された転送経路上でデータの暗号化を望む、という事だけである。
</p>

<p>
Internet Assigned Numbers Authority (IANA) は、transfer-coding 値トークンに対する登録を行なっている。
初めに登録されているものには、以下のトークンが含まれる:
&quot;chunked&quot; (section <a href="#section-3.6.1">3.6.1</a>), &quot;identity&quot; (section 3.6.2), &quot;gzip&quot; (section <a href="#section-3.5">3.5</a>), &quot;compress&quot; (section <a href="#section-3.5">3.5</a>), &quot;deflate&quot; (section <a href="#section-3.5">3.5</a>). (※)
</p>

<p class="note">
(※訳注) section 3.6.2 は、RFC 2616 中には存在しない。
</p>

<p>
新しい transfer-coding 値トークンは、新しい content-coding 値トークンと同様にして登録される<em>べきである</em> (section <a href="#section-3.5">3.5</a>)。
</p>

<p>
理解できない transfer-coding を含むエンティティボディを受信したサーバは、501 (Unimplemented) を返して接続を閉じる<em>べきである</em>。
サーバは、HTTP/1.0 クライアントに転送エンコーディングを送っ<em>てはならない</em>。
</p>

<h4 id="section-3.6.1">3.6.1 チャンク形式転送エンコーディング</h4>

<p>
チャンク形式エンコーディングは、それぞれが自身のサイズ指標を持つ、一連のチャンクと、エンティティヘッダフィールドを含む<em>オプショナルな</em> trailer を付加して転送するためにメッセージのボディを書き換える。
これによって、受信者が全メッセージを受信した事を確かめるために必要な情報を、動的に生成された内容と一緒に転送できるようにする。
</p>

<pre> Chunked-Body   = *chunk
                  last-chunk
                  trailer
                  CRLF

 chunk          = chunk-size [ chunk-extension ] CRLF
                  chunk-data CRLF
 chunk-size     = 1*HEX
 last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

 chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
 chunk-ext-name = token
 chunk-ext-val  = token | quoted-string
 chunk-data     = chunk-size(OCTET)
 trailer        = *(entity-header CRLF)
</pre>

<p>
chunk-size フィールドは、チャンクのサイズを示す 16 進数の数字列である。
チャンク形式エンコーディングは、サイズが 0 のチャンクで終わり、空行によって終わる物{trailer} が続く。
</p>

<p>
trailer では、送信者はメッセージの末尾に HTTP ヘッダフィールドを追加できる。
Trailer ヘッダフィールドは、trailer の中に含まれたヘッダフィールドを示すために使う事ができる (section <a href="#section-14.40">14.40</a> 参照)。
</p>

<p>
レスポンスでチャンク形式転送コーディングを使うサーバは、以下のどれにも当てはまらなければ、ヘッダフィールドにおいて trailer を使っ<em>てはならない</em>。
</p>

<ol class="abc">
<li>
section <a href="#section-14.39">14.39</a> で示すように、&quot;trailers&quot; を表す TE ヘッダフィールドを含むリクエストが、レスポンスの転送コーディングで受け入れ可能である。
</li>
<li>
そのサーバがレスポンスのオリジンサーバで、trailer フィールド全体がオプショナルなメタデータから成り、受信者はこのメタデータを受け入れる事無しにその (マナーとしてオリジンサーバは受け入れ可能な) メッセージを使う事ができる。
言いかえれば、オリジンサーバは、クライアントまでの道のりの中で trailer フィールドが黙って廃棄されるかもしれないという可能性を受け入れる事を意図する。
</li>
</ol>

<p>
この要求は、HTTP/1.1 (もしくはそれ以降) のプロクシがメッセージを受信して、それを HTTP/1.0 の受信者に転送する時に、相互通信が失敗しないようにする。
これは、もしかしたらプロクシに無限のバッファを送る必要があるような規約を伴う承諾の場面を避ける。
</p>

<p>
Chunked-Body デコーディングのための例題過程は、付録の <a href="#section-19.4.6">19.4.6</a> で紹介されている。
</p>

<p>
すべての HTTP/1.1 アプリケーションは、&quot;chunked&quot; 転送コーディングを受信しデコードでき<em>なければならない</em>し、理解できない転送コーディング拡張は無視し<em>なければならない</em>。
</p>

<h3 id="section-3.7">3.7 メディアタイプ</h3>

<p>
HTTP は、Content-Type (section <a href="#section-14.17">14.17</a>) と Accept (section <a href="#section-14.1">14.1</a>) ヘッダフィールドにおいて、開放・拡張データタイプの決定やタイプネゴシエーションを供給するために Internet Media Type <a href="#ref-17">[17]</a> を使用する。
</p>

<pre> media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
 type           = token
 subtype        = token
</pre>

<p>
(section <a href="#section-3.6">3.6</a>で定義されているように) attribute/value ペアの形態で、タイプ/サブタイプがあり、その後にパラメータを置く事が<em>できる</em>。
</p>

<p>
タイプ、サブタイプ、パラメータ属性名は、大文字・小文字を区別しない。
しかし、パラメータ値は、パラメータ名の意味論に依存するので、大文字・小文字は区別されるかもしれない。
連続した空白文字 (LWS: Linear white space) は、タイプとサブタイプの間や属性とその値の間で使われ<em>てはならない</em>。
パラメータのある無しは、メディアタイプの定義に依存するので、メディアタイプ決定のプロセスに重要なものとなるだろう。
</p>

<p>
古い HTTP アプリケーションの中には、メディアタイプパラメータを認識しないものもある事に注意せよ。
従って、実装が古い HTTP アプリケーションにデータを送る時は、タイプ/サブタイプ定義を要求した場合に時のみ、メディアタイプパラメータを使用す<em>べきである</em>。
</p>

<p>
メディアタイプ値は、Internete Assigned Number Authority (IANA <a href="#ref-19">[19]</a>) によって登録される。
メディアタイプ登録手続きの方法は、RFC 1590 <a href="#ref-17">[17]</a> において概説されている。
登録されていないメディアタイプの使用は推奨されない。
</p>

<h4 id="section-3.7.1">3.7.1 公式化とテキストの既定</h4>

<p>
インターネットメディアタイプは、公式の形式で登録される。
HTTP メッセージ経由で転送されるエンティティボディは、次のパラグラフで定義されるような &quot;text&quot; タイプを除けば、転送する前に、その適切な公式形式で表され<em>なければならない</em>。
</p>

<p>
公式形式では、&quot;text&quot; タイプのメディアサブタイプは、テキストの行末に CRLF を使う。
HTTP では、エンティティボディ全体で一貫している場合は、この要求をゆるめ、行末を表すのに単独の CR や LF をつけたテキストメディアの転送を認めている。
HTTP アプリケーションは、HTTP 経由で受信されるテキストメディアの行末表現として、CRLF, CR, LF を受け入れ<em>なければならない</em>。
加えて、もしテキストが、幾つかのマルチバイト文字セットの場合のように、CR と LF それぞれに対してオクテットの 13 と 10 が使われていないような文字セットで表現されているならば、HTTP は、行末の CR や LF と同等の表現をするための、その文字セットで定義されているどんなオクテットシーケンスの使用をも認める。
行末に関するこの柔軟性は、エンティティボディ内のテキストメディアにのみ適用される。
すなわち、(ヘッダフィールドやマルチパート境界等の) HTTP 制御構造では、いかなる単独の CR や LF も、CRLF に置き換え<em>てはならない</em>。
</p>

<p>
エンティティボディが内容エンコーディングでエンコードされている場合は、根底のデータは、エンコードされる前には上で定義される形態をとってい<em>なければならない</em>。
</p>

<p>
&quot;charset&quot; パラメータは、データの文字セット (section <a href="#section-3.4">3.4</a>) を定義するためにいくつかのメディアタイプで使用されている。
明示的な charset パラメータが送り側から供給されない時に、HTTP 経由で受信される &quot;text&quot; タイプのメディアサブタイプは、既定の charset である &quot;ISO-8859-1&quot; という値を持つと定義される。
&quot;ISO-8859-1&quot; やそのサブセット以外の文字セットを使うデータは、適切な charset 値をラベル付け<em>なければならない</em>。
互換性の問題については section <a href="#section-3.4.1">3.4.1</a> 参照。
</p>

<h4 id="section-3.7.2">3.7.2 マルチパートタイプ</h4>

<p>
MIME は、一つのメッセージボディの中に複数のエンティティをカプセル化する &quot;multipart&quot; タイプをいくつか供給する。
すべてのマルチパートタイプは RFC 2046 <a href="#ref-40">[40]</a> の section 5.1.1 で定義されているように、共通の構文を共有し、メディアタイプ値の一部として境界パラメータ{boundary parameter} を含め<em>なければならない</em>。
メッセージボディは、それ自身プロトコル要素の一部であり、それゆえに、body-parts 間の行末を表すためには CRLF のみを使用し<em>なければならない</em>。
RFC 2046 と異なり、どのマルチパートメッセージのエピローグ{epilogue} も空でなければならない。
そのため、HTTP アプリケーションは (たとえ元のマルチパートがエピローグを含んでいても) エピローグを転送し<em>てはならない</em>。
これらの制限は、最後のマルチパートの境界線によってメッセージボディの &quot;終端&quot; を示せるように、マルチパートのメッセージボディに自己限界性質{the self-delimiting nature} を持たせるために存在する。
</p>

<p>
一般的に、HTTP はマルチパートメッセージボディを他のメディアタイプとは区別無く、すなわち単なる付加物{payload} として扱う。
ただ一つ例外は、206 (Partial Content) レスポンス中に現れる時の &quot;multipart/byteranges&quot; タイプ (appendix <a href="#section-19.2">19.2</a>) であり、その場合 section <a href="#section-13.5.4">13.5.4</a> や section <a href="#section-14.16">14.16</a> で表されるような、いくつかの HTTP キャッシュメカニズムによって解釈されるだろう。
その他のすべての場合では、HTTP ユーザエージェントは、MIME ユーザエージェントがマルチパートタイプの受けとる時と同じ、ま
たは似たような振る舞いをす<em>べきである</em>。
マルチパートメッセージボディの各々のボディ部分中の MIME ヘッダフィールドは、HTTP ではそれらの MIME 意味論による定義以上にどんな意味も持たない。
</p>

<p>
一般的には、HTTP ユーザエージェントは、MIME ユーザエージェントがマルチパートタイプの受けとる時と同じ、または似たような振る舞いをす<em>べきである</em>。
アプリケーションが認識できないマルチパートサブタイプを受け取った場合は、それを &quot;multipart/mixed&quot; に相当するものとして扱わ<em>なければならない</em>。
</p>

<p class="note">
注: &quot;multipart/form-data&quot; タイプは、RFC 1867 <a href="#ref-15">[15]</a> で表されるように、特に POST リクエストメソッド経由で処理するのに合ったフォームデータを転送するために特別に定義されている。
</p>

<h3 id="section-3.8">3.8 製品トークン</h3>

<p>
製品トークンは、ソフトウェアの名前とバージョンによってその製品である事を識別するアプリケーションと通信する事ができるようにするために使われる。
製品トークンで使用されるほとんどのフィールドは、アプリケーションの重要な部分を形成する部分製品{sub-product} を空白で区切るように列挙できるようになっている。
慣習では、製品はそのアプリケーションを識別するために重要なものの順に列挙される。
</p>

<pre> product         = token [&quot;/&quot; product-version]
 product-version = token
</pre>

<p>例を見よ。</p>

<pre><samp> User-Agent: CERN-LineMode/2.15 libwww/2.17b3
 Server: Apache/0.8.4</samp>
</pre>

<p>
製品トークンは短く要点のみである<em>べきである</em>。
宣伝や別の本質的でない情報のために使用し<em>てはならない</em>。
製品バージョンにはあらゆるトークン文字を使用<em>できる</em>が、このトークンはバージョン識別子に対してのみ使われる<em>べきである</em>。
(例えば、同じ製品の連続したバージョンは、製品値の製品バージョン部分のみが異なる<em>べきである</em>)。
</p>

<h3 id="section-3.9">3.9 品質値</h3>

<p>
HTTP 内容ネゴシエーション (section <a href="#section-12">12</a>) は、さまざまなネゴシエート可能なパラメータの相対な重要性 (&quot;ウェイト&quot;) を示すために短い &quot;浮動小数点&quot; 数を使う。
ウェイトは、0 から 1 までの実数値と標準化され、0 は最小値で 1 は最大値である。
もしパラメータが 0 の品質値を持っていたら、そのパラメータと共にあるものはクライアントは「利用不可能」である。
HTTP/1.1 アプリケーションは、小数点以下で三桁を越える数字を生成し<em>てはならない</em>。
これらの値のユーザ設定も、この様式にかぎられる<em>べきである</em>。
</p>

<pre> qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )
</pre>

<p>
&quot;品質値&quot; とは、単に要請される特質の相対的な格付けを示すものなので、実際は誤った表現である。
</p>

<h3 id="section-3.10">3.10 言語タグ</h3>

<p>
言語タグは、他の人間との情報のコミュニケーションのため、人間によって話され、書かれ、あるいは別の方法で伝えられる自然言語を識別する。
コンピュータ言語は完全に除外される。HTTP では、Accept-Language や Content-Language 各フィールドにおいて言語タグを使用する。
</p>

<p>
HTTP 言語タグの構文や登録は、RFC 1766 <a href="#ref-1">[1]</a> で定義されたものと同じである。
要約すると、言語タグは第一の言語タグと空の可能性のあるサブタグのいくつかから成る。
</p>

<pre> language-tag  = primary-tag *( &quot;-&quot; subtag )
 primary-tag   = 1*8ALPHA
 subtag        = 1*8ALPHA
</pre>

<p>
ホワイトスペースはタグの中では認められず、すべてのタグで大文字・小文字を区別しない。
言語タグの名前空間は IANA によって管理されている。
例えば、言語タグには以下のような物がは含まれる。
</p>

<pre> <samp>en, en-US, en-cockney, i-cherokee, x-pig-latin</samp></pre>

<p>
第一タグの二文字は、ISO-639 の言語短縮形であり、サブタグの最初の二文字は、ISO-3166 カントリーコードである。
(上記の後ろ三つのタグは登録されていないタグである; しかし、全て将来に登録されるかもしれないタグの例である。)
</p>

<h3 id="section-3.11">3.11 エンティティタグ</h3>

<p>
エンティティタグは、同一の要求リソースからの二つ以上のエンティティを比較するために使用される。
HTTP/1.1 では、ETag (section <a href="#section-14.19">14.19</a>), If-Match (section <a href="#section-14.24">14.24</a>), If-None-Match (section <a href="#section-14.26">14.26</a>), If-Range (section <a href="#section-14.27">14.27</a>) 各ヘッダフィールドで、エンティティタグを使う。
それらがキャッシュバリディタとして、どのよう使われ、比較されるかの定義は、section <a href="#section-13.3.3">13.3.3</a> にある。
エンティティタグは、それ自体は読んでも意味のわからない{opaque} 引用符で括られた文字列から成り、weakness インジケータが前方に付く場合もある。
</p>

<pre> entity-tag = [ weak ] opaque-tag
 weak       = &quot;W/&quot;
 opaque-tag = quoted-string
</pre>

<p>
&quot;strong entity tag&quot; では、もしそれらがオクテット文字によって同等の場合にのみ、リソースの2つのエンティティが共有<em>できる</em>。
</p>

<p>
&quot;W/&quot; プレフィクスによって示される &quot;weak entity tag&quot; では、エンティティが等価であり、意味論においてそれぞれ重要な変更がなく互いを代わりに使う事が出来る場合のみ、リソースの2つのエンティティが共有<em>できる</em>。
weak エンティティタグは、弱い比較の時のみ使用される。
</p>

<p>
エンティティタグは、特有のリソースと関連付けられた全てのエンティティの全てのバージョンの中で一意{unique} で<em>なければならない</em>。
与えられたエンティティタグの値は、異なる URI へのリクエストから得られたエンティティのために使う事が<em>できる</em>。
異なる URI へのリクエストから得られたエンティティに同じエンティティタグの値を使っているからといって、それらのエンティティの同等性を暗に意味するものではない。
</p>

<h3 id="section-3.12">3.12 レンジ単位</h3>

<p>
HTTP/1.1 では、クライアントはレスポンス内に含まれるレスポンスエンティティの (範囲の) 一部だけを要求できる。
HTTP/1.1 は、Range (section <a href="#section-14.35">14.35</a>) と Content-Range (section <a href="#section-14.16">14.16</a>) 各ヘッダフィールドにおいてレンジ単位を使用する。
エンティティは、さまざまな構造上の単位に従ったサブレンジへと分解されるだろう。
</p>

<pre> range-unit       = bytes-unit | other-range-unit
 bytes-unit       = &quot;bytes&quot;
 other-range-unit = token
</pre>

<p>
HTTP/1.1 で定義されている唯一のレンジ単位は、&quot;bytes&quot; である。
HTTP/1.1 実装は、別の単位を使って指定されたレンジは無視する事が<em>できる</em>。
</p>

<p>
HTTP/1.1 では、アプリケーションの実装がレンジについての知識に依存しないという事が認められる様に設計されている。
</p>

<h2 id="section-4">4 HTTP メッセージ</h2>

<h3 id="section-4.1">4.1 メッセージタイプ</h3>

<p>
HTTPメッセージは、クライアントからサーバへのリクエストと、サーバからクライアントへのレスポンスから成る。
</p>

<pre> HTTP-message   = Request | Response     ; HTTP/1.1 messages</pre>

<p>
リクエスト (section <a href="#section-5">5</a>) と レスポンス (section <a href="#section-6">6</a>) 各メッセージは、エンティティ (メッセージの付加物) を転送するために RFC 822 <a href="#ref-9">[9]</a> の一般的なメッセージフォーマットを使用する。
両タイプとも、開始行、0 以上のヘッダフィールド (&quot;headers&quot;として知られているもの)、ヘッダフィールドの終了を示す (CRLF の前に何もない行のような) 空行、そして任意のメッセージボディからなる。
</p>

<pre> generic-message = start-line
                   *(message-header CRLF)
                   CRLF
                   [ message-body ]
 start-line      = Request-Line | Status-Line
</pre>

<p>
強い関心を持って、サーバは、Request-Line である事が期待できる位置で受け取った空行はいかなるものも無視す<em>べきである</em>。
言いかえれば、サーバが、メッセージの開始地点からプロトコルストリームで読み出しを行って、最初に CRLF を受信した場合、その CRLF は無視すべきである。
</p>

<p>
バグを持つ HTTP/1.0 クライアント実装の中には、POST リクエストの後に余計な CRLF を生成するものもある。
BNF によって明示的に禁止される事を再述すれば、HTTP/1.1 クライアントはリクエストの際に余計 CRLF を前にも後ろにもつけ<em>てはならない</em>。
</p>

<h3 id="section-4.2">4.2 メッセージヘッダ</h3>

<p>
一般ヘッダ (section <a href="#section-4.5">4.5</a>)、リクエストヘッダ (section <a href="#section-5.3">5.3</a>)、レスポンスヘッダ (section <a href="#section-6.2">6.2</a>)、エンティティヘッダ (section <a href="#section-7.1">7.1</a>) 各フィールドを含む HTTP ヘッダフィールドは、RFC 822 <a href="#ref-9">[9]</a> の Section 3.1 で与えられているものと同じである共通のフォーマットに従う。
それぞれのヘッダフィールドは、名前、その後にコロン(&quot;:&quot;)、そしてフィールド値から成る。
フィールド名は、大文字・小文字を区別しない。
フィールド値には、いくつもの LWS を先行させる事が<em>できる</em>が、SP 一つだけが好ましい。
ヘッダフィールドは、一つ以上の SP や HT をそれぞれの行頭につける事で複数行にまたがる事ができる。
アプリケーションが HTTP 構造を生成する時には、&quot;共通形式&quot; を超えたものは受け入れられない実装がいくつか存在するであろう事を考慮し、知られている、あるいは示されている &quot;共通形式&quot;に従うべきである。
</p>

<pre> message-header = field-name &quot;:&quot; [ field-value ]
 field-name     = token
 field-value    = *( field-content | LWS )
 field-content  = &lt;field-value を構成し、*TEXT あるいは
                  token, separators, quoted-string を連結
                  したものから成る OCTET&gt;
</pre>

<p>
field-content は、LWS を前にも後ろにも、すなわち field-value の最初の空白以外の文字の前にも、あるいは field-value の最後の空白以外の文字の後ろにも、含まない。
そのような前後の LWS は、フィールド値の意味論を変える事無く削除される<em>であろう</em>。
field-content の間のいかなる LWS もフィールド値に解釈されたり、下流{downstream} に転送される前に単なる SP に置き換えられる<em>であろう</em>。
</p>

<p>
異なるフィールド名を持つヘッダフィールドが受信される順序は、重要ではない。
しかしながら、最初に一般ヘッダフィールド、その後にリクエストヘッダやレスポンスヘッダ、そして最後にエンティティフィールドを送る事が &quot;良い習慣&quot; である。
</p>

<p>
同じフィールド名を持つ複数のメッセージヘッダフィールドは、そのヘッダフィールドの全体のフィールド値が [例えば、#(value) のように] コンマで区切られたリストとして定義される場合にのみ、メッセージに存在<em>できる</em>。
そしてそれら複数のヘッダフィールドは、最初の field-value に、コンマによって分けられたそれぞれの field-value を追加する事で、メッセージの意味論を変える事無しに、一つの &quot;header-name: header-value&quot; ペアに結合でき<em>なければならない</em>。
それゆえ、同じフィールド名のヘッダフィールドが受信される順番は、連結されたフィールド値の中間処理のために重要なので、プロクシはメッセージを転送する時にはそれらのヘッダ値の順番を変え<em>てはならない</em>。
</p>

<h3 id="section-4.3">4.3 メッセージボディ</h3>

<p>
HTTP メッセージにメッセージボディがあったとしたら、それはリクエストやレスポンスに関連するエンティティボディを運ぶために使われる。
メッセージボディは、Transfer-Encoding ヘッダフィールド (section <a href="#section-14.41">14.41</a>) によって示されるように、転送コーディングが適用された場合のみ、エンティティボディとは異なる。
</p>

<pre> message-body = entity-body
              | &lt;Transfer-Encoding にてエンコードされた entity-body&gt;
</pre>

<p>
Transfer-Encoding は、メッセージの安全かつ適切な転送を保障するアプリケーションによって、適用されるすべての転送コーディングを示すために使われ<em>なければならない</em>。
Transfer-Encoding は、メッセージの性質であり、エンティティの性質ではないので、リクエスト/レスポンス連鎖に関わるあらゆるアプリケーションによって追加されたり削除されたり<em>されうる</em>。
(しかしながら、確実に転送コーディングが用いられているであろう時のために、section <a href="#section-3.6">3.6</a> にて制限を設けている。)
</p>

<p>
メッセージボディがメッセージにおいて認められる規定は、リクエストとレスポンスで異なる。
</p>

<p>
リクエストにおけるメッセージボディの存在は、リクエスト時にメッセージヘッダに Content-Length や Transfer-Encoding 各ヘッダフィールドを含む事によって伝えられる。
リクエスト時に、もし使用するリクエストメソッド (section <a href="#section-5.1.1">5.1.1</a>) の定義で、リクエスト時にエンティティボディを送信する事を許可していなければ、メッセージボディをリクエストに含んでは<em>ならない</em>。
サーバは、どんなリクエストでもメッセージボディを読んで転送す<em>べきである</em>。
すなわち、もしリクエストメソッドがエンティティボディについて定義された意味論を含んでいなければ、そのメッセージ
ボディはリクエストを処理した時に無視する<em>べきである</em>。
</p>

<p>
レスポンスメッセージでは、メッセージボディがメッセージに含まれているかどうかは、リクエストメソッドとレスポンスステータスコード (section <a href="#section-6.1.1">6.1.1</a>) の両方に依存する。
HEAD リクエストメソッドへのレスポンスは、たとえそこに含まれるエンティティヘッダフィールドがそうするようにあったとしても、いかなる場合もメッセージボディを含んでは<em>ならない</em>。
1xx (Information), 204 (no content), 304 (not modified) レスポンスでは、すべてメッセージボディを含んでは<em>ならない</em>。
その他のレスポンスでは、その長さはゼロである<em>かもしれない</em>が、すべてメッセージボディを含んでいる。
</p>

<h3 id="section-4.4">4.4 メッセージの長さ</h3>

<p>
メッセージの転送長さ{transfer-length} は、それがメッセージの中に現れた時、つまりある転送コーディングが適用された後のメッセージボディの長さである。
メッセージボディがメッセージに含まれる時、そのボディの転送長さは以下のうちのどれかで決定される（優先順位順）。
</p>

<ol>
<li>
メッセージボディを含ん &quot;<em>ではならない</em>&quot;（1xx, 204, 304 レスポンスや HEAD リクエストに対するすべてのレスポンス）レスポンスメッセージは、メッセージ中にエンティティヘッダフィールドがあるか無いかに関わらず、常にヘッダフィールドの後の最初の空行で終了する。
</li>
<li>
もし、Transfer-Encoding ヘッダフィールド (section <a href="#section-14.41">14.41</a>) があり、&quot;identity&quot; 以外の値を持っていて、接続を閉じる事でメッセージが終了しているのでなければ、転送長さは &quot;chunked&quot; エンコーディング (section <a href="#section-3.6">3.6</a>) の使用によって定義される。
</li>
<li>
もし、Content-Length ヘッダフィールド(section <a href="#section-14.14">14.14</a>) があれば、そのオクテット中の10進数の値は、エンティティ長さ{entity-length} と転送長さを表す。
もしそれら二つの長さが違うのならば、Content-Length ヘッダフィールドを送っ<em>てはならない</em> (例えば、Transfer-Encoding がある場合)。
もし、メッセージが Transfer-Encoding ヘッダフィールドと Content-Length ヘッダフィールドとを一緒に送ってきたならば、後者は無視し<em>なければならない</em>。
</li>
<li>
もし、メッセージがメディアタイプ &quot;multipart/byteranges&quot; を使い、その転送長さが別の方法で特定できなければ、自身で区切りを持つこのメディアタイプは、その転送長さを定義する。
送信者は、受信者がこのメディアタイプを解析できる事という事を知らないのでならば、使っ<em>てはならない</em>。
リクエスト時の複数のバイトレンジを持つ Range ヘッダの存在は、クライアントが multipart/byterange レスポンスを解析できる事を暗黙的に意味する。
<p class="note">
multipart/byterange を理解しない HTTP/1.0 プロクシは、Range ヘッダを転送するだろう。
この場合、サーバはこの章で定義されているうちの 1, 3, 5 の項目のいずれかの方法を使って、このメッセージを制御し<em>なければならない</em>。
</p>
</li>
<li>
接続を閉じるサーバによる。
（サーバがレスポンスを送り返す可能性がある事を捨て置けないので、リクエストボディの終了を示すために接続を閉じるという方法は、使えない。）
</li>
</ol>

<p>
HTTP/1.0 アプリケーションへの互換性のため、メッセージボディを含む HTTP/1.1 リクエストは、もしサーバが HTTP/1.1 に準じている事を知らなければ、適した Content-Length ヘッダフィールドを含ま<em>なければならない</em>。
もし、リクエストがメッセージボディを含んでいて、Content-Length を含んでいなかったら、サーバは、それによってメッセージの長さが決定できない場合は 400 (bad request) を、有効な Content-Length を受けとりたい場合は 411 (length required) を、それぞれ返す<em>べきである</em>。
</p>

<p>
エンティティを受け取るすべての HTTP/1.1 アプリケーションは、&quot;chunked&quot; 転送エンコーディング (section <a href="#section-3.6">3.6</a>) を受け入れられ<em>なければならない</em>ので、メッセージ長が前もって決定できない時には、このメカニズムをメッセージに対して使う事が認められる。
</p>

<p>
メッセージには、Content-Length ヘッダフィールドと identity でない転送コーディングの両方を含んでは<em>ならない</em>。
メッセージが、identity でない転送コーディングを含んでいたら、Content-Length は無視され<em>なければならない</em>。
</p>

<p>
メッセージボディが認められるメッセージにて Content-Length が与えられる時には、そのフィールド値はメッセージボディにおけるオクテットの数と正確に一致し<em>なければならない</em>。
HTTP/1.1 ユーザエージェントは、不正な長さが受信されたり検出された時には、それをユーザに通知し<em>なければならない</em>。</p>

<h3 id="section-4.5">4.5 一般ヘッダフィールド</h3>

<p>
リクエストとレスポンスの両メッセージで、一般的な適用性を持つが、転送されたエンティティには適用されないヘッダがいくつかある。
これらのヘッダフィールドは、伝えられているメッセージに対してのみ適用する。
</p>

<pre> general-header = Cache-Control            ; Section <a href="#section-14.9">14.9</a>
                | Connection               ; Section <a href="#section-14.10">14.10</a>
                | Date                     ; Section <a href="#section-14.18">14.18</a>
                | Pragma                   ; Section <a href="#section-14.32">14.32</a>
                | Trailer                  ; Section <a href="#section-14.40">14.40</a>
                | Transfer-Encoding        ; Section <a href="#section-14.41">14.41</a>
                | Upgrade                  ; Section <a href="#section-14.42">14.42</a>
                | Via                      ; Section <a href="#section-14.45">14.45</a>
                | Warning                  ; Section <a href="#section-14.46">14.46</a>
</pre>

<p>
一般ヘッダフィールド名は、プロトコルバージョンの変化に伴う連動においてのみ確実に拡張されうる。
しかしながら、新しい、あるいは実験的なヘッダフィールドは、もしそのコミュニケーションでのすべてのパーティがそれらを一般ヘッダフィールドであると認識できるなら、一般的なヘッダフィールドの意味論を与えてもよい。
認識されないヘッダフィールドは、エンティティヘッダフィールドとして扱われる。
</p>

<h2 id="section-5">5 リクエスト</h2>

<p>
クライアントからサーバへのリクエストメッセージには、リソースに適用されるメソッド、リソースの識別子、使用するプロトコルのバージョンが最初の行に含まれる。
</p>

<pre> Request       = Request-Line              ; Section <a href="#section-5.1">5.1</a>
                 *(( general-header        ; Section <a href="#section-4.5">4.5</a>
                  | request-header         ; Section <a href="#section-5.3">5.3</a>
                  | entity-header ) CRLF)  ; Section <a href="#section-7.1">7.1</a>
                 CRLF
                 [ message-body ]          ; Section <a href="#section-4.3">4.3</a>
</pre>

<h3 id="section-5.1">5.1 リクエストライン</h3>

<p>
リクエストラインは、メソッドトークンに始まり、 Request-URI とプロトコルバージョンが後に続き、CRLF で終了する。
要素は SP によって分けられる。
最後の CRLF シーケンス以外には、CR も LF も許されない。
</p>

<pre>Request-Line   = Method SP  Request-URI SP HTTP-Version CRLF
</pre>

<h4 id="section-5.1.1">5.1.1 メソッド</h4>

<p>
メソッドトークンは、 Request-URIにより識別されるリソースに働きかけるためのメソッドを示す。
メソッドは大文字・小文字を区別する。
</p>

<pre> Method         = &quot;OPTIONS&quot;                ; Section <a href="#section-9.2">9.2</a>
                | &quot;GET&quot;                    ; Section <a href="#section-9.3">9.3</a>
                | &quot;HEAD&quot;                   ; Section <a href="#section-9.4">9.4</a>
                | &quot;POST&quot;                   ; Section <a href="#section-9.5">9.5</a>
                | &quot;PUT&quot;                    ; Section <a href="#section-9.6">9.6</a>
                | &quot;DELETE&quot;                 ; Section <a href="#section-9.7">9.7</a>
                | &quot;TRACE&quot;                  ; Section <a href="#section-9.8">9.8</a>
                | &quot;CONNECT&quot;                ; Section <a href="#section-9.9">9.9</a>
                | extension-method
 extension-method = token
</pre>

<p>
リソースにより認められるメソッドのリストは、Allow ヘッダフィールド (section <a href="#section-14.7">14.7</a>) により示される。
許されるメソッドのセットは動的に変化できるため、レスポンスのリターンコードはそのメソッドが現在リソースに許されているかどうかにかかわらず、常にクライアントに通知される。
オリジンサーバは、メソッドを理解できても要求されたリソースに対して許されていない場合は、ステータスコード 405 (Method Not Allowed) を返す<em>べきであり</em>、またオリジンサーバがそのメソッドを認識できなかったり実装されていない場合には 501 (Not Implemented) を返す<em>べきである</em>。
すべての一般目的サーバ{general-purpose servers} では、GET とHEAD メソッドは、サポートしてい<em>なければならない</em>。
他のすべてのメソッドは<em>オプショナル</em>であるが、もし上記のメソッドが実装されるなら、それらは section <a href="#section-9">9</a> で記述されているものと同じ意味論で実装されなければならない。
</p>

<h4 id="section-5.1.2">5.1.2  Request-URI</h4>

<p>
Request-URI は、Uniform Resource Identifier (section <a href="#section-3.2">3.2</a>) であり、リクエストを適用するリソースを識別する。
</p>

<pre> Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority</pre>

<p>
Request-URI の 4 つのオプションは、そのリクエストの性質に依存する。
アスタリスク &quot;*&quot; は、そのリクエストが特定のリソースではなく、サーバ自身に適用するという事を意味し、使用されるメソッドがリソースに適用される必要がない時にのみ許される。
一例を挙げる。
</p>

<pre> <samp>OPTIONS * HTTP/1.1</samp></pre>

<p>
absoluteURI 形式は、リクエストがプロクシに対して生成されている時に<em>要求される</em>。
プロクシは、そのリクエストを転送するか、有効なキャッシュ内から提供する時に呼び出され、レスポンスを返す。
プロクシは、そのリクエストを別のプロクシか、あるいは absoluteURI によって特定されたサーバに直接送る事が<em>できる</em>事に注意せよ。
リクエストループを避けるために、プロクシはそのサーバ名をエイリアス、ローカルバリエーション、数値 IP アドレスまで含め、すべて理解でき<em>なければならない</em>。
Request-Line の例は以下の様になる。
</p>

<pre> <samp>GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1</samp></pre>

<p>
HTTP の将来のバージョンにおいてすべてのリクエストが absoluteURI へ移行する事ができるように、例え HTTP/1.1 クライアントはプロクシへのリクエストとしてのみしか生成しないものであったとしても、全ての HTTP/1.1 サーバはリクエストにおける absoluteURI 形式を受け入れ<em>なければならない</em>。
</p>

<p>
authority 形式は、CONNECT メソッド (section <a href="#section-9.9">9.9</a>) のみで使用する。
</p>

<p>
Request-URI の最も一般的な形式は、オリジンサーバやゲートウェイ上のリソースを識別するために使用される事である。
この場合、URI の絶対パスは Request-URI として通信され<em>なければならない</em> (section <a href="#section-3.2.1">3.2.1</a>, abs_path 参照) し、URI のネットワークロケーション(authority) は、Host ヘッダフィールドにおいて転送され<em>なければならない</em>。
例えば、オリジンサーバから直接上記のリソースを回収する事を望むクライアントは、ホスト &quot;www.w3.org&quot; のポート 80 に TCP 接続を確立し、その行を送る。
</p>

<pre><samp> GET /pub/WWW/TheProject.html HTTP/1.1
 Host: www.w3.org</samp></pre>

<p>
残りのリクエストをその後に送る。絶対パスは空ではない事に注意せよ。
もし、元の URI で何も与えられていなければ、それは &quot;/&quot; (サーバのルート) が与えられ<em>なければならない</em>。
</p>

<p>
Request-URI は、section <a href="#section-3.2.1">3.2.1</a> に記された形式で送られる。
もし、 Request-URI に &quot;% HEX HEX&quot; エンコード <a href="#ref-42">[42]</a> が使用されていたら、オリジンサーバはそのリクエストを適切に解釈するためにその Request-URIをデコードし<em>なければならない</em>。
サーバは、不正な Request-URI には、適切なステータスコードをもって応答す<em>べきである</em>。
</p>

<p>
透過的プロクシは、上で記した空の{null} abs_path を &quot;/&quot; に置き換えるという場合以外は、次のインバウンドサーバに転送する時に、受け取った Request-URI の &quot;abs_path&quot; の一部を書き換え<em>てはならない</em>。
</p>

<p class="note">
注: &quot;書き換え禁止&quot; という規則は、オリジンサーバが予約された目的のための予約されていない URL 文字を不適当に使用している時に、プロクシがリクエストの意味を変えないようにする狙いがある。
実装者は、いくつかの HTTP/1.1 以前のプロクシが Request-URI を書き換える事が知られている、という事を認識すべきである。
</p>

<h3 id="section-5.2">5.2 リクエストによって識別されるリソース</h3>

<p>
インターネットリクエストにより識別された正確なリソースは、 Request-URI と Host ヘッダフィールドの両方で調べる事で決定される。
</p>

<p>
HTTP/1.1 リクエストによってリソースを決定する時、リクエストされたホストによってリソースが異なるという事を認めていないオリジンサーバは、Host ヘッダフィールド値を無視するで<em>あろう</em>。(但し、HTTP/1.1 での Host をサポートする別の必要条件について section <a href="#section-19.6.1.1">19.6.1.1</a> 参照。)
</p>

<p>
リクエストされたホストに基づいてリソースを区別する (しばしば仮想ホストや空虚{vanity} なホスト名として参照される) オリジンサーバは、HTTP/1.1 リクエストで要求されたリソースを決定するために以下の規定を使わ<em>なければならない</em>。
</p>

<ol>
<li>
もし、 Request-URI が absoluteURI ならば、ホストは Request-URI の一部である。
リクエストにおけるどんな Host ヘッダフィールド値も無視され<em>なければならない</em>。
</li>
<li>
もし、 Request-URI が absoluteURI でなく、リクエストが Host ヘッダフィールドを含んでいるならば、ホストは Host ヘッダフィールド値によって決定される。
</li>
<li>
もし、規則 1 や 2 で決定されるようなホストがそのサーバで正当なホストでないならば、レスポンスは 400 (Bad Request) エラーメッセージで<em>なければならない</em>。
</li>
</ol>

<p>
Host ヘッダフィールドが無い HTTP/1.0 リクエストを受信した者は、要求されたリソースがどれほど正確な要求されているかを決定するため (例えば、特定のホストのユニークな何かに対する URI パスの試験のような) 発見方法を試す事が<em>できる</em>。
</p>

<h3 id="section-5.3">5.3 リクエストヘッダフィールド</h3>

<p>
リクエストヘッダフィールドを用いて、クライアントはサーバにリクエストやクライアント自身に関する追加的な情報を渡す事ができる。
これらのフィールドは、メソッド発動{invocation} プログラミング言語におけるパラメータと同等な意味論を持つ、リクエスト修飾子として動作する。
</p>

<pre> request-header = Accept                   ; Section <a href="#section-14.1">14.1</a>
                | Accept-Charset           ; Section <a href="#section-14.2">14.2</a>
                | Accept-Encoding          ; Section <a href="#section-14.3">14.3</a>
                | Accept-Language          ; Section <a href="#section-14.4">14.4</a>
                | Authorization            ; Section <a href="#section-14.8">14.8</a>
                | Expect                   ; Section <a href="#section-14.20">14.20</a>
                | From                     ; Section <a href="#section-14.22">14.22</a>
                | Host                     ; Section <a href="#section-14.23">14.23</a>
                | If-Match                 ; Section <a href="#section-14.24">14.24</a>
                | If-Modified-Since        ; Section <a href="#section-14.25">14.25</a>
                | If-None-Match            ; Section <a href="#section-14.26">14.26</a>
                | If-Range                 ; Section <a href="#section-14.27">14.27</a>
                | If-Unmodified-Since      ; Section <a href="#section-14.28">14.28</a>
                | Max-Forwards             ; Section <a href="#section-14.31">14.31</a>
                | Proxy-Authorization      ; Section <a href="#section-14.34">14.34</a>
                | Range                    ; Section <a href="#section-14.35">14.35</a>
                | Referer                  ; Section <a href="#section-14.36">14.36</a>
                | TE                       ; Section <a href="#section-14.39">14.39</a>
                | User-Agent               ; Section <a href="#section-14.43">14.43</a>
</pre>

<p>
リクエストヘッダフィールド名は、プロトコルバージョンの変化に伴ってのみ確実に拡張されうる。
しかしながら、新しい、あるいは実験的なヘッダフィールドは、もしそのコミュニケーションでのすべてのパーティがそれらをリクエストヘッダフィールドであると認識できるなら、一般的なヘッダフィールドの意味論を与えても<em>よい</em>。
認識されないヘッダフィールドは、エンティティヘッダフィールドとして扱われる。 
</p>

<h2 id="section-6">6 レスポンス</h2>

<p>
リクエストメッセージを受信・解釈した後、サーバは HTTP レスポンスメッセージを返す。
</p>

<pre> Response      = Status-Line               ; Section <a href="#section-6.1">6.1</a>
                 *(( general-header        ; Section <a href="#section-4.5">4.5</a>
                  | response-header        ; Section <a href="#section-6.2">6.2</a>
                  | entity-header ) CRLF)  ; Section <a href="#section-7.1">7.1</a>
                 CRLF
                 [ message-body ]          ; Section <a href="#section-7.2">7.2</a>
</pre>

<h3 id="section-6.1">6.1 ステータスライン</h3>

<p>
レスポンスメッセージの最初の行は、プロトコルのバージョン、ステータスコード番号、それに関連したテキストフレーズからなるステータスラインで、それぞれの要素は、SP によって分けられる。
最後の CRLF シーケンス以外には、CR も LF も許されない。 
</p>

<pre> Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
</pre>

<h4 id="section-6.1.1">6.1.1 ステータスコードと説明句</h4>

<p>
ステータスコード要素とは、リクエストを理解し満足するための試行についての三桁の数字による結果コードである。
これらのコードは、section <a href="#section-10">10</a> にて完全に定義されている。
説明句は、ステータスコードについて短いテキスト記述を与える目的を持つ。
ステータスコードは自動処理によって、また説明句は人間によってそれぞれ使われる事を意図している。
クライアントは、説明句を調べたり表示したりする必要はない。
</p>

<p>
ステータスコードの最初の数字はレスポンスのクラスを定義する。
後ろの二つの数字はどんな分類規定も持たない。
最初の数字には五つの値がある。
</p>

<ul>
<li><code>1xx: Informational</code> - リクエストは受け入れられ、処理を続けている</li>
<li><code>2xx: Success</code> - 動作は正常に受信され、理解され、受け入れられた</li>
<li><code>3xx: Redirection</code> - リクエストを完了するためには、さらに動作を行わなければならない</li>
<li><code>4xx: Client Error</code> - リクエストは間違った構文か、果たす事のできないものを含んでいる</li>
<li><code>5xx: Server Error</code> - サーバは明白に明らかにリクエストを果たすのに失敗した</li>
</ul>

<p>
HTTP/1.1 で定義された個々のステータスコード数値、及びそれに相当する説明句のセットの例の値を以下に示す。
ここでリストされた説明句は推奨に過ぎない。
すなわち、これらはプロトコルに影響が出ないローカルな範囲で、それに相当するものに置き換えても<em>よい</em>。
</p>

<pre> Status-Code=
      &quot;100&quot;  ; Section <a href="#section-10.1.1">10.1.1</a>: Continue
    | &quot;101&quot;  ; Section <a href="#section-10.1.2">10.1.2</a>: Switching Protocols
    | &quot;200&quot;  ; Section <a href="#section-10.2.1">10.2.1</a>: OK
    | &quot;201&quot;  ; Section <a href="#section-10.2.2">10.2.2</a>: Created
    | &quot;202&quot;  ; Section <a href="#section-10.2.3">10.2.3</a>: Accepted
    | &quot;203&quot;  ; Section <a href="#section-10.2.4">10.2.4</a>: Non-Authoritative Information
    | &quot;204&quot;  ; Section <a href="#section-10.2.5">10.2.5</a>: No Content
    | &quot;205&quot;  ; Section <a href="#section-10.2.6">10.2.6</a>: Reset Content
    | &quot;206&quot;  ; Section <a href="#section-10.2.7">10.2.7</a>: Partial Content
    | &quot;300&quot;  ; Section <a href="#section-10.3.1">10.3.1</a>: Multiple Choices
    | &quot;301&quot;  ; Section <a href="#section-10.3.2">10.3.2</a>: Moved Permanently
    | &quot;302&quot;  ; Section <a href="#section-10.3.3">10.3.3</a>: Found
    | &quot;303&quot;  ; Section <a href="#section-10.3.4">10.3.4</a>: See Other
    | &quot;304&quot;  ; Section <a href="#section-10.3.5">10.3.5</a>: Not Modified
    | &quot;305&quot;  ; Section <a href="#section-10.3.6">10.3.6</a>: Use Proxy
    | &quot;307&quot;  ; Section <a href="#section-10.3.8">10.3.8</a>: Temporary Redirect
    | &quot;400&quot;  ; Section <a href="#section-10.4.1">10.4.1</a>: Bad Request
    | &quot;401&quot;  ; Section <a href="#section-10.4.2">10.4.2</a>: Unauthorized
    | &quot;402&quot;  ; Section <a href="#section-10.4.3">10.4.3</a>: Payment Required
    | &quot;403&quot;  ; Section <a href="#section-10.4.4">10.4.4</a>: Forbidden
    | &quot;404&quot;  ; Section <a href="#section-10.4.5">10.4.5</a>: Not Found
    | &quot;405&quot;  ; Section <a href="#section-10.4.6">10.4.6</a>: Method Not Allowed
    | &quot;406&quot;  ; Section <a href="#section-10.4.7">10.4.7</a>: Not Acceptable
    | &quot;407&quot;  ; Section <a href="#section-10.4.8">10.4.8</a>: Proxy Authentication Required
    | &quot;408&quot;  ; Section <a href="#section-10.4.9">10.4.9</a>: Request Time-out
    | &quot;409&quot;  ; Section <a href="#section-10.4.10">10.4.10</a>: Conflict
    | &quot;410&quot;  ; Section <a href="#section-10.4.11">10.4.11</a>: Gone
    | &quot;411&quot;  ; Section <a href="#section-10.4.12">10.4.12</a>: Length Required
    | &quot;412&quot;  ; Section <a href="#section-10.4.13">10.4.13</a>: Precondition Failed
    | &quot;413&quot;  ; Section <a href="#section-10.4.14">10.4.14</a>: Request Entity Too Large
    | &quot;414&quot;  ; Section <a href="#section-10.4.15">10.4.15</a>:  Request-URI Too Large
    | &quot;415&quot;  ; Section <a href="#section-10.4.16">10.4.16</a>: Unsupported Media Type
    | &quot;416&quot;  ; Section <a href="#section-10.4.17">10.4.17</a>: Requested range not satisfiable
    | &quot;417&quot;  ; Section <a href="#section-10.4.18">10.4.18</a>: Expectation Failed
    | &quot;500&quot;  ; Section <a href="#section-10.5.1">10.5.1</a>: Internal Server Error
    | &quot;501&quot;  ; Section <a href="#section-10.5.2">10.5.2</a>: Not Implemented
    | &quot;502&quot;  ; Section <a href="#section-10.5.3">10.5.3</a>: Bad Gateway
    | &quot;503&quot;  ; Section <a href="#section-10.5.4">10.5.4</a>: Service Unavailable
    | &quot;504&quot;  ; Section <a href="#section-10.5.5">10.5.5</a>: Gateway Time-out
    | &quot;505&quot;  ; Section <a href="#section-10.5.6">10.5.6</a>: HTTP Version not supported
    | extension-code

 extension-code = 3DIGIT
 Reason-Phrase  = *&lt;CR, LF を含まない TEXT&gt;
</pre>

<p>
HTTP ステータスコードは拡張可能である。
HTTP アプリケーションは、登録されたすべてのステータスコードを明確に理解できる事が望ましいが、それらのすべての意味を理解する必要はない。
しかし、アプリケーションは最初の数字によって示されるステータスコードのクラスはすべて理解し<em>なければならない</em>し、理解できないレスポンスはキャッシュし<em>てはならない</em>という例外を除いて、すべての理解できないレスポンスをそのクラスの x00 ステータスコードと同等に扱わ<em>なければならない</em>。
例えば、431 という理解できないステータスコードがクライアントに受信されたなら、そのリクエストに何か誤りがあると安全に推測ができ、それが 400 ステータスコードを受信したかのようにレスポンスを扱う事ができる。このような場合、エンティティはこの異常なステータスを説明しているであろう人間が読める情報を含んでいると思われるから、ユーザエージェントはレスポンスと共に返されたエンティティをユーザに見せる<em>べきである</em>。
</p>

<h3 id="section-6.2">6.2 レスポンスヘッダフィールド</h3>

<p>
レスポンスヘッダフィールドを用いて、サーバはステータスラインに置けないレスポンスに関する追加的な情報を渡す事ができる。
これらのヘッダフィールドは、サーバについてや、 Request-URI によって識別されるリソースへの更なるアクセスに関する情報を与える。
</p>

<pre> response-header = Accept-Ranges           ; Section <a href="#section-14.5">14.5</a>
                 | Age                     ; Section <a href="#section-14.6">14.6</a>
                 | ETag                    ; Section <a href="#section-14.19">14.19</a>
                 | Location                ; Section <a href="#section-14.30">14.30</a>
                 | Proxy-Authenticate      ; Section <a href="#section-14.33">14.33</a>
                 | Retry-After             ; Section <a href="#section-14.37">14.37</a>
                 | Server                  ; Section <a href="#section-14.38">14.38</a>
                 | Vary                    ; Section <a href="#section-14.44">14.44</a>
                 | WWW-Authenticate        ; Section <a href="#section-14.47">14.47</a>
</pre>

<p>
レスポンスヘッダフィールド名は、プロトコルバージョンの変化に伴ってのみ確実に拡張されうる。
しかしながら、新しい、あるいは実験的なヘッダフィールドは、もしそのコミュニケーションでのすべてのパーティがそれらをレスポンスヘッダフィールドであると認識できるなら、一般的なヘッダフィールドの意味論を与えても<em>よい</em>。
認識されないヘッダフィールドは、エンティティヘッダフィールドとして扱われる。 
</p>

<h2 id="section-7">7 エンティティ</h2>

<p>
リクエストやレスポンスでのメッセージは、リクエストメソッドやレスポンスステータスコードによって規制されていなければ、エンティティを転送する事が<em>できる</em>。
エンティティは、エンティティヘッダフィールドとエンティティボディから成るが、エンティティヘッダのみを含むレスポンスもあ
る。
</p>

<p>
この章においては、送信者と受信者の両方がクライアントかサーバのどちらかを表すが、それはエンティティを送信するか受信するかに依存する。
</p>

<h3 id="section-7.1">7.1 エンティティヘッダフィールド</h3>

<p>
エンティティヘッダフィールドは、エンティティボディや、もしボディが無ければリクエストによって識別されたリソースについての外部情報を定義する。この外部情報は、<em>オプションナル</em>なものもあるが、この仕様書の中で<em>要求している</em>ものもある。
</p>

<pre> entity-header  = Allow                    ; Section <a href="#section-14.7">14.7</a>
                | Content-Encoding         ; Section <a href="#section-14.11">14.11</a>
                | Content-Language         ; Section <a href="#section-14.12">14.12</a>
                | Content-Length           ; Section <a href="#section-14.13">14.13</a>
                | Content-Location         ; Section <a href="#section-14.14">14.14</a>
                | Content-MD5              ; Section <a href="#section-14.15">14.15</a>
                | Content-Range            ; Section <a href="#section-14.16">14.16</a>
                | Content-Type             ; Section <a href="#section-14.17">14.17</a>
                | Expires                  ; Section <a href="#section-14.21">14.21</a>
                | Last-Modified            ; Section <a href="#section-14.29">14.29</a>
                | extension-header

 extension-header = message-header
</pre>

<p>
拡張ヘッダメカニズムは、プロトコルを変更する事無く追加的エンティティヘッダフィールドを定義できるようにしているが、これらのフィールドが受信者によって認識されるという事は仮定できない。
認識されないヘッダフィールドは、受信者によって無視される<em>べきであり</em>、透過的プロクシによって転送され<em>なければならない</em>。
</p>

<h3 id="section-7.2">7.2 エンティティボディ</h3>

<p>
もし、HTTP リクエストやレスポンスと共にエンティティボディが送られてきたら、それはエンティティヘッダフィールドによって定義されるフォーマットをもってエンコーディングされている。
</p>

<pre> entity-body    = *OCTET
</pre>

<p>
エンティティボディは、section <a href="#section-4.3">4.3</a> に記されるように、メッセージボディがある時のみ、メッセージの中に存在する。
エンティティボディは、メッセージの安全かつ適切な転送を保証するために適用されるであろうあらゆる転送エンコーディングをデコードする事によってメッセージボディから得られる。
</p>

<h4 id="section-7.2.1">7.2.1 タイプ</h4>

<p>
エンティティボディがメッセージに含まれる時、このボディのデータタイプは Content-Type と Content-Encoding 各ヘッダフィールドによって決定される。
これらは、2層の順列エンコーディングモデル {ordered encoding model} を定義する。
</p>

<pre> entity-body := Content-Encoding( Content-Type( data ) )
</pre>

<p>
Content-Type は、元のデータのメディアタイプを示す。Content-Encoding は、要求されたリソースが持つデータを、通常はデータ圧縮という目的のために適用されるあらゆる追加的な内容コーディングを示すために使われるであろう。
既定のエンコーディングはない。
</p>

<p>
エンティティボディを含む HTTP/1.1 メッセージは、いつでもそのボディのメディアタイプを定義するための Content-Type ヘッダフィールドを含む<em>べきである</em>。
メディアタイプが Content-Type ヘッダによって与えられない場合に限り、受信者はリソースの内容の検査や、あるいはリソースを識別するために使用されているURI の名前拡張子を調べる事によってメディアタイプを推測してみても<em>よい</em>。
もしメディアタイプが分からないままであったら、受信者はそれをタイプ &quot;application/octet-stream&quot; として扱う<em>べきである</em>。
</p>

<h4 id="section-7.2.2">7.2.2 エンティティ長</h4>

<p>
メッセージのエンティティボディ長は、あらゆる転送エンコーディングが適用される前のメッセージボディの長さである。
section <a href="#section-4.4">4.4</a> では、どのようにメッセージボディの転送長さが決められているかを定義している。
</p>

<h2 id="section-8">8 接続</h2>

<h3 id="section-8.1">8.1 持続的接続</h3>

<h4 id="section-8.1.1">8.1.1 目的</h4>

<p>
持続的接続が無い時代には、別々の URL からリソースを取得するために、それぞれで TCP 接続を確立していたため、サーバのロードを増加させ、インターネットの混雑を引き起こす原因になっていた。
インラインイメージやその他の関連するデータの使用のために、クライアントはしばしば短時間に同じサーバへ複数のリクエストを行う必要がある。
これらのパフォーマンスの問題の解析や持続的接続のプロトタイプの実装から得られた結果については、現在入手可能である <a href="#ref-26">[26]</a> <a href="#ref-30">[30]</a>。
持続的接続を実装する過程で得た経験や、実際に HTTP/1.1 (RFC 2068) を実装したものを測定した所、良い結果が得られた <a href="#ref-39">[39]</a>。
また一方で、例えば T/TCP <a href="#ref-27">[27]</a> のような、違う選択肢も研究されてきている。
</p>

<p>
持続的 HTTP 接続には、いくつかの利点がある。
</p>

<ul>
<li>
TCP コネクションの開閉が少なくなる事で、ルータやホスト (クライアント、サーバ、プロクシ、ゲートウェイ、トンネル、キャッシュ) における CPU 時間は節約され、TCP プロトコルコントロールブロックのために使用されるメモリも節約される。
</li>
<li>
HTTP リクエストとレスポンスは、接続上でパイプライン化する事ができる。
パイプライン化によって、クライアントは、各々のレスポンスを待つ事なく複数のリクエストを行う事ができ、また1つの TCP 接続をより少ない経過時間で、より効果的に使用できる。
</li>
<li>
TCP のオープンや、TCP sufficient time にネットワークの混雑状況を決定させるために使われるパケットの数の減少によって、ネットワークにおける混雑は減少される。
</li>
<li>
TCP 接続がすでに確立しているので、次回リクエスト時にはそのための時間が必要無く、リクエストへの反応時間は短縮される。
</li>
<li>
TCP 接続を閉じるという罰則無しにエラーを報告できるため、HTTP はより上品に発展する。
もし古いサーバと通信するとしても、HTTP の将来のバージョンを使用するクライアントは、楽天的に新しい機能を試みる事ができ、エラー報告の後には古い意味論が伴う再試行も報告されるであろう。
</li>
</ul>

<p>
HTTP 実装は持続的接続を実装す<em>べきである</em>。
</p>

<h4 id="section-8.1.2">8.1.2 全体の動作</h4>

<p>
HTTP/1.1 と HTTP のそれ以前のバージョンとの重要な違いは、すべての HTTP 接続において持続的な接続が既定の動作であるかどうかという事である。
すなわち、何か別の方法が示されない限り、クライアントは、例えサーバからエラーレスポンスが返されても、サーバが持続的接続を維持するであろうと仮定す<em>べきである</em>。
</p>

<p>
持続的接続は、クライアントとサーバが TCP 接続を閉じる時に合図を行えるというメカニズムを提供する。
この合図は、Connection ヘッダフィールド (section <a href="#section-14.10">14.10</a>) を用いて示す。
一度接続を閉じる事が示されたら、クライアントはその接続でそれ以上のリクエストを送っ<em>てはならない</em>。
</p>

<h5 id="section-8.1.2.1">8.1.2.1 ネゴシエーション</h5>

<p>
HTTP/1.1 サーバは、HTTP/1.1 クライアントがリクエスト中に &quot;close&quot; という connection-token を含んでいる Connection ヘッダを送られなければ、持続的接続を維持するつもりである事を想定しても<em>よい</em>。
もし、サーバがレスポンスを送信した後すぐに接続を閉じる事を選ぶのであれば、connection-token に close を含んでいる Connection ヘッダを送信す<em>べきである</em>。
</p>

<p>
HTTP/1.1 クライアントは、接続が開いたままである事を期待しても<em>よい</em>が、サーバからのレスポンスが connection-token が close である Connection ヘッダを含んでいるかどうかに基づいて回線の維持についてを決めるであろう。
クライアントがそのリクエスト以上に接続を維持する事を望まない場合は、connection-token に close を含む Connection ヘッダを送る<em>べきである</em>。
</p>

<p>
もし、クライアントかサーバのどちらかが、Connection ヘッダにおいて close トークンを送ったならば、そのリクエストはその接続に対する最後のものとなる。
</p>

<p>
クライアントやサーバは、それが明確に合図された場合以外は、1.1 よりも低い HTTP のバージョンにおいては、持続的接続が維持されていると仮定す<em>べきではない</em>。
HTTP/1.0 クライアントとの下位互換性に必要な情報については section <a href="#section-19.6.2">19.6.2</a> 参照。
</p>

<p>
持続性を維持するために、接続上のすべてのメッセージは section <a href="#section-4.4">4.4</a> で定義されているように、自身で定義した (例えばそれが接続の切断によって定義されるようなものではない) メッセージ長さを持た<em>なければならない</em>。
</p>

<h5 id="section-8.1.2.2">8.1.2.2 パイプライン化</h5>

<p>
持続的接続をサポートするクライアントは、そのリクエストを &quot;パイプライン&quot; する事が<em>できる</em> (例えば、複数のレスポンスを待つ事無く、複数のリクエストを送る)。
サーバは、リクエストが受信されたのと同じ順番で、それらのリクエストのレスポンスを返さ<em>なければならない</em>。
</p>

<p>
持続的接続を想定し、接続確立の後にすぐパイプラインを行うクライアントは、もし最初のパイプライン化への試行が失敗した場合は、それらの接続を再試行する準備をす<em>べきである</em>。
クライアントがそのような再試行を行う場合は、その接続が持続的であると分かるまではパイプラインを行っ<em>てはならない</em>。
もし、サーバがすべての通信のレスポンスを返す前に接続を閉じてしまったら、クライアントはそれらのリクエストを再送信する準備をし<em>なければならない</em>。
</p>

<p>
クライアントは、冪等でない{non-idempotent} メソッド、あるいはメソッドのシーケンスを使ったリクエストをパイプラインす<em>べきではない</em> (section <a href="#section-9.1.2">9.1.2</a> 参照)。
そうでなければ、転送接続の早期異常終了が不確定な結果を招く事になるだろう。
冪等でない{non-idempotent} リクエストを送ろうとするクライアントは、前のリクエストのレスポンスステータスを受け取るまでリクエストを送る事を待つ<em>べきである</em>。
</p>

<h4 id="section-8.1.3">8.1.3 プロクシサーバ</h4>

<p>
プロクシが section <a href="#section-14.10">14.10</a> で指定されるように Connection ヘッダの機能を
正確に実装する事は特に重要である。
</p>

<p>
プロクシサーバは、自身が接続しているクライアントとオリジンサーバ (あるいは別のプロクシサーバ) のそれぞれに持続的接続を知らせ<em>なければならない</em>。
それぞれの持続的接続は、一つの転送リンクのみで適用される。
</p>

<p>
プロクシサーバは、HTTP/1.0 クライアントと HTTP/1.1 の持続的接続を確立し<em>てはならない</em> (但し、多くの HTTP/1.0 クライアントに実装されている Keep-Alive ヘッダを使った問題の情報と議論については RFC 2068 <a href="#ref-33">[33]</a> 参照)。
</p>

<h4 id="section-8.1.4">8.1.4 現実的な考察</h4>

<p>
多くのサーバは、もはや接続を維持しないとするタイムアウト値を持っているであろう。
クライアントはたぶん同じサーバへとより多くの接続を持とうとするはずなので、プロクシサーバはサーバが設定するタイムアウト値よりも大きな値にしたほうがよい。
持続的接続の使用は、クライアントやサーバのためのこのタイムアウト値の長さ (あるいは存在) に必要性を置かない。
</p>

<p>
クライアントやサーバがタイムアウトを望む時は、転送接続上礼儀正しい切断を発行す<em>べきである</em>。
クライアントもサーバも、他方の転送の切断を絶えず監視し、適切にそれに応じる<em>べきである</em>。
もし、クライアントやサーバが、相手側の切断を即座に検出しなければ、それはネットワーク上の不必要なリソース消耗を引き起こすかもしれない。
</p>

<p>
クライアント、サーバ、あるいはプロクシは、どんな時でも転送接続を切断する事が<em>できる</em>。
例えば、サーバが &quot;アイドル&quot; 状態の接続を切断しようと決めたのと同時に、クライアントは新しいリクエストを送り始めるかもしれない。
サーバ側から見れば接続はアイドルである間に切断されているが、クライアント側から見ればリクエストは進行中である。
</p>

<p>
これは、クライアント、サーバ、プロクシが、非同期の切断状態{event} から回復でき<em>なければならない</em>という事を意味する。
クライアントソフトウェアは転送接続を再度オープンし、リクエストシーケンスが冪等{idempotent} (section <a href="#section-9.1.2">9.1.2</a> 参照) である限り、ユーザインタラクションなしに中止されたリクエストのシーケンスを再送信す<em>べきである</em>。
そうでないメソッドやシーケンスは自動的に再試行し<em>てはならない</em>が、ユーザエージェントは人間のオペレータにリクエストの再試行についての選択を尋ねても<em>よい</em>。
アプリケーションが意味を理解した上で、ユーザ自身の確認の代わりにユーザエージェントソフトウェアが確認しても<em>よい</em>。
この自動再試行は、もし二回目のリクエストシーケンスが失敗したなら繰り返す<em>べきではない</em>。
</p>

<p>
サーバは、もし完全に可能なら、常に一つの接続につき少なくとも一つのリクエストにレスポンスす<em>べきである</em>。
サーバは、ネットワークやクライアントの失敗を疑う場合以外は、レスポンスの転送中に接続を切断す<em>べきではない</em>。
</p>

<p>
持続的接続を使用するクライアントは、サーバへ維持する同時接続の数を制限す<em>べきである</em>。
シングルユーザクライアントは、どんなサーバやプロクシへも 2 接続より多く維持す<em>べきではない</em>。
プロクシは、N は同時のアクティブユーザの数として、別のサーバやプロクシへの接続使用数を多くても 2*N までとす<em>べきである</em>。
これらのガイドラインは HTTP レスポンスタイムを改善し、ネットワークの混雑を避けようとするものである。
</p>

<h3 id="section-8.2">8.2 メッセージ転送の必要条件</h3>

<h4 id="section-8.2.1">8.2.1 持続的接続とフローコントロール</h4>

<p>
HTTP/1.1 サーバは、一時的な過負荷を解消するためには、持続的接続を維持し、TCP フローコントロールメカニズムを使う<em>べきであり</em>、クライアントが再試行するであろうという期待を持って接続を終了させるよりもよい。
後者の方法ではネットワークの混雑はよりひどくなるであろう。
</p>

<h4 id="section-8.2.2">8.2.2 エラーステータスメッセージのための接続のモニタリング</h4>

<p>
メッセージボディを送る HTTP/1.1 (あるいはそれ以降) のクライアントは、リクエストを送っている間、エラーステータスのためにネットワークの接続をモニタリングす<em>べきである</em>。
エラーステータスを発見した場合、すぐにボディの転送を止める<em>べきである</em>。
もしボディに &quot;chunked&quot; エンコーディング (section <a href="#section-3.6">3.6</a>) を施していたら、早過ぎるメッセージの終わりを表すために 0 サイズのチャンクと空の trailer を使う事が<em>できる</em>。
もしボディより Content-Length ヘッダが先に送られていたら、クライアントは接続を閉じ<em>なければならない</em>。
</p>

<h4 id="section-8.2.3">8.2.3 100 (Continue) ステータスの使用</h4>

<p>
100 (Continue) ステータス (section <a href="#section-10.1.1">10.1.1</a> 参照) は、オリジンサーバがクライアントがリクエストボディを送る前に (リクエストヘッダに基づいた) リクエストを受け入れようとする場合に、リクエストボディを伴ったリクエストメッセージを送る事をクライアントに決めさせるという目的を持つ。
いくつかのケースでは、サーバがボディを見る事も無くメッセージを受けつけていない場合にクライアントがボディを送る事は、不適切でひどく効率が悪くなる事がある。
</p>

<p>
HTTP/1.1 クライアントの必要条件は、以下の通りである。
</p>

<ul>
<li>
もしクライアントがリクエストボディを送る前に 100 (Continue) レスポンスのために待とうとするならば、&quot;100-continue&quot; という expectation を持った Expect リクエストヘッダフィールド(section <a href="#section-14.20">14.20</a>) を送らなければ<em>ならない</em>。
</li>
<li>
もしリクエストボディを送るつもりが無いならば、&quot;100-continue&quot; という expectation を持った Expect リクエストヘッダフィールド(section <a href="#section-14.20">14.20</a>) を送っ<em>てはならない</em>。
</li>
</ul>

<p>
未だに古い実装が存在するため、プロトコルではクライアントが 417 (Expectation Failed) ステータスや 100 (Continue) ステータスを受け取る前に、&quot;Expect: 100-continue&quot; を送ってしまうかもしれないようなあいまいな場面を認めている。
それ故に、クライアントが 100 (Continue) ステータスを見た事が無いようなオリジンサーバ (あるいは経由するプロクシ) にこれを送るような時でも、リクエストボディを送る前に無期限で待つような事はす<em>べきではない</em>。
</p>

<p>
HTTP/1.1 オリジンサーバの必要条件は、以下の通りである。
</p>

<ul>
<li>
&quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダフィールドを含むリクエストを受け取った時は、100 (Continue) ステータスを応答し引き続き入力ストリームを読み続けるか、最終ステータスコードを応答するか、どちらかを実行し<em>なければならない</em>。
オリジンサーバは、100 (Continue) レスポンスを送る前にリクエストボディを待ってい<em>てはならない</em>。
最終ステータスコードを応答した場合は、転送接続を切断しても<em>よい</em>し、引き続き読みこんで残りのリクエストを破棄しても<em>よい</em>。
最終ステータスコードを返した場合は、そのリクエストメソッドを実行し<em>てはならない</em>。
</li>
<li>
オリジンサーバは、リクエストメッセージが &quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダを含んでいなければ 100 (Continue) レスポンスを送る<em>べきではなく</em>、リクエストが HTTP/1.0 (あるいはそれ以前) のクライアントからのものであったら、100 (Continue) レスポンスを送っ<em>てはならない</em>。
この規則には拡張がある。
すなわち、RFC 2068 との互換性のため、サーバは &quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダを含んでいない HTTP/1.1 PUT あるいは POST リクエストへのレスポンスに 100 (Continue) を送る事が<em>できる</em>。
クライアントのプロセスが 100 (Continue) ステータスのために宣言されない待機によって遅れる事を最小限にするという目的を持つこの拡張は、HTTP/1.1 リクエストにのみ適用され、他の HTTP バージョン値を持つリクエストには適用されない。
</li>
<li>
オリジンサーバは、すでにそのリクエストに関する一部、あるいは全部のリクエストボディを既に受け取っている場合、100 (Continue) レスポンスを省略する事が<em>できる</em>。
</li>
<li>
100 (Continue) レスポンスを送るオリジンサーバは、先に転送接続が切られているので無ければ、一度リクエストボディが受け取られ、処理され、最終的には最終ステータスコードを送ら<em>なければならない</em>。
</li>
<li>
オリジンサーバが &quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダフィールドを含まないリクエストを受け取ったならば、リクエストはリクエストボディを含んでいるので、サーバはその転送接続からのリクエストボディ全体を読みきる前に最終ステータスコードを返すが、リクエスト全体を読みきるまで、あるいはクライアントがその接続を切断するまでは、サーバは、その転送接続を切断す<em>べきではない</em>。
そうしなければ、クライアントは確実にレスポンスメッセージを受け取れないかもしれない。
しかし、この必要条件はサーバがサービス不能攻撃{denial-of-service attacks} やひどく破綻したクライアント実装から、己の身を守る事を妨げるようには作られてはいない。
</li>
</ul>

<p>
HTTP/1.1 プロクシの必要条件は、以下の通りである。
</p>

<ul>
<li>
プロクシが &quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダフィールドを含むリクエストを受け取った時に、プロクシが次に接続する{next-hop} サーバが HTTP/1.1 以上に従っている事を知っている、あるいは次に接続するサーバの HTTP バージョンを知らない場合には、Expect ヘッダフィールドを含めて、リクエストを転送し<em>なければならない</em>。
</li>
<li>
プロクシが、次に接続するサーバが HTTP/1.0 以下のバージョンである事を知っていたら、そのリクエストは転送せずに、417 (Expectation Failed) ステータスを返さ<em>なければならない</em>。
</li>
<li>
プロクシは、最近参照したネクストホップサーバから受け取った HTTP バージョン番号をキャッシュに記録し保管す<em>べきである</em>。
</li>
<li>
プロクシは、HTTP/1.0 (あるいはそれ以前) のクライアントから受け取り、そこに &quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダフィールドを含んでいないリクエストメッセージは、100 (Continue) レスポンスを転送し<em>てはならない</em>。
この必要条件は、1xx レスポンス (section <a href="#section-10.1">10.1</a> 参照) を転送するという一般規則を上書きする。
</li>
</ul>

<h4 id="section-8.2.4">8.2.4 サーバが早まって接続を閉じた場合のクライアントの振る舞い</h4>

<p>
もし、HTTP/1.1 クライアントがリクエストボディを持つが、&quot;100-continue&quot; という expectation を持つ Expect リクエストヘッダフィールドを含んでいないリクエストメッセージを送り、しかもクライアントは HTTP/1.1 オリジンサーバには直接接続はしておらず、そこでクライアントがサーバからのどんなステータスをも受け取る前に接続の切断を知った場合は、クライアントはリクエストを再試行す<em>べきである</em>。
クライアントがこのリクエストを再試行する時は、確実なレスポンスの獲得を保証させるため、以下の &quot;binary exponential backoff&quot; アルゴリズムを使用<em>できる</em>。
</p>

<ol>
<li>サーバへの接続を初期化する</li>
<li>リクエストヘッダを転送する</li>
<li>サーバへと見積もった round-trip time (つまり、その接続を確立するためにかかった時間に基づいているもの) か、あるいは round-trip time が利用できい場合は定数値である 5 秒で変数 R を初期化する。</li>
<li>T = R * (2**N) を計算する。この時、N はこのリクエストの前までの試行回数である。</li>
<li>サーバからのエラーレスポンスが来るか、もしくは T 秒 (どちらかが来るまで) 待つ</li>
<li>エラーレスポンスが受信されなければ、T 秒後にリクエストのボディを転送する。</li>
<li>クライアントは、コネクションが早まって切断されたのを知ったならば、リクエストが受け入れられ、エラーレスポンスを受け取るか、ユーザが待ちかねて再試行プロセスを終了するまで、ステップ 1 から繰り返す。</li>
</ol>

<p>
上のどの時点でも、エラーステータスを受けとったら、クライアントは
</p>

<ul>
<li>続ける<em>べきではない</em>し</li>
<li>もしリクエストメッセージを完全に送信していなければ、接続を切断す<em>べきである</em>。</li>
</ul>

<h2 id="section-9">9 メソッド定義</h2>

<p>
HTTP/1.1 のための一般的なメソッドのセットは以下に定義される。
このセットは拡張可能であるが、追加されるメソッドは別々に拡張されたクライアントとサーバに対して同じ意味論を共有する事を仮定できない。
</p>

<p>
Host リクエストヘッダフィールド(section <a href="#section-14.23">14.23</a>) は、すべての HTTP/1.1 リクエストに付加され<em>なければならない</em>。
</p>

<h3 id="section-9.1">9.1 安全{safe} なメソッドと冪等{idempotent} なメソッド</h3>

<h4 id="section-9.1.1">9.1.1 安全{safe} なメソッド</h4>

<p>
実装者は、インターネット上における相互動作においてはソフトウェアがユーザを表しているという事を認識すべきであり、ユーザがそれら自身や他のものに対して予測しない意図を持つようなあらゆる動作に気がつく事ができるように注意すべきである。
</p>

<p>
特に、GET と HEAD メソッドはその動作にリソースの回収以上の意味を持つ<em>べきではない</em>という慣習が確立されている。
これらのメソッドは、&quot;安全{safe}&quot; だと考えるべきである。
これによって、ユーザエージェントがそれ以外の、例えば POST, PUT, DELETE のようなメソッドを特別な方法で表す事ができるようになり、ユーザにひょっとしたら安全でない動作が要求されているかもしれないという事実を認識させる。
</p>

<p>
本質的に、サーバが GET リクエストを実行した結果として副作用を起こさないという事を保証するのは不可能であり、事実、いくつかの動的なリソースはそれが特徴であると考えている。
ここで特に区別すべきなのは、ユーザが副作用を要求しなかったという事であり、それゆえにそれらに対しては責任をもてない。
</p>

<h4 id="section-9.1.2">9.1.2 冪等{idempotent} なメソッド</h4>

<p>
メソッドは、(エラーや期限切れ発行とは別に) 同一のリクエストの N &gt; 0 の副作用が単一のリクエストにおけるものと同じであるような際には &quot;冪等{idempotence}&quot; の性質を持つ事もできる。
GET, HEAD, PUT, DELETE 各メソッドはこの性質を共有する。
また、OPTIONS と TRACE 各メソッドは副作用を持つ<em>べきではない</em>し、本来冪等であるものである。
</p>

<p>
しかしながら、たとえその順序にて実行される全てのメソッドが冪等であったとしても、いくつかのリクエストの順番は冪等ではない。
(もし全体の順序中のある一つを実行しても、その順序の全体、または一部分を再実行した際に結果は常に変わらないという事になるのであれば、順序は冪等である。)
例えば、同じ順序でもその結果が後に修正される値に依存するのであれば、順序は冪等ではない。
</p>

<p>
副作用を持たない順序は、(同時に起こる動作は同じリソースの一組{set} 上に実行されている事は無い、との条件で) 定義によって冪等である。
</p>

<h3 id="section-9.2">9.2 OPTIONS</h3>

<p>
OPTIONS メソッドは、 Request-URI によって識別されるリクエスト/レスポンス連鎖上で利用可能な通信オプションについての情報のためのリクエストを表す。
クライアントは、このメソッドはを使ってリソースアクションを暗に意味したりリソース回収を初期化する事なしに、リソースやサーバの能力に関するオプションや必要条件を決定する事ができる。
</p>

<p>
このメソッドへのレスポンスはキャッシュ可能ではない。
</p>

<p>
もし OPTIONS リクエストが (Content-Length や Transfer-Encoding の存在によって指し示される様な) エンティティボディを含むならば、そのメディアタイプは Content-Type フィールドによって指し示され<em>なければならない</em>。
この特性は、そのようなエンティティボディのいかなる使用方法も決定しないが、HTTP の将来的な拡張によってそのサーバについてのより詳細な情報文字列を作るために OPTIONS のボディを使うかもしれない。
そのような拡張機能をサポートしていないサーバでは、リクエストボディを廃棄する<em>かもしれない</em>。
</p>

<p>
もし、 Request-URI がアスタリスク (&quot;*&quot;) なら、OPTIONS リクエストは特定のリソースへというよりも全体としてサーバへ適用する意思を示す。
サーバのコミュニケーションオプションは典型的にリソースに依存するので、&quot;*&quot; リクエストは、まるで &quot;ping&quot; や &quot;no-op&quot; のように使われるのみで、すなわちサーバの能力をテストするする事をクライアントに許可する以上には意味を持たない。
例えば、これはプロクシに HTTP/1.1 に従っているか (あるいはその機能が欠けているか) をテストするために使われる。
</p>

<p>
もし、 Request-URI が アスタリスクでなければ、OPTIONS リクエストはそのリソースと通信する時に利用可能なオプションのみを尋ねる。
</p>

<p>
200 レスポンスには、サーバによって実装され、そのリソースに適用できる追加的機能を示すためのヘッダフィールド (例えば、Allow) や、可能であればこの仕様書で定義されていないような拡張も含む<em>べきである</em>。
もしレスポンスボディがあれば、それは通信オプションについての情報も含む<em>べきである</em>。
そのようなボディのフォーマットはこの仕様書では定義されないが、将来の HTTP の拡張によって定義されるかもしれない。
適切なレスポンスフォーマットを選択するために、内容ネゴシエーションを使う事が<em>できる</em>。
もしレスポンスボディが含まれていなければ、そのレスポンスは &quot;0&quot; という field-value を持つ Content-Length フィールドを含ま<em>なければならない</em>。
</p>

<p>
Max-Forwards リクエストヘッダフィールドは、リクエスト連鎖中で特定のプロクシを目標に使われるで<em>あろう</em>。
プロクシは、転送が許可されたリクエストのための absoluteURI と共に OPTIONS リクエストを受けとった時には、Max-Forwards フィールドをチェックし<em>なければならない</em>。
もし、Max-Forwards フィールドの値がゼロ (&quot;0&quot;) ならば、プロクシはそのメッセージを転送し<em>てはならない</em>。
その代わりに、プロクシ自身のコミュニケーションオプションを返す<em>べきである</em>。
もし、Max-Forwards フィールドの値がゼロより大きな整数値ならば、プロクシはリクエストを転送する際にその値を一つ減らさ<em>なければならない</em>。
リクエストの中に Max-Forwards フィールドが存在していなければ、転送するリクエストに Max-Forwards フィールドを含め<em>てはならない</em>。
</p>

<h3 id="section-9.3">9.3 GET</h3>

<p>
GET メソッドは、 Request-URI で識別される (エンティティ形式の) 情報ならなんでも回収する事を意味する。
もし、 Request-URI がデータ生産プロセス{data-producing process} を参照するのであれば、それはレスポンスのエンティティとして返されるであろうとして生産されるデータであり、もしそのテキストがプロセスの出力として生じるのでなければ、プロセスのソーステキストではない。
</p>

<p>
リクエストメッセージに If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, If-Range のいずれかのヘッダフィールドを含んでいる場合、GET メソッドの意味論は条件付き GET に変わる。
条件付き GET メソッドは、エンティティがその条件付きヘッダフィールドによって表される状況下でのみ転送されるようにリクエストする。
条件付き GET メソッドは、キャッシュされるエンティティに複数のリクエストを要求する事や、クライアントによってすでに保持されているデータを転送する事無く清新できるようにする事で、不必要なネットワークの使用を減らそうというものである。
</p>

<p>
リクエストメッセージに Range ヘッダフィールドを含んでいる場合、GET メソッドの意味論は &quot;部分的 GET&quot; に変わる。
部分的 GET は、section <a href="#section-14.35">14.35</a> で示されるように、転送されるエンティティの一部のみを要求する。
部分的 GET メソッドは、クライアントによって既に保持されているデータを転送する事無くエンティティを部分的に取得させて、完全なものにできるようにする事で、不必要なネットワークの使用を減らそうというものである。
</p>

<p>
GET リクエストへのレスポンスは、section <a href="#section-13">13</a> に示されるような HTTP キャッシングのための必要条件がそろった場合にのみ、キャッシュ可能となる。
</p>

<p>
フォームを使った場合のセキュリティの考察については、section <a href="#section-15.1.3">15.1.3</a> を見よ。
</p>

<h3 id="section-9.4">9.4 HEAD</h3>

<p>
HEAD メソッドは、サーバがレスポンスにおいてメッセージボディを返し<em>てはならない</em>事を除けば GET と同一である。
HEAD リクエストへのレスポンスにおける HTTP ヘッダに含まれる外部情報は、GET リクエストへのレスポンスで送られる情報と同一である<em>べきである</em>。
このメソッドは、エンティティボディ自身を転送する事なしにリクエストによって意味されるエンティティに付いての外部情報を得るために使用される。
このメソッドは、ハイパーテキストリンクの正当性、アクセス可能性、最近の修正のテストのために、しばしば使用される。
</p>

<p>
HEAD リクエストへのレスポンスは、そのレスポンスに含まれる情報はリソースから前もってキャッシュされたエンティティを更新するために使う事が<em>できる</em>、という意味でキャッシュ可能である<em>かもしれない</em>。
もし、新しいフィールド値がキャッシュされたエンティティは (Content-Length, Content-MD5, ETag, Last-Modified 各値の変更によって示されるように) 現在のエンティティと違うという事を示すならば、キャッシュはそのキャッシュエンティティを新鮮でないものとして扱わ<em>なければならない</em>。
</p>

<h3 id="section-9.5">9.5 POST</h3>

<p>
POST メソッドは、サーバがリクエストライン内の Request-URI により識別されるリソースへの新しい従属{subordinate} として、リクエストに同封されるエンティティを受け入れる事を要求するために使用される。
POST は以下の機能のカバーするための画一的メソッドとして設計されている。
</p>

<ul>
<li>既存リソースの注釈</li>
<li>掲示板、ニュースグループ、メーリングリスト、あるいはその類の記事グループへのメッセージの投稿</li>
<li>フォーム提出の結果のような、データ処理プロセス {data-handling process} へのデータブロックの供給</li>
<li>追加動作を通したデータベースの拡張</li>
</ul>

<p>
POST メソッドによって実行される実際の機能はサーバによって決定され、通常は Request-URI に依存する。
ポストされたエンティティは、ファイルがディレクトリに従属し、ニュース記事がそれがポストされたニュースグループに従属し、レコードがそのデータベースに従属しているという事と同じ形で、その URI に従属する。
</p>

<p>
POST メソッドによって実行される動作は、URI によって識別されうるリソースという結果にはならないかもしれない。
この場合、200 (OK) か 204 (No Content) が適切なレスポンスステータスであり、それはレスポンスが結果を記述したエンティティを含んでいるかどうかに依存する。
</p>

<p>
リソースがオリジンサーバで既に生成されている場合、レスポンスは 201 (Created) であり、リクエストのステータス、新しいリソースへの参照、Location ヘッダ (section <a href="#section-14.30">14.30</a>) を記述したエンティティを含む<em>べきである</em>。
</p>

<p>
レスポンスが適切な Cache-Control や Expires ヘッダフィールドを含んでいなければ、このメソッドのレスポンスはキャッシュ可能ではない。
しかしながら、303 (See Other) レスポンスは、ユーザエージェントにキャッシュ可能なリソースの検索を指示するために使用される。
</p>

<p>
POST リクエストは、section <a href="#section-8.2">8.2</a> にあるメッセージ転送要求に従わ<em>なければならない</em>。
</p>

<p>
セキュリティの考察については、section <a href="#section-15.1.3">15.1.3</a> 参照。
</p>

<h3 id="section-9.6">9.6 PUT</h3>

<p>
PUT メソッドは、同封されたエンティティを供給される Request-URI の元に保存するように要求する。
 Request-URI が既に存在するリソースを参照している場合は、同封されるエンティティはオリジンサーバにあるそれの修正版とみなされる<em>べきである</em>。
 Request-URI が既存のリソースを指していない場合に、その URI がリクエストしているユーザエージェントによって新しいリソースとして定義する事ができる時は、オリジンサーバはその URI にリソースを作成できる。
新しいリソースが作成された場合、オリジンサーバは 201 (Created) レスポンスをもってユーザエージェントに知らせ<em>なければならない</em>。
既存のリソースが更新された場合は、リクエストが成功し終了した事を示すために 200 (OK) か 204 (No Content) のいずれかのレスポンスコードを送る<em>べきである</em>。
もし、リソースがそのリクエスト URI に作成、あるいは更新されなかった時は、問題の本質を反映する適切なエラーレスポンスが与えられる<em>べきである</em>。
エンティティを受ける側は、理解できなかったり実装していないようないかなる Content-* ヘッダ (例えば Content-Range 等) も無視してはならず、そのような場合には 501 (Not Implemented) レスポンスを返さ<em>なければならない</em>。
</p>

<p>
リクエストがキャッシュを通り抜けたり、 Request-URI が現在キャッシュされている一つ以上のエンティティを識別する場合、これらのエンティティは新鮮でないものとして扱われる<em>べきである</em>。
このメソッドのレスポンスはキャッシュできない。
</p>

<p>
リクエスト POST と PUT とでの根本的な違いは、 Request-URI の意味の違いをもたらす。
POST リクエストにおける URI は、同封されたエンティティを処理するであろうリソースを識別する。
リソースは、データ受諾プロセス{data-accepting process} か、ある別のプロトコルへのゲートウェイ、あるいは注釈を受け入れる分割されたエンティティであろう。
それに対して、PUT リクエストにおける URI は、リクエストとともに同封されたエンティティを識別する。
しかし、ユーザエージェントがリソースにその URI を割り当てるつもりであっても、サーバはそのリクエストをある別のリソースへと割り当てようとし<em>てはならない</em>。
そのリクエストを別の URI に申しこむように要求する時は、サーバは 301 (Moved Permanently) レスポンスを返さ<em>なければならない</em>。
この時、ユーザエージェントはそのリクエストをリダイレクトするかどうかに関して決める事が<em>できる</em>。
</p>

<p>
単一のリソースが、多くの異なった URI によって識別される<em>かもしれない</em>。
例えば、ある記事が各々のバージョンを識別する URI とは別に、&quot;最新のバージョン&quot; を識別するための URI を持っているかもしれない。
この場合、一般の URI への PUT リクエストは、オリジンサーバによって定義されているいくつかの他の URI へと行われるはずである。
</p>

<p>
HTTP/1.1 では、PUT メソッドがオリジンサーバの状態にどのように影響を及ぼすかは定義しない。
</p>

<p>
PUT リクエストは、section <a href="#section-8.2">8.2</a> にあるメッセージ転送要求に従わ<em>なければならない</em>。
</p>

<p>
特定のエンティティヘッダが別の方法では指定できない場合、PUT リクエストにおけるエンティティヘッダは、PUT によって作成、あるいは修正されたリソースに適用される<em>べきである</em>。
</p>

<h3 id="section-9.7">9.7 DELETE</h3>

<p>
DELETE メソッドは、オリジンサーバが Request-URI により識別されるリソースを削除する事を要求する。
このメソッドは、オリジンサーバにおいて人間の手 (あるいは別の方法) によって上書きされている<em>かもしれない</em>。
例えオリジンサーバから返されたステータスコードは動作がうまく完了したという事を示していたとしても、クライアントはその操作が実行された事は保証されない。
しかしそのレスポンスが与えられた場合に、サーバがそのリソースを削除したり、アクセスできない場所へ移動したりしようとしていないのであれば、成功を示す<em>べきではない</em>。
</p>

<p>
成功したレスポンスは、もしレスポンスがステータスで表しているエンティティを含んでいるなら 200 (OK)、もし動作がまだ行われていないなら 202 (Accepted)、もし動作は行われたが、レスポンスにエンティティを含んでいないなら 204 (No Content) である<em>べきである</em>。
</p>

<p>
もし、リクエストがキャッシュを通り抜けたり、 Request-URI が現在キャッシュされている一つ以上のエンティティとして識別されるなら、これらのエンティティは新鮮でないものとして扱われる<em>べきである</em>。
このメソッドのレスポンスはキャッシュできない。
</p>

<h3 id="section-9.8">9.8 TRACE</h3>

<p>
TRACE メソッドは、リクエストメッセージのアプリケーション層のループバックを遠隔的に発動するために使用される。
リクエストの最後の受信者は、200 (OK) レスポンスのエンティティボディとして、そのメッセージをクライアントにそのまま送り返す<em>べきである</em>。
最後の受信者とは、オリジンサーバ、もしくはリクエストで Max-Forwards (section <a href="#section-14.31">14.31</a>) 値がゼロ (0) であったものを受け取った最初のプロクシかゲートウェイである。
TRACE リクエストはエンティティを含ん<em>ではならない</em>。
</p>

<p>
TRACE を使って、クライアントはリクエスト連鎖の反対側では何が受け取られているのかを見る事や、テストや診断情報のためのデータを使用する事ができる。
これはリクエスト連鎖のトレースとして動作するので、Via ヘッダフィールド (section <a href="#section-14.45">14.45</a>) の値が特に重要である。
Max-Forwards ヘッダフィールドを使用する事で、クライアントにリクエスト連鎖の大きさに制限を与える事ができ、これは無限ループ上でメッセージを転送するプロクシ連鎖をテストするために有用である。
</p>

<p>
もしリクエストが妥当ならば、レスポンスは &quot;message/http&quot; という Content-Type と一緒に、エンティティボディとしてリクエストメッセージの全体を含む<em>べきである</em>。
このメソッドのレスポンスはキャッシュされ<em>てはならない</em>。
</p>

<h3 id="section-9.9">9.9 CONNECT</h3>

<p>
この仕様書では、(例えば SSL トンネリング <a href="#ref-44">[44]</a> 等の) トンネルとなるように動的に切り換える事ができるプロクシが使用する時のために CONNECT というメソッド名を予約する。
</p>

<h2 id="section-10">10 ステータスコード定義</h2>

<p>
各々のステータスコードについて、レスポンス時に後に従える事の出来るメソッドと必要とされるすべての外部情報の記述と共に、以下に記述する。
</p>

<h3 id="section-10.1">10.1 Informational 1xx</h3>

<p>
このステータスコードのクラスは一時的なレスポンスを示し、ステータスラインとオプション的なヘッダからのみなり、空行で終了する。
このステータスコードのクラスのための必要なリクエストヘッダは無い。
HTTP/1.0 では、どんな 1xx ステータスコードも定義していないので、サーバは実験的な状況下以外では HTTP/1.0 クライアントに 1xx レスポンスを送っ<em>てはならない</em>。
</p>

<p>
クライアントは、例え 100 (Continue) ステータスメッセージを期待していなかったとしても、通常のレスポンスの前の一つ以上の 1xx レスポンスを受け入れるよう準備されてい<em>なければならない</em>。
ユーザエージェントは、期待していない 1xx レスポンスを無視する事が<em>できる</em>。
</p>

<p>
プロクシは、もしプロクシとクライアント間の接続が切断されている、あるいはプロクシ自身が 1xx レスポンスの生成を要求したという場合以外は、1xx レスポンスを転送しなければならない。
(例えば、プロクシがリクエストを転送する時に &quot;Expect: 100-continue&quot; というフィールドを付け加えた時には、それに相当する 100 (Continue) レスポンスを転送する必要はない。)
</p>

<h4 id="section-10.1.1">10.1.1 100 Continue</h4>

<p>
クライアントは、そのリクエストを続ける<em>べきである</em>。
この暫定的レスポンスは、リクエストの始めの部分は受け取られ、サーバによって拒否されたものではないという事をクライアントに知らせるために使用される。
クライアントは、リクエストの残りを送り続けるか、もし既にリクエストが完了していれば、このレスポンスを無視す<em>べきである</em>。
サーバは、リクエストが完了した後に最終的なレスポンスを送ら<em>なければならない</em>。
このステータスコードの使用・処理の詳細な議論のために section <a href="#section-8.2.3">8.2.3</a> 参照。
</p>

<h4 id="section-10.1.2">10.1.2 101 Switching Protocols</h4>

<p>
サーバはクライアントのリクエストを理解し、Upgrade メッセージヘッダフィールド (section <a href="#section-14.42">14.42</a>) を使って、この接続で使用されているアプリケーションプロトコルを変更する事でこのリクエストに従おうとしている。
サーバは 101 レスポンスを終了する空行のあと、直ちにレスポンスの Upgrade ヘッダフィールドによって定義されたプロトコルに変更するだろう。
</p>

<p>
プロトコルは、変更した方が有益な場合にのみ変更される<em>べきである</em>。
例えば、HTTP のより新しいバージョンに変更するという事は、古いバージョン以上に有益だし、リアルタイムに、同期するプロトコルを変更する事はそのような機能を使うリソースを配布するときに都合が良いだろう。
</p>

<h3 id="section-10.2">10.2 Successful 2xx</h3>

<p>
このステータスコードのクラスは、クライアントのリクエストがうまく受信され、理解され、そして受け入れられた事を示す。
</p>

<h4 id="section-10.2.1">10.2.1 200 OK</h4>

<p>
リクエストは成功した。
レスポンスと共に返される情報はリクエストに使用されたメソッドに依存し、例えば以下の様になる。
</p>

<dl>
<dt>GET</dt>
<dd>リクエストされたリソースに対応するエンティティがレスポンスとして送られる。</dd>
<dt>HEAD</dt>
<dd>リクエストされたリソースに対応するエンティティヘッダフィールドがメッセージボディを伴わずにレスポンスとして送信される。</dd>
<dt>POST</dt>
<dd>動作の結果を記述もしくは含んでいるエンティティ</dd>
<dt>TRACE</dt>
<dd>端末サーバによって受信されたリクエストメッセージを含んでいるエンティティ</dd>
</dl>

<h4 id="section-10.2.2">10.2.2 201 Created</h4>

<p>
リクエストは果たされ、結果として新しいリソースが作成された。
新しく作成されたリソースは Location ヘッダにより与えられるリソースに対する最も明確な URI を伴って、レスポンスのエンティティにおいて返される URI によって参照される。
レスポンスは、ユーザあるいはユーザエージェントが最も適切なものを選択するために、リソースの特徴と場所のリストをエンティティとして含む<em>べきである</em>。
エンティティのフォーマットは、Content-Type ヘッダフィールドにて与えられるメディアタイプによって指定される。
オリジンサーバは、201 ステータスコードを返す前にリソースを作成し<em>なければならない</em>。
もし動作がすぐに実行できないのであれば、サーバは代わりに 202 (Accepted) レスポンスを返す<em>べきである</em>。
</p>

<p>
201 レスポンスは、作成されたばかりのリクエストされたバリアントのために、現在のエンティティタグの値を示す ETag レスポンスヘッダフィールドを含む事が<em>できる</em>。
section <a href="#section-14.19">14.19</a> 参照。
</p>

<h4 id="section-10.2.3">10.2.3 202 Accepted</h4>

<p>
リクエストは処理のために受け入れられたが、処理は完了されていない。
このリクエストは、実際に処理される時に拒否されるかもしれないので、最終的に動作されるかどうかは不明である。
このような非同期操作からステータスコードを再送信するための機能は存在しない。
</p>

<p>
202 レスポンスは、意図的に責任を持たない{non-committal}。
これはサーバが、プロセスが完了されるまでユーザエージェントとの接続を持続させる事無く、他のいくつかのプロセス (多分一日に一度しか実行されないバッチ指向プロセス{batch-oriented process}) のためのリクエストを受け入れる事を可能にするという目的を持つ。
このレスポンスによって返されるエンティティは、リクエストの現在の状態を表すものと、状態モニタへのポインタ、あるいはそのリクエストがいつ果たされるかをユーザが予期できる見積もりのどちらかを含む<em>べきである</em>。
</p>

<h4 id="section-10.2.4">10.2.4 203 Non-Authoritative Information</h4>

<p>
エンティティヘッダにおいて返された外部情報は、オリジンサーバから利用できるような決定的なセットではなく、ローカルもしくはサードパーティコピーから集められたものである。
提示されたセットは元のバージョンのサブセットかスーパーセットで<em>あろう</em>。
例えば、リソースについてのローカルな注釈情報を含む事はオリジンサーバによって知らされる外部情報のスーパーセットとなるかもしれない。
そのレスポンスが 200 (OK) とは別の方法で示したい場合、このレスポンスコードを使用する必要はないが、そのような場合にのみ適切である。
</p>

<h4 id="section-10.2.5">10.2.5 204 No Content</h4>

<p>
サーバはリクエストを受け入れたが、エンティティボディを送り返す必要は無く、更新された外部情報を返す事を望むだろう。
レスポンスは、エンティティヘッダ形式の中に、新規あるいは更新された外部情報を含む事が<em>でき</em>、もしあればリクエストされたバリアントが関連付けられる<em>べきである</em>。
</p>

<p>
もしクライアントがユーザエージェントなら、リクエストの送信をもたらした状態からその文書画面{view} を変える<em>べきではない</em>。
このレスポンスは主に、ユーザエージェントの現在の{active} 文書画面ビューを変える事無く、動作を起こすための入力をさせる意図を持つが、どんな新規あるいは更新された外部情報もユーザエージェントの現在の画面中にある現在の文書に適用される<em>べきである</em>。
</p>

<p>
204 レスポンスは メッセージボディを含ん<em>ではならない</em> ので、常にヘッダフィールドの後の最初の空行で終了する。
</p>

<h4 id="section-10.2.6">10.2.6 205 Reset Content</h4>

<p>
サーバはリクエストを受け入れたので、ユーザエージェントは送信されたリクエストをもたらした現在の画面をリセットす<em>べきである</em>。
このレスポンスは主に、ユーザが別の入力動作を簡単に始められるように、入力が与えられたフォームをクリアして、ユーザの入力経由で動作を起こすための入力をさせる意図を持つ。
レスポンスはエンティティを含ん<em>ではならない</em>。
</p>

<h4 id="section-10.2.7">10.2.7 206 Partial Content</h4>

<p>
サーバはリソースに対する部分的 GET リクエストを受け入れた。
リクエストは、望む範囲を示すための Range ヘッダフィールド (section <a href="#section-14.35">14.35</a>) を含め<em>なければならない</em>し、またリクエストを条件付きにしたいければ If-Range ヘッダフィールド (section <a href="#section-14.27">14.27</a>) を含んだ方が<em>よい</em>。
</p>

<p>
レスポンスは、以下のヘッダフィールドを含め<em>なければならない</em>。
</p>

<ul>
<li>このレスポンスに含まれる範囲を示す Content-Range ヘッダフィールド (section <a href="#section-14.16">14.16</a>) か、それぞれの部分に Content-Range フィールドを含む multipart/byteranges という Content-Type のどちらか。
このレスポンスにて Content-Length ヘッダフィールドが送られた場合、その値はメッセージボディで転送される OCTET の実際の数と一致し<em>なければならない</em>。</li>
<li>Date</li>
<li>もしそのヘッダが、同じリクエストに対して 200 レスポンス を返すであろう場合は ETag, Content-Location のうち一つ以上</li>
<li>もしフィールド値が、同じバリアントのための以前のレスポンスで送られたものと異なるならば、Expires, Cache-Control, Vary のうち一つ以上</li>
</ul>

<p>
もし 206 レスポンスが、強いキャッシュバリディタ (section <a href="#section-13.3.3">13.3.3</a> 参照) を使った If-Range リクエストの結果ならば、レスポンスは他のエンティティヘッダを含める<em>べきではない</em>。
もし、レスポンスが弱いバリディタを使った If-Range リクエストの結果がとしたら、レスポンスは他のエンティティヘッダを含め<em>てはならない</em>。
これはキャッシュされたエンティティボディと更新されたエンティティヘッダとの不一致を避ける為である。
そうで無ければ、レスポンスは同じリクエストに対して 200 (OK) レスポンスと共に返されたであろうすべてのエンティティヘッダを含め<em>なければならない</em>。
</p>

<p>
もし ETag か Last-Modified ヘッダが正確に一致しなければ、キャッシュは他の以前キャッシュされた要素と 206 レスポンスとを結びつけ<em>てはならない</em>。
section <a href="#section-13.5.4">13.5.4</a> 参照。
</p>

<p>
Range や Content-Range ヘッダをサポートしていないキャッシュは、206 (Partial) レスポンスをキャッシュし<em>てはならない</em>。
</p>

<h3 id="section-10.3">10.3 Redirection 3xx</h3>

<p>
このステータスコードのクラスは、リクエストを果たすためにはユーザエージェントによって更なる動作が行われる必要がある事を示す。
二番目のリクエストで使われたメソッドが GET か HEAD である場合にのみ、ユーザとの相互動作無しに、ユーザエージェントによって要求された動作を実行する事が<em>できる</em>。
リダイレクションループによって各々のリダイレクションはネットワーク渋滞を生み出す事になるので、クライアントは無限リダイレクションループを発見す<em>べきである</em>。
</p>

<p class="note">
注: この仕様書の前のバージョンでは、5 回のリダイレクションを最大として推奨している。
内容開発者{Content developers} は、そのような修正された制限を実装したクライアントがあるであろう事を意識すべきである。
</p>

<h4 id="section-10.3.1">10.3.1 300 Multiple Choices</h4>

<p>
リクエストされたリソースは、表現セットの一つに対応し、各々が特有の場所にあり、エージェント駆動型ネゴシエーション情報 (section <a href="#section-12">12</a>) が、ユーザ (あるいはユーザエージェント) が望む表現を選択でき、その位置にリクエストをリダイレクトできるように供給されている。
</p>

<p>
もし HEAD リクエストでなければ、レスポンスはエンティティにユーザかユーザエージェントが最も適切なものを選択するためのリソースの特徴と場所のリストを含む<em>べきである</em>。
エンティティのフォーマットは、Content-Type ヘッダフィールドにて与えられるメディアタイプによって指定される。
データフォーマットやユーザエージェントの能力に依存する事なので、最も適切な選択は自動的に行われる<em>かもしれない</em>。
しかし、この仕様書ではそのような自動選択に対してどのような標準も定義しない。
</p>

<p>
サーバが選択された表現を持っているのであれば、Location フィールド内にその表現のための具体的な URI を含む<em>べきである</em>。
ユーザエージェントは、自動リダイレクションのためにその Location フィールドの値を使う事が<em>できる</em>。
このレスポンスは、別のものを示しているのでなければキャッシュ可能である。
</p>

<h4 id="section-10.3.2">10.3.2 301 Moved Permanently</h4>

<p>
リクエストされたリソースは新しい恒久的な URI に割り当てられたので、以降そのリソースへの参照は返された URI の一つを使用す<em>べきである</em>。
リンク編集機能を持つクライアントは、可能であればサーバにより返された新しい参照の一つ以上の Request-URI を参照するように自動的に再リンクすべきである。
このレスポンスは、別のものを示しているのでなければキャッシュ可能である。
</p>

<p>
新しい恒久的 URI は、レスポンス内の Location フィールドによって与えられる<em>べきである</em>。
リクエストメソッドが HEAD でなければ、レスポンスのエンティティは新しい URI へのハイパーリンクを持った短いハイパーテキス
トの注釈を含む<em>べきである</em>。
</p>

<p>
もし 301 ステータスコードが GET や HEAD 以外のリクエストのレスポンスとして受信されたら、リクエストが発行された時点の条件から変わっているかもしれないため、ユーザエージェントはユーザに確認せずに、リクエストを自動的にリダイレクトし<em>てはならない</em>。
</p>

<p class="note">
注: 301 ステータスコードを受信した後 POST リクエストを自動的にリダイレクトする時、既存の HTTP/1.0 ユーザエージェントの中には誤ってそれを GET リクエストに変えるものがある。
</p>

<h4 id="section-10.3.3">10.3.3 302 Found</h4>

<p>
リクエストされたリソースは、一時的に別の URI に属している。このリダイレクションは場合によって変更されるかもしれないので、クライアントは将来のリクエストではその Request-URI を使い続ける<em>べきである</em>。
このレスポンスは Cache-Control か Expires のどちらかのヘッダフィールドによって期限が示されている場合にのみキャッシュ可能である。
</p>

<p>
一時的 URI は、レスポンス内の Location フィールドによって与えられる<em>べきである</em>。
リクエストメソッドが HEAD でなければ、レスポンスのエンティティは新しい URI へのハイパーリンクを持った短いハイパーテキストの注釈を含む<em>べきである</em>。
</p>

<p>
もし 302 ステータスコードが GET や HEAD 以外のリクエストのレスポンスとして受信されたら、リクエストが発行された時点の条件から変わっているかもしれないため、ユーザエージェントはユーザに確認されなければ、リクエストを自動的にリダイレクトし<em>てはならない</em>。
</p>

<p class="note">
注: RFC 1945 や RFC 2068 では、クライアントはリダイレクトするリクエストのメソッドを変えてはならないと明確に述べられている。
しかしながら、多くの既存ユーザエージェントは 302 レスポンスをまるで 303 レスポンスのようにみなし、元々のリクエストメソッドにかかわらず Location フィールド値へと GET を行う。
ステータスコード 303 と 307 は、クライアントが期待する反応の種類を明確にしたいというサーバのために加えられた。
</p>

<h4 id="section-10.3.4">10.3.4 303 See Other</h4>

<p>
リクエストに対するレスポンスは別の URI の元から発見でき、このリソースを GET メソッドを使用して回収す<em>べきである</em>。
このメソッドは、主に POST によって活性化される {POST-activated} スクリプトの出力が選択されたリソースへユーザエージェントをリダイレクトできるようにするために存在する。
新しい URI は元々リクエストされたリソースに対する代わりの参照ではない。
303 レスポンスはキャッシュ可能し<em>てはならない</em> が、二番目の (リダイレクトされた) リクエストへのレスポンスはキャッシュ可能である。
</p>

<p>
異なる URI は、レスポンス内の Location フィールドによって与えられる<em>べきである</em>。
リクエストメソッドが HEAD でなければ、レスポンスのエンティティは新しい URI へのハイパーリンクを持った短いハイパーテキストの注釈を含む<em>べきである</em>。
</p>

<p class="note">
注: 多くの HTTP/1.1 以前のユーザエージェントは 303 ステータスを理解できない。
そのようなクライアントと相互通信する時、ほとんどのユーザエージェントは 302 レスポンスを 303 レスポンスのように扱うので、302 レスポンスコードが代わりに使われるであろう。
</p>

<h4 id="section-10.3.5">10.3.5 304 Not Modified</h4>

<p>
クライアントが条件付き GET リクエストを実行し、アクセスは許可されたがその文書は更新されていなかった場合、サーバはこのステータスコードもって応答す<em>べきである</em>。
304 レスポンスはレスポンスボディを含ん<em>ではならない</em>ので、いつもヘッダフィールドの後の最初の空行で終了する。
</p>

<p>
レスポンスは以下のヘッダフィールドを含ま<em>なければならない</em>。
</p>

<ul>
<li>
その省略が section <a href="#section-14.18.1">14.18.1</a> によって要求されていなければ、Date
<p>
時計の無いオリジンサーバがこの規定に従っている場合、プロクシやクラ
イアントは ([RFC 2068] の section <a href="#section-14.19">14.19</a> にて既に記されているように)
受信した Date ヘッダを持たないいかなるレスポンスにも自身の Date を付
け加える事で、キャッシュは正常に作動するであろう。
</p>
</li>
<li>
もしそのヘッダが、同じリクエストに対して 200 レスポンス を返すであろう場合は ETag, Content-Location のうち一つ以上
</li>
<li>
もしフィールド値が、同じバリアントのための以前のレスポンスで送られたものと異なるならば、Expires, Cache-Control, Vary のうち一つ以上
</li>
</ul>

<p>
条件付き GET に、強いキャッシュバリディタ (section <a href="#section-13.3.3">13.3.3</a> 参照) を使う場合、レスポンスは他のエンティティヘッダを含める<em>べきではない</em>。
そうでない (例えば条件付き GET が弱いバリディタを使う) 場合、レスポンスは他のエンティティヘッダを含め<em>てはならない</em>。
これは、キャッシュされたエンティティボディと更新されたエンティティヘッダとの不一致を避ける為である。
</p>

<p>
304 レスポンスが現在キャッシュされていないエンティティを示すならば、キャッシュはレスポンスを無視し、条件なしのリクエストを反復し<em>なければならない</em>。
</p>

<p>
キャッシュが受信された 304 レスポンスをキャッシュエントリを更新するために使用する場合、キャッシュはレスポンスで与えられたあらゆる新しいフィールド値をも反映させるため、エントリを更新し<em>なければならない</em>。
</p>

<h4 id="section-10.3.6">10.3.6 305 Use Proxy</h4>

<p>
リクエストされたリソースは Location フィールドによって与えられるプロクシを通してアクセスされ<em>なければならない</em>。
Location フィールドはプロクシの URI を与える。
受信側はプロクシ経由で単一のリクエストを再送信する事を期待する。
305 レスポンスはオリジンサーバによってのみ生成され<em>なければならない</em>。
</p>

<p class="note">
注: RFC 2068 では、305 は単一リクエストをリダイレクトさせようとする事、またオリジンサーバによってのみ生成される事は明確にしていない。
これらの制限がセキュリティの上で重要な意味を持つという事を認識していなかったためである。
</p>

<h4 id="section-10.3.7">10.3.7 306 (Unused)</h4>

<p>
306 ステータスコードは前のバージョンの仕様書では使われていたが、もはや使われておらず、将来のために予約されている。
</p>

<h4 id="section-10.3.8">10.3.8 307 Temporary Redirect</h4>

<p>
リクエストされたリソースは、一時的に別の URI に属している。
このリダイレクションは場合によって変更する事が<em>できる</em>ので、クライアントは将来のリクエストではその Request-URI を使い続ける<em>べきである</em>。
このレスポンスは Cache-Control か Expires のヘッダフィールドによって期限が示される場合にのみキャッシュ可能である。
</p>

<p>
一時的 URI は、レスポンス内の Location フィールドによって与えられる<em>べきである</em>。
多くの HTTP/1.1 以前のユーザエージェントは 307 ステータスを理解できないので、リクエストメソッドが HEAD でなければ、レスポンスのエンティティは新しい URI へのハイパーリンクを持った短いハイパーテキストの注釈を含む<em>べきである</em>。
それ故に、その注釈にはユーザが新しい URI に元々のリクエストを繰り返すために必要な情報を含む<em>べきである</em>。
</p>

<p>
もし 307 ステータスコードが GET や HEAD 以外のリクエストのレスポンスとして受信されたら、リクエストが発行された時点の条件から変わっているかもしれないため、ユーザエージェントはユーザに確認されなければ、リクエストを自動的にリダイレクトし<em>てはならない</em>。
</p>

<h3 id="section-10.4">10.4 Client Error 4xx</h3>

<p>
ステータスコードの 4xx クラスは、クライアントが間違えているような場合を示す。
HEAD リクエストへのレスポンスを除き、サーバはエラー状況が一時的か恒久的かに拘わらず、エラー状況の説明を含むエンティティを返す<em>べきである</em>。
これらのステータスコードは、あらゆるリクエストメソッドに適用されうる。
ユーザエージェントは、含まれるエンティティすべてをユーザに表示す<em>べきである</em>。
</p>

<p>
もしクライアントがデータを送信している最中ならば、TCP を使用しているサーバ実装は、サーバが入力接続を切断する前に、レスポンスを含んでいるパケットの受領をクライアントが認識できる事を保証するために気を配る<em>べきである</em>。
もし切断後にもクライアントがサーバにデータを送信し続けていたら、サーバの TCP スタックはクライアントにリセットパケットを送り、これによって、HTTP アプリケーションがリクエストを読み出して中間処理する前に、クライアントの認識されない入力バッファを消去するだろう。
</p>

<h4 id="section-10.4.1">10.4.1 400 Bad Request</h4>

<p>
リクエストは、不正な構文のためサーバに理解されなかった。
クライアントは、修正しないままでそのリクエストを再送信す<em>べきではない</em>。
</p>

<h4 id="section-10.4.2">10.4.2 401 Unauthorized</h4>

<p>
リクエストはユーザ認証を必要とする。レスポンスは、リクエストされたリソースに適用できる challenge を含む WWW-Authenticate ヘッダフィールド (section <a href="#section-14.47">14.47</a>) を含ま<em>なければならない</em>。
クライアントは、適切な Authorization ヘッダフィールド (section <a href="#section-14.8">14.8</a>) を伴うリクエストを繰り返す事が<em>できる</em>。
もしリクエストがすでに Authorization credentials を含んでいるのであれば、この 401 レスポンスは認証がそれらの credentials に対して拒否された事を示す。
もし 401 レスポンスが前のレスポンス時と同じ challenge を含み、ユーザエージェントが既に最低一回認証を試みているならば、そのエンティティに関連する診断情報を含んでいるであろうから、ユーザエージェントはレスポンスで与えられたエンティティを表示す<em>べきである</em>。
HTTP アクセス認証は、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; において説明されている。
</p>

<h4 id="section-10.4.3">10.4.3 402 Payment Required</h4>

<p>
このコードは、将来の使用のため予約されている。
</p>

<h4 id="section-10.4.4">10.4.4 403 Forbidden</h4>

<p>
サーバはリクエストを理解したが、それを実行する事を拒否した。
認証は役に立たないであろうから、リクエストは繰り返される<em>べきではない</em>。
リクエストメソッドが HEAD で無い時に、サーバはなぜリクエストが実行されなかったかを公にしたいならば、エンティティにおいて拒否の理由を記す<em>べきである</em>。
サーバはこの情報をクライアントに利用されたくないならば、ステータスコードとして 404 (Not Found) を代わりに使う事が出来る。
</p>

<h4 id="section-10.4.5">10.4.5 404 Not Found</h4>

<p>
サーバが、 Request-URI に一致するものを見つけられなかった。
その状態が一時的か恒久的かに拘わらず、与えられる指示はない。
もしサーバが、ある内部に組み込まれているメカニズムを通して、古いリソースが恒久的に利用できず、それを転送するためのアドレスも無いという事を知っていたら、410 (Gone) ステータスコードが使用される<em>べきである</em>。
このステータスコードは一般に、サーバが何故リクエストが拒否したかを正確には表したく無い時、あるいは他に適切なレスポンスが無い時に使われる。
</p>

<h4 id="section-10.4.6">10.4.6 405 Method Not Allowed</h4>

<p>
リクエストラインに記述されたメソッドは、 Request-URI によって識別されるリソースに許可されていない。
レスポンスは、リクエストされたリソースへ適用できるメソッドのリストを含む Allow ヘッダを含ま<em>なければならない</em>。
</p>

<h4 id="section-10.4.7">10.4.7 406 Not Acceptable</h4>

<p>
リクエストによって識別されるリソースは、リクエスト中に送られた Accept ヘッダによれば、受け入れられない内容特性を持つレスポンスエンティティを生成する事ができるのみである。
</p>

<p>
もし HEAD リクエストでなければ、レスポンスはエンティティにユーザかユーザエージェントが最も適切なものを選択するためのリソースの特徴と場所のリストを含む<em>べきである</em>。
エンティティのフォーマットは、Content-Type ヘッダフィールドにて与えられるメディアタイプによって指定される。
データフォーマットやユーザエージェントの能力に依存する事なので、最も適切な選択は自動的に行われる<em>かもしれない</em>。
しかし、この仕様書ではそのような自動選択に対してどのような標準も定義しない。
</p>

<p class="note">
注: HTTP/1.1 サーバは、リクエスト中に送られた Accept ヘッダによれば受け入れる事ができないとされるレスポンスを返す事を許されている。
そのような場合、406 レスポンスを送る事が望ましい。
ユーザエージェントは、もしそれを受け入れられるなら、それを決定するために送られてきたレスポンスのヘッダを詳しく調べる事が推奨される。
</p>

<p>
もしレスポンスが受け入れる事ができなければ、ユーザエージェントはそれ以上のデータの受信を一時的に中止し、それ以降の動作を決定するためユーザに尋ねる<em>べきである</em>。
</p>

<h4 id="section-10.4.8">10.4.8 407 Proxy Authentication Required</h4>

<p>
このコードは、401 (Unauthorized) と似ているが、クライアントが最初にプロクシに認証されなければならない事を示す。
プロクシは、リクエストされたリソースのためのプロクシに適用できる challenge を含んだ Proxy-Authenticate ヘッダフィールド (section <a href="#section-14.33">14.33</a>) を返さ<em>なければならない</em>。
クライアントは、適切な Proxy-Authorization ヘッダフィールド (section <a href="#section-14.34">14.34</a>) を伴うリクエストを繰り返す事ができる。
HTTP アクセス認証は、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; <a href="#ref-43">[43]</a> において説明されている。
</p>

<h4 id="section-10.4.9">10.4.9 408 Request Timeout</h4>

<p>
クライアントは、サーバの待ち時間内にリクエストを発行しなかった。
クライアントは、それ以降に修正しないでリクエストを繰り返しても<em>よい</em>。
</p>

<h4 id="section-10.4.10">10.4.10 409 Conflict</h4>

<p>
リクエストは、リソースの現在の状態との矛盾のため完了できなかった。
このコードは、ユーザが矛盾を解決し、リクエストを再提出できる事が期待できる状況のみに許される。
レスポンスボディには、ユーザが矛盾の原因を認識するための十分な情報を含む<em>べきである</em>。
理論的には、そのレスポンスエンティティはユーザやユーザエージェントが問題を修正するための十分な情報を含んでいるであろうが、実際それは不可能だろうしその必要もない。
</p>

<p>
矛盾は、PUT リクエストへのレスポンス時に最も発生しやすい。
例えば、もしバージョン処理{versioning} が使用され、PUT されているエンティティが初期 (サードパーティ) のリクエストによって作られたものと矛盾しているリソースに変わるものを含んでいるならば、サーバはリクエストが完了できない事を示す 409 レスポンスを使用できる。
この場合、レスポンスエンティティにはおそらく、レスポンスの Content-Type によって定義されるフォーマット中で二つのバージョンの違いについてのリストを含むであろう。
</p>

<h4 id="section-10.4.11">10.4.11 410 Gone</h4>

<p>
リクエストされたリソースは、もはやそのサーバでは利用できないし、転送先のアドレスも分からない。
この状況は、恒久的なものとみなされるであろう。
リンク編集機能を持つクライアントは、ユーザから承認を得た後にリクエスト URI の参照を削除す<em>べきである</em>。
サーバがその状況が恒久的なものかどうかを、知らないか、あるいはそれを決定するための能力が無いのであれば、代わりにステータスコード 404 (Not Found) が使用される<em>べきである</em>。
別の方法が示されなければ、このレスポンスはキャッシュできる。
</p>

<p>
410 レスポンスは主に、リソースが故意に利用不可能であったり、サーバのオーナーがリソースへのリモートリンクを削除したい事を受信者に通知する事でウェブメンテナンスの作業を補助する意図を持つ。
そのような事は、期間限定の宣伝サービスや、サーバのサイト内でもはや働いていない個人が所有していたリソースに対して一般的である。
&quot;無くなった{gone}&quot; ような恒久的に利用できないすべてのリソースをマークしたり、いつまでもそのマークを維持しておく必要はないが、これをいつ破棄するかはサーバオーナーの判断にまかされる。
</p>

<h4 id="section-10.4.12">10.4.12 411 Length Required</h4>

<p>
サーバは、定義された Content-Length の無いリクエストを受け入れる事を拒否した。
リクエストメッセージにメッセージボディの長さを含んでいる妥当な Content-Length ヘッダフィールドを追加すれば、クライアントはリクエストを繰り返す事が<em>できる</em>。
</p>

<h4 id="section-10.4.13">10.4.13 412 Precondition Failed</h4>

<p>
一つ以上のリクエストヘッダフィールドで与えられた前提条件は、それがサーバでテストされたときに偽であると評価された。このレスポンスコードはクライアントが現在のリソースの外部情報 (ヘッダフィールドデータ) を前提条件として置けるようにし、それによってリクエストされたメソッドを目的以外のリソースに適用されないようにする。
</p>

<h4 id="section-10.4.14">10.4.14 413 Request Entity Too Large</h4>

<p>
リクエストエンティティがサーバが想定、あるいは処理可能なものより大きいため、サーバはリクエストの処理を拒否している。
サーバは、クライアントにリクエストを続けさせないため接続を閉じて<em>よい</em>。
</p>

<p>
もしその状態が一時的なものであれば、サーバはそれが一時的であるという事と、クライアントが再試行しても<em>よい</em>経過時間を示す Retry-After ヘッダフィールドを含む<em>べきである</em>。
</p>

<h4 id="section-10.4.15">10.4.15 414  Request-URI Too Long</h4>

<p>
サーバが中間処理をするために想定している Request-URI より長いため、サーバはリクエストのサービスを拒否している。
このまれな状態は、クライアントが長いクエリ情報を伴った POST リクエストを GET リクエストに不適当に変換した時、クライアントがリダイレクションの URI &quot;ブラックホール&quot; (例えば、リダイレクトされた URI が自身の末尾を指すようなものを自身の前に置いてしまうような状態) に陥った時、あるいはサーバが Request-URI の読み出しや操作のために固定長バッファを使用しているいくつかのサーバに存在する当面のセキュリティホールを利用しようとしているクライアントからアタックを受けている時にのみ起こる傾向がある。
</p>

<h4 id="section-10.4.16">10.4.16 415 Unsupported Media Type</h4>

<p>
リクエストのエンティティは、リクエストされたメソッドに対してリクエストされたリソースがサポートしていないフォーマットであるため、サーバはリクエストのサービスを拒否している。
</p>

<h4 id="section-10.4.17">10.4.17 416 Requested Range Not Satisfiable</h4>

<p>
リクエストが Range ヘッダフィールド (section <a href="#section-14.35">14.35</a>) を含み、このフィールドの範囲指定値が選ばれたリソースの現在の範囲に重なっていなくて、リクエストに If-Range リクエストヘッダフィールドを含んでいなかったら、サーバはこのステータスコードを含むレスポンスを返す<em>べきである</em>。
(バイトレンジの場合、これはすべての byte-range-spec 値での first-bytes-pos が、現在選択されているリソースの長さを超えている事を意味する。)
</p>

<p>
このステータスコードをバイトレンジのリクエストで返す場合、レスポンスには選ばれたリソースの現在のサイズを特定するために Content-Range ヘッダフィールドを含む<em>べきである</em> (section <a href="#section-14.16">14.16</a> 参照)。
このレスポンスは、content-type が multipart/byteranges のものに使用し<em>てはならない</em>。
</p>

<h4 id="section-10.4.18">10.4.18 417 Expectation Failed</h4>

<p>
Expect リクエストヘッダフィールド (section <a href="#section-14.20">14.20</a> 参照) によって与えられるこの拡張は、このサーバでは受け入れる事は出来ないし、あるいはサーバがプロクシであったなら、次に到達するサーバがそのリクエストを受け入れる事ができないという明白な証拠を持っている。
</p>

<h3 id="section-10.5">10.5 Server Error 5xx</h3>

<p>
数字 &quot;5&quot; で始まるレスポンスステータスコードは、サーバがエラー状態にあるか、リクエストを実行する能力が無いと気づいた場合を表す。
HEAD リクエストに応答する場合以外は、サーバはそのエラー状況と、それが一時的か恒久的なのかの説明を含むエンティティを返す<em>べきである</em>。
ユーザエージェントは、ユーザに返されたあらゆるエンティティを表示す<em>べきである</em>。
これらのレスポンスコードは、あらゆるリクエストメソッドにも適用できる。
</p>

<h4 id="section-10.5.1">10.5.1 500 Internal Server Error</h4>

<p>
サーバは、リクエストの実行を妨げる予測しない状態に遭遇した。
</p>

<h4 id="section-10.5.2">10.5.2 501 Not Implemented</h4>

<p>
サーバは、リクエストを実行するのに必要な機能をサポートしていない。
これは、サーバがリクエストメソッドを認識できない時の適切なレスポンスであり、どんなリソースに対してもそれをサポートする能力がない。
</p>

<h4 id="section-10.5.3">10.5.3 502 Bad Gateway</h4>

<p>
ゲートウェイやプロクシとして動作しているようなサーバが、リクエストを実行しようと呼び出しているアップストリームサーバから不正なレスポンスを受け取った。
</p>

<h4 id="section-10.5.4">10.5.4 503 Service Unavailable</h4>

<p>
サーバは、一時的な過負荷かあるいはサーバのメンテナンスのため、現在リクエストを扱う事ができない。これは、いくらか遅延された後に軽減されるであろうという一時的な状態も含む。もし分かるなら、遅延時間の長さを Retry-After ヘッダで示す事が<em>できる</em>。
もし Retry-After が与えられなければ、クライアントはそれを 500 レスポンスと同様に処理すべきである。
</p>

<p class="note">
注: 503 ステータスコードの存在は、サーバが過負荷状態になった時には常にそれを使わなければならないという事を暗黙的に意味するものではない。
単に接続の拒否を望むサーバもあるだろう。
</p>

<h4 id="section-10.5.5">10.5.5 504 Gateway Timeout</h4>

<p>
ゲートウェイやプロクシとして動作するサーバは、URI によって特定されるアップストリームサーバ (例えば HTTP, FTP, LDAP) や、リクエストを完了させようとするためにアクセスに必要な他の補助のサーバ (例えば DNS) から適時のレスポンスを受信しなかった。</p>

<p class="note">
注: 実装者向け: 設置されたプロクシの中には、DNS lookup がタイムアウトした時に 400 あるいは 500 を返すものがあるという事が知られている。
</p>

<h4 id="section-10.5.6">10.5.6 505 HTTP Version Not Supported</h4>

<p>
サーバは、リクエストメッセージで使用された HTTP プロトコルバージョンをサポートしていない、あるいはサポートを拒否している。
サーバは、このエラーメッセージ以外は、section <a href="#section-3.1">3.1</a> で表されるように、クライアントと同じメジャーバージョンを使用してリクエストを完了させる事は不可能、 あるいはそれを望んでいないという事を示している。
レスポンスは、何故このバージョンがサポートされていないか、どんな別のプロトコルがこのサーバによってサポートされているかを記述したエンティティを含む<em>べきである</em>。
</p>

<h2 id="section-11">11 アクセス認証</h2>

<p>
HTTP は、サーバがクライアントにリクエストを誰何{challenge} するため、あるいはクライアントが認証情報を提供するために使用する事ができる、いくつかの<em>オプショナル</em>な誰何-応答{challenge-response} 認証メカニズムを提供する。
アクセス認証の全体の枠組、そして &quot;基本&quot; 及び &quot;ダイジェスト&quot; 認証の仕様については、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; <a href="#ref-43">[43]</a> にて記述されている。
この仕様書では、その仕様書にある &quot;challenge&quot; と &quot;credentials&quot; の定義を採用する。
</p>

<h2 id="section-12">12 内容ネゴシエーション</h2>

<p>
多くの HTTP レスポンスは、人間ユーザによって解釈される情報から成るエンティティを含む。
当然、リクエストに対応した &quot;最も利用できる&quot; エンティティをユーザに供給するのが望ましい。
サーバやキャッシュにとって不幸な事は、すべてのユーザが &quot;最上&quot; なものについて同じ優先度を持たせているわけではないし、すべてのユーザエージェントがすべてのエンティティタイプを等しく表現できるわけではないという事である。
この理由により、HTTP は &quot;内容ネゴシエーション&quot;、すなわち複数の利用可能な表現がある時に与えられたレスポンスにとって最上の表現を選択するための処理のためのいくつかのメカニズムを持っている。
</p>

<p class="note">
注: これは、ある別の表現として、メディアタイプは同じであるが使用言語が異っている等、そのタイプとは異なる能力{capabilities} を使用するかもしれないので、&quot;フォーマットネゴシエーション&quot; とは呼ばれない。
</p>

<p>
エンティティボディを含むあらゆるレスポンスは、エラーレスポンスを含めネゴシエーションを受けさせる事が<em>できる</em>。
</p>

<p>
HTTP で可能な内容ネゴシエーションには二種類ある。
サーバ駆動型ネゴシエーションとエージェント駆動型ネゴシエーションである。
これら二つのネゴシエーションは直交{orthogonal} し、故に別々にあるいは組み合わせて使う事ができる。
一つの組み合わせ方として、透過的ネゴシエーションと呼ばれる方法は、キャッシュが以降のリクエストに対してサーバ駆動型ネゴシエーションを提供するためにオリジンサーバによって供給されるエージェント駆動型ネゴシエーション情報を使用する時に発生する。</p>

<h3 id="section-12.1">12.1 サーバ駆動型ネゴシエーション</h3>

<p>
レスポンスとしての最適な表現の選択がサーバに設けられたアルゴリズムによって行われた場合、これはサーバ駆動型ネゴシエーションと呼ばれる。
選択は、利用可能なレスポンスの表現 (それが変化できる次元、例えば言語や内容コーディング等) や、リクエストメッセージ内の特定のヘッダフィールドの内容、あるいはそのリクエストに関するその他の情報 (例えばクライアントのネットワークアドレス) に基づく。
</p>

<p>
サーバ駆動型ネゴシエーションは、利用可能な表現の中から選択するためのアルゴリズムがユーザエージェントに説明するのが難しい時や、サーバが最初のレスポンスと一緒にクライアントに自身の &quot;最適な推測&quot; を送る事を望む (もしその &quot;最適な推測&quot; がユーザにとって十分なものであれば、以降のリクエストの往復時間遅れ{round-trip delay} を避けられる) 時に有益である。
サーバの推測を改善するため、ユーザエージェントはそのようなレスポンスのための自身の優先度を表すリクエストヘッダフィールド (Accept, Accept-Language, Accept-Encoding 等) を含む事が<em>できる</em>。
</p>

<p>
サーバ駆動型ネゴシエーションは以下の不都合を持つ:
</p>

<ol>
<li>ユーザエージェントの能力とレスポンスの使用目的 (例えば、ユーザはそれをスクリーンに表示させたいのか、それとも紙に印刷したいのか？) の両方の完全な情報が必要なので、サーバがそのユーザにとって &quot;最適&quot; であるものをすべて正確に決定するのは不可能である。</li>
<li>リクエスト毎にユーザエージェントに自身の能力を記述させる事は、非常に能率が悪く (レスポンスが複数の表現を持っている確率は少ないため)、ユーザのプライバシーの潜在的な侵害となりうる。</li>
<li>リクエストに対してレスポンスを生成するため、オリジンサーバの実装とそのアルゴリズムが複雑になってしまう。</li>
<li>複数のユーザのリクエストに同じレスポンスを使う共有キャッシュの能力を制限するかもしれない。</li>
</ol>

<p>
HTTP/1.1 は、ユーザエージェントの能力とユーザの設定の記述を通してサーバ駆動型ネゴシエーションを可能にするための、以下のリクエストヘッダフィールドを含んでいる。
すなわち、Accept (section <a href="#section-14.1">14.1</a>), Accept-Charset (section <a href="#section-14.2">14.2</a>), Accept-Encoding (section <a href="#section-14.3">14.3</a>), Accept-Length (section <a href="#section-14.4">14.4</a>), User-Agent (section <a href="#section-14.43">14.43</a>) である。
しかしながら、オリジンサーバはそれらの次元に限定されないし、リクエストヘッダフィールドの外部やこの仕様書にて定義されていない拡張ヘッダフィールド内部の情報を含めた、リクエストのあらゆる面に基づいてレスポンスを変える事が<em>できる</em>。
</p>

<p>
Vary ヘッダフィールドは、サーバがサーバ駆動型ネゴシエーションを受ける表現を選択するために使うパラメータを表すために使う事ができる。
キャッシュによる Vary ヘッダフィールドの使用については section <a href="#section-13.6">13.6</a> を、サーバによる Vary ヘッダフィールドの使用については section <a href="#section-14.44">14.44</a> を、それぞれ参照の事。
</p>

<h3 id="section-12.2">12.2 エージェント駆動型ネゴシエーション</h3>

<p>
エージェント駆動型ネゴシエーションの場合、レスポンスとしての最適な表現の選択は、オリジンサーバからの最初のレスポンスを受けとった後にユーザエージェントによって実行される。
選択は、最初のレスポンスのヘッダフィールドやエンティティボディに含まれる利用可能なレスポンスの表現のリストに基づき、それぞれの表現毎に自身の URI によって識別される。
表現内からの選択は、 (ユーザエージェントがそうする能力があれば) 自動的に、あるいは生成された (おそらくハイパーテキストの) メニューからのユーザの選択によって手動的に行われるだろう。
</p>

<p>
エージェント駆動型ネゴシエーションは、レスポンスが一般的に使われる次元 (例えばタイプ、言語、エンコーディングのような) と異なる時、オリジンサーバがリクエストの評価からはユーザエージェントの能力を決定できない時、そして一般的に共有キャッシュがサーバの負荷を分散し、ネットワークの使用を減らすために使用される時に有益である。
</p>

<p>
エージェント駆動型ネゴシエーションは、最適な入れ替わるべき表現を得るために次のリクエストが必要となるという不都合がある。
次のリクエストはキャッシングが使用されている時にのみ効率的である。
さらに、この仕様書では自動選択をサポートするどんなメカニズムも拡張として改良したり、HTTP/1.1 内で使用したりする事を禁止しないが、そのいかなるメカニズムも定義しない。
</p>

<p>
HTTP/1.1 は、サーバがサーバ駆動型ネゴシエーションで使って異なるレスポンスを供給しようとしない、あるいはできない時にエージェント駆動型ネゴシエーションを可能にするため、300 (Multiple Choices) と 406 (Not Acceptable) ステータスコードを定義する。
</p>

<h3 id="section-12.3">12.3 透過的ネゴシエーション</h3>

<p>
透過的ネゴシエーションは、サーバ駆動型ネゴシエーションとエージェント駆動型ネゴシエーションの両方の組み合わせである。
キャッシュが (エージェント駆動型ネゴシエーションの中で) レスポンスとして利用可能な表現のリストのフォームを供給され、その違いの次元をキャッシュが完全に理解できた時、キャッシュはそのリソースへの以降のリクエストのためにオリジンサーバに代わってサーバ駆動型ネゴシエーションを実行できるようになる。
</p>

<p>
透過的ネゴシエーションは、他の方法でオリジンサーバに要求されるネゴシエーション作業の分散と、キャッシュが正しいレスポンスを正しく推測する事ができる時にエージェント駆動型ネゴシエーションの次のリクエストによる遅れを無くするという利点を持つ。
</p>

<p>
この仕様書では、透過的ネゴシエーションのためのどんなメカニズムも拡張として改良したり、HTTP/1.1 内で使用したりする事を禁止しないが、そのいかなるメカニズムも定義しない。
</p>

<h2 id="section-13">13 HTTP におけるキャッシング</h2>

<p>
HTTP は基本的に情報配布システムとして使われるが、そのパフォーマンスはレスポンスキャッシュの使用によって改善する事ができる。
HTTP/1.1 プロトコルは、できるだけキャッシング作業を行おうとするためのいくつかの要素を含む。
これらの要素はプロトコルの別の側面からは解決できず、それらが相互に作用するため、メソッド、ヘッダ、レスポンスコードなどの詳細な記述とは別に HTTP の基本的なキャッシングデザインを記述する事は有用である。
</p>

<p>
もし十分にパフォーマンスを高めなければ、キャッシングは役に立たないであろう。
HTTP/1.1 におけるキャッシングが目指すものは、多くの場合でリクエストを送る必要を無くし、また別の多くの場合において全レスポンスを送る必要を無くす事である。
前者は、多くの操作に対して必要とされるネットワークラウンドトリップ{round-trip} をいくらか減らす。
我々は、この目的のため &quot;期限&quot; メカニズムを使用する (section <a href="#section-13.2">13.2</a> 参照)。
後者は、必要なネットワークバンド幅を減らす。
我々は、この目的のため &quot;検証&quot; メカニズムを使用する (section <a href="#section-13.3">13.3</a> 参照)。
</p>

<p>
パフォーマンス、有用性、分離された操作のための要求は、我々に意味的透過性の目標点を緩める{relax} 事ができるように要求する。
HTTP/1.1 プロトコルによって、オリジンサーバ、キャッシュ、クライアントは必要な時に透過性を明白に減らす事ができる。
しかしながら、非透過な操作は専門家以外のユーザを混乱させるかもしれないし、ある (商品の注文用等の) サーバアプリケーションとは互換性が無いかもしれないので、プロトコルは以下の透過性を緩める必要がある。
</p>

<ul>
<li>クライアントやオリジンサーバによって緩められた時は、明示的なプロトコルレベルのリクエストによってのみ</li>
<li>キャッシュやクライアントによって緩められた時は、エンドユーザに明示的な警告を伴うもののみ</li>
</ul>

<p>
それ故に、HTTP/1.1 プロトコルは以下の重要な要素を提供する。
</p>

<ol>
<li>それがすべてのパーティによって要求される時に完全な意味論を供給するプロトコル機能。</li>
<li>オリジンサーバやユーザエージェントが明示的に非透過操作を要求でき、制御できるプロトコル機能。</li>
<li>キャッシュがリクエストされた意味的透過性の概略を保存しないレスポンスに警告を付け加えられるプロトコル機能。</li>
</ol>

<p>
基本原理はクライアントが意味的透過性のあらゆる潜在的な緩和も検出可能でなければならないという事である。
</p>

<p class="note">
注: サーバ、キャッシュもしくはクライアント実装者はこの仕様書において明確に論議されないデザインの決定に直面するだろう。
もし決定が意味的透過性に影響するなら、注意深く完全な分析が透過性の破壊で重要な恩恵を表す以外、実装者は透過性を維持する面からは離れた間違いを犯すはずである。
</p>

<h4 id="section-13.1.1">13.1.1 キャッシュの正当性</h4>

<p>
正当なキャッシュは、以下の状況の一つに合うリクエスト (section <a href="#section-13.2.5">13.2.5</a>, <a href="#section-13.2.6">13.2.6</a>, <a href="#section-13.12">13.12</a> 参照) に適した、キャッシュが持っている最新のレスポンスをもってリクエストに答え<em>なければならない</em>。
</p>

<ol>
<li>
<p>オリジンサーバがレスポンスの再検証によってオリジンサーバで返されたものとの等価性が確認されている (section <a href="#section-13.3">13.3</a>)。</p>
</li>
<li>
<p>&quot;十分に新鮮&quot; (section <a href="#section-13.2">13.2</a> 参照) である。
既定の場合、これはクライアント、オリジンサーバ、キャッシュの最低限の新鮮度要求に合う事を意味する (section <a href="#section-14.9">14.9</a> 参照)。
オリジンサーバがそう指定する場合、それはオリジンサーバ単独の新鮮度要求である。
</p>
<p>
保存されたレスポンスがクライアントとオリジンサーバの両方の最も限定的な新鮮度要求から &quot;十分に新鮮&quot; で無い場合、そのようなレスポンスが禁じられている (例えば &quot;no-store&quot; キャッシュ指示子や、&quot;no-cache&quot; キャッシュリクエスト指示子等；section <a href="#section-14.9">14.9</a> 参照) ので無ければ、深く考慮された環境ではキャッシュが適切な Warning ヘッダを伴ってそのレスポンスを返しても<em>よい</em>。
</p>
</li>
<li>
<p>
適切な 304 (Not Modified), 305 (Proxy Redirect) かエラー (4xx か 5xx) レスポンスメッセージである。
</p>
</li>
</ol>

<p>
キャッシュがオリジンサーバと通信できない時、レスポンスがキャッシュから正しく対応させる事ができるならば、正しいキャッシュは上記のものを返す<em>べきであり</em>、そうでなければ通信失敗があった事を示すエラーか警告を返さ<em>なければならない</em>。
</p>

<p>
キャッシュがリクエストしているクライアントに普通に転送するレスポンス (レスポンス全体か、304 (Not Modified) レスポンス) を受け取り、その受け取ったレスポンスが既に新鮮で無い場合、キャッシュはそれに新しい Warning を追加する事無く (しかし存在するどんな Warning ヘッダも削除する事も無く) リクエストしているクライアントに転送す<em>べきである</em>。
レスポンスは転送において新鮮で無くなったのかもしれないので、キャッシュは簡単にそのレスポンスの再検証を試す<em>べきではない</em>。
それによって無限ループを引き起こすかもしれない。
Warning を伴わない新鮮で無いレスポンスを受け取ったユーザエージェントは、ユーザに示すための警告を表示する事が<em>できる</em>。
</p>

<h4 id="section-13.1.2">13.1.2 Warnings</h4>

<p>
キャッシュがファーストハンドでも無く、 (section <a href="#section-13.1.1">13.1.1</a> での二つの状態の意味において) &quot;十分に新鮮&quot; でも無いレスポンスを返す時は、常に Warning 一般レスポンスヘッダを使って、その結果に警告を付加し<em>なければならない</em>。
Warning ヘッダと現在定義されている警告は section <a href="#section-14.46">14.46</a> に記されている。
この警告はクライアントが適切な動作を行えるようにする。
</p>

<p>
警告は、キャッシュに関係するものと別のものの両方とも、他の目的で使用する事が<em>できる</em>。
エラーステータスコードではなく、警告を使う事によってこれらのレスポンスと真の失敗{true failures} とを区別する。
</p>

<p>
警告には、3 桁の warn-code が割り当てられる。最初の数字は、その警告が再検証が成功した後に保存されているキャッシュエントリから削除し<em>なければならない</em>、またはし<em>てはならない</em> かどうかを表している。
</p>

<p>
1xx の警告はレスポンスの新鮮度やステータスの再検証を表し、再検証が成功した後に削除され<em>なければならない</em>。
1XX warn-code は、キャッシュがキャッシュされたエントリを再検証した時にキャッシュによってのみ生成<em>できる</em>。
クライアントが生成し<em>てはならない</em>。
</p>

<p>
2xx の警告は、再検証によって改正されないエンティティボディやエンティティヘッダ (例えばエンティティボディの不可逆圧縮{lossy compression})の点についてを表し、再検証が成功した後に削除し<em>てはならない</em>。
</p>

<p>
コード自体の定義については section <a href="#section-14.46">14.46</a> 参照。
</p>

<p>
HTTP/1.0 キャッシュは、始めのカテゴリの一つを消す事無くすべての警告をレスポンスとしてキャッシュするだろう。
HTTP/1.0 キャッシュを通したレスポンスの警告は特別な warning-date フィールドを含んでおり、これで将来の HTTP/1.1 受信者が謝ってキャッシュの警告を信じない様にする。
</p>

<p>
警告は警告テキストも含んでいる。このテキストは適切な (おそらくクライアントの Accept ヘッダに基づいた) 自然言語で記され、どんな文字セットが使用されているかの<em>オプショナルな</em>指示を含んでいる。
</p>

<p>
レスポンスには、同じコード番号の複数の警告を含む、複数の警告を (オリジンサーバかキャッシュによって) 付加する事が<em>できる</em>。
例えば、サーバは英語とバスク語の両方のテキストで同じ警告を供給できる。
</p>

<p>
複数の警告がレスポンスに付加されている時、ユーザにそれらすべてを表示するのは実用的でも合理的でも無いかもしれない。
HTTP のこのバージョンではどの警告を表示するか、あるいはその優先順序を決定するための厳密な優先規定を記述しないが、いくつかの発見的教授方法を提案する。
</p>

<h4 id="section-13.1.3">13.1.3 キャッシュコントロールメカニズム</h4>

<p>
HTTP/1.1 における基本的なキャッシュメカニズム (サーバに指定された期限時刻とバリディタ) はキャッシュにとっての暗黙的命令である。
いくつかの場合で、サーバやクライアントは HTTP キャッシュに明示的指示を提供する必要があるかもしれない。
我々はこの目的のため Cache-Control ヘッダを使用する。
</p>

<p>
Cache-Control ヘッダによって、クライアントやサーバはリクエストやレスポンスにおける様々な指示が伝えられるようになる。
これらの指示子は、典型的に既定のキャッシングアルゴリズムを無効にする。
一般的な規定として、もしヘッダ値の間に明らかな矛盾が存在するなら、最も限定的な解釈が適用される (これは、意味論等価性を維持するために最適なものである)。
しかしながら、いくつかの場合では、Cache-Control 指示子は意味論等価性の概略を弱めるように明示的に詳述される (例えば &quot;max-stale&quot; や &quot;public&quot;)。
</p>

<p>
Cache-Control 指示子は section <a href="#section-14.9">14.9</a> において詳細に記述されている。
</p>

<h4 id="section-13.1.4">13.1.4 明示的なユーザエージェントの警告</h4>

<p>
多くのユーザエージェントでは、ユーザが基本的なキャッシングメカニズムとは別の物を使えるようにさせている。
例えば、ユーザエージェントはユーザに (明らかに古くなっているものでさえ) キャッシュされたエンティティは決して検証されないという事を指定できるようにするだろう。
あるいは、ユーザエージェントはリクエスト毎に &quot;Cache-Control: max-stale=3600&quot; を習慣的に追加するかもしれない。
ユーザエージェントは透過的で無い振る舞いや、異常に効果の無いキャッシングを引き起こす振る舞いを既定とす<em>べきではない</em> が、ユーザの明示的な動作によってはそうするように形成する事ができる。
</p>

<p>
もしユーザが基本的なキャッシングメカニズムとは別の物を使うならば、ユーザエージェントは、それがサーバの透過的要求に合っていないという情報の表示という結果になる時はいつでも (特に、表示されたエンティティが古くなっていると分かっている場合は) ユーザに明示的に示す<em>べきである</em>。
プロトコルは、通常ユーザエージェントにレスポンスが古くなっているかどうかを決定できるようにさせているので、この指示はそれが実際に起こった時にのみ表示される必要がある。この指示はダイアログボックスである必要は無く、アイコン (例えば、腐った魚の絵) や別の表示機であってもよい。
</p>

<p>
もしユーザがキャッシュの有効性を異常に減少するであろう方法でキャッシングメカニズムを上書きしているなら、ユーザが不注意に余分なリソースを消費したり過度の待ち時間に苦しまないようにユーザエージェントは続けて現在の状態をユーザに (例えば、炎の中の通貨の絵を示す事で) 表示す<em>べきである</em>。
</p>

<h4 id="section-13.1.5">13.1.5 規則と警告の例外</h4>

<p>
いくつかの場合、キャッシュのオペレータはクライアントによって要求されない時に古くなったレスポンスを返すような設定を選ぶ事が<em>できる</em>。
この決定は気軽に行われるべきではないが、有用性やパフォーマンス上の理由、特にキャッシュがオリジンサーバとの接続が不十分である時に必要であろう。
キャッシュが古くなったレスポンスを返す時はいつでも、クライアントソフトウェアがユーザに潜在的な問題があるかもしれないという事を警告できるようにするために (Warning ヘッダを使って) そのように印付けておか<em>なければならない</em>。
</p>

<p>
ユーザエージェントがファーストハンドあるいは新鮮なレスポンスを得るという処置を行う事もできる。
この理由により、クライアントが明示的にファーストハンドあるいは新鮮なレスポンスを要求している場合、技術的もしくはポリシー上の理由のために応ずる事ができないというので無ければ、キャッシュは古くなったレスポンスを返す<em>べきではない</em>。
</p>

<h4 id="section-13.1.6">13.1.6 クライアントにコントロールされた振る舞い</h4>

<p>
オリジンサーバ (とレスポンスの経過時間へ寄与するより小さな範囲の中間キャッシュ) が期限切れについての情報のプライマリリソースである間、いくつかの場合クライアントはキャッシュされたレスポンスを再検証する事無く返すかどうかについてのキャッシュの決定を制御する必要があるかもしれない。
クライアントは、いくつかの Cache-Control ヘッダの指示子を使ってこれを行う。
</p>

<p>
クライアントのリクエストは、正当性が検証されていないレスポンスの受け取りを意図して最大経過時間を指定する事が<em>できる</em>。
ゼロの値の記述すれば、強制的にキャッシュにすべてのレスポンスの正当性を再検証させる。
また、クライアントはレスポンスが期限切れになる前に残される最小時間を指定する事も<em>できる</em>。
これらオプションは両方とも、キャッシュの振る舞いの制約を増やすもので、キャッシュの意味的透過性の概略をそれ以上緩める事はできない。
</p>

<p>
クライアントは古くなったレスポンスを受け入れる意図で、ある古さまでの最大量を指定する事も<em>できる</em>。
これはキャッシュの制約を緩め、オリジンサーバに記述された意味的透過性の制約に違反する事になるかもしれないが、非接続時の操作や貧弱な接続に直面した時の高い有用性をサポートするために必要かもしれない。
</p>

<h3 id="section-13.2">13.2 期限{Expiration} モデル</h3>

<h4 id="section-13.2.1">13.2.1 サーバが指定した期限</h4>

<p>
HTTP キャッシングは、キャッシュがオリジンサーバにリクエストを送るという事を完全に避ける事ができる時に最善に動作する。
リクエストを避けるための第一のメカニズムは、レスポンスが以降のリクエストを満足させるために使用する事が<em>できる</em>という事を含め、オリジンサーバが将来において明確な期限切れになる時間を提供する事である。
言い換えれば、キャッシュはサーバに先に接続する前に新鮮なレスポンスを返す事ができる。
</p>

<p>
我々が期待する事は、有効期限が切れる前にエンティティは意味的に重要な方法では変更無いであろう、という確信を持って、サーバがレスポンスに将来の明確な有効期限を割り当てているだろう事である。
これは普通、サーバが期限を注意深く選んでいる間は、意味的な透過性を維持する。
</p>

<p>
期限メカニズムは、キャッシュから取得したレスポンスのみに適用され、リクエストしているクライアントに直ちに転送されたファーストハンドのレスポンスには適用されない。
</p>

<p>
オリジンサーバがすべてのリクエストで強制的に意味的に透過なキャッシュの検証を望む場合、過去における明示的有効期限を割り当てる事が<em>できる</em>。
これは、そのレスポンスは既に古いので、キャッシュは以降のリクエストでそれを使用する前にその正当性を検証す<em>べきである</em>という事を意味する。
強制的な再検証のためのより限定的な方法については section <a href="#section-14.9.5">14.9.5</a> 参照。
</p>

<p>
もしオリジンサーバがすべての HTTP/1.1 キャッシュを、それがどのように設定されているかに関わらず、すべてのリクエストで強制的に検証させたい場合、&quot;must-revalidate&quot; cache-control 指示子 (section <a href="#section-14.9">14.9</a> 参照) を使う<em>べきである</em>。
</p>

<p>
サーバは、Expires ヘッダか Cache-Control ヘッダの max-age 指示子のどちらかを使って明示的有効期限を指定する。
</p>

<p>
有効期限は、表示の更新や、リソースのリロードをユーザエージェントに強制するために使う事はできない。
その意味論はキャッシングメカニズムにのみ適用され、そのようなメカニズムはそのリソースへの新しいリクエストが始められた時にそのリソースの期限ステータスのみをチェックする必要がある。
キャッシュと履歴メカニズムの違いについての説明は section <a href="#section-13.13">13.13</a> 参照。
</p>

<h4 id="section-13.2.2">13.2.2 帰納的有効期限</h4>

<p>
オリジンサーバは明示的有効期限を常に提供するわけではないので、HTTP キャッシュは典型的に、本当の有効期限を見積もるために (Last-Modified の時間のような) 別のヘッダ値を使うようなアルゴリズムを使って、帰納的有効期限を割り当てる。
HTTP/1.1 仕様書では詳細なアルゴリズムを提供しないが、その結果への最悪の場合の制約を課す。
帰納的有効期限は意味的な透過性を損なうかもしれないので、それらは慎重に使用されるべきであり、我々はオリジンサーバが可能な限り明確な有効期限を提供するという事を推奨する。
</p>

<h4 id="section-13.2.3">13.2.3 経過時間の計算</h4>

<p>
キャッシュエントリが新鮮かどうかを知るために、キャッシュは経過時間がその有効期間を超えているかどうかを知る必要がある。
我々は、section <a href="#section-13.2.4">13.2.4</a> において後者、すなわち有効期限の計算方法についてを論議する。
この章ではレスポンスやキャッシュエントリの経過時間の計算方法についてを記述する。
</p>

<p>
この議論で、我々は &quot;now&quot; という用語を &quot;計算が行われているホストの現在の時刻&quot; という意味で使用する。
HTTP を使用する、特にオリジンサーバとキャッシュを実行しているホストは、それらの時計を世界的に正確な標準時刻に同期させるため NTP <a href="#ref-28">[28]</a> やそれと同じようなプロトコルを使用す<em>べきである</em>。
</p>

<p>
HTTP/1.1 では、オリジンサーバが可能であればすべてのレスポンスに、レスポンスが生成された時間を与えた Date ヘッダを送る事を要求する (section <a href="#section-14.18">14.18</a> 参照)。
我々は &quot;date_value&quot; という用語を、演算のための適切な形式において Date ヘッダの値を示すものとして使用する。
</p>

<p>
HTTP/1.1 では、レスポンスメッセージがキャッシュから得られた時にその経過時間の見積もりを伝えるために Age レスポンスヘッダを使用する。
Age フィールド値は、レスポンスがオリジンサーバによって生成、あるいは再検証されてからのキャッシュの時間量の見積もりである。
</p>

<p>
本質的に、Age 値はオリジンサーバからの経路に沿ってあるそれぞれのキャッシュでレスポンスが存在する時間と、ネットワーク経路に沿う転送にかかった時間の合計である。
</p>

<p>
我々は &quot;age_value&quot; という用語を、演算のための適切な形式で Age ヘッダの値を示すために使用する。
</p>

<p>
レスポンスの経過時間は二つの完全に独立した方法で計算する事ができる。
</p>

<ol>
<li>もしローカルの時計がオリジンサーバの時計と十分に同期しているならば、now から date_value を引く。
もしその結果が負になったら、それをゼロに置き換える。</li>
<li>もしレスポンス経路上のすべてのキャッシュが HTTP/1.1 を実装していれば、age_value である。</li>
</ol>

<p>
レスポンスを受け取った時にその経過時間を計算するために二つの独立した方法を与える事で、我々はそれらを以下のように組み合わせる事ができる。
</p>

<pre> corrected_received_age = max(now - date_value, age_value)
</pre>

<p>
我々は、ほとんど同期している時計か、あるいはすべてが HTTP/1.1 を実装した経路のどちらかを持つならば、信頼できる (保守的な) 結果を得る。
</p>

<p>
ネットワークに課される遅れによって、サーバがレスポンスを生成してから次のアウトバウンドのキャッシュやクライアントに受け取られるまでの間に多少の重要な間隔が経過するかもしれない。
もしこれが訂正されなければ、この遅延は不適当に少ない経過時間をもたらす事になる。
</p>

<p>
返された Age 値をもたらしたリクエストはその Age 値の生成より前に開始していなければならないので、リクエストを開始した時間を記録する事によってネットワークによって課された遅れを是正する事ができる。
従って、Age 値が受信された時には、それはレスポンスが受信された時間に関してでは無く、リクエストが開始された時間に関して解釈され<em>なければならない</em>。
このアルゴリズムでは、どれくらいの遅延が発生したかに関わらず保守的な振る舞いに帰着する。
そのため、我々は以下のものを計算する。
</p>

<pre> corrected_initial_age = corrected_received_age
                       + (now - request_time)
</pre>

<p>
ここで &quot;request_time&quot; は、このレスポンスを引き起こしたリクエストが送信された時の (ローカルの時計による) 時間である。
</p>

<p>
キャッシュがレスポンスを受け取った時の経過時間の計算アルゴリズムの要約は以下の通りである。
</p>

<pre> /*
  * age_value
  *      このレスポンスを持つキャッシュが受け取った Age: ヘッダの値
  * date_value
  *      オリジンサーバの Date: ヘッダの値
  * request_time
  *      キャッシュがそのキャッシュされたレスポンスを生み出したリク
  *              エストを作った (ローカルの) 時間
  * response_time
  *      キャッシュがレスポンスを受け取った (ローカルの) 時間
  * now
  *      現在の (ローカルの) 時間
  */

 apparent_age = max(0, response_time - date_value);
 corrected_received_age = max(apparent_age, age_value);
 response_delay = response_time - request_time;
 corrected_initial_age = corrected_received_age + response_delay;
 resident_time = now - response_time;
 current_age   = corrected_initial_age + resident_time;
</pre>

<p>
キャッシュエントリの current_age は、corrected_initial_age にキャッシュエントリがオリジンサーバによって最後に検証されてから (秒単位の) 時間量が加えられる事によって計算される。
レスポンスがキャッシュエントリによって生成された時、キャッシュはキャッシュエントリの current_age と等しい値をレスポンスに単一の Age ヘッダフィールドを含め<em>なければならない</em>。
</p>

<p>
レスポンスに Age ヘッダフィールドがあれば、レスポンスはファーストハンドでは無いという事を暗黙的に意味する。
しかし、リクエスト経路のすべてのキャッシュが HTTP/1.1 に従順で無ければ、レスポンスに Age ヘッダフィールドが無い事がレスポンスがファーストハンドである事を意味しないので、逆は真ではない (古い HTTP キャッシュは Age ヘッダフィールドを実装していないので)。
</p>

<h4 id="section-13.2.4">13.2.4 期限の計算</h4>

<p>
レスポンスが新鮮かどうかを決定するために、その有効期間と経過時間とを比較する必要がある。
経過時間は、section <a href="#section-13.2.3">13.2.3</a> にて表されているように計算されるが、この章では有効期間の計算方法と、レスポンスの期限が切れたかどうかの決定方法を記述する。
以下の議論において、その値は演算に対する適当な形式において表される。
</p>

<p>
我々は、&quot;expires_value&quot; という用語を Expires ヘッダの値を示すものとして使用する。
また、&quot;max_age_value&quot; という用語をレスポンス中の Cache-Control ヘッダの max-age 指示子 (section <a href="#section-14.9.3">14.9.3</a> 参照) によって伝えられた秒数の適切な値を示すものとして使用する。
</p>

<p>
max-age 指示子は Expires より優先されるので、もし max-age がレスポンス中にあれば、その計算は簡単である。
</p>

<pre> freshness_lifetime = max_age_value
</pre>

<p>
そうで無い場合に、もし Expires がレスポンス中にあれば、その計算は次の様になる。
</p>

<pre> freshness_lifetime = expires_value - date_value
</pre>

<p>
それらの情報のすべてがオリジンサーバからのものなので、どちらの計算も時計のずれに影響は受けない事に注意せよ。
</p>

<p>
レスポンスに Expires, Cache-Control: max-age, Cache-Control: s-maxage (section <a href="#section-14.9.3">14.9.3</a> 参照) のいずれも無く、レスポンスがキャッシングにおいて別の制限を受けていなければ、キャッシュは帰納的な方法を使って有効期限を計算しても<em>よい</em>。
キャッシュは、その経過時間が 24 時間を越えていながら Warning 113 の警告が付け加えられていないレスポンスがあれば、警告を追加し<em>なければならない</em>。
</p>

<p>
また、もしレスポンスが Last-Modified 時間を持っていたら、帰納的有効期限値は多くてもその時間からの間隔のある分数にす<em>べきである</em>。
この分数の典型的な設定値は 10% である。
</p>

<p>
レスポンスの期限が切れたかどうかを決定する計算は極めて単純である。
</p>

<pre> response_is_fresh = (freshness_lifetime &gt; current_age)
</pre>

<h4 id="section-13.2.5">13.2.5 期限値を曖昧にしない事</h4>

<p>
期限値が楽天的に割り当てられるために、二つのキャッシュが同じリソースに対して異なる新鮮度値を含む事が可能である。
</p>

<p>
もし回収を実行しているクライアントが自身のキャッシュにおいて既に新鮮であるリクエストに対してファーストハンドで無いレスポンスを受け取り、存在するキャッシュエントリの Date ヘッダが新しいレスポンスの Date ヘッダよりも新しければ、クライアントはそのレスポンスを無視する事が<em>できる</em>。
その場合、オリジンサーバに強制的にチェックするため、&quot;Cache-Control: max-age=0&quot; 指示子 (section <a href="#section-14.9">14.9</a> 参照) を持ったリクエストを再試行<em>できる</em>。
</p>

<p>
もしキャッシュが同じ表現だが異なるバリディタを持つ二つの新鮮なレスポンスを持つなら、Date ヘッダが新しい方を使わ<em>なければならない</em>。
この状況は、キャッシュが別のキャッシュからのレスポンスを共有するため、あるいはクライアントが明らかに新鮮なキャッシュエントリの再ロードや再検証を要求したために生じるかもしれない。
</p>

<h4 id="section-13.2.6">13.2.6 複数のレスポンスを曖昧にしない事</h4>

<p>
クライアントは複数の経路からレスポンスを受け取る事ができるので、あるレスポンスがあるキャッシュのセットを通って流れ、別のレスポンスが別のキャッシュのセットを通って流れる場合、クライアントはオリジンサーバがレスポンスを送った時とは違う順番でレスポンスを受け取るかもしれない。
もし古いレスポンスがまだ明らかに新鮮であっても、クライアントは最も新しく生成されたレスポンスを使うした方が良い。
</p>

<p>
後のレスポンスはより早い有効期限を故意に指定する事ができるので、エンティティタグや期限値でレスポンスに順序付けを課す事はできない。
Date 値に秒の粒状性{granularity} を定めた。
</p>

<p>
クライアントがキャッシュエントリの再検証を試行し、受信したレスポンスが既存のエントリの Date ヘッダよりも古い Date ヘッダを含んでいる時、クライアントはそのリクエストを無条件に繰り返す<em>べきであり</em>、そこに
</p>

<pre> Cache-Control: max-age=0
</pre>

<p>
を、あらゆる中間キャッシュにオリジンサーバへそれらのコピーの検証を強制的に行わせるために含むか、あるいは
</p>

<pre> Cache-Control: no-cache
</pre>

<p>
を、あらゆる中間キャッシュにオリジンサーバからの新しいコピーを強制的に取得させるために含む<em>べきである</em>。
</p>

<p>
Date 値が等しい場合、クライアントはどちらのレスポンスでも使う事が<em>できる</em> (あるいは極端に慎重になるでのあれば、新しいレスポンスを要求しても<em>よい</em>)。
もし同じ秒の間に生成されたレスポンスの有効期限が重複していたら、サーバはその選択の決定についてそれができるクライアントを当てにし<em>てはならない</em>。
</p>

<h3 id="section-13.3">13.3 検証{Validation} モデル</h3>

<p>
キャッシュがクライアントのリクエストへのレスポンスとして使いたいような新鮮で無いエントリを持っている時、そのキャッシュされたエントリがまだ使用可能かどうかを確かめるために最初にオリジンサーバ (かあるいは新鮮なレスポンスを持っている中間キャッシュ) へチェックしなければならない。
我々はこれをキャッシュエントリの &quot;検証{validating}&quot; と呼ぶ。
もしキャッシュされたエントリで良ければ我々は完全なレスポンスの再転送によるオーバーヘッドを望まないし、キャッシュされたエンティティが適切で無ければ余分なラウンドトリップによるオーバーヘッドを望まないので、HTTP/1.1 プロトコルは条件付きメソッドの使用をサポートしている。
</p>

<p>
条件付きメソッドをサポートするための重要なプロトコルの機能は、&quot;キャッシュバリディタ&quot; に関するものである。
オリジンサーバが全体のレスポンスを生成する時、それにある種のバリディタを付けられ、キャッシュエントリと共に保存される。
クライアント (ユーザエージェントやプロクシキャッシュ) がキャッシュエントリに持つリソースに条件付きリクエストを作る時、リクエストに関するバリディタを追加する。
</p>

<p>
この時サーバはそのバリディタと現在のエンティティのバリディタを調べ、もしそれらが一致すれば (section <a href="#section-13.3.3">13.3.3</a> 参照) 、エンティティボディを含まない特別なレスポンスコード (通常は 304 (Not Modified)) を返す。
そうで無ければ、完全なレスポンス (エンティティボディを含む) を返す。
従って、もしバリディタが一致すれば完全なレスポンスを転送する事は避けられるし、一致しなければ余分なラウンドトリップを避けられる。
</p>

<p>
HTTP/1.1 において、条件付きリクエストは、暗にそのメソッド (通常 GET) を条件付きにする (バリディタを含んだ) 特別なヘッダを含む事を除けば、同じリソースに対する通常のリクエストと全く同じに見える。
</p>

<p>
プロトコルは、キャッシュの検証条件の肯定的と否定的の両方の意図を持っている。
つまり、バリディタが一致した時のみ、あるいはバリディタが一致しなかった時のみ、のどちらかでメソッドが実行されるという事を要求する事ができる。
</p>

<p class="note">
注: バリディタの無いレスポンスは、もしそれが Cache-Control 指示子によって明示的に禁止されていなければ、その期限が切れるまでキャッシュされ、また使用されるであろう。
しかし、もしキャッシュがそのエンティティのバリディタを持っていなければ条件付き回収を行う事ができない。
これはその期限が切れた後も再び新しくする事はできないだろうという事を意味する。
</p>

<h4 id="section-13.3.1">13.3.1 Last-modified の日付</h4>

<p>
Last-Modified エンティティヘッダフィールド値はしばしばキャッシュバリディタとして使われる。
簡単な条件としては、もしエンティティが Last-Modified 値から更新されていなければキャッシュエントリは有効であるとみなせる。
</p>

<h4 id="section-13.3.2">13.3.2 エンティティタグのキャッシュバリディタ</h4>

<p>
ETag レスポンスヘッダフィールド値、すなわちエンティティタグは、&quot;それ自体は読んでも意味のわからない{opaque}&quot; キャッシュバリディタを提供する。
これによって、更新時刻を保存する事が不都合な状況、HTTP 日付値の秒単位の解析が十分でない状況、オリジンサーバが更新時刻の使用から起こるであろうある種の矛盾を避ける事を望む状況でより信頼できる検証ができるようになるだろう。
</p>

<p>
エンティティタグは section <a href="#section-3.11">3.11</a> にて記述される。
エンティティタグと共に使われるヘッダは section <a href="#section-14.19">14.19</a>, <a href="#section-14.24">14.24</a>, <a href="#section-14.26">14.26</a>, <a href="#section-14.44">14.44</a> にてそれぞれ記述される。
</p>

<h4 id="section-13.3.3">13.3.3 弱いバリディタと強いバリディタ</h4>

<p>
オリジンサーバやキャッシュの両方でそれが同じエンティティを表すかどうかを決定するために二つのバリディタを比較するため、通常はエンティティ(エンティティボディかエンティティヘッダ) が何らかの理由で変わっていたら、それに関するバリディタも同様に変更しているだろうという事を期待できる。
これが真である場合、我々はこのバリディタを &quot;強いバリディタ&quot; と呼ぶ。
</p>

<p>
しかしながら、サーバがエンティティの意味的に重要な変更時にのみバリディタを変更し、重要でない側面にはバリディタを変更したがらない場合があるかもしれない。
リソースの変更時に常に変更されないバリディタは &quot;弱いバリディタ&quot; である。
</p>

<p>
エンティティタグは通常 &quot;強いバリディタ&quot; であるが、このプロトコルでは &quot;弱い&quot; エンティティタグを付けるためのメカニズムを提供している。
強いバリディタはエンティティが少しでも変更した時に変更されるもので、弱いバリディタはエンティティの意味が変更した時に変更される、と考える事ができる。
または、強いバリディタは特定のエンティティの識別子{identifier} の一部であり、弱いバリディタは意味的に等しいエンティティのセットの識別子の一部である、と考える事もできる。
</p>

<p class="note">
注: 強いバリディタの一例に、安定した記憶装置においてエンティティが変更される毎に増加される整数がある。
</p>

<p class="note">
エンティティの更新時間は、リソースを1秒以内に2度更新する事は可能なので、もしそれが秒解像度に相当するなら弱いバリディタである。
</p>

<p class="note">
弱いバリディタのサポートはオプションである。
しかしながら、弱いバリディタによって同等のオブジェクトのより効率的なキャッシングができるようになる。
例えば、あるサイトのヒットカウンタが数日や数週毎に更新されるのであればおそらくそれで十分に良く、その期間内のあらゆる値は多分 &quot;十分に良く{good enough}&quot; 等しい。
</p>

<p>
バリディタの &quot;使用&quot; は、クライアントがリクエストを生成し検証用ヘッダフィールドにバリディタを含む時、あるいはサーバが二つのバリディタを比較する時のどちらかである。
</p>

<p>
強いバリディタはいかなる状況にも使う事ができる。
弱いバリディタはエンティティの正確な等価性に頼らない状況においてのみ使う事ができる。
例えば、完全なエンティティの条件付き GET のためにどちらかの種類を使う事ができる。
しかし、別の方法ではクライアントが内部的に一致しないエンティティとなってしまうかもしれないので、サブレンジ回収のためには強いバリディタのみを使う事ができる。
</p>

<p>
クライアントは、単純な (非サブレンジ) GET リクエストの発行には弱いバリディタも強いバリディタも使う事が<em>できる</em>。
その他のリクエストの形式には弱いバリディタを使っ<em>てはならない</em>。
</p>

<p>
HTTP/1.1 プロトコルがバリディタに定義している機能は比較のみである。
二つのバリディタ比較機能があり、これは比較状況が弱いバリディタの使用を許すかどうかに依存する。
</p>

<dl>
<dt>強い比較機能</dt>
<dd>等しさを検討するため、両方のバリディタはあらゆる方法で同一でなければならなく、両方のバリディタは共に弱くない。</dd>
<dt>弱い比較機能</dt>
<dd>等しさを検討するため、両方のバリディタはあらゆる方法で同一でなければならない。
ただし、これらのどちらかもしくは両方は結果に影響する事なく &quot;弱い&quot; とマークされている。</dd>
</dl>

<p>
明確に弱いと印されていなければエンティティタグは強い。
section <a href="#section-3.11">3.11</a> ではエンティティタグのための構文を与えている。
</p>

<p>
Last-Modified 時間がリクエストにおいてバリディタとして使用された時、以下の規定を使ってそれが強いと推定できなければ暗黙的に弱い。
</p>

<ul>
<li>そのバリディタがオリジンサーバによってエンティティに対する実際の現在のバリディタと比較されており、</li>
<li>オリジンサーバが関連するエンティティが与えられたバリディタが扱える秒の間に二度変更していない事を確実に知っている。</li>
</ul>

<p>
あるいは
</p>

<ul>
<li>クライアントが関連するエンティティについてのキャッシュエントリを持っているので、If-Modified-Since か If-Unmodified-Since ヘッダ内でそのバリディタを使おうとしているところであり、</li>
<li>そのキャッシュエントリが、オリジンサーバが元々のレスポンスを送った時の時刻を与える Date 値を含み、</li>
<li>与えられた Last-Modified 時刻は、その Date 値から最低 60 秒前である。</li>
</ul>

<p>
あるいは
</p>

<ul>
<li>そのバリディタが中間キャッシュによってエンティティに対する自身のキャッシュエントリに保存しているバリディタと比較され、</li>
<li>そのキャッシュエントリが、オリジンサーバが元々のレスポンスを送った時の時刻を与える Date 値を含み、</li>
<li>与えられた Last-Modified 時刻は、その Date 値から最低 60 秒前である。</li>
</ul>

<p>
この方法は、二つの異なるレスポンスが同じ秒にオリジンサーバから送られたが、両方とも同じ Last-Modified 時刻を持っていた場合に、それらのレスポンスの少なくとも一つはその Last-Modified 時刻と同じ Date 値を持っているであろうという事実を当てにしている。
独断的な 60 秒制限は Date と Last-Modified 値が別の時計から、あるいはレスポンスの準備の間のわずかに異なる時間に生成されるという可能性について警戒する。
もし実装が 60 秒はあまりに短いと思うのであれば、60 秒より大きな値を使用しても<em>よい</em>。
</p>

<p>
もしクライアントが Last-Modified 時刻のみを持ち、それ自体は読んでも意味のわからない{opaque} バリディタを持たない値のサブレンジ回収を行いたければ、Last-Modified 時刻がここで記述された意図において強い場合のみこれを行う事が<em>できる</em>。
</p>

<p>
完全なボディの GET リクエスト以外の、条件付きリクエストを受信するキャッシュやオリジンサーバは、条件を評価するために強い比較機能を使わ<em>なければならない</em>。
</p>

<p>
これらの規定によって、HTTP/1.1 キャッシュやクライアントは HTTP/1.0 サーバから得られた値のサブレンジ回収を安全に実行できるようになる。
</p>

<h4 id="section-13.3.4">13.3.4 エンティティタグや Last-Modified の日付を使う場合の規定</h4>

<p>
我々は様々なバリディタタイプがいつ、何の目的で使用されるべきかに関するオリジンサーバ、クライアント、キャッシュのための規定と推薦のセットを採用する。
</p>

<p>
HTTP/1.1 オリジンサーバについて
</p>

<ul>
<li>エンティティタグバリディタを生成する事が不可能で無いのであれば、それを送る<em>べきである</em>。</li>
<li>パフォーマンス考慮が弱いエンティティタグの使用を支持しているか、強いエンティティタグを送る事を不可能であるならば、強いエンティティタグの代わりに弱いエンティティタグを送る事が<em>できる</em>。</li>
<li>Last-Modified 値を送る事が可能で、If-Modified-Since ヘッダ中にこの日付の使う事から生じる、意味的な透過性における故障の危険が深刻な問題を引き起さなければ、Last-Modified 値を送る<em>べきである</em>。</li>
</ul>

<p>
言い換えれば、HTTP/1.1 オリジンサーバにとってより望まれる動作とは強いエンティティタグと Last-Modified 値の両方を送る事である。
</p>

<p>
規格上適正であるため、強いエンティティタグは関連するエンティティ値にどんな点においての変化があっても変わら<em>なければならない</em>。
弱いエンティティタグは関連するエンティティタグが意味上で重要な点において変わる時に変わる<em>べきである</em>。
</p>

<p class="note">
注: 意味的に透過なキャッシングを提供するため、オリジンサーバは二つの異なるエンティティに対しての特定の強いエンティティタグ値の再使用、あるいは二つの意味的に異なるエンティティに対しての特定の弱いエンティティタグ値の再使用を避けなければならない。
キャッシュエントリは有効期限に関係なく、任意に長期間持続するかもしれないので、キャッシュが過去のある点で得られたバリディタを使ってエントリの検証を再び試みる事は無いだろうと期待する事は不適当であろう。
</p>

<p>
HTTP/1.1 クライアントについて
</p>

<ul>
<li>エンティティタグがオリジンサーバによって提供されていたら、あらゆるキャッシュ条件付きリクエスト内で (If-Match か If-None-Match を使って) 内でこのエンティティタグを使わ<em>なければならない</em>。</li>
<li>Last-Modified 値のみがオリジンサーバによって提供されていたら、非サブレンジキャッシュ条件付きリクエスト内で (If-Modified-Since を使って) この値を使う<em>べきである</em>。</li>
<li>Last-Modified 値のみが HTTP/1.0 オリジンサーバによって提供されていたら、サブレンジキャッシュ条件付きリクエスト (If-Unmodified-Since を使った) においてこの値を使う事が<em>できる</em>。
これが難しい場合、ユーザエージェントはこれを無効にする方法を提供す<em>べきである</em>。</li>
<li>エンティティタグと Last-Modified 値の両方がオリジンサーバによって提供されていたら、キャッシュ条件付きリクエスト内で両方のバリディタを使う<em>べきである</em>。
これによって HTTP/1.0 と HTTP/1.1 キャッシュが適切に応答できるようになる。</li>
</ul>

<p>
Last-Modified 時刻 (例えば If-Modified-Since や If-Unmodified-Since 各ヘッダフィールド内で) と一つ以上のエンティティタグ (例えば If-Match, If-None-Match, If-Range 各ヘッダフィールド内で) をキャッシュバリディタとして含む条件付きリクエストを受信した HTTP/1.1 オリジンサーバは、その行いがそのリクエスト内の条件付きヘッダフィールドのすべてに一致しているのでなければ 304 (Not Modified) ステータスを返し<em>てはならない</em>。
</p>

<p>
Last-Modified 時刻と一つ以上のエンティティタグをキャッシュバリディタとして含む条件付きリクエストを受信したHTTP/1.1 キャッシングプロクシは、キャッシュされたレスポンスががそのリクエスト内の条件付きヘッダフィールドのすべてに一致しているのでなければクライアントに局地的にキャッシュされたレスポンスを返し<em>てはならない</em>。
</p>

<p class="note">
注: これらの規定の背景にある一般的な基本方針は、HTTP/1.1 サーバとクライアントがそれらのレスポンスやリクエストで利用可能であるような同等に余分過ぎない情報の転送を行うべきであるという事である。
この情報を受信する HTTP/1.1 システムは、それらが受信するバリディタについて最も保守的な仮定を行うだろう。
</p>

<p>
HTTP/1.0 クライアントやキャッシュは、エンティティタグを無視するだろう。
一般的に、これらのシステムによって受信され、使われる Last-Modified 値は透過的で効果的なキャッシングをサポートするであろうから、HTTP/1.1 オリジンサーバは Last-Modified 値を提供すべきである。
HTTP/1.0 システムによってバリディタとして Last-Modified 値を使う事が深刻な問題を引き起こすというようなまれな場合では、HTTP/1.1 オリジンサーバはこれを提供すべきではない。
</p>

<h4 id="section-13.3.5">13.3.5 非検証条件</h4>

<p>
エンティティタグの背景にある原理は、サービスの著者のみが適切なキャッシュバリディタメカニズムを選択するのに十分なリソースの意味論を知る事で、バイト等価性よりも複雑なあらゆるバリディタ比較機能についての仕様書は虫の缶{can of worms} を開ける事になるだろう。
従って、その他のヘッダの比較は (HTTP/1.0 互換性のための Last-Modified を除いて) キャッシュエントリの検証の目的では決して使用されない。
</p>

<h3 id="section-13.4">13.4 レスポンスのキャッシュ可能性</h3>

<p>
Cache-Control (section <a href="#section-14.9">14.9</a>) 指示子によって特に強制されていなければ、キャッシングシステムはキャッシュエントリとして成功したレスポンス (section <a href="#section-13.8">13.8</a> 参照) を常に保存<em>でき</em>、それが新鮮であれば検証無しにそれを返す事が<em>でき</em>、検証の後にそれを返す事も<em>できる</em>。
もしレスポンスに関連するキャッシュバリディタも明示的有効期限も無ければ、我々はそれがキャッシュされる事を期待しないが、特定のキャッシュはこの期待に違反する事が<em>できる</em> (例えば、ほとんどもしくは全くネットワーク接続が利用できない時)。
クライアントは、Date ヘッダと現在時刻を比較する事によってそのようなレスポンスがキャッシュから取得された事をたいてい検出
できる。
</p>

<p class="note">
注: HTTP/1.0 キャッシュの中には、どんな Warning も提供せずにこの期待を違反する物がある事が知られている。
</p>

<p>
しかし、いくつかの場合でキャッシュがエンティティを保持し、あるいは以降のリクエストのレスポンスとしてそれを返す事は不適切かもしれない。
これは絶対的な意味的透過性がサービスの著者によって必要であると思われるため、あるいはセキュリティやプライバシーへの配慮のためであろう。
それ故に、サーバがあるリソースエンティティ、あるいはその一部分についてが、それらの考慮に関わらずキャッシュされないという事を示せるように特定の Cache-Control 指示子が提供される。
</p>

<p>
section <a href="#section-14.8">14.8</a> では、そのリクエストが Authorization ヘッダを含んでいたら、通常は共有されたキャッシュは以前のリクエストへのレスポンスを保存したり返したりできないようにしている事に注意せよ。
</p>

<p>
200, 203, 206, 300, 301, 410 のステータスコードと共に受信されたレスポンスは、cache-control 指示子がキャッシングを禁止していなければ、キャッシュによって保存され、以降のリクエストへの応答に使用され、期限メカニズムに従う事が<em>できる</em>。
しかし、Range と Content-Range ヘッダをサポートしていないキャッシュは 206 (Partial Content) レスポンスをキャッシュし<em>てはならない</em>。
</p>

<p>
それ以外のステータスコード (例えば 302 や 307) と共に受信されたレスポンスは、明示的にそれを認める cache-control 指示子や別のヘッダが無ければ、以降のリクエストへの応答として返され<em>てはならない</em>。
例えば、これらは以下の物を含む: Expires ヘッダ (section <a href="#section-14.21">14.21</a>); &quot;max-age&quot;, &quot;s-maxage&quot;, &quot;must-revalidate&quot;, &quot;proxy-revalidate&quot;, &quot;public&quot;, &quot;private&quot;
各 cache-control 指示子 (section <a href="#section-14.9">14.9</a>)。
</p>

<h3 id="section-13.5">13.5 キャッシュからの構築したレスポンス</h3>

<p>
HTTP キャッシュの目的は、将来のリクエストへの応答での使用するためにリクエストへのレスポンスで受信した情報を保存する事である。
多くの場合、キャッシュはリクエスト者へ単純にレスポンスの適切な部分を返す。
しかしながら、もしキャッシュが以前のレスポンスに基づくキャッシュエントリを持っていたら、新しいレスポンスの部分とキャッシュエントリとして持っているものとを結び付ける事ができる。
</p>

<h4 id="section-13.5.1">13.5.1 エンドトゥエンドヘッダとホップバイホップヘッダ</h4>

<p>
キャッシュや非キャッシュプロクシの振る舞いを定義する目的のために、我々は HTTP ヘッダを二つのカテゴリに分ける。
</p>

<ul>
<li>エンドトゥエンドヘッダ。これはリクエストやレスポンスの最後の受信者に転送されるものである。レスポンス中のエンドトゥエンドヘッダはキャッシュエントリの一部として保存され<em>なければならない</em>し、またキャッシュエントリから形成されたあらゆるレスポンスで転送され<em>なければならない</em>。</li>
<li>ホップバイホップヘッダ。これは単一の転送レベル接続に対してのみ意味を持ち、キャッシュによって保存されたりプロクシによって転送されたりしないものである。</li>
</ul>

<p>
以下の HTTP/1.1 ヘッダはホップバイホップヘッダである。
</p>

<ul>
<li>Connection</li>
<li>Keep-Alive</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Authorization</li>
<li>TE</li>
<li>Trailers (※)</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>

<p class="note">
(※訳注) &quot;Trailer&quot; (section <a href="#section-14.40">14.40</a>) の Typo と思われる。
</p>

<p>
HTTP/1.1 で定義されている他のすべてのヘッダはエンドトゥエンドヘッダである。
</p>

<p>
HTTP/1.1 (あるいはそれ以降) に導入されるその他のホップバイホップヘッダは、Connection ヘッダにおいて列挙され<em>なければならない</em> (section <a href="#section-14.10">14.10</a>)。
</p>

<h4 id="section-13.5.2">13.5.2 修正できないヘッダ</h4>

<p>
Digest 認証のような、HTTP/1.1 プロトコルのいくつかの機能では、特定のエンドトゥエンドヘッダの値に依存する。
透過的プロクシは、そのヘッダの定義がそれを要求していたり、あるいはそれが特に許されている場合以外は、エンドトゥエンドヘッダを修正す<em>べきではない</em>。
</p>

<p>
透過的プロクシはリクエストやレスポンス中の以下のフィールドのどれも修正し<em>てはならない</em>し、それが存在していなければそれらを追加し<em>てはならない</em>。
</p>

<ul>
<li>Content-Location</li>
<li>Content-MD5</li>
<li>ETag</li>
<li>Last-Modified</li>
</ul>

<p>
透過的プロクシはレスポンス中の以下のフィールドについては修正し<em>てはならない</em>。
</p>

<ul>
<li>Expires</li>
</ul>

<p>
しかし、それが存在していなければそれらを追加する事が<em>できる</em>。
Expires ヘッダが追加された場合、その field-value にはそのレスポンス中の Date ヘッダと同じ値が与えられ<em>なければならない</em>。
</p>

<p>
プロクシは、no-transform cache-control 指示子を含んでいるメッセージ、あるいはあらゆるリクエストにおいて、以下のフィールドのどれも修正したり追加し<em>てはならない</em>。
</p>

<ul>
<li>Content-Encoding</li>
<li>Content-Range</li>
<li>Content-Type</li>
</ul>

<p>
非透過的プロクシは no-transform を含まないメッセージにはこれらのフィールドを修正したり追加したり<em>できる</em> が、そうする場合、メッセージ中にそれがまだ示されていなければ Warning 214 (Transformation applied) を追加し<em>なければならない</em> (section <a href="#section-14.46">14.46</a> 参照)。
</p>

<p class="note">
警告: もし HTTP の以降のバージョンでより強固な認証メカニズムが導入されるなら、エンドトゥエンドヘッダを不必要に修正する事は認証失敗を引き起こすかもしれない。
そのような認証メカニズムはここで列挙されないヘッダフィールドの値を当てにする<em>かもしれない</em>。
</p>

<p>
リクエストやレスポンスの Content-Length フィールドは section <a href="#section-4.4">4.4</a> の規則に従って追加されたり消去される。
透過的プロクシは transfer-length (section <a href="#section-4.4">4.4</a>) を変更する事は<em>できる</em> が、エンティティボディの entity-length (section <a href="#section-7.2.2">7.2.2</a>) は維持し<em>なければならない</em>。
</p>

<h4 id="section-13.5.3">13.5.3 ヘッダの連結</h4>

<p>
キャッシュがサーバに検証リクエストを送り、サーバが 304 (Not Modified) か 206 (Partial Content) レスポンスを返した場合、キャッシュはリクエストしたクライアントに返すレスポンスを構築する。
</p>

<p>
ステータスコードが 304 (Not Modified) の場合、キャッシュは出力するレスポンスのエンティティボディとしてキャッシュエントリに保存されたエンティティボディを使う。
ステータスコードが 206 (Partial Content) で ETag か Last-Modified 各ヘッダが正確に一致した場合、キャッシュはキャッシュエントリに保存された内容とレスポンスとして新たに受信した内容を連結<em>でき</em>、出力するレスポンスのエンティティボディとしてそれを使う事が<em>できる</em> (section <a href="#section-13.5.4">13.5.4</a> 参照)。
</p>

<p>
キャッシュエントリに保存されたエンドトゥエンドヘッダは、以下を除いて構築されたレスポンスのために使われる。
</p>

<ul>
<li>warn-code 1xx を持った Warning ヘッダ (section <a href="#section-14.46">14.46</a> 参照) はすべてキャッシュエントリや転送されるレスポンスから削除され<em>なければならない</em>。</li>
<li>warn-code 2xx を持った Warning ヘッダはすべてキャッシュエントリや転送されるレスポンス中で保持され<em>なければならない</em>。</li>
<li>304 や 206 各レスポンス中にあるエンドトゥエンドヘッダはキャッシュエントリから対応するヘッダを置き換え<em>なければならない</em>。</li>
</ul>

<p>
キャッシュがそのキャッシュエントリの削除を決めた場合以外は、すぐ上で示したように Warning ヘッダを除いて、キャッシュエントリと共に保存されたエンドトゥエンドヘッダを入ってきたレスポンス中に含まれる対応するヘッダと置き換え<em>なければならない</em>。
もし入ってきたレスポンス中のヘッダフィールド名がキャッシュエントリ中の二つ以上のヘッダに一致したら、そのようなすべての古いヘッダは置きかえられ<em>なければならない</em>。
</p>

<p>
言い換えれば、入ってきたレスポンスで受信したエンドトゥエンドヘッダのセットはキャッシュエントリと共に保存されているすべての対応するエンドトゥエンドヘッダを上書きする (warn-code 1xx と共に保存される Warning ヘッダを除く、これは例え上書きされなくても削除される)。
</p>

<p class="note">
注: この規則によってオリジンサーバは 304 (Not Modified) や 206 (Partial Content) 各レスポンスを同じエンティティやその一部分に対する以前のレスポンスに関連するあらゆるヘッダを更新するために使えるようになるが、それが常に意味を持ったり常にそうするのが正しいわけではない。
この規則ではオリジンサーバが 304 (Not Modified)や 206 (Partial Content) 各レスポンスを以前のレスポンスにて提供されたヘッダを完全に削除する事はできない。
</p>

<h4 id="section-13.5.4">13.5.4 バイトレンジの連結</h4>

<p>
リクエストが一つ以上の Range 詳述を含んでいたり、接続が早まって切断されたりするので、レスポンスはエンティティボディのバイトのサブレンジのみを転送できる。
そのようないくつかの転送の後、キャッシュは同じエンティティボディのいくつかの範囲を受信する事ができる。
</p>

<p>
もしキャッシュがエンティティに対するサブレンジの保存された空でないセットを持っており、入ってきたレスポンスが別のサブレンジを転送するような時に、以下の両方の条件を満たすのであれば、キャッシュは新しいサブレンジを既存のセットと連結<em>できる</em>。
</p>

<ul>
<li>入ってきたレスポンスとキャッシュエントリの両方がキャッシュバリディタを持っている。</li>
<li>二つのキャッシュバリディタは強い比較機能 (section <a href="#section-13.3.3">13.3.3</a> 参照) を使って一致しなければならない。</li>
</ul>

<p>
この要求のどちらかを満たせない場合、キャッシュは最新の部分的なレスポンス (レスポンス毎に転送された Date 値に基づき、またそれらの値が等しいか欠けているのであれば入ってきたレスポンス) のみを使用し<em>なければならない</em> し、他の部分的な情報は破棄し<em>なければならない</em>。
</p>

<h3 id="section-13.6">13.6 ネゴシエートされたレスポンスのキャッシング</h3>

<p>
レスポンス中の Vary ヘッダフィールドの存在によって示されるような、サーバ駆動型内容ネゴシエーション (section <a href="#section-12.1">12.1</a>) を使う事は、キャッシュが以降のリクエストのためにそのレスポンスを使う事ができる事によってその条件と手続きを変更する。サーバによる Vary ヘッダフィールドの使用については section <a href="#section-14.44">14.44</a> を見よ。
</p>

<p>
サーバは、サーバ駆動型ネゴシエーションを受ける複数のキャッシュ可能なレスポンスの表現から選択するためにどんなヘッダフィールドが使用されたかをキャッシュに知らせるために Vary ヘッダフィールドを使う<em>べきである</em>。
Vary フィールド値によって名付けられたヘッダフィールドのセットは &quot;選択用{selecting}&quot; リクエストヘッダとして知られる。
</p>

<p>
キャッシュはその Request-URI が Vary ヘッダフィールドを含んだ一つ以上のキャッシュエントリを指定するような以降のリクエストを受信した時、新しいリクエスト中のすべての選択用リクエストヘッダがもとのリクエスト中の対応する保存されたリクエストヘッダに一致しなければ新しいリクエストへのレスポンスを構築するためにそのようなキャッシュエントリを使っ<em>てはならない</em>。
</p>

<p>
二つのリクエストからの選択用リクエストヘッダは、最初のリクエスト中の選択用リクエストヘッダが対応する BNF が許す場所において連続した空白 (LWS) を加えたり除いたりする事によって、また section <a href="#section-4.2">4.2</a> のメッセージヘッダについての規則に従って同じフィールド名を持つ複数のメッセージヘッダを連結する事によって、二番目のリクエスト中の選択用リクエストヘッダに変換出来る場合のみに一致すると定義される。
</p>

<p>
Vary ヘッダフィールド値が &quot;*&quot; の時は、常に一致に失敗し、そのリソースへの以降のリクエストはオリジンサーバによってのみ適切に解釈する事ができる。
</p>

<p>
キャッシュされたエントリの選択用リクエストヘッダフィールドが新しいリクエストの選択用リクエストヘッダフィールドに一致しない場合に、もしそれが条件付きリクエストでオリジンサーバへ新しいリクエストを送り、サーバが 304 (Not Modified) と共に使用されるエンティティを指し示すエンティティタグか Content-Location を返すので無ければ、キャッシュはリクエストを満足させるためにキャッシュされたエントリを使っ<em>てはならない</em>。
</p>

<p>
エンティティタグがキャッシュされた表現に割り当てられていた場合、転送されたリクエストは条件付きである<em>べきであり</em>、そのリソースに対するすべてのキャッシュエントリからの If-None-Match ヘッダフィールド中にエンティティタグを含む<em>べきである</em>。
これは現在キャッシュが保有しているエンティティのセットをサーバへ転送するもので、そのためそれらエンティティの内どれか一つがリクエストされたエンティティに一致した場合、サーバはキャッシュにエントリが適切をある事を伝えるためにその 304 (Not Modified) レスポンス中で ETag ヘッダフィールドを使う事ができる。
新しいレスポンスのエンティティタグが既存のエントリのものと一致する場合、新しいレスポンスは既存のエントリのヘッダフィールドを更新するために使用される<em>べきであり</em>、その結果はクライアントに返され<em>なければならない</em>。
</p>

<p>
既存のキャッシュエントリのいかなる物も関連するエンティティについての部分的な内容のみを含んでいる場合に、もしそのリクエストがそのエントリが完全に満足する範囲に対するものでなければそのエンティティタグは If-None-Match ヘッダに含まれる<em>べきではない</em>。
</p>

<p>
キャッシュが その Content-Location フィールドが同じ Request-URI に対する既存のキャッシュエントリの物のと一致し、そのエンティティタグが既存のエントリの物とは異なり、そしてその Date が既存のエントリの物より新しいような成功レスポンスを受信した場合、既存のエントリは将来のリクエストへのレスポンスとして返される<em>べきではなく</em>、それをキャッシュから削除す<em>べきである</em>。
</p>

<h3 id="section-13.7">13.7 共有キャッシュと非共有キャッシュ</h3>

<p>
セキュリティやプライバシー上の理由により、&quot;共有{shared}&quot; キャッシュと &quot;非共有{non-shared}&quot; キャッシュとの間に区別を付ける必要がある。
非共有キャッシュは単一のユーザのみがアクセス可能なものである。この場合のアクセス可能性とは、適切なセキュリティメカニズムによって施行される<em>べきである</em>。
他のキャッシュはすべて &quot;共有&quot; されたとみなされる。
この仕様書の別の章ではプライバシーの損失やアクセス制御の失敗を防止するために共有されたキャッシュの操作へのある制約をかけている。
</p>

<h3 id="section-13.8">13.8 エラーや不完全なレスポンスのキャッシュの振る舞い</h3>

<p>
不完全なレスポンス (例えば、Content-Length ヘッダで記述されたものより少ないデータのバイトを伴うもの) を受信するキャッシュはレスポンスを保存する事が<em>できる</em>。
しかし、キャッシュは部分的なレスポンスとしてこれを扱わ<em>なければならない</em>。
部分的なレスポンスは section <a href="#section-13.5.4">13.5.4</a> にて定義されているように結合する事ができるが、その結果は完全なレスポンスかもしれないし、まだ部分的であるかもしれない。
キャッシュは 206 (Partial Content) ステータスコードを使ってそれを明示的にそれを示さなければ、クライアントに部分的なレスポンスを返し<em>てはならない</em>。
キャッシュは 200 (OK) ステータスコードを使って 部分的なレスポンスを返してはならない。
</p>

<p>
もしキャッシュがエントリの正当性再検証を試みる一方で 5xx レスポンスを受信したら、リクエストしているクライアントにこのレスポンスを転送するか、あるいはまるでサーバが応答に失敗したかのように動作するかどちらかを行う事が<em>できる</em>。
後者の場合、キャッシュされたエントリが &quot;must-revalidate&quot; cache-control 指示子 (section <a href="#section-14.9">14.9</a> 参照) を含んでいなければ、以前に受信したレスポンスを返す事が<em>できる</em>。
</p>

<h3 id="section-13.9">13.9 GET や HEAD の副作用</h3>

<p>
オリジンサーバがそれらのレスポンスのキャッシングを明示的に禁止していない場合に、あらゆるリソースへ GET や HEAD メソッドを適用する事によってそれらのレスポンスがキャッシュから取り出されたならば、誤った動作を導くような副作用を抱える<em>べきではない</em>。
それらは副作用を抱える<em>かもしれない</em>が、キャッシュはそのキャッシング決定においてそのような副作用を考慮必要は無い。
キャッシュは常にキャッシングにおいてオリジンサーバの明示的な制限を観察する事が期待される。
</p>

<p>
この規則の一つの例外について記す。アプリケーションの中には伝統的に重要な副作用を抱えた操作を実行するためにクエリ URL (それらは rel_path 部分に &quot;?&quot; を含んでいる) を伴う GET や HEAD を使用しているものがあるので、キャッシュはサーバが明示的有効期限を与えていなければそのようなURI へのレスポンスを新鮮であるように扱っ<em>てはならない</em>。
これは、そのような URI に対する HTTP/1.0 サーバからのレスポンスはキャッシュから取り出される<em>べきではない</em> という事を特に意味している。
関連する情報については section <a href="#section-9.1.1">9.1.1</a> 参照。
</p>

<h3 id="section-13.10">13.10 更新や削除後の無効化</h3>

<p>
オリジンサーバ上のリソースに行われるあるメソッドの影響によって一つ以上の既存のキャッシュエントリが非透過で無効なものになってしまうかもしれない。
つまり、それらは &quot;新鮮&quot; であり続けるかもしれないが、それらはオリジンサーバがそのリソースへの新しいリクエストに対して返すであろうものを正確に反映していないという事である。
</p>

<p>
HTTP プロトコルでは、そのようなキャッシュエントリすべてが無効であると示す事を保証するための方法は無い。
例えば、オリジンサーバ上で変更を引き起こすリクエストはキャッシュエントリが保存されているプロクシを通り抜けていないかもしれない。
しかし、いくつかの規定は間違った振る舞いの可能性を減らす助けとなる。
</p>

<p>
この章では、&quot;エンティティを無効にする&quot; というフレーズは、キャッシュはその保存媒体からそのエンティティのすべてのインスタンスを削除する、あるいはそれらが以降のリクエストへのレスポンスとして返される前にそれらを &quot;不正&quot; と印し強制的に再検証を行う必要があるであろうという意味である。
</p>

<p>
HTTP メソッドによってはキャッシュがエンティティを無効にしなければならないものがある。
これは Request-URI によって参照されるエンティティ、あるいは (それが存在するならば) Location や Content-Location レスポンスフィールドによって参照されるエンティティのどちらかである。
そのメソッドは以下のものである。
</p>

<ul>
<li>PUT</li>
<li>DELETE</li>
<li>POST</li>
</ul>

<p>
サービス不能攻撃を防ぐために、Location や Content-Location ヘッダ中の URI に基づく無効化はそのホスト部分が Request-URI のものと同じ場合にのみ実行され<em>なければならない</em>。
</p>

<p>
自身が理解できないメソッドを使ったリクエストを通すキャッシュは、その Request-URI によって参照されるあらゆるエンティティを無効化す<em>べきである</em>。
</p>

<h3 id="section-13.11">13.11 Write-Through の強制</h3>

<p>
オリジンサーバのリソースに修正をさせる事が期待されるすべてのメソッドは、オリジンサーバへと通されて書かれる{write through} もので<em>なければならない</em>。
これは現在 GET と HEAD 以外のすべてのメソッドが含まれる。
キャッシュはインバウンドサーバへとリクエストを転送し、インバウンドサーバからそれに対応するレスポンスを受け取る前には、そのようなクライアントからのリクエストに応答し<em>てはならない</em>。
これは、キャッシュがインバウンドサーバが最後の応答を送信する前にプロクシキャッシュが 100 (Continue) レスポンスを送る事は妨げない。
</p>

<p>
一貫した更新を提供する事が難しい事、また write-back より前のサーバ、キャッシュ、ネットワークの失敗から生じる問題のために、(&quot;write-back&quot; や &quot;copy-back&quot; キャッシングとして知られる) 代替案は HTTP/1.1 において認められていない。
</p>

<h3 id="section-13.12">13.12 キャッシュの代替</h3>

<p>
もしあるリソースについてのレスポンスが既にキャッシュされている時に、同じリソースから新しくキャッシュ可能な (section <a href="#section-14.9.2">14.9.2</a>, <a href="#section-13.2.5">13.2.5</a>, <a href="#section-13.2.6">13.2.6</a>, <a href="#section-13.8">13.8</a> 参照) レスポンスが受信された場合、キャッシュは現在のリクエストへの応答には新しいレスポンスを使用す<em>べきである</em>。
キャッシュはそれをキャッシュ保存媒体に書き込む事が<em>でき</em>、もし他のすべての要求を満たすのであれば、以前には古いレスポンスが返されるであろう将来のリクエストへ応答するためにそれを使用する事が<em>できる</em>。
キャッシュ保存媒体に新しいレスポンスを書き込む時は、section <a href="#section-13.5.3">13.5.3</a> の規則が適用される。
</p>

<p class="note">
注: 既存のキャッシュされたレスポンスより古い Date ヘッダ値を持つ新しいレスポンスはキャッシュ可能ではない。
</p>

<h3 id="section-13.13">13.13 履歴表</h3>

<p>
ユーザエージェントはしばしば、&quot;戻る&quot; ボタンと履歴リストのような履歴メカニズムを持っていて、セッションにおいて以前に回収したエンティティを再表示するために使う事ができる。
</p>

<p>
履歴メカニズムとキャッシュは異なる。特に履歴メカニズムはリソースの現在の状態の意味的に透過なビューを表示しようとはす<em>べきではない</em>。
むしろ、履歴メカニズムはリソースが回収された時刻を正確に表示するという意味を持つ。
</p>

<p>
既定では、有効期限は履歴メカニズムには適用されない。
もしそのエンティティがまだ保存していて、ユーザが特にエージェントを期限切れの履歴文書をリフレッシュするように設定していなければ、履歴メカニズムは例えエンティティの期限が切れていてもそれを表示す<em>べきである</em>。
</p>

<p>
これは、履歴システムがユーザにビューが古くなっているかもしれないという事を知らせる事を禁止すると解釈されるものではない。
</p>

<p class="note">
注: もし履歴表メカニズムがユーザが古くなったリソースを見る事を不必要に妨げるのであれば、サービスの著者が別の方法を望む場合に、HTTP の期限制御とキャッシュ制御を強制的に使わせないようにする傾向があるだろう。
サービスの著者は、ユーザが前もって回収したリソースを見るために (「戻る」のような) ナビゲーション制御を使う時にユーザがエラーメッセージや警告メッセージが見えない事を重要だと考えるかもしれない。
例え、時にそのようなリソースはキャッシュされるべきではなく、すぐに期限が切れるべきだとしても、不適当に機能している履歴メカニズムの影響のよって苦しまないためにユーザインターフェースはサービスの著者にキャッシングさせないようにするための別の方法 (例: &quot;一度きりの&quot; URL) に強制的に訴える事ができるように考慮されている。
</p>

<h2 id="section-14">14 ヘッダフィールド定義</h2>

<p>
この章では、すべての標準 HTTP/1.1 ヘッダフィールドの構文と意味論を定義する。
エンティティヘッダフィールドに対して、送信者と受信者の両方は、クライアントかサーバのどちらかを参照するが、それはエンティティを誰が送信し誰が受信するかに依存する。
</p>

<h3 id="section-14.1">14.1 Accept</h3>

<p>
Accept リクエストヘッダフィールドは、レスポンスで受け入れ可能なメディアタイプを指定するために使われる。
Accept ヘッダでは、インラインイメージを要求する場合などに、希望するタイプの小セット{small set} を特に限定して指定するために使われる。
</p>

<pre> Accept         = &quot;Accept&quot; &quot;:&quot;
                  #( media-range [ accept-params ] )

 media-range    = ( &quot;*/*&quot;
                  | ( type &quot;/&quot; &quot;*&quot; )
                  | ( type &quot;/&quot; subtype )
                  ) *( &quot;;&quot; parameter )
 accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
 accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]
</pre>

<p>
アスタリスク &quot;*&quot; という文字は、ある範囲のメディアタイプをグループ化するために使われ、&quot;*/*&quot; ではすべてのメディアタイプを表し、&quot;type/*&quot; はそのメディアタイプに含まれるすべてのサブタイプを表す。
media-range は、その範囲に適用できるメディアタイプパラメータを含む事が<em>できる</em>。
</p>

<p>
それぞれの media-range では、相対的な品質係数を示すため &quot;q&quot; で始まるパラメータを、一つ以上 accept-params として付加する事が<em>できる</em>。
もし &quot;q&quot; パラメータがあれば、最初の &quot;q&quot; パラメータが media-range と accept-params を分けるものとなる。品質係数によって、ユーザやユーザエージェントは 0 から 1 までの qvalue 尺度 (section <a href="#section-3.9">3.9</a>) を使って、そのメディアタイプの相対的な優先度を示す事ができる。既定値は、q=1 である。
</p>

<p class="note">
注: メディアタイプパラメータと Accept 拡張パラメータとを分けるために &quot;q&quot; パラメータの名前を使用するのは、歴史的慣例によるものである。
これによって、メディアレンジとして &quot;q&quot; という名前のパラメータを使用する事が妨げられるが、IANA メディアタイプ登録機関には &quot;q&quot; パラメータは無く、Accept でメディアタイプパラメータを使う事はまれなので、そのような状況が問題となる事はないと思われる。
将来的に、メディアタイプに &quot;q&quot; という名前を持つパラメータが登録される事は推奨されない。
</p>

<p>
次の例を見よ。
</p>

<pre> <samp>Accept: audio/*; q=0.2, audio/basic</samp></pre>

<p>
この例では、「私は audio/basic を望むが、もし品質を 80% 下げても最も有効に利用できるのであれば、どんな audio タイプでもかまわない」と解釈される<em>べきである</em>。
</p>

<p>
Accept ヘッダフィールドが無い場合は、クライアントはすべてのメディアタイプを受けつけるとみなされる。
Accept ヘッダフィールドがある場合に、サーバが Accpet フィールド値に適したレスポンスを送る事ができなければ、サーバは 406 (not acceptable) レスポンスを返す<em>べきである</em>。
</p>

<p>
より複雑な例を示す。
</p>

<pre> <samp>Accept: text/plain; q=0.5, text/html,
         text/x-dvi; q=0.8, text/x-c</samp>
</pre>

<p>
これを文字通りに解釈すると、「text/html と text/x-c が望むメディアタイプであるが、もし存在しないのであれば text/x-dvi エンティティを、それも無ければ、text/plain エンティティを送信せよ。」となる。
</p>

<p>
メディアレンジでは、より特定されるメディアレンジやメディアタイプが優先される。
あるメディアタイプに複数のメディアレンジが当てはまる場合、最も特定される指示を優先される。
例を見よ。
</p>

<pre> <samp>Accept: text/*, text/html, text/html;level=1, */*</samp></pre>

<p>
この優先順位は以下の様になる。
</p>

<ol>
<li>text/html;level=1</li>
<li>text/html</li>
<li>text/*</li>
<li>*/*</li>
</ol>

<p>
あるメディアタイプに関連付けられる品質係数は、そのメディアタイプにマッチする最も高い優先度を持つメディアレンジを発見する事によって決定される。
例を見よ。
</p>

<pre> <samp>Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
        text/html;level=2;q=0.4, */*;q=0.5</samp>
</pre>

<p>
品質係数は以下の様になる。
</p>

<pre> text/html;level=1         = 1
 text/html                 = 0.7
 text/plain                = 0.3
 image/jpeg                = 0.5
 text/html;level=2         = 0.4
 text/html;level=3         = 0.7
</pre>

<p class="note">
注: ユーザエージェントは、あるメディアレンジに対して既定の品質値を供給するかもしれない。
しかし、ユーザエージェントが他のレンダリングエージェントと相互作用できないクローズドなシステムで無いのであれば、この既定値はユーザが設定できるようにすべきである。
</p>

<h3 id="section-14.2">14.2 Accept-Charset</h3>

<p>
Accept-Charset リクエストヘッダフィールドは、レスポンスで受け入れ可能な文字セットを示すのに使われる。
このフィールドは、一般的な文字セットや、特殊な目的を持つ文字セットを理解できるクライアントがそれらの文字セットの中で文書を表現する能力を持つサーバに対して、利用できる文字セットを通知する事を可能にする。
</p>

<pre> Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
         1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
</pre>

<p>
文字セット値は、section <a href="#section-3.4">3.4</a> で記されている。
それぞれの文字セットに、ユーザの望む文字セットの優先度を表す関連付けられた品質値を付ける事が<em>できる</em>。
既定値は 1 である。
次の例を見よ。
</p>

<pre> <samp>Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</samp></pre>

<p>
特別な値である &quot;*&quot; が Accept-Charset フィールド中にある場合、その Accept-Charset フィールドにて指定されていないすべての文字セット (ISO-8859-1を含む) に合致する。
もし、&quot;*&quot; が Accept-Charset フィールドで与えられていなければ、明示されていないすべての文字セットの品質値は
0 である。
但し、ISO-8859-1 が明示されていない場合は、その品質値は 1 である。
</p>

<p>
Accept-Charset ヘッダが無い場合、既定ではどんな文字セットも受け入れ可能である。
Accept-Charset ヘッダがあっても、サーバが Accept-Charset ヘッダによって受け入れ可能なレスポンスを返せない場合、サーバは、クライアントが扱えないレスポンスを返す事もできるが、406 (not acceptable) エラーレスポンスを返す<em>べきである</em>。
</p>

<h3 id="section-14.3">14.3 Accept-Encoding</h3>

<p>
Accept-Encoding リクエストヘッダフィールドは、Accept ヘッダに似ているが、レスポンスで受け入れ可能な内容コーディング (section <a href="#section-3.5">3.5</a>) を制限する。
</p>

<pre> Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot;
                    1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
 codings          = ( content-coding | &quot;*&quot; )
</pre>

<p>
使用例は以下の様になる。
</p>

<pre> <samp>Accept-Encoding: compress, gzip
 Accept-Encoding:
 Accept-Encoding: *
 Accept-Encoding: compress;q=0.5, gzip;q=1.0
 Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0</samp>
</pre>

<p>
サーバは、Accept-Encoding フィールドに従って、以下の規定を使い内容コーディングが受け入れ可能かどうかを試す。
</p>

<ol>
<li>その内容コーディングが Accept-Encoding フィールドに列挙されているうちの一つで、その qvalue が0で無ければ、受け入れ可能である。(section <a href="#section-3.9">3.9</a> で定義されているように、qvalue が 0 であるという事は &quot;受け入れ不可能&quot; を意味する。)</li>
<li>Accept-Encoding フィールド中の特別な &quot;*&quot; 記号は、ヘッダフィールド内に明示的に列挙されていないどんな内容コーディングも受け入れ可能とみなす。</li>
<li>もし複数の内容コーディングが受け入れ可能ならば、最も大きな 0 以外の qvalue を持つ受け入れ可能な内容コーディングが優先される。</li>
<li>&quot;identity&quot; 内容コーディングは、もし Accept-Encoding フィールドが &quot;identity;q=0&quot; を含む、あるいは &quot;*;q=0&quot; を含み明示的に &quot;identity&quot; 内容コーディングを含まない事で、特に否定していなければ、常に受け入れ可能である。
もし、Accept-Encodingフィールドが空であれば、&quot;identity&quot; 内容コーディングのみが受け入れ可能である。</li>
</ol>

<p>
リクエストに Accept-Encoding ヘッダがある時に、サーバが Accept-Encoding ヘッダによって受け入れ可能なレスポンスを返せない場合、406 (not acceptable) エラーレスポンスを返す<em>べきである</em>。
</p>

<p>
リクエストに Accept-Encoding フィールドが無い場合は、サーバはどんな内容エンコーディングも受け入れると仮定する事が<em>できる</em>。
この場合、もし &quot;identity&quot; が利用可能な内容コーディングの一つで、その他の内容コーディングを使う事がクライアントにとって意味のある追加情報となるわけでなければ、サーバは &quot;identity&quot; 内容コーディングを使う<em>べきである</em>。
</p>

<p class="note">
注: リクエストが Accept-Encoding フィールドを含まず、&quot;identity&quot; が利用不可能である場合、古いクライアントの中には他の内容コーディングと共に送られるメッセージを不適当に表示するものがあるので、HTTP/1.0 クライアントが一般に理解する内容コーディング (例えば &quot;gzip&quot; や &quot;compress&quot;) を使う事が好まれる。
サーバは、また特定のユーザエージェント、あるいはクライアントについての情報に基づく決定を行ってもよい。
</p>

<p class="note">
注: 多くの HTTP/1.0 アプリケーションは、内容コーディングに関連付けられた qvalue を理解しないし、従わない。
これは、qvalue は x-gzip あるいは x-compress については作動しないし許可しない事を意味する。
</p>

<h3 id="section-14.4">14.4 Accept-Language</h3>

<p>
Accept-Language リクエストヘッダフィールドは、Accept に似ているが、リクエストへのレスポンスとして望む自然言語のセットを限定する。
言語タグは、section <a href="#section-3.10">3.10</a> にて定義されている。
</p>

<pre> Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                   1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
 language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )
</pre>

<p>
それぞれの languege-range では、そのレンジで指定する言語に対するユーザの優先度を示す品質値をつける事が<em>できる</em>。
品質値の既定は、&quot;q=1&quot; である。例を見よ。
</p>

<pre> <samp>Accept-Language: da, en-gb;q=0.8, en;q=0.7</samp></pre>

<p>
これは、&quot;私はデンマーク語を望むが、イギリス英語か、他の英語でも受け入れる。&quot; という事を意味する。
もし languege-range が、タグに一致する時、あるいはタグの接頭辞に等しくてそれに続く文字が &quot;-&quot; である時には、言語タグに一致する。
Accept-Languege フィールドに特別なレンジである &quot;*&quot; がある場合は、その Accept-Languege フィールド内に無いあらゆるタグに一致する。
</p>

<p class="note">
注: この接頭辞一致規則を使うのは、もしユーザがあるタグを持った言語を理解できるのであれば、そのユーザはこのタグを接頭辞に持つすべての言語を理解できるはずなので、言語タグをそのような方法で割り当てる、という事を暗に意味するものではない。この接頭辞規則は単に、そのような状況になれば、接頭辞タグを使ってもよいという事である。
</p>

<p>
Accept-Language フィールドによって言語タグに割り当てられる言語品質係数は、言語タグに一致するフィールドの中で最も長い languege-range の品質値である。
もしフィールド内に一致するタグが無ければ、割り当てられる言語品質係数は 0 である。
もしリクエストヘッダ内に Accept-Language が無ければ、サーバはすべての言語が同等に利用可能であるとみなす<em>べきである</em>。
Accept-Language がある場合は、0 以上の品質係数が割り当てられているすべての言語が利用可能である。
</p>

<p>
ユーザが、すべてのリクエストに完全な言語優先度を伴った Accept-Language ヘッダを送信する事は、プライバシー保護の立場とは逆のものとなるかもしれない。
この問題の議論について、section <a href="#section-15.1.4">15.1.4</a> 参照。
</p>

<p>
理解度はそれぞれのユーザへの依存度が高いので、クライアントアプリケーションはユーザが利用できる言語優先度の選択肢を作る事が薦められる。
もしその選択が利用できないように作られているならば、Accept-Language ヘッダフィールドをリクエストで与え<em>てはならない</em>。
</p>

<p class="note">
注: ユーザが利用可能な言語優先度の選択肢を作る時、開発者は、ユーザは上で記述されているようなものに一致する言語の詳細に精通していないし、それについて適切な解説を示すべきである、という事を認識すべきである。
例えば、&quot;en-gb&quot; を選択したユーザは、もしイギリス英語が利用できない時は、その他の英語文書が送られて来ると考えるであろう。
ユーザエージェントは、このような場合に最高の一致状態を得るために &quot;en&quot; を加える事を提案できる。
</p>

<h3 id="section-14.5">14.5 Accept-Ranges</h3>

<p>
Accept-Ranges レスポンスヘッダフィールドは、サーバにリソースへの範囲リクエストの受け入れを示させる。
</p>

<pre> Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
 acceptable-ranges = 1#range-unit | &quot;none&quot;
</pre>

<p>
バイトレンジリクエストを受け入れるオリジンサーバは、以下のものを送る事が<em>できる</em>。
</p>

<pre> <samp>Accept-Ranges: bytes</samp>
</pre>

<p>
しかし、これは必ずとも必要ではない。
クライアントは、必要とするリソースに関してこのヘッダを受けなくても、バイトレンジリクエストを生成する事が<em>できる</em>。
レンジ単位は、section <a href="#section-3.12">3.12</a> にて定義されている。
</p>

<p>
リソースへのいかなる範囲リクエストも受け入れないサーバは、以下のものを送る事が<em>できる</em>。
</p>

<pre> <samp>Accept-Ranges: none</samp></pre>

<p>
これは、クライアントに範囲リクエストをしないように忠告する。
</p>

<h3 id="section-14.6">14.6 Age</h3>

<p>
Age レスポンスヘッダは、オリジンサーバがレスポンスを生成した (あるいは再検証した) 時点からの送信者の推定経過時間を示す。
キャッシュされたレスポンスは、経過時間{age} がその使用有効期限{freshness lifetime} を過ぎていなければ、新鮮である。
Age 値は、section <a href="#section-13.2.3">13.2.3</a> で記述されたように計算される。
</p>

<pre> Age = &quot;Age&quot; &quot;:&quot; age-value
 age-value = delta-seconds
</pre>

<p>
Age 値は、負でない整数値であり、秒数を表す。
</p>

<p>
もしキャッシュが表現できる以上の正の整数値を持っていたり、その経過時間計算でオーバーフローしたら、2147483648 (2^31) という値の Age ヘッダを送ら<em>なければならない</em>。
キャッシュを持っている HTTP/1.1 サーバは、自身のキャッシュからのすべてのレスポンスにおいて、Age ヘッダフィールドを含ま<em>なければならない</em>。
キャッシュは、少なくても 31bit の範囲はある計算型を使う<em>べきである</em>。
</p>

<h3 id="section-14.7">14.7 Allow</h3>

<p>
Allow エンティティヘッダフィールドは、Request-URI によって識別されるリソースがサポートするメソッドの一覧を示す。
このフィールドは、リソースに関する有効なメソッドを受信者に厳密に知らせる事を目的にする。
Allow ヘッダフィールドは、405 (Method Not Allowed) レスポンス中に存在し<em>なければならない</em>。
</p>

<pre> Allow   = &quot;Allow&quot; &quot;:&quot; #Method</pre>

<p>
使用例を見よ。
</p>

<pre> <samp>Allow: GET, HEAD, PUT</samp></pre>

<p>
このフィールドを使っても、クライアントが他のメソッドを試す事を妨げる事はできない。
しかし、クライアントは Allow ヘッダフィールドにて示された値には従う<em>べきである</em>。
実際に許可されるメソッドのセットは、各々のリクエストの度にオリジンサーバによって定義される。
</p>

<p>
PUT リクエスト時に、Allow ヘッダフィールドを使って、新規、あるいは更新されるリソースによってサポートされる事が推奨されるメソッドを提供する事が<em>できる</em>。
サーバはこれらのメソッドをサポートする事は要求されないが、レスポンスには実際にサポートされるメソッドを与えた Allow ヘッダを含める<em>べきである</em>。
</p>

<p>
プロクシは、例えそこに書かれたすべてのメソッドが理解できなくても、ユーザエージェントがオリジンサーバと通信するための別の意味を持っているかもしれないので、Allow ヘッダフィールドを書き換え<em>てはならない</em>。
</p>

<h3 id="section-14.8">14.8 Authorization</h3>

<p>
サーバに認証を受けようとするユーザエージェントは、必ずというわけではないが、通常は 401 レスポンスの後、リクエストに Authorization リクエストヘッダフィールドを含める。
Authorization フィールド値は、リクエストされたリソースのある領域へのユーザエージェントの認証情報を含む credentials からなる。
</p>

<pre> Authorization  = &quot;Authorization&quot; &quot;:&quot; credentials</pre>

<p>
HTTP アクセス認証については、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; <a href="#ref-43">[43]</a> にて記述されている。
もしリクエスト認証され、領域が指定されれば、その領域内への他のすべてのリクエストへも同じ credentials は有効である<em>べきである</em> (認証スキーム自身は、例えば challenge 値や使用中の同期した時計によって変更した credentials のように、他の場合を要求しない事を仮定する)。
</p>

<p>
共有キャッシュ (section <a href="#section-13.7">13.7</a> 参照) が Authorization フィールドを含むリクエストを受けた時、以下の例外のどれにも当てはまらなければ、他のどんなリクエストへの応答としても対応するレスポンスを返し<em>てはならない</em>。
</p>

<ol>
<li>レスポンスが &quot;s-maxage&quot; という cache-control 指示が含んでいる場合は、キャッシュは、その後のリクエストへの応答にそのレスポンスを使用して<em>よい</em>。
しかし (もし指定された最大有効期限が過ぎてしまっていたら) プロクシキャッシュは、オリジンサーバに新しいリクエストを認証させるために新しいリクエストのリクエストヘッダを使って、始めにオリジンサーバで再検証し<em>なければならない</em>。
(これは s-maxage のために定義されている動作である。)
レスポンスが &quot;s-maxage=0&quot; を含んでいる場合は、プロクシは (レスポンスのキャッシュを) 再利用する前に常に再検証し<em>なければならない</em>。
</li>
<li>レスポンスが &quot;must-revalidate&quot; という cache-control 指示を含んでいる場合は、キャッシュはその後のリクエストへの応答にそのレスポンスを使用して<em>よい</em>。
しかし、レスポンスが新鮮で無い場合は、すべてのキャッシュは、オリジンサーバに新しいリクエストを認証させるために新しいリクエストのリクエストヘッダを使って、始めにオリジンサーバで再確認し<em>なければならない</em>。
</li>
<li>レスポンスが &quot;public&quot; という cache-control 指示を含んでいる場合は、キャッシュはその後のどんなリクエストへの応答にもそのレスポンスを使用して<em>よい</em>。
</li>
</ol>

<h3 id="section-14.9">14.9 Cache-Control</h3>

<p>
Cache-Control 一般ヘッダフィールドは、リクエスト/レスポンス連鎖上のすべてのキャッシングメカニズムが従わ<em>なければならない</em>指示を記述するために使用される。
キャッシュがリクエストやレスポンスに不利になるように干渉させないような振る舞いを指定する。
これらの指示は、常に既定のキャッシングアルゴリズムを上書きするものである。
キャッシュ指示は、リクエスト中にある指示があっても、それと同じ指示がレスポンスで与えられるという事を暗に意味しない、という意味において単向性である。
</p>

<p>
HTTP/1.0 キャッシュは、Cache-Control を実装してせず、Pragma: no-cache (section <a href="#section-14.32">14.32</a> 参照) しか実装していないかもしれない事に注意せよ。
</p>

<p>
キャッシュ指示は、リクエスト/レスポンス連鎖上のすべての受信者に適用できるため、プロクシやゲートウェイアプリケーションを、そのアプリケーションの重要性に関係なく通り抜け<em>なければならない</em>。
特定のキャッシュのために cache-directive を記述するのは不可能である。
</p>

<pre> Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

 cache-directive = cache-request-directive
      | cache-response-directive

 cache-request-directive =
        &quot;no-cache&quot;                          ; Section <a href="#section-14.9.1">14.9.1</a>
      | &quot;no-store&quot;                          ; Section <a href="#section-14.9.2">14.9.2</a>
      | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; Section <a href="#section-14.9.3">14.9.3</a>, <a href="#section-14.9.4">14.9.4</a>
      | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; Section <a href="#section-14.9.3">14.9.3</a>
      | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; Section <a href="#section-14.9.3">14.9.3</a>
      | &quot;no-transform&quot;                      ; Section <a href="#section-14.9.5">14.9.5</a>
      | &quot;only-if-cached&quot;                    ; Section <a href="#section-14.9.4">14.9.4</a>
      | cache-extension                     ; Section <a href="#section-14.9.6">14.9.6</a>

  cache-response-directive =
        &quot;public&quot;                               ; Section <a href="#section-14.9.1">14.9.1</a>
      | &quot;private&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ] ; Section <a href="#section-14.9.1">14.9.1</a>
      | &quot;no-cache&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]; Section <a href="#section-14.9.1">14.9.1</a>
      | &quot;no-store&quot;                             ; Section <a href="#section-14.9.2">14.9.2</a>
      | &quot;no-transform&quot;                         ; Section <a href="#section-14.9.5">14.9.5</a>
      | &quot;must-revalidate&quot;                      ; Section <a href="#section-14.9.4">14.9.4</a>
      | &quot;proxy-revalidate&quot;                     ; Section <a href="#section-14.9.4">14.9.4</a>
      | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; Section <a href="#section-14.9.3">14.9.3</a>
      | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; Section <a href="#section-14.9.3">14.9.3</a>
      | cache-extension                        ; Section <a href="#section-14.9.6">14.9.6</a>

 cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ]
</pre>

<p>
ある指示子がどんな 1#field-name パラメータも無く現れた時、その指令はリクエストやレスポンス全体に適用される。
ある指示子が 1#field-name パラメータを伴って現れたら、指定されたフィールド (群) のみに適用され、リクエストやレスポンスの残りの部分には適用されない。
このメカニズムは拡張性を持っている。
HTTP プロトコルの将来のバージョンの実装は、これらの指示子に HTTP/1.1 で定義されていないヘッダフィールドを適用する事ができる。
</p>

<p>
cache-control 指示子は、これらの一般的なカテゴリの中に分類する事ができる。
</p>


<ul>
<li>キャッシュ可能なものを制限; これらはオリジンサーバのみが課す事ができる。</li>
<li>キャッシュによって保存できるものを制限; これらはオリジンサーバかユーザエージェントのどちらかによって課す事ができる。</li>
<li>基本的な満期メカニズムの修正; これらはオリジンサーバかユーザエージェントのどちらかによって課す事ができる。</li>
<li>キャッシュの再検証と再読み込みの制御; これらはユーザエージェントのみが課す事ができる。</li>
<li>エンティティの変形についての制御。</li>
<li>キャッシングシステムの拡張。</li>
</ul>

<h4 id="section-14.9.1">14.9.1 キャッシュ可能とは何か</h4>

<p>
リクエストメソッド、リクエストヘッダフィールド、レスポンスステータスがキャッシュ可能である事を要求している場合、既定ではレスポンスはキャッシュ可能である。
section <a href="#section-13.4">13.4</a> では、キャッシュ可能性のためのこれらの既定を要約している。
以下の Cache-Control レスポンス指示子を使うと、オリジンサーバはレスポンスの既定のキャッシュ可能性を上書きする事ができる。
</p>

<dl>
<dt>public</dt>
<dd>
<p>
たとえそれが通常はキャッシュ可能でなかったり、非共有キャッシュ内でのみキャッシュ可能であったとしても、レスポンスがすべてのキャッシュによってキャッシュ可能に<em>できる</em>事を示す。
 (追加される詳細のため、section <a href="#section-14.8">14.8</a> の Authorization も見よ。)
</p>
</dd>
<dt>private</dt>
<dd>
<p>
レスポンスメッセージのすべてもしくは一部は、単一のユーザのために用意された物であり、共有キャッシュによってキャッシュされ<em>てはならない</em>事を示す。
これによって、オリジンサーバは、そのレスポンスの指定された部分ががあるユーザにのみ向けられたもので、別のユーザによるリクエストにとっては正当なレスポンスではない事を述べる事ができるようにする。
プライベート (非共有) キャッシュは、そのレスポンスをキャッシュ<em>できる</em>。
</p>
<p class="note">
注: この private と言う指示子の使用は、レスポンスがキャッシュできるところのみを制御するもので、メッセージ内容のプライバシーは保証できない。
</p>
</dd>
<dt>no-cache</dt>
<dd>
<p>
もし no-cache 指示子がフィールド名を指定していなければ、オリジンサーバへの再検証が成功するまで、以降のリクエストを満足させるためにそのレスポンスを使っ<em>てはならない</em>。
これによって、オリジンサーバはリクエストするクライアント古くなったレスポンスを返すよう設定されているキャッシュによるキャッシングさえ行えなくする事ができる。
</p>
<p>
もし no-cache 指示子が一つ以上のフィールド名を指定していたら、キャ
ッシュはキャッシングにおける他の制約の元で、以降のリクエストを満足
するためにそのレスポンスを使う事が<em>できる</em>。しかし、指定されたフ
ィールド名はオリジンサーバへの再検証が成功するまで、以降のリクエス
トを満足させるためにそのレスポンスを使っ<em>てはならない</em>。これによ
って、オリジンサーバはレスポンスの残りをキャッシングできる間、レス
ポンス中のあるヘッダフィールドの再使用を行えなくする事ができる。
</p>
<p class="note">
注: 多くの HTTP/1.0 キャッシュは、この指示子を理解できず、従う事はないだろう。
</p>
</dd>
</dl>

<h4 id="section-14.9.2">14.9.2 キャッシュによって保存できるものは何か</h4>

<dl>
<dt>no-store</dt>
<dd>
<p>
no-store 指示子の目的は、取り扱いが慎重な (例えばバックアップテープ上の) 情報の不注意な漏洩や保留を防ぐ事である。
no-store 指示子はメッセージ全体に適用され、レスポンスかリクエストのどちらかで送る事が<em>できる</em>。
リクエストで送られる場合、キャッシュはそのリクエストやそれへのいかなるレスポンスの一部分を保存し<em>てはならない</em>。
レスポンスで送られる場合、キャッシュはそのレスポンスやそれを引き起こしたリクエストの一部分を保存し<em>てはならない</em>。
この指示は、非共有・共有キャッシュのどちらにも当てはまる。
この状況下での &quot;保存し<em>てはならない</em>&quot; は、キャッシュを一時的なものではない保存場所{non-volatile storage} にその情報を故意に保存し<em>てはならない</em>し、一時的な保存場所{volatile storage} であってもそれを転送した後にできるだけ早くそこから情報の削除するために最善を尽くさ<em>なければならない</em>、という事を意味する。
</p>

<p>
その指示がレスポンスに関連している時でも、ユーザはキャッシングシステムの外側にそのようなレスポンスを明白に (例えば、&quot;Save As&quot; ダイアログを伴って) 保存できる。
履歴バッファは、これらの通常操作の一部としてこのようなレスポンスを保存する事が<em>できる</em>。
</p>

<p>
この指示の目的は、キャッシュデータ構造への予期しないアクセスを経て情報の偶発的な漏洩を心配するユーザやサービス著者達が前もって示した必要条件に見合うようにするためである。
この指示子を使う事でいくつかの場合でプライバシーを改善できるであろうが、これはプライバシーを保証するための信頼できる、もしくは十分なメカニズムのどのような方法におけるものでは<em>無い</em>事を警告しておく。
特に、悪意のあるキャッシュや一部の機能のみが実装された{compromised} キャッシュはこの命令を認識しなかったり従わなかったりするかもしれないし、あるいは通信ネットワーク自体が盗聴に対して無防備であるかもしれない。
</p>
</dd>
</dl>

<h4 id="section-14.9.3">14.9.3 基本的な期限のメカニズムの修正</h4>

<p>
エンティティの有効期限は、Expires ヘッダ (section <a href="#section-14.21">14.21</a> 参照) を使ってオリジンサーバにより記述する事が<em>できる</em>。
あるいは、レスポンスで max-age 指示子を使って記述する事が<em>できる</em>。
max-age cache-control 指示子がキャッシュされたレスポンス中にあった時に、現在まで経過した時間{age} がそのリソースへ新しいリクエストがなされてからの (秒数で) 与えられた時間を過ぎていたら、そのレスポンスは新鮮では無い。
レスポンス中の max-age 指示子は、その他にキャッシュに制限を与えるような指示子が無ければ、レスポンスはキャッシュ可能 (すなわち、&quot;共有キャッシュ&quot;) であるという事を暗黙的に意味する。
</p>

<p>
もしレスポンスに Expires ヘッダと max-age 指示子の両方が含まれたいたら、たとえ Expires ヘッダがより制限的なものであっても、max-age 指示子は Expires ヘッダを上書きする。
この規定によって、オリジンサーバは与えられたレスポンスに対して HTTP/1.0 キャッシュよりも HTTP/1.1 (及びそれ以降の) キャッシュに長い有効期限を提供できるようになる。
これは、ある HTTP/1.0 キャッシュがおそらく同期していない時計のために不適当に経過時間や有効期限を計算してしまうような場合に有用であろう。
</p>

<p>
多くの HTTP/1.0 キャッシュ実装は、Cache-Control レスポンス指示子が &quot;no-cache&quot; と同等であるようなレスポンスの Date 値以下として Expires 値を扱うであろう。
もし HTTP/1.1 キャッシュがそのようなレスポンスを受けとり、そのレスポンスが Cache-Control ヘッダフィールドを含んでいなければ、そのレスポンスは HTTP/1.0 サーバとの互換性を保つためにキャッシュ可能ではないとみなす<em>べきである</em>。
</p>

<p class="note">
注: オリジンサーバは、例えば &quot;private&quot; 指示子のような、比較的新しい HTTP キャッシュコントロール機能を、その機能を理解しない古いキャッシュを含むネットワーク上で使いたいとするかもしれない。
オリジンサーバは、その値が Date 値以下になるような Expires フィールドを新しい機能を結合する必要があるであろう。
これによって、古いキャッシュにレスポンスを不適当にキャッシングさせないようにするであろう。
</p>

<dl>
<dt>s-maxage</dt>
<dd>
<p>
レスポンスが s-maxage 指示子を含んでいる場合、共有キャッシュについて (非共有キャッシュについてではない) 、この指示子で指定された最大使用期限は max-age 指示子や Expires ヘッダによって指定された最大使用期限を上書きする。
また s-maxage 指示子は proxy-revalidate 指示子 (section <a href="#section-14.9.4">14.9.4</a> 参照) の意味論、すなわち、共有されたキャッシュはオリジンサーバに最初の再検証をせずにその後のリクエストへのレスポンスとしてそれが新鮮で無くなってしまったエントリを使ってはならない、という事も暗黙的に意味する。
s-maxage 指示子は、非共有キャッシュには常に無視される。
</p>
</dd>
</dl>

<p>
多くの古い、この仕様書に従わないようなキャッシュは、いかなる cache-control 指示子も実装していない事に注意せよ。
HTTP/1.1 に従順なキャッシュによるキャッシングを制限し、同時にそれを邪魔しない、cache-control 指示子を使いたいオリジンサーバは、max-age 指示子は Expires ヘッダを上書きするという条件と、HTTP/1.1 に従順なキャッシュ以前のものは max-age 指示子に気付かないという事実を利用する事が<em>できる</em>。
</p>

<p>
他の指示子は、ユーザエージェントが基本的な期限メカニズムを修正できるようにする。
これらの指示は、リクエストにおいて記述<em>できる</em>。
</p>

<dl>
<dt>max-age</dt>
<dd>
<p>
クライアントは、ここで記述した秒時間よりも大きな経過時間を持たないようなレスポンスを受け入れる意図を持つ事を表す。
そこに max-stale 指示子が含まれていなければ、クライアントは古くなったレスポンスを受け入れようとはしていない。
</p>
</dd>
<dt>min-fresh</dt>
<dd>
<p>
クライアントは、それが新鮮であるような残り時間がここで指定した秒時間に現在の経過時間を足した物より小さくなるようなレスポンスを受け入れる意図を持つ事を表す。
これは、クライアントが少なくとも指定した秒数の間はまだ新鮮であるようなレスポンスを望んでいるという事である。
</p>
</dd>
<dt>max-stale</dt>
<dd>
<p>
クライアントは、期限を超えたようなレスポンスを受け入れる意図を持つ事を表す。
max-stale に値を割り当てられている場合、クライアントは指定した秒数だけ有効期限を過ぎてしまったようなレスポンスを受け入れようとしている。
max-stale に値が割り当てられていない場合は、クライアントはどれだけ時間が経過しような新鮮で無いレスポンスも受け入れようとしている。
</p>
</dd>
</dl>

<p>
リクエスト中の max-stale 指示子、あるいはキャッシュがレスポンスの有効期限を上書きするように形成されているかのどちらかの理由で、キャッシュが新鮮でないレスポンスを返す場合、キャッシュは Warning 110 (Response is stale) を使って、新鮮ではないレスポンスに Warning ヘッダを追加し<em>なければならない</em>。
</p>

<p>
キャッシュは、キャッシュの再検証に関しての &quot;MUST&quot; レベルの必要条件 (例えば &quot;must-revalidate&quot; cache-control 指示子) とは矛盾を起こさないようにする場合のみ、再検証せずに新鮮で無いレスポンスを返すように構成する事が<em>できる</em>。
</p>

<p>
もし新しいリクエストとキャッシュされたエントリの両方に &quot;max-age&quot; 指示子が含まれていたら、そのリクエストのためのキャッシュされるエントリの残り時間の決定には、二つの値の小さい方が使われる。
</p>

<h4 id="section-14.9.4">14.9.4 キャッシュの再検証とリロードコントロール</h4>

<p>
時々ユーザエージェントは、キャッシュがオリジンサーバ (オリジンサーバへの経路上の次のキャッシュではなく) にキャッシュエントリの再検証を行う事を要求したり、オリジンサーバからそのキャッシュエントリをリロードする事を望みあるいは必要とするかもしれない。エンドトゥエンド{end-to-end} 再検証は、キャッシュかオリジンサーバのどちらかがキャッシュされたレスポンスの有効期限を過大評価している場合に必要とあろう。
エンドトゥエンド・リロードは、キャッシュエントリがある理由のため古く使えなくなった場合に必要とあろう。
</p>

<p>
エンドトゥエンドの再検証は、クライアントが自身のローカルにキャッシュされたコピーを持っていないような、我々が &quot;未指定性エンドトゥエンド再検証{Unspecified end-to-end revalidation}&quot; と呼ぶような場合か、クライアントがローカルにキャッシュされたコピーを持っているような、我々が&quot;指定性エンドトゥエンド再検証{Specific end-to-end revalidation}&quot; と呼ぶような場合の、どちらかの場合で要求されるであろう。
</p>

<p>
クライアントは、Cache-Control リクエスト指示子を使って以下の三種類の動作を指定する事ができる。
</p>

<dl>
<dt>エンドトゥエンド・リロード</dt>
<dd>
リクエストは、&quot;no-cache&quot; Cache-Control 指示子や、HTTP/1.0 クライアントとの互換性のための &quot;Pragma: no-cache&quot; を含んでいる。
リクエスト中には、no-cache 指示子を伴うどんなフィールド名も含ん<em>ではならない</em>。
サーバは、そのようなリクエストに応答する時にはキャッシュされたコピーを使っ<em>てはならない</em>。
</dd>
<dt>指定性エンドトゥエンド再検証</dt>
<dd>
リクエストは、&quot;max-age=0&quot; Cache-Control 指示子を含み、これは強制的に自身のエントリの正当性をオリジンサーバや、もしあればオリジンサーバへの経路上のそれぞれのキャッシュに再検証させる。
最初のリクエストでは、クライアントの現在のバリディタを伴うキャッシュの正当性検証条件{cache-validating conditional} を含んでいる。
</dd>
<dt>未指定性エンドトゥエンド再検証</dt>
<dd>
リクエストは、&quot;max-age=0&quot; Cache-Control 指示子を含み、これは強制的に自身のエントリの正当性をオリジンサーバや、もしあればオリジンサーバへの経路上のそれぞれのキャッシュに再検証させる。
最初のリクエストでは、クライアントの現在のバリディタを伴うキャッシュの正当性検証条件を含んでいない。
このリソースのキャッシュエントリを持っている経路上の最初のキャッシュ (もしあれば) は、現在のバリディタを伴うキャッシュの正当性検証条件を含んでいる。
</dd>
</dl>

<dl>
<dt>max-age</dt>
<dd>
<p>
中間キャッシュが max-age=0 によって、そのキャッシュエントリの再確認を強制され、クライアントがそのリクエスト中に自身のバリディタを供給するような場合、供給されたバリディタは現在キャッシュエントリに保存されているバリディタとは異なるかもしれない。
この場合、キャッシュは意味的透過性の影響を考える事無くそれ自身のリクエストを作成する際にはどちらのバリディタでも使う事が<em>できる</em>。
</p>

<p>
しかし、バリディタの選択によってパフォーマンスに影響が出るかもしれない。
中間キャッシュがリクエストを作成する際の最良のアプローチは、自身の確証子を使う事である。サーバが 304 (Not Modified) を返した場合は、キャッシュはクライアントに 200 (OK) レスポンスと現在の検証されたコピーを返す事ができる。
しかし、もしサーバが新しいエンティティとキャッシュバリディタを返したら、中間キャッシュは返されたバリディタとクライアントのリクエストから与えられたものとを強い比較機能を使用して比較する事ができる。
クライアントのバリディタがオリジンサーバのものと等しければ、中間キャッシュは単純に 304 (Not Modified) を返す。
そうでなければ、200 (OK) レスポンスと新しいエンティティを返す。
</p>

<p>
リクエストが no-cache 指示子を含む場合は、min-fresh, max-stale, max-age を含む<em>べきではない</em>。
</p>
</dd>

<dt>only-if-cached</dt>
<dd>
<p>
例えばネットワーク接続が極めて貧弱である等、いくつかの場合では、クライアントはキャッシュが現在保存しているレスポンスのみを返し、オリジンサーバにリロードや再検証を行わないように望むだろう。
これを行うため、クライアントはリクエスト中に only-if-cached 指示子を含む事ができる。
この指示子を受け取った場合、キャッシュはそのリクエストの別の条件を満たすようなキャッシュエントリを使って返すか、504 (Gateway Timeout) ステータスを返すか、どちらかを行う<em>べきである</em>。
しかし、もしあるキャッシュのグループが内部の接続性が良い統合システムとして運用されているなら、そのようなリクエストはそのようなキャッシュのグループ内に転送しても<em>よい</em>。
</p>
</dd>

<dt>must-revalidate</dt>
<dd>
<p>
キャッシュはサーバの指定する有効期限を無視するように形成する事が<em>でき</em>、またクライアントのリクエストでは max-stale 指示子を含む事が<em>できる</em> (これは似たような効果がある) ので、プロトコルはオリジンサーバがそれ以降に使われるあらゆるキャッシュエントリの再検証を要求するようなメカニズムを含む。
must-revalidate 指示子がキャッシュによって受信されたレスポンス中にあった時は、キャッシュはオリジンサーバに最初にそれを再検証せずに以降のリクエストに応答するために新鮮で無いエントリを使っ<em>てはならない</em>。
(すなわち、キャッシュは毎回エンドトゥエンドの再検証をし<em>なければならない</em>し、もし、単にオリジンサーバの Expires か max-age 値に基づいているなら、キャッシュされたレスポンスは新鮮なものではない。)
</p>

<p>
must-revalidate 指示子は、特定のプロトコル機能の信頼できる操作をサポートするために必要である。
いかなる状況においても HTTP/1.1 キャッシュは must-revalidate 指示子には従わ<em>なければならない</em>が、特別に、もしキャッシュが何らかの理由でオリジンサーバに到達できない場合は、504 (Gateway Timeout) レスポンスを生成し<em>なければならない</em>。
</p>

<p>
例えば黙って履行されていない財務的処理{silently unexecuted financial transaction} のように、エンティティの再検証が失敗する事でリクエストが不適当な操作というような結果になる場合にのみ、サーバは must-revalidate 指示子を送る<em>べきである</em>。
受信者は、この指示を破るような自動的動作は行っ<em>てはならない</em> し、もし再検証に失敗したらエンティティの検証が行われていないコピーを自動的に供給し<em>てはならない</em>。
</p>

<p>
これは奨励されないが、厳しい接続制約の元で操作されているユーザエージェントはこの指示を破る事が<em>できる</em>が、そのような場合でも、検証されていないレスポンスが供給された事をユーザに明確に警告し<em>なければならない</em>。
この警告は、検証されていないアクセス毎に供給され<em>なければならない</em> し、ユーザによる明確な検証を必要とす<em>べきである</em>。
</p>
</dd>

<dt>proxy-revalidate</dt>
<dd>
<p>
proxy-revalidate 指示子は、非共有ユーザエージェントキャッシュには適用されない事を除けば、must-revalidate 指示子と同じ意味を持つ。
これは、多くのユーザにサービスしているプロクシは毎回再検証する事を必要とする (それぞれのユーザが認証されている事を保証するため) 一方で、ユーザのキャッシュにそれを再検証する必要が無いレスポンス (ユーザによって既に一度認証されているので) を保存し、後に返すような事を許すような認証リクエストへのレスポンスとして使用できる。
</p>

<p>
そのような認証されたレスポンスも、それらがすべてキャッシュされるようにするためには public キャッシュコントロール指示子を必要とする事に注意せよ。
</p>
</dd>
</dl>

<h4 id="section-14.9.5">14.9.5 no-transform 指示子</h4>

<dl>
<dt>no-transform</dt>
<dd>
<p>
中間キャッシュ (プロクシ) の実装者は、あるエンティティボディのメディアタイプを変換する事が有用である事を知っている。
例えば、透過的プロクシはキャッシュスペースを節約したり、遅い通信路上のトラフィックの量を減らすために画像フォーマットの変換を行う事ができる。
</p>

<p>
しかし、これらの変換がある種のアプリケーションのために作られたエンティティボディに適用される時に、深刻な操作上の問題が起こる事がある。
例えば、医療用の映像処理、科学的なデータ分析、およびエンドトゥエンド認証を使うようなアプリケーションは、すべて元々のエンティティボディと bit 単位で同一のエンティティボディを受け取る事を前提にしている。
</p>

<p>
それ故に、もしメッセージが no-transform 指示子を含んでいたら、中間キャッシュやプロクシは no-transform 指示に従うものとして section <a href="#section-13.5.2">13.5.2</a> で列挙されているようなヘッダを変更し<em>てはならない</em>。
これは、キャッシュやプロクシがこれらのヘッダによって指定されたエンティティボディの、エンティティボディ自身の値を含め、いかなる部分も変更し<em>てはならない</em> 事を意味する。
</p>
</dd>
</dl>

<h4 id="section-14.9.6">14.9.6 キャッシュコントロールの拡張</h4>

<p>
Cache-Control ヘッダフィールドは、それぞれにオプション的に割り当てられる値を伴う、一つ以上の cache-extension トークンを使う事によって拡張可能である。
情報的拡張 (キャッシュの振る舞いにおける変更を必要としないもの) は、他の指示子の意味論を変更せずに追加<em>できる</em>。
振る舞いの拡張は、既存のキャッシュ指示子のベースへの修飾子として動作する事により機能するために設計されている。
新しい指示子と標準の指示子が与えられる場合、新しい指示子を理解しないアプリケーションは標準の指示子によって指定される振る舞いを既定とし、新しい指示子を理解するようなアプリケーションは標準命令に関連する要求点を修正するようにそれを認識する。
このようにして、Cache-Control 指示子はその基底のプロトコルを変更する必要なく拡張する事ができる。
</p>

<p>
この拡張メカニズムは、それに元々の HTTP バージョンによって定義されるすべての cache-control 指示子に従い、ある特定の拡張にも従い、理解できない指示子はすべて無視するような HTTP キャッシュに依存する。
</p>

<p>
例えば、ここで private 指示子の修飾子として動作する &quot;community&quot; と呼ばれる新しいレスポンス指示子を仮定する。
この新しい指示子を、あらゆる非共有キャッシュに加えて、この値で名前付けされたコミュニティのメンバによってのみ共有されるあらゆるキャッシュはそのレスポンスをキャッシュできる、と定義する。
UCI というコミュニティに元々プライベートレスポンスであるものを共有キャッシュとして使わせようとするオリジンサーバは、以下のものを含む事でそうする事ができる。
</p>

<pre> <samp>Cache-Control: private, community=&quot;UCI&quot;</samp></pre>

<p>
このヘッダフィールドを認識するキャッシュは、例え community というキャッシュ拡張を理解しなくても、private 指示子を見つけ理解する事で、安全な振る舞いを既定とするので正しく動作するだろう。
</p>

<p>
認識できないキャッシュ指示子は、無視され<em>なければならない</em>。
つまり、HTTP/1.1 キャッシュには理解されないであろうあらゆるキャッシュ指示子は例えキャッシュが拡張を理解できないとしてもキャッシュの振る舞いが最小限正しいものであるように、標準の指示子 (やレスポンスの既定のキャッシュ能力) と結合され送られるという事が仮定される。
</p>

<h3 id="section-14.10">14.10 Connection</h3>

<p>
Connection 一般ヘッダフィールドは、送信者が特定の接続のために望むオプションを指定する事を可能にするが、介在するプロクシとの接続を超えて伝達し<em>てはならない</em>。
</p>

<p>
Connection ヘッダは、以下の様な文法を持つ。
</p>

<pre> Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
 connection-token  = token
</pre>

<p>
HTTP/1.1 プロクシは、メッセージが転送される前に Connection ヘッダフィールドを解析し、フィールド内の各 connection-token ごとに、connection-token と同じ名前を持つヘッダフィールドをそのメッセージから削除し<em>なければならない</em>。
接続オプションは、その接続オプションに関するパラメータが無ければ、追加的ヘッダフィールドは送信されないかもしれないので、対応する追加的ヘッダフィールドによってではなく、Connection ヘッダフィールド内の connection-token によって表される。
</p>

<p>
Connection ヘッダ内に列挙されるメッセージヘッダは、Cache-Control のようなエンドトゥエンドヘッダを含め<em>てはならない</em>。
</p>

<p>
HTTP/1.1 では、送信者がレスポンスを完了した後に接続を切断するという事を合図する &quot;close&quot; 接続オプションを定義する。次の例を見よ。
</p>

<pre> <samp>Connection: close</samp></pre>

<p>
この場合、リクエスト・レスポンスのどちらかのヘッダフィールドの場合でも、その接続は現在のリクエスト/レスポンスが完了したら、「持続的」(section <a href="#section-8.1">8.1</a>) であるとみなす<em>べきではない</em>。
</p>

<p>
持続的接続をサポートしていない HTTP/1.1 アプリケーションは、すべてのメッセージに &quot;close&quot; 接続オプションを含め<em>なければならない</em>。
</p>

<p>
Connection ヘッダを含む HTTP/1.0 (あるいはそれ以前の) メッセージを受けとったシステムは、このフィールド内の各 connection-token ごとに、connection-token と同じ名前を持つメッセージからヘッダフィールドを削除し、無視し<em>なければならない</em>。
これは、HTTP/1.1 以前のプロクシによってそのようなヘッダフィールドを転送するような誤りを起こさないようにするものである。
section <a href="#section-19.6.2">19.6.2</a> 参照。
</p>

<h3 id="section-14.11">14.11 Content-Encoding</h3>

<p>
Content-Encoding エンティティヘッダフィールドは、メディアタイプの修飾子として使われる。
この値があれば、それはエンティティボディに適用されている内容コーディングを示し、すなわち Content-Type ヘッダフィールド
にあるメディアタイプを得るために適用しなければならないデコード方法を示している。
内容コーディングは、主にその根底のメディアタイプの特性を失わせる事無く文書を圧縮するために使われる。
</p>

<pre> Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding</pre>

<p>
内容コーディングは、section <a href="#section-3.5">3.5</a> にて定義されている。使用例を見よ。
</p>

<pre> <samp>Content-Encoding: gzip</samp></pre>

<p>
内容コーディングは、 Request-URI によって識別されるエンティティの特性である。
一般に、エンティティボディは、このエンコーディング状態のまま保存され、レンダリングやそれに類似した使用の直前にのみデコードされる。
しかし、透過的でないプロクシは、受信者がそれ以外のコーディングが利用可能であると知っていて、かつメッセージ中に &quot;no-transform&quot; cache-control 指示子が無い時は、内容コーディングを修正する事が<em>できる</em>。
</p>

<p>
エンティティの内容コーディングが &quot;identity&quot; で無い場合、レスポンスは現在使用されている identity で無い内容コーディング (複数可) を列挙した、Content-Encoding エンティティヘッダ (section <a href="#section-14.11">14.11</a>) を含め<em>なければならない</em>。
</p>

<p>
もしリクエストメッセージ中のエンティティの内容コーディングをオリジンサーバが利用できなければ、サーバは 415 (Unsupported Media Type) のステータスコードを持つレスポンスを返す<em>べきである</em>。
</p>

<p>
エンティティに複数のエンコーディングが適用されている場合は、それが適用された順に列挙され<em>なければならない</em>。
エンコーディングパラメータについての追加情報は、この仕様書では定義されない他のエンティティヘッダフィールドによって与える事が<em>できる</em>。
</p>

<h3 id="section-14.12">14.12 Content-Language</h3>

<p>
Content-Language エンティティヘッダフィールドは、それと共に送られるエンティティの読者の自然言語を表す。
ただし、エンティティボディで使われている言語のすべてとは一致しないかもしれない事に注意せよ。
</p>

<pre> Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag</pre>

<p>
言語タグは、section <a href="#section-3.10">3.10</a> にて定義されている。
Content-Language の主な目的は、ユーザ自身が望む言語に応じて、エンティティを識別したり区別したりできるようにするためである。そのため、もしボディの内容がデンマーク語を理解できる人のみを対象にしているのならば、それに合ったフィールドは次のようになる。
</p>

<pre> <samp>Content-Language: da</samp></pre>

<p>
Content-Language が特定されていない場合、既定ではその内容は全ての言語読者に向けられている、という事になる。
これは、送信者はそれがいずれかの自然言語に特有のものであるとは考えていないか、あるいは送信者自身がどの言語を意図しているかがわからないか、のどちらかを意味するであろう。
</p>

<p>
複数の言語の読者を対象とした内容では、複数の言語を列挙する事が<em>できる</em>。
例えば、オリジナルのマオリ語版と英語版が同時に表現される &quot;ワイタンギ条約&quot; の翻訳では、以下の様に表されるだろう。
</p>

<pre> <samp>Content-Language: mi, en</samp></pre>

<p>
しかし、エンティティ内に複数の言語があるという事が、すなわち複数の言語の読者を対象にしているとは限らない。
例えば、&quot;初めてのラテン語&quot; のようなその言語の初心者向け読み物がその例で、これは明らかに英語を理解する読者に向けられている。
この場合、Content-Language は適切に &quot;en&quot; のみを含めるべきである。
</p>

<p>
Content-Language は、テキスト文書だけでなく、あらゆるメディアタイプに適用する事が<em>できる</em>。
</p>

<h3 id="section-14.13">14.13 Content-Length</h3>

<p>
Content-Length エンティティヘッダフィールドは、受信者に送られるエンティティボディのサイズを、HEAD メソッドの場合は GET リクエストがなされた場合に送られるエンティティボディのサイズを、10 進数のオクテットで表す。
</p>

<pre> Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT</pre>

<p>
例を見よ。
</p>

<pre> <samp>Content-Length: 3495</samp></pre>

<p>
アプリケーションは、section <a href="#section-4.4">4.4</a> にある規則で禁じられていなければ、このフィールドをメッセージボディの転送長さを示すのに使う<em>べきである</em>。
</p>

<p>
0 以上の値を持つ Content-Length は、すべて有効値である。
section <a href="#section-4.4">4.4</a> では、Content-Length が与えられていない場合のメッセージボディの長さを決定する方法を記している。
</p>

<p>
このフィールドの意味は、MIME にて対応する定義、すなわち &quot;message/external-body&quot; という content-type の中で使われるオプション的フィールドとは全く異なっている事に注意せよ。
HTTP では、section <a href="#section-4.4">4.4</a> にある規則で禁じられていなければ、メッセージを転送する前にその長さを決定できる時は常にそれを送る<em>べきである</em>。
</p>

<h3 id="section-14.14">14.14 Content-Location</h3>

<p>
Content-Location エンティティヘッダフィールドは、エンティティがリクエストされたリソースの URI とは別の場所から取得可能である時に、そのメッセージに含まれるエンティティに対するリソースの場所を与える時に使う事が<em>できる</em>。
サーバは、そのレスポンスエンティティに対応する別種のもの{variant} のための Content-Location を提供す<em>べきである</em>;
特に、それに関連するリソースが複数あり、それらのエンティティが実際に個別にアクセスされ得る別の位置{location} を持っているような場合、サーバは返される特定の別リソース{variant} についての Content-Location を提供す<em>べきである</em>。
</p>

<pre> Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                   ( absoluteURI | relativeURI )
</pre>

<p>
Content-Location の値は、エンティティの基底 URI をも定義する。
</p>

<p>
Content-Location 値は、本来の Request-URI の代わりとはならない。
すなわち、リクエストの時点でのこの特定のエンティティに対応するリソースの場所を示しているだけである。
もしその特定のエンティティの源を明らかにしたければ、将来のリクエストでは Request-URI として Content-Location の URI を指定する事が<em>できる</em>。
</p>

<p>
キャッシュは、再利用するために使った URI とは異なる Content-Location を持つエンティティを、その後のその Content-Location URI へのリクエストへのレスポンスとして使ってもよいとは仮定できない。
しかし、section <a href="#section-13.6">13.6</a> に記されているように、Content-Location は単一のリクエストされたリソースから再利用するための複数のエンティティを区別するために使う事ができる。
</p>

<p>
Content-Location が相対URI であれば、その相対URI は Request-URI から相対的に解釈される。
</p>

<p>
PUT リクエストや POST リクエストでの Content-Location の意味は定義されていないので、この場合サーバはそれを無視してもかまわない。
</p>

<h3 id="section-14.15">14.15 Content-MD5</h3>

<p>
Content-MD5 エンティティヘッダフィールドは、RFC 1864 <a href="#ref-23">[23]</a> にて定義されるように、エンティティボディのメッセージ状態チェック{message integrity check} (MIC) をエンティトゥエンドで提供するという目的を持つエンティティボディの MD5 ダイジェストである。
(注: MIC は転送時における偶発的変化を発見するには有効であるが、故意的攻撃においては十分に対抗はできない。)
</p>

<pre> Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
 md5-digest   = &lt;RFC 1864 に従った 128 bit MD5 ダイジェストの base64&gt;
</pre>

<p>
Content-MD5 ヘッダフィールドは、オリジンサーバやクライアントがエンティティボディの状態チェックをするために生成する事が<em>できる</em>。
オリジンサーバやクライアントのみが Content-MD5 ヘッダフィールドを生成する事が<em>でき</em>、プロクシやゲートウェイはエンドトゥエンドでの状態チェックという価値が失われてしまうので、これを生成し<em>てはならない</em>。
ゲートウェイやプロクシを含むあらゆるエンティティボディの受信者は、このヘッダフィールド内のダイジェスト値が受信したエンティティボディのものと一致するかどうかをチェックする事が<em>できる</em>。
</p>

<p>
MD5 ダイジェストは、エンティティボディの内容に基づいて計算されるが、これは適用される内容コーディングは含むが、メッセージボディに適用される転送コーディングは含めない。
メッセージに転送コーディングがなされている場合、そのエンコーディングは受け取ったエンティティについての Content-MD5 値をチェックする前に取り除かれ<em>なければならない</em>。
</p>

<p>
これによって、もし転送コーディングが適用されずに送信された場合でも、ダイジェストを正確にエンティティボディのオクテットに基づいて計算する事ができる。
</p>

<p>
HTTP は、MIME 複合メディアタイプのダイジェスト (例えば、multipart/* や message/rfc822) を計算できるように RFC 1864 を拡張したが、前の段落で定義したようなダイジェストの計算方法は変わらない。
</p>

<p>
ここにいくつか重要な点がある。複合型のエンティティボディは、それぞれが MIME や HTTP ヘッダ (Content-MD5, Content-Transfer-Encoding, Content-Encoding 各ヘッダを含む) を持つような、複数のボディ部分{body-part} を持つ事が<em>できる</em>。
もしボディ部分に Content-Transfer-Encoding かContent-Encoding のどちらかのヘッダがあれば、そのボディ部分の内容はエンコーディングが適用されているとみなされ、Content-MD5 ダイジェストにはそのまま、すなわちエンコーディングが適用された後のボディ部分である、とみなされる。
Transfer-Encoding ヘッダフィールドは、ボディ部分に含む事は許されない。
</p>

<p>
ダイジェストを計算、あるいはチェックする前には、どんな改行も CRLF に変換し<em>てはならない</em>。
すなわち、実際に送信されたテキストで使われた改行規定は、ダイジェストを計算する時までそのままにしておか<em>なければならない</em>。
</p>

<p class="note">
注: HTTP における Content-MD5 の定義は、RFC 1864 での MIME エンティティボディについてのものと全く同一であるが、HTTP エンティティボディへの Content-MD5 の適用とMIMEエンティティボディへのものとを区別する方法がいくつかある。
まず一つは HTTP は、MIME とは違い、Content-Transfer-Encoding を使わずに、Transfer-Encoding や Content-Encoding を使う。
次に、HTTP は MIME よりも頻繁にバイナリ内容タイプを使うが、その場合は、ダイジェストを計算するのに使ったバイトオーダーが、そのタイプで定義された伝送バイトオーダーであるという事に注意する必要がある。
最後に、HTTP では正当な形式である CRLF 以外の改行規定を持つテキストタイプの伝送を許している。
</p>

<h3 id="section-14.16">14.16 Content-Range</h3>

<p>
Content-Range エンティティヘッダフィールドは、共に送られるエンティティボディの一部が、エンティティボディ全体のうちどこに当たるものかを示すために送られる。
レンジ単位は、section <a href="#section-3.12">3.12</a> にて定義されている。
</p>

<pre> Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

 content-range-spec      = byte-content-range-spec
 byte-content-range-spec = bytes-unit SP
                           byte-range-resp-spec &quot;/&quot;
                           ( instance-length | &quot;*&quot; )

 byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                | &quot;*&quot;
 instance-length           = 1*DIGIT
</pre>

<p>
エンティティボディ全体の長さがわからない、あるいはそれを決定するのが難しいというので無ければ、このヘッダにはその全体の長さを含む<em>べきである</em>。
アスタリクス &quot;*&quot; という文字があった場合、そのレスポンスが生成された時点では instance-length はわからないという事を意味する。
</p>

<p>
byte-ranges-specifier 値 (section <a href="#section-14.35.1">14.35.1</a> 参照) とは違い、byte-range-resp-spec では、範囲は一つのみ、そしてその範囲の最初と最後のバイトを絶対バイト位置で指定し<em>なければならない</em>。
</p>

<p>
last-byte-pos 値が first-byte-pos 値より小さかったり、instanse-length 値が last-byte-pos 値以下であるような byte-range-resp-spec を持った byte-content-range-spec は不正である。
不正な byte-content-range-spec を受信しても、その値、そしてそれと共に送られてきた内容は無視し<em>なければならない</em>。
</p>

<p>
レスポンスと共に 416 (Requested range not satisfiable) というステータスコードを送るサーバは、byte-range-resp-spec が &quot;*&quot; である Content-Range フィールドを含む<em>べきである</em>。
instance-length は、選択されたリソースの現在の長さを示す。
206 (Partial Content) というステータスコードのレスポンスには、byte-range-resp-spec が &quot;*&quot; である Content-Rangeフィールドを含ん<em>ではならない</em>。
</p>

<p>
byte-content-range-spec 値の例として、エンティティが全体で 1234 バイト持っていると仮定する。
</p>

<dl>
<dt>最初の 500 バイト</dt>
<dd><samp>bytes 0-499/1234</samp></dd>
<dt>次の 500 バイト</dt>
<dd><samp>bytes 500-999/1234</samp></dd>
<dt>最初の 500 バイト以外すべて</dt>
<dd><samp>bytes 500-1233/1234</samp></dd>
<dt>最後の 500 バイト</dt>
<dd><samp>bytes 734-1233/1234</samp></dd>
</dl>

<p>
HTTP メッセージが単一のレンジ (例えば、単一のレンジへのリクエスト、あるいは複数レンジであっても隙間無く重なるようなセットへのリクエスト等へのレスポンス) の内容を含んでいる場合、この内容は Content-Range ヘッダと、実際に転送されるバイト数を示した Content-Length ヘッダを伴う。
例を見よ。
</p>

<pre><samp> HTTP/1.1 206 Partial content
 Date: Wed, 15 Nov 1995 06:25:24 GMT
 Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
 Content-Range: bytes 21010-47021/47022
 Content-Length: 26012
 Content-Type: image/gif</samp>
</pre>

<p>
HTTP メッセージが複数のレンジ (例えば、その範囲が重ならないような複数レンジへのリクエストのレスポンス) の内容を含んでいる場合、それらはマルチパートメッセージとして転送される。
この目的で使われるマルチパートメディアタイプは、付録 <a href="#section-19.2">19.2</a> にて定義される &quot;multipart/byteranges&quot; である。
互換性の問題に付いては、付録 <a href="#section-19.6.3">19.6.3</a> 参照。
</p>

<p>
単一レンジへのリクエストのレスポンスには、multipart/byteranges メディアタイプを使って送っ<em>てはならない</em>。
結果的に単一レンジになるような、複数レンジへのリクエストのレスポンスには、その部分を送るのに multipart/byteranges メディアタイプを使っても<em>よい</em>。
multipart/byteranges メッセージをデコードできないクライアントは、一つのリクエストで複数のバイトレンジを要求し<em>てはならない</em>。
</p>

<p>
クライアントが１つのリクエストで複数のバイトレンジを要求した時、サーバはリクエストされた順にバイトレンジを返す<em>べきである</em>。
</p>

<p>
サーバが構文上不正だという理由で byte-range-spec を無視した場合、サーバはその不正な Range ヘッダフィールドが存在しない時と同様にそのリクエストを扱う<em>べきである</em>。
(通常、それはエンティティ全体を含んだ 200 レスポンスを返す事を意味する。)
</p>

<p>
もし、サーバが満足できない Range リクエストヘッダフィールド (つまり、その byte-range-spec 値のすべてにおいて、first-byte-pos の値が選択されたリソースの現在の長さを越えているようなもの) を含んだ (If-Range リクエストヘッダフィールドを含む場合以外の) リクエストを受けたならば、416 (Requested range not satisfiable) というレスポンスコードを返す<em>べきである</em> (section <a href="#section-10.4.17">10.4.17</a>)。
</p>

<p class="note">
注: すべてのサーバがこのリクエストヘッダを実装しているわけではないので、クライアントは満足できない Range リクエストヘッダフィールドへのレスポンスとして、サーバが 200 (OK) レスポンスの代わりに 416 (Requested range not satisfiable) レスポンスを送るであろうという事を当てにはできない。
</p>

<h3 id="section-14.17">14.17 Content-Type</h3>

<p>
Content-Type エンティティヘッダフィールドは、受信者に送られるエンティティボディのメディアタイプを示し、HEAD メソッドの場合は、GET リクエストがなされた場合に送られるエンティティボディのメディアタイプを示す。
</p>

<pre>Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type</pre>

<p>
メディアタイプは section <a href="#section-3.7">3.7</a> にて定義されている。
このフィールドの使用例を見よ。
</p>

<pre> <samp>Content-Type: text/html; charset=ISO-8859-4</samp></pre>

<p>
エンティティのメディアタイプを識別するための方法については、section <a href="#section-7.2.1">7.2.1</a> にて更に詳しく記述されている。
</p>

<h3 id="section-14.18">14.18 Date</h3>

<p>
Date 一般ヘッダフィールドは、メッセージが生成された日付・時刻を表し、RFC 822 の orig-date と同じ意味論を持つ。フィールド値は、
section <a href="#section-3.3.1">3.3.1</a> にて示される HTTP-date であり、RFC 1123 <a href="#ref-8">[8]</a> の時刻フォーマットが送られ<em>なければならない</em>。
</p>

<pre> Date  = &quot;Date&quot; &quot;:&quot; HTTP-date</pre>

<p>
例を見よ。
</p>

<pre> <samp>Date: Tue, 15 Nov 1994 08:12:31 GMT</samp></pre>

<p>
オリジンサーバは、以下の場合を除き、全てのレスポンスに Date ヘッダフィールドを含め<em>なければならない</em>。
</p>

<ol>
<li>もし、レスポンスステータスコードが 100 (Continue) か 101 (Switching Protocols) ならば、レスポンスはサーバのオプションとして、Date ヘッダフィールドを含める事が<em>できる</em>。</li>
<li>もし、レスポンスステータスコードが、例えば 500 (Internal Server Error) や 503 (Service Unavailable) 等のサーバエラーを表せば、有効な Date ヘッダを生成する事は、不便であり不可能である。</li>
<li>もし、サーバが有効な現在時刻を表せる時計を持っていなければ、レスポンスは Date ヘッダフィールドを含め<em>てはならない</em>。この場合、section <a href="#section-14.18.1">14.18.1</a> にある規則に従わ<em>なければならない</em>。</li>
</ol>

<p>
Date ヘッダフィールドを持たないメッセージが、メッセージが受信者によってキャッシュされたり、Date ヘッダが要求されるプロトコルによって経由されていれば、受信者がそれを割り当て<em>なければならない</em>。
時計を持たない HTTP 実装は、使うたびにその有効性を再検証しない限りはレスポンスをキャッシュし<em>てはならない</em>。
HTTP キャッシュ、特に共有キャッシュは、NTP <a href="#ref-28">[28]</a> のような、信頼できる外部の標準の時計と同期するためのメカニズムを使う<em>べきである</em>。
</p>

<p>
クライアントは、PUT リクエストや POST リクエストのように、エンティティボディを含むようなメッセージにのみ Date ヘッダフィールドを送る<em>べきである</em>が、省略してもよい。
時計を持たないクライアントは、リクエストに Date ヘッダフィールドを送っ<em>てはならない</em>。
</p>

<p>
Date ヘッダ中に送られる HTTP-date は、メッセージ生成後の日付・時刻を表す<em>べきではない</em>。
もし、実装がかなり正確な日付・時刻を生成できるのでなければ、メッセージの生成時刻として最も利用可能な近似値を表す<em>べきである</em>。
理論上は、日付はエンティティを生成する直前の時刻を表すべきである。
しかし実用上は、メッセージの生成中ならば、その意味上の値に影響を及ぼす事無く、いつでも生成できる。
</p>

<h4 id="section-14.18.1">14.18.1 時計の無いサーバの動作</h4>

<p>
オリジンサーバ実装の中には、利用可能な時計を持っていないものがあるかもしれない。
時計の無いオリジンサーバは、信頼ある時計を持つシステムやユーザによるリソースに関連付けられた値で無ければ、Expires や Last-Modified 値を割り当て<em>てはならない</em>。
しかし、そのサーバが設置される時刻以前の、それが過去であるとわかっている Expires 値は割り当てる事が<em>できる</em> (これは、各々のリソースの Expires 値を分けて保存する事無く、レスポンスの &quot;pre-expiration&quot; を許す) 。
</p>

<h3 id="section-14.19">14.19 ETag</h3>

<p>
ETag レスポンスヘッダフィールドは、リクエストされたバリアントのエンティティタグの現在の値を示す。
エンティティタグと共に使われるヘッダは、section <a href="#section-14.24">14.24</a>, <a href="#section-14.26">14.26</a>, <a href="#section-14.44">14.44</a> にて記されている。
エンティティタグは、同じリソースからの他のエンティティとの比較に使う事が<em>できる</em> (section <a href="#section-13.3.3">13.3.3</a> 参照)。
</p>

<pre> ETag = &quot;ETag&quot; &quot;:&quot; entity-tag</pre>

<p>
例を見よ。
</p>

<pre> <samp>ETag: &quot;xyzzy&quot;
 ETag: W/&quot;xyzzy&quot;
 ETag: &quot;&quot;</samp>
</pre>

<h3 id="section-14.20">14.20 Expect</h3>

<p>
Expect リクエストヘッダフィールドは、特定のサーバの振る舞いがクライアントによって要求されている事を示すために使われる。
</p>

<pre> Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

 expectation  =  &quot;100-continue&quot; | expectation-extension
 expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                          *expect-params ]
 expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]
</pre>

<p>
リクエスト中の Expect フィールドにある期待値{expectation values} を理解できない、あるいはそれに従えないサーバは、適切なエラーステータスを返さ<em>なければならない</em>。
サーバは、その期待{expectations} に一つでも添えない場合は、417 (Expectation Failed) ステータスを返さ<em>なければならない</em>が、そのリクエストが他に問題を持つような場合などは、他の 4xx ステータスを返してもよい。
</p>

<p>
このヘッダフィールドは、将来の拡張によって許される拡張された構文によって定義される。
もし、サーバがサポートしていない expectation-extension を含んだ Expect フィールドを持つリクエストを受けた時は、417 (Expectation Failed) ステータスを返さ<em>なければならない</em>。
</p>

<p>
期待値の比較では、&quot; &quot; にて括られていないトークン (100-continue トークンも含む) においては大文字・小文字を区別しないが、&quot; &quot; にて括られた expectation-extensions においては区別される。
</p>

<p>
Expect のメカニズムはホップバイホップである。
すなわち、HTTP/1.1 プロクシは、もし叶えられない期待を持つリクエスト受けた時には 417 (Expectation Failed) ステータスを返さ<em>なければならない</em>。
しかし、Expect リクエストヘッダフィールド自体はエンドトゥエンドである。
すなわち、もしリクエストが転送される場合には、このヘッダも転送され<em>なければならない</em>。
</p>

<p>
多くの古い HTTP/1.0 や HTTP/1.1 各アプリケーションは、Expect ヘッダを理解できない。
</p>

<p>
100 (continue) ステータスの使い方については、section <a href="#section-8.2.3">8.2.3</a> 参照。
</p>

<h3 id="section-14.21">14.21 Expires</h3>

<p>
Expires エンティティヘッダフィールドは、レスポンスが新鮮で無くなる{stale} と考えられる時点の日付/時刻を表す。
通常、キャッシュ (プロクシのキャッシュかユーザエージェントのキャッシュ) は、最初にオリジンサーバ (かエンティティの新鮮なコピーを持つ中間キャッシュ) にその有効性を検証{validated} するまでは、新鮮で無いキャッシュエントリを返さないであろう。
期限切れモデルについて、更に詳しくはsection <a href="#section-13.2">13.2</a> 参照。
</p>

<p>
Expires フィールドがあっても、オリジナルリソースがその期限前、あるいは期限後に更新されたり、削除されたりするという事を暗黙的に意味するものではない。
</p>

<p>
Expires フィールドのフォーマットは、section <a href="#section-3.3.1">3.3.1</a> にて定義される絶対日時であり、RFC 1123 の日付フォーマットで<em>なければならない</em>。
</p>

<pre> Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date</pre>

<p>
その使用例は以下のようになる。
</p>

<pre> <samp>Expires: Thu, 01 Dec 1994 16:00:00 GMT</samp></pre>

<p class="note">
注: もしレスポンスに max-age 指示子を持つ Cache-Control フィールドを含んでいたら (section <a href="#section-14.9.3">14.9.3</a> 参照) 、その指示は Expires フィールドを上書きする。
</p>

<p>
HTTP/1.1 のクライアントとキャッシュは、今までのように、この他の、特に &quot;0&quot; という値 (すなわち &quot;期限切れ&quot; ) を含む不正な日付フォーマットも扱わ<em>なければならない</em>。
</p>

<p>
レスポンスが &quot;期限切れ&quot; という事を表すためには、オリジンサーバは Date ヘッダの値と同じである Expires の日付を送る (期限の計算方法については、section <a href="#section-13.2.4">13.2.4</a> 参照)。
</p>

<p>
レスポンスが &quot;期限切れではない&quot; という事を表すためには、オリジンサーバはレスポンスが送られる時点からおよそ 1 年後の時刻の日付を持つ Expires を送る。
HTTP/1.1 サーバは、Expires の日付に 1 年後以上未来の日付を送る<em>べきではない</em>。
</p>

<p>
既定ではキャッシュできないレスポンスにおいて、ある未来の日付を持つ Expires ヘッダフィールドがあって、それに Cache-Control ヘッダフィールド (section <a href="#section-14.9">14.9</a>) にて何らかの指示がなされていなければ、そのレスポンスはキャッシュ可能である。
</p>

<h3 id="section-14.22">14.22 From</h3>

<p>
もし From リクエストヘッダフィールドが与えられていれば、そこにはリクエストしているユーザエージェントを操っている人間のインターネット e-mail アドレスが含められている<em>べきである</em>。
そのアドレスは、RFC 1123 <a href="#ref-8">[8]</a> によってアップデートされた RFC 822 <a href="#ref-9">[9]</a> の中で定義されているような、マシンが使えるものである<em>べきである</em>。
</p>

<pre> From   = &quot;From&quot; &quot;:&quot; mailbox</pre>

<p>
例を見よ。
</p>

<pre> <samp>From: webmaster@w3.org</samp></pre>

<p>
このヘッダフィールドは、ログを取るという目的や不正なあるいは望まないリクエストの原因を究明するために使う事が<em>できる</em>。
アクセス保護の安全性が確保できない形態では使う<em>べきではない</em>。
このフィールドは、このリクエストがそのメソッドを実行する責任を持つ者に代わって実行された、という事を意味する。
特に、ロボットエージェントは、受信後に問題が起きた場合にロボットを操作している責任者に連絡を取るために、このヘッダを含める<em>べきである</em>。
</p>

<p>
このフィールドのインターネット e-mail アドレスは、リクエストを発行するインターネットホストとは異なるものを使う事が<em>できる</em>。
例えば、リクエストがプロクシを通して送られた場合、元々のリクエスト者のアドレスが使われる<em>べきである</em>。
</p>

<p>
クライアントは、それがユーザのプライバシーへの関心やそのサイトのセキュリティポリシーにそぐわないかもしれないので、From ヘッダフィールドをユーザの承認無しには送る<em>べきではない</em>。
ユーザが、リクエストの前にこのフィールドの値を使用不可にしたり、使用可能にしたり、修正したりできるようする事を強く推奨する。
</p>

<h3 id="section-14.23">14.23 Host</h3>

<p>
Host リクエストヘッダフィールドは、リクエストされたリソースのインターネットホストとポート番号を、ユーザや参照されるリソースによって与えられるオリジナル URI (一般には section <a href="#section-3.2.2">3.2.2</a> にて表されるような HTTP URL) から得るために、指定する。
Host フィールド値は、オリジンサーバやオリジナル URL によって与えられているゲートウェイによって名付けられる authority を表さ<em>なければならない</em>。
これによって、オリジンサーバやゲートウェイは、単一の IP アドレス上で複数のホスト名を持つサーバのルートURL &quot;/&quot; のような、内部的に曖昧な{internally-ambiguous} URL を区別する事ができる。
</p>

<pre> Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; Section <a href="#section-3.2.2">3.2.2</a></pre>

<p>
&quot;host&quot; の後にポートの情報が無ければ、暗黙的にリクエストされるサービスの既定ポート (すなわち HTTP URL の場合は &quot;80&quot;) を使用する事を意味する。
例えば、&lt;http://www.w3.org/pub/WWW/&gt; のオリジンサーバへのリクエストは、厳密には以下のものを含んでいるであろう。
</p>

<pre> <samp>GET /pub/WWW/ HTTP/1.1
 Host: www.w3.org</samp>
</pre>

<p>
クライアントは、すべての HTTP/1.1 リクエストメッセージに Host ヘッダフィールドを含め<em>なければならない</em>。
もし、リクエストされた URI がリクエストされているサービスのインターネットホスト名を含んでいなければ、Host ヘッダフィールドの値は空にし<em>なければならない</em>。
HTTP/1.1 プロクシは、どんな転送するリクエストメッセージにも、プロクシによってリクエストされているサービスを識別する適切な Host ヘッダフィールドを含んでいるようにし<em>なければならない</em>。
すべてのインターネットベースの HTTP/1.1 サーバは、Host ヘッダフィールドが無い HTTP/1.1 リクエストメッセージには、400 (Bad Request) ステータスコードを返さ<em>なければならない</em>。
</p>

<p>
Host に関するその他の必要条件については、section <a href="#section-5.2">5.2</a> 及び <a href="#section-19.6.1.1">19.6.1.1</a> を見よ。
</p>

<h3 id="section-14.24">14.24 If-Match</h3>

<p>
If-Match リクエストヘッダフィールドは、メソッドを条件付きにするために使われる。
以前にそのリソースから一つ以上のエンティティを取得しているクライアントは、If-Match ヘッダフィールド中に関連するエンティティタグのリストを含める事によって、それらのエンティティの一つが現在使用されているものかどうかを確かめる事ができる。
エンティティタグは、section <a href="#section-3.11">3.11</a> にて定義されている。
この機能は、通信処理の負荷を最小量にするようにキャッシュされた情報を能率的に更新する事を目的としている。
また、間違ったバージョンのリソースを不注意に更新させないために、更新リクエストにも使用される。特別な場合として、&quot;*&quot; という値は、そのリソースの現在のあらゆるエンティティに一致する。
</p>

<pre> If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )</pre>

<p>
もし、いずれかのエンティティタグがそのリソースへの類似した (If-Match ヘッダが無い) GETリクエストのレスポンスとして返されるであろうエンティティのエンティティタグに一致する場合か、&quot;*&quot; が与えられている場合にそのリソースとして現在使用できるエンティティが存在する場合には、サーバはそのリクエストに If-Match ヘッダが無い場合と同じようにリクエストされた動作を行う事が<em>できる</em>。
</p>

<p>
サーバが If-Match にあるエンティティタグを比較するためには強い比較関数 (section <a href="#section-13.3.3">13.3.3</a> 参照) を使わ<em>なければならない</em>。
</p>

<p>
エンティティタグに一致するものが無かったり、&quot;*&quot; が与えられていてもそのリソースとして現在使用できるエンティティが存在しない場合には、サーバはリクエストされた動作を実行し<em>てはならない</em> 代わりに、412 (Precondition Failed) レスポンスを返さ<em>なければならない</em>。
この振る舞いは、クライアントが、ある時点に取得してから更新されたリソースを、例えば PUT のような更新メソッドによって、更新されないようにしたい場合に最も有用である。
</p>

<p>
If-Match を持たないリクエストが 2xx や 412 以外の結果を返す時は、If-Match ヘッダは無視され<em>なければならない</em>。
</p>

<p>
&quot;If-Match: *&quot; とは、オリジンサーバ (あるいは Vary メカニズムを使う事ができるようなキャッシュ、section <a href="#section-14.44">14.44</a> 参照) によって選択された表現がある時にはそのメソッドは実行される<em>べきであり</em>、その表現が無い時にはそのメソッドは実行され<em>てはならない</em> という事を意味する。
</p>

<p>
リソースを更新しようとするリクエスト (例えば PUT) は、もし If-Match の値 (単一のエンティティタグ) に対応するエンティティが、もはやそのリソースの表現で無い場合にはそのリクエストメソッドを適用し<em>てはならない</em>という事を表すために If-Match ヘッダフィールドを含める事が<em>できる</em>。
これによってユーザは、リソースが知らないうちに更新されていた場合にリクエストを成功させないようにしたいという事を示す事ができる。例を見よ。
</p>

<pre><samp> If-Match: &quot;xyzzy&quot;
 If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
 If-Match: *</samp>
</pre>

<p>
If-Match ヘッダフィールドと同時に If-None-Match か If-Modified-Since ヘッダフィールドを使用しているようなリクエストについては、この仕様書ではその結果についてを定義しない。
</p>

<h3 id="section-14.25">14.25 If-Modified-Since</h3>

<p>
If-Modified-Since リクエストヘッダフィールドは、メソッドを条件付きにするために使われる。
もしリクエストされたバリアントがこのフィールドにて指定された時刻以降に更新されていなければ、サーバはエンティティを返す代わりに、304 (not modified) レスポンスをメッセージボディ無しで返すであろう。
</p>

<pre> If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date</pre>

<p>
このフィールドの例を見よ。
</p>

<pre> <samp>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</samp></pre>

<p>
If-Modified-Since ヘッダを持っていて且つ Range ヘッダを持たない GET メソッドは、If-Modified-Since ヘッダによって与えられる時刻以降に更新された場合のみ指定したエンティティを転送する事を要求する。
これを決定するためのアルゴリズムには、以下のようなものを含む。
</p>

<ol class="abc">
<li>リクエストが 200 (OK) ステータス以外の結果を返すか、あるいは渡された If-Modified-Since の日付が不正なものであるような場合、レスポンスは通常の GET 時と全く同じものとなる。サーバの現在時刻より未来の時刻は無効である。</li>
<li>バリアントが If-Modified-Since にある時刻以降に更新されている場合、レスポンスは通常の GET 時と全く同じものとなる。</li>
<li>バリアントが有効な If-Modified-Since にある時刻以降に更新されていない場合、サーバは 304 (not modified) レスポンスを返す<em>べきである</em>。</li>
</ol>

<p>
この機能は、通信処理の負荷を最小量にするようにキャッシュされた情報を能率的に更新する事を目的にしている。
</p>

<p class="note">
注: Range リクエストヘッダフィールドは、If-Modified-Since の意味を変更する。
詳細については section <a href="#section-14.35">14.35</a> 参照。
</p>

<p class="note">
注: If-Modified-Since の時刻はサーバによって解釈されるが、この時計はクライアントのものとは同期していないかもしれない。
</p>

<p class="note">
注: If-Modified-Since ヘッダフィールドを扱う時、いくつかのサーバは 304 (not modified) レスポンスを返すかどうかを決定する際に、それ以下であるかを見る関数{less-than function} よりも、正確に時刻を比較する関数{comparison function} を使うであろう。
キャッシュの妥当性{validation} のために If-Modified-Since ヘッダフィールドを送った時に最良な結果を得るためには、クライアントは可能であればいつでも直前の Last-Modified ヘッダフィールドにて受けたそのままの時刻文字列を使う事を提案する。
</p>

<p class="note">
注: クライアントが同じリクエストから取得した Last-Modified ヘッダから得られた時刻の代わりに If-Modified-Since ヘッダに任意の時刻を使ったとしたら、クライアントはこの日付がサーバが決めている時刻の取り決めに従って解釈されるという事に注意すべきである。
クライアントは、クライアントとサーバ間の時計のズレや異なるエンコーディングの使用による丸めの問題を考慮するべきである。
これは、もし最初にリクエストした時刻からその後の If-Modified-Since にある時刻までに文書が変化した場合に競合状態が起こる可能性や、If-Modified-Since の日付がサーバの時計による修正無しにクライアントの時計から導出された場合に {clock-skew-related} 問題がおこる可能性を示している。
クライアントとサーバ間の時計のズレの修正は、ネットワーク間での待ち時間があるので、全く同じにする事はできない。
</p>

<p>
If-Modified-Since ヘッダフィールドと同時に If-Match か If-Unmodified-Since ヘッダフィールドを使用しているようなリクエストについては、この仕様書ではその結果についてを定義しない。
</p>

<h3 id="section-14.26">14.26 If-None-Match</h3>

<p>
If-None-Match リクエストヘッダフィールドは、メソッドを条件付きにする場合に使われる。
以前にそのリソースから一つ以上のエンティティを取得しているクライアントは、If-None-Match ヘッダフィールド中にそれに対応するエンティティタグのリストを含める事によって、それらのエンティティの中に現在使用できるものがないかどうかを確かめる事ができる。
この機能は、通信処理の負荷を最小量にするようにキャッシュされた情報を能率的に更新する事を目的にしている。
また (例えば PUT 等の) メソッドを使う場合に、既にあるリソースをクライアントがそのリソースが無いと考えている場合に不注意に更新してしまわないようにするためにも使われる。
</p>

<p>
特別な場合として、&quot;*&quot; という値は、そのリソースの現在のあらゆるエンティティに一致する。
</p>

<pre> If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )</pre>

<p>
いずれかのエンティティタグがそのリソースにされる類似した (If-None-Match ヘッダが無い) GET リクエストのレスポンスとして返されるエンティティのエンティティタグに一致する場合か、&quot;*&quot; が与えられる場合にそのリソースに現在使用できるエンティティが存在する場合において、サーバはリソースの更新時刻とリクエストの中の If-Modified-Since ヘッダフィールドにて与えられた時刻が一致しなかった場合以外は、リクエストされた動作を行っ<em>てはならない</em>。
その代わり、もしリクエストメソッドが GET か HEAD であれば、サーバは 304 (Not Modified) レスポンスを、一致したエンティティのうちの一つのキャッシュに関連するヘッダフィールド (特に ETag) を付けて返す<em>べきである</em>。
その他のメソッドの場合はすべて、サーバは 412 (Precondition Failed) というステータスを返さ<em>なければならない</em>。
</p>

<p>
二つのエンティティタグが一致しているかどうかを決定する方法についての決まりについては、section <a href="#section-13.3.3">13.3.3</a> 参照。
GET や HEAD リクエストの場合には、弱い比較関数のみを使う事ができる。
</p>

<p>
エンティティタグが一致するものが無ければ、サーバはそのリクエストに If-None-Match ヘッダが無い場合と同じようにリクエストされた動作を行う事が<em>できる</em>が、同時にリクエスト中のすべての If-Modified-Since ヘッダフィールドは無視され<em>なければならない</em>。
すなわち、エンティティタグが一致するものが無ければ、サーバは 304 (Not Modified) レスポンスを返し<em>てはならない</em>。
</p>

<p>
もし If-None-Match を持たないリクエストが、2xx や 304 各ステータス以外の結果を返すならば、If-None-Match ヘッダは無視され<em>なければならない</em>。
(あるリクエスト中に If-Modified-Since と If-None-Match が同時に存在する場合のサーバの振る舞いについての議論は section <a href="#section-13.3.4">13.3.4</a> を見よ。)
</p>

<p>
&quot;If-None-Match: *&quot; とは、オリジンサーバ (あるいは Vary メカニズムを使う事ができるようなキャッシュ、section <a href="#section-14.44">14.44</a> 参照) によって選択された表現がある時には、そのメソッドは実行し<em>てはならない</em> が、その表現が無い時には、そのメソッドは実行する<em>べきである</em> という事を意味する。
この機能は、ある二つの PUT 作業中に競合が起こらないようにする場合に有用である。
</p>

<p>
例を見よ。
</p>

<pre><samp> If-None-Match: &quot;xyzzy&quot;
 If-None-Match: W/&quot;xyzzy&quot;
 If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
 If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
 If-None-Match: *</samp>
</pre>

<p>
If-None-Match ヘッダフィールドと同時に If-Match か If-Unmodified-Since ヘッダフィールドを使用しているようなリクエストについては、この仕様書ではその結果についてを定義しない。
</p>

<h3 id="section-14.27">14.27 If-Range</h3>

<p>
もしクライアントがキャッシュとしてあるエンティティのコピーの一部を保持していて、そのエンティティ全体の最新のコピーが欲しい場合、 (If-Unmodified-Since か If-Match、あるいは両方を使った) 条件付き GET として Range リクエストヘッダを使う事ができる。
しかし、もしエンティティが更新されたために条件が成立しなければ、クライアントは最新のエンティティボディ全体を取得するために次なるリクエストをしなければならない。
</p>

<p>
If-Range ヘッダは、クライアントの次なるリクエストを &quot;短略化{short-circuit}&quot; する事ができる。
一般的に、これは「もしエンティティが更新されていなかったら、私が持っていない部分を送信してくれ。そうでなければ、新しいエンティティ全体を送信してくれ。」のように解釈される。
</p>

<pre> If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date )</pre>

<p>
クライアントがそのエンティティのエンティティタグは持っていないが、Last-Modified の日付を持っている場合、クライアントは If-Range ヘッダとしてその日付を使う事が<em>できる</em>。
(サーバは、多くても2文字を調べるだけで、正確な HTTP 日付と任意の形式のエンティティタグとを区別する事ができる。)
If-Range ヘッダは Range ヘッダと共にのみ使う<em>べきであり</em>、リクエストが Range ヘッダを含んでいない場合や、サーバが sub-range 操作をサポートしない場合には、これは無視され<em>なければならない</em>。
</p>

<p>
If-Range ヘッダにて与えられたエンティティタグがそのエンティティの現在のエンティティタグに一致した場合、サーバは 206 (Partial content) レスポンスを使って、そのエンティティの指定される sub-range を供給す<em>べきである</em>。
もしエンティティタグが一致しなければ、サーバは 200 (OK) レスポンスを使って、そのエンティティ全体を返す<em>べきである</em>。
</p>

<h3 id="section-14.28">14.28 If-Unmodified-Since</h3>

<p>
If-Unmodified-Since リクエストヘッダフィールドは、メソッドを条件付きにするために使われる。
もし、リクエストされたリソースがこのフィールド内に記された時刻以降に更新されていなければ、サーバはそのリクエストに If-Unmodified-Since ヘッダが無い場合と同じようにリクエストされた動作を行う<em>べきである</em>。
</p>

<p>
リクエストされたバリアントが指定された時刻以降に更新されている場合、サーバはリクエストされた動作を行っ<em>てはならない</em> 代わりに、412 (Precondition Failed) を返さ<em>なければならない</em>。
</p>

<pre> If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date</pre>

<p>
このフィールドの使用例は、次のようになる。
</p>

<pre> <samp>If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</samp></pre>

<p>
通常のリクエスト (すなわち If-Unmodified-Since が無いリクエスト) が、2xx や 412 以外の結果を返す場合、If-Unmodified-Since ヘッダは無視す<em>べきである</em>。
</p>

<p>
指定された時刻が不正であれば、このヘッダは無視される。
</p>

<p>
If-Unmodified-Since ヘッダフィールドと同時に If-None-Match か If-Modified-Since ヘッダフィールドを使用しているようなリクエストについては、この仕様書ではその結果についてを定義しない。
</p>

<h3 id="section-14.29">14.29 Last-Modified</h3>

<p>
Last-Modified エンティティヘッダフィールドは、オリジンサーバがバリアントが最後に更新されたと考える日付を表す。
</p>

<pre> Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date
</pre>

<p>
使用例は以下のようになる。
</p>

<pre>  <samp>Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</samp>
</pre>

<p>
このヘッダフィールドの正確な意味は、オリジンサーバの実装とオリジナルリソースの性質による。
それがファイルである場合、そのファイルシステムの最終更新時刻になるであろう。
動的に取りこまれる部分を持つエンティティの場合、その各構成要素の最終更新時刻の中で最も最新の物になるであろう。
データベースゲートウェイの場合、レコードの最終更新時刻のタイムスタンプになるであろう。
仮想オブジェクトの場合、内部状態が変化した最終時刻になるであろう。
</p>

<p>
オリジンサーバは、Last-Modified にメッセージを生成した時刻よりも後の日付を送っ<em>てはならない</em>。
リソースの最終更新時刻がある未来の時点を示すような場合は、サーバはその日付をメッセージ生成時点のものに置き換え<em>なければならない</em>。
</p>

<p>
オリジンサーバは、レスポンスの Date 値を生成する時刻にできるだけ近いエンティティの Last-Modified 値を得る<em>べきである</em>。
これによって受信者は、特にもしエンティティの更新がレスポンスが生成される時刻と近い場合に、エンティティの更新時刻について正確な評価ができる。
</p>

<p>
HTTP/1.1 サーバは、可能であればいつでも Last-Modified を送る<em>べきである</em>。
</p>

<h3 id="section-14.30">14.30 Location</h3>

<p>
Location レスポンスヘッダフィールドは、リクエストを完了するため、あるいは新しいリソースを識別するため、受信者を Request-URI 以外の場所にリダイレクトするのに使われる。
201 (Created) レスポンスの場合、Location はリクエストによって作られた新しいリソースの場所である。
3xx レスポンスの場合、Location はリソースへ自動でリダイレクションさせるためにサーバが望むURIを示す<em>べきである</em>。
このフィールド値は、単一の絶対 URI から成る。
</p>

<pre> Location       = &quot;Location&quot; &quot;:&quot; absoluteURI
</pre>

<p>
例を見よ。
</p>

<pre> <samp>Location: http://www.w3.org/pub/WWW/People.html</samp>
</pre>

<p class="note">
注: Content-Location ヘッダフィールド (section <a href="#section-14.14">14.14</a>) は、リクエストと共に送られるエンティティのオリジナルの場所を指すという点で、Location ヘッダとは異なる。
それ故に、レスポンスは Location と Content-Location の両ヘッダフィールドを含む事は可能である。
いくつかのメソッドでのキャッシュの必要条件については、section <a href="#section-13.10">13.10</a> も合わせて見よ。
</p>

<h3 id="section-14.31">14.31 Max-Forwards</h3>

<p>
Max-Forwards リクエストヘッダフィールドは、TRACE (section <a href="#section-9.8">9.8</a>) や OPTIONS (section <a href="#section-9.2">9.2</a>) の各メソッドに、次のインバウンドサーバにリクエストを転送できるプロクシやゲートウェイの数を制限するというメカニズムを提供する。
これは、クライアントが、その中間で失敗したりループしたりしているリクエスト連鎖を追跡しようとする場合に有用である。
</p>

<pre> Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT</pre>

<p>
Max-Forwards 値は、このリクエストメッセージが残り何回転送できるかという回数を表す 10 進数の整数値である。
</p>

<p>
Max-Forwards ヘッダフィールドを含む TRACE あるいは OPTIONS リクエストを受けたプロクシやゲートウェイは、リクエストを転送する前にその値を調べ、更新し<em>なければならない</em>。
もし、受けとった Max-Forwards の値が 0 であれば、受信者はそのリクエストを転送し<em>てはならない</em>代わりに、最後の受信者として応答し<em>なければならない</em>。
受けとった Max-Forwards の値が 0 以上であれば、転送されるメッセージにはその値から 1 を引いた値に更新した Max-Forwards フィールドを含め<em>なければならない</em>。
</p>

<p>
Max-Forwards ヘッダフィールドは、その仕様書で定義された他のすべてのメソッドや、そのメソッド定義の部分で明確に述べられていない拡張メソッド中では無視しても<em>よい</em>。
</p>

<h3 id="section-14.32">14.32 Pragma</h3>

<p>
Pragma 一般ヘッダフィールドは、リクエスト/レスポンス連鎖中のあらゆる受信者にも適用されるであろう実装の特別な指示を示すために使われる。
全ての pragma 指示子は、プロトコルの視点から見ればオプショナルな振るまいを指定するが、その振るまいが指示子と一致している事を要求するシステムがある<em>かもしれない</em>。
</p>

<pre> Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
 pragma-directive  = &quot;no-cache&quot; | extension-pragma
 extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]
</pre>

<p>
no-cache 指示子がリクエストメッセージ中にある時は、アプリケーションはリクエストされたもののキャッシュコピーを持ってたとしても、オリジンサーバに向けてリクエストを転送す<em>べきである</em>。
この pragma 指示子は、no-cache キャッシュ指示子 (section <a href="#section-14.9">14.9</a> 参照) 同じ意味論を持ち、HTTP/1.0 との後方互換のためにここで定義される。
クライアントは、HTTP/1.1 に従っているかどうかを知らないサーバに no-cache リクエストを送る際には、両方のヘッダフィールドを含める<em>べきである</em>。
</p>

<p>
pragma 指示子は、そのアプリケーションにとってどんな意味を持つかに関わらず、その指示がそのリクエスト/レスポンス連鎖に関わるすべての受信者に適用されるかもしれないので、プロクシやゲートウェイアプリケーションはそれを無加工で通さ<em>なければならない</em>。
特定の受信者のために pragma を指定する可能性は無いけれども、受信者にとって適切で無いあらゆる pragma 指示子は、受信者によって無視される<em>べきである</em>。
</p>

<p>
HTTP/1.1 キャッシュは &quot;Pragma: no-cache&quot; を &quot;Cache-Control: no-cache&quot; が送られた時と同様に扱う<em>べきである</em>。
HTTP では、新しい Pragma 指示子は定義されないであろう。
</p>

<p class="note">
注: レスポンスヘッダフィールドでの &quot;Pragma: no-cache&quot; は、実際には定義されていないので、レスポンスでの &quot;Cache-Control: no-cache&quot; の確実な代用とはならない。
</p>

<h3 id="section-14.33">14.33 Proxy-Authenticate</h3>

<p>
Proxy-Authenticate レスポンスヘッダフィールドは、407 (Proxy Authentication Required) レスポンスの一部として含めなければ <em>ならない</em>。
このフィールド値は、この Request-URI のプロクシに適用される認証スキームとパラメータを含む challenge から成る。
</p>

<pre> Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge
</pre>

<p>
HTTP アクセス認証処理方法については、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; <a href="#ref-43">[43]</a> にて記述されている。
WWW-Authenticate とは違い、Proxy-Authenticate ヘッダフィールドは現在の接続にのみ適用され、またダウンストリームのクライアントに通す<em>べきではない</em>。
しかし、中間のプロクシがダウンストリームのクライアントからリクエストされる事によって自身の credentials を得る必要がある可能性があり、そのような場合はまるでプロクシが Proxy-Authenticate ヘッダフィールドを転送しているように見える事がある。
</p>

<h3 id="section-14.34">14.34 Proxy-Authorization</h3>

<p>
Proxy-Authorization リクエストヘッダフィールドを使って、クライアントは認証を要求するプロクシに自身 (やそのユーザ) を識別させる。
Proxy-Authorization のフィールド値は、プロクシやリクエストされたリソースのある領域へのユーザエージェントの認証情報を含む credentials から成る。
</p>

<pre> Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials
</pre>

<p>
HTTP アクセス認証処理方法については、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; <a href="#ref-43">[43]</a> にて記述されている。
Authorization とは違い、Proxy-Authorization ヘッダフィールドは Proxy-Authorization を使って認証を要求する次のアウトバウンドプロクシにのみ適用される。
連鎖内に複数のプロクシがある時は、Proxy-Authorization ヘッダフィールドは、credentials を受け取ろうとしている最初のアウトバウンドプロクシによって消去される。
もしプロクシが与えられたリクエストを協同で認証するようなメカニズムならば、プロクシはリクエストから次のプロクシへとクライアントの credentials を取り次ぐ事が<em>できる</em>。
</p>

<h3 id="section-14.35">14.35 Range</h3>

<h4 id="section-14.35.1">14.35.1 バイトレンジ</h4>

<p>
HTTP メッセージ中では、すべての HTTP エンティティがバイトシーケンスで表せるので、バイトレンジの概念はあらゆる HTTP エンティティにとって意義のあるものである。
(しかしながら、すべてのクライアントとサーバがバイトレンジ操作をサポートする必要は無い。)
</p>

<p>
HTTP でのバイトレンジ指定は、エンティティボディ (それがメッセージボディと同一で無くてもよい) 中のバイトシーケンスに適用される。
</p>

<p>
バイトレンジ操作では、単一のバイトレンジ、または一つのエンティティ中で複数のレンジセットを指定する事が<em>できる</em>。
</p>

<pre> ranges-specifier = byte-ranges-specifier
 byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
 byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
 byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos]
 first-byte-pos  = 1*DIGIT
 last-byte-pos   = 1*DIGIT
</pre>

<p>
byte-range-spec 中の first-byte-pos 値には、その範囲の最初のバイトの byte-offset を与える。
last-byte-pos 値には、その範囲の最後のバイトの byte-offset を与える。
つまり、指定されるバイトの位置も含まれる。
バイトオフセットは 0 から始まる。
</p>

<p>
last-byte-pos 値がある場合、その値は byte-range-spec での first-byte-pos 以上のものにし<em>なければならない</em>が、そうで無い場合は構文上不正となる。
一つ以上の構文上不正な byte-range-spec 値を含む byte-range-set を受信しても、その byte-range-set を含むヘッダフィールドは無視し<em>なければならない</em>。
</p>

<p>
last-byte-pos 値が無い、あるいはその値が現在のエンティティボディの大きさ以上であったら、last-byte-pos はエンティティボディの現在のバイト長から 1 を引いた値になる。
</p>

<p>
クライアントは、自身が指定する last-byte-pos によって、エンティティのサイズを知らなくても受け取るバイト数を制限する事ができる。
</p>

<pre> suffix-byte-range-spec = &quot;-&quot; suffix-length
 suffix-length = 1*DIGIT
</pre>

<p>
suffix-byte-range-spec は、エンティティボディの、suffix-length 値によって与えられる長さの末尾を指定するのに使われる。
(すなわち、この形式ではエンティティボディの最後の N バイトを指定する。)
もしエンティティが指定された suffix-length 以下の長さしかなければ、エンティティ全体が使われる。
</p>

<p>
構文上不正な byte-range-set が、first-byte-pos が現在のエンティティボディ長よりも小さいような byte-range-spec、あるいは 0 でない suffix-length を持つ suffix-byte-range-spec を一つでも含んでいたら、その byte-range-set は構文を満足する。
そうでない byte-range-set は不正値である。byte-range-set が不正値である場合、サーバは 416 (Requested range not satisfiable) というステータスを持ったレスポンスを返す<em>べきである</em>。
そうで無ければ、サーバはエンティティボディのうち指定された範囲と 206 (Partial Content) というステータスを持ったレスポンスを返す<em>べきである</em>。
</p>

<p>
byte-ranges-specifier 値の例を示す (エンティティボディの大きさを 10000 と仮定する)。
</p>

<ul>
<li>最初の 500 バイト (バイトオフセットは始点・終点を含めて、0-499): <samp>bytes=0-499</samp></li>
<li>次の 500 バイト (バイトオフセットは始点・終点を含めて、500-999): <samp>bytes=500-999</samp></li>
<li>最後の 500 バイト (バイトオフセットは始点・終点を含めて、9500-9999) : <samp>bytes=-500</samp></li>
<li>あるいは <samp>bytes=9500-</samp></li>
<li>最初と最後の 1 バイト (バイトオフセットは 0 と 9999) : <samp>bytes=0-0,-1</samp></li>
<li>間違いではないが一般的ではない次の 500 バイトの指定方法 (バイトオフセットは始点・終点を含めて、500-999) :<br />
 <samp>bytes=500-600,601-999</samp><br />
 <samp>bytes=500-700,601-999</samp></li>
</ul>

<h4 id="section-14.35.2">14.35.2 レンジ更新リクエスト</h4>

<p>
条件付き、あるいは条件の付かない GET メソッドを使った HTTP 検索リクエストは Range リクエストヘッダを使って、エンティティ全体の代わりに、エンティティの一つ以上の sub-range を要求<em>でき</em>、リクエストの結果として返されるエンティティに当たる。
</p>

<pre> Range = &quot;Range&quot; &quot;:&quot; ranges-specifier
</pre>

<p>
サーバは、Range ヘッダを無視<em>できる</em>。
しかし、Range をサポートする事で転送に失敗した部分の再取得や、大きなサイズのエンティティの部分的な検索を効果的にサポートするので、HTTP/1.1 のオリジンサーバや中間キャッシュは、可能であればバイトレンジをサポートすべきである。
</p>

<p>
もし、サーバが Range ヘッダをサポートし、指定される範囲 (群) がそのエンティティに適切であれば、以下の様になる。
</p>

<ul>
<li>条件の付かない GET に Range ヘッダがあった場合、その GET が他の点で成功していれば、返る値が修正される。言いかえると、レスポンスは 200 (OK) の代わりに 206 (Partial Content) というステータスコードを返す。</li>
<li>条件付きの GET (If-Modified-Since と If-None-Match のどちらかあるいは両方、もしくは If-Unmodified-Since と If-Match のどちらかあるいは両方を使ったリクエスト) に Range ヘッダがあった場合、その GET が他の点で成功していて、条件が真であったら、返る値が修正される。もし条件が偽であれば、304 (Not Modified) レスポンスには影響ない。</li>
</ul>

<p>
場合によっては、Range ヘッダに加えて If-Range ヘッダ (section <a href="#section-14.27">14.27</a> 参照) を使う方が適切であるかもしれない。
</p>

<p>
もし、レンジをサポートするプロクシが Range リクエストを受け、そのリクエストをインバウンドサーバに転送し、その返答としてエンティティ全体を受け取ったとしたら、プロクシはクライアントが要求した範囲のみを返す<em>べきである</em>。
もしそれがキャッシュの割り当て方針にあったものであれば、キャッシュには受け取ったレスポンス全体を保存す<em>べきである</em>。
</p>

<h3 id="section-14.36">14.36 Referer</h3>

<p>
Referer[原文ママ] リクエストヘッダフィールド (&quot;referrer&quot; であるはずなのに綴りは間違っているが) は、サーバの利益のために、 Request-URI が得られたリソースのアドレス (URI) をクライアントに示させる。
Referer リクエストヘッダは、サーバが興味やログの取得、キャッシュの活用等のために、そのリソースへの逆リンクのリストを作成できるようにする。
また、メンテナンスのために、既に使用されていない{obsolete} リンクやミスタイプのリンクを追跡できるようにもする。
もし Request-URI が、例えばユーザのキーボードからの入力など、それ自身の URI を持たないソースから得られた場合は、Referer フィールドを送っ<em>てはならない</em>。
</p>

<pre> Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )
</pre>

<p>
例を示す。
</p>

<pre> <samp>Referer: http://www.w3.org/hypertext/DataSources/Overview.html</samp>
</pre>

<p>
もしこのフィールド値が相対 URI ならば、 Request-URI からの相対的なものと解釈す<em>べきである</em>。
URI にはフラグメントを含め<em>てはならない</em>。
セキュリティ上の考察については、section <a href="#section-15.1.3">15.1.3</a> 参照。
</p>

<h3 id="section-14.37">14.37 Retry-After</h3>

<p>
Retry-After レスポンスヘッダフィールドは、リクエストしているクライアントにそのサービスがどのくらいの時間利用不可能なのかを示すために、503 (Service Unavailable) レスポンスと共に使われる。
また、このフィールドはリダイレクトされたリクエストが発行される前にユーザエージェントが待たなければならない最小の時間を示すために 3xx (Redirection) レスポンスで使う事も<em>できる</em>。
このフィールドの値は、HTTP-date か、あるいはレスポンス時以降の整数の (10進数の) 秒数である。
</p>

<pre> Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )</pre>

<p>
次の二つの使用例を見よ。
</p>

<pre> <samp>Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
 Retry-After: 120</samp>
</pre>

<p>
後者の場合、その遅れは 2 分である。
</p>

<h3 id="section-14.38">14.38 Server</h3>

<p>
Server レスポンスヘッダフィールドは、リクエストを処理するオリジンサーバが使っているソフトウェアについての情報を含んでいる。
このフィールドには、複数の製品トークン (section <a href="#section-3.8">3.8</a>) や、サーバとその他の重要な付属製品を識別するためのコメントを含める事ができる。
製品トークンは、アプリケーションを識別するために重要な順に列挙される。
</p>

<pre> Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )</pre>

<p>
例を見よ。
</p>

<pre> <samp>Server: CERN/3.0 libwww/2.17</samp></pre>

<p>
レスポンスがプロクシを通して送られた場合、プロクシアプリケーションは Server レスポンスヘッダを書き換え<em>てはならない</em>。
代わりに、 (section <a href="#section-14.45">14.45</a> に記述されている) Via フィールドを使う<em>べきである</em>。
</p>

<p class="note">
注: サーバのソフトウェアバージョンを明らかにする事で、セキュリティホールを持っている事がわかっているソフトウェアを使うサーバのマシンは攻撃を受けやすくなるかもしれない。
サーバの開発者は、このフィールドをオプションとして設定を変更できるようにする事が推奨される。
</p>

<h3 id="section-14.39">14.39 TE</h3>

<p>
TE リクエストヘッダフィールドは、レスポンスとしてどんな拡張転送コーディングを受け入れられるか、またチャンク形式転送コーディング内の trailer フィールドを受け入れられるかどうかを示す。
この値は、&quot;trailers&quot; というキーワードや、 (section <a href="#section-3.6">3.6</a> にて定義される) 拡張転送コーディングの名前と省略可能な受け入れパラメータをコンマで区切ったリストからなるだろう。
</p>

<pre> TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
 t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )
</pre>

<p>
&quot;trailers&quot; というキーワードがあれば、section <a href="#section-3.6.1">3.6.1</a> にて定義されるように、クライアントはチャンク形式転送コーディング内の trailer フィールドを受け入れられる、という事を表す。
このキーワードは、たとえクライアントが転送コーディングを表せないとしても、転送コーディング値を使うために予約される。
</p>

<p>
その使用例は以下のようになる。
</p>

<pre> <samp>TE: deflate
 TE:
 TE: trailers, deflate;q=0.5</samp>
</pre>

<p>
TE ヘッダフィールドは、直接の接続にのみ適用される。
それゆえ、TE が HTTP/1.1 メッセージに存在する時は常に、このキーワードを Connection ヘッダフィールド (section <a href="#section-14.10">14.10</a>) の中に与え<em>なければならない</em>。
</p>

<p>
サーバは、TE フィールドによって与えられた転送コーディングが受け入れ可能かを試すために、以下の規則を使う事ができる。
</p>

<ol>
<li>
<p>
&quot;chunked&quot; 転送コーディングは常に受け入れ可能である。&quot;trailers&quot; というキーワードが列挙されていれば、クライアントは、自身やダウンストリームのクライアントがチャンク形式のレスポンス中の trailer フィールドを受け入れ可能である、という事を示す。このフィールドが与えられた場合、クライアントは、すべてのダウンストリームクライアントは転送されるレスポンス中の trailer フィールドを受け入れ可能であるか、あるいはダウンストリームの受信者のためにレスポンスをバッファしようとしているか、のどちらかを示している事を意味する。
</p>
<p class="note">
注: HTTP/1.1 は、クライアントがレスポンス全体のバッファリング
を保証できるようなチャンク形式レスポンスのサイズの制限するため
の手段を定義しない。
</p>
</li>
<li>
<p>現在試している転送コーディングが TE フィールド内に列挙されている転送コーディングの一つで、その qvalue が 0 でなければ、受け入れ可能である。
(section <a href="#section-3.9">3.9</a> にて定義されるように、qvalue が 0 であるという事は、&quot;受け入れ不可能&quot; を意味する。)
</p>
</li>
<li>
<p>
複数の転送コーディングが受け入れ可能である時は、qvalue が 0 以上で最も大きい値を持つ転送コーディングが優先される。&quot;chunked&quot; 転送コーディングの qvalue は常に 1 である。
</p>
</li>
</ol>

<p>
TE フィールド値が空か、あるいは TE フィールドが与えられていなければ、使用できる転送コーディングは &quot;chunked&quot; のみとなる。
転送コーディングがなされていないメッセージは、常に受け入れ可能である。
</p>

<h3 id="section-14.40">14.40 Trailer</h3>

<p>
Trailer 一般フィールドの値は、その中で与えられたヘッダフィールドのセットがチャンク形式転送コーディングにてエンコードされたメッセージの後につけられるもの{trailer} の中に含まれている事を表す。
</p>

<pre> Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name
</pre>

<p>
HTTP/1.1 のメッセージは、チャンク形式転送コーディングされ空ではない trailer を持っているメッセージ中では Trailer ヘッダフィールドを含む<em>べきである</em>。そうする事で、受信者は trailer の中にどんなヘッダフィ
ールドがあるかを知る事ができる。
</p>

<p>
Trailer ヘッダフィールドがなければ、trailer はいかなるヘッダフィールドも含む<em>べきではない</em>。
&quot;chunked&quot; 転送コーディング中の trailer フィールドの使用の制限については、section <a href="#section-3.6.1">3.6.1</a> 参照。
</p>

<p>
Trailer ヘッダフィールド中に列挙されるメッセージヘッダフィールドには以下のヘッダフィールドを含め<em>てはならない</em>。
</p>

<ul>
<li>Transfer-Encoding</li>
<li>Content-Length</li>
<li>Trailer</li>
</ul>

<h3 id="section-14.41">14.41 Transfer-Encoding</h3>

<p>
Tranfer-Encoding 一般ヘッダフィールドは、 (もし変形がなされていれば)送信者と受信者の間でメッセージボディを安全に転送するために、適用されている変形の形を示す。
転送コーディングというのは、メッセージの特性であり、エンティティの特性では無い、という点で内容コーディングとは異なる。
</p>

<pre> Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding
</pre>

<p>
転送コーディングは section <a href="#section-3.6">3.6</a> にて定義される。例を見よ。
</p>

<pre> <samp>Transfer-Encoding: chunked</samp>
</pre>

<p>
もしエンティティに複数のエンコーディングが適用されていたら、適用されている順番に列挙し<em>なければならない</em>。
エンコーディングパラメータについての追加的情報は、この仕様書に定義されていない他のエンティティヘッダフィールドによって与える事が<em>できる</em>。
</p>

<p>
多くの古い HTTP/1.0 アプリケーションは、Transfer-Encoding ヘッダを理解しない。
</p>

<h3 id="section-14.42">14.42 Upgrade</h3>

<p>
Upgrade 一般ヘッダは、クライアントが他にどんな通信プロトコルをサポートするかを表し、サーバがプロトコルを切り換えた方がいいと判断した場合に使わせたいものを指定させる。
サーバは、Upgrade ヘッダフィールドをプロトコルが切り換えられた事を示す 101 (Switching Protocols) レスポンスの中で使わ<em>なければならない</em>。
</p>

<pre> Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product</pre>

<p>
例を見よ。
</p>

<pre> <samp>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</samp></pre>

<p>
Upgrade ヘッダフィールドは、HTTP/1.1 からある他の、互換性が無いプロトコルへの変換のための単純なメカニズムを提供する事を目的としている。
これは、クライアントがたとえ現在のリクエストが HTTP/1.1 を使って作られたものであっても、例えばより大きなメジャーバージョン番号を持つ新しいバージョンの HTTP のような、他のプロトコルを使いたいという要求をした場合に変換が行われる。
これは、クライアントがもしそれが利用できれば &quot;よりよい&quot; プロトコルを使用したいという事をサーバに示している間に、より一般的にサポートされるプロトコルでリクエストを開始させる事で、互換性の無い互いのプロトコル間の難しい変換を簡単にする (ここでの &quot;よりよい&quot; とは、リクエストされているメソッドやリソースの性質に応じて、サーバが決定する)。
</p>

<p>
Upgrade ヘッダフィールドは、現在のトランスポート層にある接続上のアプリケーション層プロトコルの切り替えにのみ適用される。
Upgrade は、プロトコルの変換を強要する事はできない。
すなわち、サーバがこのフィールドを受け入れるか、それをどう使うかはサーバによる。
プロトコル変換後の最初の動作は Upgrade ヘッダフィールドを含む最初の HTTP リクエストへのレスポンスで<em>なければならない</em>が、プロトコルの変換後のアプリケーション層の通信能力とその性質は完全に選択された新しいプロトコルに依存する。
</p>

<p>
Upgrade ヘッダフィールドは、直接の接続にのみ適用される。
それゆえ、Upgrade が HTTP/1.1 メッセージに存在する時は常に、upgrade というキーワードを Connection ヘッダフィールド (section <a href="#section-14.10">14.10</a>) の中に与え<em>なければならない</em>。
</p>

<p>
Upgrade ヘッダフィールドは、異なる接続でプロトコルを変換するために使う事はできない。
この場合、301, 302, 303, 305 のいずれかのリダイレクションレスポンスを使う方が適切である。
</p>

<p>
この仕様書では、section <a href="#section-3.1">3.1</a> の HTTP バーションの規則と将来更新されるこの仕様書に定義されるように、ハイパーテキスト転送プロトコルのファミリーとして使用するための &quot;HTTP&quot; というプロトコル名のみを定義する。
プロトコル名としてはあらゆるトークンが使用できるが、クライアントとサーバの両方がその名前で同じプロトコルを関連付けている場合のみそれが有効となるであろう。
</p>

<h3 id="section-14.43">14.43 User-Agent</h3>

<p>
User-Agent リクエストヘッダフィールドは、リクエストを生成したユーザエージェントについての情報を含む。
これは、統計目的、プロトコル違反の追跡、特定のユーザエージェントの制限を回避するようなレスポンスを作成するためのユーザエージェントの自動認識のために使う。
ユーザエージェントは、リクエストの際にこのヘッダを含む<em>べきである</em>。
このフィールドには、複数の製品トークン (section <a href="#section-3.8">3.8</a>) や、エージェントやユーザエージェントの重要な付属製品を識別するためのコメントを含める事ができる。
慣習によれば、製品トークンはアプリケーションを識別するために重要な順に列挙される。
</p>

<pre> User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )</pre>

<p>
例を見よ。
</p>

<pre> <samp>User-Agent: CERN-LineMode/2.15 libwww/2.17b3</samp></pre>

<h3 id="section-14.44">14.44 Vary</h3>

<p>
Vary フィールド値は、そのレスポンスが新鮮である{fresh} 間、キャッシュが再検証無しにそれに続くリクエストに対するレスポンスとして使ってよいかどうかを、完全に決定するためのリクエストヘッダフィールドのセットを示す。
キャッシュできない、あるいは新鮮でなくなった{stale} レスポンスの場合、Vary フィールド値はユーザエージェントにその表現を選択するために使われた基準{criteria} について通知するために使われる。
&quot;*&quot; という Vary フィールド値は、キャッシュはこのレスポンスが適切な表現であるかどうかをそれに続くリクエストのリクエストヘッダからは決定できない、という事を意味する。
キャッシュにおける Vary ヘッダフィールドの使い方については section <a href="#section-13.6">13.6</a> 参照。
</p>

<pre> Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )</pre>

<p>
HTTP/1.1 サーバは、サーバ駆動型ネゴシエーションを受けるあらゆるキャッシュ可能なレスポンスに Vary ヘッダフィールド値を含む<em>べきである</em>。
そうする事で、キャッシュはそのリソースへの将来のリクエストを適切に解釈する事ができ、ユーザエージェントにそのリソースへのネゴシエーションの存在について知らせる事ができる。
サーバは、サーバ駆動型ネゴシエーションを受けるキャッシュ不可能なレスポンスにも、ユーザエージェントにそのレスポンス時には変化してしまうレスポンスのについての有益な情報を提供するであろうから、Vary ヘッダフィールド値を含む事が<em>できる</em>。
</p>

<p>
Vary フィールド値は、最もふさわしい表現を選択するために列挙されたリクエストヘッダフィールド値<em>のみ</em>を考慮する選択アルゴリズムに従ってレスポンスとして選択された表現を知らせる field-name の列挙から成る。
キャッシュは、そのレスポンスが新鮮である間は、列挙されるフィールド名に同じフィールド値を取るような将来のリクエストでも同じ選択がなされるであろう、と仮定する事が<em>できる</em>。
</p>

<p>
与えられる field-name は、この仕様書にて定義されている標準のリクエストヘッダフィールドに制限されない。
フィールド名は、大文字・小文字を区別しない。
</p>

<p>
&quot;*&quot; という Vary フィールド値は、指定されていないパラメータはリクエストヘッダに制限されないという事を示し (例えば、クライアントのネットワークアドレス) 、レスポンスの表現の選択において役割を果たす。
プロクシサーバは、&quot;*&quot; という値を生成し<em>てはならない</em>。
それは生成できるのはオリジンサーバのみである。
</p>

<h3 id="section-14.45">14.45 Via</h3>

<p>
Via 一般ヘッダフィールドは、リクエスト時におけるユーザエージェントからサーバ間の、またレスポンス時におけるオリジンサーバからユーザエージェント間の、中間のプロトコルと受信者を示すためにゲートウェイやプロクシによって使われ<em>なければならない</em>。
これは、RFC 822 <a href="#ref-9">[9]</a> での &quot;Received&quot; フィールドに類似しており、転送されるメッセージを追跡したり、リクエストループを回避したり、リクエスト/レスポンス連鎖上のすべての送信者のプロトコル能力を識別したりする意図を持つ。
</p>

<pre> Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
 received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
 protocol-name     = token
 protocol-version  = token
 received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
 pseudonym         = token
</pre>

<p>
received-protocol は、リクエスト/レスポンス連鎖上の各セグメントでサーバやクライアントから受けたメッセージのプロトコルバージョンを表す。
received-protocol のバージョンは、アップストリームのアプリケーションのプロトコル能力についての情報がすべての受信者に見えるようにするために、メッセージの転送時に Via フィールドに添えられる。
</p>

<p>
protocol-name は、&quot;HTTP&quot; である場合のみ省略可能となる。
received-by フィールドは通常、その後メッセージを転送した受信サーバやクライアントのホストと省略可能なポート番号である。
しかし、本当のホスト名が取り扱いに慎重を要する情報であるとみなされるのであれば、偽名に置き換える事が<em>できる</em>。
ポート名が与えられなければ、received-protocol の既定ポートであるとみなして<em>よい</em>。
</p>

<p>
複数の Via フィールド値は、それぞれがメッセージを転送したプロクシやゲートウェイを表す。
それぞれの受信者は、その結果がアプリケーションを転送する順序になるように末尾に自身の情報を付加し<em>なければならない</em>。
</p>

<p>
コメントは、User-Agent や Server 各ヘッダフィールドと同様に、受信プロクシやゲートウェイソフトウェアを識別するために Via ヘッダフィールド内で使う事が<em>できる</em>。
しかし、Via フィールド内のすべてのコメントは省略可能であり、他の受信者はそのメッセージを転送する前にそれを削除する事が<em>できる</em>。
</p>

<p>
例えば、リクエストメッセージが HTTP/1.0 ユーザエージェントから &quot;fred&quot; というコードネームの内部プロクシに送られ、これが HTTP/1.1 を使って nowhere.com にある公衆プロクシにリクエストを転送し、最後に www.ics.uci.edu というオリジンサーバにリクエストを転送する事で完了する場合を考える。
www.ics.uci.edu が受けるリクエストは、次のような Via ヘッダフィールドを持っているだろう。
</p>

<pre> <samp>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</samp></pre>

<p>
ネットワークファイアウォールへの入り口として使われるプロクシやゲートウェイは、既定では、ファイアウォール域内部のホスト名やポート番号を転送す<em>べきではない</em>。
この情報は、明示的に許可された場合にのみ伝えられる<em>べきである</em>。
許可されなければ、ファイアウォール内のあらゆるホストの received-by は、適当な偽名に置き換えられる<em>べきである</em>。
</p>

<p>
内部構造の守秘に関して強いプライバシー要求を持つ組織では、プロクシは同一の received-protocol 値を持つ連続した Via ヘッダフィールドエントリを一つのエントリに連結する事が<em>できる</em>。
次の例を見よ。
</p>

<pre> <samp>Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy</samp></pre>

<p>
これは次のようにまとめられる。
</p>

<pre> <samp>Via: 1.0 ricky, 1.1 mertz, 1.0 lucy</samp></pre>

<p>
アプリケーションは、それらがすべて同じ組織コントロール化にあって、ホスト名が既に偽名に置き換えられている場合以外には、複数のエントリを連結す<em>べきではない</em>。
アプリケーションは、異なる received-protocol 値を持つエントリを連結し<em>てはならない</em>。
</p>

<h3 id="section-14.46">14.46 Warning</h3>

<p>
Warning 一般ヘッダフィールドは、そのメッセージ中には反映されないであろうステータスやメッセージの変化についての付加的情報を伝えるために使われる。
この情報は、キャッシュの処理やメッセージのエンティティボディに適用される変化から意味的透過性が欠けている可能性がある事を警告するために定型的に使われる。
</p>

<p>
Warning ヘッダは、以下のような形式を使ってレスポンスと共に送られる。
</p>

<pre> Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

 warning-value = warn-code SP warn-agent SP warn-text
                                       [SP warn-date]

 warn-code  = 3DIGIT
 warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                 ; the name or pseudonym of the server adding
                 ; the Warning header, for use in debugging
 warn-text  = quoted-string
 warn-date  = &lt;&quot;&gt; HTTP-date &lt;&quot;&gt;
</pre>

<p>
レスポンスでは、複数の Warning ヘッダを転送する事が<em>できる</em>。
</p>

<p>
warn-text は、レスポンスを受けとる人間ユーザが最も理解できそうな自然言語と文字セットである<em>べきである</em>。
これはあらゆる利用できる情報、例えばキャッシュやユーザの場所、リクエスト中の Accept-Language フィールド、レスポンス中の Content-Language フィールド等に基づいて決定する事が<em>できる</em>。
既定言語は英語であり、文字セットは ISO-8859-1 である。
</p>

<p>
ISO-8859-1 以外の文字セットが使われる場合は、RFC 2047 <a href="#ref-14">[14]</a> にて記述される方法を用いて warn-text 内でエンコードし<em>なければならない</em>。
</p>

<p>
Warning ヘッダは一般にどんなメッセージにも適用する事ができるが、中には特定のキャッシュについて言及している warn-code もあり、それについてはレスポンスメッセージにのみ適用できる。
新しい Warning ヘッダは、既存の Warning ヘッダの後に追加される<em>べきである</em>。
キャッシュは、メッセージと共に受け取ったどんな Warning ヘッダも消去し<em>てはならない</em>。
しかし、キャッシュがキャッシュエントリの検証に成功した場合、特定の Warning コードに指定されているもので無ければ、前もってエントリに付加されていた Warning ヘッダを消去す<em>べきである</em>。
そして、そこに検証した時のレスポンスで受け取ったあらゆる Warning ヘッダを付け加え<em>なければならない</em>。
言い換えれば、Warning ヘッダは最新の適切なレスポンスに加
えられるものなのである。
</p>

<p>
レスポンスに複数の Warning ヘッダが付加されている時は、ユーザエージェントは、レスポンス中に現れた順序に従って、できるだけたくさんユーザに表示すべきである。
すべての警告を表示できない場合、ユーザエージェントは以下の規則に従う<em>べきである</em>。
</p>

<ul>
<li>レスポンス中に先に現れた Warning は、後に現れたものよりも優先される。</li>
<li>ユーザが指定した文字セットの Warning は、同一の warn-code や warn-agent で無ければ他の文字セットのものよりも優先される。</li>
</ul>

<p>
複数の Warning ヘッダを生成するシステムでは、このユーザエージェントの振る舞いに気をつけて、ヘッダを並べる<em>べきである</em>。
</p>

<p>
Warning を尊重するキャッシュの振る舞いの必要条件は、section <a href="#section-13.1.2">13.1.2</a> にて述べられている。
</p>

<p>
以下は、現在定義されている warn-code の一覧と、それぞれに英語での推奨される warn-text をつけて、その意味について記述したものである。
</p>

<dl>
<dt>110 Response is stale</dt>
<dd>返されるレスポンスが新鮮で無い場合は常にこれを含ま<em>なければならない</em>。</dd>
<dt>111 Revalidation failed</dt>
<dd>キャッシュがサーバに到達できないという理由で、レスポンスの再検証に失敗して古いレスポンスを返すという場合はこれを含ま<em>なければならない</em>。</dd>
<dt>112 Disconnected operation</dt>
<dd>キャッシュが一定の期間にネットワークから故意に切断される場合はこれを含む<em>べきである</em>。</dd>
<dt>113 Heuristic expiration</dt>
<dd>キャッシュが有効期限を 24 時間以上に設定している時にそのレスポンスの経過時間が 24 時間以上である場合はこれを含ま<em>なければならない</em>。</dd>
<dt>199 Miscellaneous warning</dt>
<dd>この警告文には、それを人間ユーザに表示、記録させるために独自の情報を含む事が<em>できる</em>。この警告を受けたシステムは、警告をユーザに表示する以外には、どんな自動的なアクションも起こし<em>てはならない</em>。</dd>
<dt>214 Transformation applied</dt>
<dd>(Content-Encoding ヘッダにて指定されるような) 内容コーディング、レスポンスの (Content-Type ヘッダにて指定されるような) メディアタイプ、あるいはレスポンスのエンティティボディになんらかの変形が施される時に、すでにそのレスポンスにこの Wanring コードが与えられている場合以外は、これが中間のキャッシュかプロクシによって追加され<em>なければならない</em>。</dd>
<dt>299 Miscellaneous persistent warning</dt>
<dd>この警告文には、それを人間ユーザに表示、記録させるために独自の情報を含む事が<em>できる</em>。この警告を受けたシステムは、どんな自動的なアクションも起こし<em>てはならない</em>。</dd>
</dl>

<p>
もし実装が HTTP/1.0 以下のバージョンの一つ以上の Warning ヘッダを持ったメッセージを送ったならば、送信者はそれぞれの warning-value にレスポンスの時刻に一致する warn-date を含ま<em>なければならない</em>。
</p>

<p>
もし実装が warn-date 付きの warning-value を持つメッセージを受け取り、その warn-date がレスポンス中の Date 値と異なっていたとしたら、それを保存、転送、使用する前にメッセージからその warning-value を消去し<em>なければならない</em>。
(これは、無用心なキャッシュが Warning ヘッダフィールドを処理した時に好ましくない結果を引き起こす事を防止する。)
この理由によりすべての warning-value が消去されたならば、同様にして Waning ヘッダも消去され<em>なければならない</em>。
</p>

<h3 id="section-14.47">14.47 WWW-Authenticate</h3>

<p>
WWW-Authenticate レスポンスヘッダフィールドは、401 (Unauthorized) レスポンスメッセージ中に含まれてい<em>なければならない</em>。
このフィールド値は、その Request-URI に適用できる認証スキームとパラメータを示す最低一つの challenge から成る。
</p>

<pre> WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge
</pre>

<p>
HTTP アクセス認証処理方法については、&quot;HTTP Authentication: Basic and Digest Access Authentication&quot; <a href="#ref-43">[43]</a> にて記述されている。
ユーザエージェントは、それが複数の challenge を含んでいる、あるいは複数の WWW-Authenticate ヘッダフィールドを含んでいても、challenge の内容にコンマで分けられた認証パラメータのリストを含んでいるかもしれないので、WWW-Authenticate フィールド値を解析するのには特別な注意を払うべきである。
</p>

<h2 id="section-15">15 セキュリティについての考察</h2>

<p>
この章はアプリケーション開発者、情報提供者、そしてユーザにこの文書で記述されているような HTTP/1.1 のセキュリティ限界を知らせるという意図を持つ。
このディスカッションでは明示される問題の決定的な解決方法を含んでいないが、セキュリティリスクを減らすためのいくつかの提案を行っている。
</p>

<h3 id="section-15.1">15.1 個人情報</h3>

<p>
HTTP クライアントはしばしば多くの量の個人情報 (例えばユーザの名前、場所、メールアドレス、パスワード、暗号キー、等々) を管理しているので、この情報を HTTP プロトコル経由で他のリソースへと知らないうちに漏洩していないように特に気をつける<em>べきである</em>。
我々は、ユーザがそのような情報の公開についてを制御するための便利なインタフェースが提供される事と、設計者や実装者はこの部分を特に注意する事を特に強く推奨する。
歴史的に、この部分のエラーがしばしば深刻なセキュリティやプライバシー問題を引き起こし、その結果実装者の会社に対して不利な評判を高めている。
</p>

<h4 id="section-15.1.1">15.1.1 サーバログ情報の乱用</h4>

<p>
サーバは、読み込みの傾向や興味の対象で識別されるであろうユーザのリクエストについての個人情報を保存する立場にある。
この情報は本質的に明らかに秘密であり、その扱いは国によっては法によって統制されているであろう。
データを供給するために HTTP プロトコルを使用している人々は、そのようなデータは発行された結果、身元がわかってしまうその個人の許可無しには配布されないという事を保証しなければならない。
</p>

<h4 id="section-15.1.2">15.1.2 機密性の高い情報の転送</h4>

<p>
一般的なデータ転送プロトコルと同様に、HTTP は転送されるデータの内容を規制する事はできないし、与えられるリクエストの状況の中でその情報の特定の部分の機密性を決定するためのどんな優先的方法もない。
それ故に、アプリケーションはこの情報の供給者にできるだけ多くこの情報の制御機能を供給す<em>べきである</em>。
この状況において特に言及の価値がある四つのヘッダフィールドが Server, Via, Referer, From である。
</p>

<p>
サーバの具体的なソフトウェアのバージョンを示す事によって、サーバマシンはあるセキュリティホールが知られているソフトウェアに対するアタックを受けやすくなるかもしれない。
実装者は、Server ヘッダフィールドを設定可能なオプションとす<em>べきである</em>。
</p>

<p>
ネットワークファイアウォールの入口の役割を果たすプロクシは、ファイアウォールの内側にあるホストを識別するヘッダ情報の転送について特に用心す<em>べきである</em>。
特に、ファイアウォールの内側で生成されたすべての Via フィールドは削除するか安全なものに置き換える<em>べきである</em>。
</p>

<p>
Referer ヘッダは、読み込み傾向を調査したりやリンクの逆引きをできるようにさせる。
これはとても有用であるが、もしユーザの詳細が Referer に含まれる情報から分けられていなければ、その力は悪用されうる。
さらに個人情報が既に削除されていても、Referer ヘッダは公表が不適当であろうプライベート文書の URI を示すかもしれない。
</p>

<p>
From フィールドで送られる情報はユーザのプライバシー観念やサイトのセキュリティポリシーに反するかもしれないので、ユーザがそのフィールドの値を無効、有効、変更ができないのであれば転送される<em>べきではない</em>。
ユーザは、ユーザ設定やアプリケーションの初期設定においてこのフィールドの内容をセットでき<em>なければならない</em>。
</p>

<p>
必ずというわけではないが、我々はユーザが From と Referer 情報の送信を有効、無効にできるようにする便利なトグルインターフェースを提案する。
</p>

<p>
User-Agent (section <a href="#section-14.43">14.43</a>) や Server (section <a href="#section-14.38">14.38</a>) ヘッダフィールドは、時々そのクライアントやサーバが搾取{exploit} 可能な特定のセキュリティホールを持っているという事を判別するために使われる。
不幸な事に、この同じ情報は現在の HTTP ではそれ以上の仕組みを持たない他の貴重な目的にもしばしば使われる。
</p>

<h4 id="section-15.1.3">15.1.3 URI での機密性の高い情報のエンコード</h4>

<p>
リンクのソースがプライベートな情報、あるいは他のプライベートな情報のソースを明らかにしてしまうかもしれないので、ユーザが Referer フィールドを送信するかどうかを選択出来るようにする事を強く推奨する。
例えば、ブラウザクライアントは公然に/匿名にブラウジングするためのトグルスイッチを持ち、Referer や From の各情報の送信をそれぞれ有効/無効とできる。
</p>

<p>
クライアントは、参照されるページがセキュアプロトコルで転送された場合は、(セキュアで無い) HTTP リクエストに Referer ヘッダフィールドを含む<em>べきではない</em>。
</p>

<p>
HTTP プロトコルを使うサービスの作者は、その Request-URI にエンコードされたデータが現れるので、機密性の高いデータの提出に GET を使ったフォームを使う<em>べきではない</em>。
多くの現存のサーバやプロクシ、ユーザエージェントは、第三者が見るかもしれない場所にその Request-URI を記録するだろう。
サーバは、代わりに POST を使ったフォームを使うべきである。
</p>

<h4 id="section-15.1.4">15.1.4 Accept ヘッダに関連するプライバシーの問題</h4>

<p>
Accept リクエストヘッダは、アクセスされたすべてのサーバにユーザに関する情報を表す事ができる。
特に Accept-Language ヘッダは、特定の言語を理解するという事がしばしば特定の民族グループの一員である事と強く関連付けられているため、個人的な性質であるとみなすであろう情報を表す。
リクエスト毎に送られる Accept-Language ヘッダの内容を設定するためのオプションを提供するユーザエージェントは、設定のプロセス中にそれがユーザのプライバシーの損失になるという事に気づかせるようなメッセージを含むようにする事が強く推奨される。</p>

<p>
プライバシーの損失をより制限するためには、ユーザエージェントが既定では Accept-Language ヘッダを送信しないようにし、サーバによって生成された Vary レスポンスヘッダフィールドを見つけ、その送信によってサービスの品質を向上できるとわかった場合に、サーバに Accept-Language ヘッダを送る事を開始するどうかをユーザに尋ねるようにする。
</p>

<p>
ユーザによって設定された詳細な Accept ヘッダフィールドがリクエストごとに送られ、特にそれらが品質値を含んでいたら、比較的信頼でき長い間住んでいる{long-lived} ユーザを識別するものとしてサーバによって使われうる。
そのようなユーザを識別するものは、内容供給者がクリックの追跡{click-trail tracking} をできるようにし、共同で作業する内容供給者が個々のユーザのサーバ越しのクリックの追跡{cross-server click-trail} やフォーム提出と一致できるようにする。
プロクシの内側でない多くのユーザにとって、ユーザエージェントが実行されているホストのネットワークアドレスも長く住んでいる{long-lived} ユーザを識別するものとして役に立つという事に注意せよ。
プロクシがプライバシーを高めるために使用されている環境においては、ユーザエージェントはエンドユーザに accept ヘッダコンフィギュレーションオプションを提供する事には保守的であるべきである。
極端なプライバシー手段として、プロクシは中継されたリクエストにおける accept ヘッダをフィルタできる。
高いヘッダ設定機能を供給する一般的な目的のユーザエージェントは、伴う可能性のあるプライバシーの損失に関してユーザに警告す<em>べきである</em>。
</p>

<h3 id="section-15.2">15.2 ファイル名やパス名に基づく攻撃</h3>

<p>
HTTP オリジンサーバの実装は、HTTP リクエストによって返される文書はサーバ管理者によって意図されたものだけに制限するように注意す<em>べきである</em>。
HTTP サーバがファイルシステムコールを含む HTTP URI を直接解釈する場合、サーバは HTTP クライアントへの配信を意図しないファイルを送信しないように特に注意を払わ<em>なければならない</em>。
例えば、UNIX や Microsoft Windows や他のオペレーティングシステムはカレントディレクトリの上の階層のディレクトリを表すパス要素として &quot;..&quot; を使う。
そのようなシステムにおいては、HTTP サーバ経由でアクセス可能である事が意図されている外部リソースへのアクセスが別の方法で許されている場合、HTTP サーバは  Request-URI 中にそのような構造のものを許し<em>てはならない</em>。
同様に、サーバ内部でのみでの参照が意図されたファイル (アクセス制御ファイル、設定ファイル、スクリプトコード等) は、機密性の高い情報を含んでいるので、不適当な検索から保護され<em>なければならない</em>。
経験的に、そのような HTTP サーバ実装の小さなバグがセキュリティリスクになっている。
</p>

<h3 id="section-15.3">15.3 DNS スプーフィング</h3>

<p>
HTTP を使用しているクライアントは Domain Name Service に非常に頼っており、従って一般的に IP アドレスと DNS 名の故意なる間違った組み合わせをベースとしたセキュリティアタックが行われる傾向にある。
クライアントは、IP アドレス/DNS 名の組み合わせの正当性の連続についての仮定にて注意深くある必要がある。
</p>

<p>
特に、HTTP クライアントは前回のホスト名 lookup の結果のキャッシュよりも、IP アドレス/DNS 名組み合わせの確認についてはそのネームリゾルバを頼る<em>べきである</em>。
多くのプラットフォームは適切な時期に既にローカルにホスト名 lookup をキャッシュできるので、そうするように設定す<em>べきである</em>。
しかし、これらの lookup はネームサーバによって報告された TTL (Time To Live) 情報がキャッシュされた情報がおそらく有効であるであろうとした時にのみキャッシュされるのが適切である。
</p>

<p>
もし HTTP クライアントがパフォーマンスを改善させるためにホスト名 lookup の結果をキャッシュするなら、DNS によって報告される TTL 情報を監視し<em>なければならない</em>。
</p>

<p>
もし HTTP クライアントがこの規定を守らないと、それらは直前にアクセスしたサーバの IP アドレスが変更された時にだまされる。
ネットワークの数値再割り当てがますます一般的になってくる事が予想されるため <a href="#ref-24">[24]</a>、この形式のアタックの可能性は高くなる。
従って、この要求を監視する事によってこの潜在的なセキュリティの弱さを減らす。
</p>

<p>
また、この要求は同じ DNS 名を使用している複製されたサーバに対してクライアントのロードバランシング{load-balancing} 動作を改善し、この作戦を使うサイトをアクセスした場合にユーザが直面する失敗の可能性を減らす。
</p>

<h3 id="section-15.4">15.4 Location ヘッダとスプーフィング</h3>

<p>
もし単一のサーバがお互いを信頼していない複数の組織をサポートするならば、権限を持っていないところでリソースを無効にしないようにと気をつけるため、示された組織の制御の元で生成されたレスポンスの Location ヘッダと Content-Location ヘッダの値をチェックし<em>なければならない</em>。
</p>

<h3 id="section-15.5">15.5 Content-Disposition 問題</h3>

<p>
RFC 1806 <a href="#ref-35">[35]</a> は、HTTP ではしばしば実装されている Content-Disposition ヘッダについてのものだが、これはいくつかの深刻なセキュリティ上の問題を抱えている。
Content-Disposition は HTTP 標準では無いが、広く実装されているので、我々は実装者にその使用法とリスクについて記述している。
詳細については (RFC 1806 を更新した) RFC 2183 <a href="#ref-49">[49]</a> を参照。
</p>

<h3 id="section-15.6">15.6 認証用証明書{credentials} と無配慮なクライアント</h3>

<p>
現存の HTTP クライアントやユーザエージェントは、典型的に認証情報を無期限に保持している。
HTTP/1.1 では、サーバがクライアントこれらのキャッシュされた証明書を破棄させるようにするための方法は提供していない。
これは、HTTP の将来の拡張で要求される重大な欠点である。証明書をキャッシュした状況ではアプリケーションのセキュリティモデルと共にそれに干渉する事ができるが、以下については制限がない。
</p>

<ul>
<li>サーバがクライアントにユーザの証明書の再提出を望んだ後に延長された期間アイドル状態であるクライアント</li>
<li>サーバサイドのアプリケーションがクライアントがこれ以上証明書を保持する理由がないと「知った」後にセッションの終了を示すもの (例えばページの下にある `logout' や `commit' ボタン) を受けたアプリケーション</li>
</ul>

<p>
これは現在切り離され研究されている。
この問題に一部にまつわるものがいくつかあるが、我々はスクリーンセーバへのパスワードプロテクト、アイドル時のタイムアウト、その他この問題が本来持っているセキュリティ問題を軽減するための方法を使用する事を推奨する。
特に、証明書をキャッシュするユーザエージェントにはユーザが簡単にキャッシュされた証明書を破棄を指示できるようなメカニズムを提供する事を推奨する。
</p>

<h3 id="section-15.7">15.7 プロクシとキャッシング</h3>

<p>
その性質から必然的に、HTTP プロクシは人と人の間に入り{men-in-the-middle}、中継者による攻撃{man-in-the-middle attacks} の機会が与えられる。
プロクシが運転されているシステムの妥協{compromise} が深刻なセキュリティとプライバシーの問題を引き起こす。
プロクシはセキュリティに関係した情報、ユーザ個人やその団体についての個別の情報、ユーザやそのプロバイダが所有する所有者情報にアクセスする。
妥協したプロクシや、セキュリティやプライバシーの問題に無関心に実装、形成されたプロクシは、様々な可能性を持つ攻撃に使われる。
</p>

<p>
プロクシのオペレータは、機密性の高い情報を含み、また転送するシステムを守るように、プロクシが運転しているシステムを守るべきである。
特に、プロクシによって集められたログ情報はしばしば特に機密性の高い個人情報や組織情報を含んでいる。
ログ情報は注意深く監視すべきであり、改善や更新のための使用にも適切なガイドラインを設けるべきである。
(section <a href="#section-15.1.1">15.1.1</a>)
</p>

<p>
キャッシングプロクシは、キャッシュの内容が悪意ある利用には魅力的なターゲットを表しているので、潜在的な弱点が付け加えられる。
キャッシュの内容が HTTP リクエストが完了した後もずっと残っているので、キャッシュへのアタックでユーザがその情報はネットワークからは既に削除されたと信じているずっと後にその情報を見る事ができる。
それ故に、キャッシュの内容は機密性の高い情報として守られるべきである。
</p>

<p>
プロクシの実装者は、その設計やコーディングの決定、そしてプロクシオペレータへ提供する設定オプション (特に既定の設定) がプライバシーやセキュリティに関わるという事を考慮すべきである。
</p>

<p>
プロクシのユーザは、プロクシを運転する人間しか信頼する価値のある人はいないという事を知っておく必要がある。
HTTP 自身はこの問題を解決できない。
</p>

<p>
暗号を適切な時に適切に使う事は、広い範囲のセキュリティや個人への攻撃に対しての防御に十分なものとなろう。
このような暗号については HTTP/1.1 の仕様書の範囲を超える。
</p>

<h4 id="section-15.7.1">15.7.1 プロクシを使ったサービス拒否攻撃</h4>

<p>
この攻撃は存在する。この攻撃を防御する事は難しい。調査を続けよ。用心せよ。
</p>

<h2 id="section-16">16 謝辞</h2>

<p>
この仕様書では、RFC 822 <a href="#ref-9">[9]</a> において David H. Crocker によって定義された拡張 BNF と共通概念を多数使用している。
同様に、MIME <a href="#ref-7">[7]</a> において Nathaniel Borenstein と Ned Freed によって与えられた多くの定義を再利用している。
我々は、この仕様書内に含まれる事柄が過去に HTTP とインターネットメールメッセージフォーマットとの間にあった混乱を減らす助けとなって欲しいと願っている。
</p>

<p>
HTTP プロトコルは、1 年でかなり発展した。
これは、大きな、そして活発な www-talk メーリングリストに参加している多くの人々から成る開発者コミュニティのおかげであり、そしてそコミュニティは一般に HTTP や World-Wide Web を成功させるために最も責任のあるコミュニティである。
Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, Marc VanHeyningen 各氏は、このプロトコルの初期の概観を定義したという努力に対して特に評価されるに値する。
</p>

<p>
この文書は、おおいに HTTP-WG に参加するすべての人のコメントのおかげである。
すでに述べた人達の他に、以下の方々がこの仕様書に貢献してくれた。
</p>

<pre> Gary Adams                  Ross Patterson
 Harald Tveit Alvestrand     Albert Lunde
 Keith Ball                  John C. Mallery
 Brian Behlendorf            Jean-Philippe Martin-Flatin
 Paul Burchard               Mitra
 Maurizio Codogno            David Morris
 Mike Cowlishaw              Gavin Nicol
 Roman Czyborra              Bill Perry
 Michael A. Dolan            Jeffrey Perry
 David J. Fiander            Scott Powers
 Alan Freier                 Owen Rees
 Marc Hedlund                Luigi Rizzo
 Greg Herlihy                David Robinson
 Koen Holtman                Marc Salomon
 Alex Hopmann                Rich Salz
 Bob Jernigan                Allan M. Schiffman
 Shel Kaphan                 Jim Seidman
 Rohit Khare                 Chuck Shotton
 John Klensin                Eric W. Sink
 Martijn Koster              Simon E. Spero
 Alexei Kosut                Richard N. Taylor
 David M. Kristol            Robert S. Thau
 Daniel LaLiberte            Bill (BearHeart) Weinman
 Ben Laurie                  Francois Yergeau
 Paul J. Leach               Mary Ellen Zurko
 Daniel DuBois               Josh Cohen
</pre>

<p>
キャッシングのデザインの内容と表現の多くは、以下の方々からの提案とコメントのおかげである:
Shel Kaphan, Paul Leach, Koen Holtman, David Morris, Larry Masinter.
</p>

<p>
レンジの仕様の多くは、元々は Ari Luotonen と John Franks によって行われていたものに基づいており、それに Steve Zilles がいくらか追加したものである。
</p>

<p>
Palo Alto の &quot;洞穴男&quot; に感謝する。
本人ならそれが誰だかわかるはずだ。
</p>

<p>
Jim Gettys (この文書の現在の筆者) は、この文書の前の筆者達である John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, Larry Masinter, および彼らを助けた人達、そして特に Roy Fielding に感謝する。
そして &quot;MUST/MAY/SHOULD&quot; の審査をしてくれた Jeff Mogul と Scott Lawrence も特に感謝する。
</p>

<p>
The Apache Group, Anselm Baird-Smith, Jigsaw の作者, Henrik Frystyk は、RFC 2068 以前のものを実装した。
我々はそれによってこの文書が正そうとしていた多くの問題を発見する事ができたという事を彼らに感謝したい。
</p>

<h2 id="section-17">17 参照文献</h2>

<dl class="references">
<dt id="ref-1">1</dt>
<dd>Alvestrand, H., <cite>Tags for the Identification of Languages</cite>, <a href="http://tools.ietf.org/html/rfc1766">RFC 1766</a>, March 1995.</dd>
<dt id="ref-2">2</dt>
<dd>Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D. and B. Alberti, <cite>The Internet Gopher Protocol (a distributed document search and retrieval protocol)</cite>, <a href="http://tools.ietf.org/html/rfc1436">RFC 1436</a>, March 1993.</dd>
<dt id="ref-3">3</dt>
<dd>Berners-Lee, T., <cite>Universal Resource Identifiers in WWW</cite>, <a href="http://tools.ietf.org/html/rfc1630">RFC 1630</a>, June 1994.</dd>
<dt id="ref-4">4</dt>
<dd>Berners-Lee, T., Masinter, L. and M. McCahill, <cite>Uniform Resource Locators (URL)</cite>, <a href="http://tools.ietf.org/html/rfc1738">RFC 1738</a>, December 1994.</dd>
<dt id="ref-5">5</dt>
<dd>Berners-Lee, T. and D. Connolly, <cite>Hypertext Markup Language - 2.0</cite>, <a href="http://tools.ietf.org/html/rfc1866">RFC 1866</a>, November 1995.</dd>
<dt id="ref-6">6</dt>
<dd>Berners-Lee, T., Fielding, R. and H. Frystyk, <cite>Hypertext Transfer Protocol -- HTTP/1.0</cite>, <a href="http://tools.ietf.org/html/rfc1945">RFC 1945</a>, May 1996.</dd>
<dt id="ref-7">7</dt>
<dd>Freed, N. and N. Borenstein, <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite>, <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>, November 1996.</dd>
<dt id="ref-8">8</dt>
<dd>Braden, R., <cite>Requirements for Internet Hosts -- Communication Layers</cite>, STD 3, <a href="http://tools.ietf.org/html/rfc1123">RFC 1123</a>, October 1989.</dd>
<dt id="ref-9">9</dt>
<dd>Crocker, D., <cite>Standard for The Format of ARPA Internet Text Messages</cite>, STD 11, <a href="http://tools.ietf.org/html/rfc0822">RFC 822</a>, August 1982.</dd>
<dt id="ref-10">10</dt>
<dd>Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J., and M. Grinbaum, <cite>WAIS Interface Protocol Prototype Functional Specification,</cite> (v1.5), Thinking Machines Corporation, April 1990.</dd>
<dt id="ref-11">11</dt>
<dd>Fielding, R., <cite>Relative Uniform Resource Locators</cite>, <a href="http://tools.ietf.org/html/rfc1808">RFC 1808</a>, June 1995.</dd>
<dt id="ref-12">12</dt>
<dd>Horton, M. and R. Adams, <cite>Standard for Interchange of USENET Messages</cite>, <a href="http://tools.ietf.org/html/rfc1036">RFC 1036</a>, December 1987.</dd>
<dt id="ref-13">13</dt>
<dd>Kantor, B. and P. Lapsley, <cite>Network News Transfer Protocol</cite>, <a href="http://tools.ietf.org/html/rfc0977">RFC 977</a>, February 1986.</dd>
<dt id="ref-14">14</dt>
<dd>Moore, K., <cite>MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</cite>, <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>, November 1996.</dd>
<dt id="ref-15">15</dt>
<dd>Nebel, E. and L. Masinter, <cite>Form-based File Upload in HTML</cite>, <a href="http://www.ietf.org/rfc1867.txt">RFC 1867</a>, November 1995.</dd>
<dt id="ref-16">16</dt>
<dd>Postel, J., <cite>Simple Mail Transfer Protocol</cite>, STD 10, <a href="http://tools.ietf.org/html/rfc0821">RFC 821</a>, August 1982.</dd>
<dt id="ref-17">17</dt>
<dd>Postel, J., <cite>Media Type Registration Procedure</cite>, <a href="http://tools.ietf.org/html/rfc1590">RFC 1590</a>, November 1996.</dd>
<dt id="ref-18">18</dt>
<dd>Postel, J. and J. Reynolds, <cite>File Transfer Protocol</cite>, STD 9, <a href="http://tools.ietf.org/html/rfc0959">RFC 959</a>, October 1985.</dd>
<dt id="ref-19">19</dt>
<dd>Reynolds, J. and J. Postel, <cite>Assigned Numbers</cite>, STD 2, <a href="http://tools.ietf.org/html/rfc1700">RFC 1700</a>, October 1994.</dd>
<dt id="ref-20">20</dt>
<dd>Sollins, K. and L. Masinter, <cite>Functional Requirements for Uniform Resource Names</cite>, <a href="http://tools.ietf.org/html/rfc1737">RFC 1737</a>, December 1994.</dd>
<dt id="ref-21">21</dt>
<dd> US-ASCII. Coded Character Set - 7-Bit American Standard Code for Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.</dd>
<dt id="ref-22">22</dt>
<dd> ISO-8859. International Standard -- Information Processing -- 8-bit Single-Byte Coded Graphic Character Sets --
<ul>
<li>Part 1: Latin alphabet No. 1, ISO-8859-1:1987.</li>
<li>Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.</li>
<li>Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.</li>
<li>Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.</li>
<li>Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.</li>
<li>Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.</li>
<li>Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.</li>
<li>Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.</li>
<li>Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.</li>
</ul>
</dd>
<dt id="ref-23">23</dt>
<dd>Meyers, J. and M. Rose, <cite>The Content-MD5 Header Field</cite>, <a href="http://tools.ietf.org/html/rfc1864">RFC 1864</a>, October 1995.</dd>
<dt id="ref-24">24</dt>
<dd>Carpenter, B. and Y. Rekhter, <cite>Renumbering Needs Work</cite>, <a href="http://tools.ietf.org/html/rfc1900">RFC 1900</a>, February 1996.</dd>
<dt id="ref-25">25</dt>
<dd>Deutsch, P., <cite>GZIP file format specification version 4.3</cite>, <a href="http://www.ietf.org/rfc1952.txt">RFC 1952</a>, May 1996.</dd>
<dt id="ref-26">26</dt>
<dd>Venkata N. Padmanabhan, and Jeffrey C. Mogul. <cite>Improving HTTP Latency</cite>, Computer Networks and ISDN Systems, v. 28, pp. 25-35, Dec. 1995. Slightly revised version of paper in Proc. 2nd International WWW Conference '94: Mosaic and the Web, Oct. 1994, which is available at <a href="http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html">http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html</a>.</dd>
<dt id="ref-27">27</dt>
<dd>Joe Touch, John Heidemann, and Katia Obraczka. <cite>Analysis of HTTP Performance</cite>, &lt;URL: <a href="http://www.isi.edu/touch/pubs/http-perf96/">http://www.isi.edu/touch/pubs/http-perf96/</a>&gt;, ISI Research Report ISI/RR-98-463, (original report dated Aug. 1996), USC/Information Sciences Institute, August 1998.</dd>
<dt id="ref-28">28</dt>
<dd>Mills, D., <cite>Network Time Protocol (Version 3) Specification, Implementation and Analysis</cite>, <a href="http://tools.ietf.org/html/rfc1305">RFC 1305</a>, March 1992.</dd>
<dt id="ref-29">29</dt>
<dd>Deutsch, P., <cite>DEFLATE Compressed Data Format Specification version 1.3</cite>, <a href="http://tools.ietf.org/html/rfc1951">RFC 1951</a>, May 1996.</dd>
<dt id="ref-30">30</dt>
<dd>S. Spero, <cite>Analysis of HTTP Performance Problems,</cite> <a href="http://sunsite.unc.edu/mdma-release/http-prob.html">http://sunsite.unc.edu/mdma-release/http-prob.html</a>.</dd>
<dt id="ref-31">31</dt>
<dd>Deutsch, P. and J. Gailly, <cite>ZLIB Compressed Data Format Specification version 3.3</cite>, <a href="http://tools.ietf.org/html/rfc1950">RFC 1950</a>, May 1996.</dd>
<dt id="ref-32">32</dt>
<dd>Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P., Luotonen, A., Sink, E. and L. Stewart, <cite>An Extension to HTTP: Digest Access Authentication</cite>, <a href="http://tools.ietf.org/html/rfc2069">RFC 2069</a>, January 1997.</dd>
<dt id="ref-33">33</dt>
<dd>Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T. Berners-Lee, <cite>Hypertext Transfer Protocol -- HTTP/1.1</cite>, <a href="http://tools.ietf.org/html/rfc2068">RFC 2068</a>, January 1997.</dd>
<dt id="ref-34">34</dt>
<dd>Bradner, S., <cite>Key words for use in RFCs to Indicate Requirement Levels</cite>, BCP 14, <a href="http://www.ietf.org/rfc2119.txt">RFC 2119</a>, March 1997.</dd>
<dt id="ref-35">35</dt>
<dd>Troost, R. and Dorner, S., <cite>Communicating Presentation Information in Internet Messages: The Content-Disposition Header</cite>, <a href="http://tools.ietf.org/html/rfc1806">RFC 1806</a>, June 1995.</dd>
<dt id="ref-36">36</dt>
<dd>Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, <cite>Use and Interpretation of HTTP Version Numbers</cite>, <a href="http://www.ietf.org/rfc2145.txt">RFC 2145</a>, May 1997. [jg639]</dd>
<dt id="ref-37">37</dt>
<dd>Palme, J., <cite>Common Internet Message Headers</cite>, <a href="http://tools.ietf.org/html/rfc2076">RFC 2076</a>, February 1997. [jg640]</dd>
<dt id="ref-38">38</dt>
<dd>Yergeau, F., <cite>UTF-8, a transformation format of Unicode and ISO-10646</cite>, <a href="http://tools.ietf.org/html/rfc2279">RFC 2279</a>, January 1998. [jg641]</dd>
<dt id="ref-39">39</dt>
<dd>Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E., Lie, H., and C. Lilley. <cite>Network Performance Effects of HTTP/1.1, CSS1, and PNG,</cite> Proceedings of ACM SIGCOMM '97, Cannes France, September 1997.[jg642]</dd>
<dt id="ref-40">40</dt>
<dd>Freed, N. and N. Borenstein, <cite>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</cite>, <a href="http://tools.ietf.org/html/rfc2046">RFC 2046</a>, November 1996. [jg643]</dd>
<dt id="ref-41">41</dt>
<dd>Alvestrand, H., <cite>IETF Policy on Character Sets and Languages</cite>, BCP 18, <a href="http://tools.ietf.org/html/rfc2277">RFC 2277</a>, January 1998. [jg644]</dd>
<dt id="ref-42">42</dt>
<dd>Berners-Lee, T., Fielding, R. and L. Masinter, <cite>Uniform Resource Identifiers (URI): Generic Syntax and Semantics</cite>, <a href="http://tools.ietf.org/html/rfc2396">RFC 2396</a>, August 1998. [jg645]</dd>
<dt id="ref-43">43</dt>
<dd>Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Sink, E. and L. Stewart, <cite>HTTP Authentication: Basic and Digest Access Authentication</cite>, <a href="http://www.ietf.org/rfc2617.txt">RFC 2617</a>, June 1999. [jg646]</dd>
<dt id="ref-44">44</dt>
<dd>Luotonen, A., <cite>Tunneling TCP based protocols through Web proxy servers,</cite>  Work in Progress. [jg647]</dd>
<dt id="ref-45">45</dt>
<dd>Palme, J. and A. Hopmann, <cite>MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)</cite>, <a href="http://tools.ietf.org/html/rfc2110">RFC 2110</a>, March 1997.</dd>
<dt id="ref-46">46</dt>
<dd>Bradner, S., <cite>The Internet Standards Process -- Revision 3</cite>, BCP 9, <a href="http://tools.ietf.org/html/rfc2026">RFC 2026</a>, October 1996.</dd>
<dt id="ref-47">47</dt>
<dd>Masinter, L., <cite>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</cite>, <a href="http://www.ietf.org/rfc2324.txt">RFC 2324</a>, 1 April 1998.</dd>
<dt id="ref-48">48</dt>
<dd>Freed, N. and N. Borenstein, <cite>Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</cite>, <a href="http://tools.ietf.org/html/rfc2049">RFC 2049</a>, November 1996.</dd>
<dt id="ref-49">49</dt>
<dd>Troost, R., Dorner, S. and K. Moore, <cite>Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</cite>, <a href="http://www.ietf.org/rfc2183.txt">RFC 2183</a>, August 1997.</dd>
</dl>

<h2 id="section-18">18 筆者のアドレス</h2>

<pre> Roy T. Fielding
 Information and Computer Science
 University of California, Irvine
 Irvine, CA 92697-3425, USA

 Fax: +1 (949) 824-1715
 EMail: fielding@ics.uci.edu


 James Gettys
 World Wide Web Consortium
 MIT Laboratory for Computer Science
 545 Technology Square
 Cambridge, MA 02139, USA

 Fax: +1 (617) 258 8682
 EMail: jg@w3.org


 Jeffrey C. Mogul
 Western Research Laboratory
 Compaq Computer Corporation
 250 University Avenue
 Palo Alto, California, 94305, USA

 EMail: mogul@wrl.dec.com


 Henrik Frystyk Nielsen
 World Wide Web Consortium
 MIT Laboratory for Computer Science
 545 Technology Square
 Cambridge, MA 02139, USA

 Fax: +1 (617) 258 8682
 EMail: frystyk@w3.org


 Larry Masinter
 Xerox Corporation
 3333 Coyote Hill Road
 Palo Alto, CA 94034, USA

 EMail: masinter@parc.xerox.com


 Paul J. Leach
 Microsoft Corporation
 1 Microsoft Way
 Redmond, WA 98052, USA

 EMail: paulle@microsoft.com


 Tim Berners-Lee
 Director, World Wide Web Consortium
 MIT Laboratory for Computer Science
 545 Technology Square
 Cambridge, MA 02139, USA

 Fax: +1 (617) 258 8682
 EMail: timbl@w3.org
</pre>

<h2 id="section-19">19 付録</h2>

<h3 id="section-19.1">19.1 インターネットメディアタイプ message/http と application/http</h3>

<p>
HTTP/1.1 プロトコルの定義に追加して、この文書ではインターネットメディアタイプ &quot;message/http&quot; と &quot;application/http&quot; についての仕様を示す。
message/http タイプは単一の HTTP リクエストやレスポンスメッセージを含むために使う事ができ、行長さやエンコーディングに関する全ての &quot;message&quot; タイプが受ける MIME 制限 に従う。
application/http タイプは一つ以上の HTTP リクエストやレスポンスメッセージ (混合されてはいないもの) のパイプラインを含むために使う事ができる。
以下のものが IANA にて登録されている。
</p>

<table summary="message/http についての表" width="80%" border="2" cellpadding="5">
<col align="left" width="30%" />
<col align="left" width="70%" />
<tbody>
<tr><td>メディアタイプ名</td><td>message</td></tr>
<tr><td>メディアサブタイプ名</td><td>http</td></tr>
<tr><td>必要なパラメータ</td><td>なし</td></tr>
<tr><td>省略可能なパラメータ</td><td>version, msgtype<dl>
<dt>version</dt>
<dd>メッセージに同封された HTTP-Version 番号 (例えば &quot;1.1&quot;等)。
与えられない場合、バージョンはボディの最初の行から決定する事ができる。</dd>
<dt>msgtype</dt>
<dd>メッセージタイプ -- すなわち &quot;request&quot; か &quot;response&quot;。
与えられない場合、タイプはボディの最初の行から決定する事ができる。</dd>
</dl></td></tr>
<tr><td>エンコーディングについて</td><td>&quot;7bit&quot;, &quot;8bit&quot;, &quot;バイナリ&quot; のみが許される。</td></tr>
<tr><td>セキュリティについて</td><td>なし</td></tr>
</tbody>
</table>

<table summary="application/http についての表" width="80%" border="2" cellpadding="5">
<col align="left" width="30%" />
<col align="left" width="70%" />
<tbody>
<tr><td>メディアタイプ名</td><td>application</td></tr>
<tr><td>メディアサブタイプ名</td><td>http</td></tr>
<tr><td>必要なパラメータ</td><td>なし</td></tr>
<tr><td>省略可能なパラメータ</td><td>
version, msgtype<dl>
<dt>version</dt>
<dd>メッセージに同封された HTTP-Version 番号 (例えば &quot;1.1&quot;等)。
与えられない場合、バージョンはボディの最初の行から決定する事ができる。</dd>
<dt>msgtype</dt>
<dd>メッセージタイプ -- すなわち &quot;request&quot; か &quot;response&quot;。
与えられない場合、タイプはボディの最初の行から決定する事ができる。</dd>
</dl></td></tr>
<tr><td>エンコーディングについて</td><td>このタイプに含まれる HTTP メッセージは &quot;バイナリ&quot; フォーマットである; すなわち、 E-mail 経由で転送される時は、適切な Content-Transfer-Encoding の使用が必要である。</td></tr>
<tr><td>セキュリティについて</td><td>なし</td></tr>
</tbody>
</table>

<h3 id="section-19.2">19.2 インターネットメディアタイプ multipart/byteranges</h3>

<p>
HTTP 206 (Partial Content) レスポンスメッセージが複数の範囲の内容 (複数の重ならない範囲のリクエストへのレスポンス) を含む時、これらはマルチパートメッセージボディとして転送される。
この目的のためのメディアタイプは &quot;multipart/byteranges&quot; と呼ばれる。
</p>

<p>
multipart/byteranges メディアタイプは二つ以上の部分を含み、それぞれに自身の Content-Type と Content-Range フィールドを持つ。
要求される境界パラメータはそれぞれのボディ部分を分けるために使われる境界文字列を指定する。
</p>

<table summary="multipart/byteranges についての表" width="80%" border="2" cellpadding="5">
<col align="left" width="30%" />
<col align="left" width="70%" />
<tbody>
<tr><td>メディアタイプ名</td><td>multipart</td></tr>
<tr><td>メディアサブタイプ名</td><td>byteranges</td></tr>
<tr><td>必要なパラメータ</td><td>boundary</td></tr>
<tr><td>省略可能なパラメータ</td><td>なし</td></tr>
<tr><td>エンコーディングについて</td><td>&quot;7bit&quot;, &quot;8bit&quot;, &quot;バイナリ&quot; のみが許される。</td></tr>
<tr><td>セキュリティについて</td><td>なし</td></tr>
</tbody>
</table>

<p>
例を見よ。
</p>

<pre><samp> HTTP/1.1 206 Partial Content
 Date: Wed, 15 Nov 1995 06:25:24 GMT
 Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
 Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

 --THIS_STRING_SEPARATES
 Content-type: application/pdf
 Content-range: bytes 500-999/8000

 ...最初の範囲...
 --THIS_STRING_SEPARATES
 Content-type: application/pdf
 Content-range: bytes 7000-7999/8000

 ...次の範囲
 --THIS_STRING_SEPARATES--</samp>
</pre>

<p>注意</p>

<ol>
<li>エンティティの最初の境界文字列の前に追加の CRLF を置く事ができる。</li>
<li>RFC 2046 <a href="#ref-40">[40]</a> ではクォートされた境界文字列を認めているが、既存の実装の中にはクォートされた文字列を不適切に扱うものがある。</li>
<li>いくつかのブラウザやサーバは multipart/x-byteranges というメディアタイプを使用するバイト範囲の仕様の初期ドラフトに基づいてコーディングされているが、それは HTTP/1.1 にて記述されるバージョンとは、ほぼ互換性はあるものの、完全互換ではない。</li>
</ol>

<h3 id="section-19.3">19.3 寛容なアプリケーション</h3>

<p>
この文書は HTTP/1.1 メッセージの生成についての要求を表しているものであるが、すべてのアプリケーションが正しくそれらを実装しているわけでは無いであろう。
故に、我々は作業アプリケーションはもし実装から逸脱する部分があってもそれが明確に中間処理できる時は、逸脱に対して寛容である事を推奨する。
</p>

<p>
クライアントはステータスラインの解析において、またサーバはリクエストラインの解析時においてそれぞれ寛容である<em>べきである</em>。
特に、例えそこには単一の SP のみが必要だったとしても、フィールド間のいかなる量の SP や HT 各文字列を受け入れる<em>べきである</em>。
</p>

<p>
message-header フィールドについての行末は CRLF シーケンスである。
しかし我々は、アプリケーションがそのようなヘッダを解析する時には、単一の LF を行末として認識しその前の CR を無視する事を推奨する。
</p>

<p>
エンティティボディの文字セットは、US-ASCII や ISO-8859-1 ラベルをもってエンティティをラベル付けされるという事以上に好まれるラベル付けは無いという例外を除けば、そのボディで使用されている文字コードの共通点が最も低い特徴としてラベル付けされる<em>べきである</em>。
section <a href="#section-3.7.1">3.7.1</a> や <a href="#section-3.4.1">3.4.1</a> 参照。
</p>

<p>
日付の解析やエンコーディング上の要求や日付エンコーディングに伴うその他の潜在的な問題に対する追加的規則には以下が含まれる。
</p>

<ul>
<li>HTTP/1.1 クライアントやキャッシュは、将来において 50 年を越えて現れると思われる RFC-850 日付は実際過去のものであると仮定す<em>べきである</em> (これは &quot;2000年&quot; 問題を解決する助けとなる)。</li>
<li>HTTP/1.1 実装は解析された Expires 日付を適切な値よりも早いように内部的に表す事が<em>できる</em>が、解析されたExpires を適切な値よりも遅いように内部的に表し<em>てはならない</em>。</li>
<li>有効期限に関連するすべての計算は、GMT で行われ<em>なければならない</em>。ローカルタイムゾーンは経過時間や有効期限の計算や比較に影響を及ぼし<em>てはならない</em>。</li>
<li>HTTP ヘッダが誤って GMT 以外のタイムゾーンの日付値を転送してしまった場合、最も可能な限り保守的な変換を使って GMT へと変換され<em>なければならない</em>。</li>
</ul>

<h3 id="section-19.4">19.4 HTTP のエンティティ と RFC2045 のエンティティとの違い</h3>

<p>
HTTP/1.1 は、エンティティが公開されている様々な表現や拡張可能なメカニズムによって転送できるようにするためにインターネットメール (RFC 822 <a href="#ref-9">[9]</a>) や Multipurpose Internet Mail Extensions (MIME <a href="#ref-7">[7]</a>) のために定義されている多くの構造を使用する。
しかし、RFC 2045 ではメールについて議論し、HTTP は RFC 2045 中に表されているものとは違ういくつかの特徴を持っている。
これらの違いはバイナリ接続以上にパフォーマンスを最適化するために、新しいメディアタイプをより自由に使用できるために、日付の比較を容易にするために、そしていくつかの初期の HTTP サーバやクライアントの実行を認めるために注意深く選ばれた。
</p>

<p>
この付録では HTTP が RFC 2045 と異なる具体的な部分を表す。厳密な MIME 環境へのプロクシやゲートウェイはこの違いを知る<em>べきであり</em>必要な部分での適切な変換を提供す<em>べきである</em>。
また MIME 環境から HTTP へのプロクシやゲートウェイもいくつか変換が必要であるのでこの違いを知る必要がある。
</p>

<h4 id="section-19.4.1">19.4.1 MIME-Version</h4>

<p>
HTTP は MIME 準拠のプロトコルではない。
しかし、HTTP/1.1 メッセージはそのメッセージを構成するためにどんな MIME プロトコルのバージョンが使用されたかを示すために単一の MIME-Version 一般ヘッダフィールドを含む事が<em>できる</em>。
MIME-Version ヘッダフィールドの使用は (RFC 2045 <a href="#ref-7">[7]</a> にて定義されるように) そのメッセージが MIME プロトコルの完全に追従している事を示す。
プロクシ/ゲートウェイは HTTP メッセージを厳密な MIME 環境にエクスポートする時に (それが可能であれば) 完全に追従している事を保証する責任を持つ。
</p>

<pre> MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT</pre>

<p>
MIME バージョン &quot;1.0&quot; は HTTP/1.1 で使う既定である。
しかし、HTTP/1.1 メッセージの解析や意味論はこの文書によって定義されるものであり、MIME の仕様ではない。
</p>

<h4 id="section-19.4.2">19.4.2 公式形式への変換</h4>

<p>
RFC 2045 <a href="#ref-7">[7]</a> は、RFC 2049 <a href="#ref-48">[48]</a> の section 4 にて記述される様に、インターネットメールエンティティが転送される前に公式形式に変換される事を要求する。
この文書の section <a href="#section-3.7.1">3.7.1</a> では HTTP 上を転送される時の &quot;text&quot; メディアタイプのサブタイプについて認められる形式を記述している。
RFC 2046 は、&quot;text&quot; タイプを伴う内容は CRLF をもって行末を表し、行末シーケンス以外の CR や LF の使用を禁止する事を要求する。
HTTP ではメッセージが HTTP 上を転送される時にはテキスト内容の行末を示すために CRLF、単独の CR、単独の LF を認めている。
</p>

<p>
可能であれば、HTTP から厳密な MIME 環境へのプロクシやゲートウェイはこの文書の section <a href="#section-3.7.1">3.7.1</a> にて記述されたテキストメディアタイプに含まれるすべての行末を RFC 2049 の公式形式である CRLF に変換す<em>べきである</em>。
しかし、HTTP がいくつかのマルチバイト文字セットのための場合として、Content-Encoding がある事や、 CR と LF を表すためにオクテットの 13 と 10 を使わないいくつかの文字セットの使用を認めているという事実によってこれが複雑になっているかもしれない事に注意せよ。
</p>

<p>
実装者は、もし元の内容が既に公式形式であるので無ければ、変換は元の内容に適用されている暗号チェックサムを壊してしまうであろう事に注意せよ。
故に、公式形式は HTTP 中にてチェックサムを使うあらゆる内容に対して推奨される。
</p>

<h4 id="section-19.4.3">19.4.3 日付フォーマットの変換</h4>

<p>
HTTP/1.1 は日付比較の処理を簡単にするために制限された日付フォーマット (section <a href="#section-3.3.1">3.3.1</a>) のセットを使用する。
他のプロトコルからのプロクシやゲートウェイは、確実にメッセージ中に与えられるあらゆる Date ヘッダも HTTP/1.1 フォーマットの一つに従い必要であれば日付を書き換える<em>べきである</em>。
</p>

<h4 id="section-19.4.4">19.4.4 内容コーディングの導入</h4>

<p>
RFC 2045 は HTTP/1.1 の Content-Encoding ヘッダフィールドに相当するどんな概念も含んでいない。
これはメディアタイプを修正子のように動作するので、HTTP から MIME 準拠のプロトコルへのプロクシやゲートウェイは Content-Type ヘッダフィールドの値を変更するか、あるいはメッセージを転送する前にエンティティボディをデコードするかし<em>なければならない</em>。
(インターネットメールについての Content-Type のいくつかの実験的なアプリケーションは既に Content-Encoding と等価な機能を行う &quot;;conversions=&lt;content-coding&gt;&quot; のメディアタイプパラメータを使用している。
しかし、このパラメータは RFC 2045 の一部ではない。)
</p>

<h4 id="section-19.4.5">19.4.5 No Content-Transfer-Encoding</h4>

<p>
HTTP は RFC 2045 の Content-Transfer-Encoding (CTE) フィールドを使用していない。
MIME 準拠のプロトコルから HTTP へのプロクシやゲートウェイは HTTP クライアントへとレスポンスメッセージを配信する前にあらゆる identify で無い CTE (&quot;quoted-printable&quot; や &quot;base64&quot;) エンコーディングを取り除か<em>なければならない</em>。
</p>

<p>
HTTP から MIME 準拠のプロトコルへのプロクシやゲートウェイはメッセージがそのプロトコル上で安全に転送されるための正しいフォーマットとエンコーディングがなされる事を保証する責任を持つが、ここでの &quot;安全な転送&quot; とは使用されているプロトコルの制限によって定義される。
そのようなプロクシやゲートウェイは、もしそうする事が目的のプロトコル上での安全な転送の可能性を高めるのであれば、適切な Content-Transfer-Encoding を持ったデータをラベル付けす<em>べきである</em>。
</p>

<h4 id="section-19.4.6">19.4.6 転送エンコーディングの導入</h4>

<p>
HTTP/1.1 は Transfer-Encoding ヘッダフィールド (section <a href="#section-14.41">14.41</a>) を導入する。
プロクシ/ゲートウェイは MIME 準拠のプロトコル経由でメッセージを転送する前にあらゆる転送コーディングを削除し<em>なければならない</em>。
</p>

<p>
&quot;chunked&quot; 転送コーディング (section <a href="#section-3.6">3.6</a>) をデコードするための処理は以下の疑似コードによって表される:
</p>

<pre> length := 0
 read chunk-size, chunk-extension (if any) and CRLF
 while (chunk-size &gt; 0) {
    read chunk-data and CRLF
    append chunk-data to entity-body
    length := length + chunk-size
    read chunk-size and CRLF
 }
 read entity-header
 while (entity-header not empty) {
    append entity-header to existing header fields
    read entity-header
 }
 Content-Length := length
 Remove &quot;chunked&quot; from Transfer-Encoding
</pre>

<h4 id="section-19.4.7">19.4.7 MHTML と行末制限</h4>

<p>
MHTML <a href="#ref-45">[45]</a> 実装に伴うコードを共有する HTTP 実装は、MIME 行末制限に気をつける必要がある。
HTTP にはそのような制限は無いので、HTTP は長い行を折り返さない。HTTP によって転送されている MHTML メッセージは、HTTP はすべてのメッセージボディを付加物{payload} として転送し、その中に含まれるであろう内容や MIME ヘッダラインを解釈しないので、行末制限、折り返し、公式化などを含んだ、すべての MHTML の慣習に従う。
</p>

<h3 id="section-19.5">19.5 追加機能</h3>

<p>
RFC 1945 や RFC 2068 ではいくつかの既存の HTTP 実装によって使われているプロトコル要素について記述したが、これらは多くのHTTP/1.1 アプリケーションを通じて一貫していなく、また正確ではない。
実装者はこれらの機能を知っておいたほうがよいが、他の HTTP/1.1 アプリケーションにおいてそれらの存在や通信協力{interoperability} を当てにはできない。
これらの内のいくつかは実験的な機能として提案されるものを示し、またいくつかは基本の HTTP/1.1 仕様書中に現在表された欠如を実験的な配置が見つける機能を記述する。
</p>

<p>
Content-Disposition や Title のような、SMTP や MIME からのいくつかの他のヘッダもまたしばしば実装される (RFC 2076 <a href="#ref-37">[37]</a> 参照)。
</p>

<h4 id="section-19.5.1">19.5.1 Content-Disposition</h4>

<p>
Content-Disposition レスポンスヘッダフィールドは、ユーザがその内容をファイルに保存したい場合にオリジンサーバが既定ファイル名を提案する事を意味するように勧告されている。
この使用法は RFC 1806 <a href="#ref-35">[35]</a> 中の Content-Disposition の定義に由来する。
</p>

<pre> content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                       disposition-type *( &quot;;&quot; disposition-parm )
 disposition-type = &quot;attachment&quot; | disp-extension-token
 disposition-parm = filename-parm | disp-extension-parm
 filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
 disp-extension-token = token
 disp-extension-parm = token &quot;=&quot; ( token | quoted-string )
</pre>

<p>例を見よ。</p>

<pre> <samp>Content-Disposition: attachment; filename=&quot;fname.ext&quot;</samp></pre>

<p>
受信するユーザエージェントは filename-parm パラメータ中に表されているディレクトリパス情報を尊重す<em>べきではない</em>。
その時 HTTP 実装に適用されるために信じられる唯一の情報だからである。
ファイル名は端末構成部品としてのみ扱われる<em>べきである</em>。
</p>

<p>
このヘッダが content-type に application/octet-stream を持つレスポンス中で使われる場合、ユーザエージェントはレスポンスを表示すべきではなく、直接「レスポンスを名前を付けて保存」ダイアログを記入する事が暗黙的に提案される。
</p>

<p>
Content-Disposition のセキュリティ上の問題については section <a href="#section-15.5">15.5</a> 参照。
</p>

<h3 id="section-19.6">19.6 前バージョンとの互換性</h3>

<p>
前のバージョンに従うように指示する事はプロトコル仕様書としての範疇を超える。
しかしながら、HTTP/1.1 は前のバージョンを簡単にサポートさせられるように慎重に設計された。
この仕様書を作った時 (1996) に、我々が HTTP/1.1 サーバに以下を期待していたであろう事に注目する価値はある。
</p>

<ul>
<li>HTTP/0.9, 1.0, 1.1 それぞれのリクエストラインのフォーマットを認識する</li>
<li>HTTP/0.9, 1.0, 1.1 それぞれのフォーマットのあらゆる有効なリクエストを理解する</li>
<li>クライアントが使ったものと同じメジャーバージョンのメッセージを伴い適切に応答する</li>
</ul>

<p>
また、我々は HTTP/1.1 クライアントには以下を期待していたであろう事に注目する価値はある。
</p>

<ul>
<li>HTTP/0.9, 1.0, 1.1 それぞれのステータスラインのフォーマットを認識する</li>
<li>HTTP/0.9, 1.0, 1.1 それぞれのフォーマットのあらゆる有効なレスポンスを理解する</li>
</ul>

<p>
多くの HTTP/1.0 実装では、それぞれの接続はリクエストの前にクライアントによって確立され、レスポンスを送った後にサーバによって切断される。
実装の中には RFC 2068 <a href="#ref-33">[33]</a> の section 19.7.1 中に記される Keep-Alive バージョンの持続的接続を実装しているものがある。
</p>

<h4 id="section-19.6.1">19.6.1 HTTP/1.0 からの変更点</h4>

<p>
この章では HTTP/1.0 と HTTP/1.1 との間での主な違いを簡単に述べる。
</p>

<h5 id="section-19.6.1.1">19.6.1.1 複数割当{Multi-homed} Web サーバを簡単化し IP アドレスを保護するための変更</h5>

<p>
クライアントとサーバは Host リクエストヘッダをサポートし、HTTP/1.1 リクエストに Host リクエストヘッダ (section <a href="#section-14.23">14.23</a>) が欠落していた場合はエラーを知らせ、絶対 URI (section <a href="#section-5.1.2">5.1.2</a>) を受け入れる、という必要条件はこの仕様書にて定義されている最も重要な変更の一つである。
</p>

<p>
古い HTTP/1.0 クライアントは IP アドレスとサーバの一対一の関係を仮定していたので、そのリクエストが向けられた IP アドレスとは他にリクエストの意図されたサーバを区別するための別の確立されたメカニズムが存在しなかった。
上に概説された変更によって、インターネットは、かつての古い HTTP クライアントはもはや一般的では無い、単一の IP アドレスで複数の Web サイトをサポートできるようになり、単一のホストへの多くの IP アドレスの割り当てが深刻な問題を引き起こしているような、大きな作業上の Web サーバをより簡略化する事ができる。
また、インターネットもルートレベルの HTTP URL 中で使われる特別な目的のドメイン名の唯一の目的に割り当てられていた IP アドレスを取り返す事ができる。Web の成長率と既に設置されたサーバの数を考慮に入れると、全ての HTTP 実装 (既存の HTTP/1.0 アプリケーションを更新したものを含む) がこれらの要求を正しく実装する事は非常に重要である。
</p>

<ul>
<li>HTTP/1.1 リクエストを送るクライアントは Host ヘッダを送ら<em>なければならない</em>。</li>
<li>クライアントとサーバ共に、Host リクエストヘッダをサポートし<em>なければならない</em>。</li>
<li>サーバは、HTTP/1.1 リクエストが Host リクエストヘッダを含んでいなければエラー 400 (Bad Request) を知らせ<em>なければならない</em>。</li>
<li>サーバは 絶対 URI を受け入れ<em>なければならない</em>。</li>
</ul>

<h4 id="section-19.6.2">19.6.2 HTTP/1.0 持続的接続との互換性</h4>

<p>
クライアントやサーバの中には HTTP/1.0 のクライアントやサーバ中における持続的接続についてある以前の実装と互換性を持たせたいと思うかもしれない。
HTTP/1.0 における持続的接続はそれらが既定の振る舞いでは無いとして明確にネゴシエートされる。
HTTP/1.0 の持続的接続の実験的な実装には欠点があり、HTTP/1.1 における新しい機能はこれらの問題を改善するために設計されている。
問題はある既存の 1.0 クライアントが Connection を理解できないプロクシサーバへ Keep-Alive が送っているかもしれず、さらにインバウンドサーバに誤ってそれを転送するかもしれず、そうなると Keep-Alive 接続が確立され、その結果レスポンスでの切断を待っている HTTP/1.0 プロクシのハングアップを引き起こす事になるであろう。
これは HTTP/1.0 クライアントがプロクシと通信する時に Keep-Alive を使用する事を防がなければならないという事である。
</p>

<p>
しかし、プロクシとの通信は持続的接続の最も重要な使い方であり、その禁止は明らかに受け入れる事はできない。
故に、我々は Connection を無視する古いプロクシと通信する時に使用しても安全な、持続的接続が望まれている事を示すための他のメカニズムを必要とする。
持続的接続は HTTP/1.1 メッセージの既定であり、我々は非持続性を宣言するための新しいキーワード (Connection: close) を導入する。
section <a href="#section-14.10">14.10</a> 参照。
</p>

<p>
持続的接続の元の HTTP/1.0 の形式 (Connection:Keep-Alive や Keep-Alive ヘッダ) は RFC 2068 <a href="#ref-33">[33]</a> 中に記述されている。
</p>

<h4 id="section-19.6.3">19.6.3 RFC 2068 からの変更点</h4>

<p>
この仕様書はキーワードの仕様について正しくまた曖昧で無い様に慎重に検査された。
RFC 2068 は RFC 2119 <a href="#ref-34">[34]</a> 中に置かれた約定について多くの問題を抱えていた。
</p>

<p>
インバウンドサーバの失敗のために使われるべきエラーコードは明らかにされる (例. DNS の失敗)。
(Section <a href="#section-10.5.5">10.5.5</a>)
</p>

<p>
CREATE はリソースが最初に生成された時に送られる ETag を要求する種類を持つ。
(Section <a href="#section-10.2.2">10.2.2</a>)
</p>

<p>
Content-Base は仕様書から削除された。
これは広くは実装されてはおらず、また、逞しい{robust} 拡張メカニズム無しにこれを導入する事は単純なものでも安全なものでも無い。
加えて、これは MHTML <a href="#ref-45">[45]</a> 中では似たようなものが使われているが、同一のやり方ではない。
</p>

<p>
(自己分割できない転送コーディングを考慮に入れるために) チャンクエンコーディングが使用される場合、Transfer-coding とメッセージ長は全て正確なる固定が要求される方法において相互動作する; どのようにメッセージ長が計算されるかを正確に決定しておく事は重要であった。
(Sections <a href="#section-3.6">3.6</a>, <a href="#section-4.4">4.4</a>, <a href="#section-7.2.2">7.2.2</a>, <a href="#section-13.5.2">13.5.2</a>, <a href="#section-14.13">14.13</a>, <a href="#section-14.16">14.16</a>)
</p>

<p>
キャッシング中に発見される問題を解決するために、内容コーディングに &quot;identity&quot; が導入された。
(Section <a href="#section-3.5">3.5</a>)
</p>

<p>
0 という品質値は、クライアントが表現を拒否できるように &quot;それを望まない&quot; という事を示すべきである。
(Section <a href="#section-3.9">3.9</a>)
</p>

<p>
HTTP のバージョン番号の使用とその説明については RFC 2145 にて明示された。
プロクシは HTTP/1.0 実装に見られる問題を扱う事をサポートするために最も高いプロトコルバージョンにアップグレードする必要がある。
(Section <a href="#section-3.1">3.1</a>)
</p>

<p>
Accept ヘッダ中の文字セット名の急激な増加を避けるために文字セットのワイルドカード{Charset wildcarding} が導入された。
(Section <a href="#section-14.2">14.2</a>)
</p>

<p>
ある事例が HTTP/1.1 の Cache-Control モデル中に入れ損なわれていた。
よって、s-maxage がこの抜けた事例を加えるために導入された。
(Sections <a href="#section-13.4">13.4</a>, <a href="#section-14.8">14.8</a>, <a href="#section-14.9">14.9</a>, <a href="#section-14.9.3">14.9.3</a>)
</p>

<p>
レスポンスの場合の Cache-Control: max-age 指示子が適切に定義されていなかった。
(Section <a href="#section-14.9.3">14.9.3</a>)
</p>

<p>
サーバ（特にプロクシ）がレスポンスの全長は知らないが、バイト範囲リクエストをする能力はあるという場合がある。
故に、我々はメッセージの全長を示さない content-range を伴ったバイト範囲を許すメカニズムを必要とする。
(Section <a href="#section-14.16">14.16</a>)
</p>

<p>
レンジリクエストは、既に全ての外部データが返されていた場合には、ひどく冗長になるであろう。
しかし、サーバが 206 レスポンス中に必要なヘッダのみを送る事ができるようにする事によって、この問題は解決できる。
(Section <a href="#section-10.2.7">10.2.7</a>, <a href="#section-13.5.3">13.5.3</a>, <a href="#section-14.27">14.27</a>)
</p>

<p>
満足できないレンジリクエストに修正について。
これには二つの場合があって、構文上の問題と、その範囲が文書に存在しない場合とがある。
416 ステータスコードは、文書の実際の内容以外の点について失敗したバイト範囲リクエストのエラーを示すために、その曖昧さを解決するために必要である。
(Section <a href="#section-10.4.17">10.4.17</a>, <a href="#section-14.16">14.16</a>)
</p>

<p>
ここにあるエラーの結果はインターネットに重要な影響を及ぼしうるので、実装者が状況をこれ以上悪くする事を、また実装者が以下の問題を扱う事を避けるためのメッセージ転送の必要条件の書き直し:
</p>

<ol>
<li>その部分が将来の HTTP/1.x バージョンの実装の振る舞いにおける必要条件を不正確に示している文脈において、&quot;HTTP/1.1 以降&quot; を &quot;HTTP/1.1&quot; に変える</li>
<li>ユーザエージェントはリクエストを繰り返すべきであるが、一般に &quot;クライアント&quot; はそうすべきではない、という事を明らかにさせる。</li>
<li>クライアントは予期しない 100 (Continue) レスポンスを無視せよ、またプロクシは 100 レスポンスを転送せよ、という必要条件を 1xx レスポンスに対する一般的な必要条件に変える。</li>
<li>いくつかの TCP に特定した言語を修正し、HTTP のためには TCP ではない転送でも可能であるという事をより明らかにする。</li>
<li>オリジンサーバは自身が要求された 100 (Continue) レスポンスを送る前には、リクエストボディを待っ<em>てはならない</em>という事を必要とする。</li>
<li>サーバはリクエストボディの一部を既に取得している場合は 100 (Continue) レスポンスを省略する事を、必要とするよりもむしろ、それを見込んでいる。</li>
<li>サーバはサービス不能攻撃や故障したクライアントから身を守る事ができる。</li>
</ol>

<p>
この変更により Expect ヘッダと 417 ステータスコードが付け加えられた。
メッセージ転送の必要条件は sections <a href="#section-8.2">8.2</a>, <a href="#section-10.4.18">10.4.18</a>, <a href="#section-8.1.2.2">8.1.2.2</a>, <a href="#section-13.11">13.11</a>, <a href="#section-14.20">14.20</a> の各節にて修正される。
</p>

<p>
プロクシは適切な時点で Content-Length を付け加える事ができるべきである。
(Section <a href="#section-13.5.2">13.5.2</a>)
</p>

<p>
403 と 404 の各レスポンスの区別を明らかにせよ。
(Section <a href="#section-10.4.4">10.4.4</a>, <a href="#section-10.4.5">10.4.5</a>, and <a href="#section-10.4.11">10.4.11</a>)
</p>

<p>
Warning が不正確にキャッシュされたリ、適切に更新されなかったりした。
(Section <a href="#section-13.1.2">13.1.2</a>, <a href="#section-13.2.4">13.2.4</a>, <a href="#section-13.5.2">13.5.2</a>, <a href="#section-13.5.3">13.5.3</a>, <a href="#section-14.9.3">14.9.3</a>, <a href="#section-14.46">14.46</a>)
また Warning は一般ヘッダである必要があり、よって PUT や他のメソッドではリクエスト中にそれが必要となるであろう。
</p>

<p>
転送コーディングは、特にチャンク形式エンコーディングで相互作用する時に、重要な問題を持っていた。
これは転送コーディングが内容コーディングのように完全なものとなる事で解決する。
これには転送コーディング (内容コーディングとは別に) や新しいヘッダフィールド (TE) が IANA レジストリに登録され、将来的に trailer ヘッダが使用可能になる事が必要となる。
転送エンコーディングはパフォーマンス上に大きな利益があるので、修正す
る価値はある <a href="#ref-39">[39]</a>。
TE はその他の、チャンク形式にエンコーディングされた認証用のもの{authentication trailers} と HTTP/1.0 クライアントとの間の相互作用によって起こったはっきりしない下方の相互運用上の問題を解決する。
(Section <a href="#section-3.6">3.6</a>, <a href="#section-3.6.1">3.6.1</a>, <a href="#section-14.39">14.39</a>)
</p>

<p>
この仕様書の前のバージョンでは PATCH, LINK, UNLINK 各メソッドが定義されていたが、これは一般には実装されていない。
RFC 2068 <a href="#ref-33">[33]</a> 参照。
</p>

<p>
この仕様書の前のバージョンでは Alternates, Content-Version, Derived-From, Link, URI, Public, Content-Base 各ヘッダフィールドが定義されていたが、これは一般には実装されていない。
RFC 2068 <a href="#ref-33">[33]</a> 参照。
</p>

<h2 id="section-20">20 索引</h2>

<p>
索引についてはこの RFC の PostScript 版を見ていただきたい。
</p>

<h2 id="section-21">21 著作権表示全文</h2>

<p>
Copyright &copy; The Internet Society (1999).  All Rights Reserved.
</p>

<p>
この文章とその翻訳は、複製し他人に配布する事ができ、またその実装についてのコメント、その他の方法を用いた説明、その補助となるような派生的作業はそれらの中に上の著作権表示とこの段落を含む事によって、その全て又は一部を、いかなる制約も受けずに、作成、複製、発表、及び配布する事ができる。
しかしながら、インターネット標準化プロセスにて定義されている著作権のための手続きに従わなければならないような場合の中でインターネット標準を開発するという目的に必要である、あるいは英語以外の言語に翻訳する必要があるという場合を除いて、この文章自体を、その著作権表示や、インターネット学会あるいは他のインターネット団体への参照を削除するような、いかなる変更もできない。
</p>

<p>
上で認めた制限された許諾は永続的なものであり、インターネット学会及びその継承者や譲渡者によって取り消される事は無い。
</p>

<p>
この文書とここに含まれた情報は、&quot;そのまま {AS IS}&quot; である事を基に提供され、<em>インターネット学会、及び IETF は、この中の情報の使用が、商用利用及び特定用途においていかなる権利もいかなる暗黙的保障も侵害していないという保障への制限を含め、明示的に又は暗黙的に、全ての保障を放棄する</em>。
</p>

<h3>謝辞</h3>

<p>
RFC Editer 機構の資金は、現在インターネット学会から提供されている。
</p>

<hr />
<div><a href="#TOP">#TOP</a></div>
<address>
Copyright &copy; 1999-2008 <a href="http://www.studyinghttp.net/help#Notice">橋本英彦 (H-Hash)</a>, All Rights Reserved.
</address>

</body>
</html>
