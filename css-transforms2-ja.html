<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Transforms Module Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<script src="common0.js"></script>
<script src="common1.js" async></script>

<style>
td[colspan] {
	text-align:center;
}

#supporting-functions-table > tr > td:first-child {
	font-family: monospace0, monospace;
}

.upper-alpha > li {
	list-style-type: upper-alpha;
}

._matrix tr {
	border: none;
}
._matrix td {
	text-align: center;
}
._matrix {
	border-collapse: separate;
	border-spacing: 0;
	border: solid thin currentcolor;
	border-style: none solid;
	border-radius: 5px;
}
</style>

<script >

Util.ready = function(){
	const source_data = {
		persisted_parts: Object.create(null),
		generate: expand
	};
	{
		// 行列表現を生成
		const data = PAGE_DATA.matrix_data
.replace( /\s*●(.+)/g,
	'</tbody></table><table id="_dgm-$1" class="_matrix"><tbody>' )
.replace(/[\s\S]*?<\/table>/, '')
.replace(/\n(?=[^<\s])/g, '<tr><td>')
.replace(/,[ \t]*/g, '<td>')
.replace(/%m(\d+)/g, '<var>m<sub>$1</sub></var>')
.replace(/%([\wα-ε]+)/g, '<var>$1</var>')
+ '</tbody></table>';
		delete PAGE_DATA.matrix_data;

		const div = C('div');
		div.innerHTML = data;
		for(let e = div.firstElementChild; e; e = e.nextElementSibling){
			if(e.id){
				source_data.persisted_parts[e.id] = e;
			}
		}
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%[\wα-ε\-一-鿆~あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 't': // typedef
	text = `&lt;${key}&gt;`;
	break;
case 'vp': // perspective-origin
	href=`#valdef-perspective-origin-${key}`;
	break;
case 'f': // funcdef
	text = `${key}()`;
	break;
case 'M': // 行列成分
	text = `m<sub>${key}</sub>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Transforms Module Level 2
spec_date:2025-11-30
trans_update:2025-12-03
source_checked:230711
page_state_key:CSS
original_url:https://drafts.csswg.org/css-transforms-2/
	abbr_url:TRANSFORM2
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:transform,css
conformance:css
copyright:2025,permissive
trans_1st_pub:2017-01-14


●●class_map
p:property
e:element
a:attr
css:css
f:func
t:type
v:value
vp:value

●●tag_map
p:code
svg:code
css:code
e:code
a:code
c:code
I:code
m:code
M:var
t:var
b:b
f:code
v:code
vp:code
V:var
cite:cite

●●words_table1
MOTION1:motion-ja.html
	none:<a class="value" href="#none">none</a>
none0:none
none1:none


●●words_table


	●座標系／行列／変形
変形-:transform::~
変形:transform::~
	変形-原点:transform-origin
変形n:transformation::変形
変形d:transformed::変形
	変形されない:untransformed

行列:matrix:~
行列式:determinant:~
単位i:identity::単位
逆行列:inverse:~
恒等:identity:~
	恒等~変形-関数:identity transform function

遠近法:perspective::~
透視:perspective::~
射影:projection::~
投影:projection::~
	映され:projected onto

回転-:rotate::~
回転:rotation::~
回転角:angle::~
角度:angle::~
並進-:translate::~
並進:translation::~
拡縮-:scale::~
拡縮:scale::~
拡縮率:scale::~
拡縮ng:scaling::拡縮
	拡縮率:scaling
	拡縮ng:scale operation
	拡縮-法:scaling
拡大-:scale up::~
縮小-:scale down::~
斜傾:skew::~::スキュー
斜傾率:shear::~::シアー

写像:mapping::~::マッピング
写像-:map::~::マップ
線型:linear::~

単位元:neutral element:~
特異性:singularity::~
組成-:composite::~
再構成-:recompose::~
	再構成-法:recomposing
分解-:decompose::~
	分解-法:decomposing
分解:decomposition::~
派生関数:derived transform function:derived transform 関数:~
原始関数:primitive:~
派生:derivative::~
派生-:derive::~
換算-:convert:~
換算:conversion:~
	converting
四元数:quaternions::~
等式:equation:~
	右辺:right hand side
直交する:orthogonalになる::~
直交な:orthogonalな::直交する
直交化する:orthogonal 化する::直交させる
	:orthogonalize
	unflip
斉次:homogeneous::~
無限小:infinitesimal:~
	無限小:infinitesimal small／thickness
無限遠:infinitely far:~
球面:spherical::~
作用-:operate:~
作用:operation:~
	~~作用:interact

	左から乗算-:pre-multiply
平方根:square root:~
総和:sum:~
	2 乗:square

	●幾何
2D:
3D:
4D:
	-:dimension 
	~2D:two-dimensional
	~3D:three-dimensional
	~4D:four-dimensional
	~2D:2d
	~3D:3d
	~3D:3d-
	~3D:3D-
4x4::4×4
3x2::3×2
3x3::3×3

裏返す:flipする:~
裏返され:flipされ:~
裏表に:back-to-backに:~
	貼り合わせる:place 〜 back-to-back
裏面:back:~
背面:backface:裏面
表面:front:~
裏側:reverse side:~
表側:front side:~
	前面:in front of
	前面から後面への
	後面から前面
	手前から奥:front-to-back
	奥から手前:back-to-front
五角形:pentagon:~
三角形:triangle:~
四辺形:quadrilateral:~
矩形:rectangle:~
多角形:polygon:~
四角錐:pyramid:~

時計回り:clockwise:~

垂直:perpendicular:~
平面:plane:~
	平面的:as flat planes
消失点:vanishing point:~
深度:depth:~
	深度~順に基づいてdepth-sort
奥行き:depth:~

横:horizontal:~
縦:vertical:~
視点:viewer:~
	視点:the same place the viewer is looking from
	視聴者の目の~~位置
隅:corner:~
頂点:vertex:~
封入-:enclose:~
風景:scene:~
狭小:narrow:~
遠近感:foreshortening:~
	-:parallel

X:
Y:
Z:
	X:x
	Y:y
	Z:z
	〜に向かって:towards
	〜倍に:factor
	ずれ:offset
	より大きい:greater
	より大きい:larger
	より小さく:smaller
	小さい:small
	より近く:closer
	より遠い:further away
	十分に遠い:very far
	非常に広大:enormous
	中央:middle
	右下方:
	扉が開く様に:swings closer
	一定位置
	カメラ
		切り取:cut out／chopped off ／ truncating ／ slice away
	中程度:moderate
	俯瞰:looking at
	傾けられて:tilting out
	全体:complete

	どこまで〜しようが:No matter how far
	半分:half
	原点:origin of point
	原点:point of origin
	原点からの:origin-centered 
	両側
	右方
	地点:
	向く:faces
	周:turns
	四隅:
	埋める:fill

	増大-:increases
	大きく越えて:far past
	小さい:small
	左上:upper-left
	左上隅
	引き延ばされる:stretched over／stretch out
	flat surface
	感:feeling
	本物らしく:realistic
	様子
	手前:in front
	指す先から:end
	極小:very small

	正方向
	無限大
	無限遠点
	画面:drawing plane／plane of the screen
	真正面
	移動
	移動量
	移動／変動するmoves
	薄さ:thickness

	近さ:close
	限りなく近付ける:bringing the box closer and closer
	近付:
	近似:
	逆方向:
	遠く:far
	遠く離れた:faraway
	鏡:sheet of glass
	鏡像:mirror-image 1
	鏡像をとるmirroring
	隣接:
	飛び出す:pop out
	同一~平面にある:coplanar
	比例する:proportional

	●アニメーション
加法的:additive::~
累積:accumulation::~
累積-:accumulate::~
累積d:accumulated::累積
	加算:arithmetic addition

反転:flip:~
始値-:source:始値-
終値-:destination:終値-

値A:<var>V</var><sub>A</sub>
値B:<var>V</var><sub>B</sub>
	結果値:<var>V<sub>result</sub></var>
差分:delta:~
端点:endpoint:~


	●レイアウト
基準:reference:~
	基準~box:reference box
包装:wrapper:~
	~group化:grouping
	scrolling
封込め:containment::封じ込め

	●塗り
積層:stacking::~
多層化:layering::~::多レイヤ化
装飾:decoration:~
背後:behind:~
塗ng:painting:塗り
塗り:paint:~
不透明度:opacity::~
	radial-gradient^f:radial gradient
stroke::::ストローク
	~stroke法:stroking

	描画~文脈:Rendering Context

	●構文
	単位なしの:Unitless

	●CSS
	算出d長さ$:absolute length

	●仕様
論拠:reasoning:~
表記:notation:~
奇妙:bizarre:~
改正-:amend:~
印象:impression:~

	consequently
	通例のように:per usual
	compat
	有効:effective
	なるべく:possible
	の効力により:by virtue of
	効力を発揮する:comes into play
	し易く:easier／easily
	別法として:alternately
	ゆえに:consequence
	いずれにせよ:anyway
	させなくする:prevent
	方法
	付録
	仮想
	〜下の:contained
	参考
	当該の:in question／respective
	注意:
	詳細:
	規定:
	要する:necessary／
	に関する:with regards to
	~~歪める:stress
	ふるまう:act
	判明:tested
	参照:
	想定:
	捉え:thought
	要する:require
	試案:pass at an attempt to
	解く:solve
	改め得:alter
	調べる:looking at
	該当しない:does not count
	~~追加で:extra
	本当は:really
	互換性:compat
	~web互換性:webcompat
	機能:
	基本:
	どの程度~正確に〜を精確に指定するための最初の試案:first pass at an attempt to precisely specify how exactly
	記す:write
	選ぶ:chosen
	単なる:just
	価し:worth
	主要な:substantive
	為され:made
	と同じく:as in
	と同じく:just like 〜 does

	●未分類
連結:concatenation:~
展開-:expand:~
	同じ〜に共存:share a common〜
巻上げら:hoist upさ:巻き上げら
切詰め:clamping:切り詰め
切抜き:clipping::切り抜き::クリッピング
	-:quantity
列主導順:column-major order::~
数学的:mathematical:~
	数学的:math
数量的:numerical:~
公式:formula:~
graphics::::グラフィックス
疑似:pseudo::~
絵図:drawing:~
固定-:fix:~
固定的:fixed:~
交互:alternate:~
舞台:stage:~
遊戯用:playing:~
card::::カード
hover:
個別的:individual:~
簡約-:reduce:~

	元々は:originally
	~~固定-:anchor
	~screen外:off-screen
	〜化:instantiated
	対:pair
	1 に基づく:one-based
	計算-結果:calculated value
	指す:address
	与えられ:given
	~~動的:live
	変動:
	変化:
	渡され:passed
	現れる:appear する
	据え:sits
	省略された:missing
	省略された:not given
	戻す:back

	web
	成分値:
	引数:parameter
	行~vector
	等しい:equal
	等しく:equally
	量:amount
	-:quantity
	見かけ:look
	大きく:larger
	住まう:living
	変形あり, 変形なし:no transform versus transform

	1:one
	下段:bottom
	上段:top
	部分:part
	上述
	下図
	前の例:previous example
	前段落:
	前節
	前節による:former
	前者
	後者
	後述
	一方
	一連の:collection／
	一部
	以下
	以外
	任意
	次項
	残り:rest
	最終的な:final
	自体:
	自身:
		全部:whole thing
	上の:the previous

	右辺
	場合:
	大抵:
	対応:
	対象:
	属している:live in
	属する
	時点:
	橙色:orange
	水色:light blue
	青色:blue
	黄緑色:lime
	黄色:yellow
	個目／本目
	実線:solid outline
	点線:dashed
	およそ:about
	〜からなる:consists
	一時的:temporarily
	個数:number of
	先立:
	再度
	-:equal
	〜時には:For the time of
	を経ない限り／-:former
	それから:afterwards


●●original_id_map

●●mdn_urls
propdef-backface-visibility:CSS/backface-visibility
propdef-perspective:CSS/perspective
propdef-perspective-origin:CSS/perspective-origin
propdef-transform:CSS/transform
propdef-rotate:CSS/rotate
propdef-scale:CSS/scale
propdef-translate:CSS/translate
propdef-transform-style:CSS/transform-style

typedef-transform-function:CSS/transform-function

funcdef-matrix3d:CSS/transform-function/matrix3d
funcdef-perspective:CSS/transform-function/perspective
funcdef-rotate3d:CSS/transform-function/rotate3d
funcdef-rotatex:CSS/transform-function/rotateX
funcdef-rotatey:CSS/transform-function/rotateY
funcdef-rotatez:CSS/transform-function/rotateZ
funcdef-scale3d:CSS/transform-function/scale3d
funcdef-scalex:CSS/transform-function/scaleX
funcdef-scaley:CSS/transform-function/scaleY
funcdef-scalez:CSS/transform-function/scaleZ
funcdef-translate3d:CSS/transform-function/translate3d
funcdef-translatez:CSS/transform-function/translateZ


●●link_map

	●e
e.a:~SVGlinking#elementdef-a
	＊e.a:~HEtextlevel#the-a-element
e.animate:https://svgwg.org/specs/animations/animate.html#AnimateElement
e.clipPath:~MASKING1#elementdef-clippath
e.foreignObject:~SVGembedded#elementdef-foreignObject
e.g:~SVGstruct#elementdef-g
e.linearGradient:~SVGpservers#elementdef-linearGradient
e.mask:~MASKING1#elementdef-mask
e.pattern:~SVGpservers#elementdef-pattern
e.radialGradient:~SVGpservers#elementdef-radialGradient
e.set:https://svgwg.org/specs/animations/animate.html#SetElement
e.svg:~SVGstruct#elementdef-svg

	●p
p.background-position:~CSSBG#propdef-background-position
p.clip-path:~MASKING1#propdef-clip-path
p.clip:~MASKING1#propdef-clip
p.filter:~FILTERS#propdef-filter
p.isolation:~COMPOSITING#propdef-isolation
	p.isolation:~CSSWG/compositing-2/#propdef-isolation
p.mask-border-source:~MASKING1#propdef-mask-border-source
p.mask-image:~MASKING1#propdef-mask-image
p.mix-blend-mode:~COMPOSITING#propdef-mix-blend-mode
	p.mix-blend-mode:~CSSWG/compositing-2/#propdef-mix-blend-mode
p.offset:~MOTION1#propdef-offset
p.opacity:~CSSCOLOR#propdef-opacity
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.position:~CSSPOS#propdef-position
p.vector-effect:~SVGcoords#VectorEffectProperty

p.backface-visibility:#propdef-backface-visibility
p.perspective-origin:#propdef-perspective-origin
p.perspective:#propdef-perspective
p.rotate:#propdef-rotate
p.scale:#propdef-scale
p.translate:#propdef-translate
p.transform-style:#propdef-transform-style

p.transform:~TRANSFORM#propdef-transform
p.transform-origin:~TRANSFORM#propdef-transform-origin
p.z-index:~CSS2J#propdef-z-index
p.contain:~CSSCONTAIN#propdef-contain
p.content-visibility:~CSSCONTAIN#propdef-content-visibility

	●f
f.matrix3d:#funcdef-matrix3d
f.perspective:#funcdef-perspective
f.rotate3d:#funcdef-rotate3d
f.rotateX:#funcdef-rotatex
f.rotateY:#funcdef-rotatey
f.rotateZ:#funcdef-rotatez
f.scale:#funcdef-scale
f.scaleX:#funcdef-scalex
f.scaleY:#funcdef-scaley
f.scale3d:#funcdef-scale3d
f.scaleZ:#funcdef-scalez
f.translate3d:#funcdef-translate3d
f.translateZ:#funcdef-translatez

f.matrix:~TRANSFORM#funcdef-transform-matrix
f.rotate:~TRANSFORM#funcdef-transform-rotate
f.translate:~TRANSFORM#funcdef-transform-translate
f.translateX:~TRANSFORM#funcdef-transform-translatex
f.translateY:~TRANSFORM#funcdef-transform-translatey

f.radial-gradient:~CSSIMAGE#funcdef-radial-gradient

	●t
t.length:~CSSVAL#length-value
t.length [0,∞]:~CSSVAL#length-value
	t.length:#valdef-perspective-length
t.transform-function:#typedef-transform-function
	t.matrix3d():#funcdef-matrix3d
	t.perspective():#funcdef-perspective
t.angle:~CSSVAL#angle-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.number:~CSSVAL#number-value
t.percentage:~CSSVAL#percentage-value
t.position:~CSSVAL5#typedef-position
t.zero:~CSSVAL#zero-value
t.transform-list:~TRANSFORM#typedef-transform-list

	●v
	vt.length:#valdef-perspective-origin-length
	vt.percentage:#valdef-perspective-origin-percentage
v.none:#valdef-perspective-none
v.~none1:#valdef-perspective-func-none
v.~none0:#valdef-translate-none

v.bottom:#valdef-perspective-origin-bottom
v.center:#valdef-perspective-origin-center
v.left:#valdef-perspective-origin-left
v.right:#valdef-perspective-origin-right
v.top:#valdef-perspective-origin-top

v.x:#valdef-rotate-x
v.y:#valdef-rotate-y
v.z:#valdef-rotate-z

v.visible:~CSSOVERFLOW3#valdef-overflow-visible
v.clip:~CSSOVERFLOW3#valdef-overflow-clip

v.paint:~CSSCONTAIN#valdef-contain-paint

c.getComputedStyle():~CSSOM1#dom-window-getcomputedstyle

	●用語
視点:#_viewer

~3D並進:#Translate3dDefined
~3D回転:#Rotate3dDefined
~3D変形:#three-d-transform-functions
~3D変形-関数:#3d-transform-functions
~3D拡縮ng:#Scale3dDefined
~3D変形d要素:#3d-transformed-element
~3D行列:#3d-matrix
恒等~変形-関数:#identity-transform-function
累積~3D変形n行列:#accumulated-3d-transformation-matrix
透視~投影~行列:#PerspectiveDefined
透視~行列:#perspective-matrix

1 に基づく値~用の累積:#accumulation-for-one-based-values

~3D描画~文脈:#3d-rendering-context
	§:#3d-rendering-contexts

§ ~3D変形による描画:#3d-transform-rendering
§ 変形-関数の数学的~記述:#mathematical-description
§ 累積~3D変形n行列の算出:#accumulated-3d-transformation-matrix-computation
§ 行列の補間:#matrix-interpolation

~group化~prop値:#grouping-property-values

	●用語（level 1
すべての子孫~用の包含塊:~TRANSFORM#containing-block-for-all-descendants

~2D~3x2行列:~TRANSFORM#MatrixDefined
~2D行列:~TRANSFORM#2d-matrix
~2D並進:~TRANSFORM#TranslateDefined
基準~box:~TRANSFORM#reference-box
変形-可能:~TRANSFORM#transformable-element
変形d要素:~TRANSFORM#transformed-element
変形n行列:~TRANSFORM#transformation-matrix
変形-関数:~TRANSFORM#transform-functions
原始関数:~TRANSFORM#transform-primitives
	派生関数:~TRANSFORM#transform-primitives
局所~座標系:~TRANSFORM#local-coordinate-system
左から乗算-:~TRANSFORM#pre-multiply
右から乗算-:~TRANSFORM#post-multiply

	●用語（CSS
補間:~CSSVAL#interpolation
加算:~CSSVAL#addition
累積:~CSSVAL#accumulation
算出d長さ:~CSSVAL#computed-length

使用~値:~CASCADE#used-value
算出d値:~CASCADE#computed-value

積層~文脈:~CSS2J#stacking-context
付録 E:~CSS22/zindex.html#elaborate-stacking-contexts

包含塊:~CSSDISP#containing-block

解決d値:~CSSOM1#resolved-value
解決d値は特別:~CSSOM1#resolved-value-special-case-property

塗り封込め:~CSSCONTAIN#paint-containment

	●用語（外部
呈示~属性:~SVGstyling#TermPresentationAttribute
	呈示~属性:~SVG11/intro.html#TermPresentationAttribute
~graphicを参照する要素:~SVGstruct#TermGraphicsReferencingElement
~graphics要素:~SVGstruct#TermGraphicsElement
容器~要素:~SVGstruct#TermContainerElement

~list:~INFRA#list
~cloneする:~INFRA#list-clone
拡張する:~INFRA#list-extend
	付加する:~INFRA#list-append	→ 拡張する

●●matrix_data


●3x3matrix
%a, %c, %e
%b, %d, %f
0, 0, 1

●4x4matrix
%m11, %m21, %m31, %m41
%m12, %m22, %m32, %m42
%m13, %m23, %m33, %m43
%m14, %m24, %m34, %m44

●translate3d
1, 0, 0, %tx
0, 1, 0, %ty
0, 0, 1, %tz
0, 0, 0, 1 

●scale3d
%sx, 0, 0, 0
0, %sy, 0, 0
0, 0, %sz, 0
0, 0, 0, 1

●rotate3dmatrix
1 − 2⋅( %y⋅%y + %z⋅%z )⋅%ss, 2⋅( %x⋅%y⋅%ss − %z⋅%sc ), 2⋅( %x⋅%z⋅%ss + %y⋅%sc ), 0
2⋅( %x⋅%y⋅%ss + %z⋅%sc ), 1 − 2⋅( %x⋅%x + %z⋅%z )⋅%ss, 2⋅( %y⋅%z⋅%ss − %x⋅%sc ), 0
2⋅( %x⋅%z⋅%ss − %y⋅%sc ), 2⋅( %y⋅%z⋅%ss + %x⋅%sc ), 1 − 2⋅( %x⋅%x + %y⋅%y )⋅%ss, 0
0, 0, 0, 1

●rotate3dX
1, 0, 0, 0
0, 1 − 2⋅%ss, − 2⋅%sc, 0
0, 2⋅%sc, 1 − 2⋅%ss, 0
0, 0, 0, 1

●rotate3dY
1 − 2⋅%ss, 0, 2⋅%sc, 0
0, 1, 0, 0
− 2⋅%sc, 0, 1 − 2⋅%ss, 0
0, 0, 0, 1

●rotate3dZ
1 − 2⋅%ss, − 2⋅%sc, 0, 0
2⋅%sc, 1 − 2⋅%ss, 0, 0
0, 0, 1, 0
0, 0, 0, 1

●perspective
1, 0, 0, 0
0, 1, 0, 0
0, 0, 1, 0
0, 0, −1/%d, 1

●●images
＠css-transforms2/
coordinates｜height:240px;｜＝Demonstration of the initial coordinate space｜.svg
simple-3d-example｜height:190px;｜｜.png
perspective_distance｜height:600px;｜｜.svg
perspective_origin｜height:300px;｜＝Diagram of different perspective-origin｜.svg
simple-perspective-example｜height:190px;｜｜.png
3d-intersection｜height:198px;｜｜.png
3d-rendering-context-flat｜height:200px;｜｜.png
3d-rendering-context-3d｜height:200px;｜｜.png


●●ref_normative

[COMPOSITING-2]
    ＜Compositing and Blending Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/compositing-2/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-4]
    Chris Lilley; Tab Atkins Jr.; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color-4/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-MASKING-1]
    Dirk Schulze; Brian Birtles; Tab Atkins Jr.. ＜CSS Masking Module Level 1＞. URL: https://drafts.csswg.org/css-masking-1/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VALUES-5]
    Tab Atkins Jr.; Elika Etemad; Miriam Suzanne. ＜CSS Values and Units Module Level 5＞. URL: https://drafts.csswg.org/css-values-5/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[FILTER-EFFECTS-1]
    Dirk Schulze; Dean Jackson. ＜Filter Effects Module Level 1＞. URL: https://drafts.csswg.org/filter-effects-1/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MOTION-1]
    Tab Atkins Jr.; Dirk Schulze; Jihye Hong. ＜Motion Path Module Level 1＞. URL: https://drafts.csswg.org/motion-1/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SVG-ANIMATIONS]
    ＜SVG Animations Level 2＞. Editor's Draft. URL: https://svgwg.org/specs/animations/
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[SVG2]
    Amelia Bellamy-Royds; et al. ＜Scalable Vector Graphics (SVG) 2＞. URL: https://svgwg.org/svg2-draft/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Transforms Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-transforms-2/
公表履歴
	https://www.w3.org/standards/history/css-transforms-2/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-transforms-2">CSSWG Issues Repository</a>

編集
	<a href="https://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
	<a href="https://dbaron.org/">L. David Baron</a> (Google) 
	<a href="mailto:simon.fraser@apple.com">Simon Fraser</a> (Apple Inc)
	<a href="mailto:dino@apple.com">Dean Jackson</a> (Apple Inc)
	<a href="mailto:eoconnor@apple.com">Theresa O’Connor</a> (Apple Inc)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-transforms-2/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-transforms-2

差分仕様
	yes
</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS による 3D 変形 — CSS Transforms Module Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
CSS Transform （変形, 座標系変換）は、
要素を［
~2D空間／~3D空間
］内で変形するよう~CSSで~styleすることを許容する。
◎
CSS transforms allows elements styled with CSS to be transformed in two-dimensional or three-dimensional space.
</p>

<p>
この仕様は、
~3D変形~用の新たな［
変形~関数／~prop
］, および 単純な変形~用の便利~関数を追加する。
◎
This spec adds new transform functions and properties for three-dimensional transforms, and convenience functions for simple transforms.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
この仕様は、
`css-transforms-1$r を拡張する差分~仕様であり，
要素を~3D空間~内で変形することを作者に許容する。
`transform$p ~prop用の新たな`~3D変形-関数$により，~3D変形が可能になる。
加えて，~3D変形で作業し易くするための追加的な~propもあり、
作者は，入子な~3D変形の~~作用についての制御も可能になる。
◎
This specification is a delta spec that extends [css-transforms-1] to allow authors to transform elements in three-dimensional space. New transform functions for the transform property allow three-dimensional transforms, and additional properties make working with three-dimensional transforms easier, and allow the author to control how nested three-dimensional transformed elements interact.
</p>

<ul>
	<li>
`perspective$p ~propは、［
遠近法による変形nを~~追加で伴う子~要素を供する
］ことを作者に許容する。
◎
The perspective property allows the author to provide child elements with an extra perspective transformation.＼
</li>
	<li>
`perspective-origin$p ~propは、
遠近法が適用される原点に対する制御を供することにより，
“消失点” の所在を実質的に変更できる。
◎
The perspective-origin property provides control over the origin at which perspective is applied, effectively changing the location of the "vanishing point".
</li>
	<li>
`transform-style$p ~propは、
~3D変形された［
要素, その子孫たち
］を同じ~3D空間に共存させることにより，
~3D~obj階層の構築を許容する。
◎
The transform-style property allows 3D-transformed elements and their 3D-transformed descendants to share a common three-dimensional space, allowing the construction of hierarchies of three-dimensional objects.
</li>
	<li>
`backface-visibility$p ~propは、
要素が［
その裏側が`視点$から可視になるよう，~3D変形を通して反転されている
］ときに効力を発揮する。
その種の要素は，隠される方が望ましい状況もあるが、
この~prop用の値 `hidden^v を利用することで，それがアリになる。
◎
The backface-visibility property comes into play when an element is flipped around via three-dimensional transforms such that its reverse side is visible to the viewer. In some situations it is desirable to hide the element in this situation, which is possible using the value of hidden for this property.
</li>
</ul>

<p class="note">注記：
`transform$p ~propの一部の値は，要素を ~3D座標系において変形するが、
その要素~自身は~3D~objにはされない。
それらは~2D平面~内に存在し，奥行きを持たない。
◎
Note: While some values of the transform property allow an element to be transformed in a three-dimensional coordinate system, the elements themselves are not three-dimensional objects. Instead, they exist on a two-dimensional plane (a flat surface) and have no depth.
</p>

<p class="trans-note">【
`視点@
とは、
想定されている，（一定位置にある）~page閲覧者の目の~~位置、
言い換えれば仮想のカメラ~~位置を意味する。
遠近法が無い~2D描画~文脈の下では、
これは有意にならない（実質的に、
画面から垂直に閲覧者~側へ向かう，無限遠点にある）。
`~3D描画~文脈$の下では、
画面から視点までの距離, および その文脈~下の~boxの中心から視点への X, Y 軸~方向のずれ量が，実際の描画に織り込まれることになる。
また、
後述される様に，視点は~pageの部分ごとに設定できる。
ただし，視点の~~位置は~boxに相対的になる
— ~screenに相対的にする機能（~boxが~scrollされても “画面外では固定的な” 現実の閲覧者の目の~~位置に合わせて動的に描画を変える）は，特に用意されていない。
】</p>

<p>
この仕様はまた、
単純な変形を容易に［
記述-／~animate
］できるよう， 3 種の便利~prop［
`scale$p, `translate$p, `rotate$p
］も追加する。
◎
This specification also adds three convenience properties, scale, translate and rotate, that make it easier to describe and animate simple transforms.
</p>

		<section id="module-interactions">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
ここでの`~3D変形-関数$は、
`transform$p ~propがとり得る関数たちが成す集合を拡張する。
◎
The 3D transform functions here extend the set of functions for the transform property.
</p>

<p>
次に挙げる~prop用の一部の値は、［
`積層~文脈$／`すべての子孫~用の包含塊$
］を作成させる
⇒＃
`perspective$p,
`transform-style$p,
`backface-visibility$p
◎
Some values of perspective, transform-style and backface-visibility result in the creation of a containing block for all descendants, and/or the creation of a stacking context.
</p>

<p>
~3D変形は、
要素たちの視覚的な多層化に影響する
— それは、
`CSS21$r `付録 E$ に述べられた，奥から手前にかけての塗ng順序を上書きする。
◎
Three-dimensional transforms affect the visual layering of elements, and thus override the back-to-front painting order described in Appendix E of [CSS21].
</p>

		</section>
		<section id="values">
<h3 title="Value Definitions">1.2. 値~定義</h3>

<p class="trans-note">【
この節の内容は、
`~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<dl>
	<dt>
`~3D変形d要素@
◎
3D transformed element
</dt>
	<dd>
`transform$p ~propの算出d値に `~3D変形-関数$を伴う要素。
◎
An element whose computed value for the transform property includes one of the 3D transform functions
</dd>

	<dt>
`~3D行列@
◎
3D matrix
</dt>
	<dd>
`~2D行列$の要件を充足しない~4x4行列。
◎
A 4x4 matrix which does not fulfill the requirements of an 2D matrix.
</dd>

	<dt>
`恒等~変形-関数@
◎
identity transform function
</dt>
	<dd>
<p>
`CSS-TRANSFORMS-1$r による`恒等~変形-関数＠~TRANSFORM#identity-transform-function$に加え、
恒等~変形-関数の例には，次が挙げられる：
</p>

<div style="white-space:pre-wrap; margin-left: 2em;"
>`translate3d(0, 0, 0)^v,
`translateZ(0)^v,
`scaleZ(1)^v,
`rotate3d(1, 1, 1, 0)^v,
`rotateX(0)^v,
`rotateY(0)^v,
`rotateZ(0)^v,
`matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)^v
</div>

<p>
遠近法の特殊な事例として，
`perspective(none)^v がある
— この場合、
`34^M の値は無限小になり，したがって変形-関数は単位i行列に等しいものと見做される。
</p>

◎
In addition to the identity transform function in CSS Transforms, examples for identity transform functions include translate3d(0, 0, 0), translateZ(0), scaleZ(1), rotate3d(1, 1, 1, 0), rotateX(0), rotateY(0), rotateZ(0) and matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1). A special case is perspective: perspective(none). The value of m34 becomes infinitesimal small and the transform function is therefore assumed to be equal to the identity matrix.
</dd>

	<dt>
`透視~行列@
◎
perspective matrix 
</dt>
	<dd>
［
`perspective$p, `perspective-origin$p
］~propの値から，
`下で述べるとおり＠#perspective-matrix-computation$に算出される行列。
◎
A matrix computed from the values of the perspective and perspective-origin properties as described below.
</dd>

	<dt>
`累積~3D変形n行列@
◎
accumulated 3D transformation matrix
</dt>

	<dd>
要素に対し，その`~3D描画~文脈$の根に相対的に算出される行列
— ~~詳細は `§ 累積~3D変形n行列の算出$に。
◎
A matrix computed for an element relative to the root of its 3D rendering context, as described below.
</dd>

	<dt>
`~3D描画~文脈@
◎
3D rendering context
</dt>
	<dd>
同じ~3D座標系に共存する，先祖が共通な要素たちが成す集合。
~~詳細は
`§ ~3D描画~文脈＠#3d-rendering-contexts$に。
◎
A set of elements with a common ancestor which share a common three-dimensional coordinate system, as described below.
</dd>
</dl>

		<section id="serialization-of-the-computed-value">
<h3 title="Resolved value of transform">2.1. `transform^p の解決d値</h3>

<p>
`transform$p ~propの`解決d値は特別$である `CSSOM$r
— その`解決d値$は：
◎
The transform property is a resolved value special case property. [CSSOM]
</p>
<ul>
	<li>
`算出d値$が `transform-list$t になる場合
⇒
それを成す各 `transform-function$t を~4x4行列に換算してから順に`右から乗算-$した結果に応じて
⇒＃
`~2D行列$になる場合，結果を `matrix$f として直列化した結果になる。
他の場合， `matrix3d$f として直列化した結果になる。
◎
When the computed value is a &lt;transform-list&gt;, the resolved value is one &lt;matrix()&gt; function or one &lt;matrix3d()&gt; function computed by the following algorithm:
• Let transform be a 4x4 matrix initialized to the identity matrix. The elements m11, m22, m33 and m44 of transform must be set to 1; all other elements of transform must be set to 0.
• Post-multiply all &lt;transform-function&gt;s in &lt;transform-list&gt; to transform.
• Chose between &lt;matrix()&gt; or &lt;matrix3d()&gt; serialization:
•• If transform is a 2D matrix
••• Serialize transform to a &lt;matrix()&gt; function.
•• Otherwise
••• Serialize transform to a &lt;matrix3d()&gt; function.
</li>
	<li>
他の場合
⇒
`算出d値$と同じになる。
◎
For other computed values, the resolved value is the computed value.
</li>
</ul>

		</section>
	</section>
	<section id="two-dimensional-subset">
<h2 title="Two Dimensional Subset">3. ~2D下位集合</h2>

<p>
~UAは、
~3D変形を描画できるとは限らず，
この仕様を成す~2D下位集合しか~supportしないこともある。
この場合：
◎
UAs may not always be able to render three-dimensional transforms and then just support a two-dimensional subset of this specification. In this case＼
</p>

<ul>
	<li>
`~3D変形$を~supportしないモノトスル。
◎
three-dimensional transforms and＼
</li>
	<li>
次に挙げる~propを~supportしないモノトスル
⇒＃
`transform-style$p,
`perspective$p,
`perspective-origin$p,
`backface-visibility$p
◎
the properties transform-style, perspective, perspective-origin and backface-visibility must not be supported.＼
</li>
	<li>
`§ ~3D変形による描画$は適用されない。
◎
Section 3D Transform Rendering does not apply.＼
</li>
	<li>
行列の分解-法は
“`Graphics Gems II, edited by Jim Arvo^cite”
による “`unmatrix^en” 手法を~2Dの場合に単純~化した技法を利用する。
◎
Matrix decomposing uses the technique taken from the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", simplified for the 2D case.＼
</li>
	<li>
<p>
`§ 変形-関数の数学的~記述$は，依然として有効であるが、
下図に示す~3x3変形n行列を利用して簡約できる
— ここで図の［
%a, %b, %c, %d, %e, %f
］は、
順に［
`11^M, `12^M, `21^M, `22^M, `41^M, `42^M
］に対応する（ `~2D~3x2行列$を見よ）：
◎
Section Mathematical Description of Transform Functions is still effective but can be reduced by using a 3x3 transformation matrix where a equals m11, b equals m12, c equals m21, d equals m22, e equals m41 and f equals m42 (see A 2D 3x2 matrix with six parameter).
</p>

<figure>`3x3matrix^dgm
<figcaption>
~2D変形n用の~3x3行列
◎
3x3 matrix for two-dimensional transformations.
</figcaption></figure>

	</li>
</ul>

<div class="example">
<p>
作者は、
~UAが~3D変形を~supportしない場合の~fallbackを容易に供せる。
次の例に 2 個の `transform$p ~prop宣言【！definition】を示す
— 1 個目は 2 個の~2D変形-関数からなり，
2 個目は ~2D変形-関数と~3D変形-関数からなる。
◎
Authors can easily provide a fallback if UAs do not provide support for three-dimensional transforms. The following example has two property definitions for transform. The first one consists of two two-dimensional transform functions. The second one has a two-dimensional and a three-dimensional transform function.
</p>

<pre class="lang-css">
div {
  transform: scale(2) rotate(45deg);
  transform: scale(2) rotate3d(0, 0, 1, 45deg);
}</pre>

<p>
~3Dが~supportされる場合、
2 個目の宣言が 1 個目の宣言を上書きすることになる。
~3Dが~supportされない場合、
 2 個目の宣言は無効になり，~UAは 1 個目の宣言に~fall-backする。
◎
With 3D support, the second definition will override the first one. Without 3D support, the second definition is invalid and a UA falls back to the first definition.
</p>
</div>

	</section>
	<section id="transform-rendering">
<h2 title="The Transform Rendering Model">4. 変形の描画~model</h2>

<div>
<p>
この仕様は、
`CSS-TRANSFORMS-1$r `§ 変形の描画~model＠~TRANSFORM#transform-rendering$
を拡張して，次に挙げるものを織り込む【！for the existence of】：
</p>
<ul>
	<li>
`~3D変形-関数$
</li>
	<li>
`transform-origin$p の Z 値
</li>
	<li>
`perspective$p ~prop
</li>
	<li>
`transform-style$p ~propの`使用~値$が `preserve-3d^v になるときに適用される新たな~3D描画~model
</li>
</ul>
◎
This specification extends CSS Transforms 1 § 3 The Transform Rendering Model to account for the existence of three-dimensional transform functions, the Z value of transform-origin, the perspective property, and a new 3D rendering model that applies when the used value of the transform-style property is preserve-3d.
</div>

<p>
`~3D変形-関数$は、
画面に垂直かつ視点に向けて増大する Z 軸を加えることで，~2D座標~空間を概念的に~3Dへ拡張する。
◎
Three-dimensional transform functions conceptually extend the coordinate space into three dimensions, adding a Z axis perpendicular to the plane of the screen, that increases towards the viewer.
</p>

<figure>
<figcaption id="_dgm-coordinates">
初期~時の座標~空間のデモ。
◎
Demonstration of the initial coordinate space.
</figcaption></figure>

		<section id="3d-transform-rendering">
<h3 title="3D Transform Rendering">4.1. ~3D変形による描画</h3>

<p>
通常は、
要素は平面的に，要素が属する`積層~文脈$と同じ平面に埋め込まれるように描画される。
大抵の場合、
それは~pageを成す残りと共有される平面になる。
~2D変形-関数は要素の外観を改め得るが、
それでも，描画される平面は要素が属する積層~文脈と同じになる。
◎
Normally, elements render as flat planes, and are rendered into the same plane as their stacking context. Often this is the plane shared by the rest of the page. Two-dimensional transform functions can alter the appearance of an element, but that element is still rendered into the same plane as its stacking context.
</p>

<p>
~3D変形を伴う要素のうち，`~3D描画~文脈$に包含されていないものは、
適切な変形を適用して描画されるが，他のどの要素とも交差しない。
この事例における~3D変形は、
~2D変形と同様に，単なる塗ng効果と見なせる。
同様に，その変形は、
塗ng順序にも影響しない。
例えば， Z 軸において正な並進を伴う変形は、
要素の見かけを大きくし得るが，当の要素を Z 軸における並進を伴わない要素の前面に描画させることはない。
◎
An element with a three-dimensional transform that is not contained in a 3D rendering context renders with the appropriate transform applied, but does not intersect with any other elements. The three-dimensional transform in this case can be considered just as a painting effect, like two-dimensional transforms. Similarly, the transform does not affect painting order. For example, a transform with a positive Z translation may make an element look larger, but does not cause that element to render in front of elements with no translation in Z.
</p>

<p class="issue">
入子な~3D変形d要素をどう描画するか述べる（たぶん，数学的に)
◎
describe how nested 3d-transformed elements render (perhaps with math)
</p>

<div class="example">
<p class="issue">
この例は、
上の~textに従っていない。
◎
This example doesn’t follow from the previous text.
</p>

<p>
要素に適用される~3D変形の効果を，次の例に示す：
◎
This example shows the effect of three-dimensional transform applied to an element.
</p>

<pre class="lang-html">
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  border: 1px solid black;
}
.transformed {
  transform: rotateY(50deg);
}
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;</pre>

<figure>
<p class="alt" hidden id="_dgm-simple-3d-example">
`rotateY^f により変形された `div^e 要素の見本~描画。
◎
Div with a rotateY transform.
</p>
</figure>

<p>
この変形は、
Y 軸（縦方向）を中心に 50° 回転させる。
これにより，青色な~box（ `.transformed^css ）は狭小に現れるが、
~3Dではない。
◎
The transform is a 50° rotation about the vertical, Y axis. Note how this makes the blue box appear narrower, but not three-dimensional.
</p>
</div>

			<section id="perspective">
<h4 title="Perspective">4.1.1. 遠近法</h4>

<p>
遠近法（ `perspective$p ~prop）を利用すれば、
風景に奥行き感を追加できる
— 要素は、
その Z 座標（以下 %z ）を高くする（`視点$に近付ける）ほど，より大きく現れ、
低くする（`視点$から遠ざける）ほど，より小さく現れる。
拡縮率は［
%d ÷ ( %d − %z )
］に比例する。
ここで， %d は `perspective$p の値であり，画面から視点と見做される地点（下図の “みなし~~視点”
【！Assumed Eye Position】
）までの距離を与える。
◎
Perspective can be used to add a feeling of depth to a scene by making elements higher on the Z axis (closer to the viewer) appear larger, and those further away appear smaller. The scaling is proportional to d/(d − Z) where d, the value of perspective, is the distance from the drawing plane to the assumed position of the viewer’s eye.
</p>

<p>
`~3D変形d要素$に遠近法の外観を適用する仕方には、
次の 2 つがある：
◎
The appearance of perspective can be applied to a 3d-transformed element in two ways.＼
</p>

<ul>
	<li>
要素の “変形-関数~list” は、
`perspective$f 関数を包含でき，要素の現在の`変形n行列$の中へ算出される。
◎
First, the element’s 'transform function list' can contain the perspective() function which computes into the element’s 'current transformation matrix'.
</li>
	<li>
要素には、［
`perspective$p, `perspective-origin$p
］~propを適用できる
— それらは、
~3D変形された子たちの描画に波及し，［
子たちで共有され，子たちが同じ~3D風景~内に住まうような印象を供する遠近法
］を与える。
◎
Second, the perspective and perspective-origin properties can be applied to an element to influence the rendering of its 3d-transformed children, giving them a shared perspective that provides the impression of them living in the same three-dimensional scene.
</li>
</ul>

<figure>
<p class="alt" hidden id="_dgm-perspective_distance">
拡縮率と~Z位置の関係を示す図式
◎
Diagram of scale vs. Z position
</p>
<figcaption>
拡縮-法が `perspective$p ~propと Z 位置に依存する様子を示す図式。
上段の図式では， %z が %d の半分にされている。
元の円（実線）が %z （点線の円）の所に現れるようにするため、
円は 2 倍に拡大され，水色な円で示されるものになる。
下段の図式では、
円は 2 ÷ 3 倍に縮小されて，元の位置の背後に現れる。
◎
Diagrams showing how scaling depends on the perspective property and Z position. In the top diagram, Z is half of d. In order to make it appear that the original circle (solid outline) appears at Z (dashed circle), the circle is scaled up by a factor of two, resulting in the light blue circle. In the bottom diagram, the circle is scaled down by a factor of one-third to make it appear behind the original position.
</figcaption></figure>

<p>
通常は、
`視点$と見做される地点は，絵図の中心（真正面）にある。
欲されるなら `perspective-origin$p を設定して，この位置を移動することもできる
—
例えば、
~page内の複数の絵図が，同じ遠近法を共有すべき場合など。
◎
Normally the assumed position of the viewer’s eye is centered on a drawing. This position can be moved if desired – for example, if a web page contains multiple drawings that should share a common perspective – by setting perspective-origin.
</p>

<figure>
<figcaption id="_dgm-perspective_origin">
遠近法の原点を上方へ移動する効果を示す図式。
◎
Diagram showing the effect of moving the perspective origin upward.
</figcaption></figure>

<p id="perspective-matrix-computation">
`透視~行列$は、
単位i行列に対し，以下に与える各~変形nを順に累積する
【各~変形nを表現する行列を，所与の順に`右から乗算-$する】
ことにより算出される：
◎
The perspective matrix is computed as follows:
• Start with the identity matrix.
</p>

<ol>
	<li>
`perspective-origin$p の算出d値で与えられる移動量による`~2D並進$
◎
Translate by the computed X and Y values of perspective-origin
</li>
	<li>
<p>
［
`perspective$p ~propの値から供される長さ値
］を引数にとる `perspective$f 変形-関数から得される`透視~投影~行列$
◎
Multiply by the matrix that would be obtained from the perspective() transform function, where the length is provided by the value of the perspective property
</li>
	<li>
最初の段に与えたものとは，逆方向への並進【逆行列】
◎
Translate by the negated computed X and Y values of perspective-origin
</li>
</ol>

<div class="example">
<p>
次の例に、
~3D変形が より本物らしく現れるようにするための， `perspective^p の利用を示す：
◎
This example shows how perspective can be used to cause three-dimensional transforms to appear more realistic.
</p>

<pre class="lang-html">
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  perspective: 500px;
  border: 1px solid black;
}
.transformed {
  transform: rotateY(50deg);
}
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>

<figure>
<p class="alt" hidden id="_dgm-simple-perspective-example">
`div^e 要素が `rotateY^f により変形され，その容器は遠近法（ `perspective^p ）を伴う場合の見本~描画。
◎
Div with a rotateY transform, and perspective on its container
</p>
</figure>

<p>
内縁な要素は，前の例と同じ変形を有するが、
その描画には，今や その親~要素の `perspective^p ~propが波及している。
`perspective^p により、
絵図の中の点の X, Y 座標は、
その Z 座標が（`視点$により近い）正な所では拡大される一方，
（`視点$からより遠い）負な所では縮小され、
外観に奥行き感が与えられる。
◎
The inner element has the same transform as in the previous example, but its rendering is now influenced by the perspective property on its parent element. Perspective causes vertices that have positive Z coordinates (closer to the viewer) to be scaled up in X and Y, and those further away (negative Z coordinates) to be scaled down, giving an appearance of depth.
</p>
</div>

			</section>
			<section id="3d-rendering-contexts">
<h4 title="3D Rendering Contexts">4.1.2. ~3D描画~文脈</h4>

<p>
この節では、
~3D変形, および `transform-style$p ~propを利用する内容を描画するための~modelを指定する。
この~modelを述べるため、
“~3D描画~文脈” の概念を導入する。
◎
This section specifies the rendering model for content that uses 3D-transforms and the transform-style property. In order to describe this model, we introduce the concept of a "3D rendering context".
</p>

<p>
`~3D描画~文脈$は、［
~3D変形を描画する目的において，同じ~3D座標系に共存すると見なされる
］ような［
共通な先祖を根とする要素たち
］が成す集合である。
~3D描画~文脈における各~要素の手前から奥への描画は、
当の~3D空間における各自の z 位置に依存する
— 要素どうしが~3D変形により交差する場合、
その交差を伴って描画される。
◎
A 3D rendering context is a set of elements rooted in a common ancestor that, for the purposes of 3D-transform rendering, are considered to share a common three-dimensional coordinate system. The front-to-back rendering of elements in the a 3D rendering context depends on their z-position in that three-dimensional space, and, if the 3D transforms on those elements cause them to intersect, then they are rendered with intersection.
</p>

<p>
その~3D空間における各~要素の位置は、
要素から当の`~3D描画~文脈$を確立した要素まで，
各自の変形n行列を`累積する＠#accumulated-3d-transformation-matrix$ことにより決定される。
◎
The position of each element in that three-dimensional space is determined by accumulating the transformation matrices up from the given element to the element that establishes the 3D rendering context.
</p>

<p>
要素は、
次に従って~3D描画~文脈［
を確立する／に関与する
］：
◎
Elements establish and participate in 3D rendering contexts as follows:
</p>
<ul>
	<li>
<p>
`変形-可能$な要素のうち，
`transform-style$p の`使用~値$が `preserve-3d^v になるものは：
</p>
		<ul>
			<li>
`~3D描画~文脈$の一部を成してないならば、
`~3D描画~文脈$を確立し，要素~自身も その文脈に関与することになる。
</li>
			<li>
ある`~3D描画~文脈$に関与しているならば、
その~3D描画~文脈を拡張する
— 新たなそれを確立することなく。
</li>
		</ul>
◎
A 3D rendering context is established by a transformable element whose used value for transform-style is preserve-3d and which itself is not part of a 3D rendering context. An element that establishes a 3D rendering context also participates in that context.
◎
An element whose used value for transform-style is preserve-3d and which itself participates in a 3D rendering context, extends that 3D rendering context rather than establishing a new one.
</li>
	<li>
要素は、
その親が`~3D描画~文脈$を［
確立する／拡張する
］ならば，`~3D描画~文脈$に関与する。
◎
An element participates in a 3D rendering context if its parent establishes or extends a 3D rendering context.
</li>
</ul>

<p>
~CSS~propには、
“~group化” を強制する値
— 当の要素が他の要素と組成される前に，［
要素と その子孫たちを~groupとして描画する
］よう要求する値 —
をとるものがある。
これらには、
不透明度, ~filter, 切抜きに影響する~propも含まれる。
これに関連な~prop値は、
`~group化~prop値$にて挙げる。
その帰結として，そのような値が［
`transform-style$p が `preserve-3d^v をとる要素
］に利用された場合、
`transform-style^p の`使用~値$は `flat^v に変更され，
要素は`~3D描画~文脈$を［
作成-／拡張-
］しなくなる。
◎
Some CSS properties have values that are considered to force "grouping": they require that their element and its descendants are rendered as a group before being composited with other elements; these include opacity, filters and properties that affect clipping. The relevant property values are listed under grouping property values. Consequently, when used on an element with transform-style:preserve-3d, they change the used value to flat and prevent it from creating or extending a 3D rendering context.
</p>

<p>
所与の`~3D描画~文脈$ %文脈 においては、
要素たちは，次に従って描画され, ~sortされる
— 以下における %R は、
%文脈 を確立した要素を表す：
◎
In a 3D rendering context, rendering and sorting of elements is done as follows:
</p>
<ol>
	<li>
<p>
%R および %文脈 に関与している他の`~3D変形d要素$たちは、
各自の自前の平面の中に描画される。
この平面†には，当の要素†の［
背景,
~border,
他の~box装飾,
内容,
子孫~要素
］が含まれるが、
子孫~要素のうち自前の平面を有するもの（および，それらの子孫）は，除外される。
この描画は、
`CSS21$r `付録 E$ に則って行われる。
</p>
<p class="trans-note">【†
%R のみを指すのか，他の各 要素にも適用されるのか、
明瞭でない
（文法的には後者に解釈できそうだが、
下の注記は前者を示唆している）。
】</p>
◎
The element establishing the 3D rendering context, and each other 3D transformed element participating in the 3D rendering context, is rendered into its own plane. This plane includes the element’s backgrounds, borders, other box decorations, content, and descendant elements, excluding any descendant elements that have their own plane (and their descendants). This rendering is done according to CSS 2.1, Appendix E, Section E.2 Painting Order.
</li>
	<li>
`Newell の~algo＠https://en.wikipedia.org/wiki/Newell%27s_algorithm$に則って、
これらの平面どうしで交差が遂行される
— 各~平面は、
`累積~3D変形n行列$により変形した上で。
同一~平面にある`~3D変形d要素$たちは、
塗ng順序で描画される。
◎
Intersection is performed between this set of planes, according to Newell’s algorithm, with the planes transformed by the accumulated 3D transformation matrix. Coplanar 3D transformed elements are rendered in painting order.
</li>
</ol>

<p class="issue">
~2D`変形d要素$たちを各自の自前の平面の中へ `pop^en しなくて大丈夫か？
◎
is it OK to not pop 2D-transformed elements into their own planes?
</p>

<p class="note">注記：
以前まで，この仕様は、
%R の［
背景, ~border, 他の~box装飾
］は，~3D風景~全体の背後に描画されるものと定義していたが、
`6238$issue により変更された。
しかしながら，将来に~3D描画~文脈の定義が変更された場合、
この変更を戻すことも考慮するに価し得る。
◎
Note: This specification previously defined that the background, borders, and other box decorations of the establishing element were rendered behind the entire 3D scene. This was changed in #6238. However, if the definition of 3D Rendering Contexts is changed in the future, it may be worth considering changing back.
</p>

<p>
z-成分が負な変形を伴う要素は、
%R の［
内容, 変形されない子孫
］の背後に描画されることに注意。
したがって`~3D変形d要素$は、
内容や変形されない要素に浸出し得る。
◎
Note that elements with transforms which have a negative z-component will render behind the content and untransformed descendants of the establishing element, and that 3D transformed elements may interpenetrate with content and untransformed elements.
</p>

<p class="note">注記：
~3D描画~文脈~内の`~3D変形d要素$たちは、
深度~順に基づいて互いに交差し得るので，
実質的には互いに同胞であるかのように描画される。
<code class="css">`transform-style^p: `preserve-3d^v</code>
による効果は、
~3D描画~文脈~内の`~3D変形d要素$は，どれも［
%R の下に巻上げられつつ，依然として自身の`累積~3D変形n行列$により描画される
］ようにすることと捉えられる。
◎
Note: Because the 3D-transformed elements in a 3D rendering context can all depth-sort and intersect with each other, they are effectively rendered as if they were siblings. The effect of transform-style: preserve-3d can then be thought of as causing all the 3D transformed elements in a 3D rendering context to be hoisted up into the establishing element, but still rendered with their accumulated 3D transformation matrix.
</p>

<div class="example">
<pre class="lang-html">
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.scene {
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid black;
  perspective: 500px;
}
.container {
      transform-style: preserve-3d;
}
.container &gt; div {
  position: absolute;
  left: 0;
}
.container &gt; :first-child {
  transform: rotateY(45deg);
  background-color: orange;
  top: 10px;
  height: 135px;
}
.container &gt; :last-child {
  transform: translateZ(40px);
  background-color: rgba(0, 0, 255, 0.6);
  top: 50px;
  height: 100px;
}
&lt;/style&gt;

&lt;div class="scene"&gt;
  &lt;div class="container"&gt;
    Lorem ipsum dolor sit amet, consectetaur adipisicing elit…
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
この例は、
~3D描画~文脈~内の要素が互いに交差し得ることを示す。
`.container^css 要素は、［
自身, その 2 個の子
］用の~3D描画~文脈を確立する。
`.scene^css 要素は、
この~3D描画~文脈に遠近法を追加する。
子たちは互いに交差し、
橙色な子と `.container^css 要素も互いに交差する。
◎
This example shows show elements in a 3D rendering context can intersect. The container element establishes a 3D rendering context for itself and its two children, and the scene element adds perspective to the 3D rendering context. The children intersect with each other, and the orange element also intersects with the container.
</p>

<figure>
<p class="alt" hidden id="_dgm-3d-intersection">
交差している同胞な要素たち。
◎
Intersecting sibling elements.
</p>
</figure>

</div>

<div class="example">
<pre class="lang-html">
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  perspective: 500px;
  border: 1px solid black;
}
.transformed {
  transform: rotateY(50deg);
  background-color: blue; /* <span class="comment">青色</span> */
}
.child {
  transform-origin: top left;
  transform: rotateX(40deg);
  background-color: lime; /* <span class="comment">黄緑色</span> */
}
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;
      &lt;div class="child"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
この例は、
入子な~3D変形の描画の様子を示す。
青色な `div^e は、
前の例と同じく
— その描画には，その親~要素の遠近法（ `perspective^p ）が波及して —
変形される。
黄緑色な要素も，（ `transform-origin$p の効力により，青色な `div^e の上端に~~固定された） X 軸を中心に回転される，~3D変形を有する —
しかしながら，同じ~3D描画~文脈には属さないので、
黄緑色な要素は短く現れ，青色な要素から “飛び出す” ことはない。
◎
This example shows how nested 3D transforms are rendered. The blue div is transformed as in the previous example, with its rendering influenced by the perspective on its parent element. The lime element also has a 3D transform, which is a rotation about the X axis (anchored at the top, by virtue of the transform-origin). However, the lime element is being rendered into the plane of its parent because it is not a member of the same 3D rendering context. Thus the lime element only appears shorter; it does not "pop out" of the blue element.
</p>

<figure>
<p class="alt" hidden id="_dgm-3d-rendering-context-flat">
入子にされた~3D変形が平坦~化された場合の見本~描画
◎
Nested 3D transforms, with flattening
</p>
</figure>
</div>

			</section>
			<section id="transformed-element-hierarchies">
<h4 title="Transformed element hierarchies">4.1.3. 変形d要素の階層</h4>

<p>
`変形d要素$は，既定では、
`~3D描画~文脈$を作成せず，自身の内容の平坦~化された表現を作成する。
この平坦~化する挙動は、
`transform-style$p ~propに値 `preserve-3d^v を指定して上書きできる
— それは、
同じ~3D空間に共存する，変形された~objたちが成す階層を構築するために有用になる。
これは、［
`変形d要素$の子孫たちが，同じ~3D描画~文脈に共存する
］ことを許容する。
その種の要素の~3D変形されない子孫たちは，
上述の段 C 【？】における要素の平面に描画される一方、
同じ~3D描画~文脈に共存する`~3D変形d要素$は，
各自が自前の平面から “飛び出す” 。
◎
By default, transformed elements do not create a 3D rendering context and create a flattened representation of their content. However, since it is useful to construct hierarchies of transformed objects that share a common 3-dimensional space, this flattening behavior may be overridden by specifying a value of preserve-3d for the transform-style property. This allows descendants of the transformed element to share the same 3D rendering context. Non-3D-transformed descendants of such elements are rendered into the plane of the element in step C above, but 3D-transformed elements in the same 3D rendering context will "pop out" into their own planes.
</p>

<div class="example">
<pre class="lang-html">
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  perspective: 500px;
  border: 1px solid black;
}
.transformed {
  `transform-style^p: `preserve-3d^v;
  transform: rotateY(50deg);
  background-color: blue; /* <span class="comment">青色</span> */
}
.child {
  transform-origin: top left;
  transform: rotateX(40deg);
  background-color: lime; /* <span class="comment">黄緑色</span> */
}
&lt;/style&gt;</pre>

<p>
この例は、
青色な要素に <code class="css">`transform-style$p: `preserve-3d^v</code>
が追加されたことを除いて，前の例と一致する。
青色な要素は今や，その容器の~3D描画~文脈を拡張する。
それにより，青色な要素と黄緑色な要素は同じ~3D空間に共存するので、
黄緑色な要素は，容器~上の遠近法の~~影響を受け，その親から【~3D的に】傾けられて描画される。
◎
This example is identical to the previous example, with the addition of transform-style: preserve-3d on the blue element. The blue element now extends the 3D rendering context of its container. Now both blue and lime elements share a common three-dimensional space, so the lime element renders as tilting out from its parent, influenced by the perspective on the container.
</p>

<figure>
<p class="alt" hidden id="_dgm-3d-rendering-context-3d">
入子にされた~3D変形が `preserve-3d^v を伴う場合の見本~描画。
◎
Nested 3D transforms, with preserve-3d.
</p>
</figure>

</div>

			</section>
			<section id="accumulated-3d-transformation-matrix-computation">
<h4 title="Accumulated 3D Transformation Matrix Computation">4.1.4. 累積d~3D変形n行列の算出</h4>

<div class="algo">
<p>
`~3D描画~文脈$に属する変形d要素 %現在の要素 の`累積~3D変形n行列$
— すなわち， %現在の要素 を描画する際に利用される変形の最終的な値 —
は、
次に従って算出される：
◎
The final value of the transform used to render an element in a 3D rendering context is computed by accumulating an accumulated 3D transformation matrix as follows:
</p>
<ol>
	<li>
%M ~LET 単位i行列
◎
Let transform be the identity matrix.
◎
↑Let current element be the transformed element.
◎
↓Let parent element be the parent element of the transformed element.
</li>
	<li>
%根 ~LET 当の`~3D描画~文脈$を確立した要素
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
◎
↓While current element is an element in the transformed element’s 3D rendering context:
<p>
		<ol>
			<li>
~IF［
%現在の要素 の `transform$p 値 ~NEQ `~none0$v
］
⇒
%M に［
%現在の要素 の`変形n行列$
］を`左から乗算-$する
◎
If current element has a value for transform which is not none, pre-multiply current element’s transformation matrix with the transform.
</li>
			<li>
%親 ~SET %現在の要素 の親
◎
↓</li>
			<li>
%M に［
次を表現する並進~行列
］を`左から乗算-$する
⇒
%親 からの， %現在の要素 の~offset（~scroll~offsetも含む）
◎
Compute a translation matrix which represents the offset (including the scroll offset) of current element from its parent element, and pre-multiply that matrix into the transform.
</li>
			<li>
~IF［
%親 の `perspective$p 値 ~NEQ `none$v
］
⇒
%M に［
%親 の`透視~行列$
］を`左から乗算-$する
◎
If parent element has a value for perspective which is not none, pre-multiply the parent element’s perspective matrix into the transform.
</li>
			<li>
~IF［
%現在の要素 ~EQ %根
］
⇒
~BREAK
◎
↑</li>
			<li>
%現在の要素 ~SET %親
◎
Let current element be the parent element.
◎
Let parent element be the current element’s parent.
</li>
		</ol>
	</li>
	<li>
~RET %M
</li>
</ol>
</div>

<p class="note">注記：
ここに述べたとおり，`累積~3D変形n行列$は、［
変形d要素, その`~3D描画~文脈$を確立した要素までにある先祖~連鎖を成す各~要素
］に対し，
`視覚-整形~model＠~CSS2J#visuren$により生成された~offset（~scroll~offsetも含む）を織り込む。
◎
Note: as described here, the accumulated 3D transformation matrix takes into account offsets (including the scroll offset) generated by the visual formatting model on the transformed element, and elements in its ancestor chain up to and including the element that establishes the its 3D rendering context.
</p>

			</section>
			<section id="backface-visibility">
<h4 title="Backface Visibility">4.1.5. 背面の可視性</h4>

<p>
~3D変形を利用すれば、
要素を［
その裏側が可視になるよう変形する
］こともアリになる。
`~3D変形d要素$は，その両側にて同じ内容を示すので、
裏側は表側の鏡像に見えるようになる（要素が鏡に映されたかのように）。
視点に対し裏側を向けている要素は，通常は可視であり続けるが、
`backface-visibility$p ~propにより，それを不可視にさせれる。
この挙動は “~~動的（ `live^en ）” である
— 例えば、
`backface-visibility$p に `hidden^v を伴う要素が，
その［
表側, 裏側
］が交互に可視になるよう~animateされた場合、
表側が視点に向くときに限り可視になる
◎
Using three-dimensional transforms, it’s possible to transform an element such that its reverse side is visible. 3D-transformed elements show the same content on both sides, so the reverse side looks like a mirror-image of the front side (as if the element were projected onto a sheet of glass). Normally, elements whose reverse side is towards the viewer remain visible. However, the backface-visibility property allows the author to make an element invisible when its reverse side is towards the viewer. This behavior is "live"; if an element with backface-visibility: hidden were animating, such that its front and reverse sides were alternately visible, then it would only be visible when the front side were towards the viewer.
</p>

<p>
要素の裏側の可視性は，`累積~3D変形n行列$を利用して考慮されるので、
`~3D描画~文脈$を確立している要素の親に相対的になる。
【可視性は、この親に垂直な方向から決まる？】
◎
Visibility of the reverse side of an element is considered using the accumulated 3D transformation matrix, and is thus relative to the parent of the element that establishes the 3D rendering context.
</p>

<p class="note">注記：
この~propは、
遊戯用~cardを作成するときのように， 2 個の要素を裏表に貼り合わせるときに有用になる。
この~propを伴わない下では、
~animationの間に~cardを裏返すためには，
その時点で［
表面の要素, 裏面の要素
］の場所を入れ替えることになる。
別の例として、
6 個の要素で囲まれた~~直方体の内側~面だけを見せるよう欲されるときが挙げられる。
◎
Note: This property is useful when you place two elements back-to-back, as you would to create a playing card. Without this property, the front and back elements could switch places at times during an animation to flip the card. Another example is creating a box out of 6 elements, but where you want to see only the inside faces of the box.
</p>

<div class="example">
<p>
次の例に、
`#card^css 要素が~clickされたとき，裏返されるように見せる方法を示す。
裏返されるとき平坦になるのを避けるため、
`#card^css には
<samp class="css">`transform-style^p: `preserve-3d^v</samp>
が必要yなことに注意。
◎
This example shows how to make a "card" element that flips over when clicked. Note the "transform-style: preserve-3d" on #card which is necessary to avoid flattening when flipped.
</p>

<pre class="lang-html">
&lt;style&gt;
.body { perspective: 500px; }
#card {
    position: relative;
    height: 300px; width: 200px;
    transition: transform 1s;
    transform-style: preserve-3d;
}
#card.flipped {
    transform: rotateY(180deg);
}
.face {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: silver;
    border-radius: 40px;
    backface-visibility: hidden;
}
.back {
    transform: rotateY(180deg);
}
&lt;/style&gt;
&lt;div id="card" onclick="this.classList.toggle('flipped')"&gt;
    &lt;div class="front face"&gt;Front&lt;/div&gt;
    &lt;div class="back face"&gt;Back&lt;/div&gt;
&lt;/div&gt;
</pre>

</div>

<p class="issue">
`backface-visibility^p は
非~変形d要素／ ~2D`変形d要素$には どう影響iする？
各自の自前の平面の中へ 【！＊】 `pop^en され, 交差するのか？【？】
◎
what is the impact of backface-visibility on non-transformed or 2D-transformed elements? Do they get popped into their own planes and intersect?
</p>

			</section>
		</section>
		<section id="processing-of-perspective-transformed-boxes">
<h3 title="Processing of Perspective-Transformed Boxes">4.2. 遠近法により変形された~boxの処理-法</h3>

<p class="issue">
これは、［
供された行列を利用して，要素を どこまで正確に変形するか
］を精確に指定するための最初の試案であり，
理想的ではないかもしれない
— 実装者からの~feedbackが奨励される。
`912$issue を見よ。
◎
This is a first pass at an attempt to precisely specify how exactly to transform elements using the provided matrices. It might not be ideal, and implementer feedback is encouraged. See #912.
</p>

<p>
`累積~3D変形n行列$は、
`perspective$p ~prop, および
`transform$p ~prop値の中に在る `perspective()^v 変形-関数から影響される。
◎
The accumulated 3D transformation matrix is affected both by the perspective property, and by any perspective() transform function present in the value of the transform property.
</p>

<p>
この`累積~3D変形n行列$は 4×4 行列であるが、
変形される~objは~2D~boxである。
~boxの各~隅
( %a, %b )
を変形するためには、
まず，~4Dの点 ( %a, %b, 0 ,1 ) に対し当の行列を適用して，
結果の点 ( %x, %y, %z, %w ) を次に従って変形して，
~3Dの点 ( %x′, %y′, %z′) へ戻すモノトスル：
◎
This accumulated 3D transformation matrix is a 4×4 matrix, while the objects to be transformed are two-dimensional boxes. To transform each corner (a, b) of a box, the matrix must first be applied to (a, b, 0, 1), which will result in a four-dimensional point (x, y, z, w). This is transformed back to a three-dimensional point (x′, y′, z′) as follows:
</p>

<p class="trans-note">【
すなわち、
~2D空間を~3D射影~空間に埋込んだ上で，
4 次~行列により写像した結果を~3D空間へ戻す。
】</p>
<ul>
	<li>
%w &gt; 0 の場合
⇒
( %x′, %y′, %z′) = ( %x ÷ %w, %y ÷ %w, %z ÷ %w )
◎
If w &gt; 0, (x′, y′, z′) = (x/w, y/w, z/w).
</li>
	<li>
<p>
%w = 0 の場合
⇒
( %x′, %y′, %z′) = ( %x × %n, %y × %n, %z × %n )
◎
If w = 0, (x′, y′, z′) = (x ⋅ n, y ⋅ n, z ⋅ n).＼
</p>

<p>
%n
は実装に依存する値であり、
アリなら［
%x′, %y′ どちらかは、
表示域~sizeより ずっと大きくなる
］ように選ぶべきである。
例えば， %n = 1000 にした場合、
( `5px^v, `22px^v, `0px^v, `0^v )
に対しては
( `5000px^v, `22000px^v, `0px^v )
になるが、
この %n の値は，
( `0.1px^v, `0.05px^v, `0px^v, `0^v )
に対しては小さ過ぎることになる。
この仕様は、
%n について正確な値は定義しない。
概念的には、
( %x′, %y′, %z′ )
は
( %x, %y, %z )
方向の`無限遠＠https://en.wikipedia.org/wiki/Plane_at_infinity$にある。
◎
n is an implementation-dependent value that should be chosen so that x′ or y′ is much larger than the viewport size, if possible. For example, (5px, 22px, 0px, 0) might become (5000px, 22000px, 0px), with n = 1000, but this value of n would be too small for (0.1px, 0.05px, 0px, 0). This specification does not define the value of n exactly. Conceptually, (x′, y′, z′) is infinitely far in the direction (x, y, z).
</p>

<p class="trans-note">【
すなわち、
射影~空間の中の［
現実の~3D空間では表現し得ない無限遠な点
］に対しては，なるべく近い表示になる（実装定義な）値で~~代用する。
】</p>
	</li>
</ul>

<p>
変形された~boxの 4 隅すべてで %w ~LT 0 になる場合、
~boxは描画されない。
◎
If w &lt; 0 for all four corners of the transformed box, the box is not rendered.
</p>

<p>
変形された~boxの 1 〜 3 個の隅で %w ~LT 0 になる場合、
~boxを［
~boxを成す［
%w ~LT 0 へ写像される部分
］を~boxから切り取った結果
］に置換するモノトスル。
これは一般に、
3 〜 5 個の頂点からなる多角形になり，
うち 2 個の隣接する頂点では %w ~EQ 0, 残りの頂点では %w ~GT 0 になる。
次に，これらの頂点は、
前段落の規則を利用して~3Dの点に変形される。
概念的には、
%w ~LT 0 になる点は，`視点$の “背後” にある
— なので、
可視にならないべきである。
◎
If w &lt; 0 for one to three corners of the transformed box, the box must be replaced by a polygon that has any parts with w &lt; 0 cut out. This will in general be a polygon with three to five vertices, of which exactly two will have w = 0 and the rest w &gt; 0. These vertices are then transformed to three-dimensional points using the rules just stated. Conceptually, a point with w &lt; 0 is "behind" the viewer, so should not be visible.
</p>

<div class="example">
<pre class="lang-css">
.transformed {
  height: 100px;
  width: 100px;
  background: lime;
  transform: perspective(50px) translateZ(100px);
}
</pre>

<p>
~boxのどの隅の %z 座標も，`perspective$f に与えた視点の Z 座標より大きい。
これは~boxが視点の背後にあって表示されないことを意味する。
数学的には、
点
( %x, %y )
は，まず
( %x, %y, 0, 1 )
にされた後，
( %x, %y, 100, 1 )
へ並進され，遠近法が適用されて
( %x, %y, 100, −1 )
になる。
この座標は %w ~LT 0 になるので，表示されない。
実装は %w ~LT 0 になる事例を分けて取扱う必要がある。
さもなければ、
この座標を −1 で除算した
( − %x, − %y, −100 )
による，不正な表示（~boxの鏡像）になり得る。
◎
All of the box’s corners have z-coordinates greater than the perspective. This means that the box is behind the viewer and will not display. Mathematically, the point (x, y) first becomes (x, y, 0, 1), then is translated to (x, y, 100, 1), and then applying the perspective results in (x, y, 100, −1). The w-coordinate is negative, so it does not display. An implementation that doesn’t handle the w &lt; 0 case separately might incorrectly display this point as (−x, −y, −100), dividing by −1 and mirroring the box.
</p>
</div>

<div class="example">
<pre class="lang-css">
.transformed {
  height: 100px;
  width: 100px;
  background: radial-gradient(yellow, blue);     /* <span class="comment">黄色, 青色</span> */
  transform: perspective(50px) translateZ(50px);
}
</pre>

<p>
ここでは、
~boxは，中心が視点と同じ所に据えられように，上層へ並進される。
これは，視界~全体が埋まるまで，~boxを限りなく視点に近付けるようにする。
既定の `transform-origin$p は~boxの中心にあり，そこは黄色に塗られるので、
~screenは黄色で埋められることになる。
◎
Here, the box is translated upward so that it sits at the same place the viewer is looking from. This is like bringing the box closer and closer to one’s eye until it fills the entire field of vision. Since the default transform-origin is at the center of the box, which is yellow, the screen will be filled with yellow.
</p>

<p>
数学的には、
点
( %x, %y )
は，まず
( %x, %y, 0, 1 )
としてから,
( %x, %y, 50, 1 )
へ並進され,
遠近法を適用した結果は
( %x, %y, 50, 0 )
になる。
左上~隅は、
中心にある変形-原点から相対的に
( −50, −50 )
の所にあるので，結果の左上~隅は
( −50, −50, 50, 0 )
になる。
これは左上から十分に遠い ある地点，例えば
( −5000, −5000, 5000 )
へ変形される。
同様に、
他の隅も十分に遠い所へ移される。
~box全体に引き延ばされる `radial-gradient$f は，今や非常に広大になるので、
可視~部分は
— ~scrollされていないとするなら —
中央の画素の色, 黄色になるはずである。
しかしながら，~boxは実際には無限でないので、
利用者は，依然として［
周辺まで~scrollして青色~部分を見る
］ことも可能になる。
◎
Mathematically, the point (x, y) first becomes (x, y, 0, 1), then is translated to (x, y, 50, 1), then becomes (x, y, 50, 0) after applying perspective. Relative to the transform-origin at the center, the upper-left corner was (−50, −50), so it becomes (−50, −50, 50, 0). This is transformed to something very far to the upper left, such as (−5000, −5000, 5000). Likewise the other corners are sent very far away. The radial gradient is stretched over the whole box, now enormous, so the part that’s visible without scrolling should be the color of the middle pixel: yellow. However, since the box is not actually infinite, the user can still scroll to the edges to see the blue parts.
</p>
</div>

<div class="example">
<pre class="lang-css">
.transformed {
  height: 50px;
  width: 50px;
  background: lime;
  border: 25px solid blue;
  transform-origin: left;
  transform: perspective(50px) rotateY(-45deg);
}
</pre>

<p>
~boxの左~辺は固定され、
右~辺は扉が開く様に，`視点$に向かって 45° 回転されることになる。
右~辺は、
遠近法の値 `50px^v より大きい %z = `70.7px^v の所にあるので，
（視点の “背後” に）消失することになり、
可視な部分は，右方へ無限に遠くまで引き延ばされることになる。
◎
The box will be rotated toward the viewer, with the left edge staying fixed while the right edge swings closer. The right edge will be at about z = 70.7px, which is closer than the perspective of 50px. Therefore, the rightmost edge will vanish ("behind" the viewer), and the visible part will stretch out infinitely far to the right.
</p>

<p>
数学的には、
元々は変形-原点から相対的に ( 100, −50 ) の所にあった~boxの右上~頂点は、
まず ( 100, −50, 0, 1 ) に展開されてから，指定された変形が適用され、
およそ ( 70.71, −50, 70.71, −0.4142 ) の所に写像される。
この %w 座標 −0.4142 は負なので，~boxを成す［
%w ~LT 0 へ写像される部分
］を切り取る必要がある。
その結果，新たな右上~頂点は
( 50, −50, 50, 0 )
になる。
次に，
これは同じ方向にある, 変形-原点から右上方へ遠く離れたある点
（例えば ( 5000, −5000, 5000 ) ）
へ写像される。
右下~隅についても同様の演算が行われ，遠く右下方へ写像される。
結果の~boxは、
~screenの辺を大きく越えて延ばされる。
◎
Mathematically, the top right vertex of the box was originally (100, −50), relative to the transform-origin. It is first expanded to (100, −50, 0, 1). After applying the transform specified, this will get mapped to about (70.71, −50, 70.71, −0.4142). This has w = −0.4142 &lt; 0, so we need to slice away the part of the box with w &lt; 0. This results in the new top-right vertex being (50, −50, 50, 0). This is then mapped to some faraway point in the same direction, such as (5000, −5000, 5000), which is up and to the right from the transform-origin. Something similar is done to the lower right corner, which gets mapped far down and to the right. The resulting box stretches far past the edge of the screen.
</p>

<p>
ここでも、
描画される~boxは依然として有限であり，利用者は~scrollして全部を見れる。
しかしながら、
右側部分
— 元の~boxの右~端から `30px^v 程の部分 —
は，すでに切り取られており、
利用者がどこまで~scrollしようが，可視にならない。
幅 `25px^v の青色な~borderについては、
左端, 上端, 下端は可視になるが，右端は可視にならない。
◎
Again, the rendered box is still finite, so the user can scroll to see the whole thing if they choose. However, the right part has been chopped off. No matter how far the user scrolls, the rightmost 30px or so of the original box will not be visible. The blue border was only 25px wide, so it will be visible on the left, top, and bottom, but not the right.
</p>

<p>
［
1 個／ 3 個
］の頂点で %w ~LT 0 になる場合も、
同じ基本的な手続-が適用されることになる。
ただし、
この場合に［
%w ~LT 0 へ写像される部分
］を切り取った結果は、
四辺形ではなく［
三角形／五角形
］になる。
◎
The same basic procedure would apply if one or three vertices had w &lt; 0. However, in that case the result of truncating the w &lt; 0 part would be a triangle or pentagon instead of a quadrilateral.
</p>
</div>

		</section>
	</section>

	<section id="individual-transforms">
<h2 title="Individual Transform Properties: the translate, scale, and rotate properties">5. 個別的な変形~prop：`translate^p, `scale^p, `rotate^p</h2>

<p>
［
`translate$p, `rotate$p, `scale$p
］~propは、［
~UIにおける代表的な用法に対応する仕方で，単純な変形を独立に指定する
］ことを作者に許容する
— `transform$p における［
`translate$f, `rotate$f, `scale$f
］の動作の順序を覚えずに済むよう。
これらの~propは、
それらの動作（同順）を `transform$p とは独立に保って，~screen座標~内で動作する。
【すなわち，これらの~propによる変形は、`決められた順序＠#ctm$で適用される。】
◎
The translate, rotate, and scale properties allow authors to specify simple transforms independently, in a way that maps to typical user interface usage, rather than having to remember the order in transform that keeps the actions of translate(), rotate() and scale() independent and acting in screen coordinates.
</p>

<div>
◎名 `translate@p
◎値 `~none0$v | `length-percentage$t [ `length-percentage$t `length$t? ]?
◎初 `none^v
◎適 `変形-可能$な要素
◎継 されない
◎百 ［
1 個目／ 2 個目
］の値は、
`基準~box$の［
横幅／縦幅
］に相対的
◎算 
~keyword `none^v ／ 
2 個の［
`length-percentage$t の算出d値
］と 1 個の`算出d長さ$
◎順 文法に従う
◎ア 算出された値~型による
— ただし， `none^v については下を見よ
◎表終
◎
Name: 	translate
Value: 	none | &lt;length-percentage&gt; [ &lt;length-percentage&gt; &lt;length&gt;? ]?
Initial: 	none
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	relative to the width of the reference box (for the first value) or the height (for the second value)
Computed value: 	the keyword none or a pair of computed &lt;length-percentage&gt; values and an absolute length
Canonical order: 	per grammar
Animation type: 	by computed value, but see below for none
</div>

<p>
`translate$p ~propは、
順に［
X, Y, Z
］軸~~方向の並進を指定する 1 〜 3 個の値を受容する：
◎
The translate property accepts 1-3 values, each specifying a translation against one axis, in the order X, Y, then Z.＼
</p>
<ul>
	<li>
［
2 個目／3 個目
］の値が省略された場合の既定は、
`0px^v とする。
◎
When the second or third values are missing, they default to 0px.
</li>
	<li>
<p>
3 個目の値が：
◎
If the third value＼
</p>
		<ul>
			<li>
［
省略された／ 0 をとる
］場合、
~2D並進を指定する
— `translate$f 関数と等価になる。
◎
is omitted or zero, this specifies a 2d translation, equivalent to the translate() function.＼
</li>
			<li>
他の場合、
~3D並進を指定する
— `translate3d$f 関数と等価になる。
◎
Otherwise, this specifies a 3d translation, equivalent to the translate3d() function.
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
`translate$p ~propの`解決d値$は`算出d値$なので、
`getComputedStyle()$c の結果は百分率~値を含む【百分率~値が指定された場合には】。
◎
Note: The resolved value of the translate property is the computed value, and thus getComputedStyle() includes percentage values in its results.
</p>

<div>
◎名 `rotate@p
◎値 `~none0$v | `angle$t | [ `x$v | `y$v | `z$v | `number$t{3} ]? &amp;&amp; `angle$t
◎初 `none^v
◎適 `変形-可能$な要素
◎継 されない
◎百 受容しない
◎算 ［
~keyword `none^v ／ `angle$t
］と回転~軸を表現する［
3 個の `number$t が成す~list
］
◎順 文法に従う
◎ア SLERP として
【`~~参照＠#interpolation-of-decomposed-3d-matrix-values$】
— ただし， `none^v については下を見よ
◎表終
◎
Name: 	rotate
Value: 	none | &lt;angle&gt; | [ x | y | z | &lt;number&gt;{3} ] &amp;&amp; &lt;angle&gt;
Initial: 	none
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	the keyword none, or an &lt;angle&gt; with an axis consisting of a list of three &lt;number&gt;s
Canonical order: 	per grammar
Animation type: 	as SLERP, but see below for none
</div>

<p>
`rotate$p ~propは、
次を受容する
⇒＃
要素を回転する角度（ `angle^t ）,
どの軸~周りで回転するか（省略可能）
◎
The rotate property accepts an angle to rotate an element, and optionally an axis to rotate it around.
</p>

<p>
軸は、
次に挙げるいずれかで指定できる：
◎
↓</p>
<ul>
	<li>
~keyword［
`x@v ／
`y@v ／
`z@v
］
⇒
順に［
x ／ y ／ z
］軸~周りの回転を指定する
— ［
`rotateX$f ／ `rotateY$f ／ `rotateZ$f 
］関数と等価になる。
◎
The axis can be specified with either the x, y, or z keywords, which specify a rotation around that axis, equivalent to the rotateX(), rotateY(), and rotateZ() transform functions.＼
</li>
	<li>
3 個の `number$t
⇒
原点からの~vectorを成す［
x, y, z
］成分を順に表現する 
— `rotate3d$f 関数と等価になる。
◎
Alternately, the axis can be specified explicitly by giving three numbers representing the x, y, and z components of an origin-centered vector, equivalent to the rotate3d() function.
</li>
</ul>

<p>
`angle$t のみが指定された場合、
z 軸~周りの回転になり，［
~keyword `z$v ／
~vector [ 0, 0, 正な値 ]
］が指定された場合と同じに挙動する。
それらは、
どれも `rotate$f 関数と等価な~2D回転になる
（例えば、
`rotate$p 用の値［
`30deg^v,
`z 30deg^v,
`0 0 1 30deg^v
］は互いに等価になる）。
◎
There is no difference in behavior between a rotation specified as an &lt;angle&gt; alone and a rotation specified as being around the z-axis (whether by the z keyword or by a vector whose first two components are zero and third component is positive); they are all 2d rotations equivalent to the rotate() function. For example, rotate: 30deg, rotate: z 30deg, and rotate: 0 0 1 30deg are equivalent.
</p>

<div>
◎名 `scale@p
◎値 `~none0$v | [ `number$t | `percentage$t ]{1,3} 
◎初 `none^v
◎適 `変形-可能$な要素
◎継 されない
◎百 受容しない
◎算 ~keyword `none^v ／ 3 個の `number$t が成す~list
◎順 文法に従う
◎ア 算出された値~型による
— ただし， `none^v については下を見よ
◎表終
◎
Name: 	scale
Value: 	none | [ &lt;number&gt; | &lt;percentage&gt; ]{1,3}
Initial: 	none
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	n/a
Computed value: 	the keyword none, or a list of 3 &lt;number&gt;s
Canonical order: 	per grammar
Animation type: 	by computed value, but see below for none
</div>

<p>
`scale$p ~propは、
順に［
X, Y, Z
］軸~~方向の拡縮率を指定する 1 〜 3 個の値を受容する：
◎
The scale property accepts 1-3 values, each specifying a scale along one axis, in order X, Y, then Z.
</p>
<ul>
	<li>
2 個目の値（ Y ）が省略された場合の既定は、
1 個目の値（ X ）と同じになる。
◎
If the Y value is not given, then it defaults to being the same as the X value.
</li>
	<li>
3 個目の値（ Z ）が省略された場合の既定は、
`1^v になる。
◎
If the Z value is not given, then it defaults to 1.
</li>
	<li>
<p>
3 個目の値が：
</p>
		<ul>
			<li>
［
省略された／ `1^v をとる／ `100%^v をとる
］場合、
~2D拡縮ngを指定する
— `scale$f 関数と等価になる。
これらの各場合の挙動に相違は無い。
</li>
			<li>
他の場合、
~3D拡縮ngを指定する
— `scale3d$f 関数と等価になる。
</li>
		</ul>
◎
If the third value is omitted, 1, or 100%, this specifies a 2d scaling, equivalent to the scale() function.＼
Otherwise, this specifies a 3d scaling, equivalent to the scale3d() function.
◎
There is no difference in behavior between the third value being omitted and the third value being 1 or 100%.
</li>
</ul>

<p>
`scale$p に指定された `percentage$t は、
同じ~~比率を与える
`number$t と等価になる
— 例えば，値 `100%^v は `1^v と等価になる。
これらの `percentage$t の直列化には、
`number$t が利用される。
◎
A &lt;percentage&gt; is equivalent to a &lt;number&gt;, for example scale: 100% is equivalent to scale: 1. Numbers are used during serialization of specified and computed values.
</p>

<p>
これら 3 種の~propは、
いずれも
`~none0@v
を既定の値として受容する
— それは、
まったく変形を施さないことを指示する。
特に，この値は、
積層~文脈や`すべての子孫~用の包含塊$の作成を<em>誘発しない</em>。
一方で，他のすべての値は
（ <code class="css">`translate$p: `0px^v</code> の様な “恒等” 変形も含む）、
変形~用の通例にしたがって，［
積層~文脈, `すべての子孫~用の包含塊$
］を作成させる。
◎
All three properties accept (and default to) the value none, which produces no transform at all. In particular, this value does not trigger the creation of a stacking context or containing block for all descendants, while all other values (including “identity” transforms like translate: 0px) create a stacking context and containing block for all descendants, per usual for transforms.
</p>

<p>
［
`translate$p ／ `rotate$p ／ `scale$p
］が［
~animateまたは遷移-
］していて，その［
<b>from</b> 値, <b>to</b> 値
］のうち片方だけ `none^v をとる場合、
その `none^v は，等価な恒等~変形~値［
`0px^v ／ `0deg^v ／ `1^v
］に置換される。
◎
When translate, rotate or scale are animating or transitioning, and the from value or to value (but not both) is none, the value none is replaced by the equivalent identity value (0px for translate, 0deg for rotate, 1 for scale).
</p>

		<section id="individual-transform-serialization">
<h3 title="Serialization">5.1. 直列化</h3>

<p>
［
`translate$p ／ `rotate$p ／ `scale$p
］~prop【の算出d値】を直列化するときは、
次に従うモノトスル：
◎
Because these properties have two distinct modes of behavior (no transform versus transform), serialization must take this into account:
</p>

<ul>
	<li>
いずれの~propも，
~keyword `~none0$v （変形なし）をとる【！originally specified】場合、
`none^v に直列化する。
（恒等~変形は、
これに該当しない（変形あり）ので，以下に従う。）
◎
↑↓</li>
	<li>
<p>
他の場合、
~propに応じて：
</p>
		<dl class="switch">
			<dt>
`translate$p
◎
for translate
</dt>
			<dd>
<p>
3 個の値として直列化する
— ただし、
3 個目の値は `0px^v （既定）をとる場合：
</p>
				<ul>
					<li>
直列化においては，通例通り 3 個目の値を省略する。
</li>
					<li>
加えて，
2 個目の値も `0px^v （既定）をとる場合、
直列化においては，通例通り 2 個目の値も省略する。
</li>
				</ul>
◎
If a translation is specified, the property must serialize with one through three values. (As usual, if the second and third values are 0px, the default, or if only the third value is 0px, then those 0px values must be omitted when serializing).
◎
↑ It must serialize as the keyword none if and only if none was originally specified. (An identity transform does not count; it must serialize as 0px.)
</dd>

			<dt>
`rotate$p
◎
for rotate
</dt>
			<dd>
<p>
［
軸を表す 3 個の値
］および `angle$t として直列化する
— ただし：
</p>
				<ul>
					<li>
z 軸~周りの回転（すなわち，~2D回転）である場合、
直列化においては，軸を省略する。
</li>
					<li>
［
x ／ y
］軸~周りの回転である場合、
軸を~keyword［
`x^v ／ `y^v
］に直列化する。
</li>
				</ul>
◎
If a rotation about the z axis (that is, in 2D) is specified, the property must serialize as just an &lt;angle&gt;.
◎
If any other rotation is specified, the property must serialize with an axis specified. If the axis is parallel with the x or y axes, it must serialize as the appropriate keyword.
◎
↑ It must serialize as the keyword none if and only if none was originally specified. (An identity transform does not count; it must serialize as 0deg.)
</dd>

			<dt>
`scale$p
◎
for scale
</dt>
			<dd>
<p>
3 個の値として直列化する
— ただし、
3 個目の値は `1^v （既定）をとる場合：
</p>
				<ul>
					<li>
直列化においては，通例通り 3 個目の値を省略する。
</li>
					<li>
加えて， 2 個目の値は 1 個目と同じ値（既定）をとる場合、
直列化においては，通例通り 2 個目の値も省略する。
</li>
				</ul>
◎
If a scale is specified, the property must serialize with only one through three values. As usual, if the third value is 1, the default, then it is omitted when serializing. If the third value is omitted and the second value is the same as the first (the default), then the second value is also omitted when serializing.
◎
↑ It must serialize as the keyword none if and only if none was originally specified. (An identity transform does not count; it must serialize as 1.)
</dd>
		</dl>
	</li>
</ul>

		</section>
	</section>
	<section id="ctm">
<h2 title="Current Transformation Matrix">6. 現在の変形n行列</h2>

<p id="transformation-matrix-computation">
`変形n行列$は、
次に従って［
`transform$p,
`transform-origin$p,
`translate$p,
`rotate$p,
`scale$p,
`offset$p
］~propから算出されるよう改正される
— それは、
単位i行列に対し，以下の変形nを累積する
【各~変形nを表現する行列を，所与の順に`右から乗算-$する】：
◎
The transformation matrix computation is amended to the following:
◎
The transformation matrix is computed from the transform, transform-origin, translate, rotate, scale, and offset properties as follows:
• Start with the identity matrix.
</p>

<ol>
	<li>
`transform-origin$p の算出d値による`~3D並進$
◎
Translate by the computed X, Y, and Z values of transform-origin.
</li>
	<li>
`translate$p の算出d値による`~3D並進$
◎
Translate by the computed X, Y, and Z values of translate.
</li>
	<li>
`rotate$p の算出d値による`~3D回転$
◎
Rotate by the computed &lt;angle&gt; about the specified axis of rotate.
</li>
	<li>
`scale$p の算出d値による`~3D拡縮ng$
◎
Scale by the computed X, Y, and Z values of scale.
</li>
	<li>
`offset$p により指定される変形（~2D並進と~2D回転）
◎
Translate and rotate by the transform specified by offset.
</li>
	<li>
`transform$p の値【算出d値？】に~listされた順で与えられる，各~変形-関数
◎
Multiply by each of the transform functions in transform from left to right.
</li>
	<li>
最初の段に与えたものとは逆方向への並進【逆行列】
◎
Translate by the negated computed X, Y and Z values of transform-origin.
</li>
</ol>

	</section>
	<section id="transform-style-property">
<h2 title="The transform-style Property">7. `transform-style^p ~prop</h2>

<div>
◎名 `transform-style@p
◎値 `flat^v | `preserve-3d^v
◎初 `flat^v
◎適 `変形-可能$な要素
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎使 `~group化~prop値$が［
在るならば `flat^v ／
無いならば 指定された~keyword
］
◎表終
◎
Name: 	transform-style
Value: 	flat | preserve-3d
Initial: 	flat
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	N/A
Computed value: 	specified keyword
Canonical order: 	per grammar
Animation type: 	discrete
Used value: 	flat if a grouping property is present, specified keyword otherwise
</div>

<p>
`変形-可能$な要素の `transform-style$p の算出d値が `preserve-3d^v になる場合、
要素は［
`積層~文脈$, `すべての子孫~用の包含塊$
］の両者を確立する。
`使用~値$が `preserve-3d^v になる場合、
`~3D描画~文脈$も［
確立する／拡張する
］。
◎
A computed value of preserve-3d for transform-style on a transformable element establishes both a stacking context and a containing block for all descendants. If the used value is preserve-3d then it also establishes or extends a 3D rendering context.
</p>

		<section id="grouping-property-values">
<h3 title="Grouping property values">7.1. ~group化~prop値</h3>

<p>
次の表tを成す各行に対し，［
1 列目に挙げる~prop用の 2 列目に挙げる値
］は、［
適用し得るようになる前に，子孫~要素たちが成す平坦~化された表現を作成する
］ことを~UAに要求する。
したがって、［
当の要素の `transform-style$p 用の値 `preserve-3d^v
］用の`使用~値$を `flat^v に強制する：
◎
The following CSS property values require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore force the element to have a used style of flat for preserve-3d.
</p>

<div>
<table><thead><tr><th>~prop
<th>値
<tbody>

<tr><td>`overflow$p
<td>`visible$v, `clip$v 以外の値

<tr><td>`opacity$p
<td>1 未満の値

<tr><td>`filter$p
<td>`none^v 以外の値

<tr><td>`clip$p
<td>`auto^v 以外の値

<tr><td>`clip-path$p
<td>`none^v 以外の値

<tr><td>`isolation$p
<td>`使用~値$ `isolate^v

<tr><td>`mask-image$p
<td>`none^v 以外の値

<tr><td>`mask-border-source$p
<td>`none^v 以外の値

<tr><td>`mix-blend-mode$p
<td>`normal^v 以外の値

<tr><td>`contain$p
<td>`paint$v

<tr><td>`contain$p 以外
<td>
<p>
`塗り封込め$をもたらす値
</p>

<p class="note">注記：
これに該当し得るのは、
`contain$p ~propの`使用~値$に影響する［
~propと値
］の組合nになる
<code class="css">`content-visibility$p: `hidden^v</code>
など。
</p>
</table>

◎
overflow: any value other than visible or clip.
◎
opacity: any value less than 1.
◎
filter: any value other than none.
◎
clip: any value other than auto.
◎
clip-path: any value other than none.
◎
isolation: used value of isolate.
◎
mask-image: any value other than none.
◎
mask-border-source: any value other than none.
◎
mix-blend-mode: any value other than normal.
◎
contain: paint and any other property/value combination that causes paint containment.＼
Note: this includes any property that affect the used value of the contain property, such as content-visibility: hidden.
</div>

		</section>
	</section>
	<section id="perspective-property">
<h2 title="The perspective Property">8. `perspective^p ~prop</h2>

<div>
◎名 `perspective@p
◎値
`none^v | `length [0,∞]$t
◎初 `none$v
◎適 `変形-可能$な要素
◎継 されない
◎百 受容しない
◎算 ~keyword `none$v ／`算出d長さ$
◎順 文法に従う
◎ア 算出された値~型による
◎表終
◎
Name: 	perspective
Value: 	none | &lt;length [0,∞]&gt;
Initial: 	none
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	N/A
Computed value: 	the keyword none or an absolute length
Canonical order: 	per grammar
Animation type: 	by computed value
</div>

<dl>
	<dt id="valdef-perspective-length-0">`length [0,∞]$t</dt>
	<dd>
射影の中心からの距離。
◎
Distance to the center of projection.
</dd>
	<dd class="issue">
射影が射影の中心までの距離であることを検証yする。【？】
◎
Verify that projection is the distance to the center of projection.
</dd>
	<dd>
ごく小さな `length$t 値は，［
奇妙な描画~結果を生産し得る／変形~計算の数量的な正確度を~~歪め得る
］ので、
`1px^v 未満の値は，描画の目的においては `1px^v として扱うモノトスル。
（この切詰めは下層の値には影響しないので、
~stylesheet内の
<code class="css">`perspective$p: `0^v</code>
を直列化した結果は，依然として `0^v になる。）
◎
As very small &lt;length&gt; values can produce bizarre rendering results and stress the numerical accuracy of transform calculations, values less than 1px must be treated as 1px for rendering purposes. (This clamping does not affect the underlying value, so perspective: 0; in a stylesheet will still serialize back as 0.)
</dd>

	<dt>`none@v</dt>
	<dd>
遠近法による変形は適用されない。
その効果は、
数学的には，無限大な `length$t 値に近似する。
すべての~objは、
~canvas上に平坦に現れる。
◎
No perspective transform is applied. The effect is mathematically similar to an infinite &lt;length&gt; value. All objects appear to be flat on the canvas.
</dd>
</dl>

<p>
この~propに `none$v 以外の値を利用した場合、
積層~文脈を確立する。
それは、
`transform$p ~propと同じく，`すべての子孫~用の包含塊$も確立する。
◎
The use of this property with any value other than none establishes a stacking context. It also establishes a containing block for all descendants, just like the transform property does.
</p>

<p class="issue">
［
積層~文脈／包含塊
］は，遠近法には本当は必要ではないが、
これを変更すると，~web互換性を得られなくなるであろう。
◎
We don’t really need to be a stacking context or containing block for perspective, but maybe webcompat means we can’t change this.
</p>

<p>
［
`perspective$p ／ `perspective-origin$p
］~propの値は、
上述に従って`透視~行列$の算出に利用される。
◎
The values of the perspective and perspective-origin properties are used to compute the perspective matrix, as described above.
</p>

	</section>
	<section id="perspective-origin-property">
<h2 title="The perspective-origin Property">9. `perspective-origin^p ~prop</h2>

<p>
`perspective-origin$p ~propは， `perspective$p ~prop用の原点を確立する。
それは、
実質的に，想定される［
要素の一連の子を俯瞰する`視点$
］の X, Y 位置を設定する。
◎
The perspective-origin property establishes the origin for the perspective property. It effectively sets the X and Y position at which the viewer appears to be looking at the children of the element.
</p>

<div>
◎名 `perspective-origin@p
◎値 `position$t
◎初 `50% 50%^v
◎適 `変形-可能$な要素
◎継 されない
◎百 `基準~box$の~sizeに相対的
◎算 `background-position$p を見よ
◎順 文法に従う
◎ア 算出された値~型による
◎表終
◎
Name: 	perspective-origin
Value: 	&lt;position&gt;
Initial: 	50% 50%
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	refer to the size of the reference box
Computed value: 	see background-position
Canonical order: 	per grammar
Animation type: 	by computed value
</div>

<p>
［
`perspective$p ／ `perspective-origin$p
］~propの値は、
上述に従って`透視~行列$の算出に利用される。
◎
The values of the perspective and perspective-origin properties are used to compute the perspective matrix, as described above.
</p>

<p>
`perspective-origin$p 用の値は、
遠近法の原点の［
`基準~box$の左上~隅からの~offset
］を表現する。
◎
The values for perspective-origin represent an offset of the perspective origin from the top left corner of the reference box.
</p>

<dl>
	<dt id="valdef-perspective-origin-percentage">`percentage$t</dt>
	<dd>
［
横／縦
］~offset用の百分率~値は，`基準~box$の［
横幅／縦幅
］に相対的になる。
【絶対~化された結果の】それは、
`基準~box$の左上~隅からの［
横／縦
］~offsetを表現する。
◎
A percentage for the horizontal perspective offset is relative to the width of the reference box. A percentage for the vertical offset is relative to height of the reference box. The value for the horizontal and vertical offset represent an offset from the top left corner of the reference box.
</dd>

	<dt id="valdef-perspective-origin-length">`length$t</dt>
	<dd>
~offsetとして固定的な長さを与える。
それは、
`基準~box$の左上~隅からの［
横／縦
］~offsetを表現する。
◎
A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the reference box.
</dd>

	<dt>`top@vp</dt>
	<dt>`right@vp</dt>
	<dt>`bottom@vp</dt>
	<dt>`left@vp</dt>
	<dd>
		<ul>
			<li>
所与の成分~値が 3 個~以上ある下で，これらの~keywordの直後の成分として［
`percentage^t ／ `length^t
］値が与えられた場合、
その値は，挙げられた順に［
上端, 右端, 下端, 左端
］辺からの~offsetを表現することになる。
</li>
			<li>
他の場合、
これらの~keywordは，挙げられた順に［
縦~位置~用の `0%^v,
横~位置~用の `100%^v,
縦~位置~用の `100%^v,
横~位置~用の `0%^v
］に算出される。
</li>
		</ul>

◎
Computes to 0% for the vertical position if one or two values are given, otherwise specifies the top edge as the origin for the next offset.
◎
Computes to 100% for the horizontal position if one or two values are given, otherwise specifies the right edge as the origin for the next offset.
◎
Computes to 100% for the vertical position if one or two values are given, otherwise specifies the bottom edge as the origin for the next offset.
◎
Computes to 0% for the horizontal position if one or two values are given, otherwise specifies the left edge as the origin for the next offset.
</dd>

	<dt>`center@vp</dt>
	<dd>
横~位置が指定されなかった場合、
横~位置~用の `50%^v 【！left 50%】に算出される。
他の場合、
縦~位置~用の `50%^v 【！top 50%】に算出される。
◎
Computes to 50% (left 50%) for the horizontal position if the horizontal position is not otherwise specified, or 50% (top 50%) for the vertical position if it is.
</dd>

</dl>

<p>
`perspective-origin$p の`解決d値$は、
<a href="~CSSOM1#resolved-value-special-case-property-like-height">`height^p の様に特別</a>
とする。
`CSSOM$r
◎
The perspective-origin property is a resolved value special case property like height. [CSSOM]
</p>

	</section>
	<section id="backface-visibility-property">
<h2 title="The backface-visibility Property">10. `backface-visibility^p ~prop</h2>

<div>
◎名 `backface-visibility@p
◎値 `visible^v | `hidden^v
◎初 `visible^v
◎適 `変形-可能$な要素
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終
◎
Name: 	backface-visibility
Value: 	visible | hidden
Initial: 	visible
Applies to: 	transformable elements
Inherited: 	no
Percentages: 	N/A
Computed value: 	specified keyword
Canonical order: 	per grammar
Animation type: 	discrete
</div>

<p>
`~3D描画~文脈$に関与する`変形-可能$な要素は、
その `backface-visibility$p の算出d値が `hidden^v になるならば，［
`積層~文脈$, `すべての子孫~用の包含塊$
］どちらも確立する。
◎
A computed value of hidden for backface-visibility on a transformable element that participates in a 3D rendering context establishes both a stacking context and a containing block for all descendants.
</p>

<p>
<code class="css">`backface-visibility$p: `hidden^v</code>
を伴う要素の可視性は、
次に従って決定される：
◎
The visibility of an element with backface-visibility: hidden is determined as follows:
</p>

<ol>
	<li>
要素の`累積~3D変形n行列$を算出する。
◎
Compute the element’s accumulated 3D transformation matrix.
</li>
	<li>
行列の `33^M 成分が負である場合、
要素は見えなくされるべきである。
他の場合は可視である。
◎
If the component of the matrix in row 3, column 3 is negative, then the element should be hidden. Otherwise it is visible.
</li>
</ol>

<p class="issue">
背面の可視性は `33^M を調べるだけでは判明しない。
`917$issue を見よ。
◎
Backface-visibility cannot be tested by only looking at m33. See #917.
</p>

<p class="trans-note">【
すなわち、
下に述べられている論拠の中の %z 値の大きさ比較と, 視点からの距離の比較は、
必ずしも整合しない（例えば、
矩形が Y 軸を中心に 90° 近く回転されていて，右方／左方に~~位置するとき）。
】</p>

<p class="note">注記：
この定義の論拠は次で与えられる：
要素が，薄さ無限小な x–y 平面に埋め込まれた矩形であるとする。
要素が変形されないときの［
表面／裏面
］の座標は，ある極小の %ε に対し
( %x, %y, %ε ) ／ ( %x, %y, − %ε )
になる。
変形-後，要素の表面が裏面よりも
`視点$に近くなる（ %z 値がより高くなる）か, 視点から遠くなるか
どうかを調べればよい。
表面の %z 座標は、
遠近法を織り込む前の段階で
`13^M × %x + `23^M × %y + `33^M × %ε + `43^M
になり，裏面は
`13^M × %x + `23^M × %y − `33^M × %ε + `43^M
になる。
前者の量が後者より大きくなるのは、
`33^M ~GT 0 のとき, そのときに限る。
（ 0 に等しいときは，視点からの表面と裏面の近さは等しくなる。
これはおそらく 90° 回転の様な何かを意味する
—
それは，いずれにせよ要素を不可視にするので、
消失するかどうかを考慮する必要はない）
◎
Note: The reasoning for this definition is as follows. Assume elements are rectangles in the x–y plane with infinitesimal thickness. The front of the untransformed element has coordinates like (x, y, ε), and the back is (x, y, −ε), for some very small ε. We want to know if after the transformation, the front of the element is closer to the viewer than the back (higher z-value) or further away. The z-coordinate of the front will be m13x + m23y + m33ε + m43, before accounting for perspective, and the back will be m13x + m23y − m33ε + m43. The first quantity is greater than the second if and only if m33 &gt; 0. (If it equals zero, the front and back are equally close to the viewer. This probably means something like a 90-degree rotation, which makes the element invisible anyway, so we don’t really care whether it vanishes.)
</p>

	</section>
	<section id="svg-three-dimensional-functions">
<h2 title="SVG and 3D transform functions">11. ~SVGと~3D変形-関数</h2>

<p>
この仕様は、
次に挙げる~SVG要素に対し，`~3D変形-関数$の適用-を明示的に要求する
⇒＃
`容器~要素$のうち `a$e, `g$e, `svg$e,
`~graphics要素$,
`~graphicを参照する要素$,
`foreignObject$e 要素
◎
This specification explicitly requires three-dimensional transform functions to apply to the container elements: a, g, svg, all graphics elements, all graphics referencing elements and the SVG foreignObject element.
</p>


<div>
<p>
［
`clipPath$e,
`linearGradient$e,
`radialGradient$e,
`pattern$e
］要素に対しては：
</p>
<ul>
	<li>
`~3D変形-関数$は利用できない。
これらの要素に利用された変形~listが`~3D変形-関数$を含む場合、
当の~list全体を無視するモノトスル。
</li>
	<li>
次に挙げる~propは利用できない
— それらの値は，無視するモノトスル
⇒＃
`perspective$p,
`perspective-origin$p,
`transform-style$p,
`backface-visibility$p
</li>
	<li>
これらの要素に包含された`変形-可能$な要素は、
~3D変形-関数を有し得る。
</li>
</ul>
◎
Three-dimensional transform functions and the properties perspective, perspective-origin, transform-style and backface-visibility can not be used for the elements: clipPath, linearGradient, radialGradient and pattern. If a transform list includes a three-dimensional transform function, the complete transform list must be ignored. The values of every previously named property must be ignored. Transformable elements that are contained by one of these elements can have three-dimensional transform functions.＼
</div>

<p>
［
`clipPath$e, `mask$e, `pattern$e
］要素は、［
適用し得るようになる前に，
子孫~要素たちが成す平坦~化された表現を作成する
］よう~UAに要求するので、
<code class="css">`transform-style$p: `preserve-3d^v</code>
の挙動を上書きする。
◎
The clipPath, mask, pattern elements require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore override the behavior of transform-style: preserve-3d.
</p>

<p>
`~3D描画~文脈$に属する~objに対しては、
`vector-effect$p ~propが `non-scaling-stroke^v に設定されても，~objの~stroke法には影響しない。
◎
If the vector-effect property is set to non-scaling-stroke and an object is within a 3D rendering context the property has no affect on stroking the object.
</p>

<p class="issue">
~SVGにおける~3D変形~関数の構文を正式に述べる
— `~2D関数~用に述べた＠~TRANSFORM#svg-syntax$のと同じく。
◎
formally describe the syntax of the 3D transform functions in SVG, as is done for the 2-D functions.
</p>

	</section>
	<section id="transform-functions">
<h2 title="The Transform Functions">12. 変形-関数</h2>

<p>
`transform$p ~propの値は
`transform-function@t
たちが成す~listである。
許容される変形-関数たちが成す集合は、
以下に与えられる。
この仕様において `angle$t が利用される所では、
0 に等しい `number$t も許容され，角度 0 として扱われる。
並進~用の［
横／縦
］ `percentage$t 値は，`基準~box$の［
横幅／縦幅
］に相対的になる。
拡縮-関数（ `scale^f, 等々）における `percentage$t は、
`number$t と等価であり，指定d値においては `number$t として直列化される。
例えば，
`scale3d(50%, 100%, 150%)^v
は、
`scale3d(0.5, 1, 1.5)^v
として直列化される。
◎
The value of the transform property is a list of &lt;transform-function&gt;. The set of allowed transform functions is given below. Wherever &lt;angle&gt; is used in this specification, a &lt;number&gt; that is equal to zero is also allowed, which is treated the same as an angle of zero degrees. A percentage for horizontal translations is relative to the width of the reference box. A percentage for vertical translations is relative to the height of the reference box. A percentage in a scale function is equivalent to a number, and serializes as a number in specified values. For example, scale3d(50%, 100%, 150%) serializes as scale3d(0.5, 1, 1.5).
</p>

		<section id="two-d-transform-functions">
<h3 title="2D Transform Functions">12.1. ~2D変形~関数</h3>

<p>
拡縮-関数は、
`css-transforms-1$r にて定義され，今や百分率を~supportする。
◎
The scale functions defined in [css-transforms-1] now support percentages.
</p>

<dl class="valdef">
	<dt>`scale@f = scale( [ `number$t | `percentage$t ]#{1,2} )</dt>
	<dt>`scaleX@f = scaleX( [ `number$t | `percentage$t ] )</dt>
	<dt>`scaleY@f = scaleY( [ `number$t | `percentage$t ] )</dt>
	<dd>
百分率を受容することを除き，
`css-transforms-1$r に`定義される＠~TRANSFORM#two-d-transform-functions$とおり。
◎
As defined in css-transforms-1, but also accepting percentages as described above.
</dd>
</dl>

		</section>
		<section id="three-d-transform-functions">
<h3 title="3D Transform Functions">12.2. ~3D変形-関数</h3>

<p>
以下に挙げるものは、
`~3D変形-関数@
と総称される
— それらにおける `zero$t は、
`0deg^v と同じに挙動する
（ “単位なしの 0” による角度は、
旧来との互換性の理由から保全される）。
◎
In the following 3d transform functions, a &lt;zero&gt; behaves the same as 0deg. ("Unitless 0" angles are preserved for legacy compat reasons.)
</p>

<dl class="valdef">
	<dt>`matrix3d@f = matrix3d( `number$t#{16} )</dt>
	<dd>
`列主導順＠~GEOMETRY#_column-major-order$による 16 個の値が成す~4x4斉次~行列として、
~3D変形nを指定する。
◎
specifies a 3D transformation as a 4x4 homogeneous matrix of 16 values in column-major order.
</dd>

	<dt>`translate3d@f = translate3d( `length-percentage$t, `length-percentage$t, `length$t )</dt>
	<dd>
所与の【！廃）`translation-value^t 】 3 個の~parameterからなる移動量~vector
[ %tx, %ty, %tz ]
により，`~3D並進$を指定する。
◎
specifies a 3D translation by the vector [tx,ty,tz], with tx, ty and tz being the first, second and third translation-value parameters respectively.
</dd>

	<dt>`translateZ@f = translateZ( `length$t )</dt>
	<dd>
所与の `length^t 値 %tz による移動量~vector
[ 0, 0, %tz ]
により， Z 方向の`~3D並進$を指定する。
◎
specifies a 3D translation by the vector [0,0,tz] with the given amount in the Z direction.
</dd>

	<dt>`scale3d@f = scale3d( [ `number$t | `percentage$t ]#{3} )</dt>
	<dd>
所与の 3 個の~parameterからなる拡縮ng~vector
[ %sx, %sy, %sz ]
により，`~3D拡縮ng$を指定する。
◎
specifies a 3D scale operation by the [sx,sy,sz] scaling vector described by the 3 parameters.
</dd>

	<dt>`scaleZ@f = scaleZ( [ `number$t | `percentage$t ] )</dt>
	<dd>
所与の~parameter %sz による拡縮ng~vector
[ 0, 0, %sz ]
により，`~3D拡縮ng$を指定する。
◎
specifies a 3D scale operation using the [1,1,sz] scaling vector, where sz is given as the parameter.
</dd>

	<dt>`rotate3d@f = rotate3d( `number$t, `number$t, `number$t, [ `angle$t | `zero$t ] )</dt>
	<dd>
所与の［
3 個の `number^t 値からなる方向~vector [ %x, %y, %z ],
回転角 `angle^t
］により，`~3D回転$を指定する。
[ 0, 0, 0 ]
のような 正規化できない方向~vectorに対しては、
回転は適用されない。
◎
specifies a 3D rotation by the angle specified in last parameter about the [x,y,z] direction vector described by the first three parameters. A direction vector that cannot be normalized, such as [0,0,0], will cause the rotation to not be applied.
</dd>
	<dd class="note">注記：
回転は、
~vectorが指す先から原点を見たときに時計回りになる。
◎
Note: the rotation is clockwise as one looks from the end of the vector toward the origin.
</dd>

	<dt>`rotateX@f = rotateX( [ `angle$t | `zero$t ] )</dt>
	<dd>
`rotate3d(1, 0, 0, &lt;angle&gt;)^v
と同じ。
◎
same as rotate3d(1, 0, 0, &lt;angle&gt;).
</dd>

	<dt>`rotateY@f = rotateY( [ `angle$t | `zero$t ] )</dt>
	<dd>
`rotate3d(0, 1, 0, &lt;angle&gt;)^v
と同じ。
◎
same as rotate3d(0, 1, 0, &lt;angle&gt;).
</dd>

	<dt>`rotateZ@f = rotateZ( [ `angle$t | `zero$t ] )</dt>
	<dd>
`rotate3d(0, 0, 1, &lt;angle&gt;)^v
と同じ
— `rotate(&lt;angle&gt;)^v と等価な~3D変形を与える。
◎
same as rotate3d(0, 0, 1, &lt;angle&gt;), which is a 3d transform equivalent to the 2d transform rotate(&lt;angle&gt;).
</dd>

	<dt>`perspective@f = perspective( [ `length [0,∞]$t | `~none1@v ] )</dt>
	<dd>
`透視~投影~行列$を指定する。
この行列は、
空間の点を，その Z 値に基づいて X, Y 方向に拡縮する
—
正な Z 値を伴う点は，（画面~上では）原点から離れる方向に拡大し、
負な Z 値を伴う点は，原点に近付く方向に縮小する。
z=0 平面~上の点は不変になる。
`length^t ~parameterは、
`視点$から画面（ z=0 平面）までの距離を表現する。
この値を小さくする程、
視点と画面の四隅を頂点とする四角錐は，より平たくなり、
遠近法の効果が誇張されるようになる。
例えば，値 `1000px^v は中程度の遠近感を与え、
値 `200px^v は極度の遠近感を与える。
◎
specifies a perspective projection matrix. This matrix scales points in X and Y based on their Z value, scaling points with positive Z values away from the origin, and those with negative Z values towards the origin. Points on the z=0 plane are unchanged. The parameter represents the distance of the z=0 plane from the viewer. Lower values give a more flattened pyramid and therefore a more pronounced perspective effect. For example, a value of 1000px gives a moderate amount of foreshortening and a value of 200px gives an extreme amount.
</dd>
	<dd>
<p>
この深度~値が `1px^v 未満の場合、
次に挙げる所では `1px^v として扱うモノトスル
⇒＃
描画~目的／
`transform$p の`解決d値$を算出するとき／
`補間＠#interpolation-of-transform-functions$の端点として利用するとき
◎
If the depth value is less than 1px, it must be treated as 1px for the purpose of rendering, for computing the resolved value of transform, and when used as the endpoint of interpolation.
</p>

<p class="note">注記：
上の “`1px^v 未満” 規則の意図は、
`perspective$f 関数を行列に変換する必要がある事例を受持つことにある。
◎
Note: The intent of the above rules on values less than 1px is that they cover the cases where the perspective() function needs to be converted into a matrix.
</p>
	</dd>
</dl>

		</section>
		<section id="transform-primitives">
<h3 title="Transform function primitives and derivatives">12.3. 原始関数とその派生関数</h3>

<p>
一部の変形-関数は、
より汎用な変形-関数の特殊な場合として表現できる。
後者は
<dfn>原始関数</dfn>
（ `primitive transform functions^en, 略して `primitive^en ），
前者は その
<dfn>派生関数</dfn>
（ `derived transform function^en ）
と呼ばれる。
~3Dにおける原始関数, その派生関数は：
◎
Some transform functions can be represented by more generic transform functions. These transform functions are called derived transform functions, and the generic transform functions are called primitive transform functions. Three-dimensional primitives and their derived transform functions are:
</p>

<table><thead><tr>
<th>原始関数
<th>派生関数
<tbody>

<tr><td id="translate3d-primitive">`translate3d$f
<td>
`translateX$f,
`translateY$f,
`translateZ$f,
`translate$f
◎
for &lt;translateX()&gt;, &lt;translateY()&gt;, translateZ() and &lt;translate()&gt;.

<tr><td id="scale3d-primitive">`scale3d$f
<td>
`scaleX$f,
`scaleY$f,
`scaleZ$f,
`scale$f
◎
for &lt;scaleX()&gt;, &lt;scaleY()&gt;, scaleZ() and &lt;scale()&gt;.

<tr><td id="rotate3d-primitive">`rotate3d$f
<td>
`rotate$f,
`rotateX$f,
`rotateY$f,
`rotateZ$f
◎
for &lt;rotate()&gt;, rotateX(), rotateY() and rotateZ().
</table>

<p>
派生関数に対応する原始関数として~2D, ~3D両者がある場合、
どちらを利用するかは，文脈から決まる。
`§ 原始関数と派生関数の補間＠#interpolation-of-transform-functions$
を見よ。
◎
For derived transform functions that have a two-dimensional primitive and a three-dimensional primitive, the context decides about the used primitive. See Interpolation of primitives and derived transform functions.
</p>

		</section>
	</section>
	<section id="matrix-interpolation">
<h2 title="Interpolation of Matrices">13. 二つの行列の補間</h2>

<p>
2 つの行列の合間を補間するためには、
まず，各~行列を対応している［
並進, 回転, 拡縮, 斜傾
］
— `~3D行列$の場合は、
それに加えて遠近法の成分 —
に分解する。
次に，この分解された 2 つの［
一連の行列
］の間で、
互いに対応する行列を，数量的に補間する。
最後に、
その結果の一連の行列を，一つの行列に再構成する。
◎
When interpolating between two matrices, each matrix is decomposed into the corresponding translation, rotation, scale, skew and (for a 3D matrix) perspective values. Each corresponding component of the decomposed matrices gets interpolated numerically and recomposed back to a matrix in a final step.
</p>

		<section id="interpolation-of-3d-matrices">
<h3 title="Interpolation of 3D matrices">13.1. 二つの~3D行列の補間</h3>

			<section id="decomposing-a-3d-matrix">
<h4 title="Decomposing a 3D matrix">13.1.1. ~3D行列の分解-法</h4>

<p>
下の疑似~codeは
“`Graphics Gems II, edited by Jim Arvo^cite”
による “`unmatrix^en” 手法に基づくが、
`Gimbal Locks^en
【`ジンバルロック＠https://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%B3%E3%83%90%E3%83%AB$】
の問題を避けるため，
`Euler angle^en
【`オイラー角＠https://ja.wikipedia.org/wiki/%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E8%A7%92$】
の代わりに
`Quaternions^en
【`四元数＠https://ja.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B0$】
を利用するよう改変されている。
◎
The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", but modified to use Quaternions instead of Euler angles to avoid the problem of Gimbal Locks.
</p>

<p>
次の疑似~codeは~4x4斉次~行列に対して働く：
【！homogeneous transformation matrix同次変形n行列】
◎
The following pseudocode works on a 4x4 homogeneous matrix:
</p>

<pre class="lang-other">
入力:
   %matrix      ; ~4x4行列
出力:
   %translate   ; 3 成分~vectorで表現される並進~成分
   %scale       ; 3 成分~vectorで表現される拡縮~成分
   %skew        ; 3 成分~vectorで表現される XY, XZ, YZ 斜傾~成分
   %perspective ; 4 成分~vectorで表現される遠近法~成分
   %quaternion  ; 4 成分~vectorで表現される四元数による，回転~成分

返り値:
   行列を分解できたなら true, できなかったなら false


/* <span class="comment">
行列を正規化する
</span> */
double %m33 = %matrix[3][3]
if (%m33 == 0)
    return false

for (%i = 0; %i &lt; 4; %i++)
    for (%j = 0; %j &lt; 4; %j++)
        %matrix[%i][%j] /= %m33

/* <span class="comment">
%perspective を解くため，`透視~行列$ %PM 【！perspectiveMatrix】が利用されるが、
それは， upper ~3x3成分の特異性を容易に~testする仕方も与える。
</span> */

%PM = %matrix; /* <span class="comment">透視~行列, 複製</span> */

%PM[0][3] = %PM[1][3] = %PM[2][3] = 0
%PM[3][3] = 1

if (determinant(%PM) == 0)
    return false

/* <span class="comment">
最初に，遠近法を分離する
</span> */
if (%matrix[0][3] != 0 || %matrix[1][3] != 0 || %matrix[2][3] != 0)
    /* <span class="comment">
%rightHandSide は等式の右辺
</span> */
    %rightHandSide[0] = %matrix[0][3]
    %rightHandSide[1] = %matrix[1][3]
    %rightHandSide[2] = %matrix[2][3]
    %rightHandSide[3] = %matrix[3][3]

    /* <span class="comment">
%rightHandSide を %PM の逆行列で乗算して，等式を解く
</span> */
    %perspective = multVecMatrix(%rightHandSide, transposeMatrix4(inverse(%PM)))
else
    /* <span class="comment">
遠近法なし
</span> */
    %perspective[0] = %perspective[1] = %perspective[2] = 0
    %perspective[3] = 1

/* <span class="comment">
次に並進を得る
</span> */
for (%i = 0; %i &lt; 3; %i++)
    %translate[%i] = %matrix[3][%i]

/* <span class="comment">
次は拡縮率と斜傾率を得る
— %row は 3 個の 3 成分~vectorからなる配列
</span> */
for (%i = 0; %i &lt; 3; %i++)
    %row[%i][0] = %matrix[%i][0]
    %row[%i][1] = %matrix[%i][1]
    %row[%i][2] = %matrix[%i][2]

/* <span class="comment">
X 拡縮率を算出して %row[0] を正規化する
</span> */
%scale[0] = length(%row[0])
%row[0] = normalize(%row[0])

/* <span class="comment">
XY 斜傾率を算出して %row[1] を %row[0] に直交化する
</span> */
%skew[0] = dot(%row[0], %row[1])
%row[1] = combine(%row[1], %row[0], 1.0, -%skew[0])

/* <span class="comment">
Y 拡縮率を算出した上で %row[1] を正規化する
</span> */
%scale[1] = length(%row[1])
%row[1] = normalize(%row[1])
%skew[0] /= %scale[1];

/* <span class="comment">
XZ, YZ の斜傾率を算出して，%row[2] を直交化する
</span> */
%skew[1] = dot(%row[0], %row[2])
%row[2] = combine(%row[2], %row[0], 1.0, -%skew[1])
%skew[2] = dot(%row[1], %row[2])
%row[2] = combine(%row[2], %row[1], 1.0, -%skew[2])

/* <span class="comment">
Z 拡縮率を得て, %row[2] を正規化する
</span> */
%scale[2] = length(%row[2])
%row[2] = normalize(%row[2])
%skew[1] /= %scale[2]
%skew[2] /= %scale[2]

/* <span class="comment">
この時点で, 行列は直交する（各 row ~vectorは互いに直交な単位~vector）。
座標系が反転されているか検査する。
行列式が −1 ならば行列と拡縮率を −1 倍する
</span> */
%pdum3 = cross(%row[1], %row[2])
if (dot(%row[0], %pdum3) &lt; 0)
    for (%i = 0; %i &lt; 3; %i++)
        %scale[%i] *= -1;
        %row[%i][0] *= -1
        %row[%i][1] *= -1
        %row[%i][2] *= -1

/* <span class="comment">
回転を~~抽出する
</span> */
%quaternion[0] = 0.5 * sqrt(max(1 + %row[0][0] - %row[1][1] - %row[2][2], 0))
%quaternion[1] = 0.5 * sqrt(max(1 - %row[0][0] + %row[1][1] - %row[2][2], 0))
%quaternion[2] = 0.5 * sqrt(max(1 - %row[0][0] - %row[1][1] + %row[2][2], 0))
%quaternion[3] = 0.5 * sqrt(max(1 + %row[0][0] + %row[1][1] + %row[2][2], 0))

if (%row[2][1] &gt; %row[1][2])
    %quaternion[0] = -%quaternion[0]
if (%row[0][2] &gt; %row[2][0])
    %quaternion[1] = -%quaternion[1]
if (%row[1][0] &gt; %row[0][1])
    %quaternion[2] = -%quaternion[2]

return true
</pre>

<!-- 

Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can


// Normalize the matrix.
if (matrix[3][3] == 0)
    return false

for (i = 0; i &lt; 4; i++)
    for (j = 0; j &lt; 4; j++)
        matrix[i][j] /= matrix[3][3]

// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
perspectiveMatrix = matrix

for (i = 0; i &lt; 3; i++)
    perspectiveMatrix[i][3] = 0

perspectiveMatrix[3][3] = 1

if (determinant(perspectiveMatrix) == 0)
    return false

// First, isolate perspective.
if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
    // rightHandSide is the right hand side of the equation.
    rightHandSide[0] = matrix[0][3]
    rightHandSide[1] = matrix[1][3]
    rightHandSide[2] = matrix[2][3]
    rightHandSide[3] = matrix[3][3]

    // Solve the equation by inverting perspectiveMatrix and multiplying
    // rightHandSide by the inverse.
    inversePerspectiveMatrix = inverse(perspectiveMatrix)
    transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
    perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)
else
    // No perspective.
    perspective[0] = perspective[1] = perspective[2] = 0
    perspective[3] = 1

// Next take care of translation
for (i = 0; i &lt; 3; i++)
    translate[i] = matrix[3][i]

// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
for (i = 0; i &lt; 3; i++)
    row[i][0] = matrix[i][0]
    row[i][1] = matrix[i][1]
    row[i][2] = matrix[i][2]

// Compute X scale factor and normalize first row.
scale[0] = length(row[0])
row[0] = normalize(row[0])

// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0] = dot(row[0], row[1])
row[1] = combine(row[1], row[0], 1.0, -skew[0])

// Now, compute Y scale and normalize 2nd row.
scale[1] = length(row[1])
row[1] = normalize(row[1])
skew[0] /= scale[1];

// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1] = dot(row[0], row[2])
row[2] = combine(row[2], row[0], 1.0, -skew[1])
skew[2] = dot(row[1], row[2])
row[2] = combine(row[2], row[1], 1.0, -skew[2])

// Next, get Z scale and normalize 3rd row.
scale[2] = length(row[2])
row[2] = normalize(row[2])
skew[1] /= scale[2]
skew[2] /= scale[2]

// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
pdum3 = cross(row[1], row[2])
if (dot(row[0], pdum3) &lt; 0)
    for (i = 0; i &lt; 3; i++)
        scale[i] *= -1;
        row[i][0] *= -1
        row[i][1] *= -1
        row[i][2] *= -1

// Now, get the rotations out
quaternion[0] = 0.5 * sqrt(max(1 + row[0][0] - row[1][1] - row[2][2], 0))
quaternion[1] = 0.5 * sqrt(max(1 - row[0][0] + row[1][1] - row[2][2], 0))
quaternion[2] = 0.5 * sqrt(max(1 - row[0][0] - row[1][1] + row[2][2], 0))
quaternion[3] = 0.5 * sqrt(max(1 + row[0][0] + row[1][1] + row[2][2], 0))

if (row[2][1] &gt; row[1][2])
    quaternion[0] = -quaternion[0]
if (row[0][2] &gt; row[2][0])
    quaternion[1] = -quaternion[1]
if (row[1][0] &gt; row[0][1])
    quaternion[2] = -quaternion[2]

return true
 -->

			</section>
			<section id="interpolation-of-decomposed-3d-matrix-values">
<h4 title="Interpolation of decomposed 3D matrix values">13.1.2. 二つの［ 分解された~3D行列~値 ］の補間</h4>

<p>
始値-行列を分解して得られた各~成分~値［
並進, 拡縮, 斜傾, 遠近法
］は、
対応する 終値-行列の各~成分との間で，線型に補間される。
◎
Each component of the decomposed values translation, scale, skew and perspective of the source matrix get linearly interpolated with each corresponding component of the destination matrix.
</p>

<p class="note">注記：
例えば、
始値-行列の <code>translate[0]</code>
と終値-行列の <code>translate[0]</code>
は数量的に補間され，その結果が~animateしている要素の並進を設定するために利用される。
◎
Note: For instance, translate[0] of the source matrix and translate[0] of the destination matrix are interpolated numerically, and the result is used to set the translation of the animating element.
</p>

<p>
分解された［
始値-／終値-
］行列の四元数は、
下の疑似~codeにて述べられる球面~線型~補間
（ `Slerp^en 【`参考＠https://en.wikipedia.org/wiki/Slerp$】）
を利用して，補間される。
◎
Quaternions of the decomposed source matrix are interpolated with quaternions of the decomposed destination matrix using the spherical linear interpolation (Slerp) as described by the pseudo code below:
</p>

<pre class="lang-other">
入力:
   %quaternionA   ; 4 成分~vector
   %quaternionB   ; 4 成分~vector
   %t             ; 補間~parameter, 0 &lt;= %t &lt;= 1
出力:
   %quaternionDst ; 4 成分~vector


%product = dot(%quaternionA, %quaternionB)

/* <span class="comment">
%product が −1.0 以上 1.0 以下になるよう切り詰める
</span> */
%product = min(%product, 1.0)
%product = max(%product, -1.0)

if (abs(%product) == 1.0)
   %quaternionDst = %quaternionA
   return

%theta = acos(%product)
%w = sin(%t * %theta) / sqrt(1 - %product * %product)

for (%i = 0; %i &lt; 4; %i++)
  %quaternionA[%i] *= cos(%t * %theta) - %product * %w
  %quaternionB[%i] *= %w
  %quaternionDst[%i] = %quaternionA[%i] + %quaternionB[%i]

</pre>

<!-- 
Input:  quaternionA   ; a 4 component vector
        quaternionB   ; a 4 component vector
        t             ; interpolation parameter with 0 &lt;= t &lt;= 1
Output: quaternionDst ; a 4 component vector


product = dot(quaternionA, quaternionB)

// Clamp product to -1.0 &lt;= product &lt;= 1.0
product = min(product, 1.0)
product = max(product, -1.0)

if (abs(product) == 1.0)
   quaternionDst = quaternionA
   return

theta = acos(product)
w = sin(t * theta) / sqrt(1 - product * product)

for (i = 0; i &lt; 4; i++)
  quaternionA[i] *= cos(t * theta) - product * w
  quaternionB[i] *= w
  quaternionDst[i] = quaternionA[i] + quaternionB[i]

return
 -->

			</section>
			<section id="recomposing-to-a-3d-matrix">
<h4 title="Recomposing to a 3D matrix">13.1.3. ~3D行列への再構成-法</h4>

<p>
補間の結果の値が、
要素の利用元~空間を変形するときに利用される。
これらの値は~4x4行列に再構成するために利用される。
これは、
次の疑似~codeにより行える：
◎
After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below:
</p>

<pre class="lang-other">
入力:
   %translation ; 3 成分~vector
   %scale       ; 3 成分~vector
   %skew        ; 3 成分~vectorで表現される斜傾~率 XY,XZ,YZ
   %perspective ; 4 成分~vector
   %quaternion  ; 4 成分~vector
出力:
   %matrix      ; ~4x4行列

/* <span class="comment">
遠近法を適用する
</span> */
for (%i = 0; %i &lt; 4; %i++)
   %matrix[%i][3] = %perspective[%i]

/* <span class="comment">
並進を適用する
</span> */
for (%i = 0; %i &lt; 4; %i++)
   for (%j = 0; %j &lt; 3; %j++)
      %matrix[3][%i] += %translation[%j] * %matrix[%j][%i]

/* <span class="comment">
回転を適用する
</span> */
%x = %quaternion[0]
%y = %quaternion[1]
%z = %quaternion[2]
%w = %quaternion[3]

/* <span class="comment">
四元数による値から複合的な回転~行列を構築する。
%rotationMatrix は、
初期~時は~4x4単位i行列
</span> */
%rotationMatrix[0][0] = 1 - 2 * (%y * %y + %z * %z)
%rotationMatrix[0][1] =     2 * (%x * %y - %z * %w)
%rotationMatrix[0][2] =     2 * (%x * %z + %y * %w)
%rotationMatrix[1][0] =     2 * (%x * %y + %z * %w)
%rotationMatrix[1][1] = 1 - 2 * (%x * %x + %z * %z)
%rotationMatrix[1][2] =     2 * (%y * %z - %x * %w)
%rotationMatrix[2][0] =     2 * (%x * %z - %y * %w)
%rotationMatrix[2][1] =     2 * (%y * %z + %x * %w)
%rotationMatrix[2][2] = 1 - 2 * (%x * %x + %y * %y)

%matrix = multiply(%matrix, %rotationMatrix)

/* <span class="comment">
斜傾を適用する。
%temp は、
初期~時は~4x4の単位i行列
</span> */
if (%skew[2])
    %temp[2][1] = %skew[2]
    %matrix = multiply(%matrix, %temp)

if (%skew[1])
    %temp[2][1] = 0
    %temp[2][0] = %skew[1]
    %matrix = multiply(%matrix, %temp)

if (%skew[0])
    %temp[2][0] = 0
    %temp[1][0] = %skew[0]
    %matrix = multiply(%matrix, %temp)

/* <span class="comment">
拡縮を適用する
</span> */
for (%i = 0; %i &lt; 3; %i++)
   for (%j = 0; %j &lt; 4; %j++)
      %matrix[%i][%j] *= %scale[%i]

return
</pre>
<!-- 
Input:  translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

Supporting functions (matrix is a 4x4 matrix):
  matrix  multiply(matrix a, matrix b)   returns the 4x4 matrix product of a * b  

// apply perspective
for (i = 0; i &lt; 4; i++)
  matrix[i][3] = perspective[i]

// apply translation
for (i = 0; i &lt; 3; i++)
  for (j = 0; j &lt; 3; j++)
    matrix[3][i] += translation[j] * matrix[j][i]

// apply rotation
x = quaternion[0]
y = quaternion[1]
z = quaternion[2]
w = quaternion[3]

// Construct a composite rotation matrix from the quaternion values
// rotationMatrix is a identity 4x4 matrix initially
rotationMatrix[0][0] = 1 - 2 * (y * y + z * z)
rotationMatrix[0][1] = 2 * (x * y - z * w)
rotationMatrix[0][2] = 2 * (x * z + y * w)
rotationMatrix[1][0] = 2 * (x * y + z * w)
rotationMatrix[1][1] = 1 - 2 * (x * x + z * z)
rotationMatrix[1][2] = 2 * (y * z - x * w)
rotationMatrix[2][0] = 2 * (x * z - y * w)
rotationMatrix[2][1] = 2 * (y * z + x * w)
rotationMatrix[2][2] = 1 - 2 * (x * x + y * y)

matrix = multiply(matrix, rotationMatrix)

// apply skew
// temp is a identity 4x4 matrix initially
if (skew[2])
    temp[2][1] = skew[2]
    matrix = multiply(matrix, temp)

if (skew[1])
    temp[2][1] = 0
    temp[2][0] = skew[1]
    matrix = multiply(matrix, temp)

if (skew[0])
    temp[2][0] = 0
    temp[1][0] = skew[0]
    matrix = multiply(matrix, temp)

// apply scale
for (i = 0; i &lt; 3; i++)
  for (j = 0; j &lt; 3; j++)
    matrix[i][j] *= scale[i]

return
 -->

			</section>
		</section>
	</section>
	<section id="interpolation-of-transform-functions">
<h2 title="Interpolation of primitives and derived transform functions">14. 原始関数と派生関数の補間</h2>

<p>
2 つの変形-関数は、
名前も引数の個数も同じならば，
前節による換算を要することなく数量的に補間できる。
その計算-結果は、
同じ個数の引数を伴う同じ型の変形-関数になる。
◎
Two transform functions with the same name and the same number of arguments are interpolated numerically without a former conversion. The calculated value will be of the same transform function type with the same number of arguments.＼
</p>

<p>
変形-関数［
`matrix$f,
`matrix3d$f,
`perspective$f
］には、
特別な規則が適用される
— いずれも、
まず~4x4行列に換算されてから，`§ 行列の補間$の定義に従って補間される。
◎
Special rules apply to &lt;matrix()&gt;, &lt;matrix3d()&gt; and &lt;perspective()&gt;.
◎
The transform functions &lt;matrix()&gt;, matrix3d() and perspective() get converted into 4x4 matrices first and interpolated as defined in section Interpolation of Matrices afterwards.
</p>

<p>
原始関数 `rotate3d$f の補間~用には、
まず，両~変形-関数の方向~vectorが正規化される。
［
互いの正規化された~vectorは等しくない
］かつ［
回転~角度は どちらも 0 でない
］場合、
両~変形-関数は，まず~4x4行列に換算されてから，`§ 行列の補間$の定義に従って補間される。
他の場合、
回転~角度は数量的に補間され，［
両~角度とも 0 になる場合は (0, 0, 1) ／
~ELSE_ 0 でない角度
］による回転~vectorが利用される。
◎
For interpolations with the primitive rotate3d(), the direction vectors of the transform functions get normalized first. If the normalized vectors are not equal and both rotation angles are non-zero the transform functions get converted into 4x4 matrices first and interpolated as defined in section Interpolation of Matrices afterwards. Otherwise the rotation angle gets interpolated numerically and the rotation vector of the non-zero angle is used or (0, 0, 1) if both angles are zero.
</p>

<div class="example">
<p>
2 つの変形~関数［
`translate(0)^v, `translate(100px)^v
］は、
同じ型を成し，同じ個数の引数をとる。
したがって，数量的に補間できる。
変形~関数［
`translateX(100px)^v ／ `translate(100px, 0)^v
］は、
それらと［
同じ型を成さない／
同じ個数の引数をとらない
］ので，変換~段を経ない限り補間し得ない。
◎
The two transform functions translate(0) and translate(100px) are of the same type, have the same number of arguments and therefore can get interpolated numerically. translateX(100px) is not of the same type and translate(100px, 0) does not have the same number of arguments, therefore these transform functions can not get interpolated without a former conversion step.
</p>
</div>

<p>
2 つの変形~関数は、［
同じ原始関数を共有するが，型は異なる／
同じ型を成すが，引数の個数は異なる
］場合でも，補間できる。
両~変形~関数は、
最初に共通な原始関数への変換が必要になり，
それから数量的に補間される。
算出d値は、
結果の補間された引数を伴う原始関数になる。
◎
Two different types of transform functions that share the same primitive, or transform functions of the same type with different number of arguments can be interpolated. Both transform functions need a former conversion to the common primitive first and get interpolated numerically afterwards. The computed value will be the primitive with the resulting interpolated arguments.
</p>

<div class="example">
<p>
次の例は、
`div^e ~boxに~hoverされているときの，
`translateX(100px)^v から `translateY(100px)^v への 3 秒間の遷移を述べる。
両~変形~関数は、
同じ原始関数 `translate$f から派生するので，補間できる。
◎
The following example describes a transition from translateX(100px) to translateY(100px) in 3 seconds on hovering over the div box. Both transform functions derive from the same primitive translate() and therefore can be interpolated.
</p>

<pre class="lang-html">div {
  transform: translateX(100px);
}

div:hover {
  transform: translateY(100px);
  transition: transform 3s;
}
</pre>

<p>
両~変形~関数は、
遷移-時には，共通な原始関数へ変形される。
［
`translateX(100px)^v は `translate(100px, 0)^v ／
`translateY(100px)^v は `translate(0, 100px)^v
］に変換される。
両~変形~関数は、
それから数量的に補間し得るようになる。
◎
For the time of the transition both transform functions get transformed to the common primitive. translateX(100px) gets converted to translate(100px, 0) and translateY(100px) gets converted to translate(0, 100px). Both transform functions can then get interpolated numerically.
</p>
</div>

<p>
両~変形~関数が ある~2D原始関数を共有する場合、
両~変形~関数とも 当の~2D原始関数に変換される。
どちらかが~3D変形~関数である場合、
共通な~3D原始関数が利用される。
◎
If both transform functions share a primitive in the two-dimensional space, both transform functions get converted to the two-dimensional primitive. If one or both transform functions are three-dimensional transform functions, the common three-dimensional primitive is used.
</p>

<div class="example">
<p>
この例では、
~2D変形~関数から~3D変形~関数へ~animateされる。
共通な原始関数は `translate3d$f になる。
◎
In this example a two-dimensional transform function gets animated to a three-dimensional transform function. The common primitive is translate3d().
</p>

<pre class="lang-css">
div {
  transform: translateX(100px);
}

div:hover {
  transform: translateZ(100px);
  transition: transform 3s;
}
</pre>

<p>
まず、［
`translateX(100px)^v は `translate3d(100px, 0, 0)^v ／
`translateZ(100px)^v は `translate3d(0, 0, 100px)^v
］に変換される。
次に、
変換された両~変形~関数は，数量的に補間される。
◎
First translateX(100px) gets converted to translate3d(100px, 0, 0) and translateZ(100px) to translate3d(0, 0, 100px) respectively. Then both converted transform functions get interpolated numerically.
</p>
</div>

	</section>
	<section id="combining-transform-lists">
<h2 title="Addition and accumulation of transform lists">15. 変形~listの加算と累積</h2>

<div class="algo">
<p>
2 個の変形~list
( 値A, 値B )
の`加算$は、
`~list$の連結として定義される
— すなわち、
%結果値 は次に従って得られる：
</p>

<ol>
	<li>
%結果値 ~LET 値A を`~cloneする$
</li>
	<li>
%結果値 を 値B で`拡張する$
</li>
	<li>
~RET %結果値
</li>
</ol>

◎
Addition of two transform lists Va and Vb is defined as list concatenation such that Vresult is equal to Vb appended to Va.
</div>

<div class="algo">
<p>
2 個の変形~list
( 値A, 値B )
の`累積$は、
互いの対応する【！with regards to matching】変形-関数どうしの補間と同じ手続きに従う
（ `CSS-TRANSFORMS-1$r `§ 変形どうしの補間＠~TRANSFORM#interpolation-of-transforms$
を見よ）
— 必要yなだけ［
~listに`恒等~変形-関数$を補充する／
`none^v を`恒等~変形-関数$に変換する／
両~引数を行列に変換する
］ことも含めて。
しかしながら，個々の~parameterは、
補間する代わりに，加算を利用して結合される。
ただし、
~parameterの値が［
`恒等~変形-関数$における 1
］である事例（例：
拡縮率~parameterや, 行列の `11^M, `22^M, `33^M, `44^M ~~成分
）においては、
次に与える
`1 に基づく値~用の累積@
を利用して結合する
⇒
%結果値 ~SET 値A ~PLUS 値B ~MINUS 1
◎
Accumulation of two transform lists Va and Vb follows the same steps as interpolation with regards to matching transform functions including padding lists with identity transform functions, converting none to an identity transform function, and converting both arguments to matrices as necessary (see CSS Transforms 1 § 9 Interpolation of Transforms). However, instead of interpolating the individual parameters, they are combined using arithmetic addition—except in the case of parameters whose value is one in the identity transform function (e.g. scale parameters and matrix elements m11, m22, m33, and m44), which combine using accumulation for one-based values as follows:
• Vresult = Va + Vb - 1
</p>
</div>

<div class="note">

<p>注記：
上の定義は、［
値B は 値A からの差分として動作する
］とする`累積$の意図を保全する。
それは、
次のような~animationが：
◎
The above definition preserves the intent of accumulation which is that Vb acts as a delta from Va and allows an animation such as:
</p>

<pre class="lang-js">
div.animate(
  { transform: ['scale(1)', 'scale(2)'] },
  {
    duration: 1000,
    easing: 'ease',
  }
);
</pre>

<p>
次のように拡張されたとき，期待される挙動を生産することを許容する：
◎
to produce the expected behavior when extended as follows:
</p>

<pre class="lang-js">
div.animate(
  { transform: ['scale(1)', 'scale(2)'] },
  {
    duration: 1000,
    easing: 'ease',
    <mark>iterations: 5,</mark>
    <mark>iterationComposite: 'accumulate',</mark>
  }
);</pre>

</div>

		<section id="neutral-element">
<h3 title="Neutral element for addition">15.1. 加算における単位元</h3>

<div >
<p>
一部の~animationは、
加算における単位元を要する。
変形-関数に対しては、
これは，［
値 0 をとる~scalar
］または［
そのような~scalarたちが成す~list
］である。
変形-関数に対する単位元の例として、
次が挙げられる：
</p>

<ul ><li>`translate(0)^v
</li><li>`translate3d(0, 0, 0)^v
</li><li>`translateX(0)^v
</li><li>`translateY(0)^v
</li><li>`translateZ(0)^v
</li><li>`scale(0)^v
</li><li>`scaleX(0)^v
</li><li>`scaleY(0)^v
</li><li>`scaleZ(0)^v
</li><li>`rotate(0)^v
</li><li><code class="value">rotate3d(%v<sub>x</sub>, %v<sub>y</sub>, %v<sub>z</sub>, 0)</code>（ここで %v は、
文脈に依存する~vector）
</li><li>`rotateX(0)^v
</li><li>`rotateY(0)^v
</li><li>`rotateZ(0)^v
</li><li>`skew(0, 0)^v
</li><li>`skewX(0)^v
</li><li>`skewY(0)^v
</li><li>`matrix(0, 0, 0, 0, 0, 0)^v
</li><li>`matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)^v
</li><li>`perspective(none)^v
</li></ul>

◎
Some animations require a neutral element for addition. For transform functions this is a scalar or a list of scalars of 0. Examples of neutral elements for transform functions are translate(0), translate3d(0, 0, 0), translateX(0), translateY(0), translateZ(0), scale(0), scaleX(0), scaleY(0), scaleZ(0), rotate(0), rotate3d(vx, vy, vz, 0) (where v is a context dependent vector), rotateX(0), rotateY(0), rotateZ(0), skew(0, 0), skewX(0), skewY(0), matrix(0, 0, 0, 0, 0, 0), matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) and perspective(none).
</div>

<p class="note">注記：
［
`matrix$f, `matrix3d$f, `perspective$f
］による単位元［
からの（ `from^b ） ／への（ `to^b ）
］~animationは、
離散的な~animationに~fall-backする（`§ 行列の補間$を見よ）。
◎
Note: Animations to or from the neutral element of additions &lt;matrix()&gt;, matrix3d() and perspective() fall back to discrete animations (See § 13 Interpolation of Matrices).
</p>

		</section>
	</section>
	<section id="mathematical-description">
<h2 title="Mathematical Description of Transform Functions">16. 変形-関数の数学的~記述</h2>

<!-- 
function make_matrix(data){
	return (
		'<math xmlns="http://www.w3.org/1998/Math/MathML">'
		+ '<mfenced open="[" close="]"><mtable>'
		+ data.split('／').map(func(row){
			return '<mtr><mtd>' + row.replace(/｜/g, '</mtd><mtd>') + '</mtd></mtr>'
		}).join('')
		+ '</mtable></mfenced></math>'
	);
}

<math xmlns="http://www.w3.org/1998/Math/MathML"
><mfenced open="[" close="]"><mtable>
<mtr><mtd>x</mtd><mtd>y</mtd></mtr>
<mtr><mtd>x</mtd><mtd>y</mtd></mtr>
</mtable></mfenced></math>

 -->

<p>
すべての変形-関数は、
次のような形の~4x4変形n行列として数学的に表現できる：
◎
Mathematically, all transform functions can be represented as 4x4 transformation matrices of the following form:
</p>

<figure>`4x4matrix^dgm</figure>

<p class="trans-note">【
この仕様における行列は、
座標を~~縦~vectorと見なして左から作用し、
子の局所~座標系から親の局所~座標系への変形nを与える。
】</p>

<p>
行列~上の並進の 1 単位は、
要素の`局所~座標系$の 1 画素と等価になる。
◎
One translation unit on a matrix is equivalent to 1 pixel in the local coordinate system of the element.
</p>

<ul>
	<li>
<p>
移動量 [ %tx, %ty, %tz ] による
`~3D並進@
は、
次の行列と等価になる：
◎
A 3D translation with the parameters tx, ty and tz is equivalent to the matrix:
</p>

<figure>`translate3d^dgm</figure>
	</li>
	<li>
<p>
拡縮率 [ %sx, %sy, %sz ] による
`~3D拡縮ng@
は、
次の行列と等価になる：
◎
A 3D scaling with the parameters sx, sy and sz is equivalent to the matrix:
</p>

<figure>`scale3d^dgm</figure>
	</li>
	<li>
<p>
軸~vector [ %x, %y, %z ] と回転角 %α による
`~3D回転@
は、
次の行列と等価になる：
◎
A 3D rotation with the vector [x,y,z] and the parameter alpha is equivalent to the matrix:
</p>

<figure>`rotate3dmatrix^dgm</figure>

<p>
ここで：
◎
where:
</p>
		<ul>
			<li>
%sc = sin (%α/2) ⋅ cos (%α/2)
◎
\newline sc = \sin (\alpha/2) \cdot \cos (\alpha/2)＼
</li>
			<li>
%ss = sin (%α/2) ⋅ sin (%α/2)
◎
\newline sq = \sin^2 (\alpha/2)
</li>
			<li>
%x, %y, %z は、
いずれも正規化-済み
— ［
それぞれの 2 乗の総和
］の平方根で除算-済み —
とする。
◎
and where x, y, and z have been normalized (that is, where the x, y, and z values given have been divided by the square root of the sum of their squares).
</li>
		</ul>

<div class="note">
<p>注記：
各~軸~周りの回転は、
以下のように単純~化される。
◎
↓</p>

<p>
X 軸~周りの回転：
◎
Note that this means that a rotation around the X axis simplifies to:
</p>
<figure>`rotate3dX^dgm</figure>

<p>
Y 軸~周りの回転：
◎
a rotation around the Y axis simplifies to:
</p>
<figure>`rotate3dY^dgm</figure>

<p>
Z 軸~周りの回転：
◎
and a rotation around the Z axis simplifies to:
</p>
<figure>`rotate3dZ^dgm</figure>
</div>
	</li>
	<li>
<p>
~parameter %d による
`透視~投影~行列@
は、
次の行列と等価になる：
◎
A perspective projection matrix with the parameter d is equivalent to the matrix:
</p>

<figure>`perspective^dgm</figure>

【！[ x, y, z, 1 ] → [ x, y, z, 1 − z/d ] 〜 [ x/s, y/s, z/s, 1 ];  s = 1 − z/d】

<p>
~parameter %d は、
`~none1$v の場合には無限大として扱われる
（結果の行列は、
単位i行列になる）。
◎
If the parameter d is none it is treated as infinity (and the resulting matrix is the identity matrix).
</p>

<p class="trans-note">【
`perspective(calc(infinity * 1px))^v
から得られる`透視~投影~行列$は、
`none^v を~~近似するものにはなろうが，
`none^v とは異なる。
引数の `calc^f は、
`perspective$f 関数に渡される前に，
`許容される最大に切詰められる＠~CSSVAL#calc-range$ことになるので。
】</p>
	</li>
</ul>

	</section>
	<section id="svg-transform">
<h2 title="The SVG transform Attribute">17. ~SVG `transform^a 属性</h2>

<p>
この仕様は、
新たな`呈示~属性$として，次に挙げるものも導入する
⇒＃
`transform-origin$p,
`perspective$p,
`perspective-origin$p,
`transform-style$p,
`backface-visibility$p
◎
This specification will also introduce the new presentation attributes transform-origin, perspective, perspective-origin, transform-style and backface-visibility.
</p>

<p>
新たに導入された`呈示~属性$の値は、
~SVG~data型の構文~規則 `SVG11$r
【`参照＠~SVGtypes#syntax$（ `SVG2$r ）】
に従って構文解析される。
◎
Values on new introduced presentation attributes get parsed following the syntax rules on SVG Data Types [SVG11].
</p>

	</section>
	<section id="svg-animation">
<h2 title="SVG Animation">18. ~SVG~animation</h2>

		<section id="svg-animate-element">
<h3 title="The animate and set element">18.1. `animate$e, `set$e 要素</h3>

<p>
この仕様により`呈示~属性$とされる~prop［
`perspective$p,
`perspective-origin$p,
`transform-style$p,
`backface-visibility$p
］は、
~animate可能である。
［
`transform-style$p,
`backface-visibility$p 
］は、
加法的でない。
◎
The introduce presentation attributes perspective, perspective-origin, transform-style and backface-visibility are animatable. transform-style and backface-visibility are non-additive.
</p>

		</section>
	</section>
	<section id="more-issues">
<h2 title="More Issues">更なる課題</h2>

<p class="issue">
`https://lists.w3.org/Archives/Public/www-style/2015Mar/0371.html＠https://lists.w3.org/Archives/Public/www-style/2015Mar/0371.html$
により，当~WGは、
~SVGの `non-scaling-stroke^v 仕様
【 “`拡縮されない~stroke＠~SVGpainting#PaintingVectorEffects$” 】
などから利用するために，
変形を統一された “拡縮率” に分解するための公式を追加するものと解決した
（この仕様は［
`scaleX$f , `scaleY$f, `scaleZ$f
］に分解する方法を すでに定義している）。
`その公式はここに定義される＠https://www.w3.org/Graphics/SVG/WG/wiki/Proposals/Specifying_decomposition_of_scale$
。
◎
Per https://lists.w3.org/Archives/Public/www-style/2015Mar/0371.html, the WG resolved to add a formula for decomposing a transform into a unified "scale" (the spec already defines how to decompose it into scaleX/Y/Z), for use by things like SVG’s non-scaling stroke spec. Formula is defined here.
</p>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様に対し報告された，新たな~privacyの考慮点は、
無い。
◎
No new privacy considerations have been reported on this specification.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この仕様に対し報告された，新たな~securityの考慮点は、
無い。
◎
No new security considerations have been reported on this specification.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-recent">
`2021年 11月 9日 作業草案＠~TR/2021/WD-css-transforms-2-20211109/$
からの主要な変更点
◎
Recent Changes
◎
Substantive changes since 9 November 2021 WD:
</dt>
	<dd>
まだ無い
◎
None yet
</dd>

	<dt>
`2020年 3月 3日 作業草案＠~TR/2020/WD-css-transforms-2-20200303/$
からの主要な変更点
◎
Substantive changes since 3 March 2020 WD:
</dt>
	<dd>
<p>
この仕様は、もはや，［
個々の変形~propが~2D値, ~3D値どちらをとるか状態を保守する
］よう要求しない
— 代わりに，［
~2Dとして表出し得る値
【例： `translate$p に対する `10px 10px 0^v 】
は、
どれも~2Dとして扱う
］ことを要求するようにした。
（ `3305$issue）
◎
The specification no longer requires maintaining state for whether individual transform properties have 2D or 3D values, but instead requires that any value that can be expressed as 2D is treated as 2D (see #3305).
</p>

<p class="note">注記：
相似的な変更は、
変形~関数に対しても意図されるが，まだ為されていない。
◎
Note: An analogous change is intended for transform functions, but it has not been made yet.
</p>
	</dd>
	<dd>
`scale$p ~prop, ［
`scale$f, `scaleX$f, `scaleY$f
］関数は、
今や百分率を~supportする。
（`3399$issue）
◎
The scale property and scale(), scaleX() and scaleY() functions now support percentages (see #3399).
</dd>
	<dd>
<p>
複数の定義を仕様の~3D描画~文脈~用の定義と整合するよう修正した：
◎
Fix multiple definitions to be consistent with the spec’s definition for a 3D Rendering Context:
</p>
		<ul>
			<li>
~3D描画~文脈を確立している要素の［
~border,
背景,
~box装飾
］は、
自身の~3D風景における z=0 平面に描画されるものと定義した
— ~3D風景の背後ではなく。
（`6238$issue）
◎
Define that borders, backgrounds, and box decorations of an element establishing a 3D Rendering Context are rendered at z=0 in its 3D scene, rather than behind its 3D scene (see #6238).
</li>
			<li>
`累積~3D変形n行列$は、［
【~3D描画~文脈を】確立している要素の `transform$p,
その親の `perspective$p
］も含めるよう定義した。
（`6191$issue）
◎
Define accumulated 3D transformation matrix to include the transform of the establishing element and the perspective of its parent (see #6191).
</li>
		</ul>
	</dd>
	<dd>
塗り封込めは、
`~group化~prop値$になるものと定義した。
（`6202$issue）
◎
Define that paint containment is a grouping property (see #6202).
</dd>
	<dd>
`perspective$f に `~none1$v 引数の~supportを追加した。
（ `6488$issue）
◎
Add support for a none argument to perspective() (see #6488).
</dd>
	<dd>
`perspective$f の値の切詰めは、［
解決d値, 補間
］にも適用するものと定義した。
（`6320$issue, `6346$issue）
◎
Define that clamping of values of perspective() also applies to resolved values and interpolation (see #6320 and #6346).
</dd>
	<dd>
`preserve-3d^v による効果が影響するのは、
`変形-可能$な要素に限られることを明確化した。
（`6430$issue）
◎
Clarify that the effects of preserve-3d only affect transformable elements (see #6430).
</dd>
	<dd>
`perspective$f 用の`加算における単位元＠#neutral-element$を
`perspective(none)^v に修正した。
◎
Fixed the neutral element for addition for perspective() to be perspective(none)
</dd>
	<dd>
`translate$p の解決d値が百分率を含むことについて，注記を追加した。
（`2124$issue）
◎
Added a note that the resolved value of translate includes percentages (see #2124).
</dd>
	<dd>
~3D~sort法を より精確に述べた
— どの子孫が含まれるか説明して，
`付録 E$ への参照を段 1 〜 7 に制限しないようにした。
（`926$issue）
◎
Describe 3D sorting more precisely, to explain which descendants are included, and not limit Appendix E reference to steps 1-7 (see #926).
</dd>
</dl>

	</section>
</main></div>

