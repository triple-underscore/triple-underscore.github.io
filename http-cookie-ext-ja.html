<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Cookies: HTTP State Management Mechanism （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<style>

/* cookie 属性 */
.cookie-attr {
	font-weight: normal;
	color: var(--text-color-3);
}
/* cookie フィールド名 */
.cookie-filed {
	color: var(--text-color-4);
}

.dom {
	color: var(--text-color-0);
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^§])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#${key}`;//.toLowerCase();
	break;
case 'l': // octet literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'cK':
	href = `#cookie.${key}`;
	break;
case 'p':
	href = `#p.${key}`;
	break;
case 'ch':
	return(
`<code>%x${(key.charCodeAt(0)).toString(16).toUpperCase()}</code>（ "<code class="literal">${key}</code>" ）`
	);
	break;
case 'rfc':
	{
		const [rfc, sec] = key.split('/');
		if(!sec) {
			return match;
		}
		return `<a href="#ref-RFC${rfc}">[RFC${rfc}]</a> <a href="~RFCx/rfc${rfc}#section-${sec}">§ ${sec}</a> `;
	}
	break;
case 'X': // byte value
	text = `%x${text}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '§':
		text = ` <a href="${href}">§ ${text}</a> `;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2025-08-27
trans_update:2025-08-29
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html
source_checked:240322
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
	ref_id_prefix:ref-
site_nav:network,http
trans_1st_pub:2019-12-30

●●class_map
cK:cookie-filed
a:cookie-attr
p:production
P:token
X:hex-value
h:header
m:method
dom:dom
st:status
2119:rfc2119

●●tag_map
cK:code
I:code
a:code
h:code
m:code
P:code
p:code
c:code
dom:code
s:samp
X:span
i:i
cite:cite
st:code
2119:em

●●original_id_map

references:
normative:
informative:

●●mdn_urls
cookie:HTTP/Headers/Cookie
sane-cookie:HTTP/Headers/Cookie
set-cookie:HTTP/Headers/Set-Cookie
sane-set-cookie:HTTP/Headers/Set-Cookie

●●link_map

	h.Cookie:#cookie
	h.Cookie:#sane-cookie
	h.Set-Cookie:#set-cookie
	h.Set-Cookie:#sane-set-cookie

m.POST:~HTTPsem#POST
m.GET:~HTTPsem#GET
	m.HEAD:~HTTPsem#HEAD
	m.OPTIONS:~HTTPsem#OPTIONS
	m.TRACE:~HTTPsem#TRACE

100 番台:~HTTPsem#status.1xx
400 番台:~HTTPsem#status.4xx
500 番台:~HTTPsem#status.5xx
st.404:~HTTPsem#status.404
st.3xx:~HTTPsem#status.3xx
st.301:~HTTPsem#status.301
st.302:~HTTPsem#status.302

p.IMF-fixdate:~HTTPinfra#p.IMF-fixdate
p.token:~HTTPinfra#p.token
p.BWS:~HTTPinfra#p.BWS
p.OWS:~HTTPinfra#p.OWS

a.Expires:#attribute-expires
	ua-attribute-expires
a.Max-Age:#attribute-max-age
a.Domain:#attribute-domain
a.Path:#attribute-path
a.Secure:#attribute-secure
a.HttpOnly:#attribute-httponly
a.SameSite:#attribute-samesite
	the-samesite-attribute

l.__Secure-:#the-secure-prefix
l.__Host-:#the-host-prefix
l.Strict:#samesite-strict
l.Lax:#samesite-lax
l.None:#samesite-none
l.Default:#samesite-default
l.Lax-allowing-unsafe:#lax-allowing-unsafe

~cookie保管庫:#cookie-store
要請~URI:#request-uri
非HTTP~API:#dfn-non-HTTP
二分:#split
要請~host:#dfn-request-host
~host名を正準-化する:#dfn-canonicalized

文字列:#dfn-string
既定の~path:#dfn-default-path
~domain合致して:#dfn-domain-match
~path合致して:#dfn-patrh-match
文字大小無視で合致する:#dfn-case-insensitively-match

~cookieを受信した:#dfn-receive-a-cookie
	別々に扱われる:#_-store-cookie
失効した:#dfn-expired
属性:#dfn-attributes

~ambient権限:#dfn-ambient-authority
公共~接尾辞:#dfn-public-suffix
登録-可能な~domain:#registrable-domain
~cookie用~site:#site-for-cookies
同一-~site:#same-site
非同一-~site:#cross-site
rq.非同一-~site:#request-cross-site
rq.同一-~site:#request-same-site
同一-~siteな~cookie:#same-site-cookie
	＊~top-level~site:#top-level-site

~UI~reload~navi要請:#_UI-reload-navigation

~CSRF攻撃:#CSRF
~secureな接続:#secure-connection
~top-level~navi:#top-level-navigation
~top-level要請:#top-level-navigation

生成元:#origin
~top-level生成元:#top-level-origin

検索取得:#retrieval
rT.要請:#retrieval-request
rT.~URI:#retrieval-uri
rT.同一-~site状態s:#retrieval-same-site-status
rT.種別:#retrieval-type

きちんと挙動するための~profile:#well-behaved-profile

	●§

3.2:#implementation-advisory
4.1:#sane-set-cookie
4.1.1:#abnf-syntax
4.1.2:#sane-set-cookie-semantics
4.1.2.1:#attribute-expires
4.1.2.2:#attribute-max-age
4.1.2.3:#attribute-domain
4.1.2.4:#attribute-path
4.1.2.5:#attribute-secure
4.1.2.6:#attribute-httponly
4.1.2.7:#attribute-samesite
4.1.3:#server-name-prefixes
4.2.1:#syntax
5.1.4:#cookie-path
5.2:#same-site-requests
5.2.1:#document-requests
5.3:#ignoring-cookies
5.4:#ua-name-prefixes
5.6:#set-cookie
5.6.1:#ua-attribute-expires
5.6.2:#ua-attribute-max-age
5.6.7:#the-samesite-attribute
5.6.7.1:#strict-lax
5.6.7.2:#lax-allowing-unsafe
5.7:#storage-model
5.8.1:#cookie
5.8.2:#non-http
5.8.3:#retrieval-algorithm
8.8:#samesite-cookies
8.8.2:#top-level-navigations
8.8.6:#unsafe-top-level-requests
利用者-制御:#user-controls
~server要件:#sane-profile
~UA要件:#ua-requirements
保管~model:#storage-model
機密性の弱点:#weak-confidentiality
完全性の弱点:#weak-integrity
日付:#cookie-date
第三者-主体~cookie:#third-party-cookies
文書に基づく要請:#document-requests
~securityの考慮点:#security-considerations
~cookie施策:#cookie-policy
~cookieを検索取得する:#retrieve-a-cookie
~cookieの存続期間の上限:#cookie-lifetime-limits


	●外部（HTTP

安全:~HTTPsem#safe-method
冪等:~HTTPsem#idempotent-method
~headerの結合-法:~HTTPinfra#combine-headers
~target~URI:~HTTPsem#target-URI
生成元~server:~HTTPinfra#origin-server
~UA:~HTTPinfra#user-agent
~client:~HTTPinfra#client
~server:~HTTPinfra#server
媒介者:~HTTPinfra#intermediary
	各種用語:~HTTPinfra#terminology
~field行l:~HTTPinfra#field-line
~field行l値:~HTTPinfra#field-line-value
状態s~code:~HTTPsem#status-code
時計:~HTTPinfra#clock

	●外部

dom.WorkerGlobalScope:~WORKERS#workerglobalscope
dom.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
dom.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
dom.document.cookie:~HTMLdom#dom-document-cookie

	から開始して:~INFRA#byte-sequence-starts-with
~byte大小無視:~INFRA#byte-case-insensitive
同型に復号-:~INFRA#isomorphic-decode

文書:~HTMLdom#the-document-object
	Document,

閲覧~文脈~sandbox化( 生成元 )~flag:~ORIGIN#sandboxed-origin-browsing-context-flag
~sandbox法~flag集合:~ORIGIN#sandboxing-flag-set
作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set

全部的に作動中:~HTMLds#fully-active
~navigable:~HTMLds#navigable
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
nav.作動中な文書:~HTMLds#nav-document
nav.容器~文書:~HTMLds#nav-container-document
先祖~navigable群:~HTMLds#ancestor-navigables
内容~navigable:~HTMLds#content-navigable
広義-先祖~navigable群:~HTMLds#inclusive-ancestor-navigables

~top-level辿可能:~HTMLds#top-level-traversable
nav.~top-level辿可能:~HTMLds#nav-top
~node~navigable:~HTMLds#node-navigable
子~navigable:~HTMLds#child-navigable

~navigate:~HTMLnav#navigate
~navi~algo:~HTMLnav#navigate

url.生成元:~URL1#concept-url-origin
enV.生成元:~WAPI#concept-settings-object-origin
doc.生成元:~DOM4#concept-document-origin
o.生成元:~ORIGIN#concept-origin
enV.生成元:~WAPI#concept-settings-object-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
同一-生成元:~ORIGIN#same-origin
同一-~site:~ORIGIN#same-site

環境:~WAPI#environment
環境~設定群~obj:~WAPI#environment-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context

専用~worker:~WORKERS#dedicatedworkerglobalscope
共用~worker:~WORKERS#sharedworkerglobalscope
	:~WORKERS#shared-worker
所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set
	the-worker's-Documents

~sw:~SW1#dfn-service-worker

	登録-可能な~domain:~URL1#host-registrable-domain
~URL:~URL1#concept-url

要請:~FETCH#concept-request
rq.~client:~FETCH#concept-request-client
rq.現在の~URL:~FETCH#concept-request-current-url
	rq.~URL~list:~FETCH#concept-request-url-list
	rq.~method:~FETCH#concept-request-method
rq.予約-済み~client:~FETCH#concept-request-reserved-client

o.~host:~ORIGIN#concept-origin-host
url.~host:~URL1#concept-url-host
~domain:~URL1#concept-domain

	PSL$r:http://publicsuffix.org/

●● §
1:#introduction
2:#conventions
2.1:#conformance-criteria
2.2:#syntax-notation
2.3:#terminology
3:#overview
3.1:#examples
3.2:#implementation-advisory
3.2.1:#cookie-producing-implementations
3.2.2:#cookie-consuming-implementations
3.2.2.1:#languages-frameworks
4:#sane-profile
4.1:#sane-set-cookie
4.1.1:#abnf-syntax
4.1.2:#sane-set-cookie-semantics
4.1.2.1:#attribute-expires
4.1.2.2:#attribute-max-age
4.1.2.3:#attribute-domain
4.1.2.4:#attribute-path
4.1.2.5:#attribute-secure
4.1.2.6:#attribute-httponly
4.1.2.7:#attribute-samesite
4.1.3:#server-name-prefixes
4.2:#sane-cookie
4.2.1:#syntax
4.2.2:#semantics
5:#ua-requirements
5.1:#subcomponent-algorithms
5.1.1:#cookie-date
5.1.2:#canonicalized-host-names
5.1.3:#domain-matching
5.1.4:#cookie-path
5.2:#same-site-requests
5.2.1:#document-requests
5.2.2:#worker-requests
5.3:#ignoring-cookies
5.4:#ua-name-prefixes
5.5:#cookie-lifetime-limits
5.6:#set-cookie
5.6.1:#ua-attribute-expires
5.6.2:#ua-attribute-max-age
5.6.3:#the-domain-attribute
5.6.4:#the-path-attribute
5.6.5:#the-secure-attribute
5.6.6:#the-httponly-attribute
5.6.7:#the-samesite-attribute
5.6.7.1:#strict-lax
5.6.7.2:#lax-allowing-unsafe
5.7:#storage-model
5.8.1:#cookie
5.8.2:#non-http
5.8.3:#retrieval-algorithm
6:#implementation-considerations
6.1:#limits
6.2:#application-programming-interfaces
7:#privacy-considerations
7.1:#third-party-cookies
7.2:#cookie-policy
7.3:#user-controls
7.4:#expiration-dates
8:#security-considerations
8.1:#overview-1
8.2:#ambient-authority
8.3:#clear-text
8.4:#session-identifiers
8.5:#weak-confidentiality
8.6:#weak-integrity
8.7:#reliance-on-dns
8.8:#samesite-cookies
8.8.1:#defense-in-depth
8.8.2:#top-level-navigations
8.8.3:#mashups-and-widgets
8.8.4:#server-controlled
8.8.5:#reload-navigations
8.8.6:#unsafe-top-level-requests
9:#iana-considerations
9.1:#iana-cookie
9.2:#iana-set-cookie
9.3:#cookie-attribute-registry
9.3.1:#procedure
9.3.2:#registration
10:#rfc.references
10.1:#rfc.references.1
10.2:#rfc.references.2
A:#changes
A.1:#draft-ietf-httpbis-rfc6265bis-00
A.2:#draft-ietf-httpbis-rfc6265bis-01
A.3:#draft-ietf-httpbis-rfc6265bis-02
A.4:#draft-ietf-httpbis-rfc6265bis-03
A.5:#draft-ietf-httpbis-rfc6265bis-04
#acknowledgements
#rfc.authors

●●words_table1
CAPABILITY-URLS:capability-urls-ja.html
HTTPv2:https://httpwg.org/specs/rfc9113.html

ナラナイ:<em class="rfc2119">ならない</em>
ベキ:<em class="rfc2119">べき</em>
ヨイ:<em class="rfc2119">よい</em>

●●words_table


	●network
DNS:
TLS:
SSL:
URI:
IP:
HTTP2:HTTP/2
HTTP3:HTTP/3
非HTTP: “non-HTTP” :: “非 HTTP” 
IDNA:
公共:public::~
internet::::インターネット
	~internet:the Internet
SNS:
hop:
	~transport層:transport-layer
	応用~層:application-layer
socket::::ソケット
帯域幅:bandwidth::~
発行-:issue::~
為す:makeする:~
為され:makeされ:~
冪等:idempotent::~
reload::::リロード
refresh:
端点:endpoint::~::エンドポイント

	~header:header field
	伝送-:transmission
	^en:A-label
	^en:Non-Reserved LDH
	sw:Service Workers

	●cookie
	-:flag
下位domain:subdomain::下位 domain:下位ドメイン
	ドメイン名:domain name
	下位ディレクトリ:subdirectory
directory::::ディレクトリ
付-:attach::~
抹消-:evict::~
超過:excess::~
超過-:exceed::~
内包-:include::~
	これ:removing
	-:removal priority
保管:storage::~::ストレージ
保管庫:store::~::ストア
逼迫:pressure:~
有効:valid::~
書込める:writeできる::書き込める
書込n:write::書き込み
割当分:quota::割り当て分::クォータ
再起動:restart:~
上限:limit:~
	上限:upper limit
	~~上限:upper bound
	容量:capabilities／
	総容量
	少なくかつ小容量:few and as small
	終了
	終了時:at the end／is over
	対象範囲:scope
	優先:has precedence
	優先順位:priority order
	総和:sum of
	sharing
	現れる:appear
	`Cookie^h ~header:cookie header
	`secure-only-flag$cK:Secure flag
	有効果:effective:有効

	●期間
存続期間:lifetime::~
持続的:persistent::~
持続-:persist::~
時計:clock::~
齢:age:~
	%~cookie齢の上限:cookie-age-limit
維持-:retain::~
維持:retention::~
失効-:expire::~
失効日時:expiry-time::~
	%失効日時:expiry-time
	%失効日時:the expiry time
有効期限:expiration date::~
	有効期限:expiry date
	有効期限:expiry
有効期間:expiration period::~
日時:date and time::~
年t:year::年
月t:month::月
日t:day::日
時t:hour::時
分t:minute::分
秒t:second::秒
閏秒:leap seconds::うるう秒
秒差:delta-seconds:~

	期日:date
	期間:duration
	期間内:time period
	時間:amount of time
	期間:maximum amount of time
	期限
	最長:maximum
	〜週間:weeks
	未来:future, later
	最も~~未来:latest
	過去:past
	最も過去:earliest
	~~上限以下:at most a duration
	〜間:in duration
	〜以内の:or sooner
	経過

	●構文
文法記号:grammatical term:~
文法記法:grammatical notation:~
下位成分:subcomponent::~
連結-:concatenate::~
剥がさ:stripさ:~
剥ぐ:stripする:~

	^ch:comma
	^ch:semicolon
	^ch:backslash

	小文字:lower case
	数:number
	-:boolean
	桁表記:
	-:型
	データ形式
	二重引用符:double quote
	日付形式
	日付~文字列:date string
	10 進数字:decimal
	連列:sequence
	-:abort
	successful
	足し:plus
	直前にある:its left
	括られ:wrap
	先頭と末尾:initial and trailing
	の頭部 〜 に一致:begins with a case-sensitive match for
	の頭部 〜 に一致:a prefix for
	^en:letters
	^en:carriage return
	^en:line feed
	^en:horizontal tab
	HTAB^P:horizontal tab
	^en:collation
	名前を伴わない:nameless
	名前, 値どちらも:name nor value
	名前, 値どちらか:nameless/valueless
	長さ:octets

	●一般処理／構文解析
近過去:recent:~
経過-:elapse:~
percent-::: %-
分割0:divide:分割
基数:base:~
生産器:producer::~
消費器:consumer::~
圧縮:compression::~
回復-:recover:~
	回復-不能:unrecoverable

	認識されない／できない:unrecognized
	外す:omit
	直前まで
	~GTE:greater than or equal to
	~LTE:less than or equal to
	何もしない:skip the remaining substeps and continue processing the cookie.
	~RET:Abort these ...
	-:output
	-:creation
	~CONTINUE:continue
	~CONTINUE:ignore ... return to Step ...
	分:minute
	~call元:caller
	~PLUS:total
	文字大小無視で処理している:being case-insensitive
	文字大小を違える:miscapitalize
	渡す:pass

	%新~cookie:newly-created cookie
	%~cookie属性~list:cookie-attribute-list
	%属性~名:attribute-name
	%属性~値:attribute-value
	%~cookie名:the cookie-name
	%~host:host
	-:hostA
	-:hostB
	%A
	%B

	●保安
	:ambient
私的:private:~:::プライベート
ambient:
XSS:cross-site scripting:XSS
CSRF:
	CSRF:cross-site request forgery
nonce::::ナンス
防がれ:preventされ:~
side-channel::::サイドチャネル
被害者:victim::~
被害:damage::~
拒否-:refuse::~
再現:replay::~
能動的:active::~::アクティブ
	阻止-法:blocking
認証:authentication::~
認証-:authenticate::~
	認証し直すよう:reauthentication step
真正:authentic:~
権限:authority::~
権限付与:authorization::~
権限付与され:authorizeされ::権限が付与され
	~~閲覧権限がある:authorized to see
弱体化-:compromise::~
機密性:confidentiality::~
機密:confidential::~
暗号化-:encrypt::~
暗号化:encryption::~
暗号:cryptography::~
署名-:sign::~
傍受-:intercept::~
侵害-:disrupt::~
固定化:fixation:~
修正:fixing:~
欠陥:infelicities:~
	秘匿情報:secret information
秘匿情報:secrets::~
	セッション強制:session fixation
堅牢:robust::~
平文:clear::~
上品:graceful::~
退行-:degrade::~
原理:principles:~
	予測-不能:unpredictable
盗聴者:eavesdropper:~
上書-:overwrite::上書き
絡める:entangleする:~
検索-:look up:~
稼働-:run:~
陥穽:pitfall:落とし穴
仕掛ける:mountする:~
施行:enforcement::~
多層防御:defense in depth::~
防御:defense::~
悪用-:exploit::~
悪用:exploitation:~
打破-:defeat:~
差止める:withholdする:差し止める
差止めた:withholdした:差し止めた
差止めら:withholdさ:差し止めら
login::::ログイン
活動:activity:~
相関-:correlate:~
濫用:abuse:~
警告-:warn:~
組立てる:assembleする:組み立てる
社会:society:~
広告:advertisement:~
	広告:ad:~
詐欺行為:fraud:~
脆弱:vulnerable::~
真似る:mimicする:~

	安全でない:unsafe
	抗する:against
	路上の段差:speedbump along the road
	互いに信用し合っていない:mutually distrusting
	根本から払拭する:mitigate 〜 completely
	弱点:weak
	混乱した使節の問題:confused deputy
	最悪:the worst
	分離:separate
	読む:read
	読む:learns
	偽造:forgery
	~~放任:let
	互いに~~無関係に見える複数の:different, seemingly unconnected
	^en:Connection and/or socket pooling, Token Binding, and Channel ID
	^en:Single-Sign-On
	なりすます:impersonate
	わざと:purposefully
	わからない:won't be able to tell
	信用に価し得る:potentially trustworthy

	●仕様
variation::::バリエーション
programmer::::プログラマ
	~API:application programming interface (API)
project::::プロジェクト
応用-:apply:~
指図-:instruct:~
競合-:conflict:~
競争:race condition::~
増補-:enhance:~
	期待されない:unexpectedly
	予期しない:unexpectedly
指名-:designate::~
指名:designation::~
創出-:create:~
運用者:operator:~
依拠:reliance:~
給-:supply:~
承認-:endorse:~
考えて:considerして:~
行使-:exercise:~
慣行:common practice:~
相互運用-:interoperate:~
許可的:permissive:寛容
	~~寛容:liberal
	~~寛容:lenient
	~~寛容:tolerant
	~~寛容さ:tolerance
等価性:equivalence:~
一般用:general-use:~
際立つ:salientな:~
助言:advice:~
今日:today:~
処する:dealする:~
欠点:drawbacks:~
実態:reality:~
探求-:explore:~
確証:confidence:~
複雑:complicated:~
万能:panacea:~
差異:difference:~
採用-:adopt:~
機能-:function:~
機能:function:~
推定-:infer:~
聴取-:audit:~
惑わす:confuseする:~
惑わさ:confuseさ:~
惑い:confusion:~
信じる:believeする:~
mashup::機能の組み合わせ
排他的:exclusive:~
立証-:prove:~
揃う:alignする:~
	裏で:background
上塗り:overlay:~
当日最新の:up-to-dateな:~
満足する:satisfyする:満たす
収容-:accommodate:~
措置:measure:~
変種:variant:~
供給:provision:~
採用:adoption:~
一時的:temporary:~
過渡的:transitional:~
究極的:ultimate:~
放棄-:waive:~
成文化-:codify:~
避けな:avoidしな:~
総意:consensus:~
健全さ:health:~
後継:successor:~
限定的:limited:~
実現可能:feasible:~
享受-:enjoy:~
判定-:judge:~
妨害:disruption:~
内来的:inherent:~
仕分ける:partitionする:~
促進-:promote:~
決めら:predetermineさ:~
対象読者:target audience:~
要件群:requirement 群:~
	要件群:set of requirements
理解:understanding:~
養う:developする:~
間違った:wrongな:~
背後:behind:~
不作為:inadvertent:~
思慮深く:thoughtfulに:~
禁制-:prohibit:~
支援-:assist:~
逸脱-:deviate:~

	きちんと挙動するための:well-behaved
	最大~化:maximize
	最小~化:minimize
	アリでない:impossible
	ほぼ無意味と化す:largely moot
	正しく〜ない:incorrect
	performant
	普及している:popularな
	足る:sufficient
	不足:insufficient
	併用:in conjunction with
	事実、:In fact
	依然:still
	~~可能性:potential
	下位~節:subsections
	無用に:gratuitously
	参考:Non-Normative／Informative
	~~詳細:more information
	形をとる:in the form of
	一見:seemingly
	:associated
	何をもって:notion
	何十年:multiple decades
	顕著:most apparent
	表記
	~~進行:navigating
	貴重な:invaluable
	denoted
	notice
	well
	ある種の:certain kinds of
	ある種の:certain
	すべてを成すには至らない:prudent to ensure that this designation is not the 
	価する:worth
	巨人の肩の上:standing upon the shoulders of giants
	心配:worried about
	改められない:unaltered
	綴って:spell out
	綴られ:spellされ
	関心がある:in the interests of
	それ自体は:in and of themselves
	きちんと:well に
	満たす:meet
	一つだけある:to one and only one
	~~普通にあり得る:quite possible
	あり得る:It's possible that
	あり得る:it's possible 〜 could
	-:unprocessed
	により定義される:-defined
	要-:require
	:reasonably
	see
	導き:lead to
	至る:lead
	至らす:lead
	未知:not know
	呼ばれる／知られ:known as
	促す:facilitate their
	抑制するものにもなり得る:may reduce the likelihood
	相互運用能:will be able to interoperate with
	~~思慮深く応用:judicious application
	資料:references
	呼ばれ:called
	なりすまして:impersonating
	それ自体は:in and of themselves
	例として:for instance
	検出-:detection
	一方で:whereas
	小さな:minor
	少しだけ:small
	例外として、:carves out an exception
	かするほど:tangential
	促す:promptする
	選ぶ:chooseする
	するため:in order
	表して:denote
	~~妨げ:preclude
	明瞭に~~区切:clear-cut
	間違いなく:certainly
	当然〜よう:certainly
	およそ〜あろう:most likely
	~~介入:involved
	切り分ける:hew
	助けになる:help
	助ける:help
	-:vice-versa
	警告:warning
	-:普通の
	-:initially
	-:相手
	~~段階:step
	呼称:names
	~~別名:or
	名称:name
	~~情報:signal
	それ以外の:as a general category
	それ以外のとき:or otherwise
	大半:majority
	詳細:detailing
	~HTTP~field名~registry:HTTP Field Name Registry
	~HTTP~field名~registry:permanent message header field registry
	~cookie属性~registry:"Cookie Attribute" registry
	^en:RFC Required
	〜に基づいて行われる:happen on〜basis
	^en:CamelCase
	原因:cause
	無に帰す:nullified
	当初:first place
	とする:suppose
	いらついて:frustrated
	容易にする:ease
	望ましくない:not be desirable
	~UAが選んだ〜:user agent's choosing
	必要yあり得る:may necessitate
	指す:refer
	と称される:referred to as
	導入される以前から在る:prior to the introduction
	少なくすることが必要yである:necessarily provides fewer
	問わず:regardless
	該当する段:the penultimate bullet point
	-:reading
	出自に:originate
	無い:free of
	かまわない:free to
	広く:wideに
	広い:wide
	それだけで:on their own
	様々な:varied
	ばかりではない:not every 〜 is necessarily
	回数や~~頻度:how often
	より幅広い:broader
	広まった:widespread
	まだ早過ぎる:it is too early
	最終的:eventual
	最終的な:final
	にはなるが，それを超えるものではない:best characterised as
	書いて:writing
	きちんと定義された:well-defined
	課す:impose
	少なくとも当面の間は 〜 見込まれる~for the foreseeable future
	もたらす:resulted in
	多様な:variety of
	~Web／~web:Web
	〜する場合には:do／does
	以前の:emeritus
	に注意:It's important to note that
	概ね:roughly
	最も適する:best fit
	築かれてきた:built up
	多い:frequently
	勧める:advised to
	念頭に置く:mindful
	見込みが高い:likely
	注記:note
	勧めた:advise
	止める:against
	~~再構成:refactor
	したがって:meaning that

	●未分類
UTC:
pop-up:pop up
欠如:lack:~
subset::::サブセット
mail::::メール
email::::メール
	居る下で:presence
top::::トップ
	~top:top-
打込む:typeする:~
対称:symmetric:~
UTC:
	協定世界時
MegaCorp:
	社:Inc
同型:isomorphic::~
成分組:tuple::~
toolbar::::ツールバー
事業:business:~
suite::::スイート
stateful::::ステートフル
transaction::::トランザクション
	~transaction上の:transactional

	以外の:except
	:omit, exclude
	~click:press
	~web~mail:webmail
	~web~site:website
	文書:Document
	-:stop
	登録-可能:registrable
	伴わせ:attach
	-:yield
	近く:closely
	及ぶ／またがる~span
	~EQ／~NEQ:exact-match
	-:quite
	一致しない:diverge
	一致する:the shared value in cases where the values agree
	~serviceを供して:provider
	伴わせ:mark
	~SNS用の〜:social networking 〜 services
	~comment欄:commenting
	~serverにより制御されるもの:server-controlled
	〜側:-side
	何もない:don't do anything
	何であれ:anything
	唯一の:the only
	個数:number
	~serverへの:outbound
	~serverからの:inbound
	〜番台:-level
	何らかの:some
	一連
	範囲
	連続
	-:prudent to ensure
	-:designation
	同時に:at once
	~form提出:submission
	指定し得る:distinct
	~domain合致-:domain-match
	~path合致-:path-match
	複数階に入子にされた:multiple-nested
	~~構成するもの:piece
	-:sense
	^en:drop-in
	^en:plus one
	^p:cookie-value
	^p:request-uri
	名前空間:name space
	伴わせる:marked as X=Y
	文書:Document
	総数:total
	総:total
	作成してから 2 分 以下のもの:a cookie age of 2 minutes or less
	見ている:viewing
	返送-:send back
	すでに設定された下で:already has a
	接頭辞を伴う:prefix
	切り替え:toggle
	警告-対象になるもの:some things that 〜 warned against
	現在:current
	後続
	後続して:subsequently
	場合:if, case ...
	場所
	多数
	以下
	以前
	先頭
	全部で:total
	同時
	一形態:a form of
	一部
	まるごと:in its entirety／entirely／entire
	複数
	直前
	個以上
	時点
	同時に:simultaneously
	唯一:the only
	頭部:leading
	尾部:suffix
	尾部:trailing
	末尾:trailing
	残りの部分:remainder
	対応
	対象
	before
	below
	between
	during
	次の様に:as follows
	next: 5
	non: 22
	後／後で:later
	より短い:lower
	より短い:shorter
	より長い:longer
	より長い:higher
	次回:next time
	巨大:large
	多数の:large number of
	締めくくる:concluding
	一意~性を成す~key:uniqueness computation

●●ref_key_map
COOKIES:

●●ref_data
COOKIES=副             ~/http-layered-cookies.html

●●ref_normative
[DOM-DOCUMENT-COOKIE]
    WHATWG, ＜HTML - Living Standard＞, 18 May 2021, URL: https://html.spec.whatwg.org/#dom-document-cookie
[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
[RFC1034]
    Mockapetris, P., ＜Domain names - concepts and facilities＞, STD 13, ~RFC1034, November 1987
[RFC1123]
    Braden, R., Ed., ＜Requirements for Internet Hosts - Application and Support＞, STD 3, ~RFC1123, October 1989
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC4790]
    Newman, C., Duerst, M., and A. Gulbrandsen, ＜Internet Application Protocol Collation Registry＞, ~RFC4790, March 2007
[RFC5234]
    Crocker, D., Ed. and P. Overell, ＜Augmented BNF for Syntax Specifications: ABNF＞, STD 68, ~RFC5234, January 2008
[RFC5890]
    Klensin, J., ＜Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework＞, ~RFC5890, August 2010
[RFC6454]
    Barth, A., ＜The Web Origin Concept＞, ~RFC6454, December 2011
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, ＜Guidelines for Writing an IANA Considerations Section in RFCs＞, BCP 26, ~RFC8126, June 2017
[RFC8174]
     Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[SAMESITE]
    WHATWG, ＜HTML - Living Standard＞, 26 January 2021, URL: https://html.spec.whatwg.org/#same-site
[USASCII]
    American National Standards Institute, ＜Coded Character Set -- 7-bit American Standard Code for Information Interchange＞, ANSI X3.4, 1986.

●●ref_informative

[Aggarwal2010]
    Aggarwal, G., Burzstein, E., Jackson, C., and D. Boneh, ＜An Analysis of Private Browsing Modes in Modern Browsers＞, 2010, URL: http://www.usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf
[app-isolation]
    Chen, E., Bau, J., Reis, C., Barth, A., and C. Jackson, ＜App Isolation - Get the Security of Multiple Browsers with Just One＞, 2011, URL: http://www.collinjackson.com/research/papers/appisolation.pdf
[CSRF]
    Barth, A., Jackson, C., and J. Mitchell, ＜Robust Defenses for Cross-Site Request Forgery＞, ISBN 978-1-59593-810-7, ACM CCS '08: Proceedings of the 15th ACM conference on Computer and communications security (pages 75-88), October 2008, URL: http://portal.acm.org/citation.cfm?id=1455770.1455782
[FETCH]
    van Kesteren, A., ＜Fetch Living Standard＞, n.d., WHATWG. URL: https://fetch.spec.whatwg.org/
[HTML]
    van Kesteren, A., Denicola, D., Farolino, D., Hickson, I., Jägenstedt, P., and S. Pieters, ＜HTML Living Standard＞, n.d., WHATWG. URL: https://html.spec.whatwgorg/>

[HttpFieldNameRegistry]
    ＜Hypertext Transfer Protocol (HTTP) Field Name Registry＞, n.d., URL: https://www.iana.org/assignments/http-fields/
[prerendering]
    Bentzel, C., ＜Chrome Prerendering＞, n.d., URL: https://www.chromium.org/developers/design-documents/prerender
[PSL]
    ＜Public Suffix List＞, n.d., URL: https://publicsuffix.org/list/
[RFC2109]
     Kristol, D. and L. Montulli, ＜HTTP State Management Mechanism＞, ~RFC2109, February 1997.
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, ＜Uniform Resource Identifier (URI): Generic Syntax＞, STD 66, ~RFC3986, January 2005
[RFC4648]
    Josefsson, S., ＜The Base16, Base32, and Base64 Data Encodings＞, ~RFC4648, October 2006
[RFC6265]
    Barth, A., ＜HTTP State Management Mechanism＞, ~RFC6265, April 2011
[RFC7034]
    Ross, D. and T. Gondrom, ＜HTTP Header Field X-Frame-Options＞, ~RFC7034, October 2013
[RFC9113]
    Thomson, M., Ed. and C. Benfield, Ed., ＜HTTP/2＞, ~RFC9113, June 2022
[RFC9114]
    Bishop, M., Ed., ＜HTTP/3＞, ~RFC9114, June 2022
[SERVICE-WORKERS]
    Archibald, J. and M. Kruisselbrink, ＜Service Workers＞, n.d., URL: https://www.w3.org/TR/service-workers/
[TLS13]
    Rescorla, E., ＜The Transport Layer Security (TLS) Protocol Version 1.3＞, ~RFC8446, August 2018

●●ref_additional
[COOKIES]
    Johann Hofmann; Anne van Kesteren. ＜Cookies: HTTP State Management Mechanism＞. URL: https://httpwg.org/http-extensions/draft-ietf-httpbis-layered-cookies.html
[URL]
    ＜URL＞, A. van Kesteren. WHATWG.
    URL: https://url.spec.whatwg.org/
[INFRA]
    ＜Infra＞, A. van Kesteren, D. Denicola. WHATWG.
    URL: https://infra.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP State Management Mechanism</a>
（ RFC 6265 の改訂）を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

公表者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	6265 （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	Steven Bingler (Google LLC), <a href="bingler@chromium.org">Email</a>
	<a href="https://mikewest.org/">Mike West</a> (Google LLC), <a href="mkwst@google.com">Email</a>
	John Wilander (Apple, Inc), <a href="wilander@apple.com">Email</a>
課題追跡
	https://github.com/httpwg/http-extensions/labels/6265bis
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-rfc6265bis/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-rfc6265bis.md
HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications

</script>

</head>

<body>


<header>
	<hgroup>
<h1>クッキー： HTTP 状態管理の仕組み</h1>
<p>Cookies: HTTP State Management Mechanism</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は~HTTP `Cookie^h と `Set-Cookie^h ~headerを定義する。
これらの~headerは、
（~cookieと呼ばれる）状態~情報を~HTTP~UA側に格納させるために，
~HTTP~serverにより利用され得るものであり、
ほぼ状態~情報がない~HTTP~protocol越しに，
~serverが状態を保つ~sessionを保守できるようにする。
~cookieには，~securityと~privacyを退行させる 多くの歴史的な欠陥があるが、
`Cookie^h と `Set-Cookie^h ~headerは~internet上で広く利用されている。
この文書は `RFC6265$r を廃用にする†。
◎
This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 6265.
</p>

<p class="trans-note">【†
しかしながら、
この文書も，その改訂 `COOKIES$r により廃用にされることになる。
当面の間は，この日本語訳も残しておくが、
そのうち，この~siteから除去されるかもしれない。
】</p>

	</section>
	<section>
<h2 title="About This Document">この文書について</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#about-this-draft$に移譲。
】</p>

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
この文書は、
~HTTP［
`Cookie^h, `Set-Cookie^h
］~headerを定義する。
~HTTP~serverは、
`Set-Cookie^h ~headerを利用して，~cookieと呼ばれる［
( 名前, 値 ) が成す~pair, それに結付けられた~metadata
］を~UAに渡せる。
~UAは、
~serverへ後続な要請を為す際に，
その~metadataと他の情報を利用して
( 名前, 値 ) が成す~pairを `Cookie^h ~header内に返すかどうか決定する。
◎
This document defines the HTTP Cookie and Set-Cookie header fields. Using the Set-Cookie header field, an HTTP server can pass name/value pairs and associated metadata (called cookies) to a user agent. When the user agent makes subsequent requests to the server, the user agent uses the metadata and other information to determine whether to return the name/value pairs in the Cookie header field.
</p>

<p class="trans-note">【
“~header” は、
正式には “~header~field（ `header field^en ）” と称されるが，
この訳では一律に “~header” と略記する。
】【
“~cookie” は、
~dataとしては［
~serverが `Set-Cookie^h ~header内に送信するそれ／
~UAが自身の`~cookie保管庫$内に格納するそれ／
~UAが `Cookie^h ~header内に送信するそれ
］いずれかを指す
— どれを指すかは、
文脈に依存する。
】</p>

<p>
見かけの単純さに反し、
~cookieには，いくつかの複階性がある。
例えば，~serverは、
~UAに向けて送信する各~cookieごとに，その視野を指示する。
この視野は、
当の~cookieを［
~UAが返すべき期間,
~UAが返すべき~server,
適用-可能な接続~種別【`~secureな接続$か否か】
］を指示する。
◎
Although simple on their surface, cookies have a number of complexities. For example, the server indicates a scope for each cookie when sending it to the user agent. The scope indicates the maximum amount of time in which the user agent should return the cookie, the servers to which the user agent should return the cookie, and the connection types for which the cookie is applicable.
</p>

<p>
歴史的な理由から、
~cookieには，~securityと~privacyに関わる いくつかの欠陥がある。
例えば，~serverは、
`Secure$a 属性により［
当の~cookieは、
`~secureな接続$用に意図される
］ことを指示できるが、
それは，能動的~network攻撃者が居る下で完全性（ `integrity^en ）を供するものではない。
同様に、
異なる~portを介して検索取得された内容どうしは，
~web~browserに利用される通例の “同一-生成元~施策” （ `same-origin policy^en ）により隔離されるにも関わらず、
所与の~host用の~cookieは，同じ~host上のすべての~portにわたって共有される。
◎
For historical reasons, cookies contain a number of security and privacy infelicities. For example, a server can indicate that a given cookie is intended for "secure" connections, but the Secure attribute does not provide integrity in the presence of an active network attacker. Similarly, cookies for a given host are shared across all the ports on that host, even though the usual "same-origin policy" used by web browsers isolates content retrieved via different ports.
</p>

<p>
この仕様は、［
~cookieを生産する~server,
~cookieを消費する~UA
］どちらの開発者にも適用される。
`3.2§ にて、
これら各~実装~種別に意図される対象読者を明確化する助けを与える。
◎
This specification applies to developers of both cookie-producing servers and cookie-consuming user agents. Section 3.2 helps to clarify the intended target audience for each implementation type.
</p>

<p>
~UAとの相互運用能を最大~化するため、
~serverは，自らを`きちんと挙動するための~profile$に制限する下で~cookieを生成するベキである。
◎
To maximize interoperability with user agents, servers SHOULD limit themselves to the well-behaved profile defined in Section 4 when generating cookies.
</p>

<p>
~UAは、
`きちんと挙動するための~profile$に適合しない既存の~serverとの相互運用能を最大~化するため、
`~UA要件§にて定義される より~~寛容な処理~規則を実装しなければナラナイ。
◎
User agents MUST implement the more liberal processing rules defined in Section 5, in order to maximize interoperability with existing servers that do not conform to the well-behaved profile defined in Section 4.
</p>

<p>
この文書は、
これらの~headerの構文と意味論を，~internetにおける実際の利用に沿うように指定する。
特に、
この文書は，今日 利用-中にあるものを超える新たな構文や意味論を創出するものではない。
`~server要件§に与える，~cookie生成についての推奨は、
現在の~serverの挙動を成す好ましい~subsetを表現する。
`~UA要件§にて与える，より~~寛容な~cookie処理~algoは、
今日 利用-中にある［
構文や意味論の~variation
］を成すすべてを推奨するものではない。
この文書では、
一部の既存の~softwareにおける，推奨される~protocolとの有意な差異についても説明する。
◎
This document specifies the syntax and semantics of these header fields as they are actually used on the Internet. In particular, this document does not create new syntax or semantics beyond those in use today. The recommendations for cookie generation provided in Section 4 represent a preferred subset of current server behavior, and even the more liberal cookie processing algorithm provided in Section 5 does not recommend all of the syntactic and semantic variations in use today. Where some existing software differs from the recommended protocol in significant ways, the document contains a note explaining the difference.
</p>

<p>
この文書は `RFC6265$r を廃用にする。
◎
This document obsoletes [RFC6265].
</p>

	</section>
	<section id="conventions">
<h2 title="Conventions">2. 表記規約</h2>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
いくつかの用語（外部の仕様にて定義されるものなど）には、
~linkを補完している。
</p>

		</section>
		<section id="conformance-criteria">
<h3 title="Conformance Criteria">2.1. 適合性の判定基準</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#conformance-criteria$に移譲。
】</p>

		</section>
		<section id="syntax-notation">
<h3 title="Syntax Notation">2.2. 構文の記法</h3>

<p>
この仕様は
`RFC5234$r
による~ABNF（ Augmented Backus-Naur Form ）記法を利用する。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].
</p>

<p>
次に挙げる中核~規則は、
`RFC 5234, Appendix B.1＠~RFCx/rfc5234#appendix-B.1$
にて定義されるものとして，参照される
⇒＃
`ALPHA^P （ `letters^en ）,
`CR^P （ `carriage return^en ）,
`CRLF^P （ CR LF ）,
`CTL^P （制御文字）,
`DIGIT^P （ 10 進数字 0-9 ）,
`DQUOTE^P （二重引用符）,
`HEXDIG^P （ 16 進数字 0-9/A-F/a-f ）,
`LF^P （ `line feed^en ）,
`NUL^P （ ~NULL ~octet ）,
`OCTET^P （ `NUL^P 以外の任意の 8-bit ~data列）,
`SP^P （ `space^en ）,
`HTAB^P （ `horizontal tab^en ）,
`CHAR^P （【 `NUL^P 以外の】任意の `USASCII$r 文字）,
`VCHAR^P （任意の可視な `USASCII$r 文字）,
`WSP^P （空白【 `SP^P と `HTAB^P 】）
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTLs (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), NUL (null octet), OCTET (any 8-bit sequence of data except NUL), SP (space), HTAB (horizontal tab), CHAR (any [USASCII] character), VCHAR (any visible [USASCII] character), and WSP (whitespace).
</p>

<p>
次に挙げる規則は、
`HTTP$r にて定義される
⇒＃
【`IMF-fixdate$p,】
【`token$p,】
`OWS$p （省略可能な空白）,
`BWS$p （不良な空白）
◎
The OWS (optional whitespace) and BWS (bad whitespace) rules are defined in Section 5.6.3 of [HTTP].
</p>

		</section>
		<section id="terminology">
<h3 title="Terminology">2.3. 各種用語</h3>

<p>
次に挙げる用語の意味は、
`HTTP$r に従う【~link先を見よ】
【！未利用：~proxy,】
⇒＃
`~UA$,
`~client$,
`~server$,
`生成元~server$
◎
The terms "user agent", "client", "server", "proxy", and "origin server" have the same meaning as in the HTTP/1.1 specification (Section 3 of [HTTP]).
</p>

<p>
`要請~host@
とは、
`~UA$が［
~HTTP要請を送信している相手, あるいは
それに対する~HTTP応答を受信した相手
］として，~UAに既知な~host名を~~意味する。
◎
The request-host is the name of the host, as known by the user agent, to which the user agent is sending an HTTP request or from which it is receiving an HTTP response (i.e., the name of the host to which it sent the corresponding HTTP request).
</p>

<p>
`要請~URI@
（ `request-uri^en ）は、
`~target~URI$ `HTTP$r を指す。
◎
The term request-uri refers to "target URI" as defined in Section 7.1 of [HTTP].
</p>

<p>
2 個の［
~octet列
］は、
`RFC4790$r にて定義される
`i;ascii-casemap collation＠~RFCx/rfc4790#section-9.2.1$en
の下で等価であるとき, そのときに限り，
`文字大小無視で合致する@
とされる。
【 `INFRA$r にて定義される`~byte大小無視$と同じ。】
◎
Two sequences of octets are said to case-insensitively match each other if and only if they are equivalent under the i;ascii-casemap collation defined in [RFC4790].
</p>

<p>
`文字列@
とは、
`NUL^P を含まない~octet列を意味する。
◎
The term string means a sequence of non-NUL octets.
</p>

<p class="trans-note">【
したがって、語 “文字” も， 1 個の~octetを意味する。
また、空~文字列は，長さ 0 の`文字列$を意味する。
】【
文法において~ASCIIでない文字が許容される箇所は無いが、
それでも，それらの文字を［
（ `cookie-octet$p 内に）生成する~server／~supportする~UA
］は在る
（`課題 #1073＠https://github.com/httpwg/http-extensions/issues/1073$）。
】</p>

<p>
次に挙げる用語は、
`HTML$r にて定義される
⇒＃
`作動中な閲覧~文脈$nav,
`作動中な文書$nav,
`先祖~navigable群$,
`容器~文書$nav,
`内容~navigable$,
`専用~worker$,
`文書$,
`広義-先祖~navigable群$,
`~navigable$,
`~navigate$,
`不透明な生成元$,
`閲覧~文脈~sandbox化( 生成元 )~flag$,
`共用~worker$,
`the worker's Documents^en†【~workerの`所有者~集合$】,
`~top-level辿可能$,
`WorkerGlobalScope$dom
◎
The terms "active browsing context", "active document", "ancestor navigables", "container document", "content navigable", "dedicated worker", "Document", "inclusive ancestor navigables", "navigable", "navigate", "opaque origin", "sandboxed origin browsing context flag", "shared worker", "the worker's Documents", "top-level traversable", and "WorkerGlobalScope" are defined in [HTML].
</p>

<p class="trans-note">【
原文には挙げらていないが、
他にもある。
明確化するため，この訳では、
他の用語（例：`~node~navigable$）を利用して，等価に言い換えた箇所もある。
】【†
この用語は， `HTML$r には定義されていない（廃されたと思われる）ので、
この訳では，代わる用語に置換する。
】</p>

<p>
`~sw$は、
`SERVICE-WORKERS$r にて定義される。
◎
"Service Workers" are defined in the Service Workers specification [SERVICE-WORKERS].
</p>

<p>
用語
`生成元@
および［
~URIから生成元を導出する仕組み,
生成元~用の “同一-” 照合~algo
］は、
`RFC6454$r にて定義される。
◎
The term "origin", the mechanism of deriving an origin from a URI, and the "the same" matching algorithm for origins are defined in [RFC6454].
</p>

<p class="trans-note">【
~web~platformの文脈では、
`HTML$r が定義する［
`生成元$o，および`同一-生成元$
］と見なすことになろう
（加えて、
`~URL$の`生成元$urlは `URL$r にて定義される）。
特に，この仕様に現れる［
文書の`生成元$doc,
`環境~設定群~obj$の`生成元$enV
］は、
その定義
— ~web~platformに特有な`~domain成分＠~ORIGIN#concept-origin-domain$で拡張された定義 —
に基づく。
この~domain成分は、
この仕様においては，用語 `同一-~site$の中に組入れられる。
また、
`RFC6454$r における GUID は，
`HTML$r における`不透明な生成元$に対応する。
】【
生成元は、
文脈によっては，`生成元~server$の略称を表すこともある。
】</p>

<p>
`安全$な~HTTP~method（
`GET^m, `HEAD^m, `OPTIONS^m, `TRACE^m
など）は、
`HTTP$r にて定義される。
◎
"Safe" HTTP methods include GET, HEAD, OPTIONS, and TRACE, as defined in Section 9.2.1 of [HTTP].
</p>

<p>
~domainの
`公共~接尾辞@
（ `public suffix^en ）とは、
~domainを成す部位のうち
— 例： `com^s ／ `co.uk^s ／ `pvt.k12.wy.us^s など —
公共~registryにより制御されるものを指す。
~domainの
`登録-可能な~domain@
は、
~domainの`公共~接尾辞$に，その直前にある~labelを足したものである。
◎
A domain's "public suffix" is the portion of a domain that is controlled by a public registry, such as "com", "co.uk", and "pvt.k12.wy.us". A domain's "registrable domain" is the domain's public suffix plus the label to its left.＼
</p>

<p>
例えば，
`https://www.site.example^s
に対しては、
その［
`公共~接尾辞$は `example^s,
`登録-可能な~domain$は `site.example^s
］になる。
~UAは、
アリなときは，当日最新の公共~接尾辞~listを利用するベキである
— Mozilla ~projectにより `PSL$r にて保守されているそれなど。
◎
That is, for https://www.site.example, the public suffix is example, and the registrable domain is site.example. Whenever possible, user agents SHOULD use an up-to-date public suffix list, such as the one maintained by the Mozilla project at [PSL].
</p>

<p class="trans-note">【
`URL$r にて定義される［
`公共~接尾辞＠~URL1#host-public-suffix$／
`登録-可能な~domain＠~URL1#host-registrable-domain$
］と同じ。
】【
“~URIの`登録-可能な~domain$” は、
~URIを表現する`~URL$の`生成元$urlの`~host$oの`登録-可能な~domain$の略記である
— ~hostが`~domain$でない場合（例：~IP~address）、定義されない（存在しない）。
】</p>

<p>
次に挙げる用語は、
`FETCH$r にて定義される
⇒
`要請$, および その
【！未利用：`~method$rq, `~URL~list$rq】
【！廃：target browsing context】
⇒＃
`~client$rq,
`現在の~URL$rq
◎
The term "request", as well as a request's "client", "current url", "method", "target browsing context", and "url list", are defined in [FETCH].
</p>

<p>
用語
`非HTTP~API@
は、~cookieを［
設定する／検索取得する
］ために利用される ~HTTP以外の仕組みを指す
— ~scriptに~cookieを公開する~web~browser~APIなど。
【具体的には、 `document.cookie$dom 】
◎
The term "non-HTTP APIs" refers to non-HTTP mechanisms used to set and retrieve cookies, such as a web browser API that exposes cookies to scripts.
</p>

<p>
用語
`~top-level~navi@
は、
`~top-level辿可能$に対する~naviを指す。
◎
The term "top-level navigation" refers to a navigation of a top-level traversable.
</p>

<p class="trans-note">【
“~top-level要請” という語も現れるが、
おそらく，`~top-level~navi$により為される要請を意味する。
】</p>

<p>
この仕様における
`~secureな接続@
（ `"secure" connection^en ）の~~意味は、
`~UA$により定義される。
</p>

<p class="note">注記：
~secureな接続の観念は、
この文書では定義されない。
~UAは，概して、
~transport層の~security
— ~SSLや~TLS `TLS13$r など —
を用立てる接続 `HTTP$r を~secureであると見なす／
あるいは、
~hostが信用-済みな場合もそう見なす。
例えば，ほとんどの~UAは、
"`https^c" を~secureな~protocolを表す~schemeと見なす／
"`localhost^c" を信用-済みな~hostであると見なす。
【！The notion of a "secure" connection ...】
</p>

<p class="trans-note">【
~secureな［
`生成元$／~URI
］は、
その~scheme成分が［
`~secureな接続$を利用する~protocolを表すものである
］ことを意味する。
】【
原文では “~secureな~channel” とも称される箇所もあるが、
実質的に同義なので，この訳では一律に “~secureな接続” と記す。
】【
`~secureな接続$に関する記述は，
原文では他の各所に散らばっているが、
集約するため，この訳では ここに与える。
】</p>

		</section>
	</section>
	<section id="overview">
<h2 title="Overview">3. 概観</h2>

<p>
この節では、［
`生成元~server$が，ある状態~情報を`~UA$に向けて送信する仕方
］および［
~UAが，当の状態~情報を生成元~serverへ返す仕方
］について要旨する。
◎
This section outlines a way for an origin server to send state information to a user agent and for the user agent to return the state information to the origin server.
</p>

<p>
`生成元~server$は、
`~UA$に状態を格納させるために，
~HTTP応答に `Set-Cookie^h ~headerを内包する。
~UAは、
後続な要請において，［
以前に `Set-Cookie^h ~headerにて受信した~cookieを包含する `Cookie^h 要請~header
］を生成元~serverへ返す。
生成元~serverは、
その `Cookie^h ~headerを無視しても, その内容を応用が定義する目的に利用してもかまわない。
◎
To store state, the origin server includes a Set-Cookie header field in an HTTP response. In subsequent requests, the user agent returns a Cookie request header field to the origin server. The Cookie header field contains cookies the user agent received in previous Set-Cookie header fields. The origin server is free to ignore the Cookie header field or use its contents for an application-defined purpose.
</p>

<p>
`生成元~server$は、
どの応答にも `Set-Cookie^h 応答~headerを送信してヨイ。
生成元~serverは、
単独の応答に複数個の `Set-Cookie^h ~headerを内包できる。
`Cookie^h や `Set-Cookie^h ~headerが在っても，~HTTP~cacheが応答を格納したり再利用する~~妨げにはならない。
◎
Origin servers MAY send a Set-Cookie response header field with any response. An origin server can include multiple Set-Cookie header fields in a single response. The presence of a Cookie or a Set-Cookie header field does not preclude HTTP caches from storing and reusing a response.
</p>

<p>
［
`生成元~server$／`媒介者$
］は、
複数個の `Set-Cookie^h ~header値【`~field行l値$】を 1 個の~header【`~field行l$】の中へ結合してはナラナイ。
~headerを結合する通例の仕組み（ `HTTP$r `~headerの結合-法$にて定義される）は、
`Set-Cookie^h における `,^ch の利用と競合するので，
`Set-Cookie^h ~headerの意味論を変更し得る。
◎
Origin servers and intermediaries MUST NOT combine multiple Set-Cookie header fields into a single header field. The usual mechanism for combining HTTP headers fields (i.e., as defined in Section 5.3 of [HTTP]) might change the semantics of the Set-Cookie header field because the %x2C (",") character is used by Set-Cookie in a way that conflicts with such combining.
 folding.
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Set-Cookie: a=b;path=/c,d=e
</pre>

<p>
は、
次のどちらが意図されたのか多義的になる
⇒＃
2 個の~cookie `a=b;…^c と `d=e^c ／
~path `/c,d=e^c を伴う 1 個の~cookie
◎
is ambiguous. It could be intended as two cookies, a=b and d=e, or a single cookie with a path of /c,d=e.
</p>
</div>

<p>
`~UA$は、
`Set-Cookie^h ~headerを［
応答の`状態s~code$／自身の`~cookie施策$
］に基づいて，無視してもヨイ
（ `5.3§ を見よ）。
◎
User agents MAY ignore Set-Cookie header fields based on response status codes or the user agent's cookie policy (see Section 5.3).
</p>

<p>
注記：
~cookieを成す各~octetは、
`USASCII$r 文字として処理されなければナラナイ。
`非HTTP~API$が `USASCII$r 以外の文字を伴う `set-cookie-string$p を渡すこともあり得るが、
これらの~octetを `USASCII$r 文字~以外の何かとして解釈する試みは為されるべきでない。
◎
Note: A cookie's octets MUST be processed as [USASCII] characters. While it's possible a non-HTTP API could pass a set-cookie-string with one or more non-[USASCII] characters, no attempt should be made to interpret these octets as anything other than [USASCII] characters.
</p>

		<section id="examples">
<h3 title="Examples">3.1. 例</h3>

<div class="example">

<p>
~serverは、
`~UA$への~HTTP応答に `Set-Cookie^h ~headerを利用して，
短い`文字列$を送信できる
— ~UAは、
その~cookieの視野に入る未来の~HTTP要請において，
その文字列を返すことになる。
例えば，~serverは、
`SID^s と命名された “~session識別子” として値 `31d4d96e407aad42^s を~UAへ送信できる。
~UAは、
後続な要請にて，その~session識別子を返すことになる：
◎
Using the Set-Cookie header field, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie. For example, the server can send the user agent a "session identifier" named SID with the value 31d4d96e407aad42. The user agent then returns the session identifier in subsequent requests.
</p>

<!-- 
Server -&gt; User Agent
User Agent -&gt; Server
 -->

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>

<p>
~serverは、［
`Path$a ／ `Domain$a
］属性を利用して，~cookieの既定の視野を改めれる。
例えば，~serverは、
`site.example^s の［
どの~path,
どの下位domain
］に対しても，その~cookieを返すよう~UAに指図できる：
◎
The server can alter the default scope of the cookie using the Path and Domain attributes. For example, the server can instruct the user agent to return the cookie to every path and every subdomain of site.example.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=site.example

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>

<p>
次の例に示されるとおり、
~serverは，複数個の~cookieを~UAに格納させれる。
例えば，~serverは、
2 個の `Set-Cookie^h ~headerを返すことにより，
~session識別子と同時に利用者が選好する言語も格納させれる。
~serverは、
より~securityに敏感な~session識別子~用には，
追加的な保護を供する［
`Secure$a, `HttpOnly$a
］`属性$（ § 4.1.2 ）を利用することに注意：
◎
As shown in the next example, the server can store multiple cookies at the user agent. For example, the server can store a session identifier as well as the user's preferred language by returning two Set-Cookie header fields. Notice that the server uses the Secure and HttpOnly attributes to provide additional security protections for the more sensitive session identifier (see Section 4.1.2).
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42; Path=/; Secure; HttpOnly
Set-Cookie: lang=en-US; Path=/; Domain=site.example

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
上の `Cookie^h ~headerは、
2 個の~cookie
— `SID^s と命名されたもの, `lang^s と命名されたもの —
を包含していることに注意。
◎
Notice that the Cookie header field above contains two cookies, one named SID and one named lang.
</p>

<p>
~cookie名は、
文字大小区別である。
したがって，~serverが［
名前の文字大小に限り相違する 2 個の `Set-Cookie^h ~header
］を~UAへ送信した場合、
~UAは，それら両~cookieを［
格納して，後続な要請において返す
］ことになる：
◎
Cookie names are case-sensitive, meaning that if a server sends the user agent two Set-Cookie header fields that differ only in their name's case the user agent will store and return both of those cookies in subsequent requests.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: SID=31d4d96e407aad42
Set-Cookie: sid=31d4d96e407aad42

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; sid=31d4d96e407aad42
</pre>

<p>
~UAの “複数~session” 越しに（例：~UAの再起動を挟んで）~cookieを持続させるよう望むなら、
~serverは， `Expires$a 属性にその有効期限を指定できる。
~UAは、
自身の`~cookie保管庫$の総容量が割当分を超過した場合や，
利用者が手動で~serverの~cookieを削除した場合など、
有効期限が過ぎる前に~cookieを削除し得ることに注意。
◎
If the server wishes the user agent to persist the cookie over multiple "sessions" (e.g., user agent restarts), the server can specify an expiration date in the Expires attribute. Note that the user agent might delete the cookie before the expiration date if the user agent's cookie store exceeds its quota or if the user manually deletes the server's cookie.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: lang=en-US; Expires=Wed, 09 Jun 2021 10:18:14 GMT

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
最後に，~cookieを除去するためには、
~serverは，有効期限を過去にした `Set-Cookie^h ~headerを返す。
これが成功するのは、
`Set-Cookie^h ~header内の［
`Path$a, `Domain$a
］両~属性とも，~cookieの作成-時に利用した値に合致するときに限られる。
◎
Finally, to remove a cookie, the server returns a Set-Cookie header field with an expiration date in the past. The server will be successful in removing the cookie only if the Path and the Domain attribute in the Set-Cookie header field match the values used when the cookie was created.
</p>

<pre class="lang-http">
<span>== ~server → ~UA ==</span>

Set-Cookie: lang=; Expires=Sun, 06 Nov 1994 08:49:37 GMT

<span>== ~UA → ~server ==</span>

Cookie: SID=31d4d96e407aad42
</pre>
</div>

		</section>
		<section id="implementation-advisory">
<h3 title="Which Requirements to Implement">3.2. どの要件を実装するか</h3>

<p>
下に与える［
`~server要件§, `~UA要件§
］は、
別個な種別の実装~用の要件群を論じる。
この節は、
実装者が自身の目標に どちらの要件群が最も適するか決定する際の手引きとして意味される。
間違った要件群を選ぶと，他の~cookie実装との互換性を欠如する結果にもなり得る。
◎
The upcoming two sections, Section 4 and Section 5, discuss the set of requirements for two distinct types of implementations. This section is meant to help guide implementers in determining which set of requirements best fits their goals. Choosing the wrong set of requirements could result in a lack of compatibility with other cookie implementations.
</p>

<p>
互換であることが何を意味するかは、
実装者の目標に依存して異なることに注意。
これらの相違点は、［
意図的な仕様~変更,
意図的でない仕様~変更,
仕様の解釈,
歴史的な実装~間の相違点
］に因り，時を経るに伴い築かれてきた。
◎
It's important to note that being compatible means different things depending on the implementer's goals. These differences have built up over time due to both intentional and unintentional spec changes, spec interpretations, and historical implementation differences.
</p>

<p>
この節は、
概ね，~cookie仕様の実装者を 2 つの種別
— 生産器と消費器 —
に分割0する。
これらは、
公式的な用語ではない
— これらは、［
読者が，利用事例に対する直感的な理解を養う
］ことを助けるためにあり，この節でしか利用されない。
◎
This section roughly divides implementers of the cookie spec into two types, producers and consumers. These are not official terms and are only used here to help readers develop an intuitive understanding of the use cases.
</p>

			<section id="cookie-producing-implementations">
<h4 title="Cookie Producing Implementations">3.2.1. ~cookieを生産している実装</h4>

<p>
実装者は、［
~cookieを作成して，~web~browserなどの~UAへ送信する
］ことになるときは，`~server要件§を選ぶべきである。
これらの実装は，この仕様では~serverと称されることが多いが、
~cookieを首に生産するものは，何であれ含まれる
— 例えば：
◎
An implementer should choose Section 4 whenever cookies are created and will be sent to a user agent, such as a web browser. These implementations are frequently referred to as servers by the spec but that term includes anything which primarily produces cookies. Some potential examples:
</p>
<ul>
	<li>
ある［
~web~site／~API
］を~hostしている~server応用
◎
Server applications hosting a website or API
</li>
	<li>
~cookieを~supportする［
~programming言語／~software~framework
］
◎
Programming languages or software frameworks that support cookies
</li>
	<li>
統合された【何に？】第三者-主体による~web応用
— 事業~管理~suiteなど
◎
Integrated third-party web applications, such as a business management suite
</li>
</ul>

<p>
これらはいずれも、［
アリな限り多くの~UAを~supportすることのみならず，他の~serverも~supportすること
］から便益を得る。
このことは、［
ある~cookieが，ある~software~frameworkにより生産され、
後で，それを読取る必要がある~server応用へ返送する場合
］に有用になる。
`~server要件§は、
このイミの互換性を最大~化するための助けになる最善な実施を助言する。
◎
All these benefit from not only supporting as many user agents as possible but also supporting other servers. This is useful if a cookie is produced by a software framework and is later sent back to a server application which needs to read it. Section 4 advises best practices that help maximize this sense of compatibility.
</p>

<p>
［
~programming言語／~software~framework
］についての詳細は、
`3.2.2.1＠#languages-frameworks§ を見よ。
◎
See Section 3.2.2.1 for more details on programming languages and software frameworks.
</p>

			</section>
			<section id="cookie-consuming-implementations">
<h4 title="Cookie Consuming Implementations">3.2.2. ~cookieを消費している実装</h4>

<p>
実装者は、
~cookieが首に別の~sourceから受信されるときは，`~UA要件§を選ぶべきである。
これらの実装は、
~UAと称される
— 例えば：
◎
An implementer should choose Section 5 whenever cookies are primarily received from another source. These implementations are referred to as user agents. Some examples:
</p>
<ul>
	<li>
~web~browser
◎
Web browsers
</li>
	<li>
~statefulな~HTTPを~supportする~tool
◎
Tools that support stateful HTTP
</li>
	<li>
~cookieを~supportする［
~programming言語／~software~framework
］
◎
Programming languages or software frameworks that support cookies
</li>
</ul>

<p>
~UAは，［
利用者が どの~serverへ~accessすることになるか
］および［
その~serverは最善な実施に従っているかどうか
］を知り得ないので、
より~~寛容な要件群を実装して，［
~serverが生産すると警告-対象になるもの
］も受容するよう勧める。
`~UA要件§は、
このイミの互換性を最大~化するための助けになる最善な実施を助言する。
◎
Because user agents don't know which servers a user will access, and whether or not that server is following best practices, users agents are advised to implement a more lenient set of requirements and to accept some things that servers are warned against producing. Section 5 advises best practices that help maximize this sense of compatibility.
</p>

<p>
［
~programming言語／~software~framework
］についての詳細は、
`3.2.2.1＠#languages-frameworks§ を見よ。
◎
See Section 3.2.2.1 for more details on programming languages and software frameworks.
</p>

				<section id="languages-frameworks">
<h5 title="Programming Languages &amp; Software Frameworks">3.2.2.1. ~programming言語と~software~framework</h5>

<p>
~cookie用の~supportを伴う［
~programming言語／~software~framework
］は、［
~cookie生産器や~cookie消費器, あるいはこの両者
］として動作する応用を作成するためにも適度に利用され得る。
開発者は，［
生産器／消費器
］としての互換性を最大~化するよう求めるであろうから、
これらの［
言語／~framework
］は，
互換性~mode切り替えの背後で［
`~server要件§, `~UA要件§
］どちらも~supportすることを強く考慮するべきである。
この切り替えは、
既定では，`~server要件§になるべきである。
◎
A programming language or software framework with support for cookies could reasonably be used to create an application that acts as a cookie producer, cookie consumer, or both. Because a developer may want to maximize their compatibility as either a producer or consumer, these languages or frameworks should strongly consider supporting both sets of requirements, Section 4 and Section 5, behind a compatibility mode toggle. This toggle should default to Section 4's requirements.
</p>

<p>
そうすることで、
当の開発者の応用が［
他の~serverにより読取れない~cookie
］を不作為に作成する機会cは，抑制されることになる。
◎
Doing so will reduce the chances that a developer's application can inadvertently create cookies that cannot be read by other servers.
</p>

				</section>
			</section>
		</section>
	</section>
	<section id="sane-profile">
<h2 title="Server Requirements">4. ~serverに課される要件</h2>

<p>
この節では、［
`Cookie^h ／ `Set-Cookie^h
］~headerが
`きちんと挙動するための~profile@
（ `well-behaved profile^en ）†
を成す構文と意味論を述べる。
◎
This section describes the syntax and semantics of a well-behaved profile of the Cookie and Set-Cookie header fields.
</p>

<p class="trans-note">【†
既存の［
~server, ~UA
］の挙動から導出された， “きちんとした挙動” を成す描像。
】</p>

		<section id="sane-set-cookie">
<h3 title="Set-Cookie">4.1. `Set-Cookie^h ~header</h3>

<p>
`Set-Cookie^h ~HTTP応答~headerは、
~serverから~UAへ~cookieを送信するときに利用される。
◎
The Set-Cookie HTTP response header field is used to send cookies from the server to the user agent.
</p>

			<section id="abnf-syntax">
<h4 title="Syntax">4.1.1. 構文</h4>

<p>
非正式には、
`Set-Cookie^h 応答~headerの値は，［
次の並びで与えられる 1 個の~cookie
］を包含する：
◎
Informally, the Set-Cookie response header field contains a cookie,＼
</p>
<ol>
	<li>
( ~cookieの名前（ `cookie-name$p ）, ~cookieの値（ `cookie-value$p ） )
が成す~pair（ `cookie-pair$p ）
◎
which begins with a name-value-pair,＼
</li>
	<li>
0 個~以上の`属性$（ `cookie-av$p ）
— 各 `属性$は、
( 属性~名, 属性~値 )
が成す~pairを与える
◎
followed by zero or more attribute-value pairs.＼
</li>
</ol>

<p>
この~profileに適合している~serverは、
次の文法から逸脱する `Set-Cookie^h ~headerを送信してはナラナイ：
◎
Servers conforming to this profile MUST NOT send Set-Cookie header fields that deviate from the following grammar:
</p>

<pre class="bnf">
`set-cookie@p
	= `set-cookie-string$p
`set-cookie-string@p
	= `BWS$p `cookie-pair$p *( `BWS$p ";" `OWS$p `cookie-av$p )
`cookie-pair@p
	= `cookie-name$p `BWS$p "=" `BWS$p `cookie-value$p
`cookie-name@p
	= `token$p
	; <span class="comment">
`HTTP$r にて定義される
</span>
`cookie-value@p
	= *`cookie-octet$p
	/ ( DQUOTE *`cookie-octet$p DQUOTE )
`cookie-octet@p
	= `%x21^_
	/ `%x23-2B^_
	/ `%x2D-3A^_
	/ `%x3C-5B^_
	/ `%x5D-7E^_
	; <span class="comment">
`CTL^P, `SP^P, `DQUOTE^P, `,^ch, `;^ch, `\^ch 以外の US-ASCII 文字
◎
US-ASCII characters excluding CTLs, whitespace, DQUOTE, comma, semicolon, and backslash
</span>
<span class="_en">token = &lt;token, defined in [HTTP], Section 5.6.2&gt;</span>
`cookie-av@p
	= `expires-av$p
	/ `max-age-av$p
	/ `domain-av$p
	/ `path-av$p
	/ `secure-av$p
	/ `httponly-av$p
	/ `samesite-av$p
	/ `extension-av$p
`expires-av@p
	= "Expires" `BWS$p "=" `BWS$p `sane-cookie-date$p
`sane-cookie-date@p
	= `IMF-fixdate$p
	; <span class="comment">
`HTTP$r にて定義される
【しかしながら、閏秒は許容されない（`日付§を見よ）】
◎
IMF-fixdate, defined in [HTTP], Section 5.6.7
</span>
`max-age-av@p
	= "Max-Age" `BWS$p "=" `BWS$p `non-zero-digit$p *DIGIT
`non-zero-digit@p
	= `%x31-39^_
	; <span class="comment">
数字 1 〜 9
◎
digits 1 through 9
</span>

`domain-av@p
	= "Domain" `BWS$p "=" `BWS$p `domain-value$p
`domain-value@p
	= &lt;`subdomain^p&gt;
	; <span class="comment">
下に与える詳細を見よ
◎
see details below
</span>
`path-av@p
	= "Path" `BWS$p "=" `BWS$p `path-value$p
`path-value@p
	= *`av-octet$p
`secure-av@p
	= "Secure"
`httponly-av@p
	= "HttpOnly"
`samesite-av@p
	= "SameSite" `BWS$p "=" `BWS$p `samesite-value$p
`samesite-value@p
	= "Strict"
	/ "Lax"
	/ "None"
`extension-av@p
	= *`av-octet$p
`av-octet@p
	= `%x20-3A^_
	/ `%x3C-7E^_
	; <span class="comment">
`CTL^P, `;^ch を除く `CHAR^P
◎
any CHAR except CTLs or ";"
</span>
</pre>

<p>
上の中の一部の文法記号は、
この文書の文法記法（ ~ABNF `RFC5234$r ）とは異なる記法を利用する文書を参照していることに注意。
◎
Note that some of the grammatical terms above reference documents that use different grammatical notations than this document (which uses ABNF from [RFC5234]).
</p>

<p>
上の文法により、
`~server$は，名前を伴わない~cookie（すなわち， `cookie-name$p は空）を生産してはナラナイ
— そのような~cookieは、
`~UA$により
— ~serverへ返送するとき —
予測-不能に†直列化されたものである場合もあるので。
【† 例えば，`非HTTP~API$を通して設定されたもの。】
◎
Per the grammar above, servers MUST NOT produce nameless cookies (i.e.: an empty cookie-name) as such cookies may be unpredictably serialized by UAs when sent back to the server.
</p>

<p>
`cookie-value$p の意味論は、
この文書では定義されない。
◎
The semantics of the cookie-value are not defined by this document.
</p>

<p>
`cookie-value$p の中に任意の~dataを格納するよう望む~serverは、
~UAとの互換性を最大~化するためには，その~dataを【 `cookie-octet$p のみからなるよう】符号化するベキである
（例えば， Base64 `RFC4648$r を利用して）。
◎
To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].
</p>

<p>
上の文法により、
`cookie-value$p は `DQUOTE^P で括られてもヨイ。
この事例では、
先頭と末尾の `DQUOTE^P は剥がされないことに注意
— それらは `cookie-value$p の一部を成し、
~serverへ送信される `Cookie^h ~headerに内包されることになる。
◎
Per the grammar above, the cookie-value MAY be wrapped in DQUOTE characters. Note that in this case, the initial and trailing DQUOTE characters are not stripped. They are part of the cookie-value, and will be included in Cookie header fields sent to the server.
</p>

<p>
上の文法により、
 `cookie-av$p は［
頭部／尾部
］に `WSP$p を包含してはナラナイ
— それらは、
`BWS$p として解釈され，除去されることになるので。
◎
Per the grammar above, cookie-avs MUST NOT contain leading or trailing WSP characters as they will be interpreted as BWS and removed.
</p>

<p>
`domain-value$p は、［
`1034/3.5$rfc にて定義され， `1123/2.1$rfc にて増補される
］とおりの `subdomain^p （ “下位domain” ）である。
したがって、
`domain-value$p は `USASCII$r 文字たちが成す文字列になる
— `5890/2.3.2.1$rfc にて定義される “`A-label^en” など。
◎
The domain-value is a subdomain as defined by Section 3.5 of [RFC1034], and as enhanced by Section 2.1 of [RFC1123]. Thus, domain-value is a string of [USASCII] characters, such as an "A-label" as defined in Section 2.3.2.1 of [RFC5890].
</p>

<p>
`set-cookie-string$p の中で，文法記号 `cookie-av$p が生産する部位は、
`属性@
と称される。
~UAとの互換性を最大~化するためには、
~serverは，同じ `set-cookie-string$p の中に同じ名前の 2 個の属性を生産してはナラナイ
（~UAがこの場合をどう取扱うかについては、
`保管~model§を見よ）。
◎
The portions of the set-cookie-string produced by the cookie-av term are known as attributes. To maximize compatibility with user agents, servers MUST NOT produce two attributes with the same name in the same set-cookie-string. (See Section 5.7 for how user agents handle this case.)
</p>

<p class="note">注記：
`属性$の名前は、
ここでは `CamelCase^en で呈示されるが
（ "`HttpOnly^a" や "`SameSite^a" など），
文字大小無視である。
なので、
文字大小がどうなっていようが
（例： "`httponly^a", "`Httponly^a", "`hTTPoNLY^a", 等々），
受容される。
◎
Note: The name of an attribute-value pair is not case-sensitive. So while they are presented here in CamelCase, such as "HttpOnly" or "SameSite", any case is accepted. E.x.: "httponly", "Httponly", "hTTPoNLY", etc.
</p>

<p>
~serverは、
同じ応答~内に同じ `cookie-name$p の複数個の `Set-Cookie^h ~headerを内包するベキでない。
（~UAがこの場合をどう取扱うかについては、
`5.6§ を見よ。）
◎
Servers SHOULD NOT include more than one Set-Cookie header field in the same response with the same cookie-name. (See Section 5.6 for how user agents handle this case.)
</p>

<p>
~serverが `Set-Cookie^h ~headerを包含している複数個の応答を，同時に~UAに送信した場合
（例：複数の~socket越しに~UAと通信するとき）、
これらの応答は “競争” を生じさせ，
予測-不能な挙動へ導き得る。
◎
If a server sends multiple responses containing Set-Cookie header fields concurrently to the user agent (e.g., when communicating with the user agent over multiple sockets), these responses create a "race condition" that can lead to unpredictable behavior.
</p>

<p class="note">注記：
一部の既存の~UAは、
2 桁表記の年tの解釈が他と異なる。
互換性の課題を避けるため、
~serverは，
`RFC1123$r に則り，年tの表記に 4 桁を要する `rfc1123-date^p 【 `IMF-fixdate$p 】形式を利用するベキである。
◎
Note: Some existing user agents differ in their interpretation of two-digit years. To avoid compatibility issues, servers SHOULD use the rfc1123-date format, which requires a four-digit year.
</p>

<p class="note">注記：
一部の~UAは、
~cookie内の日付を 32-bit の UNIX `time_t^c 型の値として格納し, 処理する。
一部の~systemには， `time_t^c 処理を~supportする~libraryに実装~bugがあり、
その種の~UAでは， 2038 年より後の日付が正しく処理されないかもしれない。
◎
Note: Some user agents store and process dates in cookies as 32-bit UNIX time_t values. Implementation bugs in the libraries supporting time_t processing on some systems might cause such user agents to process dates after the year 2038 incorrectly.
</p>

			</section>
			<section id="sane-set-cookie-semantics">
<h4 title="Semantics (Non-Normative)">4.1.2. 意味論（規範的でない）</h4>

<p class="trans-note">【
“規範的でない” と記されているが、
少数の規範的な要件も含まれている。
】</p>

<p>
この節では、
`Set-Cookie^h ~headerの意味論を単純~化して述べる。
これらの意味論は、
~serverにおける~cookieの最も共通的な利用を理解するには十分詳細なものである。
全部的な意味論は`~UA要件§にて述べる。
◎
This section describes simplified semantics of the Set-Cookie header field. These semantics are detailed enough to be useful for understanding the most common uses of cookies by servers. The full semantics are described in Section 5.
</p>

<p>
`Set-Cookie^h ~headerを受信した~UAは、
その~cookieを，その属性もひっくるめて格納する。
~UAは、
後続して~HTTP要請を為す際には，
適用-可能かつ まだ失効していない~cookieを `Cookie^h ~headerに内包する。
◎
When the user agent receives a Set-Cookie header field, the user agent stores the cookie together with its attributes. Subsequently, when the user agent makes an HTTP request, the user agent includes the applicable, non-expired cookies in the Cookie header field.
</p>

<p id="_-store-cookie">
~UAは、
すでに格納された~cookieと同じ［
`cookie-name$p,
`domain-value$p,
`path-value$p
］を伴う新たな`~cookieを受信した$場合、
既存の~cookieは抹消され，新たな~cookieに置換される。
~serverは、
新たな~cookieを
— その `Expires$a 属性の値を過去に設定した上で —
~UAに送信することにより，~cookieを削除できることに注意。
◎
If the user agent receives a new cookie with the same cookie-name, domain-value, and path-value as a cookie that it has already stored, the existing cookie is evicted and replaced with the new cookie. Notice that servers can delete cookies by sending the user agent a new cookie with an Expires attribute with a value in the past.
</p>

<p>
~cookieは、
~cookieの属性により指示されない限り，
（例えば，下位domainではなく）`生成元~server$に対してのみ返され，
現在の~sessionの終了時に失効する
（ “~sessionの~~終了” は、
~UAにより定義される）。
~UAは、
認識できない~cookie属性を無視する（~cookieまるごと，ではなく）。
◎
Unless the cookie's attributes indicate otherwise, the cookie is returned only to the origin server (and not, for example, to any subdomains), and it expires at the end of the current session (as defined by the user agent). User agents ignore unrecognized cookie attributes (but not the entire cookie).
</p>

				<section id="attribute-expires">
<h5 title="The Expires Attribute">4.1.2.1. `Expires^a 属性</h5>

<p>
`Expires$a 属性は、
~cookieの最長な存続期間を指示するものであり，~cookieが失効する日時として表現される。
~UAは、
指定された期日を調整してもヨイ
— その期日を過ぎるまで~cookieを維持することは、
要求されない。
事実，~UAは、
~memoryの逼迫や~privacyの懸念に因り，~cookieを抹消することが多い。
◎
The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires. The user agent may adjust the specified date and is not required to retain the cookie until that date has passed. In fact, user agents often evict cookies due to memory pressure or privacy concerns.
</p>

<p>
~cookieの存続期間は、
`~UA$の`時計$に基づく
— それは、
~serverの`時計$とは相違し得る。
`~server$は、
~cookieが［
~serverの時計において，正確に指定された日時に抹消される
］ことに依存してはナラナイ。
◎
The cookie's lifetime is based on the user agent's clock which may differ from the server's clock. Servers MUST NOT depend on cookies being evicted exactly at the specified date and time of the server's clock.
</p>

				</section>
				<section id="attribute-max-age">
<h5 title="The Max-Age Attribute">4.1.2.2. `Max-Age^a 属性</h5>

<p>
`Max-Age$a 属性もまた、
~cookieの最長な存続期間を指示するものであり，
~cookieが失効するまでの秒t数として表現される。
~UAは、
指定された期間を調整してもヨイ
— その期間を過ぎるまで~cookieを維持することは、
要求されない。
事実，~UAは、
~memoryの逼迫や~privacyの懸念に因り，~cookieを抹消することが多い。
◎
The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires. The user agent may adjust the specified duration and is not required to retain the cookie for that duration. In fact, user agents often evict cookies due to memory pressure or privacy concerns.
</p>

<p class="note">注記：
一部の既存の~UAは、
`Max-Age$a 属性を~supportしない。
そのような~UAは、
この属性を無視する。
◎
Note: Some existing user agents do not support the Max-Age attribute. User agents that do not support the Max-Age attribute ignore the attribute.
</p>

<p>
~cookieに `Max-Age$a, `Expires$a 両~属性とも与えられている場合、
`Max-Age$a 属性が優先され，~cookieの有効期限を制御する。
~cookieに `Max-Age$a, `Expires$a 両~属性とも与えられていない場合、
~UAは、
（自身が定義する） “現在の~sessionの終了時” まで，~cookieを維持することになる。
◎
If a cookie has both the Max-Age and the Expires attribute, the Max-Age attribute has precedence and controls the expiration date of the cookie. If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until "the current session is over" (as defined by the user agent).
</p>

				</section>
				<section id="attribute-domain">
<h5 title="The Domain Attribute">4.1.2.3. `Domain^a 属性</h5>

<p>
`Domain$a 属性は、
~cookieが送信されることになる~hostを指定する。
例えば， `Domain$a 属性の値が `site.example^l ならば、
~UAは，［
`site.example^s ／
`www.site.example^s ／
`www.corp.site.example^s
］へ向けて~HTTP要請を送信する際に、
その~cookieを `Cookie^h ~headerに内包することになる
（先頭の `.^ch は、
在っても無視されることに注意
— その文字は許可されてないが，それでも）。
~serverが `Domain$a 属性を省略した場合、
~UAは，`生成元~server$に限り~cookieを返すことになる。
◎
The Domain attribute specifies those hosts to which the cookie will be sent. For example, if the value of the Domain attribute is "site.example", the user agent will include the cookie in the Cookie header field when making HTTP requests to site.example, www.site.example, and www.corp.site.example. (Note that a leading %x2E ("."), if present, is ignored even though that character is not permitted.) If the server omits the Domain attribute, the user agent will return the cookie only to the origin server.
</p>

<p class="warning"><strong>警告：</strong>
一部の既存の~UAは、
`Domain$a 属性が無い下でも，
`Domain$a 属性が在って，現在の~host名を包含していたかのように扱う。
例えば，
`site.example^s
が `Domain$a 属性が無い `Set-Cookie^h ~headerを返した場合、
これらの~UAは，その~cookieを
`www.site.example^s
にも誤って送信することになる。
◎
WARNING: Some existing user agents treat an absent Domain attribute as if the Domain attribute were present and contained the current host name. For example, if site.example returns a Set-Cookie header field without a Domain attribute, these user agents will erroneously send the cookie to www.site.example as well.
</p>

<p>
~UAは、
~cookieの `Domain$a 属性が，その~cookieの`生成元~server$を内包する視野を指定していない限り、
その~cookieを却下することになる。
例えば、
`foo.site.example^s
から受信した~cookieの `Domain$a 属性の値が
`site.example^s
や
`foo.site.example^s
であれば，その~cookieは受容されることになるが、
`Domain$a 属性の値が
`bar.site.example^s
や
`baz.foo.site.example^s
であれば，その~cookieは受容されないことになる。
◎
The user agent will reject cookies unless the Domain attribute specifies a scope for the cookie that would include the origin server. For example, the user agent will accept a cookie with a Domain attribute of "site.example" or of "foo.site.example" from foo.site.example, but the user agent will not accept a cookie with a Domain attribute of "bar.site.example" or of "baz.foo.site.example".
</p>

<p class="note">注記：
~securityの理由から、
多くの~UAでは，`公共~接尾辞$に対応する `Domain$a 属性を却下するよう環境設定されている。
例えば，一部の~UAは、
`Domain$a 属性が
`com^l や `co.uk^l
であるものを却下することになる。
（~~詳細は `保管~model§を見よ。）
◎
Note: For security reasons, many user agents are configured to reject Domain attributes that correspond to "public suffixes". For example, some user agents will reject Domain attributes of "com" or "co.uk". (See Section 5.7 for more information.)
</p>

				</section>
				<section id="attribute-path">
<h5 title="The Path Attribute">4.1.2.4. `Path^a 属性</h5>

<p>
各~cookieの視野は、［
その `Path$a 属性で制御される，~pathの集合
］に制限される。
~serverが `Path$a 属性を省略した場合、
~UAは，`要請~URI$の~path成分の “~directory” を既定の値として利用することになる
（詳細は `5.1.4§ を見よ）。
◎
The scope of each cookie is limited to a set of paths, controlled by the Path attribute. If the server omits the Path attribute, the user agent will use the "directory" of the request-uri's path component as the default value. (See Section 5.1.4 for more details.)
</p>

<p>
~UAは、
`要請~URI$の~path部位が~cookieの `Path$a 属性に合致する
（またはその下位~directoryになっている）
場合に限り，その~cookieを~HTTP要請に内包することになる
— ここで， `/^ch は、
~directory分離子として解釈される。
◎
The user agent will include the cookie in an HTTP request only if the path portion of the request-uri matches (or is a subdirectory of) the cookie's Path attribute, where the %x2F ("/") character is interpreted as a directory separator.
</p>

<p>
所与の~hostの中で，~pathが異なる~cookieを互いに隔離することは、
一見 有用であるが，
~securityは `Path$a 属性に依存できない
（`~securityの考慮点§を見よ）。
◎
Although seemingly useful for isolating cookies between different paths within a given host, the Path attribute cannot be relied upon for security (see Section 8).
</p>

				</section>
				<section id="attribute-secure">
<h5 title="The Secure Attribute">4.1.2.5. `Secure^a 属性</h5>

<p>
`Secure$a 属性は、
~cookieの視野を`~secureな接続$に制限する。
`Secure$a 属性を有する~cookieに対しては、
~UAは，`~secureな接続$越しに伝送される場合に限り，
その~cookieを要請に内包することになる。
◎
The Secure attribute limits the scope of the cookie to "secure" channels (where "secure" is defined by the user agent). When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS [TLS13]) [HTTP]).
</p>

				</section>
				<section id="attribute-httponly">
<h5 title="The HttpOnly Attribute">4.1.2.6. `HttpOnly^a 属性</h5>

<p>
`HttpOnly$a 属性は、
~cookieの視野を~HTTP要請に制限する。
特に，この属性は、
`非HTTP~API$を介して~cookieへの~accessを供するときは，
当の~cookieを省略することを~UAに指図する。
◎
The HttpOnly attribute limits the scope of the cookie to HTTP requests. In particular, the attribute instructs the user agent to omit the cookie when providing access to cookies via non-HTTP APIs.
</p>

<p>
`HttpOnly$a 属性, `Secure$a 属性は、
互いに独立であることに注意
— 同じ~cookieが この両`属性$を有せる。
◎
Note that the HttpOnly attribute is independent of the Secure attribute: a cookie can have both the HttpOnly and the Secure attribute.
</p>

				</section>
				<section id="attribute-samesite">
<h5 title="The SameSite Attribute">4.1.2.7. `SameSite^a 属性</h5>

<p>
`SameSite^a 属性は、
~cookieの視野を［
`同一-~site$rqな`要請$に限り，~cookieを伴わせる
【！as defined by the algorithm in Section 5.2】
］よう制限する。
例えば，
`https://site.example/sekrit-image^s
向けの要請は、［
それを起動した文脈の`~cookie用~site$が次を満たす`生成元$である場合
］に限り，`同一-~siteな~cookie$を伴わせることになる
⇒
［
~scheme ~EQ `https^c
］~AND［
~hostの`登録-可能な~domain$【！登録-済み~domain】 ~EQ `site.example^l
］
◎
The "SameSite" attribute limits the scope of the cookie such that it will only be attached to requests if those requests are same-site, as defined by the algorithm in Section 5.2. For example, requests for https://site.example/sekrit-image will attach same-site cookies if and only if initiated from a context whose "site for cookies" is an origin with a scheme and registered domain of "https" and "site.example" respectively.
</p>

<p class="trans-note">【
`同一-~siteな~cookie@
とは、
`~cookie保管庫$に格納された~cookieのうち［
`same-site-flag$cK ~NEQ `None$l
］を満たすものの総称を意味する。
】</p>

<p>
【より~~詳細には，`~cookie保管庫$に格納された】
~cookieを要請に伴わせて送信し得るのは、
`SameSite^a 属性の値†に応じて，要請が次を満たす場合に限られる：
◎
If the "SameSite" attribute's＼
</p>

<p class="trans-note">【†
すなわち、
`5.6.7§に従って正規化した結果の，~cookieの `same-site-flag$cK の値。
】</p>

<ul class="switch">
	<li>
`Strict@l
⇒
`同一-~site$rqである。
◎
value is "Strict", the cookie will only be sent along with "same-site" requests.＼
</li>
	<li>
`Lax@l
⇒
`同一-~site$rqであるか、
`~top-level~navi$によるもの（ `8.8.2§ ）である
— <a href="#strict-lax">§ `Lax^l の施行</a>を見よ。
◎
If the value is "Lax", the cookie will be sent with same-site requests, and with "cross-site" top-level navigations, as described in Section 5.6.7.1.＼
</li>
	<li>
`None@l
⇒
無条件
◎
If the value is "None", the cookie will be sent with same-site and cross-site requests.＼
</li>
	<li>
<p>
`Default@l
（既定の施行~mode）
⇒
~UAが `Lax-allowing-unsafe$l【！`5.6.7.2】 の施行を［
利用するならば それ ／
利用しないならば `Lax$l
］に定義される条件。
</p>

<p class="trans-note">【
この値は、
~serverが送信する `SameSite^a 属性においては，［
上に挙げた `Default^l 以外の値に文字大小無視で合致するもの
］を除く，すべての値に対応する。
】</p>
◎
If the "SameSite" attribute's value is something other than these three known keywords, the attribute's value will be subject to a default enforcement mode that is equivalent to "Lax". If a user agent uses "Lax-allowing-unsafe" enforcement (See Section 5.6.7.2) then this default enforcement mode will instead be equivalent to "Lax-allowing-unsafe".
</li>
</ul>

<p>
`SameSite^a 属性は、
~cookieの作成, および送達に影響する。
この属性において［
`Lax$l ／ `Strict$l
］を表明する~cookieは、
`非同一-~site$rqな［
下位資源~要請や入子な~navi
］に対する応答においては設定し得ない。
設定し得るのは、
それ以外のとき
— `~top-level~navi$や`同一-~site$rqな要請によるとき —
である。
◎
The "SameSite" attribute affects cookie creation as well as delivery. Cookies which assert "SameSite=Lax" or "SameSite=Strict" cannot be set in responses to cross-site subresource requests, or cross-site nested navigations. They can be set along with any top-level navigation, cross-site or otherwise.
</p>

				</section>
			</section>
			<section id="server-name-prefixes">
<h4 title="Cookie Name Prefixes">4.1.3. ~cookie名の接頭辞</h4>

<p>
この文書の
`機密性の弱点§,
`完全性の弱点§
では、
~cookieの歴史的な実装の欠点の一部について綴っている。
特に，~serverにとっては、［
所与の【受信した要請に伴われた】~cookieが，
【以前に，当の~serverが】特定0の［
属性たちが成す集合
］を伴わせて設定したものである
］ものと確証を得ることはアリでない。
そのような確証を後方-互換な仕方で供するため、
~cookieの名前を成す最初の数~文字から 2 つの共通的な要件を推定できる
【ようにする特能を，以下に指定する】。
◎
Section 8.5 and Section 8.6 of this document spell out some of the drawbacks of cookies' historical implementation. In particular, it is impossible for a server to have confidence that a given cookie was set with a particular set of attributes. In order to provide such confidence in a backwards-compatible way, two common sets of requirements can be inferred from the first few characters of the cookie's name.
</p>

<p>
以下に述べる接頭辞~用の~UA要件は、
`5.4§ にて，その詳細が与えられる。
◎
The user agent requirements for the prefixes described below are detailed in Section 5.4.
</p>

<p>
`~UA$との互換性を最大~化するため、
`~server$は，以下に述べるとおりに接頭辞を利用するベキである。
◎
To maximize compatibility with user agents servers SHOULD use prefixes as described below.
</p>

				<section id="the-secure-prefix">
<h5 title="The __Secure- Prefix">4.1.3.1. `__Secure-^l 接頭辞</h5>

<p>
~cookieの名前の頭部が`文字列$ `__Secure-^l に一致している場合、
その~cookieは， `Secure$a 属性を伴って設定されていたことになる。
【~serverが~UAから受信した そのような~cookieは、過去にそのように設定されたものと推定できる。】
◎
If a cookie's name begins with a case-sensitive match for the string __Secure-, then the cookie will have been set with a Secure attribute.
</p>

<div class="example">
<p>
例えば，次の `Set-Cookie^h ~headerは、
`Secure$a 属性を伴わないので，適合tな~UAはそれを却下することになろう。
◎
For example, the following Set-Cookie header field would be rejected by a conformant user agent, as it does not have a Secure attribute.
</p>

<pre class="lang-http">
Set-Cookie: __Secure-SID=12345; Domain=site.example
</pre>

<p>
一方で，次の `Set-Cookie^h ~headerは、［
~secureな生成元（例： "`https://site.example/^c" ）から設定された場合は，受容される／
他の場合は，却下される
］ことになろう：
◎
Whereas the following Set-Cookie header field would be accepted if set from a secure origin (e.g. "https://site.example/"), and rejected otherwise:
</p>

<pre class="lang-http">
Set-Cookie: __Secure-SID=12345; Domain=site.example; Secure
</pre>
</div>

				</section>
				<section id="the-host-prefix">
<h5 title="The __Host- Prefix">4.1.3.2. `__Host-^l 接頭辞</h5>

<p>
~cookieの名前の頭部が`文字列$ `__Host-^l に一致している場合、
その~cookieは，次のように設定されていたことになる
【~serverが~UAから受信した そのような~cookieは、過去にそのように設定されたものと推定できる】
⇒＃
`Secure$a 属性を伴う,
値 `/^ch をとる `Path$a 属性を伴う,
`Domain$a 属性を伴わない
◎
If a cookie's name begins with a case-sensitive match for the string __Host-, then the cookie will have been set with a Secure attribute, a Path attribute with a value of /, and no Domain attribute.
</p>

<p>
この組合nは、
`生成元$を~security境界として扱うことに なるべく近くなるよう，~cookieを切り分ける：
◎
This combination yields a cookie that hews as closely as a cookie can to treating the origin as a security boundary.＼
</p>

<ul>
	<li>
`Domain$a 属性の欠如は、
次を確保する
⇒
当の~cookieの `host-only-flag$cK を ~T にして，~cookieを
— 下位domainに及ぶのを許容することなく —
特定0の~hostに~lockする
◎
The lack of a Domain attribute ensures that the cookie's host-only-flag is true, locking the cookie to a particular host, rather than allowing it to span subdomains.＼
</li>
	<li>
`Path$a を `/^ch に設定することは、
次を意味する
⇒
当の~cookieは、
~host全体に効果的になり，
特定の~path用の~cookieにより上書きされなくなる
◎
Setting the Path to / means that the cookie is effective for the entire host, and won't be overridden for specific paths.＼
</li>
	<li>
`Secure$a 属性は、
次を確保する
⇒＃
~secureでない`生成元$が当の~cookieを改めることはない／
当の~cookieは複数の~protocolにまたがらない【`~secureな接続$に限られる】
◎
The Secure attribute ensures that the cookie is unaltered by non-secure origins, and won't span protocols.
</li>
</ul>

<p>
生成元~modelを~~構成するもののうち，~portのみが、
`__Host-^l ~cookieが無視し続けるものになる。
◎
Ports are the only piece of the origin model that __Host- cookies continue to ignore.
</p>

<div class="example">
<p>
例えば，次に挙げる~cookieは、
常に，~UAにより却下されることになる：
◎
For example, the following cookies would always be rejected:
</p>

<pre class="lang-http">
Set-Cookie: __Host-SID=12345
Set-Cookie: __Host-SID=12345; Secure
Set-Cookie: __Host-SID=12345; Domain=site.example
Set-Cookie: __Host-SID=12345; Domain=site.example; Path=/
Set-Cookie: __Host-SID=12345; Secure; Domain=site.example; Path=/
</pre>

<p>
次の~cookieは、
~secureな生成元（例： `https://site.example/^s ）により設定された場合には受容され，他の場合は却下される：
◎
While the following would be accepted if set from a secure origin (e.g. "https://site.example/"), and rejected otherwise:
</p>

<pre class="lang-http">
Set-Cookie: __Host-SID=12345; Secure; Path=/
</pre>
</div>

				</section>
			</section>
		</section>
		<section id="sane-cookie">
<h3 title="Cookie">4.2. `Cookie^h ~header</h3>

			<section id="syntax">
<h4 title="Syntax">4.2.1. 構文</h4>

<p>
~UAは、
自身が格納した~cookieたちを `Cookie^h ~headerに伴わせて，`生成元~server$へ送信する。
~serverが
<a href="#sane-set-cookie">§ `Set-Cookie^h ~header</a>
の要件に適合する（かつ~UAが`~UA要件§に適合する）場合、
~UAは，次の文法に適合する `Cookie^h ~headerを送信することになる：
◎
The user agent sends stored cookies to the origin server in the Cookie header field. If the server conforms to the requirements in Section 4.1 (and the user agent conforms to the requirements in Section 5), the user agent will send a Cookie header field that conforms to the following grammar:
</p>

<pre class="bnf">
`cookie@p
	= `cookie-string$p
`cookie-string@p
	= `cookie-pair$p *( ";" SP `cookie-pair$p )
</pre>

<p>
`HTTP$r `~fieldの長さ制限s＠~HTTPinfra#fields.limits§は，
~header用には長さ制限sを定義しないが、
~web~serverの実装は，ある上限を課す見込みが高い
— 普及している多くの実装には、
既定の上限 8192 ~octetがある。
`~server$は、
最終的な `cookie-string$p が自身が~headerに課す上限を超過しないよう，
多数の巨大な~cookieを設定することを避けるベキである。
さもなければ、
~serverへの要請を失敗させかねない。
◎
While Section 5.4 of [HTTP] does not define a length limit for header fields it is likely that the web server's implementation does impose a limit; many popular implementations have default limits of 8192 octets. Servers SHOULD avoid setting a large number of large cookies such that the final cookie-string would exceed their header field limit. Not doing so could result in requests to the server failing.
</p>

<p>
`~server$は、
複数個の `Cookie^h ~headerに対し~~寛容でなければナラナイ。
例えば，
~HTTP2 `RFC9113$r や~HTTP3 `RFC9114$r における［
`~client$／`媒介者$
］は、
圧縮を改善するために， `Cookie^h ~headerを分割するかもしれない。
~serverは、
この~~寛容さが どんな形をとるか決定してもかまわない。
例えば，~serverは、［
各 `Cookie^h ~headerを個別に処理する
］ことも［
すべての `Cookie^h ~headerを一つに連結してから，
最終的な 1 個の~headerを処理する
］こともできる。
~serverは、
どちらの~approachをとるか裁定するときには，
自身が~headerに課す上限を念頭に置くべきである。
◎
Servers MUST be tolerant of multiple cookie headers. For example, an HTTP/2 [RFC9113] or HTTP/3 [RFC9114] client or intermediary might split a cookie header to improve compression. Servers are free to determine what form this tolerance takes. For example, the server could process each cookie header individually or the server could concatenate all the cookie headers into one and then process that final, single, header. The server should be mindful of any header field limits when deciding which approach to take.
</p>

<p class="note">注記：
`媒介者$は，
`Cookie^h ~headerを改変し得るが、
~serverが送信されてきた~headerを処理できなくなるのを避けるため，
~serverが~headerに課す共通的な上限も念頭に置くべきである。
例えば、
複数個の `Cookie^h ~headerを 1 個の~headerの中へ連結すると，
~serverの~size上限を超過するかもしれない。
◎
Note: Since intermediaries can modify cookie headers they should also be mindful of common server header field limits in order to avoid sending servers headers that they cannot process. For example, concatenating multiple cookie headers into a single header might exceed a server's size limit.
</p>

			</section>
			<section id="semantics">
<h4 title="Semantics">4.2.2. 意味論</h4>

<p>
各 `cookie-pair$p が，~UAに格納されている~cookieを表現する。
`cookie-pair$p は、
~UAが `Set-Cookie^h ~header内に受信した［
`cookie-name$p と `cookie-value$p
］を包含する。
◎
Each cookie-pair represents a cookie stored by the user agent. The cookie-pair contains the cookie-name and cookie-value the user agent received in the Set-Cookie header field.
</p>

<p>
~cookieの`属性$は、
~UAから~serverへは返されないことに注意。
特に，~serverは、
`Cookie^h ~header~~単独からは，~cookieが［
いつ失効するのか？／
どの~hostに有効なのか？／
どの~pathに有効なのか？／
`Secure$a や `HttpOnly$a 属性を伴って設定されたものかどうか？
］を決定できない。
◎
Notice that the cookie attributes are not returned. In particular, the server cannot determine from the Cookie field alone when a cookie will expire, for which hosts the cookie is valid, for which paths the cookie is valid, or whether the cookie was set with the Secure or HttpOnly attributes.
</p>

<p>
`Cookie^h ~header内の個々の~cookieの意味論については、
この文書では定義されない。
これらの~cookieに対する応用に特有な意味論は、
~serverごとに指定されることが期待されている。
◎
The semantics of individual cookies in the Cookie header field are not defined by this document. Servers are expected to imbue these cookies with application-specific semantics.
</p>

<p>
~cookieは `Cookie^h ~headerにて直列化されるが、
~serverは，その直列化の順序に依拠するベキでない。
特に， `Cookie^h ~headerが同じ名前の 2 個の~cookieを包含している場合
（例：異なる［
`Path$a ／ `Domain$a
］属性を伴って設定されたもの）、
~serverは，これらの~cookieが~header内に現れる順序に依拠するベキでない。
◎
Although cookies are serialized linearly in the Cookie header field, servers SHOULD NOT rely upon the serialization order. In particular, if the Cookie header field contains two cookies with the same name (e.g., that were set with different Path or Domain attributes), servers SHOULD NOT rely upon the order in which these cookies appear in the header field.
</p>

			</section>
		</section>
	</section>
	<section id="ua-requirements">
<h2 title="User Agent Requirements">5. ~UAに課される要件</h2>

<p>
この節では、
`Cookie^h と `Set-Cookie^h ~headerについて、
これらの要件を精確に実装する~UAが，
既存の~serverと
（当の~serverが`きちんと挙動するための~profile$に適合しない場合でも）
相互運用できるに足る詳細を指定する。
◎
This section specifies the Cookie and Set-Cookie header fields in sufficient detail that a user agent implementing these requirements precisely can interoperate with existing servers (even those that do not conform to the well-behaved profile described in Section 4).
</p>

<p>
~UAは、
ここで指定されるものより多くの制約（例：~UAの`~cookie施策$）を施行し得る。
しかしながら，そのような追加の制約は、
既存の~serverとの相互運用能を抑制するものにもなり得る。
◎
A user agent could enforce more restrictions than those specified herein (e.g., restrictions specified by its cookie policy, described in Section 7.2). However, such additional restrictions may reduce the likelihood that a user agent will be able to interoperate with existing servers.
</p>

		<section id="subcomponent-algorithms">
<h3 title="Subcomponent Algorithms">5.1. 下位成分~algo</h3>

<p>
この節では、［
`Cookie^h ／ `Set-Cookie^h
］~headerを成す特定の下位成分を処理するために~UAが利用する，いくつかの~algoを定義する。
【これらの~algoは、後続な節から参照される。】
◎
This section defines some algorithms used by user agents to process specific subcomponents of the Cookie and Set-Cookie header fields.
</p>

			<section id="cookie-date">
<h4 title="Dates">5.1.1. 日付</h4>

<div class="algo">
<p>
~UAは，`文字列$ `cookie-date$p を構文解析するときは、
次と等価な~algoを利用しなければナラナイ：
◎
The user agent MUST use an algorithm equivalent to the following algorithm to parse a cookie-date.＼
</p>
<ol>
	<li>
( %年t値, %月t値, %日t値, %時t値, %分t値, %秒t値 ) ~LET ( ε, ε, ε, ε, ε, ε )
◎
Note that the various boolean flags defined as a part of the algorithm (i.e., found-time, found-day-of-month, found-month, found-year) are initially "not set".
</li>
	<li>
<p>
%~token~list ~LET ［
下の文法を利用して， `cookie-date$p を一連の `date-token$p に分割0した結果
］で与えられる，出現順による~list
◎
Using the grammar below, divide the cookie-date into date-tokens.
</p>

<p class="trans-note">【
この構文解析に失敗することはない
— `delimiter$p と `non-delimiter$p が，あらゆる~octetを消費するので
（後者は、
前者~以外の~octetを表す）。
】</p>

<pre class="bnf">
`cookie-date@p
	= *`delimiter$p `date-token-list$p *`delimiter$p
`date-token-list@p
	= `date-token$p *( 1*`delimiter$p `date-token$p )
`date-token@p
	= 1*`non-delimiter$p

`delimiter@p
	= `%x09^_
	/ `%x20-2F^_
	/ `%x3B-40^_
	/ `%x5B-60^_
	/ `%x7B-7E^_
`non-delimiter@p
	= `%x00-08^_
	/ `%x0A-1F^_
	/ DIGIT
	/ ":"
	/ ALPHA
	/ `%x7F-FF^_
`non-digit@p
	= `%x00-2F^_
	/ `%x3A-FF^_

`day-of-month@p
	= 1*2DIGIT [ `non-digit$p *OCTET ]
`month@p
	= ( "jan" / "feb" / "mar" / "apr" /
	    "may" / "jun" / "jul" / "aug" /
	    "sep" / "oct" / "nov" / "dec" ) *OCTET
`year@p
	= 2*4DIGIT [ `non-digit$p *OCTET ]
`time@p
	= `hms-time$p [ `non-digit$p *OCTET ]
`hms-time@p
	= `time-field$p ":" `time-field$p ":" `time-field$p
`time-field@p
	= 1*2DIGIT
</pre>

	</li>
	<li>
<p>
%~token~list を成す
~EACH( `date-token$p %日付~token )
に対し：
◎
Process each date-token sequentially in the order the date-tokens appear in the cookie-date:
</p>
		<ol>
			<li>
~IF［
%時t値 ~EQ ε
］~AND［
%日付~token は生成規則 `time$p に合致する
］
⇒＃
( %時t値, %分t値, %秒t値 ) ~SET 順に %日付~token の中の各~数字~列が表す数；
~CONTINUE
◎
If the found-time flag is not set and the token matches the time production, set the found-time flag and set the hour-value, minute-value, and second-value to the numbers denoted by the digits in the date-token, respectively. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%日t値 ~EQ ε
］~AND［
%日付~token は生成規則 `day-of-month$p に合致する
］
⇒＃
%日t値 ~SET %日付~token が表す数；
~CONTINUE
◎
If the found-day-of-month flag is not set and the date-token matches the day-of-month production, set the found-day-of-month flag and set the day-of-month-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%月t値 ~EQ ε
］~AND［
%日付~token は生成規則 `month$p に合致する
］
⇒＃
%月t値 ~SET %日付~token が表す月t；
~CONTINUE
◎
If the found-month flag is not set and the date-token matches the month production, set the found-month flag and set the month-value to the month denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
			<li>
~IF［
%年t値 ~EQ ε
］~AND［
%日付~token は生成規則 `year$p に合致する
］
⇒＃
%年t値 ~SET %日付~token が表す数；
~CONTINUE
◎
If the found-year flag is not set and the date-token matches the year production, set the found-year flag and set the year-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.
</li>
		</ol>
	</li>
	<li>
~IF［
ε ~IN { %日t値, %月t値, %年t値, %時t値 }
］
⇒
~RET `失敗^i
◎
↓↓</li>
	<li>
~IF［
%年t値 ~GTE 70
］~AND［
%年t値 ~LTE 99
］
⇒
%年t値 ~INCBY 1900
◎
If the year-value is greater than or equal to 70 and less than or equal to 99, increment the year-value by 1900.
</li>
	<li>
<p>
~IF［
%年t値 ~GTE 0
］~AND［
%年t値 ~LTE 69
］
⇒
%年t値 ~INCBY 2000
◎
If the year-value is greater than or equal to 0 and less than or equal to 69, increment the year-value by 2000.
</p>

<p class="note">注記：
一部の既存の~UAは、
2 桁表記の年tを他と異なるように解釈する。
◎
Note: Some existing user agents interpret two-digit years differently.
</p>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
↓ Abort this algorithm and fail to parse the cookie-date if:
◎
↑ at least one of the found-day-of-month, found-month, found-year, or found-time flags is not set,
</p>
		<ul>
			<li>
［
%日t値 ~LT 1
］~OR［
%日t値 ~GT 31
］
◎
the day-of-month-value is less than 1 or greater than 31,
</li>
			<li>
%年t値 ~LT 1601
◎
the year-value is less than 1601,
</li>
			<li>
%時t値 ~GT 23
◎
the hour-value is greater than 23,
</li>
			<li>
%分t値 ~GT 59
◎
the minute-value is greater than 59, or
</li>
			<li>
%秒t値 ~GT 59
◎
the second-value is greater than 59.
</li>
		</ul>

<p>
…ならば
⇒
~RET `失敗^i
◎
↑</p>

<p>
（閏秒はこの構文では表現できないことに注意。）
◎
(Note that leap seconds cannot be represented in this syntax.)
</p>
	</li>
	<li>
%~cookie日付 ~SET 次で与えられる~UTC（協定世界時）による日付
⇒＃
年t: %年t値,
月t: %月t値,
日t: %日t値,
時t: %時t値,
分t: %分t値,
秒t: %秒t値
◎
Let the parsed-cookie-date be the date whose day-of-month, month, year, hour, minute, and second (in UTC) are the day-of-month-value, the month-value, the year-value, the hour-value, the minute-value, and the second-value, respectively.＼
</li>
	<li>
~IF［
%~cookie日付 が表す日付は存在しない【例： 2 月 31 日】
］
⇒
~RET `失敗^i
◎
If no such date exists, abort this algorithm and fail to parse the cookie-date.
</li>
	<li>
~RET %~cookie日付
◎
Return the parsed-cookie-date as the result of this algorithm.
</li>
</ol>
</div>

			</section>
			<section id="canonicalized-host-names">
<h4 title="Canonicalized Host Names">5.1.2. 正準-化された~host名</h4>

<div class="algo">
<p>
`~host名を正準-化する@
~algoは、
所与の
( %~host名 )
に対し，`文字列$を返す：
◎
A canonicalized host name is the string generated by the following algorithm:
</p>
<ol>
	<li>
%~label群 ~LET 空な~list
◎
↓</li>
	<li>
<p>
%~host名 を成す
~EACH( ~domain名~label %~label )
に対し，現れる順に：
</p>
		<ol>
			<li>
~IF［
%~label は `Non-Reserved LDH^en （ NR-LDH ）~labelでない
］
⇒
%~label ~SET %~label を `A-label^en （ `5890/2.3.2.1$rfc ）に変換した結果
</li>
			<li>
%~label群 に %~label を付加する
</li>
		</ol>
◎
Convert the host name to a sequence of individual domain name labels.
◎
Convert each label that is not a Non-Reserved LDH (NR-LDH) label, to an A-label (see Section 2.3.2.1 of [RFC5890] for the former and latter).
</li>
	<li>
~RET %~label群 を成すすべての~labelを，文字 `.^ch で分離して順に連結した結果
◎
Concatenate the resulting labels, separated by a %x2E (".") character.
</li>
</ol>
</div>

			</section>
			<section id="domain-matching">
<h4 title="Domain Matching">5.1.3. ~domainの照合-法</h4>

<div class="algo">
<p>
所与の
( `文字列$ %文字列, `文字列$ %~domain文字列 )
が
`~domain合致して@
いるとは、
~OR↓ が満たされることをいう
（この時点では、
%~domain文字列, %文字列 は，どちらも小文字に正準-化済みであることに注意）：
◎
A string domain-matches a given domain string if at least one of the following conditions hold:
</p>
<ul>
	<li>
%~domain文字列 ~EQ %文字列
◎
The domain string and the string are identical. (Note that both the domain string and the string will have been canonicalized to lower case at this point.)
</li>
	<li>
<p>
~AND↓：
◎
All of the following conditions hold:
</p>
		<ul>
			<li>
%文字列 の尾部は［
%~domain文字列 の先頭に文字 `.^ch を付加した結果
］に一致する
◎
The domain string is a suffix of the string.
◎
The last character of the string that is not included in the domain string is a %x2E (".") character.
</li>
			<li>
%文字列 は~host名である（すなわち，~IP~addressではない）
◎
The string is a host name (i.e., not an IP address).
</li>
		</ul>
	</li>
</ul>
</div>

			</section>
			<section id="cookie-path">
<h4 title="Paths and Path-Match">5.1.4. ~pathと~path合致-</h4>

<div class="algo">
<p>
~UAは、
~cookieの
`既定の~path@
を算出するときは、
次と等価な~algoを利用しなければナラナイ：
◎
The user agent MUST use an algorithm equivalent to the following algorithm to compute the default-path of a cookie:
</p>
<ol>
	<li>
%~URI~path ~SET `要請~URI$には~path部位が［
在るならば それ／
無いならば 空~文字列
］
◎
Let uri-path be the path portion of the request-uri if such a portion exists (and empty otherwise).
</li>
	<li>
~IF［
%~URI~path は文字 `/^ch を 2 個以上~包含する
］~AND［
%~URI~path を成す最初の文字 ~EQ `/^ch
］
⇒
~RET %~URI~path の［
先頭から最後の `/^ch の直前まで
］を成す文字列
◎
If the uri-path is empty or if the first character of the uri-path is not a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
◎
If the uri-path contains no more than one %x2F ("/") character, output %x2F ("/") and skip the remaining step.
◎
Output the characters of the uri-path from the first character up to, but not including, the right-most %x2F ("/").
</li>
	<li>
~RET `/^ch
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
所与の
( `文字列$ %要請~path, `文字列$ %~cookie~path )
が
`~path合致して@
いるとは、
~OR↓ が満たされることをいう：
◎
A request-path path-matches a given cookie-path if at least one of the following conditions holds:
</p>
<ul>
	<li>
<p>
%~cookie~path ~EQ %要請~path
◎
The cookie-path and the request-path are identical.
</p>

<p class="note">注記：
これは、
`RFC3986$r による~path成分の等価性の規則とは異なることに注意
— よって、
異なる~cookieが，その規則の下で等価な~pathを伴い得る。
◎
Note that this differs from the rules in [RFC3986] for equivalence of the path component, and hence two equivalent paths can have different cookies.
</p>
	</li>
	<li>
次の結果は %要請~path の頭部に一致している
⇒＃
%~cookie~path の末尾に文字 `/^ch が在るならば %~cookie~path ／
~ELSE_ %~cookie~path の末尾に `/^ch を付加した結果
◎
The cookie-path is a prefix of the request-path, and the last character of the cookie-path is %x2F ("/").
◎
The cookie-path is a prefix of the request-path, and the first character of the request-path that is not included in the cookie-path is a %x2F ("/") character.
</li>
</ul>
</div>

			</section>
		</section>
		<section id="same-site-requests">
<h3 title="Same-site and cross-site Requests">5.2. 同一-~site／非同一-~siteな要請</h3>

<p>
2 つの`生成元$が
`同一-~site@
（ `same-site^en ）であるとは、
`SAMESITE$r にて定義される`同一-~site$（ `same site^en ）による判定基準を満足することをいう。
◎
Two origins are same-site if they satisfy the "same site" criteria defined in [SAMESITE].＼
</p>

<p class="trans-note">【
`非同一-~site@
（ `cross-site^en ）は、
`同一-~site$の否定を意味する。
】</p>

<p>
所与の`要請$ %要請 が［
`同一-~site@rq
／
`非同一-~site@rq
］であるとは、
~OR↓ を［
満たす／
満たさない
］ことをいう：
◎
A request is "same-site" if＼
</p>
<ul>
	<li>
<p>
~AND↓：
◎
the following criteria are true:
</p>
		<ul>
			<li>
%要請 は`~UI~reload~navi要請$でない
◎
The request is not the result of a reload navigation triggered through a user interface element (as defined by the user agent; e.g., a request triggered by the user clicking a refresh button on a toolbar).
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
%要請 の`~client$rq ~EQ ~NULL【！has no client】
</li>
					<li>
次は`同一-~site$である
⇒＃
%要請 の`現在の~URL$rqの`生成元$url,
%要請 の`~client$rqの`~cookie用~site$（それは、ある`生成元$を与える）
</li>
				</ul>
◎
The request's current url's origin is same-site with the request's client's "site for cookies" (which is an origin), or if the request has no client or the request's client is null.
</li>
		</ul>
	</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%要請 は`~UI~reload~navi要請$である
</li>
			<li>
%要請 により~reloadされる文書は、
元々は`同一-~site$な要請を介して`~navigate$されたものである
</li>
		</ul>
◎
Requests which are the result of a reload navigation triggered through a user interface element are same-site if the reloaded document was originally navigated to via a same-site request.＼
↑↑A request that is not "same-site" is instead "cross-site".
</li>
</ul>

<p>
`~UI~reload~navi要請@
とは、［
~UAにより定義される，~UI要素を通して誘発される~reload~navi
］により生じる`要請$である（例：利用者が~toolbarの~refresh~buttonを~clickして誘発した要請）。
◎
↑</p>

<p>
`要請$の`~client$rqの
`~cookie用~site@
（ `site for cookies^en ）は，以下の下位~節に述べるとおり，`~client$rqの型†に依存して計算される`生成元$である。
【† すなわち、`~client$rqは，どの型の~objに`関連な設定群~obj$であるか。】
◎
The request's client's "site for cookies" is calculated depending upon its client's type, as described in the following subsections:
</p>

			<section id="document-requests">
<h4 title="Document-based requests">5.2.1. 文書に基づく要請</h4>

<p>
~UAの~URL~bar内に表示される~URIは，利用者に直に公開される唯一の~security文脈であり、
したがって，利用者が特定0の~web~siteを信用するかどうか決定するにあたって適度に依拠できる唯一の~~情報である。
その~URIの`生成元$は、［
利用者が，自身がヤリトリしていると およそ信じるであろう文脈
］を表現する。
`~top-level生成元@
とは、
この`生成元$
— すなわち`~top-level辿可能$にて`作動中な文書$navの`生成元$ —
として定義される。
◎
The URI displayed in a user agent's address bar is the only security context directly exposed to users, and therefore the only signal users can reasonably rely upon to determine whether or not they trust a particular website. The origin of that URI represents the context in which a user most likely believes themselves to be interacting. We'll define this origin, the top-level traversable's active document's origin, as the "top-level origin".
</p>

<p>
`文書$の`~cookie用~site$は、
`文書$の`~node~navigable$に応じて
【これは、規範的な定義ではない】：
◎
↓</p>
<ul>
	<li>
`~top-level辿可能$である場合、
`~top-level生成元$になる。
◎
For a document displayed in a top-level traversable, we can stop here: the document's "site for cookies" is the top-level origin.
</li>
	<li>
`子~navigable$である場合【！For `容器~文書$nav】、
`7034/4$rfc に述べられるように “~~複数階に入子にされた局面” を織り込むため，
文書の`先祖~navigable群$を成す各`~navigable$にて`作動中な文書$navの`生成元$を聴取する必要がある
⇒
［
文書, その各~先祖~文書
］を成す どの文書に対しても，
( その`生成元$, `~top-level生成元$ )
は`同一-~site$である場合, そのときに限り，`~top-level生成元$になり、
他の場合は，`不透明な生成元$【！に設定される`生成元$】になる。
◎
For container documents, we need to audit the origins of each of a document's ancestor navigables' active documents in order to account for the "multiple-nested scenarios" described in Section 4 of [RFC7034]. A document's "site for cookies" is the top-level origin if and only if the top-level origin is same-site with the document's origin, and with each of the document's ancestor documents' origins. Otherwise its "site for cookies" is an origin set to an opaque origin.
</li>
</ul>

<div class="algo">
<p>
所与の
( `文書$ %文書 )
の`~cookie用~site$は、
次の~algoにより決定される：
◎
Given a Document (document), the following algorithm returns its "site for cookies":
</p>
<ol>
	<li>
%~top文書 ~LET %文書 の`~node~navigable$の`~top-level辿可能$navにて`作動中な文書$nav
◎
Let top-document be the active document in document's navigable's top-level traversable.
</li>
	<li>
%~top生成元 ~LET ［
次が満たされるならば %~top文書 の~URIの`生成元$ ／
~ELSE_ %~top文書 の`生成元$
］
⇒
`閲覧~文脈~sandbox化( 生成元 )~flag$ ~IN %~top文書 にて`作動中な~sandbox法~flag集合$
◎
Let top-origin be the origin of top-document's URI if top-document's sandboxed origin browsing context flag is set, and top-document's origin otherwise.
</li>
	<li>
<p>
［
%文書 の`広義-先祖~navigable群$を成す
~EACH( `~navigable$ %~navigable  )
に対し：
◎
Let documents be a list consisting of the active documents of document's inclusive ancestor navigables.
◎
For each item in documents:
</p>
		<ol>
			<li>
%文書~item ~LET %~navigable にて`作動中な文書$nav
◎
↑</li>
			<li>
%生成元 ~LET ［
次が満たされるならば %文書~item の~URIの`生成元$ ／
~ELSE_ %文書~item の`生成元$
］
⇒
`閲覧~文脈~sandbox化( 生成元 )~flag$ ~IN %文書~item にて`作動中な~sandbox法~flag集合$
◎
Let origin be the origin of item's URI if item's sandboxed origin browsing context flag is set, and item's origin otherwise.
</li>
			<li>
~IF［
( %生成元, %~top生成元 )
は`同一-~site$でない
］
⇒
~RET `不透明な生成元$
◎
If origin is not same-site with top-origin, return an origin set to an opaque origin.
</li>
		</ol>
	</li>
	<li>
~RET %~top生成元
◎
Return top-origin.
</li>
</ol>

<p class="note">注記：
この~algoは、［
%~top文書 から %文書 までの連鎖~全体を成す，すべての文書が作動中【`全部的に作動中$】である
］ときに限り，適用される。
【したがって、 %文書~item が ~NULL になることはない。】
◎
Note: This algorithm only applies when the entire chain of documents from top-document to document are all active.
</p>
</div>

			</section>
			<section id="worker-requests">
<h4 title="Worker-based requests">5.2.2. ~workerに基づく要請</h4>

<p>
~worker駆動な`要請$は、
文書~駆動な要請ほどには明瞭に~~区切れない
— `~top-level辿可能$と~workerとの間には明瞭な~linkは無いので。
このことは、
とりわけ，`~sw$ `SERVICE-WORKERS$r に該当する
— ~swは、
可視な文書がまったく無くとも，裏で~codeを実行し得るので。
◎
Worker-driven requests aren't as clear-cut as document-driven requests, as there isn't a clear link between a top-level traversable and a worker. This is especially true for Service Workers [SERVICE-WORKERS], which may execute code in the background, without any document visible at all.
</p>

				<section id="dedicated-and-shared-requests">
<h5 title="Dedicated and Shared Workers">5.2.2.1. 専用／共用~worker</h5>

<p>
`専用~worker$【 `DedicatedWorkerGlobalScope^dom 】は、
単純である
— 各~専用~worker %~worker には、
それを束縛する文書 %文書 が一つだけあるので。
%~worker の`~cookie用~site$は、［
( %~worker の生成元, %文書 の`~cookie用~site$ )
は`同一-~site$であるならば %文書 の`~cookie用~site$／
~ELSE_ `不透明な生成元$
］になる。
◎
Dedicated workers are simple, as each dedicated worker is bound to one and only one document. The worker's "site for cookies" is the document's "site for cookies" if the worker's origin is same-site with the document's "site for cookies", otherwise its "site for cookies" is an origin set to an opaque origin.
</p>

<p>
`共用~worker$【 `SharedWorkerGlobalScope^dom 】は、
同時に複数個の文書に束縛され得る。
共用~workerの`~cookie用~site$は、［
共用~workerの`生成元$が, それらの文書~すべての`~cookie用~site$と`同一-~site$である場合は それ ／
~ELSE_（~~普通にあり得る）`不透明な生成元$
］になる。
【前~段落, この段落は、規範的な定義ではない。】
◎
Shared workers may be bound to multiple documents at once. As it is quite possible for those documents to have distinct "site for cookies" values, the worker's "site for cookies" will be an origin set to an opaque origin in cases where the values are not all same-site with the worker's origin, and the worker's origin in cases where the values agree.
</p>

<div class="algo">
<p>
所与の
( `WorkerGlobalScope$dom ~obj %~worker )
の`~cookie用~site$は、
次の~algoの結果になる：
◎
Given a WorkerGlobalScope (worker), the following algorithm returns its "site for cookies":
</p>
<ol>
	<li>
%~site ~LET %~worker 【に`関連な設定群~obj$】の`生成元$
◎
Let site be worker's origin.
</li>
	<li>
<p>
%~worker の`所有者~集合$†を成す
~EACH( %~item )
に対し：
◎
For each document in worker's Documents:
</p>
		<ol>
			<li>
%~item~site ~LET %~item の`~cookie用~site$
— これは、
%~item に応じて
⇒＃
`文書$である場合，`文書に基づく要請§に従う ／
`WorkerGlobalScope$dom ~objである場合，この~algoを再帰的に呼出して決定される††
◎
Let document-site be document's "site for cookies" (as defined in Section 5.2.1).
</li>
			<li>
~IF［
( %~item~site, %~site )
は`同一-~site$でない
］
⇒
~RET `不透明な生成元$【！に設定された`生成元$】
◎
If document-site is not same-site with site, return an origin set to an opaque origin.
</li>
		</ol>

<p class="trans-note">【†
`所有者~集合$は、
原文では “`worker's Documents^en” という未定義な（または現在は廃された？）用語で記されている。
】【††
%~worker は別の~workerに入子にされ得るので、
`所有者~集合$
（それは、`文書$を一つも含まないかもしれない）
は再帰的にたどる必要があろう。
】</p>

	</li>
	<li>
~RET %~site
◎
Return site.
</li>
</ol>
</div>

				</section>
				<section id="service-workers">
<h5 title="Service Workers">5.2.2.2. ~sw</h5>

<p>
`~sw$は、
もっと複雑になる。
それは，完全に別々な実行~文脈の下で動作し、
それを登録した`文書$との関係性は，かするほどしかないので。
◎
Service Workers are more complicated, as they act as a completely separate execution context with only tangential relationship to the Document which registered them.
</p>

<p>
~UAが`~sw$をどう取扱うかは，~UA間で相違し得るが、
~UAは， `SERVICE-WORKERS$r 仕様に合致するベキである。
◎
How user agents handle Service Workers may differ, but user agents SHOULD match the [SERVICE-WORKERS] specification.
</p>

				</section>
			</section>
		</section>
		<section id="ignoring-cookies">
<h3 title="Ignoring Set-Cookie Header Fields">5.3. `Set-Cookie^h ~headerの無視-法</h3>

<p>
`~UA$は、［
応答の`状態s~code$は `100 番台$である場合
］には，応答が包含する `Set-Cookie^h ~headerを無視してもヨイ。
加えて、
自身の`~cookie施策$に基づいて無視してもヨイ（ `~cookie施策§ を見よ）。
◎
User agents MAY ignore Set-Cookie header fields contained in responses with 100-level status codes or based on its cookie policy (see Section 7.2).
</p>

<p>
他のすべての `Set-Cookie^h ~headerは、
`5.6§ に則って処理するベキである。
すなわち，応答の`状態s~code$が`100 番台$以外（ `400 番台$, `500 番台$も含む）である場合、
応答に包含される `Set-Cookie^h ~headerを
— `~UA$の`~cookie施策$に則って無視されないならば —
処理するベキである。
◎
All other Set-Cookie header fields SHOULD be processed according to Section 5.6. That is, Set-Cookie header fields contained in responses with non-100-level status codes (including those in responses with 400- and 500-level status codes) SHOULD be processed unless ignored according to the user agent's cookie policy.
</p>

		</section>
		<section id="ua-name-prefixes">
<h3 title="Cookie Name Prefixes">5.4. ~cookie名の接頭辞</h3>

<p>
`~UA$に課される~cookie名の接頭辞~用の要件は、
それと`~server$に課されるそれ（ `4.1.3§ ）とで少し相違する
— `~UA$は、
【特定0の接頭辞の有無を検査する目的においては，】
接頭辞~文字列を文字大小無視で照合しなければナラナイ。
◎
User agents' requirements for cookie name prefixes differ slightly from servers' (Section 4.1.3) in that UAs MUST match the prefix string case-insensitively.
</p>

<p>
接頭辞~用の規範的な要件の詳細は、
`保管~model§に与える~algo内で定義される。
◎
The normative requirements for the prefixes are detailed in the storage model algorithm defined in Section 5.7.
</p>

<p>
このことは、
一部の`~server$が~cookie名【！~cookies】を文字大小無視で処理する結果，［
意図的でなく接頭辞の文字大小を違える／
文字大小が違えられた接頭辞を受容する
］ことになるからである。
◎
This is because some servers will process cookies case-insensitively, resulting in them unintentionally miscapitalizing and accepting miscapitalized prefixes.
</p>

<div class="example">
<p>
例えば、
ある~serverが，次の `Set-Cookie^h ~headerを送信したとする：
◎
For example, if a server sends the following Set-Cookie header field
</p>

<pre class="lang-http">
Set-Cookie: __SECURE-SID=12345
</pre>

<p>
接頭辞を文字大小区別で検査する~UAは、
この~cookieを【 `Secure$a 属性が無くても】受容することになる
— その結果、
当の~serverは，この~cookieが【~UAから返されたとき】［
`__Secure-$l と綴られるものと同じ保証の~subjectになる
【すなわち、 `Secure$a 属性を伴っていた】
］ものと不正に予見することになろう。
◎
to a UA which checks prefixes case-sensitively it will accept this cookie and the server would incorrectly believe the cookie is subject the same guarantees as one spelled __Secure-.
</p>
</div>

<p>
加えて，
接頭辞を文字大小区別で検査する`~UA$がある場合、
~serverは，［
接頭辞を伴う~cookieになりすますために，ある~cookie名の文字大小をわざと違える攻撃者
］に対し脆弱になる。
◎
Additionally the server is vulnerable to an attacker that purposefully miscapitalizes a cookie in order to impersonate a prefixed cookie.＼
</p>

<div class="example">
<p>
例えば、
ある~site用の~cookie `__Secure-SID=12345^c が すでに設定された下で，攻撃者が
— 何らかの手段により —
当の~site用に次の `Set-Cookie^h ~headerを そのような~UAへ送信したとする：
◎
For example, a site already has a cookie __Secure-SID=12345 and by some means an attacker sends the following Set-Cookie header field for the site to a UA which checks prefixes case-sensitively.
</p>

<pre class="lang-http">
Set-Cookie: __SeCuRe-SID=evil
</pre>

<p>
利用者が次回に当の~siteに訪問したとき、
そのような~UAは，どちらの~cookieも送信することになる：
◎
The next time a user visits the site the UA will send both cookies:
</p>

<pre class="lang-http">
Cookie: __Secure-SID=12345; __SeCuRe-SID=evil
</pre>

<p>
文字大小無視で処理している~serverは、
この 2 つの~cookieの相違がわからないので，
当の~siteを弱体化することを攻撃者に許容することになる。
◎
The server, being case-insensitive, won't be able to tell the difference between the two cookies allowing the attacker to compromise the site.
</p>
</div>

<p>
これらの課題を防止するため、
`~UA$は，~cookie名の接頭辞を文字大小無視で照合しなければナラナイ。
◎
To prevent these issues, UAs MUST match cookie name prefixes case-insensitively.
</p>

<p class="note">注記：
それでも、
異なる名前を伴う~cookieどうしは，~UAにより別々なものと見なされる。
なので、［
`__Secure-foo=bar^c, `__secure-foo=baz^c
］は，別個な~cookieとして同時に存在し得る
— どちらにも、
`__Secure-$l 接頭辞の要件が適用されることになる。
◎
Note: Cookies with different names are still considered separate by UAs. So both __Secure-foo=bar and __secure-foo=baz can exist as distinct cookies simultaneously and both would have the requirements of the __Secure- prefix applied.
</p>

<div class="example">
<p>
次に挙げる `Set-Cookie^h ~headerは、
適合tな~UAにおいては却下されることになろう。
◎
The following are examples of Set-Cookie header fields that would be rejected by a conformant user agent.
</p>

<pre class="lang-http">
Set-Cookie: __Secure-SID=12345; Domain=site.example
Set-Cookie: __secure-SID=12345; Domain=site.example
Set-Cookie: __SECURE-SID=12345; Domain=site.example
Set-Cookie: __Host-SID=12345
Set-Cookie: __host-SID=12345; Secure
Set-Cookie: __host-SID=12345; Domain=site.example
Set-Cookie: __HOST-SID=12345; Domain=site.example; Path=/
Set-Cookie: __Host-SID=12345; Secure; Domain=site.example; Path=/
Set-Cookie: __host-SID=12345; Secure; Domain=site.example; Path=/
Set-Cookie: __HOST-SID=12345; Secure; Domain=site.example; Path=/
</pre>

<p>
一方で，次に挙げる `Set-Cookie^h ~headerは、
ある~secureな生成元から設定されたなら，受容されることになろう。
◎
Whereas the following Set-Cookie header fields would be accepted if set from a secure origin.
</p>

<pre class="lang-http">
Set-Cookie: __Secure-SID=12345; Domain=site.example; Secure
Set-Cookie: __secure-SID=12345; Domain=site.example; Secure
Set-Cookie: __SECURE-SID=12345; Domain=site.example; Secure
Set-Cookie: __Host-SID=12345; Secure; Path=/
Set-Cookie: __host-SID=12345; Secure; Path=/
Set-Cookie: __HOST-SID=12345; Secure; Path=/
</pre>
</div>

		</section>
		<section id="cookie-lifetime-limits">
<h3 title="Cookie Lifetime Limits">5.5. ~cookieの存続期間の上限</h3>

<p>
`~UA$は，［
`Expires$a ／ `Max-Age$a
］属性で指定された存続期間を伴う~cookieを処理するときは、
当の~cookieの最大な齢を制限しなければナラナイ。
その上限は、
400 日t（ 34560000 秒t）後の未来を超えるベキではない。
`推奨される^2119上限は 400 日t後の未来であるが、
`~UA$は，上限を調整してもヨイ
（`~cookie施策§を見よ）。
［
`Expires^a ／ `Max-Age^a
］属性が，この上限より長い存続期間を指定する場合、
この上限~以下に抑制しなければナラナイ。
◎
When processing cookies with a specified lifetime, either with the Expires or with the Max-Age attribute, the user agent MUST limit the maximum age of the cookie. The limit SHOULD NOT be greater than 400 days (34560000 seconds) in the future. The RECOMMENDED limit is 400 days in the future, but the user agent MAY adjust the limit (see Section 7.2). Expires or Max-Age attributes that specify a lifetime longer than the limit MUST be reduced to the limit.
</p>

		</section>
		<section id="set-cookie">
<h3 title="The Set-Cookie Header Field">5.6. `Set-Cookie^h ~header</h3>

<p>
`~UA$は、
~HTTP応答~内に受信した `Set-Cookie^h ~headerを まるごと無視してもヨイ
（ `5.3§ を見よ）。
◎
When a user agent receives a Set-Cookie header field in an HTTP response, the user agent MAY ignore the Set-Cookie header field in its entirety (see Section 5.3).
</p>

<p>
`~UA$は，
`Set-Cookie^h ~headerをまるごと無視しない場合には、
以下で定義されるとおり，
`Set-Cookie^h ~headerの値を `set-cookie-string$p として構文解析しなければナラナイ。
◎
If the user agent does not ignore the Set-Cookie header field in its entirety, the user agent MUST parse the field-value of the Set-Cookie header field as a set-cookie-string (defined below).
</p>

<div class="note">
<p>注記：
以下に与える~algoは、
`4.1.1§【！`4.1§】における文法 %文法 よりも許可的である。
例えば、
この~algoは：
◎
Note: The algorithm below is more permissive than the grammar in Section 4.1. For example,＼
</p>
<ul>
	<li>
`cookie-name$p が `cookie-octet$p たちからなることを許容する
— %文法 においては、
`token$p であるものと指定されるが。
◎
the algorithm allows cookie-name to be comprised of cookie-octets instead of being a token as specified in Section 4.1＼
</li>
	<li>
%文法 に則った `cookie-octet$p において、
その一部を成さない いくつかの文字を収容する。
◎
and the algorithm accommodates some characters that are not cookie-octets according to the grammar in Section 4.1.＼
</li>
	<li>
~cookieの［
名前, 値
］から［
頭部／尾部
］を成す空白~列を剥ぐ
（内部の空白は保守される）。
一方で、
%文法 においては，そのような空白は禁止される。
◎
In addition, the algorithm below also strips leading and trailing whitespace from the cookie name and value (but maintains internal whitespace), whereas the grammar in Section 4.1 forbids whitespace in these positions.＼
</li>
</ul>

<p>
~UAは、
`~server要件§の推奨に従わない~serverと相互運用するために，この~algoを利用する。
◎
User agents use this algorithm so as to interoperate with servers that do not follow the recommendations in Section 4.
</p>
</div>

<p class="note">注記：
`set-cookie-string$p は`非HTTP~API$を出自にし得るので、
`CTL^P が無いことは保証されない。
よって，この~algoは、
それらを明示的に取扱う。
ただし， `HTAB^P は、
空白と見なされるので［
`set-cookie-string$p を却下へ至らす `CTL^P
］からは除外され，別々に取扱われる。
◎
Note: As set-cookie-string may originate from a non-HTTP API, it is not guaranteed to be free of CTL characters, so this algorithm handles them explicitly. Horizontal tab (%x09) is excluded from the CTL characters that lead to set-cookie-string rejection, as it is considered whitespace, which is handled separately.
</p>

<p class="note">注記：
`set-cookie-string$p は、［
`RFC3986$r § 2.1 に従って~percent-符号化されたように現れる~octet列
］を包含し得る。
しかしながら、
~UAは，そのような~octet列を復号してはナラナイ
— 代わりに、
個々の~octetを この~algoに指定されるとおり構文解析すること。
◎
Note: The set-cookie-string may contain octet sequences that appear percent-encoded as per Section 2.1 of [RFC3986]. However, a user agent MUST NOT decode these sequences and instead parse the individual octets as specified in this algorithm.
</p>

<div class="algo">
<p>
~UAは、
所与の
( `set-cookie-string$p %~cookie文字列 )
を構文解析するときは、
次と等価な~algoを利用しなければナラナイ
（この~algoの最後の段に達する前に現れる ~RET は、
%~cookie文字列 をまるごと無視することを意味する）：
◎
A user agent MUST use an algorithm equivalent to the following algorithm to parse a set-cookie-string:
</p>
<ol>
	<li>
~IF［
%~cookie文字列 は `HTAB^P 以外の `CTL^P を包含する
］
⇒
~RET
◎
If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F character (CTL characters excluding HTAB): Abort this algorithm and ignore the set-cookie-string entirely.
</li>
	<li>
( %名~値~pair, %属性~list文字列 ) ~SET %~cookie文字列 を文字 `;^ch で`二分$した結果
◎
If the set-cookie-string contains a %x3B (";") character:
• The name-value-pair string consists of the characters up to, but not including, the first %x3B (";"), and the unparsed-attributes consist of the remainder of the set-cookie-string (including the %x3B (";") in question).
◎
Otherwise:
• The name-value-pair string consists of all the characters contained in the set-cookie-string, and the unparsed-attributes is the empty string.
</li>
	<li>
<p>
~IF［
%名~値~pair に文字 `=^ch は含まれていない
］
⇒
( %~cookie名, %~cookie値 ) ~SET ( 空~文字列, %名~値~pair )
</p>

<p class="trans-note">【
`cookie-pair$p は `=^ch を要求しているが、
この~algoでは，その不在も許容されることになる
（これは、
前~version `RFC6265$r からの変更である）。
】</p>
◎
If the name-value-pair string lacks a %x3D ("=") character, then the name string is empty, and the value string is the value of name-value-pair.
</li>
	<li>
~ELSE
⇒
( %~cookie名【！possibly empty】, %~cookie値 ) ~SET %名~値~pair を文字 `=^ch で`二分$した結果
◎
Otherwise, the (possibly empty) name string consists of the characters up to, but not including, the first %x3D ("=") character, and the (possibly empty) value string consists of the characters after the first %x3D ("=") character.
</li>
	<li>
%~cookie名 から頭部と尾部を成す `WSP^P 並びを除去する
◎
↓</li>
	<li>
%~cookie値 から頭部と尾部を成す `WSP^P 並びを除去する
◎
Remove any leading or trailing WSP characters from the name string and the value string.
</li>
	<li>
~IF［
%~cookie名 の長さ ~PLUS %~cookie値 の長さ ~GT 4096
］
⇒
~RET
◎
If the sum of the lengths of the name string and the value string is more than 4096 octets, abort this algorithm and ignore the set-cookie-string entirely.
◎
↑↑The cookie-name is the name string, and the cookie-value is the value string.
</li>
	<li>
%~cookie属性~list ~LET 空~list
（この~listを成す各~itemは、
( 名前, 値 ) が成す~pairで表現される`属性$を与えることになる）
◎
The user agent MUST use an algorithm equivalent to the following algorithm to parse the unparsed-attributes:
</li>
	<li>
<p>
~WHILE［
%属性~list文字列 ~NEQ 空~文字列
］：
◎
If the unparsed-attributes string is empty, skip the rest of these steps.
</p>
		<ol>
			<li>
( %~cookie属性~文字列, %属性~list文字列 ) ~SET %属性~list文字列 を文字 `;^ch で`二分$した結果
◎
Discard the first character of the unparsed-attributes (which will be a %x3B (";") character).
◎
If the remaining unparsed-attributes contains a %x3B (";") character:
• Consume the characters of the unparsed-attributes up to, but not including, the first %x3B (";") character.
◎
Otherwise:
• Consume the remainder of the unparsed-attributes.
◎
Let the cookie-av string be the characters consumed in this step; unparsed-attributes now contains any remaining characters.
</li>
			<li>
( %属性~名, %属性~値 ) ~SET %~cookie属性~文字列 を文字 `=^ch で`二分$した結果
◎
If the cookie-av string contains a %x3D ("=") character:
• The (possibly empty) attribute-name string consists of the characters up to, but not including, the first %x3D ("=") character, and the (possibly empty) attribute-value string consists of the characters after the first %x3D ("=") character.
◎
Otherwise:
• The attribute-name string consists of the entire cookie-av string, and the attribute-value string is empty.
</li>
			<li>
%属性~名 から 頭部と尾部を成す `WSP^P 並びを除去する
◎
Remove any leading or trailing WSP characters from the attribute-name string＼
</li>
			<li>
%属性~値 から 頭部と尾部を成す `WSP^P 並びを除去する
◎
and the attribute-value string.
</li>
			<li>
~IF［
%属性~値 の長さ ~GT 1024
］
⇒
~CONTINUE
◎
If the attribute-value is longer than 1024 octets, ignore the cookie-av string and return to Step 1 of this algorithm.
</li>
			<li>
<p>
この節の各 下位~節に与える要件に従って，
%属性~名, %属性~値
を処理する（ %属性~名 が下位~節のどの~algoからも認識されない属性は無視する）
</p>

<p class="trans-note">【
処理に成功したなら、
%~cookie属性~list に`属性$が付加される。
同じ名前の複数個の属性が付加された場合、
名前を問わず，最後のもの以外は無視されることになる
（`保管~model§を見よ）
（この~listは、
実際には~mapとして定義した方が，この仕様の記述は もっと簡潔になろう）。
】</p>
◎
Process the attribute-name and attribute-value according to the requirements in the following subsections. (Notice that attributes with unrecognized attribute-names are ignored.)
◎
Return to Step 1 of this algorithm.
</li>
		</ol>
	</li>
	<li>
この段に達した時点で、
~UAは，`要請~URI$から
( 名前: %~cookie名, 値: %~cookie値, 属性~list: %~cookie属性~list )
を伴う
`~cookieを受信した@
とされる
（~cookieを受信したことにより誘発される追加的な要件については、
`保管~model§を見よ）。
◎
When the user agent finishes parsing the set-cookie-string, the user agent is said to "receive a cookie" from the request-uri with name cookie-name, value cookie-value, and attributes cookie-attribute-list. (See Section 5.7 for additional requirements triggered by receiving a cookie.)
</li>
</ol>
</div>

<div class="algo">
<p>
上の~algoにおいて、
`文字列$ %S を文字 %c で
`二分@
するときは、
次で与えられる 2 個の`文字列$が成す（有順序な）~pairを返すとする：
</p>
<ol>
	<li>
%S の先頭から連続する， %c でない文字からなる，最長な`文字列$（ %S が空~文字列，または %S の先頭が %c ならば，空~文字列）
</li>
	<li>
前段の残りを成す`文字列$から，（もしあれば）先頭の %c は除外した`文字列$（残りが空~文字列, または %c 1 個だけならば，空~文字列）
</li>
</ol>

<p class="trans-note">【
この定義は、
記述を簡潔かつ簡明にするために，この訳に導入している。
】</p>
</div>

			<section id="ua-attribute-expires">
<h4 title="The Expires Attribute">5.6.1. `Expires^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `Expires^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ：
◎
If the attribute-name case-insensitively matches the string "Expires", the user agent MUST process the cookie-av as follows.
</p>
<ol>
	<li>
%失効日時 ~LET `日付§に従って，
%属性~値 を `cookie-date$p として構文解析した結果
◎
Let the expiry-time be the result of parsing the attribute-value as cookie-date (see Section 5.1.1).
</li>
	<li>
~IF［
%失効日時 ~EQ `失敗^i
］
⇒
~RET
— この`属性$は無視する
◎
If the attribute-value failed to parse as a cookie date, ignore the cookie-av.
</li>
	<li>
%~cookie齢の上限 ~LET ~cookieの最大~齢
（ 400 日t~以内の未来になるベキである
— `~cookieの存続期間の上限§を見よ）
◎
Let cookie-age-limit be the maximum age of the cookie (which SHOULD be 400 days in the future or sooner, see Section 5.5).
</li>
	<li>
~IF［
%失効日時 は %~cookie齢の上限 を超える
］
⇒
%失効日時 ~SET %~cookie齢の上限【！ in seconds】
◎
If the expiry-time is more than cookie-age-limit, the user agent MUST set the expiry time to cookie-age-limit in seconds.
</li>
	<li>
~UAは次をしてもヨイ
⇒
~IF［
%失効日時 は ~UAが表現-可能な最も過去の日付より前
］
⇒
%失効日時 ~SET ~UAが表現-可能な最も過去の日付
◎
If the expiry-time is earlier than the earliest date the user agent can represent, the user agent MAY replace the expiry-time with the earliest representable date.
</li>
	<li>
%~cookie属性~list に
( 名前: `Expires$a, 値: %失効日時 )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Expires and an attribute-value of expiry-time.
</li>
</ol>
</div>

			</section>
			<section id="ua-attribute-max-age">
<h4 title="The Max-Age Attribute">5.6.2. `Max-Age^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `Max-Age^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ：
◎
If the attribute-name case-insensitively matches the string "Max-Age", the user agent MUST process the cookie-av as follows.
</p>
<ol>
	<li>
<p>
~IF［
%属性~値 は ~AND↓ を満たさない
］…
</p>
		<ul>
			<li>
1 個以上の `DIGIT^P を含む
</li>
			<li>
最初の文字は［
`DIGIT^P ／ `-^ch
］である
</li>
			<li>
最初~以外の文字は（在るならば）すべて `DIGIT^P である
</li>
		</ul>
<p>
…ならば
⇒
~RET
— この`属性$は無視する
</p>

◎
If the attribute-value is empty, ignore the cookie-av.
◎
If the first character of the attribute-value is neither a DIGIT, nor a "-" character followed by a DIGIT, ignore the cookie-av.
◎
If the remainder of attribute-value contains a non-DIGIT character, ignore the cookie-av.
</li>
	<li>
%秒差 ~SET %属性~値 を基数 10 の下で整数に変換した結果
【最初の文字が 0 でも他の基数に解釈しない】
◎
Let delta-seconds be the attribute-value converted to a base 10 integer.
</li>
	<li>
%~cookie齢の上限 ~LET 【秒t数による】~cookieの最大~齢
（ 400 日t間~以下になるベキである
— `~cookieの存続期間の上限§を見よ）
◎
Let cookie-age-limit be the maximum age of the cookie (which SHOULD be 400 days or less, see Section 5.5).
</li>
	<li>
~IF［
%秒差 ~GT %~cookie齢の上限
］
⇒
%秒差 ~SET %~cookie齢の上限
◎
Set delta-seconds to the smaller of its present value and cookie-age-limit.
</li>
	<li>
%失効日時 ~LET ［
%秒差 ~LTE 0 ならば ~UAが表現-可能な最も過去の日付 ／
~ELSE_ 現在の日時から %秒差 秒~後の日時
］
◎
If delta-seconds is less than or equal to zero (0), let expiry-time be the earliest representable date and time. Otherwise, let the expiry-time be the current date and time plus delta-seconds seconds.
</li>
	<li>
%~cookie属性~list に
( 名前: `Max-Age$a, 値: %失効日時 )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Max-Age and an attribute-value of expiry-time.
</li>
</ol>
</div>

			</section>
			<section id="the-domain-attribute">
<h4 title="The Domain Attribute">5.6.3. `Domain^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `Domain^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ：
◎
If the attribute-name case-insensitively matches the string "Domain", the user agent MUST process the cookie-av as follows.
</p>
<ol>
	<li>
%~cookie~domain ~LET ［
%属性~値 を成す最初の文字 ~EQ `.^ch ならば %属性~値 から最初の文字を除いた結果 ／
~ELSE_ %属性~値
］
◎
Let cookie-domain be the attribute-value.
◎
If cookie-domain starts with %x2E ("."), let cookie-domain be cookie-domain without its leading %x2E (".").
</li>
	<li>
%~cookie~domain ~SET %~cookie~domain を小文字~化した結果
◎
Convert the cookie-domain to lower case.
</li>
	<li>
%~cookie属性~list に
( 名前: `Domain$a, 値: %~cookie~domain )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Domain and an attribute-value of cookie-domain.
</li>
</ol>
</div>

			</section>
			<section id="the-path-attribute">
<h4 title="The Path Attribute">5.6.4. `Path^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `Path^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ：
◎
If the attribute-name case-insensitively matches the string "Path", the user agent MUST process the cookie-av as follows.
</p>
<ol>
	<li>
%~cookie~path ~LET %属性~値
◎
↓</li>
	<li>
~IF［
%~cookie~path ~EQ 空~文字列
］~OR［
%~cookie~path を成す最初の文字 ~NEQ `/^ch
］
⇒
%~cookie~path ~SET `既定の~path$
◎
If the attribute-value is empty or if the first character of the attribute-value is not %x2F ("/"):
• Let cookie-path be the default-path.
◎
Otherwise:
• Let cookie-path be the attribute-value.
</li>
	<li>
%~cookie属性~list に
( 名前: `Path$a, 値: %~cookie~path )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of Path and an attribute-value of cookie-path.
</li>
</ol>
</div>

			</section>
			<section id="the-secure-attribute">
<h4 title="The Secure Attribute">5.6.5. `Secure^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `Secure^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ
⇒
%~cookie属性~list に
( 名前: `Secure$a, 値: 空~文字列 )
の属性を付加する
◎
If the attribute-name case-insensitively matches the string "Secure", the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of Secure and an empty attribute-value.
</p>
</div>

			</section>
			<section id="the-httponly-attribute">
<h4 title="The HttpOnly Attribute">5.6.6. `HttpOnly^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `HttpOnly^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ
⇒
%~cookie属性~list に
( 名前: `HttpOnly$a, 値: 空~文字列 )
の属性を付加する
◎
If the attribute-name case-insensitively matches the string "HttpOnly", the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of HttpOnly and an empty attribute-value.
</p>
</div>

			</section>
			<section id="the-samesite-attribute">
<h4 title="The SameSite Attribute">5.6.7. `SameSite^a 属性</h4>

<div class="algo">
<p>
~UAは、［
%属性~名 が`文字列$ `SameSite^l に`文字大小無視で合致する$
］`属性$を，次に従って処理しなければナラナイ：
◎
If the attribute-name case-insensitively matches the string "SameSite", the user agent MUST process the cookie-av as follows:
</p>
<ol>
	<li>
%値 ~LET %属性~値 に応じて
⇒＃
`None^l に`文字大小無視で合致する$ならば `None$l ／
`Strict^l に`文字大小無視で合致する$ならば `Strict$l ／
`Lax^l に`文字大小無視で合致する$ならば `Lax$l ／
~ELSE_ `Default$l
◎
Let enforcement be "Default".
◎
If cookie-av's attribute-value is a case-insensitive match for "None", set enforcement to "None".
◎
If cookie-av's attribute-value is a case-insensitive match for "Strict", set enforcement to "Strict".
◎
If cookie-av's attribute-value is a case-insensitive match for "Lax", set enforcement to "Lax".
</li>
	<li>
%~cookie属性~list に
( 名前: `SameSite$a, 値: %値 )
の属性を付加する
◎
Append an attribute to the cookie-attribute-list with an attribute-name of "SameSite" and an attribute-value of enforcement.
</li>
</ol>
</div>

				<section id="strict-lax">
<h5 title="Strict and Lax enforcement">5.6.7.1. `Strict^l ／ `Lax^l の施行</h5>

<p>
`同一-~siteな~cookie$のうち `Strict$l 施行~modeにされたものは、
`非同一-~site$rqな文書~文脈から誘発された`~top-level~navi$に伴って送信されることはない。
`8.8.2§ にて論じるように、
これは，既存の~session管理~systemと互換にならないこともある。
`~CSRF攻撃$の~riskを軽減する `drop-in^en な仕組み【具体的には，当の § 8.8.2 を見よ】を供することに関心がある開発者は、
`SameSite$a 属性を `Lax$l 施行~modeに設定できる
— それは，例外として、
`安全$な【！in the `RFC7231$r sense】~HTTP~methodを利用する`~top-level~navi$である場合に限り，
`非同一-~site$rqな要請に`同一-~siteな~cookie$を伴わせて送信する。
（要請の~methodは、
一部の~redirectに対しては，
`POST$m から `GET$m に変更され得ることに注意
（ `HTTP$r `301§st, `302§st を見よ
— そのような事例では、
要請の “安全” さは，現在の~redirect~hop【~redirectされた要請】の~methodに基づいて決定される。）
◎
Same-site cookies in "Strict" enforcement mode will not be sent along with top-level navigations which are triggered from a cross-site document context. As discussed in Section 8.8.2, this might or might not be compatible with existing session management systems. In the interests of providing a drop-in mechanism that mitigates the risk of CSRF attacks, developers may set the SameSite attribute in a "Lax" enforcement mode that carves out an exception which sends same-site cookies along with cross-site requests if and only if they are top-level navigations which use a "safe" (in the [HTTP] sense) HTTP method. (Note that a request's method may be changed from POST to GET for some redirects (see Sections 15.4.2 and 15.4.3 of [HTTP]); in these cases, a request's "safe"ness is determined based on the method of the current redirect hop.)
</p>

<p>
`Lax$l の施行は、［
`~CSRF攻撃$のうち，`安全$でない~HTTP~method（ `POST$m など）に依拠するもの
］に抗する適度な多層防御を供するが，それ以外の~CSRF攻撃に抗する堅牢な防御は提供しない：
◎
Lax enforcement provides reasonable defense in depth against CSRF attacks that rely on unsafe HTTP methods (like POST), but does not offer a robust defense against CSRF as a general category of attack:
</p>

<ul>
	<li>
攻撃者は、
依然として
— `文書に基づく要請§にて述べたとおり —
`同一-~site$rqな要請を作成するために，
新たな~UIwindowを~pop-upし得る／
`~top-level~navi$を誘発し得る
— そのような悪用にとって， `Lax^l は路上の段差ほどにしかならない。
◎
Attackers can still pop up new windows or trigger top-level navigations in order to create a "same-site" request (as described in Section 5.2.1), which is only a speedbump along the road to exploitation.
</li>
	<li>
`&lt;link rel="prerender"&gt;^c `prerendering$r の様な特能は、
`同一-~site$rqな要請を作成するために悪用され得る
— 利用者から検出される~riskなしに。
◎
Features like &lt;link rel='prerender'&gt; [prerendering] can be exploited to create "same-site" requests without the risk of user detection.
</li>
</ul>

<p>
開発者は、
~session管理の仕組み
— `8.8.2§ に述べるものなど —
を通して，`~CSRF攻撃$を もっと完全に軽減できる。
◎
Developers can more completely mitigate CSRF through a session management mechanism such as that described in Section 8.8.2.
</p>

				</section>
				<section id="lax-allowing-unsafe">
<h5 title="'Lax-Allowing-Unsafe' enforcement">5.6.7.2. `Lax-allowing-unsafe^l の施行</h5>

<p>
`8.8.6§ にて論じられるとおり、
互換性の懸念により，
`Lax-allowing-unsafe$l 施行~modeの利用が必要yあり得る
— それは、
要請~methodを問わず，
`~top-level要請$である場合, そのときに限り［
~cookieが`非同一-~site$rqな~HTTP要請に伴って送信される
］ことを許容する。
すなわち， `Lax-allowing-unsafe$l 施行~modeは、
【その場合に対し，】［
`~cookieを検索取得する$~algoの
`SameSite$a を`施行する段＠#step-for-same-site$における要件
“要請の~methodは`安全$である”
を放棄する。
（［
`SameSite$a にて供された施行~mode,
~HTTP要請~method
］を問わず，`~top-level~navi$に対しては，どの~cookieも
— `保管~model§にて指定されるとおり —
設定され得る。）
◎
As discussed in Section 8.8.6, compatibility concerns may necessitate the use of a "Lax-allowing-unsafe" enforcement mode that allows cookies to be sent with a cross-site HTTP request if and only if it is a top-level request, regardless of request method. That is, the "Lax-allowing-unsafe" enforcement mode waives the requirement for the HTTP request's method to be "safe" in the SameSite enforcement step of the retrieval algorithm in Section 5.8.3. (All cookies, regardless of SameSite enforcement mode, may be set for top-level navigations, regardless of HTTP request method, as specified in Section 5.7.)
</p>

<p>
`Lax-allowing-unsafe$l は、
`SameSite$a 属性に指定し得る【！distinct】値ではない。
~UAは、
`SameSite$a 属性を明示的に指定していない~cookie（すなわち，`same-site-flag$cK は既定で `Default$l に設定されたもの）に限り，
`Lax-allowing-unsafe$l の施行を適用してもヨイ。
この互換性~modeの視野を制限するため、
`Lax-allowing-unsafe$l の施行を適用する~UAは，
その施行を近過去に作成された~cookieに制約するベキである。
配備~経験から、
適度な上限として，作成してから 2 分 以下のものに限ることが示されている。
◎
"Lax-allowing-unsafe" is not a distinct value of the SameSite attribute. Rather, user agents MAY apply "Lax-allowing-unsafe" enforcement only to cookies that did not explicitly specify a SameSite attribute (i.e., those whose same-site-flag was set to "Default" by default). To limit the scope of this compatibility mode, user agents which apply "Lax-allowing-unsafe" enforcement SHOULD restrict the enforcement to cookies which were created recently. Deployment experience has shown a cookie age of 2 minutes or less to be a reasonable limit.
</p>

<p>
~UAは， `Lax-allowing-unsafe$l 施行~modeを利用する場合には、
`~cookieを検索取得する$ ~algoに対し，次の改変を適用しなければナラナイ
⇒
~algo内の［
`該当する段＠#step-for-same-site$の中に与えた，次の条件 (1)
］を次の条件 (2) に置換する：
◎
If the user agent uses "Lax-allowing-unsafe" enforcement, it MUST apply the following modification to the retrieval algorithm defined in Section 5.8.3:
◎
Replace the condition in the penultimate bullet point of step 1 of the retrieval algorithm reading
</p>

<ul>
	<li>
(1)
%検索取得 の`要請$rTの~methodは`安全$である
◎
• The HTTP request associated with the retrieval uses a "safe" method.
with
</li>
	<li>
(2) ［
%検索取得 の`要請$rTの~methodは`安全$である
］~OR［［
%~cookie の `same-site-flag$cK ~EQ `Default$l
］~AND［
%~cookie の `creation-time$cK から経過した時間は、
~UAが選んだ~~上限以下である
］］
◎
• At least one of the following is true:
•• 1. The HTTP request associated with the retrieval uses a "safe" method.
•• 2. The cookie's same-site-flag is "Default" and the amount of time elapsed since the cookie's creation-time is at most a duration of the user agent's choosing.
</li>
</ul>

				</section>
			</section>
		</section>
		<section id="storage-model">
<h3 title="Storage Model">5.7. 保管~model</h3>

<p>
~UAは、
受信した~cookieを格納するための大域的な
`~cookie保管庫@
（ `cookie store^en ）を保守する。
`~cookie保管庫$を成す各~cookieは、
次に挙げる~fieldからなる
⇒＃
`name@cK,
`value@cK,
`expiry-time@cK,
`domain@cK,
`path@cK,
`creation-time@cK,
`last-access-time@cK,
`persistent-flag@cK,
`host-only-flag@cK,
`secure-only-flag@cK,
`http-only-flag@cK,
`same-site-flag@cK
◎
The user agent stores the following fields about each cookie: name, value, expiry-time, domain, path, creation-time, last-access-time, persistent-flag, host-only-flag, secure-only-flag, http-only-flag, and same-site-flag.
</p>

<div class="algo">
<p>
~UAは、
`要請~URI$から
( 名前: %~cookie名, 値: %~cookie値, 属性~list: %~cookie属性~list )
を伴う`~cookieを受信した$ときは、
その~cookieを，以下に従って処理しなければナラナイ
（この~algoの最後の段に達する前に現れる ~RET は、
受信した~cookieをまるごと無視することを意味する）：
◎
When the user agent "receives a cookie" from a request-uri with name cookie-name, value cookie-value, and attributes cookie-attribute-list, the user agent MUST process the cookie as follows:
</p>
<ol>
	<li>
~UAは次をしてもヨイ（ `5.3§を見よ）
⇒
~RET
◎
A user agent MAY ignore a received cookie in its entirety. See Section 5.3.
</li>
	<li>
~IF［
%~cookie名 ~EQ 空~文字列
］~AND［
%~cookie値 ~EQ 空~文字列
］
⇒
~RET
◎
If cookie-name is empty and cookie-value is empty, abort this algorithm and ignore the cookie entirely.
</li>
	<li>
~IF［
%~cookie名 は `HTAB^P 以外の `CTL^P を包含する
］~OR［
%~cookie値 は `HTAB^P 以外の `CTL^P を包含する
］
⇒
~RET
◎
If the cookie-name or the cookie-value contains a %x00-08 / %x0A-1F / %x7F character (CTL characters excluding HTAB), abort this algorithm and ignore the cookie entirely.
</li>
	<li>
~IF［
%~cookie名 の長さ ~PLUS %~cookie値 の長さ ~GT 4096
］
⇒
~RET
◎
If the sum of the lengths of cookie-name and cookie-value is more than 4096 octets, abort this algorithm and ignore the cookie entirely.
</li>
	<li>
%要請~host ~LET `~host名を正準-化する$( `要請~host$ )
◎
↓</li>
	<li>
<p>
%新~cookie ~LET 新たな~cookie
— その
⇒＃
`name$cK ~SET %~cookie名,
`value$cK ~SET %~cookie値,
`expiry-time$cK ~SET ~UAが表現-可能な最も~~未来の日付,
`domain$cK ~SET %要請~host,
`path$cK ~SET `要請~URI$の`既定の~path$,
`creation-time$cK ~SET 現在の日時,
`last-access-time$cK ~SET 現在の日時,
`persistent-flag$cK ~SET ~F,
`host-only-flag$cK ~SET ~T,
`secure-only-flag$cK ~SET ~F,
`http-only-flag$cK ~SET ~F,
`same-site-flag$cK ~SET `Default$l
◎
Create a new cookie with name cookie-name, value cookie-value. Set the creation-time and the last-access-time to the current date and time.
◎
↓↓</p>

<p class="trans-note">【
~logicを単純化するため，この訳では、
予め，~cookieの全~fieldを “既定の値” に初期化する。
】</p>
	</li>
	<li>
~IF［
%~cookie属性~list 内に 名前 `Max-Age$a の属性は在る
］
⇒＃
%新~cookie の `persistent-flag$cK ~SET ~T；
%新~cookie の `expiry-time$cK ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Max-Age":
• Set the cookie's persistent-flag to true.
• Set the cookie's expiry-time to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "Max-Age".
</li>
	<li>
~ELIF［
%~cookie属性~list 内に 名前 `Expires$a の属性は在る
］
⇒＃
%新~cookie の `persistent-flag$cK ~SET ~T；
%新~cookie の `expiry-time$cK ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
Otherwise, if the cookie-attribute-list contains an attribute with an attribute-name of "Expires" (and does not contain an attribute with an attribute-name of "Max-Age"):
• Set the cookie's persistent-flag to true.
• Set the cookie's expiry-time to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "Expires".
◎
↑↑Otherwise:
• Set the cookie's persistent-flag to false.
• Set the cookie's expiry-time to the latest representable date.
</li>
	<li>
%~domain ~LET 空~文字列
◎
↓</li>
	<li>
<p>
~IF［
%~cookie属性~list 内に名前 `Domain$a の属性であって［
その値の長さ ~LTE 1024
］を満たすものは在る
］
⇒
%~domain ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
</p>

<p>
（ %~domain の先頭の `.^ch は、
在っても無視されることに注意
— その文字は許可されてないが，それでも）
</p>
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Domain":
• Let the domain-attribute be the attribute-value of the last attribute in the cookie-attribute-list with both an attribute-name of "Domain" and an attribute-value whose length is no more than 1024 octets. (Note that a leading %x2E ("."), if present, is ignored even though that character is not permitted.)
◎
↑Otherwise:
• Let the domain-attribute be the empty string.
</li>
	<li>
~IF［
%~domain は `CHAR^P 以外の文字を包含する
］
⇒
~RET
◎
If the domain-attribute contains a character that is not in CHAR, abort this algorithm and ignore the cookie entirely.
</li>
	<li>
<p id="_reject-public-suffix">
~IF［
~UAは`公共~接尾辞$を却下するよう環境設定されている
］~AND［
%~domain は`公共~接尾辞$である
］：
◎
If the user agent is configured to reject "public suffixes" and the domain-attribute is a public suffix:
</p>
				<ol>
					<li>
~IF［
%~domain ~NEQ %要請~host
］
⇒
~RET
◎
↑If the domain-attribute is identical to the canonicalized request-host:
• Let the domain-attribute be the empty string.
◎
Otherwise:
• Abort this algorithm and ignore the cookie entirely.
</li>
					<li>
%~domain ~SET 空~文字列
◎
↑</li>
				</ol>

<p class="note">注記：
この段は、
下位domainに居る攻撃者（例： `attacker.example^s ）が［
その`公共~接尾辞$（例： `example^s ）を値にとる `Domain$a 属性
］を伴う~cookieを設定することにより［
別の下位domain（例： `site.example^s ）の完全性を侵害すること
］を防止するために本質的である。
◎
Note: This step prevents attacker.example from disrupting the integrity of site.example by setting a cookie with a Domain attribute of "example".
</li>
	<li>
<p>
~IF［
%~domain ~NEQ 空~文字列
］：
</p>
		<ol>
			<li>
~IF［
( %要請~host, %~domain )
は`~domain合致して$いない
］
⇒
~RET
</li>
			<li>
%新~cookie の `host-only-flag$cK ~SET ~F
</li>
			<li>
%新~cookie の `domain$cK ~SET %~domain
</li>
		</ol>
◎
If the domain-attribute is non-empty:
• If the canonicalized request-host does not domain-match the domain-attribute:
•• Abort this algorithm and ignore the cookie entirely.
• Otherwise:
•• Set the cookie's host-only-flag to false.
•• Set the cookie's domain to the domain-attribute.
◎
↑↑Otherwise:
• Set the cookie's host-only-flag to true.
• Set the cookie's domain to the canonicalized request-host.
</li>
	<li>
~IF［
%~cookie属性~list 内に 名前 `Path$a の属性であって［
その値の長さ ~LTE 1024
］を満たすものは在る
］
⇒
%新~cookie の `path$cK ~SET ［ 該当する属性のうち %~cookie属性~list 内で最後のもの ］の値
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Path", set the cookie's path to attribute-value of the last attribute in the cookie-attribute-list with both an attribute-name of "Path" and an attribute-value whose length is no more than 1024 octets.＼
↑↑Otherwise, set the cookie's path to the default-path of the request-uri.
</li>
	<li>
%~secureか ~LET ~IS［
`要請~URI$は`~secureな接続$を表す
］
◎
↓</li>
	<li>
<p>
~IF［
%~cookie属性~list 内に名前 `Secure$a の属性は在る
］：
</p>
		<ol>
			<li>
~IF［
%~secureか ~EQ ~F
］
⇒
~RET
</li>
			<li>
%新~cookie の `secure-only-flag$cK ~SET ~T
</li>
		</ol>
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "Secure", set the cookie's secure-only-flag to true.＼
↑↑Otherwise, set the cookie's secure-only-flag to false.
◎
If the request-uri does not denote a "secure" connection (as defined by the user agent), and the cookie's secure-only-flag is true, then abort these steps and ignore the cookie entirely.
</li>
	<li>
%非~HTTP~APIか ~LET ~IS［
%新~cookie は`非HTTP~API$から受信された
【~UAは、非HTTP~APIを介して設定された`~cookieを受信した$かのように挙動している】
］
◎
↓</li>
	<li>
<p>
~IF［
%~cookie属性~list 内に 名前 `HttpOnly$a の属性は在る
］：
</p>
		<ol>
			<li>
~IF［
%非~HTTP~APIか ~EQ ~T
］
⇒
~RET
</li>
			<li>
%新~cookie の `http-only-flag$cK ~SET ~T
</li>
		</ol>
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "HttpOnly", set the cookie's http-only-flag to true.＼
↑↑Otherwise, set the cookie's http-only-flag to false.
◎
If the cookie was received from a "non-HTTP" API and the cookie's http-only-flag is true, abort this algorithm and ignore the cookie entirely.
</li>
	<li>
<p>
~IF［
%新~cookie の `secure-only-flag$cK ~EQ ~F
］~AND［
%~secureか ~EQ ~F
］~AND［
`~cookie保管庫$内に ~AND↓ を満たす~cookieは在る
］…
◎
If the cookie's secure-only-flag is false, and the request-uri does not denote a "secure" connection, then abort this algorithm and ignore the cookie entirely if the cookie store contains one or more cookies that meet all of the following criteria:
</p>
		<ul>
			<li>
その `name$cK ~EQ【！matches】 %新~cookie の `name$cK
◎
Their name matches the name of the newly-created cookie.
</li>
			<li>
その `secure-only-flag$cK ~EQ ~T
◎
Their secure-only-flag is true.
</li>
			<li>
［
( その `domain$cK, %新~cookie の `domain$cK )
は`~domain合致して$いる
］~OR［
( %新~cookie の `domain$cK, その `domain$cK )
は`~domain合致して$いる
］
◎
Their domain domain-matches the domain of the newly-created cookie, or vice-versa.
</li>
			<li>
( %新~cookie の `path$cK, その `path$cK )
は`~path合致して$いる
◎
The path of the newly-created cookie path-matches the path of the existing cookie.
</li>
		</ul>

<p>
…ならば
⇒
~RET
</p>

<p class="note">注記：
~pathの比較が対称でないのは、［
%新~cookie が~secureでない場合は、
既存の~secureな~cookie
【のうち~pathの視野が %新~cookie 以上であるもの】
を上塗りしない
］ことを確保して，［
~cookie修正~攻撃に抗する，いくぶんの軽減
］を供するためである。
すなわち，既存の~secureな~cookieに［
`path$cK に `/login^l を伴うもの
］が在る場合、
同じ `name$cK を有する新たな~cookieとして［
`path$cK に `/^l や `/foo^l を伴うもの
］は設定できても，［
`path$cK に `/login^l や `/login/en^l を伴うもの
］は設定できない。
【ここでの~secureとは、 `secure-only-flag$cK ~EQ ~T を意味する。】
◎
Note: The path comparison is not symmetric, ensuring only that a newly-created, non-secure cookie does not overlay an existing secure cookie, providing some mitigation against cookie-fixing attacks. That is, given an existing secure cookie named 'a' with a path of '/login', a non-secure cookie named 'a' could be set for a path of '/' or '/foo', but not for a path of '/login' or '/login/en'.
</p>
	</li>
	<li>
<p>
~IF［
%~cookie属性~list 内に 名前 `SameSite$a の属性は在る
］：
</p>
		<ol>
			<li>
%same-site ~LET 該当する属性のうち %~cookie属性~list 内で最後のものの値
</li>
			<li>
~IF［
%same-site ~IN { `Strict$l, `Lax$l, `None$l }
］
⇒
%新~cookie の `same-site-flag$cK ~SET %same-site
</li>
		</ol>
◎
If the cookie-attribute-list contains an attribute with an attribute-name of "SameSite", and an attribute-value of "Strict", "Lax", or "None", set the cookie's same-site-flag to the attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of "SameSite".＼
↑↑Otherwise, set the cookie's same-site-flag to "Default".
</li>
	<li>
<p>
~IF［
%新~cookie の `same-site-flag$cK ~NEQ `None$l
］：
◎
If the cookie's same-site-flag is not "None":
</p>
		<ol>
			<li>
~IF［
%非~HTTP~APIか ~EQ ~T
］~AND［
その~APIは、
ある`~navigable$にて`作動中な文書$navから~callされていて，
( その文書の`~cookie用~site$, `~top-level生成元$ )
は`同一-~site$でない
］
⇒
~RET
◎
If the cookie was received from a "non-HTTP" API, and the API was called from a navigable's active document whose "site for cookies" is not same-site with the top-level origin, then abort this algorithm and ignore the newly created cookie entirely.
</li>
			<li>
<p>
~IF［
~NOT ~OR↓
］…
</p>
				<ul>
					<li>
%新~cookie は`同一-~site$rqな要請から受信された
【！(as defined in Section 5.2)】
</li>
					<li>
<p>
%新~cookie は，ある`~top-level辿可能$を`~navigate$している`要請$から受信された
`HTML$r
</p>

<p>
（例：
要請の`予約-済み~client$rqは、
~NULL または［
`環境$であって、
その`~target閲覧~文脈$enVは，ある`~top-level辿可能$にて`作動中な閲覧~文脈$navである
］）
</p>
				</li>
				</ul>
<p>
…ならば
⇒
~RET
</p>

<p class="note">注記：
`~top-level~navi$は、
どの `SameSite$a 値を伴う~cookieも作成し得る
— %新~cookie が `wouldn't have been^en 要請に伴って送信され
`had it^en ~naviに先立って存在していた場合でも。【？】
</p>

◎
If the cookie was received from a "same-site" request (as defined in Section 5.2), skip the remaining substeps and continue processing the cookie.
◎
If the cookie was received from a request which is navigating a top-level traversable [HTML] (e.g. if the request's "reserved client" is either null or an environment whose "target browsing context"'s navigable is a top-level traversable), skip the remaining substeps and continue processing the cookie.
◎
Note: Top-level navigations can create a cookie with any SameSite value, even if the new cookie wouldn't have been sent along with the request had it already existed prior to the navigation.
◎
Abort this algorithm and ignore the newly created cookie entirely.
</li>
		</ol>
	</li>
	<li>
~IF［
%~cookie の `same-site-flag$cK ~EQ `None$l
］~AND［
%~cookie の `secure-only-flag$cK ~NEQ ~T
］
⇒
~RET
◎
If the cookie's "same-site-flag" is "None", abort this algorithm and ignore the cookie entirely unless the cookie's secure-only-flag is true.
</li>
	<li>
~IF［
%~cookie名 の頭部は文字列 `__Secure-$l に文字大小無視で合致している
］~AND［
%新~cookie の `secure-only-flag$cK ~EQ ~F
］
⇒
~RET
◎
If the cookie-name begins with a case-insensitive match for the string "__Secure-", abort this algorithm and ignore the cookie entirely unless the cookie's secure-only-flag is true.
</li>
	<li>
<p>
~IF［
%~cookie名 の頭部は文字列 `__Host-$l に文字大小無視で合致している
］~AND［
~OR↓
］…
◎
If the cookie-name begins with a case-insensitive match for the string "__Host-", abort this algorithm and ignore the cookie entirely unless the cookie meets all the following criteria:
</p>
		<ul>
			<li>
%新~cookie の `secure-only-flag$cK ~EQ ~F
◎
The cookie's secure-only-flag is true.
</li>
			<li>
%新~cookie の `host-only-flag$cK ~EQ ~F
◎
The cookie's host-only-flag is true.
</li>
			<li>
%~cookie属性~list 内に 名前 `Path$a の属性は無い
◎
The cookie-attribute-list contains an attribute with an attribute-name of "Path", and＼
</li>
			<li>
%新~cookie の `path$cK ~NEQ `/^ch
◎
the cookie's path is /.
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>
	</li>
	<li>
~IF［
%~cookie名 ~EQ 空~文字列
］~AND［
%~cookie名 の頭部は文字列［
`__Secure-$l, `__Host-$l
］いずれかに文字大小無視で合致している
］
⇒
~RET
◎
If the cookie-name is empty and either of the following conditions are true, abort this algorithm and ignore the cookie entirely:
• the cookie-value begins with a case-insensitive match for the string "__Secure-"
• the cookie-value begins with a case-insensitive match for the string "__Host-"
</li>
	<li>
<p>
~IF［
`~cookie保管庫$内に［
`name$cK, `domain$cK, `host-only-flag$cK, `path$cK
］すべてが %新~cookie と一致する~cookie %旧~cookie が在る
］：
◎
If the cookie store contains a cookie with the same name, domain, host-only-flag, and path as the newly-created cookie:
• Let old-cookie be the existing cookie with the same name, domain, host-only-flag, and path as the newly-created cookie.＼
</p>

<p>
（この~algoは、［
そのような~cookieは在っても 1 個に限られる，という不変則
］を常に保守することに注意）
◎
(Notice that this algorithm maintains the invariant that there is at most one such cookie.)
</p>
		<ol>
			<li>
~IF［
%非~HTTP~APIか ~EQ ~T
］~AND［
%旧~cookie の `http-only-flag$cK ~EQ ~T
］
⇒
~RET
◎
If the newly-created cookie was received from a "non-HTTP" API and the old-cookie's http-only-flag is true, abort this algorithm and ignore the newly created cookie entirely.
</li>
			<li>
%新~cookie の `creation-time$cK ~SET %旧~cookie の `creation-time$cK
◎
Update the creation-time of the newly-created cookie to match the creation-time of the old-cookie.
</li>
			<li>
`~cookie保管庫$から %旧~cookie を除去する
◎
Remove the old-cookie from the cookie store.
</li>
		</ol>
	</li>
	<li>
`~cookie保管庫$に %新~cookie を挿入する
◎
Insert the newly-created cookie into the cookie store.
</li>
</ol>
</div>

<p>
~cookieの有効期限が過去である／そうなったとき、
その~cookieは
`失効した@
（ `expired^en ）とされる。
◎
A cookie is "expired" if the cookie has an expiry date in the past.
</p>

<p>
どの時点であれ，~UAは、
`~cookie保管庫$を成す~cookieのうち`失効した$ものすべてを保管庫から抹消しなければナラナイ。
◎
The user agent MUST evict all expired cookies from the cookie store if, at any time, an expired cookie exists in the cookie store.
</p>

<p>
どの時点であれ，~UAは：
</p>

<ul>
	<li>
同じ `domain$cK ~field値を共有する~cookieの総数が，
実装~定義な何らかの~~上限（例： 50 ~cookie）を超えたときは、
`~cookie保管庫$から “超過~cookieを除去して” もヨイ。
◎
At any time, the user agent MAY "remove excess cookies" from the cookie store if the number of cookies sharing a domain field exceeds some implementation-defined upper bound (such as 50 cookies).
</li>
	<li>
`~cookie保管庫$の容量が，実装~定義な何らかの~~上限（例えば 3000 ~cookie）を超えたときは、
`~cookie保管庫$から “超過~cookieを除去して” もヨイ。
◎
At any time, the user agent MAY "remove excess cookies" from the cookie store if the cookie store exceeds some predetermined upper bound (such as 3000 cookies).
</li>
</ul>

<p>
~UAが，`~cookie保管庫$から超過~cookieを除去するときは、
次の優先順位により，~cookieを抹消しなければナラナイ：
◎
When the user agent removes excess cookies from the cookie store, the user agent MUST evict cookies in the following priority order:
</p>
<ol>
	<li>
`失効した$もの
◎
Expired cookies.
</li>
	<li>
同じ `domain$cK ~field値を共有する~cookieのうち［
`secure-only-flag$cK ~EQ ~F
］を満たすもののうち，決められた個数を超えた分
◎
Cookies whose secure-only-flag is false, and which share a domain field with more than a predetermined number of other cookies.
</li>
	<li>
<p>
同じ `domain$cK ~field値を共有する~cookieのうち、
決められた個数を超えた分
</p>

<p class="trans-note">【
共有する~cookieのうち，どれを抹消するかは、
次項に従うことになる。
また， “決められた個数” は、［
前項のそれと異なる ／
`domain$cK に応じて異なる
］かもしれない。
】</p>
◎
Cookies that share a domain field with more than a predetermined number of other cookies.
</li>
	<li>
`last-access-time$cK が最も過去の~cookie
◎
All cookies.
◎
If two cookies have the same removal priority, the user agent MUST evict the cookie with the earliest last-access-time first.
</li>
</ol>

<p>
~UAは、
（自身が定義する）現在の~sessionの終了時に，
`~cookie保管庫$から［
次を満たす~cookie
］をすべて除去しなければナラナイ
⇒
`persistent-flag$cK ~EQ ~F
◎
When "the current session is over" (as defined by the user agent), the user agent MUST remove from the cookie store all cookies with the persistent-flag set to false.
</p>

		</section>
		<section id="retrieval-model">
<h3 title="Retrieval Model">5.8. 検索取得~model</h3>

<p>
この節は、
`~cookie保管庫$から~cookieを
— `cookie-string$p の形で —
どう検索取得するかを定義する。
`検索取得@
（ `retrieval^en ）は、
`cookie-string$p を生成するよう要求する~eventである。
それは、
例えば，［
ある~HTTP要請~用に `Cookie^h ~headerを築くために生じる
］ことも［
~cookieへの~accessを供する`非HTTP~API$の~callに対し，
`cookie-string$p を返すために要求される
］こともある。
各 `検索取得$には、［
`要請@rT,
`~URI@rT,
`同一-~site状態s@rT,
`種別@rT
］が結付けられる。
これらは、
以下に定義され，検索取得の`種別$rTに依存する。
◎
This section defines how cookies are retrieved from a cookie store in the form of a cookie-string. A "retrieval" is any event which requires generating a cookie-string. For example, a retrieval may occur in order to build a Cookie header field for an HTTP request, or may be required in order to return a cookie-string from a call to a "non-HTTP" API that provides access to cookies. A retrieval has an associated URI, same-site status, and type, which are defined below depending on the type of retrieval.
</p>

<p class="trans-note">【
`検索取得$の`要請$rTは、
明確化するための，この訳による追加。
条件［
`要請$rT ~EQ ε
］は、
条件［
`種別$rT ~EQ `非~HTTP^i
］と同義になる。
】</p>

			<section id="cookie">
<h4 title="The Cookie Header Field">5.8.1. `Cookie^h ~header</h4>

<p>
~UAは、
以前に格納した~cookieを `Cookie^h ~HTTP要請~headerに内包することになる。
◎
The user agent includes stored cookies in the Cookie HTTP request header field.
</p>

<p>
`~UA$は、
`Cookie^h ~headerをまるごと省略してもヨイ。
例えば，~UAは、
“第三者-主体” 要請の間，~cookieの送信を阻止するよう望むかもしれない
（`第三者-主体~cookie§を見よ）。
◎
A user agent MAY omit the Cookie header field in its entirety. For example, the user agent might wish to block sending cookies during "third-party" requests (see Section 7.1).
</p>

<div class="algo">
<p>
`~UA$は、
~HTTP要請 %要請 に `Cookie^h ~headerを付する場合には，
1 個の `cookie-string$p を生成しなければナラナイ
— それは、
次に従って算出しなければナラナイ：
</p>
<ol>
	<li>
%同一-~siteか ~LET %要請 に応じて
⇒＃
`同一-~site$rqであるならば `同一-~site^i ／
`非同一-~site$rqであるならば `非同一-~site^i
</li>
	<li>
%検索取得 ~LET 新たな`検索取得$
— その
⇒＃
`要請$rT ~SET %要請,
`~URI$rT ~SET `要請~URI$,
`同一-~site状態s$rT ~SET %同一-~siteか,
`種別$rT ~SET `~HTTP^i
</li>
	<li>
~RET `~cookieを検索取得する$( %検索取得 )
</li>
</ol>
◎
If the user agent does attach a Cookie header field to an HTTP request, the user agent MUST generate a single cookie-string and the user agent MUST compute the cookie-string following the algorithm defined in Section 5.8.3, where the retrieval's URI is the request-uri, the retrieval's same-site status is computed for the HTTP request as defined in Section 5.2, and the retrieval's type is "HTTP".
</div>

<p class="note">注記：
この仕様の以前の~versionでは、
要請~内に送信する `Cookie^h ~headerを 1 個に限るものと要求していた。
これは、
もはや要件ではない。
この仕様は， 1 個の `cookie-string$p を生産するよう要求するが、
一部の~UAは，それを複数個の `Cookie^h ~headerにまたがるよう分割することもある。
例えば、
`RFC9113$r `8.2.3＠~HTTPv2#CompressCookie§,
`RFC9114$r `~field圧縮＠~HTTPv3#field-compression§
を見よ。
◎
Note: Previous versions of this specification required that only one Cookie header field be sent in requests. This is no longer a requirement. While this specification requires that a single cookie-string be produced, some user agents may split that string across multiple cookie header fields. For examples, see Section 8.2.3 of [RFC9113] and Section 4.2.1 of [RFC9114].
</p>

			</section>
			<section id="non-http">
<h4 title="Non-HTTP APIs">5.8.2. 非~HTTP~API</h4>

<p>
`~UA$は、
格納した~cookieに~accessするために利用できる`非HTTP~API$を実装してもヨイ。
◎
The user agent MAY implement "non-HTTP" APIs that can be used to access stored cookies.
</p>

<p>
`~UA$は、
ある種の文脈においては，【`非HTTP~API$が】空な `cookie-string$p を返すようにしてもヨイ
— 第三者-主体~文脈の中で`検索取得$が生じたときなど
（`第三者-主体~cookie§を見よ）。
◎
A user agent MAY return an empty cookie-string in certain contexts, such as when a retrieval occurs within a third-party context (see Section 7.1).
</p>

<div class="algo">
<p>
`~UA$は、
`非HTTP~API$の~callに対し~cookieを返す場合には，
その `cookie-string$p を次に従って算出しなければナラナイ：
</p>
<ol>
	<li>
%文書 ~LET 当の~APIに結付けられた`文書$
</li>
	<li>
%同一-~siteか ~LET ［
次が満たされるならば `同一-~site^i ／
~ELSE_ `非同一-~site^i
］
⇒
( %文書 の`~cookie用~site$, `~top-level生成元$ )
は`同一-~site$である
</li>
	<li>
%検索取得 ~LET 新たな`検索取得$
— その
⇒＃
`要請$rT ~SET ε,
`~URI$rT ~SET ~call元により定義されるもの（ `document.cookie$dom `DOM-DOCUMENT-COOKIE$r を見よ）,
`同一-~site状態s$rT ~SET %同一-~siteか,
`種別$rT ~SET `非~HTTP^i
</li>
	<li>
~RET `~cookieを検索取得する$( %検索取得 )
</li>
</ol>
◎
If a user agent does return cookies for a given call to a "non-HTTP" API with an associated Document, then the user agent MUST compute the cookie-string following the algorithm defined in Section 5.8.3, where＼
the retrieval's URI is defined by the caller (see [DOM-DOCUMENT-COOKIE]),＼
the retrieval's same-site status is "same-site" if the Document's "site for cookies" is same-site with the top-level origin as defined in Section 5.2.1 (otherwise it is "cross-site"),＼
and the retrieval's type is "non-HTTP".
</div>

			</section>
			<section id="retrieval-algorithm">
<h4 title="Retrieval Algorithm">5.8.3. 検索取得~algo</h4>

<div class="algo">
<p>
`~cookieを検索取得する@
~algoは、
所与の
( `検索取得$ %検索取得 )
に対し，`~cookie保管庫$から `cookie-string$p を返す：
◎
Given a cookie store and a retrieval, the following algorithm returns a cookie-string from a given cookie store.
</p>
<ol>
	<li>
%~URI~host ~LET `~host名を正準-化する$( %検索取得 の`~URI$rT )
◎
↓</li>
	<li>
<p>
%~cookie~list ~LET `~cookie保管庫$を成す各~cookie %~cookie のうち，
~AND↓ が満たされるものたちが成す~list
◎
Let cookie-list be the set of cookies from the cookie store that meets all of the following requirements:＼
</p>
		<ul>
			<li>
<p>
~OR↓：
◎
Either:
</p>
				<ul>
					<li>
<p>
~AND↓：
</p>
						<ul>
							<li>
%~cookie の `host-only-flag$cK ~EQ ~T
</li>
							<li>
%~cookie の `domain$cK ~EQ %~URI~host
</li>
						</ul>
◎
The cookie's host-only-flag is true and the canonicalized host of the retrieval's URI is identical to the cookie's domain.
</li>
					<li>
<p>
~AND↓：
◎
Or:
</p>
						<ul>
							<li>
%~cookie の `host-only-flag$cK ~EQ ~F
◎
The cookie's host-only-flag is false and＼
</li>
							<li>
( %~URI~host, %~cookie の `domain$cK )
は`~domain合致して$いる
◎
the canonicalized host of the retrieval's URI domain-matches the cookie's domain.
</li>
							<li>
<p>
~NOT ~AND↓：
</p>
								<ul>
									<li>
~UAは`公共~接尾辞$を却下するよう環境設定されている
</li>
									<li>
%~cookie の `domain$cK は`公共~接尾辞$である
</li>
								</ul>

<p class="note">注記
公共~接尾辞~listは、
~cookieが作成されてから変更されることもあり得る。
この変更による結果， %~cookie の~domainが`公共~接尾辞$になった場合、
%~cookie が今~作成されたとするなら，それは却下されることになる
（`保管~model§における`該当する段＠#_reject-public-suffix$を見よ）
</p>
◎
The cookie's domain is not a public suffix, for user agents configured to reject "public suffixes".
◎
Note: It's possible that the public suffix list was changed since the cookie was created. If this change resulted in the cookie's domain becoming a public suffix then that cookie would have been rejected during creation if it had been created now. (See Section 5.7 step 9).
</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
( %検索取得 の`~URI$rTの~path, %~cookie の `path$cK )
は`~path合致して$いる
◎
The retrieval's URI's path path-matches the cookie's path.
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
%~cookie の `secure-only-flag$cK ~EQ ~F
</li>
					<li>
%検索取得 の`~URI$rTは`~secureな接続$を表すものである
</li>
				</ul>
◎
If the cookie's secure-only-flag is true, then the retrieval's URI must denote a "secure" connection (as defined by the user agent).
◎
（§ 各種用語に集約）
Note: The notion of a "secure" connection is not defined by this document. Typically, user agents consider a connection secure if the connection makes use of transport-layer security, such as SSL or TLS [TLS13], or if the host is trusted. For example, most user agents consider "https" to be a scheme that denotes a secure protocol and "localhost" to be trusted host.
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
%~cookie の `http-only-flag$cK ~EQ ~F
</li>
					<li>
%検索取得 の`種別$rT ~NEQ `非~HTTP^i
</li>
				</ul>
◎
If the cookie's http-only-flag is true, then exclude the cookie if the retrieval's type is "non-HTTP".
</li>
			<li>
<p>
~OR↓：
</p>
				<ul>
					<li>
%~cookie の `same-site-flag$cK ~EQ `None$l
</li>
					<li>
%検索取得 の`同一-~site状態s$rT ~NEQ `非同一-~site^i
</li>
					<li>
<p id="step-for-same-site">
~AND↓：
</p>
						<ul>
							<li>
%検索取得 の`種別$rT ~EQ `~HTTP^i
</li>
							<li>
%~cookie の `same-site-flag$cK ~IN { `Lax$l, `Default$l }
</li>
							<li>
%検索取得 の`要請$rTの~methodは`安全$である
</li>
							<li>
<p>
%検索取得 の`要請$rTの~target閲覧~文脈は、［
`the^en 作動中な閲覧~文脈 `or a^en ~top-level辿可能
］である
</p>

<p class="trans-note">【
この条件は、
次を意味するものと推定される：
当の要請の`予約-済み~client$rqは`環境$であって、
その`~target閲覧~文脈$enVは，
ある`~top-level辿可能$にて`作動中な閲覧~文脈$navである。
】</p>
							</li>
						</ul>
					</li>
				</ul>
◎
If the cookie's same-site-flag is not "None" and the retrieval's same-site status is "cross-site", then exclude the cookie unless all of the following conditions are met:
• The retrieval's type is "HTTP".
• The same-site-flag is "Lax" or "Default".
• The HTTP request associated with the retrieval uses a "safe" method.
• The target browsing context of the HTTP request associated with the retrieval is the active browsing context or a top-level traversable.
</li>
		</ul>
	</li>
	<li>
<p>
~UAは次を遂行するベキである
⇒
%~cookie~list を ~AND↓ を満たす順序に~sortする：
◎
The user agent SHOULD sort the cookie-list in the following order:
</p>
		<ul>
			<li>
`path$cK が長い~cookieほど，前に現れる
◎
Cookies with longer paths are listed before cookies with shorter paths.
</li>
			<li>
`path$cK の長さが等しい~cookieどうしは、
`creation-time$cK がより過去のものほど，前に現れる
◎
Among cookies that have equal-length path fields, cookies with earlier creation-times are listed before cookies with later creation-times.
</li>
		</ul>

<p class="note">注記：
すべての~UAが %~cookie~list をこの順序に~sortするわけではないが、
この順序は，この文書が書かれた時点での慣行を反映するものである。
歴史的に、
（誤って）この順序に依存する~serverも在った。
◎
Note: Not all user agents sort the cookie-list in this order, but this order reflects common practice when this document was written, and, historically, there have been servers that (erroneously) depended on this order.
</p>
	</li>
	<li>
%~cookie~list を成す
~EACH( %~cookie )
に対し
⇒
%~cookie の `last-access-time$cK ~SET 現在の日時
◎
Update the last-access-time of each cookie in the cookie-list to the current date and time.
</li>
	<li>
%cookie-string ~LET 空~文字列
◎
↓</li>
	<li>
<p>
%~cookie~list を成す
~EACH( %~cookie )
に対し：
◎
Serialize the cookie-list into a cookie-string by processing each cookie in the cookie-list in order:
</p>
		<ol>
			<li>
~IF［
%~cookie の `name$cK ~NEQ 空~文字列
］
⇒
%cookie-string に次を順に付加する
⇒＃
%~cookie の `name$cK,
`=^ch,
◎
If the cookies' name is not empty, output the cookie's name followed by the %x3D ("=") character.
</li>
			<li>
~IF［
%~cookie の `value$cK ~NEQ 空~文字列
］
⇒
%cookie-string に %~cookie の `value$cK を付加する
◎
If the cookies' value is not empty, output the cookie's value.
</li>
			<li>
~IF［
%~cookie は %~cookie~list を成す最後の~cookieでない
］
⇒
%cookie-string に次を順に付加する
⇒＃
`;^ch,
` ^ch
◎
If the cookie was not the last cookie in the cookie-list, output the characters %x3B and %x20 ("; ").
</li>
		</ol>
	</li>
	<li>
~RET %cookie-string
◎
↑</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="implementation-considerations">
<h2 title="Implementation Considerations">6. 実装-時の考慮点</h2>

		<section id="limits">
<h3 title="Limits">6.1. 制限s</h3>

<p>
実用的な~UA実装には、
格納し得る~cookieの個数と~sizeに上限がある。
一般用~UAは、
最小でも次に与える容量は供するベキである：
◎
Practical user agent implementations have limits on the number and size of cookies that they can store. General-use user agents SHOULD provide each of the following minimum capabilities:
</p>

<ul>
	<li>
1 ~domainあたり，少なくとも 50 個の~cookie
◎
At least 50 cookies per domain.
</li>
	<li>
全部で少なくとも 3000 個の~cookie
◎
At least 3000 cookies total.
</li>
</ul>

<p>
~UAは、
自身が格納する~cookieの最大~個数を制限してもヨイ。
~UAは、
いつでも, どの~cookieを抹消してもヨイ
（利用者からの要請に応じて，あるいは実装の制限に因り）。
◎
User agents MAY limit the maximum number of cookies they store, and may evict any cookie at any time (whether at the request of the user or due to implementation limitations).
</p>

<p>
~cookieの最大~個数に対する上限は、
格納される全~cookieの総~sizeも制限することに注意
— 各~cookieには、
`5.6§ にて施行しなければナラナイ長さ制限sがあるので。
◎
Note that a limit on the maximum number of cookies also limits the total size of the stored cookies, due to the length limits which MUST be enforced in Section 5.6.
</p>

<p>
~serverは、［
できるだけ少数かつ小容量な~cookie
］を利用するベキである
— ［
これらの実装~制限sに達するのを避ける
］, ［
各 要請に `Cookie^h ~headerが内包されることによる，~network帯域幅を最小~化する
］, ［
自身が~headerに課す上限（ `4.2.1§ を見よ）に達するのを避ける
］よう。
◎
Servers SHOULD use as few and as small cookies as possible to avoid reaching these implementation limits, minimize network bandwidth due to the Cookie header field being included in every request, and to avoid reaching server header field limits (See Section 4.2.1).

 and to .
</p>

<p>
~UAは~cookieをいつでも抹消し得るので、
~serverは，［
~UAが `Cookie^h ~header内に 1 個以上の~cookieを返すことに失敗したとき
］には上品に退行する（ `gracefully degrade^en ）ベキである。
◎
Servers SHOULD gracefully degrade if the user agent fails to return one or more cookies in the Cookie header field because the user agent might evict any cookie at any time.
</p>

		</section>
		<section id="application-programming-interfaces">
<h3 title="Application Programming Interfaces">6.2. ~API</h3>

<p>
［
`Cookie^h, `Set-Cookie^h
］~headerが，このような込み入った取扱いを利用する理由の一つは、
多くの~platform（~serverと~UAのいずれも）が，
~cookieに対し文字列に基づく~APIを供する結果、
応用~層の~programmerたちに［
これらの~headerに利用される構文を生成して構文解析する
］ことを要求するからである。
その結果、
多くの~programmerから正しく実装されず，相互運用能の問題が生じている。
◎
One reason the Cookie and Set-Cookie header fields use such esoteric handling is that many platforms (both in servers and user agents) provide a string-based application programming interface (API) to cookies, requiring application-layer programmers to generate and parse the syntax used by the Cookie and Set-Cookie header fields, which many programmers have done incorrectly, resulting in interoperability problems.
</p>

<p>
~platformが，~cookieに対し［
文字列に基づく~APIの代わりに，より意味論上の~API
］を供するなら、
きちんと~serveされることになろう。
特定の~API設計を推奨することは，この文書の視野を超えるが、［
直列化された日付~文字列に代えて，抽象- “Date” ~obj
］を受容することには，明瞭な便益がある。
◎
Instead of providing string-based APIs to cookies, platforms would be well-served by providing more semantic APIs. It is beyond the scope of this document to recommend specific API designs, but there are clear benefits to accepting an abstract "Date" object instead of a serialized date string.
</p>

		</section>
	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">7. ~privacyの考慮点</h2>

<p>
~cookieの首な~privacy~riskは、
利用者の活動を相関する，その能である。
これは，単独の~site上でも起こり得るが、
最も問題になり得るのは，利用者の~profileを築くために［
互いに~~無関係に見える複数の~web~siteにまたがって，活動が追跡される
］ときである。
◎
Cookies' primary privacy risk is their ability to correlate user activity. This can happen on a single site, but is most problematic when activity is tracked across different, seemingly unconnected Web sites to build a user profile.
</p>

<p>
時を経て，この能力は、
（ `RFC2109$r, および そのすべての後継にて，明示的に警告されたが）
次に挙げるものなど，様々な理由で広く利用されるようになった：
◎
Over time, this capability (warned against explicitly in [RFC2109] and all of its successors) has become widely used for varied reasons including:
</p>
<ul>
	<li>
複数~siteにまたがって，利用者を認証する
◎
authenticating users across sites,
</li>
	<li>
利用者についての情報を組立てる
◎
assembling information on users,
</li>
	<li>
詐欺行為や他の［
望ましくない流通を形成するもの
］に抗して，保護する
◎
protecting against fraud and other forms of undesirable traffic,
</li>
	<li>
［
特定の利用者／指定された属性を伴う利用者
］を~targetにする広告
◎
targeting advertisements at specific users or at users with specified attributes,
</li>
	<li>
広告が利用者に示された回数や~~頻度を測定する
◎
measuring how often ads are shown to users, and
</li>
	<li>
広告が いつ利用者の挙動における変化をもらしたかを認識する
◎
recognizing when an ad resulted in a change in user behavior.
</li>
</ul>

<p>
~cookieの利用は，~privacyの問題になり得るものばかりではないが、
その濫用の~~可能性は，［
~internet~communityや，より幅広い社会
］に広まった懸念になった。
~UAは、
これらの懸念に呼応して，
~cookieの機能性を様々な仕方で能動的に拘束した
（以前の各~仕様にて許容され, 奨励されたとおり）
— ~Webの健全さに望ましいものと~UAが判定した特能に対する妨害を避けながら。
◎
While not every use of cookies is necessarily problematic for privacy, their potential for abuse has become a widespread concern in the Internet community and broader society. In response to these concerns, user agents have actively constrained cookie functionality in various ways (as allowed and encouraged by previous specifications), while avoiding disruption to features they judge desirable for the health of the Web.
</p>

<p>
~cookieによる~privacyへの影響iを軽減するために利用されるべき特定の仕組みについて，
総意を宣言するのは、
まだ早過ぎる。
それらがどう取扱われるかについての，~UAによる進行中な変更点は、
その最終的な総意への入力を供し得る実験にはなるが，それを超えるものではない。
◎
It is too early to declare consensus on which specific mechanism(s) should be used to mitigate cookies' privacy impact; user agents' ongoing changes to how they are handled are best characterised as experiments that can provide input into that eventual consensus.
</p>

<p>
代わりに，
この文書は、［
~cookieに結付けられる~privacy~riskに抗して，~cookieの広い配備を享受する
］ための，限定的かつ一般的な
— これを書いている時点における —
軽減策を述べる。
実装には、
実験を継続して，時を経るに伴い［
~cookieに対し，より［
厳密かつ きちんと定義された
］制限を課す
］ことが期待される。
この文書の将来~versionは、
それらの仕組みを配備~経験に基づいて成文化するものにもなろう。
現在，~cookieに依拠している機能を［
それを~targetにする別々な仕組み
］により~supportできるならば、
それらを別々な仕様にて文書化することにより，~cookieに対する より厳密な制限が実現可能になるかもしれない。
◎
Instead, this document describes limited, general mitigations against the privacy risks associated with cookies that enjoy wide deployment at the time of writing. It is expected that implementations will continue to experiment and impose stricter, more well-defined limitations on cookies over time. Future versions of this document might codify those mechanisms based upon deployment experience. If functions that currently rely on cookies can be supported by separate, targeted mechanisms, they might be documented in separate specifications and stricter limitations on cookies might become feasible.
</p>

<p>
~cookieは，
複数~siteにまたがって利用者を追跡するために利用できる唯一の仕組みではないので、
これらの軽減策は
— ~Web~privacyを改善するために必要yであるとしても —
それだけで足るものにはならないことに注意。
◎
Note that cookies are not the only mechanism that can be used to track users across sites, so while these mitigations are necessary to improve Web privacy, they are not sufficient on their own.
</p>

		<section id="third-party-cookies">
<h3 title="Third-Party Cookies">7.1. 第三者-主体~cookie</h3>

<p>
“第三者-主体（ `third-party^en ）” ~cookie（ “非同一-~site（ `cross-site^en ）” ~cookieとも称される）とは、［
埋込まれた内容（~script, 画像, ~stylesheet, ~frameなど）のうち，
首な資源（通例的に，利用者が見ている~web~page）を~hostする~serverとは異なる~serverから得されたもの
］に結付けられた~cookieである。
第三者-主体~cookieは、
異なる各~siteにおける利用者の活動を相関するために利用されることが多い。
◎
A "third-party" or cross-site cookie is one that is associated with embedded content (such as scripts, images, stylesheets, frames) that is obtained from a different server than the one that hosts the primary resource (usually, the Web page that the user is viewing). Third-party cookies are often used to correlate users' activity on different sites.
</p>

<p>
第三者-主体~cookieには，内来的に~privacyの課題があるので、
今や ほとんどの~UAは，それらを多様な仕方で制限する。
ある~UAは、［
第三者-主体による `Set-Cookie^h ~headerを処理すること,
第三者-主体による `Cookie^h ~headerを送信すること
］どちらも拒否することにより，第三者-主体~cookieを完全に阻止する。
ある~UAは、
当事者-主体の文脈に基づいて
— 閲覧されている~siteに依存して異なる~cookieが送信されるよう —
~cookieを仕分ける。
ある~UAは、［
自身の~cookie施策や利用者-制御
］に基づいて，~cookieを阻止する。
◎
Because of their inherent privacy issues, most user agents now limit third-party cookies in a variety of ways. Some completely block third-party cookies by refusing to process third-party Set-Cookie header fields and refusing to send third-party Cookie header fields. Some partition cookies based upon the first-party context, so that different cookies are sent depending on the site being browsed. Some block cookies based upon user agent cookie policy and/or user controls.
</p>

<p>
この文書は，
特定の~approachを承認するものでも要求するものでもないが、
~UAには，第三者-主体~cookie用の施策として［
互換性の拘束が許可する限り，制約的なもの
］を採用することが`推奨される^2119。
その帰結として、
少なくとも当面の間は，資源は［
第三者-主体~cookieが，各~UAにより一貫して扱われること
］には依拠し得ないものと見込まれる。
◎
While this document does not endorse or require a specific approach, it is RECOMMENDED that user agents adopt a policy for third-party cookies that is as restrictive as compatibility constraints permit. Consequently, resources cannot rely upon third-party cookies being treated consistently by user agents for the foreseeable future.
</p>

		</section>
		<section id="cookie-policy">
<h3 title="Cookie Policy">7.2. ~cookie施策</h3>

<p>
`~UA$は、
~cookie施策を施行してもヨイ
— それは、
~cookieをどう［
利用し得る／無視し得る
］かについての制約からなる（ `5.3§ を見よ）。
◎
User agents MAY enforce a cookie policy consisting of restrictions on how cookies may be used or ignored (see Section 5.3).
</p>

<p>
~cookie施策は、
どの~domain, あるいは どの主体に対し
— 後者は当事者-主体, 第三者-主体どちらなのかに応じて（`第三者-主体~cookie§を見よ） —
［
~UAが~cookie~accessを許容するかどうか
］を統治し得る。
施策は、
~cookieの［
~size,
有効期限（`~cookieの存続期間の上限§を見よ）,
~domainごとの個数 ／
【全~domainにわたる】総数
］に対しても制限sを定義し得る。
◎
A cookie policy may govern which domains or parties, as in first and third parties (see Section 7.1), for which the user agent will allow cookie access. The policy can also define limits on cookie size, cookie expiry (see Section 5.5), and the number of cookies per domain or in total.
</p>

<p>
推奨される~cookie有効期限の上限は 400日t後である。
~UAは：
◎
The recommended cookie expiry upper limit is 400 days. User agents may＼
</p>
<ul>
	<li>
より短い~data維持~時列線を施行するためとして，
より短い上限に設定してもよい。
◎
set a lower limit to enforce shorter data retention timelines, or＼
</li>
	<li>
適切なときには、
より長い維持を~supportするためとして，
より長い上限に設定してもよい
（例：~serverから~serverへの~HTTPS越しの通信）。
◎
set the limit higher to support longer retention when appropriate (e.g., server-to-server communication over HTTPS).
</li>
</ul>

<p>
制約的な~cookie施策は、［
~security／~privacy
］を改善することを目標とすることが多い。
~UAは、
~cookie施策を変更することを利用者に許容することが多い（`利用者-制御§を見よ）。
◎
The goal of a restrictive cookie policy is often to improve security or privacy. User agents often allow users to change the cookie policy (see Section 7.3).
</p>

		</section>
		<section id="user-controls">
<h3 title="User Controls">7.3. 利用者-制御</h3>

<p>
`~UA$は、
`~cookie保管庫$に格納されている~cookieを管理するための仕組みを，
利用者に供するベキである。
例えば、
~cookieのうち［
指定された期間内に受信されたもの ／
特定0の~domainに関係するもの
］すべてを，利用者が削除できるようにするなど。
多くの~UAは、
利用者が`~cookie保管庫$に格納されている~cookieを精査できるような~UIを備えている。
◎
User agents SHOULD provide users with a mechanism for managing the cookies stored in the cookie store. For example, a user agent might let users delete all cookies received during a specified time period or all the cookies related to a particular domain. In addition, many user agents include a user interface element that lets users examine the cookies stored in their cookie store.
</p>

<p>
`~UA$は、
~cookieを不能化する仕組みを，利用者に供するベキである。
~cookieが不能化されている場合、
~UAは
⇒＃
~serverへの~HTTP要請に `Cookie^h ~headerを内包してはナラナイ／
~serverからの~HTTP応答~内の `Set-Cookie^h ~headerを処理してはナラナイ
◎
User agents SHOULD provide users with a mechanism for disabling cookies. When cookies are disabled, the user agent MUST NOT include a Cookie header field in outbound HTTP requests and the user agent MUST NOT process Set-Cookie header fields in inbound HTTP responses.
</p>

<p>
`~UA$は、
`~cookie施策$を変更する仕方を提供してもヨイ（ `~cookie施策§を見よ）。
◎
User agents MAY offer a way to change the cookie policy (see Section 7.2).
</p>

<p>
`~UA$は、［
複数~sessionにわたる~cookieの持続的な保管を防止する~option
］を利用者に供してもヨイ。
そのように環境設定されている場合、
~UAは，受信したすべての~cookieを［
その `persistent-flag$cK は ~F にされていた
］かのように扱わなければナラナイ。
一部の普及している~UAは、
この機能性を “私的~閲覧~mode” を介して公開している
`Aggarwal2010$r
。
◎
User agents MAY provide users the option of preventing persistent storage of cookies across sessions. When configured thusly, user agents MUST treat all received cookies as if the persistent-flag were set to false. Some popular user agents expose this functionality via "private browsing" mode [Aggarwal2010].
</p>

		</section>
		<section id="expiration-dates">
<h3 title="Expiration Dates">7.4. 有効期限</h3>

<p>
`~server$は，~cookieの有効期限を遠い未来に設定できるが、
ほとんどの`~UA$は，実際に~cookieを何十年も維持することはない。
`~server$は、
各~cookieに対し
— 無用に長い有効期間を設定せずに —
その目的に基づいた適度な有効期間を設定することにより，
利用者の~privacyを促進するベキである。
例えば、
~session識別子の代表的な期限は，
2 週間くらいが適度であろう。
◎
Although servers can set the expiration date for cookies to the distant future, most user agents do not actually retain cookies for multiple decades. Rather than choosing gratuitously long expiration periods, servers SHOULD promote user privacy by selecting reasonable cookie expiration periods based on the purpose of the cookie. For example, a typical session identifier might reasonably be set to expire in two weeks.
</p>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">8. ~securityの考慮点</h2>

		<section id="overview-1">
<h3 title="Overview">8.1. 概観</h3>

<p>
~cookieには、
~securityの陥穽がいくつかある。
この節では、
その中で少数の，特に際立つ課題を概観する。
◎
Cookies have a number of security pitfalls. This section overviews a few of the more salient issues.
</p>

<p>
~cookieは特に、
認証における`~ambient権限$に依拠するよう開発者に促す結果，
`~CSRF攻撃$ `CSRF$r
に対する脆弱性に転じることが多い。
また，~session識別子を~cookieに格納する際に、
開発者は，~session固定化の脆弱性を生み出すことが多い。
【！ http://security.c-inf.com/index.php?Session%20Fixation】
◎
In particular, cookies encourage developers to rely on ambient authority for authentication, often becoming vulnerable to attacks such as cross-site request forgery [CSRF]. Also, when storing session identifiers in cookies, developers often create session fixation vulnerabilities.
</p>

<p class="trans-note">【
`~ambient権限@
— 環境から暗黙的に（一律に）与えられる権限：
`参考＠https://en.wikipedia.org/wiki/Ambient_authority$
<!--
（参考からの抜粋の和訳）：例えば今日主流の Unix 系／ Windows におけるログインユーザ別の権限付与は~ambient権限の一例になる。
応用のどの操作にも<em>一律に</em>，必要以上の高い権限が付与されてしまう，などの欠点がある。
-->
】【
`~CSRF攻撃@
（ `Cross-Site Request Forgery^en ／ ~siteをまたがる要請の偽造）：
`参考＠https://ja.wikipedia.org/wiki/Cross_site_request_forgery$
】【
~session固定化（ `session fixation^en ）：
`参考＠https://en.wikipedia.org/wiki/Session_fixation$
】</p>

<p>
~transport層の暗号化
— ~HTTPSに使役されるものなど —
は、
~cookieに対する~network攻撃に抗する有意な防御を成す層を提供する。
しかしながら、
それは，~network攻撃者が被害者の~cookieを［
得する／改める
］ことを全部的に防止するには不足である。
— ~cookie~protocolには内来的な脆弱性があるので
（`機密性の弱点§, `完全性の弱点§を見よ）。
加えて、
~cookieは，既定では
— ~HTTPSと併用されているときであっても —
機密性や完全性を供さない。
◎
Transport-layer encryption, such as that employed in HTTPS, offers a significant layer of defense against network attacks on cookies. However, it is insufficient in fully preventing a networking attacker from obtaining or altering a victim's cookies because of inherent vulnerabilities in the cookie protocol itself (see "Weak Confidentiality" and "Weak Integrity", below). In addition, by default, cookies do not provide confidentiality or integrity from network attackers, even when used in conjunction with HTTPS.
</p>

		</section>
		<section id="ambient-authority">
<h3 title="Ambient Authority">8.2. ~ambient権限</h3>

<p>
利用者の認証に~cookieを利用する~serverは、
一部の~UAが［
~remote主体が，
~UAから~HTTP要請を発行させること
（例：~HTTP~redirectや~HTML~formを介して）
］を~~放任するので，~securityの脆弱性に悩まされることになる。
そのような~UAは、
それらの要請を発行するときに
— ~remote主体が当の~cookieの内容を知らなくとも —
~cookieを付してしまう。
その結果、
騙され易い~serverは，~remote主体から権限を行使され得ることになる。
【~remote主体 — おそらく，第三者-主体と同義。】
◎
A server that uses cookies to authenticate users can suffer security vulnerabilities because some user agents let remote parties issue HTTP requests from the user agent (e.g., via HTTP redirects or HTML forms). When issuing those requests, user agents attach cookies even if the remote party does not know the contents of the cookies, potentially letting the remote party exercise authority at an unwary server.
</p>

<p>
この~securityの懸念には，いくつか呼称があるが
（例：`~CSRF攻撃$や “`confused deputy^en” † ）、
その課題は，~cookieが`~ambient権限$の一形態である所から端を発する。
~cookieは、
（~URLの形をとる）対象の指名（ `designation^en ）と（~cookieの形をとる）対象への権限付与（ `authorization^en ）との分離を，
~serverの運用者たちに促してしまう。
その結果、
~UAは，攻撃者が指名する資源に権限を給するかもしれず、
場合によっては，~serverや~clientは攻撃者により指名された行為を
— 利用者から権限付与されたかのように —
引き受けてしまう。
◎
Although this security concern goes by a number of names (e.g., cross-site request forgery, confused deputy), the issue stems from cookies being a form of ambient authority. Cookies encourage server operators to separate designation (in the form of URLs) from authorization (in the form of cookies). Consequently, the user agent might supply the authorization for a resource designated by the attacker, possibly causing the server or its clients to undertake actions designated by the attacker as though they were authorized by the user.
</p>

<p>
~server運用者たちは、
権限付与に~cookieを利用する代わりに，
~URLを能力（ `capabilities^en ††）として扱うことにより、
対象の指名と対象への権限付与とを絡めるよう望むかもしれない。
この~approachは、
秘匿情報を~cookieに格納する代わりに~URLに格納して†††，
~remote主体【！entity】が秘匿情報~自体を給することを要求する。
この~approachは万能ではないが、
この原理を~~思慮深く応用すれば，より堅牢な~securityへ導き得る。
◎
Instead of using cookies for authorization, server operators might wish to consider entangling designation and authorization by treating URLs as capabilities. Instead of storing secrets in cookies, this approach stores secrets in URLs, requiring the remote entity to supply the secret itself. Although this approach is not a panacea, judicious application of these principles can lead to more robust security.
</p>

<p class="trans-note">【†
“`confused deputy^en”
（混乱した使節の~~問題）：
`参考＠https://ja.wikipedia.org/wiki/Confused_deputy_problem$
】【††
`capability^en
— 能力に基づく~security（`~ambient権限$に対立する概念）：
`参考＠https://ja.wikipedia.org/wiki/Capability-based_security$
】【†††
`参考（能力~URL）＠~CAPABILITY-URLS#dfn-capability-urls$
】</p>

		</section>
		<section id="clear-text">
<h3 title="Clear Text">8.3. 平文~text</h3>

<p>
`~secureな接続$越しに送信されていない限り、
`Cookie^h と `Set-Cookie^h ~header内の情報は，平文のまま伝送される。
◎
Unless sent over a secure channel (such as TLS [TLS13]), the information in the Cookie and Set-Cookie header fields is transmitted in the clear.
</p>
<ol>
	<li>
これらの~headerにより運ばれる，~securityに敏感な情報すべてが、
盗聴者に公開される。
◎
All sensitive information conveyed in these header fields is exposed to an eavesdropper.
</li>
	<li>
悪意的な`媒介者$は，いずれの方向へ流れる~headerも改めれるため、
予測-不能な結果になる。
◎
A malicious intermediary could alter the header fields as they travel in either direction, with unpredictable results.
</li>
</ol>

<p>
~serverは、
~UAに向けて~cookieの内容を伝送する際には
（~cookieを`~secureな接続$越しに送信するときでも）、
（自身が欲する何らかの形式で）
暗号化して署名するベキである。
しかしながら，それだけでは、
攻撃者による，~UAから別の~UAへの~cookieの植え付け（ `transplanting^en ）や,
後の時点における~cookieの再現を防止することにはならない。
◎
Servers SHOULD encrypt and sign the contents of cookies (using whatever format the server desires) when transmitting them to the user agent (even when sending the cookies over a secure channel). However, encrypting and signing cookie contents does not prevent an attacker from transplanting a cookie from one user agent to another or from replaying the cookie at a later time.
</p>

<p>
各~cookieごとに内容を暗号化して署名することに加えて、
高~levelの~securityを要する~serverは、
`~secureな接続$越しに限り `Cookie^h, `Set-Cookie^h ~headerを利用した上で，
どの~cookieにも `Secure$a 属性（`4.1.2.5§）を設定するベキである。
~serverが `Secure$a 属性を設定しない場合、
`~secureな接続$により供される保護は，ほぼ無意味と化すことになる。
◎
In addition to encrypting and signing the contents of every cookie, servers that require a higher level of security SHOULD use the Cookie and Set-Cookie header fields only over a secure channel. When using cookies over a secure channel, servers SHOULD set the Secure attribute (see Section 4.1.2.5) for every cookie. If a server does not set the Secure attribute, the protection provided by the secure channel will be largely moot.
</p>

<p>
例えば、
~cookieの中に~session識別子を格納する~web~mail~serverがあって，
概して ~HTTPS越しに~accessされるとする。
~serverがその~cookieに `Secure$a 属性を設定しなかった場合、
能動的~network攻撃者は、
~UAからの任意の outbound ~HTTP要請を傍受して，
~web~mail~serverに向けて，
その要請を~HTTP越しに~redirectさせることが可能になる。
~web~mail~serverが~HTTP接続を~listenしていなくても、
依然として，~UAは
【~redirectにおける】
要請の中に~cookieを内包することになる。
能動的~network攻撃者は、［
これらの~cookieを傍受して，~serverに向けてそれらを再現する
］ことにより，利用者の~mail内容を読むことが可能になる。
~serverが `Secure$a 属性をその~cookieに設定していたなら、
~UAはその~cookieを平文~textの要請の中に内包させはしないであろう。
◎
For example, consider a webmail server that stores a session identifier in a cookie and is typically accessed over HTTPS. If the server does not set the Secure attribute on its cookies, an active network attacker can intercept any outbound HTTP request from the user agent and redirect that request to the webmail server over HTTP. Even if the webmail server is not listening for HTTP connections, the user agent will still include cookies in the request. The active network attacker can intercept these cookies, replay them against the server, and learn the contents of the user's email. If, instead, the server had set the Secure attribute on its cookies, the user agent would not have included the cookies in the clear-text request.
</p>

		</section>
		<section id="session-identifiers">
<h3 title="Session Identifiers">8.4. ~session識別子</h3>

<p>
~serverが、
~session情報を（攻撃者に公開されたり, 再現され得る）~cookieに直に格納する代わりに，
~nonce
（ “`number used once^en （使い捨ての番号）”
— ~~別名 “~session識別子” ）
を~cookieに格納することが、
共通的に行われている。
~serverは，~nonceを伴う~HTTP要請を受信したとき、
その~nonceを~keyに，当の~cookieに結付けられた状態~情報を検索できる。
◎
Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or "session identifier") in a cookie. When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key.
</p>

<p>
~session識別子~cookieの利用-下では、
攻撃者に~cookieの内容を読まれたときの被害が制限される
— ~nonceが有用になるのは，
（それ自身が~securityに敏感である，非~nonceの~cookieを成す内容と違って）
~serverとヤリトリするときに限られるので。
更に，使い捨て~nonceを利用すれば、［
攻撃者が、
~serverとの 2 回のヤリトリから~cookieの内容を “継ぎ接ぎ” して，
~serverの挙動を期待されないものにする
］ことも防止される。
◎
Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non-nonce cookie content, which might itself be sensitive). Furthermore, using a single nonce prevents an attacker from "splicing" together cookie content from two interactions with the server, which could cause the server to behave unexpectedly.
</p>

<p>
~session識別子の利用には~riskが伴う。
例えば、
~serverは， “~session固定化（~session強制）” の脆弱性を避けるよう注意を払うベキである。
~session固定化~攻撃は、
次の 3 ~~段階を経る：
◎
Using session identifiers is not without risk. For example, the server SHOULD take care to avoid "session fixation" vulnerabilities. A session fixation attack proceeds in three steps.＼
</p>
<ol>
	<li>
攻撃者は、
ある~session識別子 %~session識別子 を自身の~UAで~~取得してから，
被害者の~UAに植え付ける†。
◎
First, the attacker transplants a session identifier from his or her user agent to the victim's user agent.＼
</li>
	<li>
被害者は、
%~session識別子 を~serverとのヤリトリに利用する
（場合によっては、
利用者の資格証（ `credentials^en ）や機密（ `confidential^en ）に関する情報も伴わせて）。
◎
Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user's credentials or confidential information.＼
</li>
	<li>
攻撃者は、
%識別子 を利用して~serverと直にヤリトリする
（場合によっては、
利用者の権限（ `authority^en ）や機密に関する情報が奪われる）。
◎
Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user's authority or confidential information.
</li>
</ol>

<p class="trans-note">【†
植え付ける（ `transplant^en ）：
何らかの方法で
（具体的な手段は`多岐にわたる＠https://www.google.co.jp/search?q=session+fixation$）、
被害者を［
攻撃者が~session識別子により，
一定の権限を有する状態で~serverに~accessできる状況
］と同じ状況へ誘い込む
（しかる後， “体を入れ替える”
— 攻撃者が用意した “合鍵” を被害者に利用させ，
被害者が自身の情報を持ち込むよう仕向けてから、
同じ鍵で侵入する。
したがって、
“~login” 時に鍵を別の鍵に交換することが効果的な対策になると考えられる）。
】</p>

		</section>
		<section id="weak-confidentiality">
<h3 title="Weak Confidentiality">8.5. 機密性の弱点</h3>

<p>
~cookieは~portによる隔離を供さない。
~cookieが，ある~port上で稼働している~serviceで読取れるならば、
その~cookieは，同じ~serverの別~port上の~serviceでも読取れる。
~cookieが，ある~port上の~serviceで書込めるならば、
その~cookieは，同じ~serverの別~port上の~serviceでも書込める。
この理由から、
~serverは、［
同じ~hostの異なる~port上で，互いに信用し合っていない~serviceを同時に稼働しているとき
］は，~securityに敏感な情報を~cookieを利用して格納するベキでない。
◎
Cookies do not provide isolation by port. If a cookie is readable by a service running on one port, the cookie is also readable by a service running on another port of the same server. If a cookie is writable by a service on one port, the cookie is also writable by a service running on another port of the same server. For this reason, servers SHOULD NOT both run mutually distrusting services on different ports of the same host and use cookies to store security-sensitive information.
</p>

<p>
~cookieは~schemeによる隔離を供さない。
~cookieは `http^c と `https^c ~schemeで最も共通的に利用されるが、
所与の~host用の~cookieは，
`ftp^c や `gopher^c などの他の~schemeでも可用になり得る。
この，~schemeによる隔離の欠如は、
~cookieへの~accessを許可する`非HTTP~API$
（例：~HTMLの `document.cookie$dom ~API）
において顕著に見られるが、
~schemeによる隔離の欠如はまた，
~cookieの処理~要件にも実際に在る
（例：~HTTPを介して `gopher^c ~scheme~URIから検索取得することを考えてみよ）。
【~web~platform（~browser）においては、 `gopher^c はすでに廃されている ／ `ftp^c は廃されつつある。】
◎
Cookies do not provide isolation by scheme. Although most commonly used with the http and https schemes, the cookies for a given host might also be available to other schemes, such as ftp and gopher. Although this lack of isolation by scheme is most apparent in non-HTTP APIs that permit access to cookies (e.g., HTML's document.cookie API), the lack of isolation by scheme is actually present in requirements for processing cookies themselves (e.g., consider retrieving a URI with the gopher scheme via HTTP).
</p>

<p>
~cookieは~pathによる隔離を常に供するものではない。
~network~levelの~protocolでは、
ある~pathに対応して格納された~cookieが，別の~pathに向けて送信されることはないが、
一部の~UAは，［
~HTMLの `document.cookie^dom ~APIなどの`非HTTP~API$
］を介して~cookieを公開する。
これらの~UAの一部（例：~web~browser）は，
異なる~pathから受信した資源を隔離しないので、
ある~pathから検索取得された資源は，
別の~path用に格納された~cookieに~access可能になるかもしれない。
◎
Cookies do not always provide isolation by path. Although the network-level protocol does not send cookies stored for one path to another, some user agents expose cookies via non-HTTP APIs, such as HTML's document.cookie API. Because some of these user agents (e.g., web browsers) do not isolate resources received from different paths, a resource retrieved from one path might be able to access cookies stored for another path.
</p>

		</section>
		<section id="weak-integrity">
<h3 title="Weak Integrity">8.6. 完全性の弱点</h3>

<p>
~cookieは、
同胞~domain（およびそれらの下位domain）に対する完全性（ `integrity^en ）を保証しない。
例えば, `foo.site.example^s と `bar.site.example^s を考える。
`foo.site.example^s の~serverは、
`Domain$a 属性 `site.example^l の~cookieを設定できる
（場合によっては、
既存の `site.example^l ~cookieを上書する）。
~UAは、
その~cookieを `bar.site.example^s へ向けた~HTTP要請に内包することになる。
最悪の場合、
`bar.site.example^s は，この~cookieと 自身が設定した~cookieとを判別できなくなる。
`foo.site.example^s ~serverは、
この能を利用して `bar.site.example^s への攻撃を仕掛けるかもしれない。
◎
Cookies do not provide integrity guarantees for sibling domains (and their subdomains). For example, consider foo.site.example and bar.site.example. The foo.site.example server can set a cookie with a Domain attribute of "site.example" (possibly overwriting an existing "site.example" cookie set by bar.site.example), and the user agent will include that cookie in HTTP requests to bar.site.example. In the worst case, bar.site.example will be unable to distinguish this cookie from a cookie it set itself. The foo.site.example server might be able to leverage this ability to mount an attack against bar.site.example.
</p>

<p>
`Set-Cookie^h ~headerが `Path$a 属性を~supportしていても，
~UAは `Set-Cookie^h ~header内の任意の `Path$a 属性を受容するので、
`Path$a 属性は，いかなる完全性の保護も供さない。
例えば，
`http://site.example/foo/bar^s
に向けた要請に対する~HTTP応答は、
`Path$a 属性 `/qux^l の~cookieを設定できる。
したがって~serverは、［
同じ~hostの異なる~path上で，互いに信用し合っていない~serviceを同時に稼働しているとき
］は，~securityに敏感な情報を~cookieを利用して格納するベキでない。
◎
Even though the Set-Cookie header field supports the Path attribute, the Path attribute does not provide any integrity protection because the user agent will accept an arbitrary Path attribute in a Set-Cookie header field. For example, an HTTP response to a request for http://site.example/foo/bar can set a cookie with a Path attribute of "/qux". Consequently, servers SHOULD NOT both run mutually distrusting services on different paths of the same host and use cookies to store security-sensitive information.
</p>

<p>
能動的~network攻撃者は、
`http://site.example/^s
からの応答になりすまして `Set-Cookie^h ~headerを注入することにより，
`https://site.example/^s
に向けて送信される `Cookie^h ~headerに~cookieを注入できる。
`site.example^s
にある~HTTPS~serverは、
~HTTPS応答の中のこれらの~cookieと 自身が設定した~cookieとを判別できない。
`site.example^s が~HTTPSを排他的に利用していたとしても、
能動的~network攻撃者は，
この能を利用して `site.example^s への攻撃を仕掛けるかもしれない。
◎
An active network attacker can also inject cookies into the Cookie header field sent to https://site.example/ by impersonating a response from http://site.example/ and injecting a Set-Cookie header field. The HTTPS server at site.example will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response. An active network attacker might be able to leverage this ability to mount an attack against site.example even if site.example uses HTTPS exclusively.
</p>

<p>
~serverは、
自身の~cookieを［
その内容を暗号化して署名するか，
`__Secure-$l 接頭辞を伴うよう命名する
］ことにより，これらの攻撃を部分的に軽減できる。
しかしながら，［
攻撃者は、
自身が真正な `site.example^s ~serverから受信した~cookieを，
利用者の~sessionの中で再現できる
］ので、
暗号の利用は この課題を根本から払拭するものではなく，予測-不能な結果になる。
◎
Servers can partially mitigate these attacks by encrypting and signing the contents of their cookies, or by naming the cookie with the __Secure- prefix. However, using cryptography does not mitigate the issue completely because an attacker can replay a cookie he or she received from the authentic site.example server in the user's session, with unpredictable results.
</p>

<p>
最後に，攻撃者は、
多数の~cookieを格納させることにより，
~cookieを削除するよう~UAに強制するかもしれない。
~UAは，自身の保管~上限に達したとき、
何らかの~cookieを抹消するよう強制されることになる。
~serverは、
~UAが~cookieを維持することに依拠するベキでない。
◎
Finally, an attacker might be able to force the user agent to delete cookies by storing a large number of cookies. Once the user agent reaches its storage limit, the user agent will be forced to evict some cookies. Servers SHOULD NOT rely upon user agents retaining cookies.
</p>

		</section>
		<section id="reliance-on-dns">
<h3 title="Reliance on DNS">8.7. ~DNSへの依拠</h3>

<p>
~cookieの~securityは、
~DNS（ `Domain Name System^en ）に依拠する。
~DNSが部分的または全部的に弱体化された場合、
~cookie~protocolは，応用が要する~securityを供するのに失敗するであろう。
◎
Cookies rely upon the Domain Name System (DNS) for security. If the DNS is partially or fully compromised, the cookie protocol might fail to provide the security properties required by applications.
</p>

		</section>
		<section id="samesite-cookies">
<h3 title="SameSite Cookies">8.8. `SameSite^a ~cookie</h3>

			<section id="defense-in-depth">
<h4 title="Defense in depth">8.8.1. 多層防御</h4>

<p>
~cookieを配備するにあたって，
`SameSite$a を `Strict$l ~modeに設定した場合、
`~client$rqが それを~supportするならば，`~CSRF攻撃$に抗する堅牢な防御を提供する。
しかしながら，それだけでは、
`~CSRF攻撃$に抗する~siteの防御~すべてを成すには至らない
— `同一-~site$rqな［
~navi／~form提出
］は、
他の攻撃~行路
— ~XSSや~page~redirectionの濫用など —
を併用すれば，間違いなく実行できるので。
◎
"SameSite" cookies offer a robust defense against CSRF attack when deployed in strict mode, and when supported by the client. It is, however, prudent to ensure that this designation is not the extent of a site's defense against CSRF, as same-site navigations and submissions can certainly be executed in conjunction with other attack vectors such as cross-site scripting or abuse of page redirections.
</p>

<p>
要請がいつ, どうやって`同一-~site$rqであると見なされるかを理解することは、
~siteを `SameSite$a ~cookie用に適正に設計するためにも重要になる。
例えば、
`非同一-~site$rqな`~top-level要請$が，ある敏感な~page
— 要請は`非同一-~site$rqであると見なされ，
`SameSite$a が `Strict$l に設定された【！SameSite=Strict】~cookieは送信されなくなる~page —
へ為された場合でも、
その~pageの下位-資源への要請は`同一-~site$rqになり，
`SameSite$a が `Strict$l に設定された~cookieを受信することになろう。
~siteは、
初期~pageへの要請が適切な~cookieを内包しない場合には，
~errorを返すことにより［
これらの下位-資源への~accessを不作為に許容する
］ことを避けれる。
◎
Understanding how and when a request is considered same-site is also important in order to properly design a site for SameSite cookies. For example, if a cross-site top-level request is made to a sensitive page that request will be considered cross-site and SameSite=Strict cookies won't be sent; that page's sub-resources requests, however, are same-site and would receive SameSite=Strict cookies. Sites can avoid inadvertently allowing access to these sub-resources by returning an error for the initial page request if it doesn't include the appropriate cookies.
</p>

<p>
~riskをもっと全部的に軽減するため、
開発者には，通例の~server側~防御
（［
`安全$な~HTTP~methodは`冪等$になることを確保するための，~CSRF~token
］, 等々）
を配備することが強く奨励される。
◎
Developers are strongly encouraged to deploy the usual server-side defenses (CSRF tokens, ensuring that "safe" HTTP methods are idempotent, etc) to mitigate the risk more fully.
</p>

<p>
加えて，~client側の技法には
— `app-isolation$r 【 “~appどうしの隔離” 】に述べられるものなど —
`~CSRF攻撃$に抗して効果的であることを立証できるものもあり、
当然ながら， `SameSite$a ~cookieとの組合nで探求するに価しよう。
◎
Additionally, client-side techniques such as those described in [app-isolation] may also prove effective against CSRF, and are certainly worth exploring in combination with "SameSite" cookies.
</p>

			</section>
			<section id="top-level-navigations">
<h4 title="Top-level Navigations">8.8.2. ~top-level~navi</h4>

<p>
`SameSite$a 属性を `Strict$l ~modeに設定することは，`~CSRF攻撃$に抗する堅牢な多層防御を供するが、
~siteの開発者が［
~cookieに基づく~session管理~systemが，`~top-level~navi$を適度にきちんと処すること
］を注意深く確保していない限り，利用者を惑わす~~可能性がある。
◎
Setting the SameSite attribute in "strict" mode provides robust defense in depth against CSRF attacks, but has the potential to confuse users unless sites' developers carefully ensure that their cookie-based session management systems deal reasonably well with top-level navigations.
</p>

<p>
~MegaCorp社が
`https://site.example/^s
にて~web~mail~serviceを供していて，
利用者がそこで~emailを読んでいる局面を考える。
利用者は，［
~email内にある
`https://projects.example/secret/project^s
への~linkを~clickしたなら，~~閲覧権限がある秘匿情報（ “`secret project^en” ）を示す
］ものと期待するかもしれないが、
`https://projects.example^s が~session~cookieの `SameSite$a 属性に `Strict$l を伴わせていた場合，［
この~navi用に送信する`非同一-~site$rqな要請には、
その~cookieは伴われない
］ことになる。
`https://projects.example^s は，
秘匿情報の漏洩ngを避けるべく `404$st ~errorを具現化することになり、
利用者は惑わされることになろう。
◎
Consider the scenario in which a user reads their email at MegaCorp Inc's webmail provider https://site.example/. They might expect that clicking on an emailed link to https://projects.example/secret/project would show them the secret project that they're authorized to see, but if https://projects.example has marked their session cookies as SameSite=Strict, then this cross-site navigation won't send them along with the request. https://projects.example will render a 404 error to avoid leaking secret information, and the user will be quite confused.
</p>

<p>
開発者は、
~session管理~systemとして，~cookieに依拠するものを 1 つでなく 2 つ
— 概念的に 2 種の~access［
“読取n”, “書込n”
］を是認するもの —
を採用することにより，この惑いを避けれる：
◎
Developers can avoid this confusion by adopting a session management system that relies on not one, but two cookies: one conceptually granting "read" access, another granting "write" access.＼
</p>
<ul>
	<li>
“書込n” 用には、
`SameSite$a 属性に `Strict$l を伴わせることもできる
— それが無いときは［
冪等でない動作を実行する前に，認証し直す
］よう促すことになる。
◎
The latter could be marked as SameSite=Strict, and its absence would prompt a reauthentication step before executing any non-idempotent action.＼
</li>
	<li>
<p>
“読取n” 用には、
`SameSite$a 属性に次のどちらを伴わせることもできる：
</p>
		<ul>
			<li>
`Lax$l：
`~top-level~navi$を介する~dataに対し利用者からの~accessを許容するためには
</li>
			<li>
`None$l：
すべての文脈（非同一-~site埋込d文脈も含む）において~accessを許可するためには
</li>
		</ul>
◎
The former could be marked as SameSite=Lax, in order to allow users access to data via top-level navigation, or SameSite=None, to permit access in all contexts (including cross-site embedded contexts).
</li>
</ul>

			</section>
			<section id="mashups-and-widgets">
<h4 title="Mashups and Widgets">8.8.3. ~mashup／~widget</h4>

<p>
`SameSite$a 属性~用の［
`Lax$l ／ `Strict$l
］値は、
いくつかの重要な利用事例においては，不適切になる。
特に，`非同一-~site$な文脈に埋込むことが意図された内容
（例として，~SNS用の~widgetや~comment欄）は、
`同一-~siteな~cookie$に~accessできなくなることに注意。
これらの状況に要求される~cookieは、
`SameSite$a に `None$l を伴わせて，`非同一-~site$な文脈にも~accessを許容するべきである。
◎
The Lax and Strict values for the SameSite attribute are inappropriate for some important use-cases. In particular, note that content intended for embedding in cross-site contexts (social networking widgets or commenting services, for instance) will not have access to same-site cookies. Cookies which are required in these situations should be marked with SameSite=None to allow access in cross-site contexts.
</p>

<p>
同様に，ある形の `Single-Sign-On^en
【一回の認証で，複数の文脈にわたって認証されるようにすること】
は、
`非同一-~site$な文脈において，~cookieに基づく認証を要求するかもしれない。
これらの仕組みは、
`同一-~siteな~cookie$では意図されるように機能しないので，
`SameSite$a に `None$l を要することになる。
◎
Likewise, some forms of Single-Sign-On might require cookie-based authentication in a cross-site context; these mechanisms will not function as intended with same-site cookies and will also require SameSite=None.
</p>

			</section>
			<section id="server-controlled">
<h4 title="Server-controlled">8.8.4. ~serverにより制御されるもの</h4>

<p>
`SameSite$a ~cookieそれ自体には、［
`第三者-主体~cookie§【！`6265/7.1$rfc】にて要旨された，一般的な~privacyの懸念
］に取組むものは何もない。
`SameSite$a 属性は、
~serverにより設定され，~serverが心配する ある種の攻撃による~riskを軽減するよう~serveする。
この裁定には、
利用者は~~介入できない。
さらには、［
~cookieが無いときでも，別個な要請どうしを~linkすることを~serverに許容し得る
］ような，いくつかの~side-channelが存在する
（例えば，`同一-~site$rqな要請と`非同一-~site$rqな要請の間での `connection^en や `socket pooling^en ）。
◎
SameSite cookies in and of themselves don't do anything to address the general privacy concerns outlined in Section 7.1 of [RFC6265]. The "SameSite" attribute is set by the server, and serves to mitigate the risk of certain kinds of attacks that the server is worried about. The user is not involved in this decision. Moreover, a number of side-channels exist which could allow a server to link distinct requests even in the absence of cookies (for example, connection and/or socket pooling between same-site and cross-site requests).
</p>

			</section>
			<section id="reload-navigations">
<h4 title="Reload navigations">8.8.5. ~reload~navi</h4>

<p>
`~UI~reload~navi要請$が`同一-~site$rqになるのは、
~reloadされた文書が元々`同一-~site$な要請を介して`~navigate$された場合に限られる。
これは、
他の~reload~naviの取扱いと相違する。
後者は、
`~top-level~navi$ならば
— `~navi~algo$に渡す %~source文書 【！~source~navigableにて`作動中な文書$nav】は，精確に~reloadされている文書になるので —
常に`同一-~site$になる。
◎
Requests issued for reloads triggered through user interface elements (such as a refresh button on a toolbar) are same-site only if the reloaded document was originally navigated to via a same-site request. This differs from the handling of other reload navigations, which are always same-site if top-level, since the source navigable's active document is precisely the document being reloaded.
</p>

<p>
`~UI~reload~navi要請$に対する，この特別な取扱いは、
利用者が起動した~reloadに対し，`同一-~siteな~cookie$【！`SameSite$a ~cookie（以下同様）】の送信を避ける
— 元の~naviに対し，それが差止められた場合には（すなわち，初期~naviによる要請は`非同一-~site$rqであった場合）。
代わりに、
当の~reload~naviを`同一-~site$と見なして，初期~時に差止めた`同一-~siteな~cookie$をすべて送信した場合、
当初に差止めたことによる~securityの便益は，無に帰すことになろう。
これが，とりわけ重要になるのは、［
`非同一-~site$rqな~navi要請に対し，`同一-~siteな~cookie$を差止めること
］は，~siteの可視な非互換化に至ることもあり、
その結果，~reloadを誘発するよう利用者を促すことになるときである。
◎
This special handling of reloads triggered through a user interface element avoids sending SameSite cookies on user-initiated reloads if they were withheld on the original navigation (i.e., if the initial navigation were cross-site). If the reload navigation were instead considered same-site, and sent all the initially withheld SameSite cookies, the security benefits of withholding the cookies in the first place would be nullified. This is especially important given that the absence of SameSite cookies withheld on a cross-site navigation request may lead to visible site breakage, prompting the user to trigger a reload.
</p>

<p>
例えば、
利用者が攻撃者の~site
`https://attacker.example/^s
から被害者の~site
`https://victim.example/^s
を~~指す~linkを~clickしたとする。
これは，`非同一-~site$rqな要請になるので、
`同一-~siteな~cookie$（ `Strict$l ）は差止められる。
これが被害者の~siteが非互換化されるよう現れる原因になるとする
— 被害者の~siteは、
特定0の`同一-~siteな~cookie$が要請~内に在る場合に限り，
敏感な内容を表示することにしていたので。
利用者が予期しない~siteの破損にいらついて，~browserの~toolbarの~refreshを~clickすると、
今や，~reload要請は`同一-~site$と見なされ，
初期~時に差止めた`同一-~siteな~cookie$を送信することになる結果、
当初の目的を打破することになろう
— 当の`~UI~reload~navi要請$は、
元の（悪意的にもなり得る）要請を再現し得るので。
したがって，`~UI~reload~navi要請$は、
初期~時に~pageへ`~navigate$した要請と同様に，
`非同一-~site$rqな要請と見なされるべきである。
◎
For example, suppose the user clicks on a link from https://attacker.example/ to https://victim.example/. This is a cross-site request, so SameSite=Strict cookies are withheld. Suppose this causes https://victim.example/ to appear broken, because the site only displays its sensitive content if a particular SameSite cookie is present in the request. The user, frustrated by the unexpectedly broken site, presses refresh on their browser's toolbar. To now consider the reload request same-site and send the initially withheld SameSite cookie would defeat the purpose of withholding it in the first place, as the reload navigation triggered through the user interface may replay the original (potentially malicious) request. Thus, the reload request should be considered cross-site, like the request that initially navigated to the page.
</p>

<p>
~reload用に発行された要請が利用者が起動したものでない場合，
どれも `SameSite$a ~cookieを付するので、
開発者は，`~CSRF攻撃$を避けるよう［
~reloadをいつ起動するかについて，注意深くかつ思慮深くある
］べきである。
例えば、
~pageは，［
初期~要請に~CSRF~tokenが在る場合に限り，~reloadを起動する
］こともできる。
◎
Because requests issued for, non-user initiated, reloads attach all SameSite cookies, developers should be careful and thoughtful about when to initiate a reload in order to avoid a CSRF attack. For example, the page could only initiate a reload if a CSRF token is present on the initial request.
</p>

			</section>
			<section id="unsafe-top-level-requests">
<h4 title="Top-level requests with 'unsafe' methods">8.8.6. 安全でない~methodを伴う`~top-level要請$</h4>

<p>
`5.6.7.1§ に述べた `Lax$l 施行~modeは、［
`安全$な~HTTP~methodを伴う`~top-level~navi$である
］場合, そのときに限り，［
~cookieが`非同一-~site$rqな~HTTP要請に伴って送信される
］ことを許容する。
実装~経験により、
これを既定の挙動として適用するのは，困難であることが示されている
— 一部の~site（ `SameSite$a 属性が導入される以前から在る~siteなど）は、
次のような~cookieに依拠するので
⇒
［
`SameSite$a 属性を明示的に指定していない
］~AND［
それを含んでいる要請は、
次を満たす
］
⇒
［
`~top-level~navi$である
］~AND［
`非同一-~site$rqである
］~AND［
その~HTTP~methodは`安全$でない
］
◎
The "Lax" enforcement mode described in Section 5.6.7.1 allows a cookie to be sent with a cross-site HTTP request if and only if it is a top-level navigation with a "safe" HTTP method. Implementation experience shows that this is difficult to apply as the default behavior, as some sites may rely on cookies not explicitly specifying a SameSite attribute being included on top-level cross-site requests with "unsafe" HTTP methods (as was the case prior to the introduction of the SameSite attribute).
</p>

<p>
例えば，ある~login~flowを締めくくる段は、
ある端点への［
`非同一-~site$rqな~top-level `POST$m 要請
］を孕んでいて，この端点は［
近過去に作成された~loginを~secureに完了するために必要yな，~transaction上の状態~情報
］を包含している~cookieを期待することもある。
そのような~cookie用には、
`Lax$l の施行は適切でない
— そうすると、
要請~methodが`安全$でないことに因り，当の~cookieは除外され、
その結果，当の~login~flowは回復-不能な失敗になる。
◎
For example, the concluding step of a login flow may involve a cross-site top-level POST request to an endpoint; this endpoint expects a recently created cookie containing transactional state information, necessary to securely complete the login. For such a cookie, "Lax" enforcement is not appropriate, as it would cause the cookie to be excluded due to the unsafe HTTP request method, resulting in an unrecoverable failure of the whole login flow.
</p>

<p>
【！`5.6.7.2§ にて述べた】
`Lax-allowing-unsafe$l 施行~modeは，
`Lax$l の施行を成す保護の一部を（ `None$l に比較して）維持するが、
それでも，［
近過去に作成された~cookieが［
`非同一-~site$rqな`安全$でない`~top-level要請$
］に伴って送信される
］ことを許容する。
◎
The "Lax-allowing-unsafe" enforcement mode described in Section 5.6.7.2 retains some of the protections of "Lax" enforcement (as compared to "None") while still allowing recently created cookies to be sent cross-site with unsafe top-level requests.
</p>

<p>
`Lax-allowing-unsafe$l ~modeは，
`Lax$l ~modeの［
より許可的な変種
］であり、
`~CSRF攻撃$に抗する保護を少なくすることが必要yである。
そのような施行~modeの供給は、
究極的には，［
既定では `Lax$l 施行~modeにすること
］の採用を容易にするための［
一時的かつ過渡的な措置
］と見るべきである。
◎
As a more permissive variant of "Lax" mode, "Lax-allowing-unsafe" mode necessarily provides fewer protections against CSRF. Ultimately, the provision of such an enforcement mode should be seen as a temporary, transitional measure to ease adoption of "Lax" enforcement by default.
</p>

			</section>
		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">9. ~IANA考慮点</h2>

		<section id="iana-cookie">
<h3>9.1. `Cookie^h</h3>

<p>
~HTTP~field名~registry `HttpFieldNameRegistry$r は、
以下の登録により更新される必要がある。
◎
The HTTP Field Name Registry (see [HttpFieldNameRegistry]) needs to be updated with the following registration:
</p>

<div>
<table><tbody>
<tr><th>~header名
<td>`Cookie^h
<tr><th>適用-可能な~protocol
<td>http
<tr><th>位置付け
<td>standard
<tr><th>著作者
<td>IETF
<tr><th>変更~制御者
<td>IETF
<tr><th>仕様~文書
<td>この仕様の `5.8.1§
</table>
◎
Header field name:
• Cookie
Applicable protocol:
• http
Status:
• standard
Author/Change controller:
• IETF
Specification document:
• this specification (Section 5.8.1)
</div>

		</section>
		<section id="iana-set-cookie">
<h3>9.2. `Set-Cookie^h</h3>

<p>
~HTTP~field名~registry `HttpFieldNameRegistry$r は、
以下の登録により更新される必要がある。
◎
The HTTP Field Name Registry (see [HttpFieldNameRegistry]) needs to be updated with the following registration:
</p>

<div>
<table><tbody>
<tr><th>~header名
<td>`Set-Cookie^h
<tr><th>位置付け
<td>standard
<tr><th>著作者
<td>IETF
<tr><th>変更~制御者
<td>IETF
<tr><th>仕様~文書
<td>この仕様の `5.6§
</table>
◎
Header field name:
• Set-Cookie
Applicable protocol:
• http
Status:
• standard
Author/Change controller:
• IETF
Specification document:
• this specification (Section 5.6)
</div>

		</section>
		<section id="cookie-attribute-registry">
<h3 title="“Cookie Attribute” Registry">9.3. ~cookie属性~registry</h3>

<p>
~IANAには、
“~HTTP~cookie属性~registry（ `Hypertext Transfer Protocol (HTTP) Cookie Attributes^en ）”
と称される新たな~registry~groupを作成することが要請される。
この~registryは、［
~cookieの挙動を制御するために利用される属性たち
］が成す名前空間を定義する。
この~registryは、
`~IANA-a/cookie-attribute-names＠~IANA-a/cookie-attribute-names$
にて保守されるべきである。
【~link先は、まだ存在しない。】
◎
IANA is requested to create the "Cookie Attributes" registry, defining the name space of attributes used to control cookies' behavior. The registry should be maintained in a new registry group called "Hypertext Transfer Protocol (HTTP) Cookie Attributes" at https://www.iana.org/assignments/cookie-attribute-names.
</p>

			<section id="procedure">
<h4 title="Procedure">9.3.1. 手続-</h4>

<p>
登録される各 属性の名前には、
記述, および次への参照が結付けられる
⇒
属性が［
どう処理され, 格納されるか
］の詳細
◎
Each registered attribute name is associated with a description, and a reference detailing how the attribute is to be processed and stored.
</p>

<p>
新たな登録は、
`RFC8126$r `~RFCが要求される＠~RFCx/rfc8126#section-4.7§ 
に基づいて行われる。
登録される属性は、
`extension-av$p 構文に合致しなければナラナイ。
属性の名前は、
一般には `CamelCase^en で定義されるが，
文字大小無視として認識されなければナラナイことに注意。
文字大小無視で合致する複数の属性~名が登録されてはナラナイ。
◎
New registrations happen on a "RFC Required" basis (see Section 4.7 of [RFC8126]). The attribute to be registered MUST match the extension-av syntax defined in Section 4.1.1. Note that attribute names are generally defined in CamelCase but MUST be recognized case-insensitively. Two attribute names that case-insensitively match MUST NOT be registered.
</p>
			</section>
			<section id="registration">
<h4 title="Registration">9.3.2. 登録</h4>

<p>
“~HTTP~cookie属性~registry” は、
以下の登録を伴って作成されるべきである：
◎
The "Cookie Attributes" registry should be created with the registrations below:
</p>

<div>
<table><thead>
<tr><th>名前
<th>参照
<tbody>

<tr><td>`Domain^a
<td>この文書の `4.1.2.3§
<tr><td>`Expires^a
<td>この文書の `4.1.2.1§
<tr><td>`HttpOnly^a
<td>この文書の `4.1.2.6§
<tr><td>`Max-Age^a
<td>この文書の `4.1.2.2§
<tr><td>`Path^a
<td>この文書の `4.1.2.4§
<tr><td>`SameSite^a
<td>この文書の `4.1.2.7§
<tr><td>`Secure^a
<td>この文書の `4.1.2.5§
</table>
◎
Name	Reference
Domain	Section 4.1.2.3 of this document
Expires	Section 4.1.2.1 of this document
HttpOnly	Section 4.1.2.6 of this document
Max-Age	Section 4.1.2.2 of this document
Path	Section 4.1.2.4 of this document
SameSite	Section 4.1.2.7 of this document
Secure	Section 4.1.2.5 of this document
</div>

			</section>
		</section>
	</section>
	<section id="changes-from-rfc-6265">
<h2 title="Changes from RFC 6265">~RFC 6265 からの変更点</h2>

<ul>
	<li>
`同一-~site$の概念と `SameSite$a 属性を追加した。
（ `5.2§, `4.1.2.7§ 【, `8.8§ 】 ）
◎
Adds the same-site concept and the SameSite attribute. (Section 5.2 and Section 4.1.2.7)
</li>
	<li>
~cookie接頭辞を導入した。
名前を伴わない~cookieが そのような接頭辞を真似る値を設定することを禁制した。
（ `4.1.3§, `5.7§ ）
◎
Introduces cookie prefixes and prohibits nameless cookies from setting a value that would mimic a cookie prefix. (Section 4.1.3 and Section 5.7)
</li>
	<li>
~secureでない生成元が［
新たな／既存の
］~cookieの `secure-only-flag$cK【！Secure flag】 を ~T に［
設定する／上書する
］ことを禁制した。
（ `5.7§ ）
◎
Prohibits non-secure origins from setting cookies with a Secure flag or overwriting cookies with this flag. (Section 5.7)
</li>
	<li>
~cookie~sizeの最大を制限した。
（ `5.7§ ）
◎
Limits maximum cookie size. (Section 5.7)
</li>
	<li>
［
`Max-Age$a, `Expires$a
］用の最大な値を制限した。
（ `5.6.1§, `5.6.2§ ）
◎
Limits maximum values for max-age and expire. (Section 5.6.1 and Section 5.6.2)
</li>
	<li>
`host-only-flag$cK も【`~cookie保管庫$における】~cookieの一意~性を成す~keyとして含めるようにした。
（ `5.7§ ）
◎
Includes the host-only-flag as part of a cookie’s uniqueness computation. (Section 5.7)
</li>
	<li>
信用に価し得る生成元は “~secureである” ものと見なすようにした。
（ `5.7§ 【この訳においては、`~secureな接続$に関する注記】）
◎
Considers potentially trustworthy origins as "secure". (Section 5.7)
</li>
	<li>
<p>
~cookie構文を改善した：
◎
Improves cookie syntax
</p>
		<ul>
			<li>
<code>Set-Cookie: %token</code> は、
( 名前: 空~文字列, 値: %token )
を伴う~cookieを作成するものとして扱うようにした。 
（ `5.6§ ）
◎
Treats Set-Cookie: token as creating the cookie ("", "token"). (Section 5.6)
</li>
			<li>
名前, 値どちらも伴わない~cookieを却下するようにした。
（ `5.7§ ）
◎
Rejects cookies without a name nor value. (Section 5.7)
</li>
			<li>
名前, 値どちらかを伴わない~cookieを直列化する方法を指定した。
（ `5.8.3§ ）
◎
Specifies how to serialize a nameless/valueless cookie. (Section 5.8.3)
</li>
			<li>
［
`cookie-pair$p,
`set-cookie-string$p
【！the Cookie header production】
］用の~ABNFを~space【 `BWS$p 】を許容するよう調整した。
（ `4.1.1§ ）
◎
Adjusts ABNF for cookie-pair and the Cookie header production to allow for spaces. (Section 4.1.1)
</li>
			<li>
制御~文字【 `CTL^P 】を明示的に取扱うようにした。
（ `5.6§, `5.7§ ）
◎
Explicitly handle control characters. (Section 5.6 and Section 5.7)
</li>
			<li>
空な `Domain$a 属性を取扱う方法を指定した。
（ `5.7§ ）
◎
Specifies how to handle empty domain attributes. (Section 5.7)
</li>
			<li>
`Domain$a 属性には~ASCII文字が要求されるものとした。
（ `5.7§ ）
◎
Requires ASCII characters for the domain attribute. (Section 5.7)
</li>
		</ul>
	</li>
	<li>
~cookie検索取得~algoを非~HTTP~APIを~supportするよう~~再構成した。
（ `5.8.2§ ）
◎
Refactors cookie retrieval algorithm to support non-HTTP APIs. (Section 5.8.2)
</li>
	<li>
`Set-Cookie^h 行l【を成す~percent-符号化された~octet列】は復号するべきでないものと指定した。
（ `5.6§ ）
◎
Specifies that the Set-Cookie line should not be decoded. (Section 5.6)
</li>
	<li>
実装者が どの要件を実装するか裁定することを支援するための助言的な節を追加した。
（ `3.2§ ）
◎
Adds an advisory section to assist implementers in deciding which requirements to implement. (Section 3.2)
</li>
	<li>
公共~接尾辞~listの変更に因り無効になった~cookieの送信を止めるよう勧めた。
 （ `5.8.3§ ）
◎
Advises against sending invalid cookies due to public suffix list changes. (Section 5.8.3)
</li>
	<li>
`Cookie^h ~headerは 1 個までとする要件を除去した。
（ `5.8.1§ ）
◎
Removes the single cookie header requirement. (Section 5.8.1)
</li>
	<li>
<p>
正誤表に取組んだ：
</p>
		<ul>
			<li>
`正誤表 3444＠https://www.rfc-editor.org/errata/eid3444$：
`path-value$p, `extension-av$p の文法を更新することにより。
</li>
			<li>
`正誤表 4148＠https://www.rfc-editor.org/errata/eid4148$：
`day-of-month$p, `year$p, `time$p の文法を更新することにより。
</li>
			<li>
`正誤表 3663＠https://www.rfc-editor.org/errata/eid3663$：
要請された注記を追加することにより。
</li>
		</ul>
<p>
（ `4.1§, `5.1.4§ ）
</p>
◎
Address errata 3444 by updating the path-value andextension-av grammar, errata 4148 by updating the day-of-month, year, and time grammar, and errata 3663 by adding the requested note. (Section 4.1 and Section 5.1.4)
</li>
</ul>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
RFC 6265 は、
`Adam Barth^en 氏により書かれた。
この文書は、
RFC 6265 に対し，特能を追加して その仕様を今日の配備の実態に揃うようにした更新である。
この仕様の大半を成す~textは氏によるものであり、
我々は，その巨人の肩の上に乗っている。
◎
RFC 6265 was written by Adam Barth. This document is an update of RFC 6265, adding features and aligning the specification with the reality of today's deployments. Here, we're standing upon the shoulders of a giant since the majority of the text is still Adam's.
</p>

<p>
以前の編集者 `Lily Chen^en 氏, `Steven Englehardt^en 氏による，
この草案を改善する有意な貢献に感謝する。
◎
Thank you to both Lily Chen and Steven Englehardt, editors emeritus, for their significant contributions improving this draft.
</p>

	</section>
</main></div>
