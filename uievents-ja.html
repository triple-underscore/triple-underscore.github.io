<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>UI Events （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
img {
	background: white;
}
.glyph {
	color: var(--K-color);
	background: var(--O-bg);
}

.key-cap {
	border: outset thin var(--N-color);
	font-family: sans-serif0, sans-serif;
}

.key, .key-code, .key-cap {
	padding:0 0.2em;
	color: var(--K-color);
	border-radius: 3px;
}

.key {
	/* event.key */
	background: var(--C-bg);
}
.key-code {
	/* event.code */
	background: var(--V-bg);
}

tr {
	border-top: thin solid var(--table-rule-color);
}

@supports (grid-template-columns: subgrid) and (display: contents) {

#_event-list {
	grid-template-columns: 4em 1fr 1fr 1fr;
	min-width: 32em;
	max-width: 54em;
	tr {
		grid-template-areas:
			"型 型 型 型"
			". 同期 浮上 取消"
			". 標的 標的 interface"
			". 動作 動作 動作"
		;
		> *:nth-child(1) {
			grid-area: 型;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 同期;
		}
		> *:nth-child(3) {
			grid-area: 浮上;
		}
		> *:nth-child(4) {
			grid-area: 標的;
		}
		> *:nth-child(5) {
			grid-area: interface;
		}
		> *:nth-child(6) {
			grid-area: 取消;
		}
		> *:nth-child(7) {
			grid-area: 動作;
			min-height: 1.3em;
		}
	}
}

}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	let current_ifc = '#';

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.*?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'e':
	text = `&lt;${key}&gt;`;
	break;
case 'kY': // key event .key value
	href = `~UIEVENTS-KEY#key-${key}`;
	break;
case 'kC': // key event .code value
	href = `~UIEVENTS-CODE#code-${key}`;
	break;
case 'kGl': // key glyph
	text = `"<code class="glyph">${key}</code>"`;
	break;
case 'cap': // key cap
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'I':
	if((indicator === '@') || (indicator === '!')){
		current_ifc = `#dom-${key.toLowerCase()}-`;
	}
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`;
	break;
case 'm' :
	let n = text.indexOf('(');
	if( n > 0 ){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	n = key.indexOf('.');
	if( 0 > n ) {
		href = current_ifc + key.toLowerCase();
	} else {
		text = text.slice(n + 1);
		href = `#dom-${key.replace(/\./, '-').toLowerCase()}`;
	}
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'cn':
	text = key.toUpperCase();
	break;
case 'APX':
	return (
`<p class="trans-note">【この節の和訳は<a href="~UIEVENTS-A#${key}">別~page</a>にて。】</p>`
	);
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2026-02-21
trans_update:2026-02-24
source_checked:260221
page_state_key:UIEVENTS
original_url:https://w3c.github.io/uievents/
	http://www.w3.org/TR/uievents/
	abbr_url:UIEVENTS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
	conformance:w3c
copyright:2026,permissive
trans_1st_pub:2015-08-28


●●class_map
E:error
et:event-type
e:element
a:attr
kY:key
U:code-point
kC:key-code
cap:key-cap
css:css
p:css
cn:cp-name

●●tag_map
c:code
I:code
m:code
E:code
et:code
e:code
a:code
css:code
p:code
kY:code
U:span
kC:code
cap:span
v:var
cn:span
i:i
em:em
cite:cite

●●navs
イベント:.eventdef

●●original_id_map

	uievent:uievent-uievent
	keyboardevent:keyboardevent-keyboardevent
element:

	initialize-a-uievent:initialize-a-uievent-id
	initialize-a-mouseevent:initialize-a-mouseevent-id
	initialize-pointerlock-attributes-for-mouseevent:initialize-pointerlock-attributes-for-mouseevent-id
	set-pointerlock-attributes-for-mousemove:set-pointerlock-attributes-for-mousemove-id

●●mdn_urls
compositionevent:API/CompositionEvent
focusevent:API/FocusEvent
inputevent:API/InputEvent
keyboardevent:API/KeyboardEvent
uievent:API/UIEvent

	load:？/load
	unload:？/unload
	abort:？/abort
error:API/Element/error_event
select:API/Element/select_event
beforeinput:API/HTMLElement/beforeinput_event
input:API/HTMLElement/input_event
blur:API/Element/blur_event
compositionend:API/Element/compositionend_event
compositionstart:API/Element/compositionstart_event
compositionupdate:API/Element/compositionupdate_event
focus:API/Element/focus_event
focusin:API/Element/focusin_event
focusout:API/Element/focusout_event
keydown:API/Element/keydown_event
keyup:API/Element/keyup_event

●●link_map

Exposed:~WEBIDLjs#Exposed

boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
unsigned long:~WEBIDL#idl-unsigned-long
unrestricted double:~WEBIDL#idl-unrestricted-double
DOMString:~WEBIDL#idl-DOMString
USVString:~WEBIDL#idl-USVString

I.EventTarget:~DOM4#eventtarget
I.EventListener:~DOM4#callbackdef-eventlistener
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.CustomEvent:~DOM4#customevent
I.XMLHttpRequest:~XHR#xmlhttprequest
I.MutationObserver:~DOM4#mutationobserver

I.UIEvent:#uievent
I.UIEventInit:#dictdef-uieventinit
I.FocusEvent:#focusevent
I.FocusEventInit:#dictdef-focuseventinit
I.EventModifierInit:#dictdef-eventmodifierinit
I.MouseEvent:~POINTEREVENTS#dom-mouseevent
I.InputEvent:#inputevent
	I.InputEvent:#interface-InputEvent
I.InputEventInit:#dictdef-inputeventinit
I.KeyboardEvent:#keyboardevent
I.KeyboardEventInit:#dictdef-keyboardeventinit
I.CompositionEvent:#compositionevent
I.CompositionEventInit:#dictdef-compositioneventinit

I.Element:~DOM4#element
I.Document:~DOM4#document
	I.Document:#interface-Document
I.Window:~WINDOW#window
I.WindowProxy:~HTMLWPROXY#windowproxy
I.HTMLInputElement:~HEinput#htmlinputelement

et.abort:#abort
et.beforeinput:#beforeinput
et.blur:#blur
et.compositionend:#compositionend
et.compositionstart:#compositionstart
et.compositionupdate:#compositionupdate
et.error:#error
et.focus:#focus
et.focusin:#focusin
et.focusout:#focusout
et.input:#input
et.keydown:#keydown
et.keyup:#keyup
et.load:#load
et.select:#select
et.unload:#unload

et.click:~POINTEREVENTS#dfn-click
et.mousemove:~POINTEREVENTS#dfn-mousemove
et.keypress:~UIEVENTS-A#keypress
et.DOMActivate:~UIEVENTS-A#domactivate

	m.~indata:#dom-inputevent-data
	m.~compdata:#dom-compositionevent-data
	m.target:#dom-event-target

m.InputEvent.data:#dom-inputevent-data

m.NONE:~DOM4#dom-event-none
m.CAPTURING_PHASE:~DOM4#dom-event-capturing_phase
m.AT_TARGET:~DOM4#dom-event-at_target
m.BUBBLING_PHASE:~DOM4#dom-event-bubbling_phase

m.addeventlistener:~DOM4#dom-eventtarget-addeventlistener
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.charCode:~UIEVENTS-A#dom-keyboardevent-charcode
m.composed:~DOM4#dom-event-composed
m.currentTarget:~DOM4#dom-event-currenttarget
m.defaultPrevented:~DOM4#dom-event-defaultprevented
	m.detail:~DOM4#dom-customevent-detail
m.eventPhase:~DOM4#dom-event-eventphase
m.initEvent:~DOM4#dom-event-initevent
m.initCustomEvent:~DOM4#dom-customevent-initcustomevent
m.isTrusted:~DOM4#dom-event-istrusted
m.keyCode:~UIEVENTS-A#dom-keyboardevent-keycode
m.movementX:~POINTERLOCK#dom-mouseevent-movementx
m.movementY:~POINTERLOCK#dom-mouseevent-movementy
	＠~POINTEREVENTS#dom-mouseevent-screenx
	＠~POINTEREVENTS#dom-mouseevent-screeny

m.preventDefault:~DOM4#dom-event-preventdefault
m.removeeventlistener:~DOM4#dom-eventtarget-removeeventlistener
m.stopPropagation:~DOM4#dom-event-stoppropagation
m.stopImmediatePropagation:~DOM4#dom-event-stopimmediatepropagation
m.type:~DOM4#dom-event-type
m.target:~DOM4#dom-event-target
	m.target → ev.~target
m.timeStamp:~DOM4#dom-event-timestamp
m.which:~UIEVENTS-A#dom-uievent-which


m.dispatchEvent:~DOM4#dom-eventtarget-dispatchevent
m.createEvent:~DOM4#dom-document-createevent
m.handleEvent:~DOM4#dom-eventlistener-handleevent

	m.view:#dom-uievent-view
	m.detail:#dom-uievent-detail

m.Document.getSelection:~SELECTIONAPI#dom-document-getselection

e.textarea:~HEforms#the-textarea-element
e.input:~HEinput#the-input-element

	●用語
組成~event:#composition-events
~focus~event:#events-focusevent
~keyboard~event:#events-keyboardevents

修飾~UIkey状態:#key-modifier-state

内部~UIkey修飾~状態:~POINTEREVENTS#dfn-internal-key-modifier-state
~UIkey修飾~名:~POINTEREVENTS#dfn-key-modifier-name

~UIEventを初期化する:#initialize-a-uievent

最後の~mousemove位置:#last-mouse-move
~MouseEvent用に各~pointer~lock属性を初期化する:#initialize-pointerlock-attributes-for-mouseevent
~mousemove用に各~pointer~lock属性を設定する:#set-pointerlock-attributes-for-mousemove

	●§
§ ~keyboard~eventと~UIkey値:#keys
§ 各種~UI~eventに共通な文脈~情報:#_common-UI-event-context
§ 各種~入力~eventに共通な文脈~情報:#_common-input-event-context
§ 各種~keyboard~eventに共通な文脈~情報:#_common-keyboard-event-context
	各種~変異~eventに共通な文脈~情報:#_common-mutation-event-context
§ 各種~組成~eventに共通な文脈~情報:#_common-composition-event-context


	●appendix
作者:~UIEVENTS-A#author
非推奨:~UIEVENTS-A#deprecated
非推奨に:~UIEVENTS-A#deprecated
~host言語:~UIEVENTS-A#host-language

修飾~UIkeyの表t:~UIEVENTS-KEY#keys-modifier
~UIkey属性~値:~UIEVENTS-KEY#key-attribute-value

	●用語集
作動化の誘発:#activation-trigger
~body要素:#body-element
文字~値:#character-value
~dead-key:#dead-key
既定~動作:#default-action
要素:#element
空~文字列:#empty-string
~event型:#event-type
~event~focus:#event-focus
~focus:#event-focus
~focus環:#event-focus-ring
~event~focus環:#event-focus-ring
~event~target:#event-target
~target:#event-target
	~target:~DOM4#event-target
~IME:#ime
	入力~method~editor:#input-method-editor
~UIkey対応付け:#key-mapping
~UIkey値:#key-value
~UIkey~code:#keys-codevalues

修飾~UIkey:#modifier-key
QWERTY:#qwerty
根~要素:#root-element
~text組成~system:#text-composition-system
~Unicode字種:#unicode-character-categories
未初期化~値:#un-initialized-value

~trusted:#_trusted-event
取消~可能:#_cancelable
浮上-:#_bubbles

	●外部
~UA:~INFRA#user-agent
文書:~DOM#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
~event:~DOM4#concept-event
~eventを初期化する:~DOM4#concept-event-initialize
配送-:~DOM4#concept-event-dispatch
作動化の挙動:~DOM4#eventtarget-activation-behavior
ev.~target:~DOM4#event-target
~event~listener:~DOM4#concept-event-listener

捕捉-相:~DOM4#dom-event-capturing_phase
~target相:~DOM4#dom-event-at_target
浮上-相:~DOM4#dom-event-bubbling_phase

~window:~WINDOW#the-window-object


●●words_table1
UAAG20:http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/
	http://www.w3.org/TR/UAAG20/
UIEVENTS-A:uievents-appendix-ja.html
	https://w3c.github.io/uievents/
UIEVENTS-KEY:uievents-key-ja.html
	https://www.w3.org/TR/uievents-key/
UIEVENTS-CODE:https://www.w3.org/TR/uievents-code/
POINTERLOCK:https://w3c.github.io/pointerlock/

compdata:data
aT:@
SPACEBAR:<span style="color:var(--pale-color)"> Space </span>

集約簡略化:<p class="trans-note">【この訳では、各所に共通な記述をこの節に集約する。】</p>


●●words_table

	●略称／名称
Events:
Event:

IME:
PC:
XHTML:

UIEvent:
MouseEvent:

	unicode
	window:Window
	QWERTY
	Windows
	Macintosh
	MacOS
	Chrome
	Firefox
	Linux
	Latin Small Letter
	~pointer~lock:PointerLock
	DOM Level 2
	DOM Level 0:DOM0

	●event flow
序列:order::~::オーダー
組成:composition::~
組成-:compose::~
	組成-済み:composed
	~text組成
	組成~event:Composition Events:::組成イベント
	Composition Events
	:composing

誘発:trigger::~
trusted:
	~trustedでない:untrusted
	信用済み
相:phase::~::フェイズ
	target:::ターゲット
	at-target:
捕捉-:capture::~::キャプチャ
経路:path::~::パス
作動-:actuate::~::アクチュエート
活動:activity:~:::アクティビティ
文脈依存:varies:~
到着-:arrive:~
合成な:syntheticな::~

	●処理一般
相互相対順序:set order relative to one another:互いに相対的な順序
発する:emitする:~
復帰-:revert:~
立上げる:launchする:立ち上げる
立上げら:launchさ:立ち上げら
稼働-:run:~
経過-:elapse:~
持続-:persist:~
後続-:follow:~
	後続-:followed by
初期化子:initializer:~
未初期化:un-initialized:~
渡して:passして:~
受動的:passive::~
mousemove:

	進捗~中:in-progress
	起動-:initiation
	状態~変化-中にある:state-changing
	直後:immediately after
	直後:after
	時点:at the time
	この時点:at this point
	1 にする:set
	0 にする:clear
	ε:undefined
	~RET:exit

	●変数

	%~event:event
	%~event型:eventType
	%~event~target:eventTarget
	%浮上するか:bubbles
	%取消~可能か:cancelable
	%~x:-
	%~y:-
	%動き~x:event.movementX
	%動き~y:event.movementY

	●構造
先行-:precede::~
	child-parent-sibling::親, 子, 同胞

	●UI
desktop::::デスクトップ
環:ring::~
被focus:focused:被 focus::被フォーカス
tabbing::::タブキー操作
shortcut::::ショートカット

失う:loseする:~
失っ:loseし:~
	~UItab帯:tab-strip
voice::::ボイス
touch::::タッチ
macro::::マクロ
player::::プレイヤー
game::::ゲーム
checkbox::::チェックボックス
	~graphicな:graphical
	~URL~bar:Web site location bar
知覚-:percept:~
	perceptible
真似て:mimicして:~
模倣-:simulate:~
人間工学:ergonomics:~
	~~外見上の~~類似:superficial resemblance
淵:edge:~
rate::::レート
窓:window:~
投入-:feed:~

	:WASD
	時間~内で:amount of time
	最も前面:frontmost

	●UI 操作
~操作
shift:
	~shiftなし:unshifted
	~shiftあり:shifted
	-:shift-state
	切替わる
	~~切替えた:shiftした
打込んだ:typeした:打ち込んだ:::タイプした
打込まれ:typeされ:打ち込まれ:::タイプされ
叩いた:hitした:~
押下げら:depressさ:~
	-:long depression
押-:press:~
	~UIkeyの長押し:long-key-press
	押:down
	~~押下げ:down
離す:releaseする:~
離-:release:~
	離:up
手書き:handwriting:~
操作o:operation:操作
開く:openする:~
閉じる:closeする:~
閉じら:closeさ:~
退けら:dismissさ:~
動き:movement:~
選択-:select:~
選択:selection:~
編集-:edit:~
編集:editing:~
transaction::::トランザクション

	一定時間:sustained period
	~~持続的に:sustained manner

	●UI keyboard
locale::::ロケール
対応付-:mapし::~
	対応付-直:remap
	〜用の`~UIkey対応付け$:mapping
keystroke::::キーストローク
function::::ファンクション
scancode::::スキャンコード
switch::::スィッチ
銘:legend::~
US:
	US 配列
Romaji::::ローマ字
Arabic::::アラビア語
Colemak:
Dvorak:
French::::フランス語配列
Serbian::セルビア語
中国語:Chinese:~
日本語:Japanese:~
韓国語:Korean:~
漢字:Kanji characters:~
数字n:number:数字
umlaut::::ウムラウト
大文字形:majuscule form (uppercase or capital letters):~
小文字形:minuscule form (lowercase or small letters):~
	~key-state::::
	~Form::::
書記体系:writing system:~
普通字:letter::~
asterisk::::アスタリスク
約物:punctuation:~
accent::::アクセント符
表語文字:logogram:~
字種:character categories:~
異形同音異義語:homophone:~
発音-:pronounce:~
発音区別符:diacritic:~
発音区別符号:diacritical-mark:~
表意文字:ideograph:~
修飾:modifier:~
	修飾~UIkey:modifiers
修飾-:modify:~
未修飾:unmodified:~
候補:candidate:~
所在-:locate:~
矢印:arrow:~

	対にする:matchさせる
	対を成さない:unmatched
	対を成す:matching
	対を成さない:dangling
	記号:Symbol

	`Shift^l:shift
	`Control^l:control
	`Alt^l:alt
	`AltGraph^l:altgraph
	`Meta^l:meta

	●装置
pen::::ペン
tablet::::タブレット
物理的0:mechanical:物理的
携帯:mobile::~::モバイル
表面:surface:~
加速:accelerator:~
右:right:~
左:left:~
hotkey::::ホットキー
cap::::キャップ
PC101US:PC 101 Key US::PC 101 US
dead-key::::デッドキー
	dead key
十key:numeric keypad:::テンキーの類
numpad:numeric pad:::テンキー
access-key:access key:::アクセスキー
目印:marking:~
印字-:mark:~
	-:printable


	●仕様
機種:model:~
標準的:standard:~
参考な:informativeな:規範的でない
用語集:glossary:~
首尾一貫する:consistent かつ coherent な:様々な環境下で首尾一貫する
合法:legal:~
安定的:stable:~
方法:how:~
明白:obvious:~
有用性:usefulness:~
機能:function:~
機能上の:functional:~
独特:idiosyncratic:~
脚注:footnote:~
類似性:similarities:~
virtual:
中立:neutral:~
備考:notes:~
資料:resource:~
popularな::普及している
扱い:treatment:~
図表:chart:~
地域化:localization::~::ローカル化
解消-:solve:~
借用-:borrow:~
依存:dependent:~
従属:dependent:~
強勢:emphasis:~
	際しての:when interacting with
補足-:supplement:~
補足的:supplemental:~
	補足的な:supplementary
維持-:retain:~
演繹-:deduce:~
図面化-:depict:~
副次的:secondary:~


	版
	-:native
	^en:modality
	一貫でない:inconsistent
	~~注目して:with attention
	~~現時点:presently
	可用でない:unavailable
	第一の:primary
	第二の:second
	回答:answer
	-:testing facility
	rather
	正確aでない:inaccurate
	~want
	概括:briefly
	同義語:synonym
	editor
	-:interchangeable
	loosely referred
	確定されたもの:definitive
	であろう:likely
	現実の:real-world
	~~区別:distinction
	に基づいてふるまわせる用途に:for users who are interested in
	:please
	~~混成:hybrid
	基礎を成す:fundamental
	確たるもの:definitive
	対象にする:deal
	~~関係ない:no bearing
	非推奨にされ:marked as deprecated
	見よ:refer to
	~~参照
	図示:illustrate
	満たす:met／meet
	勧める:advised
	user-guided
	~~促進-:foster
	-:take care
	consider
	更に〜もある:further optional
	:disregarding
	regard
	記され:denote
	書かれた:written
	:made
	note
	see
	-:misrepresent
	生じた:cause
	~~区別する:disambiguate
	:said
	遂げられ:carried out
	~~役割を果た:serve
	できるように:permit
	writing
	-:enhancements
	称され:called
	しないようにする:prevent 〜 from being
	最終的に:eventually
	一時的:temporary
	~~場所:home
	〜に従うなら:says
	互換性:compat
	織り込む:account for

	●未分類
x:
y:
切離され:disconnectされ:切り離され
切替える:switchする:切り替える
切替えら:switchさ:切り替えら
切替わっ:switchされ:切り替わっ
移転-:shift:~

辞書検索:dictionary lookup:~
	対応-:correspond
派性-:derive:~
unload::::
覆う:coverする:~
出生-:originate:生成
寄与-:contribute:~
発話:speech::~::スピーチ
築上げる:build upする:築き上げる
付され:attachされ:~
	pair::::ペア
trap::::トラップ
digital::::デジタル
body:
	instance化:::instantiating
	~style上の:stylistic
component::::コンポーネント
一対一:one-to-one:~
一節:passage:~
回数:count:~
	16 進:hexadecimal
	10 進:decimal
整形式:well-formed::~
文脈l:contextual:文脈
数学的:mathematical:~
数的:numeric:~
数量的:numerical:~
記号:symbol:~
連続して:consecutiveに:~
remote-control:remote control:::リモコン
工場出荷:factory-reset:~
繰返n:repetition:繰り返し
中間的:intermediate:~

	~choice
	逆順:reverse
	:starting
	:place
	:follow
	示す:show
	~~指す／:point
	まだ居る:stay
	beginning
	持続-:persisting
	持ち続ける:persistent
	保ち続ける:remain
	get
	得る:gain／gaining
	:dented
	direct:
	向けられ:directed
	-:posses:
	-:held
	終わらせる:exit
	保つ:keep
	し続け:keep 〜
	様々に:vary
	resulting
	上向き:upward-pointing
	最も近く:closest match
	複数~UIkeyの同時押下げ:chording
	重複させる:duplicate
	入る:enter
	~~目立たせている／注視されている:receptivity and concentration
	首位に据える:priming
	最初へ戻る:wraps around
	~~相対的:respect
	それぞれの／対応する／対を成す／:respective
	前掲の
	-:rectangular
	-:bound
	followed
	~remaining
	~large
	-:front end
	視点:perspective
	低~level:low-level
	長い:long
	left
	-:binary
	time
	stage
	主区画:main section
	welcome
	:period
	事項:portions
	~meta
	に示されるもの:option
	~capital
	~~小文字:Latin small letter
	~small
	~~括る:bracket
	row
	色付け:color code
	命名 名前
	~~素の:bare
	部位:portion
	一部:part
	alt
	track
	working

	現在:currently
	〜時
	以前の:previous
	以前に:previously
	以前は:formerly
	次:next
	各種:various
	別物:distinct
	古い:older
	最も上層の:highest
	広範に:widely
	much
	entire
	neither
	during
	final
	沿う:along
	right-most
	bottom-most
	farthest
	いくつあっても:arbitrary
	一連の:successive
	higher
	下へ:down
	上へ:up
	lower
	both
	~~最後に:finally
	一連の:series of
	between
	それに続く:trailing
	最上段:top row
	bottom
	上から下へ:top to bottom
	~~以前の先に／prior
	:after
	around
	where
	逆:opposite
	後続な:later
	の各~属性:public attributes
	各種:various
	`CSSOM-View$r による拡張を含む:+CSSOM attributes

●●images
＠uievents/
event-inheritance｜height:200px;｜＝Graphical representation of inheritance of interfaces defined by this specification｜.svg


●●ref_data
UAAG20=副        imagedrive.github.io/TR/UAAG20/
INPUTEVENTS=副   ~/input-events-ja.html
UIEVENTSKEY=副   ~/uievents-key-ja.html

●●ref_normative

[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. ＜CSS Color Module Level 3＞. URL: https://drafts.csswg.org/css-color-3/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[DOM-Level-3-Core]
    Arnaud Le Hors; et al. ＜Document Object Model (DOM) Level 3 Core Specification＞. 28 September 2021. REC. URL: https://www.w3.org/TR/DOM-Level-3-Core/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[POINTEREVENTS4]
    Patrick Lauke; Robert Flack. ＜Pointer Events＞. URL: https://w3c.github.io/pointerevents/
[PointerLock]
    Mustaq Ahmed; Vincent Scheib. ＜Pointer Lock 2.0＞. URL: https://w3c.github.io/pointerlock/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[UIEvents-Code]
    Travis Leithead; Gary Kacmarcik. ＜UI Events KeyboardEvent code Values＞. URL: https://w3c.github.io/uievents-code/
[UIEvents-Key]
    Travis Leithead; Gary Kacmarcik. ＜UI Events KeyboardEvent key Values＞. URL: https://w3c.github.io/uievents-key/
[WebIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[DWW95]
    N. Kano. ＜Developing International Software for Windows 95 and Windows NT: A Handbook for International Software Design＞. 1995.
[Editing]
    A. Gregor. ＜HTML Editing APIs＞. URL: https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html
[HTML5]
    Ian Hickson; et al. ＜HTML5＞. 27 March 2018. REC. URL: https://www.w3.org/TR/html5/
[Input-Events]
    Johannes Wilm. ＜Input Events Level 2＞. URL: https://w3c.github.io/input-events/
[RFC20]
    V.G. Cerf. ＜ASCII format for network interchange＞. October 1969. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc20
[UAAG20]
    James Allan; et al. ＜User Agent Accessibility Guidelines (UAAG) 2.0＞. URL: https://www.w3.org/TR/2015/NOTE-UAAG20-20151215/
[UAX15]
    Ken Whistler. ＜Unicode Normalization Forms＞. 30 July 2025. Unicode Standard Annex #15. URL: https://www.unicode.org/reports/tr15/tr15-57.html
[Unicode]
    ＜The Unicode Standard＞. URL: https://www.unicode.org/versions/latest/
[US-ASCII]
    ＜Coded Character Set - 7-Bit American Standard Code for Information Interchange＞. 1986.
[WIN1252]
    ＜Windows 1252 a Coded Character Set - 8-Bit＞. URL: https://www.microsoft.com/globaldev/reference/sbcs/1252.htm
[XFORMS11]
    John Boyer. ＜XForms 1.1＞. 20 October 2009. REC. URL: https://www.w3.org/TR/xforms11/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/
[XML-Names11]
    Tim Bray; et al. ＜Namespaces in XML 1.1 (Second Edition)＞. 16 August 2006. REC. URL: https://www.w3.org/TR/xml-names11/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">UI Events</a>
を日本語に翻訳したものです
（一部の内容の日本語訳は
<a href="uievents-appendix-ja.html">別ページ</a>
に分けています）。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/uievents/
公表履歴
	https://www.w3.org/standards/history/uievents/
フィードバック
	https://github.com/w3c/uievents/issues/
論点（歴史的）
	https://lists.w3.org/Archives/Public/public-webapps/
編集
	Xiaoqian Wu (W3C)
前任編集者
	Gary Kacmarcik (Google)
	Travis Leithead (Microsoft)
	Doug Schepers (Mar 2008 - May 2011)

テスト
	https://github.com/web-platform-tests/wpt/tree/master/uievents
テスト（進行中な作業）
	https://github.com/web-platform-tests/wpt/labels/uievents

commit 履歴
	https://github.com/w3c/uievents/commits/gh-pages
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>

</script>


</head>

<body>
<header>

	<hgroup>
<h1>UI Events</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、
`DOM$r にて定義される DOM Event ~objを拡張する，~UI~Eventsを定義する。
~UI~Eventsは、
概して視覚的な~UAにより，
利用者-ヤリトリ
— ~mouseや~keyboardによる入力など —
を取扱うために実装されている。
◎
This specification defines UI Events which extend the DOM Event objects defined in [DOM]. UI Events are those typically implemented by visual user agents for handling user interaction such as mouse and keyboard input.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
`この節では、公表~時点における…^em
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="ui-events-intro">
<h2 title="Introduction">1. 序論</h2>

		<section id="dom-events-overview">
<h3 title="Overview">1.1. 概観</h3>
<p>
~UI~Eventsは、
~~主に二つの目標を念頭に設計されている。
第一の目標は、
`~event$~systemを［
`~event~listener$の登録を許容する
］よう, および［
~event~flowを~tree構造を通して述べる
］ように設計することである。
加えて，この仕様は、
~UI~controlや文書の変異†
— これら各~event~module用に定義済みな文脈l情報を含む —
を通知するための，~eventの標準的な~moduleを供する。
◎
UI Events is designed with two main goals. The first goal is the design of an event system which allows registration of event listeners and describes event flow through a tree structure. Additionally, the specification will provide standard modules of events for user interface control and document mutation notifications, including defined contextual information for each of these event modules.
</p>

<p class="trans-note">【†
変異~event~API（ `MutationEvent^I ）は、
`非推奨に$され（今や，この仕様からも除去され），
`DOM$r により `MutationObserver$I として定義し直された。
】</p>

<p>
~UI~Eventsの第二の目標は、
既存の~browserに利用されている，現在の~event~systemに共通な~~機能を供することである。
これには、
既存の［
~script, 内容
］との相互運用能を~~促進することが意図されている。
この目標には、
後方-互換性を全部的に満たすことは，期待されていない。
しかしながら，この仕様は、
アリな所では これを達成しようと試みる。
◎
The second goal of UI Events is to provide a common subset of the current event systems used in existing browsers. This is intended to foster interoperability of existing scripts and content. It is not expected that this goal will be met with full backwards compatibility. However, the specification attempts to achieve this when possible.
</p>

●＊
1.1.1. Mouse and Wheel Events

The Mouse Events and Wheel Events section of this specification have been moved to the Pointer Events specification [pointerevents4].

		</section>
		<section id="dom-events-conformance">
<h3 title="Conformance">1.2. 適合性</h3>

`ui-events-conformance^APX

		</section>
	</section>
	<section id="style-conventions">
<h3 title="Stylistic Conventions">2. ~style上の規約</h3>
<p>
この仕様では、
次の表記が用いられる
【！`Proposed W3C Specification Conventions＠http://www.w3.org/People/Schepers/spec-conventions.html$ に従う】：
◎
This specification follows the Proposed W3C Specification Conventions, with the following supplemental additions:
</p>

<div>

<table><thead>
<tr><th>表記~例
<th>意味
<tbody>

<tr><td>`↓^cap, `=^cap, `Q^cap
<td>~UIkey上に印字される `~UIkey~cap＠#key-legends$。
この表記は、
生成される `KeyboardEvent!I の `key$m, `code$m 値には関わらない，利用者~視点の~UIkeyを指すときに利用される。

<tr><td>`ア^kGl, `~~漢字^kGl
<td>文字／文字~並びを表現している~glyph並び

<tr><td>`003D^U
<td>~Unicode文字

<tr><td>`ArrowDown$kY, `=^kY, `q^kY, `Q^kY
<td>~UIkeyを押して生成される~UIkey値
（すなわち、
`KeyboardEvent^I の `key$m 値）
の名前

<tr><td>`ArrowDown$kC, `Equal$kC, `KeyQ$kC
<td>物理的な~UIkeyに結付けられた~UIkey~code
（すなわち、
`KeyboardEvent^I の `code$m 値）
の名前
</table>

◎
• The key cap printed on a key is shown as ↓, = or Q. This is used to refer to a key from the user’s perspective without regard for the key and code values in the generated KeyboardEvent.
• Glyphs representing character are shown as: "𣧂".
• Unicode character encodings are shown as: U+003d.
• Names of key values generated by a key press (i.e., the value of KeyboardEvent.key) are shown as: "ArrowDown", "=", "q" or "Q".
• Names of key codes associated with the physical keys (i.e., the value of KeyboardEvent.code) are shown as: "ArrowDown", "Equal" or "KeyQ".
</div>

<p>
加えて，この仕様における ある種の用語は、
特定0の意味で利用される。
語 “実装”は、
~browser, 内容~著作~tool, その他，この仕様を実装する`~UA$を~~指す。
語 内容~作者は、
~interface, ~method, 属性, ~event, その他，この仕様にて述べる他の特能を利用する~scriptや~codeを書いて，~Web~appを作る者を~~指す。
利用者とは，ある実装の下で それらの~Web~appを利用する者を~~指す。
◎
In addition, certain terms are used in this specification with particular meanings. The term "implementation" applies to a browser, content authoring tool, or other user agent that implements this specification, while a content author is a person who writes script or code that takes advantage of the interfaces, methods, attributes, events, and other features described in this specification in order to make Web applications, and a user is the person who uses those Web applications in an implementation.
◎
And finally:
• This is a note.
• This is an open issue.
• This is a warning.
interface Example {
    // This is an IDL definition.
}
</p>

	</section>
	<section id="event-interfaces">
<h2 title="Basic Event Interfaces">3. 基本~event~interface</h2>

<p>
基本~event~interfaceは `DOM$r にて定義され，~UI~Eventsの基礎を成す。
実装は、
以下に挙げる基本~event~interfaceを常に~supportするモノトスル：
◎
The basic event interfaces defined in [DOM] are fundamental to UI Events. These basic event interfaces MUST always be supported by the implementation:
</p>

<ul>
	<li>
`Event$I ~interface, および その［
定数, ~method, 属性
］のうち次に挙げるもの
⇒＃
`NONE$m
`CAPTURING_PHASE$m,
`AT_TARGET$m,
`BUBBLING_PHASE$m,
`type$m,
`target$m,
`currentTarget$m,
`eventPhase$m,
`bubbles$m,
`cancelable$m,
`composed$m,
`timeStamp$m,
`defaultPrevented$m,
`isTrusted$m,
`stopPropagation()$m,
`stopImmediatePropagation()$m,
`preventDefault()$m,
`initEvent()$m
◎
The Event interface and its following constants, methods and attributes:
• NONE constant
• CAPTURING_PHASE constant
• AT_TARGET constant
• BUBBLING_PHASE constant
• type attribute
• target attribute
• currentTarget attribute
• eventPhase attribute
• bubbles attribute
• cancelable attribute
• composed attribute
• timeStamp attribute
• defaultPrevented attribute
• isTrusted attribute
• stopPropagation() method
• stopImmediatePropagation() method
• preventDefault() method
• initEvent() method
</li>
	<li>
`CustomEvent$I ~interface, および その
⇒＃
`initCustomEvent()$m ~method,
`detail＠~DOM4#dom-customevent-detail$m 属性
◎
The CustomEvent interface and its following method and attribute:
• initCustomEvent() method
• detail attribute
</li>
	<li>
`EventTarget$I ~interface, および その~methodのうち次に挙げるもの
⇒＃
`addeventlistener()$m,
`removeeventlistener()$m,
`dispatchEvent()$m
◎
The EventTarget interface and its following methods:
• addEventListener() method
• removeEventListener() method
• dispatchEvent() method
</li>
	<li>
`EventListener$I ~interface, および その
`handleEvent()$m ~method
◎
The EventListener interface and its handleEvent() method
</li>
	<li>
`Document$I ~interfaceの `createEvent()$m ~method
◎
The Document interface’s createEvent() method
</li>
</ul>

<p>
この仕様に定義される各種~event型【用の~interface】は、
これらの基本~interfaceいずれかから派性し，そのすべての［
属性, ~method, 定数
］を継承するモノトスル。
◎
The event types defined in this specification derive from these basic interfaces, and MUST inherit all of the attributes, methods, and constants of the interfaces they derive from.
</p>

<p>
この仕様に述べる各種~interfaceの継承~構造を，次の図表に述べる：
◎
The following chart describes the inheritance structure of the interfaces described in this specification.
</p>

<figure id="figure-event-inheritance">
<figcaption id="_dgm-event-inheritance">
この仕様により定義される~interfaceの継承を成す~graphicな表現
◎
Graphical representation of inheritance of interfaces defined by this specification
</figcaption></figure>

		<section id="event-types-list">
<h3 title="List of Event Types">3.1. 各種~event型の~list</h3>

<p>
各~eventには、
`~event型^emと称される，ある型が結付けられ、
~event~obj上の `type$m 属性にて可用にするモノトスル。
~event型は `DOMString^c 型でなければナラナイ。
◎
Each event MUST be associated with a type, called event type and available as the type attribute on the event object. The event type MUST be of type DOMString.
</p>

<p>
実装は、［
~DOM~supportの~level／
表示~用に利用される装置（例： ~screen）／
ヤリトリ用に利用される装置（例： ~mouse, ~keyboard, ~touch~screen, ~voice）
］に依存して，これらの~event型を生成し得る。
`XML$r や `HTML$r【！HTML5】 の応用に利用されるときは、
その言語の仕様は，~event型に結付けられる意味論と視野（特に，アリな`~target$）を制約し得る／してもヨイ。
［
それらの制約／この文書にて定義されない~event型
］を見出すには、
利用される言語を定義している仕様を見よ。
◎
Depending on the level of DOM support, or the devices used for display (e.g., screen) or interaction (e.g., mouse, keyboard, touch screen, or voice), these event types can be generated by the implementation. When used with an [XML] or [HTML5] application, the specifications of those languages MAY restrict the semantics and scope (in particular the possible event targets) associated with an event type. Refer to the specification defining the language used in order to find those restrictions or to find event types that are not defined in this document.
</p>

<p class="trans-note">【
参考：
`DOM Event Viewers＠https://domeventviewer.com/$en にて、
この仕様に定義される各種~event型の挙動を試せる。
】</p>

<p>
次の表tに，この仕様に述べる各種~event型の参考な要約を供する：
◎
The following table provides an informative summary of the event types described in this specification.
</p>

<table id="_event-list" class="grid-table"><thead>
<tr><th>~event型
<th>同期c？
<th>浮上-？
<th>`~trusted$な~target
<th>~DOM~interface
<th>取消~可否
<th>`既定~動作$（空欄は動作なし）
<tbody>

<tr><td>`abort$et
<td>あり
<td>しない
<td>`Window$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`beforeinput$et
<td>あり
<td>する
<td>`Element$I
<td>`InputEvent$I
<td>可
<td>
~DOM要素を更新する
◎
Update the DOM element

<tr><td>`blur$et
<td>あり
<td>しない
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`compositionstart$et
<td>あり
<td>する
<td>`Element$I
<td>`CompositionEvent$I
<td>可
<td>
`~text組成~system$の候補~窓を示す
◎
Show a text composition system candidate window

<tr><td>`compositionupdate$et
<td>あり
<td>する
<td>`Element$I
<td>`CompositionEvent$I
<td>不可
<td>

<tr><td>`compositionend$et
<td>あり
<td>する
<td>`Element$I
<td>`CompositionEvent$I
<td>不可
<td>

<tr><td>`error$et
<td>なし
<td>しない
<td>`Window$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`focus$et
<td>あり
<td>しない
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`focusin$et
<td>あり
<td>する
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`focusout$et
<td>あり
<td>する
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`input$et
<td>あり
<td>する
<td>`Element$I
<td>`InputEvent$I
<td>不可
<td>

<tr><td>`keydown$et
<td>あり
<td>する
<td>`Element$I
<td>`KeyboardEvent$I
<td>可
<td>
文脈依存
— 次に挙げるいずれかを誘発する
⇒＃
`beforeinput$et, `input$et ~event／
`~text組成~system$を立上げる／
`blur$et, `focus$et ~event／
`keypress$et ~event（~supportされるならば）／
`作動化の挙動$／
その他の~event
◎
Varies: trigger beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other events

<tr><td>`keyup$et
<td>あり
<td>する
<td>`Element$I
<td>`KeyboardEvent$I
<td>可
<td>

<tr><td>`load$et
<td>なし
<td>しない
<td>`Window$I, `Document$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`select$et
<td>あり
<td>する
<td>
<td>`Event$I
<td>不可
<td>

<tr><td>`unload$et
<td>あり
<td>しない
<td>`Window$I, `Document$I, `Element$I
<td>`Event$I
<td>不可
<td>
</table>

<p>
この仕様にて非推奨にされた~eventたちが成す~listは、
`§ 旧来の~event型＠~UIEVENTS-A#legacy-event-types$
を見よ。
◎
For a list of events which are deprecated in this specification, see the Legacy Event Types appendix at the end of this document.
</p>

<p class="example">
上の表tを解釈する仕方の一つは：
`load$et ~eventは、［
その~event用に `Element$I ~nodeに付された`~event~listener$
］を［
`捕捉-相$, `~target相$
］にて誘発することになる。
この~eventは`取消~可能$でない。
`load$et ~event用の`~event~listener$は、［
`Window$I, `Document$I, `Element$I
］以外の~nodeに付されても，`浮上-相$のみに付されても誘発されない。
◎
The following is one way to interpret the above tables: the load event will trigger event listeners attached on Element nodes for that event and on the capture and target phases. This event is not cancelable. If an event listener for the load event is attached to a node other than Window, Document, or Element nodes, or if it is attached to the bubbling phase only, this event listener would not be triggered.
</p>

<p class="note">注記：
上の表tを そこに挙げられた~event型~用に確たるものとして解釈しないこと。
例えば `load$et ~eventは、
`XMLHttpRequest$I などの他の仕様にも利用される。
同様に，`~trusted$でない~eventは、
`EventTarget$I も実装する<strong>どの~obj</strong>にも，それ用の~listenerへ `dispatchEvent()$m を利用して配送できる。
◎
Don’t interpret the above tables as definitive for the listed event types. For example, the load event is used in other specifications, for example, in XMLHttpRequest. Similarly, dispatchEvent() can be used to dispatch untrusted events to listeners on any object that also implements EventTarget.
</p>

<p class="note">注記：
上に述べた各~event型に結付けられる~event~objは、
追加的な文脈~情報を包含する
— 更なる情報は、
~DOM~interfaceの記述を見よ。
◎
The event objects associated with the event types described above contain additional context information--refer to the description of the DOM interfaces for further information.
</p>

		</section>
		<section id="_event-definition-table">
<h3>~event定義~表t</h3>

<p class="trans-note">【
この節は、
この訳による補完。
】</p>

<p>
この仕様に現れる，各種`~event型$の定義は、
次のような表tとして与えられる：
</p>

◎イ型
この欄には、
当の~event型の名前が記される
（例： `click^et ）。
この名前が、
~eventの `type$m 属性の値になる。
◎界面
この欄には、
この型の~event~objが実装する~interfaceが示される
（例： `KeyboardEvent$I ）。
◎同期
この欄には、
この型の~eventが他の~eventと同期的に生じ得るならば “あり”／
他の場合は “なし” と記される。
◎浮上
この欄には、
この型の~eventが `浮上-$するならば “する” ／
他の場合は “しない” と記される。
◎標的
この欄には、
この型の~eventの`~target$になり得る~objが挙げられる
（例： `Element$I ）。
◎取消
この欄には、
この型の~eventが`取消~可能$ならば “可” ／
他の場合は “不可” と記される。
◎構
`composed$m 属性に関係する
— 単に［
“Yes” ／ “No”
］と記されているなら その値は［
~T ／ ~F
］になると見受けられる —
が、
実際の定義は不明
（ “Yes”, “No” の他にも とり得る値や何らかの記述があり得るかなど）。
この欄が無い~event型もあり、
その不在が何を意味するのかも不明
（ “No” を意味するのか 単に策定されていないのか判別できない）。

◎既定動作
この欄には、
この型の~eventに結付けられ得る`既定~動作$が挙げられる
（例：~pageを~scrollする）。
◎文脈
この欄には、
この型の~eventが実装する（~interface欄に挙げられている）~interfaceの各種~memberが，どのような値に初期化されるかが述べられる。
◎表終

<p>
この表tが適用されるのは、
`~trusted$な~eventに限られる
（~scriptにより配送される~eventには、
適用されない）。
</p>

<p>
以下に挙げる用語は、
この仕様が更新される前にあった記述の（かなり端折った）要約であり，
規範的な定義ではない：
</p>
<ul>
	<li>
`~UA$により
— 通例的に，利用者-ヤリトリに呼応して —
生成される~eventは、
`~trusted@
な~eventと呼ばれる。
対して，~scriptにより
（ `dispatchEvent()$m ~methodを介して）
配送される~eventは、
~trustedでない~eventになる
（合成な~eventとも称される）。
~trustedか否かは、
~eventの `isTrusted$m 属性に反映される。
</li>
	<li>
~eventが
`浮上-@
（ `bubble^en ）するとは、
当の~eventが`~target相$に伝播した後も，先祖へ遡るよう伝播し続けることを意味する。
その可否は~eventの `bubbles$m 属性に反映される。
</li>
	<li>
~eventが
`取消~可能@
（ `cancelable^en ）であるとは、
`preventDefault()$m ~methodを~callすることで，
`既定~動作$を取消せることを意味する。
その可否は、
~eventの `cancelable$m 属性に反映される。
</li>
</ul>

		</section>
		<section id="events-uievents">
<h3 title="User Interface Events">3.2. ~UI~event</h3>

<p>
~UI~event~moduleは、
~UIや文書の操作に結付けられた，基本的な~event型を包含する。
◎
The User Interface event module contains basic event types associated with user interfaces and document manipulation.
</p>

			<section id="interface-uievent">
<h4 title="Interface UIEvent">3.2.1. `UIEvent^I ~interface</h4>

<p class="intro-dom">
DOM Level 2 にて導入された。
◎
Introduced in DOM Level 2
</p>

<p>
`UIEvent^I ~interfaceは、
~UI~eventに特有な文脈l情報を供する。
◎
The UIEvent interface provides specific contextual information associated with User Interface events.
</p>

<p>
`UIEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `UIEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the UIEvent interface, use the UIEvent constructor, passing an optional UIEventInit dictionary.
</p>

<p class="note">注記：
新たに定義される~eventは、
単に~UIに関係するだけで， `UIEvent$I ~interfaceを継承する必要はない。
`UIEventInit$I の~memberのみ継承することでも，イミを成す。
◎
For newly defined events, you don’t have to inherit UIEvent interface just because they are related to user interface. Inherit only when members of UIEventInit make sense to those events. 
</p>

				<section id="idl-uievent">
<h5>3.2.1.1. `UIEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `UIEvent@I : `Event$I {
    `UIEvent@mc(`DOMString$ %type, optional `UIEventInit$I %eventInitDict = {});

    readonly attribute `Window$I? `view$m;
    readonly attribute `long$ `detail$m;
};
</pre>

<dl class="idl-def">

<!-- ＊
UIEvent . view 等々
 -->

	<dt>
`view@m
◎
UIEvent . view
</dt>
	<dd>
この属性は、
~eventがどの `Window$I から生成されたかを識別する。
◎
The view attribute identifies the Window from which the event was generated.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>
`detail@m
◎
UIEvent . detail
</dt>
	<dd>
この属性には、
~eventの型に依存して， `Event$I についての一部の詳細~情報が指定される。
◎
Specifies some detail information about the Event, depending on the type of event.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>
</dl>

				</section>
				<section id="idl-uieventinit">
<h5>3.2.1.2. `UIEventInit^I</h5>

<pre class="idl">
dictionary `UIEventInit@I : `EventInit$I {
    `Window$I? `view$m = null;
    `long$ `detail$m = 0;
};
</pre>

<dl class="idl-def">
	<dt>
`view@m
◎
UIEventInit . view
</dt>
	<dd>
この~memberは、
この~eventの配送-先の大域~環境の~windowになるベキである。
この~eventが要素に配送されるなら、
その要素の`~node文書$を包含する~windowに設定されるベキである。
◎
Should be initialized to the Window object of the global environment in which this event will be dispatched. If this event will be dispatched to an element, the view property should be set to the Window object containing the element’s ownerDocument.
</dd>

	<dt>
`detail@m
◎
UIEventInit . detail
</dt>
	<dd>
この値は、
~appに特有な整数を与える。
◎
This value is initialized to a number that is application-specific.
</dd>
</dl>

				</section>
			</section>
			<section id="uievent-algorithms">
<h4 title="UIEvent Algorithms">3.2.2. `UIEvent^I 用の~algo</h4>

<div class="algo">
<p>
`~UIEventを初期化する@
~algoは、
所与の
⇒＃
`UIEvent$I %~event,
文字列 %~event型,
`EventTarget$I %~event~target,
真偽値 %浮上するか,
真偽値 %取消~可能か
◎終
に対し：
◎
3.2.2.1. initialize a UIEvent
◎
Input
• event, the UIEvent to initialize
• eventType, a DOMString containing the event type
• eventTarget, the EventTarget of the event
• bubbles, true if this event bubbles
• cancelable, true if this event is cancelable
Output
• None
</p>
<ol>
	<li>
<p>
基底 `Event$I の各~属性を初期化する：
◎
Initialize the base Event attributes:
</p>
		<ol>
			<li>
`~eventを初期化する$( %~event, %~event型, %浮上するか, %取消~可能か )
◎
Initialize an Event with event, eventType, bubbles and cancelable
</li>
			<li>
%~event の`~target$ev【！`target$m】 ~SET %~event~target
◎
Set event.target = eventTarget
</li>
		</ol>
	</li>
	<li>
<p>
`UIEvent$I の各~属性を初期化する
⇒
%~event の
⇒＃
`view$m ~SET %~event~target の`~node文書$の`~window$【！ `Window$I ~obj】,
`detail$m ~SET 0,
`which$m ~SET 0
</p>
<p>
（ `which^m は、
歴史的な属性であり，
`MouseEvent$I, `KeyboardEvent$I どちらにも利用される。）
</p>
◎
Initialize the following public attributes:
• Set event.view = the eventTarget’s node document’s Window object
• Set event.detail = 0
◎
Initialize the following historical attributes:
• Set event.which = 0 (used by both MouseEvent and KeyboardEvent)
</li>
</ol>
</div>

			</section>
			<section id="events-uievent-types">
<h4 title="UIEvent Types">3.2.3. 各種~UI~event型</h4>

<p>
以下に，各種~UI~event型を挙げる。
これらの~eventのうち一部のものは、［
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
］~interfaceを利用する。
詳細は各~eventに。
◎
The User Interface event types are listed below. Some of these events use the UIEvent interface if generated from a user interface, but the Event interface otherwise, as detailed in each event.
</p>

				<section id="event-type-load">
<h5>3.2.3.1. `load^et</h5>

<div>
◎イ型 `load@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 なし
◎浮上 しない
◎標的 `Window$I, `Document$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
【！contained】資源を読込んだ【！common】~obj
</li>
</ul>
◎表終

◎
Type 	load
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Async
Bubbles 	No
Trusted Targets 	Window, Document, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : common object whose contained resources have loaded
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
~DOM実装が資源（文書など）, および
すべての従属~資源（画像, ~stylesheet, ~scriptなど）の読込ngを完遂した
］とき，この~eventを発火するモノトスル。
従属~資源の読込nに失敗した場合でも、
それを読込んだ資源が~DOMを介して依然として~access可能である場合には，
この~eventの発火は止めないモノトスル。
実装が，この~event型を発火するときには、
少なくとも `Document$I ~node上に配送することが要求される。
◎
A user agent MUST dispatch this event when the DOM implementation finishes loading the resource (such as the document) and any dependent resources (such as images, style sheets, or scripts). Dependent resources that fail to load MUST NOT prevent this event from firing if the resource that loaded them is still accessible via the DOM. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.
</p>

<p class="note">注記：
旧来の理由から、
~HTML実装においては［
文書の内側の資源（例えば画像）用の `load$et ~eventの伝播~経路
］は，`~window$を含まない。
詳細は `HTML$r【！HTML5】 を見よ。
◎
For legacy reasons, load events for resources inside the document (e.g., images) do not include the Window in the propagation path in HTML implementations. See [HTML5] for more information.
</p>

				</section>
				<section id="event-type-unload">
<h5>3.2.3.2. `unload^et</h5>

<div>
◎イ型 `unload@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Document$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
【！contained】資源が除去された【！common】~obj
</li>
</ul>
◎表終

◎
Type 	unload
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Document, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : common object whose contained resources have been removed
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
~DOM実装が，環境から資源（文書など）や 従属~資源（画像, ~stylesheet, ~scriptなど）を除去した
］とき，この~eventを発火するモノトスル。
文書の~unloadは，この~event型が配送された後になるモノトスル。
実装が，この~event型を配送するときには、
少なくとも `Document$I ~node上に配送することが要求される。
◎
A user agent MUST dispatch this event when the DOM Implementation removes from the environment the resource (such as the document) or any dependent resources (such as images, style sheets, scripts). The document MUST be unloaded after the dispatch of this event type. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.
</p>

				</section>
				<section id="event-type-abort">
<h5>3.2.3.3. `abort^et</h5>

<div>
◎イ型 `abort@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>

<ul>
	<li>
`target$m：
資源の読込ngが~error以外により停止された要素
</li>
</ul>
◎表終

◎
Type 	abort
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : element whose resources have been stopped from loading without error
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
資源の読込ngがまだ進捗~中に，利用者が取消したなどにより中止された
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when the loading of a resource has been aborted, such as by a user canceling the load while it is still in progress.
</p>

				</section>
				<section id="event-type-error">
<h5>3.2.3.4. `error^et</h5>

<div>
◎イ型 `error@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 なし
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>

<ul>
	<li>
`target$m：
資源の読込ngが~errorにより停止された要素
</li>
</ul>
◎表終

◎
Type 	error
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Async
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : element whose resources have been stopped from loading due to error
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
資源の読込nに失敗した, または読込まれたが その意味論に則って解釈-できない
（妥当でない画像, ~script実行~error, 整形式でない~XMLなど）
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when a resource failed to load, or has been loaded but cannot be interpreted according to its semantics, such as an invalid image, a script execution error, or non-well-formed XML.
</p>

				</section>
				<section id="event-type-select">
<h5>3.2.3.5. `select^et</h5>

<div>
◎イ型 `select@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
~text内容が選択された要素
</li>
</ul>
◎表終

◎
Type 	select
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : element whose text content has been selected
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
利用者が一部の~textを選択した
］とき，この~eventを発火するモノトスル。
この~eventは、
選択が生じた後に配送される。
◎
A user agent MUST dispatch this event when a user selects some text. This event is dispatched after the selection has occurred.
</p>

<div class="p">
<p>
この仕様は、
選択された~textへ~accessするための文脈l情報を供さない。
`~host言語$は、
適用-可能な所では，次のための規則を定義するベキである：
</p>
<ul>
	<li>
利用者が内容を選択できる方法
（国際的~言語~規約も考慮して）
</li>
	<li>
`select$et ~eventがどこで発火されたか
</li>
	<li>
内容~作者がその選択された内容に~accessできる方法
</li>
</ul>
◎
This specification does not provide contextual information to access the selected text. Where applicable, a host language SHOULD define rules for how a user MAY select content (with consideration for international language conventions), at what point the select event is dispatched, and how a content author MAY access the user-selected content.
</div>

<p class="note">注記：
利用者により選択された内容に~accessするためには、
内容~作者は，`~host言語$に備わる能力を利用することになる
— 
HTML Editing APIs `Editing$r の
`Document.getSelection()$m ~methodなど。
◎
In order to access to user-selected content, content authors will use native capabilities of the host languages, such as the Document.getSelection() method of the HTML Editing APIs [Editing].
</p>

<p class="note">注記：
`select$et ~eventは、
どの言語のどの要素でも可用になるとは限らない。
例えば `HTML$r【！HTML5】 においては、
`select$et ~eventが配送され得るのは，［
`input$e ／ `textarea$e
］要素に限られている。
実装は、［
~form~controlの外側の~text選択,
~SVG内などの 画像や~markupの選択
］なども含め，適切と判断される文脈にて `select$et ~eventを配送できる。
◎
The select event might not be available for all elements in all languages. For example, in [HTML5], select events can be dispatched only on form input and textarea elements. Implementations can dispatch select events in any context deemed appropriate, including text selections outside of form controls, or image or markup selections such as in SVG.
</p>

				</section>
			</section>
			<section id="_common-UI-event-context">
<h4>各種~UI~eventに共通な文脈~情報</h4>

集約簡略化

<p>
多くの~UI~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`UIEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`view$m</dt>
			<dd>
`Window$I ~obj
◎
UIEvent.view : Window
</dd>
			<dt>`detail$m</dt>
			<dd>
0
◎
UIEvent.detail : 0
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-focusevent">
<h3 title="Focus Events">3.3. ~focus~event</h3>

<p class="note">注記：
この節の~interface, および それに結付けられた［
~event型,
`~focus~event序列＠#events-focusevent-event-order$
］は、［
`~UA~accessibility指針 2.0＠~UAAG20$cite
`UAAG20$r に定義される概念と指針
］に則って，特に［
`~focusの仕組み＠~UAAG20#gl-focus-mechanism$, および
`~focusの用語集＠~UAAG20#def-focus$
に定義される用語
］に~~注目して設計されている。
◎
This interface and its associated event types and § 3.3.2 Focus Event Order were designed in accordance to the concepts and guidelines defined in User Agent Accessibility Guidelines 2.0 [UAAG20], with particular attention on the focus mechanism and the terms defined in the glossary entry for focus.
</p>

			<section id="interface-focusevent">
<h4 title="Interface FocusEvent">3.3.1. `FocusEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`FocusEvent^I ~interfaceは、
~focus~eventに特有な文脈l情報を供する。
◎
The FocusEvent interface provides specific contextual information associated with Focus events.
</p>

<p>
`FocusEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `FocusEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the FocusEvent interface, use the FocusEvent constructor, passing an optional FocusEventInit dictionary.
</p>

				<section id="idl-focusevent">
<h5>3.3.1.1. `FocusEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `FocusEvent@I : `UIEvent$I {
    `FocusEvent@mc(`DOMString$ %type, optional `FocusEventInit$I %eventInitDict = {});
    readonly attribute `EventTarget$I? `relatedTarget$m;
};
</pre>

<dl class="idl-def">
	<dt>
`relatedTarget@m
◎
FocusEvent . relatedTarget
</dt>
	<dd>
~focus~eventに関係する副次的な `EventTarget$I を識別するために利用され、
~eventの型に依存する。
◎
Used to identify a secondary EventTarget related to a Focus event, depending on the type of event.
</dd>
	<dd>
~securityの理由から、
入子な関係にある閲覧~文脈どうしで~focusが~~移動したときには【！tabbing into or out 】，
この属性の値【！関連な EventTarget 】は ~NULL になるベキである。
◎
For security reasons with nested browsing contexts, when tabbing into or out of a nested context, the relevant EventTarget SHOULD be null.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>
</dl>

				</section>
				<section id="idl-focuseventinit">
<h5>3.3.1.2. `FocusEventInit^I</h5>

<pre class="idl">
dictionary `FocusEventInit@I : `UIEventInit$I {
    `EventTarget$I? `relatedTarget@m = null;
};
</pre>

<p>
この辞書の各~memberは、
`FocusEventInit!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
FocusEventInit . relatedTarget
• The relatedTarget should be initialized to the element losing focus (in the case of a focus or focusin event) or the element gaining focus (in the case of a blur or focusout event).
</p>

				</section>
			</section>
			<section id="events-focusevent-event-order">
<h4 title="Focus Event Order">3.3.2. ~focus~event序列</h4>
<p>
この仕様にて定義される~focus~eventは、
相互相対順序の下で生じる。
被focus要素が無い状態から要素 %A, 要素 %B の順に~focusが移転されたときの代表的な~event連列を次に示す：
◎
The focus events defined in this specification occur in a set order relative to one another. The following is the typical sequence of events when a focus is shifted between elements (this order assumes that no element is initially focused):
</p>

<table class="event-sequence-table"><thead>

<tr><th>~event型
<th>備考
<tbody>

<tr><td>
<td>
<td><em>
利用者が~focusを移転した
</em>
◎
User shifts focus
<tr><td>1.
<td>`focus$et
<td>
%A が~focusを受取った直後に送信される
◎
Sent after first target element receives focus

<tr><td>2.
<td>`focusin$et
<td>
`focus$et ~eventに後続する
◎
Follows the focus event

<tr><td>
<td>
<td><em>
利用者が~focusを移転した
</em>
◎
User shifts focus

<tr><td>3.
<td>`blur$et
<td>
%A が~focusを失った直後に送信される
◎
Sent after first target element loses focus

<tr><td>4.
<td>`focusout$et
<td>
`blur$et ~eventに後続する
◎
Follows the blur event

<tr><td>5.
<td>`focus$et
<td>
%B が~focusを受取った直後に送信される
◎
Sent after second target element receives focus

<tr><td>6.
<td>`focusin$et
<td>
`focus$et ~eventに後続する
◎
Follows the focus event
</table>

<p class="note">注記：
この仕様は、
`focus()^m や `blur()^m
などの~methodに際しての~focus~eventの挙動は定義しない。
そのような挙動については、
それらの~methodを定義している，関連な仕様を見よ。
◎
This specification does not define the behavior of focus events when interacting with methods such as focus() or blur(). See the relevant specifications where those methods are defined for such behavior.
</p>

			</section>
			<section id="events-focusevent-doc-focus">
<h4 title="Document Focus and Focus Context">3.3.3. 文書~focusと~focus文脈</h4>

<p>
この~event~moduleは、
文書`~focus$の変化を通知するための~event型を含む。
この論点に関連な，3 種の別個な~focus文脈がある：
◎
This event module includes event types for notification of changes in document focus. There are three distinct focus contexts that are relevant to this discussion:
</p>
<ul>
	<li>
~OS~focus文脈
⇒
この文脈の下では、
~computer上で現在~稼働している多数の~appのうち一つが，~focusを持ち得るとされる。
~browserは、
その一つを成し得る。
◎
The operating system focus context which MAY be on one of many different applications currently running on the computer. One of these applications with focus can be a browser.
</li>
	<li>
~app~focus文脈
⇒
~browserが~focusを得ているときが，この文脈である。
この文脈の下では、
利用者は、
~browserの各種~UI~field
（例： ~URL~bar, 探索~field, 等々）
間で~focusを切替えることもある
（~tab~UIkeyなどにより）。
~UItab内に示されている文書も、
これらの~UI~fieldの一つを成し得る。
◎
When the browser has focus, the user can switch (such as with the tab key) the application focus context among the different browser user interface fields (e.g., the Web site location bar, a search field, etc.). One of these user interface fields can be the document being shown in a tab.
</li>
	<li>
文書~focus文脈
⇒
文書~自身が~focusを得ているときが、
この文脈である。
この文脈の下では、
文書~内で~focus可能な要素が~focusを得ることができる。
◎
When the document itself has focus, the document focus context can be set to any of the focusable elements in the document.
</li>
</ul>

<p>
この仕様にて定義される各種~event型は、
もっぱら文書~focusのみを対象にする。
~eventの詳細~にて識別される`~target$は、
~window内の文書またその一部に限るモノトスル
— ~focus文脈が別の文脈へ切替わったときでも，決して ~browserや~OSの一部にはならない。
◎
The event types defined in this specification deal exclusively with document focus, and the event target identified in the event details MUST only be part of the document or documents in the window, never a part of the browser or operating system, even when switching from one focus context to another.
</p>

<div class="p">
<p>
通常は、
文書は常に被focus要素を持ち
（他に無ければ，`文書~要素$が被focus要素になる）、
また，`~focus環$を持ち続ける。
~focus文脈が切替わっても，文書における現在の被focus要素, および文書の`~focus環$は、
通常は現在の状態を保ち続ける。
例えば，文書にて~focus可能な要素が 3 個あって，
2 個目の要素が~focusされている下で、
利用者が~OS~focusを別の~appに変更してから また~browserに戻ったとき、
2 個目の要素は，文書の中で依然として被focusのままにされ、
~tabbingなどで~focusが切り替えられたときは，
3 個目の要素に~focusが移ることになる。
</p>

<p>
`~host言語$は、
次を定義してもヨイ：
</p>

<ul>
	<li>
どの要素が~focusを受取れるか
</li>
	<li>
要素はどの条件の下で~focusを受取るか
</li>
	<li>
~focusはどの手段で変更できるか
</li>
	<li>
~focusはどの順序で変化するか
</li>
</ul>

<p >
例えば，
要素に~pointerが接触するだけで要素が~focusを得ることもあれば、
~clickを要する状況下もある。
要素には、
まったく~focusされ得ないものもあれば、
特別な手段（要素~上を~clickするなど）を通してなら~focusできるが，~tabbingでは~focusできないものもある。
文書は、
複数の`~focus環$を包含してもヨイ。
</p>

<p>
他の仕様は、
この仕様にて述べるものより複階的な~focus~modelを定義してもヨイ
— 複数の要素が，現在の~focusを得られるようにすることも含め。
</p>

◎
Normally, a document always has a focused element (even if it is the document element itself) and a persistent focus ring. When switching between focus contexts, the document’s currently focused element and focus ring normally remain in their current state. For example, if a document has three focusable elements, with the second element focused, when a user changes operating system focus to another application and then back to the browser, the second element will still be focused within the document, and tabbing will change the focus to the third element. A host language MAY define specific elements which might receive focus, the conditions under which an element MAY receive focus, the means by which focus MAY be changed, and the order in which the focus changes. For example, in some cases an element might be given focus by moving a pointer over it, while other circumstances might require a mouse click. Some elements might not be focusable at all, and some might be focusable only by special means (clicking on the element), but not by tabbing to it. Documents MAY contain multiple focus rings. Other specifications MAY define a more complex focus model than is described in this specification, including allowing multiple elements to have the current focus.
</div>

			</section>
			<section id="events-focus-types">
<h4 title="Focus Event Types">3.3.4. 各種~focus~event型</h4>

<p>
以下に，各種~focus~event型を挙げる：
◎
The Focus event types are listed below.
</p>

				<section id="event-type-blur">
<h5>3.3.4.1. `blur^et</h5>

<div>
◎イ型 `blur@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
~focusを失った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
新たに~focusを受取っている`~event~target$。
</li>
</ul>
◎表終

◎
Type 	blur
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target losing focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target receiving focus.
</div>

<p>
~UAは、
要素が~focusを失った直後に，
当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`focusout$et に類似するが，浮上しない。
◎
A user agent MUST dispatch this event when an event target loses focus. The focus MUST be taken from the element before the dispatch of this event type. This event type is similar to focusout, but does not bubble.
</p>

				</section>
				<section id="event-type-focus">
<h5>3.3.4.2. `focus^et</h5>

<div>
◎イ型 `focus@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
新たに~focusを受取った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
~focusを失っている`~event~target$（もしあれば）。
</li>
</ul>
◎表終

◎
Type 	focus
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target receiving focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target losing focus (if any).
</div>

<p>
~UAは、
要素が~focusを受取った直後に，
当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`focusin$et に類似するが，浮上しない。
◎
A user agent MUST dispatch this event when an event target receives focus. The focus MUST be given to the element before the dispatch of this event type. This event type is similar to focusin, but does not bubble.
</p>

				</section>
				<section id="event-type-focusin">
<h5>3.3.4.3. `focusin^et</h5>

<div>
◎イ型 `focusin@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 する
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
新たに~focusを受取った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
~focusを失っている`~event~target$（もしあれば）。
</li>
</ul>
◎表終

◎
Type 	focusin
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target receiving focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target losing focus (if any).
</div>

<p>
~UAは、［
要素が~focusを受取った直後
］かつ［
当の要素に向けて `focus$et ~eventを配送した後
］に，当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`focus$et に類似するが，浮上する。
◎
A user agent MUST dispatch this event when an event target receives focus. The event target MUST be the element which received focus. The focus event MUST fire before the dispatch of this event type. This event type is similar to focus, but does bubble.
</p>

				</section>
				<section id="event-type-focusout">
<h5>3.3.4.4. `focusout^et</h5>

<div>
◎イ型 `focusout@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 する
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~UI~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`target$m：
~focusを失った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
新たに~focusを受取っている`~event~target$。
</li>
</ul>
◎表終

◎
Type 	focusout
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target losing focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target receiving focus.
</div>

<p>
~UAは、［
要素が~focusを失った直後
］かつ［
当の要素に向けて `blur$et ~eventを配送した後
］に，
当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`blur$et に類似するが，浮上する。
◎
A user agent MUST dispatch this event when an event target loses focus. The event target MUST be the element which lost focus. The blur event MUST fire before the dispatch of this event type. This event type is similar to blur, but does bubble.
</p>

				</section>
			</section>
		</section>
		<section id="events-inputevents">
<h3 title="Input Events">3.4. 入力~event型</h3>

<p>
入力~eventは、
利用者-動作の直接的な結果として
（例：編集-可能な領域~内での~keyboard入力や, 整形-中にある~textを削除したとき, 等々）
~DOMが更新された（または，されつつある）とき，通知として送信される。
◎
Input events are sent as notifications whenever the DOM is being updated (or about to be updated) as a direct result of a user action (e.g., keyboard input in an editable region, deleting or formatting text, ...).
</p>

			<section id="interface-inputevent">
<h4 title="Interface InputEvent">3.4.1. `InputEvent^I ~interface</h4>

				<section id="idl-inputevent">
<h5>3.4.1.1. `InputEvent^I</h5>

<p>
DOM3 にて導入された。
◎
Introduced in DOM Level 3
</p>

<pre class="idl">
[`Exposed$=Window]
interface `InputEvent@I : `UIEvent$I {
    `InputEvent@mc(`DOMString$ %type, optional `InputEventInit$I %eventInitDict = {});
    readonly attribute `USVString$? `data$m;
    readonly attribute `boolean$ `isComposing$m;
    readonly attribute `DOMString$ `inputType$m;
};
</pre>

<dl class="idl-def">
	<dt>
`data@m
◎
data, of type USVString, readonly, nullable
</dt>
	<dd>
~IMEにより生成される~Unicode文字 `Unicode$r 並びの値を保持する
— `空~文字列$にもなり得る。
一連の文字は、
`UAX15$r にて定義される~Unicode正規化~形
`NFC^em による定義に従って正規化されるベキである。
◎
data holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY contain the empty string.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>
`isComposing@m
◎
isComposing, of type boolean, readonly
</dt>
	<dd>
入力~eventが組成~sessionの一部として
— すなわち， `compositionstart$et ~eventの後, かつ
対応する `compositionend$et ~eventの前に —
生じたならば~T。
◎
true if the input event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`inputType@m
◎
inputType, of type DOMString, readonly
</dt>
	<dd>
~eventに結付けられた［
入力の型
］を識別する文字列を包含する。
◎
inputType contains a string that identifies the type of input associated with the event.
</dd>
	<dd>
この属性に妥当な値たちが成す~listは `Input-Events$r を見よ。
◎
For a list of valid values for this attribute, refer to the [Input-Events] specification.
</dd>
	<dd>
`未初期化~値$： 空~文字列
◎
The un-initialized value of this attribute MUST be the empty string "".
</dd>
</dl>

				</section>
				<section id="idl-inputeventinit">
<h5>3.4.1.2. `InputEventInit^I</h5>

<pre class="idl">
dictionary `InputEventInit@I : `UIEventInit$I {
    `DOMString$? `data@m = null;
    `boolean$ `isComposing@m = false;
    `DOMString$ `inputType@m = "";
};
</pre>

<p>
この辞書の各~memberは、
`InputEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
data, of type DOMString, nullable, defaulting to null
• Initializes the data attribute of the InputEvent object.
◎
isComposing, of type boolean, defaulting to false
• Initializes the isComposing attribute of the InputEvent object.
◎
inputType, of type DOMString, defaulting to ""
• Initializes the inputType attribute of the InputEvent object. 
</p>

				</section>
			</section>
			<section id="events-inputevent-event-order">
<h4 title="Input Event Order">3.4.2. 入力~event序列</h4>

<p>
この仕様にて定義される入力~eventは、
相互相対順序の下で生じるモノトスル。
◎
The input events defined in this specification MUST occur in a set order relative to one another.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`beforeinput$et
<td>

<tr><td>
<td>
<td><em>
DOM 要素は更新された
</em>
◎
DOM element is updated

<tr><td>2.
<td>`input$et
<td>
</table>

			</section>
			<section id="events-input-types">
<h4>3.4.3. 各種~入力~event型</h4>

				<section id="event-type-beforeinput">
<h5>3.4.3.1. `beforeinput^et</h5>

<div>
◎イ型 `beforeinput@et
◎界面 `InputEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
— 特定的には， `HTMLInputElement$I 等の~control, または
`contenteditable^a 属性が可能化されている任意の `Element$I 。
◎
Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
◎取消 可
◎構 Yes
◎既定動作
~DOM要素を更新する
◎
Update the DOM element
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~入力~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`InputEvent.data$m は、
内容が削除されることになる場合は， ~NULL にされてもヨイ。
</li>
</ul>
◎表終

◎
Type 	beforeinput
Interface 	InputEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
Cancelable 	Yes
Composed 	Yes
Default action 	Update the DOM element
Context
(trusted events) 	

• Event.target : event target that is about to be updated
• UIEvent.view : Window
• UIEvent.detail : 0
• InputEvent.data : the string containing the data that will be added to the element, which MAY be null if the content will be deleted
• InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</div>

<p>
~UAは、
~DOMが更新されつつあるとき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when the DOM is about to be updated.
</p>

				</section>
				<section id="event-type-input">
<h5>3.4.3.2. `input^et</h5>

<div>
◎イ型 `input@et
◎界面 `InputEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
— 特定的には， `HTMLInputElement$I 等の~control, または
`contenteditable^a 属性が可能化されている任意の `Element$I 。
◎
Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~入力~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`InputEvent.data$m は、
内容が削除された場合には，`空~文字列$にされてもヨイ。
</li>
</ul>
◎表終

◎
Type 	input
Interface 	InputEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target that was just updated
• UIEvent.view : Window
• UIEvent.detail : 0
• InputEvent.data : the string containing the data that has been added to the element, which MAY be the empty string if the content has been deleted
• InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</div>

<p>
~UAは、
~DOMが更新された直後に，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event immediately after the DOM has been updated.
</p>

				</section>
			</section>
			<section id="_common-input-event-context">
<h4>各種~入力~eventに共通な文脈~情報</h4>

集約簡略化

<p>
各種~入力~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
更新されつつある／された`~event~target$。
◎
event target that
[ is about to be / was just ]
updated
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`§ 各種~UI~eventに共通な文脈~情報$を見よ。
</dd>
	<dt>`InputEvent!I ：</dt>
	<dd>
	<dd>
		<dl>
			<dt>`data$m</dt>
			<dd>
要素に追加された／されることになる~dataを包含する文字列。
内容が削除されることになる／された場合には、
~eventの型に応じて，`空~文字列$または~NULLにされてもヨイ。
◎
InputEvent.data : the string containing the data that
[ has been | will be ]
added to the element, which MAY be
[ the empty string | null ]
if the content
[ will be | has been ] deleted
</dd>
			<dt>`isComposing$m</dt>
			<dd>
この~eventが`~dead-key＠#keys-dead$連列, または
`~IME$が作動中な間に配送されたものであれば ~T
（`組成~event$が配送されているときなど）
／
~ELSE_ ~F
◎
InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-keyboardevents">
<h3 title="Keyboard Events">3.5. ~keyboard~event型</h3>

<p>
~keyboard~eventは、
装置~依存である
— すなわち，それは、［
入力~装置の能力, および
【物理的な~UIkeyが】
~OSにてどう対応付けられているか
］に依拠する。
詳細は、
~keyboard~eventと`組成~event$とを組合せる用例も含め，
`§ ~keyboard~eventと~UIkey値$を見よ。
文字~生成~装置によっては，~keyboard~eventを生成しないものもある。
◎
Keyboard events are device dependent, i.e., they rely on the capabilities of the input devices and how they are mapped in the operating systems. Refer to Keyboard events and key values for more details, including examples on how Keyboard Events are used in combination with Composition Events. Depending on the character generation device, keyboard events might not be generated.
</p>

<p class="note">注記：
~keyboard~eventは、
~textな入力を供する~~方式（ `modality^en ）の一つにすぎない。
編集~時には、
~keyboard~eventを代替するもの（または それへの追加）として，
`InputEvent$I の利用も考慮すること。
◎
Keyboard events are only one modality of providing textual input. For editing scenarios, consider also using the InputEvent as an alternate to (or in addition to) keyboard events.
</p>

<p class="trans-note">【
参考：
`Keyboard Event Viewer＠https://w3c.github.io/uievents/tools/key-event-viewer.html$en
にて、
各種~keyboard~eventの挙動を試せる。
】</p>

			<section id="interface-keyboardevent">
<h4 title="Interface KeyboardEvent">3.5.1. `KeyboardEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`KeyboardEvent!I ~interfaceは、
~keyboard装置に特有な文脈l情報を供する。
各~keyboard~eventは、
値を利用して~UIkeyを参照する。
~keyboard~eventは、
共通して，~focusを得ている要素へ向けられることが多い。
◎
The KeyboardEvent interface provides specific contextual information associated with keyboard devices. Each keyboard event references a key using a value. Keyboard events are commonly directed at the element that has the focus.
</p>

<p>
`KeyboardEvent$I ~interfaceは、
一部の共通的な修飾~UIkey用の簡便な属性：［
`ctrlKey$m,
`shiftKey$m,
`altKey$m,
`metaKey$m
］を供する。
これらの属性【への取得~access】は、
順に，［
`Control$kY,
`Shift$kY,
`Alt$kY,
`Meta$kY
］を引数に
`getModifierState()$m ~methodを利用するのと等価である。
◎
The KeyboardEvent interface provides convenient attributes for some common modifiers keys: ctrlKey, shiftKey, altKey, metaKey. These attributes are equivalent to using the method getModifierState() with Control, Shift, Alt, or Meta respectively.
</p>

<p>
`KeyboardEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `KeyboardEventInit$I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the KeyboardEvent interface, use the KeyboardEvent constructor, passing an optional KeyboardEventInit dictionary.
</p>

				<section id="idl-keyboardevent">
<h5>3.5.1.1. `KeyboardEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `KeyboardEvent@I : `UIEvent$I {
    `KeyboardEvent@mc(`DOMString$ %type, optional `KeyboardEventInit$I %eventInitDict = {});

    // <span class="comment">`location$m 属性がとり得る定数</span>
    const `unsigned long$ `DOM_KEY_LOCATION_STANDARD$m = 0x00;
    const `unsigned long$ `DOM_KEY_LOCATION_LEFT$m = 0x01;
    const `unsigned long$ `DOM_KEY_LOCATION_RIGHT$m = 0x02;
    const `unsigned long$ `DOM_KEY_LOCATION_NUMPAD$m = 0x03;

    readonly attribute `DOMString$ `key$m;
    readonly attribute `DOMString$ `code$m;
    readonly attribute `unsigned long$ `location$m;

    readonly attribute `boolean$ `ctrlKey$m;
    readonly attribute `boolean$ `shiftKey$m;
    readonly attribute `boolean$ `altKey$m;
    readonly attribute `boolean$ `metaKey$m;

    readonly attribute `boolean$ `repeat$m;
    readonly attribute `boolean$ `isComposing$m;

    `boolean$ `getModifierState$m(`DOMString$ %keyArg);
};
</pre>

<dl class="idl-def">
	<dt>`DOM_KEY_LOCATION_STANDARD@m</dt>
	<dd>
作動化された~UIkeyは、
~UIkeyの［
左／右
］~versionとして判別されるものではなく，かつ
十key（ `NumLock^cap ~UIkeyは除く）, または それに対応する~virtual~UIkeyからも出生されていないことを指示する。
◎
The key activation MUST NOT be distinguished as the left or right version of the key, and (other than the NumLock key) did not originate from the numeric keypad (or did not originate with a virtual key corresponding to the numeric keypad).
</dd>
	<dd class="example">
<p>
~PC101US~keyboardの `Q^cap ~UIkey。
◎
The Q key on a PC 101 Key US keyboard.
</p>
<p>
~PC101US~keyboardの
`NumLock^cap ~UIkey。
◎
The NumLock key on a PC 101 Key US keyboard.
</p>
<p>
~PC101US~keyboardの主区画に所在する `1^cap ~UIkey。
◎
The 1 key on a PC 101 Key US keyboard located in the main section of the keyboard.
</p>
	</dd>

	<dt>`DOM_KEY_LOCATION_LEFT@m</dt>
	<dd>
作動化された~UIkeyは、
左~UIkey所在から出生されていることを指示する
（当の~UIkey用にアリな所在が複数ある場合に限る）。
◎
The key activated originated from the left key location (when there is more than one possible location for this key).
</dd>
	<dd class="example">
~PC101US~keyboardの左 `Control^cap ~UIkey。
◎
The left Control key on a PC 101 Key US keyboard.
</dd>

	<dt>`DOM_KEY_LOCATION_RIGHT@m</dt>
	<dd>
作動化された~UIkeyは、
右~UIkey所在から出生されていることを指示する
（当の~UIkey用にアリな所在が複数ある場合に限る）。
◎
The key activation originated from the right key location (when there is more than one possible location for this key).
</dd>
	<dd class="example">
~PC101US~keyboardの 右 `Shift^cap ~UIkey。
◎
The right Shift key on a PC 101 Key US keyboard.
</dd>
	<dt>`DOM_KEY_LOCATION_NUMPAD@m</dt>
	<dd>
作動化された~UIkeyは、
十key, または それに 対応する~virtual~UIkeyから出生されていることを指示する
（当の~UIkey用にアリな所在が複数ある場合に限る）。
`NumLock^cap ~UIkeyは常に，所在 `DOM_KEY_LOCATION_STANDARD$m を伴って符号化されるベキであることに注意。
◎
The key activation originated on the numeric keypad or with a virtual key corresponding to the numeric keypad (when there is more than one possible location for this key). Note that the NumLock key should always be encoded with a location of DOM_KEY_LOCATION_STANDARD.
</dd>
	<dd class="example">
~PC101US~keyboardの ~numpadに所在する `1^cap ~UIkey。
◎
The 1 key on a PC 101 Key US keyboard located on the numeric pad.
</dd>

	<dt>
`key@m
◎
key, of type DOMString, readonly
</dt>
	<dd>
押された~UIkeyに対応する`~UIkey属性~値$を保持する。
◎
key holds a key attribute value corresponding to the key pressed.
</dd>
	<dd class="note">注記：
`key^m 属性は，旧来の `keyCode$m 属性には関係しない
— とり得る値の集合も同じでない。
◎
The key attribute is not related to the legacy keyCode attribute and does not have the same set of values.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>

	<dt>
`code@m
◎
code, of type DOMString, readonly
</dt>
	<dd>
`code^m は、
押されている物理的~UIkeyを識別する文字列を保持する。
値は，現在の~keyboard~layoutや修飾~状態からは影響されないので、
同じ~UIkeyからは常に同じ値が返されることになる。
◎
code holds a string that identifies the physical key being pressed. The value is not affected by the current keyboard layout or modifier state, so a particular key will always return the same value.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>

	<dt>
`location@m
◎
location, of type unsigned long, readonly
</dt>
	<dd>
`location^m 属性は、
装置~上の~UIkeyの論理的な所在の指示を包含する。
◎
The location attribute contains an indication of the logical location of the key on the device.
</dd>
	<dd>
この属性は、［
装置~上の~UIkeyの所在を指示する，
`DOM_KEY_LOCATION-…^m 定数
］のうちの，いずれかに設定するモノトスル。
◎
This attribute MUST be set to one of the DOM_KEY_LOCATION constants to indicate the location of a key on the device.
</dd>
	<dd>
【環境設定により】~UIkeyを対応付-直すことを許容する~UAは、
対応付けられた~~元の~UIkey用の `location$m 値を，新たな~UIkeyに適切な値に設定するモノトスル。
例えば， `ControlLeft$kC ~UIkeyが `KeyQ$kC ~UIkeyに対応付-直されたなら、
この属性は `DOM_KEY_LOCATION_STANDARD$m に設定するモノトスル。
逆に， `KeyQ$kC ~UIkeyが左右いずれかの `Control^cap ~UIkeyに対応付-直された場合、
それに応じて，この属性も［
`DOM_KEY_LOCATION_LEFT$m, `DOM_KEY_LOCATION_RIGHT$m
］のいずれかに設定するモノトスル。
◎
If a user agent allows keys to be remapped, then the location value for a remapped key MUST be set to a value which is appropriate for the new key. For example, if the "ControlLeft" key is mapped to the "KeyQ" key, then the location attribute MUST be set to DOM_KEY_LOCATION_STANDARD. Conversely, if the "KeyQ" key is remapped to one of the Control keys, then the location attribute MUST be set to either DOM_KEY_LOCATION_LEFT or DOM_KEY_LOCATION_RIGHT.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`ctrlKey@m
◎
ctrlKey, of type boolean, readonly
</dt>
	<dd>
`Control^cap （ control ）修飾が作動中であったならば~T
◎
true if the Control (control) key modifier was active. 
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`shiftKey@m
◎
shiftKey, of type boolean, readonly
</dt>
	<dd>
`Shift^cap （ shift ）修飾が作動中であったならば~T。
◎
true if the shift (Shift) key modifier was active.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`altKey@m
◎
altKey, of type boolean, readonly
</dt>
	<dd>
`Alt^cap （ alternative, ~~別名 `Option^cap ）修飾が作動中であったならば~T。
◎
true if the Alt (alternative) (or "Option") key modifier was active.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`metaKey@m
◎
metaKey, of type boolean, readonly
</dt>
	<dd>
`Meta^cap（ meta ）修飾が作動中であったならば~T。
◎
true if the meta (Meta) key modifier was active.
</dd>
	<dd class="note">注記：
Macintosh ~system上の `Command^cap （ `⌘^cap ）~UIkey修飾は
この~UIkey修飾を利用して表現される。
◎
The "Command" ("⌘") key modifier on Macintosh systems is represented using this key modifier.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`repeat@m
◎
repeat, of type boolean, readonly
</dt>
	<dd>
~UIkeyが~~持続的に押されているならば ~T 。
~UIkeyが~~押下げ続けられている下では、［
`keydown$et, `beforeinput$et, `input$et
］~eventが、
この順序で，~system環境設定から決定される~rateで，繰返すモノトスル。
`~UIkeyの長押し^em に対する挙動を備える携帯~機器においては、
`repeat$m 属性~値に ~T を伴う最初の~UIkey~eventが，その挙動を指示する~~役割を果たすモノトスル。
繰返され始めるまで~UIkeyを押し続ける必要がある時間の長さは、
環境設定に依存する。
◎
true if the key has been pressed in a sustained manner. Holding down a key MUST result in the repeating the events keydown, beforeinput, input in this order, at a rate determined by the system configuration. For mobile devices which have long-key-press behavior, the first key event with a repeat attribute value of true MUST serve as an indication of a long-key-press. The length of time that the key MUST be pressed in order to begin repeating is configuration-dependent.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`isComposing@m
◎
isComposing, of type boolean, readonly
</dt>
	<dd>
~UIkey~eventが組成~sessionの一部として
— すなわち， `compositionstart$et ~eventの後, かつ
対応する `compositionend$et ~eventの前に —
生じたならば~T。
◎
true if the key event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`getModifierState(keyArg)@m
</dt>
	<dd>
`~UIkey値$を利用して，ある修飾の状態を~queryする。
◎
Queries the state of a modifier using a key value.
</dd>
	<dd>
［
%keyArg は修飾~UIkey用の`~UIkey値$であって，その~UIkeyは作動化されているならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if it is a modifier key and the modifier is activated, false otherwise.
</dd>
	<dd>
引数 %keyArg には、
修飾`~UIkey値$を与える。
妥当な`修飾~UIkey$は、
`UIEvents-Key$r の`修飾~UIkeyの表t$にて定義される。
◎
DOMString keyArg
◎
A modifier key value. Valid modifier keys are defined in the Modifier Keys table in [UIEvents-Key].
</dd>
	<dd class="note">注記：
~appが 右, 左の修飾を判別したいと望む場合、
この情報は，
~keyboard~event, および
`KeyboardEvent.location$m
を利用して演繹することもできる。
◎
If an application wishes to distinguish between right and left modifiers, this information could be deduced using keyboard events and location.
</dd>
</dl>

				</section>
				<section id="idl-keyboardeventinit">
<h5>3.5.1.2. `KeyboardEventInit^I</h5>

<pre class="idl">
dictionary `KeyboardEventInit@I : `EventModifierInit$I {
    `DOMString$ `key@m = "";
    `DOMString$ `code@m = "";
    `unsigned long$ `location@m = 0;
    `boolean$ `repeat@m = false;
    `boolean$ `isComposing@m = false;
};
</pre>

<p>
この辞書の各~memberは、
`KeyboardEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
key, of type DOMString, defaulting to ""
• Initializes the key attribute of the KeyboardEvent object to the unicode character string representing the meaning of a key after taking into account all keyboard modifiers (such as shift-state). This value is the final effective value of the key. If the key is not a printable character, then it should be one of the key values defined in [UIEvents-Key].
◎
code, of type DOMString, defaulting to ""
• Initializes the code attribute of the KeyboardEvent object to the unicode character string representing the key that was pressed, ignoring any keyboard modifications such as keyboard layout. This value should be one of the code values defined in [UIEvents-Code].
◎
location, of type unsigned long, defaulting to 0
• Initializes the location attribute of the KeyboardEvent object to one of the following location numerical constants:
• DOM_KEY_LOCATION_STANDARD (numerical value 0)
• DOM_KEY_LOCATION_LEFT (numerical value 1)
• DOM_KEY_LOCATION_RIGHT (numerical value 2)
• DOM_KEY_LOCATION_NUMPAD (numerical value 3)
◎
repeat, of type boolean, defaulting to false
• Initializes the repeat attribute of the KeyboardEvent object. This attribute should be set to true if the the current KeyboardEvent is considered part of a repeating sequence of similar events caused by the long depression of any single key, false otherwise.
◎
isComposing, of type boolean, defaulting to false
• Initializes the isComposing attribute of the KeyboardEvent object. This attribute should be set to true if the event being constructed occurs as part of a composition sequence, false otherwise.
</p>

				</section>

<div class="warning">
<p>
旧来の~keyboard~event実装は 3 種の追加的な属性［
`keyCode$m, `charCode$m, `which$m
］を含んでいる。
`keyCode^m 属性は［
~computer~keyboardの特定0の~UIkeyに結付けられた数的な値
］を指示する一方、
`charCode^m 属性は［
その~UIkeyに結付けられた文字の~ASCII値
］を指示し（ `keyCode^m 値と同じにもなり得る），
適用-可能なのは`文字~値$を生産する~UIkeyに限られる。
◎
Legacy keyboard event implementations include three additional attributes, keyCode, charCode, and which. The keyCode attribute indicates a numeric value associated with a particular key on a computer keyboard, while the charCode attribute indicates the ASCII value of the character associated with that key (which might be the same as the keyCode value) and is applicable only to keys that produce a character value.
</p>

<p>
実施においては、［
`keyCode^m, `charCode^m
］は，［
~platform間で, あるいは
同じ実装ですら 種々の~OSや地域化の間で
］一貫でない。
この仕様は［
`keyCode^m, `charCode^m
］の値も, `charCode^m の挙動も定義しない。
適合~UI~Events実装においては，内容~作者は、［
`KeyboardEvent.key$m, `KeyboardEvent.code$m
］を利用できる。
◎
In practice, keyCode and charCode are inconsistent across platforms and even the same implementation on different operating systems or using different localizations. This specification does not define values for either keyCode or charCode, or behavior for charCode. In conforming UI Events implementations, content authors can instead use key and code.
</p>

<p><em>
更なる情報は、
参考な
`§ 旧来の~UIkey属性＠~UIEVENTS-A#legacy-key-attributes$
を見よ。
</em>
◎
For more information, see the informative appendix on Legacy key attributes.
</p>
</div>

<p class="note">注記：
既存の内容との互換性のため，~virtual~keyboard
— ~screenに基づく入力~装置~上の~software~keyboardなど —
は、［
物理的~UIkeyを処理しなくとも，通常の範囲の~keyboard~eventを生産する
］ものと期待されている。
◎
For compatibility with existing content, virtual keyboards, such as software keyboards on screen-based input devices, are expected to produce the normal range of keyboard events, even though they do not possess physical keys.
</p>

<p class="note">注記：
一部の実装／~system環境設定においては、
一部の~UIkey~eventやその値は，利用-中にある`~IME$により抑止されることがある。
◎
In some implementations or system configurations, some key events, or their values, might be suppressed by the IME in use.
</p>

			</section>
			<section id="events-keyboard-key-location">
<h4 title="Keyboard Event Key Location">3.5.2. ~keyboard~eventに対する~UIkeyの所在</h4>

<!-- `KeyboardEvent!I -->

<p>
`location$m 属性は、
~keyboard上の異なる物理的~UIkeyから同じ`~UIkey値$が生成される場合に，
それらを~~区別するために利用できる。
例えば、
左右 `Shift^cap ~UIkey，あるいは
物理的~矢印~UIkeyと（ `NumLock^cap が off のときの）~numpad上の矢印~UIkey。
◎
The location attribute can be used to disambiguate between key values that can be generated by different physical keys on the keyboard, for example, the left and right Shift key or the physical arrow keys vs. the numpad arrow keys (when NumLock is off).
</p>

<p>
~keyboard上に所在が複数あるような特別な~UIkey用の，妥当な `location$m 値は、
次の表tに定義される：
◎
The following table defines the valid location values for the special keys that have more than one location on the keyboard:
</p>

<table class="event-sequence-table"><thead>
<tr><th>
`key$m 値
◎
KeyboardEvent . key
<th>
妥当な `location$m 値
◎
Valid location values
<tbody>

<tr><td>
`Shift$kY, `Control$kY, `Alt$kY, `Meta$kY
<td>
`DOM_KEY_LOCATION_LEFT$m,
`DOM_KEY_LOCATION_RIGHT$m

<tr><td>
`ArrowDown$kY, `ArrowLeft$kY, `ArrowRight$kY, `ArrowUp$kY
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

<tr><td>
`End$kY, `Home$kY, `PageDown$kY, `PageUp$kY
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

<tr><td>
`0^kY, `1^kY, `2^kY, `3^kY,
`4^kY, `5^kY, `6^kY, `7^kY,
`8^kY, `9^kY, `.^kY, `Enter$kY,
`+^kY, `-^kY, `*^kY, `/^kY,
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m
</table>

<p>
この表tに挙げられていない他のすべての~UIkey用の `location$m 属性は、
常に `DOM_KEY_LOCATION_STANDARD$m に設定するモノトスル。
◎
For all other keys not listed in this table, the location attribute MUST always be set to DOM_KEY_LOCATION_STANDARD. 
</p>

			</section>
			<section id="event-modifier-initializers">
<h4 title="Event Modifier Initializers">3.5.3. ~eventの~UIkey修飾~初期化子</h4>

<p>
［
`MouseEvent$I, `KeyboardEvent$I
］~interfaceは、
各種~keyboard修飾~属性を共有し，
追加的な修飾~状態を検索取得するための仕組みを~supportする。
`EventModifierInit$I 辞書は、
作者が［
これらの~interfaceの各種~keyboard修飾~属性
］および［［
前者の `getModifierState()＠~POINTEREVENTS#dom-mouseevent-getmodifierstate$m ／
後者の `KeyboardEvent.getModifierState()$m
］を介して~queryされる追加的な修飾~状態
］を初期化することを可能化する。
この辞書を利用して~mouse~eventを構築する手続きは、
`POINTEREVENTS4$r にて定義される†。
◎
The MouseEvent and KeyboardEvent interfaces share a set of keyboard modifier attributes and support a mechanism for retrieving additional modifier states. The following dictionary enables authors to initialize keyboard modifier attributes of the MouseEvent and KeyboardEvent interfaces, as well as the additional modifier states queried via getModifierState(). The steps for constructing mouse events using this dictionary are defined in the [pointerevents4] specification.
</p>

<p class="trans-note">【†
`§ ~mouse~eventの構築-法＠~POINTEREVENTS#constructing-mouse-events$
— それは、
元々はこの仕様にて定義されたたものであり，
そこに述べられる処理nは `KeyboardEvent$I を構築する際にも適用されるべきであろう
（そこで `MouseEvent$I 用に定義される`内部~UIkey修飾~状態$は、
`KeyboardEvent$I 用にも定義されるものと見なすべきである）。
】</p>

<pre class="idl">
dictionary `EventModifierInit@I : `UIEventInit$I {
    `boolean$ `ctrlKey$m = false;
    `boolean$ `shiftKey$m = false;
    `boolean$ `altKey$m = false;
    `boolean$ `metaKey$m = false;

    `boolean$ `modifierAltGraph$m = false;
    `boolean$ `modifierCapsLock$m = false;
    `boolean$ `modifierFn$m = false;
    `boolean$ `modifierFnLock$m = false;
    `boolean$ `modifierHyper$m = false;
    `boolean$ `modifierNumLock$m = false;
    `boolean$ `modifierScrollLock$m = false;
    `boolean$ `modifierSuper$m = false;
    `boolean$ `modifierSymbol$m = false;
    `boolean$ `modifierSymbolLock$m = false;
};
</pre>

<div>
<p>
以下において、
%~event は［
`MouseEvent$I ／ `KeyboardEvent$I
］いずれかを実装する~event~obj，
`getModifierState()^m は %~event 上の同じ名前の~methodを表すとする。
</p>

<dl class="idl-def">
	<dt>`ctrlKey@m</dt>
	<dt>`shiftKey@m</dt>
	<dt>`altKey@m</dt>
	<dt>`metaKey@m</dt>
	<dd>
<p>
これらの各~memberは、
%~event 上の同じ名前の属性を初期化する。
値の意味は、
`KeyboardEvent$I の同じ名前の属性の記述を見よ。
</p>

<p>
加えて，実装は、
%~event の`内部~UIkey修飾~状態$を［
次の表tの 2 列目に挙げる値を引数に %~event 上の `getModifierState()^m が呼出されたときは，同じ行の 1 列目に挙げる名前の~member値が返される
］ように初期化するモノトスル。
</p>

<table><thead>
<tr><th>名前
<th>引数
<tbody>

<tr><td>`altKey^c
<td>`Alt^l【！^cap】

<tr><td>`ctrlKey^c
<td>`Control^l

<tr><td>`altKey^c
<td>`Meta^l

<tr><td>`shiftKey^c
<td>`Shift^l
</table>
	</dd>

	<dt>`modifierAltGraph@m</dt>
	<dt>`modifierCapsLock@m</dt>
	<dt>`modifierFn@m</dt>
	<dt>`modifierFnLock@m</dt>
	<dt>`modifierHyper@m</dt>
	<dt>`modifierNumLock@m</dt>
	<dt>`modifierScrollLock@m</dt>
	<dt>`modifierSuper@m</dt>
	<dt>`modifierSymbol@m</dt>
	<dt>`modifierSymbolLock@m</dt>
	<dd>
これらの~memberは、
%~event の`内部~UIkey修飾~状態$を［
対応する`~UIkey修飾~名$
— すなわち、
~member名を `modifier<var>XXX</var>^c とするときの，文字列 %XXX —
を引数に %~event 上の `getModifierState()^m が呼出されたときは，
その~member値が返される
］ように初期化する。
</dd>
</dl>

◎
ctrlKey, of type boolean, defaulting to false
• Initializes the ctrlKey attribute of the MouseEvent or KeyboardEvent objects to true if the Control key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Control must return true.
◎
shiftKey, of type boolean, defaulting to false
• Initializes the shiftKey attribute of the MouseEvent or KeyboardEvent objects to true if the Shift key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Shift must return true.
◎
altKey, of type boolean, defaulting to false
• Initializes the altKey attribute of the MouseEvent or KeyboardEvent objects to true if the Alt (alternative) (or Option) key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Alt must return true.
◎
metaKey, of type boolean, defaulting to false
• Initializes the metaKey attribute of the MouseEvent or KeyboardEvent objects to true if the Meta key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with either the parameter Meta must return true.

◎
modifierAltGraph, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter AltGraph must return true.
◎
modifierCapsLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter CapsLock must return true.
◎
modifierFn, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Fn must return true.
◎
modifierFnLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter FnLock must return true.
◎
modifierHyper, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Hyper must return true.
◎
modifierNumLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter NumLock must return true.
◎
modifierScrollLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter ScrollLock must return true.
◎
modifierSuper, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Super must return true.
◎
modifierSymbol, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Symbol must return true.
◎
modifierSymbolLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter SymbolLock must return true.
</div>

			</section>
			<section id="keyboardevent-algorithms">
<h4 title="KeyboardEvent Algorithms">3.5.4. `KeyboardEvent^I 用の~algo</h4>

				<section id="keyboardevent-global-state">
<h5 title="Global State for KeyboardEvent">3.5.4.1. `KeyboardEvent^I 用の大域的な状態</h5>

<div>
<p id="keyboardevent-global-ua">
~UAは、
~UA全体で共有される値をとして，次を保守するモノトスル：
</p>
<ul>
	<li>
<p>
`修飾~UIkey状態@
⇒
~systemにて可用な各［
%名前 ~IN { `Shift^l, `Control^l, `Alt^l, `AltGraph^l, `Meta^l } で識別される`修飾~UIkey$
］の現在の状態を追跡し続ける。
</p>

<p>
＊`修飾~UIkey状態$( %名前 )
と記された所では、
%名前 で識別される修飾~UIkeyは［
押されているならば ~T ／
~ELSE_ ~F
］を返すとする。
【この記法は、他所を簡潔に述べるためのこの訳による追加。】
</p>
	</li>
</ul>
◎
3.5.4.1.1. User Agent-Level State
◎
The UA must maintain the following values that are shared for the entire User Agent.
◎
A key modifier state (initially empty) that keeps track of the current state of each modifier key available on the system.
</div>

				</section>
			</section>
			<section id="events-keyboard-event-order">
<h4 title="Keyboard Event Order">3.5.5. ~keyboard~event序列</h4>

<p>
この仕様にて定義される~keyboard~eventは、
与えられたどの~UIkeyに対しても，相互相対順序の下で生じる：
◎
The keyboard events defined in this specification occur in a set order relative to one another, for any given key:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>

<tr><td>2.
<td>`beforeinput$et
<td><em>
（`文字~値$を生産する~UIkeyに対してのみ）
</em>
◎
(only for keys which produce a character value)

<tr><td>
<td>
<td><em>
この~UIkeyに関係する`既定~動作$
— 文字を~DOMの中へ挿入するなど —
があれば，それが行われる。
</em>
◎
Any default actions related to this key, such as inserting a character in to the DOM.

<tr><td>3.
<td>`input$et
<td><em>
（~DOMを更新させた~UIkeyに対してのみ）
</em>
◎
(only for keys which have updated the DOM)

<tr><td>
<td>
<td><em>
一定時間，~UIkeyが押下げられたとき、
生じ得るような~event（下を見よ）。
</em>
◎
Any events as a result of the key being held for a sustained period (see below).

<tr><td>4.
<td>`keyup$et
<td>
</table>

<p>
一定時間，~UIkeyが押下げられた場合、
環境に依存する~rateで，次の~eventが繰返されてもヨイ：
◎
If the key is depressed for a sustained period, the following events MAY repeat at an environment-dependent rate:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td><em>
（ `KeyboardEvent.repeat$m 属性は ~T に設定される）
</em>
◎
(with repeat attribute set to true)

<tr><td>2.
<td>`beforeinput$et
<td><em>
（`文字~値$を生産した~UIkeyに対してのみ）
</em>
◎
(only for keys which produce a character value)

<tr><td>
<td>
<td><em>
【！複製】
この~UIkeyに関係する`既定~動作$
— 文字を~DOMの中へ挿入するなど —
があれば，それが行われる。
</em>
◎
Any default actions related to this key, such as inserting a character in to the DOM.

<tr><td>3.
<td>`input$et
<td><em>
【！複製】
（~DOMを更新させた~UIkeyに対してのみ）
</em>
◎
(only for keys which have updated the DOM)
</table>

<p class="note">注記：
概して、
特定0の~UIkeyに結付けられた`既定~動作$があれば，
`keyup$et ~eventが発火される前に完了する。
これは
`keyup$et ~eventを少しばかり遅延し得る
（おそらく，知覚される程の遅延にはならないであろうが）。
◎
Typically, any default actions associated with any particular key are completed before the keyup event is dispatched. This might delay the keyup event slightly (though this is not likely to be a perceptible delay).
</p>

<p>
~UIkey~eventの`~target$は、
~keyboard活動を処理している現在の被focus要素である。
これは、［
~HTML `input^e 要素／編集-可能な~textな要素
］になることが多いが、
`~host言語$における非~text目的の~keyboard入力
— 加速~UIkeyの作動化や 一部の他の挙動の誘発など —
を受容するように定義された要素になることもある。
相応しい被focus要素が無い場合の~event~targetは、［
可用なら ~HTML`~body要素$ ／
他の場合は `文書~要素$＊`根~要素$
］になる。
◎
The event target of a key event is the currently focused element which is processing the keyboard activity. This is often an HTML input element or a textual element which is editable, but MAY be an element defined by the host language to accept keyboard input for non-text purposes, such as the activation of an accelerator key or trigger of some other behavior. If no suitable element is in focus, the event target will be the HTML body element if available, otherwise the root element.
</p>

<p class="note">注記：
`~event~target$は、
一連の~UIkey~event間で変化し得る。
例えば， `Tab^cap ~UIkey用の `keydown$et ~eventの`~target$は、
同じ~keystroke用の `keyup$et ~eventと異なるであろう。
◎
The event target might change between different key events. For example, a keydown event for the Tab key will likely have a different event target than the keyup event on the same keystroke.
</p>

			</section>
			<section id="events-keyboard-types">
<h4>3.5.6. 各種~keyboard~event型</h4>

				<section id="event-type-keydown">
<h5>3.5.6.1. `keydown^et</h5>

<div>
◎イ型 `keydown@et
◎界面 `KeyboardEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作
<p>
文脈依存：
</p>
<ul>
	<li>
`beforeinput$et ＆ `input$et ~event
</li>
	<li>
`~text組成~system$を立上げる
</li>
	<li>
`blur$et ＆ `focus$et ~event
</li>
	<li>
`keypress$et ~event（~support有りなら）
</li>
	<li>
`作動化の挙動$
</li>
	<li>
その他の~event
</li>
</ul>
◎
Varies: beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other event
◎文脈
`§ 各種~keyboard~eventに共通な文脈~情報$を見よ。
◎表終

◎
Type 	keydown
Interface 	KeyboardEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies: beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other event
Context
(trusted events) 	

• Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
• UIEvent.view : Window
• UIEvent.detail : 0
• KeyboardEvent.key : the key value of the key pressed.
• KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
• KeyboardEvent.location : the location of the key on the device.
• KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
• KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
• KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
• KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
• KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
• KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</div>

<p>
~UAは、［
~UIkeyが押された
］とき，この~eventを発火するモノトスル。
`keydown$et ~event型は装置~依存であり，
入力~装置の能力, および
それらが~OSにおいて対応付けられている方法に依拠する。
この~event型は、
`~UIkey対応付け$の後に生成するモノトスル。
この~event型は、
同じ~UIkeyに結付けられた［
`beforeinput$et, `input$et, `keyup$et
］~eventの前に配送するモノトスル。
◎
A user agent MUST dispatch this event when a key is pressed down. The keydown event type is device dependent and relies on the capabilities of the input devices and how they are mapped in the operating system. This event type MUST be generated after the key mapping. This event type MUST be dispatched before the beforeinput, input, and keyup events associated with the same key.
</p>

<p>
`keydown$et
~eventの既定~動作は，~UIkeyに依存する：
◎
The default action of the keydown event depends upon the key:
</p>

<ul>
	<li>
~UIkeyが文字に結付けられた場合の既定~動作は、［
`beforeinput$et ~event, 後続する `input$et ~event
］を発火するモノトスル。
~UIkeyが複数の文字に結付けられた場合
（~macroを伴うものや ~dead-keyからなる連列など）
の既定~動作は、
各~文字に対し［
`beforeinput$et, `input$et
］~event対を発火するモノトスル。
◎
If the key is associated with a character, the default action MUST be to dispatch a beforeinput event followed by an input event. In the case where the key which is associated with multiple characters (such as with a macro or certain sequences of dead keys), the default action MUST be to dispatch one set of beforeinput / input events for each character
</li>
	<li>
~UIkeyが`~text組成~system$に結付けられた場合の既定~動作は、
その~systemを立上げるモノトスル。
◎
If the key is associated with a text composition system, the default action MUST be to launch that system
</li>
	<li>
~UIkeyが `Tab^cap ~UIkeyの場合の既定~動作は、
`~focus~event$型にて述べたとおり，文書~focusを現在の被focus要素（もしあれば）から新たな被focus要素へ移転するモノトスル。
◎
If the key is the Tab key, the default action MUST be to shift the document focus from the currently focused element (if any) to the new focused element, as described in Focus Event Types
</li>
	<li>
~UIkeyが `Enter^cap ／ `~SPACEBAR^cap ~UIkeyであって, かつ
現在の~focusが状態~変化-中にある要素~上にある場合の既定~動作は、［
`click$et ~eventに加えて，~UAが~supportするならば `DOMActivate$et ~event
］を発火するモノトスル。
◎
If the key is the Enter or (Space) key and the current focus is on a state-changing element, the default action MUST be to dispatch a click event, and a DOMActivate event if that event type is supported by the user agent.
</li>
</ul>

<p>
この~eventが取消された場合、［
結付けられた~event型は発火しないことに加え，
結付けられた動作も遂行しない
］モノトスル。
◎
If this event is canceled, the associated event types MUST NOT be dispatched, and the associated actions MUST NOT be performed.
</p>

<p class="note">注記：
［
`keydown$et ／ `keyup$et
］~eventは、
伝統的に［
`文字~値$を生産する~UIkeyに限らず，他の~UIkeyの検出-法
］にも結付けられる。
◎
The keydown and keyup events are traditionally associated with detecting any key, not just those which produce a character value.
</p>

				</section>
				<section id="event-type-keyup">
<h5>3.5.6.2. `keyup^et</h5>

<div>
◎イ型 `keyup@et
◎界面 `KeyboardEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
`§ 各種~keyboard~eventに共通な文脈~情報$を見よ。
◎表終

◎
Type 	keyup
Interface 	KeyboardEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
• UIEvent.view : Window
• UIEvent.detail : 0
• KeyboardEvent.key : the key value of the key pressed.
• KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
• KeyboardEvent.location : the location of the key on the device.
• KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
• KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
• KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
• KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
• KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
• KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</div>

<p>
~UAは、［
~UIkeyが離された
］とき，この~eventを発火するモノトスル。
`keyup$et ~event型は装置~依存であり，
入力~装置の能力, および
それらが~OSにおいて対応付けられている方法
に依拠する。
この~event型は，`~UIkey対応付け$の後に生成するモノトスル。
この~event型は、
同じ~UIkeyに結付けられた［
`keydown$et,
`beforeinput$et,
`input$et
］~eventの後に発火するモノトスル。
◎
A user agent MUST dispatch this event when a key is released. The keyup event type is device dependent and relies on the capabilities of the input devices and how they are mapped in the operating system. This event type MUST be generated after the key mapping. This event type MUST be dispatched after the keydown, beforeinput, and input events associated with the same key.
</p>

<p class="note">注記：
［
`keydown$et ／ `keyup$et
］~eventは、
伝統的に［
`文字~値$を生産する~UIkeyに限らず，他の~UIkeyの検出-法
］にも結付けられる。
◎
The keydown and keyup events are traditionally associated with detecting any key, not just those which produce a character value.
</p>

				</section>
			</section>
			<section id="_common-keyboard-event-context">
<h4>各種~keyboard~eventに共通な文脈~情報</h4>

集約簡略化

<p>
~keyboard~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
~UIkey~eventを処理している被focus要素。
被focus要素がない場合、
可用ならば`~body要素$ ／
他の場合 `根~要素$
◎
Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`§ 各種~UI~eventに共通な文脈~情報$を見よ。
</dd>

	<dt>`KeyboardEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`key$m</dt>
			<dd>
押された~UIkeyの`~UIkey値$。
◎
KeyboardEvent.key : the key value of the key pressed.
</dd>
			<dt>`code$m</dt>
			<dd>
~UIkeyの~keyboard上での物理的~~位置に結付けられた~code値
◎
KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
</dd>
			<dt>`location$m</dt>
			<dd>
装置~上の~UIkeyの所在。
◎
KeyboardEvent.location : the location of the key on the device.
</dd>
			<dt>`altKey$m</dt>
			<dd>
`Alt^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
</dd>
			<dt>`shiftKey$m</dt>
			<dd>
`Shift^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
</dd>
			<dt>`ctrlKey$m</dt>
			<dd>
`Control^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
</dd>
			<dt>`metaKey$m</dt>
			<dd>
`Meta^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
</dd>
			<dt>`repeat$m</dt>
			<dd>
~UIkeyの繰返nを誘発するに十分~長く~UIkeyが押下げられているならば ~T ／
他の場合 ~F
◎
KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
</dd>
			<dt>`isComposing$m</dt>
			<dd>
~UIkey~eventが，組成~sessionの一部として生じたならば ~T ／
他の場合 ~F
◎
KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-compositionevents">
<h3 title="Composition Events">3.6. 組成~event</h3>

<div>
<p>
`組成~event@
（ `Composition Events^en ）は、
~~普通の~keyboardには無い文字を利用することを許容するために，
`~keyboard~event$による方式に［
補足的な, あるいは代替する
］方式で，~textを入力する手段を供する。
組成~eventは、
例えば，次のために利用され得る：
</p>
<ul>
	<li>
文字に標準的な~US~keyboardには無い~accentを追加する。
</li>
	<li>
多くのアジア圏の言語において，基底~成分／字種から表語文字を築上げる。
</li>
	<li>
携帯~機器~keyboardで，押されている~UIkeyの組合nから 単語を選択する。
</li>
	<li>
発話~認識~処理器を利用して，一連の~voice~commandを~textに変換する。
</li>
</ul>

<p>
`組成~event$を~keyboard~eventと組合せる用例については、
`§ ~keyboard~eventと~UIkey値$を見よ。
</p>

◎
Composition Events provide a means for inputing text in a supplementary or alternate manner than by Keyboard Events, in order to allow the use of characters that might not be commonly available on keyboard. For example, Composition Events might be used to add accents to characters despite their absence from standard US keyboards, to build up logograms of many Asian languages from their base components or categories, to select word choices from a combination of key presses on a mobile device keyboard, or to convert voice commands into text using a speech recognition processor. Refer to § 4 Keyboard events and key values for examples on how Composition Events are used in combination with keyboard events.
</div>

<p>
概念的には、
組成~sessionは［
1 個の `compositionstart$et ~event,
1 個【 0 個？】以上の `compositionupdate$et ~event,
1 個の `compositionend$et ~event
］からなり、
それらの~eventの `CompositionEvent.data$m 属性の値は，
各~sessionの最中のこの~event連鎖【伝播？連列？】の各 “stage” 間で持続する【？】。
◎
Conceptually, a composition session consists of one compositionstart event, one or more compositionupdate events, and one compositionend event, with the value of the data attribute persisting between each "stage" of this event chain during each session.
</p>

<p class="note">注記：
組成~sessionで利用されている入力~装置が~keyboardである場合、
組成~sessionが作動中にある間の~keyboard~eventは，~DOMへ発火され得る。
関連な~eventたちの順序付けについては、
`compositionstart$et の詳細, `§ ~IME＠#keys-IME$を見よ。
◎
Note: While a composition session is active, keyboard events can be dispatched to the DOM if the keyboard is the input device used with the composition session. See the compositionstart event details and IME section for relevent event ordering.
</p>

<p>
`~IME$~system／装置は，~DOMに必要yな~dataを公開するとは限らないので、
作動中な組成~文字列
（ “変換窓（ `Reading Window^en ）” や “候補~選択~menuに示されるもの” ）
は，この~interfaceを通して可用でないこともある
— その場合、
選択は`空~文字列$として表現されることもある。
◎
Not all IME systems or devices expose the necessary data to the DOM, so the active composition string (the "Reading Window" or "candidate selection menu option") might not be available through this interface, in which case the selection MAY be represented by the empty string.
</p>

			<section id="interface-compositionevent">
<h4 title="Interface CompositionEvent">3.6.1. `CompositionEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`CompositionEvent^I ~interfaceは、
`組成~event$に特有な文脈l情報を供する。
◎
The CompositionEvent interface provides specific contextual information associated with Composition Events.
</p>

<p>
`CompositionEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `CompositionEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the CompositionEvent interface, use the CompositionEvent constructor, passing an optional CompositionEventInit dictionary.
</p>

				<section id="idl-compositionevent">
<h5>3.6.1.1. `CompositionEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `CompositionEvent@I : `UIEvent$I {
    `CompositionEvent@mc(`DOMString$ %type, optional `CompositionEventInit$I %eventInitDict = {});
    readonly attribute `USVString$ `data$m;
};
</pre>

<dl class="idl-def">
	<dt>
`data@m
◎
data, of type USVString, readonly
</dt>
	<dd>
`data^c は~IMEにより生成された一連の`文字~値$を保持する
— `空~文字列$にもなり得る。
一連の文字は、［
`UAX15$r にて定義される~Unicode正規化~形 `NFC^em
］による定義に従って正規化されるベキである。
◎
data holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY be the empty string.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>
</dl>

				</section>
				<section id="idl-compositioneventinit">
<h5>3.6.1.2. `CompositionEventInit^I</h5>

<pre class="idl">
dictionary `CompositionEventInit@I : `UIEventInit$I {
    `DOMString$ `data@m = "";
};
</pre>

<p>
この辞書の各~memberは、
`CompositionEvent!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
data, of type DOMString, defaulting to ""
• Initializes the data attribute of the CompositionEvent object to the characters generated by the IME composition.
</p>

				</section>
			</section>
			<section id="events-composition-order">
<h4 title="Composition Event Order">3.6.2. 組成~event序列</h4>

<p>
この仕様にて定義される`組成~event$は、
次による相互相対順序の下で生じるモノトスル：
◎
The Composition Events defined in this specification MUST occur in the following set order relative to one another:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`compositionstart$et
<td>

<tr><td>2.
<td>`compositionupdate$et
<td>複数回 生じ得る
◎
Multiple events

<tr><td>3.
<td>`compositionend$et
<td>
</table>

			</section>
			<section id="events-composition-handwriting">
<h4 title="Handwriting Recognition Systems">3.6.3. 手書き認識~system</h4>
<p>
次の例に、［
~pen~tabletなどの手書き認識~systemの下で，一節の~text "text" を組成する
］ときにアリな~event連列を，`組成~event$の~modelを利用して述べる。
◎
The following example describes a possible sequence of events when composing a text passage "text" with a handwriting recognition system, such as on a pen tablet, as modeled using Composition Events.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`compositionstart$et
<td>`^kGl
<td>

<tr><td>
<td>
<td>
<td><em>
利用者が~tablet表面に単語を書いた
</em>
◎
User writes word on tablet surface

<tr><td>2.
<td>`compositionupdate$et
<td>`test^kGl
<td>

<tr><td>
<td>
<td>
<td><em>
利用者が~~候補として最初に挙げられた単語を却下して，異なる~~候補を選択した
</em>
◎
User rejects first word-match suggestion, selects different match

<tr><td>3.
<td>`compositionupdate$et
<td>`text^kGl
<td>

<tr><td>4.
<td>`compositionend$et
<td>`text^kGl
<td>
</table>

			</section>
			<section id="events-composition-canceling">
<h4 title="Canceling Composition Events">3.6.4. 組成~eventの取消~法</h4>
<p>
`keydown$et ~eventが取消された場合、
その `keydown$et の結果として発火されることになる
どの`組成~event$も，発火されるベキでない：
◎
If a keydown event is canceled then any Composition Events that would have fired as a result of that keydown SHOULD not be dispatched:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td><em>
`組成~event$は発火されない。
</em>
◎
No Composition Events are dispatched

<tr><td>2.
<td>`keyup$et
<td>
</table>

<p>
初期 `compositionstart$et ~eventが取消された場合、
~text組成~sessionは，終了されるベキである。
`compositionend$et ~eventは、
組成~sessionが終了されたかどうかに関わらず，送信するモノトスル。
◎
If the initial compositionstart event is canceled then the text composition session SHOULD be terminated. Regardless of whether or not the composition session is terminated, the compositionend event MUST be sent.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>

<tr><td>2.
<td>`compositionstart$et
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td><em>
【！複製】
`組成~event$は発火されない。
</em>
◎
No Composition Events are dispatched

<tr><td>3.
<td>`compositionend$et
<td>

<tr><td>4.
<td>`keyup$et
<td>
</table>

			</section>
			<section id="events-composition-key-events">
<h4 title="Key Events During Composition">3.6.5. 組成~時における~UIkey~event</h4>

<p>
組成~sessionの最中でも、
依然として［
`keydown$et, `keyup$et
］~eventは送信するモノトスル
— その `KeyboardEvent.isComposing$m 属性は ~T になるモノトスル。
◎
During the composition session, keydown and keyup events MUST still be sent, and these events MUST have the isComposing attribute set to true.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`KeyboardEvent.isComposing$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>~F
<td>
これが組成を起動した~UIkey~eventである。
◎
This is the key event that initiates the composition.
<tr><td>2.
<td>`compositionstart$et
<td>
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>

<tr><td>4.
<td>`keyup$et
<td>~T
<td>

<tr><td>
<td>...
<td>
<td>
組成~sessionの最中に送信された どの~UIkey~eventも，
`KeyboardEvent.isComposing$m は ~T に設定するモノトスル。
◎
Any key events sent during the composition session MUST have isComposing set to true.
<tr><td>5.
<td>`keydown$et
<td>~T
<td>
これが組成を終わらせた~UIkey~eventである。
◎
This is the key event that exits the composition.
<tr><td>6.
<td>`compositionend$et
<td>
<td>

<tr><td>7.
<td>`keyup$et
<td>~F
<td>
</table>

			</section>
			<section id="events-composition-input-events">
<h4 title="Input Events During Composition">3.6.6. 組成~sessionの間の入力~event</h4>

<p>
組成~sessionの間は、
その `compositionupdate$et は，
`beforeinput$et が送信された後, かつ
`input$et が送信される前に発火するモノトスル。
◎
During the composition session, the compositionupdate MUST be dispatched after the beforeinput is sent, but before the input event is sent.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`beforeinput$et
<td>

<tr><td>2.
<td>`compositionupdate$et
<td>

<tr><td>
<td>
<td><em>
~DOMの更新はこの時点で生じる。
</em>
◎
Any DOM updates occur at this point.

<tr><td>3.
<td>`input$et
<td>

</table>

<p class="note">注記：
ほとんどの~IMEは、
組成~sessionの間における更新の取消~法は~supportしない。
◎
Most IMEs do not support canceling updates during a composition session.
</p>

<p>
［
`beforeinput$et ／ `input$et
］~eventは、
組成の一部として~DOMが更新されるときに，
`compositionupdate$et ~eventに伴って送信される。
`compositionend$et ~eventに対しては，~DOMの更新はないので、［
`beforeinput$et ／ `input$et
］~eventは送信されるべきではない。
◎
The beforeinput and input events are sent along with the compositionupdate event whenever the DOM is updated as part of the composition. Since there are no DOM updates associated with the compositionend event, beforeinput and input events should not be sent at that time.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`beforeinput$et
<td>
これを取消したときは ~DOM更新と `input$et ~eventを防止することになる。
◎
Canceling this will prevent the DOM update and the input event.

<tr><td>2.
<td>`compositionupdate$et
<td>

<tr><td>
<td>
<td><em>
~DOMの更新はこの時点で生じる。
</em>
◎
Any DOM updates occur at this point.

<tr><td>3.
<td>`input$et
<td><em>
~DOMが更新された場合に限り送信される。
</em>
◎
Sent only if the DOM was updated.

<tr><td>4.
<td>`compositionend$et
<td>

</table>

			</section>
			<section id="events-composition-types">
<h4 title="Composition Event Types">3.6.7. 各種~組成~event型</h4>

				<section id="event-type-compositionstart">
<h5>3.6.7.1. `compositionstart^et</h5>

<div>
◎イ型 `compositionstart@et
◎界面 `CompositionEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作
`~text組成~system$が可能化されているならば，新たな組成~sessionを開始する。
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~組成~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`CompositionEvent.data$m：
編集-中にある【！元の】文字列, または`空~文字列$
</li>
</ul>
◎表終

◎
Type 	compositionstart
Interface 	CompositionEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Start a new composition session when a text composition system is enabled
Context
(trusted events) 	

• Event.target : focused element processing the composition
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the original string being edited, otherwise the empty string
</div>

<p>
~UAは、
`~text組成~system$が可能化されている下で，［
~textの一節を組成する準備として，新たな組成~sessionが始まりつつある
（または，`~text組成~system$に依存して始まった）
］とき，この~eventを発火するモノトスル。
この~event型は、
装置に依存し，［
~text変換~systemの能力,
~OSの中へ対応付けられる方法
］に依拠することもある。
この~event型は、
~IMEへの~~入力が~keyboardから投入された場合は，
`keydown$et ~eventの後に生成されるが、［
発話／手書き
］認識~systemにおいては
~keyboard~eventを伴わずに送信されてもヨイ。
実装は、
`compositionstart$et ~eventの `CompositionEvent.data$m 属性を［
文書にて現在（編集／置換~用に）選択されている~text
］で拡充してもヨイ
— そうしない場合、
`空~文字列$にするモノトスル。
◎
A user agent MUST dispatch this event when a text composition system is enabled and a new composition session is about to begin (or has begun, depending on the text composition system) in preparation for composing a passage of text. This event type is device-dependent, and MAY rely upon the capabilities of the text conversion system and how it is mapped into the operating system. When a keyboard is used to feed an input method editor, this event type is generated after a keydown event, but speech or handwriting recognition systems MAY send this event type without keyboard events. Some implementations MAY populate the data attribute of the compositionstart event with the text currently selected in the document (for editing and replacement). Otherwise, the value of the data attribute MUST be the empty string.
</p>

<p>
この~eventは、
`~text組成~system$が新たな組成~sessionを始める直前に, かつ
組成~処理により~DOMが改変される前に，発火するモノトスル。
この~eventの，`~text組成~system$用の既定~動作は、
新たな組成~sessionを開始させる。
この~eventが取消された場合、
`~text組成~system$は，現在の組成~sessionを破棄するベキである。
◎
This event MUST be dispatched immediately before a text composition system begins a new composition session, and before the DOM is modified due to the composition process. The default action of this event is for the text composition system to start a new composition session. If this event is canceled, the text composition system SHOULD discard the current composition session.
</p>

<p class="note">注記：
`compositionstart$et ~eventを取消すことと，`~text組成~system$自身を取消すこと
（例： 取消~buttonを叩いたり, `~IME$ ~UIwindowを閉じるなど）
とは、
別物である。
◎
Canceling the compositionstart event type is distinct from canceling the text composition system itself (e.g., by hitting a cancel button or closing an IME window).
</p>

<p class="note">注記：
~IMEには、
進捗-中にある組成~sessionの取消~法を~supportしないものもある
（例： GTK などは，~~現時点ではそのような~APIを備えていない）。
そのような事例では、
`preventDefault()$m を~callしても，この~eventの既定~動作は停止されないことになる。
◎
Some IMEs do not support cancelling an in-progress composition session (e.g., such as GTK which doesn’t presently have such an API). In these cases, calling preventDefault() will not stop this event’s default action.
</p>

				</section>
				<section id="event-type-compositionupdate">
<h5>3.6.7.2. `compositionupdate^et</h5>

<div>
◎イ型 `compositionupdate@et
◎界面 `CompositionEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~組成~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`CompositionEvent.data$m：
組成~sessionの現在の結果を成す文字列
— 内容が削除された場合、
`空~文字列$になることもある。
</li>
</ul>
◎表終

◎
Type 	compositionupdate
Interface 	CompositionEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : focused element processing the composition, null if not accessible
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the string comprising the current results of the composition session, which MAY be the empty string if the content has been deleted
</div>

<p>
~UAは、［
組成~sessionの最中に，`~text組成~system$が その作動中な~text一節を新たな文字で更新するとき
］に，この~eventを発火するベキである。
また、
配送するときは，
`CompositionEvent.data$m 値にその更新を反映するモノトスル。
◎
A user agent SHOULD dispatch this event during a composition session when a text composition system updates its active text passage with a new character, which is reflected in the string in data.
</p>

<p>
［
進行中な組成と入力~controlとの同期cを保つ
］ような `~text組成~system$においては、
`compositionupdate$et ~eventは，その~controlが更新される前に配送するモノトスル。
◎
In text composition systems which keep the ongoing composition in sync with the input control, the compositionupdate event MUST be dispatched before the control is updated.
</p>

<p>
`~text組成~system$には、
この情報を~DOMに公開しないものもある
— その場合、
この~eventは，組成~処理nの最中には発火されないことになる。
◎
Some text composition systems might not expose this information to the DOM, in which case this event will not fire during the composition process.
</p>

<p>
組成~sessionが取消された場合、
この~eventは， `compositionend$et ~eventの直前に
— その `CompositionEvent.data$m 属性を`空~文字列$に設定した上で —
発火されることになる。
◎
If the composition session is canceled, this event will be fired immediately before the compositionend event, and the data attribute will be set to the empty string.
</p>

				</section>
				<section id="event-type-compositionend">
<h5>3.6.7.3. `compositionend^et</h5>

<div>
◎イ型 `compositionend@et
◎界面 `CompositionEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次に挙げるものを除き，
`§ 各種~組成~eventに共通な文脈~情報$
を見よ：
</p>
<ul>
	<li>
`CompositionEvent.data$m：
組成~sessionの最終的な結果を成す文字列
— ［
内容が削除された／組成~処理nが取消された
］場合、
`空~文字列$になることもある。
</li>
</ul>
◎表終

◎
Type 	compositionend
Interface 	CompositionEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : focused element processing the composition
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the string comprising the final result of the composition session, which MAY be the empty string if the content has been deleted or if the composition process has been canceled
</div>

<p>
~UAは、［
`~text組成~system$が
現在の組成~sessionを
完了した, または取消された
］とき，この~eventを発火するモノトスル。
この~eventは、
~controlが更新された後に配送するモノトスル。
◎
A user agent MUST dispatch this event when a text composition system completes or cancels the current composition session, and the compositionend event MUST be dispatched after the control is updated.
</p>

<p>
この~eventは、
`~text組成~system$が組成~sessionを完了した直後に配送される
（例： `~IME$が［
閉じられた ／
最小~化された ／
~focusが他へ切替えられた ／
その他~退けられた
］後に，~focusが~~元の~UAに切替わったときなど）。
◎
This event is dispatched immediately after the text composition system completes the composition session (e.g., the IME is closed, minimized, switched out of focus, or otherwise dismissed, and the focus switched back to the user agent).
</p>

				</section>
			</section>
			<section id="_common-composition-event-context">
<h4>各種~組成~eventに共通な文脈~情報</h4>

集約簡略化

<p>
多くの組成~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
組成を処理している被focus要素。
~access可能でないならば~NULL。
◎
Event.target : focused element processing the composition, null if not accessible
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`§ 各種~UI~eventに共通な文脈~情報$を見よ。
</dd>
</dl>

			</section>
		</section>
	</section>
	<section id="keys">
<h2 title="Keyboard events and key values">4. ~keyboard~eventと~UIkey値</h2>

<!-- 
`KeyboardEvent!I
-->

<p>
この節では、
~keyboard~eventに関して必要yな情報を与える：
◎
This section contains necessary information regarding keyboard events:
</p>

<ul>
	<li>
~keyboard~layout,
`~UIkey対応付け$,
`~UIkey値$
についての説明。
◎
Explanation of keyboard layout, mapping, and key values.
</li>
	<li>
`~dead-key$や修飾~UIkeyなどの、
~UIkeyどうしの関係。
◎
Relations between keys, such as dead keys or modifiers keys.
</li>
	<li>
~keyboard~eventとその既定~動作との関係。
◎
Relations between keyboard events and their default actions.
</li>
	<li>
`key^m 値の集合, および
この集合を拡張する方法についての指針。
◎
The set of key values, and guidelines on how to extend this set.
</li>
</ul>

<p class="note">注記：
この節では、
~Serbianと漢字を利用する。
【！which could be misrepresented or unavailable...】
◎
This section uses Serbian and Kanji characters which could be misrepresented or unavailable in the PDF version or printed version of this specification.
</p>

		<section id="keyboard-input">
<h3 title="Keyboard Input">4.1. ~keyboard入力</h3>

◎非規範的

<p>
完全な~keyboardの各~UIkeyの関係性には，次に挙げる別々な側面があり、
いずれも
— 特に，~localeに特有な理由で —
~keyboard機種や環境設定により様々になる：
◎
The relationship of each key to the complete keyboard has three separate aspects, each of which vary among different models and configurations of keyboards, particularly for locale-specific reasons:
</p>

<ul>
	<li>
<strong>物理的0な~layout</strong>：
~keyboard上での物理的な~UIkeyの
寸法, ~size, ~~配置
◎
Mechanical layout: the dimensions, size, and placement of the physical keys on the keyboard
</li>
	<li>
<strong>視覚的な目印</strong>：
各~UIkeyを印字する~label（または `銘^em）
◎
Visual markings: the labels (or legends) that mark each key
</li>
	<li>
<strong>機能上の`~UIkey対応付け$</strong>：
各~UIkey用の抽象的な ~UIkey ↔ 値の結付け。
◎
Functional mapping: the abstract key-value association of each key.
</li>
</ul>

<p>
この仕様は、
<a href="#keys-keyvalues">`key^m 値</a>
および
<a href="#keys-codevalues">`code^m 値</a>
を通して，機能上の`~UIkey対応付け$のみを定義するが、
背景0として，
`~UIkey銘＠#key-legends$についても概括する。
◎
This specification only defines the functional mapping, in terms of key values and code values, but briefly describes key legends for background.
</p>

			<section id="key-legends">
<h4 title="Key Legends">4.1.1. ~UIkey銘</h4>

◎非規範的

<p>
~UIkey銘（ `key legend^en ）とは、
その `~UIkey~cap^em
（~UIkeyの物理的0な~switchを覆う “~cap” ）
上に印刷されたり, 彫り込まれている，視覚的な目印である。
この種の目印は、
通常は，その~UIkeyに対する~keystrokeが生産するような 1 個~以上の文字からなる（例： `G^kGl, `8^kGl, `ш^kGl ）, 
あるいは その~UIkeyの機能を指示する名前や記号
（例： `Shift^cap を指示する上向き矢印 `⇧^kGl, 文字列 "Enter" など）。
~UIkeyは、
この目印で指されることが多い
（例： “ Shift ＋ F ~UIkeyを押してください。” ）。
しかしながら、
~UIkeyの視覚的な見かけは，その~digital表現とは~~関係ないものであり、
多くの環境設定で，まったく正確aでないものにもなり得る。
`Enter^cap などの［
制御~UIkey／~function~UIkey
］であっても，［
機能性が異なるものや文字~UIkey
］に対応付けられることすら あり得る。
◎
The key legend is the visual marking that is printed or embossed on the key cap (the rectangular "cap" that covers the mechanical switch for the key). These markings normally consist of one or more characters that a keystroke on that key will produce (such as "G", "8", or "ш"), or names or symbols which indicate that key’s function (such as an upward-pointing arrow "⇧" indicating Shift, or the string "Enter"). Keys are often referred to by this marking (e.g., "Press the "Shift" and "G" keys."). Note, however, that the visual appearance of the key has no bearing on its digital representation, and in many configurations may be completely inaccurate. Even the control and function keys, such as Enter, may be mapped to different functionality, or even mapped as character keys.
</p>

<p class="note">注記：
多くの~keyboardは、
~Unicode等価な記号があっても，通常は文字を生産しない~UIkeyを備えている。
例えば， `Shift^cap ~UIkeyには、
記号 `⇧^kGl （~Unicode符号位置 `21E7^U ）が付けられることもあるが，
`Shift^cap ~UIkeyだけ押しても この`文字~値$を生産することはないし,
`Shift^cap に対応する~Unicode符号位置もない。
◎
Many keyboards contain keys that do not normally produce any characters, even though the symbol might have a Unicode equivalent. For example, the Shift key might bear the symbol "⇧", which has the Unicode code point U+21E7, but pressing the Shift key will not produce this character value, and there is no Unicode code point for Shift.
</p>
			</section>
		</section>
		<section id="keys-codevalues">
<h3 title="Key codes">4.2. ~UIkey~code</h3>

<p>
~keyboard~eventに結付けられた物理的~UIkeyを識別するときは、
~keyboard~eventの `code$m 属性で指示される~UIkey~codeを利用できる。
それは、
USB Usage ID に類似な, ~vendor中立な, 低~levelな（~scancodeに類似な）値を供する。
◎
A key code is an attribute of a keyboard event that can be used to identify the physical key associated with the keyboard event. It is similar to USB Usage IDs in that it provides a low-level value (similar to a scancode) that is vendor-neutral.
</p>

<p>
`code$m 属性の首な目的は、
~UIkeyを その物理的~所在に基づいて識別するための，首尾一貫する仕方を供することである。
加えて、
~keyboardの各~UIkeyに（現在の~keyboard状態に影響されないような）安定的な名前も供して，それらを一意に識別する。
◎
The primary purpose of the code attribute is to provide a consistent and coherent way to identify keys based on their physical location. In addition, it also provides a stable name (unaffected by the current keyboard state) that uniquely identifies each key on the keyboard.
</p>

<p>
妥当な `code^m 値たちが成す~listは、
`UIEvents-Code$r にて定義される。
◎
The list of valid code values is defined in the [UIEvents-Code].
</p>

			<section id="code-motivation">
<h4 title="Motivation for the code Attribute">4.2.1. `code^m 属性の動機</h4>

<p>
標準的な~PC~keyboardが備えている一群の~UIkeyが生成する `key$m 値は、
利用者が現在~選択している（利用している書記体系に適切な）~keyboard~layoutにより異なる。
このような状況では、
~UIkeyをその物理的~所在に基づいて検出するような~codeを書くことは困難になる
— ~codeが，どの `key^m 値を検査すればよいか知るためには、
現在~有効な~layoutがどれなのかを知る必要があるので。
現実の例として、
~playerの動きを制御するために［
`W^kGl, `A^kGl, `S^kGl, `D^kGl
］~UIkeyを利用する~gameがある。
`code$m 属性は、
それを検査するための，`現在の~keyboard~layoutに影響されない^em, 安定的な値を供して、
この問題を解消する。
◎
The standard PC keyboard has a set of keys (which we refer to as writing system keys) that generate different key values based on the current keyboard layout selected by the user. This situation makes it difficult to write code that detects keys based on their physical location since the code would need to know which layout is in effect in order to know which key values to check for. A real-world example of this is a game that wants to use the "W", "A", "S" and "D" keys to control player movement. The code attribute solves this problem by providing a stable value to check that is not affected by the current keyboard layout.
</p>

<p>
加えて、
`key$m 属性がとる値は，現在の~keyboard状態にも依存する。
このため、
修飾~UIkeyと他の~UIkeyが［
押される／離される
］順序も， `key$m 属性に格納される値に影響し得る。
`code$m 属性は、
`現在の~keyboard~layoutに影響されない^em,
安定的な値を供して、
この問題を解消する。
◎
In addition, the values in the key attribute depend as well on the current keyboard state. Because of this, the order in which keys are pressed and released in relation to modifier keys can affect the values stored in the key attribute. The code attribute solves this problem by providing a stable value that is not affected by the current keyboard state.
</p>
			</section>
			<section id="relationship-between-key-code">
<h4 title="The Relationship Between key and code">4.2.2. `key^m と `code^m の関係性</h4>

<dl>
	<dt>`key^m</dt>
	<dd>
`key$m 属性に意図されている用途は、
押されている~UIkeyの意味に基づくふるまいを得ることである
— その値には、
現在の~keyboard~layoutに加えて，~IMEも織り込まれる
（`~dead-key＠#keys-dead$ には，一意な `key^m 値が与えられる）。
例えば、［
~UIkeyが修飾~UIkeyを伴うかどうかや
~~素の修飾~UIkey
］を検出する利用事例がある
（例：~keyboard~shortcutに呼応して何らかの動作を遂行するためなど）。
◎
The key attribute is intended for users who are interested in the meaning of the key being pressed, taking into account the current keyboard layout (and IME; dead keys are given a unique key value). Example use case: Detecting modified keys or bare modifier keys (e.g., to perform an action in response to a keyboard shortcut).
</dd>

	<dt>`code^m</dt>
	<dd>
`code$m 属性に意図されている用途は、
利用者により押された~UIkeyそのもの
— ~keyboard~layoutにより改変されないままの~UIkey —
に基づくふるまいを得ることである。
例えば、
~gameにおける動き制御~用に［
`W^cap, `A^cap, `S^cap, `D^cap
］~UIkeyを検出したり、
すべての~UIkeyを~trapする
（例： すべての~UIkeyを~remote~hostに送信する~remote~desktop~client）
などの利用事例がある。
◎
The code attribute is intended for users who are interested in the key that was pressed by the user, without any layout modifications applied. Example use case: Detecting WASD keys (e.g., for movement controls in a game) or trapping all keys (e.g., in a remote desktop client to send all keys to the remote host).
</dd>
</dl>

			</section>
			<section id="code-examples">
<h4 title="code Examples">4.2.3. ~code例</h4>

<div class="example">
<p>
左右 Alt ~UIkeyの取扱い：
◎
Handling the Left and Right Alt Keys
</p>

<!-- 
`KeyboardEvent!I
-->

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<th>備考
<tbody>

<tr><td>US
<td>`Alt$kY
<td>`AltLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>~French
<td>`Alt$kY
<td>`AltLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>US
<td>`Alt$kY
<td>`AltRight$kC
<td>`DOM_KEY_LOCATION_RIGHT^m

<tr><td>~French
<td>`AltGraph$kY
<td>`AltRight$kC
<td>`DOM_KEY_LOCATION_RIGHT^m
</table>

<p>
この例は、［
`key$m 属性を検査すれば，左右どちらの `Alt^cap ~UIkeyが押されたか気にせずに `Alt^cap と照合できる
］ことを示している。
`code$m 属性を検査すれば，現在~有効な~layoutが何かを気にすることなく
右 `Alt^cap ~UIkey（ `AltRight$kC ）と照合できるようになる。
◎
In this example, checking the key attribute permits matching Alt without worrying about which Alt key (left or right) was pressed. Checking the code attribute permits matching the right Alt key ("AltRight") without worrying about which layout is currently in effect.
</p>

<p>
~Frenchの例では、［
`Alt^cap ／ `AltGraph^cap
］~UIkeyは どちらも 1 個しかないが，それらの［
左／右
］の所在は維持されることに注意。
◎
Note that, in the French example, the Alt and AltGraph keys retain their left and right location, even though there is only one of each key.
</p>
</div>

<div class="example">
<p>
Single Quote ~UIkeyの取扱い：
◎
Handling the Single Quote Key
</p>

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<tbody>

<tr><td>US
<td>`'^kY
<td>`Quote$kC

<tr><td>日本語
<td>`:^kY
<td>`Quote$kC

<tr><td>US Intl
<td>`Dead$kY
<td>`Quote$kC
</table>

<p>
この例は、
属性において，~dead-key値がどう符号化されるかを示している。
`key^m 値は，現在の~localeに基づいて様々になる一方、
`code$m 属性は，一貫した値を返す。
◎
This example shows how dead key values are encoded in the attributes. The key values vary based on the current locale, whereas the code attribute returns a consistent value.
</p>
</div>

<div class="example" id="example-key-2">

<p>
種々の~keyboard~layoutにおける
`2^kGl ~UIkeyの取扱い
（ Shift も押したとき／押さないとき）：
◎
Handling the "2" Key (with and without Shift pressed) on various keyboard layouts.
</p>

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<th>Shift の有無
<tbody>

<tr><td>US
<td>`2^kY
<td>`Digit2$kC
<td>

<tr><td>US
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>UK
<td>`2^kY
<td>`Digit2$kC
<td>

<tr><td>UK
<td>`"^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>~French
<td>`é^kY
<td>`Digit2$kC
<td>

<tr><td>~French
<td>`2^kY
<td>`Digit2$kC
<td>`shiftKey$m
</table>

<p>
現在の~localeや修飾~UIkey状態に関わらず，
~US~keyboardで~UIkey `2^kGl の~UIkeyを押したときの `code$m 属性の結果は、
常に `Digit2$kC になる。
◎
Regardless of the current locale or the modifier key state, pressing the key labelled "2" on a US keyboard always results in "Digit2" in the code attribute.
</p>
</div>

<div class="example" id="example-key-shift-2">

<p>
~keyboard~event連列：
`Shift^cap ＆ `2^cap
◎
Sequence of Keyboard Events : Shift and 2
</p>

<p>
次では、
2 つの~UIkey~event連列における属性~値を比較する。
それらは いずれも
~US~keyboardでは 文字 `~aT^kGl を生産するが、
~UIkeyが離される順序により相違する。
最初の例の連列の順序は：
`Shift^cap （押） →
`2^cap （押） →
`2^cap（離） →
`Shift^cap（離）。
◎
Compare the attribute values in the following two key event sequences. They both produce the "@" character on a US keyboard, but differ in the order in which the keys are released. In the first sequence, the order is: Shift (down), 2 (down), 2 (up), Shift (up).
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`code$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>2.
<td>`keydown$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>3.
<td>`keypress$et
<td>`~aT^kY
<td>`Digit2$kC
<td>（~support有りなら）

<tr><td>4.
<td>`keyup$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m
</table>

<p>
次の例の連列は、
2 を離すより先に Shift を離した場合：
`Shift^cap（押） →
`2^cap（押） →
`Shift^cap（離） →
`2^cap（離）。
◎
In the second sequence, the Shift is released before the 2, resulting in the following event order: Shift (down), 2 (down), Shift (up), 2 (up).
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`code$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>2.
<td>`keydown$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>3.
<td>`keypress$et
<td>`~aT^kY
<td>`Digit2$kC
<td>（~support有りなら）

<tr><td>4.
<td>`keyup$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>5.
<td>`keyup$et
<td>`2^kY
<td>`Digit2$kC
<td>
</table>

<p>
~UIkey `2^kGl については、
`key$m 属性の値が
`keydown$et ~eventと `keyup$et ~eventとの間で合致しないことに注意。
`code$m 属性は、
現在の修飾~状態に影響されず，一貫した値を供する。
◎
Note that the values contained in the key attribute does not match between the keydown and keyup events for the "2" key. The code attribute provides a consistent value that is not affected by the current modifier state.
</p>
</div>

			</section>
			<section id="code-virtual-keyboards">
<h4 title="code and Virtual Keyboards">4.2.4. `code^m と~virtual~keyboard</h4>
<p>
`code$m 属性の有用性は、
~virtual~keyboardに対しては明白でない
（~remote-control~keyboardや複数~UIkeyの同時押下げに対しても）。
~virtual（または~remote-control）~keyboardに対しては、
標準的な~keyboardの
~layout／機能性
を真似ているものについては，
`code$m 属性を適切に設定するモノトスル。
真似ていない~keyboardについては、
標準的な~keyboardになるべく近いものに設定するか, または
未定義なままにしてもヨイ。
◎
The usefulness of the code attribute is less obvious for virtual keyboards (and also for remote controls and chording keyboards). In general, if a virtual (or remote control) keyboard is mimicking the layout and functionality of a standard keyboard, then it MUST also set the code attribute as appropriate. For keyboards which are not mimicking the layout of a standard keyboard, then the code attribute MAY be set to the closest match on a standard keyboard or it MAY be left undefined.
</p>

<p>
修飾~状態に基づいて異なる値を生産する~UIkeyを伴うような~virtual~keyboardに対しては、
`code^m 値は，［
装置がその工場出荷~状態にある下で~buttonが押された
］ときに生成される `key^m 値になるベキである。
◎
For virtual keyboards with keys that produce different values based on some modifier state, the code value should be the key value generated when the button is pressed while the device is in its factory-reset state.
</p>

			</section>
		</section>
		<section id="keys-keyvalues">
<h3 title="Keyboard Event key Values">4.3. ~keyboard~eventの `key^m 値</h3>

<div class="p">
<p>
`~UIkey値$は、
~keyboard上の任意の~UIkeyを
— その位置や状態に関わらず —
それが生産する値で指示するために利用できる `DOMString^I である。
これらの~UIkey値は、
次に挙げるものに利用できる／され得る：
</p>
<ul>
	<li>
実装により生成される~keyboard~event用の返り値
</li>
	<li>
内容~作者から欲される入力（~keyboard~shortcutなど）を指定するための入力~値
</li>
</ul>
◎
A key value is a DOMString that can be used to indicate any given key on a keyboard, regardless of position or state, by the value it produces. These key values MAY be used as return values for keyboard events generated by the implementation, or as input values by the content author to specify desired input (such as for keyboard shortcuts).
</div>

<p>
妥当な `key^m 値たちが成す~listは `UIEvents-Key$r にて定義される。
◎
The list of valid key values is defined in [UIEvents-Key].
</p>

<p>
`~UIkey値$は、
`key$m 属性を利用して，押された~UIkeyの値を検出するときに利用される値である。
内容~作者は、［
大文字や小文字, 数字n, 記号
］その他，文字を生産する~UIkeyに対しては その`文字~値$を検索取得でき、［
制御~UIkey, 修飾~UIkey, ~function~UIkey
］その他，文字を生産しない~UIkeyに対しては その`~UIkey値$を検索取得できる。
これらの値は、［
特定0の入力~文字列を監視する ／
他の入力（~mouseなど）との組合nで 修飾~UIkey入力を検出して動作する ／
~virtual~keyboardを作成する
］その他，いくつもの目的に利用できる。
◎
Key values can be used to detect the value of a key which has been pressed, using the key attribute. Content authors can retrieve the character value of upper- or lower-case letters, number, symbols, or other character-producing keys, and also the key value of control keys, modifier keys, function keys, or other keys that do not generate characters. These values can be used for monitoring particular input strings, for detecting and acting on modifier key input in combination with other inputs (such as a mouse), for creating virtual keyboards, or for any number of other purposes.
</p>

<p>
内容~作者は、
`~UIkey値$を文字列~比較にも利用できる
—
適合`~host言語$における~markup属性~用の値（~HTMLの `accesskey^a など）として, あるいは
他の関係する目的に。
適合`~host言語$は、
`~UIkey値$用の 2 つの等価な文字列~値
— `文字~値$, `~UIkey値$ —
どちらも利用できることを内容~作者に許容するベキである。
◎
Key values can also be used by content authors in string comparisons, as values for markup attributes (such as the HTML accesskey) in conforming host languages, or for other related purposes. A conforming host language SHOULD allow content authors to use either of the two equivalent string values for a key value: the character value, or the key value.
</p>

<p class="note">注記：
実装は、
所与の~UIkey用に
— ~platformや~keyboard~layout用の`~UIkey対応付け$からは独立に —
最も関連な値を利用することになる一方、
内容~作者は，それらを生成する~keyboard装置の能について前提を置けない。
内容~作者は、
~shortcut~UIkeyの組合nとして~keyboard~eventと~UIkey値を利用するときには，普通字の代わりに
数字n~UIkey, ~function~UIkey（ `F4^cap, `F5^cap, 等々）の利用も考慮できる（ `DWW95$r ）
— ほとんどの~keyboard~layoutは，それら用の~UIkeyを供するので。
◎
While implementations will use the most relevant value for a key independently of the platform or keyboard layout mappings, content authors can not make assumptions on the ability of keyboard devices to generate them. When using keyboard events and key values for shortcut-key combinations, content authors can "consider using numbers and function keys (F4, F5, and so on) instead of letters" ([DWW95]) given that most keyboard layouts will provide keys for those.
</p>

<p>
`~UIkey値$は、
物理的な~keyboard上の特定の~UIkeyを指示するものでも，
~UIkey上に印刷された文字を反映するものでもない。
~UIkey値は、
作動中な［
~UIkeyすべて／~UIkey入力~mode（~shift~modeを含む）の現在の状態
］が考慮に入れられ，~OSによる~keyboard用の`~UIkey対応付け$に反映され, 実装に報告されるような，~eventの現在の値を指示する。
例えば、［
`QWERTY$ ~keyboardの `O^cap ~UIkey
］の~UIkey値は，［
~shiftなしなら `o^kY ／
~shiftありなら `O^kY
］になる。
利用者は，自身の~keyboardを任意な~custom環境設定に対応付けれるので、
内容~作者には，［
~UIkeyの~shiftの有無と, 文字~表現の［
大文字形, 小文字形
］との間に関係性が存在する
］ものと見做すことなく， `key$m 属性の値を利用することが奨励される。
例えば、
`D3E-code$r にて図面化されている標準的な “102 ~keyboard” ~layoutは、
あるアリな~keyboard~layoutにおける，`~UIkey対応付け$が成す集合としてアリな一つを図示する。
他にも、
標準なもの, 独特なものが多数 存在する。
◎
A key value does not indicate a specific key on the physical keyboard, nor does it reflect the character printed on the key. A key value indicates the current value of the event with consideration to the current state of all active keys and key input modes (including shift modes), as reflected in the operating-system mapping of the keyboard and reported to the implementation. In other words, the key value for the key labeled O on a QWERTY keyboard has the key value "o" in an unshifted state and "O" in a shifted state. Because a user can map their keyboard to an arbitrary custom configuration, the content author is encouraged not to assume that a relationship exists between the shifted and unshifted states of a key and the majuscule form (uppercase or capital letters) and minuscule form (lowercase or small letters) of a character representation, but is encouraged instead to use the value of the key attribute. For example, the Standard "102" Keyboard layout depicted in [UIEvents-Code] illustrates one possible set of key mappings on one possible keyboard layout. Many others exist, both standard and idiosyncratic.
</p>

<p class="note">注記：
`~dead-key$用の~supportを単純~化するため、
~OSによる~keyboard用の`~UIkey対応付け$が`~dead-key$状態を取扱うとき，
~dead-key連列の現在の状態は `key$m 属性を介しては報告されず，
代わりに`~UIkey値$ `Dead$kY が報告される。
実装は、
代わりに［
~dead-key連列の中間的な状態を包含する，一連の`組成~event$
］を生成して，それを `CompositionEvent.data$m 属性を介して報告する。
前掲の例と同様に，［
`QWERTY$ ~keyboardの `O^cap と印字された~UIkey用の`~UIkey値$には，
~dead-key操作oの最中に~umlaut発音区別符が追加される
］ので、
`CompositionEvent.data$m 値は，
~shiftなしなら `ö^kGl になり,
~shiftありなら `Ö^kGl になる。
◎
To simplify dead key support, when the operating-system mapping of the keyboard is handling a dead key state, the current state of the dead key sequence is not reported via the key attribute. Rather, a key value of "Dead" is reported. Instead, implementations generate composition events which contain the intermediate state of the dead key sequence reported via the data attribute. As in the previous example, the key value for the key marked O on a QWERTY keyboard has a data value of "ö" in an unshifted state during a dead-key operation to add an umlaut diacritic, and "Ö" in a shifted state during a dead-key operation to add an umlaut diacritic.
</p>

<p>
また、
~UIkey~eventの各~状態と各`~UIkey値$との間には，
一対一の関係性はないことにも特に注意。
複数の~UIkeyが特定0の~UIkey値に結付けられることもある。
例えば，多くの標準的な~keyboardは、
`Shift^cap ~UIkeyや `8^cap ~UIkeyを複数~備えている
（通常は、
いずれも `location$m 値で判別される
— 前者は［
`DOM_KEY_LOCATION_LEFT$m ／ `DOM_KEY_LOCATION_RIGHT$m
］で，後者は［
`DOM_KEY_LOCATION_STANDARD$m ／ `DOM_KEY_LOCATION_NUMPAD$m
］で）。
また，利用者により環境設定された~custom~keyboard~layoutは、
どの~UIkey値にも複数の~UIkey状態が対応~付けられ得る
（ `location$m は、
標準的な~keyboard~layout~~用途に意図されていることに注意
— 有意義な~~区別を常に指示できるわけではない）。
◎
It is also important to note that there is not a one-to-one relationship between key event states and key values. A particular key value might be associated with multiple keys. For example, many standard keyboards contain more than one key with the Shift key value (normally distinguished by the location values DOM_KEY_LOCATION_LEFT and DOM_KEY_LOCATION_RIGHT) or 8 key value (normally distinguished by the location values DOM_KEY_LOCATION_STANDARD and DOM_KEY_LOCATION_NUMPAD), and user-configured custom keyboard layouts MAY duplicate any key value in multiple key-state scenarios (note that location is intended for standard keyboard layouts, and cannot always indicate a meaningful distinction).
</p>

<p>
~~最後に、
与えられた文字~表現の意味は，文脈に依存する上に複階的である。
例えば，一部の文脈では、
~asterisk~glyph（ `*^kGl ）は，脚注や強勢を表現する
（~textの一節を~~括るとき）。
しかしながら，［
それ／その機能
］は、
文書や実行-可能な~programによっては，
数学的な乗算に等価であることも,
乗算~記号（ `×^kGl, ~Unicode `00D7^U ）として予約-済みなことも,
~~英小文字 "x" （ `Latin small letter x^cn ）であることもある
（多くの~keyboardが乗算~UIkeyを欠くこと，あるいは `×^kGl と `x^kGl のような~glyphの~~外見上の~~類似に因り）。
したがって、［
意味論上の意味, 文字~表現の機能
］は，この仕様の視野から外れる。
◎
Finally, the meaning of any given character representation is context-dependent and complex. For example, in some contexts, the asterisk (star) glyph ("*") represents a footnote or emphasis (when bracketing a passage of text). However, in some documents or executable programs it is equivalent to the mathematical multiplication operation, while in other documents or executable programs, that function is reserved for the multiplication symbol ("×", Unicode value U+00D7) or the Latin small letter "x" (due to the lack of a multiplication key on many keyboards and the superficial resemblance of the glyphs "×" and "x"). Thus, the semantic meaning or function of character representations is outside the scope of this specification.
</p>

			<section id="keys-modifiers">
<h4 title="Modifier keys">4.3.1. 修飾~UIkey</h4>

<p>
修飾~UIkeyを利用する~keyboard入力は、
~UIkeyの通常の挙動を変化させる。
他の~UIkeyと同様、
修飾~UIkeyは，下の例に示すとおり［
`keydown$et ／ `keyup$et
］~eventを生成する。
修飾~UIkeyには、
押されている間 作動化されるものもあれば
（
`Alt^cap,
`Control^cap,
`Shift^cap,
`AltGraph^cap,
`Meta^cap
など）、
状態を持ち，その状態に依存して作動化されるものもある
（
`CapsLock^cap,
`NumLock^cap,
`ScrollLock^cap
など）。
状態の変化は、
修飾~UIkeyが押されたときに起こる。
`KeyboardEvent!I ~interfaceは、
一部の共通的な修飾~UIkeyに対し，簡便な属性
— `ctrlKey$m, `shiftKey$m, `altKey$m, `metaKey$m —
を供する。
一部の~OSは、
修飾~UIkey `AltGraph^cap を，修飾~UIkey `Alt^cap, `Control^cap の組合nで模倣する。
実装には、
`AltGraph^cap 修飾~UIkeyを利用することが奨励される。
◎
Keyboard input uses modifier keys to change the normal behavior of a key. Like other keys, modifier keys generate keydown and keyup events, as shown in the example below. Some modifiers are activated while the key is being pressed down or maintained pressed such as Alt, Control, Shift, AltGraph, or Meta. Other modifiers are activated depending on their state such as CapsLock, NumLock, or ScrollLock. Change in the state happens when the modifier key is being pressed down. The KeyboardEvent interface provides convenient attributes for some common modifiers keys: ctrlKey, shiftKey, altKey, metaKey. Some operating systems simulate the AltGraph modifier key with the combination of the Alt and Control modifier keys. Implementations are encouraged to use the AltGraph modifier key.
</p>

<p>
次の例に、
~US~keyboardで, ~US用の`~UIkey対応付け$を利用している下で，
~Unicode文字 Q（ `0051^U `Latin Capital Letter Q^cn ）
が生成されるときにアリな~event連列を述べる：
◎
This example describes a possible sequence of events associated with the generation of the Unicode character Q (Latin Capital Letter Q, Unicode code point U+0051) on a US keyboard using a US mapping:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>`shiftKey$m
<td>`Latin Capital Letter Q^cn

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Q^kY
<td>`shiftKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
</table>
</div>

<p>
次の例に、
上の例において， `Q^cap ~UIkeyを離す前に `Shift^cap ~UIkeyを離したとき，
代わりに生じ得る~UIkey連列を述べる。
~UIkey `Q^cap 用の`~UIkey値$は、
`keyup$et ~eventに対しては，その無shift値に復帰することになる：
◎
Th example describes an alternate sequence of keys to the example above, where the Shift key is released before the Q key. The key value for the Q key will revert to its unshifted value for the keyup event:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>`shiftKey$m
<td>`Latin Capital Letter Q^cn

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`q^kY
<td>
<td>`Latin Small Letter Q^cn
</table>
</div>

<p>
次の例に、
~Unicode文字を生成しないときにアリな~UIkeyの連列を述べる
（前の例と同じ環境設定の下で）:
◎
The following example describes a possible sequence of keys that does not generate a Unicode character (using the same configuration as the previous example):
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`v^kY
<td>`ctrlKey$m
<td>`Latin Small Letter V^cn

<tr><td>
<td colspan="4"><em>
`beforeinput$et／`input$et
~eventは生成されない。
</em>
◎
No beforeinput or input events are generated.

<tr><td>3.
<td>`keyup$et
<td>`v^kY
<td>`ctrlKey$m
<td>`Latin Small Letter V^cn

<tr><td>4.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</table>
</div>

<p>
次の例に，
`Shift^cap, `Control^cap が両者とも押されたときの~event連列を示す：
◎
The following example shows the sequence of events when both Shift and Control are pressed:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Shift$kY
<td>`ctrlKey$m, `shiftKey$m
<td>

<tr><td>3.
<td>`keydown$et
<td>`V^kY
<td>`ctrlKey$m, `shiftKey$m
<td>`Latin Capital Letter V^cn

<tr><td>
<td colspan="4"><em>
【！複製】
`beforeinput$et／`input$et
~eventは生成されない。
</em>
◎
No beforeinput or input events are generated.

<tr><td>4.
<td>`keyup$et
<td>`V^kY
<td>`ctrlKey$m, `shiftKey$m
<td>`Latin Capital Letter V^cn

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>`ctrlKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</table>
</div>

<p>
非~US~keyboard~layoutに対しても，~event連列は同じになるが、
~UIkeyの値は，現在の~keyboard~layoutに基づく。
次の例に，~Arabic~keyboard~layoutが利用されるときの~event連列を示す：
◎
For non-US keyboard layouts, the sequence of events is the same, but the value of the key is based on the current keyboard layout. This example shows a sequence of events when an Arabic keyboard layout is used:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`&#x631;^kY
<td>`ctrlKey$m
<td>`Arabic Letter Reh^cn

<tr><td>
<td colspan="4">
【！複製】
`beforeinput$et／`input$et
~eventは生成されない。
◎
No beforeinput or input events are generated.

<tr><td>3.
<td>`keyup$et
<td>`&#x631;^kY
<td>`ctrlKey$m
<td>`Arabic Letter Reh^cn

<tr><td>4.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</table>
</div>

<p class="note">注記：
［
`keydown$et ／ `keyup$et
］~eventにおける値は、
~UIkeyが押されたときに有効な現在の~keyboard~layoutに基づいて，様々になる。
これは、
同じ物理的~UIkeyであっても、
~US~layout上の `v^cap ~UIkey と ~Arabic~layout上の `&#x631;^cap ~UIkeyとでは，
異なる~eventを生成することを意味する。
これらの~eventを同じ物理的~UIkeyとして識別するためには、
`code$m 属性を利用する必要がある。
◎
The value in the keydown and keyup events varies based on the current keyboard layout in effect when the key is pressed. This means that the v key on a US layout and the ر key on an Arabic layout will generate different events even though they are the same physical key. To identify these events as coming from the same physical key, you will need to make use of the code attribute.
</p>

<p>
修飾~UIkeyが，~UIkey~event用の`~UIkey値$を変化させる事例もある。
例えば，一部の MacOS ~keyboard上の “delete” ~UIkeyは、
未修飾~時にはWindows ~OS上の `Backspace^cap ~UIkeyと同じに機能するが、
`Fn^cap ~UIkeyで修飾されたときは `Delete^cap ~UIkeyとして動作し，
~UIkey値は 現在の修飾された状態に最も適切な~UIkeyの機能に合致することになる。
◎
In some cases, modifier keys change the key value for a key event. For example, on some MacOS keyboards, the key labeled "delete" functions the same as the Backspace key on the Windows OS when unmodified, but when modified by the Fn key, acts as the Delete key, and the value of key will match the most appropriate function of the key in its current modified state.
</p>

			</section>
			<section id="keys-dead">
<h4 title="Dead keys">4.3.2. ~dead-key</h4>

<p>
~keyboard入力では、
`~dead-key$を利用して組成-済み文字~連列を入力することもある。
手書き式に最初に基底~文字を手入力するのでなく、
そこでの~keyboard入力には，特別な状態に入ることが要求され、
`~dead-key$が押された~~直後では，限られた数の “合法な” 基底~文字が手入力されたときに限り，文字（たち）を発する。
◎
Some keyboard input uses dead keys for the input of composed character sequences. Unlike the handwriting sequence, in which users enter the base character first, keyboard input requires to enter a special state when a dead key is pressed and emit the character(s) only when one of a limited number of "legal" base character is entered.
</p>

<p class="note">注記：
［
MacOS ／ Linux ~OS
］は、
`~dead-key$を処理するときに~IMEを利用する。
◎
The MacOS and Linux operating systems use input methods to process dead keys.
</p>

<p>
`~dead-key$は、
（すべての~keyboard~layout, `~UIkey対応付け$に渡り，）
`~UIkey値$ `Dead$kY で表現される。
~dead-keyが押されたときは、
~UAは それに呼応して，`組成~event$たちを発火するモノトスル。
加えて、
その
`compositionupdate$et ~eventの `CompositionEvent.data$m 値は，~dead-key結合~連列の現在の状態の`文字~値$になるモノトスル。
◎
The dead keys (across all keyboard layouts and mappings) are represented by the key value Dead. In response to any dead key press, composition events must be dispatched by the user agent and the compositionupdate event’s data value must be the character value of the current state of the dead key combining sequence.
</p>

<p>
~Unicode結合~文字は，常に［
対応する普通字とそれに続く結合~文字による手書き連列
］に倣う一方で、
代表的な~dead-key入力では，その結合~文字が対応する普通字の前に来るように連列を逆順にすることもある。
例えば，単語 "naïve" は、
結合~発音区別符 "¨" を利用して，~Unicodeでは
"nai¨ve"
として連列的に表現されるが、
"na¨ive" と打込まれ得る。
~keystroke連列［
`0302^U （ `Combining Circumflex Accent^cn ~UIkey）,
`0065^U （ `Latin Small Letter E^cn と印字される~UIkey）
］は，［
`NFC^em （ `Unicode Normalization Form^en ）に選好される ~Unicode文字
`ê^kGl （ `Latin Small Letter E With Circumflex^cn ）
］を生産するであろう
（~French~keyboardでは、
修飾~UIkeyを作動化させずに，~French用の`~UIkey対応付け$を利用して）。
◎
While Unicode combining characters always follow the handwriting sequence, with the combining character trailing the corresponding letter, typical dead key input MAY reverse the sequence, with the combining character before the corresponding letter. For example, the word naïve, using the combining diacritic ¨, would be represented sequentially in Unicode as nai¨ve, but MAY be typed na¨ive. The sequence of keystrokes U+0302 (Combining Circumflex Accent key) and U+0065 (key marked with the Latin Small Letter E) will likely produce (on a French keyboard using a french mapping and without any modifier activated) the Unicode character "ê" (Latin Small Letter E With Circumflex), as preferred by the Unicode Normalization Form NFC.
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>~F
<td>
<td>`Combining Circumflex Accent^cn （~dead-key）

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`0302^U
<td>

<tr><td>4.
<td>`keyup$et
<td>`Dead$kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`ê^kY
<td>~T
<td>
<td>

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`ê^kGl
<td>

<tr><td>7.
<td>`compositionend$et
<td>
<td>
<td>`ê^kGl
<td>

<tr><td>8.
<td>`keyup$et
<td>`e^kY
<td>~F
<td>
<td>`Latin Small Letter E^cn
</table>
</div>

<p class="note">注記：
2 個目の `keydown^c ~event（段 5）では、
（~eventは抑止されていないとするとき，）
通常の状況下では`~UIkey値$ `e^kY （ `Latin Small Letter E^cn ~UIkey）`にはならない^em
— ~UAに送達される値は、
すでに~dead-key操作oにより修飾されることになるので。
◎
In the second keydown event (step 5), the key value (assuming the event is not suppressed) will not be "e" (Latin Small Letter E key) under normal circumstances because the value delivered to the user agent will already be modified by the dead key operation.
</p>

<p>
この処理nは、
利用者が［
`~dead-key$を押した後に，
~supportされない基底~文字
（すなわち，作動中な発音区別符号が可用でない基底~文字）
を打込んだとき
］には，中止され得る：
◎
This process might be aborted when a user types an unsupported base character (that is, a base character for which the active diacritical mark is not available) after pressing a dead key:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>~F
<td>
<td>`Combining Circumflex Accent^cn （~dead-key）

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`0302^U
<td>

<tr><td>4.
<td>`keyup$et
<td>`Dead$kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`q^kY
<td>~T
<td>
<td>`Latin Small Letter Q^cn

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>7.
<td>`compositionend$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>8.
<td>`keyup$et
<td>`q^kY
<td>~F
<td>
<td>
</table>
</div>

			</section>
			<section id="keys-IME">
<h4 title="Input Method Editors">4.3.3. ~IME（ `Input Method Editors^en ）</h4>

<p>
この仕様は、
`CompositionEvent$I ~interface＆~event
を通して，`~IME$（ `Input Method Editor^en ）用の~modelを含めている。
しかしながら、
`組成~event$と`~keyboard~event$を一対一に対応付けるとは限らない。
例として、
`~UIkey値$ `Accept^cap を伴う `keydown$et を受取ったとしても，それは、
`~IME$において現在~選択された~textが受容されたことを含意するとは限らず，~keystrokeが起きたことのみを指示する
— 受容されている`~IME$の機能性からは切離されて
（それは、
ほとんどの`~IME$~systemにおいては，
通常は `compositionend$et ~eventを生じさせることになるが）。
~keyboard~eventは、
~IMEの現在の状態を決定する用途には，利用できない
— その状態は `CompositionEvent.data$m 属性を通して得することができる。
加えて、
`~IME$~systemや装置の機能性は様々であり、
その機能性を作動化するために，どの~UIkey
— `Convert^cap ／ `Accept^cap ~UIkeyなど —
が利用されているかは、
他の可用な~UIkeyにより表現されることもある。
~keyboard~eventは、
~keyboard~layout用の`~UIkey対応付け$の後に，入力~装置により生成された~eventに対応する。
◎
This specification includes a model for input method editors (IMEs), through the CompositionEvent interface and events. However, Composition Events and Keyboard Events do not necessarily map as a one-to-one relationship. As an example, receiving a keydown for the Accept key value does not necessarily imply that the text currently selected in the IME is being accepted, but indicates only that a keystroke happened, disconnected from the IME Accept functionality (which would normally result in a compositionend event in most IME systems). Keyboard events cannot be used to determine the current state of the input method editor, which can be obtained through the data attribute of the CompositionEvent interface. Additionally, IME systems and devices vary in their functionality, and in which keys are used for activating that functionality, such that the Convert and Accept keys MAY be represented by other available keys. Keyboard events correspond to the events generated by the input device after the keyboard layout mapping.
</p>

<p class="note">注記：
一部の実装／~system環境設定においては、
一部の~UIkey~eventやその値は，利用-中にある`~IME$により抑止されることがある。
◎
In some implementations or system configurations, some key events, or their values, might be suppressed by the IME in use.
</p>

<p>
次の例に、
日本語~IMEを利用して，
~Unicode文字 `~~市^kGl
（ `CJK Unified Ideographs^en の一部である漢字 ）
が生成されるときにアリな~UIkey連列を述べる。
この例では、
~IMEは作動化されていて，日本語~Romaji入力~mode下にあるとする。
~UIkey
`Convert^cap （ “~~変換” ）／ `Accept^cap （ “~~確定” ）
は、
利用-中にある入力~装置や~IMEの環境設定に依存して，他に置換されることもある
— 例えば
`~SPACEBAR^cap （ `0020^U ）／ `Enter^cap
にもなり得る。
◎
The following example describes a possible sequence of keys to generate the Unicode character "市" (Kanji character, part of CJK Unified Ideographs) using Japanese input methods. This example assumes that the input method editor is activated and in the Japanese-Romaji input mode. The keys Convert and Accept MAY be replaced by others depending on the input device in use and the configuration of the IME, e.g., it can be respectively U+0020 (Space key) and Enter.
</p>

<p class="note">注記：
`~~詩^kGl と `~~市^kGl は異形同音異義語であり，
いずれも “し” と発音されるので、
利用者は，
`Convert^cap ~UIkeyを利用して 適正な~optionを選択する必要がある。
◎
"詩" ("poem") and "市" ("city") are homophones, both pronounced し ("shi"/"si"), so the user needs to use the Convert key to select the proper option.
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`s^kY
<td>~F
<td>
<td>`Latin Small Letter S^cn

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>4.
<td>`compositionupdate$et
<td>
<td>
<td>`s^kGl
<td>

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>5.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`s^kY
<td>~T
<td>
<td>

<tr><td>7.
<td>`keydown$et
<td>`i^kY
<td>~T
<td>
<td>`Latin Small Letter I^cn

<tr><td>8.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>9.
<td>`compositionupdate$et
<td>
<td>
<td>`し^kGl
<td>
◎
shi

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>10.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>11.
<td>`keyup$et
<td>`i^kY
<td>~T
<td>
<td>

<tr><td>12.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>13.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>14.
<td>`compositionupdate$et
<td>
<td>
<td>`詩^kGl
<td>
◎
"poem"

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>15.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>16.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>17.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>18.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>19.
<td>`compositionupdate$et
<td>
<td>
<td>`市^kGl
<td>
◎
"city"

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>20.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>21.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>22.
<td>`keydown$et
<td>`Accept$kY
<td>~T
<td>
<td>“~~確定”
◎
Accept

<tr><td>23.
<td>`compositionend$et
<td>
<td>
<td>`市^kGl
<td>

<tr><td>24.
<td>`keyup$et
<td>`Accept$kY
<td>~F
<td>
<td>
</table>
</div>

<p>
~IME組成は、
前掲の例と一致する条件で，次の例のとおり取消され得る。
~UIkey `Cancel^cap も利用-中にある入力~装置や~IMEの環境設定に依存して，他に置換され得る
— 例えば `001B^U （ `Escape^cap ~UIkey ）にもなり得る。
◎
IME composition can also be canceled as in the following example, with conditions identical to the previous example. The key 'Cancel' might also be replaced by others depending on the input device in use and the configuration of the IME, e.g., it could be U+001B (Escape key).
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`s^kY
<td>~F
<td>
<td>`Latin Small Letter S^cn

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`s^kGl
<td>

<tr><td>4.
<td>`keyup$et
<td>`s^kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`i^kY
<td>~T
<td>
<td>`Latin Small Letter I^cn

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`し^kGl
<td>

<tr><td>7.
<td>`keyup$et
<td>`i^kY
<td>~T
<td>
<td>

<tr><td>8.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>9.
<td>`compositionupdate$et
<td>
<td>
<td>`詩^kGl
<td>

<tr><td>10.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>11.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>12.
<td>`compositionupdate$et
<td>
<td>
<td>`市^kGl
<td>

<tr><td>13.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>14.
<td>`keydown$et
<td>`Cancel$kY
<td>~T
<td>
<td>“~~取消”
◎
Cancel

<tr><td>15.
<td>`compositionupdate$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>16.
<td>`compositionend$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>17.
<td>`keyup$et
<td>`Cancel$kY
<td>~F
<td>
<td>
</table>
</div>

<p class="note">注記：
`~IME$（ MacOS ~OS上など）によっては、
組成を取消す前に組成~data属性に`空~文字列$を設定するものもある。
◎
Some input method editors (such as on the MacOS operating system) might set an empty string to the composition data attribute before canceling a composition.
</p>

				<section id="keys-IME-keys">
<h5 title="Input Method Editor mode keys">4.3.3.1. ~IME~mode~UIkey</h5>

<p>
ある種の装置では、
一部の~UIkeyに，［
`~IME$を作動化したり, 作動中な`~IME$の~modeを変更する
］ような機能性が意図されている。
これを目的とする~UIkeyは、
装置や言語~modeごとに異なるものが定義され得る。
この仕様では、
次に挙げるものが，これを目的とする~UIkeyとして定義される
⇒＃
`Alphanumeric$kY,
`CodeInput$kY,
`FinalMode$kY,
`HangulMode$kY,
`HanjaMode$kY,
`Hiragana$kY,
`JunjaMode$kY,
`KanaMode$kY,
`KanjiMode$kY,
`Katakana$kY,
`Romaji$kY
◎
Some keys on certain devices are intended to activate input method editor functionality, or to change the mode of an active input method editor. Custom keys for this purpose can be defined for different devices or language modes. The keys defined in this specification for this purpose are: "Alphanumeric", "CodeInput", "FinalMode", "HangulMode", "HanjaMode", "Hiragana", "JunjaMode", "KanaMode", "KanjiMode", "Katakana", and "Romaji".＼
</p>

<p>
`~IME$が作動中でない下で，これらいずれかの~UIkeyが押されたときは、
（可用なら）適切な`~IME$が，~UIkeyにより指示される~modeで作動化されるものと期待される。
~UIkeyが押されたとき，`~IME$がすでに作動中である場合、［
装置／~app
］に特有なふるまいに基づいて，`~IME$が 指示された~modeへ変更されたり,
異なる`~IME$が立上げられたり, あるいは無視されることもある。
◎
When one of these keys is pressed, and no IME is currently active, the appropriate IME is expected to be activated in the mode indicated by the key (if available). If an IME is already active when the key is pressed, the active IME might change to the indicated mode, or a different IME might be launched, or the might MAY be ignored, on a device- and application-specific basis.
</p>

<p>
この仕様は、
他の~UIkey
— 特定的には、
次に挙げる`~IME$に意図される操作o用の~UIkey —
も定義する
⇒＃
`Accept$kY,
`AllCandidates$kY,
`Cancel$kY,
`Convert$kY,
`Compose$kY,
`Zenkaku$kY （ `FullWidth^en ）,
`Hankaku$kY （ `HalfWidth^en ）,
`NextCandidate$kY,
`NonConvert$kY,
`PreviousCandidate$kY
◎
This specification also defines other keys which are intended for operation specifically with input method editors: "Accept", "AllCandidates", "Cancel", "Convert", "Compose", "Zenkaku" (FullWidth), "Hankaku" (HalfWidth), "NextCandidate", "NonConvert", and "PreviousCandidate".＼
</p>

<p>
これらの~UIkeyの機能は、
この仕様では定義されない
— `~IME$機能性についての詳細は、
他の資料を見よ。
◎
The functions of these keys are not defined in this specification — refer to other resources for details on input method editor functionality.
</p>

<p class="note">注記：
`~IME$機能を伴う~UIkeyは、
その目的に制約されず，他の装置や実装に特有な目的があることもある。
◎
Keys with input method editor functions are not restricted to that purpose, and can have other device- or implementation-specific purposes.
</p>

				</section>
			</section>
			<section id="keys-cancelable-keys">
<h4 title="Default actions and cancelable keyboard events">4.3.4. 既定~動作と取消~可能~keyboard~event</h4>

<p>
`keydown$et ~eventの`既定~動作$が取消されたときは，
それと対を成す `keyup$et ~eventには影響しないモノトスルが、
それに対応する［
`beforeinput$et ／ `input$et ／（~support有りなら） `keypress$et
］~eventは生成しないようにするモノトスル。
次の例に、
~US~keyboardで, ~US用の`~UIkey対応付け$を利用している下で，
~Unicode文字 Q（ `Latin Capital Letter Q^cn ）
が生成されるときにアリな~UIkey連列を述べる：
◎
Canceling the default action of a keydown event MUST NOT affect its respective keyup event, but it MUST prevent the respective beforeinput and input (and keypress if supported) events from being generated. The following example describes a possible sequence of keys to generate the Unicode character Q (Latin Capital Letter Q) on a US keyboard using a US mapping:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td>
<td>
<td>
<td><em>
［
`beforeinput$et／`input$et
］~event, および（~supportされるなら）`keypress$et ~eventは、
生成されない
</em>
◎
No beforeinput or input (or keypress, if supported) events are generated

<tr><td>3.
<td>`keyup$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>4.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
<td>
</table>
</div>

<p>
~UIkeyが修飾~UIkeyであった場合、
~keystrokeは，依然として修飾~状態に織り込むモノトスル。
次の例に、
~US~keyboardで, ~US用の`~UIkey対応付け$を利用している下で，
~Unicode文字 Q（ `Latin Capital Letter Q^cn ）
が生成されるときにアリな連列を述べる：
◎
If the key is a modifier key, the keystroke MUST still be taken into account for the modifiers states. The following example describes a possible sequence of keys to generate the Unicode character Q (Latin Capital Letter Q) on a US keyboard using a US mapping:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>
<td>`shiftKey$m
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>3.
<td>`beforeinput$et
<td>
<td>`Q^kGl
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
<td>
</table>
</div>

<p>
~UIkeyが何回かの~keystrokeからなる連列の一部を成す場合，
それが`~dead-key$であれ, ~IME連列に寄与しているものであれ、
その~keystrokeは，
`keydown$et ~event上で`既定~動作$が取消された場合に限り，無視するモノトスル
（織り込まれない）。
`~dead-key$による`keyup$et ~eventを取消しても，
`beforeinput$et ／ `input$et
~eventには効果がない。
次の例に、
~French~keyboardで, ~French用の`~UIkey対応付け$を利用し，どの修飾も作動化されない下で、［
~dead-key `Dead$kY （ `0302^U `Combining Circumflex Accent^cn ~UIkey）
］, ［
`e^kY ~UIkey（ `0065^U `Latin Small Letter E^cn ~UIkey）
］を利用したときに生じる~event連列を示す：
◎
If the key is part of a sequence of several keystrokes, whether it is a dead key or it is contributing to an Input Method Editor sequence, the keystroke MUST be ignored (not taken into account) only if the default action is canceled on the keydown event. Canceling a dead key on a keyup event has no effect on beforeinput or input events. The following example uses the dead key "Dead" (U+0302 Combining Circumflex Accent key) and "e" (U+0065, Latin Small Letter E key) on a French keyboard using a French mapping and without any modifier activated:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>2.
<td>`keyup$et
<td>`Dead$kY
<td>
<td>

<tr><td>3.
<td>`keydown$et
<td>`e^kY
<td>
<td>

<tr><td>4.
<td>`beforeinput$et
<td>
<td>`e^kGl
<td>

<tr><td>5.
<td>`input$et
<td>
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`e^kY
<td>
<td>
</table>
</div>

			</section>
		</section>
	</section>
	<section id="external-algorithms">
<h2 title="External Algorithms">5. 外部~algo</h2>

<p>
この節は、
この仕様により要求されるが，他の仕様が~hostする方が適正になる~algoを包含する。
◎
This sections contains algorithms that are required by this specification, but are more properly hosted by other specifications.
</p>

<p class="note">注記：
この節は、
これらの定義~用の一時的な~~場所として~serveすることが意図される。
それらは、
最終的には，もっと適切な~~場所へ移動されるべきであり、
そのときには，この節~全体が削除され得る。
◎
The intent is that this sections serve as a temporary home for these definitions, and they should eventually be moved into a more appropriate home so this entire section can be deleted.
</p>

		<section id="external-dom-algorithms">
<h3 title="Core DOM Algorithms">5.1. 中核~DOM~algo</h3>

<p class="note">注記：
以下に与える~algoは、
どこか【他の仕様】へ移動されるべきである。
◎
The following algorithms should be moved... somewhere.
</p>

		</section>
		<section id="external-pointerlock-algorithms">
<h3 title="PointerLock Algorithms">5.2. ~pointer~lock用の~algo</h3>

<p class="note">注記：
以下に与える~algoは、
`PointerLock$r の中へ移動されるべきである。
◎
The following algorithm should be moved into the [PointerLock] spec.
</p>

<p class="trans-note">【
“~pointer~lock” は，
原文では `PointerLock^en と称されるが、
これは，~interfaceの名前ではなく仕様の名前である。
】</p>

			<section id="pointer-lock-global-state">
<h4 title="Global State for PointerLock">5.2.1. ~pointer~lock用の大域的な状態</h4>

<p id="pointer-lock-global-window">
~UAは、
各`~window$の中で共有される値をとして，次を保守するモノトスル
⇒
`最後の~mousemove位置@
⇒
最後の `mousemove$et ~eventの位置を記録する
— 初期~時は ε とする。
◎
5.2.1.1. Window-Level State
◎
The UA must maintain the following values that are shared for the Window.
◎
A last mouse move value (initially undefined) that records the position of the last mousemove event.
</p>

			</section>
			<section id="_algorithms-for-pointerlock">
<h4>5.2.2. 各種~algo</h4>

<div class="algo">
<p>
`~MouseEvent用に各~pointer~lock属性を初期化する@
~algoは、
所与の
( `MouseEvent$I %~event )
に対し：
◎
5.2.2. initialize PointerLock attributes for MouseEvent
◎
Input
• event, a MouseEvent
Output
• None
</p>
<ol>
	<li>
%~event の
⇒＃
`movementX$m ~SET 0,
`movementY$m ~SET 0
◎
Set event.movementX = 0
◎
Set event.movementY = 0
</li>
</ol>
</div>

<div class="algo">
<p>
`~mousemove用に各~pointer~lock属性を設定する@
~algoは、
所与の
( `MouseEvent$I %~event )
に対し：
◎
5.2.3. set PointerLock attributes for mousemove
◎
Input
• event, a MouseEvent
Output
• None
</p>
<ol>
	<li>
~IF［
%~event の `type$m ~NEQ `mousemove^l
］
⇒
~RET
◎
If event.type is not "mousemove", then exit
</li>
	<li>
( %~x, %~y ) ~LET ( %~event の `screenX＠~POINTEREVENTS#dom-mouseevent-screenx$m, %~event の `screenY＠~POINTEREVENTS#dom-mouseevent-screeny$m )
◎
↓</li>
	<li>
( %動き~x, %動き~y ) ~LET ( 0, 0 )
◎
If last mouse move is not defined, then
• Set event.movementX = 0
• Set event.movementY = 0
</li>
	<li>
~IF［
`最後の~mousemove位置$ ~NEQ ε
］
⇒＃
%動き~x ~SET %~x ~MINUS `最後の~mousemove位置$の~x座標；
%動き~y ~SET %~y ~MINUS `最後の~mousemove位置$の~y座標
◎
Otherwise,
• Set event.movementX = event.screenX - last mouse move’s x-coordinate
• Set event.movementY = event.screenX - last mouse move’s y-coordinate
</li>
	<li>
%~event の
⇒＃
`movementX$m ~SET %動き~x,
`movementY$m ~SET %動き~y
◎
↑</li>
	<li>
`最後の~mousemove位置$ ~SET ( %~x, %~y )
◎
Set last mouse move = ( event.screenX, event.screenY )
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="legacy-event-initializers" class="appendix">
<h2 title="Legacy Event Initializers">6. 旧来の~event初期化子</h2>

`legacy-event-initializers^APX

	</section>
	<section id="legacy-key-attributes">
<h2 title="Legacy Key Attributes">7. 旧来の~UIkey属性</h2>

`legacy-key-attributes^APX

	</section>
	<section id="legacy-event-types">
<h2 title="Legacy Event Types">8. 旧来の~event型</h2>

`legacy-event-types^APX

	</section>
	<section id="extending-events">
<h2 title="Extending Events">9. ~eventの拡張-法</h2>

`extending-events^APX

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">10. ~securityの考慮点</h2>

`security-considerations^APX

	</section>
	<section id="changes-from-earlier-versions">
<h2 title="Changes">11. 変更点</h2>

`changes-from-earlier-versions^APX

	</section>
	<section id="acknowledgements-contributors">
<h2 title="Acknowledgements">12. 謝辞</h2>

`acknowledgements-contributors^APX

	</section>
	<section id="glossary">
<h2 title="Glossary">13. 用語集</h2>

<p class="1st">
次の用語の定義の一部は、
他の［
W3C ／標準
］文書の類似な定義から借用されたり, 改変されている。
詳細は、
定義~内の~linkを見よ。
◎
Some of the following term definitions have been borrowed or modified from similar definitions in other W3C or standards documents. See the links within the definitions for more information.
</p>

<p class="trans-note">【
適合性に関連な用語は、
`別~pageの § 用語集＠~UIEVENTS-A#glossary$
に挙げる。
】【
ここでは、
原文の~~アルファベット順による並びに代えて，
互いの関連度に基づく並びに改めている。
】</p>

<dl id="glossary-list">
	<dt>
`要素@
（ `element^en ）
</dt>
	<dd>
`Element$I ~interface `DOM$r
を~instance化した~obj
</dd>

	<dt>
`根~要素@
（ `root element^en ）
</dt>
	<dd>
`文書~要素$。
［
~HTML／ ~XHTML
］`文書$においては、
`html^e 要素が該当する。
◎
The first element node of a document, of which all other elements are children. The document element.
</dd>

	<dt>
`~body要素@
（ `body element^en ）
</dt>
	<dd>
［
~HTML／ ~XHTML
］`文書$においては、
`根~要素$の子孫【子？】である `body^e 要素のうち，最初のもの。
~body要素は，文書の内容を表現する。
【`~HTML仕様による定義＠~HTMLdom#the-body-element-2$】
◎
In HTML or XHTML documents, the body element represents the contents of the document. In a well-formed HTML document, the body element is a first descendant of the root element.
</dd>

	<dt>
`空~文字列@
（ `empty string^en ）
</dt>
	<dd>
長さ 0 の，`DOMString^I 型~値。
◎
The empty string is a value of type DOMString of length 0, i.e., a string which contains no characters (neither printing nor control characters).
</dd>

	<dt>
`未初期化~値@
（ `un-initialized value^en ）
</dt>
	<dd>
~eventが `initEvent()$m†
で初期化される前の，各種~event属性
（ `bubbles$m や `currentTarget$m など）
が，既定でとるものとされる値。
~eventの未初期化~値は、
`Document.createEvent()$m ~method††を利用して
新たな~eventが作成される時点で適用される。
◎
The value of any event attribute (such as bubbles or currentTarget) before the event has been initialized with initEvent(). The un-initialized values of an event apply immediately after a new event has been created using the method createEvent().
</dd>
	<dd class="trans-note">【†
または，構築子に与える `EventInit$I （または それを継承する）型の辞書~引数
】【††
または，各種~event~interfaceの構築子
】【
この種の値は、
“既定値（ `default value^en ）” 命名されることが多いが、
この名前にされている理由は，~IDL用語の “既定値” と区別するためと思われる。
】</dd>

	<dt>
`~event型@
（ `event type^en ）
</dt>
	<dd>
`~event$~objの~event型は、
特定0の名前を伴い, 特定0の［
誘発~条件, ~prop, 他の~event型から判別される他の特性
］を定義する。
例えば、
~event型 `keydown$et の特性は `blur$et や `load$et とは異なる。
~event型は、
~event~obj上では `type$m 属性として公開される。
~event型が `keydown$et である~eventは、
“`keydown^et ~event”
のように略記されることもある。
◎
An event type is an event object with a particular name and which defines particular trigger conditions, properties, and other characteristics which distinguish it from other event types. For example, the keydown event type has different characteristics than the blur or load event types. The event type is exposed as the type attribute on the event object. Also loosely referred to as "event", such as the keydown event.
</dd>

	<dt>
`~event~focus@
（ `event focus^en ）
</dt>
	<dd>
~event~focusは、
`文書$の中の［
特定0の要素~その他の`~event~target$
］において，［
~~目立たせている／~~注視されている
］ような特別な状態である。
~focusされたときの挙動は、
各~要素ごとに その機能性に依存して異なる
— ［
（~buttonや~hyperlink用に）要素を作動化~対象の首位に据える／
（~checkbox用に）状態を~toggleする／
（~text~form~field用に）~text入力を受取る／
選択された~textを複製する
］など。
詳細は
`§ 文書~focusと~focus文脈＠#events-focusevent-doc-focus$を見よ。
◎
Event focus is a special state of receptivity and concentration on an particular element or other event target within a document. Each element has different behavior when focused, depending on its functionality, such as priming the element for activation (as for a button or hyperlink) or toggling state (as for a checkbox), receiving text input (as for a text form field), or copying selected text. For more details, see § 4.3.3 Document Focus and Focus Context.
</dd>

	<dt>
`~event~focus環@
（ `event focus ring^en ）
</dt>
	<dd>
~event~focus環とは、
`文書$内の`~event~focus$の~targetになり得るものからなる有順序~集合である。
`~host言語$は、
これらの~targetの順序を決定する複数の仕方を定義することもある
— ［
文書~順序 ／
各~focus~targetに定義される数量的~index ／
各~focus~targetに明示的に与えられる次の~target ／
これらの異なる~modelの~~混成
］など。
文書は、
複数の~focus環や条件付き~focus環を包含することもある。
概して、［
文書~順序／~index【~tab~index】
］に基づく~focus環においては、
最後の~focus~targetの次の~focusは， “最初へ戻る” 。
◎
An event focus ring is an ordered set of event focus targets within a document. A host language MAY define one or more ways to determine the order of targets, such as document order, a numerical index defined per focus target, explicit pointers between focus targets, or a hybrid of different models. Each document MAY contain multiple focus rings, or conditional focus rings. Typically, for document-order or indexed focus rings, focus wraps around from the last focus target to the first.
</dd>

	<dt>
`~event~target@
（ `event target^en, 略して “~target” ）
</dt>
	<dd>
~event~flowを利用して，`~event$の`~target＠~DOM4#event-target$にされている~obj
— `target$m 属性の値が，それを与える。
◎
The object to which an event is targeted using the event flow. The event target is the value of the target attribute.
</dd>

	<dt>
`作動化の誘発@
（ `activation trigger^en ）
</dt>
	<dd>
`作動化の挙動$を起動するように定義された~event。
◎
An event which is defined to initiate an activation behavior.
</dd>

	<dt>
`既定~動作@
（ `default action^en ）
</dt>
	<dd>
`既定~動作$は、
任意選択†な補足的な挙動であって，実装が~event~objの配送-と組合せて遂行しなければナラナイものである。
各種~event型~定義, および
各種 仕様は、
その~event型~用の`既定~動作$があれば，それを定義する。
`作動化の誘発$に結付けられたときなど、
一部の状況下では，~eventの各~instanceには`既定~動作$が複数ある場合もある。
`既定~動作$は、
`preventDefault()$m ~methodの呼出nを通して取消されることもある。
◎
A default action is an OPTIONAL supplementary behavior that an implementation MUST perform in combination with the dispatch of the event object. Each event type definition, and each specification, defines the default action for that event type, if it has one. An instance of an event MAY have more than one default action under some circumstances, such as when associated with an activation trigger. A default action MAY be cancelled through the invocation of the preventDefault() method.
</dd>
	<dd class="trans-note">【†
どの主体から見て任意選択なのかはっきりしない
— 実装ではなく，この仕様を参照している他の仕様？
】</dd>

<!-- delta #delta → ~POINTEREVENTS （原文削除漏れ）-->

	<dt>
`文字~値@
（ `character value^en ）
</dt>
	<dd>
~UIkey値の文脈においては、
文字~値は， 1 個~以上の~Unicode文字を表現する文字列である
— 普通字や記号, あるいは 何個かの普通字が成す並びなど，それぞれが妥当な`~Unicode字種$が成す集合に属するような。
この仕様では、
文字~値は ~Unicode文字列（例： `0020^U ）, または
同じ符号位置の~glyph表現（例： `X^kGl ）として記され、
2 つの表現を判別し易くするよう色付けられる。
◎
In the context of key values, a character value is a string representing one or more Unicode characters, such as a letter or symbol, or a set of letters, each belonging to the set of valid Unicode character categories. In this specification, character values are denoted as a unicode string (e.g., U+0020) or a glyph representation of the same code point (e.g., " "), and are color coded to help distinguish these two representations.
</dd>
	<dd class="note">注記：
~source~codeにおいては、
非~graphic文字などの一部の~UIkey値は，
利用-中にある~programming言語の文字~escape構文を利用して表現され得る。
◎
In source code, some key values, such as non-graphic characters, can be represented using the character escape syntax of the programming language in use.
</dd>

	<dt>
`~UIkey値@
（ `key value^en ）
</dt>
	<dd>
~UIkey値は、
特定0の状態にある~UIkeyに結付けられた，`文字~値$ または［
複数~文字からなる文字列
（ `Enter$kY, `Tab$kY, `MediaTrackNext$kY など）
］である。
~UIkey値は、
どの~UIkeyにも
— 制御~UIkey, ~function~UIkey, `修飾~UIkey$, `~dead-key$, その他の~UIkeyも含む —
`文字~値$を有するかどうかに関わらず，あてがわれる。
与えられた時点の与えられたどの~UIkeyの~UIkey値も、
`~UIkey対応付け$に依存する。
◎
A key value is a character value or multi-character string (such as "Enter", "Tab", or "MediaTrackNext") associated with a key in a particular state. Every key has a key value, whether or not it has a character value. This includes control keys, function keys, modifier keys, dead keys, and any other key. The key value of any given key at any given time depends upon the key mapping.
</dd>

	<dt>
`修飾~UIkey@
（ `modifier key^en ）
</dt>
	<dd>
修飾~UIkeyは、
~UIkeyの通常の挙動を変更する
— （ `Shift^cap ~UIkeyで）異なる文字caseを生産させたり,
（`Fn^cap や `Alt^cap ~UIkeyなどで）~UIkeyが誘発する機能性を改めるなど。
修飾~UIkeyについての情報は、
`§ 修飾~UIkey＠#keys-modifiers$を見よ。
妥当な修飾~UIkeyたちが成す~listは、
`UIEvents-Key$r の`修飾~UIkeyの表t$内にある。
◎
A modifier key changes the normal behavior of a key, such as to produce a character of a different case (as with the Shift key), or to alter what functionality the key triggers (as with the Fn or Alt keys). See § 5.3.1 Modifier keys for more information about modifier keys and refer to the Modifier Keys table in [UIEvents-Key] for a list of valid modifier keys.
</dd>

	<dt>
`~dead-key@
（ `dead key^en ）
</dt>
	<dd>
~dead-keyは、
自身は文字を生産しないが，［
別の~UIkeyとの［
組合n／連列
］により，修飾された文字
— 発音区別符号を伴う文字（例： `ö^kGl, `é^kGl, `â^kGl ）など —
を生産する
］ような［
~UIkeyまたは~UIkeyの組合n
］である。
◎
A dead key is a key or combination of keys which produces no character by itself, but which in combination or sequence with another key produces a modified character, such as a character with diacritical marks (e.g., "ö", "é", "â").
</dd>

	<dt>
`~text組成~system@
（ `text composition system^en ）
</dt>
	<dd>
何らかの形による代替-入力
（`~IME$, 発話~処理器, 手書き認識~systemなど）
を解釈して，それを~textに変換する~software~component。
◎
A software component that interprets some form of alternate input (such as a input method editor, a speech processor, or a handwriting recognition system) and converts it to text.
</dd>

	<dt>
`~UIkey対応付け@
（ `key mapping^en ）
</dt>
	<dd>
~UIkey対応付けは、
特定0の~UIkeyに~UIkey値をあてがう処理nであり、
いくつかの要因
— ~OSや~keyboard~layout
（例： `QWERTY$, Dvorak, Spanish, InScript, Chinese, 等々），
および［
`修飾~UIkey$（ `Shift^cap, `Alt^cap, 等々）／ `~dead-key$
］の状態すべてを含む —
を組合せた結果である。
◎
Key mapping is the process of assigning a key value to a particular key, and is the result of a combination of several factors, including the operating system and the keyboard layout (e.g., QWERTY, Dvorak, Spanish, InScript, Chinese, etc.), and after taking into account all modifier key (Shift, Alt, et al.) and dead key states.
</dd>

	<dt>
`~IME@
（ `input method editor^en, 入力方式エディタ ）
</dt>
<!-- 
	<dt id="glossary-input-method-editor"></dt>
-->
	<dd>
~IMEは、
一連の~keystrokeから表意文字その他の文字への変換を
— 通例的に，利用者により手引きされる辞書検索により —
遂行する~appであり、
東アジア圏の言語（例：中国語, 日本語, 韓国語）でよく利用される。
~IMEは、
携帯~機器などでも単語の入力補完に利用されることもある。
この仕様における~IMEの扱いについては、
`§ ~IME＠#keys-IME$を見よ。
§ `~text組成~system$も見よ。
◎
An input method editor (IME), also known as a front end processor, is an application that performs the conversion between keystrokes and ideographs or other characters, usually by user-guided dictionary lookup, often used in East Asian languages (e.g., Chinese, Japanese, Korean). An IME MAY also be used for dictionary-based word completion, such as on mobile devices. See § 5.3.3 Input Method Editors for treatment of IMEs in this specification. See also text composition system.
</dd>

<!-- 
namespace URI 未利用
-->

	<dt>
`QWERTY@
</dt>
	<dd>
QWERTY（ “ˈkwɜrti” と発音される）は、
共通的な~keyboard~layoutの普通字~UIkeyの上段の最初の 6 文字が
Q, W, E, R, T, Y
であることから命名されている。
他にも~popularな~keyboard~layoutは数多くあり（~Dvorakや~Colemak~layoutなど）、
そのほとんどは，地域化や人間工学~用に設計されている。
◎
QWERTY (pronounced ˈkwɜrti) is a common keyboard layout, so named because the first five character keys on the top row of letter keys are Q, W, E, R, T, and Y. There are many other popular keyboard layouts (including the Dvorak and Colemak layouts), most designed for localization or ergonomics.
</dd>

	<dt>
`~Unicode字種@
（ `Unicode character categories^en ）
</dt>
	<dd>
各~Unicode符号位置に対し定義されている
`General Category^en 値の部分集合。
この部分集合には、
次に挙げる字種に属するものすべてが包含される：
<ul>
	<li>
普通字（ `Letter^en ）：
<abbr title="Letter, Lowercase">Ll</abbr>,
<abbr title="Letter, Modifier">Lm</abbr>,
<abbr title="Letter, Other">Lo</abbr>,
<abbr title="Letter, Titlecase">Lt</abbr>,
<abbr title="Letter, Uppercase">Lu</abbr>
</li>
	<li>
数字n（ `Number^en ）：
<abbr title="Number, Decimal Digit">Nd</abbr>,
<abbr title="Number, Letter">Nl</abbr>,
<abbr title="Number, Letter">NO</abbr>
</li>
	<li>
約物（ `Punctuation^en ）：
<abbr title="Punctuation, Connector">Pc</abbr>,
<abbr title="Punctuation, Dash">Pd</abbr>,
<abbr title="Punctuation, Close">Pe</abbr>,
<abbr title="Punctuation, Final quote">Pf</abbr>,
<abbr title="Punctuation, Initial quote">Pi</abbr>,
<abbr title="Punctuation, Other">Po</abbr>,
<abbr title="Punctuation, Open">Ps</abbr>
</li>
	<li>
記号（ `Symbol^en ）：
<abbr title="Symbol, Currency">Sc</abbr>,
<abbr title="Symbol, Modifier">Sk</abbr>,
<abbr title="Symbol, Math">Sm</abbr>,
<abbr title="Symbol, Other">So</abbr>
</li>
</ul>

◎
A subset of the General Category values that are defined for each Unicode code point. This subset contains all the Letter (Ll, Lm, Lo, Lt, Lu), Number (Nd, Nl, No), Punctuation (Pc, Pd, Pe, Pf, Pi, Po, Ps) and Symbol (Sc, Sk, Sm, So) category values.
</dd>
</dl>

	</section>
</main></div>


