<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>UI Events （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.page_state_key = '___UI-EVENTS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://w3c.github.io/uievents/',
//		original_url: 'http://www.w3.org/TR/uievents/',
		main: 'MAIN',
		spec_status: 'WD',
		fill_text_link: '#_versions > dd',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};


	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		collectParts: Util.collectParts,
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語寄り:英語+漢字:漢字主体:カナ主体',
		level: 3,
		generate: expand
	}

	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 170125 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var unicode_map = this.unicode_map;
	var class_map = {
		E: 'error',
		l: 'literal',
		et: 'event-type',
		e: 'element',
		a: 'attr',
		kY: 'key',
		U: 'code-point',
		kC: 'key-code',
		cap: 'key-cap',
	};
	var tag_map = {
		c: 'code',
		I: 'code', // interface, dictionary, enum 
		i: 'code',
		m: 'code',
		E: 'code',
		et: 'code',
		l: 'code',
		e: 'code',
		a: 'code',
		kY: 'code',
		U: 'span',
		kC: 'code',
		cap: 'span',
		v: 'var',
	};
	var current_ifc = '#';
	var in_idl = false;

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|【.*?】|%[\w~一-鿆]+|`(.*?)([$@!\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '◎':
	default:
	}
	return '<span lang="en">' + match.slice(1).trim() + '</span>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'e': // DOM element tag name
	text = '&lt;' + key + '&gt;';
	break;
case 'kY': // key event .key value
	href = "~UIEVENTS-KEY#key-" + key;
	break;
case 'kC': // key event .code value
	href = "~UIEVENTS-CODE#code-" + key;
	break;
case 'kGl': // key glyph
	text = '"<code class="glyph">' + text + '</code>"';
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'U': // unicode code point
	text = 'U+' + key;
	break;
case 'cap': // key cap
	break;

case 'I': // IDL interface
//	href = '#' + key.toLowerCase();
	if((indicator === '@') || (indicator === '!')){
		current_ifc = '#dom-' + key.toLowerCase() + '-';
	}
	if(in_idl) tag = '';
	break;
case 'm' : // interface member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	n = key.indexOf('.');
	if(n < 0 ) {
		href = current_ifc + key.toLowerCase();
	} else {
		text = text.slice(n + 1);
		href = '#dom-' + key.replace(/\./, '-').toLowerCase();
	}
	break;
case 'et': // event type
	href = '#' + key.toLowerCase();
	//href = '#event-type-' + key;
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '">＊</a>';
	break;
case 'APX':
	return (
'<p class="trans-note">【この節の和訳は<a href="~UIEVENTS-A#'
+ key +'">別ページ</a>にて。】</p>'
	);
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
scroll-unit:
right-hand-coordinate-system:
element:
	＊propagation-path
	＊
</script>


<!--%links -->
<script type="text/plain" id="_link_map">

I.EventTarget:~DOM4#eventtarget
I.EventListener:~DOM4#callbackdef-eventlistener
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
	I.CustomEvent:~DOM4#customevent

I.UIEvent:#uievent
I.UIEventInit:#dictdef-uieventinit
I.FocusEvent:#focusevent
I.FocusEventInit:#dictdef-focuseventinit
I.MouseEvent:#mouseevent
I.MouseEventInit:#dictdef-mouseeventinit
I.EventModifierInit:#dictdef-eventmodifierinit
I.WheelEvent:#wheelevent
I.WheelEventInit:#dictdef-wheeleventinit
I.InputEvent:#inputevent
I.InputEventInit:#dictdef-inputeventinit
I.KeyboardEvent:#keyboardevent
I.KeyboardEventInit:#dictdef-keyboardeventinit
I.CompositionEvent:#compositionevent
I.CompositionEventInit:#dictdef-compositioneventinit

I.Window:#window
I.Document:#document
I.Element:#element

I.WindowProxy:~BROWSERS#windowproxy
I.HTMLInputElement:~HEinput#htmlinputelement

	I.Document:#interface-Document
	I.InputEvent:#interface-InputEvent

et.DOMNodeInserted:~UIEVENTS-A#event-type-DOMNodeInserted
et.DOMNodeRemoved:~UIEVENTS-A#event-type-DOMNodeInserted
et.keypress:~UIEVENTS-A#event-type-keypress
et.DOMActivate:~UIEVENTS-A#event-type-DOMActivate

	m.~indata:#dom-inputevent-data
m.InputEvent.data:#dom-inputevent-data
m.keyCode:~UIEVENTS-A#dom-keyboardevent-keycode
m.charCode:~UIEVENTS-A#dom-keyboardevent-charcode
m.which:~UIEVENTS-A#dom-keyboardevent-which
m.initMouseEvent:~UIEVENTS-A#dom-mouseevent-initmouseEvent

	m.~compdata:#dom-compositionevent-data
	m.target:#dom-event-target


m.type:~DOM4#dom-event-type
m.target:~DOM4#dom-event-target
m.currentTarget:~DOM4#dom-event-currenttarget
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.composed:~DOM4#dom-event-composed
m.timeStamp:~DOM4#dom-event-timestamp
m.defaultPrevented:~DOM4#dom-event-defaultprevented
m.isTrusted:~DOM4#dom-event-istrusted
m.stopPropagation:~DOM4#dom-event-stoppropagation
m.stopImmediatePropagation:~DOM4#dom-event-stopimmediatepropagation
m.preventDefault:~DOM4#dom-event-preventdefault
m.initEvent:~DOM4#dom-event-initevent

m.dispatchEvent:~DOM4#dom-eventtarget-dispatchevent
m.createEvent:~DOM4#dom-document-createevent
m.handleEvent:~DOM4#dom-eventlistener-handleevent

	m.view:#dom-uievent-view
	m.detail:#dom-uievent-detail

m.Document.getSelection
	http://w3c.github.io/selection-api/#widl-Document-getSelection-Selection
	https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#dom-document-getselection

e.textarea:~HEforms#the-textarea-element
e.input:~HEinput#the-input-element


~keyboard~eventと~key値:#keys
内部~key修飾~状態:#internal-key-modifier-state
~key修飾~状態:#internal-key-modifier-state
~key修飾~名:#modifier-key-name

各種~UI~eventに共通する文脈~情報:#_common-UI-event-context
各種~mouse~eventに共通する文脈~情報:#_common-mouse-event-context
各種~入力~eventに共通する文脈~情報:#_common-input-event-context
各種~keyboard~eventに共通する文脈~情報:#_common-keyboard-event-context
	各種~変異~eventに共通する文脈~情報:#_common-mutation-event-context
各種~組成~eventに共通する文脈~情報:#_common-composition-event-context

組成~event:#events-compositionevents
~focus~event:#events-focusevent
~keyboard~event:#events-keyboardevents
~mouse~event:#events-mouseevents

作動化の誘発と挙動:#event-flow-activation
	→ 別名／重複→集約, 本文内

~event相:#event-phase
浮上-相:#bubble-phase
捕獲-相:#capture-phase
標的~相:#target-phase
伝播~経路:#propagation-path
浮上-:#bubble-phase
現在の~click回数:#current-click-count

	●補完
~trusted:#trusted-events
非trusted:#trusted-events
同期:#sync-async
	非同期的
同期的
広義先祖:~DOM4#concept-tree-inclusive-ancestor
広義子孫:~DOM4#concept-tree-inclusive-descendant
計測~単位:#scroll-unit
右手~座標系:#right-hand-coordinate-system
取消可能:#_cancelable
~task待行列:~WAPI#task-queue
~task源:~WAPI#task-source
~event-loop:~WAPI#event-loop
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element

進捗~event:http://www.w3.org/TR/progress-events#interface-progressevent
	I.ProgressEvent


~pointing先:#_pointing


	●用語集
		＊glossary-除去
作動化の挙動:#activation-behavior
作動化の誘発:#activation-trigger
~body要素:#body-element
	浮上-相#bubbling-phase
	捕獲-相#capture-phase
	候補~event~listenerたち:#candidate-event-handlers
	#dfn-candidate-event-listeners
文字~値:#character-value
現在の~event標的:#current-event-target
現在の標的:#current-event-target
~dead-key:#dead-key
既定~動作:#default-action
~delta:#delta
配送:#dispatch
文書:#document
要素:#element

~DOM0:#dom-level-0
空~文字列:#empty-string
~event:#event
~event型:#event-type
~event~focus:#event-focus
~focus:#event-focus
~focus環:#event-focus-ring
~event~focus環:#event-focus-ring
~event~handler:#event-handler
~event~listener:#event-listener
~event序列:#event-order
	~event相:#event-phase
~event標的:#event-target
標的:#event-target
最上層の~event標的:#topmost-event-target
接触判定:#topmost-event-target

発火-:#fire
~hysteresis:#hysteresis
~IME:#ime
	入力~method~editor:#input-method-editor
~key~mapping:#key-mapping
~key値:#key-value
~key~code:#keys-codevalues

修飾~key:#modifier-key
名前空間~URI:#namespace-uri
相:#phase
伝播~経路:#propagation-path
QWERTY:#qwerty
根~要素:#root-element
回転:#rotation
	標的~相→
~text組成~system:#text-composition-system
木:#tree
~DOM木:#tree
~Unicode字種:#unicode-character-categories
未初期化~値:#un-initialized-value
~Window:#window


作者:~UIEVENTS-A#author
~UA:~UIEVENTS-A#user-agent
非推奨:~UIEVENTS-A#deprecated
非推奨に:~UIEVENTS-A#deprecated
~DOM~app:~UIEVENTS-A#dom-application
~host言語:~UIEVENTS-A#host-language

修飾~key一覧:http://www.w3.org/TR/uievents-key/#keys-modifier
	https://w3c.github.io/uievents/DOM3Events-key.html#keys-modifier

~hover_ps 疑似類:~SELECTORS4#the-hover-pseudo
</script>

<!--%置換語 -->
<script type="text/plain" id="words_table1">
DS:DOMString
NULL:null
RA:readonly attribute

UAAG20:http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/
	http://www.w3.org/TR/UAAG20/
UIEVENTS-A:uievents-appendix-ja.html
	https://w3c.github.io/uievents/
UIEVENTS-KEY:http://www.w3.org/TR/uievents-key/
UIEVENTS-CODE:http://www.w3.org/TR/uievents-code/

compdata:data
aT:@
hover_ps:<code class="css">:hover</code>
SPACEBAR:<span style="color:#AAAAAA"> Space </span>

●型:<table class="eventdef"><tbody><tr><th>型<td>
●界面:<tr><th>~ifc<td>
●同期:<tr><th>同期？<td>
●浮上:<tr><th>浮上-？<td>
●標的:<tr><th>標的<td>
●取消:<tr><th>取消可？<td>
●構:<tr><th>Composed？<td>
●既定動作:<tr><th>既定~動作<td>
●文脈:<tr><th>文脈~情報<td>
●表終:</tbody></table>


INFORMATIVE:<p><em>この節は参考である。</em><span lang="en">This section is informative.</span></p>
集約簡略化:<p class="trans-note">【この訳では、各所に共通する記述をこの節に集約する。】</p>

</script>
<!-- 

●~event連列:<table class="event-sequence-table"><thead><tr><td><th>~event型<th>備考</thead>
●tr0:<tbody><tr><td>
●tr:<tr><td>
●td:<td>
●td0:<td class="em">
●thead:<th>
●th:<th>

-->

<!--%語彙 -->
<script type="text/plain" id="words_table">
	16 進:hexadecimal#2
	10 進:decimal#1
DOM2:DOM Level 2:DOM2
DOM0:DOM Level 0:DOM0
DOM:
Events:
Event:

ASCII:
API:
Alt:
IME:
OS:
PC:
UA:
UI:
Unicode:
Web:
Window:

	HTML:
	SVG:
	ECMAScript:
	QWERTY:
	XForms:
	XHTML:
	XML:
	XMLHttpRequest:
	Windows:
	Mac
	~stylistic::::
	~dom::::
	Small::::
	Letter::::
	~Mouse::::
	~key-value::::
	~Mutation::::
	~MutationEvent:
	~attrChange::::
	~BarOrg::::
	~codebase::::
	~typing::::

	●カナ

machine::::マシン
	pair::::ペア
size::::サイズ
trap::::トラップ

	~event-type::::
	更に〜もある~further optional::::
digital::::デジタル

programming::::プログラミング
web::::ウェブ

access:::アクセス
	access可能:accessible
accessibility::::アクセス容易性:アクセシビリティ

block:::ブロック

body:

code::::コード
command::::コマンド
comment::::コメント
feedback::::フィードバック
data::::データ

escape::::エスケープ
field::::フィールド
client::::クライアント
hyperlink::::ハイパーリンク
index::::
埋込みの:inline::~
instance::::インスタンス
	instance化:::instantiating#1
link::::リンク
list::::リスト
読込ing:loading::読み込み::ローディング
読込み:load::読み込み::ロード
読込んだ:load した::読み込んだ::ロードした
読込まれ:load され::読み込まれ::ロードされ

network::::ネットワーク
property::::プロパティ


reset::::リセット
style::::スタイル
stylesheet:style sheet:::スタイルシート

shortcut::::ショートカット
text::::テキスト
unload::::
animation:::アニメーション

	●event flow
event::::イベント
event-loop:event loop::イベントループ
連列:sequence::~::シーケンス
連列的:sequential::~::シーケンシャル
	順々にsequential
	~sequence:::
序列:order::~::オーダー

組成:composition::~::コンポジション
組成-:compose::~::コンポーズ
組成済みの:composed::~::コンポーズ済みの
	~text組成
	組成~event:Composition Events:::組成イベント

	~Composition~Events:::
	~composing:#1
flow::::フロー

誘発:trigger::~
誘発-:trigger::~
trusted:
非trusted:untrusted:非 trusted
trust:
	信用済み
相:phase::~::フェイズ
	target:::ターゲット
標的:target:::ターゲット
	at-target:
捕獲-:capture::~::キャプチャ
捕獲:capturing::~::キャプチャリング
浮上-:bubble::~::バブル
浮上:bubbling::~::バブリング

伝播-:propagate::~::プロパゲート
伝播:propagation::~::プロパゲーション
経路:path::~::パス

動作-:act::~::アクト
動作:action::~::アクション
	作動:actuation::~::アクチュエーション
作動-:actuate::~::アクチュエート
作動中:active::~::アクティブ
作動中の:active::~::アクティブな
作動化-:activate::~::アクティブ化
作動化:activation::~::アクティブ化
作動化の:activation::~::アクティブ化の
作動可能:activatable::~::アクティブ化可能
活動:activity:~:::アクティビティ

既定:default::~::デフォルト

取消して:cancel して::~::キャンセルして
取消した:cancel した::~::キャンセルした
取消し:canceling::~::キャンセリング
取消す:cancel する::~::キャンセルする
取消-:cancel::~::キャンセル
取消:cancelation::~::キャンセレーション
取消可能:cancelable::~::キャンセル可能
取消可否:cancelable::~::キャンセル可否
取消可:cancelable::~::キャンセル可能

発火-:fire::~
発火:firing::~
最上層の:topmost:~
session::::セッション
task::::タスク
source::::ソース
源:source::~::ソース

抑止-:suppress:~
抑止法:suppressing:~
	圧殺／抑止／抑制／制止／差止~suppressing:#1

資源:resource::~:リソース

合成-:synthesize:~
合成:synthesis:~
同時的な:concurrent:~
	同時:simultaneous:~
同期:sync:~
	同期-:synchronize:~
同期的:synchronous:~
非同期:async:~
非同期的:asynchronous:~
型:type:~
相互相対順序:set order relative to one another:互いに相対的な順序
文脈依存:varies:~
到着:arrive:~
登録-:register::~
	登録:registration::~
配送:dispatch::~::ディスパッチ
処理待ち:pending::~
再入可能:reentrant::~::リエントラント
	即時:immediate に:~
再開-:resume:~
要請:request:~
要請-:request:~

中止:abort:~
停止-:stop:~
到達-:reach:~
	割り込み:interrupt:~
割込んで:interrupt して:割り込んで
	割込まれ:interrupt され:割り込まれ
中断-:interrupt:~
特権:privilege:~
loop::::ループ
処理0:operation:処理
履行:fulfill:~


	●dom/idl/js
作成-:create:~
返値:return value::返り値
timer:::タイマー


構築子:constructor::~::コンストラクタ
	~calling::::
window::::ウィンドウ
bitmask::::ビットマスク
bitwise::::ビットごとの
callback::::コールバック
call:
handler::::ハンドラ
ifc:interface:::インタフェース
listener::::リスナ
member::::メンバ
辞書:dictionary::~::ディクショナリ
error::::エラー
method::::メソッド
node::::ノード
obj:object:::オブジェクト
parameter::::パラメタ
script::::スクリプト
support::::サポート
	未~supportの:unsupported:~
定数:constant::~
例外:exception:~

木:tree::~::ツリー
根:root::~::ルート
親:parent::~
子:child::~
	child-parent-sibling::親, 子, 同胞
広義先祖:inclusive ancestor::~
広義子孫:inclusive descendant::~
子孫:descendant::~
文書:document::~
文書順:document order::~
先祖:ancestor::~
先行-:precede::~
入子の:nested::入れ子の
入子に:nest::入れ子に

	最も近い共通の広義先祖:nearest-common-inclusive-ancestor:~
初期:initial:~
初期化-:initialize:~
初期化:initialization:~
初期化子:initializer:~
未初期化:un-initialized:~
	既定値
大域:global:~
属性:attribute:~

呼出時:invoke 時:呼び出し時
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出し:invoking:呼び出し
呼出:invocation:呼び出し
文字列:string:~
引数:argument:~
待行列:queue::待ち行列::キュー
要素:element:~
投出-:throw:~
演算:operation:~
値:value:~
名前:name:~
名:name:~

	●UI
click::::クリック
double-click::::ダブルクリック
control::::コントロール
custom::::カスタム
	custom化:::customize
delta::::デルタ
desktop::::デスクトップ
給-:feed:~
focus::::フォーカス
環:ring::~
可focus:focusable:focus 可能::フォーカス可能
被focus:focused:被 focus::被フォーカス
tabbing::::タブキー操作
受取る:receive する:受け取る
受取れる:receive できる:受け取れる
受取った:receive した:受け取った
失う:lose する:~
	＊失いつ:lose しつ:~
失った:lose した:~


menu::::メニュー
mode::::モード
pointer::::ポインタ
screen::::スクリーン
scroll::::スクロール
	~scrolling::::~~操作
zoom::::ズーム
	~zooming:~zoom時／~~操作
shift::::シフト
	~Shift::::
未shift:unshifted:::シフトなし
有shift:shifted:::シフトあり
	未~shifted:~unshifted::::
	~shifted::::
	~shift-state::::
	~shift:~~切替わる
	~~切替えた:shift した
button::::ボタン
item::::アイテム
drag::::ドラッグ
	~image-drag::::
drop::::ドロップ
tab::::タブ
voice::::ボイス

	textual:::テキスト的
	~text用の~textual
	~Key::::
	~keypad::::
macro::::マクロ
player::::プレイヤー
game::::ゲーム
	~WASD::::
	check::::チェック
checkbox::::チェックボックス
graphic::::グラフィック
	~Track::::
form::::フォーム
	形:form:~
対話-:interact:~
手書き:handwriting:~
操作:operation:~
	操作-:operate:~
操作0:interaction:操作
操作1:manipulation:操作
利用者操作:user interaction:利用者による操作
所在bar:Web site location bar::ロケーションバー
接触判定:hit testing:~

	●UI keyboard
glyph::::グリフ
locale::::ロケール
map::::マップ
再map:remap:::リマップ
mapping::::マッピング
key::::キー
keystroke::::キーストローク
label::::ラベル
銘:legend::~

layout::::レイアウト
	配列0:layout:::配列
	keyboard-layout:keyboard layout:::キー配列
US:
	US 配列
Romaji::::ローマ字
Arabic::::アラビア語
Colemak:
Dvorak:
French::::フランス語配列
中国語:Chinese:~
日本語:Japanese:~
韓国語:Korean:~
Serbian::セルビア語
漢字:Kanji characters:~
数字:number:~
umlaut::::ウムラウト

	~French::::
大文字形:majuscule form (uppercase or capital letters):~
小文字形:minuscule form (lowercase or small letters):~
	~key-state::::
	~Form::::
書記体系:writing system:~
普通字:letter::~
asterisk::::アスタリスク
	英字:alphabetic character:~
	~alphabetic:#3
	numeric characters
約物:punctuation:~
accent::::アクセント符
表語文字:logogram:~


	~Symbol::::

scancode::::スキャンコード
	行:line:~

文字:character:~
大文字:uppercase:~
小文字:lowercase:~
文字大小区別:case-sensitive:~
字種:character categories:~
異形同音異義語:homophone:~
発音-:pronounce:~
発音区別符:diacritic:~
発音区別符号:diacritical-mark:~
符号:sign:~
符号位置:code point:~
符号空間:code space:~
符号化:encode:~
結合:combining:~
行高:line-height:~
表意文字:ideograph:~
function::::ファンクション
	~function key:~

修飾:modifier:~
修飾-:modify:~
未修飾の:unmodified:~
未修飾:unmodified:~
候補:candidate:~
所在:location:~
所在-:locate:~
	対にする:match させる
	対を成さない unmatched
	対を成す matching
	対を成さない dangling


	●装置
pointing::::ポインタ指示
	装置
装置:device:~
物理的0:mechanical:物理的
物理的:physical:~
wheel::::ホイール
pen::::ペン
tablet::::タブレット
swipe::::スワイプ
pan::::パン
	panning:~pan~~操作

trackball::::トラックボール
trackpad::::トラックパッド
mouse-ball::::マウスボール
hardware::::ハードウェア
touchpad::::タッチパッド
mouse::::マウス
携帯機器:mobile device:~:::モバイルデバイス
表面:surface:~
平坦:flat:~

加圧:pressure:~
touch::::タッチ

右手:right-hand:~
座標系:coordinate system:~
回転-:rotate:~
回転:rotation:~
回転動作:literal rotation:~
高速化:speed-up:~
加速機能:acceleration:~
加速:accelerator:~

中央:middle:中
首:primary:~
副:secondary:~

hotkey::::ホットキー
cap::::キャップ
PC101US:PC 101 Key US::PC 101 US
keyboard::::キーボード
dead-key::::デッドキー
	dead key
十key:numeric keypad:::テンキーの類
numpad:numeric pad:::テンキー
access-key:access key:::アクセスキー
叩いた:type した:~
叩かれ:type され:~
押下げ:depression:~
押下げら:depress され:~
	:long depression:長い押下げ
	~keyの長押し:long-key-press
押-:press:~
押す:press する:~
離す:release する:~
離-:release:~
	~~押下げ:~down
	~up
目印:marking:~
印字-:mark:~
印字可能:printable:~


	●仕様
仕様:spec:~
指定-:specify:~
	策定中:underspecified:~
特有:-specific:~
作者:author:~
	作者が与える:author-defined:~
processor::::プロセッサ
保安上の:security::~::セキュリティ上の
software::::ソフトウェア
system::::システム
version::::バージョン
	版
model::::モデル
機種:model:~
module::::モジュール
platform::::プラットフォーム
	各~platform間で~~可用になる~cross-platform:#1
program::::プログラム
algo:algorithm:::アルゴリズム
app:application:::アプリ
応用:application::~
著作tool:authoring tool::著作ツール
browser::::ブラウザ
level::::レベル
host::::ホスト
computer::::コンピュータ
	に備わる:~native::::
markup::::マークアップ
architecture::::アーキテクチャ
vendor::::ベンダ
互換性:compatibility:~
後方互換性:backwards-compatibility:~
抽象的:abstract:~
実装-:implement:~
実装:implementation:~
将来:future:~
導入-:introduce:~
	序論:introduction:~

拡張-:extend:~
拡張:extension:~
指針:guideline:~
	挙動し:behave し:ふるまわ
	挙動-:behave:~
挙動:behavior:ふるまい
提案:proposal:~
概念:concept:~
概念的:conceptual:~
概観:overview:~
旧来の:legacy:~
明確化-:clarify:~
精緻化:refine:~
明示的:explicit:~
未定義:undefined:~
標準:standard:~
標準の:standard:~
標準的な:standard:~
定義済みの:predefined:~
再定義-:redefine:~
利用:use:~
利用者定義の:user-defined:~
制約-:restrict:~
制約:restriction:~
参照:reference:~
参照のこ:refer するこ:参照のこ
	~~参照
	指す:refer:~
参考:informative:~
国際的:international:~
地域化:localization:~
定義-:define:~
定義:definition:~
非推奨に:deprecate:~
	非推奨にされmarked as deprecated
相互運用性:interoperability:~
特色機能:feature:~
規範的:normative:~
規約:convention:~
言語:language:~
記述:description:~
記述-:describe:~
設計:design:~
許容-:allow:~
詳細:details:~
論点:discussion:~
謝辞:acknowledgement:~
適合-:conform:~
適合:conforming:~
適合性:conformance:~
	適合している~
能力:capabilities:~
	則って:in accordance with:~
	注視して:with attention で:~
用語集:glossary:~
選択肢:option:~
首尾一貫する:consistent かつ coherent な:様々な環境下で首尾一貫する
一貫して:consistent で:~
一貫する:consistent な:~
動機:motivation:~
解消-:solve:~
解決:resolution:~
能:ability:~
前提:assumption:~
有意義な:meaningful:~
発見-:discover:~
合法な:legal:~
	違って~unlike:#2
	用法~usage:#1
	通例的に:usually:~
	拡張法:extending:~
	最新の~most recent#1
	最新の:latest:~
収集-:borrow:~
	対象にする~deal:#1
proprietary::::プロプライエタリ

結付け:association:~
結付けて:associate して:結び付けて
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
一定の:certain:~
	~~現時点:presently:~
下層の:underlying:~
予備:auxiliary:~
予期-:expect:~
期待-:expect:~
事例:case:~
介在-:intervene:~
仕方:way:~
仕組み:mechanism:~
機構:mechanism:~
	機構:mechanics:~
	他の:other:~
	他の場合:otherwise:~
付録:Appendix:~
	付録:appendix:~
	多くの:many:~
大部分の:most:ほとんどの
奨励-:encourage:~
妥当:valid:~
安定的:stable:~
最後の:last:~
最終的な:final:~
方式:manner:~
方法:how:~
既存の:existing:~
明白:obvious:~
有用性:usefulness:~
概して:typical に:~
機能:function:~
機能上の:functional:~
機能性:functionality:~
段:step:~
汎用:generic:~
一般的:general:~
	一般的な:general:~
一般:general:一般
決定-:determine:~
準備-:prepare:~
準備:preparation:~
無効な:invalid:~
	特に:particularly:~
	特に:specifically:~
特別な:special:~
特定0の:particular:ある特定の
特定の:specific:~
状況:circumstance:~
独特の:idiosyncratic:~
	異なる:different:~
節:section:~
簡便な:convenient:~
精確な:precise:~
目標:goal:~
目的0:purpose:目的
相対的:relative:~
考慮点:consideration:~
考慮-:consider:~
脚注:footnote:~
	自身:itself:~
作業草案:Working Draft:~
援助:aid:~
複雑:complex:~
要求-:require:~
要約:summary:~
	Abstract
見做す:assume する:~
見做せる:assume できる:~
	見做-:assume:~
	見做さず:assume せず:~
通常の:normal:~
通常は:normal では:~
達成-:accomplish:~
適切:appropriate:~
適正:proper:~
適用-:apply:~
	適用し得る:applicable:~
選好-:prefer:~
関係-:relate:~
関係:relation:~
関係する:related:~
	~~関係ない:no bearing
関係性:relationship:~
	関連の:relevant
関連する:relevant な:~
類似性:similarities:~
類別-:categorize:~
	代わりに:instead:~
代替:alternate:~
代用:replacement:~
代表的な:typical:~
仮想:virtual:~
伝統的:traditional:~
使用感:user experience:~
余分の:extra:~
例外的:exceptional:~
依存-:depend:~
依存:dependent:~
	依存しない:independent
従属:dependent:~
独立:independent:~
依拠-:rely:~
	依拠~可能な:reliably:~
	依然として:still:~
保持-:hold:~
保証-:guarantee:~
側面:aspect:~
共通の:common:~
共通的な:common:よくある
共通して:common に:~
即応性:responsivenes:~
受容-:accept:~
受容:allowing:~
可用:available:~
	可用でない unavailable
可能0:possible:可能
	あり得る:possibleである
	可能性:possibilities:~
	その他いくらでもあるany number of other possibilities
	別々:separate:~
	別の:another:~
別個の:distinct:~
	別物
	前者の:former:~
	加えて:additionally:~
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
取扱う:handle する:取り扱う

実際の:actual:~
	必要:need:~
	必要とされ:necessarily:~
手段:means:~
強調:emphasis:~
影響-:affect:~
	後者:latter:~
意味-:mean:~
意味:meaning:~
意味論:semantics:~
意味論的部分:semantic meaning
意図-:intend:~
手続き:steps:~
下位手続き:sub-steps:~
指示-:indicate:~
指示:indication:~
指示子:indicator:~
提供-:provide:~
相互作用:interaction:~
改める:alter する:~
改善-:improve:~
基本:basic:~
基本的な:basic:~
基礎:fundamental:~
増強-:enhance:~
変更点:changes:~
単独の:single:~
単純化-:simplify:~
	同様に:similarly:~
問題:problem:~
	回答:answer:~
中立の:neutral:~
	例:example:~
実施:practice:~
追補的:supplemental:~
	追補的な:supplementary:~
追補:supplement:~
用語:term:~
取組まな:address しな:取り組まな
防止-:prevent:~
全部的:full:~
	全:full:~
	満たす~met:
	満たす:meet する
	~understand:解#1
	勧める~advised:#1
	ある種の

図面化-:depict:~
	図示~illustrate:#1

	用立てられる~utilize できる
統治-:govern:~
方式0:modality:方式
望む:wish する:~
相違-:differ:~
最適な:optimal:~
局面:scenario:~
備考:notes:~
資料:resource:~
勧告:Recommendation:~
位置付け:status:~
含意:imply:~
任意選択:optional:~
検証-:validate:~
省略可:optional:~
一次的:primary:主
	第一の:primary な:~
	第二の:second

	●
	~~配置:placement:~
一対一の:one-to-one:~
一意:unique:~
	~~固有のもの:unique
一節:passage:~
	一部／部分:part:~
	一部の:some:~
	個目:second／third

予約-:reserve:~

	改変:modification:~
改変-:modify:~
	個別:individual:~

入力:input:~
公開-:expose:~
共有-:share:~


外側:outside:~
外部:external:~
内部:internal:~
内側:inside:~
内容:content:~
処理:process:~
処理能:performance:~
出力0:emit:出力
手入力:enter:入力
切離され:disconnect され:切り離され

switch::::スィッチ
切替:switch:~
切替えら:switch さ:切り替えら
切替わっ:switch され:切り替わっ
移転:shift:~
	切変わる:shift する:切り替える
	切変わっ:shift され:切り替わっ
	切変えた:shift した:切り替えた
	列挙:enumerated:~

削除-:delete:~


効果:effect:~
包含-:contain:~
	包含塊:containing block→~pointing先

区別-:distinguish:~
	単~button:single-button:~
単位:unit:~
単語:word:~
印刷-:print:~
却下-:reject:~
反映-:reflect:~
取得0-:retrieve:取得

右:right:~
左:left:~
	各:each:~

合致-:match:~
照合-:match:~
同一:identical:~


回数:count:~
因子:factor:~
困難:difficult:~
座標:coordinate:~
基底:base:~
報告-:report:~
境界:boundary:~
	境界~s:boundaries:~
変換:conversion:~
変換-:convert:~
変数:variable:~
変更:change:~
変化-:change:~
変異:mutation:~
失敗-:fail:~
存在-:exist:~
完了-:complete:~
完了:completion:~
完全:complete:~
遂行-:perform:~
実行-:execute:~
実行:execution:~
実行可能:executable:~
寸法:dimension:~
空間的次元:spatial dimension:~
	対応-:correspond:~
	対応する:corresponding:~

	〜時

	常に:always:~
	広範に:widely:~

形式:format:~
整形式:well-formed:~
後続の:subsequent:~
	悪意のある:malicious:~
情報:information:~
所在的:locative:~

持続的な:sustained:~

一定時間:sustained period の間:ある一定の間


挿入-:insert:~
挿入:insertion:~
	~offer:~~提供

疑似類:pseudo-class::疑似 class:疑似クラス
	数:number:~

数的:numeric:~
	数的:numerical:~
文脈:context::~
文脈的:contextual:~
新たな:new:~
方向:direction:~
更新-:update:~
最初の:first:~
乗算:multiplication:~
数学的:mathematical:~

最小化-:minimize:~
可能化-:enable:~
条件:condition:~
条件付き:conditional:~

	極力抑える:minimal にする:~
格納-:store:~:::ストア
桁:digit:~
検査-:check:~
検出-:detect:~
	検出-法:detecting
検索:search:~
辞書検索:dictionary lookup:~

構文:syntax:~:::シンタックス
構文解析-:parse:~:::パース
構築-:construct:~
構築法:constructing:~
構造:structure:~

真似て:mimic して:~
模倣-:emulate:~
模造-:simulate:模倣

横方向:horizontal:~


	次:next:~
	一般に:In general:~

消去-:erase:~
無視-:ignore:~
無限:infinite:~
照会-:query:~
特性:characteristic:~
状態:state:~
	状態~変化~中の:state-changing:~

現在:currently:~
現在の:current:~
理由:reason:~
生成-:generate:~
生成:generation:~
生産-:produce:~
画像:image:~
画素:pixel:~
派性-:derive:~
正規化-:normalize:~
正規化形:normalization form:~
比較-:compare:~
比較:comparison:~
整数:integer:~
組合せ:combination:~
	組にして:in combination
組合せた:combin した:~
組合せて:combin して:~
環境:environment:~
環境設定-:configure:~
環境設定:configuration:~
環境設定0:enviroment configuration:環境設定
環境設定1:enviroment settings:環境設定


監視-:monitor:~
	~~相対的~respect:#1
	~respectively:#1
	それぞれの／呼応する／~respective:#6
	対を成す~respective


	起動:initiation:~
起動-:initiate:~
起動0-:launch:起動
矢印:arrow:~
	矩形の:rectangular:~
破棄-:discard:~
確保-:ensure:~
移動-:move:~
	境界をまたいだmoved onto the boundaries
移動:movement:~
動き:movement:~
動く:move する:~
動いた:move した:~
動いて:move して:~
動かさ:move さ:~
動かす:move させる:~

稼働中:running:~
積層-:stack:~
積層:stacking:~
空:empty:~
等価:equivalent:~

範囲:range:~
終了-:terminate:~
経過-:elapse:~
	結果:result:~

絶対:absolute:~
継承-:inherit:~
継承:inheritance:~
継承関係:inheritance:~
維持管理-:maintain:~

	網羅する:exhaustive:~
編集-:edit:~
編集:editing:~
編集可能:editable:~
縦方向:vertical:~
置換-:replace:~

背景:background:~
表現-:represent:~
表現:representation:~
表示:display:~
表示域:viewport:~
	複数の:multiple:~
複製:copy:~
規則:rule:~
視覚的:visual:~
視野:scope:~:::スコープ
観測-:observe:~
	し得る:observable
解釈-:interpret:~
解釈:interpretation:~
計測:measurement:~
計測-:measure:~
計算-:calculate:~
記号:symbol:~
設定-:set:~
	設定しておく:set up
許容誤差:tolerance:~
hysteresis::::ヒステリシス
認識:recognition:~
説明:explanation:~
論理的:logical:~
識別-:identify:~
負の:negative:~
軸:axis:~
淵:edge:~
追加-:add:~
追加:addition:~
追加の:additional:~
送信-:send:~
送達:deliver:~
通知:notification:~
通知-:notify:~
速度:speed:~
連続して:consecutive に:~
連鎖:chain:~
進捗:progress:~
	進捗~中:in-progress
進行中:ongoing:~
遅延:delay:~
遠隔:remote:~:::リモート
選択-:select:~
選択:selection:~
選択可能:selectable:~
除去-:remove:~
除去:removal:~

部分集合:subset:~
量:amount:~
長さ:length:~
	開始-:start／starting／bigin／biginning
	関わらず:regardless:~

閲覧文脈:browsing context:~
階層的:hierarchical:~
頁:page:::ページ
頁区分:demarcated page:page 区分::ページ区分
順序:order:~
順序付けら:order さ:~
有順序:ordered:~
	順序を持つ:ordered:~
順序付け:ordering:~
順序集合:ordered set:順序付けられた集合
	類似する:similar:~
	似る／似た:similar:~
	字類:category:~


	●未分類
飛ばさ:skip さ:~
頻度:rate:~
位置:position:~
graphical:::グラフィック的
	＄文:statement:~
以前の:previous:~
	前掲の
	~previously:以前に#3
	築き上げる~build~up

request::::リクエスト
view::::ビュー
時間的:temporal:~
	~~出来事／~occurrence:#4

駆動-:drive:~
駆動:driven:~
anchor::::アンカー

終えた:finish した:~
出生-:originate:生成
由来-:originate:~

	由来する~origin
	~originated:#3
元の:original:~

増分的な:incremental:~
増加-:increment:~
幅:width:~
高さ:height:~

原点:origin:~
総和:sum:~

身体的不利:physical disabilities:~
	やりとり~interact:#1
	~remaining:#1
	~disregarding:#1
	~large:#2
工場出荷:factory-reset:~

頻度0:frequency:頻度

翻訳-:translate:~
	設定~setting:#2
増大-:increase:~
直接的な:direct:~
		繰返し:repetition:繰り返し

成分:component:~
component::::コンポーネント
	~choice:#2
発話:speech::~::スピーチ
覆う:cover する:~
拡充-:populate:~
遷移:transition:~
人間工学:ergonomics:~
描画-:render:~
	rendering
閲覧文脈:browsing context::~
中間的な:intermediate:~
復帰-:revert:~
関与-:contribute:~
自前の:own:~
制御:control:~

</script>

<!--%他の語
	~~区別する~disambiguate
	視点:perspective
	~halt:#1
	逆順にする~reverse:#2
	逆順にreverse order
	~starting:#2
	~perspective:#1
	~signal:~~通知#1
	~undo:#1
	~said:#1
	~preventing:#2
	切り替える~toggle:#1
	切り替え~toggling:#1
	~mention:#1
	~carried:#1
	~undone:#1
	~~以前の~prior:#2
	~place:#9
	いくつかの~several:#4
	~terminology:~~用語#1

	~swallow:#1
	~trust:#1
	~afford:~~付与#1
	~retain:~~維持#2
	~follow:#2
	〜の所へ~~移動reposition 〜 relative to:#1
	~clock time:時刻#1
	~period:-／#3
	~timerに基づく~timer-based:#1
	~address:#3
	~pertinent:~~関係する#4
	~formerly:以前までは#2
	~being:#19
	~chart:図表#5
	~bar~chart:図表

	示す~show:#2

	確定されたもの~definitive:#1
	~lower:#2
	~detailed:#1
	~contained:#2
	~~指す／~point:#4
	~deem:判断#1
	結び付け／~association:#2



	~~収まる~fall:#1
	まだ居る~stay:#1
	二回~twice:#1
	~beginning:#1
	~left0:#6
	~bound:境界#2
	~entering:#3
	~NULL~null:#1
	~between:#9

	~site:#2
	持ち続ける持続的~persistent:#1
	保ち続ける／~remain:#3
	~get:#2
	losing
	~gain:#1
	~gaining:#1
	沿う~along:#5
	~dented:#1
	~right-most:#3
	~bottom-most:#3
	~farthest:#3
	~depth:#3
	配慮／~care:#2
	表さ~express:#2
	在る~present
	在れば:present すれば:~
	一連の~successive:#1
	倍々~double:#1
	~binary:#1
	~serie:#2
	任意の~arbitrary:#2
	~desired:#1
	~desire:欲-#5
	~build:#2
	~after:#6
	~review:#1
	~refinement:#1

	~~促進-:foster:~

	~time:#12
	であろう:likely
	~find:#1

	~stage:#2
	~mailing:#1
	~publish:#2
	~welcome:#1
	主区画~main section:
	#2
	得ようと~achieve:#1
	~entirety:#1

	~subject:#1

しないことが奨励される~discouraged:#2
他所~elsewhere:#1

	-later:→将来
事項~portions
	~best:#1
	~practice

	~issue:#4
	~open:#3
	開かれるopens up
	終端-:~end:#3


	~shared:#1
	~t:#24
	重なり合う~overlap:#1
	~~頻度:lag time, degree, distance, and number of:#1
	上端~top
	最上段~top~row
	:#3
	~bottom:#1
	上から下へtop to bottom
	~around:#4
	~where:#3
	逆:opposite:~
	~emulate:#1
	~diagonal:#1
	~higher:#2
	~consider:#2
	~direct:#8
	向けられ~directed:#1
	3 個の~three:#5
	印刷~printed:#3

	~wish
	~meta:#1
	~holding:#1
	~long-key-pres:#1
	~~役割を果た:serve
	一覧／~table:#4
	推定-:deduce:
	~note:#4
	~unicode:#10
	~final:#2
	生じた~cause:#6
	一貫してinconsistent で:#2
	~posses:#1
	~held:#1
	知覚され得る~perceptible:#1
	~persisting:#1
	~option:#2
	に示されるもの~option
	
	~surface:#2
	~during:#4
	含める~including:#1
	終わらせる~exit:#2
	先に~earlier:#1
	次に来る~upcoming:#1

	叩く~hitting:#1
	閉じる~closing:#1
	保つ~keep:#2
	退けられ-~dismiss:#1
	~misrepresent:#1
	様々になる~vary:#4
	上向き~upward-pointing:#1
	~digital:#1
	~~正確でない:inaccurate:~
	低~level low-level:#1
	~adding:#1
	~writing:#3
	~~状況下~situation:#1
	現実の~real-world:#1

	~~素の:bare:#1


	できるようにする:permit:~
	~resulting:#2
	複数~keyの同時押下げ~chording:#1
	最も近くclosest match

	~using:#1
	~capital:#1
	~~小文字Latin~small~letter
	~small:#3
	~both:#1
	~rather:#2


	重複させる~duplicate:#1
	~~区別~distinction:#1
	~~最後に~finally:#1
	~~括る~bracket:#1
	~~外見上の~~類似:superficial resemblance:#1
	~semantic:#1

	~Web-application-based:#1
	~star:#1


	人~human:#3

	入る~enter:#1
	それに続く~trailing:#1
	前~before:#1
	明らかにする~apparent:#1
	~editor:#2
	~selecting:#1
	~see:#6

	~much:#1
	~fix:#1
	記す~signify:#5
	~fixed:#3
	因りdue to:#3
	~although:#1

	~want:#1

	成し~constitute:#2
	あたる~consult
	~made:#4

	部位~portion
	~contribution:#1
	~following:#1
	~please:#2
	~production:#1
	~run:#1
	概括~briefly:#1
	~Note:#1

	に基づいてふるまわせる用途に:for users who are interested in
	改良~refining:#1
	~pick:#1
	~saw:#1
	辿らせる~traverseさせる:#1
	~traversal:#2

	記され~denote:#1
	~color:#1
	各種~various:#1
	古い~older:#1
	~~互換な~interchangeable:#1
	~entire:#1
	書かれた~written:#1
	~~混成:hybrid::::ハイブリッド
	混成:mix:~
	~neither:#1
	~~目立たせている／注視されている~receptivity and concentration
	首位に据える~priming:#1
	最初へ戻るwraps around

	~loosely:#1
	~referred:#1
	同義語:synonym:~
	front-end:front end::::フロントエンド
	user-guided利用者により手引される
	各回~turn:#1
	~row:#1
	~five:#1
	普及している:popular な:~

	最も上層の~highest:#1
	~facility:#1
	~regard:#1
	直系かつ〜階層: the hierarchy in a direct lineage:
	~followed:#1
	~four:#1


元に戻す~undo
この時点at this point
取り上げられpicked up
には無いabsence from
通過-:pass:~
渡:pass:~
色付け~color~code
命名 名前

落とされ~drop

望ましい~desirable:#1
-~due~to
則って~accordingly
~~関わる~call~out
同じ時機に生じる~temporal occurrence
	-specifically,
複数回 生じ得るMultiple mousemove events
0 回 以上生じ得るOPTIONAL, multiple events
~~移動~shift
	微小な時間差small deviation in the time
 1 画素~単位より精細に~sub-pixel
右方／下方／奥方right-most edge, bottom-most edge, and farthest depth 
下へ~down
上へ~up
同時に複数の軸が回転された場合、＊~diagonal
場当たり的~ad-hoc:#1

決して:never:~
この:this#408
これらの:these#47
しかしながら:however#12
したがって，:thus#6
すでに:already#6
すべての:all#45
その:that#54
そのような:such#28
それらの:those#10
より:more#15
織り込んだtaking~into~account:#2
長い~long:#1
採られる~taken:#2
~~処理される＊~take~place

	~would:#7
	~have:#8
	~has:#9
	~alt:#1
	~very:#1
	~been:#6
	~we:#2
	~since:#3
	多い~often:#4
	~off:#2
	~onto:#2
	http:#1
	having:#1
	etc:#2
	jan:#1
	also:#6
	there:#4
	Model:#1
	their:#14
	what:#2
	either:#6
	if:#10
	no:#8
	nor:#2
	into:#5
	though:#4
	T:#31
	took:#1
	one:#21
	up:#6
	over:#10
	could:#6
	below:#4
	within:#1
	every:#3
	with:#24
	while:#10
	make:#6
	take:#15
	might:#24
	once:#3
	an:#13
	can:#13
	because:#1
	they:#1
	when:#5
	whose:#3
	just:#5
	even:#5
	only:#5
	down:#5
	must:#5

	track:#2
	publication:#1
	endorsement:#1
	Membership:#1
	by:#11
	be:#36
	or:#50
	at:#10
	any:#42
	than:#3
	in:#68
	who:#4
	are:#11
	not:#15
	out:#7
	under:#3
	them:#2
	taking:#3
	from:#5
	working:#1
	september:#1
	the:#209
	a:#79
	which:#24
	of:#60
	and:#163
	for:#30
	on:#7
	is:#16
	it:#15
	will:#11
	to:#64
	thank:#6
	was:#7
	yet:#1
	do:#3
	then:#3
	upon:#2
	so:#3
	us:#1
	your:#1


-->
<!--%style -->

<style>

.key, .key-code, .key-cap {
	padding:0 0.2em;
	color: black;
	border-radius: 3px;
}

.key {
	/* event.key value */
    background-color: #B0E0E6;
}
.glyph {
	color: black;
	background-color: #FFE4B5;
}
.key-code { /* event.code value */
	background: #f0a4f0;
}

.key-cap {
	border: outset 1px silver;
	font-family: sans-serif0, sans-serif;
}

*[lang="en"] {
	white-space: pre-line;
}




/* event 定義表 */

tr {
	border-top: 1px solid silver;
}

table.eventdef {
	border-spacing: 0px;
	background-color: hsl(300, 50%, 95% );
	border-left: 0.5em solid;
}

table.eventdef {
	border-left-color: hsl(300, 70%, 80% )
}

table.eventdef tr,
table.eventdef td {
	border-top-color: hsl(300, 50%, 85% );
}

table.eventdef th {
	white-space: nowrap;
}

table.eventdef td {
	min-width: 12em;
	border-left: 1px solid hsl(300, 50%, 85% );
}


</style>


</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
<!--%resource pool -->
	<div id="_persisted_parts">

<img
	id="_dgm-eventflow"
	style="display:block; height:560px;"
	src="uievents/eventflow.svg"
	alt=""
>

<img
	id="_dgm-stacked-event-mouse-dispatch"
	style="display:block; height:250px;"
	src="uievents/stacked-event-mouse-dispatch.svg"
	alt="Graphical representation of three stacked elements all on top of each other. The bottom element is labeled A and the top element is C"
>
	</div>
</div>

<aside class="trans-meta">
<h1>UI Events 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により副題の日付にて <strong>作業草案</strong>として公開された
<a id="_SPEC_URL">UI Events</a>
（ 旧 DOM Level 3 Events ）を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2017-02-06</time>
（公開：<time>2015-08-28</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>



<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 id="title">UI Events 仕様</h1>
<h2>2017 年 2 月 4 日付 W3C 作業草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd><span>https://www.w3.org/TR/2017/WD-uievents-20170204/</span></dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/uievents/</dd>

	<dt title="Editor's Draft:">編集者草案</dt>
	<dd>https://w3c.github.io/uievents/</dd>

	<dt title="Previous versions:">以前のバージョン</dt>
	<dd>https://www.w3.org/TR/2015/WD-uievents-20151215/</dd>
	<dd>http://www.w3.org/TR/2015/WD-uievents-20150428/</dd>
	<dd>http://www.w3.org/TR/2015/WD-uievents-20150319/</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/uievents/issues/">GitHub</a></dd>
<!-- 
https://github.com/w3c/uievents/commits/gh-pages
	<dd><dfn id="_inline-in-spec" data-cycling=".issue">仕様内</dfn></dd>
 -->

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:garykac@google.com?subject=%5BUI-events%5D%20Spec%20Feedback">Gary Kacmarcik</a> (Google)</dd>
	<dd><a href="mailto:travis.leithead@microsoft.com?subject=%5BUI-events%5D%20Spec%20Feedback">Travis Leithead</a> (Microsoft)</dd>
	<dd>Doug Schepers (Mar 2008 - May 2011)</dd>

</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2017 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply. 
</small>


</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">~~要約</h2>

<p>
この仕様は、
`DOM$r にて定義される DOM Event ~objを拡張する， UI Events を定義する。
UI Events は、概して視覚的~UAにより，利用者による~mouseや~keyboardなどの入力~操作を取扱うために実装されている。
◎
This specification defines UI Events which extend the DOM Event objects defined in [DOM]. UI Events are those typically implemented by visual user agents for handling user interaction such as mouse and keyboard input.
</p>

	</section>
	<section id="status">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲。
】</span></p>

<p>
この文書は、
<a href="http://www.w3.org/WebPlatform/WG/">Web Platform Working Group</a>
により，作業草案として~~発行されました。
この文書に関する~feedbackと~commentを歓迎します。
<a href="https://github.com/w3c/uievents/issues">Github issues</a>
を利用されたし。
これまでの討論は
<a href="https://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org archives</a>
に見られます。
◎
This document was published by the Web Platform Working Group as a Working Draft. Feedback and comments on this specification are welcome. Please use Github issues Historical discussions can be found in the public-webapps@w3.org archives.
</p>

<!-- 
This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/.

The management and production of this document follows a relatively complex setup. Details are provided as part of the introduction.

Publication as a Working Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.

This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 September 2015 W3C Process Document.
-->


	</section>

<main id="MAIN0">

	<section id="ui-events-intro">


<h2 title="Introduction">1. 序論</h2>

		<section id="dom-events-overview">
<h3 title="Overview">1.1. 概観</h3>
<p>
UI Events は、~~主に二つの目標を念頭に設計されている。
第一の目標は、`~event$~systemを，`~event~listener$を登録できるように, および
~event~flowを木~構造を通して述べ得るように設計することである。
加えて，この仕様は、~UI~controlや文書の変異†
— これら各~event~moduleに対する定義済みの文脈的~情報を含む —
を通知するための，~eventの標準的な~moduleを提供する。
◎
UI Events is designed with two main goals. The first goal is the design of an event system which allows registration of event listeners and describes event flow through a tree structure. Additionally, the specification will provide standard modules of events for user interface control and document mutation notifications, including defined contextual information for each of these event modules.
</p>

<p class="trans-note">【†
<a href="~UIEVENTS-A#legacy-mutationevent-events">変異~event</a>
については，`非推奨に$されており、 `DOM$r にて再定義されている。
】</p>

<p>
UI Events の第二の目標は、既存の~browserに利用されている，現在の~event~systemに共通する~~機能を提供することである。
これには、既存の［
~script, 内容
］との相互運用性を~~促進することが意図されている。
この目標には、後方互換性を全部的に満たすことは，期待されていない。
しかしながら、この仕様は，可能0な所では これを得ようと試みる。
◎
The second goal of UI Events is to provide a common subset of the current event systems used in existing browsers. This is intended to foster interoperability of existing scripts and content. It is not expected that this goal will be met with full backwards compatibility. However, the specification attempts to achieve this when possible.
</p>
		</section>
		<section id="dom-events-conformance">
<h3 title="Conformance">1.2. 適合性</h3>

`ui-events-conformance^APX

		</section>
		<section id="style-conventions">
<h3 title="Stylistic Conventions">2. ~style上の規約</h3>
<p>
<!-- 
この仕様
<a href="http://www.w3.org/People/Schepers/spec-conventions.html">Proposed W3C Specification Conventions</a>
に従う,
 -->
この仕様では、次の表記が用いられる：
◎
This specification follows the Proposed W3C Specification Conventions, with the following supplemental additions:
</p>

<div>

<table>
<thead><tr><th>表記~例
<th>意味
</thead>

<tbody><tr><td>`↓^cap, `=^cap, `Q^cap
<td>~key上に印字される <a href="#key-legends">~key~cap</a>。
この表記は、生成される `KeyboardEvent!I の `key$m, `code$m 値には関わらない，利用者~視点の~keyを指すときに利用される。

<tr><td>`ア^kGl, `漢字^kGl
<td>文字／文字~並びを表現している~glyph並び

<tr><td>`003D^U
<td>~Unicode文字

<tr><td>`ArrowDown$kY, `=^kY, `q^kY, `Q^kY
<td>~keyを押して生成される~key値の名前（すなわち，
`KeyboardEvent^I の `key$m 値）。

<tr><td>`ArrowDown$kC, `Equal$kC, `KeyQ$kC
<td>物理的な~keyに結付けられている~key~code（すなわち、 
`KeyboardEvent^I の `code$m 値）の名前

</tbody></table>

◎
• The key cap printed on a key is shown as ↓, = or Q. This is used to refer to a key from the user’s perspective without regard for the key and code values in the generated KeyboardEvent.
• Glyphs representing character are shown as: "𣧂".
• Unicode character encodings are shown as: U+003d.
• Names of key values generated by a key press (i.e., the value of KeyboardEvent.key) are shown as: "ArrowDown", "=", "q" or "Q".
• Names of key codes associated with the physical keys (i.e., the value of KeyboardEvent.code) are shown as: "ArrowDown", "Equal" or "KeyQ".
</div>


<p>
加えて，この仕様における一定の用語は、特定0の意味で利用される。
語 “実装”は、~browser, 内容~著作tool, その他，この仕様を実装する`~UA$を~~指す。
語 内容~作者は、~ifc, ~method, 属性, ~event, その他，この仕様にて述べる他の特色機能を利用する~scriptや~codeを書いて，~Web~appを作る者を~~指す。
利用者とは，ある実装の下で それらの~Web~appを利用する者を~~指す。
◎
In addition, certain terms are used in this specification with particular meanings. The term "implementation" applies to a browser, content authoring tool, or other user agent that implements this specification, while a content author is a person who writes script or code that takes advantage of the interfaces, methods, attributes, events, and other features described in this specification in order to make Web applications, and a user is the person who uses those Web applications in an implementation.
◎
And finally:
• This is a note.
• This is an open issue.
• This is a warning.
interface Example {
    // This is an IDL definition.
}
</p>

		</section>
	</section>
	<section id="dom-event-architecture">

<h2 title="DOM Event Architecture">3. ~DOM~event~architecture</h2>

<p>
この節は規定ではない。
~DOM~event~architectureの規範的な記述は `DOM$r を参照のこと。
◎
This section is non-normative. Refer to [DOM] for a normative description of the DOM event architecture
</p>


		<section id="event-flow">
<h3 title="Event dispatch and DOM event flow">3.1. ~event配送と~DOM~event~flow</h3>


<p>
この節では、~event`配送$の仕組みの概観を与え、~eventが~DOM木を通してどのように伝播するかについて述べる。
~appは， `dispatchEvent()$m ~methodを利用して~event~objを配送し、~event~objは，~DOM~event~flowにより決定されるように~DOM木を通して伝播する。
◎
This section gives a brief overview of the event dispatch mechanism and describes how events propagate through the DOM tree. Applications can dispatch event objects using the dispatchEvent() method, and the event object will propagate through the DOM tree as determined by the DOM event flow.
</p>

<figure id="figure-dom-event-flow">`eventflow^dgm
<figcaption>
~DOM~event~flowを利用して`~DOM木$内に配送される~eventの~graphical表現
◎
Graphical representation of an event dispatched in a DOM tree using the DOM event flow
</figcaption></figure>

<p>
~event~objは，`~event標的$に向けて配送されるが、その前に~event~objの`伝播~経路$を決定する必要がある。
◎
Event objects are dispatched to an event target. But before dispatch can begin, the event object’s propagation path must first be determined.
</p>

<p>
`伝播~経路$は，`現在の~event標的$たちからなる有順序~listであり、~eventはそれらを通過する。
この伝播~経路は、文書の階層的~木~構造を反映する。
~list内の最後の~itemが`~event標的$になり、~list内で先行する~itemは
<em>標的の先祖</em>とされ, 直前の~itemが <em>標的の親</em>とされる。
◎
The propagation path is an ordered list of current event targets through which the event passes. This propagation path reflects the hierarchical tree structure of the document. The last item in the list is the event target, and the preceding items in the list are referred to as the target’s ancestors, with the immediately preceding item as the target’s parent.
</p>

<p>
`伝播~経路$が決定されたなら、~event~objは， 1 つ以上の`~event相$を経る。
~event相には、次の 3 つ：［
`捕獲-相$, `標的~相$, `浮上-相$
］がある。
~event~objは、これらの相を下に述べるように完了する。
相のうち~supportされないものは，飛ばされ、また，~event~objの伝播が停止された場合にも飛ばされる。
例えば、
`bubbles$m 属性が ~F に設定された場合，浮上-相は飛ばされ、配送するに先立って
`stopPropagation()$m が~callされた場合，すべての相は飛ばされることになる。
◎
Once the propagation path has been determined, the event object passes through one or more event phases. There are three event phases: capture phase, target phase and bubble phase. Event objects complete these phases as described below. A phase will be skipped if it is not supported, or if the event object’s propagation has been stopped. For example, if the bubbles attribute is set to false, the bubble phase will be skipped, and if stopPropagation() has been called prior to the dispatch, all phases will be skipped.
</p>


<dl>
	<dt>`捕獲-相@ （ capture phase ）</dt>
	<dd>
この相の下では、~event~objは，`伝播~経路$を順方向に辿って, 標的の手前まで伝播する。
すなわち、`~Window$から標的の親まで，標的の各~先祖を辿ることになる。
◎
The capture phase: The event object propagates through the target’s ancestors from the Window to the target’s parent. This phase is also known as the capturing phase.
</dd>

	<dt>`標的~相@（ at-target phase ）</dt>
	<dd>
~event~objは、その`標的$に到着する。
`~event型$にて，~eventは浮上しないものと指示されている場合、~eventの伝播は，この相の完了を以って終える。
◎
The target phase: The event object arrives at the event object’s event target. This phase is also known as the at-target phase. If the event type indicates that the event doesn’t bubble, then the event object will halt after completion of this phase.
</dd>

	<dt>`浮上-相@ （ bubble phase ）</dt>
	<dd>
この相の下では、~event~objは，`捕獲-相$のときと同じ`伝播~経路$を，その逆順に辿ることになる。
すなわち、標的の親から `~Window$まで，標的の各~先祖を辿って伝播することになる。
◎
The bubble phase: The event object propagates through the target’s ancestors in reverse order, starting with the target’s parent and ending with the Window. This phase is also known as the bubbling phase.
</dd>
</dl>

		</section>
		<section id="event-flow-default-cancel">
<h3 title="Default actions and cancelable events">3.2. 既定~動作と取消可能~event</h3>


<p>
~eventは、概して，［
利用者による動作の結果として ／
~taskの完了に呼応して ／
非同期的~活動（~network~requestなど）の進捗を~~通知するために
］実装により発火される。
~eventには、その後に実装が次に採り得る挙動を制御する（または すでに採った動作を元に戻す）ために利用されるものもある。
この類の~eventは，
`取消可能@
と呼ばれ、それが取消す挙動は，
`既定~動作$
と呼ばれる。
`取消可能$な~event~objには、複数の`既定~動作$が結付けられることもある。
~eventを取消すためには、 `preventDefault()$m ~methodを~callする。
◎
Events are typically dispatched by the implementation as a result of a user action, in response to the completion of a task, or to signal progress during asynchronous activity (such as a network request). Some events can be used to control the behavior that the implementation may take next (or undo an action that the implementation already took). Events in this category are said to be cancelable and the behavior they cancel is called their default action. Cancelable event objects can be associated with one or more 'default actions'. To cancel an event, call the preventDefault() method.
</p>

<div class="example">

<p>
`mousedown$et ~eventは、利用者が~pointing装置（概して~mouse）の~buttonを押した直後に発火される。
実装が採り得る`既定~動作$の一つには、［
利用者が 画像や選択~textを~dragできるように，状態~machineを設定しておく
］ことが挙げられる。
`既定~動作$は，次に何が起きるかに依存する
— 例えば、利用者の~pointing装置が~text上を指していれば，~text選択が始まり、画像~上を指していれば，画像の~drag動作が始まるであろう。
`mousedown$et ~eventの`既定~動作$を防止すると、これらの動作は生じなくなる。
◎
A mousedown event is dispatched immediately after the user presses down a button on a pointing device (typically a mouse). One possible default action taken by the implementation is to set up a state machine that allows the user to drag images or select text. The default action depends on what happens next — for example, if the user’s pointing device is over text, a text selection might begin. If the user’s pointing device is over an image, then an image-drag action could begin. Preventing the default action of a mousedown event prevents these actions from occurring.
</p>
</div>

<p>
`既定~動作$は，通例、~event配送が完了した後に遂行される~SHOULDであるが、例外的~事例では，~eventが配送される直前に遂行されることもある。
◎
Default actions are usually performed after the event dispatch has been completed, but in exceptional cases they may also be performed immediately before the event is dispatched.
</p>

<div class="example">
<p>
`input type="checkbox"^e 要素~上の `click$et ~eventに結付けられている既定~動作は、その要素の `checked^c IDL 属性~値を
【~eventが配送される前に】
切り替える。
`click$et ~eventの既定~動作が取消された場合、値は，~~元の状態に戻される。
◎
The default action associated with the click event on &lt;input type="checkbox"&gt; elements toggles the checked IDL attribute value of that element. If the click event’s default action is cancelled, then the value is restored to its former state.
</p>
</div>

<p>
~eventが取消されたときは、~eventに結付けられている条件付き`既定~動作$は，飛ばされる（あるいは，上に示したように、`既定~動作$が配送~前に行われていたなら，その効果は~~元に戻される）。
~event~objが`取消可能$かどうかは、 `cancelable$m 属性に指示される。
`preventDefault()$m の~callは、~event~objに関係するすべての`既定~動作$を
【その~eventが取消可能ならば】
停止する。
`defaultPrevented$m 属性は、~eventが（例えば，先に呼ばれた`~event~listener$により）すでに取消されたかどうかを指示する。
`~DOM~app$自身が
`dispatchEvent()$m ~methodで配送を起動させた場合、その返値は，~event~objが取消されたかどうかを指示する。
◎
When an event is canceled, then the conditional default actions associated with the event is skipped (or as mentioned above, if the default actions are carried out before the dispatch, their effect is undone). Whether an event object is cancelable is indicated by the cancelable attribute. Calling preventDefault() stops all related default actions of an event object. The defaultPrevented attribute indicates whether an event has already been canceled (e.g., by a prior event listener). If the DOM application itself initiated the dispatch, then the return value of the dispatchEvent() method indicates whether the event object was cancelled.
</p>

<p class="note">注記：
多くの実装は，`~event~listener$の返値を上述に加えて解釈する
— 値 ~F  に対しては、`取消可能$~eventの`既定~動作$を取消すことを意味するなど（~~例外として、 `window.onerror^m ~handlerでは， ~T を返すことにより取消されるが）。
◎
Many implementations additionally interpret an event listener’s return value, such as the value false, to mean that the default action of cancelable events will be cancelled (though window.onerror handlers are cancelled by returning true).
</p>

		</section>
		<section id="sync-async">
<h3 title="Synchronous and asynchronous events">3.3. 同期的／非同期的~event</h3>

<p>
~eventは、他の~eventと同期的に配送されることもあれば, そうでない（非同期的）こともある。
◎
Events may be dispatched either synchronously or asynchronously.
</p>

<p>
~eventのうち，同期的とされているもの（ “同期~event” ）は、同じ時機に生じた［
他の~event ／ ~DOMにおける変更 ／ 利用者操作
］による~eventの <em>連列</em>（ sequence ）の中で互いに順序付けられた，［
FIFO（ first-in-first-out ）~modelにおける，仮想の待行列
］内にあるかのように扱われる。
この待行列~内の各~eventは、前の~eventにおける伝播の挙動が［
完了するか, 取消される
］まで遅延される。
一部の同期~eventは、~mouse~button~eventなど，特定の［
装置／処理
］により駆動される。
この種の~eventは、そのような~event連列に対し定義され，`~event序列$~algoにより統治される
— ~UAは、この種の~eventを定義済みの順序で配送することになる。
◎
Events which are synchronous ("sync events") are treated as if they are in a virtual queue in a first-in-first-out model, ordered by sequence of temporal occurrence with respect to other events, to changes in the DOM, and to user interaction. Each event in this virtual queue is delayed until the previous event has completed its propagation behavior, or been canceled. Some sync events are driven by a specific device or process, such as mouse button events. These events are governed by the event order algorithms defined for that set of events, and user agents will dispatch these events in the defined order.
</p>

<p class="trans-note">【
同期／非同期
の定義は，他の~eventとの関係に基づく
— 現在は非同期とされている~eventであっても，新たな~event型が導入されたときは、それと同期的な関係になり得ることになる。
】</p>


<p>
非同期的な~event（ “非同期~event” ）は、［
他の~event ／
~DOMにおける他の変更 ／
利用者操作
］には関係なく，動作が完了した結果として発火され得る。
◎
Events which are asynchronous ("async events") may be dispatched as the results of the action are completed, with no relation to other events, to other changes in the DOM, nor to user interaction.
</p>

<div class="example">

<p>
埋込みの~script要素は、文書の読込み中に構文解析されて実行される。
`load$et ~eventは、その~script要素にて，非同期的に発火されるように待行列に入れられる。
しかしながら，それは非同期~eventなので、文書の読込み中に発火される他の同期的~event（ `HTML5$r の `DOMContentLoaded^et など）との順序~関係は、保証されない。
◎
During loading of a document, an inline script element is parsed and executed. The load event is queued to be fired asynchronously at the script element. However, because it is an async event, its order with relation to other synchronous events fired during document load (such as the DOMContentLoaded event from [HTML5]) is not guaranteed.
</p>
</div>

		</section>
		<section id="trusted-events">
<h3 title="Trusted events">3.4. ~trusted~event</h3>

<p>
利用者操作の結果として, あるいは
~DOMに対する変更の直接的な結果として，`~UA$により生成される~eventは、`~UA$により~trustされ、［
~scriptにより［
`createEvent()$m ~methodを通して生成された ／
`initEvent()$m ~methodを利用して改変された ／
`dispatchEvent()$m ~methodを介して配送された
］~event
］には~~付与されないような，特権が伴われる。
`isTrusted$m 属性の値は、~trusted~eventに対しては ~T であり，
非trusted~eventに対しては ~F である。
◎
Events that are generated by the user agent, either as a result of user interaction, or as a direct result of changes to the DOM, are trusted by the user agent with privileges that are not afforded to events generated by script through the createEvent() method, modified using the initEvent() method, or dispatched via the dispatchEvent() method. The isTrusted attribute of trusted events has a value of true, while untrusted events have a isTrusted attribute value of false.
</p>

<p class="trans-note">【
~scriptにより間接的に~trusted~eventが発火されることはあり得る。
例えば`~pointing先$の要素が`~DOM木$から除去された場合、その背後にある要素に向けて `mouseover$et が発火され得る
— その~eventの `isTrusted^m は ~T になる。
】</p>

<p>
`click$et ~eventを除く大部分の非trusted~eventは、`既定~動作$を誘発することはない。
`click$et ~eventは、
`isTrusted$m 属性が ~F であっても，`既定~動作$を誘発する（この挙動は、後方互換性のために~~維持されている）。
他のすべての非trusted~eventは、その~event上に
`preventDefault()$m
~methodが~callされていたかのように，ふるまう。
◎
Most untrusted events will not trigger default actions, with the exception of the click event. This event always triggers the default action, even if the isTrusted attribute is false (this behavior is retained for backward-compatibility). All other untrusted events behave as if the preventDefault() method had been called on that event.
</p>



		</section>
		<section id="event-flow-activation">
<h3 title="Activation triggers and behavior">3.5. 作動化の 誘発と挙動</h3>

<p>
ある種の`~event標的$（~link要素／~button要素など）には、実装が，`作動化の誘発$（例：~linkを~clickする）に呼応して遂行するような，`作動化の挙動$（例：~linkを辿る）が結付けられることもある。
◎
Certain event targets (such as a link or button element) may have associated activation behavior (such a following a link) that implementations perform in response to an activation trigger (such as clicking a link).
</p>


<div class="example" id="example-activation">
<p>
HTML, SVG のいずれも
~linkを指示する `a^e 要素を備えている。
`a^e 要素に関連する`作動化の誘発$には、［
`a^e 要素の内容~上での `click$et ~event
］, ［
`a^e 要素が~focusを得ている下での，
`KeyboardEvent.key$m 属性~値が `Enter$kY ~keyである `keydown$et ~event
］がある。
`a^e 要素に対する通常の`作動化の挙動$は、外部~linkならば ~windowの内容を新たな文書に一新し，内部~linkならば 現在の文書にて~link先の~anchorへ~~移動することである。
◎
Both HTML and SVG have an &lt;a&gt; element which indicates a link. Relevant activation triggers for an &lt;a&gt; element are a click event on the text or image content of the &lt;a&gt; element, or a keydown event with a key attribute value of "Enter" key when the &lt;a&gt; element has focus. The activation behavior for an &lt;a&gt; element is normally to change the content of the window to the content of the new document, in the case of external links, or to reposition the current document relative to the new anchor, in the case of internal links.
</p>
</div>

<div >
<p>
`作動化の誘発$は、［
利用者による動作
］であるか, または［［
`作動化の挙動$が起動されるべきことを，実装に指示する
］ような，~event
］である。
</p>

<p>
利用者により起動される`作動化の誘発$には、作動可能な要素に対する次の動作が含まれる：
</p>

<ul><li>その要素~上で~mouse~buttonを~clickする
</li><li>その要素が~focusを得ている下で `Enter^cap ~keyを押す
</li><li>その要素が~focusを得ているかどうかに関わらず，何らかの方法で その要素に~linkされている~key（
“~hotkey” ／ “~access-key”
）を押す
</li></ul>

<p>
~eventに基づく`作動化の誘発$には、次のものがあり得る：
</p>

<ul><li>［
一定の時刻に／一定~時間が経過したとき
］に要素を作動化させるような，~timerに基づく~event
</li><li>一定の動作の完了~時に生じるような，`進捗~event$
</li><li>他の 条件／状態に基づくような，多数の~event
</li></ul>

◎
An activation trigger is a user action or an event which indicates to the implementation that an activation behavior should be initiated. User-initiated activation triggers include clicking a mouse button on an activatable element, pressing the Enter key when an activatable element has focus, or pressing a key that is somehow linked to an activatable element (a "hotkey" or "access key") even when that element does not have focus. Event-based activation triggers may include timer-based events that activate an element at a certain clock time or after a certain time period has elapsed, progress events after a certain action has been completed, or many other condition-based or state-based events.
</div>

		</section>
		<section id="event-constructors">
<h2 title="Constructing Mouse and Keyboard Events">3.6. `Mouse^I ／ `Keyboard^I ~eventの構築法</h2>

<p>
一般的に、`Event$I ~ifc またはそれを継承する~ifcの構築子が呼出されたときは，
`DOM$r に述べられる手続きに従うべきであるが、それに加え，［
`KeyboardEvent$I ／ `MouseEvent$I
］~ifcは、［
`Event$I ~objにおける<a href="#keys-modifiers">~key修飾</a>の内部~状態を初期化する
］ための追加の辞書~memberも提供する。
この内部~状態は、［
`KeyboardEvent.getModifierState()$m ／ `MouseEvent.getModifierState()$m
］~methodを用いて照会できる。
この節では、 DOM4 による，新たな `Event$I ~objを初期化する手続きに，この修飾~状態の初期化も追補する。
◎
Generally, when a constructor of an Event interface, or of an interface inherited from the Event interface, is invoked, the steps described in [DOM] should be followed. However the KeyboardEvent and MouseEvent interfaces provide additional dictionary members for initializing the internal state of the Event object’s key modifiers: specifically, the internal state queried for using the getModifierState() and getModifierState() methods. This section supplements the DOM4 steps for intializing a new Event object with these optional modifier states.
</p>

<div class="p">

<p>
与えられた，どの［
`KeyboardEvent$I, `MouseEvent$I, または
これらから派性する~ifc
］を実装する~objも，各種
`~key修飾~名$
に対応する，
`内部~key修飾~状態@
を持つ。
それは：
</p>

<ul><li>下の~algoを利用して，~objを構築する際に設定できる。
</li><li>`UIEvents-Key$r の`修飾~key一覧$に述べられる
`~key修飾~名@
を用いて取得0できる。
</li></ul>


◎
For the purposes of constructing a KeyboardEvent, MouseEvent, or object derived from these objects using the algorithm below, all KeyboardEvent, MouseEvent, and derived objects have internal key modifier state which can be set and retrieved using the key modifier names described in the Modifier Keys table in [UIEvents-Key].
</div>

<p>
次の手続きが， DOM4 による~eventの構築法に定義される~algoに追補される：
◎
The following steps supplement the algorithm defined for constructing events in DOM4:
</p>

<ol>
	<li>
<p>
~event~obj %~event を構築する際に，構築子に
`EventModifierInit$I 引数 %dict が供された場合、次の下位手続きを実行する：
</p>
		<ol>
			<li>
<p>
各 `~key修飾~名$ %名前 に対し：
</p>
				<ol>
					<li>
<p>
%dict 内に［［
文字列 "`modifier^c" と %名前 を順に連結した文字列
］を名前に持つ辞書~member %member
］があるならば：
</p>
						<ol>
							<li>
［
%名前 に対応する，
%~event の `内部~key修飾~状態$
］を %member の値に設定する。
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
◎
If the Event being constructed is a KeyboardEvent or MouseEvent object or an object that derives from either of these, and a EventModifierInit argument was provided to the constructor, then run the following sub-steps:
◎
For each EventModifierInit argument, if the dictionary member begins with the string "modifier", then let the key modifier name be the dictionary member’s name excluding the prefix "modifier", and set the Event object’s internal key modifier state that matches the key modifier name to the corresponding value.
	</li>
</ol>
		</section>
	</section>
	<section id="event-types">

<h2 title="Event Types">4. ~event型</h2>
<p>
~DOM~Event ~modelでは、~DOM実装が複数の~moduleからなる~eventを~supportすることも
許容される。
~modelは、将来における新たな~event~moduleを追加できるように，設計されている。
この文書は、可能0なすべての~eventを定義することは試みない。
相互運用性の目的0においては、~DOMが
~UI~eventの~module（低~levelの装置~依存~eventを含む）, および
文書~変異~eventの~moduleを定義する。
◎
The DOM Event Model allows a DOM implementation to support multiple modules of events. The model has been designed to allow addition of new event modules in the future. This document does not attempt to define all possible events. For purposes of interoperability, the DOM defines a module of user interface events including lower level device dependent events and a module of document mutation events.
</p>

		<section id="_event-definition-table">
<h3>【~eventの定義表】</h3>

<p>
この仕様に現れる，各種`~event型$の定義は、次のような表形式で与えられる：
</p>

`●型^
この欄には、当の~event型の名前が記される（例： `click^et ）。
`●界面^
この欄には、この型の~event~objが実装する~ifcが示される（例： `MouseEvent^I ）。
`●同期^
この欄には、この型の~eventが他の~eventと`同期$して生じ得るならば “あり”／
他の場合は “なし” と記される。
`●浮上^
この欄には、この型の~eventが `浮上-$するならば “する” ／
他の場合は “しない” と記される。
後者の場合、この~eventに対する`~event~listener$が`浮上-相$に対し登録されても，誘発されないことになる。
`●標的^
この欄には、この型の~eventの`標的$になり得る~objが挙げられる（例： `Element$I ）。
そうでない~objに，この~eventに対する`~event~listener$が登録されても，`~trusted$~eventは誘発されないことになる。
`●取消^
この欄には、この型の~eventが`取消可能$ならば  “可” ／
他の場合は “不可” と記される。
`●構^
`composed$m 属性に関係する
— 単に， “Yes” 記されているならその属性~値は ~T をとる —
と見られるが、実際の定義は不明。
<!-- 
Yes = この型の~eventは “shadow 木を貫く” ？
-->
“Yes” 以外にどのような値または記述があり得るのかも不明。
この欄が無い~event型もあり、その不在が何を意味するのかも不明。

`●既定動作^
この欄には、この型の~eventに結付けられ得る`既定~動作$が挙げられる（例：頁を~scrollする）。
`●文脈^
この欄には、この型の~eventが実装する（~ifc欄に挙げられている）~ifcの各種~memberが，どのような値に初期化されるかが述べられる。
`●表終^


<p>注意：
この表の大部分は、`~trusted$~eventに対してのみ意味を持つ。
`~trusted$でない~event（~scriptが作成したものなど）は、この表に従うとは限らない。
例えば、`既定~動作$があっても，行われないであろう。
</p>

		</section>
		<section id="events-uievents">
<h3 title="User Interface Events">4.1. ~UI~event</h3>

<p>
~UI~event~moduleは、~UIや文書の操作1に結付けられている，基本的な~event型について述べる。
◎
The User Interface event module contains basic event types associated with user interfaces and document manipulation.
</p>

			<section id="interface-uievent">
<h4 title="Interface UIEvent">4.1.1. ~ifc `UIEvent^I</h4>

<p class="intro-dom">
~DOM2にて導入された。
◎
Introduced in DOM Level 2
</p>

<p>
`UIEvent^I ~ifcは、~UI~event特有の文脈的~情報を提供する。
◎
The UIEvent interface provides specific contextual information associated with User Interface events.
</p>

<p>
`UIEvent^I ~ifcの~instanceを作成するためには、その構築子に
`UIEventInit^I 辞書（省略可）を渡して呼び出す。
◎
To create an instance of the UIEvent interface, use the UIEvent constructor, passing an optional UIEventInit dictionary.
</p>

				<section id="idl-uievent">
<h5>4.1.1.1. `UIEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `UIEventInit$I %eventInitDict)]
interface `UIEvent@I : `Event$I {
    ~RA `Window$I? `view$m;
    ~RA long    `detail$m;
};
</pre>


<dl class="idl-def">

<!-- ＊
UIEvent . view 等々
 -->

	<dt>`view@m</dt>
	<dd>
この属性は、~eventがどの `Window$I から生成されたかを識別する。
◎
The view attribute identifies the Window from which the event was generated.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>`detail@m</dt>
	<dd>
この属性には、~eventの型に依存して， `Event$I についての一部の詳細~情報が指定される。
◎
Specifies some detail information about the Event, depending on the type of event.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>
</dl>

				</section>
				<section id="idl-uieventinit">
<h5>4.1.1.2. `UIEventInit^I</h5>

<pre class="idl">
dictionary `UIEventInit@I : `EventInit$I {
    `Window$I? `view$m = null;
    long    `detail$m = 0;
};
</pre>

<dl class="idl-def">
	<dt>`view@m</dt>
	<dd>
この~memberは、この~eventの配送~先の大域~環境の~Windowにされる~SHOULDである。
この~eventが要素に配送されるなら、その要素の`~node文書$を包含する~Windowに設定される~SHOULDである。
◎
Should be initialized to the Window object of the global environment in which this event will be dispatched. If this event will be dispatched to an element, the view property should be set to the Window object containing the element’s ownerDocument.
</dd>

	<dt>`detail@m</dt>
	<dd>
この値は、個々の~app特有の整数を与える。
◎
This value is initialized to a number that is application-specific.
</dd>

</dl>

				</section>
			</section>
			<section id="events-uievent-types">
<h4>4.1.2. 各種~UI~event型</h4>

<p>
以下に，各種~UI~event型を挙げる。
これらの~eventのうち一部のものは、［
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
］~ifcを利用する。
詳細は各~eventに。
◎
The User Interface event types are listed below. Some of these events use the UIEvent interface if generated from a user interface, but the Event interface otherwise, as detailed in each event.
</p>


				<section id="event-type-load">
<h5>4.1.2.1. `load^et</h5>

`●型^ `load@et
`●界面^ 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎
UIEvent if generated from a user interface, Event otherwise.
`●同期^ なし
`●浮上^ しない
`●標的^ `Window$I, `Document$I, `Element$I
`●取消^ 不可
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
資源を読込んだ~obj<!-- ＊ -->
</li></ul>

◎
• Event.target : common object whose contained resources have loaded
• UIEvent.view : Window
• UIEvent.detail : 0

`●表終^

<p>
~UAは、［
~DOM実装が資源（文書など）, および
すべての従属~資源（画像, ~stylesheet, ~scriptなど）の読込ingを終えた
］とき，この~eventを発火し~MUST。
従属~資源の読込みに失敗した場合でも、それを読込んだ資源が~DOMを介して依然として~access可能である場合には，この~eventの発火を止めては~MUST_NOT。
実装が，この~event型を発火するときには、少なくとも `Document$I ~node上に配送することが要求される。
◎
A user agent MUST dispatch this event when the DOM implementation finishes loading the resource (such as the document) and any dependent resources (such as images, style sheets, or scripts). Dependent resources that fail to load MUST NOT prevent this event from firing if the resource that loaded them is still accessible via the DOM. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.
</p>

<p class="note">注記：
旧来の理由から、 HTML 実装においては、文書の内側の資源（例えば画像）に対する `load$et ~eventの`伝播~経路$は， `~Window$ を含まない。
詳細は `HTML5$r を見よ。
◎
For legacy reasons, load events for resources inside the document (e.g., images) do not include the Window in the propagation path in HTML implementations. See [HTML5] for more information.
</p>



				</section>
				<section id="event-type-unload">
<h5>4.1.2.2. `unload^et</h5>

`●型^ `unload@et
`●界面^ 
<!-- copy -->
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎
UIEvent if generated from a user interface, Event otherwise.
`●同期^ あり
`●浮上^ しない
`●標的^ `Window$I, `Document$I, `Element$I
`●取消^ 不可
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
包含されている資源が除去された共通の~obj
</li></ul>
◎
• Event.target : common object whose contained resources have been removed
• UIEvent.view : Window
• UIEvent.detail : 0

`●表終^

<p>
~UAは、［
~DOM実装が，環境から資源（文書など）や 従属~資源（画像, ~stylesheet, ~scriptなど）を除去した
］とき，この~eventを発火し~MUST。
文書の~unloadは，この~event型が配送された後で~MUST。
実装が，この~event型を配送するときには、少なくとも `Document$I ~node上に配送することが要求される。
◎
A user agent MUST dispatch this event when the DOM Implementation removes from the environment the resource (such as the document) or any dependent resources (such as images, style sheets, scripts). The document MUST be unloaded after the dispatch of this event type. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.
</p>




				</section>
				<section id="event-type-abort">
<h5>4.1.2.3. `abort^et</h5>

`●型^ `abort@et
`●界面^ 
<!-- copy -->
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎
UIEvent if generated from a user interface, Event otherwise.
`●同期^ あり
`●浮上^ しない
`●標的^ `Window$I, `Element$I
`●取消^ 不可
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
資源の読込ingが~error以外により停止された要素
</li></ul>
◎
• Event.target : element whose resources have been stopped from loading without error
• UIEvent.view : Window
• UIEvent.detail : 0

`●表終^

<p>
~UAは、［
資源の読込ingがまだ進捗~中に，利用者による取消しなどで中止された
］とき，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when the loading of a resource has been aborted, such as by a user canceling the load while it is still in progress.
</p>




				</section>
				<section id="event-type-error">
<h5>4.1.2.4. `error^et</h5>

`●型^ `error@et
`●界面^ 
<!-- copy -->
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎
UIEvent if generated from a user interface, Event otherwise.
`●同期^ なし
`●浮上^ しない
`●標的^ `Window$I, `Element$I
`●取消^ 不可
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
資源の読込ingが~errorにより停止された要素
</li></ul>
◎
• Event.target : element whose resources have been stopped from loading due to error
• UIEvent.view : Window
• UIEvent.detail : 0

`●表終^

<p>
~UAは、［
資源の読込みに失敗した, または読込まれたが その意味論に従って解釈-できない（
無効な画像, ~script実行~error, 整形式でない XML 
など）
］とき，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when a resource failed to load, or has been loaded but cannot be interpreted according to its semantics, such as an invalid image, a script execution error, or non-well-formed XML.
</p>




				</section>
				<section id="event-type-select">
<h5>4.1.2.5. `select^et</h5>

`●型^ `select@et
`●界面^ 
<!-- copy -->
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎
UIEvent if generated from a user interface, Event otherwise.
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 不可
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
~text内容が選択された要素
</li></ul>
◎
• Event.target : element whose text content has been selected
• UIEvent.view : Window
• UIEvent.detail : 0

`●表終^

<p>
~UAは、［
利用者が一部の~textを選択した
］とき，この~eventを発火し~MUST。
この~eventは、選択が生じた後に配送される。
◎
A user agent MUST dispatch this event when a user selects some text. This event is dispatched after the selection has occurred.
</p>

<div class="p">
<p>
この仕様は、選択された~textへ~accessするための文脈的~情報を提供しない。
`~host言語$は、適用し得る所では，次のための規則を定義する~SHOULDである：
</p>

<ul><li>利用者が内容を選択できる方法（国際的~言語~規約も考慮して）
</li><li>`select$et ~eventがどこで発火されたか
</li><li>内容~作者がその選択された内容に~accessできる方法
</li></ul>

◎
This specification does not provide contextual information to access the selected text. Where applicable, a host language SHOULD define rules for how a user MAY select content (with consideration for international language conventions), at what point the select event is dispatched, and how a content author MAY access the user-selected content.
</div>


<p class="note">注記：
利用者により選択された内容に~accessするためには、内容~作者は，`~host言語$に備わる能力を利用することになる
— 
HTML Editing APIs `Editing$r の
`Document.getSelection()^m ~methodなど。
◎
In order to access to user-selected content, content authors will use native capabilities of the host languages, such as the Document.getSelection() method of the HTML Editing APIs [Editing].
</p>

<p class="note">注記：
`select$et ~eventは、どの言語のどの要素でも可用になるとは限らない。
例えば `HTML5$r においては、
`select$et ~eventが配送され得るのは，［
`input$e ／ `textarea$e
］要素に限られている。
実装は、［
~form~controlの外側の~text選択,
SVG 内などの 画像や~markupの選択
］なども含め，適切と判断される文脈にて `select$et ~eventを配送できる。
◎
The select event might not be available for all elements in all languages. For example, in [HTML5], select events can be dispatched only on form input and textarea elements. Implementations can dispatch select events in any context deemed appropriate, including text selections outside of form controls, or image or markup selections such as in SVG.
</p>

				</section>
			</section>
			<section id="_common-UI-event-context">
<h4>各種~UI~eventに共通する文脈~情報</h4>

集約簡略化

<p>
多くの~UI~eventに共通する文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、これらより優先される：
</p>

<dl>
	<dt>`UIEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`view$m</dt>
			<dd>
`Window$I ~obj
◎
UIEvent.view : Window
</dd>
			<dt>`detail$m</dt>
			<dd>
0
◎
UIEvent.detail : 0
</dd>
		</dl>
	</dd>
</dl>


			</section>
		</section>
		<section id="events-focusevent">
<h3 title="Focus Events">4.2. ~focus~event</h3>

<p class="note">注記：
この節の~ifc, および それに結付けられている［
~event型,
<a href="#events-focusevent-event-order">~focus~event序列</a>
］は、［
<a href="~UAAG20">User Agent Accessibility Guidelines 2.0</a>
`UAAG20$r に定義される概念と指針
］に則って，特に［
<a href="~UAAG20#gl-focus-mechanism">~focusの仕組み</a>, および
<a href="~UAAG20#def-focus">~focusの用語集</a>
に定義されている用語
］に注視して設計されている。
◎
This interface and its associated event types and §4.2.2 Focus Event Order were designed in accordance to the concepts and guidelines defined in User Agent Accessibility Guidelines 2.0 [UAAG20], with particular attention on the focus mechanism and the terms defined in the glossary entry for focus.
</p>



			<section id="interface-focusevent">
<h4 title="Interface FocusEvent">4.2.1. ~ifc `FocusEvent^I</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`FocusEvent^I ~ifcは、~focus~event特有の文脈的~情報を提供する。
◎
The FocusEvent interface provides specific contextual information associated with Focus events.
</p>

<p>
`FocusEvent^I ~ifcの~instanceを作成するためには、その構築子に
`FocusEventInit^I 辞書（省略可）を渡して呼び出す。
◎
To create an instance of the FocusEvent interface, use the FocusEvent constructor, passing an optional FocusEventInit dictionary.
</p>

				<section id="idl-focusevent">
<h5>4.2.1.1. `FocusEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `FocusEventInit$I %eventInitDict)]
interface `FocusEvent@I : `UIEvent$I {
    ~RA `EventTarget$I? `relatedTarget$m;
};
</pre>



<dl class="idl-def">
	<dt>`relatedTarget@m</dt>
	<dd>
~focus~eventに関係する，副 `EventTarget$I を識別するために利用される。
~eventの型に依存する。
◎
Used to identify a secondary EventTarget related to a Focus event, depending on the type of event.
</dd>
	<dd>
保安上の理由から、入子の関係にある閲覧文脈の間で~focusが切り替わったときには，この属性の値は、~NULL にされる~SHOULDである。
<!--
tabbing into or out 
関連の EventTarget
-->
◎
For security reasons with nested browsing contexts, when tabbing into or out of a nested context, the relevant EventTarget SHOULD be null.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>
</dl>

				</section>
				<section id="idl-focuseventinit">
<h5>4.2.1.2. `FocusEventInit^I</h5>

<pre class="idl">
dictionary `FocusEventInit@I : `UIEventInit$I {
    `EventTarget$I? `relatedTarget@m = null;
};
</pre>

<p>
この辞書の各~memberは、
`FocusEventInit!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、その~ifc定義の記述を見よ。
◎
FocusEventInit . relatedTarget
◎
The relatedTarget should be initialized to the element losing focus (in the case of a focus or focusin event) or the element gaining focus (in the case of a blur or focusout event).
</p>

				</section>
			</section>
			<section id="events-focusevent-event-order">
<h4 title="Focus Event Order">4.2.2. ~focus~event序列</h4>
<p>
この仕様にて定義される~focus~eventは、相互相対順序の下で生じる。
被focus要素が無い状態から要素 %A, 要素 %B の順に~focusが移転したときの代表的な~event連列を次に示す:
◎
The focus events defined in this specification occur in a set order relative to one another. The following is the typical sequence of events when a focus is shifted between elements (this order assumes that no element is initially focused):
</p>

<table class="event-sequence-table">
<thead><tr><th>~event型
<th>備考
</thead>

<tbody><tr><td>
<td>
<td><em>
利用者が~focusを移転させた
</em>
◎
User shifts focus

<tr><td>1.
<td>`focusin$et
<td>
%A が~focusを受取る直前に送信される
◎
Sent before first target element receives focus
<tr><td>2.
<td>`focus$et
<td>
%A が~focusを受取った直後に送信される
◎
Sent after first target element receives focus
<tr><td>
<td>
<td><em>
利用者が~focusを移転させた
</em>
◎
User shifts focus

<tr><td>3.
<td>`focusout$et
<td>
%A が~focusを失う直前に送信される
◎
Sent before first target element loses focus
<tr><td>4.
<td>`focusin$et
<td>
%B が~focusを受取る直前に送信される
◎
Sent before second target element receives focus
<tr><td>5.
<td>`blur$et
<td>
%A が~focusを失った直後に送信される
◎
Sent after first target element loses focus
<tr><td>6.
<td>`focus$et
<td>
%B が~focusを受取った直後に送信される
◎
Sent after second target element receives focus
</tbody></table>

<p class="note">注記：
この仕様は、対話-時における
`focus()^m ／ `blur()^m
などの~methodによる
~focus~eventの挙動は定義しない。
そのような挙動については、それらの~methodを定義している，関連の仕様を見よ。
◎
This specification does not define the behavior of focus events when interacting with methods such as focus() or blur(). See the relevant specifications where those methods are defined for such behavior.
</p>
			</section>
			<section id="events-focusevent-doc-focus">
<h4 title="Document Focus and Focus Context">4.2.3. 文書~focusと~focus文脈</h4>

<p>
この~event~moduleは、文書`~focus$の変化を通知するための~event型を含む。
この論点に関連する，3 種の別個の~focus文脈がある：
◎
This event module includes event types for notification of changes in document focus. There are three distinct focus contexts that are relevant to this discussion:
</p>

<dl>
	<dt>~OS~focus文脈</dt>
	<dd>
この文脈の下では、~computer上で現在~稼働中の多数の~appのうちの一つが，~focusを持ち得るとされる。
~browserは、その一つになり得る。
◎
The operating system focus context which MAY be on one of many different applications currently running on the computer. One of these applications with focus can be a browser.
</dd>

	<dt>~app~focus文脈</dt>
	<dd>
~browserが~focusを得ているときが、この文脈である。
この文脈の下では、利用者は、~browserの各種~UI~field（例：
所在bar, 検索~field, 等々
）間で~focusを切替し得る（~tab~keyなどにより）。
~tab内に示されている文書も、これらの~UI~fieldのうちの一つになり得る。
◎
When the browser has focus, the user can switch (such as with the tab key) the application focus context among the different browser user interface fields (e.g., the Web site location bar, a search field, etc.). One of these user interface fields can be the document being shown in a tab.
</dd>

	<dt>文書~focus文脈</dt>
	<dd>
文書~自身が~focusを得ているときが、この文脈である。
この文脈の下では、文書~内で可focusな要素が~focusを得ることができる。
◎
When the document itself has focus, the document focus context can be set to any of the focusable elements in the document.
</dd>

</dl>

<p>
この仕様にて定義される各種~event型は、もっぱら文書~focusのみを対象にする。
~eventの詳細にて識別される`標的$は、~window内の文書またその一部に限られ~MUST
— ~focus文脈が別の文脈へ切替わったときでも，決して ~browserや~OSの一部にはならない。
◎
The event types defined in this specification deal exclusively with document focus, and the event target identified in the event details MUST only be part of the document or documents in the window, never a part of the browser or operating system, even when switching from one focus context to another.
</p>

<div class="p">
<p>
通常、文書は常に被focus要素を持ち（他に無ければ，`文書~要素$が被focus要素になる）、また，`~focus環$を持ち続ける。
~focus文脈が切替わっても，文書における現在の被focus要素, および文書の`~focus環$は、通常は現在の状態を保ち続ける。
例えば，文書にて可focusな要素が 3 個あって， 2 個目の要素が~focusされている下で、利用者が~OS~focusを別の~appに変更してから また~browserに戻ったとき、 2 個目の要素は，文書の中で依然として被focusのままにされ，~tabbingなどで~focusが切り替えられたときは、 3 個目の要素に~focusが移ることになる。
</p>

<p>
`~host言語$は、次を定義して~MAY：
</p>

<ul><li>どの要素が~focusを受取れるか
</li><li>要素はどの条件の下で~focusを受取るか
</li><li>~focusはどの手段で変更できるか
</li><li>~focusはどの順序で変化するか
</li></ul>

<p >
例えば，要素に~pointerが接触するだけで，要素が~focusを得ることもあれば、~mouse~clickを要する状況もある。
要素には、全く~focusされ得ないないものもあれば、特別な手段（要素~上を~clickするなど）を通してなら~focusできるが，~tabbingでは~focusできないものもある。
文書は、複数の`~focus環$を包含して~MAY。
</p>

<p>
他の仕様は、この仕様にて述べるものより複雑な~focus~modelを定義して~MAY
— 複数の要素が，現在の~focusを得られるようにすることも含め。
</p>

◎
Normally, a document always has a focused element (even if it is the document element itself) and a persistent focus ring. When switching between focus contexts, the document’s currently focused element and focus ring normally remain in their current state. For example, if a document has three focusable elements, with the second element focused, when a user changes operating system focus to another application and then back to the browser, the second element will still be focused within the document, and tabbing will change the focus to the third element. A host language MAY define specific elements which might receive focus, the conditions under which an element MAY receive focus, the means by which focus MAY be changed, and the order in which the focus changes. For example, in some cases an element might be given focus by moving a pointer over it, while other circumstances might require a mouse click. Some elements might not be focusable at all, and some might be focusable only by special means (clicking on the element), but not by tabbing to it. Documents MAY contain multiple focus rings. Other specifications MAY define a more complex focus model than is described in this specification, including allowing multiple elements to have the current focus.
</div>

			</section>
			<section id="events-focus-types">
<h4>4.2.4. 各種~focus~event型</h4>

<p>
以下に，各種~focus~event型を挙げる：
◎
The Focus event types are listed below.
</p>


				<section id="event-type-blur">
<h5>4.2.4.1. `blur^et</h5>

`●型^ `blur@et
`●界面^ `FocusEvent$I
`●同期^ あり
`●浮上^ しない
`●標的^ `Window$I, `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
~focusを失った`~event標的$
</li><li>`FocusEvent.relatedTarget$m：
新たに~focusを受取った`~event標的$。
</li></ul>
◎
• Event.target : event target losing focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target receiving focus.

`●表終^

<p>
~UAは、要素が~focusを失った直後に，その要素を標的に，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when an event target loses focus. The focus MUST be taken from the element before the dispatch of this event type. This event type is similar to focusout, but is dispatched after focus is shifted, and does not bubble.
</p>




				</section>
				<section id="event-type-focus">
<h5>4.2.4.2. `focus^et</h5>

`●型^ `focus@et
`●界面^ `FocusEvent$I
`●同期^ あり
`●浮上^ しない
`●標的^ `Window$I, `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
新たに~focusを受取った`~event標的$
</li><li>`FocusEvent.relatedTarget$m：
~focusを失った`~event標的$（もしあれば）。
</li></ul>
◎
• Event.target : event target receiving focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target losing focus (if any).

`●表終^

<p>
~UAは、要素が~focusを受取った直後に，その要素を標的に，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when an event target receives focus. The focus MUST be given to the element before the dispatch of this event type. This event type is similar to focusin, but is dispatched after focus is shifted, and does not bubble.
</p>




				</section>
				<section id="event-type-focusin">
<h5>4.2.4.3. `focusin^et</h5>

`●型^ `focusin@et
`●界面^ `FocusEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Window$I, `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
新たに~focusを受取ることになる`~event標的$
</li><li>`FocusEvent.relatedTarget$m：
~focusを失うことになる`~event標的$（もしあれば）。
</li></ul>

◎
• Event.target : event target receiving focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target losing focus (if any).

`●表終^

<p>
~UAは、要素が~focusを受取る直前に，その要素を標的に，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when an event target is about to receive focus. This event type MUST be dispatched before the element is given focus. The event target MUST be the element which is about to receive focus. This event type is similar to focus, but is dispatched before focus is shifted, and does bubble.
</p>

<p class="note" id="_9">注記：
この~event型を利用すれば、内容~作者は，~focusが次の~focus`~event標的$へ移転する前に
~eventの `FocusEvent.relatedTarget$m 属性（または~host言語~特有の~methodや手段）を利用して，現在の被focus要素を得ることができる。
◎
When using this event type, the content author can use the event’s relatedTarget attribute (or a host-language-specific method or means) to get the currently focused element before the focus shifts to the next focus event target, thus having access to both the element losing focus and the element gaining focus without the use of the blur or focusout event types.
</p>




				</section>
				<section id="event-type-focusout">
<h5>4.2.4.4. `focusout^et</h5>

`●型^ `focusout@et
`●界面^ `FocusEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Window$I, `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~UI~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
~focusを失うことになる`~event標的$
</li><li>`FocusEvent.relatedTarget$m：
新たに~focusを受取ることになる`~event標的$。
</li></ul>

◎
• Event.target : event target losing focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target receiving focus.

`●表終^

<p>
~UAは、要素が~focusを失う直前に，その要素を標的に，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when an event target is about to lose focus. This event type MUST be dispatched before the element loses focus. The event target MUST be the element which is about to lose focus. This event type is similar to blur, but is dispatched before focus is shifted, and does bubble.
</p>

				</section>
			</section>
		</section>
		<section id="events-mouseevents">
<h3 title="Mouse Events">4.3. ~mouse~event</h3>

<p>
~mouse~event~moduleは
`HTML40$r の［
`onclick^c,
`ondblclick^c,
`onmousedown^c,
`onmouseup^c,
`onmouseover^c,
`onmousemove^c,
`onmouseout^c
］属性に由来する。
この~event~moduleは、特に，~pointing入力~装置（~mouseや~trackballなど）による利用のために設計されている。
◎
The mouse event module originates from the [HTML40] onclick, ondblclick, onmousedown, onmouseup, onmouseover, onmousemove, and onmouseout attributes. This event module is specifically designed for use with pointing input devices, such as a mouse or a trackball.
</p>

			<section id="interface-mouseevent">
<h4 title="Interface MouseEvent">4.3.1. ~ifc `MouseEvent^I</h4>

<p class="intro-dom">
~DOM2にて導入され、この仕様にて改変された。
◎
Introduced in DOM Level 2, modified in this specification
</p>

<p>
`MouseEvent^I ~ifcは、`~mouse~event$特有の文脈的~情報を提供する。
◎
The MouseEvent interface provides specific contextual information associated with Mouse events.
</p>

<p>
入子にされている要素に対しては、~mouse~eventは，
<!-- 常に -->
通例的には，最も深い入子の要素を標的にすることになる。

◎
In the case of nested elements, mouse events are always targeted at the most deeply nested element.
</p>

<p class="note">注記：
標的にされた要素の先祖は、~event浮上を利用して，子孫~要素の中で生じた~mouse~eventの通知を得ることができる。
◎
Ancestors of the targeted element can use event bubbling to obtain notifications of mouse events which occur within their descendent elements.
</p>

<p>
`MouseEvent^I ~ifcの~instanceを作成するためには、その構築子に
`MouseEventInit^I 辞書（省略可）を渡して呼び出す。
◎
To create an instance of the MouseEvent interface, use the MouseEvent constructor, passing an optional MouseEventInit dictionary.
</p>

<p class="note">注記：
実装は、~client座標
`clientX^c, `clientY^c
を利用して，［
`initMouseEvent()$m を利用して `MouseEvent^I ~objを初期化する際
］の他の座標（ `~DOM0$実装や他の~proprietary属性により公開される標的の座標
— 例えば `pageX^c など）を計算できる。
◎
When initializing MouseEvent objects using initMouseEvent, implementations can use the client coordinates clientX and clientY for calculation of other coordinates (such as target coordinates exposed by DOM Level 0 implementations or other proprietary attributes, e.g., pageX).
</p>

				<section id="idl-mouseevent">
<h5>4.3.1.1. `MouseEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `MouseEventInit$I %eventInitDict)]
interface `MouseEvent@I : `UIEvent$I {
    ~RA long           `screenX$m;
    ~RA long           `screenY$m;
    ~RA long           `clientX$m;
    ~RA long           `clientY$m;

    ~RA boolean        `ctrlKey$m;
    ~RA boolean        `shiftKey$m;
    ~RA boolean        `altKey$m;
    ~RA boolean        `metaKey$m;

    ~RA short          `button$m;
    ~RA unsigned short `buttons$m;

    ~RA `EventTarget$I?   `relatedTarget$m;

    boolean `getModifierState$m(~DS %keyArg);
};
</pre>

<dl class="idl-def">

	<dt>`screenX@m</dt>
	<dt>`screenY@m</dt>
	<dd>
順に、［
~screen座標系の原点
］に相対的な，~eventが生じた~~地点の［
横方向, 縦方向
］座標。
◎
screenX, of type long, readonly
◎
The horizontal coordinate at which the event occurred relative to the origin of the screen coordinate system.
◎
The un-initialized value of this attribute MUST be 0.
◎
screenY, of type long, readonly
◎
The vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.
◎
The un-initialized value of this attribute MUST be 0.
</dd>
	<dd>
`未初期化~値$： 0
◎
↑</dd>

	<dt>`clientX@m</dt>
	<dt>`clientY@m</dt>
	<dd>
順に、［
~eventに結付けられている表示域
］に相対的な，~eventが生じた~~地点の［
横方向, 縦方向
］座標。
◎
clientX, of type long, readonly
◎
The horizontal coordinate at which the event occurred relative to the viewport associated with the event.
◎
The un-initialized value of this attribute MUST be 0.
◎
clientY, of type long, readonly
◎
The vertical coordinate at which the event occurred relative to the viewport associated with the event.
◎
The un-initialized value of this attribute MUST be 0.
</dd>
	<dd>
`未初期化~値$： 0
◎
↑</dd>

	<dt>`ctrlKey@m</dt>
	<dt>`shiftKey@m</dt>
	<dt>`altKey@m</dt>
	<dt>`metaKey@m</dt>
	<dd>
これらについては、 `KeyboardEvent$I の同じ名前の属性を参照のこと。
◎
ctrlKey, of type boolean, readonly
◎
Refer to the KeyboardEvent's ctrlKey attribute.
◎
The un-initialized value of this attribute MUST be false.
◎
shiftKey, of type boolean, readonly
◎
Refer to the KeyboardEvent's shiftKey attribute.
◎
The un-initialized value of this attribute MUST be false.
◎
altKey, of type boolean, readonly
◎
Refer to the KeyboardEvent's altKey attribute.
◎
The un-initialized value of this attribute MUST be false.
◎
metaKey, of type boolean, readonly
◎
Refer to the KeyboardEvent's metaKey attribute.
◎
The un-initialized value of this attribute MUST be false.
</dd>
	<dd>
`未初期化~値$： ~F
◎
↑</dd>

	<dt>`button@m</dt>
	<dd>
~mouse~buttonの状態変化による~mouse~eventに対しては、この属性を利用して，その状態を変化させた~pointing装置の~buttonを指示し~MUST。
◎
button, of type short, readonly
◎
During mouse events caused by the depression or release of a mouse button, button MUST be used to indicate which pointer device button changed state.
</dd>
	<dd>
<p>
この属性に対する値［
0 ／ 1 ／ 2
］は、次を指示し~MUST：
◎
The value of the button attribute MUST be as follows:
</p>

		<ul>
			<li>
0 は、装置の首~button（一般に、~UI~controlや選択~textを作動化するために利用されるような，左~button, または 単~button装置~上の唯一の~button）, または
`未初期化~値$。
◎
0 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text) or the un-initialized value.
</li>
			<li>
1 は、予備~button（一般に，中央~button — ~mouse~wheelと組み合わされることが多い）。
◎
1 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).
</li>
			<li>
2 は、副~button（一般に，右~button — 文脈~menuを表示するために利用されることが多い）。
◎
2 MUST indicate the secondary button (in general, the right button, often used to display a context menu).
</li>
		</ul>
	</dd>
	<dd>
~pointing装置には、もっと他の~button状態を提供する／模造するものもある
— そのような~buttonを表現するために
0, 1, 2 以外の値が利用されることもある。
◎
Some pointing devices provide or simulate more button states, and values higher than 2 or lower than 0 MAY be used to represent such buttons.
</dd>
	<dd class="note">注記：
`button$m の値は、~mouse~buttonの状態変化によるものでない~eventに対しては，更新されない。
そのような局面における値 0 は、左~buttonではなく，`未初期化~値$として解釈すること。
◎
The value of button is not updated for events not caused by the depression/release of a mouse button. In these scenarios, take care not to interpret the value 0 as the left button, but rather as the un-initialized value.
</dd>
	<dd class="note">注記：
`mousedown$et や `mouseup$et などの~eventに関係する`既定~動作$には、利用中の特定の~mouse~buttonに依存するものもある。
◎
Some default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`buttons@m</dt>
	<dd>
~mouse~buttonが現在どの組合せで押されているかを指示する~bitmask。
どの~mouse~eventにおいても、それを指示するときには，この属性が利用され~MUST。
◎
buttons, of type unsigned short, readonly
◎
During any mouse events, buttons MUST be used to indicate which combination of mouse buttons are currently being pressed, expressed as a bitmask.
</dd>
	<dd class="note">注記：
似た名前の `button$m 属性がとる値とは，全く異なる。
`button^m の値を妥当と見做せるのは，
`mousedown$et ／ `mouseup$et
`~event~handler$の中に限られる一方、
`buttons^m 属性は，どの`~trusted$ `MouseEvent^I ~objに対しても（それが配送されている間）~mouseの各~buttonの状態を反映する
— それは、 “現在どの~buttonも作動中でない” 状態（ 0 ）も表現できるので。
◎
Though similarly named, the values for the buttons attribute and the button attribute are very different. The value of button is assumed to be valid during mousedown / mouseup event handlers, whereas the buttons attribute reflects the state of the mouse’s buttons for any trusted MouseEvent object (while it is being dispatched), because it can represent the "no button currently active" state (0).
</dd>
	<dd>
<p>
`MouseEvent.buttons$m 属性の~bitmask値［
0 ／ 1 ／ 2  ／ 4 
］は、次を指示し~MUST：
◎
The value of the buttons attribute MUST be as follows:
</p>

		<ul>
			<li>
0 は、どの~buttonも現在~作動中でないこと。
◎
0 MUST indicate no button is currently active.
</li>
			<li>
1 は、装置の首~button（一般に、~UI~controlや選択~textを作動化するために利用されるような，左~button, または 単~button装置~上の唯一の~button）。
◎
1 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text).
</li>
			<li>
2 は、副~button（一般に，右~button
— 文脈~menuを表示するために利用されることが多い）。
◎
2 MUST indicate the secondary button (in general, the right button, often used to display a context menu), if present.
</li>
			<li>
4 は、予備~button（一般に，中央~button
— ~mouse~wheelと組み合わされることが多い）。
◎
4 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).
</li>
		</ul>

	</dd>
	<dd>
~pointing装置には、上述以外の~buttonを提供する／模造するものもある
— そのような~buttonを表現する値は，各~buttonごとに倍々にされ~MUST（ 8, 16, 32, ... ）。
◎
Some pointing devices provide or simulate more buttons. To represent such buttons, the value MUST be doubled for each successive button (in the binary series 8, 16, 32, ... ).
</dd>
	<dd class="note" id="buttons-mask">注記：
~buttonたち全体が成すどの状態も、各~button値の総和で一意に表現されるので、内容~作者は，装置~上の~mouse~buttonがいくつあっても，~bitwise演算を利用して，現在どの~buttonが押されているかを決定できる。
例えば、値 3 は，左＆右~buttonが押された（押されている）ことを指示し、値 5 は，左＆中央~buttonが押されたことを指示する。
◎
Because the sum of any set of button values is a unique number, a content author can use a bitwise operation to determine how many buttons are currently being pressed and which buttons they are, for an arbitrary number of mouse buttons on a device. For example, the value 3 indicates that the left and right button are currently both pressed, while the value 5 indicates that the left and middle button are currently both pressed.
</dd>
	<dd class="note">注記：
<!-- copy -->
`mousedown$et や `mouseup$et などの，一部の~eventに関係する`既定~動作$には、どの~mouse~buttonが利用中にあるかに依存するものもある。
◎
Some default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`relatedTarget@m</dt>
	<dd>
~eventの型に依存して、
~UI~eventに関係する副 `EventTarget$I を識別するために利用される。
◎
relatedTarget, of type EventTarget, readonly, nullable
◎
Used to identify a secondary EventTarget related to a UI event, depending on the type of event.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>`getModifierState(keyArg)@m</dt>
	<dd>
<em>この仕様にて導入された。</em>
◎
Introduced in this specification
</dd>
	<dd>
`KeyboardEvent.getModifierState()$m
~methodを見よ。
◎
Queries the state of a modifier using a key value. See §5.3.1 Modifier keys for a list of valid (case-sensitive) arguments to this method.
◎
Returns true if it is a modifier key and the modifier is activated, false otherwise.
◎
DOMString keyArg 
◎
Refer to the KeyboardEvent's getModifierState() method for a description of this parameter.
</dd>
</dl>

				</section>
				<section id="idl-mouseeventinit">
<h5>4.3.1.2. `MouseEventInit^I</h5>

<pre class="idl">
dictionary `MouseEventInit@I : `EventModifierInit$I {
    long           `screenX@m = 0;
    long           `screenY@m = 0;
    long           `clientX@m = 0;
    long           `clientY@m = 0;

    short          `button@m = 0;
    unsigned short `buttons@m = 0;
    `EventTarget$I?   `relatedTarget@m = null;
};
</pre>

<!-- 5.3.1.3 Dictionary MouseEventInit Members -->

<p>
この辞書の各~memberは、
`MouseEvent!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、その~ifc定義の記述を見よ。
◎
screenX, of type long, defaulting to 0
• Initializes the screenX attribute of the MouseEvent object to the desired horizontal relative position of the mouse pointer on the user’s screen.
• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
screenY, of type long, defaulting to 0
• Initializes the screenY attribute of the MouseEvent object to the desired vertical relative position of the mouse pointer on the user’s screen.

• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
clientX, of type long, defaulting to 0
• Initializes the clientX attribute of the MouseEvent object to the desired horizontal position of the mouse pointer relative to the client window of the user’s browser.
• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
clientY, of type long, defaulting to 0
• Initializes the clientY attribute of the MouseEvent object to the desired vertical position of the mouse pointer relative to the client window of the user’s browser.
• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
button, of type short, defaulting to 0
• Initializes the button attribute of the MouseEvent object to a number representing the desired state of the button(s) of the mouse.
• The value 0 is used to represent the primary mouse button, 1 is used to represent the auxiliary/middle mouse button, and 2 to represent the right mouse button. Numbers greater than 2 are also possible, but are not specified in this document.
◎
buttons, of type unsigned short, defaulting to 0
• Initializes the buttons attribute of the MouseEvent object to a number representing one or more of the button(s) of the mouse that are to be considered active.
• The buttons attribute is a bit-field. If a mask value of 1 is true when applied to the value of the bit field, then the primary mouse button is down. If a mask value of 2 is true when applied to the value of the bit field, then the right mouse button is down. If a mask value of 4 is true when applied to the value of the bit field, then the auxiliary/middle button is down.
• In JavaScript, to initialize the buttons attribute as if the right (2) and middle button (4) were being pressed simultaneously, the buttons value can be assigned as either:
    { buttons: 2 | 4 }
    or:
    { buttons: 6 }
◎
relatedTarget, of type EventTarget, nullable, defaulting to null
• The relatedTarget should be initialized to the element whose bounds the mouse pointer just left (in the case of a mouseover or mouseenter event) or the element whose bounds the mouse pointer is entering (in the case of a mouseout or mouseleave or focusout event). For other events, this value need not be assigned (and will default to null).
</p>

<p>
`MouseEvent$I ~objが指示する~mouse位置がどう初期化されようが，利用者の~mouse~pointerがその位置に動かされては~MUST_NOT。
◎
↑</p>

<p>
実装は、~mouse~eventを生成するときには，
`現在の~click回数@
を維持管理し~MUST。
これは、【同じ】~pointing装置の~buttonが，特定の時間~内に連続して~clickされた数を指示する非~負の整数で~MUST。
どの程度の遅延で回数が~resetされるかは、環境設定0 特有になる。
◎
Implementations MUST maintain the current click count when generating mouse events. This MUST be a non-negative integer indicating the number of consecutive clicks of a pointing device button within a specific time. The delay after which the count resets is specific to the environment configuration.
</p>

<p class="trans-note">【
回数が増加される~~正確な時機がいつなのか記されていないが、 `click$et ~eventが配送される直前と見られる。
】【
複数の~pointing装置があるときは、装置ごとに~click回数を維持管理する？
それとも，~clickした装置が切り替わったら，~click回数は~resetされる？
】</p>

				</section>
			</section>
			<section id="event-modifier-initializers">
<h4 title="Event Modifier Initializers">4.3.2. ~eventの~key修飾 初期化子</h4>

<p>
`MouseEvent$I ／ `KeyboardEvent$I
~ifcは、各種~keyboard修飾~属性を共有し，追加の修飾~状態を取得0するための仕組みを~supportする。
次の辞書により、作者は，これらの~ifcの［
各種~keyboard修飾~属性, および［
`MouseEvent.getModifierState()$m ／ `KeyboardEvent.getModifierState()$m
］を介して照会される追加の修飾~状態
］を初期化できるようになる。
この辞書を利用して~eventを構築する手続きは、
<a href="#event-constructors">~event構築子 節</a>
にて定義される。
◎
The MouseEvent and KeyboardEvent interfaces share a set of keyboard modifier attributes and support a mechanism for retrieving additional modifier states. The following dictionary enables authors to initialize keyboard modifier attributes of the MouseEvent and KeyboardEvent interfaces, as well as the additional modifier states queried via getModifierState(). The steps for constructing events using this dictionary are defined in the event constructors section.
</p>

<pre class="idl">
dictionary `EventModifierInit@I : `UIEventInit$I {
    boolean `ctrlKey$m = false;
    boolean `shiftKey$m = false;
    boolean `altKey$m = false;
    boolean `metaKey$m = false;

    boolean `modifierAltGraph$m = false;
    boolean `modifierCapsLock$m = false;
    boolean `modifierFn$m = false;
    boolean `modifierFnLock$m = false;
    boolean `modifierHyper$m = false;
    boolean `modifierNumLock$m = false;
    boolean `modifierScrollLock$m = false;
    boolean `modifierSuper$m = false;
    boolean `modifierSymbol$m = false;
    boolean `modifierSymbolLock$m = false;
};
</pre>


<p>
以下において、 %~event は，
`MouseEvent$I ／ `KeyboardEvent$I
いずれかを実装する~event~obj、
`getModifierState()^m は， %~event 上の同じ名前の~method（
`MouseEvent.getModifierState()$m ／ `KeyboardEvent.getModifierState()$m
）を表すとする。
</p>

<dl class="idl-def">
	<dt>`ctrlKey@m</dt>
	<dt>`shiftKey@m</dt>
	<dt>`altKey@m</dt>
	<dt>`metaKey@m</dt>
	<dd>
<p>
これらの各~memberは、 %~event 上の同じ名前の属性を初期化する。
値の意味は、 `KeyboardEvent$I の同じ名前の属性の記述を見よ。
</p>

<p>
加えて，実装は、 %~event の`~key修飾~状態$を，［
下の表の 2 列目の値を引数に %~event 上の `getModifierState()^m が呼出されたときは，その行の 1 列目の名前の~member値が返される
］ように初期化し~MUST。
</p>

<table>
<thead><tr><th>名前
<th>引数
</thead>

<tbody><tr><td>`altKey^c
<td>`Alt^l<!-- ^cap -->

<tr><td>`ctrlKey^c
<td>`Control^l

<tr><td>`altKey^c
<td>`Meta^l

<tr><td>`shiftKey^c
<td>`Shift^l

</tbody></table>


◎
ctrlKey, of type boolean, defaulting to false
• Initializes the ctrlKey attribute of the MouseEvent or KeyboardEvent objects to true if the Control key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Control must return true.
◎
shiftKey, of type boolean, defaulting to false
• Initializes the shiftKey attribute of the MouseEvent or KeyboardEvent objects to true if the Shift key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Shift must return true.
◎
altKey, of type boolean, defaulting to false
• Initializes the altKey attribute of the MouseEvent or KeyboardEvent objects to true if the Alt (alternative) (or Option) key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Alt must return true.
◎
metaKey, of type boolean, defaulting to false
• Initializes the metaKey attribute of the MouseEvent or KeyboardEvent objects to true if the Meta key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with either the parameter Meta must return true.
</dd>

	<dt>`modifierAltGraph@m</dt>
	<dt>`modifierCapsLock@m</dt>
	<dt>`modifierFn@m</dt>
	<dt>`modifierFnLock@m</dt>
	<dt>`modifierHyper@m</dt>
	<dt>`modifierNumLock@m</dt>
	<dt>`modifierScrollLock@m</dt>
	<dt>`modifierSuper@m</dt>
	<dt>`modifierSymbol@m</dt>
	<dt>`modifierSymbolLock@m</dt>
	<dd>
これらの~memberは、 %~event の`~key修飾~状態$を，［
対応する`~key修飾~名$
— すなわち、~member名を `modifier<var>XXX</var>^c とするときの，文字列 %XXX —
を引数に %~event 上の `getModifierState()^m が呼出されたときは，その~member値が返される
］ように，初期化する。

◎
modifierAltGraph, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter AltGraph must return true.
◎
modifierCapsLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter CapsLock must return true.
◎
modifierFn, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Fn must return true.
◎
modifierFnLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter FnLock must return true.
◎
modifierHyper, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Hyper must return true.
◎
modifierNumLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter NumLock must return true.
◎
modifierScrollLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter ScrollLock must return true.
◎
modifierSuper, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Super must return true.
◎
modifierSymbol, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Symbol must return true.
◎
modifierSymbolLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter SymbolLock must return true.
</dd>
</dl> 


			</section>
			<section id="events-mouseevent-event-order">
<h4 title="Mouse Event Order">4.3.3. ~mouse~event序列</h4>

<p>
この仕様にて定義される一定の~mouse~eventは、相互相対順序の下で生じ~MUST。
`~pointing先$が，ある要素 %A に変化したときは、次の~event連列が生じ~MUST：
◎
Certain mouse events defined in this specification MUST occur in a set order relative to one another. The following shows the event sequence that MUST occur when a pointing device’s cursor is moved over an element:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>要素
<th>備考
</thead>

<tbody><tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A に変化した…
</em>
◎
Pointing device is moved into element A...

<tr><td>2.
<td>`mouseover$et
<td>%A
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る◎Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A でなくなった…
</em>
◎
Pointing device is moved out of element A...

<tr><td>5.
<td>`mouseout$et
<td>%A
<td>

<tr><td>6.
<td>`mouseleave$et
<td>%A
<td>
</tbody></table>

<p>
`~pointing先$が要素 %A に変化して，その入子の要素 %B に変化して
また %A に戻ったときは、次の~event連列が生じ~MUST：
◎
When a pointing device is moved into an element A, and then into a nested element B and then back out again, the following sequence of events MUST occur:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>要素
<th>備考
</thead>

<tbody><tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A に変化した…
</em>
◎
Pointing device is moved into element A...

<tr><td>2.
<td>`mouseover$et
<td>%A
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る◎Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %B に変化した…
</em>
◎
Pointing device is moved into nested element B...

<tr><td>5.
<td>`mouseout$et
<td>%A
<td>

<tr><td>6.
<td>`mouseover$et
<td>%B
<td>

<tr><td>7.
<td>`mouseenter$et
<td>%B
<td>

<tr><td>8.
<td>`mousemove$et
<td>%B
<td>複数回 生じ得る◎Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %B から %A に変化した…
</em>
◎
Pointing device is moved from element B into A...

<tr><td>9.
<td>`mouseout$et
<td>%B
<td>

<tr><td>10.
<td>`mouseleave$et
<td>%B
<td>

<tr><td>11.
<td>`mouseover$et
<td>%A
<td>

<tr><td>12.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る◎Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A でなくなった…
</em>
◎
Pointing device is moved out of element A...

<tr><td>13.
<td>`mouseout$et
<td>%A
<td>

<tr><td>14.
<td>`mouseleave$et
<td>%A
<td>
</tbody></table>

<p>
CSS の利用により，いくつかの要素が視覚的に重なり合うこともある。
次の例では、
3 個の要素［
%A, %B, %C
］は，いずれも ~web頁~上で 同じ［
寸法, 絶対~位置
］にされていて、~DOM内では，
%C は %B の子,
%B は %A の子
であるとする：
◎
Sometimes elements can be visually overlapped using CSS. In the following example, three elements labeled A, B, and C all have the same dimensions and absolute position on a web page. Element C is a child of B, and B is a child of A in the DOM:
</p>

<figure id="figure-mouse-event-stacked-elements">`stacked-event-mouse-dispatch^dgm
<figcaption>
同じ所に積層された 3 個の要素の~graphical表現
— ~pointing装置は、最も手前の要素（ %C ）上に動いている。
◎
Graphical representation of three stacked elements all on top of each other, with the pointing device moving over the stack.
</figcaption></figure>

<p>
~pointing装置が、積層された要素の外側から要素 %C 内に動いて，また外へ出たときは、次の~event連列が生じ~MUST：
◎
When the pointing device is moved from outside the element stack to the element labeled C and then moved out again, the following series of events MUST occur:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>要素
<th>備考
</thead>

<tbody><tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は［
積層-内の最上層の要素である要素 %C
］に変化した…
</em>
◎
Pointing device is moved into element C, the topmost element in the stack

<tr><td>2.
<td>`mouseover$et
<td>%C
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mouseenter$et
<td>%B
<td>

<tr><td>5.
<td>`mouseenter$et
<td>%C
<td>

<tr><td>6.
<td>`mousemove$et
<td>%C
<td>複数回 生じ得る◎Multiple mousemove events
<tr><td>
<td>
<td>
<td><em>
`~pointing先$は 要素 %C でなくなった…
</em>
◎
Pointing device is moved out of element C...

<tr><td>7.
<td>`mouseout$et
<td>%C
<td>

<tr><td>8.
<td>`mouseleave$et
<td>%C
<td>

<tr><td>9.
<td>`mouseleave$et
<td>%B
<td>

<tr><td>10.
<td>`mouseleave$et
<td>%A
<td>
</tbody></table>

<p class="note">注記：
`mouseover$et ／ `mouseout$et
~eventが発火されるのは， 1 度だけである一方、
`mouseenter$et ／ `mouseleave$et
~eventは，（各~要素ごとに 1 度ずつ）計 3 度~発火される。
◎
The mouseover/mouseout events are only fired once, while mouseenter/mouseleave events are fired three times (once to each element).
</p>

<p class="trans-note">【
概念的には、一連の［
`mouseenter$et ／  `mouseleave$et
］~eventは，~pointerが［
先祖から子孫に向かって ／ 子孫から先祖に向かって
］（微小な間をおいて）要素の境界を順々にまたいでいったと解釈した下で生じるもの，と捉えられる
— ただし、この解釈は，
`MouseEvent.relatedTarget$m
に関して~~正確でないが（この解釈の下では、最初の要素を除く各~子孫に配送される `mouseenter$et ~eventの `relatedTarget^m は，その親を指すことになる）。
これらは、~eventの伝播ではないので、例えば，［
要素 %A に登録されている `mouseenter$et に対する~event~handler
］が，［
%B ／ %C を，その表示位置はそのままに，~DOM内での位置を変えた場合
］の挙動は，明示的に規定されていない（この節の最後の記述も~~参照）。
】</p>


<p>
~pointing装置に結付けられている~button（例：~mouse~buttonや~trackpad）が，要素~上で押されてから, 離されたときの，代表的な~event連列：
◎
The following is the typical sequence of events when a button associated with a pointing device (e.g., a mouse button or trackpad) is pressed and released over an element:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`mousedown$et
<td>

<tr><td>2.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）
◎
OPTIONAL, multiple events, some limits

<tr><td>3.
<td>`mouseup$et
<td>

<tr><td>4.
<td>`click$et
<td>

<tr><td>5.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）
◎
OPTIONAL, multiple events, some limits

<tr><td>6.
<td>`mousedown$et
<td>

<tr><td>7.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）
◎
OPTIONAL, multiple events, some limits

<tr><td>8.
<td>`mouseup$et
<td>

<tr><td>9.
<td>`click$et
<td>

<tr><td>10.
<td>`dblclick$et
<td>
</tbody></table>

<p class="note">注記：
上の［
`mousedown$et と `mouseup$et ~eventの間
］に許容される `mousemove$et ~eventを生じさせる~~移動距離や~~頻度は、［
実装／装置／~platform
］特有になる。
この許容誤差は、手の~~動きが不安定であるなど，身体的不利のある利用者が，~pointing装置でやりとりするときの援助にもなり得る。
◎
The lag time, degree, distance, and number of mousemove events allowed between the mousedown and mouseup events while still firing a click or dblclick event will be implementation-, device-, and platform-specific. This tolerance can aid users that have physical disabilities like unsteady hands when these users interact with a pointing device.
</p>

<p>
各~実装は、適切な`~hysteresis$を決定することになるが、
一般に
［［
結付けられている
`mousedown$et と `mouseup$et
~event
］の標的が同じ要素であって，
`mouseout$et や `mouseleave$et ~eventが介在しない
］ときには、
`click$et／`dblclick$et
~eventを発火する~SHOULDである。
また、［
結付けられている
`mousedown$et と `mouseup$et とで標的が異なる
］ときは、最も近い共通の`広義先祖$ 上に
`click$et／`dblclick$et
~eventを発火する~SHOULDである。
◎
Each implementation will determine the appropriate hysteresis tolerance, but in general SHOULD fire click and dblclick events when the event target of the associated mousedown and mouseup events is the same element with no mouseout or mouseleave events intervening, and SHOULD fire click and dblclick events on the nearest common inclusive ancestor when the associated mousedown and mouseup event targets are different.
</p>

<div class="example">

<p>
`mousedown$et ~eventが HTML 文書の `~body要素$を標的にしていて，対応する `mouseup$et ~eventが`根~要素$を標的にしている場合、最も近い共通の`広義先祖$は`根~要素$なので， `click$et ~eventは根~要素へ配送されることになる。
◎
If a mousedown event was targeted at an HTML document’s body element, and the corresponding mouseup event was targeted at the root element, then the click event will be dispatched to the root element, since it is the nearest common inclusive ancestor.
</p>
</div>

<p>
~mouse~event連列の最中に，`~event標的$が~DOMから除去された場合、連列の残りの部分の~eventが，その要素~上に発火されては~MUST_NOT。
◎
If the event target (e.g. the target element) is removed from the DOM during the mouse events sequence, the remaining events of the sequence MUST NOT be fired on that element.
</p>

<p class="trans-note">【
標的が~DOMの中で移動された場合はどうなる？
その種の位置~変化が伴われるような いかなる~DOM~~操作も，［
要素をいったん~DOM木から除去してから挿入し直すものである
］と解釈するならば、それらの要素には，~eventは配送されなくなることになるが。
】</p>

<div class="example">

<p>
`mousedown$et ~eventの結果，【~event~listenerにより】
標的~要素が~DOMから除去された場合、その要素に対し［
`mouseup$et, `click$et, `dblclick$et,
］~eventは発火されず、これらの~eventによる既定の`作動化の挙動$も誘発されなくなる。
しかしながら， `mouseup$et ~eventは、依然として［
標的~要素が除去された後に新たに`~pointing先$になった要素
］に対しては発火されることになる。
同様に， `mouseup$et ~eventの配送の最中に 標的~要素が~DOMから除去された場合、
`click$et, および後続の~eventは，配送されなくなる。
◎
If the target element is removed from the DOM as the result of a mousedown event, no events for that element will be dispatched for mouseup, click, or dblclick, nor any default activation events. However, the mouseup event will still be dispatched on the element that is exposed to the mouse after the removal of the initial target element. Similarly, if the target element is removed from the DOM during the dispatch of a mouseup event, the click and subsequent events will not be dispatched.
</p>
</div>

			</section>
			<section id="events-mouse-types">
<h4>4.3.4. 各種~mouse~event型</h4>
<p>
以下に，各種~mouse~event型を挙げる。
入子にされている要素に対しては、~mouse~event型は，常に`~pointing先$
— 入子において最も深い要素† —
を標的にする。
標的にされた要素の先祖は、~event浮上を利用して，その子孫~要素たちの中で生じた~mouse~eventの通知を得ることができる。
◎
The Mouse event types are listed below. In the case of nested elements, mouse event types are always targeted at the most deeply nested element. Ancestors of the targeted element MAY use bubbling to obtain notification of mouse events which occur within its descendent elements.
</p>

<p class="trans-note">【†
`mouseenter$et, `mouseleave$et に関しては、その限りでない。
】</p>



				<section id="event-type-click">
<h5>4.3.4.1. `click^et</h5>

`●型^ `click@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ 文脈依存
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`UIEvent.detail$m：
`現在の~click回数$を指示する：
属性~値は、利用者がこの動作を始めたときは
1 になり，その後，各~clickごとに 1 ずつ増加され~MUST。
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
`●表終^

<p>
`click$et ~event型は、利用者が首~pointer~buttonを［
押してから, 離した
］とき, あるいは［
そのような動作を模造する方式で~pointerが作動化された
］ときに、`~pointing先$が要素であるならば，それに向けて発火され~MUST。
~mouse~buttonがどのように作動されるかは、［
~pointing装置, 環境設定0
］に依存する。
例えば、~screen上の所在や，~buttonが押されてから離されるまでの遅延に依存することもある。
◎
The click event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.
</p>

<p>
`click^et ~eventは、首~pointer~buttonに対してのみ発火される~SHOULDである
（すなわち， `MouseEvent!I の
`button$m 値は 0 ／
`buttons$m 値は 1
）。
`click^et ~eventは、副~button（標準的な~mouseの
中央~button／右~button
など）に対しては，発火されては~MUST_NOT。
◎
The click event should only be fired for the primary pointer button (i.e., when button value is 0, buttons value is 1). Secondary buttons (like the middle or right button on a standard mouse) MUST NOT fire click events.
</p>

<p>
`click$et ~eventに先行して，同じ要素~上に［
`mousedown$et ／ `mouseup$et
］~eventが発火される場合もある
— 他の~node型（例： ~text~node）への移動は~~無視して【下記 例を見よ】。
環境設定0に依存して、 `click$et ~eventは、~pointing装置の~buttonが押されてから離されるまでの間に ~event型［
`mouseover$et,
`mousemove$et,
`mouseout$et
］ 1 回以上 生じた場合にも発火されてよい。
`click$et ~eventには `dblclick$et ~eventが~~後続してもよい。
◎
The click event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the click event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button. The click event MAY also be followed by the dblclick event.
</p>

<div class="example">

<p>
利用者が、（ CSS ~propertyにより）行高が大きくとられた `p^e 要素~内の，ある子~text~node上で~mouseを~~押下げて、~mouseを，その~text~node上を外れる所まで少し~~動かして（すなわち，~pointerは同じ~text~blockの行の合間にあるが，`~pointing先$は 依然として `p^e 要素を指している）から~mouseを~~離した場合でも、まだ同じ要素の視野にあるので，依然として `click$et ~eventを誘発するであろう（ `click$et に対する通常の時間的`~hysteresis$に~~収まるならば）。
~UAにより生成される~mouse~eventは、~text~node上に発火されることはないことに注意。
◎
If a user mouses down on a text node child of a &lt;p&gt; element which has been styled with a large line-height, shifts the mouse slightly such that it is no longer over an area containing text but is still within the containing block of that &lt;p&gt; element (i.e., the pointer is between lines of the same text block, but not over the text node per se), then subsequently mouses up, this will likely still trigger a click event (if it falls within the normal temporal hysteresis for a click), since the user has stayed within the scope of the same element. Note that user-agent-generated mouse events are not dispatched on text nodes.
</p>
		</div>

<p>
~event型 `click$et は、結付けられている~pointing装置に加えて、`作動化の誘発と挙動$にて述べたように，要素に対する作動化の一環としても発火され~MUST。
◎
In addition to being associated with pointer devices, the click event type MUST be dispatched as part of an element activation, as described in §3.5 Activation triggers and behavior.
</p>

<p class="note">注記：
~accessibilityを最大限にするため、内容~作者には，~custom~controlに対する`作動化の挙動$を定義する際にも `click$et ~event型を利用することが奨励される
— `mousedown$et ／ `mouseup$et など、~pointing装置に より特有の他の~event型ではなく。
`click$et ~event型は，~pointing装置（例： ~mouse）に由来するものであるが、後の実装において，その結付けを超えるように拡張されており、要素を作動化するための，装置に依存しない~event型と見なせるので。
◎
For maximum accessibility, content authors are encouraged to use the click event type when defining activation behavior for custom controls, rather than other pointing-device event types such as mousedown or mouseup, which are more device-specific. Though the click event type has its origins in pointer devices (e.g., a mouse), subsequent implementation enhancements have extended it beyond that association, and it can be considered a device-independent event type for element activation.
</p>

<p>
`click$et ~event型の`既定~動作$は、文脈依存であり，［
~eventの`標的$
］, および［
`MouseEvent!I の
`button$m ／ `buttons$m
属性の値
］に基づく。
`click$et ~event型の代表的な`既定~動作$は、次に従う：
◎
The default action of the click event type varies based on the event target of the event and the value of the button or buttons attributes. Typical default actions of the click event type are as follows:
</p>

		<ul>
			<li>
`標的$に結付けられている`作動化の挙動$があるならば、`既定~動作$は，その`作動化の挙動$を実行するもので~MUST（`作動化の誘発と挙動$を見よ）。
◎
If the event target has associated activation behavior, the default action MUST be to execute that activation behavior (see §3.5 Activation triggers and behavior).
</li>
			<li>
`標的$が可focusならば、`既定~動作$は，その要素に文書~focusを与え~MUST。
◎
If the event target is focusable, the default action MUST be to give that element document focus.
</li>
		</ul>




				</section>
				<section id="event-type-dblclick">
<h5>4.3.4.2. `dblclick^et</h5>

`●型^ `dblclick@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`UIEvent.detail$m：
`現在の~click回数$
を指示する
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
`●表終^

<p>
~UAは、［
要素~上で~pointing装置の首~buttonが
【ある時間内に】
二回~clickされた
］とき，この~eventを発火し~MUST。
~double-clickの定義は、［
その標的が
`mousedown$et ／ `mouseup$et ／ `dblclick$et
と同じで~MUST
］ことを除いて，環境設定0に依存する。
この~event型は、［
~clickと~double-clickが同時に生じた場合は `click$et  ／
他の場合は `mouseup$et
］の後に配送され~MUST。
◎
A user agent MUST dispatch this event when the primary button of a pointing device is clicked twice over an element. The definition of a double click depends on the environment configuration, except that the event target MUST be the same between mousedown, mouseup, and dblclick. This event type MUST be dispatched after the event type click if a click and double click occur simultaneously, and after the event type mouseup otherwise.
</p>

<p>
`click$et ~eventと同様に，
`dblclick$et ~eventは，首~pointer~buttonに対してのみ発火される~SHOULDであり、副~buttonに対して発火されては~MUST_NOT。
◎
As with the click event, the dblclick event should only be fired for the primary pointer button. Secondary buttons MUST NOT fire dblclick events.
</p>

<p class="note">注記：
`click$et ~eventを取消しても、
`dblclick$et ~eventが発火されるかどうかには影響しない。
◎
Canceling the click event does not affect the firing of a dblclick event.
</p>

<p>
`click$et
~event型と同様に，

`dblclick$et ~event型の`既定~動作$は、文脈依存であり，［
~eventの`標的$, および
`MouseEvent.button$m ／ `MouseEvent.buttons$m
属性の値
］に基づく。
`dblclick$et ~event型の代表的な`既定~動作$は、通常，
`click$et ~event型のそれと合致するが，次の追加の挙動も伴う:
◎
As with the click event type, the default action of the dblclick event type varies based on the event target of the event and the value of the button or buttons attributes. Normally, the typical default actions of the dblclick event type match those of the click event type, with the following additional behavior:
</p>

		<ul>
			<li>
`標的$が選択可能ならば、`既定~動作$は，その選択可能な内容の一部またはすべてを選択するもので~MUST。
後続の各~clickは、その内容の選択可能な部位を追加で選択して~MAY。
【代表的な例： 初回は単語を選択し, 次回は行全体を選択するなど。】
◎
If the event target is selectable, the default action MUST be to select part or all of the selectable content. Subsequent clicks MAY select additional selectable portions of that content.
</li>
		</ul>




				</section>
				<section id="event-type-mousedown">
<h5>4.3.4.3. `mousedown^et</h5>

`●型^ `mousedown@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ 

<ul><li>~drag／~drop操作を開始する
</li><li>~text選択を開始する
</li><li>~scroll／~pan
操作0を開始する
（~supportされるなら，中央~mouse~buttonとの組合せで）
</li></ul>

◎
Varies: Start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported)
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`UIEvent.detail$m：
( `現在の~click回数$ + 1 )
を指示する。
例えば、 `mousedown$et の直前に~clickが起きていない場合の
`UIEvent.detail$m 値は 1 になる。
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count incremented by one. For example, if no click happened before the mousedown, detail will contain the value 1
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null

`●表終^

<p>
~UAは、［
~pointing装置の~buttonが要素~上で押された
］とき，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when a pointing device button is pressed over an element.
</p>

<p class="note">注記：
多くの実装が、
`mousedown$et ~eventを利用して，文脈に依存する種々の`既定~動作$を開始する。
これらの既定~動作は、この~eventを取消すことにより，防止できる。
これらの既定~動作には、［
画像や~linkの ~dragや~dropの開始 ／
操作0の開始 ／
~text選択の開始
］, 等々がある。
加えて、~mouse駆動による~pan~~操作 特色機能を提供する実装もある（ `mousedown$et ~eventの配送-時に，中央~mouse~buttonが押されていた場合に作動化されるような）。
◎
Many implementations use the mousedown event to begin a variety of contextually dependent default actions. These default actions can be prevented if this event is canceled. Some of these default actions could include: beginning a drag/drop interaction with an image or link, starting text selection, etc. Additionally, some implementations provide a mouse-driven panning feature that is activated when the middle mouse button is pressed at the time the mousedown event is dispatched.
</p>





				</section>
				<section id="event-type-mouseenter">
<h5>4.3.4.4. `mouseenter^et</h5>

`●型^ `mouseenter@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ しない
`●標的^ `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
注釈文を見よ。
</li><li>`MouseEvent.button$m： 0
</li><li>`MouseEvent.relatedTarget$m：
変化前の`~pointing先$。
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is exiting, if any.

`●表終^

<p>
~UAは、［
~pointerが動かされて, 要素とその子孫たちが成す境界に入った†
］とき、その要素に向けて，この~eventを発火し~MUST。
この~event型は， `mouseover$et に似るが、浮上しないこと, および
前の`~pointing先$が要素の子孫の場合は 要素に発火されてはならない点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or one of its descendent elements. This event type is similar to mouseover, but differs in that it does not bubble, and MUST NOT be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
</p>

<div class="trans-note">

<p>【†
すなわち、ある~pointerの`~pointing先$が変化したとき，次の両~条件を満たす要素があれば、<em>それら</em>に向けて発火されることになる：
</p>

<ul><li>要素は、変化-後の~pointing先か, または その先祖である。
</li><li>要素は、変化-前の~pointing先でも, その子孫でもない。
</li></ul>

<p>
そのような要素は、同時に複数~存在し得る（変化-前の~pointing先が ~NULL ならば、変化-後の~pointing先と その先祖~要素すべてが該当することになる）。
その場合、該当する各~要素に向けて，最も先祖のものから順に，この~eventを発火することになる（前~節に述べられた
<a href="#figure-mouse-event-stacked-elements">図 3 の積層された例</a>
における~mouse~event序列を見よ）。
</p>

<p>
条件を満たす各~要素のうち，変化-後の`~pointing先$ 以外のものは，~eventが生じた時点で`接触判定$の対象から除外されている可能性も考えられる。
その場合、［
そのような要素へは，~eventは発火されない
］とするのが正しい挙動かもしれない。
】</p>

</div>

<p class="note">注記：
この~event型と CSS `~hover_ps 疑似類$
`CSS2$r
には，類似性がある。
`mouseleave$et ~event型も見よ。
◎
There are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseleave event type.
</p>




				</section>
				<section id="event-type-mouseleave">
<h5>4.3.4.5. `mouseleave^et</h5>

`●型^ `mouseleave@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ しない
`●標的^ `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
注釈文を見よ。
</li><li>`MouseEvent.button$m：
0
</li><li>`MouseEvent.relatedTarget$m：
変化後の`~pointing先$。
【原文の記述は “変化前” を示唆しているが、更新-時の誤りであろう。】
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is exiting, if any.

`●表終^

<p>
~UAは、［
~pointerが動かされて, 要素とその子孫たちが成す境界から出た†
］とき、その要素に向けて，この~eventを発火し~MUST。
この~event型は， `mouseout$et に似るが、浮上しないこと, および
新たな`~pointing先$が要素の子孫である場合は 要素に発火されてはならない点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element and all of its descendent elements. This event type is similar to mouseout, but differs in that does not bubble, and that it MUST NOT be dispatched until the pointing device has left the boundaries of the element and the boundaries of all of its children.
</p>

<div class="trans-note">

<p>【†
すなわち、ある~pointerの`~pointing先$が変化したとき，次の両~条件を満たす要素があれば、<em>それら</em>に向けて発火されることになる：
</p>

<ul><li>要素は、変化-前の~pointing先か, または その先祖である。
</li><li>要素は、変化-後の~pointing先でも, その子孫でもない。
</li></ul>

<p>
そのような要素は、同時に複数~存在し得る（新たな~pointing先が ~NULL ならば、変化-前の~pointing先と その先祖~要素すべてが該当することになる）。
その場合、該当する各~要素に向けて，（ `mouseenter^et のときとは逆順に）最も子孫のものから順に，この~eventを発火することになる。
】</p>
</div>

<p class="note">注記：
この~event型と CSS `~hover_ps 疑似類$ `CSS2$r には類似性がある。
`mouseenter$et ~event型も見よ。
◎
There are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseenter event type.
</p>




				</section>
				<section id="event-type-mousemove">
<h5>4.3.4.6. `mousemove^et</h5>

`●型^ `mousemove@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`MouseEvent.button$m：
0
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null

`●表終^

<p>
~UAは、［
`~pointing先$が要素~上で動いた
］とき，その要素に向けて，この~eventを発火し~MUST。
~pointing装置が動かされる間に~eventが生じる頻度0は［
実装／装置／~platform
］に特有であるが、持続的な動きに対しては，動きが止まる度にではなく，複数の `mousemove$et ~eventが連続して発火される~SHOULDである。
実装には、即応性と処理能との兼ね合いをとる最適な頻度0を決定することが奨励される。
◎
A user agent MUST dispatch this event when a pointing device is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive mousemove events SHOULD be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance.
</p>

<p class="note">注記：
~browserなどの一部の実装~環境においては、
`mousemove$et~eventは，利用者が（~mouse~buttonを押すなどして）~drag操作を始めてから ~pointing装置が~UAの境界を離れた後も，発火し続け得る。
◎
In some implementation environments, such as a browser, mousemove events can continue to fire if the user began a drag operation (e.g., a mouse button is pressed) and the pointing device has left the boundary of the user agent.
</p>

<p class="note" id="mousemove-now-cancelable">注記：
以前は、 `DOM-Level-2-Events$r において，この~eventは`取消可能$でないと指定されていたが、既存の~UA間の相互運用性を反映するため，変更された。
◎
This event was formerly specified to be non-cancelable in DOM Level 2 Events [DOM-Level-2-Events], but was changed to reflect existing interoperability between user agents.
</p>




				</section>
				<section id="event-type-mouseout">
<h5>4.3.4.7. `mouseout^et</h5>

`●型^ `mouseout@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`target$m：
変化前の`~pointing先$。
</li><li>`MouseEvent.button$m：
0
</li><li>`MouseEvent.relatedTarget$m：
変化後の`~pointing先$。
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is entering, if any.

`●表終^

<p>
~UAは、~pointerが動かされて, `~pointing先$が変化したとき，前の`~pointing先$が要素であるならば、この~eventをその要素に向けて発火し~MUST。
この~event型は， `mouseleave$et に似るが、浮上すること, および
新たな`~pointing先$が要素の子孫であっても 要素に発火され~MUST点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element. This event type is similar to mouseleave, but differs in that does bubble, and that it MUST be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
</p>

<p class="note">注記：
`mouseover$et ~event型も見よ。
◎
See also the mouseover event type.
</p>




				</section>
				<section id="event-type-mouseover">
<h5>4.3.4.8. `mouseover^et</h5>

`●型^ `mouseover@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`MouseEvent.button$m：
0
</li><li>`MouseEvent.relatedTarget$m：
変化前の`~pointing先$。
【原文の記述は “変化後” を示唆しているが、更新-時の誤りであろう。】
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is entering, if any.

`●表終^

<p>
~UAは、~pointerが動かされて, `~pointing先$が変化したとき，新たな`~pointing先$が要素であるならば、この~eventをその要素に向けて発火し~MUST。
この~event型は， `mouseenter$et に似るが、浮上すること, および
前の`~pointing先$が要素の子孫であっても 要素に発火され~MUST点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element. This event type is similar to mouseenter, but differs in that it bubbles, and that it MUST be dispatched when the pointer device moves onto the boundaries of an element whose ancestor element is the event target for the same event listener instance.
</p>

<p class="note">注記：
`mouseout$et ~event型も見よ。
◎
See also the mouseout event type.
</p>




				</section>
				<section id="event-type-mouseup">
<h5>4.3.4.9. `mouseup^et</h5>

`●型^ `mouseup@et
`●界面^ `MouseEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ 
文脈~menuを呼出す（~supportされるなら，右~mouse~buttonとの組合せで）
◎
Invoke a context menu (in combination with the right mouse button, if supported)
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`UIEvent.detail$m：
( `現在の~click回数$ + 1 )
を指示する。
</li></ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count incremented by one.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null

`●表終^

<p>
~UAは、［
~pointing装置の~buttonが要素~上で離された
］とき，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when a pointing device button is released over an element.
</p>

<p class="note">注記：
多くの実装は、右~mouse~buttonが離されるとき†には、この~eventの既定~動作として，文脈~menuを呼出す。
【†押したときに呼出す実装もある（そのほうが多い？）。】
◎
Many implementations will invoke a context menu as the default action of this event if the right mouse button is being released.
</p>

<p class="note">注記：
~browserなど，実装~環境によっては、 `mouseup$et ~eventは，~pointing装置が~UAの境界から出たときにも発火され得る。
例： 利用者が~mouse~buttonを押して~drag操作を始めたときなど。
◎
In some implementation environments, such as a browser, a mouseup event can be dispatched even if the pointing device has left the boundary of the user agent, e.g., if the user began a drag operation with a mouse button pressed.
</p>

				</section>
			</section>
			<section id="_common-mouse-event-context">
<h4>各種~mouse~eventに共通する文脈~情報</h4>

集約簡略化

<p>
多くの~mouse~eventに共通する文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
`~pointing先$
◎
Event.target : topmost event target
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通する文脈~情報$にて与えられる。
</dd>

	<dt>`MouseEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`screenX$m</dt>
			<dd>
~screen上の~pointer位置に基づく値
◎
MouseEvent.screenX : value based on the pointer position on the screen
</dd>

			<dt>`screenY$m</dt>
			<dd>
~screen上の~pointer位置に基づく値
◎
MouseEvent.screenY : value based on the pointer position on the screen
</dd>

			<dt>`clientX$m</dt>
			<dd>
表示域の中の~pointer位置に基づく値
◎
MouseEvent.clientX : value based on the pointer position within the viewport
</dd>

			<dt>`clientY$m</dt>
			<dd>
表示域の中の~pointer位置に基づく値
◎
MouseEvent.clientY : value based on the pointer position within the viewport
</dd>

			<dt>`altKey$m</dt>
			<dd>
`Alt^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.altKey : true if Alt modifier was active, otherwise false
</dd>

			<dt>`ctrlKey$m</dt>
			<dd>
`Control^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
</dd>

			<dt>`shiftKey$m</dt>
			<dd>
`Shift^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
</dd>

			<dt>`metaKey$m</dt>
			<dd>
`Meta^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.metaKey : true if Meta modifier was active, otherwise false
</dd>

			<dt>`button$m</dt>
			<dd>
現在 押されている~buttonに基づく値。
◎
MouseEvent.button : value based on current button pressed
</dd>

			<dt>`buttons$m</dt>
			<dd>
現在の押下げられているすべての~buttonに基づく値。
押された~buttonが無ければ 0 になる。
◎
MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
</dd>

			<dt>`relatedTarget$m</dt>
			<dd>
~NULL
◎
MouseEvent.relatedTarget : null
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-wheelevents">
<h3 title="Wheel Events">4.4. ~wheel~event</h3>
<p>
~wheelは、 1 つ以上の空間的次元にて回転できる装置であり，~pointing装置に結付けられ得る。
座標系は環境設定0に依存する。
◎
Wheels are devices that can be rotated in one or more spatial dimensions, and which can be associated with a pointer device. The coordinate system depends on the environment configuration.
</p>

<div class="example">

<p>
利用者の環境は、［
横~scroll／縦~scroll／~zoom
］を［
x-軸／y-軸／z-軸
］に沿う回転に結付けるように環境設定され得る。
◎
The user’s environment might be configured to associate vertical scrolling with rotation along the y-axis, horizontal scrolling with rotation along the x-axis, and zooming with rotation along the z-axis.
</p>
</div>

<p>
`WheelEvent!I ~objの［
`deltaX$m ／ `deltaY$m ／ `deltaZ$m
］属性は、それぞれの軸に沿う，いずれかの`計測~単位$による計測を指示する。
報告される計測は、［
環境~特有の~algoが，~wheel装置の実際の 回転や動き を適切な 値＆単位 に翻訳した後
］に提供される。
◎
The deltaX, deltaY, and deltaZ attributes of WheelEvent objects indicate a measurement along their respective axes in units of pixels, lines, or pages. The reported measurements are provided after an environment-specific algorithm translates the actual rotation/movement of the wheel device into the appropriate values and units.
</p>

<p>
【定義追加：】
`計測~単位@
とは、画素~数, 行~数, 頁~数の総称である。
</p>

<div class="trans-note">
<p>
原文には、これらが何の計量に基づくかは，記されていない。
次の定義が考えられるが：
</p>

<ul><li>画素~数は、 CSS pixel 単位（機器~画素~単位ではなく）。
</li><li>行数は、`根~要素$の CSS `line-height^c ~propertyに基づく。
</li><li>頁~数は、よくある~computer~screenの下では，
CSS 表示域（ viewport ）の寸法に基づく。
</li></ul>
</div>

<p class="note">注記：
利用者は、~wheel装置の実際の
回転／動き
を異なる仕方で解釈させるよう環境設定1を~custom化し得る。
［
共通的な
“dented” 【？】
~mouse~wheelの一回の動き
］は、何~画素か（実際の値は ~UAの現在の~screen寸法に依存する）に計測されるが、利用者は、自身の環境設定1を変更して，この数を増大させ、~mouse~wheelを高速化することもある。
更には、~mouse~wheel~softwareには，加速機能（~wheelを高速に回転させる／動かす程，各~計測の`~delta$が大きくなる）を~supportするものや，
1 画素~単位より精細に`回転$を計測するものもある。
よって作者は、ある~UAにおける`回転$量が，他の~UAにおいても 同じ`~delta$値を生産すると見做すことはできない。
◎
A user’s environment settings can be customized to interpret actual rotation/movement of a wheel device in different ways. One movement of a common "dented" mouse wheel can produce a measurement of 162 pixels (162 is just an example value, actual values can depend on the current screen dimensions of the user-agent). But a user can change their default environment settings to speed-up their mouse wheel, increasing this number. Furthermore, some mouse wheel software can support acceleration (the faster the wheel is rotated/moved, the greater the delta of each measurement) or even sub-pixel rotation measurements. Because of this, authors can not assume a given rotation amount in one user agent will produce the same delta value in all user agents.
</p>

<p>
［
`deltaX^m ／ `deltaY^m ／ `deltaZ^m
］属性~値の正負は、実際の~wheel装置が同じ方向に 回転する／動く 間， `wheel$et ~eventの複数の発火において一貫して~MUST。
~UAは、 `wheel$et ~eventの既定~動作として~scrollする場合の`~delta$の符号を，
`右手~座標系@
で
— すなわち，［
X／Y／Z
］軸の正~方向が，文書の［
右方／下方／奥方（利用者から遠ざかる）
］を向くように —
与える~SHOULDである。
◎
The sign (positive or negative) of the values of the deltaX, deltaY, and deltaZ attributes MUST be consistent between multiple dispatches of the wheel event while the motion of the actual wheel device is rotating/moving in the same direction. If a user agent scrolls as the default action of the wheel event then the sign of the delta SHOULD be given by a right-hand coordinate system where positive X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.
</p>

<p class="note">注記：
~wheelの物理的な操作に対する解釈は、個々の~UAによって（あるいは~UAや~hardwareの環境設定に依存して）異なることもある。
例えば，~trackpadの淵で上から下へ~swipeされたとき、下への頁~scrollを意図する~wheel動作として解釈されることもあれば、その逆に解釈されることもある（すなわち， `deltaY^m 値は、前者が正, 後者が負）。
◎
Individual user agents can (depending on their environment and hardware configuration) interpret the same physical user interaction on the wheel differently. For example, a vertical swipe on the edge of a trackpad from top to bottom can be interpreted as a wheel action intended to either scroll the page down or to pan the page up (i.e., resulting in either a positive or negative deltaY value respectively).
</p>

			<section id="interface-wheelevent">
<h4 title="Interface WheelEvent">4.4.1. ~ifc `WheelEvent^I</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`WheelEvent^I ~ifcは、 `wheel$et ~event特有の文脈的~情報を提供する。
`WheelEvent^I ~ifcの~instanceを作成するためには、その構築子に
`WheelEventInit^I 辞書（省略可）を渡して呼び出す。
◎
The WheelEvent interface provides specific contextual information associated with wheel events. To create an instance of the WheelEvent interface, use the WheelEvent constructor, passing an optional WheelEventInit dictionary.
</p>

				<section id="idl-wheelevent">
<h5>4.4.1.1. `WheelEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `WheelEventInit$I %eventInitDict)]
interface `WheelEvent@I : `MouseEvent$I {
    // <span class="comment">`deltaMode^m 値がとり得る定数</span>
    const unsigned long `DOM_DELTA_PIXEL$m = 0x00;
    const unsigned long `DOM_DELTA_LINE$m = 0x01;
    const unsigned long `DOM_DELTA_PAGE$m = 0x02;

    ~RA double        `deltaX$m;
    ~RA double        `deltaY$m;
    ~RA double        `deltaZ$m;
    ~RA unsigned long `deltaMode$m;
};
</pre>

<dl class="idl-def">

	<dt>`DOM_DELTA_PIXEL@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、`~delta$に対する`計測~単位$は，画素~数で~MUST。
これは、大部分の~OSや実装の環境設定における，最も代表的な事例である。
◎
The units of measurement for the delta MUST be pixels. This is the most typical case in most operating system and implementation configurations.
</dd>

	<dt>`DOM_DELTA_LINE@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、`~delta$に対する`計測~単位$は，~textの行~数で~MUST。
これは，多くの~form~controlに該当する。
◎
The units of measurement for the delta MUST be individual lines of text. This is the case for many form controls.
</dd>

	<dt>`DOM_DELTA_PAGE@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、`~delta$に対する`計測~単位$は，［
単独の~screen, または 頁区分
］に基いて定義される頁~数で~MUST。
◎
The units of measurement for the delta MUST be pages, either defined as a single screen or as a demarcated page.
</dd>

	<dt>`deltaX@m</dt>
	<dt>`deltaY@m</dt>
	<dt>`deltaZ@m</dt>
	<dd>
`wheel$et ~eventの既定~動作が~scrollである~UAでは、~eventが取消されなかった場合の値は，当該の軸に沿って~scrollされることになる（いずれかの`計測~単位$による）計測で~MUST。
他の場合、これは［
当該の軸~~廻りの~wheel装置の動き
］の実装~特有の（いずれかの`計測~単位$による）計測。
◎
deltaX, of type double, readonly
• In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the x-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the x-axis.
◎
The un-initialized value of this attribute MUST be 0.0.
◎
deltaY, of type double, readonly
• In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the y-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the y-axis.
◎
The un-initialized value of this attribute MUST be 0.0.
◎
deltaZ, of type double, readonly
• In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the z-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the z-axis.
</dd>

	<dd>
`未初期化~値$： 0.0
◎
The un-initialized value of this attribute MUST be 0.0.
</dd>

	<dt>`deltaMode@m</dt>
	<dd>
`deltaMode^m 属性~値は、`~delta$値に対する`計測~単位$を指示する。
既定~値は `DOM_DELTA_PIXEL$m （画素~数）。
◎
deltaMode, of type unsigned long, readonly
• The deltaMode attribute contains an indication of the units of measurement for the delta values. The default value is DOM_DELTA_PIXEL (pixels).
</dd>
	<dd>
この属性は、［
`~delta$値に対する`計測~単位$を指示する，いずれかの `DOM_DELTA_…^m 定数
］に設定され~MUST。
精確な計測は，［
装置／~OS／~app
］の環境設定に特有になる。
◎
This attribute MUST be set to one of the DOM_DELTA constants to indicate the units of measurement for the delta values. The precise measurement is specific to device, operating system, and application configurations.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

</dl>

				</section>
				<section id="idl-wheeleventinit">
<h5>4.4.1.2. `WheelEventInit^I</h5>

<pre class="idl">
dictionary `WheelEventInit@I : `MouseEventInit$I {
    double        `deltaX@m = 0.0;
    double        `deltaY@m = 0.0;
    double        `deltaZ@m = 0.0;
    unsigned long `deltaMode@m = 0;
};
</pre>

<p>
この辞書の各~memberは、
`WheelEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、その~ifc定義の記述を見よ。
◎
deltaX, of type double, defaulting to 0.0
• See deltaZ attribute.
◎
deltaY, of type double, defaulting to 0.0
• See deltaZ attribute.
◎
deltaZ, of type double, defaulting to 0.0
• double deltaZ = 0.0
◎
Initializes the deltaZ attribute of the WheelEvent object. Relative positive values for this attribute (as well as the deltaX and deltaY attributes) are given by a right-hand coordinate system where the X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively. Negative relative values are in the respective opposite directions.
◎
deltaMode, of type unsigned long, defaulting to 0
• Initializes the deltaMode attribute on the WheelEvent object to the enumerated values 0, 1, or 2, which represent the amount of pixels scrolled (DOM_DELTA_PIXEL), lines scrolled (DOM_DELTA_LINE), or pages scrolled (DOM_DELTA_PAGE) if the rotation of the wheel would have resulted in scrolling.
</p>

				</section>
			</section>
			<section id="events-wheel-types">
<h4>4.4.2. 各種~wheel~event型</h4>

				<section id="event-type-wheel">
<h5>4.4.2.1. `wheel^et</h5>

`●型^ `wheel@et
`●界面^ `WheelEvent$I
`●同期^ なし
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ 
文書を~scroll（または~zoom）する
◎
Scroll (or zoom) the document
`●文脈^
<p>
次を除き，`各種~mouse~eventに共通する文脈~情報$にて与えられる：
</p>

<ul >
	<li>
~wheelが~pointing装置に結付けられていない場合、
`MouseEvent!I の［
`screenX$m,
`screenY$m,
`clientX$m,
`clientY$m,
`button$m,
`buttons$m
］は、 0 にされる。
また、
`relatedTarget$m は
【明示的に記されていないが，おそらく】
~NULL （`未初期化~値$）。
</li>
	<li>
`WheelEvent!I の［
`deltaX$m ／
`deltaY$m ／
`deltaZ$m
］は、［
X  ／ Y  ／ Z
］軸~~廻りの~wheel装置の動きを~~反映する量であって、［
頁が `deltaMode$m 単位に従って，その軸に沿って~scrollする量
］であるか，または実装~特有の値。
</li>
	<li>
`WheelEvent.deltaMode$m は、［
`deltaX$m ／ `deltaY$m ／ `deltaZ$m
］属性に対する，（いずれかの`計測~単位$を表現する）単位~指示子。
</li>
</ul>

◎
• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0
• MouseEvent.screenY : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0
• MouseEvent.clientX : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0
• MouseEvent.clientY : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : if wheel is associated with a pointing device, value based on current button pressed, otherwise 0
• MouseEvent.buttons : if wheel is associated with a pointing device, value based on all buttons current depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target the pointing device is pointing at, if any
• WheelEvent.deltaX : expected amount that the page will scroll along the x-axis according to the deltaMode units; or an implemenation-specific value of movement of a wheel around the x-axis
• WheelEvent.deltaY : expected amount that the page will scroll along the y-axis according to the deltaMode units; or an implemenation-specific value of movement of a wheel around the y-axis
• WheelEvent.deltaZ : expected amount that the page will scroll along the z-axis according to the deltaMode units; or an implemenation-specific value of movement of a wheel around the z-axis
• WheelEvent.deltaMode : unit indicator (pixels, lines, or pages) for the deltaX, deltaY, and deltaZ attributes
`●表終^


<p>
~UAは、［
~mouse~wheelが，いずれかの軸で回転された, または
等価な入力~装置（~mouse-ballや, 一部の~tabletや~touchpad, 等々）が そのような動作を模倣した
］とき，この~eventを発火し~MUST。
同時に複数の軸が回転された場合の~wheel`~delta$は、~platformや入力~装置に依存して，［
単独の `wheel$et ~eventにまとめて, あるいは
軸ごとに別々の `wheel$et ~eventとして
］，送達されることもある。
`wheel$et ~event型の代表的な`既定~動作$は、指示された量だけ文書を~scrollする（あるいは一部の事例では，~zoomする）。
この~eventが取消された場合、実装は，文書を
~scroll／~zoom
しては~MUST_NOT（あるいは，何であれ、この~event型に結付けられている 他の実装~特有の既定~動作も）。
◎
A user agent MUST dispatch this event when a mouse wheel has been rotated around any axis, or when an equivalent input device (such as a mouse-ball, certain tablets or touchpads, etc.) has emulated such an action. Depending on the platform and input device, diagonal wheel deltas MAY be delivered either as a single wheel event with multiple non-zero axes or as separate wheel events for each non-zero axis. The typical default action of the wheel event type is to scroll (or in some cases, zoom) the document by the indicated amount. If this event is canceled, the implementation MUST NOT scroll or zoom the document (or perform whatever other implementation-specific default action is associated with this event type).
</p>

<p class="note">注記：
~UA や入力~装置によっては、~wheelが回される速度も`~delta$値に影響し得る
— 高速になる程 高い`~delta$値を生産するように。
◎
In some user agents, or with some input devices, the speed that the wheel has been turned can affect the delta values, with a faster speed producing a higher delta value.
</p>

				</section>
			</section>
		</section>
		<section id="events-inputevents">
<h3 title="Input Events">4.5. 入力~event型</h3>

<p>
入力~eventは、~DOMの更新~時に通知として送信される。
◎
Input events are sent as notifications whenever the DOM is being updated.
</p>

			<section id="interface-inputevent">
<h4 title="Interface InputEvent">4.5.1. ~ifc `InputEvent^I</h4>

<p>
DOM3 にて導入された。
◎
Introduced in DOM Level 3
</p>

				<section id="idl-inputevent">
<h5>4.5.1.1. `InputEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `InputEventInit$I %eventInitDict)]
interface `InputEvent@I : `UIEvent$I {
    readonly        attribute ~DS? `data$m;
    readonly        attribute boolean   `isComposing$m;
};
</pre>


<dl class="idl-def">
	<dt>`data@m</dt>
	<dd>
~IMEにより生成される~Unicode文字 `Unicode$r 並びの値を保持する（`空~文字列$にもなり得る）。
一連の文字は、 `UAX15$r にて定義される~Unicode正規化形
<em>NFC</em> による定義に従って正規化される~SHOULDである。
◎
data, of type DOMString, readonly, nullable
• data holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY contain the empty string.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>`isComposing@m</dt>
	<dd>
入力~eventが組成~sessionの一部として
— すなわち， `compositionstart$et ~eventの後, かつ
対応する `compositionend$et ~eventの前に —
生じたならば~T。
◎
isComposing, of type boolean, readonly
• true if the input event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

</dl>

				</section>
				<section id="idl-inputeventinit">
<h5>4.5.1.2. `InputEventInit^I</h5>

<pre class="idl">
dictionary `InputEventInit@I : `UIEventInit$I {
    ~DS?     `data@m = "";
    boolean       `isComposing@m = false;
};
</pre>

<p>
この辞書の各~memberは、
`InputEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、その~ifc定義の記述を見よ。
◎
data, of type DOMString, nullable, defaulting to ""
• Initializes the data attribute of the InputEvent object.
isComposing of type boolean, defaulting to false
◎
isComposing, of type boolean, defaulting to false
• Initializes the isComposing attribute of the InputEvent object.
</p>

				</section>
			</section>
			<section id="events-inputevent-event-order">

<h4 title="Input Event Order">4.5.2. 入力~event序列</h4>

<p>
この仕様にて定義される入力~eventは、相互相対順序の下で生じ~MUST。
◎
The input events defined in this specification MUST occur in a set order relative to one another.
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`beforeinput$et
<td>

<tr><td>
<td>
<td><em>DOM 要素は更新された</em>
◎
DOM element is updated

<tr><td>2.
<td>`input$et
<td>

</tbody></table>

			</section>
			<section id="events-input-types">
<h4>4.5.3. 各種~入力~event型</h4>

<p>
◎
The Input event types are listed below.
</p>

				<section id="event-type-beforeinput">
<h5>4.5.3.1. `beforeinput^et</h5>

`●型^ `beforeinput@et
`●界面^ `InputEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
— 特に，`HTMLInputElement$I 等の~control, または
`contenteditable^a 属性が可能化されている任意の `Element$I 。
◎
Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
`●取消^ 可
`●構^ Yes
`●既定動作^
~DOM要素を更新する
◎
Update the DOM element
`●文脈^
<p>
次を除き，`各種~入力~eventに共通する文脈~情報$にて与えられる：
</p>
<ul><li>`InputEvent.data$m は、内容が削除された場合には~NULLにされてよい。
</li></ul>

◎
• Event.target : event target that is about to be updated
• UIEvent.view : Window
• UIEvent.detail : 0
• InputEvent.data : the string containing the data that will be added to the element, which MAY be null if the content has been deleted
• InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
`●表終^

<p>
~UAは、~DOMが更新されつつあるとき，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event when the DOM is about to be updated.
</p>

				</section>
				<section id="event-type-input">
<h5>4.5.3.2. `input^et</h5>

`●型^ `input@et
`●界面^ `InputEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
— 特に，`HTMLInputElement$I 等の~control, または
`contenteditable^a 属性が可能化されている任意の `Element$I 。
◎
Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~入力~eventに共通する文脈~情報$にて与えられる：
</p>
<ul><li>`InputEvent.data$m は、内容が削除された場合には`空~文字列$にされてよい。
</li></ul>

◎
• Event.target : event target that was just updated
• UIEvent.view : Window
• UIEvent.detail : 0
• InputEvent.data : the string containing the data that will be added to the element, which MAY be the empty string if the content has been deleted
• InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
`●表終^

<p>
~UAは、~DOMが更新された直後に，この~eventを発火し~MUST。
◎
A user agent MUST dispatch this event immediately after the DOM has been updated.
</p>


				</section>
			</section>
			<section id="_common-input-event-context">
<h4>各種~入力~eventに共通する文脈~情報</h4>

集約簡略化

<p>
各種~入力~eventに共通する文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
更新されつつある／された`~event標的$。
◎
event target that
[ is about to be / was just ]
updated
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通する文脈~情報$にて与えられる。
</dd>
	<dt>`InputEvent!I ：</dt>
	<dd>
	<dd>
		<dl>
			<dt>`data$m</dt>
			<dd>
要素に追加されることになる~dataを包含する文字列。
内容が削除された場合には、~eventの型に応じて，`空~文字列$または~NULLにされてよい。
◎
InputEvent.data : the string containing the data that will be added to the element, which MAY be
[ the empty string | null ]
if the content has been deleted
</dd>
			<dt>`isComposing$m</dt>
			<dd>
この~eventが<a href="#keys-dead">~dead-key</a>連列, または
`~IME$が作動中の間に配送されたものであれば（`組成~event$が配送されているときなど） ~T
／
~ELSE_ ~F
◎
InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</dd>
		</dl>
	</dd>
</dl>


			</section>
		</section>
		<section id="events-keyboardevents">
<h3 title="Keyboard Events">4.6. ~keyboard~event型</h3>

<p>
~keyboard~eventは、装置~依存である
— すなわち，それは、［
入力~装置の能力, および
【物理的な~keyが】
~OSにてどう~mapされているか
］に依拠する。
詳細は、~keyboard~eventと`組成~event$とを組合せる用例も含め，`~keyboard~eventと~key値$ 節に。
文字~生成~装置によっては，~keyboard~eventを生成しないものもある。
◎
Keyboard events are device dependent, i.e., they rely on the capabilities of the input devices and how they are mapped in the operating systems. Refer to Keyboard events and key values for more details, including examples on how Keyboard Events are used in combination with Composition Events. Depending on the character generation device, keyboard events might not be generated.
</p>

<p class="note">注記：
~keyboard~eventは、~text用の入力を提供する唯一の方式0である。
編集~時には、~keyboard~eventに対する代替（または それへの追加）として， `InputEvent$I の利用も考慮すること。
◎
Keyboard events are only one modality of providing textual input. For editing scenarios, consider also using the InputEvent as an alternate to (or in addition to) keyboard events.
</p>

			<section id="interface-keyboardevent">
<h4 title="Interface KeyboardEvent">4.6.1. ~ifc `KeyboardEvent^I</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`KeyboardEvent!I ~ifcは、~keyboard装置~特有の文脈的~情報を提供する。
各~keyboard~eventは、値を利用して~keyを参照する。
~keyboard~eventは、共通して，~focusを得ている要素へ向けられることが多い。
◎
The KeyboardEvent interface provides specific contextual information associated with keyboard devices. Each keyboard event references a key using a value. Keyboard events are commonly directed at the element that has the focus.
</p>

<p>
`KeyboardEvent$I ~ifcは、一部の共通的な修飾~keyのための簡便な属性：［
`ctrlKey$m,
`shiftKey$m,
`altKey$m,
`metaKey$m
］を提供する。
これらの属性【への取得~access】は、順に，［
`Control^cap,
`Shift^cap,
`Alt^cap,
`Meta^cap
］を引数に
`getModifierState()$m ~methodを利用するのと等価である。
`KeyboardEvent^I ~ifcの~instanceを作成するためには、その構築子に
`KeyboardEventInit$I 辞書（省略可）を渡して呼び出す。
◎
The KeyboardEvent interface provides convenient attributes for some common modifiers keys: ctrlKey, shiftKey, altKey, metaKey. These attributes are equivalent to using the method getModifierState() with Control, Shift, Alt, or Meta respectively. To create an instance of the KeyboardEvent interface, use the KeyboardEvent constructor, passing an optional KeyboardEventInit dictionary.
</p>

				<section id="idl-keyboardevent">
<h5>4.6.1.1. `KeyboardEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `KeyboardEventInit$I %eventInitDict)]
interface `KeyboardEvent@I : `UIEvent$I {
    // <span class="comment">`location$m 属性がとり得る定数</span>
    const unsigned long `DOM_KEY_LOCATION_STANDARD$m = 0x00;
    const unsigned long `DOM_KEY_LOCATION_LEFT$m = 0x01;
    const unsigned long `DOM_KEY_LOCATION_RIGHT$m = 0x02;
    const unsigned long `DOM_KEY_LOCATION_NUMPAD$m = 0x03;

    ~RA ~DS     `key$m;
    ~RA ~DS     `code$m;
    ~RA unsigned long `location$m;

    ~RA boolean       `ctrlKey$m;
    ~RA boolean       `shiftKey$m;
    ~RA boolean       `altKey$m;
    ~RA boolean       `metaKey$m;

    ~RA boolean       `repeat$m;
    ~RA boolean       `isComposing$m;

    boolean `getModifierState$m (~DS %keyArg);
};
</pre>


<dl class="idl-def">
	<dt>`DOM_KEY_LOCATION_STANDARD@m</dt>
	<dd>
作動化された~keyは、~keyの左／右 ~versionとして区別されるものではなく，かつ
十key（ `NumLock^cap ~keyは除く）, または それに対応する仮想~keyからも出生されていないことを指示する。
◎
The key activation MUST NOT be distinguished as the left or right version of the key, and (other than the NumLock key) did not originate from the numeric keypad (or did not originate with a virtual key corresponding to the numeric keypad).
</dd>
	<dd class="example">
<p>
~PC101US~keyboardの `Q^cap ~key。
◎
The Q key on a PC 101 Key US keyboard.
</p>
<p>
~PC101US~keyboardの
`NumLock^cap ~key。
◎
The NumLock key on a PC 101 Key US keyboard.
</p>
<p>
~PC101US~keyboardの主区画に所在する `1^cap ~key。
◎
The 1 key on a PC 101 Key US keyboard located in the main section of the keyboard.
</p>
	</dd>

	<dt>`DOM_KEY_LOCATION_LEFT@m</dt>
	<dd>
作動化された~keyは、左~key所在から出生されていることを指示する（当の~keyに対し複数の所在がある場合に限る）。
◎
The key activated originated from the left key location (when there is more than one possible location for this key).
</dd>
	<dd class="example">
~PC101US~keyboardの左 `Control^cap ~key。
◎
The left Control key on a PC 101 Key US keyboard.
</dd>

	<dt>`DOM_KEY_LOCATION_RIGHT@m</dt>
	<dd>
作動化された~keyは、右~key所在から出生されていることを指示する（当の~keyに対し複数の所在がある場合に限る）。
◎
The key activation originated from the right key location (when there is more than one possible location for this key).
</dd>
	<dd class="example">
~PC101US~keyboardの 右 `Shift^cap ~key。
◎
The right Shift key on a PC 101 Key US keyboard.
</dd>
	<dt>`DOM_KEY_LOCATION_NUMPAD@m</dt>
	<dd>
作動化された~keyは、十key, または それに 対応する仮想~keyから出生されていることを指示する（当の~keyに対し複数の所在がある場合に限る）。
`NumLock^cap ~keyは常に，所在 `DOM_KEY_LOCATION_STANDARD$m を伴って符号化される~SHOULDであることに注意。
◎
The key activation originated on the numeric keypad or with a virtual key corresponding to the numeric keypad (when there is more than one possible location for this key). Note that the NumLock key should always be encoded with a location of DOM_KEY_LOCATION_STANDARD.
</dd>
	<dd class="example">
~PC101US~keyboardの ~numpadに所在する `1^cap ~key。
◎
The 1 key on a PC 101 Key US keyboard located on the numeric pad.
</dd>

	<dt>`key@m</dt>
	<dd>
`key^m は押された~keyに対応する`~key値$<!-- ＊ -->を保持する。
◎
key, of type DOMString, readonly
• key holds a key attribute value corresponding to the key pressed.
</dd>
	<dd class="note">注記：
`key^m 属性は，旧来の `keyCode$m 属性には関係しない
— とり得る値の集合も同じでない。
◎
The key attribute is not related to the legacy keyCode attribute and does not have the same set of values.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>

	<dt>`code@m</dt>
	<dd>
`code^m は、押されている物理的~keyを識別する文字列を保持する。
値は，現在の~keyboard~layoutや修飾~状態からは影響されないので、同じ~keyからは常に同じ値が返されることになる。
◎
code, of type DOMString, readonly
◎
code holds a string that identifies the physical key being pressed. The value is not affected by the current keyboard layout or modifier state, so a particular key will always return the same value.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>

	<dt>`location@m</dt>
	<dd>
`location^m 属性は、装置~上の~keyの論理的な所在の指示を包含する。
◎
location, of type unsigned long, readonly
◎
The location attribute contains an indication of the logical location of the key on the device.
</dd>
	<dd>
この属性は、［
装置~上の~keyの所在を指示する，
`DOM_KEY_LOCATION-…^m 定数
］のうちの，いずれかに設定され~MUST。
◎
This attribute MUST be set to one of the DOM_KEY_LOCATION constants to indicate the location of a key on the device.
</dd>
	<dd>
~keyの再mapを許容する~UAは、再mapされた~keyに対する `location$m 値を，新たな~keyに適切な値に設定し~MUST。
例えば、 `ControlLeft$kC ~keyが `KeyQ$kC ~keyに再mapされたなら、この属性は
`DOM_KEY_LOCATION_STANDARD$m に設定され~MUST。
逆に， `KeyQ$kC ~keyが左右いずれかの `Control^cap ~keyに再mapされた場合、それに応じて，この属性も［
`DOM_KEY_LOCATION_LEFT$m, `DOM_KEY_LOCATION_RIGHT$m
］のいずれかに設定され~MUST。
◎
If a user agent allows keys to be remapped, then the location value for a remapped key MUST be set to a value which is appropriate for the new key. For example, if the "ControlLeft" key is mapped to the "KeyQ" key, then the location attribute MUST be set to DOM_KEY_LOCATION_STANDARD. Conversely, if the "KeyQ" key is remapped to one of the Control keys, then the location attribute MUST be set to either DOM_KEY_LOCATION_LEFT or DOM_KEY_LOCATION_RIGHT.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`ctrlKey@m</dt>
	<dd>
`Control^cap （ control ）修飾が作動中であったならば~T
◎
ctrlKey, of type boolean, readonly
◎
true if the Control (control) key modifier was active. 
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>`shiftKey@m</dt>
	<dd>
`Shift^cap （ shift ）修飾が作動中であったならば~T。
◎
shiftKey, of type boolean, readonly
◎
true if the shift (Shift) key modifier was active.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>`altKey@m</dt>
	<dd>
`Alt^cap （ alternative, 別名 `Option^cap ）修飾が作動中であったならば~T。
◎
altKey, of type boolean, readonly
◎
true if the Alt (alternative) (or "Option") key modifier was active.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>`metaKey@m</dt>
	<dd>
`Meta^cap（ meta ）修飾が作動中であったならば~T。
◎
metaKey, of type boolean, readonly
◎
true if the meta (Meta) key modifier was active.
</dd>
	<dd class="note">注記：
Macintosh ~system上の `Command^cap （ `⌘^cap ）~key修飾は
この~key修飾を利用して表現される。
◎
The "Command" ("⌘") key modifier on Macintosh systems is represented using this key modifier.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>`repeat@m</dt>
	<dd>
~keyが持続的に押されているならば~T。
~keyが~~押下げ続けられている下では、［
`keydown$et, `beforeinput$et, `input$et
］~eventが、この順序で，~system環境設定から決定される頻度で，繰り返され~MUST。
<em>~keyの長押し</em> に対する挙動を備える携帯機器においては、
`repeat$m 属性~値に ~T を伴う最初の~key~eventが，その挙動を指示する~~役割を果たさ~MUST。
繰り返しが始まるために~keyが押され続ける必要がある時間の長さは、環境設定に依存する。
◎
repeat, of type boolean, readonly
◎
true if the key has been pressed in a sustained manner. Holding down a key MUST result in the repeating the events keydown, beforeinput, input in this order, at a rate determined by the system configuration. For mobile devices which have long-key-press behavior, the first key event with a repeat attribute value of true MUST serve as an indication of a long-key-press. The length of time that the key MUST be pressed in order to begin repeating is configuration-dependent.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>`isComposing@m</dt>
	<dd>
~key~eventが組成~sessionの一部として
— すなわち， `compositionstart$et ~eventの後, かつ
対応する `compositionend$et ~eventの前に —
生じたならば~T。
◎
isComposing, of type boolean, readonly
◎
true if the key event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>`getModifierState(keyArg)@m</dt>
	<dd>
`~key値$を利用して，ある修飾の状態を照会する。
この~methodの引数がとり得る妥当な値（文字大小区別）については
<a href="#keys-modifiers">修飾~key</a>
を見よ。
◎
Queries the state of a modifier using a key value. See Modifier keys for a list of valid (case-sensitive) arguments to this method.
</dd>
	<dd>
<p>
引数 %keyArg は：
◎
DOMString keyArg
</p>

		<ul>
			<li>
修飾`~key値$。
妥当な修飾~keyは、 `UIEvents-Key$r の`修飾~key一覧$にて定義される。
◎
A modifier key value. Valid modifier keys are defined in the Modifier Keys table in [UIEvents-Key].
</li>
			<li>
%keyArg が［
修飾~keyである, かつ
その修飾が作動化されているならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if it is a modifier key and the modifier is activated, false otherwise.
</li>
		</ul>
	</dd>
	<dd class="note">注記：
~appが 右, 左の修飾を区別したいと望む場合、この情報は，
~keyboard~event, および
`KeyboardEvent.location$m
を利用して，推定することもできる。
◎
If an application wishes to distinguish between right and left modifiers, this information could be deduced using keyboard events and location.
</dd>

</dl>

				</section>
				<section id="idl-keyboardeventinit">
<h5>4.6.1.2. `KeyboardEventInit^I</h5>

<pre class="idl">
dictionary `KeyboardEventInit@I : `EventModifierInit$I {
    ~DS     `key@m = "";
    ~DS     `code@m = "";
    unsigned long `location@m = 0;
    boolean       `repeat@m = false;
    boolean       `isComposing@m = false;
};
</pre>


<p>
この辞書の各~memberは、
`KeyboardEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、その~ifc定義の記述を見よ。
◎
key, of type DOMString, defaulting to ""
• Initializes the key attribute of the KeyboardEvent object to the unicode character string representing the meaning of a key after taking into account all keyboard modifiers (such as shift-state). This value is the final effective value of the key. If the key is not a printable character, then it should be one of the key values defined in [UIEvents-Key].
◎
code, of type DOMString, defaulting to ""
• Initializes the code attribute of the KeyboardEvent object to the unicode character string representing the key that was pressed, ignoring any keyboard modifications such as keyboard layout. This value should be one of the code values defined in [UIEvents-Code].
◎
location, of type unsigned long, defaulting to 0
• Initializes the location attribute of the KeyboardEvent object to one of the following location numerical constants:
• DOM_KEY_LOCATION_STANDARD (numerical value 0)
• DOM_KEY_LOCATION_LEFT (numerical value 1)
• DOM_KEY_LOCATION_RIGHT (numerical value 2)
• DOM_KEY_LOCATION_NUMPAD (numerical value 3)
◎
repeat, of type boolean, defaulting to false
• Initializes the repeat attribute of the KeyboardEvent object. This attribute should be set to true if the the current KeyboardEvent is considered part of a repeating sequence of similar events caused by the long depression of any single key, false otherwise.
◎
isComposing, of type boolean, defaulting to false
• Initializes the isComposing attribute of the KeyboardEvent object. This attribute should be set to true if the event being constructed occurs as part of a composition sequence, false otherwise.
</p>

				</section>

<div class="warning">
<p>
旧来の~keyboard~event実装は 3 種の追加の属性［
`keyCode$m, `charCode$m, `which$m
］を含んでいる。
`keyCode^m 属性は、［
~computer~keyboardの特定0の~keyに結付けられている数的~値
］を指示する一方、
`charCode^m 属性は［
その~keyに結付けられている文字の~ASCII値
］を指示し（ `keyCode^m 値と同じにもなり得る），`文字~値$を生産する~keyのみに適用し得る。
◎
Legacy keyboard event implementations include three additional attributes, keyCode, charCode, and which. The keyCode attribute indicates a numeric value associated with a particular key on a computer keyboard, while the charCode attribute indicates the ASCII value of the character associated with that key (which might be the same as the keyCode value) and is applicable only to keys that produce a character value.
</p>

<p>
実施においては、 `keyCode^m, `charCode^m は、~platform間で, あるいは
同じ実装ですら 種々の ~OS／地域化~間で，一貫してない。
この仕様は
`keyCode^m や `charCode^m の値も, `charCode^m の挙動も定義しない。
適合~UI~Events実装においては、内容~作者は，
`KeyboardEvent.key$m, `KeyboardEvent.code$m
を利用できる。
◎
In practice, keyCode and charCode are inconsistent across platforms and even the same implementation on different operating systems or using different localizations. This specification does not define values for either keyCode or charCode, or behavior for charCode. In conforming UI Events implementations, content authors can instead use key and code.
</p>


<p><em>
更なる情報は、参考~付録
<a href="~UIEVENTS-A#legacy-key-attributes">旧来の~key属性</a>
を見よ。
</em>

◎
For more information, see the informative appendix on Legacy key attributes.
</p>
</div>


<p class="note">注記：
既存の内容との互換性のため，仮想~keyboard
— ~screenに基づく入力~装置~上の~software~keyboardなど —
は、物理的~keyを処理しなくとも，通常の範囲の~keyboard~eventを生産するものと期待されている。
◎
For compatibility with existing content, virtual keyboards, such as software keyboards on screen-based input devices, are expected to produce the normal range of keyboard events, even though they do not possess physical keys.
</p>

<p class="note">注記：
一部の実装／~system環境設定においては、一部の~key~eventやその値は，利用中の`~IME$により抑止されることがある。
◎
In some implementations or system configurations, some key events, or their values, might be suppressed by the IME in use.
</p>

			</section>
			<section id="events-keyboard-key-location">
<h4 title="Keyboard Event Key Location">4.6.2. ~keyboard~eventに対する~keyの所在</h4>

<!-- `KeyboardEvent!I -->

<p>
`location$m 属性は、~keyboard上の異なる物理的~keyから同じ`~key値$が生成される場合に、それらを~~区別するために利用できる。
例えば、左右 `Shift^cap ~key，あるいは
物理的~矢印~keyと（ `NumLock^cap が off のときの）~numpad上の矢印~key。
◎
The location attribute can be used to disambiguate between key values that can be generated by different physical keys on the keyboard, for example, the left and right Shift key or the physical arrow keys vs. the numpad arrow keys (when NumLock is off). The following table defines the valid location values for the special keys that have more than one location on the keyboard:
</p>

<p>
~keyboard上に所在が複数あるような特別な~keyに対する，妥当な `location$m 値は、次の表に定義される：
◎
↑</p>


<table class="event-sequence-table">
<thead><tr><th>`key$m 値◎KeyboardEvent . key
<th>妥当な `location$m 値◎Valid location values
</thead>

<tbody><tr><td>
`Shift$kY, `Control$kY, `Alt$kY, `Meta$kY
<td>
`DOM_KEY_LOCATION_LEFT$m,
`DOM_KEY_LOCATION_RIGHT$m

<tr><td>
`ArrowDown$kY, `ArrowLeft$kY, `ArrowRight$kY, `ArrowUp$kY
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

<tr><td>
`End$kY, `Home$kY, `PageDown$kY, `PageUp$kY
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

<tr><td>
`0^kY, `1^kY, `2^kY, `3^kY,
`4^kY, `5^kY, `6^kY, `7^kY,
`8^kY, `9^kY, `.^kY, `Enter$kY,
`+^kY, `-^kY, `*^kY, `/^kY,
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

</tbody></table>

<p>
この表に挙げられていない他のすべての~keyに対する
`location$m 属性は、常に
`DOM_KEY_LOCATION_STANDARD$m に設定され~MUST。
◎
For all other keys not listed in this table, the location attribute MUST always be set to DOM_KEY_LOCATION_STANDARD. 
</p>

			</section>
			<section id="events-keyboard-event-order">
<h4 title="Keyboard Event Order">4.6.3. ~keyboard~event序列</h4>

<p>
この仕様にて定義される~keyboard~eventは、与えられたどの~keyに対しても，相互相対順序の下で生じる：
◎
The keyboard events defined in this specification occur in a set order relative to one another, for any given key:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>

<tr><td>2.
<td>`beforeinput$et
<td><em>
（`文字~値$を生産する~keyに対してのみ）
</em>
◎
(only for keys which produce a character value)

<tr><td>
<td>
<td><em>
この~keyに関係する`既定~動作$
— 文字を~DOMの中へ挿入するなど —
があれば，それが行われる。
</em>
◎
Any default actions related to this key, such as inserting a character in to the DOM.

<tr><td>3.
<td>`input$et
<td><em>
（~DOMを更新させた~keyに対してのみ）
</em>
◎
(only for keys which have updated the DOM)

<tr><td>
<td>
<td><em>
一定時間，~keyが押下げられるとき、生じ得るような~event（下を見よ）。
</em>
◎
Any events as a result of the key being held for a sustained period (see below).

<tr><td>4.
<td>`keyup$et
<td>
</tbody></table>


<p>
一定時間，~keyが押下げられた場合、環境に依存する頻度で，次の~eventが繰り返されることもある：
◎
If the key is depressed for a sustained period, the following events MAY repeat at an environment-dependent rate:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td><em>
（ `KeyboardEvent.repeat$m 属性は ~T に設定される）
</em>
◎
(with repeat attribute set to true)

<tr><td>2.
<td>`beforeinput$et
<td><em>
（`文字~値$を生産した~keyに対してのみ）
</em>
◎
(only for keys which produce a character value)

<tr><td>
<td>
<td><em>
<!-- copy -->
この~keyに関係する`既定~動作$
— 文字を~DOMの中へ挿入するなど —
があれば，それが行われる。
</em>
◎
Any default actions related to this key, such as inserting a character in to the DOM.

<tr><td>3.
<td>`input$et
<td><em>
<!-- copy -->
（~DOMを更新させた~keyに対してのみ）
</em>
◎
(only for keys which have updated the DOM)
</tbody></table>

<p class="note">注記：
概して、特定0の~keyに結付けられている`既定~動作$があれば， `keyup$et ~eventが発火される前に完了する。
これは
`keyup$et ~eventを少しばかり遅延し得る（おそらく，知覚される程の遅延にはならないであろうが）。
◎
Typically, any default actions associated with any particular key are completed before the keyup event is dispatched. This might delay the keyup event slightly (though this is not likely to be a perceptible delay).
</p>

<p>
~key~eventの`標的$は、~keyboard活動を処理している現在の被focus要素である。
これは、 HTML `input^e 要素か，編集可能な~text用の要素になることが多いが、`~host言語$における非~text目的0の
— 加速~keyの作動化や 一部の他の挙動の誘発などの —
~keyboard入力を受容するように定義された要素になることもある。
相応しい被focus要素が無い場合の~event標的は、可用なら HTML `~body要素$，他の場合 `根~要素$になる。
◎
The event target of a key event is the currently focused element which is processing the keyboard activity. This is often an HTML input element or a textual element which is editable, but MAY be an element defined by the host language to accept keyboard input for non-text purposes, such as the activation of an accelerator key or trigger of some other behavior. If no suitable element is in focus, the event target will be the HTML body element if available, otherwise the root element.
</p>

<p class="note">注記：
`~event標的$は、一連の~key~event間で変化し得る。
例えば， `Tab^cap ~keyに対する `keydown$et ~eventの`標的$は、同じ~keystrokeに対する `keyup$et ~eventから異なるであろう。
◎
The event target might change between different key events. For example, a keydown event for the Tab key will likely have a different event target than the keyup event on the same keystroke.
</p>
			</section>
			<section id="events-keyboard-types">
<h4>4.6.4. 各種~keyboard~event型</h4>


				<section id="event-type-keydown">
<h5>4.6.4.1. `keydown^et</h5>

`●型^ `keydown@et
`●界面^ `KeyboardEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^
<p>
文脈依存：
</p>

<ul><li>`beforeinput$et ＆ `input$et ~event
</li><li>`~text組成~system$を起動0させる
</li><li>`blur$et ＆ `focus$et ~event
</li><li>`keypress$et ~event（~support有りなら）
</li><li>`作動化の挙動$
</li><li>その他の~event
</li></ul>
◎
Varies: beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other event
`●文脈^

`各種~keyboard~eventに共通する文脈~情報$にて与えられる。
◎
• Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
• UIEvent.view : Window
• UIEvent.detail : 0
• KeyboardEvent.key : the key value of the key pressed.
• KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
• KeyboardEvent.location : the location of the key on the device.
• KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
• KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
• KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
• KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
• KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
• KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false

`●表終^

<p>
~UAは、［
~keyが押された
］とき，この~eventを発火し~MUST。
`keydown$et ~event型は装置~依存であり，
入力~装置の能力, および
それらが~OSにおいて~mapされている方法に依拠する。
この~event型は，`~key~mapping$の後に生成され~MUST。
この~event型は、同じ~keyに結付けられている［
`beforeinput$et, `input$et, `keyup$et
］~eventの前に配送され~MUST。
◎
A user agent MUST dispatch this event when a key is pressed down. The keydown event type is device dependent and relies on the capabilities of the input devices and how they are mapped in the operating system. This event type MUST be generated after the key mapping. This event type MUST be dispatched before the beforeinput, input, and keyup events associated with the same key.
</p>

<p>
`keydown$et
~eventの既定~動作は，~keyに依存する：
◎
The default action of the keydown event depends upon the key:
</p>

<ul>
	<li>
~keyが文字に結付けられている場合の既定~動作は、［
`beforeinput$et ~eventと, ~~後続する `input$et ~event
］を発火するもので~MUST。
~keyが複数の文字に結付けられている場合（~macroを伴うものや ~dead-keyからなる連列など）の既定~動作は、各~文字に対し［
`beforeinput$et, `input$et
］~event対を発火するもので~MUST。
◎
If the key is associated with a character, the default action MUST be to dispatch a beforeinput event followed by an input event. In the case where the key which is associated with multiple characters (such as with a macro or certain sequences of dead keys), the default action MUST be to dispatch one set of beforeinput / input events for each character
</li>
	<li>
~keyが`~text組成~system$に結付けられている場合の既定~動作は、その~systemを起動0させるもので~MUST。
◎
If the key is associated with a text composition system, the default action MUST be to launch that system
</li>
	<li>
~keyが `Tab^cap ~keyの場合の既定~動作は、`~focus~event$型にて述べた様に、文書~focusを現在の被focus要素（もしあれば）から新たな被focus要素へ移転させるもので~MUST。
◎
If the key is the Tab key, the default action MUST be to shift the document focus from the currently focused element (if any) to the new focused element, as described in Focus Event Types
</li>
	<li>
~keyが `Enter^cap ／ `~SPACEBAR^cap ~keyであって, かつ
現在の~focusが状態~変化~中の要素~上にある場合の既定~動作は、［
`click$et ~eventに加えて，~UAにより~supportされているなら `DOMActivate$et ~event
］を発火するもので~MUST
（詳細は、`作動化の誘発と挙動$に）
◎
If the key is the 'Enter' or ' ' key and the current focus is on a state-changing element, the default action MUST be to dispatch a click event, and a DOMActivate event if that event type is supported by the user agent (refer to §3.5 Activation triggers and behavior for more details)
</li>
</ul>

<p>
この~eventが取消された場合、結付けられている~event型は，発火されては~MUST_NOT。
また、結付けられている動作も，遂行されては~MUST_NOT。
◎
If this event is canceled, the associated event types MUST NOT be dispatched, and the associated actions MUST NOT be performed.
</p>

<p class="note">注記：
`keydown$et ／ `keyup$et
~eventは、伝統的に，`文字~値$を生産するものだけでなく，何か~keyが~~押されたかどうかの検出-法にも結付けられている。
◎
The keydown and keyup events are traditionally associated with detecting any key, not just those which produce a character value.
</p>




				</section>
				<section id="event-type-keyup">
<h5>4.6.4.2. `keyup^et</h5>

`●型^ `keyup@et
`●界面^ `KeyboardEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^ なし
`●文脈^
`各種~keyboard~eventに共通する文脈~情報$にて与えられる。
◎
• Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
• UIEvent.view : Window
• UIEvent.detail : 0
• KeyboardEvent.key : the key value of the key pressed.
• KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
• KeyboardEvent.location : the location of the key on the device.
• KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
• KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
• KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
• KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
• KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
• KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false


`●表終^

<p>
~UAは、［
~keyが離された
］とき，この~eventを発火し~MUST。
`keyup$et ~event型は装置~依存であり，
入力~装置の能力, および
それらが~OSにおいて~mapされている方法
に依拠する。
この~event型は，`~key~mapping$の後に生成され~MUST。
この~event型は、
同じ~keyに結付けられている［
`keydown$et,
`beforeinput$et,
`input$et
］~eventの後に発火され~MUST。
◎
A user agent MUST dispatch this event when a key is released. The keyup event type is device dependent and relies on the capabilities of the input devices and how they are mapped in the operating system. This event type MUST be generated after the key mapping. This event type MUST be dispatched after the keydown, beforeinput, and input events associated with the same key.
</p>

<p class="note">注記：
<!-- copy -->
`keydown$et ／ `keyup$et
~eventは、伝統的に，`文字~値$を生産するものだけでなく，何か~keyが~~押されたかどうかの検出-法にも結付けられている。
◎
The keydown and keyup events are traditionally associated with detecting any key, not just those which produce a character value.
</p>

				</section>
			</section>
			<section id="_common-keyboard-event-context">
<h4>各種~keyboard~eventに共通する文脈~情報</h4>

集約簡略化

<p>
~keyboard~eventに共通する文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
~key~eventを処理している被focus要素。
被focus要素がない場合、可用ならば`~body要素$ ／
他の場合 `根~要素$
◎
Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通する文脈~情報$にて与えられる。
</dd>

	<dt>`KeyboardEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`key$m</dt>
			<dd>
押された~keyの`~key値$。
◎
KeyboardEvent.key : the key value of the key pressed.
</dd>
			<dt>`code$m</dt>
			<dd>
~keyの~keyboard上での物理的~~位置に結付けられている~code値
◎
KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
</dd>
			<dt>`location$m</dt>
			<dd>
装置~上の~keyの所在。
◎
KeyboardEvent.location : the location of the key on the device.
</dd>
			<dt>`altKey$m</dt>
			<dd>
`Alt^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
</dd>
			<dt>`shiftKey$m</dt>
			<dd>
`Shift^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
</dd>
			<dt>`ctrlKey$m</dt>
			<dd>
`Control^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
</dd>
			<dt>`metaKey$m</dt>
			<dd>
`Meta^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
</dd>
			<dt>`repeat$m</dt>
			<dd>
~keyの繰返しを誘発するに十分~長く~keyが押下げられているならば ~T ／
他の場合 ~F
◎
KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
</dd>
			<dt>`isComposing$m</dt>
			<dd>
~key~eventが，組成~sessionの一部として生じたならば ~T ／
他の場合 ~F
◎
KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</dd>
		</dl>
	</dd>
</dl>


			</section>
		</section>
		<section id="events-compositionevents">
<h3 title="Composition Events">4.7. 組成~event</h3>

<div>
<p>
組成~event（ Composition Events ）は、~~普通の~keyboardにない文字を利用できるように，`~keyboard~event$によるものに追補的な, あるいは代替による方式で，~textを入力する手段を提供する。
組成~eventは、例えば，次のために利用され得る：
</p>

<ul><li>文字に標準的な~US~keyboardには無い~accentを追加する。
</li><li>多くのアジア圏の言語において，基底~成分／字種から表語文字を築き上げる。
</li><li>携帯機器~keyboardで，押されている~keyの組合せから 単語を選択する。
</li><li>発話~認識~processorを利用して，一連の~voice~commandを~textに変換する。
</li></ul>

<p>
`組成~event$を~keyboard~eventと組合せる用例については、`~keyboard~eventと~key値$ 節に。
</p>

◎
Composition Events provide a means for inputing text in a supplementary or alternate manner than by Keyboard Events, in order to allow the use of characters that might not be commonly available on keyboard. For example, Composition Events might be used to add accents to characters despite their absence from standard US keyboards, to build up logograms of many Asian languages from their base components or categories, to select word choices from a combination of key presses on a mobile device keyboard, or to convert voice commands into text using a speech recognition processor. Refer to §5 Keyboard events and key values for examples on how Composition Events are used in combination with keyboard events.
</div>

<p>
概念的には、組成~sessionは，［
1 個の
`compositionstart$et ~event,
1 個【 0 個？】以上の
`compositionupdate$et ~event,
1 個の `compositionend$et
~event
］からなり、それらの~eventの
`CompositionEvent.data$m 属性の値は，
各~sessionの最中のこの~event連鎖【伝播~経路？】の各 “stage” 間で persisting【？】。
◎
Conceptually, a composition session consists of one compositionstart event, one or more compositionupdate events, and one compositionend event, with the value of the data attribute persisting between each "stage" of this event chain during each session.
</p>

<p class="note">注記：
組成~sessionで利用されている入力~装置が~keyboardである場合、
組成~sessionが作動中にある間の~keyboard~eventは，~DOMへ発火され得る。
関連する~eventたちの順序付けについては、
`compositionstart$et の詳細,
<a href="#keys-IME">~IME節</a>
を見よ。
◎
Note: While a composition session is active, keyboard events can be dispatched to the DOM if the keyboard is the input device used with the composition session. See the compositionstart event details and IME section for relevent event ordering.
</p>

<p>
`~IME$~system／装置は，~DOMに必要とされる~dataを公開するとは限らないので、
作動中の組成~文字列（
“変換窓（ Reading Window ）” や
“候補~選択~menuに示されるもの”
）は，この~ifcを通して可用でないこともある
— その場合、選択は`空~文字列$として表現されることもある。
◎
Not all IME systems or devices expose the necessary data to the DOM, so the active composition string (the "Reading Window" or "candidate selection menu option") might not be available through this interface, in which case the selection MAY be represented by the empty string.
</p>

			<section id="interface-compositionevent">
<h4 title="Interface CompositionEvent">4.7.1. ~ifc `CompositionEvent^I</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`CompositionEvent^I ~ifcは、`組成~event$特有の文脈的~情報を提供する。
◎
The CompositionEvent interface provides specific contextual information associated with Composition Events.
</p>

<p>
`CompositionEvent^I ~ifcの~instanceを作成するためには、その構築子に
`CompositionEventInit^I 辞書（省略可）を渡して呼び出す。
◎
To create an instance of the CompositionEvent interface, use the CompositionEvent constructor, passing an optional CompositionEventInit dictionary.
</p>

				<section id="idl-compositionevent">
<h5>4.7.1.1. `CompositionEvent^I</h5>

<pre class="idl">
[Constructor(~DS %type, optional `CompositionEventInit$I %eventInitDict)]
interface `CompositionEvent@I : `UIEvent$I {
    ~RA ~DS `data$m;
};
</pre>


<dl class="idl-def">
	<dt>`data@m</dt>
	<dd>
`data^c は~IMEにより生成された一連の`文字~値$を保持する。
これは、長さ 1 以上の~Unicode文字~連列をとることもある。
一連の文字は、 `UAX15$r にて定義される~Unicode正規化形
<em>NFC</em> による定義に従って正規化される~SHOULDである。
この属性は、`空~文字列$になることもある。
◎
data, of type DOMString, readonly
◎
data holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY be the empty string.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>
</dl>

				</section>
				<section id="idl-compositioneventinit">
<h5>4.7.1.2. `CompositionEventInit^I</h5>

<pre class="idl">
dictionary `CompositionEventInit@I : `UIEventInit$I {
    ~DS `data@m = "";
};
</pre>


<p>
この辞書の各~memberは、
`CompositionEvent!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、その~ifc定義の記述を見よ。
◎
data, of type DOMString, defaulting to ""
• Initializes the data attribute of the CompositionEvent object to the characters generated by the IME composition.
</p>

				</section>
			</section>
			<section id="events-composition-order">
<h4 title="Composition Event Order">4.7.2. 組成~event序列</h4>

<p>
この仕様にて定義される`組成~event$は、次による相互相対順序の下で生じ~MUST：
◎
The Composition Events defined in this specification MUST occur in the following set order relative to one another:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`compositionstart$et
<td>

<tr><td>2.
<td>`compositionupdate$et
<td>複数回 生じ得る◎Multiple events

<tr><td>3.
<td>`compositionend$et
<td>
</tbody></table>
			</section>
			<section id="events-composition-handwriting">
<h4 title="Handwriting Recognition Systems">4.7.3. 手書き認識~system</h4>
<p>
次の例に、［
~pen~tabletなどの手書き認識~systemの下で，一節の~text "text" を組成する
］ときに生じ得る~event連列を，`組成~event$の~modelを利用して述べる。
◎
The following example describes a possible sequence of events when composing a text passage text with a handwriting recognition system, such as on a pen tablet, as modeled using Composition Events.
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`CompositionEvent.data$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`compositionstart$et
<td>`^kGl
<td>

<tr><td>
<td>
<td>
<td><em>
利用者が~tablet表面に単語を書いた
</em>
◎
User writes word on tablet surface

<tr><td>2.
<td>`compositionupdate$et
<td>`test^kGl
<td>

<tr><td>
<td>
<td>
<td><em>
利用者が~~候補として最初に挙げられた単語を却下して，異なる~~候補を選択した
</em>
◎
User rejects first word-match suggestion, selects different match

<tr><td>3.
<td>`compositionupdate$et
<td>`text^kGl
<td>

<tr><td>4.
<td>`compositionend$et
<td>`text^kGl
<td>
</tbody></table>
			</section>
			<section id="events-composition-canceling">
<h4 title="Canceling Composition Events">4.7.4. 組成~eventの取消し</h4>
<p>
`keydown$et ~eventが取消された場合、その `keydown$et の結果として発火されることになる
どの`組成~event$も，発火される~SHOULDでない：
◎
If a keydown event is canceled then any Composition Events that would have fired as a result of that keydown SHOULD not be dispatched:
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>
`既定~動作$は、例えば `preventDefault()$m の呼出しにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td><em>
`組成~event$は発火されない。
</em>
◎
No Composition Events are dispatched

<tr><td>2.
<td>`keyup$et
<td>
</tbody></table>

<p>
初期 `compositionstart$et ~eventが取消された場合、~text組成~sessionは，終了される~SHOULDである。
`compositionend$et ~eventは、
組成~sessionが終了されたかどうかに関わらず，
送信され~MUST。
◎
If the initial compositionstart event is canceled then the text composition session SHOULD be terminated. Regardless of whether or not the composition session is terminated, the compositionend event MUST be sent.
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>

<tr><td>2.
<td>`compositionstart$et
<td>
<!-- copy -->
`既定~動作$は、例えば `preventDefault()$m の呼出しにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td><em>
<!-- copy -->
`組成~event$は発火されない。
</em>
◎
No Composition Events are dispatched

<tr><td>3.
<td>`compositionend$et
<td>

<tr><td>4.
<td>`keyup$et
<td>
</tbody></table>
			</section>
			<section id="events-composition-key-events">
<h4 title="Key Events During Composition">4.7.5. 組成~時における~key~event</h4>

<p>
組成~sessionの最中でも、依然として［
`keydown$et, `keyup$et
］~eventは送信され~MUST
— その `KeyboardEvent.isComposing$m 属性は ~T にされ~MUST。
◎
During the composition session, keydown and keyup events MUST still be sent, and these events MUST have the isComposing attribute set to true.
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`KeyboardEvent.isComposing$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>~F
<td>
これが組成を起動させた~key~eventである。
◎
This is the key event that initiates the composition.
<tr><td>2.
<td>`compositionstart$et
<td>
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>

<tr><td>4.
<td>`keyup$et
<td>~T
<td>

<tr><td>
<td>...
<td>
<td>
組成~sessionの最中に送信された どの~key~eventも，
`KeyboardEvent.isComposing$m は ~T に設定され~MUST。
◎
Any key events sent during the composition session MUST have isComposing set to true.
<tr><td>5.
<td>`keydown$et
<td>~T
<td>
これが組成を終わらせた~key~eventである。
◎
This is the key event that exits the composition.
<tr><td>6.
<td>`compositionend$et
<td>
<td>

<tr><td>7.
<td>`keyup$et
<td>~F
<td>
</tbody></table>


			</section>
			<section id="events-composition-input-events">
<h4 title="Input Events During Composition">4.7.6. 組成~sessionの間の入力~event</h4>

<p>
組成~sessionの間は、その `compositionupdate$et は，
`beforeinput$et が送信された後, かつ
`input$et が送信される前に発火され~MUST。
◎
During the composition session, the compositionupdate MUST be dispatched after the beforeinput is sent, but before the input event is sent.
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr><td>1.
<td>`beforeinput$et
<td>

<tr><td>2.
<td>`compositionupdate$et
<td>

<tr><td>
<td>
<td><em>
~DOMの更新はこの時点で生じる。
</em>
◎
Any DOM updates occur at this point.

<tr><td>3.
<td>`input$et
<td>

</table>

<p class="note">注記：
大部分の~IMEは、組成~sessionの間における更新の取消しは~supportしない。
◎
Most IMEs do not support canceling updates during a composition session.
</p>

<p>
`beforeinput$et ／ `input$et ~eventは、組成の一部として~DOMが更新されるときに，
`compositionupdate$et ~eventに伴って送信される。
`compositionend$et ~eventに対しては，~DOMの更新はないので、
`beforeinput$et ／ `input$et
~eventは送信されるべきではない。
◎
The beforeinput and input events are sent along with the compositionupdate event whenever the DOM is updated as part of the composition. Since there are no DOM updates associated with the compositionend event, beforeinput and input events should not be sent at that time.
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>備考
</thead>

<tbody><tr>
<td>1.
<td>`beforeinput$et
<td>
これの取消しは ~DOM更新と `input$et ~eventを防止することになる。
◎
Canceling this will prevent the DOM update and the input event.

<tr><td>2.
<td>`compositionupdate$et
<td>

<tr><td>
<td>
<td><em>
~DOMの更新はこの時点で生じる。
</em>
◎
Any DOM updates occur at this point.

<tr><td>3.
<td>`input$et
<td><em>
~DOMが更新された場合に限り送信される。
</em>
◎
Sent only if the DOM was updated.

<tr><td>4.
<td>`compositionend$et
<td>

</table>


			</section>
			<section id="events-composition-types">
<h4 title="Composition Event Types">4.7.7. 各種~組成~event型</h4>


				<section id="event-type-compositionstart">
<h5>4.7.7.1. `compositionstart^et</h5>

`●型^ `compositionstart@et
`●界面^ `CompositionEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 可
`●構^ Yes
`●既定動作^
`~text組成~system$が可能化されているならば，新たな組成~sessionを開始する。
◎
Start a new composition session when a text composition system is enabled
`●文脈^
<p>
次を除き，`各種~組成~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`CompositionEvent.data$m：
編集-中の<!-- ＊元の -->文字列, または
`空~文字列$
</li></ul>
◎
• Event.target : focused element processing the composition
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the original string being edited, otherwise the empty string

`●表終^

<p>
~UAは、`~text組成~system$が可能化されている下で，［
~textの一節を組成する準備として，新たな組成~sessionが始まりつつある（または，`~text組成~system$に依存して始まった）
］とき，この~eventを発火し~MUST。
この~event型は、装置に依存し，［
~text変換~systemの能力,
~OSに~mapされる方法
］に依拠することもある。
この~event型は、~IMEへの~~入力が~keyboardから給される場合は，
`keydown$et ~eventの後に生成されるが、［
発話／手書き
］認識~systemにおいては
~keyboard~eventを伴わずに送信されて~MAY。
実装は、 `compositionstart$et ~eventの `CompositionEvent.data$m 属性を，文書にて現在（編集／~~置換のために）選択されている~textで拡充しても~MAY
— そうしない場合、`空~文字列$にし~MUST。
◎
A user agent MUST dispatch this event when a text composition system is enabled and a new composition session is about to begin (or has begun, depending on the text composition system) in preparation for composing a passage of text. This event type is device-dependent, and MAY rely upon the capabilities of the text conversion system and how it is mapped into the operating system. When a keyboard is used to feed an input method editor, this event type is generated after a keydown event, but speech or handwriting recognition systems MAY send this event type without keyboard events. Some implementations MAY populate the data attribute of the compositionstart event with the text currently selected in the document (for editing and replacement). Otherwise, the value of the data attribute MUST be the empty string.
</p>

<p>
この~eventは、`~text組成~system$が新たな組成~sessionを始める直前に, かつ
組成~処理により~DOMが改変される前に，発火され~MUST。
この~eventの，`~text組成~system$に対する既定~動作は、新たな組成~sessionを開始させる。
この~eventが取消された場合、`~text組成~system$は，現在の組成~sessionを破棄する~SHOULDである。
◎
This event MUST be dispatched immediately before a text composition system begins a new composition session, and before the DOM is modified due to the composition process. The default action of this event is for the text composition system to start a new composition session. If this event is canceled, the text composition system SHOULD discard the current composition session.
</p>

<p class="note">注記：
`compositionstart$et ~eventを取消すことと，`~text組成~system$自身を取消すこと（例： 取消-~buttonを~~叩いたり, `~IME$~windowを~~閉じるなど）とは、別物である。
◎
Canceling the compositionstart event type is distinct from canceling the text composition system itself (e.g., by hitting a cancel button or closing an IME window).
</p>

<p class="note">注記：
~IMEには、進捗~中の組成~sessionの取消-を~supportしないものもある（例： GTK などは，~~現時点ではそのような~APIを備えていない）。
そのような事例では、
`preventDefault()$m を~callしても，この~eventの既定~動作は停止されないことになる。
◎
Some IMEs do not support cancelling an in-progress composition session (e.g., such as GTK which doesn’t presently have such an API). In these cases, calling preventDefault will not stop this event’s default action.
</p>




				</section>
				<section id="event-type-compositionupdate">
<h5>4.7.7.2. `compositionupdate^et</h5>

`●型^ `compositionupdate@et
`●界面^ `CompositionEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~組成~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`CompositionEvent.data$m：
組成~sessionの現在の結果を成す文字列。
内容が削除された場合には`空~文字列$になることもある。
</li></ul>
◎
• Event.target : focused element processing the composition, null if not accessible
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the string comprising the current results of the composition session, which MAY be the empty string if the content has been deleted

`●表終^

<p>
~UAは、［
組成~sessionの最中に，`~text組成~system$が その作動中の~text一節を新たな文字で更新するとき
］に，この~eventを発火する~SHOULDである。
また、配送するときは， `CompositionEvent.data$m 値にその更新を反映させ~MUST。
◎
A user agent SHOULD dispatch this event during a composition session when a text composition system updates its active text passage with a new character, which is reflected in the string in data.
</p>

<p>
［
進行中の組成と入力~controlとの同期を保つ
］ような `~text組成~system$においては、
`compositionupdate$et ~eventは，その~controlが更新される前に配送され~MUST。
◎
In text composition systems which keep the ongoing composition in sync with the input control, the compositionupdate event MUST be dispatched before the control is updated.
</p>

<p>
`~text組成~system$には、この情報を~DOMに公開しないものもある
— その場合、この~eventは，組成~処理の最中には発火されないことになる。
◎
Some text composition systems might not expose this information to the DOM, in which case this event will not fire during the composition process.
</p>

<p>
組成~sessionが取消された場合、この~eventは， `compositionend$et ~eventの直前に、その `CompositionEvent.data$m 属性を`空~文字列$に設定した上で，発火されることになる。
◎
If the composition session is canceled, this event will be fired immediately before the compositionend event, and the data attribute will be set to the empty string.
</p>




				</section>
				<section id="event-type-compositionend">
<h5>4.7.7.3. `compositionend^et</h5>

`●型^ `compositionend@et
`●界面^ `CompositionEvent$I
`●同期^ あり
`●浮上^ する
`●標的^ `Element$I
`●取消^ 不可
`●構^ Yes
`●既定動作^ なし
`●文脈^
<p>
次を除き，`各種~組成~eventに共通する文脈~情報$にて与えられる：
</p>

<ul><li>`CompositionEvent.data$m：
組成~sessionの最終的な結果を成す文字列。
内容が削除されたり, 組成~処理が取消された場合など、`空~文字列$になることもある。
</li></ul>
◎
• Event.target : focused element processing the composition
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the string comprising the final result of the composition session, which MAY be the empty string if the content has been deleted or if the composition process has been canceled

`●表終^

<p>
~UAは、［
`~text組成~system$が
現在の組成~sessionを
完了した, または取消された
］とき，この~eventを発火し~MUST。
この~eventは、~controlが更新された後に配送され~MUST。
◎
A user agent MUST dispatch this event when a text composition system completes or cancels the current composition session, and the compositionend event MUST be dispatched after the control is updated.
</p>

<p>
この~eventは、`~text組成~system$が組成~sessionを完了した直後に配送される（例： `~IME$が［
閉じられた ／
最小化された ／
~focusが他へ切替えられた ／
その他~退けられた
］後に，~focusが~~元の~UAに切替わったときなど）。
◎
This event is dispatched immediately after the text composition system completes the composition session (e.g., the IME is closed, minimized, switched out of focus, or otherwise dismissed, and the focus switched back to the user agent).
</p>

				</section>
			</section>
			<section id="_common-composition-event-context">
<h4>各種~組成~eventに共通する文脈~情報</h4>

集約簡略化

<p>
多くの組成~eventに共通する文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
組成を処理している被focus要素。
~access可能でないならば~NULL。
◎
Event.target : focused element processing the composition, null if not accessible
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通する文脈~情報$にて与えられる。
</dd>
</dl>


			</section>
		</section>
	</section>
	<section id="keys">

<h2 title="Keyboard events and key values">5. ~keyboard~eventと~key値</h2>

<!-- 
`KeyboardEvent!I
-->

<p>
この節では、~keyboard~eventに関して必要とされる情報を包含する：
◎
This section contains necessary information regarding keyboard events:
</p>

<ul>
	<li>
~keyboard~layout,
~mapping,
`~key値$
についての説明。
◎
Explanation of keyboard layout, mapping, and key values.
</li>
	<li>
`~dead-key$や修飾~keyなどの、~key間の関係。
◎
Relations between keys, such as dead keys or modifiers keys.
</li>
	<li>
~keyboard~eventとその既定~動作との関係。
◎
Relations between keyboard events and their default actions.
</li>
	<li>
`key^m 値の集合, および
この集合を拡張する方法についての指針。
◎
The set of key values, and guidelines on how to extend this set.
</li>
</ul>

<p class="note">注記：
この節では、~Serbianと漢字を利用する。
<!-- 
この仕様の PDF 版／印刷~時に
misrepresentされたり可用でないこともある。
-->
◎
This section uses Serbian and Kanji characters which could be misrepresented or unavailable in the PDF version or printed version of this specification.
</p>

		<section id="keyboard-input">
<h3 title="Keyboard Input">5.1. ~keyboard入力</h3>

~INFORMATIVE

<p>
完全な~keyboardの各~keyの関係性には，三つの別々の側面があり、いずれも，特に ~locale特有の理由で，~keyboard機種や環境設定によって様々になる：
◎
The relationship of each key to the complete keyboard has three separate aspects, each of which vary among different models and configurations of keyboards, particularly for locale-specific reasons:
</p>

<ul>
	<li>
<strong>物理的0~layout</strong>：
~keyboard上での物理的~keyの
寸法, ~size, ~~配置
◎
Mechanical layout: the dimensions, size, and placement of the physical keys on the keyboard
</li>
	<li>
<strong>視覚的~目印</strong>：
各~keyを印字する~label（または <em>銘（ legend ）</em>）
◎
Visual markings: the labels (or legends) that mark each key
</li>
	<li>
<strong>機能上の~mapping</strong>：
各~keyに対する 抽象的な ~key ↔ 値の結付け。
◎
Functional mapping: the abstract key-value association of each key.
</li>
</ul>

<p>
この仕様は、
<a href="#keys-keyvalues">`key^m 値</a>
および
<a href="#keys-codevalues">`code^m 値</a>
を通して，機能上の~mappingのみを定義するが、背景として，
<a href="#key-legends">~key銘</a>
についても概括する。
◎
This specification only defines the functional mapping, in terms of key values and code values, but briefly describes key legends for background.
</p>

			<section id="key-legends">
<h4 title="Key Legends">5.1.1. ~key銘</h4>

~INFORMATIVE

<p>
~key銘とは、その <em>~key~cap</em>（~keyの物理的0~switchを覆う “~cap” ）上に印刷されたり, 彫り込まれている，視覚的~目印である。
この種の目印は、通常は，その~keyに対する~keystrokeが生産するような， 1 つ以上の文字からなる（例： `G^kGl, `8^kGl, `ш^kGl ）, あるいは
その~keyの機能を指示する名前や記号（例： `Shift^cap を指示する上向き矢印 `⇧^kGl, 文字列 "Enter" など）。
~keyは、この目印で指されることが多い（例：
“ Shift ＋ F ~keyを押してください。”
）。
しかしながら、~keyの視覚的な見かけは，その~digital表現とは~~関係ないものであり、多くの環境設定で，全く~~正確でないものにもなり得る。
`Enter^cap などの
制御~key／~function~key
であっても，機能性が異なるものや, 文字~keyに~mapされることすら あり得る。
◎
The key legend is the visual marking that is printed or embossed on the key cap (the rectangular "cap" that covers the mechanical switch for the key). These markings normally consist of one or more characters that a keystroke on that key will produce (such as "G", "8", or "ш"), or names or symbols which indicate that key’s function (such as an upward-pointing arrow "⇧" indicating Shift, or the string "Enter"). Keys are often referred to by this marking (e.g., "Press the "Shift" and "G" keys."). Note, however, that the visual appearance of the key has no bearing on its digital representation, and in many configurations may be completely inaccurate. Even the control and function keys, such as Enter, may be mapped to different functionality, or even mapped as character keys.
</p>

<p class="note">注記：
多くの~keyboardは、~Unicode等価な記号があっても，通常は文字を生産しない~keyを備えている。
例えば， `Shift^cap ~keyには、記号 `⇧^kGl （~Unicode符号位置 `21E7^U ）が付けられることもあるが，
`Shift^cap ~keyだけ押しても この`文字~値$を生産することはないし,
`Shift^cap に対応する~Unicode符号位置もない。
◎
Many keyboards contain keys that do not normally produce any characters, even though the symbol might have a Unicode equivalent. For example, the Shift key might bear the symbol "⇧", which has the Unicode code point U+21E7, but pressing the Shift key will not produce this character value, and there is no Unicode code point for Shift.
</p>
			</section>
		</section>
		<section id="keys-codevalues">
<h3 title="Key codes">5.2. ~key~code</h3>

<p>
~keyboard~eventに結付けられている物理的~keyを識別するときは、~keyboard~eventの `code$m 属性で指示される~key~codeを利用できる。
それは、 USB Usage ID に似た，~vendor中立の（~scancodeに似た）低~level値を提供する。
◎
A key code is an attribute of a keyboard event that can be used to identify the physical key associated with the keyboard event. It is similar to USB Usage IDs in that it provides a low-level value (similar to a scancode) that is vendor-neutral.
</p>

<p>
`code$m 属性の首~目的0は、~keyを その物理的~所在に基づいて識別するための，首尾一貫する仕方を提供することである。
加えて、~keyboardの各~keyに（現在の~keyboard状態に影響されないような）安定的な名前も提供して，それらを一意に識別する。
◎
The primary purpose of the code attribute is to provide a consistent and coherent way to identify keys based on their physical location. In addition, it also provides a stable name (unaffected by the current keyboard state) that uniquely identifies each key on the keyboard.
</p>

<p>
妥当な `code^m 値の~listは、
`UIEvents-Code$r にて定義される。
◎
The list of valid code values is defined in the [UIEvents-Code].
</p>

			<section id="code-motivation">
<h4 title="Motivation for the code Attribute">5.2.1. `code^m 属性の動機</h4>

<p>
標準的な~PC~keyboardが備えている一連の~keyが生成する `key$m 値は、利用者が現在~選択している（利用している書記体系に適切な）~keyboard~layoutにより異なる。
このような~~状況下では、~keyをその物理的~所在に基づいて検出するような~codeを書くことは困難になる
— ~codeが，どの `key^m 値を検査すればよいか知るためには、現在~有効な~layoutがどれなのかを知る必要があるので。
現実の例として、~player移動を制御するために［
`W^kGl, `A^kGl, `S^kGl, `D^kGl
］~keyを利用する~gameがある。
`code$m 属性は、それを検査するための，<em>現在の~keyboard~layoutに影響されない</em>, 安定的な値を提供して、この問題を解消する。
◎
The standard PC keyboard has a set of keys (which we refer to as writing system keys) that generate different key values based on the current keyboard layout selected by the user. This situation makes it difficult to write code that detects keys based on their physical location since the code would need to know which layout is in effect in order to know which key values to check for. A real-world example of this is a game that wants to use the "W", "A", "S" and "D" keys to control player movement. The code attribute solves this problem by providing a stable value to check that is not affected by the current keyboard layout.
</p>

<p>
加えて、 `key$m 属性がとる値は，現在の~keyboard状態にも依存する。
このため、修飾~keyと他の~keyが［
押される／離される
］順序も， `key$m 属性に格納される値に影響し得る。
`code$m 属性は、
<em>現在の~keyboard~layoutに影響されない</em>,
安定的な値を提供して、この問題を解消する。
◎
In addition, the values in the key attribute depend as well on the current keyboard state. Because of this, the order in which keys are pressed and released in relation to modifier keys can affect the values stored in the key attribute. The code attribute solves this problem by providing a stable value that is not affected by the current keyboard state.
</p>
			</section>
			<section id="relationship-between-key-code">
<h4 title="The Relationship Between key and code">5.2.2. `key^m と `code^m の関係性</h4>

<dl>
	<dt>`key^m</dt>
	<dd>
`key$m 属性に意図されている用途は、押されている~keyの意味に基づくふるまいを得ることである
— その値には、現在の~keyboard~layoutに加えて，~IMEも織り込まれる（
<a href="#keys-dead">~dead-key</a> には，一意な `key^m 値が与えられる）。
例えば、［
~keyが修飾~keyを伴うかどうかや
~~素の修飾~key
］を検出する利用~事例がある（例：
~keyboard~shortcutに呼応して何らかの動作を遂行するためなど）。
◎
The key attribute is intended for users who are interested in the meaning of the key being pressed, taking into account the current keyboard layout (and IME; dead keys are given a unique key value). Example use case: Detecting modified keys or bare modifier keys (e.g., to perform an action in response to a keyboard shortcut).
</dd>

	<dt>`code^m</dt>
	<dd>
`code$m 属性に意図されている用途は、利用者により押された~keyそのもの
— ~keyboard~layoutにより改変されないままの~key —
に基づくふるまいを得ることである。
例えば、~gameにおける移動~制御のために［
`W^kGl, `A^kGl, `S^kGl, `D^kGl
］~keyを検出したり、すべての~keyを~trapする（例： すべての~keyを遠隔~hostに送信する遠隔~desktop~client）などの利用~事例がある。
◎
The code attribute is intended for users who are interested in the key that was pressed by the user, without any layout modifications applied. Example use case: Detecting WASD keys (e.g., for movement controls in a game) or trapping all keys (e.g., in a remote desktop client to send all keys to the remote host).
</dd>
				</dl>
			</section>
			<section id="code-examples">
<h4 title="Code Examples">5.2.3. ~code例</h4>

<div class="example">

<p>
左右 Alt ~keyの取扱い：
◎
Handling the Left and Right Alt Keys
</p>

<!-- 
`KeyboardEvent!I
-->

<table class="data-table" style="width:auto">
<thead><tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<th>備考
</thead>

<tbody><tr><td>US
<td>`Alt$kY
<td>`AltLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>~French
<td>`Alt$kY
<td>`AltLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>US
<td>`Alt$kY
<td>`AltRight$kC
<td>`DOM_KEY_LOCATION_RIGHT^m

<tr><td>~French
<td>`AltGr$kY
<td>`AltRight$kC
<td>`DOM_KEY_LOCATION_RIGHT^m
</tbody></table>

<p>
この例は、 `key$m 属性を検査すれば，左右どちらの `Alt^cap ~keyが押されたか気にせずに `Alt^cap と照合できることを示している。
`code$m 属性を検査すれば，現在~有効な~layoutが何かを気にすることなく
右~Alt~key（ `AltRight$kC ）と照合できるようになる。
◎
In this example, checking the key attribute permits matching Alt without worrying about which Alt key (left or right) was pressed. Checking the code attribute permits matching the right Alt key ("AltRight") without worrying about which layout is currently in effect.
</p>

<p>
~Frenchの例では、
`Alt^cap ／ `AltGr^cap
~keyは，それぞれ 1 個しかないが，
左／右
の所在は~~維持されることに注意。
◎
Note that, in the French example, the Alt and AltGr keys retain their left and right location, even though there is only one of each key.
</p>
</div>


<div class="example">
<p>
Single Quote ~keyの取扱い：
◎
Handling the Single Quote Key
</p>

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
</thead>

<tbody><tr><td>US
<td>`'^kY
<td>`Quote$kC

<tr><td>Japanese
<td>`:^kY
<td>`Quote$kC

<tr><td>US Intl
<td>`Dead$kY
<td>`Quote$kC
</tbody></table>

<p>
この例は、属性において，~dead-key値がどう符号化されるかを示している。
`key^m 値は，現在の~localeに基づいて様々になる一方、
`code$m 属性は，一貫する値を返す。
◎
This example shows how dead key values are encoded in the attributes. The key values vary based on the current locale, whereas the code attribute returns a consistent value.
</p>
</div>


<div class="example" id="example-key-2">

<p>
種々の~keyboard~layoutにおける
`2^kGl ~keyの取扱い（ Shift も押したとき／押さないとき）：
◎
Handling the "2" Key (with and without Shift pressed) on various keyboard layouts.
</p>

<table class="data-table" style="width:auto">
<thead><tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<th>Shift の有無
</thead>

<tbody><tr><td>US
<td>`2^kY
<td>`Digit2$kC
<td>

<tr><td>US
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>UK
<td>`2^kY
<td>`Digit2$kC
<td>

<tr><td>UK
<td>`"^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>~French
<td>`é^kY
<td>`Digit2$kC
<td>

<tr><td>~French
<td>`2^kY
<td>`Digit2$kC
<td>`shiftKey$m
</tbody></table>

<p>
現在の~localeや修飾~key状態に関わらず，~US~keyboardで~key `2^kGl の~keyを押したときの `code$m 属性の結果は、常に `Digit2$kC になる。
◎
Regardless of the current locale or the modifier key state, pressing the key labelled "2" on a US keyboard always results in "Digit2" in the code attribute.
</p>
</div>



<div class="example" id="example-key-shift-2">

<p>
~keyboard~eventの連列：
`Shift^cap ＆ `2^cap
◎
Sequence of Keyboard Events : Shift and 2
</p>

<p>
次では、 2 つの~key~event連列における属性~値を比較する。
それらは いずれも
~US~keyboardでは 文字 `~aT^kGl を生産するが、~keyが離される順序により相違する。
最初の例の連列の順序は：
`Shift^cap （押） →
`2^cap （押） →
`2^cap（離） →
`Shift^cap（離）。
◎
Compare the attribute values in the following two key event sequences. They both produce the "@" character on a US keyboard, but differ in the order in which the keys are released. In the first sequence, the order is: Shift (down), 2 (down), 2 (up), Shift (up).
</p>

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`code$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>2.
<td>`keydown$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>3.
<td>`keypress$et
<td>`~aT^kY
<td>空~文字列
<td>（~support有りなら）

<tr><td>4.
<td>`keyup$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m
</tbody></table>

<p>
次の例の連列は、 2 を離すより先に Shift を離した場合：
`Shift^cap（押） →
`2^cap（押） →
`Shift^cap（離） →
`2^cap（離）。
◎
In the second sequence, the Shift is released before the 2, resulting in the following event order: Shift (down), 2 (down), Shift (up), 2 (up).
</p>


<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`code$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>2.
<td>`keydown$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>3.
<td>`keypress$et
<td>`~aT^kY
<td>空~文字列
<td>（~support有りなら）

<tr><td>4.
<td>`keyup$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>5.
<td>`keyup$et
<td>`2^kY
<td>`Digit2$kC
<td>
</tbody></table>

<p>
~key `2^kGl については、 `key$m 属性の値が
`keydown$et ~eventと `keyup$et ~eventとの間で合致しないことに注意。
`code$m 属性は、現在の修飾~状態に影響されず，一貫する値を提供する。
◎
Note that the values contained in the key attribute does not match between the keydown and keyup events for the "2" key. The code attribute provides a consistent value that is not affected by the current modifier state.
</p>
</div>


			</section>
			<section id="code-virtual-keyboards">
<h4 title="code and Virtual Keyboards">5.2.4. `code^m と仮想~keyboard</h4>
<p>
`code$m 属性の有用性は、仮想~keyboardに対しては明白でない（遠隔~制御~keyboardや複数~keyの同時押下げに対しても）。
仮想（または遠隔~制御）~keyboardに対しては、
標準的な~keyboardの
~layout／機能性
を真似ているものについては，
`code$m 属性を適切に設定し~MUST。
真似ていない~keyboardについては、標準的な~keyboardになるべく近いものに設定するか, または
未定義のままにして~MAY。
◎
The usefulness of the code attribute is less obvious for virtual keyboards (and also for remote controls and chording keyboards). In general, if a virtual (or remote control) keyboard is mimicking the layout and functionality of a standard keyboard, then it MUST also set the code attribute as appropriate. For keyboards which are not mimicking the layout of a standard keyboard, then the code attribute MAY be set to the closest match on a standard keyboard or it MAY be left undefined.
</p>

<p>
修飾~状態に基づいて異なる値を生産する~keyを伴うような仮想~keyboardに対しては、 `code^m 値は，［
装置がその工場出荷~状態にある下で~buttonが押された
］ときに生成される `key^m 値にされる~SHOULDである。
◎
For virtual keyboards with keys that produce different values based on some modifier state, the code value should be the key value generated when the button is pressed while the device is in its factory-reset state.
</p>
			</section>
		</section>
		<section id="keys-keyvalues">
<h3 title="Keyboard Event key Values">5.3. ~keyboard~eventの `key^m 値</h3>

<div class="p">
<p>
`~key値$は、~keyboard上の任意の~keyを，その位置や状態に関わらず，
それが生産する値で指示するために利用し得る `DOMString^I である。
これらの~key値は、次のものに利用できる／され得る：
</p>

<ul><li>実装により生成される~keyboard~eventに対する返値
</li><li>内容~作者から欲される入力（~keyboard~shortcutなど）を指定するための入力~値
</li></ul>

◎
A key value is a DOMString that can be used to indicate any given key on a keyboard, regardless of position or state, by the value it produces. These key values MAY be used as return values for keyboard events generated by the implementation, or as input values by the content author to specify desired input (such as for keyboard shortcuts).
</div>

<p>
妥当な `key^m 値の~listは `UIEvents-Key$r にて定義される。
◎
The list of valid key values is defined in [UIEvents-Key].
</p>

<p>
`~key値$は、 `key$m 属性を利用して，押された~keyの値を検出するときに利用される値である。
内容~作者は、［
大文字や小文字, 数字, 記号
］その他，文字を生産する~keyに対しては その`文字~値$を取得0でき、［
制御~key, 修飾~key, ~function~key
］その他，文字を生産しない~keyに対しては その`~key値$を取得0できる。
これらの値は、［
特定0の入力~文字列を監視する ／
他の入力（~mouseなど）との組合せで 修飾~key入力を検出して動作する ／
仮想~keyboardを作成する
］その他，いくつもの目的0に利用できる。
◎
Key values can be used to detect the value of a key which has been pressed, using the key attribute. Content authors can retrieve the character value of upper- or lower-case letters, number, symbols, or other character-producing keys, and also the key value of control keys, modifier keys, function keys, or other keys that do not generate characters. These values can be used for monitoring particular input strings, for detecting and acting on modifier key input in combination with other inputs (such as a mouse), for creating virtual keyboards, or for any number of other purposes.
</p>

<p>
内容~作者は、`~key値$を文字列~比較にも利用できる
—
適合`~host言語$における
~markup属性に対する値（ HTML の `accesskey^a など）として, あるいは
他の関係する目的0に。
適合`~host言語$は、内容~作者が，`~key値$に対する 2 つの等価な文字列~値：［
`文字~値$ または `~key値$
］のいずれも利用できるようにする~SHOULDである。
◎
Key values can also be used by content authors in string comparisons, as values for markup attributes (such as the HTML accesskey) in conforming host languages, or for other related purposes. A conforming host language SHOULD allow content authors to use either of the two equivalent string values for a key value: the character value, or the key value.
</p>

<p class="note">注記：
実装は、~keyに対し，~platformや~keyboard~layout~mappingから独立に，最も関連する値を利用することになる一方、内容~作者は，それらを生成する~keyboard装置の能について前提を置けない。
内容~作者は、~shortcut~keyの組合せとして~keyboard~eventと~key値を利用するときには，普通字の代わりに
数字~key, ~function~key（ `F4^cap, `F5^cap, 等々）の利用も考慮できる（ `DWW95$r ）
— 大部分の~keyboard~layoutは，それらに対する~keyを提供するので。
◎
While implementations will use the most relevant value for a key independently of the platform or keyboard layout mappings, content authors can not make assumptions on the ability of keyboard devices to generate them. When using keyboard events and key values for shortcut-key combinations, content authors can "consider using numbers and function keys (F4, F5, and so on) instead of letters" ([DWW95]) given that most keyboard layouts will provide keys for those.
</p>

<p>
`~key値$は、物理的~keyboard上の特定の~keyを指示するものでも，~key上に印刷された文字を反映するものでもない。
~key値は、作動中の［
~keyすべて／~key入力~mode（~shift~modeを含む）の現在の状態
］が考慮に入れられ，~OSによる~keyboard~mappingに反映され, 実装に報告されるような，~eventの現在の値を指示する。
例えば、［
`QWERTY$ ~keyboardの `O^cap~key
］の~key値は，［
未shiftの下では `o^kY ／
有shiftの下では `O^kY
］になる。
利用者は，自身の~keyboardを任意の~custom環境設定に~mapできるので、内容~作者には，［
~keyの~shiftの有無や，文字~表現の［
大文字形, 小文字形
］の間に，関係性が存在する
］ものと見做すことなく， `key$m 属性の値を利用することが奨励される。
例えば、
`D3E-code$r にて図面化されている標準的な “102 ~keyboard” ~layoutは、ある~keyboard~layoutにおける，`~key~mapping$の集合としてあり得る一つを図示する。
他にも、標準のもの, 独特のものが多数 存在する。
◎
A key value does not indicate a specific key on the physical keyboard, nor does it reflect the character printed on the key. A key value indicates the current value of the event with consideration to the current state of all active keys and key input modes (including shift modes), as reflected in the operating-system mapping of the keyboard and reported to the implementation. In other words, the key value for the key labeled O on a QWERTY keyboard has the key value "o" in an unshifted state and "O" in a shifted state. Because a user can map their keyboard to an arbitrary custom configuration, the content author is encouraged not to assume that a relationship exists between the shifted and unshifted states of a key and the majuscule form (uppercase or capital letters) and minuscule form (lowercase or small letters) of a character representation, but is encouraged instead to use the value of the key attribute. For example, the Standard "102" Keyboard layout depicted in [UIEvents-Code] illustrates one possible set of key mappings on one possible keyboard layout. Many others exist, both standard and idiosyncratic.
</p>

<p class="note">注記：
`~dead-key$ ~supportを単純化するため、~keyboardの~OS~mappingが`~dead-key$状態を取扱うときの，~dead-key連列の現在の状態は、
`key$m 属性を介しては報告されず，代わりに`~key値$ `Dead$kY が報告される。
実装は、代わりに［
~dead-key連列の中間的な状態を包含する，一連の`組成~event$
］を生成して，それを `CompositionEvent.data$m 属性を介して報告する。
前掲の例と同様に， `QWERTY$ ~keyboardの `O^cap と印字された~keyに対する`~key値$には，~dead-key操作の最中に~umlaut発音区別符が追加されるので、
`CompositionEvent.data$m 値は，未shiftでは `ö^kGl になり, 有shiftでは `Ö^kGl になる。
◎
To simplify dead key support, when the operating-system mapping of the keyboard is handling a dead key state, the current state of the dead key sequence is not reported via the key attribute. Rather, a key value of "Dead" is reported. Instead, implementations generate composition events which contain the intermediate state of the dead key sequence reported via the data attribute. As in the previous example, the key value for the key marked O on a QWERTY keyboard has a data value of 'ö' in an unshifted state during a dead-key operation to add an umlaut diacritic, and 'Ö' in a shifted state during a dead-key operation to add an umlaut diacritic.
</p>

<p>
また、~key~eventの各~状態と各`~key値$との間には，一対一の関係性はないことにも特に注意。
複数の~keyが特定0の~key値に結付けられることもある。
例えば，多くの標準的な~keyboardは、 `Shift^cap ~keyや `8^cap ~keyを複数~備えている（通常は［
いずれも `location$m 値で区別される
— 前者は［
`DOM_KEY_LOCATION_LEFT$m ／ `DOM_KEY_LOCATION_RIGHT$m
］で，後者は［
`DOM_KEY_LOCATION_STANDARD$m ／ `DOM_KEY_LOCATION_NUMPAD$m
］で）。
また，利用者により環境設定された~custom~keyboard~layoutは、どの~key値にも複数の~key状態が対応付けられ得る（ `location$m は、標準的な~keyboard~layout~~用途に意図されていることに注意
— 有意義な~~区別を常に指示できるわけではない）。
◎
It is also important to note that there is not a one-to-one relationship between key event states and key values. A particular key value might be associated with multiple keys. For example, many standard keyboards contain more than one key with the Shift key value (normally distinguished by the location values DOM_KEY_LOCATION_LEFT and DOM_KEY_LOCATION_RIGHT) or 8 key value (normally distinguished by the location values DOM_KEY_LOCATION_STANDARD and DOM_KEY_LOCATION_NUMPAD), and user-configured custom keyboard layouts MAY duplicate any key value in multiple key-state scenarios (note that location is intended for standard keyboard layouts, and cannot always indicate a meaningful distinction).
</p>

<p>
~~最後に、与えられた文字~表現の意味は，文脈に依存する上に複雑である。
例えば，一部の文脈では、~asterisk~glyph（ `*^kGl ）は，脚注や強調を表現する（~textの一節を~~括るとき）。
しかしながら、それ／その機能は、文書や実行可能~programによっては，数学的な乗算に等価であったり, 乗算~記号として予約されていたり（ `×^kGl, ~Unicode値 `00D7^U ）, ~~小文字の "x" のこともある（多くの~keyboardが乗算~keyを欠くこと，あるいは `×^kGl と `x^kGl のような~glyphの~~外見上の~~類似に因り）。
したがって、意味論的部分や, 文字~表現の機能は，この仕様の視野~外である。
◎
Finally, the meaning of any given character representation is context-dependent and complex. For example, in some contexts, the asterisk (star) glyph ("*") represents a footnote or emphasis (when bracketing a passage of text). However, in some documents or executable programs it is equivalent to the mathematical multiplication operation, while in other documents or executable programs, that function is reserved for the multiplication symbol ("×", Unicode value U+00D7) or the Latin small letter x (due to the lack of a multiplication key on many keyboards and the superficial resemblance of the glyphs "×" and "x"). Thus, the semantic meaning or function of character representations is outside the scope of this specification.
</p>

			<section id="keys-modifiers">
<h4 title="Modifier keys">5.3.1. 修飾~key</h4>

<p>
修飾~keyを利用する~keyboard入力は、~keyの通常の挙動を変化させる。
他の~keyと同様、修飾~keyは，下の例に示すように
`keydown$et ／ `keyup$et
~eventを生成する。
修飾~keyには、押されている間 作動化されるものもあれば（
`Alt^cap,
`Control^cap,
`Shift^cap,
`AltGraph^cap,
`Meta^cap
など）、状態を持ち，その状態に依存して作動化されるものもある（
`CapsLock^cap,
`NumLock^cap,
`ScrollLock^cap
など）。
状態の変化は、修飾~keyが押されたときに起こる。
`KeyboardEvent!I ~ifcは、一部の共通的な修飾~keyに対し，簡便な属性
— `ctrlKey$m, `shiftKey$m, `altKey$m, `metaKey$m —
を提供する。
一部の~OSは、修飾~key `AltGraph^cap を，修飾~key `Alt^cap, `Control^cap の組合せで模造する。
実装には、 `AltGraph^cap 修飾~keyを利用することが奨励される。
◎
Keyboard input uses modifier keys to change the normal behavior of a key. Like other keys, modifier keys generate keydown and keyup events, as shown in the example below. Some modifiers are activated while the key is being pressed down or maintained pressed such as Alt, Control, Shift, AltGraph, or Meta. Other modifiers are activated depending on their state such as CapsLock, NumLock, or ScrollLock. Change in the state happens when the modifier key is being pressed down. The KeyboardEvent interface provides convenient attributes for some common modifiers keys: ctrlKey, shiftKey, altKey, metaKey. Some operating systems simulate the AltGraph modifier key with the combination of the Alt and Control modifier keys. Implementations are encouraged to use the AltGraph modifier key.
</p>

<p>
次の例に、~US~keyboardで, ~US~mappingを利用している下で，~Unicode文字 Q（ Latin Capital Letter Q, ~Unicode符号位置 `0051^U ）が生成されるときに生じ得る~event連列を述べる：
◎
This example describes a possible sequence of events associated with the generation of the Unicode character Q (Latin Capital Letter Q, Unicode code point U+0051) on a US keyboard using a US mapping:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>`shiftKey$m
<td>Latin Capital Letter Q

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Q^kY
<td>`shiftKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
</tbody></table>
</div>


<p>
次の例に、上の例において， `Q^cap ~keyを離す前に `Shift^cap ~keyを離したときに，代わって生じ得る~key連列を述べる。
~key `Q^cap に対する`~key値$は、
`keyup$et ~eventに対しては，その未shift値に復帰することになる：
◎
Th example describes an alternate sequence of keys to the example above, where the Shift key is released before the Q key. The key value for the Q key will revert to its unshifted value for the keyup event:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>`shiftKey$m
<td>Latin Capital Letter Q

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`q^kY
<td>
<td>Latin Small Letter Q
</tbody></table>
</div>


<p>
次の例に、~Unicode文字を生成しないときに生じ得る~keyの連列を述べる（前の例と同じ環境設定の下で）:
◎
The following example describes a possible sequence of keys that does not generate a Unicode character (using the same configuration as the previous example):
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`v^kY
<td>`ctrlKey$m
<td>Latin Small Letter V

<tr><td>
<td colspan="4"><em>
`beforeinput$et／`input$et
~eventは生成されない。
</em>
◎
No beforeinput or input events are generated.

<tr><td>3.
<td>`keyup$et
<td>`v^kY
<td>`ctrlKey$m
<td>Latin Small Letter V

<tr><td>4.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</tbody></table>
</div>


<p>
次の例に，
`Shift^cap, `Control^cap が両者とも押されたときの~event連列を示す：
◎
The following example shows the sequence of events when both Shift and Control are pressed:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Shift$kY
<td>`ctrlKey$m, `shiftKey$m
<td>

<tr><td>3.
<td>`keydown$et
<td>`V^kY
<td>`ctrlKey$m, `shiftKey$m
<td>Latin Capital Letter V

<tr><td>
<td colspan="4"><em>
<!-- copy -->
`beforeinput$et／`input$et
~eventは生成されない。
</em>
◎
No beforeinput or input events are generated.

<tr><td>4.
<td>`keyup$et
<td>`V^kY
<td>`ctrlKey$m, `shiftKey$m
<td>Latin Capital Letter V

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>`ctrlKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</tbody></table>
</div>


<p>
非~US~keyboard~layoutに対しても，~event連列は同じになるが、~keyの値は，現在の~keyboard~layoutに基づく。
次の例に，~Arabic~keyboard~layoutが利用されるときの~event連列を示す：
◎
For non-US keyboard layouts, the sequence of events is the same, but the value of the key is based on the current keyboard layout. This example shows a sequence of events when an Arabic keyboard layout is used:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`&#x631;^kY
<td>`ctrlKey$m
<td>Arabic Letter Reh


<tr><td>
<td colspan="4">
<!-- copy -->
`beforeinput$et／`input$et
~eventは生成されない。
◎
No beforeinput or input events are generated.

<tr><td>3.
<td>`keyup$et
<td>`&#x631;^kY
<td>`ctrlKey$m
<td>Arabic Letter Reh

<tr><td>4.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</tbody></table>
</div>

<p class="note">注記：
`keydown$et ／ `keyup$et
~eventにおける値は、~keyが押されたときに有効な現在の~keyboard~layoutに基づいて，様々になる。
これは、同じ物理的~keyであっても，
~US~layout上の `v^cap ~key と
~Arabic~layout上の `&#x631;^cap ~keyとでは，異なる~eventを生成することを意味する。
これらの~eventを同じ物理的~keyとして識別するためには、 `code$m 属性を利用する必要がある。
◎
The value in the keydown and keyup events varies based on the current keyboard layout in effect when the key is pressed. This means that the v key on a US layout and the ر key on an Arabic layout will generate different events even though they are the same physical key. To identify these events as coming from the same physical key, you will need to make use of the code attribute.
</p>

<p>
修飾~keyが，~key~eventに対する`~key値$を変化させる事例もある。
例えば，一部の MacOS ~keyboard上の “delete” ~keyは、未修飾~時にはWindows ~OS上の `Backspace^cap ~keyと同じに機能するが、
`Fn^cap ~keyで修飾されたときは `Delete^cap ~keyとして動作し，~key値は 現在の修飾された状態に最も適切な~keyの機能に合致することになる。
◎
In some cases, modifier keys change the key value for a key event. For example, on some MacOS keyboards, the key labeled "delete" functions the same as the Backspace key on the Windows OS when unmodified, but when modified by the Fn key, acts as the Delete key, and the value of key will match the most appropriate function of the key in its current modified state.
</p>

			</section>
			<section id="keys-dead">
<h4 title="Dead keys">5.3.2. ~dead-key</h4>

<p>
~keyboard入力では、`~dead-key$を利用して組成済みの文字~連列を入力することもある。
手書き式に最初に基底~文字を手入力するのでなく、そこでの~keyboard入力には，特別な状態に入ることが要求され、`~dead-key$が押された~~直後では，限られた数の “合法な” 基底~文字が手入力されたときにのみ，文字（たち）を出力0する。
◎
Some keyboard input uses dead keys for the input of composed character sequences. Unlike the handwriting sequence, in which users enter the base character first, keyboard input requires to enter a special state when a dead key is pressed and emit the character(s) only when one of a limited number of "legal" base character is entered.
</p>

<p class="note">注記：
MacOS ／ Linux ~OSは、`~dead-key$を処理するときに~IMEを利用する。
◎
The MacOS and Linux operating systems use input methods to process dead keys.
</p>

<p>
（すべての~keyboard~layout, および~mappingに渡り，）`~dead-key$は、`~key値$ `Dead$kY で表現される。
~dead-keyが押されたときは、~UAは それに呼応して，`組成~event$たちを発火し~MUST。
加えて、その
`compositionupdate$et ~eventの `CompositionEvent.data$m 値は，~dead-key結合~連列の現在の状態の`文字~値$にされ~MUST。
◎
The dead keys (across all keyboard layouts and mappings) are represented by the key value Dead. In response to any dead key press, composition events must be dispatched by the user agent and the compositionupdate event’s data value must be the character value of the current state of the dead key combining sequence.
</p>

<p>
~Unicode結合~文字は，常に［
対応する普通字とそれに続く結合~文字による手書き連列
］に倣う一方で、代表的な~dead-key入力では，その結合~文字が対応する普通字の前に来るように 連列を逆順にすることもある。
例えば，単語 "naïve" は、結合~発音区別符 "¨" を利用して，~Unicodeでは
"nai¨ve"
として連列的に表現されるが、
"na¨ive" と叩かれ得る。
~keystroke連列［
`0302^U （ Combining Circumflex Accent ~key）,
`0065^U （ Latin Small Letter E と印字される~key）
］は，［
<em>NFC</em> （ Unicode Normalization Form ）に選好される ~Unicode文字
`ê^kGl （ Latin Small Letter E With Circumflex ）
］を生産するであろう（~French~keyboardでは、修飾~keyを作動化させずに，~French~mappingを利用して）。
◎
While Unicode combining characters always follow the handwriting sequence, with the combining character trailing the corresponding letter, typical dead key input MAY reverse the sequence, with the combining character before the corresponding letter. For example, the word naïve, using the combining diacritic ¨, would be represented sequentially in Unicode as nai¨ve, but MAY be typed na¨ive. The sequence of keystrokes U+0302 (Combining Circumflex Accent key) and U+0065 (key marked with the Latin Small Letter E) will likely produce (on a French keyboard using a french mapping and without any modifier activated) the Unicode character "ê" (Latin Small Letter E With Circumflex), as preferred by the Unicode Normalization Form NFC.
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>~F
<td>
<td>Combining Circumflex Accent (Dead Key)

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`0302^U
<td>

<tr><td>4.
<td>`keyup$et
<td>`Dead$kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`ê^kY
<td>~T
<td>
<td>

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`ê^kGl
<td>

<tr><td>7.
<td>`compositionend$et
<td>
<td>
<td>`ê^kGl
<td>

<tr><td>8.
<td>`keyup$et
<td>`e^kY
<td>~F
<td>
<td>Latin Small Letter E
</tbody></table>
</div>

<p class="note">注記：
2 個目の `keydown^c ~event（段 5）では、（~eventは抑止されていないとするとき，）通常の状況~下では`~key値$ `e^kY （ Latin Small Letter E ~key）<em>にはならない</em>
— ~UAに送達される値は、すでに~dead-key操作により修飾されることになるので。
◎
In the second keydown event (step 5), the key value (assuming the event is not suppressed) will not be "e" (Latin Small Letter E key) under normal circumstances because the value delivered to the user agent will already be modified by the dead key operation.
</p>

<p>
この処理は、利用者が`~dead-key$を押した後に~supportされない基底~文字（すなわち，作動中の発音区別符号が可用でない基底~文字）を叩いたときには，中止され得る：
◎
This process might be aborted when a user types an unsupported base character (that is, a base character for which the active diacritical mark is not available) after pressing a dead key:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>~F
<td>
<td>Combining Circumflex Accent (Dead Key)

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`0302^U
<td>

<tr><td>4.
<td>`keyup$et
<td>`Dead$kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`q^kY
<td>~T
<td>
<td>Latin Small Letter Q

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>7.
<td>`compositionend$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>8.
<td>`keyup$et
<td>`q^kY
<td>~F
<td>
<td>
</tbody></table>
</div>
			</section>
			<section id="keys-IME">
<h4 title="Input Method Editors">5.3.3. ~IME（ Input Method Editors ）</h4>

<p>
この仕様は、
`CompositionEvent$I ~ifc＆~event
を通して，`~IME$（ Input Method Editor ）のための~modelを含めている。
しかしながら、`組成~event$と`~keyboard~event$を一対一に~mapすることは，必要とされていない。
例として、`~key値$ `Accept^cap を伴う `keydown$et を受取ったとしても、それは，
`~IME$において現在~選択-中の~textが受容されたことを含意するわけではなく、~keystrokeが起きたことのみを指示する
— 受容されている`~IME$の機能性からは切離されて（通常それは、大部分の`~IME$~systemにおいて， `compositionend$et ~eventを生じさせることになるが）。
~keyboard~eventは、~IMEの現在の状態を決定する用途には，利用できない
— その状態は `CompositionEvent.data$m 属性を通して得ることができる。
加えて、`~IME$~systemや装置の機能性は様々であり，その機能性を作動化するために，どの~key
— `Convert^cap ／ `Accept^cap ~keyなど —
が利用されているかは、他の可用な~keyにより表現さることもある。
~keyboard~eventは、~keyboard~layout~mappingの後に，入力~装置により生成された~eventに対応する。
◎
This specification includes a model for input method editors (IMEs), through the CompositionEvent interface and events. However, Composition Events and Keyboard Events do not necessarily map as a one-to-one relationship. As an example, receiving a keydown for the Accept key value does not necessarily imply that the text currently selected in the IME is being accepted, but indicates only that a keystroke happened, disconnected from the IME Accept functionality (which would normally result in a compositionend event in most IME systems). Keyboard events cannot be used to determine the current state of the input method editor, which can be obtained through the data attribute of the CompositionEvent interface. Additionally, IME systems and devices vary in their functionality, and in which keys are used for activating that functionality, such that the Convert and Accept keys MAY be represented by other available keys. Keyboard events correspond to the events generated by the input device after the keyboard layout mapping.
</p>

<p class="note">注記：
一部の実装／~system環境設定においては、一部の~key~eventやその値は，利用中の`~IME$により抑止されることがある。
◎
In some implementations or system configurations, some key events, or their values, might be suppressed by the IME in use.
</p>

<p>
次の例に、日本語~IMEを利用して，~Unicode文字 `~~市^kGl （ CJK Unified Ideographs の一部である漢字 ）が生成されるときに生じ得る~key連列を述べる。
この例では、~IMEは作動化されていて，日本語~Romaji入力~mode下にあるとする。
~key
`Convert^cap （ “~~変換” ）／ `Accept^cap （ “~~確定” ）
は、利用中の入力~装置や~IMEの環境設定に依存して，他に置換されることもある
— 例えば
`~SPACEBAR^cap （ `0020^U ）／ `Enter^cap
にもなり得る。
◎
The following example describes a possible sequence of keys to generate the Unicode character "市" (Kanji character, part of CJK Unified Ideographs) using Japanese input methods. This example assumes that the input method editor is activated and in the Japanese-Romaji input mode. The keys Convert and Accept MAY be replaced by others depending on the input device in use and the configuration of the IME, e.g., it can be respectively U+0020 (Space key) and Enter.
</p>

<p class="note">注記：
`~~詩^kGl と `~~市^kGl は、異形同音異義語であり，いずれも “し” と発音されるので、利用者は，
`Convert^cap ~keyを利用して 適正な選択肢を選択する必要がある。
◎
"詩" ("poem") and "市" ("city") are homophones, both pronounced し ("shi"/"si"), so the user needs to use the Convert key to select the proper option.
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`s^kY
<td>~F
<td>
<td>Latin Small Letter S

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>4.
<td>`compositionupdate$et
<td>
<td>
<td>`s^kGl
<td>

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>5.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`s^kY
<td>~T
<td>
<td>

<tr><td>7.
<td>`keydown$et
<td>`i^kY
<td>~T
<td>
<td>Latin Small Letter I

<tr><td>8.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>9.
<td>`compositionupdate$et
<td>
<td>
<td>`し^kGl
<td>◎shi

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>10.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>11.
<td>`keyup$et
<td>`i^kY
<td>~T
<td>
<td>

<tr><td>12.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”◎Convert

<tr><td>13.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>14.
<td>`compositionupdate$et
<td>
<td>
<td>`詩^kGl
<td>◎"poem"

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>15.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>16.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>17.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”◎Convert

<tr><td>18.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>19.
<td>`compositionupdate$et
<td>
<td>
<td>`市^kGl
<td>◎"city"

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>20.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>21.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>22.
<td>`keydown$et
<td>`Accept$kY
<td>~T
<td>
<td>“~~確定”◎Accept

<tr><td>23.
<td>`compositionend$et
<td>
<td>
<td>`市^kGl
<td>

<tr><td>24.
<td>`keyup$et
<td>`Accept$kY
<td>~F
<td>
<td>
</tbody></table>
</div>

<p>
~IME組成は、前掲の例と同一の条件で，次の例のように取消され得る。
~key `Cancel^cap も利用中の入力~装置や~IMEの環境設定に依存して，他に置換され得る
— 例えば `001B^U （ `Escape^cap ~key ）にもなり得る。
◎
IME composition can also be canceled as in the following example, with conditions identical to the previous example. The key 'Cancel' might also be replaced by others depending on the input device in use and the configuration of the IME, e.g., it could be U+001B (Escape key).
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`s^kY
<td>~F
<td>
<td>Latin Small Letter S

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`s^kGl
<td>

<tr><td>4.
<td>`keyup$et
<td>`s^kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`i^kY
<td>~T
<td>
<td>Latin Small Letter I

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`し^kGl
<td>

<tr><td>7.
<td>`keyup$et
<td>`i^kY
<td>~T
<td>
<td>

<tr><td>8.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”◎Convert

<tr><td>9.
<td>`compositionupdate$et
<td>
<td>
<td>`詩^kGl
<td>

<tr><td>10.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>11.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”◎Convert

<tr><td>12.
<td>`compositionupdate$et
<td>
<td>
<td>`市^kGl
<td>

<tr><td>13.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>14.
<td>`keydown$et
<td>`Cancel$kY
<td>~T
<td>
<td>“~~取消”◎Cancel

<tr><td>15.
<td>`compositionupdate$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>16.
<td>`compositionend$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>17.
<td>`keyup$et
<td>`Cancel$kY
<td>~F
<td>
<td>
</tbody></table>
</div>

<p class="note">注記：
`~IME$（ MacOS ~OS上など）によっては、組成を取消す前に組成~data属性に`空~文字列$を設定するものもある。
◎
Some input method editors (such as on the MacOS operating system) might set an empty string to the composition data attribute before canceling a composition.
</p>

				<section id="keys-IME-keys">
<h5 title="Input Method Editor mode keys">5.3.3.1. ~IME~mode~key</h5>

<p>
ある種の装置では、一部の~keyに，［
`~IME$を作動化したり, 作動中の`~IME$の~modeを変更する
］ような機能性が意図されている。
これを目的0とする~keyは、装置や言語~modeごとに異なるものが定義され得る。
この仕様では、次のものが，これを目的0とする~keyとして定義される：
`Alphanumeric$kY,
`CodeInput$kY,
`FinalMode$kY,
`HangulMode$kY,
`HanjaMode$kY,
`Hiragana$kY,
`JunjaMode$kY,
`KanaMode$kY,
`KanjiMode$kY,
`Katakana$kY,
`RomanCharacters$kY
。
`~IME$が作動中でない下で，これらのいずれかの~keyが押されたときは、（可用なら）適切な`~IME$が，~keyにより指示される~modeで作動化されることが予期される。
~keyが押されたとき，`~IME$がすでに作動中である場合、［
装置／~app
］に特有のふるまいに基づいて，`~IME$が 指示された~modeへ変更されたり,
異なる`~IME$が起動0されたり, あるいは無視されることもある。
◎
Some keys on certain devices are intended to activate input method editor functionality, or to change the mode of an active input method editor. Custom keys for this purpose can be defined for different devices or language modes. The keys defined in this specification for this purpose are: "Alphanumeric", "CodeInput", "FinalMode", "HangulMode", "HanjaMode", "Hiragana", "JunjaMode", "KanaMode", "KanjiMode", "Katakana", and "RomanCharacters". When one of these keys is pressed, and no IME is currently active, the appropriate IME is expected to be activated in the mode indicated by the key (if available). If an IME is already active when the key is pressed, the active IME might change to the indicated mode, or a different IME might be launched, or the might MAY be ignored, on a device- and application-specific basis.
</p>

<p>
この仕様は、特に`~IME$に意図されている操作，その他の~keyも定義する：
`Accept$kY,
`AllCandidates$kY,
`Cancel$kY,
`Convert$kY,
`Compose$kY,
`FullWidth$kY,
`HalfWidth$kY,
`NextCandidate$kY,
`Nonconvert$kY,
`PreviousCandidate$kY
。
これらの~keyの機能は、この仕様では定義されない
— `~IME$機能性についての詳細は、他の資料を参照のこと。
◎
This specification also defines other keys which are intended for operation specifically with input method editors: "Accept", "AllCandidates", "Cancel", "Convert", "Compose", "FullWidth", "HalfWidth", "NextCandidate", "Nonconvert", and "PreviousCandidate". The functions of these keys are not defined in this specification — refer to other resources for details on input method editor functionality.
</p>

<p class="note">注記：
`~IME$機能を伴う~keyは、その目的0に制約されず，他の装置や実装~特有の目的0を持つこともある。
◎
Keys with input method editor functions are not restricted to that purpose, and can have other device- or implementation-specific purposes.
</p>
				</section>
			</section>
			<section id="keys-cancelable-keys">
<h4 title="Default actions and cancelable keyboard events">5.3.4. 既定~動作と取消可能~keyboard~event</h4>

<p>
`keydown$et ~eventの`既定~動作$が取消されたときは，それと対を成す `keyup$et ~eventには影響しては~MUST_NOTが、それに呼応する［
`beforeinput$et ／ `input$et ／（~support有りなら） `keypress$et
］~eventは 生成されないようにし~MUST。
次の例に、~US~keyboardで, ~US~mappingを利用している下で，~Unicode文字 Q（ Latin Capital Letter Q ）が生成されるときに生じ得る~key連列を述べる：
◎
Canceling the default action of a keydown event MUST NOT affect its respective keyup event, but it MUST prevent the respective beforeinput and input (and keypress if supported) events from being generated. The following example describes a possible sequence of keys to generate the Unicode character Q (Latin Capital Letter Q) on a US keyboard using a US mapping:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>
<!-- copy -->
`既定~動作$は、例えば `preventDefault()$m の呼出しにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td>
<td>
<td>
<td><em>
`beforeinput$et／`input$et
~event, および（~supportされるなら）`keypress$et ~eventは、生成されない
</em>
◎
No beforeinput or input (or keypress, if supported) events are generated

<tr><td>3.
<td>`keyup$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>4.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
<td>
</tbody></table>
</div>

<p>
~keyが修飾~keyであった場合、~keystrokeは，依然として修飾~状態には織り込まれ~MUST。
次の例に、~US~keyboardで, ~US~mappingを利用している下で，~Unicode文字 Q（ Latin Capital Letter Q ）が生成されるときに生じ得る連列を述べる：
◎
If the key is a modifier key, the keystroke MUST still be taken into account for the modifiers states. The following example describes a possible sequence of keys to generate the Unicode character Q (Latin Capital Letter Q) on a US keyboard using a US mapping:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>修飾
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>
<td>`shiftKey$m
<td>
<!-- copy -->
`既定~動作$は、例えば `preventDefault()$m の呼出しにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>3.
<td>`beforeinput$et
<td>
<td>`Q^kGl
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
<td>
</tbody></table>
</div>

<p>
~keyが何回かの~keystrokeからなる連列の一部である場合、それが `~dead-key$であれ, ~IME連列に関与しているものであれ、その~keystrokeは，
`keydown$et ~event上で`既定~動作$が取消された場合にのみ，無視され~MUST（織り込まれない）。
`~dead-key$による`keyup$et ~eventを取消しても，
`beforeinput$et ／ `input$et
~eventには効果がない。
次の例に、~French~keyboardで, ~French~mappingを利用し，どの修飾も作動化されない下で、［
~dead-key `Dead$kY （ `0302^U Combining Circumflex Accent ~key）
］, ［
`e^kY ~key（ `0065^U, Latin Small Letter E ~key）
］を利用したときに生じる~event連列を示す：
◎
If the key is part of a sequence of several keystrokes, whether it is a dead key or it is contributing to an Input Method Editor sequence, the keystroke MUST be ignored (not taken into account) only if the default action is canceled on the keydown event. Canceling a dead key on a keyup event has no effect on beforeinput or input events. The following example uses the dead key "Dead" (U+0302 Combining Circumflex Accent key) and "e" (U+0065, Latin Small Letter E key) on a French keyboard using a French mapping and without any modifier activated:
</p>

<div class="example">

<table class="event-sequence-table">
<thead><tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>備考
</thead>

<tbody><tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>
<td>
<!-- copy -->
`既定~動作$は、例えば `preventDefault()$m の呼出しにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>2.
<td>`keyup$et
<td>`Dead$kY
<td>
<td>

<tr><td>3.
<td>`keydown$et
<td>`e^kY
<td>
<td>

<tr><td>4.
<td>`beforeinput$et
<td>
<td>`e^kGl
<td>

<tr><td>5.
<td>`input$et
<td>
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`e^kY
<td>
<td>
</tbody></table>
</div>
			</section>
		</section>
	</section>
	<section id="legacy-event-initializers" class="appendix">

<h2 title="Legacy Event Initializers">6. 旧来の~event初期化子</h2>

`legacy-event-initializers^APX

	</section>
	<section id="legacy-key-attributes">

<h2 title="Legacy Key Attributes">7. 旧来の~key属性</h2>

`legacy-key-attributes^APX

	</section>
	<section id="legacy-event-types">

<h2 title="Legacy Event Types">8. 旧来の~event型</h2>

`legacy-event-types^APX

	</section>
	<section id="extending-events">

<h2 title="Extending Events">9. ~eventを拡張するとき</h2>

`extending-events^APX

	</section>
	<section id="security-considerations">

<h2 title="Security Considerations">10. 保安上の考慮点</h2>

`security-considerations^APX

	</section>
	<section id="changes-from-earlier-versions">

<h2 title="Changes">11. 変更点</h2>

`changes-from-earlier-versions^APX

	</section>
	<section id="acknowledgements-contributors">
<h2 title="Acknowledgements">12. 謝辞</h2>

`acknowledgements-contributors^APX

	</section>
	<section id="glossary">


<h2 title="Glossary">13. 用語集</h2>

<p class="1st">
次の用語の定義の一部は、他の
W3C ／標準
の文書の似た定義から収集されたり, 改変されている。
詳細は、定義~内の~linkを見よ。
◎
Some of the following term definitions have been borrowed or modified from similar definitions in other W3C or standards documents. See the links within the definitions for more information.
</p>

<p class="trans-note">【
この訳では、利用されていない（本文の改訂により参照されなくなった）用語, 適合性~関連の用語については、省略する。
また、原文の~~アルファベット順による並びを，互いの関連度に基づく並びに変えている。
】</p>

<dl id="glossary-list">

	<dt>`~Window@ （ `Window^I ~obj）</dt>
	<dd>
~Windowは、 `HTML5$r
にて定義されるように，［
現在の文書の閲覧文脈の
`WindowProxy$I ~obj
］から~~参照される，~objである。
◎
The Window is the object referred to by the current document’s browsing context’s Window Proxy object as defined in HTML5 [HTML5].
</dd>

	<dt>`文書@ （ `Document^I ~obj ）</dt>
	<dd>
<a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#i-Document" title="Document Object Model Core">`Document^I ~ifc</a>
`DOM-Level-3-Core$r
<ins> ／ <a href="~DOM4#document">`Document^I</a> ~ifc `DOM$r</ins>
を~instance化する~obj
—
HTML／XML ~text文書 全体を表現する。
概念的には、それは 文書~木の根であり，文書の~dataへの一次的~accessを提供する。
◎
An object instantiating the Document interface [DOM-Level-3-Core], representing the entire HTML or XML text document. Conceptually, it is the root of the document tree, and provides the primary access to the document’s data.
</dd>

	<dt>`要素@ （ `Element^I ~obj ）</dt>
	<dd>
<a href="~DOM4#element">`Element^I</a> ~ifc `DOM$r
を~instance化する~obj
</dd>

	<dt>`木@ （ tree ）</dt>
	<dd>
【この項の内容は、DOM4 仕様の<a href="~DOM4#trees">~node木</a> 節に委譲。】
◎
A data structure that represents a document as a hierarchical set of nodes with child-parent-sibling relationships, i.e., each node having one or more possible ancestors (nodes higher in the hierarchy in a direct lineage), one or more possible descendants (nodes lower in the hierarchy in a direct lineage), and one or more possible peers (nodes of the same level in the hierarchy, with the same immediate ancestor).
</dd>

	<dt>`根~要素@ （ root element ）</dt>
	<dd>
`文書~要素$。
HTML／ XHTML 文書においては、 `html^e 要素が該当する。
◎
The first element node of a document, of which all other elements are children. The document element.
</dd>

	<dt>`~body要素@ （ body element ）</dt>
	<dd>
HTML／ XHTML 文書においては、`根~要素$の，子孫【子？】である `body^e 要素のうち，最初のもの。
~body要素は，文書の内容を表現する。
◎
In HTML or XHTML documents, the body element represents the contents of the document. In a well-formed HTML document, the body element is a first descendant of the root element.
</dd>


	<dt>`空~文字列@ （ empty string ）</dt>
	<dd>
長さ 0 の，`DOMString^I 型~値。
◎
The empty string is a value of type DOMString of length 0, i.e., a string which contains no characters (neither printing nor control characters).
</dd>


	<dt>`~event@ （ event ）</dt>
	<dd>
~eventは、その`標的$に結付けられている何らかの~~出来事（呈示されている要素に対する~mouse~click, 要素からの子~nodeが除去された, その他，いくらでもある）の表現である。
各~eventは、ある特定の`~event型$の~instanceである。
◎
An event is the representation of some occurrence (such as a mouse click on the presentation of an element, the removal of child node from an element, or any number of other possibilities) which is associated with its event target. Each event is an instantiation of one specific event type.
</dd>

	<dt>`未初期化~値@ （ un-initialized value ）</dt>
	<dd>
~eventが `initEvent()$m†
で初期化される前の，各種~event属性（
`bubbles$m や `currentTarget$m
など）が，既定でとるものとされる値。
~eventの未初期化~値は、
`Document.createEvent()$m ~method††
を利用して 新たな~eventが作成される時点で適用される。
◎
The value of any event attribute (such as bubbles or currentTarget) before the event has been initialized with initEvent(). The un-initialized values of an event apply immediately after a new event has been created using the method createEvent().
</dd>
	<dd class="trans-note">【†
または，構築子に与える辞書~型~引数
】【††
または，各種~event~ifcの構築子
】【
この種の値は、 “既定値（ default value ）” 命名されることが多いが、この名前にされている理由は， IDL 用語の “既定値” と区別するためと思われる。
】</dd>

	<dt>`~event型@ （ event type ）</dt>
	<dd>
<em>~event型</em>
は、特定0の名前を持ち, 特定0の［
誘発~条件, ~property, 他の~event型から区別される他の特性
］を定義する`~event$~objである。
例えば、 ~event型 `click$et は， `mouseover$et や `load$et とは異なる特性を持つ。
~event型は、~event~obj上では `type$m 属性として公開される。
詳細は<a href="#event-types">~event型</a>に。
~event型が `click^et である~eventは、
“`click^et ~event”
のように略記されることもある。
◎
An event type is an event object with a particular name and which defines particular trigger conditions, properties, and other characteristics which distinguish it from other event types. For example, the click event type has different characteristics than the mouseover or load event types. The event type is exposed as the type attribute on the event object. See §4 Event Types for more details. Also loosely referred to as "event", such as the click event.
</dd>

	<dt>`~event~focus@ （ event focus ）</dt>
	<dd>
~event~focusは、文書の中の
特定0の要素その他の`~event標的$
において，~~目立たせている／~~注視されているような特別な状態である。
~focusされたときの挙動は、各~要素ごとに その機能性に依存して異なる
— ［
（~buttonや~hyperlinkに対し）要素を作動化~対象の首位に据える ／
（~checkboxに対する）状態の切り替え ／
（~text~form~fieldに対する）~text入力を受取る ／
選択された~textを複製する
］など。
詳細は
<a href="#events-focusevent-doc-focus">文書~focusと~focus文脈</a>
節に。
◎
Event focus is a special state of receptivity and concentration on an particular element or other event target within a document. Each element has different behavior when focused, depending on its functionality, such as priming the element for activation (as for a button or hyperlink) or toggling state (as for a checkbox), receiving text input (as for a text form field), or copying selected text. For more details, see §4.2.3 Document Focus and Focus Context.
</dd>

	<dt>`~event~focus環@ （ event focus ring ）</dt>
	<dd>
~event~focus環とは、文書~内の`~event~focus$の標的になり得るものからなる順序集合である。
`~host言語$は、これらの標的の順序を決定する複数の仕方を定義することもある
— ［
文書~順序 ／
各~focus標的に定義される数的~index ／
各~focus標的に明示的に与えられる次の標的 ／
これらの異なる~modelの~~混成
］など。
文書は、複数の~focus環や条件付き~focus環を包含することもある。
概して、
文書順／~index
に基づく~focus環においては、最後の~focus標的の次の~focusは， “最初へ戻る” 。
◎
An event focus ring is an ordered set of event focus targets within a document. A host language MAY define one or more ways to determine the order of targets, such as document order, a numerical index defined per focus target, explicit pointers between focus targets, or a hybrid of different models. Each document MAY contain multiple focus rings, or conditional focus rings. Typically, for document-order or indexed focus rings, focus wraps around from the last focus target to the first.
</dd>

	<dt>`~event序列@ （ event order ）</dt>
	<dd>
同じ［
~event源／処理
］から生じた~event連列であって、各~eventは，同じまたは関係する~event~ifcを利用しているもの。
例えば，［
~mouse, ~trackpad, ~keyboard,
］などの各種 入力~装置を備える環境では、それぞれが互いに別々の~event源を成し, 自前の~event序列に従うことになる。
~trackpadから `mousedown$et ~eventが生じて,
~mouseから `mouseup$et ~eventが生じても、
`click$et ~eventは生じない。
◎
The sequence in which events from the same event source or process occur, using the same or related event interfaces. For example, in an environment with a mouse, a track pad, and a keyboard, each of those input devices would constitute a separate event source, and each would follow its own event order. A mousedown event from the trackpad followed by a mouseup event from the mouse would not result in a click event.
</dd>
	<dd class="note">注記：
異なる~event序列~間には相互作用があり得る。
例えば、
`click$et ~eventは，同時的な `keydown$et ~eventにより修飾され得る（例えば `Shift^cap ＋ `click^et で）。
しかしながら，これら異なる~event源による~event序列は、別個のものになる。
◎
There can be interactions between different event orders. For example, a click event might be modified by a concurrent keydown event (e.g., via Shift+click). However, the event orders of these different event sources would be distinct.
</dd>
	<dd>
一部の~UIによる~event序列は、装置に依存しない。
例えば利用者は、 `Tab^cap ~keyを利用して, あるいは
~mouseで新たな被focus要素を~clickして，~focusを変更し得る。
そのような事例における~event序列は、状態~変化を起動させた装置の状態ではなく，
処理の状態に依存する。
◎
The event order of some interfaces are device-independent. For example, a user might change focus using the Tab key, or by clicking the new focused element with the mouse. The event order in such cases depends on the state of the process, not on the state of the device that initiates the state change.
</dd>

	<dt>`~event標的@（または単に “標的”）（ event target ）</dt>
	<dd>
<p>
次の二つの意味で用いられる：
</p>

<ul><li><a href="#event-flow">~DOM~event~flow</a>
を利用して，`~event$の標的にされている~obj。
~event標的は、 `target$m 属性で指示される。
</li><li>何らかの~eventに対し，前項の意味で 標的になり得る~obj。
</li></ul>

◎
The object to which an event is targeted using the §3.1 Event dispatch and DOM event flow. The event target is the value of the target attribute.
</dd>

	<dt>`現在の~event標的@ （ current event target ）</dt>
	<dd>
<p>
次の二つの意味で用いられる：
</p>

		<ul>
			<li>
~event~flowにおいて，現在~eventが配送されている`~event~handler$に結付けられている，~obj。
この~objは、当の~event標的か, または その先祖のいずれかになる。
現在の標的は、`~event$が ~event~flowの各種`~event相$を通して
~objから~objへ伝播するに伴って，変化する。
現在の標的は、 `currentTarget$m 属性で指示される。
</li>
			<li>
何らかの~eventに対し，前項の意味で 現在の~event標的になり得る各~obj（すなわち，当の~eventの`伝播~経路$に属する~obj）。
</li>
		</ul>
◎
In an event flow, the current event target is the object associated with the event handler that is currently being dispatched. This object MAY be the event target itself or one of its ancestors. The current event target changes as the event propagates from object to object through the various phases of the event flow. The current event target is the value of the currentTarget attribute.
</dd>


	<dt id="glossary-propagation-path">~eventの`伝播~経路@（ propagation path ）</dt>
	<dd>
`~event$~objが `~event標的$
へ向かって行く／から戻る
道を順々に通過する，`現在の標的$たちからなる順序集合である。
~eventが伝播するに伴い、 `currentTarget$m には，各回ごとに経路に属する`現在の標的$が設定される。
伝播~経路は、`~event型$にて定義されるように，初期~時には一つ以上の`~event相$からなるが、中断されることもある。
“~event標的~連鎖” とも呼ばれる。
◎
The ordered set of current event targets though which an event object will pass sequentially on the way to and back from the event target. As the event propagates, each current event target in the propagation path is in turn set as the currentTarget. The propagation path is initially composed of one or more event phases as defined by the event type, but MAY be interrupted. Also known as an event target chain.
</dd>


	<dt>~eventの`発火-@ （ fire ）</dt>
	<dd>
`DOM$r にて<a href="~DOM4#firing-events">定義されている</a>。
~eventの型, および~eventが生じた文脈に応じて、適切な~ifcを実装する~eventを作成し，適切に属性を初期化した上で，`~event標的$へ向けて`配送$することを意味する（例：
“`click$et ~eventを発火する”
）。
◎
A synonym for dispatch.
</dd>

	<dt>~eventの`配送@ （ dispatch ）</dt>
	<dd>
所与の~eventを，指定された`伝播~経路$を通して伝播させる処理を意味する（例：
“`load$et ~eventを配送する”
）。
◎
To create an event with attributes and methods appropriate to its type and context, and propagate it through the DOM tree in the specified manner. Interchangeable with the term fire, e.g., fire a click event or dispatch a load event.
</dd>

	<dd class="trans-note">【
原文では、 “配送” が上の “発火-” を意味するものとして定義されていて、
“`発火-$” は，配送と~~互換な語であるとされているが、この訳では、 `DOM$r その他の~web仕様の用法に合わせるため，上述のように使い分けて対訳している（この訳の “発火-” の多くは，原文における “配送” の対訳である）。
】</dd>

	<dt id="glossary-phase">`~event相@ （ event phase ）</dt>
	<dd>
<p >
`~event$の文脈においては、相は，~DOM木の 先祖への／子孫への 論理的な走査を表す：
</p>

<ol ><li>`捕獲-相$： `~Window$ → `文書$ → `根~要素$ → … → `~event標的$の親~node
</li><li>`標的~相$： `~event標的$
</li><li>`浮上-相$： 捕獲-相と同じ連鎖の逆順
</li></ol>

◎
In the context of events, a phase is set of logical traversals from node to node along the DOM tree, from the Window to the Document object, root element, and down to the event target (capture phase), at the event target itself (target phase), and back up the same chain (bubbling phase).
</dd>

	<dt id="glossary-bubbling-phase">`浮上-相$ （ bubbling phase ）</dt>
	<dd>
`~event標的$により取扱われた<em>後に</em>，
標的のいずれかの先祖により取扱われ得る`~event$の処理。
詳細は、~event~flowの文脈における `浮上-相$の記述に。
◎
The process by which an event can be handled by one of the target’s ancestors after being handled by the event target. See the description of the bubble phase in the context of event flow for more details.
</dd>

	<dt id="glossary-target-phase">`標的~相$ （ target phase ）</dt>
	<dd>
`~event$が`~event標的$により取扱われ得る処理。
詳細は、~event~flowの文脈における`標的~相$の記述に。
◎
The process by which an event can be handled by the event target. See the description of the target phase in the context of event flow for more details.
</dd>

	<dt id="glossary-capture-phase">`捕獲-相$ （ capture phase ）</dt>
	<dd>
`~event標的$により取扱われる<em>前に</em>，
標的のいずれかの先祖により取扱われ得る`~event$の処理。
詳細は、~event~flowの文脈における `捕獲-相$の記述に。
◎
The process by which an event can be handled by one of the target’s ancestors before being handled by the event target. See the description of the capture phase in the context of event flow for more details.
</dd>

	<dt>`~event~listener@ （ event listener ）</dt>
	<dt>`~event~handler@ （ event handler ）</dt>
	<dd>
`EventListener!I ~ifcを実装する利用者~objであって
`handleEvent()$m ~callback~methodを提供するもの。
~event~handlerは、言語~特有である。
~event~handlerは、特定0の~obj（`現在の~event標的$）の文脈で†，
~event~obj自身を引数に伴って呼出される。
◎
An object that implements the EventListener interface and provides an handleEvent() callback method. Event handlers are language-specific. Event handlers are invoked in the context of a particular object (the current event target) and are provided with the event object itself.
</dd>

<dd class="trans-note">【†
すなわち，~callback this 値がその~objにされた下で。
】【
参考：
`DOM$r による、
<a href="~DOM4#concept-event-listener">~event~listenerの定義</a>。
】</dd>

	<dd class="note">注記：
JavaScript においては、利用者定義の関数は，
`EventListener$I ~ifcを実装するものと見なされる。
したがって、その関数の呼出時には，その最初の引数に~event~objが渡されることになる。
加えて、 JavaScript ~objは，
`handleEvent()$m ~methodを定義して `EventListener$I ~ifcを実装することもできる。
◎
In JavaScript, user-defined functions are considered to implement the EventListener interface. Thus the event object will be provided as the first parameter to the user-defined function when it is invoked. Additionally, JavaScript objects can also implement the EventListener interface when they define a handleEvent method.
</dd>

<!-- ＊
	<dt>候補~event~listenerたち@ （ candidate event listeners ）</dt>
	<dd>
＊未利用

<p>
標的~obj上に登録されている
すべての `~event~listener$からなる，登録された順序による~list。

~eventが標的~objに向けて配送されようとするとき，
現在の~listenerの~listは、
標的~上の~event~listenerに配送される前に＊凍結 captureされ、
~event配送が始まった後に新たに追加された~listenerは， captureされた~listにおける~listenerの順序には影響しないことになる
— 配送が始まった後に除去された~listenerは除去されることになるが。
◎
The list of all event listeners that have been registered on the target object in their order of registration. When an event is about to be dispatched to a target object, the list of current listeners is captured before any event listeners are dispatched on the target. Listeners which are newly added after the event dispatch begins will not affect the order of listeners in the captured list, although listeners which are removed after dispatch begins will be removed.
</p>

<p class="note">注記：
候補~event~listenerたちを配送-前に凍結する, および
新たな~listenerを追加するのを許容しない
ことにより、標的~obj上での~event~listener配送が無限~loopすることは なくなる。
◎
Initially capturing the candidate event handlers and not allowing new listeners to be added prevents infinite loops of event listener dispatch on a given target object.
</p>
</dd>
-->

	<dt>`作動化の挙動@ （ activation behavior ）</dt>
	<dd>
`~event$（概して、利用者により，入力~装置を通して起動される）が、要素に定義されている~taskを履行させるとき採られる動作。
この~taskは、その要素に対し［
`~host言語$,
作者により定義された変数
］あるいはこの両者により，定義されることもある。
与えられた要素に対する既定の~taskは、汎用の動作であったり, その要素に~~固有のものになることもある。
例えば、
HTML／SVG
の `a^e 要素の作動化の挙動は、~UAに `href^a 属性にて指定される~linkを辿らせる
— そのための閲覧文脈を指定するような~parameter（
現在の~window／ある~tab／有名~window／新たな~window
など）を更に伴なうこともある。
例えば、［
`type^a 属性~値が `submit^l にされた HTML `input$e 要素
］に対する作動化の挙動は、
`form^e 要素の一連の値を，作者が与える URI へ向けて 作者が与える HTTP ~methodで送信する。
詳細は、`作動化の誘発と挙動$に。
◎
The action taken when an event, typically initiated by users through an input device, causes an element to fulfill a defined task. The task MAY be defined for that element by the host language, or by author-defined variables, or both. The default task for any given element MAY be a generic action, or MAY be unique to that element. For example, the activation behavior of an HTML or SVG &lt;a&gt; element is to cause the user agent to traverse the link specified in the href attribute, with the further optional parameter of specifying the browsing context for the traversal (such as the current window or tab, a named window, or a new window). The activation behavior of an HTML &lt;input&gt; element with the type attribute value submit is be to send the values of the form elements to an author-defined IRI by the author-defined HTTP method. See §3.5 Activation triggers and behavior for more details.
</dd>

	<dt>`作動化の誘発@ （ activation trigger ）</dt>
	<dd>
`作動化の挙動$を起動するように定義されている~event。
詳細は`作動化の誘発と挙動$に。
◎
An event which is defined to initiate an activation behavior. Refer to §3.5 Activation triggers and behavior for more details.
</dd>

	<dt>`既定~動作@ （ default action ）</dt>
	<dd>
`既定~動作$は、任意選択†の追補的な挙動であって，実装が~event~objの配送と組合せて遂行し~MUSTものである。
各種~event型~定義, および
各種 仕様は、その~event型に対する`既定~動作$があれば，それを定義する。
`作動化の誘発$に結付けられているときなど、状況に応じて，~eventの各~instanceには`既定~動作$が複数ある場合もある。
`既定~動作$は、
`preventDefault()$m ~methodの呼出を通して取消されることもある。
詳細は
<a href="#event-flow-default-cancel">既定~動作と取消可能~event</a>
に。
◎
A default action is an OPTIONAL supplementary behavior that an implementation MUST perform in combination with the dispatch of the event object. Each event type definition, and each specification, defines the default action for that event type, if it has one. An instance of an event MAY have more than one default action under some circumstances, such as when associated with an activation trigger. A default action MAY be cancelled through the invocation of the preventDefault() method. For more details, see §3.2 Default actions and cancelable events.
</dd>
	<dd class="trans-note">【†
どの主体から見て任意選択なのかはっきりしないが、実装ではなく，この仕様を利用する他の仕様？
】</dd>

	<dt>`最上層の~event標的@ （ topmost event target ）</dt>
	<dd>
最上層の~event標的は、`~event標的$になれるような，最も上層に描画される要素で~MUST。
~graphical~UIにおいては、これは，利用者の~pointing装置が~~指す所の~~直下にある要素になる。
この標的の決定は、~UIの “接触判定” に基づく。
接触判定と積層~順序に関する特定の詳細は、`~host言語$を参照のこと。
◎
The topmost event target MUST be the element highest in the rendering order which is capable of being an event target. In graphical user interfaces this is the element under the user’s pointing device. A user interface’s hit testing facility is used to determine the target. For specific details regarding hit testing and stacking order, refer to the host language.
</dd>
	<dd class="trans-note">【
例えば pointer-events ~property（ SVG ）などにより，明示的に接触判定の対象から除外されるものは、最も上層に塗られていても，最上層の~event標的にはならない。
】</dd>

	<dt>`~pointing先@ 【この用語は、この訳による追加】</dt>
	<dd>
~pointing装置が現在 指している`最上層の~event標的$を意味する（存在しない場合は~NULL）。
</dd>

	<dd class="trans-note">【
仕様の記述からは、
“~pointing先が変化した”
と見なされるためには、~pointerが（利用者により）動かされていることも必要とされているように見受けられるが、現実の挙動は，~UAに依存して異なっている。
静止している~pointerに要素が重なったときでも
— 例えば、 DOM ~~操作により要素が追加-／除去されたり, ~animation／~scroll~~操作により —
“変化した”
ものと見なし，~mouse~eventを発火する~UAもあれば、この意味で変化した後，~pointerが動かされた時点で
“変化した”
と見なす~UAもある。
】</dd>

	<dt>`回転@ （ rotation ）</dt>
	<dd>
`WheelEvent$I ~ifcを利用している入力~装置~上の
増分的な変化の指示。
これには、装置により
~wheelの回転動作,
平坦な表面をなぞる動き,
特定0の~buttonの加圧
などがあり得る。
◎
An indication of incremental change on an input device using the WheelEvent interface. On some devices this MAY be a literal rotation of a wheel, while on others, it MAY be movement along a flat surface, or pressure on a particular button.
</dd>

	<dt>`~delta@ （ delta ）</dt>
	<dd>
~UAが `WheelEvent!I ~ifcとして~supportされるような入力~装置（~mouse~wheelや~touchpadなど）の物理的な動きに呼応して，頁を~scrollしたり~zoomするときに見積もられる~scroll量。
`~delta$の値（例：
`deltaX$m, `deltaY$m, `deltaZ$m
属性）は、
`deltaMode$m ~propertyによる`計測~単位$として解釈される。
~wheel（または他の装置）の物理的な動きと`~delta$の正負との関係性は、環境や装置に依存する。
しかしながら，~UAが`既定~動作$として~scrollする場合、`~delta$の正負は`右手~座標系$により与えられる。
◎
The estimated scroll amount (in pixels, lines, or pages) that the user agent will scroll or zoom the page in response to the physical movement of an input device that supports the WheelEvent interface (such as a mouse wheel or touch pad). The value of a delta (e.g., the deltaX, deltaY, or deltaZ attributes) is to be interpreted in the context of the current deltaMode property. The relationship between the physical movement of a wheel (or other device) and whether the delta is positive or negative is environment and device dependent. However, if a user agent scrolls as the default action then the sign of the delta is given by a right-hand coordinate system where positive X,Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.
</dd>


	<dt>`~hysteresis@ （ hysteresis ）</dt>
	<dd>
使用感を改善するために，一定限度まで所在や時間がずれた入力も受容するような、人~ifc設計の特色機能。
例えば、利用者が~mouse~buttonを~double-clickするときの微小な時間差の受容は，時間的~hysteresisであり、利用者が子~menuへ遷移しようとして，~mouseが親~windowから外れたときに，入子の~menuを直ぐに閉じないことは、所在的~hysteresisである。
◎
A feature of human interface design to accept input values within a certain range of location or time, in order to improve the user experience. For example, allowing for small deviation in the time it takes for a user to double-click a mouse button is temporal hysteresis, and not immediately closing a nested menu if the user mouses out from the parent window when transitioning to the child menu is locative hysteresis.
</dd>


	<dt>`文字~値@ （ character value ）</dt>
	<dd>
<p>
~key値の文脈では、文字~値は， 一つ以上の~Unicode文字を表現する文字列である
— 普通字や記号, あるいは 何個かの普通字の並びなど。
この仕様では、文字~値は ~Unicode文字列（例： `0020^U ）, または
同じ符号位置の~glyph表現（例： `X^kGl ）として記され、 2 つの表現を区別し易くするよう色付けられる。
◎
In the context of key values, a character value is a string representing one or more Unicode characters, such as a letter or symbol, or a set of letters. In this specification, character values are denoted as a unicode string (e.g., U+0020) or a glyph representation of the same code point (e.g., ' '), and are color coded to help distinguish these two representations.
</p>

<p class="note">注記：
~source~codeにおいては、非~graphic文字などの一部の~key値は，利用中の~programming言語の文字~escape構文を利用して表現され得る。
◎
In source code, some key values, such as non-graphic characters, can be represented using the character escape syntax of the programming language in use.
</p>
</dd>


	<dt>`~key値@ （ key value ）</dt>
	<dd>
~key値は、特定0の状態にある~keyに結付けられている，`文字~値$ または［
複数~文字からなる文字列（ `Enter$kY, `Tab$kY, `MediaTrackNext$kY など）
］である。
~key値は、［
制御~key, ~function~key, `修飾~key$, `~dead-key$, その他の~key
］も含め，どの~keyにも、`文字~値$を持つかどうかに関わらず，あてがわれる。
与えられた時点の与えられたどの~keyの~key値も、`~key~mapping$に依存する。
◎
A key value is a character value or multi-character string (such as "Enter", "Tab", or "MediaTrackNext") associated with a key in a particular state. Every key has a key value, whether or not it has a character value. This includes control keys, function keys, modifier keys, dead keys, and any other key. The key value of any given key at any given time depends upon the key mapping.
</dd>
<!-- 
	<dt>local name【局所名 — 未利用】</dt>
	<dd>
See local name in [XML-Names11].
</dd>
	<dt>namespace URI</dt>
	<dd>
A namespace URI is a URI that identifies an XML namespace. This is called the namespace name in [XML-Names11]. See also sections 1.3.2 DOM URIs and 1.3.3 XML Namespaces regarding URIs and namespace URIs handling and comparison in the DOM APIs.
</dd>
 -->

	<dt>`修飾~key@ （ modifier key ）</dt>
	<dd>
修飾~keyは、~keyの通常の挙動を変更する
—
（ `Shift^cap ~keyで）異なる文字caseを生産させたり,
（`Fn^cap や `Alt^cap ~keyなどで）~keyが誘発する機能性を改めるなど。
修飾~keyの~listは
<a href="#keys-modifiers">修飾~key節</a>
に。
◎
A modifier key changes the normal behavior of a key, such as to produce a character of a different case (as with the Shift key), or to alter what functionality the key triggers (as with the 'Fn' or Alt keys). Refer to §5.3.1 Modifier keys for a list of modifier keys.
</dd>


	<dt>`~dead-key@ （ dead key ）</dt>
	<dd>
~dead-keyは、自身は文字を生産しないが，［
別の~keyとの
組合せ／連列
により，修飾された文字
— 発音区別符号を伴う文字（例： `ö^kGl, `é^kGl, `â^kGl ）など —
を生産する
］ような，~keyまたは~keyの組合せである。
◎
A dead key is a key or combination of keys which produces no character by itself, but which in combination or sequence with another key produces a modified character, such as a character with diacritical marks (e.g., "ö", "é", "â").
</dd>

	<dt>`~text組成~system@ （ text composition system ）</dt>
	<dd>
何らかの形による代替~入力（`~IME$, 発話~processor, 手書き認識~system
など）を解釈して，それを~textに変換する~software~component。
◎
A software component that interprets some form of alternate input (such as a input method editor, a speech processor, or a handwriting recognition system) and converts it to text.
</dd>

	<dt>`~key~mapping@ （ key mapping ）</dt>
	<dd>
~key~mappingは、特定0の~keyに~key値をあてがう処理であり、いくつかの因子
— ~OSや~keyboard~layout（例： `QWERTY$, Dvorak, Spanish, InScript, Chinese, 等々），および［
`修飾~key$（ `Shift^cap, `Alt^cap, 等々）／ `~dead-key$
］の状態すべてを含む —
を組合せた結果である。
◎
Key mapping is the process of assigning a key value to a particular key, and is the result of a combination of several factors, including the operating system and the keyboard layout (e.g., QWERTY, Dvorak, Spanish, InScript, Chinese, etc.), and after taking into account all modifier key (Shift, Alt, et al.) and dead key states.
</dd>


	<dt>`~IME@ （ input method editor, 入力方式エディタ ）</dt>
<!-- 
	<dt id="glossary-input-method-editor"></dt>
-->
	<dd>
~IMEは、一連の~keystrokeから表意文字その他の文字への変換を
— 通例的に，利用者により手引される辞書検索により —
遂行する~appであり、東アジア圏の言語（例：中国語, 日本語, 韓国語）でよく利用される。
~IMEは、携帯機器などでも単語の入力補完に利用されることもある。
この仕様における~IMEの扱いについては、
<a href="#keys-IME">~IME節</a>に。
`~text組成~system$
も見よ。
◎
An input method editor (IME), also known as a front end processor, is an application that performs the conversion between keystrokes and ideographs or other characters, usually by user-guided dictionary lookup, often used in East Asian languages (e.g., Chinese, Japanese, Korean). An IME MAY also be used for dictionary-based word completion, such as on mobile devices. See §5.3.3 Input Method Editors for treatment of IMEs in this specification. See also text composition system.
</dd>



<!-- 
namespace URI 未利用
-->


	<dt>`QWERTY@</dt>
	<dd>
QWERTY（ “ˈkwɜrti” と発音される）は、
共通的な~keyboard~layoutの普通字~keyの上段の最初の 6 文字が
Q, W, E, R, T, Y
であることから命名されている。
他にも普及している~keyboard~layoutは数多くあり（~Dvorakや~Colemak~layoutなど）、そのほとんどは，地域化や人間工学のために設計されている。
◎
QWERTY (pronounced ˈkwɜrti) is a common keyboard layout, so named because the first five character keys on the top row of letter keys are Q, W, E, R, T, and Y. There are many other popular keyboard layouts (including the Dvorak and Colemak layouts), most designed for localization or ergonomics.
</dd>

	<dt>`~Unicode字種@ （ Unicode character categories ）</dt>
	<dd>
各~Unicode符号位置に対し定義されている
General Category 値の部分集合。
この部分集合には、次の字種に属するものすべてが包含される：
<ul>
	<li>
普通字（ Letter ）：
<abbr title="Letter, Lowercase">Ll</abbr>,
<abbr title="Letter, Modifier">Lm</abbr>,
<abbr title="Letter, Other">Lo</abbr>,
<abbr title="Letter, Titlecase">Lt</abbr>,
<abbr title="Letter, Uppercase">Lu</abbr>
</li>
	<li>
数字（ Number ）：
<abbr title="Number, Decimal Digit">Nd</abbr>,
<abbr title="Number, Letter">Nl</abbr>,
<abbr title="Number, Letter">NO</abbr>
</li>
	<li>
約物（ Punctuation ）：
<abbr title="Punctuation, Connector">Pc</abbr>,
<abbr title="Punctuation, Dash">Pd</abbr>,
<abbr title="Punctuation, Close">Pe</abbr>,
<abbr title="Punctuation, Final quote">Pf</abbr>,
<abbr title="Punctuation, Initial quote">Pi</abbr>,
<abbr title="Punctuation, Other">Po</abbr>,
<abbr title="Punctuation, Open">Ps</abbr>
</li>
	<li>
記号（ Symbol ）：
<abbr title="Symbol, Currency">Sc</abbr>,
<abbr title="Symbol, Modifier">Sk</abbr>,
<abbr title="Symbol, Math">Sm</abbr>,
<abbr title="Symbol, Other">So</abbr>
</li>
</ul>

◎
A subset of the General Category values that are defined for each Unicode code point. This subset contains all the Letter (Ll, Lm, Lo, Lt, Lu), Number (Nd, Nl, No), Punctuation (Pc, Pd, Pe, Pf, Pi, Po, Ps) and Symbol (Sc, Sk, Sm, So) category values.
</dd>

	<dt>`~DOM0@ （ DOM Level 0 ）</dt>
	<dd>
用語
“~DOM0”
は， HTML 文書の種々の機能性の混成を指し、公式的には指定されていないことが多いが，伝統的に，事実上の標準として~supportされているものである。
元々は
Netscape Navigator 3.0 や,
Microsoft Internet Explorer 3.0
により実装された。
属性や~methodは、多くの事例で
“~DOM0” との後方互換性の理由から含められている。
◎
The term DOM Level 0 refers to a mix of HTML document functionalities, often not formally specified but traditionally supported as de facto standards, implemented originally by Netscape Navigator version 3.0 or Microsoft Internet Explorer version 3.0. In many cases, attributes or methods have been included for reasons of backward compatibility with DOM Level 0.
</dd>
</dl>


	</section>

</main></div>

	<section id="references">

<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範的）</h3>

<p class="trans-note">【
<a href="uievents-appendix-ja.html">付録ページ</a>のみから参照されているものは省略する。
】</p>

<!-- appendix
RFC2119

informative:
RFC20
US-ASCII
WIN1252
XFORMS
-->

<script type="text/plain" class="ref_data">

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[DOM-Level-2-Events]
    Tom Pixley. Document Object Model (DOM) Level 2 Events Specification. 13 November 2000. REC. URL: https://www.w3.org/TR/DOM-Level-2-Events/ 
[DOM-Level-3-Core]
    Arnaud Le Hors; et al. Document Object Model (DOM) Level 3 Core Specification. 7 April 2004. REC. URL: https://www.w3.org/TR/DOM-Level-3-Core/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTML5]
    Ian Hickson; et al. HTML5. 28 October 2014. REC. URL: https://www.w3.org/TR/html5/ 
[SVG2]
    Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. 15 September 2016. CR. URL: https://www.w3.org/TR/SVG2/ 
[UIEvents-Code]
    Gary Kacmarcik; Travis Leithead. UI Events KeyboardEvent code Values. 24 October 2016. WD. URL: https://www.w3.org/TR/uievents-code/ 
[UIEvents-Key]
    Gary Kacmarcik; Travis Leithead. UI Events KeyboardEvent key Values. 24 October 2016. WD. URL: https://www.w3.org/TR/uievents-key/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. WD. URL: https://www.w3.org/TR/WebIDL-1/ 
</script>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">

[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2 
[DWW95]
    N. Kano. Developing International Software for Windows 95 and Windows NT: A Handbook for International Software Design. 1995. 
[Editing]
    A. Gregor. HTML Editing APIs. URL: https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html 
[HTML40]
    Dave Raggett; Arnaud Le Hors; Ian Jacobs. HTML 4.0 Recommendation. 24 April 1998. REC. URL: https://www.w3.org/TR/html40 
[UAAG20]
    James Allan; et al. User Agent Accessibility Guidelines (UAAG) 2.0. 15 December 2015. NOTE. URL: https://www.w3.org/TR/UAAG20/ 
[UAX15]
    Mark Davis; Ken Whistler. Unicode Normalization Forms. 31 August 2012. Unicode Standard Annex #15. URL: http://www.unicode.org/reports/tr15 
[Unicode]
    The Unicode Standard. URL: http://www.unicode.org/versions/latest/ 
[XML-Names11]
    Tim Bray; et al. Namespaces in XML 1.1 (Second Edition). 16 August 2006. REC. URL: https://www.w3.org/TR/xml-names11/
</script>




		</section>
	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>

</body></html>

