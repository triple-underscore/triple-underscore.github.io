<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>UI Events （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
img {
	background: white;
}
.glyph {
	color: var(--K-color);
	background: var(--O-bg);
}

.key-cap {
	border: outset thin var(--N-color);
	font-family: sans-serif0, sans-serif;
}

.key, .key-code, .key-cap {
	padding:0 0.2em;
	color: var(--K-color);
	border-radius: 3px;
}

.key {
	/* event.key */
	background: var(--C-bg);
}
.key-code {
	/* event.code */
	background: var(--V-bg);
}

tr {
	border-top: thin solid var(--table-rule-color);
}

@supports (grid-template-columns: subgrid) and (display: contents) {

#_event-list {
	grid-template-columns: 4em 1fr 1fr 1fr;
	min-width: 32em;
	max-width: 54em;
}

#_event-list tr {
	grid-template-areas:
		"型 型 型 型"
		". 同期 浮上 取消"
		". 標的 標的 interface"
		". 動作 動作 動作"
	;
}

#_event-list tr > *:nth-child(1) {
	grid-area: 型;
	border-left-width: 0;
}

#_event-list tr > *:nth-child(2) {
	grid-area: 同期;
}

#_event-list tr > *:nth-child(3) {
	grid-area: 浮上;
}

#_event-list tr > *:nth-child(4) {
	grid-area: 標的;
}

#_event-list tr > *:nth-child(5) {
	grid-area: interface;
}

#_event-list tr > *:nth-child(6) {
	grid-area: 取消;
}

#_event-list tr > *:nth-child(7) {
	grid-area: 動作;
	min-height: 1.3em;
}

}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	let current_ifc = '#';

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.*?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'e':
	text = `&lt;${key}&gt;`;
	break;
case 'kY': // key event .key value
	href = `~UIEVENTS-KEY#key-${key}`;
	break;
case 'kC': // key event .code value
	href = `~UIEVENTS-CODE#code-${key}`;
	break;
case 'kGl': // key glyph
	text = `"<code class="glyph">${key}</code>"`;
	break;
case 'cap': // key cap
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'I':
	if((indicator === '@') || (indicator === '!')){
		current_ifc = `#dom-${key.toLowerCase()}-`;
	}
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`;
	break;
case 'm' :
	let n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	n = key.indexOf('.');
	if(n < 0 ) {
		href = current_ifc + key.toLowerCase();
	} else {
		text = text.slice(n + 1);
		href = `#dom-${key.replace(/\./, '-').toLowerCase()}`;
	}
	break;
case 'et':
	href = `#${key.toLowerCase()}`;
	//href = `#event-type-${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'cn':
	text = key.toUpperCase();
	break;
case 'APX':
	return (
`<p class="trans-note">【この節の和訳は<a href="~UIEVENTS-A#${key}">別~page</a>にて。】</p>`
	);
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2024-09-07
trans_update:2024-06-22
source_checked:240613
page_state_key:UIEVENTS
original_url:https://w3c.github.io/uievents/
	http://www.w3.org/TR/uievents/
	abbr_url:UIEVENTS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
	conformance:w3c
copyright:2024,permissive
trans_1st_pub:2015-08-28


●●class_map
E:error
et:event-type
e:element
a:attr
kY:key
U:code-point
kC:key-code
cap:key-cap
css:css
p:css
cn:cp-name

●●tag_map
c:code
I:code
m:code
E:code
et:code
e:code
a:code
css:code
p:code
kY:code
U:span
kC:code
cap:span
v:var
cn:span
i:i
em:em
cite:cite

●●navs
イベント:.eventdef

●●original_id_map

	uievent:uievent-uievent
	keyboardevent:keyboardevent-keyboardevent
element:

	_modifiers-map:shift-flag
	_modifiers-map:control-flag
	_modifiers-map:alt-flag
	_modifiers-map:altgraph-flag
	_modifiers-map:meta-flag

	initialize-a-uievent:initialize-a-uievent-id
	initialize-a-mouseevent:initialize-a-mouseevent-id
	_create-a-mouseevent:create-a-cancelable-mouseevent
	_create-a-mouseevent:create-a-cancelable-mouseevent-id
	_create-a-mouseevent:create-a-non-cancelable-mouseevent
	_create-a-mouseevent:create-a-non-cancelable-mouseevent-id
	set-mouseevent-attributes-from-native:set-mouseevent-attributes-from-native-id
	handle-native-mouse-down:handle-native-mouse-down-id
	handle-native-mouse-up:handle-native-mouse-up-id
	handle-native-mouse-click:handle-native-mouse-click-id
	handle-native-mouse-double-click:handle-native-mouse-double-click-id
	handle-native-mouse-move:handle-native-mouse-move-id
	set-mouse-event-modifiers:set-mouse-event-modifiers-id
	calculate-mouseevent-button-attribute:calculate-mouseevent-button-attribute-id
	calculate-dom-path:calculate-dom-path-id
	hit-test:hit-test-id
	initialize-pointerlock-attributes-for-mouseevent:initialize-pointerlock-attributes-for-mouseevent-id
	set-pointerlock-attributes-for-mousemove:set-pointerlock-attributes-for-mousemove-id
	initialize-a-pointerevent:initialize-a-pointerevent-id
	create-a-pointerevent:create-a-pointerevent-id
	create-pointerevent-from-mouseevent:create-pointerevent-from-mouseevent-id
	send-click-event:send-click-event-id
	maybe-show-context-menu:maybe-show-context-menu-id

	_maybe-send-pointer-event:maybe-send-pointerdown-event
	_maybe-send-pointer-event:maybe-send-pointerdown-event-id
	_maybe-send-pointer-event:maybe-send-pointerenter-event
	_maybe-send-pointer-event:maybe-send-pointerenter-event-id
	_maybe-send-pointer-event:maybe-send-pointerleave-event
	_maybe-send-pointer-event:maybe-send-pointerleave-event-id
	_maybe-send-pointer-event:maybe-send-pointermove-event
	_maybe-send-pointer-event:maybe-send-pointermove-event-id
	_maybe-send-pointer-event:maybe-send-pointerout-event
	_maybe-send-pointer-event:maybe-send-pointerout-event-id
	_maybe-send-pointer-event:maybe-send-pointerover-event
	_maybe-send-pointer-event:maybe-send-pointerover-event-id
	_maybe-send-pointer-event:maybe-send-pointerup-event
	_maybe-send-pointer-event:maybe-send-pointerup-event-id

●●mdn_urls
compositionevent:API/CompositionEvent
contextmenu:API/Element/contextmenu_event
focusevent:API/FocusEvent
inputevent:API/InputEvent
keyboardevent:API/KeyboardEvent
mouseevent:API/MouseEvent
uievent:API/UIEvent
wheelevent:API/WheelEvent
	dictdef-compositioneventinit:API/CompositionEventInit
	dictdef-eventmodifierinit:API/EventModifierInit
	dictdef-focuseventinit:API/FocusEventInit
	dictdef-inputeventinit:API/InputEventInit
	dictdef-keyboardeventinit:API/KeyboardEventInit
	dictdef-mouseeventinit:API/MouseEventInit
	dictdef-uieventinit:API/UIEventInit
	dictdef-wheeleventinit:API/WheelEventInit

	load:？/load
	unload:？/unload
	abort:？/abort
error:API/Element/error_event
select:API/Element/select_event
beforeinput:API/HTMLElement/beforeinput_event
input:API/HTMLElement/input_event
auxclick:API/Element/auxclick_event
blur:API/Element/blur_event
click:API/Element/click_event
compositionend:API/Element/compositionend_event
compositionstart:API/Element/compositionstart_event
compositionupdate:API/Element/compositionupdate_event
dblclick:API/Element/dblclick_event
focus:API/Element/focus_event
focusin:API/Element/focusin_event
focusout:API/Element/focusout_event
keydown:API/Element/keydown_event
keyup:API/Element/keyup_event
mousedown:API/Element/mousedown_event
mouseenter:API/Element/mouseenter_event
mouseleave:API/Element/mouseleave_event
mousemove:API/Element/mousemove_event
mouseout:API/Element/mouseout_event
mouseover:API/Element/mouseover_event
mouseup:API/Element/mouseup_event
wheel:API/Element/wheel_event

●●link_map

Exposed:~WEBIDLjs#Exposed

boolean:~WEBIDL#idl-boolean
long:~WEBIDL#idl-long
short:~WEBIDL#idl-short
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
double:~WEBIDL#idl-double
unrestricted double:~WEBIDL#idl-unrestricted-double
DOMString:~WEBIDL#idl-DOMString
USVString:~WEBIDL#idl-USVString

I.EventTarget:~DOM4#eventtarget
I.EventListener:~DOM4#callbackdef-eventlistener
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.CustomEvent:~DOM4#customevent
I.XMLHttpRequest:~XHR#xmlhttprequest
I.MutationObserver:~DOM4#mutationobserver

I.UIEvent:#uievent
I.UIEventInit:#dictdef-uieventinit
I.FocusEvent:#focusevent
I.FocusEventInit:#dictdef-focuseventinit
I.MouseEvent:#mouseevent
I.MouseEventInit:#dictdef-mouseeventinit
I.EventModifierInit:#dictdef-eventmodifierinit
I.WheelEvent:#wheelevent
I.WheelEventInit:#dictdef-wheeleventinit
I.InputEvent:#inputevent
	I.InputEvent:#interface-InputEvent
I.InputEventInit:#dictdef-inputeventinit
I.KeyboardEvent:#keyboardevent
I.KeyboardEventInit:#dictdef-keyboardeventinit
I.CompositionEvent:#compositionevent
I.CompositionEventInit:#dictdef-compositioneventinit

I.PointerEvent:~POINTEREVENTS#dom-pointerevent
	#pointerevent-interface

I.Element:~DOM4#element
I.Document:~DOM4#document
	I.Document:#interface-Document
I.Window:~WINDOW#window
I.WindowProxy:~HTMLWPROXY#windowproxy
I.HTMLInputElement:~HEinput#htmlinputelement

et.keypress:~UIEVENTS-A#event-type-keypress
et.pointerdown:~POINTEREVENTS#the-pointerdown-event
et.pointerup:~POINTEREVENTS#the-pointerup-event
et.pointermove:~POINTEREVENTS#the-pointermove-event
et.pointerrawupdate:~POINTEREVENTS#the-pointerrawupdate-event

et.DOMActivate:~UIEVENTS-A#event-type-DOMActivate

	m.~indata:#dom-inputevent-data
	m.~compdata:#dom-compositionevent-data
	m.target:#dom-event-target

m.InputEvent.data:#dom-inputevent-data

m.NONE:~DOM4#dom-event-none
m.CAPTURING_PHASE:~DOM4#dom-event-capturing_phase
m.AT_TARGET:~DOM4#dom-event-at_target
m.BUBBLING_PHASE:~DOM4#dom-event-bubbling_phase

m.addeventlistener:~DOM4#dom-eventtarget-addeventlistener
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.charCode:~UIEVENTS-A#dom-keyboardevent-charcode
m.composed:~DOM4#dom-event-composed
m.currentTarget:~DOM4#dom-event-currenttarget
m.defaultPrevented:~DOM4#dom-event-defaultprevented
	m.detail:~DOM4#dom-customevent-detail
m.elementFromPoint:~CSSOMVIEW#dom-document-elementfrompoint
m.elementsFromPoint:~CSSOMVIEW#dom-document-elementsfrompoint
m.eventPhase:~DOM4#dom-event-eventphase
m.initEvent:~DOM4#dom-event-initevent
m.initCustomEvent:~DOM4#dom-customevent-initcustomevent
m.initMouseEvent:~UIEVENTS-A#dom-mouseevent-initmouseevent
m.isTrusted:~DOM4#dom-event-istrusted
m.keyCode:~UIEVENTS-A#dom-keyboardevent-keycode
m.movementX:~POINTERLOCK#dom-mouseevent-movementx
m.movementY:~POINTERLOCK#dom-mouseevent-movementy
m.preventDefault:~DOM4#dom-event-preventdefault
m.removeeventlistener:~DOM4#dom-eventtarget-removeeventlistener
m.stopPropagation:~DOM4#dom-event-stoppropagation
m.stopImmediatePropagation:~DOM4#dom-event-stopimmediatepropagation
m.type:~DOM4#dom-event-type
m.target:~DOM4#dom-event-target
	m.target → ev.~target
m.timeStamp:~DOM4#dom-event-timestamp
m.which:~UIEVENTS-A#dom-uievent-which


m.dispatchEvent:~DOM4#dom-eventtarget-dispatchevent
m.createEvent:~DOM4#dom-document-createevent
m.handleEvent:~DOM4#dom-eventlistener-handleevent

	m.view:#dom-uievent-view
	m.detail:#dom-uievent-detail

m.Document.getSelection:~SELECTIONAPI#dom-document-getselection

e.textarea:~HEforms#the-textarea-element
e.input:~HEinput#the-input-element

p.pointer-events:~CSSUI#propdef-pointer-events

	●用語
内部~UIkey修飾~状態:#internal-key-modifier-state
~UIkey修飾~名:#modifier-key-name

組成~event:#events-compositionevents
~focus~event:#events-focusevent
~keyboard~event:#events-keyboardevents
~mouse~event:#events-mouseevents
~wheel~event~transaction:#wheel-event-transaction
現在の~click回数:#current-click-count

	●用語（algo
~mouse~button名:#_mouse-button-name
表示域~座標:#_viewport-coordinates
	~desktop座標:#_desktop-coordinates
修飾~UIkey状態:#key-modifier-state
修飾~UIkey状態~map:#_modifiers-map

~UIEventを初期化する:#initialize-a-uievent
~mouse~button~bitmask:#mouse-button-bitmask
最後の~mouse要素:#last-mouse-element
最後の~mouse~DOM経路:#last-mouse-dom-path

~MouseEventを初期化する:#initialize-a-mouseevent
~MouseEvent属性を~nativeな~eventから設定する:#set-mouseevent-attributes-from-native
~nativeな~mousedownを取扱う:#handle-native-mouse-down
~nativeな~mouseupを取扱う:#handle-native-mouse-up
~nativeな~clickを取扱う:#handle-native-mouse-click
~nativeな~double-clickを取扱う:#handle-native-mouse-double-click
~nativeな~mousemoveを取扱う:#handle-native-mouse-move
~mouse~eventの修飾~UIkey状態を設定する:#set-mouse-event-modifiers
~MouseEventを作成する:#_create-a-mouseevent
~button名を整数に変換する:#calculate-mouseevent-button-attribute
~DOM経路を計算する:#calculate-dom-path
接触判定する:#hit-test
最後の~mousemove位置:#last-mouse-move
~MouseEvent用に各~pointer~lock属性を初期化する:#initialize-pointerlock-attributes-for-mouseevent
~mousemove用に各~pointer~lock属性を設定する:#set-pointerlock-attributes-for-mousemove
~PointerEventを初期化する:#initialize-a-pointerevent
~PointerEventを作成する:#create-a-pointerevent
~MouseEventから~PointerEventを作成する:#create-pointerevent-from-mouseevent
~click~eventを送信する:#send-click-event
必要なら文脈~menuを示す:#maybe-show-context-menu
必要なら~pointer~eventを送信する:#_maybe-send-pointer-event

	●§
§ ~keyboard~eventと~UIkey値:#keys
各種~UI~eventに共通な文脈~情報:#_common-UI-event-context
各種~mouse~eventに共通な文脈~情報:#_common-mouse-event-context
各種~入力~eventに共通な文脈~情報:#_common-input-event-context
各種~keyboard~eventに共通な文脈~情報:#_common-keyboard-event-context
	各種~変異~eventに共通な文脈~情報:#_common-mutation-event-context
各種~組成~eventに共通な文脈~情報:#_common-composition-event-context

	●補完
~pointing先:#_pointing
有効に変化-:#_effectively-changed
測定~単位:#_scroll-unit
右手~座標系:#_right-hand-coordinate-system

	●appendix
作者:~UIEVENTS-A#author
非推奨:~UIEVENTS-A#deprecated
非推奨に:~UIEVENTS-A#deprecated
~host言語:~UIEVENTS-A#host-language

修飾~UIkeyの表t:~UIEVENTS-KEY#keys-modifier
~UIkey属性~値:~UIEVENTS-KEY#key-attribute-value

	●用語集
作動化の誘発:#activation-trigger
~body要素:#body-element
文字~値:#character-value
現在の~target:#current-event-target
~dead-key:#dead-key
既定~動作:#default-action
~delta:#delta
要素:#element
空~文字列:#empty-string
~event型:#event-type
~event~focus:#event-focus
~focus:#event-focus
~focus環:#event-focus-ring
~event~focus環:#event-focus-ring
~event~target:#event-target
~target:#event-target
	~target:~DOM4#event-target
最上層の~event~target:#topmost-event-target
~hysteresis:#hysteresis
~IME:#ime
	入力~method~editor:#input-method-editor
~UIkey対応付け:#key-mapping
~UIkey値:#key-value
~UIkey~code:#keys-codevalues

修飾~UIkey:#modifier-key
QWERTY:#qwerty
根~要素:#root-element
回転:#rotation
~text組成~system:#text-composition-system
~Unicode字種:#unicode-character-categories
未初期化~値:#un-initialized-value

~trusted:#_trusted-event
取消~可能:#_cancelable
浮上-:#_bubbles

	●外部
~UA:~INFRA#user-agent
~map:~INFRA#ordered-map
連結する:~INFRA#string-concatenate
付加する:~INFRA#list-append

首~pointer:~POINTEREVENTS#the-primary-pointer

先祖:~DOM4#concept-tree-ancestor
広義-先祖:~DOM4#concept-tree-inclusive-ancestor
文書:~DOM#concept-document
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
~event:~DOM4#concept-event
~eventを作成する:~DOM4#concept-event-create
~eventを初期化する:~DOM4#concept-event-initialize
配送-:~DOM4#concept-event-dispatch
~eventを配送する:~DOM4#concept-event-dispatch
作動化の挙動:~DOM4#eventtarget-activation-behavior
ev.~target:~DOM4#event-target
~event~listener:~DOM4#concept-event-listener

捕捉-相:~DOM4#dom-event-capturing_phase
~target相:~DOM4#dom-event-at_target
浮上-相:~DOM4#dom-event-bubbling_phase

~event~handler:~WAPI#event-handlers
~window:~WINDOW#the-window-object
fe.不能化されて:~HTMLforms#concept-fe-disabled
~clickで~focus可能:~HTMLinteraction#click-focusable
~focus可能な区画:~HTMLinteraction#focusable-area
不活:~HTMLinteraction#inert
~objを~focusする:~HTMLinteraction#focusing-steps

~box~tree:~CSSDISP#box-tree
表示域:~CSS2J#viewport
積層~文脈:~CSS2J#stacking-context
有位置:~CSSPOS#positioned-box
積層~文脈を塗る:~CSSPOS4#paint-a-stacking-context

~hover_ps 疑似類:~SELECTORS4#the-hover-pseudo


●●words_table1
UAAG20:http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/
	http://www.w3.org/TR/UAAG20/
UIEVENTS-A:uievents-appendix-ja.html
	https://w3c.github.io/uievents/
UIEVENTS-KEY:uievents-key-ja.html
	https://www.w3.org/TR/uievents-key/
UIEVENTS-CODE:https://www.w3.org/TR/uievents-code/
POINTERLOCK:https://w3c.github.io/pointerlock/

compdata:data
aT:@
hover_ps:<code class="css">:hover</code>
SPACEBAR:<span style="color:var(--pale-color)"> Space </span>

集約簡略化:<p class="trans-note">【この訳では、各所に共通な記述をこの節に集約する。】</p>


●●words_table

	●略称／名称
Events:
Event:

IME:
PC:
XHTML:

UIEvent:
MouseEvent:
PointerEvent:

	unicode
	window:Window
	QWERTY
	Windows
	Macintosh
	MacOS
	Chrome
	Firefox
	Linux
	Latin Small Letter
	~pointer~lock:PointerLock
	DOM Level 2
	DOM Level 0:DOM0

	●event flow
序列:order::~::オーダー
組成:composition::~
組成-:compose::~
	組成-済み:composed
	~text組成
	組成~event:Composition Events:::組成イベント
	Composition Events
	:composing

誘発:trigger::~
trusted:
	~trustedでない:untrusted
	信用済み
相:phase::~::フェイズ
	target:::ターゲット
	at-target:
捕捉-:capture::~::キャプチャ
経路:path::~::パス
作動-:actuate::~::アクチュエート
活動:activity:~:::アクティビティ

最上層の:topmost:~
文脈依存:varies:~
到着-:arrive:~
合成な:syntheticな::~

	から出て行く際の:for leaving
	へ入って行く際の:for entering

	●処理一般
相互相対順序:set order relative to one another:互いに相対的な順序
発する:emitする:~
復帰-:revert:~
立上げる:launchする:立ち上げる
立上げら:launchさ:立ち上げら
稼働-:run:~
無視r:disregard:無視することに
経過-:elapse:~
持続-:persist:~
後続-:follow:~
	後続-:followed by
初期化子:initializer:~
未初期化:un-initialized:~
渡して:passして:~
受動的:passive::~
scrolling::::スクロール処理
合体-:coalesce::~
丸めた:roundした:~
丸めら:roundさ:~
近過去:recent:~

	進捗~中:in-progress
	起動-:initiation
	状態~変化-中にある:state-changing
	直後:immediately after
	直後:after
	時点:at the time
	この時点:at this point
	1 にする:set
	0 にする:clear
	ε:undefined
	~RET:exit

	●変数
contextmenu:
mousemove:
mousedown:
mouseup:
mouseover:
mouseout:
mouseenter:
mouseleave:

	%~button~ID:mbutton
	%~nativeな~event:native
	%~event:event
	%~mouse~event:mouseevent
	%~event型:eventType
	%~event~target:eventTarget
	%浮上するか:bubbles
	%取消~可能か:cancelable
	%取消されなかったか:result
	%~target~DOM経路:targetDomPath
	%要素:element
	%位置:pos
	%経路:path
	%~x:-
	%~y:-
	%動き~x:-
	%動き~y:-
	%修飾~状態:-
	%~UIkey名:-
	%~contextmenu:menuevent
	%~mouseout:mouseout
	%~mouseleave:mouseleave
	%~mouseover:mouseover
	%~mouseenter:mouseenter
	%~mousemove:mousemove
	%~mouseenter要素~群:enterElements
	%~mouseleave要素~群:leaveElements

	●構造
広義-:inclusive:~
先行-:precede::~
	child-parent-sibling::親, 子, 同胞

	●UI
double-click::::ダブルクリック
	~double-click:mouse double-click
	~click:mouse click
	~mousedown:mouse down
	~mouseup:mouse up

delta::::デルタ
desktop::::デスクトップ
環:ring::~
被focus:focused:被 focus::被フォーカス
tabbing::::タブキー操作
shortcut::::ショートカット

失う:loseする:~
失っ:loseし:~
	~UItab帯:tab-strip
voice::::ボイス
touch::::タッチ
macro::::マクロ
player::::プレイヤー
game::::ゲーム
checkbox::::チェックボックス
	~graphicな:graphical
	~URL~bar:Web site location bar
接触判定:hit testing:~
接触判定-:hit test:~
使用感:user experience:~
知覚-:percept:~
	perceptible
真似て:mimicして:~
模倣-:emulate:~
模造-:simulate:模倣
人間工学:ergonomics:~
	~~外見上の~~類似:superficial resemblance
許容誤差:tolerance::~
hysteresis::::ヒステリシス
淵:edge:~
速度:speed:~
頻度:rate:~
頻度0:frequency:頻度
時間的:temporal:~
所在的:locative:~
重合する:overlapする:重なり合う
積層-:stack:~
積層:stacking:~
窓:window:~
投入-:feed:~
不活:inert::~

	~pointing先:containing block
	単-~button:single-button
	:WASD
	時間~内で:amount of time
	最も前面:frontmost

	●UI 操作
~操作
zoom::::ズーム
	~zoom時／~zoom~~操作:zooming
shift:
	~shiftなし:unshifted
	~shiftあり:shifted
	-:shift-state
	切替わる
	~~切替えた:shiftした
drag::::ドラッグ
	:image-drag
drop::::ドロップ
押圧:pressure:~
打込んだ:typeした:打ち込んだ:::タイプした
打込まれ:typeされ:打ち込まれ:::タイプされ
叩いた:hitした:~
押下げら:depressさ:~
	-:long depression
押-:press:~
押す:pressする:~
	~UIkeyの長押し:long-key-press
	押:down
	~~押下げ:down
	~~押されている:being held
離す:releaseする:~
離-:release:~
	離:up
手書き:handwriting:~
操作o:operation:操作
開く:openする:~
閉じる:closeする:~
閉じな:closeしな:~
閉じら:closeさ:~
退けら:dismissさ:~
動き:movement:~
動く:moveする:~
動いた:moveした:~
動いて:moveして:~
動かさ:moveさ:~
動かす:moveさせる:~
選択-:select:~
選択:selection:~
編集-:edit:~
編集:editing:~
transaction::::トランザクション

	一定時間:sustained period
	~~持続的な:sustained
	~~持続的に:sustained manner
	境界をまたいだ:moved onto the boundaries
	同時に複数の軸が回転された場合、:diagonal
	~~移動距離や~~頻度:lag time, degree, distance, and number of
	同じ時機に生じ:temporal occurrence
	複数回 生じ得る:Multiple mousemove events
	0 回 以上生じ得る:OPTIONAL, multiple events
	微小な時間差:small deviation in the time
	1 画素~単位より精細に:sub-pixel

	●UI keyboard
locale::::ロケール
対応付-:mapし::~
	対応付-直:remap
	〜用の`~UIkey対応付け$:mapping
keystroke::::キーストローク
function::::ファンクション
scancode::::スキャンコード
switch::::スィッチ
銘:legend::~
US:
	US 配列
Romaji::::ローマ字
Arabic::::アラビア語
Colemak:
Dvorak:
French::::フランス語配列
Serbian::セルビア語
中国語:Chinese:~
日本語:Japanese:~
韓国語:Korean:~
漢字:Kanji characters:~
数字n:number:数字
umlaut::::ウムラウト
大文字形:majuscule form (uppercase or capital letters):~
小文字形:minuscule form (lowercase or small letters):~
	~key-state::::
	~Form::::
書記体系:writing system:~
普通字:letter::~
asterisk::::アスタリスク
約物:punctuation:~
accent::::アクセント符
表語文字:logogram:~
字種:character categories:~
異形同音異義語:homophone:~
発音-:pronounce:~
発音区別符:diacritic:~
発音区別符号:diacritical-mark:~
符号:sign:~
行高:line-height:~
表意文字:ideograph:~
修飾:modifier:~
	修飾~UIkey:modifiers
修飾-:modify:~
未修飾:unmodified:~
候補:candidate:~
所在-:locate:~
矢印:arrow:~

	対にする:matchさせる
	対を成さない:unmatched
	対を成す:matching
	対を成さない:dangling
	記号:Symbol

	`Shift^l:shift
	`Control^l:control
	`Alt^l:alt
	`AltGraph^l:altgraph
	`Meta^l:meta

	●装置
pointing::::ポインタ指示
wheel::::ホイール
pen::::ペン
tablet::::タブレット
swipe::::スワイプ
pan::::パン
	~pan~~操作:panning

trackball::::トラックボール
trackpad::::トラックパッド
mouse-ball::::マウスボール
touchpad::::タッチパッド

物理的0:mechanical:物理的
携帯:mobile::~::モバイル
表面:surface:~
右手:right-hand:~
回転-:rotate:~
回転:rotation:~
回転動作:literal rotation:~
高速化:speed-up:~
加速機能:acceleration:~
加速:accelerator:~

首:primary:~
副:secondary:~
中央:middle:中
X1:
X2:
右:right:~
左:left:~

hotkey::::ホットキー
cap::::キャップ
PC101US:PC 101 Key US::PC 101 US
dead-key::::デッドキー
	dead key
十key:numeric keypad:::テンキーの類
numpad:numeric pad:::テンキー
access-key:access key:::アクセスキー
目印:marking:~
印字-:mark:~
	-:printable


	●仕様
機種:model:~
標準的:standard:~
参考な:informativeな:規範的でない
用語集:glossary:~
首尾一貫する:consistent かつ coherent な:様々な環境下で首尾一貫する
合法:legal:~
proprietary::::プロプライエタリ
予備:auxiliary:~
安定的:stable:~
方法:how:~
明白:obvious:~
有用性:usefulness:~
機能:function:~
機能上の:functional:~
独特:idiosyncratic:~
脚注:footnote:~
類似性:similarities:~
virtual:~
中立:neutral:~
備考:notes:~
資料:resource:~
選択肢:option:~
popularな::普及している
扱い:treatment:~
図表:chart:~
地域化:localization::~::ローカル化
解消-:solve:~
借用-:borrow:~
介在-:intervene:~
依存:dependent:~
従属:dependent:~
即応性:responsiveness:~
受容:allowing:~
強勢:emphasis:~
	際しての:when interacting with
補足-:supplement:~
補足的:supplemental:~
	補足的な:supplementary
維持-:retain:~
演繹-:deduce:~
図面化-:depict:~



	版
	-:native
	^en:modality
	一貫でない:inconsistent
	~~注目して:with attention
	~~現時点:presently
	可用でない:unavailable
	第一の:primary
	第二の:second
	回答:answer
	-:testing facility
	rather
	正確aでない:inaccurate
	~want
	概括:briefly
	同義語:synonym
	editor
	-:interchangeable
	loosely referred
	確定されたもの:definitive
	であろう:likely
	現実の:real-world
	~~区別:distinction
	に基づいてふるまわせる用途に:for users who are interested in
	:please
	~~混成:hybrid
	基礎を成す:fundamental
	確たるもの:definitive
	対象にする:deal
	~~関係ない:no bearing
	非推奨にされ:marked as deprecated
	見よ:refer to
	~~参照
	図示:illustrate
	満たす:met／meet
	勧める:advised
	user-guided
	~~促進-:foster
	注力する:taking care
	-:take care
	consider
	更に〜もある:further optional
	:disregarding
	regard
	記され:denote
	書かれた:written
	:made
	note
	see
	-:misrepresent
	生じた:cause
	~~区別する:disambiguate
	:said
	遂げられ:carried out
	~~役割を果た:serve
	できるように:permit
	writing
	-:enhancements
	称され:called
	しないようにする:prevent 〜 from being
	最終的に:eventually
	一時的:temporary
	~~場所:home
	〜に従うなら:says
	無さそうに見えるが:appears to have no
	互換性:compat
	織り込む:account for

	●未分類
x:
y:
切離され:disconnectされ:切り離され
切替える:switchする:切り替える
切替えら:switchさ:切り替えら
切替わっ:switchされ:切り替わっ
移転-:shift:~

辞書検索:dictionary lookup:~
	対応-:correspond
派性-:derive:~

環境設定0:environment configuration:環境設定
環境設定1:environment settings:環境設定

unload::::
reset::::リセット
覆う:coverする:~
出生-:originate:生成
由来-:originate:~
	由来する:origin
	~originated
増分的:incremental:~
増加-:increment:~
増大-:increase:~
翻訳-:translate:~
寄与-:contribute:~
発話:speech::~::スピーチ
築上げる:build upする:築き上げる
付され:attachされ:~
	pair::::ペア
trap::::トラップ
digital::::デジタル
body:
bitmask::::ビットマスク
	~bitごとの:bitwise
	instance化:::instantiating
	~style上の:stylistic
component::::コンポーネント
一対一:one-to-one:~
一節:passage:~
回数:count:~
	16 進:hexadecimal
	10 進:decimal
整形式:well-formed::~
文脈的:contextual:~
数学的:mathematical:~
数的:numeric:~
数量的:numerical:~
量:amount:~
総和:sum:~
記号:symbol:~
連続して:consecutiveに:~
remote-control:remote control:::リモコン
空間的:spatial:~
横方向:horizontal::~
縦方向:vertical::~
身体的不利:physical disabilities:~
工場出荷:factory-reset:~
繰返n:repetition:繰り返し
中間的:intermediate:~
	正負:sign／positive or negative
塗る:paintする:~
塗られ:paintされ:~

	~choice
	吸い取る:swallow
	逆順:reverse
	:starting
	より~~上位~bitに対応する:starting with 0x08
	:place
	:follow
	示す:show
	~~指す／:point
	~~収まる:falls within
	まだ居る:stay
	beginning
	持続-:persisting
	持ち続ける:persistent
	保ち続ける:remain
	get
	得る:gain／gaining
	:dented
	direct:
	向けられ:directed
	-:posses:
	-:held
	終わらせる:exit
	保つ:keep
	し続け:keep 〜
	様々に:vary
	resulting
	上向き:upward-pointing
	最も近く:closest match
	複数~UIkeyの同時押下げ:chording
	重複させる:duplicate
	入る:enter
	~~目立たせている／注視されている:receptivity and concentration
	首位に据える:priming
	最初へ戻る:wraps around
	~~相対的:respect
	それぞれの／対応する／対を成す／:respective
	~page~~区分:demarcated page
	前掲の
	-:rectangular
	-:bound
	followed
	~remaining
	~large
	-:front end
	視点:perspective
	低~level:low-level
	長い:long
	left
	倍々:double
	-:binary
	time
	stage
	主区画:main section
	welcome
	:period
	事項:portions
	~meta
	に示されるもの:option
	~capital
	~~小文字:Latin small letter
	~small
	~~括る:bracket
	row
	色付け:color code
	命名 名前
	~~素の:bare
	部位:portion
	一部:part
	alt
	track
	working

	現在:currently
	〜時
	廻り:along
	似た:similarly
	以前の:previous
	以前に:previously
	以前は:formerly
	次:next
	各種:various
	別物:distinct
	古い:older
	最も上層の:highest
	広範に:widely
	much
	entire
	neither
	during
	final
	沿う:along
	right-most
	bottom-most
	farthest
	いくつあっても:arbitrary
	一連の:successive
	higher
	右方／下方／奥方:right-most edge, bottom-most edge, and farthest depth 
	下へ:down
	上へ:up
	lower
	二回:twice
	both
	~~最後に:finally
	一連の:series of
	between
	それに続く:trailing
	最上段:top row
	bottom
	上から下へ:top to bottom
	~~以前の先に／prior
	:after
	around
	where
	逆:opposite
	最下層:bottom
	後続な:later
	の各~属性:public attributes
	各種:various
	`CSSOM-View$r による拡張を含む:+CSSOM attributes
	~CSS `pointer-events$p :css-pointer-events

●●images
＠uievents/
event-inheritance｜height:200px;｜＝Graphical representation of inheritance of interfaces defined by this specification｜.svg
stacked-event-mouse-dispatch｜height:250px;｜＝Graphical representation of three stacked elements all on top of each other. The bottom element is labeled A and the top element is C｜.svg


●●ref_data
UAAG20=副        imagedrive.github.io/TR/UAAG20/
INPUTEVENTS=副   ~/input-events-ja.html
UIEVENTSKEY=副   ~/uievents-key-ja.html

●●ref_normative

[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-View]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[DOM-Level-3-Core]
    Arnaud Le Hors; et al. ＜Document Object Model (DOM) Level 3 Core Specification＞. 28 September 2021. REC. URL: https://www.w3.org/TR/DOM-Level-3-Core/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[HTML5]
    Ian Hickson; et al. ＜HTML5＞. URL: https://www.w3.org/html/wg/drafts/html/master/
[PointerEvents3]
    Patrick Lauke; Robert Flack. ＜Pointer Events＞. URL: https://w3c.github.io/pointerevents/
[POINTERLOCK-2]
    Mustaq Ahmed; Vincent Scheib. ＜Pointer Lock 2.0＞. URL: https://w3c.github.io/pointerlock/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[UIEvents-Code]
    Travis Leithead; Gary Kacmarcik. ＜UI Events KeyboardEvent code Values＞. URL: https://w3c.github.io/uievents-code/
[UIEvents-Key]
    Travis Leithead; Gary Kacmarcik. ＜UI Events KeyboardEvent key Values＞. URL: https://w3c.github.io/uievents-key/
[WebIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[DWW95]
    N. Kano. ＜Developing International Software for Windows 95 and Windows NT: A Handbook for International Software Design＞. 1995.
[Editing]
    A. Gregor. ＜HTML Editing APIs＞. URL: https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html
[HTML401]
    Dave Raggett; Arnaud Le Hors; Ian Jacobs. ＜HTML 4.01 Specification＞. 27 March 2018. REC. URL: https://www.w3.org/TR/html401/
[Input-Events]
    Johannes Wilm. ＜Input Events Level 1＞. URL: https://w3c.github.io/input-events/
[PointerLock]
    Vincent Scheib. ＜Pointer Lock＞. URL: https://w3c.github.io/pointerlock/
[RFC20]
    V.G. Cerf. ＜ASCII format for network interchange＞. October 1969. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc20
[UAAG20]
    James Allan; et al. ＜User Agent Accessibility Guidelines (UAAG) 2.0＞. URL: https://www.w3.org/TR/2015/NOTE-UAAG20-20151215/
[UAX15]
    Ken Whistler. ＜Unicode Normalization Forms＞. 12 August 2023. Unicode Standard Annex #15. URL: https://www.unicode.org/reports/tr15/tr15-54.html
[Unicode]
    ＜The Unicode Standard＞. URL: https://www.unicode.org/versions/latest/
[US-ASCII]
    ＜Coded Character Set - 7-Bit American Standard Code for Information Interchange＞. 1986.
[WIN1252]
    ＜Windows 1252 a Coded Character Set - 8-Bit＞. URL: https://www.microsoft.com/globaldev/reference/sbcs/1252.htm
[XFORMS11]
    John Boyer. ＜XForms 1.1＞. 20 October 2009. REC. URL: https://www.w3.org/TR/xforms11/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/
[XML-Names11]
    Tim Bray; et al. ＜Namespaces in XML 1.1 (Second Edition)＞. 16 August 2006. REC. URL: https://www.w3.org/TR/xml-names11/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">UI Events</a>
を日本語に翻訳したものです
（一部の内容の日本語訳は
<a href="uievents-appendix-ja.html">別ページ</a>
に分けています）。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/uievents/
公表履歴
	https://www.w3.org/standards/history/uievents/
フィードバック
	https://github.com/w3c/uievents/issues/
論点（歴史的）
	https://lists.w3.org/Archives/Public/public-webapps/
編集
	<a href="mailto:garykac@google.com">Gary Kacmarcik</a> (Google)
	<a href="mailto:travil@microsoft.com">Travis Leithead</a> (Microsoft)
前任編集者
	Doug Schepers (Mar 2008 - May 2011)

テスト
	https://github.com/web-platform-tests/wpt/tree/master/uievents
テスト（進行中な作業）
	https://github.com/web-platform-tests/wpt/labels/uievents

commit 履歴
	https://github.com/w3c/uievents/commits/gh-pages
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>

</script>


</head>

<body>
<header>

	<hgroup>
<h1>UI Events</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、
`DOM$r にて定義される DOM Event ~objを拡張する，~UI~Eventsを定義する。
~UI~Eventsは、
概して視覚的な~UAにより，
利用者-ヤリトリ
— ~mouseや~keyboardによる入力など —
を取扱うために実装されている。
◎
This specification defines UI Events which extend the DOM Event objects defined in [DOM]. UI Events are those typically implemented by visual user agents for handling user interaction such as mouse and keyboard input.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
`この節では、公表~時点における…^em
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="ui-events-intro">
<h2 title="Introduction">1. 序論</h2>

		<section id="dom-events-overview">
<h3 title="Overview">1.1. 概観</h3>
<p>
~UI~Eventsは、
~~主に二つの目標を念頭に設計されている。
第一の目標は、
`~event$~systemを［
`~event~listener$の登録を許容する
］よう, および［
~event~flowを~tree構造を通して述べる
］ように設計することである。
加えて，この仕様は、
~UI~controlや文書の変異†
— これら各~event~module用に定義済みな文脈的~情報を含む —
を通知するための，~eventの標準的な~moduleを供する。
◎
UI Events is designed with two main goals. The first goal is the design of an event system which allows registration of event listeners and describes event flow through a tree structure. Additionally, the specification will provide standard modules of events for user interface control and document mutation notifications, including defined contextual information for each of these event modules.
</p>

<p class="trans-note">【†
変異~event~API（ `MutationEvent^I ）は、
`非推奨に$され（今や，この仕様からも除去され），
`DOM$r により `MutationObserver$I として定義し直された。
】</p>

<p>
~UI~Eventsの第二の目標は、
既存の~browserに利用されている，現在の~event~systemに共通な~~機能を供することである。
これには、
既存の［
~script, 内容
］との相互運用能を~~促進することが意図されている。
この目標には、
後方-互換性を全部的に満たすことは，期待されていない。
しかしながら，この仕様は、
アリな所では これを達成しようと試みる。
◎
The second goal of UI Events is to provide a common subset of the current event systems used in existing browsers. This is intended to foster interoperability of existing scripts and content. It is not expected that this goal will be met with full backwards compatibility. However, the specification attempts to achieve this when possible.
</p>

		</section>
		<section id="dom-events-conformance">
<h3 title="Conformance">1.2. 適合性</h3>

`ui-events-conformance^APX

		</section>
	</section>
	<section id="style-conventions">
<h3 title="Stylistic Conventions">2. ~style上の規約</h3>
<p>
この仕様では、
次の表記が用いられる
【！`Proposed W3C Specification Conventions＠http://www.w3.org/People/Schepers/spec-conventions.html$ に従う】：
◎
This specification follows the Proposed W3C Specification Conventions, with the following supplemental additions:
</p>

<div>

<table><thead>
<tr><th>表記~例
<th>意味
<tbody>

<tr><td>`↓^cap, `=^cap, `Q^cap
<td>~UIkey上に印字される `~UIkey~cap＠#key-legends$。
この表記は、
生成される `KeyboardEvent!I の `key$m, `code$m 値には関わらない，利用者~視点の~UIkeyを指すときに利用される。

<tr><td>`ア^kGl, `~~漢字^kGl
<td>文字／文字~並びを表現している~glyph並び

<tr><td>`003D^U
<td>~Unicode文字

<tr><td>`ArrowDown$kY, `=^kY, `q^kY, `Q^kY
<td>~UIkeyを押して生成される~UIkey値
（すなわち、
`KeyboardEvent^I の `key$m 値）
の名前

<tr><td>`ArrowDown$kC, `Equal$kC, `KeyQ$kC
<td>物理的な~UIkeyに結付けられた~UIkey~code
（すなわち、
`KeyboardEvent^I の `code$m 値）
の名前
</table>

◎
• The key cap printed on a key is shown as ↓, = or Q. This is used to refer to a key from the user’s perspective without regard for the key and code values in the generated KeyboardEvent.
• Glyphs representing character are shown as: "𣧂".
• Unicode character encodings are shown as: U+003d.
• Names of key values generated by a key press (i.e., the value of KeyboardEvent.key) are shown as: "ArrowDown", "=", "q" or "Q".
• Names of key codes associated with the physical keys (i.e., the value of KeyboardEvent.code) are shown as: "ArrowDown", "Equal" or "KeyQ".
</div>

<p>
加えて，この仕様における一定の用語は、
特定0の意味で利用される。
語 “実装”は、
~browser, 内容~著作~tool, その他，この仕様を実装する`~UA$を~~指す。
語 内容~作者は、
~interface, ~method, 属性, ~event, その他，この仕様にて述べる他の特能を利用する~scriptや~codeを書いて，~Web~appを作る者を~~指す。
利用者とは，ある実装の下で それらの~Web~appを利用する者を~~指す。
◎
In addition, certain terms are used in this specification with particular meanings. The term "implementation" applies to a browser, content authoring tool, or other user agent that implements this specification, while a content author is a person who writes script or code that takes advantage of the interfaces, methods, attributes, events, and other features described in this specification in order to make Web applications, and a user is the person who uses those Web applications in an implementation.
◎
And finally:
• This is a note.
• This is an open issue.
• This is a warning.
interface Example {
    // This is an IDL definition.
}
</p>

	</section>
	<section id="event-interfaces">
<h2 title="Basic Event Interfaces">3. 基本~event~interface</h2>

<p>
基本~event~interfaceは `DOM$r にて定義され，~UI~Eventsの基礎を成す。
実装は、
以下に挙げる基本~event~interfaceを常に~supportするモノトスル：
◎
The basic event interfaces defined in [DOM] are fundamental to UI Events. These basic event interfaces MUST always be supported by the implementation:
</p>

<ul>
	<li>
`Event$I ~interface, および その［
定数, ~method, 属性
］のうち次に挙げるもの
⇒＃
`NONE$m
`CAPTURING_PHASE$m,
`AT_TARGET$m,
`BUBBLING_PHASE$m,
`type$m,
`target$m,
`currentTarget$m,
`eventPhase$m,
`bubbles$m,
`cancelable$m,
`composed$m,
`timeStamp$m,
`defaultPrevented$m,
`isTrusted$m,
`stopPropagation()$m,
`stopImmediatePropagation()$m,
`preventDefault()$m,
`initEvent()$m
◎
The Event interface and its following constants, methods and attributes:
• NONE constant
• CAPTURING_PHASE constant
• AT_TARGET constant
• BUBBLING_PHASE constant
• type attribute
• target attribute
• currentTarget attribute
• eventPhase attribute
• bubbles attribute
• cancelable attribute
• composed attribute
• timeStamp attribute
• defaultPrevented attribute
• isTrusted attribute
• stopPropagation() method
• stopImmediatePropagation() method
• preventDefault() method
• initEvent() method
</li>
	<li>
`CustomEvent$I ~interface, および その
⇒＃
`initCustomEvent()$m ~method,
`detail＠~DOM4#dom-customevent-detail$m 属性
◎
The CustomEvent interface and its following method and attribute:
• initCustomEvent() method
• detail attribute
</li>
	<li>
`EventTarget$I ~interface, および その~methodのうち次に挙げるもの
⇒＃
`addeventlistener()$m,
`removeeventlistener()$m,
`dispatchEvent()$m
◎
The EventTarget interface and its following methods:
• addEventListener() method
• removeEventListener() method
• dispatchEvent() method
</li>
	<li>
`EventListener$I ~interface, および その
`handleEvent()$m ~method
◎
The EventListener interface and its handleEvent() method
</li>
	<li>
`Document$I ~interfaceの `createEvent()$m ~method
◎
The Document interface’s createEvent() method
</li>
</ul>

<p>
この仕様に定義される各種~event型【用の~interface】は、
これらの基本~interfaceいずれかから派性し，そのすべての［
属性, ~method, 定数
］を継承するモノトスル。
◎
The event types defined in this specification derive from these basic interfaces, and MUST inherit all of the attributes, methods, and constants of the interfaces they derive from.
</p>

<p>
この仕様に述べる各種~interfaceの継承~構造を，次の図表に述べる：
◎
The following chart describes the inheritance structure of the interfaces described in this specification.
</p>

<figure id="figure-event-inheritance">
<figcaption id="_dgm-event-inheritance">
この仕様により定義される~interfaceの継承を成す~graphicな表現
◎
Graphical representation of inheritance of interfaces defined by this specification
</figcaption></figure>

		<section id="event-types-list">
<h3 title="List of Event Types">3.1. 各種~event型の~list</h3>

<p>
各~eventには、
`~event型^emと称される，ある型が結付けられ、
~event~obj上の `type$m 属性にて可用にするモノトスル。
~event型は `DOMString^c 型でなければナラナイ。
◎
Each event MUST be associated with a type, called event type and available as the type attribute on the event object. The event type MUST be of type DOMString.
</p>

<p>
実装は、［
~DOM~supportの~level／
表示~用に利用される装置（例： ~screen）／
対話~用に利用される装置（例： ~mouse, ~keyboard, ~touch~screen, ~voice）
］に依存して，これらの~event型を生成し得る。
`XML$r や `HTML$r【！HTML5】 の応用に利用されるときは、
その言語の仕様は，~event型に結付けられる意味論と視野（特に，アリな`~target$）を制約し得る／してもヨイ。
［
それらの制約／この文書にて定義されない~event型
］を見出すには、
利用される言語を定義している仕様を見よ。
◎
Depending on the level of DOM support, or the devices used for display (e.g., screen) or interaction (e.g., mouse, keyboard, touch screen, or voice), these event types can be generated by the implementation. When used with an [XML] or [HTML5] application, the specifications of those languages MAY restrict the semantics and scope (in particular the possible event targets) associated with an event type. Refer to the specification defining the language used in order to find those restrictions or to find event types that are not defined in this document.
</p>

<p class="trans-note">【
参考：
`DOM Event Viewers＠https://domeventviewer.com/$en にて、
この仕様に定義される各種~event型の挙動を試せる。
】</p>

<p>
次の表tに，この仕様に述べる各種~event型の参考な要約を供する：
◎
The following table provides an informative summary of the event types described in this specification.
</p>

<table id="_event-list" class="grid-table"><thead>
<tr><th>~event型
<th>同期c？
<th>浮上-？
<th>`~trusted$な~target
<th>~DOM~interface
<th>取消~可否
<th>`既定~動作$（空欄は動作なし）
<tbody>

<tr><td>`abort$et
<td>あり
<td>しない
<td>`Window$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`auxclick$et
<td>あり
<td>する
<td>`Element$I
<td>`PointerEvent$I
<td>可
<td>文脈依存

<tr><td>`beforeinput$et
<td>あり
<td>する
<td>`Element$I
<td>`InputEvent$I
<td>可
<td>
~DOM要素を更新する
◎
Update the DOM element

<tr><td>`blur$et
<td>あり
<td>しない
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`click$et
<td>あり
<td>する
<td>`Element$I
<td>`PointerEvent$I
<td>可
<td>
文脈依存
⇒＃
`作動化の挙動$が結付けられた`~target$に対しては，それを実行する／
~focus可能な要素である`~target$に対しては，それを~focusする
◎
Varies: for targets with an associated activation behavior, executes the activation behavior; for focusable targets, gives the element focus.

<tr><td>`compositionstart$et
<td>あり
<td>する
<td>`Element$I
<td>`CompositionEvent$I
<td>可
<td>
`~text組成~system$の候補~窓を示す
◎
Show a text composition system candidate window

<tr><td>`compositionupdate$et
<td>あり
<td>する
<td>`Element$I
<td>`CompositionEvent$I
<td>不可
<td>

<tr><td>`compositionend$et
<td>あり
<td>する
<td>`Element$I
<td>`CompositionEvent$I
<td>不可
<td>

<tr><td>`contextmenu$et
<td>あり
<td>する
<td>`Element$I
<td>`PointerEvent$I
<td>可
<td>
~supportされるなら、
文脈~menuを呼出す
◎
Invoke a context menu if supported

<tr><td>`dblclick$et
<td>あり
<td>する
<td>`Element$I
<td>`MouseEvent$I
<td>不可
<td>
文脈依存
⇒＃
`作動化の挙動$が結付けられた`~target$に対しては，それを実行する／
~focus可能な要素である`~target$に対しては，それを~focusする
◎
Varies: for targets with an associated activation behavior, executes the activation behavior; for focusable targets, gives the element focus.

<tr><td>`error$et
<td>なし
<td>しない
<td>`Window$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`focus$et
<td>あり
<td>しない
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`focusin$et
<td>あり
<td>する
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`focusout$et
<td>あり
<td>する
<td>`Window$I, `Element$I
<td>`FocusEvent$I
<td>不可
<td>

<tr><td>`input$et
<td>あり
<td>する
<td>`Element$I
<td>`InputEvent$I
<td>不可
<td>

<tr><td>`keydown$et
<td>あり
<td>する
<td>`Element$I
<td>`KeyboardEvent$I
<td>可
<td>
文脈依存
— 次に挙げるいずれかを誘発する
⇒＃
`beforeinput$et, `input$et ~event／
`~text組成~system$を立上げる／
`blur$et, `focus$et ~event／
`keypress$et ~event（~supportされるならば）／
`作動化の挙動$／
その他の~event
◎
Varies: trigger beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other events

<tr><td>`keyup$et
<td>あり
<td>する
<td>`Element$I
<td>`KeyboardEvent$I
<td>可
<td>

<tr><td>`load$et
<td>なし
<td>しない
<td>`Window$I, `Document$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`mousedown$et
<td>あり
<td>する
<td>`Element$I
<td>`MouseEvent$I
<td>可
<td>
文脈依存
— 次に挙げるいずれかを開始する
⇒＃
~drag＆~drop操作o／
~text選択／
~scrollや~panによるヤリトリ
（~supportされるなら，中央~mouse~buttonとの組合nで）
◎
Varies: start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported)

<tr><td>`mouseenter$et
<td>あり
<td>しない
<td>`Element$I
<td>`MouseEvent$I
<td>不可
<td>

<tr><td>`mouseleave$et
<td>あり
<td>しない
<td>`Element$I
<td>`MouseEvent$I
<td>不可
<td>

<tr><td>`mousemove$et
<td>あり
<td>する
<td>`Element$I
<td>`MouseEvent$I
<td>`可＠#mousemove-now-cancelable$
<td>

<tr><td>`mouseout$et
<td>あり
<td>する
<td>`Element$I
<td>`MouseEvent$I
<td>可
<td>

<tr><td>`mouseover$et
<td>あり
<td>する
<td>`Element$I
<td>`MouseEvent$I
<td>可
<td>

<tr><td>`mouseup$et
<td>あり
<td>する
<td>`Element$I
<td>`MouseEvent$I
<td>可
<td>

<tr><td>`select$et
<td>あり
<td>する
<td>`Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`unload$et
<td>あり
<td>しない
<td>`Window$I, `Document$I, `Element$I
<td>`Event$I
<td>不可
<td>

<tr><td>`wheel$et
<td>なし
<td>する
<td>`Element$I
<td>`WheelEvent$I
<td>可
<td>
文書を~scrollする
（または~zoomする）
◎
Scroll (or zoom) the document
</table>

<p>
この仕様にて非推奨にされた~eventたちが成す~listは、
`§ 旧来の~event型＠~UIEVENTS-A#legacy-event-types$
を見よ。
◎
For a list of events which are deprecated in this specification, see the Legacy Event Types appendix at the end of this document.
</p>

<p class="example">
上の表tを解釈する仕方の一つは：
`load$et ~eventは、［
その~event用に `Element$I ~nodeに付された`~event~listener$
］を［
`捕捉-相$, `~target相$
］にて誘発することになる。
この~eventは`取消~可能$でない。
`load$et ~event用の`~event~listener$は、［
`Window$I, `Document$I, `Element$I
］以外の~nodeに付されても，`浮上-相$のみに付されても誘発されない。
◎
The following is one way to interpret the above tables: the load event will trigger event listeners attached on Element nodes for that event and on the capture and target phases. This event is not cancelable. If an event listener for the load event is attached to a node other than Window, Document, or Element nodes, or if it is attached to the bubbling phase only, this event listener would not be triggered.
</p>

<p class="note">注記：
上の表tを そこに挙げられた~event型~用に確たるものとして解釈しないこと。
例えば `load$et ~eventは、
`XMLHttpRequest$I などの他の仕様にも利用される。
同様に，`~trusted$でない~eventは、
`EventTarget$I も実装する<strong>どの~obj</strong>にも，それ用の~listenerへ `dispatchEvent()$m を利用して配送できる。
◎
Don’t interpret the above tables as definitive for the listed event types. For example, the load event is used in other specifications, for example, in XMLHttpRequest. Similarly, dispatchEvent() can be used to dispatch untrusted events to listeners on any object that also implements EventTarget.
</p>

<p class="note">注記：
上に述べた各~event型に結付けられる~event~objは、
追加的な文脈~情報を包含する
— 更なる情報は、
~DOM~interfaceの記述を見よ。
◎
The event objects associated with the event types described above contain additional context information--refer to the description of the DOM interfaces for further information.
</p>

		</section>
		<section id="_event-definition-table">
<h3>~event定義~表t</h3>

<p class="trans-note">【
この節は、
この訳による補完。
】</p>

<p>
この仕様に現れる，各種`~event型$の定義は、
次のような表tとして与えられる：
</p>

◎イ型
この欄には、
当の~event型の名前が記される
（例： `click^et ）。
この名前が、
~eventの `type$m 属性の値になる。
◎界面
この欄には、
この型の~event~objが実装する~interfaceが示される
（例： `MouseEvent^I ）。
◎同期
この欄には、
この型の~eventが他の~eventと同期的に生じ得るならば “あり”／
他の場合は “なし” と記される。
◎浮上
この欄には、
この型の~eventが `浮上-$するならば “する” ／
他の場合は “しない” と記される。
◎標的
この欄には、
この型の~eventの`~target$になり得る~objが挙げられる
（例： `Element$I ）。
◎取消
この欄には、
この型の~eventが`取消~可能$ならば “可” ／
他の場合は “不可” と記される。
◎構
`composed$m 属性に関係する
— 単に［
“Yes” ／ “No”
］と記されているなら その値は［
~T ／ ~F
］になると見受けられる —
が、
実際の定義は不明
（ “Yes”, “No” の他にも とり得る値や何らかの記述があり得るかなど）。
この欄が無い~event型もあり、
その不在が何を意味するのかも不明
（ “No” を意味するのか 単に策定されていないのか判別できない）。

◎既定動作
この欄には、
この型の~eventに結付けられ得る`既定~動作$が挙げられる
（例：~pageを~scrollする）。
◎文脈
この欄には、
この型の~eventが実装する（~interface欄に挙げられている）~interfaceの各種~memberが，どのような値に初期化されるかが述べられる。
◎表終

<p>
この表tが適用されるのは、
`~trusted$な~eventに限られる
（~scriptにより配送される~eventには、
適用されない）。
</p>

<p>
以下に挙げる用語は、
この仕様が更新される前にあった記述の（かなり端折った）要約であり，
規範的な定義ではない：
</p>
<ul>
	<li>
`~UA$により
— 通例的に，利用者-ヤリトリに呼応して —
生成される~eventは、
`~trusted@
な~eventと呼ばれる。
対して，~scriptにより
（ `dispatchEvent()$m ~methodを介して）
配送される~eventは、
~trustedでない~eventになる
（合成な~eventとも称される）。
~trustedか否かは、
~eventの `isTrusted$m 属性に反映される。
</li>
	<li>
~eventが
`浮上-@
（ `bubble^en ）するとは、
当の~eventが`~target相$に伝播した後も，先祖へ遡るよう伝播し続けることを意味する。
その可否は~eventの `bubbles$m 属性に反映される。
</li>
	<li>
~eventが
`取消~可能@
（ `cancelable^en ）であるとは、
`preventDefault()$m ~methodを~callすることで，
`既定~動作$を取消せることを意味する。
その可否は、
~eventの `cancelable$m 属性に反映される。
</li>
</ul>

		</section>
		<section id="events-uievents">
<h3 title="User Interface Events">3.2. ~UI~event</h3>

<p>
~UI~event~moduleは、
~UIや文書の操作に結付けられた，基本的な~event型を包含する。
◎
The User Interface event module contains basic event types associated with user interfaces and document manipulation.
</p>

			<section id="interface-uievent">
<h4 title="Interface UIEvent">3.2.1. `UIEvent^I ~interface</h4>

<p class="intro-dom">
DOM Level 2 にて導入された。
◎
Introduced in DOM Level 2
</p>

<p>
`UIEvent^I ~interfaceは、
~UI~eventに特有な文脈的~情報を供する。
◎
The UIEvent interface provides specific contextual information associated with User Interface events.
</p>

<p>
`UIEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `UIEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the UIEvent interface, use the UIEvent constructor, passing an optional UIEventInit dictionary.
</p>

<p class="note">注記：
新たに定義される~eventは、
単に~UIに関係するだけで， `UIEvent$I ~interfaceを継承する必要はない。
`UIEventInit$I の~memberのみ継承することでも，イミを成す。
◎
For newly defined events, you don’t have to inherit UIEvent interface just because they are related to user interface. Inherit only when members of UIEventInit make sense to those events. 
</p>

				<section id="idl-uievent">
<h5>3.2.1.1. `UIEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `UIEvent@I : `Event$I {
    `UIEvent@mc(`DOMString$ %type, optional `UIEventInit$I %eventInitDict = {});

    readonly attribute `Window$I? `view$m;
    readonly attribute `long$ `detail$m;
};
</pre>

<dl class="idl-def">

<!-- ＊
UIEvent . view 等々
 -->

	<dt>
`view@m
◎
UIEvent . view
</dt>
	<dd>
この属性は、
~eventがどの `Window$I から生成されたかを識別する。
◎
The view attribute identifies the Window from which the event was generated.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>
`detail@m
◎
UIEvent . detail
</dt>
	<dd>
この属性には、
~eventの型に依存して， `Event$I についての一部の詳細~情報が指定される。
◎
Specifies some detail information about the Event, depending on the type of event.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>
</dl>

				</section>
				<section id="idl-uieventinit">
<h5>3.2.1.2. `UIEventInit^I</h5>

<pre class="idl">
dictionary `UIEventInit@I : `EventInit$I {
    `Window$I? `view$m = null;
    `long$ `detail$m = 0;
};
</pre>

<dl class="idl-def">
	<dt>
`view@m
◎
UIEventInit . view
</dt>
	<dd>
この~memberは、
この~eventの配送-先の大域~環境の~windowになるベキである。
この~eventが要素に配送されるなら、
その要素の`~node文書$を包含する~windowに設定されるベキである。
◎
Should be initialized to the Window object of the global environment in which this event will be dispatched. If this event will be dispatched to an element, the view property should be set to the Window object containing the element’s ownerDocument.
</dd>

	<dt>
`detail@m
◎
UIEventInit . detail
</dt>
	<dd>
この値は、
~appに特有な整数を与える。
◎
This value is initialized to a number that is application-specific.
</dd>
</dl>

				</section>
			</section>
			<section id="uievent-algorithms">
<h4 title="UIEvent Algorithms">3.2.2. `UIEvent^I 用の~algo</h4>

<div class="algo">
<p>
`~UIEventを初期化する@
ときは、
所与の
⇒＃
`UIEvent$I %~event,
文字列 %~event型,
`EventTarget$I %~event~target,
真偽値 %浮上するか,
真偽値 %取消~可能か
◎終
に対し：
◎
4.2.2.1. initialize a UIEvent
◎
Input
• event, the UIEvent to initialize
• eventType, a DOMString containing the event type
• eventTarget, the EventTarget of the event
• bubbles, true if this event bubbles
• cancelable, true if this event is cancelable
Output
• None
</p>
<ol>
	<li>
<p>
基底 `Event$I の各~属性を初期化する：
◎
Initialize the base Event attributes:
</p>
		<ol>
			<li>
`~eventを初期化する$( %~event, %~event型, %浮上するか, %取消~可能か )
◎
Initialize an Event with event, eventType, bubbles and cancelable
</li>
			<li>
%~event の`~target$ev【！`target$m】 ~SET %~event~target
◎
Set event.target = eventTarget
</li>
		</ol>
	</li>
	<li>
<p>
`UIEvent$I の各~属性を初期化する
⇒
%~event の
⇒＃
`view$m ~SET %~event~target の`~node文書$の`~window$【！ `Window$I ~obj】,
`detail$m ~SET 0,
`which$m ~SET 0
</p>
<p>
（ `which^m は、
歴史的な属性であり，
`MouseEvent$I, `KeyboardEvent$I どちらにも利用される。）
</p>
◎
Initialize the following public attributes:
• Set event.view = the eventTarget’s node document’s Window object
• Set event.detail = 0
◎
Initialize the following historical attributes:
• Set event.which = 0 (used by both MouseEvent and KeyboardEvent)
</li>
</ol>
</div>

			</section>
			<section id="events-uievent-types">
<h4 title="UIEvent Types">3.2.3. 各種~UI~event型</h4>

<p>
以下に，各種~UI~event型を挙げる。
これらの~eventのうち一部のものは、［
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
］~interfaceを利用する。
詳細は各~eventに。
◎
The User Interface event types are listed below. Some of these events use the UIEvent interface if generated from a user interface, but the Event interface otherwise, as detailed in each event.
</p>

				<section id="event-type-load">
<h5>3.2.3.1. `load^et</h5>

<div>
◎イ型 `load@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 なし
◎浮上 しない
◎標的 `Window$I, `Document$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
【！contained】資源を読込んだ【！common】~obj
</li>
</ul>
◎表終

◎
Type 	load
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Async
Bubbles 	No
Trusted Targets 	Window, Document, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : common object whose contained resources have loaded
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
~DOM実装が資源（文書など）, および
すべての従属~資源（画像, ~stylesheet, ~scriptなど）の読込ngを完遂した
］とき，この~eventを発火するモノトスル。
従属~資源の読込nに失敗した場合でも、
それを読込んだ資源が~DOMを介して依然として~access可能である場合には，
この~eventの発火は止めないモノトスル。
実装が，この~event型を発火するときには、
少なくとも `Document$I ~node上に配送することが要求される。
◎
A user agent MUST dispatch this event when the DOM implementation finishes loading the resource (such as the document) and any dependent resources (such as images, style sheets, or scripts). Dependent resources that fail to load MUST NOT prevent this event from firing if the resource that loaded them is still accessible via the DOM. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.
</p>

<p class="note">注記：
旧来の理由から、
~HTML実装においては［
文書の内側の資源（例えば画像）用の `load$et ~eventの伝播~経路
］は，`~window$を含まない。
詳細は `HTML$r【！HTML5】 を見よ。
◎
For legacy reasons, load events for resources inside the document (e.g., images) do not include the Window in the propagation path in HTML implementations. See [HTML5] for more information.
</p>

				</section>
				<section id="event-type-unload">
<h5>3.2.3.2. `unload^et</h5>

<div>
◎イ型 `unload@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Document$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
【！contained】資源が除去された【！common】~obj
</li>
</ul>
◎表終

◎
Type 	unload
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Document, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : common object whose contained resources have been removed
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
~DOM実装が，環境から資源（文書など）や 従属~資源（画像, ~stylesheet, ~scriptなど）を除去した
］とき，この~eventを発火するモノトスル。
文書の~unloadは，この~event型が配送された後になるモノトスル。
実装が，この~event型を配送するときには、
少なくとも `Document$I ~node上に配送することが要求される。
◎
A user agent MUST dispatch this event when the DOM Implementation removes from the environment the resource (such as the document) or any dependent resources (such as images, style sheets, scripts). The document MUST be unloaded after the dispatch of this event type. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.
</p>

				</section>
				<section id="event-type-abort">
<h5>3.2.3.3. `abort^et</h5>

<div>
◎イ型 `abort@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>

<ul>
	<li>
`target$m：
資源の読込ngが~error以外により停止された要素
</li>
</ul>
◎表終

◎
Type 	abort
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : element whose resources have been stopped from loading without error
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
資源の読込ngがまだ進捗~中に，利用者が取消したなどにより中止された
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when the loading of a resource has been aborted, such as by a user canceling the load while it is still in progress.
</p>

				</section>
				<section id="event-type-error">
<h5>3.2.3.4. `error^et</h5>

<div>
◎イ型 `error@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 なし
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>

<ul>
	<li>
`target$m：
資源の読込ngが~errorにより停止された要素
</li>
</ul>
◎表終

◎
Type 	error
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Async
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : element whose resources have been stopped from loading due to error
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
資源の読込nに失敗した, または読込まれたが その意味論に則って解釈-できない
（妥当でない画像, ~script実行~error, 整形式でない~XMLなど）
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when a resource failed to load, or has been loaded but cannot be interpreted according to its semantics, such as an invalid image, a script execution error, or non-well-formed XML.
</p>

				</section>
				<section id="event-type-select">
<h5>3.2.3.5. `select^et</h5>

<div>
◎イ型 `select@et
◎界面 
~UIから生成されるときは `UIEvent$I ／
他のときは `Event$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 不可
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
~text内容が選択された要素
</li>
</ul>
◎表終

◎
Type 	select
Interface 	UIEvent if generated from a user interface, Event otherwise.
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	No
Default action 	None
Context
(trusted events) 	

• Event.target : element whose text content has been selected
• UIEvent.view : Window
• UIEvent.detail : 0
</div>

<p>
~UAは、［
利用者が一部の~textを選択した
］とき，この~eventを発火するモノトスル。
この~eventは、
選択が生じた後に配送される。
◎
A user agent MUST dispatch this event when a user selects some text. This event is dispatched after the selection has occurred.
</p>

<div class="p">
<p>
この仕様は、
選択された~textへ~accessするための文脈的~情報を供さない。
`~host言語$は、
適用-可能な所では，次のための規則を定義するベキである：
</p>
<ul>
	<li>
利用者が内容を選択できる方法
（国際的~言語~規約も考慮して）
</li>
	<li>
`select$et ~eventがどこで発火されたか
</li>
	<li>
内容~作者がその選択された内容に~accessできる方法
</li>
</ul>
◎
This specification does not provide contextual information to access the selected text. Where applicable, a host language SHOULD define rules for how a user MAY select content (with consideration for international language conventions), at what point the select event is dispatched, and how a content author MAY access the user-selected content.
</div>

<p class="note">注記：
利用者により選択された内容に~accessするためには、
内容~作者は，`~host言語$に備わる能力を利用することになる
— 
HTML Editing APIs `Editing$r の
`Document.getSelection()$m ~methodなど。
◎
In order to access to user-selected content, content authors will use native capabilities of the host languages, such as the Document.getSelection() method of the HTML Editing APIs [Editing].
</p>

<p class="note">注記：
`select$et ~eventは、
どの言語のどの要素でも可用になるとは限らない。
例えば `HTML$r【！HTML5】 においては、
`select$et ~eventが配送され得るのは，［
`input$e ／ `textarea$e
］要素に限られている。
実装は、［
~form~controlの外側の~text選択,
~SVG内などの 画像や~markupの選択
］なども含め，適切と判断される文脈にて `select$et ~eventを配送できる。
◎
The select event might not be available for all elements in all languages. For example, in [HTML5], select events can be dispatched only on form input and textarea elements. Implementations can dispatch select events in any context deemed appropriate, including text selections outside of form controls, or image or markup selections such as in SVG.
</p>

				</section>
			</section>
			<section id="_common-UI-event-context">
<h4>各種~UI~eventに共通な文脈~情報</h4>

集約簡略化

<p>
多くの~UI~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`UIEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`view$m</dt>
			<dd>
`Window$I ~obj
◎
UIEvent.view : Window
</dd>
			<dt>`detail$m</dt>
			<dd>
0
◎
UIEvent.detail : 0
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-focusevent">
<h3 title="Focus Events">3.3. ~focus~event</h3>

<p class="note">注記：
この節の~interface, および それに結付けられた［
~event型,
`~focus~event序列＠#events-focusevent-event-order$
］は、［
`~UA~accessibility指針 2.0＠~UAAG20$cite
`UAAG20$r に定義される概念と指針
］に則って，特に［
`~focusの仕組み＠~UAAG20#gl-focus-mechanism$, および
`~focusの用語集＠~UAAG20#def-focus$
に定義される用語
］に~~注目して設計されている。
◎
This interface and its associated event types and § 4.3.2 Focus Event Order were designed in accordance to the concepts and guidelines defined in User Agent Accessibility Guidelines 2.0 [UAAG20], with particular attention on the focus mechanism and the terms defined in the glossary entry for focus.
</p>

			<section id="interface-focusevent">
<h4 title="Interface FocusEvent">3.3.1. `FocusEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`FocusEvent^I ~interfaceは、
~focus~eventに特有な文脈的~情報を供する。
◎
The FocusEvent interface provides specific contextual information associated with Focus events.
</p>

<p>
`FocusEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `FocusEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the FocusEvent interface, use the FocusEvent constructor, passing an optional FocusEventInit dictionary.
</p>

				<section id="idl-focusevent">
<h5>3.3.1.1. `FocusEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `FocusEvent@I : `UIEvent$I {
    `FocusEvent@mc(`DOMString$ %type, optional `FocusEventInit$I %eventInitDict = {});

    readonly attribute `EventTarget$I? `relatedTarget$m;
};
</pre>

<dl class="idl-def">
	<dt>
`relatedTarget@m
◎
FocusEvent . relatedTarget
</dt>
	<dd>
~focus~eventに関係する，副 `EventTarget$I を識別するために利用され、
~eventの型に依存する。
◎
Used to identify a secondary EventTarget related to a Focus event, depending on the type of event.
</dd>
	<dd>
~securityの理由から、
入子な関係にある閲覧~文脈どうしで~focusが~~移動したときには【！tabbing into or out 】，
この属性の値【！関連な EventTarget 】は ~NULL になるベキである。
◎
For security reasons with nested browsing contexts, when tabbing into or out of a nested context, the relevant EventTarget SHOULD be null.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>
</dl>

				</section>
				<section id="idl-focuseventinit">
<h5>3.3.1.2. `FocusEventInit^I</h5>

<pre class="idl">
dictionary `FocusEventInit@I : `UIEventInit$I {
    `EventTarget$I? `relatedTarget@m = null;
};
</pre>

<p>
この辞書の各~memberは、
`FocusEventInit!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
FocusEventInit . relatedTarget
• The relatedTarget should be initialized to the element losing focus (in the case of a focus or focusin event) or the element gaining focus (in the case of a blur or focusout event).
</p>

				</section>
			</section>
			<section id="events-focusevent-event-order">
<h4 title="Focus Event Order">3.3.2. ~focus~event序列</h4>
<p>
この仕様にて定義される~focus~eventは、
相互相対順序の下で生じる。
被focus要素が無い状態から要素 %A, 要素 %B の順に~focusが移転されたときの代表的な~event連列を次に示す：
◎
The focus events defined in this specification occur in a set order relative to one another. The following is the typical sequence of events when a focus is shifted between elements (this order assumes that no element is initially focused):
</p>

<table class="event-sequence-table"><thead>

<tr><th>~event型
<th>備考
<tbody>

<tr><td>
<td>
<td><em>
利用者が~focusを移転した
</em>
◎
User shifts focus
<tr><td>1.
<td>`focus$et
<td>
%A が~focusを受取った直後に送信される
◎
Sent after first target element receives focus

<tr><td>2.
<td>`focusin$et
<td>
`focus$et ~eventに後続する
◎
Follows the focus event

<tr><td>
<td>
<td><em>
利用者が~focusを移転した
</em>
◎
User shifts focus

<tr><td>3.
<td>`blur$et
<td>
%A が~focusを失った直後に送信される
◎
Sent after first target element loses focus

<tr><td>4.
<td>`focusout$et
<td>
`blur$et ~eventに後続する
◎
Follows the blur event

<tr><td>5.
<td>`focus$et
<td>
%B が~focusを受取った直後に送信される
◎
Sent after second target element receives focus

<tr><td>6.
<td>`focusin$et
<td>
`focus$et ~eventに後続する
◎
Follows the focus event
</table>

<p class="note">注記：
この仕様は、
`focus()^m や `blur()^m
などの~methodに際しての~focus~eventの挙動は定義しない。
そのような挙動については、
それらの~methodを定義している，関連な仕様を見よ。
◎
This specification does not define the behavior of focus events when interacting with methods such as focus() or blur(). See the relevant specifications where those methods are defined for such behavior.
</p>

			</section>
			<section id="events-focusevent-doc-focus">
<h4 title="Document Focus and Focus Context">3.3.3. 文書~focusと~focus文脈</h4>

<p>
この~event~moduleは、
文書`~focus$の変化を通知するための~event型を含む。
この論点に関連な，3 種の別個な~focus文脈がある：
◎
This event module includes event types for notification of changes in document focus. There are three distinct focus contexts that are relevant to this discussion:
</p>
<ul>
	<li>
~OS~focus文脈
⇒
この文脈の下では、
~computer上で現在~稼働している多数の~appのうち一つが，~focusを持ち得るとされる。
~browserは、
その一つを成し得る。
◎
The operating system focus context which MAY be on one of many different applications currently running on the computer. One of these applications with focus can be a browser.
</li>
	<li>
~app~focus文脈
⇒
~browserが~focusを得ているときが，この文脈である。
この文脈の下では、
利用者は、
~browserの各種~UI~field
（例： ~URL~bar, 探索~field, 等々）
間で~focusを切替えることもある
（~tab~UIkeyなどにより）。
~UItab内に示されている文書も、
これらの~UI~fieldの一つを成し得る。
◎
When the browser has focus, the user can switch (such as with the tab key) the application focus context among the different browser user interface fields (e.g., the Web site location bar, a search field, etc.). One of these user interface fields can be the document being shown in a tab.
</li>
	<li>
文書~focus文脈
⇒
文書~自身が~focusを得ているときが、
この文脈である。
この文脈の下では、
文書~内で~focus可能な要素が~focusを得ることができる。
◎
When the document itself has focus, the document focus context can be set to any of the focusable elements in the document.
</li>
</ul>

<p>
この仕様にて定義される各種~event型は、
もっぱら文書~focusのみを対象にする。
~eventの詳細~にて識別される`~target$は、
~window内の文書またその一部に限るモノトスル
— ~focus文脈が別の文脈へ切替わったときでも，決して ~browserや~OSの一部にはならない。
◎
The event types defined in this specification deal exclusively with document focus, and the event target identified in the event details MUST only be part of the document or documents in the window, never a part of the browser or operating system, even when switching from one focus context to another.
</p>

<div class="p">
<p>
通常は、
文書は常に被focus要素を持ち
（他に無ければ，`文書~要素$が被focus要素になる）、
また，`~focus環$を持ち続ける。
~focus文脈が切替わっても，文書における現在の被focus要素, および文書の`~focus環$は、
通常は現在の状態を保ち続ける。
例えば，文書にて~focus可能な要素が 3 個あって，
2 個目の要素が~focusされている下で、
利用者が~OS~focusを別の~appに変更してから また~browserに戻ったとき、
2 個目の要素は，文書の中で依然として被focusのままにされ、
~tabbingなどで~focusが切り替えられたときは，
3 個目の要素に~focusが移ることになる。
</p>

<p>
`~host言語$は、
次を定義してもヨイ：
</p>

<ul>
	<li>
どの要素が~focusを受取れるか
</li>
	<li>
要素はどの条件の下で~focusを受取るか
</li>
	<li>
~focusはどの手段で変更できるか
</li>
	<li>
~focusはどの順序で変化するか
</li>
</ul>

<p >
例えば，
要素に~pointerが接触するだけで要素が~focusを得ることもあれば、
~clickを要する状況下もある。
要素には、
まったく~focusされ得ないものもあれば、
特別な手段（要素~上を~clickするなど）を通してなら~focusできるが，~tabbingでは~focusできないものもある。
文書は、
複数の`~focus環$を包含してもヨイ。
</p>

<p>
他の仕様は、
この仕様にて述べるものより複階的な~focus~modelを定義してもヨイ
— 複数の要素が，現在の~focusを得られるようにすることも含め。
</p>

◎
Normally, a document always has a focused element (even if it is the document element itself) and a persistent focus ring. When switching between focus contexts, the document’s currently focused element and focus ring normally remain in their current state. For example, if a document has three focusable elements, with the second element focused, when a user changes operating system focus to another application and then back to the browser, the second element will still be focused within the document, and tabbing will change the focus to the third element. A host language MAY define specific elements which might receive focus, the conditions under which an element MAY receive focus, the means by which focus MAY be changed, and the order in which the focus changes. For example, in some cases an element might be given focus by moving a pointer over it, while other circumstances might require a mouse click. Some elements might not be focusable at all, and some might be focusable only by special means (clicking on the element), but not by tabbing to it. Documents MAY contain multiple focus rings. Other specifications MAY define a more complex focus model than is described in this specification, including allowing multiple elements to have the current focus.
</div>

			</section>
			<section id="events-focus-types">
<h4 title="Focus Event Types">3.3.4. 各種~focus~event型</h4>

<p>
以下に，各種~focus~event型を挙げる：
◎
The Focus event types are listed below.
</p>

				<section id="event-type-blur">
<h5>3.3.4.1. `blur^et</h5>

<div>
◎イ型 `blur@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
~focusを失った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
新たに~focusを受取っている`~event~target$。
</li>
</ul>
◎表終

◎
Type 	blur
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target losing focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target receiving focus.
</div>

<p>
~UAは、
要素が~focusを失った直後に，
当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`focusout$et に類似するが，浮上しない。
◎
A user agent MUST dispatch this event when an event target loses focus. The focus MUST be taken from the element before the dispatch of this event type. This event type is similar to focusout, but does not bubble.
</p>

				</section>
				<section id="event-type-focus">
<h5>3.3.4.2. `focus^et</h5>

<div>
◎イ型 `focus@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
新たに~focusを受取った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
~focusを失っている`~event~target$（もしあれば）。
</li>
</ul>
◎表終

◎
Type 	focus
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target receiving focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target losing focus (if any).
</div>

<p>
~UAは、
要素が~focusを受取った直後に，
当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`focusin$et に類似するが，浮上しない。
◎
A user agent MUST dispatch this event when an event target receives focus. The focus MUST be given to the element before the dispatch of this event type. This event type is similar to focusin, but does not bubble.
</p>

				</section>
				<section id="event-type-focusin">
<h5>3.3.4.3. `focusin^et</h5>

<div>
◎イ型 `focusin@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 する
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
新たに~focusを受取った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
~focusを失っている`~event~target$（もしあれば）。
</li>
</ul>
◎表終

◎
Type 	focusin
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target receiving focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target losing focus (if any).
</div>

<p>
~UAは、［
要素が~focusを受取った直後
］かつ［
当の要素に向けて `focus$et ~eventを配送した後
］に，当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`focus$et に類似するが，浮上する。
◎
A user agent MUST dispatch this event when an event target receives focus. The event target MUST be the element which received focus. The focus event MUST fire before the dispatch of this event type. This event type is similar to focus, but does bubble.
</p>

				</section>
				<section id="event-type-focusout">
<h5>3.3.4.4. `focusout^et</h5>

<div>
◎イ型 `focusout@et
◎界面 `FocusEvent$I
◎同期 あり
◎浮上 する
◎標的 `Window$I, `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~UI~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
~focusを失った`~event~target$
</li>
	<li>
`FocusEvent.relatedTarget$m：
新たに~focusを受取っている`~event~target$。
</li>
</ul>
◎表終

◎
Type 	focusout
Interface 	FocusEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Window, Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target losing focus
• UIEvent.view : Window
• UIEvent.detail : 0
• FocusEvent.relatedTarget : event target receiving focus.
</div>

<p>
~UAは、［
要素が~focusを失った直後
］かつ［
当の要素に向けて `blur$et ~eventを配送した後
］に，
当の要素に向けて この~eventを発火するモノトスル。
この~event型は、
`blur$et に類似するが，浮上する。
◎
A user agent MUST dispatch this event when an event target loses focus. The event target MUST be the element which lost focus. The blur event MUST fire before the dispatch of this event type. This event type is similar to blur, but does bubble.
</p>

				</section>
			</section>
		</section>
		<section id="events-mouseevents">
<h3 title="Mouse Events">3.4. ~mouse~event</h3>

<p>
~mouse~event~moduleは
`HTML401$r の［
`onclick^c,
`ondblclick^c,
`onmousedown^c,
`onmouseup^c,
`onmouseover^c,
`onmousemove^c,
`onmouseout^c
］属性に由来する。
この~event~moduleは、
特定的には，~pointing入力~装置
（~mouseや~trackballなど）
で利用するために設計されている。
◎
The mouse event module originates from the [HTML401] onclick, ondblclick, onmousedown, onmouseup, onmouseover, onmousemove, and onmouseout attributes. This event module is specifically designed for use with pointing input devices, such as a mouse or a trackball.
</p>

			<section id="interface-mouseevent">
<h4 title="Interface MouseEvent">3.4.1. `MouseEvent^I ~interface</h4>

<p class="intro-dom">
DOM Level 2 にて導入され、
この仕様にて改変された。
◎
Introduced in DOM Level 2, modified in this specification
</p>

<p>
`MouseEvent^I ~interfaceは、
`~mouse~event$に特有な文脈的~情報を供する。
◎
The MouseEvent interface provides specific contextual information associated with Mouse events.
</p>

<p>
入子な要素に対しては、
~mouse~eventは、
通例的には【！always】，最も深い入子な要素を~targetにすることになる。

◎
In the case of nested elements, mouse events are always targeted at the most deeply nested element.
</p>

<p class="note">注記：
~targetにされた要素の先祖は、
~event浮上を利用して，子孫~要素の中で生じた~mouse~eventの通知を得することができる。
◎
Ancestors of the targeted element can use event bubbling to obtain notifications of mouse events which occur within their descendent elements.
</p>

<p>
`MouseEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `MouseEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the MouseEvent interface, use the MouseEvent constructor, passing an optional MouseEventInit dictionary.
</p>

<p class="note">注記：
実装は、
~client座標
`clientX^c, `clientY^c
を利用して，［
`initMouseEvent()$m を利用して `MouseEvent^I ~objを初期化する際
］の他の座標
（ “DOM Level 0” 】実装や他の~proprietaryな属性
— 例えば `pageX^c など —
により公開される~targetの座標）
を計算できる。
◎
When initializing MouseEvent objects using initMouseEvent, implementations can use the client coordinates clientX and clientY for calculation of other coordinates (such as target coordinates exposed by DOM Level 0 implementations or other proprietary attributes, e.g., pageX).
</p>

				<section id="idl-mouseevent">
<h5>3.4.1.1. `MouseEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `MouseEvent@I : `UIEvent$I {
    `MouseEvent@mc(`DOMString$ %type, optional `MouseEventInit$I %eventInitDict = {});

    readonly attribute `long$ `screenX$m;
    readonly attribute `long$ `screenY$m;
    readonly attribute `long$ `clientX$m;
    readonly attribute `long$ `clientY$m;
    readonly attribute `long$ `layerX$m;
    readonly attribute `long$ `layerY$m;

    readonly attribute `boolean$ `ctrlKey$m;
    readonly attribute `boolean$ `shiftKey$m;
    readonly attribute `boolean$ `altKey$m;
    readonly attribute `boolean$ `metaKey$m;

    readonly attribute `short$ `button$m;
    readonly attribute `unsigned short$ `buttons$m;

    readonly attribute `EventTarget$I? `relatedTarget$m;

    `boolean$ `getModifierState$m(`DOMString$ %keyArg);
};
</pre>

<dl class="idl-def">
	<dt>
`screenX@m
◎
screenX, of type long, readonly
</dt>
	<dd>
~screen座標系の原点に相対的な，~eventが生じた~~地点の横方向~座標。
◎
The horizontal coordinate at which the event occurred relative to the origin of the screen coordinate system.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`screenY@m
◎
screenY, of type long, readonly
</dt>
	<dd>
横方向を縦方向に読み替える下で，
`screenX$m と同じ。
◎
The vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`clientX@m
◎
clientX, of type long, readonly
</dt>
	<dd>
~eventに結付けられた表示域に相対的な，~eventが生じた~~地点の横方向~座標。
◎
The horizontal coordinate at which the event occurred relative to the viewport associated with the event.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`clientY@m
◎
clientY, of type long, readonly
</dt>
	<dd>
横方向を縦方向に読み替える下で，
`clientX$m と同じ。
◎
The vertical coordinate at which the event occurred relative to the viewport associated with the event.
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`layerX@m
◎
layerX, of type long, readonly
</dt>
	<dd>
<p>
~AND↓ を満たす要素のうち【`現在の~target$】に最も近いもの【が生成する~boxの左上隅】からの【~eventが生じた~~地点の】横方向~offset：
</p>
		<ul>
			<li>
【`~box~tree$において，`現在の~target$の】`先祖$である
</li>
			<li>
`積層~文脈$を生成している【！is a】
</li>
			<li>
`有位置$である
</li>
			<li>
`積層~文脈を塗る$ときに有位置 `phase^en【？】 にて塗られる
</li>
		</ul>

<p class="trans-note">【
該当する要素が無い場合について言及されていない
（ ［
`clientX$m ／ `clientY$m
］と同じになる？）。
】</p>
◎
The horizontal offset from the nearest ancestor element which is a stacking context, is positioned, or paints in the positioned phase when painting a stacking context.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`layerY@m
◎
layerY, of type long, readonly
</dt>
	<dd>
横方向を縦方向に読み替える下で，
`layerX$m と同じ。
◎
The vertical offset from the nearest ancestor element which is a stacking context, is positioned, or paints in the positioned phase when painting a stacking context.
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`ctrlKey@m
</dt>
	<dt>
`shiftKey@m
</dt>
	<dt>
`altKey@m
</dt>
	<dt>
`metaKey@m
</dt>
	<dd>
これらについては、
`KeyboardEvent$I の同じ名前の属性を見よ。
◎
ctrlKey, of type boolean, readonly
• Refer to the KeyboardEvent's ctrlKey attribute.
• The un-initialized value of this attribute MUST be false.
◎
shiftKey, of type boolean, readonly
• Refer to the KeyboardEvent's shiftKey attribute.
• The un-initialized value of this attribute MUST be false.
◎
altKey, of type boolean, readonly
• Refer to the KeyboardEvent's altKey attribute.
• The un-initialized value of this attribute MUST be false.
◎
metaKey, of type boolean, readonly
• Refer to the KeyboardEvent's metaKey attribute.
• The un-initialized value of this attribute MUST be false.
</dd>
	<dd>
`未初期化~値$： ~F
◎
↑</dd>

	<dt>
`button@m
◎
button, of type short, readonly
</dt>
	<dd>
~mouse~buttonの状態~変化による~mouse~eventに対しては、
この属性を利用して，その状態を変化させた~pointing装置の~buttonを指示するモノトスル。
◎
During mouse events caused by the depression or release of a mouse button, button MUST be used to indicate which pointer device button changed state.
</dd>
	<dd>
<p>
この属性に対する整数~値 ~IN { 0 〜 4 } は、
次を指示するモノトスル：
◎
The value of the button attribute MUST be as follows:
</p>
		<ul>
			<li>
0 は、
装置の首~button
（一般に、
~UI~controlや選択~textを作動化するために利用される，
左~button, または 単-~buttonな装置の唯一の~button）,
または`未初期化~値$。
◎
0 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text) or the un-initialized value.
</li>
			<li>
1 は、
予備~button
（一般に，中央~button — ~mouse~wheelと組合されることが多い）。
◎
1 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).
</li>
			<li>
2 は、
副~button
（一般に，右~button — 文脈~menuを表示するために利用されることが多い）。
◎
2 MUST indicate the secondary button (in general, the right button, often used to display a context menu).
</li>
			<li>
3 は、
~X1（ `back^en ）~button。
◎
3 MUST indicate the X1 (back) button.
</li>
			<li>
4 は、
~X2（ `forward^en ） ~button。
◎
4 MUST indicate the X2 (forward) button.
</li>
		</ul>
	</dd>
	<dd>
~pointing装置には，もっと他の~button状態を［
供する／模造する
］ものもあり、
そのような~buttonを表現するために，上に挙げたもの以外の整数が利用されることもある。
◎
Some pointing devices provide or simulate more button states, and values higher than 2 or lower than 0 MAY be used to represent such buttons.
</dd>
	<dd class="note">注記：
`button$m の値は、
~mouse~buttonの状態~変化によるものでない~eventに対しては，更新されない。
そのような局面における値 0 は、
左~buttonではなく，`未初期化~値$として解釈すること。
◎
The value of button is not updated for events not caused by the depression/release of a mouse button. In these scenarios, take care not to interpret the value 0 as the left button, but rather as the un-initialized value.
</dd>
	<dd class="note">注記：
`mousedown$et や `mouseup$et などの~eventに関係する`既定~動作$には、
利用-中にある特定の~mouse~buttonに依存するものもある。
◎
Some default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`buttons@m
◎
buttons, of type unsigned short, readonly
</dt>
	<dd>
~mouse~buttonが現在どの組合nで押されているかを表出する~bitmask。
どの~mouse~eventにおいても、
それを指示するときには，この属性を利用するモノトスル。
◎
During any mouse events, buttons MUST be used to indicate which combination of mouse buttons are currently being pressed, expressed as a bitmask.
</dd>
	<dd class="note">注記：
似た名前の `button$m 属性がとる値とは，まったく異なる。
`button^m の値を妥当と見做せるのは，
`mousedown$et ／ `mouseup$et
`~event~handler$の中に限られる一方、
`buttons^m 属性は，`~trusted$な どの `MouseEvent^I ~objに対しても（それが配送される間）~mouseの各~buttonの状態を反映する
— それは、
“現在どの~buttonも作動中でない” 状態（ 0 ）も表現できるので。
◎
Though similarly named, the values for the buttons attribute and the button attribute are very different. The value of button is assumed to be valid during mousedown / mouseup event handlers, whereas the buttons attribute reflects the state of the mouse’s buttons for any trusted MouseEvent object (while it is being dispatched), because it can represent the "no button currently active" state (0).
</dd>
	<dd>
<p>
`buttons$m 属性の~bitmask値［
0 ／ 1 ／ 2  ／ 4 
］は、
次を指示するモノトスル：
◎
The value of the buttons attribute MUST be as follows:
</p>
		<ul>
			<li>
0 は、
どの~buttonも現在~作動中でないこと。
◎
0 MUST indicate no button is currently active.
</li>
			<li>
1 は、
装置の首~button
（一般に、
~UI~controlや選択~textを作動化するために利用される，左~button, または単-~buttonな装置の唯一の~button）。
◎
1 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text).
</li>
			<li>
2 は、
副~button
（一般に，右~button
— 文脈~menuを表示するために利用されることが多い）。
◎
2 MUST indicate the secondary button (in general, the right button, often used to display a context menu), if present.
</li>
			<li>
4 は、
予備~button
（一般に，中央~button
— ~mouse~wheelと組合されることが多い）。
◎
4 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).
</li>
		</ul>

	</dd>
	<dd>
~pointing装置には、
上述以外の~buttonを供する／模造するものもある
— そのような~buttonを表現する値は，各~buttonごとに倍々にするモノトスル
（ 8, 16, 32, ... ）。
◎
Some pointing devices provide or simulate more buttons. To represent such buttons, the value MUST be doubled for each successive button (in the binary series 8, 16, 32, ... ).
</dd>
	<dd class="note" id="buttons-mask">注記：
~buttonたち全体が成すどの状態も，各~button値の総和で一意に表現されるので、
内容~作者は，装置~上の~mouse~buttonがいくつあっても，~bitごとの演算を利用して，現在どの~buttonが押されているかを決定できる。
例えば、
値 3 は，左＆右~buttonが押された（押されている）ことを指示し、
値 5 は，左＆中央~buttonが押されたことを指示する。
◎
Because the sum of any set of button values is a unique number, a content author can use a bitwise operation to determine how many buttons are currently being pressed and which buttons they are, for an arbitrary number of mouse buttons on a device. For example, the value 3 indicates that the left and right button are currently both pressed, while the value 5 indicates that the left and middle button are currently both pressed.
</dd>
	<dd class="note">注記：
【！複製】
`mousedown$et や `mouseup$et などの，一部の~eventに関係する`既定~動作$には、
どの~mouse~buttonが利用-中にあるかに依存するものもある。
◎
Some default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`relatedTarget@m
◎
relatedTarget, of type EventTarget, readonly, nullable
</dt>
	<dd>
~eventの型に依存して、
~UI~eventに関係する副 `EventTarget$I を識別するために利用される。
◎
Used to identify a secondary EventTarget related to a UI event, depending on the type of event.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>
`getModifierState(keyArg)@m
</dt>
	<dd>
`この仕様にて導入された。^em
◎
Introduced in this specification
</dd>
	<dd>
`KeyboardEvent.getModifierState()$m
~methodを見よ。
◎
Queries the state of a modifier using a key value.
◎
Returns true if it is a modifier key and the modifier is activated, false otherwise.
◎
DOMString keyArg 
◎
Refer to the KeyboardEvent's getModifierState() method for a description of this parameter.
</dd>
</dl>

				</section>
				<section id="idl-mouseeventinit">
<h5>3.4.1.2. `MouseEventInit^I</h5>

<pre class="idl">
dictionary `MouseEventInit@I : `EventModifierInit$I {
    `long$ `screenX@m = 0;
    `long$ `screenY@m = 0;
    `long$ `clientX@m = 0;
    `long$ `clientY@m = 0;

    `short$ `button@m = 0;
    `unsigned short$ `buttons@m = 0;
    `EventTarget$I? `relatedTarget@m = null;
};
</pre>

<!-- 5.3.1.3 Dictionary MouseEventInit Members -->

<p>
この辞書の各~memberは、
`MouseEvent!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
screenX, of type long, defaulting to 0
• Initializes the screenX attribute of the MouseEvent object to the desired horizontal relative position of the mouse pointer on the user’s screen.
• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
screenY, of type long, defaulting to 0
• Initializes the screenY attribute of the MouseEvent object to the desired vertical relative position of the mouse pointer on the user’s screen.

• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
clientX, of type long, defaulting to 0
• Initializes the clientX attribute of the MouseEvent object to the desired horizontal position of the mouse pointer relative to the client window of the user’s browser.
• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
clientY, of type long, defaulting to 0
• Initializes the clientY attribute of the MouseEvent object to the desired vertical position of the mouse pointer relative to the client window of the user’s browser.
• Initializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.
◎
button, of type short, defaulting to 0
• Initializes the button attribute of the MouseEvent object to a number representing the desired state of the button(s) of the mouse.
• The value 0 is used to represent the primary mouse button, 1 is used to represent the auxiliary/middle mouse button, and 2 to represent the right mouse button. Numbers greater than 2 are also possible, but are not specified in this document.
◎
buttons, of type unsigned short, defaulting to 0
• Initializes the buttons attribute of the MouseEvent object to a number representing one or more of the button(s) of the mouse that are to be considered active.
• The buttons attribute is a bit-field. If a mask value of 1 is true when applied to the value of the bit field, then the primary mouse button is down. If a mask value of 2 is true when applied to the value of the bit field, then the right mouse button is down. If a mask value of 4 is true when applied to the value of the bit field, then the auxiliary/middle button is down.
• In JavaScript, to initialize the buttons attribute as if the right (2) and middle button (4) were being pressed simultaneously, the buttons value can be assigned as either:
    { buttons: 2 | 4 }
    or:
    { buttons: 6 }
◎
relatedTarget, of type EventTarget, nullable, defaulting to null
• The relatedTarget should be initialized to the element whose bounds the mouse pointer just left (in the case of a mouseover or mouseenter event) or the element whose bounds the mouse pointer is entering (in the case of a mouseout or mouseleave or focusout event). For other events, this value need not be assigned (and will default to null).
</p>

<p>
`MouseEvent$I ~objが指示する~mouse位置がどう初期化されようが，利用者の~mouse~pointerはその位置に動かされないモノトスル。
◎
↑</p>

<p>
実装は、
~mouse~eventを生成するときには，
`現在の~click回数@
を保守するモノトスル。
これは、
【同じ】~pointing装置の~buttonが，特定の時間~内に連続して~clickされた数を指示する負でない整数になるモノトスル。
どの程度の遅延で回数が~resetされるかは、
環境設定0に特有になる。
◎
Implementations MUST maintain the current click count when generating mouse events. This MUST be a non-negative integer indicating the number of consecutive clicks of a pointing device button within a specific time. The delay after which the count resets is specific to the environment configuration.
</p>

<p class="trans-note">【
回数が増加される~~正確な時機がいつなのか記されていないが、
`click$et ~eventが配送される直前と思われる。
】【
複数の~pointing装置があるときは、
装置ごとに~click回数を保守する？
それとも，~clickした装置が切り替わったら，~click回数は~resetされる？
】</p>

				</section>
			</section>
			<section id="event-modifier-initializers">
<h4 title="Event Modifier Initializers">3.4.2. ~eventの~UIkey修飾 初期化子</h4>

<p>
［
`MouseEvent$I, `KeyboardEvent$I
］~interfaceは、
各種~keyboard修飾~属性を共有し，
追加的な修飾~状態を検索取得するための仕組みを~supportする。
次の辞書は、
作者が，これらの~interfaceの［
各種~keyboard修飾~属性, および［
`MouseEvent.getModifierState()$m ／ `KeyboardEvent.getModifierState()$m
］を介して~queryされる追加的な修飾~状態
］を初期化することを可能化する。
この辞書を利用して~eventを構築する手続きは、
<a href="#mouse-event-constructors">`Mouse^I ~eventの構築-法</a>
にて定義される。
◎
The MouseEvent and KeyboardEvent interfaces share a set of keyboard modifier attributes and support a mechanism for retrieving additional modifier states. The following dictionary enables authors to initialize keyboard modifier attributes of the MouseEvent and KeyboardEvent interfaces, as well as the additional modifier states queried via getModifierState(). The steps for constructing events using this dictionary are defined in the MouseEvent constructors section.
</p>

<pre class="idl">
dictionary `EventModifierInit@I : `UIEventInit$I {
    `boolean$ `ctrlKey$m = false;
    `boolean$ `shiftKey$m = false;
    `boolean$ `altKey$m = false;
    `boolean$ `metaKey$m = false;

    `boolean$ `modifierAltGraph$m = false;
    `boolean$ `modifierCapsLock$m = false;
    `boolean$ `modifierFn$m = false;
    `boolean$ `modifierFnLock$m = false;
    `boolean$ `modifierHyper$m = false;
    `boolean$ `modifierNumLock$m = false;
    `boolean$ `modifierScrollLock$m = false;
    `boolean$ `modifierSuper$m = false;
    `boolean$ `modifierSymbol$m = false;
    `boolean$ `modifierSymbolLock$m = false;
};
</pre>

<p>
以下において、
%~event は［
`MouseEvent$I ／ `KeyboardEvent$I
］いずれかを実装する~event~obj，
`getModifierState()^m は %~event 上の同じ名前の~method
（ `MouseEvent.getModifierState()$m ／ `KeyboardEvent.getModifierState()$m ）
を表すとする。
</p>

<dl class="idl-def">
	<dt>`ctrlKey@m</dt>
	<dt>`shiftKey@m</dt>
	<dt>`altKey@m</dt>
	<dt>`metaKey@m</dt>
	<dd>
<p>
これらの各~memberは、
%~event 上の同じ名前の属性を初期化する。
値の意味は、
`KeyboardEvent$I の同じ名前の属性の記述を見よ。
</p>

<p>
加えて，実装は、
%~event の`内部~UIkey修飾~状態$を［
下の表tの 2 列目の値を引数に %~event 上の `getModifierState()^m が呼出されたときは，その行の 1 列目の名前の~member値が返される
］ように初期化するモノトスル。
</p>

<table><thead>
<tr><th>名前
<th>引数
<tbody>

<tr><td>`altKey^c
<td>`Alt^l【！^cap】

<tr><td>`ctrlKey^c
<td>`Control^l

<tr><td>`altKey^c
<td>`Meta^l

<tr><td>`shiftKey^c
<td>`Shift^l
</table>

◎
ctrlKey, of type boolean, defaulting to false
• Initializes the ctrlKey attribute of the MouseEvent or KeyboardEvent objects to true if the Control key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Control must return true.
◎
shiftKey, of type boolean, defaulting to false
• Initializes the shiftKey attribute of the MouseEvent or KeyboardEvent objects to true if the Shift key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Shift must return true.
◎
altKey, of type boolean, defaulting to false
• Initializes the altKey attribute of the MouseEvent or KeyboardEvent objects to true if the Alt (alternative) (or Option) key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Alt must return true.
◎
metaKey, of type boolean, defaulting to false
• Initializes the metaKey attribute of the MouseEvent or KeyboardEvent objects to true if the Meta key modifier is to be considered active, false otherwise.
• When true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with either the parameter Meta must return true.
</dd>

	<dt>`modifierAltGraph@m</dt>
	<dt>`modifierCapsLock@m</dt>
	<dt>`modifierFn@m</dt>
	<dt>`modifierFnLock@m</dt>
	<dt>`modifierHyper@m</dt>
	<dt>`modifierNumLock@m</dt>
	<dt>`modifierScrollLock@m</dt>
	<dt>`modifierSuper@m</dt>
	<dt>`modifierSymbol@m</dt>
	<dt>`modifierSymbolLock@m</dt>
	<dd>
これらの~memberは、
%~event の`内部~UIkey修飾~状態$を［
対応する`~UIkey修飾~名$
— すなわち、
~member名を `modifier<var>XXX</var>^c とするときの，文字列 %XXX —
を引数に %~event 上の `getModifierState()^m が呼出されたときは，
その~member値が返される
］ように初期化する。

◎
modifierAltGraph, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter AltGraph must return true.
◎
modifierCapsLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter CapsLock must return true.
◎
modifierFn, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Fn must return true.
◎
modifierFnLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter FnLock must return true.
◎
modifierHyper, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Hyper must return true.
◎
modifierNumLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter NumLock must return true.
◎
modifierScrollLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter ScrollLock must return true.
◎
modifierSuper, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Super must return true.
◎
modifierSymbol, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Symbol must return true.
◎
modifierSymbolLock, of type boolean, defaulting to false
• Initializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter SymbolLock must return true.
</dd>
</dl>

			<section id="mouse-event-constructors">
<h4 title="Constructing Mouse Events">3.4.2.1. `Mouse^I ~eventの構築-法</h4>

<p>
一般に、
`Event$I ~interface またはそれを継承する~interfaceの構築子が呼出されたときは，
`DOM$r に述べられる手続きに従うべきであるが、
それに加え，
`MouseEvent$I ~interfaceは、［
`Event$I ~objにおける`~UIkey修飾＠#keys-modifiers$の内部~状態を初期化する
］ための追加的な辞書~memberも供する。
この内部~状態は、
特定的には `MouseEvent.getModifierState()$m ~methodを用いて~queryできる。
この節では、
`DOM$r【！DOM4】 による新たな `MouseEvent$I ~objを初期化する手続きに，
この修飾~状態の初期化も補足する。
◎
Generally, when a constructor of an Event interface, or of an interface inherited from the Event interface, is invoked, the steps described in [DOM] should be followed. However the MouseEvent interfaces provide additional dictionary members for initializing the internal state of the Event object’s key modifiers: specifically, the internal state queried for using the getModifierState() methods. This section supplements the DOM4 steps for intializing a new MouseEvent object with these optional modifier states.
</p>

<div class="p">
<p>
`MouseEvent$I ~interface（それを継承するものも含む）を実装する各~objは、
各`~UIkey修飾~名$ごとに対応する
`内部~UIkey修飾~状態@
を有する。
それは：
</p>
<ul>
	<li>
`UIEvents-Key$r の`修飾~UIkeyの表t$内に述べられる
`~UIkey修飾~名@
を用いて検索取得できる。
</li>
	<li>
<p>
次に与える~algoを利用して，~objを構築する際に設定できる
— `DOM$r【！DOM4】 による~eventの構築-法に定義される~algoには、
次の手続きが補足される：
</p>
<div class="algo">
<p>
~event~obj %~event を構築するとき，構築子に
( `EventModifierInit$I 引数 %eventInitDict )
が供された場合は、
次を走らす：
</p>
		<ol>
			<li>
<p>
~EACH( `~UIkey修飾~名$ %名前 )
に対し：
</p>
				<ol>
					<li>
%~member名 ~LET 次を順に`連結する$
⇒＃
`modifier^l,
%名前
</li>
					<li>
~IF［
%eventInitDict[ %~member名 ] ~NEQ ε
］
⇒
%名前 に対応する， %~event の`内部~UIkey修飾~状態$ ~SET %eventInitDict[ %~member名 ]
</li>
				</ol>
			</li>
		</ol>
</div>
◎
For the purposes of constructing a MouseEvent, or object derived from these objects using the algorithm below, all MouseEvent, and derived objects have internal key modifier state which can be set and retrieved using the key modifier names described in the Modifier Keys table in [UIEvents-Key].
◎
The following steps supplement the algorithm defined for constructing events in DOM4:
• If the Event being constructed is a MouseEvent object or an object that derives from it, and a EventModifierInit argument was provided to the constructor, then run the following sub-steps:
•• For each EventModifierInit argument, if the dictionary member begins with the string "modifier", then let the key modifier name be the dictionary member’s name excluding the prefix "modifier", and set the Event object’s internal key modifier state that matches the key modifier name to the corresponding value.
</li>
</ul>
</div>

<p class="trans-note">【
`内部~UIkey修飾~状態$は，
`MouseEvent$I 用に新たに導入された`修飾~UIkey状態~map$と重複するが、
後者が受持つ`~UIkey修飾~名$は，一部に限られる。
】</p>

				</section>
			</section>
			<section id="mouseevent-algorithms">
<h4 title="MouseEvent Algorithms">3.4.3. `MouseEvent!I 用の~algo</h4>

				<section id="mouseevent-native-requirements">
<h5 title="Native OS Requirements">3.4.3.1. ~native~OS要件</h5>

<p>
この節に与える~algoは、
~native~platform~OSが次を供することになるものと見做す：
◎
The algorithms in this section assume that the native platform OS will provide the following:
</p>
<ul>
	<li>
~nativeな~mousemove
⇒
~mouseが動かされたときの~event
（`~nativeな~mousemoveを取扱う$により取扱われる）
◎
An event when the mouse is moved (handled by handle native mouse move)
</li>
	<li>
~nativeな~mousedown
⇒
~mouse~buttonが押されたときの~event
（`~nativeな~mousedownを取扱う$により取扱われる）
◎
An event when a mouse button is pressed (handled by handle native mouse down)
</li>
	<li>
~nativeな~mouseup
⇒
~mouse~buttonが離されたときの~event
（`~nativeな~mouseupを取扱う$により取扱われる）
◎
An event when a mouse button is released (handled by handle native mouse up)
</li>
	<li>
<p>
~mouse~buttonが押されたとき，それを “~click” として解釈するべきか否かを識別する仕方
（`~nativeな~clickを取扱う$により取扱われる）：
◎
A way to identify when a mouse button press should be interpreted as a "click" (handled by handle native mouse click)
</p>
		<ul>
			<li>
例えば、
ある~flagとして，あるいは別々な~eventとして
◎
For example, as a flag or as a separate event
</li>
			<li>
別々な “~click” ~eventとして発火する場合には、
~native~OSは，それを対応する［
~mouse~buttonが離されたときの~event【！"mouseup" event】
］の直後に
— その間に，~mouseに関係する他の~eventは介在することなく —
発火することになる。
◎
If a separate "click" event is fired, then the native OS will fire it immediately after the corresponding "mouse up" event, with no intervening mouse-related events
</li>
		</ul>
	</li>
	<li>
所与の~clickを “~double-click” として解釈するべきか否かを識別する仕方
（`~nativeな~double-clickを取扱う$により取扱われる）
◎
A way to identify when a mouse click is a "double click" (handled by handle native mouse double click)
</li>
</ul>

<p class="trans-note">【
原文には触れられていないが、
これは，実質的には、
~UAが［
所与の~nativeな~eventが どの`文書$上で生じたか
］を決定する処理nも含意する。
以下に定義される各~algoは、
暗黙的に，当の~eventが生じた文書の文脈で遂行されるものと見做される。
】</p>

<p>
加えて、
これらの~event用に，次に挙げる報を供することも可能であると見做す：
◎
For these events, the OS will be able to provide the following info:
</p>
<ul>
	<li>
<p>
~desktop座標
⇒
~native~OSの~desktop【の原点】に相対的な ( ~x, ~y ) ~mouse座標
</p>

<p class="trans-note">【
~desktopとは何なのかは定義されていない。
】</p>
◎
The x,y mouse coordinates relative to the native OS desktop
</li>
	<li>
<p>
`表示域~座標@
⇒
~UAの~UIwindow表示域【の原点】に相対的な ( ~x, ~y ) ~mouse座標
◎
The x,y mouse coordinates relative to the UA’s window viewport
</p>

<p class="trans-note">【
これは、
実際には［
~UIwindowではなく`文書$
］の`表示域$の原点に相対的な座標として利用される。
したがって、
実質的には，当の文書が呈示される位置（~UAにより決定される）にも基づくことになる。
】</p>
	</li>
	<li>
~keyboardにて現在~~押されている修飾~UIkeyたち
【`修飾~UIkey状態~map$に挙げる文字列で識別される。】
◎
Which keyboard modifiers are currently being held
</li>
	<li>
`~mouse~button名@
【この項は、この訳による補完】
⇒
~mouse~buttonが［
押された／離された
］ときの~event用に，どの~buttonが［
押された／離された
］かを識別する値として，次に挙げるいずれかが供される
（それらの意味は `button$m を見よ）
⇒＃
`首~button^i,
`予備~button^i,
`副~button^i,
`~X1~button^i,
`~X2~button^i
</li>
</ul>

				</section>
				<section id="mouseevent-global-state">
<h5 title="Global State for MouseEvent">3.4.3.2. `MouseEvent^I 用の大域的な状態</h5>

<p id="mouseevent-global-ua">
~UAは、
~UA全体で共有される値をとして，次を保守するモノトスル
⇒
`~mouse~button~bitmask@
⇒
各~mouse~buttonの現在の状態を追跡する。
◎
4.4.3.2.1. User Agent-Level State
◎
The UA must maintain the following values that are shared for the entire User Agent.
◎
A mouse button bitmask that tracks the current state of the mouse buttons.
</p>

<p id="mouseevent-global-window">
~UAは、
各`~window$の中で共有される値をとして，次を保守するモノトスル：
◎
4.4.3.2.2. Window-Level State
◎
The UA must maintain the following values that are shared for the Window.
</p>
<ul>
	<li>
`最後の~mouse要素@
⇒
`MouseEvent$I が最後に送信された要素【！`Element$I】を追跡し続ける
— 初期~時は ~NULL【！undefined】 とする。
◎
A last mouse element value (initially undefined) that keeps track of the last Element that we sent a MouseEvent to.
</li>
	<li>
`最後の~mouse~DOM経路@
⇒
最も近過去に~mouse~eventを送信した時点における`最後の~mouse要素$の先祖~要素【！`Element$I】たちが成す~list（~snapshot）
— 初期~時は空とする。
◎
A last mouse DOM path value (initially empty) that contains a snapshot of the ancestors Elements of the last mouse element when the most recent mouse event was sent.
</li>
</ul>

				</section>
				<section id="mouseevent-internal-state">
<h5 title="Internal State for MouseEvent">3.4.3.3. `MouseEvent^I 用の内部~状態</h5>

<div>
<p>
各 `MouseEvent$I は、
`修飾~UIkey状態~map@
を有する
— それは、
~mouse~eventに関連な修飾~UIkeyたちの状態を追跡するために利用される`~map$であり，
初期~時は空とする
（~eventの作成-時に拡充される）：
</p>
<ul>
	<li>
~mapを成す各~keyは、
文字列であり，次に挙げる`~UIkey修飾~名$として与えられる
⇒＃
`Shift^l,
`Control^l,
`Alt^l,
`AltGraph^l,
`Meta^l
</li>
	<li>
対応する各~値は、
真偽値をとる
— 当の~keyが指示する修飾~UIkeyが当の~mouse~eventが生じた時点に押されて［
いたならば ~T ／
いなかったならば ~F
］に設定される。
</li>
</ul>

◎
A MouseEvent has the following internal flags that are used to track the state of various modifier keys: shift flag, control flag, alt flag, altgraph flag, and meta flag. These flags are set if the corresponding modifier key was pressed at the time of the mouse event.
</div>

<p class="trans-note">【
これは、
原文では，挙げられた各~UIkey名ごとに その名前を伴う~flagとして定義されているが、
この訳では，一つの~mapに集約することにする。
】</p>

				</section>
				<section id="_algorithms-for-mouseevent">
<h4>3.4.3.4. 各種~algo</h4>

<div class="algo">
<p>
`~MouseEventを初期化する@
ときは、
所与の
⇒＃
`MouseEvent$I %~event,
文字列 %~event型,
`EventTarget$I %~event~target,
真偽値 %浮上するか,
真偽値 %取消~可能か
◎終
に対し：
◎
4.4.3.4. initialize a MouseEvent
◎
Input
• event, the MouseEvent to initialize
• eventType, a DOMString containing the event type
• eventTarget, the EventTarget of the event
• bubbles, true if this event bubbles
• cancelable, true if this event is cancelable
Output
• None
</p>
<ol>
	<li>
`~UIEventを初期化する$( %~event, %~event型, %~event~target, %浮上するか, %取消~可能か )
◎
Initialize a UIEvent with event, eventType, eventTarget, bubbles and cancelable.
</li>
	<li>
<p>
`MouseEvent$I の各~属性を初期化する：
</p>
		<ol>
			<li>
%位置 ~LET 当の~eventが生じた位置
【この情報は、本当は引数として渡される必要があろう。】
</li>
			<li>
%~event の
⇒＃
`screenX$m ~SET ~desktopの原点に相対的な %位置 の~x座標,
`screenY$m ~SET ~desktopの原点に相対的な %位置 の~y座標,
`clientX$m ~SET `表示域$の原点に相対的な %位置 の~x座標,
`clientY$m ~SET `表示域$の原点に相対的な %位置 の~y座標,
`button$m ~SET 0,
`buttons$m ~SET `~mouse~button~bitmask$
</li>
			<li>
`~mouse~eventの修飾~UIkey状態を設定する$( %~event )
</li>
		</ol>
◎
Initialize the following public attributes:
• Set event.screenX = the x-coordinate of the position where the event occurred relative to the origin of the desktop
• Set event.screenY = the y-coordinate of the position where the event occurred relative to the origin of the desktop
• Set event.clientX = the x-coordinate of the position where the event occurred relative to the origin of the viewport
• Set event.clientY = the y-coordinate of the position where the event occurred relative to the origin of the viewport
• Set mouse event modifiers with event
• Set event.button = 0
• Set event.buttons = mouse button bitmask
</li>
	<li>
`~MouseEvent用に各~pointer~lock属性を初期化する$( %~event )
◎
Initialize PointerLock attributes for MouseEvent with event
</li>
</ol>
</div>

<div class="algo">
<p>
`~mouse~eventの修飾~UIkey状態を設定する@
ときは、
所与の
( `MouseEvent$I %~event )
に対し：
◎
4.4.3.5. set mouse event modifiers
◎
Input
• event, the MouseEvent to update
Output
• None
</p>
<ol>
	<li>
%修飾~状態 ~LET %~event の`修飾~UIkey状態~map$
</li>
	<li>
« `Shift^l, `Control^l, `Alt^l, `AltGraph^l, `Meta^l »
を成す
~EACH( %~UIkey名 )
に対し
⇒
%修飾~状態[ %~UIkey名 ] ~SET `修飾~UIkey状態$( %~UIkey名 )
◎
Set event’s shift flag if key modifier state includes "Shift", unset it otherwise
◎
Set event’s control flag if key modifier state includes "Control", unset it otherwise
◎
Set event’s alt flag if key modifier state includes "Alt", unset it otherwise
◎
Set event’s altgraph flag if key modifier state includes "AltGraph", unset it otherwise
◎
Set event’s meta flag if key modifier state includes "Meta", unset it otherwise
</li>
	<li>
%~event の `shiftKey$m ~SET %修飾~状態[ `Shift^l ]
◎
Set event.shiftKey = true if the event’s shift flag is set, false otherwise
</li>
	<li>
%~event の `ctrlKey$m ~SET %修飾~状態[ `Control^l ]
◎
Set event.ctrlKey = true if the event’s control flag is set, false otherwise
</li>
	<li>
%~event の `altKey$m ~SET ~IS［
%修飾~状態[ `Alt^l ] ~EQ ~T
］~AND［
%修飾~状態[ `AltGraph^l ] ~EQ ~T
］
◎
Set event.altKey = true if the event’s alt flag or altgraph flag is set, false otherwise
</li>
	<li>
%~event の `metaKey$m ~SET %修飾~状態[ `Meta^l ]
◎
Set event.metaKey = true if the event’s meta flag is set, false otherwise
</li>
</ol>
</div>

<div class="algo">
<p>
`~MouseEventを作成する@
ときは、
所与の
( 文字列 %~event型, `EventTarget$I 【または ~NULL】 %~event~target, %取消~不能か ~IN { `取消~不能^i, ε } （省略時は ε ）)
に対し：
◎
4.4.3.6. create a cancelable MouseEvent
◎
Input
• eventType, a DOMString containing a valid MouseEvent type
• eventTarget, the EventTarget of the event
Output
• None
</p>
<ol>
	<li>
%取消~可能か ~LET ~IS［
%取消~不能か ~EQ ε
］
◎
Let bubbles be "true"
◎
Let cancelable be "true"
</li>
	<li>
%浮上するか ~LET %取消~可能か
◎
↑↓</li>
	<li>
%~event ~SET `~eventを作成する$( `MouseEvent$I )
◎
Let event = the result of creating a new event using MouseEvent
</li>
	<li>
`~MouseEventを初期化する$( ↓ )
⇒＃
%~event,
%~event型,
%~event~target,
%浮上するか,
%取消~可能か
◎
Initialize a MouseEvent with event, eventType, eventTarget, bubbles and cancelable.
</li>
	<li>
~RET %~event
◎
Return event
</li>
</ol>

<div>
<p class="trans-note">【
これは，原文では 2 つの~algo
— “取消~可能な~MouseEventを作成する”, “取消~不能な~MouseEventを作成する” —
に分けて定義されているが、
この訳では，追加的な引数 %取消~可能か を導入することにより一つに統合することにする。
】</p>
◎
4.4.3.7. create a non-cancelable MouseEvent
◎
Input
• eventType, a DOMString containing a valid MouseEvent type
• eventTarget, the EventTarget of the event
Output
• None
◎
Let bubbles be "false"
◎
Let cancelable be "false"
◎
Let event = the result of creating a new event using MouseEvent
◎
Initialize a MouseEvent with event, eventType, eventTarget, bubbles and cancelable.
◎
Return event
</div>
</div>

<div class="algo">
<p>
`~button名を整数に変換する@
ときは、
所与の
( `~mouse~button名$ %~button~ID )
に対し，
`MouseEvent$I の `button$m 属性への格納-用に相応しい値を返す：
◎
4.4.3.8. calculate MouseEvent button attribute
◎
Input
• mbutton, an ID that identifies a mouse button
Output
• A button ID suitable for storing in the MouseEvent's button attribute
</p>
<ol>
	<li>
~RET %~button~ID に応じて
⇒＃
`首~button^i ならば 0 ／
`予備~button^i ならば 1 ／
`副~button^i ならば 2 ／
`~X1~button^i ならば 3 ／
`~X2~button^i ならば 4
◎
If mbutton is the primary mouse button, then return 0
◎
If mbutton is the auxiliary (middle) mouse button, then return 1
◎
If mbutton is the secondary mouse button, then return 2
◎
If mbutton is the X1 (back) button, then return 3
◎
If mbutton is the X2 (forward) button, then return 4
</li>
</ol>
</div>

<div class="algo">
<p>
`~MouseEvent属性を~nativeな~eventから設定する@
ときは、
所与の
( `MouseEvent$I %~event, ~nativeな~mouse~event %~nativeな~event )
に対し：
◎
4.4.3.9. set MouseEvent attributes from native
◎
Input
• event, the MouseEvent to initialize
• native, the native mouse event
Output
• None
</p>

<ol>
	<li class="issue">
ここで設定すべき属性は他にもある。
◎
TODO
</li>
	<li>
~IF［
%~event の `type$m ~IN { `mousedown^l, `mouseup^l }
］
⇒
%~event の `button$m ~SET `~button名を整数に変換する$( %~nativeな~event の`~mouse~button名$ )
◎
If event.type is one of [ mousedown, mouseup ], then
• Let mbutton be an ID from native that identifies which mouse button was pressed
• Set event.button = calculate MouseEvent button attribute with mbutton
</li>
</ol>
</div>

<div class="algo">
<p>
`~nativeな~mousedownを取扱う@
ときは、
所与の
( ~nativeな~mousedown %~nativeな~event )
に対し：
◎
4.4.3.10. handle native mouse down
◎
Input
• native, the native mousedown
Output
• None
</p>
<ol>
	<li>
%~button~ID ~LET %~nativeな~event の`~mouse~button名$
◎
Let mbutton be an ID from native that identifies which mouse button was pressed
</li>
	<li>
<p>
`~mouse~button~bitmask$を更新する
— %~button~ID に応じて，次に与える~bitが 1 になるよう
⇒＃
`首~button^i ならば 0x01 ／
`副~button^i ならば 0x02 ／
`予備~button^i ならば 0x04
◎
Update the mouse button bitmask as follows:
• If mbutton is the primary mouse button, then set the 0x01 bit
• If mbutton is the secondary mouse button, then set the 0x02 bit
• If mbutton is the auxiliary (middle) mouse button, then set the 0x04 bit
</p>

<p class="note">注記：
より~~上位~bitに対応する他の~buttonも追加され得る。
◎
Other buttons can be added starting with 0x08
</p>
	</li>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target = hit test with viewport-relative coordinates from native
</li>
	<li>
%~event ~LET `~MouseEventを作成する$( `mousedown^l, %~target )
◎
Let event = create a cancelable MouseEvent with "mousedown", target
</li>
	<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with native
</li>
	<li>
`必要なら~pointer~eventを送信する$( %~event )
◎
Maybe send pointerdown event with event
</li>
	<li>
%取消されなかったか ~LET `~eventを配送する$( %~target, %~event )
◎
Let result = dispatch event at target
</li>
	<li>
~IF［
%取消されなかったか ~EQ ~T
］~AND［
%~target は`~focus可能な区画$である
］~AND［
%~target は`~clickで~focus可能$である
］
⇒
`~objを~focusする$( %~target )
◎
If result is true and target is a focusable area that is click focusable, then
• Run the focusing steps at target
</li>
	<li>
~IF［
%~button~ID ~EQ `副~button^i
］
⇒
`必要なら文脈~menuを示す$( %~nativeな~event, %~target )
◎
if mbutton is the secondary mouse button, then
• Maybe show context menu with native, target
</li>
</ol>
</div>

<div class="algo">
<p>
`~nativeな~mouseupを取扱う@
ときは、
所与の
( ~nativeな~mouseup %~nativeな~event )
に対し：
◎
4.4.3.11. handle native mouse up
◎
Input
• native, the native mouseup
Output
• None
</p>

<p class="note">注記：
`mousedown$et と `mouseup$et の合間には、
他の~mouse~eventも生じ得る。
◎
Other mouse events can occur between the mousedown and mouseup.
</p>
<ol>
	<li>
%~button~ID ~LET %~nativeな~event の`~mouse~button名$
◎
Let mbutton be an ID from native that identifies which mouse button was pressed
</li>
	<li>
`~mouse~button~bitmask$を更新する
— %~button~ID に応じて，次に与える~bitが 0 になるよう
⇒＃
`首~button^i ならば 0x01 ／
`副~button^i ならば 0x02 ／
`予備~button^i ならば 0x04
◎
Update the mouse button bitmask as follows:
• If mbutton is the primary mouse button, then clear the 0x01 bit
• If mbutton is the secondary mouse button, then clear the 0x02 bit
• If mbutton is the auxiliary (middle) mouse button, then clear the 0x04 bit
</li>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target = hit test with viewport-relative coordinates from native
</li>
	<li>
%~event ~LET `~MouseEventを作成する$( `mouseup^l, %~target )
◎
Let event = create a cancelable MouseEvent with "mouseup", target
</li>
	<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with native
</li>
	<li>
`必要なら~pointer~eventを送信する$( %~event )
◎
Maybe send pointerup event with event
</li>
	<li>
`~eventを配送する$( %~target, %~event )
◎
dispatch event at target
</li>
</ol>
</div>

<div class="algo">
<p>
`~nativeな~clickを取扱う@
ときは、
所与の
( ~nativeな~click %~nativeな~event )
に対し：
◎
4.4.3.12. handle native mouse click
◎
Input
• native, the native mouse click
Output
• None
</p>

<p class="note">注記：
~platformは、
~clickを生成する~mouseup用には，
`~nativeな~mouseupを取扱う$の直後にこれを~callするべきである。
◎
The platform should call this immediately after handle native mouse up for mouseups that generate clicks.
</p>
<ol>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target = hit test with viewport-relative coordinates from native
</li>
	<li>
`~click~eventを送信する$( %~nativeな~event, %~target )
◎
Send click event with native and target.
</li>
</ol>
</div>

<div class="algo">
<p>
`~click~eventを送信する@
ときは、
所与の
( ~nativeな~mousedown %~nativeな~event, `EventTarget$I %~target )
に対し：
◎
4.4.3.13. send click event
◎
Input
• native, the native mousedown
• target, the EventTarget of the event
Output
• None
</p>
<ol>
	<li>
%~event型 ~SET ［
次が満たされるならば `click^l ／
~ELSE_ `auxclick^l
］
⇒
［
%~nativeな~event は妥当でない
【何をもって “妥当” とされる？】
］~OR［
%~nativeな~event の`~mouse~button名$ ~EQ `首~button^i
］
◎
Let mbutton = 1 (primary mouse button by default)
◎
If native is valid, then
• Let mbutton be an ID from native that identifies which mouse button was pressed
◎
Set eventType = "click" if mbutton is the primary mouse button, otherwise "auxclick"
</li>
	<li>
%~event ~LET `~PointerEventを作成する$( %~event型, %~target )
◎
Let event = create a PointerEvent with eventType and target
</li>
	<li>
<p>
~IF［
%~nativeな~event は妥当である
］：
◎
If native is valid, then
</p>
		<ol>
			<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with event, native
</li>
			<li>
%~event の `screenX$m ~SET %~event の `screenX$m を整数に丸めた結果
◎
If event.screenX is not an integer value, then round it.
</li>
			<li>
%~event の `screenY$m ~SET %~event の `screenY$m を整数に丸めた結果
◎
If event.screenY is not an integer value, then round it.
</li>
		</ol>
	</li>
	<li>
`~eventを配送する$( %~target, %~event )
◎
dispatch event at target
</li>
</ol>

<p class="note">注記：
`PointerEvent^I, 丸められた座標を利用している~browserについての報は、
`PointerEvents3$r の`課題 #100＠https://github.com/w3c/pointerevents/issues/100$
を見よ。
◎
See pointerevents/100 for info about browsers using PointerEvents and rounded coordinates.
</p>

<p class="note">注記：
“`既定~動作$” は、［
配送する間に，~target用の`作動化の挙動$を誘発する
］ことにより取扱われる。
なので、
ここで それを取扱う必要は無い。
しかしながら、
既存の仕様が［
`不能化されて$feいるもの／
~CSS `pointer-events$p ／
`不活$なもの
］などを取扱うことを検証yする必要がある。
◎
Any "default action" is handled during dispatch by triggering the activation behavior algorithm for the target. So there is no need for handle that here. However, need to verify that the existing spec handles disabled/css-pointer-events/inert/...
</p>

<p class="note">注記：
`~HTML要素＠~HTMLINFRA#html-elements$【！HTMLelement】の `click()＠~HTMLinteraction#dom-click$c を取扱うときは、［
%~nativeな~event には ~NULL,
%~target には当の要素
］を渡して，この~algoを~callすること。
◎
To handle `HTMLelement.click()`, call this algorithm with native = null and target = `HTMLelement`.
</p>

<p class="note">注記：
~keyboardから起動される~clickを取扱うときは、［
%~nativeな~event には ~NULL,
%~target には現在~focusされている要素
］を渡して，この~algoを~callすること。
◎
To handle keyboard-initiated clicks, call this algorithm with native = null and target = currently focused element.
</p>
</div>

<div class="algo">
<p>
`~nativeな~double-clickを取扱う@
ときは、
所与の
( ~nativeな~double-click %~nativeな~event )
に対し：
◎
4.4.3.14. handle native mouse double click
◎
Input
• native, the native mouse double click
Output
• None
</p>

<p class="note">注記：
これは、
~double-clickを生成する~click用には，
`~nativeな~clickを取扱う$の直後に~callされるべきである。
◎
This should be called immediately after handle native mouse click for mouse clicks that generate double clicks.
</p>
<ol>
	<li>
~IF［
%~nativeな~event の`~mouse~button名$ ~NEQ `首~button^i
］
⇒
~RET
◎
Let mbutton be an ID from native that identifies which mouse button was pressed
◎
If mbutton is not the primary mouse button, then return
</li>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target = hit test with viewport-relative coordinates from native
</li>
	<li>
%~event ~LET `~PointerEventを作成する$( `dblclick^l, %~target )
◎
Let event = create a PointerEvent with "dblclick" and target
</li>
	<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with event, native
</li>
	<li>
%~event の `screenX$m ~SET %~event の `screenX$m を整数に丸めた結果
◎
If event.screenX is not an integer value, then round it.
</li>
	<li>
%~event の `screenY$m ~SET %~event の `screenY$m を整数に丸めた結果
◎
If event.screenY is not an integer value, then round it.
</li>
	<li>
`~eventを配送する$( %~target, %~event )
◎
dispatch event at target
</li>
</ol>
</div>

<div class="algo">
<p>
`~nativeな~mousemoveを取扱う@
ときは、
所与の
( ~nativeな~mousemove %~nativeな~event )
に対し：
◎
4.4.3.15. handle native mouse move
◎
Input
• native, the native mouse move
Output
• None
</p>

<p class="note">注記：
この~algoは、
`PointerEvent$I の配送について，ある種の前提を置く
— それらは、
現時点では明示的に指定されていないので。
`PointerEvents3$r の`課題 #285＠https://github.com/w3c/pointerevents/issues/285$
が解決されたなら、
これは更新される必要があろう。
◎
This algorithm makes assumptions about the dispatch of PointerEvents because they are not currently specified explicitly. Once pointerevents/285 is resolved this may need to be updated.
</p>
<ol>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target = hit test with viewport-relative coordinates from native
</li>
	<li>
%~target~DOM経路 ~LET `~DOM経路を計算する$( %~target )
◎
Let targetDomPath = calculate DOM path
</li>
	<li>
<p>
（この段は、
現在の要素から出て行く際の~eventを生成する。）
◎
Generate events for leaving the current element:
</p>

<p>
~IF［
`最後の~mouse要素$ ~NIN { ~NULL, %~target }
【！is defined and not equal to】
］：
◎
If last mouse element is defined and not equal to target, then
</p>
		<ol>
			<li>
%~mouseout ~LET `~MouseEventを作成する$( `mouseout^l, `最後の~mouse要素$ )
◎
Let mouseout = create a cancelable MouseEvent with "mouseout" and last mouse element
</li>
			<li class="issue">【！note】
%~nativeな~event から，
%~mouseout を成す `MouseEvent$I の属性
— `CSSOM-View$r による`拡張＠~CSSOMVIEW#extensions-to-the-mouseevent-interface$も含む —
を設定する。
◎
TODO: Set mouseout attributes from native. +CSSOM attributes
</li>
			<li>
`必要なら~pointer~eventを送信する$( %~mouseout )
◎
Maybe send pointerout event with mouseout
</li>
			<li>
<p>
`~eventを配送する$( %~target, %~mouseout )
◎
Dispatch mouseout at target
</p>

<p class="issue">【！note】
取消されたときの挙動を（その効果は無さそうに見えるが）検証yする。
◎
Verify behavior when canceled (appears to have no effect).
</p>
			</li>
			<li>
%~mouseleave要素~群 ~LET « »
◎
↓</li>
			<li>
`最後の~mouse~DOM経路$を成す
~EACH( %要素 )
に対し
⇒
~IF［
%要素 ~NIN %~target~DOM経路
］
⇒
%~mouseleave要素~群 に %要素 を`付加する$
◎
Let leaveElements be a copy of last mouse DOM path with all elements common to targetDomPath removed.
</li>
			<li>
<p>
%~mouseleave要素~群 を成す
~EACH( %要素 )
に対し：
◎
For each element in leaveElements, do
</p>

<p class="issue">【！note】
%要素 が【~event~handlerなどにより】［
削除された事例, 移動された事例
］を取扱う：
`mouseleave$et ~eventは、
~DOM変異により誘発-済みになるべきか？
ここで送信するべきか？
落とされるべきか？
— 現在の~browserが何を行っているか検証yする必要がある。
◎
Handle case where element has been deleted. Also case where it has been moved: Should the DOM mutation have triggered a mouseleave event? Should we sent it now? Should it be dropped? Need to verify what current browsers do.
</p>
				<ol>
					<li>
%~mouseleave ~LET `~MouseEventを作成する$( `mouseleave^l, 
%要素, `取消~不能^i )
◎
Let mouseleave = create a non-cancelable MouseEvent with "mouseleave" and element
</li>
					<li>
<p>
%~mouseleave の `composed$m ~SET ~F
◎
Set mouseleave.composed = false
</p>

<p class="issue">【！note】
互換性を検査する：
`composed$m の値は、
仕様に従うなら ~F になるが，［
Linux 上の Chrome においては ~T,
Linux 上の Firefox においては ~F
］になる。
◎
Check compat: Value of event.composed. Spec says false. Chrome/Linux = true. Firefox/Linux = false.
</p>
					</li>
					<li>
`必要なら~pointer~eventを送信する$( %~mouseleave )
◎
Maybe send pointerleave event with mouseleave
</li>
					<li>
【！利用されない変数 Let result = 】
`~eventを配送する$( %要素, %~mouseleave )
◎
Let result = dispatch mouseleave at element
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
（この段は、
新たな要素へ入って行く際の~eventを生成する。）
◎
Generate events for entering the new element:
</p>

<p>
~IF［
%~target ~NEQ `最後の~mouse要素$
］：
◎
If target is not last mouse element, then
</p>
		<ol>
			<li>
%~mouseover ~LET `~MouseEventを作成する$( `mouseover^l, %~target )
◎
Let mouseover = create a cancelable MouseEvent with "mouseover" and target
</li>
			<li class="issue">【！note】
%~nativeな~event から，
%~mouseout を成す `MouseEvent$I の属性
— `CSSOM-View$r による`拡張＠~CSSOMVIEW#extensions-to-the-mouseevent-interface$も含む —
を設定する。
◎
TODO: Set mouseout attributes from native. +CSSOM attributes
</li>
			<li>
`必要なら~pointer~eventを送信する$( %~mouseover )
◎
Maybe send pointerover event with mouseover
</li>
			<li>
<p>
`~eventを配送する$( %~target, %~mouseout )
◎
Dispatch mouseout at target
</p>

<p class="issue">【！note】
取消されたときの挙動を（その効果は無さそうに見えるが）検証yする。
◎
Need to verify behavior when canceled (appears to have no effect).
</p>
			</li>
			<li>
%~mouseenter要素~群 ~LET « »
◎
↓</li>
			<li>
%~target~DOM経路 を成す
~EACH( %要素 )
に対し
⇒
~IF［
%要素 ~NIN `最後の~mouse~DOM経路$
］
⇒
%~mouseenter要素~群 に %要素 を`付加する$
◎
Let enterElements be a copy of targetDomPath with all elements common to last mouse DOM path removed.
</li>
			<li>
<p>
%~mouseenter要素~群 を成す
~EACH( %要素 )
に対し：
◎
For each element in enterElements, do
</p>

<p class="issue">【！note】
%要素 が【~event~handlerなどにより】［
削除された事例, 移動された事例
］を取扱う。
◎
Handle case where element has been deleted or moved.
</p>
				<ol>
					<li>
%~mouseenter ~LET `~MouseEventを作成する$( `mouseenter^l, %要素, `取消~不能^i )
◎
Let mouseenter = create a non-cancelable MouseEvent with "mouseenter" and element
</li>
					<li>
<p>
%~mouseenter の `composed$m ~SET ~F
◎
Set mouseenter.composed = false
</p>

<p class="issue">【！note】
互換性を検査する：
`composed$m の値は、
仕様に従うなら ~F になるが，［
Linux 上の Chrome においては ~T,
Linux 上の Firefox においては ~F
］になる。
◎
Check compat: Value of event.composed. Spec says false. Chrome/Linux = true. Firefox/Linux = false.
</p>
					</li>
					<li>
`必要なら~pointer~eventを送信する$( %~mouseenter )
◎
Maybe send pointerenter event with mouseenter
</li>
					<li class="issue">【！note】
~shadow~DOM要素~用に互換性を検査する。
Linux 上の Chrome は、
この~eventを当の［
要素, ~shadow根
］に向けて発火する。
◎
Check compat for shadow DOM elements. Chrome/Linux fires this event at the element and the shadow root.
</li>
					<li>
【！利用されない変数 Let result = 】
`~eventを配送する$( %要素, %~mouseenter )
◎
Let result = dispatch mouseenter at element
</li>
				</ol>
			</li>
			<li>
`最後の~mouse要素$ ~SET %~target
◎
Set last mouse element to target
</li>
			<li>
`最後の~mouse~DOM経路$ ~SET %~target~DOM経路
◎
Set last mouse DOM path to targetDomPath
</li>
		</ol>
	</li>
	<li>
%~mousemove ~LET `~MouseEventを作成する$( `mousemove^l, %要素 )
◎
Let mousemove = create a cancelable MouseEvent with "mousemove" and element
</li>
	<li>
`~mousemove用に各~pointer~lock属性を設定する$( %~mousemove )
◎
Set PointerLock attributes for mousemove
</li>
	<li>
`必要なら~pointer~eventを送信する$( %~mousemove )
◎
Maybe send pointermove event with mousemove
</li>
	<li>
`~eventを配送する$( %要素, %~mousemove )
◎
Dispatch mousemove at element
</li>
</ol>
</div>

<div class="algo">
<p>
`必要なら文脈~menuを示す@
ときは、
所与の
( ~nativeな~mousedown【 or pointer event】 %~nativeな~event, `EventTarget$I %~target )
に対し：
◎
4.4.3.16. maybe show context menu
◎
Input
• native, the native mousedown or pointer event
• target, the EventTarget of the event
Output
• None
</p>
<ol>
	<li>
%~contextmenu ~LET `~PointerEventを作成する$( `contextmenu^l, %~target )
◎
Let menuevent = create a PointerEvent with "contextmenu", target
</li>
	<li>
~IF［
%~nativeな~event は妥当である
【何をもって “妥当” とされる？】
］
⇒
`~MouseEvent属性を~nativeな~eventから設定する$( %~contextmenu, %~nativeな~event )
◎
If native is valid, then
• Set MouseEvent attributes from native with native
</li>
	<li>
%取消されなかったか ~LET `~eventを配送する$( %~target, %~contextmenu )
◎
Let result = dispatch menuevent at target
</li>
	<li>
~IF［
%取消されなかったか ~EQ ~T
］
⇒
~UAの文脈~menuを示す
◎
If result is true, then show the UA context menu
</li>
</ol>

<p class="note">注記：
~keyboardにより誘発される文脈~menuを取扱うときは、［
%~nativeな~event には ~NULL,
%~target には 現在~focusされている要素
］を渡して，この~algoを~callすること。
◎
To handle a context menu triggered by the keyboard, call this algorithm with native = null and target = currently focused element.
</p>
</div>

				</section>
			</section>
			<section id="events-mouseevent-event-order">
<h4 title="Mouse Event Order">3.4.4. ~mouse~event序列</h4>

<p>
この仕様にて定義される一定の~mouse~eventは、
相互相対順序の下で生じるモノトスル。
`~pointing先$が，ある要素 %A に変化したときは、
次の~event連列が生じるモノトスル：
◎
Certain mouse events defined in this specification MUST occur in a set order relative to one another. The following shows the event sequence that MUST occur when a pointing device’s cursor is moved over an element:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>要素
<th>備考
<tbody>

<tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A に変化した…
</em>
◎
Pointing device is moved into element A...

<tr><td>2.
<td>`mouseover$et
<td>%A
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る
◎
Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A でなくなった…
</em>
◎
Pointing device is moved out of element A...

<tr><td>5.
<td>`mouseout$et
<td>%A
<td>

<tr><td>6.
<td>`mouseleave$et
<td>%A
<td>
</table>

<p>
`~pointing先$が要素 %A に変化して，その入子な要素 %B に変化して
また %A に戻ったときは、
次の~event連列が生じるモノトスル：
◎
When a pointing device is moved into an element A, and then into a nested element B and then back out again, the following sequence of events MUST occur:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>要素
<th>備考
<tbody>

<tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A に変化した…
</em>
◎
Pointing device is moved into element A...

<tr><td>2.
<td>`mouseover$et
<td>%A
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る
◎
Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %B に変化した…
</em>
◎
Pointing device is moved into nested element B...

<tr><td>5.
<td>`mouseout$et
<td>%A
<td>

<tr><td>6.
<td>`mouseover$et
<td>%B
<td>

<tr><td>7.
<td>`mouseenter$et
<td>%B
<td>

<tr><td>8.
<td>`mousemove$et
<td>%B
<td>複数回 生じ得る
◎
Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %B から %A に変化した…
</em>
◎
Pointing device is moved from element B into A...

<tr><td>9.
<td>`mouseout$et
<td>%B
<td>

<tr><td>10.
<td>`mouseleave$et
<td>%B
<td>

<tr><td>11.
<td>`mouseover$et
<td>%A
<td>

<tr><td>12.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る
◎
Multiple mousemove events

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A でなくなった…
</em>
◎
Pointing device is moved out of element A...

<tr><td>13.
<td>`mouseout$et
<td>%A
<td>

<tr><td>14.
<td>`mouseleave$et
<td>%A
<td>
</table>

<p>
~CSSの利用により，いくつかの要素が視覚的に重合することもある。
次の例では、
3 個の要素［
%A, %B, %C
］は，いずれも ~web~page上で 同じ［
寸法, 絶対~位置
］にされていて、
~DOM内では，
%C は %B の子,
%B は %A の子
であるとする：
◎
Sometimes elements can be visually overlapped using CSS. In the following example, three elements labeled A, B, and C all have the same dimensions and absolute position on a web page. Element C is a child of B, and B is a child of A in the DOM:
</p>

<figure id="figure-mouse-event-stacked-elements">
<figcaption id="_dgm-stacked-event-mouse-dispatch">
同じ所に積層された 3 個の要素の~graphicな表現（最下層から順に %A, %B, %C ）
— ~pointing装置は、
最も手前の要素（ %C ）上に動いている。
◎
Graphical representation of three stacked elements all on top of each other, with the pointing device moving over the stack.
</figcaption></figure>

<p>
~pointing装置が、
積層された要素の外側から要素 %C 内に動いて，また外へ出たときは、
次の~event連列が生じるモノトスル：
◎
When the pointing device is moved from outside the element stack to the element labeled C and then moved out again, the following series of events MUST occur:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>要素
<th>備考
<tbody>

<tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は［
積層-内の最上層の要素である要素 %C
］に変化した…
</em>
◎
Pointing device is moved into element C, the topmost element in the stack

<tr><td>2.
<td>`mouseover$et
<td>%C
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mouseenter$et
<td>%B
<td>

<tr><td>5.
<td>`mouseenter$et
<td>%C
<td>

<tr><td>6.
<td>`mousemove$et
<td>%C
<td>複数回 生じ得る
◎
Multiple mousemove events
<tr><td>
<td>
<td>
<td><em>
`~pointing先$は 要素 %C でなくなった…
</em>
◎
Pointing device is moved out of element C...

<tr><td>7.
<td>`mouseout$et
<td>%C
<td>

<tr><td>8.
<td>`mouseleave$et
<td>%C
<td>

<tr><td>9.
<td>`mouseleave$et
<td>%B
<td>

<tr><td>10.
<td>`mouseleave$et
<td>%A
<td>
</table>

<p class="note">注記：
`mouseover$et ／ `mouseout$et
~eventが発火されるのは， 1 度だけである一方、
`mouseenter$et ／ `mouseleave$et
~eventは，（各~要素ごとに 1 度ずつ）計 3 度~発火される。
◎
The mouseover/mouseout events are only fired once, while mouseenter/mouseleave events are fired three times (once to each element).
</p>

<p class="trans-note">【
概念的には、
一連の［
`mouseenter$et ／  `mouseleave$et
］~eventは，~pointerが［
先祖から子孫に向かって ／ 子孫から先祖に向かって
］（微小な間をおいて）要素の境界を順々にまたいでいったと解釈した下で生じるもの，
と捉えられる
— ただし、
この解釈は，
`MouseEvent.relatedTarget$m
に関して~~正確でないが
（この解釈の下では、
各~子孫に配送される `mouseenter$et ~eventの `relatedTarget^m は，各自の親を指すことになる）。
これらは、
~eventの伝播ではないので、
例えば，［
要素 %A に登録されている `mouseenter$et 用の`~event~handler$
］が，［
%B ／ %C を，その表示位置はそのままに，~DOM内での位置を変えた場合
］の挙動は，明示的に規定されていない
（この節の最後の記述も~~参照）。
】</p>

<p>
~pointing装置に結付けられた~button
（例：~mouse~buttonや~trackpad）
が，要素~上で押されてから, 離されたときの，代表的な~event連列：
◎
The following is the typical sequence of events when a button associated with a pointing device (e.g., a mouse button or trackpad) is pressed and released over an element:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`mousedown$et
<td>

<tr><td>2.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）
◎
OPTIONAL, multiple events, some limits

<tr><td>3.
<td>`mouseup$et
<td>

<tr><td>4.
<td>`click$et
<td>

<tr><td>5.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）
◎
OPTIONAL, multiple events, some limits

<tr><td>6.
<td>`mousedown$et
<td>

<tr><td>7.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）
◎
OPTIONAL, multiple events, some limits

<tr><td>8.
<td>`mouseup$et
<td>

<tr><td>9.
<td>`click$et
<td>

<tr><td>10.
<td>`dblclick$et
<td>
</table>

<p class="note">注記：
上の［
`mousedown$et と `mouseup$et ~eventの間
］に許容される `mousemove$et ~eventを生じさせる~~移動距離や~~頻度は、［
実装／装置／~platform
］に特有になる。
この許容誤差は、
身体的不利のある利用者
— 手の~~動きが不安定であるなど —
が，~pointing装置でヤリトリするときの援助にもなり得る。
◎
The lag time, degree, distance, and number of mousemove events allowed between the mousedown and mouseup events while still firing a click or dblclick event will be implementation-, device-, and platform-specific. This tolerance can aid users that have physical disabilities like unsteady hands when these users interact with a pointing device.
</p>

<p>
各~実装は，適切な`~hysteresis$を決定することになるが、
一般に［
結付けられた［
`mousedown$et ~event, `mouseup$et ~event
］の~targetが同じ要素であって，
`mouseout$et ~eventや `mouseleave$et ~eventは介在しない
］ときには、［
`click$et ／ `dblclick$et
］~eventを発火するベキである。
また，結付けられた［
`mousedown$et ~event, `mouseup$et ~event
］の~targetが異なるときは、
最も近い共通な`広義-先祖$に対し［
`click$et ／ `dblclick$et
］~eventを発火するベキである。
◎
Each implementation will determine the appropriate hysteresis tolerance, but in general SHOULD fire click and dblclick events when the event target of the associated mousedown and mouseup events is the same element with no mouseout or mouseleave events intervening, and SHOULD fire click and dblclick events on the nearest common inclusive ancestor when the associated mousedown and mouseup event targets are different.
</p>

<div class="example">
<p>
`mousedown$et ~eventが~HTML文書の `~body要素$を~targetにしていて，
対応する `mouseup$et ~eventが`根~要素$を~targetにしている場合、
最も近い共通な`広義-先祖$は`根~要素$なので，
`click$et ~eventは根~要素へ配送されることになる。
◎
If a mousedown event was targeted at an HTML document’s body element, and the corresponding mouseup event was targeted at the root element, then the click event will be dispatched to the root element, since it is the nearest common inclusive ancestor.
</p>
</div>

<p>
~mouse~event連列の最中に，`~event~target$が~DOMから除去された場合、
連列の残りの部分の~eventは，その要素には発火されないモノトスル。
◎
If the event target (e.g. the target element) is removed from the DOM during the mouse events sequence, the remaining events of the sequence MUST NOT be fired on that element.
</p>

<p class="trans-note">【
~targetが~DOMの中で移動された場合はどうなる？
その種の位置~変化が伴われるような いかなる~DOM~~操作も，［
要素をいったん~DOM~treeから除去してから挿入し直すものである
］と解釈するならば、
それらの要素には，~eventは配送されなくなることになるが。
】</p>

<div class="example">
<p>
`mousedown$et ~eventの結果，【~event~listenerにより】
~target要素が~DOMから除去された場合、
その要素に対しては［
`mouseup$et, `click$et, `dblclick$et,
］~eventは発火されず、
これらの~eventによる既定の`作動化の挙動$も誘発されなくなる。
しかしながら， `mouseup$et ~eventは、
依然として［
~target要素が除去された後に新たに`~pointing先$になった要素
］に対しては発火されることになる。
同様に， `mouseup$et ~eventの配送-の最中に ~target要素が~DOMから除去された場合、
`click$et, および後続な~eventは，配送されなくなる。
◎
If the target element is removed from the DOM as the result of a mousedown event, no events for that element will be dispatched for mouseup, click, or dblclick, nor any default activation events. However, the mouseup event will still be dispatched on the element that is exposed to the mouse after the removal of the initial target element. Similarly, if the target element is removed from the DOM during the dispatch of a mouseup event, the click and subsequent events will not be dispatched.
</p>
</div>

			</section>
			<section id="events-mouse-types">
<h4 title="Mouse Event Types">3.3.4. 各種~mouse~event型</h4>

<p>
以下に，各種~mouse~event型を挙げる。
入子な要素に対しては、
~mouse~event型は，常に`~pointing先$
— 入子において最も深い要素† —
を~targetにする。
~targetにされた要素の先祖は、
~event浮上を利用して，その子孫~要素たちの中で生じた~mouse~eventの通知を得することができる。
◎
The Mouse event types are listed below. In the case of nested elements, mouse event types are always targeted at the most deeply nested element. Ancestors of the targeted element MAY use bubbling to obtain notification of mouse events which occur within its descendent elements.
</p>

<p class="trans-note">【†
`mouseenter$et, `mouseleave$et に関しては、
その限りでない。
】</p>

				<section id="event-type-auxclick">
<h5>3.4.5.1. `auxclick^et</h5>

<div>
◎イ型 `auxclick@et
◎界面 `PointerEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 文脈依存
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`UIEvent.detail$m：
`現在の~click回数$を指示する
— 属性~値は、
利用者がこの動作を始めたときは
1 になり，その後，各~clickごとに 1 ずつ増加するモノトスル。
</li>
	<li>
`PointerEvent$I に特有な属性については、
`PointerEvents3$r を見よ。
</li>
</ul>
◎表終

◎
Type 	auxclick
Interface 	PointerEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
• For PointerEvent specific attributes, see the [PointerEvents3] spec.
</div>

<p>
`auxclick$et ~event型は、
利用者が非~首~pointer~buttonを［
押してから, 離した
］とき, あるいは［
そのような動作を模造する方式で~pointerが作動化された
］ときに、
`~pointing先$が要素であるならば，それに向けて発火するモノトスル。
~mouse~buttonがどのように作動されるかは、［
~pointing装置, 環境設定0
］に依存する。
例えば、
~screen上の所在や，~buttonが押されてから離されるまでの遅延に依存することもある。
◎
The auxclick event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the non-primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.
</p>

<p>
`auxclick^et ~eventは、
非~首~pointer~button用に限り，発火されるベキである
（すなわち， `MouseEvent!I の
`button$m 値 ~NEQ 0 ／
`buttons$m 値 ~GT 1
）。
`auxclick^et ~eventは、
首~button（標準的な~mouseの左~buttonなど）からは，発火されないモノトスル。
対応する，首~buttonに結付けられた~eventについては `click$et を見よ。
◎
The auxclick event should only be fired for the non-primary pointer buttons (i.e., when button value is not 0, buttons value is greater than 1). The primary button (like the left button on a standard mouse) MUST NOT fire auxclick events. See click for a corresponding event that is associated with the primary button.
</p>

<p>
`auxclick$et ~eventに先行して，同じ要素~上に［
`mousedown$et ／ `mouseup$et
］~eventが発火される場合もある
— 他の~node型（例： ~text~node）への移動は無視rして【下記 例を見よ】。
環境設定0に依存して、
`auxclick$et ~eventは、
~pointing装置の~buttonが押されてから離されるまでの間に ~event型［
`mouseover$et,
`mousemove$et,
`mouseout$et
］ 1 回以上 生じた場合にも発火されてヨイ。
◎
The auxclick event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the auxclick event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button.
</p>

<p>
`auxclick$et ~event型の`既定~動作$は、
文脈依存であり，［
~eventの`~target$
］, および［
`MouseEvent!I の
`button$m ／ `buttons$m
属性の値
］に基づく。
`auxclick$et ~event型の代表的な`既定~動作$は、
次に従う：
◎
The default action of the auxclick event type varies based on the event target of the event and the value of the button or buttons attributes. Typical default actions of the auxclick event type are as follows:
</p>

<ul>
	<li>
`~target$に結付けられた`作動化の挙動$があるならば、
`既定~動作$は，それを実行するモノトスル。
◎
If the event target has associated activation behavior, the default action MUST be to execute that activation behavior.
</li>
</ul>

<div class="example" >
<p>
中央~buttonによる `auxclick^et を受取って取扱う例：
◎
Receiving and handling auxclick for the middle button.
</p>

<pre class="lang-js">
%myLink.addEventListener( "auxclick", function(%e) {
   if (%e.button === 1) {
     /* <span class="comment">
これは既定の挙動
— 例えば ~link上で中央~clickしたときに新たな~UItabで開くなど —
を防止することになる。
◎
This would prevent the default behavior which is for example opening a new tab when middle clicking on a link.
</span> */
     %e.preventDefault();

     /* <span class="comment">
中央~buttonの~clickを取扱うために何か他を行う
— ~appに適した仕方で新たな~UItab内に ~linkや非~link~buttonを開くことに注力する様な。
~UItab帯~内の~UItabを閉じる様な，~click動作で行われるべき他の動作もここで行える。
◎
Do something else to handle middle button click like taking care of opening link or non-link buttons in new tabs in a way that fits the app. Other actions like closing a tab in a tab-strip which should be done on the click action can be done here too.
</span> */
   }
 });
</pre>

</div>

<p class="note">注記：
右~buttonの事例では、
`auxclick^et ~eventは，
`contextmenu$et ~eventより後に配送される。
一部の~UAは、
文脈~menuが表示されている間，すべての入力~eventを吸い取ることに注意
— そのような局面では、
`auxclick$et は~appに可用にならないであろう。
より明確には、
`次の例＠#example-auxclick-right$
を見よ。
◎
In the case of right button, the auxclick event is dispatched after any contextmenu event. Note that some user agents swallow all input events while a context menu is being displayed, so auxclick may not be available to applications in such scenarios. See this example for more clarification.
</p>

<div class="example">
<p id="example-auxclick-right">
右~buttonによる `auxclick^et を受取って取扱う例：
◎
Receiving and handling auxclick for the right button
</p>

<pre class="lang-js">
%myDiv.addEventListener("contextmenu", function(%e) {
   /* <span class="comment">
この~callは、
~pageが~eventを受取ったときに，~pageに干渉するような文脈~menuは示されないようにする。
◎
This call makes sure no context menu is shown to interfere with page receiving the events.
</span> */
    %e.preventDefault();
});

%myDiv.addEventListener("auxclick", function(%e) {
  if (%e.button === 2) {
    /* <span class="comment">
右~button~clickを取扱うために何か他を行う
— ~appの内側に~custom化した文脈~menuを開く様な。
◎
Do something else to handle right button click like opening a customized context menu inside the app.
</span> */
 }
});
</pre>

</div>

				</section>
				<section id="event-type-click">
<h5>3.4.5.2. `click^et</h5>

<div>
◎イ型 `click@et
◎界面 `PointerEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 文脈依存
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`UIEvent.detail$m：
`現在の~click回数$を指示する
— 属性~値は、
利用者がこの動作を始めたときは
1 になり，その後，各~clickごとに 1 ずつ増加するモノトスル。
</li>
	<li>
`PointerEvent$I に特有な属性については、
`PointerEvents3$r を見よ。
</li>
</ul>
◎表終

◎
Type 	click
Interface 	PointerEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
• For PointerEvent specific attributes, see the [PointerEvents3] spec.
</div>

<p>
`click$et ~event型は、
利用者が首~pointer~buttonを［
押してから, 離した
］とき, あるいは［
そのような動作を模造する方式で~pointerが作動化された
］ときに、
`~pointing先$が要素であるならば，それに向けて発火するモノトスル。
~mouse~buttonがどのように作動されるかは、［
~pointing装置, 環境設定0
］に依存する。
例えば、
~screen上の所在や，~buttonが押されてから離されるまでの遅延に依存することもある。
◎
The click event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.
</p>

<p>
`click^et ~eventは、
首~pointer~button用に限り，発火されるベキである
（すなわち， `MouseEvent!I の
`button$m 値は 0 ／
`buttons$m 値は 1
）。
`click^et ~eventは、
副~button
（標準的な~mouseの［
中央~button／右~button
］など）
からは，発火されないモノトスル。
対応する，非~首~buttonに結付けられた~eventについては `auxclick$et を見よ。
◎
The click event should only be fired for the primary pointer button (i.e., when button value is 0, buttons value is 1). Secondary buttons (like the middle or right button on a standard mouse) MUST NOT fire click events. See auxclick for a corresponding event that is associated with the non-primary buttons.
</p>

<p>
`click$et ~eventに先行して，同じ要素~上に［
`mousedown$et ／ `mouseup$et
］~eventが発火される場合もある
— 他の~node型（例： ~text~node）への移動は無視rして【下記 例を見よ】。
環境設定0に依存して、
`click$et ~eventは、
~pointing装置の~buttonが押されてから離されるまでの間に ~event型［
`mouseover$et,
`mousemove$et,
`mouseout$et
］ 1 回以上 生じた場合にも発火されてヨイ。
`click$et ~eventには `dblclick$et ~eventが後続してもヨイ。
◎
The click event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the click event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button. The click event MAY also be followed by the dblclick event.
</p>

<div class="example">
<p>
利用者が、
（~CSS~propにより）行高が大きくとられた `p^e 要素~内の，ある子~text~node上で~mouseを~~押下げて、
~mouseを，その~text~node上を外れる所まで少し~~動かしてから
（すなわち，~pointerは同じ~text~blockの行の合間にあるが，`~pointing先$は 依然として `p^e 要素を指している）~mouseを~~離した場合でも、
まだ同じ要素の視野にあるので，依然として `click$et ~eventを誘発するであろう
（ `click$et 用の通常の時間的`~hysteresis$に~~収まるならば）。
~UAにより生成される~mouse~eventは、
~text~nodeに対し発火されることはないことに注意。
◎
If a user mouses down on a text node child of a &lt;p&gt; element which has been styled with a large line-height, shifts the mouse slightly such that it is no longer over an area containing text but is still within the containing block of that &lt;p&gt; element (i.e., the pointer is between lines of the same text block, but not over the text node per se), then subsequently mouses up, this will likely still trigger a click event (if it falls within the normal temporal hysteresis for a click), since the user has stayed within the scope of the same element. Note that user-agent-generated mouse events are not dispatched on text nodes.
</p>
		</div>

<p>
~event型 `click$et は、
結付けられた~pointing装置に加えて，
要素に対する作動化の一環としても発火するモノトスル。
◎
In addition to being associated with pointer devices, the click event type MUST be dispatched as part of an element activation.
</p>

<p class="note">注記：
~accessibilityを最大限に得るため、
内容~作者には，~custom~control用の`作動化の挙動$を定義する際にも `click$et ~event型を利用することが奨励される
— `mousedown$et ／ `mouseup$et など、
~pointing装置に より特有な他の~event型ではなく。
`click$et ~event型は，~pointing装置（例： ~mouse）に由来するものであるが、
後続な実装において，その結付けを超えるように拡張されており、
要素を作動化するための，装置に依存しない~event型と見なせるので。
◎
For maximum accessibility, content authors are encouraged to use the click event type when defining activation behavior for custom controls, rather than other pointing-device event types such as mousedown or mouseup, which are more device-specific. Though the click event type has its origins in pointer devices (e.g., a mouse), subsequent implementation enhancements have extended it beyond that association, and it can be considered a device-independent event type for element activation.
</p>

<p>
`click$et ~event型の`既定~動作$は、
文脈依存であり，［
~eventの`~target$
］, および［
`MouseEvent!I の
`button$m ／ `buttons$m
属性の値
］に基づく。
`click$et ~event型の代表的な`既定~動作$は、
次に従う：
◎
The default action of the click event type varies based on the event target of the event and the value of the button or buttons attributes. Typical default actions of the click event type are as follows:
</p>
<ul>
	<li>
`~target$に結付けられた`作動化の挙動$があるならば、
`既定~動作$は，それを実行するモノトスル。
◎
If the event target has associated activation behavior, the default action MUST be to execute that activation behavior.
</li>
	<li>
`~target$が~focus可能ならば、
`既定~動作$は，その要素に文書~focusを与えるモノトスル。
◎
If the event target is focusable, the default action MUST be to give that element document focus.
</li>
</ul>

				</section>
				<section id="event-type-contextmenu">
<h5>3.4.5.3. `contextmenu^et</h5>

<div>
◎イ型 `contextmenu@et
◎界面 `PointerEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 ~supportされるなら、文脈~menuを呼出す
◎文脈
<p>
`各種~mouse~eventに共通な文脈~情報$を見よ
</p>
◎表終

◎
Type 	contextmenu
Interface 	PointerEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Invoke a context menu if supported.
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
~UAは、
この~eventを文脈~menuを呼出す前に配送するモノトスル。
◎
A user agent MUST dispatch this event before invoking a context menu.
</p>

<p>
`contextmenu$et ~eventが右~mouse~buttonにより誘発されたときは、
`mousedown$et ~eventより後に配送するモノトスル。
◎
When the contextmenu event is triggered by right mouse button, the contextmenu event MUST be dispatched after the mousedown event.
</p>

<p class="note">注記：
`contextmenu$et ~eventが `mouseup$et ~eventより前に配送されるか後に配送されるかは、
~platformに依存する。
◎
Depending on the platform, the contextmenu event may be dispatched before or after the mouseup event.
</p>

				</section>
				<section id="event-type-dblclick">
<h5>3.4.5.4. `dblclick^et</h5>

<div>
◎イ型 `dblclick@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`UIEvent.detail$m：
`現在の~click回数$
を指示する
</li>
</ul>
◎表終

◎
Type 	dblclick
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
~UAは、［
要素~上で~pointing装置の首~buttonが
【ある時間内に】
二回~clickされた
］とき，この~eventを発火するモノトスル。
~double-clickの定義は、
その~targetが［
`mousedown$et ／ `mouseup$et ／ `dblclick$et
］と同じになるモノトスルことを除いて，環境設定0に依存する。
この~event型は、［
~clickと~double-clickが同時に生じた場合は `click$et  ／
他の場合は `mouseup$et
］の後に配送するモノトスル。
◎
A user agent MUST dispatch this event when the primary button of a pointing device is clicked twice over an element. The definition of a double click depends on the environment configuration, except that the event target MUST be the same between mousedown, mouseup, and dblclick. This event type MUST be dispatched after the event type click if a click and double click occur simultaneously, and after the event type mouseup otherwise.
</p>

<p>
`click$et ~eventと同様に，
`dblclick$et ~eventが発火されるのは、
首~pointer~buttonからに限られるベキであり，
副~buttonからは発火されないモノトスル。
◎
As with the click event, the dblclick event should only be fired for the primary pointer button. Secondary buttons MUST NOT fire dblclick events.
</p>

<p class="note">注記：
`click$et ~eventを取消しても、
`dblclick$et ~eventが発火されるかどうかには影響しない。
◎
Canceling the click event does not affect the firing of a dblclick event.
</p>

<p>
`click$et ~event型と同様に、
`dblclick$et ~event型の`既定~動作$は，文脈依存であり、
~eventの`~target$および［
`MouseEvent.button$m ／ `MouseEvent.buttons$m
］属性の値に基づく。
`dblclick$et ~event型の代表的な`既定~動作$は、
`click$et ~event型のそれと合致する。
◎
As with the click event type, the default action of the dblclick event type varies based on the event target of the event and the value of the button or buttons attributes. The typical default actions of the dblclick event type match those of the click event type.
</p>

				</section>
				<section id="event-type-mousedown">
<h5>3.4.5.5. `mousedown^et</h5>

<div>
◎イ型 `mousedown@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 
<ul>
	<li>
~drag／~drop操作oを開始する
</li>
	<li>
~text選択を開始する
</li>
	<li>
~scroll／~panによるヤリトリを開始する
（~supportされるなら，中央~mouse~buttonとの組合nで）
</li>
</ul>
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`UIEvent.detail$m：
( `現在の~click回数$ + 1 )
を指示する。
例えば、
`mousedown$et の直前に~clickが起きていない場合の `UIEvent.detail$m 値は
1 になる。
</li>
</ul>
◎表終

◎
Type 	mousedown
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies: Start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported)
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count incremented by one. For example, if no click happened before the mousedown, detail will contain the value 1
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
~UAは、［
~pointing装置の~buttonが要素~上で押された
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when a pointing device button is pressed over an element.
</p>

<p class="note">注記：
多くの実装が、
`mousedown$et ~eventを利用して，文脈に依存する種々の`既定~動作$を開始する。
これらの既定~動作は、
この~eventを取消すことにより，防止できる。
これらの既定~動作には、
画像や~linkに対し［
~drag／~drop
］によるヤリトリを始めたり，~text選択を開始する, 等々がある。
加えて、
~mouse駆動な~pan~~操作 特能を供する実装もある
（ `mousedown$et ~eventの配送-時に，中央~mouse~buttonが押されていた場合に作動化されるような）。
◎
Many implementations use the mousedown event to begin a variety of contextually dependent default actions. These default actions can be prevented if this event is canceled. Some of these default actions could include: beginning a drag/drop interaction with an image or link, starting text selection, etc. Additionally, some implementations provide a mouse-driven panning feature that is activated when the middle mouse button is pressed at the time the mousedown event is dispatched.
</p>

				</section>
				<section id="event-type-mouseenter">
<h5>3.4.5.6. `mouseenter^et</h5>

<div>
◎イ型 `mouseenter@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Element$I
◎取消 不可
◎構 No
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
注釈文を見よ。
</li>
	<li>
`MouseEvent.button$m： 0
</li>
	<li>
`MouseEvent.relatedTarget$m：
以前の`~pointing先$。
</li>
</ul>
◎表終

◎
Type 	mouseenter
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Element
Cancelable 	No
Composed 	No
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is exiting, if any.
</div>

<p>
~UAは、［
`~pointing先$が`有効に変化-$して，ある要素とその子孫たちが成す境界に入った†
］とき、
その要素に向けて，この~eventを発火するモノトスル。
この~event型は， `mouseover$et に類似するが、
浮上しないこと, および［
以前の`~pointing先$が要素の子孫である場合、
要素に向けて発火してはナラナイ
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or one of its descendent elements. A user agent MUST also dispatch this event when the element or one of its descendants moves to be underneath the primary pointing device. This event type is similar to mouseover, but differs in that it does not bubble, and MUST NOT be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
</p>

<div class="trans-note">
<p>【†
すなわち、
~pointing先が変化したとき，
~AND↓ を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
新たな~pointing先か, または その先祖である。
</li>
	<li>
以前の~pointing先でも, その先祖でもない。
</li>
</ul>
<p>
該当する要素が複数~在る場合
（例：以前の~pointing先が ~NULL ならば、
新たな~pointing先と その先祖~要素~すべてが該当する）、
最も先祖のものから順に，この~eventを発火することになろう
（この順序は、
一般な記述として明文化されてはいないが，前~節に述べた
`積層された例＠#figure-mouse-event-stacked-elements$
における~mouse~event序列に基づく）。
</p>

<p>
該当する要素のうち，新たな`~pointing先$ 以外のものは、
`接触判定＠#topmost-event-target$の対象から除外されているかもしれない
— そのような要素には発火しないとするのが正しい挙動かもしれない（はっきりしない）。
】</p>

</div>

<p class="note">注記：
この~event型と~CSS `~hover_ps 疑似類$ `CSS2$r には、
類似性がある。
`mouseleave$et ~event型も見よ。
◎
There are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseleave event type.
</p>

				</section>
				<section id="event-type-mouseleave">
<h5>3.4.5.7. `mouseleave^et</h5>

<div>
◎イ型 `mouseleave@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Element$I
◎取消 不可
◎構 No
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
注釈文を見よ。
</li>
	<li>
`MouseEvent.button$m：
0
</li>
	<li>
`MouseEvent.relatedTarget$m：
新たな`~pointing先$。
【原文の記述は “以前の~pointing先” を示唆しているが、更新-時の誤りであろう。】
【！issue #307】
</li>
</ul>
◎表終

◎
Type 	mouseleave
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Element
Cancelable 	No
Composed 	No
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is exiting, if any.
</div>

<p>
~UAは、［
`~pointing先$が`有効に変化-$して，ある要素とその子孫たちが成す境界から出た†
］とき、
その要素に向けて，この~eventを発火するモノトスル。
この~event型は， `mouseout$et に類似するが、
浮上しないこと, および［
新たな`~pointing先$が要素の子孫である場合、
要素に向けて発火してはナラナイ
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element and all of its descendent elements. A user agent MUST also dispatch this event when the element or one of its descendants moves to be no longer underneath the primary pointing device. This event type is similar to mouseout, but differs in that does not bubble, and that it MUST NOT be dispatched until the pointing device has left the boundaries of the element and the boundaries of all of its children.
</p>

<div class="trans-note">
<p>【†
すなわち、
~pointing先が変化したとき，
~AND↓ を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
以前の~pointing先か, または その先祖である。
</li>
	<li>
新たな~pointing先でも, その先祖でもない。
</li>
</ul>
<p>
該当する要素が複数~在る場合
（例：新たな~pointing先が ~NULL ならば、
以前の~pointing先と その先祖~要素~すべてが該当する）、
最も子孫のものから順に
（ `mouseenter$et のときとは逆順に），
この~eventを発火することになろう。
】</p>
</div>

<p class="note">注記：
この~event型と~CSS `~hover_ps 疑似類$ `CSS2$r には、
類似性がある。
`mouseenter$et ~event型も見よ。
◎
There are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseenter event type.
</p>

				</section>
				<section id="event-type-mousemove">
<h5>3.4.5.8. `mousemove^et</h5>

<div>
◎イ型 `mousemove@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`MouseEvent.button$m：
0
</li>
</ul>
◎表終

◎
Type 	mousemove
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
~UAは、［
`~pointing先$が要素~上で動いた
］とき，その要素に向けて，この~eventを発火するモノトスル。
~pointing装置が動かされる間に~eventが生じる頻度0は［
実装／装置／~platform
］に特有であるが、
~~持続的な動きに対しては，動きが止まる度にではなく，複数の `mousemove$et ~eventが連続して発火されるベキである。
実装には、
即応性と処理能との兼ね合いをとる最適な頻度0を決定することが奨励される。
◎
A user agent MUST dispatch this event when a pointing device is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive mousemove events SHOULD be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance.
</p>

<p class="note">注記：
~browserなどの一部の実装~環境においては、
`mousemove$et~eventは，利用者が（~mouse~buttonを押すなどして）~drag操作oを始めてから ~pointing装置が~UAの境界を離れた後も，発火し続け得る。
◎
In some implementation environments, such as a browser, mousemove events can continue to fire if the user began a drag operation (e.g., a mouse button is pressed) and the pointing device has left the boundary of the user agent.
</p>

<p class="note" id="mousemove-now-cancelable">注記：
この~eventは、
以前は DOM Level 2 Events において`取消~可能$でないと指定されていたが，
既存の~UA間の相互運用能を反映するよう変更された。
◎
This event was formerly specified to be non-cancelable in DOM Level 2 Events, but was changed to reflect existing interoperability between user agents.
</p>

				</section>
				<section id="event-type-mouseout">
<h5>3.4.5.9. `mouseout^et</h5>

<div>
◎イ型 `mouseout@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
以前の`~pointing先$
</li>
	<li>
`MouseEvent.button$m：
0
</li>
	<li>
`MouseEvent.relatedTarget$m：
新たな`~pointing先$
</li>
</ul>
◎表終

◎
Type 	mouseout
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is entering, if any.
</div>

<p>
~UAは、
`~pointing先$が`有効に変化-$したとき，以前の`~pointing先$が要素であるならば、
この~eventをその要素に向けて発火するモノトスル。
この~event型は， `mouseleave$et に類似するが、
浮上すること, および［
新たな`~pointing先$が要素の子孫であっても、
要素に向けて発火するモノトスル
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element or when the element is moved to be no longer underneath the primary pointing device. This event type is similar to mouseleave, but differs in that does bubble, and that it MUST be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
</p>

<p class="note">注記：
`mouseover$et ~event型も見よ。
◎
See also the mouseover event type.
</p>

				</section>
				<section id="event-type-mouseover">
<h5>3.4.5.10. `mouseover^et</h5>

<div>
◎イ型 `mouseover@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`MouseEvent.button$m：
0
</li>
	<li>
`MouseEvent.relatedTarget$m：
以前の`~pointing先$
【原文の記述は “新たな~pointing先” を示唆しているが、更新-時の誤りであろう。】
【！issue #307】
</li>
</ul>
◎表終

◎
Type 	mouseover
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target a pointing device is entering, if any.
</div>

<p>
~UAは、
`~pointing先$が`有効に変化-$したとき，新たな`~pointing先$が要素であるならば、
この~eventを当の要素に向けて発火するモノトスル。
この~event型は， `mouseenter$et に類似するが、
浮上すること, および［
以前の`~pointing先$が要素の子孫であっても、
要素に向けて発火するモノトスル
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or when the element is moved to be underneath the primary pointing device. This event type is similar to mouseenter, but differs in that it bubbles, and that it MUST be dispatched when the pointer device moves onto the boundaries of an element whose ancestor element is the event target for the same event listener instance.
</p>

<p class="note">注記：
`mouseout$et ~event型も見よ。
◎
See also the mouseout event type.
</p>

				</section>
				<section id="event-type-mouseup">
<h5>3.4.5.11. `mouseup^et</h5>

<div>
◎イ型 `mouseup@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`UIEvent.detail$m：
( `現在の~click回数$ + 1 )
を指示する
</li>
</ul>
◎表終

◎
Type 	mouseup
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count incremented by one.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
~UAは、［
~pointing装置の~buttonが要素~上で離された
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when a pointing device button is released over an element.
</p>

<p class="note">注記：
~browserなど，実装~環境によっては、
`mouseup$et ~eventは，~pointing装置が~UAの境界から出たときにも発火され得る。
例： 利用者が~mouse~buttonを押して~drag操作oを始めたときなど。
◎
In some implementation environments, such as a browser, a mouseup event can be dispatched even if the pointing device has left the boundary of the user agent, e.g., if the user began a drag operation with a mouse button pressed.
</p>

				</section>
			</section>
			<section id="_common-mouse-event-context">
<h4>各種~mouse~eventに共通な文脈~情報</h4>

集約簡略化

<p>
多くの~mouse~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
`~pointing先$
◎
Event.target : topmost event target
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通な文脈~情報$を見よ。
</dd>

	<dt>`MouseEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`screenX$m</dt>
			<dd>
~screen上の~pointer位置に基づく値
◎
MouseEvent.screenX : value based on the pointer position on the screen
</dd>

			<dt>`screenY$m</dt>
			<dd>
~screen上の~pointer位置に基づく値
◎
MouseEvent.screenY : value based on the pointer position on the screen
</dd>

			<dt>`clientX$m</dt>
			<dd>
`表示域$の中の~pointer位置に基づく値
◎
MouseEvent.clientX : value based on the pointer position within the viewport
</dd>

			<dt>`clientY$m</dt>
			<dd>
`表示域$の中の~pointer位置に基づく値
◎
MouseEvent.clientY : value based on the pointer position within the viewport
</dd>

			<dt>`layerX$m</dt>
			<dd>
包含している要素の中の~pointer位置に基づく値
◎
MouseEvent.layerX : value based on the pointer position within the containing element
</dd>

			<dt>`layerY$m</dt>
			<dd>
包含している要素の中の~pointer位置に基づく値
◎
MouseEvent.layerY : value based on the pointer position within the containing element
</dd>

			<dt>`altKey$m</dt>
			<dd>
`Alt^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.altKey : true if Alt modifier was active, otherwise false
</dd>

			<dt>`ctrlKey$m</dt>
			<dd>
`Control^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
</dd>

			<dt>`shiftKey$m</dt>
			<dd>
`Shift^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
</dd>

			<dt>`metaKey$m</dt>
			<dd>
`Meta^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.metaKey : true if Meta modifier was active, otherwise false
</dd>

			<dt>`button$m</dt>
			<dd>
現在 押されている~buttonに基づく値。
◎
MouseEvent.button : value based on current button pressed
</dd>

			<dt>`buttons$m</dt>
			<dd>
現在の押下げられているすべての~buttonに基づく値。
押された~buttonが無ければ 0 になる。
◎
MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
</dd>

			<dt>`relatedTarget$m</dt>
			<dd>
~NULL
◎
MouseEvent.relatedTarget : null
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-wheelevents">
<h3 title="Wheel Events">3.5. ~wheel~event</h3>
<p>
~wheelは、
1 つ以上の空間的~次元にて回転できる装置であり，
~pointing装置に結付けられ得る。
座標系は環境設定0に依存する。
◎
Wheels are devices that can be rotated in one or more spatial dimensions, and which can be associated with a pointer device. The coordinate system depends on the environment configuration.
</p>

<div class="example">
<p>
利用者の環境は、［
横~scroll／縦~scroll／~zoom
］を［
x-軸／y-軸／z-軸
］に沿う回転に結付けるよう環境設定され得る。
◎
The user’s environment might be configured to associate vertical scrolling with rotation along the y-axis, horizontal scrolling with rotation along the x-axis, and zooming with rotation along the z-axis.
</p>
</div>

<p>
`WheelEvent!I ~objの［
`deltaX$m ／ `deltaY$m ／ `deltaZ$m
］属性は、
それぞれの軸に沿う，いずれかの`測定~単位$による測定を指示する。
報告される測定は、
環境に特有な~algoが，~wheel装置の実際の［
回転や動き
］を［
適切な単位を伴う適切な値
］に翻訳した後に供される。
◎
The deltaX, deltaY, and deltaZ attributes of WheelEvent objects indicate a measurement along their respective axes in units of pixels, lines, or pages. The reported measurements are provided after an environment-specific algorithm translates the actual rotation/movement of the wheel device into the appropriate values and units.
</p>

<p>
【定義追加：】
`測定~単位@
とは、
画素~数, 行~数, ~page数の総称である。
</p>

<div class="trans-note">
<p>
原文には、
これらが何の計量に基づくかは，定義されていない。
次の定義が考えられるが：
</p>
<ul>
	<li>
画素~数は、
~CSS `px^css 単位
（機器~画素~単位ではなく）。
</li>
	<li>
行数は、
`根~要素$の~CSS `line-height^p ~propに基づく。
</li>
	<li>
~page数は、
よくある~computer~screenの下では，`表示域$（ `viewport^en ）の寸法に基づく。
</li>
</ul>
</div>

<p class="note">注記：
利用者は、
~wheel装置の実際の
回転／動き
を異なる仕方で解釈させるよう環境設定1を~custom化し得る。
［
共通的な
“dented” 【？】
~mouse~wheelの一回の動き
］は、
何~画素か（実際の値は ~UAの現在の~screen寸法に依存する）に測定されるが、
利用者は、
自身の環境設定1を変更して この数を増大させ，~mouse~wheelを高速化することもある。
更には，
~mouse~wheel~softwareには、
加速機能
（~wheelを高速に回転させる／動かす程，各~測定の`~delta$が大きくなる）
を~supportするものや，
1 画素~単位より精細に`回転$を測定するものもある。
よって作者は、［
ある~UAにおける`回転$量が，他の~UAにおいても同じ`~delta$値を生産する
］と見做すことはできない。
◎
A user’s environment settings can be customized to interpret actual rotation/movement of a wheel device in different ways. One movement of a common "dented" mouse wheel can produce a measurement of 162 pixels (162 is just an example value, actual values can depend on the current screen dimensions of the user-agent). But a user can change their default environment settings to speed-up their mouse wheel, increasing this number. Furthermore, some mouse wheel software can support acceleration (the faster the wheel is rotated/moved, the greater the delta of each measurement) or even sub-pixel rotation measurements. Because of this, authors can not assume a given rotation amount in one user agent will produce the same delta value in all user agents.
</p>

<p>
［
`deltaX^m ／ `deltaY^m ／ `deltaZ^m
］属性~値の正負は、
実際の~wheel装置が同じ方向に［
回転する間, 動く間
］は， `wheel$et ~eventの複数の発火において一貫するモノトスル。
~UAは、［
`wheel$et ~eventの既定~動作として~scrollする場合
］の`~delta$の符号を
`右手~座標系@
で
— すなわち，［
X／Y／Z
］軸の正な方向が，`文書$の［
右方／下方／奥方（利用者から遠ざかる）
］を向くように —
与えるベキである。
◎
The sign (positive or negative) of the values of the deltaX, deltaY, and deltaZ attributes MUST be consistent between multiple dispatches of the wheel event while the motion of the actual wheel device is rotating/moving in the same direction. If a user agent scrolls as the default action of the wheel event then the sign of the delta SHOULD be given by a right-hand coordinate system where positive X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.
</p>

<p class="note">注記：
~wheelの物理的な操作oに対する解釈は、
個々の~UAに応じて
（あるいは~UAや~hardwareの環境設定に依存して）
異なることもある。
例えば，~trackpadの淵で上から下へ~swipeされたとき、
下への~page~scrollを意図する~wheel動作として解釈されることもあれば，
その逆に解釈されることもある
（すなわち， `deltaY^m 値は、
前者が正に, 後者が負に）。
◎
Individual user agents can (depending on their environment and hardware configuration) interpret the same physical user interaction on the wheel differently. For example, a vertical swipe on the edge of a trackpad from top to bottom can be interpreted as a wheel action intended to either scroll the page down or to pan the page up (i.e., resulting in either a positive or negative deltaY value respectively).
</p>

<p>
`~wheel~event~transaction@
とは、
ある単独の利用者~gestureに結付けられる【から生じる】一連の~wheel~eventである。
`~UA$は、
それらのうち最初の~wheel~eventが発火されたとき，［
実装に特有な時間
【言い換えれば、単独の~gestureが成し得る最大な時間】
内で生じる後続な~wheel~eventすべて
］が同じ要素を~targetにできるよう，
`~wheel~event~transaction$を作成するモノトスル。
各`~wheel~event~transaction$には、
それを成す最初の~wheel~eventが生じた時点における`最上層の~event~target$が結付けられるモノトスル。
◎
A user agent MUST create a wheel event transaction when the first wheel event is fired, so that all subsequent wheel events within a implementation-specific amount of time can be targetted at the same element. A wheel event transaction is series of wheel events that are associated with a single user gesture. The wheel event transaction MUST have an associated event target that is the topmost event target at the time the first wheel event occurs in the group.
</p>

<p class="example">
ある~scroll可能な要素~内のどこかを~targetにする一連の~wheel~eventが，
ある子~要素から開始された場合、
当の子~要素が，同じ利用者~gesture用の後続な~eventが生じ得る要素になる。
◎
If a series of wheel events targetted in a scrollable element start above a child element, later events for the same user gesture may occur over the child element.
</p>

			<section id="interface-wheelevent">
<h4 title="Interface WheelEvent">3.5.1. `WheelEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`WheelEvent^I ~interfaceは、
`wheel$et ~eventに特有な文脈的~情報を供する。
◎
The WheelEvent interface provides specific contextual information associated with wheel events.
</p>

<p>
`WheelEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `WheelEventInit$I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the WheelEvent interface, use the WheelEvent constructor, passing an optional WheelEventInit dictionary.
</p>

				<section id="idl-wheelevent">
<h5>3.5.1.1. `WheelEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `WheelEvent@I : `MouseEvent$I {
    `WheelEvent@mc(`DOMString$ %type, optional `WheelEventInit$I %eventInitDict = {});

    // <span class="comment">`deltaMode^m 値がとり得る定数</span>
    const `unsigned long$ `DOM_DELTA_PIXEL$m = 0x00;
    const `unsigned long$ `DOM_DELTA_LINE$m = 0x01;
    const `unsigned long$ `DOM_DELTA_PAGE$m = 0x02;

    readonly attribute `double$ `deltaX$m;
    readonly attribute `double$ `deltaY$m;
    readonly attribute `double$ `deltaZ$m;
    readonly attribute `unsigned long$ `deltaMode$m;
};
</pre>

<dl class="idl-def">

	<dt>`DOM_DELTA_PIXEL@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、
`~delta$用の`測定~単位$は，画素~数になるモノトスル。
これは、
ほとんどの~OSや実装の環境設定における，最も代表的な事例である。
◎
The units of measurement for the delta MUST be pixels. This is the most typical case in most operating system and implementation configurations.
</dd>

	<dt>`DOM_DELTA_LINE@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、
`~delta$用の`測定~単位$は，~textの行~数になるモノトスル。
これは，多くの~form~controlに該当する。
◎
The units of measurement for the delta MUST be individual lines of text. This is the case for many form controls.
</dd>

	<dt>`DOM_DELTA_PAGE@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、
`~delta$用の`測定~単位$は，［
単独の~screen, または ~page~~区分
］に基いて定義される~page数になるモノトスル。
◎
The units of measurement for the delta MUST be pages, either defined as a single screen or as a demarcated page.
</dd>

	<dt>`deltaX@m</dt>
	<dt>`deltaY@m</dt>
	<dt>`deltaZ@m</dt>
	<dd>
`wheel$et ~eventの既定~動作が~scrollである~UAでは、
~eventが取消されなかった場合の値は，当該の軸に沿って~scrollされることになる（いずれかの`測定~単位$による）測定になるモノトスル。
他の場合、
これは［
当該の軸~廻りの~wheel装置の動き
］の実装に特有な（いずれかの`測定~単位$による）測定。
◎
deltaX, of type double, readonly
• In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the x-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the x-axis.
• The un-initialized value of this attribute MUST be 0.0.
◎
deltaY, of type double, readonly
• In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the y-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the y-axis.
• The un-initialized value of this attribute MUST be 0.0.
◎
deltaZ, of type double, readonly
• In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the z-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the z-axis.
• The un-initialized value of this attribute MUST be 0.0.
</dd>

	<dd>
`未初期化~値$： 0.0
◎
↑</dd>

	<dt>
`deltaMode@m
◎
deltaMode, of type unsigned long, readonly
</dt>
	<dd>
`deltaMode^m 属性~値は、
`~delta$値~用の`測定~単位$を指示する。
既定~値は `DOM_DELTA_PIXEL$m （画素~数）。
◎
The deltaMode attribute contains an indication of the units of measurement for the delta values. The default value is DOM_DELTA_PIXEL (pixels).
</dd>
	<dd>
この属性は、［
`~delta$値~用の`測定~単位$を指示する，いずれかの `DOM_DELTA_…^m 定数
］に設定するモノトスル。
精確な測定は，［
装置／~OS／~app
］の環境設定に特有になる。
◎
This attribute MUST be set to one of the DOM_DELTA constants to indicate the units of measurement for the delta values. The precise measurement is specific to device, operating system, and application configurations.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>
</dl>

				</section>
				<section id="idl-wheeleventinit">
<h5>3.5.1.2. `WheelEventInit^I</h5>

<pre class="idl">
dictionary `WheelEventInit@I : `MouseEventInit$I {
    `double$ `deltaX@m = 0.0;
    `double$ `deltaY@m = 0.0;
    `double$ `deltaZ@m = 0.0;
    `unsigned long$ `deltaMode@m = 0;
};
</pre>

<p>
この辞書の各~memberは、
`WheelEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
deltaX, of type double, defaulting to 0.0
• See deltaZ attribute.
◎
deltaY, of type double, defaulting to 0.0
• See deltaZ attribute.
◎
deltaZ, of type double, defaulting to 0.0
• Initializes the deltaZ attribute of the WheelEvent object. Relative positive values for this attribute (as well as the deltaX and deltaY attributes) are given by a right-hand coordinate system where the X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively. Negative relative values are in the respective opposite directions.
◎
deltaMode, of type unsigned long, defaulting to 0
• Initializes the deltaMode attribute on the WheelEvent object to the enumerated values 0, 1, or 2, which represent the amount of pixels scrolled (DOM_DELTA_PIXEL), lines scrolled (DOM_DELTA_LINE), or pages scrolled (DOM_DELTA_PAGE) if the rotation of the wheel would have resulted in scrolling.
</p>

				</section>
			</section>
			<section id="events-wheel-types">
<h4>3.5.2. 各種~wheel~event型</h4>

				<section id="event-type-wheel">
<h5>3.5.2.1. `wheel^et</h5>

<div>
◎イ型 `wheel@et
◎界面 `WheelEvent$I
◎同期 なし
◎浮上 する
◎標的 `Element$I
◎取消 `文脈依存＠#cancelability-of-wheel-events$
◎構 Yes
◎既定動作 
文書を~scroll（または~zoom）する
◎文脈
<p>
次を除き，`各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
現在の`~wheel~event~transaction$用の~target
</li>

	<li>
<p>
~wheelが~pointing装置に結付けられていない場合、
`MouseEvent!I の：
</p>
		<ul>
			<li>
次に挙げる属性は 0 【すなわち，`未初期化~値$】になる
⇒＃
`screenX$m,
`screenY$m,
`clientX$m,
`clientY$m,
`button$m,
`buttons$m
</li>
			<li class="trans-note">【
`layerX$m, `layerY$m も，前項と同様になると思われるが、
原文には言及されていない。
】</li>
			<li class="trans-note">【
`relatedTarget$m は， ~NULL （`未初期化~値$）になると思われるが、
原文には言及されていない。
】</li>
		</ul>
	</li>
	<li>
`WheelEvent!I の［
`deltaX$m ／
`deltaY$m ／
`deltaZ$m
］：
［
X ／ Y ／ Z
］軸~廻りの~wheel装置の動きを~~反映する量であって、［
~pageが `deltaMode$m 単位に従って，その軸に沿って~scrollする量
］であるか，または実装に特有な値
</li>
	<li>
`WheelEvent.deltaMode$m：
［
`deltaX$m ／ `deltaY$m ／ `deltaZ$m
］属性~用の（いずれかの`測定~単位$を表現する）単位~指示子
</li>
</ul>
◎表終

◎
Type 	wheel
Interface 	WheelEvent
Sync / Async 	Async
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Varies
Composed 	Yes
Default action 	Scroll (or zoom) the document
Context
(trusted events) 	

• Event.target : element target for the current wheel event transaction
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0
• MouseEvent.screenY : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0
• MouseEvent.clientX : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0
• MouseEvent.clientY : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : if wheel is associated with a pointing device, value based on current button pressed, otherwise 0
• MouseEvent.buttons : if wheel is associated with a pointing device, value based on all buttons current depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the event target the pointing device is pointing at, if any
• WheelEvent.deltaX : expected amount that the page will scroll along the x-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the x-axis
• WheelEvent.deltaY : expected amount that the page will scroll along the y-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the y-axis
• WheelEvent.deltaZ : expected amount that the page will scroll along the z-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the z-axis
• WheelEvent.deltaMode : unit indicator (pixels, lines, or pages) for the deltaX, deltaY, and deltaZ attributes
</div>

<p>
~UAは、
~mouse~wheelが いずれかの軸で回転されたとき
— あるいは、
等価な入力~装置
（~mouse-ballや, 一部の~tabletや~touchpad, 等々）
が そのような動作を模倣したとき —
この~eventを発火するモノトスル。
同時に複数の軸が回転された場合の~wheel`~delta$は、
~platformや入力~装置に依存して，［
単独の `wheel$et ~eventにまとめて, あるいは
軸ごとに別々な `wheel$et ~eventとして
］送達されることもある。
◎
A user agent MUST dispatch this event when a mouse wheel has been rotated around any axis, or when an equivalent input device (such as a mouse-ball, certain tablets or touchpads, etc.) has emulated such an action. Depending on the platform and input device, diagonal wheel deltas MAY be delivered either as a single wheel event with multiple non-zero axes or as separate wheel events for each non-zero axis.
</p>

<p>
`wheel$et ~event型の代表的な`既定~動作$は、
指示された量だけ文書を~scrollする
（あるいは一部の事例では，~zoomする）。
この~eventが取消された場合、
実装は，文書を［
~scroll／~zoom
］しないモノトスル
（あるいは，何であれ、
この~event型に結付けられた他の実装に特有な既定~動作も）。
◎
The typical default action of the wheel event type is to scroll (or in some cases, zoom) the document by the indicated amount. If this event is canceled, the implementation MUST NOT scroll or zoom the document (or perform whatever other implementation-specific default action is associated with this event type).
</p>

<p class="note">注記：
~UA や入力~装置によっては、
~wheelが回される速度も`~delta$値に影響し得る
— 高速になる程 高い`~delta$値を生産するよう。
◎
In some user agents, or with some input devices, the speed that the wheel has been turned can affect the delta values, with a faster speed producing a higher delta value.
</p>

				</section>
				<section id="cancelability-of-wheel-events">
<h5 title="cancelability of wheel events">3.5.2.2. `wheel^et ~eventの取消~可否</h5>

<p>
`wheel$et ~eventに対し `preventDefault()$m を~callした場合、
~scrollingを［
防止-／中断-
］し得る。
~UAは，~scroll処理能を最大にするためとして、
~scrollに結付けられた `wheel^et ~event連列を成す各~eventに対し，それが
— 取消されたかどうか見るために —
処理されるまで待機しなくてもヨイ。
そのような事例では、
~UAは，生成する `wheel^et ~eventの `cancelable$m を ~F にするべきである
— これは、
`preventDefault()$m を利用しても，~scrollingを［
防止-／中断-
］し得ないことを指示する。
他の場合、
`cancelable$m は ~T になる。
◎
Calling preventDefault on a wheel event can prevent or otherwise interrupt scrolling. For maximum scroll performance, a user agent may not wait for each wheel event associated with the scroll to be processed to see if it will be canceled. In such cases the user agent should generate wheel events whose cancelable property is false, indicating that preventDefault cannot be used to prevent or interrupt scrolling. Otherwise cancelable will be true.
</p>

<p>
特に，~UAは、
~event用の`受動的でない~listenerは無いことを観測した＠~DOM4#observing-event-listeners$ならば，
生成するどの `wheel$et ~eventも取消~不能にする【 `cancelable^m を ~F にする】ベキである。
◎
In particular, a user agent should generate only uncancelable wheel events when it observes that there are no non-passive listeners for the event.
</p>

				</section>
			</section>
		</section>
		<section id="events-inputevents">
<h3 title="Input Events">3.6. 入力~event型</h3>

<p>
入力~eventは、
利用者-動作の直接的な結果として
（例：編集-可能な領域~内での~keyboard入力や, 整形-中にある~textを削除したとき, 等々）
~DOMが更新された（または，されつつある）とき，通知として送信される。
◎
Input events are sent as notifications whenever the DOM is being updated (or about to be updated) as a direct result of a user action (e.g., keyboard input in an editable region, deleting or formatting text, ...).
</p>

			<section id="interface-inputevent">
<h4 title="Interface InputEvent">3.6.1. `InputEvent^I ~interface</h4>

<p>
DOM3 にて導入された。
◎
Introduced in DOM Level 3
</p>

				<section id="idl-inputevent">
<h5>3.6.1.1. `InputEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `InputEvent@I : `UIEvent$I {
    `InputEvent@mc(`DOMString$ %type, optional `InputEventInit$I %eventInitDict = {});

    readonly attribute `USVString$? `data$m;
    readonly attribute `boolean$ `isComposing$m;
    readonly attribute `DOMString$ `inputType$m;
};
</pre>

<dl class="idl-def">
	<dt>
`data@m
◎
data, of type USVString, readonly, nullable
</dt>
	<dd>
~IMEにより生成される~Unicode文字 `Unicode$r 並びの値を保持する
— `空~文字列$にもなり得る。
一連の文字は、
`UAX15$r にて定義される~Unicode正規化~形
`NFC^em による定義に従って正規化されるベキである。
◎
data holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY contain the empty string.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>
`isComposing@m
◎
isComposing, of type boolean, readonly
</dt>
	<dd>
入力~eventが組成~sessionの一部として
— すなわち， `compositionstart$et ~eventの後, かつ
対応する `compositionend$et ~eventの前に —
生じたならば~T。
◎
true if the input event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`inputType@m
◎
inputType, of type DOMString, readonly
</dt>
	<dd>
~eventに結付けられた［
入力の型
］を識別する文字列を包含する。
◎
inputType contains a string that identifies the type of input associated with the event.
</dd>
	<dd>
この属性に妥当な値たちが成す~listは `Input-Events$r を見よ。
◎
For a list of valid values for this attribute, refer to the [Input-Events] specification.
</dd>
	<dd>
`未初期化~値$： 空~文字列
◎
The un-initialized value of this attribute MUST be the empty string "".
</dd>
</dl>

				</section>
				<section id="idl-inputeventinit">
<h5>3.6.1.2. `InputEventInit^I</h5>

<pre class="idl">
dictionary `InputEventInit@I : `UIEventInit$I {
    `DOMString$? `data@m = null;
    `boolean$ `isComposing@m = false;
    `DOMString$ `inputType@m = "";
};
</pre>

<p>
この辞書の各~memberは、
`InputEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
data, of type DOMString, nullable, defaulting to null
• Initializes the data attribute of the InputEvent object.
◎
isComposing, of type boolean, defaulting to false
• Initializes the isComposing attribute of the InputEvent object.
◎
inputType, of type DOMString, defaulting to ""
• Initializes the inputType attribute of the InputEvent object. 
</p>

				</section>
			</section>
			<section id="events-inputevent-event-order">
<h4 title="Input Event Order">3.6.2. 入力~event序列</h4>

<p>
この仕様にて定義される入力~eventは、
相互相対順序の下で生じるモノトスル。
◎
The input events defined in this specification MUST occur in a set order relative to one another.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`beforeinput$et
<td>

<tr><td>
<td>
<td><em>
DOM 要素は更新された
</em>
◎
DOM element is updated

<tr><td>2.
<td>`input$et
<td>
</table>

			</section>
			<section id="events-input-types">
<h4>3.6.3. 各種~入力~event型</h4>

<p>
◎
The Input event types are listed below.
</p>

				<section id="event-type-beforeinput">
<h5>3.6.3.1. `beforeinput^et</h5>

<div>
◎イ型 `beforeinput@et
◎界面 `InputEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
— 特定的には， `HTMLInputElement$I 等の~control, または
`contenteditable^a 属性が可能化されている任意の `Element$I 。
◎
Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
◎取消 可
◎構 Yes
◎既定動作
~DOM要素を更新する
◎
Update the DOM element
◎文脈
<p>
次を除き，`各種~入力~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`InputEvent.data$m は、
内容が削除されることになる場合は， ~NULL にされてもヨイ。
</li>
</ul>
◎表終

◎
Type 	beforeinput
Interface 	InputEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
Cancelable 	Yes
Composed 	Yes
Default action 	Update the DOM element
Context
(trusted events) 	

• Event.target : event target that is about to be updated
• UIEvent.view : Window
• UIEvent.detail : 0
• InputEvent.data : the string containing the data that will be added to the element, which MAY be null if the content will be deleted
• InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</div>

<p>
~UAは、
~DOMが更新されつつあるとき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when the DOM is about to be updated.
</p>

				</section>
				<section id="event-type-input">
<h5>3.6.3.2. `input^et</h5>

<div>
◎イ型 `input@et
◎界面 `InputEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
— 特定的には， `HTMLInputElement$I 等の~control, または
`contenteditable^a 属性が可能化されている任意の `Element$I 。
◎
Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~入力~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`InputEvent.data$m は、
内容が削除された場合には，`空~文字列$にされてもヨイ。
</li>
</ul>
◎表終

◎
Type 	input
Interface 	InputEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : event target that was just updated
• UIEvent.view : Window
• UIEvent.detail : 0
• InputEvent.data : the string containing the data that has been added to the element, which MAY be the empty string if the content has been deleted
• InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</div>

<p>
~UAは、
~DOMが更新された直後に，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event immediately after the DOM has been updated.
</p>

				</section>
			</section>
			<section id="_common-input-event-context">
<h4>各種~入力~eventに共通な文脈~情報</h4>

集約簡略化

<p>
各種~入力~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
更新されつつある／された`~event~target$。
◎
event target that
[ is about to be / was just ]
updated
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通な文脈~情報$を見よ。
</dd>
	<dt>`InputEvent!I ：</dt>
	<dd>
	<dd>
		<dl>
			<dt>`data$m</dt>
			<dd>
要素に追加された／されることになる~dataを包含する文字列。
内容が削除されることになる／された場合には、
~eventの型に応じて，`空~文字列$または~NULLにされてもヨイ。
◎
InputEvent.data : the string containing the data that
[ has been | will be ]
added to the element, which MAY be
[ the empty string | null ]
if the content
[ will be | has been ] deleted
</dd>
			<dt>`isComposing$m</dt>
			<dd>
この~eventが`~dead-key＠#keys-dead$連列, または
`~IME$が作動中な間に配送されたものであれば ~T
（`組成~event$が配送されているときなど）
／
~ELSE_ ~F
◎
InputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-keyboardevents">
<h3 title="Keyboard Events">3.7. ~keyboard~event型</h3>

<p>
~keyboard~eventは、
装置~依存である
— すなわち，それは、［
入力~装置の能力, および
【物理的な~UIkeyが】
~OSにてどう対応付けられているか
］に依拠する。
詳細は、
~keyboard~eventと`組成~event$とを組合せる用例も含め，
`§ ~keyboard~eventと~UIkey値$を見よ。
文字~生成~装置によっては，~keyboard~eventを生成しないものもある。
◎
Keyboard events are device dependent, i.e., they rely on the capabilities of the input devices and how they are mapped in the operating systems. Refer to Keyboard events and key values for more details, including examples on how Keyboard Events are used in combination with Composition Events. Depending on the character generation device, keyboard events might not be generated.
</p>

<p class="note">注記：
~keyboard~eventは、
~textな入力を供する~~方式（ `modality^en ）の一つにすぎない。
編集~時には、
~keyboard~eventを代替するもの（または それへの追加）として，
`InputEvent$I の利用も考慮すること。
◎
Keyboard events are only one modality of providing textual input. For editing scenarios, consider also using the InputEvent as an alternate to (or in addition to) keyboard events.
</p>

<p class="trans-note">【
参考：
`Keyboard Event Viewer＠https://w3c.github.io/uievents/tools/key-event-viewer.html$en
にて、
各種~keyboard~eventの挙動を試せる。
】</p>

			<section id="interface-keyboardevent">
<h4 title="Interface KeyboardEvent">3.7.1. `KeyboardEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`KeyboardEvent!I ~interfaceは、
~keyboard装置に特有な文脈的~情報を供する。
各~keyboard~eventは、
値を利用して~UIkeyを参照する。
~keyboard~eventは、
共通して，~focusを得ている要素へ向けられることが多い。
◎
The KeyboardEvent interface provides specific contextual information associated with keyboard devices. Each keyboard event references a key using a value. Keyboard events are commonly directed at the element that has the focus.
</p>

<p>
`KeyboardEvent$I ~interfaceは、
一部の共通的な修飾~UIkey用の簡便な属性：［
`ctrlKey$m,
`shiftKey$m,
`altKey$m,
`metaKey$m
］を供する。
これらの属性【への取得~access】は、
順に，［
`Control$kY,
`Shift$kY,
`Alt$kY,
`Meta$kY
］を引数に
`getModifierState()$m ~methodを利用するのと等価である。
◎
The KeyboardEvent interface provides convenient attributes for some common modifiers keys: ctrlKey, shiftKey, altKey, metaKey. These attributes are equivalent to using the method getModifierState() with Control, Shift, Alt, or Meta respectively.
</p>

<p>
`KeyboardEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `KeyboardEventInit$I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the KeyboardEvent interface, use the KeyboardEvent constructor, passing an optional KeyboardEventInit dictionary.
</p>

				<section id="idl-keyboardevent">
<h5>3.7.1.1. `KeyboardEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `KeyboardEvent@I : `UIEvent$I {
    `KeyboardEvent@mc(`DOMString$ %type, optional `KeyboardEventInit$I %eventInitDict = {});

    // <span class="comment">`location$m 属性がとり得る定数</span>
    const `unsigned long$ `DOM_KEY_LOCATION_STANDARD$m = 0x00;
    const `unsigned long$ `DOM_KEY_LOCATION_LEFT$m = 0x01;
    const `unsigned long$ `DOM_KEY_LOCATION_RIGHT$m = 0x02;
    const `unsigned long$ `DOM_KEY_LOCATION_NUMPAD$m = 0x03;

    readonly attribute `DOMString$ `key$m;
    readonly attribute `DOMString$ `code$m;
    readonly attribute `unsigned long$ `location$m;

    readonly attribute `boolean$ `ctrlKey$m;
    readonly attribute `boolean$ `shiftKey$m;
    readonly attribute `boolean$ `altKey$m;
    readonly attribute `boolean$ `metaKey$m;

    readonly attribute `boolean$ `repeat$m;
    readonly attribute `boolean$ `isComposing$m;

    `boolean$ `getModifierState$m (`DOMString$ %keyArg);
};
</pre>

<dl class="idl-def">
	<dt>`DOM_KEY_LOCATION_STANDARD@m</dt>
	<dd>
作動化された~UIkeyは、
~UIkeyの左／右 ~versionとして判別されるものではなく，かつ
十key（ `NumLock^cap ~UIkeyは除く）, または それに対応する~virtual~UIkeyからも出生されていないことを指示する。
◎
The key activation MUST NOT be distinguished as the left or right version of the key, and (other than the NumLock key) did not originate from the numeric keypad (or did not originate with a virtual key corresponding to the numeric keypad).
</dd>
	<dd class="example">
<p>
~PC101US~keyboardの `Q^cap ~UIkey。
◎
The Q key on a PC 101 Key US keyboard.
</p>
<p>
~PC101US~keyboardの
`NumLock^cap ~UIkey。
◎
The NumLock key on a PC 101 Key US keyboard.
</p>
<p>
~PC101US~keyboardの主区画に所在する `1^cap ~UIkey。
◎
The 1 key on a PC 101 Key US keyboard located in the main section of the keyboard.
</p>
	</dd>

	<dt>`DOM_KEY_LOCATION_LEFT@m</dt>
	<dd>
作動化された~UIkeyは、
左~UIkey所在から出生されていることを指示する
（当の~UIkey用にアリな所在が複数ある場合に限る）。
◎
The key activated originated from the left key location (when there is more than one possible location for this key).
</dd>
	<dd class="example">
~PC101US~keyboardの左 `Control^cap ~UIkey。
◎
The left Control key on a PC 101 Key US keyboard.
</dd>

	<dt>`DOM_KEY_LOCATION_RIGHT@m</dt>
	<dd>
作動化された~UIkeyは、
右~UIkey所在から出生されていることを指示する
（当の~UIkey用にアリな所在が複数ある場合に限る）。
◎
The key activation originated from the right key location (when there is more than one possible location for this key).
</dd>
	<dd class="example">
~PC101US~keyboardの 右 `Shift^cap ~UIkey。
◎
The right Shift key on a PC 101 Key US keyboard.
</dd>
	<dt>`DOM_KEY_LOCATION_NUMPAD@m</dt>
	<dd>
作動化された~UIkeyは、
十key, または それに 対応する~virtual~UIkeyから出生されていることを指示する
（当の~UIkey用にアリな所在が複数ある場合に限る）。
`NumLock^cap ~UIkeyは常に，所在 `DOM_KEY_LOCATION_STANDARD$m を伴って符号化されるベキであることに注意。
◎
The key activation originated on the numeric keypad or with a virtual key corresponding to the numeric keypad (when there is more than one possible location for this key). Note that the NumLock key should always be encoded with a location of DOM_KEY_LOCATION_STANDARD.
</dd>
	<dd class="example">
~PC101US~keyboardの ~numpadに所在する `1^cap ~UIkey。
◎
The 1 key on a PC 101 Key US keyboard located on the numeric pad.
</dd>

	<dt>
`key@m
◎
key, of type DOMString, readonly
</dt>
	<dd>
押された~UIkeyに対応する`~UIkey属性~値$を保持する。
◎
key holds a key attribute value corresponding to the key pressed.
</dd>
	<dd class="note">注記：
`key^m 属性は，旧来の `keyCode$m 属性には関係しない
— とり得る値の集合も同じでない。
◎
The key attribute is not related to the legacy keyCode attribute and does not have the same set of values.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>

	<dt>
`code@m
◎
code, of type DOMString, readonly
</dt>
	<dd>
`code^m は、
押されている物理的~UIkeyを識別する文字列を保持する。
値は，現在の~keyboard~layoutや修飾~状態からは影響されないので、
同じ~UIkeyからは常に同じ値が返されることになる。
◎
code holds a string that identifies the physical key being pressed. The value is not affected by the current keyboard layout or modifier state, so a particular key will always return the same value.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>

	<dt>
`location@m
◎
location, of type unsigned long, readonly
</dt>
	<dd>
`location^m 属性は、
装置~上の~UIkeyの論理的な所在の指示を包含する。
◎
The location attribute contains an indication of the logical location of the key on the device.
</dd>
	<dd>
この属性は、［
装置~上の~UIkeyの所在を指示する，
`DOM_KEY_LOCATION-…^m 定数
］のうちの，いずれかに設定するモノトスル。
◎
This attribute MUST be set to one of the DOM_KEY_LOCATION constants to indicate the location of a key on the device.
</dd>
	<dd>
【環境設定により】~UIkeyを対応付-直すことを許容する~UAは、
対応付けられた~~元の~UIkey用の `location$m 値を，新たな~UIkeyに適切な値に設定するモノトスル。
例えば， `ControlLeft$kC ~UIkeyが `KeyQ$kC ~UIkeyに対応付-直されたなら、
この属性は `DOM_KEY_LOCATION_STANDARD$m に設定するモノトスル。
逆に， `KeyQ$kC ~UIkeyが左右いずれかの `Control^cap ~UIkeyに対応付-直された場合、
それに応じて，この属性も［
`DOM_KEY_LOCATION_LEFT$m, `DOM_KEY_LOCATION_RIGHT$m
］のいずれかに設定するモノトスル。
◎
If a user agent allows keys to be remapped, then the location value for a remapped key MUST be set to a value which is appropriate for the new key. For example, if the "ControlLeft" key is mapped to the "KeyQ" key, then the location attribute MUST be set to DOM_KEY_LOCATION_STANDARD. Conversely, if the "KeyQ" key is remapped to one of the Control keys, then the location attribute MUST be set to either DOM_KEY_LOCATION_LEFT or DOM_KEY_LOCATION_RIGHT.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>
`ctrlKey@m
◎
ctrlKey, of type boolean, readonly
</dt>
	<dd>
`Control^cap （ control ）修飾が作動中であったならば~T
◎
true if the Control (control) key modifier was active. 
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`shiftKey@m
◎
shiftKey, of type boolean, readonly
</dt>
	<dd>
`Shift^cap （ shift ）修飾が作動中であったならば~T。
◎
true if the shift (Shift) key modifier was active.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`altKey@m
◎
altKey, of type boolean, readonly
</dt>
	<dd>
`Alt^cap （ alternative, ~~別名 `Option^cap ）修飾が作動中であったならば~T。
◎
true if the Alt (alternative) (or "Option") key modifier was active.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`metaKey@m
◎
metaKey, of type boolean, readonly
</dt>
	<dd>
`Meta^cap（ meta ）修飾が作動中であったならば~T。
◎
true if the meta (Meta) key modifier was active.
</dd>
	<dd class="note">注記：
Macintosh ~system上の `Command^cap （ `⌘^cap ）~UIkey修飾は
この~UIkey修飾を利用して表現される。
◎
The "Command" ("⌘") key modifier on Macintosh systems is represented using this key modifier.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`repeat@m
◎
repeat, of type boolean, readonly
</dt>
	<dd>
~UIkeyが~~持続的に押されているならば ~T 。
~UIkeyが~~押下げ続けられている下では、［
`keydown$et, `beforeinput$et, `input$et
］~eventが、
この順序で，~system環境設定から決定される頻度で，繰返すモノトスル。
`~UIkeyの長押し^em に対する挙動を備える携帯~機器においては、
`repeat$m 属性~値に ~T を伴う最初の~UIkey~eventが，その挙動を指示する~~役割を果たすモノトスル。
繰返され始めるまで~UIkeyを押し続ける必要がある時間の長さは、
環境設定に依存する。
◎
true if the key has been pressed in a sustained manner. Holding down a key MUST result in the repeating the events keydown, beforeinput, input in this order, at a rate determined by the system configuration. For mobile devices which have long-key-press behavior, the first key event with a repeat attribute value of true MUST serve as an indication of a long-key-press. The length of time that the key MUST be pressed in order to begin repeating is configuration-dependent.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`isComposing@m
◎
isComposing, of type boolean, readonly
</dt>
	<dd>
~UIkey~eventが組成~sessionの一部として
— すなわち， `compositionstart$et ~eventの後, かつ
対応する `compositionend$et ~eventの前に —
生じたならば~T。
◎
true if the key event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.
</dd>
	<dd>
`未初期化~値$： ~F
◎
The un-initialized value of this attribute MUST be false.
</dd>

	<dt>
`getModifierState(keyArg)@m
</dt>
	<dd>
`~UIkey値$を利用して，ある修飾の状態を~queryする。
◎
Queries the state of a modifier using a key value.
</dd>
	<dd>
［
%keyArg は修飾~UIkey用の`~UIkey値$であって，その~UIkeyは作動化されているならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if it is a modifier key and the modifier is activated, false otherwise.
</dd>
	<dd>
引数 %keyArg には、
修飾`~UIkey値$を与える。
妥当な`修飾~UIkey$は、
`UIEvents-Key$r の`修飾~UIkeyの表t$にて定義される。
◎
DOMString keyArg
◎
A modifier key value. Valid modifier keys are defined in the Modifier Keys table in [UIEvents-Key].
</dd>
	<dd class="note">注記：
~appが 右, 左の修飾を判別したいと望む場合、
この情報は，
~keyboard~event, および
`KeyboardEvent.location$m
を利用して演繹することもできる。
◎
If an application wishes to distinguish between right and left modifiers, this information could be deduced using keyboard events and location.
</dd>
</dl>

				</section>
				<section id="idl-keyboardeventinit">
<h5>3.7.1.2. `KeyboardEventInit^I</h5>

<pre class="idl">
dictionary `KeyboardEventInit@I : `EventModifierInit$I {
    `DOMString$ `key@m = "";
    `DOMString$ `code@m = "";
    `unsigned long$ `location@m = 0;
    `boolean$ `repeat@m = false;
    `boolean$ `isComposing@m = false;
};
</pre>

<p>
この辞書の各~memberは、
`KeyboardEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
key, of type DOMString, defaulting to ""
• Initializes the key attribute of the KeyboardEvent object to the unicode character string representing the meaning of a key after taking into account all keyboard modifiers (such as shift-state). This value is the final effective value of the key. If the key is not a printable character, then it should be one of the key values defined in [UIEvents-Key].
◎
code, of type DOMString, defaulting to ""
• Initializes the code attribute of the KeyboardEvent object to the unicode character string representing the key that was pressed, ignoring any keyboard modifications such as keyboard layout. This value should be one of the code values defined in [UIEvents-Code].
◎
location, of type unsigned long, defaulting to 0
• Initializes the location attribute of the KeyboardEvent object to one of the following location numerical constants:
• DOM_KEY_LOCATION_STANDARD (numerical value 0)
• DOM_KEY_LOCATION_LEFT (numerical value 1)
• DOM_KEY_LOCATION_RIGHT (numerical value 2)
• DOM_KEY_LOCATION_NUMPAD (numerical value 3)
◎
repeat, of type boolean, defaulting to false
• Initializes the repeat attribute of the KeyboardEvent object. This attribute should be set to true if the the current KeyboardEvent is considered part of a repeating sequence of similar events caused by the long depression of any single key, false otherwise.
◎
isComposing, of type boolean, defaulting to false
• Initializes the isComposing attribute of the KeyboardEvent object. This attribute should be set to true if the event being constructed occurs as part of a composition sequence, false otherwise.
</p>

				</section>

<div class="warning">
<p>
旧来の~keyboard~event実装は 3 種の追加的な属性［
`keyCode$m, `charCode$m, `which$m
］を含んでいる。
`keyCode^m 属性は［
~computer~keyboardの特定0の~UIkeyに結付けられた数的な値
］を指示する一方、
`charCode^m 属性は［
その~UIkeyに結付けられた文字の~ASCII値
］を指示し（ `keyCode^m 値と同じにもなり得る），
適用-可能なのは`文字~値$を生産する~UIkeyに限られる。
◎
Legacy keyboard event implementations include three additional attributes, keyCode, charCode, and which. The keyCode attribute indicates a numeric value associated with a particular key on a computer keyboard, while the charCode attribute indicates the ASCII value of the character associated with that key (which might be the same as the keyCode value) and is applicable only to keys that produce a character value.
</p>

<p>
実施においては、［
`keyCode^m, `charCode^m
］は，［
~platform間で, あるいは
同じ実装ですら 種々の~OSや地域化の間で
］一貫でない。
この仕様は［
`keyCode^m, `charCode^m
］の値も, `charCode^m の挙動も定義しない。
適合~UI~Events実装においては，内容~作者は、［
`KeyboardEvent.key$m, `KeyboardEvent.code$m
］を利用できる。
◎
In practice, keyCode and charCode are inconsistent across platforms and even the same implementation on different operating systems or using different localizations. This specification does not define values for either keyCode or charCode, or behavior for charCode. In conforming UI Events implementations, content authors can instead use key and code.
</p>

<p><em>
更なる情報は、
参考な
`§ 旧来の~UIkey属性＠~UIEVENTS-A#legacy-key-attributes$
を見よ。
</em>
◎
For more information, see the informative appendix on Legacy key attributes.
</p>
</div>

<p class="note">注記：
既存の内容との互換性のため，~virtual~keyboard
— ~screenに基づく入力~装置~上の~software~keyboardなど —
は、［
物理的~UIkeyを処理しなくとも，通常の範囲の~keyboard~eventを生産する
］ものと期待されている。
◎
For compatibility with existing content, virtual keyboards, such as software keyboards on screen-based input devices, are expected to produce the normal range of keyboard events, even though they do not possess physical keys.
</p>

<p class="note">注記：
一部の実装／~system環境設定においては、
一部の~UIkey~eventやその値は，利用-中にある`~IME$により抑止されることがある。
◎
In some implementations or system configurations, some key events, or their values, might be suppressed by the IME in use.
</p>

			</section>
			<section id="events-keyboard-key-location">
<h4 title="Keyboard Event Key Location">3.7.2. ~keyboard~eventに対する~UIkeyの所在</h4>

<!-- `KeyboardEvent!I -->

<p>
`location$m 属性は、
~keyboard上の異なる物理的~UIkeyから同じ`~UIkey値$が生成される場合に，
それらを~~区別するために利用できる。
例えば、
左右 `Shift^cap ~UIkey，あるいは
物理的~矢印~UIkeyと（ `NumLock^cap が off のときの）~numpad上の矢印~UIkey。
◎
The location attribute can be used to disambiguate between key values that can be generated by different physical keys on the keyboard, for example, the left and right Shift key or the physical arrow keys vs. the numpad arrow keys (when NumLock is off).
</p>

<p>
~keyboard上に所在が複数あるような特別な~UIkey用の，妥当な `location$m 値は、
次の表tに定義される：
◎
The following table defines the valid location values for the special keys that have more than one location on the keyboard:
</p>

<table class="event-sequence-table"><thead>
<tr><th>
`key$m 値
◎
KeyboardEvent . key
<th>
妥当な `location$m 値
◎
Valid location values
<tbody>

<tr><td>
`Shift$kY, `Control$kY, `Alt$kY, `Meta$kY
<td>
`DOM_KEY_LOCATION_LEFT$m,
`DOM_KEY_LOCATION_RIGHT$m

<tr><td>
`ArrowDown$kY, `ArrowLeft$kY, `ArrowRight$kY, `ArrowUp$kY
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

<tr><td>
`End$kY, `Home$kY, `PageDown$kY, `PageUp$kY
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m

<tr><td>
`0^kY, `1^kY, `2^kY, `3^kY,
`4^kY, `5^kY, `6^kY, `7^kY,
`8^kY, `9^kY, `.^kY, `Enter$kY,
`+^kY, `-^kY, `*^kY, `/^kY,
<td>
`DOM_KEY_LOCATION_STANDARD$m,
`DOM_KEY_LOCATION_NUMPAD$m
</table>

<p>
この表tに挙げられていない他のすべての~UIkey用の `location$m 属性は、
常に `DOM_KEY_LOCATION_STANDARD$m に設定するモノトスル。
◎
For all other keys not listed in this table, the location attribute MUST always be set to DOM_KEY_LOCATION_STANDARD. 
</p>

			</section>
			<section id="keyboardevent-algorithms">
<h4 title="KeyboardEvent Algorithms">3.7.3. `KeyboardEvent^I 用の~algo</h4>

				<section id="keyboardevent-global-state">
<h5 title="Global State for KeyboardEvent">3.7.3.1. `KeyboardEvent^I 用の大域的な状態</h5>

<div>
<p id="keyboardevent-global-ua">
~UAは、
~UA全体で共有される値をとして，次を保守するモノトスル：
</p>
<ul>
	<li>
<p>
`修飾~UIkey状態@
⇒
~systemにて可用な各［
%名前 ~IN { `Shift^l, `Control^l, `Alt^l, `AltGraph^l, `Meta^l } で識別される`修飾~UIkey$
］の現在の状態を追跡し続ける。
</p>

<p>
`修飾~UIkey状態$( %名前 )
と記された所では、
%名前 で識別される修飾~UIkeyは［
押されているならば ~T ／
~ELSE_ ~F
］を返すとする。
【この記法は、他所を簡潔に述べるためのこの訳による追加。】
</p>
	</li>
</ul>
◎
4.7.3.1.1. User Agent-Level State
◎
The UA must maintain the following values that are shared for the entire User Agent.
◎
A key modifier state (initially empty) that keeps track of the current state of each modifier key available on the system.
</div>

				</section>
			</section>
			<section id="events-keyboard-event-order">
<h4 title="Keyboard Event Order">3.7.4. ~keyboard~event序列</h4>

<p>
この仕様にて定義される~keyboard~eventは、
与えられたどの~UIkeyに対しても，相互相対順序の下で生じる：
◎
The keyboard events defined in this specification occur in a set order relative to one another, for any given key:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>

<tr><td>2.
<td>`beforeinput$et
<td><em>
（`文字~値$を生産する~UIkeyに対してのみ）
</em>
◎
(only for keys which produce a character value)

<tr><td>
<td>
<td><em>
この~UIkeyに関係する`既定~動作$
— 文字を~DOMの中へ挿入するなど —
があれば，それが行われる。
</em>
◎
Any default actions related to this key, such as inserting a character in to the DOM.

<tr><td>3.
<td>`input$et
<td><em>
（~DOMを更新させた~UIkeyに対してのみ）
</em>
◎
(only for keys which have updated the DOM)

<tr><td>
<td>
<td><em>
一定時間，~UIkeyが押下げられたとき、
生じ得るような~event（下を見よ）。
</em>
◎
Any events as a result of the key being held for a sustained period (see below).

<tr><td>4.
<td>`keyup$et
<td>
</table>

<p>
一定時間，~UIkeyが押下げられた場合、
環境に依存する頻度で，次の~eventが繰返されてもヨイ：
◎
If the key is depressed for a sustained period, the following events MAY repeat at an environment-dependent rate:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td><em>
（ `KeyboardEvent.repeat$m 属性は ~T に設定される）
</em>
◎
(with repeat attribute set to true)

<tr><td>2.
<td>`beforeinput$et
<td><em>
（`文字~値$を生産した~UIkeyに対してのみ）
</em>
◎
(only for keys which produce a character value)

<tr><td>
<td>
<td><em>
【！複製】
この~UIkeyに関係する`既定~動作$
— 文字を~DOMの中へ挿入するなど —
があれば，それが行われる。
</em>
◎
Any default actions related to this key, such as inserting a character in to the DOM.

<tr><td>3.
<td>`input$et
<td><em>
【！複製】
（~DOMを更新させた~UIkeyに対してのみ）
</em>
◎
(only for keys which have updated the DOM)
</table>

<p class="note">注記：
概して、
特定0の~UIkeyに結付けられた`既定~動作$があれば，
`keyup$et ~eventが発火される前に完了する。
これは
`keyup$et ~eventを少しばかり遅延し得る
（おそらく，知覚される程の遅延にはならないであろうが）。
◎
Typically, any default actions associated with any particular key are completed before the keyup event is dispatched. This might delay the keyup event slightly (though this is not likely to be a perceptible delay).
</p>

<p>
~UIkey~eventの`~target$は、
~keyboard活動を処理している現在の被focus要素である。
これは、［
~HTML `input^e 要素／編集-可能な~textな要素
］になることが多いが、
`~host言語$における非~text目的の~keyboard入力
— 加速~UIkeyの作動化や 一部の他の挙動の誘発など —
を受容するように定義された要素になることもある。
相応しい被focus要素が無い場合の~event~targetは、［
可用なら ~HTML`~body要素$ ／
他の場合は `根~要素$
］になる。
◎
The event target of a key event is the currently focused element which is processing the keyboard activity. This is often an HTML input element or a textual element which is editable, but MAY be an element defined by the host language to accept keyboard input for non-text purposes, such as the activation of an accelerator key or trigger of some other behavior. If no suitable element is in focus, the event target will be the HTML body element if available, otherwise the root element.
</p>

<p class="note">注記：
`~event~target$は、
一連の~UIkey~event間で変化し得る。
例えば， `Tab^cap ~UIkey用の `keydown$et ~eventの`~target$は、
同じ~keystroke用の `keyup$et ~eventと異なるであろう。
◎
The event target might change between different key events. For example, a keydown event for the Tab key will likely have a different event target than the keyup event on the same keystroke.
</p>

			</section>
			<section id="events-keyboard-types">
<h4>3.7.5. 各種~keyboard~event型</h4>

				<section id="event-type-keydown">
<h5>3.7.5.1. `keydown^et</h5>

<div>
◎イ型 `keydown@et
◎界面 `KeyboardEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作
<p>
文脈依存：
</p>
<ul>
	<li>
`beforeinput$et ＆ `input$et ~event
</li>
	<li>
`~text組成~system$を立上げる
</li>
	<li>
`blur$et ＆ `focus$et ~event
</li>
	<li>
`keypress$et ~event（~support有りなら）
</li>
	<li>
`作動化の挙動$
</li>
	<li>
その他の~event
</li>
</ul>
◎
Varies: beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other event
◎文脈
`各種~keyboard~eventに共通な文脈~情報$を見よ。
◎表終

◎
Type 	keydown
Interface 	KeyboardEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies: beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other event
Context
(trusted events) 	

• Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
• UIEvent.view : Window
• UIEvent.detail : 0
• KeyboardEvent.key : the key value of the key pressed.
• KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
• KeyboardEvent.location : the location of the key on the device.
• KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
• KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
• KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
• KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
• KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
• KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</div>

<p>
~UAは、［
~UIkeyが押された
］とき，この~eventを発火するモノトスル。
`keydown$et ~event型は装置~依存であり，
入力~装置の能力, および
それらが~OSにおいて対応付けられている方法に依拠する。
この~event型は、
`~UIkey対応付け$の後に生成するモノトスル。
この~event型は、
同じ~UIkeyに結付けられた［
`beforeinput$et, `input$et, `keyup$et
］~eventの前に配送するモノトスル。
◎
A user agent MUST dispatch this event when a key is pressed down. The keydown event type is device dependent and relies on the capabilities of the input devices and how they are mapped in the operating system. This event type MUST be generated after the key mapping. This event type MUST be dispatched before the beforeinput, input, and keyup events associated with the same key.
</p>

<p>
`keydown$et
~eventの既定~動作は，~UIkeyに依存する：
◎
The default action of the keydown event depends upon the key:
</p>

<ul>
	<li>
~UIkeyが文字に結付けられた場合の既定~動作は、［
`beforeinput$et ~event, 後続する `input$et ~event
］を発火するモノトスル。
~UIkeyが複数の文字に結付けられた場合
（~macroを伴うものや ~dead-keyからなる連列など）
の既定~動作は、
各~文字に対し［
`beforeinput$et, `input$et
］~event対を発火するモノトスル。
◎
If the key is associated with a character, the default action MUST be to dispatch a beforeinput event followed by an input event. In the case where the key which is associated with multiple characters (such as with a macro or certain sequences of dead keys), the default action MUST be to dispatch one set of beforeinput / input events for each character
</li>
	<li>
~UIkeyが`~text組成~system$に結付けられた場合の既定~動作は、
その~systemを立上げるモノトスル。
◎
If the key is associated with a text composition system, the default action MUST be to launch that system
</li>
	<li>
~UIkeyが `Tab^cap ~UIkeyの場合の既定~動作は、
`~focus~event$型にて述べたとおり，文書~focusを現在の被focus要素（もしあれば）から新たな被focus要素へ移転するモノトスル。
◎
If the key is the Tab key, the default action MUST be to shift the document focus from the currently focused element (if any) to the new focused element, as described in Focus Event Types
</li>
	<li>
~UIkeyが `Enter^cap ／ `~SPACEBAR^cap ~UIkeyであって, かつ
現在の~focusが状態~変化-中にある要素~上にある場合の既定~動作は、［
`click$et ~eventに加えて，~UAが~supportするならば `DOMActivate$et ~event
］を発火するモノトスル。
◎
If the key is the Enter or   (Space) key and the current focus is on a state-changing element, the default action MUST be to dispatch a click event, and a DOMActivate event if that event type is supported by the user agent.
</li>
</ul>

<p>
この~eventが取消された場合、［
結付けられた~event型は発火しないことに加え，
結付けられた動作も遂行しない
］モノトスル。
◎
If this event is canceled, the associated event types MUST NOT be dispatched, and the associated actions MUST NOT be performed.
</p>

<p class="note">注記：
［
`keydown$et ／ `keyup$et
］~eventは、
伝統的に［
`文字~値$を生産する~UIkeyに限らず，他の~UIkeyの検出-法
］にも結付けられる。
◎
The keydown and keyup events are traditionally associated with detecting any key, not just those which produce a character value.
</p>

				</section>
				<section id="event-type-keyup">
<h5>3.7.5.2. `keyup^et</h5>

<div>
◎イ型 `keyup@et
◎界面 `KeyboardEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
`各種~keyboard~eventに共通な文脈~情報$を見よ。
◎表終

◎
Type 	keyup
Interface 	KeyboardEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
• UIEvent.view : Window
• UIEvent.detail : 0
• KeyboardEvent.key : the key value of the key pressed.
• KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
• KeyboardEvent.location : the location of the key on the device.
• KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
• KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
• KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
• KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
• KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
• KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</div>

<p>
~UAは、［
~UIkeyが離された
］とき，この~eventを発火するモノトスル。
`keyup$et ~event型は装置~依存であり，
入力~装置の能力, および
それらが~OSにおいて対応付けられている方法
に依拠する。
この~event型は，`~UIkey対応付け$の後に生成するモノトスル。
この~event型は、
同じ~UIkeyに結付けられた［
`keydown$et,
`beforeinput$et,
`input$et
］~eventの後に発火するモノトスル。
◎
A user agent MUST dispatch this event when a key is released. The keyup event type is device dependent and relies on the capabilities of the input devices and how they are mapped in the operating system. This event type MUST be generated after the key mapping. This event type MUST be dispatched after the keydown, beforeinput, and input events associated with the same key.
</p>

<p class="note">注記：
［
`keydown$et ／ `keyup$et
］~eventは、
伝統的に［
`文字~値$を生産する~UIkeyに限らず，他の~UIkeyの検出-法
］にも結付けられる。
◎
The keydown and keyup events are traditionally associated with detecting any key, not just those which produce a character value.
</p>

				</section>
			</section>
			<section id="_common-keyboard-event-context">
<h4>各種~keyboard~eventに共通な文脈~情報</h4>

集約簡略化

<p>
~keyboard~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
~UIkey~eventを処理している被focus要素。
被focus要素がない場合、
可用ならば`~body要素$ ／
他の場合 `根~要素$
◎
Event.target : focused element processing the key event or if no element focused, then the body element if available, otherwise the root element
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通な文脈~情報$を見よ。
</dd>

	<dt>`KeyboardEvent!I ：</dt>
	<dd>
		<dl>
			<dt>`key$m</dt>
			<dd>
押された~UIkeyの`~UIkey値$。
◎
KeyboardEvent.key : the key value of the key pressed.
</dd>
			<dt>`code$m</dt>
			<dd>
~UIkeyの~keyboard上での物理的~~位置に結付けられた~code値
◎
KeyboardEvent.code : the code value associated with the key’s physical placement on the keyboard.
</dd>
			<dt>`location$m</dt>
			<dd>
装置~上の~UIkeyの所在。
◎
KeyboardEvent.location : the location of the key on the device.
</dd>
			<dt>`altKey$m</dt>
			<dd>
`Alt^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.altKey : true if Alt modifier was active, otherwise false
</dd>
			<dt>`shiftKey$m</dt>
			<dd>
`Shift^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.shiftKey : true if Shift modifier was active, otherwise false
</dd>
			<dt>`ctrlKey$m</dt>
			<dd>
`Control^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.ctrlKey : true if Control modifier was active, otherwise false
</dd>
			<dt>`metaKey$m</dt>
			<dd>
`Meta^cap 修飾が作動中であったなら ~T ／
他の場合 ~F
◎
KeyboardEvent.metaKey : true if Meta modifier was active, otherwise false
</dd>
			<dt>`repeat$m</dt>
			<dd>
~UIkeyの繰返nを誘発するに十分~長く~UIkeyが押下げられているならば ~T ／
他の場合 ~F
◎
KeyboardEvent.repeat : true if a key has been depressed long enough to trigger key repetition, otherwise false
</dd>
			<dt>`isComposing$m</dt>
			<dd>
~UIkey~eventが，組成~sessionの一部として生じたならば ~T ／
他の場合 ~F
◎
KeyboardEvent.isComposing : true if the key event occurs as part of a composition session, otherwise false
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
		<section id="events-compositionevents">
<h3 title="Composition Events">3.8. 組成~event</h3>

<div>
<p>
組成~event（ `Composition Events^en ）は、
~~普通の~keyboardには無い文字を利用することを許容するために，
`~keyboard~event$による方式に［
補足的な, あるいは代替する
］方式で，~textを入力する手段を供する。
組成~eventは、
例えば，次のために利用され得る：
</p>
<ul>
	<li>
文字に標準的な~US~keyboardには無い~accentを追加する。
</li>
	<li>
多くのアジア圏の言語において，基底~成分／字種から表語文字を築上げる。
</li>
	<li>
携帯~機器~keyboardで，押されている~UIkeyの組合nから 単語を選択する。
</li>
	<li>
発話~認識~処理器を利用して，一連の~voice~commandを~textに変換する。
</li>
</ul>

<p>
`組成~event$を~keyboard~eventと組合せる用例については、
`§ ~keyboard~eventと~UIkey値$を見よ。
</p>

◎
Composition Events provide a means for inputing text in a supplementary or alternate manner than by Keyboard Events, in order to allow the use of characters that might not be commonly available on keyboard. For example, Composition Events might be used to add accents to characters despite their absence from standard US keyboards, to build up logograms of many Asian languages from their base components or categories, to select word choices from a combination of key presses on a mobile device keyboard, or to convert voice commands into text using a speech recognition processor. Refer to § 4 Keyboard events and key values for examples on how Composition Events are used in combination with keyboard events.
</div>

<p>
概念的には、
組成~sessionは［
1 個の `compositionstart$et ~event,
1 個【 0 個？】以上の `compositionupdate$et ~event,
1 個の `compositionend$et ~event
］からなり、
それらの~eventの `CompositionEvent.data$m 属性の値は，
各~sessionの最中のこの~event連鎖【伝播？連列？】の各 “stage” 間で持続する【？】。
◎
Conceptually, a composition session consists of one compositionstart event, one or more compositionupdate events, and one compositionend event, with the value of the data attribute persisting between each "stage" of this event chain during each session.
</p>

<p class="note">注記：
組成~sessionで利用されている入力~装置が~keyboardである場合、
組成~sessionが作動中にある間の~keyboard~eventは，~DOMへ発火され得る。
関連な~eventたちの順序付けについては、
`compositionstart$et の詳細, `§ ~IME＠#keys-IME$を見よ。
◎
Note: While a composition session is active, keyboard events can be dispatched to the DOM if the keyboard is the input device used with the composition session. See the compositionstart event details and IME section for relevent event ordering.
</p>

<p>
`~IME$~system／装置は，~DOMに必要yな~dataを公開するとは限らないので、
作動中な組成~文字列
（ “変換窓（ `Reading Window^en ）” や “候補~選択~menuに示されるもの” ）
は，この~interfaceを通して可用でないこともある
— その場合、
選択は`空~文字列$として表現されることもある。
◎
Not all IME systems or devices expose the necessary data to the DOM, so the active composition string (the "Reading Window" or "candidate selection menu option") might not be available through this interface, in which case the selection MAY be represented by the empty string.
</p>

			<section id="interface-compositionevent">
<h4 title="Interface CompositionEvent">3.8.1. `CompositionEvent^I ~interface</h4>

<p class="intro-dom">
この仕様にて導入された。
◎
Introduced in this specification
</p>

<p>
`CompositionEvent^I ~interfaceは、
`組成~event$に特有な文脈的~情報を供する。
◎
The CompositionEvent interface provides specific contextual information associated with Composition Events.
</p>

<p>
`CompositionEvent^I ~interfaceの~instanceを作成するためには、
その構築子に `CompositionEventInit^I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the CompositionEvent interface, use the CompositionEvent constructor, passing an optional CompositionEventInit dictionary.
</p>

				<section id="idl-compositionevent">
<h5>3.8.1.1. `CompositionEvent^I</h5>

<pre class="idl">
[`Exposed$=Window]
interface `CompositionEvent@I : `UIEvent$I {
    `CompositionEvent@mc(`DOMString$ %type, optional `CompositionEventInit$I %eventInitDict = {});

    readonly attribute `USVString$ `data$m;
};
</pre>

<dl class="idl-def">
	<dt>
`data@m
◎
data, of type USVString, readonly
</dt>
	<dd>
`data^c は~IMEにより生成された一連の`文字~値$を保持する
— `空~文字列$にもなり得る。
一連の文字は、［
`UAX15$r にて定義される~Unicode正規化~形 `NFC^em
］による定義に従って正規化されるベキである。
◎
data holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY be the empty string.
</dd>
	<dd>
`未初期化~値$： `空~文字列$
◎
The un-initialized value of this attribute MUST be "" (the empty string).
</dd>
</dl>

				</section>
				<section id="idl-compositioneventinit">
<h5>3.8.1.2. `CompositionEventInit^I</h5>

<pre class="idl">
dictionary `CompositionEventInit@I : `UIEventInit$I {
    `DOMString$ `data@m = "";
};
</pre>

<p>
この辞書の各~memberは、
`CompositionEvent!I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
data, of type DOMString, defaulting to ""
• Initializes the data attribute of the CompositionEvent object to the characters generated by the IME composition.
</p>

				</section>
			</section>
			<section id="events-composition-order">
<h4 title="Composition Event Order">3.8.2. 組成~event序列</h4>

<p>
この仕様にて定義される`組成~event$は、
次による相互相対順序の下で生じるモノトスル：
◎
The Composition Events defined in this specification MUST occur in the following set order relative to one another:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`compositionstart$et
<td>

<tr><td>2.
<td>`compositionupdate$et
<td>複数回 生じ得る
◎
Multiple events

<tr><td>3.
<td>`compositionend$et
<td>
</table>

			</section>
			<section id="events-composition-handwriting">
<h4 title="Handwriting Recognition Systems">3.8.3. 手書き認識~system</h4>
<p>
次の例に、［
~pen~tabletなどの手書き認識~systemの下で，一節の~text "text" を組成する
］ときにアリな~event連列を，`組成~event$の~modelを利用して述べる。
◎
The following example describes a possible sequence of events when composing a text passage "text" with a handwriting recognition system, such as on a pen tablet, as modeled using Composition Events.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`compositionstart$et
<td>`^kGl
<td>

<tr><td>
<td>
<td>
<td><em>
利用者が~tablet表面に単語を書いた
</em>
◎
User writes word on tablet surface

<tr><td>2.
<td>`compositionupdate$et
<td>`test^kGl
<td>

<tr><td>
<td>
<td>
<td><em>
利用者が~~候補として最初に挙げられた単語を却下して，異なる~~候補を選択した
</em>
◎
User rejects first word-match suggestion, selects different match

<tr><td>3.
<td>`compositionupdate$et
<td>`text^kGl
<td>

<tr><td>4.
<td>`compositionend$et
<td>`text^kGl
<td>
</table>

			</section>
			<section id="events-composition-canceling">
<h4 title="Canceling Composition Events">3.8.4. 組成~eventの取消~法</h4>
<p>
`keydown$et ~eventが取消された場合、
その `keydown$et の結果として発火されることになる
どの`組成~event$も，発火されるベキでない：
◎
If a keydown event is canceled then any Composition Events that would have fired as a result of that keydown SHOULD not be dispatched:
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td><em>
`組成~event$は発火されない。
</em>
◎
No Composition Events are dispatched

<tr><td>2.
<td>`keyup$et
<td>
</table>

<p>
初期 `compositionstart$et ~eventが取消された場合、
~text組成~sessionは，終了されるベキである。
`compositionend$et ~eventは、
組成~sessionが終了されたかどうかに関わらず，送信するモノトスル。
◎
If the initial compositionstart event is canceled then the text composition session SHOULD be terminated. Regardless of whether or not the composition session is terminated, the compositionend event MUST be sent.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>

<tr><td>2.
<td>`compositionstart$et
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td><em>
【！複製】
`組成~event$は発火されない。
</em>
◎
No Composition Events are dispatched

<tr><td>3.
<td>`compositionend$et
<td>

<tr><td>4.
<td>`keyup$et
<td>
</table>

			</section>
			<section id="events-composition-key-events">
<h4 title="Key Events During Composition">3.8.5. 組成~時における~UIkey~event</h4>

<p>
組成~sessionの最中でも、
依然として［
`keydown$et, `keyup$et
］~eventは送信するモノトスル
— その `KeyboardEvent.isComposing$m 属性は ~T になるモノトスル。
◎
During the composition session, keydown and keyup events MUST still be sent, and these events MUST have the isComposing attribute set to true.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`KeyboardEvent.isComposing$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>~F
<td>
これが組成を起動した~UIkey~eventである。
◎
This is the key event that initiates the composition.
<tr><td>2.
<td>`compositionstart$et
<td>
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>

<tr><td>4.
<td>`keyup$et
<td>~T
<td>

<tr><td>
<td>...
<td>
<td>
組成~sessionの最中に送信された どの~UIkey~eventも，
`KeyboardEvent.isComposing$m は ~T に設定するモノトスル。
◎
Any key events sent during the composition session MUST have isComposing set to true.
<tr><td>5.
<td>`keydown$et
<td>~T
<td>
これが組成を終わらせた~UIkey~eventである。
◎
This is the key event that exits the composition.
<tr><td>6.
<td>`compositionend$et
<td>
<td>

<tr><td>7.
<td>`keyup$et
<td>~F
<td>
</table>

			</section>
			<section id="events-composition-input-events">
<h4 title="Input Events During Composition">3.8.6. 組成~sessionの間の入力~event</h4>

<p>
組成~sessionの間は、
その `compositionupdate$et は，
`beforeinput$et が送信された後, かつ
`input$et が送信される前に発火するモノトスル。
◎
During the composition session, the compositionupdate MUST be dispatched after the beforeinput is sent, but before the input event is sent.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`beforeinput$et
<td>

<tr><td>2.
<td>`compositionupdate$et
<td>

<tr><td>
<td>
<td><em>
~DOMの更新はこの時点で生じる。
</em>
◎
Any DOM updates occur at this point.

<tr><td>3.
<td>`input$et
<td>

</table>

<p class="note">注記：
ほとんどの~IMEは、
組成~sessionの間における更新の取消~法は~supportしない。
◎
Most IMEs do not support canceling updates during a composition session.
</p>

<p>
［
`beforeinput$et ／ `input$et
］~eventは、
組成の一部として~DOMが更新されるときに，
`compositionupdate$et ~eventに伴って送信される。
`compositionend$et ~eventに対しては，~DOMの更新はないので、［
`beforeinput$et ／ `input$et
］~eventは送信されるべきではない。
◎
The beforeinput and input events are sent along with the compositionupdate event whenever the DOM is updated as part of the composition. Since there are no DOM updates associated with the compositionend event, beforeinput and input events should not be sent at that time.
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`beforeinput$et
<td>
これを取消したときは ~DOM更新と `input$et ~eventを防止することになる。
◎
Canceling this will prevent the DOM update and the input event.

<tr><td>2.
<td>`compositionupdate$et
<td>

<tr><td>
<td>
<td><em>
~DOMの更新はこの時点で生じる。
</em>
◎
Any DOM updates occur at this point.

<tr><td>3.
<td>`input$et
<td><em>
~DOMが更新された場合に限り送信される。
</em>
◎
Sent only if the DOM was updated.

<tr><td>4.
<td>`compositionend$et
<td>

</table>

			</section>
			<section id="events-composition-types">
<h4 title="Composition Event Types">3.8.7. 各種~組成~event型</h4>

				<section id="event-type-compositionstart">
<h5>3.8.7.1. `compositionstart^et</h5>

<div>
◎イ型 `compositionstart@et
◎界面 `CompositionEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作
`~text組成~system$が可能化されているならば，新たな組成~sessionを開始する。
◎文脈
<p>
次を除き，`各種~組成~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`CompositionEvent.data$m：
編集-中にある【！元の】文字列, または`空~文字列$
</li>
</ul>
◎表終

◎
Type 	compositionstart
Interface 	CompositionEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Start a new composition session when a text composition system is enabled
Context
(trusted events) 	

• Event.target : focused element processing the composition
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the original string being edited, otherwise the empty string
</div>

<p>
~UAは、
`~text組成~system$が可能化されている下で，［
~textの一節を組成する準備として，新たな組成~sessionが始まりつつある
（または，`~text組成~system$に依存して始まった）
］とき，この~eventを発火するモノトスル。
この~event型は、
装置に依存し，［
~text変換~systemの能力,
~OSの中へ対応付けられる方法
］に依拠することもある。
この~event型は、
~IMEへの~~入力が~keyboardから投入された場合は，
`keydown$et ~eventの後に生成されるが、［
発話／手書き
］認識~systemにおいては
~keyboard~eventを伴わずに送信されてもヨイ。
実装は、
`compositionstart$et ~eventの `CompositionEvent.data$m 属性を［
文書にて現在（編集／置換~用に）選択されている~text
］で拡充してもヨイ
— そうしない場合、
`空~文字列$にするモノトスル。
◎
A user agent MUST dispatch this event when a text composition system is enabled and a new composition session is about to begin (or has begun, depending on the text composition system) in preparation for composing a passage of text. This event type is device-dependent, and MAY rely upon the capabilities of the text conversion system and how it is mapped into the operating system. When a keyboard is used to feed an input method editor, this event type is generated after a keydown event, but speech or handwriting recognition systems MAY send this event type without keyboard events. Some implementations MAY populate the data attribute of the compositionstart event with the text currently selected in the document (for editing and replacement). Otherwise, the value of the data attribute MUST be the empty string.
</p>

<p>
この~eventは、
`~text組成~system$が新たな組成~sessionを始める直前に, かつ
組成~処理により~DOMが改変される前に，発火するモノトスル。
この~eventの，`~text組成~system$用の既定~動作は、
新たな組成~sessionを開始させる。
この~eventが取消された場合、
`~text組成~system$は，現在の組成~sessionを破棄するベキである。
◎
This event MUST be dispatched immediately before a text composition system begins a new composition session, and before the DOM is modified due to the composition process. The default action of this event is for the text composition system to start a new composition session. If this event is canceled, the text composition system SHOULD discard the current composition session.
</p>

<p class="note">注記：
`compositionstart$et ~eventを取消すことと，`~text組成~system$自身を取消すこと
（例： 取消~buttonを叩いたり, `~IME$ ~UIwindowを閉じるなど）
とは、
別物である。
◎
Canceling the compositionstart event type is distinct from canceling the text composition system itself (e.g., by hitting a cancel button or closing an IME window).
</p>

<p class="note">注記：
~IMEには、
進捗-中にある組成~sessionの取消~法を~supportしないものもある
（例： GTK などは，~~現時点ではそのような~APIを備えていない）。
そのような事例では、
`preventDefault()$m を~callしても，この~eventの既定~動作は停止されないことになる。
◎
Some IMEs do not support cancelling an in-progress composition session (e.g., such as GTK which doesn’t presently have such an API). In these cases, calling preventDefault() will not stop this event’s default action.
</p>

				</section>
				<section id="event-type-compositionupdate">
<h5>3.8.7.2. `compositionupdate^et</h5>

<div>
◎イ型 `compositionupdate@et
◎界面 `CompositionEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~組成~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`CompositionEvent.data$m：
組成~sessionの現在の結果を成す文字列
— 内容が削除された場合、
`空~文字列$になることもある。
</li>
</ul>
◎表終

◎
Type 	compositionupdate
Interface 	CompositionEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : focused element processing the composition, null if not accessible
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the string comprising the current results of the composition session, which MAY be the empty string if the content has been deleted
</div>

<p>
~UAは、［
組成~sessionの最中に，`~text組成~system$が その作動中な~text一節を新たな文字で更新するとき
］に，この~eventを発火するベキである。
また、
配送するときは，
`CompositionEvent.data$m 値にその更新を反映するモノトスル。
◎
A user agent SHOULD dispatch this event during a composition session when a text composition system updates its active text passage with a new character, which is reflected in the string in data.
</p>

<p>
［
進行中な組成と入力~controlとの同期cを保つ
］ような `~text組成~system$においては、
`compositionupdate$et ~eventは，その~controlが更新される前に配送するモノトスル。
◎
In text composition systems which keep the ongoing composition in sync with the input control, the compositionupdate event MUST be dispatched before the control is updated.
</p>

<p>
`~text組成~system$には、
この情報を~DOMに公開しないものもある
— その場合、
この~eventは，組成~処理nの最中には発火されないことになる。
◎
Some text composition systems might not expose this information to the DOM, in which case this event will not fire during the composition process.
</p>

<p>
組成~sessionが取消された場合、
この~eventは， `compositionend$et ~eventの直前に
— その `CompositionEvent.data$m 属性を`空~文字列$に設定した上で —
発火されることになる。
◎
If the composition session is canceled, this event will be fired immediately before the compositionend event, and the data attribute will be set to the empty string.
</p>

				</section>
				<section id="event-type-compositionend">
<h5>3.8.7.3. `compositionend^et</h5>

<div>
◎イ型 `compositionend@et
◎界面 `CompositionEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 不可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`各種~組成~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`CompositionEvent.data$m：
組成~sessionの最終的な結果を成す文字列
— ［
内容が削除された／組成~処理nが取消された
］場合、
`空~文字列$になることもある。
</li>
</ul>
◎表終

◎
Type 	compositionend
Interface 	CompositionEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	No
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : focused element processing the composition
• UIEvent.view : Window
• UIEvent.detail : 0
• CompositionEvent.data : the string comprising the final result of the composition session, which MAY be the empty string if the content has been deleted or if the composition process has been canceled
</div>

<p>
~UAは、［
`~text組成~system$が
現在の組成~sessionを
完了した, または取消された
］とき，この~eventを発火するモノトスル。
この~eventは、
~controlが更新された後に配送するモノトスル。
◎
A user agent MUST dispatch this event when a text composition system completes or cancels the current composition session, and the compositionend event MUST be dispatched after the control is updated.
</p>

<p>
この~eventは、
`~text組成~system$が組成~sessionを完了した直後に配送される
（例： `~IME$が［
閉じられた ／
最小~化された ／
~focusが他へ切替えられた ／
その他~退けられた
］後に，~focusが~~元の~UAに切替わったときなど）。
◎
This event is dispatched immediately after the text composition system completes the composition session (e.g., the IME is closed, minimized, switched out of focus, or otherwise dismissed, and the focus switched back to the user agent).
</p>

				</section>
			</section>
			<section id="_common-composition-event-context">
<h4>各種~組成~eventに共通な文脈~情報</h4>

集約簡略化

<p>
多くの組成~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
組成を処理している被focus要素。
~access可能でないならば~NULL。
◎
Event.target : focused element processing the composition, null if not accessible
</dd>

	<dt>`UIEvent!I の各~属性：</dt>
	<dd>
`各種~UI~eventに共通な文脈~情報$を見よ。
</dd>
</dl>

			</section>
		</section>
	</section>
	<section id="keys">
<h2 title="Keyboard events and key values">4. ~keyboard~eventと~UIkey値</h2>

<!-- 
`KeyboardEvent!I
-->

<p>
この節では、
~keyboard~eventに関して必要yな情報を与える：
◎
This section contains necessary information regarding keyboard events:
</p>

<ul>
	<li>
~keyboard~layout,
`~UIkey対応付け$,
`~UIkey値$
についての説明。
◎
Explanation of keyboard layout, mapping, and key values.
</li>
	<li>
`~dead-key$や修飾~UIkeyなどの、
~UIkeyどうしの関係。
◎
Relations between keys, such as dead keys or modifiers keys.
</li>
	<li>
~keyboard~eventとその既定~動作との関係。
◎
Relations between keyboard events and their default actions.
</li>
	<li>
`key^m 値の集合, および
この集合を拡張する方法についての指針。
◎
The set of key values, and guidelines on how to extend this set.
</li>
</ul>

<p class="note">注記：
この節では、
~Serbianと漢字を利用する。
【！which could be misrepresented or unavailable...】
◎
This section uses Serbian and Kanji characters which could be misrepresented or unavailable in the PDF version or printed version of this specification.
</p>

		<section id="keyboard-input">
<h3 title="Keyboard Input">4.1. ~keyboard入力</h3>

◎非規範的

<p>
完全な~keyboardの各~UIkeyの関係性には，次に挙げる別々な側面があり、
いずれも
— 特に，~localeに特有な理由で —
~keyboard機種や環境設定により様々になる：
◎
The relationship of each key to the complete keyboard has three separate aspects, each of which vary among different models and configurations of keyboards, particularly for locale-specific reasons:
</p>

<ul>
	<li>
<strong>物理的0な~layout</strong>：
~keyboard上での物理的な~UIkeyの
寸法, ~size, ~~配置
◎
Mechanical layout: the dimensions, size, and placement of the physical keys on the keyboard
</li>
	<li>
<strong>視覚的な目印</strong>：
各~UIkeyを印字する~label（または `銘^em）
◎
Visual markings: the labels (or legends) that mark each key
</li>
	<li>
<strong>機能上の`~UIkey対応付け$</strong>：
各~UIkey用の抽象的な ~UIkey ↔ 値の結付け。
◎
Functional mapping: the abstract key-value association of each key.
</li>
</ul>

<p>
この仕様は、
<a href="#keys-keyvalues">`key^m 値</a>
および
<a href="#keys-codevalues">`code^m 値</a>
を通して，機能上の`~UIkey対応付け$のみを定義するが、
背景0として，
`~UIkey銘＠#key-legends$についても概括する。
◎
This specification only defines the functional mapping, in terms of key values and code values, but briefly describes key legends for background.
</p>

			<section id="key-legends">
<h4 title="Key Legends">4.1.1. ~UIkey銘</h4>

◎非規範的

<p>
~UIkey銘（ `key legend^en ）とは、
その `~UIkey~cap^em
（~UIkeyの物理的0な~switchを覆う “~cap” ）
上に印刷されたり, 彫り込まれている，視覚的な目印である。
この種の目印は、
通常は，その~UIkeyに対する~keystrokeが生産するような 1 個~以上の文字からなる（例： `G^kGl, `8^kGl, `ш^kGl ）, 
あるいは その~UIkeyの機能を指示する名前や記号
（例： `Shift^cap を指示する上向き矢印 `⇧^kGl, 文字列 "Enter" など）。
~UIkeyは、
この目印で指されることが多い
（例： “ Shift ＋ F ~UIkeyを押してください。” ）。
しかしながら、
~UIkeyの視覚的な見かけは，その~digital表現とは~~関係ないものであり、
多くの環境設定で，まったく正確aでないものにもなり得る。
`Enter^cap などの［
制御~UIkey／~function~UIkey
］であっても，［
機能性が異なるものや文字~UIkey
］に対応付けられることすら あり得る。
◎
The key legend is the visual marking that is printed or embossed on the key cap (the rectangular "cap" that covers the mechanical switch for the key). These markings normally consist of one or more characters that a keystroke on that key will produce (such as "G", "8", or "ш"), or names or symbols which indicate that key’s function (such as an upward-pointing arrow "⇧" indicating Shift, or the string "Enter"). Keys are often referred to by this marking (e.g., "Press the "Shift" and "G" keys."). Note, however, that the visual appearance of the key has no bearing on its digital representation, and in many configurations may be completely inaccurate. Even the control and function keys, such as Enter, may be mapped to different functionality, or even mapped as character keys.
</p>

<p class="note">注記：
多くの~keyboardは、
~Unicode等価な記号があっても，通常は文字を生産しない~UIkeyを備えている。
例えば， `Shift^cap ~UIkeyには、
記号 `⇧^kGl （~Unicode符号位置 `21E7^U ）が付けられることもあるが，
`Shift^cap ~UIkeyだけ押しても この`文字~値$を生産することはないし,
`Shift^cap に対応する~Unicode符号位置もない。
◎
Many keyboards contain keys that do not normally produce any characters, even though the symbol might have a Unicode equivalent. For example, the Shift key might bear the symbol "⇧", which has the Unicode code point U+21E7, but pressing the Shift key will not produce this character value, and there is no Unicode code point for Shift.
</p>
			</section>
		</section>
		<section id="keys-codevalues">
<h3 title="Key codes">4.2. ~UIkey~code</h3>

<p>
~keyboard~eventに結付けられた物理的~UIkeyを識別するときは、
~keyboard~eventの `code$m 属性で指示される~UIkey~codeを利用できる。
それは、
USB Usage ID に類似な, ~vendor中立な, 低~levelな（~scancodeに類似な）値を供する。
◎
A key code is an attribute of a keyboard event that can be used to identify the physical key associated with the keyboard event. It is similar to USB Usage IDs in that it provides a low-level value (similar to a scancode) that is vendor-neutral.
</p>

<p>
`code$m 属性の首~目的は、
~UIkeyを その物理的~所在に基づいて識別するための，首尾一貫する仕方を供することである。
加えて、
~keyboardの各~UIkeyに（現在の~keyboard状態に影響されないような）安定的な名前も供して，それらを一意に識別する。
◎
The primary purpose of the code attribute is to provide a consistent and coherent way to identify keys based on their physical location. In addition, it also provides a stable name (unaffected by the current keyboard state) that uniquely identifies each key on the keyboard.
</p>

<p>
妥当な `code^m 値たちが成す~listは、
`UIEvents-Code$r にて定義される。
◎
The list of valid code values is defined in the [UIEvents-Code].
</p>

			<section id="code-motivation">
<h4 title="Motivation for the code Attribute">4.2.1. `code^m 属性の動機</h4>

<p>
標準的な~PC~keyboardが備えている一群の~UIkeyが生成する `key$m 値は、
利用者が現在~選択している（利用している書記体系に適切な）~keyboard~layoutにより異なる。
このような状況では、
~UIkeyをその物理的~所在に基づいて検出するような~codeを書くことは困難になる
— ~codeが，どの `key^m 値を検査すればよいか知るためには、
現在~有効な~layoutがどれなのかを知る必要があるので。
現実の例として、
~playerの動きを制御するために［
`W^kGl, `A^kGl, `S^kGl, `D^kGl
］~UIkeyを利用する~gameがある。
`code$m 属性は、
それを検査するための，`現在の~keyboard~layoutに影響されない^em, 安定的な値を供して、
この問題を解消する。
◎
The standard PC keyboard has a set of keys (which we refer to as writing system keys) that generate different key values based on the current keyboard layout selected by the user. This situation makes it difficult to write code that detects keys based on their physical location since the code would need to know which layout is in effect in order to know which key values to check for. A real-world example of this is a game that wants to use the "W", "A", "S" and "D" keys to control player movement. The code attribute solves this problem by providing a stable value to check that is not affected by the current keyboard layout.
</p>

<p>
加えて、
`key$m 属性がとる値は，現在の~keyboard状態にも依存する。
このため、
修飾~UIkeyと他の~UIkeyが［
押される／離される
］順序も， `key$m 属性に格納される値に影響し得る。
`code$m 属性は、
`現在の~keyboard~layoutに影響されない^em,
安定的な値を供して、
この問題を解消する。
◎
In addition, the values in the key attribute depend as well on the current keyboard state. Because of this, the order in which keys are pressed and released in relation to modifier keys can affect the values stored in the key attribute. The code attribute solves this problem by providing a stable value that is not affected by the current keyboard state.
</p>
			</section>
			<section id="relationship-between-key-code">
<h4 title="The Relationship Between key and code">4.2.2. `key^m と `code^m の関係性</h4>

<dl>
	<dt>`key^m</dt>
	<dd>
`key$m 属性に意図されている用途は、
押されている~UIkeyの意味に基づくふるまいを得ることである
— その値には、
現在の~keyboard~layoutに加えて，~IMEも織り込まれる
（`~dead-key＠#keys-dead$ には，一意な `key^m 値が与えられる）。
例えば、［
~UIkeyが修飾~UIkeyを伴うかどうかや
~~素の修飾~UIkey
］を検出する利用事例がある
（例：~keyboard~shortcutに呼応して何らかの動作を遂行するためなど）。
◎
The key attribute is intended for users who are interested in the meaning of the key being pressed, taking into account the current keyboard layout (and IME; dead keys are given a unique key value). Example use case: Detecting modified keys or bare modifier keys (e.g., to perform an action in response to a keyboard shortcut).
</dd>

	<dt>`code^m</dt>
	<dd>
`code$m 属性に意図されている用途は、
利用者により押された~UIkeyそのもの
— ~keyboard~layoutにより改変されないままの~UIkey —
に基づくふるまいを得ることである。
例えば、
~gameにおける動き制御~用に［
`W^cap, `A^cap, `S^cap, `D^cap
］~UIkeyを検出したり、
すべての~UIkeyを~trapする
（例： すべての~UIkeyを~remote~hostに送信する~remote~desktop~client）
などの利用事例がある。
◎
The code attribute is intended for users who are interested in the key that was pressed by the user, without any layout modifications applied. Example use case: Detecting WASD keys (e.g., for movement controls in a game) or trapping all keys (e.g., in a remote desktop client to send all keys to the remote host).
</dd>
</dl>

			</section>
			<section id="code-examples">
<h4 title="code Examples">4.2.3. ~code例</h4>

<div class="example">
<p>
左右 Alt ~UIkeyの取扱い：
◎
Handling the Left and Right Alt Keys
</p>

<!-- 
`KeyboardEvent!I
-->

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<th>備考
<tbody>

<tr><td>US
<td>`Alt$kY
<td>`AltLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>~French
<td>`Alt$kY
<td>`AltLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>US
<td>`Alt$kY
<td>`AltRight$kC
<td>`DOM_KEY_LOCATION_RIGHT^m

<tr><td>~French
<td>`AltGraph$kY
<td>`AltRight$kC
<td>`DOM_KEY_LOCATION_RIGHT^m
</table>

<p>
この例は、［
`key$m 属性を検査すれば，左右どちらの `Alt^cap ~UIkeyが押されたか気にせずに `Alt^cap と照合できる
］ことを示している。
`code$m 属性を検査すれば，現在~有効な~layoutが何かを気にすることなく
右 `Alt^cap ~UIkey（ `AltRight$kC ）と照合できるようになる。
◎
In this example, checking the key attribute permits matching Alt without worrying about which Alt key (left or right) was pressed. Checking the code attribute permits matching the right Alt key ("AltRight") without worrying about which layout is currently in effect.
</p>

<p>
~Frenchの例では、［
`Alt^cap ／ `AltGraph^cap
］~UIkeyは どちらも 1 個しかないが，それらの［
左／右
］の所在は維持されることに注意。
◎
Note that, in the French example, the Alt and AltGraph keys retain their left and right location, even though there is only one of each key.
</p>
</div>

<div class="example">
<p>
Single Quote ~UIkeyの取扱い：
◎
Handling the Single Quote Key
</p>

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<tbody>

<tr><td>US
<td>`'^kY
<td>`Quote$kC

<tr><td>日本語
<td>`:^kY
<td>`Quote$kC

<tr><td>US Intl
<td>`Dead$kY
<td>`Quote$kC
</table>

<p>
この例は、
属性において，~dead-key値がどう符号化されるかを示している。
`key^m 値は，現在の~localeに基づいて様々になる一方、
`code$m 属性は，一貫した値を返す。
◎
This example shows how dead key values are encoded in the attributes. The key values vary based on the current locale, whereas the code attribute returns a consistent value.
</p>
</div>

<div class="example" id="example-key-2">

<p>
種々の~keyboard~layoutにおける
`2^kGl ~UIkeyの取扱い
（ Shift も押したとき／押さないとき）：
◎
Handling the "2" Key (with and without Shift pressed) on various keyboard layouts.
</p>

<table class="data-table" style="width:auto"><thead>
<tr><th>Keyboard Layout
<th>`key$m
<th>`code$m
<th>Shift の有無
<tbody>

<tr><td>US
<td>`2^kY
<td>`Digit2$kC
<td>

<tr><td>US
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>UK
<td>`2^kY
<td>`Digit2$kC
<td>

<tr><td>UK
<td>`"^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>~French
<td>`é^kY
<td>`Digit2$kC
<td>

<tr><td>~French
<td>`2^kY
<td>`Digit2$kC
<td>`shiftKey$m
</table>

<p>
現在の~localeや修飾~UIkey状態に関わらず，
~US~keyboardで~UIkey `2^kGl の~UIkeyを押したときの `code$m 属性の結果は、
常に `Digit2$kC になる。
◎
Regardless of the current locale or the modifier key state, pressing the key labelled "2" on a US keyboard always results in "Digit2" in the code attribute.
</p>
</div>

<div class="example" id="example-key-shift-2">

<p>
~keyboard~event連列：
`Shift^cap ＆ `2^cap
◎
Sequence of Keyboard Events : Shift and 2
</p>

<p>
次では、
2 つの~UIkey~event連列における属性~値を比較する。
それらは いずれも
~US~keyboardでは 文字 `~aT^kGl を生産するが、
~UIkeyが離される順序により相違する。
最初の例の連列の順序は：
`Shift^cap （押） →
`2^cap （押） →
`2^cap（離） →
`Shift^cap（離）。
◎
Compare the attribute values in the following two key event sequences. They both produce the "@" character on a US keyboard, but differ in the order in which the keys are released. In the first sequence, the order is: Shift (down), 2 (down), 2 (up), Shift (up).
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`code$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>2.
<td>`keydown$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>3.
<td>`keypress$et
<td>`~aT^kY
<td>`Digit2$kC
<td>（~support有りなら）

<tr><td>4.
<td>`keyup$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m
</table>

<p>
次の例の連列は、
2 を離すより先に Shift を離した場合：
`Shift^cap（押） →
`2^cap（押） →
`Shift^cap（離） →
`2^cap（離）。
◎
In the second sequence, the Shift is released before the 2, resulting in the following event order: Shift (down), 2 (down), Shift (up), 2 (up).
</p>

<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`code$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>2.
<td>`keydown$et
<td>`~aT^kY
<td>`Digit2$kC
<td>`shiftKey$m

<tr><td>3.
<td>`keypress$et
<td>`~aT^kY
<td>`Digit2$kC
<td>（~support有りなら）

<tr><td>4.
<td>`keyup$et
<td>`Shift$kY
<td>`ShiftLeft$kC
<td>`DOM_KEY_LOCATION_LEFT^m

<tr><td>5.
<td>`keyup$et
<td>`2^kY
<td>`Digit2$kC
<td>
</table>

<p>
~UIkey `2^kGl については、
`key$m 属性の値が
`keydown$et ~eventと `keyup$et ~eventとの間で合致しないことに注意。
`code$m 属性は、
現在の修飾~状態に影響されず，一貫した値を供する。
◎
Note that the values contained in the key attribute does not match between the keydown and keyup events for the "2" key. The code attribute provides a consistent value that is not affected by the current modifier state.
</p>
</div>

			</section>
			<section id="code-virtual-keyboards">
<h4 title="code and Virtual Keyboards">4.2.4. `code^m と~virtual~keyboard</h4>
<p>
`code$m 属性の有用性は、
~virtual~keyboardに対しては明白でない
（~remote-control~keyboardや複数~UIkeyの同時押下げに対しても）。
~virtual（または~remote-control）~keyboardに対しては、
標準的な~keyboardの
~layout／機能性
を真似ているものについては，
`code$m 属性を適切に設定するモノトスル。
真似ていない~keyboardについては、
標準的な~keyboardになるべく近いものに設定するか, または
未定義なままにしてもヨイ。
◎
The usefulness of the code attribute is less obvious for virtual keyboards (and also for remote controls and chording keyboards). In general, if a virtual (or remote control) keyboard is mimicking the layout and functionality of a standard keyboard, then it MUST also set the code attribute as appropriate. For keyboards which are not mimicking the layout of a standard keyboard, then the code attribute MAY be set to the closest match on a standard keyboard or it MAY be left undefined.
</p>

<p>
修飾~状態に基づいて異なる値を生産する~UIkeyを伴うような~virtual~keyboardに対しては、
`code^m 値は，［
装置がその工場出荷~状態にある下で~buttonが押された
］ときに生成される `key^m 値になるベキである。
◎
For virtual keyboards with keys that produce different values based on some modifier state, the code value should be the key value generated when the button is pressed while the device is in its factory-reset state.
</p>

			</section>
		</section>
		<section id="keys-keyvalues">
<h3 title="Keyboard Event key Values">4.3. ~keyboard~eventの `key^m 値</h3>

<div class="p">
<p>
`~UIkey値$は、
~keyboard上の任意の~UIkeyを
— その位置や状態に関わらず —
それが生産する値で指示するために利用できる `DOMString^I である。
これらの~UIkey値は、
次に挙げるものに利用できる／され得る：
</p>
<ul>
	<li>
実装により生成される~keyboard~event用の返り値
</li>
	<li>
内容~作者から欲される入力（~keyboard~shortcutなど）を指定するための入力~値
</li>
</ul>
◎
A key value is a DOMString that can be used to indicate any given key on a keyboard, regardless of position or state, by the value it produces. These key values MAY be used as return values for keyboard events generated by the implementation, or as input values by the content author to specify desired input (such as for keyboard shortcuts).
</div>

<p>
妥当な `key^m 値たちが成す~listは `UIEvents-Key$r にて定義される。
◎
The list of valid key values is defined in [UIEvents-Key].
</p>

<p>
`~UIkey値$は、
`key$m 属性を利用して，押された~UIkeyの値を検出するときに利用される値である。
内容~作者は、［
大文字や小文字, 数字n, 記号
］その他，文字を生産する~UIkeyに対しては その`文字~値$を検索取得でき、［
制御~UIkey, 修飾~UIkey, ~function~UIkey
］その他，文字を生産しない~UIkeyに対しては その`~UIkey値$を検索取得できる。
これらの値は、［
特定0の入力~文字列を監視する ／
他の入力（~mouseなど）との組合nで 修飾~UIkey入力を検出して動作する ／
~virtual~keyboardを作成する
］その他，いくつもの目的に利用できる。
◎
Key values can be used to detect the value of a key which has been pressed, using the key attribute. Content authors can retrieve the character value of upper- or lower-case letters, number, symbols, or other character-producing keys, and also the key value of control keys, modifier keys, function keys, or other keys that do not generate characters. These values can be used for monitoring particular input strings, for detecting and acting on modifier key input in combination with other inputs (such as a mouse), for creating virtual keyboards, or for any number of other purposes.
</p>

<p>
内容~作者は、
`~UIkey値$を文字列~比較にも利用できる
—
適合`~host言語$における~markup属性~用の値（~HTMLの `accesskey^a など）として, あるいは
他の関係する目的に。
適合`~host言語$は、
`~UIkey値$用の 2 つの等価な文字列~値
— `文字~値$, `~UIkey値$ —
どちらも利用できることを内容~作者に許容するベキである。
◎
Key values can also be used by content authors in string comparisons, as values for markup attributes (such as the HTML accesskey) in conforming host languages, or for other related purposes. A conforming host language SHOULD allow content authors to use either of the two equivalent string values for a key value: the character value, or the key value.
</p>

<p class="note">注記：
実装は、
所与の~UIkey用に
— ~platformや~keyboard~layout用の`~UIkey対応付け$からは独立に —
最も関連な値を利用することになる一方、
内容~作者は，それらを生成する~keyboard装置の能について前提を置けない。
内容~作者は、
~shortcut~UIkeyの組合nとして~keyboard~eventと~UIkey値を利用するときには，普通字の代わりに
数字n~UIkey, ~function~UIkey（ `F4^cap, `F5^cap, 等々）の利用も考慮できる（ `DWW95$r ）
— ほとんどの~keyboard~layoutは，それら用の~UIkeyを供するので。
◎
While implementations will use the most relevant value for a key independently of the platform or keyboard layout mappings, content authors can not make assumptions on the ability of keyboard devices to generate them. When using keyboard events and key values for shortcut-key combinations, content authors can "consider using numbers and function keys (F4, F5, and so on) instead of letters" ([DWW95]) given that most keyboard layouts will provide keys for those.
</p>

<p>
`~UIkey値$は、
物理的な~keyboard上の特定の~UIkeyを指示するものでも，
~UIkey上に印刷された文字を反映するものでもない。
~UIkey値は、
作動中な［
~UIkeyすべて／~UIkey入力~mode（~shift~modeを含む）の現在の状態
］が考慮に入れられ，~OSによる~keyboard用の`~UIkey対応付け$に反映され, 実装に報告されるような，~eventの現在の値を指示する。
例えば、［
`QWERTY$ ~keyboardの `O^cap ~UIkey
］の~UIkey値は，［
~shiftなしなら `o^kY ／
~shiftありなら `O^kY
］になる。
利用者は，自身の~keyboardを任意な~custom環境設定に対応付けれるので、
内容~作者には，［
~UIkeyの~shiftの有無と, 文字~表現の［
大文字形, 小文字形
］との間に関係性が存在する
］ものと見做すことなく， `key$m 属性の値を利用することが奨励される。
例えば、
`D3E-code$r にて図面化されている標準的な “102 ~keyboard” ~layoutは、
あるアリな~keyboard~layoutにおける，`~UIkey対応付け$が成す集合としてアリな一つを図示する。
他にも、
標準なもの, 独特なものが多数 存在する。
◎
A key value does not indicate a specific key on the physical keyboard, nor does it reflect the character printed on the key. A key value indicates the current value of the event with consideration to the current state of all active keys and key input modes (including shift modes), as reflected in the operating-system mapping of the keyboard and reported to the implementation. In other words, the key value for the key labeled O on a QWERTY keyboard has the key value "o" in an unshifted state and "O" in a shifted state. Because a user can map their keyboard to an arbitrary custom configuration, the content author is encouraged not to assume that a relationship exists between the shifted and unshifted states of a key and the majuscule form (uppercase or capital letters) and minuscule form (lowercase or small letters) of a character representation, but is encouraged instead to use the value of the key attribute. For example, the Standard "102" Keyboard layout depicted in [UIEvents-Code] illustrates one possible set of key mappings on one possible keyboard layout. Many others exist, both standard and idiosyncratic.
</p>

<p class="note">注記：
`~dead-key$用の~supportを単純~化するため、
~OSによる~keyboard用の`~UIkey対応付け$が`~dead-key$状態を取扱うとき，
~dead-key連列の現在の状態は `key$m 属性を介しては報告されず，
代わりに`~UIkey値$ `Dead$kY が報告される。
実装は、
代わりに［
~dead-key連列の中間的な状態を包含する，一連の`組成~event$
］を生成して，それを `CompositionEvent.data$m 属性を介して報告する。
前掲の例と同様に，［
`QWERTY$ ~keyboardの `O^cap と印字された~UIkey用の`~UIkey値$には，
~dead-key操作oの最中に~umlaut発音区別符が追加される
］ので、
`CompositionEvent.data$m 値は，
~shiftなしなら `ö^kGl になり,
~shiftありなら `Ö^kGl になる。
◎
To simplify dead key support, when the operating-system mapping of the keyboard is handling a dead key state, the current state of the dead key sequence is not reported via the key attribute. Rather, a key value of "Dead" is reported. Instead, implementations generate composition events which contain the intermediate state of the dead key sequence reported via the data attribute. As in the previous example, the key value for the key marked O on a QWERTY keyboard has a data value of "ö" in an unshifted state during a dead-key operation to add an umlaut diacritic, and "Ö" in a shifted state during a dead-key operation to add an umlaut diacritic.
</p>

<p>
また、
~UIkey~eventの各~状態と各`~UIkey値$との間には，
一対一の関係性はないことにも特に注意。
複数の~UIkeyが特定0の~UIkey値に結付けられることもある。
例えば，多くの標準的な~keyboardは、
`Shift^cap ~UIkeyや `8^cap ~UIkeyを複数~備えている
（通常は、
いずれも `location$m 値で判別される
— 前者は［
`DOM_KEY_LOCATION_LEFT$m ／ `DOM_KEY_LOCATION_RIGHT$m
］で，後者は［
`DOM_KEY_LOCATION_STANDARD$m ／ `DOM_KEY_LOCATION_NUMPAD$m
］で）。
また，利用者により環境設定された~custom~keyboard~layoutは、
どの~UIkey値にも複数の~UIkey状態が対応~付けられ得る
（ `location$m は、
標準的な~keyboard~layout~~用途に意図されていることに注意
— 有意義な~~区別を常に指示できるわけではない）。
◎
It is also important to note that there is not a one-to-one relationship between key event states and key values. A particular key value might be associated with multiple keys. For example, many standard keyboards contain more than one key with the Shift key value (normally distinguished by the location values DOM_KEY_LOCATION_LEFT and DOM_KEY_LOCATION_RIGHT) or 8 key value (normally distinguished by the location values DOM_KEY_LOCATION_STANDARD and DOM_KEY_LOCATION_NUMPAD), and user-configured custom keyboard layouts MAY duplicate any key value in multiple key-state scenarios (note that location is intended for standard keyboard layouts, and cannot always indicate a meaningful distinction).
</p>

<p>
~~最後に、
与えられた文字~表現の意味は，文脈に依存する上に複階的である。
例えば，一部の文脈では、
~asterisk~glyph（ `*^kGl ）は，脚注や強勢を表現する
（~textの一節を~~括るとき）。
しかしながら，［
それ／その機能
］は、
文書や実行-可能な~programによっては，
数学的な乗算に等価であることも,
乗算~記号（ `×^kGl, ~Unicode `00D7^U ）として予約-済みなことも,
~~英小文字 "x" （ `Latin small letter x^cn ）であることもある
（多くの~keyboardが乗算~UIkeyを欠くこと，あるいは `×^kGl と `x^kGl のような~glyphの~~外見上の~~類似に因り）。
したがって、［
意味論上の意味, 文字~表現の機能
］は，この仕様の視野から外れる。
◎
Finally, the meaning of any given character representation is context-dependent and complex. For example, in some contexts, the asterisk (star) glyph ("*") represents a footnote or emphasis (when bracketing a passage of text). However, in some documents or executable programs it is equivalent to the mathematical multiplication operation, while in other documents or executable programs, that function is reserved for the multiplication symbol ("×", Unicode value U+00D7) or the Latin small letter "x" (due to the lack of a multiplication key on many keyboards and the superficial resemblance of the glyphs "×" and "x"). Thus, the semantic meaning or function of character representations is outside the scope of this specification.
</p>

			<section id="keys-modifiers">
<h4 title="Modifier keys">4.3.1. 修飾~UIkey</h4>

<p>
修飾~UIkeyを利用する~keyboard入力は、
~UIkeyの通常の挙動を変化させる。
他の~UIkeyと同様、
修飾~UIkeyは，下の例に示すとおり［
`keydown$et ／ `keyup$et
］~eventを生成する。
修飾~UIkeyには、
押されている間 作動化されるものもあれば
（
`Alt^cap,
`Control^cap,
`Shift^cap,
`AltGraph^cap,
`Meta^cap
など）、
状態を持ち，その状態に依存して作動化されるものもある
（
`CapsLock^cap,
`NumLock^cap,
`ScrollLock^cap
など）。
状態の変化は、
修飾~UIkeyが押されたときに起こる。
`KeyboardEvent!I ~interfaceは、
一部の共通的な修飾~UIkeyに対し，簡便な属性
— `ctrlKey$m, `shiftKey$m, `altKey$m, `metaKey$m —
を供する。
一部の~OSは、
修飾~UIkey `AltGraph^cap を，修飾~UIkey `Alt^cap, `Control^cap の組合nで模造する。
実装には、
`AltGraph^cap 修飾~UIkeyを利用することが奨励される。
◎
Keyboard input uses modifier keys to change the normal behavior of a key. Like other keys, modifier keys generate keydown and keyup events, as shown in the example below. Some modifiers are activated while the key is being pressed down or maintained pressed such as Alt, Control, Shift, AltGraph, or Meta. Other modifiers are activated depending on their state such as CapsLock, NumLock, or ScrollLock. Change in the state happens when the modifier key is being pressed down. The KeyboardEvent interface provides convenient attributes for some common modifiers keys: ctrlKey, shiftKey, altKey, metaKey. Some operating systems simulate the AltGraph modifier key with the combination of the Alt and Control modifier keys. Implementations are encouraged to use the AltGraph modifier key.
</p>

<p>
次の例に、
~US~keyboardで, ~US用の`~UIkey対応付け$を利用している下で，
~Unicode文字 Q（ `0051^U `Latin Capital Letter Q^cn ）
が生成されるときにアリな~event連列を述べる：
◎
This example describes a possible sequence of events associated with the generation of the Unicode character Q (Latin Capital Letter Q, Unicode code point U+0051) on a US keyboard using a US mapping:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>`shiftKey$m
<td>`Latin Capital Letter Q^cn

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Q^kY
<td>`shiftKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
</table>
</div>

<p>
次の例に、
上の例において， `Q^cap ~UIkeyを離す前に `Shift^cap ~UIkeyを離したとき，
代わりに生じ得る~UIkey連列を述べる。
~UIkey `Q^cap 用の`~UIkey値$は、
`keyup$et ~eventに対しては，その無shift値に復帰することになる：
◎
Th example describes an alternate sequence of keys to the example above, where the Shift key is released before the Q key. The key value for the Q key will revert to its unshifted value for the keyup event:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>`shiftKey$m
<td>`Latin Capital Letter Q^cn

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`q^kY
<td>
<td>`Latin Small Letter Q^cn
</table>
</div>

<p>
次の例に、
~Unicode文字を生成しないときにアリな~UIkeyの連列を述べる
（前の例と同じ環境設定の下で）:
◎
The following example describes a possible sequence of keys that does not generate a Unicode character (using the same configuration as the previous example):
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`v^kY
<td>`ctrlKey$m
<td>`Latin Small Letter V^cn

<tr><td>
<td colspan="4"><em>
`beforeinput$et／`input$et
~eventは生成されない。
</em>
◎
No beforeinput or input events are generated.

<tr><td>3.
<td>`keyup$et
<td>`v^kY
<td>`ctrlKey$m
<td>`Latin Small Letter V^cn

<tr><td>4.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</table>
</div>

<p>
次の例に，
`Shift^cap, `Control^cap が両者とも押されたときの~event連列を示す：
◎
The following example shows the sequence of events when both Shift and Control are pressed:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Shift$kY
<td>`ctrlKey$m, `shiftKey$m
<td>

<tr><td>3.
<td>`keydown$et
<td>`V^kY
<td>`ctrlKey$m, `shiftKey$m
<td>`Latin Capital Letter V^cn

<tr><td>
<td colspan="4"><em>
【！複製】
`beforeinput$et／`input$et
~eventは生成されない。
</em>
◎
No beforeinput or input events are generated.

<tr><td>4.
<td>`keyup$et
<td>`V^kY
<td>`ctrlKey$m, `shiftKey$m
<td>`Latin Capital Letter V^cn

<tr><td>5.
<td>`keyup$et
<td>`Shift$kY
<td>`ctrlKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</table>
</div>

<p>
非~US~keyboard~layoutに対しても，~event連列は同じになるが、
~UIkeyの値は，現在の~keyboard~layoutに基づく。
次の例に，~Arabic~keyboard~layoutが利用されるときの~event連列を示す：
◎
For non-US keyboard layouts, the sequence of events is the same, but the value of the key is based on the current keyboard layout. This example shows a sequence of events when an Arabic keyboard layout is used:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Control$kY
<td>`ctrlKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`&#x631;^kY
<td>`ctrlKey$m
<td>`Arabic Letter Reh^cn

<tr><td>
<td colspan="4">
【！複製】
`beforeinput$et／`input$et
~eventは生成されない。
◎
No beforeinput or input events are generated.

<tr><td>3.
<td>`keyup$et
<td>`&#x631;^kY
<td>`ctrlKey$m
<td>`Arabic Letter Reh^cn

<tr><td>4.
<td>`keyup$et
<td>`Control$kY
<td>
<td>
</table>
</div>

<p class="note">注記：
［
`keydown$et ／ `keyup$et
］~eventにおける値は、
~UIkeyが押されたときに有効な現在の~keyboard~layoutに基づいて，様々になる。
これは、
同じ物理的~UIkeyであっても、
~US~layout上の `v^cap ~UIkey と ~Arabic~layout上の `&#x631;^cap ~UIkeyとでは，
異なる~eventを生成することを意味する。
これらの~eventを同じ物理的~UIkeyとして識別するためには、
`code$m 属性を利用する必要がある。
◎
The value in the keydown and keyup events varies based on the current keyboard layout in effect when the key is pressed. This means that the v key on a US layout and the ر key on an Arabic layout will generate different events even though they are the same physical key. To identify these events as coming from the same physical key, you will need to make use of the code attribute.
</p>

<p>
修飾~UIkeyが，~UIkey~event用の`~UIkey値$を変化させる事例もある。
例えば，一部の MacOS ~keyboard上の “delete” ~UIkeyは、
未修飾~時にはWindows ~OS上の `Backspace^cap ~UIkeyと同じに機能するが、
`Fn^cap ~UIkeyで修飾されたときは `Delete^cap ~UIkeyとして動作し，
~UIkey値は 現在の修飾された状態に最も適切な~UIkeyの機能に合致することになる。
◎
In some cases, modifier keys change the key value for a key event. For example, on some MacOS keyboards, the key labeled "delete" functions the same as the Backspace key on the Windows OS when unmodified, but when modified by the Fn key, acts as the Delete key, and the value of key will match the most appropriate function of the key in its current modified state.
</p>

			</section>
			<section id="keys-dead">
<h4 title="Dead keys">4.3.2. ~dead-key</h4>

<p>
~keyboard入力では、
`~dead-key$を利用して組成-済み文字~連列を入力することもある。
手書き式に最初に基底~文字を手入力するのでなく、
そこでの~keyboard入力には，特別な状態に入ることが要求され、
`~dead-key$が押された~~直後では，限られた数の “合法な” 基底~文字が手入力されたときに限り，文字（たち）を発する。
◎
Some keyboard input uses dead keys for the input of composed character sequences. Unlike the handwriting sequence, in which users enter the base character first, keyboard input requires to enter a special state when a dead key is pressed and emit the character(s) only when one of a limited number of "legal" base character is entered.
</p>

<p class="note">注記：
［
MacOS ／ Linux ~OS
］は、
`~dead-key$を処理するときに~IMEを利用する。
◎
The MacOS and Linux operating systems use input methods to process dead keys.
</p>

<p>
`~dead-key$は、
（すべての~keyboard~layout, `~UIkey対応付け$に渡り，）
`~UIkey値$ `Dead$kY で表現される。
~dead-keyが押されたときは、
~UAは それに呼応して，`組成~event$たちを発火するモノトスル。
加えて、
その
`compositionupdate$et ~eventの `CompositionEvent.data$m 値は，~dead-key結合~連列の現在の状態の`文字~値$になるモノトスル。
◎
The dead keys (across all keyboard layouts and mappings) are represented by the key value Dead. In response to any dead key press, composition events must be dispatched by the user agent and the compositionupdate event’s data value must be the character value of the current state of the dead key combining sequence.
</p>

<p>
~Unicode結合~文字は，常に［
対応する普通字とそれに続く結合~文字による手書き連列
］に倣う一方で、
代表的な~dead-key入力では，その結合~文字が対応する普通字の前に来るように連列を逆順にすることもある。
例えば，単語 "naïve" は、
結合~発音区別符 "¨" を利用して，~Unicodeでは
"nai¨ve"
として連列的に表現されるが、
"na¨ive" と打込まれ得る。
~keystroke連列［
`0302^U （ `Combining Circumflex Accent^cn ~UIkey）,
`0065^U （ `Latin Small Letter E^cn と印字される~UIkey）
］は，［
`NFC^em （ `Unicode Normalization Form^en ）に選好される ~Unicode文字
`ê^kGl （ `Latin Small Letter E With Circumflex^cn ）
］を生産するであろう
（~French~keyboardでは、
修飾~UIkeyを作動化させずに，~French用の`~UIkey対応付け$を利用して）。
◎
While Unicode combining characters always follow the handwriting sequence, with the combining character trailing the corresponding letter, typical dead key input MAY reverse the sequence, with the combining character before the corresponding letter. For example, the word naïve, using the combining diacritic ¨, would be represented sequentially in Unicode as nai¨ve, but MAY be typed na¨ive. The sequence of keystrokes U+0302 (Combining Circumflex Accent key) and U+0065 (key marked with the Latin Small Letter E) will likely produce (on a French keyboard using a french mapping and without any modifier activated) the Unicode character "ê" (Latin Small Letter E With Circumflex), as preferred by the Unicode Normalization Form NFC.
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>~F
<td>
<td>`Combining Circumflex Accent^cn （~dead-key）

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`0302^U
<td>

<tr><td>4.
<td>`keyup$et
<td>`Dead$kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`ê^kY
<td>~T
<td>
<td>

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`ê^kGl
<td>

<tr><td>7.
<td>`compositionend$et
<td>
<td>
<td>`ê^kGl
<td>

<tr><td>8.
<td>`keyup$et
<td>`e^kY
<td>~F
<td>
<td>`Latin Small Letter E^cn
</table>
</div>

<p class="note">注記：
2 個目の `keydown^c ~event（段 5）では、
（~eventは抑止されていないとするとき，）
通常の状況下では`~UIkey値$ `e^kY （ `Latin Small Letter E^cn ~UIkey）`にはならない^em
— ~UAに送達される値は、
すでに~dead-key操作oにより修飾されることになるので。
◎
In the second keydown event (step 5), the key value (assuming the event is not suppressed) will not be "e" (Latin Small Letter E key) under normal circumstances because the value delivered to the user agent will already be modified by the dead key operation.
</p>

<p>
この処理nは、
利用者が［
`~dead-key$を押した後に，
~supportされない基底~文字
（すなわち，作動中な発音区別符号が可用でない基底~文字）
を打込んだとき
］には，中止され得る：
◎
This process might be aborted when a user types an unsupported base character (that is, a base character for which the active diacritical mark is not available) after pressing a dead key:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>~F
<td>
<td>`Combining Circumflex Accent^cn （~dead-key）

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`0302^U
<td>

<tr><td>4.
<td>`keyup$et
<td>`Dead$kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`q^kY
<td>~T
<td>
<td>`Latin Small Letter Q^cn

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>7.
<td>`compositionend$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>8.
<td>`keyup$et
<td>`q^kY
<td>~F
<td>
<td>
</table>
</div>

			</section>
			<section id="keys-IME">
<h4 title="Input Method Editors">4.3.3. ~IME（ `Input Method Editors^en ）</h4>

<p>
この仕様は、
`CompositionEvent$I ~interface＆~event
を通して，`~IME$（ `Input Method Editor^en ）用の~modelを含めている。
しかしながら、
`組成~event$と`~keyboard~event$を一対一に対応付けるとは限らない。
例として、
`~UIkey値$ `Accept^cap を伴う `keydown$et を受取ったとしても，それは、
`~IME$において現在~選択された~textが受容されたことを含意するとは限らず，~keystrokeが起きたことのみを指示する
— 受容されている`~IME$の機能性からは切離されて
（それは、
ほとんどの`~IME$~systemにおいては，
通常は `compositionend$et ~eventを生じさせることになるが）。
~keyboard~eventは、
~IMEの現在の状態を決定する用途には，利用できない
— その状態は `CompositionEvent.data$m 属性を通して得することができる。
加えて、
`~IME$~systemや装置の機能性は様々であり、
その機能性を作動化するために，どの~UIkey
— `Convert^cap ／ `Accept^cap ~UIkeyなど —
が利用されているかは、
他の可用な~UIkeyにより表現されることもある。
~keyboard~eventは、
~keyboard~layout用の`~UIkey対応付け$の後に，入力~装置により生成された~eventに対応する。
◎
This specification includes a model for input method editors (IMEs), through the CompositionEvent interface and events. However, Composition Events and Keyboard Events do not necessarily map as a one-to-one relationship. As an example, receiving a keydown for the Accept key value does not necessarily imply that the text currently selected in the IME is being accepted, but indicates only that a keystroke happened, disconnected from the IME Accept functionality (which would normally result in a compositionend event in most IME systems). Keyboard events cannot be used to determine the current state of the input method editor, which can be obtained through the data attribute of the CompositionEvent interface. Additionally, IME systems and devices vary in their functionality, and in which keys are used for activating that functionality, such that the Convert and Accept keys MAY be represented by other available keys. Keyboard events correspond to the events generated by the input device after the keyboard layout mapping.
</p>

<p class="note">注記：
一部の実装／~system環境設定においては、
一部の~UIkey~eventやその値は，利用-中にある`~IME$により抑止されることがある。
◎
In some implementations or system configurations, some key events, or their values, might be suppressed by the IME in use.
</p>

<p>
次の例に、
日本語~IMEを利用して，
~Unicode文字 `~~市^kGl
（ `CJK Unified Ideographs^en の一部である漢字 ）
が生成されるときにアリな~UIkey連列を述べる。
この例では、
~IMEは作動化されていて，日本語~Romaji入力~mode下にあるとする。
~UIkey
`Convert^cap （ “~~変換” ）／ `Accept^cap （ “~~確定” ）
は、
利用-中にある入力~装置や~IMEの環境設定に依存して，他に置換されることもある
— 例えば
`~SPACEBAR^cap （ `0020^U ）／ `Enter^cap
にもなり得る。
◎
The following example describes a possible sequence of keys to generate the Unicode character "市" (Kanji character, part of CJK Unified Ideographs) using Japanese input methods. This example assumes that the input method editor is activated and in the Japanese-Romaji input mode. The keys Convert and Accept MAY be replaced by others depending on the input device in use and the configuration of the IME, e.g., it can be respectively U+0020 (Space key) and Enter.
</p>

<p class="note">注記：
`~~詩^kGl と `~~市^kGl は異形同音異義語であり，
いずれも “し” と発音されるので、
利用者は，
`Convert^cap ~UIkeyを利用して 適正な選択肢を選択する必要がある。
◎
"詩" ("poem") and "市" ("city") are homophones, both pronounced し ("shi"/"si"), so the user needs to use the Convert key to select the proper option.
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`s^kY
<td>~F
<td>
<td>`Latin Small Letter S^cn

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>4.
<td>`compositionupdate$et
<td>
<td>
<td>`s^kGl
<td>

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>5.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`s^kY
<td>~T
<td>
<td>

<tr><td>7.
<td>`keydown$et
<td>`i^kY
<td>~T
<td>
<td>`Latin Small Letter I^cn

<tr><td>8.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>9.
<td>`compositionupdate$et
<td>
<td>
<td>`し^kGl
<td>
◎
shi

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>10.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>11.
<td>`keyup$et
<td>`i^kY
<td>~T
<td>
<td>

<tr><td>12.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>13.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>14.
<td>`compositionupdate$et
<td>
<td>
<td>`詩^kGl
<td>
◎
"poem"

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>15.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>16.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>17.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>18.
<td>`beforeinput$et
<td>
<td>
<td>
<td>

<tr><td>19.
<td>`compositionupdate$et
<td>
<td>
<td>`市^kGl
<td>
◎
"city"

<tr><td>
<td>
<td>
<td>
<td>
<td>~DOMは更新された
◎
DOM is updated

<tr><td>20.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>21.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>22.
<td>`keydown$et
<td>`Accept$kY
<td>~T
<td>
<td>“~~確定”
◎
Accept

<tr><td>23.
<td>`compositionend$et
<td>
<td>
<td>`市^kGl
<td>

<tr><td>24.
<td>`keyup$et
<td>`Accept$kY
<td>~F
<td>
<td>
</table>
</div>

<p>
~IME組成は、
前掲の例と一致する条件で，次の例のとおり取消され得る。
~UIkey `Cancel^cap も利用-中にある入力~装置や~IMEの環境設定に依存して，他に置換され得る
— 例えば `001B^U （ `Escape^cap ~UIkey ）にもなり得る。
◎
IME composition can also be canceled as in the following example, with conditions identical to the previous example. The key 'Cancel' might also be replaced by others depending on the input device in use and the configuration of the IME, e.g., it could be U+001B (Escape key).
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`isComposing$m
<th>`CompositionEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`s^kY
<td>~F
<td>
<td>`Latin Small Letter S^cn

<tr><td>2.
<td>`compositionstart$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>3.
<td>`compositionupdate$et
<td>
<td>
<td>`s^kGl
<td>

<tr><td>4.
<td>`keyup$et
<td>`s^kY
<td>~T
<td>
<td>

<tr><td>5.
<td>`keydown$et
<td>`i^kY
<td>~T
<td>
<td>`Latin Small Letter I^cn

<tr><td>6.
<td>`compositionupdate$et
<td>
<td>
<td>`し^kGl
<td>

<tr><td>7.
<td>`keyup$et
<td>`i^kY
<td>~T
<td>
<td>

<tr><td>8.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>9.
<td>`compositionupdate$et
<td>
<td>
<td>`詩^kGl
<td>

<tr><td>10.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>11.
<td>`keydown$et
<td>`Convert$kY
<td>~T
<td>
<td>“~~変換”
◎
Convert

<tr><td>12.
<td>`compositionupdate$et
<td>
<td>
<td>`市^kGl
<td>

<tr><td>13.
<td>`keyup$et
<td>`Convert$kY
<td>~T
<td>
<td>

<tr><td>14.
<td>`keydown$et
<td>`Cancel$kY
<td>~T
<td>
<td>“~~取消”
◎
Cancel

<tr><td>15.
<td>`compositionupdate$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>16.
<td>`compositionend$et
<td>
<td>
<td>`^kGl
<td>

<tr><td>17.
<td>`keyup$et
<td>`Cancel$kY
<td>~F
<td>
<td>
</table>
</div>

<p class="note">注記：
`~IME$（ MacOS ~OS上など）によっては、
組成を取消す前に組成~data属性に`空~文字列$を設定するものもある。
◎
Some input method editors (such as on the MacOS operating system) might set an empty string to the composition data attribute before canceling a composition.
</p>

				<section id="keys-IME-keys">
<h5 title="Input Method Editor mode keys">4.3.3.1. ~IME~mode~UIkey</h5>

<p>
ある種の装置では、
一部の~UIkeyに，［
`~IME$を作動化したり, 作動中な`~IME$の~modeを変更する
］ような機能性が意図されている。
これを目的とする~UIkeyは、
装置や言語~modeごとに異なるものが定義され得る。
この仕様では、
次に挙げるものが，これを目的とする~UIkeyとして定義される
⇒＃
`Alphanumeric$kY,
`CodeInput$kY,
`FinalMode$kY,
`HangulMode$kY,
`HanjaMode$kY,
`Hiragana$kY,
`JunjaMode$kY,
`KanaMode$kY,
`KanjiMode$kY,
`Katakana$kY,
`Romaji$kY
◎
Some keys on certain devices are intended to activate input method editor functionality, or to change the mode of an active input method editor. Custom keys for this purpose can be defined for different devices or language modes. The keys defined in this specification for this purpose are: "Alphanumeric", "CodeInput", "FinalMode", "HangulMode", "HanjaMode", "Hiragana", "JunjaMode", "KanaMode", "KanjiMode", "Katakana", and "Romaji".＼
</p>

<p>
`~IME$が作動中でない下で，これらいずれかの~UIkeyが押されたときは、
（可用なら）適切な`~IME$が，~UIkeyにより指示される~modeで作動化されるものと期待される。
~UIkeyが押されたとき，`~IME$がすでに作動中である場合、［
装置／~app
］に特有なふるまいに基づいて，`~IME$が 指示された~modeへ変更されたり,
異なる`~IME$が立上げられたり, あるいは無視されることもある。
◎
When one of these keys is pressed, and no IME is currently active, the appropriate IME is expected to be activated in the mode indicated by the key (if available). If an IME is already active when the key is pressed, the active IME might change to the indicated mode, or a different IME might be launched, or the might MAY be ignored, on a device- and application-specific basis.
</p>

<p>
この仕様は、
他の~UIkey
— 特定的には、
次に挙げる`~IME$に意図される操作o用の~UIkey —
も定義する
⇒＃
`Accept$kY,
`AllCandidates$kY,
`Cancel$kY,
`Convert$kY,
`Compose$kY,
`Zenkaku$kY （ `FullWidth^en ）,
`Hankaku$kY （ `HalfWidth^en ）,
`NextCandidate$kY,
`NonConvert$kY,
`PreviousCandidate$kY
◎
This specification also defines other keys which are intended for operation specifically with input method editors: "Accept", "AllCandidates", "Cancel", "Convert", "Compose", "Zenkaku" (FullWidth), "Hankaku" (HalfWidth), "NextCandidate", "NonConvert", and "PreviousCandidate".＼
</p>

<p>
これらの~UIkeyの機能は、
この仕様では定義されない
— `~IME$機能性についての詳細は、
他の資料を見よ。
◎
The functions of these keys are not defined in this specification — refer to other resources for details on input method editor functionality.
</p>

<p class="note">注記：
`~IME$機能を伴う~UIkeyは、
その目的に制約されず，他の装置や実装に特有な目的があることもある。
◎
Keys with input method editor functions are not restricted to that purpose, and can have other device- or implementation-specific purposes.
</p>

				</section>
			</section>
			<section id="keys-cancelable-keys">
<h4 title="Default actions and cancelable keyboard events">4.3.4. 既定~動作と取消~可能~keyboard~event</h4>

<p>
`keydown$et ~eventの`既定~動作$が取消されたときは，
それと対を成す `keyup$et ~eventには影響しないモノトスルが、
それに対応する［
`beforeinput$et ／ `input$et ／（~support有りなら） `keypress$et
］~eventは生成しないようにするモノトスル。
次の例に、
~US~keyboardで, ~US用の`~UIkey対応付け$を利用している下で，
~Unicode文字 Q（ `Latin Capital Letter Q^cn ）
が生成されるときにアリな~UIkey連列を述べる：
◎
Canceling the default action of a keydown event MUST NOT affect its respective keyup event, but it MUST prevent the respective beforeinput and input (and keypress if supported) events from being generated. The following example describes a possible sequence of keys to generate the Unicode character Q (Latin Capital Letter Q) on a US keyboard using a US mapping:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>
<td>`shiftKey$m
<td>

<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>
<td>
<td>
<td>
<td>
<td><em>
［
`beforeinput$et／`input$et
］~event, および（~supportされるなら）`keypress$et ~eventは、
生成されない
</em>
◎
No beforeinput or input (or keypress, if supported) events are generated

<tr><td>3.
<td>`keyup$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>4.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
<td>
</table>
</div>

<p>
~UIkeyが修飾~UIkeyであった場合、
~keystrokeは，依然として修飾~状態に織り込むモノトスル。
次の例に、
~US~keyboardで, ~US用の`~UIkey対応付け$を利用している下で，
~Unicode文字 Q（ `Latin Capital Letter Q^cn ）
が生成されるときにアリな連列を述べる：
◎
If the key is a modifier key, the keystroke MUST still be taken into account for the modifiers states. The following example describes a possible sequence of keys to generate the Unicode character Q (Latin Capital Letter Q) on a US keyboard using a US mapping:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>修飾
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Shift$kY
<td>
<td>`shiftKey$m
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>2.
<td>`keydown$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>3.
<td>`beforeinput$et
<td>
<td>`Q^kGl
<td>
<td>

<tr><td>4.
<td>`input$et
<td>
<td>
<td>
<td>

<tr><td>5.
<td>`keyup$et
<td>`Q^kY
<td>
<td>`shiftKey$m
<td>

<tr><td>6.
<td>`keyup$et
<td>`Shift$kY
<td>
<td>
<td>
</table>
</div>

<p>
~UIkeyが何回かの~keystrokeからなる連列の一部を成す場合，
それが`~dead-key$であれ, ~IME連列に寄与しているものであれ、
その~keystrokeは，
`keydown$et ~event上で`既定~動作$が取消された場合に限り，無視するモノトスル
（織り込まれない）。
`~dead-key$による`keyup$et ~eventを取消しても，
`beforeinput$et ／ `input$et
~eventには効果がない。
次の例に、
~French~keyboardで, ~French用の`~UIkey対応付け$を利用し，どの修飾も作動化されない下で、［
~dead-key `Dead$kY （ `0302^U `Combining Circumflex Accent^cn ~UIkey）
］, ［
`e^kY ~UIkey（ `0065^U `Latin Small Letter E^cn ~UIkey）
］を利用したときに生じる~event連列を示す：
◎
If the key is part of a sequence of several keystrokes, whether it is a dead key or it is contributing to an Input Method Editor sequence, the keystroke MUST be ignored (not taken into account) only if the default action is canceled on the keydown event. Canceling a dead key on a keyup event has no effect on beforeinput or input events. The following example uses the dead key "Dead" (U+0302 Combining Circumflex Accent key) and "e" (U+0065, Latin Small Letter E key) on a French keyboard using a French mapping and without any modifier activated:
</p>

<div class="example">
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>`key$m
<th>`InputEvent.data$m
<th>備考
<tbody>

<tr><td>1.
<td>`keydown$et
<td>`Dead$kY
<td>
<td>
【！複製】
`既定~動作$は、
例えば `preventDefault()$m の呼出ngにより，防止された。
◎
The default action is prevented, e.g., by invoking preventDefault().
<tr><td>2.
<td>`keyup$et
<td>`Dead$kY
<td>
<td>

<tr><td>3.
<td>`keydown$et
<td>`e^kY
<td>
<td>

<tr><td>4.
<td>`beforeinput$et
<td>
<td>`e^kGl
<td>

<tr><td>5.
<td>`input$et
<td>
<td>
<td>

<tr><td>6.
<td>`keyup$et
<td>`e^kY
<td>
<td>
</table>
</div>

			</section>
		</section>
	</section>
	<section id="external-algorithms">
<h2 title="External Algorithms">5. 外部~algo</h2>

<p>
この節は、
この仕様により要求されるが，他の仕様が~hostする方が適正になる~algoを包含する。
◎
This sections contains algorithms that are required by this specification, but are more properly hosted by other specifications.
</p>

<p class="note">注記：
この節は、
これらの定義~用の一時的な~~場所として~serveすることが意図される。
それらは、
最終的には，もっと適切な~~場所へ移動されるべきであり、
そのときには，この節~全体が削除され得る。
◎
The intent is that this sections serve as a temporary home for these definitions, and they should eventually be moved into a more appropriate home so this entire section can be deleted.
</p>

		<section id="external-dom-algorithms">
<h3 title="Core DOM Algorithms">5.1. 中核~DOM~algo</h3>

<p class="note">注記：
以下に与える~algoは、
どこか【他の仕様】へ移動されるべきである。
◎
The following algorithms should be moved... somewhere.
</p>

<div class="algo">
<p>
`接触判定する@
ときは、
所与の
( %位置 )
に対し，
%位置 に~~重なる~DOM要素のうち最も前面にあるものを返す：
◎
6.1.1. hit test
◎
Input
• pos, the x,y coordinates relative to the viewport
Output
• The frontmost DOM element at pos
</p>
<ol>
	<li>
<p>
~RET 【当の~nativeな~eventが生じた`文書$上の】
`elementFromPoint()$m ~method手続き( %位置 )
`CSSOM-View$r
</p>

<p class="issue">【！note】
［
`不活$な要素, `不能化されて$feいる要素
］も織り込む必要がある。
そのためには、
`elementsFromPoint()$m 手続きを~callした上で，
妥当でない要素を却下するべきである。
</p>
◎
To account for inert or disabled elements. this should call elementsFromPoint and reject invalid elements
◎
Return [CSSOM-View]'s elementFromPoint with pos
</li>
</ol>
</div>

<div class="algo">
<p>
`~DOM経路を計算する@
ときは、
所与の
( 要素 %要素 )
に対し，
%要素 の先祖~要素たちが成す~listを返す：
◎
6.1.2. calculate DOM path
◎
Input
• element, the starting element
Output
• The list of ancestor elements for the given element
</p>
<ol>
	<li>
%経路 ~LET « %要素 »
◎
Let path = A list that contains element
</li>
	<li class="issue">【！note】
ここには、
%経路 に先祖たちを追加するための適正な定義が必要である。
◎
This needs a proper definition to add ancestors to path.
</li>
	<li>
~RET %経路
◎
Return path
</li>
</ol>
</div>

		</section>
		<section id="external-pointerlock-algorithms">
<h3 title="PointerLock Algorithms">5.2. ~pointer~lock用の~algo</h3>

<p class="note">注記：
以下に与える~algoは、
`PointerLock$r の中へ移動されるべきである。
◎
The following algorithm should be moved into the [PointerLock] spec.
</p>

<p class="trans-note">【
“~pointer~lock” は，
原文では `PointerLock^en と称されるが、
これは，~interfaceの名前ではなく仕様の名前である。
】</p>

			<section id="pointer-lock-global-state">
<h4 title="Global State for PointerLock">5.2.1. ~pointer~lock用の大域的な状態</h4>

<p id="pointer-lock-global-window">
~UAは、
各`~window$の中で共有される値をとして，次を保守するモノトスル
⇒
`最後の~mousemove位置@
⇒
最後の `mousemove$et ~eventの位置を記録する
— 初期~時は ε とする。
◎
6.2.1.1. Window-Level State
◎
The UA must maintain the following values that are shared for the Window.
◎
A last mouse move value (initially undefined) that records the position of the last mousemove event.
</p>

			</section>
			<section id="_algorithms-for-pointerlock">
<h4>5.2.2. 各種~algo</h4>

<div class="algo">
<p>
`~MouseEvent用に各~pointer~lock属性を初期化する@
ときは、
所与の
( `MouseEvent$I %~event )
に対し：
◎
6.2.2. initialize PointerLock attributes for MouseEvent
◎
Input
• event, a MouseEvent
Output
• None
</p>
<ol>
	<li>
%~event の
⇒＃
`movementX$m ~SET 0,
`movementY$m ~SET 0
◎
Set event.movementX = 0
◎
Set event.movementY = 0
</li>
</ol>
</div>

<div class="algo">
<p>
`~mousemove用に各~pointer~lock属性を設定する@
ときは、
所与の
( `MouseEvent!I %~event )
に対し：
◎
6.2.3. set PointerLock attributes for mousemove
◎
Input
• event, a MouseEvent
Output
• None
</p>
<ol>
	<li>
~IF［
%~event の `type$m ~NEQ `mousemove^l
］
⇒
~RET
◎
If event.type is not "mousemove", then exit
</li>
	<li>
( %~x, %~y ) ~LET ( %~event の `screenX$m, %~event の `screenY$m )
◎
↓</li>
	<li>
( %動き~x, %動き~y ) ~LET ( 0, 0 )
◎
If last mouse move is not defined, then
• Set event.movementX = 0
• Set event.movementY = 0
</li>
	<li>
~IF［
`最後の~mousemove位置$ ~NEQ ε
］
⇒＃
%動き~x ~SET %~x ~MINUS `最後の~mousemove位置$の~x座標；
%動き~y ~SET %~y ~MINUS `最後の~mousemove位置$の~y座標
◎
Otherwise,
• Set event.movementX = event.screenX - last mouse move’s x-coordinate
• Set event.movementY = event.screenX - last mouse move’s y-coordinate
</li>
	<li>
%~event の
⇒＃
`movementX$m ~SET %動き~x,
`movementY$m ~SET %動き~y
◎
↑</li>
	<li>
`最後の~mousemove位置$ ~SET ( %~x, %~y )
◎
Set last mouse move = ( event.screenX, event.screenY )
</li>
</ol>
</div>

			</section>
		</section>
		<section id="external-pointerevent-algorithms">
<h3 title="PointerEvent Algorithms">5.3. `PointerEvent^I 用の~algo</h3>

<p class="note">注記：
以下に与える~algoは、
`PointerEvents3$r の中へ移動されるべきである。
◎
The following algorithms should be moved into the [PointerEvents3] spec.
</p>

<div class="algo">
<p>
`~PointerEventを初期化する@
ときは、
所与の
( `PointerEvent$I %~event, 文字列 %~event型, `EventTarget$I %~event~target )
に対し：
◎
6.3.1. initialize a PointerEvent
◎
Input
• event, the PointerEvent to initialize
• eventType, a DOMString containing the event type
• eventTarget, the EventTarget of the event
Output
• None
</p>
<ol>
	<li>
`~MouseEventを初期化する$( ↓ )
⇒＃
%~event,
%~event型,
%~event~target
◎
Initialize a MouseEvent with event, eventType and eventTarget
</li>
	<li class="issue">【！note】
ここで `PointerEvent$I の各~属性を初期化する。
◎
TODO - initialize the pointerevent attributes
</li>
</ol>
</div>

<div class="algo">
<p>
`~PointerEventを作成する@
ときは、
所与の
( 文字列 %~event型, `EventTarget$I %~event~target )
に対し：
◎
6.3.2. create a PointerEvent
◎
Input
• eventType, a DOMString containing the event type
• eventTarget, the EventTarget of the event
Output
• None
</p>
<ol>
	<li>
%~event ~LET `~eventを作成する$( `PointerEvent$I )
◎
Let event = the result of creating a new event using PointerEvent
</li>
	<li>
`~PointerEventを初期化する$( %~event, %~event型, %~event~target )
◎
Initialize a PointerEvent with event, eventType and eventTarget
</li>
	<li>
~RET %~event
◎
Return event
</li>
</ol>
</div>

<div class="algo">
<p>
`~MouseEventから~PointerEventを作成する@
ときは、
所与の
( 文字列 %~event型, `MouseEvent$I %~mouse~event )
に対し：
◎
6.3.3. create PointerEvent from MouseEvent
◎
Input
• eventType, a DOMString containing the event type
• mouseevent, the corresponding MouseEvent
Output
• None
</p>
<ol>
	<li>
%~event ~LET `~eventを作成する$( `PointerEvent$I )
◎
Let event = the result of creating a new event using PointerEvent
</li>
	<li>
`~PointerEventを初期化する$( %~event, %~event型, %~mouse~event の`~target$ev )
◎
Let target = mouseevent.target
◎
Initialize a PointerEvent with event, eventType and target
</li>
	<li>
%~mouse~event から %~event の中へ `MouseEvent$I の属性たちを複製する
◎
Copy MouseEvent attributes from mouseevent into event
</li>
	<li>
~RET %~event
◎
Return event
</li>
</ol>
</div>

<div class="algo">
<p>
`必要なら~pointer~eventを送信する@
ときは、
所与の
( `MouseEvent$I %~mouse~event, 文字列 %~event型（省略時は ε ） )
に対し：
</p>

<p class="trans-note">【
この~algoは、
原文では %~event型 ごとに別々な~algoとして定義されているが，
この訳では一つに統合することにする。
】【
“必要なら（ `maybe^en ）”：
現時点では、
この~algoは，常に %~mouse~event に対応する~pointer~eventを配送するよう定義されているが、
将来には そうならない事例も追加されるものと思われる。
】</p>
<ol>
	<li>
<p>
~IF［
%~event型 ~EQ ε
］
⇒
%~event型 ~SET %~mouse~event の `type$m に応じて
⇒＃
`mouseout^l ならば `pointerout^l ／
`mouseleave^l ならば `pointerleave^l ／
`mouseover^l ならば `pointerover^l ／
`mouseenter^l ならば `pointerenter^l ／
`mousemove^l ならば `pointermove^l ／
`mousedown^l ならば `pointerdown^l ／
`mouseup^l ならば `pointerup^l
</p>

<p class="issue">【！note】
【！Can this send pointermove and pointerrawupdate? Or do we need 2 methods?】
%~event型 ~EQ `pointermove^l の場合、
これは，
`pointermove$et に加えて `pointerrawupdate$et も送信し得るか？
あるいは 2 つの~methodが必要になるか？
</p>

<p class="issue">【！note】
【！What is needed to properly define how pointermove events are coalesced?】
%~event型 ~EQ `pointermove^l の場合に
`pointermove$et ~eventたちがどう`合体される＠~POINTEREVENTS#coalesced-events$かを適正に定義するためには、
何が必要か？
</p>

<p class="note">注記：
【！Unlike mousedown events, ...】
【！Unlike mouseup events, ...】
（ %~event型 ~IN { `pointerdown^l, `pointerup^l } の場合）
［
`mousedown$et ／ `mouseup$et
］~eventと違って、［
`pointerdown$et ／ `pointerup$et
］~eventは，複数の~buttonが押されたときでも入子にされない。
【~eventが “入子にされる” とは何を意味する？】
当の `MouseEvent^I は、
各~fieldを `PointerEvent^I の中へ複製できるよう渡される。
</p>
	</li>
	<li>
%~pointer~event ~LET `~MouseEventから~PointerEventを作成する$( %~mouse~event, %~event型 )
</li>
	<li class="issue">【！note】
ここで `PointerEvent$I の各~属性を（ %~event型 に応じて適切に）設定する。
</li>
	<li>
`~eventを配送する$( %~mouse~event の`~target$ev, %~pointer~event )
</li>
</ol>

◎
6.3.4. maybe send pointerout event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
◎
6.3.5. maybe send pointerleave event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
◎
6.3.6. maybe send pointerover event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
◎
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
◎
6.3.7. maybe send pointerenter event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
◎
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
◎
6.3.8. maybe send pointermove event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
◎
Can this send pointermove and pointerrawupdate? Or do we need 2 methods?
◎
What is needed to properly define how pointermove events are coalesced?
◎
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
◎
6.3.9. maybe send pointerdown event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
◎
Unlike mousedown events, pointerdown events are not nested when multiple buttons are pressed. The MouseEvent is passed so that the fields can be copied into the PointerEvent.
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
◎
6.3.10. maybe send pointerup event
◎
Input
• mouseout, the corresponding mouseout MouseEvent
Output
• None
◎
Unlike mouseup events, pointerup events are not nested when multiple buttons are pressed. The MouseEvent is passed so that the fields can be copied into the PointerEvent.
• Let pointerout = create PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• TODO
• Let target = mouseout.target
• dispatch pointerout at target
</div>

		</section>
	</section>
	<section id="legacy-event-initializers" class="appendix">
<h2 title="Legacy Event Initializers">6. 旧来の~event初期化子</h2>

`legacy-event-initializers^APX

	</section>
	<section id="legacy-key-attributes">
<h2 title="Legacy Key Attributes">7. 旧来の~UIkey属性</h2>

`legacy-key-attributes^APX

	</section>
	<section id="legacy-event-types">
<h2 title="Legacy Event Types">8. 旧来の~event型</h2>

`legacy-event-types^APX

	</section>
	<section id="extending-events">
<h2 title="Extending Events">9. ~eventの拡張-法</h2>

`extending-events^APX

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">10. ~securityの考慮点</h2>

`security-considerations^APX

	</section>
	<section id="changes-from-earlier-versions">
<h2 title="Changes">11. 変更点</h2>

`changes-from-earlier-versions^APX

	</section>
	<section id="acknowledgements-contributors">
<h2 title="Acknowledgements">12. 謝辞</h2>

`acknowledgements-contributors^APX

	</section>
	<section id="glossary">
<h2 title="Glossary">13. 用語集</h2>

<p class="1st">
次の用語の定義の一部は、
他の［
W3C ／標準
］文書の類似な定義から借用されたり, 改変されている。
詳細は、
定義~内の~linkを見よ。
◎
Some of the following term definitions have been borrowed or modified from similar definitions in other W3C or standards documents. See the links within the definitions for more information.
</p>

<p class="trans-note">【
適合性に関連な用語は、
`別~pageの § 用語集＠~UIEVENTS-A#glossary$
に挙げる。
】【
ここでは、
原文の~~アルファベット順による並びに代えて，
互いの関連度に基づく並びに改めている。
】</p>

<dl id="glossary-list">
	<dt>
`要素@
（ `element^en ）
</dt>
	<dd>
`Element$I ~interface `DOM$r
を~instance化した~obj
</dd>

	<dt>
`根~要素@
（ `root element^en ）
</dt>
	<dd>
`文書~要素$。
［
~HTML／ ~XHTML
］`文書$においては、
`html^e 要素が該当する。
◎
The first element node of a document, of which all other elements are children. The document element.
</dd>

	<dt>
`~body要素@
（ `body element^en ）
</dt>
	<dd>
［
~HTML／ ~XHTML
］`文書$においては、
`根~要素$の子孫【子？】である `body^e 要素のうち，最初のもの。
~body要素は，文書の内容を表現する。
【`~HTML仕様による定義＠~HTMLdom#the-body-element-2$】
◎
In HTML or XHTML documents, the body element represents the contents of the document. In a well-formed HTML document, the body element is a first descendant of the root element.
</dd>

	<dt>
`空~文字列@
（ `empty string^en ）
</dt>
	<dd>
長さ 0 の，`DOMString^I 型~値。
◎
The empty string is a value of type DOMString of length 0, i.e., a string which contains no characters (neither printing nor control characters).
</dd>

	<dt>
`未初期化~値@
（ `un-initialized value^en ）
</dt>
	<dd>
~eventが `initEvent()$m†
で初期化される前の，各種~event属性
（ `bubbles$m や `currentTarget$m など）
が，既定でとるものとされる値。
~eventの未初期化~値は、
`Document.createEvent()$m ~method††を利用して
新たな~eventが作成される時点で適用される。
◎
The value of any event attribute (such as bubbles or currentTarget) before the event has been initialized with initEvent(). The un-initialized values of an event apply immediately after a new event has been created using the method createEvent().
</dd>
	<dd class="trans-note">【†
または，構築子に与える `EventInit$I （または それを継承する）型の辞書~引数
】【††
または，各種~event~interfaceの構築子
】【
この種の値は、
“既定値（ `default value^en ）” 命名されることが多いが、
この名前にされている理由は，~IDL用語の “既定値” と区別するためと思われる。
】</dd>

	<dt>
`~event型@
（ `event type^en ）
</dt>
	<dd>
`~event型^em は、
特定0の名前を持ち, 特定0の［
誘発~条件, ~prop, 他の~event型から判別される他の特性
］を定義する`~event$~objである。
例えば、
~event型 `click$et は `mouseover$et や `load$et とは異なる特性を有する。
~event型は、
~event~obj上では `type$m 属性として公開される。
~event型が `click^et である~eventは、
“`click^et ~event”
のように略記されることもある。
◎
An event type is an event object with a particular name and which defines particular trigger conditions, properties, and other characteristics which distinguish it from other event types. For example, the click event type has different characteristics than the mouseover or load event types. The event type is exposed as the type attribute on the event object. Also loosely referred to as "event", such as the click event.
</dd>

	<dt>
`~event~focus@
（ `event focus^en ）
</dt>
	<dd>
~event~focusは、
`文書$の中の［
特定0の要素~その他の`~event~target$
］において，［
~~目立たせている／~~注視されている
］ような特別な状態である。
~focusされたときの挙動は、
各~要素ごとに その機能性に依存して異なる
— ［
（~buttonや~hyperlink用に）要素を作動化~対象の首位に据える ／
（~checkbox用の）状態の切り替え ／
（~text~form~field用の）~text入力を受取る ／
選択された~textを複製する
］など。
詳細は
`§ 文書~focusと~focus文脈＠#events-focusevent-doc-focus$を見よ。
◎
Event focus is a special state of receptivity and concentration on an particular element or other event target within a document. Each element has different behavior when focused, depending on its functionality, such as priming the element for activation (as for a button or hyperlink) or toggling state (as for a checkbox), receiving text input (as for a text form field), or copying selected text. For more details, see § 4.3.3 Document Focus and Focus Context.
</dd>

	<dt>
`~event~focus環@
（ `event focus ring^en ）
</dt>
	<dd>
~event~focus環とは、
`文書$内の`~event~focus$の~targetになり得るものからなる有順序~集合である。
`~host言語$は、
これらの~targetの順序を決定する複数の仕方を定義することもある
— ［
文書~順序 ／
各~focus~targetに定義される数量的~index ／
各~focus~targetに明示的に与えられる次の~target ／
これらの異なる~modelの~~混成
］など。
文書は、
複数の~focus環や条件付き~focus環を包含することもある。
概して、［
文書~順序／~index【~tab~index】
］に基づく~focus環においては、
最後の~focus~targetの次の~focusは， “最初へ戻る” 。
◎
An event focus ring is an ordered set of event focus targets within a document. A host language MAY define one or more ways to determine the order of targets, such as document order, a numerical index defined per focus target, explicit pointers between focus targets, or a hybrid of different models. Each document MAY contain multiple focus rings, or conditional focus rings. Typically, for document-order or indexed focus rings, focus wraps around from the last focus target to the first.
</dd>

	<dt>
`~event~target@
（ `event target^en, 略して “~target” ）
</dt>
	<dd>
~event~flowを利用して，`~event$の`~target＠~DOM4#event-target$にされている~obj
— `target$m 属性の値が，それを与える。
◎
The object to which an event is targeted using the event flow. The event target is the value of the target attribute.
</dd>

	<dt>
`作動化の誘発@
（ `activation trigger^en ）
</dt>
	<dd>
`作動化の挙動$を起動するように定義された~event。
◎
An event which is defined to initiate an activation behavior.
</dd>

	<dt>
`既定~動作@
（ `default action^en ）
</dt>
	<dd>
`既定~動作$は、
任意選択†な補足的な挙動であって，実装が~event~objの配送-と組合せて遂行しなければナラナイものである。
各種~event型~定義, および
各種 仕様は、
その~event型~用の`既定~動作$があれば，それを定義する。
`作動化の誘発$に結付けられたときなど、
一部の状況下では，~eventの各~instanceには`既定~動作$が複数ある場合もある。
`既定~動作$は、
`preventDefault()$m ~methodの呼出nを通して取消されることもある。
◎
A default action is an OPTIONAL supplementary behavior that an implementation MUST perform in combination with the dispatch of the event object. Each event type definition, and each specification, defines the default action for that event type, if it has one. An instance of an event MAY have more than one default action under some circumstances, such as when associated with an activation trigger. A default action MAY be cancelled through the invocation of the preventDefault() method.
</dd>
	<dd class="trans-note">【†
どの主体から見て任意選択なのかはっきりしない
— 実装ではなく，この仕様を参照している他の仕様？
】</dd>

	<dt>
`最上層の~event~target@
（ `topmost event target^en ）
</dt>
	<dd>
最上層の~event~targetは、
`~event~target$になれるような，最も上層に描画される要素でなければナラナイ。
~graphicな~UIにおいては、
これは，利用者の~pointing装置が~~指す所の~~直下にある要素になる。
この~targetの決定は、
~UIの “接触判定” に基づく。
接触判定と積層~順序に関する特定の詳細は、
`~host言語$を見よ。
◎
The topmost event target MUST be the element highest in the rendering order which is capable of being an event target. In graphical user interfaces this is the element under the user’s pointing device. A user interface’s hit testing facility is used to determine the target. For specific details regarding hit testing and stacking order, refer to the host language.
</dd>
	<dd class="trans-note">【
例えば `pointer-events$p ~propなどにより，明示的に接触判定の対象から除外されるものは、
最も上層に塗られていても，最上層の~event~targetにはならない。
】</dd>

	<dt>
`~pointing先@
</dt>
	<dd>
~pointing装置が現在 指している`最上層の~event~target$を意味する（存在しない場合は~NULL）。
</dd>
	<dd class="trans-note">【
この用語と次に与える用語は、
各所の記述を集約して簡潔にするために，この訳に導入している。
】</dd>
	<dd>
`~pointing先$が
`有効に変化-@
したとは、
その変化は，［
~pointing装置の`首~pointer$によるものである†1
］かつ［
（利用者により）~pointerが動かされたか，ある要素が動いた†2
］ことにより生じたことを意味する。
</dd>
	<dd class="trans-note">【†1
非 `首~pointer$からは、
この定義を参照する~mouse~event（互換性~mouse~event）は生じない。
】【†2
要素が “動いた” とは、
~scrollや~layout変化によるそれに加えて，要素を挿入するなどの~DOM変異によるそれも含まれる
（と思われる
— 少なくとも一部の~browserの実装は、
そうなっている）。
】【†2
動いた要素と変化-［
前／後
］の~pointing先が一致する必要はない。
例えば、
動いた要素は新たな~pointing先の先祖かもしれない。
】</dd>

	<dt>
`回転@
（ `rotation^en ）
</dt>
	<dd>
`WheelEvent$I ~interfaceを利用している入力~装置~上の
増分的な変化の指示。
これには、
装置により
~wheelの回転動作,
平坦な表面をなぞる動き,
特定0の~buttonの押圧
などがあり得る。
◎
An indication of incremental change on an input device using the WheelEvent interface. On some devices this MAY be a literal rotation of a wheel, while on others, it MAY be movement along a flat surface, or pressure on a particular button.
</dd>

	<dt>
`~delta@
（ `delta^en ）
</dt>
	<dd>
~UAが `WheelEvent!I ~interfaceとして~supportされるような入力~装置（~mouse~wheelや~touchpadなど）の物理的な動きに呼応して，~pageを~scrollしたり~zoomするときに見積もられる~scroll量。
`~delta$の値（例：
`deltaX$m, `deltaY$m, `deltaZ$m
属性）は、
`deltaMode$m ~propによる`測定~単位$として解釈される。
~wheel（または他の装置）の物理的な動きと`~delta$の正負との関係性は、
環境や装置に依存する。
しかしながら，~UAが`既定~動作$として~scrollする場合、
`~delta$の正負は`右手~座標系$により与えられる。
◎
The estimated scroll amount (in pixels, lines, or pages) that the user agent will scroll or zoom the page in response to the physical movement of an input device that supports the WheelEvent interface (such as a mouse wheel or touch pad). The value of a delta (e.g., the deltaX, deltaY, or deltaZ attributes) is to be interpreted in the context of the current deltaMode property. The relationship between the physical movement of a wheel (or other device) and whether the delta is positive or negative is environment and device dependent. However, if a user agent scrolls as the default action then the sign of the delta is given by a right-hand coordinate system where positive X,Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.
</dd>

	<dt>
`~hysteresis@
（ `hysteresis^en ）
</dt>
	<dd>
使用感を改善するために，所在や時間がずれた入力も一定限度までは受容するような、
ヒト~interface設計の特能。
例えば、
利用者が~mouse~buttonを~double-clickするときの微小な時間差の受容は，時間的~hysteresisであり、［
利用者が子~menuへ遷移しようとして，~mouseが親~UIwindowから外れたとき，入子な~menuを直ぐに閉じないこと
］は，所在的~hysteresisである。
◎
A feature of human interface design to accept input values within a certain range of location or time, in order to improve the user experience. For example, allowing for small deviation in the time it takes for a user to double-click a mouse button is temporal hysteresis, and not immediately closing a nested menu if the user mouses out from the parent window when transitioning to the child menu is locative hysteresis.
</dd>

	<dt>
`文字~値@
（ `character value^en ）
</dt>
	<dd>
<p>
~UIkey値の文脈では、
文字~値は， 1 個~以上の~Unicode文字を表現する文字列である
— 普通字や記号, あるいは 何個かの普通字が成す並びなど，それぞれが妥当な`~Unicode字種$が成す集合に属するような。
この仕様では、
文字~値は ~Unicode文字列（例： `0020^U ）, または
同じ符号位置の~glyph表現（例： `X^kGl ）として記され、
2 つの表現を判別し易くするよう色付けられる。
◎
In the context of key values, a character value is a string representing one or more Unicode characters, such as a letter or symbol, or a set of letters, each belonging to the set of valid Unicode character categories. In this specification, character values are denoted as a unicode string (e.g., U+0020) or a glyph representation of the same code point (e.g., " "), and are color coded to help distinguish these two representations.
</p>

<p class="note">注記：
~source~codeにおいては、
非~graphic文字などの一部の~UIkey値は，
利用-中にある~programming言語の文字~escape構文を利用して表現され得る。
◎
In source code, some key values, such as non-graphic characters, can be represented using the character escape syntax of the programming language in use.
</p>
</dd>

	<dt>
`~UIkey値@
（ `key value^en ）
</dt>
	<dd>
~UIkey値は、
特定0の状態にある~UIkeyに結付けられた，`文字~値$ または［
複数~文字からなる文字列
（ `Enter$kY, `Tab$kY, `MediaTrackNext$kY など）
］である。
~UIkey値は、
どの~UIkeyにも
— 制御~UIkey, ~function~UIkey, `修飾~UIkey$, `~dead-key$, その他の~UIkeyも含む —
`文字~値$を有するかどうかに関わらず，あてがわれる。
与えられた時点の与えられたどの~UIkeyの~UIkey値も、
`~UIkey対応付け$に依存する。
◎
A key value is a character value or multi-character string (such as "Enter", "Tab", or "MediaTrackNext") associated with a key in a particular state. Every key has a key value, whether or not it has a character value. This includes control keys, function keys, modifier keys, dead keys, and any other key. The key value of any given key at any given time depends upon the key mapping.
</dd>

	<dt>
`修飾~UIkey@
（ `modifier key^en ）
</dt>
	<dd>
修飾~UIkeyは、
~UIkeyの通常の挙動を変更する
— （ `Shift^cap ~UIkeyで）異なる文字caseを生産させたり,
（`Fn^cap や `Alt^cap ~UIkeyなどで）~UIkeyが誘発する機能性を改めるなど。
修飾~UIkeyについての情報は、
`§ 修飾~UIkey＠#keys-modifiers$を見よ。
妥当な修飾~UIkeyたちが成す~listは、
`UIEvents-Key$r の`修飾~UIkeyの表t$内にある。
◎
A modifier key changes the normal behavior of a key, such as to produce a character of a different case (as with the Shift key), or to alter what functionality the key triggers (as with the Fn or Alt keys). See § 5.3.1 Modifier keys for more information about modifier keys and refer to the Modifier Keys table in [UIEvents-Key] for a list of valid modifier keys.
</dd>

	<dt>
`~dead-key@
（ `dead key^en ）
</dt>
	<dd>
~dead-keyは、
自身は文字を生産しないが，［
別の~UIkeyとの［
組合n／連列
］により，修飾された文字
— 発音区別符号を伴う文字（例： `ö^kGl, `é^kGl, `â^kGl ）など —
を生産する
］ような［
~UIkeyまたは~UIkeyの組合n
］である。
◎
A dead key is a key or combination of keys which produces no character by itself, but which in combination or sequence with another key produces a modified character, such as a character with diacritical marks (e.g., "ö", "é", "â").
</dd>

	<dt>
`~text組成~system@
（ `text composition system^en ）
</dt>
	<dd>
何らかの形による代替-入力
（`~IME$, 発話~処理器, 手書き認識~systemなど）
を解釈して，それを~textに変換する~software~component。
◎
A software component that interprets some form of alternate input (such as a input method editor, a speech processor, or a handwriting recognition system) and converts it to text.
</dd>

	<dt>
`~UIkey対応付け@
（ `key mapping^en ）
</dt>
	<dd>
~UIkey対応付けは、
特定0の~UIkeyに~UIkey値をあてがう処理nであり、
いくつかの要因
— ~OSや~keyboard~layout
（例： `QWERTY$, Dvorak, Spanish, InScript, Chinese, 等々），
および［
`修飾~UIkey$（ `Shift^cap, `Alt^cap, 等々）／ `~dead-key$
］の状態すべてを含む —
を組合せた結果である。
◎
Key mapping is the process of assigning a key value to a particular key, and is the result of a combination of several factors, including the operating system and the keyboard layout (e.g., QWERTY, Dvorak, Spanish, InScript, Chinese, etc.), and after taking into account all modifier key (Shift, Alt, et al.) and dead key states.
</dd>

	<dt>
`~IME@
（ `input method editor^en, 入力方式エディタ ）
</dt>
<!-- 
	<dt id="glossary-input-method-editor"></dt>
-->
	<dd>
~IMEは、
一連の~keystrokeから表意文字その他の文字への変換を
— 通例的に，利用者により手引きされる辞書検索により —
遂行する~appであり、
東アジア圏の言語（例：中国語, 日本語, 韓国語）でよく利用される。
~IMEは、
携帯~機器などでも単語の入力補完に利用されることもある。
この仕様における~IMEの扱いについては、
`§ ~IME＠#keys-IME$を見よ。
§ `~text組成~system$も見よ。
◎
An input method editor (IME), also known as a front end processor, is an application that performs the conversion between keystrokes and ideographs or other characters, usually by user-guided dictionary lookup, often used in East Asian languages (e.g., Chinese, Japanese, Korean). An IME MAY also be used for dictionary-based word completion, such as on mobile devices. See § 5.3.3 Input Method Editors for treatment of IMEs in this specification. See also text composition system.
</dd>

<!-- 
namespace URI 未利用
-->

	<dt>
`QWERTY@
</dt>
	<dd>
QWERTY（ “ˈkwɜrti” と発音される）は、
共通的な~keyboard~layoutの普通字~UIkeyの上段の最初の 6 文字が
Q, W, E, R, T, Y
であることから命名されている。
他にも~popularな~keyboard~layoutは数多くあり（~Dvorakや~Colemak~layoutなど）、
そのほとんどは，地域化や人間工学~用に設計されている。
◎
QWERTY (pronounced ˈkwɜrti) is a common keyboard layout, so named because the first five character keys on the top row of letter keys are Q, W, E, R, T, and Y. There are many other popular keyboard layouts (including the Dvorak and Colemak layouts), most designed for localization or ergonomics.
</dd>

	<dt>
`~Unicode字種@
（ `Unicode character categories^en ）
</dt>
	<dd>
各~Unicode符号位置に対し定義されている
`General Category^en 値の部分集合。
この部分集合には、
次に挙げる字種に属するものすべてが包含される：
<ul>
	<li>
普通字（ `Letter^en ）：
<abbr title="Letter, Lowercase">Ll</abbr>,
<abbr title="Letter, Modifier">Lm</abbr>,
<abbr title="Letter, Other">Lo</abbr>,
<abbr title="Letter, Titlecase">Lt</abbr>,
<abbr title="Letter, Uppercase">Lu</abbr>
</li>
	<li>
数字n（ `Number^en ）：
<abbr title="Number, Decimal Digit">Nd</abbr>,
<abbr title="Number, Letter">Nl</abbr>,
<abbr title="Number, Letter">NO</abbr>
</li>
	<li>
約物（ `Punctuation^en ）：
<abbr title="Punctuation, Connector">Pc</abbr>,
<abbr title="Punctuation, Dash">Pd</abbr>,
<abbr title="Punctuation, Close">Pe</abbr>,
<abbr title="Punctuation, Final quote">Pf</abbr>,
<abbr title="Punctuation, Initial quote">Pi</abbr>,
<abbr title="Punctuation, Other">Po</abbr>,
<abbr title="Punctuation, Open">Ps</abbr>
</li>
	<li>
記号（ `Symbol^en ）：
<abbr title="Symbol, Currency">Sc</abbr>,
<abbr title="Symbol, Modifier">Sk</abbr>,
<abbr title="Symbol, Math">Sm</abbr>,
<abbr title="Symbol, Other">So</abbr>
</li>
</ul>

◎
A subset of the General Category values that are defined for each Unicode code point. This subset contains all the Letter (Ll, Lm, Lo, Lt, Lu), Number (Nd, Nl, No), Punctuation (Pc, Pd, Pe, Pf, Pi, Po, Ps) and Symbol (Sc, Sk, Sm, So) category values.
</dd>
</dl>

	</section>
</main></div>

