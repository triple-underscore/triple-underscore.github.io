<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Service Workers Nightly （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>
.response-status {
	font-family: sans-serif0, sans-serif;
	color: green;
}

	/* protocol element */
.protocol {
	color: purple;
	font-family: monospace0, monospace;
}

/* Examples */
aside.example {
	margin-bottom: 0.5em;
}


ul.input-params::before {
	content: "入力：";
	display: block;
	color: gray;
	text-indent: -2em;
}

#_hierarchy td {
	text-align: center;
	border: none;
}

@supports (display: grid) and (display: contents) {

#_event-table {
	min-width:30em;
	max-width:70em;
}

#_event-table tr {
	grid-template-areas:
		"名 型 類"
		"時 時 時";
	grid-template-columns: 1fr 1fr 1fr;
	grid-auto-flow: row;
}

#_event-table tr > *:nth-child(1) {
	grid-area: 名;
	background-color: hsl(300, 50%, 95% );
}

#_event-table tr > *:nth-child(2) {
	grid-area: 型;
}

#_event-table tr > *:nth-child(3) {
	grid-area: 類;
}

#_event-table tr > *:nth-child(4) {
	grid-area: 時;
}


#_event-table1 {
	min-width:30em;
	max-width:40em;
}

#_event-table1 tr {
	grid-template-areas:
		"名 先"
		"時 時";
	grid-template-columns: 1fr 1fr;
	grid-auto-flow: row;
}

#_event-table1 tr > *:nth-child(1) {
	grid-area: 名;
	background-color: hsl(300, 50%, 95% );
}

#_event-table1 tr > *:nth-child(2) {
	grid-area: 先;
}

#_event-table1 tr > *:nth-child(3) {
	grid-area: 時;
}

}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let context_ifc = '';
	let context_ifc1 = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'C': // Constructor
	text = 'Constructor';
	href = `#dom-${key.toLowerCase()}-${key.toLowerCase()}`
	break;
case 'm':
case 'm1':
case 'n':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
		switch(klass){
		case 'm':
			href = context_ifc + key.toLowerCase();
			break;
		case 'm1':
			href = context_ifc1 + key.toLowerCase();
			break;
		}
	}
	break;
case 'I1':
	context_ifc1 = `#dom-${key.toLowerCase()}-`;
	if(indicator === '^'){
		return '';
	}
	klass = 'I';
	break;
case 'I0':
	context_ifc = `#dom-${key.toLowerCase()}-`;
	if(indicator === '^'){
		return '';
	}
	klass = 'I';
	break;
case 'I':
	if(indicator === '@'){
		context_ifc = `#dom-${key.toLowerCase()}-`;
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'issue':
	return (
`<a href="https://github.com/w3c/ServiceWorker/issues/${key}">issue#${key}</a>`
	);
case 'en':
	return `<span lang="en-x-a0">${key}</span>`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[klass ? `${klass}.${key}` : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

/*
		m: 'code',
mWGS: 'code',
mSWGS: 'code',
mMe: 'code',
mEe: 'code',
mFei: 'code',
mC: 'code',
mCQo: 'code',
mCS: 'code',
mCl: 'code',
mEMe: 'code',
mEMei: 'code',
mFe: 'code',
mNPL: 'code',
mNPM: 'code',
mRo: 'code',
mSW: 'code',
mSWC: 'code',
mSWR: 'code',
mWC: 'code',
*/

</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2019-08-15
trans_update:2019-08-10
source_checked:190611
original_url:https://w3c.github.io/ServiceWorker/
	abbr_url:SW1
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2019,permissive
site_nav:network,http,security,storage
trans_1st_pub:2019-06-03

●●class_map
e:element
E:error
a:attr
st:response-status
et:event-type
v:value
jv:js-value
sl:js-slot
P:protocol
jA:abstract
jT:js-type
dir:directive
	h:header

●●tag_map
I:code
E:code
m:code
m1:code
n:code
c:code
e:code
a:code
et:code
sub:sub
v:code
dir:code
P:var
jv:code
jA:span
sl:span
st:span
V:var
i:i
jT:span
sub:sub

●●original_id_map

●●link_map

CEReactions:~HEcustom#cereactions
Exposed:~WEBIDL#Exposed
Global:~WEBIDL#Global
NewObject:~WEBIDL#NewObject
SameObject:~WEBIDL#SameObject
SecureContext:~WEBIDL#SecureContext

USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
ByteString:~WEBIDL#idl-ByteString
DOMString:~WEBIDL#idl-DOMString

E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.QuotaExceededError:~WEBIDL#quotaexceedederror
E.SecurityError:~WEBIDL#securityerror
E.AbortError:~WEBIDL#aborterror

	I.DOMException:~WEBIDL#idl-DOMException
I.AbstractWorker:~WORKERS#abstractworker
I.Cache:#cache
I.CacheQueryOptions:#dictdef-cachequeryoptions
I.MultiCacheQueryOptions:#dictdef-multicachequeryoptions
I.CacheStorage:#cachestorage
I.Client:#client
I.ClientQueryOptions:#dictdef-clientqueryoptions
I.ClientType:#enumdef-clienttype
I.Clients:#clients
I.DOMContentLoaded:~HTMLindex#event-domcontentloaded
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.ExtendableEvent:#extendableevent
I.ExtendableEventInit:#dictdef-extendableeventinit
I.ExtendableMessageEvent:#extendablemessageevent
I.ExtendableMessageEventInit:#dictdef-extendablemessageeventinit
I.FetchEvent:#fetchevent
I.FetchEventInit:#dictdef-fetcheventinit
I.FrameType:#enumdef-frametype
I.Headers:~FETCH#headers
I.Location:~HISTORY#location
I.MessageEvent:~HTMLcomms#messageevent
I.MessagePort:~HTMLcomms#messageport
I.NavigationPreloadManager:#navigationpreloadmanager
I.NavigationPreloadState:#dictdef-navigationpreloadstate
I.Navigator:~HTMLnavigator#navigator
I.PostMessageOptions:~HTMLcomms#postmessageoptions
I.ReadableStream:~FETCH#concept-readablestream
I.RegistrationOptions:#dictdef-registrationoptions
I.Request:~FETCH#request
I.RequestInfo:~FETCH#requestinfo
I.Response:~FETCH#response
I.ServiceWorker:#serviceworker
I.ServiceWorkerContainer:#serviceworkercontainer
I.ServiceWorkerGlobalScope:#serviceworkerglobalscope
I.ServiceWorkerRegistration:#serviceworkerregistration
I.ServiceWorkerState:#enumdef-serviceworkerstate
I.ServiceWorkerUpdateViaCache:#enumdef-serviceworkerupdateviacache
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.VisibilityState:~PAGE-VISIBILITY#dom-visibilitystate
	:~PAGE-VISIBILITY#visibilitystate
I.Window:~WINDOW#window
	:~WINDOW#window-object
I.WindowClient:#windowclient
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
I.Worker:~WORKERS#worker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WorkerLocation:~WORKERS#workerlocation
I.WorkerNavigator:~WORKERS#workernavigator
I.WorkerType:~WORKERS#workertype

I.NotificationEvent:~NOTIFICATIONS#notificationevent
I.PushEvent:https://w3c.github.io/push-api/#dom-pushevent
I.PaymentRequestEvent:https://w3c.github.io/payment-handler/#dom-paymentrequestevent
I.CanMakePaymentEvent:https://w3c.github.io/payment-handler/#dom-canmakepaymentevent
I.SyncEvent:https://wicg.github.io/BackgroundSync/spec/#syncevent

	m.event.clientId:#dom-fetchevent-clientid
	m.event.data:#dom-extendablemessageevent-data
	m.event.lastEventId:#dom-extendablemessageevent-lasteventid
	m.event.origin:#dom-extendablemessageevent-origin
	m.event.ports:#dom-extendablemessageevent-ports
	m.event.preloadResponse:#dom-fetchevent-preloadresponse
	m.event.request:#dom-fetchevent-request
	m.event.resultingClientId:#dom-fetchevent-resultingclientid
	m.event.respondWith(r):#dom-fetchevent-respondwith
	m.event.source:#dom-extendablemessageevent-source
	m.event.replacesClientId:#dom-fetchevent-replacesclientid
	m.event.waitUntil(f):#dom-extendableevent-waituntil
	m.event.waitUntil(r):#dom-extendableevent-waituntil

	m.navigator.serviceWorker.controller:#dom-serviceworkercontainer-controller
	m.navigator.serviceWorker:#navigator-service-worker-attribute
	m.self.caches:#global-caches-attribute
	m.navigator:~HTMLnavigator#dom-window-navigator
	m.navigator:~WORKERS#dom-worker-navigator


l.report:~FETCH#dom-requestdestination-report

l.sharedworker:#dom-clienttype-sharedworker
l.window:#dom-clienttype-window
l.worker:#dom-clienttype-worker
l.all:#dom-clienttype-all

	l.parsed:#dom-serviceworkerstate-parsed
	l.installing:#dom-serviceworkerstate-installing
	l.installed:#dom-serviceworkerstate-installed
	l.activating:#dom-serviceworkerstate-activating
	l.activated:#dom-serviceworkerstate-activated
	l.redundant:#dom-serviceworkerstate-redundant

	l.imports:#dom-serviceworkerupdateviacache-imports
	＊l.all:#dom-serviceworkerupdateviacache-all
	l.none:#dom-serviceworkerupdateviacache-none

	l.auxiliary:#dom-frametype-auxiliary
	l.top-level:#dom-frametype-top-level
	l.nested:#dom-frametype-nested
	l.none:#dom-frametype-none

n.self.fetch:~FETCH#dom-global-fetch
n.caches:#global-caches-attribute
n.cancelable:~DOM4#dom-event-cancelable
n.isTrusted:~DOM4#dom-event-istrusted
n.get:~FETCH#dom-headers-get
n.headers:~FETCH#dom-request-headers
n.signal:~FETCH#dom-request-signal
n.serviceWorker:#navigator-service-worker-attribute
n.type:~DOM4#dom-event-type
n.visibilityState:~PAGE-VISIBILITY#dom-document-visibilitystate
n.Request:~FETCH#dom-request
n.importScripts:~WORKERS#dom-workerglobalscope-importscripts
		dom-workerglobalscope-importScripts
c.importScripts():#importscripts-method

n.data:~HTMLcomms#dom-messageevent-data
n.origin:~HTMLcomms#dom-messageevent-origin
n.ports:~HTMLcomms#dom-messageevent-ports
n.source:~HTMLcomms#dom-messageevent-source

n.waitUntil:#dom-extendableevent-waituntil
n.respondWith:#dom-fetchevent-respondwith
n.~postMessageClient:#dom-client-postmessage-options
n.~postMessageSW:#dom-serviceworker-postmessage-options

n.register:#dom-serviceworkercontainer-register

	ServiceWorkerGlobalScope.clients:#dom-serviceworkerglobalscope-clients
	ServiceWorkerGlobalScope.registration:#dom-serviceworkerglobalscope-registration
	ServiceWorkerGlobalScope.serviceworker:#dom-serviceworkerglobalscope-serviceworker
	ServiceWorkerGlobalScope.skipWaiting:#dom-serviceworkerglobalscope-skipwaiting
	ServiceWorkerGlobalScope.onactivate:#dom-serviceworkerglobalscope-onactivate
	ServiceWorkerGlobalScope.onfetch:#dom-serviceworkerglobalscope-onfetch
	ServiceWorkerGlobalScope.oninstall:#dom-serviceworkerglobalscope-oninstall
	ServiceWorkerGlobalScope.onmessage:#dom-serviceworkerglobalscope-onmessage
	ServiceWorkerGlobalScope.onmessageerror:#dom-serviceworkerglobalscope-onmessageerror

	ExtendableEvent.Constructor:#dom-extendableevent-extendableevent
	ExtendableEvent.waitUntil:#dom-extendableevent-waituntil

	FetchEventInit.clientId:#dom-fetcheventinit-clientid
	FetchEventInit.preloadResponse:#dom-fetcheventinit-preloadresponse
	FetchEventInit.request:#dom-fetcheventinit-request
	FetchEventInit.resultingClientId:#dom-fetcheventinit-resultingclientid
	FetchEventInit.replacesClientId:#dom-fetcheventinit-replacesclientid

	Cache.add:#dom-cache-add
	Cache.addAll:#dom-cache-addall
	Cache.delete:#dom-cache-delete
	Cache.keys:#dom-cache-keys
	Cache.match:#dom-cache-match
	Cache.matchAll:#dom-cache-matchall
	Cache.put:#dom-cache-put

	MultiCacheQueryOptions.cacheName:#dom-multicachequeryoptions-cachename
	CacheQueryOptions.ignoreMethod:#dom-cachequeryoptions-ignoremethod
	CacheQueryOptions.ignoreSearch:#dom-cachequeryoptions-ignoresearch
	CacheQueryOptions.ignoreVary:#dom-cachequeryoptions-ignorevary
	ClientQueryOptions.includeUncontrolled:#dom-clientqueryoptions-includeuncontrolled
	ClientQueryOptions.type:#dom-clientqueryoptions-type
	
	CacheStorage.delete:#dom-cachestorage-delete
	CacheStorage.has:#dom-cachestorage-has
	CacheStorage.keys:#dom-cachestorage-keys
	CacheStorage.match:#dom-cachestorage-match
	CacheStorage.open:#dom-cachestorage-open
	
	Client.frameType:#dom-client-frametype
	Client.id:#dom-client-id
	Client.postMessage:#dom-client-postmessage
	Client.postMessage:#dom-client-postmessage-options
	Client.reserved:#dom-client-reserved
	Client.type:#dom-client-type
	Client.url:#dom-client-url

	Clients.claim:#dom-clients-claim
	Clients.get:#dom-clients-get
	Clients.matchAll:#dom-clients-matchall
	Clients.openWindow:#dom-clients-openwindow
	
	ExtendableMessageEvent.Constructor:#dom-extendablemessageevent-extendablemessageevent
	ExtendableMessageEvent.data:#dom-extendablemessageevent-data
	ExtendableMessageEvent.lastEventId:#dom-extendablemessageevent-lasteventid
	ExtendableMessageEvent.origin:#dom-extendablemessageevent-origin
	ExtendableMessageEvent.ports:#dom-extendablemessageevent-ports
	ExtendableMessageEvent.source:#dom-extendablemessageevent-source
	ExtendableMessageEventInit.data:#dom-extendablemessageeventinit-data
	ExtendableMessageEventInit.lastEventId:#dom-extendablemessageeventinit-lasteventid
	ExtendableMessageEventInit.origin:#dom-extendablemessageeventinit-origin
	ExtendableMessageEventInit.ports:#dom-extendablemessageeventinit-ports
	ExtendableMessageEventInit.source:#dom-extendablemessageeventinit-source
	
	FetchEvent.Constructor:#dom-fetchevent-fetchevent
	FetchEvent.clientId:#dom-fetchevent-clientid
	FetchEvent.preloadResponse:#dom-fetchevent-preloadresponse
	FetchEvent.request:#dom-fetchevent-request
	FetchEvent.resultingClientId:#dom-fetchevent-resultingclientid
	FetchEvent.respondWith:#dom-fetchevent-respondwith
	FetchEvent.replacesClientId:#dom-fetchevent-replacesclientid
	
	NavigationPreloadState.enabled:#dom-navigationpreloadstate-enabled
	NavigationPreloadState.headerValue:#dom-navigationpreloadstate-headervalue
	
	NavigationPreloadManager.disable:#dom-navigationpreloadmanager-disable
	NavigationPreloadManager.enable:#dom-navigationpreloadmanager-enable
	NavigationPreloadManager.getState:#dom-navigationpreloadmanager-getstate
	NavigationPreloadManager.setHeaderValue:#dom-navigationpreloadmanager-setheadervalue
	
	RegistrationOptions.scope:#dom-registrationoptions-scope
	RegistrationOptions.type:#dom-registrationoptions-type
	RegistrationOptions.updateViaCache:#dom-registrationoptions-updateviacache
	
	ServiceWorker.onstatechange:#dom-serviceworker-onstatechange
	ServiceWorker.postMessage:#dom-serviceworker-postmessage
	ServiceWorker.postMessage:#dom-serviceworker-postmessage-options
	ServiceWorker.scriptURL:#dom-serviceworker-scripturl
	ServiceWorker.state:#dom-serviceworker-state

	ServiceWorkerContainer.controller:#dom-serviceworkercontainer-controller
	ServiceWorkerContainer.getRegistration:#dom-serviceworkercontainer-getregistration
	ServiceWorkerContainer.getRegistrations:#dom-serviceworkercontainer-getregistrations
	ServiceWorkerContainer.oncontrollerchange:#dom-serviceworkercontainer-oncontrollerchange
	ServiceWorkerContainer.onmessage:#dom-serviceworkercontainer-onmessage
	ServiceWorkerContainer.onmessageerror:#dom-serviceworkercontainer-onmessageerror
	ServiceWorkerContainer.ready:#dom-serviceworkercontainer-ready
	ServiceWorkerContainer.register:#dom-serviceworkercontainer-register
	ServiceWorkerContainer.startMessages:#dom-serviceworkercontainer-startmessages
	
	ServiceWorkerRegistration.active:#dom-serviceworkerregistration-active
	ServiceWorkerRegistration.installing:#dom-serviceworkerregistration-installing
	ServiceWorkerRegistration.navigationPreload:#dom-serviceworkerregistration-navigationpreload
	ServiceWorkerRegistration.onupdatefound:#dom-serviceworkerregistration-onupdatefound
	ServiceWorkerRegistration.scope:#dom-serviceworkerregistration-scope
	ServiceWorkerRegistration.unregister:#dom-serviceworkerregistration-unregister
	ServiceWorkerRegistration.update:#dom-serviceworkerregistration-update
	ServiceWorkerRegistration.updateViaCache:#dom-serviceworkerregistration-updateviacache
	ServiceWorkerRegistration.waiting:#dom-serviceworkerregistration-waiting
	
	WindowClient.ancestorOrigins:#dom-windowclient-ancestororigins
	WindowClient.focus:#dom-windowclient-focus
	WindowClient.focused:#dom-windowclient-focused
	WindowClient.navigate:#dom-windowclient-navigate
	WindowClient.visibilityState:#dom-windowclient-visibilitystate

	●et
et.activate:#service-worker-global-scope-activate-event
et.canmakepayment:https://w3c.github.io/payment-handler/#the-canmakepaymentevent
et.controllerchange:#service-worker-container-controllerchange-event
et.fetch:#service-worker-global-scope-fetch-event
et.install:#service-worker-global-scope-install-event
	et.install:#install
	et.activate:#activate
et.message:#eventdef-serviceworkerglobalscope-message
et.messageerror:#eventdef-serviceworkerglobalscope-messageerror
et.notificationclick:~NOTIFICATIONS#dom-serviceworkerglobalscope-onnotificationclick
et.notificationclose:~NOTIFICATIONS#dom-serviceworkerglobalscope-onnotificationclose
et.paymentrequest:https://w3c.github.io/payment-handler/#the-paymentrequestevent
et.push:https://w3c.github.io/push-api/#h-the-push-event
et.push:https://w3c.github.io/push-api/#dfn-push
et.statechange:#eventdef-serviceworker-statechange
et.sync:https://wicg.github.io/BackgroundSync/spec/#sync
et.updatefound:#service-worker-registration-updatefound-event
et.~message0:~HTMLindex#event-message
et.~messageerror0:~HTMLindex#event-messageerror

	●h
h.Service-Worker:#service-worker
h.Service-Worker-Allowed:#service-worker-allowed
h.Vary:~RFC7231#section-7.1.4
h.Cache-Control:~RFC7234#section-5.2
h.Content-Security-Policy-Report-Only:~CSP3#header-content-security-policy-report-only
h.Content-Security-Policy:~CSP3#header-content-security-policy
h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
	h.Service-Worker-Navigation-Preload

	●
P.field-value:~RFC7230#section-3.2

sl.Call:~TC39#sec-ecmascript-function-objects-call-thisargument-argumentslist
Completion:~TC39#sec-completion-record-specification-type

	●用語

~sw:#dfn-service-worker
走っている:#service-worker-running
開始-状態:#service-worker-start-status

sw.状態:#dfn-state
sw.~script~url:#dfn-script-url
sw.種別:#dfn-type
sw.包含している~sw登録:#dfn-containing-service-worker-registration
sw.大域~obj:#dfn-service-worker-global-object
sw.~script資源:#dfn-script-resource
sw.過去評価済み~flag:#dfn-has-ever-been-evaluated-flag
sw.~HTTPS状態:#dfn-https-state
sw.~referrer施策:#dfn-referrer-policy
sw.~script資源~map:#dfn-script-resource-map
sw.利用した~scriptの集合:#dfn-set-of-used-scripts
sw.待機を飛ばす~flag:#dfn-skip-waiting-flag
sw.古典~script~import済み~flag:#dfn-classic-scripts-imported-flag
sw.取扱う~event型の集合:#dfn-set-of-event-types-to-handle
sw.延長-済み~event集合:#dfn-set-of-extended-events
sw.生成元:#_service-worker-origin

~sw~event:#dfn-service-worker-events
~lifecycle~event:#dfn-lifecycle-events
機能的~event:#dfn-functional-events

~sw登録:#dfn-service-worker-registration
未登録にされて:#dfn-service-worker-registration-unregistered
非新鮮:#service-worker-registration-stale
表現する~sw登録:#serviceworkerregistration-service-worker-registration
swr.~scope~url:#dfn-scope-url
swr.~install中の~worker:#dfn-installing-worker
swr.待機-中の~worker:#dfn-waiting-worker
	~waiting:#dfn-waiting-worker-
swr.作動中の~worker:#dfn-active-worker
	＊作動中:#dfn-active-worker-
swr.最後の更新~検査-時刻:#dfn-last-update-check-time
swr.~cacheを介する更新~mode:#dfn-update-via-cache
swr.~back-up~task~list:#dfn-service-worker-registration-task-queue
	~task~queueたち
swr.~NavigationPreloadManager:#service-worker-registration-navigationpreloadmanager
swr.~navi~preload可能化~flag:#service-worker-registration-navigation-preload-enabled-flag
swr.~navi~preload~header値:#service-worker-registration-navigation-preload-header-value

FE.応答になり得る:#fetchevent-potential-response
FE.~enteredで応答する~flag:#fetchevent-respond-with-entered-flag
FE.~errorで応答する~flag:#fetchevent-respond-with-error-flag
FE.応答するまで待機-中~flag:#fetchevent-wait-to-respond-flag

不良な~import~script応答:#dfn-bad-import-script-response

~job:#dfn-job
job.~job種別:#dfn-job-type
job.~scope~url:#dfn-job-scope-url
job.~script~url:#dfn-job-script-url
job.~worker種別:#dfn-job-worker-type
job.~cacheを介する更新~mode:#dfn-job-update-via-cache-mode
job.~client:#dfn-job-client
job.~referrer:#job-referrer
job.~job~promise:#dfn-job-promise
job.包含している~job~queue:#dfn-containing-job-queue
job.等価~job~list:#dfn-job-list-of-equivalent-jobs
job.~cacheを迂回するよう強制する~flag:#dfn-job-force-bypass-cache-flag
job.等価である:#dfn-job-equivalent
	sub.~job:#dfn-job-equivalent
~job~queue:#dfn-job-queue

~cache~batch演算:#dfn-cache-batch-operation
cbo.種別:#dfn-cache-batch-operation-type
cbo.要請:#dfn-cache-batch-operation-request
cbo.応答:#dfn-cache-batch-operation-response
cbo.~options:#dfn-cache-batch-operation-options

~sw~client:#dfn-service-worker-client
~window~client:#dfn-window-client
専用~worker~client:#dfn-dedicatedworker-client
共用~worker~client:#dfn-sharedworker-client
~worker~client:#dfn-worker-client
破棄-済み~flag:#service-worker-client-discarded-flag

	＊~extendable:#dom-extendableevent-waituntil

~lifetimeを延長する~promiseたち:#extendableevent-extend-lifetime-promises
~lifetime~promiseを追加する:#extendableevent-add-lifetime-promise
処理待ち~promise数:#extendableevent-pending-promises-count
eX.作動中:#extendableevent-active
時間切れ~flag:#extendableevent-timed-out-flag

	他の仕様により拡張-可能:#extensibility
	~sw拡張:#extensibility
拡張:#extensibility

要請~応答~list:#dfn-request-response-list
関連な要請~応答~list:#dfn-relevant-request-response-list

名前から~cacheへの~map:#dfn-name-to-cache-map
関連な名前から~cacheへの~map:#dfn-relevant-name-to-cache-map
~scopeから登録への~map:#dfn-scope-to-registration-map
~scopeから~job~queueへの~map:#dfn-scope-to-job-queue-map

	名前→~cache~map:#dfn-name-to-cache-map
	関連な名前→~cache~map:#dfn-relevant-name-to-cache-map
	~scope→登録~map:#dfn-scope-to-registration-map
	~scope→~job~queue~map:#dfn-scope-to-job-queue-map

大域~obj:#cachestorage-global-object
~fetchを取扱う~task源:#dfn-handle-fetch-task-source
機能的~eventを取扱う~task源:#dfn-handle-functional-event-task-source

制御-:#dfn-control
利用-:#dfn-use
利用して:#dfn-use

cl.~sw~client:#dfn-service-worker-client-service-worker-client
cl.~frame種別:#dfn-service-worker-client-frame-type
cl.~sw:#_clients-service-worker

cl.生成元:#service-worker-client-origin
cl.閲覧文脈:#dfn-service-worker-client-browsing-context
cl.可視性~状態:#dfn-service-worker-client-visibilitystate
cl.~focus状態:#dfn-service-worker-client-focusstate
cl.先祖~生成元~配列:#windowclient-ancestor-origins-array

SWC.準備済み~promise:#serviceworkercontainer-ready-promise
SWC.~sw~client:#serviceworkercontainer-service-worker-client
	~associated:#serviceworkercontainer-service-worker-client-
SWC.~client~message~queue:#dfn-client-message-queue

SWG.~sw:#serviceworkerglobalscope-service-worker
SWG.~importする~script用には~cacheを迂回するよう強制する~flag:#serviceworkerglobalscope-force-bypass-cache-for-import-scripts-flag

~event~handlerを定義-:#extension-to-service-worker-global-scope

enV.~sw~obj~map:#environment-settings-object-service-worker-object-map
enV.~sw登録~obj~map:#environment-settings-object-service-worker-registration-object-map
~sw~objを取得する:#get-the-service-worker-object
~sw登録~objを取得する:#get-the-service-worker-registration-object

	●algo
~jobを作成する:#create-job
~jobを~scheduleする:#schedule-job
~jobを走らす:#run-job
~jobを完遂する:#finish-job
~job~promiseを解決する:#resolve-job-promise
~job~promiseを却下する:#reject-job-promise
登録を開始する:#start-register
登録する:#register
登録-:#register
更新する:#update
~soft更新する:#soft-update
~installする:#install
作動化する:#activate
作動化しようと試行する:#try-activate
~swを走らす:#run-service-worker
~swを終了する:#terminate-service-worker
終了-:#terminate-service-worker
終了:#terminate-service-worker

~fetchを取扱う:#handle-fetch
~eventを飛ばすべきか:#should-skip-event
機能的~eventを発火する:#fire-functional-event
~unload:#handle-service-worker-client-unload
~sw~clientを~unloadする:#handle-service-worker-client-unload
~UA~shutdownを取扱う:#handle-user-agent-shutdown
~sw延長-済み~event集合を更新する:#update-service-worker-extended-events-set
未登録に:#unregister
未登録にする:#unregister
登録を設定する:#set-registration
登録を消去する:#clear-registration
登録を消去しようと試行する:#try-clear-registration
登録の状態を更新する:#update-registration-state
~workerの状態を更新する:#update-worker-state
制御器の変化を通知する:#notify-controller-change
合致する~sw登録:#match-service-worker-registration
登録を取得する:#get-registration
最新の~workerを取得する:#get-newest-worker
~swには処理待ち~eventは無い:#service-worker-has-no-pending-events
~clientを作成する:#create-client
~window~clientを作成する:#create-window-client
~frame種別を取得する:#get-frame-type
~clientを取得する~promiseを解決する:#resolve-get-client-promise
~cacheを~queryする:#query-cache
要請は~cache済み~itemに合致するか:#request-matches-cached-item
~cache演算を~batchする:#batch-cache-operations


	●用語 基盤（INFRA/PROMISES/DOM/URL/IDL
~ASCII大小無視:~INFRA#ascii-case-insensitive
連結する:~INFRA#string-concatenate
符号単位~接頭辞:~INFRA#code-unit-prefix
	~EACH:~INFRA#map-iterate
~list:~INFRA#list
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
付加する:~INFRA#list-append
拡張する:~INFRA#list-extend
	~SET:~INFRA#map-set
~cloneする:~INFRA#list-clone
	~INFRA#list-iterate

~byte列:~INFRA#byte-sequence
	~IN:~INFRA#list-contain
~key~listを取得する:~INFRA#map-getting-the-keys
~item:~INFRA#list-item
除去する:~INFRA#list-remove
集合:~INFRA#ordered-set
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~queue:~INFRA#queue
~enqueue:~INFRA#queue-enqueue
~dequeue:~INFRA#queue-dequeue

構造体:~INFRA#struct
~pair:~INFRA#pair

有順序~map:~INFRA#ordered-map
map.~entry:~INFRA#map-entry
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
map.存在-:~INFRA#map-exists
map.除去する:~INFRA#map-remove

新たな~promise:~PROMISES#a-new-promise
変形-:~PROMISES#transforming-by
すべてを待機する~promiseを取得する:~PROMISES#waiting-for-all-promise
すべての~promiseを待機する:~PROMISES#waiting-for-all
解決する:~PROMISES#resolve-promise
却下する:~PROMISES#reject-promise
充足-時:~PROMISES#upon-fulfillment
却下-時:~PROMISES#upon-rejection
解決される~promise:~PROMISES#a-promise-resolved-with
却下される~promise:~PROMISES#a-promise-rejected-with
充足~値:~PROMISES#fulfillment-value
事由~値:~PROMISES#reason-value

~eventを作成する:~DOM4#concept-event-create
配送する:~DOM4#concept-event-dispatch
配送-~flag:~DOM4#dispatch-flag
取消d~flag:~DOM4#canceled-flag
伝播即停止~flag:~DOM4#stop-immediate-propagation-flag
伝播停止~flag:~DOM4#stop-propagation-flag
~event:~DOM4#concept-event
~event~listener:~DOM4#concept-event-listener
~eventを発火する:~DOM4#concept-event-fire
	文脈~obj:~DOM4#context-object
中止-を通達する:~DOM4#abortsignal-signal-abort

~URL:~URL1#concept-url
同等な~URL:~URL1#concept-url-equals
url.生成元:~URL1#concept-url-origin
url.~path:~URL1#concept-url-path
url.~scheme:~URL1#concept-url-scheme
url.~query:~URL1#concept-url-query
url.素片:~URL1#concept-url-fragment
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer

例外:~WEBIDL#dfn-exception
新たな例外:~WEBIDL#dfn-create-exception
~message:~WEBIDL#dfn-exception-message
	~THROW:~WEBIDL#dfn-throw
部分的~interface:~WEBIDL#dfn-partial-interface
在する:~WEBIDL#dfn-present
凍結d配列:~WEBIDL#dfn-frozen-array-type
凍結d配列を作成する:~WEBIDL#dfn-create-frozen-array

	●用語 FETCH
Rq.要請:~FETCH#concept-request-request
Rq.~Headers:~FETCH#request-headers
Rs.応答:~FETCH#concept-response-response
Rs.~Headers:~FETCH#response-headers

要請:~FETCH#concept-request
要請を~cloneする:~FETCH#concept-request-clone
rq.~cache~mode:~FETCH#concept-request-cache-mode
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.~header~list:~FETCH#concept-request-header-list
rq.起動元:~FETCH#concept-request-initiator
rq.~method:~FETCH#concept-request-method
rq.生成元:~FETCH#concept-request-origin
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.応答~tainting:~FETCH#concept-request-response-tainting
rq.置換する~client~id:~FETCH#concept-request-replaces-client-id
rq.~URL:~FETCH#concept-request-url
rq.~sw~mode:~FETCH#request-service-workers-mode
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
rq.同期~flag:~FETCH#synchronous-flag
rq.資格証利用URL~flag:~FETCH#concept-request-use-url-credentials-flag

応答:~FETCH#concept-response
rs.~CORSに公開される~header名~list:~FETCH#concept-response-cors-exposed-header-name-list
rs.~HTTPS状態:~FETCH#concept-response-https-state
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.種別:~FETCH#concept-response-type
rs.中止~flag:~FETCH#concept-response-aborted

終了された:~FETCH#concept-fetch-terminate
終了させる:~FETCH#concept-fetch-terminate

~headerを付加する:~FETCH#concept-header-list-append
hl.~guard:~FETCH#concept-headers-guard
~header~listから~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
hd.名前:~FETCH#concept-header-name
hd.値:~FETCH#concept-header-value

~header~listから値を取得する:~FETCH#concept-header-list-get

~CORS安全とされる~method:~FETCH#cors-safelisted-method
~CORS安全とされる要請~header:~FETCH#cors-safelisted-request-header

~navi要請:~FETCH#navigation-request
非~下位資源~要請:~FETCH#non-subresource-request
下位資源~要請:~FETCH#subresource-request
~naviまたは下位資源いずれかになり得る要請:~FETCH#potential-navigation-or-subresource-request

~CORS絞込み応答:~FETCH#concept-filtered-response-cors
基本~絞込み応答:~FETCH#concept-filtered-response-basic
絞込み応答:~FETCH#concept-filtered-response
内部~応答:~FETCH#concept-internal-response
不透明~redirect絞込み応答:~FETCH#concept-filtered-response-opaque-redirect
不透明な絞込み応答:~FETCH#concept-filtered-response-opaque
応答を処理する:~FETCH#process-response
応答の本体終端を処理する:~FETCH#process-response-end-of-body
~HTTPS状態~値:~FETCH#concept-https-state-value
~byte列すべてを読取る:~FETCH#concept-read-all-bytes-from-readablestream

取消す:~FETCH#concept-cancel-readablestream
~closeする:~FETCH#concept-close-readablestream
	~closeされた:~FETCH#concept-readablestream-closed
~ReadableStream~objを構築する:~FETCH#concept-construct-readablestream
妨げられて:~FETCH#concept-body-disturbed
空の~ReadableStream~obj:~FETCH#concept-empty-readablestream
~errorにする:~FETCH#concept-error-readablestream
~errorした:~FETCH#concept-readablestream-errored
~header~listから値を抽出する:~FETCH#extract-header-list-values
~fetch:~FETCH#concept-fetch
読取器を取得する:~FETCH#concept-get-reader
~header:~FETCH#concept-header
~HTTP~fetch:~FETCH#concept-http-fetch
~lockされて:~FETCH#concept-body-locked
~lockされ:~FETCH#concept-body-locked
~network~error:~FETCH#concept-network-error
~ok状態s:~FETCH#ok-status
RS.~chunkを読取る:~FETCH#concept-read-chunk-from-readablestream
RS.~enqueue:~FETCH#concept-enqueue-readablestream
本体:~FETCH#concept-body
~stream:~FETCH#concept-body-stream
名前に持つ~header:~FETCH#_headers-of-name
応答を~cloneする:~FETCH#concept-response-clone
~cache状態:~FETCH#concept-response-cache-state

	●用語 HTML

enV.~id:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker
enV.実行~準備済み~flag:~WAPI#concept-environment-execution-ready-flag
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.担当の~event-loop:~WAPI#responsible-event-loop
enV.担当の文書:~WAPI#responsible-document
enV.~API用~URL文字~符号化法:~WAPI#api-url-character-encoding
enV.~API用~基底~URL:~WAPI#api-base-url
enV.生成元:~WAPI#concept-settings-object-origin
enV.~HTTPS状態:~WAPI#https-state
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.大域~obj:~WAPI#concept-settings-object-global
enV.~Realm:~WAPI#environment-settings-object's-realm
	'
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context

~Realm:~WAPI#concept-global-object-realm
関連な~realm:~WAPI#concept-relevant-realm
古典~script:~WAPI#classic-script
現在の大域~obj:~WAPI#current-global-object
環境:~WAPI#environment
環境~設定群~obj:~WAPI#environment-settings-object
環境を破棄する手続き:~WAPI#environment-discarding-steps
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event-loop:~WAPI#event-loop
~worker用~古典~scriptを~fetchする:~WAPI#fetch-a-classic-worker-script
~module~worker~script~graphを~fetchする:~WAPI#fetch-a-module-worker-script-tree
~workerが~importした古典~scriptを~fetchする:~WAPI#fetch-a-classic-worker-imported-script
現任の設定群~obj:~WAPI#incumbent-settings-object
	i.~top-level内:~WAPI#fetching-scripts-is-top-level
	sC.~record:~WAPI#concept-script-record
~module~script:~WAPI#module-script
~fetchを遂行する:~WAPI#fetching-scripts-perform-fetch
小taskを~queueする:~WAPI#queue-a-microtask
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
	~re-queues~those~tasks:~WAPI#queue-a-task
関連な~Realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
古典~scriptを走らす:~WAPI#run-a-classic-script
~module~scriptを走らす:~WAPI#run-a-module-script
~script:~WAPI#concept-script
	＊~source~text:~WAPI#concept-classic-script-source-text
~task源:~WAPI#task-source
tK.源:~WAPI#concept-task-source
tK.手続き:~WAPI#concept-task-steps
tK.文書:~WAPI#concept-task-document
利用者~対話~task源:~WAPI#user-interaction-task-source
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue

作動中の文書:~BROWSERS#active-document
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
閲覧文脈が作成され:~BROWSERS#creating-a-new-browsing-context

破棄されて:~WINDOW#a-browsing-context-is-discarded
文書を破棄-:~WINDOW#discard-a-document
対応する閲覧文脈:~WINDOW#window-bc
wC.作成-:~WINDOW#set-up-a-window-environment-settings-object

先祖~生成元~list:~HISTORY#concept-location-ancestor-origins-list

~source閲覧文脈:~NAVI#source-browsing-context
~navigateする:~NAVI#navigate
~navigate:~NAVI#navigate
~navi:~NAVI#navigate
doc.~unload:~NAVI#unload-a-document
i.置換を可能化する:~NAVI#replacement-enabled
i.例外を可能化する:~NAVI#exceptions-enabled
~app~cache:~HTMLLS/offline.html#application-cache

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
同一-生成元:~ORIGIN#same-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
sub.生成元:#same-origin

作動中の~timer~list:~HTMLGAPI#list-of-active-timers

wG.~referrer施策:~WORKERS#concept-workerglobalscope-referrer-policy
wG.種別:~WORKERS#concept-workerglobalscope-type
wG.~url:~WORKERS#concept-workerglobalscope-url
wG.~HTTPS状態:~WORKERS#concept-workerglobalscope-https-state
wG.~close中~flag:~WORKERS#dom-workerglobalscope-closing

wG.作成-:~WORKERS#set-up-a-worker-environment-settings-object

所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set
共用~worker:~WORKERS#shared-workers
~web~worker:~WORKERS#workers
~worker大域~scopeの中に~scriptを~importする:~WORKERS#import-scripts-into-worker-global-scope
	~scriptを~worker大域~scopeの中に取込む
~workerを走らす:~WORKERS#run-a-worker


並列的:~HTMLINFRA#in-parallel
非同期に完了-:~HTMLINFRA#_asynchronously-complete

非安全~応答:~HTMLurl#unsafe-response
文書~基底~URL:~HTMLurl#document-base-url

~focusされ:~HTMLinteraction#focusing-steps
~objを~focusする:~HTMLinteraction#focusing-steps
~focusを得ている:~HTMLinteraction#has-focus-steps
利用者の作動化により誘発されて:~HTMLinteraction#triggered-by-user-activation


文書:~DOM4#concept-document

~sandbox化:~HEembed#attr-iframe-sandbox

	●用語他

~blob~URL:~FILEAPI#blob-url
~chunk:~STREAMS#chunk

jA.DetachArrayBuffer:~TC39#sec-detacharraybuffer
jA.InitializeHostDefinedRealm():~TC39#sec-initializehostdefinedrealm
jA.StructuredDeserializeWithTransfer:~HTMLcloning#structureddeserializewithtransfer
jA.StructuredSerializeWithTransfer:~HTMLcloning#structuredserializewithtransfer

~promise:~TC39#sec-promise-objects
~JS実行~文脈:~TC39#sec-execution-contexts
中途完了:~TC39#sec-completion-record-specification-type
完了~record:~TC39#sec-completion-record-specification-type
	~List:~TC39#sec-list-and-record-specification-type
		→ ~list:~INFRA#list
	~Record:~TC39#sec-list-and-record-specification-type
	~ECMAScript~6~Map~objs:~TC39#sec-map-objects

~JS~MIME型:~MIMESNIFF#javascript-mime-type

施行-:~CSP3#enforced
監視-:~CSP3#monitored

~referrer施策を構文解析する:~REFERRER-POLICY#parse-referrer-policy-from-header
~referrer施策:~REFERRER-POLICY#referrer-policy

信用に価し得る~URL:~SECURE-CONTEXT#potentially-trustworthy-url
信用に価し得る生成元か？:~SECURE-CONTEXT#potentially-trustworthy-origin
~secure文脈:~SECURE-CONTEXT#secure-contexts
	:~SECURE-CONTEXT#threat-risks
	:~SECURE-CONTEXT#localhost

	~example:~NOTIFICATIONS#activating-a-notification
	~reported~that~several属性:http://alistapart.com/article/application-cache-is-a-douchebag
	~unrecoverable~errors:http://alistapart.com/article/application-cache-is-a-douchebag#section6

r.ABNF:#biblio-rfc5234

	Notifications~API:#biblio-notifications
	Inline In Spec:#issues-index

	:https://github.com/whatwg/fetch/issues/376
	:https://developer.chrome.com/extensions/background_pages
	:https://developer.chrome.com/extensions/event_pages
	:https://w3c.github.io/ServiceWorker/v1/
	:#execution-context-events
	:https://w3c.github.io/push-api/#dfn-fire-the-push-event
	:~NOTIFICATIONS#activating-a-notification
	:~NOTIFICATIONS#closing-a-notification
	:https://wicg.github.io/BackgroundSync/spec/#fire-a-sync-event
	:https://w3c.github.io/payment-handler/#dfn-handling-a-canmakepaymentevent
	:https://w3c.github.io/payment-handler/#dfn-handling-a-paymentrequestevent

	§ 3.1.2~scriptURL:#service-worker-url

	●

●●words_table1

messageerror0:messageerror
message0:message
postMessageClient:postMessage
postMessageSW:postMessage
example-bob:www.example.com/~bob
example-alice:www.example.com/~alice

●●words_table

max:
ReadableStream:
NavigationPreloadManager:
	-:Unicode

古典:classic::~::クラシック
close:
	~close法:closing
	~close中:closing
open:
開く:openする:~
database::::データベース
dump::::
entered::::
	旧来の~event:Legacy
	機能的~event:Functional
	~lifecycle~event:Lifecycle

geolocation:
gyroscope:
id:
import:
	~import済み:imported
importScripts:
	importScripts:importscripts
log::::ログ
上位path:upper path:上位 path::上位パス

	~plugin:plug-in
schema::::スキーマ
slash::::スラッシュ
scope:
	scope::::スコープ
serviceworker:
guard::::ガード
quota::::クォータ
soft::::ソフト

	●構造／関係

container::::コンテナ
包装-:wrap::~
束ねら:tieさ::~
束ねる:tieする::~
	bound
層:layer::~
下位:sub::~
	対応-:correspond
作成元:creator::~

	●data型／操作
chunk::::チャンク
	~byte列として一致:byte-for-byte identical
	byte列:bytes
	~messageをやりとり:messaging
storage::::ストレージ
number:
parameter:
逆直列化-:deserialize::~
直列形の:serialized::~::シリアル形の
新-:new::~
作成時の:creation::~
消去-:clear::~
増分:increment::~
減分:decrement::~
連結-:concatenate::~
結合-:combine::~

	追加する:addする:付加する
	〜を成す~byte列:subsequence

	●navi／network／fetch
	~serve法:serving
tainting::::
Vary::::
http::::
load::::
port::::
Headers:
CDN:
	~HTTP／~HTTPS:HTTP(S)
https:
	~network用:networking
offline:
redirect::::リダイレクト
referrer::::リファラ
本体終端:end-of-body::~
	下位~資源:sub-resource
	非~下位資源:non-subresource
端点:endpoint::~
	〜で応答する:respond-with
絞込み:filtered::~
資格証利用URL:use-URL-credentials::URL資格証明情報-利用::URLクレデンシャル利用
unload:
	未読込みに:unload::未読み込みに
blob:
	経由して:routed through

	●保安／Realm
	~secureでない:insecure
XSS:cross-site scripting:XSS
監視-:monitor::~
	更新-済み:updated
消失-:disappear::~
脅威:threat::~
隔離-:isolate::~
	攻撃を永遠に引き伸ばす:to turn a bad day into a bad eternity

策:strategy::~
補助:auxiliary::~
現任の:incumbent::~
防御-:defend::~
directory::::ディレクトリ
硬い:hardな:~
	各区分:segments
sandbox::::サンドボックス
	~sandbox法:sandboxing

	●処理
機能的:functional::~
	機能し続ける:remain functional
commit::::コミット
back-up:
batch::::バッチ
cast:
	~catchされなかった:uncaught
dummy::::
install::::
installation::::
job:
kill:
lifecycle:
lifetime:
none::なし
ok:
options:::option 集
pipe::::パイプ
preload::::
restart::::
schedule::::スケジュール
shutdown::::
	単~threadの:single-threaded
timer::::タイマー
延長-:extend::~
延長:extension::~
	延長-済み:extended
	延命
処理待ち:pending::~
決着-:settle::~
	決着していない:pending
	ABRUPT:Rethrow any exceptions
	~~手続き的:procedural
動作者:actor::~
同時的:concurrent::~
	:completion
失効-:expire::~
実行時:runtime::~
待機:waiting::~
	待機-中の:waiting
中止:aborted::~
冗長:redundant::~
入口:entry point::~
伝播即停止:stop immediate propagation::~
伝播停止:stop propagation::~
過去評価済み:has ever been evaluated::~
終了-:terminate::~
終了:termination::~
進行中の:ongoing::~
	追跡し放題になり得る:potential unsanctioned tracking
	追跡できる:may be tracked at 
	:invocation
回復-:recover::~
	回復-不能:unrecoverable
不可分的:atomic::~
小task:microtask:小 task:小タスク
準備済み:ready::~
迂回-:bypass::~
妨げら:disturbさ::~
読取器:reader::読み取り器
読取る:readする::読み取る
制御器:controller::~
変形-:transform::~
生存-:alive::~
	生存し続け:keep-alive
時間:time::~
時間切れ:timed out::~
時刻:time::~
時間制限付き:time-limited:~
機会:opportunity::~
復旧-:restore::~
持続-:persist::~
持続的:persistent::~
中途完了:abrupt completion::~
再始動:restart:~
期限切れの:outdated:~
近過去:recent:~
一掃-:purge:~
予備:backup::~
退避:backup::~
巻戻す:roll backする:巻き戻す
非新鮮:stale::~
具体:concrete:~

	却下-時:upon rejection
	同時に:simultaneous
	配送-後:post-dispatch
	阻むこと:blocking
	他を阻む:blocking
	待機を飛ばす:skip waiting
	早々に ~RETする:enforces early return
	最初期:very first
	滅する:die
	外でも生きられる:may outlive
	渡せる／渡して／渡され:pass

	●仕様
選択肢:option:~
	:optional
有効:effective:~
有意味な:meaningful:意味のある
即応的:responsive:~
後継:successor:~
現象:phenomenon:~
柔軟性:flexibility:~
異常:abnormal:~
馴染みの:familiarな:~
馴染んで:familiarで:~
細分化:ramifications:~
協同:collaboration:~
傾向:tend:~
根拠:rationale:~
独特:unique:~

	前方-互換にする:forward compatibility across
	不良でない:good
	program的:programmatical
	可能性／可能性もある:possibilities／possible
	なり得る／:potential
	必要性:necessity
	~~足らない:deficit of
	比して:versus
	付き物の~~障害:hazards
	と引き換えに at the price of
	読者:reader
	~~高度に:highly
	頭に入れておく:keep in mind
	満たす:satisfy
	不利な所:place 〜at a disadvantage
	不利を塗り替える:redress this balance
	限るようにする:make sure
	得られるようにする:enables applications to take
	決定可能な:deterministically
	至る所で:pervade
	面し:face
	大きな糧に:borrows heavily from
	~~同等以上のもの:bear more than a passing resemblance to
	留意-:note
	~~重点:key
	~~主要:key
	学び:lesson
	最も懸案:top-of-mind
	sure
	下位節:subsections
	sw:Service Worker

	●仕様（動詞
寄与-:contribute:~
未実装の:unimplemented:~
未利用の:unused:~
制限:limitation:~
懸念点:concerns:~
昇格:upgrade::~
	~~昇格:promote
警告:warning:~
運用-:operate:~
	ずに済む:avoid
相対性:relativity:~
相互運用-:interoperate:~
観測-可能:observable:~
解く:solveする:~
解決策:solution:~
保つ:keepする:~
利点:advantage:~
高度な:advanced:~
温存-:conserve:~
起因-:arise:~
遂げる:attainする:~
助ける:helpする:~
分類:category:~

	応じて:depend
	により定義される:-defined
	~~進行中の:advancing
	~~強調-:accentuate
	多用する:use ~ heavily
	勧める:advised to
	捉えれる:can be thought of
	必要がある:implies

	●未分類（動詞
アタれ:consultでき:あたれ
派生-:derive::~
在する:presentする:在る
	伴わせる:present
書込-:write::書き込み
	ε:omitted
超過-:exceed::~
遭遇-:encounter::~
生きた:living::~
発行-:make::~
接頭-:prefix::~
改築-:architect::~
	改築し直す:re-architecting
集中型の:centralized:~
聴取-:audit:~
喪失:loss:~

	置いて:put
	予約-済み:reserved
	~debugし易くする:aid debugging
	座して:sits in
	〜になる:progress
	選ぶ:choose
	come
	met
	note
	put

	●未分類
refresh:
bootstrap:
main::::メイン
総和:sum::~
特性:property::~
非安全:unsafe::~
無限:infinite::~
同等:equal:~
	等し:equal
背景:background::~
administrator::::サーバ管理者
高価:expensive::~

memory::::メモリー
disk::::ディスク

	-:exactly what
	等:or equivalent
	末尾:end〜trailing
	-:byte-to-byte
	旧:old

	~~広範な:broad class
	~~付随:attach
	-:back of
	-:balance
	~~視界が~~開ける:coast is 〜 clear
	^en:head-of-line blocking
	~GOTO:Jump to the step labeled
	秒:second
	秒間に何度も:many times second
	利用した~scriptたち:usedSet
	`undefined^jv:undefined
	〜外に:off-〜
	~path構造に:path-structural
	で区切って:separated from each other by
	〜側の:-side
	価しない:Not Trusted
	壊れた:broke／broken
	山括弧:angle brackets
	-:undo
	委ねられ:resorting
	~~指示する:denote
	最終的に:eventually 
	旧来の~event:Legacy
	機能的~event:Functional
	~lifecycle~event:Lifecycle
	-:placed before／:placed first／:placed next
	~WHILE:repeatedly
	^en:spin-off
	作成されることになる:to-be-created
	-:unassociate
	:long

	●指示語
首な:primaryな:主な
首に:primaryに:主に
	首に:primarily
	新たな:newly created
最新の:newest::~
最新:newest::~

	-:original
	概ね:more or less
	多様な:many sorts of
	いくつかの:some
	後続の:subsequent
	一種:type
	互いに別々の:separated
	間に狭んで:put 〜 between
	いくつ〜も:many
	最大:maximum
	から来た:come~from
	外にある
	この類の:sort of
	向けての:toward
	いつでも:at 〜 any time
	以前／従来／これまで／:previous
	時点:moment
	それ自体:in and of itself
	再び:re-
	一部:part of
	初回:first time
	まったく:ever
	~per
	ほぼ:nearly
	neither
	nor
	now
	〜外にある:off-
	他所:other places
	rest
	幅広く:largely:#1
	全体を通して:throughout
	ほぼすべて:almost entirely
	毎回:every time
	何度でも:as often as it likes
	-:remaining
	を~~対象に:against
	またがって:across
	後続してsubsequently
	いずれにせよ:anyway
	まるごと／全体的にentirely
	類似する:similar
	後続の／従って:following
	広範な:a range of
	早々に:early
	上端:top
	下位:sub
	頭部:beginning
	頭部:starting
	の頭部は〜に一致する:starts with
	個数／〜数:count
	最長の:longest
	大多数の:major
	残り:rest

	●変数
	%~target~Realm:targetRealm
	%~cacheは存在する:cacheExists
	%~cacheを介する更新:updateViaCache
	%~cache名:cacheName
	%~cache済み~URL:cachedURL
	%~cache済み応答:cachedResponse
	%~cache済み要請:cachedRequest
	%~event構築子:eventConstructor
	%初期化:initialization
	%配送-後~手続き:postDispatchSteps
	%~client~URL:clientURL
	%~client~URL文字列:clientURLString
	%~client~obj:clientObject
	%~clientは列挙-可能:isClientEnumerable
	%~dummy~stream:dummyStream
	%~event:e
	%~eventは取消された:eventCanceled
	%~event型:eventType
	%~event名:eventName
	%~fetchを取扱うのに失敗した:handleFetchFailed
	%~https状態:httpsState
	%~install中の~worker:installingWorker
	%~installに失敗した:installFailed
	%~job:Job
	%~job型:jobType
	%最大~scope:maxScope
	%最大~scope文字列:maxScopeString
	-:messageClone
	%~navigateに失敗した:navigateFailed
	%~navi~preload応答:navigationPreloadResponse
	%~preload応答~promise:preloadResponse
	%~preload応答~obj:preloadResponseObject
	%~preload要請:preloadRequest
	%~preload要請~headerたち:preloadRequestHeaders
	%~promise:Promise
	%~realm実行~文脈:realmExecutionContext
	%~referrer施策:referrerPolicy
	%~scope~URL:scopeURL
	%~scope文字列:scopeString
	%~scope文字列~集合:scopeStringSet
	%~script~URL:scriptURL
	%~source設定群:sourceSettings
	%~sw:serviceWorker
	%~target~clientたち:targetClients
	%~target~client:targetClient
	%~target~storage:targetStorage
	-:thisArgument
	%~window~client:windowClient
	%~windowを開くのに失敗した:openWindowFailed
	%~worker~event-loop:workerEventLoop
	%~worker~objたち:workerObjects
	%~worker~obj:workerObject
	%~worker種別:workerType
	%~worker大域~scope:workerGlobalScope
	%~sw大域~scope:serviceWorkerGlobalScope
	%予約-済み~client:reservedClient
	%作動中の~worker:activeWorker
	%合致した~clientたち:matchedClients
	%合致している~scope:matchingScope
	%合致している~scope文字列:matchingScopeString
	%大域~obj:globalObject
	%応答たち／%応答~list:responses
	%応答~obj~list:responseList
	%~enteredで応答する:respondWithEntered
	%応答~promise:responsePromise
	%応答~配列~promise:responseArrayPromise
	%応答になり得る:potentialResponse
	%新-~stream:newStream
	%新-文脈:newContext
	%-:newPorts
	%最新~worker:newestWorker
	%最後の~job:lastJob
	%合致した:isMatched
	%登録~objたち:registrationObjects
	%登録~obj:registrationObject
	%等価な~job:equivalentJob
	%結果~promise:resultPromise
	%結果~配列:resultArray
	%要請~URL:requestURL
	%要請~URL文字列:requestURLString
	%要請~応答:requestResponse
	%要請~応答~配列:requestResponseArray
	%要請たち:requests
	%内縁~要請:innerRequest
	%設定群~obj:settingsObject
	%設定群~objたち:settingsObjects
	%許容される~sw:serviceWorkerAllowed
	%直列形の転送-結果:serializeWithTransferResult
	%追加される~itemたち:addedItems
	%逆直列化-~record:deserializeRecord
	%演算たち:operations
	%演算:operation
	%-:convertedValue
	%等価な~job:equivalentJob
	%可視性~状態:visibilityState
	%~focus状態:focusState
	%先祖~生成元~list:ancestorOriginsList
	%閲覧文脈:browsingContext
	%要請~応答:requestResponse
	%予備~cache:backupCache
	%~client~objたち:clientObjects
	%要請~list:requestList
	%~cache~job~promise:cacheJobPromise
	%~error~data:errorData
	非同期~拡張を待機する:WaitForAsynchronousExtensions
	%資源を更新した:hasUpdatedResources
	%ある~prop名:propertyName
	%別の~prop名:%anotherPropertyName
	%~sw登録:serviceWorkerRegistration
	%配送した~event:dispatchedEvent
	%限界水位:highWaterMark
	%~size~algo:sizeAlgorithm
	%走らせた結果:runResult
	%~obj~map:objectMap
	%現任の大域~obj:incumbentGlobal
	%評価~状態s:evaluationStatus
	%開始-に失敗した:startFailed
	%~soft更新すべき:shouldSoftUpdate
	%~cacheを迂回するよう強制する:forceBypassCache

●●ref_normative

[CSP-3]
    Content Security Policy Level 3 URL: https://www.w3.org/TR/CSP3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FileAPI]
    Marijn Kruisselbrink; Arun Ranganathan. File API. 31 May 2019. WD. URL: https://www.w3.org/TR/FileAPI/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[PAGE-VISIBILITY]
    Jatinder Mann; Arvind Jain. Page Visibility (Second Edition). 29 October 2013. REC. URL: https://www.w3.org/TR/page-visibility/ 
[PROMISES-GUIDE]
    Domenic Denicola. Writing Promise-Using Specifications. 9 November 2018. TAG Finding. URL: https://www.w3.org/2001/tag/doc/promises-guide 
[REFERRER-POLICY]
    Jochen Eisinger; Emily Stark. Referrer Policy. 26 January 2017. CR. URL: https://www.w3.org/TR/referrer-policy/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC5234]
    D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234 
[RFC7230]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html 
[RFC7231]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7231.html 
[SECURE-CONTEXTS]
    Mike West. Secure Contexts. 15 September 2016. CR. URL: https://www.w3.org/TR/secure-contexts/ 
[STREAMS]
    Adam Rice; Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[UNSANCTIONED-TRACKING]
    Unsanctioned Web Tracking. 17 July 2015. Finding of the W3C TAG. URL: https://www.w3.org/2001/tag/doc/unsanctioned-tracking/ 

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Service Worker</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/service-workers/

最新の課題
	<a href="https://github.com/w3c/ServiceWorker/issues/">GitHub</a>

編集
	<a href="mailto:slightlyoff@chromium.org">Alex Russell</a> (Google)
	<a href="mailto:jungkee.song@microsoft.com">Jungkee Song</a> (Microsoft‚ represented Samsung until April 2018)
	<a href="mailto:jakearchibald@chromium.org">Jake Archibald</a> (Google)
	<a href="mailto:mek@chromium.org">Marijn Kruisselbrink</a> (Google)

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/service-workers">web-platform-tests service-workers/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/service-workers">ongoing work</a>)

バージョン履歴
	https://github.com/w3c/ServiceWorker/commits/master

</script>

</head>

<body>

<header>
	<hgroup>
<h1>Service Workers Nightly</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、［
~web~appが，持続的な背景~処理の利点を得られるようにする
］ための~methodを述べる
— ~offlineにある間に~bootstrapするのを可能化する~hookも含め。
◎
This specification describes a method that enables applications to take advantage of persistent background processing, including hooks to enable bootstrapping of web applications while offline.
</p>

<p>
この~systemを成す中核は、~swと呼ばれる
— 文書や他の~sourceから配送される~eventに応答するような，~event駆動な`~web~worker$ —
であり，［
~installation, ~version, 昇格
］を管理するための~systemを供する。
◎
The core of this system is an event-driven Web Worker, which responds to events dispatched from documents and other sources. A system for managing installation, versions, and upgrades is provided.
</p>

<p>
~swは、~Web~platformにおける~event駆動な背景~処理~用の，汎用の入口である
— <a href="#extensibility">他の仕様が拡張できる</a>ような。
◎
The service worker is a generic entry point for event-driven background processing in the Web Platform that is extensible by other specifications.
</p>

	</section>
	<section id="status">
~STATUSofTHIS

<p>
これは編集者草案の公の複製です…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<!-- 

This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at https://www.w3.org/TR/.

This document was published by the Service Workers Working Group as an Editors Draft. This document is intended to become a W3C Recommendation.

This is a living document. Readers need to be aware that this specification may include unimplemented features, and details that may change. Service Workers 1 is a version that is advancing toward a W3C Recommendation.

Feedback and comments on this specification are welcome, please send them to public-webapps@w3.org (subscribe, archives) with [service-workers] at the start of your email’s subject.

Publication as an Editors Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.

This document was produced by a group operating under the W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 March 2017 W3C Process Document.

 -->

<p><strong>
この文書の変更点は
<a href="https://github.com/w3c/ServiceWorker">https://github.com/w3c/ServiceWorker</a>
にて追跡できる。
</strong>
◎
Changes to this document may be tracked at https://github.com/w3c/ServiceWorker.
</p>

<p>
この仕様について論点は
<a href="https://github.com/w3c/ServiceWorker/issues">GitHub issues</a>
が選好される。
<a href="http://lists.w3.org/Archives/Public/public-webapps/">historical mailing-list archive</a>
もある。
◎
GitHub issues are preferred for discussion of this specification. There is also a historical mailing-list archive.
</p>

<p>
これは “生きた文書” である。
読者は、この仕様が［
未実装の特能も含み得ること／
詳細が変更され得ること
］を自覚しておく必要がある。
<a href="https://w3c.github.io/ServiceWorker/v1/">Service Workers 1</a>
は、 W3C 勧告へ至るべく~~進行中の~versionである。
◎
This is a living document. Readers need to be aware that this specification may include unimplemented features, and details that may change. Service Workers 1 is a version that is advancing toward a W3C Recommendation.
</p>

	</section>

<main id="MAIN0">

	<section id="motivations">
<h2 title="Motivations">1. 動機</h2>

~INFORMATIVE

<p>
伝統的に，~web~appは、~platformの至る所で ~networkは到達-可能であると見做す。
伝統的に，~HTML文書は、~HTTP越しに読込まれ，その下位~資源すべてを後続の~HTTP要請を介して~fetchする。
~web内容が他の技術~stackに比して不利な点は、ここにある。
◎
Web Applications traditionally assume that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally fetch all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.
</p>

<p>
`~sw$は，首に、［
~naviが生じつつあるとき，実行時に開始できる~web~worker文脈
］を供することにより，この不利を塗り替えるべく設計されている。
この，~event駆動な~workerは、生成元と~path（または【~pathが合致するための】~pattern）を~~対象に登録される
— すなわち、~~対象にされた所在への~naviが生じるときには，~workerにアタれることを意味する。
~network要請に対応する~eventは，この~workerへ配送され、この~workerにより生成された応答は，~network~stackの既定の挙動を上書きできる。
これは，概念的には、~networkと文書~具現化器の間に`~sw$を狭んで、~offlineにある間でも，`~sw$が文書~用の内容を供することを可能にする。
【言い換えれば、局所的に稼働する~proxy~serverのようなものである。】
◎
The service worker is designed first to redress this balance by providing a Web Worker context, which can be started by a runtime when navigations are about to occur. This event-driven worker is registered against an origin and a path (or pattern), meaning it can be consulted when navigations occur to that location. Events that correspond to network requests are dispatched to the worker and the responses generated by the worker may override default network stack behavior. This puts the service worker, conceptually, between the network and a document renderer, allowing the service worker to provide content for documents, even while offline.
</p>

<p>
~offline問題を従来の試みにより解くことに馴染んでいた~web開発者たちは、その種の解決策に柔軟性が~~足らないことを報告した。
その結果として、最大の柔軟性を開発者に供するため，`~sw$は~~高度に~~手続き的になっている
— 追加的な複階性と引き換えに。
この複階性の一部は、単~threadの実行~modelに面したときでも，`~sw$を即応的に保つ必要があることに起因する。
結果として，`~sw$により公開される~APIは、他の~JS文脈において馴染みの~patternではあるが，ほぼすべて非同期的である
— ここに~~強調されるように，［
文書を阻む／資源を読込む
］ことを避ける必要があるので。
◎
Web developers familiar with previous attempts to solve the offline problem have reported a deficit of flexibility in those solutions. As a result, the service worker is highly procedural, providing a maximum of flexibility at the price of additional complexity for developers. Part of this complexity arises from the need to keep service workers responsive in the face of a single-threaded execution model. As a result, APIs exposed by service workers are almost entirely asynchronous, a pattern familiar in other JavaScript contexts but accentuated here by the need to avoid blocking document and resource loading.
</p>

<p>
`~app~cache$の設計は，
<a href="http://alistapart.com/article/application-cache-is-a-douchebag#section6">回復-不能な~error</a>
に寄与するような いくつかの属性を備えていることが、開発者から
<a href="http://alistapart.com/article/application-cache-is-a-douchebag">報告されている</a>。
`~sw$は、~errorは <em>常に</em> 回復-可能とする原則を~~重点に設計されている。
`~sw$の更新-処理-を成す詳細の多くは、これらに付き物の~~障害を避けるよう設計されている。
◎
Developers using the HTML5 Application Cache have also reported that several attributes of the design contribute to unrecoverable errors. A key design principle of the service worker is that errors should always be recoverable. Many details of the update process of service workers are designed to avoid these hazards.
</p>

<p>
`~sw$は、［
文書ではなく，~event
］との関係性に基づいて，開始され, 生存し続ける。
この設計は、`共用~worker$と
<a href="https://developer.chrome.com/extensions/background_pages">Chrome Background Pages</a>
における 開発者や~vendorの経験を大きな糧にしている。
これらの~systemから得られた~~主要な学びは、背景~処理~文脈の実行~時間を制限することの必要性である
— 開発者に最も懸案される［
資源を温存することと，背景~文脈の喪失と再始動
］の両立を確保するために。
結果として，`~sw$は、［
Background Pages の後継である
<a href="https://developer.chrome.com/extensions/event_pages">Chrome Event Page</a>
］に~~同等以上のものになっている。
~UAは、`~sw$を，<em>文書が~~付随していなくとも</em>開始してヨイし, ほぼいつでも~killしてヨイ。
`~sw$は、概念的には，文書からの~messageを まったく取扱わずに［
開始して, ~eventを処理して, 滅する
］ことが可能な共用~workerと捉えれる。
開発者は、［
`~sw$は，秒間に何度も開始され, ~killされ得る
］ことを頭に入れておくことを勧める。
◎
Service workers are started and kept alive by their relationship to events, not documents. This design borrows heavily from developer and vendor experience with Shared Workers and Chrome Background Pages. A key lesson from these systems is the necessity to time-limit the execution of background processing contexts, both to conserve resources and to ensure that background context loss and restart is top-of-mind for developers. As a result, service workers bear more than a passing resemblance to Chrome Event Pages, the successor to Background Pages. Service workers may be started by user agents without an attached document and may be killed by the user agent at nearly any time. Conceptually, service workers can be thought of as Shared Workers that can start, process events, and die without ever handling messages from documents. Developers are advised to keep in mind that service workers may be started and killed many times a second.
</p>

<p>
`~sw$は、生成元において，［
汎用の, ~event駆動な, 時間制限付き
］で走るような~script文脈である。
これらの特性により，~swは、特定0の文書の文脈の外でも生きられるような，広範な実行時~service用の自然な端点になる
— 例えば、［
~push通知を取扱う／
背景~dataと同期する／
他の生成元からの資源~要請に応答する／
計算が高価な~dataによる集中型の更新を受信する
］など（例：~geolocationや~gyroscope）。
◎
Service workers are generic, event-driven, time-limited script contexts that run at an origin. These properties make them natural endpoints for a range of runtime services that may outlive the context of a particular document, e.g. handling push notifications, background data synchronization, responding to resource requests from other origins, or receiving centralized updates to expensive-to-calculate data (e.g., geolocation or gyroscope).
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
［
~EQ／~NEQ 
］に添えられる
`生成元@sub
は、`同一-生成元$による比較に基づくとする。
</p>

<!-- ＊
<p>
特に断らない限り、~algoの中で，~APIの~IDL［
~method／構築子
］ %m を呼出すときは、 %m に定義されている~algoを直に呼出すとする
— 単に， “%m を遂行する”, 等々と記される。
~methodの場合、 `Call$sl 内部~methodの `this^jv 引数には文脈~obj（此れ）を渡すとする。）
</p>
-->

	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>

		<section id="service-worker-concept">
<h3 title="Service Worker">2.1. ~sw</h3>

<p>
`~sw@
は，`~web~worker$の一種であり、それを登録している`~sw~client$の`生成元$cl【！`生成元$】において実行される。
◎
A service worker is a type of web worker. A service worker executes in the registering service worker client's origin.
</p>

<p>
各`~sw$には、以下のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`状態@sw</dt>
	<dd>
次のいずれか【括弧内は訳者補足】
⇒＃
`parsed^l （構文解析-済み）／
`installing^l （~install中） ／
`installed^l （~install済み） ／
`activating^l （作動化-中） ／
`activated^l （作動化-済み）／
`redundant^l （冗長）
◎
A service worker has an associated state, which is one of "parsed", "installing", "installed", "activating", "activated", and "redundant".＼
</dd>
	<dd>
初期~時には `parsed^l とする。
◎
It is initially "parsed".
</dd>

	<dt>`~script~url@sw</dt>
	<dd>
`~URL$。
◎
A service worker has an associated script url (a URL).
</dd>

	<dt>`種別@sw</dt>
	<dd>
次のいずれか
⇒
`classic^l ／ `module^l
◎
A service worker has an associated type which is either "classic" or "module".＼
</dd>
	<dd>
他が言明されない限り，  `classic^l とする
◎
Unless stated otherwise, it is "classic".
</dd>

	<dt>`包含している~sw登録@sw</dt>
	<dd>
この~swを包含している，`~sw登録$。
◎
A service worker has an associated containing service worker registration (a service worker registration), which contains itself.
</dd>
	<dd class="trans-note">【
これが具体的にどう［
定義-／決定-／設定-
］されるかは、この仕様には述べられていない。
この~swが，ある~sw登録の［
`~install中の~worker$swr／`待機-中の~worker$swr／`作動中の~worker$swr
］であるときの、その~sw登録を指すように見受けられる（該当し得る記述は他に見当たらない）。
】</dd>

	<dt>`大域~obj@sw</dt>
	<dd>
`ServiceWorkerGlobalScope$I ~obj, または ~NULL
◎
A service worker has an associated global object (a ServiceWorkerGlobalScope object or null).
</dd>
	<dd class="trans-note">【
~accessされる前に，（この`~swを走らす$ときに）非 ~NULL に設定される（ ~NULL をとるのは初期~時に限られるようだ）。
】</dd>

	<dt>`~script資源@sw</dt>
	<dd>
<p>
`~script$
— 
この~swの自前の~script資源を表現する。
◎
A service worker has an associated script resource (a script), which represents its own script resource.＼
</dd>
	<dd>
<p>
初期~時には ~NULL とする。
◎
It is initially set to null.
</p>

<p>
各`~script資源$swには、以下のものが結付けられる：
◎
↓</p>
		<dl class="def-list">
			<dt>`過去評価済み~flag@sw</dt>
			<dd>
真偽値をとり，初期~時には ~F とする。
◎
A script resource has an associated has ever been evaluated flag. It is initially unset.
</dd>

			<dt>`~HTTPS状態@sw</dt>
			<dd>
`~HTTPS状態~値$。
◎
A script resource has an associated HTTPS state (an HTTPS state value).＼
</dd>
			<dd>
初期~時には `none^l とする。
◎
It is initially "none".
</dd>

			<dt>`~referrer施策@sw</dt>
			<dd>
`~referrer施策$。
◎
A script resource has an associated referrer policy (a referrer policy).＼
</dd>
	<dd>
初期~時には空~文字列とする。
◎
It is initially the empty string.
</dd>
		</dl>
	</dd>

	<dt>`~script資源~map@sw</dt>
	<dd>
`有順序~map$であり，それを成す各~entryは［
`~URL$ → `応答$
］を与える。
◎
A service worker has an associated script resource map which is an ordered map where the keys are URLs and the values are responses.
</dd>

	<dt>`利用した~scriptの集合@sw</dt>
	<dd>
`集合$であり，それを成す各`~item$は`~URL$を与える。
◎
A service worker has an associated set of used scripts (a set) whose item is a URL.＼
</dd>
	<dd>
初期~時には新たな`集合$とする。
◎
It is initially a new set.
</dd>
	<dd class="note">注記：
`利用した~scriptの集合$swは、［
更新~検査の間に旧~workerの~mapに基づいて拡充された，新たな~workerの~map
］から［
その~installation後に未利用の資源を刈り取る
］ために限り利用される。
◎
Note: The set of used scripts is only used to prune unused resources from a new worker’s map after installation, that were populated based on the old worker’s map during the update check.
</dd>

	<dt>`待機を飛ばす~flag@sw</dt>
	<dd>
真偽値をとり，他が言明されない限り ~F とする。
◎
A service worker has an associated skip waiting flag. Unless stated otherwise it is unset.
</dd>

	<dt>`古典~script~import済み~flag@sw</dt>
	<dd>
真偽値をとり，初期~時には ~F とする。
◎
A service worker has an associated classic scripts imported flag. It is initially unset.
</dd>

	<dt>`取扱う~event型の集合@sw</dt>
	<dd>
`~event~listener$の~event型たちからなる`集合$。
◎
A service worker has an associated set of event types to handle (a set) whose item is an event listener’s event type.＼
</dd>
	<dd>
初期~時には新たな`集合$とする。
◎
It is initially a new set.
</dd>

	<dt>`延長-済み~event集合@sw</dt>
	<dd>
`ExtendableEvent$I たちからなる`集合$。
◎
A service worker has an associated set of extended events (a set) whose item is an ExtendableEvent.＼
</dd>
	<dd>
初期~時には新たな`集合$とする。
◎
It is initially a new set.
</dd>

	<dt>`開始-状態@</dt>
	<dd>
~NULL または`Completion$
◎
A service worker has an associated start status which can be null or a Completion.＼
	<dd>
初期~時には ~NULL とする。
◎
It is initially null.
</dd>
</dl>

<p>
`~sw$は、その`~event-loop$が走っているとき，
`走っている@
という。
◎
A service worker is said to be running if its event loop is running.
</p>

			<section id="service-worker-lifetime">
<h4 title="Lifetime">2.1.1. ~lifetime</h4>

<p>
`~sw$の~lifetimeは、一連の~eventが成す実行~lifetimeに束ねられる
— `~sw~client$が保持する `ServiceWorker$I ~objへの参照ではなく。
◎
The lifetime of a service worker is tied to the execution lifetime of events and not references held by service worker clients to the ServiceWorker object.
</p>

<p>
~UAは、次に該当するときは，いつでも`~sw$を`終了-$してヨイ：
◎
A user agent may terminate service workers at any time it:
</p>

<ul>
	<li>
取扱う~eventがないとき。
◎
Has no event to handle.
</li>
	<li>
異常な演算を検出したとき
— 無限~loopがあるとき，あるいは［
~eventを取扱っている間に，課されている時間~制限-を超過する
］ような~taskがあるとき。
◎
Detects abnormal operation: such as infinite loops and tasks exceeding imposed time limits (if any) while handling the events.
</li>
</ul>

			</section>
			<section id="service-worker-events">
<h4 title="Events">2.1.2. ~event</h4>

<p>
~sw仕様は、
`~sw~event@
として，次に挙げる`~event$を定義する（<a href="#execution-context-events">一覧</a>を見よ）：
◎
The Service Workers specification defines service worker events (each of which is an event) that include (see the list):
</p>

<ul>
	<li>
`~lifecycle~event@
⇒
`install$et,
`activate$et
◎
Lifecycle events: install and activate.
</li>
	<li>
`機能的~event@
⇒
`fetch$et,
~sw仕様を<a href="#extensibility">拡張する</a>他の仕様により定義される`~event$（<a href="#execution-context-events">一覧</a>を見よ）
◎
Functional events: fetch and the events defined by other specifications that extend the Service Workers specification. (See the list.)
</li>
	<li>
`message$et,
`messageerror$et
◎
message and messageerror.
</li>
</ul>

			</section>
		</section>
		<section id="service-worker-registration-concept">
<h3 title="Service Worker Registration">2.2. ~sw登録</h3>

<p>
`~sw登録@
は、`~scope~url$swr, および一式の`~sw$
— `~install中の~worker$swr, `待機-中の~worker$swr, `作動中の~worker$swr —
からなる~tupleである。
◎
A service worker registration is a tuple of a scope url and a set of service workers, an installing worker, a waiting worker, and an active worker.＼
</p>

<p>
~UAは、同じ生成元の中で，`~sw登録$を何個でも可能化してヨイ
— それらの`~scope~url$swrが，互いに相違する限りにおいて。
`~sw登録$は、その`~scope~url$swrが~UA内に既存の`~sw登録$のそれと一致するときには，既存の`~sw登録$を置換することになる。
◎
A user agent may enable many service worker registrations at a single origin so long as the scope url of the service worker registration differs. A service worker registration of an identical scope url when one already exists in the user agent causes the existing service worker registration to be replaced.
</p>

<p>
各`~sw登録$には、以下のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~scope~url@swr</dt>
	<dd>
`~URL$。
◎
A service worker registration has an associated scope url (a URL).
</dd>

	<dt>`~install中の~worker@swr</dt>
	<dd>
~NULL, または［
`状態$sw ~EQ `installing^l
］なる`~sw$。
◎
A service worker registration has an associated installing worker (a service worker or null) whose state is "installing".＼
</dd>
	<dd>
初期~時には ~NULL とする。
◎
It is initially set to null.
</dd>

	<dt>`待機-中の~worker@swr</dt>
	<dd>
~NULL, または［
`状態$sw ~EQ `installed^l
］なる`~sw$。
◎
A service worker registration has an associated waiting worker (a service worker or null) whose state is "installed".＼
</dd>
	<dd>
初期~時には ~NULL とする。
◎
It is initially set to null.
</dd>

	<dt>`作動中の~worker@swr</dt>
	<dd>
~NULL, または［
`状態$sw ~IN { `activating^l, `activated^l }
］なる`~sw$。
◎
A service worker registration has an associated active worker (a service worker or null) whose state is either "activating" or "activated".＼
</dd>
	<dd>
初期~時には ~NULL とする。
◎
It is initially set to null.
</dd>

	<dt>`最後の更新~検査-時刻@swr</dt>
	<dd>
初期~時には ~NULL とする。
◎
A service worker registration has an associated last update check time. It is initially set to null.
</dd>
	<dd>
`~sw登録$が
`非新鮮@
であるとは、この句が評価される時点で，次が満たされることを意味する
⇒
［
`最後の更新~検査-時刻$swr ~NEQ ~NULL
］~AND［
現在の時刻 ~GT `最後の更新~検査-時刻$swr ~PLUS 86400 秒
］
◎
A service worker registration is said to be stale if the registration’s last update check time is non-null and the time difference in seconds calculated by the current time minus the registration’s last update check time is greater than 86400.
</dd>

	<dt>`~cacheを介する更新~mode@swr</dt>
	<dd>
次のいずれか
⇒＃
`imports^l,
`all^l,
`none^l
◎
A service worker registration has an associated update via cache mode, which is "imports", "all", or "none".＼
</dd>
	<dd>
初期~時には `imports^l とする。
◎
It is initially set to "imports".
</dd>

	<dt>`~back-up~task~list@swr</dt>
	<dd>
［
この`~sw登録$にて`作動中の~worker$swrの`~event-loop$
］に属する`~task~queue$からの`~task$たちを，~back-upする。
この~listが~back-upするのは、［
`~fetchを取扱う~task源$／`機能的~eventを取扱う~task源$
］から~queueされた~taskに限られる。
◎
A service worker registration has one or more task queues that back up the tasks from its active worker’s event loop’s corresponding task queues. (The target task sources for this back up operation are the handle fetch task source and the handle functional event task source.)＼
</dd>
	<dd class="trans-note">【
この用語は、原文では
“~task源ごとに仕分けられる，いくつかの~task~queue”
として定義されているが、この訳では，単独の~listに改めている
— どの~taskも その`源$tKが当の~task源を保持するので，ここで仕分ける必要はないことに加え、これは単なる~back-up用の~listであり，`~task~queue$ではないので。
（それに伴い，この用語が利用される箇所も 原文と等価になるよう変形している。）
】</dd>
	<dd>
~UAは、`作動中の~worker$swrが`終了-$されたとき，~workerの`~task$たちを`~back-up~task~list$swrに~dumpした上で、~workerが再び立ち上がった（ `spin-off^en した）ときには，~dumpされた~taskたちを［
%~worker の`~event-loop$に属する，各~taskの`源$tKに対応している`~task~queue$
］に~queueし直すことになる。
【！ 不要 Unlike the task queues owned by event loops, ...】
◎
The user agent dumps the active worker’s tasks to the service worker registration's task queues when the active worker is terminated and re-queues those tasks to the active worker’s event loop’s corresponding task queues when the active worker spins off. Unlike the task queues owned by event loops, the service worker registration's task queues are not processed by any event loops in and of itself.
</dd>

	<dt>`~NavigationPreloadManager@swr</dt>
	<dd>
`NavigationPreloadManager$I ~obj。
【各 `~sw登録$と一対一に対応する。】
◎
A service worker registration has an associated NavigationPreloadManager object.
</dd>

	<dt>`~navi~preload可能化~flag@swr</dt>
	<dd>
真偽値をとり，初期~時には ~F とする。
◎
A service worker registration has an associated navigation preload enabled flag. It is initially unset.
</dd>

	<dt>`~navi~preload~header値@swr</dt>
	<dd>
`~byte列$。
◎
A service worker registration has an associated navigation preload header value, which is a byte sequence.＼
</dd>
	<dd>
初期~時には `true^bl とする。
◎
It is initially set to `true`.
</dd>
</dl>

<p>
次を満たす`~sw登録$ %登録 は、
`未登録にされて@
いるとされる
⇒
`~scopeから登録への~map$[ %登録 の`~scope~url$swr ] ~NEQ %登録
◎
A service worker registration is said to be unregistered if scope to registration map[this service worker registration's scope url] is not this service worker registration.
</p>

			<section id="service-worker-registration-lifetime">
<h4 title="Lifetime">2.2.1. ~lifetime</h4>

<p>
~UAは、`登録-$された`~sw登録$たちが成す~listを持続的に保つモノトスル
— 明示的に`未登録にされて$いない限り。
~UAは、`~scopeから登録への~map$を持つ
— その各~entryは［
`~URLを直列化する$( `~sw登録$の`~scope~url$swr ) → `~sw登録$
］を格納する。
`~sw登録$ %登録 の~lifetimeは、
%登録 を表現する `ServiceWorkerRegistration$I ~objの~lifetimeを超える
— 後者の~lifetimeは、 %登録 に対応している`~sw~client$の~lifetimeに限られる。
◎
A user agent must persistently keep a list of registered service worker registrations unless otherwise they are explicitly unregistered. A user agent has a scope to registration map that stores the entries of the tuple of service worker registration's scope url, serialized, and the corresponding service worker registration. The lifetime of service worker registrations is beyond that of the ServiceWorkerRegistration objects which represent them within the lifetime of their corresponding service worker clients.
</p>

			</section>
		</section>
		<section id="service-worker-client-concept">
<h3 title="Service Worker Client">2.3. ~sw~client</h3>

<p>
`~sw~client@
は、`環境$である。
◎
A service worker client is an environment.
</p>

<p>
各`~sw~client$には、真偽値をとる
`破棄-済み~flag@
が結付けられる。
初期~時には ~F とする。
◎
A service worker client has an associated discarded flag. It is initially unset.
</p>

<div class="algorithm">
<p>
`~sw~client$ %~client の`環境を破棄する手続き$は、次を走らすとする：
◎
Each service worker client has the following environment discarding steps:
</p>

<ol>
	<li>
%~client の`破棄-済み~flag$ ~SET ~T
◎
Set client’s discarded flag.
</li>
</ol>

<p class="note">注記：
実装は、`破棄-済み~flag$ ~EQ ~T になった~clientを破棄できる。
◎
Note: Implementations can discard clients whose discarded flag is set.
</p>
</div>

<div class="algorithm">
<p>
`~sw~client$ %~client の
`生成元@cl
は、 %~client に応じて，次を返す
⇒＃
`環境~設定群~obj$であるならば %~client の`生成元$enV ／
~ELSE_ %~client の`作成時の~URL$enVの`生成元$url
◎
A service worker client has an algorithm defined as the origin that returns the service worker client's origin if the service worker client is an environment settings object, and the service worker client's creation URL’s origin otherwise.
</p>
</div>

<p>
`~sw~client$は、その`大域~obj$enVに応じて：
</p>

<ul>
	<li>
`Window$I ~objであるならば
`~window~client@
と称される。
◎
A window client is a service worker client whose global object is a Window object.
</li>
	<li>
`DedicatedWorkerGlobalScope$I ~objであるならば
`専用~worker~client@
と称される。
◎
A dedicated worker client is a service worker client whose global object is a DedicatedWorkerGlobalScope object.
</li>
	<li>
`SharedWorkerGlobalScope$I ~objであるならば
`共用~worker~client@
と称される。
◎
A shared worker client is a service worker client whose global object is a SharedWorkerGlobalScope object.
</li>
</ul>

<p>
`~worker~client@
は、［
`専用~worker~client$, `共用~worker~client$
］の総称である。
◎
A worker client is either a dedicated worker client or a shared worker client.
</p>

		</section>
		<section id="control-and-use">
<h3 title="Control and Use">2.4. 制御と利用</h3>

<p>
`~sw~client$ %~client にて`作動中の~sw$enVは、自前の読込ng, およびその下位資源を~serveする。
%~client にて`作動中の~sw$enVが ~NULL でないとき、 %~client は
`作動中の~sw$enVにより
`制御-@
されているという。
%~client が，ある`~sw$により`制御-$されているとき、
%~client は`~sw$を`包含している~sw登録$swを
`利用して@
いるという。
%~client にて`作動中の~sw$enVは、以下の各~下位節にて説明されるように決定される。
◎
A service worker client has an active service worker that serves its own loading and its subresources. When a service worker client has a non-null active service worker, it is said to be controlled by that active service worker. When a service worker client is controlled by a service worker, it is said that the service worker client is using the service worker’s containing service worker registration. A service worker client's active service worker is determined as explained in the following subsections.
</p>

<p class="trans-note">【
すなわち，次の 3 つの句は、同じことを，主語と目的語を入れ替えて表している
】
⇒＃
“%~sw は %~client を制御している”,
“%~client は %登録 を利用している”,
“%登録 は %~sw を包含している”
</p>

<p>
`この節の残りは規範的でない^em。
◎
The rest of the section is non-normative.
</p>

<p class="issue">
この節における挙動は、まだ全部的に指定されておらず，
<a href="https://html.spec.whatwg.org">~HTML標準</a>
にて指定されることになる。
その作業は、
`765$issue,
<a href="https://github.com/whatwg/html/pull/2809">pull request</a>
にて追跡されている。
◎
The behavior in this section is not fully specified yet and will be specified in HTML Standard. The work is tracked by the issue and the pull request.
</p>

			<section id="control-and-use-window-client">
<h4 title="The window client case">2.4.1. ~window~client事例</h4>

<p>
`~window~client$は、次のいずれかのとき，`作成-$wCされる：
◎
A window client is created when a browsing context is created and when it navigates.
</p>

<ul>
	<li>
<p>
新たな`閲覧文脈が作成され$るとき
— このときの，`~window~client$にて`作動中の~sw$enVは、次に従って設定される：
◎
When a window client is created in the process of a browsing context creation:
</p>
		<ol>
			<li>
`閲覧文脈$の［
初期~時の`作動中の文書$
］の`生成元$は`不透明な生成元$である場合
⇒
~NULL
◎
If the browsing context's initial active document's origin is an opaque origin, the window client's active service worker is set to null.＼
</li>
			<li>
他の場合
⇒
作成元`文書$†の`~sw~client$にて`作動中の~sw$enV
◎
Otherwise, it is set to the creator document's service worker client's active service worker.
</li>
		</ol>

【† すなわち、`閲覧文脈が作成され$るときに渡された %作成元 】

	</li>
	<li>
<p>
`閲覧文脈$が`~navigate$されるとき
— このときの，`~window~client$にて`作動中の~sw$enVは、次に従って設定される：
◎
When a window client is created in the process of the browsing context's navigation:
</p>

		<ol>
			<li>
その`~fetch$が`~HTTP~fetch$を経由しているならば
⇒
`合致する~sw登録$【の`作動中の~worker$swrに設定されることになる~sw？】
◎
If the fetch is routed through HTTP fetch, the window client's active service worker is set to the result of the service worker registration matching.＼
</li>
			<li>
他の場合，作成された`文書$の`生成元$は`不透明な生成元$であるならば
⇒
~NULL
◎
Otherwise, if the created document's origin is an opaque origin＼
</li>
			<li>
他の場合，［
( 作成された`文書$の`生成元$, その作成元`文書$†の`生成元$ )
は`同一-生成元$でない
］ならば
⇒
~NULL
◎
or not the same as its creator document's origin, the window client's active service worker is set to null.＼
</li>
			<li>
他の場合
⇒
その作成元`文書$†の`~sw~client$にて`作動中の~sw$enV
◎
Otherwise, it is set to the creator document's service worker client's active service worker.
</li>
		</ol>

【† すなわち、`~source閲覧文脈$にて`作動中の文書$】

	</li>
</ul>

<p class="note">注記：
`置換を可能化する$i下で行われる初期`~navi$用には、［
`閲覧文脈が作成され$たとき`作成-$wCされた初期`~window~client$
］が再利用されるが，`作動中の~sw$enVは上と同じ挙動により決定される。
◎
Note: For an initial navigation with replacement enabled, the initial window client that was created when the browsing context was created is reused, but the active service worker is determined by the same behavior as above.
</p>

<p class="note">注記：
`~sandbox化$された `iframe^e が~sandbox法~指令［
`allow-same-origin^dir, `allow-scripts^dir
］を伴わない場合、その`生成元$は`不透明な生成元$になるので，`作動中の~sw$enVは ~NULL になる。
◎
Note: Sandboxed iframes without the sandboxing directives, allow-same-origin and allow-scripts, result in having the active service worker value of null as their origin is an opaque origin.
</p>

			</section>
			<section id="control-and-use-worker-client">
<h4 title="The worker client case">2.4.2. ~worker~client事例</h4>

<p>
`~worker~client$は、~UAが`~workerを走らす$ときに`作成-$wGされる。
◎
A worker client is created when the user agent runs a worker.
</p>

<p>
`~worker~client$が作成されるときの，`作動中の~sw$enVは、次に従って設定される：
◎
When the worker client is created:
</p>

<ol>
	<li>
その`~fetch$が`~HTTP~fetch$を経由しているならば
⇒
`合致する~sw登録$【の`作動中の~worker$swrに設定されることになる~sw？】
◎
When the fetch is routed through HTTP fetch, the worker client's active service worker is set to the result of the service worker registration matching.＼
</li>
	<li>
他の場合，`~worker~client$の`生成元$clは`不透明な生成元$であるならば
⇒
~NULL
◎
Otherwise, if the worker client's origin is an opaque origin,＼
</li>
	<li>
他の場合，［
その`要請$の`~URL$rqは`~blob~URL$である
］~AND［
( `~worker~client$の`生成元$cl, `~worker~client$の`大域~obj$の`所有者~集合$の最後の~itemの`生成元$ )
は`同一-生成元$でない
］ならば
⇒
~NULL
◎
or the request's URL is a blob URL and the worker client's origin is not the same as the origin of the last item in the worker client's global object's owner set, the worker client's active service worker is set to null.＼
</li>
	<li>
他の場合
⇒
`~worker~client$の`大域~obj$の`所有者~集合$の最後の`~item$の`環境~設定群~obj$にて`作動中の~sw$enV
◎
Otherwise, it is set to the active service worker of the environment settings object of the last item in the worker client's global object's owner set.
</li>
</ol>

			</section>

<p class="note">注記：
<a href="~IETF/rfc2397#section-2">`data:^c ~URL</a>
を伴う［
`~window~client$／`~worker~client$
］に対しては、その`生成元$は`不透明な生成元$になるので，`作動中の~sw$enVは ~NULL になる。
`~blob~URL$を伴う［
`~window~client$／`~worker~client$
］は，その［
作成元`文書$／所有者
］から`作動中の~sw$enVを継承し得るが、`要請$の`生成元$rqが［
作成元`文書$／所有者
］の`生成元$と`同一-生成元$でない場合，`作動中の~sw$enVは ~NULL に設定される。
◎
Note: Window clients and worker clients with a data: URL result in having the active service worker value of null as their origin is an opaque origin. Window clients and worker clients with a blob URL can inherit the active service worker of their creator document or owner, but if the request's origin is not the same as the origin of their creator document or owner, the active service worker is set to null.
</p>

		</section>
		<section id="task-sources">
<h3 title="Task Sources">2.5. ~task源</h3>

<p>
`~sw$は、次の`~task源$も追加的に利用する：
◎
The following additional task sources are used by service workers.
</p>

<dl>
	<dt>
`~fetchを取扱う~task源@
◎
The handle fetch task source
</dt>
	<dd>
この`~task源$は、 `fetch$et ~eventを`~sw$に`配送する$ときに利用される。
◎
This task source is used for dispatching fetch events to service workers.
</dd>

	<dt>
`機能的~eventを取扱う~task源@
◎
The handle functional event task source
</dt>
	<dd>
この`~task源$は、他の`機能的~event$ を`配送する$特能~用に利用される
— 例： `~sw$向けの `push$et ~event。
◎
This task source is used for features that dispatch other functional events, e.g. push events, to service workers.
</dd>
	<dd class="note">注記：
~UAは、各~機能的~event型ごとに，別々の~task源を利用してもヨイ
— ある種の機能的~eventに対する `head-of-line blocking^en 現象†を避けるためとして。
【†長い~taskにより後続の~taskが~~渋滞する現象】
【！~RFC7230#section-6.4】
◎
Note: A user agent may use a separate task source for each functional event type in order to avoid a head-of-line blocking phenomenon for certain functional events.
</dd>
</dl>

		</section>
		<section id="user-agent-shutdown">
<h3 title="User Agent Shutdown">2.6. ~UA~shutdown</h3>

<p>
~UAは、複数回の再始動にまたがって，自身が格納している`~sw登録$たちの状態を，次の規則の下で保守するモノトスル：
◎
A user agent must maintain the state of its stored service worker registrations across restarts with the following rules:
</p>

<ul>
	<li>
`~install中の~worker$swrは、持続することなく破棄する。
それが`~sw登録$用の唯一の`~sw$であった場合、その登録も破棄する。
◎
An installing worker does not persist but is discarded. If the installing worker was the only service worker for the service worker registration, the service worker registration is discarded.
</li>
	<li>
`待機-中の~worker$swrは、`作動中の~worker$swrに~~昇格する。
◎
A waiting worker promotes to an active worker.
</li>
</ul>

<p>
これを遂げるため，~UAは、自身が終了するときには，次を呼出すモノトスル
⇒
`~UA~shutdownを取扱う$()
◎
To attain this, the user agent must invoke Handle User Agent Shutdown when it terminates.
</p>

		</section>
	</section>
	<section id="document-context">
<h2 title="Client Context">3. ~client文脈</h2>

<div class="example">

<p>
~swで~bootstrapする例：
◎
Bootstrapping with a service worker:
</p>

<pre>
/* <span class="comment">
既定の~scopeは、当の~scriptが座している~path
— この例では `/^l —
になる
◎
scope defaults to the path the script sits in "/" in this example
</span> */
navigator.`serviceWorker$n.`register$n("/serviceworker.js").then(%registration =&gt; {
  console.log("success!");
  if (%registration.`ServiceWorkerRegistration^I1`installing$m1) {
    %registration.installing.`~postMessageSW$n("Howdy from your installing page.");
  }
}, %err =&gt; {
  console.error("Installing the worker failed!", %err);
});
</pre>

</div>

		<section id="serviceworker-interface">
<h3>3.1. `ServiceWorker^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `ServiceWorker@I : `EventTarget$I {
  readonly attribute `USVString$ `scriptURL$m;
  readonly attribute `ServiceWorkerState$I `state$m;
  void `postMessage$m(any %message, sequence&lt;`object$&gt; %transfer);
  void `~postMessageSW$n(any %message, optional `PostMessageOptions$I %options = {});

  // event
  attribute `EventHandler$I `onstatechange$m;
};
`ServiceWorker$I includes `AbstractWorker$I;

enum `ServiceWorkerState@I {
  "`parsed@m",
  "`installing@m",
  "`installed@m",
  "`activating@m",
  "`activated@m",
  "`redundant@m"
};
</pre>

<p>
`ServiceWorker$I ~objは、ある`~sw$を表現する。
いくつかの文書や~workerにまたがって，同時に複数の `ServiceWorker$I ~objが同じ`~sw$を表現し得る。
◎
A ServiceWorker object represents a service worker. Each ServiceWorker object is associated with a service worker. Multiple separate objects implementing the ServiceWorker interface across documents and workers can all be associated with the same service worker simultaneously.
</p>

<p>
`ServiceWorkerState$I 列挙は、`~sw$がとり得る`状態$swを表現し，`~workerの状態を更新する$ときに利用される。
◎
A ServiceWorker object has an associated ServiceWorkerState object which is itself associated with service worker's state.
</p>

`ServiceWorker^I0

			<section id="service-worker-creation">
<h4 title="Getting ServiceWorker instances">3.1.1. `ServiceWorker^I ~instanceを取得する</h4>

<p>
各 `環境~設定群~obj$は、
`~sw~obj~map@enV
を持つ
— それは`有順序~map$であり，それを成す各`~entry$mapは［
`~sw$ → `ServiceWorker$I ~obj
］を与える。
◎
An environment settings object has a service worker object map, a map where the keys are service workers and the values are ServiceWorker objects.
</p>

<div class="algorithm">

<p>
（ある環境~内で~swを表現している）
`~sw~objを取得する@
ときは、所与の
( `~sw$ %~sw, `環境~設定群~obj$ %環境 )
に対し，次を走らす：
◎
To get the service worker object representing serviceWorker (a service worker) in environment (an environment settings object), run these steps:
</p>

<ol>
	<li>
%~obj~map ~LET %環境 の`~sw~obj~map$enV
◎
Let objectMap be environment’s service worker object map.
</li>
	<li>
<p>
~IF［
%~obj~map[ %~sw ] ~EQ ε
］：
◎
If objectMap[serviceWorker] does not exist, then:
</p>
		<ol>
			<li>
%~sw~obj ~LET %環境 の`~Realm$enV内の，新たな `ServiceWorker$I
◎
Let serviceWorkerObj be a new ServiceWorker in environment’s Realm,＼
</li>
			<li>
%~sw~obj に %~sw を結付ける
【 %~sw~obj は %~sw を “表現する” 】
◎
and associate it with serviceWorker.
</li>
			<li>
%~sw~obj の `state$m ~SET %~sw の`状態$sw
◎
Set serviceWorkerObj’s state to serviceWorker’s state.
</li>
			<li>
%~obj~map[ %~sw ] ~SET %~obj
◎
Set objectMap[serviceWorker] to serviceWorkerObj.
</li>
		</ol>
	</li>
	<li>
~RET %~obj~map[ %~sw ]
◎
Return objectMap[serviceWorker].
</li>
</ol>
</div>

			</section>
			<section id="service-worker-url">
<h4>3.1.2. `scriptURL@m</h4>

<p>
取得子は、次の結果を返すモノトスル
⇒
`~URLを直列化する$( 此れが表現する`~sw$の`~script~url$sw )
◎
The scriptURL attribute must return the service worker's serialized script url.
</p>

<div class="example">

<p>
例えば
`https://example.com/app.html^c
への~naviにより作成される文書を考える
— それは、以前に次の登録~callが実行されていて，`合致する~sw登録$があるとする：
◎
For example, consider a document created by a navigation to https://example.com/app.html which matches via the following registration call which has been previously executed:
</p>

<pre>
/* <span class="comment">
~page `https://example.com/app.html^c 上の~script
◎
Script on the page https://example.com/app.html
</span> */
navigator.`serviceWorker$n.`register$n("/service_worker.js");
</pre>

<p>
`navigator.serviceWorker.controller.scriptURL^c の値は
`https://example.com/service_worker.js^l 
になる。
◎
The value of navigator.serviceWorker.controller.scriptURL will be "https://example.com/service_worker.js".
</p>

</div>

			</section>
			<section id="service-worker-state">
<h4>3.1.3. `state@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
最後に設定された（ `ServiceWorkerState$I 列挙~型の）値
【この値は、此れが表現する`~sw$の`状態$swを反映する。】
◎
The state attribute must return the value (in ServiceWorkerState enumeration) to which it was last set.
</p>

			</section>
			<section id="service-worker-postmessage">
<h4>3.1.4. `postMessage(message, transfer)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The postMessage(message, transfer) method must run these steps:
</p>

<ol>
	<li>
%options ~LET «[ `transfer^l → %transfer ]»
◎
Let options be «[ "transfer" → transfer ]».
</li>
	<li>
此れ上で `~postMessageSW(message, options)$n （次節）の~algoを遂行する
◎
Invoke postMessage(message, options) with message and options as the arguments.
</li>
</ol>

			</section>
			<section id="service-worker-postmessage-options">
<h4>3.1.5. `~postMessageSW(message, options)@n</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The postMessage(message, options) method must run these steps:
</p>

<ol>
	<li>
%~sw ~LET 此れが表現している`~sw$
◎
Let serviceWorker be the service worker represented by the context object.
</li>
	<li>
%現任の設定群 ~LET `現任の設定群~obj$
◎
Let incumbentSettings be the incumbent settings object.
</li>
	<li>
%現任の大域~obj ~LET %現任の設定群 の`大域~obj$enV
◎
Let incumbentGlobal be incumbentSettings’s global object.
</li>
	<li>
%直列形の転送-結果 ~LET 
~ABRUPT `StructuredSerializeWithTransfer$jA( %message, %options.`transfer^m )
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, options.transfer). Rethrow any exceptions.
</li>
	<li>
~IF［
`~eventを飛ばすべきか$( `message^l, %~sw ) ~EQ ~T
］
⇒
~RET
◎
If the result of running the Should Skip Event algorithm with "message" and serviceWorker is true, then return.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
~IF［
`~swを走らす$( %~sw ) ~EQ `失敗^i
］
⇒
~RET
◎
If the result of running the Run Service Worker algorithm with serviceWorker is failure, then return.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き )：
◎
Queue a task on the DOM manipulation task source to run the following steps:
</p>
				<ol>
					<li>
<p>
%~source ~LET %現任の大域~obj の型に応じて，次で決定される~obj：
◎
Let source be determined by switching on the type of incumbentGlobal:
</p>
						<dl class="switch">
							<dt>`ServiceWorkerGlobalScope$I</dt>
							<dd>
`~sw~objを取得する$( %現任の大域~obj の`~sw$SWG, %~sw の`大域~obj$swに`関連な設定群~obj$ )
◎
The result of getting the service worker object that represents incumbentGlobal’s service worker in the relevant settings object of serviceWorker’s global object.
</dd>

							<dt>`Window$I</dt>
							<dd>
%現任の大域~obj に`関連な設定群~obj$を表現する，新たな `WindowClient$I ~obj
◎
a new WindowClient object that represents incumbentGlobal’s relevant settings object.
</dd>

							<dt>その他</dt>
							<dd>
%現任の大域~obj に結付けられている~workerを表現する，新たな `Client$I ~obj
◎
a new Client object that represents incumbentGlobal’s associated worker
</dd>
						</dl>
					</li>
					<li>
%生成元 ~LET `生成元を直列化する$( %現任の設定群 の`生成元$enV )
◎
Let origin be the serialization of incumbentSettings’s origin.
</li>
					<li>
%行先 ~LET %~sw に結付けられている `ServiceWorkerGlobalScope$I 【 %~sw の`大域~obj$sw】
【！上で`~swを走らす$ときに作成され得る／ %行先 の`~sw$SWG ~EQ %~sw 】
◎
Let destination be the ServiceWorkerGlobalScope object associated with serviceWorker.
</li>
					<li>
<p>
%逆直列化-~record ~LET
`StructuredDeserializeWithTransfer$jA( %直列形の転送-結果, %行先 に`関連な~Realm$ )
</p>

<p>
例外が投出されたときは、~catchして：
</p>
						<ol>
							<li>
%行先 に向けて，名前 `messageerror$et の`~eventを発火する$
— `MessageEvent$I を利用し，次のように初期化して
⇒＃
`origin$n 属性 ~SET %生成元,
`source$n 属性 ~SET %~source
</li>
							<li>
~RET
</li>
						</ol>
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, destination’s Realm).
◎
If this throws an exception, catch it, fire an event named messageerror at destination, using MessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source, and then abort these steps.
</li>
					<li>
%e ~LET `~eventを作成する$( `ExtendableMessageEvent$I )
◎
↓</li>
					<li>
%新たな~portたち ~LET
【 %行先 に`関連な~Realm$内で】
`凍結d配列を作成する$( %逆直列化-~record . `TransferredValues^sl 内のすべての `MessagePort$I ~objからなる同順の~list )
◎
Let messageClone be deserializeRecord.[[Deserialized]].
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.
</li>
					<li>
%e の各種~属性を次のように初期化する
⇒＃
`type$n 属性 ~SET `message$et,
`ExtendableMessageEvent^I1`origin$m1 属性 ~SET %生成元,
`source$m1 属性 ~SET %~source,
`data$m1 属性 ~SET %逆直列化-~record . `Deserialized^sl,
`ports$m1 属性 ~SET %新たな~portたち
◎
Let e be the result of creating an event named message, using ExtendableMessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.
</li>
					<li>
%行先 に向けて， %e を`配送する$
◎
Dispatch e at destination.
</li>
					<li>
`~sw延長-済み~event集合を更新する$( %~sw, %e )
◎
Invoke Update Service Worker Extended Events Set with serviceWorker and e.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="service-worker-event-handler">
<h4 title="Event handler">3.1.6. ~event~handler</h4>

<p>
どの `ServiceWorker$I ~objも、次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported, as event handler IDL attributes, by all objects implementing ServiceWorker interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody>
<tr><td>`onstatechange@m
<td>`statechange$et

</tbody></table>

			</section>
		</section>
		<section id="serviceworkerregistration-interface">
<h3>3.2. `ServiceWorkerRegistration^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `ServiceWorkerRegistration@I : `EventTarget$I {
  readonly attribute `ServiceWorker$I? `installing$m;
  readonly attribute `ServiceWorker$I? `waiting$m;
  readonly attribute `ServiceWorker$I? `active$m;
  [`SameObject$] readonly attribute `NavigationPreloadManager$I `navigationPreload$m;

  readonly attribute `USVString$ `scope$m;
  readonly attribute `ServiceWorkerUpdateViaCache$I `updateViaCache$m;

  [`NewObject$] Promise&lt;void&gt; `update$m();
  [`NewObject$] Promise&lt;`boolean$&gt; `unregister$m();

  // event
  attribute `EventHandler$I `onupdatefound$m;
};

enum `ServiceWorkerUpdateViaCache@I {
  "`imports@m",
  "`all@m",
  "`none@m"
};

</pre>

<p>
各 `ServiceWorkerRegistration$I ~objは、ある`~sw登録$を表現する。
それを指して，~objが
`表現する~sw登録@
という。
◎
A ServiceWorkerRegistration has a service worker registration (a service worker registration).
</p>

<p class="trans-note">【
所与の~sw登録を表現する `ServiceWorkerRegistration^I ~objは， 1 つに限られないが、同じ`~Realm$（環境~設定群~obj）内では 1 つに限られる。
】</p>

`ServiceWorkerRegistration^I0


			<section id="service-worker-registration-creation">
<h4 title="Getting ServiceWorkerRegistration instances">3.2.1. `ServiceWorkerRegistration^I ~instanceの取得-法</h4>

<p>
各 `環境~設定群~obj$は、
`~sw登録~obj~map@enV
を持つ
— それは`有順序~map$であり，それを成す各`~entry$mapは［
`~sw登録$ → `ServiceWorkerRegistration$I ~obj
］を与える。
◎
An environment settings object has a service worker registration object map, a map where the keys are service worker registrations and the values are ServiceWorkerRegistration objects.
</p>

<div class="algorithm">
<p>
（ある環境~内で~sw登録を表現している）
`~sw登録~objを取得する@
ときは、所与の
( `~sw登録$ %登録, `環境~設定群~obj$ %環境 )
に対し，次を走らす：
◎
To get the service worker registration object representing registration (a service worker registration) in environment (an environment settings object), run these steps:
</p>
<ol>
	<li>
%~obj~map ~LET %環境 の`~sw登録~obj~map$enV
◎
Let objectMap be environment’s service worker registration object map.
</li>
	<li>
<p>
~IF［
%~obj~map[ %登録 ] ~EQ ε
］：
◎
If objectMap[registration] does not exist, then:
</p>
		<ol>
			<li>
%登録~obj ~LET %環境 の`~Realm$enV内の，新たな `ServiceWorkerRegistration$I
◎
Let registrationObject be a new ServiceWorkerRegistration in environment’s Realm.
</li>
			<li>
%登録~obj が`表現する~sw登録$ ~SET %登録
◎
Set registrationObject’s service worker registration to registration.
</li>
			<li>
%登録~obj の
⇒＃
`installing$m 属性 ~SET ~NULL,
`waiting$m 属性 ~SET ~NULL,
`active$m 属性 ~SET ~NULL
◎
Set registrationObject’s installing attribute to null.
◎
Set registrationObject’s waiting attribute to null.
◎
Set registrationObject’s active attribute to null.
</li>
			<li>
~IF［
%登録 の`~install中の~worker$swr ~NEQ ~NULL
］
⇒
%登録~obj の `installing$m 属性 ~SET
`~sw~objを取得する$( %登録 の`~install中の~worker$swr, %環境 )
◎
If registration’s installing worker is not null, then set registrationObject’s installing attribute to the result of getting the service worker object that represents registration’s installing worker in environment.
</li>
			<li>
~IF［
%登録 にて`待機-中の~worker$swr ~NEQ ~NULL
］
⇒
%登録~obj の `waiting$m 属性 ~SET
`~sw~objを取得する$( %登録 にて`待機-中の~worker$swr, %環境 )
◎
If registration’s waiting worker is not null, then set registrationObject’s waiting attribute to the result of getting the service worker object that represents registration’s waiting worker in environment.
</li>
			<li>
~IF［
%登録 にて`作動中の~worker$swr ~NEQ ~NULL
］
⇒
%登録~obj の `active$m 属性 ~SET
`~sw~objを取得する$( %登録 にて`作動中の~worker$swr, %環境 )
◎
If registration’s active worker is not null, then set registrationObject’s active attribute to the result of getting the service worker object that represents registration’s active worker in environment.
</li>
			<li>
%~obj~map[ %登録 ] ~SET %登録~obj
◎
Set objectMap[registration] to registrationObject.
</li>
		</ol>
	</li>
	<li>
~RET %~obj~map[ %登録 ]
◎
Return objectMap[registration].
</li>
</ol>
</div>

			</section>
			<section id="navigator-service-worker-installing">
<h4>3.2.2. `installing@m</h4>

<p>
取得子は、最後に設定された値を返すモノトスル。
【~NULL でなければ`~install中の~worker$swrを表現する】
◎
installing attribute must return the value to which it was last set.
</p>

<p class="note">注記：
同じ`~Realm$enVの中では、同じ`~sw$を表現する `ServiceWorker$I ~objは，一つに限られる。
◎
Note: Within a Realm, there is only one ServiceWorker object per associated service worker.
</p>

			</section>
			<section id="navigator-service-worker-waiting">
<h4>3.2.3. `waiting@m</h4>

<p>
取得子は、最後に設定された値を返すモノトスル。
【~NULL でなければ`待機-中の~worker$swrを表現する】
◎
waiting attribute must return the value to which it was last set.
</p>

<p class="note">注記：
同じ`~Realm$enVの中では、同じ`~sw$を表現する `ServiceWorker$I ~objは，一つに限られる。
◎
Note: Within a Realm, there is only one ServiceWorker object per associated service worker.
</p>

			</section>
			<section id="navigator-service-worker-active">
<h4>3.2.4. `active@m</h4>

<p>
取得子は、最後に設定された値を返すモノトスル。
【~NULL でなければ`作動中の~worker$swrを表現する】
◎
active attribute must return the value to which it was last set.
</p>

<p class="note">注記：
同じ`~Realm$enVの中では、同じ`~sw$を表現する `ServiceWorker$I ~objは，一つに限られる。
◎
Note: Within a Realm, there is only one ServiceWorker object per associated service worker.
</p>

			</section>
			<section id="service-worker-registration-navigationpreload">
<h4>3.2.5. `navigationPreload@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れが`表現する~sw登録$の`~NavigationPreloadManager$swr
◎
The navigationPreload attribute must return service worker registration's NavigationPreloadManager object.
</p>

			</section>
			<section id="service-worker-registration-scope">
<h4>3.2.6. `scope@m</h4>

<p>
取得子は、次の結果を返すモノトスル
⇒
`~URLを直列化する$( 此れが`表現する~sw登録$の`~scope~url$swr )
◎
The scope attribute must return service worker registration's serialized scope url.
</p>

<div class="example">

<p>
例えば、 `ServiceWorker^I1`scriptURL$m1 節の例においては、
</p>

<pre>
navigator.serviceWorker.ready.then(%registration =&gt; console.log(%registration.scope))
</pre>

<p>
から得られる `registration.scope^c の値は、
`https://example.com/^l
になる。
</p>
◎
In the example in § 3.1.2 scriptURL, the value of registration.scope, obtained from navigator.serviceWorker.ready.then(registration =&gt; console.log(registration.scope)) for example, will be "https://example.com/".
</div>

			</section>
			<section id="service-worker-registration-updateviacache">
<h4>3.2.7. `updateViaCache@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れが`表現する~sw登録$の`~cacheを介する更新~mode$swr
◎
The updateViaCache attribute must return service worker registration's update via cache mode.
</p>

			</section>
			<section id="service-worker-registration-update">
<h4>3.2.8. `update()@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
update() method must run these steps:
</p>

<ol>
	<li>
%登録 ~LET 此れが`表現する~sw登録$
◎
Let registration be the service worker registration.
</li>
	<li>
%最新~worker ~LET
`最新の~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as its argument.
</li>
	<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
~RET `InvalidStateError$E 例外で`却下される~promise$
◎
If newestWorker is null, return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
	<li>
%大域~obj ~LET 此れに`関連な設定群~obj$の`大域~obj$enV
</li>
	<li>
~IF［
%大域~obj は `ServiceWorkerGlobalScope$I ~objである
］~AND［
%大域~obj の`~sw$SWGの`状態$sw ~EQ `installing^l
］
⇒
~RET `InvalidStateError$E 例外で`却下される~promise$
◎
If the context object’s relevant settings object’s global object globalObject is a ServiceWorkerGlobalScope object, and globalObject’s associated service worker's state is "installing", return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a promise.
</li>
	<li>
%~job ~LET `~jobを作成する$( 次に挙げる引数 )
⇒＃
`更新する^i,
%登録 の`~scope~url$swr,
%最新~worker の`~script~url$sw,
%~promise,
此れに`関連な設定群~obj$
◎
Let job be the result of running Create Job with update, registration’s scope url, newestWorker’s script url, promise, and the context object’s relevant settings object.
</li>
	<li>
%~job の`~worker種別$job ~SET %最新~worker の`種別$sw
◎
Set job’s worker type to newestWorker’s type.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-unregister">
<h4>3.2.9. `unregister()@m</h4>

<p class="note">注記：
この~methodは、`~sw登録$を未登録にする。
［［［
現在`制御-$されている`~sw~client$
］にて`作動中の~sw$enV
］を`包含している~sw登録$sw
］は、この`~sw登録$を利用しているすべての`~sw~client$（自身を含めて）が~unloadされるまで，有効になることに注意。
すなわち， `unregister()$m ~methodが影響するのは、後続の`~navi$に限られる。
◎
Note: The unregister() method unregisters the service worker registration. It is important to note that the currently controlled service worker client's active service worker's containing service worker registration is effective until all the service worker clients (including itself) using this service worker registration unload. That is, the unregister() method only affects subsequent navigations.
</p>

<p>
被呼出時には、次を走らすモノトスル：
◎
unregister() method must run these steps:
</p>

<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~job ~LET `~jobを作成する$( 次に挙げる引数 )
⇒＃
`未登録にする^i,
此れが`表現する~sw登録$の`~scope~url$swr,
~NULL,
%~promise,
此れに`関連な設定群~obj$
◎
Let job be the result of running Create Job with unregister, the scope url of the service worker registration, null, promise, and the context object’s relevant settings object.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="service-worker-registration-event-handler">
<h4 title="Event handler">3.2.10. ~event~handler</h4>

<p>
どの `ServiceWorkerRegistration$I ~objも、次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported, as event handler IDL attributes, by all objects implementing ServiceWorkerRegistration interface:
</p>

<table><thead>

<tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onupdatefound@m
<td>`updatefound$et

</tbody></table>

			</section>
		</section>
		<section id="navigator-serviceworker">
<h3>3.3. `serviceWorker^m</h3>

<pre class="idl">
partial interface `Navigator$I {
  [`SecureContext$, `SameObject$] readonly attribute `ServiceWorkerContainer$I `serviceWorker$n;
};

partial interface `WorkerNavigator$I {
  [`SecureContext$, `SameObject$] readonly attribute `ServiceWorkerContainer$I `serviceWorker$n;
};
</pre>

<p>
`serviceWorker@n
取得子は、次を返すモノトスル
⇒
此れに結付けられている `ServiceWorkerContainer$I ~obj
◎
The serviceWorker attribute must return the ServiceWorkerContainer object that is associated with the context object.
</p>

		</section>
		<section id="serviceworkercontainer-interface">
<h3>3.4. `ServiceWorkerContainer^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `ServiceWorkerContainer@I : `EventTarget$I {
  readonly attribute `ServiceWorker$I? `controller$m;
  readonly attribute Promise&lt;`ServiceWorkerRegistration$I&gt; `ready$m;

  [`NewObject$] Promise&lt;`ServiceWorkerRegistration$I&gt; `register$m(`USVString$ %scriptURL, optional `RegistrationOptions$I %options = {});

  [`NewObject$] Promise&lt;any&gt; `getRegistration$m(optional `USVString$ %clientURL = "");
  [`NewObject$] Promise&lt;FrozenArray&lt;`ServiceWorkerRegistration$I&gt;&gt; `getRegistrations$m();

  void `startMessages$m();

  // events
  attribute `EventHandler$I `oncontrollerchange$m;
  attribute `EventHandler$I `onmessage$m; /* <span class="comment">
`message$et ~eventの `source^m 属性は `ServiceWorker$I ~objになる
◎
event.source of message events is ServiceWorker object
</span> */
  attribute `EventHandler$I `onmessageerror$m;
};
</pre>

<pre class="idl" id="registration-option-list-dictionary">
dictionary `RegistrationOptions@I {
  `USVString$ `scope@m;
  `WorkerType$I `type@m = `classic^l;
  `ServiceWorkerUpdateViaCache$I `updateViaCache@m = `imports^l;
};
</pre>

<p>
~UAは、［
`Navigator$I ／ `WorkerNavigator$I
］~objを作成したときには、
`ServiceWorkerContainer$I ~objを作成して，前者に後者を結付けるモノトスル。
◎
The user agent must create a ServiceWorkerContainer object when a Navigator object or a WorkerNavigator object is created and associate it with that object.
</p>

<p>
`ServiceWorkerContainer$I は、`~sw登録$ %登録 を［
登録する, 未登録にする, 更新する
］能力，および［
%登録 の状態, および
%登録 に結付けられている`~sw$たち
］への~accessを供する。
◎
A ServiceWorkerContainer provides capabilities to register, unregister, and update the service worker registrations, and provides access to the state of the service worker registrations and their associated service workers.
</p>

<p>
各 `ServiceWorkerContainer$I ~obj %~container には、以下のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~sw~client@SWC</dt>
	<dd>
次を満たすような`~sw~client$ %~client を指す
⇒
［
%~client の`大域~obj$enVに結付けられている［
`Navigator$I ／ `WorkerNavigator$I
］~obj
に結付けられている `ServiceWorkerContainer$I ~obj
］ ~EQ %~container
◎
A ServiceWorkerContainer has an associated service worker client, which is a service worker client whose global object is associated with the Navigator object or the WorkerNavigator object that the ServiceWorkerContainer is retrieved from.
</dd>
	<dd class="trans-note">【
すなわち， 大域~obj . `navigator^n . `serviceWorker$n ~EQ %~container
】</dd>

	<dt>`準備済み~promise@SWC</dt>
	<dd>
`~promise$。
◎
A ServiceWorkerContainer object has an associated ready promise (a promise).＼
</dd>
	<dd>
初期~時には `新たな~promise$とする
◎
It is initially set to a new promise.
</dd>

	<dt>`~client~message~queue@SWC</dt>
	<dd>
`~task源$であり、初期~時には空とする。
【すなわち、`~task~queue$であると同時に，独立な~task源を成す。】
◎
A ServiceWorkerContainer object has a task source called the client message queue, initially empty.＼
</dd>
	<dd>
この~queueは［
可能化-／不能化-
］され得る
— 初期~時には不能化されているとする。
可能化されたときは、`~event-loop$は，それを自身の`~task源$の一つとして利用するモノトスル。
【すなわち，可能化されている間に限り、~queueを成す~taskたちを~event-loopの中で走らす。】
◎
A client message queue can be enabled or disabled, and is initially disabled. When a ServiceWorkerContainer object’s client message queue is enabled, the event loop must use it as one of its task sources.＼
</dd>
	<dd>
［
%~container に`関連な大域~obj$ %G が `Window$I ~objである
］ときは、この~queueに`~queueされ$たすべての`~task$には，
%G 【に`関連な設定群~obj$】の`担当の文書$enVを結付けるモノトスル。
【すなわち、~taskの`文書$tK ~SET 担当の文書】
◎
When the ServiceWorkerContainer object’s relevant global object is a Window object, all tasks queued on its client message queue must be associated with its relevant settings object’s responsible document.
</dd>
</dl>

`ServiceWorkerContainer^I0

			<section id="navigator-service-worker-controller">
<h4>3.4.1. `controller@m</h4>

<p>
取得子は、次を走らすモノトスル：
◎
controller attribute must run these steps:
</p>

<ol>
	<li>
%~client ~LET 此れの`~sw~client$SWC
◎
Let client be the context object’s service worker client.
</li>
	<li>
~IF［
%~client にて`作動中の~sw$enV ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If client’s active service worker is null, then return null.
</li>
	<li>
~RET `~sw~objを取得する$( %~client にて`作動中の~sw$enV, 此れに`関連な設定群~obj$ )
◎
Return the result of getting the service worker object that represents client’s active service worker in the context object's relevant settings object.
</li>
</ol>

<p class="note">注記：
<code>navigator . `serviceWorker$n . `controller$m</code>
は、要請が~refresh（
<kbd>shift+refresh</kbd>†
）を強制する場合には ~NULL を返す。
【結果は、 %~client を`制御-$している~swを表現する。】
【† ~cacheされていないかのように同じ資源を要請し直す（ “強制再読み込み” ）】
【！shift+reload も現れる】
◎
Note: navigator.serviceWorker.controller returns null if the request is a force refresh (shift+refresh).
</p>

			</section>
			<section id="navigator-service-worker-ready">
<h4>3.4.2. `ready@m</h4>

<p>
取得子は、次を走らすモノトスル：
◎
ready attribute must run these steps:
</p>

<ol>
	<li>
%準備済み~promise ~LET 此れの`準備済み~promise$SWC
◎
Let readyPromise be the context object's ready promise.
</li>
	<li>
<p>
~IF［
%準備済み~promise は決着している
］
⇒
次の手続きを`並列的$に走らす：
◎
If readyPromise is pending, run the following substeps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET `合致する~sw登録$( 此れの`~sw~client$SWCの`作成時の~URL$enV )
◎
Let registration be the result of running Match Service Worker Registration with the context object's service worker client's creation URL.
</li>
			<li>
~IF［
%登録 ~NEQ ~NULL
］~AND［
%登録 にて`作動中の~worker$swr ~NEQ ~NULL
］
⇒
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %準備済み~promise に`関連な設定群~obj$の`担当の~event-loop$enV )
⇒
次の結果で %準備済み~promise を解決する
⇒
`~sw登録~objを取得する$( %登録, %準備済み~promise に`関連な設定群~obj$ )
◎
If registration is not null, and registration’s active worker is not null, queue a task on readyPromise’s relevant settings object's responsible event loop, using the DOM manipulation task source, to resolve readyPromise with the result of getting the service worker registration object that represents registration in readyPromise’s relevant settings object.
</li>
		</ol>
	</li>
	<li>
~RET %準備済み~promise
◎
Return readyPromise.
</li>
</ol>

<p class="note">注記：
返される`準備済み~promise$SWCが却下されることは決してない。
この~algo内で解決されなかった場合、最終的に，合致する`~sw登録$が登録され, その`作動中の~worker$swrが設定されたときに解決されることになる（
<a href="#activate-resolve-ready-step">作動化する~algoの関連な段</a>
を見よ）。
◎
Note: The returned ready promise will never reject. If it does not resolve in this algorithm, it will eventually resolve when a matching service worker registration is registered and its active worker is set. (See the relevant Activate algorithm step.)
</p>

			</section>
			<section id="navigator-service-worker-register">
<h4>3.4.3. `register(scriptURL, options)@m</h4>

<p class="note">注記：
この~methodは、所与の`~scope~url$swr用に`~sw登録$を作成する, あるいは更新する。
成功した場合、`~sw登録$は，供された %scriptURL を`~scope~url$swrに束ねる
— それは、後続して
<a href="#handle-fetch">~naviと照合する</a>
ときにも利用される。
◎
Note: The register(scriptURL, options) method creates or updates a service worker registration for the given scope url. If successful, a service worker registration ties the provided scriptURL to a scope url, which is subsequently used for navigation matching.
</p>

<p>
被呼出時には、次を走らすモノトスル：
◎
The register(scriptURL, options) method must run these steps:
</p>

<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a promise.
</li>
	<li>
%~client ~LET 此れの`~sw~client$SWC
◎
Let client be the context object’s service worker client.
</li>
	<li>
%~script~URL ~LET `~URL構文解析する$( %scriptURL, 此れに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let scriptURL be the result of parsing scriptURL with the context object’s relevant settings object’s API base URL.
</li>
	<li>
%~scope~URL ~LET ~NULL
◎
Let scopeURL be null.
</li>
	<li>
~IF［
%options . `RegistrationOptions^I1`scope$m1 は`在する$
］
⇒
%~scope~URL ~SET `~URL構文解析する$( %options . `scope$m1, 此れに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
If options.scope is present, set scopeURL to the result of parsing options.scope with the context object’s relevant settings object’s API base URL.
</li>
	<li>
`登録を開始する$(
%~scope~URL,
%~script~URL,
%~promise,
%~client,
%~client の`作成時の~URL$enV,
%options . `type$m1,
%options . `updateViaCache$m1
)
◎
Invoke Start Register with scopeURL, scriptURL, p, client, client’s creation URL, options.type, and options.updateViaCache.
</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-getRegistration">
<h4>3.4.4. `getRegistration(clientURL)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
getRegistration(clientURL) method must run these steps:
</p>

<ol>
	<li>
%~client ~LET 此れの`~sw~client$SWC
◎
Let client be the context object’s service worker client.
</li>
	<li>
%clientURL ~LET `~URL構文解析する$( %clientURL, 此れに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let clientURL be the result of parsing clientURL with the context object’s relevant settings object’s API base URL.
</li>
	<li>
~IF［
%clientURL ~EQ `失敗^i
］
⇒
~RET `TypeError^E で`却下される~promise$
◎
If clientURL is failure, return a promise rejected with a TypeError.
</li>
	<li>
%clientURL の`素片$url ~SET ~NULL
◎
Set clientURL’s fragment to null.
</li>
	<li>
~IF［
%clientURL の`生成元$url
~NEQ`生成元$sub
%~client の`生成元$cl【！`生成元$enV】
【！is not】
］
⇒
~RET `SecurityError$E 例外で`却下される~promise$
◎
If the origin of clientURL is not client’s origin, return a promise rejected with a "SecurityError" DOMException.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET `合致する~sw登録$( %clientURL )
◎
Let registration be the result of running Match Service Worker Registration algorithm with clientURL as its argument.
</li>
			<li>
~IF［
%登録 ~EQ ~NULL
］
⇒
`undefined^jv で %~promise を`解決する$
◎
If registration is null, resolve promise with undefined and abort these steps.
</li>
			<li>
~ELSE
⇒
次の結果で %~promise を解決する
⇒
`~sw登録~objを取得する$( %登録, %~promise に`関連な設定群~obj$ )
◎
Resolve promise with the result of getting the service worker registration object that represents registration in promise’s relevant settings object.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-getRegistrations">
<h4>3.4.5. `getRegistrations()@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
getRegistrations() method must run these steps:
</p>

<ol>
	<li>
%~client ~LET 此れの`~sw~client$SWC
◎
Let client be the context object's service worker client.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%登録~list ~LET 新たな`~list$
◎
Let registrations be a new list.
</li>
			<li>
<p>
`~scopeから登録への~map$を成す
~EACH( %~scope → %登録 )
に対し：
</p>
				<ol>
					<li>
%~url ~LET `~URL構文解析する$( %~scope )
</li>
					<li>
~IF［
%~url の`生成元$url
~NEQ`生成元$sub
%~client の`生成元$cl【！`生成元$enV】
］
⇒
~CONTINUE
</li>
					<li>
%登録~list に %登録 を`付加する$
</li>
				</ol>
◎
For each scope → registration of scope to registration map:
• If the origin of the result of parsing scope is the same as client’s origin, then append registration to registrations.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task on promise’s relevant settings object's responsible event loop, using the DOM manipulation task source, to run the following steps:
</p>
				<ol>
					<li>
%登録~obj~list ~LET 新たな`~list$
◎
Let registrationObjects be a new list.
</li>
					<li>
%登録~list 内の
~EACH( `~sw登録$ )
に対し
⇒
%登録~obj~list に次の結果を`付加する$
⇒
`~sw登録~objを取得する$( %登録, %~promise に`関連な設定群~obj$ )
◎
For each registration of registrations:
• Let registrationObj be the result of getting the service worker registration object that represents registration in promise’s relevant settings object.
• Append registrationObj to registrationObjects.
</li>
					<li>
次の結果で %~promise を`解決する$
⇒
%~promise に`関連な~Realm$内で`凍結d配列を作成する$( %登録~obj~list )
◎
Resolve promise with a new frozen array of registrationObjects in promise’s relevant Realm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-startMessages">
<h4>3.4.6. `startMessages()@m</h4>

<p>
被呼出時には、此れの`~client~message~queue$SWCを可能化するモノトスル
— 可能化されてなければ。
◎
startMessages() method must enable the context object’s client message queue if it is not enabled.
</p>

			</section>
			<section id="service-worker-container-event-handlers">
<h4 title="Event handlers">3.4.7. ~event~handler</h4>

<p>
どの `ServiceWorkerContainer$I ~objも、次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the ServiceWorkerContainer interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`oncontrollerchange@m
<td>`controllerchange$et

<tr><td>`onmessage@m
<td>`message$et

<tr><td>`onmessageerror@m
<td>`~messageerror0$et

</tbody></table>

<p>
此れの `onmessage$m ~IDL属性が初回に設定されたときは、此れの`~client~message~queue$SWCを可能化するモノトスル。
◎
The first time the context object’s onmessage IDL attribute is set, its client message queue must be enabled.
</p>

			</section>
		</section>
		<section id="document-context-events">
<h3 title="Events">3.5. ~event</h3>

<div >

<p>
次の表の 1 列目に挙げる~eventが、同じ行の 2 列目に挙げる~objに向けて配送される
— いずれも， `Event$I を実装する：
</p>

<table id="_event-table1" class="grid-table">
<thead><tr><th>~event名
<th>配送-先
<th>配送-時機
</thead><tbody>

<tr><td>`statechange@et
<td>`ServiceWorker$I
<td>`ServiceWorker$I1 ~objの `state$m1 属性が変化したとき。

<tr><td>`updatefound@et
<td>`ServiceWorkerRegistration$I
<td>~objが`表現する~sw登録$にて`~install中の~worker$swrが変化したとき（`~installする$ ~algoを見よ）。

<tr><td>`controllerchange@et
<td>`ServiceWorkerContainer$I
<td>
<p>
`~sw~client$SWCにて`作動中の~sw$enVが変化したとき（`作動化する$~algoを見よ）。
</p>
<p>
［
`~sw$の`待機を飛ばす~flag$sw ~EQ ~T
］の下では、`~sw~client$たちが`~sw登録$を`利用して$いる間，`~sw登録$を`作動化する$
— `作動中の~worker$swrは，即時に，`~sw~client$を`制御-$している`~sw$として
<code>navigator . `ServiceWorkerContainer^I1`serviceWorker$n . `controller$m1</code>
に反映される。）
</p>
</tbody></table>

◎
The following event is dispatched on ServiceWorker object:
Event name 	Interface 	Dispatched when…
statechange 	Event 	The state attribute of the ServiceWorker object is changed.

The following event is dispatched on ServiceWorkerRegistration object:
Event name 	Interface 	Dispatched when…
updatefound 	Event 	The service worker registration's installing worker changes. (See step 8 of the Install algorithm.)

The following events are dispatched on ServiceWorkerContainer object:
Event name 	Interface 	Dispatched when…
controllerchange 	Event 	The service worker client's active service worker changes. (See step 9.2 of the Activate algorithm. The skip waiting flag of a service worker causes activation of the service worker registration to occur while service worker clients are using the service worker registration, navigator.serviceWorker.controller immediately reflects the active worker as the service worker that controls the service worker client.) 
</div>

		</section>
		<section id="navigation-preload-manager">
<h3>3.6. `NavigationPreloadManager^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `NavigationPreloadManager@I {
  Promise&lt;void&gt; `enable$m();
  Promise&lt;void&gt; `disable$m();
  Promise&lt;void&gt; `setHeaderValue$m(`ByteString$ %value);
  Promise&lt;`NavigationPreloadState$I&gt; `getState$m();
};

dictionary `NavigationPreloadState@I {
  `boolean$ `enabled@m = false;
  `ByteString$ `headerValue@m;
};
</pre>

`NavigationPreloadManager^I0

			<section id="navigation-preload-manager-enable">
<h4>3.6.1. `enable()@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
The enable() method, when invoked, must return a new promise promise and run the following steps in parallel:
</p>

<ol>
	<li>
%登録 ~LET 此れを結付けている`~sw登録$
◎
Let registration be the context object's associated service worker registration.
</li>
	<li>
~IF［
%登録 にて`作動中の~worker$swr ~EQ ~NULL
］
⇒＃
`InvalidStateError$E 例外で %~promise を`却下する$；
~RET
◎
If registration’s active worker is null, reject promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
	<li>
%登録 の`~navi~preload可能化~flag$swr ~SET ~T
◎
Set registration’s navigation preload enabled flag.
</li>
	<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
</ol>

			</section>
			<section id="navigation-preload-manager-disable">
<h4>3.6.2. `disable()@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
The disable() method, when invoked, must return a new promise promise and run the following steps in parallel:
</p>

<ol>
	<li>
%登録 ~LET 此れを結付けている`~sw登録$
◎
Let registration be the context object's associated service worker registration.
</li>
	<li>
~IF［
%登録 にて`作動中の~worker$swr ~EQ ~NULL
］
⇒＃
`InvalidStateError$E 例外で %~promise を`却下する$；
~RET
◎
If registration’s active worker is null, reject promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
	<li>
%登録 の`~navi~preload可能化~flag$swr ~SET ~F
◎
Unset registration’s navigation preload enabled flag.
</li>
	<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
</ol>

			</section>
			<section id="navigation-preload-manager-setheadervalue">
<h4>3.6.3. `setHeaderValue(value)@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
The setHeaderValue(value) method, when invoked, must return a new promise promise and run the following steps in parallel:
</p>

<ol>
	<li>
%登録 ~LET 此れを結付けている`~sw登録$
◎
Let registration be the context object's associated service worker registration.
</li>
	<li>
~IF［
%登録 にて`作動中の~worker$swr ~EQ ~NULL
］
⇒＃
`InvalidStateError$E 例外で %~promise を`却下する$；
~RET
◎
If registration’s active worker is null, reject promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
	<li>
%登録 の`~navi~preload~header値$swr ~SET %value
◎
Set registration’s navigation preload header value to value.
</li>
	<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
</ol>

			</section>
			<section id="navigation-preload-manager-getstate">
<h4>3.6.4. `getState()@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
The getState() method, when invoked, must return a new promise promise and run the following steps in parallel:
</p>

<ol>
	<li>
%登録 ~LET 此れを結付けている`~sw登録$
◎
Let registration be the context object's associated service worker registration.
</li>
	<li>
次のようにされた新たな `NavigationPreloadState$I 辞書で %~promise を`解決する$
⇒＃
`NavigationPreloadState^I1`enabled$m1 ~SET %登録 の`~navi~preload可能化~flag$swr,
`headerValue$m1 ~SET %登録 の`~navi~preload~header値$swr
◎
Let state be a new NavigationPreloadState dictionary.
◎
If registration’s navigation preload enabled flag is set, set state’s enabled dictionary member to true.
◎
Set state’s headerValue dictionary member to the registration’s navigation preload header value.
◎
Resolve promise with state.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="execution-context">
<h2 title="Execution Context">4. 実行~文脈</h2>

<div class="example">

<p>
~cacheされた資源たちの~serve法：
◎
Serving Cached Resources:
</p>

<pre>
// caching.js
self.addEventListener("install", %event =&gt; {
  %event.`waitUntil$n(
    /* <span class="comment">
資源たちが成す~cacheを~openする。
◎
Open a cache of resources.
</span> */
    `caches$n.`CacheStorage^I1`open$m1("shell-v1").then(%cache =&gt; {
      /* <span class="comment">
それらを~fetchする処理-を始める。
すべての資源が準備済みになったときに限り，~~視界が~~開ける。
◎
Begins the process of fetching them. The coast is only clear when all the resources are ready.
</span> */
      return %cache.addAll([
        "/app.html",
        "/assets/v1/base.css",
        "/assets/v1/app.js",
        "/assets/v1/logo.png",
        "/assets/v1/intro_video.webm"
      ]);
    })
  );
});

self.addEventListener("fetch", %event =&gt; {
  /* <span class="comment">
成功裡に~installされ, 作動化されるまでは、~swに向けて `fetch$et ~eventが配送されることはない。
◎
No "fetch" events are dispatched to the service worker until it successfully installs and activates.
</span> */

  /* <span class="comment">
合致している~URLも含め，~cache上のすべての演算は非同期cなので、~promiseを多用する。
これを可能化するため， `respondWith()$n も~promiseを引数にとる：
◎
All operations on caches are async, including matching URLs, so we use promises heavily. e.respondWith() even takes promises to enable this:
</span> */
  %event.respondWith(
    `caches$n.`Cache^I1`match$m1(%e.request).then(%response =&gt; {
      return %response || fetch(%e.request);
    }).catch(() =&gt; {
      return caches.match("/fallback.html");
    })
  );
});
</pre>

</div>

		<section id="serviceworkerglobalscope-interface">
<h3>4.1. `ServiceWorkerGlobalScope^I</h3>

<pre class="idl">
[`Global$=(`Worker$I,`ServiceWorker$I), `Exposed$=ServiceWorker]
interface `ServiceWorkerGlobalScope@I : `WorkerGlobalScope$I {
  [`SameObject$] readonly attribute `Clients$I `clients$m;
  [`SameObject$] readonly attribute `ServiceWorkerRegistration$I `registration$m;
  [`SameObject$] readonly attribute `ServiceWorker$I `serviceWorker$m;

  [`NewObject$] Promise&lt;void&gt; `skipWaiting$m();

  attribute `EventHandler$I `oninstall$m;
  attribute `EventHandler$I `onactivate$m;
  attribute `EventHandler$I `onfetch$m;

  attribute `EventHandler$I `onmessage$m;
  attribute `EventHandler$I `onmessageerror$m;
};
</pre>

<div class="p">
<p>
`ServiceWorkerGlobalScope$I ~objは、`~sw$の大域~実行~文脈を表現する。
各 `ServiceWorkerGlobalScope$I ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~sw@SWG</dt>
	<dd>
`~sw$。
</dd>

	<dt>`~importする~script用には~cacheを迂回するよう強制する~flag@SWG</dt>
	<dd>
真偽値をとり，初期~時には ~F とする。
</dd>
</dl>
◎
A ServiceWorkerGlobalScope object represents the global execution context of a service worker. A ServiceWorkerGlobalScope object has an associated service worker (a service worker). A ServiceWorkerGlobalScope object has an associated force bypass cache for import scripts flag. It is initially unset.
</div>

<p class="note">注記：
`ServiceWorkerGlobalScope$I ~objは、生成元の下で走らす［
汎用の,
~event駆動な,
時間制限付き
］~script実行~文脈を供する。
成功裡に`登録-$されたなら、`~sw$は，［
`~sw~client$ではなく，~event
］との関係性に基づいて
開始され, 生存し続け, ~killされる。
`~sw$の内側においては、いかなる型の同期的な要請も，起動されてはナラナイ。
◎
Note: ServiceWorkerGlobalScope object provides generic, event-driven, time-limited script execution contexts that run at an origin. Once successfully registered, a service worker is started, kept alive and killed by their relationship to events, not service worker clients. Any type of synchronous requests must not be initiated inside of a service worker.
</p>

			<section id="service-worker-global-scope-clients">
<h4>4.1.1. `clients@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れに<a href="#_serviceworkerglobalscope-client">結付けられている</a> `Clients$I ~obj
◎
The clients attribute must return the Clients object that is associated with the context object.
</p>

			</section>
			<section id="service-worker-global-scope-registration">
<h4>4.1.2. `registration@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
`~sw登録~objを取得する$( 此れの`~sw$SWGを`包含している~sw登録$sw, 此れに`関連な設定群~obj$ )
◎
The registration attribute must return the result of getting the service worker registration object representing the context object's service worker's containing service worker registration in context object's relevant settings object.
</p>

			</section>
			<section id="service-worker-global-scope-serviceworker">
<h4>4.1.3. `serviceWorker@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
`~sw~objを取得する$( 此れの`~sw$SWG, 此れに`関連な設定群~obj$ )
◎
The serviceWorker attribute must return the result of getting the service worker object that represents the context object's service worker in the context object's relevant settings object.
</p>

			</section>
			<section id="service-worker-global-scope-skipwaiting">
<h4>4.1.4. `skipWaiting()@m</h4>

<p class="note">注記：
この~methodは、此れの`~sw$SWG【！`~sw$】が，それを`包含している~sw登録$swにて`待機-中の~worker$swrから`作動中の~worker$swrになることを許容する
— その登録を`利用して$いる`~sw~client$がある間でも。
◎
Note: The skipWaiting() method allows this service worker to progress from the registration's waiting position to active even while service worker clients are using the registration.
</p>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
skipWaiting() method must run these steps:
• Let promise be a new promise.
• Run the following substeps in parallel:
</p>

<ol>
	<li>
此れの`~sw$SWGの`待機を飛ばす~flag$sw ~SET ~T
◎
Set service worker's skip waiting flag.
</li>
	<li>
`作動化しようと試行する$( 此れの`~sw$SWGを`包含している~sw登録$sw )
◎
Invoke Try Activate with service worker's containing service worker registration.
</li>
	<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
◎
↑↑
Return promise.
</li>
</ol>

			</section>
			<section id="service-worker-global-scope-event-handlers">
<h4 title="Event handlers">4.1.5. ~event~handler</h4>

<p>
どの `ServiceWorkerGlobalScope$I ~objも、次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the ServiceWorkerGlobalScope interface:
</p>

<table><thead>

<tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`oninstall@m
<td>`install$et

<tr><td>`onactivate@m
<td>`activate$et

<tr><td>`onfetch@m
<td>`fetch$et

<tr><td>`onmessage@m
<td>`message$et

<tr><td>`onmessageerror@m
<td>`messageerror$et

</tbody></table>

			</section>
		</section>
		<section id="client-interface">
<h3>4.2. `Client^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `Client@I {
  readonly attribute `USVString$ `url$m;
  readonly attribute `FrameType$I `frameType$m;
  readonly attribute `DOMString$ `id$m;
  readonly attribute `ClientType$I `type$m;
  void `postMessage$m(any %message, sequence&lt;`object$&gt; %transfer);
  void `~postMessageClient$n(any %message, optional `PostMessageOptions$I %options = {});
};

[`Exposed$=ServiceWorker]
interface `WindowClient@I : `Client$I {
  readonly attribute `VisibilityState$I `visibilityState$m;
  readonly attribute `boolean$ `focused$m;
  [`SameObject$] readonly attribute FrozenArray&lt;`USVString$&gt; `ancestorOrigins$m;
  [`NewObject$] Promise&lt;`WindowClient$I&gt; `focus$m();
  [`NewObject$] Promise&lt;`WindowClient$I?&gt; `navigate$m(`USVString$ %url);
};

enum `FrameType@I {
  "`auxiliary@m",
  "`top-level@m",
  "`nested@m",
  "`none@m"
};
</pre>

<p>
各 `Client$I ~objには、以下のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~sw~client@cl</dt>
	<dd>
`~sw~client$。
◎
A Client object has an associated service worker client (a service worker client).
</dd>

	<dt>`~frame種別@cl</dt>
	<dd>
`FrameType$I に挙げられたいずれかの文字列。
他が言明されない限り， `none^l とする。
【値の意味は、`~frame種別を取得する$を見よ。】
◎
A Client object has an associated frame type, which is one of "auxiliary", "top-level", "nested", and "none". Unless stated otherwise it is "none".
</dd>
</dl>

<p>
各 `WindowClient$I ~objには、以下のものも結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`閲覧文脈@cl</dt>
	<dd>
自身の`~sw~client$clの`大域~obj$enVの`閲覧文脈$を指す。
【すなわち、大域~objである~windowに`対応する閲覧文脈$】
◎
A WindowClient object has an associated browsing context, which is its service worker client's global object's browsing context.
</dd>

	<dt>`可視性~状態@cl</dt>
	<dd>
`visibilityState$n 属性がとり得る いずれかの値。
◎
A WindowClient object has an associated visibility state, which is one of visibilityState attribute value.
</dd>

	<dt>`~focus状態@cl</dt>
	<dd>
~T ／ ~F。
初期~時には~Fとする。
◎
A WindowClient object has an associated focus state, which is either true or false (initially false).
</dd>

	<dt>`先祖~生成元~配列@cl</dt>
	<dd>
【`先祖~生成元~list$に設定されることになる。】
◎
A WindowClient object has an associated ancestor origins array.
</dd>
</dl>

`Client^I0

			<section id="client-url">
<h4>4.2.1. `url@m</h4>

<p>
取得子は、次の結果を返すモノトスル
⇒
`~URLを直列化する$( 此れの`~sw~client$clの`作成時の~URL$enV )
◎
The url attribute must return the context object’s associated service worker client's serialized creation URL.
</p>

			</section>
			<section id="client-frametype">
<h4>4.2.2. `frameType@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れの`~frame種別$cl
◎
The frameType attribute must return the context object's frame type.
</p>

			</section>
			<section id="client-id">
<h4>4.2.3. `id@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れの`~sw~client$clの`~id$enV
◎
The id attribute must return its associated service worker client's id.
</p>

			</section>
			<section id="client-type">
<h4>4.2.4. `type@m</h4>

<p>
取得子は、此れの`~sw~client$clに応じて，次を返すモノトスル
⇒＃
`環境~設定群~obj$でないならば `window$l ／
`~window~client$であるならば `window$l ／
`専用~worker~client$であるならば `worker$l ／
`共用~worker~client$であるならば `sharedworker$l
◎
The type attribute must run these steps:
◎
Let client be context object's service worker client.
◎
If client is an environment settings object, then:
• If client is a window client, return "window".
• Else if client is a dedicated worker client, return "worker".
• Else if client is a shared worker client, return "sharedworker".
◎
Else:
• Return "window".
</p>

			</section>
			<section id="client-postmessage">
<h4>4.2.5. `postMessage(message, transfer)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The postMessage(message, transfer) method must run these steps:
</p>

<ol>
	<li>
%options ~LET «[ `transfer^l → %transfer ]»
◎
Let options be «[ "transfer" → transfer ]».
</li>
	<li>
此れ上で `~postMessageClient(message, options)$n （次節）の~algoを遂行する
◎
Invoke postMessage(message, options) with message and options as the arguments.
</li>
</ol>

			</section>
			<section id="client-postmessage-options">
<h4>4.2.6. `~postMessageClient(message, options)@n</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The postMessage(message, options) method must run these steps:
</p>

<ol>
	<li>
%~source設定群 ~LET 此れに`関連な設定群~obj$
◎
Let contextObject be the context object.
◎
Let sourceSettings be the contextObject’s relevant settings object.
</li>
	<li>
%直列形の転送-結果 ~LET
~ABRUPT `StructuredSerializeWithTransfer$jA( %message, %options.`transfer^m )
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, options.transfer). Rethrow any exceptions.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~target~client ~LET 此れの`~sw~client$cl
◎
↓</li>
			<li>
<p>
~IF［
%~target~client はすでに~unloadされた（`1042$issue）
］
⇒
~RET
◎
Let targetClient be null.
◎
For each service worker client client:
• If client is the contextObject’s service worker client, set targetClient to client, and break.
◎
If targetClient is null, return.
</p>

<p class="trans-note">【
原文のこの段は，そのまま訳すと意図不明になるので、この訳では，手を加えている（ “`is^en” と “~EQ” の違いを日本語で表現できない）。
】</p>
			</li>
			<li>
%行先 ~LET 次を満たす `ServiceWorkerContainer$I ~obj
⇒
その`~sw~client$SWC ~EQ %~target~client
◎
Let destination be the ServiceWorkerContainer object whose associated service worker client is targetClient.
</li>
			<li>
<p>
%行先 の`~client~message~queue$SWCに
次の手続きを走らす`~task$を追加する：
◎
Add a task that runs the following steps to destination’s client message queue:
</p>
				<ol>
					<li>
%生成元 ~LET `生成元を直列化する$( %~source設定群 の`生成元$enV )
◎
Let origin be the serialization of sourceSettings’s origin.
</li>
					<li>
%~source ~LET `~sw~objを取得する$( 此れに`関連な大域~obj$の`~sw$SWG, %~target~client )
◎
Let source be the result of getting the service worker object that represents contextObject’s relevant global object's service worker in targetClient.
</li>
					<li>
<p>
%逆直列化-~record ~LET 
`StructuredDeserializeWithTransfer$jA( %直列形の転送-結果, %行先 に`関連な~Realm$ )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, destination’s relevant Realm).
</p>

<div class="p">
<p>
例外が投出されたときは、~catchして：
</p>
						<ol>
							<li>
%行先 に向けて，名前 `messageerror$et の`~eventを発火する$
— `MessageEvent$I を利用し，次のように初期化して
⇒＃
`origin$n 属性 ~SET %生成元,
`source$n 属性 ~SET %~source
</li>
							<li>
~RET
</li>
						</ol>
◎
If this throws an exception, catch it, fire an event named messageerror at destination, using MessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source, and then abort these steps.
</div>
					</li>
					<li>
%新たな~portたち ~LET 
【%行先 に`関連な~Realm$内で】
`凍結d配列を作成する$( %逆直列化-~record . `TransferredValues^sl 内のすべての `MessagePort$I ~objからなる同順の~list )
◎
Let messageClone be deserializeRecord.[[Deserialized]].
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any.
</li>
					<li>
%行先 に向けて，名前 `~message0$et の~eventを`配送する$
— `MessageEvent$I を利用し，次のように初期化した上で
⇒＃
`origin$n 属性 ~SET %生成元,
`source$n 属性 ~SET %~source,
`data$n 属性 ~SET %逆直列化-~record . `Deserialized^sl,
`ports$n 属性 ~SET %新たな~portたち
◎
Dispatch an event named message at destination, using MessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>

`WindowClient^I0

			<section id="client-visibilitystate">
<h4>4.2.7. `visibilityState@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れの`可視性~状態$cl
◎
The visibilityState attribute must return the context object’s visibility state.
</p>

			</section>
			<section id="client-focused">
<h4>4.2.8. `focused@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れの`~focus状態$cl
◎
The focused attribute must return the context object’s focus state.
</p>

			</section>
			<section id="client-ancestororigins">
<h4>4.2.9. `ancestorOrigins@m</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れの`先祖~生成元~配列$cl
◎
The ancestorOrigins attribute must return the context object’s associated ancestor origins array.
</p>

			</section>
			<section id="client-focus">
<h4>4.2.10. `focus()@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The focus() method must run these steps:
</p>

<ol>
	<li>
~IF［
この~algoは`利用者の作動化により誘発されて$いない
］
⇒
~RET `InvalidAccessError$E 例外で`却下される~promise$
◎
If this algorithm is not triggered by user activation, return a promise rejected with an "InvalidAccessError" DOMException.
</li>
	<li>
%~sw~event-loop ~LET `現在の大域~obj$の`~event-loop$
◎
Let serviceWorkerEventLoop be the current global object's event loop.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
`~taskを~queueする$( `利用者~対話~task源$, 次の手続き, 此れの`~sw~client$clの`担当の~event-loop$enV )：
◎
Queue a task to run the following steps on the context object's associated service worker client's responsible event loop using the user interaction task source:
</p>
		<ol>
			<li>
%閲覧文脈 ~LET 此れの`閲覧文脈$cl
◎
↓</li>
			<li>
`~objを~focusする$( %閲覧文脈 )
◎
Run the focusing steps with the context object's browsing context.
</li>
			<li>
%~frame種別 ~LET `~frame種別を取得する$( %閲覧文脈 )
◎
Let frameType be the result of running Get Frame Type with the context object's browsing context.
</li>
			<li>
%作動中の文書 ~LET %閲覧文脈 にて`作動中の文書$
◎
↓</li>
			<li>
%可視性~状態 ~LET %作動中の文書 の`visibilityState$n 属性~値
◎
Let visibilityState be the context object's browsing context's active document's visibilityState attribute value.
</li>
			<li>
%~focus状態 ~SET `~focusを得ている$( %作動中の文書 )
◎
Let focusState be the result of running the has focus steps with the context object's browsing context's active document.
</li>
			<li>
%先祖~生成元~list ~LET ［［［［
%作動中の文書
］に`関連な大域~obj$
］の `Location$I ~obj
］の`先祖~生成元~list$
］に結付けられている~list
◎
Let ancestorOriginsList be the context object's browsing context's active document's relevant global object's Location object’s ancestor origins list's associated list.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~sw~event-loop )：
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
</p>
				<ol>
					<li>
%~window~client ~LET 
`~window~clientを作成する$( 次に挙げる引数 )
⇒＃
此れの`~sw~client$cl,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
Let windowClient be the result of running Create Window Client with the context object's associated service worker client, frameType, visibilityState, focusState, and ancestorOriginsList.
</li>
					<li>
~IF［
%~window~client の`~focus状態$cl ~EQ ~T
］
⇒
%~window~client で %~promise を`解決する$
◎
If windowClient’s focus state is true, resolve promise with windowClient.
</li>
					<li>
~ELSE
⇒
`TypeError^E で %~promise を`却下する$
◎
Else, reject promise with a TypeError.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="client-navigate">
<h4>4.2.11. `navigate(url)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The navigate(url) method must run these steps:
</p>

<ol>
	<li>
%~url ~LET `~URL構文解析する$( %~url, 此れに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let url be the result of parsing url with the context object’s relevant settings object’s API base URL.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `TypeError^E で`却下される~promise$：
</p>

<ul ><li>%~url ~EQ `失敗^i
</li><li>%~url ~EQ `about:blank^c
</li><li>此れの`~sw~client$clにて`作動中の~sw$enV~NEQ 此れに`関連な大域~obj$の`~sw$SWG
</li></ul>

◎
If url is failure, return a promise rejected with a TypeError.
◎
If url is about:blank, return a promise rejected with a TypeError.
◎
If the context object’s associated service worker client's active service worker is not the context object’s relevant global object’s service worker, return a promise rejected with a TypeError.
</li>
	<li>
%~sw~event-loop ~LET `現在の大域~obj$の`~event-loop$
◎
Let serviceWorkerEventLoop be the current global object's event loop.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
`~taskを~queueする$( `利用者~対話~task源$, 次の手続き, 此れの`~sw~client$clの`担当の~event-loop$enV )：
◎
Queue a task to run the following steps on the context object's associated service worker client's responsible event loop using the user interaction task source:
</p>
		<ol>
			<li>
%閲覧文脈 ~LET 此れの`閲覧文脈$cl
◎
Let browsingContext be the context object's browsing context.
</li>
			<li>
<p>
~IF［
%閲覧文脈 は その`文書を破棄-$した【`作動中の文書$を破棄した？】
］：
</p>
				<ol>
					<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~sw~event-loop )
⇒
`TypeError^E で %~promise を`却下する$
</li>
					<li>
~RET
</li>
				</ol>
◎
If browsingContext has discarded its Document, queue a task to reject promise with a TypeError, on serviceWorkerEventLoop using the DOM manipulation task source, and abort these steps.
</li>
			<li>
【！ HandleNavigate】
次を与える下で
%閲覧文脈 を %~url へ`~navigateする$
⇒＃
`~source閲覧文脈$ ~SET %閲覧文脈,
`例外を可能化する$i
◎
HandleNavigate: Navigate browsingContext to url with exceptions enabled. The source browsing context must be browsingContext.
</li>
			<li>
<p>
~IF［
前~段にて例外が投出された
］：
</p>
				<ol>
					<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~sw~event-loop )
⇒
その例外で %~promise を`却下する$
</li>
					<li>
~RET
</li>
				</ol>
◎
If the algorithm steps invoked in the step labeled HandleNavigate throws an exception, queue a task to reject promise with the exception, on serviceWorkerEventLoop using the DOM manipulation task source, and abort these steps.
</li>
			<li>
%~frame種別 ~LET `~frame種別を取得する$( %閲覧文脈 )
◎
Let frameType be the result of running Get Frame Type with browsingContext.
</li>
			<li>
%可視性~状態 ~LET %作動中の文書 の`visibilityState$n 属性~値
◎
Let visibilityState be browsingContext’s active document’s visibilityState attribute value.
</li>
			<li>
%~focus状態 ~SET `~focusを得ている$( %作動中の文書 )
◎
Let focusState be the result of running the has focus steps with browsingContext’s active document.
</li>
			<li>
%先祖~生成元~list ~LET ［［［［
%閲覧文脈 にて`作動中の文書$
］に`関連な大域~obj$
］の `Location$I ~obj
］の`先祖~生成元~list$
］に結付けられている~list
◎
Let ancestorOriginsList be browsingContext’s active document's relevant global object's Location object’s ancestor origins list's associated list.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~sw~event-loop )：
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
</p>
				<ol>
					<li>
%~window~client ~LET ~NULL
◎
↓</li>
					<li>
~IF［
%閲覧文脈 の `Window$I ~objの`環境~設定群~obj$の`作成時の~URL$enVの`生成元$url
~EQ`生成元$sub
`~sw$SWGの`生成元$sw【！`生成元$enV】
］
⇒
%~window~client ~SET `~window~clientを作成する$( 次に挙げる引数 )
⇒＃
此れの`~sw~client$cl,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
If browsingContext’s Window object’s environment settings object’s creation URL’s origin is not the same as the service worker's origin, resolve promise with null and abort these steps.
◎
Let windowClient be the result of running Create Window Client with the context object's service worker client, frameType, visibilityState, focusState, and ancestorOriginsList.
</li>
					<li>
%~window~client で %~promise を`解決する$
◎
Resolve promise with windowClient.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="clients-interface">
<h3>4.3. `Clients^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `Clients@I {
  /* <span class="comment">
返される~objは、毎回~新たな~instanceになる
◎
The objects returned will be new instances every time
</span> */
  [`NewObject$] Promise&lt;any&gt; `get$m(`DOMString$ %id);
  [`NewObject$] Promise&lt;FrozenArray&lt;`Client$I&gt;&gt; `matchAll$m(optional `ClientQueryOptions$I %options = {});
  [`NewObject$] Promise&lt;`WindowClient$I?&gt; `openWindow$m(`USVString$ %url);
  [`NewObject$] Promise&lt;void&gt; `claim$m();
};
</pre>

<pre class="idl" id="serviceworker-client-query-options-dictionary">
dictionary `ClientQueryOptions@I {
  `boolean$ `includeUncontrolled@m = false;
  `ClientType$I `type@m = "window";
};
</pre>

<pre class="idl" id="client-type-enum">
enum `ClientType@I {
  "`window@m",
  "`worker@m",
  "`sharedworker@m",
  "`all@m"
};
</pre>

<p id="_serviceworkerglobalscope-client">
~UAは，`ServiceWorkerGlobalScope$I ~obj %G の作成-時には、
`Clients$I ~obj %C を作成して， %G に %C を結付けるモノトスル。
以下における %C の
`~sw@cl
は、 %G の`~sw$SWGを指すとする。
【この用語は、以下の記述を明確化するために，この訳に導入している。】
◎
The user agent must create a Clients object when a ServiceWorkerGlobalScope object is created and associate it with that object.
</p>

`Clients^I0

			<section id="clients-get">
<h4>4.3.1. `get(id)@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
The get(id) method must run these steps:
• Let promise be a new promise.
• Run these substeps in parallel:
</p>

<ol>
	<li>
%~sw ~LET 此れの`~sw$cl
◎
↓</li>
	<li>
<p>
~EACH( `~sw~client$ %~client )
に対し：
◎
For each service worker client client＼
</p>
		<ol>
			<li>
~IF［
%~client の`生成元$cl
~NEQ`生成元$sub
%~sw の`生成元$sw【！`生成元$enV】
］~OR［
%~client の`~id$enV~NEQ %id
］
⇒
~CONTINUE
◎
whose origin is the same as the associated service worker's origin:
◎
If client’s id is not id, continue.
</li>
			<li>
次が満たされるまで待機する
⇒
［
%~client の`実行~準備済み~flag$enV ~EQ ~T
］~OR［
%~client の`破棄-済み~flag$ ~EQ ~T
］
◎
Wait for either client’s execution ready flag to be set or for client’s discarded flag to be set.
</li>
			<li>
~IF［
%~client の`実行~準備済み~flag$enV ~EQ ~T
］
⇒＃
`~clientを取得する~promiseを解決する$( %~client, %~promise )；
~RET
◎
If client’s execution ready flag is set, then invoke Resolve Get Client Promise with client and promise, and abort these steps.
</li>
		</ol>
	</li>
	<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
◎
↑↑
Return promise.
</li>
</ol>

			</section>
			<section id="clients-matchall">
<h4>4.3.2. `matchAll(options)@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
The matchAll(options) method must run these steps:
• Let promise be a new promise.
• Run the following steps in parallel:
</p>

<ol>
	<li>
%~target~clientたち ~LET 新たな`~list$
◎
Let targetClients be a new list.
</li>
	<li>
%~sw ~LET 此れの`~sw$cl
◎
↓</li>
	<li>
<p>
~EACH( `~sw~client$ %~client )
に対し：
◎
For each service worker client client＼
</p>
		<ol>
			<li>
<p>
~IF［
次がすべて満たされる
］…：
</p>
				<ul>
					<li>
%~client の`生成元$cl
~EQ`生成元$sub
%~sw の`生成元$sw【！`生成元$enV】
</li>
					<li>
%~client の`実行~準備済み~flag$enV ~EQ ~T
</li>
					<li>
%~client の`破棄-済み~flag$ ~EQ ~F
</li>
					<li>
%~client は`~secure文脈$である
</li>
					<li>
［
%options[ "`ClientQueryOptions^I1`includeUncontrolled$m1" ] ~EQ ~T
］~OR［
%~client にて`作動中の~sw$enV ~EQ %~sw
］
</li>
				</ul>
<p>
…ならば
⇒
%~target~clientたち に %~client を追加する
</p>
◎
whose origin is the same as the associated service worker's origin:
• If client’s execution ready flag is unset or client’s discarded flag is set, continue.
• If client is not a secure context, continue.
• If options["includeUncontrolled"] is false, and if client’s active service worker is not the associated service worker, continue.
• Add client to targetClients.
</li>
		</ol>
	</li>
	<li>
%合致した~window~data ~LET 新たな`~list$
◎
Let matchedWindowData be a new list.
</li>
	<li>
%合致した~clientたち ~LET 新たな`~list$
◎
Let matchedClients be a new list.
</li>
	<li>
<p>
%~target~clientたち を成す
~EACH( `~sw~client$ %~client )
に対し：
◎
For each service worker client client in targetClients:
</p>
		<ol>
			<li>
<p>
~IF［
%options [ "`ClientQueryOptions^I1`type$m1" ] ~IN { `window$l, `all$l }
］~AND［［
%~client は`環境~設定群~obj$でない
］~OR［
%~client は`~window~client$である
］］：
◎
If options["type"] is "window" or "all", and client is not an environment settings object or is a window client, then:
</p>
				<ol>
					<li>
%~window~data ~LET «[ `client^l → client, `ancestorOriginsList^l → 新たな`~list$ ]»
◎
Let windowData be «[ "client" → client, "ancestorOriginsList" → a new list ]».
</li>
					<li>
%~clientは列挙-可能 ~LET ~T
◎
Let browsingContext be null.
◎
Let isClientEnumerable be true.
</li>
					<li>
%閲覧文脈 ~LET［
%~client は`環境~設定群~obj$であるならば %~client の`大域~obj$enVの`閲覧文脈$ ／
~ELSE_ %~client の`~target閲覧文脈$enV
］
◎
If client is an environment settings object, set browsingContext to client’s global object's browsing context.
◎
Else, set browsingContext to client’s target browsing context.
</li>
					<li>
<p>
%~task ~LET `~taskを~queueする$( `利用者~対話~task源$, 次の手続き, %閲覧文脈 の`~event-loop$ )：
◎
Queue a task task to run the following substeps on browsingContext’s event loop using the user interaction task source:
</p>
						<ol>
							<li>
~IF［
%閲覧文脈 は`破棄されて$いる
］
⇒＃
%~clientは列挙-可能 ~SET ~F；
~RET
◎
If browsingContext has been discarded, then set isClientEnumerable to false and abort these steps.
</li>
							<li>
%作動中の文書 ~LET %閲覧文脈 にて`作動中の文書$
◎
↓</li>
							<li>
~IF［
%~client は`~window~client$である
］~AND［
%~client の`担当の文書$enV ~NEQ %作動中の文書
］
⇒＃
%~clientは列挙-可能 ~SET ~F；
~RET
◎
If client is a window client and client’s responsible document is not browsingContext’s active document, then set isClientEnumerable to false and abort these steps.
</li>
							<li>
%~window~data[ `frameType^l ] ~SET `~frame種別を取得する$( %閲覧文脈 )
◎
Set windowData["frameType"] to the result of running Get Frame Type with browsingContext.
</li>
							<li>
%~window~data[ `visibilityState^l ] ~SET %作動中の文書 の`visibilityState$n 属性~値
◎
Set windowData["visibilityState"] to browsingContext’s active document's visibilityState attribute value.
</li>
							<li>
%~window~data[ `focusState^l ] ~SET `~focusを得ている$( %作動中の文書 )
◎
Set windowData["focusState"] to the result of running the has focus steps with browsingContext’s active document as the argument.
</li>
							<li>
~IF［
%~client は`~window~client$である
］
⇒
%~window~data[ `ancestorOriginsList^l ] ~SET %作動中の文書 に`関連な大域~obj$の`Location$I ~objの`先祖~生成元~list$に結付けられている~list
◎
If client is a window client, then set windowData["ancestorOriginsList"] to browsingContext’s active document's relevant global object's Location object’s ancestor origins list's associated list.
</li>
						</ol>
					</li>
					<li>
<p>
%~task が実行されるまで待機する
◎
Wait for task to have executed.
</p>

<p class="note">注記：
これは他を阻むように待機するが、実装者は，状態が壊れない限り各 反復を並列的に走らせてもよい。
◎
Note: Wait is a blocking wait, but implementers may run the iterations in parallel as long as the state is not broken.
</p>
					</li>
					<li>
~IF［
%~clientは列挙-可能 ~EQ ~T
］
⇒
%合致した~window~data に %~window~data を追加する
◎
If isClientEnumerable is true, then:
• Add windowData to matchedWindowData.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
次のいずれかが満たされる
］…
</p>
				<ul>
					<li>
［
%~client は`専用~worker~client$である
］~AND［
%options[ `ClientQueryOptions^I1`type$m1 ] ~IN { `worker$l, `all$l }
］
</li>
					<li>
［
%~client は`共用~worker~client$である
］~AND［
%options[ `type$m1 ] ~IN { `sharedworker$l, `all$l }
］
</li>
				</ul>
<p>
…ならば
⇒
%合致した~clientたち に次の結果を追加する
⇒
`~clientを作成する$( %~client )
</p>
◎
Else if options["type"] is "worker" or "all" and client is a dedicated worker client, or options["type"] is "sharedworker" or "all" and client is a shared worker client, then:
• Add client to matchedClients.
</li>
		</ol>
	</li>
	<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task to run the following steps on promise’s relevant settings object's responsible event loop using the DOM manipulation task source:
</p>
		<ol>
			<li>
%~client~objたち ~LET 新たな`~list$
◎
Let clientObjects be a new list.
</li>
			<li>
%合致した~window~data を成す
~EACH( %~window~data )
に対し
⇒
%~client~objたち に次の結果を`付加する$
⇒
`~window~clientを作成する$( 次に挙げる引数 )
⇒＃
%~window~data[ `client^l ],
%~window~data[ `frameType^l ],
%~window~data[ `visibilityState^l ],
%~window~data[ `focusState^l ],
%~window~data[ `ancestorOriginsList^l ]
◎
For each windowData in matchedWindowData:
• Let windowClient be the result of running Create Window Client algorithm with windowData["client"], windowData["frameType"], windowData["visibilityState"], windowData["focusState"], and windowData["ancestorOriginsList"] as the arguments.
• Append windowClient to clientObjects.
</li>
			<li>
%合致した~clientたち を成す
~EACH( %~client )
に対し
⇒
%~client~objたち に次の結果を`付加する$
⇒
`~clientを作成する$( %~client )
◎
For each client in matchedClients:
• Let clientObject be the result of running Create Client algorithm with client as the argument.
• Append clientObject to clientObjects.
</li>
			<li>
<p>
%~client~objたち を，次に与える順に~sortする：
◎
Sort clientObjects such that:
</p>
				<ol>
					<li>
<p>
`WindowClient$I ~objたちのうち，それまでにその`閲覧文脈$clが`~focusされ$たものたち
— 最も近過去に`~focusされ$たものから順に。
◎
WindowClient objects whose browsing context has been focused are placed first, sorted in the most recently focused order.
</li>
					<li>
前項に該当しない `WindowClient$I ~objたち
— それぞれの`~sw~client$clの作成~順に。
◎
WindowClient objects whose browsing context has never been focused are placed next, sorted in their service worker client's creation order.
</li>
					<li>
`Client$I ~objのうち，`~sw~client$clは`~worker~client$であるものたち
— それぞれの`~sw~client$clの作成~順に。
◎
Client objects whose associated service worker client is a worker client are placed next, sorted in their service worker client's creation order.
</li>
				</ol>

<p class="note">注記：
`~window~client$ は、常に`~worker~client$より先に来る。
◎
Note: Window clients are always placed before worker clients.
</p>

			</li>
			<li>
次の結果で %~promise を`解決する$
⇒
%promise に`関連な~Realm$内で`凍結d配列を作成する$( %合致した~clientたち )
◎
Resolve promise with a new frozen array of clientObjects in promise’s relevant Realm.
</li>
		</ol>
<p>
◎
↑↑Return promise.
</p>
	</li>
</ol>

			</section>
			<section id="clients-openwindow">
<h4>4.3.3. `openWindow(url)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The openWindow(url) method must run these steps:
</p>

<ol>
	<li>
%~url ~LET 
`~URL構文解析する$( %url, 此れに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let url be the result of parsing url with the context object’s relevant settings object’s API base URL.
</li>
	<li>
~IF［
%~url ~EQ `失敗^i
］~OR［
%~url ~EQ `about:blank^c
］
⇒
~RET `TypeError^E で`却下される~promise$：
◎
If url is failure, return a promise rejected with a TypeError.
◎
If url is about:blank, return a promise rejected with a TypeError.
</li>
	<li>
~IF［
この~algoは`利用者の作動化により誘発されて$いない
］
⇒
~RET `InvalidAccessError$E 例外で`却下される~promise$
◎
If this algorithm is not triggered by user activation, return a promise rejected with an "InvalidAccessError" DOMException.
</li>
	<li>
%~sw~event-loop ~LET `現在の大域~obj$の`~event-loop$
◎
Let serviceWorkerEventLoop be the current global object's event loop.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%新-文脈 ~LET 新たな`~top-level閲覧文脈$
◎
Let newContext be a new top-level browsing context.
</li>
			<li>
<p>
`~taskを~queueする$( `利用者~対話~task源$, 次の手続き, %新-文脈 の`Window$I ~objの`環境~設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task to run the following steps on newContext’s Window object’s environment settings object's responsible event loop using the user interaction task source:
</p>
				<ol>
					<li>
【！ HandleNavigate】
次を与える下で
%新-文脈 を %~url へ`~navigateする$
⇒＃
`例外を可能化する$i,
`置換を可能化する$i
◎
HandleNavigate: Navigate newContext to url with exceptions enabled and replacement enabled.
</li>
					<li>
<p>
~IF［
前~段にて例外が投出された
］：
</p>
						<ol>
							<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~sw~event-loop )
⇒
その例外で %~promise を`却下する$
</li>
							<li>
~RET
</li>
						</ol>
◎
If the algorithm steps invoked in the step labeled HandleNavigate throws an exception, queue a task to reject promise with the exception, on serviceWorkerEventLoop using the DOM manipulation task source, and abort these steps.
</li>
					<li>
%~frame種別 ~LET `~frame種別を取得する$( %新-文脈 )
◎
Let frameType be the result of running Get Frame Type with newContext.
</li>
					<li>
%可視性~状態 ~LET %新-文脈 にて`作動中の文書$ の`visibilityState$n 属性~値
◎
Let visibilityState be newContext’s active document’s visibilityState attribute value.
</li>
					<li>
%~focus状態 ~LET `~focusを得ている$( %新-文脈 にて`作動中の文書$ )
◎
Let focusState be the result of running the has focus steps with newContext’s active document as the argument.
</li>
					<li>
%先祖~生成元~list ~LET %新-文脈 にて`作動中の文書$に`関連な大域~obj$の `Location$I ~objの`先祖~生成元~list$に結付けられている~list
◎
Let ancestorOriginsList be newContext’s active document’s relevant global object’s Location object’s ancestor origins list's associated list.
</li>
					<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~sw~event-loop )：
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
</p>
						<ol>
							<li>
%~client ~LET ~NULL
◎
↓</li>
							<li>
%設定群 ~LET %新-文脈 の `Window$I ~objの`環境~設定群~obj$
◎
↓</li>
							<li>
~IF［
%設定群 の`作成時の~URL$enVの`生成元$url
~EQ`生成元$sub
此れの`~sw$clの`生成元$enV
］
⇒
%~client ~SET `~window~clientを作成する$( 次に挙げる引数 )
⇒＃
%設定群,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
If newContext’s Window object’s environment settings object's creation URL's origin is not the same as the service worker's origin, resolve promise with null and abort these steps.
◎
Let client be the result of running Create Window Client with newContext’s Window object’s environment settings object, frameType, visibilityState, focusState, and ancestorOriginsList as the arguments.
</li>
							<li>
%~client で %~promise を`解決する$
◎
Resolve promise with client.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="clients-claim">
<h4>4.3.4. `claim()@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The claim() method must run these steps:
</p>

<ol>
	<li>
%~sw ~LET 此れの`~sw$cl
◎
↓</li>
	<li>
~IF［
%~sw は`作動中の~worker$swrでない
］
⇒
~RET `InvalidStateError$E 例外で`却下される~promise$
◎
If the service worker is not an active worker, return a promise rejected with an "InvalidStateError" DOMException.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
<div >
<p>
次をすべて満たす
~EACH( `~sw~client$ %~client )
に対し…：
</p>
				<ul>
					<li>
`生成元$cl
~EQ`生成元$sub
%~sw の`生成元$enV
</li>
					<li>
`実行~準備済み~flag$enV ~EQ ~T
</li>
					<li>
`破棄-済み~flag$ ~EQ ~F
</li>
					<li>
`~secure文脈$である
</li>
				</ul>
<p>
…に対し：
</p>

◎
For each service worker client client whose origin is the same as the service worker's origin:
• If client’s execution ready flag is unset or client’s discarded flag is set, continue.
• If client is not a secure context, continue.
</div>
				<ol>
					<li>
%登録 ~LET `合致する~sw登録$( %~client の`作成時の~URL$enV )
◎
Let registration be the result of running Match Service Worker Registration algorithm passing client’s creation URL as the argument.
</li>
					<li>
<p>
~IF［
%登録 ~NEQ %~sw を`包含している~sw登録$sw
］
⇒
~CONTINUE
◎
If registration is not the service worker's containing service worker registration, continue.
</p>

<p class="note">注記：
%登録 は、この`~sw$SWGを`包含している~sw登録$swが`未登録にされて$いる場合には， ~NULL になる。
◎
Note: registration will be null if the service worker's containing service worker registration is unregistered.
</p>
					</li>
					<li>
~IF［
%~client にて`作動中の~sw$enV ~EQ %~sw
］
⇒
~CONTINUE
◎
If client’s active service worker is not the service worker, then:
</li>
					<li>
`~sw~clientを~unloadする$( %~client )
◎
Invoke Handle Service Worker Client Unload with client as the argument.
</li>
					<li>
%~client にて`作動中の~sw$enV ~SET %~sw
◎
Set client’s active service worker to service worker.
</li>
					<li>
`制御器の変化を通知する$( %~client )
◎
Invoke Notify Controller Change algorithm with client as the argument.
</li>
				</ol>
			</li>
			<li>
`undefined^jv で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="extendableevent-interface">
<h3>4.4. `ExtendableEvent^I</h3>

<pre class="idl">
[`ExtendableEvent@C(`DOMString$ %type, optional `ExtendableEventInit$I %eventInitDict = {}), `Exposed$=ServiceWorker]
interface `ExtendableEvent@I : `Event$I {
  void `waitUntil$m(Promise&lt;any&gt; %f);
};
</pre>

<pre class="idl" id="extendable-event-init-dictionary">
dictionary `ExtendableEventInit@I : `EventInit$I {
  /* <span class="comment">
`ExtendableEvent^I から派生する~eventを前方-互換にするために定義される
◎
Defined for the forward compatibility across the derived events
</span> */
};
</pre>

<p>
各 `ExtendableEvent$I0 ~objには、以下のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~lifetimeを延長する~promiseたち@</dt>
	<dd>
`~promise$たちが成す配列。【！＊】
◎
An ExtendableEvent object has an associated extend lifetime promises (an array of promises).＼
</dd>
	<dd>
初期~時には空~配列とする。
◎
It is initially an empty array.
</dd>

	<dt>`処理待ち~promise数@</dt>
	<dd>
`~lifetimeを延長する~promiseたち$内の処理待ち~promiseの個数を表す整数。
【実際の個数と正確には同期しないため、この定義が必要とされている。】
◎
An ExtendableEvent object has an associated pending promises count (the number of pending promises in the extend lifetime promises).＼
</dd>
	<dd>
初期~時には 0 とする。
◎
It is initially set to zero.
</dd>

	<dt>`時間切れ~flag@</dt>
	<dd>
真偽値をとり，初期~時には ~F とする。
［
`処理待ち~promise数$ ~GT 0
］の場合に，~UAが任意選択で課す遅延~後に ~T にされる。
◎
An ExtendableEvent object has an associated timed out flag. It is initially unset, and is set after an optional user agent imposed delay if the pending promises count is greater than zero.
</dd>
</dl>

<p>
`ExtendableEvent$I ~objは、次を満たしている間は
`作動中@eX
であるとされる
⇒
［
`時間切れ~flag$ ~EQ ~F
］~AND［［
`処理待ち~promise数$ ~GT 0
］~OR［
`配送-~flag$ ~EQ ~T
］］
◎
An ExtendableEvent object is said to be active when its timed out flag is unset and either its pending promises count is greater than zero or its dispatch flag is set.
</p>

<p>
`~sw$には、 2 種の`~lifecycle~event$
— `install$et, `activate$et —
がある。
`~sw$は、これらの~event用に `ExtendableEvent$I ~interfaceを利用する。
◎
Service workers have two lifecycle events, install and activate. Service workers use the ExtendableEvent interface for activate event and install event.
</p>

<p>
`~event~handlerを定義-$する`拡張$も、
`ExtendableEvent$I ~interfaceを利用したり拡張してもヨイ。
◎
Service worker extensions that define event handlers may also use or extend the ExtendableEvent interface.
</p>

			<section id="wait-until-method">
<h4>4.4.1. `waitUntil(f)@m</h4>

<p class="note">注記：
この~methodは、~eventの~lifetimeを延長する。
◎
Note: waitUntil() method extends the lifetime of the event.
</p>

<p>
被呼出時には、次を走らすモノトスル：
◎
waitUntil(f) method must run these steps:
</p>

<ol>
	<li>
`~lifetime~promiseを追加する$( %f, 此れ )
◎
Let event be the context object.
◎
Add lifetime promise f to event.
</li>
</ol>

<div class="algorithm">

<p>
`~lifetime~promiseを追加する@
ときは、所与の
( `~promise$ %~promise, `ExtendableEvent$I %~event )
に対し，次を走らす：
◎
To add lifetime promise promise (a promise) to event (an ExtendableEvent), run these steps:
</p>

<ol>
	<li>
~IF［
%~event の `isTrusted$n ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If event’s isTrusted attribute is false, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
%~event は`作動中$eXでない
］
⇒
~THROW `InvalidStateError$E
◎
If event is not active, throw an "InvalidStateError" DOMException.
</p>

<p class="note">注記：
~event~handlerを~callした~task内で~lifetime延長~promiseが追加されなかった場合、後続の非同期的な~task内で `waitUntil()$m を~callすると，投出することになる。
◎
Note: If no lifetime extension promise has been added in the task that called the event handlers, calling waitUntil() in subsequent asynchronous tasks will throw.
</p>
	</li>
	<li>
%~event の`~lifetimeを延長する~promiseたち$に
%~promise を追加する
◎
Add promise to event’s extend lifetime promises.
</li>
	<li>
<p>
%~event の`処理待ち~promise数$ ~INCBY 1
◎
Increment event’s pending promises count by one.
</p>

<p class="note">注記：
所与の~promiseがすでに決着していた場合でも、`処理待ち~promise数$は増分される。
対応する減分は、その~promiseに対する反応（次の段）により~queueされる小task内で行われる。
◎
Note: The pending promises count is incremented even if the given promise has already been settled. The corresponding count decrement is done in the microtask queued by the reaction to the promise.
</p>
	</li>
	<li>
<p>
%~promise の［
`充足-時$／`却下-時$
］には
⇒
`小taskを~queueする$( 次の下位手続き ) ：
◎
Upon fulfillment or rejection of promise, queue a microtask to run these substeps:
</p>
		<ol>
			<li>
%~event の`処理待ち~promise数$ ~DECBY 1
◎
Decrement event’s pending promises count by one.
</li>
			<li>
~IF［
%~event の`処理待ち~promise数$ ~EQ 0
］
⇒
~RET
◎
If event’s pending promises count is 0, then:
</li>
			<li>
%登録 ~LET `現在の大域~obj$の`~sw$SWGを`包含している~sw登録$sw
◎
Let registration be the current global object's associated service worker's containing service worker registration.
</li>
			<li>
~IF［
%登録 は`未登録にされて$いる
］
⇒
`登録を消去しようと試行する$( %登録 )
◎
If registration is unregistered, invoke Try Clear Registration with registration.
</li>
			<li>
~IF［
%登録 ~NEQ ~NULL
］
⇒
`作動化しようと試行する$( %登録 )
◎
If registration is not null, invoke Try Activate with registration.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは、所与の`~sw$ %~sw に対し，［
`~swには処理待ち~eventは無い$( %~sw ) が ~F を返す間
］は %~sw を`終了-$するベキでない。
◎
The user agent should not terminate a service worker if Service Worker Has No Pending Events returns false for that service worker.
</p>

<div class="p">
<p>
`~event~handlerを定義-$する［
`~sw$／ `拡張$
］は、次のような自前の挙動を定義してもヨイ：
</p>
<ul><li>`~lifetimeを延長する~promiseたち$を許容することにより，演算の長さを示唆する。
</li><li>`~lifetimeを延長する~promiseたち$内の`~promise$に却下された状態を許容することにより，演算の失敗を示唆する。
</li></ul>

◎
Service workers and extensions that define event handlers may define their own behaviors, allowing the extend lifetime promises to suggest operation length, and the rejected state of any of the promise in extend lifetime promises to suggest operation failure.
</div>

<p class="note">注記：
`~sw$は、 `install$et ~eventの`~lifetimeを延長する~promiseたち$内のすべての`~promise$が成功裡に解決されるまで，`~install中の~worker$swrが `installed^l として扱われるのを遅延する（
<a href="#install-settle-step">~installする~algoの関連な段</a>
を見よ）。
いずれかの~promiseが却下された場合、その~installationは失敗する。
これは首に、`~sw$が依存する中核~cacheを成すすべてが拡充されるまで，
`installed^l （すなわち， `待機-中の~worker$swrである）と見なされないことを確保するために利用される。
同様に，`~sw$は、
`activate$et ~event内の`~lifetimeを延長する~promiseたち$内のすべての`~promise$が決着されるまで，`作動中の~worker$swr が
`activated^l として扱われるのを遅延する（
<a href="#activate-settle-step">作動化する~algoの関連な段</a>
を見よ。）
これは首に、`~sw$が［
~database~schemaを昇格して，期限切れの~cache~entryを削除する
］までは，［
`~sw$を表現する `ServiceWorkerGlobalScope$I ~objに向けて`機能的~event$は配送されない
］ことを確保するために利用される。
◎
Note: Service workers delay treating the installing worker as "installed" until all the promises in the install event’s extend lifetime promises resolve successfully. (See the relevant Install algorithm step.) If any of the promises rejects, the installation fails. This is primarily used to ensure that a service worker is not considered "installed" until all of the core caches it depends on are populated. Likewise, service workers delay treating the active worker as "activated" until all the promises in the activate event’s extend lifetime promises settle. (See the relevant Activate algorithm step.) This is primarily used to ensure that any functional events are not dispatched to the service worker until it upgrades database schemas and deletes the outdated cache entries.
</p>
<!-- 

<p>
`~sw$は、
<a href="#install">`install^et</a>,
<a href="#activate">`activate^et</a>
~event用に，次の挙動を定義する：
◎
Service workers define the following behaviors for install event and activate event, respectively:
</p>

<ul>
	<li>

</li>
	<li>
</li>
</ul>
 -->

			</section>
		</section>
		<section id="fetchevent-interface">
<h3>4.5. `FetchEvent^I</h3>

<pre class="idl">
[`FetchEvent@C(`DOMString$ %type, `FetchEventInit$I %eventInitDict), `Exposed$=ServiceWorker]
interface `FetchEvent@I : `ExtendableEvent$I {
  [`SameObject$] readonly attribute `Request$I `request$m;
  readonly attribute Promise&lt;any&gt; `preloadResponse$m;
  readonly attribute `DOMString$ `clientId$m;
  readonly attribute `DOMString$ `resultingClientId$m;
  readonly attribute `DOMString$ `replacesClientId$m;

  void `respondWith$m(Promise&lt;`Response$I&gt; %r);
};
</pre>

<pre class="idl" id="fetch-event-init-dictionary">
dictionary `FetchEventInit@I : `ExtendableEventInit$I {
  required `Request$I `request@m;
  Promise&lt;any&gt; `preloadResponse@m;
  `DOMString$ `clientId@m = "";
  `DOMString$ `resultingClientId@m = "";
  `DOMString$ `replacesClientId@m = "";
};
</pre>

<p>
`~sw$に~~不可欠な`機能的~event$には、 `fetch$et ~eventがある。
`~sw$は、  `FetchEvent$I ~interfaceを `fetch$et ~eventに利用する
— それは、 `ExtendableEvent$I ~interfaceを拡張する。
◎
Service workers have an essential functional event fetch. For fetch event, service workers use the FetchEvent interface which extends the ExtendableEvent interface.
</p>

<div >
<p>
`FetchEvent$I ~interfaceを利用する各~eventには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`応答になり得る@FE</dt>
	<dd>
`応答$または ~NULL。
初期~時は ~NULL とする。
</dd>

	<dt>`応答するまで待機-中~flag@FE</dt>
	<dt>`~enteredで応答する~flag@FE</dt>
	<dt>`~errorで応答する~flag@FE</dt>
	<dd>
いずれも、真偽値をとり，初期~時は ~F とする。
</dd>
</dl>

◎
Each event using FetchEvent interface has an associated potential response (a response), initially set to null, and the following associated flags that are initially unset:
• wait to respond flag
• respond-with entered flag
• respond-with error flag
</div>

`FetchEvent^I0

			<section id="fetch-event-request">
<h4>4.5.1. `request@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
◎
request attribute must return the value it was initialized to.
</p>

			</section>
			<section id="fetch-event-preloadresponse">
<h4>4.5.2. `preloadResponse@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は
`undefined^jv で`解決される~promise$に初期化するモノトスル。
◎
preloadResponse attribute must return the value it was initialized to. When an event is created the attribute must be initialized to a promise resolved with undefined.
</p>

			</section>
			<section id="fetch-event-clientid">
<h4>4.5.3. `clientId@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は
空~文字列に初期化するモノトスル。
◎
clientId attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

			</section>
			<section id="fetch-event-resultingclientid">
<h4>4.5.4. `resultingClientId@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は
空~文字列に初期化するモノトスル。
◎
resultingClientId attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

			</section>
			<section id="fetch-event-replacesClientId">
<h4>4.5.5. `replacesClientId@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は
空~文字列に初期化するモノトスル。
◎
replacesClientId attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

			</section>
			<section id="fetch-event-respondwith">
<h4>4.5.6. `respondWith(r)@m</h4>

<p class="note">注記：
開発者は、引数 %r を［
`Response$I ~objで解決される`~promise$ ／ `Response$I ~obj
］に設定できる（後者は自動的に~promiseに~castされる
【<a href="~PROMISES#resolve-arguments">~promiseとして解決される</a>】
）。
他の場合、`~fetch$に対し`~network~error$が返される。
［
非同一-生成元に属する内容に対する，具現化器 側における~tainting
］についての~security検査は、`~fetch$に定義される`絞込み応答$の種別に束ねられる。
◎
Note: Developers can set the argument r with either a promise that resolves with a Response object or a Response object (which is automatically cast to a promise). Otherwise, a network error is returned to Fetch. Renderer-side security checks about tainting for cross-origin content are tied to the types of filtered responses defined in Fetch.
</p>

<p>
被呼出時には、次を走らすモノトスル：
◎
respondWith(r) method must run these steps:
</p>

<ol>
	<li>
~IF［
此れの`配送-~flag$ ~EQ ~F
］~OR［
此れの`~enteredで応答する~flag$FE ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
Let event be the context object.
◎
If event’s dispatch flag is unset, throw an "InvalidStateError" DOMException.
◎
If event’s respond-with entered flag is set, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
`~lifetime~promiseを追加する$( %r, 此れ )
◎
Add lifetime promise r to event.
</p>

<p class="note">注記：
此れ . `respondWith(r)$m
は、既定で此れの~lifetimeを延長する
— 此れ . `waitUntil(r)$n が~callされたかのように。
◎
Note: event.respondWith(r) extends the lifetime of the event by default as if event.waitUntil(r) is called.
</p>
	</li>
	<li>
此れの
⇒＃
`伝播停止~flag$ ~SET ~T,
`伝播即停止~flag$ ~SET ~T,
`~enteredで応答する~flag$FE ~SET ~T,
`応答するまで待機-中~flag$FE ~SET ~T
◎
Set event’s stop propagation flag and stop immediate propagation flag.
◎
Set event’s respond-with entered flag.
◎
Set event’s wait to respond flag.
</li>
	<li>
%~target~Realm ~LET 此れに`関連な~Realm$
◎
Let targetRealm be event’s relevant Realm.
</li>
	<li>
<p>
%r の`却下-時$には：
◎
Upon rejection of r:
</p>
		<ol>
			<li>
此れの`~errorで応答する~flag$FE ~SET ~T
◎
Set event’s respond-with error flag.
</li>
			<li>
此れの`応答するまで待機-中~flag$FE ~SET ~F
◎
Unset event’s wait to respond flag.
</li>
		</ol>
	</li>
	<li>
<p>
%応答 による %r の`充足-時$には：
◎
Upon fulfillment of r with response:
</p>
		<ol>
			<li>
<p>
~IF［
%応答 は `Response$I ~objでない
］
⇒
此れの`~errorで応答する~flag$FE ~SET ~T
◎
If response is not a Response object, then set the respond-with error flag.
</p>

<p class="note">注記：
`~fetch$に対しては、`~errorで応答する~flag$FEに応じて［
~T ならば`~network~error$ ／
~F ならば %応答
］が，`~fetchを取扱う$~algoを通して返される。
【！＊step 22.1 】
◎
Note: If the respond-with error flag is set, a network error is returned to Fetch through Handle Fetch algorithm. (See the step 21.1.) Otherwise, the value response is returned to Fetch through Handle Fetch algorithm. (See the step 22.1.)
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Else:
</p>
				<ol>
					<li>
%~byte列 ~LET 空~byte列
◎
Let bytes be an empty byte sequence.
</li>
					<li>
%本体終端 ~LET ~F
◎
Let end-of-body be false.
◎
Let done be false.
</li>
					<li>
%応答になり得る ~LET %応答 に結付けられている`応答$Rsの複製
— ただし、`本体$rsは複製しない
◎
Let potentialResponse be a copy of response’s associated response, except for its body.
</li>
					<li>
<p>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］：
◎
If response’s body is non-null, run these substeps:
</p>
						<ol>
							<li>
%読取器 ~LET `読取器を取得する$( %応答 の`本体$rsの`~stream$ )
◎
Let reader be the result of getting a reader from response’s body's stream.
</li>
							<li>
%限界水位 ~LET ~UAが~~任意に選ぶ［
有限かつ負でない~number, または `Infinity^jv
］
◎
Let highWaterMark be a non-negative, non-NaN number, chosen by the user agent.
</li>
							<li>
%~size~algo ~LET 次を走らす~algo
⇒
`~chunk$~objを受容し，~UAが~~任意に選ぶ［
有限かつ負でない~number
］を返す
◎
Let sizeAlgorithm be an algorithm that accepts a chunk object and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
</li>
							<li>
<p>
%~pull ~LET 次を走らす動作
⇒
%~promise ~LET `~chunkを読取る$RS( %読取器 )
◎
Let pull be an action that runs these subsubsteps:
• Let promise be the result of reading a chunk from response’s body's stream with reader.
</p>

<div>
<p>
`object^jT %O による %~promise の充足-時には：
</p>
								<ol>
									<li>
~IF［
%O の `done^c ~prop ~EQ ~T
］
⇒
%本体終端 ~SET ~T
</li>
									<li>
<p>
~ELSE：
</p>
										<ol>
											<li>
%value ~LET %O の `value^c ~prop
</li>
											<li>
<p>
~IF［
%value は `Uint8Array^c ~objである
］：
</p>
												<ol>
													<li>
%~byte列 に %value が表現する~byte列を付加する
</li>
													<li>
~NOABRUPT `DetachArrayBuffer$jA( %value が包装している `ArrayBuffer^c ~obj )
</li>
												</ol>
											</li>
											<li>
~ELSE
⇒
`TypeError^E で %新-~stream を`~errorにする$
【！ ＊原文 ~FETCH#concept-readablestream-errored はおそらく誤記】
</li>
										</ol>
									</li>
								</ol>
◎
When promise is fulfilled with an object whose done property is false and whose value property is a Uint8Array object, append the bytes represented by the value property to bytes and perform ! DetachArrayBuffer with the ArrayBuffer object wrapped by the value property.
◎
When promise is fulfilled with an object whose done property is true, set end-of-body to true.
</div>

<p>
%~promise の却下-時には
⇒
`TypeError^E で %新-~stream を`~errorにする$
◎
When promise is fulfilled with a value that matches with neither of the above patterns, or promise is rejected, error newStream with a TypeError.
</p>


【 %新-~stream は下に与えられる。】
							</li>
							<li>
%取消す ~LET 次を走らす動作
⇒
%読取器 で %応答 の`本体$rsの`~stream$を`取消す$
◎
Let cancel be an action that cancels response’s body's stream with reader.
</li>
							<li>
%新-~stream ~LET
%~target~Realm 内で`~ReadableStream~objを構築する$( %限界水位, %~size~algo, %~pull, %取消す )
◎
Let newStream be the result of construct a ReadableStream object with highWaterMark, sizeAlgorithm, pull, and cancel in targetRealm.
</li>
							<li>
%応答になり得る の`本体$rs ~SET 次のようにされた 新たな`本体$
⇒
`~stream$ ~SET %新-~stream
◎
Set potentialResponse’s body to a new body whose stream is newStream.
</li>
							<li>
<p>
この段は`並列的$に走らす：
◎
Run these subsubsteps repeatedly in parallel＼
</p>

<p>
~WHILE 無条件：
◎
while done is false:
</p>
								<ol>
									<li>
~IF［
%新-~stream は`~errorした$
］
⇒
~BREAK
◎
If newStream is errored, then set done to true.
</li>
									<li>
%pull を遂行した結果の~promiseが決着するまで待機する
【この段はこの訳による補完】
</li>
									<li>
<p>
~IF［
%~byte列 は空である
］：
</p>
										<ol>
											<li>
~IF［
%本体終端 ~EQ ~F
］
⇒
~CONTINUE
</li>
											<li>
%新-~stream を`~closeする$
</li>
											<li>
~BREAK
</li>
										</ol>
◎
Otherwise, if bytes is empty and end-of-body is true, then close newStream and set done to true.
◎
Otherwise, if bytes is not empty, run these subsubsubsteps:
</li>
									<li>
%~chunk ~LET
%~byte列 の頭部を成す~byte列【どこまでかは述べられていない】
◎
Let chunk be a subsequence of bytes starting from the beginning of bytes.
</li>
									<li>
%~chunk を %~byte列 から除去する
◎
Remove chunk from bytes.
</li>
									<li>
%~buffer ~LET
%~target~Realm 内に作成され, %~chunk を包含している新たな `ArrayBuffer^I ~obj
◎
Let buffer be an ArrayBuffer object created in targetRealm and containing chunk.
</li>
									<li>
%新-~stream に次を`~enqueue$RSする
⇒
%~target~Realm 内に作成され, %~buffer を包装している新たな `Uint8Array^I ~obj
◎
Enqueue a Uint8Array object created in targetRealm and wrapping buffer to newStream.
</li>
								</ol>

<p class="note">注記：
この下位手続きは、［
%応答 の`本体$rsの`~stream$を %応答になり得る の中へ “~pipeすること”
］の，観測-可能な等価を生産することが意味されている。
◎
Note: These substeps are meant to produce the observable equivalent of "piping" response’s body's stream into potentialResponse.
</p>
							</li>
						</ol>
					</li>
					<li>
~IF［
%応答になり得る ~NEQ `~error^i
］
⇒
此れの`応答になり得る$FE ~SET %応答になり得る
◎
Set event’s potential response to potentialResponse.
</li>
				</ol>
			</li>
			<li>
此れの`応答するまで待機-中~flag$FE ~SET ~F
◎
Unset event’s wait to respond flag.
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="extendablemessageevent-interface">
<h3>4.6. `ExtendableMessageEvent^I</h3>

<pre class="idl">
[`ExtendableMessageEvent@C(`DOMString$ %type, optional `ExtendableMessageEventInit$I %eventInitDict = {}),
 `Exposed$=ServiceWorker]
interface `ExtendableMessageEvent@I : `ExtendableEvent$I {
  readonly attribute any `data$m;
  readonly attribute `USVString$ `origin$m;
  readonly attribute `DOMString$ `lastEventId$m;
  [`SameObject$] readonly attribute (`Client$I or `ServiceWorker$I or `MessagePort$I)? `source$m;
  readonly attribute FrozenArray&lt;`MessagePort$I&gt; `ports$m;
};
</pre>

<pre class="idl" id="extendablemessage-event-init-dictionary">
dictionary `ExtendableMessageEventInit@I : `ExtendableEventInit$I {
  any `data@m = null;
  `USVString$ `origin@m = "";
  `DOMString$ `lastEventId@m = "";
  (`Client$I or `ServiceWorker$I or `MessagePort$I)? `source@m = null;
  sequence&lt;`MessagePort$I&gt; `ports@m = [];
};
</pre>

<p>
`~sw$は、
<a href="#dom-extendableevent-waituntil">拡張-可能</a>な
`message$et ~eventを定義して、~eventの~lifetimeを延長するのを許容する。
`~sw$は、
`message$et
~eventに対しては，
`ExtendableMessageEvent$I
~interfaceを利用する
— それは `ExtendableEvent$I ~interfaceを拡張する。
◎
Service workers define the extendable message event to allow extending the lifetime of the event. For the message event, service workers use the ExtendableMessageEvent interface which extends the ExtendableEvent interface.
</p>

`ExtendableMessageEvent^I0

			<section id="extendablemessage-event-data">
<h4>4.6.1. `data@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は ~NULL に初期化するモノトスル。
それは、送信されている~messageを表現する。
◎
The data attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to null. It represents the message being sent.
</p>

			</section>
			<section id="extendablemessage-event-origin">
<h4>4.6.2. `origin@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は，空~文字列に初期化するモノトスル。
それは、~messageを送信した`~sw~client$の`生成元$enVを表現する。
◎
The origin attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to the empty string. It represents the origin of the service worker client that sent the message.
</p>

			</section>
			<section id="extendablemessage-event-lasteventid">
<h4>4.6.3. `lastEventId@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は，空~文字列に初期化するモノトスル。
◎
The lastEventId attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to the empty string.
</p>

			</section>
			<section id="extendablemessage-event-source">
<h4>4.6.4. `source@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は， ~NULL に初期化するモノトスル。
それは、~messageの送信-元 `Client$I ~objを表現する。
◎
The source attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to null. It represents the Client object from which the message is sent.
</p>

			</section>
			<section id="extendablemessage-event-ports">
<h4>4.6.5. `ports@m</h4>

<p>
取得子は、初期化-時の値を返すモノトスル。
此れの作成-時には、この属性は，空~配列に初期化するモノトスル。
それは、送信されている `MessagePort$I 配列を表現する。
◎
The ports attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to the empty array. It represents the MessagePort array being sent.
</p>

			</section>
		</section>
		<section id="execution-context-events">
<h3 title="Events">4.7. ~event</h3>

<p>
以下に挙げる~eventは、`~sw~event$と呼ばれ，
`ServiceWorkerGlobalScope$I ~objに向けて配送される
— 以下に現れる %~sw は、~objの`~sw$SWGを表すとする：
◎
The following events, called service worker events, are dispatched on ServiceWorkerGlobalScope object:
</p>

<table id="_event-table" class="grid-table">
<thead><tr><th>~event名
<th>~interface
<th>分類
<th>配送-時機
</thead>

<tbody><tr><td>`install@et
<td>`ExtendableEvent$I
<td>`~lifecycle~event$
<td>
%~sw を`包含している~sw登録$swにて`~install中の~worker$swrが変化したとき（`~installする$を見よ）。
【！＊ step 11.2 → 10.2 issues#1391】
◎
The service worker's containing service worker registration’s installing worker changes. (See step 11.2 of the Install algorithm.)

<tr><td>`activate@et
<td>`ExtendableEvent$I
<td>`~lifecycle~event$
<td>
%~sw を`包含している~sw登録$swにて`作動中の~worker$swrの変化したとき （`作動化する$を見よ）。
【！＊step 12.2 】
◎
The service worker's containing service worker registration’s active worker changes. (See step 12.2 of the Activate algorithm.)

<tr><td>`fetch@et
<td>`FetchEvent$I
<td>`機能的~event$
<td>
`~HTTP~fetch$は、`~fetchを取扱う$( 要請 ) を呼出す。
これを遂行した結果として、 %~sw は，`~HTTP~fetch$に`応答$を返す。
この`応答$は、`Response$I ~objにより表現され，［
`Cache$I ~objから ／
`self.fetch(input, init)$n ~methodを利用して~networkから直に
］検索取得できる。
（別の選択肢として~custom `Response$I ~objもある。）
◎
The http fetch invokes Handle Fetch with request. As a result of performing Handle Fetch, the service worker returns a response to the http fetch. The response, represented by a Response object, can be retrieved from a Cache object or directly from network using self.fetch(input, init) method. (A custom Response object can be another option.)

<tr><td>`push$et
<td>`PushEvent$I
<td>`機能的~event$
<td>
（
<a href="https://w3c.github.io/push-api/#dfn-fire-the-push-event">`push^et ~eventの発火-法</a>
を見よ。）
◎
(See Firing a push event.)

<tr><td>`notificationclick$et
<td>`NotificationEvent$I
<td>`機能的~event$
<td>
（
<a href="~NOTIFICATIONS#activating-a-notification">通知の作動化-法</a>
を見よ。）
◎
(See Activating a notification.)

<tr><td>`notificationclose$et
<td>`NotificationEvent$I
<td>`機能的~event$
<td>
（
<a href="~NOTIFICATIONS#closing-a-notification">通知の~close法</a>
を見よ。）
◎
(See Closing a notification.)

<tr><td>`sync$et
<td>`SyncEvent$I
<td>`機能的~event$
<td>
（
<a href="https://wicg.github.io/BackgroundSync/spec/#fire-a-sync-event">`sync^et ~eventの発火-法</a>
を見よ。）
◎
(See Firing a sync event.)

<tr><td>`canmakepayment$et
<td>`CanMakePaymentEvent$I
<td>`機能的~event$
<td>
（
<a href="https://w3c.github.io/payment-handler/#dfn-handling-a-canmakepaymentevent">`CanMakePaymentEvent^I の取扱い</a>
を見よ。）
◎
(See Handling a CanMakePaymentEvent.)

<tr><td>`paymentrequest$et
<td>`PaymentRequestEvent$I
<td>`機能的~event$
<td>
（
<a href="https://w3c.github.io/payment-handler/#dfn-handling-a-paymentrequestevent">`PaymentRequestEvent^I の取扱い</a>
を見よ。）
◎
(See Handling a PaymentRequestEvent.)

<tr><td>`message@et
<td>`ExtendableMessageEvent$I
<td>旧来の~event
<td>
~messageを受信したとき。
◎
When it receives a message.

<tr><td>`messageerror@et
<td>`MessageEvent$I
<td>旧来の~event
<td>
逆直列化できない~messageが送信されてきたとき。
◎
When it was sent a message that cannot be deserialized.

</tbody></table>

		</section>
	</section>
	<section id="cache-objects">
<h2 title="Caches">5. ~cache</h2>

<p>
作者が~offline用に内容~cacheを全部的に管理できるようにするため、［
`Window$I ／ `WorkerGlobalScope$I
］は，
`Cache$I ~objを~openして操作するための非同期的な~cache用~methodを供する。
同じ`生成元$enVは、複数の有名 `Cache$I ~objを持ち得る
— その内容は、まるごと~scriptの制御~下に置かれる。
~cacheは、異なる`生成元$間で共有されることはなく，~browserの~HTTP~cacheからも完全に隔離される。
◎
To allow authors to fully manage their content caches for offline use, the Window and the WorkerGlobalScope provide the asynchronous caching methods that open and manipulate Cache objects. An origin can have multiple, named Cache objects, whose contents are entirely under the control of scripts. Caches are not shared across origins, and they are completely isolated from the browser’s HTTP cache.
</p>

		<section id="cache-constructs">
<h3 title="Constructs">5.1. 構成子</h3>

<p>
`要請~応答~list@
は、 0 個~以上の
( `要請$ / `応答$ )
`~pair$からなる`~list$である。
◎
A request response list is a list of pairs consisting of a request (a request) and a response (a response).
</p>

<p>
~obj %O に
`関連な要請~応答~list@
は、 %O が表現する`要請~応答~list$を指す。
【 %O に該当するものは、この仕様においては `Cache$I ~objしかない。】
◎
The relevant request response list is the instance that the context object represents.
</p>

<p>
`名前から~cacheへの~map@
は、`有順序~map$であり，それを成す各`~entry$mapは［
`要請~応答~list$の名前を表現する文字列 → `要請~応答~list$
］を与える。
◎
A name to cache map is an ordered map whose entry consists of a key (a string that represents the name of a request response list) and a value (a request response list).
</p>

<p>
各`生成元$には、ある`名前から~cacheへの~map$が結付けられる。
◎
Each origin has an associated name to cache map.
</p>

<p>
~obj %O に
`関連な名前から~cacheへの~map@
は、
%O に`関連な設定群~obj$の`生成元$enVの`名前から~cacheへの~map$を指す。
【！%O に結付けられている`大域~obj$の`環境~設定群~obj$】
【 %O に該当するものは、この仕様においては `CacheStorage$I ~objしかない。】
◎
The relevant name to cache map is the instance of the context object's associated global object's environment settings object's origin.
</p>

		</section>
		<section id="cache-lifetimes">
<h3 title="Understanding Cache Lifetimes">5.2. ~cacheの~lifetimeを理解する</h3>

<p>
`Cache$I ~instanceは、~browserの~HTTP~cacheの一部を成さない。
作者~自身が、 `Cache$I ~objを管理する必要がある：
◎
The Cache instances are not part of the browser’s HTTP cache. The Cache objects are exactly what authors have to manage themselves.＼
</p>

<ul>
	<li>
作者が明示的に要請しない限り，更新されない。
◎
The Cache objects do not get updated unless authors explicitly request them to be.＼
</li>
	<li>
それを成す各~entryは、作者が削除しない限り失効しない。
◎
The Cache objects do not expire unless authors delete the entries.＼
</li>
	<li>
`~sw$~scriptを更新するだけで消失することはない
— すなわち、~cacheは自動的には更新されず，その更新-は手動で管理しなければナラナイ。
◎
The Cache objects do not disappear just because the service worker script is updated. That is, caches are not updated automatically. Updates must be manually managed.＼
</li>
</ul>

<p>
したがって作者は、自身の~cacheに名前†により~versionを付与した上で、それを利用するのは，安全に運用できる~versionの`~sw$に限るようにするべきである。
◎
This implies that authors should version their caches by name and make sure to use the caches only from the version of the service worker that can safely operate on.
</p>

<p class="trans-note">【†
`CacheStorage$I 上の各種~methodの %cacheName 引数 ／
`MultiCacheQueryOptions$I の `cacheName^m ~memberを指す。
】</p>

		</section>
		<section id="self-caches">
<h3>5.3. `self.caches^m</h3>

<pre class="idl">
partial interface mixin `WindowOrWorkerGlobalScope$I {
  [`SecureContext$, `SameObject$] readonly attribute `CacheStorage$I `caches$n;
};
</pre>

			<section id="global-caches">
<h4>5.3.1. `caches@n</h4>

<p>
取得子は、次を返すモノトスル
⇒
此れに結付けられている `CacheStorage$I ~obj
◎
caches attribute must return this object’s associated CacheStorage object.
</p>

			</section>
		</section>
		<section id="cache-interface">
<h3>5.4. `Cache^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `Cache@I {
  [`NewObject$] Promise&lt;any&gt; `match$m(`RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
  [`NewObject$] Promise&lt;FrozenArray&lt;`Response$I&gt;&gt; `matchAll$m(optional `RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
  [`NewObject$] Promise&lt;void&gt; `add$m(`RequestInfo$I %request);
  [`NewObject$] Promise&lt;void&gt; `addAll$m(sequence&lt;`RequestInfo$I&gt; %requests);
  [`NewObject$] Promise&lt;void&gt; `put$m(`RequestInfo$I %request, `Response$I %response);
  [`NewObject$] Promise&lt;`boolean$&gt; `delete$m(`RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
  [`NewObject$] Promise&lt;FrozenArray&lt;`Request$I&gt;&gt; `keys$m(optional `RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
};
</pre>

<pre class="idl" id="cache-query-options-dictionary">
dictionary `CacheQueryOptions@I {
  `boolean$ `ignoreSearch@m = false;
  `boolean$ `ignoreMethod@m = false;
  `boolean$ `ignoreVary@m = false;
};
</pre>

<p>
`Cache$I ~objは、`要請~応答~list$を表現する。
いくつかの文書や~workerにまたがって、同時に複数の `Cache$I ~objが 同じ`要請~応答~list$を表現し得る。
【同じ文書や~worker上でも，複数あり得る（ `CacheStorage^I1 `open()$m1 を見よ）。】
◎
A Cache object represents a request response list. Multiple separate objects implementing the Cache interface across documents and workers can all be associated with the same request response list simultaneously.
</p>

<div>
<p>
`~cache~batch演算@
は、次のものからなる`構造体$である：
</p>

<dl class="def-list">
	<dt>`種別@cbo</dt>
	<dd>
`delete^l, `put^l のいずれか。
</dd>

	<dt>`要請@cbo</dt>
	<dd>
`要請$。
</dd>

	<dt>`応答@cbo</dt>
	<dd>
`応答$。
</dd>

	<dt>`~options@cbo</dt>
	<dd>
`CacheQueryOptions$I ~obj。
</dd>
</dl>

◎
A cache batch operation is a struct that consists of:
• A type ("delete" or "put").
• A request (a request).
• A response (a response).
• An options (a CacheQueryOptions).
</div>

`Cache^I0

			<section id="cache-match">
<h4>5.4.1. `match(request, options)@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
match(request, options) method must run these steps:
• Let promise be a new promise.
• Run these substeps in parallel:
</p>

<ol>
	<li>
%p ~LET 此れ上で `matchAll(request, options)$m の~algoを遂行する
◎
Let p be the result of running the algorithm specified in matchAll(request, options) method with request and options.
</li>
	<li>
<p>
%p が決着するまでまで待機する：
◎
Wait until p settles.
</p>
		<ul>
			<li>
%p は %例外 で却下されたときは
⇒
%例外 で %~promise を却下する
◎
If p rejects with an exception, then:
• Reject promise with that exception.
</li>
			<li>
%p は配列 %応答たち で充足されたときは
⇒
次に与える値で %~promise を`解決する$
⇒＃
%応答たち は空でないならば その最初の要素 ／
~ELSE_ `undefined^jv
◎
Else if p resolves with an array, responses, then:
• If responses is an empty array, then:
•• Resolve promise with undefined.
• Else:
•• Resolve promise with the first element of responses.
</li>
		</ul>
<p>
◎
↑↑Return promise.
</p>
	</li>
</ol>

			</section>
			<section id="cache-matchall">
<h4>5.4.2. `matchAll(request, options)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
matchAll(request, options) method must run these steps:
</p>

<ol>
	<li>
%r ~LET ε
◎
Let r be null.
</li>
	<li>
<p>
~IF［
%request ~NEQ ε
］：
◎
If the optional argument request is not omitted, then:
</p>
		<ol>
			<li>
<p>
~IF［
%request は `Request$I ~objである
］：
◎
If request is a Request object, then:
</p>
				<ol>
					<li>
%r ~SET %request の`要請$Rq
◎
Set r to request’s request.
</li>
					<li>
~IF［
%r の`~method$rq ~NEQ `GET^bl
］~AND［
%options . `CacheQueryOptions^I1`ignoreMethod$m1 ~EQ ~F
］
⇒
~RET 空~配列で`解決される~promise$
◎
If r’s method is not `GET` and options.ignoreMethod is false, return a promise resolved with an empty array.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %request は文字列である）：
◎
Else if request is a string, then:
</p>
				<ol>
					<li>
%request ~SET 構築子 `Request(request)$n の~algoを遂行する
⇒
例外が投出されたときは、~catchして
⇒
~RET その例外で`却下される~promise$
◎
Set r to the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
					<li>
%r ~SET %request の`要請$Rq
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~realm ~LET 此れに`関連な~realm$
◎
Let realm be the context object's relevant realm.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%応答~list ~LET 新たな`~list$
◎
Let responses be an empty list.
</li>
			<li>
%要請~応答~list ~LET 此れに`関連な要請~応答~list$
◎
↓</li>
			<li>
~IF［
%r ~NEQ ε
］
⇒
%要請~応答~list ~SET `~cacheを~queryする$( %r, %要請~応答~list, %options )
◎
If the optional argument request is omitted, then:
• For each requestResponse of the relevant request response list:
•• Add a copy of requestResponse’s response to responses.
◎
Else:
• Let requestResponses be the result of running Query Cache with r and options.
•• For each requestResponse of requestResponses:
••• Add a copy of requestResponse’s response to responses.
（ copy は次の段で行う）
</li>
			<li>
%要請~応答~list を成す
~EACH( %要請~応答 )
に対し
⇒
%応答~list に［
%要請~応答 を成す応答
］の複製を`付加する$
◎
↑</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task, on promise’s relevant settings object's responsible event loop using the DOM manipulation task source, to perform the following steps:
</p>
				<ol>
					<li>
%応答~obj~list ~LET 新たな`~list$
◎
Let responseList be a list.
</li>
					<li>
%応答~list を成す
~EACH( %応答 )
に対し
⇒
%応答~obj~list に［
次のようにされた 新たな `Response$I ~obj
］を`付加する$
⇒＃
`応答$Rs ~SET %応答；
`~Headers$Rs ~SET ［ `~guard$hl ~SET `immutable^l ］にされた新たな `Headers$I ~obj
◎
For each response of responses:
• Add a new Response object associated with response and a new Headers object whose guard is "immutable" to responseList.
</li>
					<li>
次の結果で %~promise を`解決する$
⇒
%~realm 内で`凍結d配列を作成する$( %応答~obj~list )
◎
Resolve promise with a frozen array created from responseList, in realm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="cache-add">
<h4>5.4.3. `add(request)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
add(request) method must run these steps:
</p>

<ol>
	<li>
%requests ~LET %request のみを包含している配列
◎
Let requests be an array containing only request.
</li>
	<li>
%応答~配列~promise ~LET 此れ上で `addAll(requests)$m の~algoを遂行する
◎
Let responseArrayPromise be the result of running the algorithm specified in addAll(requests) passing requests as the argument.
</li>
	<li>
~RET ［
`undefined^jv を返す充足~handler
］で
%応答~配列~promise を`変形-$した結果
◎
Return the result of transforming responseArrayPromise with a fulfillment handler that returns undefined.
</li>
</ol>

			</section>
			<section id="cache-addAll">
<h4>5.4.4. `addAll(requests)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
addAll(requests) method must run these steps:
</p>

<ol>
	<li>
%応答~promiseたち ~LET 新たな`~list$
◎
Let responsePromises be an empty list.
</li>
	<li>
%要請~list ~LET 新たな`~list$
◎
Let requestList be an empty list.
</li>
	<li>
<p>
~IF［
%requests 内のある %要請~obj は次をいずれも満たす
］…：
</p>
		<ul>
			<li>
`Request$I ~objである
</li>
			<li>
%要請~obj の`要請$Rqは次を満たす
⇒
［
その`~URL$rqの`~scheme$url ~NIN { `http^l, `https^l }
］~OR［
その`~method$rq ~NEQ `GET^bl
］
</li>
		</ul>
<p>
…ならば
⇒
~RET `TypeError^E で`却下される~promise$
</p>
◎
For each request whose type is Request in requests:
• Let r be request’s request.
◎
If r’s url's scheme is not one of "http" and "https", or r’s method is not `GET`, return a promise rejected with a TypeError.
</li>
	<li>
<p>
%requests を成す
~EACH( %request )
に対し：
◎
For each request in requests:
</p>
		<ol>
			<li>
%request ~LET 構築子 `Request(request)$n の~algoを遂行する
【！ method = GET になる】
⇒
例外が投出されたときは、~catchして
⇒
~RET その例外で`却下される~promise$
◎
Let r be the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
			<li>
%要請 ~LET %request の`要請$Rq
◎
↑</li>
			<li>
<p>
~IF［
%要請 の`~URL$rqの`~scheme$url ~NIN { `http^l, `https^l }
］：
◎
If r’s url's scheme is not one of "http" and "https", then:
</p>
				<ol>
					<li>
%requests により起動された
~EACH( 進行中の~fetch )
に対し
⇒
それを`終了させる$( `中止する^i )
◎
Terminate all the ongoing fetches initiated by requests with the aborted flag set.
</li>
					<li>
~RET `TypeError^E で`却下される~promise$
◎
Return a promise rejected with a TypeError.
</li>
				</ol>
			</li>
			<li>
~IF［
%要請 の`~client$rqの`大域~obj$enV は `ServiceWorkerGlobalScope$I ~objである
］
⇒
%要請 の`~sw~mode$rq ~SET `none^l
【！＊request】
◎
If r’s client's global object is a ServiceWorkerGlobalScope object, set request’s service-workers mode to "none".
</li>
			<li>
%要請 の
⇒＃
`起動元$rq ~SET `fetch^l,
`行先$rq ~SET `subresource^l
◎
Set r’s initiator to "fetch" and destination to "subresource".
</li>
			<li>
%要請~list に %要請 を`付加する$
◎
Add r to requestList.
</li>
			<li>
%応答~promise ~LET  `新たな~promise$
◎
Let responsePromise be a new promise.
</li>
			<li>
<p>
この段は`並列的$に走らす
⇒
%要請 を`~fetch$する：
◎
Run the following substeps in parallel:
• Fetch r.
</p>
				<ul>
					<li>
<p>
`応答を処理する$ときは、所与の %応答 に対し：
◎
To process response for response, run these substeps:
</p>
						<ol>
							<li>
~IF［
%応答 の`種別$rs ~EQ `error^l
］~OR［
%応答 の`状態s$rsは`~ok状態s$でない
］~OR［
%応答 の`状態s$rs ~EQ `206^st
］
⇒
`TypeError^E で %応答~promise を却下する
◎
If response’s type is "error", or response’s status is not an ok status or is 206, reject responsePromise with a TypeError.
</li>
							<li>
<p>
~ELIF［
%応答 の`~header~list$rs内に `Vary$h を`名前に持つ~header$はある
］~AND［
その~header値を成す ある `field-value$P ~EQ `*^bl
］：
◎
Else if response’s header list contains a header named `Vary`, then:
• Let fieldValues be the list containing the elements corresponding to the field-values of the Vary header.
•• For each fieldValue of fieldValues:
••• If fieldValue matches "*", then:
</p>
								<ol>
									<li>
`TypeError^E で %応答~promise を却下する
◎
Reject responsePromise with a TypeError.
</li>
									<li>
%requests により起動された
~EACH( 進行中の~fetch )
に対し
⇒
それを`終了させる$( `中止する^i )
◎
Terminate all the ongoing fetches initiated by requests with the aborted flag set.
◎
Abort these steps.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
<p>
`応答の本体終端を処理する$ときは、所与の
( %応答 )
に対し：
◎
To process response end-of-body for response, run these substeps:
</p>

						<ol>
							<li>
~IF［
%応答 の`中止~flag$rs ~EQ ~T
］
⇒＃
`AbortError$E 例外で %応答~promise を却下する；
◎
If response’s aborted flag is set, reject responsePromise with an "AbortError" DOMException and abort these steps.
</li>
							<li>
~ELSE
⇒
%応答 で %応答~promise を`解決する$
◎
Resolve responsePromise with response.
</li>
						</ol>

<p class="note">注記：
応答の本体が全部的に受信されたときは、~cache~commitは許容される。
◎
Note: The cache commit is allowed when the response’s body is fully received.
</p>
					</li>
				</ul>
			</li>
			<li>
%応答~promiseたち に %応答~promise を`付加する$
◎
Add responsePromise to responsePromises.
</li>
		</ol>
	</li>
	<li>
%p ~LET `すべての~promiseを待機する$( %応答~promiseたち, † )
【`すべてを待機する~promiseを取得する$？`1363$issue ／†成功~手続きが指定されていない — 下の充足~handlerを適切に解釈し直す必要がある。】
◎
Let p be waiting for all of responsePromises.
</li>
	<li>
<div class="p">
<p>
~RET 次に与える充足~handlerで %p を`変形-$した結果
</p>

<p>
充足~handlerは、引数 ( %応答~obj~list ) で~callされたとき，次の下位手続きを遂行する：
</p>
◎
Return the result of transforming p with a fulfillment handler that, when called with argument responses, performs the following substeps:
</div>
		<ol>
			<li>
%演算~list ~LET 新たな`~list$
◎
Let operations be an empty list.
</li>
			<li>
%~index ~LET 0
◎
Let index be zero.
</li>
			<li>
<p>
%応答~obj~list を成す
~EACH( %応答~obj )
に対し：
◎
For each response in responses:
</p>

				<ol>
					<li>
%演算~list に［
次のようにされた 新たな`~cache~batch演算$
］を`付加する$
⇒＃
`種別$cbo ~SET `put^l,
`要請$cbo ~SET %要請~list[ %~index ],
`応答$cbo ~SET %応答~obj 【の`応答$Rs】
◎
Let operation be a cache batch operation.
◎
Set operation’s type to "put".
◎
Set operation’s request to requestList[index].
◎
Set operation’s response to response.
◎
Append operation to operations.
</li>
					<li>
%~index ~INCBY 1
◎
Increment index by one.
</li>
				</ol>
			</li>
			<li>
%~realm ~LET 此れに`関連な~Realm$
◎
Let realm be the context object's relevant realm.
</li>
			<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
			<li>
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
%~error~data ~LET ~NULL
◎
Let errorData be null.
</li>
					<li>
`~cache演算を~batchする$( %演算~list, 此れ )
⇒
例外が投出されたときは、~catchして
⇒
%~error~data ~SET その例外
◎
Invoke Batch Cache Operations with operations. If this throws an exception, set errorData to the exception.
</li>
				<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~cache~job~promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task, on cacheJobPromise’s relevant settings object's responsible event loop using the DOM manipulation task source, to perform the following substeps:
</p>

					<ol>
						<li>
~IF［
%~error~data ~EQ ~NULL
］
⇒
`undefined^jv で %~cache~job~promise を`解決する$
◎
If errorData is null, resolve cacheJobPromise with undefined.
</li>
	<li>
~ELSE
⇒
次に与える例外で %~cache~job~promise を却下する
⇒
%~realm 内に作成される`新たな例外$( %~error~data, ~UAにより定義される`~message$ )
◎
Else, reject cacheJobPromise with a new exception with errorData and a user agent-defined message, in realm.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~RET %~cache~job~promise
◎
Return cacheJobPromise.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="cache-put">
<h4>5.4.5. `put(request, response)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
put(request, response) method must run these steps:
</p>

<ol>
	<li>
<p>
~IF［
%request は `Request$I ~objでない【文字列である】
］
⇒
%request ~SET 構築子 `Request(request)$n の~algoを遂行する
【！ method = GET になる】
⇒
例外が投出されたときは、~catchして
⇒
~RET その例外で`却下される~promise$
◎
Let innerRequest be null.
◎
If request is a Request object, then set innerRequest to request’s request.
◎
Else:
• Let requestObj be the result of invoking Request's constructor with request as its argument. If this throws an exception, return a promise rejected with exception.
• Set innerRequest to requestObj’s request.
</li>
	<li>
%内縁~要請 ~LET %request の`要請$Rq
◎
↑</li>
	<li>
~IF［
%内縁~要請 の`~URL$rqの`~scheme$url ~NIN { `http^l , `https^l }
］~OR［
%内縁~要請 の`~method$rq ~NEQ `GET^bl
］
⇒
~RET `TypeError^E で`却下される~promise$：
◎
If innerRequest’s url's scheme is not one of "http" and "https", or innerRequest’s method is not `GET`, return a promise rejected with a TypeError.
◎
</li>
	<li>
%内縁~応答 ~LET %response の`応答$Rs
◎
Let innerResponse be response’s response.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `TypeError^E で`却下される~promise$：
◎
↓</p>
		<ul>
			<li>
%内縁~応答 の`状態s$rs ~EQ `206^st
◎
If innerResponse’s status is 206, return a promise rejected with a TypeError.
</li>
			<li>
［
%内縁~応答 の`~header~list$rs内に `Vary$h を`名前に持つ~header$はある
］~AND［
その~header値を成す ある `field-value$P ~EQ `*^bl
］
◎
If innerResponse’s header list contains a header named `Vary`, then:
• Let fieldValues be the list containing the items corresponding to the Vary header’s field-values.
•• For each fieldValue in fieldValues:
••• If fieldValue matches "*", return a promise rejected with a TypeError.
</li>
			<li>
%内縁~応答 の`本体$rsは［
`妨げられて$いる／`~lockされて$いる
］
◎
If innerResponse’s body is disturbed or locked, return a promise rejected with a TypeError.
</li>
		</ul>
	</li>
	<li>
%~cloneされた応答 ~LET `応答を~cloneする$( %内縁~応答 )
◎
Let clonedResponse be a clone of innerResponse.
</li>
	<li>
%本体を読取る~promise ~LET `undefined^jv で`解決される~promise$
◎
Let bodyReadPromise be a promise resolved with undefined.
</li>
	<li>
<p>
~IF［
%内縁~応答 の`本体$rs ~NEQ ~NULL
］：
◎
If innerResponse’s body is non-null, run these substeps:
</p>
		<ol>
			<li>
%~stream ~LET %内縁~応答 の`本体$rsの`~stream$
◎
Let stream be innerResponse’s body's stream.
</li>
			<li>
%読取器 ~LET `読取器を取得する$( %~stream )
◎
Let reader be the result of getting a reader for stream.
</li>
			<li>
%本体を読取る~promise ~SET %読取器 で %~stream から`~byte列すべてを読取る$
◎
Set bodyReadPromise to the result of reading all bytes from stream with reader.
</li>
		</ol>
<p class="note">注記：
これは、 %内縁~応答 の`本体$rsが`~lockされ$ることを確保して、
%~cloneされた応答 内の本体を全部的に~bufferした複製を得る。
実装は、~memoryではなく~diskへ直に~streamすることにより最適化することもできる。
◎
Note: This ensures that innerResponse’s body is locked, and we have a full buffered copy of the body in clonedResponse. An implementation could optimize by streaming directly to disk rather than memory.
</p>
	</li>
	<li>
%演算 ~LET 次のようにされた 新たな`~cache~batch演算$
⇒＃
`種別$cbo ~SET `put^l
`要請$cbo ~SET %内縁~要請
`応答$cbo ~SET %~cloneされた応答
◎
Let operations be an empty list.
◎
Let operation be a cache batch operation.
◎
Set operation’s type to "put".
◎
Set operation’s request to innerRequest.
◎
Set operation’s response to clonedResponse.
◎
Append operation to operations.
</li>
	<li>
%~realm ~LET 此れに`関連な~realm$
◎
Let realm be the context object's relevant realm.
</li>
	<li>
<p>
%本体を読取る~promise の`充足-時$の結果を返す【この言明は何を意味する？】：
◎
Return the result of the fulfillment of bodyReadPromise:
</p>
		<ol>
			<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
			<li>
~RET %~cache~job~promise
— ただし、以下も`並列的$に走らす
◎
Return cacheJobPromise and run these steps in parallel:
</li>
			<li>
%~error~data ~LET ~NULL
◎
Let errorData be null.
</li>
			<li>
`~cache演算を~batchする$( « %演算 », 此れ )
⇒
例外が投出されたときは、~catchして
⇒
%~error~data ~SET その例外
◎
Invoke Batch Cache Operations with operations. If this throws an exception, set errorData to the exception.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~cache~job~promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task, on cacheJobPromise’s relevant settings object's responsible event loop using the DOM manipulation task source, to perform the following substeps:
</p>
				<ol>
					<li>
~IF［
%~error~data ~EQ ~NULL
］
⇒
`undefined^jv で %~cache~job~promise を`解決する$
◎
If errorData is null, resolve cacheJobPromise with undefined.
</li>
					<li>
~ELSE
⇒
次に与える例外で %~cache~job~promise を却下する
⇒
%~realm 内に作成される`新たな例外$( %~error~data, ~UAにより定義される`~message$ )
◎
Else, reject cacheJobPromise with a new exception with errorData and a user agent-defined message, in realm.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="cache-delete">
<h4>5.4.6. `delete(request, options)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
delete(request, options) method must run these steps:
</p>

<ol>
	<li>
%r ~LET ~NULL
◎
Let r be null.
</li>
	<li>
<p>
~IF［
%request は `Request$I ~objである
］：
◎
If request is a Request object, then:
</p>
		<ol>
			<li>
%r ~SET %request の`要請$Rq
◎
Set r to request’s request.
</li>
			<li>
~IF［
%r の`~method$rq ~NEQ `GET^bl
］~AND［
%~options . `ignoreMethod$m1 ~EQ ~F
］
⇒
~RET ~F で`解決される~promise$
◎
If r’s method is not `GET` and options.ignoreMethod is false, return a promise resolved with false.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %request は文字列である）：
◎
Else if request is a string, then:
</p>
		<ol>
			<li>
%request ~SET 構築子 `Request(request)$n の~algoを遂行する
⇒
例外が投出されたときは、~catchして
⇒
~RET その例外で`却下される~promise$
◎
Set r to the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
			<li>
%r ~SET %request の`要請$Rq
◎
↑</li>
		</ol>
	</li>
	<li>
%演算~list ~LET 次のようにされた 新たな`~cache~batch演算$のみからなる，新たな`~list$
⇒＃
`種別$cbo ~SET `delete^l,
`要請$cbo ~SET %r,
%演算 の`~options$cbo ~SET %options
◎
Let operations be an empty list.
◎
Let operation be a cache batch operation.
◎
Set operation’s type to "delete".
◎
Set operation’s request to r.
◎
Set operation’s options to options.
◎
Append operation to operations.
</li>
	<li>
%~realm ~LET 此れに`関連な~Realm$
◎
Let realm be the context object's relevant realm.
</li>
	<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
%~error~data ~LET ~NULL
◎
Let errorData be null.
</li>
			<li>
%要請~応答~list ~LET `~cache演算を~batchする$( %演算~list, 此れ )
⇒
例外が投出されたときは、~catchして
⇒
%~error~data ~SET その例外
◎
Let requestResponses be the result of running Batch Cache Operations with operations. If this throws an exception, set errorData to the exception.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~cache~job~promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task, on cacheJobPromise’s relevant settings object's responsible event loop using the DOM manipulation task source, to perform the following substeps:
</p>

				<ol>
					<li>
<p>
~IF［
%~error~data ~EQ ~NULL
］
⇒
次に与える値で %~cache~job~promise を`解決する$
⇒＃
%要請~応答~list は`空$でないならば ~T ／
~ELSE_ ~F 
◎
If errorData is null, then:
• If requestResponses is not empty, resolve cacheJobPromise with true.
• Else, resolve cacheJobPromise with false.
</li>
					<li>
~ELSE
⇒
次に与える例外で %~cache~job~promise を却下する
⇒
%~realm 内に作成される`新たな例外$( %~error~data, ~UAにより定義される`~message$ )
◎
Else, reject cacheJobPromise with a new exception with errorData and a user agent-defined message, in realm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~cache~job~promise
◎
Return cacheJobPromise.
</li>
</ol>

			</section>
			<section id="cache-keys">
<h4>5.4.7. `keys(request, options)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
keys(request, options) method must run these steps:
</p>

<ol>
	<li>
%r ~LET ε
◎
Let r be null.
</li>
	<li>
<p>
~IF［
%request ~NEQ ε
］：
◎
If the optional argument request is not omitted, then:
</p>
		<ol>
			<li>
<p>
~IF［
%request は `Request$I ~objである
］：
◎
If request is a Request object, then:
</p>

				<ol>
					<li>
%r ~SET %request の`要請$Rq
◎
Set r to request’s request.
</li>
					<li>
~IF［
%r の`~method$rq ~NEQ `GET^bl
］~AND［
%options . `ignoreMethod$m1 ~EQ ~F
］
⇒
~RET 空~配列で`解決される~promise$
◎
If r’s method is not `GET` and options.ignoreMethod is false, return a promise resolved with an empty array.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %request は文字列である）：
◎
Else if request is a string, then:
</p>

				<ol>
					<li>
%request ~SET 構築子 `Request(request)$n の~algoを遂行する
⇒
例外が投出されたときは、~catchして
⇒
~RET その例外で`却下される~promise$
◎
Set r to the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
					<li>
%r ~SET %request の`要請$Rq
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~realm ~LET 此れに`関連な~Realm$
◎
Let realm be the context object's relevant realm.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%要請~list ~LET 新たな`~list$
◎
Let requests be an empty list.
</li>
			<li>
%要請~応答~list ~LET 此れに`関連な要請~応答~list$
◎
↓</li>
			<li>
~IF［
%r ~NEQ ε
］
⇒
%要請~応答~list ~SET `~cacheを~queryする$( %r, %要請~応答~list, %options )
◎
↓</li>
			<li>
%要請~応答~list を成す
~EACH( %要請~応答 )
に対し
⇒
%要請~list に［
%要請~応答 を成す要請
］を`付加する$
◎
If the optional argument request is omitted, then:
• For each requestResponse of the relevant request response list:
•• Add requestResponse’s request to requests.
◎
Else:
• Let requestResponses be the result of running Query Cache with r and options.
•• For each requestResponse of requestResponses:
••• Add requestResponse’s request to requests.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task, on promise’s relevant settings object's responsible event loop using the DOM manipulation task source, to perform the following steps:
</p>
				<ol>
					<li>
%要請~obj~list ~LET 新たな`~list$
◎
Let requestList be a list.
</li>
					<li>
%要請~list を成す
~EACH( %要請 )
に対し
⇒
%要請~obj~list に 次のようにされた 新たな `Request$I ~objを`付加する$
⇒＃
`要請$Rq ~SET %要請,
`~Headers$Rq ~SET ［ `~guard$hl ~SET `immutable^l ］にされた新たな `Headers$I ~obj
◎
For each request of requests:
• Add a new Request object associated with request and a new associated Headers object whose guard is "immutable" to requestList.
</li>
					<li>
次の結果で %~promise を`解決する$
⇒
%~realm 内で`凍結d配列を作成する$( %要請~obj~list )
◎
Resolve promise with a frozen array created from requestList, in realm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="cachestorage-interface">
<h3>5.5. `CacheStorage^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `CacheStorage@I {
  [`NewObject$] Promise&lt;any&gt; `match$m(`RequestInfo$I %request, optional `MultiCacheQueryOptions$I %options = {});
  [`NewObject$] Promise&lt;`boolean$&gt; `has$m(`DOMString$ %cacheName);
  [`NewObject$] Promise&lt;`Cache$I&gt; `open$m(`DOMString$ %cacheName);
  [`NewObject$] Promise&lt;`boolean$&gt; `delete$m(`DOMString$ %cacheName);
  [`NewObject$] Promise&lt;sequence&lt;`DOMString$&gt;&gt; `keys$m();
};

dictionary `MultiCacheQueryOptions@I : `CacheQueryOptions$I {
  DOMString `cacheName@m;
};
</pre>

<p class="note">注記：
`CacheStorage$I ~interfaceは
<a href="~TC39#sec-map-objects">ECMAScript 6 Map object</a>
に幅広く適合するよう設計されているが、全体的に非同期cであり，追加的な便利~methodも伴う。
［
`clear()^m ／ `forEach()^m ／ `entries()^m ／ `values()^m
］~methodは、最初の~versionの視野からは，意図的に除外されている
— TC39 による非同期cな反復についての進行中の論点に委ねられているので。
◎
Note: CacheStorage interface is designed to largely conform to ECMAScript 6 Map objects but entirely async, and with additional convenience methods. The methods, clear, forEach, entries and values, are intentionally excluded from the scope of the first version resorting to the ongoing discussion about the async iteration by TC39.
</p>

<p>
~UAは，［
`Window$I ／ `WorkerGlobalScope$I
］大域~obj %G を作成したときは、
`CacheStorage$I ~obj %C を作成して，それに %G を結付けるモノトスル。
この %G を指して，単に %C の
`大域~obj@
と称される。
◎
The user agent must create a CacheStorage object when a Window object or a WorkerGlobalScope object is created and associate it with that global object.
</p>

<p>
`CacheStorage$I ~objは、その`大域~obj$の`環境~設定群~obj$†の`生成元$enVに属する`名前から~cacheへの~map$††を表現する。
いくつかの文書や~workerにまたがって、同時に複数の `CacheStorage$I ~objが 同じ`名前から~cacheへの~map$を表現し得る†††。
◎
A CacheStorage object represents a name to cache map of its associated global object's environment settings object’s origin. Multiple separate objects implementing the CacheStorage interface across documents and workers can all be associated with the same name to cache map simultaneously.
</p>

<p class="trans-note">【†
すなわち、`関連な設定群~obj$。
】【††
すなわち、`関連な名前から~cacheへの~map$。
】【†††
が、各 `大域~obj$enVごとに， 1 個に限られる
— この~objを返す `caches$n 属性は [SameObject] なので。
】</p>

`CacheStorage^I0

			<section id="cache-storage-match">
<h4>5.5.1. `match(request, options)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
match(request, options) method must run these steps:
</p>

<ol>
	<li>
<p>
~IF［
%options . `MultiCacheQueryOptions^I1`cacheName$m1 は`在する$
］：
◎
If options.cacheName is present, then:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
</li>
			<li>
~RET %~promise
— ただし、以降の手続きも`並列的$に走らす
◎
Return a new promise promise and run the following substeps in parallel:
</li>
			<li>
%結果 ~LET `undefined^jv
◎
↓</li>
			<li>
%~cache ~LET 此れに`関連な名前から~cacheへの~map$[ %options . `cacheName$m1 ]
◎
↓</li>
			<li>
~IF［
%~cache ~NEQ ε
］
⇒
%結果 ~LET %~cache 【を表現する（新たな？） `Cache$I ~obj】上で `Cache^I1`match(request, options)$m1 の~algoを遂行する
◎
For each cacheName → cache of the relevant name to cache map:
• If options.cacheName matches cacheName, then:
•• Resolve promise with the result of running the algorithm specified in match(request, options) method of Cache interface with request and options (providing cache as thisArgument to the [[Call]] internal method of match(request, options).)
• Abort these steps.
</li>
			<li>
%結果 で %~promise を`解決する$
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
%~promise ~LET `undefined^jv で`解決される~promise$
◎
Else:
◎
Let promise be a promise resolved with undefined.
</li>
	<li>
<p>
此れに`関連な名前から~cacheへの~map$を成す
~EACH( %~cache名 → %~cache )
に対し：
◎
For each cacheName → cache of the relevant name to cache map:
</p>
		<ol>
			<li>
<p>
%~promise ~SET ［
引数 ( %応答 ) で~callされたとき，次の下位手続きを遂行する充足~handler
］で %~promise を`変形-$した結果：
◎
Set promise to the result of transforming itself with a fulfillment handler that, when called with argument response, performs the following substeps:
</p>
				<ol>
					<li>
~IF［
%応答 ~NEQ `undefined^jv
］
⇒
~RET %応答
◎
If response is not undefined, return response.
</li>
					<li>
~RET
%~cache 上で `Cache^I1`match(request, options)$m1 の~algoを遂行する
◎
Return the result of running the algorithm specified in match(request, options) method of Cache interface with request and options as the arguments (providing cache as thisArgument to the [[Call]] internal method of match(request, options).)
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="cache-storage-has">
<h4>5.5.2. `has(cacheName)@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
has(cacheName) method must run these steps:
• Let promise be a new promise.
• Run the following substeps in parallel:
</p>

<ol>
	<li>
［
次が満たされるならば ~T ／
~ELSE_ ~F
］で %~promise を`解決する$
⇒
此れに`関連な名前から~cacheへの~map$[ %cacheName ] ~NEQ ε
◎
For each key → value of the relevant name to cache map:
• If cacheName matches key, resolve promise with true and abort these steps.
◎
Resolve promise with false.
◎
↑↑
Return promise.
</li>
</ol>

			</section>
			<section id="cache-storage-open">
<h4>5.5.3. `open(cacheName)@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
open(cacheName) method must run these steps:
• Let promise be a new promise.
• Run the following substeps in parallel:
</p>

<div>
<ol>
	<li>
%~cache ~LET 此れに`関連な名前から~cacheへの~map$[ %cacheName ]
</li>
	<li>
<p>
~IF［
%~cache ~EQ ε
］：
</p>
		<ol>
			<li>
%~cache ~SET 新たな`要請~応答~list$
</li>
			<li>
此れに`関連な名前から~cacheへの~map$[ %cacheName ] ~SET %~cache
⇒
~IF［
この~cache書込-演算は、是認されている~quota制限-を超過することにより失敗した
］
⇒＃
`QuotaExceededError$E 例外で %~promise を`却下する$；
~RET
</li>
		</ol>
	</li>
	<li>
［
%~cache を表現する新たな `Cache$I ~obj
］で %~promise を`解決する$
</li>
</ol>

◎
For each key → value of the relevant name to cache map:
• If cacheName matches key, then:
•• Resolve promise with a new Cache object that represents value.
•• Abort these steps.
• Let cache be a new request response list.
• Set the relevant name to cache map[cacheName] to cache. If this cache write operation failed due to exceeding the granted quota limit, reject promise with a "QuotaExceededError" DOMException and abort these steps.
• Resolve promise with a new Cache object that represents cache.
◎
↑↑
Return promise.
</div>

			</section>
			<section id="cache-storage-delete">
<h4>5.5.4. `delete(cacheName)@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
delete(cacheName) method must run these steps:
</p>

<ol>
	<li>
%~promise ~LET 此れ上で `has(cacheName)$m の~algoを遂行する
◎
Let promise be the result of running the algorithm specified in has(cacheName) method with cacheName.
</li>
	<li>
<div class="p">
<p>
~RET 次に与える充足~handlerで %~promise を`変形-$した結果
</p>

<p>
充足~handlerは、引数 ( %~cacheは存在する ) で~callされたとき，次の下位手続きを遂行する：
</p>
◎
Return the result of transforming promise with a fulfillment handler that, when called with argument cacheExists, performs the following substeps:
</div>
		<ol>
			<li>
~IF［
%~cacheは存在する ~EQ ~F
］
⇒
~RET ~F
◎
If cacheExists is false, then:
• Return false.
</li>
			<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
			<li>
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
此れに`関連な名前から~cacheへの~map$[ %cacheName ] ~SET ε
◎
Remove the relevant name to cache map[cacheName].
</li>
					<li>
~T で %~cache~job~promise を`解決する$
◎
Resolve cacheJobPromise with true.
</li>
				</ol>

<p class="note">注記：
この段~以降も、既存の~DOM~obj（すなわち，現在~参照されている
`Cache^I ／ `Request^I ／ `Response^I
~obj）は機能し続けるべきである。
◎
Note: After this step, the existing DOM objects (i.e. the currently referenced Cache, Request, and Response objects) should remain functional.
</p>
			</li>
			<li>
~RET %~cache~job~promise
◎
Return cacheJobPromise.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="cache-storage-keys">
<h4>5.5.5. `keys()@m</h4>

<p>
被呼出時には、`新たな~promise$ %~promise を返した上で，次の手続きを`並列的$に走らすモノトスル：
◎
keys() method must run these steps:
• Let promise be a new promise.
• Run the following substeps in parallel:
</p>

<ol>
	<li>
<p>
%~cache~keyたち ~LET `~key~listを取得する$( 此れに`関連な名前から~cacheへの~map$ )
◎
Let cacheKeys be the result of getting the keys of the relevant name to cache map.
</p>

<p class="note">注記：
結果の`有順序~集合$における`~item$たちの順序は、それらに対応する~entryが`名前から~cacheへの~map$に追加された順になる。
◎
Note: The items in the result ordered set are in the order that their corresponding entry was added to the name to cache map.
</p>
	</li>
	<li>
%~cache~keyたち で %~promise を`解決する$
◎
Resolve promise with cacheKeys.
◎
↑↑
Return promise.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">6. ~security考慮点</h2>

		<section id="secure-context">
<h3 title="Secure Context">6.1. ~secure文脈</h3>

<div class="p">
<p>
`~sw$の実行, および
`~sw~client$による次に挙げる行いは、`~secure文脈$内に限られるモノトスル：
</p>

<ul ><li>`~sw登録$を登録する
</li><li>`~sw登録$への~accessを取得する
</li><li>`~sw$への~accessを取得する
</li><li>他の`~sw$と~messageをやりとりする
</li><li>`~sw$により操作されるようになること
</li></ul>

◎
Service workers must execute in secure contexts. Service worker clients must also be secure contexts to register a service worker registration, to get access to the service worker registrations and the service workers, to do messaging with the service workers, and to be manipulated by the service workers.
</div>

<p class="note">注記：
これは実質的に、`~sw$とその`~sw~client$は，~HTTPS越しに~hostする必要があることを意味する。
~UAは、開発~目的に［
`localhost^c （
<a href="~SECURE-CONTEXT#localhost">要件</a>を見よ）,
`127.0.0.0/8^c ／
`::1/128^c
］を許容できる。
この制約の首な理由は、
<a href="~SECURE-CONTEXT#threat-risks">~secureでない文脈に結付けられる~risk</a>
から利用者を保護することである。
◎
Note: This effectively means that service workers and their service worker clients need to be hosted over HTTPS. A user agent can allow localhost (see the requirements), 127.0.0.0/8, and ::1/128 for development purposes. The primary reason for this restriction is to protect users from the risks associated with insecure contexts.
</p>

		</section>
		<section id="content-security-policy">
<h3 title="Content Security Policy">6.2. ~CSP</h3>

<p>
~UAは、`~swを走らす$とき，当の~swに送達されてきた`~script資源$swに次に挙げる~HTTP ~headerが伴われている場合は：
◎
Whenever a user agent invokes the Run Service Worker algorithm with a service worker serviceWorker:
</p>

<ul>
	<li>
`Content-Security-Policy$h
⇒
その値が与える施策 を`施行-$するモノトスル。
◎
If serviceWorker’s script resource was delivered with a Content-Security-Policy HTTP header containing the value policy, the user agent must enforce policy for serviceWorker.
</li>
	<li>
`Content-Security-Policy-Report-Only$h
⇒
その値が与える施策を`監視-$するモノトスル。
◎
If serviceWorker’s script resource was delivered with a Content-Security-Policy-Report-Only HTTP header containing the value policy, the user agent must monitor policy for serviceWorker.
</li>
</ul>

<p>
この制約の首な理由は、~XSSなどの［
内容~注入に対する脆弱性が成す~~広範な~class
］を軽減するためである。
◎
The primary reason for this restriction is to mitigate a broad class of content injection vulnerabilities, such as cross-site scripting (XSS).
</p>

		</section>
		<section id="origin-relativity">
<h3 title="Origin Relativity">6.3. 生成元との相対性</h3>

			<section id="origin-restriction">
<h4 title="Origin restriction">6.3.1. 生成元の制約</h4>

~INFORMATIVE

<p>
`~sw$は、それを登録している`~sw~client$の`生成元$cl【！`生成元$enV】内で実行される。
その応用の大多数が遭遇することになる高度な懸念として、それが~CDNから~hostし得るかどうかがある。
定義により，~CDNは、他所にある~serverであり，他の`生成元$に属することが多い。
したがって、`~sw$を~CDN上で~hostすることはできない。
が、 `importScripts()$c を介して資源を含ませることはできる。
この制約の理由は、`~sw$が，不良な動作者にも ~~攻撃を永遠に引き伸ばす機会を与えるからである。
◎
A service worker executes in the registering service worker client's origin. One of the advanced concerns that major applications would encounter is whether they can be hosted from a CDN. By definition, these are servers in other places, often on other origins. Therefore, service workers cannot be hosted on CDNs. But they can include resources via importScripts(). The reason for this restriction is that service workers create the opportunity for a bad actor to turn a bad day into a bad eternity.
</p>

			</section>
			<section id="importscripts">
<h4 id="importscripts-method">6.3.2. `importScripts(urls)^n</h4>

<p>
`ServiceWorkerGlobalScope$I ~obj上の `importScripts()$n ~methodの被呼出時には、~UAは，次を走らすモノトスル
⇒
`~worker大域~scopeの中に~scriptを~importする$( 此れ, %url )
— 加えて…
◎
When the importScripts(urls) method is called on a ServiceWorkerGlobalScope object, the user agent must import scripts into worker global scope, given this ServiceWorkerGlobalScope object and urls, and with the following＼
</p>

<div class="algorithm">
<p>
…加えて，`~fetchを遂行する$ときは、所与の
( `要請$ %要請 )
に対し，次を走らす：
◎
steps to perform the fetch given the request request:
</p>
<ol>
	<li>
%~sw ~LET %要請 の`~client$rqの`大域~obj$enVの`~sw$SWG
◎
Let serviceWorker be request’s client's global object's service worker.
</li>
	<li>
%~map ~LET %~sw の`~script資源~map$sw
◎
Let map be serviceWorker’s script resource map.
</li>
	<li>
%~url ~LET %要請 の`~URL$rq
◎
Let url be request’s url.
</li>
	<li>
%応答 ~LET %~map[ %~url ]
◎
↓</li>
	<li>
~IF［
%~sw の`状態$sw ~NIN { `parsed^l, `installing^l }
］
⇒
~RET ［
%応答 ~NEQ ε ならば %応答 ／
~ELSE_ `~network~error$
］
◎
If serviceWorker’s state is not "parsed" or "installing":
• Return map[url] if it exists and a network error otherwise.
</li>
	<li>
<p>
~IF［
%応答 ~NEQ ε
］：
◎
If map[url] exists:
</p>
		<ol>
			<li>
%~sw の`利用した~scriptの集合$swに %~url を`付加する$set
◎
Append url to serviceWorker’s set of used scripts.
</li>
			<li>
~RET %応答
◎
Return map[url].
</li>
		</ol>
	</li>
	<li>
%登録 ~LET %~sw を`包含している~sw登録$sw
◎
Let registration be serviceWorker’s containing service worker registration.
</li>
	<li>
%要請 の`~sw~mode$rq ~SET `none^l
◎
Set request’s service-workers mode to "none".
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Set request’s cache mode to "no-cache" if any of the following are true:
</p>
		<ul>
			<li>
%登録 の`~cacheを介する更新~mode$swr ~EQ `none^l
◎
registration’s update via cache mode is "none".
</li>
			<li>
`現在の大域~obj$の`~importする~script用には~cacheを迂回するよう強制する~flag$SWG ~EQ ~T
◎
The current global object's force bypass cache for import scripts flag is set.
</li>
			<li>
%登録 は`非新鮮$である
◎
registration is stale.
</li>
		</ul>

<p>
…ならば
⇒
%要請 の`~cache~mode$rq ~SET `no-cache^l
</p>

	</li>
	<li>
%応答 ~SET %要請 を`~fetch$した結果
【 %要請 の`同期~flag$rqは ~T にされるので、この~fetchは同期的に応答を返すことになる。】
◎
Let response be the result of fetching request.
</li>
	<li>
~IF［
%応答 の`~cache状態$ ~NEQ `local^l 
］
⇒
%登録 の`最後の更新~検査-時刻$swr ~SET 現在の時刻
◎
If response’s cache state is not "local", set registration’s last update check time to the current time.
</li>
	<li>
~IF［
%応答 の`非安全~応答$は`不良な~import~script応答$である
］
⇒
~RET `~network~error$
◎
If response’s unsafe response is a bad import script response, then return a network error.
</li>
	<li>
%~map[ %~url ] ~SET %応答
◎
Set map[url] to response.
</li>
	<li>
%~sw の`利用した~scriptの集合$swに %~url を`付加する$set
◎
Append url to serviceWorker’s set of used scripts.
</li>
	<li>
%~sw の`古典~script~import済み~flag$sw ~SET ~T
◎
Set serviceWorker’s classic scripts imported flag.
</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="cross-origin-resources">
<h3 title="Cross-Origin Resources and CORS">6.4. 非同一-生成元に属する資源と~CORS</h3>

~INFORMATIVE

<p>
~appは、~CDNや他の`生成元$enVから来た~itemを~cacheする傾向にある。
それらの多くは、［
`script^e ／ `img^e ／ `video^e ／ `link^e
］要素を利用して，直に要請する可能性もある。
この類の実行時~協同は、~offline時に壊れた場合，著しく制限されることになる。
同様に，適切な~CORS~headerが設定されているときは、`生成元$enV外にある【すなわち同一-生成元でない】多様な資源を`~fetch$する可能性もある。
`~sw$は、［
`Cache$I が，生成元~外にある~itemを`~fetch$して~cacheできる
］ようにすることで，これを可能化する。
しかしながら，いくつかの制約も適用される：
◎
Applications tend to cache items that come from a CDN or other origin. It is possible to request many of them directly using &lt;script&gt;, &lt;img&gt;, &lt;video&gt; and &lt;link&gt; elements. It would be hugely limiting if this sort of runtime collaboration broke when offline. Similarly, it is possible to fetch many sorts of off-origin resources when appropriate CORS headers are set. Service workers enable this by allowing Caches to fetch and cache off-origin items. Some restrictions apply, however.＼
</p>

<ul>
	<li>
先ず，［
所与の資源~用に `Cache$I 内で管理され, 格納される `Response$I ~obj
］に対応する`応答$Rsは、同一-生成元に属する資源に対しては`基本~絞込み応答$になる一方で，生成元~外にある資源に対しては［
`~CORS絞込み応答$ ／ `不透明な絞込み応答$
］になる。
◎
First, unlike same-origin resources which are managed in the Cache as Response objects whose corresponding responses are basic filtered response, the objects stored are Response objects whose corresponding responses are either CORS filtered responses or opaque filtered responses.＼
</li>
	<li>
次に，生成元~外にある資源~用の `Response$I ~objは、同一-生成元に属する資源~用のそれと同じ方式で
%event . `respondWith()$n
~methodに渡せるが，そのような~objを~program的に作成することはできない。
◎
They can be passed to event.respondWith(r) method in the same manner as the Response objects whose corresponding responses are basic filtered responses, but cannot be meaningfully created programmatically.＼
</li>
</ul>

<p>
これらの制限は、~platformの~security不変則を保全するために必要とされる。
`Cache$I にそれらを格納できるようにすることにより、ほとんどの事例では，~appを改築し直さずに済むようになる。
◎
These limitations are necessary to preserve the security invariants of the platform. Allowing Caches to store them allows applications to avoid re-architecting in most cases.
</p>

		</section>
		<section id="path-restriction">
<h3 title="Path restriction">6.5. ~path制約</h3>

~INFORMATIVE

<p>
<a href="#origin-restriction">生成元~制約</a>
に加えて、~swは，~sw~scriptの`~path$urlにより制約される。
例えば，
`https://~example-bob/sw.js^c
にある~sw~scriptは、`~scope~url$swr
`https://~example-bob/^c
用には登録できるが，~scope［
`https://www.example.com/^c ／
`https://~example-alice/^c
］用には登録できない。
これは、同じ生成元に属するが互いに別々の~directory内に複数~利用者の内容を~hostする~site用に，いくぶんの保護を供する。
しかしながら，この~path制約は、硬い~security境界とは見なされない
— それを成すのは生成元に限られる。
~siteは、適切になるならば，［
~siteを成す各区分に、異なる生成元を利用して，~secureに隔離する
］ことが奨励される。
◎
In addition to the origin restriction, service workers are restricted by the path of the service worker script. For example, a service worker script at https://www.example.com/~bob/sw.js can be registered for the scope url https://www.example.com/~bob/ but not for the scope https://www.example.com/ or https://www.example.com/~alice/. This provides some protection for sites that host multiple-user content in separated directories on the same origin. However, the path restriction is not considered a hard security boundary, as only origins are. Sites are encouraged to use different origins to securely isolate segments of the site if appropriate.
</p>

<p>
~serverは、~sw~scriptに対し `Service-Worker-Allowed$h ~headerを設定することにより，この~path制約を除去できる。
◎
Servers can remove the path restriction by setting a Service-Worker-Allowed header on the service worker script.
</p>

		</section>
		<section id="script-request">
<h3 title="Service worker script request">6.6. ~sw~script要請</h3>

~INFORMATIVE

<p>
~site上の~swの悪意的な登録に抗して，更に防御するため、この仕様は次を要求する：
◎
To further defend against malicious registration of a service worker on a site, this specification requires that:
</p>

<ul>
	<li>
~sw~script要請には、 `Service-Worker$h ~headerを伴わせること。
◎
The Service-Worker header is present on service worker script requests, and
</li>
	<li>
~sw~scriptを~serveするときは、`~JS~MIME型$を伴わせること。
◎
Service worker scripts are served with a JavaScript MIME type.
</li>
</ul>

		</section>
		<section id="implementer-concerns">
<h3 title="Implementer Concerns">6.7. 実装者~向けの懸念点</h3>

~INFORMATIVE

<p>
実装者は、次に留意しておくことが奨励される：
◎
The implementers are encouraged to note:
</p>

<ul>
	<li>
`~sw$を介して~pluginを読込むベキでない。
~pluginは，自前の~urlから~security生成元を取得することもあり、埋込んでいる`~sw$はそれを取扱えないので。
この理由から、`~fetchを取扱う$~algoは、 `fetch$et ~eventを配送することなく `~naviまたは下位資源いずれかになり得る要請$を発行して（その文脈は `embed^e, `object^e のいずれかになる），即時に~networkへ~fallbackする。
◎
Plug-ins should not load via service workers. As plug-ins may get their security origins from their own urls, the embedding service worker cannot handle it. For this reason, the Handle Fetch algorithm makes the potential-navigation-or-subresource request (whose context is either &lt;embed&gt; or &lt;object&gt;) immediately fallback to the network without dispatching fetch event.
</li>
	<li>
旧来の~network用~stack~codeの一部は、`~sw$との相互作用における細分化を解するため，注意深く聴取する必要があるかもしれない。
◎
Some of the legacy networking stack code may need to be carefully audited to understand the ramifications of interactions with service workers.
</li>
</ul>

		</section>
		<section id="privacy">
<h3 title="Privacy">6.8. ~privacy</h3>

<p>
`~sw$は、次を含む新たな持続的~storage特能を導入する
⇒＃
（`~sw登録$とその`~sw$用の）`~scopeから登録への~map$,
（~cache用の）`要請~応答~list$と`名前から~cacheへの~map$,
（~script資源~用の）`~script資源~map$sw
◎
Service workers introduce new persistent storage features including scope to registration map (for service worker registrations and their service workers), request response list and name to cache map (for caches), and script resource map (for script resources).＼
</p>

<p>
<a href="#biblio-unsanctioned-tracking">追跡し放題になり得る脅威</a>
から利用者を保護するため、これらの持続的~storageは，利用者が消去するよう意図したときは消去されるベキであり、また，既存の利用者~制御
— 既存の持続的~storageをすべて一掃するなど —
と相互運用できるよう保守されるベキである。
◎
In order to protect users from any potential unsanctioned tracking threat, these persistent storages should be cleared when users intend to clear them and should maintain and interoperate with existing user controls e.g. purging all existing persistent storages.
</p>

		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">7. 拡張能</h2>

<p>
他の仕様は、~sw仕様を拡張できる。
◎
Service Workers specification is extensible from other specifications.
</p>

		<section id="extension-to-service-worker-registration">
<h3 title="Define API bound to Service Worker Registration">7.1. ~sw登録に束縛される~APIを定義する</h3>

<p>
仕様は、 `ServiceWorkerRegistration$I ~interfaceの`部分的~interface$定義を利用して，そこに仕様に特有な属性や~methodを定義して，`~sw登録$に束ねられる~APIを定義してもヨイ：
◎
Specifications may define an API tied to a service worker registration by using partial interface definition to the ServiceWorkerRegistration interface where it may define the specification specific attributes and methods:
</p>

<pre class="example idl">
partial interface ServiceWorkerRegistration {
  /* <span class="comment">
~API名前空間を定義する例：
◎
e.g. define an API namespace
</span> */
  readonly attribute APISpaceType APISpace;
  /* <span class="comment">
~methodを定義する例：
◎
e.g. define a method
</span> */
  Promise&lt;T&gt; methodName(/* <span class="comment">引数~list</span> */);
};
</pre>

		</section>
		<section id="extension-to-extendable-event">
<h3 title="Define Functional Event">7.2. 機能的~eventを定義する</h3>

<p>
各~仕様は、`ExtendableEvent$I ~interfaceを拡張することにより，`機能的~event$を定義してもヨイ。
◎
Specifications may define a functional event by extending ExtendableEvent interface:
</p>

<pre class="example idl">
/* <span class="comment">
`FunctionalEvent^I ~interfaceを定義する例：
◎
e.g. define FunctionalEvent interface
</span> */
interface FunctionalEvent : ExtendableEvent {
  /* <span class="comment">
機能的~eventの自前の属性や~methodを追加する
◎
add a functional event’s own attributes and methods
</span> */
};
</pre>

		</section>
		<section id="extension-to-service-worker-global-scope">
<h3 title="Define Event Handler">7.3. ~event~handlerを定義する</h3>

<p>
各~仕様は、 `ServiceWorkerGlobalScope$I ~interface用の`部分的~interface$定義を利用して，対応している`機能的~event$用に~event~handler属性を定義してもヨイ：
◎
Specifications may define an event handler attribute for the corresponding functional event using partial interface definition to the ServiceWorkerGlobalScope interface:
</p>

<pre class="example idl">
partial interface ServiceWorkerGlobalScope {
  attribute EventHandler onfunctionalevent;
};
</pre>

		</section>
		<section id="firing-functional-events">
<h3 title="Firing Functional Events">7.4. 機能的~eventの発火-法</h3>

<p>
各~仕様は、`~sw登録$にて`作動中の~worker$swrに向けて `機能的~event$を配送するよう要請するときは，`機能的~eventを発火する$べきである。
◎
To request a functional event dispatch to the active worker of a service worker registration, specifications should invoke Fire Functional Event.
</p>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Appendix A: Algorithms">各種~algo</h2>

<p>
以下の定義は、この仕様~全体を通して利用される，~UAの内部~data構造である。
◎
The following definitions are the user agent’s internal data structures used throughout the specification.
</p>

<p>
`~scopeから登録への~map@
は、`有順序~map$であり，それを成す各`~entry$mapは［
`~URLを直列化する$( `~scope~url$swr ) → `~sw登録$
］を与える。
◎
A scope to registration map is an ordered map where the keys are scope urls, serialized, and the values are service worker registrations.
</p>

<p>
`~job@
は、`~sw登録$を［
登録- ／ 更新- ／ 未登録に
］する要請の抽象-化である。
◎
A job is an abstraction of one of register, update, and unregister request for a service worker registration.
</p>

<p>
各`~job$には、以下のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~job種別@job</dt>
	<dd>
次のいずれか
⇒
`登録する^i ／
`更新する^i ／
`未登録にする^i
◎
A job has a job type, which is one of register, update, and unregister.
</dd>

	<dt>`~scope~url@job</dt>
	<dd>
`~URL$
◎
A job has a scope url (a URL).
</dd>

	<dt>`~script~url@job</dt>
	<dd>
`~URL$
◎
A job has a script url (a URL).
</dd>

	<dt>`~worker種別@job</dt>
	<dd>
次のいずれか
⇒
`classic^l ／ `module^l 
◎
A job has a worker type ("classic" or "module").
</dd>

	<dt>`~cacheを介する更新~mode@job</dt>
	<dd>
次のいずれか
⇒
`imports^l ／ `all^l ／ `none^l
◎
A job has an update via cache mode, which is "imports", "all", or "none".
</dd>

	<dt>`~client@job</dt>
	<dd>
`~sw~client$
◎
A job has a client (a service worker client).＼
</dd>
	<dd>
初期~時には ~NULL とする。
◎
It is initially null.
</dd>

	<dt>`~referrer@job</dt>
	<dd>
次のいずれか
⇒
`~URL$ ／ ~NULL
◎
A job has a referrer (a URL or null).
</dd>

	<dt>`~job~promise@job</dt>
	<dd>
`~promise$
◎
A job has a job promise (a promise).＼
</dd>
	<dd>
初期~時には ~NULL とする。
◎
It is initially null.
</dd>

	<dt>`包含している~job~queue@job</dt>
	<dd>
次のいずれか
⇒
`~job~queue$ ／ ~NULL
◎
A job has a containing job queue (a job queue or null).＼
</dd>
	<dd>
初期~時には ~NULL とする。
◎
It is initially null.
</dd>

	<dt>`等価~job~list@job</dt>
	<dd>
0 個以上の`~job$からなる~list
◎
A job has a list of equivalent jobs (a list of jobs).＼
</dd>
	<dd>
初期~時には空~list とする。
◎
It is initially the empty list.
</dd>

	<dt>`~cacheを迂回するよう強制する~flag@job</dt>
	<dd>
真偽値をとり，初期~時には ~F とする。
◎
A job has a force bypass cache flag. It is initially unset.
</dd>
</dl>

<p>
2 つの `~job$は、互いの`~job種別$jobが同じであって, かつ
`~job種別$jobに応じて次が満たされるならば
`等価である@job
とされる：
◎
Two jobs are equivalent when their job type is the same and:
</p>

<div>
<dl class="switch">
	<dt>`登録する^i</dt>
	<dt>`更新する^i</dt>
	<dd>
互いの［
`~scope~url$job,
`~script~url$job,
`~worker種別$job,
`~cacheを介する更新~mode$job
］は，いずれも同じ。
</dd>

	<dt>`未登録にする^i</dt>
	<dd>
互いの`~scope~url$jobは同じ。
</dd>
</dl>
◎
For register and update jobs, their scope url, script url, worker type, and update via cache mode are the same.
◎
For unregister jobs, their scope url is the same.
</div>

<p>
`~job~queue@
は，~thread安全な`~queue$であり、いくつかの同時的な`~job$を互いに同期するために利用される。
`~job~queue$は，初期~時は空であり、それを成す各`~item$は，ある`~job$を与える。
◎
A job queue is a thread safe queue used to synchronize the set of concurrent jobs. The job queue contains jobs as its items. A job queue is initially empty.
</p>

<p>
`~scopeから~job~queueへの~map@
は、`有順序~map$であり，それを成す各`~entry$mapは［
`~URLを直列化する$( `~scope~url$swr ) → `~job~queue$
］を与える。
◎
A scope to job queue map is an ordered map where the keys are scope urls, serialized, and the values are job queues.
</p>

<p>
`不良な~import~script応答@
とは、次に挙げるいずれかの条件を満たす`応答$である：
◎
A bad import script response is a response for which any of the following conditions are met:
</p>

<ul>
	<li>
応答の`種別$rs ~EQ `error^l
◎
response’s type is "error"
</li>
	<li>
応答の`状態s$rsは`~ok状態s$でない
◎
response’s status is not an ok status
</li>
	<li>
<p>
次の結果は`~JS~MIME型$でない
⇒
`~header~listから~MIME型を抽出する$( 応答の`~header~list$rs )
◎
The result of extracting a MIME type from response’s header list is not a JavaScript MIME type
</p>

<p class="note">注記：
この定義と［
`~workerが~importした古典~scriptを~fetchする$
］とが同期cするよう保つ。
◎
Note: Keep this definition in sync with fetch a classic worker-imported script.
</p>
	</li>
</ul>

		<section id="create-job-algorithm">
<h3 title="Create Job">`~jobを作成する@</h3>

<ul>
	<li>
入力
⇒＃
%~job種別 — `~job種別$job,
%~scope~URL — `~URL$,
%~script~URL — `~URL$,
%~promise — `~promise$,
%~client — `~sw~client$
◎
Input
• jobType, a job type
• scopeURL, a URL
• scriptURL, a URL
• promise, a promise
• client, a service worker client
</li>
	<li>
出力
⇒＃
%~job — `~job$
◎
Output
• job, a job
</li>
</ul>

<ol>
	<li>
%~job ~LET 新たな`~job$
◎
Let job be a new job.
</li>
	<li>
%~job の
⇒＃
`~job種別$job ~SET %~job種別,
`~scope~url$job ~SET %~scope~URL,
`~script~url$job ~SET %~script~URL,
`~job~promise$job ~SET %~promise,
`~client$job ~SET %~client
◎
Set job’s job type to jobType.
◎
Set job’s scope url to scopeURL.
◎
Set job’s script url to scriptURL.
◎
Set job’s job promise to promise.
◎
Set job’s client to client.
</li>
	<li>
~IF［
%~client ~NEQ ~NULL
］
⇒
%~job の`~referrer$job ~SET %~client の`作成時の~URL$enV
◎
If client is not null, set job’s referrer to client’s creation URL.
</li>
	<li>
~RET %~job
◎
Return job.
</li>
</ol>

		</section>
		<section id="schedule-job-algorithm">
<h3 title="Schedule Job">`~jobを~scheduleする@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$
◎
Input
• job, a job
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
%~job~queue ~LET ~NULL
◎
Let jobQueue be null.
</li>
	<li>
%~job~scope ~LET `~URLを直列化する$( %~job の`~scope~url$job )
◎
Let jobScope be job’s scope url, serialized.
</li>
	<li>
~IF［
`~scopeから~job~queueへの~map$[ %~job~scope ] ~EQ ε
］
⇒
`~scopeから~job~queueへの~map$[ %~job~scope ] ~SET 新たな`~job~queue$
◎
If scope to job queue map[jobScope] does not exist, set scope to job queue map[jobScope] to a new job queue.
</li>
	<li>
%~job~queue ~SET `~scopeから~job~queueへの~map$[ %~job~scope ]
◎
Set jobQueue to scope to job queue map[jobScope].
</li>
	<li>
<p>
~IF［
%~job~queue は`空$である
］：
◎
If jobQueue is empty, then:
</p>
		<ol>
			<li>
%~job を`包含している~job~queue$job ~SET %~job~queue
◎
Set job’s containing job queue to jobQueue, and＼
</li>
			<li>
%~job~queue に %~job を`~enqueue$する
◎
enqueue job to jobQueue.
</li>
			<li>
`~jobを走らす$( %~job~queue )
◎
Invoke Run Job with jobQueue.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Else:
</p>
		<ol>
			<li>
%最後の~job ~LET %~job~queue の最後の`~item$
【！＊the element at the back of】
◎
Let lastJob be the element at the back of jobQueue.
</li>
			<li>
~IF［
`等価である$job( %~job, %最後の~job )
］~AND［
%最後の~job の`~job~promise$jobはまだ決着してない
］
⇒
%最後の~job の`等価~job~list$jobに %~job を付加する
◎
If job is equivalent to lastJob and lastJob’s job promise has not settled, append job to lastJob’s list of equivalent jobs.
</li>
			<li>
~ELSE
⇒＃
%~job を`包含している~job~queue$job ~SET %~job~queue；
%~job~queue に %~job を`~enqueue$する
◎
Else, set job’s containing job queue to jobQueue, and enqueue job to jobQueue.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="run-job-algorithm">
<h3 title="Run Job">`~jobを走らす@</h3>

<ul>
	<li>
入力
⇒＃
%~job~queue — `~job~queue$
◎
Input
• jobQueue, a job queue
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
~Assert：
%~job~queue は`空$でない
◎
Assert: jobQueue is not empty.
</li>
	<li>
<p>
次を走らす`~taskを~queueする$【どの~task源？】：
◎
Queue a task to run these steps:
</p>
		<ol>
			<li>
%~job ~LET %~job~queue の最初の`~item$
◎
Let job be the first item in jobQueue.
</li>
			<li>
%~job種別 ~LET %~job の`~job種別$job
◎
↓</li>
			<li>
<p>
この段は`並列的$に走らす
⇒
%~job種別 に応じて：
</p>
					<ul class="switch">
						<li>
`登録する^i
⇒
`登録する$( %~job )
</li>

						<li>
`更新する^i
⇒
`更新する$( %~job )
</li>

						<li>
`未登録にする^i
⇒
`未登録にする$( %~job )
</li>
					</ul>

<p class="note">注記：
%~job の［
登録-／更新-
］に対しては、~UAは，［
%~job を走らす~task
］を~queueするのを［［
%~job を起動した文書
］に向けて， `DOMContentLoaded$I ~eventを配送した後
］まで遅延する。
</p>

◎
If job’s job type is register, run Register with job in parallel.
◎
Else if job’s job type is update, run Update with job in parallel.
◎
Note: For a register job and an update job, the user agent delays queuing a task for running the job until after a DOMContentLoaded event has been dispatched to the document that initiated the job.
◎
Else if job’s job type is unregister, run Unregister with job in parallel.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="finish-job-algorithm">
<h3 title="Finish Job">`~jobを完遂する@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$
◎
Input
• job, a job
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
%~job~queue ~LET %~job を`包含している~job~queue$job
◎
Let jobQueue be job’s containing job queue.
</li>
	<li>
~Assert：
%~job~queue の最初の`~item$ ~EQ %~job
◎
Assert: the first item in jobQueue is job.
</li>
	<li>
%~job~queue から`~dequeue$する
◎
Dequeue from jobQueue.
</li>
	<li>
~IF［
%~job~queue は`空$でない
］
⇒
`~jobを走らす$( %~job~queue )
◎
If jobQueue is not empty, invoke Run Job with jobQueue.
</li>
</ol>

		</section>
		<section id="resolve-job-promise-algorithm">
<h3 title="Resolve Job Promise">`~job~promiseを解決する@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$,
%値 — 任意の値
◎
Input
• job, a job
• value, any
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
~job~promiseを内部的に解決する( %~job )
（下を見よ）
◎
If job’s client is not null, queue a task, on job’s client's responsible event loop using the DOM manipulation task source, to run the following substeps:
• Let convertedValue be null.
• If job’s job type is either register or update, set convertedValue to the result of getting the service worker registration object that represents value in job’s client.
• Else, set convertedValue to value, in job’s client's Realm.
• Resolve job’s job promise with convertedValue.
</li>
	<li>
%~job の`等価~job~list$jobを成す
~EACH( %等価な~job )
に対し
⇒
~job~promiseを内部的に解決する( %等価な~job )
◎
For each equivalentJob in job’s list of equivalent jobs:
• If equivalentJob’s client is null, continue to the next iteration of the loop.
• Queue a task, on equivalentJob’s client's responsible event loop using the DOM manipulation task source, to run the following substeps:
•• Let convertedValue be null.
•• If equivalentJob’s job type is either register or update, set convertedValue to the result of getting the service worker registration object that represents value in equivalentJob’s client.
•• Else, set convertedValue to value, in equivalentJob’s client's Realm.
•• Resolve equivalentJob’s job promise with convertedValue.
</li>
</ol>

<div >
<p>
上で ~job~promiseを内部的に解決する所では、所与の
( %入力~job )
に対し，次の下位手続きを走らす：
</p>

<ol>
	<li>
%~client ~LET %入力~job の`~client$job
</li>
	<li>
~IF［
%~client ~EQ ~NULL
］
⇒
~RET
</li>
	<li>
%O ~LET ε
</li>
	<li>
<p>
~IF［
%入力~job の`~job種別$job ~IN { `登録する^i, `更新する^i }
］：
</p>
		<ol>
			<li>
~Assert：
%値 は`~sw登録$である
</li>
			<li>
%O ~SET `~sw登録~objを取得する$( %値, %~client )
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%O ~SET %~client の`~Realm$enV 内で %値 を表現する値
</li>
	<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~client の`担当の~event-loop$enV )
⇒
%O で %入力~job の`~job~promise$jobを解決する
</li>
</ol>
◎
↑</div>

		</section>
		<section id="reject-job-promise-algorithm">
<h3 title="Reject Job Promise">`~job~promiseを却下する@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$,
%~error~data — `新たな例外$を作成するために必要とされる情報
◎
Input
• job, a job
• errorData, the information necessary to create an exception
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
~job~promiseを内部的に却下する( %~job )
（下を見よ）
◎
If job’s client is not null, queue a task, on job’s client's responsible event loop using the DOM manipulation task source, to reject job’s job promise with a new exception with errorData and a user agent-defined message, in job’s client's Realm.
</li>
	<li>
%~job の`等価~job~list$jobを成す
~EACH( %等価な~job )
に対し
⇒
~job~promiseを内部的に却下する( %等価な~job )
◎
For each equivalentJob in job’s list of equivalent jobs:
• If equivalentJob’s client is null, continue.
• Queue a task, on equivalentJob’s client's responsible event loop using the DOM manipulation task source, to reject equivalentJob’s job promise with a new exception with errorData and a user agent-defined message, in equivalentJob’s client's Realm.
</li>
</ol>

<div>
<p>
上で ~job~promiseを内部的に却下する所では、所与の
( %入力~job )
に対し，次の下位手続きを走らす：
</p>

<ol>
	<li>
%~client ~LET %入力~job の`~client$job
</li>
	<li>
~IF［
%~client ~EQ ~NULL
］
⇒
~RET
</li>
	<li>
%例外 ~LET %~client の`~Realm$enV内に作成される`新たな例外$( %~error~data, ~UAにより定義される`~message$ )
</li>
	<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~client の`担当の~event-loop$enV )
⇒
%例外 で %入力~job の`~job~promise$jobを却下する
</li>
	</ol>
◎
↑</div>

		</section>
		<section id="start-register-algorithm">
<h3 title="Start Register">`登録を開始する@</h3>

<ul>
	<li>
入力
⇒＃
%~scope~URL — `~URL$ ／ `失敗^i ／ ~NULL,
%~script~URL — `~URL$ ／ `失敗^i,
%~promise — `~promise$,
%~client — `~sw~client$,
%~referrer — `~URL$,
%~worker種別 — `~worker種別$job,
%~cacheを介する更新 — `~cacheを介する更新~mode$swr
◎
Input
• scopeURL, a URL or failure or null
• scriptURL, a URL or failure
• promise, a promise
• client, a service worker client
• referrer, a URL
• workerType, a worker type
• updateViaCache, an update via cache mode
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
~IF［
%~script~URL ~EQ `失敗^i
］
⇒＃
`TypeError^E で %~promise を`却下する$；
~RET
◎
If scriptURL is failure, reject promise with a TypeError and abort these steps.
</li>
	<li>
<p>
%~script~URL の`素片$url ~SET ~NULL
◎
Set scriptURL’s fragment to null.
</p>

<p class="note">注記：
~UAは~scriptの~urlの`素片$urlは格納しない。
これは、`素片$urlにより`~sw$を識別する効果は無いことを意味する。
◎
Note: The user agent does not store the fragment of the script’s url. This means that the fragment does not have an effect on identifying service workers.
</p>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

<ul><li>%~script~URL の`~scheme$url ~NIN { `http^l , `https^l }
</li><li>%~script~URL の`~path$url内のある文字列は、`~ASCII大小無視$で［
`%2f^l か `%5c^l
］を包含する
</li></ul>

<p>
ならば…
⇒＃
`TypeError^E で %~promise を`却下する$；
~RET
</p>

◎
If scriptURL’s scheme is not one of "http" and "https", reject promise with a TypeError and abort these steps.
◎
If any of the strings in scriptURL’s path contains either ASCII case-insensitive "%2f" or ASCII case-insensitive "%5c", reject promise with a TypeError and abort these steps.
</li>
	<li>
<p>
~IF［
%~scope~URL ~EQ ~NULL
］
⇒
%~scope~URL ~SET `~URL構文解析する$( 文字列 `./^l , %~script~URL )
◎
If scopeURL is null, set scopeURL to the result of parsing the string "./" with scriptURL.
</p>

<p class="note">注記：
すなわち，既定では、登録~用の~scope~urlは ~sw~scriptの所在に設定される。
◎
Note: The scope url for the registration is set to the location of the service worker script by default.
</p>
	</li>
	<li>
~IF［
%~scope~URL ~EQ `失敗^i
］
⇒＃
`TypeError^E で %~promise を`却下する$；
~RET
◎
If scopeURL is failure, reject promise with a TypeError and abort these steps.
</li>
	<li>
<p>
%~scope~URL の`素片$url ~SET ~NULL
◎
Set scopeURL’s fragment to null.
</p>

<p class="note">注記：
~UAは %~scope~url の`素片$urlは格納しない。
これは、`素片$urlにより`~sw登録$を識別する効果は無いことを意味する。
◎
Note: The user agent does not store the fragment of the scope url. This means that the fragment does not have an effect on identifying service worker registrations.
</p>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

<ul><li>%~scope~URL の`~scheme$url ~NIN { `http^l , `https^l }
</li><li>%~scope~URL の`~path$url内のある文字列は、`~ASCII大小無視$で［
`%2f^l か `%5c^l 
］を包含する
</li></ul>

<p>
ならば…
⇒＃
`TypeError^E で %~promise を`却下する$；
~RET
</p>

◎
If scopeURL’s scheme is not one of "http" and "https", reject promise with a TypeError and abort these steps.
◎
If any of the strings in scopeURL’s path contains either ASCII case-insensitive "%2f" or ASCII case-insensitive "%5c", reject promise with a TypeError and abort these steps.
</li>
	<li>
%~job ~LET `~jobを作成する$( 次に挙げる引数 )
⇒＃
`登録する^i,
%~scope~URL,
%~script~URL,
%~promise,
%~client
◎
Let job be the result of running Create Job with register, scopeURL, scriptURL, promise, and client.
</li>
	<li>
%~job の
⇒＃
`~worker種別$job ~SET %~worker種別,
`~cacheを介する更新~mode$job ~SET %~cacheを介する更新,
`~referrer$job ~SET %~referrer
◎
Set job’s worker type to workerType.
◎
Set job’s update via cache mode to updateViaCache.
◎
Set job’s referrer to referrer.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
</ol>

		</section>
		<section id="register-algorithm">
<h3 title="Register">`登録する@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$
◎
Input
• job, a job
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
`信用に価し得る生成元か？$( %~job の`~script~url$jobの生成元 ) ~EQ `価しない^i
</li>
			<li>
%~job の`~script~url$jobの生成元
~NEQ`生成元$sub
%~job の`~referrer$jobの生成元
【！is not】
</li>
			<li>
%~job の`~scope~url$jobの生成元
~NEQ`生成元$sub
%~job の`~referrer$jobの生成元
【！is not】
</li>
		</ul>

<p class="trans-note">【
原文のこの段にて現れる生成元は，どれも`環境~設定群~obj$の`生成元$enVを指しているが、~URLの`生成元$urlの誤りであろう。
】</p>

<p>
ならば…：
</p>

<ol><li>`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
</li><li>`~jobを完遂する$( %~job )
</li><li>~RET
</li></ol>

◎
If the result of running potentially trustworthy origin with the origin of job’s script url as the argument is Not Trusted, then:
• Invoke Reject Job Promise with job and "SecurityError" DOMException.
• Invoke Finish Job with job and abort these steps.
◎
If the origin of job’s script url is not job’s referrer's origin, then:
• Invoke Reject Job Promise with job and "SecurityError" DOMException.
• Invoke Finish Job with job and abort these steps.
◎
If the origin of job’s scope url is not job’s referrer's origin, then:
• Invoke Reject Job Promise with job and "SecurityError" DOMException.
• Invoke Finish Job with job and abort these steps.
</li>
	<li>
%登録 ~LET 
`登録を取得する$( %~job の`~scope~url$job )
◎
Let registration be the result of running the Get Registration algorithm passing job’s scope url as the argument.
</li>
	<li>
<p>
~IF［
%登録 ~NEQ ~NULL
］：
◎
If registration is not null, then:
</p>
		<ol>
			<li>
%最新~worker ~LET 
`最新の~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running the Get Newest Worker algorithm passing registration as the argument.
</li>
			<li>
<p>
~IF［
%最新~worker ~NEQ ~NULL
］~AND［
( %~job の`~script~url$job, %最新~worker の`~script~url$sw )
は`同等な~URL$である
］~AND［
%~job の`~worker種別$job ~EQ %最新~worker の`種別$sw
］~AND［
%~job の`~cacheを介する更新~mode$job ~EQ %登録 の`~cacheを介する更新~mode$swr
］：
◎
If newestWorker is not null, job’s script url equals newestWorker’s script url, job’s worker type equals newestWorker’s type, and job’s update via cache mode's value equals registration’s update via cache mode, then:
</p>
				<ol>
					<li>
`~job~promiseを解決する$( %~job, %登録 )
◎
Invoke Resolve Job Promise with job and registration.
</li>
					<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
					<li>
~RET
◎
abort these steps.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
`登録を設定する$( %~job の`~scope~url$job, %~job の`~cacheを介する更新~mode$job )
◎
Else:
• Invoke Set Registration algorithm with job’s scope url and job’s update via cache mode.
</li>
	<li>
`更新する$( %~job )
◎
Invoke Update algorithm passing job as the argument.
</li>
</ol>

		</section>
		<section id="update-algorithm">
<h3 title="Update">`更新する@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$
◎
Input
• job, a job
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
%登録 ~LET 
`登録を取得する$(  %~job の`~scope~url$job )
◎
Let registration be the result of running the Get Registration algorithm passing job’s scope url as the argument.
</li>
	<li>
<p>
~IF［
%登録 ~EQ ~NULL
］：
◎
If registration is null, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%最新~worker ~LET 
`最新の~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
</li>
	<li>
<p>
~IF［
%~job の`~job種別$job ~EQ `更新する^i
］~AND［
%最新~worker ~NEQ ~NULL
］~AND［
( %最新~worker の`~script~url$sw, %~job の`~script~url$job )
は`同等な~URL$でない
］：
◎
If job’s job type is update, and newestWorker is not null and its script url does not equal job’s script url, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%~https状態 ~LET  `none^l
◎
Let httpsState be "none".
</li>
	<li>
%~referrer施策 ~LET 空~文字列
◎
Let referrerPolicy be the empty string.
</li>
	<li>
%~url ~LET `~URLを直列化する$( %~job の`~script~url$job )
◎
↓</li>
	<li>
%資源を更新した ~LET ~F
◎
Let hasUpdatedResources be false.
</li>
	<li>
%更新-済み資源~map ~LET 新たな`有順序~map$
（この~mapは、`~script資源~map$swを与えることになる）
◎
Let updatedResourceMap be an ordered map where the keys are URLs and the values are responses.
</li>
	<li>
<p>
%~job の`~worker種別$jobに応じて：
◎
Switching on job’s worker type, run these substeps with the following options:
</p>
		<dl class="switch">
			<dt>`classic^l</dt>
			<dd>
`~worker用~古典~scriptを~fetchする$( 次に挙げる引数 )
⇒＃
%~url,
%~job の`~client$job,
`serviceworker^l,
設定群†
◎
Fetch a classic worker script given job’s serialized script url, job’s client, "serviceworker", and the to-be-created environment settings object for this service worker.
</dd>

			<dt>`module^l</dt>
			<dd>
`~module~worker~script~graphを~fetchする$( 次に挙げる引数 )
⇒＃
%~url,
%~job の`~client$job,
`serviceworker^l ,
`omit^l,
設定群†
◎
Fetch a module worker script graph given job’s serialized script url, job’s client, "serviceworker", "omit", and the to-be-created environment settings object for this service worker.
</dd>
		</dl>

<p>†
上に与えた設定群は、この~sw用に【必要になった時点で】`作成されることになる^em`環境~設定群~obj$を与える。
【例えば~fetchに失敗した場合、作成されないであろう。】
◎
↑</p>

<p class="issue">
具体`環境~設定群~obj$ではなく，作成されることになる`環境~設定群~obj$を利用しているのは、~swの処理~modelが，他の`~web~worker$の処理~modelに比較して，独特であることに因る。
~HTML標準の~scriptを~fetchする~algoは、元々は他の`~web~worker$用に設計されており，実行~環境の`環境~設定群~obj$を要求するが、~swは，~scriptを
— 後で，`~swを走らす$~algoを通して複数回~走らす前に —
`更新する$~algo内で別々に~fetchするので。
◎
Using the to-be-created environment settings object rather than a concrete environment settings object. This is used due to the unique processing model of service workers compared to the processing model of other web workers. The script fetching algorithms of HTML standard originally designed for other web workers require an environment settings object of the execution environment, but service workers fetch a script separately in the Update algorithm before the script later runs multiple times through the Run Service Worker algorithm.
</p>

<p class="issue">
~HTMLにおける［
`~worker用~古典~scriptを~fetchする$／
`~module~worker~script~graphを~fetchする$
］~algoは、
%~job の`~client$jobを引数にとる。
%~job の`~client$jobは、`~soft更新する$~algoから渡されるときは ~NULL になる。
◎
The fetch a classic worker script algorithm and the fetch a module worker script graph algorithm in HTML take job’s client as an argument. job’s client is null when passed from the Soft Update algorithm.
</p>

<div class="algorithm">
<p>
上の~fetchにて`~fetchを遂行する$ときは、所与の
( %要請, %~top-level内~flag )
に対し，次を走らす：
◎
To perform the fetch given request, run the following steps:
</p>
		<ol>
			<li>
<p>
%要請 の`~header~list$rq に`~headerを付加する$(
`Service-Worker^h / `script^bl
)
◎
Append `Service-Worker`/`script` to request’s header list.
</p>

<p class="note">注記：
<a href="#extended-http-headers">拡張された~HTTP~header節</a>
における `Service-Worker^h ~headerの定義を見よ。
◎
Note: See the definition of the Service-Worker header in Appendix B: Extended HTTP headers.
</p>
			</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Set request’s cache mode to "no-cache" if any of the following are true:
</p>
				<ul>
					<li>
%登録 の`~cacheを介する更新~mode$swr ~NEQ `all^l
◎
registration’s update via cache mode is not "all".
</li>
					<li>
%~job の`~cacheを迂回するよう強制する~flag$job ~EQ ~T
◎
job’s force bypass cache flag is set.
</li>
					<li>
［
%最新~worker ~NEQ ~NULL
］~AND［
%登録 は`非新鮮$である
］
◎
newestWorker is not null and registration is stale.
</li>
			</ul>
<p>
…ならば
⇒
%要請 の`~cache~mode$rq ~SET `no-cache^l
</p>

<p class="note">注記：
［
~cache~mode ~NEQ `no-cache^l 
］の場合でも、~UAは，［
~browser~cacheを迂回するべきかどうか
］を決定するため［
~network層における `Cache-Control$h ~headerの `max-age^dir 値
］を順守する。
◎
Note: Even if the cache mode is not set to "no-cache", the user agent obeys Cache-Control header’s max-age value in the network layer to determine if it should bypass the browser cache.
</p>
			</li>
			<li>
%要請 の`~sw~mode$rq ~SET `none^l
◎
Set request’s service-workers mode to "none".
</li>
			<li>
~IF［
%~top-level内~flag ~EQ ε
］
⇒
~RET %要請 を`~fetch$した結果
【この場合は、同期的に完了する。】
◎
If the is top-level flag is unset, then return the result of fetching request.
</li>
			<li>
%要請 の`~redirect~mode$rq ~SET `error^l
◎
Set request’s redirect mode to "error".
</li>
			<li>
<div class="algorithm">
<p>
%要請 を`~fetch$する
— ~fetchし終えるまで非同期に待機した上で、`応答を処理する$一部として，所与の
( `応答$ %応答 )
に対し，次の手続き走らす：
◎
Fetch request, and asynchronously wait to run the remaining steps as part of fetch’s process response for the response response.
</p>
				<ol>
					<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Extract a MIME type from the response’s header list.＼
</li>
					<li>
<p>
~IF［
%~MIME型 は`~JS~MIME型$でない【！不要：(ignoring parameters)】
］：
◎
If this MIME type (ignoring parameters) is not a JavaScript MIME type, then:
</p>
						<ol>
							<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
◎
Invoke Reject Job Promise with job and "SecurityError" DOMException.
</li>
							<li>
`~network~error$を結果として，`非同期に完了-$する
◎
Asynchronously complete these steps with a network error.
</li>
						</ol>
					</li>
					<li>
<p>
%許容される~sw ~LET 
`~header~listから値を抽出する$( %応答 の`~header~list$rs, `Service-Worker-Allowed^h )
◎
Let serviceWorkerAllowed be the result of extracting header list values given `Service-Worker-Allowed` and response’s header list.
</p>

<p class="note">注記：
<a href="#extended-http-headers">拡張された~HTTP~header節</a>
における `Service-Worker-Allowed$h ~headerの定義を見よ。
◎
Note: See the definition of the Service-Worker-Allowed header in Appendix B: Extended HTTP headers.
</p>
					</li>
					<li>
%~https状態 ~SET %応答 の`~HTTPS状態$rs
◎
Set httpsState to response’s HTTPS state.
</li>
					<li>
%~referrer施策 ~SET
`~referrer施策を構文解析する$( %応答 の `Referrer-Policy$h ~header )
◎
Set referrerPolicy to the result of parse a referrer policy from a Referrer-Policy header of response.
</li>
					<li>
~IF［
%許容される~sw ~EQ `失敗^i
］
⇒
`~network~error$を結果として，`非同期に完了-$する
◎
If serviceWorkerAllowed is failure, then:
• Asynchronously complete these steps with a network error.
</li>
					<li>
<p>
%合致した ~LET 次の下位手続きを走らせた結果
◎
↓↓</p>
						<ol>
							<li>
%最大~scope ~LET ε
◎
↓↓
Let scopeURL be registration’s scope url.
◎
↓↓
Let maxScopeString be null.
</li>
							<li>
<p>
~IF［
%許容される~sw ~EQ ~NULL
］
⇒
%最大~scope ~LET `~URL構文解析する$( `./^l, %~job の`~script~url$job )
◎
If serviceWorkerAllowed is null, then:
• Let resolvedScope be the result of parsing "./" using job’s script url as the base URL.
• Set maxScopeString to "/", followed by the strings in resolvedScope’s path (including empty strings), separated from each other by "/".
</p>

<p class="note">注記：
%最大~scope の`~path$urlの最後の~itemは，常に空~文字列になるので、下の %最大~scope文字列 の末尾は `/^l になる。
◎
Note: The final item in resolvedScope’s path will always be an empty string, so maxScopeString will have a trailing "/".
</p>
							</li>
							<li>
<p>
~ELSE：
◎
Else:
</p>
								<ol>
									<li>
%最大~scope ~LET `~URL構文解析する$( %許容される~sw, %~job の`~script~url$job )
◎
Let maxScope be the result of parsing serviceWorkerAllowed using job’s script url as the base URL.
</li>
									<li>
~IF［
%最大~scope の`生成元$url ~NEQ`生成元$sub %~job の`~script~url$jobの`生成元$url
］
⇒
~RET ~F
◎
If maxScope’s origin is job’s script url's origin, then:
• Set maxScopeString to "/", followed by the strings in maxScope’s path (including empty strings), separated from each other by "/".
</li>
								</ol>
							</li>
							<li>
%最大~scope文字列 ~LET 次の結果を `/^l で`連結する$
⇒
« 空~文字列 » を %最大~scope の`~path$urlで`拡張する$
◎
↑</li>
							<li>
%~scope文字列 ~LET 次の結果を `/^l で`連結する$
⇒
« 空~文字列 » を［
%登録 の`~scope~url$swrの`~path$url
］で`拡張する$
◎
Let scopeString be "/", followed by the strings in scopeURL’s path (including empty strings), separated from each other by "/".
</li>
							<li>
~IF［
%最大~scope文字列 は %~scope文字列 の`符号単位~接頭辞$でない【！not start with】
］
⇒
~RET ~F
◎
↓</li>
							<li>
~RET ~T
◎
↓</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%合致した ~EQ ~F
］：
◎
If maxScopeString is null or scopeString does not start with maxScopeString, then:
</p>
						<ol>
							<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
◎
Invoke Reject Job Promise with job and "SecurityError" DOMException.
</li>
							<li>
`~network~error$を結果として，`非同期に完了-$する
◎
Asynchronously complete these steps with a network error.
</li>
						</ol>
					</li>
					<li>
%~url ~LET %要請 の`~URL$rq
◎
Let url be request’s url.
</li>
					<li>
%更新-済み資源~map[ %~url ] ~SET %応答
◎
Set updatedResourceMap[url] to response.
</li>
					<li>
~IF［
%応答 の`~cache状態$ ~NEQ `local^l 
］
⇒
%登録 の`最後の更新~検査-時刻$swr ~SET 現在の時刻
◎
If response’s cache state is not "local", set registration’s last update check time to the current time.
</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
						<ul>
							<li>
%最新~worker ~EQ ~NULL
</li>
							<li>
［
%最新~worker の`~script~url$sw ~NEQ %~url【！＊】
］~OR［
%最新~worker の`種別$sw ~NEQ %~job の`~worker種別$job
］
</li>
							<li>
［
%最新~worker の`~script資源~map$sw[ %~url ] の`本体$rs, %応答 の`本体$rs
］は、~byte列として一致しない
</li>
						</ul>
<p>
…ならば
⇒
%資源を更新した ~SET ~T
</p>

◎
Set hasUpdatedResources to true if any of the following are true:
• newestWorker is null.
• newestWorker’s script url is not url or newestWorker’s type is not job’s worker type.
• newestWorker’s script resource map[url]'s body is not byte-for-byte identical with response’s body.
</li>
					<li>
<p>
~IF［
%資源を更新した ~EQ ~F
］~AND［
%最新~worker の`古典~script~import済み~flag$sw ~EQ ~T
］：
◎
If hasUpdatedResources is false and newestWorker’s classic scripts imported flag is set, then:
</p>

<p class="note">注記：
この段は、~importした~scriptが更新されたかどうかを検査する
— ~main~scriptは変化しなかった【ことが前~段から判明した】ので。
◎
Note: The following checks to see if an imported script has been updated, since the main script has not changed.
</p>
						<ol>
							<li>
<p>
%最新~worker の`~script資源~map$swを成す
~EACH( %~import~URL → %格納-済み応答 )
に対し：
◎
For each importUrl → storedResponse of newestWorker’s script resource map:
</p>
								<ol>
									<li>
~IF［
%~import~URL ~EQ %~url【！＊】
］
⇒
~CONTINUE
◎
If importUrl is url, then continue.
</li>
									<li>
%~import要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~URL$rq~SET %~import~URL,
`~client$rq~SET %~job の`~client$job,
`行先$rq~SET `script^l,
`構文解析器~metadata$rq~SET  `not parser-inserted^l,
`同期~flag$rq~SET ~T,
`資格証利用URL~flag$rq~SET ~T
◎
Let importRequest be a new request whose url is importUrl, client is job’s client, destination is "script", parser metadata is "not parser-inserted", synchronous flag is set, and whose use-URL-credentials flag is set.
</li>
									<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
Set importRequest’s cache mode to "no-cache" if any of the following are true:
</p>
										<ul>
											<li>
%登録 の`~cacheを介する更新~mode$swr ~EQ `none^l 
◎
registration’s update via cache mode is "none".
</li>

											<li>
%~job の`~cacheを迂回するよう強制する~flag$job ~EQ ~T
◎
job’s force bypass cache flag is set.
</li>

											<li>
%登録 は`非新鮮$である
◎
registration is stale.
</li>
										</ul>
<p>
…ならば
⇒
%~import要請 の`~cache~mode$rq ~SET `no-cache^l
◎
↑</p>
									</li>
									<li>
%~fetchした応答 ~LET %~import要請 を`~fetch$する
◎
Let fetchedResponse be the result of fetching importRequest.
</li>
									<li>
%更新-済み資源~map[ %~import要請 の`~URL$rq ] ~SET %~fetchした応答
◎
Set updatedResourceMap[importRequest’s url] to fetchedResponse.
</li>
									<li>
%~fetchした応答 ~SET %~fetchした応答 の`非安全~応答$
◎
Set fetchedResponse to fetchedResponse’s unsafe response.
</li>
									<li>
~IF［
%~fetchした応答 の`~cache状態$ ~NEQ `local^l
］
⇒
%登録 の`最後の更新~検査-時刻$swr ~SET 現在の時刻
◎
If fetchedResponse’s cache state is not "local", set registration’s last update check time to the current time.
</li>
									<li>
<p>
~IF［
%~fetchした応答 は`不良な~import~script応答$である
］
⇒
~CONTINUE
◎
If fetchedResponse is a bad import script response, continue.
</p>

<p class="note">注記：
`importScripts()$c に対する不良な応答は、~byte列として検査する目的（次の段）においては無視される。
［
現任の~worker ／ 更新~workerになり得るもの【！potential＊】
］に対する不良でない応答に限り考慮される。
その根拠のいくつかは， `1374$issue を見よ。
◎
Note: Bad responses for importScripts() are ignored for the purpose of the byte-to-byte check. Only good responses for the incumbent worker and good responses for the potential update worker are considered. See issue #1374 for some rationale.
</p>
									</li>
									<li>
<p>
~IF［［
%~fetchした応答 の`本体$rs
］と［
%格納-済み応答 の`非安全~応答$の`本体$rs
］は、~byte列として一致しない
］
⇒
%資源を更新した ~SET ~T
◎
If fetchedResponse’s body is not byte-for-byte identical with storedResponse’s unsafe response's body, set hasUpdatedResources to true.
</p>
									</li>
								</ol>

<p class="note">注記：
~importしたすべての~scriptで~cacheを拡充するため、~loopはこの段で ~BREAK することなく ~CONTINUE する。
【！The control】
◎
Note: The control does not break the loop in this step to continue with all the imported scripts to populate the cache.
</p>

							</li>
						</ol>
					</li>
					<li>
%応答 を結果として，`非同期に完了-$する
◎
Asynchronously complete these steps with response.
</li>
				</ol>
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
前~段が %~script を結果として，`非同期に完了-$するまで待機する
◎
↓↓</li>
	<li>
<p>
~IF［
%~script ~EQ ~NULL
］：
◎
If the algorithm asynchronously completes with null, then:
</p>
		<ol>
			<li>
<p>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</p>

<p class="note">注記：
これは、以前に
`~job~promiseを却下する$( `SecurityError$E 例外 )
が呼出されていた場合は何もしない。
◎
Note: This will do nothing if Reject Job Promise was previously invoked with "SecurityError" DOMException.
</p>
			</li>
			<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
`~scopeから登録への~map$[ `~URLを直列化する$( %登録 の`~scope~url$swr ) ] ~SET ε
【！原文の %scopeURL は定義されていない】
◎
If newestWorker is null, then remove scope to registration map[scopeURL, serialized].
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%資源を更新した ~EQ ~F
］：
◎
Else, continue the rest of these steps after the algorithm’s asynchronous completion, with script being the asynchronous completion value.
◎
If hasUpdatedResources is false, then:
</p>
		<ol>
			<li>
%登録 の`~cacheを介する更新~mode$swr ~SET %~job の`~cacheを介する更新~mode$job
◎
Set registration’s update via cache mode to job’s update via cache mode.
</li>
			<li>
`~job~promiseを解決する$( %~job, %登録 )
◎
Invoke Resolve Job Promise with job and registration.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%~worker ~LET 次のようにされた新たな`~sw$
⇒＃
`~script~url$sw ~SET %~job の`~script~url$job,
`種別$sw ~SET %~job の`~worker種別$job,
`~script資源$sw ~SET %~script,
`~script資源~map$sw ~SET %更新-済み資源~map
◎
Let worker be a new service worker.
◎
Set worker’s script url to job’s script url, worker’s script resource to script, worker’s type to job’s worker type, and worker’s script resource map to updatedResourceMap.
</li>
	<li>
%~worker の`利用した~scriptの集合$swに %~url を付加する
◎
Append url to worker’s set of used scripts.
</li>
	<li>
%~worker の`~script資源$swの
⇒＃
`~HTTPS状態$sw ~SET %~https状態,
`~referrer施策$sw ~SET %~referrer施策
◎
Set worker’s script resource’s HTTPS state to httpsState.
◎
Set worker’s script resource’s referrer policy to referrerPolicy.
</li>
	<li>
%走らせた結果 ~LET `~swを走らす$( %~worker, %~job の`~cacheを迂回するよう強制する~flag$job )
◎
Let forceBypassCache be true if job’s force bypass cache flag is set, and false otherwise.
◎
Let runResult be the result of running the Run Service Worker algorithm with worker and forceBypassCache.
</li>
	<li>
<p>
IF［
%走らせた結果 ~EQ `失敗^i
］~OR［
%走らせた結果 は`中途完了$である
］：
◎
If runResult is failure or an abrupt completion, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</li>
			<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
`~scopeから登録への~map$[ `~URLを直列化する$( %登録 の`~scope~url$swr ) ] ~SET ε
◎
If newestWorker is null, then remove scope to registration map[registration’s scope url, [serialized].
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
`~installする$( %~job, %~worker, %登録 )
◎
Else, invoke Install algorithm with job, worker, and registration as its arguments.
</li>
</ol>

		</section>
		<section id="soft-update-algorithm">
<h3 title="Soft Update">`~soft更新する@</h3>

<p>
~UAは、これを何度でも~callして，更新-を検査してヨイ。
◎
The user agent may call this as often as it likes to check for updates.
</p>

<ul>
	<li>
<p>
入力
⇒＃
%登録 — `~sw登録$,
%~cacheを迂回するよう強制する — 真偽値（省略時は ~F ）
◎
Input
• registration, a service worker registration
• forceBypassCache, an optional boolean, false by default
</p>

<p class="note">注記：
実装者は、~debugし易くなるよう
%~cacheを迂回するよう強制する
を利用してもヨイ（例：開発者~toolから呼出すなど）。
また、~swを拡張する他の仕様も，自前の必要に応じてこの~flagを利用してもヨイ。
◎
Note: Implementers may use forceBypassCache to aid debugging (e.g. invocations from developer tools), and other specifications that extend service workers may also use the flag on their own needs.
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
%最新~worker ~LET 
`最新の~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as its argument.
</li>
	<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
~RET
◎
If newestWorker is null, abort these steps.
</li>
	<li>
%~job ~LET `~jobを作成する$( 次に挙げる引数 )
⇒＃
`更新する^i,
%登録 の`~scope~url$swr,
%最新~worker の`~script~url$sw,
~NULL,
~NULL
◎
Let job be the result of running Create Job with update, registration’s scope url, newestWorker’s script url, null, and null.
</li>
	<li>
%~job の`~worker種別$job ~SET %最新~worker の`種別$sw
◎
Set job’s worker type to newestWorker’s type.
</li>
	<li>
%~job の`~cacheを迂回するよう強制する~flag$job ~SET %~cacheを迂回するよう強制する
◎
Set job’s force bypass cache flag if forceBypassCache is true.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
</ol>

		</section>
		<section id="installation-algorithm">
<h3 title="Install">`~installする@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$,
%~worker — `~sw$,
%登録 — `~sw登録$
◎
Input
• job, a job
• worker, a service worker
• registration, a service worker registration
</li>
	<li>
出力
⇒＃
~none
◎
Output
• none
</li>
</ul>

<ol>
	<li>
%~installに失敗した ~LET ~F
◎
Let installFailed be false.
</li>
	<li>
%最新~worker ~LET `最新の~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as its argument.
</li>
	<li>
%登録 の`~cacheを介する更新~mode$swr ~SET %~job の`~cacheを介する更新~mode$job
◎
Set registration’s update via cache mode to job’s update via cache mode.
</li>
	<li>
`登録の状態を更新する$( %登録, `installing^l, %~worker )
◎
Run the Update Registration State algorithm passing registration, "installing" and worker as the arguments.
</li>
	<li>
`~workerの状態を更新する$( %登録 にて`~install中の~worker$swr, `installing^l )
◎
Run the Update Worker State algorithm passing registration’s installing worker and "installing" as the arguments.
</li>
	<li>
~Assert：
%~job の`~job~promise$job ~NEQ ~NULL
◎
Assert: job’s job promise is not null.
</li>
	<li>
`~job~promiseを解決する$( %~job, %登録 )
◎
Invoke Resolve Job Promise with job and registration.
</li>
	<li>
%設定群~objたち ~LET 次を満たす`環境~設定群~obj$すべてからなる集合
⇒
`生成元$enV ~EQ`生成元$sub %登録 の`~scope~url$swrの`生成元$url
◎
Let settingsObjects be all environment settings objects whose origin is registration’s scope url's origin.
</li>
	<li>
<p>
%設定群~objたち を成す
~EACH( %設定群~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %設定群~obj の`担当の~event-loop$enV )：
◎
For each settingsObject of settingsObjects, queue a task on settingsObject’s responsible event loop in the DOM manipulation task source to run the following steps:
</p>
		<ol>
			<li>
%登録~objたち ~LET %設定群~obj の`~Realm$enV内の `ServiceWorkerRegistration$I ~objのうち［
`表現する~sw登録$ ~EQ %登録
］を満たすもの
◎
Let registrationObjects be every ServiceWorkerRegistration object in settingsObject’s realm, whose service worker registration is registration.
</li>
			<li>
%登録~objたち を成す
~EACH( %登録~obj )
に対し
⇒
%登録~obj に向けて，名前 `updatefound$et の`~eventを発火する$
◎
For each registrationObject of registrationObjects, fire an event on registrationObject named updatefound.
</li>
		</ol>
	</li>
	<li>
%~install中の~worker ~LET %登録 にて`~install中の~worker$swr
◎
Let installingWorker be registration’s installing worker.
</li>
	<li>
<p>
~IF［
`~eventを飛ばすべきか$( `install^l, %~install中の~worker ) ~EQ ~F
］：
◎
If the result of running the Should Skip Event algorithm with installingWorker and "install" is false, then:
</p>
		<ol>
			<li>
%~cacheを迂回するよう強制する ~LET %~job の`~cacheを迂回するよう強制する~flag$job
◎
Let forceBypassCache be true if job’s force bypass cache flag is set, and false otherwise.
</li>
			<li>
~IF［
`~swを走らす$( %~install中の~worker, %~cacheを迂回するよう強制する ) ~EQ `失敗^i
］
⇒
%~installに失敗した ~SET ~T
◎
If the result of running the Run Service Worker algorithm with installingWorker and forceBypassCache is failure, then:
• Set installFailed to true.
</li>
			<li>
<p>
~ELSE：
◎
Else:
</p>
				<ol>
					<li>
<p>
%~task ~LET `~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~install中の~worker の`~event-loop$ )：
◎
Queue a task task on installingWorker’s event loop using the DOM manipulation task source to run the following steps:
</p>
						<ol>
							<li>
%~event ~LET `~eventを作成する$( `ExtendableEvent$I )
◎
Let e be the result of creating an event with ExtendableEvent.
</li>
							<li>
%~event の`type$n 属性 ~SET `install$et に初期化する
◎
Initialize e’s type attribute to install.
</li>
							<li>
%~install中の~worker の`大域~obj$swに向けて，
%~event を`配送する$
◎
Dispatch e at installingWorker’s global object.
</li>
							<li>
<p>
`非同期~拡張を待機する^i
— この段は`並列的$に走らす：
◎
WaitForAsynchronousExtensions: Run the following substeps in parallel:
</p>
								<ol>
									<li id="install-settle-step">
次が満たされるまで待機する
⇒
%~event は`作動中$eXでない
◎
Wait until e is not active.
</li>
									<li>
%~promise ~LET `すべての~promiseを待機する$( %~event の`~lifetimeを延長する~promiseたち$, † )
【`すべてを待機する~promiseを取得する$？`1363$issue ／†成功（失敗）手続きが指定されていない — 次に与える動作を適切に解釈し直す必要がある。】
⇒
待機している間に［
%~event の`時間切れ~flag$ ~EQ ~T
］になったときは ／
%~promise の`却下-時$には
⇒
%~installに失敗した ~SET ~T
◎
If e’s timed out flag is set, or the result of waiting for all of e’s extend lifetime promises rejected, set installFailed to true.
</li>
								</ol>
							</li>
						</ol>
<p>
%~task が破棄されたときは
⇒
%~installに失敗した ~SET ~T
◎
If task is discarded, set installFailed to true.
</p>
					</li>
					<li>
%~task が実行されるか破棄されるまで待機する
◎
Wait for task to have executed or been discarded.
</li>
					<li>
`非同期~拡張を待機する^i 段が完了するまで待機する
◎
Wait for the step labeled WaitForAsynchronousExtensions to complete.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~installに失敗した ~EQ ~T
］：
◎
If installFailed is true, then:
</p>
		<ol>
			<li>
`~workerの状態を更新する$( %登録 にて`~install中の~worker$swr, `redundant^l )
◎
Run the Update Worker State algorithm passing registration’s installing worker and "redundant" as the arguments.
</li>
			<li>
`登録の状態を更新する$( %登録, `installing^l, ~NULL )
◎
Run the Update Registration State algorithm passing registration, "installing" and null as the arguments.
</li>
			<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
`~scopeから登録への~map$[ `~URLを直列化する$( %登録 の`~scope~url$swr ) ] ~SET ε
◎
If newestWorker is null, then remove scope to registration map[registration’s scope url, [serialized].
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%~map ~LET %登録 にて`~install中の~worker$swrの`~script資源~map$sw
◎
Let map be registration’s installing worker's script resource map.
</li>
	<li>
%利用した~scriptたち ~LET %登録 にて`~install中の~worker$swrの`利用した~scriptの集合$sw
◎
Let usedSet be registration’s installing worker's set of used scripts.
</li>
	<li>
%~map を成す
~EACH( %~url )
に対し
⇒
~IF［
%~url ~NIN %利用した~scriptたち
］
⇒
%~map[ %~url ] ~SET ε
◎
For each url of map:
• If usedSet does not contain url, then remove map[url].
</li>
	<li>
<p>
~IF［
%登録 にて`待機-中の~worker$swr ~NEQ ~NULL
］：
◎
If registration’s waiting worker is not null, then:
</p>
		<ol>
			<li>
`~swを終了する$( %登録 にて`待機-中の~worker$swr )
◎
Terminate registration’s waiting worker.
</li>
			<li>
`~workerの状態を更新する$( %登録 にて`待機-中の~worker$swr, `redundant^l )
◎
Run the Update Worker State algorithm passing registration’s waiting worker and "redundant" as the arguments.
</li>
		</ol>
	</li>
	<li>
`登録の状態を更新する$( %登録, `waiting^l, %登録 にて`~install中の~worker$swr )
◎
Run the Update Registration State algorithm passing registration, "waiting" and registration’s installing worker as the arguments.
</li>
	<li>
`登録の状態を更新する$( %登録, `installing^l, ~NULL )
◎
Run the Update Registration State algorithm passing registration, "installing" and null as the arguments.
</li>
	<li>
`~workerの状態を更新する$( %登録 にて`待機-中の~worker$swr, `installed^l )
◎
Run the Update Worker State algorithm passing registration’s waiting worker and "installed" as the arguments.
</li>
	<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job.
</li>
	<li>
［
この~algoにより呼出された`~workerの状態を更新する$
］により`~queueされ$たすべての`~task$ が実行されるまで待機する
◎
Wait for all the tasks queued by Update Worker State invoked in this algorithm to have executed.
</li>
	<li>
<p>
`作動化しようと試行する$( %登録 )
◎
Invoke Try Activate with registration.
</p>

<div class="note">
<p>注記：
ここで`作動化しようと試行する$() が`作動化する$() を誘発しない場合、`作動化する$() は，次のとき再度~試行される：
</p>
<ul><li>既存の`作動中の~worker$swrにより制御されている最後の~clientが，`~unload$されたとき。
</li><li>`ServiceWorkerGlobalScope^I1`skipWaiting()$m1 が非同期的に~callされたとき。
</li><li>既存の`作動中の~worker$swr用の`~lifetimeを延長する~promiseたち$が決着したとき。
</li></ul>
◎
Note: If Try Activate does not trigger Activate here, Activate is tried again when the last client controlled by the existing active worker is unloaded, skipWaiting() is asynchronously called, or the extend lifetime promises for the existing active worker settle.
</div>
	</li>
</ol>

		</section>
		<section id="activation-algorithm">
<h3 title="Activate">`作動化する@</h3>

<ul>
	<li>
入力
⇒＃
%登録 — `~sw登録$
◎
Input
• registration, a service worker registration
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
~IF［
%登録 にて`待機-中の~worker$swr ~EQ ~NULL
］
⇒
~RET
◎
If registration’s waiting worker is null, abort these steps.
</li>
	<li>
<p>
~IF［
%登録 にて`作動中の~worker$swr ~NEQ ~NULL
］：
◎
If registration’s active worker is not null, then:
</p>
		<ol>
			<li>
`~swを終了する$( %登録 にて`作動中の~worker$swr )
◎
Terminate registration’s active worker.
</li>
			<li>
`~workerの状態を更新する$( %登録 にて`作動中の~worker$swr, `redundant^l )
◎
Run the Update Worker State algorithm passing registration’s active worker and "redundant" as the arguments.
</li>
		</ol>
	</li>
	<li>
`登録の状態を更新する$( %登録, `active^l, %登録 にて`待機-中の~worker$swr )
◎
Run the Update Registration State algorithm passing registration, "active" and registration’s waiting worker as the arguments.
</li>
	<li>
`登録の状態を更新する$( %登録, `waiting^l, ~NULL )
◎
Run the Update Registration State algorithm passing registration, "waiting" and null as the arguments.
</li>
	<li>
<p>
`~workerの状態を更新する$( %登録 にて`作動中の~worker$swr, `activating^l )
◎
Run the Update Worker State algorithm passing registration’s active worker and "activating" as the arguments.
</p>

<p class="note">注記：
作動中の~workerが作動化-中（ `activating^l ）になって以降は、［
実行時~script~error, 作動中の~workerの強制-終了
］のいずれも，作動中の~workerが作動化されるのを防止しない。
◎
Note: Once an active worker is activating, neither a runtime script error nor a force termination of the active worker prevents the active worker from getting activated.
</p>
	</li>
	<li>
%合致した~clientたち ~LET 次を満たす`~sw~client$ %~client すべてからなる~list
【順序は述べられていない】
⇒
`合致する~sw登録$( %~client の`作成時の~URL$enV ) ~EQ %登録 【！の`~scope~url$swr】
◎
Let matchedClients be a list of service worker clients whose creation URL matches registration’s scope url.
</li>
	<li>
<p>
%合致した~clientたち を成す
~EACH( %~client )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~client に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
For each client of matchedClients, queue a task on client’s responsible event loop, using the DOM manipulation task source, to run the following substeps:
</p>
		<ol>
			<li>
%準備済み~promise ~LET %~client の`大域~obj$enVの `ServiceWorkerContainer$I の`準備済み~promise$SWC
◎
Let readyPromise be client’s global object's ServiceWorkerContainer object’s ready promise.
</li>
			<li id="activate-resolve-ready-step">
~IF［
%準備済み~promise は決着していない
］
⇒
次の結果で %準備済み~promise を解決する
⇒
`~sw登録~objを取得する$( %登録, %準備済み~promise に`関連な設定群~obj$ )
◎
If readyPromise is pending, resolve readyPromise with the the result of getting the service worker registration object that represents registration in readyPromise’s relevant settings object.
</li>
		</ol>
	</li>
	<li>
<p>
【この段は未訳：`~app~cache$関連の記述（要約：~app~cacheは~~無効にする）。】
◎
For each client of matchedClients:
• If client is a window client, unassociate client’s responsible document from its application cache, if it has one.
• Else if client is a shared worker client, unassociate client’s global object from its application cache, if it has one.
</p>

<p class="note">注記：
資源は、今や，既存の~app~cacheに代えて~sw登録を利用することになる。
◎
Note: Resources will now use the service worker registration instead of the existing application cache.
</p>
	</li>
	<li>
<p>
%登録 を`利用して$いる
~EACH( `~sw~client$ %~client )
に対し：
◎
For each service worker client client who is using registration:
</p>
		<ol>
			<li>
%~client にて`作動中の~sw$enV【！`作動中の~worker$swrは誤記】 ~SET %登録 にて`作動中の~worker$swr
◎
Set client’s active worker to registration’s active worker.
</li>
			<li>
`制御器の変化を通知する$( %~client )
◎
Invoke Notify Controller Change algorithm with client as the argument.
</li>
		</ol>
	</li>
	<li>
%作動中の~worker ~LET %登録 にて`作動中の~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
<p>
~IF［
`~eventを飛ばすべきか$( `activate^l, %作動中の~worker ) ~EQ ~F
］：
◎
If the result of running the Should Skip Event algorithm with activeWorker and "activate" is false, then:
</p>
		<ol>
			<li>
<p>
~IF［
`~swを走らす$( %作動中の~worker ) ~NEQ `失敗^i
］：
◎
If the result of running the Run Service Worker algorithm with activeWorker is not failure, then:
</p>
				<ol>
					<li>
<p>
%~task ~LET `~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %作動中の~worker の`~event-loop$ )：
◎
Queue a task task on activeWorker’s event loop using the DOM manipulation task source to run the following steps:
</p>
						<ol>
							<li>
%~event ~LET `~eventを作成する$( `ExtendableEvent$I )
◎
Let e be the result of creating an event with ExtendableEvent.
</li>
							<li>
%~event の`type$n 属性 ~SET "`activate$et" に初期化する
◎
Initialize e’s type attribute to activate.
</li>
							<li>
%作動中の~worker の`大域~obj$swに向けて，
%~event を`配送する$
◎
Dispatch e at activeWorker’s global object.
</li>
							<li id="activate-settle-step">
`非同期~拡張を待機する^i
⇒
%~event が`作動中$eXでなくなるまで`並列的$に待機する
◎
WaitForAsynchronousExtensions: Wait, in parallel, until e is not active.
</li>
						</ol>
					</li>
					<li>
%~task が実行されるか破棄されるまで待機する
◎
Wait for task to have executed or been discarded.
</li>
					<li>
`非同期~拡張を待機する^i 段が完了するまで待機する
◎
Wait for the step labeled WaitForAsynchronousExtensions to complete.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`~workerの状態を更新する$( %登録 にて`作動中の~worker$swr, `activated^l )
◎
Run the Update Worker State algorithm passing registration’s active worker and "activated" as the arguments.
</li>
</ol>

		</section>
		<section id="try-activate-algorithm">
<h3 title="Try Activate">`作動化しようと試行する@</h3>

<ul>
	<li>
入力
⇒＃
%登録 — `~sw登録$
◎
Input
• registration, a service worker registration
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
~IF［
%登録 にて`待機-中の~worker$swr ~EQ ~NULL
］
⇒
~RET
◎
If registration’s waiting worker is null, return.
</li>
	<li>
<p>
~IF［
%登録 にて`作動中の~worker$swr ~NEQ ~NULL
］~AND［
%登録 にて`作動中の~worker$swrの`状態$sw ~EQ `activating^l
］
⇒
~RET
◎
If registration’s active worker is not null and registration’s active worker's state is "activating", return.
</p>

<p class="note">注記：
既存の作動中の~workerの状態が依然として作動化-中（ `activating^l ）にある場合、待機-中の~workerの作動化は遅延される。
◎
Note: If the existing active worker is still in activating state, the activation of the waiting worker is delayed.
</p>
	</li>
	<li>
<p>
~IF［
%登録 にて`作動中の~worker$swr ~EQ ~NULL
］~OR［
次のいずれも満たされる
］：
◎
Invoke Activate with registration if either of the following is true:
• registration’s active worker is null.
</p>
		<ul>
			<li>
`~swには処理待ち~eventは無い$( %登録 にて`作動中の~worker$swr ) ~EQ ~T
◎
The result of running Service Worker Has No Pending Events with registration’s active worker is true, and＼
</li>
			<li>
［
%登録 を`利用して$いる`~sw~client$はない
］~OR［
%登録 にて`待機-中の~worker$swrの`待機を飛ばす~flag$sw ~EQ ~T
］
◎
no service worker client is using registration or registration’s waiting worker's skip waiting flag is set.
</li>
		</ul>
<p>
…ならば
⇒
`作動化する$( %登録 )
◎
↑
</p>

	</li>
</ol>

		</section>
		<section id="run-service-worker-algorithm">
<h3 title="Run Service Worker">`~swを走らす@</h3>

<ul>
	<li>
入力
⇒＃
%~sw — `~sw$,
%~cacheを迂回するよう強制する — 真偽値（省略時は ~F ）
◎
Input
• serviceWorker, a service worker
• forceBypassCache, an optional boolean, false by default
</li>
	<li>
出力
⇒＃
`Completion$ ／ `失敗^i
◎
Output
• a Completion or failure
</li>
</ul>

<p class="note">注記：
この~algoは、［
当の~swが`走っている$ようになるか，開始-に失敗する
］まで他を阻む。
◎
Note: This algorithm blocks until the service worker is running or fails to start.
</p>

<ol>
	<li>
~IF［
%~sw は`走っている$
］
⇒
~RET %~sw の`開始-状態$
◎
If serviceWorker is running, then return serviceWorker’s start status.
</li>
	<li>
~IF［
%~sw の`状態$sw ~EQ `redundant^l
］
⇒
~RET `失敗^i
◎
If serviceWorker’s state is "redundant", then return failure.
</li>
	<li>
~Assert：
%~sw の`開始-状態$ ~EQ ~NULL
◎
Assert: serviceWorker’s start status is null.
</li>
	<li>
%~script ~LET %~sw の`~script資源$sw
◎
Let script be serviceWorker’s script resource.
</li>
	<li>
~Assert：
%~script ~NEQ ~NULL
◎
Assert: script is not null.
</li>
	<li>
%開始-に失敗した ~LET ~F
◎
Let startFailed be false.
</li>
	<li>
<p>
別々の並列的な実行~環境（すなわち、別々の~thread等【！ or process】，等価な構成子）を作成した上で、その文脈~内で次の手続きを走らす：
◎
Create a separate parallel execution environment (i.e. a separate thread or process or equivalent construct), and run the following steps in that context:
</p>
		<ol>
			<li>
%~worker大域~scope ~LET 新たな `ServiceWorkerGlobalScope$I ~obj
◎
↓</li>
			<li>
%~realm実行~文脈 ~LET
大域~objに %~worker大域~scope を用いるように~custom化する下で、
~JS `InitializeHostDefinedRealm()$jA 抽象-演算を~callして作成される`~JS実行~文脈$
◎
Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:
• For the global object, create a new ServiceWorkerGlobalScope object. Let workerGlobalScope be the created object.
• Let realmExecutionContext be the created JavaScript execution context.
</li>
			<li>
%~sw の`大域~obj$sw ~SET %~worker大域~scope
◎
Set serviceWorker’s global object to workerGlobalScope.
</li>
			<li>
%~worker~event-loop ~LET 新たな`~event-loop$
◎
Let workerEventLoop be a newly created event loop.
</li>
			<li>
<p>
%設定群~obj ~LET 新たな`環境~設定群~obj$
— その各種~algoは、次に従うように定義する：
◎
Let settingsObject be a new environment settings object whose algorithms are defined as follows:
</p>
				<dl>
					<dt>`~realm実行~文脈$enV</dt>
					<dd>
~RET %~realm実行~文脈
◎
Return realmExecutionContext.
</dd>

					<dt>`大域~obj$enV</dt>
					<dd>
~RET %~worker大域~scope
◎
Return workerGlobalScope.
</dd>

					<dt>`担当の~event-loop$enV</dt>
					<dd>
~RET %~worker~event-loop
◎
Return workerEventLoop.
</dd>

					<dt>`~referrer施策$enV</dt>
					<dd>
~RET %~worker大域~scope の`~referrer施策$wG
◎
Return workerGlobalScope’s referrer policy.
</dd>

					<dt>`~API用~URL文字~符号化法$enV</dt>
					<dd>
~RET ~UTF-8
◎
Return UTF-8.
</dd>

					<dt>`~API用~基底~URL$enV</dt>
					<dd>
~RET %~sw の`~script~url$sw
◎
Return serviceWorker’s script url.
</dd>

					<dt id="_sw-origin">`生成元$enV</dt>
					<dd>
~RET %~sw を登録している`~sw~client$【！＊】の`生成元$cl【！`生成元$enV】
◎
Return its registering service worker client's origin.
</dd>

					<dt>`作成時の~URL$enV</dt>
					<dd>
~RET %~worker大域~scope の`~url$wG
◎
Return workerGlobalScope’s url.
</dd>

					<dt>`~HTTPS状態$enV</dt>
					<dd>
~RET %~worker大域~scope の`~HTTPS状態$wG
◎
Return workerGlobalScope’s HTTPS state.
</dd>
				</dl>
			</li>
			<li>
%~worker大域~scope の
⇒＃
`~url$wG ~SET %~sw の`~script~url$sw,
`~HTTPS状態$wG ~SET %~sw の`~script資源$swの`~HTTPS状態$sw,
`~referrer施策$wG ~SET %~sw の`~script資源$swの`~referrer施策$sw,
`種別$wG ~SET %~sw の`種別$sw,
`~importする~script用には~cacheを迂回するよう強制する~flag$SWG ~SET %~cacheを迂回するよう強制する
◎
Set workerGlobalScope’s url to serviceWorker’s script url.
◎
Set workerGlobalScope’s HTTPS state to serviceWorker’s script resource’s HTTPS state.
◎
Set workerGlobalScope’s referrer policy to serviceWorker’s script resource’s referrer policy.
◎
Set workerGlobalScope’s type to serviceWorker’s type.
◎
Set workerGlobalScope’s force bypass cache for import scripts flag if forceBypassCache is true.
</li>
			<li>
%~worker大域~scope に，新たな `WorkerLocation$I ~objを結付ける
◎
Create a new WorkerLocation object and associate it with workerGlobalScope.
</li>
			<li>
<p>
~IF［
%~sw は`作動中の~worker$swrである
］：
</p>
				<ol>
					<li>
［
%~sw を`包含している~sw登録$swの`~back-up~task~list$swr
］を成す
~EACH( `~task$ %~task )
に対し，順に
⇒
`~taskを~queueする$( %~task の`源$tK, %~task の`手続き$tK, %~sw の`~event-loop$ )
</li>
					<li>
`~back-up~task~list$swrを空にする
【この段は、この訳による補完（さもなければ，この~listは肥大する一方になり、ここ以外に，~listから除去し得る~~機会もない）。】
</li>
				</ol>
◎
If serviceWorker is an active worker, and there are any tasks queued in serviceWorker’s containing service worker registration’s task queues, queue them to serviceWorker’s event loop’s task queues in the same order using their original task sources.
</li>
			<li>
<p>
%評価~状態s ~LET %~script の種類に応じて，次を走らせた結果：
</p>
				<ul class="switch">
					<li>
`古典~script$
⇒
`古典~scriptを走らす$( %~script )
</li>
					<li>
`~module~script$
⇒
`~module~scriptを走らす$( %~script )
</li>
				</ul>

◎
Let evaluationStatus be the result of running the classic script script if script is a classic script, otherwise, the result of running the module script script if script is a module script.
</li>
			<li>
~IF［
%評価~状態s .`Value^sl は空である（すなわち、~scriptは，まだ評価されていない）
］
⇒＃
%開始-に失敗した ~SET ~T；
~RET
◎
If evaluationStatus.[[Value]] is empty, this means the script was not evaluated. Set startFailed to true and abort these steps.
</li>
			<li>
~IF［
当の~scriptは`~swを終了する$~algoにより中止された
］
⇒＃
%開始-に失敗した ~SET ~T；
~RET
◎
If the script was aborted by the Terminate Service Worker algorithm, set startFailed to true and abort these steps.
</li>
			<li>
%~sw の`開始-状態$ ~SET %評価~状態s
◎
Set serviceWorker’s start status to evaluationStatus.
</li>
			<li>
<p>
~IF［
%~script の`過去評価済み~flag$sw ~EQ ~F
］：
◎
If script’s has ever been evaluated flag is unset, then:
</p>
				<ol>
					<li>
<p>
%設定群~obj の`大域~obj$enVに結付けられている【！＊？】
~EACH( `~event~listener$ %~listener )
に対し
⇒
%~worker大域~scope の`~sw$SWGが`取扱う~event型の集合$swに %~listener の~event型 を`付加する$set
◎
For each eventType of settingsObject’s global object's associated list of event listeners' event types:
• Append eventType to workerGlobalScope’s associated service worker's set of event types to handle.
</p>

<p class="note">注記：
この時点に［
大域~objに結付けられている~event~listener
］が追加されてない場合、当の`~sw$SWGが`取扱う~event型の集合$swは，空~集合であり続ける。
~UAには、［
~event~listenerは、~worker~scriptの最初期の評価-時に追加される必要がある旨
］を，警告に示すことが奨励される。
【 “最初期” とは、おそらく，最初に同期的に走る~codeを意味する。】
◎
Note: If the global object’s associated list of event listeners does not have any event listener added at this moment, the service worker’s set of event types to handle remains an empty set. The user agents are encouraged to show a warning that the event listeners must be added on the very first evaluation of the worker script.
</p>
					</li>
					<li>
%~script の`過去評価済み~flag$sw ~SET ~T
◎
Set script’s has ever been evaluated flag.
</li>
				</ol>
			</li>
			<li>
%設定群~obj により指定される
`担当の~event-loop$enVを，破壊されるまで走らす
◎
Run the responsible event loop specified by settingsObject until it is destroyed.
</li>
			<li>
%~worker大域~scope にて`作動中の~timer~list$を空にする
◎
Empty workerGlobalScope’s list of active timers.
</li>
		</ol>
	</li>
	<li>
次が満たされるまで待機する
⇒
［
%~sw は`走っている$
］~OR［
%開始-に失敗した ~EQ ~T
］
◎
Wait for serviceWorker to be running, or for startFailed to be true.
</li>
	<li>
~IF［
%開始-に失敗した ~EQ ~T
］
⇒
~RET `失敗^i
◎
If startFailed is true, then return failure.
</li>
	<li>
~RET %~sw の`開始-状態$
◎
Return serviceWorker’s start status.
</li>
</ol>

		</section>
		<section id="terminate-service-worker-algorithm">
<h3 title="Terminate Service Worker">`~swを終了する@</h3>

<ul>
	<li>
入力
⇒＃
%~sw — `~sw$
◎
Input
• serviceWorker, a service worker
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<p>
以下は、 %~sw の~main~loopとは`並列的$に走らす：
◎
Run the following steps in parallel with serviceWorker’s main loop:
</p>

<ol>
	<li>
%~sw大域~scope ~LET %~sw の`大域~obj$sw
◎
Let serviceWorkerGlobalScope be serviceWorker’s global object.
</li>
	<li>
%~sw大域~scope の`~close中~flag$wG ~SET ~T
◎
Set serviceWorkerGlobalScope’s closing flag to true.
</li>
	<li>
%~sw の`延長-済み~event集合$swを`空にする$
◎
Remove all the items from serviceWorker’s set of extended events.
</li>
	<li>
%~back-up ~LET %~sw を`包含している~sw登録$swの`~back-up~task~list$swr
◎
↓</li>
	<li>
~EACH( %~task源 ~IN { `~fetchを取扱う~task源$, `機能的~eventを取扱う~task源$ } )
に対し
⇒
%~sw大域~scope の`~event-loop$に属する［
%~task源 に結付けられている`~task~queue$
］を成す
~EACH( %~task )
に対し
⇒
%~back-up に %~task を`付加する$set
◎
If there are any tasks, whose task source is either the handle fetch task source or the handle functional event task source, queued in serviceWorkerGlobalScope’s event loop’s task queues, queue them to serviceWorker’s containing service worker registration’s corresponding task queues in the same order using their original task sources, and＼
</li>
	<li>
<p>
%~sw大域~scope の`~event-loop$に属する
~EACH( `~task~queue$ %~queue )
に対し
⇒
%~queue を`空にする$
◎
discard all the tasks (including tasks whose task source is neither the handle fetch task source nor the handle functional event task source) from serviceWorkerGlobalScope’s event loop’s task queues without processing them.
</p>

<p class="note">注記：
これは実質的に， `fetch$et やその他の`機能的~event$（ `push$et ~eventなど）に限り~back-upされ、他の~task（ `message$et ~eventなど）は処理することなく破棄されることを意味する。
◎
Note: This effectively means that the fetch events and the other functional events such as push events are backed up by the registration’s task queues while the other tasks including message events are discarded.
</p>
	</li>
	<li>
%~sw 内で現在~走らせている`~scriptを中止する^
◎
Abort the script currently running in serviceWorker.
</li>
	<li>
%~sw の`開始-状態$ ~SET ~NULL
◎
Set serviceWorker’s start status to null.
</li>
</ol>

		</section>
		<section id="on-fetch-request-algorithm">
<h3 title="Handle Fetch">`~fetchを取扱う@</h3>

<p>
この~algoは、［
`~sw$文脈に手渡される，`~fetch$の取扱い
］用の入口である。
【`~HTTP~fetch$から利用される。】
◎
The Handle Fetch algorithm is the entry point for the fetch handling handed to the service worker context.
</p>

<ul>
	<li>
入力
⇒＃
%要請 — `要請$,
%~fetch~instance — 進行中の`~fetch$を表現する~fetch~algoの~instance
◎
Input
• request, a request
• ↓↓
</li>
	<li>
出力
⇒＃
%応答 — `応答$ 【または ~NULL 】
◎
Output
• response, a response
</li>
</ul>

<ol>
	<li>
%~fetchを取扱うのに失敗した ~LET ~F
◎
Let handleFetchFailed be false.
</li>
	<li>
%~enteredで応答する ~LET ~F
◎
Let respondWithEntered be false.
</li>
	<li>
%~eventは取消された ~LET ~F
◎
Let eventCanceled be false.
</li>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%登録 ~LET ~NULL
◎
Let registration be null.
</li>
	<li>
%~client ~LET %要請 の`~client$rq
◎
Let client be request’s client.
</li>
	<li>
%予約-済み~client ~LET %要請 の`予約-済み~client$rq
◎
Let reservedClient be request’s reserved client.
</li>
	<li>
%~preload応答~promise ~LET `新たな~promise$
◎
Let preloadResponse be a new promise.
◎
Let fetchInstance be the instance of the fetch algorithm representing the ongoing fetch.
</li>
	<li>
~Assert：
%要請 の`行先$rq ~NEQ  `serviceworker^l
◎
Assert: request’s destination is not "serviceworker".
</li>
	<li>
~IF［
%要請 は`~naviまたは下位資源いずれかになり得る要請$である
］
⇒
~RET ~NULL
◎
If request is a potential-navigation-or-subresource request, then:
• Return null.
</li>
	<li>
<p>
~IF［
%要請 は`非~下位資源~要請$である
］：
◎
Else if request is a non-subresource request, then:
</p>

<p class="note">注記：
~sw登録の~scope下にある非~下位資源~要請に対しては、それが~sw登録を利用するかどうかに関わらず，~app~cacheは完全に迂回される。
◎
Note: If the non-subresource request is under the scope of a service worker registration, application cache is completely bypassed regardless of whether the non-subresource request uses the service worker registration.
</p>
		<ol>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
				<ul>
					<li>
［
%予約-済み~client は`環境~設定群~obj$である
］~AND［
%予約-済み~client は`~secure文脈$でない
］
</li>
					<li>
［
%予約-済み~client は`環境~設定群~obj$でない
］~AND［
%要請 の`~URL$rq は`信用に価し得る~URL$でない
］
</li>
					<li>
［
%要請 は`~navi要請$である
］~AND［
それを誘発している`~navi$は、
<kbd>shift+reload</kbd> 等により起動された
【実際には何を意味する？ `952$issue】
］
</li>
				</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>

◎
If reservedClient is not null and is an environment settings object, then:
• If reservedClient is not a secure context, return null.
◎
Else:
• If request’s url is not a potentially trustworthy URL, return null.
◎
If request is a navigation request and the navigation triggering it was initiated with a shift+reload or equivalent, return null.
</li>
			<li>
%登録 ~SET `合致する~sw登録$( %要請 の`~URL$rq )
◎
Set registration to the result of running Match Service Worker Registration algorithm passing request’s url as the argument.
</li>
			<li>
~IF［
%登録 ~EQ ~NULL
］~OR［
%登録 にて`作動中の~worker$swr ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If registration is null or registration’s active worker is null, return null.
</li>
			<li>
~IF［
%要請 の`行先$rq ~NEQ `report$l
］
⇒
%予約-済み~client にて`作動中の~sw$enV ~SET %登録 にて`作動中の~worker$swr
◎
If request’s destination is not "report", set reservedClient’s active service worker to registration’s active worker.
</li>
			<li>
<p>
~IF［
次がすべて満たされる
］…
⇒＃
%要請 は`~navi要請$である,
%登録 の`~navi~preload可能化~flag$swr ~EQ ~T,
%要請 の`~method$rq ~EQ `GET^bl,
`fetch$et ~IN %登録 にて`作動中の~worker$swrが`取扱う~event型の集合$sw†
◎
If request is a navigation request, registration’s navigation preload enabled flag is set, request’s method is `GET`, and registration’s active worker's set of event types to handle contains fetch, then:
</p>

<p class="note">注記：
これらの条件が，最後のもの† を除いて満たされる場合、開発者の意図が明瞭でないので，~UAは~consoleに警告を示したいと望むかもしれない。
◎
Note: If the above is true except registration’s active worker's set of event types to handle does not contain fetch, then the user agent may wish to show a console warning, as the developer’s intent isn’t clear.
</p>

<p>
…ならば：
</p>

				<ol>
					<li>
%~preload要請 ~LET `要請を~cloneする$( %要請 )
◎
Let preloadRequest be the result of cloning the request request.
</li>
					<li>
%~preload要請~headerたち ~LET %~preload要請 の`~header~list$rq
◎
Let preloadRequestHeaders be preloadRequest’s header list.
</li>
					<li>
%~preload応答~obj ~LET 次のようにされた新たな `Response$I ~obj
⇒
`~Headers$Rs ~SET ［ `~guard$hl ~SET `immutable^l ］にされた新たな `Headers$I ~obj
◎
Let preloadResponseObject be a new Response object associated with a new Headers object whose guard is "immutable".
</li>
					<li>
%~preload要請~headerたち に`~headerを付加する$(
`Service-Worker-Navigation-Preload^h / %登録 の`~navi~preload~header値$swr
) 
◎
Append to preloadRequestHeaders a new header whose name is `Service-Worker-Navigation-Preload` and value is registration’s navigation preload header value.
</li>
					<li>
%~preload要請 の`~sw~mode$rq ~SET  `none^l
◎
Set preloadRequest’s service-workers mode to "none".
</li>
					<li>
<p>
この段は`並列的$に走らす
⇒
%~preload要請 を`~fetch$する：
◎
Run the following substeps in parallel:
• Fetch preloadRequest and let preloadFetchInstance be the instance of the fetch algorithm.
</p>

						<ul>
							<li>
<p>
`応答を処理する$ときは、所与の
( `応答$ %~navi~preload応答 )
に対し：
◎
To process response for navigationPreloadResponse, run these substeps:
</p>

								<ol>
									<li>
~IF［
%~navi~preload応答 の`種別$rs ~EQ `error^l 
］
⇒
`TypeError^E で %~preload応答~promise を`却下する$
◎
If navigationPreloadResponse’s type is "error", reject preloadResponse with a TypeError and terminate these substeps.
</li>
									<li>
<p>
~ELSE：
</p>
										<ol>
											<li>
%~preload応答~obj の`応答$Rs ~SET %~navi~preload応答
◎
Associate preloadResponseObject with navigationPreloadResponse.
</li>
											<li>
%~preload応答~obj で %~preload応答~promise を`解決する$
◎
Resolve preloadResponse with preloadResponseObject.
</li>
										</ol>
									</li>
								</ol>
							<li>
%~fetch~instance が`終了された$ときは
⇒
この段で走らせた~fetch~instance も`終了させる$( `中止する^i )
◎
If fetchInstance is terminated, then terminate preloadFetchInstance with the aborted flag set.
</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`undefined^jv で %~preload応答~promise を`解決する$
◎
Else, resolve preloadResponse with undefined.
</li>
		</ol>

<p class="note">注記：
この時点から、`~sw~client$は，その`作動中の~sw$enVを`包含している~sw登録$swを`利用-$するのを開始する。
◎
Note: From this point, the service worker client starts to use its active service worker’s containing service worker registration.
</p>
	</li>
	<li>
<p>
~ELIF［
%要請 は`下位資源~要請$である
］：
</p>
		<ol>
			<li>
~IF［
%~client にて`作動中の~sw$enV ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
			<li>
%登録 ~SET %~client にて`作動中の~sw$enV を`包含している~sw登録$sw
</li>
		</ol>
◎
Else if request is a subresource request, then:
• If client’s active service worker is non-null, set registration to client’s active service worker’s containing service worker registration.
• Else, return null.
</li>
	<li>
%作動中の~worker ~LET %登録 にて`作動中の~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>

	<li>
%~soft更新すべき ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%要請 は`非~下位資源~要請$である
］~OR［［
%要請 は`下位資源~要請$である
］~AND［
%登録 は`非新鮮$である
］］
◎
Let shouldSoftUpdate be true if any of the following are true, and false otherwise:
• request is a non-subresource request.
• request is a subresource request and registration is stale.
</li>
	<li>
<p>
~IF［
`~eventを飛ばすべきか$( `fetch^l, %作動中の~worker ) ~EQ ~T
］：
◎
If the result of running the Should Skip Event algorithm with "fetch" and activeWorker is true, then:
</p>
		<ol>
			<li>
~IF［
%~soft更新すべき ~EQ ~T
］
⇒
次を`並列的$に走らす
⇒
`~soft更新する$( %登録 )
◎
If shouldSoftUpdate is true, then in parallel run the Soft Update algorithm with registration.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
~IF［
%作動中の~worker の`状態$sw ~EQ `activating^l
］
⇒
%作動中の~worker の`状態$sw ~EQ `activated^l になるまで待機する
◎
If activeWorker’s state is "activating", wait for activeWorker’s state to become "activated".
</li>
	<li>
~IF［
`~swを走らす$( %作動中の~worker ) ~EQ `失敗^i
］
⇒
%~fetchを取扱うのに失敗した ~SET ~T
◎
If the result of running the Run Service Worker algorithm with activeWorker is failure, then set handleFetchFailed to true.
</li>
	<li>
<p>
~ELSE：
◎
Else＼
</p>
		<ol>
			<li>
<p>
%~task ~LET `~taskを~queueする$( `~fetchを取扱う~task源$, 次の下位手続き, %作動中の~worker の`~event-loop$ )：
◎
queue a task task to run the following substeps:
</p>
				<ol>
					<li>
%~event ~LET `~eventを作成する$( `FetchEvent$I )
◎
Let e be the result of creating an event with FetchEvent.
</li>
					<li>
%要請~obj ~LET 次のようにされた 新たな `Request$I ~obj
⇒＃
`要請$Rq ~SET %要請,
`~Headers$Rq ~SET ［ `~guard$hl ~SET `immutable^l ］にされた新たな `Headers$I ~obj
◎
Let requestObject be a new Request object associated with request and a new associated Headers object whose guard is "immutable".
</li>
					<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$n 属性 ~SET `fetch$et,
`cancelable$n 属性 ~SET ~T,
`FetchEvent^I1`request$m1 属性 ~SET %要請~obj,
`preloadResponse$m1 ~SET %~preload応答~promise,
`clientId$m1 属性 ~SET %~client の`~id$enV,
`resultingClientId$m1 属性 ~SET 空~文字列,
`replacesClientId$m1 属性 ~SET 空~文字列
◎
Initialize e’s type attribute to fetch.
◎
Initialize e’s cancelable attribute to true.
◎
Initialize e’s request attribute to requestObject.
◎
Initialize e’s preloadResponse to preloadResponse.
◎
Initialize e’s clientId attribute to client’s id.
</li>
					<li>
~IF［
%要請 は`非~下位資源~要請$である
］~AND［
%要請 の`行先$rq ~NEQ `report$l
］
⇒
%~event の `resultingClientId$m 属性 ~SET %予約-済み~client の`~id$enV
◎
If request is a non-subresource request and request’s destination is not "report", initialize e’s resultingClientId attribute to reservedClient’s id, and to the empty string otherwise.
</li>
					<li>
~IF［
%要請 は`~navi要請$である
］
⇒
%~event の `replacesClientId$m 属性 ~SET %要請 の`置換する~client~id$rq
◎
If request is a navigation request, initialize e’s replacesClientId attribute to request’s replaces client id, and to the empty string otherwise.
</li>
					<li>
%作動中の~worker の`大域~obj$swに向けて，
%~event を`配送する$
◎
Dispatch e at activeWorker’s global object.
</li>
					<li>
`~sw延長-済み~event集合を更新する$( %作動中の~worker, %~event )
◎
Invoke Update Service Worker Extended Events Set with activeWorker and e.
</li>
					<li>
~IF［
%~event の`~enteredで応答する~flag$FE ~EQ ~T
］
⇒
%~enteredで応答する ~SET ~T
◎
If e’s respond-with entered flag is set, set respondWithEntered to true.
</li>
					<li>
<p>
~IF［
%~event の`応答するまで待機-中~flag$FE ~EQ ~T
］：
◎
If e’s wait to respond flag is set, then:
</p>
						<ol>
							<li>
次が満たされるまで待機する
⇒
%~event の`応答するまで待機-中~flag$FE ~EQ ~F
◎
Wait until e’s wait to respond flag is unset.
</li>
							<li>
~IF［
%~event の`~errorで応答する~flag$FE ~EQ ~T
］
⇒
%~fetchを取扱うのに失敗した ~SET ~T
◎
If e’s respond-with error flag is set, set handleFetchFailed to true.
</li>
							<li>
~ELSE
⇒
%応答 ~SET %~event の`応答になり得る$FE
◎
Else, set response to e’s potential response.
</li>
						</ol>
					</li>
					<li>
~IF［
%~event の`取消d~flag$ ~EQ ~T
］
⇒
%~eventは取消された ~SET ~T
◎
If e’s canceled flag is set, set eventCanceled to true.
</li>
					<li>
~IF［
%~fetch~instance は`終了された$
］
⇒
`~taskを~queueする$( `~fetchを取扱う~task源$, 次の手続き, %作動中の~worker の`~event-loop$ )
⇒
`中止-を通達する$( %要請~obj の `signal$n )
◎
If fetchInstance is terminated, then queue a task to signal abort on requestObject’s signal.
</li>
				</ol>

<p>
%~task が破棄されたときは
⇒
%~fetchを取扱うのに失敗した ~SET ~T
◎
If task is discarded, set handleFetchFailed to true.
◎
↑
The task must use activeWorker’s event loop and the handle fetch task source.
</p>
			</li>
			<li>
%~task が実行されるか［
%~fetchを取扱うのに失敗した ~EQ ~T
］になるまで待機する
◎
Wait for task to have executed or for handleFetchFailed to be true.
</li>
		</ol>
	</li>
	<li>
~IF［
%~soft更新すべき ~EQ ~T
］
⇒
次を`並列的$に走らす
⇒
`~soft更新する$( %登録 )
◎
If shouldSoftUpdate is true, then in parallel run the Soft Update algorithm with registration.
</li>
	<li>
~IF［
%~enteredで応答する ~EQ ~F
］
⇒
~RET ［
%~eventは取消された ~EQ ~T ならば`~network~error$ ／
~ELSE_ ~NULL
］
⇒
◎
If respondWithEntered is false, then return a network error if eventCanceled is true and null otherwise.
</li>
	<li>
~IF［
%~fetchを取扱うのに失敗した ~EQ ~T
］
⇒
~RET `~network~error$
◎
If handleFetchFailed is true, then return a network error.
</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

		</section>
		<section id="should-skip-event-algorithm">
<h3 title="Should Skip Event">`~eventを飛ばすべきか@</h3>

<ul>
	<li>
入力
⇒＃
%~event名 — 文字列,
%~sw — `~sw$
◎
Input
• eventName, a string
• serviceWorker, a service worker
</li>
	<li>
出力
⇒＃
真偽値
◎
Output
• a boolean
</li>
</ul>

<p class="note">注記：
不必要な遅延を避けるため，この仕様は、所与の %~event型 に関して次が決定可能であるならば，
%~event型 の~event配送-は飛ばすことを許可する
⇒
~script実行の最初期の間に，当の~swの大域~objに追加された［
%~event型 用の~event~listener
］は無い
◎
Note: To avoid unnecessary delays, this specification permits skipping event dispatch when no event listeners for the event have been deterministically added in the service worker’s global during the very first script execution.
</p>

<ol>
	<li>
~IF［
%~event名 ~IN %~sw の`取扱う~event型の集合$sw
］
⇒
~RET ~F
◎
↓</li>
	<li>
~UAは次をしても`ヨイ^em
⇒
~RET ~T
◎
If serviceWorker’s set of event types to handle does not contain eventName, then the user agent may return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

		</section>
		<section id="fire-functional-event-algorithm">
<h3 title="Fire Functional Event">`機能的~eventを発火する@</h3>

<ul>
	<li>
入力
⇒＃
%~event名 — 文字列,
%~event構築子 — `ExtendableEvent$I を拡張する~event構築子,
%登録 — `~sw登録$,
%初期化 — %~event構築子 で構築される~event用の~propを初期化する~~指示書き（省略時は ε ）,
%配送-後~手続き — 構築された~eventを引数に`作動中の~worker$swrの~event-loopを走らす手続き
◎
Input
• eventName, a string
• eventConstructor, an event constructor that extends ExtendableEvent
• registration, a service worker registration
• initialization, optional property initialization for event, constructed from eventConstructor
• postDispatchSteps, optional steps to run on the active worker's event loop, with dispatchedEvent set to the instance of eventConstructor that was dispatched.
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
~Assert：
%登録 にて`作動中の~worker$swr ~NEQ ~NULL
◎
Assert: registration’s active worker is not null.
</li>
	<li>
%作動中の~worker ~LET %登録 にて`作動中の~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
<p>
`(A)^i：
</p>
		<ol>
			<li>
~IF［
`~eventを飛ばすべきか$( %~event名, %作動中の~worker ) ~EQ ~T
］
⇒
~BREAK `(A)^i
◎
If the result of running Should Skip Event with eventName and activeWorker is true, then:
• If registration is stale, then in parallel run the Soft Update algorithm with registration.
• Return.
</li>
			<li>
~IF［
%作動中の~worker の`状態$sw ~EQ `activating^l
］
⇒
次が満たされるまで待機する
⇒
%作動中の~worker の`状態$sw ~EQ `activated^l
◎
If activeWorker’s state is "activating", wait for activeWorker’s state to become "activated".
</li>
			<li>
<p>
~IF［
`~swを走らす$( %作動中の~worker ) ~EQ `失敗^i
］
⇒
~BREAK `(A)^i
◎
If the result of running the Run Service Worker algorithm with activeWorker is failure, then:
• If registration is stale, then in parallel run the Soft Update algorithm with registration.
• Return.
</li>
			<li>
<p>
%~task ~LET `~taskを~queueする$( `機能的~eventを取扱う~task源$, 次の手続き, %作動中の~worker の`~event-loop$ )：
◎
Queue a task task to run these substeps:
</p>
				<ol>
					<li>
%~event ~LET `~eventを作成する$( %~event構築子, %作動中の~worker の`大域~obj$swに`関連な~realm$ )
◎
Let event be the result of creating an event with eventConstructor and the relevant realm of activeWorker’s global object.
</li>
					<li>
~IF［
%初期化 ~NEQ ε
］
⇒
%初期化 に従って %~event を初期化する
◎
If initialization is not null, then initialize event with initialization.
</li>
					<li>
%作動中の~worker の`大域~obj$swに向けて， %~event を`配送する$ 
◎
Dispatch event on activeWorker’s global object.
</li>
					<li>
`~sw延長-済み~event集合を更新する$( %作動中の~worker, %~event )
◎
Invoke Update Service Worker Extended Events Set with activeWorker and event.
</li>
					<li>
~IF［
%配送-後~手続き ~NEQ ε
］
⇒
%~event を渡して， %配送-後~手続き を走らす
◎
If postDispatchSteps is not null, then run postDispatchSteps passing event as dispatchedEvent.
</li>
				</ol>
			</li>
			<li>
%~task が実行されるか破棄されるまで待機する
◎
↑The task must use activeWorker’s event loop and the handle functional event task source.
◎
Wait for task to have executed or been discarded.
</li>
		</ol>
	</li>
	<li>
~IF［
%登録 は`非新鮮$である
］
⇒
次を`並列的$に走らす
⇒
`~soft更新する$( %登録 )
◎
If registration is stale, then in parallel run the Soft Update algorithm with registration.
</li>
</ol>

<div class="example">

<p>
特定0の %~sw登録 に向けて，（ `AmazingThingEvent^I 型の） `amazingthing^et ~eventを
— その各種~propを初期化した上で —
発火するときの注釈文は、次のようになる：
◎
To fire an "amazingthing" event (which is of type AmazingThingEvent) on a particular serviceWorkerRegistration, and initialize the event object’s properties, the prose would be:
</p>

<ol>
	<li>
%~sw登録 に向けて，名前 `amazingthing^et の`機能的~eventを発火する$
— `AmazingThingEvent^I を利用し，次のように初期化して
⇒＃
`ある~prop名^i ~SET 何らかの値,
`別の~prop名^i ~SET 別の値
◎
Fire Functional Event "amazingthing" using AmazingThingEvent on serviceWorkerRegistration with the following properties:
◎
propertyName
• value
◎
anotherPropertyName
• anotherValue
</li>
	<li>
%配送した~event ~LET 前~段にて配送した~event
◎
Then run the following steps with dispatchedEvent:
</li>
	<li>
%配送した~event を用いて，当の~swの~event-loop上で行う必要がある何かをする
◎
Do whatever you need to with dispatchedEvent on the service worker’s event loop.
</li>
</ol>

<p>
初期化~手続き, 配送-後の手続きは任意選択~であることに注意。
必要なければ、注釈文は次のようになる：
◎
Note that the initialization steps and post-dispatch steps are optional. If they aren’t needed, the prose would be:
</p>

<ol>
	<li>
%~sw登録 に向けて，名前 `whatever^et の`機能的~eventを発火する$
— `ExtendableEvent$I を利用して
◎
Fire Functional Event "whatever" using ExtendableEvent on serviceWorkerRegistration.
</li>
</ol>

</div>

		</section>
		<section id="on-client-unload-algorithm">
<h3 title="Handle Service Worker Client Unload">`~sw~clientを~unloadする@</h3>

<p>
~UAは、［
文書を`~unload$doc ／ ~swを`終了-$
］するとき，それにより`~sw~client$を~unloadするときは、この手続きを走らすモノトスル。
◎
The user agent must run these steps when a service worker client unloads by unloading or terminating.
</p>

<ul>
	<li>
入力
⇒＃
%~client — `~sw~client$
◎
Input
• client, a service worker client
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<p>
この手続きは不可分的に走らすとする：
◎
Run the following steps atomically.
</p>

<ol>
	<li>
%登録 ~LET %~client が`利用して$いる`~sw登録$
◎
Let registration be the service worker registration used by client.
</li>
	<li>
~IF［
%登録 ~EQ ~NULL
］
⇒
~RET
◎
If registration is null, abort these steps.
</li>
	<li>
~IF［
%~client 以外に， %登録 を`利用して$いる`~sw~client$はある
］
⇒
~RET
◎
If any other service worker client is using registration, abort these steps.
</li>
	<li>
~IF［
%登録 は`未登録にされて$いる
］
⇒
`登録を消去しようと試行する$( %登録 )
◎
If registration is unregistered, invoke Try Clear Registration with registration.
</li>
	<li>
`作動化しようと試行する$( %登録 )
◎
Invoke Try Activate with registration.
</li>
</ol>

		</section>
		<section id="on-user-agent-shutdown-algorithm">
<h3 title="Handle User Agent Shutdown">`~UA~shutdownを取扱う@</h3>

<ul>
	<li>
入力
⇒＃
~none
◎
Input
• None
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
<p>
`~scopeから登録への~map$を成す
~EACH( %~scope → %登録 )
に対し：
◎
For each scope → registration of scope to registration map:
</p>
		<ol>
			<li>
<p>
~IF［
%登録 にて`~install中の~worker$swr %~install中の~worker ~NEQ ~NULL
］：
◎
If registration’s installing worker installingWorker is not null, then:
</p>
				<ol>
					<li>
~IF［
%登録 にて`待機-中の~worker$swr ~EQ ~NULL
］~AND［
%登録 にて`作動中の~worker$swr ~EQ ~NULL
］
⇒
`登録を消去する$( %登録 )
◎
If registration’s waiting worker is null and registration’s active worker is null, invoke Clear Registration with registration and continue to the next iteration of the loop.
</li>
					<li>
~ELSE
⇒
%~install中の~worker ~SET ~NULL 【意図不明な段】
◎
Else, set installingWorker to null.
</li>
				</ol>
			</li>
			<li>
~IF［
%登録 にて`待機-中の~worker$swr ~NEQ ~NULL
］
⇒
次を`並列的$に走らす
⇒
`作動化する$( %登録 )
◎
If registration’s waiting worker is not null, run the following substep in parallel:
• Invoke Activate with registration.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="update-service-worker-extended-events-set-algorithm">
<h3 title="Update Service Worker Extended Events Set">`~sw延長-済み~event集合を更新する@</h3>

<ul>
	<li>
入力
⇒＃
%~worker — `~sw$,
%~event — `~event$
◎
Input
• worker, a service worker
• event, an event
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
~Assert：
%~event の`配送-~flag$ ~EQ ~F
◎
Assert: event’s dispatch flag is unset.
</li>
	<li>
<p>
%~worker の`延長-済み~event集合$swを成す
~EACH( %~item )
に対し
⇒
~IF［
%~item は`作動中$eXでない
］
⇒
%~worker の`延長-済み~event集合$swから %~item を`除去する$
◎
For each item of worker’s set of extended events:
• If item is not active, remove item from worker’s set of extended events.
</li>
	<li>
~IF［
%~event は`作動中$eXである
］
⇒
%~worker の`延長-済み~event集合$swに %~event を`付加する$set
◎
If event is active, append event to worker’s set of extended events.
</li>
</ol>

		</section>
		<section id="unregister-algorithm">
<h3 title="Unregister">`未登録にする@</h3>

<ul>
	<li>
入力
⇒＃
%~job — `~job$
◎
Input
• job, a job
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
<p>
~IF［
%~job の`~scope~url$jobの`生成元$url
~NEQ`生成元$sub
%~job の`~client$jobの`生成元$cl【！`生成元$enV】
］：
◎
If the origin of job’s scope url is not job’s client's origin, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
◎
Invoke Reject Job Promise with job and "SecurityError" DOMException.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%登録 ~LET `登録を取得する$( %~job の`~scope~url$job )
◎
Let registration be the result of running Get Registration algorithm passing job’s scope url as the argument.
</li>
	<li>
<p>
~IF［
%登録 ~EQ ~NULL
］：
◎
If registration is null, then:
</p>
		<ol>
			<li>
`~job~promiseを解決する$( %~job, ~F )
◎
Invoke Resolve Job Promise with job and false.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
`~scopeから登録への~map$[ %~job の`~scope~url$job ] ~SET ε
【！`除去する$map】
◎
Remove scope to registration map[job’s scope url].
</li>
	<li>
`~job~promiseを解決する$( %~job, ~T )
◎
Invoke Resolve Job Promise with job and true.
</li>
	<li>
<p>
`登録を消去しようと試行する$( %登録 )
◎
Invoke Try Clear Registration with registration.
</p>

<p class="note">注記：
この`登録を消去しようと試行する$() が，`登録を消去する$() を誘発しなかった場合、次に該当するときに再度，誘発するよう試行することになる
⇒＃
%登録 を`利用して$いる最後の~clientが`~unload$されたとき ／
%登録 の~sw用の`~lifetimeを延長する~promiseたち$が決着したとき
◎
Note: If Try Clear Registration does not trigger Clear Registration here, Clear Registration is tried again when the last client using the registration is unloaded or the extend lifetime promises for the registration’s service workers settle.
</p>
	</li>
	<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job.
</li>
</ol>

		</section>
		<section id="set-registration-algorithm">
<h3 title="Set Registration">`登録を設定する@</h3>

<ul>
	<li>
入力
⇒＃
%~scope — `~URL$,
%~cacheを介する更新 — `~cacheを介する更新~mode$swr
◎
Input
• scope, a URL
• updateViaCache, an update via cache mode
</li>
	<li>
出力
⇒＃
%登録 — `~sw登録$
◎
Output
• registration, a service worker registration
</li>
</ul>

<p>
この手続きは不可分的に走らすとする：
◎
Run the following steps atomically.
</p>

<ol>
	<li>
%~scope文字列 ~LET 
`~URLを直列化する$( %~scope, `素片は除外する^i )
◎
Let scopeString be serialized scope with the exclude fragment flag set.
</li>
	<li>
%登録 ~LET 新たな`~sw登録$
◎
Let registration be a new service worker registration whose scope url is set to scope and update via cache mode is set to updateViaCache.
</li>
	<li>
%登録 の ( `~scope~url$swr, `~cacheを介する更新~mode$swr ) ~SET ( %~scope, %~cacheを介する更新 )
◎
↑</li>
	<li>
`~scopeから登録への~map$[ %~scope文字列 ] ~SET %登録
◎
Set scope to registration map[scopeString] to registration.
</li>
	<li>
~RET %登録
◎
Return registration.
</li>
</ol>

		</section>
		<section id="clear-registration-algorithm">
<h3 title="Clear Registration">`登録を消去する@</h3>

<ul>
	<li>
入力
⇒＃
%登録 — `~sw登録$
◎
Input
• registration, a service worker registration
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<p>
この手続きは不可分的に走らすとする：
◎
Run the following steps atomically.
</p>

<ol>
	<li>
<p>
次の表の
~EACH( 行 )
に対し，順に：
</p>

<table><tbody>

<tr><td>%登録 にて`~install中の~worker$swr
<td>`installing^l

<tr><td>%登録 にて`待機-中の~worker$swr
<td>`waiting^l

<tr><td>%登録 にて`作動中の~worker$swr
<td>`active^l

</tbody></table>

		<ol>
			<li>
( %~worker, %~target ) ~LET 行の ( 1 列目, 2 列目 ) に挙げる値
</li>
			<li>
~IF［
%~worker ~EQ ~NULL
］
⇒
~CONTINUE
</li>
			<li>
`~swを終了する$( %~worker )
</li>
			<li>
`~workerの状態を更新する$( %~worker, `redundant^l )
</li>
			<li>
`登録の状態を更新する$( %登録, %~target, ~NULL )
</li>
		</ol>

◎
If registration’s installing worker is not null, then:
• Terminate registration’s installing worker.
• Run the Update Worker State algorithm passing registration’s installing worker and "redundant" as the arguments.
• Run the Update Registration State algorithm passing registration, "installing" and null as the arguments.
◎
If registration’s waiting worker is not null, then:
• Terminate registration’s waiting worker.
• Run the Update Worker State algorithm passing registration’s waiting worker and "redundant" as the arguments.
• Run the Update Registration State algorithm passing registration, "waiting" and null as the arguments.
◎
If registration’s active worker is not null, then:
• Terminate registration’s active worker.
• Run the Update Worker State algorithm passing registration’s active worker and "redundant" as the arguments.
• Run the Update Registration State algorithm passing registration, "active" and null as the arguments.
</li>
</ol>

		</section>
		<section id="try-clear-registration-algorithm">
<h3 title="Try Clear Registration">`登録を消去しようと試行する@</h3>

<ul>
	<li>
入力
⇒＃
%登録 — `~sw登録$
◎
Input
• registration, a service worker registration
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
<p>
~IF［
次のすべてが満たされる
］…：
</p>

<ul ><li>%登録 を`利用して$いる`~sw~client$はない
</li><li>`~swには処理待ち~eventは無い$( %登録 にて`~install中の~worker$swr ) ~EQ ~T
</li><li>`~swには処理待ち~eventは無い$( %登録 にて`待機-中の~worker$swr ) ~EQ ~T
</li><li>`~swには処理待ち~eventは無い$( %登録 にて`作動中の~worker$swr ) ~EQ ~T
</li></ul>

<p>
…ならば
⇒
`登録を消去する$( %登録 )
</p>

◎
Invoke Clear Registration with registration if no service worker client is using registration and all of the following conditions are true:
• registration’s installing worker is null or the result of running Service Worker Has No Pending Events with registration’s installing worker is true.
• registration’s waiting worker is null or the result of running Service Worker Has No Pending Events with registration’s waiting worker is true.
• registration’s active worker is null or the result of running Service Worker Has No Pending Events with registration’s active worker is true.
</li>
</ol>

		</section>
		<section id="update-registration-state-algorithm">
<h3 title="Update Registration State">`登録の状態を更新する@</h3>

`ServiceWorkerRegistration^I0

<ul>
	<li>
入力
⇒＃
%登録 — `~sw登録$,
%~target ~IN { `installing^l , `waiting^l , `active^l }
%~source — `~sw$ ／ ~NULL
◎
Input
• registration, a service worker registration
• target, a string (one of "installing", "waiting", and "active")
• source, a service worker or null
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
%登録~objたち ~LET %登録 を表現している すべての `ServiceWorkerRegistration$I ~objからなる集合
【順序は指定されていない】
◎
Let registrationObjects be an array containing all the ServiceWorkerRegistration objects associated with registration.
</li>
<!-- 
配列 → 集合
結付けられている → 表現している
包含している → からなる
-->
	<li>
<p>
%~target に応じて：
</p>
		<dl class="switch">
			<dt>
`installing^l
◎
If target is "installing", then:
</dt>
			<dd>
				<ol>
					<li>
%登録 にて`~install中の~worker$swr ~SET %~source
◎
Set registration’s installing worker to source.
</li>
					<li>
%登録~objたち を成す
~EACH( %登録~obj )
に対し
⇒
次を走らす`~taskを~queueする$†
⇒
%登録~obj の `installing$m 属性 ~SET ［
%登録 の`~install中の~worker$swr ~EQ ~NULL ならば ~NULL ／
~ELSE_ `~sw~objを取得する$( %登録 の`~install中の~worker$swr, %登録~obj に`関連な設定群~obj$ )
］
◎
For each registrationObject in registrationObjects:
• Queue a task to set the installing attribute of registrationObject to null if registration’s installing worker is null, or the result of getting the service worker object that represents registration’s installing worker in registrationObject’s relevant settings object.
</li>
				</ol>
			</dd>

			<dt>
`waiting^l
◎
Else if target is "waiting", then:
</dt>
			<dd>
				<ol>
					<li>
%登録 にて`待機-中の~worker$swr ~SET %~source
◎
Set registration’s waiting worker to source.
</li>
					<li>
%登録~objたち を成す
~EACH( %登録~obj )
に対し
⇒
次を走らす`~taskを~queueする$†
⇒
%登録~obj の `waiting$m 属性 ~SET ［
%登録 の`待機-中の~worker$swr ~EQ ~NULL ならば ~NULL ／
~ELSE_ `~sw~objを取得する$( %登録 の`待機-中の~worker$swr, %登録~obj に`関連な設定群~obj$ )
］
◎
For each registrationObject in registrationObjects:
• Queue a task to set the waiting attribute of registrationObject to null if registration’s waiting worker is null, or the result of getting the service worker object that represents registration’s waiting worker in registrationObject’s relevant settings object.
</li>
				</ol>
			</dd>

			<dt>
`active^l
◎
Else if target is "active", then:
</dt>
			<dd>
				<ol>
					<li>
%登録 にて`作動中の~worker$swr ~SET %~source
◎
Set registration’s active worker to source.
</li>
					<li>
%登録~objたち を成す
~EACH( %登録~obj )
に対し
⇒
次を走らす`~taskを~queueする$†
⇒
%登録~obj の `active$m 属性 ~SET ［
%登録 の`作動中の~worker$swr ~EQ ~NULL ならば ~NULL ／
~ELSE_ `~sw~objを取得する$( %登録 の`作動中の~worker$swr, %登録~obj に`関連な設定群~obj$ )
］
◎
For each registrationObject in registrationObjects:
• Queue a task to set the active attribute of registrationObject to null if registration’s active worker is null, or the result of getting the service worker object that represents registration’s active worker in registrationObject’s relevant settings object.
</li>
				</ol>
			</dd>
		</dl>
<p>†
これらの`~task$は、`~DOM操作~task源$から［
%登録~obj に`関連な設定群~obj$の`担当の~event-loop$enV
］の中へ~queueするモノトスル。
◎
The task must use registrationObject’s relevant settings object's responsible event loop and the DOM manipulation task source.
</p>
	</li>
</ol>

		</section>
		<section id="update-state-algorithm">
<h3 title="Update Worker State">`~workerの状態を更新する@</h3>

<ul>
	<li>
入力
⇒＃
%~worker — `~sw$,
%状態 — `~sw$の`状態$sw
◎
Input
• worker, a service worker
• state, a service worker state
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
<p>
~Assert：
%状態 ~NEQ `parsed^l
◎
Assert: state is not "parsed".
</p>

<p class="note">注記：
`parsed^l は初期~状態である。
この状態にある`~sw$が更新されることは、決してない。
◎
Note: "parsed" is the initial state. A service worker is never updated to this state.
</p>
	</li>
	<li>
%~worker の`状態$sw ~SET %状態
◎
Set worker’s state to state.
</li>
	<li>
%設定群~objたち ~LET 次を満たす`環境~設定群~obj$すべてからなる集合
⇒
`生成元$enV ~EQ`生成元$sub %~worker の`~script~url$swの`生成元$url
◎
Let settingsObjects be all environment settings objects whose origin is worker’s script url's origin.
</li>
	<li>
<p>
%設定群~objたち を成す
~EACH( %設定群~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %設定群~obj の`担当の~event-loop$enV )：
◎
For each settingsObject of settingsObjects, queue a task on settingsObject’s responsible event loop in the DOM manipulation task source to run the following steps:
</p>
		<ol>
			<li>
%~obj~map ~LET %設定群~obj の`~sw~obj~map$enV
◎
Let objectMap be settingsObject’s service worker object map.
</li>
			<li>
%~worker~obj ~LET %~obj~map[ %~worker ]
◎
↓</li>
			<li>
~IF［
%~worker~obj ~EQ ε
］
⇒
~RET
◎
If objectMap[worker] does not exist, then abort these steps.
◎
Let workerObj be objectMap[worker].
</li>
			<li>
%~worker~obj の `ServiceWorker^I1`state$m1 ~SET %状態
◎
Set workerObj’s state to state.
</li>
			<li>
%~worker~obj に向けて，名前 `statechange$et の`~eventを発火する$
◎
Fire an event named statechange at workerObject.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="notify-controller-change-algorithm">
<h3 title="Notify Controller Change">`制御器の変化を通知する@</h3>

<ul>
	<li>
入力
⇒＃
%~client — `~sw~client$
◎
Input
• client, a service worker client
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
~Assert：
%~client ~NEQ ~NULL
◎
Assert: client is not null.
</li>
	<li>
~IF［
%~client は`環境~設定群~obj$である
］
⇒
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~client の`担当の~event-loop$enV )
⇒
次を満たす `ServiceWorkerContainer$I ~objに向けて，名前 `controllerchange$et の`~eventを発火する$
⇒
その`~sw~client$SWC ~EQ %~client
◎
If client is an environment settings object, queue a task to fire an event named controllerchange at the ServiceWorkerContainer object that client is associated with.
◎
↑The task must use client’s responsible event loop and the DOM manipulation task source.
</li>
</ol>

		</section>
		<section id="scope-match-algorithm">
<h3 title="Match Service Worker Registration">`合致する~sw登録@</h3>

<ul>
	<li>
入力
⇒＃
%~client~URL — `~URL$
◎
Input
• clientURL, a URL
</li>
	<li>
出力
⇒＃
`~sw登録$【または ~NULL】
◎
Output
• A service worker registration
</li>
</ul>

<p>
この手続きは不可分的に走らすとする：
◎
Run the following steps atomically.
</p>

<ol>
	<li>
%~client~URL文字列 ~LET
`~URLを直列化する$(  %~client~URL )
◎
Let clientURLString be serialized clientURL.
◎
↓Let matchingScopeString be the empty string.
</li>
	<li>
%~scope文字列~集合 ~LET 
`~key~listを取得する$( `~scopeから登録への~map$ )
◎
Let scopeStringSet be the result of getting the keys from scope to registration map.
</li>
	<li>
<p>
%合致している~scope文字列 ~LET %~scope文字列~集合 内に次を満たすものが［
在るならば，それらのうち最長の文字列 ／
無いならば，空~文字列
］
⇒
%~client~URL文字列 の`符号単位~接頭辞$である【！starts with】
◎
Set matchingScopeString to the longest value in scopeStringSet which the value of clientURLString starts with, if it exists.
</p>

<p class="note">注記：
この段で合致している~URL文字列は、接頭辞に基づき，~path構造は~~加味されない。
例えば~client~URL文字列
`https://example.com/prefix-of/resource.html^l
は、
`https://example.com/prefix^l
を伴う~scope用の登録に合致することになる。
このような~URL文字列の比較は、同一-生成元~security用には安全である
— ［
~HTTP／~HTTPS
］`~URLを直列化する$ときには、生成元~~成分は，常に末尾に~slashを伴うように直列化されるので。
◎
Note: The URL string matching in this step is prefix-based rather than path-structural. E.g. a client URL string with "https://example.com/prefix-of/resource.html" will match a registration for a scope with "https://example.com/prefix". The URL string comparison is safe for the same-origin security as HTTP(S) URLs are always serialized with a trailing slash at the end of the origin part of the URLs.
</p>
	</li>
	<li>
%合致している~scope ~LET ~NULL
◎
Let matchingScope be null.
</li>
	<li>
<p>
~IF［
%合致している~scope文字列 ~NEQ 空~文字列
］：
◎
If matchingScopeString is not the empty string, then:
</p>
		<ol>
			<li>
%合致している~scope ~SET `~URL構文解析する$( %合致している~scope文字列 )
◎
Set matchingScope to the result of parsing matchingScopeString.
</li>
			<li>
~Assert：
%合致している~scope の`生成元$url
~EQ`生成元$sub
%~client~URL の`生成元$url
◎
Assert: matchingScope’s origin and clientURL’s origin are same origin.
</li>
		</ol>
	</li>
	<li>
~RET `登録を取得する$( %合致している~scope )
◎
Return the result of running Get Registration algorithm passing matchingScope as the argument.
</li>
</ol>

		</section>
		<section id="get-registration-algorithm">
<h3 title="Get Registration">`登録を取得する@</h3>

<ul>
	<li>
入力
⇒＃
%~scope — `~URL$【または ~NULL】
◎
Input
• scope, a URL
</li>
	<li>
出力
⇒＃
`~sw登録$【または ~NULL】
◎
Output
• A service worker registration
</li>
</ul>

<p>
この手続きは不可分的に走らすとする：
◎
Run the following steps atomically.
</p>

<ol>
	<li>
%~scope文字列 ~LET 空~文字列
◎
Let scopeString be the empty string.
</li>
	<li>
~IF［
%~scope ~NEQ ~NULL
］
⇒
%~scope文字列 ~SET
`~URLを直列化する$( %~scope, `素片は除外する^i )
◎
If scope is not null, set scopeString to serialized scope with the exclude fragment flag set.
</li>
	<li>
%登録 ~LET `~scopeから登録への~map$[ %~scope文字列 ]
◎
For each key → value of scope to registration map:
• If scopeString matches key, then return value.
</li>
	<li>
~RET ［
%登録 ~NEQ ε ならば %登録 ／
~ELSE_ ~NULL
］
◎
Return null.
</li>
</ol>

		</section>
		<section id="get-newest-worker-algorithm">
<h3 title="Get Newest Worker">`最新の~workerを取得する@</h3>

<ul>
	<li>
入力
⇒＃
%登録 — `~sw登録$
◎
Input
• registration, a service worker registration
</li>
	<li>
出力
⇒＃
`~sw$【または ~NULL】
◎
Output
• newestWorker, a service worker
</li>
</ul>

<p>
この手続きは不可分的に走らすとする：
◎
Run the following steps atomically.
• Let newestWorker be null.
</p>

<ol>
	<li>
~IF［
%登録 にて`~install中の~worker$swr ~NEQ ~NULL
］
⇒
~RET %登録 にて`~install中の~worker$swr
◎
If registration’s installing worker is not null, set newestWorker to registration’s installing worker.
</li>
	<li>
~IF［
%登録 にて`待機-中の~worker$swr ~NEQ ~NULL
］
⇒
~RET %登録 にて`待機-中の~worker$swr
◎
Else if registration’s waiting worker is not null, set newestWorker to registration’s waiting worker.
</li>
	<li>
~IF［
%登録 にて`作動中の~worker$swr ~NEQ ~NULL
］
⇒
~RET %登録 にて`作動中の~worker$swr
◎
Else if registration’s active worker is not null, set newestWorker to registration’s active worker.
</li>
	<li>
~RET ~NULL
◎
Return newestWorker.
</li>
</ol>

		</section>
		<section id="service-worker-has-no-pending-events-algorithm">
<h3 title="Service Worker Has No Pending Events">`~swには処理待ち~eventは無い@</h3>

<ul>
	<li>
入力
⇒＃
%~worker  — `~sw$または~NULL,
【この ~NULL と~algoの最初の段は、他所の記述を簡潔にするための訳者による追加。】
◎
Input
• worker, a service worker
</li>
	<li>
出力
⇒＃
真偽値
◎
Output
• True or false, a boolean
</li>
</ul>

<ol>
	<li>
~IF［
%~worker ~EQ ~NULL
］
⇒
~RET ~T
◎
↑</li>
	<li>
<p>
%~worker の`延長-済み~event集合$swを成す
~EACH( %~event )
に対し
⇒
~IF［
%~event は`作動中$eXである
］
⇒
~RET ~F
◎
For each event of worker’s set of extended events:
• If event is active, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

		</section>
		<section id="create-client-algorithm">
<h3 title="Create Client">`~clientを作成する@</h3>

<ul>
	<li>
入力
⇒＃
%~client — `~sw~client$
◎
Input
• client, a service worker client
</li>
	<li>
出力
⇒＃
`Client$I ~obj
◎
Output
• clientObject, a Client object
</li>
</ul>

<ol>
	<li>
~RET 次のようにされた 新たな `Client$I ~obj
⇒＃
`~sw~client$cl ~SET %~client
◎
Let clientObject be a new Client object.
◎
Set clientObject’s service worker client to client.
◎
Return clientObject.
</li>
</ol>

		</section>
		<section id="create-windowclient-algorithm">
<h3 title="Create Window Client">`~window~clientを作成する@</h3>

<ul>
	<li>
入力
⇒＃
%~client — `~sw~client$,
%~frame種別 — 文字列【 `FrameType$I 値】,
%可視性~状態 — 文字列 【 `VisibilityState$I 値】,
%~focus状態 — 真偽値,
%先祖~生成元~list — 【文字列の】~list
◎
Input
• client, a service worker client
• frameType, a string
• visibilityState, a string
• focusState, a boolean
• ancestorOriginsList, a list
</li>
	<li>
出力
⇒＃
`WindowClient$I ~obj
◎
Output
• windowClient, a WindowClient object
</li>
</ul>

<ol>
	<li>
~RET 次のようにされた 新たな `WindowClient$I ~obj
⇒＃
`~sw~client$cl ~SET %~client,
`~frame種別$cl ~SET %~frame種別,
`可視性~状態$cl ~SET %可視性~状態,
`~focus状態$cl ~SET %~focus状態,
`先祖~生成元~配列$cl ~SET `凍結d配列を作成する$( %先祖~生成元~list ) 【 %~client に`関連な~Realm$内で？】
◎
Let windowClient be a new WindowClient object.
• Set windowClient’s service worker client to client.
• Set windowClient’s frame type to frameType.
• Set windowClient’s visibility state to visibilityState.
• Set windowClient’s focus state to focusState.
• Set windowClient’s ancestor origins array to a frozen array created from ancestorOriginsList.
◎
Return windowClient.
</li>
</ol>

		</section>
		<section id="get-frametype-algorithm">
<h3 title="Get Frame Type">`~frame種別を取得する@</h3>

<ul>
	<li>
入力
⇒＃
%閲覧文脈 — `閲覧文脈$
◎
Input
• browsingContext, a browsing context
</li>
	<li>
出力
⇒＃
%~frame種別 — 文字列
◎
Output
• frameType, a string
</li>
</ul>

<ol>
	<li>
~RET %閲覧文脈 に応じて
⇒＃
`入子の閲覧文脈$ならば `nested^l ／
`補助~閲覧文脈$ならば `auxiliary^l ／
~ELSE_ `top-level^l
◎
Return the value by switching on the type of browsingContext:
◎
Nested browsing context
• "nested"
Auxiliary browsing context
• "auxiliary"
Otherwise
• "top-level"
</li>
</ol>

		</section>
		<section id="resolve-get-client-promise-algorithm">
<h3 title="Resolve Get Client Promise">`~clientを取得する~promiseを解決する@</h3>

<ul>
	<li>
入力
⇒＃
%~client — `~sw~client$,
%~promise — `~promise$
◎
Input
• client, a service worker client
• promise, a promise
</li>
	<li>
出力
⇒＃
~none
◎
Output
• None
</li>
</ul>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
［
%~client は`環境~設定群~obj$である
］~AND［
%~client は`~secure文脈$でない
］
</li>
			<li>
［
%~client は`環境~設定群~obj$でない
］~AND［
%~client の`作成時の~URL$enV は`信用に価し得る~URL$でない
］
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event-loop$enV )
⇒
`SecurityError$E 例外で %~promise を`却下する$
</li>
			<li>
~RET
</li>
		</ol>
◎
If client is an environment settings object, then:
• If client is not a secure context, queue a task to reject promise with a "SecurityError" DOMException, on promise’s relevant settings object's responsible event loop using the DOM manipulation task source, and abort these steps.
◎
Else:
• If client’s creation URL is not a potentially trustworthy URL, queue a task to reject promise with a "SecurityError" DOMException, on promise’s relevant settings object's responsible event loop using the DOM manipulation task source, and abort these steps.
</li>
	<li>
<p>
~IF［
%~client は`環境~設定群~obj$である
］~AND［
%~client は`~window~client$でない
］：
◎
If client is an environment settings object and is not a window client, then:
</p>
		<ol>
			<li>
%~client~obj ~LET `~clientを作成する$( %~client )
◎
Let clientObject be the result of running Create Client algorithm with client as the argument.
</li>
			<li>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event-loop$enV )
⇒
%~client~obj で %~promise を`解決する$
◎
Queue a task to resolve promise with clientObject, on promise’s relevant settings object's responsible event loop using the DOM manipulation task source, and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%閲覧文脈 ~LET［
%~client は`環境~設定群~obj$であるならば %~client の`大域~obj$enVの`閲覧文脈$ ／
~ELSE_ %~client の`~target閲覧文脈$enV
］
◎
Else:
◎
Let browsingContext be null.
◎
If client is an environment settings object, set browsingContext to client’s global object's browsing context.
◎
Else, set browsingContext to client’s target browsing context.
</li>
	<li>
<p>
`~taskを~queueする$( `利用者~対話~task源$, 次の手続き, %閲覧文脈 の`~event-loop$ )：
◎
Queue a task to run the following steps on browsingContext’s event loop using the user interaction task source:
</p>
		<ol>
			<li>
%作動中の文書 ~LET %閲覧文脈 にて`作動中の文書$
◎
↓</li>
			<li>
%~frame種別 ~LET `~frame種別を取得する$( %閲覧文脈 )
◎
Let frameType be the result of running Get Frame Type with browsingContext.
</li>
			<li>
%可視性~状態 ~LET %作動中の文書 の`visibilityState$n 属性~値
◎
Let visibilityState be browsingContext’s active document's visibilityState attribute value.
</li>
			<li>
%~focus状態 ~SET `~focusを得ている$( %作動中の文書 )
◎
Let focusState be the result of running the has focus steps with browsingContext’s active document as the argument.
</li>
			<li>
%先祖~生成元~list ~LET 空~list
◎
Let ancestorOriginsList be the empty list.
</li>
			<li>
~IF［
%~client は`~window~client$である
］
⇒
%先祖~生成元~list ~SET %作動中の文書 に`関連な大域~obj$の `Location$I ~objの`先祖~生成元~list$に結付けられている~list
◎
If client is a window client, set ancestorOriginsList to browsingContext’s active document's relevant global object's Location object’s ancestor origins list's associated list.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task源$, 次の手続き, %promise に`関連な設定群~obj$の`担当の~event-loop$enV )：
◎
Queue a task to run the following steps on promise’s relevant settings object's responsible event loop using the DOM manipulation task source:
</p>
				<ol>
					<li>
%結果 ~LET `undefined^jv
◎
↓</li>
					<li>
~IF［
%~client の`破棄-済み~flag$ ~EQ ~F
］
⇒
%結果 ~SET `~window~clientを作成する$( 次に挙げる引数 )
⇒＃
%~client,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
If client’s discarded flag is set, resolve promise with undefined and abort these steps.
◎
Let windowClient be the result of running Create Window Client with client, frameType, visibilityState, focusState, and ancestorOriginsList.
</li>
					<li>
%結果 で %~promise を`解決する$
◎
Resolve promise with windowClient.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="query-cache-algorithm">
<h3 title="Query Cache">`~cacheを~queryする@</h3>

<ul>
	<li>
入力
⇒＃
%要請~query — `要請$,
%~storage — `要請~応答~list$†,
%~options — `CacheQueryOptions$I ~obj（省略時は ε ）,
◎
Input
• requestQuery, a request
• options, a CacheQueryOptions object, optional
• targetStorage, a request response list, optional
</li>
	<li>
出力
⇒＃
%結果~list — `要請~応答~list$
◎
Output
• resultList, a request response list
</li>
</ul>

<p class="trans-note">【†
%~storage は、原文では省略可能とされているが、この訳では，常に明示的に与えて呼出すよう改めている。
原文では，省略時には
`関連な要請~応答~list$
になるものとされているが、どの~objに関連なそれなのか明らかでなく，呼出す箇所で与える方が明確になるので。
それに伴い、引数の順序も改めている。
】</p>

<ol>
	<li>
%結果~list ~LET 新たな`~list$
◎
Let resultList be an empty list.
</li>
	<li>
<p>
%~storage を成す
~EACH( %要請~応答 )
に対し：
◎
Let storage be null.
◎
If the optional argument targetStorage is omitted, set storage to the relevant request response list.
◎
Else, set storage to targetStorage.
◎
For each requestResponse of storage:
</p>
		<ol>
			<li>
%要請 ~LET %要請~応答 を成す要請
◎
Let cachedRequest be requestResponse’s request.
</li>
			<li>
%応答 ~LET %要請~応答 を成す応答
◎
Let cachedResponse be requestResponse’s response.
</li>
			<li>
~IF［
`要請は~cache済み~itemに合致するか$( %要請~query, %要請, %応答, %~options )
~EQ ~T
］
⇒
%結果~list に
( %要請 の複製 / %応答 の複製 )
を`付加する$
◎
If Request Matches Cached Item with requestQuery, cachedRequest, cachedResponse, and options returns true, then:
• Let requestCopy be a copy of cachedRequest.
• Let responseCopy be a copy of cachedResponse.
• Add requestCopy/responseCopy to resultList.
</li>
		</ol>
	</li>
	<li>
~RET %結果~list
◎
Return resultList.
</li>
</ol>

		</section>
		<section id="request-matches-cached-item-algorithm">
<h3 title="Request Matches Cached Item">`要請は~cache済み~itemに合致するか@</h3>

<ul>
	<li>
入力
⇒＃
%要請~query — `要請$
%要請 — `要請$
%応答 — `応答$または ~NULL （省略時は ~NULL ）
%~options — `CacheQueryOptions$I ~obj（省略時は ε ）
◎
Input
• requestQuery, a request
• request, a request
• response, a response or null, optional, defaulting to null
• options, a CacheQueryOptions object, optional
</li>
	<li>
出力
⇒＃
真偽値
◎
Output
• a boolean
</li>
</ul>

<ol>
	<li>
~IF［
%~options ~EQ ε
］
⇒
%~options ~SET 新たな `CacheQueryOptions$I ~obj
【この段は、この訳による補完】
</li>
	<li>
~IF［
%~options . `CacheQueryOptions^I1`ignoreMethod$m1 ~EQ ~F
］~AND［
%要請~query の`~method$rq ~NEQ `GET^bl
］
⇒
~RET ~F
◎
If options.ignoreMethod is false and request’s method is not `GET`, return false.
</li>
	<li>
%~query~URL ~LET %要請~query の`~URL$rq
◎
Let queryURL be requestQuery’s url.
</li>
	<li>
%~cache済み~URL ~LET %要請 の`~URL$rq
◎
Let cachedURL be request’s url.
</li>
	<li>
<p>
~IF［
%~options . `ignoreSearch$m1 ~EQ ~T
］：
◎
If options.ignoreSearch is true, then:
</p>
		<ol>
			<li>
%~cache済み~URL の`~query$url ~SET 空~文字列
◎
Set cachedURL’s query to the empty string.
</li>
			<li>
%~query~URL の`~query$url ~SET 空~文字列
◎
Set queryURL’s query to the empty string.
</li>
		</ol>
	</li>
	<li>
~IF［
( %~query~URL, %~cache済み~URL  )
は `素片は除外する^i 下で`同等な~URL$でない
］
⇒
~RET ~F
◎
If queryURL does not equal cachedURL with the exclude fragment flag set, then return false.
</li>
	<li>
<p>
~RET ［
次がすべて満たされるならば ~F ／
~ELSE_ ~T
］：
</p>
		<ul>
			<li>
%応答 ~NEQ ~NULL
</li>
			<li>
%~options . `ignoreVary$m1 ~EQ ~F
</li>
			<li>
<p>
%応答 の`~header~list$rs内に `Vary$h を`名前に持つ~header$が在って、その`値$hdを成す
ある `field-value$P %~field値 に対し，次のいずれかが満たされる：
</p>
				<ul>
					<li>
%~field値 ~EQ `*^l
</li>
					<li>
`~header~listから値を取得する$( %要請 の`~header~list$rq, %~field値 )
~NEQ
`~header~listから値を取得する$( %要請~query の`~header~list$rq, %~field値 )
</li>
				</ul>
			</li>
		</ul>
◎
If response is null, options.ignoreVary is true, or response’s header list does not contain `Vary`, then return true.
◎
Let fieldValues be the list containing the elements corresponding to the field-values of the Vary header for the value of the header with name `Vary`.
◎
For each fieldValue in fieldValues:
• If fieldValue matches "*", or the combined value given fieldValue and request’s header list does not match the combined value given fieldValue and requestQuery’s header list, then return false.
◎
Return true.
</li>
</ol>

		</section>
		<section id="batch-cache-operations-algorithm">
<h3 title="Batch Cache Operations">`~cache演算を~batchする@</h3>

<ul>
	<li>
入力
⇒＃
%演算~list — `~cache~batch演算$ ~objの`~list$,
%O — `要請~応答~list$を表現する~obj【この訳による補完】
◎
Input
• operations, a list of cache batch operation objects
</li>
	<li>
出力
⇒＃
%結果~list — `要請~応答~list$
◎
Output
• resultList, a request response list
</li>
</ul>

<ol>
	<li>
%~cache ~LET %O に`関連な要請~応答~list$
◎
Let cache be the relevant request response list.
</li>
	<li>
%予備~cache ~LET %~cache を`~cloneする$
◎
Let backupCache be a new request response list that is a copy of cache.
</li>
	<li>
%追加される~itemたち ~LET 新たな`~list$
◎
Let addedItems be an empty list.
</li>
	<li>
<p>
この段は不可分的に走らす
— ただし、手続きの中で例外が投出されたときは，この段の次の段へ進む：
◎
Try running the following substeps atomically:
</p>
		<ol>
			<li>
%結果~list ~LET 空~list
◎
Let resultList be an empty list.
</li>
			<li>
<p>
%演算~list を成す
~EACH( %演算 )
に対し：
◎
For each operation in operations:
</p>
				<ol>
					<li>
( %要請, %応答, %種別, %~options ) ~LET
%演算 の ( `要請$cbo, `応答$cbo, `種別$cbo, `~options$cbo )
◎
↓</li>
					<li>
~IF［
%種別 ~NIN { `delete^l, `put^l }
］
⇒
~THROW `TypeError^E
◎
If operation’s type matches neither "delete" nor "put", throw a TypeError.
</li>
					<li>
~IF［
%種別 ~NEQ `delete^l
］~AND［
%応答 ~NEQ ~NULL
］
⇒
~THROW `TypeError^E
◎
If operation’s type matches "delete" and operation’s response is not null, throw a TypeError.
</li>
					<li>
~IF［
`~cacheを~queryする$( %要請, %追加される~itemたち, %~options )
の結果は`空$でない
］
⇒
~THROW `InvalidStateError$E
◎
If the result of running Query Cache with operation’s request, operation’s options, and addedItems is not empty, throw an "InvalidStateError" DOMException.
</li>
					<li>
%要請~応答~list ~LET 新たな`~list$
◎
Let requestResponses be an empty list.
</li>
					<li>
<p>
~IF［
%種別 ~EQ `delete^l
］：
◎
If operation’s type matches "delete", then:
</p>
						<ol>
							<li>
%要請~応答~list ~SET `~cacheを~queryする$( %要請, %~cache, %~options )
◎
Set requestResponses to the result of running Query Cache with operation’s request and operation’s options.
</li>
							<li>
%~cache から次を満たす`~item$たちを`除去する$
⇒
`~item$ ~IN %要請~応答~list
◎
For each requestResponse in requestResponses:
• Remove the item whose value matches requestResponse from cache.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%種別 ~EQ `put^l
］：
◎
Else if operation’s type matches "put", then:
</p>
						<ol>
							<li>
~IF［
%応答 ~EQ ~NULL
］
⇒
~THROW `TypeError^E
◎
If operation’s response is null, throw a TypeError.
</li>
							<li>
【！ 's associated `要請$Rq 】
~IF［
%要請 の`~URL$rqの`~scheme$url ~NIN { `http^l , `https^l } 
］
⇒
~THROW `TypeError^E
◎
↑↑
Let r be operation’s request's associated request.
（'s associated request は余計）
◎
If r’s url's scheme is not one of "http" and "https", throw a TypeError.
</li>
							<li>
~IF［
%要請 の`~method$rq ~NEQ `GET^bl
］
⇒
~THROW `TypeError^E
◎
If r’s method is not `GET`, throw a TypeError.
</li>
							<li>
~IF［
%演算 の`~options$cbo ~NEQ ~NULL
］
⇒
~THROW `TypeError^E
◎
If operation’s options is not null, throw a TypeError.
</li>
							<li>
%要請~応答~list ~SET `~cacheを~queryする$( %要請, %~cache )
◎
Set requestResponses to the result of running Query Cache with operation’s request.
</li>
							<li>
%~cache から次を満たす`~item$たちを`除去する$
⇒
`~item$ ~IN %要請~応答~list
◎
For each requestResponse of requestResponses:
• Remove the item whose value matches requestResponse from cache.
</li>
							<li>
%cache に
( %要請 / %応答 )
を`付加する$
◎
Append operation’s request/operation’s response to cache.
</li>
							<li>
~IF［
【！previous two steps？】
前~段の~cache書込-演算は、是認されている~quota制限-を超過することにより失敗した
］
⇒
~THROW `QuotaExceededError$E
◎
If the cache write operation in the previous two steps failed due to exceeding the granted quota limit, throw a "QuotaExceededError" DOMException.
</li>
							<li>
%追加される~itemたち に
( %要請 / %応答 )
を`付加する$
◎
Append operation’s request/operation’s response to addedItems.
</li>
						</ol>
					</li>

					<li>
%結果~list に
( %要請 / %応答 )
を`付加する$
◎
Append operation’s request/operation’s response to resultList.
</li>
				</ol>
			</li>
			<li>
~RET %結果~list
◎
Return resultList.
</li>
		</ol>
	</li>
	<li>
<p>
前~段にて %例外 が投出されたときは：
◎
And then, if an exception was thrown, then:
</p>
		<ol>
			<li>
%~cache を`空にする$
◎
Remove all the items from the relevant request response list.
</li>
			<li>
%予備~cache を成す
~EACH( %要請~応答 )
に対し
⇒
%~cache に %要請~応答 を`付加する$
◎
For each requestResponse of backupCache:
• Append requestResponse to the relevant request response list.
</li>
			<li>
~THROW %例外
◎
Throw the exception.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
例外が投出されたときには、実装は，［
~batch演算~jobの間に~cache~storageに加えられた変更
］を巻戻すことになる。
◎
Note: When an exception is thrown, the implementation does undo (roll back) any changes made to the cache storage during the batch operation job.
</p>

		</section>
	</section>
	<section id="extended-http-headers">
<h2 title="Appendix B: Extended HTTP headers">付録 B. 拡張された~HTTP~header</h2>

		<section id="service-worker-script-request">
<h3 title="Service Worker Script Request">~sw~script要請</h3>

<p>
`~sw$の`~script資源$swを`~fetch$する~HTTP要請は、次の`~header$を含めることになる：
◎
An HTTP request to fetch a service worker's script resource will include the following header:
</p>

<dl>
	<dt>`Service-Worker@h</dt>
	<dd>
この要請は`~sw$の`~script資源$sw要請であることを指示する。
◎
Indicates this request is a service worker's script resource request.
</dd>
	<dd class="note">注記：
この~headerは、~administratorが要請を~logして，脅威を検出するのを助ける。
◎
Note: This header helps administrators log the requests and detect threats.
</dd>
</dl>

		</section>
		<section id="service-worker-script-response">
<h3 title="Service Worker Script Response">~sw~script応答</h3>

<p>
`~sw$の`~script資源$sw要請に対する~HTTP応答は、次に挙げる`~header$を含ませれる：
◎
An HTTP response to a service worker's script resource request can include the following header:
</p>

<dl>
	<dt>`Service-Worker-Allowed@h</dt>
	<dd>
~path制約を上書きするよう~UAに指示する
— これは、~scriptに`制御-$することが許容される最大の`~scope~url$swrを，所与の値に制限する。
◎
Indicates the user agent will override the path restriction, which limits the maximum allowed scope url that the script can control, to the given value.
</dd>
	<dd class="note">注記：
この値は~URLである。
相対的~URLが与えられた場合、それは~scriptの~URLに基づいて構文解析される。
◎
Note: The value is a URL. If a relative URL is given, it is parsed against the script’s URL.
</dd>
</dl>

<div class="example">
<p>
既定の~scope：
◎
Default scope:
</p>

<pre>
/* <span class="comment">
許容される最大の~scopeは、既定では，~scriptが座している~path
— 次の例では `/js/^l —
になる：
◎
Maximum allowed scope defaults to the path the script sits in "/js/" in this example
</span> */
navigator.serviceWorker.register("/js/sw.js").then(() =&gt; {
  console.log("既定の~scope '/js/' で~installに成功しました。");
});
</pre>
【！ "Install succeeded with the default scope '/js/'." 】
</div>

<div class="example">

<p>
`Service-Worker-Allowed^h ~headerが伴われないときの，上位path：
◎
Upper path without Service-Worker-Allowed header:
</p>

<pre>
/* <span class="comment">
`Response^I に `Service-Worker-Allowed^h ~headerがないときに，~scopeを~scriptの所在の上位pathに設定する：
◎
Set the scope to an upper path of the script location Response has no Service-Worker-Allowed header
</span> */
navigator.serviceWorker.register("/js/sw.js", { scope: "/" }).catch(() =&gt; {
  console.error("~path制約に違反しているため、~installに失敗しました。");
});
</pre>
【！"Install failed due to the path restriction violation."】
</div>

<div class="example">

<p>
`Service-Worker-Allowed^h ~headerが伴われるときの，上位path：
◎
Upper path with Service-Worker-Allowed header:
</p>

<pre>
/* <span class="comment">
`Response^I に `Service-Worker-Allowed : /^bl が含まれているときに，~scopeを~script所在の上位pathに設定する：
◎
Set the scope to an upper path of the script location Response included "Service-Worker-Allowed : /"
</span> */
navigator.serviceWorker.register("/js/sw.js", { scope: "/" }).then(() =&gt; {
  console.log("許容される最大の~scopeは '/' に上書きされたので、~installに成功しました。");
});
</pre>
【！"Install succeeded as the max allowed scope was overriden to '/'."】
</div>

<div class="example">

<p>
`Service-Worker-Allowed^h ~headerが伴われていても，~path制約~違反になる例：
◎
A path restriction voliation even with Service-Worker-Allowed header:
</p>

<pre>
/* <span class="comment">
`Response^I に
`Service-Worker-Allowed : /foo^bl
が含まれているときに，~scopeを~script所在の上位pathに設定する：
◎
Set the scope to an upper path of the script location Response included "Service-Worker-Allowed : /foo"
</span> */
navigator.serviceWorker.register("/foo/bar/sw.js", { scope: "/" }).catch(() =&gt; {
  console.log("許容される最大の~scopeは上書きされましたが，まだ~scopeはその外にあるので、~installに失敗しました。");
});
</pre>
【！ "Install failed as the scope is still out of the overriden maximum allowed scope."】
</div>

		</section>
		<section id="syntax">
<h3 title="Syntax">構文</h3>

<p>
`~sw$の`~script資源$swへの［
要請と, 対する応答
］により利用される~headerに与える値の `ABNF$r は、次で与えられる：
◎
ABNF for the values of the headers used by the service worker's script resource requests and responses:
</p>

<pre class="ABNF">
Service-Worker = `%x73.63.72.69.70.74^_ ; "script", case-sensitive
</pre>

<p class="note">注記：
`Service-Worker-Allowed^h ~headerの値を検証するときには、この~ABNFは利用されない
— 検証は、（更新-~algo内で）~URL構文解析~algoが行う。
◎
Note: The validation of the Service-Worker-Allowed header’s values is done by URL parsing algorithm (in Update algorithm) instead of using ABNF.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<div lang="en-x-a0">
<p>
Deep thanks go to Andrew Betts for organizing and hosting a small workshop of like-minded individuals including: Jake Archibald, Jackson Gabbard, Tobie Langel, Robin Berjon, Patrick Lauke, Christian Heilmann. From the clarity of the day’s discussions and the use-cases outlined there, much has become possible. Further thanks to Andrew for raising consciousness about the offline problem. His organization of EdgeConf and inclusion of Offline as a persistent topic there has created many opportunities and connections that have enabled this work to progress.
</p>

<p>
Anne van Kesteren has generously lent his encyclopedic knowledge of Web Platform arcana and standards development experience throughout the development of the service worker. This specification would be incomplete without his previous work in describing the real-world behavior of URLs, HTTP Fetch, Promises, and DOM. Similarly, this specification would not be possible without Ian Hickson’s rigorous Web Worker spec. Much thanks to him.
</p>

<p>
In no particular order, deep gratitude for design guidance and discussion goes to: Jungkee Song, Alec Flett, David Barrett-Kahn, Aaron Boodman, Michael Nordman, Tom Ashworth, Kinuko Yasuda, Darin Fisher, Jonas Sicking, Jesús Leganés Combarro, Mark Christian, Dave Hermann, Yehuda Katz, François Remy, Ilya Grigorik, Will Chan, Domenic Denicola, Nikhil Marathe, Yves Lafon, Adam Barth, Greg Simon, Devdatta Akhawe, Dominic Cooney, Jeffrey Yasskin, Joshua Bell, Boris Zbarsky, Matt Falkenhagen, Tobie Langel, Gavin Peters, Ben Kelly, Hiroki Nakagawa, Jake Archibald, Josh Soref, Jinho Bang, Yutaka Hirano, Michael(tm) Smith, isonmad, Ali Alabbas, Philip Jägenstedt, Mike Pennisi, and Eric Willigers.
</p>

<p>
Jason Weber, Chris Wilson, Paul Kinlan, Ehsan Akhgari, and Daniel Austin have provided valuable, well-timed feedback on requirements and the standardization process.
</p>

<p>
The authors would also like to thank Dimitri Glazkov for his scripts and formatting tools which have been essential in the production of this specification. The authors are also grateful for his considerable guidance.
</p>

<p>
Thanks also to Vivian Cromwell, Greg Simon, Alex Komoroske, Wonsuk Lee, and Seojin Kim for their considerable professional support.
</p>

</div>

	</section>
</main></div>

