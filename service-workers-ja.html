<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Service Workers Nightly （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>
.response-status {
	font-family: sans-serif0, sans-serif;
	color: var(--text-color-2);
}

	/* protocol element */
.protocol {
	color: var(--text-color-1);
	font-family: monospace0, monospace;
}

/* Examples */
aside.example {
	margin-bottom: 0.5em;
}


ul.input-params::before {
	content: "入力：";
	display: block;
	color: var(--dim-color);
	text-indent: -2em;
}

#_hierarchy td {
	text-align: center;
	border: none;
}

@supports (grid-template-columns: subgrid) and (display: contents) {

#_event-table {
	grid-template-columns: 1fr 1fr 1fr;
	min-width:30em;
	max-width:70em;
	tr {
		grid-template-areas:
			"名 型 類"
			"時 時 時";
		> *:nth-child(1) {
			grid-area: 名;
			background: var(--V-bg);
		}
		> *:nth-child(2) {
			grid-area: 型;
		}
		> *:nth-child(3) {
			grid-area: 類;
		}
		> *:nth-child(4) {
			grid-area: 時;
		}
	}
}

#_event-table1 {
	grid-template-columns: 1fr 1fr;
	min-width:30em;
	max-width:40em;
	tr {
		grid-template-areas:
			"名 先"
			"時 時";
		> *:nth-child(1) {
			grid-area: 名;
			background: var(--V-bg);
		}
		> *:nth-child(2) {
			grid-area: 先;
		}
		> *:nth-child(3) {
			grid-area: 時;
		}
	}
}

}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let context_ifc = '';
	let context_ifc1 = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-んア-ンー]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'mc':
	href = context_ifc + context_ifc.slice(5,-1);
	break;
case 'm':
case 'm1':
case 'n':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
		switch(klass){
		case 'm':
			href = context_ifc + key.toLowerCase();
			break;
		case 'm1':
			href = context_ifc1 + key.toLowerCase();
			break;
		}
	}
	break;
case 'I1':
	context_ifc1 = `#dom-${key.toLowerCase()}-`;
	if(indicator === '^'){
		return '';
	}
	klass = 'I';
	break;
case 'I0':
	context_ifc = `#dom-${key.toLowerCase()}-`;
	if(indicator === '^'){
		return '';
	}
	klass = 'I';
	break;
case 'I':
	if(indicator === '@'){
		context_ifc = `#dom-${key.toLowerCase()}-`;
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'issue':
	return (
`<a href="https://github.com/w3c/ServiceWorker/issues/${key}">課題 #${key}</a>`
	);
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

/*
		m: 'code',
mWGS: 'code',
mSWGS: 'code',
mMe: 'code',
mEe: 'code',
mFei: 'code',
mC: 'code',
mCQo: 'code',
mCS: 'code',
mCl: 'code',
mEMe: 'code',
mEMei: 'code',
mFe: 'code',
mNPL: 'code',
mNPM: 'code',
mRo: 'code',
mSW: 'code',
mSWC: 'code',
mSWR: 'code',
mWC: 'code',
*/

</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2025-06-19
trans_update:2025-06-19
source_checked:250530
original_url:https://w3c.github.io/ServiceWorker/
	abbr_url:SW1
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2025,permissive
site_nav:network,http,security,storage
trans_1st_pub:2019-06-03

●●class_map
e:element
E:error
a:attr
st:response-status
et:event-type
etC:event-type
v:value
jv:js-value
sl:js-slot
P:protocol
jA:abstract
jT:js-type
dir:directive
	h:header

●●tag_map
I:code
E:code
m:code
m1:code
n:code
c:code
e:code
a:code
et:code
etC:code
sub:sub
v:code
dir:code
P:var
jv:code
jA:span
sl:span
st:span
V:var
i:i
jT:span
sub:sub
em:em
cite:cite

●●original_id_map

●●mdn_urls
cache:API/Cache
cachestorage:API/CacheStorage
client:API/Client
clients:API/Clients
extendableevent:API/ExtendableEvent
extendablemessageevent:API/ExtendableMessageEvent
fetchevent:API/FetchEvent
navigationpreloadmanager:API/NavigationPreloadManager
serviceworker:API/ServiceWorker
serviceworkercontainer:API/ServiceWorkerContainer
serviceworkerglobalscope:API/ServiceWorkerGlobalScope
serviceworkerregistration:API/ServiceWorkerRegistration
windowclient:API/WindowClient
	dictdef-cachequeryoptions:API/CacheQueryOptions
	dictdef-clientqueryoptions:API/ClientQueryOptions
	dictdef-extendableeventinit:API/ExtendableEventInit
	dictdef-extendablemessageeventinit:API/ExtendableMessageEventInit
	dictdef-fetcheventinit:API/FetchEventInit
	dictdef-multicachequeryoptions:API/MultiCacheQueryOptions
	dictdef-navigationpreloadstate:API/NavigationPreloadState
	dictdef-registrationoptions:API/RegistrationOptions
	enumdef-clienttype:API/ClientType
	enumdef-frametype:API/FrameType
enumdef-serviceworkerstate:API/ServiceWorkerState
	enumdef-serviceworkerupdateviacache:API/ServiceWorkerUpdateViaCache

eventdef-serviceworkerglobalscope-message:API/ServiceWorkerGlobalScope/message_event
	eventdef-serviceworkerglobalscope-messageerror:API/ServiceWorkerGlobalScope/messageerror_event
	service-worker-global-scope-activate-event:API/ExtendableEvent/activate_event
	service-worker-global-scope-fetch-event:API/FetchEvent/fetch_event
	service-worker-global-scope-install-event:API/ExtendableEvent/install_event
	service-worker-container-controllerchange-event:API/ServiceWorkerContainer/controllerchange_event
	eventdef-serviceworker-statechange:API/ServiceWorker/statechange_event
	service-worker-registration-updatefound-event:API/ServiceWorkerRegistration/updatefound_event

●●link_map

	●IDL
CEReactions:~HEcustom#cereactions
Exposed:~WEBIDLjs#Exposed
Global:~WEBIDLjs#Global
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject
SecureContext:~WEBIDLjs#SecureContext

any:~WEBIDL#idl-any
undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
sequence:~WEBIDL#idl-sequence
USVString:~WEBIDL#idl-USVString
ByteString:~WEBIDL#idl-ByteString
DOMString:~WEBIDL#idl-DOMString
	文字列:~WEBIDL#idl-DOMString
Promise:~WEBIDL#idl-promise
FrozenArray:~WEBIDL#idl-frozen-array
c.TrustedScriptURL:~TRUSTED-TYPES#trustedscripturl


E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.QuotaExceededError:~WEBIDL#quotaexceedederror
E.SecurityError:~WEBIDL#securityerror
E.AbortError:~WEBIDL#aborterror
E.NetworkError:~WEBIDL#networkerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

	I.DOMException:~WEBIDL#idl-DOMException
I.AbortController:~DOM4#abortcontroller
I.AbstractWorker:~WORKERS#abstractworker
	I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer → ~buffer~sourceを作成する
I.Cache:#cache
I.CacheQueryOptions:#dictdef-cachequeryoptions
I.CacheStorage:#cachestorage
I.CanMakePaymentEvent:https://w3c.github.io/payment-handler/#dom-canmakepaymentevent
I.Client:#client
I.ClientQueryOptions:#dictdef-clientqueryoptions
I.ClientType:#enumdef-clienttype
I.Clients:#clients
I.DOMContentLoaded:~HTMLindex#event-domcontentloaded
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.Document:~DOM4#document
I.DocumentVisibilityState:~HTMLdom#documentvisibilitystate
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventListener:~DOM4#callbackdef-eventlistener
I.EventTarget:~DOM4#eventtarget
I.ExtendableEvent:#extendableevent
I.ExtendableEventInit:#dictdef-extendableeventinit
I.ExtendableMessageEvent:#extendablemessageevent
I.ExtendableMessageEventInit:#dictdef-extendablemessageeventinit
I.FetchEvent:#fetchevent
I.FetchEventInit:#dictdef-fetcheventinit
I.FrameType:#enumdef-frametype
	I.Headers:~FETCH#headers
I.InstallEvent:#installevent
I.Location:~WINDOW#location
I.MessageEvent:~HTMLcomms#messageevent
I.MessagePort:~HTMLcomms#messageport
I.MultiCacheQueryOptions:#dictdef-multicachequeryoptions
I.NavigationPreloadManager:#navigationpreloadmanager
I.NavigationPreloadState:#dictdef-navigationpreloadstate
I.Navigator:~HTMLnavigator#navigator
I.NotificationEvent:~NOTIFICATIONS#notificationevent
I.PaymentRequestEvent:https://w3c.github.io/payment-handler/#dom-paymentrequestevent
I.PushEvent:https://w3c.github.io/push-api/#dom-pushevent
I.ReadableStream:~STREAMS#readablestream
I.RegistrationOptions:#dictdef-registrationoptions
I.Request:~FETCH#request
I.RequestDestination:~FETCH#requestdestination
I.RequestInfo:~FETCH#requestinfo
I.RequestMode:~FETCH#requestmode
I.Response:~FETCH#response
I.RouterCondition:#dictdef-routercondition
I.RouterRule:#dictdef-routerrule
I.RouterSource:#typedefdef-routersource
I.RouterSourceDict:#dictdef-routersourcedict
I.RouterSourceEnum:#enumdef-routersourceenum
I.RunningStatus:#enumdef-runningstatus
I.ServiceWorker:#serviceworker
I.ServiceWorkerContainer:#serviceworkercontainer
I.ServiceWorkerGlobalScope:#serviceworkerglobalscope
I.ServiceWorkerRegistration:#serviceworkerregistration
I.ServiceWorkerState:#enumdef-serviceworkerstate
I.ServiceWorkerUpdateViaCache:#enumdef-serviceworkerupdateviacache
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.StructuredSerializeOptions:~HTMLcomms#structuredserializeoptions
I.SyncEvent:https://wicg.github.io/background-sync/spec/#syncevent
I.URLPatternCompatible:~URLPATTERN#typedefdef-urlpatterncompatible
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Window:~WINDOW#window
~window:~WINDOW#the-window-object
	:~WINDOW#window-object
I.WindowClient:#windowclient
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
I.Worker:~WORKERS#worker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WorkerLocation:~WORKERS#workerlocation
I.WorkerNavigator:~WORKERS#workernavigator
I.WorkerType:~WORKERS#workertype

	m.event.clientId:#dom-fetchevent-clientid
	m.event.data:#dom-extendablemessageevent-data
	m.event.lastEventId:#dom-extendablemessageevent-lasteventid
	m.event.origin:#dom-extendablemessageevent-origin
	m.event.ports:#dom-extendablemessageevent-ports
	m.event.preloadResponse:#dom-fetchevent-preloadresponse
	m.event.request:#dom-fetchevent-request
	m.event.resultingClientId:#dom-fetchevent-resultingclientid
	m.event.respondWith(r):#dom-fetchevent-respondwith
	m.event.source:#dom-extendablemessageevent-source
	m.event.replacesClientId:#dom-fetchevent-replacesclientid
	m.event.handled:#dom-fetchevent-handled
	m.event.waitUntil(f):#dom-extendableevent-waituntil
	m.event.waitUntil(r):#dom-extendableevent-waituntil

	m.navigator.serviceWorker.controller:#dom-serviceworkercontainer-controller
	m.navigator.serviceWorker:#navigator-service-worker-attribute
	m.self.caches:#global-caches-attribute
	m.navigator:~HTMLnavigator#dom-window-navigator
	m.navigator:~WORKERS#dom-worker-navigator


l.report:~FETCH#dom-requestdestination-report

l.sharedworker:#dom-clienttype-sharedworker
l.window:#dom-clienttype-window
l.worker:#dom-clienttype-worker
l.all:#dom-clienttype-all

l.cacheName:#dom-routersourcedict-cachename
l.running:#dom-runningstatus-running
l.not-running:#dom-runningstatus-not-running
l.cache:#dom-routersourceenum-cache
l.fetch-event:#dom-routersourceenum-fetch-event
l.network:#dom-routersourceenum-network
l.race-network-and-fetch-handler:#dom-routersourceenum-race-network-and-fetch-handler

	l.parsed:#dom-serviceworkerstate-parsed
	l.installing:#dom-serviceworkerstate-installing
	l.installed:#dom-serviceworkerstate-installed
	l.activating:#dom-serviceworkerstate-activating
	l.activated:#dom-serviceworkerstate-activated
	l.redundant:#dom-serviceworkerstate-redundant

	l.imports:#dom-serviceworkerupdateviacache-imports
	＊l.all:#dom-serviceworkerupdateviacache-all
	l.none:#dom-serviceworkerupdateviacache-none

	l.auxiliary:#dom-frametype-auxiliary
	l.top-level:#dom-frametype-top-level
	l.nested:#dom-frametype-nested
	l.none:#dom-frametype-none

n.self.fetch:~FETCH#dom-global-fetch
n.caches:#global-caches-attribute
n.cancelable:~DOM4#dom-event-cancelable
n.isTrusted:~DOM4#dom-event-istrusted
n.get:~FETCH#dom-headers-get
n.headers:~FETCH#dom-request-headers
n.serviceWorker:#navigator-service-worker-attribute
n.transfer:~HTMLcomms#dom-structuredserializeoptions-transfer
n.type:~DOM4#dom-event-type
n.visibilityState:~HTMLinteraction#dom-document-visibilitystate
n.new Request:~FETCH#dom-request
n.importScripts:#importscripts-method
		~WORKERS#dom-workerglobalscope-importscripts
		dom-workerglobalscope-importScripts

n.data:~HTMLcomms#dom-messageevent-data
n.origin:~HTMLcomms#dom-messageevent-origin
n.ports:~HTMLcomms#dom-messageevent-ports
n.source:~HTMLcomms#dom-messageevent-source

n.waitUntil:#dom-extendableevent-waituntil
n.respondWith:#dom-fetchevent-respondwith
n.~postMessageClient:#dom-client-postmessage-message-options
n.~postMessageSW:#dom-serviceworker-postmessage-message-options

n.register:#dom-serviceworkercontainer-register

	ServiceWorkerGlobalScope.clients:#dom-serviceworkerglobalscope-clients
	ServiceWorkerGlobalScope.registration:#dom-serviceworkerglobalscope-registration
	ServiceWorkerGlobalScope.serviceworker:#dom-serviceworkerglobalscope-serviceworker
	ServiceWorkerGlobalScope.skipWaiting:#dom-serviceworkerglobalscope-skipwaiting
	ServiceWorkerGlobalScope.onactivate:#dom-serviceworkerglobalscope-onactivate
	ServiceWorkerGlobalScope.onfetch:#dom-serviceworkerglobalscope-onfetch
	ServiceWorkerGlobalScope.oninstall:#dom-serviceworkerglobalscope-oninstall
	ServiceWorkerGlobalScope.onmessage:#dom-serviceworkerglobalscope-onmessage
	ServiceWorkerGlobalScope.onmessageerror:#dom-serviceworkerglobalscope-onmessageerror

	ExtendableEvent.constructor:#dom-extendableevent-extendableevent
	ExtendableEvent.waitUntil:#dom-extendableevent-waituntil

	InstallEvent.constructor:#dom-installevent-installevent
	InstallEvent.addRoutes:#dom-installevent-addroutes

	FetchEventInit.clientId:#dom-fetcheventinit-clientid
	FetchEventInit.preloadResponse:#dom-fetcheventinit-preloadresponse
	FetchEventInit.request:#dom-fetcheventinit-request
	FetchEventInit.resultingClientId:#dom-fetcheventinit-resultingclientid
	FetchEventInit.replacesClientId:#dom-fetcheventinit-replacesclientid
	FetchEventInit.handled:#dom-fetcheventinit-handled

	Cache.add:#dom-cache-add
	Cache.addAll:#dom-cache-addall
	Cache.delete:#dom-cache-delete
	Cache.keys:#dom-cache-keys
	Cache.match:#dom-cache-match
	Cache.matchAll:#dom-cache-matchall
	Cache.put:#dom-cache-put

	MultiCacheQueryOptions.cacheName:#dom-multicachequeryoptions-cachename
	CacheQueryOptions.ignoreMethod:#dom-cachequeryoptions-ignoremethod
	CacheQueryOptions.ignoreSearch:#dom-cachequeryoptions-ignoresearch
	CacheQueryOptions.ignoreVary:#dom-cachequeryoptions-ignorevary
	ClientQueryOptions.includeUncontrolled:#dom-clientqueryoptions-includeuncontrolled
	ClientQueryOptions.type:#dom-clientqueryoptions-type
	
	CacheStorage.delete:#dom-cachestorage-delete
	CacheStorage.has:#dom-cachestorage-has
	CacheStorage.keys:#dom-cachestorage-keys
	CacheStorage.match:#dom-cachestorage-match
	CacheStorage.open:#dom-cachestorage-open
	
	Client.frameType:#dom-client-frametype
	Client.id:#dom-client-id
	Client.postMessage:#dom-client-postmessage
	Client.postMessage:#dom-client-postmessage-options
	Client.reserved:#dom-client-reserved
	Client.type:#dom-client-type
	Client.url:#dom-client-url

	Clients.claim:#dom-clients-claim
	Clients.get:#dom-clients-get
	Clients.matchAll:#dom-clients-matchall
	Clients.openWindow:#dom-clients-openwindow
	
	ExtendableMessageEvent.constructor:#dom-extendablemessageevent-extendablemessageevent
	ExtendableMessageEvent.data:#dom-extendablemessageevent-data
	ExtendableMessageEvent.lastEventId:#dom-extendablemessageevent-lasteventid
	ExtendableMessageEvent.origin:#dom-extendablemessageevent-origin
	ExtendableMessageEvent.ports:#dom-extendablemessageevent-ports
	ExtendableMessageEvent.source:#dom-extendablemessageevent-source
	ExtendableMessageEventInit.data:#dom-extendablemessageeventinit-data
	ExtendableMessageEventInit.lastEventId:#dom-extendablemessageeventinit-lasteventid
	ExtendableMessageEventInit.origin:#dom-extendablemessageeventinit-origin
	ExtendableMessageEventInit.ports:#dom-extendablemessageeventinit-ports
	ExtendableMessageEventInit.source:#dom-extendablemessageeventinit-source
	
	FetchEvent.constructor:#dom-fetchevent-fetchevent
	FetchEvent.clientId:#dom-fetchevent-clientid
	FetchEvent.preloadResponse:#dom-fetchevent-preloadresponse
	FetchEvent.request:#dom-fetchevent-request
	FetchEvent.resultingClientId:#dom-fetchevent-resultingclientid
	FetchEvent.respondWith:#dom-fetchevent-respondwith
	FetchEvent.replacesClientId:#dom-fetchevent-replacesclientid
	FetchEvent.handled:#dom-fetchevent-handled

	NavigationPreloadState.enabled:#dom-navigationpreloadstate-enabled
	NavigationPreloadState.headerValue:#dom-navigationpreloadstate-headervalue
	
	NavigationPreloadManager.disable:#dom-navigationpreloadmanager-disable
	NavigationPreloadManager.enable:#dom-navigationpreloadmanager-enable
	NavigationPreloadManager.getState:#dom-navigationpreloadmanager-getstate
	NavigationPreloadManager.setHeaderValue:#dom-navigationpreloadmanager-setheadervalue
	
	RegistrationOptions.scope:#dom-registrationoptions-scope
	RegistrationOptions.type:#dom-registrationoptions-type
	RegistrationOptions.updateViaCache:#dom-registrationoptions-updateviacache

	RouterSourceDict.cacheName:#dom-routersourcedict-cachename

	RouterRule.condition:#dom-routerrule-condition
	RouterRule.source:#dom-routerrule-source

	RouterCondition.urlPattern:#dom-routercondition-urlpattern
	RouterCondition.requestMethod:#dom-routercondition-requestmethod
	RouterCondition.requestMode:#dom-routercondition-requestmode
	RouterCondition.requestDestination:#dom-routercondition-requestdestination
	RouterCondition.runningStatus:#dom-routercondition-runningstatus
	RouterCondition.or:#dom-routercondition-or
	RouterCondition.not:#dom-routercondition-not

	ServiceWorker.onstatechange:#dom-serviceworker-onstatechange
	ServiceWorker.postMessage:#dom-serviceworker-postmessage
	ServiceWorker.postMessage:#dom-serviceworker-postmessage-message-options
	ServiceWorker.scriptURL:#dom-serviceworker-scripturl
	ServiceWorker.state:#dom-serviceworker-state

	ServiceWorkerContainer.controller:#dom-serviceworkercontainer-controller
	ServiceWorkerContainer.getRegistration:#dom-serviceworkercontainer-getregistration
	ServiceWorkerContainer.getRegistrations:#dom-serviceworkercontainer-getregistrations
	ServiceWorkerContainer.oncontrollerchange:#dom-serviceworkercontainer-oncontrollerchange
	ServiceWorkerContainer.onmessage:#dom-serviceworkercontainer-onmessage
	ServiceWorkerContainer.onmessageerror:#dom-serviceworkercontainer-onmessageerror
	ServiceWorkerContainer.ready:#dom-serviceworkercontainer-ready
	ServiceWorkerContainer.register:#dom-serviceworkercontainer-register
	ServiceWorkerContainer.startMessages:#dom-serviceworkercontainer-startmessages
	
	ServiceWorkerRegistration.active:#dom-serviceworkerregistration-active
	ServiceWorkerRegistration.installing:#dom-serviceworkerregistration-installing
	ServiceWorkerRegistration.navigationPreload:#dom-serviceworkerregistration-navigationpreload
	ServiceWorkerRegistration.onupdatefound:#dom-serviceworkerregistration-onupdatefound
	ServiceWorkerRegistration.scope:#dom-serviceworkerregistration-scope
	ServiceWorkerRegistration.unregister:#dom-serviceworkerregistration-unregister
	ServiceWorkerRegistration.update:#dom-serviceworkerregistration-update
	ServiceWorkerRegistration.updateViaCache:#dom-serviceworkerregistration-updateviacache
	ServiceWorkerRegistration.waiting:#dom-serviceworkerregistration-waiting
	
	WindowClient.ancestorOrigins:#dom-windowclient-ancestororigins
	WindowClient.focus:#dom-windowclient-focus
	WindowClient.focused:#dom-windowclient-focused
	WindowClient.navigate:#dom-windowclient-navigate
	WindowClient.visibilityState:#dom-windowclient-visibilitystate

	●et
etC.controllerchange:#service-worker-container-controllerchange-event
etC.message:#service-worker-container-message-event
etC.messageerror:#service-worker-container-messageerror-event

et.activate:#service-worker-global-scope-activate-event
et.canmakepayment:https://w3c.github.io/payment-handler/#the-canmakepaymentevent
et.fetch:#service-worker-global-scope-fetch-event
et.install:#service-worker-global-scope-install-event
	et.install:#install
	et.activate:#activate
et.message:#eventdef-serviceworkerglobalscope-message
et.messageerror:#eventdef-serviceworkerglobalscope-messageerror
et.notificationclick:~NOTIFICATIONS#dom-serviceworkerglobalscope-onnotificationclick
et.notificationclose:~NOTIFICATIONS#dom-serviceworkerglobalscope-onnotificationclose
et.paymentrequest:https://w3c.github.io/payment-handler/#the-paymentrequestevent
et.push:https://w3c.github.io/push-api/#pushevent-interface
et.statechange:#eventdef-serviceworker-statechange
et.sync:https://wicg.github.io/background-sync/spec/#syncevent
et.updatefound:#service-worker-registration-updatefound-event

	●h
h.Service-Worker:#service-worker
h.Service-Worker-Allowed:#service-worker-allowed
h.Vary:~HTTPsem#field.vary
h.Cache-Control:~HTTPcache#field.cache-control
h.Content-Security-Policy-Report-Only:~CSP3#header-content-security-policy-report-only
h.Content-Security-Policy:~CSP3#header-content-security-policy
	h.Service-Worker-Navigation-Preload

e.iframe:~HEembed#the-iframe-element

	●用語

~sw:#dfn-service-worker
走っている:#service-worker-running

sw.状態:#dfn-state
sw.開始~状態:#service-worker-start-status
sw.~script~URL:#dfn-script-url
sw.種別:#dfn-type
sw.包含している~sw登録:#dfn-containing-service-worker-registration
sw.大域~obj:#dfn-service-worker-global-object
sw.~script資源:#dfn-script-resource
sw.これまでに評価されたか:#dfn-has-ever-been-evaluated-flag
sw.施策~容器:#dfn-policy-container
sw.~script資源~map:#dfn-script-resource-map
sw.利用した~scriptの集合:#dfn-set-of-used-scripts
sw.待機を飛ばすか:#dfn-skip-waiting-flag
sw.古典~scriptは~import済みか:#dfn-classic-scripts-imported-flag
sw.取扱う~event型の集合:#dfn-set-of-event-types-to-handle
sw.延長-済み~event集合:#dfn-set-of-extended-events
sw.すべての~fetch~listenerは空か:#service-worker-all-fetch-listeners-are-empty-flag
sw.~router規則~list:#service-worker-list-of-router-rules
sw.手続き~queue:#service-worker-service-worker-queue
sw.~sw~queue:#service-worker-service-worker-queue

~sw~event:#dfn-service-worker-events
~lifecycle~event:#dfn-lifecycle-events
機能的~event:#dfn-functional-events

~sw登録:#dfn-service-worker-registration
未登録にされて:#dfn-service-worker-registration-unregistered
非新鮮:#service-worker-registration-stale
表現する~sw登録:#serviceworkerregistration-service-worker-registration
swr.~storage~key:#service-worker-registration-storage-key
swr.~scope~URL:#dfn-scope-url
swr.~install中の~worker:#dfn-installing-worker
swr.待機-中な~worker:#dfn-waiting-worker
	~waiting:#dfn-waiting-worker-
swr.作動中な~worker:#dfn-active-worker
	＊作動中:#dfn-active-worker-
swr.最後の更新~検査-時刻:#dfn-last-update-check-time
swr.~cacheを介する更新~mode:#dfn-update-via-cache
swr.~back-up~task~list:#dfn-service-worker-registration-task-queue
swr.~NavigationPreloadManager:#service-worker-registration-navigationpreloadmanager
swr.~navi~preloadは可能化されるか:#service-worker-registration-navigation-preload-enabled-flag
swr.~navi~preload~header値:#service-worker-registration-navigation-preload-header-value

FE.応答になり得る:#fetchevent-potential-response
FE.~enteredで応答するか:#fetchevent-respond-with-entered-flag
FE.~errorで応答するか:#fetchevent-respond-with-error-flag
FE.応答するまで待機-中か:#fetchevent-wait-to-respond-flag

不良な~import~script応答:#dfn-bad-import-script-response

~job:#dfn-job
job.~storage~key:#job-storage-key
job.~job種別:#dfn-job-type
job.~scope~URL:#dfn-job-scope-url
job.~script~URL:#dfn-job-script-url
job.~worker種別:#dfn-job-worker-type
job.~cacheを介する更新~mode:#dfn-job-update-via-cache-mode
job.~client:#dfn-job-client
job.~referrer:#job-referrer
job.~job~promise:#dfn-job-promise
job.包含している~job~queue:#dfn-containing-job-queue
job.等価~job~list:#dfn-job-list-of-equivalent-jobs
job.~cacheを迂回するよう強制するか:#dfn-job-force-bypass-cache-flag
job.等価である:#dfn-job-equivalent
	sub.~job:#dfn-job-equivalent
~job~queue:#dfn-job-queue

~cache~batch演算:#dfn-cache-batch-operation
cbo.種別:#dfn-cache-batch-operation-type
cbo.要請:#dfn-cache-batch-operation-request
cbo.応答:#dfn-cache-batch-operation-response
cbo.~option群:#dfn-cache-batch-operation-options

~sw~client:#dfn-service-worker-client
~window~client:#dfn-window-client
専用~worker~client:#dfn-dedicatedworker-client
共用~worker~client:#dfn-sharedworker-client
~worker~client:#dfn-worker-client
破棄-済みか:#service-worker-client-discarded-flag

	＊~extendable:#dom-extendableevent-waituntil

存続期間を延長する~promise群:#extendableevent-extend-lifetime-promises
存続期間~promiseを追加する:#extendableevent-add-lifetime-promise
処理待ち~promise数:#extendableevent-pending-promises-count
eX.作動中:#extendableevent-active
時間切れか:#extendableevent-timed-out-flag

	他の仕様により拡張-可能:#extensibility
	~sw拡張:#extensibility
拡張:#extensibility

要請~応答~list:#dfn-request-response-list
関連な要請~応答~list:#dfn-relevant-request-response-list

登録~map:#dfn-scope-to-registration-map
名前から~cacheへの~map:#dfn-name-to-cache-map
関連な名前から~cacheへの~map:#dfn-relevant-name-to-cache-map
~scopeから~job~queueへの~map:#dfn-scope-to-job-queue-map

	名前→~cache~map:#dfn-name-to-cache-map
	関連な名前→~cache~map:#dfn-relevant-name-to-cache-map
	~scope→~job~queue~map:#dfn-scope-to-job-queue-map

大域~obj:#cachestorage-global-object
~fetchを取扱う~task~source:#dfn-handle-fetch-task-source
機能的~eventを取扱う~task~source:#dfn-handle-functional-event-task-source

制御-:#dfn-control
	＠#dfn-use
利用して:#dfn-use

cl.~sw~client:#dfn-service-worker-client-service-worker-client
cl.~frame種別:#dfn-service-worker-client-frame-type
cl.~sw:#_clients-service-worker
cl.生成元:#service-worker-client-origin
cl.閲覧~文脈:#dfn-service-worker-client-browsing-context
cl.可視性~状態:#dfn-service-worker-client-visibilitystate
cl.~focus状態:#dfn-service-worker-client-focusstate
cl.先祖~生成元~配列:#windowclient-ancestor-origins-array

~storage~keyが登録と同等な~client群:#_clients-with-storage-key-equals-to-registration

SWC.準備済み~promise:#serviceworkercontainer-ready-promise
SWC.~sw~client:#serviceworkercontainer-service-worker-client
	~associated:#serviceworkercontainer-service-worker-client-
SWC.~client~message~queue:#dfn-client-message-queue

SWG.~sw:#serviceworkerglobalscope-service-worker
SWG.~importする~script用には~cacheを迂回するよう強制するか:#serviceworkerglobalscope-force-bypass-cache-for-import-scripts-flag
SWG.競走~応答~map:#serviceworkerglobalscope-race-response-map

~event~handlerを定義-:#extension-to-service-worker-global-scope

enV.~sw~obj~map:#environment-settings-object-service-worker-object-map
enV.~sw登録~obj~map:#environment-settings-object-service-worker-registration-object-map
~sw~objを取得する:#get-the-service-worker-object
~sw登録~objを取得する:#get-the-service-worker-registration-object

~sw計時~報:#service-worker-timing-info
swT.開始~時刻:#service-worker-timing-info-start-time
swT.~fetch~event配送-時刻:#service-worker-timing-info-fetch-event-dispatch-time
swT.~worker~router評価~開始:#service-worker-timing-info-worker-router-evaluation-start
swT.~worker~cache検索~開始:#service-worker-timing-info-worker-cache-lookup-start
swT.~worker合致した~router~source:#service-worker-timing-info-worker-matched-router-source
swT.~worker最終-~router~source:#service-worker-timing-info-worker-final-router-source

競走~応答:#dfn-race-response
rV.値:#race-response-value
競走~結果:#dfn-race-result
rr.~route済み応答:#race-result-routed-response
rr.利用される~route:#race-result-used-route

~router条件を数えた結果:#dfn-count-router-condition-result
rcR.条件~計数:#dfn-count-router-condition-result-condition-count
rcR.~quotaを超過したか:#dfn-dfn-count-router-condition-result-quota-exceeded

	●algo
不可分に走らす:#_run-atomically

~jobを作成する:#create-job
~jobを~scheduleする:#schedule-job
~jobを走らす:#run-job
~jobを完遂する:#finish-job
~job~promiseを解決する:#resolve-job-promise
~job~promiseを却下する:#reject-job-promise
登録を開始する:#start-register
登録する:#register
登録-:#register
更新する:#update
~soft更新する:#soft-update
~installする:#install
作動化する:#activate
作動化するよう試行する:#try-activate
~swを走らす:#run-service-worker
すべての~fetch~listenerは空か？:#all-fetch-listeners-are-empty
~ServiceWorkerGlobalScopeを設定しておく:#setup-serviceworkerglobalscope
~fetch~eventを作成して配送する:#create-fetch-event-and-dispatch
~URL~patternを構文解析する:#parse-url-pattern
~router条件を検証yする:#verify-router-condition
~router条件を照合する:#match-router-condition
~router登録~上限を検査する:#check-router-registration-limit
~router内縁~条件~群を数える:#count-router-inner-conditions
~router~sourceを取得する:#get-router-source
競走~応答を検索する:#lookup-race-response
~swを終了する:#terminate-service-worker
終了-:#terminate-service-worker
終了n:#terminate-service-worker

~fetchを取扱う:#handle-fetch

~eventを飛ばすべきか？:#should-skip-event
機能的~eventを発火する:#fire-functional-event
~unload:#handle-service-worker-client-unload
~sw~clientを~unloadする:#handle-service-worker-client-unload
~UA~shutdownを取扱う:#handle-user-agent-shutdown
~sw延長-済み~event集合を更新する:#update-service-worker-extended-events-set
未登録に:#unregister
未登録にする:#unregister
登録を設定する:#set-registration
登録を~clearする:#clear-registration
登録を~clearするよう試行する:#try-clear-registration
登録の状態を更新する:#update-registration-state
~workerの状態を更新する:#update-worker-state
制御器の変化を通知する:#notify-controller-change
合致する~sw登録:#match-service-worker-registration
登録を取得する:#get-registration
最新な~workerを取得する:#get-newest-worker
~swには処理待ち~eventは無いか？:#service-worker-has-no-pending-events
~clientを作成する:#create-client
~window~clientを作成する:#create-window-client
~frame種別を取得する:#get-frame-type
~clientを取得する~promiseを解決する:#resolve-get-client-promise
~cacheを~queryする:#query-cache
要請は~cache済み~itemに合致するか？:#request-matches-cached-item
~cache演算を~batchする:#batch-cache-operations
非同期c~moduleか？:#is-async-module

	●用語 基盤（INFRA/PROMISES/DOM/URL/IDL
実装定義:~INFRA#implementation-defined
ときは中止する:~INFRA#abort-when
中止されたときは:~INFRA#if-aborted
~ASCII大小無視:~INFRA#ascii-case-insensitive
連結する:~INFRA#string-concatenate
符号単位~接頭辞:~INFRA#code-unit-prefix

map.値~群:~INFRA#map-getting-the-values
	~EACH:~INFRA#map-iterate
	~SET:~INFRA#map-set
~list:~INFRA#list
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
付加する:~INFRA#list-append
拡張する:~INFRA#list-extend
~cloneする:~INFRA#list-clone
	~INFRA#list-iterate

~byte列:~INFRA#byte-sequence
	~IN:~INFRA#list-contain
byte.長さ:~INFRA#byte-sequence-length
同型に符号化する:~INFRA#isomorphic-encode
map.~key群:~INFRA#map-getting-the-keys
~item:~INFRA#list-item
除去する:~INFRA#list-remove
集合:~INFRA#ordered-set
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~queue:~INFRA#queue
~enqueueする:~INFRA#queue-enqueue
~dequeueする:~INFRA#queue-dequeue

構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
~tuple:~INFRA#tuple

有順序~map:~INFRA#ordered-map
map.~entry:~INFRA#map-entry
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
map.存在-:~INFRA#map-exists
map.除去する:~INFRA#map-remove
map.~clearする:~INFRA#map-clear

~event:~DOM4#concept-event
ev.配送-中か:~DOM4#dispatch-flag
ev.取消されたか:~DOM4#canceled-flag
ev.伝播を即時に停止するか:~DOM4#stop-immediate-propagation-flag
ev.伝播を停止するか:~DOM4#stop-propagation-flag
~eventを作成する:~DOM4#concept-event-create
~eventを発火する:~DOM4#concept-event-fire
~eventを配送する:~DOM4#concept-event-dispatch
配送-:~DOM4#concept-event-dispatch
~event~listener:~DOM4#concept-event-listener
evL.~callback:~DOM4#event-listener-callback
~sw~fetch~event~listener~callback群を得する旧来の手続き:~DOM4#legacy-obtain-service-worker-fetch-event-listener-callbacks
aC.中止-を通達する:~DOM4#abortcontroller-signal-abort
文書:~DOM4#concept-document
doc.生成元:~DOM4#concept-document-origin
aC.通達:~DOM4#abortcontroller-signal

~URL:~URL1#concept-url
同等な~URL:~URL1#concept-url-equals
url.生成元:~URL1#concept-url-origin
url.~path:~URL1#concept-url-path
url.~scheme:~URL1#concept-url-scheme
url.~query:~URL1#concept-url-query
url.素片:~URL1#concept-url-fragment
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer

新たな~obj:~WEBIDLjs#new
新たな~promise:~WEBIDLjs#a-new-promise
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決される~promise:~WEBIDLjs#a-promise-resolved-with
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
すべてを待機する~promiseを取得する:~WEBIDLjs#waiting-for-all-promise
充足-時:~WEBIDLjs#upon-fulfillment
却下-時:~WEBIDLjs#upon-rejection
~promiseに反応する:~WEBIDLjs#dfn-perform-steps-once-promise-is-settled
~JS値に変換する:~WEBIDLjs#dfn-convert-idl-to-javascript-value
~buffer~sourceを作成する:~WEBIDLjs#_buffersource-create

例外:~WEBIDL#dfn-exception
新たな例外:~WEBIDL#dfn-create-exception
	廃）~message:~WEBIDL#dfn-exception-message
	~THROW:~WEBIDL#dfn-throw
部分的~interface:~WEBIDL#dfn-partial-interface
凍結d配列:~WEBIDL#dfn-frozen-array-type
凍結d配列を作成する:~WEBIDLjs#dfn-create-frozen-array
~callback~interface:~WEBIDL#dfn-callback-interface

	●用語 FETCH
~method:~FETCH#concept-method
禁止~method:~FETCH#forbidden-method
~methodを正規化する:~FETCH#concept-method-normalize

Rq.要請:~FETCH#concept-request-request
Rq.~Headers:~FETCH#request-headers
Rs.応答:~FETCH#concept-response-response
	Rs.~Headers:~FETCH#response-headers
Bd.利用-不能:~FETCH#body-unusable

bd.~source:~FETCH#concept-body-source

要請:~FETCH#concept-request
要請を~cloneする:~FETCH#concept-request-clone
rq.本体:~FETCH#concept-request-body
rq.~mode:~FETCH#concept-request-mode
rq.~cache~mode:~FETCH#concept-request-cache-mode
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.~header~list:~FETCH#concept-request-header-list
rq.起動元:~FETCH#concept-request-initiator
rq.~method:~FETCH#concept-request-method
rq.生成元:~FETCH#concept-request-origin
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.応答~tainting:~FETCH#concept-request-response-tainting
rq.置換する~client~ID:~FETCH#concept-request-replaces-client-id
rq.~URL:~FETCH#concept-request-url
rq.~sw~mode:~FETCH#request-service-workers-mode
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
	廃）rq.同期~flag:~FETCH#synchronous-flag
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag

応答:~FETCH#concept-response
rs.~CORSに公開される~header名~list:~FETCH#concept-response-cors-exposed-header-name-list
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.種別:~FETCH#concept-response-type
rs.中止されたか:~FETCH#concept-response-aborted
rs.~sw計時~報:~FETCH#response-service-worker-timing-info
rs.本体~報:~FETCH#concept-response-body-info

fT.符号化された~size:~FETCH#fetch-timing-info-encoded-body-size
fT.復号した~size:~FETCH#fetch-timing-info-decoded-body-size

直列化された中止-事由:~FETCH#fetch-controller-serialized-abort-reason
直列化された中止-事由を逆直列化する:~FETCH#deserialize-a-serialized-abort-reason
~Request~objを作成する:~FETCH#request-create
~Response~objを作成する:~FETCH#response-create
~headerを付加する:~FETCH#concept-header-list-append
hl.~guard:~FETCH#concept-headers-guard
~header~listから~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
hd.名前:~FETCH#concept-header-name
hd.値:~FETCH#concept-header-value

~header~listから値を取得する:~FETCH#concept-header-list-get
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split

~navi要請:~FETCH#navigation-request
非~下位資源~要請:~FETCH#non-subresource-request
下位資源~要請:~FETCH#subresource-request

~CORS絞込み応答:~FETCH#concept-filtered-response-cors
基本~絞込み応答:~FETCH#concept-filtered-response-basic
絞込み応答:~FETCH#concept-filtered-response
内部~応答:~FETCH#concept-internal-response
不透明~redirect絞込み応答:~FETCH#concept-filtered-response-opaque-redirect
不透明な絞込み応答:~FETCH#concept-filtered-response-opaque
	i.応答の処理n:~FETCH#process-response
	i.応答の本体~終了~時の処理n:~FETCH#fetch-processresponseendofbody
	応答の本体終端を処理する:~FETCH#process-response-end-of-body
	i.応答の本体を消費する処理n:~FETCH#process-response-end-of-body

~header~listから値を抽出する:~FETCH#extract-header-list-values
~fetchする:~FETCH#concept-fetch
~fetch:~FETCH#concept-fetch
~header:~FETCH#concept-header
~HTTP~fetch:~FETCH#concept-http-fetch
~network~error:~FETCH#concept-network-error
~ok状態s:~FETCH#ok-status

本体:~FETCH#concept-body
~stream:~FETCH#concept-body-stream
名前に持つ~header:~FETCH#_headers-of-name
応答を~cloneする:~FETCH#concept-response-clone
~cache状態:~FETCH#concept-response-cache-state
非同一-生成元~資源~施策~検査:~FETCH#cross-origin-resource-policy-check


~fetch制御器:~FETCH#fetch-controller
fC.状態:~FETCH#fetch-controller-state
~fetchを中止する:~FETCH#fetch-controller-abort
fP.取消された:~FETCH#fetch-params-canceled

	●用語 HTML

enV.~ID:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中な~sw:~WAPI#concept-environment-active-service-worker
enV.実行は準備済みか:~WAPI#concept-environment-execution-ready-flag
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.担当の~event~loop:~WAPI#responsible-event-loop
	廃）enV.担当の文書:~WAPI#responsible-document
enV.~API用~基底~URL:~WAPI#api-base-url
enV.生成元:~WAPI#concept-settings-object-origin
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.大域~obj:~WAPI#concept-settings-object-global
enV.~realm:~WAPI#environment-settings-object's-realm
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~secureな文脈:~WAPI#secure-context
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.時刻~起点:~WAPI#concept-settings-object-time-origin


gL.~realm:~WAPI#concept-global-object-realm
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
古典~script:~WAPI#classic-script
現在の大域~obj:~WAPI#current-global-object
環境:~WAPI#environment
環境~設定群~obj:~WAPI#environment-settings-object
環境を破棄する手続き:~WAPI#environment-discarding-steps
~event~handler:~WAPI#event-handlers
eH.~listener:~WAPI#event-handler-listener
eH.値:~WAPI#event-handler-value
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler~map:~WAPI#event-handler-map
~event~loop:~WAPI#event-loop
aG.~event~loop:~WAPI#concept-agent-event-loop
~worker用~古典~scriptを~fetchする:~WAPI#fetch-a-classic-worker-script
~module~worker~script~graphを~fetchする:~WAPI#fetch-a-module-worker-script-tree
~workerが~importした古典~scriptを~fetchする:~WAPI#fetch-a-classic-worker-imported-script
現任な設定群~obj:~WAPI#incumbent-settings-object
	%~top-levelか:~WAPI#fetching-scripts-is-top-level
sC.~record:~WAPI#concept-script-record
sC.基底~URL:~WAPI#concept-script-base-url
~module指定子を解決する:~WAPI#resolve-a-module-specifier
~module~map:~WAPI#module-map
~module~script:~WAPI#module-script
~fetch~hookを遂行する~algo:~WAPI#fetching-scripts-perform-fetch
小taskを~queueする:~WAPI#queue-a-microtask
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
	~re-queues~those~tasks:~WAPI#queue-a-task
古典~scriptを走らす:~WAPI#run-a-classic-script
~module~scriptを走らす:~WAPI#run-a-module-script
走っている~scriptを中止する:~WAPI#abort-a-running-script
~script:~WAPI#concept-script
	＊~source~text:~WAPI#concept-classic-script-source-text
~task~source:~WAPI#task-source
tK.~source:~WAPI#concept-task-source
tK.手続き:~WAPI#concept-task-steps
tK.文書:~WAPI#concept-task-document
利用者ヤリトリ~task~source:~WAPI#user-interaction-task-source
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue
新たな~realmを作成する:~WAPI#creating-a-new-javascript-realm
~sw~agentを得する:~WAPI#obtain-a-service-worker-agent

~navigable:~HTMLds#navigable
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
nav.親:~HTMLds#nav-parent
nav.作動中な文書:~HTMLds#nav-document
~node~navigable:~HTMLds#node-navigable
全部的に作動中:~HTMLds#fully-active
閲覧~文脈:~HTMLds#browsing-context
bc.作動中な文書:~HTMLds#active-document
bc.作動中な~window:~HTMLds#active-window
bc.対応する~navigable:#_bc-navigable
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
新たな~top-level閲覧~文脈と文書を作成する:~HTMLds#creating-a-new-top-level-browsing-context
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
閲覧~文脈が作成され:~HTMLds#creating-a-new-browsing-context

対応する閲覧~文脈:~WINDOW#window-bc
対応する~navigable:~WINDOW#window-navigable
wC.作成-:~WINDOW#set-up-a-window-environment-settings-object
結付けられた文書:~WINDOW#concept-document-window

先祖~生成元~list:~WINDOW#concept-location-ancestor-origins-list
先祖~生成元~文字列~list:#_document-location-ancestor-origins-list

~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navigateする:~HTMLnav#navigate
~navi~algo:~HTMLnav#navigate
~navigate:~HTMLnav#navigate
~navi:~HTMLnav#navigate
	i.履歴~取扱い:~HTMLnav#navigation-hh
	i.例外を可能化するか:~HTMLnav#exceptions-enabled
文書~unload時の片付け手続き:~HTMLlifecycle#unloading-document-cleanup-steps
hH.replace:~HTMLnav#navigationhistorybehavior-replace

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
同一-生成元:~ORIGIN#same-origin
sub.生成元:~ORIGIN#same-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
施策~容器:~ORIGIN#policy-container
~fetch応答から施策~容器を作成する:~ORIGIN#creating-a-policy-container-from-a-fetch-response

wG.施策~容器:~WORKERS#concept-workerglobalscope-policy-container
wG.種別:~WORKERS#concept-workerglobalscope-type
wG.~URL:~WORKERS#concept-workerglobalscope-url
wG.~close中か:~WORKERS#dom-workerglobalscope-closing
wG.~module~map:~WORKERS#concept-workerglobalscope-module-map
wG.作成-:~WORKERS#set-up-a-worker-environment-settings-object
wG.非同一-生成元~能力は隔離されるか:~WORKERS#concept-workerglobalscope-cross-origin-isolated-capability
wG.非同一-生成元~能力は隔離-済みか:~WORKERS#concept-workerglobalscope-cross-origin-isolated-capability

所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set
~web~worker:~WORKERS#workers
~scriptを~worker大域~scopeの中へ~importする:~WORKERS#import-scripts-into-worker-global-scope
	~scriptを~worker大域~scopeの中に取込む
~workerを走らす:~WORKERS#run-a-worker

並列的:~HTMLINFRA#in-parallel
並列~queue:~HTMLINFRA#parallel-queue
手続きを~enqueueする:~HTMLINFRA#enqueue-the-following-steps

作動中な~timer群が成す~map:~HTMLGAPI#map-of-active-timers

安全でない応答:~HTMLurl#unsafe-response
文書~基底~URL:~HTMLurl#document-base-url

~focusされ:~HTMLinteraction#focusing-steps
~objを~focusする:~HTMLinteraction#focusing-steps
~focusを有するか？:~HTMLinteraction#has-focus-steps
一過な作動化を有して:~HTMLinteraction#transient-activation

~sandbox化:~HEembed#attr-iframe-sandbox

	●用語 stream
~chunk:~STREAMS#chunk
読取n要請:~STREAMS#read-request
rR.~chunk手続き:~STREAMS#read-request-chunk-steps
rR.~close手続き:~STREAMS#read-request-close-steps
rR.~error手続き:~STREAMS#read-request-error-steps

RS.取消す:~STREAMS#readablestream-cancel
RS.設定しておく:~STREAMS#readablestream-set-up
RS.読取器を取得する:~STREAMS#readablestream-get-a-reader
RS.~errorにする:~STREAMS#readablestream-error
RS.~lockされて:~STREAMS#readablestream-locked
RS.妨げられて:~STREAMS#is-readable-stream-disturbed
RS.~errorした:~STREAMS#readablestream-errored
RS.~closeする:~STREAMS#readablestream-close
RS.~chunkを~enqueueする:~STREAMS#readablestream-enqueue

RSR.取消す:~STREAMS#readablestreamdefaultreader-cancel
RSR.すべての~byteを読取る:~STREAMS#readablestreamdefaultreader-read-all-bytes
RSR.~chunkを読取る:~STREAMS#readablestreamdefaultreader-read-a-chunk

	●用語他

~blob~URL:~FILEAPI#blob-url

jA.DetachArrayBuffer:~TC39#sec-detacharraybuffer
jA.IsCallable:~TC39#sec-iscallable
jA.StructuredDeserializeWithTransfer:~HTMLcloning#structureddeserializewithtransfer
jA.StructuredSerializeWithTransfer:~HTMLcloning#structuredserializewithtransfer
jA.ThrowCompletion:~TC39#sec-throwcompletion
jA.NormalCompletion:~TC39#sec-normalcompletion

sl.Call:~TC39#sec-ecmascript-function-objects-call-thisargument-argumentslist
Completion:~TC39#sec-completion-record-specification-type
中途完了:~TC39#sec-completion-record-specification-type
完了~record:~TC39#sec-completion-record-specification-type
~agent:~TC39#agent
~surrounding~agent:~TC39#surrounding-agent
~module~record:~TC39#sec-abstract-module-records
循環な~module~record:~TC39#sec-cyclic-module-records

~promise:~TC39#sec-promise-objects
関数~本体:~TC39#prod-FunctionBody
	~List:~TC39#sec-list-and-record-specification-type
		→ ~list:~INFRA#list
	~Record:~TC39#sec-list-and-record-specification-type
	~ECMAScript~6~Map~objs:~TC39#sec-map-objects

信用-済みな型に準拠する文字列を取得する:~TRUSTED-TYPES#abstract-opdef-get-trusted-type-compliant-string

~JS~MIME型:~MIMESNIFF#javascript-mime-type

~URL~pattern:~URLPATTERN#url-pattern
~Web~IDL値から~URL~patternを築く:~URLPATTERN#build-a-url-pattern-from-a-web-idl-value
~regexp~groupを有して:~URLPATTERN#url-pattern-has-regexp-groups
~patternを照合する:~URLPATTERN#url-pattern-match

時刻を粗化する:~HRTIME#dfn-coarsen-time
粗化した共有される現在の時刻:~HRTIME#dfn-coarsened-shared-current-time
安全でない共有される現在の時刻:~HRTIME#dfn-unsafe-shared-current-time

~storage~key:~STORAGE#storage-key
同等な~storage~key:~STORAGE#storage-key-equal
~storage~keyを得する:~STORAGE#obtain-a-storage-key

大域~obj用に~CSP初期化を走らす:~CSP3#run-global-object-csp-initialization

信用に価し得る~URL:~SECURE-CONTEXT#potentially-trustworthy-url
信用に価し得る生成元か？:~SECURE-CONTEXT#potentially-trustworthy-origin

	:~SECURE-CONTEXT#threat-risks
	:~SECURE-CONTEXT#localhost

	~example:~NOTIFICATIONS#activating-a-notification
	~reported~that~several属性:http://alistapart.com/article/application-cache-is-a-douchebag
	~unrecoverable~errors:http://alistapart.com/article/application-cache-is-a-douchebag#section6

r.ABNF:#biblio-rfc5234

	Notifications~API:#biblio-notifications
	Inline In Spec:#issues-index

	:https://github.com/whatwg/fetch/issues/376
	:https://developer.chrome.com/extensions/background_pages
	:https://developer.chrome.com/extensions/event_pages
	:https://w3c.github.io/ServiceWorker/v1/
	:#execution-context-events
	:https://w3c.github.io/push-api/#dfn-fire-the-push-event
	:~NOTIFICATIONS#activating-a-notification
	:~NOTIFICATIONS#closing-a-notification
	:https://wicg.github.io/BackgroundSync/spec/#fire-a-sync-event
	:https://w3c.github.io/payment-handler/#dfn-handling-a-canmakepaymentevent
	:https://w3c.github.io/payment-handler/#dfn-handling-a-paymentrequestevent

	§ 3.1.2~scriptURL:#service-worker-url

	●

●●words_table1
PROMISES:promises-guide-ja.html
URLPATTERN:urlpattern-ja.html

postMessageClient:postMessage
postMessageSW:postMessage
example-bob:www.example.com/~bob
example-alice:www.example.com/~alice

●●words_table

max:
NavigationPreloadManager:
	-:Unicode

close:
	~close法:closing
	~close中:closing
open:
開く:openする:~
database::::データベース
dump::::
entered::::
	旧来の~event:Legacy
	機能的~event:Functional
	~lifecycle~event:Lifecycle

geolocation:
gyroscope:
import:
	~import済み:imported
	importScripts:importscripts
上位path:upper path:上位 path::上位パス

	~plugin:plug-in
schema::::スキーマ
guard::::ガード
quota::::クォータ
soft::::ソフト

	●構造／関係

agent:
束ねら:tieさ::~
束ねる:tieする::~
	bound
	対応-:correspond
作成元:creator::~
循環な:cyclicな::~
深さ:depth::~

	●data型／操作
chunk::::チャンク
	~byte列として一致:byte-for-byte identical
	byte列:bytes
	~messageをやりとり:messaging
number:
逆直列化-:deserialize::~::逆シリアル化
新-:new::~
作成時の:creation::~
増分:increment::~
減分:decrement::~
連結-:concatenate::~
regexp:
正規表現:regular expression::~

	追加する:addする:付加する
	〜を成す~byte列:subsequence

	●navi／network／fetch
	~serve法:serving
tainting:
Vary:
http:
https:
load:
port:
CDN:
	~HTTP／~HTTPS:HTTP(S)
	~network用:networking
	~Headers:
Request:
Response:
offline::::オフライン
本体終端:end-of-body::~
	非~下位資源:non-subresource
端点:endpoint::~
	〜で応答する:respond-with
絞込み:filtered::~
unload:
	未読込みに:unload::未読み込みに
blob:
	経由して:routed through
router::::ルーター
route::::ルート
競走:race::~
負荷分散-:offload::~

	●保安／Realm
	~secureでない:insecure
XSS:cross-site scripting:XSS
COEP:
	更新-済み:updated
消失-:disappear::~
脅威:threat::~
	攻撃を永遠に引き伸ばす:to turn a bad day into a bad eternity
策:strategy::~
補助:auxiliary::~
現任:incumbent::~
防御-:defend::~
directory::::ディレクトリ
硬い:hardな:~
	各区分:segments

	●処理
ServiceWorkerGlobalScope:
機能的:functional::~
機能-:function::~
	機能し続ける:remain functional
設定up:setup::設定
commit::::コミット
back-up:
batch::::バッチ
cast:
	~catchされなかった:uncaught
dummy::::
install:
installation:
job:
kill:
lifecycle:
存続期間:lifetime::~
ok:
pipe::::パイプ
preload::::
restart::::
schedule::::スケジュール
shutdown::::
	単-~threadな:single-threaded
timer::::タイマー
延長-:extend::~
延長:extension::~
	延長-済み:extended
	延命
処理待ち:pending::~
決着-:settle::~
	決着していない:pending
	ABRUPT:Rethrow any exceptions
	~~手続き的:procedural
動作者:actor::~::アクター
	:completion
失効-:expire::~
稼働時:runtime::~
稼働時の:runtime::~
待機:waiting::~
	待機-中な:waiting
中止:aborted::~
冗長:redundant::~
入口:entry point::~
	これまでに評価された:has ever been evaluated
	追跡し放題になり得る:potential unsanctioned tracking
	追跡できる:may be tracked at 
	:invocation
回復-:recover::~
	回復-不能:unrecoverable
不可分:atomic::~
小task:microtask:小 task:小タスク
迂回-:bypass::~
妨げら:disturbさ::~
限界水位:high water mark::~
生存-:alive::~
	生存し続け:keep-alive
時間切れ:timed out::~
制限付き:limited:~
	時間~制限付き:time-limited
復旧-:restore::~
持続-:persist::~
持続的:persistent::~
中途完了:abrupt completion::~
再始動:restart:~
期限切れの:outdated:~
近過去:recent:~
一掃-:purge:~
予備:backup::~
退避:backup::~
巻戻す:roll backする:巻き戻す
非新鮮:stale::~
片付け:cleanup:~
高分解能:high resolution::~
起点:origin::~
粗化-:coarsen:粗く
検索-:lookup:~
検索:lookup:~
並列:parallel::~
指数関数的:exponential:~
数えて:countして:~
数えた:countした:~
数える:countする:~
計数:count:~
最終-:final:~

	none:-
	却下-時:upon rejection
	同時に:simultaneous
	配送-後:post-dispatch
	阻むこと:blocking
	他を阻む:blocking
	待機を飛ばす:skip waiting
	早々に ~RETする:enforces early return
	最初期:very first
	滅する:die
	外でも生きられる:may outlive
	渡せる／渡して／渡され:pass
	ある種の時点を指す時刻:certain points in time
	以前に成功したはず:must have been previously successful

	●仕様
	:optional
有効:effective:~
有意味な:meaningful:意味のある
即応的:responsive:~
後継:successor:~
現象:phenomenon:~
柔軟性:flexibility:~
異常:abnormal:~
馴染みの:familiarな:~
馴染んで:familiarで:~
細分化:ramifications:~
協同:collaboration:~
傾向:tend:~
根拠:rationale:~
独特:unique:~
理想的:ideal:~
寄与-:contribute:~
未実装な:unimplemented:~
未利用な:unused:~
上限:limit:~
懸念点:concerns:~
昇格:upgrade::~
	~~昇格:promote
警告:warning:~
運用-:operate:~
	ずに済む:avoid
相対性:relativity:~
相互運用-:interoperate:~
解く:solveする:~
解決策:solution:~
保つ:keepする:~
利点:advantage:~
先進的:advanced:~
温存-:conserve:~
起因-:arise:~
成就-:attain:~
助ける:helpする:~
分類:category:~
改築-:architect::~
	改築し直す:re-architecting
集中型の:centralized:~
普通は:ordinaalには:~
禁制-:prohibit:~
排他的:exclusive:~
最小限:minimal:~
過度:excessive:~

	前方-互換にする:forward compatibility across
	不良でない:good
	program的:programmatical
	可能性／可能性もある:possibilities／possible
	なり得る／:potential
	必要性:necessity
	~~足らない:deficit of
	比して:versus
	付き物の~~障害:hazards
	と引き換えに at the price of
	~~高度に:highly
	頭に入れておく:keep in mind
	満たす:satisfy
	不利な所:place 〜at a disadvantage
	不利を塗り替える:redress this balance
	限るようにする:make sure
	得られるようにする:enables applications to take
	決定可能な:deterministically
	至る所で:pervade
	面し:face
	大きな糧に:borrows heavily from
	~~同等以上なもの:bear more than a passing resemblance to
	留意-:note
	~~重点:key
	~~主要:key
	学び:lesson
	最も懸案:top-of-mind
	sure
	下位節:subsections
	sw:Service Worker
	関心:interest
	応じて:depend
	により定義される:-defined
	進んで:advancing
	~~強調-:accentuate
	多用する:use ~ heavily
	勧める:advised to
	捉えれる:can be thought of
	必要がある:implies
	起こされる:wake
	観測される〜が:observably
	理解し易く:ease of understanding
	ようにする:for making

	●未分類
派生-:derive::~
	伴わせる:present
書込n:write::書き込み
書込まれ:writeされ::書き込まれ
	ε:omitted
超過-:exceed::~
遭遇-:encounter::~
生きた:living::~
聴取-:audit:~
喪失:loss:~
refresh:
bootstrap:
surrounding:
main::::メイン
総和:sum::~
特質:property:~:::プロパティ
同等:equal:~
	等し:equal
administrator::::サーバ管理者
高価:expensive::~
disk::::ディスク
一過:transient::~
最新:newest::~

	最大:maximum
	Chromium
	PWA
	置いて:put
	予約-済み:reserved
	~debugし易くする:aid debugging
	座して:sits in
	〜になる:progress
	選ぶ:choose
	come
	met
	note
	put
	-:exactly what
	等:or equivalent
	末尾:end〜trailing
	-:byte-to-byte
	旧:old

	~~広範な:broad class
	~~付随:attach
	-:back of
	-:balance
	^en:head-of-line blocking
	~GOTO:Jump to the step labeled
	秒:second
	秒間に何度も:many times second
	利用した~script群:usedSet
	`undefined^jv:undefined
	〜外に:off-〜
	~path構造に:path-structural
	〜で連結する:separated from each other by 〜
	〜側の:-side
	価しない:Not Trusted
	壊れた:broke／broken
	山括弧:angle brackets
	-:undo
	委ねられ:resorting
	~~指示する:denote
	最終的に:eventually 
	旧来の~event:Legacy
	機能的~event:Functional
	~lifecycle~event:Lifecycle
	-:placed before／:placed first／:placed next
	~WHILE:repeatedly
	^en:spin-off
	作成されることになる:to-be-created
	-:unassociate
	:long
	互いに:mutually
	ずっと少ない:much less
	~~減らす:less
	~~増やす:more
	なる限り:as long as

	新たな:newly created
	-:original
	概ね:more or less
	多様な:many sorts of
	いくつかの:some
	一種:type
	互いに別々の:separated
	間に狭んで:put 〜 between
	いくつ〜も:many
	から来た:come~from
	外にある
	この類の:sort of
	向けての:toward
	いつでも:at 〜 any time
	以前／従来／これまで／:previous
	時点:moment
	それ自体:in and of itself
	再び:re-
	一部:part of
	初回:first time
	まったく:ever
	~per
	ほぼ:nearly
	neither
	nor
	now
	〜外にある:off-
	他所:other places
	rest
	幅広く:largely:#1
	全体を通して:throughout
	ほぼすべて:almost entirely
	毎回:every time
	何度でも:as often as it likes
	-:remaining
	を~~対象に:against
	またがって:across
	後続して:subsequently
	いずれにせよ:anyway
	まるごと／全体的にentirely
	後続の／従って:following
	広範な:a range of
	早々に:early
	下位:sub
	頭部:beginning
	頭部:starting
	の頭部は〜に一致する:starts with
	個数／〜数:count
	最長の:longest
	大多数の:major
	残り:rest
	非同期~拡張を待機する^i:WaitForAsynchronousExtensions
	総数:total number

	●変数
最大-:max:~
or:
not:
ナマ:raw:生
	%~target~realm:targetRealm
	%~cacheは存在するか:cacheExists
	%~cacheを介する更新:updateViaCache
	%~cache名:cacheName
	%~cache済み~URL:cachedURL
	%~cache済み応答:cachedResponse
	%~cache済み要請:cachedRequest
	%~cache~key群:cacheKeys
	%~event構築子:eventConstructor
	%初期化:initialization
	%配送-後~手続き:postDispatchSteps
	%~client~URL:clientURL
	%~client~URL文字列:clientURLString
	%~client~obj:clientObject
	%~client~obj群:clientObjects
	%~clientは列挙-可能か:isClientEnumerable
	%~dummy~stream:dummyStream
	%~event:e
	%~eventは取消されたか:eventCanceled
	%~event型:eventType
	%~event名:eventName
	%~event~handler:eventHandler
	%~event~listener~callback群:eventListenerCallbacks
	%~event~listener~callback:eventListenerCallback
	%~fetchを取扱うのに失敗したか:handleFetchFailed
	%~fetch制御器:fetchController
	%~fetch制御器~群:fetchControllers
	%~fetch結果:fetchResult
	%~install中の~worker:installingWorker
	%~installに失敗したか:installFailed
	%~job:Job
	%~job型:jobType
	%最大-~scope:maxScope
	%最大-~scope文字列:maxScopeString
	-:messageClone
	%~navi~preload応答:navigationPreloadResponse
	%~preload応答~promise:preloadResponse
	%~preload応答~obj:preloadResponseObject
	%~preload要請:preloadRequest
	%~preload要請~header群:preloadRequestHeaders
	%~promise:Promise
	%~realm実行~文脈:realmExecutionContext
	%~storage~key:storage key
	%~entry~storage~key:entry storage key
	%~entry~scope:entry scope
	%~client~storage~key:client storage key
	%~scope~URL:scopeURL
	%~scope文字列:scopeString
	%~scope文字列~集合:scopeStringSet
	%~script~URL:scriptURL
	%~source設定群:sourceSettings
	%~sw:serviceWorker
	%~sw大域~scope:serviceWorkerGlobalScope
	%~sw登録:serviceWorkerRegistration
	%~sw~event~loop:serviceWorkerEventLoop
	%~target~client群:targetClients
	%~target~client:targetClient
	%~target~storage:targetStorage
	%~target~realm:targetRealm
	-:thisArgument
	%~window~client:windowClient
	%~worker~event~loop:workerEventLoop
	%~worker~obj:workerObject
	%~worker種別:workerType
	%~worker大域~scope:workerGlobalScope
	%予約-済み~client:reservedClient
	%作動中な~worker:activeWorker
	%合致した~client群:matchedClients
	%合致している~scope:matchingScope
	%合致している~scope文字列:matchingScopeString
	%大域~obj:globalObject
	%応答:response
	%応答~群／%応答~list:responses
	%応答~obj~list:responseList
	%~enteredで応答するか:respondWithEntered
	%応答~promise:responsePromise
	%応答~配列~promise:responseArrayPromise
	%応答になり得る:potentialResponse
	%新-~stream:newStream
	%新-文脈:newContext
	%新たな~port群:newPorts
	%最新~worker:newestWorker
	%最後の~job:lastJob
	%合致したか:isMatched
	%登録:registration
	%登録~obj群:registrationObjects
	%登録~obj:registrationObject
	%等価な~job:equivalentJob
	%結果~promise:resultPromise
	%結果~配列:resultArray
	%要請~URL:requestURL
	%要請~URL文字列:requestURLString
	%要請~応答:requestResponse
	%要請~応答~配列:requestResponseArray
	%内縁~要請:innerRequest
	%設定群~obj:settingsObject
	%設定群~obj群:settingsObjects
	%許容される~sw:serviceWorkerAllowed
	%直列化した転送-結果:serializeWithTransferResult
	%追加される~item群:addedItems
	%逆直列化-~record:deserializeRecord
	%演算~群:operations
	%演算:operation
	%-:convertedValue
	%等価な~job:equivalentJob
	%可視性~状態:visibilityState
	%~focus状態:focusState
	%先祖~生成元~list:ancestorOriginsList
	%閲覧~文脈:browsingContext
	%~navigable:navigable
	%要請~応答:requestResponse
	%予備~cache:backupCache
	%要請~list:requests
	%要請~list:requestList
	%要請~obj:requestObject
	%要請~obj~list:requestList
	%~cache~job~promise:cacheJobPromise
	%~error:-
	%~error:error
	%~error~data:errorData
	%資源を更新したか:hasUpdatedResources
	%ある~prop名:propertyName
	%別の~prop名:%anotherPropertyName
	%配送した~event:dispatchedEvent
	%~size~algo:sizeAlgorithm
	%走らせた結果:runResult
	%~obj~map:objectMap
	%現任な大域~obj:incumbentGlobal
	%評価~状態s:evaluationStatus
	%評価~promise:evaluationPromise
	%開始に失敗したか:startFailed
	%~soft更新すべきか:shouldSoftUpdate
	%~cacheを迂回するよう強制するか:forceBypassCache
	%~worker~realm:workerRealm
	%取扱った~event:eventHandled
	%~pull~algo:pullAlgorithm
	%読取n要請:readRequest
	%本体終端か:end-of-body
	%取消~algo:cancelAlgorithm
	%限界水位:highWaterMark
	%読取器:reader
	%~size~algo:sizeAlgorithm
	%~URL:url
	%施策~容器:policyContainer
	%高分解能な処理能~timerを利用するか:useHighResPerformanceTimers
	%計時~報:timingInfo
	%~record:record
	%~module~map:moduleMap
	%要請された~module:requested
	%seen:seen
	%安全でない作成~時刻:unsafeCreationTime
	%~preload~fetch制御器:preloadFetchController
	%逆直列化された~error:deserializedError
	%中止-制御器:abortController
	%~router規則~群:allRules
	%~router規則~群:routerRules
	%~route済み応答:routedResponse
	%規則:rule
	%設定upに失敗したか:setupFailed
	%大域~obj:globalObject
	%~agent:agent
	%規則:-
	%~source:source
	%~cache:cache
	%~queue:queue
	%競走~fetch制御器:raceFetchController
	%競走~応答:raceResponse
	%競走~応答:entry
	%競走~network要請に対する応答:raceNetworkRequestResponse
	%競走~network結果:raceNetworkResult
	%競走~fetch~handler結果:raceFetchHandlerResult
	%~fetch~handler応答:fetchHandlerResponse
	%ナマ~pattern:rawPattern
	%基底~URL:baseURL
	%条件:condition
	%条件は在るか:hasCondition
	%~or条件~群:orConditions
	%~or条件:orCondition
	%~not条件:-
	%~method:-
	%~method:method
	%~mode:mode
	%行先:destination
	%走っているか否か:runningStatus
	%完了-時の手続き:onComplete
	%~fetchを遂行する:performFetch
	%存続期間~promise:lifetimePromise
	%結果:result
	%深さ:depth
	%~network~error:networkError

	TODO
	＊%~custom~fetch応答の処理n:processCustomFetchResponse
	応答の本体を消費する処理n:processResponseConsumeBody

●●ref_normative

[CSP-NEXT]
    ＜Scripting Policy＞. Editor's Draft. URL: https://wicg.github.io/csp-next/scripting-policy.html
[CSP3]
    Mike West; Antonio Sartori. ＜Content Security Policy Level 3＞. URL: https://w3c.github.io/webappsec-csp/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[FileAPI]
    Marijn Kruisselbrink. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MIMESNIFF]
    Gordon P. Hemsley. ＜MIME Sniffing Standard＞. Living Standard. URL: https://mimesniff.spec.whatwg.org/
[NAVIGATION-TIMING-2]
    Yoav Weiss; Noam Rosenthal. ＜Navigation Timing Level 2＞. URL: https://w3c.github.io/navigation-timing/
[PAGE-LIFECYCLE]
    ＜Page Lifecycle＞. Draft Community Group Report. URL: https://wicg.github.io/page-lifecycle/
[RESOURCE-TIMING]
    Yoav Weiss; Noam Rosenthal. ＜Resource Timing＞. URL: https://w3c.github.io/resource-timing/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[RFC5234]
    D. Crocker, Ed.; P. Overell. ＜Augmented BNF for Syntax Specifications: ABNF＞. January 2008. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc5234
[RFC7230]
    R. Fielding, Ed.; J. Reschke, Ed.. ＜Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing＞. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html
[RFC7231]
    R. Fielding, Ed.; J. Reschke, Ed.. ＜Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content＞. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7231.html
[SCREEN-CAPTURE]
    Jan-Ivar Bruaroey; Elad Alon. ＜Screen Capture＞. URL: https://w3c.github.io/mediacapture-screen-share/
[SECURE-CONTEXTS]
    Mike West. ＜Secure Contexts＞. URL: https://w3c.github.io/webappsec-secure-contexts/
[STORAGE]
    Anne van Kesteren. ＜Storage Standard＞. Living Standard. URL: https://storage.spec.whatwg.org/
[STREAMS]
    Adam Rice; et al. ＜Streams Standard＞. Living Standard. URL: https://streams.spec.whatwg.org/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[URLPATTERN]
    Ben Kelly; Jeremy Roman; 宍戸俊哉 (Shunya Shishido). ＜URL Pattern Standard＞. Living Standard. URL: https://urlpattern.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[UNSANCTIONED-TRACKING]
    ＜Unsanctioned Web Tracking＞. 17 July 2015. Finding of the W3C TAG. URL: https://www.w3.org/2001/tag/doc/unsanctioned-tracking/


●●trans_metadata
<p>
~THIS_PAGEは、
~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Service Worker</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/service-workers/
公表履歴
	https://www.w3.org/standards/history/service-workers-1/
フィードバック
	https://github.com/w3c/ServiceWorker/issues/

編集
	<a href="mailto:monicach@microsoft.com">Monica Chintala</a> (Microsoft)
	<a href="mailto:yyanagisawa@chromium.org">Yoshisato Yanagisawa</a> (Google)
前任編集者
	<a href="mailto:slightlyoff@chromium.org">Alex Russell</a> (Google)
	<a href="mailto:jakearchibald@chromium.org">Jake Archibald</a> (Google)
	<a href="mailto:jungkee.song@microsoft.com">Jungkee Song</a> (Microsoft‚ represented Samsung until April 2018)
	<a href="mailto:mek@chromium.org">Marijn Kruisselbrink</a> (Google)

テスト
	<a href="https://github.com/web-platform-tests/wpt/tree/master/service-workers">web-platform-tests service-workers/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/service-workers">ongoing work</a>)

commit 履歴
	https://github.com/w3c/ServiceWorker/commits/main/
公表者
	<a href="https://www.w3.org/groups/wg/webapps">Web Applications WG</a>
</script>

</head>

<body>

<header>
	<hgroup>
<h1>Service Workers Nightly</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様を成す中核は、
~eventを受取るとき起こされる~workerである。
これは、
~eventの行先を［
他の行先は，不適切になるか存在しない
］ときに供するために利用できる。
◎
The core of this specification is a worker that wakes to receive events. This provides an event destination that can be used when other destinations would be inappropriate, or no other destination exists.
</p>

<p>
例えば、［
ある~pageをどう~fetchするべきか裁定する
］ことを開発者に許容するためには，
~eventを配送する必要があるが、
それは，［
当の~pageの生成元~用の実行~文脈
］が存在するより前にもなり得る。
［
~push~messageや持続的な~download
］の完了に反応するとき、
それに対する関心を元々登録した文脈は，もはや存在しないこともある。
これらの事例では、
~swが，~eventの理想的な行先になる。
◎
For example, to allow the developer to decide how a page should be fetched, an event needs to dispatch potentially before any other execution contexts exist for that origin. To react to a push message, or completion of a persistent download, the context that originally registered interest may no longer exist. In these cases, the service worker is the ideal event destination.
</p>

<p>
この仕様は、
`~fetch~event＠#handle-fetch$および［
~HTTP~cacheと類似するよう設計された，`要請と応答の~cache＠#cache-objects$
］も供する
— これらは、
~offlineも可能化された~web~appを より容易に築けるようにする。
◎
This specification also provides a fetch event, and a request and response store similar in design to the HTTP cache, which makes it easier to build offline-enabled web applications.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

<p>
これは “生きた文書” です。
読者は、
この仕様が［
未実装な特能も含み得ること／
詳細が変更され得ること
］を自覚しておく必要があります。
`Service Workers 1＠https://w3c.github.io/ServiceWorker/v1/$
は、
~W3C勧告へ向かって進んでいる~versionです。
◎
This is a living document. Readers need to be aware that this specification may include unimplemented features, and details that may change. Service Workers 1 is a version that is advancing toward a W3C Recommendation.
</p>

	</section>

<main id="MAIN0">

	<section id="motivations">
<h2 title="Motivations">1. 動機</h2>

◎非規範的

<p>
伝統的に，~web~appは、
~platformの至る所で~networkは到達-可能であると見做す。
伝統的に，~HTML文書は、
~HTTP越しに読込まれ，その下位-資源すべてを後続な~HTTP要請を介して~fetchする。
~web内容が他の技術~stackに比して不利な点は、
ここにある。
◎
Web Applications traditionally assume that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally fetch all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.
</p>

<p>
`~sw$は，首に、［
~naviが生じつつあるとき，稼働時に開始できる~web~worker文脈
］を供することにより，この不利を塗り替えるべく設計されている。
この，~event駆動な~workerは、
生成元と~path（または~pattern）†を~~対象に登録される
— すなわち、
~~対象にされた所在への~naviが生じるときには，~workerに諮れることを意味する。
~network要請に対応する~eventは，この~workerへ配送され、
この~workerにより生成された応答は，~network~stackの既定の挙動を上書きできる。
これは，概念的には、
~networkと文書~具現化器の間に`~sw$を狭んで、
~offlineにある間でも，`~sw$が文書~用の内容を供することを可能にする††。
◎
The service worker is designed first to redress this balance by providing a Web Worker context, which can be started by a runtime when navigations are about to occur. This event-driven worker is registered against an origin and a path (or pattern), meaning it can be consulted when navigations occur to that location. Events that correspond to network requests are dispatched to the worker and the responses generated by the worker may override default network stack behavior. This puts the service worker, conceptually, between the network and a document renderer, allowing the service worker to provide content for documents, even while offline.
</p>

<p class="trans-note">【†
生成元は、
処理~modelにおいては，`~storage~key$swr（の一部）として表現される。
~patternとは、
~pathが合致するための~patternを意味し，
`~scope~URL$swrを通して表現される。
】【††
言い換えれば、局所的に稼働する~proxy~serverのようなものである。
】</p>

<p>
~offline問題を従来の試みにより解くことに馴染んでいた~web開発者たちは、
その種の解決策に柔軟性が~~足らないことを報告した。
その結果として、
最大な柔軟性を開発者に供するため，`~sw$は~~高度に~~手続き的になっている
— 追加的な複階性と引き換えに。
この複階性の一部は、
単-~threadな実行~modelに面したときでも，`~sw$を即応的に保つ必要があることに起因する。
結果として，`~sw$により公開される~APIは、
他の~JS文脈において馴染みの~patternではあるが，ほぼすべて非同期的である
— ここに~~強調されるように，［
文書や資源の読込ngが阻まれる
］のは避ける必要があるので。
◎
Web developers familiar with previous attempts to solve the offline problem have reported a deficit of flexibility in those solutions. As a result, the service worker is highly procedural, providing a maximum of flexibility at the price of additional complexity for developers. Part of this complexity arises from the need to keep service workers responsive in the face of a single-threaded execution model. As a result, APIs exposed by service workers are almost entirely asynchronous, a pattern familiar in other JavaScript contexts but accentuated here by the need to avoid blocking document and resource loading.
</p>

<p>
【今や廃された】~HTML`~app~cache＠~TR/2014/REC-html5-20141028/browsers.html#appcache$の設計には，`回復-不能な~error＠https://alistapart.com/article/application-cache-is-a-douchebag#section6$に寄与するような属性がいくつかあることが、
開発者から`報告された＠https://alistapart.com/article/application-cache-is-a-douchebag$。
`~sw$は、［
~errorは，`常に^em回復-可能である
］とする原則を~~重点に設計されている。
`~sw$の更新-処理nを成す詳細の多くは、
これらに付き物の~~障害を避けるよう設計されている。
◎
Developers using the HTML5 Application Cache have also reported that several attributes of the design contribute to unrecoverable errors. A key design principle of the service worker is that errors should always be recoverable. Many details of the update process of service workers are designed to avoid these hazards.
</p>

<p>
`~sw$は、［
文書ではなく，~event
］との関係性に基づいて，開始され, 生存し続ける。
この設計は、
`共用~worker＠~WORKERS#shared-workers-and-the-sharedworker-interface$と
`Chrome Background Pages＠https://developer.chrome.com/docs/extensions/mv2/background-pages$cite
における 開発者や~vendorの経験を大きな糧にしている。
これらの~systemから得られた~~主要な学びは、
背景~処理~文脈の実行~時間を制限することの必要性である
— 開発者に最も懸案される［
資源を温存することと，背景~文脈の喪失と再始動
］の両立を確保するために。
結果として，`~sw$は、［
`Background Pages^cite の後継である
`Chrome Event Page＠https://developer.chrome.com/docs/apps/event_pages$cite
］に~~同等以上なものになっている。
~UAは、
`~sw$を，`文書が~~付随していなくとも^em開始してヨイし, ほぼいつでも~killしてヨイ。
`~sw$は、
概念的には，文書からの~messageを まったく取扱わずに［
開始して, ~eventを処理して, 滅する
］ことが可能な共用~workerと捉えれる。
開発者は、［
`~sw$は，秒間に何度も開始され, ~killされ得る
］ことを頭に入れておくことを勧める。
◎
Service workers are started and kept alive by their relationship to events, not documents. This design borrows heavily from developer and vendor experience with shared workers and Chrome Background Pages. A key lesson from these systems is the necessity to time-limit the execution of background processing contexts, both to conserve resources and to ensure that background context loss and restart is top-of-mind for developers. As a result, service workers bear more than a passing resemblance to Chrome Event Pages, the successor to Background Pages. Service workers may be started by user agents without an attached document and may be killed by the user agent at nearly any time. Conceptually, service workers can be thought of as Shared Workers that can start, process events, and die without ever handling messages from documents. Developers are advised to keep in mind that service workers may be started and killed many times a second.
</p>

<p>
`~sw$は、
生成元において［
~event駆動な, 時間~制限付きで
］走るような，汎用な~script文脈である。
~swは、
これらの特質により，［
特定0の文書の文脈の外でも生きられる，広範な稼働時の~service
］用の自然な端点になる
— 例えば、［
~push通知を取扱う／
背景~dataと同期する／
他の生成元からの資源~要請に応答する／
計算が高価な~dataによる集中型の更新を受信する
］など
（例：~geolocationや~gyroscope）。
◎
Service workers are generic, event-driven, time-limited script contexts that run at an origin. These properties make them natural endpoints for a range of runtime services that may outlive the context of a particular document, e.g. handling push notifications, background data synchronization, responding to resource requests from other origins, or receiving centralized updates to expensive-to-calculate data (e.g., geolocation or gyroscope).
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
所与の`文書$ %文書 の
`先祖~生成元~文字列~list@
は、
%文書 に`関連な大域~obj$に結付けられた `Location$I ~objの`先祖~生成元~list$に結付けられた（文字列たちが成す）~listを指すとする。
</p>

<p>
所与の`閲覧~文脈$ %閲覧~文脈 に
`対応する~navigable@bc
は、
%閲覧~文脈 にて`作動中な~window$bcに`対応する~navigable$を指すとする。
</p>

<p class="trans-note">【
原文では、
各所で，［
引数として`~navigable$を期待する~algo／
文脈として`~navigable$を期待する用語
］に`閲覧~文脈$を渡している
— この用語は、
それに対処するために，この訳に導入した推定であり、
~NULL にもなり得るが，［
この仕様において，そうなる場合があり得るのかどうか
］および［
そうなった場合にどう挙動するか
］は はっきりしない。
代替として、
例えば，［
%閲覧~文脈 にて`作動中な文書$bcの`~node~navigable$
］あるいは［
`~navigable$のうち［
`作動中な閲覧~文脈$nav ~EQ %閲覧~文脈
］を満たすもの
］として定義するべきかもしれない
（これらの定義が一致するかどうかは、はっきりしない）
（原文では，一部の箇所で後者の定義を利用しているが、
該当するものが無い場合や複数ある場合が，あり得るのか
］および［
そうなった場合にどう挙動するか
］は はっきりしない。
】</p>

	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>

		<section id="service-worker-concept">
<h3 title="Service Worker">2.1. ~sw</h3>

<p>
`~sw@
は，`~web~worker$の一種であり、
それを登録している`~sw~client$の`生成元$cl【！`生成元$】において実行される。
◎
A service worker is a type of web worker. A service worker executes in the registering service worker client’s origin.
</p>

<p>
各`~sw$には、
以下に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>
`状態@sw
◎
A service worker has an associated state,＼
</dt>
	<dd>
次に挙げるいずれか
【括弧内は，この訳による補足】
⇒＃
`parsed^l （構文解析-済み）／
`installing^l （~install中） ／
`installed^l （~install済み） ／
`activating^l （作動化-中） ／
`activated^l （作動化-済み）／
`redundant^l （冗長）
◎
which is one of "parsed", "installing", "installed", "activating", "activated", and "redundant".＼
</dd>
	<dd>
初期~時は `parsed^l とする。
◎
It is initially "parsed".
</dd>

	<dt>
`~script~URL@sw
◎
A service worker has an associated script url＼
</dt>
	<dd>
ある`~URL$
◎
(a URL).
</dd>

	<dt>
`種別@sw
◎
A service worker has an associated type＼
</dt>
	<dd>
次に挙げるいずれか
⇒＃
`classic^l ／
`module^l
◎
which is either "classic" or "module".＼
</dd>
	<dd>
他が言明されない限り， `classic^l とする
◎
Unless stated otherwise, it is "classic".
</dd>

	<dt>
`包含している~sw登録@sw
◎
A service worker has an associated containing service worker registration＼
</dt>
	<dd>
この~swを包含している，`~sw登録$。
◎
(a service worker registration), which contains itself.
</dd>
	<dd class="trans-note">【
これが具体的にどう［
定義-／決定-／設定-
］されるかは、
この仕様には述べられていない。
この~swが，ある~sw登録の［
`~install中の~worker$swr／`待機-中な~worker$swr／`作動中な~worker$swr
］であるときの、
その~sw登録を指すように見受けられる
（該当し得る記述は他に見当たらない）。
】</dd>

	<dt>
`大域~obj@sw
◎
A service worker has an associated global object＼
</dt>
	<dd>
ある `ServiceWorkerGlobalScope$I ~obj／ ~NULL
◎
(a ServiceWorkerGlobalScope object or null).
</dd>
	<dd class="trans-note">【
~accessされる前に，（この`~swを走らす$ときに）非 ~NULL に設定される
（ ~NULL をとるのは初期~時に限られるようだ）。
】</dd>

	<dt>
`~script資源@sw
◎
A service worker has an associated script resource＼
</dt>
	<dd>
ある`~script$／~NULL
◎
(a script),＼
</dd>
	<dd>
この~swの自前の~script資源を表現する。
◎
which represents its own script resource.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
It is initially set to null.
</dd>
	<dd>
<p>
各`~script資源$swには、
次に挙げるものが結付けられる：
◎
↓</p>
		<ul>
			<li>
`これまでに評価されたか@sw
⇒
ある真偽値
— 初期~時は ~F とする。
◎
A script resource has an associated has ever been evaluated flag.＼
It is initially unset.
</li>
			<li>
`施策~容器@sw
⇒
ある`施策~容器$
— 初期~時は新たな`施策~容器$とする。
◎
A script resource has an associated policy container (a policy container).＼
It is initially a new policy container.
</li>
		</ul>
	</dd>

	<dt>
`~script資源~map@sw
◎
A service worker has an associated script resource map＼
</dt>
	<dd>
ある`有順序~map$
— 各~entryは［
`~URL$ → `応答$
］を与える。
◎
which is an ordered map where the keys are URLs and the values are responses.
</dd>

	<dt>
`利用した~scriptの集合@sw
◎
A service worker has an associated set of used scripts＼
</dt>
	<dd>
ある`集合$
— 各`~item$は`~URL$を与える。
◎
(a set) whose item is a URL.＼
</dd>
	<dd>
初期~時は新たな`集合$とする。
◎
It is initially a new set.
</dd>
	<dd class="note">注記：
`利用した~scriptの集合$swは、［
更新~検査の間に旧~workerの~mapに基づいて拡充された，新たな~workerの~map
］から［
その~installation後に未利用な資源を刈り取る
］ために限り利用される。
◎
Note: The set of used scripts is only used to prune unused resources from a new worker’s map after installation, that were populated based on the old worker’s map during the update check.
</dd>

	<dt>
`待機を飛ばすか@sw
◎
A service worker has an associated skip waiting＼
</dt>
	<dd>
ある真偽値
◎
flag.＼
</dd>
	<dd>
他が言明されない限り ~F とする。
◎
Unless stated otherwise it is unset.
</dd>

	<dt>
`古典~scriptは~import済みか@sw
◎
A service worker has an associated classic scripts imported＼
</dt>
	<dd>
ある真偽値
◎
flag.＼
</dd>
	<dd>
初期~時は ~F とする。
◎
It is initially unset.
</dd>

	<dt>
`取扱う~event型の集合@sw
◎
A service worker has an associated set of event types to handle＼
</dt>
	<dd>
ある`集合$
— 各`~item$は、
`~event~listener$の~event型を与える。
◎
(a set) whose item is an event listener’s event type.＼
</dd>
	<dd>
初期~時は新たな`集合$とする。
◎
It is initially a new set.
</dd>

	<dt>
`延長-済み~event集合@sw
◎
A service worker has an associated set of extended events＼
</dt>
	<dd>
ある`集合$
— 各`~item$は、
`ExtendableEvent$I を与える。
◎
(a set) whose item is an ExtendableEvent.＼
</dd>
	<dd>
初期~時は新たな`集合$とする。
◎
It is initially a new set.
</dd>

	<dt>
`開始~状態@sw
◎
A service worker has an associated start status＼
</dt>
	<dd>
~NULL ／ ある`Completion$
◎
which can be null or a Completion.＼
</dd>
	<dd>
初期~時は ~NULL とする。
◎
It is initially null.
</dd>

	<dt>
`すべての~fetch~listenerは空か@sw
◎
A service worker has an associated all fetch listeners are empty＼
</dt>
	<dd>
ある真偽値
◎
flag.＼
</dd>
	<dd>
初期~時は ~F とする。
◎
It is initially unset.
</dd>

	<dt>
`~router規則~list@sw
◎
A service worker has an associated list of router rules＼
</dt>
	<dd>
`RouterRule$I たちが成す`~list$
◎
(a list of RouterRules).＼
</dd>
	<dd>
初期~時は新たな`~list$とする。
◎
It is initially an empty list.
</dd>

	<dt>
`手続き~queue@sw
◎
↓</dt>
	<dd>
ある`並列~queue$
◎
↓</dd>
</dl>

<p>
`~sw$は、
その`~event~loop$が走っているとき，
`走っている@
という。
◎
A service worker is said to be running if its event loop is running.
◎
↑ A service worker has an associated [[service worker queue]] (a parallel queue).
</p>

			<section id="service-worker-lifetime">
<h4 title="Lifetime">2.1.1. 存続期間</h4>

<p>
`~sw$の存続期間は、
~eventたちの実行~存続期間に束ねられる
— `~sw~client$が保持する `ServiceWorker$I ~objへの参照ではなく。
◎
The lifetime of a service worker is tied to the execution lifetime of events and not references held by service worker clients to the ServiceWorker object.
</p>

<p>
~UAは、
次に該当するときは，いつでも`~sw$を`終了-$してヨイ：
◎
A user agent may terminate service workers at any time it:
</p>

<ul>
	<li>
取扱う~eventは無いとき。
◎
Has no event to handle.
</li>
	<li>
異常な演算を検出したとき
— 例
⇒＃
無限~loopになったとき／
~eventを取扱っている間に課された時間~制限sを超過した~taskがあるとき
◎
Detects abnormal operation: such as infinite loops and tasks exceeding imposed time limits (if any) while handling the events.
</li>
</ul>

			</section>
			<section id="service-worker-events">
<h4 title="Events">2.1.2. ~event</h4>

<p>
~sw仕様は、
`~sw~event@
として，次に挙げる`~event$を定義する
（`一覧＠#execution-context-events$を見よ）：
◎
The Service Workers specification defines service worker events (each of which is an event) that include (see the list):
</p>

<ul>
	<li>
`~lifecycle~event@
⇒
`install$et,
`activate$et
◎
Lifecycle events: install and activate.
</li>
	<li>
`機能的~event@
⇒
`fetch$et,
~sw仕様を`拡張する＠#extensibility$他の仕様により定義される`~event$
（`一覧＠#execution-context-events$を見よ）
◎
Functional events: fetch and the events defined by other specifications that extend the Service Workers specification. (See the list.)
</li>
	<li>
`message$et【！etC】,
`messageerror$et
◎
message and messageerror.
</li>
</ul>

			</section>
		</section>
		<section id="service-worker-timing">
<h3 title="Service Worker Timing">2.2. ~swの計時</h3>

<p>
各~swは、
ある種の時点を指す時刻を~markする
— それらは、［
`~navi計時~API＠~NAV-TIMING#dom-performancenavigationtiming$／
`資源~計時~API＠~RESOURCE-TIMING#dom-performanceresourcetiming$
］により後で公開される。
◎
Service workers mark certain points in time that are later exposed by the navigation timing API and resource timing API.
</p>

<p>
`~sw計時~報@
は、
次に挙げる`~item$sctからなる`構造体$である：
◎
A service worker timing info is a struct. It has the following items:
</p>
<ul>
	<li>
`開始~時刻@swT
⇒
ある `DOMHighResTimeStamp$I
— 初期~時は 0 とする。
◎
start time
• A DOMHighResTimeStamp, initially 0.
</li>
	<li>
`~fetch~event配送-時刻@swT
⇒
ある `DOMHighResTimeStamp$I
— 初期~時は 0 とする。
◎
fetch event dispatch time
• A DOMHighResTimeStamp, initially 0.
</li>
	<li>
`~worker~router評価~開始@swT
⇒
ある `DOMHighResTimeStamp$I
— 初期~時は 0 とする。
◎
worker router evaluation start
• A DOMHighResTimeStamp, initially 0.
</li>
	<li>
`~worker~cache検索~開始@swT
⇒
ある `DOMHighResTimeStamp$I
— 初期~時は 0 とする。
◎
worker cache lookup start
• A DOMHighResTimeStamp, initially 0.
</li>
	<li>
`~worker合致した~router~source@swT
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
worker matched router source
• A DOMString, initially an empty string.
</li>
	<li>
`~worker最終-~router~source@swT
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
worker final router source
• A DOMString, initially an empty string.
</li>
</ul>

		</section>
		<section id="service-worker-registration-concept">
<h3 title="Service Worker Registration">2.3. ~sw登録</h3>

<p>
`~sw登録@
は、［
`~scope~URL$swr, `~storage~key$, 一群の`~sw$
— `~install中の~worker$swr, `待機-中な~worker$swr, `作動中な~worker$swr —
が成す~tupleである。
◎
A service worker registration is a tuple of a scope url, a storage key, and a set of service workers, an installing worker, a waiting worker, and an active worker.＼
</p>

<p>
~UAは、
同じ生成元の中で，`~sw登録$を何個でも可能化してヨイ
— それらの`~scope~URL$swrが，互いに相違する限りにおいて。
`~sw登録$は、
その`~scope~URL$swrが~UA内に既存の`~sw登録$のそれと一致するときには，既存の`~sw登録$を置換することになる。
◎
A user agent may enable many service worker registrations at a single origin so long as the scope url of the service worker registration differs. A service worker registration of an identical scope url when one already exists in the user agent causes the existing service worker registration to be replaced.
</p>

<p>
各`~sw登録$には、
以下に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`~storage~key@swr
⇒
ある`~storage~key$
◎
A service worker registration has an associated storage key＼
(a storage key).
</li>
	<li>
`~scope~URL@swr
⇒
ある`~URL$
◎
A service worker registration has an associated scope url＼
(a URL).
</li>
	<li>
`~install中の~worker@swr
⇒
~NULL ／次を満たす`~sw$
— 初期~時は ~NULL とする
⇒
`状態$sw ~EQ `installing^l
◎
A service worker registration has an associated installing worker＼
(a service worker or null) whose state is "installing".＼
It is initially set to null.
</li>
	<li>
`待機-中な~worker@swr
⇒
~NULL ／次を満たす`~sw$
— 初期~時は ~NULL とする
⇒
`状態$sw ~EQ `installed^l
◎
A service worker registration has an associated waiting worker＼
(a service worker or null) whose state is "installed".＼
It is initially set to null.
</li>
	<li>
`作動中な~worker@swr
⇒
~NULL／次を満たす`~sw$
— 初期~時は ~NULL とする
⇒
`状態$sw ~IN { `activating^l, `activated^l }
◎
A service worker registration has an associated active worker＼
(a service worker or null) whose state is either "activating" or "activated".＼
It is initially set to null.
</li>
	<li>
<p>
`最後の更新~検査-時刻@swr
⇒
初期~時は ~NULL とする。
◎
A service worker registration has an associated last update check time.＼
It is initially set to null.
</p>

<p>
`~sw登録$が
`非新鮮@
であるとは、
この句が評価される時点で，次が満たされることを意味する
⇒
［
`最後の更新~検査-時刻$swr ~NEQ ~NULL
］~AND［
現在の時刻 ~GT `最後の更新~検査-時刻$swr ~PLUS 86400 秒
］
◎
A service worker registration is said to be stale if the registration’s last update check time is non-null and the time difference in seconds calculated by the current time minus the registration’s last update check time is greater than 86400.
</p>
	</li>
	<li>
`~cacheを介する更新~mode@swr
⇒
次に挙げるいずれか
— 初期~時は `imports^l とする
⇒＃
`imports^l,
`all^l,
`none^l
◎
A service worker registration has an associated update via cache mode,＼
which is "imports", "all", or "none".＼
It is initially set to "imports".
</li>
	<li>
<p>
`~back-up~task~list@swr
⇒
ある~list
◎
A service worker registration has one or more task queues＼
</p>

<p>
これは、［
この`~sw登録$にて`作動中な~worker$swrの`~event~loop$
］に属する`~task~queue$からの`~task$たちを~back-upする。
この~listが~back-upする~taskは、［
`~fetchを取扱う~task~source$／`機能的~eventを取扱う~task~source$
］から~queueされたものに限られる。
◎
that back up the tasks from its active worker’s event loop’s corresponding task queues. (The target task sources for this back up operation are the handle fetch task source and the handle functional event task source.)＼
</p>

<p class="trans-note">【
この用語は、
原文では
“~task~sourceごとに仕分けられる，いくつかの~task~queue”
として定義されているが、
この訳では，単独の~listに改める
— どの~taskも その`~source$tKが当の~task~sourceを保持するので，ここで仕分ける必要はないことに加え、
これは単なる~back-up用の~listであり，`~task~queue$ではないので。
（それに伴い，この用語が利用される箇所も 原文と等価になるよう変形している。）
】</p>

<p>
~UAは、
`作動中な~worker$swrが`終了-$されたとき，~workerの`~task$たちを`~back-up~task~list$swrに~dumpした上で、
~workerが再び立ち上がった（ `spin-off^en した）ときには，~dumpされた~taskたちを［
%~worker の`~event~loop$に属する，各~taskの`~source$tKに対応している`~task~queue$
］に~queueし直すことになる。
【！ 不要 Unlike the task queues owned by event loops, ...】
◎
The user agent dumps the active worker’s tasks to the service worker registration’s task queues when the active worker is terminated and re-queues those tasks to the active worker’s event loop’s corresponding task queues when the active worker spins off. Unlike the task queues owned by event loops, the service worker registration’s task queues are not processed by any event loops in and of itself.
</p>
	</li>
	<li>
`~NavigationPreloadManager@swr
⇒
ある `NavigationPreloadManager$I ~obj
【各 `~sw登録$と一対一に対応する。】
◎
A service worker registration has an associated＼
NavigationPreloadManager object.
</li>
	<li>
`~navi~preloadは可能化されるか@swr
⇒
ある真偽値
— 初期~時は ~F とする。
◎
A service worker registration has an associated navigation preload enabled＼
flag. It is initially unset.
</li>
	<li>
`~navi~preload~header値@swr
⇒
ある`~byte列$
— 初期~時は `true^bl とする。
◎
A service worker registration has an associated navigation preload header value,＼
which is a byte sequence.＼
It is initially set to `true`.
</li>
</ul>

<p>
`~sw登録$ %登録 は、
次を満たすならば，
`未登録にされて@
いるとされる
⇒
`登録~map$[ ( %登録 の`~storage~key$swr, `~URLを直列化する$( %登録【！this が`表現する~sw登録$】 の`~scope~URL$swr ) ) ] ~NEQ %登録
◎
A service worker registration is said to be unregistered if registration map[this service worker registration’s (storage key, serialized scope url)] is not this service worker registration.
</p>

			<section id="service-worker-registration-lifetime">
<h4 title="Lifetime">2.3.1. 存続期間</h4>

<p>
~UAは、
`登録-$された`~sw登録$たちが成す~listを持続的に保つモノトスル
— 明示的に`未登録にされて$いない限り。
それらは、
`登録~map$【！of the tuple of ....】に格納される。
`~sw登録$ %登録 の存続期間は、
%登録 を表現する `ServiceWorkerRegistration$I ~objの存続期間を超える
— 後者の存続期間は、
%登録 に対応している`~sw~client$の存続期間に限られる。
◎
A user agent must persistently keep a list of registered service worker registrations unless otherwise they are explicitly unregistered. A user agent has a registration map that stores the entries of the tuple of service worker registration’s (storage key, serialized scope url) and the corresponding service worker registration. The lifetime of service worker registrations is beyond that of the ServiceWorkerRegistration objects which represent them within the lifetime of their corresponding service worker clients.
</p>

			</section>
		</section>
		<section id="service-worker-client-concept">
<h3 title="Service Worker Client">2.4. ~sw~client</h3>

<p>
`~sw~client@
は、
`環境$である。
◎
A service worker client is an environment.
</p>

<p>
各`~sw~client$には、
真偽値をとる
`破棄-済みか@
次が結付けられる
— 初期~時は ~F とする。
◎
A service worker client has an associated discarded flag. It is initially unset.
</p>

<div class="algo">
<p>
`~sw~client$ %~client の`環境を破棄する手続き$は：
◎
Each service worker client has the following environment discarding steps:
</p>

<ol>
	<li>
%~client の`破棄-済みか$ ~SET ~T
◎
Set client’s discarded flag.
</li>
</ol>

<p class="note">注記：
実装は、
`破棄-済みか$ ~EQ ~T になった~clientを破棄できる。
◎
Note: Implementations can discard clients whose discarded flag is set.
</p>
</div>

<div class="algo">
<p>
`~sw~client$ %~client の
`生成元@cl
は、
%~client に応じて，次を返す
⇒＃
`環境~設定群~obj$であるならば %~client の`生成元$enV ／
~ELSE_ %~client の`作成時の~URL$enVの`生成元$url
◎
A service worker client has an algorithm defined as the origin that returns the service worker client’s origin if the service worker client is an environment settings object, and the service worker client’s creation URL’s origin otherwise.
</p>
</div>

<p>
`~sw~client$は、
その`大域~obj$enVに応じて：
◎
↓</p>
<ul>
	<li>
`Window$I ~objであるならば
`~window~client@
と称される。
◎
A window client is a service worker client whose global object is a Window object.
</li>
	<li>
`DedicatedWorkerGlobalScope$I ~objであるならば
`専用~worker~client@
と称される。
◎
A dedicated worker client is a service worker client whose global object is a DedicatedWorkerGlobalScope object.
</li>
	<li>
`SharedWorkerGlobalScope$I ~objであるならば
`共用~worker~client@
と称される。
◎
A shared worker client is a service worker client whose global object is a SharedWorkerGlobalScope object.
</li>
</ul>

<p>
`~worker~client@
は、［
`専用~worker~client$, `共用~worker~client$
］の総称である。
◎
A worker client is either a dedicated worker client or a shared worker client.
</p>

<p>
`~storage~keyが登録と同等な~client群@
とは、
次を満たす`~sw~client$ %~client たちが成す集合である
⇒
次の 2 つは`同等な~storage~key$である
⇒＃
`~storage~keyを得する$( %~client ) の結果,
%~client の`~sw$SWG【%~client を`制御-$している`~sw$？】を`包含している~sw登録$swの`~storage~key$swr
</p>

<p class="trans-note">【
この用語は、
以下を簡潔に記すために，この訳に導入している。
この集合を成す~clientたちは、
何箇所かで反復されるが，その順序は定義されていない。
】</p>

		</section>
		<section id="control-and-use">
<h3 title="Control and Use">2.5. 制御と利用</h3>

<p>
`~sw~client$ %~client にて`作動中な~sw$enVは、
自前の読込ng, およびその下位資源を~serveする。
%~client にて`作動中な~sw$enVが ~NULL でないとき、
%~client は
`作動中な~sw$enVにより
`制御-@
されているという。
%~client が，ある`~sw$により`制御-$されているとき、
%~client は`~sw$を`包含している~sw登録$swを
`利用して@
いるという。
%~client にて`作動中な~sw$enVは、
以下の各~下位節にて説明されるように決定される。
◎
A service worker client has an active service worker that serves its own loading and its subresources. When a service worker client has a non-null active service worker, it is said to be controlled by that active service worker. When a service worker client is controlled by a service worker, it is said that the service worker client is using the service worker’s containing service worker registration. A service worker client’s active service worker is determined as explained in the following subsections.
</p>

<p class="trans-note">【
すなわち，次の 3 つの句は、
同じことを，主語と目的語を入れ替えて表している
】
⇒＃
“%~sw は %~client を制御している”,
“%~client は %登録 を利用している”,
“%登録 は %~sw を包含している”
</p>

<p>
`この節の残りは規範的でない^em。
◎
The rest of the section is non-normative.
</p>

<p class="issue">
この節における挙動は、
まだ全部的に指定されておらず，
`~HTML標準＠https://html.spec.whatwg.org$
にて指定されることになる。
その作業は、
`765$issue,
`pull request＠https://github.com/whatwg/html/pull/2809$
にて追跡されている。
◎
The behavior in this section is not fully specified yet and will be specified in HTML Standard. The work is tracked by the issue and the pull request.
</p>

			<section id="control-and-use-window-client">
<h4 title="The window client case">2.5.1. ~window~client事例</h4>

<p>
`~window~client$は、
次のいずれかのとき，`作成-$wCされる：
◎
A window client is created when a browsing context is created and when it navigates.
</p>

<ul>
	<li>
<p>
新たな`閲覧~文脈が作成され$るとき
— このときの［
`~window~client$にて`作動中な~sw$enV
］は、
次に従って設定される：
◎
When a window client is created in the process of a browsing context creation:
</p>
		<ol>
			<li>
`閲覧~文脈$の［
初期~時にて`作動中な文書$bc
］の`生成元$docは`不透明な生成元$である場合
⇒
~NULL
◎
If the browsing context’s initial active document’s origin is an opaque origin, the window client’s active service worker is set to null.＼
</li>
			<li>
他の場合
⇒
作成元`文書$【当の`閲覧~文脈が作成され$るとき渡された %作成元 】の`~sw~client$にて`作動中な~sw$enV
◎
Otherwise, it is set to the creator document’s service worker client’s active service worker.
</li>
		</ol>
	</li>
	<li>
<p>
`閲覧~文脈$に`対応する~navigable$bcが`~navigate$されるとき
— このときの［
`~window~client$にて`作動中な~sw$enV
］は、
次に従って設定される：
◎
When a window client is created in the process of the browsing context’s navigation:
</p>
		<ol>
			<li>
その`~fetch$が`~HTTP~fetch$を経由しているならば
⇒
`合致する~sw登録$【の`作動中な~worker$swrに設定されることになる~sw？】
◎
If the fetch is routed through HTTP fetch, the window client’s active service worker is set to the result of the service worker registration matching.＼
</li>
			<li>
他の場合，作成された`文書$の`生成元$docは`不透明な生成元$であるならば
⇒
~NULL
◎
Otherwise, if the created document’s origin is an opaque origin＼
</li>
			<li>
他の場合，［
( 作成された`文書$の`生成元$doc, その作成元`文書$†の`生成元$doc )
は`同一-生成元$でない
］ならば
⇒
~NULL
◎
or not the same as its creator document’s origin, the window client’s active service worker is set to null.＼
</li>
			<li>
他の場合
⇒
その作成元`文書$†の`~sw~client$にて`作動中な~sw$enV
◎
Otherwise, it is set to the creator document’s service worker client’s active service worker.
</li>
		</ol>
<p class="trans-note">【†
すなわち、
`~navi~algo$に渡された %~source文書
】</p>
	</li>
</ul>

<p class="note">注記：
初期~置換`~navi$用には、［
当の`閲覧~文脈が作成され$たとき`作成-$wCされた初期`~window~client$
］が再利用されるが，`作動中な~sw$enVは上と同じ挙動により決定される。
◎
Note: For an initial replacement navigation, the initial window client that was created when the browsing context was created is reused, but the active service worker is determined by the same behavior as above.
</p>

<p class="note">注記：
`~sandbox化$された `iframe$e が~sandbox法~指令［
`allow-same-origin^dir, `allow-scripts^dir
］を伴わない場合、
その`生成元$は`不透明な生成元$になるので，`作動中な~sw$enVは ~NULL になる。
◎
Note: Sandboxed iframes without the sandboxing directives, allow-same-origin and allow-scripts, result in having the active service worker value of null as their origin is an opaque origin.
</p>

			</section>
			<section id="control-and-use-worker-client">
<h4 title="The worker client case">2.5.2. ~worker~client事例</h4>

<p>
`~worker~client$は、
~UAが`~workerを走らす$ときに`作成-$wGされる。
◎
A worker client is created when the user agent runs a worker.
</p>

<p>
`~worker~client$が作成されるときの，`作動中な~sw$enVは、
次に従って設定される：
◎
When the worker client is created:
</p>

<ol>
	<li>
その`~fetch$が`~HTTP~fetch$を経由しているならば
⇒
`合致する~sw登録$【の`作動中な~worker$swrに設定されることになる~sw？】
◎
When the fetch is routed through HTTP fetch, the worker client’s active service worker is set to the result of the service worker registration matching.＼
</li>
	<li>
他の場合，`~worker~client$の`生成元$clは`不透明な生成元$であるならば
⇒
~NULL
◎
Otherwise, if the worker client’s origin is an opaque origin,＼
</li>
	<li>
他の場合，［
その`要請$の`~URL$rqは`~blob~URL$である
］~AND［
( `~worker~client$の`生成元$cl, `~worker~client$の`大域~obj$の`所有者~集合$の最後の`~item$の`生成元$ )
は`同一-生成元$でない
］ならば
⇒
~NULL
◎
or the request’s URL is a blob URL and the worker client’s origin is not the same as the origin of the last item in the worker client’s global object’s owner set, the worker client’s active service worker is set to null.＼
</li>
	<li>
他の場合
⇒
`~worker~client$の`大域~obj$の`所有者~集合$の最後の`~item$の`環境~設定群~obj$にて`作動中な~sw$enV
◎
Otherwise, it is set to the active service worker of the environment settings object of the last item in the worker client’s global object’s owner set.
</li>
</ol>

			</section>

<p class="note">注記：
<a href="~RFCx/rfc2397#section-2">`data:^c ~URL</a>
を伴う［
`~window~client$／`~worker~client$
］に対しては、
その`生成元$は`不透明な生成元$になるので，`作動中な~sw$enVは ~NULL になる。
`~blob~URL$を伴う［
`~window~client$／`~worker~client$
］は，その［
作成元`文書$／所有者
］から`作動中な~sw$enVを継承し得るが、
`要請$の`生成元$rqが［
作成元`文書$／所有者
］の`生成元$と`同一-生成元$でない場合，`作動中な~sw$enVは ~NULL に設定される。
◎
Note: Window clients and worker clients with a data: URL result in having the active service worker value of null as their origin is an opaque origin. Window clients and worker clients with a blob URL can inherit the active service worker of their creator document or owner, but if the request’s origin is not the same as the origin of their creator document or owner, the active service worker is set to null.
</p>

		</section>
		<section id="task-sources">
<h3 title="Task Sources">2.6. ~task~source</h3>

<p>
`~sw$は、
次に挙げる`~task~source$も追加的に利用する：
◎
The following additional task sources are used by service workers.
</p>
<ul>
	<li>
`~fetchを取扱う~task~source@
⇒
`~sw$に向けて `fetch$et ~eventを`配送-$するときに利用される。
◎
The handle fetch task source
• This task source is used for dispatching fetch events to service workers.
</li>
	<li>
<p>
`機能的~eventを取扱う~task~source@
⇒
他の`機能的~event$を`配送-$する特能~用に利用される
— 例： `~sw$向けの `push$et ~event。
◎
The handle functional event task source
• This task source is used for features that dispatch other functional events, e.g. push events, to service workers.
</p>

<p class="note">注記：
~UAは、
各~機能的~event型ごとに，別々な~task~sourceを利用してもヨイ
— ある種の機能的~eventに対する `head-of-line blocking^en 現象†を避けるためとして。
【†長い~taskにより後続の~taskが~~渋滞する現象】
◎
Note: A user agent may use a separate task source for each functional event type in order to avoid a head-of-line blocking phenomenon for certain functional events.
</p>
	</li>
</ul>


		</section>
		<section id="user-agent-shutdown">
<h3 title="User Agent Shutdown">2.7. ~UA~shutdown</h3>

<p>
~UAは、
複数回の再始動にまたがって，自身が格納している`~sw登録$たちの状態を，次の規則の下で保守するモノトスル：
◎
A user agent must maintain the state of its stored service worker registrations across restarts with the following rules:
</p>

<ul>
	<li>
`~install中の~worker$swrは、
持続することなく破棄する。
それが`~sw登録$用の唯一の`~sw$であった場合、
その登録も破棄する。
◎
An installing worker does not persist but is discarded. If the installing worker was the only service worker for the service worker registration, the service worker registration is discarded.
</li>
	<li>
`待機-中な~worker$swrは、
`作動中な~worker$swrに~~昇格する。
◎
A waiting worker promotes to an active worker.
</li>
</ul>

<p>
これを成就するため，~UAは、
自身が終了するときには，次を呼出すモノトスル
⇒
`~UA~shutdownを取扱う$()
◎
To attain this, the user agent must invoke Handle User Agent Shutdown when it terminates.
</p>

		</section>
	</section>
	<section id="document-context">
<h2 title="Client Context">3. ~client文脈</h2>

<div class="example">

<p>
~swで~bootstrapする例：
◎
Bootstrapping with a service worker:
</p>

<pre class="lang-js">
/* <span class="comment">
既定の~scopeは、
当の~scriptが座している~path
— この例では `/^l —
になる
◎
scope defaults to the path the script sits in "/" in this example
</span> */
navigator.`serviceWorker$n.`register$n("/serviceworker.js").then(%registration =&gt; {
  console.log("success!");
  if (%registration.`ServiceWorkerRegistration^I1`installing$m1) {
    %registration.installing.`~postMessageSW$n("Howdy from your installing page.");
  }
}, %err =&gt; {
  console.error("Installing the worker failed!", %err);
});
</pre>

</div>

		<section id="serviceworker-interface">
<h3>3.1. `ServiceWorker^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `ServiceWorker@I : `EventTarget$I {
  readonly attribute `USVString$ `scriptURL$m;
  readonly attribute `ServiceWorkerState$I `state$m;
  `undefined$ `postMessage$m(`any$ %message, `sequence$&lt;`object$&gt; %transfer);
  `undefined$ `~postMessageSW$n(`any$ %message, optional `StructuredSerializeOptions$I %options = {});

  // event
  attribute `EventHandler$I `onstatechange$m;
};
`ServiceWorker$I includes `AbstractWorker$I;

enum `ServiceWorkerState@I {
  "`parsed@m",
  "`installing@m",
  "`installed@m",
  "`activating@m",
  "`activated@m",
  "`redundant@m"
};
</pre>

<p>
`ServiceWorker$I ~objは、
ある`~sw$を表現する。
いくつかの文書や~workerにまたがって，同時に複数の `ServiceWorker$I ~objが同じ`~sw$を表現し得る。
◎
A ServiceWorker object represents a service worker. Each ServiceWorker object is associated with a service worker. Multiple separate objects implementing the ServiceWorker interface across documents and workers can all be associated with the same service worker simultaneously.
</p>

<p>
`ServiceWorkerState$I 列挙は、
`~sw$がとり得る`状態$swを表現し，`~workerの状態を更新する$ときに利用される。
◎
A ServiceWorker object has an associated ServiceWorkerState object which is itself associated with service worker’s state.
</p>

`ServiceWorker^I0

			<section id="service-worker-creation">
<h4 title="Getting ServiceWorker instances">3.1.1. `ServiceWorker^I ~instanceを取得する</h4>

<p>
各 `環境~設定群~obj$は、
`~sw~obj~map@enV
を持つ
— それは`有順序~map$であり，それを成す各`~entry$mapは［
`~sw$ → `ServiceWorker$I ~obj
］を与える。
◎
An environment settings object has a service worker object map, a map where the keys are service workers and the values are ServiceWorker objects.
</p>

<div class="algo">
<p>
（ある環境~内で~swを表現している）
`~sw~objを取得する@
~algoは、
所与の
( `~sw$ %~sw, `環境~設定群~obj$ %環境 )
に対し：
◎
To get the service worker object representing serviceWorker (a service worker) in environment (an environment settings object), run these steps:
</p>

<ol>
	<li>
%~obj~map ~LET %環境 の`~sw~obj~map$enV
◎
Let objectMap be environment’s service worker object map.
</li>
	<li>
<p>
~IF［
%~obj~map[ %~sw ] ~EQ ε
］：
◎
If objectMap[serviceWorker] does not exist, then:
</p>
		<ol>
			<li>
%~sw~obj ~LET `新たな~obj$( `ServiceWorker$I, %環境 の`~realm$enV )
◎
Let serviceWorkerObj be a new ServiceWorker in environment’s Realm,＼
</li>
			<li>
%~sw~obj に %~sw を結付ける
【 %~sw~obj は %~sw を “表現する” 】
◎
and associate it with serviceWorker.
</li>
			<li>
%~sw~obj の `state$m ~SET %~sw の`状態$sw
◎
Set serviceWorkerObj’s state to serviceWorker’s state.
</li>
			<li>
%~obj~map[ %~sw ] ~SET %~obj
◎
Set objectMap[serviceWorker] to serviceWorkerObj.
</li>
		</ol>
	</li>
	<li>
~RET %~obj~map[ %~sw ]
◎
Return objectMap[serviceWorker].
</li>
</ol>
</div>

			</section>
			<section id="service-worker-url">
<h4>3.1.2. `scriptURL^m</h4>

<p>
`scriptURL@m
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレが表現する`~sw$の`~script~URL$sw )
◎
The scriptURL getter steps are to return the service worker’s serialized script url.
</p>

<div class="example">

<p>
例えば
`https://example.com/app.html^c
への~naviにより作成される文書を考える
— それは、
以前に次の登録~callが実行されていて，`合致する~sw登録$があるとする：
◎
For example, consider a document created by a navigation to https://example.com/app.html which matches via the following registration call which has been previously executed:
</p>

<pre class="lang-js">
/* <span class="comment">
~page `https://example.com/app.html^c 上の~script
◎
Script on the page https://example.com/app.html
</span> */
navigator.`serviceWorker$n.`register$n("/service_worker.js");
</pre>

<p>
`navigator.serviceWorker.controller.scriptURL^c の値は
`https://example.com/service_worker.js^l 
になる。
◎
The value of navigator.serviceWorker.controller.scriptURL will be "https://example.com/service_worker.js".
</p>

</div>

			</section>
			<section id="service-worker-state">
<h4>3.1.3. `state^m</h4>

<p>
`state@m
取得子~手続きは
⇒
~RET 最後に設定された（ `ServiceWorkerState$I 列挙~型の）値
【この値は、コレが表現する`~sw$の`状態$swを反映する。】
◎
The state attribute must return the value (in ServiceWorkerState enumeration) to which it was last set.
</p>

			</section>
			<section id="service-worker-postmessage">
<h4>3.1.4. `postMessage(message, transfer)^m</h4>

<p>
`postMessage(message, transfer)@m
~method手続きは：
◎
The postMessage(message, transfer) method steps are:
</p>
<ol>
	<li>
%options ~LET «[ `transfer^l → %transfer ]»
◎
Let options be «[ "transfer" → transfer ]».
</li>
	<li>
コレ上で `~postMessageSW(message, options)$n ~method手続き（次節）を遂行する
◎
Invoke postMessage(message, options) with message and options as the arguments.
</li>
</ol>

			</section>
			<section id="service-worker-postmessage-options">
<h4>3.1.5. `~postMessageSW(message, options)^m</h4>

<p>
`~postMessageSW(message, options)@n
~method手続きは：
◎
The postMessage(message, options) method steps are:
</p>
<ol>
	<li>
%~sw ~LET コレが表現している`~sw$
◎
Let serviceWorker be the service worker represented by this.
</li>
	<li>
%現任な設定群 ~LET `現任な設定群~obj$
◎
Let incumbentSettings be the incumbent settings object.
</li>
	<li>
%現任な大域~obj ~LET %現任な設定群 の`大域~obj$enV
◎
Let incumbentGlobal be incumbentSettings’s global object.
</li>
	<li>
%直列化した転送-結果 ~LET 
~ABRUPT `StructuredSerializeWithTransfer$jA( %message, %options[ "`transfer$n" ] )
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, options["transfer"]). Rethrow any exceptions.
</li>
	<li>
~IF［
`~eventを飛ばすべきか？$( `message^l, %~sw ) ~EQ ~T
］
⇒
~RET
◎
If the result of running the Should Skip Event algorithm with "message" and serviceWorker is true, then return.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
~IF［
`~swを走らす$( %~sw ) ~EQ `失敗^i
］
⇒
~RET
◎
If the result of running the Run Service Worker algorithm with serviceWorker is failure, then return.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き )
◎
Queue a task on the DOM manipulation task source to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
<p>
%~source ~LET %現任な大域~obj の型に応じて：
◎
Let source be determined by switching on the type of incumbentGlobal:
</p>
						<ul class="switch">
							<li>
`ServiceWorkerGlobalScope$I
⇒
`~sw~objを取得する$( %現任な大域~obj の`~sw$SWG, %~sw の`大域~obj$swに`関連な設定群~obj$ )
◎
ServiceWorkerGlobalScope
• The result of getting the service worker object that represents incumbentGlobal’s service worker in the relevant settings object of serviceWorker’s global object.
</li>
							<li>
`Window$I
⇒
%現任な大域~obj に`関連な設定群~obj$を表現する`新たな~obj$( `WindowClient$I )
◎
Window
• a new WindowClient object that represents incumbentGlobal’s relevant settings object. 
</li>
							<li>
その他
⇒
%現任な大域~obj に結付けられた~workerを表現する`新たな~obj$( `Client$I )
◎
Otherwise
• a new Client object that represents incumbentGlobal’s associated worker 
</li>
						</ul>
					</li>
					<li>
%生成元 ~LET `生成元を直列化する$( %現任な設定群 の`生成元$enV )
◎
Let origin be the serialization of incumbentSettings’s origin.
</li>
					<li>
%行先 ~LET %~sw に結付けられた `ServiceWorkerGlobalScope$I 【 %~sw の`大域~obj$sw】
【！上で`~swを走らす$ときに作成され得る／ %行先 の`~sw$SWG ~EQ %~sw 】
◎
Let destination be the ServiceWorkerGlobalScope object associated with serviceWorker.
</li>
					<li>
%~event ~LET `~eventを作成する$( `ExtendableMessageEvent$I )
◎
↓</li>
					<li>
<p>
%逆直列化-~record ~LET
`StructuredDeserializeWithTransfer$jA( %直列化した転送-結果, %行先 に`関連な~realm$ )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, destination’s Realm).
</p>

<p>
~IF［
例外が投出された
］
⇒
%~event の属性を次のように初期化する
⇒＃
`type$n 属性 ~SET `messageerror$et【！etC】,
`ExtendableMessageEvent^I1`origin$m1 属性 ~SET %生成元,
`source$m1 属性 ~SET %~source
◎
If this throws an exception, let e be the result of creating an event named messageerror, using ExtendableMessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source.
</p>

<p>
~ELSE：
◎
Else:
</p>
						<ol>
							<li>
%新たな~port群 ~LET
【 %行先 に`関連な~realm$内で】
`凍結d配列を作成する$( %逆直列化-~record . `TransferredValues^sl 内のすべての `MessagePort$I ~objからなる同順の~list )
◎
Let messageClone be deserializeRecord.[[Deserialized]].
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.
</li>
							<li>
%~event の属性を次のように初期化する
⇒＃
`type$n 属性 ~SET `message$et,
`ExtendableMessageEvent^I1`origin$m1 属性 ~SET %生成元,
`source$m1 属性 ~SET %~source,
`data$m1 属性 ~SET %逆直列化-~record . `Deserialized^sl,
`ports$m1 属性 ~SET %新たな~port群
◎
Let e be the result of creating an event named message, using ExtendableMessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.
</li>
						</ol>
					</li>
					<li>
`~eventを配送する$( %行先, %~event )
◎
Dispatch e at destination.
</li>
					<li>
`~sw延長-済み~event集合を更新する$( %~sw, %~event )
◎
Invoke Update Service Worker Extended Events Set with serviceWorker and e.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="service-worker-event-handler">
<h4 title="Event handler">3.1.6. ~event~handler</h4>

<p>
どの `ServiceWorker$I ~objも、
次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported, as event handler IDL attributes, by all objects implementing ServiceWorker interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
<tbody>

<tr><td>`onstatechange@m
<td>`statechange$et
</table>

			</section>
		</section>
		<section id="serviceworkerregistration-interface">
<h3>3.2. `ServiceWorkerRegistration^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `ServiceWorkerRegistration@I : `EventTarget$I {
  readonly attribute `ServiceWorker$I? `installing$m;
  readonly attribute `ServiceWorker$I? `waiting$m;
  readonly attribute `ServiceWorker$I? `active$m;
  [`SameObject$] readonly attribute `NavigationPreloadManager$I `navigationPreload$m;

  readonly attribute `USVString$ `scope$m;
  readonly attribute `ServiceWorkerUpdateViaCache$I `updateViaCache$m;

  [`NewObject$] `Promise$&lt;`ServiceWorkerRegistration$I&gt; `update$m();
  [`NewObject$] `Promise$&lt;`boolean$&gt; `unregister$m();

  // event
  attribute `EventHandler$I `onupdatefound$m;
};

enum `ServiceWorkerUpdateViaCache@I {
  "`imports@m",
  "`all@m",
  "`none@m"
};

</pre>

<p>
各 `ServiceWorkerRegistration$I ~objは、
ある`~sw登録$を表現する。
それを指して，~objが
`表現する~sw登録@
という。
◎
A ServiceWorkerRegistration has a service worker registration (a service worker registration).
</p>

<p class="trans-note">【
所与の~sw登録を表現する `ServiceWorkerRegistration^I ~objは， 1 つに限られないが、
同じ`~realm$gL（環境~設定群~obj）内では 1 つに限られる。
】</p>

`ServiceWorkerRegistration^I0


			<section id="service-worker-registration-creation">
<h4 title="Getting ServiceWorkerRegistration instances">3.2.1. `ServiceWorkerRegistration^I ~instanceの取得-法</h4>

<p>
各 `環境~設定群~obj$は、
`~sw登録~obj~map@enV
を持つ
— それは`有順序~map$であり，それを成す各`~entry$mapは［
`~sw登録$ → `ServiceWorkerRegistration$I ~obj
］を与える。
◎
An environment settings object has a service worker registration object map, a map where the keys are service worker registrations and the values are ServiceWorkerRegistration objects.
</p>

<div class="algo">
<p>
（ある環境~内で~sw登録を表現している）
`~sw登録~objを取得する@
~algoは、
所与の
( `~sw登録$ %登録, `環境~設定群~obj$ %環境 )
に対し：
◎
To get the service worker registration object representing registration (a service worker registration) in environment (an environment settings object), run these steps:
</p>
<ol>
	<li>
%~obj~map ~LET %環境 の`~sw登録~obj~map$enV
◎
Let objectMap be environment’s service worker registration object map.
</li>
	<li>
<p>
~IF［
%~obj~map[ %登録 ] ~EQ ε
］：
◎
If objectMap[registration] does not exist, then:
</p>
		<ol>
			<li>
%登録~obj ~LET `新たな~obj$( `ServiceWorkerRegistration$I, %環境 の`~realm$enV )
◎
Let registrationObject be a new ServiceWorkerRegistration in environment’s Realm.
</li>
			<li>
%登録~obj が`表現する~sw登録$ ~SET %登録
◎
Set registrationObject’s service worker registration to registration.
</li>
			<li>
%登録~obj の
⇒＃
`installing$m 属性 ~SET ~NULL,
`waiting$m 属性 ~SET ~NULL,
`active$m 属性 ~SET ~NULL
◎
Set registrationObject’s installing attribute to null.
◎
Set registrationObject’s waiting attribute to null.
◎
Set registrationObject’s active attribute to null.
</li>
			<li>
~IF［
%登録 の`~install中の~worker$swr ~NEQ ~NULL
］
⇒
%登録~obj の `installing$m 属性 ~SET
`~sw~objを取得する$( %登録 の`~install中の~worker$swr, %環境 )
◎
If registration’s installing worker is not null, then set registrationObject’s installing attribute to the result of getting the service worker object that represents registration’s installing worker in environment.
</li>
			<li>
~IF［
%登録 にて`待機-中な~worker$swr ~NEQ ~NULL
］
⇒
%登録~obj の `waiting$m 属性 ~SET
`~sw~objを取得する$( %登録 にて`待機-中な~worker$swr, %環境 )
◎
If registration’s waiting worker is not null, then set registrationObject’s waiting attribute to the result of getting the service worker object that represents registration’s waiting worker in environment.
</li>
			<li>
~IF［
%登録 にて`作動中な~worker$swr ~NEQ ~NULL
］
⇒
%登録~obj の `active$m 属性 ~SET
`~sw~objを取得する$( %登録 にて`作動中な~worker$swr, %環境 )
◎
If registration’s active worker is not null, then set registrationObject’s active attribute to the result of getting the service worker object that represents registration’s active worker in environment.
</li>
			<li>
%~obj~map[ %登録 ] ~SET %登録~obj
◎
Set objectMap[registration] to registrationObject.
</li>
		</ol>
	</li>
	<li>
~RET %~obj~map[ %登録 ]
◎
Return objectMap[registration].
</li>
</ol>
</div>

			</section>
			<section id="navigator-service-worker-installing">
<h4>3.2.2. `installing^m</h4>

<p>
`installing@m
取得子~手続きは
⇒
~RET 最後に設定された値
【~NULL でなければ`~install中の~worker$swrを表現する】
◎
installing attribute must return the value to which it was last set.
</p>

<p class="note">注記：
同じ`~realm$enVの中では、
同じ`~sw$を表現する `ServiceWorker$I ~objは，一つに限られる。
◎
Note: Within a Realm, there is only one ServiceWorker object per associated service worker.
</p>

			</section>
			<section id="navigator-service-worker-waiting">
<h4>3.2.3. `waiting^m</h4>

<p>
`waiting@m
取得子~手続きは
⇒
~RET 最後に設定された値
【~NULL でなければ`待機-中な~worker$swrを表現する】
◎
waiting attribute must return the value to which it was last set.
</p>

<p class="note">注記：
同じ`~realm$enVの中では、
同じ`~sw$を表現する `ServiceWorker$I ~objは，一つに限られる。
◎
Note: Within a Realm, there is only one ServiceWorker object per associated service worker.
</p>

			</section>
			<section id="navigator-service-worker-active">
<h4>3.2.4. `active^m</h4>

<p>
`active@m
取得子~手続きは
⇒
~RET 最後に設定された値
【~NULL でなければ`作動中な~worker$swrを表現する】
◎
active attribute must return the value to which it was last set.
</p>

<p class="note">注記：
同じ`~realm$enVの中では、
同じ`~sw$を表現する `ServiceWorker$I ~objは，一つに限られる。
◎
Note: Within a Realm, there is only one ServiceWorker object per associated service worker.
</p>

			</section>
			<section id="service-worker-registration-navigationpreload">
<h4>3.2.5. `navigationPreload^m</h4>

<p>
`navigationPreload@m
取得子~手続きは
⇒
~RET コレが`表現する~sw登録$の`~NavigationPreloadManager$swr
◎
The navigationPreload getter steps are to return the service worker registration’s NavigationPreloadManager object.
</p>

			</section>
			<section id="service-worker-registration-scope">
<h4>3.2.6. `scope^m</h4>

<p>
`scope@m
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレが`表現する~sw登録$の`~scope~URL$swr )
◎
The scope getter steps are to return the service worker registration’s serialized scope url.
</p>

<div class="example">

<p>
例えば、
§ `ServiceWorker^I1`scriptURL$m1 の例においては、
</p>

<pre class="lang-js">
navigator.serviceWorker.ready.then(%registration =&gt; console.log(%registration.scope))
</pre>

<p>
から得される `registration.scope^c の値は、
`https://example.com/^l
になる。
</p>
◎
In the example in § 3.1.2 scriptURL, the value of registration.scope, obtained from navigator.serviceWorker.ready.then(registration =&gt; console.log(registration.scope)) for example, will be "https://example.com/".
</div>

			</section>
			<section id="service-worker-registration-updateviacache">
<h4>3.2.7. `updateViaCache^m</h4>

<p>
`updateViaCache@m
取得子~手続きは
⇒
~RET コレが`表現する~sw登録$の`~cacheを介する更新~mode$swr
◎
The updateViaCache getter steps are to return the service worker registration’s update via cache mode.
</p>

			</section>
			<section id="service-worker-registration-update">
<h4>3.2.8. `update()^m</h4>

<p>
`update()@m
~method手続きは：
◎
The update() method steps are:
</p>
<ol>
	<li>
%登録 ~LET コレが`表現する~sw登録$
◎
Let registration be the service worker registration.
</li>
	<li>
%最新~worker ~LET
`最新な~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as its argument.
</li>
	<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
~RET `却下される~promise$( `InvalidStateError$E 例外 )
◎
If newestWorker is null, return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
	<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
↓</li>
	<li>
~IF［
%大域~obj は `ServiceWorkerGlobalScope$I ~objである
］~AND［
%大域~obj の`~sw$SWGの`状態$sw ~EQ `installing^l
］
⇒
~RET `却下される~promise$( `InvalidStateError$E 例外 )
◎
If this’s relevant global object globalObject is a ServiceWorkerGlobalScope object, and globalObject’s associated service worker’s state is "installing", return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a promise.
</li>
	<li>
%~job ~LET `~jobを作成する$( ↓ )
⇒＃
`更新する^i,
%登録 の`~storage~key$swr,
%登録 の`~scope~URL$swr,
%最新~worker の`~script~URL$sw,
%~promise,
コレに`関連な設定群~obj$
◎
Let job be the result of running Create Job with update, registration’s storage key, registration’s scope url, newestWorker’s script url, promise, and this’s relevant settings object.
</li>
	<li>
%~job の`~worker種別$job ~SET %最新~worker の`種別$sw
◎
Set job’s worker type to newestWorker’s type.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-unregister">
<h4>3.2.9. `unregister()^m</h4>

<p class="note">注記：
この~methodは、
`~sw登録$を未登録にする。
［［［
現在`制御-$されている`~sw~client$
］にて`作動中な~sw$enV
］を`包含している~sw登録$sw
］は、
この`~sw登録$を利用しているすべての`~sw~client$（自身を含めて）が~unloadされるまで，有効になることに注意。
すなわち， `unregister()$m ~methodが影響するのは、
後続な`~navi$に限られる。
◎
Note: The unregister() method unregisters the service worker registration. It is important to note that the currently controlled service worker client’s active service worker’s containing service worker registration is effective until all the service worker clients (including itself) using this service worker registration unload. That is, the unregister() method only affects subsequent navigations.
</p>

<p>
`unregister()@m
~method手続きは：
◎
The unregister() method steps are:
</p>
<ol>
	<li>
%登録 ~LET コレが`表現する~sw登録$
◎
Let registration be the service worker registration.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~job ~LET `~jobを作成する$( ↓ )
⇒＃
`未登録にする^i,
%登録 の`~storage~key$swr,
%登録 の`~scope~URL$swr,
~NULL,
%~promise,
コレに`関連な設定群~obj$
◎
Let job be the result of running Create Job with unregister, registration’s storage key, registration’s scope url, null, promise, and this’s relevant settings object.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="service-worker-registration-event-handler">
<h4 title="Event handler">3.2.10. ~event~handler</h4>

<p>
どの `ServiceWorkerRegistration$I ~objも、
次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported, as event handler IDL attributes, by all objects implementing ServiceWorkerRegistration interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
<tbody>

<tr><td>`onupdatefound@m
<td>`updatefound$et
</table>

			</section>
		</section>
		<section id="navigator-serviceworker">
<h3 title="navigator.serviceWorker">3.3. `serviceWorker^m</h3>

<pre class="idl">
partial interface `Navigator$I {
  [`SecureContext$, `SameObject$] readonly attribute `ServiceWorkerContainer$I `serviceWorker$n;
};

partial interface `WorkerNavigator$I {
  [`SecureContext$, `SameObject$] readonly attribute `ServiceWorkerContainer$I `serviceWorker$n;
};
</pre>

<p>
`serviceWorker@n
取得子~手続きは
⇒
~RET コレに結付けられた `ServiceWorkerContainer$I ~obj
◎
The serviceWorker getter steps are to return the ServiceWorkerContainer object that is associated with this.
</p>

		</section>
		<section id="serviceworkercontainer-interface">
<h3>3.4. `ServiceWorkerContainer^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `ServiceWorkerContainer@I : `EventTarget$I {
  readonly attribute `ServiceWorker$I? `controller$m;
  readonly attribute `Promise$&lt;`ServiceWorkerRegistration$I&gt; `ready$m;

  [`NewObject$] `Promise$&lt;`ServiceWorkerRegistration$I&gt; `register$m((`TrustedScriptURL$c or `USVString$) %scriptURL, optional `RegistrationOptions$I %options = {});

  [`NewObject$] `Promise$&lt;(`ServiceWorkerRegistration$I or `undefined$)&gt; `getRegistration$m(optional `USVString$ %clientURL = "");
  [`NewObject$] `Promise$&lt;`FrozenArray$&lt;`ServiceWorkerRegistration$I&gt;&gt; `getRegistrations$m();

  `undefined$ `startMessages$m();

  // events
  attribute `EventHandler$I `oncontrollerchange$m;
  attribute `EventHandler$I `onmessage$m; /* <span class="comment">
`message$etC ~eventの `source^m 属性は `ServiceWorker$I ~objになる
◎
event.source of message events is ServiceWorker object
</span> */
  attribute `EventHandler$I `onmessageerror$m;
};
</pre>

<pre class="idl" id="registration-option-list-dictionary">
dictionary `RegistrationOptions@I {
  `USVString$ `scope@m;
  `WorkerType$I `type@m = `classic^l;
  `ServiceWorkerUpdateViaCache$I `updateViaCache@m = `imports^l;
};
</pre>

<p>
~UAは、［
`Navigator$I ／ `WorkerNavigator$I
］~objを作成したときには、
`ServiceWorkerContainer$I ~objを作成して，前者に後者を結付けるモノトスル。
◎
The user agent must create a ServiceWorkerContainer object when a Navigator object or a WorkerNavigator object is created and associate it with that object.
</p>

<p>
`ServiceWorkerContainer$I は、
`~sw登録$ %登録 を［
登録する, 未登録にする, 更新する
］能力，および［
%登録 の状態, および
%登録 に結付けられた`~sw$たち
］への~accessを供する。
◎
A ServiceWorkerContainer provides capabilities to register, unregister, and update the service worker registrations, and provides access to the state of the service worker registrations and their associated service workers.
</p>

<p>
各 `ServiceWorkerContainer$I ~obj %容器 には、
以下に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>
`~sw~client@SWC
◎
A ServiceWorkerContainer has an associated service worker client,＼
</dt>
	<dd>
次を満たす`~sw~client$ %~client を指す
⇒
［
%~client の`大域~obj$enVに結付けられた［
`Navigator$I ／ `WorkerNavigator$I
］~objに結付けられた `ServiceWorkerContainer$I ~obj
］ ~EQ %容器
◎
which is a service worker client whose global object is associated with the Navigator object or the WorkerNavigator object that the ServiceWorkerContainer is retrieved from.
</dd>
	<dd class="trans-note">【
すなわち， 大域~obj . `navigator^n . `serviceWorker$n ~EQ %容器
】</dd>

	<dt>
`準備済み~promise@SWC
◎
A ServiceWorkerContainer object has an associated ready promise＼
</dt>
	<dd>
`~promise$ ／ ~NULL
◎
(a promise or null).＼
</dd>
	<dd>
初期~時は ~NULL とする
◎
It is initially null.
</dd>

	<dt>
`~client~message~queue@SWC
◎
A ServiceWorkerContainer object has a task source called the client message queue,＼
</dt>
	<dd>
`~task~source$
【すなわち、`~task~queue$であると同時に，独立な~task~sourceを成す。】
◎
↑</dd>
	<dd>
初期~時は空とする。
◎
initially empty.＼
</dd>
	<dd>
この~queueは［
可能化-／不能化-
］され得る
— 初期~時は不能化されているとする。
可能化されたときは、
`~event~loop$は，それを自身の`~task~source$の一つとして利用するモノトスル。
【すなわち，可能化されている間に限り、~queueを成す~taskたちを~event~loopの中で走らす。】
◎
A client message queue can be enabled or disabled, and is initially disabled. When a ServiceWorkerContainer object’s client message queue is enabled, the event loop must use it as one of its task sources.＼
</dd>
	<dd>
［
%容器 に`関連な大域~obj$ %G が`~window$である
］ときは、
この~queueに`~queueされ$たすべての`~task$には，
%G に`結付けられた文書$を結付けるモノトスル。
【すなわち、~taskの`文書$tK ~SET その文書】
◎
When the ServiceWorkerContainer object’s relevant global object is a Window object, all tasks queued on its client message queue must be associated with its relevant settings object’s associated document.
</dd>
</dl>

`ServiceWorkerContainer^I0

			<section id="navigator-service-worker-controller">
<h4>3.4.1. `controller^m</h4>

<p>
`controller@m
取得子~手続きは：
◎
controller attribute must run these steps:
</p>
<ol>
	<li>
%~client ~LET コレの`~sw~client$SWC
◎
Let client be this’s service worker client.
</li>
	<li>
~IF［
%~client にて`作動中な~sw$enV ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If client’s active service worker is null, then return null.
</li>
	<li>
~RET `~sw~objを取得する$( %~client にて`作動中な~sw$enV, コレに`関連な設定群~obj$ )
◎
Return the result of getting the service worker object that represents client’s active service worker in this’s relevant settings object.
</li>
</ol>

<p class="note">注記：
<code>navigator . `serviceWorker$n . `controller$m</code>
は、
要請が~refresh（ <kbd>shift+refresh</kbd>† ）を強制する場合には ~NULL を返す。
【結果は、 %~client を`制御-$している~swを表現する。】
【† ~cacheされていないかのように同じ資源を要請し直す（ “強制再読み込み” ）】
【！shift+reload も現れる】
◎
Note: navigator.serviceWorker.controller returns null if the request is a force refresh (shift+refresh).
</p>

			</section>
			<section id="navigator-service-worker-ready">
<h4>3.4.2. `ready^m</h4>

<p>
`ready@m
取得子~手続きは：
◎
ready attribute must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`準備済み~promise$SWC ~EQ ~NULL
］
⇒
コレの`準備済み~promise$SWC ~SET `新たな~promise$
◎
If this’s ready promise is null, then set this’s ready promise to a new promise.
</li>
	<li>
%準備済み~promise ~LET コレの`準備済み~promise$SWC
◎
Let readyPromise be this’s ready promise.
</li>
	<li>
<p>
~IF［
%準備済み~promise は決着している
］：
◎
If readyPromise is pending,＼
</p>
		<ol>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
run the following substeps in parallel:
</p>
				<ol>
					<li>
%~client ~LET コレの`~sw~client$SWC
◎
Let client by this’s service worker client.
</li>
					<li>
%~storage~key ~LET `~storage~keyを得する$( %~client )
◎
Let storage key be the result of running obtain a storage key given client.
</li>
					<li>
%登録 ~LET `合致する~sw登録$( %~storage~key, %~client の`作成時の~URL$enV )
◎
Let registration be the result of running Match Service Worker Registration given storage key and client’s creation URL.
</li>
					<li>
<p>
~IF［
%登録 ~NEQ ~NULL
］~AND［
%登録 にて`作動中な~worker$swr ~NEQ ~NULL
］
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %準備済み~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %準備済み~promise, 次の結果 )
⇒
`~sw登録~objを取得する$( %登録, %準備済み~promise に`関連な設定群~obj$ )
</div>
◎
If registration is not null, and registration’s active worker is not null, queue a task on readyPromise’s relevant settings object’s responsible event loop, using the DOM manipulation task source, to resolve readyPromise with the result of getting the service worker registration object that represents registration in readyPromise’s relevant settings object.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %準備済み~promise
◎
Return readyPromise.
</li>
</ol>

<p class="note">注記：
返される`準備済み~promise$SWCが却下されることは決してない。
この~algo内で解決されなかった場合、
最終的に，合致する`~sw登録$が登録され, その`作動中な~worker$swrが設定されたときに解決されることになる
（ `作動化する~algoの関連な段＠#activate-resolve-ready-step$
を見よ）。
◎
Note: The returned ready promise will never reject. If it does not resolve in this algorithm, it will eventually resolve when a matching service worker registration is registered and its active worker is set. (See the relevant Activate algorithm step.)
</p>

			</section>
			<section id="navigator-service-worker-register">
<h4>3.4.3. `register(scriptURL, options)^m</h4>

<p class="note">注記：
この~methodは、
所与の`~scope~URL$swr用に`~sw登録$を作成する, あるいは更新する。
成功した場合、
`~sw登録$は，供された %scriptURL を`~scope~URL$swrに束ねる
— それは、
後続して
`~naviと照合する＠#handle-fetch$
ときにも利用される。
◎
Note: The register(scriptURL, options) method creates or updates a service worker registration for the given scope url. If successful, a service worker registration ties the provided scriptURL to a scope url, which is subsequently used for navigation matching.
</p>

<p>
`register(scriptURL, options)@m
~method手続きは：
◎
The register(scriptURL, options) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a promise.
</li>
	<li>
%scriptURL ~SET `信用-済みな型に準拠する文字列を取得する$( ↓ )
⇒＃
`TrustedScriptURL$c,
コレに`関連な大域~obj$,
%scriptURL,
`ServiceWorkerContainer register^l,
`script^l
◎
Set scriptURL to the result of invoking Get Trusted Type compliant string with TrustedScriptURL, this’s relevant global object, scriptURL, "ServiceWorkerContainer register", and "script".
</li>
	<li>
%~client ~LET コレの`~sw~client$SWC
◎
Let client be this’s service worker client.
</li>
	<li>
%~script~URL ~LET `~URL構文解析する$( %scriptURL, コレに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let scriptURL be the result of parsing scriptURL with this’s relevant settings object’s API base URL.
</li>
	<li>
%~scope~URL ~LET ~NULL
◎
Let scopeURL be null.
</li>
	<li>
`RegistrationOptions^I1
%scope ~LET %options[ "`scope$m1" ]
◎
↓</li>
	<li>
~IF［
%scope ~NEQ ε
］
⇒
%~scope~URL ~SET `~URL構文解析する$( %scope, コレに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
If options["scope"] exists, set scopeURL to the result of parsing options["scope"] with this’s relevant settings object’s API base URL.
</li>
	<li>
`登録を開始する$( ↓ )
⇒＃
%~scope~URL,
%~script~URL,
%~promise,
%~client,
%~client の`作成時の~URL$enV,
%options[ "`type$m1" ],
%options[ "`updateViaCache$m1" ]
◎
Invoke Start Register with scopeURL, scriptURL, p, client, client’s creation URL, options["type"], and options["updateViaCache"].
</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-getRegistration">
<h4>3.4.4. `getRegistration(clientURL)^m</h4>

<p>
`getRegistration(clientURL)@m
~method手続きは：
◎
getRegistration(clientURL) method steps are:
</p>
<ol>
	<li>
%~client ~LET コレの`~sw~client$SWC
◎
Let client be this’s service worker client.
</li>
	<li>
%~storage~key ~LET `~storage~keyを得する$( %~client )
◎
Let storage key be the result of running obtain a storage key given client.
</li>
	<li>
%clientURL ~LET `~URL構文解析する$( %clientURL, コレに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let clientURL be the result of parsing clientURL with this’s relevant settings object’s API base URL.
</li>
	<li>
~IF［
%clientURL ~EQ `失敗^i
］
⇒
~RET `却下される~promise$( `TypeError^E 例外 )
◎
If clientURL is failure, return a promise rejected with a TypeError.
</li>
	<li>
%clientURL の`素片$url ~SET ~NULL
◎
Set clientURL’s fragment to null.
</li>
	<li>
~IF［
%clientURL の`生成元$url
~NEQ`生成元$sub
%~client の`生成元$cl【！`生成元$enV】
【！is not】
］
⇒
~RET `却下される~promise$( `SecurityError$E 例外 )
◎
If the origin of clientURL is not client’s origin, return a promise rejected with a "SecurityError" DOMException.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET `合致する~sw登録$( %~storage~key, %clientURL )
◎
Let registration be the result of running Match Service Worker Registration given storage key and clientURL.
</li>
			<li>
~IF［
%登録 ~EQ ~NULL
］
⇒
`~promiseを解決する$( %~promise )
◎
If registration is null, resolve promise with undefined and abort these steps.
</li>
			<li>
~ELSE
⇒
`~promiseを解決する$( %~promise, 次の結果 )
⇒
`~sw登録~objを取得する$( %登録, %~promise に`関連な設定群~obj$ )
◎
Resolve promise with the result of getting the service worker registration object that represents registration in promise’s relevant settings object.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-getRegistrations">
<h4>3.4.5. `getRegistrations()^m</h4>

<p>
`getRegistrations()@m
~method手続きは：
◎
getRegistrations() method steps are:
</p>
<ol>
	<li>
%~client ~LET コレの`~sw~client$SWC
◎
Let client be this’s service worker client.
</li>
			<li>
%~client~storage~key ~LET `~storage~keyを得する$( %~client )
◎
Let client storage key be the result of running obtain a storage key given client.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%登録~list ~LET 新たな`~list$
◎
Let registrations be a new list.
</li>
			<li>
`登録~map$を成す
~EACH( ( %~storage~key, %~scope ) → %登録 )
に対し
⇒
~IF［［
%~storage~key, %~client~storage~key
］は`同等な~storage~key$である
］
⇒
%登録~list に %登録 を`付加する$
◎
For each (storage key, scope) → registration of registration map:
• If storage key equals client storage key, then append registration to registrations.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task on promise’s relevant settings object’s responsible event loop, using the DOM manipulation task source, to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
%登録~obj~list ~LET 新たな`~list$
◎
Let registrationObjects be a new list.
</li>
					<li>
%登録~list 内の
~EACH( `~sw登録$ )
に対し
⇒
%登録~obj~list に次の結果を`付加する$
⇒
`~sw登録~objを取得する$( %登録, %~promise に`関連な設定群~obj$ )
◎
For each registration of registrations:
• Let registrationObj be the result of getting the service worker registration object that represents registration in promise’s relevant settings object.
• Append registrationObj to registrationObjects.
</li>
					<li>
`~promiseを解決する$( %~promise, 次の結果 )
⇒
%~promise に`関連な~realm$内で`凍結d配列を作成する$( %登録~obj~list )
◎
Resolve promise with a new frozen array of registrationObjects in promise’s relevant Realm.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigator-service-worker-startMessages">
<h4>3.4.6. `startMessages()^m</h4>

<p>
`startMessages()@m
~method手続きは、
コレの`~client~message~queue$SWCを
— 可能化されていなければ —
可能化する。
◎
The startMessages() method steps are to enable this’s client message queue if it is not enabled.
</p>

			</section>
			<section id="service-worker-container-event-handlers">
<h4 title="Event handlers">3.4.7. ~event~handler</h4>

<p>
どの `ServiceWorkerContainer$I ~objも、
次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the ServiceWorkerContainer interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
<tbody>

<tr><td>`oncontrollerchange@m
<td>`controllerchange$etC

<tr><td>`onmessage@m
<td>`message$etC

<tr><td>`onmessageerror@m
<td>`messageerror$etC
</table>

<p>
コレの `onmessage$m 設定子~手続きが初回に遂行されたときは、
コレの`~client~message~queue$SWCを可能化するモノトスル。
◎
The first time the onmessage setter steps are performed, enable this’s client message queue.
</p>

			</section>
		</section>
		<section id="document-context-events">
<h3 title="Events">3.5. ~event</h3>

<div>
<p>
次の表tの 1 列目に挙げる~eventが、
同じ行の 2 列目に挙げる~objに向けて配送される
— いずれも， `Event$I を実装する：
</p>

<table id="_event-table1" class="grid-table"><thead>
<tr><th>~event名
<th>配送-先
<th>配送-時機
<tbody>

<tr><td>`statechange@et
<td>`ServiceWorker$I
<td>`ServiceWorker$I1 ~objの `state$m1 属性が変化したとき。

<tr><td>`updatefound@et
<td>`ServiceWorkerRegistration$I
<td>~objが`表現する~sw登録$にて`~install中の~worker$swrが変化したとき
（`~installする$ ~algoを見よ）。

<tr><td>`controllerchange@etC
<td>`ServiceWorkerContainer$I
<td>
<p>
`~sw~client$SWCにて`作動中な~sw$enVが変化したとき
（`作動化する$~algoを見よ）。
</p>
<p>
［
`~sw$の`待機を飛ばすか$sw ~EQ ~T
］の下では、
`~sw~client$たちが`~sw登録$を`利用して$いる間，`~sw登録$を`作動化する$
— `作動中な~worker$swrは，即時に，`~sw~client$を`制御-$している`~sw$として
<code>navigator . `ServiceWorkerContainer^I1`serviceWorker$n . `controller$m1</code>
に反映される。）
</p>

<tr><td>`message@etC
<td>`ServiceWorkerContainer$I
<td>
`~sw~client$SWCは、
`~sw$から~messageを受信したとき。
`~postMessageClient(message, options)$n を見よ。

<tr><td>`messageerror@etC
<td>`ServiceWorkerContainer$I
<td>
`~sw~client$SWCは、
`~sw$から逆直列化できない~messageを送信したとき。
`~postMessageClient(message, options)$n を見よ。
</table>

◎
The following event is dispatched on ServiceWorker object:
• Event name 	Interface 	Dispatched when…
• statechange 	Event 	The state attribute of the ServiceWorker object is changed.
◎
The following event is dispatched on ServiceWorkerRegistration object:
• Event name 	Interface 	Dispatched when…
• updatefound 	Event 	The service worker registration’s installing worker changes. (See step 8 of the Install algorithm.)
◎
The following events are dispatched on ServiceWorkerContainer object:
• Event name 	Interface 	Dispatched when…
• controllerchange 	Event 	The service worker client’s active service worker changes. (See step 9.2 of the Activate algorithm. The skip waiting flag of a service worker causes activation of the service worker registration to occur while service worker clients are using the service worker registration, navigator.serviceWorker.controller immediately reflects the active worker as the service worker that controls the service worker client.)
• message 	Event 	The service worker client receives a message from a service worker. See postMessage(message, options).
• messageerror 	Event 	The service worker client is sent a message that cannot be deserialized from a service worker. See postMessage(message, options).
</div>

		</section>
		<section id="navigation-preload-manager">
<h3>3.6. `NavigationPreloadManager^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `NavigationPreloadManager@I {
  `Promise$&lt;`undefined$&gt; `enable$m();
  `Promise$&lt;`undefined$&gt; `disable$m();
  `Promise$&lt;`undefined$&gt; `setHeaderValue$m(`ByteString$ %value);
  `Promise$&lt;`NavigationPreloadState$I&gt; `getState$m();
};

dictionary `NavigationPreloadState@I {
  `boolean$ `enabled@m = false;
  `ByteString$ `headerValue@m;
};
</pre>

`NavigationPreloadManager^I0

			<section id="navigation-preload-manager-enable">
<h4>3.6.1. `enable()^m</h4>

<p>
`enable()@m
~method手続きは：
◎
The enable() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET コレを結付けている`~sw登録$
◎
Let registration be this’s associated service worker registration.
</li>
			<li>
~IF［
%登録 にて`作動中な~worker$swr ~EQ ~NULL
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E 例外 )；
~RET
◎
If registration’s active worker is null, reject promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
			<li>
%登録 の`~navi~preloadは可能化されるか$swr ~SET ~T
◎
Set registration’s navigation preload enabled flag.
</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigation-preload-manager-disable">
<h4>3.6.2. `disable()^m</h4>

<p>
`disable()@m
~method手続きは：
◎
The disable() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET コレを結付けている`~sw登録$
◎
Let registration be this’s associated service worker registration.
</li>
			<li>
~IF［
%登録 にて`作動中な~worker$swr ~EQ ~NULL
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E 例外 )；
~RET
◎
If registration’s active worker is null, reject promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
			<li>
%登録 の`~navi~preloadは可能化されるか$swr ~SET ~F
◎
Unset registration’s navigation preload enabled flag.
</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigation-preload-manager-setheadervalue">
<h4>3.6.3. `setHeaderValue(value)^m</h4>

<p>
`setHeaderValue(value)@m
~method手続きは：
◎
The setHeaderValue(value) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET コレを結付けている`~sw登録$
◎
Let registration be this’s associated service worker registration.
</li>
			<li>
~IF［
%登録 にて`作動中な~worker$swr ~EQ ~NULL
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E 例外 )；
~RET
◎
If registration’s active worker is null, reject promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
			<li>
%登録 の`~navi~preload~header値$swr ~SET %value
◎
Set registration’s navigation preload header value to value.
</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="navigation-preload-manager-getstate">
<h4>3.6.4. `getState()^m</h4>

<p>
`getState()@m
~method手続きは：
◎
The getState() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%登録 ~LET コレを結付けている`~sw登録$
◎
Let registration be this’s associated service worker registration.
</li>
			<li>
%状態 ~LET 新たな `NavigationPreloadState$I 辞書
◎
Let state be a new NavigationPreloadState dictionary.
</li>
			<li>
`NavigationPreloadState^I1
%状態[ "`enabled$m1" ] ~SET %登録 の`~navi~preloadは可能化されるか$swr
◎
If registration’s navigation preload enabled flag is set, set state["enabled"] to true.
</li>
			<li>
%状態[ "`headerValue$m1" ] ~SET %登録 の`~navi~preload~header値$swr
◎
Set state["headerValue"] to registration’s navigation preload header value.
</li>
			<li>
`~promiseを解決する$( %~promise, %状態 )
◎
Resolve promise with state.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="execution-context">
<h2 title="Execution Context">4. 実行~文脈</h2>

<div class="example">

<p>
~cacheされた資源たちの~serve法：
◎
Serving Cached Resources:
</p>

<pre class="lang-js">
// caching.js
self.addEventListener("install", %event =&gt; {
  %event.`waitUntil$n(
    /* <span class="comment">
資源たちが成す~cacheを~openする。
◎
Open a cache of resources.
</span> */
    `caches$n.`CacheStorage^I1`open$m1("shell-v1").then(%cache =&gt; {
      /* <span class="comment">
それらを~fetchする処理nを始める。
成功するのは、
すべての資源が格納されたときに限られる
— 一つでも失敗した資源があれば、
演算~全体は失敗する。
◎
Begins the process of fetching them. Succeeds only once all resources have been stored. Even just one failing resource causes the entire operation to fail.
</span> */
      return %cache.addAll([
        "/app.html",
        "/assets/v1/base.css",
        "/assets/v1/app.js",
        "/assets/v1/logo.png",
        "/assets/v1/intro_video.webm"
      ]);
    })
  );
});

self.addEventListener("fetch", %event =&gt; {
  /* <span class="comment">
成功裡に~installされ, 作動化されるまでは、
~swに向けて `fetch$et ~eventが配送されることはない。
◎
No "fetch" events are dispatched to the service worker until it successfully installs and activates.
</span> */

  /* <span class="comment">
合致している~URLも含め，~cache上のすべての演算は非同期cなので、
~promiseを多用する。
これを可能化するため， `respondWith()$n も~promiseを引数にとる：
◎
All operations on caches are async, including matching URLs, so we use promises heavily. e.respondWith() even takes promises to enable this:
</span> */
  %event.respondWith(
    `caches$n.`Cache^I1`match$m1(%e.request).then(%response =&gt; {
      return %response || fetch(%e.request);
    }).catch(() =&gt; {
      return caches.match("/fallback.html");
    })
  );
});
</pre>

</div>

		<section id="serviceworkerglobalscope-interface">
<h3>4.1. `ServiceWorkerGlobalScope^I</h3>

<pre class="idl">
[`Global$=(`Worker$I,`ServiceWorker$I), `Exposed$=ServiceWorker, `SecureContext$]
interface `ServiceWorkerGlobalScope@I : `WorkerGlobalScope$I {
  [`SameObject$] readonly attribute `Clients$I `clients$m;
  [`SameObject$] readonly attribute `ServiceWorkerRegistration$I `registration$m;
  [`SameObject$] readonly attribute `ServiceWorker$I `serviceWorker$m;

  [`NewObject$] `Promise$&lt;`undefined$&gt; `skipWaiting$m();

  attribute `EventHandler$I `oninstall$m;
  attribute `EventHandler$I `onactivate$m;
  attribute `EventHandler$I `onfetch$m;

  attribute `EventHandler$I `onmessage$m;
  attribute `EventHandler$I `onmessageerror$m;
};
</pre>

<p>
`ServiceWorkerGlobalScope$I ~objは、
`~sw$の大域~実行~文脈を表現する。
各 `ServiceWorkerGlobalScope$I ~objには、
次に挙げるものが結付けられる：
◎
A ServiceWorkerGlobalScope object represents the global execution context of a service worker.
</p>
<ul>
	<li>
`~sw@SWG
⇒
ある`~sw$
◎
A ServiceWorkerGlobalScope object has an associated service worker (a service worker).
</li>
	<li>
`~importする~script用には~cacheを迂回するよう強制するか@SWG
⇒
ある真偽値
— 初期~時は ~F とする。
◎
A ServiceWorkerGlobalScope object has an associated force bypass cache for import scripts flag. It is initially unset.
</li>
	<li>
`競走~応答~map@SWG
⇒
`有順序~map$
— 各~entryは［
`要請$ → `競走~応答$
］を与える。
◎
A ServiceWorkerGlobalScope object has an associated race response map which is an ordered map where the keys are requests and the values are race response.
</li>
</ul>

<p>
`競走~応答@
は、
次に挙げる~itemを伴う`構造体$であり，［
`race-network-and-fetch-handler$l を遂行するときに，当の~network応答を包含する
］ために利用される：
◎
A race response is a struct used to contain the network response when "race-network-and-fetch-handler" performs.＼
</p>
<ul>
	<li>
`値@rV
⇒＃
ある`応答$／
`pending^l ／
~NULL
◎
It has a value, which is a response, "pending", or null.
</li>
</ul>

<p class="note">注記：
`ServiceWorkerGlobalScope$I ~objは、
生成元の下で走らす［
汎用な, ~event駆動な, 時間~制限付きな
］~script実行~文脈を供する。
成功裡に`登録-$されたなら、
`~sw$は，［
`~sw~client$ではなく，~event
］との関係性に基づいて
開始され, 生存し続け, ~killされる。
`~sw$の内側においては、
いかなる型の同期的な要請も，起動されてはナラナイ。
◎
Note: ServiceWorkerGlobalScope object provides generic, event-driven, time-limited script execution contexts that run at an origin. Once successfully registered, a service worker is started, kept alive and killed by their relationship to events, not service worker clients. Any type of synchronous requests must not be initiated inside of a service worker.
</p>

			<section id="service-worker-global-scope-clients">
<h4>4.1.1. `clients^m</h4>

<p>
`clients@m
取得子~手続きは
⇒
~RET コレに`結付けられた＠#_serviceworkerglobalscope-client$ `Clients$I ~obj
◎
The clients getter steps are to return the Clients object that is associated with this.
</p>

			</section>
			<section id="service-worker-global-scope-registration">
<h4>4.1.2. `registration^m</h4>

<p>
`registration@m
取得子~手続きは
⇒
~RET `~sw登録~objを取得する$( コレの`~sw$SWGを`包含している~sw登録$sw, コレに`関連な設定群~obj$ )
◎
The registration getter steps are to return the result of getting the service worker registration object representing this’s service worker’s containing service worker registration in this’s relevant settings object.
</p>

			</section>
			<section id="service-worker-global-scope-serviceworker">
<h4>4.1.3. `serviceWorker^m</h4>

<p>
`serviceWorker@m
取得子~手続きは
⇒
~RET `~sw~objを取得する$( コレの`~sw$SWG, コレに`関連な設定群~obj$ )
◎
The serviceWorker getter steps are to return the result of getting the service worker object that represents this’s service worker in this’s relevant settings object.
</p>

			</section>
			<section id="service-worker-global-scope-skipwaiting">
<h4>4.1.4. `skipWaiting()^m</h4>

<p class="note">注記：
この~methodは、コレの`~sw$SWG【！`~sw$】が，それを`包含している~sw登録$swにて`待機-中な~worker$swrから`作動中な~worker$swrになることを許容する
— その登録を`利用して$いる`~sw~client$がある間でも。
◎
Note: The skipWaiting() method allows this service worker to progress from the registration’s waiting position to active even while service worker clients are using the registration.
</p>

<p>
`skipWaiting()@m
~method手続きは：
◎
The skipWaiting() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
コレの`~sw$SWGの`待機を飛ばすか$sw ~SET ~T
◎
Set service worker’s skip waiting flag.
</li>
			<li>
`作動化するよう試行する$( コレの`~sw$SWGを`包含している~sw登録$sw )
◎
Invoke Try Activate with service worker’s containing service worker registration.
</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="service-worker-global-scope-event-handlers">
<h4 title="Event handlers">4.1.5. ~event~handler</h4>

<p>
どの `ServiceWorkerGlobalScope$I ~objも、
次に挙げる`~event~handler$（および対応する`~event~handler~event型$）を，`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the ServiceWorkerGlobalScope interface:
</p>

<table><thead>
<tr><th>`~event~handler$
<th>`~event~handler~event型$
<tbody>

<tr><td>`oninstall@m
<td>`install$et

<tr><td>`onactivate@m
<td>`activate$et

<tr><td>`onfetch@m
<td>`fetch$et

<tr><td>`onmessage@m
<td>`message$et【！etC】

<tr><td>`onmessageerror@m
<td>`messageerror$et【！etC】
</table>

			</section>
		</section>
		<section id="client-interface">
<h3>4.2. `Client^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `Client@I {
  readonly attribute `USVString$ `url$m;
  readonly attribute `FrameType$I `frameType$m;
  readonly attribute `DOMString$ `id$m;
  readonly attribute `ClientType$I `type$m;
  `undefined$ `postMessage$m(`any$ %message, `sequence$&lt;`object$&gt; %transfer);
  `undefined$ `~postMessageClient$n(`any$ %message, optional `StructuredSerializeOptions$I %options = {});
};

[`Exposed$=ServiceWorker]
interface `WindowClient@I : `Client$I {
  readonly attribute `DocumentVisibilityState$I【！VisibilityState】 `visibilityState$m;
  readonly attribute `boolean$ `focused$m;
  [`SameObject$] readonly attribute `FrozenArray$&lt;`USVString$&gt; `ancestorOrigins$m;
  [`NewObject$] `Promise$&lt;`WindowClient$I&gt; `focus$m();
  [`NewObject$] `Promise$&lt;`WindowClient$I?&gt; `navigate$m(`USVString$ %url);
};

enum `FrameType@I {
  "`auxiliary@m",
  "`top-level@m",
  "`nested@m",
  "`none@m"
};
</pre>

<p>
各 `Client$I ~objには、
以下に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`~sw~client@cl
⇒
ある`~sw~client$
◎
A Client object has an associated service worker client (a service worker client).
</li>
	<li>
`~frame種別@cl
⇒
ある `FrameType$I 値
— 他が言明されない限り， `none^l とする。
【値の意味は、`~frame種別を取得する$を見よ。】
◎
A Client object has an associated frame type, which is one of "auxiliary", "top-level", "nested", and "none". Unless stated otherwise it is "none".
</li>
</ul>

<p>
各 `WindowClient$I ~objには、
以下に挙げるものも結付けられる：
◎
↓</p>
<ul>
	<li>
`閲覧~文脈@cl
⇒
自身の`~sw~client$clの`大域~obj$enVの`閲覧~文脈$を指す。
【すなわち、大域~obj（それは，`~window$である）に`対応する閲覧~文脈$】
◎
A WindowClient object has an associated browsing context, which is its service worker client’s global object’s browsing context.
</li>
	<li>
`可視性~状態@cl
⇒
次に挙げるいずれか
（ `visibilityState$n 属性がとり得る値）
⇒
`hidden^l ／ `visible^l
◎
A WindowClient object has an associated visibility state, which is one of visibilityState attribute value.
</li>
	<li>
`~focus状態@cl
⇒
ある真偽値
— 初期~時は ~F とする。
◎
A WindowClient object has an associated focus state, which is either true or false (initially false).
</li>
	<li>
`先祖~生成元~配列@cl
⇒
【`先祖~生成元~list$に設定されることになる。】
◎
A WindowClient object has an associated ancestor origins array.
</li>
</ul>

`Client^I0

			<section id="client-url">
<h4>4.2.1. `url^m</h4>

<p>
`url@m
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレの`~sw~client$clの`作成時の~URL$enV )
◎
The url getter steps are to return this’s associated service worker client’s serialized creation URL.
</p>

			</section>
			<section id="client-frametype">
<h4>4.2.2. `frameType^m</h4>

<p>
`frameType@m
取得子~手続きは
⇒
~RET コレの`~frame種別$cl
◎
The frameType getter steps are to return this’s frame type.
</p>

			</section>
			<section id="client-id">
<h4>4.2.3. `id^m</h4>

<p>
`id@m
取得子~手続きは
⇒
~RET コレの`~sw~client$clの`~ID$enV
◎
The id getter steps are to return this’s associated service worker client’s id.
</p>

			</section>
			<section id="client-type">
<h4>4.2.4. `type^m</h4>

<p>
`type@m
取得子~手続きは
⇒
~RET コレの`~sw~client$clに応じて
⇒＃
`環境~設定群~obj$でないならば `window$l ／
`~window~client$であるならば `window$l ／
`専用~worker~client$であるならば `worker$l ／
`共用~worker~client$であるならば `sharedworker$l
◎
The type getter steps are:
◎
Let client be this’s service worker client.
◎
If client is an environment settings object, then:
• If client is a window client, return "window".
• Else if client is a dedicated worker client, return "worker".
• Else if client is a shared worker client, return "sharedworker".
◎
Else:
• Return "window".
</p>

			</section>
			<section id="client-postmessage">
<h4>4.2.5. `postMessage(message, transfer)^m</h4>

<p>
`postMessage(message, transfer)@m
~method手続きは：
◎
The postMessage(message, transfer) method steps are:
</p>
<ol>
	<li>
%options ~LET «[ `transfer^l → %transfer ]»
◎
Let options be «[ "transfer" → transfer ]».
</li>
	<li>
コレ上で `~postMessageClient(message, options)$n ~method手続き（次節）を遂行する
◎
Invoke postMessage(message, options) with message and options as the arguments.
</li>
</ol>

			</section>
			<section id="client-postmessage-options">
<h4>4.2.6. `~postMessageClient(message, options)^m</h4>

<p>
`~postMessageClient(message, options)@n
~method手続きは：
◎
The postMessage(message, options) method steps are:
</p>
<ol>
	<li>
%~source設定群 ~LET コレに`関連な設定群~obj$
◎
Let contextObject be this.
◎
Let sourceSettings be the contextObject’s relevant settings object.
</li>
	<li>
%直列化した転送-結果 ~LET
~ABRUPT `StructuredSerializeWithTransfer$jA( %message, %options[ "`transfer$n" ] )
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, options["transfer"]). Rethrow any exceptions.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~target~client ~LET ~NULL
◎
Let targetClient be null.
</li>
			<li>
~EACH( `~sw~client$ %~client )
に対し
⇒
~IF［
%~client ~EQ コレの`~sw~client$cl
］
⇒
%~target~client ~SET コレの`~sw~client$cl
◎
For each service worker client client:
• If client is the contextObject’s service worker client, set targetClient to client, and break.
</li>
			<li>
<p>
~IF［
%~target~client ~EQ ~NULL
］
⇒
~RET
◎
If targetClient is null, return.
</p>

<div class="trans-note">
<p>【
定義により，
コレの`~sw~client$clは`~sw~client$であるので、
この条件は，決して満たされないことになる。
この段までの処理nは、
実際には，次を行うのではないかと思われる：
】</p>
				<ol>
					<li>
%~target~client ~LET コレの`~sw~client$cl
</li>
					<li>
~IF［
%~target~client の`破棄-済みか$ ~EQ ~T
］
⇒
~RET
</li>
				</ol>
</div>
			</li>
			<li>
%行先 ~LET 次を満たす `ServiceWorkerContainer$I ~obj
⇒
その`~sw~client$SWC ~EQ %~target~client
◎
Let destination be the ServiceWorkerContainer object whose associated service worker client is targetClient.
</li>
			<li>
<p>
%行先 の`~client~message~queue$SWCに
次の手続きを走らす`~task$を追加する：
◎
Add a task that runs the following steps to destination’s client message queue:
</p>
				<ol>
					<li>
%生成元 ~LET `生成元を直列化する$( %~source設定群 の`生成元$enV )
◎
Let origin be the serialization of sourceSettings’s origin.
</li>
					<li>
%~source ~LET `~sw~objを取得する$( コレに`関連な大域~obj$の`~sw$SWG, %~target~client )
◎
Let source be the result of getting the service worker object that represents contextObject’s relevant global object’s service worker in targetClient.
</li>
					<li>
<p>
%逆直列化-~record ~LET 
`StructuredDeserializeWithTransfer$jA( %直列化した転送-結果, %行先 に`関連な~realm$ )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, destination’s relevant Realm).
</p>

<div class="p">
<p>
例外が投出されたときは、
~catchして：
</p>
						<ol>
							<li>
`~eventを発火する$( %行先, `messageerror$etC【！messageerror$et】, `MessageEvent$I )
— 次のように初期化して
⇒＃
`origin$n 属性 ~SET %生成元,
`source$n 属性 ~SET %~source
</li>
							<li>
~RET
</li>
						</ol>
◎
If this throws an exception, catch it, fire an event named messageerror at destination, using MessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source, and then abort these steps.
</div>
					</li>
					<li>
%新たな~port群 ~LET 
【%行先 に`関連な~realm$内で】
`凍結d配列を作成する$( %逆直列化-~record . `TransferredValues^sl 内のすべての `MessagePort$I ~objからなる同順の~list )
◎
Let messageClone be deserializeRecord.[[Deserialized]].
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any.
</li>
					<li>
`~eventを発火する$【！`~eventを配送する$】( %行先, `message$etC【！~HTMLindex#event-message】, `MessageEvent$I )
— 次のように初期化して
⇒＃
`origin$n 属性 ~SET %生成元,
`source$n 属性 ~SET %~source,
`data$n 属性 ~SET %逆直列化-~record . `Deserialized^sl,
`ports$n 属性 ~SET %新たな~port群
◎
Dispatch an event named message at destination, using MessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>

`WindowClient^I0

			<section id="client-visibilitystate">
<h4>4.2.7. `visibilityState^m</h4>

<p>
`visibilityState@m
取得子~手続きは
⇒
~RET コレの`可視性~状態$cl
◎
The visibilityState getter steps are to return this’s visibility state.
</p>

			</section>
			<section id="client-focused">
<h4>4.2.8. `focused^m</h4>

<p>
`focused@m
取得子~手続きは
⇒
~RET コレの`~focus状態$cl
◎
The focused getter steps are to return this’s focus state.
</p>

			</section>
			<section id="client-ancestororigins">
<h4>4.2.9. `ancestorOrigins^m</h4>

<p>
`ancestorOrigins@m
取得子~手続きは
⇒
~RET コレの`先祖~生成元~配列$cl
◎
The ancestorOrigins getter steps are to return this’s associated ancestor origins array.
</p>

			</section>
			<section id="client-focus">
<h4>4.2.10. `focus()^m</h4>

<p>
`focus()@m
~method手続きは：
◎
The focus() method steps are:
</p>
<ol>
	<li>
~IF［
この`生成元$【コレの`~sw~client$clの`生成元$cl】に属する`~window$のうち，
`一過な作動化を有して$いるものは無い
］
⇒
~RET `却下される~promise$( `InvalidAccessError$E 例外 )
◎
If no Window in this origin has transient activation, return a promise rejected with an "InvalidAccessError" DOMException.
</li>
	<li>
%~sw~event~loop ~LET `~surrounding~agent$の`~event~loop$aG
◎
Let serviceWorkerEventLoop be the surrounding agent’s event loop.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
`~taskを~queueする$( `利用者ヤリトリ~task~source$, 次の手続き, コレの`~sw~client$clの`担当の~event~loop$enV )
◎
Queue a task to run the following steps on this’s associated service worker client’s responsible event loop using the user interaction task source:
</p>

<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%~navigable ~LET コレの`閲覧~文脈$clに`対応する~navigable$bc
◎
↓</li>
			<li>
`~objを~focusする$( %~navigable )
◎
Run the focusing steps with this’s browsing context.
</li>
			<li>
%~frame種別 ~LET `~frame種別を取得する$( %~navigable )
◎
Let frameType be the result of running Get Frame Type with this’s browsing context.
</li>
			<li>
%作動中な文書 ~LET %~navigable にて`作動中な文書$nav
◎
↓</li>
			<li>
%可視性~状態 ~LET %作動中な文書 の `visibilityState$n 属性~値
◎
Let visibilityState be this’s browsing context’s active document’s visibilityState attribute value.
</li>
			<li>
%~focus状態 ~SET `~focusを有するか？$( %作動中な文書 )
◎
Let focusState be the result of running the has focus steps with this’s browsing context’s active document.
</li>
			<li>
%先祖~生成元~list ~LET %作動中な文書 の`先祖~生成元~文字列~list$
◎
Let ancestorOriginsList be this’s browsing context’s active document’s relevant global object’s Location object’s ancestor origins list’s associated list.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
</p>
<div class="algo">
<p>
手続きは：
</p>
				<ol>
					<li>
%~window~client ~LET 
`~window~clientを作成する$( ↓ )
⇒＃
コレの`~sw~client$cl,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
Let windowClient be the result of running Create Window Client with this’s associated service worker client, frameType, visibilityState, focusState, and ancestorOriginsList.
</li>
					<li>
~IF［
%~window~client の`~focus状態$cl ~EQ ~T
］
⇒
`~promiseを解決する$( %~promise, %~window~client )
◎
If windowClient’s focus state is true, resolve promise with windowClient.
</li>
					<li>
~ELSE
⇒
`~promiseを却下する$( %~promise, `TypeError^E )
◎
Else, reject promise with a TypeError.
</li>
				</ol>
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="client-navigate">
<h4>4.2.11. `navigate(url)^m</h4>

<p>
`navigate(url)@m
~method手続きは：
◎
The navigate(url) method steps are:
</p>
<ol>
	<li>
%~URL ~LET `~URL構文解析する$( %url, コレに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let url be the result of parsing url with this’s relevant settings object’s API base URL.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%~URL ~EQ `失敗^i
</li>
			<li>
%~URL ~EQ `about:blank^c
</li>
			<li>
コレの`~sw~client$clにて`作動中な~sw$enV~NEQ コレに`関連な大域~obj$の`~sw$SWG
</li>
		</ul>
<p>
…ならば
⇒
~RET `却下される~promise$( `TypeError^E 例外 )
</p>

◎
If url is failure, return a promise rejected with a TypeError.
◎
If url is about:blank, return a promise rejected with a TypeError.
◎
If this’s associated service worker client’s active service worker is not this’s relevant global object’s service worker, return a promise rejected with a TypeError.
</li>
	<li>
%~sw~event~loop ~LET `現在の大域~obj$の`~event~loop$
◎
Let serviceWorkerEventLoop be the current global object’s event loop.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
`~taskを~queueする$( `利用者ヤリトリ~task~source$, 次の手続き, コレの`~sw~client$clの`担当の~event~loop$enV )
◎
Queue a task to run the following steps on this’s associated service worker client’s responsible event loop using the user interaction task source:
</p>
<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%~navigable ~LET コレの`閲覧~文脈$clに`対応する~navigable$bc
◎
Let browsingContext be this’s browsing context.
</li>
			<li>
%作動中な文書 ~LET %~navigable にて`作動中な文書$nav
【！閲覧~文脈に`結付けられた文書$】
◎
↓</li>
			<li>
<p>
~IF［
%作動中な文書 は`全部的に作動中$でない
］：
</p>
				<ol>
					<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `TypeError^E )
</div>
					</li>
					<li>
~RET
</li>
				</ol>
◎
If browsingContext’s associated document is not fully active, queue a task to reject promise with a TypeError, on serviceWorkerEventLoop using the DOM manipulation task source, and abort these steps.
</li>
			<li>
【！ HandleNavigate】
`~navigableを~URLへ~navigateする$( %~navigable, %~URL【, %作動中な文書？】 )
— 次も与える下で
⇒＃
`例外を可能化するか^i ~SET ~T
◎
HandleNavigate: Navigate browsingContext to url, using browsingContext’s associated document, with exceptionsEnabled true.
</li>
			<li>
<p>
~IF［
前~段にて例外 %e が投出された
］：
</p>
				<ol>
					<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, %e )
</div>
					</li>
					<li>
~RET
</li>
				</ol>
◎
If the algorithm steps invoked in the step labeled HandleNavigate throws an exception, queue a task to reject promise with the exception, on serviceWorkerEventLoop using the DOM manipulation task source, and abort these steps.
</li>
			<li>
%~frame種別 ~LET `~frame種別を取得する$( %~navigable )
◎
Let frameType be the result of running Get Frame Type with browsingContext.
</li>
			<li>
%可視性~状態 ~LET %作動中な文書 の `visibilityState$n 属性~値
◎
Let visibilityState be browsingContext’s active document’s visibilityState attribute value.
</li>
			<li>
%~focus状態 ~SET `~focusを有するか？$( %作動中な文書 )
◎
Let focusState be the result of running the has focus steps with browsingContext’s active document.
</li>
			<li>
%先祖~生成元~list ~LET %作動中な文書 の`先祖~生成元~文字列~list$
◎
Let ancestorOriginsList be browsingContext’s active document’s relevant global object’s Location object’s ancestor origins list’s associated list.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
</p>
<div class="algo">
<p>
手続きは：
</p>
				<ol>
					<li>
%~window~client ~LET ~NULL
◎
↓</li>
					<li>
~IF［
%閲覧~文脈 にて`作動中な~window$bcに`関連な設定群~obj$【！`Window$I ~objの`環境~設定群~obj$】の`作成時の~URL$enVの`生成元$url
~EQ`生成元$sub
`~sw$SWGの`生成元$enV【？】
］
⇒
%~window~client ~SET `~window~clientを作成する$( ↓ )
⇒＃
コレの`~sw~client$cl,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
If browsingContext’s Window object’s environment settings object’s creation URL’s origin is not the same as the service worker’s origin, resolve promise with null and abort these steps.
◎
Let windowClient be the result of running Create Window Client with this’s service worker client, frameType, visibilityState, focusState, and ancestorOriginsList.
</li>
					<li>
`~promiseを解決する$( %~promise, %~window~client )
◎
Resolve promise with windowClient.
</li>
				</ol>
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="clients-interface">
<h3>4.3. `Clients^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `Clients@I {
  /* <span class="comment">
返される~objは、
毎回~新たな~instanceになる
◎
The objects returned will be new instances every time
</span> */
  [`NewObject$] `Promise$&lt;(`Client$I or `undefined$)&gt; `get$m(`DOMString$ %id);
  [`NewObject$] `Promise$&lt;`FrozenArray$&lt;`Client$I&gt;&gt; `matchAll$m(optional `ClientQueryOptions$I %options = {});
  [`NewObject$] `Promise$&lt;`WindowClient$I?&gt; `openWindow$m(`USVString$ %url);
  [`NewObject$] `Promise$&lt;`undefined$&gt; `claim$m();
};
</pre>

<pre class="idl" id="serviceworker-client-query-options-dictionary">
dictionary `ClientQueryOptions@I {
  `boolean$ `includeUncontrolled@m = false;
  `ClientType$I `type@m = "window";
};
</pre>

<pre class="idl" id="client-type-enum">
enum `ClientType@I {
  "`window@m",
  "`worker@m",
  "`sharedworker@m",
  "`all@m"
};
</pre>

<p id="_serviceworkerglobalscope-client">
~UAは，`ServiceWorkerGlobalScope$I ~obj %G の作成-時には、
`Clients$I ~obj %~client群 を作成して，
%G に %~client群 を結付けるモノトスル。
以下における %~client群 の
`~sw@cl
は、
%G の`~sw$SWGを指すとする。
【この用語`~sw$clは、以下の記述を明確化するために，この訳に導入している。】
◎
The user agent must create a Clients object when a ServiceWorkerGlobalScope object is created and associate it with that object.
</p>

`Clients^I0

			<section id="clients-get">
<h4>4.3.1. `get(id)^m</h4>

<p>
`get(id)@m
~method手続きは：
◎
The get(id) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%~sw ~LET コレの`~sw$cl
◎
↓</li>
			<li>
<p>
`~storage~keyが登録と同等な~client群$を成す
~EACH( %~client )
に対し：
◎
For each service worker client client where the result of running obtain a storage key given client equals the associated service worker’s containing service worker registration’s storage key:
</p>
				<ol>
					<li>
~IF［
%~client の`~ID$enV~NEQ %id
］
⇒
~CONTINUE
◎
If client’s id is not id, continue.
</li>
					<li>
次が満たされるまで待機する
⇒
［
%~client の`実行は準備済みか$enV ~EQ ~T
］~OR［
%~client の`破棄-済みか$ ~EQ ~T
］
◎
Wait for either client’s execution ready flag to be set or for client’s discarded flag to be set.
</li>
					<li>
~IF［
%~client の`実行は準備済みか$enV ~EQ ~T
］
⇒＃
`~clientを取得する~promiseを解決する$( %~client, %~promise )；
~RET
◎
If client’s execution ready flag is set, then invoke Resolve Get Client Promise with client and promise, and abort these steps.
</li>
				</ol>
			</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="clients-matchall">
<h4>4.3.2. `matchAll(options)^m</h4>

<p>
`matchAll(options)@m
~method手続きは：
◎
The matchAll(options) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~target~client群 ~LET 新たな`~list$
◎
Let targetClients be a new list.
</li>
			<li>
<p>
`~storage~keyが登録と同等な~client群$を成す
~EACH( %~client )
に対し：
◎
For each service worker client client where the result of running obtain a storage key given client equals the associated service worker’s containing service worker registration’s storage key:
</p>
				<ol>
					<li>
~IF［
%~client の`実行は準備済みか$enV ~EQ ~F
］~OR［
%~client の`破棄-済みか$ ~EQ ~T
］~OR［
%~client は`~secureな文脈$enVでない
］
⇒
~CONTINUE
◎
If client’s execution ready flag is unset or client’s discarded flag is set, continue.
◎
If client is not a secure context, continue.
</li>
					<li>
~IF［
%options[ "`ClientQueryOptions^I1`includeUncontrolled$m1" ] ~EQ ~T
］~OR［
%~client にて`作動中な~sw$enV ~EQ コレの`~sw$cl
］
⇒
%~target~client群 に %~client を追加する
◎
If options["includeUncontrolled"] is false, and if client’s active service worker is not the associated service worker, continue.
◎
Add client to targetClients.
</li>
				</ol>
			</li>
			<li>
%合致した~window~data ~LET 新たな`~list$
◎
Let matchedWindowData be a new list.
</li>
			<li>
%合致した~client群 ~LET 新たな`~list$
◎
Let matchedClients be a new list.
</li>
			<li>
<p>
%~target~client群 を成す
~EACH( `~sw~client$ %~client )
に対し：
◎
For each service worker client client in targetClients:
</p>
				<ol>
					<li>
<p>
~IF［
%options [ "`ClientQueryOptions^I1`type$m1" ] ~IN { `window$l, `all$l }
］~AND［［
%~client は`環境~設定群~obj$でない
］~OR［
%~client は`~window~client$である
］］：
◎
If options["type"] is "window" or "all", and client is not an environment settings object or is a window client, then:
</p>
						<ol>
							<li>
%~window~data ~LET «[ `client^l → client, `ancestorOriginsList^l → 新たな`~list$ ]»
◎
Let windowData be «[ "client" → client, "ancestorOriginsList" → a new list ]».
</li>
							<li>
%~clientは列挙-可能か ~LET ~T
◎
Let browsingContext be null.
◎
Let isClientEnumerable be true.
</li>
							<li>
%閲覧~文脈 ~LET［
%~client は`環境~設定群~obj$であるならば %~client の`大域~obj$enVに`対応する閲覧~文脈$【！`閲覧~文脈$】 ／
~ELSE_ %~client の`~target閲覧~文脈$enV
］
◎
If client is an environment settings object, set browsingContext to client’s global object’s browsing context.
◎
Else, set browsingContext to client’s target browsing context.
</li>
							<li>
<p>
%~task ~LET `~taskを~queueする$( `利用者ヤリトリ~task~source$, 次の手続き, %閲覧~文脈 の`~event~loop$ )
◎
Queue a task task to run the following substeps on browsingContext’s event loop using the user interaction task source:
</p>

<div class="algo">
<p>
手続きは：
</p>
								<ol>
									<li>
~IF［
%閲覧~文脈 は破棄された
【`参照＠~HTMLds#a-browsing-context-is-discarded$】
【！https://wicg.github.io/page-lifecycle/#discarded】
］
⇒＃
%~clientは列挙-可能か ~SET ~F；
~RET
◎
If browsingContext has been discarded, then set isClientEnumerable to false and abort these steps.
</li>
									<li>
%~navigable ~LET %閲覧~文脈 に`対応する~navigable$bc
◎
↓</li>
									<li>
%作動中な文書 ~LET %~navigable にて`作動中な文書$nav
◎
↓</li>
									<li>
~IF［
%~client は`~window~client$である
］~AND［
%~client 【の`大域~obj$enV】に`結付けられた文書$ ~NEQ %作動中な文書
］
⇒＃
%~clientは列挙-可能か ~SET ~F；
~RET
◎
If client is a window client and client’s associated document is not browsingContext’s active document, then set isClientEnumerable to false and abort these steps.
</li>
									<li>
%~window~data[ `frameType^l ] ~SET `~frame種別を取得する$( %~navigable )
◎
Set windowData["frameType"] to the result of running Get Frame Type with browsingContext.
</li>
									<li>
%~window~data[ `visibilityState^l ] ~SET %作動中な文書 の `visibilityState$n 属性~値
◎
Set windowData["visibilityState"] to browsingContext’s active document’s visibilityState attribute value.
</li>
									<li>
%~window~data[ `focusState^l ] ~SET `~focusを有するか？$( %作動中な文書 )
◎
Set windowData["focusState"] to the result of running the has focus steps with browsingContext’s active document as the argument.
</li>
									<li>
~IF［
%~client は`~window~client$である
］
⇒
%~window~data[ `ancestorOriginsList^l ] ~SET %作動中な文書 の`先祖~生成元~文字列~list$
◎
If client is a window client, then set windowData["ancestorOriginsList"] to browsingContext’s active document’s relevant global object’s Location object’s ancestor origins list’s associated list.
</li>
								</ol>
</div>
							</li>
							<li>
<p>
%~task が実行されるまで待機する
◎
Wait for task to have executed.
</p>

<p class="note">注記：
これは他を阻むように待機するが、
実装者は，状態が壊れない限り各 反復を並列的に走らせてもよい。
◎
Note: Wait is a blocking wait, but implementers may run the iterations in parallel as long as the state is not broken.
</p>
							</li>
							<li>
~IF［
%~clientは列挙-可能か ~EQ ~T
］
⇒
%合致した~window~data に %~window~data を追加する
◎
If isClientEnumerable is true, then:
• Add windowData to matchedWindowData.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
~OR↓
］…
</p>
						<ul>
							<li>
［
%~client は`専用~worker~client$である
］~AND［
%options[ `ClientQueryOptions^I1"`type$m1" ] ~IN { `worker$l, `all$l }
］
</li>
							<li>
［
%~client は`共用~worker~client$である
］~AND［
%options[ "`type$m1" ] ~IN { `sharedworker$l, `all$l }
］
</li>
						</ul>
<p>
…ならば
⇒
%合致した~client群 に次の結果を追加する
⇒
`~clientを作成する$( %~client )
</p>
◎
Else if options["type"] is "worker" or "all" and client is a dedicated worker client, or options["type"] is "sharedworker" or "all" and client is a shared worker client, then:
• Add client to matchedClients.
</li>
				</ol>
			</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task to run the following steps on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source:
</p>

<div class="algo">
<p>
手続きは：
</p>
				<ol>
					<li>
%~client~obj群 ~LET 新たな`~list$
◎
Let clientObjects be a new list.
</li>
					<li>
%合致した~window~data を成す
~EACH( %~window~data )
に対し
⇒
%~client~obj群 に次の結果を`付加する$
⇒
`~window~clientを作成する$( ↓ )
⇒＃
%~window~data[ `client^l ],
%~window~data[ `frameType^l ],
%~window~data[ `visibilityState^l ],
%~window~data[ `focusState^l ],
%~window~data[ `ancestorOriginsList^l ]
◎
For each windowData in matchedWindowData:
• Let windowClient be the result of running Create Window Client algorithm with windowData["client"], windowData["frameType"], windowData["visibilityState"], windowData["focusState"], and windowData["ancestorOriginsList"] as the arguments.
• Append windowClient to clientObjects.
</li>
					<li>
%合致した~client群 を成す
~EACH( %~client )
に対し
⇒
%~client~obj群 に次の結果を`付加する$
⇒
`~clientを作成する$( %~client )
◎
For each client in matchedClients:
• Let clientObject be the result of running Create Client algorithm with client as the argument.
• Append clientObject to clientObjects.
</li>
					<li>
<p>
%~client~obj群 を，次に与える順に~sortする：
◎
Sort clientObjects such that:
</p>
						<ol>
							<li>
<p>
`WindowClient$I ~objたちのうち，それまでにその`閲覧~文脈$clが`~focusされ$たものたち
— 最も近過去に`~focusされ$たものから順に。
◎
WindowClient objects whose browsing context has been focused are placed first, sorted in the most recently focused order.
</li>
							<li>
前項に該当しない `WindowClient$I ~objたち
— それぞれの`~sw~client$clの作成~順に。
◎
WindowClient objects whose browsing context has never been focused are placed next, sorted in their service worker client’s creation order.
</li>
							<li>
`Client$I ~objのうち，`~sw~client$clは`~worker~client$であるものたち
— それぞれの`~sw~client$clの作成~順に。
◎
Client objects whose associated service worker client is a worker client are placed next, sorted in their service worker client’s creation order.
</li>
						</ol>

<p class="note">注記：
`~window~client$ は、
常に`~worker~client$より先に来る。
◎
Note: Window clients are always placed before worker clients.
</p>

					</li>
					<li>
`~promiseを解決する$( %~promise, 次の結果 )
⇒
%~promise に`関連な~realm$内で`凍結d配列を作成する$( %合致した~client群 )
◎
Resolve promise with a new frozen array of clientObjects in promise’s relevant Realm.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="clients-openwindow">
<h4>4.3.3. `openWindow(url)^m</h4>

<p>
`openWindow(url)@m
~method手続きは：
◎
The openWindow(url) method steps are:
</p>
<ol>
	<li>
%~URL ~LET 
`~URL構文解析する$( %url, コレに`関連な設定群~obj$の`~API用~基底~URL$enV )
◎
Let url be the result of parsing url with this’s relevant settings object’s API base URL.
</li>
	<li>
~IF［
%~URL ~EQ `失敗^i
］~OR［
%~URL ~EQ `about:blank^c
］
⇒
~RET `却下される~promise$( `TypeError^E 例外 )
◎
If url is failure, return a promise rejected with a TypeError.
◎
If url is about:blank, return a promise rejected with a TypeError.
</li>
	<li>
~IF［
この`生成元$【コレの`~sw~client$clの`生成元$cl】に属する`~window$のうち，
`一過な作動化を有して$いるものは無い
］
⇒
~RET `却下される~promise$( `InvalidAccessError$E 例外 )
◎
If no Window in this origin has transient activation, return a promise rejected with an "InvalidAccessError" DOMException.
</li>
	<li>
%~sw~event~loop ~LET `現在の大域~obj$の`~event~loop$
◎
Let serviceWorkerEventLoop be the current global object’s event loop.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%新-文脈 ~LET 新たな`~top-level閲覧~文脈$
【( %新-文脈, — ) ~LET `新たな~top-level閲覧~文脈と文書を作成する$()】
◎
Let newContext be a new top-level browsing context.
</li>
			<li>
<p>
`~taskを~queueする$( `利用者ヤリトリ~task~source$, 次の手続き, %新-文脈 にて`作動中な~window$bcに`関連な設定群~obj$【！`Window$I ~objの`環境~設定群~obj$】の`担当の~event~loop$enV )
◎
Queue a task to run the following steps on newContext’s Window object’s environment settings object’s responsible event loop using the user interaction task source:
</p>

<div class="algo">
<p>
手続きは：
</p>
				<ol>
					<li>
%~navigable ~LET %新-文脈 に`対応する~navigable$bc
◎
↓</li>
					<li>
%作動中な文書 ~LET %~navigable にて`作動中な文書$nav
◎
↓</li>
					<li>
【！ HandleNavigate】
`~navigableを~URLへ~navigateする$( %~navigable, %~URL【, %作動中な文書？】 )
— 次も与える下で
⇒＃
`例外を可能化するか^i ~SET ~T,
`履歴~取扱い^i ~SET `replace$hH
◎
HandleNavigate: Navigate newContext to url with exceptionsEnabled true, and historyHandling "replace".
</li>
					<li>
<p>
~IF［
前~段にて例外 %e が投出された
］：
</p>
						<ol>
							<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, %e )
</div>
							</li>
							<li>
~RET
</li>
						</ol>
◎
If the algorithm steps invoked in the step labeled HandleNavigate throws an exception, queue a task to reject promise with the exception, on serviceWorkerEventLoop using the DOM manipulation task source, and abort these steps.
</li>
					<li>
%~frame種別 ~LET `~frame種別を取得する$( %~navigable )
◎
Let frameType be the result of running Get Frame Type with newContext.
</li>
					<li>
%可視性~状態 ~LET %作動中な文書 の `visibilityState$n 属性~値
◎
Let visibilityState be newContext’s active document’s visibilityState attribute value.
</li>
					<li>
%~focus状態 ~LET `~focusを有するか？$( %作動中な文書 )
◎
Let focusState be the result of running the has focus steps with newContext’s active document as the argument.
</li>
					<li>
%先祖~生成元~list ~LET %作動中な文書 の`先祖~生成元~文字列~list$
◎
Let ancestorOriginsList be newContext’s active document’s relevant global object’s Location object’s ancestor origins list’s associated list.
</li>
					<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
</p>
<div class="algo">
<p>
手続きは：
</p>
						<ol>
							<li>
%設定群 ~LET %新-文脈 にて`作動中な~window$bcに`関連な設定群~obj$【！`Window$I ~objの`環境~設定群~obj$】
</li>
							<li>
%~storage~key ~LET `~storage~keyを得する$( %設定群 )
</li>
							<li>
%~client ~LET ~NULL
</li>
							<li>
~IF［
%~storage~key,
コレの`~sw$clを`包含している~sw登録$swの`~storage~key$swr
］は`同等な~storage~key$である
］
⇒
%~client ~SET `~window~clientを作成する$( ↓ )
⇒＃
%設定群,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
</li>
							<li>
`~promiseを解決する$( %~promise, %~client )
</li>
						</ol>
</div>
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
• If the result of running obtain a storage key given newContext’s Window object’s environment settings object is not equal to the service worker’s containing service worker registration’s storage key, then resolve promise with null and abort these steps.
• Let client be the result of running Create Window Client with newContext’s Window object’s environment settings object, frameType, visibilityState, focusState, and ancestorOriginsList as the arguments.
• Resolve promise with client.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="clients-claim">
<h4>4.3.4. `claim()^m</h4>

<p>
`claim()@m
~method手続きは：
◎
The claim() method steps are:
</p>
<ol>
	<li>
%~sw ~LET コレの`~sw$cl
◎
↓</li>
	<li>
~IF［
%~sw は`作動中な~worker$swrでない
］
⇒
~RET `却下される~promise$( `InvalidStateError$E 例外 )
◎
If the service worker is not an active worker, return a promise rejected with an "InvalidStateError" DOMException.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
<p>
`~storage~keyが登録と同等な~client群$を成す
~EACH( %~client )
に対し：
◎
For each service worker client client where the result of running obtain a storage key given client equals the service worker’s containing service worker registration’s storage key:
</p>
				<ol>
					<li>
~IF［
%~client の`実行は準備済みか$enV ~EQ ~F
］~OR［
%~client の`破棄-済みか$ ~EQ ~T
］~OR［
%~client は`~secureな文脈$enVでない
］
⇒
~CONTINUE
◎
If client’s execution ready flag is unset or client’s discarded flag is set, continue.
◎
If client is not a secure context, continue.
</li>
					<li>
%~storage~key ~LET `~storage~keyを得する$( %~client )
◎
Let storage key be the result of running obtain a storage key given client.
</li>
					<li>
%登録 ~LET `合致する~sw登録$( %~storage~key, %~client の`作成時の~URL$enV )
◎
Let registration be the result of running Match Service Worker Registration given storage key and client’s creation URL.
</li>
					<li>
<p>
~IF［
%登録 ~NEQ %~sw を`包含している~sw登録$sw
］
⇒
~CONTINUE
◎
If registration is not the service worker’s containing service worker registration, continue.
</p>

<p class="note">注記：
%登録 は、
この`~sw$SWGを`包含している~sw登録$swが`未登録にされて$いる場合には， ~NULL になる。
◎
Note: registration will be null if the service worker’s containing service worker registration is unregistered.
</p>
					</li>
					<li>
~IF［
%~client にて`作動中な~sw$enV ~EQ %~sw
］
⇒
~CONTINUE
◎
If client’s active service worker is not the service worker, then:
</li>
					<li>
`~sw~clientを~unloadする$( %~client )
◎
Invoke Handle Service Worker Client Unload with client as the argument.
</li>
					<li>
%~client にて`作動中な~sw$enV ~SET %~sw
◎
Set client’s active service worker to service worker.
</li>
					<li>
`制御器の変化を通知する$( %~client )
◎
Invoke Notify Controller Change algorithm with client as the argument.
</li>
				</ol>
			</li>
			<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="extendableevent-interface">
<h3>4.4. `ExtendableEvent^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `ExtendableEvent@I : `Event$I {
  `constructor@mc(`DOMString$ %type, optional `ExtendableEventInit$I %eventInitDict = {});
  `undefined$ `waitUntil$m(`Promise$&lt;`any$&gt; %f);
};
</pre>

<pre class="idl" id="extendable-event-init-dictionary">
dictionary `ExtendableEventInit@I : `EventInit$I {
  /* <span class="comment">
`ExtendableEvent^I から派生する~eventを前方-互換にするために定義される
◎
Defined for the forward compatibility across the derived events
</span> */
};
</pre>

<p>
各 `ExtendableEvent$I0 ~objには、
以下に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`存続期間を延長する~promise群@</dt>
	<dd>
`~promise$たちが成す配列。【！＊】
◎
An ExtendableEvent object has an associated extend lifetime promises (an array of promises).＼
</dd>
	<dd>
初期~時は空~配列とする。
◎
It is initially an empty array.
</dd>

	<dt>`処理待ち~promise数@</dt>
	<dd>
`存続期間を延長する~promise群$内の処理待ち~promiseの個数を表す整数。
【実際の個数と正確には同期しないため、この定義が必要yである。】
◎
An ExtendableEvent object has an associated pending promises count (the number of pending promises in the extend lifetime promises).＼
</dd>
	<dd>
初期~時は 0 とする。
◎
It is initially set to zero.
</dd>

	<dt>`時間切れか@</dt>
	<dd>
ある真偽値
— 初期~時は ~F とする。
［
`処理待ち~promise数$ ~GT 0
］の場合に，~UAが任意選択で課す遅延~後に ~T にされる。
◎
An ExtendableEvent object has an associated timed out flag. It is initially unset, and is set after an optional user agent imposed delay if the pending promises count is greater than zero.
</dd>
</dl>

<p>
`ExtendableEvent$I ~objは、
次を満たしている間は
`作動中@eX
であるとされる
⇒
［
`時間切れか$ ~EQ ~F
］~AND［［
`処理待ち~promise数$ ~GT 0
］~OR［
`配送-中か$ev ~EQ ~T
］］
◎
An ExtendableEvent object is said to be active when its timed out flag is unset and either its pending promises count is greater than zero or its dispatch flag is set.
</p>

<p>
`~sw$には、
2 種の`~lifecycle~event$
— `install$et, `activate$et —
がある。
`~sw$は、
これらの~event用に `ExtendableEvent$I ~interfaceを利用する。
◎
Service workers have two lifecycle events, install and activate. Service workers use the ExtendableEvent interface for activate event and install event.
</p>

<p>
`~event~handlerを定義-$する`拡張$も、
`ExtendableEvent$I ~interfaceを利用したり拡張してもヨイ。
◎
Service worker extensions that define event handlers may also use or extend the ExtendableEvent interface.
</p>

			<section id="wait-until-method">
<h4 title="event.waitUntil(f)">4.4.1. `waitUntil(f)^m</h4>

<p class="note">注記：
この~methodは、
~eventの存続期間を延長する。
◎
Note: waitUntil() method extends the lifetime of the event.
</p>

<p>
`waitUntil(f)@m
~method手続きは
⇒
`存続期間~promiseを追加する$( %f, コレ )
◎
The waitUntil(f) method steps are to add lifetime promise f to this.
</p>

<div class="algo">
<p>
`存続期間~promiseを追加する@
~algoは、
所与の
( `~promise$ %~promise, `ExtendableEvent$I %~event )
に対し：
◎
To add lifetime promise promise (a promise) to event (an ExtendableEvent), run these steps:
</p>
<ol>
	<li>
~IF［
%~event の `isTrusted$n ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If event’s isTrusted attribute is false, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
%~event は`作動中$eXでない
］
⇒
~THROW `InvalidStateError$E
◎
If event is not active, throw an "InvalidStateError" DOMException.
</p>

<p class="note">注記：
~event~handlerを~callした~task内で存続期間を延長~promiseが追加されなかった場合、
後続な非同期的な~task内で `waitUntil()$m を~callすると，投出することになる。
◎
Note: If no lifetime extension promise has been added in the task that called the event handlers, calling waitUntil() in subsequent asynchronous tasks will throw.
</p>
	</li>
	<li>
%~event の`存続期間を延長する~promise群$に
%~promise を追加する
◎
Add promise to event’s extend lifetime promises.
</li>
	<li>
<p>
%~event の`処理待ち~promise数$ ~INCBY 1
◎
Increment event’s pending promises count by one.
</p>

<p class="note">注記：
所与の~promiseがすでに決着していた場合でも、
`処理待ち~promise数$は増分される。
対応する減分は、
その~promiseに対する反応（次の段）により~queueされる小task内で行われる。
◎
Note: The pending promises count is incremented even if the given promise has already been settled. The corresponding count decrement is done in the microtask queued by the reaction to the promise.
</p>
	</li>
	<li class="algo">
<p>
%~promise の［
`充足-時$／`却下-時$
］には
⇒
`小taskを~queueする$( 次の手続き ) ：
◎
Upon fulfillment or rejection of promise, queue a microtask to run＼
</p>
<div class="algo">
<p>
手続きは：
◎
these substeps:
</p>
		<ol>
			<li>
%~event の`処理待ち~promise数$ ~DECBY 1
◎
Decrement event’s pending promises count by one.
</li>
			<li>
~IF［
%~event の`処理待ち~promise数$ ~EQ 0
］
⇒
~RET
◎
If event’s pending promises count is 0, then:
</li>
			<li>
%登録 ~LET `現在の大域~obj$の`~sw$SWGを`包含している~sw登録$sw
◎
Let registration be the current global object’s associated service worker’s containing service worker registration.
</li>
			<li>
~IF［
%登録 は`未登録にされて$いる
］
⇒
`登録を~clearするよう試行する$( %登録 )
◎
If registration is unregistered, invoke Try Clear Registration with registration.
</li>
			<li>
~IF［
%登録 ~NEQ ~NULL
］
⇒
`作動化するよう試行する$( %登録 )
◎
If registration is not null, invoke Try Activate with registration.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<p>
~UAは、
所与の`~sw$ %~sw に対し，［
`~swには処理待ち~eventは無いか？$( %~sw ) が ~F を返す間
］は %~sw を`終了-$するベキでない。
◎
The user agent should not terminate a service worker if Service Worker Has No Pending Events returns false for that service worker.
</p>

<div class="p">
<p>
`~event~handlerを定義-$する［
`~sw$／ `拡張$
］は、
次に挙げるような自前の挙動を定義してもヨイ：
</p>
<ul>
	<li>
`存続期間を延長する~promise群$を許容することにより，演算の長さを示唆する。
</li>
	<li>
`存続期間を延長する~promise群$内の`~promise$に却下された状態を許容することにより，演算の失敗を示唆する。
</li>
</ul>
◎
Service workers and extensions that define event handlers may define their own behaviors, allowing the extend lifetime promises to suggest operation length, and the rejected state of any of the promise in extend lifetime promises to suggest operation failure.
</div>

<p class="note">注記：
`~sw$は、
`install$et ~eventの`存続期間を延長する~promise群$内のすべての`~promise$が成功裡に解決されるまで，`~install中の~worker$swrが `installed^l として扱われるのを遅延する
（`~installする~algoの関連な段＠#install-settle-step$を見よ）。
いずれかの~promiseが却下された場合、
その~installationは失敗する。
これは首に、
`~sw$が依存する中核~cacheを成すすべてが拡充されるまで，
`installed^l （すなわち， `待機-中な~worker$swrである）
と見なされないことを確保するために利用される。
同様に，`~sw$は、
`activate$et ~event内の`存続期間を延長する~promise群$内のすべての`~promise$が決着されるまで，`作動中な~worker$swr が
`activated^l として扱われるのを遅延する
（`作動化する~algoの関連な段＠#activate-settle-step$を見よ。）
これは首に、
`~sw$が［
~database~schemaを昇格して，期限切れの~cache~entryを削除する
］までは，［
`~sw$を表現する `ServiceWorkerGlobalScope$I ~objに向けて`機能的~event$は配送されない
］ことを確保するために利用される。
◎
Note: Service workers delay treating the installing worker as "installed" until all the promises in the install event’s extend lifetime promises resolve successfully. (See the relevant Install algorithm step.) If any of the promises rejects, the installation fails. This is primarily used to ensure that a service worker is not considered "installed" until all of the core caches it depends on are populated. Likewise, service workers delay treating the active worker as "activated" until all the promises in the activate event’s extend lifetime promises settle. (See the relevant Activate algorithm step.) This is primarily used to ensure that any functional events are not dispatched to the service worker until it upgrades database schemas and deletes the outdated cache entries.
</p>

			</section>
		</section>
		<section id="installevent-interface">
<h3 title="InstallEvent">4.5. `InstallEvent^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `InstallEvent@I : `ExtendableEvent$I {
  `constructor@mc(`DOMString$ %type, optional `ExtendableEventInit$I %eventInitDict = {});
  `Promise$&lt;`undefined$&gt; `addRoutes$m((`RouterRule$I or `sequence$&lt;`RouterRule$I&gt;) %rules);
};

dictionary `RouterRule@I {
  required `RouterCondition$I `condition@m;
  required `RouterSource$I `source@m;
};

dictionary `RouterCondition@I {
  `URLPatternCompatible$I `urlPattern@m;
  `ByteString$ `requestMethod@m;
  `RequestMode$I `requestMode@m;
  `RequestDestination$I `requestDestination@m;
  `RunningStatus$I `runningStatus@m;

  `sequence$&lt;`RouterCondition$I&gt; _`or@m;
  `RouterCondition$I `not@m;
};

typedef (`RouterSourceDict$I or `RouterSourceEnum$I) `RouterSource@I;

dictionary `RouterSourceDict@I {
  `DOMString$ `cacheName@m;
};

enum `RunningStatus@I {
  "`running@m",
  "`not-running@m"
};
enum `RouterSourceEnum@I {
  "`cache@m",
  "`fetch-event@m",
  "`network@m",
  "`race-network-and-fetch-handler@m"
};
</pre>

<p>
`~router条件を数えた結果@
は、
次に挙げる~itemからなる`構造体$である：
◎
A count router condition result is a struct that consists of:
</p>
<ul>
	<li>
`条件~計数@rcR
⇒
~number
◎
A condition count (a number).
</li>
	<li>
`~quotaを超過したか@rcR
⇒
真偽値
◎
A quota exceeded (a boolean).
</li>
</ul>

`InstallEvent^I0

			<section id="register-router-method">
<h4 title="event.addRoutes(rules)">4.5.1. `addRoutes(rules)^m</h4>

<p class="note">注記：
この~methodは、［
普通は~fetch~event~handlerが行う単純な~task
］を当の~sw用に負荷分散するための規則~群を登録する。
◎
Note: addRoutes(rules) registers rules for this service worker to offload simple tasks that the fetch event handler ordinarily does.
</p>

<div class="algo">
<p>
`addRoutes(rules)@m
~method手続きは：
◎
The addRoutes(rules) method steps are:
</p>
<ol>
	<li>
~IF［
%rules は `RouterRule$I 辞書である
］
⇒
%rules ~SET « %rules »
◎
If rules is a RouterRule dictionary, set rules to « rules ».
</li>
	<li>
%~sw ~LET `現在の大域~obj$の`~sw$SWG
◎
Let serviceWorker be the current global object’s associated service worker.
</li>
	<li>
<p>
%rules を成す
~EACH( %規則 )
に対し：
`RouterRule^I1
◎
For each rule of rules:
</p>
		<ol>
			<li>
~IF［
`~router条件を検証yする$( %規則[ "`condition$m1" ], %~sw ) ~EQ ~F
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If running the Verify Router Condition algorithm with rule["condition"] and serviceWorker returns false, return a promise rejected with a TypeError.
</li>
			<li>
~IF［
%規則 [ "`source$m1" ] ~IN { `fetch-event$l, `race-network-and-fetch-handler$l }
］~AND［
`fetch$et ~NIN %~sw の`取扱う~event型の集合$sw
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If rule["source"] is either of "fetch-event" or "race-network-and-fetch-handler", and serviceWorker’s set of event types to handle does not contain fetch, return a promise rejected with a TypeError.
</li>
		</ol>
	</li>
	<li>
%存続期間~promise ~LET `新たな~promise$
◎
Let lifetimePromise be a new promise.
</li>
	<li>
<p>
`存続期間~promiseを追加する$( %存続期間~promise, コレ )
◎
Add lifetime promise lifetimePromise to this.
</p>

<p class="note">注記：
この~methodは、
既定では，当の~eventの存続期間を延長する
— コレに対し `ExtendableEvent^I0`waitUntil(promise)$m が~callされたかのように。
◎
Note: event.addRoutes(rules) extends the lifetime of the event by default as if event.waitUntil(promise) is called.
</p>
	</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<div class="algo">
%~promise の［
`充足-時$／`却下-時$
］には
⇒
`~promiseを解決する$( %存続期間~promise )
◎
Upon fulfillment or rejection of promise, resolve lifetimePromise with undefined.
</div>

<p class="note">注記：
~install~eventの失敗を避けるため、
この段は， %存続期間~promise が常に充足されるようにする。
◎
Note: this step is for making lifetimePromise always fullfilled to avoid the install event failure.
</p>
	</li>
	<li>
<p>
%~sw の`手続き~queue$swに次の`手続きを~enqueueする$【！~INFRA#queue-enqueue】：
◎
Enqueue the following steps to [[service worker queue]]:
</p>
<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%~router規則~群 ~LET %~sw の`~router規則~list$swを`~cloneする$【！の複製】
◎
Let allRules be a copy of serviceWorker’s list of router rules.
</li>
			<li>
%~router規則~群 を %rules で`拡張する$
◎
For each rule of rules:
• Append rule to allRules.
</li>
			<li>
~IF［
`~router登録~上限を検査する$( %~router規則~群 ) ~EQ ~F
］
⇒
`~promiseを却下する$( %~promise, `TypeError$E )
◎
If running the Check Router Registration Limit with allRules returns false, reject promise with a TypeError.
</li>
			<li>
%~sw の`~router規則~list$sw ~SET %~router規則~群
◎
Set serviceWorker’s list of router rules to allRules.
</li>
			<li>
%~sw~event~loop ~LET `現在の大域~obj$の`~event~loop$
◎
Let serviceWorkerEventLoop be the current global object’s event loop.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~sw~event~loop )
◎
Queue a task to run the following steps on serviceWorkerEventLoop using the DOM manipulation task source:
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="fetchevent-interface">
<h3>4.6. `FetchEvent^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `FetchEvent@I : `ExtendableEvent$I {
  `constructor@mc(`DOMString$ %type, `FetchEventInit$I %eventInitDict);
  [`SameObject$] readonly attribute `Request$I `request$m;
  readonly attribute `Promise$&lt;`any$&gt; `preloadResponse$m;
  readonly attribute `DOMString$ `clientId$m;
  readonly attribute `DOMString$ `resultingClientId$m;
  readonly attribute `DOMString$ `replacesClientId$m;
  readonly attribute `Promise$&lt;`undefined$&gt; `handled$m;

  `undefined$ `respondWith$m(`Promise$&lt;`Response$I&gt; %r);
};
</pre>

<pre class="idl" id="fetch-event-init-dictionary">
dictionary `FetchEventInit@I : `ExtendableEventInit$I {
  required `Request$I `request@m;
  `Promise$&lt;`any$&gt; `preloadResponse@m;
  `DOMString$ `clientId@m = "";
  `DOMString$ `resultingClientId@m = "";
  `DOMString$ `replacesClientId@m = "";
  `Promise$&lt;`undefined$&gt; `handled@m;
};
</pre>

<p>
`~sw$に~~不可欠な`機能的~event$には、
`fetch$et ~eventがある。
`~sw$は、
`FetchEvent$I ~interfaceを `fetch$et ~eventに利用する
— それは、
`ExtendableEvent$I ~interfaceを拡張する。
◎
Service workers have an essential functional event fetch. For fetch event, service workers use the FetchEvent interface which extends the ExtendableEvent interface.
</p>

<div >
<p>
`FetchEvent$I ~interfaceを利用する各~eventには、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`応答になり得る@FE
⇒
`応答$／ ~NULL
— 初期~時は ~NULL とする。
</li>
	<li>
`応答するまで待機-中か@FE
⇒
真偽値
— 初期~時は ~F とする。
</li>
	<li>
`~enteredで応答するか@FE
⇒
真偽値
— 初期~時は ~F とする。
</li>
	<li>
`~errorで応答するか@FE
⇒
真偽値
— 初期~時は ~F とする。
</li>
</ul>
◎
Each event using FetchEvent interface has an associated potential response (a response), initially set to null,＼
and the following associated flags that are initially unset:
• wait to respond flag
• respond-with entered flag
• respond-with error flag
</div>

`FetchEvent^I0

			<section id="fetch-event-request">
<h4 title="event.request">4.6.1. `request^m</h4>

<p>
`request@m
取得子~手続きは、
初期化-時の値を返す。
◎
request attribute must return the value it was initialized to.
</p>

			</section>
			<section id="fetch-event-preloadresponse">
<h4 title="event.preloadResponse">4.6.2. `preloadResponse^m</h4>

<p>
`preloadResponse@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は、
`解決される~promise$( `undefined^jv )
に初期化するモノトスル。
◎
preloadResponse attribute must return the value it was initialized to. When an event is created the attribute must be initialized to a promise resolved with undefined.
</p>

			</section>
			<section id="fetch-event-clientid">
<h4 title="event.clientId">4.6.3. `clientId^m</h4>

<p>
`clientId@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は
空~文字列に初期化するモノトスル。
◎
clientId attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

			</section>
			<section id="fetch-event-resultingclientid">
<h4 title="event.resultingClientId">4.6.4. `resultingClientId^m</h4>

<p>
`resultingClientId@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は
空~文字列に初期化するモノトスル。
◎
resultingClientId attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

			</section>
			<section id="fetch-event-replacesClientId">
<h4 title="event.replacesClientId">4.6.5. `replacesClientId^m</h4>

<p>
`replacesClientId@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は
空~文字列に初期化するモノトスル。
◎
replacesClientId attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</p>

			</section>
			<section id="fetch-event-handled">
<h4 title="event.handled">4.6.6. `handled^m</h4>

<p>
`handled@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は
処理待ち`~promise$【すなわち、`新たな~promise$】に初期化するモノトスル。
【`~fetchが取扱われた＠#handle-fetch$とき，解決される。】
◎
handled attribute must return the value it was initialized to. When an event is created the attribute must be initialized to a pending promise.
</p>

			</section>
			<section id="fetch-event-respondwith">
<h4 title="event.respondWith(r)">4.6.7. `respondWith(r)^m</h4>

<p class="note">注記：
開発者は、
引数 %r を［
`Response$I ~objで解決される`~promise$ ／ `Response$I ~obj
］に設定できる
（後者は自動的に~promiseに~castされる
【`~promiseとして解決される＠~PROMISES#resolve-arguments$】
）。
他の場合、
`~fetch$に対し`~network~error$が返される。
［
非同一-生成元に属する内容に対する，具現化器 側における~tainting
］についての~security検査は、
`~fetch$に定義される`絞込み応答$の種別に束ねられる。
◎
Note: Developers can set the argument r with either a promise that resolves with a Response object or a Response object (which is automatically cast to a promise). Otherwise, a network error is returned to Fetch. Renderer-side security checks about tainting for cross-origin content are tied to the types of filtered responses defined in Fetch.
</p>

<p>
`respondWith(r)@m
~method手続きは：
◎
respondWith(r) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~F
］~OR［
コレの`~enteredで応答するか$FE ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
Let event be this.
◎
If event’s dispatch flag is unset, throw an "InvalidStateError" DOMException.
◎
If event’s respond-with entered flag is set, throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
`存続期間~promiseを追加する$( %r, コレ )
◎
Add lifetime promise r to event.
</p>

<p class="note">注記：
コレ . `respondWith(r)$m
は、
既定でコレの存続期間を延長する
— コレ . `waitUntil(r)$n が~callされたかのように。
◎
Note: event.respondWith(r) extends the lifetime of the event by default as if event.waitUntil(r) is called.
</p>
	</li>
	<li>
コレの
⇒＃
`伝播を停止するか$ev ~SET ~T,
`伝播を即時に停止するか$ev ~SET ~T,
`~enteredで応答するか$FE ~SET ~T,
`応答するまで待機-中か$FE ~SET ~T
◎
Set event’s stop propagation flag and stop immediate propagation flag.
◎
Set event’s respond-with entered flag.
◎
Set event’s wait to respond flag.
</li>
	<li>
%~target~realm ~LET コレに`関連な~realm$
◎
Let targetRealm be event’s relevant Realm.
</li>
	<li>
【~RET （以下は、 %r が決着したときの挙動を与える）】
</li>
	<li class="algo">
<p>
%r の`却下-時$には：
◎
Upon rejection of r:
</p>
		<ol>
			<li>
コレの`~errorで応答するか$FE ~SET ~T
◎
Set event’s respond-with error flag.
</li>
			<li>
コレの`応答するまで待機-中か$FE ~SET ~F
◎
Unset event’s wait to respond flag.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%r の`充足-時$には、
所与の
( %応答 )
に対し：
◎
Upon fulfillment of r with response:
</p>
		<ol>
			<li>
<p>
~IF［
%応答 は `Response$I ~objでない
］
⇒
コレの`~errorで応答するか$FE ~SET ~T
◎
If response is not a Response object, then set the respond-with error flag.
</p>

<p class="note">注記：
`~fetch$に対しては、
`~errorで応答するか$FEに応じて［
~T ならば`~network~error$ ／
~F ならば %応答
］が，`~fetchを取扱う$~algoを通して返される。
【！＊step 22.1 】
◎
Note: If the respond-with error flag is set, a network error is returned to Fetch through Handle Fetch algorithm. (See the step 21.1.) Otherwise, the value response is returned to Fetch through Handle Fetch algorithm. (See the step 22.1.)
</p>
			</li>
			<li>
<p>
~ELSE：
◎
Else:
</p>
				<ol>
					<li>
%~byte列 ~LET 空な~byte列
◎
Let bytes be an empty byte sequence.
</li>
					<li>
%本体終端か ~LET ~F
◎
Let end-of-body be false.
◎
Let done be false.
</li>
					<li>
%応答になり得る ~LET %応答 に結付けられた`応答$Rsの複製
— ただし、
`本体$rsは複製しない
◎
Let potentialResponse be a copy of response’s associated response, except for its body.
</li>
					<li>
<p>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］：
◎
If response’s body is non-null, run these substeps:
</p>
						<ol>
							<li>
%読取器 ~LET %応答 の`本体$rsの`~stream$から`読取器を取得する$RS()
◎
Let reader be the result of getting a reader from response’s body’s stream.
</li>
							<li class="algo">
<p>
%~pull~algo ~LET 次の手続きを走らす動作：
◎
Let pullAlgorithm be an action that runs these steps:
</p>
								<ol>
									<li>
<p>
%読取n要請 ~LET 次に挙げる`~item$sctを伴う，`読取n要請$：
◎
Let readRequest be a new read request with the following items:
</p>
										<ul>
											<li>
<p>
`~chunk手続き$rRは、
所与の
( %~chunk )
に対し：
◎
chunk steps, given chunk
</p>
												<ol>
													<li>
~Assert：
%~chunk は `Uint8Array$I である。
◎
Assert: chunk is a Uint8Array.
</li>
													<li>
%~byte列 に［
%~chunk が表現している~byte列
］を付加する
◎
Append the bytes represented by chunk to bytes.
</li>
													<li>
%応答になり得る の`本体~報$rsの`符号化された~size$fT ~INCBY %~byte列 の`長さ$byte【！~WEBIDL#buffersource-byte-length】
◎
Increment potentialResponse’s body info’s encoded size by bytes’s byte length.
</li>
													<li>
%応答になり得る の`本体~報$rsの`復号した~size$fT ~INCBY %~byte列 の`長さ$byte【！~WEBIDL#buffersource-byte-length】
◎
Increment potentialResponse’s body info’s decoded size by bytes’s byte length.
</li>
													<li>
~NOABRUPT `DetachArrayBuffer$jA( %~chunk.`ViewedArrayBuffer^sl )
◎
Perform ! DetachArrayBuffer(chunk.[[ViewedArrayBuffer]]).
</li>
												</ol>
											</li>
											<li>
`~close手続き$rRは
⇒
%本体終端か ~SET ~T
◎
close steps
• Set end-of-body to true.
</li>
											<li>
`~error手続き$rRは、
所与の
( %~error )
に対し
⇒
%新-~stream を`~errorにする$RS( `TypeError$E )
◎
error steps
• error newStream with a TypeError.
</li>
										</ul>
									</li>
									<li>
%読取器 から`~chunkを読取る$RSR( %読取n要請 )
◎
Read a chunk from reader given readRequest.
</li>
								</ol>
							</li>
							<li class="algo">
%取消~algo ~LET 次を走らす動作
⇒
%読取器 を`取消す$RSR
◎
Let cancelAlgorithm be an action that cancels reader.
</li>
							<li>
%限界水位 ~LET ~UAが選ぶ［
有限かつ負でない~number, または `Infinity^jv
］
◎
Let highWaterMark be a non-negative, non-NaN number, chosen by the user agent.
</li>
							<li>
%~size~algo ~LET `~chunk$~objを受容し，~UAが選ぶ［
有限かつ負でない~number
］を返す~algo
◎
Let sizeAlgorithm be an algorithm that accepts a chunk object and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
</li>
							<li>
%新-~stream ~LET `新たな~obj$( `ReadableStream$I, %~target~realm )
◎
Let newStream be a new ReadableStream,＼
</li>
							<li>
%新-~stream を`設定しておく$RS
— 次を与える下で
⇒＃
`~pull~algo^i ~SET %~pull~algo,
`取消~algo^i ~SET %取消~algo,
`限界水位^i ~SET %限界水位,
`~size~algo^i ~SET %~size~algo
◎
set up with the pullAlgorithm pullAlgorithm, the cancelAlgorithm cancelAlgorithm, the highWaterMark highWaterMark, and sizeAlgorithm sizeAlgorithm, in targetRealm.
</li>
							<li>
%応答になり得る の`本体$rs ~SET 新たな`本体$
— その
⇒
`~stream$ ~SET %新-~stream
◎
Set potentialResponse’s body to a new body whose stream is newStream.
</li>
							<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these subsubsteps repeatedly in parallel＼
</p>

<p>
~WHILE 無条件：
◎
while done is false:
</p>
								<ol>
									<li>
~IF［
%新-~stream は`~errorした$RS
］
⇒
~BREAK
◎
If newStream is errored, then set done to true.
</li>
									<li>
次が満たされるまで待機する
⇒
［
%~byte列 は空でない
］~OR［
%本体終端か ~EQ ~F
］
◎
↓</li>
									<li>
~IF［
%~byte列 は空である（ %本体終端か ~EQ ~T ）
］
⇒＃
%新-~stream を`~closeする$RS()；
~BREAK
◎
Otherwise, if bytes is empty and end-of-body is true, then close newStream and set done to true.
◎
Otherwise, if bytes is not empty, run these subsubsubsteps:
</li>
									<li>
%~chunk ~LET %~byte列 の頭部を成す~byte列
【どこまでかは述べられていない（単に~UAに委ねられる？ %限界水位 ／ %~size~algo の結果に基づく？）】
◎
Let chunk be a subsequence of bytes starting from the beginning of bytes.
</li>
									<li>
%~chunk を %~byte列 から除去する
◎
Remove chunk from bytes.
</li>
									<li>
%~buffer ~LET `~buffer~sourceを作成する$( `Uint8Array$I, %~chunk, %~target~realm )
◎
Let buffer be an ArrayBuffer object created in targetRealm and containing chunk.
</li>
									<li>
%新-~stream に`~chunkを~enqueueする$RS( %~buffer )
◎
Enqueue a Uint8Array object created in targetRealm and wrapping buffer to newStream.
</li>
								</ol>

<p class="note">注記：
この段は、［
%応答 の`本体$rsの`~stream$を %応答になり得る の中へ “~pipeすること”
］の，観測-可能な等価を生産することが意味されている。
◎
Note: These substeps are meant to produce the observable equivalent of "piping" response’s body’s stream into potentialResponse.
</p>

<p class="note">注記：
~swにより~chunk内に書込まれる~dataを受取る~clientが，元と一致する~chunkを読取ることは保証されない。
すなわち、
~clientは書込まれたものと同じ~dataを読取ることになるが、
どう~chunk化されるかは，~browserに応じて異なり得る。
◎
Note: The data written by the service worker in chunks are not guaranteed to read in identical chunks by the client that receives the data. That is, the client will read the same data that was written, but it may be chunked differently by the browser.
</p>
							</li>
						</ol>
					</li>
					<li>
~IF［
%応答になり得る ~NEQ `~error^i
］
⇒
コレの`応答になり得る$FE ~SET %応答になり得る
◎
Set event’s potential response to potentialResponse.
</li>
				</ol>
			</li>
			<li>
コレの`応答するまで待機-中か$FE ~SET ~F
◎
Unset event’s wait to respond flag.
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="extendablemessageevent-interface">
<h3>4.7. `ExtendableMessageEvent^I</h3>

<pre class="idl">
[`Exposed$=ServiceWorker]
interface `ExtendableMessageEvent@I : `ExtendableEvent$I {
  `constructor@mc(`DOMString$ %type, optional `ExtendableMessageEventInit$I %eventInitDict = {});
  readonly attribute `any$ `data$m;
  readonly attribute `USVString$ `origin$m;
  readonly attribute `DOMString$ `lastEventId$m;
  [`SameObject$] readonly attribute (`Client$I or `ServiceWorker$I or `MessagePort$I)? `source$m;
  readonly attribute `FrozenArray$&lt;`MessagePort$I&gt; `ports$m;
};
</pre>

<pre class="idl" id="extendablemessage-event-init-dictionary">
dictionary `ExtendableMessageEventInit@I : `ExtendableEventInit$I {
  `any$ `data@m = null;
  `USVString$ `origin@m = "";
  `DOMString$ `lastEventId@m = "";
  (`Client$I or `ServiceWorker$I or `MessagePort$I)? `source@m = null;
  `sequence$&lt;`MessagePort$I&gt; `ports@m = [];
};
</pre>

<p>
`~sw$は、
`拡張-可能＠#dom-extendableevent-waituntil$な
`message$et ~eventを定義して，
~eventの存続期間を延長するのを許容する。
`~sw$は、
`message$et ~event用に
`ExtendableMessageEvent$I ~interfaceを利用する
— それは `ExtendableEvent$I ~interfaceを拡張する。
◎
Service workers define the extendable message event to allow extending the lifetime of the event. For the message event, service workers use the ExtendableMessageEvent interface which extends the ExtendableEvent interface.
</p>

`ExtendableMessageEvent^I0

			<section id="extendablemessage-event-data">
<h4 title="event.data">4.7.1. `data^m</h4>

<p>
`data@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は ~NULL に初期化するモノトスル。
それは、
送信されている~messageを表現する。
◎
The data attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to null. It represents the message being sent.
</p>

			</section>
			<section id="extendablemessage-event-origin">
<h4 title="event.origin">4.7.2. `origin^m</h4>

<p>
`origin@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は，空~文字列に初期化するモノトスル。
それは、
~messageを送信した`~sw~client$の`生成元$enVを表現する。
◎
The origin attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to the empty string. It represents the origin of the service worker client that sent the message.
</p>

			</section>
			<section id="extendablemessage-event-lasteventid">
<h4 title="event.lastEventId">4.7.3. `lastEventId^m</h4>

<p>
`lastEventId@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は，空~文字列に初期化するモノトスル。
◎
The lastEventId attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to the empty string.
</p>

			</section>
			<section id="extendablemessage-event-source">
<h4 title="event.source">4.7.4. `source^m</h4>

<p>
`source@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は， ~NULL に初期化するモノトスル。
それは、
~messageの送信-元 `Client$I ~objを表現する。
◎
The source attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to null. It represents the Client object from which the message is sent.
</p>

			</section>
			<section id="extendablemessage-event-ports">
<h4 title="event.ports">4.7.5. `ports^m</h4>

<p>
`ports@m
取得子~手続きは、
初期化-時の値を返す。
コレの作成-時には、
この属性は，空~配列に初期化するモノトスル。
それは、
送信されている `MessagePort$I 配列を表現する。
◎
The ports attribute must return the value it was initialized to. When the object is created, this attribute must be initialized to the empty array. It represents the MessagePort array being sent.
</p>

			</section>
		</section>
		<section id="execution-context-events">
<h3 title="Events">4.8. ~event</h3>

<p>
以下に挙げる~eventは、
`~sw~event$と呼ばれ，
`ServiceWorkerGlobalScope$I ~objに向けて配送される
— 以下に現れる %~sw は、
~objの`~sw$SWGを表すとする：
◎
The following events, called service worker events, are dispatched on ServiceWorkerGlobalScope object:
</p>

<table id="_event-table" class="grid-table"><thead>
<tr><th>~event名
<th>~interface
<th>分類
<th>配送-時機
<tbody>

<tr><td>`install@et
<td>`InstallEvent$I
<td>`~lifecycle~event$
<td>
%~sw を`包含している~sw登録$swにて`~install中の~worker$swrが変化したとき
（`~installする$を見よ）。
【！＊ step 11.2 → 10.2 issues#1391】
◎
The service worker’s containing service worker registration’s installing worker changes. (See step 11.2 of the Install algorithm.)

<tr><td>`activate@et
<td>`ExtendableEvent$I
<td>`~lifecycle~event$
<td>
%~sw を`包含している~sw登録$swにて`作動中な~worker$swrの変化したとき
（`作動化する$を見よ）。
【！＊step 12.2 】
◎
The service worker’s containing service worker registration’s active worker changes. (See step 12.2 of the Activate algorithm.)

<tr><td>`fetch@et
<td>`FetchEvent$I
<td>`機能的~event$
<td>
`~HTTP~fetch$は、
`~fetchを取扱う$( `要請$, … ) を呼出す。
これを遂行した結果として、
%~sw は，`~HTTP~fetch$に`応答$を返す。
この応答は、
`Response$I ~objにより表現され，［
`Cache$I ~objから ／
`self.fetch()$n ~methodを利用して~networkから直に
］検索取得できる。
（別の~optionとして~custom `Response$I ~objもある。）
◎
The http fetch invokes Handle Fetch with request. As a result of performing Handle Fetch, the service worker returns a response to the http fetch. The response, represented by a Response object, can be retrieved from a Cache object or directly from network using self.fetch(input, init) method. (A custom Response object can be another option.)

<tr><td>`push$et
<td>`PushEvent$I
<td>`機能的~event$
<td>
（ `push^et ~eventの`発火-法＠https://w3c.github.io/push-api/#receiving-a-push-message$を見よ。）
◎
(See Firing a push event.)

<tr><td>`notificationclick$et
<td>`NotificationEvent$I
<td>`機能的~event$
<td>
（`通知の作動化-法＠~NOTIFICATIONS#activating-a-notification$を見よ。）
◎
(See Activating a notification.)

<tr><td>`notificationclose$et
<td>`NotificationEvent$I
<td>`機能的~event$
<td>
（`通知の~close法＠~NOTIFICATIONS#closing-a-notification$を見よ。）
◎
(See Closing a notification.)

<tr><td>`sync$et
<td>`SyncEvent$I
<td>`機能的~event$
<td>
（ `sync^et ~eventの`発火-法＠https://wicg.github.io/BackgroundSync/spec/#fire-a-sync-event$
を見よ。）
◎
(See Firing a sync event.)

<tr><td>`canmakepayment$et
<td>`CanMakePaymentEvent$I
<td>`機能的~event$
<td>
（ `CanMakePaymentEvent^I の`取扱い＠https://w3c.github.io/payment-handler/#dfn-handling-a-canmakepaymentevent$
を見よ。）
◎
(See Handling a CanMakePaymentEvent.)

<tr><td>`paymentrequest$et
<td>`PaymentRequestEvent$I
<td>`機能的~event$
<td>
（ `PaymentRequestEvent^I `の取扱い＠https://w3c.github.io/payment-handler/#dfn-handling-a-paymentrequestevent$
を見よ。）
◎
(See Handling a PaymentRequestEvent.)

<tr><td>`message@et
<td>`ExtendableMessageEvent$I
<td>旧来の~event
<td>
~messageを受信したとき。
◎
When it receives a message.

<tr><td>`messageerror@et
<td>`MessageEvent$I
<td>旧来の~event
<td>
逆直列化できない~messageが送信されてきたとき。
◎
When it was sent a message that cannot be deserialized.
</table>

		</section>
	</section>
	<section id="cache-objects">
<h2 title="Caches">5. ~cache</h2>

<p>
作者が~offline用に内容~cacheを全部的に管理できるようにするため、［
`Window$I ／ `WorkerGlobalScope$I
］は，
`Cache$I ~objを~openして操作するための非同期的な~cache用~methodを供する。
同じ`生成元$enVは、
複数の有名 `Cache$I ~objを持ち得る
— その内容は、
まるごと~scriptの制御~下に置かれる。
~cacheは、
異なる`生成元$間で共有されることはなく，~browserの~HTTP~cacheからも完全に隔離される。
◎
To allow authors to fully manage their content caches for offline use, the Window and the WorkerGlobalScope provide the asynchronous caching methods that open and manipulate Cache objects. An origin can have multiple, named Cache objects, whose contents are entirely under the control of scripts. Caches are not shared across origins, and they are completely isolated from the browser’s HTTP cache.
</p>

		<section id="cache-constructs">
<h3 title="Constructs">5.1. 構成子</h3>

<p>
`要請~応答~list@
は、
0 個~以上の［
( `要請$, `応答$ )
が成す`~tuple$
］たちが成す`~list$である。
◎
A request response list is a list of tuples consisting of a request (a request) and a response (a response).
</p>

<p>
~obj %O に
`関連な要請~応答~list@
は、
%O が表現する`要請~応答~list$を指す。
【 %O に該当するものは、この仕様においては `Cache$I ~objしかない。】
◎
The relevant request response list is the instance that this represents.
</p>

<p>
`名前から~cacheへの~map@
は、
`有順序~map$であり，それを成す各`~entry$mapは［
`要請~応答~list$の名前を表現する文字列 → `要請~応答~list$
］を与える。
◎
A name to cache map is an ordered map whose entry consists of a key (a string that represents the name of a request response list) and a value (a request response list).
</p>

<p>
各`~storage~key$には、
ある`名前から~cacheへの~map$が結付けられる。
◎
Each storage key has an associated name to cache map.
</p>

<p>
~obj %O に
`関連な名前から~cacheへの~map@
は、
次の結果に結付けられた`名前から~cacheへの~map$を指す。
⇒
`~storage~keyを得する$( %O に`関連な設定群~obj$【！%O に結付けられた`大域~obj$の`環境~設定群~obj$】 )
◎
The relevant name to cache map is the name to cache map associated with the storage key obtained from this’s associated global object’s environment settings object.
</p>

<p class="trans-note">【
%O に該当するものは、
この仕様においては `CacheStorage$I ~objしかない。
】</p>

		</section>
		<section id="cache-lifetimes">
<h3 title="Understanding Cache Lifetimes">5.2. ~cacheの存続期間を理解する</h3>

<p>
`Cache$I ~instanceは、
~browserの~HTTP~cacheの一部を成さない。
作者~自身が、
`Cache$I ~objを管理する必要がある：
◎
The Cache instances are not part of the browser’s HTTP cache. The Cache objects are exactly what authors have to manage themselves.＼
</p>

<ul>
	<li>
作者が明示的に要請しない限り，更新されない。
◎
The Cache objects do not get updated unless authors explicitly request them to be.＼
</li>
	<li>
それを成す各~entryは、
作者が削除しない限り失効しない。
◎
The Cache objects do not expire unless authors delete the entries.＼
</li>
	<li>
`~sw$~scriptを更新するだけで消失することはない
— すなわち、
~cacheは自動的には更新されず，その更新-は手動で管理しなければナラナイ。
◎
The Cache objects do not disappear just because the service worker script is updated. That is, caches are not updated automatically. Updates must be manually managed.＼
</li>
</ul>

<p>
したがって作者は、
自身の~cacheに名前†により~versionを付与した上で、
それを利用するのは，安全に運用できる~versionの`~sw$に限るようにするべきである。
◎
This implies that authors should version their caches by name and make sure to use the caches only from the version of the service worker that can safely operate on.
</p>

<p class="trans-note">【†
`CacheStorage$I 上の各種~methodの %cacheName 引数 ／
`MultiCacheQueryOptions$I の `cacheName^m ~memberを指す。
】</p>

		</section>
		<section id="self-caches">
<h3>5.3. `self.caches^m</h3>

<pre class="idl">
partial interface mixin `WindowOrWorkerGlobalScope$I {
  [`SecureContext$, `SameObject$] readonly attribute `CacheStorage$I `caches$n;
};
</pre>

			<section id="global-caches">
<h4>5.3.1. `caches^m</h4>

<p>
`caches@n
取得子~手続きは
⇒
~RET コレに結付けられた `CacheStorage$I ~obj
◎
caches getter steps are to return this’s associated CacheStorage object.
</p>

			</section>
		</section>
		<section id="cache-interface">
<h3>5.4. `Cache^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `Cache@I {
  [`NewObject$] `Promise$&lt;(`Response$I or `undefined$)&gt; `match$m(`RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
  [`NewObject$] `Promise$&lt;`FrozenArray$&lt;`Response$I&gt;&gt; `matchAll$m(optional `RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
  [`NewObject$] `Promise$&lt;`undefined$&gt; `add$m(`RequestInfo$I %request);
  [`NewObject$] `Promise$&lt;`undefined$&gt; `addAll$m(`sequence$&lt;`RequestInfo$I&gt; %requests);
  [`NewObject$] `Promise$&lt;`undefined$&gt; `put$m(`RequestInfo$I %request, `Response$I %response);
  [`NewObject$] `Promise$&lt;`boolean$&gt; `delete$m(`RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
  [`NewObject$] `Promise$&lt;`FrozenArray$&lt;`Request$I&gt;&gt; `keys$m(optional `RequestInfo$I %request, optional `CacheQueryOptions$I %options = {});
};
</pre>

<pre class="idl" id="cache-query-options-dictionary">
dictionary `CacheQueryOptions@I {
  `boolean$ `ignoreSearch@m = false;
  `boolean$ `ignoreMethod@m = false;
  `boolean$ `ignoreVary@m = false;
};
</pre>

<p>
`Cache$I ~objは、
`要請~応答~list$を表現する。
いくつかの文書や~workerにまたがって、
同時に複数の `Cache$I ~objが 同じ`要請~応答~list$を表現し得る。
【同じ文書や~worker上でも，複数あり得る（ `CacheStorage^I1 `open()$m1 を見よ）。】
◎
A Cache object represents a request response list. Multiple separate objects implementing the Cache interface across documents and workers can all be associated with the same request response list simultaneously.
</p>

<div>
<p>
`~cache~batch演算@
は、
次に挙げるものからなる`構造体$である：
</p>
<ul>
	<li>
`種別@cbo
⇒
`delete^l ／ `put^l
</li>
	<li>
`要請@cbo
⇒
`要請$
</li>
	<li>
`応答@cbo
⇒
`応答$
</li>
	<li>
`~option群@cbo
⇒
`CacheQueryOptions$I ~obj
</li>
</ul>
◎
A cache batch operation is a struct that consists of:
• A type ("delete" or "put").
• A request (a request).
• A response (a response).
• An options (a CacheQueryOptions).
</div>

`Cache^I0

			<section id="cache-match">
<h4>5.4.1. `match(request, options)^m</h4>

<p>
`match(request, options)@m
~method手続きは：
◎
The match(request, options) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%p ~LET コレ上で `matchAll(request, options)$m ~method手続きを遂行する
◎
Let p be the result of running the algorithm specified in matchAll(request, options) method with request and options.
</li>
			<li>
<p>
%p が決着するまで待機する：
◎
Wait until p settles.
</p>
				<ul>
					<li class="algo">
%p は %例外 で却下されたときは
⇒
`~promiseを却下する$( %~promise, %例外 )
◎
If p rejects with an exception, then:
• Reject promise with that exception.
</li>
					<li class="algo">
<p>
%p は配列 %応答~群 で充足されたときは：
</p>
						<ol>
							<li>
%結果 ~LET ［
%応答~群 は空ならば `undefined^jv ／
~ELSE_ %応答~群[ 0 ]
］
</li>
							<li>
`~promiseを解決する$( %~promise, %結果 )
</li>
						</ol>
◎
Else if p resolves with an array, responses, then:
• If responses is an empty array, then:
•• Resolve promise with undefined.
• Else:
•• Resolve promise with the first element of responses.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="cache-matchall">
<h4>5.4.2. `matchAll(request, options)^m</h4>

<p>
`matchAll(request, options)@m
~method手続きは：
◎
The matchAll(request, options) method steps are:
</p>
<ol>
	<li>
%r ~LET ε
◎
Let r be null.
</li>
	<li>
<p>
~IF［
%request ~NEQ ε
］：
◎
If the optional argument request is not omitted, then:
</p>
		<ol>
			<li>
<p>
~IF［
%request は `Request$I ~objである
］：
◎
If request is a Request object, then:
</p>
				<ol>
					<li>
%r ~SET %request の`要請$Rq
◎
Set r to request’s request.
</li>
					<li>
~IF［
%r の`~method$rq ~NEQ `GET^bl
］~AND［
%options[ `CacheQueryOptions^I1"`ignoreMethod$m1" ] ~EQ ~F
］
⇒
~RET `解決される~promise$( 空な配列 )
◎
If r’s method is not `GET` and options.ignoreMethod is false, return a promise resolved with an empty array.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %request は文字列である）：
</p>
				<ol>
					<li>
%R ~LET `新たな~obj$( `Request$I )
</li>
					<li>
<p>
%R 上で `new Request(request)$n 構築子~手続きを遂行する
【！ method = GET になる】
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~RET `却下される~promise$( その例外 )
</p>
					</li>
					<li>
%r ~SET %R の`要請$Rq
</li>
				</ol>
◎
Else if request is a string, then:
• Set r to the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
		</ol>
	</li>
	<li>
%~realm ~LET コレに`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%応答~list ~LET 新たな`~list$
◎
Let responses be an empty list.
</li>
			<li>
%要請~応答~list ~LET コレに`関連な要請~応答~list$
◎
↓</li>
			<li>
~IF［
%r ~NEQ ε
］
⇒
%要請~応答~list ~SET `~cacheを~queryする$( %r, %要請~応答~list, %options )
◎
If the optional argument request is omitted, then:
• For each requestResponse of the relevant request response list:
•• Add a copy of requestResponse’s response to responses.
◎
Else:
• Let requestResponses be the result of running Query Cache with r and options.
•• For each requestResponse of requestResponses:
••• Add a copy of requestResponse’s response to responses.
（ copy は次の段で行う）
</li>
			<li>
%要請~応答~list を成す
~EACH( %要請~応答 )
に対し
⇒
%応答~list に［
%要請~応答 を成す応答
］の複製を`付加する$
◎
↑</li>
			<li>
%設定群 ~LET %~promise に`関連な設定群~obj$
◎
↓</li>
			<li>
<p>
%応答~list を成す
~EACH( %応答 )
に対し：
◎
For each response of responses:
</p>
				<ol>
					<li>
~IF［
%応答 の`種別$rs ~NEQ `opaque^l
］
⇒
~CONTINUE
◎
If response’s type is "opaque" and＼
</li>
					<li>
%検査~結果 ~LET `非同一-生成元~資源~施策~検査$( ↓ )
⇒＃
%設定群 の`生成元$enV,
%設定群,
空~文字列,
%応答 の`内部~応答$
◎
cross-origin resource policy check with promise’s relevant settings object’s origin, promise’s relevant settings object, "", and response’s internal response＼
</li>
					<li>
~IF［
%検査~結果 ~EQ `阻止される^i
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError^E )；
~RET
◎
returns blocked, then reject promise with a TypeError and abort these steps.
</li>
				</ol>
			</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %設定群 の`担当の~event~loop$enV )
◎
Queue a task, on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source, to perform＼
</p>
<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
				<ol>
					<li>
%応答~obj~list ~LET 新たな`~list$
◎
Let responseList be a list.
</li>
					<li>
%応答~list を成す
~EACH( %応答 )
に対し
⇒
%応答~obj~list に次の結果を`付加する$
⇒
`~Response~objを作成する$( %応答, `immutable^l, %~realm )
◎
For each response of responses:
• Add a new Response object associated with response and a new Headers object whose guard is "immutable" to responseList.
</li>
					<li>
`~promiseを解決する$( %~promise, 次の結果 )
⇒
%~realm 内で`凍結d配列を作成する$( %応答~obj~list )
◎
Resolve promise with a frozen array created from responseList, in realm.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="cache-add">
<h4>5.4.3. `add(request)^m</h4>

<p>
`add(request)@m
~method手続きは：
◎
The add(request) method steps are:
</p>
<ol>
	<li>
%requests ~LET %request のみを包含している配列
◎
Let requests be an array containing only request.
</li>
	<li>
%応答~配列~promise ~LET コレ上で `addAll(requests)$m ~method手続きを遂行する
◎
Let responseArrayPromise be the result of running the algorithm specified in addAll(requests) passing requests as the argument.
</li>
	<li>
<p>
~RET `~promiseに反応する$( %応答~配列~promise )
— `充足~手続き^i として次を与える下で：
</p>

<div class="algo">
手続きは
⇒
~RET `undefined^jv
</div>
◎
Return the result of reacting to responseArrayPromise with a fulfillment handler that returns undefined.
</li>
</ol>

			</section>
			<section id="cache-addAll">
<h4>5.4.4. `addAll(requests)^m</h4>

<p>
`addAll(requests)@m
~method手続きは：
◎
The addAll(requests) method steps are:
</p>
<ol>
	<li>
%応答~promiseたち ~LET 新たな`~list$
◎
Let responsePromises be an empty list.
</li>
	<li>
%要請~list ~LET 新たな`~list$
◎
Let requestList be an empty list.
</li>
	<li>
<p>
%requests を成す
~EACH( %r )
に対し：
</p>
		<ol>
			<li>
<p>
~IF［
%r は ~AND↓ を満たす
］…
</p>
				<ul>
					<li>
`Request$I ~objである
</li>
					<li>
%r の`要請$Rqは次を満たす
⇒
［
その`~URL$rqの`~scheme$url ~NIN { `http^l, `https^l }
］~OR［
その`~method$rq ~NEQ `GET^bl
］
</li>
				</ul>
…ならば
⇒
~RET `却下される~promise$( `TypeError^E 例外 )
</li>
		</ol>
◎
For each request whose type is Request in requests:
• Let r be request’s request.
• If r’s url’s scheme is not one of "http" and "https", or r’s method is not `GET`, return a promise rejected with a TypeError.
</li>
	<li>
%~fetch制御器~群 ~LET 新たな`~list$【！of `~fetch制御器$】
◎
Let fetchControllers be a list of fetch controllers.
</li>
	<li>
<p>
%requests を成す
~EACH( %r )
に対し：
◎
For each request in requests:
</p>
		<ol>
			<li>
%R ~LET `新たな~obj$( `Request$I )
◎
↓</li>
			<li>
<p>
%R 上で `new Request(r)$n 構築子~手続きを遂行する
【！ method = GET になる】
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~RET `却下される~promise$( その例外 )
</p>
◎
Let r be the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
			<li>
%要請 ~LET %R の`要請$Rq
◎
↑</li>
			<li>
<p>
~IF［
%要請 の`~URL$rqの`~scheme$url ~NIN { `http^l, `https^l }
］：
◎
If r’s url’s scheme is not one of "http" and "https", then:
</p>
				<ol>
					<li>†
%~fetch制御器~群 を成す
~EACH( %~fetch制御器 )
に対し
⇒
`~fetchを中止する$( %~fetch制御器 )
◎
For each fetchController of fetchControllers, abort fetchController.
</li>
					<li>
~RET `却下される~promise$( `TypeError^E 例外 )
◎
Return a promise rejected with a TypeError.
</li>
				</ol>

<p class="trans-note">【
最初の段 † は，［
これまでの反復にて、
下の並列的に走らす段の中で，
%~fetch制御器~群 に付加された各`~fetch制御器$
］に対する処理nを意図していると見受けられるが、
並列的に走らすので，この時点では
%~fetch制御器 は空にしかなり得ない。
この段の検査は、
%r が `Request$I であるならば，この~loopより前にすでに遂行されている
— 他の場合も，この~loopより前に遂行するべきであろう。
】</p>

			</li>
			<li>
~IF［
%要請 の`~client$rqの`大域~obj$enV は `ServiceWorkerGlobalScope$I ~objである
］
⇒
%要請 の`~sw~mode$rq ~SET `none^l
【！＊request】
◎
If r’s client’s global object is a ServiceWorkerGlobalScope object, set request’s service-workers mode to "none".
</li>
			<li>
%要請 の
⇒＃
`起動元$rq ~SET `fetch^l,
`行先$rq ~SET `subresource^l
◎
Set r’s initiator to "fetch" and destination to "subresource".
</li>
			<li>
%要請~list に %要請 を`付加する$
◎
Add r to requestList.
</li>
			<li>
%応答~promise ~LET `新たな~promise$
◎
Let responsePromise be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
<p>
【 %~fetch制御器~群 に】次の結果を`付加する$
⇒
%要請 を`~fetchする$
— 次を与える下で：
◎
Append the result of fetching r.
</p>
						<ul>
							<li class="algo">
<p>
`応答の処理n^i は、
所与の
( %応答 )
に対し：
◎
To processResponse for response, run these substeps:
</p>
								<ol>
									<li>
~IF［
%応答 の`種別$rs ~EQ `error^l
］~OR［
%応答 の`状態s$rsは`~ok状態s$でない
］~OR［
%応答 の`状態s$rs ~EQ `206^st
］
⇒＃
`~promiseを却下する$( %応答~promise, `TypeError^E )；
~RET
◎
If response’s type is "error", or response’s status is not an ok status or is 206, reject responsePromise with a TypeError.
</li>
									<li>
%Vary ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `Vary$h )
◎
↓</li>
									<li>
<p>
~IF［
%Vary ~NEQ ~NULL
］~AND［
`*^l ~IN %Vary
］：
◎
Else if response’s header list contains a header named `Vary`, then:
• Let fieldValues be the list containing the elements corresponding to the field-values of the Vary header.
•• For each fieldValue of fieldValues:
••• If fieldValue matches "*", then:
</p>
										<ol>
											<li>
`~promiseを却下する$( %応答~promise, `TypeError^E )
◎
Reject responsePromise with a TypeError.
</li>
											<li>
%~fetch制御器~群 を成す
~EACH( %~fetch制御器 )
に対し
⇒
`~fetchを中止する$( %~fetch制御器 )
◎
For each fetchController of fetchControllers, abort fetchController.
◎
Abort these steps.
</li>
										</ol>
									</li>
								</ol>
							</li>
							<li class="algo">
<p>
`応答の本体~終了~時の処理n^i  は、
所与の
( %応答 )
に対し：
◎
To processResponseEndOfBody for response, run these substeps:
</p>

								<ol>
									<li>
~IF［
%応答 の`中止されたか$rs ~EQ ~T
］
⇒＃
`~promiseを却下する$( %応答~promise, `AbortError$E 例外 )；
◎
If response’s aborted flag is set, reject responsePromise with an "AbortError" DOMException and abort these steps.
</li>
									<li>
~ELSE
⇒
`~promiseを解決する$( %応答~promise, %応答 )
◎
Resolve responsePromise with response.
</li>
								</ol>

<p class="note">注記：
応答の本体が全部的に受信されたときは、
~cache~commitは許容される。
◎
Note: The cache commit is allowed when the response’s body is fully received.
</p>
							</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
%応答~promiseたち に %応答~promise を`付加する$
◎
Add responsePromise to responsePromises.
</li>
		</ol>
	</li>
	<li>
%p ~LET `すべてを待機する~promiseを取得する$( %応答~promiseたち )
◎
Let p be the result of getting a promise to wait for all of responsePromises.
</li>
	<li>
<p>
~RET `~promiseに反応する$( %p )
— `充足~手続き^i として次を与える下で：
◎
Return the result of reacting to p with a fulfillment handler that,＼
</p>

<div class="algo">
<p>
手続きは、
所与の ( %応答~obj~list ) に対し：
◎
when called with argument responses, performs the following substeps:
</p>
		<ol>
			<li>
%演算~群 ~LET 新たな`~list$
◎
Let operations be an empty list.
</li>
			<li>
%~index ~LET 0
◎
Let index be zero.
</li>
			<li>
<p>
%応答~obj~list を成す
~EACH( %応答~obj )
に対し：
◎
For each response in responses:
</p>
				<ol>
					<li>
%演算 ~LET 新たな`~cache~batch演算$
— その
⇒＃
`種別$cbo ~SET `put^l,
`要請$cbo ~SET %要請~list[ %~index ],
`応答$cbo ~SET %応答~obj 【の`応答$Rs】
◎
Let operation be a cache batch operation.
◎
Set operation’s type to "put".
◎
Set operation’s request to requestList[index].
◎
Set operation’s response to response.
</li>
					<li>
%演算~群 に %演算 を`付加する$
◎
Append operation to operations.
</li>
					<li>
%~index ~INCBY 1
◎
Increment index by one.
</li>
				</ol>
			</li>
			<li>
%~realm ~LET コレに`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
			<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
%~error~data ~LET ~NULL
◎
Let errorData be null.
</li>
					<li>
<p>
`~cache演算を~batchする$( %演算~群, コレ )
◎
Invoke Batch Cache Operations with operations.＼
</p>

<p>
例外が投出されたときは、
~catchして
⇒
%~error~data ~SET その例外
◎
If this throws an exception, set errorData to the exception.
</p>
					</li>
					<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~cache~job~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task, on cacheJobPromise’s relevant settings object’s responsible event loop using the DOM manipulation task source, to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following substeps:
</p>
						<ol>
							<li>
~IF［
%~error~data ~EQ ~NULL
］
⇒
`~promiseを解決する$( %~cache~job~promise )
◎
If errorData is null, resolve cacheJobPromise with undefined.
</li>
	<li>
~ELSE
⇒
`~promiseを却下する$( %~cache~job~promise, 次に与える例外 )
⇒
%~realm 内に作成される`新たな例外$( %~error~data )
◎
Else, reject cacheJobPromise with a new exception with errorData, in realm.
</li>
						</ol>
</div>
					</li>
				</ol>

			</li>
			<li>
~RET %~cache~job~promise
◎
Return cacheJobPromise.
</li>
		</ol>
</div>
	</li>
</ol>

			</section>
			<section id="cache-put">
<h4>5.4.5. `put(request, response)^m</h4>

<p>
`put(request, response)@m
~method手続きは：
◎
The put(request, response) method steps are:
</p>
<ol>
	<li>
<p>
~IF［
%request は `Request$I ~objでない【文字列である】
］：
</p>
		<ol>
			<li>
%R ~LET `新たな~obj$( `Request$I )
</li>
			<li>
<p>
%R 上で `new Request(request)$n 構築子~手続きを遂行する
【！ method = GET になる】
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~RET `却下される~promise$( その例外 )
</p>
</li>
			<li>
%request ~SET %R
</li>
		</ol>
◎
Let innerRequest be null.
◎
If request is a Request object, then set innerRequest to request’s request.
◎
Else:
• Let requestObj be the result of invoking Request’s constructor with request as its argument. If this throws an exception, return a promise rejected with exception.
• Set innerRequest to requestObj’s request.
</li>
	<li>
%内縁~要請 ~LET %request の`要請$Rq
◎
↑</li>
	<li>
~IF［
%内縁~要請 の`~URL$rqの`~scheme$url ~NIN { `http^l , `https^l }
］~OR［
%内縁~要請 の`~method$rq ~NEQ `GET^bl
］
⇒
~RET `却下される~promise$( `TypeError^E 例外 )
◎
If innerRequest’s url’s scheme is not one of "http" and "https", or innerRequest’s method is not `GET`, return a promise rejected with a TypeError.
◎
</li>
	<li>
%内縁~応答 ~LET %response の`応答$Rs
◎
Let innerResponse be response’s response.
</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%内縁~応答 の`状態s$rs ~EQ `206^st
</li>
			<li>
［
次の結果 ~NEQ ~NULL
］~AND［
`*^l ~IN 次の結果
］
⇒
`~header~listから値を取得して復号して分割する$( %内縁~応答 の`~header~list$rs, `Vary$h )
</li>
			<li>
%内縁~応答 の`本体$rsは［
`妨げられて$RSいる／`~lockされて$RSいる
］
</li>
		</ul>
<p>
…ならば
⇒
~RET `却下される~promise$( `TypeError^E 例外 )
</p>
◎
If innerResponse’s status is 206, return a promise rejected with a TypeError.
◎
If innerResponse’s header list contains a header named `Vary`, then:
• Let fieldValues be the list containing the items corresponding to the Vary header’s field-values.
•• For each fieldValue in fieldValues:
••• If fieldValue matches "*", return a promise rejected with a TypeError.
◎
If innerResponse’s body is disturbed or locked, return a promise rejected with a TypeError.
</li>
	<li>
%~cloneされた応答 ~LET `応答を~cloneする$( %内縁~応答 )
◎
Let clonedResponse be a clone of innerResponse.
</li>
	<li>
%本体を読取る~promise ~LET `解決される~promise$( `undefined^jv )
◎
Let bodyReadPromise be a promise resolved with undefined.
</li>
	<li>
<p>
~IF［
%内縁~応答 の`本体$rs ~NEQ ~NULL
］：
◎
If innerResponse’s body is non-null, run these substeps:
</p>
		<ol>
			<li>
%~stream ~LET %内縁~応答 の`本体$rsの`~stream$
◎
Let stream be innerResponse’s body’s stream.
</li>
			<li>
%読取器 ~LET %~stream から`読取器を取得する$RS()
◎
Let reader be the result of getting a reader for stream.
</li>
			<li>
%本体を読取る~promise ~SET %読取器 から`すべての~byteを読取る$RSR()
【この段とそれに関係する処理nは、まだ `STREAMS$r による更新が反映されていない。】
◎
Set bodyReadPromise to the result of reading all bytes from reader.
</li>
		</ol>
<p class="note">注記：
これは、
%内縁~応答 の`本体$rsが`~lockされて$RSいることを確保して、
%~cloneされた応答 内の本体を全部的に~bufferした複製を得る。
実装は、
~memoryではなく~diskへ直に~streamすることにより最適化することもできる。
◎
Note: This ensures that innerResponse’s body is locked, and we have a full buffered copy of the body in clonedResponse. An implementation could optimize by streaming directly to disk rather than memory.
</p>
	</li>
	<li>
%演算 ~LET 新たな`~cache~batch演算$
— その
⇒＃
`種別$cbo ~SET `put^l
`要請$cbo ~SET %内縁~要請
`応答$cbo ~SET %~cloneされた応答
◎
Let operations be an empty list.
◎
Let operation be a cache batch operation.
◎
Set operation’s type to "put".
◎
Set operation’s request to innerRequest.
◎
Set operation’s response to clonedResponse.
◎
↓ Append operation to operations.
</li>
	<li>
%~realm ~LET コレに`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li class="algo">
<p>
~RET %本体を読取る~promise の`充足-時$には次を遂行するようにした結果：
◎
Return the result of the fulfillment of bodyReadPromise:
</p>
		<ol>
			<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
			<li>
~RET %~cache~job~promise
— ただし、
以下も`並列的$に走らす
◎
Return cacheJobPromise and run these steps in parallel:
</li>
			<li>
%~error~data ~LET ~NULL
◎
Let errorData be null.
</li>
			<li>
<p>
`~cache演算を~batchする$( « %演算 », コレ )
</p>

<p>
例外が投出されたときは、
~catchして
⇒
%~error~data ~SET その例外
</p>
◎
Invoke Batch Cache Operations with operations. If this throws an exception, set errorData to the exception.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~cache~job~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task, on cacheJobPromise’s relevant settings object’s responsible event loop using the DOM manipulation task source, to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following substeps:
</p>
				<ol>
					<li>
~IF［
%~error~data ~EQ ~NULL
］
⇒
`~promiseを解決する$( %~cache~job~promise )
◎
If errorData is null, resolve cacheJobPromise with undefined.
</li>
					<li>
~ELSE
⇒
`~promiseを却下する$( %~cache~job~promise, 次に与える例外 )
⇒
%~realm 内に作成される`新たな例外$( %~error~data )
◎
Else, reject cacheJobPromise with a new exception with errorData, in realm.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="cache-delete">
<h4>5.4.6. `delete(request, options)^m</h4>

<p>
`delete(request, options)@m
~method手続きは：
◎
The delete(request, options) method steps are:
</p>
<ol>
	<li>
%r ~LET ~NULL
◎
Let r be null.
</li>
	<li>
<p>
~IF［
%request は `Request$I ~objである
］：
◎
If request is a Request object, then:
</p>
		<ol>
			<li>
%r ~SET %request の`要請$Rq
◎
Set r to request’s request.
</li>
			<li>
~IF［
%r の`~method$rq ~NEQ `GET^bl
］~AND［
%~option群[ "`ignoreMethod$m1" ] ~EQ ~F
］
⇒
~RET `解決される~promise$( ~F )
◎
If r’s method is not `GET` and options.ignoreMethod is false, return a promise resolved with false.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %request は文字列である）：
</p>
		<ol>
			<li>
%R ~LET `新たな~obj$( `Request$I )
</li>
			<li>
<p>
%R 上で `new Request(request)$n 構築子~手続きを遂行する
【！ method = GET になる】
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~RET `却下される~promise$( その例外 )
</p>
			</li>
			<li>
%r ~SET %R の`要請$Rq
</li>
		</ol>
◎
Else if request is a string, then:
• Set r to the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
	<li>
%演算 ~LET 新たな`~cache~batch演算$
— その
⇒＃
`種別$cbo ~SET `delete^l,
`要請$cbo ~SET %r,
`~option群$cbo ~SET %options
◎
Let operations be an empty list.
◎
Let operation be a cache batch operation.
◎
Set operation’s type to "delete".
◎
Set operation’s request to r.
◎
Set operation’s options to options.
◎
↓ Append operation to operations.
</li>
	<li>
%~realm ~LET コレに`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
%~error~data ~LET ~NULL
◎
Let errorData be null.
</li>
			<li>
<p>
%要請~応答~list ~LET `~cache演算を~batchする$( « %演算 », コレ )
</p>

<p>
例外が投出されたときは、
~catchして
⇒
%~error~data ~SET その例外
</p>
◎
Let requestResponses be the result of running Batch Cache Operations with operations. If this throws an exception, set errorData to the exception.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~cache~job~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task, on cacheJobPromise’s relevant settings object’s responsible event loop using the DOM manipulation task source, to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following substeps:
</p>
				<ol>
					<li>
<p>
~IF［
%~error~data ~EQ ~NULL
］
⇒
`~promiseを解決する$( %~cache~job~promise, 次の結果 )
⇒
~IS［
%要請~応答~list は`空$でない
］
◎
If errorData is null, then:
• If requestResponses is not empty, resolve cacheJobPromise with true.
• Else, resolve cacheJobPromise with false.
</li>
					<li>
~ELSE
⇒
`~promiseを却下する$( %~cache~job~promise, 次に与える例外 )
⇒
%~realm 内に作成される`新たな例外$( %~error~data )
◎
Else, reject cacheJobPromise with a new exception with errorData, in realm.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~cache~job~promise
◎
Return cacheJobPromise.
</li>
</ol>

			</section>
			<section id="cache-keys">
<h4>5.4.7. `keys(request, options)^m</h4>

<p>
`keys(request, options)@m
~method手続きは：
◎
The keys(request, options) method steps are:
</p>
<ol>
	<li>
%r ~LET ε
◎
Let r be null.
</li>
	<li>
<p>
~IF［
%request ~NEQ ε
］：
◎
If the optional argument request is not omitted, then:
</p>
		<ol>
			<li>
<p>
~IF［
%request は `Request$I ~objである
］：
◎
If request is a Request object, then:
</p>

				<ol>
					<li>
%r ~SET %request の`要請$Rq
◎
Set r to request’s request.
</li>
					<li>
~IF［
%r の`~method$rq ~NEQ `GET^bl
］~AND［
%options[ "`ignoreMethod$m1" ] ~EQ ~F
］
⇒
~RET `解決される~promise$( 空な配列 )
◎
If r’s method is not `GET` and options.ignoreMethod is false, return a promise resolved with an empty array.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %request は文字列である）：
</p>
				<ol>
					<li>
%R ~LET `新たな~obj$( `Request$I )
</li>
					<li>
<p>
%R 上で `new Request(request)$n 構築子~手続きを遂行する
【！ method = GET になる】
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~RET `却下される~promise$( その例外 )
</p>
					</li>
					<li>
%r ~SET %R の`要請$Rq
</li>
				</ol>
◎
Else if request is a string, then:
• Set r to the associated request of the result of invoking the initial value of Request as constructor with request as its argument. If this throws an exception, return a promise rejected with that exception.
</li>
		</ol>
	</li>
	<li>
%~realm ~LET コレに`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run these substeps in parallel:
</p>
		<ol>
			<li>
%要請~list ~LET 新たな`~list$
◎
Let requests be an empty list.
</li>
			<li>
%要請~応答~list ~LET コレに`関連な要請~応答~list$
◎
↓</li>
			<li>
~IF［
%r ~NEQ ε
］
⇒
%要請~応答~list ~SET `~cacheを~queryする$( %r, %要請~応答~list, %options )
◎
↓</li>
			<li>
%要請~応答~list を成す
~EACH( %要請~応答 )
に対し
⇒
%要請~list に［
%要請~応答 を成す要請
］を`付加する$
◎
If the optional argument request is omitted, then:
• For each requestResponse of the relevant request response list:
•• Add requestResponse’s request to requests.
◎
Else:
• Let requestResponses be the result of running Query Cache with r and options.
•• For each requestResponse of requestResponses:
••• Add requestResponse’s request to requests.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task, on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source, to perform the following steps:
</p>

<div class="algo">
<p>
手続きは：
</p>
				<ol>
					<li>
%要請~obj~list ~LET 新たな`~list$
◎
Let requestList be a list.
</li>
					<li>
%要請~list を成す
~EACH( %要請 )
に対し
⇒
%要請~obj~list に次の結果を`付加する$
⇒
`~Request~objを作成する$( %要請, `immutable^l, %~realm )
◎
For each request of requests:
• Add a new Request object associated with request and a new associated Headers object whose guard is "immutable" to requestList.
</li>
					<li>
`~promiseを解決する$( %~promise, 次の結果 )
⇒
%~realm 内で`凍結d配列を作成する$( %要請~obj~list )
◎
Resolve promise with a frozen array created from requestList, in realm.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="cachestorage-interface">
<h3>5.5. `CacheStorage^I</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window,Worker)]
interface `CacheStorage@I {
  [`NewObject$] `Promise$&lt;(`Response$I or `undefined$)&gt; `match$m(`RequestInfo$I %request, optional `MultiCacheQueryOptions$I %options = {});
  [`NewObject$] `Promise$&lt;`boolean$&gt; `has$m(`DOMString$ %cacheName);
  [`NewObject$] `Promise$&lt;`Cache$I&gt; `open$m(`DOMString$ %cacheName);
  [`NewObject$] `Promise$&lt;`boolean$&gt; `delete$m(`DOMString$ %cacheName);
  [`NewObject$] `Promise$&lt;`sequence$&lt;`DOMString$&gt;&gt; `keys$m();
};

dictionary `MultiCacheQueryOptions@I : `CacheQueryOptions$I {
  DOMString `cacheName@m;
};
</pre>

<p class="note">注記：
`CacheStorage$I ~interfaceは
`ECMAScript 6 Map object＠~TC39#sec-map-objects$
に幅広く適合するよう設計されているが、
全体的に非同期cであり，追加的な便利~methodも伴う。
［
`clear()^m ／ `forEach()^m ／ `entries()^m ／ `values()^m
］~methodは、
最初の~versionの視野からは，意図的に除外されている
— TC39 による非同期cな反復についての進行中な論点に委ねられているので。
◎
Note: CacheStorage interface is designed to largely conform to ECMAScript 6 Map objects but entirely async, and with additional convenience methods. The methods, clear, forEach, entries and values, are intentionally excluded from the scope of the first version resorting to the ongoing discussion about the async iteration by TC39.
</p>

<p>
~UAは，［
`Window$I ／ `WorkerGlobalScope$I
］大域~obj %G を作成したときは、
`CacheStorage$I ~obj %C を作成して，それに %G を結付けるモノトスル。
この %G を指して，単に %C の
`大域~obj@
と称される。
◎
The user agent must create a CacheStorage object when a Window object or a WorkerGlobalScope object is created and associate it with that global object.
</p>

<p>
`CacheStorage$I ~objは、
その`大域~obj$の`環境~設定群~obj$†の`生成元$enVに属する`名前から~cacheへの~map$††を表現する。
いくつかの文書や~workerにまたがって、
同時に複数の `CacheStorage$I ~objが 同じ`名前から~cacheへの~map$を表現し得る†††。
◎
A CacheStorage object represents a name to cache map of its associated global object’s environment settings object’s origin. Multiple separate objects implementing the CacheStorage interface across documents and workers can all be associated with the same name to cache map simultaneously.
</p>

<p class="trans-note">【†
すなわち、
`関連な設定群~obj$。
】【††
すなわち、
`関連な名前から~cacheへの~map$。
】【†††
が、
各 `大域~obj$enVごとに， 1 個に限られる
— この~objを返す `caches$n 属性は [SameObject] なので。
】</p>

`CacheStorage^I0

			<section id="cache-storage-match">
<h4>5.5.1. `match(request, options)^m</h4>

<p>
`match(request, options)@m
~method手続きは：
◎
The match(request, options) method steps are:
</p>
<ol>
	<li>
%~cache名 ~LET %options[ "`MultiCacheQueryOptions^I1`cacheName$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%~cache名 ~NEQ ε
］：
◎
If options["cacheName"] exists, then:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Return a new promise promise and＼
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
run the following substeps in parallel:
</p>
				<ol>
					<li>
%結果 ~LET `undefined^jv
◎
↓</li>
					<li>
%~cache ~LET コレに`関連な名前から~cacheへの~map$[ %~cache名 ] ]
◎
↓</li>
					<li>
~IF［
%~cache ~NEQ ε
］
⇒
%結果 ~SET %~cache 【を表現する（新たな？） `Cache$I ~obj】上で `Cache^I1`match(request, options)$m1 ~method手続きを遂行する
◎
For each cacheName → cache of the relevant name to cache map:
• If options["cacheName"] matches cacheName, then:
•• Resolve promise with the result of running the algorithm specified in match(request, options) method of Cache interface with request and options (providing cache as thisArgument to the \[[Call]] internal method of match(request, options).)
• Abort these steps.
</li>
					<li>
`~promiseを解決する$( %~promise, %結果 )
◎
Resolve promise with undefined.
</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
↑</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Else:
</p>
		<ol>
			<li>
%~promise ~LET `解決される~promise$( `undefined^jv )
◎
Let promise be a promise resolved with undefined.
</li>
			<li>
<p>
コレに`関連な名前から~cacheへの~map$を成す
~EACH( %~cache名 → %~cache )
に対し
⇒
%~promise ~SET `~promiseに反応する$( %~promise )
— 次を与える下で：
◎
For each cacheName → cache of the relevant name to cache map:
• Set promise to the result of reacting to itself with＼
</p>
				<ul>
					<li class="algo">
<p>
`充足~手続き^i は、
所与の ( %応答 ) に対し：
◎
a fulfillment handler that, when called with argument response, performs the following substeps:
</p>
						<ol>
							<li>
~IF［
%応答 ~NEQ `undefined^jv
］
⇒
~RET %応答
◎
If response is not undefined, return response.
</li>
							<li>
~RET
%~cache 上で `Cache^I1`match(request, options)$m1 ~method手続きを遂行する
◎
Return the result of running the algorithm specified in match(request, options) method of Cache interface with request and options as the arguments (providing cache as thisArgument to the \[[Call]] internal method of match(request, options).)
</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="cache-storage-has">
<h4>5.5.2. `has(cacheName)^m</h4>

<p>
`has(cacheName)@m
~method手続きは：
◎
The has(cacheName) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
`~promiseを解決する$( %~promise, 次の結果 )
⇒
~IS［
コレに`関連な名前から~cacheへの~map$[ %cacheName ] ~NEQ ε
］
◎
For each key → value of the relevant name to cache map:
• If cacheName matches key, resolve promise with true and abort these steps.
◎
Resolve promise with false.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="cache-storage-open">
<h4>5.5.3. `open(cacheName)^m</h4>

<p>
`open(cacheName)@m
~method手続きは：
◎
The open(cacheName) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>

<div>
		<ol>
			<li>
%~cache ~LET コレに`関連な名前から~cacheへの~map$[ %cacheName ]
</li>
			<li>
<p>
~IF［
%~cache ~EQ ε
］：
</p>
				<ol>
					<li>
%~cache ~SET 新たな`要請~応答~list$
</li>
					<li>
コレに`関連な名前から~cacheへの~map$[ %cacheName ] ~SET %~cache
⇒
~IF［
この~cache書込n演算は、
是認されている~quota上限を超過することにより失敗した
］
⇒＃
`~promiseを却下する$( %~promise, `QuotaExceededError$E 例外 )；
~RET
</li>
				</ol>
			</li>
			<li>
`~promiseを解決する$( %~promise, %~cache を表現する`新たな~obj$( `Cache$I ) )
</li>
		</ol>
◎
For each key → value of the relevant name to cache map:
• If cacheName matches key, then:
•• Resolve promise with a new Cache object that represents value.
•• Abort these steps.
• Let cache be a new request response list.
• Set the relevant name to cache map[cacheName] to cache. If this cache write operation failed due to exceeding the granted quota limit, reject promise with a "QuotaExceededError" DOMException and abort these steps.
• Resolve promise with a new Cache object that represents cache.
</div>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="cache-storage-delete">
<h4>5.5.4. `delete(cacheName)^m</h4>

<p>
`delete(cacheName)@m
~method手続きは：
◎
The delete(cacheName) method steps are:
</p>
<ol>
	<li>
%~promise ~LET コレ上で `has(cacheName)$m ~method手続きを遂行する
◎
Let promise be the result of running the algorithm specified in has(cacheName) method with cacheName.
</li>
	<li>
<p>
~RET `~promiseに反応する$( %~promise )
— `充足~手続き^i として次を与える下で：
◎
Return the result of reacting to promise with a fulfillment handler that,＼
</p>

<div class="algo">
<p>
手続きは、
所与の ( %~cacheは存在するか ) に対し：
◎
when called with argument cacheExists, performs the following substeps:
</p>
		<ol>
			<li>
~IF［
%~cacheは存在するか ~EQ ~F
］
⇒
~RET ~F
◎
If cacheExists is false, then:
• Return false.
</li>
			<li>
%~cache~job~promise ~LET `新たな~promise$
◎
Let cacheJobPromise be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
コレに`関連な名前から~cacheへの~map$[ %cacheName ] ~SET ε
◎
Remove the relevant name to cache map[cacheName].
</li>
					<li>
`~promiseを解決する$( %~cache~job~promise, ~T )
◎
Resolve cacheJobPromise with true.
</li>
				</ol>

<p class="note">注記：
この段~以降も、
既存の~DOM~obj
（すなわち，現在~参照されている
`Cache^I ／ `Request^I ／ `Response^I
~obj）
は機能し続けるべきである。
◎
Note: After this step, the existing DOM objects (i.e. the currently referenced Cache, Request, and Response objects) should remain functional.
</p>
			</li>
			<li>
~RET %~cache~job~promise
◎
Return cacheJobPromise.
</li>
		</ol>
</div>
	</li>
</ol>

			</section>
			<section id="cache-storage-keys">
<h4>5.5.5. `keys()^m</h4>

<p>
`keys()@m
~method手続きは：
◎
The keys() method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$ 
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
		<ol>
			<li>
<p>
%~cache~key群 ~LET コレに`関連な名前から~cacheへの~map$の`~key群$map
◎
Let cacheKeys be the result of getting the keys of the relevant name to cache map.
</p>

<p class="note">注記：
結果の`有順序~集合$における`~item$たちの順序は、
それらに対応する~entryが`名前から~cacheへの~map$に追加された順になる。
◎
Note: The items in the result ordered set are in the order that their corresponding entry was added to the name to cache map.
</p>
			</li>
			<li>
`~promiseを解決する$( %~promise, %~cache~key群 )
◎
Resolve promise with cacheKeys.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">6. ~securityの考慮点</h2>

		<section id="secure-context">
<h3 title="Secure Context">6.1. ~secureな文脈</h3>

<div class="p">
<p>
`~sw$の実行, および
`~sw~client$による次に挙げる行いは、
`~secureな文脈$enV内に限るモノトスル：
</p>
<ul>
	<li>
`~sw登録$を登録する
</li>
	<li>
`~sw登録$への~accessを取得する
</li>
	<li>
`~sw$への~accessを取得する
</li>
	<li>
他の`~sw$と~messageをやりとりする
</li>
	<li>
`~sw$により操作されるようになること
</li>
</ul>

◎
Service workers must execute in secure contexts. Service worker clients must also be secure contexts to register a service worker registration, to get access to the service worker registrations and the service workers, to do messaging with the service workers, and to be manipulated by the service workers.
</div>

<p class="note">注記：
これは実質的に、
`~sw$とその`~sw~client$は，~HTTPS越しに~hostする必要があることを意味する。
~UAは、
開発~目的に［
`localhost^c 
（ `要件＠~SECURE-CONTEXT#localhost$を見よ）,
`127.0.0.0/8^c ／
`::1/128^c
］を許容できる。
この制約の首な理由は、
`~secureでない文脈に結付けられる~risk＠~SECURE-CONTEXT#threat-risks$から利用者を保護することである。
◎
Note: This effectively means that service workers and their service worker clients need to be hosted over HTTPS. A user agent can allow localhost (see the requirements), 127.0.0.0/8, and ::1/128 for development purposes. The primary reason for this restriction is to protect users from the risks associated with insecure contexts.
</p>

		</section>
		<section id="content-security-policy">
<h3 title="Content Security Policy">6.2. ~CSP</h3>

<p>
~UAは、
`~swを走らす$とき，当の~swに送達されてきた`~script資源$swに次に挙げる~HTTP ~headerが伴われている場合は：
◎
Whenever a user agent invokes the Run Service Worker algorithm with a service worker serviceWorker:
</p>

<ul>
	<li>
`Content-Security-Policy$h
⇒
その値が与える施策を`施行-＠~CSP3#enforced$するモノトスル。
【！https://wicg.github.io/csp-next/scripting-policy.html#scripting-policy-pair-enforced】
◎
If serviceWorker’s script resource was delivered with a Content-Security-Policy HTTP header containing the value policy, the user agent must enforce policy for serviceWorker.
</li>
	<li>
`Content-Security-Policy-Report-Only$h
⇒
その値が与える施策を`監視-＠~CSP3#monitored$するモノトスル。
【！https://w3c.github.io/mediacapture-screen-share/#dfn-monitor$】
◎
If serviceWorker’s script resource was delivered with a Content-Security-Policy-Report-Only HTTP header containing the value policy, the user agent must monitor policy for serviceWorker.
</li>
</ul>

<p>
この制約の首な理由は、
~XSSなどの［
内容~注入に対する脆弱性が成す~~広範な~class
］を軽減するためである。
◎
The primary reason for this restriction is to mitigate a broad class of content injection vulnerabilities, such as cross-site scripting (XSS).
</p>

		</section>
		<section id="origin-relativity">
<h3 title="Origin Relativity">6.3. 生成元との相対性</h3>

			<section id="origin-restriction">
<h4 title="Origin restriction">6.3.1. 生成元~制約</h4>

◎非規範的

<p>
`~sw$は、
それを登録している`~sw~client$の`生成元$cl【！`生成元$enV】内で実行される。
その応用の大多数が遭遇することになる先進的な懸念として、
それが~CDNから~hostし得るかどうかがある。
~CDNは、
定義により，他所にある~serverであり、
他の`生成元$に属することが多い。
したがって、
`~sw$を~CDN上で~hostすることはできない。
が、
`importScripts()$n を介して資源を含ませることはできる。
この制約がある理由は、
`~sw$が，不良な動作者にも~~攻撃を永遠に引き伸ばす機会を与えるからである。
◎
A service worker executes in the registering service worker client’s origin. One of the advanced concerns that major applications would encounter is whether they can be hosted from a CDN. By definition, these are servers in other places, often on other origins. Therefore, service workers cannot be hosted on CDNs. But they can include resources via importScripts(). The reason for this restriction is that service workers create the opportunity for a bad actor to turn a bad day into a bad eternity.
</p>

			</section>
			<section id="importscripts">
<h4>6.3.2. `importScripts(urls)^n</h4>

<p>
`ServiceWorkerGlobalScope$I ~objの
`importScripts(urls)@n
~method手続きは
⇒
`~scriptを~worker大域~scopeの中へ~importする$( ↓ )
⇒＃
コレ,
%urls,
次に定義される（`~fetch~hookを遂行する~algo$を成す）手続き
◎
When the importScripts(urls) method is called on a ServiceWorkerGlobalScope object, the user agent must import scripts into worker global scope, given this ServiceWorkerGlobalScope object and urls, and with the following perform the fetch hook steps,＼
</p>

<div class="algo">
<p>
手続きは、
所与の
( `要請$ %要請, %~top-levelか )
に対し：
◎
given the request request:
</p>
<ol>
	<li>
%~sw ~LET %要請 の`~client$rqの`大域~obj$enVの`~sw$SWG
◎
Let serviceWorker be request’s client’s global object’s service worker.
</li>
	<li>
%~map ~LET %~sw の`~script資源~map$sw
◎
Let map be serviceWorker’s script resource map.
</li>
	<li>
%~URL ~LET %要請 の`~URL$rq
◎
Let url be request’s url.
</li>
	<li>
%応答 ~LET %~map[ %~URL ]
◎
↓</li>
	<li>
~IF［
%~sw の`状態$sw ~NIN { `parsed^l, `installing^l }
］
⇒
~RET ［
%応答 ~NEQ ε ならば %応答 ／
~ELSE_ `~network~error$
］
◎
If serviceWorker’s state is not "parsed" or "installing":
• Return map[url] if it exists and a network error otherwise.
</li>
	<li>
<p>
~IF［
%応答 ~NEQ ε
］：
◎
If map[url] exists:
</p>
		<ol>
			<li>
%~sw の`利用した~scriptの集合$swに %~URL を`付加する$set
◎
Append url to serviceWorker’s set of used scripts.
</li>
			<li>
~RET %応答
◎
Return map[url].
</li>
		</ol>
	</li>
	<li>
%登録 ~LET %~sw を`包含している~sw登録$sw
◎
Let registration be serviceWorker’s containing service worker registration.
</li>
	<li>
%要請 の`~sw~mode$rq ~SET `none^l
◎
Set request’s service-workers mode to "none".
</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
Set request’s cache mode to "no-cache" if any of the following are true:
</p>
		<ul>
			<li>
%登録 の`~cacheを介する更新~mode$swr ~EQ `none^l
◎
registration’s update via cache mode is "none".
</li>
			<li>
`現在の大域~obj$の`~importする~script用には~cacheを迂回するよう強制するか$SWG ~EQ ~T
◎
The current global object’s force bypass cache for import scripts flag is set.
</li>
			<li>
%登録 は`非新鮮$である
◎
registration is stale.
</li>
		</ul>
<p>
…ならば
⇒
%要請 の`~cache~mode$rq ~SET `no-cache^l
◎
↑</p>
	</li>
	<li>
%応答 ~SET %要請 を`~fetch$した結果
◎
Let response be the result of fetching request.
</li>
	<li>
~IF［
%応答 の`~cache状態$ ~NEQ `local^l 
］
⇒
%登録 の`最後の更新~検査-時刻$swr ~SET 現在の時刻
◎
If response’s cache state is not "local", set registration’s last update check time to the current time.
</li>
	<li>
~IF［
%応答 の`安全でない応答$は`不良な~import~script応答$である
］
⇒
~RET `~network~error$
◎
If response’s unsafe response is a bad import script response, then return a network error.
</li>
	<li>
%~map[ %~URL ] ~SET %応答
◎
Set map[url] to response.
</li>
	<li>
%~sw の`利用した~scriptの集合$swに %~URL を`付加する$set
◎
Append url to serviceWorker’s set of used scripts.
</li>
	<li>
%~sw の`古典~scriptは~import済みか$sw ~SET ~T
◎
Set serviceWorker’s classic scripts imported flag.
</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="cross-origin-resources">
<h3 title="Cross-Origin Resources and CORS">6.4. 非同一-生成元に属する資源と~CORS</h3>

◎非規範的

<p>
~appは、
~CDNや他の`生成元$enVから来た~itemを~cacheする傾向にある。
それらの多くは、［
`script^e ／ `img^e ／ `video^e ／ `link^e
］要素を利用して，直に要請する可能性もある。
この類の稼働時における協同は、
~offline時に壊れた場合，著しく制限されることになる。
同様に，適切な~CORS~headerが設定されているときは、
`生成元$enV外にある【すなわち同一-生成元でない】多様な資源を`~fetch$する可能性もある。
`~sw$は、［
`Cache$I が，生成元~外にある~itemを`~fetch$して~cacheできる
］ようにすることで，これを可能化する。
しかしながら，いくつかの制約も適用される：
◎
Applications tend to cache items that come from a CDN or other origin. It is possible to request many of them directly using &lt;script&gt;, &lt;img&gt;, &lt;video&gt; and &lt;link&gt; elements. It would be hugely limiting if this sort of runtime collaboration broke when offline. Similarly, it is possible to fetch many sorts of off-origin resources when appropriate CORS headers are set. Service workers enable this by allowing Caches to fetch and cache off-origin items. Some restrictions apply, however.＼
</p>

<ul>
	<li>
先ず，［
所与の資源~用に `Cache$I 内で管理され, 格納される `Response$I ~obj
］に対応する`応答$Rsは、
同一-生成元に属する資源に対しては`基本~絞込み応答$になる一方で，生成元~外にある資源に対しては［
`~CORS絞込み応答$ ／ `不透明な絞込み応答$
］になる。
◎
First, unlike same-origin resources which are managed in the Cache as Response objects whose corresponding responses are basic filtered response, the objects stored are Response objects whose corresponding responses are either CORS filtered responses or opaque filtered responses.＼
</li>
	<li>
次に，生成元~外にある資源~用の `Response$I ~objは、
同一-生成元に属する資源~用のそれと同じ方式で
%event . `respondWith()$n
~methodに渡せるが，そのような~objを~program的に作成することはできない。
◎
They can be passed to event.respondWith(r) method in the same manner as the Response objects whose corresponding responses are basic filtered responses, but cannot be meaningfully created programmatically.＼
</li>
</ul>

<p>
これらの制限は、
~platformの~security不変則を保全するために必要yである。
`Cache$I にそれらを格納できるようにすることにより、
ほとんどの事例では，~appを改築し直さずに済むようになる。
◎
These limitations are necessary to preserve the security invariants of the platform. Allowing Caches to store them allows applications to avoid re-architecting in most cases.
</p>

		</section>
		<section id="path-restriction">
<h3 title="Path restriction">6.5. ~path制約</h3>

◎非規範的

<p>
`生成元~制約＠#origin-restriction$に加えて、
~swは，~sw~scriptの`~path$urlにより制約される。
例えば，
`https://~example-bob/sw.js^c
にある~sw~scriptは、
`~scope~URL$swr
`https://~example-bob/^c
用には登録できるが，~scope［
`https://www.example.com/^c ／
`https://~example-alice/^c
］用には登録できない。
これは、
同じ生成元に属するが互いに別々な~directory内に複数~利用者の内容を~hostする~site用に，いくぶんの保護を供する。
しかしながら，この~path制約は、
硬い~security境界とは見なされない
— それを成すのは生成元に限られる。
~siteは、
適切になるならば，［
~siteを成す各区分に、
異なる生成元を利用して，~secureに隔離する
］ことが奨励される。
◎
In addition to the origin restriction, service workers are restricted by the path of the service worker script. For example, a service worker script at https://www.example.com/~bob/sw.js can be registered for the scope url https://www.example.com/~bob/ but not for the scope https://www.example.com/ or https://www.example.com/~alice/. This provides some protection for sites that host multiple-user content in separated directories on the same origin. However, the path restriction is not considered a hard security boundary, as only origins are. Sites are encouraged to use different origins to securely isolate segments of the site if appropriate.
</p>

<p>
~serverは、
~sw~scriptに対し `Service-Worker-Allowed$h ~headerを設定することにより，この~path制約を除去できる。
◎
Servers can remove the path restriction by setting a Service-Worker-Allowed header on the service worker script.
</p>

		</section>
		<section id="script-request">
<h3 title="Service worker script request">6.6. ~sw~script要請</h3>

◎非規範的

<p>
~site上の~swの悪意的な登録に抗して，更に防御するため、
この仕様は次を要求する：
◎
To further defend against malicious registration of a service worker on a site, this specification requires that:
</p>

<ul>
	<li>
~sw~script要請には、
`Service-Worker$h ~headerを伴わせること。
◎
The Service-Worker header is present on service worker script requests, and
</li>
	<li>
~sw~scriptを~serveするときは、
`~JS~MIME型$を伴わせること。
◎
Service worker scripts are served with a JavaScript MIME type.
</li>
</ul>

		</section>
		<section id="implementer-concerns">
<h3 title="Implementer Concerns">6.7. 実装者~向けの懸念点</h3>

◎非規範的

<p>
実装者は、
次に留意しておくことが奨励される：
◎
The implementers are encouraged to note:
</p>

<ul>
	<li>
`~sw$を介して~pluginを読込むベキでない。
~pluginは，自前の~URLから~security生成元を取得することもあり、
埋込んでいる`~sw$はそれを取扱えないので。
この理由から，`~fetchを取扱う$~algoは、［
`embed^e ／ `object^e
］による要請に対しては，［
`fetch$et ~eventを配送することなく，即時に~networkへ~fallbackする
］ようにする。
◎
Plug-ins should not load via service workers. As plug-ins may get their security origins from their own urls, the embedding service worker cannot handle it. For this reason, the Handle Fetch algorithm makes &lt;embed&gt; and &lt;object&gt; requests immediately fallback to the network without dispatching fetch event.
</li>
	<li>
旧来の~network用~stack~codeの一部は、
`~sw$との相互作用における細分化を解するため，注意深く聴取する必要があるかもしれない。
◎
Some of the legacy networking stack code may need to be carefully audited to understand the ramifications of interactions with service workers.
</li>
</ul>

		</section>
		<section id="privacy">
<h3 title="Privacy">6.8. ~privacy</h3>

<p>
`~sw$は、
次を含む新たな持続的~storage特能を導入する
⇒＃
（`~sw登録$とその`~sw$用の）`登録~map$,
（~cache用の）`要請~応答~list$と`名前から~cacheへの~map$,
（~script資源~用の）`~script資源~map$sw
◎
Service workers introduce new persistent storage features including registration map (for service worker registrations and their service workers), request response list and name to cache map (for caches), and script resource map (for script resources).＼
</p>

<p>
`追跡し放題になり得る脅威＠#biblio-unsanctioned-tracking$から利用者を保護するため、
これらの持続的~storageは，利用者が~clearするよう意図したときは~clearされるベキであり、
また，既存の利用者-制御
— 既存の持続的~storageをすべて一掃するなど —
と相互運用できるよう保守されるベキである。
◎
In order to protect users from any potential unsanctioned tracking threat, these persistent storages should be cleared when users intend to clear them and should maintain and interoperate with existing user controls e.g. purging all existing persistent storages.
</p>

		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">7. 拡張能</h2>

<p>
他の仕様は、
~sw仕様を拡張できる。
◎
Service Workers specification is extensible from other specifications.
</p>

		<section id="extension-to-service-worker-registration">
<h3 title="Define API bound to Service Worker Registration">7.1. ~sw登録に束縛される~APIを定義する</h3>

<p>
仕様は、
`ServiceWorkerRegistration$I ~interfaceの`部分的~interface$定義を利用して，そこに仕様に特有な属性や~methodを定義して，`~sw登録$に束ねられる~APIを定義してもヨイ：
◎
Specifications may define an API tied to a service worker registration by using partial interface definition to the ServiceWorkerRegistration interface where it may define the specification specific attributes and methods:
</p>

<pre class="example idl">
partial interface ServiceWorkerRegistration {
  /* <span class="comment">
~API名前空間を定義する例：
◎
e.g. define an API namespace
</span> */
  readonly attribute APISpaceType APISpace;
  /* <span class="comment">
~methodを定義する例：
◎
e.g. define a method
</span> */
  Promise&lt;T&gt; methodName(/* <span class="comment">
引数~list
◎
list of arguments
</span> */);
};
</pre>

		</section>
		<section id="extension-to-extendable-event">
<h3 title="Define Functional Event">7.2. 機能的~eventを定義する</h3>

<p>
各~仕様は、
`ExtendableEvent$I ~interfaceを拡張することにより，`機能的~event$を定義してもヨイ。
◎
Specifications may define a functional event by extending ExtendableEvent interface:
</p>

<pre class="example idl">
/* <span class="comment">
`FunctionalEvent^I ~interfaceを定義する例：
◎
e.g. define FunctionalEvent interface
</span> */
interface FunctionalEvent : ExtendableEvent {
  /* <span class="comment">
機能的~eventの自前の属性や~methodを追加する
◎
add a functional event’s own attributes and methods
</span> */
};
</pre>

		</section>
		<section id="extension-to-service-worker-global-scope">
<h3 title="Define Event Handler">7.3. ~event~handlerを定義する</h3>

<p>
各~仕様は、
`ServiceWorkerGlobalScope$I ~interface用の`部分的~interface$定義を利用して，対応している`機能的~event$用に~event~handler属性を定義してもヨイ：
◎
Specifications may define an event handler attribute for the corresponding functional event using partial interface definition to the ServiceWorkerGlobalScope interface:
</p>

<pre class="example idl">
partial interface ServiceWorkerGlobalScope {
  attribute EventHandler onfunctionalevent;
};
</pre>

		</section>
		<section id="firing-functional-events">
<h3 title="Firing Functional Events">7.4. 機能的~eventの発火-法</h3>

<p>
各~仕様は、
`~sw登録$にて`作動中な~worker$swrに向けて `機能的~event$を配送するよう要請するときは，`機能的~eventを発火する$べきである。
◎
To request a functional event dispatch to the active worker of a service worker registration, specifications should invoke Fire Functional Event.
</p>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Appendix A: Algorithms">各種~algo</h2>

<p>
以下の定義は、
この仕様~全体を通して利用される，~UAの内部~data構造である。
◎
The following definitions are the user agent’s internal data structures used throughout the specification.
</p>

<div class="p">
<p>
`登録~map@
は、
`有順序~map$である
— それを成す各`~entry$mapの：
</p>
<ul>
	<li>
~keyは、
( `~storage~key$, ~URL )
が成す`~tuple$であり，~URLは次の結果として与えられる
⇒
`~URLを直列化する$( ある`~sw登録$の`~scope~URL$swr ) )
</li>
	<li>
値は、
ある`~sw登録$を与える。
</li>
</ul>
◎
A registration map is an ordered map where the keys are (storage key, serialized scope urls) and the values are service worker registrations.
</div>

<p>
`~job@
は、
`~sw登録$を［
登録- ／ 更新- ／ 未登録に
］する要請の抽象-化である。
◎
A job is an abstraction of one of register, update, and unregister request for a service worker registration.
</p>

<p>
各`~job$には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`~job種別@job
⇒
`登録する^i ／
`更新する^i ／
`未登録にする^i
◎
A job has a job type, which is one of register, update, and unregister.
</li>
	<li>
`~storage~key@job
⇒
`~storage~key$
◎
A job has a storage key (a storage key).
</li>
	<li>
`~scope~URL@job
⇒
`~URL$
◎
A job has a scope url (a URL).
</li>
	<li>
`~script~URL@job
⇒
`~URL$
◎
A job has a script url (a URL).
</li>
	<li>
`~worker種別@job
⇒
`classic^l ／ `module^l
◎
A job has a worker type ("classic" or "module").
</li>
	<li>
`~cacheを介する更新~mode@job
⇒
`imports^l ／ `all^l ／ `none^l
◎
A job has an update via cache mode, which is "imports", "all", or "none".
</li>
	<li>
`~client@job
⇒
`~sw~client$
— 初期~時は ~NULL とする。
◎
A job has a client (a service worker client). It is initially null.
</li>
	<li>
`~referrer@job
⇒
`~URL$ ／ ~NULL
◎
A job has a referrer (a URL or null).
</li>
	<li>
`~job~promise@job
⇒
`~promise$
— 初期~時は ~NULL とする。
◎
A job has a job promise (a promise). It is initially null.
</li>
	<li>
`包含している~job~queue@job
⇒
`~job~queue$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
A job has a containing job queue (a job queue or null). It is initially null.
</li>
	<li>
`等価~job~list@job
⇒
`~job$たちが成す~list
— 初期~時は新たな~listとする。
◎
A job has a list of equivalent jobs (a list of jobs). It is initially the empty list.
</li>
	<li>
`~cacheを迂回するよう強制するか@job
⇒
真偽値
— 初期~時は ~F とする。
◎
A job has a force bypass cache flag. It is initially unset.
</li>
</ul>

<p>
2 つの `~job$が
`等価である@job
とは、
~AND↓ が満たされることをいう：
◎
Two jobs are equivalent when＼
<ul>
	<li>
互いの`~job種別$jobは同じ
◎
their job type is the same and:
</li>
	<li>
<p>
`~job種別$jobに応じて，次が満たされる：
</p>
		<dl class="switch">
			<dt>`登録する^i</dt>
			<dt>`更新する^i</dt>
			<dd>
互いの［
次に挙げるもの
］は，いずれも同じ
⇒＃
`~scope~URL$job,
`~script~URL$job,
`~worker種別$job,
`~cacheを介する更新~mode$job
</dd>

			<dt>`未登録にする^i</dt>
			<dd>
互いの`~scope~URL$jobは同じ
</dd>
		</dl>
◎
For register and update jobs, their scope url, script url, worker type, and update via cache mode are the same.
◎
For unregister jobs, their scope url is the same.
</li>
</ul>

<p>
`~job~queue@
は，~thread安全な`~queue$であり、
複数の同時並行な`~job$を互いに同期するために利用される。
`~job~queue$は，初期~時は空であり、
それを成す各`~item$は，ある`~job$を与える。
◎
A job queue is a thread safe queue used to synchronize the set of concurrent jobs. The job queue contains jobs as its items. A job queue is initially empty.
</p>

<p>
`~scopeから~job~queueへの~map@
は、
`有順序~map$であり，それを成す各`~entry$mapは［
`~URLを直列化する$( `~scope~URL$swr ) → `~job~queue$
］を与える。
◎
A scope to job queue map is an ordered map where the keys are scope urls, serialized, and the values are job queues.
</p>

<p>
`不良な~import~script応答@
とは、
~OR↓ を満たす`応答$である：
◎
A bad import script response is a response for which any of the following conditions are met:
</p>
<ul>
	<li>
応答の`種別$rs ~EQ `error^l
◎
response’s type is "error"
</li>
	<li>
応答の`状態s$rsは`~ok状態s$でない
◎
response’s status is not an ok status
</li>
	<li>
<p>
次の結果は`~JS~MIME型$でない
⇒
`~header~listから~MIME型を抽出する$( 応答の`~header~list$rs )
◎
The result of extracting a MIME type from response’s header list is not a JavaScript MIME type
</p>

<p class="note">注記：
この定義と［
`~workerが~importした古典~scriptを~fetchする$
］とが同期cするよう保つ。
◎
Note: Keep this definition in sync with fetch a classic worker-imported script.
</p>
	</li>
</ul>

<p>
`競走~結果@
は、
次に挙げる~itemが成す`~tuple$である：
◎
A race result is a tuple of a routed response and used route.
</p>
<ol>
	<li>
`~route済み応答@rr
⇒
ある`応答$
◎
A race result has an associated routed response (a response).
</li>
	<li>
`利用される~route@rr
⇒
ある `RouterSourceEnum$I
◎
A race result has an associated used route (a RouterSourceEnum).
</li>
</ol>

		<section id="create-job-algorithm">
<h3 title="Create Job">`~jobを作成する@</h3>

<p>
~algoは、
所与の
⇒＃
`~job種別$job %~job種別,
`~storage~key$ %~storage~key,
`~URL$ %~scope~URL,
`~URL$ %~script~URL,
`~promise$ %~promise,
`~sw~client$ %~client
◎終
に対し，ある`~job$を返す：
◎
Input
• jobType, a job type
• storage key, a storage key
• scopeURL, a URL
• scriptURL, a URL
• promise, a promise
• client, a service worker client
◎
Output
• job, a job
</p>

<ol>
	<li>
%~job ~LET 新たな`~job$
◎
Let job be a new job.
</li>
	<li>
%~job の
⇒＃
`~job種別$job ~SET %~job種別,
`~storage~key$job ~SET %~storage~key,
`~scope~URL$job ~SET %~scope~URL,
`~script~URL$job ~SET %~script~URL,
`~job~promise$job ~SET %~promise,
`~client$job ~SET %~client
◎
Set job’s job type to jobType.
◎
Set job’s storage key to storage key.
◎
Set job’s scope url to scopeURL.
◎
Set job’s script url to scriptURL.
◎
Set job’s job promise to promise.
◎
Set job’s client to client.
</li>
	<li>
~IF［
%~client ~NEQ ~NULL
］
⇒
%~job の`~referrer$job ~SET %~client の`作成時の~URL$enV
◎
If client is not null, set job’s referrer to client’s creation URL.
</li>
	<li>
~RET %~job
◎
Return job.
</li>
</ol>

		</section>
		<section id="schedule-job-algorithm">
<h3 title="Schedule Job">`~jobを~scheduleする@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job
◎終
に対し：
◎
Input
• job, a job
◎
Output
• none
</p>
<ol>
	<li>
%~job~queue ~LET ~NULL
◎
Let jobQueue be null.
</li>
	<li>
%~job~scope ~LET `~URLを直列化する$( %~job の`~scope~URL$job )
◎
Let jobScope be job’s scope url, serialized.
</li>
	<li>
~IF［
`~scopeから~job~queueへの~map$[ %~job~scope ] ~EQ ε
］
⇒
`~scopeから~job~queueへの~map$[ %~job~scope ] ~SET 新たな`~job~queue$
◎
If scope to job queue map[jobScope] does not exist, set scope to job queue map[jobScope] to a new job queue.
</li>
	<li>
%~job~queue ~SET `~scopeから~job~queueへの~map$[ %~job~scope ]
◎
Set jobQueue to scope to job queue map[jobScope].
</li>
	<li>
<p>
~IF［
%~job~queue は`空$である
］：
◎
If jobQueue is empty, then:
</p>
		<ol>
			<li>
%~job を`包含している~job~queue$job ~SET %~job~queue
◎
Set job’s containing job queue to jobQueue, and＼
</li>
			<li>
%~job~queue に %~job を`~enqueueする$
◎
enqueue job to jobQueue.
</li>
			<li>
`~jobを走らす$( %~job~queue )
◎
Invoke Run Job with jobQueue.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Else:
</p>
		<ol>
			<li>
%最後の~job ~LET %~job~queue の最後の`~item$
【！＊the element at the back of】
◎
Let lastJob be the element at the back of jobQueue.
</li>
			<li>
~IF［
`等価である$job( %~job, %最後の~job )
］~AND［
%最後の~job の`~job~promise$jobはまだ決着してない
］
⇒
%最後の~job の`等価~job~list$jobに %~job を付加する
◎
If job is equivalent to lastJob and lastJob’s job promise has not settled, append job to lastJob’s list of equivalent jobs.
</li>
			<li>
~ELSE
⇒＃
%~job を`包含している~job~queue$job ~SET %~job~queue；
%~job~queue に %~job を`~enqueueする$
◎
Else, set job’s containing job queue to jobQueue, and enqueue job to jobQueue.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="run-job-algorithm">
<h3 title="Run Job">`~jobを走らす@</h3>

<p>
~algoは、
所与の
⇒＃
`~job~queue$ %~job~queue
◎終
に対し：
◎
Input
• jobQueue, a job queue
◎
Output
• none
</p>
<ol>
	<li>
~Assert：
%~job~queue は`空$でない
◎
Assert: jobQueue is not empty.
</li>
	<li>
<p>
`~taskを~queueする$(【どの~task~sourceか指定されていない】, 次の手続き )
◎
Queue a task to run＼
</p>
<div class="algo">
<p>
手続きは：
◎
these steps:
</p>
		<ol>
			<li>
%~job ~LET %~job~queue の最初の`~item$
◎
Let job be the first item in jobQueue.
</li>
			<li>
%~job種別 ~LET %~job の`~job種別$job
◎
↓</li>
			<li class="algo">
<p>
この段は`並列的$に走らす
⇒
%~job種別 に応じて：
</p>
					<ul class="switch">
						<li>
`登録する^i
⇒
`登録する$( %~job )
</li>

						<li>
`更新する^i
⇒
`更新する$( %~job )
</li>

						<li>
`未登録にする^i
⇒
`未登録にする$( %~job )
</li>
					</ul>

<p class="note">注記：
%~job の［
登録-／更新-
］に対しては、
~UAは，［
%~job を走らす~task
］を~queueするのを［［
%~job を起動した文書
］に向けて， `DOMContentLoaded$I ~eventを配送した後
］まで遅延する。
</p>

◎
If job’s job type is register, run Register with job in parallel.
◎
Else if job’s job type is update, run Update with job in parallel.
◎
Note: For a register job and an update job, the user agent delays queuing a task for running the job until after a DOMContentLoaded event has been dispatched to the document that initiated the job.
◎
Else if job’s job type is unregister, run Unregister with job in parallel.
</li>
		</ol>
</div>
	</li>
</ol>

		</section>
		<section id="finish-job-algorithm">
<h3 title="Finish Job">`~jobを完遂する@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job
◎終
に対し：
◎
Input
• job, a job
◎
Output
• none
</p>
<ol>
	<li>
%~job~queue ~LET %~job を`包含している~job~queue$job
◎
Let jobQueue be job’s containing job queue.
</li>
	<li>
~Assert：
%~job~queue の最初の`~item$ ~EQ %~job
◎
Assert: the first item in jobQueue is job.
</li>
	<li>
%~job~queue から`~dequeueする$
◎
Dequeue from jobQueue.
</li>
	<li>
~IF［
%~job~queue は`空$でない
］
⇒
`~jobを走らす$( %~job~queue )
◎
If jobQueue is not empty, invoke Run Job with jobQueue.
</li>
</ol>

		</section>
		<section id="resolve-job-promise-algorithm">
<h3 title="Resolve Job Promise">`~job~promiseを解決する@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job,
任意の値 %値
◎終
に対し：
◎
Input
• job, a job
• value, any
◎
Output
• none
</p>
<ol>
	<li class="algo">
<p>
%~job~promiseを内部的に解決する ~LET 所与の
( %入力~job )
に対し，次を走らす手続き：
</p>
		<ol>
			<li>
%~client ~LET %入力~job の`~client$job
</li>
			<li>
~IF［
%~client ~EQ ~NULL
］
⇒
~RET
</li>
			<li>
%O ~LET ε
</li>
			<li>
<p>
~IF［
%入力~job の`~job種別$job ~IN { `登録する^i, `更新する^i }
］：
</p>
				<ol>
					<li>
~Assert：
%値 は`~sw登録$である
</li>
					<li>
%O ~SET `~sw登録~objを取得する$( %値, %~client )
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%O ~SET %~client の`~realm$enV 内で %値 を表現する値
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~client の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
%O で %入力~job の`~job~promise$jobを解決する
</div>
			</li>
		</ol>

◎
↓</li>
	<li>
%~job~promiseを内部的に解決する( %~job )
◎
If job’s client is not null, queue a task, on job’s client’s responsible event loop using the DOM manipulation task source, to run the following substeps:
• Let convertedValue be null.
• If job’s job type is either register or update, set convertedValue to the result of getting the service worker registration object that represents value in job’s client.
• Else, set convertedValue to value, in job’s client’s Realm.
• Resolve job’s job promise with convertedValue.
</li>
	<li>
%~job の`等価~job~list$jobを成す
~EACH( %等価な~job )
に対し
⇒
%~job~promiseを内部的に解決する( %等価な~job )
◎
For each equivalentJob in job’s list of equivalent jobs:
• If equivalentJob’s client is null, continue to the next iteration of the loop.
• Queue a task, on equivalentJob’s client’s responsible event loop using the DOM manipulation task source, to run the following substeps:
•• Let convertedValue be null.
•• If equivalentJob’s job type is either register or update, set convertedValue to the result of getting the service worker registration object that represents value in equivalentJob’s client.
•• Else, set convertedValue to value, in equivalentJob’s client’s Realm.
•• Resolve equivalentJob’s job promise with convertedValue.
</li>
</ol>

		</section>
		<section id="reject-job-promise-algorithm">
<h3 title="Reject Job Promise">`~job~promiseを却下する@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job,
`新たな例外$を作成するために必要yな情報 %~error~data
◎終
に対し：
◎
Input
• job, a job
• errorData, the information necessary to create an exception
◎
Output
• none
</p>
<ol>
	<li class="algo">
<p>
%~job~promiseを内部的に却下する ~LET 所与の
( %入力~job )
に対し，次を走らす手続き：
</p>
		<ol>
			<li>
%~client ~LET %入力~job の`~client$job
</li>
			<li>
~IF［
%~client ~EQ ~NULL
］
⇒
~RET
</li>
			<li>
%例外 ~LET %~client の`~realm$enV内に作成される`新たな例外$( %~error~data )
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~client の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %入力~job の`~job~promise$job, %例外 )
</div>
			</li>
		</ol>
◎
↓</li>
	<li>
%~job~promiseを内部的に却下する( %~job )
◎
If job’s client is not null, queue a task, on job’s client’s responsible event loop using the DOM manipulation task source, to reject job’s job promise with a new exception with errorData, in job’s client’s Realm.
</li>
	<li>
%~job の`等価~job~list$jobを成す
~EACH( %等価な~job )
に対し
⇒
%~job~promiseを内部的に却下する( %等価な~job )
◎
For each equivalentJob in job’s list of equivalent jobs:
• If equivalentJob’s client is null, continue.
• Queue a task, on equivalentJob’s client’s responsible event loop using the DOM manipulation task source, to reject equivalentJob’s job promise with a new exception with errorData, in equivalentJob’s client’s Realm.
</li>
</ol>

		</section>
		<section id="start-register-algorithm">
<h3 title="Start Register">`登録を開始する@</h3>

<p>
~algoは、
所与の
⇒＃
［ `~URL$ ／ `失敗^i ／ ~NULL ］ %~scope~URL,
［ `~URL$ ／ `失敗^i ］ %~script~URL,
`~promise$ %~promise,
`~sw~client$ %~client,
`~URL$ %~referrer,
`~worker種別$job %~worker種別,
`~cacheを介する更新~mode$swr %~cacheを介する更新
◎終
に対し：
◎
Input
• scopeURL, a URL or failure or null
• scriptURL, a URL or failure
• promise, a promise
• client, a service worker client
• referrer, a URL
• workerType, a worker type
• updateViaCache, an update via cache mode
◎
Output
• none
</p>
<ol>
	<li>
~IF［
%~script~URL ~EQ `失敗^i
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError^E )；
~RET
◎
If scriptURL is failure, reject promise with a TypeError and abort these steps.
</li>
	<li>
<p>
%~script~URL の`素片$url ~SET ~NULL
◎
Set scriptURL’s fragment to null.
</p>

<p class="note">注記：
~UAは~scriptの~URLの`素片$urlは格納しない。
これは、
`素片$urlにより`~sw$を識別する効果は無いことを意味する。
◎
Note: The user agent does not store the fragment of the script’s url. This means that the fragment does not have an effect on identifying service workers.
</p>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%~script~URL の`~scheme$url ~NIN { `http^l , `https^l }
</li>
			<li>
%~script~URL の`~path$url内のある文字列は、
`~ASCII大小無視$で［
`%2f^l か `%5c^l
］を包含する
</li>
		</ul>
<p>
…ならば
⇒＃
`~promiseを却下する$( %~promise, `TypeError^E )；
~RET
</p>

◎
If scriptURL’s scheme is not one of "http" and "https", reject promise with a TypeError and abort these steps.
◎
If any of the strings in scriptURL’s path contains either ASCII case-insensitive "%2f" or ASCII case-insensitive "%5c", reject promise with a TypeError and abort these steps.
</li>
	<li>
<p>
~IF［
%~scope~URL ~EQ ~NULL
］
⇒
%~scope~URL ~SET `~URL構文解析する$( 文字列 `./^l , %~script~URL )
◎
If scopeURL is null, set scopeURL to the result of parsing the string "./" with scriptURL.
</p>

<p class="note">注記：
すなわち，既定では、
登録~用の~scope~URLは ~sw~scriptの所在に設定される。
◎
Note: The scope url for the registration is set to the location of the service worker script by default.
</p>
	</li>
	<li>
~IF［
%~scope~URL ~EQ `失敗^i
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError^E )；
~RET
◎
If scopeURL is failure, reject promise with a TypeError and abort these steps.
</li>
	<li>
<p>
%~scope~URL の`素片$url ~SET ~NULL
◎
Set scopeURL’s fragment to null.
</p>

<p class="note">注記：
~UAは %~scope~URL の`素片$urlは格納しない。
これは、
`素片$urlにより`~sw登録$を識別する効果は無いことを意味する。
◎
Note: The user agent does not store the fragment of the scope url. This means that the fragment does not have an effect on identifying service worker registrations.
</p>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%~scope~URL の`~scheme$url ~NIN { `http^l , `https^l }
</li>
			<li>
%~scope~URL の`~path$url内のある文字列は、
`~ASCII大小無視$で［
`%2f^l か `%5c^l 
］を包含する
</li>
		</ul>
<p>
…ならば
⇒＃
`~promiseを却下する$( %~promise, `TypeError^E )；
~RET
</p>

◎
If scopeURL’s scheme is not one of "http" and "https", reject promise with a TypeError and abort these steps.
◎
If any of the strings in scopeURL’s path contains either ASCII case-insensitive "%2f" or ASCII case-insensitive "%5c", reject promise with a TypeError and abort these steps.
</li>
	<li>
%~storage~key ~LET `~storage~keyを得する$( %~client )
◎
Let storage key be the result of running obtain a storage key given client.
</li>
	<li>
%~job ~LET `~jobを作成する$( ↓ )
⇒＃
`登録する^i,
%~storage~key,
%~scope~URL,
%~script~URL,
%~promise,
%~client
◎
Let job be the result of running Create Job with register, storage key, scopeURL, scriptURL, promise, and client.
</li>
	<li>
%~job の
⇒＃
`~worker種別$job ~SET %~worker種別,
`~cacheを介する更新~mode$job ~SET %~cacheを介する更新,
`~referrer$job ~SET %~referrer
◎
Set job’s worker type to workerType.
◎
Set job’s update via cache mode to updateViaCache.
◎
Set job’s referrer to referrer.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
</ol>

		</section>
		<section id="register-algorithm">
<h3 title="Register">`登録する@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job
◎終
に対し：
◎
Input
• job, a job
◎
Output
• none
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
`信用に価し得る生成元か？$( %~job の`~script~URL$jobの`生成元$url【！`生成元$enV】 ) ~EQ `価しない^i
</li>
			<li>
%~job の`~script~URL$jobの`生成元$url
~NEQ`生成元$sub
%~job の`~referrer$jobの`生成元$url
</li>
			<li>
%~job の`~scope~URL$jobの`生成元$url
~NEQ`生成元$sub
%~job の`~referrer$jobの`生成元$url
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
</li>
			<li>
`~jobを完遂する$( %~job )
</li>
			<li>
~RET
</li>
		</ol>
◎
If the result of running potentially trustworthy origin with the origin of job’s script url as the argument is Not Trusted, then:
• Invoke Reject Job Promise with job and "SecurityError" DOMException.
• Invoke Finish Job with job and abort these steps.
◎
If job’s script url’s origin and job’s referrer’s origin are not same origin, then:
• Invoke Reject Job Promise with job and "SecurityError" DOMException.
• Invoke Finish Job with job and abort these steps.
◎
If job’s scope url’s origin and job’s referrer’s origin are not same origin, then:
• Invoke Reject Job Promise with job and "SecurityError" DOMException.
• Invoke Finish Job with job and abort these steps.
</li>
	<li>
%登録 ~LET 
`登録を取得する$( %~job の`~storage~key$job, %~job の`~scope~URL$job )
◎
Let registration be the result of running Get Registration given job’s storage key and job’s scope url.
</li>
	<li>
<p>
~IF［
%登録 ~NEQ ~NULL
］：
◎
If registration is not null, then:
</p>
		<ol>
			<li>
%最新~worker ~LET 
`最新な~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running the Get Newest Worker algorithm passing registration as the argument.
</li>
			<li>
<p>
~IF［
%最新~worker ~NEQ ~NULL
］~AND［
( %~job の`~script~URL$job, %最新~worker の`~script~URL$sw )
は`同等な~URL$である
］~AND［
%~job の`~worker種別$job ~EQ %最新~worker の`種別$sw
］~AND［
%~job の`~cacheを介する更新~mode$job ~EQ %登録 の`~cacheを介する更新~mode$swr
］：
◎
If newestWorker is not null, job’s script url equals newestWorker’s script url, job’s worker type equals newestWorker’s type, and job’s update via cache mode’s value equals registration’s update via cache mode, then:
</p>
				<ol>
					<li>
`~job~promiseを解決する$( %~job, %登録 )
◎
Invoke Resolve Job Promise with job and registration.
</li>
					<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
					<li>
~RET
◎
abort these steps.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
`登録を設定する$( %~job の`~storage~key$job, %~job の`~scope~URL$job, %~job の`~cacheを介する更新~mode$job )
◎
Else:
• Invoke Set Registration algorithm with job’s storage key, job’s scope url, and job’s update via cache mode.
</li>
	<li>
`更新する$( %~job )
◎
Invoke Update algorithm passing job as the argument.
</li>
</ol>

		</section>
		<section id="update-algorithm">
<h3 title="Update">`更新する@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job
◎終
に対し：
◎
Input
• job, a job
◎
Output
• none
</p>
<ol>
	<li>
%登録 ~LET `登録を取得する$( %~job の`~storage~key$job, %~job の`~scope~URL$job )
◎
Let registration be the result of running Get Registration given job’s storage key and job’s scope url.
</li>
	<li>
<p>
~IF［
%登録 ~EQ ~NULL
］：
◎
If registration is null, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%最新~worker ~LET 
`最新な~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
</li>
	<li>
<p>
~IF［
%~job の`~job種別$job ~EQ `更新する^i
］~AND［
%最新~worker ~NEQ ~NULL
］~AND［
( %最新~worker の`~script~URL$sw, %~job の`~script~URL$job )
は`同等な~URL$でない
］：
◎
If job’s job type is update, and newestWorker is not null and its script url does not equal job’s script url, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%~URL ~LET `~URLを直列化する$( %~job の`~script~URL$job )
◎
↓</li>
	<li>
%資源を更新したか ~LET ~F
◎
Let hasUpdatedResources be false.
</li>
	<li>
%更新-済み資源~map ~LET 新たな`有順序~map$
（この~mapは、
`~script資源~map$swを与えることになる）
◎
Let updatedResourceMap be an ordered map where the keys are URLs and the values are responses.
</li>
	<li>
<p class="trans-note">【
この訳では、
`HTML$r の更新に整合させるため，
原文における この段の中の一部の記述を改めている
— それは、
`この仕様に期待される更新＠https://github.com/w3c/ServiceWorker/pull/1658$に基づく
（処理~modelに対する本質的な変更は無い）
（特に、［
%完了-時の手続き,
%~fetchを遂行する
］を導入するとともに，
原文にて `Asynchronously complete^en （ “非同期に完了する” ）と記された箇所を
%~custom~fetch応答の処理n（および ~RET）に置換している）。
】</p>

<p>
%~job の`~worker種別$jobに応じて：
◎
Switching on job’s worker type, run these substeps with the following options:
</p>
		<dl class="switch">
			<dt>`classic^l</dt>
			<dd>
`~worker用~古典~scriptを~fetchする$( ↓ )
⇒＃
%~URL,
%~job の`~client$job,
`serviceworker^l,
設定群†
%完了-時の手続き（以下に定義される）,
%~fetchを遂行する（以下に定義される）
◎
Fetch a classic worker script given job’s serialized script url, job’s client, "serviceworker", and the to-be-created environment settings object for this service worker.
</dd>

			<dt>`module^l</dt>
			<dd>
`~module~worker~script~graphを~fetchする$( ↓ )
⇒＃
%~URL,
%~job の`~client$job,
`serviceworker^l,
`omit^l,
設定群†
%完了-時の手続き（以下に定義される）,
%~fetchを遂行する（以下に定義される）【この引数は不要？】
◎
Fetch a module worker script graph given job’s serialized script url, job’s client, "serviceworker", "omit", and the to-be-created environment settings object for this service worker.
</dd>
		</dl>

<p>†
上に与えた設定群は、
この~sw用に【必要になった時点で】`作成されることになる^em`環境~設定群~obj$を与える。
【例えば~fetchに失敗した場合、作成されないであろう。】
◎
↑</p>

<p class="issue">
具象的な`環境~設定群~obj$ではなく，作成されることになる`環境~設定群~obj$を利用しているのは、
~swの処理~modelが，他の`~web~worker$の処理~modelに比較して，独特であることに因る。
~HTML標準の~scriptを~fetchする~algoは、
元々は他の`~web~worker$用に設計されており，実行~環境の`環境~設定群~obj$を要求するが、
~swは，~scriptを
— 後で，`~swを走らす$~algoを通して複数回~走らす前に —
`更新する$~algo内で別々に~fetchするので。
◎
Using the to-be-created environment settings object rather than a concrete environment settings object. This is used due to the unique processing model of service workers compared to the processing model of other web workers. The script fetching algorithms of HTML standard originally designed for other web workers require an environment settings object of the execution environment, but service workers fetch a script separately in the Update algorithm before the script later runs multiple times through the Run Service Worker algorithm.
</p>

<p class="issue">
~HTMLにおける［
`~worker用~古典~scriptを~fetchする$／
`~module~worker~script~graphを~fetchする$
］~algoは、
%~job の`~client$jobを引数にとる。
%~job の`~client$jobは、
`~soft更新する$~algoから渡されるときは ~NULL になる。
◎
The fetch a classic worker script algorithm and the fetch a module worker script graph algorithm in HTML take job’s client as an argument. job’s client is null when passed from the Soft Update algorithm.
</p>

<div class="algo">
<p>
%~fetchを遂行する は、
`~fetch~hookを遂行する~algo$であり，
所与の
( %要請, %~top-levelか, %~custom~fetch応答の処理n )
に対し，次を走らす：
【！In both cases, let performFetch be the following asynchronous perform the fetch hook given request, isTopLevel and processCustomFetchResponse:】
◎
To perform the fetch hook given request, run the following steps:
</p>
		<ol>
			<li>
<p>
%要請 の`~header~list$rq に`~headerを付加する$(
( `Service-Worker^h, `script^bl )
)
◎
Append `Service-Worker`/`script` to request’s header list.
</p>

<p class="note">注記：
`§ 拡張された~HTTP~header＠#extended-http-headers$
における `Service-Worker^h ~headerの定義を見よ。
◎
Note: See the definition of the Service-Worker header in Appendix B: Extended HTTP headers.
</p>
			</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
Set request’s cache mode to "no-cache" if any of the following are true:
</p>
				<ul>
					<li>
%登録 の`~cacheを介する更新~mode$swr ~NEQ `all^l
◎
registration’s update via cache mode is not "all".
</li>
					<li>
%~job の`~cacheを迂回するよう強制するか$job ~EQ ~T
◎
job’s force bypass cache flag is set.
</li>
					<li>
［
%最新~worker ~NEQ ~NULL
］~AND［
%登録 は`非新鮮$である
］
◎
newestWorker is not null and registration is stale.
</li>
			</ul>
<p>
…ならば
⇒
%要請 の`~cache~mode$rq ~SET `no-cache^l
◎
↑</p>

<p class="note">注記：
［
~cache~mode ~NEQ `no-cache^l 
］の場合でも、
~UAは，［
~browser~cacheを迂回するべきかどうか
］を決定するため［
~network層における `Cache-Control$h ~headerの `max-age^dir 値
］を順守する。
◎
Note: Even if the cache mode is not set to "no-cache", the user agent obeys Cache-Control header’s max-age value in the network layer to determine if it should bypass the browser cache.
</p>
			</li>
			<li>
%要請 の`~sw~mode$rq ~SET `none^l
◎
Set request’s service-workers mode to "none".
</li>
			<li>
<p>
~IF［
%~top-levelか ~EQ ~F
］：
</p>
				<ol>
					<li>
~RET %要請 を`~fetchする$
— 次を与える下で
⇒
`応答の本体を消費する処理n^i ~SET %~custom~fetch応答の処理n
</li>
					<li>；
~RET
</li>
				</ol>
【！If isTopLevel is false fetch request with processCustomFetchResponse as processResponseConsumeBody, and abort these steps.】
◎
If the isTopLevel flag is unset, then return the result of fetching request.
</li>
			<li>
%要請 の`~redirect~mode$rq ~SET `error^l
◎
Set request’s redirect mode to "error".
</li>
			<li>
<p>
%要請 を`~fetchする$
— 次を与える下で
⇒
`応答の処理n^i ~SET 次に定義する手続き
◎
Fetch request, and asynchronously wait to run the remaining steps as part of fetch’s processResponse for the response response.
</p>

<div class="algo">
<p>
手続きは、
所与の
( `応答$ %応答 )
に対し：
◎
↑</p>
				<ol>
					<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Extract a MIME type from the response’s header list.＼
</li>
					<li>
<p>
~IF［
%~MIME型 は`~JS~MIME型$でない【！不要：(ignoring parameters)】
］：
◎
If this MIME type (ignoring parameters) is not a JavaScript MIME type, then:
</p>
						<ol>
							<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
◎
Invoke Reject Job Promise with job and "SecurityError" DOMException.
</li>
							<li>
%~custom~fetch応答の処理n( `~network~error$ )
【！Invoke processCustomFetchResponse with a network error and abort these steps.】
◎
Asynchronously complete these steps with a network error.
</li>
							<li>
~RET
</li>
						</ol>
					</li>
					<li>
<p>
%許容される~sw ~LET 
`~header~listから値を抽出する$( %応答 の`~header~list$rs, `Service-Worker-Allowed^h )
◎
Let serviceWorkerAllowed be the result of extracting header list values given `Service-Worker-Allowed` and response’s header list.
</p>

<p class="note">注記：
`§ 拡張された~HTTP~header＠#extended-http-headers$
における `Service-Worker-Allowed$h ~headerの定義を見よ。
◎
Note: See the definition of the Service-Worker-Allowed header in Appendix B: Extended HTTP headers.
</p>
					</li>
					<li>
%施策~容器 ~SET `~fetch応答から施策~容器を作成する$( %応答 )
◎
Set policyContainer to the result of creating a policy container from a fetch response given response.
</li>
					<li>
~IF［
%許容される~sw ~EQ `失敗^i
］
⇒＃
%~custom~fetch応答の処理n( `~network~error$ )；
~RET【！If serviceWorkerAllowed is failure, then: Invoke processCustomFetchResponse with a network error and abort these steps.】
◎
If serviceWorkerAllowed is failure, then:
• Asynchronously complete these steps with a network error.
</li>
					<li class="algo">
<p>
%合致したか ~LET 次の手続きを走らせた結果
◎
↓↓</p>
						<ol>
							<li>
%最大-~scope ~LET ε
◎
↓↓ Let scopeURL be registration’s scope url.
◎
↓↓ Let maxScopeString be null.
</li>
							<li>
<p>
~IF［
%許容される~sw ~EQ ~NULL
］
⇒
%最大-~scope ~LET `~URL構文解析する$( `./^l, %~job の`~script~URL$job )
◎
If serviceWorkerAllowed is null, then:
• Let resolvedScope be the result of parsing "./" using job’s script url as the base URL.
• Set maxScopeString to "/", followed by the strings in resolvedScope’s path (including empty strings), separated from each other by "/".
</p>

<p class="note">注記：
%最大-~scope の`~path$urlの最後の~itemは，常に空~文字列になるので、
下の %最大-~scope文字列 の末尾は `/^l になる。
◎
Note: The final item in resolvedScope’s path will always be an empty string, so maxScopeString will have a trailing "/".
</p>
							</li>
							<li>
<p>
~ELSE：
◎
Else:
</p>
								<ol>
									<li>
%最大-~scope ~LET `~URL構文解析する$( %許容される~sw, %~job の`~script~URL$job )
◎
Let maxScope be the result of parsing serviceWorkerAllowed using job’s script url as the base URL.
</li>
									<li>
~IF［
%最大-~scope の`生成元$url ~NEQ`生成元$sub %~job の`~script~URL$jobの`生成元$url
］
⇒
~RET ~F
◎
If maxScope’s origin is job’s script url’s origin, then:
• Set maxScopeString to "/", followed by the strings in maxScope’s path (including empty strings), separated from each other by "/".
</li>
								</ol>
							</li>
							<li>
%最大-~scope文字列 ~LET 次の結果を `/^l で`連結する$
⇒
« 空~文字列 » を %最大-~scope の`~path$urlで`拡張する$
◎
↑</li>
							<li>
%~scope文字列 ~LET 次の結果を `/^l で`連結する$
⇒
« 空~文字列 » を［
%登録 の`~scope~URL$swrの`~path$url
］で`拡張する$
◎
Let scopeString be "/", followed by the strings in scopeURL’s path (including empty strings), separated from each other by "/".
</li>
							<li>
~IF［
%最大-~scope文字列 は %~scope文字列 の`符号単位~接頭辞$でない【！not start with】
］
⇒
~RET ~F
◎
↓</li>
							<li>
~RET ~T
◎
↓</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%合致したか ~EQ ~F
］：
◎
If maxScopeString is null or scopeString does not start with maxScopeString, then:
</p>
						<ol>
							<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
◎
Invoke Reject Job Promise with job and "SecurityError" DOMException.
</li>
							<li>
%~custom~fetch応答の処理n( `~network~error$ )
【！】
◎
Asynchronously complete these steps with a network error.
</li>
							<li>
~RET
</li>
						</ol>
					</li>
					<li>
%~URL ~LET %要請 の`~URL$rq
◎
Let url be request’s url.
</li>
					<li>
%更新-済み資源~map[ %~URL ] ~SET %応答
◎
Set updatedResourceMap[url] to response.
</li>
					<li>
~IF［
%応答 の`~cache状態$ ~NEQ `local^l 
］
⇒
%登録 の`最後の更新~検査-時刻$swr ~SET 現在の時刻
◎
If response’s cache state is not "local", set registration’s last update check time to the current time.
</li>
					<li>
<p>
~IF［
~OR↓
］…
</p>
						<ul>
							<li>
%最新~worker ~EQ ~NULL
</li>
							<li>
［
%最新~worker の`~script~URL$sw ~NEQ %~URL【！＊】
］~OR［
%最新~worker の`種別$sw ~NEQ %~job の`~worker種別$job
］
</li>
							<li>
［
%最新~worker の`~script資源~map$sw[ %~URL ] の`本体$rs, %応答 の`本体$rs
］は、
~byte列として一致しない
</li>
						</ul>
<p>
…ならば
⇒
%資源を更新したか ~SET ~T
</p>

◎
Set hasUpdatedResources to true if any of the following are true:
• newestWorker is null.
• newestWorker’s script url is not url or newestWorker’s type is not job’s worker type.
• newestWorker’s script resource map[url]'s body is not byte-for-byte identical with response’s body.
</li>
					<li>
<p>
~IF［
%資源を更新したか ~EQ ~F
］~AND［
%最新~worker の`古典~scriptは~import済みか$sw ~EQ ~T
］：
◎
If hasUpdatedResources is false and newestWorker’s classic scripts imported flag is set, then:
</p>

<p class="note">注記：
この段は、
~importした~scriptが更新されたかどうかを検査する
— ~main~scriptは変化しなかった【ことが前~段から判明した】ので。
◎
Note: The following checks to see if an imported script has been updated, since the main script has not changed.
</p>
						<ol>
							<li>
<p>
%最新~worker の`~script資源~map$swを成す
~EACH( %~import~URL → %格納-済み応答 )
に対し：
◎
For each importUrl → storedResponse of newestWorker’s script resource map:
</p>
								<ol>
									<li>
~IF［
%~import~URL ~EQ %~URL【！＊】
］
⇒
~CONTINUE
◎
If importUrl is url, then continue.
</li>
									<li>
%~import要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq~SET %~import~URL,
`~client$rq~SET %~job の`~client$job,
`行先$rq~SET `script^l,
`構文解析器~metadata$rq~SET `not parser-inserted^l,
同期~flag【廃された】 ~SET ~T,
`~URL資格証を利用するか$rq~SET ~T
◎
Let importRequest be a new request whose url is importUrl, client is job’s client, destination is "script", parser metadata is "not parser-inserted", synchronous flag is set, and whose use-URL-credentials flag is set.
</li>
									<li>
<p>
~IF［
~OR↓
］…
◎
Set importRequest’s cache mode to "no-cache" if any of the following are true:
</p>
										<ul>
											<li>
%登録 の`~cacheを介する更新~mode$swr ~EQ `none^l 
◎
registration’s update via cache mode is "none".
</li>

											<li>
%~job の`~cacheを迂回するよう強制するか$job ~EQ ~T
◎
job’s force bypass cache flag is set.
</li>

											<li>
%登録 は`非新鮮$である
◎
registration is stale.
</li>
										</ul>
<p>
…ならば
⇒
%~import要請 の`~cache~mode$rq ~SET `no-cache^l
◎
↑</p>
									</li>
									<li>
%~fetchした応答 ~LET %~import要請 を`~fetchする$
◎
Let fetchedResponse be the result of fetching importRequest.
</li>
									<li>
%更新-済み資源~map[ %~import要請 の`~URL$rq ] ~SET %~fetchした応答
◎
Set updatedResourceMap[importRequest’s url] to fetchedResponse.
</li>
									<li>
%~fetchした応答 ~SET %~fetchした応答 の`安全でない応答$
◎
Set fetchedResponse to fetchedResponse’s unsafe response.
</li>
									<li>
~IF［
%~fetchした応答 の`~cache状態$ ~NEQ `local^l
］
⇒
%登録 の`最後の更新~検査-時刻$swr ~SET 現在の時刻
◎
If fetchedResponse’s cache state is not "local", set registration’s last update check time to the current time.
</li>
									<li>
<p>
~IF［
%~fetchした応答 は`不良な~import~script応答$である
］
⇒
~CONTINUE
◎
If fetchedResponse is a bad import script response, continue.
</p>

<p class="note">注記：
`importScripts()$n に対する不良な応答は、
~byte列として検査する目的（次の段）においては無視される。
［
現任な~worker ／ 更新~workerになり得るもの【！potential＊】
］に対する不良でない応答に限り考慮される。
その根拠のいくつかは， `1374$issue を見よ。
◎
Note: Bad responses for importScripts() are ignored for the purpose of the byte-to-byte check. Only good responses for the incumbent worker and good responses for the potential update worker are considered. See issue #1374 for some rationale.
</p>
									</li>
									<li>
<p>
~IF［［
%~fetchした応答 の`本体$rs
］と［
%格納-済み応答 の`安全でない応答$の`本体$rs
］は、
~byte列として一致しない
］
⇒
%資源を更新したか ~SET ~T
◎
If fetchedResponse’s body is not byte-for-byte identical with storedResponse’s unsafe response’s body, set hasUpdatedResources to true.
</p>
									</li>
								</ol>

<p class="note">注記：
~importしたすべての~scriptで~cacheを拡充するため、
~loopはこの段で ~BREAK することなく ~CONTINUE する。
【！The control】
◎
Note: The control does not break the loop in this step to continue with all the imported scripts to populate the cache.
</p>

							</li>
						</ol>
					</li>
					<li>
%~custom~fetch応答の処理n( %応答 )
【！Invoke processCustomFetchResponse with response.】
◎
Asynchronously complete these steps with response.
</li>
				</ol>
</div>
			</li>
		</ol>
</div>

<div class="algo">
<p>
%完了-時の手続き は、
所与の( %~script )
に対し：
【！In both cases, let onComplete given script the following algorithm:】
◎
When the algorithm asynchronously completes, continue the rest of these steps, with script being the asynchronous completion value.
</p>
		<ol>
			<li>
<p>
~IF［
%~script ~EQ ~NULL
］~OR［
`非同期c~moduleか？$( %~script の`~record$sC, 【引数が足らない】,  %~script の`基底~URL$sC, « » ) ~EQ ~T
］：
◎
If script is null or Is Async Module with script’s record, script’s base URL, and « » is true, then:
</p>
				<ol>
					<li>
<p>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</p>

<p class="note">注記：
これは、
以前に
`~job~promiseを却下する$( `SecurityError$E 例外 )
が呼出されていた場合は何もしない。
◎
Note: This will do nothing if Reject Job Promise was previously invoked with "SecurityError" DOMException.
</p>
					</li>
					<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
`登録~map$[ ( %登録 の`~storage~key$swr, `~URLを直列化する$( %登録 の`~scope~URL$swr ) ) ] ~SET ε
【！原文の %scopeURL は定義されていない】
◎
If newestWorker is null, then remove registration map[(registration’s storage key, serialized scopeURL)].
</li>
					<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
					<li>
~RET
◎
abort these steps.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%資源を更新したか ~EQ ~F
］：
◎
If hasUpdatedResources is false, then:
</p>
				<ol>
					<li>
%登録 の`~cacheを介する更新~mode$swr ~SET %~job の`~cacheを介する更新~mode$job
◎
Set registration’s update via cache mode to job’s update via cache mode.
</li>
					<li>
`~job~promiseを解決する$( %~job, %登録 )
◎
Invoke Resolve Job Promise with job and registration.
</li>
					<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
					<li>
~RET
◎
abort these steps.
</li>
				</ol>
			</li>
			<li>
%~worker ~LET 新たな`~sw$
— その
⇒＃
`~script~URL$sw ~SET %~job の`~script~URL$job,
`種別$sw ~SET %~job の`~worker種別$job,
`~script資源$sw ~SET %~script,
`~script資源~map$sw ~SET %更新-済み資源~map
◎
Let worker be a new service worker.
◎
Set worker’s script url to job’s script url, worker’s script resource to script, worker’s type to job’s worker type, and worker’s script resource map to updatedResourceMap.
</li>
			<li>
%~worker の`利用した~scriptの集合$swに %~URL を付加する
◎
Append url to worker’s set of used scripts.
</li>
			<li>
%~worker の`~script資源$swの`施策~容器$sw ~SET %施策~容器
◎
Set worker’s script resource’s policy container to policyContainer.
</li>
			<li>
%走らせた結果 ~LET `~swを走らす$( %~worker, %~job の`~cacheを迂回するよう強制するか$job )
◎
Let forceBypassCache be true if job’s force bypass cache flag is set, and false otherwise.
◎
Let runResult be the result of running the Run Service Worker algorithm with worker and forceBypassCache.
</li>
			<li>
<p>
~IF［
%走らせた結果 ~EQ `失敗^i
］~OR［
%走らせた結果 は`中途完了$である
］：
◎
If runResult is failure or an abrupt completion, then:
</p>
				<ol>
					<li>
`~job~promiseを却下する$( %~job, `TypeError^E )
◎
Invoke Reject Job Promise with job and TypeError.
</li>
					<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
`登録~map$[ ( %登録 の`~storage~key$swr, `~URLを直列化する$( %登録 の`~scope~URL$swr ) ) ] ~SET ε
◎
If newestWorker is null, then remove registration map[(registration’s storage key, serialized scopeURL)].

</li>
					<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`~installする$( %~job, %~worker, %登録 )
◎
Else, invoke Install algorithm with job, worker, and registration as its arguments.
</li>
		</ol>
</div>
	</li>
</ol>

		</section>
		<section id="soft-update-algorithm">
<h3 title="Soft Update">`~soft更新する@</h3>

<p>
~UAは、
これを何度でも~callして，更新-を検査してヨイ。
◎
The user agent may call this as often as it likes to check for updates.
</p>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録,
真偽値 %~cacheを迂回するよう強制するか ~DF ~F
◎終
に対し：
◎
Input
• registration, a service worker registration
• forceBypassCache, an optional boolean, false by default
</p>

<p class="note">注記：
実装者は、
~debugし易くなるよう
%~cacheを迂回するよう強制するか
を利用してもヨイ（例：開発者~toolから呼出すなど）。
また、
~swを拡張する他の仕様も，自前の必要に応じてこの~flagを利用してもヨイ。
◎
Note: Implementers may use forceBypassCache to aid debugging (e.g. invocations from developer tools), and other specifications that extend service workers may also use the flag on their own needs.
◎
Output
• None
</p>

<ol>
	<li>
%最新~worker ~LET `最新な~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as its argument.
</li>
	<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
~RET
◎
If newestWorker is null, abort these steps.
</li>
	<li>
%~job ~LET `~jobを作成する$( ↓ )
⇒＃
`更新する^i,
%登録 の`~storage~key$swr,
%登録 の`~scope~URL$swr,
%最新~worker の`~script~URL$sw,
~NULL,
~NULL
◎
Let job be the result of running Create Job with update, registration’s storage key, registration’s scope url, newestWorker’s script url, null, and null.
</li>
	<li>
%~job の`~worker種別$job ~SET %最新~worker の`種別$sw
◎
Set job’s worker type to newestWorker’s type.
</li>
	<li>
%~job の`~cacheを迂回するよう強制するか$job ~SET %~cacheを迂回するよう強制するか
◎
Set job’s force bypass cache flag if forceBypassCache is true.
</li>
	<li>
`~jobを~scheduleする$( %~job )
◎
Invoke Schedule Job with job.
</li>
</ol>

		</section>
		<section id="installation-algorithm">
<h3 title="Install">`~installする@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job,
`~sw$ %~worker,
`~sw登録$ %登録
◎終
に対し：
◎
Input
• job, a job
• worker, a service worker
• registration, a service worker registration
◎
Output
• none
</p>
<ol>
	<li>
%~installに失敗したか ~LET ~F
◎
Let installFailed be false.
</li>
	<li>
%最新~worker ~LET `最新な~workerを取得する$( %登録 )
◎
Let newestWorker be the result of running Get Newest Worker algorithm passing registration as its argument.
</li>
	<li>
%登録 の`~cacheを介する更新~mode$swr ~SET %~job の`~cacheを介する更新~mode$job
◎
Set registration’s update via cache mode to job’s update via cache mode.
</li>
	<li>
`登録の状態を更新する$( %登録, `installing^l, %~worker )
◎
Run the Update Registration State algorithm passing registration, "installing" and worker as the arguments.
</li>
	<li>
`~workerの状態を更新する$( %登録 にて`~install中の~worker$swr, `installing^l )
◎
Run the Update Worker State algorithm passing registration’s installing worker and "installing" as the arguments.
</li>
	<li>
~Assert：
%~job の`~job~promise$job ~NEQ ~NULL
◎
Assert: job’s job promise is not null.
</li>
	<li>
`~job~promiseを解決する$( %~job, %登録 )
◎
Invoke Resolve Job Promise with job and registration.
</li>
	<li>
%設定群~obj群 ~LET 次を満たす`環境~設定群~obj$すべてからなる集合
⇒
`生成元$enV ~EQ`生成元$sub %登録 の`~scope~URL$swrの`生成元$url
◎
Let settingsObjects be all environment settings objects whose origin is registration’s scope url’s origin.
</li>
	<li>
<p>
%設定群~obj群 を成す
~EACH( %設定群~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %設定群~obj の`担当の~event~loop$enV )
◎
For each settingsObject of settingsObjects, queue a task on settingsObject’s responsible event loop in the DOM manipulation task source to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
%登録~obj群 ~LET %設定群~obj の`~realm$enV内の `ServiceWorkerRegistration$I ~objのうち［
`表現する~sw登録$ ~EQ %登録
］を満たすもの
◎
Let registrationObjects be every ServiceWorkerRegistration object in settingsObject’s realm, whose service worker registration is registration.
</li>
			<li>
%登録~obj群 を成す
~EACH( %登録~obj )
に対し
⇒
`~eventを発火する$( %登録~obj, `updatefound$et )
◎
For each registrationObject of registrationObjects, fire an event on registrationObject named updatefound.
</li>
		</ol>
</div>
	</li>
	<li>
%~install中の~worker ~LET %登録 にて`~install中の~worker$swr
◎
Let installingWorker be registration’s installing worker.
</li>
	<li>
<p>
~IF［
`~eventを飛ばすべきか？$( `install^l, %~install中の~worker ) ~EQ ~F
］：
◎
If the result of running the Should Skip Event algorithm with installingWorker and "install" is false, then:
</p>
		<ol>
			<li>
%~cacheを迂回するよう強制するか ~LET %~job の`~cacheを迂回するよう強制するか$job
◎
Let forceBypassCache be true if job’s force bypass cache flag is set, and false otherwise.
</li>
			<li>
~IF［
`~swを走らす$( %~install中の~worker, %~cacheを迂回するよう強制するか ) ~EQ `失敗^i
］
⇒
%~installに失敗したか ~SET ~T
◎
If the result of running the Run Service Worker algorithm with installingWorker and forceBypassCache is failure, then:
• Set installFailed to true.
</li>
			<li>
<p>
~ELSE：
◎
Else:
</p>
				<ol>
					<li>
<p>
%~task ~LET `~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~install中の~worker の`~event~loop$ )
◎
Queue a task task on installingWorker’s event loop using the DOM manipulation task source to run
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
						<ol>
							<li>
%~event ~LET `~eventを作成する$( `InstallEvent$I )
◎
Let e be the result of creating an event with InstallEvent.
</li>
							<li>
%~event の`type$n 属性 ~SET `install$et に初期化する
◎
Initialize e’s type attribute to install.
</li>
							<li>
`~eventを配送する$( %~install中の~worker の`大域~obj$sw, %~event )
◎
Dispatch e at installingWorker’s global object.
</li>
							<li class="algo">
<p>
`非同期~拡張を待機する^i
— この段は`並列的$に走らす：
◎
WaitForAsynchronousExtensions: Run the following substeps in parallel:
</p>
								<ol>
									<li id="install-settle-step">
次が満たされるまで待機する
⇒
%~event は`作動中$eXでない
◎
Wait until e is not active.
</li>
									<li>
~IF［
%~event の`時間切れか$ ~EQ ~T
］
⇒
%~installに失敗したか ~SET ~T
◎
If e’s timed out flag is set, set installFailed to true.
</li>
									<li>
%~promise ~LET `すべてを待機する~promiseを取得する$( %~event の`存続期間を延長する~promise群$ )
◎
Let p be the result of getting a promise to wait for all of e’s extend lifetime promises.
</li>
								</ol>
<div class="algo">
%~promise の`却下-時$には
⇒
%~installに失敗したか ~SET ~T
◎
Upon rejection of p, set installFailed to true.
</div>
							</li>
						</ol>
</div>

<p>
%~task が破棄されたときは
⇒
%~installに失敗したか ~SET ~T
◎
If task is discarded, set installFailed to true.
</p>
					</li>
					<li>
%~task が実行されるか破棄されるまで待機する
◎
Wait for task to have executed or been discarded.
</li>
					<li>
`非同期~拡張を待機する^i 段が完了するまで待機する
◎
Wait for the step labeled WaitForAsynchronousExtensions to complete.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~installに失敗したか ~EQ ~T
］：
◎
If installFailed is true, then:
</p>
		<ol>
			<li>
`~workerの状態を更新する$( %登録 にて`~install中の~worker$swr, `redundant^l )
◎
Run the Update Worker State algorithm passing registration’s installing worker and "redundant" as the arguments.
</li>
			<li>
`登録の状態を更新する$( %登録, `installing^l, ~NULL )
◎
Run the Update Registration State algorithm passing registration, "installing" and null as the arguments.
</li>
			<li>
~IF［
%最新~worker ~EQ ~NULL
］
⇒
`登録~map$[ ( %登録 の`~storage~key$swr, `~URLを直列化する$( %登録 の`~scope~URL$swr ) ) ] ~SET ε
◎

If newestWorker is null, then remove registration map[(registration’s storage key, serialized registration’s scope url)].
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%~map ~LET %登録 にて`~install中の~worker$swrの`~script資源~map$sw
◎
Let map be registration’s installing worker’s script resource map.
</li>
	<li>
%利用した~script群 ~LET %登録 にて`~install中の~worker$swrの`利用した~scriptの集合$sw
◎
Let usedSet be registration’s installing worker’s set of used scripts.
</li>
	<li>
%~map を成す
~EACH( %~URL )
に対し
⇒
~IF［
%~URL ~NIN %利用した~script群
］
⇒
%~map[ %~URL ] ~SET ε
◎
For each url of map:
• If usedSet does not contain url, then remove map[url].
</li>
	<li>
<p>
~IF［
%登録 にて`待機-中な~worker$swr ~NEQ ~NULL
］：
◎
If registration’s waiting worker is not null, then:
</p>
		<ol>
			<li>
`~swを終了する$( %登録 にて`待機-中な~worker$swr )
◎
Terminate registration’s waiting worker.
</li>
			<li>
`~workerの状態を更新する$( %登録 にて`待機-中な~worker$swr, `redundant^l )
◎
Run the Update Worker State algorithm passing registration’s waiting worker and "redundant" as the arguments.
</li>
		</ol>
	</li>
	<li>
`登録の状態を更新する$( %登録, `waiting^l, %登録 にて`~install中の~worker$swr )
◎
Run the Update Registration State algorithm passing registration, "waiting" and registration’s installing worker as the arguments.
</li>
	<li>
`登録の状態を更新する$( %登録, `installing^l, ~NULL )
◎
Run the Update Registration State algorithm passing registration, "installing" and null as the arguments.
</li>
	<li>
`~workerの状態を更新する$( %登録 にて`待機-中な~worker$swr, `installed^l )
◎
Run the Update Worker State algorithm passing registration’s waiting worker and "installed" as the arguments.
</li>
	<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job.
</li>
	<li>
［
この~algoにより呼出された`~workerの状態を更新する$
］により`~queueされ$たすべての`~task$ が実行されるまで待機する
◎
Wait for all the tasks queued by Update Worker State invoked in this algorithm to have executed.
</li>
	<li>
<p>
`作動化するよう試行する$( %登録 )
◎
Invoke Try Activate with registration.
</p>

<div class="note">
<p>注記：
ここで`作動化するよう試行する$() が`作動化する$() を誘発しない場合、
`作動化する$() は，次のとき再度~試行される：
</p>
<ul>
	<li>
既存の`作動中な~worker$swrにより制御されている最後の~clientが，`~unload$されたとき。
</li>
	<li>
`ServiceWorkerGlobalScope^I1`skipWaiting()$m1 が非同期的に~callされたとき。
</li>
	<li>
既存の`作動中な~worker$swr用の`存続期間を延長する~promise群$が決着したとき。
</li>
</ul>
◎
Note: If Try Activate does not trigger Activate here, Activate is tried again when the last client controlled by the existing active worker is unloaded, skipWaiting() is asynchronously called, or the extend lifetime promises for the existing active worker settle.
</div>
	</li>
</ol>

		</section>
		<section id="activation-algorithm">
<h3 title="Activate">`作動化する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録
◎終
に対し：
◎
Input
• registration, a service worker registration
◎
Output
• None
</p>
<ol>
	<li>
~IF［
%登録 にて`待機-中な~worker$swr ~EQ ~NULL
］
⇒
~RET
◎
If registration’s waiting worker is null, abort these steps.
</li>
	<li>
<p>
~IF［
%登録 にて`作動中な~worker$swr ~NEQ ~NULL
］：
◎
If registration’s active worker is not null, then:
</p>
		<ol>
			<li>
`~swを終了する$( %登録 にて`作動中な~worker$swr )
◎
Terminate registration’s active worker.
</li>
			<li>
`~workerの状態を更新する$( %登録 にて`作動中な~worker$swr, `redundant^l )
◎
Run the Update Worker State algorithm passing registration’s active worker and "redundant" as the arguments.
</li>
		</ol>
	</li>
	<li>
`登録の状態を更新する$( %登録, `active^l, %登録 にて`待機-中な~worker$swr )
◎
Run the Update Registration State algorithm passing registration, "active" and registration’s waiting worker as the arguments.
</li>
	<li>
`登録の状態を更新する$( %登録, `waiting^l, ~NULL )
◎
Run the Update Registration State algorithm passing registration, "waiting" and null as the arguments.
</li>
	<li>
<p>
`~workerの状態を更新する$( %登録 にて`作動中な~worker$swr, `activating^l )
◎
Run the Update Worker State algorithm passing registration’s active worker and "activating" as the arguments.
</p>

<p class="note">注記：
作動中な~workerが作動化-中（ `activating^l ）になって以降は、［
稼働時の~script~error, 作動中な~workerの強制-終了n
］のいずれも，作動中な~workerが作動化されるのを防止しない。
◎
Note: Once an active worker is activating, neither a runtime script error nor a force termination of the active worker prevents the active worker from getting activated.
</p>

<p class="note">注記：
作動化~handlerは、
（片付け~などの様な）本質的でない作業を行うよう設計すること。
作動化~handlerは
— とりわけ，作動化の間に~browserが終了する事例では —
完了まで走らないこともあるので。
~swは、
作動化~handlerが成功裡に完了しないものがあっても，適正に機能するよう設計されるベキである。
◎
Note: Make sure to design activation handlers to do non-essential work (like cleanup). This is because activation handlers may not all run to completion, especially in the case of browser termination during activation. A Service Worker should be designed to function properly, even if the activation handlers do not all complete successfully.
</p>

	</li>
	<li>
%合致した~client群 ~LET 次を満たす`~sw~client$ %~client すべてからなる~list
【順序は述べられていない】
⇒
`合致する~sw登録$( %登録 の`~storage~key$swr, %~client の`作成時の~URL$enV ) ~EQ %登録 【！の`~scope~URL$swr】
◎
Let matchedClients be a list of service worker clients whose creation URL matches registration’s storage key and registration’s scope url.
</li>
	<li>
<p>
%合致した~client群 を成す
~EACH( %~client )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~client に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
For each client of matchedClients, queue a task on client’s responsible event loop, using the DOM manipulation task source, to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following substeps:
</p>
		<ol>
			<li>
%準備済み~promise ~LET %~client の`大域~obj$enVの `ServiceWorkerContainer$I の`準備済み~promise$SWC
◎
Let readyPromise be client’s global object’s ServiceWorkerContainer object’s ready promise.
</li>
			<li>
~IF［
%準備済み~promise ~EQ ~NULL
］
⇒
~CONTINUE
◎
If readyPromise is null, then continue.
</li>
			<li id="activate-resolve-ready-step">
~IF［
%準備済み~promise は決着していない
］
⇒
`~promiseを解決する$( %準備済み~promise, 次の結果 )
⇒
`~sw登録~objを取得する$( %登録, %準備済み~promise に`関連な設定群~obj$ )
◎
If readyPromise is pending, resolve readyPromise with the the result of getting the service worker registration object that represents registration in readyPromise’s relevant settings object.
</li>
		</ol>
</div>
	</li>
	<li>
<p>
%登録 を`利用して$いる
~EACH( `~sw~client$ %~client )
に対し：
◎
For each service worker client client who is using registration:
</p>
		<ol>
			<li>
%~client にて`作動中な~sw$enV【！`作動中な~worker$swrは誤記】 ~SET %登録 にて`作動中な~worker$swr
◎
Set client’s active worker to registration’s active worker.
</li>
			<li>
`制御器の変化を通知する$( %~client )
◎
Invoke Notify Controller Change algorithm with client as the argument.
</li>
		</ol>
	</li>
	<li>
%作動中な~worker ~LET %登録 にて`作動中な~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
<p>
~IF［
`~eventを飛ばすべきか？$( `activate^l, %作動中な~worker ) ~EQ ~F
］：
◎
If the result of running the Should Skip Event algorithm with activeWorker and "activate" is false, then:
</p>
		<ol>
			<li>
<p>
~IF［
`~swを走らす$( %作動中な~worker ) ~NEQ `失敗^i
］：
◎
If the result of running the Run Service Worker algorithm with activeWorker is not failure, then:
</p>
				<ol>
					<li>
<p>
%~task ~LET `~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %作動中な~worker の`~event~loop$ )
◎
Queue a task task on activeWorker’s event loop using the DOM manipulation task source to run
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
						<ol>
							<li>
%~event ~LET `~eventを作成する$( `ExtendableEvent$I )
◎
Let e be the result of creating an event with ExtendableEvent.
</li>
							<li>
%~event の `type$n 属性 ~SET "`activate$et" に初期化する
◎
Initialize e’s type attribute to activate.
</li>
							<li>
`~eventを配送する$( %作動中な~worker の`大域~obj$sw, %~event )
◎
Dispatch e at activeWorker’s global object.
</li>
							<li id="activate-settle-step">
`非同期~拡張を待機する^i
⇒
%~event が`作動中$eXでなくなるまで`並列的$に待機する
◎
WaitForAsynchronousExtensions: Wait, in parallel, until e is not active.
</li>
						</ol>
</div>
					</li>
					<li>
%~task が実行されるか破棄されるまで待機する
◎
Wait for task to have executed or been discarded.
</li>
					<li>
`非同期~拡張を待機する^i 段が完了するまで待機する
◎
Wait for the step labeled WaitForAsynchronousExtensions to complete.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`~workerの状態を更新する$( %登録 にて`作動中な~worker$swr, `activated^l )
◎
Run the Update Worker State algorithm passing registration’s active worker and "activated" as the arguments.
</li>
</ol>

		</section>
		<section id="try-activate-algorithm">
<h3 title="Try Activate">`作動化するよう試行する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録
◎終
に対し：
◎
Input
• registration, a service worker registration
◎
Output
• None
</p>
<ol>
	<li>
~IF［
%登録 にて`待機-中な~worker$swr ~EQ ~NULL
］
⇒
~RET
◎
If registration’s waiting worker is null, return.
</li>
	<li>
<p>
~IF［
%登録 にて`作動中な~worker$swr ~NEQ ~NULL
］~AND［
%登録 にて`作動中な~worker$swrの`状態$sw ~EQ `activating^l
］
⇒
~RET
◎
If registration’s active worker is not null and registration’s active worker’s state is "activating", return.
</p>

<p class="note">注記：
既存の作動中な~workerの状態が依然として作動化-中（ `activating^l ）にある場合、
待機-中な~workerの作動化は遅延される。
◎
Note: If the existing active worker is still in activating state, the activation of the waiting worker is delayed.
</p>
	</li>
	<li>
<p>
~IF［
%登録 にて`作動中な~worker$swr ~EQ ~NULL
］~OR［
~AND↓
］…
◎
Invoke Activate with registration if either of the following is true:
• registration’s active worker is null.
</p>
		<ul>
			<li>
`~swには処理待ち~eventは無いか？$( %登録 にて`作動中な~worker$swr ) ~EQ ~T
◎
The result of running Service Worker Has No Pending Events with registration’s active worker is true, and＼
</li>
			<li>
［
%登録 を`利用して$いる`~sw~client$はない
］~OR［
%登録 にて`待機-中な~worker$swrの`待機を飛ばすか$sw ~EQ ~T
］
◎
no service worker client is using registration or registration’s waiting worker’s skip waiting flag is set.
</li>
		</ul>
<p>
…ならば
⇒
`作動化する$( %登録 )
◎
↑</p>

	</li>
</ol>

		</section>
		<section id="setup-serviceworkerglobalscope-algorithm">
<h3 title="Setup ServiceWorkerGlobalScope">`~ServiceWorkerGlobalScopeを設定しておく@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw$ %~sw
◎終
に対し，［
ある `ServiceWorkerGlobalScope$I ~obj／ ~NULL
］を返す：
◎
Input
• serviceWorker, a service worker
◎
Output
• a ServiceWorkerGlobalScope object or null
</p>

<p class="note">注記：
この~algoは、［
~NULL／
~CSP検査-用に利用-可能な `ServiceWorkerGlobalScope$I
］を返す。
%~sw は作動中な `ServiceWorkerGlobalScope$I を有する場合、
それが返される
— 他の場合
当の~objが新たに作成されることになる。
◎
Note: This algorithm returns a ServiceWorkerGlobalScope usable for a CSP check, or null. If serviceWorker has an active ServiceWorkerGlobalScope, then it is returned. Otherwise, the object will be newly created.
</p>

<div class="note">

<p>注記：
この~algoは、
当の~sw用に［
~CSPや~COEPの様な~security検査-用に利用-可能な何かを作成する
］ために必要yな最小限な設定upを行う。
この仕様は、［
そのような検査が遂行される前に，この~algoが~callされる
］ことを確保する。
◎
This algorithm does the minimal setup for the service worker that is necessary to create something usable for security checks like CSP and COEP. This specification ensures that this algorithm is called before any such checks are performed.
</p>

<p>
各~仕様においては、
そのような~security検査には，［
`ServiceWorkerGlobalScope$I,
`関連な設定群~obj$,
`~realm$gL,
`~agent$
］を作成することが要求される。
各~実装においては、
要求される作業は，ずっと少ないかもしれず
— 観測される結果が等価になる限り（特に，すべての~security検査は結果が同じになる限り） —
この~algoが行う作業を~~減らす一方で，
`~swを走らす$ときの作業を~~増やすこともできる。
◎
In specifications, such security checks require creating a ServiceWorkerGlobalScope, a relevant settings object, a realm, and an agent. In implementations, the amount of work required might be much less. Therefore, implementations could do less work in their equivalent of this algorithm, and more work in Run Service Worker, as long as the results are observably equivalent. (And in particular, as long as all security checks have the same result.)
</p>
</div>

<ol>
	<li>
%安全でない作成~時刻 ~LET `安全でない共有される現在の時刻$
◎
Let unsafeCreationTime be the unsafe shared current time.
</li>
	<li>
~IF［
%~sw は`走っている$
］
⇒
~RET %~sw の`大域~obj$sw
◎
If serviceWorker is running, then return serviceWorker’s global object.
</li>
	<li>
~IF［
%~sw の`状態$sw ~EQ `redundant^l
］
⇒
~RET ~NULL
◎
If serviceWorker’s state is "redundant", then return null.
</li>
	<li>
~IF［
%~sw の`大域~obj$sw ~NEQ ~NULL
］
⇒
~RET %~sw の`大域~obj$sw
◎
If serviceWorker’s global object is not null, then return serviceWorker’s global object.
</li>
	<li>
~Assert：
%~sw の`開始~状態$sw ~EQ ~NULL
◎
Assert: serviceWorker’s start status is null.
</li>
	<li>
%設定upに失敗したか ~LET ~F
◎
Let setupFailed be false.
</li>
	<li>
%大域~obj ~LET ~NULL
◎
Let globalObject be null.
</li>
	<li>
%~agent ~LET `~sw~agentを得する$()
◎
Let agent be the result of obtaining a service worker agent,＼
</li>
	<li class="algo">
<p>
%~agent の文脈~内で次の手続きを走らす：
◎
and run the following steps in that context:
</p>
		<ol>
			<li>
%~worker大域~scope ~LET `新たな~obj$( `ServiceWorkerGlobalScope$I )
◎
↓</li>
			<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で、
%~agent 内で`新たな~realmを作成する$
⇒
大域~obj用には %~worker大域~scope を利用する
◎
Let realmExecutionContext be the result of creating a new realm given agent and the following customizations:
• For the global object, create a new ServiceWorkerGlobalScope object. Let workerGlobalScope be the created object.
</li>
			<li>
<p>
%設定群~obj ~LET 新たな`環境~設定群~obj$
— その各種~algoは、
次に従って定義される：
◎
Let settingsObject be a new environment settings object whose algorithms are defined as follows:
</p>
				<ul>
					<li class="algo">
`~realm実行~文脈$enV
⇒
~RET %~realm実行~文脈
◎
The realm execution context
• Return realmExecutionContext.
</li>
					<li class="algo">
`~module~map$enV
⇒
~RET %~worker大域~scope の`~module~map$wG
◎
The module map
• Return workerGlobalScope’s module map.
</li>
					<li class="algo">
`~API用~基底~URL$enV
⇒
~RET %~sw の`~script~URL$sw
◎
The API base URL
• Return serviceWorker’s script url.
</li>
					<li class="algo" id="_sw-origin">
`生成元$enV
⇒
~RET %~sw を登録している`~sw~client$【！＊】の`生成元$cl【！`生成元$enV】
◎
The origin
• Return its registering service worker client’s origin.
</li>
					<li class="algo">
`施策~容器$enV
⇒
~RET %~worker大域~scope の`施策~容器$wG
◎
The policy container
• Return workerGlobalScope’s policy container.
</li>
					<li class="algo">
`時刻~起点$enV
⇒
~RET `時刻を粗化する$( %安全でない作成~時刻, %~worker大域~scope の`非同一-生成元~能力は隔離されるか$wG )
◎
The time origin
• Return the result of coarsening unsafeCreationTime given workerGlobalScope’s cross-origin isolated capability.
</li>
				</ul>
			</li>
			<li>
%設定群~obj の
⇒＃
`~ID$enV ~SET 新たな一意かつ不透明な文字列,
`作成時の~URL$enV ~SET %~sw の`~script~URL$sw,
`~top-level作成時の~URL$enV ~SET ~NULL,
`~top-level生成元$enV ~SET `実装定義$な値,
`~target閲覧~文脈$enV ~SET ~NULL,
`作動中な~sw$enV ~SET ~NULL
◎
Set settingsObject’s id to a new unique opaque string, creation URL to serviceWorker’s script url, top-level creation URL to null, top-level origin to an implementation-defined value, target browsing context to null, and active service worker to null.
</li>
			<li>
%~worker大域~scope の
⇒＃
`~URL$wG ~SET %~sw の`~script~URL$sw,
`施策~容器$wG ~SET %~sw の`~script資源$swの`施策~容器$sw,
`種別$wG ~SET %~sw の`種別$sw
◎
Set workerGlobalScope’s url to serviceWorker’s script url.
◎
Set workerGlobalScope’s policy container to serviceWorker’s script resource’s policy container.
◎
Set workerGlobalScope’s type to serviceWorker’s type.
</li>
			<li>
%~worker大域~scope に`新たな~obj$( `WorkerLocation$I ) を結付ける
◎
Create a new WorkerLocation object and associate it with workerGlobalScope.
</li>
			<li>
~IF［
`大域~obj用に~CSP初期化を走らす$( %~worker大域~scope ) ~EQ `阻止される^i
］
⇒＃
%設定upに失敗したか ~SET ~T；
~RET
◎
If the run CSP initialization for a global object algorithm returns "Blocked" when executed upon workerGlobalScope, set setupFailed to true and abort these steps.
</li>
			<li>
%大域~obj ~SET %~worker大域~scope
◎
Set globalObject to workerGlobalScope.
</li>
		</ol>
	</li>
	<li>
次が満たされるまで待機する
⇒
［
%大域~obj ~NEQ ~NULL
］~OR［
%設定upに失敗したか ~EQ ~T
］
◎
Wait for globalObject is not null, or for setupFailed to be true.
</li>
	<li>
~IF［
%設定upに失敗したか ~EQ ~T
］
⇒
~RET ~NULL
◎
If setupFailed is true, then return null.
</li>
	<li>
~RET %大域~obj
◎
Return globalObject.
</li>
</ol>

		</section>
		<section id="run-service-worker-algorithm">
<h3 title="Run Service Worker">`~swを走らす@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw$ %~sw,
真偽値 %~cacheを迂回するよう強制するか ~DF ~F
◎終
に対し，［
ある `Completion$ ／ `失敗^i
］を返す：
◎
Input
• serviceWorker, a service worker
• forceBypassCache, an optional boolean, false by default
◎
Output
• a Completion or failure
</p>

<p class="note">注記：
この~algoは、［
当の~swが`走っている$ようになるか，開始に失敗する
］まで他を阻む。
◎
Note: This algorithm blocks until the service worker is running or fails to start.
</p>

<ol>
	<li>
~IF［
%~sw は`走っている$
］
⇒
~RET %~sw の`開始~状態$sw
◎
If serviceWorker is running, then return serviceWorker’s start status.
</li>
	<li>
~IF［
%~sw の`状態$sw ~EQ `redundant^l
］
⇒
~RET `失敗^i
◎
If serviceWorker’s state is "redundant", then return failure.
</li>
	<li>
~Assert：
%~sw の`開始~状態$sw ~EQ ~NULL
◎
Assert: serviceWorker’s start status is null.
</li>
	<li>
%~script ~LET %~sw の`~script資源$sw
◎
Let script be serviceWorker’s script resource.
</li>
	<li>
~Assert：
%~script ~NEQ ~NULL
◎
Assert: script is not null.
</li>
	<li>
%開始に失敗したか ~LET ~F
◎
Let startFailed be false.
</li>
	<li>
%~worker大域~scope ~LET %~sw の`大域~obj$sw
◎
Let workerGlobalScope be serviceWorker’s global object.
</li>
	<li>
<p>
~IF［
%~worker大域~scope ~EQ ~NULL
］：
◎
If workerGlobalScope is null:
</p>
		<ol>
			<li>
%~worker大域~scope ~SET `~ServiceWorkerGlobalScopeを設定しておく$( %~sw )
◎
Set workerGlobalScope to be the result of running the Setup ServiceWorkerGlobalScope algorithm with serviceWorker.
</li>
			<li>
~IF［
%~worker大域~scope ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If workerGlobalScope is null, then return failure.
</li>
			<li>
%~sw の`大域~obj$sw ~SET %~worker大域~scope
◎
Set serviceWorker’s global object to workerGlobalScope.
</li>
		</ol>
	</li>
	<li>
%~agent ~LET %~worker大域~scope の`~realm実行~文脈$enV用の~agentを得する
◎
Obtain agent for workerGlobalScope’s realm execution context,＼
</li>
	<li class="algo">
<p>
%~agent の文脈~内で次の手続きを走らす：
◎
and run the following steps in that context:
</p>
		<ol>
			<li>
~IF［
%~cacheを迂回するよう強制するか ~EQ ~T
］
⇒
%~worker大域~scope の`~importする~script用には~cacheを迂回するよう強制するか$SWG ~SET %~cacheを迂回するよう強制するか
◎
Set workerGlobalScope’s force bypass cache for import scripts flag if forceBypassCache is true.
</li>
			<li>
<p>
~IF［
%~sw は`作動中な~worker$swrである
］：
</p>
				<ol>
					<li>
［
%~sw を`包含している~sw登録$swの`~back-up~task~list$swr
］を成す
~EACH( `~task$ %~task )
に対し，順に
⇒
`~taskを~queueする$( %~task の`~source$tK, %~task の`手続き$tK, %~sw の`~event~loop$ )
</li>
					<li>
<p>
`~back-up~task~list$swrを空にする
</p>

<p class="trans-note">【
この段は、
この訳による補完
— さもなければ，この~listは肥大する一方になり、
ここ以外に，~listから除去し得る~~機会はないので。
】</p>
</li>
				</ol>
◎
If serviceWorker is an active worker, and there are any tasks queued in serviceWorker’s containing service worker registration’s task queues, queue them to serviceWorker’s event loop’s task queues in the same order using their original task sources.
</li>
			<li>
%評価~状態s ~LET ~NULL
◎
Let evaluationStatus be null.
</li>
			<li>
<p>
~IF［
%~script は`古典~script$である
］：
◎
If script is a classic script, then:
</p>
				<ol>
					<li>
%評価~状態s ~SET `古典~scriptを走らす$( %~script )
◎
Set evaluationStatus to the result of running the classic script script.
</li>
					<li>
~IF［
%評価~状態s .`Value^sl は空である
（すなわち、
~scriptは，まだ評価されていない）
］
⇒＃
%開始に失敗したか ~SET ~T；
~RET
◎
If evaluationStatus.[[Value]] is empty, this means the script was not evaluated. Set startFailed to true and abort these steps.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%~script は`~module~script$である
］：
◎
Otherwise, if script is a module script, then:
</p>
				<ol>
					<li>
%評価~promise ~LET `~module~scriptを走らす$( %~script 【！, with report errors set to false】)
◎
Let evaluationPromise be the result of running the module script script, with report errors set to false.
</li>
					<li>
~Assert：
%評価~promise . `PromiseState^sl ~NEQ `pending^l
◎
Assert: evaluationPromise.[[PromiseState]] is not "pending".
</li>
					<li>
~IF［
%評価~promise . `PromiseState^sl ~EQ `rejected^l
］
⇒
%評価~状態s ~SET `ThrowCompletion$jA( %評価~promise . `PromiseResult^sl )
◎
If evaluationPromise.[[PromiseState]] is "rejected":
• Set evaluationStatus to ThrowCompletion(evaluationPromise.[[PromiseResult]]).
</li>
					<li>
~ELSE
⇒
%評価~状態s ~SET `NormalCompletion$jA( `undefined^jv )
◎
Otherwise:
• Set evaluationStatus to NormalCompletion(undefined).
</li>
				</ol>
			</li>
			<li>
~IF［
当の~scriptは`~swを終了する$~algoにより中止された
］
⇒＃
%開始に失敗したか ~SET ~T；
~RET
◎
If the script was aborted by the Terminate Service Worker algorithm, set startFailed to true and abort these steps.
</li>
			<li>
%~sw の`開始~状態$sw ~SET %評価~状態s
◎
Set serviceWorker’s start status to evaluationStatus.
</li>
			<li>
<p>
~IF［
%~script の`これまでに評価されたか$sw ~EQ ~F
］：
◎
If script’s has ever been evaluated flag is unset, then:
</p>
				<ol>
					<li>
<p>
%設定群~obj の`大域~obj$enVに結付けられた【！＊？】
~EACH( `~event~listener$ %~listener )
に対し
⇒
%~worker大域~scope の`~sw$SWGが`取扱う~event型の集合$swに %~listener の~event型 を`付加する$set
◎
For each eventType of settingsObject’s global object’s associated list of event listeners' event types:
• Append eventType to workerGlobalScope’s associated service worker’s set of event types to handle.
</p>

<p class="note">注記：
この時点に［
大域~objに結付けられた~event~listener
］が追加されてない場合、
当の`~sw$SWGが`取扱う~event型の集合$swは，空~集合であり続ける。
◎
Note: If the global object’s associated list of event listeners does not have any event listener added at this moment, the service worker’s set of event types to handle remains an empty set.
</p>
					</li>
					<li>
%~script の`これまでに評価されたか$sw ~SET ~T
◎
Set script’s has ever been evaluated flag.
</li>
					<li>
%~sw の`すべての~fetch~listenerは空か$sw ~SET ~F
◎
Unset the serviceWorker’s all fetch listeners are empty flag.
</li>
					<li>
任意選択で
⇒
~IF［
`すべての~fetch~listenerは空か？$( %~worker大域~scope ) ~EQ ~T
］
⇒
%~sw の`すべての~fetch~listenerは空か$sw ~SET ~T
◎
The user agent may, if the All Fetch Listeners Are Empty algorithm with workerGlobalScope returns true, set serviceWorker’s all fetch listeners are empty flag.
</li>
				</ol>
			</li>
			<li>
%設定群~obj により指定される`担当の~event~loop$enVを，破壊されるまで走らす
◎
Run the responsible event loop specified by settingsObject until it is destroyed.
</li>
			<li>
%~worker大域~scope の`作動中な~timer群が成す~map$を`~clearする$map
◎
Clear workerGlobalScope’s map of active timers.
</li>
		</ol>
	</li>
	<li>
次が満たされるまで待機する
⇒
［
%~sw は`走っている$
］~OR［
%開始に失敗したか ~EQ ~T
］
◎
Wait for serviceWorker to be running, or for startFailed to be true.
</li>
	<li>
~IF［
%開始に失敗したか ~EQ ~T
］
⇒
~RET `失敗^i
◎
If startFailed is true, then return failure.
</li>
	<li>
~RET %~sw の`開始~状態$sw
◎
Return serviceWorker’s start status.
</li>
</ol>

		</section>
		<section id="all-fetch-listeners-are-empty-algorithm">
<h3 title="All Fetch Listeners Are Empty">`すべての~fetch~listenerは空か？@</h3>

<p>
~algoは、
所与の
⇒＃
`大域~obj$sw %~worker大域~scope
◎終
に対し，ある真偽値を返す：
◎
Input
• workerGlobalScope, a global object.
◎
Output
• a boolean
</p>
<ol>
	<li>
~IF［
`fetch^l ~NIN %~worker大域~scope が`取扱う~event型の集合$sw 
］
⇒
~RET ~T
◎
If workerGlobalScope’s set of event types to handle does not contain fetch, then return true.
</li>
	<li>
%~event~handler ~LET %~worker大域~scope の`~event~handler~map$[ `onfetch^l ]
◎
Let eventHandler be workerGlobalScope’s event handler map["onfetch"]'s value.
</li>
	<li>
%~event~listener~callback群 ~LET 
`~sw~fetch~event~listener~callback群を得する旧来の手続き$( %~worker大域~scope )
◎
Let eventListenerCallbacks be the result of calling legacy-obtain service worker fetch event listener callbacks given workerGlobalScope.
</li>
	<li>
<p>
%~event~listener~callback群 を成す
~EACH( %~event~listener~callback )
に対し：
◎
For each eventListenerCallback of eventListenerCallbacks:
</p>
		<ol>
			<li>
%~callback ~LET ~NULL
◎
Let callback be null.
</li>
			<li>
~IF［
%~event~handler ~NEQ ~NULL
］~AND［
%~event~listener~callback ~EQ %~event~handler の`~listener$eHの`~callback$evL
］
⇒
%~callback ~SET `~JS値に変換する$( %~event~handler の`値$eH )
◎
If eventHandler is not null and eventListenerCallback equals eventHandler’s listener’s callback, then set callback to the result of converting to an ECMAScript value eventHandler’s value.
</li>
			<li>
~ELSE
⇒
%~callback ~SET `~JS値に変換する$( %~event~listener~callback )
◎
Otherwise, set callback to the result of converting to an ECMAScript value eventListenerCallback.
</li>
			<li>
<p>
~IF［
`IsCallable$jA( %~callback ) ~EQ ~F
］
⇒
~RET ~F
◎
If IsCallable(callback) is false, then return false.
</p>

<p class="note">注記：
`~callback~interface$を実装する~objのうち，
`handleEvent^c を利用するもの
（ `EventListener$I ~obj【！ `Callback^c ／ `~callback$evL】）
は、
【次の段と同じく】
空でないものと見做される。
この段は、
`handleEvent^c 取得子
（ `EventListener^I の `handleEvent(event)＠~DOM4#dom-eventlistener-handleevent$m ）
が~callされるのを避ける
（それは、
この検査の間に当の~event~listenerたちを改変し得るので）。
◎
Note: Callback objects that use handleEvent(event) are assumed to be non-empty. This avoids calling the handleEvent(event) getters, which could modify the event listeners during this check.
</p>
			</li>
			<li>
<p>
~IF［
%~callback の`関数~本体$は空でない
（すなわち［
`statement, declaration＠~TC39#sec-ecmascript-language-statements-and-declarations$en
］いずれかは存在する）
］
⇒
~RET ~F
◎
If callback’s function body is not empty (i.e. either a statement or declaration exist), then return false.
</p>

<p class="note">注記：
これは、
`() =&gt; {}^c の様な `fetch^l ~listenerを検出する。
一部の~siteは、
自身が［
Chromium から PWA（ `progressive web application^en ）として認識される
］よう，本体が空な~fetch~event~listenerを有する。
◎
Note: This detects "fetch" listeners like () =&gt; {}. Some sites have a fetch event listener with empty body to make them recognized by Chromium as a progressive web application (PWA).
</p>
			</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

<p class="note">注記：
~UAには、
次を指示する警告を示すことが奨励される
⇒
空な `fetch^l ~listenerは不必要であり、
処理能に負な影響iを及ぼし得る。
◎
Note: User agents are encouraged to show a warning indicating that empty "fetch" listeners are unnecessary, and may have a negative performance impact.
</p>
		</section>
		<section id="terminate-service-worker-algorithm">
<h3 title="Terminate Service Worker">`~swを終了する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw$ %~sw
◎終
に対し
— 以下は、
%~sw の~main~loopとは`並列的$に走らすとする：
◎
Input
• serviceWorker, a service worker
◎
Output
• None
◎
Run the following steps in parallel with serviceWorker’s main loop:
</p>
<ol>
	<li>
%~sw大域~scope ~LET %~sw の`大域~obj$sw
◎
Let serviceWorkerGlobalScope be serviceWorker’s global object.
</li>
	<li>
%~sw大域~scope の`~close中か$wG ~SET ~T
◎
Set serviceWorkerGlobalScope’s closing flag to true.
</li>
	<li>
%~sw の`延長-済み~event集合$swを`空にする$
◎
Remove all the items from serviceWorker’s set of extended events.
</li>
	<li>
%~back-up ~LET %~sw を`包含している~sw登録$swの`~back-up~task~list$swr
◎
↓</li>
	<li>
~EACH( %~task~source ~IN { `~fetchを取扱う~task~source$, `機能的~eventを取扱う~task~source$ } )
に対し
⇒
%~sw大域~scope の`~event~loop$に属する［
%~task~source に結付けられた`~task~queue$
］を成す
~EACH( %~task )
に対し
⇒
%~back-up に %~task を`付加する$set
◎
If there are any tasks, whose task source is either the handle fetch task source or the handle functional event task source, queued in serviceWorkerGlobalScope’s event loop’s task queues, queue them to serviceWorker’s containing service worker registration’s corresponding task queues in the same order using their original task sources, and＼
</li>
	<li>
<p>
%~sw大域~scope の`~event~loop$に属する
~EACH( `~task~queue$ %~queue )
に対し
⇒
%~queue を`空にする$
◎
discard all the tasks (including tasks whose task source is neither the handle fetch task source nor the handle functional event task source) from serviceWorkerGlobalScope’s event loop’s task queues without processing them.
</p>

<p class="note">注記：
これは実質的に， `fetch$et やその他の`機能的~event$（ `push$et ~eventなど）に限り~back-upされ、
他の~task（ `message$et ~eventなど）は処理することなく破棄されることを意味する。
◎
Note: This effectively means that the fetch events and the other functional events such as push events are backed up by the registration’s task queues while the other tasks including message events are discarded.
</p>
	</li>
	<li>
%~sw 内で現在`走っている~scriptを中止する$
◎
Abort the script currently running in serviceWorker.
</li>
	<li>
%~sw の`開始~状態$sw ~SET ~NULL
◎
Set serviceWorker’s start status to null.
</li>
</ol>

		</section>
		<section id="on-fetch-request-algorithm">
<h3 title="Handle Fetch">`~fetchを取扱う@</h3>

<p>
この~algoは、［
`~sw$文脈に手渡される，`~fetch$の取扱い
］用の入口である。
【`~HTTP~fetch$から利用される。】
◎
The Handle Fetch algorithm is the entry point for the fetch handling handed to the service worker context.
</p>

<p>
~algoは、
所与の
⇒＃
`要請$ %要請,
`~fetch制御器$ %~fetch制御器,
真偽値 %高分解能な処理能~timerを利用するか
◎終
に対し，［
ある`応答$／ある`~sw計時~報$
］を返す：
◎
Input
• request, a request
• fetchController, a fetch controller
• useHighResPerformanceTimers, a boolean
◎
Output
• a response or service worker timing info
</p>
<ol>
	<li>
%登録 ~LET ~NULL
◎
Let registration be null.
</li>
	<li>
%~client ~LET %要請 の`~client$rq
◎
Let client be request’s client.
</li>
	<li>
%予約-済み~client ~LET %要請 の`予約-済み~client$rq
◎
Let reservedClient be request’s reserved client.
</li>
	<li>
%~preload応答~promise ~LET `新たな~promise$
◎
Let preloadResponse be a new promise.
</li>
	<li>
%~worker~realm ~LET ~NULL
◎
Let workerRealm be null.
</li>
	<li>
%計時~報 ~LET 新たな`~sw計時~報$
◎
Let timingInfo be a new service worker timing info.
</li>
	<li>
~Assert：
%要請 の`行先$rq ~NEQ `serviceworker^l
◎
Assert: request’s destination is not "serviceworker".
</li>
	<li>
~IF［
%要請 の`行先$rq ~IN { `embed^l, `object^l }
］
⇒
~RET ~NULL
◎
If request’s destination is either "embed" or "object", then:
• Return null.
</li>
	<li>
<p>
~IF［
%要請 は`非~下位資源~要請$である
］：
◎
Else if request is a non-subresource request, then:
</p>
		<ol>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
［
%予約-済み~client は`環境~設定群~obj$である
］~AND［
%予約-済み~client は`~secureな文脈$enVでない
］
</li>
					<li>
［
%予約-済み~client は`環境~設定群~obj$でない
］~AND［
%要請 の`~URL$rq は`信用に価し得る~URL$でない
］
</li>
					<li>
［
%要請 は`~navi要請$である
］~AND［
それを誘発している`~navi$は、
<kbd>shift+reload</kbd> 等により起動された
【実際には何を意味する？ `952$issue】
］
</li>
				</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>

◎
If reservedClient is not null and is an environment settings object, then:
• If reservedClient is not a secure context, return null.
◎
Else:
• If request’s url is not a potentially trustworthy URL, return null.
◎
If request is a navigation request and the navigation triggering it was initiated with a shift+reload or equivalent, return null.
</li>
			<li>
~Assert：
%予約-済み~client ~NEQ ~NULL
◎
Assert reservedClient is not null.
</li>
			<li>
%~storage~key ~LET `~storage~keyを得する$( %予約-済み~client )
◎
Let storage key be the result of running obtain a storage key given reservedClient.
</li>
			<li>
%登録 ~SET `合致する~sw登録$( %~storage~key, %要請 の`~URL$rq )
◎
Set registration to the result of running Match Service Worker Registration given storage key and request’s url.
</li>
			<li>
~IF［
%登録 ~EQ ~NULL
］~OR［
%登録 にて`作動中な~worker$swr ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If registration is null or registration’s active worker is null, return null.
</li>
			<li>
~IF［
%要請 の`行先$rq ~NEQ `report$l
］
⇒
%予約-済み~client にて`作動中な~sw$enV ~SET %登録 にて`作動中な~worker$swr
◎
If request’s destination is not "report", set reservedClient’s active service worker to registration’s active worker.
</li>
		</ol>

<p class="note">注記：
この時点から、
`~sw~client$は，［
その`作動中な~sw$enVを`包含している~sw登録$sw
］の`利用＠#dfn-use$を開始する。
◎
Note: From this point, the service worker client starts to use its active service worker’s containing service worker registration.
</p>
	</li>
	<li>
<p>
~ELIF［
%要請 は`下位資源~要請$である
］：
</p>
		<ol>
			<li>
~IF［
%~client にて`作動中な~sw$enV ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
			<li>
%登録 ~SET %~client にて`作動中な~sw$enV を`包含している~sw登録$sw
</li>
		</ol>
◎
Else if request is a subresource request, then:
• If client’s active service worker is non-null, set registration to client’s active service worker’s containing service worker registration.
• Else, return null.
</li>
	<li>
%作動中な~worker ~LET %登録 にて`作動中な~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
%~soft更新すべきか ~LET ~IS［
%要請 は`非~下位資源~要請$である
］~OR［［
%要請 は`下位資源~要請$である
］~AND［
%登録 は`非新鮮$である
］］
◎
Let shouldSoftUpdate be true if any of the following are true, and false otherwise:
• request is a non-subresource request.
• request is a subresource request and registration is stale.
</li>
	<li>
<p>
~IF［
%作動中な~worker の`~router規則~list$swは`空$である
］：
◎
If activeWorker’s list of router rules is not empty:
</p>
		<ol>
			<li>
%計時~報 の`~worker~router評価~開始$swT ~SET `粗化した共有される現在の時刻$( %高分解能な処理能~timerを利用するか )
◎
Set timingInfo’s worker router evaluation start to the coarsened shared current time given useHighResPerformanceTimers.
</li>
			<li>
%~source ~LET `~router~sourceを取得する$( %登録 にて`作動中な~worker$swr, %要請 )
◎
Let source be the result of running the Get Router Source algorithm with registration’s active worker and request.
</li>
			<li>
<p>
~IF［
%~source ~NEQ ~NULL
］：
◎
If source is non-null, then:
</p>
				<ol>
					<li>
%計時~報 の
⇒＃
`~worker合致した~router~source$swT ~SET %~source,
`~worker最終-~router~source$swT ~SET `network$l
◎
Set timingInfo’s worker matched router source be set to source, and worker final router source be set to "network".
</li>
					<li>
<p>
~IF［
%~source ~EQ `network$l
］：
◎
If source is "network":
</p>
						<ol>
							<li>
<p>
~IF［
%~soft更新すべきか ~EQ ~T
］
⇒
次の手続きを`並列的$に走らす
◎
If shouldSoftUpdate is true, then in parallel run＼
</p>

<div class="algo">
手続きは
⇒
`~soft更新する$( %登録 )
◎
the Soft Update algorithm with registration.
</div>
							</li>
							<li>
~RET %計時~報
◎
Return timingInfo.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%~source ~EQ `cache$l
］~OR［
%~source[ `RouterSourceDict^I1"`cacheName$m1" ] ~NEQ ε
］：
◎
Else if source is "cache", or source["cacheName"] exists, then:
</p>
						<ol>
							<li>
<p>
~IF［
%~soft更新すべきか ~EQ ~T
］
⇒
次の手続きを`並列的$に走らす
◎
If shouldSoftUpdate is true, then in parallel run＼
</p>

<div class="algo">
手続きは
⇒
`~soft更新する$( %登録 )
◎
the Soft Update algorithm with registration.
</div>
							</li>
							<li>
%計時~報 の`~worker~cache検索~開始$swT ~SET `粗化した共有される現在の時刻$( %高分解能な処理能~timerを利用するか )
◎
Set timingInfo’s worker cache lookup start to the coarsened shared current time given useHighResPerformanceTimers.
</li>
							<li>
<p>
%登録 の`~storage~key$swrの`名前から~cacheへの~map$を成す
~EACH( %~cache名 → %~cache )
に対し：
◎
For each cacheName → cache of the registration’s storage key’s name to cache map.
</p>
								<ol>
									<li>
~IF［
%~source[ `RouterSourceDict^I1"`cacheName$m1" ] ~NIN { ε, %~cache名 }
］
⇒
~CONTINUE
◎
If source["cacheName"] exists and source["cacheName"] is not cacheName, continue.
</li>
									<li>
%要請~応答~list ~LET `~cacheを~queryする$( %要請, 新たな `CacheQueryOptions$I, %~cache )
◎
Let requestResponses be the result of running Query Cache with request, a new CacheQueryOptions, and cache.
</li>
									<li>
~IF［
%要請~応答~list は`空$である
］
⇒
~RET %計時~報
◎
If requestResponses is an empty list, return timingInfo.
</li>
									<li>
<p>
~ELSE：
◎
Else:
</p>
										<ol>
											<li>
%要請~応答 ~LET %要請~応答~list[ 0 ]
◎
Let requestResponse be the first element of requestResponses.
</li>
											<li>
%応答 ~LET %要請~応答 を成す応答
◎
Let response be requestResponse’s response.
</li>
											<li>
%大域~obj ~LET %作動中な~worker の`大域~obj$sw
◎
Let globalObject be activeWorker’s global object.
</li>
											<li>
~IF［
%大域~obj ~EQ ~NULL
］
⇒
%大域~obj ~SET `~ServiceWorkerGlobalScopeを設定しておく$( %作動中な~worker )
◎
If globalObject is null:
• Set globalObject to the result of running Setup ServiceWorkerGlobalScope with activeWorker.
</li>
											<li>
~IF［
%大域~obj ~EQ ~NULL
］
⇒
~RET %計時~報
◎
If globalObject is null, return timingInfo.
</li>
										</ol>

<p class="note">注記：
ここで `ServiceWorkerGlobalScope$I を作成される `ServiceWorkerGlobalScope$I は、
~CORS検査にしか要求されない
— 実装は、
実際に それを作成することは期待されない。
◎
Note: This only creates a ServiceWorkerGlobalScope because CORS checks require that. It is not expected that implementations will actually create a ServiceWorkerGlobalScope here.
</p>
										<ol>
											<li>
<p>
~IF［
%応答 の`種別$rs ~EQ `opaque^l
］：
◎
If response’s type is "opaque",＼
</p>
												<ol>
													<li>
%検査~結果 ~LET `非同一-生成元~資源~施策~検査$( ↓ )
⇒＃
%大域~obj の`生成元$enV,
%大域~obj,
空~文字列,
%応答 の`内部~応答$
◎
and cross-origin resource policy check with globalObject’s origin, globalObject, "", and response’s internal response returns＼
</li>
													<li>
~IF［
%検査~結果 ~EQ `阻止される^i
］
⇒
~RET %計時~報
◎
blocked, then return timingInfo.
</li>
												</ol>
											</li>
											<li>
%計時~報 の`~worker最終-~router~source$swT ~SET `cache$l
◎
Set timingInfo’s worker final router source be set to "cache".
</li>
											<li>
<p>
%結果 の`~sw計時~報$† ~SET %計時~報
</p>

<p class="trans-note">【†
変数 %結果 は宣言されていない
— おそらく，［
%応答 の`~sw計時~報$rs
］の誤記であろう。
】</p>
◎
Set result’s service worker timing info be set to timingInfo.
</li>
											<li>
~RET %応答
◎
Return response.
</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
~RET %計時~報
◎
Return timingInfo.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%~source ~EQ `race-network-and-fetch-handler$l
］~AND［
%要請 の`~method$rq ~EQ `GET^bl
］：
◎
Else if source is "race-network-and-fetch-handler", and request’s method is `GET` then:
</p>
						<ol>
							<li>
<p>
~IF［
%~soft更新すべきか ~EQ ~T
］
⇒
次の手続きを`並列的$に走らす
◎
If shouldSoftUpdate is true, then in parallel run＼
</p>

<div class="algo">
手続きは
⇒
`~soft更新する$( %登録 )
◎
the Soft Update algorithm with registration.
</div>
							</li>
							<li>
%~queue ~LET 新たな`~queue$
◎
Let queue be an empty queue of race result.
</li>
							<li>
%競走~fetch制御器 ~LET ~NULL
◎
Let raceFetchController be null.
</li>
							<li>
%競走~応答 ~LET 新たな`競走~応答$
— その
⇒＃
`値$rV ~SET `pending^l
◎
Let raceResponse be a race response whose value is "pending".
</li>
							<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
								<ol>
									<li>
~IF［
%~fetch制御器 の`状態$fC ~IN { `terminated^l, `aborted^l }
］
⇒
%競走~応答 ~SET 新たな`競走~応答$
— その
⇒＃
`値$rV ~SET ~NULL
◎
If fetchController’s state is "terminated" or "aborted", then set raceResponse to a race response whose value is null,＼
</li>
									<li>
<p>
~ELSE
⇒
%競走~fetch制御器 ~SET %要請 を`~fetchする$
— 次を与える下で：
◎
and abort these steps.
◎
Set raceFetchController to the result of calling fetch given request, with＼
</p>
										<ul>
											<li class="algo">
<p>
`応答の処理n^i は、
所与の
( `応答$ %競走~network要請に対する応答 )
に対し：
◎
processResponse set to the following steps given a response raceNetworkRequestResponse:
</p>
												<ol>
													<li>
<p>
この段は、［
%~fetch制御器 の`状態$fC ~IN { `terminated^l, `aborted^l }
］になった`ときは中止する$：
◎
Run these steps, but abort when fetchController’s state is "terminated" or "aborted".
</p>
														<ol>
															<li>
%競走~応答 の`値$rV ~SET %競走~network要請に対する応答
◎
Set raceResponse’s value to raceNetworkRequestResponse.
</li>
															<li>
<p>
~IF［
%競走~network要請に対する応答 の`状態s$rsは`~ok状態s$である
］：
◎
If raceNetworkRequestResponse’s status is ok status, then:
</p>
																<ol>
																	<li>
%競走~network結果 ~LET 新たな`競走~結果$
— その
⇒＃
`~route済み応答$rr ~SET %競走~network要請に対する応答,
`利用される~route$rr ~SET `network$l
◎
Let raceNetworkResult be a race result whose routed response is raceNetworkRequestResponse and used route is "network".
</li>
																	<li>
%~queue に %競走~network結果 を`~enqueueする$
◎
Enqueue raceNetworkResult to queue.
</li>
																</ol>
															</li>
														</ol>
<p>
`中止されたときは$：
◎
If aborted＼
</p>
														<ol>
															<li>
<p>
~IF［
%競走~fetch制御器 ~NEQ ~NULL
］：
◎
and raceFetchController is not null, then:
</p>
																<ol>
																	<li>
`~fetchを中止する$( %競走~fetch制御器 )
◎
Abort raceFetchController.
</li>
																	<li>
%競走~応答 ~SET 新たな`競走~応答$
— その
⇒＃
`値$rV ~SET ~NULL
◎
Set raceResponse to a race response whose value is null.
</li>
																</ol>
															</li>
														</ol>
													</li>
												</ol>
											</li>
										</ul>
									</li>
								</ol>
							</li>
							<li>
`~promiseを解決する$( %~preload応答~promise )
◎
Resolve preloadResponse with undefined.
</li>
							<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following substeps in parallel:
</p>
								<ol>
									<li>
%~fetch~handler応答 ~LET `~fetch~eventを作成して配送する$( ↓ )
⇒＃
%要請,
%登録,
%高分解能な処理能~timerを利用するか,
%計時~報,
%~worker~realm,
%予約-済み~client,
%~preload応答~promise,
%競走~応答
◎
Let fetchHandlerResponse be the result of Create Fetch Event and Dispatch with request, registration, useHighResPerformanceTimers, timingInfo, workerRealm, reservedClient, preloadResponse, and raceResponse.
</li>
									<li>
<p>
~IF［
~AND↓
］…
</p>
										<ul>
											<li>
%~fetch~handler応答 ~NEQ ~NULL
</li>
											<li>
%~fetch~handler応答 は`~network~error$でない
</li>
											<li>
%競走~fetch制御器 ~NEQ ~NULL
</li>
										</ul>
<p>
…ならば
⇒
`~fetchを中止する$( %競走~fetch制御器 )
</p>
◎
If fetchHandlerResponse is not null and not a network error, and raceFetchController is not null, abort raceFetchController.
</li>
									<li>
%競走~fetch~handler結果 ~LET 新たな`競走~結果$
— その
⇒＃
`~route済み応答$rr ~SET %~fetch~handler応答,
`利用される~route$rr ~SET `fetch-event$l
◎
Let raceFetchHandlerResult be a race result whose routed response is fetchHandlerResponse and used route is "fetch-event".
</li>
									<li>
%~queue に %競走~fetch~handler結果 を`~enqueueする$
◎
Enqueue raceFetchHandlerResult to queue.
</li>
								</ol>
							</li>
							<li>
次が満たされるまで待機する
⇒
%~queue は`空$でない
◎
Wait until queue is not empty.
</li>
							<li>
%結果 ~LET %~queue から`~dequeueする$
◎
Let result be the result of dequeue queue.
</li>
							<li>
%~route済み応答 ~LET %結果 の`~route済み応答$rr
◎
Let routedResponse be result’s routed response.
</li>
							<li>
~IF［
%~route済み応答 ~EQ ~NULL
］
⇒
~RET %計時~報
◎
If routedResponse is null:
• Return timingInfo.
</li>
							<li>
~IF［
%結果 の`利用される~route$rr ~EQ `network$l
］
⇒
%~route済み応答 の`~sw計時~報$ ~SET %計時~報
◎
If result’s used route is "network", then:
• Set routedResponse’s service worker timing info be set to timingInfo.
</li>
							<li>
%~route済み応答 の`~sw計時~報$の`~worker最終-~router~source$swT ~SET %結果 の`利用される~route$rr
◎
Set routedResponse’s service worker timing info’s worker final router source be set to result’s used route.
</li>
							<li>
~RET %~route済み応答
◎
Return routedResponse.
</li>
						</ol>
					</li>
					<li>
~Assert：
%~source ~EQ `fetch-event$l
◎
Assert: source is "fetch-event"
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If＼
</p>
		<ul>
			<li>
%要請 は`~navi要請$である
◎
request is a navigation request,＼
</li>
			<li>
%登録 の`~navi~preloadは可能化されるか$swr ~EQ ~T
◎
registration’s navigation preload enabled flag is set,＼
</li>
			<li>
%要請 の`~method$rq ~EQ `GET^bl
◎
request’s method is `GET`,＼
</li>
			<li>
`fetch$et ~IN %登録 にて`作動中な~worker$swrが`取扱う~event型の集合$sw ※
◎
registration’s active worker’s set of event types to handle contains fetch,＼
</li>
			<li>
%登録 にて`作動中な~worker$swrの`すべての~fetch~listenerは空か$sw ~EQ ~F
◎
and registration’s active worker’s all fetch listeners are empty flag is not set then:
</li>
		</ul>

<p class="note">注記：
これらの条件が， ※ を除いて満たされる場合、
開発者の意図は明瞭でないので，~UAは~consoleに警告を示したいと望むかもしれない。
◎
Note: If the above is true except registration’s active worker’s set of event types to handle does not contain fetch, then the user agent may wish to show a console warning, as the developer’s intent isn’t clear.
</p>

<p>
…ならば：
</p>
		<ol>
			<li>
%~preload要請 ~LET `要請を~cloneする$( %要請 )
◎
Let preloadRequest be the result of cloning the request request.
</li>
			<li>
%~preload要請~header群 ~LET %~preload要請 の`~header~list$rq
◎
Let preloadRequestHeaders be preloadRequest’s header list.
</li>
			<li>
<p>
%~preload応答~obj ~LET 
`~Response~objを作成する$( 新たな`応答$†, `immutable^l, %~worker~realm )
</p>

<p class="trans-note">【†
入力に渡す応答は、
形式上必要なものでしかなく，以下で置換されることになる。
】</p>
◎
Let preloadResponseObject be a new Response object associated with a new Headers object whose guard is "immutable".
</li>
			<li>
%~preload要請~header群 に`~headerを付加する$(
( `Service-Worker-Navigation-Preload^h, %登録 の`~navi~preload~header値$swr )
) 
◎
Append to preloadRequestHeaders a new header whose name is `Service-Worker-Navigation-Preload` and value is registration’s navigation preload header value.
</li>
			<li>
%~preload要請 の`~sw~mode$rq ~SET `none^l
◎
Set preloadRequest’s service-workers mode to "none".
</li>
			<li>
%~preload~fetch制御器 ~LET ~NULL
◎
Let preloadFetchController be null.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らすが、［
%~fetch制御器 の`状態$fC ~IN { `terminated^l, `aborted^l }
］になった`ときは中止する$
⇒
%~preload~fetch制御器 ~SET %~preload要請 を`~fetchする$
— 次を与える下で：
◎
Run the following substeps in parallel, but abort when fetchController’s state is "terminated" or "aborted":
• Set preloadFetchController to the result of fetching preloadRequest.
</p>
				<ul>
					<li class="algo">
<p>
`応答の処理n^i は、
所与の
( `応答$ %~navi~preload応答 )
に対し：
◎
To processResponse for navigationPreloadResponse, run these substeps:
</p>
						<ol>
							<li>
~IF［
%~navi~preload応答 の`種別$rs ~EQ `error^l
］
⇒
`~promiseを却下する$( %~preload応答~promise, `TypeError^E )
◎
If navigationPreloadResponse’s type is "error", reject preloadResponse with a TypeError＼
</li>
							<li>
<p>
~ELSE：
◎
and terminate these substeps.
</p>
								<ol>
									<li>
%~preload応答~obj の`応答$Rs ~SET %~navi~preload応答
◎
Associate preloadResponseObject with navigationPreloadResponse.
</li>
									<li>
`~promiseを解決する$( %~preload応答~promise, %~preload応答~obj )
◎
Resolve preloadResponse with preloadResponseObject.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ul>
<p>
`中止されたときは$：
◎
If aborted, then:
</p>
				<ol>
					<li>
%逆直列化された~error ~LET `直列化された中止-事由を逆直列化する$( ~NULL, %~worker~realm )
◎
Let deserializedError be the result of deserialize a serialized abort reason given null and workerRealm.
</li>
					<li>
`~fetchを中止する$( %~preload~fetch制御器, %逆直列化された~error )
◎
Abort preloadFetchController with deserializedError.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
`~promiseを解決する$( %~preload応答~promise )
◎
Else, resolve preloadResponse with undefined.
</li>
	<li>
%~fetch結果 ~LET `~fetch~eventを作成して配送する$( ↓ )
⇒＃
%要請,
%登録,
%高分解能な処理能~timerを利用するか,
%計時~報,
%~worker~realm,
%予約-済み~client,
%~preload応答~promise,
~NULL
◎
Let fetchResult be the result of Create Fetch Event and Dispatch with request, registration, useHighResPerformanceTimers, timingInfo, workerRealm, reservedClient, preloadResponse, and null.
</li>
	<li>
<p>
~IF［
%計時~報 の`~worker最終-~router~source$swT ~NEQ 空~文字列
］：
◎
If timingInfo’s worker final router source is not an empty string:
</p>
		<ol>
			<li>
~Assert：
%計時~報 の`~worker最終-~router~source$swT ~EQ `network$l
◎
Assert timingInfo’s worker final router source is "network".
</li>
			<li>
~IF［
%~fetch結果 ~NEQ ~NULL
］
⇒
~RET %計時~報
◎
If fetchResult is null, then return timingInfo.
</li>
			<li>
~Assert：
%~fetch結果 の`~sw計時~報$rsの`~worker最終-~router~source$swT ~EQ `network$l
◎
Else:
• Assert fetchResult’s service worker timing info’s worker final router source is "network".
</li>
			<li>
%~fetch結果 の`~sw計時~報$rsの`~worker最終-~router~source$swT ~SET `fetch-event$l
◎
• Set fetchResult’s service worker timing info’s worker final router source to "fetch-event".
</li>
		</ol>
	</li>
	<li>
~RET %~fetch結果
◎
Return fetchResult.
</li>
</ol>

		</section>
		<section id="create-fetch-event-and-dispatch-algorithm">
<h3 title="Create Fetch Event and Dispatch">`~fetch~eventを作成して配送する@</h3>

<p>
~algoは、
所与の
⇒＃
`要請$ %要請,
`~sw登録$ %登録,
真偽値 %高分解能な処理能~timerを利用するか,
`~sw計時~報$ %計時~報,
ある`大域~obj$swに`関連な~realm$ %~worker~realm,
`予約-済み~client$rq %予約-済み~client,
`~promise$ %~preload応答~promise,
［ `競走~応答$／ ~NULL ］ %競走~応答
◎終
に対し，［
ある`応答$／ ~NULL
］を返す：
◎
Input
• request, a request
• registration, a service worker registration
• useHighResPerformanceTimers, a boolean
• timingInfo, a service worker timing info
• workerRealm, a relevant realm of the global object
• reservedClient, a reserved client
• preloadResponse, a promise
• raceResponse, a race response or null
◎
Output
• a response or null
</p>
<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%~eventは取消されたか ~LET ~F
◎
Let eventCanceled be false.
</li>
	<li>
%~client ~LET %要請 の`~client$rq
◎
Let client be request’s client.
</li>
	<li>
%作動中な~worker ~LET %登録 にて`作動中な~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
%取扱った~event ~LET ~NULL
◎
Let eventHandled be null.
</li>
	<li>
%~fetchを取扱うのに失敗したか ~LET ~F
◎
Let handleFetchFailed be false.
</li>
	<li>
%~enteredで応答するか ~LET ~F
◎
Let respondWithEntered be false.
</li>
	<li>
%~network~error ~LET `~network~error$
◎
Let networkError be a network error.
</li>
	<li>
~IF［
%競走~応答 ~EQ ~NULL
］
⇒
%~network~error の`~sw計時~報$rs ~SET %計時~報
◎
If raceResponse is not null:
• Set networkError’s service worker timing info to timingInfo.
</li>
	<li>
%~soft更新すべきか ~LET ~IS［
%要請 は`非~下位資源~要請$である
］~OR［［
%要請 は`下位資源~要請$である
］~AND［
%登録 は`非新鮮$である
］］
◎
Let shouldSoftUpdate be true if any of the following are true, and false otherwise:
• request is a non-subresource request.
• request is a subresource request and registration is stale.
</li>
	<li>
<p>
~IF［
`~eventを飛ばすべきか？$( `fetch^l, %作動中な~worker ) ~EQ ~T
］：
◎
If the result of running the Should Skip Event algorithm with "fetch" and activeWorker is true, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~soft更新すべきか ~EQ ~T
］
⇒
次の手続きを`並列的$に走らす
◎
If shouldSoftUpdate is true, then in parallel run＼
</p>

<div class="algo">
手続きは
⇒
`~soft更新する$( %登録 )
◎
the Soft Update algorithm with registration.
</div>
			</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%作動中な~worker の`すべての~fetch~listenerは空か$sw ~EQ ~T
］：
◎
If activeWorker’s all fetch listeners are empty flag is set:
</p>
		<ol>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
In parallel:
</p>
				<ol>
					<li>
~IF［
%作動中な~worker の`状態$sw ~EQ `activating^l
］
⇒
次が満たされるまで待機する
⇒
%作動中な~worker の`状態$sw ~EQ `activated^l
◎
If activeWorker’s state is "activating", then wait for activeWorker’s state to become "activated".
</li>
					<li>
`~swを走らす$( %作動中な~worker )
◎
Run the Run Service Worker algorithm with activeWorker.
</li>
					<li>
~IF［
%~soft更新すべきか ~EQ ~T
］
⇒
`~soft更新する$( %登録 )
◎
If shouldSoftUpdate is true, then run the Soft Update algorithm with registration.
</li>
				</ol>
			</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
~IF［
%高分解能な処理能~timerを利用するか ~EQ ~T
］
⇒
%高分解能な処理能~timerを利用するか ~SET %作動中な~worker の`大域~obj$swの`非同一-生成元~能力は隔離されるか$wG
◎
If useHighResPerformanceTimers is true, then set useHighResPerformanceTimers to activeWorker’s global object’s cross-origin isolated capability.
</li>
	<li>
%計時~報 の`開始~時刻$swT ~LET `粗化した共有される現在の時刻$( %高分解能な処理能~timerを利用するか )
◎
Let timingInfo’s start time be the coarsened shared current time given useHighResPerformanceTimers.
</li>
	<li>
~IF［
%作動中な~worker の`状態$sw ~EQ `activating^l
］
⇒
%作動中な~worker の`状態$sw ~EQ `activated^l になるまで待機する
◎
If activeWorker’s state is "activating", wait for activeWorker’s state to become "activated".
</li>
	<li>
~IF［
`~swを走らす$( %作動中な~worker ) ~EQ `失敗^i
］
⇒
%~fetchを取扱うのに失敗したか ~SET ~T
◎
If the result of running the Run Service Worker algorithm with activeWorker is failure, then set handleFetchFailed to true.
</li>
	<li>
<p>
~ELSE：
◎
Else:
</p>
		<ol>
			<li>
%~worker~realm ~SET %作動中な~worker の`大域~obj$swに`関連な~realm$
◎
Set workerRealm to the relevant realm of the activeWorker’s global object.
</li>
			<li>
%取扱った~event ~SET %~worker~realm 内の`新たな~promise$
◎
Set eventHandled to a new promise in workerRealm.
</li>
			<li>
~IF［
%競走~応答 ~NEQ ~NULL
］
⇒
%作動中な~worker の`大域~obj$swの`競走~応答~map$SWG[ %要請 ] ~SET %競走~応答
◎
If raceResponse is not null, set activeWorker’s global object’s race response map[request] to raceResponse.
</li>
			<li>
<p>
%~task ~LET `~taskを~queueする$( `~fetchを取扱う~task~source$, 次の手続き, %作動中な~worker の`~event~loop$ )
◎
Queue a task task to run
</p>

<div class="algo">
<p>
手続きは：
◎
the following substeps:
</p>
				<ol>
					<li>
%~event ~LET `~eventを作成する$( `FetchEvent$I )
◎
Let e be the result of creating an event with FetchEvent.
</li>
					<li>
%中止-制御器 ~LET `新たな~obj$( `AbortController$I, %~worker~realm )
◎
Let abortController be a new AbortController object with workerRealm.
</li>
					<li>
%要請~obj ~LET `~Request~objを作成する$( %要請, `immutable^l, %中止-制御器 の`通達$aC, %~worker~realm )
◎
Let requestObject be the result of creating a Request object, given request, a new Headers object’s guard which is "immutable", abortController’s signal, and workerRealm.
</li>
					<li>
%~event の各種~属性を次のように初期化する
⇒＃
`type$n 属性 ~SET `fetch$et,
`cancelable$n 属性 ~SET ~T,
`FetchEvent^I1`request$m1 属性 ~SET %要請~obj,
`preloadResponse$m1 ~SET %~preload応答~promise,
`clientId$m1 属性 ~SET %~client の`~ID$enV,
`resultingClientId$m1 属性 ~SET 空~文字列,
`replacesClientId$m1 属性 ~SET 空~文字列,
`handled$m1 属性 ~SET %取扱った~event
◎
Initialize e’s type attribute to fetch.
◎
Initialize e’s cancelable attribute to true.
◎
Initialize e’s request attribute to requestObject.
◎
Initialize e’s preloadResponse to preloadResponse.
◎
Initialize e’s clientId attribute to client’s id.
◎
↓</li>
					<li>
~IF［
%要請 は`非~下位資源~要請$である
］~AND［
%要請 の`行先$rq ~NEQ `report^l【！TODO `report$l】
］
⇒
%~event の `resultingClientId$m1 属性 ~SET %予約-済み~client の`~ID$enV
◎
If request is a non-subresource request and request’s destination is not "report", initialize e’s resultingClientId attribute to reservedClient’s id,＼
↑ and to the empty string otherwise.
</li>
					<li>
~IF［
%要請 は`~navi要請$である
］
⇒
%~event の `replacesClientId$m1 属性 ~SET %要請 の`置換する~client~ID$rq
◎
If request is a navigation request, initialize e’s replacesClientId attribute to request’s replaces client id,＼
↑ and to the empty string otherwise.
◎
↑ Initialize e’s handled to eventHandled.
</li>
					<li>
%計時~報 の`~fetch~event配送-時刻$swT ~LET 
`粗化した共有される現在の時刻$( %高分解能な処理能~timerを利用するか )
◎
Let timingInfo’s fetch event dispatch time to the coarsened shared current time given useHighResPerformanceTimers.
</li>
					<li>
`~eventを配送する$( %作動中な~worker の`大域~obj$sw, %~event )
◎
Dispatch e at activeWorker’s global object.
</li>
					<li>
`~sw延長-済み~event集合を更新する$( %作動中な~worker, %~event )
◎
Invoke Update Service Worker Extended Events Set with activeWorker and e.
</li>
					<li>
~IF［
%~event の`~enteredで応答するか$FE ~EQ ~T
］
⇒
%~enteredで応答するか ~SET ~T
◎
If e’s respond-with entered flag is set, set respondWithEntered to true.
</li>
					<li>
<p>
~IF［
%~event の`応答するまで待機-中か$FE ~EQ ~T
］：
◎
If e’s wait to respond flag is set, then:
</p>
						<ol>
							<li>
次が満たされるまで待機する
⇒
%~event の`応答するまで待機-中か$FE ~EQ ~F
◎
Wait until e’s wait to respond flag is unset.
</li>
							<li>
~IF［
%~event の`~errorで応答するか$FE ~EQ ~T
］
⇒
%~fetchを取扱うのに失敗したか ~SET ~T
◎
If e’s respond-with error flag is set, set handleFetchFailed to true.
</li>
							<li>
~ELSE
⇒
%応答 ~SET %~event の`応答になり得る$FE
◎
Else, set response to e’s potential response.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%応答 ~EQ ~NULL
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］：
◎
If response is null, request’s body is not null, and request’s body’s source is null, then:
</p>
						<ol>
							<li>
~IF［
%要請 の`本体$rqは`利用-不能$Bdである
］
⇒
%~fetchを取扱うのに失敗したか ~SET ~T
◎
If request’s body is unusable, set handleFetchFailed to true.
</li>
							<li>
~ELSE
⇒
%要請 の`本体$rqを`取消す$RS( `undefined^jv )
◎
Else, cancel request’s body with undefined.
</li>
						</ol>
					</li>
					<li>
~IF［
%応答 ~NEQ ~NULL
］
⇒
%応答 の`~sw計時~報$rs ~SET %計時~報
◎
If response is not null, then set response’s service worker timing info to timingInfo.
</li>
					<li>
~IF［
%~event の`取消されたか$ev ~EQ ~T
］
⇒
%~eventは取消されたか ~SET ~T
◎
If e’s canceled flag is set, set eventCanceled to true.
</li>
					<li>
<p>
~IF［
%~fetch制御器【 %中止-制御器 ？】 の`状態$fC ~IN { `terminated^l, `aborted^l }
］：
◎
If fetchController state is "terminated" or "aborted", then:
</p>
						<ol>
							<li>
%逆直列化された~error ~LET `直列化された中止-事由を逆直列化する$( %~fetch制御器【 %中止-制御器 ？】 の`直列化された中止-事由$, %~worker~realm )
◎
Let deserializedError be the result of deserialize a serialized abort reason given fetchController’s serialized abort reason and workerRealm.
</li>
							<li>
<p>
`~taskを~queueする$( `~fetchを取扱う~task~source$, 次の手続き, %作動中な~worker の`~event~loop$ )
</p>

<div class="algo">
手続きは
⇒
`中止-を通達する$aC( %中止-制御器, %逆直列化された~error )
</div>
◎
Queue a task to signal abort on abortController with deserializedError.
</li>
						</ol>
					</li>
				</ol>
</div>

<div class="algo">
%~task が破棄されたときは
⇒
%~fetchを取扱うのに失敗したか ~SET ~T
◎
If task is discarded, set handleFetchFailed to true.
◎
↑↑ The task must use activeWorker’s event loop and the handle fetch task source.
</div>
			</li>
		</ol>
	</li>
	<li>
%~task が実行されるか次が満たされるまで待機する
⇒
%~fetchを取扱うのに失敗したか ~EQ ~T
◎
Wait for task to have executed or for handleFetchFailed to be true.
</li>
	<li>
<p>
~IF［
%~soft更新すべきか ~EQ ~T
］
⇒
次の手続きを`並列的$に走らす
◎
If shouldSoftUpdate is true, then in parallel run＼
</p>

<div class="algo">
手続きは
⇒
`~soft更新する$( %登録 )
◎
the Soft Update algorithm with registration.
</div>
	</li>
	<li>
%作動中な~worker の`大域~obj$swの`競走~応答~map$SWG[ %要請 ] ~SET ε
◎
If activeWorker’s global object’s race response map[request] exists, remove activeWorker’s global object’s race response map[request].
</li>
	<li>
<p>
~IF［
%~enteredで応答するか ~EQ ~F
］：
◎
If respondWithEntered is false, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~eventは取消されたか ~EQ ~T
］：
◎
If eventCanceled is true, then:
</p>
				<ol>
					<li>
~IF［
%取扱った~event ~NEQ ~NULL
］
⇒
`~promiseを却下する$( %取扱った~event, %~worker~realm 内の `NetworkError$E 例外 )
◎
If eventHandled is not null, then reject eventHandled with a "NetworkError" DOMException in workerRealm.
</li>
					<li>
~RET %~network~error
◎
Return networkError.
</li>
				</ol>
			</li>
			<li>
~IF［
%取扱った~event ~NEQ ~NULL
］
⇒
`~promiseを解決する$( %取扱った~event )
◎
If eventHandled is not null, then resolve eventHandled.
</li>
			<li>
<p>
~IF［
%競走~応答 ~NEQ ~NULL
］~AND［
%競走~応答 の`値$rV ~NEQ ~NULL
］：
◎
If raceResponse is not null, and raceResponse’s value is not null, then:
</p>
				<ol>
					<li>
次が満たされるまで待機する
⇒
%競走~応答 の`値$rV ~NEQ `pending^l
◎
Wait until raceResponse’s value is not "pending".
</li>
					<li>
~IF［
%競走~応答 の`値$rVは`応答$である
］
⇒
~RET %競走~応答 の`値$rV
◎
If raceResponse’s value is a response, return raceResponse’s value.
</li>
				</ol>
			</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~fetchを取扱うのに失敗したか ~EQ ~T
］：
◎
If handleFetchFailed is true, then:
</p>
		<ol>
			<li>
~IF［
%取扱った~event ~NEQ ~NULL
］
⇒
`~promiseを却下する$( %取扱った~event, %~worker~realm 内の `NetworkError$E 例外 )
◎
If eventHandled is not null, then reject eventHandled with a "NetworkError" DOMException in workerRealm.
</li>
			<li>
~RET %~network~error
◎
Return networkError
</li>
		</ol>
	</li>
	<li>
~IF［
%取扱った~event ~NEQ ~NULL
］
⇒
`~promiseを解決する$( %取扱った~event )
◎
If eventHandled is not null, then resolve eventHandled.
</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

		</section>
		<section id="parse-urlpattern-algorithm">
<h3 title="Parse URL Pattern">`~URL~patternを構文解析する@</h3>

<p>
~algoは、
所与の
⇒＃
`URLPatternCompatible$I %ナマ~pattern
`~sw$ %~sw
◎終
に対し，ある`~URL~pattern$を返す：
◎
Input
• rawPattern, a URLPatternCompatible
• serviceWorker, a service worker
◎
Output
• A URL pattern
</p>
<ol>
	<li>
%基底~URL ~LET %~sw の`~script~URL$sw
◎
Let baseURL be serviceWorker’s script url.
</li>
	<li>
~RET `~Web~IDL値から~URL~patternを築く$( %ナマ~pattern, %基底~URL )
◎
Return the result of building a URL pattern from a Web IDL value rawPattern given baseURL.
</li>
</ol>

		</section>
		<section id="verify-router-rule-algorithm">
<h3 title="Verify Router Condition">`~router条件を検証yする@</h3>

<p>
~algoは、
所与の
⇒＃
`RouterCondition$I %条件
%~sw `~sw$
◎終
に対し，ある真偽値を返す：
◎
Input
• condition, a RouterCondition
• serviceWorker, a service worker
◎
Output
• a boolean
</p>
`RouterCondition^I1
<ol>
	<li>
%条件は在るか ~LET ~F
◎
Let hasCondition be false.
</li>
	<li>
%ナマ~pattern ~LET %条件[ "`urlPattern$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%ナマ~pattern ~NEQ ε
］：
◎
If condition["urlPattern"] exists, then:
• Let rawPattern be condition["urlPattern"].
</p>
		<ol>
			<li>
<p>
%~pattern ~LET `~URL~patternを構文解析する$( %ナマ~pattern, %~sw )
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~RET ~F
</p>
◎
Let pattern be the result of running the Parse URL Pattern algorithm passing rawPattern and serviceWorker. If this throws an exception, catch it and return false.
</li>
			<li>
<p>
~IF［
%~pattern は`~regexp~groupを有して$いる
］
⇒
~RET ~F
◎
If pattern has regexp groups, then return false.
</p>

<p class="note">注記：
利用者~定義な正規表現は、
禁制される
— それを走らすことには、
~securityの懸念があるので。
◎
Note: Since running a user-defined regular expression has a security concern, it is prohibited.
</p>
			</li>
			<li>
%条件は在るか ~SET ~T
◎
Set hasCondition to true.
</li>
		</ol>
	</li>
	<li>
%~method ~LET %条件[ "`requestMethod$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%~method ~NEQ ε
］：
◎
If condition["requestMethod"] exists:
• Let method be condition["requestMethod"].
</p>
		<ol>
			<li>
~IF［
%~method は`~method$でない
］
⇒
~RET ~F
◎
If method is not a method, then return false.
</li>
			<li>
~IF［
%~method は`禁止~method$である
］
⇒
~RET ~F
◎
If method is a forbidden method, then return false.
</li>
			<li>
%条件は在るか ~SET ~T
◎
Set hasCondition to true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%条件[ "`requestMode$m1" ] ~NEQ ε
</li>
			<li>
%条件[ "`requestDestination$m1" ] ~NEQ ε
</li>
			<li>
%条件[ "`runningStatus$m1" ] ~NEQ ε
</li>
		</ul>
<p>
…ならば
⇒
%条件は在るか ~SET ~T
</p>
◎
If condition["requestMode"] exists, set hasCondition to true.
◎
If condition["requestDestination"] exists, set hasCondition to true.
◎
If condition["runningStatus"] exists, set hasCondition to true.
</li>
	<li>
%~or条件~群 ~LET %条件[ "`or$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%~or条件~群 ~NEQ ε
］：
◎
If condition["_or"] exists, then:
</p>
		<ol>
			<li>
<p>
~IF［
%条件は在るか ~EQ ~T
］
⇒
~RET ~F
◎
If hasCondition is true, return false.
</p>

<p class="note">注記：
~router規則を理解し易くするため、
%~or条件~群 と他の条件は，互いに排他的である。
【言い換えれば、両者が在る場合，当の規則は無視される。】
◎
Note: For ease of understanding the router rule, the "or" condition is mutually exclusive with other conditions.
</p>
			</li>
			<li>
%~or条件~群 を成す
~EACH( %~or条件 )
に対し
⇒
~IF［
`~router条件を検証yする$( %~or条件, %~sw ) ~EQ ~F
］
⇒
~RET ~F
◎
Let orConditions be condition["_or"].
◎
For each orCondition of orConditions:
• If running the Verify Router Condition algorithm with orCondition and serviceWorker returns false, return false.
</li>
			<li>
%条件は在るか ~SET ~T
◎
Set hasCondition to true.
</li>
		</ol>
	</li>
	<li>
%~not条件 ~LET %条件[ "`not$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%~not条件 ~NEQ ε
］：
◎
If condition["not"] exists, then:
</p>
		<ol>
			<li>
<p>
~IF［
%条件は在るか ~EQ ~T
］
⇒
~RET ~F
◎
If hasCondition is true, return false.
</p>

<p class="note">注記：
~router規則を理解し易くするため、
%~not条件 と他の条件は，互いに排他的である。
【言い換えれば、両者が在る場合，当の規則は無視される。】
◎
Note: For ease of understanding the router rule, the "not" condition is mutually exclusive with other conditions.
</p>
			</li>
			<li>
~IF［
`~router条件を検証yする$( %~not条件, %~sw ) ~EQ ~F
］
⇒
~RET ~F
◎
If running the Verify Router Condition algorithm with condition["not"] and serviceWorker returns false, return false.
</li>
			<li>
%条件は在るか ~SET ~T
◎
Set hasCondition to true.
</li>
		</ol>
	</li>
	<li>
~RET %条件は在るか
◎
Return hasCondition.
</li>
</ol>

		</section>
		<section id="match-router-condition-algorithm">
<h3 title="Match Router Condition">`~router条件を照合する@</h3>

<p>
~algoは、
所与の
⇒＃
`RouterCondition$I %条件,
`~sw$ %~sw,
`要請$ %要請
◎終
に対し，ある真偽値を返す：
◎
Input
• condition, a RouterCondition
• serviceWorker, a service worker
• request, a request
◎
Output
• a boolean
</p>
`RouterCondition^I1

<p class="note">注記：
複数の条件が在る場合
（例：
`urlPattern$m1, `runningStatus$m1, `requestMethod$m1 が設定された）、
照合されるすべての条件が ~T を返す必要がある。
◎
Note: if there are multiple conditions (e.g. urlPattern, runningStatus, and requestMethod are set), all conditions need to match for true to be returned.
</p>
<ol>
	<li>
%~or条件~群 ~LET %条件[ "`or$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%~or条件~群 ~NEQ ε
］：
◎
If condition["or"] exists, then:
• Let orConditions be condition["or"].
</p>
		<ol>
			<li>
%~or条件~群 を成す
~EACH( %~or条件 )
に対し
⇒
~IF［
`~router条件を照合する$( %~or条件, %~sw, %要請 ) ~EQ ~T
］
⇒
~RET ~T
◎
For each orCondition of orConditions:
• If running the Match Router Condition algorithm with orCondition, serviceWorker and request returns true, then return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
%~not条件 ~LET %条件[ "`not$m1" ]
◎
↓</li>
	<li>
<p>
~IF［
%~not条件 ~NEQ ε
］
⇒
~RET ~IS［
`~router条件を照合する$( %~not条件, %~sw, %要請 ) ~EQ ~F
］
◎
If condition["not"] exists, then:
• If running the Match Router Condition algorithm with condition["not"], serviceWorker and request returns true, then return false.
• Return true.
</li>
	<li>
<p>
~ELSE：
◎
Else:
</p>

<p class="note">注記：
この~algoに先立って，`~router条件を検証yする$ので、［
`or$m1, `not$m1, 他のいずれか任意の~member
］による条件は，互いに排他的になる
【どれかが ε でないならば他は ε になる】
ことが保証される。
◎
Note: The Verify Router Condition algorithm guarantees that or, not, and other conditions are mutually exclusive.
</p>
		<ol>
			<li>
%ナマ~pattern ~LET %条件[ "`urlPattern$m1" ]
◎
↓</li>
			<li>
<p>
~IF［
%ナマ~pattern ~NEQ ε
］：
◎
If condition["urlPattern"] exists, then:
• Let rawPattern be condition["urlPattern"].
</p>
				<ol>
					<li>
%~pattern ~LET `~URL~patternを構文解析する$( %ナマ~pattern, %~sw )
◎
Let pattern be the result of running the Parse URL Pattern algorithm passing rawPattern and serviceWorker.
</li>
					<li>
~IF［
`~patternを照合する$( %~pattern, %要請 の`~URL$rq ) ~EQ ~NULL
］
⇒
~RET ~F
◎
If running match with pattern and request’s URL returns null, return false.
</li>
				</ol>
			</li>
			<li>
%~method ~LET %条件[ "`requestMethod$m1" ]
◎
↓</li>
			<li>
~IF［
%~method ~NEQ ε
］~AND［
%要請 の`~method$rq ~NEQ `~methodを正規化する$( %~method )
］
⇒
~RET ~F
◎
If condition["requestMethod"] exists, then:
• Let method be condition["requestMethod"].
• Normalize method.
• If request’s method is not method, return false.
</li>
			<li>
%~mode ~LET %条件[ "`requestMode$m1" ]
◎
↓</li>
			<li>
~IF［
%~mode ~NEQ ε
］~AND［
%要請 の`~mode$rq ~NEQ %~mode
］
⇒
~RET ~F
◎
If condition["requestMode"] exists, then:
• Let mode be condition["requestMode"].
• If request’s mode is not mode, return false.
</li>
			<li>
%行先 ~LET %条件[ "`requestDestination$m1" ]
◎
↓</li>
			<li>
~IF［
%行先 ~NEQ ε
］~AND［
%要請 の`行先$rq ~NEQ %行先
］
⇒
~RET ~F
◎
If condition["requestDestination"] exists, then:
• Let destination be condition["requestDestination"].
• If request’s destination is not destination, return false.
</li>
			<li>
%走っているか否か ~LET %条件[ "`runningStatus$m1" ]
◎
↓</li>
			<li>
<p>
~IF［
%走っているか否か ~NEQ ε
］：
</p>
				<ol>
					<li>
~IF［
%走っているか否か ~EQ `running$l
］~AND［
~NOT %~sw は`走っている$
］
⇒
~RET ~F
</li>
					<li>
~IF［
%走っているか否か ~EQ `not-running$l
］~AND［
%~sw は`走っている$
］
⇒
~RET ~F
</li>
				</ol>
◎
If condition["runningStatus"] exists, then:
• Let runningStatus be condition["runningStatus"].
• If runningStatus is "running", and serviceWorker is not running, return false.
• If runningStatus is "not-running", and serviceWorker is running, return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="check-router-registration-limit-algorithm">
<h3 title="Check Router Registration Limit">`~router登録~上限を検査する@</h3>

<p>
~algoは、
所与の
⇒＃
`~router規則~list$sw %~router規則~群
◎終
に対し，ある真偽値を返す：
◎
Input
• routerRules, a list of router rules
◎
Output
• a boolean
</p>

<div class="note">
<p>注記：
~router条件は、［
`RouterCondition^I1
`or$m1, `not$m1
］を利用して入子にされ得るなど，複階的なこともある。
過度な処理を防止するため、
この~algoは，次に挙げる上限を導入する：
◎
Note: Router conditions can be complex and nested using _or and not. To prevent excessive processing, this algorithm introduces two limits.＼
</p>
<ul>
	<li>
条件の総数
は、
入子にされた条件もすべて数えて，
1024 を超過し得ない。
◎
First, the total number of conditions, counting all nested conditions, cannot exceed 1024.＼
</li>
	<li>
指数関数的な算出を避けるため、
入子ng深さは 10 ~levelまでに制限される。
◎
Second, the nesting depth is limited to 10 levels to avoid exponential computation.
</li>
</ul>
</div>

<ol>
	<li>
%結果 ~LET `~router条件を数えた結果$
— その
⇒＃
`条件~計数$rcR ~SET 1024,
`~quotaを超過したか$rcR ~SET ~F
◎
Let result be a count router condition result.
◎
Set result’s condition count to 1024.
◎
Set result’s quota exceeded to false.
</li>
	<li>
<p>
%~router規則~群 を成す
~EACH( %規則 )
に対し：
◎
For each rule of routerRules:
</p>
		<ol>
			<li>
%結果 ~SET `~router内縁~条件~群を数える$( %規則[ `RouterRule^I1"`condition$m1" ], %結果, 10 )
◎
Set result to be the result of running Count Router Inner Conditions with rule["condition"], result, and 10.
</li>
			<li>
~IF［
%結果 の`~quotaを超過したか$rcR ~EQ ~T
］
⇒
~RET ~F
◎
If result’s quota exceeded is true, return false.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

		</section>
		<section id="count-router-inner-conditions-algorithm">
<h3 title="Count Router Inner Conditions">`~router内縁~条件~群を数える@</h3>

<p>
~algoは、
所与の
⇒＃
`RouterCondition$I1 %条件
`~router条件を数えた結果$ %結果
~number【負でない整数】 %深さ
◎終
に対し，ある`~router条件を数えた結果$を返す：
◎
Input
• condition, a RouterCondition
• result, a count router condition result
• depth, a number
◎
Output
• result, a count router condition result
</p>

<ol>
	<li>
%結果 の`条件~計数$rcR ~DECBY 1
◎
Decrement result’s condition count by one.
</li>
	<li>
<p>
~IF［
%結果 の`条件~計数$rcR ~EQ 0
］~OR［
%深さ ~EQ 0
］：
◎
If result’s condition count is zero, or depth is zero, then:
</p>
		<ol>
			<li>
%結果 の`~quotaを超過したか$rcR ~SET ~T
◎
Set result’s quota exceeded to be true.
</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%条件[ "`or$m1" ] ~NEQ ε
］：
◎
If condition["_or"] exists, then:
</p>
		<ol>
			<li>
%深さ ~DECBY 1
◎
Decrement depth by one.
</li>
			<li>
<p>
%条件[ "`or$m1" ] を成す
~EACH( %~or条件 )
に対し：
◎
For each orCondition of condition["_or"]:
</p>
				<ol>
					<li>
%結果 ~SET `~router内縁~条件~群を数える$( %~or条件, %結果, %深さ )
◎
Set result to be the result of running Count Router Inner Conditions with orCondition, result, and depth.
</li>
					<li>
~IF［
%結果 の`~quotaを超過したか$rcR ~EQ ~T
］
⇒
~RET %結果
◎
If result’s quota exceeded is true, return result.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%条件[ "`not$m1" ] ~NEQ ε
］：
◎
Else if condition["not"] exists, then:
</p>
		<ol>
			<li>
%深さ ~DECBY 1
◎
Decrement depth by one.
</li>
			<li>
%結果 ~SET`~router内縁~条件~群を数える$( %条件[ "`not$m1" ], %結果, %深さ )
◎
Set result to be the result of running Count Router Inner Conditions with condition["not"], result, and depth.
</li>
			<li>
~IF［
%結果 の`~quotaを超過したか$rcR ~EQ ~T
］
⇒
~RET %結果
◎
If result’s quota exceeded is true, return result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

		</section>
		<section id="get-router-source-algorithm">
<h3 title="Get Router Source">`~router~sourceを取得する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw$ %~sw,
`要請$ %要請
◎終
に対し，［
ある `RouterSource$I ／ ~NULL
］を返す：
◎
Input
• serviceWorker, a service worker
• request, a request
◎
Output
• RouterSource or null
</p>
`RouterRule^I1
<ol>
	<li>
%~sw の`~router規則~list$swを成す
~EACH( %規則 )
に対し
⇒
~IF［
`~router条件を照合する$( %規則[ "`condition$m1" ], %~sw, %要請 ) ~EQ ~T
］
⇒
~RET %規則[ "`source$m1" ]
◎
For each rule of serviceWorker’s list of router rules:
• If running the Match Router Condition algorithm with rule["condition"], serviceWorker and request returns true, then return rule["source"].
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

		</section>
		<section id="should-skip-event-algorithm">
<h3 title="Should Skip Event">`~eventを飛ばすべきか？@</h3>

<p>
~algoは、
所与の
⇒＃
文字列 %~event名,
`~sw$ %~sw
◎終
に対し，ある真偽値を返す：
◎
Input
• eventName, a string
• serviceWorker, a service worker
◎
Output
• a boolean
</p>

<p class="note">注記：
不必要な遅延を避けるため、
この仕様は，次を許可する
⇒
次が決定可能ならば，［
%~event名 用の~event配送-
］を飛ばす
⇒
~script実行の最初期の間に， %~sw の大域~objに追加された［
%~event名 用の~event~listener
］は無い
◎
Note: To avoid unnecessary delays, this specification permits skipping event dispatch when no event listeners for the event have been deterministically added in the service worker’s global during the very first script execution.
</p>

<ol>
	<li>
~IF［
%~event名 ~IN %~sw が`取扱う~event型の集合$sw
］
⇒
~RET ~F
◎
↓</li>
	<li>
~UAは次をしても`ヨイ^em
⇒
~RET ~T
◎
If serviceWorker’s set of event types to handle does not contain eventName, then the user agent may return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

		</section>
		<section id="fire-functional-event-algorithm">
<h3 title="Fire Functional Event">`機能的~eventを発火する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録,
文字列 %~event名,
`ExtendableEvent$I を拡張する~event構築子 %~event構築子,
%~event構築子 で構築される~event用の~propを初期化する~~指示書き %初期化 ~DF ε,
構築された~eventを引数に`作動中な~worker$swrの~event~loopを走らす手続き %配送-後~手続き ~DF ε
◎終
に対し：
◎
Input
• eventName, a string
• eventConstructor, an event constructor that extends ExtendableEvent
• registration, a service worker registration
• initialization, optional property initialization for event, constructed from eventConstructor
• postDispatchSteps, optional steps to run on the active worker’s event loop, with dispatchedEvent set to the instance of eventConstructor that was dispatched.
◎
Output
• None
</p>
<ol>
	<li>
~Assert：
%登録 にて`作動中な~worker$swr ~NEQ ~NULL
◎
Assert: registration’s active worker is not null.
</li>
	<li>
%作動中な~worker ~LET %登録 にて`作動中な~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
<p>
`(A)^i：
</p>
		<ol>
			<li>
~IF［
`~eventを飛ばすべきか？$( %~event名, %作動中な~worker ) ~EQ ~T
］
⇒
~BREAK `(A)^i
◎
If the result of running Should Skip Event with eventName and activeWorker is true, then:
• If registration is stale, then in parallel run the Soft Update algorithm with registration.
• Return.
</li>
			<li>
~IF［
%作動中な~worker の`状態$sw ~EQ `activating^l
］
⇒
次が満たされるまで待機する
⇒
%作動中な~worker の`状態$sw ~EQ `activated^l
◎
If activeWorker’s state is "activating", wait for activeWorker’s state to become "activated".
</li>
			<li>
<p>
~IF［
`~swを走らす$( %作動中な~worker ) ~EQ `失敗^i
］
⇒
~BREAK `(A)^i
◎
If the result of running the Run Service Worker algorithm with activeWorker is failure, then:
• If registration is stale, then in parallel run the Soft Update algorithm with registration.
• Return.
</li>
			<li>
<p>
%~task ~LET `~taskを~queueする$( `機能的~eventを取扱う~task~source$, 次の手続き, %作動中な~worker の`~event~loop$ )
◎
Queue a task task to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
these substeps:
</p>
				<ol>
					<li>
%~event ~LET `~eventを作成する$( %~event構築子, %作動中な~worker の`大域~obj$swに`関連な~realm$ )
◎
Let event be the result of creating an event with eventConstructor and the relevant realm of activeWorker’s global object.
</li>
					<li>
~IF［
%初期化 ~NEQ ε
］
⇒
%初期化 に従って %~event を初期化する
◎
If initialization is not null, then initialize event with initialization.
</li>
					<li>
`~eventを配送する$( %作動中な~worker の`大域~obj$sw, %~event ) 
◎
Dispatch event on activeWorker’s global object.
</li>
					<li>
`~sw延長-済み~event集合を更新する$( %作動中な~worker, %~event )
◎
Invoke Update Service Worker Extended Events Set with activeWorker and event.
</li>
					<li>
~IF［
%配送-後~手続き ~NEQ ε
］
⇒
%~event を渡して， %配送-後~手続き を走らす
◎
If postDispatchSteps is not null, then run postDispatchSteps passing event as dispatchedEvent.
</li>
				</ol>
</div>
			</li>
			<li>
%~task が実行されるか破棄されるまで待機する
◎
↑The task must use activeWorker’s event loop and the handle functional event task source.
◎
Wait for task to have executed or been discarded.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%登録 は`非新鮮$である
］
⇒
次の手続きを`並列的$に走らす
</p>
<div class="algo">
手続きは
⇒
`~soft更新する$( %登録 )
</div>
◎
If registration is stale, then in parallel run the Soft Update algorithm with registration.
</li>
</ol>

<div class="example">

<p>
特定0の %~sw登録 に向けて，（ `AmazingThingEvent^I 型の） `amazingthing^et ~eventを
— その各種~propを初期化した上で —
発火するときの注釈文は、
次のようになる：
◎
To fire an "amazingthing" event (which is of type AmazingThingEvent) on a particular serviceWorkerRegistration, and initialize the event object’s properties, the prose would be:
</p>

<ol>
	<li>
`機能的~eventを発火する$( %~sw登録, `amazingthing^et, `AmazingThingEvent^I )
— 次のように初期化して
⇒＃
`ある~prop名^i ~SET 何らかの値,
`別の~prop名^i ~SET 別の値
◎
Fire Functional Event "amazingthing" using AmazingThingEvent on serviceWorkerRegistration with the following properties:
◎
propertyName
• value
◎
anotherPropertyName
• anotherValue
</li>
	<li>
%配送した~event ~LET 前~段にて配送した~event
◎
Then run the following steps with dispatchedEvent:
</li>
	<li>
%配送した~event を用いて，当の~swの~event~loop上で行う必要がある何かをする
◎
Do whatever you need to with dispatchedEvent on the service worker’s event loop.
</li>
</ol>

<p>
初期化~手続き, 配送-後の手続きは任意選択~であることに注意。
必要なければ、
注釈文は次のようになる：
◎
Note that the initialization steps and post-dispatch steps are optional. If they aren’t needed, the prose would be:
</p>

<ol>
	<li>
`機能的~eventを発火する$( %~sw登録, `whatever^et, `ExtendableEvent$I )
◎
Fire Functional Event "whatever" using ExtendableEvent on serviceWorkerRegistration.
</li>
</ol>

</div>

		</section>
		<section id="on-client-unload-algorithm">
<h3 title="Handle Service Worker Client Unload">`~sw~clientを~unloadする@</h3>

<p>
~UAは、［
`文書~unload時の片付け手続き$／~swの`終了n$
］を介して`~sw~client$を~unloadするときは、
この手続きを走らすモノトスル。
◎
The user agent must run these steps as part of when a service worker client unloads via unloading document cleanup steps or termination.
</p>
<p>
~algoは、
所与の
⇒＃
`~sw~client$ %~client
◎終
に対し
— 以下の手続きは`不可分に走らす$とする†：
◎
Input
• client, a service worker client
◎
Output
• None
◎
Run the following steps atomically.
</p>

<p class="trans-note">【†
この句
`不可分に走らす@
が何を意図しているのか よくわからない
— 一般に，~algoは、
並列的に走らすよう指示されない限り，不可分に走ることになるので。
他の~algoにおける同じ句も同様。
】</p>
<ol>
	<li>
%登録 ~LET %~client が`利用して$いる`~sw登録$
◎
Let registration be the service worker registration used by client.
</li>
	<li>
~IF［
%登録 ~EQ ~NULL
］
⇒
~RET
◎
If registration is null, abort these steps.
</li>
	<li>
~IF［
%~client 以外に， %登録 を`利用して$いる`~sw~client$はある
］
⇒
~RET
◎
If any other service worker client is using registration, abort these steps.
</li>
	<li>
~IF［
%登録 は`未登録にされて$いる
］
⇒
`登録を~clearするよう試行する$( %登録 )
◎
If registration is unregistered, invoke Try Clear Registration with registration.
</li>
	<li>
`作動化するよう試行する$( %登録 )
◎
Invoke Try Activate with registration.
</li>
</ol>

		</section>
		<section id="on-user-agent-shutdown-algorithm">
<h3 title="Handle User Agent Shutdown">`~UA~shutdownを取扱う@</h3>

<p>
~algoは：
◎
Input
• None
◎
Output
• None
</p>
<ol>
	<li>
%登録~list ~LET `登録~map$の`値~群$map
◎
↓</li>
	<li>
<p>
%登録~list を成す
~EACH( %登録 )
に対し：
◎
For each registration of registration map’s values:
</p>
		<ol>
			<li>
<p>
~IF［
%登録 にて`~install中の~worker$swr ~NEQ ~NULL
］：
◎
If registration’s installing worker is not null, then:
</p>
				<ol>
					<li>
~IF［
%登録 にて`待機-中な~worker$swr ~EQ ~NULL
］~AND［
%登録 にて`作動中な~worker$swr ~EQ ~NULL
］
⇒
`登録を~clearする$( %登録 )
◎
If registration’s waiting worker is null and registration’s active worker is null, invoke Clear Registration with registration and continue to the next iteration of the loop.
</li>
					<li>
~ELSE
⇒
%登録 にて`~install中の~worker$swr ~SET ~NULL
◎
Else, set registration’s installing worker to null.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%登録 にて`待機-中な~worker$swr ~NEQ ~NULL
］
⇒
次の手続きを`並列的$に走らす
</p>

<div class="algo">
手続きは
⇒
`作動化する$( %登録 )
</div>
◎
If registration’s waiting worker is not null, then in parallel:
• Invoke Activate with registration.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="update-service-worker-extended-events-set-algorithm">
<h3 title="Update Service Worker Extended Events Set">`~sw延長-済み~event集合を更新する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw$ %~worker,
`~event$ %~event
◎終
に対し：
◎
Input
• worker, a service worker
• event, an event
◎
Output
• None
</p>
<ol>
	<li>
~Assert：
%~event の`配送-中か$ev ~EQ ~F
◎
Assert: event’s dispatch flag is unset.
</li>
	<li>
<p>
%~worker の`延長-済み~event集合$swを成す
~EACH( %~item )
に対し
⇒
~IF［
%~item は`作動中$eXでない
］
⇒
%~worker の`延長-済み~event集合$swから %~item を`除去する$
◎
For each item of worker’s set of extended events:
• If item is not active, remove item from worker’s set of extended events.
</li>
	<li>
~IF［
%~event は`作動中$eXである
］
⇒
%~worker の`延長-済み~event集合$swに %~event を`付加する$set
◎
If event is active, append event to worker’s set of extended events.
</li>
</ol>

		</section>
		<section id="unregister-algorithm">
<h3 title="Unregister">`未登録にする@</h3>

<p>
~algoは、
所与の
⇒＃
`~job$ %~job
◎終
に対し：
◎
Input
• job, a job
◎
Output
• None
</p>
<ol>
	<li>
<p>
~IF［
%~job の`~scope~URL$jobの`生成元$url
~NEQ`生成元$sub
%~job の`~client$jobの`生成元$cl【！`生成元$enV】
］：
◎
If the origin of job’s scope url is not job’s client’s origin, then:
</p>
		<ol>
			<li>
`~job~promiseを却下する$( %~job, `SecurityError$E 例外 )
◎
Invoke Reject Job Promise with job and "SecurityError" DOMException.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
%登録 ~LET `登録を取得する$( %~job の`~storage~key$job, %~job の`~scope~URL$job )
◎
Let registration be the result of running Get Registration given job’s storage key and job’s scope url.
</li>
	<li>
<p>
~IF［
%登録 ~EQ ~NULL
］：
◎
If registration is null, then:
</p>
		<ol>
			<li>
`~job~promiseを解決する$( %~job, ~F )
◎
Invoke Resolve Job Promise with job and false.
</li>
			<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job and＼
</li>
			<li>
~RET
◎
abort these steps.
</li>
		</ol>
	</li>
	<li>
`登録~map$[ ( %登録 の`~storage~key$swr, %~job の`~scope~URL$job ) ] ~SET ε
◎
Remove registration map[(registration’s storage key, job’s scope url)].
</li>
	<li>
`~job~promiseを解決する$( %~job, ~T )
◎
Invoke Resolve Job Promise with job and true.
</li>
	<li>
<p>
`登録を~clearするよう試行する$( %登録 )
◎
Invoke Try Clear Registration with registration.
</p>

<p class="note">注記：
この`登録を~clearするよう試行する$() が，`登録を~clearする$() を誘発しなかった場合、
次に該当するときに再度，誘発するよう試行することになる
⇒＃
%登録 を`利用して$いる最後の~clientが`~unload$されたとき ／
%登録 の~sw用の`存続期間を延長する~promise群$が決着したとき
◎
Note: If Try Clear Registration does not trigger Clear Registration here, Clear Registration is tried again when the last client using the registration is unloaded or the extend lifetime promises for the registration’s service workers settle.
</p>
	</li>
	<li>
`~jobを完遂する$( %~job )
◎
Invoke Finish Job with job.
</li>
</ol>

		</section>
		<section id="set-registration-algorithm">
<h3 title="Set Registration">`登録を設定する@</h3>

<p>
~algoは、
所与の
⇒＃
`~storage~key$ %~storage~key,
`~URL$ %~scope,
`~cacheを介する更新~mode$swr %~cacheを介する更新
◎終
に対し，ある`~sw登録$を返す
— 以下の手続きは`不可分に走らす$とする：
◎
Input
• storage key, a storage key
• scope, a URL
• updateViaCache, an update via cache mode
◎
Output
• registration, a service worker registration
◎
Run the following steps atomically.
</p>
<ol>
	<li>
%~scope文字列 ~LET `~URLを直列化する$( %~scope, `素片は除外する^i )
◎
Let scopeString be serialized scope with the exclude fragment flag set.
</li>
	<li>
%登録 ~LET 新たな`~sw登録$
— その
⇒＃
`~storage~key$swr ~SET %~storage~key,
`~scope~URL$swr ~SET %~scope,
`~cacheを介する更新~mode$swr ~SET %~cacheを介する更新
◎
Let registration be a new service worker registration whose storage key is set to storage key, scope url is set to scope, and update via cache mode is set to updateViaCache.
</li>
	<li>
`登録~map$[ ( %~storage~key, %~scope文字列 ) ] ~SET %登録
◎
Set registration map[(storage key, scopeString)] to registration.
</li>
	<li>
~RET %登録
◎
Return registration.
</li>
</ol>

		</section>
		<section id="clear-registration-algorithm">
<h3 title="Clear Registration">`登録を~clearする@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録
◎終
に対し
— 以下の手続きは`不可分に走らす$とする：
◎
Input
• registration, a service worker registration
◎
Output
• None
◎
Run the following steps atomically.
</p>
<ol>
	<li>
<p>
次の表tを成す
~EACH( 行 )
に対し，順に：
</p>

<table><tbody>

<tr><td>%登録 にて`~install中の~worker$swr
<td>`installing^l

<tr><td>%登録 にて`待機-中な~worker$swr
<td>`waiting^l

<tr><td>%登録 にて`作動中な~worker$swr
<td>`active^l
</table>

		<ol>
			<li>
( %~worker, %~target ) ~LET 行の ( 1 列目, 2 列目 ) に挙げる値
</li>
			<li>
~IF［
%~worker ~EQ ~NULL
］
⇒
~CONTINUE
</li>
			<li>
`~swを終了する$( %~worker )
</li>
			<li>
`~workerの状態を更新する$( %~worker, `redundant^l )
</li>
			<li>
`登録の状態を更新する$( %登録, %~target, ~NULL )
</li>
		</ol>

◎
If registration’s installing worker is not null, then:
• Terminate registration’s installing worker.
• Run the Update Worker State algorithm passing registration’s installing worker and "redundant" as the arguments.
• Run the Update Registration State algorithm passing registration, "installing" and null as the arguments.
◎
If registration’s waiting worker is not null, then:
• Terminate registration’s waiting worker.
• Run the Update Worker State algorithm passing registration’s waiting worker and "redundant" as the arguments.
• Run the Update Registration State algorithm passing registration, "waiting" and null as the arguments.
◎
If registration’s active worker is not null, then:
• Terminate registration’s active worker.
• Run the Update Worker State algorithm passing registration’s active worker and "redundant" as the arguments.
• Run the Update Registration State algorithm passing registration, "active" and null as the arguments.
</li>
</ol>

		</section>
		<section id="try-clear-registration-algorithm">
<h3 title="Try Clear Registration">`登録を~clearするよう試行する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録
◎終
に対し：
◎
Input
• registration, a service worker registration
◎
Output
• None
</p>
<ol>
	<li>
<p>
~IF［
~AND↓
］…
</p>
		<ul>
			<li>
%登録 を`利用して$いる`~sw~client$はない
</li>
			<li>
`~swには処理待ち~eventは無いか？$( %登録 にて`~install中の~worker$swr ) ~EQ ~T
</li>
			<li>
`~swには処理待ち~eventは無いか？$( %登録 にて`待機-中な~worker$swr ) ~EQ ~T
</li>
			<li>
`~swには処理待ち~eventは無いか？$( %登録 にて`作動中な~worker$swr ) ~EQ ~T
</li>
		</ul>
<p>
…ならば
⇒
`登録を~clearする$( %登録 )
</p>

◎
Invoke Clear Registration with registration if no service worker client is using registration and all of the following conditions are true:
• registration’s installing worker is null or the result of running Service Worker Has No Pending Events with registration’s installing worker is true.
• registration’s waiting worker is null or the result of running Service Worker Has No Pending Events with registration’s waiting worker is true.
• registration’s active worker is null or the result of running Service Worker Has No Pending Events with registration’s active worker is true.
</li>
</ol>

		</section>
		<section id="update-registration-state-algorithm">
<h3 title="Update Registration State">`登録の状態を更新する@</h3>

`ServiceWorkerRegistration^I0

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録,
%~target ~IN { `installing^l , `waiting^l , `active^l }
［ `~sw$ ／ ~NULL］ %~source
◎終
に対し：
◎
Input
• registration, a service worker registration
• target, a string (one of "installing", "waiting", and "active")
• source, a service worker or null
◎
Output
• None
</p>
<ol>
	<li>
%登録~obj群 ~LET %登録 を表現している すべての `ServiceWorkerRegistration$I ~objからなる集合
【順序は指定されていない】
◎
Let registrationObjects be an array containing all the ServiceWorkerRegistration objects associated with registration.
</li>
<!-- 
配列 → 集合
結付けられた → 表現している
包含している → からなる
-->
	<li>
<p>
%~target に応じて：
</p>
		<dl class="switch">
			<dt>
`installing^l
◎
If target is "installing", then:
</dt>
			<dd>
				<ol>
					<li>
%登録 にて`~install中の~worker$swr ~SET %~source
◎
Set registration’s installing worker to source.
</li>
					<li>
<p>
%登録~obj群 を成す
~EACH( %登録~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %登録~obj に`関連な設定群~obj$の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
%登録~obj の `installing$m 属性 ~SET %登録 の`~install中の~worker$swrに応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ `~sw~objを取得する$( %登録 の`~install中の~worker$swr, %登録~obj に`関連な設定群~obj$ )
</div>
◎
For each registrationObject in registrationObjects:
• Queue a task to set the installing attribute of registrationObject to null if registration’s installing worker is null, or the result of getting the service worker object that represents registration’s installing worker in registrationObject’s relevant settings object.
</li>
				</ol>
			</dd>

			<dt>
`waiting^l
◎
Else if target is "waiting", then:
</dt>
			<dd>
				<ol>
					<li>
%登録 にて`待機-中な~worker$swr ~SET %~source
◎
Set registration’s waiting worker to source.
</li>
					<li>
<p>
%登録~obj群 を成す
~EACH( %登録~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %登録~obj に`関連な設定群~obj$の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
%登録~obj の `waiting$m 属性 ~SET %登録 の`待機-中な~worker$swrに応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ `~sw~objを取得する$( %登録 の`待機-中な~worker$swr, %登録~obj に`関連な設定群~obj$ )
</div>
◎
For each registrationObject in registrationObjects:
• Queue a task to set the waiting attribute of registrationObject to null if registration’s waiting worker is null, or the result of getting the service worker object that represents registration’s waiting worker in registrationObject’s relevant settings object.
</li>
				</ol>
			</dd>

			<dt>
`active^l
◎
Else if target is "active", then:
</dt>
			<dd>
				<ol>
					<li>
%登録 にて`作動中な~worker$swr ~SET %~source
◎
Set registration’s active worker to source.
</li>
					<li>
<p>
%登録~obj群 を成す
~EACH( %登録~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %登録~obj に`関連な設定群~obj$の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
%登録~obj の `active$m 属性 ~SET ［
%登録 の`作動中な~worker$swr ~EQ ~NULL ならば ~NULL ／
~ELSE_ `~sw~objを取得する$( %登録 の`作動中な~worker$swr, %登録~obj に`関連な設定群~obj$ )
］
</div>
◎
For each registrationObject in registrationObjects:
• Queue a task to set the active attribute of registrationObject to null if registration’s active worker is null, or the result of getting the service worker object that represents registration’s active worker in registrationObject’s relevant settings object.
</li>
				</ol>
			</dd>
		</dl>
<p>
◎
↑ The task must use registrationObject’s relevant settings object’s responsible event loop and the DOM manipulation task source.
</p>
	</li>
</ol>

		</section>
		<section id="update-state-algorithm">
<h3 title="Update Worker State">`~workerの状態を更新する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw$ %~worker,
`~sw$の`状態$sw %状態
◎終
に対し：
◎
Input
• worker, a service worker
• state, a service worker state
◎
Output
• None
</p>
<ol>
	<li>
<p>
~Assert：
%状態 ~NEQ `parsed^l
◎
Assert: state is not "parsed".
</p>

<p class="note">注記：
`parsed^l は初期~状態である。
この状態にある`~sw$が更新されることは、
決してない。
◎
Note: "parsed" is the initial state. A service worker is never updated to this state.
</p>
	</li>
	<li>
%~worker の`状態$sw ~SET %状態
◎
Set worker’s state to state.
</li>
	<li>
%設定群~obj群 ~LET 次を満たす`環境~設定群~obj$すべてからなる集合
⇒
`生成元$enV ~EQ`生成元$sub %~worker の`~script~URL$swの`生成元$url
◎
Let settingsObjects be all environment settings objects whose origin is worker’s script url’s origin.
</li>
	<li>
<p>
%設定群~obj群 を成す
~EACH( %設定群~obj )
に対し
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %設定群~obj の`担当の~event~loop$enV )
◎
For each settingsObject of settingsObjects, queue a task on settingsObject’s responsible event loop in the DOM manipulation task source to run＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
%~obj~map ~LET %設定群~obj の`~sw~obj~map$enV
◎
Let objectMap be settingsObject’s service worker object map.
</li>
			<li>
%~worker~obj ~LET %~obj~map[ %~worker ]
◎
↓</li>
			<li>
~IF［
%~worker~obj ~EQ ε
］
⇒
~RET
◎
If objectMap[worker] does not exist, then abort these steps.
◎
Let workerObj be objectMap[worker].
</li>
			<li>
%~worker~obj の `ServiceWorker^I1`state$m1 ~SET %状態
◎
Set workerObj’s state to state.
</li>
			<li>
`~eventを発火する$( %~worker~obj, `statechange$et )
◎
Fire an event named statechange at workerObj.
</li>
		</ol>
</div>
	</li>
</ol>

		</section>
		<section id="notify-controller-change-algorithm">
<h3 title="Notify Controller Change">`制御器の変化を通知する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw~client$ %~client
◎終
に対し：
◎
Input
• client, a service worker client
◎
Output
• None
</p>
<ol>
	<li>
~Assert：
%~client ~NEQ ~NULL
◎
Assert: client is not null.
</li>
	<li>
<p>
~IF［
%~client は`環境~設定群~obj$である
］
⇒
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~client の`担当の~event~loop$enV )
</p>
<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%O ~LET 次を満たす `ServiceWorkerContainer$I ~obj
⇒
その`~sw~client$SWC ~EQ %~client
</li>
			<li>
`~eventを発火する$( %O, `controllerchange$etC )
</li>
		</ol>
</div>
◎
If client is an environment settings object, queue a task to fire an event named controllerchange at the ServiceWorkerContainer object that client is associated with.
◎
The task must use client’s responsible event loop and the DOM manipulation task source.
</li>
</ol>

		</section>
		<section id="scope-match-algorithm">
<h3 title="Match Service Worker Registration">`合致する~sw登録@</h3>

<p>
~algoは、
所与の
⇒＃
`~storage~key$ %~storage~key,
`~URL$ %~client~URL
◎終
に対し，［
ある`~sw登録$【／ ~NULL】
］を返す
— 以下の手続きは`不可分に走らす$とする：
◎
Input
• storage key, a storage key
• clientURL, a URL
◎
Output
• A service worker registration
◎
Run the following steps atomically.
</p>
<ol>
	<li>
%~client~URL文字列 ~LET `~URLを直列化する$(  %~client~URL )
◎
Let clientURLString be serialized clientURL.
◎
↓Let matchingScopeString be the empty string.
</li>
	<li>
%~scope文字列~集合 ~LET 新たな`~list$
◎
Let scopeStringSet be an empty list.
</li>
	<li>
`登録~map$の`~key群$mapを成す
~EACH( %~key )
に対し
⇒
~IF［［

%~storage~key, %~key[ 0 ]
］は`同等な~storage~key$である
］
⇒
%~scope文字列~集合 に %~key[ 1 ] を`付加する$
◎
For each (entry storage key, entry scope) of registration map’s keys:
• If storage key equals entry storage key, then append entry scope to the end of scopeStringSet.
</li>
	<li>
<p>
%合致している~scope文字列 ~LET %~scope文字列~集合 内に次を満たすものが［
在るならば，それらのうち最長の文字列 ／
無いならば，空~文字列
］
⇒
%~client~URL文字列 の`符号単位~接頭辞$である【！starts with】
◎
Set matchingScopeString to the longest value in scopeStringSet which the value of clientURLString starts with, if it exists.
</p>

<p class="note">注記：
この段で合致している~URL文字列は、
接頭辞に基づき，~path構造は~~加味されない。
例えば~client~URL文字列
`https://example.com/prefix-of/resource.html^l
は、
`https://example.com/prefix^l
を伴う~scope用の登録に合致することになる。
このような~URL文字列の比較は、
同一-生成元~security用には安全である
— ［
~HTTP／~HTTPS
］`~URLを直列化する$ときには、
生成元~~成分は，常に末尾に~slashを伴うように直列化されるので。
◎
Note: The URL string matching in this step is prefix-based rather than path-structural. E.g. a client URL string with "https://example.com/prefix-of/resource.html" will match a registration for a scope with "https://example.com/prefix". The URL string comparison is safe for the same-origin security as HTTP(S) URLs are always serialized with a trailing slash at the end of the origin part of the URLs.
</p>
	</li>
	<li>
%合致している~scope ~LET ~NULL
◎
Let matchingScope be null.
</li>
	<li>
<p>
~IF［
%合致している~scope文字列 ~NEQ 空~文字列
］：
◎
If matchingScopeString is not the empty string, then:
</p>
		<ol>
			<li>
%合致している~scope ~SET `~URL構文解析する$( %合致している~scope文字列 )
◎
Set matchingScope to the result of parsing matchingScopeString.
</li>
			<li>
~Assert：
%合致している~scope の`生成元$url
~EQ`生成元$sub
%~client~URL の`生成元$url
◎
Assert: matchingScope’s origin and clientURL’s origin are same origin.
</li>
		</ol>
	</li>
	<li>
~RET `登録を取得する$( %~storage~key, %合致している~scope )
◎
Return the result of running Get Registration given storage key and matchingScope.
</li>
</ol>

		</section>
		<section id="get-registration-algorithm">
<h3 title="Get Registration">`登録を取得する@</h3>

<p>
~algoは、
所与の
⇒＃
`~storage~key$ %~storage~key,
［ `~URL$【／ ~NULL】 ］ %~scope
◎終
に対し，［
ある`~sw登録$【／ ~NULL】
］を返す
— 以下の手続きは`不可分に走らす$とする：
◎
Input
• storage key, a storage key
• scope, a URL
◎
Output
• A service worker registration
◎
Run the following steps atomically.
</p>
<ol>
	<li>
%~scope文字列 ~LET 空~文字列
◎
Let scopeString be the empty string.
</li>
	<li>
~IF［
%~scope ~NEQ ~NULL
］
⇒
%~scope文字列 ~SET `~URLを直列化する$( %~scope, `素片は除外する^i )
◎
If scope is not null, set scopeString to serialized scope with the exclude fragment flag set.
</li>
	<li>
`登録~map$を成す
~EACH( %~key → %登録 )
に対し
⇒
~IF［［
%~storage~key, %~key[ 0 ]
］は`同等な~storage~key$である
］~AND［
%~scope文字列 ~EQ【！match】 %~key[ 1 ]
］
⇒
~RET %登録
◎
For each (entry storage key, entry scope) → registration of registration map:
• If storage key equals entry storage key and scopeString matches entry scope, then return registration.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

		</section>
		<section id="get-newest-worker-algorithm">
<h3 title="Get Newest Worker">`最新な~workerを取得する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw登録$ %登録
◎終
に対し，［
ある`~sw$【／ ~NULL】
］を返す
— 以下の手続きは`不可分に走らす$とする：
◎
Input
• registration, a service worker registration
◎
Output
• newestWorker, a service worker
◎
Run the following steps atomically.
• Let newestWorker be null.
</p>
<ol>
	<li>
~IF［
%登録 にて`~install中の~worker$swr ~NEQ ~NULL
］
⇒
~RET %登録 にて`~install中の~worker$swr
◎
If registration’s installing worker is not null, set newestWorker to registration’s installing worker.
</li>
	<li>
~IF［
%登録 にて`待機-中な~worker$swr ~NEQ ~NULL
］
⇒
~RET %登録 にて`待機-中な~worker$swr
◎
Else if registration’s waiting worker is not null, set newestWorker to registration’s waiting worker.
</li>
	<li>
~IF［
%登録 にて`作動中な~worker$swr ~NEQ ~NULL
］
⇒
~RET %登録 にて`作動中な~worker$swr
◎
Else if registration’s active worker is not null, set newestWorker to registration’s active worker.
</li>
	<li>
~RET ~NULL
◎
Return newestWorker.
</li>
</ol>

		</section>
		<section id="service-worker-has-no-pending-events-algorithm">
<h3 title="Service Worker Has No Pending Events">`~swには処理待ち~eventは無いか？@</h3>

<p>
~algoは、
所与の
⇒＃
［ `~sw$／ ~NULL† ］ %~worker
◎終
に対し，ある真偽値を返す：
◎
Input
• worker, a service worker
◎
Output
• True or false, a boolean
</p>
<p class="trans-note">【†
この ~NULL と以下の最初の段は、
他所を簡潔に述べるための，この訳による追加。
】</p>
<ol>
	<li>
~IF［
%~worker ~EQ ~NULL
］
⇒
~RET ~T
◎
↑</li>
	<li>
<p>
%~worker の`延長-済み~event集合$swを成す
~EACH( %~event )
に対し
⇒
~IF［
%~event は`作動中$eXである
］
⇒
~RET ~F
◎
For each event of worker’s set of extended events:
• If event is active, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

		</section>
		<section id="create-client-algorithm">
<h3 title="Create Client">`~clientを作成する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw~client$ %~client
◎終
に対し，ある `Client$I ~objを返す：
◎
Input
• client, a service worker client
◎
Output
• clientObject, a Client object
</p>
<ol>
	<li>
~RET `新たな~obj$( `Client$I )
— その
⇒＃
`~sw~client$cl ~SET %~client
◎
Let clientObject be a new Client object.
◎
Set clientObject’s service worker client to client.
◎
Return clientObject.
</li>
</ol>

		</section>
		<section id="create-windowclient-algorithm">
<h3 title="Create Window Client">`~window~clientを作成する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw~client$ %~client,
文字列【 `FrameType$I 値】 %~frame種別,
文字列【 `DocumentVisibilityState$I 値】 %可視性~状態,
真偽値 %~focus状態,
【文字列たちが成す】~list %先祖~生成元~list
◎終
に対し，ある `WindowClient$I ~objを返す：
◎
Input
• client, a service worker client
• frameType, a string
• visibilityState, a string
• focusState, a boolean
• ancestorOriginsList, a list
◎
Output
• windowClient, a WindowClient object
</p>
<ol>
	<li>
~RET `新たな~obj$( `WindowClient$I )
— その
⇒＃
`~sw~client$cl ~SET %~client,
`~frame種別$cl ~SET %~frame種別,
`可視性~状態$cl ~SET %可視性~状態,
`~focus状態$cl ~SET %~focus状態,
`先祖~生成元~配列$cl ~SET `凍結d配列を作成する$( %先祖~生成元~list ) 【 %~client に`関連な~realm$内で？】
◎
Let windowClient be a new WindowClient object.
• Set windowClient’s service worker client to client.
• Set windowClient’s frame type to frameType.
• Set windowClient’s visibility state to visibilityState.
• Set windowClient’s focus state to focusState.
• Set windowClient’s ancestor origins array to a frozen array created from ancestorOriginsList.
◎
Return windowClient.
</li>
</ol>

		</section>
		<section id="get-frametype-algorithm">
<h3 title="Get Frame Type">`~frame種別を取得する@</h3>

<p>
~algoは、
所与の
⇒＃
`~navigable$ %~navigable
◎終
に対し，ある `FrameType$I 値【！string】を返す：
◎
Input
• navigable, a navigable
◎
Output
• frameType, a string
</p>
<ol>
	<li>
~IF［
%~navigable の`親$nav ~NEQ ~NULL
］
⇒
~RET `nested^l
◎
If navigable’s parent is not null, then return "nested".
</li>
	<li>
~IF［
%~navigable にて`作動中な閲覧~文脈$navは`補助~閲覧~文脈$である
］
⇒
~RET `auxiliary^l
◎
If navigable’s active browsing context is an auxiliary browsing context, then return "auxiliary".
</li>
	<li>
~RET `top-level^l
◎
Return "top-level".
</li>
</ol>

		</section>
		<section id="resolve-get-client-promise-algorithm">
<h3 title="Resolve Get Client Promise">`~clientを取得する~promiseを解決する@</h3>

<p>
~algoは、
所与の
⇒＃
`~sw~client$ %~client,
`~promise$ %~promise
◎終
に対し：
◎
Input
• client, a service worker client
• promise, a promise
◎
Output
• None
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
［
%~client は`環境~設定群~obj$である
］~AND［
%~client は`~secureな文脈$enVでない
］
</li>
			<li>
［
%~client は`環境~設定群~obj$でない
］~AND［
%~client の`作成時の~URL$enV は`信用に価し得る~URL$でない
］
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `SecurityError$E 例外 )
</div>
			</li>
			<li>
~RET
</li>
		</ol>
◎
If client is an environment settings object, then:
• If client is not a secure context, queue a task to reject promise with a "SecurityError" DOMException, on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source, and abort these steps.
◎
Else:
• If client’s creation URL is not a potentially trustworthy URL, queue a task to reject promise with a "SecurityError" DOMException, on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source, and abort these steps.
</li>
	<li>
<p>
~IF［
%~client は`環境~設定群~obj$である
］~AND［
%~client は`~window~client$でない
］：
◎
If client is an environment settings object and is not a window client, then:
</p>
		<ol>
			<li>
%~client~obj ~LET `~clientを作成する$( %~client )
◎
Let clientObject be the result of running Create Client algorithm with client as the argument.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise, %~client~obj )
</div>
◎
Queue a task to resolve promise with clientObject, on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source,＼
</li>
			<li>
~RET
◎
and abort these steps.
</li>
		</ol>
	</li>
	<li>
%閲覧~文脈 ~LET［
%~client は`環境~設定群~obj$であるならば %~client の`大域~obj$enVに`対応する閲覧~文脈$【！`閲覧~文脈$】 ／
~ELSE_ %~client の`~target閲覧~文脈$enV
］
◎
Else:
◎
Let browsingContext be null.
◎
If client is an environment settings object, set browsingContext to client’s global object’s browsing context.
◎
Else, set browsingContext to client’s target browsing context.
</li>
	<li>
%~navigable ~LET %閲覧~文脈 に`対応する~navigable$bc
【！`作動中な閲覧~文脈$navに %閲覧~文脈 を伴う`~navigable$】
◎
Let navigable be the navigable with a active browsing context of browsingContext.
</li>
	<li>
<p>
`~taskを~queueする$( `利用者ヤリトリ~task~source$, 次の手続き, %閲覧~文脈 の`~event~loop$ )
◎
Queue a task to run the following steps on browsingContext’s event loop using the user interaction task source:
</p>
<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%~frame種別 ~LET `~frame種別を取得する$( %~navigable  )
◎
Let frameType be the result of running Get Frame Type with navigable.
</li>
			<li>
%作動中な文書 ~LET %~navigable にて`作動中な文書$nav
◎
↓</li>
			<li>
%可視性~状態 ~LET %作動中な文書 の `visibilityState$n 属性~値
◎
Let visibilityState be browsingContext’s active document’s visibilityState attribute value.
</li>
			<li>
%~focus状態 ~SET `~focusを有するか？$( %作動中な文書 )
◎
Let focusState be the result of running the has focus steps with browsingContext’s active document as the argument.
</li>
			<li>
%先祖~生成元~list ~LET 空~list
◎
Let ancestorOriginsList be the empty list.
</li>
			<li>
~IF［
%~client は`~window~client$である
］
⇒
%先祖~生成元~list ~SET %作動中な文書 の`先祖~生成元~文字列~list$
◎
If client is a window client, set ancestorOriginsList to browsingContext’s active document’s relevant global object’s Location object’s ancestor origins list’s associated list.
</li>
			<li>
<p>
`~taskを~queueする$( `~DOM操作~task~source$, 次の手続き, %~promise に`関連な設定群~obj$の`担当の~event~loop$enV )
◎
Queue a task to run the following steps on promise’s relevant settings object’s responsible event loop using the DOM manipulation task source:
</p>

<div class="algo">
<p>
手続きは：
</p>
				<ol>
					<li>
%結果 ~LET `undefined^jv
◎
↓</li>
					<li>
~IF［
%~client の`破棄-済みか$ ~EQ ~F
］
⇒
%結果 ~SET `~window~clientを作成する$( ↓ )
⇒＃
%~client,
%~frame種別,
%可視性~状態,
%~focus状態,
%先祖~生成元~list
◎
If client’s discarded flag is set, resolve promise with undefined and abort these steps.
◎
Let windowClient be the result of running Create Window Client with client, frameType, visibilityState, focusState, and ancestorOriginsList.
</li>
					<li>
`~promiseを解決する$( %~promise, %結果 )
◎
Resolve promise with windowClient.
</li>
				</ol>
</div>
			</li>
		</ol>
</div>
	</li>
</ol>

		</section>
		<section id="query-cache-algorithm">
<h3 title="Query Cache">`~cacheを~queryする@</h3>

<p>
~algoは、
所与の
⇒＃
`要請$ %要請~query,
`要請~応答~list$† %~storage,
`CacheQueryOptions$I ~obj %~option群 ~DF ε
◎終
に対し，ある`要請~応答~list$を返す：
◎
Input
• requestQuery, a request
• options, a CacheQueryOptions object, optional
• targetStorage, a request response list, optional
◎
Output
• resultList, a request response list
</p>

<p class="trans-note">【†
%~storage は、
原文では省略可能とされているが、
この訳では，常に明示的に与えて呼出すよう改めている。
原文では，省略時には
`関連な要請~応答~list$
になるものとされているが、
どの~objに関連なそれなのか明らかでなく，呼出す箇所で与える方が明確になるので。
それに伴い、
引数の順序も改めている。
】</p>

<ol>
	<li>
%結果~list ~LET 新たな`~list$
◎
Let resultList be an empty list.
</li>
	<li>
<p>
%~storage を成す
~EACH( %要請~応答 )
に対し：
◎
Let storage be null.
◎
If the optional argument targetStorage is omitted, set storage to the relevant request response list.
◎
Else, set storage to targetStorage.
◎
For each requestResponse of storage:
</p>
		<ol>
			<li>
%要請 ~LET %要請~応答 を成す要請
◎
Let cachedRequest be requestResponse’s request.
</li>
			<li>
%応答 ~LET %要請~応答 を成す応答
◎
Let cachedResponse be requestResponse’s response.
</li>
			<li>
~IF［
`要請は~cache済み~itemに合致するか？$( %要請~query, %要請, %応答, %~option群 )
~EQ ~T
］
⇒
%結果~list に
( %要請 の複製, %応答 の複製 )
を`付加する$
◎
If Request Matches Cached Item with requestQuery, cachedRequest, cachedResponse, and options returns true, then:
• Let requestCopy be a copy of cachedRequest.
• Let responseCopy be a copy of cachedResponse.
• Add requestCopy/responseCopy to resultList.
</li>
		</ol>
	</li>
	<li>
~RET %結果~list
◎
Return resultList.
</li>
</ol>

		</section>
		<section id="request-matches-cached-item-algorithm">
<h3 title="Request Matches Cached Item">`要請は~cache済み~itemに合致するか？@</h3>

<p>
~algoは、
所与の
⇒＃
`要請$ %要請~query
`要請$ %要請
`応答$ %応答 ~DF ~NULL
`CacheQueryOptions$I ~obj %~option群 ~DF ε
◎終
に対し，ある真偽値を返す：
◎
Input
• requestQuery, a request
• request, a request
• response, a response or null, optional, defaulting to null
• options, a CacheQueryOptions object, optional
◎
Output
• a boolean
</p>
<ol>
	<li>
~IF［
%~option群 ~EQ ε
］
⇒
%~option群 ~SET 新たな `CacheQueryOptions$I 辞書
【この段は、この訳による補完】
</li>
	<li>
~IF［
%~option群[ `CacheQueryOptions^I1"`ignoreMethod$m1" ] ~EQ ~F
］~AND［
%要請~query の`~method$rq ~NEQ `GET^bl
］
⇒
~RET ~F
◎
If options["ignoreMethod"] is false and request’s method is not `GET`, return false.
</li>
	<li>
%~query~URL ~LET %要請~query の`~URL$rq
◎
Let queryURL be requestQuery’s url.
</li>
	<li>
%~cache済み~URL ~LET %要請 の`~URL$rq
◎
Let cachedURL be request’s url.
</li>
	<li>
<p>
~IF［
%~option群[ "`ignoreSearch$m1" ] ~EQ ~T
］：
◎
If options["ignoreSearch"] is true, then:
</p>
		<ol>
			<li>
%~cache済み~URL の`~query$url ~SET 空~文字列
◎
Set cachedURL’s query to the empty string.
</li>
			<li>
%~query~URL の`~query$url ~SET 空~文字列
◎
Set queryURL’s query to the empty string.
</li>
		</ol>
	</li>
	<li>
~IF［
( %~query~URL, %~cache済み~URL  )
は `素片は除外する^i 下で`同等な~URL$でない
］
⇒
~RET ~F
◎
If queryURL does not equal cachedURL with the exclude fragment flag set, then return false.
</li>
	<li>
~IF［
%応答 ~EQ ~NULL
］~OR［
%~option群[ "`ignoreVary$m1" ] ~EQ ~T
］
⇒
~RET ~T
◎
If response is null, options["ignoreVary"] is true, or＼
↓response’s header list does not contain `Vary`,＼
then return true.
</li>
	<li>
%Vary ~SET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `Vary$h )
◎
Let fieldValues be the list containing the elements corresponding to the field-values of the Vary header for the value of the header with name `Vary`.
</li>
	<li>
~IF［
%Vary ~EQ ~NULL
］
⇒
~RET ~T
◎
↑</li>
	<li>
<p>
%Vary を成す
~EACH( %~field値 )
に対し：
◎
For each fieldValue in fieldValues:
</p>
		<ol>
			<li>
%~field値 ~SET `同型に符号化する$( %~field値 )
◎
↓</li>
			<li>
~IF［
%~field値 ~EQ `*^bl
］
⇒
~RET ~F
◎
If fieldValue matches "*", or＼
</li>
			<li>
~IF［
`~header~listから値を取得する$( %要請 の`~header~list$rq, %~field値 )
~NEQ
`~header~listから値を取得する$( %要請~query の`~header~list$rq, %~field値 )
【！原文 “combined value” ~FETCH#concept-header-list-combine は、~header~listを改変するので不適切】
］
⇒
~RET ~F
◎
the combined value given fieldValue and request’s header list does not match the combined value given fieldValue and requestQuery’s header list, then return false.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

		</section>
		<section id="batch-cache-operations-algorithm">
<h3 title="Batch Cache Operations">`~cache演算を~batchする@</h3>

<p>
~algoは、
所与の
⇒＃
`~cache~batch演算$ ~objの`~list$ %演算~群,
`要請~応答~list$を表現する~obj %O 【この訳による補完】
◎終
に対し，ある`要請~応答~list$を返す：
◎
Input
• operations, a list of cache batch operation objects
◎
Output
• resultList, a request response list
</p>
<ol>
	<li>
%~cache ~LET %O に`関連な要請~応答~list$
◎
Let cache be the relevant request response list.
</li>
	<li>
%予備~cache ~LET %~cache を`~cloneする$
◎
Let backupCache be a new request response list that is a copy of cache.
</li>
	<li>
%追加される~item群 ~LET 新たな`~list$
◎
Let addedItems be an empty list.
</li>
	<li class="algo">
<p>
この段は不可分に走らす
— ただし、
手続きの中で例外が投出されたときは，この段の次の段へ進む：
◎
Try running the following substeps atomically:
</p>
		<ol>
			<li>
%結果~list ~LET 空~list
◎
Let resultList be an empty list.
</li>
			<li>
<p>
%演算~群 を成す
~EACH( %演算 )
に対し：
◎
For each operation in operations:
</p>
				<ol>
					<li>
( %要請, %応答, %種別, %~option群 ) ~LET
%演算 の ( `要請$cbo, `応答$cbo, `種別$cbo, `~option群$cbo )
◎
↓</li>
					<li>
~IF［
%種別 ~NIN { `delete^l, `put^l }
］
⇒
~THROW `TypeError^E
◎
If operation’s type matches neither "delete" nor "put", throw a TypeError.
</li>
					<li>
~IF［
%種別 ~NEQ `delete^l
］~AND［
%応答 ~NEQ ~NULL
］
⇒
~THROW `TypeError^E
◎
If operation’s type matches "delete" and operation’s response is not null, throw a TypeError.
</li>
					<li>
~IF［
`~cacheを~queryする$( %要請, %追加される~item群, %~option群 )
の結果は`空$でない
］
⇒
~THROW `InvalidStateError$E
◎
If the result of running Query Cache with operation’s request, operation’s options, and addedItems is not empty, throw an "InvalidStateError" DOMException.
</li>
					<li>
%要請~応答~list ~LET 新たな`~list$
◎
Let requestResponses be an empty list.
</li>
					<li>
<p>
~IF［
%種別 ~EQ `delete^l
］：
◎
If operation’s type matches "delete", then:
</p>
						<ol>
							<li>
%要請~応答~list ~SET `~cacheを~queryする$( %要請, %~cache, %~option群 )
◎
Set requestResponses to the result of running Query Cache with operation’s request and operation’s options.
</li>
							<li>
%~cache から次を満たす`~item$たちを`除去する$
⇒
`~item$ ~IN %要請~応答~list
◎
For each requestResponse in requestResponses:
• Remove the item whose value matches requestResponse from cache.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%種別 ~EQ `put^l
］：
◎
Else if operation’s type matches "put", then:
</p>
						<ol>
							<li>
~IF［
%応答 ~EQ ~NULL
］
⇒
~THROW `TypeError^E
◎
If operation’s response is null, throw a TypeError.
</li>
							<li>
【！ ’s associated `要請$Rq 】
~IF［
%要請 の`~URL$rqの`~scheme$url ~NIN { `http^l , `https^l } 
］
⇒
~THROW `TypeError^E
◎
↑↑Let r be operation’s request’s associated request.
（’s associated request は余計）
◎
If r’s url’s scheme is not one of "http" and "https", throw a TypeError.
</li>
							<li>
~IF［
%要請 の`~method$rq ~NEQ `GET^bl
］
⇒
~THROW `TypeError^E
◎
If r’s method is not `GET`, throw a TypeError.
</li>
							<li>
~IF［
%演算 の`~option群$cbo ~NEQ ~NULL
］
⇒
~THROW `TypeError^E
◎
If operation’s options is not null, throw a TypeError.
</li>
							<li>
%要請~応答~list ~SET `~cacheを~queryする$( %要請, %~cache )
◎
Set requestResponses to the result of running Query Cache with operation’s request.
</li>
							<li>
%~cache から次を満たす`~item$たちを`除去する$
⇒
`~item$ ~IN %要請~応答~list
◎
For each requestResponse of requestResponses:
• Remove the item whose value matches requestResponse from cache.
</li>
							<li>
%cache に
( %要請, %応答 )
を`付加する$
◎
Append operation’s request/operation’s response to cache.
</li>
							<li>
~IF［
【！previous two steps？】
前~段の~cache書込n演算は、
是認されている~quota上限を超過することにより失敗した
］
⇒
~THROW `QuotaExceededError$E
◎
If the cache write operation in the previous two steps failed due to exceeding the granted quota limit, throw a "QuotaExceededError" DOMException.
</li>
							<li>
%追加される~item群 に
( %要請, %応答 )
を`付加する$
◎
Append operation’s request/operation’s response to addedItems.
</li>
						</ol>
					</li>

					<li>
%結果~list に
( %要請, %応答 )
を`付加する$
◎
Append operation’s request/operation’s response to resultList.
</li>
				</ol>
			</li>
			<li>
~RET %結果~list
◎
Return resultList.
</li>
		</ol>
	</li>
	<li>
<p>
前~段にて %例外 が投出されたときは：
◎
And then, if an exception was thrown, then:
</p>
		<ol>
			<li>
%~cache を`空にする$
◎
Remove all the items from the relevant request response list.
</li>
			<li>
%予備~cache を成す
~EACH( %要請~応答 )
に対し
⇒
%~cache に %要請~応答 を`付加する$
◎
For each requestResponse of backupCache:
• Append requestResponse to the relevant request response list.
</li>
			<li>
~THROW %例外
◎
Throw the exception.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
例外が投出されたときには、
実装は，［
~batch演算~jobの間に~cache~storageに加えられた変更
］を巻戻すことになる。
◎
Note: When an exception is thrown, the implementation does undo (roll back) any changes made to the cache storage during the batch operation job.
</p>

		</section>
		<section id="is-async-module-algorithm">
<h3 title="Is Async Module">`非同期c~moduleか？@</h3>

<p>
~algoは、
所与の
⇒＃
`~module~record$ %~record,
`~module~map$ %~module~map,
`~URL$ %基底,
`~URL$たちが成す`有順序~集合$ %seen †
◎終
に対し，ある真偽値を返す：
◎
Input
• record, a Module Record
• moduleMap, a module map
• base, a URL
• seen, a set of URLs
◎
Output
• a boolean
</p>

<p class="trans-note">【†
この集合を成す~URLどうしの同等性は、
`同等な~URL$に基づくであろう。
】</p>
<ol>
	<li>
~IF［
%~record は`循環な~module~record$でない
］
⇒
~RET ~F
◎
If record is not a Cyclic Module Record, then:
• Return false.
</li>
	<li>
~IF［
%~record . `Async^sl ~EQ ~T
］
⇒
~RET ~T
◎
If record.[[Async]] is true, then:
• Return true.
</li>
	<li>
<p>
%~record . `RequestedModules^sl を成す
~EACH( 文字列 %要請された~module )
に対し：
◎
For each string requested of record.[[RequestedModules]]:
</p>
		<ol>
			<li>
%~URL ~LET `~module指定子を解決する$( %基底, %要請された~module )
◎
Let url be the result of resolving a module specifier given base and requested.
</li>
			<li>
~Assert：
%~URL ~NEQ `失敗^i
— 前~段は、
同じ 2 個の引数で以前に成功したはずなので
◎
Assert: url is never failure, because resolving a module specifier must have been previously successful with these same two arguments.
</li>
			<li>
<p>
~IF［
%~URL ~NIN %seen
］：
◎
If seen does not contain url, then:
</p>
				<ol>
					<li>
%seen に %~URL を`付加する$set
◎
Append url to seen.
</li>
					<li>
~IF［
%~module~map[ %~URL ] の`~record$sC ~EQ ~NULL【！does not have】
］
⇒
~RET ~F
◎
If moduleMap[url] does not have a record, then:
• Return false.
</li>
					<li>
~IF［
`非同期c~moduleか？$( %~module~map[ %~URL ] の`~record$sC, %~module~map, %基底, %seen ) ~EQ ~T
］
⇒
~RET ~T
◎
If Is Async Module for moduleMap[url]'s record, moduleMap, base, and seen is true, then:
• Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

		</section>
		<section id="lookup-race-response-algorithm">
<h3 title="Lookup Race Response">`競走~応答を検索する@</h3>

<p>
~algoは、
所与の
⇒＃
`要請$ %要請
◎終
に対し，［
ある`応答$／~NULL
］を返す：
◎
Input
• request, a request
◎
Output
• a response or null
</p>
<ol>
	<li>
%登録 ~LET ~NULL
◎
Let registration be null.
</li>
	<li>
<p>
~IF［
%要請 は`非~下位資源~要請$である
］：
◎
If request is a non-subresource request, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`予約-済み~client$rq ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If request’s reserved client is null, return null.
</li>
			<li>
%~storage~key ~LET `~storage~keyを得する$( %要請 の`予約-済み~client$rq )
◎
Let storage key be the result of running obtain a storage key given request’s reserved client.
</li>
			<li>
%登録 ~SET `合致する~sw登録$( %~storage~key, %要請 の`~URL$rq )
◎
Set registration to the result of running Match Service Worker Registration given storage key and request’s url.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%要請 は`下位資源~要請$である
］：
◎
Else if request is a subresource request, then:
</p>
		<ol>
			<li>
%~client ~LET %要請 の`~client$rq
◎
Let client be request’s client.
</li>
			<li>
~IF［
%~client にて`作動中な~sw$enV ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If client’s active service worker is null, return null.
</li>
			<li>
%登録 ~SET %~client にて`作動中な~sw$enVを`包含している~sw登録$sw
◎
Set registration to client’s active service worker’s containing service worker registration.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET ~NULL
◎
Otherwise, return null.
</li>
	<li>
%作動中な~worker ~LET %登録 にて`作動中な~worker$swr
◎
Let activeWorker be registration’s active worker.
</li>
	<li>
%~map ~LET %作動中な~worker の`大域~obj$swの`競走~応答~map$SWG
◎
Let map be activeWorker’s global object’s race response map.
</li>
	<li>
<p>
~IF［
%~map[ %要請 ] ~NEQ ε
］：
◎
If map[request] exists, then:
</p>
		<ol>
			<li>
%競走~応答 ~LET %~map[ %要請 ]
◎
Let entry be map[request].
</li>
			<li>
%~map[ %要請 ] ~SET ε
◎
Remove map[request].
</li>
			<li>
次が満たされるまで待機する
⇒
%競走~応答 の`値$rV ~NEQ `pending^l
◎
Wait until entry’s value is not "pending"
</li>
			<li>
~IF［
%競走~応答 の`値$rVは`応答$である
］
⇒
~RET %競走~応答 の`値$rV
◎
If entry’s value is response, return entry’s value.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

		</section>
	</section>
	<section id="extended-http-headers">
<h2 title="Appendix B: Extended HTTP headers">付録 B. 拡張された~HTTP~header</h2>

		<section id="service-worker-script-request">
<h3 title="Service Worker Script Request">~sw~script要請</h3>

<p>
`~sw$の`~script資源$swを`~fetch$する~HTTP要請は、
次の`~header$を含めることになる：
◎
An HTTP request to fetch a service worker’s script resource will include the following header:
</p>

<dl>
	<dt>`Service-Worker@h</dt>
	<dd>
この要請は`~sw$の`~script資源$sw要請であることを指示する。
◎
Indicates this request is a service worker’s script resource request.
</dd>
	<dd class="note">注記：
この~headerは、
~administratorが要請を~logして，脅威を検出するのを助ける。
◎
Note: This header helps administrators log the requests and detect threats.
</dd>
</dl>

		</section>
		<section id="service-worker-script-response">
<h3 title="Service Worker Script Response">~sw~script応答</h3>

<p>
`~sw$の`~script資源$sw要請に対する~HTTP応答は、
次に挙げる`~header$を含ませれる：
◎
An HTTP response to a service worker’s script resource request can include the following header:
</p>

<dl>
	<dt>`Service-Worker-Allowed@h</dt>
	<dd>
~path制約を上書きするよう~UAに指示する
— これは、
~scriptに`制御-$することが許容される最大な`~scope~URL$swrを，所与の値に制限する。
◎
Indicates the user agent will override the path restriction, which limits the maximum allowed scope url that the script can control, to the given value.
</dd>
	<dd class="note">注記：
この値は~URLである。
相対的~URLが与えられた場合、
それは~scriptの~URLに基づいて構文解析される。
◎
Note: The value is a URL. If a relative URL is given, it is parsed against the script’s URL.
</dd>
</dl>

<div class="example">
<p>
既定の~scope：
◎
Default scope:
</p>

<pre class="lang-js">
/* <span class="comment">
許容される最大な~scopeは、
既定では，~scriptが座している~path
— 次の例では `/js/^l —
になる：
◎
Maximum allowed scope defaults to the path the script sits in "/js/" in this example
</span> */
navigator.serviceWorker.register("/js/sw.js").then(() =&gt; {
  console.log("既定の~scope '/js/' で~installに成功しました。");
});
</pre>
【！ "Install succeeded with the default scope '/js/'." 】
</div>

<div class="example">

<p>
`Service-Worker-Allowed^h ~headerが伴われないときの，上位path：
◎
Upper path without Service-Worker-Allowed header:
</p>

<pre class="lang-js">
/* <span class="comment">
`Response^I に `Service-Worker-Allowed^h ~headerがないときに，~scopeを~scriptの所在の上位pathに設定する：
◎
Set the scope to an upper path of the script location Response has no Service-Worker-Allowed header
</span> */
navigator.serviceWorker.register("/js/sw.js", { scope: "/" }).catch(() =&gt; {
  console.error("~path制約に違反しているため、
~installに失敗しました。");
});
</pre>
【！"Install failed due to the path restriction violation."】
</div>

<div class="example">

<p>
`Service-Worker-Allowed^h ~headerが伴われるときの，上位path：
◎
Upper path with Service-Worker-Allowed header:
</p>

<pre class="lang-js">
/* <span class="comment">
`Response^I に `Service-Worker-Allowed : /^bl が含まれているときに，~scopeを~script所在の上位pathに設定する：
◎
Set the scope to an upper path of the script location Response included "Service-Worker-Allowed : /"
</span> */
navigator.serviceWorker.register("/js/sw.js", { scope: "/" }).then(() =&gt; {
  console.log("許容される最大な~scopeは '/' に上書きされたので、
~installに成功しました。");
});
</pre>
【！"Install succeeded as the max allowed scope was overriden to '/'."】
</div>

<div class="example">

<p>
`Service-Worker-Allowed^h ~headerが伴われていても，~path制約~違反になる例：
◎
A path restriction voliation even with Service-Worker-Allowed header:
</p>

<pre class="lang-js">
/* <span class="comment">
`Response^I に
`Service-Worker-Allowed : /foo^bl
が含まれているときに，~scopeを~script所在の上位pathに設定する：
◎
Set the scope to an upper path of the script location Response included "Service-Worker-Allowed : /foo"
</span> */
navigator.serviceWorker.register("/foo/bar/sw.js", { scope: "/" }).catch(() =&gt; {
  console.log("許容される最大な~scopeは上書きされましたが，まだ~scopeはその外にあるので、
~installに失敗しました。");
});
</pre>
【！ "Install failed as the scope is still out of the overriden maximum allowed scope."】
</div>

		</section>
		<section id="syntax">
<h3 title="Syntax">構文</h3>

<p>
`~sw$の`~script資源$swへの［
要請と, 対する応答
］により利用される~headerに与える値の `ABNF$r は：
◎
ABNF for the values of the headers used by the service worker’s script resource requests and responses:
</p>

<pre class="bnf">
Service-Worker
	= `%x73.63.72.69.70.74^_ ; "script", 文字大小区別
</pre>

<p class="note">注記：
`Service-Worker-Allowed^h ~headerの値を検証するときには、
この~ABNFは利用されない
— 検証は、
（更新-~algo内で）~URL構文解析~algoが行う。
◎
Note: The validation of the Service-Worker-Allowed header’s values is done by URL parsing algorithm (in Update algorithm) instead of using ABNF.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<div lang="en">
<p>
Deep thanks go to Andrew Betts for organizing and hosting a small workshop of like-minded individuals including: Jake Archibald, Jackson Gabbard, Tobie Langel, Robin Berjon, Patrick Lauke, Christian Heilmann. From the clarity of the day’s discussions and the use-cases outlined there, much has become possible. Further thanks to Andrew for raising consciousness about the offline problem. His organization of EdgeConf and inclusion of Offline as a persistent topic there has created many opportunities and connections that have enabled this work to progress.
</p>

<p>
Anne van Kesteren has generously lent his encyclopedic knowledge of Web Platform arcana and standards development experience throughout the development of the service worker. This specification would be incomplete without his previous work in describing the real-world behavior of URLs, HTTP Fetch, Promises, and DOM. Similarly, this specification would not be possible without Ian Hickson’s rigorous Web Worker spec. Much thanks to him.
</p>

<p>
In no particular order, deep gratitude for design guidance and discussion goes to: Jungkee Song, Alec Flett, David Barrett-Kahn, Aaron Boodman, Michael Nordman, Tom Ashworth, Kinuko Yasuda, Darin Fisher, Jonas Sicking, Jesús Leganés Combarro, Mark Christian, Dave Hermann, Yehuda Katz, François Remy, Ilya Grigorik, Will Chan, Domenic Denicola, Nikhil Marathe, Yves Lafon, Adam Barth, Greg Simon, Devdatta Akhawe, Dominic Cooney, Jeffrey Yasskin, Joshua Bell, Boris Zbarsky, Matt Falkenhagen, Tobie Langel, Gavin Peters, Ben Kelly, Hiroki Nakagawa, Jake Archibald, Josh Soref, Jinho Bang, Yutaka Hirano, Michael(tm) Smith, isonmad, Ali Alabbas, Philip Jägenstedt, Mike Pennisi, and Eric Willigers.
</p>

<p>
Jason Weber, Chris Wilson, Paul Kinlan, Ehsan Akhgari, and Daniel Austin have provided valuable, well-timed feedback on requirements and the standardization process.
</p>

<p>
The authors would also like to thank Dimitri Glazkov for his scripts and formatting tools which have been essential in the production of this specification. The authors are also grateful for his considerable guidance.
</p>

<p>
Thanks also to Vivian Cromwell, Greg Simon, Alex Komoroske, Wonsuk Lee, and Seojin Kim for their considerable professional support.
</p>

</div>

	</section>
</main></div>
