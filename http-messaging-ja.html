<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP/1.1: Messaging （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />
<style>

.hex-value {
	font-family: sans-serif0, sans-serif;
}

</style>

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP/1.1: Messaging
spec_date:2019-11-20
trans_update:2019-11-22
source_checked:191120
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-messaging-latest.html
abbr_url:HTTPmsg
spec_status:IETFID
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●link_map

c.1.1:#version-1.1
c.trailers:~HTTPmsg#_trailers-token
c.keep-alive:~HTTPmsg#compatibility.with.http.1.0.persistent.connections
c.message/http:~HTTPmsg#media.type.message.http
c.application/http:~HTTPmsg#media.type.application.http

空~行l:~HTTPmsg#empty-line
~trailer~header:~HTTPmsg#trailer-field
応答待ち要請:~HTTPmsg#outstanding-request

~header節:#header-section
~trailer節:#chunked.trailer.section
~message本体:#message.body

~chunked:~HTTPmsg#chunked.encoding
~chunked転送~符号法:~HTTPmsg#chunked.encoding
~chunk拡張:~HTTPmsg#chunked.extension
~version:~HTTPmsg#http.version
~protocol~version:~HTTPmsg#http.version

	圧縮~符号法:~HTTPmsg#compression.codings

	実効~要請~URI:~HTTPmsg#h1.effective.request.uri
持続的~接続:~HTTPmsg#persistent.connections
接続~option:~HTTPmsg#connection-option
最終~転送~符号法:~HTTPmsg#final-transfer-coding
転送~符号法の名前:~HTTPmsg#transfer-coding-name
本体~長さ:~HTTPmsg#body-length
端点間~header:~HTTPmsg#end-to-end-header
隣点間~header:~HTTPmsg#hop-by-hop-header

応答~分割:~HTTPmsg#response.splitting
要請~密入:~HTTPmsg#request.smuggling


	●§
7.3:#transfer.coding.registry
7.1.2:#chunked.trailer.part
7.1.3:#decoding.chunked
9.7:#persistent.tear-down
9.9.2:#upgrade.token.registry
11:#security.considerations
A:#collected.abnf
B:#differences.between.http.and.mime
C.2:#changes.from.rfc.7230
D:#change.log
	D.8:#changes.since.0
著作者の~address:#rfc.authors

Semantics/3.5:~HTTPsem#protocol.version
Semantics/4.3:~HTTPsem#trailer.fields
Semantics/5.2:~HTTPsem#routing.inbound
Semantics/5.6:~HTTPsem#message.forwarding
Semantics/6.1.1.2:~HTTPsem#canonicalization.and.text.defaults
Semantics/7.2.2:~HTTPrq#idempotent.methods
Semantics/10.1.1.1:~HTTPrs#http.date
Semantics/12:~HTTPsem#abnf.extension
Semantics/謝辞:~HTTPsem#acks

Caching/3:~HTTPcache#response.cacheability

~message構文解析:#message.parsing

cite.転送~符号法~登記簿:~IANA-a/http-parameters
cite.~HTTP Upgrade ~token登記簿:~IANA-a/http-upgrade-tokens

	~version番号:~HTTPsem#version-number
	権限的:~HTTPsem#authoritative
	既定の~TCP~port
	p.userinfo:3986#section-3.2.1

●●section_map

	rfc.abstract
	rfc.authors
	rfc.copyrightnotice
	rfc.index
	rfc.note.1
	rfc.status

1:#introduction
1.1:#intro.requirements
1.2:#notation
2:#http.message
2.1:#message.format
2.2:#message.parsing
2.3:#http.version
3:#request.line
3.1:#request.method
3.2:#request.target
3.2.1:#origin-form
3.2.2:#absolute-form
3.2.3:#authority-form
3.2.4:#asterisk-form
3.3:#h1.effective.request.uri
4:#status.line
5:#header.fields
5.1:#field.parsing
5.2:#line.folding
6:#message.body
6.1:#header.transfer-encoding
6.2:#body.content-length
6.3:#message.body.length
7:#transfer.codings
7.1:#chunked.encoding
7.1.1:#chunked.extension
7.1.2:#chunked.trailer.part
7.1.3:#decoding.chunked
7.2:#compression.codings
7.3:#transfer.coding.registry
7.4:#header.te
8:#incomplete.messages
9:#connection.management
9.1:#header.connection
9.2:#persistent.establishment
9.3:#associating.response.to.request
9.4:#persistent.connections
9.4.1:#persistent.retrying.requests
9.4.2:#pipelining
9.5:#persistent.concurrency
9.6:#persistent.failures
9.7:#persistent.tear-down
9.9:#header.upgrade
9.9.1:#upgrade.protocol.names
9.9.2:#upgrade.token.registry
10:#enclosing.messages
10.1:#media.type.message.http
10.2:#media.type.application.http
11:#security.considerations
11.1:#response.splitting
11.2:#request.smuggling
11.3:#message.integrity
11.4:#message.confidentiality
12:#IANA.considerations
12.1:#header.field.registration
12.2:#media.type.http
12.3:#transfer.coding.registration
12.4:#upgrade.token.registration
13:#rfc.references

A:#collected.abnf
B:#differences.between.http.and.mime
B.1:#mime-version
B.2:#conversion.to.canonical.form
B.3:#conversion.of.date.formats
B.4:#conversion.content-encoding
B.5:#conversion.content-transfer-encoding
B.6:#mhtml.line.length
C:#compatibility
C.1:#changes.from.1.0
C.1.1:#changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses
C.1.2:#compatibility.with.http.1.0.persistent.connections
C.1.3:#introduction.of.transfer-encoding
C.2:#changes.from.rfc.7230
D:#change.log
D.1:#changes.since.publication.as.rfc
D.2:#changes.since.00
D.3:#changes.since.01
D.4:#changes.since.02

●●words_table1

●●words_table

	●仕様
仮の:hypothetical:~
厳格:stringent:~
場当的:ad hoc:場当たり的
仮想:virtual::~
公正:fair:~
意図n:intention:意図
寛容:lenient:~
精査:examination:~
急増:proliferation:~
悪化-:exacerbate:~
招いて:inviteして:~
普及-:prevalent:~
正当化:justify:~
濫用的:abusive:~
無分別:unwise:~
細工:craft:~
確立法:establishment::~
確約-:assure:~
調べて:surveyして:~
順位:rank:~
壊れて:corruptして:~
免除-:exempt:~
無頓着:oblivious:~
流儀:fashion:~

	欲されない:not desirable
	自由度を高める:greater freedom
	分野:areas
	~~確立:making
	備えておく:prepare
	つもりはない:unprepared
	用意はない:unwilling to
	必要とあらば，:be willing to
	疑いを示すもの:call into question
	目を向け:regard
	最低でも:at a minimum
	機会:chance／
	~~由来:out of deference to
	称され:refer
	窓口:point of
	見え難い:obscure
	見せかけ:look like／apparent
	読み易く:consistent readability
	適度に~~確信できた:reasonably certain
	見込みが高まる:improve the likelihood of
	〜準拠:-compliant
	指定するもの:specifics
	超える:transcend

	●保安
密入:smuggling::~
薬剤相互作用:drug interaction:薬の飲み合わせ
被害:damage:~
迂回-:bypass:~
checksum::::チェックサム

	●network
IP:
	HTTP/1.x
pipeline::::パイプライン
alert:
peer:
再符号され:recode::符号し直され::コードし直され
包装-:wrap::~::ラップ
時間制限:timeout::~::タイムアウト
梱包:packaging:~
流れる:flowする:~
混雑-:congest:~
混雑:congestion:~
相互通信:interaction::~
自動訂正:autocorrect:~
解体:tear-down:~
	^en:head-of-line blocking

	●構文
space:
転化-:translate::~
不正形な:malformed:不正な形の
US-ASCII:
単語:word:~
終了子:terminator::~::ターミネータ
改行:line break:~
切落され:truncateされ:切り落とされ
	切落され:truncation
	^p:rank
	前後:around

	●未分類
export:
MHTML:
digital::::デジタル
hung::::ハング
locale::::ロケール
multihomed:
multibyte::::マルチバイト
上位集合:superset::~::スーパーセット
	~~誤りのある:faulty:
	~random化:randomization
付番方式:numbering scheme:~
保って:keepして:~
入力用:incoming:~
再整形:reformatting:~
医療:medical:~
同時並行性:concurrency:~
幾千:thousands:~
後続-:follow:~
復唱:echo:~
一対一:one-to-one:~
数的:numeric:~

	base64
	sprintf

	●他の語（言い換え
	~frame法:framing
	内包する:inclusion
	抽出する:extraction
	文字大小無視:case-insensitively
	~~余儀なくされ:necessitated
	受容-可能でない:unacceptable
	回復-不能:unrecoverable
	圧縮-済み:compressed
	~~恒久的に居残る:stays forever
	~~発行:issue
	他にアテガって:reassign
	符号化-済み:encoded
	~~直の:immediate
	導入し直:re-introduce
	構築し直:reconstruct
	伝送し直:retransmit
	格納-:storage

	●他の語
	一度:once
	増えて:increase
	それぞれに異なる:each has its own unique
	head-of-line blocking
	long polling
	~~上限:ceiling
	:concatenating
	以上の~version:or later
	全て:intact
	まちまち:varying ways
	最下~層のものから昇順に:layer-ascending order
	欠落している:missing
	締めくくる:conclude
	視る:view
	重い処理を要する:takes significant 〜 processing
	それ以上:no further
	~~各部:portions
	前もって:in advance

●●ref_normative
[Caching]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP Caching”, (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html
[RFC1950]
    Deutsch, L. and J-L. Gailly, “ZLIB Compressed Data Format Specification version 3.3”, ~RFC1950, May 1996
[RFC1951]
    Deutsch, P., “DEFLATE Compressed Data Format Specification version 1.3”, ~RFC1951, May 1996
[RFC1952]
    Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L., and G. Randers-Pehrson, “GZIP file format specification version 4.3”, ~RFC1952, May 1996
[RFC2119]
    Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, ~RFC2119, March 1997
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, ~RFC3986, January 2005
[RFC5234]
    Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, ~RFC5234, January 2008
[RFC7405]
    Kyzivat, P., “Case-Sensitive String Support in ABNF”, ~RFC7405, December 2014
[RFC8446]
    Rescorla, E., “The Transport Layer Security (TLS) Protocol Version 1.3”, ~RFC8446, August 2018
[Semantics]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP Semantics” (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
[USASCII]
    American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI X3.4, 1986.
[Welch]
    Welch, T., “A Technique for High-Performance Data Compression”, IEEE Computer 17(6), June 1984.

●●ref_informative
[Err4667]
    RFC Errata, Erratum ID 4667, RFC 7230, URL: https://www.rfc-editor.org/errata/eid4667
[Klein]
    Klein, A., “Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics”, March 2004, URL: http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf
[Linhart]
    Linhart, C., Klein, A., Heled, R., and S. Orrin, “HTTP Request Smuggling”, June 2005, URL: http://www.watchfire.com/news/whitepapers.aspx
[RFC1945]
    Berners-Lee, T., Fielding, R., and H. Nielsen, “Hypertext Transfer Protocol -- HTTP/1.0”, ~RFC1945, May 1996
[RFC2045]
    Freed, N. and N. Borenstein, “Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies”, ~RFC2045, November 1996
[RFC2046]
    Freed, N. and N. Borenstein, “Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types”, ~RFC2046, November 1996
[RFC2049]
    Freed, N. and N. Borenstein, “Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples”, ~RFC2049, November 1996
[RFC2068]
    Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, ~RFC2068, January 1997
[RFC2557]
    Palme, F., Hopmann, A., Shelness, N., and E. Stefferud, “MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)”, ~RFC2557, March 1999
[RFC5322]
    Resnick, P., “Internet Message Format”, ~RFC5322, October 2008
[RFC7230]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, ~RFC7230, June 2014
[RFC7231]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, ~RFC7231, June 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, ~RFC8126, June 2017

●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.ietf.org/">IETF</a>
による， Internet-Draft
<a href="~SPEC_URL">HTTP/1.1: Messaging</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
発行者
	<a href="https://httpwg.org/">HTTP Working Group</a>
位置付け
	Internet-Draft
廃用
	7230 （承認されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集
	R. Fielding (Adobe)
	M. Nottingham (Fastly)
	J. Reschke (greenbytes)

履歴
	<a href="https://github.com/httpwg/http-core/commits/master">GitHub</a>
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-messaging
HTTP working group mailing list
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)

Draft HTTP Core Documents
	https://github.com/httpwg/http-core

</script>

</head>
<body>

<header>
	<hgroup>
<h1 title="HTTP/1.1: Messaging">HTTP/1.1 メッセージ法（ Messaging ）</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="rfc.abstract">
~ABSTRACT

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、分散型の協調的な~hypertext情報~system用の，`~stateless$な応用~levelの~protocolである。
この文書は、［
`~HTTP11$ ~message構文, 構文解析, 接続の管理, 関係する~securityの懸念
］を指定する。
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document specifies the HTTP/1.1 message syntax, message parsing, connection management, and related security concerns.
</p>

<p>
この文書は、 RFC 7230 を成す~~各部を廃用にする。
◎
This document obsoletes portions of RFC 7230.
</p>

	</section>
	<section id="rfc.note.1">
<h2 title="Editorial Note">編集上の注記</h2>

<p>
この注記は、~RFCとして発行する前に除去されることになる。
◎
This note is to be removed before publishing as an RFC.
</p>

<p>
この草案について論を交わす場, この草案の~source~codeや課題~listは、冒頭の仕様~metadataから見出せる。
◎
Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;https://lists.w3.org/Archives/Public/ietf-http-wg/&gt;.
◎
Working Group information can be found at &lt;https://httpwg.org/&gt;; source code and issues list for this draft can be found at &lt;https://github.com/httpwg/http-core&gt;.
</p>

<p>
この草案における変更点は、 `D$sec 【！D.8】に要約されている。
◎
The changes in this draft are summarized in Appendix D.8.
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>に委譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en-x-a0">
Copyright © 2019 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に委譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、［
~networkに基づく，~hypertext情報~system
］と柔軟にヤリトリするために［
拡張-可能な意味論, および自己記述的な~message
］を利用する，`~stateless$な応用~levelの［
要請, 応答
］~protocolである。
~HTTPは、次に挙げる［
`~HTTP11$仕様を総集的に形成する一連の文書
］により定義される
⇒＃
<a href="~HTTPsem">~HTTP意味論</a> `Semantics$r,
<a href="~HTTPcache">~HTTP~cache法</a> `Caching$r,
~HTTP11~message法（この文書）
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive messages for flexible interaction with network-based hypertext information systems. HTTP is defined by a series of documents that collectively form the HTTP/1.1 specification:
• "HTTP Semantics" [Semantics]
• "HTTP Caching" [Caching]
• "HTTP/1.1 Messaging" (this document)
</p>

<p>
この文書は、~HTTP11［
~message構文と~frame法
］要件, および それらに結付けらる接続~管理を定義する。
その目標は、［
~message意味論に依存しない~HTTP11~messageを取扱うために必要とされる，すべての仕組み
］を定義して，それにより［
~message構文解析器／~messageを回送している中継者
］用の完全な要件の集合を定義することにある。
◎
This document defines HTTP/1.1 message syntax and framing requirements and their associated connection management. Our goal is to define all of the mechanisms necessary for HTTP/1.1 message handling that are independent of message semantics, thereby defining the complete set of requirements for message parsers and message-forwarding intermediaries.
</p>

<p>
この文書は、 `RFC7230$r を成す［
~HTTP11~message法と接続~管理に関係する部位
］を廃用にする
— その変更点は、 `C.2$sec に要約されている。
`RFC7230$r を成す他の各部は、
“~HTTP意味論” `Semantics$r により廃用にされた。
◎
This document obsoletes the portions of RFC 7230 related to HTTP/1.1 messaging and connection management, with the changes being summarized in Appendix C.2. The other parts of RFC 7230 are obsoleted by "HTTP Semantics" [Semantics].
</p>

		<section id="intro.requirements">
<h3 title="Requirements Notation">1.1. 要件の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
適合性の判定基準, ~errorの取扱いに関する考慮点は、`適合性$sec `Semantics$r に定義される。
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
◎
Conformance criteria and considerations regarding error handling are defined in Section 3 of [Semantics].
</p>

		</section>
		<section id="notation">
<h3 title="Syntax Notation">1.2. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#syntax-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
`A$sec にて、すべての~list演算子を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].
◎
It also uses a list extension, defined in Section 12 of [Semantics], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition).＼
◎
Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.
◎
As a convention, ABNF rule names prefixed with "obs-" denote "obsolete" grammar rules that appear for historical reasons.
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).
</p>

<p>
次に挙げる規則は `Semantics$r にて定義される
⇒＃
`BWS$p,
`OWS$p,
`RWS$p,
`absolute-URI$p,
`absolute-path$p,
`authority$p,
`comment$p,
`field-name$p,
`field-value$p,
`obs-text$p,
`port$p,
`query$p,
`quoted-string$p,
`token$p,
`uri-host$p
◎
The rules below are defined in [Semantics]:

  BWS           = &lt;BWS, see [Semantics], Section 11.1&gt;
  OWS           = &lt;OWS, see [Semantics], Section 11.1&gt;
  RWS           = &lt;RWS, see [Semantics], Section 11.1&gt;
  absolute-URI  = &lt;absolute-URI, see [RFC3986], Section 4.3&gt;
  absolute-path = &lt;absolute-path, see [Semantics], Section 2.4&gt;
  authority     = &lt;authority, see [RFC3986], Section 3.2&gt;
  comment       = &lt;comment, see [Semantics], Section 4.2.3.3&gt;
  field-name    = &lt;field-name, see [Semantics], Section 4.1&gt;
  field-value   = &lt;field-value, see [Semantics], Section 4.2&gt;
  obs-text      = &lt;obs-text, see [Semantics], Section 4.2.3.2&gt;
  port          = &lt;port, see [RFC3986], Section 3.2.3&gt;
  query         = &lt;query, see [RFC3986], Section 3.4&gt;
  quoted-string = &lt;quoted-string, see [Semantics], Section 4.2.3.2&gt;
  token         = &lt;token, see [Semantics], Section 4.2.3.1&gt;
  uri-host      = &lt;host, see [RFC3986], Section 3.2.2&gt;
</p>



		</section>
	</section>
	<section id="http.message">
<h2 title="Message">2. ~message</h2>
		<section id="message.format">
<h3 title="Message Format">2.1. ~message形式</h3>

<div class="p">
<p>
`~HTTP11$~messageは、順に［
`start-line$p, `CRLF$P, ある~octet列
］からなる。
この~octet列は，
`Internet Message Format^cite `RFC5322$r に類似な形式であり、次の並びからなる：
◎
An HTTP/1.1 message consists of a start-line followed by a CRLF and a sequence of octets in a format similar to the Internet Message Format [RFC5322]:＼
</p>

<ol>
	<li>
0 個以上の`~header$からなる
`~header節@
（ “`header section^en” ）
◎
zero or more header fields (collectively referred to as the "headers" or the "header section"),＼
</li>
	<li>
~header節の終端を指示する`空~行l$
◎
an empty line indicating the end of the header section, and＼
</li>
	<li>
`~message本体$（省略可）
◎
an optional message body.
</li>
</ol>

</div>

<pre class="ABNF">
`HTTP-message@p
    = `start-line$p `CRLF$P
      *( `header-field$p `CRLF$P )
      <dfn id="empty-line">CRLF</dfn>
      [ `message-body$p ]
</pre>

<div class="p">

<p>
~messageは、［
`~client$から`~server$へ流れる要請
］か［
`~server$から`~client$へ流れる応答
］のいずれかになる。
この 2 つの型の~messageは、次に挙げるものに限り相違する：
◎
A message can be either a request from client to server or a response from server to client. Syntactically, the two types of message differ only in＼
</p>

<ul>
	<li>
`start-line$p の構文は［
要請~用には `request-line$p ／
応答~用には `status-line$p
］になる。
◎
the start-line, which is either a request-line (for requests) or＼
</li>
	<li>
`~message本体$の長さを決定する~algo。
◎
a status-line (for responses), and in the algorithm for determining the length of the message body (Section 6).
</li>
</ul>
</div>

<pre class="ABNF">
`start-line@p
    = `request-line$p / `status-line$p
</pre>

<p class="trans-note">【
これは、~messageの “最初の行l（ first line ）” とも称される。
】</p>

<p>
理論~上は、`~client$も要請を受信でき, `~server$も応答を受信できる
— それらは `start-line$p 形式の相違から判別できるので。
実施においては、~serverは，要請のみを期待するように実装され（応答は，未知または妥当でない`要請~method$と解釈される）、~clientは，応答のみを期待するように実装されている。
◎
In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats. In practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method) and clients are implemented to only expect a response.
</p>

<p>
~HTTPは `RFC2045$r に類似な いくつかの~protocol要素を用立てるが、~HTTPと~MIME~messageとの相違点は `B$sec を見よ。
◎
Although HTTP makes use of some protocol elements similar to the Multipurpose Internet Mail Extensions (MIME) [RFC2045], see Appendix B for the differences between HTTP and MIME messages.
</p>

		</section>
		<section id="message.parsing">
<h3 title="Message Parsing">2.2. ~message構文解析</h3>

<div class="p">

<p>
~HTTP~messageを構文解析するための通常の手続きは、次のようになる：
◎
The normal procedure for parsing an HTTP message is to＼
</p>

<ol>
	<li>
`start-line$p の構造を読取る。
◎
read the start-line into a structure,＼
</li>
	<li>
`空~行l$に遭遇するまで，各`~header$を［
`~header名$を~keyとする~hash~table
］に読取る。
◎
read each header field into a hash table by field name until the empty line, and then＼
</li>
	<li>
前段までに構文解析された~dataを利用して、［
`~message本体$が期待されるかどうか
］を決定する。
◎
use the parsed data to determine if a message body is expected.＼
</li>
	<li>
~message本体が在ることが指示された場合、それを~octetの~streamとして，［
`~message本体~長さ$に等しい量だけ読取られるか, 接続が~closeされる
］まで，読取る。
◎
If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.
</li>
</ol>

</div>

<p>
`受信者$は、~HTTP~messageを，［
~US-ASCII `USASCII$r の上位集合である符号化法による，~octet列
］として構文解析しなければナラナイ。
特定の符号化法について目を向けずに，~HTTP~messageを［
~Unicode文字たちが成す~streamとして構文解析する
］ことは、~securityの脆弱性をもたらす
— それは、［
~octet `LF$P を包含する，妥当でない~multibyte文字~並び
］の取扱いが、文字列~処理~libraryにより，まちまちなことに因る。
文字列に基づく構文解析器を ~protocol要素の中で安全に利用できるのは、その要素が，~messageから抽出された後に限られる
— ~messageを構文解析して，個々の~headerを取り出した後の`~header値$の中など。
◎
A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field-value after message parsing has delineated the individual fields.
</p>

<p>
［
`start-line$p ／各`~header$
］に対する行l終了子は， `CRLF$P ~octet並びであるが、`受信者$は，［
1 個の `LF$P ~octet
］を行l終了子として認識して, 先行する `CR$P を無視してもヨイ。
◎
Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.
</p>

<p>
早期の~server応用には，［
`CRLF$P で終了されていない`~message本体$
］の内容の読取りに失敗するものもあるため、古い~HTTP10~UA実装は，その対処法として，
`POST$m 要請の後に余分な `CRLF$P を送信することがある。
`~HTTP11$`~UA$は、要請の前後に `CRLF$P を付け足してはナラナイ。
`~UA$は、要請~message本体を `CRLF$P で終了させたいときには，その `CRLF$P の分も`~message本体~長さ$に数えなければナラナイ。
◎
Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.
</p>

<p>
堅牢性の~~観点からは、［
`request-line$p を受信して, 構文解析する
］ことを期待している`~server$は、［
`request-line$p に先立って受信された，空~行l
］を，少なくとも 1 行l以上は無視するベキである。
◎
In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.
</p>

<div class="p">

<p>
`送信者$は、［
`start-line$p と最初の`~header$の合間
］に`空白$を送信してはナラナイ。
そのような`空白$を受信した`受信者$は、次のいずれかを行わなければナラナイ：
◎
A sender MUST NOT send whitespace between the start-line and the first header field. A recipient that receives whitespace between the start-line and the first header field MUST either＼
</p>
<ul>
	<li>
~messageを妥当でないものとして却下する。
◎
reject the message as invalid or＼
</li>
	<li>
空白が先行する各~行lを，それ以上~処理せずに消費する（すなわち、［
適正に形成された~headerが受信されるか, または`~header節$が終了される
］まで，後続の, 空白が先行する どの行lも無視する）。
◎
consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).
</li>
</ul>
</div>

<p>
そのような空白が要請に在る場合、［
その~headerを無視させたり,
その後の行lを新たな要請として処理させる
］ような，~serverを騙す試みの~~可能性がある
— そのいずれにせよ、［
要請の`連鎖$上にある他の実装
］が，［
同じ~messageを異なるように解釈する
］場合に、~securityの脆弱性になり得る。
同様に，そのような空白が応答に在る場合、無視する`~client$もあれば，構文解析を止める~clientもある。
◎
The presence of such whitespace in a request might be an attempt to trick a server into ignoring that field or processing the line after it as a new request, either of which might result in a security vulnerability if other implementations within the request chain interpret the same message differently. Likewise, the presence of such whitespace in a response might be ignored by some clients or cause others to cease parsing.
</p>

<p>
`~server$は、［
~HTTP要請~messageのみを~listenしている
］とき, あるいは［［
`start-line$p から出現するものが，~HTTP要請~messageになるかどうか
］を処理している
］ときに，［
`HTTP-message$p 文法に合致しない~octet列
］を受信したときには、上に挙げた堅牢性の例外を除き，［
`400$st 応答
］で応答するベキである。
◎
When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response.
</p>

		</section>
		<section id="http.version">
<h3 title="HTTP Version">2.3. ~HTTP~version</h3>

<p>
~HTTPは、~protocolの各 `~version^dfn を指示するために，
"<code class="grammar">&lt;`~major^V&gt;.&lt;`~minor^V&gt;</code>"
による付番方式を利用する。
この仕様が定義する~version番号は、
"`1.1@c"
である。
~HTTP~version番号の意味論は、
`Semantics/3.5$sec
にて指定される。
◎
HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol. This specification defines version "1.1". Section 3.5 of [Semantics] specifies the semantics of HTTP version numbers.
</p>

<p>
HTTP/1.x ~messageの~versionは、［
`start-line$p 内の `HTTP-version$p ~field
］により指示される。
`HTTP-version$p は文字大小区別である。
◎
The version of an HTTP/1.x message is indicated by an HTTP-version field in the start-line. HTTP-version is case-sensitive.
</p>

<pre class="ABNF">
`HTTP-version@p
    = `HTTP-name$p "/" `DIGIT$P "." `DIGIT$P
`HTTP-name@p
    = ~Ps"HTTP"
</pre>

<p>
~versionが［
~HTTP10 `RFC1945$r あるいは未知
］の`受信者$に向けて送信される`~HTTP11$~messageは、［
より新たな特能すべてが無視されたなら，妥当な~HTTP10~messageとして解釈できる
］ように構築される。
この仕様は、一部の新たな特能に対し，次が守られるように［
受信者~versionの要件
］を設置する
⇒
`送信者$は、自身が当の特能に適合するとしても，［
環境設定や, ~messageの受領を通して，受信者が~HTTP11を~supportする
］ことを決定するまでは、互換な特能のみを利用する。
◎
When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [RFC1945] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored. This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.
</p>

<p>
`中継者$は、~HTTP~messageを処理する（すなわち，`~tunnel$として動作していない）ときは，自身が回送する~message内に［
自前の `HTTP-version$p
］を送信しなければナラナイ。
言い換えれば，`中継者$には、~messageの［
受信, 送信
］の両者において，［
その~message内の~protocol~versionが，自身が適合する~versionに合致する
］ことが確保されない限り，［
`start-line$p を盲目的に回送する
］ことは許容されない。
仮に， `HTTP-version$p を書換えないまま~HTTP~messageが回送された場合、`下流$の`受信者$が［
その`送信者$の~versionを利用して，［
~message送信者との今後の通信~用に安全に利用できる特能
］を決定している
］ときに，通信~errorになるかもしれない。
◎
Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages. In other words, they are not allowed to blindly forward the start-line without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.
</p>

<div class="p">
<p>
`~server$は、`~client$による~HTTP11要請に対し，［
その~clientが，~HTTP仕様を不正に実装していて, 後継~versionの応答を正しく処理できない
］ことが，既知または疑わしいならば、~HTTP10応答を送信してもヨイ
— 例えば、次が既知であるときなど：
◎
A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as＼
</p>

<ul>
	<li>
`~client$が、［
~version番号を正しく構文解析する
］ことに失敗する。
◎
when a client fails to parse the version number correctly or＼
</li>
	<li>
`中継者$が、所与の［
~protocolの`~minor~version$
］に自身が適合しないときにも， `HTTP-version$p を盲目的に回送する。
◎
when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.＼
</li>
</ul>

<p>
そのような［
~protocolの降格
］は、［
特定の~client属性により誘発されたもの
］でない限り，遂行されるベキでない
— 例えば：
1 個~以上の要請~header（例： `User-Agent$h ）が、［［
~errorにあることが既知である，ある~client
【~client実装~version】
］が送信する値
］に，一意に合致するときなど。
◎
Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.
</p>
</div>

		</section>
	</section>
	<section id="request.line">
<h2 title="Request Line">3. `request-line^p</h2>

<p>
`request-line$p の構文は、次で与えられる：
◎
A request-line begins with a method token, followed by a single space (SP), the request-target, another single space (SP), and ends with the protocol version.
</p>

<pre class="ABNF">
`request-line@p
    = `method$p `SP$P `request-target$p `SP$P `HTTP-version$p
</pre>

<p>
文法~規則 `request-line$p は，［
各種~成分~要素どうしが 1 個の `SP$P ~octetで分離される
］ことを要求しているが、`受信者$は，代わりに
空白で区切られる単語~境界を構文解析した上で，終了子の `CRLF$P は別として，頭部／尾部の空白は無視しつつ, 任意の形による空白を `SP$P 分離子と扱ってもヨイ
— そのような空白は、 1 個~以上の，次の~octetからなり得る：［
`SP$P,
`HTAB$P,
`VT^P (`0B^X),
`FF^P (`0C^X), ［
`CRLF$P の一部でない `CR$P
］］。
しかしながら，寛容な構文解析-法は、［
~messageに対し複数の`受信者$が居て、堅牢性のための解釈が，それぞれに異なる場合
］に，~securityの脆弱性になり得る（§`要請~密入$を見よ）。
◎
Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).
</p>

<div class="p">
<p>
~HTTPは、
`適合性$sec `Semantics$r
にて述べるように，
`request-line$p の長さに対する定義済み制限は設置しない。
`~server$は：
◎
HTTP does not place a predefined limit on the length of a request-line, as described in Section 3 of [Semantics].＼
</p>

<ul>
	<li>
［
自身が実装するよりも長い `method$p
］を受信したときは、
`501$st で応答するベキである。
◎
A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code.＼
</li>
	<li>
［
自身が望んで構文解析する どの`~URI$よりも長い `request-target$p
］を受信したときは、
`414$st で応答しなければナラナイ。
◎
A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 9.5.15 of [Semantics]).
</li>
</ul>
</div>

<p>
実施においては、
`request-line$p の長さには，様々な場当的な制限が見出される。
すべての~HTTP［
`送信者$／`受信者$
］は、この長さとして，~octet数で最低でも 8000 以上を~supportするベキである【！RECOMMENDED】。
◎
Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.
</p>

		<section id="request.method">
<h3 title="Method">3.1. ~method</h3>

<p>
`method$p `token^p は、［
`~target資源$上で遂行される`要請~method$
］を指示する。
要請~methodは、文字大小区別である。
◎
The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.
</p>

<pre class="ABNF">
`method@p
    = `token$p
</pre>

<p>
要請~methodは、次も含め，`要請~method$sec `Semantics$r に定義される
⇒＃
~HTTP~method登記簿に関する情報,
新たな~methodを定義する際の考慮点
◎
The request methods defined by this specification can be found in Section 7 of [Semantics], along with information regarding the HTTP method registry and considerations for defining new methods.
</p>

		</section>
		<section id="request.target">
<h3 title="Request Target">3.2. 要請~target</h3>

<p>
`request-target$p は、要請を どの~target資源に適用するかを識別する。
`~client$は、欲された`~target~URI$から `request-target$p を導出する。
要請~targetには、［
要請された~method,
要請は`~proxy$向けかどうか
］の両者に依存して， 4 種の別個な形式がある：
◎
The request-target identifies the target resource upon which to apply the request. The client derives a request-target from its desired target URI. There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.
</p>

<pre class="ABNF">
`request-target@p
    = `origin-form$p
    / `absolute-form$p
    / `authority-form$p
    / `asterisk-form$p
</pre>

<p>
`request-target$p 内には、空白は許容されない。
あいにく，一部の`~UA$は［
~hypertext参照に見出される空白
］を適正に［
符号化する／除外する
］ことに失敗する
— その結果、許容されない それらの文字が，不正形な `request-line$p 内に `request-target$p として送信されることになる。
◎
No whitespace is allowed in the request-target. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent as the request-target in a malformed request-line.
</p>

<div class="p">
<p>
`受信者$は、妥当でない `request-line$p に対しては：
◎
Recipients of an invalid request-line＼
</p>

<ul>
	<li>
<p>
次のいずれかで応答するベキである：
◎
SHOULD respond with either＼
</p>
		<ul>
			<li>
`400$st ~error
◎
a 400 (Bad Request) error or＼
</li>
			<li>
［
適正に符号化された `request-target$p
］を伴う `301$st ~redirect
◎
a 301 (Moved Permanently) redirect with the request-target properly encoded.＼
</li>
		</ul>
	</li>
	<li>
~redirectせずに，要請を自動訂正して処理しようと試みるベキでない
— 妥当でない `request-line$p は、要請の`連鎖$沿いにある~security~filterを迂回するために，故意に細工された~~可能性もあるので。
◎
A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.
</li>
</ul>
</div>

			<section id="origin-form">
<h4 title="origin-form">3.2.1. `origin-form^p</h4>

<p>
`request-target$p の最も共通的な形は、 `origin-form$p である：
◎
The most common form of request-target is the origin-form.
</p>

<pre class="ABNF">
`origin-form@p
    = `absolute-path$p [ "?" `query$p ]
</pre>

<p>
`~client$は、［
`CONNECT$m ／`~server-wide$ `OPTIONS$m
］（詳細は後述）以外の要請を，`生成元~server$へ直に為すときは、
`request-target$p として，`~target~URI$の［
`absolute-path$p, `query$p
］成分のみを送信しなければナラナイ。
`~target~URI$の `path$p 成分が空の場合、~clientは，［
`request-target$p の `origin-form$p の中の `path$p
］として
"`/^c"
を送信しなければナラナイ。
また、 `Host$h ~headerも，その定義に従って送信することになる。
◎
When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send only the absolute path and query components of the target URI as the request-target. If the target URI's path component is empty, the client MUST send "/" as the path within the origin-form of request-target. A Host header field is also sent, as defined in Section 5.4 of [Semantics].
</p>

<div class="example">

<p>
例えば、~clientが［
次で識別される`資源$
］の`表現$を検索取得したいと望むときは：
◎
For example, a client wishing to retrieve a representation of the resource identified as
</p>

<pre>
http://www.example.org/where?q=now
</pre>

<p>
［
~host "`www.example.org^c" の~port 80
］への~TCP接続を，`生成元~server$から直に~openして（または再利用して）、次の 2 行l：
◎
directly from the origin server would open (or reuse) a TCP connection to port 80 of the host "www.example.org" and send the lines:
</p>

<pre class="http-code">
GET /where?q=now HTTP/1.1
Host: www.example.org
</pre>

<p>
および，後続して要請~messageの残りの部分を，送信することになろう。
◎
followed by the remainder of the request message.
</p>

</div>

			</section>
			<section id="absolute-form">
<h4 title="absolute-form">3.2.2. `absolute-form^p</h4>

<p>
`~client$は、［
`CONNECT$m ／`~server-wide$ `OPTIONS$m
］（詳細は後述）以外の要請を，`~proxy$へ向けて為すときは、
`request-target$p として，
`absolute-form$p による`~target~URI$を送信しなければナラナイ。
◎
When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in absolute-form as the request-target.
</p>

<pre class="ABNF">
`absolute-form@p
    = `absolute-URI$p
</pre>

<p>
要請を受けた`~proxy$は、［
アリなら，それに対し有効な`~cache$で~serviceする
］か, あるいは、~clientに利するため［
`内方$にある次の~proxy~serverへ向けて
］または［
`request-target$p が指示する`生成元~server$へ向けて，直に
］同じ要請を為す。
そのような~messageの “回送-法” に課される要件は、
`Semantics/5.6$sec【！5.5】
にて定義される。
◎
The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf to either the next inbound proxy server or directly to the origin server indicated by the request-target. Requirements on such "forwarding" of messages are defined in Section 5.5 of [Semantics].
</p>

<div class="example">

<p>
`absolute-form$p による `request-target$p を伴う `request-line$p の例：
◎
An example absolute-form of request-line would be:
</p>

<pre class="http-code">
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</pre>

</div>

<p>
［
~HTTPの将来の`~version$における，すべての要請にわたる `absolute-form$p への移行
］を許容するため、`~server$は，［
要請~内の `absolute-form$p
］を受容しなければナラナイ
— ~HTTP11~clientが，それらを`~proxy$向けの要請~内にのみ送信することになるとしても。
◎
To allow for transition to the absolute-form for all requests in some future version of HTTP, a server MUST accept the absolute-form in requests, even though HTTP/1.1 clients will only send them in requests to proxies.
</p>

			</section>
			<section id="authority-form">
<h4 title="authority-form">3.2.3. `authority-form^p</h4>

<p>
`authority-form$p による `request-target$p が利用されるのは、
`CONNECT$m 要請に限られる：
◎
The authority-form of request-target is only used for CONNECT requests (Section 7.3.6 of [Semantics]).
</p>

<pre class="ABNF">
`authority-form@p
    = `authority$p
</pre>

<p>
`~client$は，［
1 個~以上の`~proxy$
］を通した`~tunnel$を確立するために， `CONNECT$m 要請を為すときは、
`request-target$p として，`~target~URI$の `authority$p 成分（ただし， `userinfo$p および, その "`@^c" 区切子は除外する）のみを送信しなければナラナイ。
◎
When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the target URI's authority component (excluding any userinfo and its "@" delimiter) as the request-target. For example,
</p>

<div class="example">
<p>
`authority-form$p による `request-target$p を伴う `request-line$p の例：
</p>

<pre class="http-code">
CONNECT www.example.com:80 HTTP/1.1
</pre>
</div>

			</section>
			<section id="asterisk-form">
<h4 title="asterisk-form">3.2.4. `asterisk-form^p</h4>

<p>
`asterisk-form$p による `request-target$p が利用されるのは、`~server-wide$に適用される `OPTIONS$m 要請に限られる。
◎
The asterisk-form of request-target is only used for a server-wide OPTIONS request (Section 7.3.7 of [Semantics]).
</p>

<pre class="ABNF">
`asterisk-form@p
    = "*"
</pre>

<p>
`~client$が，`~server$に対し `~server-wide$ `OPTIONS$m のみを
— その~serverにおける特定の名前の`資源$を~~指すことなく —
要請したいと望むときは、
`request-target$p として，
"`*^c" (`2A^X）のみを送信しなければナラナイ。
◎
When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only "*" (%x2A) as the request-target. For example,
</p>

<div class="example">
<p>
`asterisk-form$p による `request-target$p を伴う `request-line$p の例：
</p>

<pre class="http-code">
OPTIONS * HTTP/1.1
</pre>
</div>

<p>
`OPTIONS$m 要請を受信した`~proxy$は、［
要請の `request-target$p は［
~pathが空, かつ `query$p 成分が無い`~URI$
］を与える `absolute-form$p
］であって，［
自身が要請の`連鎖$上にある最後の`~proxy$である
］ならば、その要請を指示された`生成元~server$へ向けて回送するときに，
`request-target$p として
"`*^c" を送信しなければナラナイ。
◎
If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of "*" when it forwards the request to the indicated origin server.
</p>

<div class="example">
<p>
例えば、次の要請は：
◎
For example, the request
</p>

<pre class="http-code">
OPTIONS http://www.example.org:8001 HTTP/1.1
</pre>

<p>
最終`~proxy$においては、［
~host "`www.example.org^c" の~port 8001
］へ接続した後，次のように回送することになろう：
◎
would be forwarded by the final proxy as
</p>

<pre class="http-code">
OPTIONS * HTTP/1.1
Host: www.example.org:8001
</pre>

<p>
—
◎
after connecting to port 8001 of host "www.example.org".
</p>

</div>

			</section>
		</section>
		<section id="h1.effective.request.uri">
<h3 title="Effective Request URI">3.3. 実効~要請~URI</h3>

<p>
`request-target$p は，［
`~UA$の`~target~URI$の一部分のみ
］を包含することが多いので、`~server$は，意図された~targetを
— 要請に対し適正に~serviceするために —
`実効~要請~URI$として構築し直す。【！5.3】
◎
Since the request-target often contains only part of the user agent's target URI, a server reconstructs the intended target as an effective request URI to properly service the request (Section 5.3 of [Semantics]).
</p>

<p>
`実効~要請~URI$は、所与の
( `request-target$p `要請~target^V )
に対し，［
`要請~target^V は `absolute-form$p である
］ならば `要請~target^V と同じであり，他の場合は 次に従って構築される：
◎
If the request-target is in absolute-form, the effective request URI is the same as the request-target. Otherwise, the effective request URI is constructed as follows:
</p>

<ol>
	<li>
<p>
その `scheme$p 成分は：
</p>
		<ol>
			<li>
`~server$の環境設定（または`外方$にある`~gateway$）にて，固定的な~URI~schemeが供されているならば
⇒
その~scheme
</li>
			<li>
他の場合，［
要請は TLS で~secure化された~TCP接続~越しに受信された
］ならば
⇒
"`https$c"
</li>
			<li>
他の場合
⇒
"`http$c"
</li>
		</ol>

◎
If the server's configuration (or outbound gateway) provides a fixed URI scheme, that scheme is used for the effective request URI. Otherwise, if the request is received over a TLS-secured TCP connection, the effective request URI's scheme is "https"; if not, the scheme is "http".
</li>
	<li>
<p>
その `authority$p 成分は：
</p>
		<ol>
			<li>
`~server$の環境設定（または`外方$にある`~gateway$）にて，固定的な~URI `authority$p 成分が供されているならば
⇒
その `authority$p 。
</li>
			<li>
他の場合，［
`要請~target^V は `authority-form$p である
］ならば
⇒
`要請~target^V と同じ。
</li>
			<li>
他の場合，［
`Host$h ~headerが給されていて，その`~header値$は空でない
］ならば
⇒
その~header値。
</li>
			<li>
他の場合
⇒
`~server$に環境設定された既定の名前
— 更に，［
接続の入力用~TCP~port番号が［
`実効~要請~URI$の `scheme$p 用の既定の~port
］と相違する場合は，［
~colon （"`:^c"）, および（~decimal形による）その入力用~port番号
］も付加する。
</li>
		</ol>

◎
If the server's configuration (or outbound gateway) provides a fixed URI authority component, that authority is used for the effective request URI. If not, then if the request-target is in authority-form, the effective request URI's authority component is the same as the request-target. If not, then if a Host header field is supplied with a non-empty field-value, the authority component is the same as the Host field-value. Otherwise, the authority component is assigned the default name configured for the server and, if the connection's incoming TCP port number differs from the default port for the effective request URI's scheme, then a colon (":") and the incoming port number (in decimal form) are appended to the authority component.
</li>
	<li>
<p>
その結合された［
`path$p, `query$p
］成分は、 `要請~target^V の形式に応じて，次で与えられる：
</p>
		<dl class="switch">
			<dt>`authority-form$p</dt>
			<dt>`asterisk-form$p </dt>
			<dd>
空。
</dd>

			<dt>`origin-form$p</dt>
			<dd>
`要請~target^V と同じ。
</dd>
		</dl>

◎
If the request-target is in authority-form or asterisk-form, the effective request URI's combined path and query component is empty. Otherwise, the combined path and query component is the same as the request-target.
</li>
	<li>
`実効~要請~URI$は、［
上で決定された各~成分, および 文字列 "`://^c"
］を，次の順に連結した結果の `absolute-URI$p 形
【 `absolute-form$p 】
になる
⇒＃
`scheme$p,
"`://^c",
`authority$p,
結合された `path$p, `query$p 成分
◎
The components of the effective request URI, once determined as above, can be combined into absolute-URI form by concatenating the scheme, "://", authority, and combined path and query component.
</li>
</ol>

<div class="example">

<p>
~secureでない~TCP接続~越しに受信された，次の~messageの：
◎
Example 1: the following message received over an insecure TCP connection
</p>

<pre class="http-code">
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
</pre>

<p>
実効~要請~URIは：
◎
has an effective request URI of
</p>

<pre>
http://www.example.org:8080/pub/WWW/TheProject.html
</pre>

<p>
TLS で~secure化された~TCP接続~越しに受信された，次の~messageの：
◎
Example 2: the following message received over a TLS-secured TCP connection
</p>

<pre class="http-code">
OPTIONS * HTTP/1.1
Host: www.example.org
</pre>

<p>
実効~要請~URIは：
◎
has an effective request URI of
</p>

<pre>
https://www.example.org
</pre>

</div>

<p>
［
`Host$h ~headerを欠如する~HTTP10要請
］の`受信者$は、［
`実効~要請~URI$の `authority$p 成分
］を推測するために，経験則（例： 特定0の~hostに一意な何かに対する，~URI~pathの精査）の利用が必要になることもある。
◎
Recipients of an HTTP/1.0 request that lacks a Host header field might need to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to guess the effective request URI's authority component.
</p>

		</section>
	</section>
	<section id="status.line">
<h2 title="Status Line">4. 状態s行l</h2>

<p>
応答~messageの最初の行lは，状態s行l（ `status-line$p ）と呼ばれ、次の順による並びからなる
⇒＃
`~protocol~version$,
1 個の~space `SP^P,
`状態s~code$,
1 個の~space `SP^P,
`省略可能^2119な状態s~codeについて述べる~textな句
◎
The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, another space, and ending with an OPTIONAL textual phrase describing the status code.
</p>

<pre class="ABNF">
`status-line@p
    = `HTTP-version$p `SP$P `status-code$p `SP$P [`reason-phrase$p]
</pre>

<p>
文法~規則 `status-line$p は，［
各種~成分~要素どうしが 1 個の `SP$P ~octetで分離される
］ことを要求しているが、`受信者$は，代わりに
空白で区切られる単語~境界を構文解析した上で
— 行l終了子は別として, および頭部／尾部の空白は無視した上で —
任意の形による空白を `SP$P 分離子と扱ってもヨイ
— そのような空白は、 1 個~以上の，次に挙げる~octetからなり得る
⇒＃
`SP$P,
`HTAB$P,
`VT^P  (`0B^X),
`FF^P  (`0C^X), ［
`CRLF$P の一部を成さない `CR$P
◎
Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.＼
</p>

<p>
しかしながら，寛容な構文解析-法は、［
~messageに対し複数の`受信者$が居て，堅牢性を得るための解釈が それぞれに異なる
］場合に，~securityの脆弱性になり得る
— `応答~分割$secを見よ。
◎
However, lenient parsing can result in response splitting security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.1).
</p>

<p>
`status-code$p 要素は，応答の`状態s~code$を~~表す 3 桁の整数~codeであり、`~server$が［
対応ng，`~client$からの要請
］を，解して, 満足しようと試みた結果を述べる。
応答~messageの残りの部分は、その状態s~codeに定義されている意味論に照らし合わせて，解釈される。
◎
The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request. The rest of the response message is to be interpreted in light of the semantics defined for that status code.
</p>

<pre class="ABNF">
`status-code@p
    = 3`DIGIT$P
</pre>

<p>
`状態s~code$の意味論 `Semantics$r には、次に挙げる情報も含まれる
⇒＃
状態s~codeの最初の桁で指示される，応答の`応答class$,
この仕様にて定義される各種 状態s~code,
新たな状態s~codeを定義する際の考慮点,
~IANA登記簿
◎
See Section 9 of [Semantics] for information about the semantics of status codes, including the classes of status code (indicated by the first digit), the status codes defined by this specification, considerations for the definition of new status codes, and the IANA registry.
◎
status-code = 3DIGIT
</p>

<p>
`reason-phrase$p 要素は、もっぱら［
数的な`状態s~code$に結付けられた，~textな説明d
］を供する目的で存在する（空でもよい）
— そのほとんどは、［
対話的~text~clientにより より頻繁に利用されていた，早期の~Internet応用~protocol
］に~~由来している。
◎
The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients.
</p>

<pre class="ABNF">
`reason-phrase@p
    = 1*( `HTAB$P / `SP$P / `VCHAR$P / `obs-text$p )
</pre>

<p>
`~client$は、 `reason-phrase$p の内容を無視するベキである
— それは、情報~用の~channelとして依拠-可能でないので（それは、所与の~localeに翻訳されたり,
`中継者$により上書きされたり,
他の~HTTP~versionを介して~messageが回送されるときに破棄されることもある）。
`~server$は、 `reason-phrase$p が無い場合でも，それを `status-code$p から分離する~spaceは送信しなければナラナイ（その場合、 `status-line$p は 3 個の~octet `SP^P `CR^P `LF^P で終端することになる）。
◎
A client SHOULD ignore the reason-phrase content because it is not a reliable channel for information (it might be translated for a given locale, overwritten by intermediaries, or discarded when the message is forwarded via other versions of HTTP). A server MUST send the space that separates status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the three octets SP CR LF).
</p>


	</section>
	<section id="header.field.syntax">
<h2 title="Header Field Syntax">5. ~header（ ~header~field ）の構文</h2>

<p class="trans-note">【
この訳に現れる語 “~header” は、
“`~header節$” を除き，ほぼすべて “~header~field” の略記である。
】</p>

<p>
各 `~header$の構文は、次で与えられる：
◎
Each header field consists of a case-insensitive field name followed by a colon (":"), optional leading whitespace, the field value, and optional trailing whitespace.
</p>

<pre class="ABNF">
`header-field@p
    = `field-name$p ":" `OWS$p `field-value$p `OWS$p
</pre>

<p>
ほとんどの~HTTP`~header名$, および［
`~header値$の中での構文解析~用の規則
］は、`~header$sec `Semantics$r に定義される。
この節は、~headerを~HTTP11~message［
の中に内包する／から抽出する
］ための汎用~構文を受持つ。
◎
Most HTTP field names and the rules for parsing within field values are defined in Section 4 of [Semantics]. This section covers the generic syntax for header field inclusion within, and extraction from, HTTP/1.1 messages.＼
<p>

<p>
加えて，この文書は、次に挙げる，~HTTP11~message処理に特有な~headerを定義する
— どれも，位置付けは標準（ `standard^en ）である
⇒＃
`Connection$h,
`MIME-Version$h,
`TE$h,
`Transfer-Encoding$h,
`Upgrade$h
◎
In addition, the following header fields are defined by this document because they are specific to HTTP/1.1 message processing:
◎
Table 1
◎
Header Field Name 	Status 	Reference
Connection 	standard 	Section 9.1
MIME-Version 	standard 	Appendix B.1
TE 	standard 	Section 7.4
Transfer-Encoding 	standard 	Section 6.1
Upgrade 	standard 	Section 9.9
</p>

<p>
更に，`~header名$ `Close^h の位置付けは、予約-済みである
— その名前を~HTTP~headerとして利用すると、
`Connection$h ~headerの `~close_接続~option$と競合するかもしれないので。
◎
Furthermore, the field name "Close" is reserved, since using that name as an HTTP header field might conflict with the "close" connection option of the Connection header field (Section 9.1).
◎
Header Field Name 	Protocol 	Status 	Reference
Close 	http 	reserved 	Section 5
</p>

		<section id="field.parsing">
<h3 title="Header Field Parsing">5.1. ~headerの構文解析</h3>

<p>
~messageは、［
個々の`~header名$に依存しない，汎用~algo
］を利用して構文解析される。
所与の`~header値$の内容は、~message解釈の今後の段階（通例的に，~messageの`~header節$全体が処理された後になる）まで，構文解析されない。
◎
Messages are parsed using a generic algorithm, independent of the individual header field names. The contents within a given field value are not parsed until a later stage of message interpretation (usually after the message's entire header section has been processed).
</p>

<p>
`~header$における `field-name$p と~colonの合間には，`空白$は許容されない。
過去においては，［
そのような空白の取扱いにおける相違点
］から、
要請の~route法／応答の取扱い
に，~securityの脆弱性が導かれていた。
［
~headerにそのような空白を内包するような要請~message
］を受信した`~server$は、状態s~code `400$st で応答して，それを却下しなければナラナイ。
`~proxy$は、~messageを`下流$に回送する前に，応答~messageから そのような空白すべてを除去しなければナラナイ。
◎
No whitespace is allowed between the header field-name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject any received request message that contains whitespace between a header field-name and colon with a response status code of 400 (Bad Request). A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.
</p>

<p>
`~header値$の前後には、省略可能な空白（ `OWS$p ）が［
先行する／後続する
］こともある
— ヒトから読み易くするため、 `field-value$p には， 1 個の `SP$P を先行させることが選好される。
~header値 自体は、［
頭部／尾部
］の`空白$を内包しない：
~header値の［
最初の非~空白~octetより前 ／ 最後の非~空白~octetより後
］に生じる `OWS$p は、~headerから~header値を抽出するときには，構文解析器により除外される~OUGHT。
◎
A field value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field-value is preferred for consistent readability by humans. The field value does not include any leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field value or after the last non-whitespace octet of the field value ought to be excluded by parsers when extracting the field value from a header field.
</p>

		</section>
		<section id="line.folding">
<h3 title="Obsolete Line Folding">5.2. 廃用にされた行l折返し</h3>

<p>
歴史的に、~HTTP~header値は，複数~行lにも渡れるように拡張されていた
— 2 行l~目 以降の各~行lに， 1 個~以上の［
`SP$P や `HTAB$P
］を先行させること（ `obs-fold$p ）により。
この仕様は、［
~MIME型 `message/http$c の中
］を除いて，そのような行l折返しを非推奨にする。
◎
Historically, HTTP header field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the message/http media type (Section 10.1).
</p>

<pre class="ABNF">
`obs-fold@p
    = `OWS$p `CRLF$P `RWS$p
    ; <span class="comment">廃用にされた行l折返し
◎
obsolete line folding
</span>
</pre>

<p>
`送信者$は、行l折返しを内包する（すなわち， `obs-fold$p 規則に合致する部分を包含する `field-value$p がある）~messageを
— ~MIME型 `message/http^c への梱包を意図するときを除き —
`生成し$てはナラナイ。
◎
A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type.
</p>

<p>
［
`message/http$c ~containerの中でない要請~message内
］に `obs-fold$p を受信したときは：
◎
↓</p>

<ul>
	<li>
<p>
`~server$は、次のいずれかを行わなければナラナイ：
◎
A server that receives an obs-fold in a request message that is not within a message/http container MUST either＼
</p>

		<ul>
			<li>
`400$st を送信して，~messageを却下する — それには，［［
廃用にされた行l折返しは，受容-可能でない
］ことを説明する表現
］が伴われることが好ましい。
◎
reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or＼
</li>
			<li>
［
`~header値$を解釈したり, ~messageを`下流$へ回送する
］に先立って、受信された各 `obs-fold$p を， 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
</li>
		</ul>
	</li>
	<li>
<p>
［
`~proxy$／`~gateway$
］は、次のいずれかを行わなければナラナイ：
◎
A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either＼
</p>

		<ul>
			<li>
~messageを破棄して， `502$st 応答に置換する — それには，［［
受容-可能でない行l折返しが受信された
］ことを説明する表現
］が伴われることが好ましい。
◎
discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or＼
</li>
			<li>
［
`~header値$を解釈したり, ~messageを`下流$へ回送する
］に先立って、受信された各 `obs-fold$p を， 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
</li>
		</ul>
	</li>
	<li>
<p>
`~UA$は、次を行わなければナラナイ：
◎
A user agent that receives an obs-fold in a response message that is not within a message/http container MUST＼
</p>
		<ul>
			<li>
［
`~header値$を解釈する
］に先立って、受信された各 `obs-fold$p を， 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value.
</li>
		</ul>
	</li>
</ul>

		</section>
	</section>
	<section id="message.body">
<h2 title="Message Body">6. ~message本体</h2>

<p>
~HTTP~messageの~message本体（もし在れば）は、その［
要請／応答
］の`~payload本体$を運ぶために利用される。
`Transfer-Encoding$h に述べるように，`転送~符号法$が適用されていない限り、~message本体は，~payload本体に一致する。
◎
The message body (if any) of an HTTP message is used to carry the payload body (Section 6.3.3 of [Semantics]) of that request or response. The message body is identical to the payload body unless a transfer coding has been applied, as described in Section 6.1.
</p>

<p class="trans-note">【
すなわち、~message本体は，~messageに埋め込まれた~dataそのままを意味し、~payload本体は，`転送~符号法$による符号化は［
施されていない／復号された
］~dataを意味する（端点からの視点では、~payload本体は，［
中継者を透過的な~~存在と見なした下で，実質的にやりとりされる本体~data
］と捉えられる）。
】</p>

<pre class="ABNF">
`message-body@p
    = *`OCTET$P
</pre>

<p>
~HTTP11~message内に いつ~message本体が在るか決定する規則は、要請と応答で相違する。
◎
The rules for determining when a message body is present in an HTTP/1.1 message differ for requests and responses.
</p>

<p>
要請に~message本体が在ることは、［
`Content-Length$h または `Transfer-Encoding$h 
］~headerにより通達される。
要請~messageの~frame法が，`~method$の意味論に依存することはない
— ~methodが，~message本体の利用について何も定義していなくても。
◎
The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field. Request message framing is independent of method semantics, even if the method does not define any use for a message body.
</p>

<p>
応答の~message本体の有無は、［
それが応答している要請の`~method$,
`応答~状態s~code$（ `status-line$p ）
］の両者に依存し，`~payload本体$がいつ許容されるかに対応する。
`~payload本体$を見よ。
◎
The presence of a message body in a response depends on both the request method to which it is responding and the response status code (Section 4), and corresponds to when a payload body is allowed; see Section 6.3.3 of [Semantics].
</p>

		<section id="header.transfer-encoding">
<h3 title="Transfer-Encoding">6.1. `Transfer-Encoding^h</h3>

<p>
`Transfer-Encoding$h ~headerは、一連の［
`~message本体$を形成するために，`~payload本体$に適用された（または適用されることになる）`転送~符号法$
］に対応する，一連の`転送~符号法の名前$を~listする：
◎
The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body. Transfer codings are defined in Section 7.
</p>

<pre class="ABNF">
`Transfer-Encoding@p
    = 1#`transfer-coding$p
</pre>

<div class="p">
<p>
`Transfer-Encoding$h は、~binary~dataの安全な~transportを
7-bit ~transport~service越しに可能化するために設計された，
~MIMEの `Content-Transfer-Encoding$h ~header `RFC2045$r
に相似的である。
しかしながら，安全な~transportは、転送~protocolを `8bit-clean^en にするという，異なる面に力点を置いている。
~HTTPにおける `Transfer-Encoding$h には、首に，次が意図されている：
◎
Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended＼
</p>

<ul>
	<li>
動的に`生成され$る`~payload$を正確aに区切る。
◎
to accurately delimit a dynamically generated payload and＼
</li>
	<li>
`~payload$に適用されている符号化法が、［
~transportの効率性のためのみ
］であるか, ［
選定された`資源$の特性に因る~securityのため
］かを判別する。
◎
to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.
</li>
</ul>

</div>

<div class="p">

<p>
`受信者$は、`~chunked転送~符号法$を構文解析できなければナラナイ
— 何故ならそれは、［
`~payload本体$の~sizeが前もって既知でない下で，~messageを~frame化するとき
］に，不可欠な役割を担うので。
◎
A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the payload body size is not known in advance.＼
</p>

<p>
`送信者$は：
◎
＼</p>
<ul>
	<li>
`~message本体$に対し，複数回の~chunk化を適用してはナラナイ（すなわち，すでに~chunk化された~messageを更に~chunk化することは許容されない）。
◎
A sender MUST NOT apply chunked more than once to a message body (i.e., chunking an already chunked message is not allowed).＼
</li>
	<li>
`~chunked$以外の`転送~符号法$が，要請`~payload本体$に適用された場合、［
~messageが適正に~frame化される
］ことを確保するために，~chunkedを
`最終~転送~符号法@
として適用しなければナラナイ。
◎
If any transfer coding other than chunked is applied to a request payload body, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.＼
</li>
	<li>
`~chunked$以外の`転送~符号法$が，応答`~payload本体$に適用された場合、［
~chunkedを`最終~転送~符号法$として適用する
］か, または［
接続を~closeして~messageを終了させ
］なければナラナイ。
◎
If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.
</li>
</ul>
</div>

<div class="example">

<p>
例えば、次のものは：
◎
For example,
</p>

<pre class="http-code">
Transfer-Encoding: gzip, chunked
</pre>

<p>
`~payload本体$が，~message本体を形成する際に［
"`gzip$c" 符号法を利用して圧縮された上で，
~chunked符号法を利用して~chunk化されている
］ことを指示する。
◎
indicates that the payload body has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.
</p>

</div>

<p>
`Content-Encoding$h による`内容~符号法$と~~違って、
`Transfer-Encoding$h は，~messageの~propertyであり，表現のそれではない：
［
要請／応答
］の`連鎖$沿いにある どの`受信者$も，受信された`転送~符号法$（たち）を復号したり,
`~message本体$に追加的な`転送~符号法$（たち）を適用してもヨイ
— `Transfer-Encoding$h `~header値$にも，対応ng変更sを加えた上で。
符号化~parameterについての追加的な情報も、この仕様で定義されない他の~headerにて供され得る。
◎
Unlike Content-Encoding (Section 6.1.2 of [Semantics]), Transfer-Encoding is a property of the message, not of the representation, and any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field-value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>

<p>
`Transfer-Encoding$h は、［
`HEAD$m 要請に対する応答 ／
`GET$m 要請に対する `304$st 応答
］内に，送信されてもヨイ
— この いずれも~message本体を内包しない —
それは、［
要請が条件付きでない `GET$m だとしたときに，`生成元~server$が~message本体に適用することになる`転送~符号法$
］を指示する。
しかしながら，この指示は、要求されてはいない
— 応答の`連鎖$上にある どの`受信者$も（`生成元~server$も含む）、不要になり次第，転送~符号法を除去できるので。
◎
Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 9.4.5 of [Semantics]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.
</p>

<div class="p">
<p>
`~server$は、次に挙げるどの応答にも，
`Transfer-Encoding$h ~headerを送信してはナラナイ：
◎
A server MUST NOT send a Transfer-Encoding header field in＼
</p>

<ul>
	<li>
状態s~codeに［
`1xx$st ／ `204$st 
］を伴う応答
◎
any response with a status code of 1xx (Informational) or 204 (No Content).＼
</li>
	<li>
`CONNECT$m 要請に対する `2xx$st 応答
◎
A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 7.3.6 of [Semantics]).
</li>
</ul>
</div>

<div class="p">
<p>
`Transfer-Encoding$h は、`~HTTP11$にて追加された。
［
~HTTP10の~supportのみを広告している実装
］は、一般に，転送~符号化-済み`~payload$を処理する方法を解さないものと見做されている：
◎
Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process a transfer-encoded payload.＼
</p>

<ul>
	<li>
`~client$は、［
`~server$が~HTTP11（以上の~version）の要請を取扱える
］ことを知っていない限り，［
`Transfer-Encoding$h を包含している要請
］を送信してはナラナイ
— そのような知識は、［
特定の利用者~環境設定
］や［
先に受信された応答の`~version$を記憶する
］形をとるであろう。
◎
A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.＼
</li>
	<li>
`~server$は、対応ng要請が［
~HTTP11（以上の~version）
］を指示していない限り，［
`Transfer-Encoding$h を包含している応答
］を送信してはナラナイ。
◎
A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later).
</li>
</ul>
</div>

<p>
`~server$は、［
自身が解さない`転送~符号法$を伴う要請~message
］を受信したときには， `501$st で応答するベキである。
◎
A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).
</p>

		</section>
		<section id="body.content-length">
<h3 title="Content-Length">6.2. `Content-Length^h</h3>

<div class="p">
<p>
~messageに `Transfer-Encoding$h ~headerが無いときは、
`Content-Length$h ~headerにより，［
`~payload本体$に見越される，~octet数による~size
］を，~decimal~~表現で供せる。
`Content-Length$h `~header値$は、~messageが~payload本体を内包するかどうかに応じて：
◎
When a message does not have a Transfer-Encoding header field, a Content-Length header field can provide the anticipated size, as a decimal number of octets, for a potential payload body.＼
</p>

<ul>
	<li>
内包する場合、［
本体（および~message）がどこで終端するかを決定するために必要とされる，~frame法~情報
］を供する。
◎
For messages that do include a payload body, the Content-Length field-value provides the framing information necessary for determining where the body (and message) ends.＼
</li>
	<li>
内包しない場合、`選定された表現$の~sizeを指示する。
◎
For messages that do not include a payload body, the Content-Length indicates the size of the selected representation (Section 6.2.4 of [Semantics]).
</li>
</ul>
</div>

<p class="note">注記：
~HTTPにおける［
~message~frame法のための `Content-Length$h の利用
］は、［
~MIMEにおける同じ~headerの利用
］から有意に相違する
— そこでの `Content-Length^h は、~MIME型 "`message/external-body^c" の中でのみ利用される，~header（省略可）である。
◎
Note: HTTP's use of Content-Length for message framing differs significantly from the same field's use in MIME, where it is an optional field used only within the "message/external-body" media-type.
</p>

		</section>
		<section id="message.body.length">
<h3 title="Message Body Length">6.3. ~message本体の長さ</h3>

<p>
`~message本体$の長さ（以下，
`本体~長さ@
）は、［
以下に挙げる項目のうち，その~messageが該当する~~最初の項目
］に対応する記述に従って決定される：
◎
The length of a message body is determined by one of the following (in order of precedence):
</p>

<dl class="switch">
	<dt>
`HEAD$m 要請に対する応答である
◎
Any response to a HEAD request and＼
</dt>
	<dt>
`1xx$st／ `204$st／ `304$st 応答である
◎
any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code＼
</dt>
	<dd>
~message内にどのような~headerが在るかに関わらず，常に［
一連の~headerの後の最初の`空~行l$
］で終了される。
従って，~message本体を包含し得ない。
◎
is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body.
</dd>

	<dt>
`CONNECT$m 要請に対する， `2xx$st 応答である
◎
Any 2xx (Successful) response to a CONNECT request＼
</dt>
	<dd>
これは，接続が、［
`~header節$を締めくくる`空~行l$の直後から，`~tunnel$になる
］ことを含意する。
`~client$は、そのような~message内に受信された どの［
`Content-Length$h ／ `Transfer-Encoding$h
］~headerも，無視しなければナラナイ。
◎
implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.
</dd>

	<dt>
`Transfer-Encoding$h ~headerが在る
◎
↓</dt>
	<dd>
		<dl class="switch">
			<dt>
`最終~転送~符号法$は`~chunked$である
◎
If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding,＼
</dt>
			<dd>
`本体~長さ$は、~chunked~dataを，［
その転送~符号法により，~dataの完了が指示される
］まで読取って復号することにより，決定される。
◎
the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.
</dd>

			<dt>
`最終~転送~符号法$は`~chunked$でない
◎
↓</dt>
			<dd>
				<dl class="switch">
					<dt>
応答である場合
◎
If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding,＼
</dt>
					<dd>
`本体~長さ$は、`~server$により~closeされるまで 接続を読取ることにより，決定される。
◎
the message body length is determined by reading the connection until it is closed by the server.＼
</dd>

					<dt>
要請である場合
◎
If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding,＼
</dt>
					<dd>
`本体~長さ$は、依拠-可能に決定し得ない
— `~server$は、状態s~code `400$st で応答した上で，接続を~closeしなければナラナイ。
◎
the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.
</dd>
				</dl>
			</dd>
		</dl>
<p>
受信した~messageが［
`Transfer-Encoding$h, `Content-Length$h
］の両~headerを伴う場合、
`Transfer-Encoding$h が `Content-Length$h を上書きする。
そのような~messageは［
`要請~密入$や`応答~分割$
］を遂行する試みを指示しているかもしれないので、［
~errorとして取扱われる~OUGHT
］。
`送信者$は，［
そのような~messageを`下流$へ回送する
］に先立って［
受信された `Content-Length$h ~header
］を除去しなければナラナイ。
◎
If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.
</p>
	</dd>

	<dt>
`~header値$が相違する，複数の `Content-Length$h ~headerを伴う
◎
If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or＼
</dt>
	<dt>
妥当でない値をとる `Content-Length$h ~headerを伴う
◎
a single Content-Length header field having an invalid value, then＼
</dt>
	<dd id="invalid-Content-Length-value">
<p>
~message~frame法は妥当でないので、`受信者$は，それを回復-不能な~errorとして扱った上で，次に従って動作しなければナラナイ：
◎
the message framing is invalid and the recipient MUST treat it as an unrecoverable error.＼
</p>
		<dl class="switch">
			<dt>
要請である場合
◎
If this is a request message,＼
</dt>
			<dd>
`~server$は、状態s~code `400$st で応答した上で，接続を~closeする。
◎
the server MUST respond with a 400 (Bad Request) status code and then close the connection.＼
</dd>

			<dt>
`~proxy$が受信した応答である場合
◎
If this is a response message received by a proxy,＼
</dt>
			<dd>
`~proxy$は、`~server$への接続を~closeし,
受信された応答を破棄した上で，`~client$に向けて［
`502$st 応答
］を送信する。
◎
the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client.＼
</dd>

			<dt>
~UAが受信した応答である場合
◎
If this is a response message received by a user agent,＼
</dt>
			<dd>
`~UA$は、`~server$への接続を~closeした上で，受信された応答を破棄する。
◎
the user agent MUST close the connection to the server and discard the received response.
</dd>
		</dl>
	</dd>

	<dt>
妥当な `Content-Length$h ~headerが在る
◎
</dt>
	<dd>
その~decimal値が、~octet数による，期待される`本体~長さ$を定義する。
［
送信者が接続を~closeした
］または［
受信者が，指示された~octet数が受信される前に時間制限を超えた
］場合、`受信者$は，~messageが`不完全$であると見なして接続を~closeしなければナラナイ。
◎
If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.
</dd>

	<dt>
要請である
◎
</dt>
	<dd>
`本体~長さ$は 0 である（~message本体は無い
【“長さ 0 の本体を内包する” と記されるべき？】
）。
◎
If this is a request message and none of the above are true, then the message body length is zero (no message body is present).
</dd>

	<dt>
他の場合
◎
Otherwise,＼
</dt>
	<dd>
すなわち，`本体~長さ$が宣言されていない応答~messageになるので、
`本体~長さ$は［
`~server$が接続を~closeするに先立って受信された~octet数
］により決定される。
◎
this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.
</dd>
</dl>

<p>
~messageが［
成功裡に完了し，~closeで区切られたもの
］なのか,［
~network失敗により中断され，部分的に受信されたもの
］なのかを判別する仕方はないので、`~server$は，アリな所では、自身が`生成する$~messageを［
符号化法または長さ
【 `Transfer-Encoding$h または `Content-Length$h 】
］で区切るベキである。
~closeで区切る特能は、首に［
~HTTP10との後方~互換性
］用に存在する。
◎
Since there is no way to distinguish a successfully completed, close-delimited message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.
</p>

<p>
`~server$は、［
`~message本体$は包含するが
`Content-Length$h は包含しない
］要請に対し，
`411$st で応答して却下してもヨイ。
◎
A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).
</p>

<p>
~chunked以外の`転送~符号法$が適用されていない限り，［
`~message本体$を包含している要請
］を送信する`~client$は、その`本体~長さ$が前もって既知であるときは，［
`~chunked転送~符号法$
］ではなく［
妥当な `Content-Length$h ~header
］を利用するベキである
— 一部の既存の~serviceは、`~chunked転送~符号法$を解するにも関わらず，~chunkedに対し状態s~code `411$st で応答するので。
これは概して、そのような~serviceが，［
呼び出される手前の所に， `Content-Length$h を要求する`~gateway$を介する
］ように実装されていて、~serverが，要請~全体を処理する前に~bufferできない／する用意がないためである。
◎
Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content-length in advance of being called and the server is unable or unwilling to buffer the entire request before processing.
</p>

<p>
［
`~message本体$を包含している要請
］を送信する`~UA$は、［
`~server$が`~HTTP11$（以上の~version）の要請を取扱える
］ことを知っていない場合には，［
妥当な `Content-Length$h ~header
］を送信しなければナラナイ
— そのような知識は、特定の利用者~環境設定や, ~~直前に受信された応答の`~version$を記憶する形をとるであろう。
◎
A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.
</p>

<div class="p">
<p>
［
接続~上の最後の要請に対する最終~応答が完全に†受信された
］かつ［
読取る追加的な~dataが残っている
］場合、`~UA$は，次のいずれかを~~行ってもヨイ：
◎
If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY＼
</p>

<p class="trans-note">【†
この “完全に” は、上で決定される`本体~長さ$（ `Content-Length^h に指示される長さなど）まで（本体を持たないとされている場合は，`~header節$全体まで），を意味すると見受けられる。
】</p>

<ul>
	<li>
残っている~dataを破棄する。
◎
discard the remaining data or＼
</li>
	<li>
その~dataが~~直前の応答~本体の一部である†かどうか，決定することを試みる。
◎
attempt to determine if that data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect.＼
</li>
</ul>

<p>†
これが~~起こるのは、［
~~直前の~messageの `Content-Length$h 値が不正である
］事例が該当し得る。
`~client$は、そのような余分な~dataを，別々の応答として［
処理-／~cache／回送-
］してはナラナイ
— そのような挙動は、~cache汚染に対し脆弱になるので。
◎
A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.
</p>
</div>

		</section>
	</section>
	<section id="transfer.codings">
<h2 title="Transfer Codings">7. 転送~符号法</h2>

<p>
`転送~符号法^dfn（ `transfer-coding$p ）は、［［
~networkを通した “安全な~transport”
］を確保するために，`~payload本体$に適用-［
された／
され得る／
させる必要が~~生じ得る
］ような，符号化法の形式変換
］を指示するために利用される。
転送~符号法は、~messageの~propertyである点で，［
転送されている`表現$の~propertyである，`内容~符号法$
］から相違する。
◎
Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a payload body in order to ensure "safe transport" through the network. This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.
</p>

<pre class="ABNF">
`transfer-coding@p
    = `token$p *( `OWS$p ";" `OWS$p `transfer-parameter$p )
</pre>

<p>
`transfer-parameter$p は、
<code>`name^V=`value^V</code>
~pairの形をとる：
◎
Parameters are in the form of a name=value pair.
</p>


<pre class="ABNF">
`transfer-parameter@p
    = `token$p `BWS$p "=" `BWS$p ( `token$p / `quoted-string$p )
</pre>

<p>
`transfer-coding$p を成す先頭の `token^p が
`転送~符号法の名前@
を与える。
`転送~符号法の名前$は、すべて文字大小無視である。
それらは、 `7.3$sec に定義されるように，`~HTTP転送~符号法~登記簿^citeに登録される~OUGHT。
それらは、［
`TE$h ／ `Transfer-Encoding$h
］~header内で利用される。
◎
All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 7.3. They are used in the TE (Section 7.4) and Transfer-Encoding (Section 6.1) header fields.
</p>

<div>
<table><thead><tr><td>名前
<td>説明d
</thead>

<tbody><tr><td>"`chunked$c"
<td>一連の~chunkによる転送

<tr><td>"`compress$c"
<td>UNIX "compress" ~data形式 `Welch$r

<tr><td>"`deflate$c"
<td>
"zlib" ~data形式 `RFC1950$r の内側の "deflate" 圧縮-済み~data `RFC1951$r

<tr><td>"`gzip$c"
<td>GZIP ~file形式 `RFC1952$r

<tr><td>"`trailers^c"
<td>（予約-済み）

<tr><td>"`x-compress^c"
<td>非推奨d（ "`compress$c" の別名）

<tr><td>"`x-gzip^c"
<td>非推奨d（ "`gzip$c" の別名）

</tbody></table>

◎
Table 2
Name 	Description 	Reference

chunked 	Transfer in a series of chunks 	Section 7.1
compress 	UNIX "compress" data format [Welch] 	Section 7.2
deflate 	"deflate" compressed data ([RFC1951]) inside the "zlib" data format ([RFC1950]) 	Section 7.2
gzip 	GZIP file format [RFC1952] 	Section 7.2
trailers 	(reserved) 	Section 7
x-compress 	Deprecated (alias for compress) 	Section 7.2
x-gzip 	Deprecated (alias for gzip) 	Section 7.2
</div>

<p class="note">注記：
符号法~名 "`trailers^c" は、予約-済みである
— その利用は `TE$h ~headerにおける~keyword "`trailers^c" と競合することになるので。
◎
Note: the coding name "trailers" is reserved because its use would conflict with the keyword "trailers" in the TE header field (Section 7.4).
</p>

		<section id="chunked.encoding">
<h3 title="Chunked Transfer Coding">7.1. ~chunked転送~符号法</h3>

<div class="p">
<p>
`~chunked転送~符号法^dfn
（ "`chunked^c" ）は、`~payload本体$を，次の並びとして転送するために包装する：
◎
The chunked transfer coding wraps the payload body in order to transfer it as＼
</p>
<ol>
	<li>
一連の~chunk
— 各~chunkは，自前の~size指示子（ `chunk-size$p ）を~serveする。
◎
a series of chunks, each with its own size indicator,＼
</li>
	<li>
`省略可能^2119な，`~trailer~header$たちを包含する`~trailer節$。
◎
followed by an OPTIONAL trailer section containing trailer fields.＼
</li>
</ol>

<p>
~chunkedは、［
未知~sizeの内容~stream
］を，［
長さで区切られる，一連の~buffer
］として転送できるようにする。
これにより、送信者が 接続の持続性を維持しつつ，受信者は いつ~message全体が受信されたかを知ることが~~可能になる。
◎
Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.
</p>

</div>

<pre class="ABNF">
`chunked-body@p
    = *`chunk$p `last-chunk$p `trailer-section$p `CRLF$P
`chunk@p
    = `chunk-size$p [ `chunk-ext$p ] `CRLF$P `chunk-data$p `CRLF$P
`chunk-size@p
    = 1*`HEXDIG$P
`last-chunk@p
    = 1*("0") [ `chunk-ext$p ] `CRLF$P
`chunk-data@p
    = 1*OCTET
    ; <span class="comment">~~長さ `chunk-size^p の~octet列
◎
a sequence of chunk-size octets
</span>
</pre>

<p>
`chunk-size$p ~fieldは、［
~octet数による `chunk-data$p の~size
］を指示する，［
何個かの~hex桁からなる文字列
］である。
~chunked転送~符号法が完了するのは、［
`chunk-size$p は 0 の~chunk
— 場合によっては`~trailer節$も後続する —
が受信され，最後に 空~行lにより終了された
］ときである。
◎
The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer section, and finally terminated by an empty line.
</p>

<p>
`受信者$は、［
~chunked転送~符号法
］を構文解析して復号できなければナラナイ。
◎
A recipient MUST be able to parse and decode the chunked transfer coding.
</p>

<p>
~chunked転送~符号法に定義される~parameterは無い。
~parameterが在っても、~errorに扱われるベキではない。
◎
The chunked encoding does not define any parameters. Their presence SHOULD be treated as an error.
</p>
			<section id="chunked.extension">
<h4 title="Chunk Extensions">7.1.1. ~chunk拡張</h4>

<p>
`~chunked$符号化により、各~chunkは，
`chunk-size$p の直後に 0 個~以上の
`~chunk拡張^dfn
（ `chunk-ext$p ）を内包させられるようになる
— その~~目的は、［
~chunkごとの~metadata（署名や~hashなど）,
~messageの中途を制御する情報,
~message本体~sizeの~random化
］を給することである。
◎
The chunked encoding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size.
</p>

<pre class="ABNF">
`chunk-ext@p
    = *( `BWS$p ";" `BWS$p `chunk-ext-name$p [ `BWS$p "=" `BWS$p `chunk-ext-val$p ] )
`chunk-ext-name@p
    = `token$p
`chunk-ext-val@p
    = `token$p / `quoted-string$p
</pre>

<p>
`~chunked$による符号化は，接続ごとに特有であり、［
より高~levelの応用が，それらの拡張を検分する機会を得る
］より前に，`受信者$たち（`中継者$も含む）により，除去されたり再符号される見込みが高い。
よって，`~chunk拡張$の利用は、一般に，特化された~HTTP~serviceに制限される
— 例えば：［
“`long polling^en” （~clientと~serverは，~chunk拡張の利用に関する期待を共有する）／
`端点間$の~secure化された接続の中での~padding
］用など。
◎
The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, use of chunk extensions is generally limited to specialized HTTP services such as "long polling" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.
</p>

<p>
`受信者$は、［
自身が認識しない`~chunk拡張$
］を無視しなければナラナイ。
`~server$は、［
要請~内に受信される~chunk拡張の総~長さ
］を［
供される~serviceに見合う量
］に制限する~OUGHT
— ［
~messageの他の各部に適用される，長さ制限や時間制限
］と同じ仕方で、かつ，その量を超過したときは［
適切な `4xx$st 応答
］を`生成する$ことにより。
◎
A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.
</p>

			</section>
			<section id="chunked.trailer.section">
<h4 title="Chunked Trailer Section">7.1.2. ~chunked~trailer節</h4>

<p>
`送信者$は、~chunk化された~messageの末尾に
`~trailer節^dfn
（ `trailer-section$p ）と呼ばれる~dataを内包させられる。
それは、`~message本体$が送信される間に，動的に`生成し$得る~metadata
— ~message完全性~検査, ~digital署名, 後処理~状態sなど —
を給するためにあり、
`~trailer~header@
と呼ばれる，何個かの追加的な~headerからなる。
~trailer~headerの適正な利用と制限は、
`Semantics/4.3$sec
に定義される。
◎
A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 4.3 of [Semantics].
</p>

<pre class="ABNF">
`trailer-section@p
    = *( `header-field$p `CRLF$P )
</pre>

<div class="p">
<p>
~messageからの~chunked符号化法を（例：蓄積~用に／~HTTP11でない~peerへ回送するために）復号して除去する受信者は、受信した各~trailer~header `T^V に対し，次のいずれかをしなければナラナイ：
◎
A recipient that decodes and removes the chunked encoding from a message (e.g., for storage or forwarding to a non-HTTP/1.1 peer) MUST＼
</p>

<ul>
	<li>
`T^V を破棄する
◎
discard any received trailer fields,＼
</li>
	<li>
`~header節$とは別々に，
`T^V を［
格納する／回送する
］
◎
store/forward them separately from the header fields, or＼
</li>
	<li>
`~header節$の中に，選択的に `T^V を併合する
— ただし、受信者が次を解する場合に限る
⇒
`T^V に対応ng~headerの定義において，
`T^V の値を安全に併合する方法が定義されていて、そうすることが明示的に許可されている
◎
selectively merge into the header section only those trailer fields corresponding to header field definitions that are understood by the recipient to explicitly permit and define how their corresponding trailer field value can be safely merged.
</li>
</ul>
</div>

			</section>
			<section id="decoding.chunked">
<h4 title="Decoding Chunked">7.1.3. ~chunkedの復号-法</h4>

<p>
`~chunked転送~符号法$を復号する処理nは、次の疑似~codeで表現できる：
◎
A process for decoding the chunked transfer coding can be represented in pseudo-code as:
</p>

<div class="p">

<ol>
	<li>
`長さ^V ~LET 0
</li>
	<li>
`本体^V ~LET 空
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
［
`chunk-size$p, `chunk-ext$p （もしあれば）, `CRLF$P
］を読取る
</li>
			<li>
~IF［
`chunk-size$p ~EQ 0 ）
］
⇒
~BREAK
</li>
			<li>
［
`chunk-data$p, `CRLF$P
］を読取る
</li>
			<li>
`本体^V に `chunk-data$p を付加する
</li>
			<li>
`長さ^V ~SET `長さ^V + `chunk-size$p
</li>
		</ol>
	</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
`f^V ~LET 次の`~trailer~header$を読取った結果
</li>
			<li>
~IF［
`f^V は空である
］
⇒
~BREAK
</li>
			<li>
~IF［
`f^V は別々に［
格納する／回送する
］ことが許容されている
］
⇒
既存の`~trailer節$に `f^V を付加する
</li>
			<li>
~ELIF［
受信者は `f^V を解する，かつ `f^V は併合-可能であるものと定義されている
］
⇒
既存の~headerたちに `f^V を併合する
</li>
			<li>
~ELSE
⇒
`f^V を破棄する
</li>
		</ol>

<p class="trans-note">【
この段の~logicは、前節に述べた要件と違って，裁量の余地が無いかのように記されている。
（“疑似~code” なので、規範的ではない？）
】</p>

	</li>
	<li>
`Content-Length$h の`~header値$ ~SET `長さ^V
</li>
	<li>
`Transfer-Encoding$h から "`chunked$c" を除去する
</li>
	<li>
既存の`~header節$から `Trailer$h を除去する
</li>
	<li>
~RET `本体^V
</li>
</ol>

<pre lang="en">
length := 0
read chunk-size, chunk-ext (if any), and CRLF
while (chunk-size &gt; 0) {
   read chunk-data and CRLF
   append chunk-data to decoded-body
   length := length + chunk-size
   read chunk-size, chunk-ext (if any), and CRLF
}
read trailer field
while (trailer field is not empty) {
   if (trailer fields are stored/forwarded separately) {
       append trailer field to existing trailer fields
   }
   else if (trailer field is understood and defined as mergeable) {
       merge trailer field with existing header fields
   }
   else {
       discard trailer field
   }
   read trailer field
}
Content-Length := length
Remove "chunked" from Transfer-Encoding
Remove Trailer from existing header fields
</pre>
</div>

			</section>
		</section>
		<section id="compression.codings">
<h3 title="Transfer Codings for Compression">7.2. 圧縮~用の転送~符号法</h3>

<p>
次に挙げる圧縮~用の`転送~符号法の名前$は、対応する`内容~符号法の名前$と同じ~algoにより定義される
⇒＃
`compress$c （および `x-compress^c ）,
`deflate$c,
`gzip$c （および `x-gzip^c ）
◎
The following transfer coding names for compression are defined by the same algorithm as their corresponding content coding:
◎
compress (and x-compress)
• See Section 6.1.2.1 of [Semantics].
deflate
• See Section 6.1.2.2 of [Semantics].
gzip (and x-gzip)
• See Section 6.1.2.3 of [Semantics].
</p>

<p>
これらの圧縮~符号法に定義される~parameterは無い。
~parameterが在っても、~errorに扱われるベキではない。
◎
The compression codings do not define any parameters. Their presence SHOULD be treated as an error.
</p>

		</section>
		<section id="transfer.coding.registry">
<h3 title="Transfer Coding Registry">7.3. 転送~符号法~登記簿</h3>

<p>
`転送~符号法の名前$用の名前空間は、
`転送~符号法~登記簿$cite
にて保守され，定義される。
◎
The "HTTP Transfer Coding Registry" defines the namespace for transfer coding names. It is maintained at &lt;https://www.iana.org/assignments/http-parameters&gt;.
</p>

<p>
登録にあたっては、次に挙げる~fieldを内包しなければナラナイ
⇒＃
名前,
説明d,
仕様~textへの~pointer
◎
Registrations MUST include the following fields:
• Name
• Description
• Pointer to specification text
</p>

<p>
各 `転送~符号法の名前$は、`内容~符号法の名前$ `Semantics$r と重合してはナラナイ
— 符号化法の形式変換（`内容~符号法$secに定義される各種 圧縮~符号法など）が一致している場合を除き。
◎
Names of transfer codings MUST NOT overlap with names of content codings (Section 6.1.2 of [Semantics]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.
</p>

<p>
`TE$h ~headerは、複数の転送~符号法が受容-可能なときに，
`rank$p 値として名前 "`q^c" の疑似~parameterを利用する。
多義性を避けるため、将来における転送~符号法の登録は、
"`q^c" （文字大小無視）と呼ばれる~parameterを定義するベキでない。
◎
The TE header field (Section 7.4) uses a pseudo parameter named "q" as rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called "q" (case-insensitively) in order to avoid ambiguities.
</p>

<p>
この名前空間に追加される値は、
`IETF による考査$を要し，［
この仕様にて定義される`転送~符号法$の目的
］に適合しなければナラナイ。
◎
Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]), and MUST conform to the purpose of transfer coding defined in this specification.
</p>

<p>
~program名は，符号化~形式の識別子として欲されないので、将来の符号化法には用いないことが奨励される。
◎
Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
</p>

		</section>
		<section id="header.te">
<h3 title="TE">7.4. `TE^h</h3>

<div class="p">
<p>
要請~内の `TE^h ~headerは、次の 2 つを指示する：
◎
The "TE" header field in a request indicates＼
</p>

<ul>
	<li>
`~client$が、`~chunked$の他に，応答にて受容する用意がある`転送~符号法$。
◎
what transfer codings, besides chunked, the client is willing to accept in response, and＼
</li>
	<li>
`~client$は、`~chunked転送~符号法$にて`~trailer~header$を受容する用意があるかどうか。
◎
whether or not the client is willing to accept trailer fields in a chunked transfer coding.
</li>
</ul>
</div>

<p>
`TE^h `~header値$は，［
何個かの`転送~符号法の名前$からなる，~comma区切りの~list
］であり、そのそれぞれには，［
0 個以上の~parameter（ `transfer-parameter$p ）,
0 〜 1 個の~keyword "`trailers$c"
］も許容される。
`~client$は、`TE^h 内に，`転送~符号法の名前$として "`chunked$c" を送信してはナラナイ
— `~HTTP11$`受信者$に対しては、`~chunked$は常に受容-可能なので。
◎
The TE field-value consists of a comma-separated list of transfer coding names, each allowing for optional parameters (as described in Section 7), and/or the keyword "trailers". A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.
</p>

<pre class="ABNF">
`TE@p
    = #`t-codings$p
`t-codings@p
    = "`trailers$c"
    / ( `transfer-coding$p [ `t-ranking$p ] )
`t-ranking@p
    = `OWS$p ";" `OWS$p "q=" `rank$p
`rank@p
    = ( "0" [ "." 0*3`DIGIT$P ] )
    / ( "1" [ "." 0*3("0") ] )
</pre>

<div class="example">

<p>
`TE^h の利用を示す 3 つの例：
◎
Three examples of TE use are below.
</p>

<pre class="http-code">
TE: deflate
TE:
TE: trailers, deflate;q=0.5
</pre>

</div>

<div class="p">

<p>
~keyword
"`trailers@c"
が在る場合、［
`7.1.2$sec にて定義されるように，`~client$が
— 自身および`下流$の~clientたちに利するため —
`~chunked転送~符号法$内に`~trailer~header$を受容する用意がある
］ことを指示する。
`中継者$からの要請については、これは，次のいずれか【または両方？】を含意する：
◎
The presence of the keyword "trailers" indicates that the client is willing to accept trailer fields in a chunked transfer coding, as defined in Section 7.1.2, on behalf of itself and any downstream clients. For requests from an intermediary, this implies that either:＼
</p>

<ul>
	<li>
`下流$のすべての~clientは、回送された応答~内の`~trailer~header$を受容する用意がある。
◎
(a) all downstream clients are willing to accept trailer fields in the forwarded response; or,＼
</li>
	<li>
`中継者$は、`下流$の受信者たちに利するため，応答を~bufferしようと試みることになる。
◎
(b) the intermediary will attempt to buffer the response on behalf of downstream recipients.＼
</li>
</ul>

<p>
`~HTTP11$は、［
~chunked応答の~sizeを，［
`中継者$が応答~全体を~bufferできることが確約される
］ように制限する
］ような，いかなる手段も定義しないことに注意。
◎
Note that HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response.
</p>
</div>

<div class="p">

<p>
複数の`転送~符号法$が受容-可能なとき、`~client$は，［
文字大小無視 "`q=^c" ~parameter（ `rank$p ）
］を利用して，それらの符号法の選好を順位~付けてもヨイ。
順位~値は、範囲 0 〜 1 の実数を表し，値が大きいほど選好される（`内容~折衝$~headerにて利用される`品質値$（ “`qvalue^en” ）に類似する）：
◎
When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive "q" parameter (similar to the qvalues used in content negotiation fields, Section 8.4.1 of [Semantics]). The rank value is a real number in the range 0 through 1, where＼
</p>

<ul>
	<li>
`0.001^c は，最も選好されないことを表す。【小数部は 3 桁までなので】
◎
0.001 is the least preferred and＼
</li>
	<li>
`1^c は，最も選好されることを表す。
◎
1 is the most preferred;＼
</li>
	<li>
`0^c は， “受容-可能でない” ことを意味する。
◎
a value of 0 means "not acceptable".
</li>
</ul>
</div>

<p>
［
`TE^h の`~header値$が空または，
`TE^h ~headerが無い
］場合に受容-可能な`転送~符号法$は、 "`chunked$c" に限られる。
転送~符号法を伴わない~messageは、常に受容-可能である。
◎
If the TE field-value is empty or if no TE field is present, the only acceptable transfer coding is chunked. A message with no transfer coding is always acceptable.
</p>

<p>
`TE^h ~headerは，~~直の接続に限り適用されるので、
`TE^h の`送信者$は
— ［
`TE^h の意味論を~supportしない`中継者$による `TE^h ~headerの回送
］を防ぐため —
`Connection$h ~headerの中に "`TE^c" `接続~option$も送信しなければナラナイ。
◎
Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a "TE" connection option within the Connection header field (Section 9.1) in order to prevent the TE field from being forwarded by intermediaries that do not support its semantics.
</p>

		</section>
	</section>
	<section id="incomplete.messages">
<h2 title="Handling Incomplete Messages">8. 不完全な~messageの取扱い</h2>

<p>
`不完全$な要請~messageを受信した`~server$は、接続を~closeするに先立って，~error応答を送信してもヨイ。
そのような要請は、通例的に［
要請が取消されたり，時間制限による例外が誘発された
］ことに因る。
◎
A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.
</p>

<p>
`不完全$な応答~messageを受信した`~client$は、その~messageを不完全なものと記録しなければナラナイ。
そのような応答は、接続が尚早に~closeされたときや,
`~chunked転送~符号法$と思しきものの復号に失敗したときに，生じ得る。
不完全な応答~用の`~cache$に対する要件は、
`Caching/3$sec
にて定義される。
◎
A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3 of [Caching].
</p>

<p>
応答が［
`~header節$の中途で（すなわち，`空~行l$が受信される前に）終了した
］かつ［
その`状態s~code$は、応答の全部的な意味を，~headerに依拠して伝達する可能性がある
］場合、`~client$は，その意味が伝達されたものと見做せないので、次にとる動作を決定するために，要請を繰返す必要が~~生じ得る。
◎
If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.
</p>

<div class="p">
<p>
次のとき、~messageは
`不完全@
とされる：
</p>

<ul>
	<li>
`~message本体$の`転送~符号法$に`~chunked$が利用されていて，符号化を終了させる［
~size 0 の~chunk
］が受信されなかったとき。
</li>
	<li>
`Content-Length$h が利用されていて，その値より［
受信された~message本体の（~octet数による）~size
］が小さいとき。
</li>
</ul>
◎
A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received. A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length.＼
</div>

<p>
`~chunked転送~符号法$も `Content-Length$h も持たない応答は，［
接続の~closure
］により終了されるので、［
`~header節$は全て受信された
］限りにおいて，［
受信された~message本体の~octet数
］に関わらず 完全と見なされる。
◎
A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, thus, is considered complete regardless of the number of message body octets received, provided that the header section was received intact.
</p>

	</section>
	<section id="connection.management">
<h2 title="Connection Management">9. 接続の管理</h2>

<p>
~HTTP~message法は、［
下層の［
~transport／~session
］層における接続~protocolたち
］に依存しない。
~HTTPは、［［
各~要請の順序~通りの送達と，それらに対応する各~応答の順序~通りの送達
］が依拠-可能に~transportされる
］ことのみを~~前提にする。
~HTTP［
要請／応答
］の構造から［
下層~transport~protocolの~data単位
］上への対応付けは、この仕様の対象外である。
◎
HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s). HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses. The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.
</p>

<p>
`Semantics/5.2$sec にて述べられるように，~HTTPのヤリトリに利用される［
特定の接続~protocol
］は、［
`~client$の環境設定, および`~target~URI$
］により決定される。
例えば， "`http$c" ~URI~schemeは、［［
既定の~TCP~port 80
］を伴う［
~TCP over ~IPの既定の接続
］］を指示するが、~clientは，［
何らかの他の［
接続 ／ ~port ／ ~protocol
］を介した~proxy
］を利用するようにも環境設定され得る。
◎
As described in Section 5.2 of [Semantics], the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI. For example, the "http" URI scheme (Section 2.5.1 of [Semantics]) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.
</p>

<div class="p">
<p>
~HTTP実装には、接続の管理に参加することが期待されている
— それには，次が含まれる：
◎
HTTP implementations are expected to engage in connection management, which includes＼
</p>

<ul>
	<li>
現在の接続の状態を保守する。
◎
maintaining the state of current connections,＼
</li>
	<li>
新たな接続を確立したり, 既存の接続を再利用する。
◎
establishing a new connection or reusing an existing connection,＼
</li>
	<li>
接続~上にて受信された~messageを処理する。
◎
processing messages received on a connection,＼
</li>
	<li>
接続の失敗を検出する。
◎
detecting connection failures, and＼
</li>
	<li>
各~接続を~closeする。
◎
closing each connection.＼
</li>
</ul>

<p>
ほとんどの`~client$は、複数の接続
— 同じ~server`端点$に対する複数個の接続も含む —
を，並列的に保守する。
ほとんどの`~server$は、［
公正な利用は可能化しつつ，~DoS攻撃を検出する
］ために，［
要請の~queueを制御しながら, 幾千もの同時的~接続を保守する
］ように設計されている。
◎
Most clients maintain multiple connections in parallel, including more than one connection per server endpoint. Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.
</p>
</div>

		<section id="header.connection">
<h3 title="Connection">9.1. `Connection^h</h3>

<p>
`Connection$h ~headerにより、`送信者$は，［
現在の接続に欲される制御~option
］を指示できるようになる。
［
`~proxy$／`~gateway$
］は、受信された どの接続~optionも
— `下流$の`受信者$たちが混同しないよう —
~messageを回送する前に【以下に述べるように】除去するか置換しなければナラナイ。
◎
The "Connection" header field allows the sender to indicate desired control options for the current connection. In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message.
</p>

<div class="p">

<p>
`送信者$は、［
現在の接続~用の／についての制御~情報を給する
］ために［
`Connection$h 以外の~header
］を利用するときには，［
対応ng `field-name$p
］を `Connection$h ~headerの中に~listしなければナラナイ。
◎
When a header field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field-name within the Connection header field.＼
</p>

<p>
［
`~proxy$／`~gateway$
］は、受信した~message `M^V を回送する前に，次を行わなければナラナイ：
◎
A proxy or gateway MUST＼
</p>

<ol>
	<li>
`M^V 内の `Connection$h ~header値を，構文解析する。
◎
parse a received Connection header field before a message is forwarded and,＼
</li>
	<li>
この~header内の各 `connection-option$p に対し， `M^V から［
`connection-option$p と同じ名前を伴う，すべての~header
］を除去する。
◎
for each connection-option in this field, remove any header field(s) from the message with the same name as the connection-option, and then＼
</li>
	<li>
［
`M^V から `Connection$h ~headerを除去する
］か, あるいは［
`M^V 内の `Connection$h の値を 自前の接続~optionで置換する
］。
◎
remove the Connection header field itself (or replace it with the intermediary's own connection options for the forwarded message).
</li>
</ol>

</div>

<p>
すなわち， `Connection$h ~headerは、［
~~直の`受信者$のみに意図された
`隣点間~header@
］と,［
`連鎖$上にある すべての`受信者$に意図された
`端点間~header@
］を判別できるようにする，宣言的な仕方を供する
— それは、~messageを自己記述的にすることで，［
古い`中継者$により盲目的に回送されるおそれ
］なく，［
接続ごとに特有な，将来の拡張
］を配備できるようにする。
◎
Hence, the Connection header field provides a declarative way of distinguishing header fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.
</p>

<p>
`Connection$h ~header値の文法は、次で与えられる：
◎
The Connection header field's value has the following grammar:
</p>

<pre class="ABNF">
`Connection@p
    = 1#`connection-option$p
`connection-option@p
    = `token$p
</pre>

<p>
`connection-option$p が各
`接続~option@
を与える。
それは、文字大小無視である。
◎
Connection options are case-insensitive.
</p>

<p>
`送信者$は、［
`~payload$を受け取るすべての`受信者$向けに意図された~header
］に対応するような`接続~option$を，送信してはナラナイ。
例えば， `Cache-Control$h は、接続~optionとしては，決して適切にならない。
◎
A sender MUST NOT send a connection option corresponding to a header field that is intended for all recipients of the payload. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [Caching]).
</p>

<p>
`接続~option$は，常に［
~message内に在る~header
］に対応するとは限らない
— 結付けられる~parameterがない接続~optionに対しては、［
接続ごとに特有な~header
］は不要になり得るので。
対照的に，［
対応する接続~optionを伴わずに受信された，
接続ごとに特有な~header
］は、通例的に［
~headerが`中継者$により不適正に回送された
］ことを指示するので，`受信者$は無視する~OUGHT。
◎
The connection options do not always correspond to a header field present in the message, since a connection-specific header field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific header field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.
</p>

<p>
仕様~策定者が，新たな`接続~option$を定義するときは、既存の`~header名$を調べて，［
新たな接続~optionが，すでに配備されている~headerと同じ名前を共有しない
］ことを確保する~OUGHT。
新たな接続~optionを定義することは、本質的に，その`~header名$を［
接続~optionに関係する追加的な情報
］を運ぶ用途に予約することに等しく、送信者にとっては，その`~header名$を他の何かに利用するのは無分別になるので。
◎
When defining new connection options, specification authors ought to survey existing header field names and ensure that the new connection option does not share the same name as an already deployed header field. Defining a new connection option essentially reserves that potential field-name for carrying additional information related to the connection option, since it would be unwise for senders to use that field-name for anything else.
</p>

<p>
`~close_接続~option@
は、`送信者$が，［
この接続が，応答の完了の後に~closeされる
］ことを他へ通達するためのものとして，定義される。
例えば：
◎
The "close" connection option is defined for a sender to signal that this connection will be closed after completion of the response. For example,
</p>

<div class="example">

<pre class="http-code">
Connection: close
</pre>

</div>

<p>
要請, 応答のいずれにおいても、この~headerは，［
`送信者$が，現在の［
要請／応答
］が完了した（ `9.7$sec ）後に，接続を~closeしようとしている
］ことを指示する。
◎
in either the request or the response header fields indicates that the sender is going to close the connection after the current request/response is complete (Section 9.7).
</p>

<p>
［
`持続的~接続$を~supportしない`~client$
］は、毎~要請~messageごとに，`~close_接続~option$を送信しなければナラナイ。
◎
A client that does not support persistent connections MUST send the "close" connection option in every request message.
</p>

<p>
［
`持続的~接続$を~supportしない`~server$
］は、［
状態s~codeが `1xx$st でない
］ような毎~応答~messageごとに，`~close_接続~option$を送信しなければナラナイ。
◎
A server that does not support persistent connections MUST send the "close" connection option in every response message that does not have a 1xx (Informational) status code.
</p>

		</section>
		<section id="persistent.establishment">
<h3 title="Establishment">9.2. 確立法</h3>

<p>
接続が，様々な［
~transport／~session
］層の~protocolを介して確立される方法について述べることは、この仕様の視野を超える。
各~接続は、 1 個の~transport~linkのみに適用される。
◎
It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols. Each connection applies to only one transport link.
</p>

		</section>
		<section id="associating.response.to.request">
<h3 title="Associating a Response to a Request">9.3. 応答から要請への結付け</h3>

<p>
~HTTP11には、［
所与の要請~message
］を［
1 個~以上の，対応ng応答~message
］に結付けるような要請~識別子は，ない。
よって，その結付けは［
同じ接続~上で要請が為された順序が，応答が到着した順序に正確に対応する
］ことに依拠する。
1 個の要請に対し複数個の応答~messageが生じるのは、［
同じ要請に対する最終~応答に， 1 個~以上の `1xx$st 応答が先行する
］ときに限られる。
◎
HTTP/1.1 does not include a request identifier for associating a given request message with its corresponding one or more response messages. Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection. More than one response message per request only occurs when one or more informational responses (1xx, see Section 9.2 of [Semantics]) precede a final response to the same request.
</p>

<p>
`~client$は、接続~上に，
`応答待ち要請@
— まだ最終（非 `1xx$st ）応答が受信されていない要請 —
が複数個あるときには、次に従わなければナラナイ
⇒
それらの要請からなる，送信した順序による~listを保守した上で、その接続~上で応答~messageが受信されたときには、~listから~~先頭の要請を抜き取って，受信した応答に結付ける。
◎
A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response.
</p>

<p>
~HTTP11~clientは、`応答待ち要請$が無い接続~上で受信された~dataを，まだ~~発行してない要請に対する応答と見なしてはナラナイ。
そのような接続は~closeするベキである
— ~messageの区切りは、今や多義的なので（当の~dataが，`~message構文解析$secにより破棄できる何個かの `CRLF$P のみからなる場合は別として）。
◎
If an HTTP/1.1 client receives data on a connection that doesn't have any outstanding requests, it MUST NOT consider them to be a response to a not-yet-issued request; it SHOULD close the connection, since message delimitation is now ambiguous, unless the data consists only of one or more CRLF (which can be discarded, as per Section 2.2).
</p>


		</section>
		<section id="persistent.connections">
<h3 title="Persistence">9.4. 持続性</h3>

<p>
`~HTTP11$では、
`持続的~接続^dfn
は，既定で利用できる
— これは、単独の接続~越しに，複数の［
要請や応答
］を運べるようにする。
`~close_接続~option$は、［
接続が現在の［
要請／応答
］の後に持続しない
］ことを通達するために利用される。
~HTTP実装は、`持続的~接続$を~supportするベキである。
◎
HTTP/1.1 defaults to the use of "persistent connections", allowing multiple requests and responses to be carried over a single connection. The "close" connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections.
</p>

<p>
`受信者$は、［
最も近過去に受信された~message
］の［
`~protocol~version$と `Connection$h ~header（もし在れば)
【！ (or not) based on／or (not based on) 】
］に基づいて，［
接続が現在の応答の後にも持続することになるかどうか
］を決定する：
◎
A recipient determines whether a connection is persistent or not based on the most recently received message's protocol version and Connection header field (if any):
</p>

<ol>
	<li>
`~close_接続~option$が在るならば、持続しない。
◎
If the "close" connection option is present, the connection will not persist after the current response; else,
</li>
	<li>
他の場合，［
受信された~protocolが`~HTTP11$（以上の~version）である
］ならば、持続する。
◎
If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,
</li>
	<li>
<p>
他の場合，次がすべて満たされるならば、持続する：
</p>
		<ul>
			<li>
受信された~protocolは~HTTP10である。
</li>
			<li>
"`keep-alive$c" `接続~option$が在る。
</li>
			<li>
受信者は~proxyでない, または~messageは応答である。
</li>
			<li>
受信者は［
~HTTP10 による "`keep-alive$c" の仕組み
］を尊守するよう望んでいる。
</li>
		</ul>
◎
If the received protocol is HTTP/1.0, the "keep-alive" connection option is present, either the recipient is not a proxy or the message is a response, and the recipient wishes to honor the HTTP/1.0 "keep-alive" mechanism, the connection will persist after the current response; otherwise,
</li>
	<li>
他の場合，持続しない。
◎
The connection will close after the current response.
</li>
</ol>

<p>
`~client$は、自身が，［
`~close_接続~option$を送信する, または受信する
］または［
`keep-alive$c" `接続~option$を伴わない~HTTP10応答を受信する
］まで、`持続的~接続$上に，追加的な要請を送信してもヨイ。
◎
A client MAY send additional requests on a persistent connection until it sends or receives a "close" connection option or receives an HTTP/1.0 response without a "keep-alive" connection option.
</p>

<p>
持続的であり続けるためには、接続~上の どの~messageも
— §`~message本体$に述べたように —
その長さが~message自身により定義される必要がある（すなわち，長さは接続の~closureにより定義されるものではない）。
`~server$は、［
要請`~message本体$全体を読取る
］または［
自身が応答を送信した後に接続を~closeする
］のいずれかをしなければナラナイ
— さもなければ［
`持続的~接続$上に残っている~data
］が，その次の要請として誤解釈されることになる。
同様に，`~client$は、［
後続の要請に同じ接続を再利用する
］ことを意図するならば，［
応答~message本体~全体
］を読取らなければナラナイ。
◎
In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 6. A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.
</p>

<p>
`~proxy$~serverは、~HTTP10`~client$と伴に `持続的~接続$を保守してはナラナイ（多くの~HTTP10~clientにより実装されている `Keep-Alive$h ~headerに伴われる問題の情報, 論点については、 `RFC2068/19.7.1$secを見よ）。
◎
A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).
</p>

<p>
~HTTP10~clientに対する後方~互換性についての更なる情報は、
`Keep-Alive$h を見よ。
◎
See Appendix C.1.2 for more information on backwards compatibility with HTTP/1.0 clients.
</p>

			<section id="persistent.retrying.requests">
<h4 title="Retrying Requests">9.4.1. 要請の再試行-法</h4>

<p>
意図nの有無に関わらず，接続はいつでも~closeできる。
実装は、［
非同期的な~close~eventから回復する必要があるかどうか
］を見越しておく~OUGHT。
どの条件の下で，`~client$が一連の`応答待ち要請$を自動的に再試行できるかは、
`Semantics/7.2.2$sec
に定義される。
◎
Connections can be closed at any time, with or without intention. Implementations ought to anticipate the need to recover from asynchronous close events. The conditions under which a client can automatically retry a sequence of outstanding requests are defined in Section 7.2.2 of [Semantics].
</p>

			</section>
			<section id="pipelining">
<h4 title="Pipelining">9.4.2. ~pipeline法</h4>

<p>
［
`持続的~接続$を~supportする`~client$
］は、自身の要請を，~pipeline化してもヨイ（すなわち，各~応答を待機せずに，複数の要請を送信する）。
`~server$は、［
~pipeline化された一連の要請
］を［
それらすべてが`安全$な~methodを持つ
］ならば，並列的に処理してもヨイ
— その際には、要請が受信された順序と同じ順序で，対応ng応答を送信しなければナラナイ。
◎
A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 7.2.1 of [Semantics]), but it MUST send the corresponding responses in the same order that the requests were received.
</p>

<p>
要請を~pipeline化する`~client$は、［
対応ng応答のすべてを受信する前に 接続が~closeされた
］場合は，未~回答の要請を再試行するベキである。
接続が失敗した（接続が，~serverによる最後の完全な応答により明示的に~closeされていない）後に［
要請の~pipeline化を再試行する
］ときは、`~client$は，［
接続が確立された直後
］に~pipeline化してはナラナイ
— ［
先の~pipelineに残っている要請のうち，~~最初のもの
］が、~error応答をもたらした可能性があり，［
複数の要請が［
尚早に~closeされた接続
］上に送信される
］場合に再び失われ得るので（ `9.7$sec にて述べる~TCP~reset問題を見よ）。
◎
A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 9.7).
</p>

<p>
`冪等$な~methodは、~pipelineにとって有意である
— それらは，接続~失敗の後に自動的に再試行できるので。
`~UA$は、冪等でない~methodの後に，［
その~methodに対する最終 `応答~状態s~code$
］が受信されるまでは，要請を~pipeline化するベキでない
— ただし，`~UA$が［
~pipeline化された一連の要請を孕んでいる
部分的~失敗~条態
］を［
検出し, それを回復する手段を持っている
］場合は除く。
◎
Idempotent methods (Section 7.2.2 of [Semantics]) are significant to pipelining because they can be automatically retried after a connection failure. A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.
</p>

<div class="p">

<p>
~pipeline化された要請たちを受信した`中継者$は、それらを`内方$へ回送するときには，~pipeline化してもヨイ
— 要請を安全に~pipeline化できるかどうかは，`外方$にある~UAたちに依拠して決定できるので。
~pipeline化している`中継者$は、ある応答を受信する前に，`内方$への接続が失敗した場合には：
◎
An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined. If the inbound connection fails before receiving a response, the pipelining intermediary＼
</p>

<ul>
	<li>
すべての要請の~methodが`冪等$ならば、［
要請たちのうち，対応ng応答がまだ受信されていないもの
］の再試行-を試みてもヨイ。
◎
MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods;＼
</li>
	<li>
他の場合、受信された応答はすべて回送してから，対応ng`外方$への接続（たち）を~closeするベキである
— `外方$にある~UAたちが，それに則って回復できるようにするため。
◎
otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.
</li>
</ul>

</div>

			</section>
		</section>
		<section id="persistent.concurrency">
<h3 title="Concurrency">9.5. 同時並行性</h3>

<p>
`~client$は、所与の`~server$に対し保守する［
同時~open接続~数
］を制限する~OUGHT。
◎
A client ought to limit the number of simultaneous open connections that it maintains to a given server.
</p>

<p>
~HTTPの以前の改訂では、接続~数に特定の~~上限を設けていたが、これは，多くの応用にとり実用的でないことが判っている。
そのため，この仕様は、特定0の最大~接続~数を義務付けない
— 代わりに、~clientが複数の接続を~openするにあたっては，保守的になることを奨励する。
◎
Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.
</p>

<p>
複数~接続は、概して， “`head-of-line blocking^en” 問題
— ［
`~server$側に重い処理を要したり, 巨大な`~payload$を持つ
］ような要請が、同じ接続~上の後続の要請を阻むこと —
を避けるために利用される。
しかしながら、接続のそれぞれが~server資源を消費する。
更には、複数の接続が利用された場合，混雑した~networkに，望ましくない副作用をもたらし得る。
◎
Multiple connections are typically used to avoid the "head-of-line blocking" problem, wherein a request that takes significant server-side processing and/or has a large payload blocks subsequent requests on the same connection. However, each connection consumes server resources. Furthermore, using multiple connections can cause undesirable side effects in congested networks.
</p>

<p>
`~server$は、単独の~clientからの過度の~open接続~数など，［
濫用的あるいは, ~DoS攻撃の特性を有している
］と判断した流通を，却下することもあることに注意。
◎
Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.
</p>

		</section>
		<section id="persistent.failures">
<h3 title="Failures and Timeouts">9.6. 失敗と時間制限</h3>

<p>
`~server$は、通例的に，何らかの時間制限~値を持つ
— それを超過したときには，作動中でない接続を もはや保守しなくなるような。
`~proxy$~serverは、この値をより高くすることもある
— `~client$は、同じ~proxy~serverを通して，更なる接続を~~確立する見込みが高いので。
`持続的~接続$の利用は、［
`~client$／`~server$
］いずれに対しても，［
この時間制限の長さ（または その有無）
］に要件を設置しない。
◎
Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.
</p>

<p>
時間制限を望む`~client$／`~server$は、接続~上に上品な~closeを~~発行するベキである。
実装は、［
~open接続にて受信される~closure通達
］を常時~監視して，それに対し適切に応答するベキである
— 接続の両~側に向けて~closureを促すことで，割振られた~system資源を取戻せるようになるので。
◎
A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.
</p>

<p>
［
`~client$／`~server$／`~proxy$
］は、~transport接続をいつでも~closeしてもヨイ。
例えば、~serverが “遊休~中” の接続を~closeすると裁定したと同時に，~clientが新たな要請の送信を開始することもあり得る
— その場合、~server視点からは，遊休~中に接続が~closeされているように見える一方で、~client視点からは，要請は進捗~中に見えることになる。
◎
A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the "idle" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.
</p>

<p>
`~server$は、アリなときは，`持続的~接続$を維持させ, ［
一時的な過負荷は、下層~transportの~flow制御の仕組みにより解決できる
］ようにするベキである
— `~client$が再試行する期待に基づいて，接続を終了させる技法は、~network混雑を悪化させ得るので。
◎
A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads, rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.
</p>

<p>
［
`~message本体$を送信している`~client$
］は、要請を伝送している間，［
~network接続における~error応答
］を監視するベキである。
~clientは、［［
`~server$は、~message本体を受信するのを望まず，接続を~closeしている
］ことを指示する応答
］を受け取ったときには，本体の伝送処理を即時に止めた上で，自身の側の接続を~closeするベキである。
◎
A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.
</p>

		</section>
		<section id="persistent.tear-down">
<h3 title="Tear-down">9.7. 解体</h3>

<p>
`Connection$h ~headerは、`~close_接続~option$を供する
— `送信者$は、［
現在の［
要請/応答
］~pair
］の後に，接続を~closeしたいと望むとき それを送信するベキである。
◎
The Connection header field (Section 9.1) provides a "close" connection option that a sender SHOULD send when it wishes to close the connection after the current request/response pair.
</p>

<div class="p">
<p>
`~close_接続~option$を伴う要請を送信した`~client$は：
◎
A client that sends a "close" connection option＼
</p>

<ul>
	<li>
同じ接続~上に，更なる要請を送信してはナラナイ。
◎
MUST NOT send further requests on that connection (after the one containing "close") and＼
</li>
	<li>
この要請に対応する最終~応答~messageを読取ったときは，その接続を~closeしなければナラナイ。
◎
MUST close the connection after reading the final response message corresponding to this request.
</li>
</ul>
</div>

<div class="p">

<p>
`~close_接続~option$を伴う要請を受信した`~server$は：
◎
A server that receives a "close" connection option＼
</p>

<ul>
	<li>
［
その要請に対する最終~応答
］を送信した後に，接続の~close（下を見よ）を起動しなければナラナイ。
◎
MUST initiate a close of the connection (see below) after it sends the final response to the request that contained "close".＼
</li>
	<li>
加えて，その最終~応答~内に［
`~close_接続~option$
］を送信するベキである。
◎
The server SHOULD send a "close" connection option in its final response on that connection.＼
</li>
	<li>
［
その接続~上に受信された, どの更なる要請
］も，処理してはナラナイ。
◎
The server MUST NOT process any further requests received on that connection.
</li>
</ul>

</div>

<div class="p">
<p>
`~close_接続~option$を伴う応答を送信した`~server$は：
◎
A server that sends a "close" connection option＼
</p>

<ul>
	<li>
接続の~close（下を見よ）を起動しなければナラナイ。
◎
MUST initiate a close of the connection (see below) after it sends the response containing "close".＼
</li>
	<li>
その接続~上に受信された, どの更なる要請も，処理してはナラナイ。
◎
The server MUST NOT process any further requests received on that connection.
</li>
</ul>

</div>

<div class="p">
<p>
`~close_接続~option$を伴う応答~messageを受信した`~client$は：
◎
A client that receives a "close" connection option＼
</p>

<ul>
	<li>
その接続~上の要請の送信を止めた上で，その応答を読取った後に，接続を~closeしなければナラナイ
◎
MUST cease sending requests on that connection and close the connection after reading the response message containing the "close";＼
</li>
	<li>
【その応答を受信する前に】
同じ接続~上に，追加的な［
~pipeline化された要請
］を送信していた場合、［
それらが`~server$により処理される
］ものと見做すベキでない。
◎
if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.
</li>
</ul>
</div>

<p>
`~server$が，~TCP接続の~closeを即時に遂行した場合、［
`~client$が最後の~HTTP応答を読取れなくなる
］有意な~riskがある：
~server【側の~TCP~stack】が，［
全部的に~closeされた接続
］上で［
~clientから追加的な~data
］を受信した場合
— 例えば、~clientが，~serverの応答を受信する前に送信した 別の要請など —
~serverの~TCP~stackは、~clientへ向けて，~reset~packetを送信することになる。
が、あいにく，~reset~packet【を受け取った~client側の~TCP~stack】は、［
~clientの~HTTP構文解析器が，入力~bufferを読取って解釈する
］前に，~clientから承認されないまま，~bufferを消去し得る。
◎
If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response. If the server receives additional data from the client on a fully closed connection, such as another request that was sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.
</p>

<div class="p">

<p>
~TCP~reset問題を避けるため、`~server$は概して，次の段階を踏んで接続を~closeする：
◎
To avoid the TCP reset problem, servers typically close a connection in stages.＼
</p>

<ol>
	<li>
［
読取り, 書込み
］接続のうち，書込み側のみを~closeする。
◎
First, the server performs a half-close by closing only the write side of the read/write connection.＼
</li>
	<li>
<p>
次のいずれかの時点まで，接続からの読取りを継続する：
◎
The server then continues to read from the connection＼
</p>
		<ul>
			<li>
`~client$による，対応ng~closeを受信したとき。
◎
until it receives a corresponding close by the client, or＼
</li>
			<li>
［
`~client$が［
`~server$の最後の応答を包含している~packetたちを承認した
］ことについて，~serverが自前の~TCP~stackが受信した
］ことを、~serverが適度に~~確信できたとき。
◎
until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response.＼
</li>
		</ul>
	</li>
	<li>
接続を全部的に~closeする。
◎
Finally, the server fully closes the connection.
</li>
</ol>

</div>

<p>
~reset問題が［
~TCP に固有なのか，他の~transport接続~protocolにも見出され得るのか
］は、未知である。
◎
It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.
</p>

		</section>
		<section id="tls.connection.closure">
<h3 title="TLS Connection Closure">9.8. ~TLS接続の~closure</h3>

<p>
~TLSは、~secure接続の~closure用の便宜性を供する。
妥当な~closure~alertを受信した実装は、その接続~上では，それ以上~dataは受信されないことを確約できる。
~TLS実装は、接続を~closeする前に，~closure~alertの交換を起動しなければナラナイ。
~closure~alertを送信した~TLS実装は、~peerから~closure~alertが送信されてくるのを待機することなく，接続を~closeしてもヨイ
— これは、 “不完全な~close” を生成することになる。
これを行う実装は、当の~sessionを再利用することにしてもヨイことに注意。
これを行うのは、当の応用が~careする~message~dataは，すべて受信されたものと（概して，~HTTP~message境界の検出-法を通して）知れたときに限るベキである。
◎
TLS provides a facility for secure connection closure. When a valid closure alert is received, an implementation can be assured that no further data will be received on that connection. TLS implementations MUST initiate an exchange of closure alerts before closing a connection. A TLS implementation MAY, after sending a closure alert, close the connection without waiting for the peer to send its closure alert, generating an "incomplete close". Note that an implementation which does this MAY choose to reuse the session. This SHOULD only be done when the application knows (typically through detecting HTTP message boundaries) that it has received all the message data that it cares about.
</p>

<p>
`RFC8446$r に指定されるように、実装は，［
最初に妥当な~closure~alertを受信することなく，接続の~closeを受信した（ “尚早な~close” ）
］ときは、その~sessionを再利用してはナラナイ。
尚早な~closeは、すでに受信した~dataの~securityについて疑いを示すものではない
— 単純に，後続の~dataは切落されたかもしれないことを指示することに注意。
~TLSは，~HTTPの［
要請／応答
］境界には無頓着なので、［
~messageの内側／ 2 つの~messageの合間
］のどちらで切落されたかは，~HTTP~data（特定的には `Content-Length$h ~header）を精査して決定することが必要とされる。
◎
As specified in [RFC8446], any implementation which receives a connection close without first receiving a valid closure alert (a "premature close") MUST NOT reuse that session. Note that a premature close does not call into question the security of the data already received, but simply indicates that subsequent data might have been truncated. Because TLS is oblivious to HTTP request/response boundaries, it is necessary to examine the HTTP data itself (specifically the Content-Length header) to determine whether the truncation occurred inside a message or between messages.
</p>

<p>
尚早な~closeに遭遇した`~client$は、自身が受信した `Content-Length$h ~headerにて指定された分の~dataを成す要請については，すべて完了したものと扱うベキである。
◎
When encountering a premature close, a client SHOULD treat as completed all requests for which it has received as much data as specified in the Content-Length header.
</p>

<p>
不完全な~closeを検出した`~client$は、それを上品に回復するベキであり，この流儀で~closeされた~TLS~sessionを再開してもヨイ。
◎
A client detecting an incomplete close SHOULD recover gracefully. It MAY resume a TLS session closed in this fashion.
</p>

<p>
`~client$は、接続を~closeする前に，~closure~alertを送信しなければナラナイ。
~clientは、それ以上の~dataを受信するつもりはないならば，［
`~server$の~closure~alertを待機することなく，単純に接続を~closeする
］ことにしてもヨイ
— それは、~server側にとって不完全な~closeを生成することになる。
◎
Clients MUST send a closure alert before closing the connection. Clients which are unprepared to receive any more data MAY choose not to wait for the server's closure alert and simply close the connection, thus generating an incomplete close on the server side.
</p>

<p>
`~server$は、`~client$から不完全な~closeを受信することに備えておくベキである
— ~clientは、~serverからの~dataがいつ終端するか決定できることが多いので。
~serverは、必要とあらば，この流儀で~closeされた~TLS~sessionを再開するベキである。
◎
Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often determine when the end of server data is. Servers SHOULD be willing to resume TLS sessions closed in this fashion.
</p>

<p>
`~server$は、接続を~closeする前に，`~client$との~closure~alertの交換を起動しようと試みなければナラナイ。
~closure~alertを送信した~serverは、接続を~closeしてもヨイ
— それは、~client側にとって不完全な~closeを生成することになる。
◎
Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.
</p>

		</section>
		<section id="header.upgrade">
<h3>9.9. `Upgrade^h</h3>

<p>
`Upgrade$h ~headerは、［［
ある接続~上で，`~HTTP11$から 何らかの他の~protocolへ移行する
］ための単純な仕組み
］を意図して供されている。
◎
The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.
</p>

<p>
`~client$は、要請の `Upgrade$h ~header内に［
選好順による，~protocol名の~list
］を送信して，［
`~server$が最終~応答を送信する前に，
1 個~以上の それらの名前の~protocolに切替えてもらう
］よう，~serverを招いてもヨイ。
`~server$は、その接続~上で，現在の~protocolを利用し続けたいと望むならば，［
受信された `Upgrade$h ~header
］を無視してもヨイ。
`Upgrade$h を利用して，~protocol変更を強要することはできない。
◎
A client MAY send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.
</p>

<pre class="ABNF">
`Upgrade@p
    = 1#`protocol$p
`protocol@p
    = `protocol-name$p ["/" `protocol-version$p]
`protocol-name@p
    = `token$p
`protocol-version@p
    = `token$p
</pre>


<p>
~protocol名は，選好される文字大小で登録されるが、受信者は，［
各 `protocol-name$p を~supportされる~protocolと照合するとき
］には文字大小無視で比較するベキである。
◎
Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.
</p>


<div class="p">
<p>
`101$st 応答を送信する`~server$は：
◎
A server that sends a 101 (Switching Protocols) response＼
</p>

<ul>
	<li>
`Upgrade$h ~headerを送信して、切替えようとしている接続に対し，
1 個~以上の新たな~protocolを指示しなければナラナイ。
◎
MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched;＼
</li>
	<li>
切替えようとしている~protocol層が複数ある場合，それらを，最下~層のものから昇順に~listしなければナラナイ。
◎
if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.＼
</li>
	<li>
~protocolを［［［
`~client$による，対応ng要請
］の `Upgrade$h ~header
］内に指示されていないもの
］に切替えてはナラナイ。
◎
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.＼
</li>
	<li>
<p >
［
`~client$により指示された 選好~順序
］を無視することにして，［
要請の資質や, ~server上の現在の負荷などの，他の要因に基づく新たな†~protocol（たち）
］を選定してもヨイ。
◎
A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.
</p>

<p class="trans-note">【†
新たな — その前の条項と矛盾？
】</p>
</li>
</ul>

</div>

<p>
`~server$は：
</p>

<ul>
	<li>
`426$st 応答を送信するときは、［
受容-可能な~protocolを指示する
］ために，［
選好順による， `Upgrade$h ~header
］を送信しなければナラナイ。
◎
A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.
</li>
	<li>
他の応答においても、未来の要請~用に適切になるときは，［
選好順による， `Upgrade$h ~header
］を送信して，［
自身が［
~listされた~protocolに昇格するための~support
］を実装している
］ことを広告してもヨイ。
◎
A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.
</li>
</ul>

<div class="example">

<p>
`~client$により送信される仮の例を次に示す：
◎
The following is a hypothetical example sent by a client:
</p>

<pre class="http-code">
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
</pre>

</div>

<p>
~protocol変更~後の［
応用~level通信の能力や資質
］は、［
選ばれた新たな~protocol（たち）
］に全面的に依存する。
しかしながら，`~server$は、
`101$st 応答を送信した直後に［
新たな~protocolの中で，元の要請に等価なものを受信した
］かのように応答を継続するものと期待されている（すなわち、~protocolが変更された後であっても，~serverは依然として［
まだ満足するべき`応答待ち要請$
］を持ち，［
要請の繰返し
］を要求することなく，そうするものと期待されている）。
◎
The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).
</p>

<p>
例えば，~serverが、［
`GET$m 要請にて `Upgrade$h ~headerが受信された
］下で，~protocolを切替えると裁定した場合には、まず［
HTTP/1.1 `101$st ~message
］で応答した直ぐ後に，［
新たな~protocolにおける［
`~target資源$上の `GET$m に対する応答
］に等価なもの
］が後続する。
これにより、追加的な往来による待時間~costなしに，［
~HTTPと同じ意味論を有する~protocol
］へ接続を昇格できるようになる。
`~server$は、新たな~protocolが［
受信された~message意味論
］を尊守し得ない場合は，~protocolを切替えてはナラナイ
— `OPTIONS$m 要請は，どの~protocolからも尊守し得る。
◎
For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.
</p>

<div class="example">

<p>
上に示された仮の要請に対する応答~例を，次に示す：
◎
The following is an example response to the above hypothetical request:
</p>

<pre class="http-code">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

<span class="comment">
[…… "`GET /hello^c" 要請に対し，適切な応答により~data~streamを
websocket に切替える（その新たな~protocolによる定義に従って）…… ]
◎
[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
</span>
</pre>

</div>

<p>
`Upgrade$h を送信する`送信者$は、［
`Upgrade$h が［
~listされた~protocolを実装していない`中継者$
］により偶発的に回送される
］ことを防ぐために，［
"`upgrade^c" `接続~option$を包含する `Connection$h ~header
］も送信しなければナラナイ。
`~server$は、［
~HTTP10要請にて受信された `Upgrade$h ~header
］を無視しなければナラナイ。
◎
When Upgrade is sent, the sender MUST also send a Connection header field (Section 9.1) that contains an "upgrade" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols. A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.
</p>

<p>
`~client$は、［
要請~messageを完全に送信し終える
］まで，接続~上にて昇格された~protocolの利用を~~開始できない（すなわち，~clientは、~messageの中途で，送信している~protocolを変更できない）。
`~server$は、［
`Upgrade$h,
`~100cont 期待$を伴う `Expect$h
］の両~headerとも受信したときは，
`101$st 応答を送信する前に `100$st 応答を送信しなければナラナイ。
◎
A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the "100-continue" expectation (Section 8.1.1 of [Semantics]), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.
</p>

<p>
`Upgrade$h ~headerは，［
既存の接続の上層にある~protocolの切替
］にのみ適用される。
それは［
下層~接続の（~transport）~protocolの切替
］, あるいは［
既存の通信を異なる接続に切替えること
］には利用し得ない。
その種の目的には、 `3xx$st 応答を利用する方が適切である。
◎
The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 9.4 of [Semantics]).
</p>

			<section id="upgrade.protocol.names">
<h4 title="Upgrade Protocol Names">9.9.1. `Upgrade^h ~protocol名</h4>

<p>
この仕様は、［
Hypertext Transfer Protocol 族
］に利用するための~protocol名として
—［
~HTTP~version規則
`Semantics/3.5$sec, および この仕様に対する将来の更新
］に定義されるように —
"`HTTP^c" のみを定義する。
追加的な~protocol名は、
`9.9.2$sec に定義される登録~手続きを利用して登録される~OUGHT。
◎
This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 3.5 of [Semantics] and future updates to this specification. Additional protocol names ought to be registered using the registration procedure defined in Section 9.9.2.
</p>

<div>
<table><thead><tr><td>値
<td>説明d
<td>期待される~version~token
<td>参照
</thead>

<tbody><tr><td>`HTTP^c
<td>Hypertext Transfer Protocol
<td>任意の `DIGIT.DIGIT^c （例： "`2.0^c" ）
<td>`Semantics/3.5$sec
</tbody></table>
◎
Name 	Description 	Expected Version Tokens 	Reference

HTTP 	Hypertext Transfer Protocol 	any DIGIT.DIGIT (e.g, "2.0") 	Section 3.5 of [Semantics]
</div>

			</section>
			<section id="upgrade.token.registry">
<h4 title="Upgrade Token Registry">9.9.2. `Upgrade^h ~token登記簿</h3>

<p>
［
`Upgrade$h ~header内の~protocolを識別するために利用される，
`protocol-name$p ~token
］用の名前空間は、
`~HTTP Upgrade ~token登記簿$cite
にて保守され，定義される。
◎
The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines the namespace for protocol-name tokens used to identify protocols in the Upgrade header field. The registry is maintained at &lt;https://www.iana.org/assignments/http-upgrade-tokens&gt;.
</p>

<p>
登録された各~protocol名には、連絡~先~情報に加えて，省略可能な［
接続は、昇格された後 どう処理されるかについて詳細を述べる仕様の集合
］が結付けられる。
◎
Each registered protocol name is associated with contact information and an optional set of specifications that details how the connection will be processed after it has been upgraded.
</p>

<p>
登録は、
“~~申請順（ `First Come First Served^en ）”（
`RFC8126/4.4$sec
）に基づいて行われ，次の規則の~subjectになる：
◎
Registrations happen on a "First Come First Served" basis (see Section 4.4 of [RFC8126]) and are subject to the following rules:
</p>

<ol>
	<li>
一度~登録された `protocol-name$p ~tokenは、登録されたまま~~恒久的に居残る。
◎
A protocol-name token, once registered, stays registered forever.
</li>
	<li>
`protocol-name$p ~tokenは文字大小無視であるが、送信者が生成するときは，登録された文字大小が選好される。
◎
A protocol-name token is case-insensitive and registered with the preferred case to be generated by senders.
</li>
	<li>
登録は、登録に対する責任主体を命名しなければナラナイ。
◎
The registration MUST name a responsible party for the registration.
</li>
	<li>
登録は、連絡~窓口を命名しなければナラナイ。
◎
The registration MUST name a point of contact.
</li>
	<li>
登録は、［
その~tokenに結付けられる仕様の集合
］を命名してもヨイ。
そのような仕様は、公共に可用になる必要はない。
◎
The registration MAY name a set of specifications associated with that token. Such specifications need not be publicly available.
</li>
	<li>
登録は、［
登録の時点でその~tokenに結付けられる［
期待される "`protocol-version$p" ~tokenからなる集合
］］を命名するベキである。
◎
The registration SHOULD name a set of expected "protocol-version" tokens associated with that token at the time of registration.
</li>
	<li>
責任主体は、いつでも登録を変更してもヨイ。
~IANAは、そのような変更sすべての記録-を保って，要請に応じて，それらを可用にすることになる。
◎
The responsible party MAY change the registration at any time. The IANA will keep a record of all such changes, and make them available upon request.
</li>
	<li>
IESG は、
`protocol$p ~tokenに対する責任主体を他にアテガってもヨイ。
これは、通常は，責任主体に連絡できなくなったときに限られる。
◎
The IESG MAY reassign responsibility for a protocol token. This will normally only be used in the case when a responsible party cannot be contacted.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="enclosing.messages">
<h2 title="Enclosing Messages as Data">10. ~messageを~dataとして同封するとき</h2>

		<section id="media.type.message.http">
<h3 title="Media Type message/http">10.1. ~MIME型 `message/http^c</h3>

<p>
~MIME型 `message/http^c は、単独の~HTTP［
要請／応答
］~messageを同封するために利用できる
— それが、すべての "message" 型に対し，行lの長さと符号化法に関して ~MIME制約を順守する限りにおいて。
◎
The message/http media type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all "message" types regarding line length and encodings.
</p>

<div>
<dl>
<dt>型~名
<dd>`message^c

<dt>下位型~名
<dd>`http^c

<dt>要求される~parameter
<dd>N/A

<dt>省略可能な~parameter
<dd>`version^V, `msgtype^V
	<dl>
	<dt>`version^V
	<dd>
同封された~messageの `HTTP-version$p 番号（例： "`1.1^c" ）。
無い場合の`~version$は、本体の最初の行lから決定し得る。
	<dt>`msgtype^V
	<dd>
~message型 — "`request^c" または "`response^c" 。
無い場合の型は、本体の最初の行lから決定し得る。
	</dl></dd>

<dt>符号化法の考慮点
<dd>"`7bit^c", "`8bit^c", "`binary^c" のみ許可される

<dt>~securityの考慮点
<dd>`11$sec を見よ

<dt>相互運用能の考慮点
<dd>N/A

<dt>発行した仕様
<dd>この仕様（この節を見よ）

<dt>この~MIME型を利用する応用
<dd>N/A

<dt>`素片~識別子$に対する考慮点
<dd>N/A

<dt>追加的な情報
<dd><dl>
	<dt>Magic number(s):
	<dt>Deprecated alias names for this type:
	<dt>File extension(s):
	<dt>Macintosh file type code(s):
	<dd>N/A
	</dl></dd>

<dt>Person and email address to contact for further information:
<dd>`著作者の~address$secに。

<dt>意図される用法
<dd>COMMON

<dt>用法~上の制約
<dd>N/A

<dt>著作者
<dd>`著作者の~address$secに。

<dt>変更管理者
<dd>IESG
</dl>

◎
Type name:
• message
Subtype name:
• http
Required parameters:
• N/A
Optional parameters:
• version, msgtype
•• version:
••• The HTTP-version number of the enclosed message (e.g., "1.1"). If not present, the version can be determined from the first line of the body. 
•• msgtype:
••• The message type — "request" or "response". If not present, the type can be determined from the first line of the body. 

Encoding considerations:
• only "7bit", "8bit", or "binary" are permitted
Security considerations:
• see Section 11 
Interoperability considerations:
• N/A
Published specification:
• This specification (see Section 10.1). 
Applications that use this media type:
• N/A
Fragment identifier considerations:
• N/A
Additional information:
•• Magic number(s):
•••  N/A
•• Deprecated alias names for this type:
•••  N/A
•• File extension(s):
•••  N/A
•• Macintosh file type code(s):
•••  N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

		</section>
		<section id="media.type.application.http">
<h3 title="Media Type application/http">10.2. ~MIME型 `application/http^c</h3>

<p>
~MIME型 `application/http^c は、~pipeline化された 1 個~以上の~HTTP［
要請~messageのみ／応答~messageのみ
］を同封するときに利用できる。
◎
The application/http media type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).
</p>

<div>

<p>
次に挙げる項目以外は、
`message/http^c と同じ：
</p>

<dl>
<dt>型~名
<dd>`application^c
<dt>符号化法の考慮点
<dd>
この型により同封された［
一連の~HTTP~message
］は、 "binary" 形式になる
— ~emailを介して伝送されるときは、適切な
`Content-Transfer-Encoding$h
の利用が要求される。
<dt>発行した仕様
<dd>この仕様（この節を見よ）
</dl>

◎
Type name:
• application
Subtype name:
• http
Required parameters:
• N/A
Optional parameters:
• version, msgtype
•• version:
••• The HTTP-version number of the enclosed messages (e.g., "1.1"). If not present, the version can be determined from the first line of the body. 
•• msgtype:
••• The message type — "request" or "response". If not present, the type can be determined from the first line of the body. 

Encoding considerations:
• HTTP messages enclosed by this type are in "binary" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email.
Security considerations:
• see Section 11 
Interoperability considerations:
• N/A
Published specification:
• This specification (see Section 10.2). 
Applications that use this media type:
• N/A
Fragment identifier considerations:
• N/A
Additional information:
•• Deprecated alias names for this type:
••• N/A
•• Magic number(s):
••• N/A
•• File extension(s):
••• N/A
•• Macintosh file type code(s):
••• N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

		</section>
	</section>
	<section id="security.considerations">
<h2 title="Security Considerations">11. ~securityの考慮点</h2>

<p>
この節は、［
開発者／情報~provider／利用者
］に，~HTTP~messageの［
構文, 構文解析, ~route法
］に関連な，既知な~securityの考慮点を伝えることを~~意図している。
~HTTPの［
意味論／`~payload$
］についての，~securityの考慮点は、`RFC7231$r にて取組まれる。
◎
This section is meant to inform developers, information providers, and users of known security considerations relevant to HTTP message syntax, parsing, and routing. Security considerations about HTTP semantics and payloads are addressed in [Semantics].
</p>

		<section id="response.splitting">
<h3 title="Response Splitting">11.1. 応答~分割</h3>

<p>
`応答~分割^dfn
（いわゆる `CRLF$P 注入）は、~Web利用eに対する様々な攻撃にて共通的に利用される技法であり，［
~HTTP~message~frame法の，行lに基づく資質
］と［
`持続的~接続$における，要請から応答への順序~付けられた結付け
］を悪用する
`Klein$r
。
この技法は、特に，［
要請が`共用~cache$を通して渡される
］ときに被害を大きくし得る。
◎
Response splitting (a.k.a, CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]. This technique can be particularly damaging when the requests pass through a shared cache.
</p>

<p>
応答~分割は、［
要請の何らかの~parameter
— 後に，復号され, 応答の何らかの~headerの中に 復唱されるような~parameter —
の中に，攻撃者が符号化-済み~dataを送信できる
］ような，`~server$における脆弱性（通例的に応用~serverの中）を悪用する。
~dataが，［
それを復号した結果が，応答が終端され, 後続の応答が始まる
］ように見せかけて細工されていた場合、応答は分割され，［
2 番目であるように見せかけた応答
］の内容が攻撃者により制御される。
しかる後，攻撃者は、［
同じ`持続的~接続$ 上に，他の何らかの要請を為して
］，`受信者$（`中継者$も含む）に［
分割-の~~後半部分が， 2 番目の要請に対する`権限的$な回答である
］と信じ込ませることも可能になる。
◎
Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response. If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split and the content within the apparent second response is controlled by the attacker. The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.
</p>

<p>
例えば，［
`request-target$p の中の~parameter
］は、［
応用~serverにより読取られ, ~redirectの中で再利用される
］結果、同じ~parameterが応答の `Location$h ~header内に復唱され得る。
~parameterが［
応用により復号され，応答~header内に置かれる
］ときに，適正に符号化されない下では、攻撃者は、［
符号化-済みな `CRLF$P ~octetその他の内容
］を送信して，応用の単独の応答を 2 個~以上の応答に見せかけられるようになる。
◎
For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response. If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses.
</p>

<p>
応答~分割に対抗する共通的な防御策は、要請の中の［
符号化-済みな `CR$P `LF$P 並びに見せかけた~data
］を~filterするものであるが、それは［
応用~serverが~URIの復号しか遂行していない
］ことを前提にしている
— より見え難い~data形式変換：［
~charset符号変換,
~XML実体~翻訳,
base64 復号,
sprintf 再整形,
等々
］は~~考慮されていない。
それより，［
~serverの中核~protocol~library
］以外のどこであれ，［
`~header節$の中に `CR$P や `LF$P を送信する
］ことを防ぐ方が、効果的な軽減策になる
— それは、~headerの出力を［
不良~octetを~filterする~API
］に制約して，［
応用~serverが~protocol~streamへ直に書込めなくする
］ことを意味する。
◎
A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., "%0D" and "%0A"). However, that assumes the application server is only performing URI decoding, rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc. A more effective mitigation is to prevent anything other than the server's core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream.
</p>

		</section>
		<section id="request.smuggling">
<h3 title="Request Smuggling">11.2. 要請~密入</h3>

<p>
要請~密入（`Linhart$r）は、［
様々な受信者~間での，~protocol構文解析-法における相違点
］を悪用して，［
無害に見せかけた要請
］の中に［
（さもなければ施策により阻止されるか不能化されるような）追加的な要請
］を隠す技法である。
`応答~分割$と同様に、要請~密入は，~HTTP利用eにおいて種々の攻撃を導き得る。
◎
Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request. Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.
</p>

<p>
この仕様は、［
要請~密入の実効性
］を抑制するため、特に，~message~frame法に関して，［
要請の構文解析に課される新たな要件（§`~message本体~長さ$）
］を導入した。
◎
This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 6.3, to reduce the effectiveness of request smuggling.
</p>

		</section>
		<section id="message.integrity">
<h3 title="Message Integrity">11.3. ~messageの完全性</h3>

<p>
~HTTPは、［
~messageの完全性を確保するための，特定の仕組み
］は定義しない。
代わりに［
下層~transport~protocolの~error検出~能,
完全かどうかを検出するための［
長さや, ~chunkで区切られる~frame法
］の利用
］に依拠する。
［
~hash関数や, 内容に適用される~digital署名
］などの［
完全性のための追加的な仕組み
］は、各種［
拡張-可能な~metadata~header
］を介して，選択的に~messageに追加できる。
歴史的に、［
単一の，完全性の仕組み
］の欠如は，［
ほとんどの~HTTP通信が正式でない性向にあること
］を根拠に正当化されていた。
しかしながら、情報~accessの仕組みとして ~HTTPが普及した結果，［
~message完全性の検証yが不可欠な環境
］下での利用は増えている。
◎
HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness. Additional integrity mechanisms, such as hash functions or digital signatures applied to the content, can be selectively added to messages via extensible metadata header fields. Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication. However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial.
</p>

<p>
`~UA$には、［
完全性が必要な環境~下でも、環境設定により，~messageの完全性の失敗を検出して報告できる
］ようにする手段を実装することが奨励される。
例えば，［
医療~履歴や薬剤相互作用についての情報
］を視るために利用されている~browserは、［
そのような情報が転送の間に［
不完全である／失効した／壊れている
］ことが~protocolにより検出された
］ことを，利用者に指示できることが必要とされる。
そのような仕組みは、［
~UA拡張や, 応答~内に~message完全性~metadataが在ること
］を介して，選択的に可能化できるであろう。
`~UA$は、そのような検証yが欲されるときは，最低でも［
応答~messageは完全か`不完全$かを，利用者が判別できる
］ような，何らかの指示を供する~OUGHT。
◎
User agents are encouraged to implement configurable means for detecting and reporting failures of message integrity such that those means can be enabled within environments for which integrity is necessary. For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer. Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response. At a minimum, user agents ought to provide some indication that allows a user to distinguish between a complete and incomplete response message (Section 8) when such verification is desired.
</p>

		</section>
		<section id="message.confidentiality">
<h3 title="Message Confidentiality">11.4. ~messageの機密性</h3>

<p>
~HTTPは、［
~messageの機密性が欲されるときに，それを供する
］にあたり，下層の~transport~protocolに依拠する。
~HTTPは、［
多くの異なる形による，接続の暗号化-
］にも利用し得るように，［
~transport~protocolに依存しない
］ように特定的に設計されてきた。
そのような~transportの選定は、［
選ばれた~URI~schemeや, ~UA環境設定
］により識別されている。
◎
HTTP relies on underlying transport protocols to provide message confidentiality when that is desired. HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many different forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.
</p>

<p>
機密的~接続を要求する`資源$を識別するためには、 "`https$c" `scheme^p を利用できる。
◎
The "https" scheme can be used to identify resources that require a confidential connection, as described in Section 2.5.2 of [Semantics].
</p>

		</section>
	</section>
	<section id="IANA.considerations">
<h2 title="IANA Considerations">12. ~IANA考慮点</h2>

【この節は未訳。】

	</section>
	<section id="collected.abnf">
<h2 title="Collected ABNF">付録 A. 総集的~ABNF</h2>

【この節は未訳。】

	</section>
	<section id="differences.between.http.and.mime">
<h2 title="Differences between HTTP and MIME">付録 B. ~HTTPと~MIMEの相違点</h2>

<div class="p">

<p>
`~HTTP11$は、［
`Internet Message Format^cite `RFC5322$r
および
~MIME（ `Multipurpose Internet Mail Extensions^cite ） `RFC2045$r
］用に定義された構成子の多くを利用して、`~message本体$を，拡張-可能な~headerと伴に［
~openかつ多種多様な`表現$
］により伝送できるようにする。
しかしながら，`RFC2045$rは、~emailのみに力点を置いている
— ~HTTPの応用は、~emailから相違する多くの特性を持つので，~MIMEから相違する特能を備える。
これらの相違点は、次のために注意深く選ばれている：
◎
HTTP/1.1 uses many of the constructs defined for the Internet Message Format [RFC5322] and the Multipurpose Internet Mail Extensions (MIME) [RFC2045] to allow a message body to be transmitted in an open variety of representations and with extensible header fields. However, RFC 2045 is focused only on email; applications of HTTP have many characteristics that differ from email; hence, HTTP has features that differ from MIME. These differences were carefully chosen＼
</p>

<ul>
	<li>
~binary接続の処理能を最適化する
◎
to optimize performance over binary connections,＼
</li>
	<li>
新たな`~MIME型$の利用における自由度を高める
◎
to allow greater freedom in the use of new media types,＼
</li>
	<li>
日時の比較をより容易にする
◎
to make date comparisons easier, and＼
</li>
	<li>
一部の早期の~HTTP［
~server／~client
］の実施を承認する
◎
to acknowledge the practice of some early HTTP servers and clients.
</li>
</ul>

</div>

<p>
この付録は、~HTTPが~MIMEから相違する，特定の分野について述べる。
厳密な~MIME環境 への／からの `~gateway$や`~proxy$は、これらの相違点を自覚した上で，必要とされる所では 適切な変換を供する必要がある。
◎
This appendix describes specific areas where HTTP differs from MIME. Proxies and gateways to and from strict MIME environments need to be aware of these differences and provide the appropriate conversions where necessary.
</p>

		<section id="mime-version">
<h3 title="MIME-Version">B.1. `MIME-Version^h</h3>

<p>
~HTTPは、~MIME準拠~protocolではない。
しかしながら，~messageを構築するときに［
単独の `MIME-Version^h ~header
］を内包することで、［
~MIME~protocolの どの~versionが利用されたか
］を指示できる。
`MIME-Version^h ~headerの利用は、［
~messageが（ `RFC2045$r にて定義されるように）~MIME~protocolに全部的に適合している
］ことを指示する。
`送信者$は、［
~HTTP~messageを厳密な~MIME環境に~exportする
］ときには（アリな所では）全部的な適合性を確保する責を負う。
◎
HTTP is not a MIME-compliant protocol. However, messages can include a single MIME-Version header field to indicate what version of the MIME protocol was used to construct the message. Use of the MIME-Version header field indicates that the message is in full conformance with the MIME protocol (as defined in [RFC2045]). Senders are responsible for ensuring full conformance (where possible) when exporting HTTP messages to strict MIME environments.
</p>

		</section>
		<section id="conversion.to.canonical.form">
<h3 title="Conversion to Canonical Form">B.2. 正準-形への変換</h3>

<p>
~MIMEは、 `RFC2049/4$sec にて述べられるように，転送に先立って，［
~Internet~mail本体 部分
］を正準-形に変換することを要求する。
［
"`text^c" `~MIME型$の各種 下位型が，~HTTP越しに伝送されるときに許容される形
］については、
`Semantics/6.1.1.2$sec
にて述べている。
`RFC2046$r は、その "`text^c" 型の内容が，改行を `CRLF$P として表現することを要求し，改行~並びの外での `CR$P ／ `LF$P の利用を禁止する。
一方で，~HTTPは、~text内容の中の改行を指示する［
`CRLF$P 並びや, ~~単独の `CR$P ／ `LF$P
］を許容する。
◎
MIME requires that an Internet mail body part be converted to canonical form prior to being transferred, as described in Section 4 of [RFC2049]. Section 6.1.1.2 of [Semantics] describes the forms allowed for subtypes of the "text" media type when transmitted over HTTP. [RFC2046] requires that content with a type of "text" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content.
</p>

<p>
~HTTPから厳密な~MIME環境への［
`~proxy$／`~gateway$
］は、［
~text`~MIME型$の中のすべての改行
］を［
`RFC2049$r による 正準-形  `CRLF$P
］に転化する~OUGHT。
しかしながら，これは［
`Content-Encoding$h が在ること
］, および［
~HTTPが［［
`CR$P ／ `LF$P
］を表現する~octet［
13 ／ 10
］を利用しない，一部の`~charset$
］の利用を許容する事実
］により，複雑化することもあることに注意。
◎
A proxy or gateway from HTTP to a strict MIME environment ought to translate all line breaks within text media types to the RFC 2049 canonical form of CRLF. Note, however, this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some charsets that do not use octets 13 and 10 to represent CR and LF, respectively.
</p>

<p>
変換は、［
内容が~~元々正準-形である場合
］を除き，［
元の内容に適用された暗号用の~checksumを，それが何であれ 壊す
］ことになる。
したがって、~HTTPにてそのような~checksumを利用する内容には，正準-形が推奨される。
◎
Conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such checksums in HTTP.
</p>

		</section>
		<section id="conversion.of.date.formats">
<h3 title="Conversion of Date Formats">B.3. 日時~形式の変換</h3>

<p>
`~HTTP11$は、日時の比較~処理nを単純~化するために，制約された日時~形式の集合（ `Semantics/10.1.1.1$sec ）を利用する。
他の~protocolからの［
`~proxy$／`~gateway$
］は、［
~message内に在るどの `Date$h ~header
］も，いずれかの~HTTP11形式に適合することを確保し、必要とされるなら日時を書換える~OUGHT。
◎
HTTP/1.1 uses a restricted set of date formats (Section 10.1.1.1 of [Semantics]) to simplify the process of date comparison. Proxies and gateways from other protocols ought to ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.
</p>

		</section>
		<section id="conversion.content-encoding">
<h3 title="Conversion of Content-Encoding">B.4. `Content-Encoding^h の変換</h3>

<p>
~MIMEは、`~HTTP11$の `Content-Encoding$h ~headerに等価な概念を含まない。
これは，`~MIME型$の改変子として動作するので、~HTTPから~MIME準拠~protocolへの［
`~proxy$／`~gateway$
］は，~messageを回送する前に［
`Content-Type$h ~headerの値を変更する
］か, または［
`表現$を復号する
］~OUGHT。
（~Internet~mail用の `Content-Type$h の試験的な応用には、
`Content-Encoding$h と等価な機能を遂行するために，
`media-type$p ~parameterに
"`;conversions=&lt;content-coding&gt;^c"
を利用しているものもある。
しかしながら，この~parameterは、~MIME標準の一部ではない）。
◎
MIME does not include any concept equivalent to HTTP/1.1's Content-Encoding header field. Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols ought to either change the value of the Content-Type header field or decode the representation before forwarding the message. (Some experimental applications of Content-Type for Internet mail have used a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform a function equivalent to Content-Encoding. However, this parameter is not part of the MIME standards).
</p>

		</section>
		<section id="conversion.content-transfer-encoding">
<h3 title="Conversion of Content-Transfer-Encoding">B.5. `Content-Transfer-Encoding^h の変換</h3>

<p>
~HTTPは、［
~MIMEの `Content-Transfer-Encoding$h ~header
］を利用しない。
~MIME準拠~protocolから~HTTPへの［
`~proxy$／`~gateway$
］は、応答~messageを~HTTP~clientへ送達するに先立って，すべての `Content-Transfer-Encoding^h を除去する必要がある。
◎
HTTP does not use the Content-Transfer-Encoding field of MIME. Proxies and gateways from MIME-compliant protocols to HTTP need to remove any Content-Transfer-Encoding prior to delivering the response message to an HTTP client.
</p>

<p>
~HTTPから~MIME準拠~protocolへの［
`~proxy$／`~gateway$
］は、~messageが［
その~protocol上で安全に~transportされるような，正しい［
形式, 符号化法
］である
］ことを確保する責を負う
— ここでの “安全な~transport” は、利用される~protocolによる制限により定義される。
そのような［
~proxy／~gateway
］は、［
適切な `Content-Transfer-Encoding$h を伴う~data
］を形式変換して~labelする~OUGHT
— そうすることで，行先~protocol越しの~transportが安全になる見込みが高まる場合には。
◎
Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where "safe transport" is defined by the limitations of the protocol being used. Such a proxy or gateway ought to transform and label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.
</p>

		</section>
		<section id="mhtml.line.length">
<h3 title="MHTML and Line Length Limitations">B.6. ~MHTMLと行l長さ制限</h3>

<p>
~MHTML `RFC2557$r 実装と~codeを共有する~HTTP実装は、~MIMEにおける行l長さ制限を自覚しておく必要がある。
~HTTPにおいては この制限がないので、長い行lも折返さない。
［
~HTTPにより~transportされている~MHTML~message
］は、行lの［
長さ制限, 折返し, 正準-化, 等々
］を含め，~MHTMLのすべての規約に従う
— ~HTTPは、`~message本体$を~payloadとして転送し，
"`multipart/byteranges$c" 型は別として，そこに包含され得るどの［
内容／~MIME~header行l
］も解釈しないので。
◎
HTTP implementations that share code with MHTML [RFC2557] implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transfers message-bodies as payload and, aside from the "multipart/byteranges" type (Section 6.3.5 of [Semantics]), does not interpret the content or any MIME header lines that might be contained therein.
</p>

		</section>
	</section>
	<section id="compatibility">
<h2 title="HTTP Version History">付録 C. ~HTTP~versionの歴史</h2>

<p>
~HTTPは 1990 年から利用されてきた。
後に~HTTP09と称されるようになった最初の~versionは、
~Internetをまたがる~hypertext~data転送~用の単純な~protocolで，［
~metadataの無い単独の要請~method（ `GET$m ）
］のみを利用していた。
`RFC1945$r により定義された~HTTP10には、［
~metadataの転送や, ［
要請／応答
］意味論を改変する
］ことを許容するために［
ある範囲の`要請~method$と, ~MIMEに似た~message法
］が追加された。
しかしながら，~HTTP10は、［
階層的~proxy,
~caching,
`持続的~接続$の必要性,
名前に基づく仮想~host
］の効果を十分に考慮点に入れてなかった。
更には，［
自身を "HTTP/1.0" と称して，不完全に実装された応用
］の急増から、［
通信-中の 2 つの応用が互いの~~真の能力を決定する
］ための，~protocol~version変更が~~余儀なくされた。
◎
HTTP has been in use since 1990. The first version, later referred to as HTTP/0.9, was a simple protocol for hypertext data transfer across the Internet, using only a single request method (GET) and no metadata. HTTP/1.0, as defined by [RFC1945], added a range of request methods and MIME-like messaging, allowing for metadata to be transferred and modifiers placed on the request/response semantics. However, HTTP/1.0 did not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or name-based virtual hosts. The proliferation of incompletely implemented applications calling themselves "HTTP/1.0" further necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities.
</p>

<div class="p">

<p>
`~HTTP11$は、次により，~HTTP10との互換性が保たれている：
◎
HTTP/1.1 remains compatible with HTTP/1.0 by＼
</p>

<ul>
	<li>
依拠-可能な実装を可能化する，より厳格な要件を含めている。
◎
including more stringent requirements that enable reliable implementations,＼
</li>
	<li>
追加された特能は、次に限られている
⇒＃
~HTTP10受信者からは安全に無視されるもの／
~HTTP11への適合性を広告する主体と通信するときに限り，送信されるもの
◎
adding only those features that can either be safely ignored by an HTTP/1.0 recipient or only be sent when communicating with a party advertising conformance with HTTP/1.1.
</li>
</ul>

</div>

<div class="p">

<p>
~HTTP11は、以前の~versionを~supportし易くなるように，設計された。
一般用`~HTTP11$`~server$は、次ができる~OUGHT：
◎
HTTP/1.1 has been designed to make supporting previous versions easy. A general-purpose HTTP/1.1 server ought to be able to＼
</p>

<ul>
	<li>
~HTTP10の形式による，妥当な要請も解する。
◎
understand any valid request in the format of HTTP/1.0,＼
</li>
	<li>
［
~HTTP10~clientにより解される（または安全に無視される）特能
］のみを利用する~HTTP11~messageに対し，適切に応答する。
◎
responding appropriately with an HTTP/1.1 message that only uses features understood (or safely ignored) by HTTP/1.0 clients.＼
</li>
</ul>

<p>
同様に、［
~HTTP11~clientは，妥当な~HTTP10応答を解する
］ものと期待できる。
◎
Likewise, an HTTP/1.1 client can be expected to understand any valid HTTP/1.0 response.
</p>
</div>

<p>
~HTTP09は，要請~内の~headerを~supportしなかったので、［
名前に基づく仮想~host（ `Host$h ~headerの検分による`資源$の選定）
］を~supportするための仕組みも無かった。
［
名前に基づく仮想~host
］を実装する どの`~server$も，~HTTP09の~supportを不能化する~OUGHT。
事実，~HTTP09として出現するほとんどの要請は、
`request-target$p を適正に符号化できない~clientにより，不良に構築された HTTP/1.x 要請である。
◎
Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field). Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.
</p>

		<section id="changes.from.1.0">
<h3 title="Changes from HTTP/1.0">C.1. ~HTTP10からの変更点</h3>

<p>
この節では、［
~HTTP10, ~HTTP11
］`~version$間の~~主要な相違点を要約する。
◎
This section summarizes major differences between versions HTTP/1.0 and HTTP/1.1.
</p>

			<section id="changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses">
<h4 title="Multihomed Web Servers">C.1.1. ~multihomed~web~server</h4>

<div class="p">

<p>
次に挙げる要件は、~HTTP11により定義された中でも最も重要な変更点である：
</p>

<ul>
	<li>
`~client$／`~server$は、 `Host$h ~headerを~supportし，~HTTP11要請に それが欠落しているときは~errorを報告する。
</li>
	<li>
絶対~URI（ `absolute-URI$p ）を受容する（`要請~target$sec）。
</li>
</ul>

◎
The requirements that clients and servers support the Host header field (Section 5.4 of [Semantics]), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 3.2) are among the most important changes defined by HTTP/1.1.
</div>

<p>
古い~HTTP10~clientは、［
~IP~addressと~serverとの関係性が一対一である
］ものと見做していた
— ［
要請に意図された~server
］を判別するために確立された仕組みは、要請が~directする~IP~addressの他になかった。
`Host$h ~headerは、~HTTP11の開発中に導入され，ほとんどの~HTTP10~browserに すぐに実装されたが、完全な採用を確保するため，すべての~HTTP11要請に 追加的な要件が設置された。
これが書かれた時点では、ほとんどの~HTTPに基づく~serviceが、
`Host$h ~headerに依存して，要請を~targetしている。
◎
Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism for distinguishing the intended server of a request than the IP address to which that request was directed. The Host header field was introduced during the development of HTTP/1.1 and, though it was quickly implemented by most HTTP/1.0 browsers, additional requirements were placed on all HTTP/1.1 requests in order to ensure complete adoption. At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests.
</p>

			</section>
			<section id="compatibility.with.http.1.0.persistent.connections">
<h4 title="Keep-Alive Connections">C.1.2. `Keep-Alive^h 接続</h4>

<p>
~HTTP10における各~接続は、要請に先立って`~client$により確立され，
`~server$により応答が送信された後に~closeされていた。
しかしながら，一部の実装は、`持続的~接続$の［
`RFC2068/19.7.1$secによる，明示的に折衝される~version（ `Keep-Alive$h ）
］を実装している。
◎
In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. However, some implementations implement the explicitly negotiated ("Keep-Alive") version of persistent connections described in Section 19.7.1 of [RFC2068].
</p>

<p>
一部の`~client$／`~server$は、［
これらの以前の~approachが，`持続的~接続$と互換になる
］ことを望むかもしれない
— それらに対し、［
"`Connection: keep-alive^c" 要請~headerにより，明示的に折衝する
］ことにより。
しかしながら，~HTTP10`持続的~接続$の試験的な実装には、~~誤りのあるものもある
— 例えば，~HTTP10~proxy~serverが `Connection$h を解さない場合、その~headerを`内方$にある次の~serverへ誤って回送することになる結果，接続を~hungさせることになろう。
◎
Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a "Connection: keep-alive" request header field. However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.
</p>

<p>
解決策の一つとして、［
特定的に~proxyを~targetにする，
`Proxy-Connection^h ~header
］の導入も試みられた。
実施においては、これも~~機能しなかった。
何故なら、~proxyは複数~層にて配備されていることが多いため，上に論じたのと同じ問題を持ち込むので。
◎
One attempted solution was the introduction of a Proxy-Connection header field, targeted specifically at proxies. In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above.
</p>

<p>
そのため、`~client$には，どの要請にも
`Proxy-Connection^h ~header
を送信しないことが奨励される。
◎
As a result, clients are encouraged not to send the Proxy-Connection header field in any requests.
</p>

<p>
`~client$には、要請における
<code>`Connection$p: keep-alive</code>
の利用にあたり，注意深く考慮することも奨励される
— それは，~HTTP10~serverとの`持続的~接続$を可能化できるが、それを利用する~clientは， “~hung” した要請（それは，［
~clientが~headerの送信を停止する~OUGHT
］ことを指示する）について接続を監視する必要が~~生じる
— したがって、~proxyを利用~中の~clientは，この仕組みを まったく利用しない~OUGHT。
◎
Clients are also encouraged to consider the use of Connection: keep-alive in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for "hung" requests (which indicate that the client ought stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.
</p>

			</section>
			<section id="introduction.of.transfer-encoding">
<h4 title="Introduction of Transfer-Encoding">C.1.3. `Transfer-Encoding^h の導入</h4>

<p>
~HTTP11は、`転送~符号法$用に `Transfer-Encoding$h ~headerを導入する。
それは、［
~MIME準拠~protocol越しに~HTTP~messageを回送する
］に先立って復号される必要がある。
◎
HTTP/1.1 introduces the Transfer-Encoding header field (Section 6.1). Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.
</p>

			</section>
		</section>
		<section id="changes.from.rfc.7230">
<h3 title="Changes from RFC 7230">C.2. RFC 7230 からの変更点</h3>

<p>
~HTTPの［
設計~目標／
歴史／
~architecture／
適合性~判定基準／
~protocol~version法／
~URI／
~message~route法／
~header値
］を導入している ほとんどの節は、 `Semantics$r に移動された。
この文書は、~HTTP11に特有な［
~message法~構文と接続~管理
］用の要件に抑制された。
◎
Most of the sections introducing HTTP's design goals, history, architecture, conformance criteria, protocol versioning, URIs, message routing, and header fields have been moved to [Semantics]. This document has been reduced to just the messaging syntax and connection management requirements specific to HTTP/1.1.
</p>

<p>
`~trailer~header$の意味論は、今や，`~chunked$符号化法が指定するものを超える。
~chunked用の復号~algo（ `7.1.3$sec ）は、~trailer~headerを`~header節$とは別々に［
格納する／回送する
］ことを奨励するため，更新された
— ~trailer~headerを~header節の中へ併合するのが許容されるのは、［
対応ng~headerの定義において，併合する方法が定義されていて, そうすることが許可されている
］ことを受信者が知っている場合に限られ、他の場合は併合することなく破棄するように。
`trailer part^en は、今や `trailer section^en （`~trailer節$）と呼ばれる
— より`~header節$と一貫するよう, かつ `body part^en とは別個になるよう。
◎
Trailer field semantics now transcend the specifics of chunked encoding. The decoding algorithm for chunked (Section 7.1.3) has been updated to encourage storage/forwarding of trailer fields separately from the header section, to only allow merging into the header section if the recipient knows the corresponding field definition permits and defines how to merge, and otherwise to discard the trailer fields instead of merging. The trailer part is now called the trailer section to be more consistent with the header section and more distinct from a body part (Section 7.1.2).
</p>

<p>
`~chunk拡張$用の~ABNFにおいて、［
"`;^c" ／ "`=^c"
］の前後における（不良）`空白$を導入し直した。
その空白は `RFC7230$r において除去されたが、その変更は既存の実装を壊すことが見出されたので（ `Err4667$r を見よ）。
◎
In the ABNF for chunked extensions, re-introduced (bad) whitespace around ";" and "=" (Section 7.1.1). Whitespace was removed in [RFC7230], but that change was found to break existing implementations (see [Err4667]).
</p>

<p>
`TE$h ~headerにおける `rank$p の利用と競合するのを避けるため、
"`q^c" と呼ばれる転送~符号法~parameterは許容しないようにした（ `7.3$sec ）。
◎
Disallowed transfer coding parameters called "q" in order to avoid conflicts with the use of ranks in the TE header field (Section 7.3).
</p>

		</section>
	</section>
	<section id="change.log">
<h2 title="Change Log">付録 D. 変更~log</h2>

<p>
この節は、 RFC として発行する前に除去されることになる。
【以下、この節は未訳。】
◎
This section is to be removed before publishing as an RFC.
</p>

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
`Semantics/謝辞$sec を見よ。
◎
See Appendix "Acknowledgments" of [Semantics].
</p>
	</section>
	<section id="rfc.authors">
<h2 title="Authors' Addresses">著作者の~address</h2>

<p>
`Semantics$r のそれと同じ
【なので、この訳では省略する。】
</p>

	</section>
</main></div>

