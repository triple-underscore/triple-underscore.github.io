<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP — Digest Fields（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<style>
figure > pre {
	margin: 0;
}
</style>
<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Digest Fields
spec_date:2021-10-21
trans_update:2021-10-22
source_checked:210915
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html
abbr_url:HTTPdigest
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2021-06-15

●●class_map

●●tag_map

●●original_id_map

references:
normative:
informative:

●●mdn_urls

●●link_map

h.Digest:#digest
h.Want-Digest:#want-fields
h.Want-Content-Digest:#want-fields
h.Content-Digest:#content-digest

h.Content-MD5:~RFCx/rfc2616#section-14.15

p.Digest:#p.Digest
p.Want-Digest:#p.Want-Digest
p.Content-Digest:#p.Content-Digest
p.Want-Content-Digest:#p.Want-Content-Digest
p.digest-algorithm:#p.digest-algorithm
p.representation-data-digest:#p.representation-data-digest
p.content-digest:#p.content-digest
p.want-digest-value:#p.want-digest-value
p.qvalue:~HTTPsem#p.qvalue

c.sha-256:#digest-sha-256
	i.SHA-256:#digest-sha-256
c.sha-512:#digest-sha-512
	i.SHA-512:#digest-sha-512
c.md5:#digest-md5
	i.MD5:#digest-md5
c.sha:#digest-sha
	i.SHA:#digest-sha
i.SHA-1:#digest-sha
c.unixsum:#digest-unixsum
	i.UNIXsum:#digest-unixsum
c.unixcksum:#digest-unixcksum
	i.UNIXcksum:#digest-unixcksum
c.id-sha-512:#digest-id-sha-512
c.id-sha-256:#digest-id-sha-256
c.adler32:#digest-adler32
i.ADLER32:#digest-adler32
c.crc32c:#digest-crc32c
i.CRC32c:#digest-crc32c
c.contentMD5:#digest-contentMD5


	表現~digest:#representation-digest

形式変換ng~proxy:~HTTPsem#transforming-proxy
有構造~field:~HEADER-STRUCTURE#structured~field

RFC7231/B:~RFC7231#appendix-B
RFC4960/B:~RFCx/rfc4960#appendix-B

cite.~HTTP~digest~algo値~registry:~IANA-a/http-dig-alg/

	●§
1:#introduction
1.1:#document-structure
1.2:#concept-overview
1.3:#replacing-rfc-3230
1.4:#notational-conventions
2:#representation-digest
3:#digest
4:#content-digest
5:#want-fields
6:#algorithms
7:#state-changing-requests
7.1:#digest-and-content-location
8:#security-considerations
8.1:#digest-does-not-protect-the-full-http-message
8.2:#digest-for-end-to-end-integrity
8.3:#usage-in-signatures
8.4:#usage-in-trailer-fields
8.5:#usage-with-encryption
8.6:#algorithm-agility
8.7:#duplicate-digest-algorithm-in-field-value
8.8:#resource-exhaustion
8:#iana-considerations
9.1:#iana-digest-algorithm-registry
9.2:#iana-contentMD5
9.3:#changes-compared-to-rfc3230
9.4:#changes-compared-to-rfc5843
9.5:#want-digest-field-registration
9.6:#digest-field-registration
9.7:#want-content-digest-field-registration
9.8:#content-digest-field-registration

A:#resource-representation
B:#examples-unsolicited
B.1:#example-full-representation
B.2:#server-returns-no-representation-data
B.3:#server-returns-partial-representation-data
B.4:#client-and-server-provide-full-representation-data
B.5:#client-provides-full-representation-data-server-provides-no-representation-data
B.6:#client-and-server-provide-full-representation-data-client-uses-id-sha-256
B.7:#post-not-request-uri
B.8:#post-referencing-status
B.9:#digest-with-patch
B.10:#error-responses
B.11:#use-with-trailer-fields-and-transfer-coding
C:#examples-solicited
C.1:#server-selects-clients-least-preferred-algorithm
C.2:#ex-server-selects-unsupported-algorithm
C.3:#server-does-not-support-client-algorithm-and-returns-an-error
D:#changes-from-rfc3230
D.1:#deprecate-contentMD5
D.2:#obsolete-parameters

	:#faq
	:#acknowledgements
	:#code-samples
	:#changes
	:#authors-addresses

	SEMANTICS/3.2:~HTTPinfra#representations
SEMANTICS/~field行と結合-済みな~field値:~HTTPinfra#field.lines
	SEMANTICS/5.2:~HTTPinfra#field.lines
SEMANTICS/~list~ABNF拡張:~HTTPinfra#abnf.extension
	SEMANTICS/6.4:~HTTPinfra#content
SEMANTICS/内容の識別-法:~HTTPinfra#identifying.content
SEMANTICS/~trailerの利用に対する制限:~HTTPinfra#trailers.limitations
SEMANTICS/~trailerの処理:~HTTPinfra#trailers.processing
SEMANTICS/~messageの形式変換:~HTTPsem#message.transformations
	SEMANTICS/8.4.1:~HTTPsem#content.codings
	SEMANTICS/8.1:~HTTPsem#representation.data
	SEMANTICS/8.7:~HTTPsem#field.content-location
SEMANTICS/品質~値:~HTTPsem#quality.values
	SEMANTICS/14.2:~HTTPsem#field.range

●●words_table1

●●words_table

	●略語
UNIX:
iSCSI:
SCTP:
MICE:
python3:

	●digest
base64:
SHA:
CRC:
checksum::::チェックサム
digital::::デジタル

	^i:Base64
	^i:Brotli
	^i:SHA-256
	^i:SHA-512
	^i:MD5
	^i:SHA-1
	^i:CRC32c
	^i:ADLER32
	^i:MICE
	^cite:ZLIB Compressed Data Format

	●構文
不正形な:malformedな:不正な形の
印字不能:non-printable:~
数字:digit:~
	数字~列:digit string
	数字~列:decimal-digit string
字下げ:indentation:~
単語:word:~
	digest-algorithm^p:Digest-algorithm

	文字大小-法:casing
	小文字:lower-case
	引用符で括られ:quote
	〜形式にされ:formatted
	形式~化:formatting
	頭部:leading
	quoted-string^p:quoted string
	字下げ:2 spaced of leading indentation
	重複な~tokenを除去する:de-duplication
	32 ~bit:32-bit
	16 ~bit:16-bit
	急ぐ:eager

	●処理
弄る:mangleする:~
剥がさ:stripさ:~
算出法:computation:~
診断:diagnosis:~

	通過する:pass across
	手渡す:handing off

	●保安
暗号用:cryptographic::~
hamming::::ハミング
破損:corruption:~
衝突:collision:~
操る:steerする:~
改ざん:tampering:~
晒し:exposeし:~
敵対者:adversary:~
	敵対者に~~晒され得る:potentially adversarial
真正性:authenticity::~
署名-:sign:~

	暗号化されてない:unencrypted
	抗する:against
	巡回冗長性:cyclic redundancy::~
	非~secure:insecure
	~secureでなくなる:insecure
	~secureでない:insecure

	●仕様
仕事:job:~
順応-:adapt:~
刷新-:refresh:~
	能が無い:inability
直面-:face:~
動作者:actor:~
概略的:brief:~
単直:straightforward:簡単
請求-:solicite:~
	請求されない:unsolicited
証明:proof:~
浪費-:waste:~
枯渇:exhaustion:~
包括的:comprehensive:~
簡潔:compact:~
発展-:evolve:~
	発展-度合いが様々な:population of 〜 with different evolving
相:phase:~
合法的:legitimate:~
偉業:great work:~
即応性:agility::~
廃用d:obsoleted:廃用
移行:transition:~
	から移行-:transitioning away
鑑定:appraisal:~
特質:properties:~
束ねら:tieさ:~
合格-:pass:~
欠陥:fault:~
倣う:alignする:~
尊重-:respect:~
発生-:arise:~
構成:structure:~
	構成:structured
助け:help:~
関心事:interesting:~
	興味深い:interesting
固定的:fixed:~
委譲-:delegate:~

	取って代わられ:supersede
	至らす:cause
	併せて:in conjunction with
	他の場面でも:Other places
	〜ないと見込まれる:less likely
	基づくこと:basing
	一方では:on one hand
	十分:enough
	謝意:thank
	書き直す:rewrite
	委ねられ:left as
	予め除外する:preclude
	大部分:vast majority
	欲されない:undesired
	問わない:agnostic
	選ぶ:choose
	類の:sort of
	発生-:arose
	はず:should
	対照:contrast
	十分~過ぎ:more than enough
	いずれにせよ:anyway
	最終的:eventual
	とても:very
	であったとしても:would have been 〜 too
	~~説明する:help illustrate
	価値はある:valuable
	価値ある:valuable
	良好に:nicely
	できなくする:prevent
	してもかまわない:free to
	はい:yes
	考えて:think
	考え:thought
	試験的^i:"experimental"
	廃用d^i:"obsoleted"
	~~能性:potential
	高い:high
	勧める:advise
	とは言え、:Endpoints are advised that
	交わり:intersection
	より低:lower
	選ぶ:chooseする
	偶然:accidentally
	〜できなくなる:prevents
	〜群:set of
	一覧:table
	~~最新な:state of the art
	^en:Specification Required
	参照:Reference
	賢い:smart
	質問をして:asking 〜 question
	~~偶然:accidentally
	~~義務はない:not obliged to 
	別法として:alternatively

	●未分類
消費:consumption::~
返信-:reply:~
再生器:player::~::プレイヤー
patch::::パッチ
増分的:incremental:~
	~stream途中の:mid-stream
計算l:computational:計算
差分:delta:~

	改行:-
	継ぎ合わせる:piecing together
	~~伝送の途上:in flight
	この:the present
	添える:attach
	切り離す:decouple

	●語形
	^r:Single UNIX Specification, version 2
	^en:Internet Assigned Numbers Authority
	^i:identity
	digest-algorithm^p:Digest-algorithm
	`~digest認証^cite:Digest Authentication
	~HTTP~field名~registry^cite:"Hypertext Transfer Protocol (HTTP) Field Name Registry"
	表現~digest:Representation Digest
	表現~data:representation-data
	範囲~要請:Range Request
	~field値:field-value
	~digest値:digest-value
	~MIME型:media-type

	●言い換え
中継点:hop::~
	いくつかの中継点を経る:across multiple hops
	~target~URI:effective request URI
	最も選好しない:Least Preferred
	場合に備える:should
	立場:positioned
	能力はない:not capable of
	ある種の:certain kinds of
	〜からの変更点:Changes Compared to
	~transport層:transport-layer
	~message法:messaging
	予め処理する:pre-process
	内容~符号法:content-coding
	内容:payload
	内容:body
	有構造~field:Structured Fields
	~parameter化:parameterized
	参照-先の:referenced
	~base64に符号化された:base64-encoded
	符号化されていない:unencoded
	〜を含めて:inclusive
	それらに:in this set
	とは異なる:different compared to
	よくある質問:FAQ
	〜で呈示される場合もある:For presentation purposes, ...
	行l長さの~~都合により...:fit completely within the line-length limits...
	〜形式にされ:formatted
	受信者:receiver
	識別するもの:identification of
	~~分類され:group
	~trailer節:trailers
	段階:stage
	-:finally
	この事例では:accidentally
	内容は伴わない:empty content

	●指示
	一体として:in whole
	全体:the whole
	だけ:alone
	他所における:at rest
	各部:parts
	各部ごと:in part
	何も:anything
	回数:number of
	全体を通して:throughout
	0 でない:non-zero
	一部が:partly
	のうち いくつを:all, some, or none of

●●ref_data
SEMANTICS=副          ~/http-semantics-ja.html

●●ref_key_map
PATCH:RFC5789
IDIETFHTTPBISHEADERSTRUCTURE:RFC8941

●●ref_normative

[CMU-836068]
    Carnagie Mellon University, Software Engineering Institute, "MD5 Vulnerable to collision attacks", 31 December 2008
    URL: https://www.kb.cert.org/vuls/id/836068/
[IACR-2020-014]
    Leurent, G. and T. Peyrin, "SHA-1 is a Shambles", 5 January 2020
    URL: https://eprint.iacr.org/2020/014.pdf
[NIST800-32]
    National Institute of Standards and Technology, U.S. Department of Commerce, "Introduction to Public Key Technology and the Federal PKI Infrastructure", February 2001
    URL: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-32.pdf
[RFC1321]
    Rivest, R., "The MD5 Message-Digest Algorithm", ~RFC1321, April 1992
[RFC1950]
    Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format Specification version 3.3", ~RFC1950, May 1996
[RFC2119]
    Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, ~RFC2119, March 1997
[RFC3174]
    Eastlake 3rd, D. and P. Jones, "US Secure Hash Algorithm 1 (SHA1)", ~RFC3174, September 2001
[RFC3230]
    Mogul, J. and A. Van Hoff, "Instance Digests in HTTP", ~RFC3230, January 2002
[RFC4648]
    Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", ~RFC4648, October 2006
[RFC4960]
    Stewart, R., Ed., "Stream Control Transmission Protocol", ~RFC4960, September 2007
[RFC5234]
    Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax Specifications: ABNF", STD 68, ~RFC5234, January 2008
[RFC5843]
    Bryan, A., "Additional Hash Algorithms for HTTP Instance Digests", ~RFC5843, April 2010
[RFC6234]
    Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)", ~RFC6234, May 2011
[RFC7405]
    Kyzivat, P., "Case-Sensitive String Support in ABNF", ~RFC7405, December 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, ~RFC8126, June 2017
[RFC8174]
    Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, ~RFC8174, May 2017
[SEMANTICS]
    Fielding, R. T., Nottingham, M., and J. Reschke, "HTTP Semantics", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics
[UNIX]
    The Open Group, "The Single UNIX Specification, Version 2 - 6 Vol Set for UNIX 98", February 1997.

●●ref_informative

[HTTP11]
    Fielding, R. T., Nottingham, M., and J. Reschke, "HTTP/1.1", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-messaging
[I-D.ietf-httpbis-header-structure]
    Nottingham, M. and P. Kamp, "Structured Field Values for HTTP", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-structure
[I-D.thomson-http-mice]
    Thomson, M. and J. Yasskin, "Merkle Integrity Content Encoding", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-thomson-http-mice
[NO-MD5]
    Turner, S. and L. Chen, "Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms", ~RFC6151, March 2011
[NO-SHA1]
    Polk, T., Chen, L., Turner, S., and P. Hoffman, "Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms", ~RFC6194, March 2011
[PATCH]
    Dusseault, L. and J. Snell, "PATCH Method for HTTP", ~RFC5789, March 2010
[RFC2818]
    Rescorla, E., "HTTP Over TLS", ~RFC2818, May 2000
[RFC7231]
    Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content", ~RFC7231, June 2014
[RFC7396]
    Hoffman, P. and J. Snell, "JSON Merge Patch", ~RFC7396, October 2014
[RFC7696]
    Housley, R., "Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms", BCP 201, ~RFC7696, November 2015
[RFC7807]
    Nottingham, M. and E. Wilde, "Problem Details for HTTP APIs", ~RFC7807, March 2016
[RFC8188]
    Thomson, M., "Encrypted Content-Encoding for HTTP", ~RFC8188, June 2017


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として発行された，
<a href="~SPEC_URL">Digest Fields</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

発行者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	<a href="https://datatracker.ietf.org/doc/html/rfc3230">3230</a> （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	Roberto Polli, Team Digitale, Italian Government, Italy, Email: <a href="mailto:robipolli@gmail.com">robipolli@gmail.com</a>
	Lucas Pardue, Cloudflare, Email: <a href="mailto:lucaspardue.24.7@gmail.com">lucaspardue.24.7@gmail.com</a>

課題追跡
	https://github.com/httpwg/http-extensions/labels/digest-headers
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-digest-headers.md

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
HTTP WG メーリングリスト
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)
現在の Internet-Drafts のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>


<header>
	<hgroup>
<h1 title="Digest Fields">HTTP — Digest フィールド</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この文書は、
完全性~checksumを~supportする~HTTP~fieldとして，次に挙げるものを定義する：
◎
This document defines HTTP fields that support integrity checksums.＼
</p>
<ul>
	<li>
`Digest$h ~fieldは、
~HTTP`表現$の完全性~用に利用できる。
◎
The Digest field can be used for the integrity of HTTP representations.＼
</li>
	<li>
`Content-Digest$h ~fieldは、
~HTTP~message`内容$の完全性~用に利用できる。
◎
The Content-Digest field can be used for the integrity of HTTP message content.＼
</li>
	<li>
［
`Want-Digest$h ／ `Want-Content-Digest$h
］~fieldは、`送信者$は［
`Digest$h ／ `Content-Digest$h
］を受信したいと欲することを指示するために利用できる。
◎
Want-Digest and Want-Content-Digest can be used to indicate a sender's desire to receive integrity fields respectively.
</li>
</ul>

<p>
この文書は、~RFC 3230 を廃用にする。
◎
This document obsoletes RFC 3230.
</p>

	</section>
	<section>
<h2 title="Note to Readers">読者~向け注記</h2>

<p class="trans-note">【
この節の内容は、冒頭の仕様~metadataに移譲。
】</p>

<!-- 
RFC EDITOR: please remove this section before publication

Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at https://lists.w3.org/Archives/Public/ietf-http-wg/.

The source code and issues list for this draft can be found at https://github.com/httpwg/http-extensions.
-->

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>／冒頭の仕様~metadata
に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTPは、`表現$の完全性を保護するための手段は定義しない。
~HTTP~messageが端点~間で転送されるとき、
当の~protocolは，何らかの完全性~保護を供するために，より低~層を成す特能
— 一例として，~TCP~checksumや~TLS~record —
を用立てることを選ぶかもしれない
`RFC2818$r 。
◎
HTTP does not define a means to protect the integrity of representations. When HTTP messages are transferred between endpoints, the protocol might choose to make use of features of the lower layer in order to provide some integrity protection; for instance, TCP checksums or TLS records [RFC2818].
</p>

<p>
この文書は、~HTTP用の~digest完全性の仕組みとして，次に挙げる 2 つを定義する
⇒＃
表現~data完全性は、`表現~data$に対し動作する。
内容~digest完全性は、伝達される`内容$に対し動作する。
◎
This document defines two digest integrity mechanisms for HTTP. First, representation data integrity, which acts on representation data (Section 3.2 of [SEMANTICS]). Second, content digest integrity, which acts on conveyed content (Section 6.4 of [SEMANTICS]).＼
</p>

<p>
どちらの仕組みも：
◎
↓</p>
<ul>
	<li>
~transport完全性とは独立に運用して，［
~programming~error／
~~伝送の途上や他所における~dataの破損
］を検出する~~能性（ `potential^en ）を提供する。
◎
Both mechanisms operate independent of transport integrity, offering the potential to detect programming errors and corruption of data in flight or at rest.＼
</li>
	<li>
いくつかの中継点（ `hop^en ）を経るときでも，端点間における完全性の保証を供するために利用できる
— それは、`資源$が いくつかの［
中継点／~system境界
］を経て転送されるとき，欠陥~診断を援助し得るものになる。
◎
They can be used across multiple hops in order to provide end-to-end integrity guarantees, which can aid fault diagnosis when resources are transferred across hops and system boundaries.＼
</li>
	<li>
異なる~HTTP接続を利用して~fetchされている`資源$を構築し直すとき，その完全性を検証するために利用できる。
◎
Finally, they can be used to validate integrity when reconstructing a resource fetched using different HTTP connections.
</li>
</ul>

<p>
この文書は `RFC3230$r を廃用にする。
◎
This document obsoletes [RFC3230].
</p>

		<section id="document-structure">
<h3 title="Document Structure">1.1. この文書の構成</h3>

<p>
この文書の構成は：
◎
This document is structured as follows:
</p>
<ul>
	<li>
`2$sec では、
表現~digestに関係する概念を述べる。
◎
Section 2 describes concepts related to representation digests,
</li>
	<li>
`3$sec では、
`Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 3 defines the Digest request and response header and trailer field,
</li>
	<li>
`4$sec では、
`Content-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 4 defines the Content-Digest request and response header and trailer field,
</li>
	<li>
`5$sec では、［
`Want-Digest$h, `Want-Content-Digest$h
］【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 5 defines the Want-Digest and Want-Content-Digest request and response header and trailer field,
</li>
	<li>
`6$sec, `D.1$sec では、
各種~algo, および それらの `Digest^h との関係を述べる。
◎
Section 6 and Appendix D.1 describe algorithms and their relation to Digest,
</li>
	<li>
`7$sec では、
表現~digestの算出-法の詳細を与える。
◎
Section 7 details computing representation digests,
</li>
	<li>
`D.2$sec では、
~digest~field~parameterを廃用にする。
◎
Appendix D.2 obsoletes Digest field parameters, and
</li>
	<li>
［
`B$sec ／ `C$sec
］では、［
`Digest$h ／ `Want-Digest$h
］を利用する例を供する。
◎
Appendix B and Appendix C provide examples of using Digest and Want-Digest.
</li>
</ul>

		</section>
		<section id="concept-overview">
<h3 title="Concept Overview">1.2. 概念の概観</h3>

<p>
この文書は `Digest$h ~fieldを定義する。
それは、［
要請, 応答
］どちらにも, ［
`~header節$, `~trailer節$
］どちらにも内包し得る（ `3$sec を見よ）。
高い~levelからは、その値は，
`選定された表現$の`表現~data$【！選定された表現~data】から算出された~checksumを包含する
— それは、`受信者$が完全性を検証するために利用できる。
`Digest$h を`選定された表現$に基づくようにすることは、
次に挙げる利用事例に それを適用することを単直にする：
◎
This document defines the Digest request and response header and trailer field; see Section 3. At a high level, the value contains a checksum, computed over selected representation data (Section 3.2 of [SEMANTICS]),＼
that the recipient can use to validate integrity.＼
Basing Digest on the selected representation makes it straightforward to apply it to use-cases where＼
</p>
<ul>
	<li>
転送される~dataが、表現と見なされるものに何らかの類の操作を要求する所
◎
the transferred data requires some sort of manipulation to be considered a representation＼
</li>
	<li>
`範囲~要請$ `SEMANTICS$r【！§ 14.2】など，
`資源$の部分的な表現を伝達する所
◎
or conveys a partial representation of a resource, such as Range Requests (see Section 14.2 of [SEMANTICS]).
</li>
</ul>

<p>
`内容$を成す~byte列の単純な~checksumが要求される利用事例を~supportするため、
この文書は，
`Content-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを導入する。
◎
To support use-cases where a simple checksum of the content bytes is required, this document introduces the Content-Digest request and response header and trailer field; see Section 4.
</p>

<p>
［
`Digest$h ／ `Content-Digest$h
］~fieldは、
~algo即応性【 `8.6$sec 】を~supportする。
［
`Want-Digest$h ／ `Want-Content-Digest$h
］~fieldは、［
`Digest$h ／ `Content-Digest$h
］に対する［
関心と~algoの選好
］を表出することを端点に許容する。
◎
Digest and Content-Digest support algorithm agility. The Want-Digest and Want-Content-Digest fields allows endpoints to express interest in Digest and Content-Digest respectively, and preference of algorithms in either.
</p>

<p>
`Digest$h ~fieldの計算は、［
`Content-Encoding$h, `Content-Type$h
］~headerに束ねられる。
したがって、所与の`資源$が~HTTPで転送されるとき，複数個の異なる~checksum値があり得る。
［
`内容~符号法$ `SEMANTICS$r を伴わない`表現$
］の単純な~checksumを交換することを両~端点【！主体】に許容するため、
`digest-algorithm$p には 2 つの値（ "`id-sha-256$c", "`id-sha-512$c" ）が追加された。
◎
Digest field calculations are tied to the Content-Encoding and Content-Type header fields. Therefore, a given resource may have multiple different checksum values when transferred with HTTP. To allow both parties to exchange a simple checksum with no content codings (see Section 8.4.1 of [SEMANTICS]), two more digest-algorithms are added ("id-sha-256" and "id-sha-512").
</p>

<p>
`Digest$h ~fieldは［
`~message$【全体】／`~field$たち
］の完全性は供さない。
しかしながら，それは、
~HTTP交換に欲される各部を［
一体として／各部ごとに
］保護するためとして，［
~metadataを保護する他の仕組み
］を成す各~相
— ~digital署名など —
と組合できる。
◎
Digest fields do not provide integrity for HTTP messages or fields. However, they can be combined with other mechanisms that protect metadata, such as digital signatures, in order to protect the phases of an HTTP exchange in whole or in part.
</p>

<p>
この仕様は、［
認証／権限付与／~privacy
］用の手段は定義しない。
◎
This specification does not define means for authentication, authorization or privacy.
</p>

		</section>
		<section id="replacing-rfc-3230">
<h3 title="Replacing RFC 3230">1.3. ~RFC 3230 を置換する</h3>

<p>
歴史的に， `Content-MD5$h ~headerは ~HTTP完全性の仕組みを供していたが、
`部分的な応答$に対する取扱いが一貫でないことに因り，
~HTTP11は それを廃用にした（ `RFC7231/B$sec ）。
`RFC3230$r は、
`Content-MD5$h に伴われる課題に取組む助けとして，
“~instance~digest” の概念および，もっと柔軟な完全性~schemeを定義した
— そのためとして、まず［
`Digest$h, `Want-Digest$h
］~fieldを導入した。
`RFC3230$r が発行されて以来、~HTTPの各種用語は発展した。
“~instance” の概念は、`選定される表現$に取って代わられた。
◎
Historically, the Content-MD5 header field provided an HTTP integrity mechanism but HTTP/1.1 ([RFC7231], Appendix B) obsoleted it due to inconsistent handling of partial responses. [RFC3230] defined the concept of "instance" digests and a more flexible integrity scheme to help address issues with Content-MD5. It first introduced the Digest and Want-Digest fields. HTTP terminology has evolved since [RFC3230] was published. The concept of "instance" has been superseded by selected representation.
</p>

<p>
この文書は、 `RFC3230$r を置換する。
［
`Digest$h ／ `Want-Digest$h
］~fieldの定義は、
`SEMANTICS$r による［
用語, 表記規約
］に倣うよう更新された。
変更点は、既存の実装と意味論的に互換になることが意図されるが，次に注意：
◎
This document replaces [RFC3230]. The Digest and Want-Digest field definitions are updated to align with the terms and notational conventions in [SEMANTICS]. Changes are intended to be semantically compatible with existing implementations but note that＼
</p>
<ul>
	<li>
`Content-MD5$h の折衝は、
非推奨にされた（ `D.1$sec ）。
それは `Want-Content-Digest$h を介する `Content-Digest$h の折衝により置換された。
◎
negotiation of Content-MD5 is deprecated Appendix D.1 and has been replaced by Content-Digest negotiation via Want-Content-Digest.＼
</li>
	<li>
`Digest$h ~field用の~parameterは、
廃用にされた（ `D.2$sec ）。
◎
Digest field parameters are obsoleted Appendix D.2＼
</li>
	<li>
~algo一覧【 `6$sec 】は、
現在の~~最新な状態を反映するよう更新された。
◎
and the algorithm table has been updated to reflect the current state of the art.
</li>
</ul>

		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.4. 表記規約</h3>

<p>
~keyword "MUST" …
【以下、この段落の内容（ `RFC2119$r ）は<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
この文書は、
`RFC5234$r に定義され，
`RFC7405$r にて更新された~ABNFを次に挙げるものとともに利用する
⇒＃
`SEMANTICS/~list~ABNF拡張$sec にて定義される “#規則”,
`SEMANTICS/品質~値$r にて定義される `qvalue$p
◎
This document uses the Augmented BNF defined in [RFC5234] and updated by [RFC7405] along with the "#rule" extension defined in Section 5.6.1 of [SEMANTICS] and the "qvalue" rule defined in Section 12.4.2 of [SEMANTICS].
</p>

<p>
この文書における次に挙げる用語は、
`SEMANTICS$r に述べられるとおりに解釈すること
⇒＃
`表現$,
`選定される表現$,
`表現~data$,
`表現~metadata$,
`内容$
◎
The definitions "representation", "selected representation", "representation data", "representation metadata", and "content" in this document are to be interpreted as described in [SEMANTICS].
</p>

<p>
~algo名は、
それらを定義する文書に利用される文字大小-法を尊重する
（例： `SHA-1$i, `CRC32c$i ）。
一方で，
`digest-algorithm$p を成す~tokenは、
引用符で括られる
（例： "`sha$c", "`crc32c$c" ）。
◎
Algorithm names respect the casing used in their definition document (e.g. SHA-1, CRC32c) whereas digest-algorithm tokens are quoted (e.g. "sha", "crc32c").
</p>

<p class="trans-note">【
原文にて大文字で記された “`Digest^en” は、
`Digest$h ~fieldを指すことも，
“この仕様が定義する~digest（の値／仕組み）”
を意味する所もある。
この 2 つを両義的に表す（明確に線引きできない）所も多々あるので
（加えて，原文の~markupも一貫でない）、
この訳では一律に`~field$用の~styleで呈示している。
】</p>
【！（英文の慣習により、節の~title内や文の先頭にある `Digest^en は大文字で記されるが，中には小文字による `digest^en を表すものもあるかもしれない。）】

		</section>
	</section>
	<section id="representation-digest">
<h2 title="Representation Digest">2. 表現~digest</h2>

<p>
表現~digestは、~HTTP`資源$用の，ある完全性の仕組みを成す
— それは、【~messageの】`内容$とは独立に計算される~checksumを利用する。
それは、`表現~data$を利用する
— `表現~data$は、`内容$内に［
全部的／部分的
］に包含されることも，まったく包含されないこともある。
◎
The representation digest is an integrity mechanism for HTTP resources which uses a checksum that is calculated independently of the content (see Section 6.4 of [SEMANTICS]). It uses the representation data (see Section 8.1 of [SEMANTICS]), that can be fully or partially contained in the content, or not contained at all.
</p>

<p>
これは、~messageが有する~HTTP意味論による効果を織り込む。
例えば、`内容$は［
`範囲~要請$や `HEAD$m などの~methodにより影響され得る
］ことに加え、
`内容$が “伝送路~上” に転送される仕方は，他の形式変換に依存する
（例： ~HTTP11用の`転送~符号法$
— `HTTP11$r § `Transfer-Encoding$h を見よ）。
そのようなものが `Digest$h にどう影響するか~~説明するため、
`A$sec にて，いくつかの例が供される。
◎
This takes into account the effect of the HTTP semantics on the messages; for example, the content can be affected by Range Requests or methods such as HEAD, while the way the content is transferred "on the wire" is dependent on other transformations (e.g. transfer codings for HTTP/1.1 - see Section 6.1 of [HTTP11]). To help illustrate how such things affect Digest, several examples are provided in Appendix A.
</p>

<p>
表現~digest（ `representation-data-digest$p ）は、次の 2 つからなる：
◎
A representation digest consists of＼
</p>
<ul>
	<li>
次に対し算出された~checksumを成す値
⇒
`SEMANTICS/内容の識別-法$secに則って識別される`資源$に対し`選定された表現$の`表現~data$【！選定された表現~data】全体
◎
the value of a checksum computed on the entire selected representation data (see Section 8.1 of [SEMANTICS]) of a resource identified according to Section 6.4.2 of [SEMANTICS]＼
</li>
	<li>
前項の算出に利用された~algoを指示するもの
◎
together with an indication of the algorithm used:
</li>
</ul>

<pre class="bnf">
`representation-data-digest@p
    = `digest-algorithm$p "=" &lt;<span class="comment">
符号化された~digest出力
◎
encoded digest output
</span>&gt;
</pre>

<p>
~messageに`表現~data$が無いときでも、次はアリである
⇒
空~文字列から表現~digestを算出して，送信された表現~dataは無いことを表明する
（ `8.3$sec を見よ）
◎
When a message has no representation data it is still possible to assert that no representation data was sent computing the representation digest on an empty string (see Section 8.3).
</p>

<p>
~checksumは、
`~HTTP~digest~algo値~registry$cite 
に挙げられる各 `digest-algorithm$p （ `6$sec を見よ）のうち 1 つを利用して算出され，
それに結付けられる形式に符号化される。
◎
The checksum is computed using one of the digest-algorithms listed in the HTTP Digest Algorithm Values Registry (see Section 6) and then encoded in the associated format.
</p>

	</section>
	<section id="digest">
<h2 title="The Digest Field">3. `Digest^h ~field</h2>

<p>
`Digest^h ~fieldは、
`2$sec にて定義されるとおり，
~commaで分離された 1 個以上の表現~digest値からなる~listを包含する。
それは、要請, 応答どちらにも利用され得る。
◎
The Digest field contains a comma-separated list of one or more representation digest values as defined in Section 2. It can be used in both requests and responses.
</p>

<pre class="bnf">
`Digest@p
    = 1#`representation-data-digest$p
</pre>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm
                   AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew==
</pre>
</div>

<p>
`Digest^h ~fieldは、
複数個の `representation-data-digest$p 値を包含してもヨイ。
例えば`~server$は、
能力の発展-度合いが様々な`~client$を~supportするために，
複数の異なる~algoを利用して `representation-data-digest$p 値を供することもある。
これは特に、
弱い~algoから移行する必要が発生した場合に備えるための~supportにおいて有用になる。
（ `8.6$sec を見よ）。
◎
A Digest field MAY contain multiple representation-data-digest values. For example, a server may provide representation-data-digest values using different algorithms, allowing it to support a population of clients with different evolving capabilities; this is particularly useful in support of transitioning away from weaker algorithms should the need arise (see Section 8.6).
</p>

<div class="example">

<pre class="lang-http">
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=,
        id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
</pre>
</div>

<p>
`受信者$は、
`Digest^h の`~field値$を成す各 `representation-data-digest$p に対し，どれを無視してもヨイ。
すなわち，`受信者$には、
受信した `representation-data-digest$p すべてを検証yせずに，
一部の `digest-algorithm$p に限って検証~用に利用することも許容される。
◎
A recipient MAY ignore any or all of the representation-data-digests in a Digest field. This allows the recipient to choose which digest-algorithm(s) to use for validation instead of verifying every received representation-data-digest.
</p>

<p>
`送信者$は、
`受信者$が所与の `digest-algorithm$p を［
~supportする／無視することになる
］かどうか知ることなく，
それを利用している `representation-data-digest$p を送信してもヨイ。
◎
A sender MAY send a representation-data-digest using a digest-algorithm without knowing whether the recipient supports the digest-algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Digest^h は`~trailer節$にも送信できる。
この事例では、
`Digest^h は`~header節$の中へ併合してもヨイ
— `SEMANTICS/~trailerの利用に対する制限$secを見よ。
◎
Digest can be sent in a trailer section. In this case, Digest MAY be merged into the header section; see Section 6.5.1 of [SEMANTICS].
</p>

<p>
増分的な `digest-algorithm$p が利用されるときは，［
`送信者$／`受信者$【！receiver】
］は、`内容$が~streamされている間に~digest値を動的に算出できる。
◎
When an incremental digest-algorithm is used, the sender and the receiver can dynamically compute the digest value while streaming the content.
</p>

<p>
［
`表現~metadata$／`内容$の`形式変換$／~HTTP~method
］による `Digest^h への影響iを示す，一連の例（包括的ではない）は、
`B$sec, `C$sec
にて供される。
◎
A non-comprehensive set of examples showing the impacts of representation metadata, payload transformations and HTTP methods on Digest is provided in Appendix B and Appendix C.
</p>

	</section>
	<section id="content-digest">
<h2 title="The Content-Digest Field">4. `Content-Digest^h ~field</h2>

<p>
`Content-Digest^h ~fieldは、
1 個~以上の内容~digest値からなる~commaで分離された~listを包含する。
内容~digest値は、
`digest-algorithm$p を~messageの実際の`内容$に適用することにより算出される。
それは、要請, 応答どちらにも利用できる。
◎
The Content-Digest field contains a comma-separated list of one or more content digest values. A content digest value is computed by applying a digest-algorithm to the actual message content (see Section 6.4 of [SEMANTICS]). It can be used in both requests and responses.
</p>

<pre class="bnf">
`Content-Digest@p
    = 1#`content-digest$p
`content-digest@p
    = `digest-algorithm$p "=" &lt;<span class="comment">
符号化された~digest出力
◎
encoded digest output
</span>&gt;
</pre>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
Content-Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm
                           AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew==
</pre>
</div>

<p>
`Content-Digest^h ~fieldは、
`Digest$h と類似に，複数個の `content-digest$p 値を包含してもヨイ。
◎
A Content-Digest field MAY contain multiple content-digest values, similarly to Digest (see Section 3)
</p>

<div class="example">

<pre class="lang-http">
Content-Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=,
                id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
</pre>
</div>

<p>
`受信者$は、
`Content-Digest^h の`~field値$を成す各 `content-digest$p に対し，
どれを無視してもヨイ。
すなわち，`受信者$には、
受信した `content-digest$p すべてを検証yせずに，
一部の `digest-algorithm$p に限って検証~用に利用することも許容される。
◎
A recipient MAY ignore any or all of the content-digests in a Content-Digest field. This allows the recipient to choose which digest-algorithm(s) to use for validation instead of verifying every received content-digest.
</p>

<p>
`送信者$は、
`受信者$が所与の `digest-algorithm$p を［
~supportする／無視することになる
］かどうか知ることなく，
それを利用している `content-digest$p を送信してもヨイ。
◎
A sender MAY send a content-digest using a digest-algorithm without knowing whether the recipient supports the digest-algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Content-Digest^h は`~trailer節$にも送信できる。
この事例では、
`Content-Digest^h は`~header節$の中へ併合してもヨイ
— `SEMANTICS/~trailerの利用に対する制限$secを見よ。
◎
Content-Digest can be sent in a trailer section. In this case, Content-Digest MAY be merged into the header section; see Section 6.5.1 of [SEMANTICS].
</p>

<p>
増分的な `digest-algorithm$p が利用されるときは，［
`送信者$／`受信者$【！receiver】
］は、`内容$が~streamされている間に~digest値を動的に算出できる。
◎
When an incremental digest-algorithm is used, the sender and the receiver can dynamically compute the digest value while streaming the content.
</p>

	</section>
	<section id="want-fields">
<h2 title="Want-Digest and Want-Content-Digest Fields">5. `Want-Digest^h, `Want-Content-Digest^h ~field</h2>

<p>
`送信者$は、［
`Want-Digest^h ／ `Want-Content-Digest^h
］~fieldを利用して，完全性~checksumの選好を指示できる。
これらの~fieldは、要請, 応答どちらにも利用できる。
◎
Senders can indicate their integrity checksum preferences using the Want-Digest or Want-Content-Digest fields. These can be used in both requests and responses.
</p>

<p>
`Want-Digest^h ~fieldは、次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，［
`Digest$h ~fieldを利用している表現~digest
］を受信するよう欲する。
◎
Want-Digest indicates the sender's desire to receive a representation digest on messages associated with the request URI and representation metadata, using the Digest field.
</p>

<p>
`Want-Content-Digest^h ~fieldは、次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，［
`Content-Digest$h ~fieldを利用している内容~digest
］を受信するよう欲する。
◎
Want-Content-Digest indicates the sender's desire to receive a content digest on messages associated with the request URI and representation metadata, using the Content-Digest field.
</p>

<pre class="bnf">
`Want-Digest@p
    = 1#`want-digest-value$p
`Want-Content-Digest@p
    = 1#`want-digest-value$p
`want-digest-value@p
    = `digest-algorithm$p [ ";" "q" "=" `qvalue$p]
</pre>

<p>
`qvalue$p は、
`送信者$の選好を指示する。
その用法と意味論は、
`SEMANTICS/品質~値$sec にて述べられる。
◎
qvalue indicates the sender's digest-algorithm preferences. Section 12.4.2 of [SEMANTICS]) describes qvalue usage and semantics.
</p>

<p>
`送信者$は、同じ `qvalue$p を伴う複数個の `digest-algorithm$p を供せる。
◎
Senders can provide multiple digest-algorithm items with the same qvalue.
</p>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
Want-Digest: sha-256
</pre>

<pre class="lang-http">
Want-Digest: sha-512;q=0.3, sha-256;q=1, unixsum;q=0
</pre>

<pre class="lang-http">
Want-Content-Digest: sha-256
</pre>

<pre class="lang-http">
Want-Content-Digest: sha-512;q=0.3, sha-256;q=1, unixsum;q=0
</pre>
</div>

	</section>
	<section id="algorithms">
<h2 title="Digest Algorithm Values">6. 各種~digest~algo値</h2>

<p>
`digest-algorithm$p 値は、
特定の~digest算出法を指示するために利用される。
◎
Digest-algorithm values are used to indicate a specific digest computation.
</p>

<pre class="bnf">
`digest-algorithm@p
    = `token$p
</pre>

<p>
`digest-algorithm$p を成す~tokenは、
どれも文字大小無視で比較されなければナラナイが，小文字が選好される。
◎
All digest-algorithm token values are case-insensitive but lower case is preferred; digest-algorithm token values MUST be compared in a case-insensitive fashion.
</p>

<p>
どの `digest-algorithm$p にも，
算出~手続-と その出力の符号化法【！encoding output】が定義される。
他が指定されない限り、符号化された出力の比較は，文字大小区別とする。
◎
Every digest-algorithm defines its computation procedure and encoding output. Unless specified otherwise, comparison of encoded output is case-sensitive.
</p>

<p>
~IANAにより保守される`~HTTP~digest~algo値~registry$citeは、
各 `digest-algorithm$p 値を登録する。
各 登録は、次に挙げる~fieldを含まなければナラナイ：
◎
The "HTTP Digest Algorithm Values Registry", maintained by IANA at https://www.iana.org/assignments/http-dig-alg/ registers digest-algorithm values. Registrations MUST include the following fields:
</p>
<dl>
	<dt>
~digest~algo：
◎
Digest algorithm:＼
</dt>
	<dd>
当の~token値。
この~registryは、~token値を予約するためにも利用できる。
◎
the token value. The registry can be used to reserve token values
</dd>

	<dt>
位置付け：
◎
Status:＼
</dt>
	<dd>
<p>
当の~algoの位置付け：
◎
the status of the algorithm.＼
</p>
		<ul>
			<li>
`標準^i（ `standard^en ）
⇒
標準~化された~algoのうち，
既知な問題を伴わないものには `標準^i を利用すること。
◎
Use "standard" for standardized algorithms without known problems;＼
</li>
			<li>
`試験的^i（ `experimental^en ）その他~何らかの適切な値
⇒
例えば、当の~algoを定義した首な文書の種別と位置付けに則って。
◎
"experimental" or some other appropriate value
◎
e.g. according to the type and status of the primary document in which the algorithm is defined;＼
</li>
			<li>
`非~secure^i （ `insecure^en ）
⇒
当の~algoが~secureでなくなったときには。
◎
"insecure" when the algorithm is insecure;＼
</li>
			<li>
`予約-済み^i （ `reserved^en ）
⇒
~digest~algoが予約-済みな~token値を参照するときには。
◎
"reserved" when Digest algorithm references a reserved token value
</li>
		</ul>
	</dd>

	<dt>
記述：
◎
Description:＼
</dt>
	<dd>
［
当の `digest-algorithm$p, その符号化法
］についての記述
◎
the description of the digest-algorithm and its encoding
</dd>

	<dt>
参照：
◎
Reference:＼
</dt>
	<dd>
当の `digest-algorithm$p を定義している首な文書~群への~pointer
◎
a set of pointers to the primary documents defining the digest-algorithm
</dd>
</dl>

<p>
新たな `digest-algorithm$p 用に結付けられる符号化法は、［
符号化するときに利用する文字~集合
］が［
"`;^c" ／ "`,^c"
］を含む場合には，
【符号化した結果を】
`quoted-string$p として表現しなければナラナイ。
◎
The associated encoding for new digest-algorithms MUST either be represented as a quoted string or MUST NOT include ";" or "," in the character sets used for the encoding.
</p>

<p>
~secureでない~digest~algoは、［
偶発的な変更に抗する完全性
］を保全するためとして利用してもヨイが、
敵対者に~~晒され得る設定においては，利用してはナラナイ
— 例えば，真正性を得るために内容の~digestで署名するとき。
◎
Insecure digest algorithms MAY be used to preserve integrity against accidental change, but MUST NOT be used in a potentially adversarial setting; for example, when signing the digest of content for authenticity.
</p>

<p>
この~registryは、以下に挙げる~tokenで初期化される：
◎
The registry is initialized with the tokens listed below.
</p>

<dl>
	<dt>`sha-512@c</dt>
	<dd>
~digest~algo
⇒
`sha-512^c
◎
Digest Algorithm: sha-512
</dd>
	<dd>
記述
⇒
`SHA-512^i ~algo `RFC6234$r 。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
◎
Description: The SHA-512 algorithm [RFC6234]. The output of this algorithm is encoded using the base64 encoding [RFC4648].
</dd>
	<dd>
参照
⇒
`RFC6234$r,
`RFC4648$r,
この文書。
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け
⇒
`標準^i
◎
Status: standard
</dd>

	<dt>`sha-256@c</dt>
	<dd>
~digest~algo
⇒
`sha-256^c
◎
Digest Algorithm: sha-256
</dd>
	<dd>
記述
⇒
`SHA-256^i ~algo `RFC6234$r 。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
◎
Description: The SHA-256 algorithm [RFC6234]. The output of this algorithm is encoded using the base64 encoding [RFC4648].
</dd>
	<dd>
参照
⇒
`RFC6234$r,
`RFC4648$r,
この文書
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け
⇒
`標準^i
◎
Status: standard
</dd>

	<dt>`md5@c</dt>
	<dd>
~digest~algo
⇒
`md5^c
◎
Digest Algorithm: md5
</dd>
	<dd>
記述
⇒
`RFC1321$r にて指定される `MD5^i ~algo。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
この `digest-algorithm$p は、
今や，衝突~攻撃に脆弱である
— `NO-MD5$r, `CMU-836068$r を見よ。
◎
Description: The MD5 algorithm, as specified in [RFC1321]. The output of this algorithm is encoded using the base64 encoding [RFC4648]. This digest-algorithm is now vulnerable to collision attacks. See [NO-MD5] and [CMU-836068].
</dd>
	<dd>
参照
⇒
`RFC1321$r,
`RFC4648$r,
この文書
◎
Reference: [RFC1321], [RFC4648], this document.
</dd>
	<dd>
位置付け
⇒
`非~secure^i
◎
Status: insecure
</dd>

	<dt>`sha@c</dt>
	<dd>
~digest~algo
⇒
`sha^c
◎
Digest Algorithm: sha
</dd>
	<dd>
記述
⇒
`SHA-1^i ~algo `RFC3174$r 。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
この `digest-algorithm$p は、
今や，衝突~攻撃に脆弱である
— `NO-SHA1$r, `IACR-2020-014$r を見よ。
◎
Description: The SHA-1 algorithm [RFC3174]. The output of this algorithm is encoded using the base64 encoding [RFC4648]. This digest-algorithm is now vulnerable to collision attacks. See [NO-SHA1] and [IACR-2020-014].
</dd>
	<dd>
参照
⇒
`RFC3174$r,
`RFC6234$r,
`RFC4648$r,
この文書。
◎
Reference: [RFC3174], [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け
⇒
`非~secure^i
◎
Status: insecure
</dd>

	<dt>`unixsum@c</dt>
	<dd>
~digest~algo
⇒
`unixsum^c
◎
Digest Algorithm: unixsum
</dd>
	<dd>
記述
⇒
この~algoは、
`UNIX$r により定義される~UNIX "sum" ~commandにより算出される。
この~algoの出力は、
16 ~bit~checksumを表現している~ASCII数字~列であり，
~UNIX "sum" ~commandの出力を成す最初の単語である。
◎
Description: The algorithm computed by the UNIX "sum" command, as defined by the Single UNIX Specification, Version 2 [UNIX]. The output of this algorithm is an ASCII decimal-digit string representing the 16-bit checksum, which is the first word of the output of the UNIX "sum" command.
</dd>
	<dd>
参照
⇒
`UNIX$r,
この文書。
◎
Reference: [UNIX], this document.
</dd>
	<dd>
位置付け
⇒
`非~secure^i
◎
Status: insecure
</dd>

	<dt>`unixcksum@c</dt>
	<dd>
~digest~algo
⇒
`unixcksum^c
◎
Digest Algorithm: unixcksum
</dd>
	<dd>
記述
⇒
この~algoは、
`UNIX$r により定義される~UNIX "cksum" ~commandにより算出される。
この~algoの出力は、
32 ~bit ~CRCを表現している~ASCII数字~列であり，
~UNIX "cksum" ~commandの出力を成す最初の単語である。
◎
Description: The algorithm computed by the UNIX "cksum" command, as defined by the Single UNIX Specification, Version 2 [UNIX]. The output of this algorithm is an ASCII digit string representing the 32-bit CRC, which is the first word of the output of the UNIX "cksum" command.
</dd>
	<dd>
参照
⇒
`UNIX$r,
この文書
◎
Reference: [UNIX], this document.
</dd>
	<dd>
位置付け
⇒
`非~secure^i
◎
Status: insecure
</dd>

	<dt>`adler32@c</dt>
	<dd>
~digest~algo
⇒
`adler32^c
◎
Digest Algorithm: adler32
</dd>
	<dd>
記述
⇒
`ADLER32$i ~algoは
`RFC1950$r `ZLIB Compressed Data Format^cite
にて指定される~checksumである。
その出力は、
32 ~bitであり，~hexadecimalに符号化される
（ 1 〜 8 個の~ASCII文字（ 0-9, A-F, a-f ）を利用して／頭部に 0 も許容される）。
例えば［
`adler32=03da0195^c,
`adler32=3DA0195^c
］は、どちらも［
4 ~byteな~message "`Wiki^c"
］用の妥当な~checksumを与える。
この~algoは、廃用にされたので，利用されるベキでない。
◎
Description: The ADLER32 algorithm is a checksum specified in [RFC1950] "ZLIB Compressed Data Format". The 32-bit output is encoded in hexadecimal (using between 1 and 8 ASCII characters from 0-9, A-F, and a-f; leading 0's are allowed). For example, adler32=03da0195 and adler32=3DA0195 are both valid checksums for the 4-byte message "Wiki". This algorithm is obsoleted and SHOULD NOT be used.
</dd>
	<dd>
参照
⇒
`RFC1950$r,
この文書
◎
Reference: [RFC1950], this document.
</dd>
	<dd>
位置付け
⇒
`非~secure^i
◎
Status: insecure
</dd>

	<dt>`crc32c@c</dt>
	<dd>
~digest~algo
⇒
`crc32c^c
◎
Digest Algorithm: crc32c
</dd>
	<dd>
記述
⇒
`CRC32c$i ~algoは、
32 ~bit巡回冗長性を検査する（ `cyclic redundancy check^en ）。
それは、他の多くの 32 ~bit~CRC関数より良い~hamming距離を達成する
（~error検出~処理能が他より良い）。
それは、~iSCSIや~SCTPを含む他の場面でも利用される。
その出力は、
32 ~bitであり，~hexadecimalに符号化される
（ 1 〜 8 個の~ASCII文字（ 0-9, A-F, a-f ）を利用して／頭部に 0 も許容される）。
例えば，［
`crc32c=0a72a4df^c,
`crc32c=A72A4DF^c
］は、どちらも［
3 ~byteな~message "`dog^c"
］用の妥当な~checksumを与える。
◎
Description: The CRC32c algorithm is a 32-bit cyclic redundancy check. It achieves a better hamming distance (for better error-detection performance) than many other 32-bit CRC functions. Other places it is used include iSCSI and SCTP. The 32-bit output is encoded in hexadecimal (using between 1 and 8 ASCII characters from 0-9, A-F, and a-f; leading 0's are allowed). For example, crc32c=0a72a4df and crc32c=A72A4DF are both valid checksums for the 3-byte message "dog".
</dd>
	<dd>
参照
⇒
`RFC4960/B$sec,
この文書
◎
Reference: [RFC4960] appendix B, this document.
</dd>
	<dd>
位置付け
⇒
`非~secure^i
◎
Status: insecure
</dd>
</dl>

<p>
`Content-Encoding$h とは独立に~checksumを供することを［
`送信者$／`受信者$
］に許容するため、
次に挙げる追加的な `digest-algorithm$p が定義される：
◎
To allow sender and recipient to provide a checksum which is independent from Content-Encoding, the following additional digest-algorithms are defined:
</p>

<dl>
	<dt>`id-sha-512@c</dt>
	<dd>
記述
⇒
`内容~符号法$が適用されない【または復号された】ときの，
`資源$の`表現~data$の `sha-512$c ~digest。
◎
Description: The sha-512 digest of the representation data of the resource when no content coding is applied
</dd>
	<dd>
参照
⇒
`RFC6234$r,
`RFC4648$r,
この文書
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け
⇒
`標準^i
◎
Status: standard
</dd>

	<dt>`id-sha-256@c</dt>
	<dd>
記述：
`内容~符号法$が適用されない【または復号された】ときの，
`資源$の`表現~data$の `sha-256$c ~digest。
◎
Description: The sha-256 digest of the representation data of the resource when no content coding is applied
</dd>
	<dd>
参照：
`RFC6234$r,
`RFC4648$r,
この文書
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>
</dl>

	</section>
	<section id="state-changing-requests">
<h2 title="Using Digest in State-Changing Requests">7. 状態変更~要請における `Digest^h の利用-法</h2>

<p>
状態変更~要請~内に同封された表現が`~target資源$を述べるものでないときは、
表現~digestは，`表現~data$から算出されなければナラナイ。
これは、唯一アリな選択になる
— 表現~digestは、完全な`表現~metadata$を要求するので
（ `2$sec を見よ）。
◎
When the representation enclosed in a state-changing request does not describe the target resource, the representation digest MUST be computed on the representation-data. This is the only possible choice because representation digest requires complete representation metadata (see Section 2).
</p>

<p>
応答においては：
◎
In responses,
</p>
<ul>
	<li>
当の`表現$が要請の状態sを述べる場合、
`Digest$h は，同封された`表現$から算出されなければナラナイ
（ `B.8$sec を見よ）
◎
if the representation describes the status of the request, Digest MUST be computed on the enclosed representation (see Appendix B.8 );
</li>
	<li>
参照-先の`資源$が在る場合、
`Digest$h は，その資源に`選定される表現$から算出されなければナラナイ
— それが当の`~target資源$と異なっていようが。
`Digest$h は、
同封された`表現$から算出された結果であることも，
そうでないこともある。
◎
if there is a referenced resource Digest MUST be computed on the selected representation of the referenced resource even if that is different from the target resource. That might or might not result in computing Digest on the enclosed representation.
</li>
</ul>

<p>
後者の事例は、
所与の`~method$の意味論に則って行われる
— 例えば， `Content-Location$h ~header `SEMANTICS$r を利用して。
対照的に，
`Location$h ~headerは、
`表現~metadata$ではないので，
`Digest$h には影響しない。
◎
The latter case is done according to the HTTP semantics of the given method, for example using the Content-Location header field (see Section 8.7 of [SEMANTICS]). In contrast, the Location header field does not affect Digest because it is not representation metadata.
</p>

<p>
例えば `PATCH$m 要請においては、
表現~digestは~patch文書から算出されることになる
— `表現~metadata$は、
`~target資源$ではなく，~patch文書を指すので
（ `PATCH$r § `PATCH$m を見よ）。
対する応答においては、
表現~digestは，代わりに~patchされた`資源$の`選定された表現$から算出されることになる。
◎
For example, in PATCH requests, the representation digest will be computed on the patch document because the representation metadata refers to the patch document and not to the target resource (see Section 2 of [PATCH]). In responses, instead, the representation digest will be computed on the selected representation of the patched resource.
</p>

		<section id="digest-and-content-location">
<h3 title="Digest and Content-Location in Responses">7.1. 応答~内の `Digest^h と `Content-Location^h</h3>

<p>
ある状態変更~methodに対する応答が `Content-Location$h ~headerを返すとき、
応答に同封された表現は，その`~field値$により識別される`資源$を指す
— `Digest$h はそれに則って算出される。
その例は `B.7$sec にて与える。
◎
When a state-changing method returns the Content-Location header field, the enclosed representation refers to the resource identified by its value and Digest is computed accordingly. An example is given in Appendix B.7.
</p>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">8. ~securityの考慮点</h2>

		<section id="digest-does-not-protect-the-full-http-message">
<h3 title="Digest Does Not Protect the Full HTTP Message">8.1. `Digest^h は全部的な~HTTP~messageを保護するものではない</h3>

<p>
この文書は、ある~data完全性の仕組みを指定する。
それは、~HTTP［
`表現~data$／`内容$
］を保護するが、~HTTP［
~headerや~trailer
］を ある種の偶発的な破損から保護するものではない。
◎
This document specifies a data integrity mechanism that protects HTTP representation data or content, but not HTTP header and trailer fields, from certain kinds of accidental corruption.
</p>

<p>
`Digest$h ~fieldは、
~HTTP~messageに対する悪意的な改ざんに抗する一般的な保護は意図されない。
それは、［
~transport層の~securityや~digital署名
］などの他の~approachと組合せることで達成できる。
◎
Digest fields are not intended to be a general protection against malicious tampering with HTTP messages. This can be achieved by combining it with other approaches such as transport-layer security or digital signatures.
</p>

		</section>
		<section id="digest-for-end-to-end-integrity">
<h3 title="Digest for End-to-End Integrity">8.2. 端点間の完全性~用の `Digest^h</h3>

<p>
`Digest$h ~fieldは［
実装~error／
欲されない “`形式変換ng~proxy$” `SEMANTICS$r ／
~dataが いくつかの［
中継点／~system境界
］を通過するときに伴われる他の動作
］に因る`表現~metadata$の改変を検出する助けになり得る。
［
端点間における［
`表現~data$／`内容$
］の完全性
］用の単純な仕組みであっても，価値はある
— ~UAは、［
~HTML構文解析器や動画~再生器, 等々
］に構文解析~用に手渡す前に，資源の検索取得に成功したことを検証できるので。
◎
Digest fields can help detect representation data or content modification due to implementation errors, undesired "transforming proxies" (see Section 7.7 of [SEMANTICS]) or other actions as the data passes across multiple hops or system boundaries. Even a simple mechanism for end-to-end representation data integrity is valuable because user-agent can validate that resource retrieval succeeded before handing off to a HTML parser, video player etc. for parsing.
</p>

<p>
特に，`identity^i 【`内容~符号法$を伴わない】 `digest-algorithm$p
（例： "`id-sha-256$c", "`id-sha-512$c" ）
は、端点間の完全性~用に有用になる。
それらは、~HTTP~message法の特徴が異なる各~source
— 例えば，適用する`内容~符号法$が異なる各`~server$ —
からの資源を，一緒に継ぎ合わせることを許容するので。
◎
Identity digest-algorithms (e.g. "id-sha-256" and "id-sha-512") are particularly useful for end-to-end integrity because they allow piecing together a resource from different sources with different HTTP messaging characteristics. For example, different servers that apply different content codings.
</p>

<p>
`Digest$h ~fieldだけを利用しても，端点間における~HTTP~message【全体】の完全性は
— 中継点を経ている場合には —
供さないことに注意
— その~metadataは、どの段階でも操作され得るので。
~metadataを保護する手法は、
`8.3$sec にて論じられる。
◎
Note that using digest fields alone does not provide end-to-end integrity of HTTP messages over multiple hops, since metadata could be manipulated at any stage. Methods to protect metadata are discussed in Section 8.3.
</p>

		</section>
		<section id="usage-in-signatures">
<h3 title="Usage in Signatures">8.3. 署名における用法</h3>

<p>
~digital署名は、
ある種の~messageの生成元を識別するものを供するためとして，
~checksumと一緒に広範に利用される
`NIST800-32$r
。
そのような署名は、
1 個以上の~HTTP~fieldを保護し得る
— それらに `Digest$h も含まれるときには、
追加的な考慮点がある。
◎
Digital signatures are widely used together with checksums to provide the certain identification of the origin of a message [NIST800-32]. Such signatures can protect one or more HTTP fields and there are additional considerations when Digest is included in this set.
</p>

<p>
`Digest$h ~fieldは、何個かの［
資源~表現の~hash
］を成すので，
`表現~metadata$
（例：`Content-Type$h, `Content-Encoding$h, 等々の値）
に明示的に依存する。
`Digest$h は保護しつつ他の`表現~metadata$は保護しない署名は、
当の通信を改ざんに晒し得る。
例えば，ある動作者は、
`Content-Type$h `~field値$を操作して，
`受信者$における~digest検証を失敗に至らすこともでき、
当の応用が`表現$へ~accessできなくする。
そのような攻撃は、両~端点の資源を消費する。
`7.1$sec も見よ。
◎
Since digest fields are hashes of resource representations, they explicitly depend on the representation metadata (e.g. the values of Content-Type, Content-Encoding etc). A signature that protects Digest but not other representation metadata can expose the communication to tampering. For example, an actor could manipulate the Content-Type field-value and cause a digest validation failure at the recipient, preventing the application from accessing the representation. Such an attack consumes the resources of both endpoints. See also Section 7.1.
</p>

<p>
`Digest$h ~fieldは、常に，［
~transport層において，~HTTP~fieldを保護する完全性
］を供する接続~越しに利用されるベキである。
◎
Digest fields SHOULD always be used over a connection that provides integrity at the transport layer that protects HTTP fields.
</p>

<p>
`Digest$h ~fieldに `推奨されない^2119 `digest-algorithm$p を利用しているものは、
署名には利用するベキでない。
◎
A Digest field using NOT RECOMMENDED digest-algorithms SHOULD NOT be used in signatures.
</p>

<p>
署名を利用して，空な表現の~checksumを保護することは、［
最終的な`内容$において何かが剥がされたり追加されたかどうか検出する
］ことを受信している端点に許容する。
◎
Using signatures to protect the checksum of an empty representation allows receiving endpoints to detect if an eventual payload has been stripped or added.
</p>

<p>
`Digest$h ~fieldを弄ることは、
署名の検証に影響するかもしれない
— 例：
`representation-data-digest$p 値から重複な~tokenを除去する ／
複数の`~field行l値$を`結合-$するなど
（ `SEMANTICS/~field行と結合-済みな~field値$sec を見よ）。
◎
Any mangling of digest fields, including de-duplication of representation-data-digest values or combining different field values (see Section 5.2 of [SEMANTICS]) might affect signature validation.
</p>

		</section>
		<section id="usage-in-trailer-fields">
<h3 title="Usage in Trailer Fields">8.4. ~trailerにおける用法</h3>

<p>
`送信者$は、
`~trailer節$内に `Digest$h ~fieldを送信する前に，次について考慮するべきである
⇒
`中継者$には、
どの`~trailer$も落とすことが明示的に許容されている
（ `SEMANTICS/~trailerの処理$sec を見よ）。
◎
Before sending digest fields in a trailer section, the sender should consider that intermediaries are explicitly allowed to drop any trailer (see Section 6.5.2 of [SEMANTICS]).
</p>

<p>
`Digest$h ~fieldが`~trailer節$にて利用される場合、
その`~field値$は，`内容$より後に受信される。
`~trailer節$より前に内容の処理を急ぐと，~digestは検証できなくなり、
場合によっては，無効な~dataの処理へ導き得る。
◎
When digest fields are used in a trailer section, the field-values are received after the content. Eager processing of content before the trailer section prevents digest validation, possibly leading to processing of invalid data.
</p>

<p>
`digest-algorithm$p には，`~trailer節$内の利用には相応しくないものもある
— うち一部は、
~messageを送信する前に，`内容$全体を予め処理することを要求することもある
（例： `I-D.thomson-http-mice$r を見よ）。
◎
Not every digest-algorithm is suitable for use in the trailer section, some may require to pre-process the whole payload before sending a message (e.g. see [I-D.thomson-http-mice]).
</p>

		</section>
		<section id="usage-with-encryption">
<h3 title="Usage with Encryption">8.5. 暗号化を伴う用法</h3>

<p>
`Digest$h ~fieldは、
暗号化されてない~dataに対し~checksumが算出されるときは，
暗号化された`内容$の詳細を公開し得る。
例えば、
"`id-sha-256$c" `digest-algorithm$p を
`暗号化される内容~符号法^cite `RFC8188$r
と併せて利用するとき。
◎
Digest fields may expose details of encrypted payload when the checksum is computed on the unencrypted data. For example, the use of the "id-sha-256" digest-algorithm in conjunction with the encrypted content-coding [RFC8188].
</p>

<p>
暗号化された`内容$の~checksumは、
利用される暗号化~algoに依存して，
各~messageごとに変化し得る
— そのような事例では、その値は，
“残りの部分（ `at rest^en ）” 【？】における完全性の証明も供するために利用することはできない
— 当の`内容$（例：符号化されたそれ）が一体として持続されない限り。
◎
The checksum of an encrypted payload can change between different messages depending on the encryption algorithm used; in those cases its value could not be used to provide a proof of integrity "at rest" unless the whole (e.g. encoded) content is persisted.
</p>

		</section>
		<section id="algorithm-agility">
<h3 title="Algorithm Agility">8.6. ~algo即応性</h3>

<p>
`digest-algorithm$p の~securityの特質は、
固定的でない【時を経れば変化し得る】。
`~algo即応性^cite（ `Algorithm Agility^en, `RFC7696$r ）は、［
`digest-algorithm$p を［
`9.1$secによる ~IANA`~HTTP~digest~algo値~registry$cite
］から選ぶ柔軟性
］を備える実装を供することにより達成される。
◎
The security properties of digest-algorithms are not fixed. Algorithm Agility (see [RFC7696]) is achieved by providing implementations with flexibility choose digest-algorithms from the IANA Digest Algorithm Values registry in Section 9.1.
</p>

<p>
この文書は、どの~algoが［
弱いのか, 強いのか
］端点が判別する助けになるよう，
~IANA`~HTTP~digest~algo値~registry$cite
に新たな “位置付け（ `Status^en ）” ~fieldを追加する
— それは、当の `digest-algorithm$p に対する，最も近過去な “鑑定” を包含する。
◎
To help endpoints distinguish weaker algorithms from stronger ones, this document adds to the IANA Digest Algorithm Values registry a new "Status" field containing the most recent appraisal of the digest-algorithm.
</p>

<p>
端点には、どの~algoにするか選好があるかもしれない
— `非~secure^i とされた~algoより `標準^i とされたものを選好するなど。
弱い~algoからの移行は、［
`digest-algorithm$p を［
`Want-Digest$h ／ `Want-Content-Digest$h
］を利用して折衝する／
複数個の `representation-data-digest$p 値を送信して，その中から`受信者$【！receiver】に選んでもらう
］ことにより~supportされる。
とは言え，資源を消費して複数個の値を送信しても、
`受信者$【！receiver】から無視された場合には，浪費されることになる
（ `3$sec を見よ）。
◎
An endpoint might have a preference for algorithms, such as preferring "standard" algorithms over "insecure" ones. Transition from weak algorithms is supported by negotiation of digest-algorithm using Want-Digest or Want-Content-Digest (see Section 5) or by sending multiple representation-data-digest values from which the receiver chooses. Endpoints are advised that sending multiple values consumes resources, which may be wasted if the receiver ignores them (see Section 3).
</p>

		</section>
		<section id="duplicate-digest-algorithm-in-field-value">
<h3 title="Duplicate digest-algorithm in field value">8.7. ~field値~内の重複な `digest-algorithm^p</h3>

<p>
端点は、複数個の `representation-data-digest$p 値を受信するかもしれない
（ `3$sec を見よ）
— 同じ `digest-algorithm$p を利用しつつ，その~digest値は［
異なる／一致する
］ような。
例えば：
◎
An endpoint might receive multiple representation-data-digest values (see Section 3) that use the same digest-algorithm with different or identical digest-values. For example:
</p>
<div class="example">

<pre class="lang-example">
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=,
        sha-256=47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=
</pre>
</div>

<p>
`受信者$【！receiver】には、
どの `representation-data-digest$p 値も無視することが許可される
— 重複の検証は、実装の裁定に委ねられる。
各~値のうち いくつを~checksum比較~用に選定するかは，端点に委ねられるので、
~digest検証に合格するか失敗するかは，それらの結果の交わりに基づくような条件付きになる。
◎
A receiver is permitted to ignore any representation-data-digest value, so validation of duplicates is left as an implementation decision. Endpoints might select all, some, or none of the values for checksum comparison and, based on the intersection of those results, conditionally pass or fail digest validation.
</p>

		</section>
		<section id="resource-exhaustion">
<h3 title="Resource exhaustion">8.8. 資源の枯渇</h3>

<p>
`Digest$h ~fieldの検証は、計算l資源を消費する。
実装は、資源の枯渇を避けるためとして，［
~algoの種別, 検証の回数, 内容の~size
］の検証を制約できる。
◎
Digest fields validation consumes computational resources. In order to avoid resource exhaustion, implementations can restrict validation of the algorithm types, number of validations, or the size of content.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">9. ~IANA考慮点</h2>

		<section id="iana-digest-algorithm-registry">
<h3 title="Establish the HTTP Digest Algorithm Values Registry">9.1. ~HTTP~digest~algo値~registryを確立する</h3>

<p>
このメモは、この仕様が
`~HTTP~digest~algo値~registry$cite用の文書を確立するものと設定する。
◎
This memo sets this specification to be the establishing document for the HTTP Digest Algorithm Values registry.
</p>

<p>
~IANAには次が依頼される
⇒＃
この~registry用の “参照” を この文書を指すよう更新する。
この~registryを `6$sec にて定義される~tokenで初期化する。
◎
IANA is asked to update the "Reference" for this registry to refer this document and to inizialize the registry with the tokens defined in Section 6.
</p>

<p>
この~registryは、
`Specification Required^en 施策（ `RFC8126/4.6$sec ）を利用する。
◎
This registry uses the Specification Required policy (Section 4.6 of [RFC8126]).
</p>

		</section>
		<section id="iana-contentMD5">
<h3 title="Obsolete 'contentMD5' token in Digest Algorithm">9.2. ~digest~algoにおいて廃用にされた "`contentMD5^c" ~token</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内に "`contentMD5$c" ~tokenを追加する：
◎
This memo adds the "contentMD5" token in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
`contentMD5@c
◎
Digest Algorithm: contentMD5
</li>
	<li>
記述：
`RFC3230/5$sec は、
"`contentMD5$c" ~tokenは
`Want-Digest$h 内に限り利用されるものと定義した。
この~tokenは、廃用にされた
— 利用してはナラナイ。
◎
Description: Section 5 of [RFC3230] defined the "contentMD5" token to be used only in Want-Digest. This token is obsoleted and MUST NOT be used.
</li>
	<li>
参照：
この文書の `9.2$sec,
`RFC3230/5$sec
◎
Reference: Section 9.2 of this document, Section 5 of [RFC3230].
</li>
	<li>
位置付け：
`廃用d^i
◎
Status: obsoleted
</li>
</ul>

		</section>
		<section id="changes-compared-to-rfc3230">
<h3 title="Changes Compared to RFC3230">9.3. ~RFC 3230 からの変更点</h3>

<p>
`RFC3230/5$r にて定義される `contentMD5$c `digest-algorithm$p ~tokenは、
位置付け `廃用d^i を伴って，`~HTTP~digest~algo値~registry$citeに追加された。
◎
The contentMD5 digest-algorithm token defined in Section 5 of [RFC3230] has been added to the HTTP Digest Algorithm Values Registry with the "obsoleted" status.
</p>

<p>
`RFC3230$r にて定義されたすべての `digest-algorithm$p は、
今や `非~secure^i とされた。
◎
All digest-algorithms defined in [RFC3230] are now "insecure".
</p>

		</section>
		<section id="changes-compared-to-rfc5843">
<h3 title="Changes Compared to RFC5843">9.4. ~RFC 5843 からの変更点</h3>

<p>
次に挙げる `digest-algorithm$p ~tokenは、
小文字に更新された
⇒＃
"`MD5^c",
"`SHA^c",
"`SHA-256^c",
"`SHA-512^c",
◎
The digest-algorithm tokens for "MD5", "SHA", "SHA-256", "SHA-512" have been updated to lowercase.
</p>

<p>
"`MD5^c", "`SHA^c" の位置付けは，
`非~secure^i に更新された
— それに則って、その記述も改変された。
◎
The status of "MD5" and "SHA" has been updated to "insecure", and their description has been modified accordingly.
</p>

<p>
この~registryには次に挙げる~algoが追加された
⇒＃
"`id-sha-256$c",
"`id-sha-512$c"
◎
The "id-sha-256" and "id-sha-512" algorithms have been added to the registry.
</p>

		</section>
		<section id="want-digest-field-registration">
<h3 title="Want-Digest Field Registration">9.5. `Want-Digest^h ~fieldの登録</h3>

<p>
この節は
`~HTTP~field名~registry^cite
`SEMANTICS$r
に `Want-Digest$h ~fieldを登録する。
◎
This section registers the Want-Digest field in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" [SEMANTICS].
</p>

<ul>
	<li>
~field名
⇒
`Want-Digest^h
◎
Field name: Want-Digest
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status: permanent
</li>
	<li>
仕様~文書
⇒
この文書の `5$sec
◎
Specification document(s): Section 5 of this document
</li>
</ul>

		</section>
		<section id="digest-field-registration">
<h3 title="Digest Field Registration">9.6. `Digest^h ~fieldの登録</h3>

<p>
この節では、
`~HTTP~field名~registry^cite `SEMANTICS$r
に `Digest$h ~fieldを登録する。
◎
This section registers the Digest field in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" [SEMANTICS].
</p>
<ul>
	<li>
~field名
⇒
`Digest$h
◎
Field name: Digest
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status: permanent
</li>
	<li>
仕様~文書
⇒
この文書の `3$sec
◎
Specification document(s): Section 3 of this document
</li>
</ul>

		</section>
		<section id="want-content-digest-field-registration">
<h3 title="Want-Content-Digest Field Registration">9.7. `Want-Content-Digest^h ~fieldの登録</h3>

<p>
この節は
`~HTTP~field名~registry^cite
`SEMANTICS$r
に `Want-Content-Digest$h ~fieldを登録する。
◎
This section registers the Want-Content-Digest field in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" [SEMANTICS].
</p>

<ul>
	<li>
~field名
⇒
`Want-Content-Digest^h
◎
Field name: Want-Content-Digest
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status: permanent
</li>
	<li>
仕様~文書
⇒
この文書の `5$sec
◎
Specification document(s): Section 5 of this document
</li>
</ul>

		</section>
		<section id="content-digest-field-registration">
<h3 title="Content-Digest Field Registration">9.8. `Content-Digest^h ~fieldの登録</h3>

<p>
この節では、
`~HTTP~field名~registry^cite `SEMANTICS$r
に `Content-Digest$h ~fieldを登録する。
◎
This section registers the Content-Digest field in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" [SEMANTICS].
</p>

<ul>
	<li>
~field名
⇒
`Content-Digest$h
◎
Field name: Content-Digest
</li>
	<li>
位置付け
⇒
`恒久的^i
◎
Status: permanent
</li>
	<li>
仕様~文書
⇒
この文書の `4$sec
◎
Specification document(s): Section 4 of this document
</li>
</ul>

		</section>
	</section>
	<section id="resource-representation">
<h2 title="Appendix A. Resource Representation and Representation-Data">付録 A. 資源~表現と表現~data</h2>

<p>
以下に挙げる例は、［
`表現~metadata$, `内容$の`形式変換$, `~method$
］が~messageと`内容$にどう影響iするかを示す。
以下において，`内容$が印字不能な文字を包含するとき（例：圧縮されているとき）は、
`Base64^i に符号化された文字列として示される。
◎
The following examples show how representation metadata, payload transformations and method impacts on the message and content. When the content contains non-printable characters (e.g. when it is compressed) it is shown as Base64-encoded string.
</p>

<div class="example">

<figure>
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json

{"hello": "world"}
</pre>
<figcaption>
`内容~符号法$を伴わない~JSON~objを伴う要請
◎
Figure 1: Request containing a JSON object without any content coding
</figcaption></figure>
</div>

<div class="example">
<figure>
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Encoding: gzip

H4sIAItWyFwC/6tWSlSyUlAypANQqgUAREcqfG0AAAA=
</pre>
<figcaption>
`gzip$c で符号化された~JSON~objを包含している要請
◎
Figure 2: Request containing a gzip-encoded JSON object
</figcaption></figure>
</div>

<p>
一方で，次の要請は、`内容$は上と同じでも，不正形な~JSON~objを伝達する
— それは、`内容~符号法$を指示していないので。
◎
Now the same content conveys a malformed JSON object, because the request does not indicate a content coding.
</p>

<div class="example">
<figure>
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json

H4sIAItWyFwC/6tWSlSyUlAypANQqgUAREcqfG0AAAA=
</pre>
<figcaption>
不正形な~JSONを包含している要請
◎
Figure 3: Request containing malformed JSON
</figcaption></figure>
</div>

<p>
`範囲~要請$は、`内容$を改めて，部分的な表現を伝達する。
◎
A Range-Request alters the content, conveying a partial representation.
</p>

<div class="example">
<figure>
<pre class="lang-http">
GET /entries/1234 HTTP/1.1
Host: foo.example
Range: bytes=1-7
</pre>
<figcaption>
部分的な内容に対する要請
◎
Figure 4: Request for partial content
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 206 Partial Content
Content-Encoding: gzip
Content-Type: application/json
Content-Range: bytes 1-7/18

iwgAla3RXA==
</pre>
<figcaption>
`gzip$c で符号化された表現からの部分的な応答
◎
Figure 5: Partial response from a gzip-encoded representation
</figcaption></figure>
</div>

<p>
~methodは`内容$を改めることもある。
例えば `HEAD$m 要請に対する応答は、`内容$を運ばない。
◎
The method can also alter the content. For example, the response to a HEAD request does not carry content.
</p>

<div class="example">
<figure>
<pre class="lang-http">
HEAD /entries/1234 HTTP/1.1
Host: foo.example
Accept: application/json
Accept-Encoding: gzip
</pre>
<figcaption>
`HEAD$m 要請
◎
Figure 6: HEAD request
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: gzip
</pre>
<figcaption>
対する応答は、
`内容$を伴わない
◎
Figure 7: Response to HEAD request (empty content)
</figcaption></figure>
</div>

<p>
~HTTP応答の意味論は、
`~target~URI$を同封された表現から切り離すかもしれない。
下に与える応答の例では、
`Content-Location$h ~headerは、［
同封された表現は `/authors/123^c にて可用な資源を指す
］ことを指示する
— 当の要請は `/authors/^c へ~directされていても。
◎
Finally, the semantics of an HTTP response might decouple the effective request URI from the enclosed representation. In the example response below, the Content-Location header field indicates that the enclosed representation refers to the resource available at /authors/123, even though the request is directed to /authors/.
</p>

<div class="example">

<figure>
<pre class="lang-http">
POST /authors/ HTTP/1.1
Host: foo.example
Accept: application/json
Content-Type: application/json

{"author": "Camilleri"}
</pre>
<figcaption>
`POST$m 要請
◎
Figure 8: POST request
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /authors/123
Location: /authors/123

{"id": "123", "author": "Camilleri"}
</pre>
<figcaption>
`Content-Location$h ~headerを伴う応答
◎
Figure 9: Response with Content-Location header
</figcaption></figure>

</div>

	</section>
	<section id="examples-unsolicited">
<h2 title="Appendix B. Examples of Unsolicited Digest">付録 B. 請求されない `Digest^h の例</h2>

<p>
以下に挙げる例は、
`~client$が［
`Want-Digest$h ／ `Want-Content-Digest$h
］を利用するよう請求しなかったときでも，
`~server$が［
`Digest$h ／ `Content-Digest$h
］~fieldで応答するときのヤリトリをデモる。
◎
The following examples demonstrate interactions where a server responds with a Digest or Content-Digest fields even though the client did not solicit one using Want-Digest or Want-Content-Digest.
</p>

<p>
例のうちいくつかは、
`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.
</p>

<p>
この文書にて定義される~checksumの仕組みは、
`~MIME型$を問わないことに加え，特定の形式~用の正準-化~algoは供さない。
各~例は、【対象の~data内の】~spaceも含めて計算される。
［
`Digest$h, `Content-Digest$h
］両~fieldを含む例もあるが、
これらは，独立に返され得る。
◎
Checksum mechanisms defined in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space. While examples can include both fields, Digest and Content-Digest can be returned independently.
</p>

		<section id="example-full-representation">
<h3 title="Server Returns Full Representation Data">B.1. ~serverは全部的な表現~dataを返す例</h3>

<p>
この例では、
~messageの`内容$は完全な`表現~data$を伝達するので，［
`Digest$h, `Content-Digest$h
］の値は同じになる。
◎
In this example, the message content conveys complete representation data, so Digest and Content-Digest have the same value.
</p>

<div class="example">

<figure>
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
</pre>
<figcaption>
ある~itemに対する `GET$m 要請
◎
Figure 10: GET request for an item
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
<figcaption>
対する応答は `Content-Digest$h を伴う
◎
Figure 11: Response with Content-Digest
</figcaption></figure>
</div>

		</section>
		<section id="server-returns-no-representation-data">
<h3 title="Server Returns No Representation Data">B.2. ~serverは表現~dataを返さない例</h3>

<p>
この例では、
`HEAD$m 要請を利用して`資源$の~checksumを検索取得する。
◎
In this example, a HEAD request is used to retrieve the checksum of a resource.
</p>

<p>
対する応答の `Digest$h `~field値$は，~JSON~obj
`{"hello": "world"}^c
から計算されるが、
応答の`内容$は無いので，当の~JSONは そこには示されない。
`Content-Digest$h は、空な`内容$に対し算出される。
◎
The response Digest field-value is calculated over the JSON object {"hello": "world"}, which is not shown because there is no payload data. Content-Digest is computed on empty content.
</p>

<div class="example">

<figure>
<pre class="lang-http">
HEAD /items/123 HTTP/1.1
Host: foo.example
</pre>
<figcaption>
ある~itemに対する `HEAD$m 要請
◎
Figure 12: HEAD request for an item
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Digest: sha-256=47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=
</pre>
<figcaption>
対する応答は、
`Content-Digest$h, `Digest$h 両者を伴うが，内容は伴わない
◎
Figure 13: Response with both Content-Digest and Digest; empty content
</figcaption></figure>
</div>

		</section>
		<section id="server-returns-partial-representation-data">
<h3 title="Server Returns Partial Representation Data">B.3. ~serverは部分的な表現~dataを返す例</h3>

<p>
この例では、
`~client$は、`範囲~要請$を為す
— 対して`~server$は、部分的な内容で応答する。
応答の `Digest$h `~field値$は、
~JSON~obj全体
`{"hello": "world"}^c
を表現する。
一方で `Content-Digest$h の`~field値$は、
~messageの`内容$ "`hello^c" に対し算出される。
◎
In this example, the client makes a range request and the server responds with partial content. The Digest field-value represents the entire JSON object {"hello": "world"} , while the Content-Digest field-value is computed on the message content "hello".
</p>

<div class="example">

<figure>
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Range: bytes=1-7
</pre>
<figcaption>
部分的な内容に対する要請
◎
Figure 14: Request for partial content
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 206 Partial Content
Content-Type: application/json
Content-Range: bytes 1-7/18
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Digest: sha-256=Wqdirjg/u3J688ejbUlApbjECpiUUtIwT8lY/z81Tno=

"hello"
</pre>
<figcaption>
`Content-Digest$h, `Digest$h 両者を伴う部分的な応答
◎
Figure 15: Partial response with both Content-Digest and Digest
</figcaption></figure>
</div>

		</section>
		<section id="client-and-server-provide-full-representation-data">
<h3 title="Client and Server Provide Full Representation Data">B.4. ~client, ~serverどちらも全部的な表現~dataを供する例</h3>

<p>
要請は、同封された表現から計算された `Digest$h `~field値$を包含する。
また，`~client$は、
当の要請に値 `br^c を伴う `Accept-Encoding$h ~headerを内包して，
`Brotli^i 符号化法を~supportすることを広告する。
◎
The request contains a Digest field-value calculated on the enclosed representation. It also includes an Accept-Encoding: br header field that advertises the client supports Brotli encoding.
</p>

<p>
対する応答は、
値 `br^c を伴う `Content-Encoding$h ~headerを内包する
— それは、`選定された表現$は `Brotli^i に符号化されたことを指示する。
したがって `Digest$h `~field値$は，要請のそれとは異なる。
◎
The response includes a Content-Encoding: br that indicates the selected representation is Brotli encoded. The Digest field-value is therefore different compared to the request.
</p>

<p>
応答の`内容$は、
印字不能な文字を包含するので，
呈示~目的においては `Base64^i に符号化された文字列として表示される。
◎
For presentation purposes, the response body is displayed as a Base64-encoded string because it contains non-printable characters.
</p>

<div class="example">

<figure>
<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
<figcaption>
`Digest$h を伴う `PUT$m 要請
◎
Figure 16: PUT Request with Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Location: /items/123
Content-Encoding: br
Content-Length: 22
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=

iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==
</pre>
<figcaption>
対する応答は、
符号化された内容【！応答】の `Digest$h を伴う
◎
Figure 17: Response with Digest of encoded response
</figcaption></figure>
</div>

		</section>
		<section id="client-provides-full-representation-data-server-provides-no-representation-data">
<h3 title="Client Provides Full Representation Data, Server Provides No Representation Data">B.5. ~clientは全部的な表現~dataを供する, ~serverは表現~dataを供さない例</h3>

<p>
要請の `Digest$h `~field値$は、
同封された`内容$から計算される。
◎
The request Digest field-value is calculated on the enclosed payload.
</p>

<p>
対する応答の `Digest$h `~field値$は、
応答が`内容$を包含しないときでも，`表現~header$【！表現~metadata~header】に依存する
— この例では、［
値 `br^c を伴う `Content-Encoding$h ~header
］もそれに含まれる。
◎
The response Digest field-value depends on the representation metadata header fields, including Content-Encoding: br even when the response does not contain content.
</p>

<div class="example">

<figure>
<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Length: 18
Accept-Encoding: br
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
<figcaption>
内容の `Digest$h を伴う要請
◎
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 204 No Content
Content-Type: application/json
Content-Encoding: br
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=
</pre>
<figcaption>
対する応答は、
`Digest$h を伴うが，内容は伴わない
◎
Figure 18: Empty response with Digest
</figcaption></figure>
</div>

		</section>
		<section id="client-and-server-provide-full-representation-data-client-uses-id-sha-256">
<h3 title="Client and Server Provide Full Representation Data, Client Uses id-sha-256.">B.6. ~client, ~serverどちらも全部的な表現~dataを供する，~clientは `id-sha-256^c を利用する例</h3>

<p>
応答は、 2 個の~digest値
— 適用された`内容~符号法$が［
無いときのもの, あるときのもの
］ —
を包含する：
◎
The response contains two digest values:
</p>
<ul>
	<li>
前者の~digest値（ `id-sha-256=...^c ）は、
この事例では，要請~内に送信された符号化されていない`内容$の~digest値に~~偶然
【すなわち、当の `PUT$m 要請の内容が，そのまま`表現~data$になったとするなら】
合致する。
◎
one with no content coding applied, which in this case accidentally matches the unencoded digest-value sent in the request;
</li>
	<li>
後者の~digest値には、
`Content-Encoding$h に指示される`内容~符号法$が織り込まれる。
◎
one taking into account the Content-Encoding.
</li>
</ul>

<p>
応答の`内容$は、印字不能な文字を包含するので，ここでは~base64に符号化された文字列として表示されている。
◎
As the response body contains non-printable characters, it is displayed as a base64-encoded string.
</p>

<div class="example">

<figure>
<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
<figcaption>
`Digest$h を伴う `PUT$m 要請
◎
Figure 19: PUT Request with Digest
</figcaption></figure>


<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: br
Content-Location: /items/123
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=,
        id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==
</pre>
<figcaption>
対する応答は、
符号化された内容の `Digest$h を伴う
◎
Figure 20: Response with Digest of Encoded Content
</figcaption></figure>
</div>

		</section>
		<section id="post-not-request-uri">
<h3 title="POST Response does not Reference the Request URI">B.7. `POST^m に対する応答は要請~URIを参照しない例</h3>

<p>
要請 `Digest$h `~field値$は、
同封された表現から算出される
（ `7$sec を見よ）。
◎
The request Digest field-value is computed on the enclosed representation (see Section 7).
</p>

<p>
応答~内に同封された表現は
`Content-Location$h により識別される`資源$を指す
（ `SEMANTICS/内容の識別-法$secを見よ）。
したがって， `Digest$h は、
同封された表現から算出される。
◎
The representation enclosed in the response refers to the resource identified by Content-Location (see Section 6.4.2 of [SEMANTICS]). Digest is thus computed on the enclosed representation.
</p>

<div class="example">

<figure>
<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=

{"title": "New Title"}
</pre>
<figcaption>
`Digest$h を伴う `POST$m 要請
◎
Figure 21: POST Request with Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /books/123
Location: /books/123
Digest: id-sha-256=yxOAqEeoj+reqygSIsLpT0LhumrNkIds5uLKtmdLyYE=

{
  "id": "123",
  "title": "New Title"
}
</pre>
<figcaption>
対する応答は、
資源の `Digest$h を伴う
◎
Figure 22: Response with Digest of Resource
</figcaption></figure>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、
同じ `Digest$h `~field値$を伴うなら合法的になることに注意。
その事例では、
`Content-Digest$h は，空な`内容$に対し算出した結果になろう。
◎
Note that a 204 No Content response without content but with the same Digest field-value would have been legitimate too. In that case, Content-Digest would have been computed on an empty content.
</p>

		</section>
		<section id="post-referencing-status">
<h3 title="POST Response Describes the Request Status">B.8. `POST^m に対する応答は要請の状態sを述べる例</h3>

<p>
要請の `Digest$h `~field値$は、
同封された`表現$から算出される
（ `7$sec を見よ）。
◎
The request Digest field-value is computed on the enclosed representation (see Section 7).
</p>

<p>
対する応答~内に同封された`表現$は、
要請の状態sを述べるので、
`Digest$h は，その同封された表現から算出される。
◎
The representation enclosed in the response describes the status of the request, so Digest is computed on that enclosed representation.
</p>

<p>
応答の `Digest$h には `Location$h により参照された`資源$との明示的な関係は無い。
◎
Response Digest has no explicit relation with the resource referenced by Location.
</p>

<div class="example">

<figure>
<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=

{"title": "New Title"}
</pre>
<figcaption>
`Digest$h を伴う `POST$m 要請
◎
Figure 23: POST Request with Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Digest: id-sha-256=2LBp5RKZGpsSNf8BPXlXrX4Td4Tf5R5bZ9z7kdi5VvY=
Location: /books/123

{
  "status": "created",
  "id": "123",
  "ts": 1569327729,
  "instance": "/books/123"
}
</pre>
<figcaption>
対する応答は、
表現の `Digest$h を伴う
◎
Figure 24: Response with Digest of Representation
</figcaption></figure>
</div>

		</section>
		<section id="digest-with-patch">
<h3 title="Digest with PATCH">B.9. `PATCH^m を伴う~digest</h3>

<p>
この事例は、
`~target資源$が`~target~URI$を反映する所では，
`POST$m 要請に相似的である。
◎
This case is analogous to a POST request where the target resource reflects the effective request URI.
</p>

<p>
`PATCH$m 要請は、
`RFC7396$r にて定義される`~MIME型$
`application/merge-patch+json^c
を利用する。
◎
The PATCH request uses the application/merge-patch+json media type defined in [RFC7396].
</p>

<p>
`Digest$h は、
要請に同封された`内容$から計算される
— それは、~patch文書に対応する。
◎
Digest is calculated on the enclosed payload, which corresponds to the patch document.
</p>

<p>
対する応答の `Digest$h `~field値$は、
~patchされた`資源$の完全な表現から算出される。
◎
The response Digest field-value is computed on the complete representation of the patched resource.
</p>

<div class="example">

<figure>
<pre class="lang-http">
PATCH /books/123 HTTP/1.1
Host: foo.example
Content-Type: application/merge-patch+json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=

{"title": "New Title"}
</pre>
<figcaption>
`Digest$h を伴う `PATCH$m 要請
◎
Figure 25: PATCH Request with Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: id-sha-256=yxOAqEeoj+reqygSIsLpT0LhumrNkIds5uLKtmdLyYE=

{
  "id": "123",
  "title": "New Title"
}
</pre>
<figcaption>
対する応答は、
表現の `Digest$h を伴う
◎
Figure 26: Response with Digest of Representation
</figcaption></figure>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、
同じ `Digest$h `~field値$を伴うなら合法的になることに注意。
◎
Note that a 204 No Content response without content but with the same Digest field-value would have been legitimate too.
</p>

		</section>
		<section id="error-responses">
<h3 title="Error responses">B.10. ~error応答</h3>

<p>
~error応答†においては、
`表現~data$は`~target資源$を指すとは限らない。
代わりに，~errorの表現を指す。
【†この例では `4xx$st だが、 `5xx$st も含まれるかもしれない。】
◎
In error responses, the representation-data does not necessarily refer to the target resource. Instead, it refers to the representation of the error.
</p>

<p>
以下の例では、`~client$は，
`/books/123^c
に所在する資源に~patchするために
`B.9$sec の例【！ Figure 25】と同じ要請を送信する。
しかしながら，そこには資源は存在しなかったので、
`~server$は
— `RFC7807$r に則って —
~errorを述べる`内容$を伴う `404$st0 応答を生成する。
◎
In the following example, a client sends the same request from Figure 25 to patch the resource located at /books/123. However, the resource does not exist and the server generates a 404 response with a body that describes the error in accordance with [RFC7807].
</p>

<p>
応答の `Digest$h `~field値$は、
この同封された表現から算出される。
◎
The response Digest field-value is computed on this enclosed representation.
</p>

<div class="example">
<figure>
<pre class="lang-http">
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
Digest: sha-256=KPqhVXAT25LLitV1w0O167unHmVQusu+fpxm65zAsvk=

{
  "title": "Not Found",
  "detail": "Cannot PATCH a non-existent resource",
  "status": 404
}
</pre>
<figcaption>
対する応答は、
~error表現の `Digest$h を伴う
◎
Figure 27: Response with Digest of Error Representation
</figcaption></figure>
</div>

		</section>
		<section id="use-with-trailer-fields-and-transfer-coding">
<h3 title="Use with Trailer Fields and Transfer Coding">B.11. ~trailerと転送~符号法との利用</h3>

<p>
ここでは，`生成元~server$は `Digest$h を`~trailer$として送信するので、
内容を~streamしている間に~digest値を計算でき，
したがって資源の消費を軽減する。
`Digest$h `~field値$は、
`B.1$sec と同じになる
— `Digest$h は、`転送~符号法$の利用とは独立に設計されるので
（ `2$sec を見よ）。
◎
An origin server sends Digest as trailer field, so it can calculate digest-value while streaming content and thus mitigate resource consumption. The Digest field-value is the same as in Appendix B.1 because Digest is designed to be independent from the use of one or more transfer codings (see Section 2).
</p>

<div class="example">

<figure>
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
</pre>
<figcaption>
`GET$m 要請
◎
Figure 28: GET Request
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Trailer: Digest

8\r\n
{"hello"\r\n
8
: "world\r\n
2\r\n
"}\r\n
0\r\n
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
</pre>
<figcaption>
`Digest$h を伴う~chunked応答
【 `\r\n^c は改行, 数字は~spaceの個数を表すと思われる（実際の`内容$を成す文字ではなく）。】
◎
Figure 29: Chunked Response with Digest
</figcaption></figure>
</div>

		</section>
	</section>
	<section id="examples-solicited">
<h2 title="Appendix C. Examples of Want-Digest Solicited Digest">付録 C. `Want-Digest^h により請求される `Digest^h の例</h2>

<p>
以下に挙げる例は、
`~client$が `Want-Digest$h を利用して `Digest$h を請求するときのヤリトリをデモる。
`Content-Digest$h と `Want-Content-Digest$h の挙動は一致する。
◎
The following examples demonstrate interactions where a client solicits a Digest using Want-Digest. The behavior of Content-Digest and Want-Content-Digest is identical.
</p>

<p>
例のうちいくつかは、`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.
</p>

<p>
この文書にて述べられる~checksumの仕組みは、
`~MIME型$を問わないことに加え，特定の形式~用の正準-化~algoは供さない。
各~例は、~spaceも含めて計算される。
◎
Checksum mechanisms described in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space.
</p>

		<section id="server-selects-clients-least-preferred-algorithm">
<h3 title="Server Selects Client's Least Preferred Algorithm">C.1. ~serverは~clientが最も選好しない~algoを選定する例</h3>

<p>
`~client$は、
"`sha$c" を選好している~digestを要請する。
いずれにせよ、
`~server$は "`sha-256$c" で返信してもかまわない。
◎
The client requests a digest, preferring "sha". The server is free to reply with "sha-256" anyway.
</p>

<div class="example">

<figure>
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Digest: sha-256;q=0.3, sha;q=1
</pre>
<figcaption>
`Want-Digest$h を伴う `GET$m 要請
◎
Figure 30: GET Request with Want-Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
異なる~algoを伴う
◎
Figure 31: Response with Different Algorithm
</figcaption></figure>
</div>

		</section>
		<section id="ex-server-selects-unsupported-algorithm">
<h3 title="Server Selects Algorithm Unsupported by Client">C.2. ~serverは~clientが~supportされない~algoを選定する例</h3>

<p>
`~client$は、
自身が唯一~supportする "`sha$c" ~digestのみを要請する。
`~server$は、
"`sha$c" ~digestを包含している応答を生産する~~義務はないので，
代わりに異なる~algoを利用する。
◎
The client requests a only "sha" digest because that is the only algorithm it supports. The server is not obliged to produce a response containing a "sha" digest, it instead uses a different algorithm.
</p>

<div class="example">
<figure>
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Digest: sha;q=1
</pre>
<figcaption>
`Want-Digest$h を伴う `GET$m 要請
◎
Figure 32: GET Request with Want-Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm
                   +AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew==

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
~supportされない~algoを伴う
◎
Figure 33: Response with Unsupported Algorithm
</figcaption></figure>
</div>

		</section>
		<section id="server-does-not-support-client-algorithm-and-returns-an-error">
<h3 title="Server Does Not Support Client Algorithm and Returns an Error">C.3. ~serverは~client~algoを~supportしないので~errorを返す例</h3>

<p>
`C.2$sec では、［
~clientが選好した~digest~algo
］を~serverが無視する例を与えた。
別法として，`~server$は、要請を却下して~errorを返すこともできる。
◎
Appendix C.2 is an example where a server ignores the client's preferred digest algorithm. Alternatively a server can also reject the request and return an error.
</p>

<p>
この例では、
`~client$は， "`sha$c" `Digest$h を要請するが，
`~server$は，問題の詳細 `RFC7807$r を伴う~errorを返す。
問題の詳細は、
~errorの`内容$に包含され，
~serverが~supportする~digest~algoの~listを包含する。
これは純粋に例であり、
そのような内容~用の形式や要件は，この仕様では定義されない。
◎
In this example, the client requests a "sha" Digest, and the server returns an error with problem details [RFC7807] contained in the content. The problem details contain a list of the digest algorithms that the server supports. This is purely an example, this specification does not define any format or requirements for such content.
</p>

<div class="example">
<figure>
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Digest: sha;q=1
</pre>
<figcaption>
`Want-Digest$h を伴う `GET$m 要請
◎
Figure 34: GET Request with Want-Digest
</figcaption></figure>

<figure>
<pre class="lang-http">
HTTP/1.1 400 Bad Request
Content-Type: application/problem+json

{
  "title": "Bad Request",
  "detail": "Supported digest-algorithms: sha-256, sha-512",
  "status": 400
}
</pre>
<figcaption>
対する応答は、
~supportされる~algoを広告する。
◎
Figure 35: Response advertising the supported algorithms
</figcaption></figure>
</div>

		</section>
	</section>
	<section id="changes-from-rfc3230">
<h2 title="Appendix D. Changes from RFC3230">付録 D. ~RFC 3230 からの変更点</h2>

		<section id="deprecate-contentMD5">
<h3 title="Deprecate Negotiation of Content-MD5">D.1. `Content-MD5^h の折衝は非推奨にする</h3>

<p>
この~RFCは、
`Content-MD5$h の折衝を非推奨にする
— それは `RFC7231$r により廃用にされたので。
◎
This RFC deprecates the negotiation of Content-MD5 as it has been obsoleted by [RFC7231].
</p>

<p>
~HTTP~message`内容$用の新たな~checksum折衝の仕組みは、
`4$sec を見よ。
◎
See Section 4 for a new checksum negotiation mechanism for HTTP message content.
</p>

		</section>
		<section id="obsolete-parameters">
<h3 title="Obsolete Digest Field Parameters">D.2. ~digest~field用の廃用にされた~parameter</h3>

<p>
`RFC3230/4.1.1$sec,
`RFC3230/4.2$sec
は、~field~parameterを定義した。
この文書は、
`Digest$h における~parameterを伴う用法を廃用にする
— この特能は、広範に配備されてないことに加え，`~field値$の処理を複雑化するので。
◎
Sections 4.1.1 and 4.2 of [RFC3230] defined field parameters. This document obsoletes the usage of parameters with Digest because this feature has not been widely deployed and complicates field-value processing.
</p>

<p>
`RFC3230$r は、~field~parameterを［
`representation-data-digest$p に追加的な情報を添えるための共通な仕方を供する
］ものと意図した。
しかしながら，~checksumを検証するための入力として~parameterが利用された場合、
攻撃者は，それらを改めることで検証の挙動を操ることもできる。
◎
[RFC3230] intended field parameters to provide a common way to attach additional information to a representation-data-digest. However, if parameters are used as an input to validate the checksum, an attacker could alter them to steer the validation behavior.
</p>

<p>
それでも、
`digest-algorithm$p は~parameter化できる
— ［
`representation-data-digest$p の中に~parameterを符号化する
］ための自前の仕方を定義することにより，その算出に関係する~security~riskを軽減するような仕方で。
◎
A digest-algorithm can still be parameterized by defining its own way to encode parameters into the representation-data-digest, in such a way as to mitigate security risks related to its computation.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この文書の大部分は `RFC3230$r を継承している。
その偉業を成された
`J. Mogul^en, `A. Van Hoff^en
両氏に謝意を。
この文書を刷新する元の案は、
`MICE^i `内容~符号法$を考査したときに［
`M. Nottingham^en,
`J. Yasskin^en,
`M. Thomson^en
］各氏との興味深い論点から発生した。
◎
The vast majority of this document is inherited from [RFC3230], so thanks to J. Mogul and A. Van Hoff for their great work. The original idea of refreshing this document arose from an interesting discussion with M. Nottingham, J. Yasskin and M. Thomson when reviewing the MICE content coding.
</p>

<p>
この文書に価値ある貢献をなされた `Julian Reschke^en 氏に謝意を。
［
~bugを報告して／
賢い質問をして／
~textを草案~化あるいは考査して／
~open課題を評価して
］この仕様の改善に助力された，次に挙げる貢献者たちにも
⇒
`Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, and Erik Wilde^en
◎
Thanks to Julian Reschke for his valuable contributions to this document, and to the following contributors that have helped improve this specification by reporting bugs, asking smart questions, drafting or reviewing text, and evaluating open issues: Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, and Erik Wilde.
</p>

	</section>
	<section id="faq">
<h2 title="FAQ">よくある質問</h2>

<p>
`この節は、発行~前に除去されることになる。^em
◎
RFC Editor: Please remove this section before publication.
</p>
<dl>
	<dt>
`content-md5^c 【 `contentMD5$c ／ `Content-MD5$h ？】への参照をすべて除去するのはなぜですか？
◎
Why remove all references to content-md5?
</dt>
	<dd>
それらは、この仕様を解して利用することには不必要だからです。
◎
Those were unnecessary to understanding and using this specification.
</dd>

	<dt>
なぜ~instance操作への参照を除去するのですか？
◎
Why remove references to instance manipulation?
</dt>
	<dd>
仕様を正しく利用して適用するためには，不必要だからです。
`範囲~要請$を伴う例で十分~過ぎます。
それらの事例は，すべて、この文書が利用する用語 “部分的な表現” に~~分類されるはずです。
◎
Those were unnecessary for correctly using and applying the specification. An example with Range Request is more than enough. This document uses the term "partial representation" which should group all those cases.
</dd>

	<dt>
`Digest$h を `PATCH$m ~methodと伴に利用する方法は？
◎
How to use Digest with PATCH method?
</dt>
	<dd>
`7$sec を見てください。
◎
See Section 7.
</dd>

	<dt>
差分~符号化法（ `delta encoding^en 【~RFC 3229】）への参照を除去するのはなぜですか？
◎
Why remove references to delta-encoding?
</dt>
	<dd>
この仕様の正しい実装には不必要だからです。
改訂された この仕様は， “差分~符号化法” に良好に順応できますが、
ここで差分~符号化法を参照しても，この~RFCには何も追加されません。
差分~符号化法を刷新するのは、別の仕事になるでしょう。
◎
Unnecessary for a correct implementation of this specification. The revised specification can be nicely adapted to "delta encoding", but all the references here to delta encoding don't add anything to this RFC. Another job would be to refresh delta encoding.
</dd>

	<dt>
`~digest認証^cite（ `Digest Authentication^en ）への参照を除去するのはなぜですか？
◎
Why remove references to Digest Authentication?
</dt>
	<dd>
この仕様と`~digest認証^citeは、単語 “`Digest^en” を除き，完全に無関係と見受けられます。
◎
This specification seems to me completely unrelated to Digest Authentication but for the word "Digest".
</dd>

	<dt>
`Want-Digest$h における変更点は何ですか？
◎
What changes in Want-Digest?
</dt>
	<dd>
`RFC3230/5$sec にて定義された `contentMD5$c ~tokenは、
`D.1$sec により非推奨にされました。
◎
The contentMD5 token defined in Section 5 of [RFC3230] is deprecated by Appendix D.1.
</dd>
	<dd>
`RFC3230$r は、`送信者$と`受信者$【！receiver】, それらの定義を注意深く利用します。
［
`Digest$h ／ `Want-Digest$h
］は［
要請, 応答
］どちらにも利用できることを明確化するため、［
次を広告するために，応答~内で `Want-Digest$h を利用する例
］を追加しました
⇒
~supportされる `digest-algorithm$p,
~supportされない `digest-algorithm$p を伴う要請を受容する能が無いこと
◎
To clarify that Digest and Want-Digest can be used in both requests and responses - [RFC3230] carefully uses sender and receiver in their definition - we added examples on using Want-Digest in responses to advertise the supported digest-algorithms and the inability to accept requests with unsupported digest-algorithms.
</dd>

	<dt>
この仕様は、~supportされる~algoを変更しますか？
◎
Does this specification change supported algorithms?
</dt>
	<dd>
はい。
この~RFCは、 `RFC5843$r を更新します。
— それでも、すべての~algo更新は，それに委譲されます【？】。
加えて、
2 つの~algo［
"`id-sha-256$c", "`id-sha-512$c"
］を追加します
— これらは、`資源$の［
適用される`内容~符号法$を伴わない`表現$
］の~checksumを送信することを許容します。
将来における`有構造~field$ `I-D.ietf-httpbis-header-structure$r への移行を単純~化するため、
`digest-algorithm$p 用には小文字を利用することを示唆します。
◎
Yes. This RFC updates [RFC5843] which is still delegated for all algorithms updates, and adds two more algorithms: "id-sha-256" and "id-sha-512" which allows to send a checksum of a resource representation with no content codings applied. To simplify a future transition to Structured Fields [I-D.ietf-httpbis-header-structure] we suggest to use lowercase for digest-algorithms.
</dd>

	<dt>
~stream途中の`~trailer$についてはどうですか？
◎
What about mid-stream trailer fields?
</dt>
	<dd>
<a href="https://github.com/httpwg/http-core/issues/313#issuecomment-584389706">~stream途中の~trailer</a>
は関心事ですが、
この仕様は `RFC3230$r を書き直すので，それに直面するべきとは考えていません。
最初の考えとして、~stream途中の~trailer用の利用
— 例えば増分的な `digest-algorithm$p —
を見出すような将来の作業を予め除外するものは，この文書~内にはありません。
そのような `digest-algorithm$p を定義している文書が，それが どう利用されるかを述べる最良な立場にあります。
◎
While mid-stream trailer fields are interesting, since this specification is a rewrite of [RFC3230] we do not think we should face that. As a first thought, nothing in this document precludes future work that would find a use for mid-stream trailers, for example an incremental digest-algorithm. A document defining such a digest-algorithm is best positioned to describe how it is used.
</dd>
</dl>

	</section>
	<section id="code-samples">
<h2 title="Code Samples">~code見本</h2>

<p>
`この節は、発行~前に除去されることになる^em。
◎
RFC Editor: Please remove this section before publication.
</p>

<p>
この節では、この文書~全体を通して各~例にて示される `Digest$h 値を，どう［
生成する／検証する
］かを与える。
◎
How can I generate and validate the Digest values shown in the examples throughout this document?
</p>

<p>
次の~python3~codeを利用すれば、
ある範囲の符号化法に対し，各種~SHA~algoを利用して~JSON~obj用の~digestを生成できる。
これらは、~base64形式にされることに注意。
この関数は、他の~algoに順応することもできる
— その場合、それらに特有な形式~化~規則を織り込むべきである。
◎
The following python3 code can be used to generate digests for JSON objects using SHA algorithms for a range of encodings. Note that these are formatted as base64. This function could be adapted to other algorithms and should take into account their specific formatting rules.
</p>

<div>
<pre>
import base64, json, hashlib, brotli, logging
log = logging.getLogger()

def encode_item(item, encoding=lambda x: x):
    indent = 2 if isinstance(item, dict) and len(item) &gt; 1 else None
    json_bytes = json.dumps(item, indent=indent).encode()
    return encoding(json_bytes)

def digest_bytes(bytes_, algorithm=hashlib.sha256):
    checksum_bytes = algorithm(bytes_).digest()
    log.warning("Log bytes: \n[%r]", bytes_)
    return base64.encodebytes(checksum_bytes).strip()

def digest(item, encoding=lambda x: x, algorithm=hashlib.sha256):
    content_encoded = encode_item(item, encoding)
    return digest_bytes(content_encoded, algorithm)

item = {"hello": "world"}

print("Encoding | digest-algorithm | digest-value")
print("Identity | sha256 |", digest(item))
# Encoding | digest-algorithm | digest-value
# Identity | sha256 | X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

print("Encoding | digest-algorithm | digest-value")
print("Brotli | sha256 |", digest(item, encoding=brotli.compress))
# Encoding | digest-algorithm | digest-value
# Brotli | sha256 | 4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=

print("Encoding | digest-algorithm | digest-value")
print("Identity | sha512 |", digest(item, algorithm=hashlib.sha512))
# Encoding | digest-algorithm | digest-value
# Identity | sha512 | b'WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm'
#                      '+AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew=='
</pre>
</div>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
`この節は、発行~前に除去されることになる^em
【以下，この節の内容は、未訳。】
◎
RFC Editor: Please remove this section before publication.
</p>

	</section>
</main></div>
