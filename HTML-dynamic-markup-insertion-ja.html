<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Dynamic markup insertion, DOM parsing and serialization APIs（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.arg-list {
	display: block;
	padding-left: 2em;
	white-space: pre-line;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'mt':
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'm1':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-06-20
trans_update:2025-06-20
source_checked:240415
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html
	abbr_url:HTMLdynamic
nav_prev:HTMLGAPI
nav_next:HTMLnavigator
trans_1st_pub:2018-05-03


●●class_map
e:element
a:attr
et:event-type
sc:scheme
jA:abstract
E:error
U:code-point

●●tag_map
I:code
E:code
m:code
m1:code
mb:code
c:code
e:code
a:code
sc:code
et:code
jA:span
U:span
i:i

●●original_urls

●●original_id_map

●●mdn_urls
domparser:API/DOMParser
	domparsersupportedtype:API/DOMParserSupportedType

●●link_map

	●IDL
CEReactions:~HEcustom#cereactions
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString

E.DOMException:~WEBIDL#idl-DOMException
E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror
E.NoModificationAllowedError:~WEBIDL#nomodificationallowederror

I.TrustedHTML:~TRUSTED-TYPES#trustedhtml
I.Node:~DOM4#node
	I.Node:~DOM4#interface-node → ~node
I.Document:~HTMLdom#document
I.DOMParser:#domparser
I.DOMParserSupportedType:#domparsersupportedtype
I.Element:~DOM4#element
I.Text:~DOM4#text
I.Comment:~DOM4#comment
I.ShadowRoot:~DOM4#shadowroot
	I.DocumentFragment:~DOM4#documentfragment → 文書片
I.DocumentFragment:~DOM4#documentfragment
I.Range:~DOM4#range
I.GetHTMLOptions:#gethtmloptions
I.XMLSerializer:#xmlserializer

m.new DOMParser:#dom-domparser-constructor
m.parseFromString:#dom-domparser-parsefromstring
m.new XMLSerializer:#dom-xmlserializer-constructor
m.serializeToString:#dom-xmlserializer-serializetostring
m.close:#dom-document-close
m.createContextualFragment:#dom-range-createcontextualfragment
m.document.close:#dom-document-close
m.~openW:#dom-document-open-window
m.open:#dom-document-open
c.document.open():#dom-document-open
	＠~WINDOW#dom-window-open
m.write:#dom-document-write
c.document.write():#dom-document-write
m.writeln:#dom-document-writeln
	m.document:~HTMLdom#document
m.innerHTML:#dom-element-innerhtml
m1.innerHTML:#dom-shadowroot-innerhtml
m.outerHTML:#dom-element-outerhtml
m.insertAdjacentHTML:#dom-element-insertadjacenthtml
m.setHTMLUnsafe:#dom-element-sethtmlunsafe
m1.setHTMLUnsafe:#dom-shadowroot-sethtmlunsafe
m.parseHTMLUnsafe:#dom-parsehtmlunsafe
m.getHTML:#dom-element-gethtml
m1.getHTML:#dom-shadowroot-gethtml
	m.content:~HEscripting#dom-template-content → ~template内容
	誤）m.parent:~WINDOW#dom-window-parent／#dom-parent → 親:~DOM4

mb.serializableShadowRoots:#dom-gethtmloptions-serializableshadowroots
mb.shadowRoots:#dom-gethtmloptions-shadowroots

document.write 手続き:#document-write-steps
document.open 手続き:#document-open-steps

et.beforeunload:~HTMLindex#event-beforeunload
et.pagehide:~HTMLindex#event-pagehide
et.unload:~HTMLindex#event-unload
et.readystatechange:~HTMLindex#event-readystatechange

e.html:~HEmetadata#the-html-element
e.script:~HEscripting#the-script-element
e.meta:~HEmetadata#the-meta-element
e.template:~HEscripting#the-template-element

mt.text/html:~HTMLiana#text/html
mt.text/xml:~HTMLindex#text/xml
mt.application/xml:~HTMLindex#application/xml
mt.application/xhtml+xml:~HTMLiana#application/xhtml+xml
mt.image/svg+xml:~HTMLindex#image/svg+xml

l.text/html:#dom-domparsersupportedtype-texthtml
l.text/xml:#dom-domparsersupportedtype-otherwise
l.application/xml:#dom-domparsersupportedtype-otherwise
l.application/xhtml+xml:#dom-domparsersupportedtype-otherwise
l.image/svg+xml:#dom-domparsersupportedtype-otherwise


	●用語

動的~markup挿入-時には投出する~counter:#throw-on-dynamic-markup-insertion-counter
破壊的な書込nは無視する~counter:#ignore-destructive-writes-counter
作動中な構文解析器は中止されたか:#active-parser-was-aborted
~scriptにより作成された構文解析器:#script-created-parser
文字列から~HTMLを構文解析する:#parse-html-from-a-string
~HTMLを安全でなく設定する:#unsafely-set-html
素片に直列化する:#fragment-serializing-algorithm-steps
素片を構文解析する:#fragment-parsing-algorithm-steps


	●用語（HTML
sc.~about_blank:~HTMLdep#about:blank

文書:~HTMLdom#the-document-object
	文書:~HTMLdom#document
doc.初期~about_blankか:~HTMLdom#is-initial-about:blank
作動中な構文解析器:~HTMLdom#active-parser
文書の現在の準備度を更新する:~HTMLdom#update-the-current-document-readiness

~template内容:~HEscripting#template-contents
scE.すでに開始したか:~HEscripting#already-started
scE.構文解析器~文書:~HEscripting#parser-document

生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin

~window~open手続き:~WINDOW#window-open-steps
結付けられた文書:~WINDOW#concept-document-window

~node~navigable:~HTMLds#node-navigable
全部的に作動中:~HTMLds#fully-active
閲覧~文脈:~HTMLds#browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc

~navi:~HTMLnav#navigate
進行中な~navi:~HTMLnav#ongoing-navigation
~navi~ID:~HTMLnav#navigation-id
~URLと履歴を更新する:~HTMLnav#url-and-history-update-steps

読込ngを停止する:~HTMLlifecycle#nav-stop
~unload中にある:~HTMLlifecycle#unload-a-document
~unload~counter:~HTMLlifecycle#unload-counter
完全に読込まれ:~HTMLlifecycle#completely-loaded

関連な大域~obj:~WAPI#concept-relevant-global
入口~大域~obj:~WAPI#entry-global-object
~event~loopを回す:~WAPI#spin-the-event-loop
すべての~event~listener／~event~handlerを消去する:~WAPI#erase-all-event-listeners-and-handlers
	~WAPI#concept-n-script → ＠~WAPI#concept-n-noscript
~event~handler内容~属性:~WAPI#event-handler-content-attributes

~XML構文解析器:~HTMLxml#xml-parser
	:~HTMLxml#xml-scripting-support-disabled

~HTML素片~直列化~algo:~HTMLwriting#html-fragment-serialisation-algorithm

~tokenから要素を作成-:~HTMLparsing#create-an-element-for-the-token
~HTML構文解析器:~HTMLparsing#html-parser
~load後~task用に準備済み:~HTMLparsing#ready-for-post-load-tasks
~script入子ng~level:~HTMLparsing#script-nesting-level
入力~stream:~HTMLparsing#input-stream
挿入~地点:~HTMLparsing#insertion-point
明示的な~EOF:~HTMLparsing#explicit-eof-character
符号化法の確度:~HTMLparsing#concept-encoding-confidence
静止するか:~HTMLparsing#parser-pause-flag
	~HTMLparsing#check-parser-pause-flag
~HTML素片の構文解析~algo:~HTMLparsing#html-fragment-parsing-algorithm
	V.文脈~要素:~HTMLparsing#concept-frag-parse-context

~XML素片の構文解析~algo:~HTMLxml#xml-fragment-parsing-algorithm

~iframe~loadを黙らすか:~HEembed#mute-iframe-load
~iframe~loadは進捗-中か:~HEembed#iframe-load-in-progress

~custom要素~構築子:~HEcustom#custom-element-constructor
構文解析器を阻んでいる~script:~HEscripting#pending-parsing-blocking-script


	●用語（外部
文字列:~INFRA#string
~ASCII小文字~化する:~INFRA#ascii-lowercase
	~ASCII大小無視:~INFRA#ascii-case-insensitive → ~ASCII小文字~化する
~HTML名前空間:~INFRA#html-namespace

url.素片:~URL1#concept-url-fragment

~tree順序:~DOM4#concept-tree-order
~node:~DOM4#concept-node
親:~DOM4#concept-tree-parent
親~要素:~DOM4#parent-element
子孫:~DOM4#concept-tree-descendant
最初の子？:~DOM4#concept-tree-first-child
直後の同胞？:~DOM4#concept-tree-next-sibling
文書片:~DOM4#_concept-documentfragment
要素:~DOM4#concept-element
el.局所~名:~DOM4#concept-element-local-name
el.名前空間:~DOM4#concept-element-namespace
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
doc.~mode:~DOM4#concept-document-mode
doc.符号化法:~DOM4#concept-document-encoding
doc.内容~型:~DOM4#concept-document-content-type
doc.種別:~DOM4#concept-document-type
doc.宣言的な~shadow根を許容するか:~DOM4#document-allow-declarative-shadow-roots
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
~node文書:~DOM4#concept-node-document
~host:~DOM4#concept-documentfragment-host
~shadow根:~DOM4#concept-shadow-root
sR.直列化-可能か:~DOM4#shadowroot-serializable
~shadowも含めた広義-子孫:~DOM4#concept-shadow-including-inclusive-descendant
子~群:~DOM4#concept-tree-child
全~内容を~nodeで置換する:~DOM4#concept-node-replace-all
~nodeを付加する:~DOM4#concept-node-append
要素を作成する:~DOM4#concept-create-element
子を~nodeに置換する:~DOM4#concept-node-replace
~nodeを子の前に挿入する:~DOM4#concept-node-insert
始端~node:~DOM4#concept-range-start-node

多重定義~解決~algo:~WEBIDLjs#dfn-overload-resolution-algorithm
実装-:~WEBIDLjs#implements

~UTF-8:~ENCODING#utf-8

~XML直列化:~DOM-Parsing#dfn-xml-serialization

tH.~data:~TRUSTED-TYPES#trustedhtml-data
信用-済みな型に準拠な文字列を取得する:~TRUSTED-TYPES#get-trusted-type-compliant-string-algorithm

●●words_table1
openW:open
about_blank:about:blank
getHTML0:getHTML

●●words_table

	●環境／文脈／履歴
族:family::~
	担当の:responsible
iframe:
黙らす:muteする::~

	●処理一般／task
timer::::タイマー
多重定義:overload::~
入口:entry::~
再入呼出し:reentrant invocation:再入呼び出し
渡され:passされ:~
静止-:pause::~
回す:spinする::~
準備度:readiness::~
設置-:place:~
	進捗-中:in progress

	%~target:target
	%~HTML:html
	%文脈~要素:contextElement
	%文脈:context
	%新たな子~群:newChildren
	%親:parent
	%文書片:fragment
	%文書片:element
	%文書片:fragment node
	%整形式が要求されるか:require_well-formed
	%文字列:string
	%~text:text
	%値:value
	%信用-済みか:isTrusted
sink::::シンク
	%~sink:sink
LF:
	%~LFを付加するか:lineFeed
	%準拠な文字列:compliantString
	%準拠な~HTML:compliantHTML

	●データ／型／構造／操作
消去-:erase:~

	●構文解析
EOF:
end-of-file:
tokenizer:::token 化器:トークン化器:トークナイザ
書込まれ:writeされ::書き込まれ
発-:emit::~
地点:point::~
	非~構文解析器:non-parser
確度:confidence::~
	改行文字:newline character
整形式:well-formed::~
整形式性:well-formedness::整形式

	●
open:
close:
load:
	読込n後:post load
	未読込みに:unload::未読み込みに::未ロードに
unload:
破壊的:destructive::~
書込n:write::書き込み
	破壊的な書込n:destructive-writes

吹飛ばす:blow awayする:吹き飛ばす

	●仕様
discourage
	併用:used in conjunction with
導く:leadする:~
	:abstract
直接間接問わず:direct にも indirectにも:直接間接を問わず
拒否-:refuse:~
特異的:idiosyncratic:~
究明-:investigate:~
無関連:irrelevant:関連しない
数えら:countさ:~
変種:variant:~
自立的:standalone:~
不幸:unfortunate:~
遺物:artifact:~
今日:today:~
追跡器:tracker::~::トラッカー
未決:outstanding:~
準拠な:compliantな:準拠する
upstream:
	-:per
	注記
	特に
	与え
	とても／ごく:very
	し難い:hard to
	同様に:like
	〜すら:make matters even worse
	に応じて，ふるまいが異なる:comes in several variants with
	働き続け:continue working
	保たれ:kept
	特に:notably
	応じて:according
	〜を問わず:regardless of whether or not

	●未分類
template:
現在:currently:~
段階:stage::~
危険:dangerous:~
	危険になり得る:potentially-dangerous
無毒化:sanitization::~

	安全でない:unsafe
	安全でなく:unsafely
	変わる:varies
	に加え
	化
	在る
	持たな
	挙げる
	属する
	得ら
	得る
	満たさ
	-:point
	-:pending
	ε:undefined
	:end
	以前／それまで:previous
	各種:various
	より前にある:earlier
	残り:remainder
	次第に:gradually
	下で:
	中
	伴
	例
	内
	各種
	その場で:in-place
	対し
	後者
	〜時
	時点では:at this point
	様な
	次
	〜法
	済み
	無い
	〜用
	結果
	被〜
	〜間
	〜順
	次第
	直前
	種の
	に:toward

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Dynamic markup insertion, § DOM parsing and serialization APIs</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — 動的マークアップ挿入, DOM の構文解析 API と直列化 API</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="dynamic-markup-insertion">
<h3 title="Dynamic markup insertion">8.4. 動的~markup挿入</h3>

<p class="note">注記：
~markupを文書の中へ動的に挿入するための~APIは、
構文解析器と相互作用するので，それらの挙動は［
`~HTML文書$（および`~HTML構文解析器$）,
`~XML文書$（および`~XML構文解析器$）
］のどちらで利用されるかに依存して変わる。
◎
APIs for dynamically inserting markup into the document interact with the parser, and thus their behavior varies depending on whether they are used with HTML documents (and the HTML parser) or XML documents (and the XML parser).
</p>

<p>
各 `文書$には
`動的~markup挿入-時には投出する~counter@
があり、
初期~時は 0 に設定するモノトスル。
この~counterは、
`~tokenから要素を作成-$する~algoと併用され，［
`~custom要素~構築子$が構文解析器から呼出されたとき，`文書$の［
`open()$m ／ `close()$m ／ `write()$m
］が利用-可能になる
］ことを防止するために利用される。
◎
Document objects have a throw-on-dynamic-markup-insertion counter, which is used in conjunction with the create an element for the token algorithm to prevent custom element constructors from being able to use document.open(), document.close(), and document.write() when they are invoked by the parser. Initially, the counter must be set to zero.
</p>

			<section id="opening-the-input-stream">
<h4 title="Opening the input stream">8.4.1. 入力~streamの~open法</h4>

<dl class="domintro">
	<dt>%document = %document.`open()$m</dt>
	<dd>
`文書$をその場で置換する
— それまでの~objを再利用しつつ，それが新たな`文書$であったかのように。
その~objが返される。
◎
Causes the Document to be replaced in-place, as if it was a new Document object, but reusing the previous object, which is then returned.
</dd>
	<dd>
結果の`文書$には、
~HTML構文解析器が結付けられる
— それには `document.write()$c を利用して構文解析する~dataを与えれる。
◎
The resulting Document has an HTML parser associated with it, which can be given data to parse using document.write().
</dd>
	<dd>
`文書$が依然として構文解析-中にある場合、
この~methodの効果は無い。
◎
The method has no effect if the Document is still being parsed.
</dd>
	<dd>
次の場合、
`InvalidStateError$E 例外を投出する
⇒＃
`文書$は`~XML文書$である ／
`~custom要素~構築子$を現在~実行している
◎
Throws an "InvalidStateError" DOMException if the Document is an XML document.
◎
Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.
</dd>

	<dt>%window = %document.`~openW(url, name, features)$m</dt>
	<dd>
`window.open()＠~WINDOW#dom-window-open$c ~methodと同様に働く。
◎
Works like the window.open() method.
</dd>
</dl>

<p>
各 `文書$には，真偽値をとる
`作動中な構文解析器は中止されたか@
があり、
初期~時は ~F をとるとする。
これは、［
文書にて`作動中な構文解析器$が中止された後
］に［
~scriptが［
`document.open()$c ／ `document.write()$c
］~methodを（直接間接問わず）呼出す
］ことを防止するために利用される。
◎
Document objects have an active parser was aborted boolean, which is used to prevent scripts from invoking the document.open() and document.write() methods (directly or indirectly) after the document's active parser has been aborted. It is initially false.
</p>

<div class="algo">
<p>
`document.open 手続き@
は、
所与の
( %文書 )
に対し：
◎
The document open steps, given a document, are as follows:
</p>

<ol>
	<li>
~IF［
%文書 は`~XML文書$である
］
⇒
~THROW `InvalidStateError$E
◎
If document is an XML document, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%文書 の`動的~markup挿入-時には投出する~counter$ ~GT 0
］
⇒
~THROW `InvalidStateError$E
◎
If document's throw-on-dynamic-markup-insertion counter is greater than 0, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%入口~文書 ~LET `入口~大域~obj$に`結付けられた文書$
◎
Let entryDocument be the entry global object's associated Document.
</li>
	<li>
~IF［
( %文書 の`生成元$doc, %入口~文書 の`生成元$doc )
は`同一-生成元$でない
］
⇒
~THROW `SecurityError$E
◎
If document's origin is not same origin to entryDocument's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
<p>
~IF［
%文書 には`作動中な構文解析器$がある
］~AND［
その`~script入子ng~level$ ~GT 0
］
⇒
~RET %文書
◎
If document has an active parser whose script nesting level is greater than 0, then return document.
</p>

<p class="note">注記：
これは、
`document.open()$c が［
構文解析-中に見出された~inline~script内で~callされたとき
］には，基本的に無視させる
— ~timer~callbackや~event~handlerなどの，構文解析器によらない~taskから~callされたときには、
依然として効果があるようにしつつ。
◎
This basically causes document.open() to be ignored when it's called in an inline script found during parsing, while still letting it have an effect when called from a non-parser task such as a timer callback or event handler.
</p>
	</li>
	<li>
<p>
~IF［
%文書 の`~unload~counter$ ~GT 0
］
⇒
~RET %文書
◎
Similarly, if document's unload counter is greater than 0, then return document.
</p>

<p class="note">注記：
これは、
`document.open()$c が［
%文書 が~unloadされている間に［
`beforeunload$et ／ `pagehide$et ／ `unload$et
］~event~handlerから~callされたとき
］には，基本的に無視させる。
◎
This basically causes document.open() to be ignored when it's called from a beforeunload, pagehide, or unload event handler while the Document is being unloaded.
</p>
	</li>
	<li>
<p>
~IF［
%文書 の`作動中な構文解析器は中止されたか$ ~EQ ~T
］
⇒
~RET %文書
◎
If document's active parser was aborted is true, then return document.
</p>

<p class="note">注記：
これは特に、
`document.open()$c が［
`~navi$が開始された後に~callされたとき
］には，初期~構文解析-の間に限り無視させる。
更なる背景0は
`課題 #4723＠~HTMLissue/4723$
を見よ。
◎
This notably causes document.open() to be ignored if it is called after a navigation has started, but only during the initial parse. See issue #4723 for more background.
</p>
	</li>
	<li>
~IF［
%文書 の`~node~navigable$ ~NEQ ~NULL
］~AND［
%文書 の`~node~navigable$の`進行中な~navi$は`~navi~ID$である
］
⇒
`読込ngを停止する$( %文書 の`~node~navigable$ )
◎
If document's node navigable is non-null and document's node navigable's ongoing navigation is a navigation ID, then stop loading document's node navigable.
</li>
	<li>
%文書 の
~EACH( `~shadowも含めた広義-子孫$ %~node )
に対し
⇒
`すべての~event~listener／~event~handlerを消去する$( %~node )
◎
For each shadow-including inclusive descendant node of document, erase all event listeners and handlers given node.
</li>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
↓</li>
	<li>
~IF［
%文書 ~EQ %~window に`結付けられた文書$
］
⇒
`すべての~event~listener／~event~handlerを消去する$( %~window )
◎
If document is the associated Document of document's relevant global object, then erase all event listeners and handlers given document's relevant global object.
</li>
	<li>
%文書 の`全~内容を~nodeで置換する$( ~NULL )
◎
Replace all with null within document.
</li>
	<li>
<p>
~IF［
%文書 は`全部的に作動中$である
］：
◎
If document is fully active, then:
</p>
		<ol>
			<li>
%新~URL ~LET %入口~文書 の`~URL$docの複製
◎
Let newURL be a copy of entryDocument's URL.
</li>
			<li>
~IF［
%入口~文書 ~NEQ %文書
］
⇒
%新~URL の`素片$url ~SET ~NULL
◎
If entryDocument is not document, then set newURL's fragment to null.
</li>
			<li>
`~URLと履歴を更新する$( %文書, %新~URL )
◎
Run the URL and history update steps with document and newURL.
</li>
		</ol>
	</li>
	<li>
%文書 の`初期~about_blankか$doc ~SET ~F
◎
Set document's is initial about:blank to false.
</li>
	<li>
~IF［
%文書 の`~iframe~loadは進捗-中か$ ~EQ ~T
］
⇒
%文書 の`~iframe~loadを黙らすか$  ~SET ~T
◎
If document's iframe load in progress flag is set, then set document's mute iframe load flag.
</li>
	<li>
%文書 の`~mode$doc ~SET `no-quirks^l
◎
Set document to no-quirks mode.
</li>
	<li>
<p>
%構文解析器 ~LET 新たな`~HTML構文解析器$
— その
⇒
`符号化法の確度$ ~SET `無関連^i
◎
Create a new HTML parser and associate it with document.＼
</p>
<p>
これは、
`~scriptにより作成された構文解析器@
と称される。
◎
This is a script-created parser＼
</p>

<div class="note">
<p>
それは、
次の 2 つを意味する：
</p>
		<ul>
			<li>
［
`document.open()$c ／ `document.close()$m
］~methodにより~closeできる。
</li>
			<li>
その~tokenizerは、
~end-of-file~tokenを発する前に，明示的な `document.close()$m の~callを待機する。
</li>
		</ul>
◎
(meaning that it can be closed by the document.open() and document.close() methods, and that the tokenizer will wait for an explicit call to document.close() before emitting an end-of-file token). The encoding confidence is irrelevant.
</div>
	</li>
	<li>
%構文解析器 を %文書 に結付ける
◎
↑</li>
	<li>
`挿入~地点$ ~SET `入力~stream$の終端の直前
（入力~streamは、
この時点で空になる。）
◎
Set the insertion point to point at just before the end of the input stream (which at this point will be empty).
</li>
	<li>
<p>
`文書の現在の準備度を更新する$( %文書, `loading^l )
◎
Update the current document readiness of document to "loading".
</p>

<p class="note">注記：
これにより `readystatechange$et ~eventが発火されるが、
その~eventは，実際には作者~codeから観測-可能にならない
— 上の段が，それを観測できる
`すべての~event~listener／~event~handlerを消去する$ので。
◎
This causes a readystatechange event to fire, but the event is actually unobservable to author code, because of the previous step which erased all event listeners and handlers that could observe it.
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>

<p class="note">注記：
`document.open 手続き$は、
`文書$が［
`~load後~task用に準備済み$,
`完全に読込まれ$る
］のどちらになるかには影響しない。
◎
The document open steps do not affect whether a Document is ready for post-load tasks or completely loaded.
</p>
</div>

<div class="algo">
<p>
`open(unused1, unused2)@m
~method手続きは
⇒
~RET `document.open 手続き$( コレ )
◎
The open(unused1, unused2) method must return the result of running the document open steps with this.
</p>

<p class="note">注記：
%unused1, %unused2 引数は無視されるが、
1 〜 2 個の引数で関数を~callする~codeが働き続けられるよう，~IDLには保たれる。
それらは Web IDL の`多重定義~解決~algo$の規則に因り必要yである
— その規則は、
引数が無い~callに対し `TypeError^E 例外を投出する。
`whatwg/webidl 課題 #581＠https://github.com/whatwg/webidl/issues/581$
にて、
除去を許容するために~algoを変更することについて，究明-中にある。
`WEBIDL$r
◎
The unused1 and unused2 arguments are ignored, but kept in the IDL to allow code that calls the function with one or two arguments to continue working. They are necessary due to Web IDL overload resolution algorithm rules, which would throw a TypeError exception for such calls had the arguments not been there. whatwg/webidl issue #581 investigates changing the algorithm to allow for their removal. [WEBIDL]
</p>
</div>

<div class="algo">
<p>
`~openW(url, name, features)@m
~method手続きは：
◎
The open(url, name, features) method must run these steps:
</p>
<ol>
	<li>
~IF［
コレは`全部的に作動中$でない
］
⇒
~THROW `InvalidAccessError$E
◎
If this is not fully active, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
~RET 
`~window~open手続き$( %url, %name, %features )
◎
Return the result of running the window open steps with url, name, and features.
</li>
</ol>
</div>

			</section>
			<section id="closing-the-input-stream">
<h4 title="Closing the input stream">8.4.2. 入力~streamの~close法</h4>

<dl class="domintro">
	<dt>%document.`close()$m</dt>
	<dd>
`document.open()$c ~methodで~openされた入力~streamを~closeする。
◎
Closes the input stream that was opened by the document.open() method.
</dd>
	<dd>
次の場合、
`InvalidStateError$E 例外を投出する
⇒＃
`文書$は`~XML文書$である ／
`~custom要素~構築子$を現在~実行している
◎
Throws an "InvalidStateError" DOMException if the Document is an XML document.
◎
Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.
</dd>
</dl>

<div class="algo">
<p>
`Document$I の
`close()@m
~method手続きは：
◎
The close() method must run the following steps:
</p>
<ol>
	<li>
~IF［
コレは`~XML文書$である
］
⇒
~THROW `InvalidStateError$E
◎
If this is an XML document, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`動的~markup挿入-時には投出する~counter$ ~GT 0
］
⇒
~THROW `InvalidStateError$E
◎
If this's throw-on-dynamic-markup-insertion counter is greater than zero, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%構文解析器 ~LET コレの`~scriptにより作成された構文解析器$は［
在るならば それ ／
無いならば ε
］
◎
↓</li>
	<li>
~IF［
%構文解析器 ~EQ ε
］
⇒
~RET
◎
If there is no script-created parser associated with this, then return.
</li>
	<li>
%構文解析器 の`入力~stream$の終端に`明示的な~EOF$を挿入する
◎
Insert an explicit "EOF" character at the end of the parser's input stream.
</li>
	<li>
~IF［
コレの`構文解析器を阻んでいる~script$ ~NEQ ~NULL
］
⇒
~RET
◎
If this's pending parsing-blocking script is not null, then return.
</li>
	<li>
%構文解析器 の~tokenizerを走らす
⇒
~tokenizerから~tokenが発されるごとに，それを処理する。
［
~tokenizerが`明示的な~EOF$に達するか，`~event~loopを回す$
］時点で停止する。
◎
Run the tokenizer, processing resulting tokens as they are emitted, and stopping when the tokenizer reaches the explicit "EOF" character or spins the event loop.
</li>
</ol>
</div>

			</section>
			<section id="document.write()">
<h4 title="document.write()">8.4.3. `document.write()^c</h4>

<dl class="domintro">
	<dt>%document.`write(...text)$m</dt>
	<dd>
一般に，所与の文字列（たち）を`文書$の入力~streamに追加する。
◎
In general, adds the given string(s) to the Document's input stream.
</dd>
	<dd class="warning">
この~methodの挙動は、
とても特異的である。
一部の事例では、
`~HTML構文解析器$が走っている間に 構文解析器の状態に影響し得る
— その結果、
文書の~sourceに対応しない~DOMになり得る
（例：書込まれた文字列が `&lt;plaintext&gt;^l や `&lt;!--^l であった場合など）。
別の事例では、
`document.open()$c が~callされていたかのように，現在の~pageをまず~clearすることもある。
さらには、
単純に無視されたり, 例外を投出する事例もある。
~UAには、
この~methodを介して挿入された `script^e 要素に対しては，
`実行するのを避けることが明示的に許容される＠~HTMLparsing#document-written-scripts-intervention$。
この~methodの正確な挙動は、
~network待時間に依存する事例すらあり、
とても~debugし難い失敗へ導く。
<strong>
これらすべての理由から、
この~methodの利用は，強く忌避される。
</strong>
◎
This method has very idiosyncratic behavior. In some cases, this method can affect the state of the HTML parser while the parser is running, resulting in a DOM that does not correspond to the source of the document (e.g. if the string written is the string "&lt;plaintext&gt;" or "&lt;!--"). In other cases, the call can clear the current page first, as if document.open() had been called. In yet more cases, the method is simply ignored, or throws an exception. User agents are explicitly allowed to avoid executing script elements inserted via this method. And to make matters even worse, the exact behavior of this method can in some cases be dependent on network latency, which can lead to failures that are very hard to debug. For all these reasons, use of this method is strongly discouraged.
</dd>
	<dd>
次の場合、
`InvalidStateError$E 例外を投出する
⇒＃
`文書$は`~XML文書$である ／
`~custom要素~構築子$を現在~実行している
◎
Throws an "InvalidStateError" DOMException when invoked on XML documents.
◎
Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.
</dd>
</dl>

<p class="warning">
この~methodは、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
This method performs no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<p>
各 `文書$には
`破壊的な書込nは無視する~counter@
があり、
初期~時は 0 に設定するモノトスル。
この~counterは、
`script$e 要素の処理と併用され，［
外部~scriptが［
`document.write()$c を利用して，暗黙的に `document.open()$c を~callする
］ことにより文書を吹飛ばす
］ことを防止するために利用される。
◎
Document objects have an ignore-destructive-writes counter, which is used in conjunction with the processing of script elements to prevent external scripts from being able to use document.write() to blow away the document by implicitly calling document.open(). Initially, the counter must be set to zero.
</p>

<div class="algo">
<p>
`document.write 手続き@
は、
所与の
( `文書$ %文書, ~list %~text, 真偽値 %~LFを付加するか, 文字列 %~sink )
に対し：
◎
The document write steps, given a Document object document, a list text, a boolean lineFeed, and a string sink, are as follows:
</p>
<ol>
	<li>
~Assert：
%~text を成す各~itemは［
文字列／ `TrustedHTML$I ~obj
］である。
【この段は、この訳による補完。】
</li>
	<li>
%文字列 ~LET 空~文字列
◎
Let string be the empty string.
</li>
	<li>
%信用-済みか ~LET ~T
◎
↓ Let isTrusted be false if text contains a string; otherwise true.
</li>
	<li>
<p>
%~text を成す
~EACH( %値 )
に対し：
◎
For each value of text:
</p>
		<ol>
			<li>
~IF［
%値 は `TrustedHTML$I ~objである
］
⇒
%文字列 に %値 の`~data$tHを付加する
◎
If value is a TrustedHTML object, then append value's associated data to string.
</li>
			<li>
~ELSE
⇒＃
%文字列 に %値 を付加する；
%信用-済みか ~SET ~F
◎
Otherwise, append value to string.
</li>
		</ol>
	</li>
	<li>
~IF［
%信用-済みか ~EQ ~F
］
⇒
%文字列 ~SET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%文字列,
%~sink,
`script^l
◎
If isTrusted is false, set string to the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, string, sink, and "script".
</li>
	<li>
~IF［
%~LFを付加するか ~EQ ~T
］
⇒
%文字列 に `000A^U LINE FEED を付加する
◎
If lineFeed is true, append U+000A LINE FEED to string.
</li>
	<li>
~IF［
%文書 は`~XML文書$である
］
⇒
~THROW `InvalidStateError$E
◎
If document is an XML document, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%文書 の`動的~markup挿入-時には投出する~counter$ ~GT 0
］
⇒
~THROW `InvalidStateError$E
◎
If document's throw-on-dynamic-markup-insertion counter is greater than 0, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%文書 の`作動中な構文解析器は中止されたか$ ~EQ ~T
］
⇒
~RET
◎
If document's active parser was aborted is true, then return.
</li>
	<li>
<p>
~IF［
`挿入~地点$ ~EQ ε
］：
◎
If the insertion point is undefined, then:
</p>
		<ol>
			<li>
~IF［
%文書 の`~unload~counter$ ~GT 0
］~OR［
%文書 の`破壊的な書込nは無視する~counter$ ~GT 0
］
⇒
~RET
◎
If document's unload counter is greater than 0 or document's ignore-destructive-writes counter is greater than 0, then return.
</li>
			<li>
`document.open 手続き$( %文書 )
◎
Run the document open steps with document.
</li>
		</ol>
	</li>
	<li>
%文字列 を`入力~stream$内の`挿入~地点$に挿入する
◎
Insert string into the input stream just before the insertion point.
</li>
	<li>
<p>
~IF［
%文書 の`構文解析器を阻んでいる~script$ ~EQ ~NULL
］
⇒
%文字列 を`~HTML構文解析器$に処理させる
— 以下に従う下で：
◎
If document's pending parsing-blocking script is null, then have the HTML parser process string,＼
</p>
		<ul>
			<li>
符号位置を 1 個ずつ与え，結果の~tokenが発される度にそれを処理する。
◎
one code point at a time, processing resulting tokens as they are emitted,＼
</li>
			<li>
~tokenizerが挿入~地点に達したときは、
停止する。
◎
and stopping when the tokenizer reaches the insertion point＼
</li>
			<li>
~tokenizerの処理が ~tree構築~段階にて中止されたときは、
停止する
（これは、
`script$e 終了~tag~tokenが~tokenizerにより発された場合に起こり得る）。
◎
or when the processing of the tokenizer is aborted by the tree construction stage (this can happen if a script end tag token is emitted by the tokenizer).
</li>
		</ul>

<p class="note">注記：
`document.write()$c が，~inlineに実行している~scriptから~callされた場合
（すなわち，構文解析器が `script$e を終了~tagまで構文解析したことにより，~callされた）、
これは，`構文解析器の再入呼出し＠~HTMLparsing#nestedParsing$になる。
［
構文解析器の`静止するか$ ~EQ ~T
］の場合、［
~tokenizerにおける`静止するかの検査＠~HTMLparsing#check-parser-pause-flag$
］により，［
~tokenizerは即時に中止され，~HTMLは構文解析されない
］ことになる。
◎
If the document.write() method was called from script executing inline (i.e. executing because the parser parsed a set of script tags), then this is a reentrant invocation of the parser. If the parser pause flag is set, the tokenizer will abort immediately and no HTML will be parsed, per the tokenizer's parser pause flag check.
</p>
	</li>
</ol>
</div>

<div class="algo">
`Document$I の
`write(...text)@m
~method手続きは
⇒
`document.write 手続き$( コレ, %text, ~F, `Document write^l )
◎
The document.write(...text) method steps are to run the document write steps with this, text, false, and "Document write".
</div>

			</section>
			<section id="document.writeln()">
<h4 title="document.writeln()">8.4.4. `document.writeln()^c</h4>

<dl class="domintro">
	<dt>%document.`writeln(...text)$m</dt>
	<dd>
所与の文字列（たち）を
`文書$の入力~streamに追加した上で、
改行文字も追加する。
必要yなら， `open()$m ~methodも暗黙的に~callする。
◎
Adds the given string(s) to the Document's input stream, followed by a newline character. If necessary, calls the open() method implicitly first.
</dd>
	<dd class="warning">
この~methodの挙動は、
とても特異的である。
<strong>
`document.write()$c と同じ理由から、
この~methodの利用は，強く忌避される。
</strong>
◎
This method has very idiosyncratic behavior. Use of this method is strongly discouraged, for the same reasons as document.write().
</dd>
	<dd>
次の場合、
`InvalidStateError$E 例外を投出する
⇒＃
`文書$は`~XML文書$である ／
`~custom要素~構築子$を現在~実行している
◎
Throws an "InvalidStateError" DOMException when invoked on XML documents.
◎
Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.
</dd>
</dl>

<p class="warning">
この~methodは、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
This method performs no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<div class="algo">
`Document$I の
`writeln(...text)@m
~method手続きは
⇒
`document.write 手続き$( コレ, %text, ~T, `Document writeln^l )
◎
The document.writeln(...text) method steps are to run the document write steps with this, text, true, and "Document writeln".
</div>

			</section>
		</section>
		<section id="dom-parsing-and-serialization">
<h3 title="DOM parsing and serialization APIs">8.5. ~DOMの構文解析~APIと直列化~API</h3>

<pre class="idl">
partial interface <span id="Element-partial">`Element$I</span> {
  [`CEReactions$] undefined `setHTMLUnsafe$m((`TrustedHTML$I or DOMString) %html);
  DOMString `getHTML$m(optional `GetHTMLOptions$I %options = {});

  [`CEReactions$] attribute (`TrustedHTML$I or [`LegacyNullToEmptyString$] DOMString) `innerHTML$m;
  [`CEReactions$] attribute (`TrustedHTML$I or [`LegacyNullToEmptyString$] DOMString) `outerHTML$m;
  [`CEReactions$] undefined `insertAdjacentHTML$m(DOMString position, (`TrustedHTML$I or DOMString) %string);
};

partial interface <span id="ShadowRoot-partial">`ShadowRoot$I</span> {
  [`CEReactions$] undefined `setHTMLUnsafe$m1((`TrustedHTML$I or DOMString) %html);
  DOMString `getHTML$m1(optional `GetHTMLOptions$I options = {});

  [`CEReactions$] attribute (`TrustedHTML$I or [`LegacyNullToEmptyString$] DOMString) `innerHTML$m1;
};

dictionary `GetHTMLOptions@I {
  boolean `serializableShadowRoots@mb = false;
  sequence&lt;`ShadowRoot$I&gt; `shadowRoots@mb = [];
};
</pre>

			<section id="the-domparser-interface">
<h4 title="The DOMParser interface">8.5.1. `DOMParser^I ~interface</h4>

<p>
`DOMParser$I ~interfaceは、
文字列を［
~HTML／~XML
］として構文解析して，新たな`文書$を作成することを，作者に許容する。
◎
The DOMParser interface allows authors to create new Document objects by parsing strings, as either HTML or XML.
</p>

<dl class="domintro">
	<dt>%parser = `new DOMParser()$m<dt>
	<dd>
新たな `DOMParser$I ~objを構築する。
◎
Constructs a new DOMParser object.
</dd>

	<dt>%document = %parser.`parseFromString$m( %string, %type )</dt>
	<dd>
%string を［
%type に則って［
~HTML構文解析器, ~XML構文解析器
］いずれか
］を利用する下で構文解析して，結果の`文書$を返す。
◎
Parses string using either the HTML or XML parser, according to type, and returns the resulting Document.＼
</dd>
	<dd>
%type は、
次に挙げるいずれかをとり得る
⇒＃
`text/html$mt,
`text/xml$mt,
`application/xml$mt,
`application/xhtml+xml$mt,
`image/svg+xml$mt
◎終
これらのうち［
`text/html^mt は~HTML構文解析器／
他は~XML構文解析器
］を呼出すことになる。
◎
type can be "text/html" (which will invoke the HTML parser), or any of "text/xml", "application/xml", "application/xhtml+xml", or "image/svg+xml" (which will invoke the XML parser).
</dd>
	<dd>
~XML構文解析器においては、
%string を構文解析できない場合に返される`文書$は，
結果の~errorを述べている要素たちを包含することになる。
◎
For the XML parser, if string cannot be parsed, then the returned Document will contain elements describing the resulting error.
</dd>
	<dd>
構文解析の間は， `script$e 要素は評価されないことに加え、
結果の文書の`符号化法$docは，常に`~UTF-8$になることに注意。
文書の`~URL$docは， %parser に`関連な大域~obj$から継承されることになる。
◎
Note that script elements are not evaluated during parsing, and the resulting document's encoding will always be UTF-8. The document's URL will be inherited from parser's relevant global object.
</dd>
	<dd>
上に挙げたもの以外の %type 値は、
【 `DOMParserSupportedType$I 値でないので，】
`TypeError^E 例外を投出させることになる。
◎
Values other than the above for type will cause a TypeError exception to be thrown.
</dd>
</dl>

<p class="note">注記：
`DOMParser$I の設計が，~classとして構築してから `parseFromString()$m ~methodを~callする必要があるのは、
不幸な歴史的~遺物である。
この機能性を今日~設計するなら，自立的な関数にするであろう。
~HTMLを構文解析するための現代の代替は、
`Document$I の `parseHTMLUnsafe()$m である。
◎
The design of DOMParser, as a class that needs to be constructed and then have its parseFromString() method called, is an unfortunate historical artifact. If we were designing this functionality today it would be a standalone function. For parsing HTML, the modern alternative is Document.parseHTMLUnsafe().
</p>

<p class="warning">
この~methodは、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
This method performs no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<pre class="idl">
[Exposed=Window]
interface `DOMParser@I {
  `constructor＠#dom-domparser-constructor$();

  [NewObject] `Document$I `parseFromString$m((`TrustedHTML$I or DOMString) %string, `DOMParserSupportedType$I %type);
};

enum `DOMParserSupportedType@I {
  `text/html$l,
  `text/xml$l,
  `application/xml$l,
  `application/xhtml+xml$l,
  `image/svg+xml$l
};
</pre>


<div class="algo">
`new DOMParser()@m
構築子~手続きは、
何もしない。
◎
The new DOMParser() constructor steps are to do nothing.
</div>

<div class="algo">
<p>
`parseFromString(string, type)@m
~method手続きは：
◎
The parseFromString(string, type) method steps are:
</p>
<ol>
	<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%string,
`DOMParser parseFromString^l,
`script^l
◎
Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, string, "DOMParser parseFromString", and "script".
</li>
	<li>
<p>
%文書 ~LET 新たな`文書$
— その
⇒＃
`内容~型$doc ~SET %type,
`~URL$doc ~SET コレに`関連な大域~obj$に`結付けられた文書$の`~URL$doc
◎
Let document be a new Document, whose content type is type and URL is this's relevant global object's associated Document's URL.
</p>

<p class="note">
%文書 の`符号化法$docは、
既定の`~UTF-8$のままにされることになる。
特に， %準拠な文字列 を構文解析する間に見出された どの［
~XML宣言／ `meta$e 要素
］にも効果は無い。
◎
The document's encoding will be left as its default, of UTF-8. In particular, any XML declarations or meta elements found while parsing compliantString will have no effect.
</p>
	</li>
	<li>
<p>
~IF［
%type ~EQ
`text/html@l
］
⇒
`文字列から~HTMLを構文解析する$( %文書, %準拠な文字列 )
◎
Switch on type:
◎
"text/html"
• Parse HTML from a string given document and compliantString.
</p>

<p class="note">注記：
%文書 が`属する閲覧~文脈$は無いので、
%文書 用の`~scriptingは不能化される＠~WAPI#concept-n-noscript$。
◎
Since document does not have a browsing context, scripting is disabled.
</p>
	</li>
	<li>
<p id="dom-domparsersupportedtype-otherwise">
~ELSE：
◎
Otherwise
</p>
		<ol>
			<li>
%構文解析器 ~LET 新たな`~XML構文解析器$
— その`~XML~scriptingの~supportは不能化する＠~HTMLxml#xml-scripting-support-disabled$
◎
Create an XML parser parser, associated with document, and with XML scripting support disabled.
</li>
			<li>
%構文解析器 を %文書 に結付ける
◎
↑</li>
			<li>
%構文解析器 を利用して %準拠な文字列 を構文解析する
◎
Parse compliantString using parser.
</li>
			<li>
<p>
~IF［
前~段の結果は［
~XML整形式性 ／ ~XML名前空間 整形式性
］~errorになった
］：
◎
If the previous step resulted in an XML well-formedness or XML namespace well-formedness error, then:
</p>
				<ol>
					<li>
~Assert：
%文書 には子~nodeは無い。
◎
Assert: document has no child nodes.
</li>
					<li>
%根 ~LET `要素を作成する$( %文書, `parsererror^l, `http://www.mozilla.org/newlayout/xml/parsererror.xml^l )
◎
Let root be the result of creating an element given document, "parsererror", and "http://www.mozilla.org/newlayout/xml/parsererror.xml".
</li>
					<li>
任意選択で
⇒
構文解析~errorの資質を述べるような属性や子を %根 に追加する
◎
Optionally, add attributes or children to root to describe the nature of the parsing error.
</li>
					<li>
%文書 に`~nodeを付加する$( %根 )
◎
Append root to document.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="algo">
<p>
`文字列から~HTMLを構文解析する@
~algoは、
所与の
( `文書$ %文書, `文字列$ %~HTML )
に対し：
◎
To parse HTML from a string, given a document Document and a string html:
</p>
<ol>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
Set document's type to "html".
</li>
	<li>
%構文解析器 ~LET 新たな`~HTML構文解析器$
— その
⇒
`符号化法の確度$ ~SET `無関連^i
◎
↓</li>
	<li>
%構文解析器 を %文書 に結付ける
◎
↓</li>
	<li>
%構文解析器 の`入力~stream$の中へ %~HTML を設置する
◎
Create an HTML parser parser, associated with document.
◎
↑ Place html into the input stream for parser.＼
The encoding confidence is irrelevant.
</li>
	<li>
<p>
%構文解析器 を開始して，挿入した %文字列 を成すすべての文字を消費するまで走らす
◎
Start parser and let it run until it has consumed all the characters just inserted into the input stream.
</p>

<p class="note">注記：
文書の`~mode$docは、
この段で変異するかもしれない。
◎
This might mutate the document's mode.
</p>
	</li>
</ol>
</div>
			</section>
			<section id="unsafe-html-parsing-methods">
<h4 title="Unsafe HTML parsing methods">8.5.2. 安全でない~HTML構文解析~method</h4>

<dl class="domintro">
	<dt>%element.`setHTMLUnsafe(html)$m</dt>
	<dd>
~HTML構文解析器を利用して %html を構文解析する
— その結果で %element の子~群を置換する。
%element が，当の~HTML構文解析器~用の文脈を供する。
◎
Parses html using the HTML parser, and replaces the children of element with the result. element provides context for the HTML parser.
</dd>

	<dt>%shadowRoot.`setHTMLUnsafe(html)$m1</dt>
	<dd>
~HTML構文解析器を利用して %html を構文解析する
— その結果で %shadowRoot の子~群を置換する。
%shadowRoot の`~host$が，当の~HTML構文解析器~用の文脈を供する。
◎
Parses html using the HTML parser, and replaces the children of shadowRoot with the result. shadowRoot's host provides context for the HTML parser.
</dd>

	<dt>%doc = `Document$I.`parseHTMLUnsafe(html)$m</dt>
	<dd>
~HTML構文解析器を利用して %html を構文解析した結果の`文書$を返す。
◎
Parses html using the HTML parser, and returns the resulting Document.
</dd>
	<dd>
`script$e 要素は構文解析する間に評価されないことに加え，
結果の文書の`符号化法$docは常に `~UTF-8$ になることに注意。
文書の`~URL$docは `~about_blank$sc になる。
◎
Note that script elements are not evaluated during parsing, and the resulting document's encoding will always be UTF-8. The document's URL will be about:blank.
</dd>
</dl>

<p class="warning">
これらの~methodは、［
`script$e や `~event~handler内容~属性$の様な危険になり得る要素や属性
］を除去するための無毒化を遂行しない。
◎
These methods perform no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<div class="algo">
<p>
`Element$I の
`setHTMLUnsafe(html)@m
~method手続きは：
◎
Element's setHTMLUnsafe(html) method steps are:
</p>
<ol>
	<li>
%準拠な~HTML ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%html,
`Element setHTMLUnsafe^l,
`script^l
◎
Let compliantHTML be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, html, "Element setHTMLUnsafe", and "script".
</li>
	<li>
%~target ~LET コレ
◎
↓</li>
	<li>
~IF［
コレは `template$e 要素である
］
⇒
%~target ~LET コレの`~template内容$
◎
Let target be this's template contents if this is a template element; otherwise this.
</li>
	<li>
`~HTMLを安全でなく設定する$( %~target, コレ, %準拠な~HTML )
◎
Unsafely set HTML given target, this, and compliantHTML.
</li>
</ol>
</div>

<div class="algo">
<p>
`ShadowRoot$I の
`setHTMLUnsafe(html)@m1
~method手続きは：
◎
ShadowRoot's setHTMLUnsafe(html) method steps are:
</p>
<ol>
	<li>
%準拠な~HTML ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%html,
`ShadowRoot setHTMLUnsafe^l,
`script^l
◎
Let compliantHTML be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, html, "ShadowRoot setHTMLUnsafe", and "script".
</li>
	<li>
`~HTMLを安全でなく設定する$( コレ, コレの`~host$, %準拠な~HTML )
◎
Unsafely set HTML given this, this's shadow host, and compliantHTML.
</li>
</ol>
</div>

<div class="algo">
<p>
`~HTMLを安全でなく設定する@
~algoは、
所与の
( ［
`要素$／`文書片$
］ %~target, `要素$ %文脈~要素, `文字列$ %~HTML )
に対し：
◎
To unsafely set HTML, given an Element or DocumentFragment target, an Element contextElement, and a string html:
</p>
<ol>
	<li>
%新たな子~群 ~LET `~HTML素片の構文解析~algo$( %文脈~要素, %~HTML, ~T )
◎
Let newChildren be the result of the HTML fragment parsing algorithm given contextElement, html, and true.
</li>
	<li>
%文書片 ~LET 新たな`文書片$
— その
⇒＃
`~node文書$ ~SET %文脈~要素 の`~node文書$
◎
Let fragment be a new DocumentFragment whose node document is contextElement's node document.
</li>
	<li>
%新たな子~群 を成す
~EACH( %~node )
に対し
⇒
%文書片 に`~nodeを付加する$( %~node )
◎
For each node in newChildren, append node to fragment.
</li>
	<li>
%~target の`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment within target.
</li>
</ol>

</div>

<hr>

<div class="algo">
<p>
静的な
`parseHTMLUnsafe(html)@m
~method手続きは：
◎
The static parseHTMLUnsafe(html) method steps are:
</p>
<ol>
	<li>
%準拠な~HTML ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%html,
`Document parseHTMLUnsafe^l,
`script^l
◎
Let compliantHTML be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, html, "Document parseHTMLUnsafe", and "script".
</li>
	<li>
<p>
%文書 ~LET 新たな`文書$
— その
⇒＃
`内容~型$doc ~SET `text/html^l
◎
Let document be a new Document, whose content type is "text/html".
</p>

<p class="note">注記：
%文書 が`属する閲覧~文脈$は無いので、
%文書 用の`~scriptingは不能化される＠~WAPI#concept-n-noscript$。
◎
Since document does not have a browsing context, scripting is disabled.
</p>
	</li>
	<li>
%文書 の`宣言的な~shadow根を許容するか$doc ~SET ~T
◎
Set document's allow declarative shadow roots to true.
</li>
	<li>
`文字列から~HTMLを構文解析する$( %文書, %準拠な~HTML )
◎
Parse HTML from a string given document and compliantHTML.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

			</section>
			<section id="html-serialization-methods">
<h4 title="HTML serialization methods">8.5.3 ~HTMLの直列化~method</h4>

<dl class="domintro">
	<dt>%html = %element.`getHTML(options)$m
◎
html = element.getHTML({ serializableShadowRoots, shadowRoots })
</dt>
	<dd>
<p>
%element を~HTMLへ直列化した結果を返す。
%element の中の各`~shadow根$は、
供された各~optionに則って直列化される：
◎
Returns the result of serializing element to HTML. Shadow roots within element are serialized according to the provided options:
</p>
		<ul>
			<li>
%options[ "`serializableShadowRoots$mb" ] ~EQ ~T
の場合、
次を満たす~shadow根は，すべて直列化される
⇒
`直列化-可能か$sR ~EQ ~T
◎
If serializableShadowRoots is true, then all shadow roots marked as serializable are serialized.
</li>
			<li>
%options[ "`shadowRoots$mb" ] に供された配列~内に指定された すべての~shadow根は、
その`直列化-可能か$sRを問わず，直列化される。
◎
If the shadowRoots array is provided, then all shadow roots specified in the array are serialized, regardless of whether or not they are marked as serializable.
</li>
		</ul>
<p>
どちらの~optionも供されなかった場合、
直列化される~shadow根は無い。
◎
If neither option is provided, then no shadow roots are serialized.
</p>
	</dd>

	<dt>
%html = %shadowRoot.`getHTML(options)$m1
◎
html = shadowRoot.getHTML({ serializableShadowRoots, shadowRoots })
</dt>
	<dd>
%shadowRoot を~HTMLへ直列化した結果を返す
— 文脈~要素として %shadowRoot の`~host$を利用する下で。
%shadowRoot の中の`~shadow根$は、
上と同じく，供された各~optionに則って直列化される。
◎
Returns the result of serializing shadowRoot to HTML, using its shadow host as the context element. Shadow roots within shadowRoot are serialized according to the provided options, as above.
</dd>
</dl>

<div class="algo">
`Element$I の
`getHTML(options)@m
~method手続きは
⇒
~RET `~HTML素片~直列化~algo$( コレ, %options[ "`serializableShadowRoots$mb" ], %options[ "`shadowRoots$mb" ] )
◎
Element's getHTML(options) method steps are to return the result of HTML fragment serialization algorithm with this, options["serializableShadowRoots"], and options["shadowRoots"].
</div>

<div class="algo">
`ShadowRoot$I の
`getHTML(options)@m1
~method手続きは
⇒
~RET `~HTML素片~直列化~algo$( コレ, %options[ "`serializableShadowRoots$mb" ], %options[ "`shadowRoots$mb" ] )
◎
ShadowRoot's getHTML(options) method steps are to return the result of HTML fragment serialization algorithm with this, options["serializableShadowRoots"], and options["shadowRoots"].
</div>

			</section>
			<section id="the-innerhtml-property">
<h4 title="The innerHTML property">8.5.4. `innerHTML^m ~prop</h4>

<p class="XXX">
`innerHTML$m ~propには、
`DOMPARSING$r の`課題~追跡器＠https://github.com/w3c/DOM-Parsing/issues$において，いくつか未決な課題がある
— そこには、
その仕様に伴われる様々な問題が文書化されている。
◎
The innerHTML property has a number of outstanding issues in the DOM Parsing and Serialization issue tracker, documenting various problems with its specification.
</p>

<dl class="domintro">
	<dt>%element.`innerHTML$m</dt>
	<dd>
%element の内容を表現する［［
~HTML／~XML
］を成す素片
］を返す。
◎
Returns a fragment of HTML or XML that represents the element's contents.
</dd>
	<dd>
~XML文書の事例では、
%element を~XMLへ直列化できない場合には，
`InvalidStateError$E 例外を投出する。
◎
In the case of an XML document, throws an "InvalidStateError" DOMException if the element cannot be serialized to XML.
</dd>

	<dt>%element.`innerHTML$m = %value</dt>
	<dd>
所与の文字列を構文解析した結果の~nodeたちで， %element の内容を置換する。
◎
Replaces the contents of the element with nodes parsed from the given string.
</dd>
	<dd>
~XML文書の事例では、
所与の文字列は整形式でない場合には，
`SyntaxError$E 例外を投出する。
◎
In the case of an XML document, throws a "SyntaxError" DOMException if the given string is not well-formed.
</dd>


	<dt>%shadowRoot.`innerHTML$m1</dt>
	<dd>
%element の内容を表現する［
~HTMLを成す素片
］を返す。
◎
Returns a fragment of HTML that represents the shadow roots's contents.
</dd>

	<dt>%shadowRoot.`innerHTML$m1 = %value</dt>
	<dd>
所与の文字列を構文解析した結果の~nodeたちで，
%shadowRoot の内容を置換する。
◎
Replaces the contents of the shadow root with nodes parsed from the given string.
</dd>
</dl>

<p class="warning">
これらの~propの設定子は、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
These properties' setters perform no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<div class="algo">
`素片に直列化する@
~algoは、
所与の
( ［
`要素$／`文書$／`文書片$
］ %~node, 真偽値 %整形式が要求されるか )
に対し
⇒
~RET %~node の`~node文書$に応じて
⇒＃
`~HTML文書$であるならば `~HTML素片~直列化~algo$( %~node, ~F, « » ) ／
`~XML文書$であるならば `~XML直列化$( %~node, %整形式が要求されるか )
◎
The fragment serializing algorithm steps, given an Element, Document, or DocumentFragment node and a boolean require well-formed, are:
• Let context document be node's node document.
• If context document is an HTML document, return the result of HTML fragment serialization algorithm with node, false, and « ».
• Return the XML serialization of node given require well-formed.
</div>

<div class="algo">
<p>
`素片を構文解析する@
~algoは、
所与の
( `要素$ %文脈, 文字列 %~markup )
に対し：
◎
The fragment parsing algorithm steps, given an Element context and a string markup, are:
</p>
<ol>
	<li>
%~algo ~LET %文脈 の`~node文書$に応じて
⇒＃
`~HTML文書$であるならば `~HTML素片の構文解析~algo$ ／
`~XML文書$であるならば `~XML素片の構文解析~algo$
◎
Let algorithm be the HTML fragment parsing algorithm.
◎
If context's node document is an XML document, then set algorithm to the XML fragment parsing algorithm.
</li>
	<li>
%新たな子~群 ~LET %~algo( %文脈, %~markup )
◎
Let newChildren be the result of invoking algorithm given context and markup.
</li>
	<li>
%文書片 ~LET 新たな`文書片$
— その
⇒
`~node文書$ ~SET %文脈 の`~node文書$
◎
Let fragment be a new DocumentFragment whose node document is context's node document.
</li>
	<li>
<p>
%新たな子~群 を成す
~EACH( %~node )
に対し，`~tree順序$で
⇒
%文書片 に`~nodeを付加する$( %~node )
◎
For each node of newChildren, in tree order: append node to fragment.
</p>

<p class="note">注記：
これは、
%~node 用の`~node文書$が正しくなることを確保する。
◎
This ensures the node document for the new nodes is correct.
</p>
	</li>
	<li>
~RET %文書片
◎
Return fragment.
</li>
</ol>
</div>

<p>
`Element$I の
`innerHTML@m
属性の
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは
⇒
~RET `素片に直列化する$( コレ, ~T )
◎
Element's innerHTML getter steps are to return the result of running fragment serializing algorithm steps with this and true.
◎
↓ ShadowRoot's innerHTML getter steps are to return the result of running fragment serializing algorithm steps with this and true.
</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
Element's innerHTML setter steps are:
</p>
		<ol>
			<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
所与の値,
`Element innerHTML^l,
`script^l
◎
Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, the given value, "Element innerHTML", and "script".
</li>
			<li>
%文脈 ~LET コレ
◎
Let context be this.
</li>
			<li>
%文書片 ~LET `素片を構文解析する$( %文脈, %準拠な文字列 )
◎
Let fragment be the result of invoking the fragment parsing algorithm steps with context and compliantString.
</li>
			<li>
<p>
~IF［
%文脈 は `template$e 要素である
］
⇒
%文脈 ~SET %文脈 の`~template内容$
（ある`文書片$）
◎
If context is a template element, then set context to the template element's template contents (a DocumentFragment).
</p>

<p class="note">注記：
`template$e 要素に対し `innerHTML$m を設定した場合、
その`子~群$ではなく，その`~template内容$を成すすべての~nodeを置換することになる。
◎
Setting innerHTML on a template element will replace all the nodes in its template contents rather than its children.
</p>
			</li>
			<li>
%文脈 の`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment within context.
</li>
		</ol>
	</li>
</ul>

<p>
`ShadowRoot$I の
`innerHTML@m1
属性の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET `素片に直列化する$( コレ, ~T )
◎
↑</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
ShadowRoot's innerHTML setter steps are:
</p>
		<ol>
			<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
所与の値,
`ShadowRoot innerHTML^l,
`script^l
◎
Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, the given value, "ShadowRoot innerHTML", and "script".
</li>
			<li>
%文脈 ~LET コレの`~host$
◎
Let context be this's host.
</li>
			<li>
%文書片 ~LET `素片を構文解析する$( %文脈, %準拠な文字列 )
◎
Let fragment be the result of invoking the fragment parsing algorithm steps with context and compliantString.
</li>
			<li>
コレの`全~内容を~nodeで置換する$( %文書片 )
◎
Replace all with fragment within this.
</li>
		</ol>
	</li>
</ul>

			</section>
			<section id="the-outerhtml-property">
<h4 title="The outerHTML property">8.5.5. `outerHTML^m ~prop</h4>

<p class="XXX">
`outerHTML$m ~propには、
`DOMPARSING$r の`課題~追跡器＠https://github.com/w3c/DOM-Parsing/issues$において，いくつか未決な課題がある
— そこには、
その仕様に伴われる様々な問題が文書化されている。
◎
The outerHTML property has a number of outstanding issues in the DOM Parsing and Serialization issue tracker, documenting various problems with its specification.
</p>

<dl class="domintro">
	<dt>%element.`outerHTML$m</dt>
	<dd>
［
%element とその内容
］を表現する［［
~HTML／~XML
］を成す素片
］を返す。
◎
Returns a fragment of HTML or XML that represents the element and its contents.
</dd>
	<dd>
~XML文書の事例では、
%element を~XMLに直列化できない場合，
`InvalidStateError$E 例外が投出される。
◎
In the case of an XML document, throws an "InvalidStateError" DOMException if the element cannot be serialized to XML.
</dd>

	<dt>%element.`outerHTML$m = %value</dt>
	<dd>
%element を［
所与の文字列から構文解析した結果の~nodeたち
］で置換する。
◎
Replaces the element with nodes parsed from the given string.
</dd>
	<dd>
~XML文書の事例では、
所与の文字列は整形式でない場合，
`SyntaxError$E 例外が投出される。
◎
In the case of an XML document, throws a "SyntaxError" DOMException if the given string is not well-formed.
</dd>
	<dd>
%element の親は`文書$である場合、
`NoModificationAllowedError$E 例外が投出される。
◎
Throws a "NoModificationAllowedError" DOMException if the parent of the element is a Document.
</dd>
</dl>

<p class="warning">
この~propの設定子は、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
This property's setter performs no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<p>
`Element$I の
`outerHTML@m
属性の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
Element's outerHTML getter steps are:
</p>
		<ol>
			<li>
%文書片 ~LET 新たな`文書片$
— その
⇒
`~node文書$ ~SET コレの`~node文書$
◎
Let element be a fictional node＼
</li>
			<li>
%文書片 に`~nodeを付加する$( コレ )
◎
whose only child is this.
</li>
			<li>
~RET `素片に直列化する$( %文書片, ~T )
◎
Return the result of running fragment serializing algorithm steps with element and true.
</li>
		</ol>

<p class="trans-note">【
%文書片 は、
要素~自身の~tagも含めて直列化するために必要になる
— これは、
原文では “`fictional node^en （架空な~node）” としか記されていないが，
`文書片$で用を成すであろう。
】</p>
	</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
Element's outerHTML setter steps are:
</p>
		<ol>
			<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
所与の値,
`Element outerHTML^l,
`script^l
◎
Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, the given value, "Element outerHTML", and "script".
</li>
			<li>
%親 ~LET コレの`親$
◎
Let parent be this's parent.
</li>
			<li>
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
（以降の手続きを走らせても，作成される~nodeへの参照を得する仕方はないので。）
◎
If parent is null, return. There would be no way to obtain a reference to the nodes created even if the remaining steps were run.
</li>
			<li>
~IF［
%親 は`文書$である
］
⇒
~THROW `NoModificationAllowedError$E
◎
If parent is a Document, throw a "NoModificationAllowedError" DOMException.
</li>
			<li>
~IF［
%親 は`文書片$である
］
⇒
%親 ~LET `要素を作成する$( コレの`~node文書$, `body^l, `~HTML名前空間$ )
◎
If parent is a DocumentFragment, set parent to the result of creating an element given this's node document, "body", and the HTML namespace.
</li>
			<li>
%文書片 ~LET `素片を構文解析する$( %親, %準拠な文字列 )
◎
Let fragment be the result of invoking the fragment parsing algorithm steps given parent and compliantString.
</li>
			<li>
コレの`親$の中で`子を~nodeに置換する$( コレ, %文書片 )
◎
Replace this with fragment within this's parent.
</li>
		</ol>
	</li>
</ul>

			</section>
			<section id="the-insertadjacenthtml()-method">
<h4 title="The insertAdjacentHTML() method">8.5.6. `insertAdjacentHTML()^m ~method</h4>

<p class="XXX">
`insertAdjacentHTML()$m ~methodには、
`DOMPARSING$r の`課題~追跡器＠https://github.com/w3c/DOM-Parsing/issues$において，いくつか未決な課題がある
— そこには、
その仕様に伴われる様々な問題が文書化されている。
◎
The insertAdjacentHTML() method has a number of outstanding issues in the DOM Parsing and Serialization issue tracker, documenting various problems with its specification.
</p>

<dl class="domintro">
	<dt>%element.`insertAdjacentHTML(position, string)$m</dt>
	<dd>
<p>
%string を［
~HTML／~XML
］として構文解析した上で、
その結果の~nodeを［
%position に応じて次に与える位置
］に挿入する：
◎
Parses string as HTML or XML and inserts the resulting nodes into the tree in the position given by the position argument, as follows:
</p>
		<dl>
			<dt>`beforebegin^l</dt>
			<dd>
%element の前
（すなわち，直前の同胞との合間）
◎
Before the element itself (i.e., after element's previous sibling)
</dd>

			<dt>`afterbegin^l</dt>
			<dd>
%element の内側の先頭
（すなわち，最初の子の前）
◎
Just inside the element, before its first child.
</dd>

			<dt>`beforeend^l</dt>
			<dd>
%element の内側の末尾
（すなわち，最後の子の後）
◎
Just inside the element, after its last child.
</dd>

			<dt>`afterend^l</dt>
			<dd>
%element の後
（すなわち，直後の同胞との合間）
◎
After the element itself (i.e., before element's next sibling)
</dd>
		</dl>
	</dd>
	<dd>
引数の値が妥当でない場合、
`SyntaxError$E 例外が投出される
（例：`~XML文書$の事例では、
所与の文字列が整形式でない場合）。
◎
Throws a "SyntaxError" DOMException if the arguments have invalid values (e.g., in the case of an XML document, if the given string is not well-formed).
</dd>
	<dd>
所与の位置に挿入し得ない場合、
`NoModificationAllowedError$E 例外が投出される
（例： `文書$の根~要素の後に要素を挿入しようとしたとき）。
◎
Throws a "NoModificationAllowedError" DOMException if the given position isn't possible (e.g. inserting elements after the root element of a Document).
</dd>
</dl>

<p class="warning">
この~methodは、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
This method performs no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<p>
`Element$I の
`insertAdjacentHTML(position, string)@m
~method手続きは：
◎
Element's insertAdjacentHTML(position, string) method steps are:
</p>
<ol>
	<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%string,
`Element insertAdjacentHTML^l,
`script^l
◎
Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, string, "Element insertAdjacentHTML", and "script".
</li>
	<li>
%文脈 ~LET ~NULL
◎
Let context be null.
</li>
	<li>
%position ~LET `~ASCII小文字~化する$( %position )
◎
↓</li>
	<li>
<p>
%position に応じて：
◎
Use the first matching item from this list:
</p>
		<dl class="switch">
			<dt>
`beforebegin^l
◎
If position is an ASCII case-insensitive match for the string "beforebegin"
</dt>
			<dt>
`afterend^l
◎
If position is an ASCII case-insensitive match for the string "afterend"
</dt>
			<dd>
				<ol>
					<li>
%文脈 ~SET コレの`親$
◎
Set context to this's parent.
</li>
					<li>
~IF［
%文脈 ~EQ ~NULL
］~OR［
%文脈 は`文書$である
］
⇒
~THROW `NoModificationAllowedError$E
◎
If context is null or a Document, throw a "NoModificationAllowedError" DOMException.
</li>
				</ol>
			</dd>

			<dt>
`afterbegin^l
◎
If position is an ASCII case-insensitive match for the string "afterbegin"
</dt>
			<dt>
`beforeend^l
◎
If position is an ASCII case-insensitive match for the string "beforeend"
</dt>
			<dd>
%文脈 ~SET コレ
◎
Set context to this.
</dd>

			<dt>
他の場合
◎
Otherwise
</dt>
			<dd>
~THROW `SyntaxError$E
◎
Throw a "SyntaxError" DOMException.
</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
%文脈 は`要素$でない
］~OR［
~AND↓
］…
◎
If context is not an Element or all of the following are true:
</p>
		<ul>
			<li>
%文脈 の`~node文書$は`~HTML文書$である
◎
context's node document is an HTML document;
</li>
			<li>
%文脈 の`局所~名$el ~EQ "`html$e"
◎
context's local name is "html"; and
</li>
			<li>
%文脈 の`名前空間$el ~EQ `~HTML名前空間$
◎
context's namespace is the HTML namespace,
</li>
		</ul>
<p>
…ならば
⇒
%文脈 ~SET `要素を作成する$( コレの`~node文書$, `body^l, `~HTML名前空間$ )
◎
then set context to the result of creating an element given this's node document, "body", and the HTML namespace.
</p>
	</li>
	<li>
%文書片 ~LET `素片を構文解析する$( %文脈, %準拠な文字列 )
◎
Let fragment be the result of invoking the fragment parsing algorithm steps with context and compliantString.
</li>
	<li>
<p>
%position に応じて：
◎
Use the first matching item from this list:
</p>
		<dl class="switch">
			<dt>
`beforebegin^l
◎
If position is an ASCII case-insensitive match for the string "beforebegin"
</dt>
			<dd>
コレの`親$の中で`~nodeを子の前に挿入する$( %文書片, コレ )
◎
Insert fragment into this's parent before this.
</dd>
			<dt>
`afterbegin^l
◎
If position is an ASCII case-insensitive match for the string "afterbegin"
</dt>
			<dd>
コレの中で`~nodeを子の前に挿入する$( %文書片, コレの`最初の子？$ )
◎
Insert fragment into this before its first child.
</dd>
			<dt>
`beforeend^l
◎
If position is an ASCII case-insensitive match for the string "beforeend"
</dt>
			<dd>
コレに`~nodeを付加する$( %文書片 )
◎
Append fragment to this.
</dd>
			<dt>
`afterend^l
◎
If position is an ASCII case-insensitive match for the string "afterend"
</dt>
			<dd>
コレの`親$の中で`~nodeを子の前に挿入する$( %文書片, コレの`直後の同胞？$ )
◎
Insert fragment into this's parent before this's next sibling.
</dd>
		</dl>
	</li>
</ol>

<p class="note">注記：
`~node$を直に操作する他の~APIと同じく（および `innerHTML$m とは違って ）、
`insertAdjacentHTML()$m は， `template$e 要素 %要素 に対する特別な取扱いを含まない。
ほとんどの事例では、
%要素 の子~nodeたちを直に操作する代わりに，
%要素 の`~template内容$に対し `insertAdjacentHTML()$m を利用することが求まれよう。
◎
As with other direct Node-manipulation APIs (and unlike innerHTML), insertAdjacentHTML() does not include any special handling for template elements. In most cases you will want to use templateEl.content.insertAdjacentHTML() instead of directly manipulating the child nodes of a template element.
</p>
			</section>
			<section id="the-createcontextualfragment()-method">
<h4 title="The createContextualFragment() method">8.5.7. `createContextualFragment()^m ~method</h4>

<p class="XXX">
`createContextualFragment()$m ~methodには、
`DOMPARSING$r の`課題~追跡器＠https://github.com/w3c/DOM-Parsing/issues$において，いくつか未決な課題がある
— そこには、
その仕様に伴われる様々な問題が文書化されている。
◎
The createContextualFragment() method has a number of outstanding issues in the DOM Parsing and Serialization issue tracker, documenting various problems with its specification.
</p>

<dl class="domintro">
	<dt>%docFragment = %range.`createContextualFragment(string)$m</dt>
	<dd>
~markup文字列 %string から作成される`文書片$を返す
— %string を構文解析する際の文脈として， %range の`始端~node$を利用する下で。
◎
Returns a DocumentFragment created from the markup string string using range's start node as the context in which fragment is parsed.
</dd>
</dl>

<p class="warning">
この~methodは、
`script$e や`~event~handler内容~属性$の様な危険にもなり得る［
要素, 属性
］を除去するための無毒化を遂行しない。
◎
This method performs no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.
</p>

<pre class="idl">
partial interface <span id="Range-partial">`Range$I</span> {
  [`CEReactions$, NewObject] `DocumentFragment$I `createContextualFragment$m((`TrustedHTML$I or DOMString) %string);
};
</pre>

<div class="algo">
<p>
`createContextualFragment(string)@m
~method手続きは：
◎
Range's createContextualFragment(string) method steps are:
</p>
<ol>
	<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
%string,
`Range createContextualFragment^l,
`script^l
◎
Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, string, "Range createContextualFragment", and "script".
</li>
	<li>
%~node ~LET コレの`始端~node$
◎
Let node be this's start node.
</li>
	<li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>
	<li>
~IF［
%~node は `Element$I を`実装-$する
］
⇒
%要素 ~SET %~node
◎
If node implements Element, set element to node.
</li>
	<li>
~ELIF［
%~node は `Text$I を`実装-$する
］~OR［
%~node は `Comment$I を`実装-$する
］
⇒
%要素 ~SET %~node の`親~要素$
◎
Otherwise, if node implements Text or Comment, set element to node's parent element.
</li>
	<li>
<p>
~IF［
%要素 ~EQ ~NULL
］~OR［
~AND↓
］…
◎
If element is null or all of the following are true:
</p>
		<ul>
			<li>
%要素 の`~node文書$は~HTML文書である
◎
element's node document is an HTML document;
</li>
			<li>
%要素 の`局所~名$el ~EQ "`html$e"
◎
element's local name is "html"; and
</li>
			<li>
%要素 の`名前空間$el ~EQ `~HTML名前空間$
◎
element's namespace is the HTML namespace,
</li>
		</ul>
<p>
…ならば
⇒
%要素 ~SET `要素を作成する$( コレの`~node文書$, `body^l, `~HTML名前空間$ )
◎
then set element to the result of creating an element given this's node document, "body", and the HTML namespace.
</p>
	</li>
	<li>
%文書片 ~LET `素片を構文解析する$( %要素, %準拠な文字列 )
◎
Let fragment node be the result of invoking the fragment parsing algorithm steps with element and compliantString.
</li>
	<li>
%文書片 の`子孫$である
~EACH( `script$e 要素 %~script )
に対し
⇒
%~script の
⇒＃
`すでに開始したか$scE ~SET ~F
`構文解析器~文書$scE ~SET ~NULL
◎
For each script of fragment node's script element descendants:
• Set script's already started to false.
• Set script's parser document to null.
</li>
	<li>
~RET %文書片
◎
Return fragment node.
</li>
</ol>
</div>

			</section>
			<section id="the-xmlserializer-interface">
<h4 title="The XMLSerializer interface">8.5.8. `XMLSerializer^I ~interface</h4>

<p class="XXX">
`XMLSerializer$I ~interfaceには、
`DOMPARSING$r の`課題~追跡器＠https://github.com/w3c/DOM-Parsing/issues$において，いくつか未決な課題がある
— そこには、
その仕様に伴われる様々な問題が文書化されている。
`DOMPARSING$r を成す残りは、
次第に この仕様へ~upstreamされることになる。
◎
The XMLSerializer interface has a number of outstanding issues in the DOM Parsing and Serialization issue tracker, documenting various problems with its specification. The remainder of DOM Parsing and Serialization will be gradually upstreamed to this specification.
</p>

<dl class="domintro">
	<dt>%xmlSerializer = `new XMLSerializer()$m</dt>
	<dd>
新たな `XMLSerializer$I ~objを構築する。
◎
Constructs a new XMLSerializer object.
</dd>

	<dt>%string = %xmlSerializer . `serializeToString(root)$m</dt>
	<dd>
%root を直列化した結果を返す。
◎
Returns the result of serializing root to XML.
</dd>
	<dd>
%root を~XMLへ直列化できない場合、
`InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if root cannot be serialized to XML.
</dd>
</dl>

<p class="note">
`XMLSerializer$I の設計が，~classとして構築してから `serializeToString()$m ~methodを~callする必要があるのは、
不幸な歴史的~遺物である。
この機能性を今日~設計するなら，自立的な関数にするであろう。
◎
The design of XMLSerializer, as a class that needs to be constructed and then have its serializeToString() method called, is an unfortunate historical artifact. If we were designing this functionality today it would be a standalone function.
</p>

<pre class="idl">
[Exposed=Window]
interface `XMLSerializer@I {
  `constructor＠#dom-xmlserializer-constructor$();

  DOMString `serializeToString$m(`Node$I %root);
};
</pre>

<div class="algo">
`new XMLSerializer()@m
構築子~手続きは、
何もしない。
◎
The new XMLSerializer() constructor steps are to do nothing.
</div>

<div class="algo">
`serializeToString(root)@m
~method手続きは
⇒
~RET `~XML直列化$( %root, ~F )
◎
The serializeToString(root) method steps are:
• Return the XML serialization of root given false.
</div>

			</section>
		</section>
</main>

