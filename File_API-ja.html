<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>File API （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />


<style type="text/css">
.attr-state {
	font-family: sans-serif0, sans-serif;
}

/* tables */
tr {
	border-bottom: solid 1px #DDDDDD;
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

.scheme {
	color: #006633;
}

.arg {
	font-family: monospace0, monospace;
}

.code-point {
	font-family: sans-serif0, sans-serif;
}

.js-slot{
	color: green;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 171220 spec
}

function expand(){
	var link_map = this.link_map;
	var unicode_map = this.unicode_map;
	var class_map = {
		FR: 'reason',
		e: 'element',
		a: 'attr',
		sc: 'scheme',
		h: 'header',
		E: 'error', // exception
		P: 'production',
		et: 'event-type',
		I: 'idl-interface',
		dm: 'idl-dictionary-member',
		sl: 'js-slot',
		st: 'attr-state',
		U: 'code-point',
		V: 'arg',
	};
	var tag_map = {
		samp: 'samp',
		FR: 'i', // file read error reason
		E: 'code',
		et: 'code', // event type
		e: 'code', // HTML element
		a: 'code',
		sc: 'code', // URL scheam
		h: 'code', // HTTP method/header names
		I: 'code', // idl type
		m: 'code', // idl member
		mS: 'code', // idl member ( FileReaderSync )
		dm: 'code', // idl dictionary member
		V: 'var', // idl args
		sl: 'span',
		st: 'span',
		U: 'span', // Unicode code point
		P: 'var', // production
		i: 'i',
		c: 'code',
	}

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'm':
case 'mS':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l': // literal
	text = '"<code class="literal">' + key + '</code>"'
	break;
case 'sl': // internal slot
	text = '[[' + key + ']]';
	break;
case 'sc': // internal slot
	text = key.replace(/_/, ':');
	break;
case 'U':
	text = 'U+' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2018-01-29
trans_update:2018-02-21
original_url:https://w3c.github.io/FileAPI/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:storage
conformance:w3c
copyright:2018,permissive
trans_1st_pub:2012-01-03


●●original_id_map


blob:dfn-Blob
file:dfn-file
filelist:dfn-filelist
filereader:dfn-filereader
filereadersync:dfn-FileReaderSync

dom-blob-blob:
dom-file-file:
dom-filereader-filereader:
dom-filereadersync-filereadersync:


●●link_map


	●IDL
Exposed:~WEBIDL#Exposed
Clamp:~WEBIDL#Clamp
Serializable:~HTMLcloning#serializable

DOMString:~WEBIDL#idl-DOMString
	ArrayBuffer:~WEBIDL#idl-ArrayBuffer
	unsigned short:~WEBIDL#idl-unsigned-short

I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
	I.ArrayBufferView:~WEBIDL#
I.BufferSource:~WEBIDL#BufferSource
I.Blob:#blob
I.BlobPart:#typedefdef-blobpart
I.BlobPropertyBag:#dfn-BlobPropertyBag
I.DOMString:~WEBIDL#idl-DOMString
I.EndingType:#enumdef-endingtype
I.USVString:~WEBIDL#idl-USVString
I.DataTransfer:~HTMLdnd#datatransfer
	I.Document:~DOM4#document
	~DOM4#concept-document
I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.File:#file
I.FileList:#filelist
I.FilePropertyBag:#dfn-FilePropertyBag
I.HTMLInputElement:~HEinput#htmlinputelement
I.ProgressEvent:~XHR#progressevent
I.Window:~WINDOW#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.Worker:~WORKERS#worker
I.XMLHttpRequest:~XHR#xmlhttprequest
I.URL:~URL1#url
I.FileReader:#filereader
I.FileReaderSync:#filereadersync

I.Array:~TC39#sec-array-constructor
I.Date:~TC39#sec-date-constructor

	unsigned long:~WEBIDL#idl-unsigned-long
	long long:~WEBIDL#idl-long-long
	unsigned long long:~WEBIDL#idl-unsigned-long-long
	boolean:~WEBIDL#idl-boolean


E.NotFoundError:~WEBIDL#notfounderror
E.NotReadableError:~WEBIDL#notreadableerror
E.SecurityError:~WEBIDL#securityerror
E.InvalidStateError:~WEBIDL#invalidstateerror
I.DOMException:~WEBIDL#idl-DOMException

	E.NotFoundError:#dfn-NotFoundError
	E.SecurityError:#dfn-SecurityError
	E.NotReadableError:#dfn-NotReadableError
	E.InvalidStateError:#InvalidStateError

	●contructor
m.Blob:#dom-blob-blob
	m.Blob:#dom-blob-blob-blobparts-options
m.File:#dom-file-file
	m.File(fileBits, fileName):#dom-file-file
	m.File(fileBits, fileName, options):#dom-file-file
m.FileReader:#dom-filereader-filereader
m.FileReaderSync:#dom-filereadersync-filereadersync
	m.Constructor:#dom-blob-blob
	m.Constructor:#dom-file-file
	m.Constructor:#dom-filereader-filereader
	m.Constructor:#dom-filereadersync-filereadersync

	■const
m.DONE:#dfn-done
m.EMPTY:#dfn-empty
m.LOADING:#dfn-loading

	■attrs/method
m.abort:#dfn-abort
m.createObjectURL:#dfn-createObjectURL
m.URL.createObjectURL:#dfn-createObjectURL
m.error:#dfn-error
m.item:#dfn-item
m.lastModified:#dfn-lastModified
m.length:#dfn-length
m.name:#dfn-name

m.onabort:#dfn-onabort
m.onerror:#dfn-onerror
m.onload:#dfn-onload
m.onloadend:#dfn-onloadend
m.onloadstart:#dfn-onloadstart
m.onprogress:#dfn-onprogress

m.postMessage:~WORKERS#dom-worker-postmessage

m.readAsArrayBuffer:#dfn-readAsArrayBuffer
m.readAsBinaryString:#dfn-readAsBinaryString
m.readAsDataURL:#dfn-readAsDataURL
m.readAsText:#dfn-readAsText

mS.readAsArrayBuffer:#dfn-readAsArrayBufferSync
mS.readAsBinaryString:#dfn-readAsBinaryStringSync
mS.readAsDataURL:#dfn-readAsDataURLSync
mS.readAsText:#dfn-readAsTextSync

m.readyState:#dfn-readyState
m.result:#dfn-result
m.revokeObjectURL:#dfn-revokeObjectURL
m.URL.revokeObjectURL:#dfn-revokeObjectURL
m.send:~XHR#dom-xmlhttprequest-send
m.size:#dfn-size
m.slice:#dfn-slice
m.type:#dfn-type

	■variable
V.blobParts:#dfn-blobParts
V.options:#dfn-blobOptions
	V.url:#dom-url-revokeobjecturl-url-url
V.contentType:#dfn-contentTypeBlob
V.start:#dfn-start
V.end:#dfn-end
V.fileBits:#dfn-fileBits
V.fileName:#dfn-fileName
V.fileOptions:#dfn-fileOptions
V.index:#dfn-index
V.label:#dfn-label
V.blob:#dfn-fileBlob


	■idl-dictionary-member
dm.lastModified:#dfn-FPdate
dm.type:#dfn-BPtype
dm.endings:#dom-blobpropertybag-endings

	enum
l.transparent:#dom-endingtype-transparent
l.native:#dom-endingtype-native

	■event
et.abort:#dfn-abort-event
et.error:#dfn-error-event
et.load:#dfn-load-event
et.loadend:#dfn-loadend-event
et.loadstart:#dfn-loadstart-event
et.progress:#dfn-progress-event


	■error
FR.FileLock:#FileLockFR
FR.NotFound:#NotFoundFR
FR.SnapshotState:#SnapshotStateFR
FR.TooManyReads:#TooManyReadsFR
FR.UnsafeFile:#UnsafeFileFR



	■element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.a:~HEtextlevel#the-a-element
e.form:~HEforms#the-form-element

	■content attr
a.download:~HTMLlinks#attr-hyperlink-download




	●
参照~byte列:#_ref-bytes
~Blob:#_blob-object
~data_URL:#biblio-rfc2397
~error手続き:#dfn-error-steps

~blobを成す各部位を処理する:#process-blob-parts
~native行末に変換する:#convert-line-endings-to-native

~blob~URL~store:#BlobURLStore
~blob~URL:#blob-url
新たな~blob~URLを生成する:#unicodeBlobURL
~blob~URL~storeに~entryを追加する:#add-an-entry
~blob~URL~storeから~entryを除去する:#removeTheEntry
~blob~URLを解決する:#blob-url-resolve
~blob~URLの生成元を解決する:#blob-url-resolve-the-origin

~blob~URL~entry:#blob-url-entry
bU.環境:#blob-url-entry-environment
bU.~obj:#blob-url-entry-object

選択looping:#selection-looping
~systemに関わる~file:#sensitive-files
Unix Epoch:#UnixEpoch
注釈付き~task読取り演算:#task-read-operation


符号化方式を決定-:#encoding-determination
読取り~error:#file-error-read
~error条態:#file-error-read
失敗事由:#failureReason
~file読取~task源:#fileReadingTaskSource
~file型~指針:#file-type-guidelines
進捗~eventを発火-:#fire-a-progress-event
存続期間:#lifeTime

読取り演算:#readOperation
読取り完了:#process-read-EOF
	process read EOF
読取り~dataを処理する:#process-read-data
読取り~errorを処理する:#process-read-error
読取りを開始する:#process-read


読取り~method:#read-method
非同期~読取り~method:#asynchronous-read-methods
同期~読取り~method:#read-method-sync

~snapshot状態:#snapshot-state
同期~flag:#synchronousFlag

終了-:#terminate-an-algorithm


	●外部
~byte:~INFRA#byte
~byte列:~INFRA#byte-sequence
~surrogate:~INFRA#surrogate
~list:~INFRA#list
	~EACH:~INFRA#list-iterate
付加する:~INFRA#list-append
~map:~INFRA#ordered-map
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
	値を設定する:~INFRA#map-set
	~entryを除去する:~INFRA#map-remove

符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
位置~変数:~INFRA#string-position-variable
文字列:~INFRA#string
文字:~INFRA#code-point
	符号位置:~INFRA#code-point
同型に復号する:~INFRA#isomorphic-decode
~JS文字列:~INFRA#javascript-string

~URL:~URL1#concept-url
url.~host:~URL1#concept-url-host
url.~path:~URL1#concept-url-path
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
妥当な~URL文字列:~URL1#valid-url-string
~URL構文解析-:~URL1#concept-url-parser
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer

~fetch:~FETCH#concept-fetch
本体:~FETCH#concept-body
~network~error:~FETCH#concept-network-error
伝送-済み~byte数:~FETCH#concept-body-transmitted
総~byte数:~FETCH#concept-body-total-bytes
~streamを~errorにする:~FETCH#concept-error-readablestream


復号-:~ENCODING#decode
~Unicodeに復号する:~ENCODING#decode
~labelから符号化方式を取得する:~ENCODING#concept-encoding-get

符号化方式~label:~ENCODING#label
~UTF-8:~ENCODING#utf-8
~UTF-8符号化する:~ENCODING#utf-8-encode

発火-:~DOM4#concept-event-fire
発火:~DOM4#concept-event-fire
	文脈~obj:~DOM4#context-object

~MIME型:~MIMESNIFF#mime-type
~MIME型の構文解析-:~MIMESNIFF#parse-a-mime-type
~parameter~map:~MIMESNIFF#parameters
	廃＊dictionary of parameters
構文解析-可能な~MIME型:#parsable-mime-type
	廃＊~MIMESNIFF#parsable-mime-type
妥当な~MIME型:~MIMESNIFF#valid-mime-type

被support~prop~index:~WEBIDL#dfn-supported-property-indices
投出:~WEBIDL#dfn-throw
在する:~WEBIDL#dfn-present
~byte列の複製を取得-:~WEBIDL#dfn-get-buffer-source-copy

~chunk:~STREAMS#chunk

~ASCII小文字~化する:~INFRA#ascii-lowercase
文書:~DOM4#concept-document

	●HTML
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler ~event型:~WAPI#event-handler-event-type
現在の設定群~obj:~WAPI#current-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
関連する設定群~obj:~WAPI#relevant-settings-object
~queueされ:~WAPI#queue-a-task
~taskを~queueする:~WAPI#queue-a-task
~task源:~WAPI#task-source
~task:~WAPI#concept-task

	生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
enV.生成元:~WAPI#concept-settings-object-origin
文書~unload時の片付け手続き:~NAVI#unloading-document-cleanup-steps


st.File:~HEinput#file-upload-state-(type=file)

直列化-可能:~HTMLcloning#serializable-objects
直列化~手続き:~HTMLcloning#serialization-steps
逆直列化~手続き:~HTMLcloning#deserialization-steps
下位直列化:~HTMLcloning#sub-serialization
下位逆直列化:~HTMLcloning#sub-deserialization


●●words_table1


PublicML:https://lists.w3.org/Archives/Public


●●words_table


method::::メソッド
byte::::バイト
index:
Blob:
blob:
URL:
data_URL:Data URL
Unicode:
HTML:
UI:user interface:UI
UUID:

data::::データ
size::::サイズ
buffer::::バッファ
chunk::::チャンク
file::::ファイル


被support:supported::被 support:被サポート
member::::メンバ
code::::コード
push:
worker:
window:
本体:body::~:ボディ
access::::アクセス
upload::::アップロード
unload::::
event::::イベント
target::::ターゲット
handler::::ハンドラ
interface::::インタフェース
obj:object:::オブジェクト
error::::エラー
flag::::フラグ
	~error状況:error condition
key::::キー
map::::マップ
entry::::エントリ

url:
record::::レコード
navigate::::ナビゲート
server::::サーバ
memory::::メモリ
scheme::::スキーム
	query::::クエリ
	host::::ホスト
	port::::ポート
	scope::::スコープ
storage::::ストレージ
snapshot::::スナップショット
	status::::ステータス
main::::メイン
thread::::スレッド
task::::タスク
源:source::~::ソース
chunk::::チャンク
	生データ:raw data
disk::::ディスク
directory::::ディレクトリ
辞書:dictionary::~::ディクショナリ
連列:sequence::~::シーケンス
	~byte列:bytes:バイト列

text::::テキスト
	デコード:decode
drive::::ドライブ
download::::ダウンロード
stream::::ストリーム
binary::::バイナリ
metadata::::メタデータ
parameter::::パラメタ
permission::::パーミッション
	プロセス:process
code-block:code block::コードブロック
阻む:block する:~
header::::ヘッダ
form::::フォーム
program::::プログラム
prop:property:::プロパティ
message::::メッセージ
label::::ラベル
list::::リスト
資源:resource::~:リソース
fetch:
remote::::リモート
local::::ローカル
lock::::ロック
network::::ネットワーク

path::::パス
host::::ホスト
設定群:settings::~
取消:cancel::取り消し::キャンセル
取消せ:cancel でき::取り消せ::キャンセルでき
取消され:cancel され::取り消され::キャンセルされ

大域:global::~::グローバル
構築子:constructor::~::コンストラクタ
構築:construct::~
素の:plain::~::プレーン
処理能:performance::~::パフォーマンス
mount::::マウント
test::::テスト
sample::::見本コード
console::::コンソール
漏洩:leak::~::リーク

関数:function::~
garbage::::ガーベジ
収集-:collect:~
surrogate:::サロゲート

読取っ:read し::読み取っ
読取られ:read され::読み取られ
読取れ:read でき::読み取れ
読取る:read する::読み取る
読取り:read::読み取り
読取:reading::読み取り
	読取中:reading → read 中
読専:readonly::読み取り専用

読込まれ:load され::読み込まれ
読込み:load::読み込み

注釈付き:annotated::~

切出す:slice する::切り出す
切出し:slice::切り出し

浮上:bubble::~::バブル
静的:static::~
状態:state::~

	返す:return する:~
	返され:return され:~
	返さな:return しな:~
	返して:return して:~
call:
	call

呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
呼出せる:invoke できる:呼び出せる
	invocation
	呼び出し元
	呼び出し
被呼出時:被 invoke 時:~

取得子:getter:~
取得-:get:~
在する:present する:在る

queue::::キュー

要請:request::~::リクエスト

同型に:isomorphic:~
復号-:decode::~::デコード
符号位置:code point::~::コードポイント
符号化方式:encoding::~::エンコーディング
符号化-:encode::~::エンコード
	~ASCII小文字に符号化された文字列:ASCII-encoded string in lower case
伝送-:transmit::~
	伝送-済み:transmitted

MIME:
	廃＊media type:~MIME型
型:type::~
形式:format::~::フォーマット
参照解決-:dereference::~
参照解決:dereferencing::~
参照:reference::~
参照-:reference::~
	指す:refer／ 
	参照~先:-

処理-:process:~
処理:processing:~
生成元:origin::~::オリジン
同一生成元:same origin::~::同一オリジン
進捗:progress::~
	進捗~bar:prog bar
bar::::バー
素片除外:exclude fragment::~::フラグメント除外
識別子:identifier::~
投出:throw::~
属性:attribute::~
同期的:synchronous::~
同期:synchronous::~
非同期:asynchronous::~
非同期の:asynchronous::~
非同期的:asynchronous::~
中止-:abort::~
内容:content::~
発火-:fire::~
発火:firing::~
不透明:opaque::~
文書:document::~
例外:exception::~
成功:success::~
成功-:succeed:~
成功裡:successful::~
失敗:failure::~
失敗-:fail::~
失敗事由:failure reason::~
作成-:create::~
	作成-法:creating
作成:creatation::~
創出-:mint:~
破棄-:revoke::~
	破棄-法:revoking
破棄:revocation::~
store::::ストア
	ストア:Store::~
存続期間:lifetime::~
下層:underlying:~
下層の:underlying:~
	結果:result

	●構文
ASCII:
UTF-8:
構文解析-:parse::~::パース
	構文解析-可能:parsable
	構文解析:parsing
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
	直列化-可能:serializable
直列形:serialized::~::シリアル形
下位直列化:sub-serialization::~::下位シリアル化
	逆直列化-:deserialize::~::逆シリアル化
逆直列化:deserialization::~::逆シリアル化
下位逆直列化:sub-deserialization::~::下位逆シリアル化
行末:line ending:~

入力:input:~
文字列:string:~
文字:character:~
小文字:lowercase:~
置換文字:replacement character:replacement 文字:~
改行文字:newline:~
条態:condition::~::コンディション

	●保安
保安:security::~:セキュリティ
privacy::::プライバシー
攻撃:attack:~
許容-:allow:~
保護:guard:~
防止:preventing:~
防止-:prevent:~
実行-:execute:~
	実行-可能:executable
曝露-:expose:~
違反:violation::~
選択-:select:~
選択:selection:~
選択dialog:picker::選択ダイアログ
選択攻撃:selection attacks:~
選択looping:selection looping:選択ループ
	選択強制:must choose
	際限なく:loop
	暫定的:provisional:~

	●仕様
UA:user agent:UA
Web:
API:
risk::::リスク
system::::システム
hook:::フック
model::::モデル
native::::ネイティブ
app:application:::アプリ
algo:algorithm:::アルゴリズム
platform::::プラットフォーム
問題:problem:~
選択肢:option::~::オプション
省略可:optional::~::オプション
	省略可 任意選択
後方互換性:backwards compatibility:~
指針:guideline:~
要件:requirements:~
	例:example:~
趨勢:general trend:~
可用:available:~
参考:informative:~
注記:Note:~
環境:environment:~
不変則:invariants:~
規約:convention:~
適切:appropriate:~
統計的手法:statistical method:~
経験則:heuristic:~
feedback::::フィードバック
基本的:basic:~
多彩:rich:~
	内部的:internal:~
	用法:usage:~
安全:safe:~
	いくつもの:variation:~
特色機能:feature:~
汎用:generic:~
欠損:loss:~
重要:important:~
広範囲:wide:~
事例:case:~
悪意的な:malicious:悪意のある
手続き:steps:~
下位手続き:substeps:~
段:step:~
仕組み:mechanism:~
多義性:ambiguity:~
状況:situation:~
能:ability:~
明示的:explicit:~
概して:typical に:~
各種用語:terminology:~
	~~理論的に:In theory,
柔軟性:flexibility:~
概念的:conceptual:~
自明:trivial:~
詳細:detail:~
黙って:silent に:~
目的:purpose:~
効果:effect:~
特定の:specific な:~
	草案:draft
	最終作業草案
	要約:summary／Abstract
	要覧:summary:~
	規定:normative／ normative conditions ／ normative definition
	解る様に:meaningfully
	必要
	方法
	不要
	構成要素:elements
	機能:
	可能:
	可能性:likelihood of／may
	べき:should
	例:example
	可能:possible
	必要:need
	注意しておく:take care

	●仕様（動詞
support::::サポート
遂行-:perform:~
適合:conforming:~
適合-:conform:~
	利用-:use
利用事例:use case::~::ユースケース
利用者:user:~
有用:useful:~
公開-:expose:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
供-:provide:~
供さな:provide しな:~
ベース:base::~
考慮点:considerations:~
仕様:spec:~
	specification:~
獲得-:acquire:~
設計-:design:~
無視-:ignore:~
適用-:apply:~
無反応:freezing:~
指定-:specify:~
保守-:maintain:~
統合-:integrate:~
	integration
制約-:restrict:~
提携の:affiliated:~
提携-:affiliate:~
義務付け:mandating:~
決定-:determine:~
	determination
	決定-法:determining
取扱う:handle する:~
挙動:behavior:ふるまい
開発者:developer:~
予期-:expect:~
追跡-:track:~
影響-:affect:~
見做して:assume して:~
仕方:way:~
確立-:establish:~
選好-:prefer:~
	好ましい:preferable
述べる:describe する:~
	意味-:mean:~
拡張-:extend:~
相違:difference:~
確保-:ensure:~
可能化-:enable:~
試みた:attempt した:~
試みな:attempt しな:~
	序論:introduction:~

	努める:endeavor する
	用意されて:avail of
	由来:originally／originating
	由来の:に originate している
	説明:illustrate／ 
	意味:
	注意
	知り得ない:not known
	伴用
	利用

	●未分類（動詞
DnD:drag and drop:::ドラッグ＆ドロップ
置換-:replace:~
継承-:inherit:~
変異-:mutate::~
	変異-不能:immutable
完了-:complete:~
	読取り完了:process read EOF
完全:complete:~
	抽出-:extract:~
生成-:generate:~
誘発-:trigger:~
起動-:initiate::~
監視-:monitor:~
表現-:represent:~
表現:representation:~
変換-:convert:~
演算:operation:~
最終更新日:last modified date:~
改変-:modify:~
改変:modification:~
変化-:change:~
除去-:remove:~
付加-:append:~
表示-:display:~
解決-:resolve:~
終了-:terminate:~
片付け:cleanup::~
削除-:delete:~
移動-:move:~
継続-:continue:~
続行-:proceed:~
対話:interaction:やりとり
合致-:match:~
動作-:act:~
初期化-:initialize:~
	初期化:initially set to
走らす:run する:~
走らせ:run し:~
検査-:check:~
保持-:hold:~
存在-:exist:~
開始-:start:~
更新-:update:~
登録-:register:~
観測-:observe:~
	観測-可能:observable
対応付け:mapping:~
入子の:nested:~
追加-:add:~
消去る:go away する:消え去る
	あり続ける:remain
	指す:refer
	生じ:occur
	起こる:happen
	~~反映:set
	設定
	連鎖:chaining
	開始
	取得:get／
	呼応
	喪失:lost
	成す:constitute

	●未分類
OS:
JS:JavaScript
	~JS文字列:utf-16
IDL:
MIME:
	-:token
空:empty::~
charset:
	文字~並び:characters／sequence of character
名前:name:~
名:name:~

構造:structure:~
無効:invalid:~
妥当:valid:~
要素:element:~
時刻印:time stamp::タイムスタンプ
時刻:time:~
等価:equivalent:~
既定:default:~
既定の:default:~
情報:information:~
	ミリ秒数:milliseconds 数:~
	ミリ秒:milliseconds:~
	0:zero
画像:image:~
	引数:argument:~
	引数:parameter:~
値:value:~
種別:type:~
日時:date:~
構文:syntax:~
複製:copy:~
	負数:negative number 1:~
配列:array:~
整数:integer:~
引数:argument:~
同時並行的:concurrent:~
関連する:relevant な:~
位置:position:~
変数:variable:~
種類:kind:~
一対一:one-to-one:~
	一覧:table／list
	利用回数
	後半を成す~chunk:1/2 chunk starting at middle of 
	前半を成す~chunk:1/2 chunk starting at beginning of
		記述
	代入:assignment
	名称:name
	実行中:it is on
	数値
	数値比較:mathematical comparisons
	数値演算:mathematical operation
	集合
	最大値:maximum
	最小値:minimum
	頻度:frequent

	●§利用事例
Calendar::::カレンダー
browser::::ブラウザ
dialog:::ダイアログ
offline::::オフライン
script::::スクリプト
spreadsheet::::スプレッドシート
transaction::::トランザクション
version::::バージョン
viewer::::ビューア
view::::ビュー
取組まれ:address され:取り組まれ
取組む:address する:取り組む
併合-:merge:~
保存-:save:~
働く:work する:~
出力:output:~
効率的:efficient:~
格納-:store:~
直に:direct に:~
送信-:send:~
閲覧-:browse:~
写真:photo:~
動画:video:~
予定表:calendar:~
今日:today
	会社:company
	個人情報:personal info
	期間:slots
	多忙:busy
	並び換え,操作可能:sortable, actionable
	楽曲:song
	歌詞:lyrics
	自分用:his
	許可:permission
	program
	介在抜きに:without user intervention
	入った
	入れられ
	別名で保存:Save As
	単一の:one
	印
	組み合せ
	巨大:large
	応える
	探して
	曲
	漏れない
	示され
	節では
	組み入れ
	読みたい
	課され
	通知を受ける:notify
	開かれ
	読取られ

	●指示語
新たな:new:~
現在の:current:~
一意:unique:~
内側:inside:~
	ある種:certain
	一部:
	下記
	両者
	上述:
	以上:
	以下:
	以外:
	以降:
	任意:
	together
	他所:elsewhere
	後続:
	手前
	対応
	自身:itself
	部分
	重複
	個の:one:two
	個目:second
	個数
	直前
	直後
	一度
	主体:entity:~
	各種
	同上
	時点
	最初の:first
	時機:when
	複数回
	下位節:-
	現在
	先頭:beginning of／start of
	全体
	各部位:parts
	この:this
	これらの:these
	すべての:all
	その:that
	下:below
	他の:other
	依然として:still
	その:said
	別々の:separate
	別個の:distinct
	前:before
	各:each
	同じ:same
	常に:always
	後続の:subsequent
	所与の:given
	既知の:known
	結果:result
	以降は:anymore
	どうやっても:anyway
	範囲
	連続する:consecutive
	から経過した:since
	最終結果:
	最長:-
	末尾:end
	回数:
	場合
	対象:
	as long as
	似たような:similar
	異なる:different
	更なる:futher
	なる:consist
	それ以降:no longer
	不要になり次第:as soon as 〜 no longer needed
	何らかの:some

●●ref_normative

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMA-262]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[Encoding]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[Fetch]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC2397]
    L. Masinter. The "data" URL scheme. August 1998. Proposed Standard. URL: https://tools.ietf.org/html/rfc2397 
[RFC4122]
    P. Leach; M. Mealling; R. Salz. A Universally Unique IDentifier (UUID) URN Namespace. July 2005. Proposed Standard. URL: https://tools.ietf.org/html/rfc4122 
[STREAMS]
    Adam Rice; Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 
[XHR]
    Anne van Kesteren. XMLHttpRequest Standard. Living Standard. URL: https://xhr.spec.whatwg.org/ 


●●ref_informative

[MEDIA-SOURCE]
    Matthew Wolenetz; et al. Media Source Extensions™. 17 November 2016. REC. URL: https://www.w3.org/TR/media-source/ 
[RFC2046]
    N. Freed; N. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. November 1996. Draft Standard. URL: https://tools.ietf.org/html/rfc2046 
[Workers]
    Ian Hickson. Web Workers. 24 September 2015. WD. URL: https://www.w3.org/TR/workers/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">File API</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/FileAPI/

以前のバージョン
	https://www.w3.org/TR/2017/WD-FileAPI-20171026/

バージョン履歴
	https://github.com/w3c/FileAPI/commits/gh-pages

最新の課題
	<a href="https://github.com/w3c/FileAPI/issues/">GitHub</a>

編集
	<a href="mailto:mek@chromium.org">Marijn Kruisselbrink</a> (Google) 
    Vsevolod Shmyroff (Yandex) 

前任編集者
	<a href="http://arunranga.com/">Arun Ranganathan</a> (Mozilla Corporation) <a href="mailto:arun@mozilla.com">arun@mozilla.com</a>

テスト
	<a href="https://github.com/w3c/web-platform-tests/tree/master/FileAPI">web-platform-tests FileAPI/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/FileAPI">ongoing work</a>)

最新情報
	https://github.com/w3c/FileAPI

ML／フィードバック
	<a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a>

過去 ML
	<a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a> (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archive</a>) and <a href="mailto:public-webapi@w3.org">public-webapi@w3.org</a> (<a href="http://lists.w3.org/Archives/Public/public-webapi/">archive</a>)

前回の最終作業草案に対するフィードバック
	https://www.w3.org/wiki/Webapps/LCWD-FileAPI-20130912

発行者
	<a href="https://www.w3.org/WebPlatform/WG/">Web Platform Working Group</a>

</script>

</head>

<body>

<header>



	<hgroup>
<h1 id="title">File API</h1>
	</hgroup>

</header>

<hr>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、~Web~appにおいて ~file~objを表現するための
<abbr title="Application Programming Interface">~API</abbr>，および
~fileを~program的に選択して その~dataへ~accessすることを供する。
これには次が含まれる：
◎
This specification provides an API for representing file objects in web applications, as well as programmatically selecting them and accessing their data.
This includes:
</p>

<dl>
	<dt>`FileList$I ~interface</dt>
	<dd>
下層~systemから個別に選択された~fileの配列を表現する。
選択~用の~UIは `&lt;input type="file"&gt;^c —
すなわち， `File$st 状態にある `input$e 要素 `HTML$r
— を通して呼出すことができる。
◎
A FileList interface, which represents an array of individually selected files from the underlying system.
The user interface for selection can be invoked via &lt;input type="file"&gt;, i.e. when the input element is in the File Upload state [HTML].
</dd>

	<dt>`Blob$I ~interface</dt>
	<dd>
変異-不能な生~binary~dataを表現する。
`Blob$I ~obj内の一定範囲の~byteに対する~accessも，別個の `Blob$I を通して可能にする。
◎
A Blob interface, which represents immutable raw binary data, and allows access to ranges of bytes within the Blob object as a separate Blob.
</dd>

	<dt>`File$I ~interface</dt>
	<dd>
~fileの名前や（~disk上の）更新日など，~fileについての情報を~~供する読専の属性を備える。
◎
A File interface, which includes readonly informational attributes about a file such as its name and the date of the last modification (on disk) of the file.
</dd>

	<dt>`FileReader$I ~interface</dt>
	<dd>
`File$I や `Blob$I を読取るための~method,
それらの読取った結果を取得するための~event~modelを供する。
◎
A FileReader interface, which provides methods to read a File or a Blob, and an event model to obtain the results of these reads.
</dd>

	<dt><a href="#url">~URL~scheme</a></dt>
	<dd>
~fileなどの~binary~dataを~Web~appから参照する用途に利用できる。
◎
A URL scheme for use with binary data such as files, so that they can be referenced within web applications.
</dd>

</dl>

<p>
加えて、この仕様では、~thread化された~Web~appにおける，同期的な~file読取に利用できる~objを定義する。
◎
Additionally, this specification defines objects to be used within threaded web applications for the synchronous reading of files.
</p>

<p>
<a href="#requirements">要件と利用事例</a>
節では、この仕様の背後にある動機を説明する。
◎
§10 Requirements and Use Cases covers the motivation behind this specification.
</p>

<div >
<p>
この~APIは、他の~APIや~Web~platformの構成要素と伴用されるものとして設計されている。
特に、次に挙げるものからは，~programにより~fileの~listが得られるようになるべきである：
</p>

<ul><li>`XMLHttpRequest$I `XHR$r （例えば
`File$I ／ `Blob$I
型の引数をとる，多重定義された `send()$m ~method）
</li><li>`postMessage()$m
</li><li>`DataTransfer$I （
`HTML$r に定義されている <em>~DnD~API</em> の一部）
</li><li>Web Workers `WORKERS$r
</li><li>`File$st 状態にある `input$e 要素 `HTML$r
</li></ul>

<p>
これらの種類の挙動は、適切な提携の仕様にて定義される。
</p>
◎
This API is designed to be used in conjunction with other APIs and elements on the web platform, notably: XMLHttpRequest (e.g. with an overloaded send() method for File or Blob arguments), postMessage(), DataTransfer (part of the drag and drop API defined in [HTML]) and Web Workers. Additionally, it should be possible to programmatically obtain a list of files from the input element when it is in the File Upload state [HTML]. These kinds of behaviors are defined in the appropriate affiliated specifications.
</div>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>, および 冒頭の仕様メタデータに委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~Web~appは、~fileを~remoteの~serverへ~uploadしたり, 多彩な~Web~appの中で扱うことも含め、利用者からの入力を可能な限り広範囲に扱えるようになっているべきである。
この仕様は、~file, ~fileの~list, ~fileに~accessする際の~error, ~fileを~program的に読取る仕方についての基本的な表現を定義する。
加えて、適合~UAの~main~threadと非同期に処理し得る “生~data” を表現する~interfaceも定義する。
仕様で定義される~interfaceと~APIは、
~Web~platformに公開されている他の~interfaceや~APIと伴用し得るものになる。
◎
Web applications should have the ability to manipulate as wide as possible a range of user input, including files that a user may wish to upload to a remote server or manipulate inside a rich web application.
This specification defines the basic representations for files, lists of files, errors raised by access to files, and programmatic ways to read files.
Additionally, this specification also defines an interface that represents "raw data" which can be asynchronously processed on the main thread of conforming user agents. The interfaces and API defined in this specification can be used with other interfaces and APIs exposed to the web platform.
</p>

<p>
`File$I ~interfaceは、概して，（利用者 環境の）下層の~file~systemから得られる~file~dataを表現する。
`Blob$I ~interface（ "Binary Large Object" — 元々は
<a href="#Blob-REF">Google Gears</a> の~Web~APIに由来する名称）は、変異-不能な生~dataを表現する。
`File$I／`Blob$I
の読取は~main~threadと非同期に行われるべきものであり、~thread化された~Web~app
【~worker環境下】
においては，同期的~APIを利用する選択肢もある。
非同期~APIによる~fileの読取りにより、~UAの~main~threadの~UIの “無反応” は防止される。
この仕様は、
`File$I／`Blob$I
~dataの読取りと~access用に、<em>~event~model</em> に基づく非同期~APIを定める。
`FileReader$I ~objは、~event~handler内容~属性と~eventの発火を通して ~file~dataへの~accessを行うための，`非同期~読取り~method$を供する。
~eventと~event~handlerの利用により、<em>読取りの進捗</em>を監視するとき（~file~accessの処理能が~local~driveとは異なる，~remoteの~driveや~mountされた~driveに特に有用になる）と, ~file読取り中に起こり得る`~error条態$を監視するときとで，別々の~code-blockを利用できるようになる。
例で示す：
◎
The File interface represents file data typically obtained from the underlying file system, and the Blob interface ("Binary Large Object" - a name originally introduced to web APIs in Google Gears) represents immutable raw data. File or Blob reads should happen asynchronously on the main thread, with an optional synchronous API used within threaded web applications. An asynchronous API for reading files prevents blocking and UI "freezing" on a user agent’s main thread. This specification defines an asynchronous API based on an event model to read and access a File or Blob’s data. A FileReader object provides asynchronous read methods to access that file’s data through event handler content attributes and the firing of events. The use of events and event handlers allows separate code blocks the ability to monitor the progress of the read (which is particularly useful for remote drives or mounted drives, where file access performance may vary from local drives) and error conditions that may arise during reading of a file. An example will be illustrative.
</p>

<div class="example">
<p>
次の例では［
進捗, ~error, 成功
］の，それぞれの条態に応じて、別々の~code-blockが取扱う。
◎
In the example below, different code blocks handle progress, error, and success conditions.
</p>

<pre class="js-code">
function startRead() {
  /* <span class="comment">
`input$e 要素を DOM から得る
◎
obtain input element through DOM
</span> */

  var %file = document.getElementById('file').files[0];
  if(%file){
    getAsText(%file);
  }
}

function getAsText(%readFile) {

  var %reader = new FileReader();

  /* <span class="comment">
UTF-16 として~fileを~memory内に読取る
◎
Read file into memory as UTF-16
</span> */
  %reader.readAsText(%readFile, "UTF-16");

  /* <span class="comment">
進捗, 成功, ~error を取扱う
◎
Handle progress, success, and errors
</span> */
  %reader.onprogress = updateProgress;
  %reader.onload = loaded;
  %reader.onerror = errorHandler;
}

function updateProgress(%evt) {
  if (%evt.lengthComputable) {
    /* <span class="comment">
%evt . `loaded^m および %evt . `total^m は `ProgressEvent$I の~prop
◎
evt.loaded and evt.total are ProgressEvent properties
</span> */
    var %loaded = (%evt.loaded / %evt.total);
    if (%loaded &lt; 1) {
      /* <span class="comment">
進捗~barの長さを増やす
◎
Increase the prog bar length
</span> */
      // style.width = (%loaded * 200) + "px";
    }
  }
}

function loaded(%evt) {
  /* <span class="comment">
読取られた~file~data（この事例では文字列）を得る
◎
Obtain the read file data
</span> */
  var %fileString = %evt.target.result;
  /* <span class="comment">
得られた~dataを取扱う
◎
Handle UTF-16 file dump
</span> */
  if(utils.regexp.isChinese(%fileString)) {
    /* <span class="comment">
Chinese 文字~並びの~~処理
◎
//Chinese Characters + Name validation
</span> */
  }
  else {
    /* <span class="comment">
他の~charsetについての~test
◎
run other charset test
</span> */
  }
  // xhr.send(%fileString)
}

function errorHandler(%evt) {
  if(%evt.target.error.name == "NotReadableError") {
    /* <span class="comment">
~fileを読取れなかった
◎
The file could not be read
</span> */
  }
}
</pre>
</div>


	</section>
	<section id="terminology">
<h2 title="Terminology and Algorithms">2. 各種用語と~algo</h2>


<p>
この仕様における，~algoの
`終了-@
とは、~UAが実行中の段を終えた所で~algoを終了し~MUSTことを意味する。
この仕様で定義される`非同期~読取り~method$は、当の~algoが終了される前に呼び出し元に戻ることがあり、また， `abort()$m 呼び出しにより終了され得る。
◎
When this specification says to terminate an algorithm the user agent must terminate the algorithm after finishing the step it is on. Asynchronous read methods defined in this specification may return before the algorithm in question is terminated, and can be terminated by an abort() call.
</p>

<p>
常に整数 %a, %b に対する［
max( %a, %b ) ／ min( %a, %b )
］は、 `WebIDL$r の定義に従い %a, %b の［
最大値／最小値
］を返す。
◎
The algorithms and steps in this specification use the following mathematical operations:
◎
max(a,b) returns the maximum of a and b, and is always performed on integers as they are defined in WebIDL [WebIDL]; in the case of max(6,4) the result is 6. This operation is also defined in ECMAScript [ECMA-262].
◎
min(a,b) returns the minimum of a and b, and is always performed on integers as they are defined in WebIDL [WebIDL]; in the case of min(6,4) the result is 4. This operation is also defined in ECMAScript [ECMA-262].
◎
Mathematical comparisons such as &lt; (less than), ≤ (less than or equal to), and &gt; (greater than) are as in ECMAScript [ECMA-262].
</p>

<p>
この仕様に利用される語 
`Unix Epoch@
は、時刻
00:00:00 UTC 1970 年 1 月 1 日（ 1970-01-01T00:00:00Z ISO 8601 ）を指す。
これは、 `ECMA-262$r においては，概念的な 時刻 “0” と同じになる。
◎
The term Unix Epoch is used in this specification to refer to the time 00:00:00 UTC on January 1 1970 (or 1970-01-01T00:00:00Z ISO 8601); this is the same time that is conceptually "0" in ECMA-262 [ECMA-262].
</p>


	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 此れ, 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
`~Blob@
とは、 `Blob$I ~interfaceを実装する~objの略記である（したがって， `File$I ~interfaceを実装する~objも含まれる）。
</p>

<p>
原文が参照している `MIMESNIFF$r の用語には、今や，廃された／改称されたものもある。
この訳では、その現在の仕様に揃うように，手を加えている
— 例えば，原文の “media type” に代えて、 “`~MIME型$（ MIME type ）” を利用している。
</p>

	</section>
	<section id="blob-section">
<h2 title="The Blob Interface and Binary Data">3. `Blob^I ~interfaceと~binary~data</h2>


<p>
各 `~Blob$は、次のものを内部的に持つ：
</p>

<dl>
	<dt>`参照~byte列@</dt>
	<dd>
~objが自身の~dataとして参照する`~byte列$。
~objの `size$m 属性は，`参照~byte列$の総~byte数を表現し、
`type$m 属性は，その~dataの~MIME型を（~ASCII小文字に符号化された文字列として）表現する。
◎
A Blob object refers to a byte sequence, and has a size attribute which is the total number of bytes in the byte sequence, and a type attribute, which is an ASCII-encoded string in lower case representing the media type of the byte sequence.
</dd>

	<dt>`~snapshot状態@</dt>
	<dd>
`参照~byte列$が下層~storageから得られるものである場合にのみ，その~storageの状態を反映するものとして，持た~MUST。
`~snapshot状態$についての更なる規定は，
<a href="#file-section">`File^I ~interface節</a>
にて。
◎
Each Blob must have an internal snapshot state, which must be initially set to the state of the underlying storage, if any such underlying storage exists. Further normative definition of snapshot state can be found for Files.
</dd>

</dl>


<pre class="idl">
[<a href="#dom-blob-blob">Constructor</a>(optional sequence&lt;`BlobPart$I&gt; `blobParts$V, optional `BlobPropertyBag$I `options$V),
 `Exposed$=(Window,Worker),
 `Serializable$]

interface `Blob@I {

  readonly attribute unsigned long long `size$m;
  readonly attribute `DOMString$I `type$m;

  /* <span class="comment">
`Blob^I から~byte範囲の~chunkを切出す
◎
slice Blob into byte-ranged chunks
</span> */
  Blob <a href="#dfn-slice">slice</a>(
            [`Clamp$] optional long long `start$V,
            [`Clamp$] optional long long `end$V,
            optional `DOMString$I `contentType$V
  );
};

enum `EndingType$I { `transparent@l, `native@l };

dictionary `BlobPropertyBag@I {
  `DOMString$I `type$dm = "";
  `EndingType$I `endings$dm = `transparent$l;
};

typedef (`BufferSource$I or `Blob$I or USVString) `BlobPart@I;
</pre>

<p>
`Blob$I ~objは、`直列化-可能$である：
◎
Blob objects are serializable objects.＼
</p>

<ul>
	<li>
<p>
その`直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their serialization steps, given value and serialized, are:
</p>

		<ol>
			<li>
%直列形 . `SnapshotState^sl ~SET %値 の`~snapshot状態$
◎
Set serialized.[[SnapshotState]] to value’s snapshot state.
</li>
			<li>
%直列形 . `ByteSequence^sl ~SET 
%値 の下層の~byte列
◎
Set serialized.[[ByteSequence]] to value’s underlying byte sequence.
</li>
		</ol>
	</li>
	<li>
<p>
その`逆直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their deserialization step, given serialized and value, are:
</p>

		<ol>
			<li>
%値 の`~snapshot状態$ ~SET %直列形 . `SnapshotState^sl
◎
Set value’s snapshot state to serialized.[[SnapshotState]].
</li>
			<li>
%値 の下層の~byte列 ~SET %直列形 . `ByteSequence^sl
◎
Set value’s underlying byte sequence to serialized.[[ByteSequence]].
</li>
		</ol>
	</li>
</ul>

		<section id="constructorBlob">
<h3 title="Constructors">3.1. ~Blob構築子</h3>

<p class="idl-def">
`Blob(blobParts, options)@m
の被呼出時には、次を走らせ~MUST
◎
The Blob() constructor can be invoked with zero or more parameters. When the Blob() constructor is invoked, user agents must run the following steps:
</p>

<ol>
	<li>
%種別 ~LET 空~文字列
◎
↓</li>
	<li>
%~byte列 ~LET 0 ~byteの~data
◎
↓
◎
If invoked with zero parameters, return a new Blob object consisting of 0 bytes, with size set to 0, and with type set to the empty string.
</li>
	<li>
~IF［
%blobParts は与えられている
］
⇒
%~byte列 ~LET `~blobを成す各部位を処理する$( `blobParts$V, `options$V )
◎
Let bytes be the result of processing blob parts given blobParts and options.
</li>
	<li>
~IF［
`options$V に `type$dm ~member %m は`在する$
］~AND［
%m の値 %v を成すどの文字も 範囲 { `0020^U 〜 `007E^U } に入る
］
⇒
%種別 ~SET `~ASCII小文字~化する$( %v )
◎
If the type member of the optional options argument is provided and is not the empty string, run the following sub-steps:
• Let t be the type dictionary member. If t contains any characters outside the range U+0020 to U+007E, then set t to the empty string and return from these substeps.
• Convert every character in t to ASCII lowercase.
</li>
	<li>
<p>
~RET 次のように初期化された，新たな `Blob$I ~obj
⇒＃
`参照~byte列$ ~SET %~byte列,
`size$m ~SET %~byte列 の長さ,
`type$m ~SET %種別
◎
Return a Blob object referring to bytes as its associated byte sequence, with its size set to the length of bytes, and its type set to the value of t from the substeps above.
</li>
</ol>

			<section id="constructorParams">
<h4 title="Constructor Parameters">3.1.1. 構築子に渡す引数</h4>

<p>
`Blob()$m 構築子は、次を引数に呼出せる：
◎
The Blob() constructor can be invoked with the parameters below:
</p>

<dl class="idl-def">
	<dt>
`blobParts@V
◎
A blobParts sequence
</dt> 
	<dd>
任意の要素~数からなる~IDL連列~型の引数であって、その各~要素ごとに，次の いずれかの型の値をとり得る
⇒
`BufferSource$I ／ `Blob$I ／ `DOMString$I
◎
which takes any number of the following types of elements, and in any order:
• BufferSource elements.
• Blob elements.
• USVString elements.
</dd>

	<dt>
`options@V
◎
An optional BlobPropertyBag
</dt>
	<dd>
<p>
この `BlobPropertyBag$I 辞書~型~引数（省略可）は、次の~memberを持つ：
◎
which takes these optional members:
</p>

		<dl id="dfn-BlobPropertyBagMembers">
			<dt>`type@dm</dt>
			<dd>
`~Blob$の~MIME型を表現する，~ASCII小文字に符号化された文字列。
この~memberに対する規定は、
<a href="#constructorBlob">`Blob^I 構築子</a>
節にて与えられる。
◎
type, the ASCII-encoded string in lower case representing the media type of the Blob. Normative conditions for this member are provided in the §3.1 Constructors.
</dd>

			<dt>`endings@dm</dt>
			<dd>
とり得る値は、既定の `transparent$l, または `native$l 。
◎
endings, an enum which can take the values "transparent" or "native".＼
</dd>
			<dd>
`native$l に設定された場合、
`blobParts$V 内の `USVString^I %S は，次の結果にされることになる
⇒
`~native行末に変換する$( %S )
◎
By default this is set to "transparent". If set to "native", line endings will be converted to native in any USVString elements in blobParts.
</dd>
		</dl>
	</dd>
	<dd class="trans-note">【
この引数が省略された場合、 `WebIDL$r に従って，空の辞書~値が渡されたものと見なされ、各~memberは既定の値をとることになる。
】</dd>
</dl>


<p class="algo-head">
`~blobを成す各部位を処理する@
ときは、所与の
( 一連の `BlobPart$I 値が成す連列 %parts, `BlobPropertyBag$I 型の値 %options )
に対し，次を走らす：
◎
To process blob parts given a sequence of BlobPart's parts and BlobPropertyBag options, run the following steps:
</p>

<ol>
	<li>
%~byte列 ~LET 空`~byte列$
◎
Let bytes be an empty sequence of bytes.
</li>
	<li>
<p>
%parts を成す~EACH ( %e ) に対し，順に
⇒
%~byte列 に［
%e の型に応じて 次の下位手続きを走らせた結果
］を付加する：
◎
For each element in parts:
</p>
		<dl class="switch">
			<dt>
`USVString^I
◎
If element is a USVString, run the following substeps:
</dt>
			<dd>
				<ol>
					<li>
~IF［
%options の `endings$dm ~member ~EQ `native$l 
］
⇒
%e ~SET `~native行末に変換する$( %e )
◎
Let s be element.
◎
If the endings member of options is "native", set s to the result of converting line endings to native of element.
</li>
					<li>
~RET `~UTF-8符号化する$( %e )
◎
Append the result of UTF-8 encoding s to bytes.
</li>
				</ol>
			</dd>
			<dd class="note">注記：
<a href="~WEBIDL#dfn-obtain-unicode">~Unicode文字~並びに変換する~algo</a>
`WebIDL$r は、`~JS文字列$内の対を成さない（従って妥当でない）`~surrogate$を， `FFFD^U 置換文字に置換する。
そのため、 `Blob$I 構築子においては，文字~並びの喪失や並び替わりによる何らかの~data欠損も生じ得る。
◎
Note: The algorithm from WebIDL [WebIDL] replaces unmatched surrogates in an invalid utf-16 string with U+FFFD replacement characters. Scenarios exist when the Blob constructor may result in some data loss due to lost or scrambled character sequences.
</dd>

			<dt>`BufferSource$I</dt>
			<dd>
~RET %e が保持している`~byte列の複製を取得-$した結果
◎
If element is a BufferSource, get a copy of the bytes held by the buffer source, and append those bytes to bytes.
</dd>

			<dt>`~Blob$</dt>
			<dd>
~RET %e が表現する~byte列
◎
If element is a Blob, append the bytes it represents to bytes.
</dd>
			<dd class="note">
%e の `type$m 属性は無視され、返される`~Blob$の `type$m には影響しない。
◎
Note: The type of the Blob array element is ignored and will not affect type of returned Blob object.
</dd>
		</dl>
	</li>
	<li>
~RET %~byte列
◎
Return bytes.
</li>
</ol>

<p class="algo-head">
`~native行末に変換する@
ときは、所与の
( `文字列$ %s )
に対し，次を走らす：
◎
To convert line endings to native in a string s, run the following steps:
</p>

<ol>
	<li>
%CR ~LET `文字$ `000D^U CR
◎
↓</li>
	<li>
%LF ~LET `文字$ `000A^U LF
◎
↓</li>
	<li>
%~native行末 ~LET ［
下層の~platform規約は 改行文字を［
%CR, %LF
］並びとして表現するならば その並び ／
~ELSE_ %LF のみ
］が成す文字列
◎
Let native line ending be be the code point U+000A LF.
◎
If the underlying platform’s conventions are to represent newlines as a carriage return and line feed sequence, set native line ending to the code point U+000D CR followed by the code point U+000A LF.
</li>
	<li>
%結果 ~SET 空`文字列$
◎
Set result to the empty string.
</li>
	<li>
%位置 ~LET %s の先頭を指している`位置~変数$
◎
Let position be a position variable for s, initially pointing at the start of s.
</li>
	<li>
<p>
~WHILE %位置↗ ~NEQ ε
◎
＊不要
Let token be the result of collecting a sequence of code points that are not equal to U+000A LF or U+000D CR from s given position.
◎
Append token to result.
◎
While position is not past the end of s:
</p>
		<ol>
			<li>
<p>
~IF［
%位置↗ ~IN { %CR, %LF }
］：
</p>
				<ol>
					<li>
%結果 に %~native行末 を付加する
</li>
					<li>
~IF［
%位置↗ ~EQ %CR
］~AND［
( %位置 ~PLUS 1 )↗ ~EQ %LF
］
⇒
%位置 ~INCBY 1
</li>
					<li>
%位置 ~INCBY 1
</li>
				</ol>
◎
If the code point at position within s equals U+000D CR:
• Append native line ending to result.
• Advance position by 1.
• If position is not past the end of s and the code point at position within s equals U+000A LF advance position by 1.
◎
Otherwise if the code point at position within s equals U+000A LF, advance position by 1 and append native line ending to result.
</li>
			<li>
%結果 に次の結果を付加する
⇒
%s 内の %位置 から［
%LF, %CR
］でない`符号位置~並びを収集する$
◎
Let token be the result of collecting a sequence of code points that are not equal to U+000A LF or U+000D CR from s given position.
◎
Append token to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


<div class="example">
<p>
構築子の用例：
◎
Examples of constructor usage follow.
</p>

<pre class="js-code">
/* <span class="comment">
新たな `Blob^I ~objを作成する
◎
Create a new Blob object
</span> */

var %a = new Blob();

/* <span class="comment">
1024 ~byteの `ArrayBuffer^I を作成する
◎
Create a 1024-byte ArrayBuffer
</span> */
/* <span class="comment">
~bufferは `File^I 読取りからも得られる
◎
buffer could also come from reading a File
</span> */

var %buffer = new ArrayBuffer(1024);

/* <span class="comment">
~bufferに基づく `ArrayBufferView^I ~objを作成する
◎
Create ArrayBufferView objects based on buffer
</span> */

var %shorts = new Uint16Array(%buffer, 512, 128);
var %bytes = new Uint8Array(
  %buffer,
  %shorts.byteOffset + %shorts.byteLength
);

var %b = new Blob(
  ["foobarbazetcetc" + "birdiebirdieboo"],
  {type: "text/plain;charset=utf-8"}
);

var %c = new Blob([%b, %shorts]);

var %a = new Blob([%b, %c, %bytes]);

var %d = new Blob([%buffer, %b, %c, %bytes]);

</pre>

</div>

			</section>
		</section>
		<section id="attributes-blob">
<h3 title="Attributes">3.2. 属性</h3>

<dl class="idl-def">
	<dt>`size@m</dt>
	<dd>
`参照~byte列$の~sizeを~byte数で返す。
◎
size, of type unsigned long long, readonly
◎
Returns the size of the byte sequence in number of bytes.＼
</dd>
	<dd>
取得子は、次を返さ~MUST
⇒
［
`FileReader$I ／ `FileReaderSync$I
］~objにより読取られた，総~byte数
◎
On getting, conforming user agents must return the total number of bytes that can be read by a FileReader or FileReaderSync object, or 0 if the Blob has no bytes to be read. 
</dd>

	<dt>`type@m</dt>
	<dd>
`~Blob$の~MIME型を表現する，~ASCII小文字に符号化された文字列。
◎
type, of type DOMString, readonly
◎
The ASCII-encoded string in lower case representing the media type of the Blob.＼
</dd>
	<dd>
<p>
取得子は、次を返さ~MUST：
</p>
		<ul>
			<li>
~MIME型を決定できるならば、［
~byte列に変換した結果が`構文解析-可能な~MIME型$になる
］ような，~ASCII小文字に符号化された文字列
</li>
			<li>
他の場合は、空~文字列（~byte列に変換されたときに 0 ~byteになる）
</li>
		</ul>
◎
On getting, user agents must return the type of a Blob as an ASCII-encoded string in lower case, such that when it is converted to a byte sequence, it is a parsable MIME type, or the empty string – 0 bytes – if the type cannot be determined.
</dd>
	<dd>
この属性は、~Web~app自身からも［
構築子／ `slice()$m
］の~callを通して設定できる。
これらの場合に適用される更なる規定は、［
<a href="#constructorBlob">`Blob^I 構築子 節</a>,
<a href="#file-constructor">`File^I 構築子 節</a> ／
<a href="#slice-method-algo">`slice()^m ~method 節</a>
］にて与えられる。
</dd>
	<dd>
~UAは、 `~Blob$の `type$m を，とりわけ `参照~byte列$が~disk上の~file由来のものである場合に 決定できる。
この場合に適用される更なる規定は、`~file型~指針$にて与えられる。
◎
The type attribute can be set by the web application itself through constructor invocation and through the slice() call; in these cases, further normative conditions for this attribute are in §3.1 Constructors, §4.1 Constructor, and §3.3.1 The slice method respectively. User agents can also determine the type of a Blob, especially if the byte sequence is from an on-disk file; in this case, further normative conditions are in the file type guidelines.
</dd>

	<dd class="note">注記：
`~Blob$の `type$m は、それを表現している~ASCIIに符号化された文字列を~byte列に変換した結果を `~MIME型の構文解析-$~algoに渡した結果が `失敗^i でないとき，
`構文解析-可能な~MIME型@†
であるものと見なされる。
◎
Note: The type t of a Blob is considered a parsable MIME type, if performing the parse a MIME type algorithm to a byte sequence converted from the ASCII-encoded string representing the Blob object’s type does not return undefined.
</dd>
	<dd class="trans-note">【†
原文のこの用語は，実際には `MIMESNIFF$r を参照しているが、その用語は，今や廃されている。
おそらく，この用語を利用している箇所は、`妥当な~MIME型$を利用するべきであろう。
】</dd>
	<dd class="note">注記：
`type$m 属性は、`符号化方式を決定-$するとき, および
`~blob~URL$を`~fetch$する際に `Content-Type^h ~headerを決定するとき
◎
Note: Use of the type attribute informs the encoding determination and determines the Content-Type header when fetching blob URLs.
</dd>
</dl>

		</section>
		<section id="methodsandparams-blob">
<h3 title="Methods and Parameters">3.3. ~methodと引数</h3>

<dl class="idl-def">
	<dt id="slice-method-algo">`slice(start, end, contentType)@m</dt>
	<dd>
<p>
この~method（引数はいずれも省略可）は、次のようにされた新たな `Blob$I ~objを返す：
</p>
		<ul>
			<li>
その`参照~byte列$は、此れの`参照~byte列$の中の，［
`start@V
引数から
`end@V
引数の直前まで
］の範囲（ 0 が最初の~byteを指す）を成す~byte列。
</li>
			<li>
その `type$m 属性は、
`contentType@V
引数で与えられる
— それは、 `Blob^I の~MIME型を表現する。
</li>
		</ul>

◎
The slice() method returns a new Blob object with bytes ranging from the optional start parameter up to but not including the optional end parameter, and with a type attribute that is the value of the optional contentType parameter.＼
</dd>
	<dd>
<p>
被呼出時には、次に従って動作し~MUST：
◎
It must act as follows:
</p>
		<ol>
			<li>
%size ~LET 此れの`参照~byte列$の総~byte数
◎
↓</li>
			<li>
<p>
%start ~SET `start$V に応じて，次で与えられる値：
</p>

<ol ><li>省略時は 0
</li><li>負の場合は max( ( %size + `start$V ), 0)
</li><li>他の場合は min( `start$V, %size )
</li></ol>

◎
Let O be the Blob context object on which the slice() method is being called.
◎
The optional start parameter is a value for the start point of a slice() call, and must be treated as a byte-order position, with the zeroth position representing the first byte. User agents must process slice() with start normalized according to the following:
◎
If the optional start parameter is not used as a parameter when making this call, let relativeStart be 0.
◎
If start is negative, let relativeStart be max((size + start), 0).
◎
Else, let relativeStart be min(start, size).
</li>
			<li>
<p>
%end ~SET `end$V に応じて，次で与えられる値：
</p>

<ol ><li>省略時は %size
</li><li>負の場合は max( ( %size + `end$V ), 0 )
</li><li>他の場合は min( `end$V, %size )
</li></ol> 

<!-- 
切出しの終端に対応する値：
 -->
◎
The optional end parameter is a value for the end point of a slice() call. User agents must process slice() with end normalized according to the following:
◎
If the optional end parameter is not used as a parameter when making this call, let relativeEnd be size.
◎
If end is negative, let relativeEnd be max((size + end), 0).
◎
Else, let relativeEnd be min(end, size).
</li>
			<li>
%内容~型 ~LET 空~文字列
◎
↓</li>
			<li>
~IF［
`contentType$V は与えられている
］~AND［
`contentType$V を成すどの文字も 範囲 { `0020^U 〜 `007E^U } に入る
］
⇒
%内容~型 ~SET `~ASCII小文字~化する$( `contentType$V )
◎
The optional contentType parameter is used to set the ASCII-encoded string in lower case representing the media type of the Blob. User agents must process the slice with contentType normalized according to the following:
◎
If the contentType parameter is not provided, let relativeContentType be set to the empty string.
◎
Else let relativeContentType be set to contentType and run the substeps below:
◎
If relativeContentType contains any characters outside the range of U+0020 to U+007E, then set relativeContentType to the empty string and return from these substeps.
◎
Convert every character in relativeContentType to ASCII lowercase.
</li>
			<li>
%span ~LET max( ( %end − %start ), 0 )
◎
Let span be max((relativeEnd - relativeStart), 0).
</li>
			<li>
%data ~LET 此れの`参照~byte列$の中の，~byte位置 %start から連続する %span 個の`~byte列$
◎
↓</li>
			<li>
~RET 次のように初期化された，新たな `Blob$I ~obj
⇒＃
`参照~byte列$ ~SET %data,
`size$m 属性 ~SET %span,
`type$m 属性 ~SET %内容~型
◎
Return a new Blob object S with the following characteristics:
• S refers to span consecutive bytes from O, beginning with the byte at byte-order position relativeStart.
• S.size = span.
• S.type = relativeContentType.
</li>
		</ol>
	</dd>
	<dd class="example">
<p>
種々の `slice()$m ~call例
— この例では、 `Blob$I ~interfaceを継承する `File$I ~interfaceを利用している：
◎
The examples below illustrate the different types of slice() calls possible. Since the File interface inherits from the Blob interface, examples are based on the use of the File interface.
</p>

<pre class="js-code">
/* <span class="comment">
DOM から得られる `input$e 要素から， `File$I ~objを得る
◎
obtain input element through DOM
</span> */
var %file = document.getElementById('file').files[0];

if(%file) {
  /* <span class="comment">
%file を複製する
— 次の 2 つの~callは等価
◎
create an identical copy of file
the two calls below are equivalent
</span> */
  var %fileClone = %file.slice();
  var %fileClone2 = %file.slice(0, %file.size);

  /* <span class="comment">
%file の後半を成す~chunkを切出す
— 負数を用いていることに注意
◎
slice file into 1/2 chunk starting at middle of file
Note the use of negative number
</span> */
  var %fileChunkFromEnd = %file.slice(-(Math.round(%file.size/2)));

  /* <span class="comment">
%file の前半を成す~chunkを切出す
◎
slice file into 1/2 chunk starting at beginning of file
</span> */
  var %fileChunkFromStart = %file.slice(0, Math.round(%file.size/2));

  /* <span class="comment">
%file の［
先頭から，末尾から 150 ~byte手前まで
］の部分を切出す
◎
slice file from beginning till 150 bytes before end
</span> */
  var %fileNoMetadata = %file.slice(0, -150, "application/experimental");
}
</pre>

	</dd>
</dl>


		</section>
	</section>

	<section id="file-section">
<h2 title="The File Interface">4. `File^I ~interface</h2>

<p>
`File$I ~objは、［
文字列を値にとる `name$m 属性
］も伴う， `Blob$I ~objである。
それは、~Web~appの中で構築子を通して作成されるか，あるいは
下層の~OS~file~systemからの~fileを成す`~byte列$への参照である。
◎
A File object is a Blob object with a name attribute, which is a string; it can be created within the web application via a constructor, or is a reference to a byte sequence from a file from the underlying (OS) file system.
</p>

<p>
`File$I ~objの`参照~byte列$が~disk上の~file由来の`~byte列$である場合、その`~snapshot状態$は，~objの作成-時点における~fileの状態を~~反映するべきである。
◎
If a File object is a reference to a byte sequence originating from a file on disk, then its snapshot state should be set to the state of the file on disk at the time the File object is created.
</p>

<p class="note">注記：
これは~UAにとって実装するのは自明でない要件であるため、
“<em>〜し~MUST</em>” ではなく， “<em>〜する~SHOULD</em>”
とされている `RFC2119$r。
~UAは、 `File$I ~objの`~snapshot状態$が，参照が得られる時点における~disk上の下層~storageの状態に設定されるように、努めるべきである。
その時点より後に~disk上の~fileが改変された場合、`~snapshot状態$は，下層~storageの状態と異なるようになる。
~UAは、改変~時刻印その他の仕組みを利用して，`~snapshot状態$を管理してもよいが、それについては実装の詳細に委ねられる。
◎
Note: This is a non-trivial requirement to implement for user agents, and is thus not a must but a should [RFC2119]. User agents should endeavor to have a File object’s snapshot state set to the state of the underlying storage on disk at the time the reference is taken. If the file is modified on disk following the time a reference has been taken, the File's snapshot state will differ from the state of the underlying storage. User agents may use modification time stamps and other mechanisms to maintain snapshot state, but this is left as an implementation detail.
</p>

<p>
`File$I ~objが~disk上の~fileを参照している場合、~UAは，~objの `type$m 属性の取得子が［
以下に与える
`~file型~指針@
に従うような，~MIME型
］を返すようにし~MUST：
◎
When a File object refers to a file on disk, user agents must return the type of that file, and must follow the file type guidelines below:
</p>

<ul>
	<li>
<p>
~MIME型は、次のようにすること：
</p>
		<ul class="switch">
			<li>
~fileの~MIME型を決定できる場合
⇒
［
~byte列に変換した結果が`構文解析-可能な~MIME型$になる
］ような，~ASCII小文字に符号化された文字列
</li>
			<li>
他の場合
⇒
空~文字列（~byte列に変換されたときに 0 ~byteになる）
</li>
		</ul>
◎
User agents must return the type as an ASCII-encoded string in lower case, such that when it is converted to a corresponding byte sequence, it is a parsable MIME type, or the empty string – 0 bytes – if the type cannot be determined.
</li>
	<li>
［
`~Blob$の `type$m ~EQ `text/plain^l
］の場合
⇒
~MIME型の［
`~parameter~map$ `MIMESNIFF$r にあたる部位
］には、~charset~parameterを<em>付加しない</em>こと。
◎
When the file is of type text/plain user agents must NOT append a charset parameter to the dictionary of parameters portion of the media type [MIMESNIFF].
</li>
	<li>
（統計的手法も含め）経験則により符号化方式を決定しようと試みないこと。
◎
User agents must not attempt heuristic determination of encoding, including statistical methods.
</li>
</ul>


<pre class="idl">
[<a href="#dom-file-file">Constructor</a>(
    sequence&lt;`BlobPart$I&gt; `fileBits$V,
    `USVString$I `fileName$V,
    optional `FilePropertyBag$I `fileOptions$V
),
 `Exposed$=(Window,Worker),
 `Serializable$]
interface `File@I : `Blob$I {
  readonly attribute `DOMString$I `name$m;
  readonly attribute long long `lastModified$m;
};

dictionary `FilePropertyBag@I : `BlobPropertyBag$I {
      long long `lastModified$dm;
};
</pre>

<p>
`File$I ~objは、`直列化-可能$である：
◎
File objects are serializable objects.＼
</p>

<ul>
	<li>
<p>
その`直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their serialization steps, given value and serialized, are:
</p>
		<ol>
			<li>
%直列形 . `SnapshotState^sl ~SET %値 の`~snapshot状態$
◎
Set serialized.[[SnapshotState]] to value’s snapshot state.
</li>
			<li>
%直列形 . `ByteSequence^sl ~SET %値 の下層の~byte列
◎
Set serialized.[[ByteSequence]] to value’s underlying byte sequence.
</li>
			<li>
%直列形 . `Name^sl ~SET %値 の `name$m 属性の値
◎
Set serialized.[[Name]] to the value of value’s name attribute.
</li>
			<li>
%直列形 . `LastModified^sl ~SET %値 の `lastModified$m 属性の値
◎
Set serialized.[[LastModified]] to the value of value’s lastModified attribute.
</li>
		</ol>
	</li>
	<li>
<p>
その`逆直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their deserialization steps, given value and serialized, are:
</p>

		<ol>
			<li>
%値 の`~snapshot状態$ ~SET %直列形 . `SnapshotState^sl
◎
Set value’s snapshot state to serialized.[[SnapshotState]].
</li>
			<li>
%値 の下層の~byte列 ~SET %直列形 . `ByteSequence^sl
◎
Set value’s underlying byte sequence to serialized.[[ByteSequence]].
</li>
			<li>
%値 の `name$m 属性~値 ~SET %直列形 . `Name^sl に初期化する
◎
Initialize the value of value’s name attribute to serialized.[[Name]].
</li>
			<li>
%値 の `lastModified$m 属性~値 ~SET %直列形 . `LastModified^sl に初期化する
◎
Initialize the value of value’s lastModified attribute to serialized.[[LastModified]].
</li>
		</ol>
	</li>
</ul>

		<section id="file-constructor">
<h3 title="Constructor">4.1. `File^I の構築子</h3>

<dl class="idl-def">
	<dt>`File(fileBits, fileName, fileOptions)@m</dt>
	<dd>
この構築子は、 %fileOptions 辞書~引数（省略可）を利用するかどうかに応じて，
2 個または 3 個の引数で呼出される。
◎
The File constructor is invoked with two or three parameters, depending on whether the optional dictionary parameter is used.＼
</dd>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the File() constructor is invoked, user agents must run the following steps: 
</p>
		<ol>
			<li>
%~byte列 ~LET `~blobを成す各部位を処理する$( `fileBits$V , `fileOptions$V )
◎
Let bytes be the result of processing blob parts given fileBits and options.
</li>
			<li>
<p>
%名前 ~LET `fileName$V 引数を複製した結果の中の各
`002F^U ( `/^l )
を
`003A^U ( `:^l )
に置換した結果
◎
Let n be a new string of the same size as the fileName argument to the constructor. Copy every character from fileName to n, replacing any "/" character (U+002F SOLIDUS) with a ":" (U+003A COLON).
</p>

<p class="note">注記：
~file名に用いられる規約は、下層の~OS~file~system間で異なる
— 構築された~fileに対する UTF-16 の義務付けは、~file名が`~byte列$に変換されたときの多義性を起こり難くする。
◎
Note: Underlying OS filesystems use differing conventions for file name; with constructed files, mandating UTF-16 lessens ambiquity when file names are converted to byte sequences.
</p>

			</li>
			<li>
%種別 ~LET 空~文字列
◎
↓</li>
			<li>
%日時 ~LET `Unix Epoch$ から経過したミリ秒数（
`Date.now()^m `ECMA-262$r
と等価）
◎
↓</li>
			<li>
~IF［
`fileOptions$V に `type$dm ~member %m は`在する$
］~AND［
%m の値 %v を成すどの文字も 範囲 { `0020^U 〜 `007E^U } に入る
］
⇒
%種別 ~SET `~ASCII小文字~化する$( %v )
◎
＊不要
If the optional FilePropertyBag dictionary argument is used, then run the following substeps:
◎
If the type member is provided and is not the empty string, let t be set to the type dictionary member. If t contains any characters outside the range U+0020 to U+007E, then set t to the empty string and return from these substeps.
◎
Convert every character in t to ASCII lowercase.
</li>
			<li>
<p>
~IF［
`fileOptions$V に `lastModified$dm ~memberは`在する$
］
⇒
%日時 ~SET その値
◎
If the lastModified member is provided, let d be set to the lastModified dictionary member. If it is not provided, set d to the current date and time represented as the number of milliseconds since the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
</p>

<p class="note">注記：
`ECMA-262$r `Date$I ~objは， `Unix Epoch$ から経過したミリ秒数を表現する `long long^c 値に変換されるので、 `lastModified$dm ~member値に `Date^I ~objを渡すこともできる。
◎
Note: Since ECMA-262 Date objects convert to long long values representing the number of milliseconds since the Unix Epoch, the lastModified member could be a Date object [ECMA-262].
</p>

			</li>
			<li>
~RET 次のように初期化された，新たな `File$I ~obj
⇒＃
`参照~byte列$ ~SET %~byte列,
`size$m ~SET %~byte列 の総~byte数,
`name$m ~SET %名前,
`type$m ~SET %種別,
`lastModified$m ~SET %日時
◎
Return a new File object F such that:
• F refers to the bytes byte sequence.
• F.size is set to the number of total bytes in bytes.
• F.name is set to n.
• F.type is set to t.
• F.lastModified is set to d.
</li>
		</ol>
	</dd>
</dl>

			<section id="file-constructor-params">
<h4 title="Constructor Parameters">4.1.1. 構築子に渡す引数</h4>

<p>
`File()$m 構築子は次の引数を伴って呼出され得る：
◎
The File() constructor can be invoked with the parameters below:
</p>

<dl class="idl-def">
	<dt>`fileBits@V</dt>
	<dd>
`blobParts$V と同じ。
◎
A fileBits sequence which takes any number of the following elements, and in any order:
◎
BufferSource elements.
◎
Blob elements, which includes File elements.
◎
USVString elements.
</dd>

	<dt>`fileName@V</dt>
	<dd>
~fileの名前を表現する `USVString$I 型の文字列。
この引数に対する規定は， 
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
A USVString parameter representing the name of the file; normative conditions for this constructor parameter can be found in §4.1 Constructor.
</dd>

	<dt>`fileOptions@V
◎
An optional FilePropertyBag dictionary
</dt>
	<dd>
<p>
この `FilePropertyBag$I 辞書~型~引数（省略可）は、
`BlobPropertyBag$I の~memberに加えて，次の~memberを持つ（いずれも省略可）：
◎
which in addition to the members of BlobPropertyBag takes one member:
</p>
		<dl>
			<dt>`lastModified@dm</dt>
			<dd>
~fileの更新日を表現する， `long long^c 型~値。
この~memberに対する規定は，
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
An optional lastModified member, which must be a long long; normative conditions for this member are provided in §4.1 Constructor.
</dd>
		</dl>
	</dd>
	<dd class="trans-note">【
`options$V と同様に、この引数も，構築子を呼出すときに省略された場合、空の辞書~値が渡されたものと見なされる。
】</dd>
	<dd class="trans-note">【
原文の引数~名は %options だが、 `Blob()$m 構築子の同じ名前の引数と紛らわしいので，名前を違えている。
】</dd>
</dl>


			</section>
		</section>
		<section id="file-attrs">
<h3 title="Attributes">4.2. 属性</h3>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
~fileの名前。
◎
name, of type DOMString, readonly
</dd>
	<dd>
取得子は、~fileの名前を文字列として返さ~MUST。
~file名には，下層の~OS~file~system間でいくつもの規約があるが、これは~path情報を持たない単なる~fileの名前である。
~UAは、取得-時に この情報を可用にできない場合は，空~文字列を返さ~MUST。
◎
The name of the file. On getting, this must return the name of the file as a string. There are numerous file name variations and conventions used by different underlying OS file systems; this is merely the name of the file, without path information. On getting, if user agents cannot make this information available, they must return the empty string.＼
</dd>
	<dd>
構築子を用いて作成された `File$I ~objにおける，この属性に適用される更なる規定は、
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
If a File object is created using a constructor, further normative conditions for this attribute are found in §4.1 Constructor.
</dd>

	<dt>`lastModified@m</dt>
	<dd>
~fileの最終更新日。
◎
lastModified, of type long long, readonly
</dd>
	<dd>
取得子は、次を返さ~MUST
⇒
［
この情報を可用にできるならば、 ~fileの最終更新日 ／
知り得ない場合は現在の日時（ `Date.now()^m `ECMA-262$r に等価）
］を表す［
`Unix Epoch$ から経過したミリ秒数による `long long^I 型の値
］
◎
The last modified date of the file. On getting, if user agents can make this information available, this must return a long long set to the time the file was last modified as the number of milliseconds since the Unix Epoch. If the last modification date and time are not known, the attribute must return the current date and time as a long long representing the number of milliseconds since the Unix Epoch; this is equivalent to Date.now() [ECMA-262].＼
</dd>
	<dd>
構築子を用いて作成された `File$I ~objにおける，この属性に適用される更なる規定は、
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
If a File object is created using a constructor, further normative conditions for this attribute are found in §4.1 Constructor.
</dd>
</dl>

		</section>

<div class="p">
<p>
`File$I ~interfaceは、
`FileList$I 型の属性を公開する~objにて可用にされる。
その種の~objは~HTML `HTML$r にて定義されている。
`File$I ~objは、 `Blob$I を継承する変異-不能な~objであり，`読取り演算$が起動された時点で~memory内に読取り可能な~file~dataを表現する。
~UAは、読取り中に~fileが存在しなくなっていた場合には，`読取り~error$とし~MUST
— すなわち：
</p>
<ul>
	<li>
（ Web Worker `WORKERS$r の下で）
`FileReaderSync$I が用いられている場合は `NotFoundError$E 例外を`投出$する。
</li>
	<li>
他の場合は、［
`error$m 属性が `NotFoundError$E 例外を返す
］ようにした上で `error$et ~eventを`発火-$する。
</li>
</ul>
◎
The File interface is available on objects that expose an attribute of type FileList; these objects are defined in HTML [HTML]. The File interface, which inherits from Blob, is immutable, and thus represents file data that can be read into memory at the time a read operation is initiated. User agents must process reads on files that no longer exist at the time of read as errors, throwing a NotFoundError exception if using a FileReaderSync on a Web Worker [Workers] or firing an error event with the error attribute returning a NotFoundError.
</div>


<div class="example">
<p>
下の例では、~file~objからの~metadataが解る様に表示された上で，名前と最終更新日が伴われた `File$I ~objが作成される：
◎
In the examples below, metadata from a file object is displayed meaningfully, and a file object is created with a name and a last modified date.
</p>

<pre class="js-code">
var %file = document.getElementById("filePicker").files[0];
var %date = new Date(%file.lastModified);
println(
    "選択された~file: " + %file.name +
    "~fileの最終更新日: " + %date.toDateString() + "."
);

...

/* <span class="comment">
特定の最終更新日が伴われた~fileを生成する
◎
Generate a file with a specific last modified date
</span> */

var %d = new Date(2013, 12, 5, 16, 23, 45, 600);
var %generatedFile = new File(
    ["Rough Draft ...."],
    "Draft1.txt",
    {type: "text/plain", lastModified: %d}
);

...
</pre>
<!-- 
    "You selected the file " + file.name +
    " which was modified on " + date.toDateString() + "."
 -->

</div>


	</section>
	<section id="filelist-section">
<h2 title="The FileList Interface">5. `FileList^I ~interface</h2>

<p class="note">注記：
`FileList^I ~interfaceは “~risk下にある” ものと見なされるべきである。
~Web~platformでは、この種の~interfaceを
`ECMA-262$r における `Array$I platform ~objに置換するのが，趨勢なので。
特に、
`filelist.item(0)^c の類の構文は~risk下にある。
他のほとんどの［
~programにおける `FileList^I の利用
］については、最終的に `Array^I 型に移行されたとしても，およそ影響されないものと見込まれる。
◎
Note: The FileList interface should be considered "at risk" since the general trend on the Web Platform is to replace such interfaces with the Array platform object in ECMAScript [ECMA-262]. In particular, this means syntax of the sort filelist.item(0) is at risk; most other programmatic use of FileList is unlikely to be affected by the eventual migration to an Array type. 
</p>

<p>
この~interfaceは `File$I ~objの~listを表現する。
◎
This interface is a list of File objects.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker),
 `Serializable$]
interface `FileList@I {
  getter `File$I? <a href="#dfn-item">item</a>(unsigned long `index$V);
  readonly attribute unsigned long `length$m;
};
</pre>

<p>
`FileList$I ~objは、`直列化-可能$である：
◎
FileList objects are serializable objects.＼
</p>

<ul>
	<li>
<p>
その`直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their serialization steps, given value and serialized, are:
</p>

<ol>
	<li>
%直列形 . `Files^sl ~SET 空`~list$
◎
Set serialized.[[Files]] to an empty list.
</li>
	<li>
%値 内の~EACH( %~file ) に対し
⇒
%直列形 . `Files^sl に %~file の`下位直列化$を`付加する$
◎
For each file in value, append the sub-serialization of file to serialized.[[Files]].
</li>
</ol>
	</li>
	<li>
<p>
その`逆直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their deserialization step, given serialized and value, are:
</p>

<ol>
	<li>
%直列形 . `Files^sl 内の~EACH( %~file ) に対し
⇒
%~file の`下位逆直列化$を %値 に追加する
◎
For each file of serialized.[[Files]], add the sub-deserialization of file to value.
</li>
</ol>
	</li>
</ul>


<div class="example">
<p>
~sampleにおいては、概して，~form内の `&lt;input type="file"&gt;^e 要素への DOM ~access, および選択された~fileへの~accessが含められる。
◎
Sample usage typically involves DOM access to the &lt;input type="file"&gt; element within a form, and then accessing selected files.
</p>

<pre class="js-code">
/* <span class="comment">
`uploadData^c は `form$e 要素 ／
`fileChooser^c は `type='file'^c の `input$e 要素
◎
uploadData is a form element
fileChooser is input element of type 'file'
</span> */
var %file = document.forms['uploadData']['fileChooser'].files[0];

/* <span class="comment">
等価な構文
◎
alternative syntax can be
</span> */
// var %file = document.forms['uploadData']['fileChooser'].files.item(0);

if(%file)
{
  /* <span class="comment">
~fileを開く
◎
Perform file ops
</span> */
}
</pre>
</div>

<a id="attributes-filelist"></a>
<a id="filelist-methods-params"></a>

<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
取得子は、次を返さ~MUST
⇒
此れが含んでいる `File$I ~objの総数（なければ 0 になる）
◎
Attributes
◎
length, of type unsigned long, readonly
◎
must return the number of files in the FileList object. If there are no files, this attribute must return 0.
</dd>

	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、［
`index$V ~IN { 此れの`被support~prop~index$ }
ならば 此れの中の %index 番の `File$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
Methods and Parameters
◎
must return the indexth File object in the FileList. If there is no indexth File object in the FileList, then this method must return null.
</dd>
	<dd>
`index@V
引数は、
`FileList$I における `File$I ~objの位置を指し，値 0 が最初の~fileを指すとする。
`FileList$I ~obj %O の`被support~prop~index$は、
0 以上［
%O が含んでいる `File$I ~objの総数
］未満とする。
◎
index must be treated by user agents as value for the position of a File object in the FileList, with 0 representing the first file. Supported property indices are the numbers in the range zero to one less than the number of File objects represented by the FileList object. If there are no such File objects, then there are no supported property indices.
</dd>
</dl>


<p class="note">注記：
`HTML$r における `FileList^I 型の読専~属性を持つ~interfaceには、
`HTMLInputElement^I, `DataTransfer^I 
がある。
前者は，上の例でも~accessされている。
◎
Note: The HTMLInputElement interface has a readonly attribute of type FileList, which is what is being accessed in the above example. Other interfaces with a readonly attribute of type FileList include the DataTransfer interface.
</p>

	</section>

	<section id="reading-data-section">
<h2 title="Reading Data">6. ~dataの読取</h2>

		<section id="readOperationSection">
<h3 title="The Read Operation">6.1. 読取り演算</h3>


<div class="p">
<p>
この節では、この仕様の~methodから呼出される`読取り演算$の~algoを定義する。
読取り演算には，次のものが渡され、~byte~streamとして読取られた`~byte列$を返すか，`失敗事由$を伴って失敗する：
</p>

<ul><li>`~Blob$
</li><li>`同期~flag@
— 演算は、この値に応じて［
~ON ならば同期的 ／
~OFF （既定）ならば非同期的
］に行われる。
</li></ul>

◎
The algorithm below defines a read operation, which takes a Blob and a synchronous flag as input, and reads bytes into a byte stream which is returned as the result of the read operation, or else fails along with a failure reason. Methods in this specification invoke the read operation with the synchronous flag either set or unset.
◎
The synchronous flag determines if a read operation is synchronous or asynchronous, and is unset by default. Methods may set it. If it is set, the read operation takes place synchronously. Otherwise, it takes place asynchronously.
</div>

<p>
`読取り演算@
を遂行するときは、所与の
( `~Blob$ %blob, `同期~flag$ %同期~flag )
に対し，次を走らす：
◎
To perform a read operation on a Blob and the synchronous flag, run the following steps:
</p>

<div>

<ol>
	<li>
%本体 ~LET 新たな `本体$
</li>
	<li>
%本体 の`総~byte数$ ~SET %blob の `size$m
</li>
	<li>
~IF［
%同期~flag ~EQ ~OFF
］
⇒
~RET
— ただし，この手続きは並列的に継続する
</li>
	<li>
<p>
~WHILE［
%blob からすべての~byteを読取り尽くしていない
］：
</p>

		<ol>
			<li>
%~byte列 ~LET %blob から`~chunk$の読取を試みた結果の~byte列
</li>
			<li>
<p>
~IF［
前~段にて`読取り~error$が生じた
］：
</p>

				<ul>
					<li>
%本体 の~error~flag ~SET ~ON
【この~flagは `Fetch$r 仕様から削除された — `~streamを~errorにする$？】
</li>
					<li>
~RET
— `失敗事由$も伴わせて`終了-$する
</li>
				</ul>
			</li>
			<li>
%本体 に %~byte列 を~pushする
</li>
			<li>
%本体 の`伝送-済み~byte数$に %~byte列 の~byte数を加算する
</li>
		</ol>
	</li>
	<li>
~IF［
%同期~flag ~EQ ~ON
］
⇒
~RET %本体
</li>
</ol>


<ol lang="en">
	<li>
<p>
Let s be a a new body, b be the Blob to be read from, and bytes initially set to an empty byte sequence. Set the length on s to the size of b. While there are still bytes to be read in b, perform the following substeps:
</p>

	</li>
	<li>
<p>
If the synchronous flag is set, follow the steps below:
</p>
		<ol>
			<li>
<p>
Let bytes be the byte sequence that results from reading a chunk from b. If a file read error occurs reading a chunk from b, return s with the error flag set, along with a failure reason, and terminate this algorithm.
</p>

<p>
Note: Along with returning failure, the synchronous part of this algorithm must return the failure reason that occurred for throwing an exception by synchronous methods that invoke this algorithm with the synchronous flag set.
</li>
			<li>
If there are no errors, push bytes to s, and increment s’s transmitted [Fetch] by the number of bytes in bytes. Reset bytes to the empty byte sequence and continue reading chunks as above.
</li>
			<li>
When all the bytes of b have been read into s, return s and terminate this algorithm.
</li>
		</ol>
	</li>
	<li>
Otherwise, the synchronous flag is unset. Return s and process the rest of this algorithm asynchronously.
</li>
	<li>
<p>
Let bytes be the byte sequence that results from reading a chunk from b. If a file read error occurs reading a chunk from b, set the error flag on s, and terminate this algorithm with a failure reason.
</p>

<p>
Note: The asynchronous part of this algorithm must signal the failure reason that occurred for asynchronous error reporting by methods expecting s and which invoke this algorithm with the synchronous flag unset.
</p>
	</li>
	<li>
If no file read error occurs, push bytes to s, and increment s’s transmitted [Fetch] by the number of bytes in bytes. Reset bytes to the empty byte sequence and continue reading chunks as above.
</li>
</ol>

</div>


<p>
所与の`~Blob$ %blob に対し，
`注釈付き~task読取り演算@
を遂行するときは、［
`同期~flag$ ~SET ~OFF
］の下で %blob に対する`読取り演算$ %演算 を遂行した上で，以下に従う：
◎
To perform an annotated task read operation on a Blob b, perform the steps below:
◎
Perform a read operation on b with the synchronous flag unset, along with the additional steps below.
</p>

<ul>
	<li>
%演算 が`失敗事由$を伴って終了したときは
⇒
その`失敗事由$で
`読取り~errorを処理する@
ための`~taskを~queueする$
◎
If the read operation terminates with a failure reason, queue a task to process read error with the failure reason and terminate this algorithm.
</li>
	<li>
<p>
%演算 の間に最初の`~chunk$が %body に~pushされるとき†は
⇒
`読取りを開始する@
ための`~taskを~queueする$。
◎
When the first chunk is being pushed to the body s during the read operation, queue a task to process read.
</p>

<p class="trans-note">【†
“being pushed”
— ~pushされる直前なのか？した直後なのか？。
原文の記述からは、`読取りを開始する$ための~task（ `loadstart$et ）抜きで`読取り~errorを処理する$ 可能性も排除できない。
】</p>
	</li>
	<li>
<p >
次に該当する各~時点に
`読取り~dataを処理する@
ための`~taskを~queueする$：
</p>

<ul ><li>(A) 最初に %演算 により %body に 1 個以上の`~chunk$が読取られたとき
</li><li>%blob から読取る`~chunk$が尽きたとき
</li><li>(A) の時点から［
`~chunk$が読取られるごと, または毎 50ms ごとの, <em >少ない方の頻度</em>
］の各時点
</li></ul>

◎
Once the body s from the read operation has at least one chunk read into it, or there are no chunks left to read from b, queue a task to process read data. Keep queuing tasks to process read data for every chunk read or every 50ms, whichever is least frequent.
</li> 

	<li>
%演算 により， %blob からすべての`~chunk$が %body に読取られたときは
⇒
`読取り完了@
用の`~taskを~queueする$
◎
When all of the chunks from b are read into the body s from the read operation, queue a task to process read EOF.
</li>
</ul>

<p>
これらの~taskには，同じ`~file読取~task源$を利用すること。
◎
Use the file reading task source for all these tasks.
</p>


		</section>
		<section id="blobreader-task-source">
<h3 title="The File Reading Task Source">6.2. ~file読取~task源</h3>

<p>
この仕様は、
`~file読取~task源@
と呼ばれる，新たな汎用`~task源$を定義する。
それは、この仕様にて、`~Blob$に結び付けられている~byte列を読取るために，`~queueされ$る~task
］すべてから利用される。
それはまた、~binary~dataの非同期的な読取に呼応して誘発される特色機能
【~eventなど】
用にも利用される。
◎
This specification defines a new generic task source called the file reading task source, which is used for all tasks that are queued in this specification to read byte sequences associated with Blob and File objects. It is to be used for features that trigger in response to asynchronously reading binary data.
</p>

		</section>
		<section id="APIASynch">
<h3 title="The FileReader API">6.3. `FileReader^I ~API</h3>

<pre class="idl">
[<a href="#dom-filereader-filereader">Constructor</a>,
 `Exposed$=(Window,Worker)]
interface `FileReader@I: `EventTarget$I {

  /* <span class="comment">
`非同期~読取り~method$
◎
async read methods
</span> */
  void `readAsArrayBuffer$m(`Blob$I `blob$V);
  void `readAsBinaryString$m(`Blob$I `blob$V);
  void `readAsText$m(`Blob$I `blob$V, optional `DOMString$I `label$V);
  void `readAsDataURL$m(`Blob$I `blob$V);
  void `abort()$m;

  /* <span class="comment">
状態
◎
states
</span> */
  const unsigned short `EMPTY$m = 0;
  const unsigned short `LOADING$m = 1;
  const unsigned short `DONE$m = 2;


  readonly attribute unsigned short `readyState$m;

  /* <span class="comment">
`File^I または `Blob^I ~data
◎
File or Blob data
</span> */
  readonly attribute (`DOMString$I or `ArrayBuffer$I)? `result$m;

  readonly attribute `DOMException$I? `error$m;

  /* <span class="comment">
~event~handler内容~属性
◎
event handler content attributes
</span> */
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onloadend$m;

};
</pre>


			<section id="filereaderConstrctr">
<h4 title="Constructors">6.3.1. 構築子</h4>

<dl class="idl-def">
	<dt>`FileReader()@m</dt>
	<dd>
この構築子の被呼出時には、新たな `FileReader$I ~objを返さ~MUST。
◎
When the FileReader() constructor is invoked, the user agent must return a new FileReader object.
</dd>
	<dd>
この構築子は、大域~objが［
`Window$I ／ `WorkerGlobalScope$I
］~objで表現される環境においては，可用にされ~MUST。
◎
In environments where the global object is represented by a Window or a WorkerGlobalScope object, the FileReader constructor must be available.
</dd>
</dl>

			</section>
			<section id="event-handler-attributes-section">
<h4 title="Event Handler Content Attributes">6.3.2. ~event~handler内容~属性</h4>

<p>
~UAは、 `FileReader$I の DOM 属性として，次の`~event~handler内容~属性$（およびそれらに対応する`~event~handler ~event型$
）を~supportし~MUST：
◎
The following are the event handler content attributes (and their corresponding event handler event types) that user agents must support on FileReader as DOM attributes:
</p>

<table>
<thead><tr><th>`~event~handler内容~属性$
<th>`~event~handler ~event型$
</thead>

<tbody><tr><td>`onloadstart@m
<td>`loadstart$et

<tr><td>`onprogress@m
<td>`progress$et

<tr><td>`onabort@m
<td>`abort$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onload@m
<td>`load$et

<tr><td>`onloadend@m
<td>`loadend$et

</tbody></table>

			</section>
			<section id="blobreader-state">
<h4 title="FileReader States">6.3.3. `FileReader^I の状態</h4>

<p>
`FileReader$I ~objは 3 種の状態をとり得る：
◎
The FileReader object can be in one of 3 states.＼
</p>

<dl class="idl-def">
	<dt>`readyState@m</dt>
	<dd>
<p>
取得子は、此れの現在の状態を次のいずれかの値として返さ~MUST：
◎
The readyState attribute, on getting, must return the current state, which must be one of the following values:
</p>

		<dl>
			<dt>`EMPTY@m （数値 0 ）</dt>
			<dd>
此れは構築~済みであるが、まだ読取り待ちは生じていない。
`読取り~method$はまだ一度も~callされていない。
◎
The FileReader object has been constructed, and there are no pending reads. None of the read methods have been called.＼
</dd>
			<dd>
これが、いずれかの`読取り~method$が~callされるまでの，新たに創出された `FileReader$I ~objにおける既定の状態である。
◎
This is the default state of a newly minted FileReader object, until one of the read methods have been called on it.
</dd>

			<dt>`LOADING@m （数値 1 ）</dt>
			<dd>
`~Blob$は読取り中の状態にある。
`読取り~method$のいずれかが処理されていて，読取りにまだ~errorは生じていない。
◎
A File or Blob is being read. One of the read methods is being processed, and no error has occurred during the read.
</dd>

			<dt>`DONE@m （数値 2 ）</dt>
			<dd>
`~Blob$の全体が~memory内に読取られたか,
<em >または</em> `読取り~error$が生じたか,
<em >または</em> 読取りが `abort()$m により中止されている。
此れはそれ以降は`~Blob$の読取を行わない。
この状態にある場合、少なくともいずれかの`読取り~method$が，此れ上で~callされている。
◎
The entire File or Blob has been read into memory, OR a file read error occurred, OR the read was aborted using abort(). The FileReader is no longer reading a File or Blob. If readyState is set to DONE it means at least one of the read methods have been called on this FileReader.
</dd>
		</dl>
	</dd>
</dl>

			</section>
			<section id="reading-a-file">
<h4 title="Reading a File or Blob">6.3.4. `File^I／`Blob^I の読取</h4>

<p>
`FileReader$I ~interfaceには、~fileを非同期的に~memory内に読取る数種の
`非同期~読取り~method@
— `readAsArrayBuffer()$m, `readAsBinaryString()$m, `readAsText()$m, `readAsDataURL()$m —
が可用にされている。
これらの読取り~methodが，同じ `FileReader$I ~objに対し同時並行的に重ねて~callされた場合、~UAは［
`readyState$m ~EQ `LOADING$m
］の間に生じたどの読取り~methodに対しても，
`InvalidStateError$E を`投出$し~MUST。
◎
The FileReader interface makes available several asynchronous read methods—readAsArrayBuffer(), readAsBinaryString(), readAsText() and readAsDataURL(), which read files into memory. If multiple concurrent read methods are called on the same FileReader object, user agents must throw an InvalidStateError on any of the read methods that occur when readyState = LOADING.
</p>

<p>
`FileReaderSync$I も，類似する数種の`同期~読取り~method$を可用にする。
これらの同期／非同期の読取り~methodは、併せて，
`読取り~method@
と総称される。
◎
(FileReaderSync makes available several synchronous read methods. Collectively, the sync and async read methods of FileReader and FileReaderSync are referred to as just read methods.)
</p>


				<section id="filedata-attr">
<h5 title="The result attribute">6.3.4.1. `result^m 属性</h5>

<dl class="idl-def">
	<dt>`result@m</dt>
	<dd>
此れに対し~callされた`読取り~method$に応じて, および~errorが生じた場合はその~errorに応じて、［
`DOMString$I, `ArrayBuffer$I, ~NULL
］のいずれかになる。
◎
↓</dd>
	<dd>
<p>
取得子は、次の手続きの結果で与えられる`~Blob$の~dataを返さ~MUST：
◎
On getting, the result attribute returns a Blob's data as a DOMString, or as an ArrayBuffer, or null, depending on the read method that has been called on the FileReader, and any errors that may have occurred.
◎
The list below is normative for the result attribute and is the conformance criteria for this attribute:
</p>

		<ol>
			<li>
~IF［
此れの `readyState$m ~EQ `EMPTY$m （まだ此れ上に`読取り~method$は~callされていない）
］
⇒
~RET ~NULL
◎
On getting, if the readyState is EMPTY (no read method has been called) then the result attribute must return null.
</li>
			<li>
~IF［
`~Blob$の読取に~errorが生じていた
］
⇒
~RET ~NULL （利用されている`読取り~method$に<em >かかわらず</em>）
◎
On getting, if an error in reading the File or Blob has occurred (using any read method) then the result attribute must return null.
</li>
			<li>
<p>
~RET 此れ上で~callされた`読取り~method$に応じて，次で与えられる値：
◎
↓</p>

<dl class="switch">
	<dt>`readAsDataURL()$m</dt>
	<dd>
`~Blob$の~dataを`~data_URL$に符号化した結果の `DOMString$I
◎
On getting, if the readAsDataURL() read method is used, the result attribute must return a DOMString that is a Data URL [RFC2397] encoding of the File or Blob's data.
</dd>

	<dt>`readAsBinaryString()$m</dt>
	<dd>
次の結果を表現する `DOMString$I
⇒
`同型に復号する$( `~Blob$の~data )
◎
On getting, if the readAsBinaryString() read method is called and no error in reading the File or Blob has occurred, then the result attribute must return a DOMString representing the File or Blob's data as a binary string, in which every byte is represented by a code unit of equal value [0...255].
</dd>

	<dt>`readAsText()$m</dt>
	<dd>
`~Blob$の~dataを表現する~text文字列。
この文字列は`符号化方式を決定-$した結果の形式の下で， `DOMString$I として~memory内に`復号-$されるべきである。
◎
On getting, if the readAsText() read method is called and no error in reading the File or Blob has occurred, then the result attribute must return a string representing the File or Blob's data as a text string, and should decode the string into memory in the format specified by the encoding determination as a DOMString.
</dd>

	<dt>`readAsArrayBuffer()$m</dt>
	<dd>
`~Blob$の~dataを表現する `ArrayBuffer$I ~obj。
◎
On getting, if the readAsArrayBuffer() read method is called and no error in reading the File or Blob has occurred, then the result attribute must return an ArrayBuffer object.
</dd>
</dl>
			</li>
		</ol>

	</dd>

<!-- ＊
読取り中（
`readyState$m が `LOADING$m
）の場合の記述が抜けている（ ~NULL を返す？）。
 -->

</dl>
				</section>
				<section id="_read-async-methods">
<h5>6.3.4.2 〜 5. 各種 非同期~読取り~method</h5>

<div >

<p class="trans-note">【
この訳では、各種 `非同期~読取り~method$の定義を，この節の中で一括して与える（原文では，~methodごとに個別に定義されているが、それらの大部分の記述は重複しているので）。
】</p>

	<div lang="en">

<h5>6.3.4.2. The readAsDataURL() method</h5>
<p>
When the readAsDataURL(blob) method is called, the user agent must run the steps below.
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</li>
	<li>
To process read error with a failure reason, proceed to §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE.
</li>
			<li>
<p>
Set the result attribute to the body returned by the read operation as a DataURL [RFC2397]; on getting, the result attribute returns the blob as a Data URL [RFC2397].
</p>

				<ul>
					<li>
Use the blob’s type attribute as part of the Data URL if it is available in keeping with the Data URL specification [RFC2397].
</li>
					<li>
If the type attribute is not available on the blob return a Data URL without a media-type. [RFC2397]. Data URLs that do not have media-types [RFC2046] must be treated as plain text by conforming user agents. [RFC2397].
</li>
				</ul>
			</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

<h5>6.3.4.3. The readAsText() method</h5>

<p>
The readAsText() method can be called with an optional parameter, label, which is a DOMString argument that represents the label of an encoding [Encoding]; if provided, it must be used as part of the encoding determination used when processing this method call.
</p>

<p>
When the readAsText(blob, label) method is called, the user agent must run the steps below.
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</li>
	<li>
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE.
</li>
			<li>
Set the result attribute to the body returned by the read operation, represented as a string in a format determined by the encoding determination.
</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

<h5>6.3.4.4. The readAsArrayBuffer() method</h5>

<p>
When the readAsArrayBuffer(blob) method is called, the user agent must run the steps below.
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
<p>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</p>

	<li>
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE.
</li>
			<li>
Set the result attribute to the body returned by the read operation as an ArrayBuffer object.
</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

<h5>6.3.4.5. The readAsBinaryString() method</h5>

<p>
When the readAsBinaryString(blob) method is called, the user agent must run the steps below.
</p>


<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
<p>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</p>

	<li>
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE
</li>
			<li>
Set the result attribute to the body returned by the read operation as a binary string.
</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

	</div>
</div>


<dl class="idl-def">

	<dt id="readAsDataURL">`readAsDataURL(blob)@m</dt>
	<dt id="readAsDataText">`readAsText(blob, label)@m</dt>
	<dt id="readAsArrayBuffer">`readAsArrayBuffer(blob)@m</dt>
	<dt id="readAsBinaryString">`readAsBinaryString(blob)@m</dt>
	<dd>
<p>
これらの~methodの被呼出時には、次を走らせ~MUST：
</p>

<ol>
	<li>
~IF［
`readyState$m ~EQ `LOADING$m
］
⇒
~THROW `InvalidStateError$E
◎
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
`readyState$m ~SET `LOADING$m
◎
Otherwise set readyState to LOADING.
</li>
	<li>
<p>
`blob$V 引数に対する`注釈付き~task読取り演算$を起動する
— その演算により`~file読取~task源$から`~queueされ$た~taskは、以下に従って，取扱う：
◎
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</p>

		<ul>
			<li>
`読取り~errorを処理する$ときは
⇒
その`失敗事由$を与える下で，`~error手続き$を続行する
◎
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
			<li>
`読取りを開始する$ときは
⇒
此れに向けて `loadstart$et `進捗~eventを発火-$する
◎
To process read fire a progress event called loadstart at the context object.
</li>
			<li>
`読取り~dataを処理する$ときは
⇒
此れに向けて `progress$et `進捗~eventを発火-$する
◎
To process read data fire a progress event called progress at the context object.
</li>
			<li>
<p >
`読取り完了$時には：
◎
To process read EOF run these substeps:
</p>


				<ol>
					<li>
`readyState$m ~SET `DONE$m
◎
Set readyState to DONE.
</li>
					<li>
<p>
此れの `result$m 属性 ~SET ~methodの~~種類に応じて，
`読取り演算$による結果の`本体$を以下に与える表現にした結果：
</p>

<dl class="switch">
	<dt>`readAsDataURL()^m</dt>
	<dd>
<p>
次に従うような`~data_URL$による表現：
</p>

		<ul>
			<li>
`blob$V の `type$m 属性を`~data_URL$の~MIME型の部分に利用できる場合は、~data_URL仕様 `RFC2397$r に従って，それを利用する。
</li>
			<li>
他の場合：
`~data_URL$は~MIME型を伴わない。
~UAは、~MIME型を伴わない`~data_URL$を，素の~text（ `text/plain^l ）として扱わ~MUST。
</li>
		</ul>
◎
Set the result attribute to the body returned by the read operation as a DataURL [RFC2397]; on getting, the result attribute returns the blob as a Data URL [RFC2397].
</dd>

	<dt>`readAsText()^m</dt>
	<dd>
［
`label$V 引数（省略可）から`符号化方式を決定-$して得られる形式
］の文字列による表現
◎
Set the result attribute to the body returned by the read operation, represented as a string in a format determined by the encoding determination.
</dd>

	<dt>`readAsArrayBuffer()^m</dt>
	<dd>
`ArrayBuffer$I ~objによる表現
◎
Set the result attribute to the body returned by the read operation as an ArrayBuffer object.
</dd>

	<dt>`readAsBinaryString()^m</dt>
	<dd>
~binary文字列による表現
◎
Set the result attribute to the body returned by the read operation as a binary string.
</dd>
</dl>
					</li>
					<li>
此れに向けて
`load$et `進捗~eventを発火-$する
◎
Fire a progress event called load at the context object.
</li>
					<li>
<p>
~IF［
`readyState$m ~NEQ `LOADING$m
］
⇒
此れに向けて
`loadend$et `進捗~eventを発火-$する
。
（
`readyState$m が `LOADING$m であるときは，
`loadend$et を<strong>発火しない</strong>こと）
◎
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</p>

<p class="trans-note">【
この下位手続きの最初の段で `DONE$m にされているにもかかわらず，
“`LOADING$m でない” の条件がある理由は、
`load$et の発火により呼出された~event~handlerにより，
`readyState$m が変更され得るため（<a href="#eventInvariants">~event不変則</a>節を参照）。
】</p>

					</li>
				</ol>
			</li>
		</ul>
	</li>
<!-- 
Terminate this algorithm.
 -->
</ol>

	</dd>
</dl>


<p class="note">注記：
`readAsBinaryString()$m よりも
`readAsArrayBuffer()$m の利用が選好される 
— 前者は後方互換性のために供されている。
◎
The use of readAsArrayBuffer() is preferred over readAsBinaryString(), which is provided for backwards compatibility.
</p>


				</section>
				<section id="dfn-error-steps">
<h5 title="Error Steps">6.3.4.6. ~error手続き</h5>

<p>
所与の `FileReader$I ~obj %reader に対し，`失敗事由$で`読取り~errorを処理する$手続きは、次で与えられる：
◎
These error steps are to process read error with a failure reason.
</p>


<ol>
	<li>
%reader の `readyState$m 属性 ~SET `DONE$m
◎
↓</li>
	<li>
%reader の `result$m 属性 ~SET ~NULL
◎
Set the context object’s readyState to DONE and result to null if it is not already set to null.
</li>
	<li>
%reader の `error$m 属性 ~SET `失敗事由$に対応する `DOMException$I ~obj
◎
↓</li>
	<li>
%reader に向けて `error$et `進捗~eventを発火-$する
◎
Set the error attribute on the context object; on getting, the error attribute must be a a DOMException object that corresponds to the failure reason. Fire a progress event called error at the context object.
</li>
	<li>
~IF
%reader の `readyState$m ~NEQ `LOADING$m
］
⇒
%reader に向けて `loadend$et `進捗~eventを発火-$する（
`LOADING$m のときには
`loadend$et を<strong>発火しない</strong>こと）
◎
Unless readyState is LOADING, fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
	<li>
（この~algoを呼び出した）`読取り~method$は，`終了-$させる<!-- ＊ -->
◎
Terminate the algorithm for any read method.
</li>
</ol>

				</section>
				<section id="abort">
<h5 title="The abort() method">6.3.4.7. `abort()^m ~method</h5>

<dl class="idl-def">
	<dt>`abort()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the abort() method is called, the user agent must run the steps below:
</p>

		<ol>
			<li>
~IF［
`readyState$m ~IN { `EMPTY$m, `DONE$m }
］
⇒＃
`result$m ~SET ~NULL；
~RET
◎
If readyState = EMPTY or if readyState = DONE set result to null and terminate this algorithm.
</li>
			<li>
~IF［
`readyState$m ~EQ `LOADING$m
］
⇒＃
`readyState$m ~SET `DONE$m；
`result$m  ~SET ~NULL
◎
If readyState = LOADING set readyState to DONE and result to null.
</li>
			<li>
此れに提携して`~queueされ$ている すべての`~task$を、`~file読取~task源$から除去する
◎
If there are any tasks from the context object on the file reading task source in an affiliated task queue, then remove those tasks from that task queue.
</li>
			<li>
`読取り~method$が処理-中であれば、それを`終了-$させる
◎
Terminate the algorithm for the read method being processed.
</li>
			<li>
`abort$et `進捗~eventを発火-$する
◎
Fire a progress event called abort.
</li>
			<li>
`loadend$et `進捗~eventを発火-$する
◎
Fire a progress event called loadend.
</li>
		</ol>
	</dd>
</dl>

				</section>
				<section id="blobAndFileParams">
<h5 title="Blob Parameters">6.3.4.8. `blob^V 引数</h5>

<p>
各種 `読取り~method$, および `URL.createObjectURL()$m
は、`~Blob$を引数にとる。
この節ではこの引数を定義する。
◎
The asynchronous read methods, the synchronous read methods, and URL.createObjectURL() take a Blob parameter. This section defines this parameter.
</p>

<dl>
	<dt>`blob@V</dt>
	<dd>
<p >
これは`~Blob$であり、次のいずれかへの参照で~MUST：
</p>
<ul ><li>`FileList$I ~objの中の，ある `File$I ~obj
</li><li>下層の~OS~file~systemから得られたものではない `Blob$I ~obj
</li></ul>

◎
This is a Blob argument and must be a reference to a single File in a FileList or a Blob argument not obtained from the underlying OS file system.
</dd>

</dl>

				</section>
			</section>
		</section>
		<section id="enctype">
<h3 title="Determining Encoding">6.4. 符号化方式の決定-法</h3>

<p>
`readAsText()$m `読取り~method$を用いて`~Blob$を読取る際に、
`符号化方式を決定-@
するときは、次の手続きに従わ~MUST：
◎
When reading Blob objects using the readAsText() read method, the following encoding determination steps must be followed:
</p>

<ol>
	<li>
%符号化方式 ~SET `失敗^i
◎
Let encoding be null.
</li>
	<li>
~IF［
`label@V 引数は与えられている
］
⇒
%符号化方式 ~SET `~labelから符号化方式を取得する$( `label$V 引数 )
◎
If the label argument is present when calling the method, set encoding to the result of the getting an encoding from label.
◎
If the getting an encoding steps above return failure, then set encoding to null.
</li>
	<li>
<p>
~IF［
%符号化方式 ~EQ `失敗^i
］~AND［
`blob$V 引数に `type$m 属性は在る
］~AND［
その属性は Charset Parameter `RFC2046$r を利用している
］
⇒
%符号化方式 ~SET `~labelから符号化方式を取得する$( Charset Parameter の中の`符号化方式~label$を成す部分 )
</p>

<p class="example">
`blob$V の `type$m 属性の値が
`text/plain;charset=utf-8^samp ならば、結果の~labelは `utf-8^l になる。
<!-- ＊ -->
~UAは、 Charset Parameter を構文解析して，`符号化方式~label$を成す部位を取り出さ~MUSTことに注意。
</p>

◎
If encoding is null, and the blob argument’s type attribute is present, and it uses a Charset Parameter [RFC2046], set encoding to the result of getting an encoding for the portion of the Charset Parameter that is a label of an encoding.
◎
If blob has a type attribute of text/plain;charset=utf-8 then getting an encoding is run using "utf-8" as the label. Note that user agents must parse and extract the portion of the Charset Parameter that constitutes a label of an encoding.
◎
If the getting an encoding steps above return failure, then set encoding to null.
</li>
	<li>
~IF［
%符号化方式 ~EQ `失敗^i
］
⇒
%符号化方式 ~SET `~UTF-8$
◎
If encoding is null, then set encoding to utf-8.
</li>
	<li>
~RET `~Unicodeに復号する$( %符号化方式, `blob$V )
— ［
`FileReader$I ~objの `result$m 属性の取得子
］, および［
`FileReaderSync$I ~objの同期的
<a href="#dfn-readAsTextSync">`readAsText^m</a> ~method
］においては、 %符号化方式 形式による文字列を返すようにする。
◎
Decode this blob using fallback encoding encoding, and return the result. On getting, the result attribute of the FileReader object returns a string in encoding format. The synchronous readAsText() method of the FileReaderSync object returns a string in encoding format.
</li>
</ol>

		</section>
		<section id="events">
<h3 title="Events">6.5. ~event</h3>

<p>
この仕様に定義される すべての~eventは，
`FileReader$I ~objをその~targetにし~MUST。
◎
The FileReader object must be the event target for all events in this specification.
</p>

<p>
所与の `FileReader$I ~obj %~target に向けて，
%e
`進捗~eventを発火-@
するときには、次が規定される（ %e は， `ProgressEvent$I ~objの~event名とする）：
◎
When this specification says to fire a progress event called e (for some ProgressEvent e at a given FileReader reader as the context object), the following are normative:
</p>

<ul>
	<li>
浮上しない
— ~eventの `bubbles^m 属性 `DOM$r は ~F にされ~MUST。
◎
The progress event e does not bubble. e.bubbles must be false [DOM]
</li>
	<li>
取消せない
— ~eventの `cancelable^m 属性 `DOM$r は ~F にされ~MUST。
◎
The progress event e is NOT cancelable. e.cancelable must be false [DOM]
</li>
</ul>
			<section id="event-summary">
<h4 title="Event Summary">6.5.1. ~event要覧</h4>

<p>
次の表に、 `FileReader$I ~objに向けて`発火-$される~eventを挙げる。
◎
The following are the events that are fired at FileReader objects.
</p>

<table id="event-summary-table">

<thead><tr><th>~event名
<th>~interface
<th>発火-時機
</thead>

<tbody><tr><td>`loadstart@et
<td>`ProgressEvent$I
<td>
読取りが開始されるとき。
◎
When the read starts.

<tr><td>`progress@et
<td>`ProgressEvent$I
<td>
`blob$V 読取り中（および復号-中）の間
◎
While reading (and decoding) blob

<tr><td>`abort@et
<td>`ProgressEvent$I
<td>
読取りが中止されたとき。
例えば `abort()$m ~methodが呼出されたとき。
◎
When the read has been aborted.
For instance, by invoking the abort() method.

<tr><td>`error@et
<td>`ProgressEvent$I
<td>
読取りが失敗したとき（`読取り~error$を見よ）。
◎
When the read has failed (see file read errors).

<tr><td>`load@et
<td>`ProgressEvent$I
<td>
読取りが成功裡に完了したとき。
◎
When the read has successfully completed.

<tr><td>`loadend@et
<td>`ProgressEvent$I
<td>
要請が完了したとき（成功／失敗のいずれでも）。
◎
When the request has completed (either in success or failure).

</tbody></table>

			</section>
			<section id="eventInvariants">
<h4 title="Summary of Event Invariants">6.5.2. ~event不変則の要約</h4>

~INFORMATIVE

<p>
この仕様で与えられる非同期`読取り~method$に対する~eventの発火には、次の不変則が成り立つ：
◎
The following are invariants applicable to event firing for a given asynchronous read method in this specification:
</p>

<ol>
	<li>
<p>
一度 `loadstart$et が発火された後、対応する `loadend$et が読取り完了~時に発火される。
<em >ただし</em>、次のいずれかに該当する場合を除く：
◎
Once a loadstart has been fired, a corresponding loadend fires at completion of the read, UNLESS any of the following are true:
</p>

		<ul>
			<li>
`abort()$m により`読取り~method$が取消され，新たに`読取り~method$が呼出された場合
◎
the read method has been cancelled using abort() and a new read method has been invoked
</li>
			<li>
`load$et ~eventに対する~event~handler関数が，新たな読取りを起動させた場合
◎
the event handler function for a load event initiates a new read
</li>
			<li>
`error$et ~eventに対する~event~handler関数が，新たな読取りを起動させた場合
◎
the event handler function for a error event initiates a new read.
</li>
		</ul>

<p class="note">注記：
2 つの~event `loadstart$et と `loadend$et は、一対一の組にされるわけではない。
◎
Note: The events loadstart and loadend are not coupled in a one-to-one manner.
</p>

<div class="example">
<p>
“読取りの連鎖”，すなわち “最初の” 読取り処理は継続しつつ，~event~handlerの中で別の読取りを起動する例を示す：
◎
This example showcases "read-chaining": initiating another read from within an event handler while the "first" read continues processing.
</p>

<pre class="js-code">
/* <span class="comment">
次の類いの~codeにおいて …
◎
In code of the sort...
</span> */
%reader.readAsText(%file);
%reader.onload = function(){%reader.readAsText(%alternateFile);}

.....

/* <span class="comment">
… 最初の読取りに対しては `loadend^et ~eventは発火されては~MUST_NOT
◎
... the loadend event must not fire for the first read
</span> */

%reader.readAsText(%file);
%reader.abort();
%reader.onabort = function(){%reader.readAsText(%updatedFile);}

/* <span class="comment">
… 最初の読取りに対しては `loadend^et ~eventは発火されては~MUST_NOT
◎
... the loadend event must not fire for the first read
</span> */
</pre>

		</div>
	</li>
	<li>
`blob$V が~memory内に完全に読取られた時点で `progress$et ~eventが 1 回 発火されることになる。
◎
One progress event will fire when blob has been completely read into memory.
</li>
	<li>
`loadstart$et より前に `progress$et ~eventが発火されることはない。
◎
No progress event fires before loadstart.
</li>
	<li>
`abort$et,
`load$et,
`loadend$et
の，どの発火-後にも
`progress$et ~eventが発火されることはない。
与えられた読取りに対し，少なくとも
`abort$et,
`load$et,
`error$et
のいずれかが発火される。
◎
No progress event fires after any one of abort, load, and error have fired. At most one of abort, load, and error fire for a given read.
</li>
	<li>
`loadend$et の後に
`abort$et,
`load$et,
`error$et
~eventが発火されることはない。
◎
No abort, load, or error event fires after loadend.
</li>
</ol>
			</section>
		</section>
		<section id="readingOnThreads">
<h3 title="Reading on Threads">6.6. ~threadによる読取り</h3>

<p>
Web Workers `WORKERS$r においては
`~Blob$に対する
同期的な読取り~APIも利用できる。
その種の読取り~threadが~main~threadを阻むことはない。
この節では、~workerにて利用できる同期的~APIを定義する。
~workerには非同期~API（ `FileReader$I ~obj）
<em>および</em>
同期的~API（ `FileReaderSync$I ~obj）が用意されている。
◎
Web Workers allow for the use of synchronous File or Blob read APIs, since such reads on threads do not block the main thread. This section defines a synchronous API, which can be used within Workers [[Web Workers]]. Workers can avail of both the asynchronous API (the FileReader object) and the synchronous API (the FileReaderSync object).
</p>

			<section id="FileReaderSync">
<h3 title="The FileReaderSync API">6.6.1. `FileReaderSync^I ~API</h3>

<p>
この~interfaceは
`~Blob$を~memory内に同期的に読取るための
`同期~読取り~method@
を供する。
◎
This interface provides methods to synchronously read File or Blob objects into memory.
</p>

<pre class="idl">
[<a href="#dom-filereadersync-filereadersync">Constructor</a>,
 `Exposed$=(DedicatedWorker,SharedWorker)]
interface `FileReaderSync@I {

  /* <span class="comment">
同期的に文字列を返す
◎
Synchronously return strings
</span> */

  `ArrayBuffer$I `readAsArrayBuffer$mS(`Blob$I `blob$V);
  `DOMString$I `readAsBinaryString$mS(`Blob$I `blob$V);
  `DOMString$I `readAsText$mS(`Blob$I `blob$V, optional `DOMString$I `label$V);
  `DOMString$I `readAsDataURL$mS(`Blob$I `blob$V);
};
</pre>

				<section id="filereadersyncConstrctr">
<h5 title="Constructors">6.6.1.1. 構築子</h5>

<dl class="idl-def">
	<dt>`FileReaderSync()@m</dt>
	<dd>
この構築子の被呼出時には、新たな `FileReaderSync$I ~objを返さ~MUST。
◎
When the FileReaderSync() constructor is invoked, the user agent must return a new FileReaderSync object.
</dd>
	<dd>
この構築子は、大域~objが `WorkerGlobalScope$I ~objで表現される環境においては，可用にされ~MUST。
◎
In environments where the global object is represented by a WorkerGlobalScope object, the FileReaderSync constructor must be available.
</dd>
</dl>

				</section>
				<section id="_read-sync-methods">
<h5>6.6.1.2 〜 5. 各種 同期~読取り~method</h5>

<div>

<p class="trans-note">【
この訳では、各種 `同期~読取り~method$の定義を，この節の中で一括して与える（原文では，~methodごとに個別に定義されているが、それらの大部分の記述は重複しているので）。
】</p>

	<div lang="en">
<h5>6.6.1.2. The readAsText() method</h5>
<p>
When the readAsText(blob, label) method is called, the following steps must be followed:
</p>

<ol>
	<li>
Initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
If no error has occurred, return the result of the read operation represented as a string in a format determined through the encoding determination algorithm.
</li>
</ol>

<h5>6.6.1.3. The readAsDataURL() method</h5>

<p>
When the readAsDataURL(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
Initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
If no error has occurred, return the result of the read operation as a Data URL [RFC2397] subject to the considerations below:

		<ul>
			<li>
Use the blob’s type attribute as part of the Data URL if it is available in keeping with the Data URL specification [RFC2397].
</li>
			<li>
If the type attribute is not available on the blob return a Data URL without a media-type. [RFC2397]. Data URLs that do not have media-types [RFC2046] must be treated as plain text by conforming user agents. [RFC2397].
</li>
		</ul>
	</li>
</ol>

<h5>6.6.1.4. The readAsArrayBuffer() method</h5>

<p>
When the readAsArrayBuffer(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
Initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
◎
If no error has occurred, return the result of the read operation as an ArrayBuffer.
</li>
</ol>

<h5>6.6.1.5. The readAsBinaryString() method</h5>

<p>
When the readAsBinaryString(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
Initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
If no error has occurred, return the result of the read operation as an binary string.
</li>
</ol>

	</div>
</div>


<dl class="idl-def">
	<dt id="readAsTextSync">`readAsDataURL(blob)@mS</dt>
	<dt id="readAsDataURLSync-section">`readAsText(blob, label)@mS</dt>
	<dt id="readAsArrayBufferSyncSection">`readAsArrayBuffer(blob)@mS</dt>
	<dt id="readAsBinaryStringSyncSection">`readAsBinaryString(blob)@mS</dt>
	<dd>
<p>
これらの~methodの被呼出時には、次を走らせ~MUST：
◎
When the readAsArrayBuffer(blob) method is called, the following steps must be followed:
</p>
		<ol>
			<li>
%本体 ~SET `blob$V を引数に［
`同期~flag$ ~SET ~ON
］の下で，`読取り演算$を行った結果
◎
Otherwise, initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
			<li>
~IF［
前~段の`読取り演算$が`失敗事由$を伴って終了した
］
⇒
~THROW 失敗事由に<a href="#dfn-error-codes">適切な例外</a>
◎
↑</li>
			<li>
<p>
~RET ~methodの~~種類に応じて， %本体 を次で与えられる表現にした結果：
</p>

				<dl class="switch">
					<dt>`readAsText()^m</dt>
					<dd>
`label$V 引数（省略可）から`符号化方式を決定-$して得られる形式による文字列
</dd>

					<dt>`readAsDataURL()^m</dt>
					<dd>
<p>
下記に従うような`~data_URL$
</p>

						<ul>
							<li>
~data_URL仕様 `RFC2397$r に従う形で，
`blob$V の `type$m 属性を`~data_URL$の~MIME型の部分に利用できる場合は、そのようにする。
</li>
							<li>
他の場合：
`~data_URL$は~MIME型を伴わないとする。
~UAは、~MIME型を伴わない`~data_URL$を，素の~text（ `text/plain^l ）として扱わ~MUST。
<!-- ＊
`blob$V に `type$m 属性がない場合、~MIME型を持たない~data_URLを返す
 -->
</li>
						</ul>
					</dd>

					<dt>`readAsArrayBuffer()^m</dt>
					<dd>
`ArrayBuffer$I ~obj
</dd>

					<dt>`readAsBinaryString()^m</dt>
					<dd>
~binary文字列
</dd>
				</dl>
◎
↑</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
`readAsBinaryString()$mS よりも
`readAsArrayBuffer()$mS の利用が選好される 
— 前者は後方互換性のために供されている。
◎
The use of readAsArrayBuffer() is preferred over readAsBinaryString(), which is provided for backwards compatibility.
</p>


				</section>
			</section>
		</section>
	</section>
	<section id="ErrorAndException">
<h2 title="Errors and Exceptions">7. ~errorと例外</h2>

<p>
`読取り~error@
は下層の~file~systemから~fileを読取る際に生じ得る。
起こり得る~errorのいくつかを下に挙げる。
これらは <em>参考</em> である。
◎
File read errors can occur when reading files from the underlying filesystem. The list below of potential error conditions is informative.
</p>

<ul>
	<li>
~accessされている `~Blob$
【の参照~先の~data】
は、`非同期~読取り~method$や`同期~読取り~method$が~callされた時点では，存在しない可能性がある。
これは、その参照が獲得された後に（例えば他の~appにより同時並行的に）移動されたか, または削除されたときに起こり得る。
`NotFoundError$E を見よ。
◎
The File or Blob being accessed may not exist at the time one of the asynchronous read methods or synchronous read methods are called. This may be due to it having been moved or deleted after a reference to it was acquired (e.g. concurrent modification with another application). See NotFoundError.
</li>
	<li>
`~Blob$は読取れない可能性もある。
これは、
`~Blob$への参照が獲得された後に~permissionの問題が生じたときに起こり得る（例えば他の~appにより同時並行的に~lockされたなど）。
加えて，`~snapshot状態$が変化した可能性もある。
`NotReadableError$E を見よ。
◎
A File or Blob may be unreadable. This may be due to permission problems that occur after a reference to a File or Blob has been acquired (e.g. concurrent lock with another application). Additionally, the snapshot state may have changed. See NotReadableError.
</li>
	<li>
~UAは，一部の~fileについて ~Web~app内での利用を安全でないものと定めても~MAY。
~disk上の~fileは 元々の~file選択から変化し得るので、読取り結果は無効なものになり得る。
加えて、一部の~fileや~directory構造は，下層の~file~systemにおいて制約されていることもある。
例えば それらからの読取りは，保安~違反と見なされ得る。
<a href="#security-discussion">保安~上の考慮点</a>,
`SecurityError$E を見よ。
◎
User agents MAY determine that some files are unsafe for use within Web applications. A file may change on disk since the original file selection, thus resulting in an invalid read. Additionally, some file and directory structures may be considered restricted by the underlying filesystem; attempts to read from them may be considered a security violation. See §9 Security and Privacy Considerations and SecurityError.
</li>
</ul>

		<section id="dfn-error-codes">
<h3 title="Throwing an Exception or Returning an Error">7.1. 例外の投出／返される~error</h3>

<p>
この節は規定とする。
◎
This section is normative.
</p>

<p>
`~error条態$は`~Blob$の読取り中に生じ得る。
◎
Error conditions can arise when reading a File or a Blob.
</p>

<p>
`読取り演算$は、`~Blob$の読取~中における`~error条態$により終了し得る。
`読取り演算$を失敗させる, あるいは
`読取り~errorを処理する$ための`~taskを~queueする$ような，個々の`~error条態$は、
`失敗事由@
と呼ばれる。
◎
The read operation can terminate due to error conditions when reading a File or a Blob; the particular error condition that causes a read operation to return failure or queue a task to process read error is called a failure reason.
</p>

<ul>
	<li>
`同期~読取り~method$に対しては、ある`失敗事由$により~errorが生じた場合、下の一覧に挙げる型の例外が`投出$される。
◎
Synchronous read methods throw exceptions of the type in the table below if there has been an error owing to a particular failure reason.
</li>
	<li>
`非同期~読取り~method$に対しては、
`FileReader$I ~objの
`error@m
属性が利用される。
それは、［
ある`失敗事由$により~errorが生じた場合は，下の一覧の中で最も適切な名前の
`DOMException$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
Asynchronous read methods use the error attribute of the FileReader object, which must return a DOMException object of the most appropriate type from the table below if there has been an error owing to a particular failure reason, or otherwise return null.
</li>
</ul>

<table>
<thead><tr><th>
~error名
◎
Type
<th>`失敗事由$とその説明
◎
Description and Failure Reason
</thead>

<tbody><tr><td>`NotFoundError$E
<td>
<p>
次に該当する`失敗事由$に対しては、この型の例外が利用され~MUST：
</p>

<dl>
	<dt>`NotFound@FR</dt>
	<dd>
読取りが処理された時点で`~Blob$の資源が見つからない。
</dd>
</dl>

◎
If the File or Blob resource could not be found at the time the read was processed, this is the NotFound failure reason.
◎
For asynchronous read methods the error attribute must return a NotFoundError exception and synchronous read methods must throw a NotFoundError exception.

<tr><td>`SecurityError$E
<td>

<p>
次に該当する`失敗事由$に対しては、この型の例外が利用されて~MAY：
</p>

<dl>
	<dt> `UnsafeFile@FR</dt>
	<dd>
ある種の~fileに対する ~Web~app内からの~accessが、安全でないものとされた。
</dd>

	<dt>`TooManyReads@FR</dt>
	<dd>
`~Blob$の資源に対する読取り~call回数が多すぎるものとされた。
</dd>

</dl>

<p>
これは、他の `失敗事由$に該当しない状況に利用される保安~上の~errorである。
</p>

◎
If:
it is determined that certain files are unsafe for access within a Web application, this is the UnsafeFile failure reason.
◎
it is determined that too many read calls are being made on File or Blob resources, this is the TooManyReads failure reason.
◎
For asynchronous read methods the error attribute may return a SecurityError exception and synchronous read methods may throw a SecurityError exception.
◎
This is a security error to be used in situations not covered by any other failure reason.

<tr><td>`NotReadableError$E
<td>

<p>
次に該当する`失敗事由$に対しては、この型の例外が利用され~MUST：
</p>

<dl>
	<dt>`SnapshotState@FR</dt>
	<dd>
`~Blob$の`~snapshot状態$が下層~storageの状態に合致しない。
</dd>

	<dt>`FileLock@FR</dt>
	<dd>
概して`~snapshot状態$の確立-後に生じた~permissionの問題により（例えば他の~appにより同時並行的に下層~storageが~lockされたなど）、`~Blob$を読取れない。
</dd>

</dl>

◎
If:
◎
the snapshot state of a File or a Blob does not match the state of the underlying storage, this is the SnapshotState failure reason.
◎
the File or Blob cannot be read, typically due due to permission problems that occur after a snapshot state has been established (e.g. concurrent lock on the underlying storage with another application) then this is the FileLock failure reason.
◎
For asynchronous read methods the error attribute must return a NotReadableError exception and synchronous read methods must throw a NotReadableError exception.

</tbody></table>

		</section>
	</section>
	<section id="url">
<h2 title="A URL for Blob and File reference">8. `Blob^I ／ `File^I への~URL参照</h2>

<p>
この節では`~Blob$を指すために利用される`~URL$の`~scheme$urlを定義する。
◎
This section defines a scheme for a URL used to refer to Blob objects (and File objects).
</p>

<p class="note">注記：
`MEDIA-SOURCE$r などの他の仕様は、他の型の~objも指すために，この~schemeを拡張する。
◎
Note: other specifications, such as [MEDIA-SOURCE] extend this scheme to also refer to other types of objects.
</p>

		<section id="url-intro">
<h3 title="Introduction">8.1. 序論</h3>

~INFORMATIVE

<p>
`~blob~URL$は、
`blob:http://example.com/550e8400-e29b-41d4-a716-446655440000^c
の様な~URLである。
これは、`img$e 要素などの，［
~~普通の~URLを利用するように設計された他の~Web~platform~API
］に`~Blob$を統合することを可能化する。
`~blob~URL$は、~navigateするときや,
~localに生成された~dataの~downloadを誘発するときにも利用できる。
◎
Blob (or object) URLs are URLs like blob:http://example.com/550e8400-e29b-41d4-a716-446655440000. This enables integration of Blobs and Files with other Web Platform APIs that are only designed to be used with URLs, such as the img element. Blob URLs can also be used to navigate to as well as to trigger downloads of locally generated data.
</p>

<p>
この目的で `URL$I ~interfaceには 2 つの静的~method
— `createObjectURL(blob)$m, `revokeObjectURL(url)$m —
が公開される。
前者は `~URL$から `Blob$I への対応付けを作成し，後者は その対応付けを破棄する。
対応付けが存在する限り， `Blob$I は~garbage収集できないので、参照が不要になり次第 ~URLを破棄するよう，【作者は】注意しておく必要がある。
どの`~blob~URL$も、それを作成した大域~objが消去るに伴い，破棄される。
◎
For this purpose two static methods are exposed on the URL interface, createObjectURL(blob) and revokeObjectURL(url). The first method creates a mapping from a URL to a Blob, and the second method revokes said mapping. As long as the mapping exist the Blob can’t be garbage collected, so some care must be taken to revoke the URL as soon as the reference is no longer needed. All URLs are revoked when the global that created the URL itself goes away.
</p>

		</section>
		<section id="url-model">
<h3 title="Model">8.2. ~model</h3>

<div >
<p>
各~UAは、
`~blob~URL~store@
を保守し~MUST
— それは`~map$であり、それを成す各~entryは：
</p>

<ul>
	<li>
<p>
`~blob~URL@
を`~key$mapとする。
それは、`妥当な~URL文字列$であって，それを`~URL構文解析-$した結果の`~URL$は次をすべて満たすものである：
</p>
				<ul>
					<li>
`~scheme$url ~EQ `blob^l
</li>
					<li>
`~host$urlは<a href="~URL1#empty-host">空</a>である
</li>
					<li>
`~path$urlは［
自身も`妥当な~URL文字列$である 1 個の要素
］のみからなる
</li>
				</ul>
	</li>
	<li>
<p>
`~blob~URL~entry@
を`値$mapとする。
それは、次のものからなる組である：
</p>
		<dl class="def-list">
			<dt>`~obj@bU</dt>
			<dd>
概して `Blob$I であるが、他の仕様は，これを他の型の~objを指すよう拡張できる。
</dd>

			<dt>`環境@bU</dt>
			<dd>
`環境~設定群~obj$。
</dd>
		</dl>
	</li>
</ul>

◎
Each user agent must maintain a blob URL store. A blob URL store is a map where keys are valid URL strings and values are blob URL Entries.
◎
A blob URL entry consists of an object (typically a Blob, but other specs can extend this to refer to other types of objects), and an environment (an environment settings object).
◎
Keys in the blob URL store (also known as blob URLs) are valid URL strings that when parsed result in a URL with a scheme equal to "blob", an empty host, and a path consisting of one element itself also a valid URL string.
</div>

<p class="algo-head">
`新たな~blob~URLを生成する@
ときは、次を走らす：
◎
To generate a new blob URL, run the following steps:
</p>

<ol>
	<li>
%直列形 ~LET `生成元を直列化する$( `現在の設定群~obj$の`生成元$enV )
◎
Let result be the empty string.
◎
Append the string "blob:" to result.
◎
Let settings be the current settings object
◎
Let origin be settings’s origin.
◎
Let serialized be the ASCII serialization of origin.
</li>
	<li>
~IF［
%直列形 ~EQ `null^l
］
⇒
%直列形 ~SET 実装により定義される値
◎
If serialized is "null", set it to an implementation-defined value.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
文字列 `blob:^l,
%直列形,
`0024^U SOLIDUS ( `/^c ),
~UUID `RFC4122$r を文字列として生成した結果
◎
Append serialized to result.
◎
Append U+0024 SOLIDUS (/) to result.
◎
Generate a UUID [RFC4122] as a string and append it to result.
◎
Return result.
</li>
</ol>

<p class="example">
この~algoにより生成できる~blob~URLの例
⇒
`blob:https://example.org/9115d58c-bcda-ff47-86e5-083e9a2153041^c
◎
An example of a blob URL that can be generated by this algorithm is blob:https://example.org/9115d58c-bcda-ff47-86e5-083e9a2153041.
</p>

<p class="algo-head">
`~blob~URL~storeに~entryを追加する@
ときは、所与の
( %~obj )
に対し，次を走らす：
◎
To add an entry to the blob URL store for a given object, run the following steps:
</p>

<ol>
	<li>
%~url ~LET `新たな~blob~URLを生成する$
◎
Let store be the user agent’s blob URL store.
◎
Let url be the result of generating a new blob URL.
</li>
	<li>
~UAの`~blob~URL~store$[ %~url ] ~SET 次のようにされた，新たな`~blob~URL~entry$
⇒＃
`~obj$bU ~SET %~obj,
`環境$bU ~SET `現在の設定群~obj$
◎
Let entry be a new blob URL entry consisting of object and the current settings object.
◎
Set store[url] to entry.
</li>
	<li>
~RET %~url
◎
Return url.
</li>
</ol>

<p class="algo-head">
`~blob~URL~storeから~entryを除去する@
ときは、所与の
( %~url )
に対し，次を走らす：
◎
To remove an entry from the blob URL store for a given url, run the following steps:
</p>

<ol>
	<li>
%~url文字列 ~LET `~URLを直列化する$( %~url )
◎
Let store be the user agent’s blob URL store;
◎
Let url string be the result of serializing url.
</li>
	<li>
~UAの`~blob~URL~store$[ %~url文字列 ] ~SET ε
◎
Remove store[url string].
</li>
</ol>

			<section id="requestResponseModel">
<h4 title="Dereferencing Model for blob URLs">8.2.1. ~blob~URL用の参照解決~model</h4>

<p class="trans-note">【
参照解決（ dereference ）
— 参照を参照-先の~dataに解決する。
】</p>

<p class="algo-head">
`~blob~URLを解決する@
ときは、所与の
( `~URL$ %~url )
に対し，次を走らす：
◎
To resolve a blob URL given a url (a URL), run the following steps:
</p>

<ol>
	<li>
~Assert：
%~url の`~scheme$url ~EQ `blob^l
◎
Assert: url’s scheme is "blob".
</li>
	<li>
%~url文字列 ~LET 
`~URLを直列化する$( %~url, %素片除外~flag ~SET ~ON )
◎
Let store be the user agent’s blob URL store.
◎
Let url string be the result of serializing url with the exclude fragment flag set.
</li>
	<li>
~RET ［
次の結果 ~NEQ ε ならば それ ／
~ELSE_ `失敗^i
］
⇒
~UAの`~blob~URL~store$[ %~url文字列 ]
◎
If store[url string] exists, return store[url string]; otherwise return failure.
</li>
</ol>

<p>
`~blob~URL$用の［
構文解析する／~fetchする
］~modelに対する更なる要件は、 `URL$r, `Fetch$r 仕様に定義される。
◎
Futher requirements for the parsing an fetching model for blob URLs are defined in the [URL] and [Fetch] specifications.
</p>

			</section>
			<section id="originOfBlobURL">
<h4 title="Origin of blob URLs">8.2.2. ~blob~URLの生成元</h4>

<p class="algo-head">
`~blob~URLの生成元を解決する@
ときは、所与の
( `~URL$ %~url )
に対し，次を走らす：
◎
To resolve the origin of a blob URL given a url (a URL), run the following steps:
</p>

<ol>
	<li>
~Assert：
%~url の`~scheme$url ~EQ `blob^l
◎
Assert: url’s scheme is "blob".
</li>
	<li>
%~entry ~LET `~blob~URLを解決する$( %~url )
◎
Let entry be the result of resolving url.
</li>
	<li>
~IF［
%~entry ~NEQ `失敗^i
］
⇒
~RET %~entry の`環境$bUの`生成元$enV
◎
If entry is not failure, return entry’s environment's origin.
</li>
	<li>
%入子の~url ~LET `~URL構文解析する$( %~url の`~path$url[0] )
◎
Let nested url be the result of parsing url’s path[0].
</li>
	<li>
~IF［
%入子の~url ~NEQ `失敗^i
］
⇒
~RET 新たな`不透明な生成元$
◎
Return a new opaque origin, if nested url is failure,＼
</li>
	<li>
~RET %入子の~url の`生成元$url
◎
and nested url’s origin otherwise.
</li>
</ol>

<p class="note">注記：
この~algoの効果により，~blob~URLは、破棄されるまでは，その生成元と~URLを作成した環境のそれとは常に同じになる。
~URLが破棄された場合、生成元の直列化は，~blob~URLを作成した環境の生成元の直列化と依然として同じであり続けるが、不透明な生成元に対しては生成元~自身と別個になるかもしれない。
~blob~URLは，破棄されて以降はどうやっても解決-／~fetchできなくなるので、この相違は、観測-可能にならないが。
◎
Note: The effect of this algorithm is that the origin of a blob URL is always the same as that of the environment that created the URL, as long as the URL hasn’t been revoked yet. If the URL was revoked the serialization of the origin will still remain the same as the serialization of the origin of the environment that created the blob URL, but for opaque origins the origin itself might be distinct. This difference isn’t observable though, since a revoked blob URL can’t be resolved/fetched anymore anyway.
</p>

<p class="issue">
`URL$r 仕様は、~URLが最初に構文解析されるとき，~blob~URLの生成元を解決する際に，この~algoを指すよう更新されるべきである。
これは、
<a href="https://github.com/w3c/FileAPI/issues/63">issue #63</a>,
<a href="https://github.com/whatwg/url/issues/127">whatwg/url#127</a>
にて追跡されている。
◎
The [URL] spec should be updated to refer to this algorithm to resolve the origin of a blob URL when the URL is first parsed. This is tracked in issue #63 and in whatwg/url#127.
</p>

			</section>
			<section id="lifeTime">
<h4 title="Lifetime of blob URLs">8.2.3. ~blob~URLの存続期間</h4>

<p>
この仕様は、`文書~unload時の片付け手続き$が次を走らすように拡張する：
◎
This specification extends the unloading document cleanup steps with the following steps:
</p>

<ol>
	<li>
~UAの`~blob~URL~store$から，次を満たす~entryをすべて除去する
⇒
`値$mapの`環境$bU ~EQ 当の`文書$に`関連する設定群~obj$
◎
Let environment be the Document's relevant settings object.
◎
Let store be the user agent’s blob URL store;
◎
Remove from store any entries for which the value's environment is equal to environment.
</li>
</ol>

<p class="issue">
~workerの~unload時にも，似たような~hookを与える必要がある。
◎
This needs a similar hook when a worker is unloaded.
</p>

			</section>
		</section>
		<section id="creating-revoking">
<h3 title="Creating and Revoking a blob URL">8.3. ~blob~URLの作成-法と破棄-法</h3>

<p>
`~blob~URL$は，
`URL$I ~objに公開される静的~methodを用いて作成され, 破棄される。
`~blob~URL$を破棄する（ revoke する）ことにより、それが参照する資源と`~blob~URL$は切り離される。
破棄-後に参照解決が~~試みられた場合、~UAは`~network~error$が生じたかのように動作し~MUST。
この節では、 URL 仕様 `URL$r に対する追加の~interface, および
`~blob~URL$の作成／破棄~用の~methodについて述べる。
◎
Blob URLs are created and revoked using static methods exposed on the URL object. Revocation of a blob URL decouples the blob URL from the resource it refers to, and if it is dereferenced after it is revoked, user agents must act as if a network error has occurred. This section describes a supplemental interface to the URL specification [URL] and presents methods for blob URL creation and revocation.
</p>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
partial interface `URL$I {
    static `DOMString$I `createObjectURL$m(`Blob$I `blob$V);
    static void `revokeObjectURL$m(`DOMString$I %url);
};
</pre>

<dl class="idl-def">
	<dt>`createObjectURL(blob)@m</dt>
	<dd>
この静的~methodは、次の結果を返さ~MUST
⇒
`~blob~URL~storeに~entryを追加する$( %blob )
◎
The createObjectURL(blob) static method must return the result of adding an entry to the blob URL store for blob.
</dd>

	<dt>`revokeObjectURL(url)@m</dt>
	<dd>
<p>
この静的~methodの被呼出時には、次を走らせ~MUST：
◎
The revokeObjectURL(url) static method must run these steps:
</p>
		<ol>
			<li>
%~url~record ~LET `~URL構文解析する$( %~url )
◎
Let url record be the result of parsing url.
</li>
			<li>
~IF［
%~url~record の`~scheme$url ~NEQ `blob^
］
⇒
~RET
◎
If url record’s scheme is not "blob", return.
</li>
			<li>
%生成元 ~LET `~blob~URLの生成元を解決する$( %~url~record )
◎
Let origin be the result of resolving the origin of url record.
</li>
			<li>
%設定群 ~LET `現在の設定群~obj$
◎
Let settings be the current settings object.
</li>
			<li>
~IF［
( %生成元, %設定群 の`生成元$enV )
は`同一生成元$でない
］
⇒
~RET
◎
If origin is not same origin with settings’s origin, return.
</li>
			<li>
`~blob~URL~storeから~entryを除去する$( %~url )
◎
Remove an entry from the Blob URL Store for url.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
これは，登録されていない~URLを破棄しようと試みたときには、~errorを投出することなく，黙って失敗することを意味する。
これが起きたときには、~UAは，~error~consoleに~messageを表示することもできる。
◎
Note: This means that rather than throwing some kind of error, attempting to revoke a URL that isn’t registered will silently fail. User agents might display a message on the error console is this happens.
</dd>
	<dd class="note">注記：
破棄された %~url を参照解決しようと試みた場合、`~network~error$になる。
%~url が破棄される前に開始された要請は、依然として成功するべきである。
◎
Note: Attempts to dereference url after it has been revoked will result in a network error. Requests that were started before the url was revoked should still succeed.
</dd>
</dl>


<div class="example">
<p>
次の例の
%window1, %window2 は、別々であるが`同一生成元$であるとする
— %window2 は、 %window1 の内側にある `iframe$e にもなり得る。
◎
In the example below, window1 and window2 are separate, but in the same origin; window2 could be an iframe inside window1.
</p>

<pre class="js-code">
%myurl = %window1.URL.createObjectURL(%myblob);
%window2.URL.revokeObjectURL(%myurl);
</pre>

<p>
~UAが有する大域`~blob~URL~store$は一つだけなので、ある~obj~URLを それを作成しなかった異なる~windowから破棄することも可能になる。
`URL.revokeObjectURL()$m を~callすれば、［［
それ以降に %myurl を参照解決した結果は，`~network~error$になる
］かのように，~UAが動作する
］ようになることが確保される。
◎
Since a user agent has one global blob URL store, it is possible to revoke an object URL from a different window than from which it was created. The URL.revokeObjectURL() call ensures that subsequent dereferencing of myurl results in a the user agent acting as if a network error has occurred.
</p>
</div>


			<section id="examplesOfCreationRevocation">
<h4 title="Examples of blob URL Creation and Revocation">8.3.1. ~blob~URLの作成と破棄の用例</h4>

<p>
`~blob~URL$は`~Blob$を`~fetch$するために利用される文字列であり，それを `URL.createObjectURL()$m を用いて創出した元の`文書$に残り続け得る（
<a href="#lifeTime">~blob~URLの存続期間</a>
を見よ）。
◎
Blob URLs are strings that are used to fetch Blob objects, and can persist for as long as the document from which they were minted using URL.createObjectURL()—see §8.2.3 Lifetime of blob URLs.
</p>

<p>
この節では、説明を交えながら`~blob~URL$の作成と破棄の用例を示す。
◎
This section gives sample usage of creation and revocation of blob URLs with explanations.
</p>

<div class="example">
<p>
次の例では、 2 個の `img$e 要素 `HTML$r が，同じ`~blob~URL$を参照する：
◎
In the example below, two img elements [HTML] refer to the same blob URL:
</p>

<pre class="js-code">
%url = URL.createObjectURL(%blob);
%img1.src = %url;
%img2.src = %url;
</pre>

<p>
次の例では、 `URL.revokeObjectURL()$m が明示的に~callされる：
◎
In the example below, URL.revokeObjectURL() is explicitly called.
</p>

<pre class="js-code">
var %blobURLref = URL.createObjectURL(%file);
%img1 = new Image();
%img2 = new Image();

/* <span class="comment">
いずれの代入も予期される通りに機能する
◎
Both assignments below work as expected
</span> */
%img1.src = %blobURLref;
%img2.src = %blobURLref;

/* <span class="comment">
… body の読込みに後続して、画像が 2 つとも読込まれたかどうか検査する
◎
... Following body load
Check if both images have loaded
</span> */
if(%img1.complete &amp;&amp; %img2.complete)
{
  /* <span class="comment">
以降の参照では例外が投出されるようにする
◎
Ensure that subsequent refs throw an exception
</span> */
  URL.revokeObjectURL(%blobURLref);
}
else {
  msg("Images cannot be previewed!");

  /* <span class="comment">
文字列による参照を破棄する
◎
revoke the string-based reference
</span> */
  URL.revokeObjectURL(%blobURLref);
}</pre>

</div>

<p>
上の例では、 1 個の`~blob~URL$に対する複数回の参照が可能になる。
`~blob~URL$文字列は，画像~objがいずれも読込まれた後に破棄されている。
`~blob~URL$の利用回数が制約されない分，柔軟性は得られるが、漏洩の可能性も高まる。
開発者は、 `URL.revokeObjectURL()$m の~callと対にするべきである。
◎
The example above allows multiple references to a single blob URL, and the web developer then revokes the blob URL string after both image objects have been loaded. While not restricting number of uses of the blob URL offers more flexibility, it increases the likelihood of leaks; developers should pair it with a corresponding call to URL.revokeObjectURL().
</p>

			</section>
		</section>
	</section>
	<section id="security-discussion">
<h2 title="Security and Privacy Considerations">9. 保安と~privacy上の考慮点</h2>

~INFORMATIVE

<p>
この仕様では、~Web内容が 下層の~file~systemから~fileを読取ることを許容し，~fileが一意な識別子を通して~accessされることの意味を与えるが、その種のものは保安~上の考慮点になる。
この仕様は、利用者との対話が主に~HTML~formの
`&lt;input type="file"/&gt;^e 要素 `HTML$r
によるものであり、 `FileReader$I ~objから読取られるすべての~fileは，最初に利用者の手により選択されたものであると見做している。
重要な保安~上の考慮点には、悪意的な~file選択攻撃（選択looping）の防止, `~systemに関わる~file$への~accessの防止, 選択-後の~disk上の~fileに対する改変からの保護がある。
◎
This specification allows web content to read files from the underlying file system, as well as provides a means for files to be accessed by unique identifiers, and as such is subject to some security considerations.
This specification also assumes that the primary user interaction is with the &lt;input type="file"/&gt; element of HTML forms [HTML], and that all files that are being read by FileReader objects have first been selected by the user.
Important security considerations include preventing malicious file selection attacks (selection looping), preventing access to system-sensitive files, and guarding against modifications of files on disk after a selection has taken place.
</p>

<ul>
	<li>
`選択looping@の防止：
~file選択の間、利用者は `&lt;input type="file"/&gt;^e に結びつけられた~file選択dialogにより攻撃され得る（選択しない限り，~file選択dialogが際限なく現れる “選択強制” ）。
~UAは、返される `FileList$I ~objの~sizeを 0 にすることにより，~file~accessを防止してもよい。
◎
Preventing selection looping.
During file selection, a user may be bombarded with the file picker associated with &lt;input type="file"/&gt; (in a "must choose" loop that forces selection before the file picker is dismissed) and a user agent may prevent file access to any selections by making the FileList object returned be of size 0.
</li>
	<li>
`~systemに関わる~file@：
（ system-sensitive files — 例えば /usr/bin の~file, password ~file, 他の~OS~nativeの実行-可能~file）は、概して，~Web内容に曝露されるべきではなく，`~blob~URL$を通して~accessされるべきではない。
~UAは、`同期~読取り~method$に対し `SecurityError$E 例外を`投出$してもよく, また `非同期~読取り~method$においては `SecurityError$E 例外を返してもよい。
◎
System-sensitive files (e.g. files in /usr/bin, password files, and other native operating system executables) typically should not be exposed to web content, and should not be accessed via blob URLs. User agents may throw a SecurityError exception for synchronous read methods, or return a SecurityError exception for asynchronous reads.
</li>
</ul>

<p class="issue">課題：
この節は暫定的なものである。
後続の草案には、より多くの保安~上の考慮点が追加される事になる。
◎
This section is provisional; more security data may supplement this in subsequent drafts.
</p>

	</section>
	<section id="requirements">
<h2 title="Requirements and Use Cases">10. 要件と利用事例</h2>

<p>
この節では、この~APIに対しどのような要件が課されるかについて, および
一部の利用事例についての説明を与える。
この~versionの~APIは、すべての利用事例に応えるものではない。
それらに取組むことは後続の~versionに委ねられる。
◎
This section covers what the requirements are for this API, as well as illustrates some use cases.
This version of the API does not satisfy all use cases; subsequent versions may elect to address these.
</p>

<ul>
	<li>
<p>
利用者からの許可を得たなら、~UAは，~local~fileに対する~dataを ~programから直に読取って構文解析できる能を供するべきである。
◎
Once a user has given permission, user agents should provide the ability to read and parse data directly from a local file programmatically.
</p>

<p class="example">例：
歌詞~viewer。
利用者は自身の plist ~file
【プレイリスト】
の楽曲の歌詞を読みたいとする。
利用者は plist ~fileを閲覧するとき、~fileは開かれ, 読取られ, 構文解析され, ~Web~app内で並び換えたり, 操作可能な一覧として利用者に示される。
利用者は曲を選択してその歌詞を閲覧できる。
利用者は “~fileを閲覧-” ~dialogを利用する。
◎
A lyrics viewer. User wants to read song lyrics from songs in his plist file. User browses for plist file. File is opened, read, parsed, and presented to the user as a sortable, actionable list within a web application. User can select songs to fetch lyrics. User uses the "browse for file" dialog.
</p>
	</li>
	<li>
<p>
~dataは後の利用のために~localに格納できるべきである。
それは~Web~appにおける~offline~data~accessに有用になる。
◎
Data should be able to be stored locally so that it is available for later use, which is useful for offline data access for web applications.
</p>

<p class="example">例：
~Calendar~app。
利用者の会社には予定表があり、利用者は自身の~eventと会社の “多忙” 期間の印が付けられた予定表との~~同期を（個人情報が漏れないように）とりたいとする。
利用者は一覧から~fileを探して選択する。
text/calendar ~fileは~browserにより構文解析され、単一の予定表~viewに併合できるようになる。
利用者はそれを自分用の予定表~fileに保存したり（ “別名で保存…” を用いて）、統合された予定表~fileを非同期に送信して~serverに格納させることもできる。
◎
A Calendar App. User’s company has a calendar. User wants to sync local events to company calendar, marked as "busy" slots (without leaking personal info).
User browses for file and selects it. The text/calendar file is parsed in the browser, allowing the user to merge the files to one calendar view. The user wants to then save the file back to his local calendar file. (using "Save As" ?). The user can also send the integrated calendar file back to the server calendar store asynchronously.
</p>
	</li>
	<li>
<p>
~UAは、与えられた~dataと~file名から ~programにより~local~fileに保存する能を供するべきである。
◎
User agents should provide the ability to save a local file programmatically given an amount of data and a file name.
</p>

<p class="note">注記：
この仕様は，~downloadを誘発させる明示的な~API~callは供さないが、それは HTML5 仕様にて取組まれている。
`a$e 要素の `download$a 属性 `HTML$r は、~downloadを起動させ，
`File$I を指定された名前で保存する。
この~APIと `a^e 要素の `download^a 属性との組み合せにより、~Web~appの中で~fileを作成して，~localに保存することが可能になる。
◎
Note: While this specification doesn’t provide an explicit API call to trigger downloads, the HTML5 specification has addressed this. The download attribute of the a element initiates a download, saving a File with the name specified. The combination of this API and the download attribute on a elements allows for the creation of files within web applications, and the ability to save them locally.
</p>


<p class="example">例：
~spreadsheet ~app。
利用者は~formを通して何らかの入力を生成する。
しかる後、~formから，~spreadsheetに組み入れられる CSV （ Comma Separated Variables ）出力が生成され，“保存…" が行われる。
生成された出力を直接的に~Webベースの~spreadsheetに統合させたり, 非同期に~uploadさせる事もできる。
◎
A Spreadsheet App. User interacts with a form, and generates some input. The form then generates a CSV (Comma Separated Variables) output for the user to import into a spreadsheet, and uses "Save...". The generated output can also be directly integrated into a web-based spreadsheet, and uploaded asynchronously.
</p>
	</li>
	<li>
<p>
~UAは、今日の~formを用いた~uploadよりも効率的に働くような，~fileから~remote~serverへ~dataを送信するための、効率的な~program的~能を供するべきである。
◎
User agents should provide a streamlined programmatic ability to send data from a file to a remote server that works more efficiently than form-based uploads today.
</p>

<p class="example">例：
動画や写真の~upload~app。
利用者は~uploadに巨大な~fileを選択でき，~chunkごとに~serverに送信できる。
◎
A Video/Photo Upload App.
User is able to select large files for upload, which can then be "chunk-transfered" to the server.
</p>
	</li>
	<li>
~UAは、上述の特色機能を可能にする~APIを~scriptに公開するべきである。
利用者は、~file~systemとの対話に入ったときは，いつでも~transactionの取消／中止-を常に行えるような形で，~UIから通知を受ける。
利用者は、いかなる~file選択においても通知を受けられ，それを取消せる。
これらの~APIが、利用者の介在抜きに黙って呼出されることはない。
◎
User agents should provide an API exposed to script that exposes the features above. The user is notified by UI anytime interaction with the file system takes place, giving the user full ability to cancel or abort the transaction. The user is notified of any file selections, and can cancel these. No invocations to these APIs occur silently without user intervention.
</li>
</ul>

	</section>
	<section id="acknowledgements-section">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕様は元々は SVG Working Group により開発された。
Mark Baker, Anne van Kesteren 両氏からの~feedbackに。
◎
This specification was originally developed by the SVG Working Group. Many thanks to Mark Baker and Anne van Kesteren for their feedback.
</p>

<p>
元々の仕様の編集を行った Robin Berjon, Jonas Sicking 両氏に。
◎
Thanks to Robin Berjon and Jonas Sicking for editing the original specification.
</p>

<p>次の方々に：</p>

<p lang="en-x-a0">
Special thanks to Olli Pettay, Nikunj Mehta, Garrett Smith, Aaron Boodman, Michael Nordman, Jian Li, Dmitry Titov, Ian Hickson, Darin Fisher, Sam Weinig, Adrian Bateman and Julian Reschke.
</p>

<p>
W3C WebApps WG, および public-webapps@w3.org listserv の協力者達に。
◎
Thanks to the W3C WebApps WG, and to participants on the public-webapps@w3.org listserv
</p>

	</section>

</main></div><!-- id="MAIN" -->
