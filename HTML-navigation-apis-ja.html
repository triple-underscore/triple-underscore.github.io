<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard â€” The navigation API ï¼ˆ æ—¥æœ¬èªè¨³ï¼‰</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
@supports (grid-template-columns: subgrid) and (display: contents) {

._nav-tracking {
	grid-template-columns: 4em 1fr;
	min-width:30em;
	tr {
		grid-template-areas:
			"çŠ¶æ…‹ çŠ¶æ…‹"
			". æœŸé–“"
			". èª¬æ˜"
		;
		> *:nth-child(1) {
			grid-area: çŠ¶æ…‹;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: æœŸé–“;
		}
		> *:nth-child(3) {
			grid-area: èª¬æ˜;
		}
	}
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~ä¸€-é¿†ã‚-ã‚“]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('ï¼ ');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'lS':
case 'lF':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'm':
case 'mD':
case 'mE':
case 'mN':
case 'mH':
case 'mT':
case 'mNA':
case 'mPSe':
case 'mPRe':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">ï¼Š</a>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


â—â—options

spec_date:2025-09-24
trans_update:2025-09-24
	source_checked: â†’ WINDOW
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/nav-history-apis.html
	abbr_url:HTMLnavAPI
nav_prev:WINDOW
nav_next:HTMLds
site_nav:browsers,html
trans_1st_pub:2023-07-09


â—â—class_map
E:error
sl:js-slot
e:element
a:attr
et:event-type
sc:scheme
E:error
sl:js-slot
U:code-point
v:value
h:header
jA:abstract
jv:js-value
sl:js-slot
hst:status

â—â—tag_map
I:code
E:code
m:code
mD:code
mE:code
mN:code
mH:code
mT:code
mb:code
mbC:code
mbN:code
mbR:code
mNA:code
mPSe:code
mPRe:code
c:code
e:code
a:code
et:code
v:code
h:code
jv:code
sl:span
jA:span
hst:code
sub:sub
i:i
em:em


â—â—original_urls

pagetransitionevent:API/PageTransitionEvent

â—â—words_table1
CONSOLE:console-ja.html

about_blank:about:blank
navigate_ev: <code class="event-type">navigate</code> 
beforeunload_ev: <code class="event-type">beforeunload</code> 
navigationType0:navigationType

â—â—words_table

	â—åç§°
UUID:

	â—navi/session
POST:
step:
unload:
from:
commit:
	~commitå…ˆ:committed-to
committed:
	å®Œé‚-æ™‚ã®:finished
	~commitæ™‚ã®:committed
precommit:
å·®åˆ†:delta:~
æ¨ªå–:interception::æ¨ªå–ã‚Š
æ¨ªå–-:intercept::æ¨ªå–ã‚Š
	æ¨ªå–ã•ã‚Œãªã„:non-intercepted
å‡¦åˆ†-:dispose::~
BF:
	~BF~cache:bfcache
è¿½è·¡å­:tracker::~::ãƒˆãƒ©ãƒƒã‚«ãƒ¼
ç›´åˆ—å½¢ã®:serialized::~::ã‚·ãƒªã‚¢ãƒ«å½¢ã®
å¾©æ—§-:restore::~
å¾©æ—§:restoration::~
èª­è¾¼ç›´ã™:reloadã™ã‚‹::èª­ã¿è¾¼ã¿ç›´ã™::ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹
å†èª­è¾¼ã¿:reload::å†èª­ã¿è¾¼ã¿::ãƒªãƒ­ãƒ¼ãƒ‰
æ›¸ç›´ã›:rewriteã§ã::æ›¸ãç›´ã›
	æ›¸ç›´ã›ã‚‹:can have its ã€œ rewritten
	æ›¸ç›´ã›ãªã„:cannot have its ã€œ rewritten
é€£ç¶šçš„:contiguous:~
æœ€è¿‘ã®:latest:~
å›å¾©å¯èƒ½:salvage å¯èƒ½:~

	èµ·å‹•å…ƒã¯è¨±å®¹ã•ã‚Œãªã„^i:"initiator-disallowed"
	~beforeunload_evã«ã‚ˆã‚Šå–æ¶ˆã•ã‚ŒãŸ^i:"canceled-by-beforeunload"
	~navigate_evã«ã‚ˆã‚Šå–æ¶ˆã•ã‚ŒãŸ^i:"canceled-by-navigate"
	å¤–ã¸è¡Œã:outgoing
	è¨ªå•ã—ç›´ã—ã¦:revisit
	æˆ»ã‚‹ã‚ˆã†~navigateã™ã‚‹:navigating back
	é€£ã‚Œã¦è¡Œã£ãŸ:took us
	ç´ ç‰‡ã¸~scrollã™ã‚‹:scroll-to-a-fragment
	~naviå±¥æ­´~entry~list:navigation history list
	~naviå±¥æ­´~entry~list:navigation history entry list
	éåŒä¸€-ã€œã¸è¡Œã:crossing
	å‰æ–¹ã«åœ¨ã‚‹:forward
	å¾Œæ–¹ã«åœ¨ã‚‹:previous

	â—UI
æ”¯æ´æŠ€è¡“:assistive technology:~
éš ã—ã¦:hideã—ã¦:~
å§‹ç‚¹:starting point:~
è‡ªå‹•focus:autofocus::è‡ªå‹• focus:è‡ªå‹•ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
ä¿å­˜-:save:~
affordance:

	å³~click:right click
	æŠ¼ã—ãŸ:press
	ç¤ºã•ã‚Œ:shown
	ç¤ºã™:show
	èª­è¾¼nä¸­ã‚’è¡¨ã™~UI:loading spinner UI
	ä»£ã‚ã‚Šã®ä½•ã‹:placeholder
	~pageã¯èª­è¾¼nä¸­ã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ã™ã‚‚ã®:spinner or loading page
	èª­è¾¼nä¸­ã‚’è¡¨ã™ä½•ã‹:loading spinner

	â—å‡¦ç†ä¸€èˆ¬
ç‰‡ä»˜ã‘ã‚‹:clean upã™ã‚‹:~
params::::ãƒ‘ãƒ©ãƒ¡ã‚¿ç¾¤
å°task:microtask::å° task:å°ã‚¿ã‚¹ã‚¯
checkpoint:
wrapper:
æ•æ‰-:capture::~
ç”Ÿæ®‹ã‚‹:surviveã™ã‚‹:ç”Ÿãæ®‹ã‚‹
ç”Ÿå­˜-:alive:~
	ç”Ÿå­˜ã—ç¶šã‘ã‚‹:keeping it alive
æ—©æœŸ:early:~
å‡¦ç†å¾…ã¡:pending:~
æ±ºç€-:settle::~
é€†ç›´åˆ—åŒ–-:deserialize::~::é€†ã‚·ãƒªã‚¢ãƒ«åŒ–
é€†ç›´åˆ—åŒ–:deserialization::~::é€†ã‚·ãƒªã‚¢ãƒ«åŒ–
process::::ãƒ—ãƒ­ã‚»ã‚¹
schedule::::ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
å–æ‰±æ¸ˆã¿:handled:å–ã‚Šæ‰±ã„æ¸ˆã¿
è­¦å‘Š:warning::~
æˆå¦:success or failure:~
æ¥ãŸã‚‹:upcoming:~
å·®æŒŸã‚“ã§:interleaveã•ã‚Œ:å·®ã—æŒŸã‚“ã§
é‚ã’ã‚‹:carry outã™ã‚‹:~
	ãã‚Œã«è¦‹åˆã†ã€œ:see fit to carry out
é‚ã’ã¦:carry outã—ã¦:~
é‚ã’ã‚‰:carry outã•:~
æ¥ãŸã‚‹:upcoming:~
å‡¦ã™ã‚‹:dealã™ã‚‹:~
å‡¦ã—ãŸ:dealã—ãŸ:~
çµ¦ã•ã‚Œ:supplyã•ã‚Œ:~
å·®æŒŸã¾ã‚Œ:interleaveã•ã‚Œ:å·®ã—æŒŸã¾ã‚Œ
æ™‚æ©Ÿ:timing::~
è¿½è·¡æœŸé–“:duration:~
	ã„ã‚‹é–“:duration
æ–°è¦:fresh:~
å…ˆè¡Œ-:preceed:~
æ¸¡ã™:passã™ã‚‹:~
æ¸¡ã•ã‚Œ:passã•ã‚Œ:~
æ¸¡ã—ãŸ:passã—ãŸ:~
æ¸¡ã—ã¦:passã—ã¦:~
æ¸¡ã›:passã§ã:~
å¾…å—ã‘ã‚‹:awaitã™ã‚‹::å¾…ã¡å—ã‘ã‚‹
ç¶šè¡Œ-:proceed:~

	æ®µéš:stage
	é †ã«èµ°ã‚‹:the sequence
	ã—ç¶šã‘ã‚‹:keep
	èµ°ã‚‹é †åº:sequence
	åŒæ™‚æœŸ:around the same time
	æ™‚ç‚¹:moment
	é–“:during
	å¾Œã®æ™‚ç‚¹:later
	å¾Œã®æ™‚ç‚¹:later time
	å¾Œã®æ™‚ç‚¹:later points
	ã“ã®æ™‚ç‚¹ã§:at this point
	ã“ã®æ™‚ç‚¹ã§ã€œã‚ˆã†ã«ã™ã‚‹:this point or later
	ã™ãã«~soon
	çµŒãªã„ no ã€œ goes through
	ã¨åŒæ™‚ã«:at the same time
	ã“ã®é“ãŒã¨ã‚‰ã‚Œã‚‹:This path is taken
	ã€œã•ã‚Œãªã‹ã£ãŸã“ã¨ã«ãªã‚‹:was never fired
	ç›´å¾Œ:right after
	~~é”ã™ã‚‹:ever getting to
	æŠœã‘å‡ºãŸ:bailed out
	ã€œã«ã™ã‚‹:promote
	å­˜ç¶šã™ã‚‹é™ã‚Š:lifetime
	æ¯”ã—ã¦å¤ããªã£ã¦ã„ãŸ:was outdated compared to
	çŸ­ã„æœŸé–“å†…:for brief periods
	å„ªå…ˆã•ã‚Œã‚‹å ´åˆ:in favor of
	ä»¥é™ã‚’:onward
	æ­¢ã‚ã‚‹:stop
	ã‹ãªã‚Š:pretty
	ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰:potential
	ãã®å¾Œã™ãã«:shortly after
	ä»»ã›ã‚‹:let
	ã¾ãšæœ€åˆã«:in the first place
	ãã®çµæœï¼Œ:which in turn
	ã‹ã‚‰é–‹å§‹ã—ãŸ:starting point
	å±…ç¶šã‘ã‚‹:around
	~fall-back:falling off the back of
	~networkã¾ãŸã¯~cacheã‹ã‚‰èª­è¾¼ç›´ã™:performing a from-network-or-cache reload
	~EQ:was initialized to
	ã‚ªãƒ•:turn off
	~clear:clear out
	ã€œã®ã¾ã¾ã«:left as
	è¨­å®šã•ã‚ŒãŸï¼ˆã¾ãŸã¯çœç•¥ã•ã‚ŒãŸï¼‰:left as
	å·¡ã£ãŸ:trip through
	å ´ã‚’å ã‚ã‚‹:taking place
	çµæœã€œãªã‚‹:end up
	-:rethrowing any exceptions
	å–ã£ã¦ä»£ã‚ã‚‰ã‚Œ:supersed
	ã—ç¶šã‘:continue to

	â—å¤‰æ•°
æ–°-:new:~
æ—§-:old:~
SHE:
NHE:

	%e:e
	%~API~methodè¿½è·¡å­:apiMethodTracker
	%~NHE:nhe
	%~URL~record:urlRecord
	%~commitæ™‚ã®~promise:committedPromise
	%~downloadè¦è«‹~filename:downloadRequestFilename
	%~error:error
	%~errorå ±:errorInfo
	%~event:event
	%~filename:filename
	%å®Œé‚-æ™‚ã®~promise:finishedPromise
	%~focus~target:focusTarget
	%~focusã¯å¤‰åŒ–ã—ãŸã‹:focusChanged
	%~form~data~entry~list:formDataEntryList
	%~from~NHE:fromNHE
	%~index:i
	%~index:index
	%~key:key
	%~navi:navigation
	%~navigable:navigable
	%~navigableã®å±¥æ­´~entryç¾¤:navigableSHEs
	%~navi~APIçŠ¶æ…‹:navigationAPIState
	%~naviç¨®åˆ¥:navigationType
	%~optionç¾¤:options
	%~promise~list:promisesList
	%~source~snapshot~params:sourceSnapshotParams
	%~targetå±¥æ­´~entry:targetSHE
	%ä½œå‹•åŒ–ã—ç›´ã•ã‚Œã‚‹å±¥æ­´~entry:reactivatedSHE
	%ä¾‹å¤–:exception
	%å……è¶³-æ¸ˆã¿ã‹:didFulfill
	%å‡¦åˆ†ã•ã‚Œã‚‹~NHE:disposedNHE
	%å‡¦åˆ†ã•ã‚Œã‚‹~NHEç¾¤:disposedNHEs
	%åˆæœŸ~å±¥æ­´~entry:initialSHE
	%åˆ©ç”¨è€…-é–¢ä¸i:userInvolvement
	%å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹:classicHistoryAPIState
	%åŒä¸€-æ–‡æ›¸ã‹:isSameDocument
	%å ±:info
	%å±¥æ­´~entry:she
	%å±¥æ­´~entry:she
	%æ–°-~NHE:newNHE
	%æ–°-~NHEç¾¤:newNHEs
	%æ–°-å±¥æ­´~entry:newSHE
	%æ–°-å±¥æ­´~entryç¾¤:newSHEs
	%æ—§-~NHE:matchingOldNHE
	%æ—§-~NHEç¾¤:oldNHEs
	%æ—§-ç¾åœ¨ã®~NHE:oldCurrentNHE
	%çŠ¶æ…‹:state
	%ç¾åœ¨ã®~URL:currentURL
	%ç¾åœ¨ã®~entry:current
	%ç›´åˆ—å½¢ã®çŠ¶æ…‹:serializedState
	%çµ‚äº†~çµæœã¯åŒä¸€-æ–‡æ›¸ã‹:endResultIsSameDocument
	%çµæœ:result
	%è¡Œå…ˆ:destination
	%è¡Œå…ˆ~NHE:destinationNHE
	%è¡Œå…ˆ~URL:destinationURL
	%è¡Œå…ˆ~key:destinationKey
	%è¡Œå…ˆ~å±¥æ­´~entry:destinationSHE
	-:traverseCanBeCanceled
	%è¾¿ã‚Š~API~methodè¿½è·¡å­~ç¾¤:traversalAPIMethodTrackers
	%è¾¿å¯èƒ½:traversable
	%é…é€-çµæœ:dispatchResult
	%~eventå:eventName
	%æŒç¶šã•ã‚Œã‚‹ã‹:persisted
	%äº‹ç”±:reason
	%~precommitåˆ¶å¾¡å™¨:precommitController
	%~precommit~promise~list:precommitPromisesList

	â—ä»•æ§˜
å…ƒã€…ã¯:originalã«ã¯:~
å¤å…¸çš„:classic::~::ã‚¯ãƒ©ã‚·ãƒƒã‚¯
æ³¨åŠ›-:focus:~
ç•°ç¨®:disparate:~
å‰µç™ºçš„:emergent:~
å¾®å¦™:subtle:~
å¾Œç¶™:successor:~
ç†è«–:theory:~
	ç†è«–~ä¸Šã¯:in theory
æ³¨åŠ›-:focus:~
	ã€œã«æ³¨åŠ›ã—ãŸ:-focused
æ©Ÿæ§‹:machinery:~
ä¸æ­£ç¢º:inaccurate:~

	ä¸»è¦:major:~
	å¿…è¦ãªã‚‰:potentially
	å¿…è¦ãªã‚‰:maybe
	åŒé¡ã®~API:friends
	æ³¨è¨˜-:note
	ä¸€èˆ¬çš„ã«ã¯:Generally speaking
	ã„ãã¤ã‚‚ã‚ã‚‹:so many
	ã«æ³¨æ„:Notably,
	çµå±€:after all
	ä¸»ãª:main
	ã“ã®ã“ã¨:this overlap
	å˜ã«æ¨ã¦ç½®ãã‚ã‘ã«ã¯ã„ã‹ãªã„:can't just get rid of
	åˆ©ç”¨ãŒæœ€ã‚‚é©ã™ã‚‹:is best used
	ã¾ã æŒ‡å®šã•ã‚Œã¦ãªã„:underspecified
	ç¨®åˆ¥ã‚’å•ã‚ãš:in the broad sense of the word
	å”¯ä¸€ã®:singular
	è¤‡é›‘ã«ãªã‚‹ã“ã¨:complication
	ä¸€ç’°ã¨ã—ã¦:per
	çŸ¥ã‚‹:know
	ãã‚Œã«åŠ ãˆ:plus
	Recall that:-
	è¦ã¨ã—ã¦:key
	é¸ã¶:chooseã™ã‚‹
	å•ã‚ã‚Œ:matter
	ä»»æ„é¸æŠã§:then the user agent may
	ãªã‚Šå¾—ãªã„:would not be viable
	ãã‚Œã§ã‚‚:however ã€œ still
	æ‹…å½“:responsible
	æ•£ã‚‰ã‹ã£ã¦:messy
	ã¨ã—ã¦ã‚‚ï¼Œå¸°çµã¯åŒã˜ã«ãªã‚‹:not consequential whether

	â—æœªåˆ†é¡
body:
agent:
åºæ•°:ordinal:~
å¸°å±-:attribute
	ã©ã“ã«å¸°å±ã™ã‚‹ã‹:about attributing
ä»˜éš-:accompany:~
	ä»˜éš-:acccompany
é-:non-:~
è¿‘éå»:recent:~
å¸¸æ™‚:regularã«:~
ä¸€å®š:constant:~
ç¶­æŒ-:retain:~
	`pageswap^et:page swap
é‡åˆã™ã‚‹:overlapã™ã‚‹:é‡ãªã‚Šåˆã†
é‡åˆã—ã¦:overlapã—ã¦:é‡ãªã‚Šåˆã£ã¦
åˆ‡æ›¿ãˆã‚Œ:switchã§ã:åˆ‡ã‚Šæ›¿ãˆã‚Œ

	å«ã‚€:include
	è¨˜äº‹:article
	ä¸€é€£ã®:a series of
	æº€ãŸã•ã‚Œã‚‹:hold
	~NULL åŒ–:nulled out
	ç©ºã§ãªã„:nonempty
	åˆ©ç”¨è€…ãŒ:user-
	ã—ãŸã“ã¨ã«ã‚ˆã‚‹:caused by
	ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸ:caused by
	è¤‡æ•°å›:more than once
	ã€œå¾Œã®:post-
	ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰:any
	å¯¾å¿œ-:correspond
	å…¨ä½“ã‚’é€šã—ã¦:throughout
	é€”ä¸­ã§:along the way
	ç„¡ã„ã¨ãã¨ 1 å€‹ä»¥ä¸Šã‚ã‚‹ã¨ã:0 promises versus â‰¥ 1 promises
	äº’ã„ã®:each others'
	ä»–ã¸:along
	ã€œé§†å‹•ãª:-driven
	å¤§æŠµã¯:Much of the time
	ã©ã®~entryã‹ã‚‰æ¥ã¦ã„ã‚‹ã‹:from which ã€œ is coming
	ååˆ†:enough
	ã§å ã‚ã‚‹å ´æ‰€:place
	ã¾ãŸãŒã£ã¦:across
	ä»–ã§ã¯:otherwise-
	å·¨å¤§:large
	å„éƒ¨:parts
	ã“ã“ã¾ã§ã«ï¼å‰å›ã®ï¼ä»¥å‰ã®ï¼ä¸Šã®
	ç›´å‰ã®:the previous
	ç›´å‰:right before
	å¾Œè€…ã®:previous
	ç¾åœ¨ã®æ–‡æ›¸:this one
	æœ€ã‚‚è¿‘ã„:closest
	å¤‰ãˆã‚‹:vary
	Finally:-
	æ¥:come
	æ™‚ç‚¹:at the moment
	ã‚ã‚Šç¶šã‘ã‚‹:stay
	å¤–ã¸å‡ºã‚‹:outbound
	ã‚ˆã†ã«ãªã‚‹:gets
	å°‘ã—:a bit
	æœ€çµ‚çš„ã«:ultimately

â—â—original_id_map

dom-window-navigation:dom-navigation

â—â—mdn_urls
navigation:API/Navigation
navigateevent:API/NavigateEvent
navigationdestination:API/NavigationDestination
navigationhistoryentry:API/NavigationHistoryEntry
navigationtransition:API/NavigationTransition
navigationcurrententrychangeevent:API/NavigationCurrentEntryChangeEvent

â—â—link_map

	â—IDL
E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror

Promise:~WEBIDL#idl-promise

I.ErrorEvent:~WAPI#errorevent
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.FormData:~XHR#formdata
I.Element:~DOM4#interface-element
	I.Element â†’ è¦ç´ 
è¦ç´ :~DOM4#concept-element

I.Navigation:#navigation
I.NavigateEvent:#navigateevent
I.NavigateEventInit:#navigateeventinit
I.NavigationActivation:#navigationactivation
I.NavigationCurrentEntryChangeEvent:#navigationcurrententrychangeevent
I.NavigationCurrentEntryChangeEventInit:#navigationcurrententrychangeeventinit
I.NavigationDestination:#navigationdestination
I.NavigationFocusReset:#navigationfocusreset
I.NavigationHistoryBehavior:#navigationhistorybehavior
I.NavigationHistoryEntry:#navigationhistoryentry
I.NavigationInterceptHandler:#navigationintercepthandler
I.NavigationInterceptOptions:#navigationinterceptoptions
I.NavigationNavigateOptions:#navigationnavigateoptions
I.NavigationOptions:#navigationoptions
I.NavigationPrecommitController:#navigationprecommitcontroller
I.NavigationPrecommitHandler:#navigationprecommithandler
I.NavigationReloadOptions:#navigationreloadoptions
I.NavigationResult:#navigationresult
I.NavigationScrollBehavior:#navigationscrollbehavior
I.NavigationTransition:#navigationtransition
I.NavigationType:#navigationtype
I.NavigationUpdateCurrentEntryOptions:#navigationupdatecurrententryoptions
I.PageSwapEvent:#pageswapevent
I.PageSwapEventInit:#pageswapeventinit
I.PageRevealEvent:#pagerevealevent
I.PageRevealEventInit:#pagerevealeventinit
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.ViewTransition:~CSSVT#viewtransition
I.WebSocket:~WEBSOCKET#websocket

I.AbortController:~DOM4#abortcontroller
I.AbortSignal:~DOM4#abortsignal
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.DOMException:~WEBIDL#dfn-DOMException
	I.Document:~HTMLdom#document â†’ æ–‡æ›¸
æ–‡æ›¸:~HTMLdom#the-document-object

I.Window:~WINDOW#window

mbC.state:#dom-navigationupdatecurrententryoptions-state

mbN.info:#dom-navigationoptions-info
mbN.state:#dom-navigationnavigateoptions-state
mbN.history:#dom-navigationnavigateoptions-history

mbR.state:#dom-navigationreloadoptions-state

mb.committed:#dom-navigationresult-committed
mb.finished:#dom-navigationresult-finished

m.persisted:#dom-pagetransitionevent-persisted

c.window.navigation:#dom-window-navigation
m.navigation:#dom-window-navigation
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.fetch:~FETCH#dom-global-fetch
m.from:#dom-navigationcurrententrychangeevent-from
m.isTrusted:~DOM4#dom-event-istrusted
m.preventDefault:~DOM4#dom-event-preventdefault
m.type:~DOM4#dom-event-type
m.~navigationType0:#dom-navigationcurrententrychangeevent-navigationtype

mH.url:#dom-navigationhistoryentry-url
mH.key:#dom-navigationhistoryentry-key
mH.id:#dom-navigationhistoryentry-id
mH.index:#dom-navigationhistoryentry-index
mH.sameDocument:#dom-navigationhistoryentry-samedocument
mH.getState:#dom-navigationhistoryentry-getstate
c.navigation.currentEntry.getState():#dom-navigationhistoryentry-getstate
mH.ondispose:#handler-navigationhistoryentry-ondispose

mN.onnavigate:#handler-navigation-onnavigate
mN.onnavigatesuccess:#handler-navigation-onnavigatesuccess
mN.onnavigateerror:#handler-navigation-onnavigateerror
mN.oncurrententrychange:#handler-navigation-oncurrententrychange
mN.entries:#dom-navigation-entries
c.navigation.entries():#dom-navigation-entries
c.navigation.currentEntry:#dom-navigation-currententry
mN.currentEntry:#dom-navigation-currententry
mN.updateCurrentEntry:#dom-navigation-updatecurrententry
c.navigation.updateCurrentEntry():#dom-navigation-updatecurrententry
c.navigation.canGoBack:#dom-navigation-cangoback
mN.canGoBack:#dom-navigation-cangoback
mN.canGoForward:#dom-navigation-cangoforward
c.navigation.navigate():#dom-navigation-navigate
mN.navigate:#dom-navigation-navigate
mN.reload:#dom-navigation-reload
c.navigation.reload():#dom-navigation-reload
mN.traverseTo:#dom-navigation-traverseto
c.navigation.traverseTo():#dom-navigation-traverseto
mN.back:#dom-navigation-back
mN.forward:#dom-navigation-forward
mN.transition:#dom-navigation-transition
c.navigation.transition:#dom-navigation-transition
mN.activation:#dom-navigation-activation

mNA.from:#dom-navigationactivation-from
mNA.entry:#dom-navigationactivation-entry
mNA.navigationType:#dom-navigationactivation-navigationtype

m.redirect:#dom-navigationprecommitcontroller-redirect

l.push:#dom-navigationtype-push
l.replace:#dom-navigationtype-replace
l.reload:#dom-navigationtype-reload
l.traverse:#dom-navigationtype-traverse

mT.navigationType:#dom-navigationtransition-navigationtype
mT.from:#dom-navigationtransition-from
mT.committed:#dom-navigationtransition-committed
mT.finished:#dom-navigationtransition-finished
c.navigation.transition.finished:#dom-navigationtransition-finished

mb.from:#dom-navigationcurrententrychangeeventinit-from
mb.~navigationType0:#dom-navigationcurrententrychangeeventinit-navigationtype

mb.navigationType:#dom-navigateeventinit-navigationtype
mb.destination:#dom-navigateeventinit-destination
mb.canIntercept:#dom-navigateeventinit-canintercept
mb.userInitiated:#dom-navigateeventinit-userinitiated
mb.hashChange:#dom-navigateeventinit-hashchange
mb.signal:#dom-navigateeventinit-signal
mb.formData:#dom-navigateeventinit-formdata
mb.downloadRequest:#dom-navigateeventinit-downloadrequest
mb.info:#dom-navigateeventinit-info
mb.hasUAVisualTransition:#dom-navigateeventinit-hasuavisualtransition
mb.sourceElement:#dom-navigateeventinit-sourceelement

mb.precommitHandler:#dom-navigationinterceptoptions-precommithandler
mb.handler:#dom-navigationinterceptoptions-handler
mb.focusReset:#dom-navigationinterceptoptions-focusreset
mb.scroll:#dom-navigationinterceptoptions-scroll

lF.after-transition:#dom-navigationfocusreset-after-transition
lF.manual:#dom-navigationfocusreset-manual

lS.after-transition:#dom-navigationscrollbehavior-after-transition
lS.manual:#dom-navigationscrollbehavior-manual

mE.navigationType:#dom-navigateevent-navigationtype
mE.destination:#dom-navigateevent-destination
mE.canIntercept:#dom-navigateevent-canintercept
mE.userInitiated:#dom-navigateevent-userinitiated
mE.hashChange:#dom-navigateevent-hashchange
mE.signal:#dom-navigateevent-signal
mE.formData:#dom-navigateevent-formdata
mE.downloadRequest:#dom-navigateevent-downloadrequest
mE.info:#dom-navigateevent-info
mE.hasUAVisualTransition:#dom-navigateevent-hasuavisualtransition
mE.sourceElement:#dom-navigateevent-sourceelement
mE.intercept:#dom-navigateevent-intercept
mE.scroll:#dom-navigateevent-scroll

mD.url:#dom-navigationdestination-url
c.destination.url:#dom-navigationdestination-url
mD.key:#dom-navigationdestination-key
mD.id:#dom-navigationdestination-id
mD.index:#dom-navigationdestination-index
mD.sameDocument:#dom-navigationdestination-samedocument
mD.getState:#dom-navigationdestination-getstate

mPSe.activation:#dom-pageswapevent-activation
mPSe.viewTransition:#dom-pageswapevent-viewtransition
mb.activation:#dom-pageswapeventinit-activation
mb.viewTransition:#dom-pageswapeventinit-viewtransition

mPRe.viewTransition:#dom-pagerevealevent-viewtransition
	mb.viewTransition:ï¼ #dom-pagerevealeventinit-viewtransition


nV.~entry~list:#navigation-entry-list
~naviå±¥æ­´~entry~list:#navigation-entry-list
nV.ç¾åœ¨ã®~entry~index:#navigation-current-entry-index
~naviã®ç¾åœ¨ã®~entry:#navigation-current-entry

h.Content-Disposition:https://httpwg.org/specs/rfc6266.html

hH.auto:~HTMLnav#navigationhistorybehavior-auto
hH.push:~HTMLnav#navigationhistorybehavior-push
hH.replace:~HTMLnav#navigationhistorybehavior-replace

et.currententrychange:~HTMLindex#event-currententrychange
et.dispose:~HTMLindex#event-dispose
et.load:~HTMLindex#event-load
et.navigate:~HTMLindex#event-navigate
et.navigateerror:~HTMLindex#event-navigateerror
et.navigatesuccess:~HTMLindex#event-navigatesuccess
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.unhandledrejection:~HTMLindex#event-unhandledrejection

e.a:~HEtextlevel#the-a-element
e.area:~HEimages#the-area-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element

a.autofocus:~HTMLinteraction#attr-fe-autofocus
a.download:~HTMLlinks#attr-hyperlink-download


	â—ç”¨èª
~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚ŒãŸã‹:#has-entries-and-events-disabled
~navi~API~entry~indexã‚’å–å¾—ã™ã‚‹:#getting-the-navigation-api-entry-index
~navi~API:#window-navigation-api

nhe.~sessionå±¥æ­´~entry:#nhe-she
~naviå±¥æ­´~entry:#nhe-she
nE.~key:#concept-navigationhistoryentry-key
nE.~ID:#concept-navigationhistoryentry-id
nE.~index:#concept-navigationhistoryentry-index

~navi~APIç”¨ã®è¾¿ã‚Šã‚’é‚è¡Œã™ã‚‹:#performing-a-navigation-api-traversal
æ—©æœŸ~errorçµæœ:#navigation-api-early-error-result
~navi~API~methodè¿½è·¡å­:#navigation-api-method-tracker
~navi~API~methodè¿½è·¡å­ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹çµæœ:#navigation-api-method-tracker-derived-result
é€²è¡Œä¸­ãª~navigate_ev~event:#ongoing-navigate-event
é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­:#ongoing-api-method-tracker
æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­:#upcoming-non-traverse-api-method-tracker
æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤:#upcoming-traverse-api-method-trackers

amT.~navi~obj:#navigation-api-method-tracker-navigation
amT.~key:#navigation-api-method-tracker-key
amT.å ±:#navigation-api-method-tracker-info
amT.ç›´åˆ—å½¢ã®çŠ¶æ…‹:#navigation-api-method-tracker-state
amT.~commitå…ˆ~entry:#navigation-api-method-tracker-committed-to-entry
amT.~commitæ™‚ã®~promise:#navigation-api-method-tracker-committed
amT.å®Œé‚-æ™‚ã®~promise:#navigation-api-method-tracker-finished

æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­ã‚’å¿…è¦ãªã‚‰è¨­å®šã™ã‚‹:#maybe-set-the-upcoming-non-traverse-api-method-tracker
æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­ã‚’è¿½åŠ ã™ã‚‹:#add-an-upcoming-traverse-api-method-tracker
æ¥ãŸã‚‹~API~methodè¿½è·¡å­ã‚’é€²è¡Œä¸­ã«ã™ã‚‹:#promote-an-upcoming-api-method-tracker-to-ongoing

è¿½è·¡å­ã‚’ç‰‡ä»˜ã‘ã‚‹:#navigation-api-method-tracker-clean-up
~commitå…ˆ~entryã«ã¤ã„ã¦é€šçŸ¥ã™ã‚‹:#notify-about-the-committed-to-entry
å®Œé‚-æ™‚ã®~promiseã‚’è§£æ±ºã™ã‚‹:#resolve-the-finished-promise
å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹:#reject-the-finished-promise
é€²è¡Œä¸­ãª~naviã®é–“ã«~focusã¯å¤‰åŒ–ã—ãŸã‹:#focus-changed-during-ongoing-navigation
é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹:#abort-the-ongoing-navigation
é€²è¡Œä¸­ãª~naviã®é–“ã¯é€šå¸¸ã®~scrollå¾©æ—§ã‚’æŠ‘æ­¢ã™ã‚‹ã‹:#suppress-normal-scroll-restoration-during-ongoing-navigation

æ–°ãŸãªæ–‡æ›¸~ç”¨ã«~navi~API~entryç¾¤ã‚’åˆæœŸåŒ–ã™ã‚‹:#initialize-the-navigation-api-entries-for-a-new-document
~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦:#has-entries-and-events-disabled
~navigate_ev~eventã‚’ä¸­æ­¢ã™ã‚‹:#abort-a-navigateevent
è¾¿-ç”¨ã®~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹:#fire-a-traverse-navigate-event
	arg:#fire-navigate-traverse-destinationshe
	arg:#fire-navigate-traverse-userinvolvement
~pushï¼ç½®æ›-ï¼å†èª­è¾¼ã¿ç”¨ã®~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹:#fire-a-push/replace/reload-navigate-event
	arg:#fire-navigate-prr-navigationtype
	arg:#fire-navigate-prr-issamedocument
	arg:#fire-navigate-prr-destinationurl
	arg:#fire-navigate-prr-classichistoryapistate
	arg:#fire-navigate-prr-userinvolvement
	arg:#fire-navigate-prr-sourceelement
	arg:#fire-navigate-prr-navigationapistate
	arg:#fire-navigate-prr-formdataentrylist
~downloadè¦è«‹~ç”¨ã®~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹:#fire-a-download-request-navigate-event
	arg:#fire-navigate-download-destinationurl
	arg:#fire-navigate-download-userinvolvement
	arg:#fire-navigate-download-sourceelement
	arg:#fire-navigate-download-filename
~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo:#inner-navigate-event-firing-algorithm
~navigate_ev~eventã‚’å®Œé‚ã™ã‚‹:#navigateevent-finish
~navigate_ev~eventã‚’~commitã™ã‚‹:#commit-a-navigate-event
~navigate_ev~event~handlerã®å¤±æ•—ã‚’å‡¦ç†ã™ã‚‹:#process-navigate-event-handler-failure

å­~navigableã®ç ´å£Šã«ã¤ã„ã¦~navi~APIã«ä¼ãˆã‚‹:#inform-the-navigation-api-about-child-navigable-destruction
~naviã‚’ä¸­æ­¢ã—ãŸã“ã¨ã«ã¤ã„ã¦~navi~APIã«ä¼ãˆã‚‹:#inform-the-navigation-api-about-aborting-navigation
å†~ä½œå‹•åŒ–~ç”¨ã«~navi~API~entryç¾¤ã‚’æ›´æ–°ã™ã‚‹:#update-the-navigation-api-entries-for-reactivation
åŒä¸€-æ–‡æ›¸~naviç”¨ã«~navi~API~entryç¾¤ã‚’æ›´æ–°ã™ã‚‹:#update-the-navigation-api-entries-for-a-same-document-navigation

é·ç§»:#concept-navigation-transition
nTr.~naviç¨®åˆ¥:#concept-navigationtransition-navigationtype
nTr.~from~entry:#concept-navigationtransition-from
nTr.å®Œé‚-æ™‚ã®~promise:#concept-navigationtransition-finished
nTr.~commitæ™‚ã®~promise:#concept-navigationtransition-committed
ommitæ™‚ã®~promise$
ä½œå‹•åŒ–:#navigation-activation
nA.æ—§-~entry:#nav-activation-old-entry
nA.æ–°-~entry:#nav-activation-new-entry
nA.~naviç¨®åˆ¥:#nav-activation-navigation-type

nEv.æ¨ªå–~çŠ¶æ…‹:#concept-navigateevent-interception-state
nEv.~navi~precommit~handler~list:#concept-navigateevent-navigation-precommit-handler-list
nEv.~navi~handler~list:#concept-navigateevent-navigation-handler-list
nEv.~focusã‚’è¨­å®šã—ç›´ã™æŒ™å‹•:#concept-navigateevent-focusreset
nEv.~scrollç”¨ã®æŒ™å‹•:#concept-navigateevent-scroll
nEv.ä¸­æ­¢-åˆ¶å¾¡å™¨:#concept-navigateevent-abort-controller
nEv.å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹:#concept-navigateevent-classic-history-api-state

~navi~handler~promise:#_navigation-handler-promise

pCC.~event:#concept-navigationprecommitcontroller-event

å…±ç”¨~æ¤œæŸ»ã‚’é‚è¡Œã™ã‚‹:#navigateevent-perform-shared-checks

nDt.~URL:#concept-navigationdestination-url
nDt.~entry:#concept-navigationdestination-entry
nDt.çŠ¶æ…‹:#concept-navigationdestination-state
nDt.åŒä¸€-æ–‡æ›¸ã‹:#concept-navigationdestination-samedocument

å¿…è¦ãªã‚‰~focusã‚’è¨­å®šã—ç›´ã™:#potentially-reset-the-focus
å¿…è¦ãªã‚‰~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹:#potentially-process-scroll-behavior
~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹:#process-scroll-behavior

~pageé·ç§»~eventã‚’ç™ºç«ã™ã‚‹:#fire-a-page-transition-event

	â—ç”¨èªï¼ˆHTML

~BF~cache:~HTMLnav#_bf-cache
	~HTMLnav#note-bfcache

~bodyè¦ç´ :~HTMLdom#the-body-element-2

~entry~list:~HTMLforms#entry-list
	ï¼ :~HTMLforms#concept-form-submit
æå‡º-~button:~HEforms#concept-submit-button

ç›´åˆ—åŒ–-å¯èƒ½:~HTMLcloning#serializable-objects
~URLã‚’ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æã™ã‚‹:~HTMLurl#parse-a-url

~objã‚’~focusã™ã‚‹:~HTMLinteraction#focusing-steps
é€£åˆ—çš„~focus~naviã®å§‹ç‚¹:~HTMLinteraction#sequential-focus-navigation-starting-point
å±¥æ­´~å‹•ä½œã«ã‚ˆã‚‹ä½œå‹•åŒ–ã‚’æœ‰ã—ã¦:~HTMLinteraction#history-action-activation
å±¥æ­´~å‹•ä½œã«ã‚ˆã‚‹ä½œå‹•åŒ–ã‚’æ¶ˆè²»ã™ã‚‹:~HTMLinteraction#consume-history-action-user-activation
è‡ªå‹•focuså§”ä»»-å…ˆ:~HTMLinteraction#autofocus-delegate


ä¸é€æ˜ãªç”Ÿæˆå…ƒ:~ORIGIN#concept-origin-opaque
åŒã˜ç”Ÿæˆå…ƒ~domain:~ORIGIN#same-origin-domain
åŒä¸€-ç”Ÿæˆå…ƒ:~ORIGIN#same-origin
sub.ç”Ÿæˆå…ƒ:~ORIGIN#same-origin
ç”Ÿæˆå…ƒ:~ORIGIN#concept-origin

å¯¾å¿œã™ã‚‹~navigable:~WINDOW#window-navigable
æ–‡æ›¸ã®~URLã¯æ›¸ç›´ã›ã‚‹ã‹å¦ã‹:~WINDOW#can-have-its-url-rewritten
çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸:~WINDOW#concept-document-window

nav.~sessionå±¥æ­´~è¾¿ã‚Š~queue:~HTMLds#tn-session-history-traversal-queue
nav.ä½œå‹•ä¸­ãª~entry:~HTMLds#nav-active-history-entry
nav.ä½œå‹•ä¸­ãª~window:~HTMLds#nav-window
nav.ç¾åœ¨ã®~sessionå±¥æ­´~entry:~HTMLds#nav-current-history-entry
nav.è¦ª:~HTMLds#nav-parent
nav.è¾¿å¯èƒ½ãª~navigable:~HTMLds#nav-traversable
~navigable:~HTMLds#navigable
~navigableå®¹å™¨:~HTMLds#navigable-container
~node~navigable:~HTMLds#node-navigable
~top-levelè¾¿å¯èƒ½:~HTMLds#top-level-traversable
å…¨éƒ¨çš„ã«ä½œå‹•ä¸­:~HTMLds#fully-active
å­~navigable:~HTMLds#child-navigable

shE.~URL:~HTMLnav#she-url
shE.~navi~API~ID:~HTMLnav#she-navigation-api-id
shE.~navi~API~key:~HTMLnav#she-navigation-api-key
shE.~navi~APIçŠ¶æ…‹:~HTMLnav#she-navigation-api-state
shE.~step:~HTMLnav#she-step
shE.æ–‡æ›¸:~HTMLnav#she-document
shE.æ–‡æ›¸~çŠ¶æ…‹:~HTMLnav#she-document-state
æœ€è¿‘ã®~entry:~HTMLnav#latest-entry
~URLã¨å±¥æ­´ã‚’æ›´æ–°ã™ã‚‹:~HTMLnav#url-and-history-update-steps
~navi~algo:~HTMLnav#navigate
~navigateã™ã‚‹:~HTMLnav#navigate
~navigableã‚’~URLã¸~navigateã™ã‚‹:~HTMLnav#navigate
~navigableã‚’èª­è¾¼ç›´ã™:~HTMLnav#reload
~navigateã™ã‚‹ã“ã¨ã¯~sandboxæ³•ã«ã‚ˆã‚Šè¨±å®¹ã•ã‚Œ:~HTMLnav#allowed-to-navigate
~navi~APIç”¨ã«~sessionå±¥æ­´~entryç¾¤ã‚’å–å¾—-:~HTMLnav#getting-session-history-entries-for-the-navigation-api
~naviã«å¯¾ã™ã‚‹åˆ©ç”¨è€…-é–¢ä¸i:~HTMLnav#user-navigation-involvement
~naviã¯ç½®æ›-ã«ãªã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã‹ï¼Ÿ:~HTMLnav#the-navigation-must-be-a-replace
~scrollä½ç½®~dataã‚’å¾©æ—§ã™ã‚‹:~HTMLnav#restore-scroll-position-data
~sessionå±¥æ­´~entry:~HTMLnav#session-history-entry
~sessionå±¥æ­´~entryç¾¤ã‚’å–å¾—ã™ã‚‹:~HTMLnav#getting-session-history-entries
~sessionå±¥æ­´~è¾¿ã‚Šæ‰‹ç¶šãã‚’ä»˜åŠ ã™ã‚‹:~HTMLnav#tn-append-session-history-traversal-steps
~source~snapshot~paramsã‚’~snapshotã™ã‚‹:~HTMLnav#snapshotting-source-snapshot-params
å±¥æ­´~å–æ‰±ã„ã®æŒ™å‹•:~HTMLnav#history-handling-behavior
å±¥æ­´ã‚’å·®åˆ†ã ã‘è¾¿ã‚‹:~HTMLnav#traverse-the-history-by-a-delta
æ–‡æ›¸ã‚’ä½œå‹•åŒ–ã—ç›´ã™:~HTMLnav#reactivate-a-document
ç›´åˆ—å½¢ã®çŠ¶æ…‹:~HTMLnav#serialized-state
ç´ ç‰‡ã¸ã®~navi:~HTMLnav#navigate-fragid
	ç´ ç‰‡ã¸~navigateã™ã‚‹:~HTMLnav#navigate-fragid
ç´ ç‰‡ã¸~scrollã™ã‚‹:~HTMLnav#scroll-to-the-fragment-identifier
è¾¿-ç”¨ã«å±¥æ­´~stepã‚’é©ç”¨ã™ã‚‹:~HTMLnav#apply-the-traverse-history-step
è¾¿-ç”¨ã«å±¥æ­´~stepã‚’é©ç”¨ã™ã‚‹ã“ã¨ã‚’å†é–‹ã™ã‚‹:~HTMLnav#resume-applying-the-traverse-history-step

~unload~counter:~HTMLlifecycle#unload-counter
doc.å›å¾©å¯èƒ½~çŠ¶æ…‹:~HTMLlifecycle#concept-document-salvageable

aG.~event~loop:~WAPI#concept-agent-event-loop
~event~handler:~WAPI#event-handlers
~event~handler~IDLå±æ€§:~WAPI#event-handler-idl-attributes
~event~handler~eventå‹:~WAPI#event-handler-event-type
~naviã¨è¾¿ã‚Š~task~source:~WAPI#navigation-and-traversal-task-source
~scriptã‚’èµ°ã‚‰ã™ãŸã‚ã«æº–å‚™ã™ã‚‹:~WAPI#prepare-to-run-script
~erroræƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹:~WAPI#extract-error
å¤§åŸŸ~taskã‚’~queueã™ã‚‹:~WAPI#queue-a-global-task
å°task~checkpointã‚’é‚è¡Œã™ã‚‹:~WAPI#perform-a-microtask-checkpoint
èµ°ã‚‰ã›ãŸ~scriptã‚’ç‰‡ä»˜ã‘ã‚‹:~WAPI#clean-up-after-running-script
é–¢é€£ãª~agent:~WAPI#relevant-agent
é–¢é€£ãª~realm:~WAPI#concept-relevant-realm
é–¢é€£ãªå¤§åŸŸ~obj:~WAPI#concept-relevant-global
é–¢é€£ãªè¨­å®šç¾¤~obj:~WAPI#relevant-settings-object

åºæ•°~å€¤:~HEgrouping#ordinal-value

	â—å¼•æ•°ï¼Š

	%~navi~APIçŠ¶æ…‹:~HTMLnav#navigation-navigation-api-state
	%ä¾‹å¤–ã‚’å¯èƒ½åŒ–ã™ã‚‹ã‹:~HTMLnav#exceptions-enabled
	%å±¥æ­´~å–æ‰±ã„:~HTMLnav#navigation-hh
	%~navi~APIçŠ¶æ…‹:~HTMLnav#reload-navigation-api-state
	%å±¥æ­´~å–æ‰±ã„:~HTMLnav#uhus-historyhandling
	%ç›´åˆ—å½¢ã®~data:~HTMLnav#uhus-serializeddata

	â—ç”¨èªï¼ˆå¤–éƒ¨
url.~scheme:~URL1#concept-url-scheme
url.ç´ ç‰‡:~URL1#concept-url-fragment
~URL:~URL1#concept-url
~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹:~URL1#concept-url-serializer
åŒç­‰ãª~URL:~URL1#concept-url-equals
	ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹:~URL1#url-equals-exclude-fragments

sct.~item:~INFRA#struct-item
	~Assert:~INFRA#assert
	~EACH:~INFRA#list-iterate
	~IN:~INFRA#list-contain
	~WHILE:~INFRA#iteration-while
~cloneã™ã‚‹:~INFRA#list-clone
~entryã‚’é™¤å»ã™ã‚‹:~INFRA#map-remove
~list:~INFRA#list
æœ‰é †åº~map:~INFRA#ordered-map
	~mapå†…ã«å­˜åœ¨ã™ã‚‹:~INFRA#map-exists
~size:~INFRA#list-size
	ä¸€è‡´ã™ã‚‹:~INFRA#string-is â†’ ~NEQ
ä»˜åŠ ã™ã‚‹:~INFRA#list-append
æ§‹é€ ä½“:~INFRA#struct
ç©º:~INFRA#list-is-empty
é™¤å»ã™ã‚‹:~INFRA#list-remove

æ–°ãŸãª~promise:~WEBIDLjs#a-new-promise
~promiseã‚’å´ä¸‹ã™ã‚‹:~WEBIDLjs#reject
~promiseã‚’è§£æ±ºã™ã‚‹:~WEBIDLjs#resolve
~promiseã‚’å–æ‰±æ¸ˆã¿ã¨ã—ã¦~markã™ã‚‹:~WEBIDLjs#mark-a-promise-as-handled
~callbacké–¢æ•°ã‚’å‘¼å‡ºã™:~WEBIDLjs#invoke-a-callback-function
å´ä¸‹ã•ã‚Œã‚‹~promise:~WEBIDLjs#a-promise-rejected-with
æ–°ãŸãª~obj:~WEBIDLjs#new
è§£æ±ºã•ã‚Œã‚‹~promise:~WEBIDLjs#a-promise-resolved-with
ã™ã¹ã¦ã®~promiseã‚’å¾…æ©Ÿã™ã‚‹:~WEBIDLjs#wait-for-all
	ã‚³ãƒ¬:~WEBIDL#this

aB.ä¸­æ­¢-æ¸ˆã¿:~DOM4#abortsignal-aborted
aC.ä¸­æ­¢-ã‚’é€šé”ã™ã‚‹:~DOM4#abortcontroller-signal-abort
aC.é€šé”:~DOM4#abortcontroller-signal
doc.~URL:~DOM4#concept-document-url
doc.ç”Ÿæˆå…ƒ:~DOM4#concept-document-origin
ev.å–æ¶ˆã•ã‚ŒãŸã‹:~DOM4#canceled-flag
ev.é…é€-ä¸­ã‹:~DOM4#dispatch-flag
~target:~DOM4#concept-event-target
~eventã‚’ä½œæˆã™ã‚‹:~DOM4#concept-event-create
~eventã‚’ç™ºç«ã™ã‚‹:~DOM4#concept-event-fire
~eventã‚’é…é€ã™ã‚‹:~DOM4#concept-event-dispatch
æ–‡æ›¸~è¦ç´ :~DOM4#document-element

doc.åˆæœŸ~about_blankã‹:~HTMLdom#is-initial-about:blank

dS.ç”Ÿæˆå…ƒ:~HTMLnav#document-state-origin
dS.è¦è«‹~referreræ–½ç­–:~HTMLnav#document-state-request-referrer-policy
doc.æŒ‡ç¤ºã•ã‚ŒãŸéƒ¨ä½:~HTMLnav#the-indicated-part-of-the-document
i.~browser~UI:~HTMLnav#uni-browser-ui
i.ãªã—:~HTMLnav#uni-none
i.ä½œå‹•åŒ–:~HTMLnav#uni-activation

é€†ç›´åˆ—åŒ–:~HTMLcloning#structureddeserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage


rs.çŠ¶æ…‹s:~FETCH#concept-response-status

~JSå®Ÿè¡Œ~æ–‡è„ˆ:~TC39#sec-execution-contexts
~JSå®Ÿè¡Œ~æ–‡è„ˆ~stack:~TC39#execution-context-stack

~consoleã«è­¦å‘Šã‚’å ±å‘Šã™ã‚‹:~CONSOLE#report-a-warning-to-the-console

~referreræ–½ç­–:~REFERRER-POLICY#referrer-policy

æ–‡æ›¸ã®å…ˆé ­ã¸~scrollã™ã‚‹:~CSSOMVIEW#scroll-to-the-beginning-of-the-document
è¡¨ç¤ºåŸŸ:~CSS2J#viewport

â—â—html_code_list

â– navigation-api-intro-1
<button onclick="navigation.reload()">Reload</button>
ï¼…
<input type="url" id="navigationURL">
<button onclick="navigation.navigate(navigationURL.value)">Navigate</button>
ï¼…
<button id="backButton" onclick="navigation.back()">Back</button>
<button id="forwardButton" onclick="navigation.forward()">Forward</button>
ï¼…
<select id="traversalDestinations"></select>
<button id="goButton" onclick="navigation.traverseTo(%traversalDestinations.value)">Traverse To</button>
ï¼…
<ï¼…script>
%backButton.disabled = !navigation.canGoBack;
%forwardButton.disabled = !navigation.canGoForward;
ï¼…
for (const %entry of navigation.entries()) {
  %traversalDestinations.append(new Option(%entry.url, %entry.key));
}
</ï¼…script>

â—â—trans_metadata
<p>
~THIS_PAGEã¯ã€~WHATWGã«ã‚ˆã‚‹ HTML ä»•æ§˜ã®
<a href="~SPEC_URL#nav-traversal-apis">Â§ The navigation API</a>
ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ãŸã‚‚ã®ã§ã™ã€‚
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML â€” ãƒŠãƒ“ API</h1>
<p>The navigation API</p>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="_conventions">
<h2>ã€ã“ã®è¨³ã«ç‰¹æœ‰ãªè¡¨è¨˜è¦ç´„ã€‘</h2>

â—è¡¨è¨˜è¨˜å·

	</section>
			<section id="navigation-api">
<h4 title="The navigation API">7.2.6. ~navi~API</h4>

<p class="trans-note">ã€
ã“ã®~APIã¯æ¯”è¼ƒçš„æ–°ã—ã„ã®ã§ã€
`~supportã™ã‚‹~browserï¼ https://developer.mozilla.org/en-US/docs/Web/API/Navigation#browser_compatibility$ã¯ï¼Œã¾ã é™ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
ã€‘</p>

				<section id="navigation-api-intro">
<h5 title="Introduction">7.2.6.1 åºè«–</h5>

â—éè¦ç¯„çš„

<p>
~navi~APIã¯ã€
å¤§åŸŸçš„ãª `navigation$m ~propã«ã‚ˆã‚Šä¾›ã•ã‚Œï¼Œ
~naviã¨å±¥æ­´~entryã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®ï¼»
ç¾ä»£ã®, ~web~appã«æ³¨åŠ›ã—ãŸä»•æ–¹
ï¼½ã‚’ä¾›ã™ã‚‹ã€‚
ãã‚Œã¯ã€
å¤å…¸çš„ãªï¼»
`locationï¼ ~WINDOW#dom-location$c,
`historyï¼ ~WINDOW#dom-history$c
ï¼½~APIã®å¾Œç¶™ã§ã‚ã‚‹ã€‚
â—
The navigation API, provided by the global navigation property, provides a modern and web application-focused way of managing navigations and history entries. It is a successor to the classic location and history APIs.
</p>

<p>
ã“ã®~APIãŒä¾›ã™ã‚‹èƒ½ã¨ã—ã¦
`~sessionå±¥æ­´~entry$ã‚’æ¤œåˆ†ã™ã‚‹ã“ã¨ãŒæŒ™ã’ã‚‰ã‚Œã‚‹ã€‚
ä¾‹ãˆã°ï¼Œæ¬¡ã®~codeã¯ã€
å„~entryã®~URLã‚’æœ‰é †åº~listå†…ã«è¡¨ç¤ºã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
One ability the API provides is inspecting session history entries. For example, the following will display the entries' URLs in an ordered list:
</p>

<pre class="lang-js">
const %ol = document.createElement("ol");
%ol.start = 0; /* <span class="comment">
å„~list~itemã®`åºæ•°~å€¤$ãŒ~entryã®~indexã¨åˆè‡´ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹
â—
so that the list items' ordinal values match up with the entry indices
</span> */

for (const %entry of navigation.entries()) {
  const %li = document.createElement("li");

  if (%entry.index &lt; navigation.currentEntry.index) {
    %li.className = "backward";
  } else if (%entry.index &gt; navigation.currentEntry.index) {
    %li.className = "forward";
  } else {
    %li.className = "current";
  }

  %li.textContent = %entry.url;
  %ol.append(%li);
}
</pre>

<p>
`navigation.entries()$c ãŒè¿”ã™é…åˆ—ã¯ã€
`NavigationHistoryEntry$I ~instanceãŸã¡ã‚’åŒ…å«ã™ã‚‹ã€‚
ãã‚Œã‚‰ã¯ã€
ã“ã“ã«ç¤ºã•ã‚Œã‚‹ï¼»
`url$mH, `index$mH
ï¼½~propã«åŠ ãˆã¦ï¼Œä»–ã®æœ‰ç”¨ãª~propã‚‚æœ‰ã™ã‚‹ã€‚
ã“ã®é…åˆ—ãŒåŒ…å«ã™ã‚‹ `NavigationHistoryEntry$I ~objã¯ï¼š
â—
The navigation.entries() array contains NavigationHistoryEntry instances, which have other useful properties in addition to the url and index properties shown here.ï¼¼
</p>
<ul>
	<li>
ç¾åœ¨ã®`~navigable$ã‚’è¡¨ç¾ã™ã‚‹ã‚‚ã®ã«é™ã‚‰ã‚Œã‚‹ã®ã§ã€
ãã®å†…å®¹ã¯ï¼»
`iframe$e ãªã©ï¼Œ`~navigableå®¹å™¨$ã®å†…å´ã«ã‚ã‚‹~naviï¼
å½“ã®~navi~APIãŒ `iframe$e ã®å†…å´ã§åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹äº‹ä¾‹ã§ã¯`è¦ª$navã®~navi
ï¼½ã«ã‚ˆã‚Šå½±éŸ¿iã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã€‚
â—
Note that the array only contains NavigationHistoryEntry objects that represent the current navigable, and thus its contents are not impacted by navigations inside navigable containers such as iframes, or by navigations of the parent navigable in cases where the navigation API is itself being used inside an iframe.ï¼¼
</li>
	<li>
åŒä¸€-`ç”Ÿæˆå…ƒ$ã«å±ã™ã‚‹`~sessionå±¥æ­´~entry$ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ã‚‚ã®ã«é™ã‚‰ã‚Œã‚‹
â€” ã™ãªã‚ã¡ã€
åˆ©ç”¨è€…ãŒç¾åœ¨ã®~entryã‚ˆã‚Šå‰ï¼å¾Œã«ã‚ã‚‹ä»–ã®ç”Ÿæˆå…ƒã¸è¨ªå•ã—ãŸå ´åˆï¼Œ
ãã“ã«ã¯å¯¾å¿œã™ã‚‹ `NavigationHistoryEntry$I ã¯ç„¡ã„ã€‚
â—
Additionally, it only contains NavigationHistoryEntry objects representing same-origin session history entries, meaning that if the user has visited other origins before or after the current one, there will not be corresponding NavigationHistoryEntrys.
</li>
</ul>

<hr>

<p>
~navi~APIã¯ã€
å±¥æ­´ã‚’é€šã—ã¦ï¼»
~navigateã™ã‚‹ï¼èª­è¾¼ç›´ã™ï¼è¾¿ã‚‹
ï¼½ãŸã‚ã«ã‚‚åˆ©ç”¨ã§ãã‚‹ï¼š
â—
The navigation API can also be used to navigate, reload, or traverse through the history:
</p>

`navigation-api-intro-1^xCode

<p>
ã“ã“ã§ã‚‚ã€
è¾¿ã‚Šã¯ï¼ŒåŒä¸€-`ç”Ÿæˆå…ƒ$ã«å±ã™ã‚‹è¡Œå…ˆã«åˆ¶é™ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã€‚
ã™ãªã‚ã¡ã€
ä¾‹ãˆã° `navigation.canGoBack$c ã¯ï¼Œ
ç›´å‰ã®`~sessionå±¥æ­´~entry$ãŒåˆ¥ã®ç”Ÿæˆå…ƒã«å±ã™ã‚‹~pageç”¨ã§ã‚ã‚‹å ´åˆã«ã¯
~F ã«ãªã‚‹ã€‚
â—
Note that traversals are again limited to same-origin destinations, meaning that, for example, navigation.canGoBack will be false if the previous session history entry is for a page from another origin.
</p>

<hr>

<p>
~navi~APIã‚’æˆã™æœ€ã‚‚å¼·åŠ›ãªéƒ¨åˆ†ã¯ã€
`navigate$et ~eventã§ã‚ã‚‹
â€” ãã‚Œã¯ã€
ç¾åœ¨ã®`~navigable$ã«ãŠã„ã¦ï¼Œã»ã¼ ã©ã®ï¼»
~naviï¼è¾¿ã‚Š
ï¼½ãŒç”Ÿã˜ã¦ã‚‚ç™ºç«ã•ã‚Œã‚‹ï¼š
â—
The most powerful part of the navigation API is the navigate event, which fires whenever almost any navigation or traversal occurs in the current navigable:
</p>

<pre class="lang-js">
%navigation.onnavigate = %event =&gt; {
  console.log(%event.navigationType); /* <span class="comment">
`push^l ï¼ `replace^l ï¼ `reload^l ï¼ `traverse^l
â—
"push", "replace", "reload", or "traverse"
</span> */
  console.log(%event.destination.url);
  console.log(%event.userInitiated);
  /* <span class="comment">
â€¦ãŠã‚ˆã³ï¼Œ`ä»–ã®æœ‰ç”¨ãª~propï¼ #the-navigateevent-interface$
â—
... and other useful properties
</span> */
};
</pre>

<p>
ï¼ˆã“ã®~eventã¯ã€ï¼»
`~URL~barã‹ã‚‰èµ·å‹•ã•ã‚ŒãŸï¼ ~HTMLsl#nav-traversal-ui$ï¼
ä»–ã®~windowã‹ã‚‰èµ·å‹•ã•ã‚ŒãŸï¼
è¡Œå…ˆãŒæ–°ãŸãªæ–‡æ›¸ã«ãªã‚‹
ï¼½~naviç”¨ã«ã¯ï¼Œç™ºç«ã•ã‚Œãªã„ã€‚ï¼‰
â—
(The event will not fire for location bar-initiated navigations, or navigations initiated from other windows, when the destination of the navigation is a new document.)
</p>

<p>
ã“ã®~eventã® `cancelable$m ~propã¯ã€
å¤§æŠµã¯ ~T ã«ãªã‚‹
â€” ã™ãªã‚ã¡ã€
`preventDefault()$m ã‚’åˆ©ç”¨ã—ã¦å–æ¶ˆã›ã‚‹ï¼š
â—
Much of the time, the event's cancelable property will be true, meaning this event can be canceled using preventDefault():
</p>

<pre>
navigation.onnavigate = %event =&gt; {
  if (%event.cancelable &amp;&amp; isDisallowedURL(%event.destination.url)) {
    alert(``^ãŠé¡˜ã„ã ã‹ã‚‰ ${%event.destination.url} ã¸ã¯è¡Œã‹ãªã„ã§ğŸ™``^);
    %event.preventDefault();
  }
};
</pre>

<p>
`cancelable$m ~propã¯ã€
ä¸€éƒ¨ã® `traverse$l ~naviç”¨ã«ã¯ ~F ã«ãªã‚‹
â€” æ¬¡ã«æŒ™ã’ã‚‹å ´åˆãªã©ï¼š
â—
The cancelable property will be false for some "traverse" navigations, such asï¼¼
</p>
<ul>
	<li>
`å­~navigable$ã®å†…å´ã§å ´ã‚’å ã‚ã‚‹ã‚‚ã®ã€‚
â—
those taking place inside child navigables,ï¼¼
</li>
	<li>
æ–°ãŸãªéåŒä¸€-ç”Ÿæˆå…ƒã¸è¡Œãã‚‚ã®ã€‚
â—
those crossing to new origins,ï¼¼
</li>
	<li>
åˆ©ç”¨è€…ãŒï¼»
ä»¥å‰ã« `preventDefault()$m ã®~callã«ã‚ˆã‚Šè¾¿ã‚‹ã“ã¨ã‚’é˜²æ­¢ã•ã‚ŒãŸã¨ã
ï¼½ã‹ã‚‰ï¼Œãã®å¾Œã™ãã«å†ã³è¾¿ã‚‹ã‚ˆã†è©¦ã¿ãŸã¨ãã€‚
â—
or when the user attempts to traverse again shortly after a previous call to preventDefault() prevented them from doing so.
</li>
</ul>

<p>
`NavigateEvent$I ã® `intercept()$mE ~methodã¯ã€
~naviã‚’æ¨ªå–ã—ã¦ï¼Œãã‚Œã‚’åŒä¸€-æ–‡æ›¸ã¸ã®~naviã«å¤‰æ›ã™ã‚‹ã“ã¨ã‚’è¨±å®¹ã™ã‚‹ï¼š
â—
The NavigateEvent's intercept() method allows intercepting a navigation and converting it into a same-document navigation:
</p>

<pre class="lang-js">
navigation.addEventListener("navigate", %e =&gt; {
  /* <span class="comment">
ä¸€éƒ¨ã®~naviã¯ï¼Œæ¨ªå–ã§ããªã„
â€” ä¾‹ï¼šéåŒä¸€-ç”Ÿæˆå…ƒã¸ã®~naviã€‚
ãã‚Œã‚‰ã¯ã€
é€šå¸¸ã«å–æ‰±ã†ã‚ˆã†~browserã«ä»»ã›ã‚‹ã€‚
â—
Some navigations, e.g. cross-origin navigations, we cannot intercept. Let the browser handle those normally.
</span> */
  if (!%e.canIntercept) {
    return;
  }

  /* <span class="comment">
é¡ä¼¼ã«ã€
ç´ ç‰‡ã¸ã®~naviã‚„~downloadã¯ï¼Œæ¨ªå–ã—ãªã„ã€‚
â—
Similarly, don't intercept fragment navigations or downloads.
</span> */
  if (%e.hashChange || %e.downloadRequest !== null) {
    return;
  }

  const %url = new URL(%event.destination.url);

  if (%url.pathname.startsWith("/articles/")) {
    %e.intercept({
      async handler() {
        /* <span class="comment">
~URLã¯ï¼Œã™ã§ã«å¤‰åŒ–ã—ãŸã®ã§ã€
æ–°ãŸãªå†…å®¹ã‚’~fetchã—ã¦ã„ã‚‹é–“ã¯ï¼Œä»£ã‚ã‚Šã®ä½•ã‹
â€” ~pageã¯èª­è¾¼nä¸­ã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ã™ã‚‚ã®ãªã© â€”
ã‚’ç¤ºã™ã€‚
â—
The URL has already changed, so show a placeholder while fetching the new content, such as a spinner or loading page.
</span> */
        renderArticlePagePlaceholder();

        /* <span class="comment">
æ–°ãŸãªå†…å®¹ã‚’~fetchã—ã¦ï¼Œ
æº–å‚™æ¸ˆã¿ã«ãªã£ãŸã¨ãè¡¨ç¤ºã™ã‚‹ã€‚
â—
Fetch the new content and display when ready.
</span> */
        const %articleContent = await getArticleContent(%url.pathname, { signal: %e.signal });
        renderArticlePage(%articleContent);
      }
    });
  }
});
</pre>

<p>
`handler$mb é–¢æ•°ã¯ã€
å½“ã®~naviã®ï¼»
éåŒæœŸçš„ãªé€²æ—ï¼æˆå¦
ï¼½ã‚’è¡¨ç¾ã™ã‚‹~promiseã‚’è¿”ã›ã‚‹ã“ã¨ã«æ³¨æ„ã€‚
~promiseãŒä¾ç„¶ã¨ã—ã¦å‡¦ç†å¾…ã¡ã«ã‚ã‚‹é–“ã€
~browser~UIã¯ï¼Œ~naviã‚’é€²è¡Œä¸­ã¨ã—ã¦æ‰±ãˆã‚‹
ï¼ˆä¾‹ï¼šèª­è¾¼nä¸­ã‚’è¡¨ã™ä½•ã‹ã‚’å‘ˆç¤ºã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼‰ã€‚
~navi~APIã‚’æˆã™ä»–ã®å„éƒ¨ã‚‚ï¼Œã“ã‚Œã‚‰ã®~promise
â€” `navigation.navigate()$c ã®è¿”ã‚Šå€¤ãªã© â€”
ã«æ•æ„Ÿã§ã‚ã‚‹ï¼š
â—
Note that the handler function can return a promise to represent the asynchronous progress, and success or failure, of the navigation. While the promise is still pending, browser UI can treat the navigation as ongoing (e.g., by presenting a loading spinner). Other parts of the navigation API are also sensitive to these promises, such as the return value of navigation.navigate():
</p>
<pre class="lang-js">
const { %committed, %finished } = await navigation.navigate("/articles/the-navigation-api-is-cool");

/* <span class="comment">
~commitæ™‚ã®~promiseï¼ˆ %committed ï¼‰ã¯ã€
~URLãŒå¤‰åŒ–ã—ãŸãªã‚‰ï¼Œå……è¶³ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹
â€” ãã‚Œã¯ã€
ï¼ˆ `NavigateEvent^I ãŒå–æ¶ˆã•ã‚Œãªã‹ã£ãŸãªã‚‰ï¼‰
å³æ™‚ã«èµ·ã“ã‚‹ã€‚
â—
The committed promise will fulfill once the URL has changed, which happens immediately (as long as the NavigateEvent wasn't canceled).
</span> */
await %committed;

/* <span class="comment">
å®Œé‚-æ™‚ã®~promiseï¼ˆ %finished ï¼‰ã¯ã€
`handler()^c ãŒè¿”ã—ãŸ~promiseã€ï¼Promiseã€‘ãŒå……è¶³ã•ã‚ŒãŸãªã‚‰ï¼Œå……è¶³ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹
â€” ãã‚Œã¯ã€
å½“ã®è¨˜äº‹ï¼ˆ `articles/...^l ï¼‰ãŒ~downloadã•ã‚Œï¼Œå…·ç¾åŒ–ã•ã‚ŒãŸã¨ãèµ·ã“ã‚‹ã€‚
ï¼ˆã‚ã‚‹ã„ã¯ã€
`handler()^c ãŒé€”ä¸­ã§å¤±æ•—ã—ãŸå ´åˆã«ã¯ï¼Œå´ä¸‹ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ï¼‰ã€‚
â—
The finished promise will fulfill once the Promise returned by handler() has fulfilled, which happens once the article is downloaded and rendered. (Or, it will reject, if handler() fails along the way).
</span> */
await %finished;
</pre>

				</section>
				<section id="navigation-interface">
<h5 title="The Navigation interface">7.2.6.2. `Navigation^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `Navigation@I : `EventTarget$I {
  sequence&lt;`NavigationHistoryEntry$I&gt; `entries$mN();
  readonly attribute `NavigationHistoryEntry$I? `currentEntry$mN;
  undefined `updateCurrentEntry$mN(`NavigationUpdateCurrentEntryOptions$I options);
  readonly attribute `NavigationTransition$I? `transition$mN;
  readonly attribute `NavigationActivation$I? `activation$mN;

  readonly attribute boolean `canGoBack$mN;
  readonly attribute boolean `canGoForward$mN;

  `NavigationResult$I `navigate$mN(USVString url, optional `NavigationNavigateOptions$I options = {});
  `NavigationResult$I `reload$mN(optional `NavigationReloadOptions$I options = {});

  `NavigationResult$I `traverseTo$mN(DOMString key, optional `NavigationOptions$I options = {});
  `NavigationResult$I `back$mN(optional `NavigationOptions$I options = {});
  `NavigationResult$I `forward$mN(optional `NavigationOptions$I options = {});

  attribute `EventHandler$I `onnavigate$mN;
  attribute `EventHandler$I `onnavigatesuccess$mN;
  attribute `EventHandler$I `onnavigateerror$mN;
  attribute `EventHandler$I `oncurrententrychange$mN;
};

dictionary `NavigationUpdateCurrentEntryOptions@I {
  required any `state@mbC;
};

dictionary `NavigationOptions@I {
  any `info@mbN;
};

dictionary `NavigationNavigateOptions@I : `NavigationOptions$I {
  any `state@mbN;
  `NavigationHistoryBehavior$I `history@mbN = `auto$hH;
};

dictionary `NavigationReloadOptions@I : `NavigationOptions$I {
  any `state@mbR;
};

dictionary `NavigationResult@I {
  `Promise$&lt;`NavigationHistoryEntry$I&gt; `committed@mb;
  `Promise$&lt;`NavigationHistoryEntry$I&gt; `finished@mb;
};

enum `NavigationHistoryBehavior@I {
  `auto$hH,
  `push$hH,
  `replace$hH
};
</pre>

<p>
å„ `Window$I ~obj %~window ã«ã¯ã€
`~navi~API@
â€” ã‚ã‚‹ `Navigation$I ~obj â€”
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
%~window ã®ä½œæˆ~æ™‚ã«ã¯ã€
ãã®`~navi~API$ã‚’æ¬¡ã®çµæœã«è¨­å®šã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«
â‡’
`æ–°ãŸãª~obj$( `Navigation$I, %~window ã«`é–¢é€£ãª~realm$ )
â—
Each Window has an associated navigation API, which is a Navigation object. Upon creation of the Window object, its navigation API must be set to a new Navigation object created in the Window object's relevant realm.
</p>

<div class="algo">
`Window$I ã®
`navigation@m
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~navi~API$
â—
The navigation getter steps are to return this's navigation API.
</div>

<p>
`Navigation$I ~interfaceã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã™ã¹ã¦ã®~objã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹`~event~handler$
ï¼ˆãŠã‚ˆã³ï¼Œå¯¾å¿œã—ã¦ã„ã‚‹`~event~handler~eventå‹$ï¼‰
ã‚’`~event~handler~IDLå±æ€§$ã¨ã—ã¦~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the Navigation interface:
</p>

<table><thead>
<tr><th>
`~event~handler$
â—
Event handler
<th>
`~event~handler~eventå‹$
â—
Event handler event type
<tbody>

<tr><td>`onnavigate@mN
<td>`navigate$et
<tr><td>`onnavigatesuccess@mN
<td>`navigatesuccess$et
<tr><td>`onnavigateerror@mN
<td>`navigateerror$et
<tr><td>`oncurrententrychange@mN
<td>`currententrychange$et
</table>

				</section>
				<section id="navigation-api-core">
<h5 title="Core infrastructure">7.2.6.3. ä¸­æ ¸~åŸºç›¤</h5>

<p>
å„ `Navigation$I ã«ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
â†“</p>
<ul>
	<li>
<p>
`~entry~list@nV
â‡’
`NavigationHistoryEntry$I ~objãŸã¡ãŒæˆã™`~list$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
</p>

<p class="trans-note">ã€
ã“ã®~listãŒè¡¨ç¾ã™ã‚‹ï¼»
`~sessionå±¥æ­´~entry$nheãŸã¡ãŒæˆã™~list
ï¼½ã¯ã€
â€œ~naviå±¥æ­´~entry~listâ€
ã¨ç§°ã•ã‚Œã‚‹ã€‚
ã€‘</p>
â—
Each Navigation has an associated entry list, a list of NavigationHistoryEntry objects, initially empty.
</li>
	<li>
`ç¾åœ¨ã®~entry~index@nV
â‡’
æ•´æ•°
â€” åˆæœŸ~æ™‚ã¯ âˆ’1 ã¨ã™ã‚‹ã€‚
â—
Each Navigation has an associated current entry index, an integer, initially âˆ’1.
</li>
</ul>

<div class="algo">
<p>
`~naviã®ç¾åœ¨ã®~entry@
ã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi )
ã«å¯¾ã—ï¼š
â—
The current entry of a Navigation navigation is the result of running the following steps:
</p>
<ol>
	<li>
~IFï¼»
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET ~NULL
â—
If navigation has entries and events disabled, then return null.
</li>
	<li>
~Assertï¼š
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~NEQ âˆ’1
â—
Assert: navigation's current entry index is not âˆ’1.
</li>
	<li>
~RET %~navi ã®`~entry~list$nV[ %~navi ã®`ç¾åœ¨ã®~entry~index$nV ]
â—
Return navigation's entry list[navigation's current entry index].
</li>
</ol>
</div>

<div class="algo">
<p>
`Navigation$I %~navi ã®
`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦@
ã„ã‚‹ã¨ã¯ã€ï¼»
%~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
ï¼½ãŒ ~ORâ†“ ã‚’æº€ãŸã™ã“ã¨ã‚’ã„ã†ï¼š
</p>
<ul>
	<li>
`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
</li>
	<li>
ãã®`åˆæœŸ~about_blankã‹$doc ~EQ ~T
</li>
	<li>
ãã®`ç”Ÿæˆå…ƒ$docã¯`ä¸é€æ˜ãªç”Ÿæˆå…ƒ$ã§ã‚ã‚‹
</li>
</ul>
â—
A Navigation navigation has entries and events disabled if the following steps return true:
â€¢ Let document be navigation's relevant global object's associated Document.
â€¢ If document is not fully active, then return true.
â€¢ If document's is initial about:blank is true, then return true.
â€¢ If document's origin is opaque, then return true.
â€¢ Return false.
</div>

<div class="algo">
<p>
`~navi~API~entry~indexã‚’å–å¾—ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi, `~sessionå±¥æ­´~entry$ %å±¥æ­´~entry )
ã«å¯¾ã—ï¼š
â—
To get the navigation API entry index of a session history entry she within a Navigation navigation:
</p>
<ol>
	<li>
%~index ~LET 0
â—
Let index be 0.
</li>
	<li>
<p>
%~navi ã®`~entry~list$nVã‚’æˆã™
~EACH( %~NHE )
ã«å¯¾ã—ï¼š
â—
For each nhe of navigation's entry list:
</p>
		<ol>
			<li>
~IFï¼»
%~NHE ã®`~sessionå±¥æ­´~entry$nhe ~EQ %å±¥æ­´~entry
ï¼½
â‡’
~RET %~index
â—
If nhe's session history entry is equal to she, then return index.
</li>
			<li>
%~index ~INCBY 1
â—
Increment index by 1.
</li>
		</ol>
	</li>
	<li>
~RET âˆ’1
â—
Return âˆ’1.
</li>
</ol>
</div>

<hr>

<p>
`NavigationType$I åˆ—æŒ™ã¯ã€
~navi~APIå…¨ä½“ã‚’é€šã—ã¦ï¼»
è¦ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã‚‹ç¨®åˆ¥
ï¼½ã‚’ä¸ãˆã‚‹ï¼š
â—
A key type used throughout the navigation API is the NavigationType enumeration:
</p>

<pre class="idl">
enum `NavigationType@I {
 `push$l,
 `replace$l,
 `reload$l,
 `traverse$l
};
</pre>

<p>
ã“ã‚Œã¯ã€
~webé–‹ç™ºè€…ã‹ã‚‰å¯è¦–ãª â€œ~naviâ€ ã®ä¸»ãªç¨®åˆ¥ã‚’æ•æ‰ã™ã‚‹
â€” ãã‚Œã¯ã€
ï¼ˆ`ä»–æ‰€ã«ã¦æ³¨è¨˜ã•ã‚ŒãŸï¼ ~HTMLnav#note-meaning-of-navigate$ã¨ãŠã‚Šï¼‰
ã“ã®æ¨™æº–ã‚’æˆã™å”¯ä¸€ã®`~navi~algo$ã«æ­£ç¢ºã«ã¯å¯¾å¿œã—ã¦ã„ãªã„ã€‚
å„~å€¤ã®æ„å‘³ã¯ï¼š
â—
This captures the main web developer-visible types of "navigations", which (as noted elsewhere) do not exactly correspond to this standard's singular navigate algorithm. The meaning of each value is the following:
</p>

<dl>
	<dt>`push@l</dt>
	<dd>
<p>
`~navigateã™ã‚‹$å„~callã®ã†ã¡ï¼»
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã«è©²å½“ã™ã‚‹ã‚‚ã®
ï¼½ã«å¯¾å¿œã™ã‚‹ï¼š
</p>
		<ul>
			<li>
`å±¥æ­´~å–æ‰±ã„ã®æŒ™å‹•$ã¯ `push$hH ã«ãªã‚‹ã‚‚ã®
</li>
			<li>
`history.pushState()ï¼ ~WINDOW#dom-history-pushstate$c ã«ã‚ˆã‚‹ã‚‚ã®
</li>
		</ul>
â—
Corresponds to calls to navigate where the history handling behavior ends up as "push", or to history.pushState().
</dd>

	<dt>`replace@l</dt>
	<dd>
<p>
`~navigateã™ã‚‹$å„~callã®ã†ã¡ï¼»
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã«è©²å½“ã™ã‚‹ã‚‚ã®
ï¼½ã«å¯¾å¿œã™ã‚‹ï¼š
</p>
		<ul>
			<li>
`å±¥æ­´~å–æ‰±ã„ã®æŒ™å‹•$ã¯ `replace$hH ã«ãªã‚‹ã‚‚ã®
</li>
			<li>
`history.replaceState()ï¼ ~WINDOW#dom-history-pushstate$c ã«ã‚ˆã‚‹ã‚‚ã®
</li>
		</ul>
â—
Corresponds to calls to navigate where the history handling behavior ends up as "replace", or to history.replaceState().
</dd>

	<dt>`reload@l</dt>
	<dd>
`~navigableã‚’èª­è¾¼ç›´ã™$å„~callã«å¯¾å¿œã™ã‚‹ã€‚
â—
Corresponds to calls to reload.
</dd>

	<dt>`traverse@l</dt>
	<dd>
`å±¥æ­´ã‚’å·®åˆ†ã ã‘è¾¿ã‚‹$å„~callã«å¯¾å¿œã™ã‚‹ã€‚
â—
Corresponds to calls to traverse the history by a delta.
</dd>
</dl>

<p class="note">æ³¨è¨˜ï¼š
`NavigationType$I åˆ—æŒ™ã‚’æˆã™å€¤~ç©ºé–“ã¯ã€
ã“ã®ä»•æ§˜ã®å†…éƒ¨çš„ãª`å±¥æ­´~å–æ‰±ã„ã®æŒ™å‹•$ç”¨ã®ç¨®åˆ¥ã‚’æˆã™å€¤~ç©ºé–“ã®ä¸Šä½é›†åˆã§ã‚ã‚‹ã€‚
ã“ã®æ¨™æº–ã‚’æˆã™å„éƒ¨ã¯ã€
`NavigationType$I ã‚’æœŸå¾…ã™ã‚‹~algoã«`å±¥æ­´~å–æ‰±ã„ã®æŒ™å‹•$ã‚’æ¸¡ã™ã“ã¨ã«ã‚ˆã‚Šï¼Œ
ã“ã®ã“ã¨ã‚’ç”¨ç«‹ã¦ã‚‹ã€‚
â—
The value space of the NavigationType enumeration is a superset of the value space of the specification-internal history handling behavior type. Several parts of this standard make use of this overlap, by passing in a history handling behavior to an algorithm that expects a NavigationType.
</p>

				</section>
				<section id="navigation-api-entry-updates">
<h5 title="Initializing and updating the entry list">7.2.6.4. ~entry~listã®åˆæœŸåŒ–-æ³•ã¨æ›´æ–°-æ³•</h5>

<div class="algo">
<p>
`æ–°ãŸãªæ–‡æ›¸~ç”¨ã«~navi~API~entryç¾¤ã‚’åˆæœŸåŒ–ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`Navigation$I %~navi,
`~sessionå±¥æ­´~entry$ãŸã¡ãŒæˆã™`~list$ %æ–°-å±¥æ­´~entryç¾¤,
`~sessionå±¥æ­´~entry$ %åˆæœŸ~å±¥æ­´~entry
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To initialize the navigation API entries for a new document given a Navigation navigation, a list of session history entries newSHEs, and a session history entry initialSHE:
</p>
<ol>
	<li>
~Assertï¼š
%~navi ã®`~entry~list$nVã¯`ç©º$ã§ã‚ã‚‹ã€‚
â—
Assert: navigation's entry list is empty.
</li>
	<li>
~Assertï¼š
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~EQ âˆ’1
â—
Assert: navigation's current entry index is âˆ’1.
</li>
	<li>
~IFï¼»
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET
â—
If navigation has entries and events disabled, then return.
</li>
	<li>
<p>
%æ–°-å±¥æ­´~entryç¾¤ ã‚’æˆã™
~EACH( %æ–°-å±¥æ­´~entry )
ã«å¯¾ã—ï¼š
â—
For each newSHE of newSHEs:
</p>
		<ol>
			<li>
%æ–°-~NHE ~LET `æ–°ãŸãª~obj$( `NavigationHistoryEntry$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let newNHE be a new NavigationHistoryEntry created in the relevant realm of navigation.
</li>
			<li>
%æ–°-~NHE ã®`~sessionå±¥æ­´~entry$nhe ~SET %æ–°-å±¥æ­´~entry
â—
Set newNHE's session history entry to newSHE.
</li>
			<li>
%~navi ã®`~entry~list$nVã« %æ–°-~NHE ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append newNHE to navigation's entry list.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
%æ–°-å±¥æ­´~entryç¾¤ ã¯ï¼Œ
å…ƒã€…ã¯`~navi~APIç”¨ã«~sessionå±¥æ­´~entryç¾¤ã‚’å–å¾—-$ã—ãŸçµæœãªã®ã§ã€
ãã‚Œã‚’æˆã™~entryãŸã¡ã€ï¼å„ %æ–°-å±¥æ­´~entryã€‘ã¯ï¼Œ
%åˆæœŸ~å±¥æ­´~entry ã¨é€£ç¶šçš„ã«`åŒä¸€-ç”Ÿæˆå…ƒ$ã«ãªã‚‹ã€‚
â—
newSHEs will have originally come from getting session history entries for the navigation API, and thus each newSHE will be contiguous same origin with initialSHE.
</p>
	</li>
	<li>
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~SET `~navi~API~entry~indexã‚’å–å¾—ã™ã‚‹$( %~navi, %åˆæœŸ~å±¥æ­´~entry ï¼‰
â—
Set navigation's current entry index to the result of getting the navigation API entry index of initialSHE within navigation.
</li>
</ol>
</div>

<div class="algo">
<p>
`å†~ä½œå‹•åŒ–~ç”¨ã«~navi~API~entryç¾¤ã‚’æ›´æ–°ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`Navigation$I %~navi,
`~sessionå±¥æ­´~entry$ãŸã¡ãŒæˆã™`~list$ %æ–°-å±¥æ­´~entryç¾¤,
`~sessionå±¥æ­´~entry$ %ä½œå‹•åŒ–ã—ç›´ã•ã‚Œã‚‹å±¥æ­´~entry
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To update the navigation API entries for reactivation given a Navigation navigation, a list of session history entries newSHEs, and a session history entry reactivatedSHE:
</p>
<ol>
	<li>
~IFï¼»
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET
â—
If navigation has entries and events disabled, then return.
</li>
	<li>
%æ–°-~NHEç¾¤ ~LET æ–°ãŸãªç©º`~list$
â—
Let newNHEs be a new empty list.
</li>
	<li>
%æ—§-~NHEç¾¤ ~LET %~navi ã®`~entry~list$nVã‚’`~cloneã™ã‚‹$
â—
Let oldNHEs be a clone of navigation's entry list.
</li>
	<li>
<p>
%æ–°-å±¥æ­´~entryç¾¤ ã‚’æˆã™
~EACH( %æ–°-å±¥æ­´~entry )
ã«å¯¾ã—ï¼š
â—
For each newSHE of newSHEs:
</p>
		<ol>
			<li>
%æ–°-~NHE ~LET ~NULL
â—
Let newNHE be null.
</li>
			<li>
<p>
%æ—§-~NHEç¾¤ ã‚’æˆã™
~EACH( `NavigationHistoryEntry$I %æ—§-~NHE )
ã«å¯¾ã—ï¼š
</p>
				<ol>
					<li>
~IFï¼»
%æ—§-~NHE ã®`~sessionå±¥æ­´~entry$nhe ~NEQ %æ–°-å±¥æ­´~entry
ï¼½
â‡’
~CONTINUE
</li>
					<li>
%æ–°-~NHE ~SET %æ—§-~NHE
</li>
					<li>
%æ—§-~NHEç¾¤ ã‹ã‚‰ %æ—§-~NHE ã‚’`é™¤å»ã™ã‚‹$
</li>
				</ol>
â—
If oldNHEs contains a NavigationHistoryEntry matchingOldNHE whose session history entry is newSHE, then:
â€¢ Set newNHE to matchingOldNHE.
â€¢ Remove matchingOldNHE from oldNHEs.
</li>
			<li>
<p>
~IFï¼»
%æ–°-~NHE ~EQ ~NULL
ï¼½ï¼š
â—
Otherwise:
</p>
				<ol>
					<li>
%æ–°-~NHE ~SET `æ–°ãŸãª~obj$( `NavigationHistoryEntry$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Set newNHE to a new NavigationHistoryEntry created in the relevant realm of navigation.
</li>
					<li>
%æ–°-~NHE ã®`~sessionå±¥æ­´~entry$nhe ~SET %æ–°-å±¥æ­´~entry
â—
Set newNHE's session history entry to newSHE.
</li>
				</ol>
			</li>
			<li>
%æ–°-~NHEç¾¤ ã« %æ–°-~NHE ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append newNHE to newNHEs.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
%æ–°-å±¥æ­´~entryç¾¤ ã¯ï¼Œ
å…ƒã€…ã¯`~navi~APIç”¨ã«~sessionå±¥æ­´~entryç¾¤ã‚’å–å¾—-$ã—ãŸçµæœãªã®ã§ã€
ãã‚Œã‚’æˆã™~entryãŸã¡ã€ï¼å„ %æ–°-å±¥æ­´~entryã€‘ã¯ï¼Œ
%ä½œå‹•åŒ–ã—ç›´ã•ã‚Œã‚‹å±¥æ­´~entry ã¨é€£ç¶šçš„ã«`åŒä¸€-ç”Ÿæˆå…ƒ$ã«ãªã‚‹ã€‚
â—
newSHEs will have originally come from getting session history entries for the navigation API, and thus each newSHE will be contiguous same origin with reactivatedSHE.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~loopã®çµ‚äº†ã¾ã§ %æ—§-~NHEç¾¤ å†…ã«ã‚ã‚Šç¶šã‘ã‚‹ `NavigationHistoryEntry$I ã¯ã€
ã™ã¹ã¦ï¼Œå½“ã®`æ–‡æ›¸$ãŒ`~BF~cache$å†…ã«åœ¨ã£ãŸé–“ã«å‡¦åˆ†ã•ã‚ŒãŸ`~sessionå±¥æ­´~entry$ã‚’è¡¨ç¾ã™ã‚‹ã€‚
â—
By the end of this loop, all NavigationHistoryEntrys that remain in oldNHEs represent session history entries which have been disposed while the Document was in bfcache.
</p>
	</li>
	<li>
%~navi ã®`~entry~list$ ~SET %æ–°-~NHEç¾¤
â—
Set navigation's entry list to newNHEs.
</li>
	<li>
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~SET `~navi~API~entry~indexã‚’å–å¾—ã™ã‚‹$( %~navi, %ä½œå‹•åŒ–ã—ç›´ã•ã‚Œã‚‹å±¥æ­´~entry )
â—
Set navigation's current entry index to the result of getting the navigation API entry index of reactivatedSHE within navigation.
</li>
	<li>
<p>
`å¤§åŸŸ~taskã‚’~queueã™ã‚‹$( `~naviã¨è¾¿ã‚Š~task~source$, %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$, æ¬¡ã®æ‰‹ç¶šã )
â—
Queue a global task on the navigation and traversal task source given navigation's relevant global object to run the following steps:
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
%æ—§-~NHEç¾¤ ã‚’æˆã™
~EACH( %å‡¦åˆ†ã•ã‚Œã‚‹~NHE )
ã«å¯¾ã—
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %å‡¦åˆ†ã•ã‚Œã‚‹~NHE, `dispose$et )
â—
For each disposedNHE of oldNHEs:
â€¢ Fire an event named dispose at disposedNHE.
</div>

<div class="note">
<p>æ³¨è¨˜ï¼š
ã“ã®æ‰‹ç¶šãã‚’~taskã¸é…å»¶ã™ã‚‹ã®ã¯ã€ï¼»
`dispose$et ~eventãŒ `pageshow$et ~eventã‚ˆã‚Šå¾Œã«ç™ºç«ã•ã‚Œã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ï¼»
`æ–‡æ›¸ã‚’ä½œå‹•åŒ–ã—ç›´ã™$éš›ã«~pageãŒå—å–ã‚‹æœ€åˆã®~event
ï¼½ãŒ `pageshow$et ã«ãªã‚‹ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã€‚
â—
We delay these steps by a task to ensure that dispose events will fire after the pageshow event. This ensures that pageshow is the first event a page receives upon reactivation.
</p>

<p>
ï¼ˆã—ã‹ã—ãªãŒã‚‰ï¼Œã“ã®~algoã‚’æˆã™ä»–ã®éƒ¨åˆ†ã¯ã€
`pageshow$et ~eventãŒç™ºç«ã•ã‚Œã‚‹å‰ã«èµ°ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€
`pageshow$et ~event~handlerã®é–“ã«ï¼Œï¼»
`navigation.entries()$c ï¼ `navigation.currentEntry$c
ï¼½ãŒæ­£ã—ãæ›´æ–°ã•ã‚ŒãŸå€¤ã‚’å¾—ã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ãŒç¢ºä¿ã•ã‚Œã‚‹ã€‚ï¼‰
â—
(However, the rest of this algorithm runs before the pageshow event fires. This ensures that navigation.entries() and navigation.currentEntry will have correctly-updated values during any pageshow event handlers.)
</p>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`åŒä¸€-æ–‡æ›¸~naviç”¨ã«~navi~API~entryç¾¤ã‚’æ›´æ–°ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`Navigation$I %~navi,
`~sessionå±¥æ­´~entry$ %è¡Œå…ˆ~å±¥æ­´~entry,
`NavigationType$I %~naviç¨®åˆ¥
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To update the navigation API entries for a same-document navigation given a Navigation navigation, a session history entry destinationSHE, and a NavigationType navigationType:
</p>
<ol>
	<li>
~IFï¼»
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET
â—
If navigation has entries and events disabled, then return.
</li>
	<li>
%æ—§-ç¾åœ¨ã®~NHE ~LET `~naviã®ç¾åœ¨ã®~entry$( %~navi )
â—
Let oldCurrentNHE be the current entry of navigation.
</li>
	<li>
%å‡¦åˆ†ã•ã‚Œã‚‹~NHEç¾¤ ~LET æ–°ãŸãª`~list$
â—
Let disposedNHEs be a new empty list.
</li>
	<li>
<p>
~IFï¼»
%~naviç¨®åˆ¥ ~EQ `traverse$l
ï¼½ï¼š
â—
If navigationType is "traverse", then:
</p>
		<ol>
			<li>
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~SET `~navi~API~entry~indexã‚’å–å¾—ã™ã‚‹$( %~navi, %è¡Œå…ˆ~å±¥æ­´~entry )
â—
Set navigation's current entry index to the result of getting the navigation API entry index of destinationSHE within navigation.
</li>
			<li>
~Assertï¼š
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~NEQ âˆ’1
â—
Assert: navigation's current entry index is not âˆ’1.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®~algoã¯ã€
åŒä¸€-æ–‡æ›¸ã¸ã®è¾¿ã‚Šç”¨ã«é™ã‚Š~callã•ã‚Œã‚‹ã€‚
éåŒä¸€-æ–‡æ›¸ã¸ã®è¾¿ã‚Šã¯ã€
ä»£ã‚ã‚Šã«ï¼Œæ¬¡ã®ã„ãšã‚Œã‹ã‚’~callã™ã‚‹ã“ã¨ã«ãªã‚‹
â‡’ï¼ƒ
`æ–°ãŸãªæ–‡æ›¸~ç”¨ã«~navi~API~entryç¾¤ã‚’åˆæœŸåŒ–ã™ã‚‹$ï¼
`å†~ä½œå‹•åŒ–~ç”¨ã«~navi~API~entryç¾¤ã‚’æ›´æ–°ã™ã‚‹$
â—
This algorithm is only called for same-document traversals. Cross-document traversals will instead call either initialize the navigation API entries for a new document or update the navigation API entries for reactivation.
</p>
	</li>
	<li>
<p>
~ELIFï¼»
%~naviç¨®åˆ¥ ~EQ `push$l
ï¼½ï¼š
â—
Otherwise, if navigationType is "push", then:
</p>
		<ol>
			<li>
%~navi ã®`ç¾åœ¨ã®~entry~index$nV ~INCBY 1
â—
Set navigation's current entry index to navigation's current entry index + 1.
</li>
			<li>
%~index ~LET %~navi ã®`ç¾åœ¨ã®~entry~index$nV
â—
Let i be navigation's current entry index.
</li>
			<li>
<p>
~WHILEï¼»
%~index ~LT %~navi ã®`~entry~list$nVã®`~size$
ï¼½ï¼š
â—
While i &lt; navigation's entry list's size:
</p>
				<ol>
					<li>
%å‡¦åˆ†ã•ã‚Œã‚‹~NHEç¾¤ ã« %~navi ã®`~entry~list$nV[ %~index ] ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append navigation's entry list[i] to disposedNHEs.
</li>
					<li>
%~index ~INCBY 1
â—
Set i to i + 1.
</li>
				</ol>
			</li>
			<li>
%å‡¦åˆ†ã•ã‚Œã‚‹~NHEç¾¤ ã‚’æˆã™
~EACH( %~item )
ã«å¯¾ã—
â‡’
%~navi ã®`~entry~list$nV ã‹ã‚‰ %~item ã‚’`é™¤å»ã™ã‚‹$
â—
Remove all items in disposedNHEs from navigation's entry list.
</li>
		</ol>
	</li>
	<li>
~ELIFï¼»
%~naviç¨®åˆ¥ ~EQ `replace$l
ï¼½
â‡’
%å‡¦åˆ†ã•ã‚Œã‚‹~NHEç¾¤ ã« %æ—§-ç¾åœ¨ã®~NHE ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Otherwise, if navigationType is "replace", then:
â€¢ Append oldCurrentNHE to disposedNHEs.
</li>
	<li>
<p>
~IFï¼»
%~naviç¨®åˆ¥ ~IN { `push$l, `replace$l }
ï¼½ï¼š
â—
If navigationType is "push" or "replace", then:
</p>
		<ol>
			<li>
%æ–°-~NHE ~LET `æ–°ãŸãª~obj$( `NavigationHistoryEntry$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let newNHE be a new NavigationHistoryEntry created in the relevant realm of navigation.
</li>
			<li>
%æ–°-~NHE ã®`~sessionå±¥æ­´~entry$nhe ~SET %è¡Œå…ˆ~å±¥æ­´~entry
â—
Set newNHE's session history entry to destinationSHE.
</li>
			<li>
%~navi ã®`~entry~list$nV[ %~navi ã®`ç¾åœ¨ã®~entry~index$nV ] ~SET %æ–°-~NHE
â—
Set navigation's entry list[navigation's current entry index] to newNHE.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~NEQ ~NULL
ï¼½
â‡’
`~commitå…ˆ~entryã«ã¤ã„ã¦é€šçŸ¥ã™ã‚‹$( %~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$, `~naviã®ç¾åœ¨ã®~entry$( %~navi ) )
â—
If navigation's ongoing API method tracker is non-null, then notify about the committed-to entry given navigation's ongoing API method tracker and the current entry of navigation.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ï¼»
`dispose$et ï¼ `currententrychange$et
ï¼½~eventã‚’ç™ºç«ã™ã‚‹å‰ã«è¡Œã†ã“ã¨ãŒé‡è¦ã§ã‚ã‚‹
â€” ~event~handlerã¯ã€ï¼»
åˆ¥ã®~naviã‚’é–‹å§‹ã™ã‚‹ï¼Œã‚ã‚‹ã„ã¯
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ã®å€¤ã‚’å¤‰æ›´ã™ã‚‹
ï¼½ã“ã¨ã‚‚ã§ãã‚‹ã®ã§ã€‚
â—
It is important to do this before firing the dispose or currententrychange events, since event handlers could start another navigation, or otherwise change the value of navigation's ongoing API method tracker.
</p>
	</li>
	<li>
<p>
`~scriptã‚’èµ°ã‚‰ã™ãŸã‚ã«æº–å‚™ã™ã‚‹$( %~navi ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$ )
â—
Prepare to run script given navigation's relevant settings object.
</p>

<p class="note">æ³¨è¨˜ï¼š
ãªãœã“ã‚Œã‚’è¡Œã†ã‹ç†è§£ã™ã‚‹ã«ã¯ã€
`ä»–ã®~navi~API~eventç”¨ã®è«–ç‚¹ï¼ #note-suppress-microtasks-during-navigation-events$ã‚’è¦‹ã‚ˆã€‚
â—
See the discussion for other navigation API events to understand why we do this.
</p>
	</li>
	<li>
`~eventã‚’ç™ºç«ã™ã‚‹$( %~navi, `currententrychange$et, `NavigationCurrentEntryChangeEvent$I )
â€” æ¬¡ã®ã‚ˆã†ã«åˆæœŸåŒ–ã—ã¦
â‡’ï¼ƒ
`~navigationType0$m å±æ€§ ~SET %~naviç¨®åˆ¥,
`from$m å±æ€§ ~SET %æ—§-ç¾åœ¨ã®~NHE
â—
Fire an event named currententrychange at navigation using NavigationCurrentEntryChangeEvent, with its navigationType attribute initialized to navigationType and its from initialized to oldCurrentNHE.
</li>
	<li>
%å‡¦åˆ†ã•ã‚Œã‚‹~NHEç¾¤ ã‚’æˆã™
~EACH( %å‡¦åˆ†ã•ã‚Œã‚‹~NHE )
ã«å¯¾ã—
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %å‡¦åˆ†ã•ã‚Œã‚‹~NHE, `dispose$et )
â—
For each disposedNHE of disposedNHEs:
â€¢ Fire an event named dispose at disposedNHE.
</li>
	<li>
`èµ°ã‚‰ã›ãŸ~scriptã‚’ç‰‡ä»˜ã‘ã‚‹$( %~navi ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$ )
â—
Clean up after running script given navigation's relevant settings object.
</li>
</ol>
</div>

<p class="XXX">
åŒä¸€-æ–‡æ›¸ã¸ã®~naviã¯ï¼Œå®Ÿè£…ã«ãŠã„ã¦ã¯ã€
~sessionå±¥æ­´~entry~listã«~fall-backã™ã‚‹ã€ï¼falling off the back ofã€‘ã“ã¨ã«ã‚ˆã‚Šï¼Œ
`~sessionå±¥æ­´~entry$ã‚’å‡¦åˆ†ã•ã›ã‚Œã‚‹ã€‚
ä¸Šã®~algoï¼ˆãŠã‚ˆã³ã“ã®æ¨™æº–ã‚’æˆã™ä»–ã®éƒ¨åˆ†ï¼‰ã¯ã€
ã¾ã ï¼Œã“ã‚Œã‚’å–æ‰±ã£ã¦ã„ãªã„ã€‚
ãã®ã‚ˆã†ãªäº‹ä¾‹ã«ãŠã„ã¦æ­£ã—ã„æŒ™å‹•ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã¤ã„ã¦ã¯ã€
`èª²é¡Œ #8620ï¼ ~HTMLissue/8620$
ã«ã¦ï¼Œé€²æ—ã‚’è¿½è·¡ã§ãã‚‹ã€‚
â—
In implementations, same-document navigations can cause session history entries to be disposed by falling off the back of the session history entry list. This is not yet handled by the above algorithm (or by any other part of this standard). See issue #8620 to track progress on defining the correct behavior in such cases.
</p>

				</section>
				<section id="the-navigationhistoryentry-interface">
<h5 title="The NavigationHistoryEntry interface">7.2.6.5. `NavigationHistoryEntry^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `NavigationHistoryEntry@I : `EventTarget$I {
  readonly attribute USVString? `url$mH;
  readonly attribute DOMString `key$mH;
  readonly attribute DOMString `id$mH;
  readonly attribute long long `index$mH;
  readonly attribute boolean `sameDocument$mH;

  any `getState$mH();

  attribute `EventHandler$I `ondispose$mH;
};
</pre>

  <dl class="domintro">
	<dt>%entry.`url$mH</dt>
	<dd>
ã“ã®`~naviå±¥æ­´~entry$ã®~URLã€‚
â—
The URL of this navigation history entry.
</dd>
	<dd>
ã“ã‚ŒãŒ ~NULL ã‚’è¿”ã—å¾—ã‚‹ã®ã¯ã€
%entry ã«å¯¾å¿œã™ã‚‹`æ–‡æ›¸$ %æ–‡æ›¸ ãŒï¼»
ç¾åœ¨ã®~entryã«å¯¾å¿œã™ã‚‹`æ–‡æ›¸$ã¨ã¯ç•°ãªã‚‹
ï¼ˆã™ãªã‚ã¡ %entry ã® `sameDocument$mH ~EQ ~F ï¼‰
ï¼½ã‹ã¤ï¼»
`~referreræ–½ç­–$ ~IN { `no-referrer^l, `origin^l } ã‚’ä¼´ã£ã¦~fetchã•ã‚ŒãŸ
ï¼½å ´åˆã§ã‚ã‚‹
â€” ãã‚Œã¯ã€
%æ–‡æ›¸ ã€ï¼the Document in questionã€‘ãŒ
è‡ªèº«ã®~URLã‚’
â€” åŒä¸€-ç”Ÿæˆå…ƒã«å±ã™ã‚‹ä»–ã®~pageã‹ã‚‰ã‚‚ â€”
éš ã—ã¦ã„ã‚‹ã“ã¨ã‚’æŒ‡ç¤ºã™ã‚‹ã®ã§ã€‚
â—
This can return null if the entry corresponds to a different Document than the current one (i.e., if sameDocument is false), and that Document was fetched with a referrer policy of "no-referrer" or "origin", since that indicates the Document in question is hiding its URL even from other same-origin pages.
</dd>

	<dt>%entry.`key$mH</dt>
	<dd>
ï¼»
ã“ã®`~naviå±¥æ­´~entry$ãŒ`~naviå±¥æ­´~entry~list$å†…ã§å ã‚ã‚‹å ´æ‰€
ï¼½ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ï¼»
~UAãŒç”Ÿæˆã—ãŸ~randomãª~UUIDæ–‡å­—åˆ—
ï¼½ã€‚
ã“ã®å€¤ã¯ã€
ä»–ã® `NavigationHistoryEntry$I ~instanceã®ã†ã¡ï¼»
`replace$l ~naviã«å› ã‚Šï¼Œã“ã®~entryã‚’ç½®æ›ã™ã‚‹ã‚‚ã®
ï¼½ã«ã‚ˆã‚Šå†åˆ©ç”¨ã•ã‚Œï¼Œ
å†èª­è¾¼ã¿ã‚„~sessionå¾©æ—§-ã‚’çµŒã¦ã‚‚ç”Ÿæ®‹ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
A user agent-generated random UUID string representing this navigation history entry's place in the navigation history list. This value will be reused by other NavigationHistoryEntry instances that replace this one due to "replace" navigations, and will survive reloads and session restores.
</dd>
	<dd>
ã“ã‚Œã¯ã€
`navigation.traverseTo()$c ã‚’åˆ©ç”¨ã—ã¦ï¼»
`~naviå±¥æ­´~entry~list$å†…ã§ï¼Œã“ã®~entryã¸æˆ»ã‚‹ã‚ˆã†~navigateã™ã‚‹
ï¼½ãŸã‚ã«æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
This is useful for navigating back to this entry in the navigation history list, using navigation.traverseTo(key).
</dd>

	<dt>%entry.`id$mH</dt>
	<dd>
ã“ã®ã€ï¼specificã€‘`~naviå±¥æ­´~entry$ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ï¼»
~UAãŒç”Ÿæˆã—ãŸ~randomãª~UUIDæ–‡å­—åˆ—
ï¼½ã€‚
ã“ã®å€¤ã¯ã€
ä»–ã® `NavigationHistoryEntry$I ~instanceã«ã‚ˆã‚Š`å†åˆ©ç”¨ã•ã‚Œãªã„^emã€‚
ã“ã®å€¤ã¯ã€ï¼»
å†èª­è¾¼ã¿ã‚„~sessionå¾©æ—§-
ï¼½ã‚’çµŒã¦ã‚‚ç”Ÿæ®‹ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
A user agent-generated random UUID string representing this specific navigation history entry. This value will not be reused by other NavigationHistoryEntry instances. This value will survive reloads and session restores.
</dd>
	<dd>
ã“ã‚Œã¯ã€ï¼»
ä»–ã®~storage~APIã‚’åˆ©ç”¨ã—ã¦ï¼Œã“ã®`~naviå±¥æ­´~entry$ã«~dataã‚’çµä»˜ã‘ã‚‹
ï¼½ãŸã‚ã«æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
This is useful for associating data with this navigation history entry using other storage APIs.
</dd>

	<dt>%entry.`index$mH</dt>
	<dd>
`navigation.entries()$c ã®ä¸­ã§ã®ï¼Œã“ã®`~naviå±¥æ­´~entry$ã€ï¼ï¼Š`NavigationHistoryEntry$I ã€‘ã®~indexã€‚
ã“ã®~entryãŒ`~naviå±¥æ­´~entry~list$å†…ã«ç„¡ã„å ´åˆã€
âˆ’1 ã«ãªã‚‹ã€‚
â—
The index of this NavigationHistoryEntry within navigation.entries(), or âˆ’1 if the entry is not in the navigation history entry list.
</dd>

	<dt>%entry.`sameDocument$mH</dt>
	<dd>
ã“ã®`~naviå±¥æ­´~entry$ãŒï¼Œç¾åœ¨ã®`æ–‡æ›¸$ã¨åŒã˜æ–‡æ›¸~ç”¨ã®ã‚‚ã®ã‹å¦ã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ä¾‹ãˆã°ã€
ã“ã®~entryãŒï¼»
ç´ ç‰‡ã¸ã®~naviï¼å˜-~page~appã«ãŠã‘ã‚‹~navi
ï¼½ã‚’è¡¨ç¾ã™ã‚‹ã¨ãã¯ï¼Œ ~T ã«ãªã‚‹ã€‚
â—
Indicates whether or not this navigation history entry is for the same Document as the current one, or not. This will be true, for example, when the entry represents a fragment navigation or single-page app navigation.
</dd>

	<dt>%entry.`getState$mH()</dt>
	<dd>
ã“ã®~entryå†…ã«æ ¼ç´ã•ã‚ŒãŸçŠ¶æ…‹ã®`é€†ç›´åˆ—åŒ–$ã‚’è¿”ã™
â€” ãã‚Œã¯ã€ï¼»
`navigation.navigate()$c ï¼
`navigation.updateCurrentEntry()$c
ï¼½ã‚’åˆ©ç”¨ã—ã¦~entryã«è¿½åŠ ã•ã‚ŒãŸã‚‚ã®ã§ã‚ã‚‹ã€‚
ã“ã®çŠ¶æ…‹ã¯ã€
å†èª­è¾¼ã¿ã‚„~sessionå¾©æ—§-ã‚’çµŒã¦ã‚‚ç”Ÿæ®‹ã‚‹ã€‚
â—
Returns the deserialization of the state stored in this entry, which was added to the entry using navigation.navigate() or navigation.updateCurrentEntry(). This state survives reloads and session restores.
</dd>
	<dd>
ä¸€èˆ¬ã«ï¼ŒçŠ¶æ…‹~å€¤ãŒ~primitiveã§ãªã„å ´åˆã€ï¼»
`entry.getState() !== entry.getState()^c
ï¼½ãŒæº€ãŸã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„
â€” å„~å›ã”ã¨ã«æ–°è¦ãªé€†ç›´åˆ—åŒ–ãŒè¿”ã•ã‚Œã‚‹ã®ã§ã€‚
â—
Note that in general, unless the state value is a primitive, entry.getState() !== entry.getState(), since a fresh deserialization is returned each time.
</dd>
	<dd>
ã“ã®çŠ¶æ…‹ã¯ã€
å¤å…¸çš„ãªå±¥æ­´~APIã® `history.stateï¼ ~WINDOW#dom-history-state$c ã¨ã¯ç„¡é–¢ä¿‚ã§ã‚ã‚‹ã€‚
â—
This state is unrelated to the classic history API's history.state.
</dd>
</dl>

<p>
å„ `NavigationHistoryEntry$I ã«ã¯ã€
`~sessionå±¥æ­´~entry@nhe
â€” ã‚ã‚‹`~sessionå±¥æ­´~entry$ â€”
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ã€‚
ã€ â€œ~naviå±¥æ­´~entryâ€ ã¨ã‚‚ç§°ã•ã‚Œã‚‹ã€‚ã€‘
â—
Each NavigationHistoryEntry has an associated session history entry, which is a session history entry.
</p>

<p>
æ‰€ä¸ã® `NavigationHistoryEntry$I %~NHE ã«å¯¾ã—ï¼š
â—
â†“</p>
<ul>
	<li class="algo">
<p>
%~NHE ã®
`~key@nE
ã¯ã€
æ¬¡ã®çµæœã‚’è¿”ã™ï¼š
â—
The key of a NavigationHistoryEntry nhe is given by the return value of the following algorithm:
</p>
		<ol>
			<li>
~IFï¼»
%~NHE ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If nhe's relevant global object's associated Document is not fully active, then return the empty string.
</li>
			<li>
~RET %~NHE ã®`~sessionå±¥æ­´~entry$nheã®`~navi~API~key$shE
â—
Return nhe's session history entry's navigation API key.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%~NHE ã®
`~ID@nE
ã¯ã€
æ¬¡ã®çµæœã‚’è¿”ã™ï¼š
â—
The ID of a NavigationHistoryEntry nhe is given by the return value of the following algorithm:
</p>
		<ol>
			<li>
~IFï¼»
%~NHE ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If nhe's relevant global object's associated Document is not fully active, then return the empty string.
</li>
			<li>
~RET %~NHE ã®`~sessionå±¥æ­´~entry$nheã®`~navi~API~ID$shE
â—
Return nhe's session history entry's navigation API ID.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%~NHE ã®
`~index@nE
ã¯ã€
æ¬¡ã®çµæœã‚’è¿”ã™ï¼š
â—
The index of a NavigationHistoryEntry nhe is given by the return value of the following algorithm:
</p>
		<ol>
			<li>
~IFï¼»
%~NHE ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET âˆ’1
â—
If nhe's relevant global object's associated Document is not fully active, then return âˆ’1.
</li>
			<li>
~RET `~navi~API~entry~indexã‚’å–å¾—ã™ã‚‹$( %~NHE ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã®`~navi~API$, %~NHE ã®`~sessionå±¥æ­´~entry$nhe )
â—
Return the result of getting the navigation API entry index of this's session history entry within this's relevant global object's navigation API.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
<p>
`url@mH
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The url getter steps are:
</p>
<ol>
	<li>
%æ–‡æ›¸ ~LET ã‚³ãƒ¬ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be this's relevant global object's associated Document.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If document is not fully active, then return the empty string.
</li>
	<li>
%å±¥æ­´~entry ~LET ã‚³ãƒ¬ã®`~sessionå±¥æ­´~entry$nhe
â—
Let she be this's session history entry.
</li>
	<li>
~IFï¼»
%å±¥æ­´~entry ã®`æ–‡æ›¸$shE ~NEQ %æ–‡æ›¸
ï¼½~ANDï¼»
%å±¥æ­´~entry ã®`æ–‡æ›¸~çŠ¶æ…‹$shEã®`è¦è«‹~referreræ–½ç­–$dS ~IN { `no-referrer^l, `origin^l }
ï¼½
â‡’
~RET ~NULL
â—
If she's document does not equal document, and she's document state's request referrer policy is "no-referrer" or "origin", then return null.
</li>
	<li>
~RET `~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( %å±¥æ­´~entry ã®`~URL$shE )
â—
Return she's URL, serialized.
</li>
</ol>
</div>

<div class="algo">
`key@mH
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~key$nE
â—
The key getter steps are to return this's key.
</div>

<div class="algo">
`id@mH
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~ID$nE
â—
The id getter steps are to return this's ID.
</div>

<div class="algo">
`index@mH
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~index$nE
â—
The index getter steps are to return this's index.
</div>

<div class="algo">
<p>
`sameDocument@mH
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The sameDocument getter steps are:
</p>
<ol>
	<li>
%æ–‡æ›¸ ~LET ã‚³ãƒ¬ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be this's relevant global object's associated Document.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET ~F
â—
If document is not fully active, then return false.
</li>
	<li>
~RET ~ISï¼»
ã‚³ãƒ¬ã®`~sessionå±¥æ­´~entry$nheã®`æ–‡æ›¸$shE ~EQ %æ–‡æ›¸
ï¼½
â—
Return true if this's session history entry's document equals document, and false otherwise.
</li>
</ol>
</div>

<div class="algo">
<p>
`getState()@mH
~methodæ‰‹ç¶šãã¯ï¼š
â—
The getState() method steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET `undefined^jv
â—
If this's relevant global object's associated Document is not fully active, then return undefined.
</li>
	<li>
<p>
~RET `StructuredDeserialize$jA( ã‚³ãƒ¬ã®`~sessionå±¥æ­´~entry$nheã®`~navi~APIçŠ¶æ…‹$shE )
ã€ï¼Rethrow any exceptionsã€‘
â—
Return StructuredDeserialize(this's session history entry's navigation API state). Rethrow any exceptions.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
ç†è«–~ä¸Šã¯ä¾‹å¤–ã‚’æŠ•å‡ºã—å¾—ã‚‹
â€” ååˆ†ãª~memoryãŒå¯ç”¨ã§ãªã„ã¨ãã«å·¨å¤§ãª `ArrayBuffer$I ã‚’é€†ç›´åˆ—åŒ–ã—ã‚ˆã†ã¨è©¦ã¿ãŸå ´åˆã«ã€‚
â—
This can in theory throw an exception, if attempting to deserialize a large ArrayBuffer when not enough memory is available.
</p>
	</li>
</ol>
</div>

<p>
`NavigationHistoryEntry$I ~interfaceã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã™ã¹ã¦ã®~objã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚’`~event~handler$
ï¼ˆãŠã‚ˆã³ï¼Œå¯¾å¿œã—ã¦ã„ã‚‹`~event~handler~eventå‹$ï¼‰
ã‚’`~event~handler~IDLå±æ€§$ã¨ã—ã¦~supportã™ã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ï¼š
â—
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the NavigationHistoryEntry interface:
</p>

<table><thead>
<tr><th>
`~event~handler$
â—
Event handler
<th>
`~event~handler~eventå‹$
â—
Event handler event type
<tbody>

<tr><td>`ondispose@mH
<td>`dispose$et
</table>

				</section>
				<section id="the-history-entry-list">
<h5 title="The history entry list">7.2.6.6. å±¥æ­´~entry~list</h5>

<dl class="domintro">
	<dt>%entries = `navigation$m.`entries()$mN</dt>
	<dd>
ç¾åœ¨ã®`~naviå±¥æ­´~entry~list$ã‚’è¡¨ç¾ã™ã‚‹ï¼»
`NavigationHistoryEntry$I ~instanceãŸã¡ãŒæˆã™é…åˆ—
ï¼½ã‚’è¿”ã™ã€‚
ã™ãªã‚ã¡ã€
ã“ã®`~navigable$ç”¨ã®`~sessionå±¥æ­´~entry$ã®ã†ã¡ï¼Œï¼»
`ç¾åœ¨ã®~sessionå±¥æ­´~entry$navã¨é€£ç¶šçš„ã«`åŒä¸€-ç”Ÿæˆå…ƒ$ã§ã‚ã‚‹ã‚‚ã®
ï¼½ã™ã¹ã¦ã‹ã‚‰ãªã‚‹ã€‚
â—
Returns an array of NavigationHistoryEntry instances represent the current navigation history entry list, i.e., all session history entries for this navigable that are same origin and contiguous to the current session history entry.
</dd>

	<dt>`navigation$m.`currentEntry$mN</dt>
	<dd>
`ç¾åœ¨ã®~sessionå±¥æ­´~entry$navã«å¯¾å¿œã—ã¦ã„ã‚‹ `NavigationHistoryEntry$I ã‚’è¿”ã™ã€‚
â—
Returns the NavigationHistoryEntry corresponding to the current session history entry.
</dd>

	<dt>`navigation$m.`updateCurrentEntry$mN({ `state$mbC })</dt>
	<dd>
`ç¾åœ¨ã®~sessionå±¥æ­´~entry$navã®`~navi~APIçŠ¶æ…‹$shEã‚’æ›´æ–°ã™ã‚‹
â€” `navigation.reload()$c ãŒè¡Œã†æ§˜ãª~naviã‚’é‚è¡Œã™ã‚‹ã“ã¨ãªãã€‚
â—
Updates the navigation API state of the current session history entry, without performing a navigation like navigation.reload() would do.
</dd>
	<dd>
ã“ã®~methodã®åˆ©ç”¨ãŒæœ€ã‚‚é©ã™ã‚‹ã®ã¯ã€
~pageã«å¯¾ã—ã™ã§ã«èµ·ããŸæ›´æ–°ã‚’æ•æ‰ã—ã¦ï¼Œ
~navi~APIçŠ¶æ…‹ã®ä¸­ã¸åæ˜ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã§ã‚ã‚‹ã€‚
çŠ¶æ…‹~æ›´æ–°ãŒ~pageæ›´æ–°ã‚’é§†å‹•ã™ã‚‹ã“ã¨ãŒæ„å‘³ã•ã‚Œã‚‹äº‹ä¾‹ã«ã¯ã€
ä»£ã‚ã‚Šã«ï¼»
`navigation.navigate()$c ï¼ `navigation.reload()$c
ï¼½ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨
â€” ã“ã‚Œã‚‰ã¯ã€
`navigate$et ~eventã‚’èª˜ç™ºã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
This method is best used to capture updates to the page that have already happened, and need to be reflected into the navigation API state. For cases where the state update is meant to drive a page update, instead use navigation.navigate() or navigation.reload(), which will trigger a navigate event.
</dd>

	<dt>`navigation$m.`canGoBack$mN</dt>
	<dd>
`ç¾åœ¨ã®~sessionå±¥æ­´~entry$navï¼ˆã™ãªã‚ã¡ `currentEntry$mN ï¼‰ãŒï¼»
`~naviå±¥æ­´~entry~list$ï¼ˆã™ãªã‚ã¡ `entries()$mN ï¼‰å†…ã«åœ¨ã‚‹æœ€åˆã®ã‚‚ã®
ï¼½ã§ãªã„å ´åˆã€
~T ã‚’è¿”ã™ã€‚
ã“ã®ã“ã¨ã¯ã€
ã“ã®`~navigable$ç”¨ã«ï¼»
ã€ãã®`~sessionå±¥æ­´~å†…ï¼ ~HTMLnav#getting-session-history-entries$ã§ã€‘
æ¬¡ã‚’æº€ãŸã™`~sessionå±¥æ­´~entry$ãŒç›´å‰ã«åœ¨ã‚‹
ï¼½ã“ã¨ã‚’æ„å‘³ã™ã‚‹
â‡’
ãã®`æ–‡æ›¸~çŠ¶æ…‹$shEã®`ç”Ÿæˆå…ƒ$dS ~EQ`ç”Ÿæˆå…ƒ$sub ç¾åœ¨ã®`æ–‡æ›¸$ã®`ç”Ÿæˆå…ƒ$doc
â—
Returns true if the current current session history entry (i.e., currentEntry) is not the first one in the navigation history entry list (i.e., in entries()). This means that there is a previous session history entry for this navigable, and its document state's origin is same origin with the current Document's origin.
</dd>

	<dt>`navigation$m.`canGoForward$mN</dt>
	<dd>
`ç¾åœ¨ã®~sessionå±¥æ­´~entry$navï¼ˆã™ãªã‚ã¡ `currentEntry$mN ï¼‰ãŒï¼»
`~naviå±¥æ­´~entry~list$ï¼ˆã™ãªã‚ã¡ `entries()$mN ï¼‰å†…ã«ã‚ã‚‹æœ€å¾Œã®ã‚‚ã®
ï¼½ã§ãªã„å ´åˆã€
~T ã‚’è¿”ã™ã€‚
ã“ã®ã“ã¨ã¯ã€
ã“ã®`~navigable$ç”¨ã«ï¼»
ã€ãã®`~sessionå±¥æ­´~å†…ï¼ ~HTMLnav#getting-session-history-entries$ã§ã€‘
æ¬¡ã‚’æº€ãŸã™`~sessionå±¥æ­´~entry$ãŒç›´å¾Œã«åœ¨ã‚‹
ï¼½ã“ã¨ã‚’æ„å‘³ã™ã‚‹
â‡’
ãã®`æ–‡æ›¸~çŠ¶æ…‹$shEã®`ç”Ÿæˆå…ƒ$dS ~EQ`ç”Ÿæˆå…ƒ$sub ç¾åœ¨ã®`æ–‡æ›¸$ã®`ç”Ÿæˆå…ƒ$doc
â—
Returns true if the current current session history entry (i.e., currentEntry) is not the last one in the navigation history entry list (i.e., in entries()). This means that there is a next session history entry for this navigable, and its document state's origin is same origin with the current Document's origin.
</dd>
</dl>

<div class="algo">
<p>
`entries()@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The entries() method steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET æ–°ãŸãª~list
â—
If this has entries and events disabled, then return the empty list.
</li>
	<li>
<p>
~RET ã‚³ãƒ¬ã®`~entry~list$nV
â—
Return this's entry list.
</p>

<p class="note">æ³¨è¨˜ï¼š
~Web~IDLã®`é€£åˆ—~å‹~ç”¨ã®å¤‰æ›~è¦å‰‡ï¼ ~WEBIDLjs#sequence-to-es$ã‹ã‚‰ã€
ã“ã‚Œã¯ï¼Œå„~callã”ã¨ã«æ–°ãŸãª~JSé…åˆ—~objã‚’ä½œæˆã™ã‚‹ã€‚
ã™ãªã‚ã¡ï¼Œæ¬¡ãŒæº€ãŸã•ã‚Œã‚‹
â‡’
<code>navigation.entries() !== navigation.entries()</code>
â—
Recall that because of Web IDL's sequence type conversion rules, this will create a new JavaScript array object on each call. That is, navigation.entries() !== navigation.entries().
</p>
	</li>
</ol>
</div>

<div class="algo">
`currentEntry@mN
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET `~naviã®ç¾åœ¨ã®~entry$( ã‚³ãƒ¬ )
â—
The currentEntry getter steps are to return the current entry of this.
</div>

<div class="algo">
<p>
`updateCurrentEntry(options)@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The updateCurrentEntry(options) method steps are:
</p>
<ol>
	<li>
%ç¾åœ¨ã®~entry ~LET `~naviã®ç¾åœ¨ã®~entry$( ã‚³ãƒ¬ )
â—
Let current be the current entry of this.
</li>
	<li>
~IFï¼»
%ç¾åœ¨ã®~entry ~EQ ~NULL
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If current is null, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ~LET `StructuredSerializeForStorage$jA( %options[ "`state$mbC" ] )
ã€ï¼rethrowing any exceptionsã€‘
â—
Let serializedState be StructuredSerializeForStorage(options["state"]), rethrowing any exceptions.
</li>
	<li>
%ç¾åœ¨ã®~entry ã®`~sessionå±¥æ­´~entry$nheã®`~navi~APIçŠ¶æ…‹$shE ~SET %ç›´åˆ—å½¢ã®çŠ¶æ…‹
â—
Set current's session history entry's navigation API state to serializedState.
</li>
	<li>
`~eventã‚’ç™ºç«ã™ã‚‹$( ã‚³ãƒ¬, `currententrychange$et, `NavigationCurrentEntryChangeEvent$I )
â€” æ¬¡ã®ã‚ˆã†ã«åˆæœŸåŒ–ã—ã¦
â‡’ï¼ƒ
`~navigationType0$m å±æ€§ ~SET ~NULL,
`from$m å±æ€§ ~SET %ç¾åœ¨ã®~entry
â—
Fire an event named currententrychange at this using NavigationCurrentEntryChangeEvent, with its navigationType attribute initialized to null and its from initialized to current.
</li>
</ol>
</div>

<div class="algo">
<p>
`canGoBack@mN
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The canGoBack getter steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET ~F
â—
If this has entries and events disabled, then return false.
</li>
	<li>
~Assertï¼š
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~NEQ âˆ’1
â—
Assert: this's current entry index is not âˆ’1.
</li>
	<li>
~RET ~ISï¼»
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~NEQ 0
ï¼½
â—
If this's current entry index is 0, then return false.
â—
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`canGoForward@mN
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The canGoForward getter steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½
â‡’
~RET ~F
â—
If this has entries and events disabled, then return false.
</li>
	<li>
~Assertï¼š
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~NEQ âˆ’1
â—
Assert: this's current entry index is not âˆ’1.
</li>
	<li>
~RET ~ISï¼»
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~NEQ ã‚³ãƒ¬ã®`~entry~list$nVã®`~size$ ~MINUS 1
ï¼½
â—
If this's current entry index is equal to this's entry list's size âˆ’ 1, then return false.
â—
Return true.
</li>
</ol>
</div>

				</section>
				<section id="navigation-api-initiating-navigations">
<h5 title="Initiating navigations">7.2.6.7. ~naviã®èµ·å‹•-æ³•</h5>

<dl class="domintro">
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`navigate$mN(%url)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`navigate$mN(%url, %options)</dt>
	<dd>
<p>
ç¾åœ¨ã®~pageã‹ã‚‰æ‰€ä¸ã® %url ã¸`~navigateã™ã‚‹$ã€‚
%options ã¯æ¬¡ã«æŒ™ã’ã‚‹å€¤ã‚’åŒ…å«ã—å¾—ã‚‹ï¼š
â—
Navigates the current page to the given url. options can contain the following values:
</p>
		<ul>
			<li>
`history$mbN
â‡’
`replace$hH ã«è¨­å®šã™ã‚Œã°ã€
~pushã™ã‚‹ä»£ã‚ã‚Šã«ï¼Œç¾åœ¨ã®~sessionå±¥æ­´~entryã‚’æ–°ãŸãªã‚‚ã®ã«ç½®æ›ã§ãã‚‹ã€‚
â—
history can be set to "replace" to replace the current session history entry, instead of pushing a new one.
</li>
			<li>
`info$mbN
â‡’
ä»»æ„ã®å€¤ã‚’è¨­å®šã§ãã‚‹
â€” ãã‚Œã¯ã€
å¯¾å¿œã—ã¦ã„ã‚‹ `NavigateEvent$I ã® `info$mE ~propã‚’æ‹¡å……ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</li>
			<li>
`state$mbN
â‡’
`ç›´åˆ—åŒ–-å¯èƒ½$ãªä»»æ„ã®å€¤ã‚’è¨­å®šã§ãã‚‹
â€” ãã‚Œã¯ã€
åŒä¸€-æ–‡æ›¸ã¸ã®~naviç”¨ã«ã¯ï¼Œå½“ã®~naviãŒå®Œäº†ã—ãŸã¨ãï¼Œ
`navigation.currentEntry.getState()$c
ã«ã‚ˆã‚Šæ¤œç´¢å–å¾—ã•ã‚Œã‚‹çŠ¶æ…‹ã‚’æ‹¡å……ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ï¼ˆçµæœãŒéåŒä¸€-æ–‡æ›¸ã¸ã®~naviã«ãªã‚‹å ´åˆã€
ç„¡è¦–ã•ã‚Œã‚‹ã€‚ï¼‰
â—
state can be set to any serializable value; it will populate the state retrieved by navigation.currentEntry.getState() once the navigation completes, for same-document navigations. (It will be ignored for navigations that end up cross-document.)
</li>
		</ul>
<p>
æ—¢å®šã§ã¯ã€
ã“ã‚Œã¯ï¼Œå…¨éƒ¨çš„ãª~naviã‚’é‚è¡Œã™ã‚‹ã“ã¨ã«ãªã‚‹
ï¼ˆã™ãªã‚ã¡ã€
æ‰€ä¸ã®~URLãŒç¾åœ¨ã®~URLã¨`ç´ ç‰‡$urlã«é™ã‚Šç›¸é•ã™ã‚‹å ´åˆã‚’é™¤ãï¼Œ
éåŒä¸€-æ–‡æ›¸ã¸ã®~naviã«ãªã‚‹ï¼‰ã€‚
`intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ~methodã‚’åˆ©ç”¨ã™ã‚Œã°ã€
ãã‚Œã‚’åŒä¸€-æ–‡æ›¸ã¸ã®~naviã«å¤‰æ›ã§ãã‚‹ã€‚
â—
By default this will perform a full navigation (i.e., a cross-document navigation, unless the given URL differs only in a fragment from the current one). The navigateEvent.intercept() method can be used to convert it into a same-document navigation.
</p>
	</dd>
	<dd>
<p>
è¿”ã•ã‚Œã‚‹~promiseãŸã¡ã¯ã€
æ¬¡ã«å¾“ã£ã¦æŒ™å‹•ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
The returned promises will behave as follows:
</p>
		<ul>
			<li>
~naviãŒä¸­æ­¢ã•ã‚ŒãŸå ´åˆ
â‡’
ã©ã¡ã‚‰ã®~promiseã‚‚ `AbortError$E ä¾‹å¤–ã§å´ä¸‹ã•ã‚Œã‚‹ã€‚
â—
For navigations that get aborted, both promises will reject with an "AbortError" DOMException.
</li>
			<li>
<p>
åŒä¸€-æ–‡æ›¸ã¸ã®~naviã«ãªã‚‹å ´åˆï¼š
â—
For same-document navigationsï¼¼
</p>
				<ul>
					<li>
<p>
å½“ã®~naviã¯ `intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ~methodã‚’åˆ©ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸå ´åˆï¼š
â—
created by using the navigateEvent.intercept() method,ï¼¼
</p>
						<ul>
							<li>
`committed$mb ã¯ã€
~navi~commitãŸã¡ã®å¾Œã«å……è¶³ã•ã‚Œã‚‹ã€‚
â—
committed will fulfill after the navigation commits,ï¼¼
</li>
							<li>
`finished$mb ã¯ã€
`~navi~handler~promise$ãŸã¡ã€ï¼promsiesã€‘ã«å‰‡ã£ã¦ï¼Œå……è¶³ã•ã‚Œã‚‹ã‹å´ä¸‹ã•ã‚Œã‚‹ã€‚
â—
and finished will fulfill or reject according to any promsies returned by handlers passed to intercept().
</li>
						</ul>
					</li>
					<li>
ä»–ã®å ´åˆï¼ˆä¾‹ï¼šæ¨ªå–ã•ã‚Œãªã„`ç´ ç‰‡ã¸ã®~navi$ï¼‰
â‡’
ã©ã¡ã‚‰ã®~promiseã‚‚å³æ™‚ã«å……è¶³ã•ã‚Œã‚‹ã€‚
â—
For other same-document navigations (e.g., non-intercepted fragment navigations), both promises will fulfill immediately.
</li>
				</ul>
			</li>
			<li>
<p>
éåŒä¸€-æ–‡æ›¸ã¸ã®~naviã®å ´åˆ
â‡’
ã©ã¡ã‚‰ã®~promiseã‚‚ï¼Œæ±ºã—ã¦æ±ºç€ã—ãªã„ã€‚
</p>

<p>
ã“ã‚Œã«ã¯ã€
~naviã®çµæœï¼Œ~serverã‹ã‚‰æ¬¡ã®ã„ãšã‚Œã‹ãŒè¿”ã•ã‚ŒãŸå ´åˆã‚‚å«ã¾ã‚Œã‚‹ï¼š
</p>
				<ul>
					<li>
`çŠ¶æ…‹s$rs ~IN { `204^hst, `205^hst }
</li>
					<li>
å€¤ `attachment^bl ã‚’ä¼´ã† `Content-Disposition$h ~header
ï¼ˆã—ãŸãŒã£ã¦ã€
å®Ÿéš›ã«ã¯~navigateã—ãªã„ï¼‰
</li>
				</ul>

â—
For cross-document navigations, or navigations that result in 204 or 205 statuses or `Content-Disposition: attachment` header fields from the server (and thus do not actually navigate), both promises will never settle.
</li>
		</ul>
<p>
ã©ã®äº‹ä¾‹ã«ãŠã„ã¦ã‚‚ã€
è¿”ã•ã‚ŒãŸ~promiseãŒå……è¶³ã•ã‚Œã‚‹ã¨ãã¯ï¼Œ
ãã®~navigateå…ˆã§ã‚ã£ãŸ `NavigationHistoryEntry$I ã§è§£æ±ºã•ã‚Œã‚‹ã€‚
â—
In all cases, when the returned promises fulfill, it will be with the NavigationHistoryEntry that was navigated to.
</p>
	</dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`reload$mN(%options)</dt>
	<dd>
ç¾åœ¨ã®~pageã‚’`èª­è¾¼ç›´ã™ï¼ ~HTMLnav#reload$ã€‚
%options ã¯ï¼»
`info$mbN ï¼ `state$mbR
ï¼½ã‚’åŒ…å«ã—å¾—ã‚‹
â€” ã“ã‚Œã‚‰ã¯ã€
ä¸Šã«è¿°ã¹ãŸã¨ãŠã‚Šã«æŒ™å‹•ã™ã‚‹ã€‚
â—
Reloads the current page. options can contain info and state, which behave as described above.
</dd>
	<dd>
ç¾åœ¨ã®~pageã«å¯¾ã—ï¼Œ~networkã¾ãŸã¯~cacheã‹ã‚‰èª­è¾¼ç›´ã™ã¨ãã¯ã€
`intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ~methodã‚’åˆ©ç”¨ã—ã¦ï¼Œ
æ—¢å®šã®æŒ™å‹•ã‚’ä¸Šæ›¸ãã§ãã‚‹ã€‚
ãã†ã™ã‚‹ã“ã¨ã¯ã€
æ¬¡ã‚’æ„å‘³ã™ã‚‹
â‡’
ã“ã®~callãŒè¡Œã†ã®ã¯ã€
çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹ã‹ï¼Œé©åˆ‡ãª `info$mbN ã‚’ä»–ã¸æ¸¡ã™ã“ã¨ã«é™ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã«åŠ ãˆï¼Œ `navigate$et ~eventç”¨ã®~handlerã¯ã€
ä½•ã§ã‚ã‚Œã€ï¼whaterã€‘ãã‚Œã«è¦‹åˆã†å‹•ä½œã‚’é‚è¡Œã™ã‚‹ã€‚
â—
The default behavior of performing a from-network-or-cache reload of the current page can be overriden by the using the navigateEvent.intercept() method. Doing so will mean this call only updates state or passes along the appropriate info, plus performing whater actions the navigate event handlers see fit to carry out.
</dd>
	<dd>
<p>
è¿”ã•ã‚Œã‚‹~promiseãŸã¡ã¯ã€
æ¬¡ã«å¾“ã£ã¦æŒ™å‹•ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
The returned promises will behave as follows:
</p>
		<ul>
			<li>
<p>
å½“ã®å†èª­è¾¼ã¿ãŒ `intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ~methodã‚’åˆ©ç”¨ã—ã¦æ¨ªå–ã•ã‚ŒãŸå ´åˆï¼š
â—
If the reload is intercepted by using the navigateEvent.intercept() method,ï¼¼
</p>
				<ul>
					<li>
`committed$mb ã¯ã€
~navi~commitãŸã¡ã®å¾Œã«å……è¶³ã•ã‚Œã‚‹ã€‚
â—
committed will fulfill after the navigation commits,ï¼¼
</li>
					<li>
`finished$mb ã¯ã€
`~navi~handler~promise$ãŸã¡ã€ï¼promsiesã€‘ã«å‰‡ã£ã¦ï¼»
å……è¶³ã•ã‚Œã‚‹ï¼å´ä¸‹ã•ã‚Œã‚‹
ï¼½ã€‚
â—
and finished will fulfill or reject according to any promsies returned by handlers passed to intercept().
</li>
				</ul>
			</li>
			<li>
ä»–ã®å ´åˆã€
ã©ã¡ã‚‰ã®~promiseã‚‚æ±ºã—ã¦æ±ºç€ã—ãªã„ã€‚
â—
Otherwise, both promises will never settle.
</li>
		</ul>
   </dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`traverseTo$mN(%key)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`traverseTo$mN(%key, { `info$mbN })</dt>
	<dd>
æ¬¡ã‚’æº€ãŸã™`~naviå±¥æ­´~entry$ãŒåœ¨ã‚‹ãªã‚‰ã°ï¼Œ
ãã‚Œã‚‰ã®ã†ã¡æœ€ã‚‚è¿‘ã„ã‚‚ã®ã¸`è¾¿ã‚‹ï¼ ~HTMLnav#apply-the-traverse-history-step$
â‡’
ï¼»
`navigation.entries()$c å†…ã®ã‚ã‚‹ `NavigationHistoryEntry$I ã®`~sessionå±¥æ­´~entry$nheã§ã‚ã‚‹
ï¼½~ANDï¼»
ãã®`~navi~API~key$shE ~EQ %key
ï¼½
â—
Traverses to the closest session history entry that matches the NavigationHistoryEntry with the given key.ï¼¼
</dd>
	<dd>
`info$mbN ã«ã¯ä»»æ„ã®å€¤ã‚’è¨­å®šã§ãã‚‹
â€” ãã‚Œã¯ã€
å¯¾å¿œã—ã¦ã„ã‚‹ `NavigateEvent$I ã® `info$mE ~propã‚’æ‹¡å……ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</dd>
	<dd>
å‰è¿°ã®æ¡ä»¶ã‚’æº€ãŸã™å±¥æ­´~entryã¸ã®é€²æ—-ä¸­ãªè¾¿ã‚ŠãŒï¼Œã™ã§ã«åœ¨ã‚‹å ´åˆã€
ã“ã‚Œã¯ï¼Œãã®è¾¿ã‚Šç”¨ã®~promiseã‚’è¿”ã™ã“ã¨ã«ãªã‚Šã€
`info$mE ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If a traversal to that session history entry is already in progress, then this will return the promises for that original traversal, and info will be ignored.
</dd>
	<dd>
<p>
è¿”ã•ã‚Œã‚‹~promiseãŸã¡ã¯ã€
æ¬¡ã«å¾“ã£ã¦æŒ™å‹•ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
â—
The returned promises will behave as follows:
</p>
		<ul>
			<li>
å‰è¿°ã®æ¡ä»¶ã‚’æº€ãŸã™å±¥æ­´~entryã¯ç„¡ã„å ´åˆ
â‡’
ã©ã¡ã‚‰ã®~promiseã‚‚ `InvalidStateError$E ä¾‹å¤–ã§å´ä¸‹ã•ã‚Œã‚‹ã€‚
â—
If there is no NavigationHistoryEntry in navigation.entries() whose key matches key, both promises will reject with an "InvalidStateError" DOMException.
</li>
			<li>
<p>
åŒä¸€-æ–‡æ›¸ã¸ã®è¾¿ã‚Šã§ã‚ã‚‹å ´åˆï¼š
â—
For same-document traversalsï¼¼
</p>
				<ul>
					<li>
<p>
`intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ~methodã«ã‚ˆã‚Šæ¨ªå–ã•ã‚ŒãŸå ´åˆï¼š
â—
intercepted by the navigateEvent.intercept() method,ï¼¼
</p>
						<ul>
							<li>
`committed$mb ã¯ã€ï¼»
å½“ã®è¾¿ã‚ŠãŒå‡¦ç†ã•ã‚Œï¼Œ
`navigation.currentEntry$c ãŒæ›´æ–°ã•ã‚Œã‚‹
ï¼½ã«ä¼´ã„ï¼Œå……è¶³ã•ã‚Œã‚‹ã€‚
â—
committed will fulfill as soon as the traversal is processed and navigation.currentEntry is updated,ï¼¼
</li>
							<li>
`finished$mb ã¯ã€
`~navi~handler~promise$ãŸã¡ã€ï¼promsiesã€‘ã«å‰‡ã£ã¦ï¼»
å……è¶³ã•ã‚Œã‚‹ï¼å´ä¸‹ã•ã‚Œã‚‹
ï¼½ã€‚
â—
and finished will fulfill or reject according to any promsies returned by the handlers passed to intercept().
</li>
						</ul>
					</li>
					<li>
ä»–ã®å ´åˆ
â‡’
ã©ã¡ã‚‰ã®~promiseã‚‚ã€ï¼»
å½“ã®è¾¿ã‚Šã€ï¼travesalã€‘ãŒå‡¦ç†ã•ã‚Œï¼Œ
`navigation.currentEntry$c ãŒæ›´æ–°ã•ã‚Œã‚‹
ï¼½ã«ä¼´ã„ï¼Œå……è¶³ã•ã‚Œã‚‹ã€‚
â—
For non-intercepted same-document travesals, both promises will fulfill as soon as the traversal is processed and navigation.currentEntry is updated.
</li>
				</ul>
			</li>
			<li>
<p>
éåŒä¸€-æ–‡æ›¸ã¸ã®è¾¿ã‚Šã§ã‚ã‚‹å ´åˆ
â‡’
ã©ã¡ã‚‰ã®~promiseã‚‚æ±ºã—ã¦æ±ºç€ã—ãªã„
</p>

<p>
ã“ã‚Œã«ã¯ã€
~serverã‹ã‚‰æ¬¡ã®ã„ãšã‚Œã‹ãŒè¿”ã•ã‚ŒãŸå ´åˆã‚‚å«ã¾ã‚Œã‚‹ï¼š
</p>
				<ul>
					<li>
`çŠ¶æ…‹s$rs ~IN { `204^hst, `205^hst }
</li>
					<li>
å€¤ `attachment^bl ã‚’ä¼´ã† `Content-Disposition$h ~header
ï¼ˆã—ãŸãŒã£ã¦ã€
å®Ÿéš›ã«ã¯è¾¿ã‚‰ãªã„ï¼‰
</li>
				</ul>
â—
For cross-document traversals, including attempted cross-document traversals that end up resulting in a 204 or 205 statuses or `Content-Disposition: attachment` header fields from the server (and thus do not actually traverse), both promises will never settle.
</li>
		</ul>
	</dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`back$mN(ã€ï¼%keyã€‘)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`back$mN(ã€ï¼%key, ã€‘{ `info$mbN })</dt>
	<dd>
å¾Œæ–¹ã«åœ¨ã‚‹`~sessionå±¥æ­´~entry$ã®ã†ã¡ï¼Œã“ã®`~navigable$ã‚’è¾¿ã‚‰ã›ã‚‹ã‚‚ã®
â€” ã™ãªã‚ã¡ã€
ç•°ãªã‚‹ `NavigationHistoryEntry$I ã«å¯¾å¿œã™ã‚‹ã‚‚ã®
ï¼ˆã—ãŸãŒã£ã¦ã€
`navigation.currentEntry$c ã‚’å¤‰åŒ–ã•ã›ã‚‹ã‚‚ã®ï¼‰ â€”
ã®ã†ã¡æœ€ã‚‚è¿‘ã„ã‚‚ã®ã¸è¾¿ã‚‹ã€‚
â—
Traverses to the closest previous session history entry which results in this navigable traversing, i.e., which corresponds to a different NavigationHistoryEntry and thus will cause navigation.currentEntry to change.ï¼¼
</dd>
	<dd>
`info$mbN ã«ã¯ä»»æ„ã®å€¤ã‚’è¨­å®šã§ãã‚‹
â€” ãã‚Œã¯ã€
å¯¾å¿œã—ã¦ã„ã‚‹ `NavigateEvent$I ã® `info$mE ~propã‚’æ‹¡å……ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</dd>
	<dd>
ãã®ã‚ˆã†ãª`~sessionå±¥æ­´~entry$ã¸ã®é€²æ—-ä¸­ãªè¾¿ã‚ŠãŒï¼Œã™ã§ã«åœ¨ã‚‹å ´åˆã€
ã“ã‚Œã¯ï¼Œãã®è¾¿ã‚Šç”¨ã®~promiseã‚’è¿”ã™ã“ã¨ã«ãªã‚Šã€
`info$mE ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If a traversal to that session history entry is already in progress, then this will return the promises for that original traversal, and info will be ignored.
</dd>
	<dd>
è¿”ã•ã‚Œã‚‹å„~promiseã¯ã€
`traverseTo()$mN ãŒè¿”ã™ã‚‚ã®ã¨ç­‰ä¾¡ã«æŒ™å‹•ã™ã‚‹ã€‚
â—
The returned promises behave equivalently to those returned by traverseTo().
</dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`forward$mN(%key)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`forward$mN(%key, { `info$mbN })</dt>
	<dd>
å‰æ–¹ã«åœ¨ã‚‹`~sessionå±¥æ­´~entry$ã®ã†ã¡ï¼Œã“ã®`~navigable$ã‚’è¾¿ã‚‰ã›ã‚‹ã‚‚ã®
â€” ã™ãªã‚ã¡ã€
ç•°ãªã‚‹ `NavigationHistoryEntry$I ã«å¯¾å¿œã™ã‚‹ã‚‚ã®
ï¼ˆã—ãŸãŒã£ã¦ã€
`navigation.currentEntry$c ã‚’å¤‰åŒ–ã•ã›ã‚‹ã‚‚ã®ï¼‰ â€”
ã®ã†ã¡æœ€ã‚‚è¿‘ã„ã‚‚ã®ã¸è¾¿ã‚‹ã€‚
â—
Traverses to the closest forward session history entry which results in this navigable traversing, i.e., which corresponds to a different NavigationHistoryEntry and thus will cause navigation.currentEntry to change.ï¼¼
</dd>
	<dd>
`info$mbN ã«ã¯ä»»æ„ã®å€¤ã‚’è¨­å®šã§ãã‚‹
â€” ãã‚Œã¯ã€
å¯¾å¿œã—ã¦ã„ã‚‹ `NavigateEvent$I ã® `info$mE ~propã‚’æ‹¡å……ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</dd>
	<dd>
ãã®ã‚ˆã†ãª`~sessionå±¥æ­´~entry$ã¸ã®é€²æ—-ä¸­ãªè¾¿ã‚ŠãŒï¼Œã™ã§ã«åœ¨ã‚‹å ´åˆã€
ã“ã‚Œã¯ï¼Œãã®è¾¿ã‚Šç”¨ã®~promiseã‚’è¿”ã™ã“ã¨ã«ãªã‚Šã€
`info$mE ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
If a traversal to that session history entry is already in progress, then this will return the promises for that original traversal, and info will be ignored.
</dd>
	<dd>
è¿”ã•ã‚Œã‚‹å„~promiseã¯ã€
`traverseTo()$mN ãŒè¿”ã™ã‚‚ã®ã¨ç­‰ä¾¡ã«æŒ™å‹•ã™ã‚‹ã€‚
â—
The returned promises behave equivalently to those returned by traverseTo().
</dd>
</dl>

<div class="algo">
<p>
`navigate(url, options)@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The navigate(url, options) method steps are:
</p>
<ol>
	<li>
%~URL~record ~LET `~URLã‚’ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æã™ã‚‹$( %url, ã‚³ãƒ¬ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$ )
â—
Let urlRecord be the result of parsing a URL given url, relative to this's relevant settings object.
</li>
	<li>
~IFï¼»
%~URL~record ~EQ `å¤±æ•—^i
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `SyntaxError$E ä¾‹å¤– )
â—
If urlRecord is failure, then return an early error result for a "SyntaxError" DOMException.
</li>
	<li>
~IFï¼»
%~URL~record ã®`~scheme$url ~EQ `javascriptï¼ ~HTMLnav#the-javascript:-url-special-case$l
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `NotSupportedError$E ä¾‹å¤– )
â—
If urlRecord's scheme is "javascript", then return an early error result for a "NotSupportedError" DOMException.
</li>
	<li>
%æ–‡æ›¸ ~LET ã‚³ãƒ¬ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be this's relevant global object's associated Document.
</li>
	<li>
~IFï¼»
%options[ "`history$mbN" ] ~EQ `push$hH
ï¼½~ANDï¼»
`~naviã¯ç½®æ›-ã«ãªã‚‹ãƒ¢ãƒãƒˆã‚¹ãƒ«ã‹ï¼Ÿ$( %~URL~record, %æ–‡æ›¸ ) ~EQ ~T
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `NotSupportedError$E ä¾‹å¤– )
â—
If options["history"] is "push", and the navigation must be a replace given urlRecord and document, then return an early error result for a "NotSupportedError" DOMException.
</li>
	<li>
%state ~LET %options[ "`state$mbN" ]
â—
â†“</li>
	<li>
~IFï¼»
%state ~EQ Îµ
ï¼½
â‡’
%state ~SET `undefined^jv
â—
Let state be options["state"], if it exists; otherwise, undefined.
</li>
	<li>
<p>
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ~LET `StructuredSerializeForStorage$jA( %state )
â—
Let serializedState be StructuredSerializeForStorage(state).ï¼¼
</p>

<p>
ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚ŒãŸå ´åˆ
â‡’
~RET `æ—©æœŸ~errorçµæœ$( ãã®ä¾‹å¤– )
â—
If this throws an exception, then return an early error result for that exception.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€
æ—©æœŸã«é‚è¡Œã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã‚ã‚‹ã€‚
ç›´åˆ—åŒ–ã¯ï¼Œ~webé–‹ç™ºè€…~codeã‚’å‘¼å‡ºã™ã“ã¨ã‚‚ã‚ã‚Šã€
ãã®çµæœï¼Œå¾Œã®æ®µã§æ¤œæŸ»ã™ã‚‹æ§˜ã€…ãªã‚‚ã®ã‚’å¤‰æ›´ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€‚
â—
It is important to perform this step early, since serialization can invoke web developer code, which in turn might change various things we check in later steps.
</p>
	</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If document is not fully active, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã®`~unload~counter$ ~GT 0
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If document's unload counter is greater than 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%info ~LET %options[ "`info$mbN" ]
â—
â†“</li>
	<li>
~IFï¼»
%info ~EQ Îµ
ï¼½
â‡’
%info ~SET `undefined^jv
â—
Let info be options["info"], if it exists; otherwise, undefined.
</li>
	<li>
%~API~methodè¿½è·¡å­ ~LET `æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­ã‚’å¿…è¦ãªã‚‰è¨­å®šã™ã‚‹$( ã‚³ãƒ¬, %info, %ç›´åˆ—å½¢ã®çŠ¶æ…‹ )
â—
Let apiMethodTracker be the result of maybe setting the upcoming non-traverse API method tracker for this given info and serializedState.
</li>
	<li>
<p>
`~navigableã‚’~URLã¸~navigateã™ã‚‹$( %æ–‡æ›¸ ã®`~node~navigable$, %~URL~record, %æ–‡æ›¸ )
â€” æ¬¡ã‚‚ä¸ãˆã‚‹ä¸‹ã§
â‡’ï¼ƒ
`å±¥æ­´~å–æ‰±ã„^i ~SET %options[ "`history$mbN" ],
`~navi~APIçŠ¶æ…‹^i ~SET %ç›´åˆ—å½¢ã®çŠ¶æ…‹
â—
Navigate document's node navigable to urlRecord using document, with historyHandling set to options["history"] and navigationAPIState set to serializedState.
</p>

<p class="note">æ³¨è¨˜ï¼š
ï¼»
`åŒã˜ç”Ÿæˆå…ƒ~domain$å¢ƒç•Œã‚’ã¾ãŸãŒã£ã¦å…¬é–‹ã•ã‚Œã‚‹
`location.assign()ï¼ ~WINDOW#dom-location-assign$c ã‚„åŒé¡ã®~API
ï¼½ã¨é•ã£ã¦ã€ï¼»
`navigation.navigate()$c ã«~accessã—å¾—ã‚‹~code
ï¼½ã¯ï¼Œï¼»
`window.navigation$c ~propã«å¯¾ã—ï¼Œç›´ã«ã‹ã¤åŒæœŸçš„ã«~accessã™ã‚‹ã‚‚ã®
ï¼½ã«é™ã‚‰ã‚Œã‚‹ã€‚
ã—ãŸãŒã£ã¦ï¼Œï¼»
å½“ã®~naviã«æ¸¡ã•ã‚Œã‚‹ %~sourceæ–‡æ›¸ ãŒã©ã“ã«å¸°å±ã™ã‚‹ã‹
ï¼½ã«ã¤ã„ã¦è¤‡é›‘ã«ãªã‚‹ã®ã¯é¿ã‘ã‚‰ã‚Œã€ï¼»
`~navigateã™ã‚‹ã“ã¨ã¯~sandboxæ³•ã«ã‚ˆã‚Šè¨±å®¹ã•ã‚Œ$ã‚‹ã‹å¦ã‹ã®æ¤œæŸ»
ï¼½ãŠã‚ˆã³ï¼»
ãã‚Œã«ä»˜éšã—ã¦ã„ã‚‹ `ä¾‹å¤–ã‚’å¯èƒ½åŒ–ã™ã‚‹ã‹ï¼ ~HTMLnav#exceptions-enabled$i
ï¼½ã‚’å‡¦ã™ã‚‹å¿…è¦ã¯ãªããªã‚‹ã€‚
ã™ã¹ã¦ã®~naviã¯ã€
ã“ã® `Navigation$I ~objè‡ªèº«ï¼ˆã™ãªã‚ã¡ï¼Œã‚³ãƒ¬ï¼‰ã«å¯¾å¿œã—ã¦ã„ã‚‹`æ–‡æ›¸$ï¼ˆã™ãªã‚ã¡ %æ–‡æ›¸ ï¼‰ã‹ã‚‰æ¥ãŸã‹ã®ã‚ˆã†ã«æ‰±ã†ã ã‘ã§æ¸ˆã‚€ã€‚
â—
Unlike location.assign() and friends, which are exposed across origin-domain boundaries, navigation.navigate() can only be accessed by code with direct synchronous access to the window.navigation property. Thus, we avoid the complications about attributing the source document of the navigation, and we don't need to deal with the allowed by sandboxing to navigate check and its acccompanying exceptionsEnabled flag. We just treat all navigations as if they come from the Document corresponding to this Navigation object itself (i.e., document).
</p>
	</li>
	<li>
<p>
~IFï¼»
ã‚³ãƒ¬ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~EQ %~API~methodè¿½è·¡å­
ï¼½ï¼š
â—
If this's upcoming non-traverse API method tracker is apiMethodTracker, then:
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ™‚ç‚¹ã§ã‚‚ï¼Œã“ã®æ¡ä»¶ãŒæº€ãŸã•ã‚Œã‚‹å ´åˆã€
`~navi~algo$ã¯ï¼Œ`~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo$
ï¼ˆãã‚Œã¯ã€
`æ¥ãŸã‚‹~API~methodè¿½è·¡å­ã‚’é€²è¡Œä¸­ã«ã™ã‚‹$ï¼‰
ã¸~~é”ã™ã‚‹å‰ã«æŠœã‘å‡ºãŸã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
If the upcoming non-traverse API method tracker is still apiMethodTracker, this means that the navigate algorithm bailed out before ever getting to the inner navigate event firing algorithm which would promote that upcoming API method tracker to ongoing.
</p>
		<ol>
			<li>
ã‚³ãƒ¬ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~SET ~NULL
â—
Set this's upcoming non-traverse API method tracker to null.
</li>
			<li>
~RET `æ—©æœŸ~errorçµæœ$( `AbortError$E ä¾‹å¤– )
â—
Return an early error result for an "AbortError" DOMException.
</li>
		</ol>
	</li>
	<li>
~RET `~navi~API~methodè¿½è·¡å­ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹çµæœ$( %~API~methodè¿½è·¡å­ )
â—
Return a navigation API method tracker-derived result for apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`reload(options)@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The reload(options) method steps are:
</p>
<ol>
	<li>
%æ–‡æ›¸ ~LET ã‚³ãƒ¬ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be this's relevant global object's associated Document.
</li>
	<li>
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ~LET `StructuredSerializeForStorage$jA( `undefined^jv )
â—
Let serializedState be StructuredSerializeForStorage(undefined).
</li>
	<li>
%state ~LET %options[ "`state$mbR" ]
â—
â†“</li>
	<li>
<p>
~IFï¼»
%state ~NEQ Îµ
ï¼½
â‡’
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ~SET `StructuredSerializeForStorage$jA( %state )
â—
If options["state"] exists, then set serializedState to StructuredSerializeForStorage(options["state"]).ï¼¼
</p>

<p>
ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚ŒãŸå ´åˆ
â‡’
~RET `æ—©æœŸ~errorçµæœ$( ãã®ä¾‹å¤– )
â—
If this throws an exception, then return an early error result for that exception.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€
æ—©æœŸã«é‚è¡Œã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã‚ã‚‹ã€‚
ç›´åˆ—åŒ–ã¯ï¼Œ~webé–‹ç™ºè€…~codeã‚’å‘¼å‡ºã™ã“ã¨ã‚‚ã‚ã‚Šã€
ãã®çµæœï¼Œå¾Œã®æ®µã§æ¤œæŸ»ã™ã‚‹æ§˜ã€…ãªã‚‚ã®ã‚’å¤‰æ›´ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã€‚
â—
It is important to perform this step early, since serialization can invoke web developer code, which in turn might change various things we check in later steps.
</p>
	</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
		<ol>
			<li>
%ç¾åœ¨ã®~entry ~LET `~naviã®ç¾åœ¨ã®~entry$( ã‚³ãƒ¬ )
â—
Let current be the current entry of this.
</li>
			<li>
~IFï¼»
%ç¾åœ¨ã®~entry ~NEQ ~NULL
ï¼½
â‡’
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ~SET %ç¾åœ¨ã®~entry ã®`~sessionå±¥æ­´~entry$nheã®`~navi~APIçŠ¶æ…‹$shE
â—
If current is not null, then set serializedState to current's session history entry's navigation API state.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If document is not fully active, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã®`~unload~counter$ ~GT 0
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If document's unload counter is greater than 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%info ~LET %options[ "`info$mbN" ]
â—
â†“</li>
	<li>
~IFï¼»
%info ~EQ Îµ
ï¼½
â‡’
%info ~SET `undefined^jv
â—
Let info be options["info"], if it exists; otherwise, undefined.
</li>
	<li>
%~API~methodè¿½è·¡å­ ~LET `æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­ã‚’å¿…è¦ãªã‚‰è¨­å®šã™ã‚‹$( ã‚³ãƒ¬, %info, %ç›´åˆ—å½¢ã®çŠ¶æ…‹ )
â—
Let apiMethodTracker be the result of maybe setting the upcoming non-traverse API method tracker for this given info and serializedState.
</li>
	<li>
`~navigableã‚’èª­è¾¼ç›´ã™$( %æ–‡æ›¸ ã®`~node~navigable$, %ç›´åˆ—å½¢ã®çŠ¶æ…‹ )
â—
Reload document's node navigable with navigationAPIState set to serializedState.
</li>
	<li>
~RET `~navi~API~methodè¿½è·¡å­ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹çµæœ$( %~API~methodè¿½è·¡å­ )
â—
Return a navigation API method tracker-derived result for apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`traverseTo(key, options)@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The traverseTo(key, options) method steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~EQ âˆ’1
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If this's current entry index is âˆ’1, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
ã‚³ãƒ¬ã®`~entry~list$nVã‚’æˆã™
~EACH( %~entry )
ã«å¯¾ã—
â‡’
~IFï¼»
%~entry ã®`~sessionå±¥æ­´~entry$nheã®`~navi~API~key$shE ~EQ %key
ï¼½
â‡’
~RET `~navi~APIç”¨ã®è¾¿ã‚Šã‚’é‚è¡Œã™ã‚‹$( ã‚³ãƒ¬, %key, %options )
â—
If this's entry list does not contain a NavigationHistoryEntry whose session history entry's navigation API key equals key, then return an early error result for an "InvalidStateError" DOMException.
â—
Return the result of performing a navigation API traversal given this, key, and options.
</li>
	<li>
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
â†‘</li>
</ol>
</div>

<div class="algo">
<p>
`back(options)@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The back(options) method steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~IN { âˆ’1, 0 }
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If this's current entry index is âˆ’1 or 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%~key ~LET ã‚³ãƒ¬ã®`~entry~list$nV[ ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~MINUS 1 ] ã®`~sessionå±¥æ­´~entry$nheã®`~navi~API~key$shE
â—
Let key be this's entry list[this's current entry index âˆ’ 1]'s session history entry's navigation API key.
</li>
	<li>
~RET `~navi~APIç”¨ã®è¾¿ã‚Šã‚’é‚è¡Œã™ã‚‹$( ã‚³ãƒ¬, %~key, %options )
â—
Return the result of performing a navigation API traversal given this, key, and options.
</li>
</ol>
</div>

<div class="algo">
<p>
`forward(options)@mN
~methodæ‰‹ç¶šãã¯ï¼š
â—
The forward(options) method steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~IN { âˆ’1, ã‚³ãƒ¬ã®`~entry~list$nVã®`~size$ ~MINUS 1 }
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If this's current entry index is âˆ’1 or is equal to this's entry list's size âˆ’ 1, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%~key ~LET ã‚³ãƒ¬ã®`~entry~list$nV[ ã‚³ãƒ¬ã®`ç¾åœ¨ã®~entry~index$nV ~PLUS 1] ã®`~sessionå±¥æ­´~entry$nheã®`~navi~API~key$shE
â—
Let key be this's entry list[this's current entry index + 1]'s session history entry's navigation API key.
</li>
	<li>
~RET `~navi~APIç”¨ã®è¾¿ã‚Šã‚’é‚è¡Œã™ã‚‹$( ã‚³ãƒ¬, %~key, %options )
â—
Return the result of performing a navigation API traversal given this, key, and options.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi~APIç”¨ã®è¾¿ã‚Šã‚’é‚è¡Œã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`Navigation$I %~navi,
æ–‡å­—åˆ— %~key,
`NavigationOptions$I %~optionç¾¤
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To perform a navigation API traversal given a Navigation navigation, a string key, and a NavigationOptions options:
</p>
<ol>
	<li>
%æ–‡æ›¸ ~LET %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be navigation's relevant global object's associated Document.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If document is not fully active, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
~IFï¼»
%æ–‡æ›¸ ã®`~unload~counter$ ~GT 0
ï¼½
â‡’
~RET `æ—©æœŸ~errorçµæœ$( `InvalidStateError$E ä¾‹å¤– )
â—
If document's unload counter is greater than 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%ç¾åœ¨ã®~entry ~LET `~naviã®ç¾åœ¨ã®~entry$( %~navi )
â—
Let current be the current entry of navigation.
</li>
	<li>
~IFï¼»
%~key ~EQ %ç¾åœ¨ã®~entry ã®`~sessionå±¥æ­´~entry$nheã®`~navi~API~key$shE
ï¼½
â‡’
~RET Â«[ æ¬¡ã«æŒ™ã’ã‚‹~entry ]Â»
â‡’ï¼ƒ
"`committed$mb" â†’ `è§£æ±ºã•ã‚Œã‚‹~promise$( %ç¾åœ¨ã®~entry ),
"`finished$mb" â†’ `è§£æ±ºã•ã‚Œã‚‹~promise$( %ç¾åœ¨ã®~entry )
â—
If key equals current's session history entry's navigation API key, then return Â«[ "committed" â†’ a promise resolved with current, "finished" â†’ a promise resolved with current ]Â».
</li>
	<li>
~IFï¼»
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %~key ] ~NEQ Îµ
ï¼½
â‡’
~RET `~navi~API~methodè¿½è·¡å­ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹çµæœ$( %~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %~key ] )
â—
If navigation's upcoming traverse API method trackers[key] exists, then return a navigation API method tracker-derived result for navigation's upcoming traverse API method trackers[key].
</li>
	<li>
%info ~LET %~optionç¾¤[ "`info$mbN" ]
â—
â†“</li>
	<li>
~IFï¼»
%info ~EQ Îµ
ï¼½
â‡’
%info ~SET `undefined^jv
â—
Let info be options["info"], if it exists; otherwise, undefined.
</li>
	<li>
%~API~methodè¿½è·¡å­ ~LET `æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­ã‚’è¿½åŠ ã™ã‚‹$( %~navi, %~key, %info )
â—
Let apiMethodTracker be the result of adding an upcoming traverse API method tracker for navigation given key and info.
</li>
	<li>
%~navigable ~LET %æ–‡æ›¸ ã®`~node~navigable$
â—
Let navigable be document's node navigable.
</li>
	<li>
%è¾¿å¯èƒ½ ~LET %~navigable ã®`è¾¿å¯èƒ½ãª~navigable$nav
â—
Let traversable be navigable's traversable navigable.
</li>
	<li>
%~source~snapshot~params ~LET `~source~snapshot~paramsã‚’~snapshotã™ã‚‹$( %æ–‡æ›¸ )
â—
Let sourceSnapshotParams be the result of snapshotting source snapshot params given document.
</li>
	<li>
<p>
`~sessionå±¥æ­´~è¾¿ã‚Šæ‰‹ç¶šãã‚’ä»˜åŠ ã™ã‚‹$( %è¾¿å¯èƒ½, æ¬¡ã®æ‰‹ç¶šã )
â—
Append the following session history traversal steps to traversable:
</p>

<div class="algo">
<p>
æ‰‹ç¶šãã¯ï¼š
â—
â†‘</p>
		<ol>
			<li>
%~navigableã®å±¥æ­´~entryç¾¤ ~LET `~sessionå±¥æ­´~entryç¾¤ã‚’å–å¾—ã™ã‚‹$( %~navigable )
â—
Let navigableSHEs be the result of getting session history entries given navigable.
</li>
			<li>
%~targetå±¥æ­´~entry ~LET Îµ
â—
â†“</li>
			<li>
%~navigableã®å±¥æ­´~entryç¾¤ ã‚’æˆã™
~EACH( `~sessionå±¥æ­´~entry$ %å±¥æ­´~entry )
ã«å¯¾ã—
â‡’
~IFï¼»
%å±¥æ­´~entry ã®`~navi~API~key$shE ~EQ %~key
ï¼½
â‡’ï¼ƒ
%~targetå±¥æ­´~entry ~SET %å±¥æ­´~entryï¼›
~BREAK
â—
Let targetSHE be the session history entry in navigableSHEs whose navigation API key is key.ï¼¼
</li>
			<li>
<p>
~IFï¼»
%~targetå±¥æ­´~entry ~EQ Îµ
ï¼½ï¼š
â—
If no such entry exists, then:
</p>
				<ol>
					<li>
<p>
`å¤§åŸŸ~taskã‚’~queueã™ã‚‹$( `~naviã¨è¾¿ã‚Š~task~source$, %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$, æ¬¡ã®æ‰‹ç¶šã )
â—
Queue a global task on the navigation and traversal task source given navigation's relevant global object toï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­, `InvalidStateError$E ä¾‹å¤– )
â—
reject the finished promise for apiMethodTracker with an "InvalidStateError" DOMException.
</div>
					</li>
					<li>
~RET
â—
Abort these steps.
</li>
				</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®é“ãŒã¨ã‚‰ã‚Œã‚‹ã®ã¯ã€
%~navi ã®`~entry~list$nVãŒ %~navigableã®å±¥æ­´~entryç¾¤ ã«æ¯”ã—ã¦å¤ããªã£ã¦ã„ãŸå ´åˆã§ã‚ã‚‹
â€” ã“ã‚ŒãŒç”Ÿã˜å¾—ã‚‹ã®ã¯ã€ï¼»
é–¢é€£ãªï¼»
~thread, ~process
ï¼½ã™ã¹ã¦ãŒå±¥æ­´~å¤‰æ›´ã«å¯¾ã™ã‚‹åå¿œã«ãŠã„ã¦åŒæœŸã•ã‚Œã¦ã„ã‚‹é–“
ï¼½ã‚’æˆã™çŸ­ã„æœŸé–“å†…ã§ã‚ã‚‹ã€‚
â—
This path is taken if navigation's entry list was outdated compared to navigableSHEs, which can occur for brief periods while all the relevant threads and processes are being synchronized in reaction to a history change.
</p>
			</li>
			<li>
<p>
~IFï¼»
%~targetå±¥æ­´~entry ~EQ %~navigable ã«ã¦`ä½œå‹•ä¸­ãª~entry$nav
ï¼½
â‡’
~RET
â—
If targetSHE is navigable's active session history entry, then abort these steps.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚ŒãŒç”Ÿã˜å¾—ã‚‹ã®ã¯ã€
ä»¥å‰ã«`~queueã•ã‚Œï¼ ~HTMLnav#tn-append-session-history-traversal-steps$ãŸè¾¿ã‚ŠãŒï¼Œã™ã§ã« ã“ã®`~sessionå±¥æ­´~entry$ã¸é€£ã‚Œã¦è¡Œã£ãŸå ´åˆã§ã‚ã‚‹ã€‚
ãã®äº‹ä¾‹ã§ã¯ã€
ä»¥å‰ã®è¾¿ã‚ŠãŒï¼Œ %~API~methodè¿½è·¡å­ ã‚’ã™ã§ã«å‡¦ã—ãŸã“ã¨ã«ãªã‚‹ã€‚
â—
This can occur if a previously queued traversal already took us to this session history entry. In that case the previous traversal will have dealt with apiMethodTracker already.
</p>
			</li>
			<li>
%çµæœ ~LET `è¾¿-ç”¨ã«å±¥æ­´~stepã‚’é©ç”¨ã™ã‚‹$( â†“ )
â‡’ï¼ƒ
%~targetå±¥æ­´~entry ã®`~step$shE,
%è¾¿å¯èƒ½,
%~source~snapshot~params,
%~navigable,
`ãªã—$i
â—
Let result be the result of applying the traverse history step given by targetSHE's step to traversable, given sourceSnapshotParams, navigable, and "none".
</li>
			<li>
<p>
~IFï¼»
%çµæœ ~EQ `~beforeunload_evã«ã‚ˆã‚Šå–æ¶ˆã•ã‚ŒãŸ^i
ï¼½
â‡’
`å¤§åŸŸ~taskã‚’~queueã™ã‚‹$( `~naviã¨è¾¿ã‚Š~task~source$, %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$, æ¬¡ã®æ‰‹ç¶šã )
â—
If result is "canceled-by-beforeunload", then queue a global task on the navigation and traversal task source given navigation's relevant global object toï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­, %~navi ã«`é–¢é€£ãª~realm$å†…ã«ä½œæˆã•ã‚Œã‚‹æ–°ãŸãª `AbortError$E ä¾‹å¤– )
â—
reject the finished promise for apiMethodTracker with a new "AbortError" DOMException created in navigation's relevant realm.
</div>
			</li>
			<li>
<p>
~IFï¼»
%çµæœ ~EQ `èµ·å‹•å…ƒã¯è¨±å®¹ã•ã‚Œãªã„^i
ï¼½
â‡’
`å¤§åŸŸ~taskã‚’~queueã™ã‚‹$( `~naviã¨è¾¿ã‚Š~task~source$, %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$, æ¬¡ã®æ‰‹ç¶šã )
â—
If result is "initiator-disallowed", then queue a global task on the navigation and traversal task source given navigation's relevant global object toï¼¼
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­, %~navi ã«`é–¢é€£ãª~realm$å†…ã«ä½œæˆã•ã‚Œã‚‹æ–°ãŸãª `SecurityError$E ä¾‹å¤– )
â—
reject the finished promise for apiMethodTracker with a new "SecurityError" DOMException created in navigation's relevant realm.
</div>

<div class="note">
<p>æ³¨è¨˜ï¼š
%çµæœ ãŒï¼»
`~beforeunload_evã«ã‚ˆã‚Šå–æ¶ˆã•ã‚ŒãŸ^i ï¼ `èµ·å‹•å…ƒã¯è¨±å®¹ã•ã‚Œãªã„^i
ï¼½ã®å ´åˆã€
`navigate$et ~eventã¯ç™ºç«ã•ã‚Œãªã‹ã£ãŸã“ã¨ã«ãªã‚‹ã®ã§ï¼Œ
`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹$ã®ã¯ä¸æ­£ã«ãªã‚‹
â€” ãã®çµæœã€
`navigateerror$et ~eventã‚’ï¼»
å…ˆè¡Œã™ã‚‹ `navigate$et ~eventã‚’ä¼´ã‚ãšã«ç™ºç«ã™ã‚‹
ï¼½ã“ã¨ã«ãªã‚‹ã€‚
â—
When result is "canceled-by-beforeunload" or "initiator-disallowed", the navigate event was never fired, aborting the ongoing navigation would not be correct; it would result in a navigateerror event without a preceding navigate event.
</p>

<p>
%çµæœ ãŒ `~navigate_evã«ã‚ˆã‚Šå–æ¶ˆã•ã‚ŒãŸ^i ã«ãªã‚‹äº‹ä¾‹ã§ã¯ã€
`navigate$et ~eventã¯`ç™ºç«ã•ã‚Œã‚‹^emãŒï¼Œ
`~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo$ãŒ`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹$ã‚ˆã†~careã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
In the "canceled-by-navigate" case, navigate is fired, but the inner navigate event firing algorithm will take care of aborting the ongoing navigation.
</p>
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
~RET `~navi~API~methodè¿½è·¡å­ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹çµæœ$( %~API~methodè¿½è·¡å­ )
â—
Return a navigation API method tracker-derived result for apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`æ—©æœŸ~errorçµæœ@
ã¯ã€
æ‰€ä¸ã®
( ä¾‹å¤– %e )
ã«å¯¾ã—
â‡’
~RET  Â«[ æ¬¡ã«æŒ™ã’ã‚‹~entry ]Â» ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹ `NavigationResult$I è¾æ›¸~instance
â‡’ï¼ƒ
"`committed$mb" â†’ `å´ä¸‹ã•ã‚Œã‚‹~promise$( %e ),
"`finished$mb" â†’ `å´ä¸‹ã•ã‚Œã‚‹~promise$( %e )
â—
An early error result for an exception e is a NavigationResult dictionary instance given by Â«[ "committed" â†’ a promise rejected with e, "finished" â†’ a promise rejected with e ]Â».
</p>
</div>

<div class="algo">
<p>
`~navi~API~methodè¿½è·¡å­ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹çµæœ@
ã¯ã€
æ‰€ä¸ã®
( `~navi~API~methodè¿½è·¡å­$ )
ã«å¯¾ã—
â‡’
~RET  Â«[ æ¬¡ã«æŒ™ã’ã‚‹~entry ]Â» ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹ `NavigationResult$I è¾æ›¸~instance
â‡’ï¼ƒ
"`committed$mb" â†’ %~API~methodè¿½è·¡å­ ã®`~commitæ™‚ã®~promise$amT,
"`finished$mb" â†’ %~API~methodè¿½è·¡å­ ã®`å®Œé‚-æ™‚ã®~promise$amT
â—
A navigation API method tracker-derived result for a navigation API method tracker is a NavigationResult dictionary instance given by Â«[ "committed" â†’ apiMethodTracker's committed promise, "finished" â†’ apiMethodTracker's finished promise ]Â».
</p>
</div>

				</section>
				<section id="ongoing-navigation-tracking">
<h5 title="Ongoing navigation tracking">7.2.6.8. é€²è¡Œä¸­ãª~naviã®è¿½è·¡-æ³•</h5>

<p>
ï¼ˆ`ç¨®åˆ¥ã‚’å•ã‚ãšï¼ #navigationtype$ï¼‰
æ‰€ä¸ã®~naviã®é–“ã€
`Navigation$I ~objã¯ï¼Œä»¥ä¸‹ã«æŒ™ã’ã‚‹ã‚‚ã®ã‚’è¿½è·¡ã—ç¶šã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼š
â—
During any given navigation (in the broad sense of the word), the Navigation object needs to keep track of the following:
</p>

<table class="_nav-tracking grid-table">
<caption>
ã™ã¹ã¦ã®~naviç”¨
â—
For all navigations
</caption>
<thead>
<tr><th>
çŠ¶æ…‹
â—
State
<th>
è¿½è·¡æœŸé–“
â—
Duration
<th>
èª¬æ˜
â—
Explanation
<tbody>

<tr><td>
`NavigateEvent$I
â—
The NavigateEvent
<td>
~eventã‚’ç™ºç«ã—ã¦ã„ã‚‹é–“
â—
For the duration of event firing
<td>
å½“ã®~eventã‚’ç™ºç«ã—ã¦ã„ã‚‹é–“ã«å½“ã®~naviãŒå–æ¶ˆã•ã‚ŒãŸå ´åˆã«ï¼Œ
å½“ã®~eventã‚’`å–æ¶ˆã›ã‚‹ï¼ ~DOM4#canceled-flag$ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that if the navigation is canceled while the event is firing, we can cancel the event
<tr><td>
~eventã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEv
â—
The event's abort controller
<td>
ã™ã¹ã¦ã®`~navi~handler~promise$ãŒæ±ºç€ã™ã‚‹ã¾ã§
â—
Until all promises returned from handlers passed to intercept() have settled
<td>
å½“ã®~naviãŒå–æ¶ˆã•ã‚ŒãŸå ´åˆã«`ä¸­æ­¢-ã‚’é€šé”ã§ãã‚‹ï¼ ~DOM4#abortcontroller-signal-abort$ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that if the navigation is canceled, we can signal abort

<tr><td>
æ–°ãŸã«`~focusã•ã‚Œï¼ ~HTMLinteraction#focusing-steps$ãŸè¦ç´ ãŒã‚ã‚‹ã‹ã©ã†ã‹
â—
Whether a new element was focused
<td>
ã™ã¹ã¦ã®`~navi~handler~promise$ãŒæ±ºç€ã™ã‚‹ã¾ã§
â—
Until all promises returned from handlers passed to intercept() have settled
<td>
ãã®ã‚ˆã†ãªè¦ç´ ãŒã‚ã‚‹å ´åˆã€
`~focusã‚’è¨­å®šã—ç›´ã•ãªã„ï¼ #potentially-reset-the-focus$ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that if one was, focus is not reset
<tr><td>
~navigateã•ã‚Œã¦ã„ã‚‹ `NavigationHistoryEntry$I
â—
The NavigationHistoryEntry being navigated to
<td>
ãã‚ŒãŒæ±ºå®šã•ã‚ŒãŸã¨ãã‹ã‚‰ï¼Œ
ã™ã¹ã¦ã®`~navi~handler~promise$ãŒæ±ºç€ã™ã‚‹ã¾ã§
â—
From when it is determined, until all promises returned from handlers passed to intercept() have settled
<td>
ï¼»
`committed$mb ï¼ `finished$mb
ï¼½~promiseï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰ã‚’ä½•ã§è§£æ±ºã™ã‚‹ã‹çŸ¥ã‚‹ãŸã‚
â—
So that we know what to resolve any committed and finished promises with
<tr><td>
è¿”ã•ã‚ŒãŸ `finished$mb ~promiseï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
â—
Any finished promise that was returned
<td>
ã™ã¹ã¦ã®`~navi~handler~promise$ãŒæ±ºç€ã™ã‚‹ã¾ã§
â—
Until all promises returned from handlers passed to intercept() have settled
<td>
ãã‚Œã‚’é©åˆ‡ã«ï¼»
è§£æ±ºã§ãã‚‹ï¼å´ä¸‹ã§ãã‚‹
ï¼½ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that we can resolve or reject it appropriately
</table>

<table class="_nav-tracking grid-table">
<caption>
é- `traverse$l ~naviç”¨
â—
For "traverse" navigations
</caption>
<thead>
<tr><th>
çŠ¶æ…‹
â—
State
<th>
è¿½è·¡æœŸé–“
â—
Duration
<th>
èª¬æ˜
â—
Explanation
<tbody>

<tr><td>
`state$mbN
ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
â—
Any state
<td>
~eventã‚’ç™ºç«ã—ã¦ã„ã‚‹é–“
â—
For the duration of event firing
<td>
å½“ã®~eventç™ºç«ãŒ`å–æ¶ˆã•ã‚Œã‚‹ï¼ ~DOM4#canceled-flag$ã“ã¨ãªãå®Œé‚ã—ãŸå ´åˆã«ï¼Œ
ç¾åœ¨ã®~entryã®`~navi~APIçŠ¶æ…‹$shEã‚’æ›´æ–°ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that we can update the current entry's navigation API state if the event finishes firing without being canceled
</table>

<table class="_nav-tracking grid-table">
<caption>
`traverse$l ~naviç”¨
â—
For "traverse" navigations
</caption>
<thead>
<tr><th>
çŠ¶æ…‹
â—
State
<th>
è¿½è·¡æœŸé–“
â—
Duration
<th>
èª¬æ˜
â—
Explanation
<tbody>

<tr><td>
`info$mbN
ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
â—
Any info
<td>
`navigate$et ~eventã‚’ç™ºç«ã™ã‚‹~taskãŒ~queueã•ã‚Œã‚‹ã¾ã§
â—
Until the task is queued to fire the navigate event
<td>
å½“ã®`~sessionå±¥æ­´~è¾¿ã‚Š~queue$navã‚’å·¡ã£ãŸå¾Œã«ï¼Œ
ãã‚Œã‚’åˆ©ç”¨ã—ã¦ `navigate$et ã‚’ç™ºç«ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€‚
â—
So that we can use it to fire the navigate after the trip through the session history traversal queue.
<tr><td>
è¿”ã•ã‚ŒãŸ `committed$mb ~promise
ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰
â—
Any committed promise that was returned
<td>
ï¼ˆåŒã˜~taskã®å†…å´ã§ï¼‰
å½“ã®~sessionå±¥æ­´ãŒæ›´æ–°ã•ã‚Œã‚‹ã¾ã§
â—
Until the session history is updated (inside that same task)
<td>
ãã‚Œã‚’é©åˆ‡ã«ï¼»
è§£æ±ºã§ãã‚‹ï¼å´ä¸‹ã§ãã‚‹
ï¼½ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that we can resolve or reject it appropriately
<tr><td>
`intercept()$mE ã¯~callã•ã‚ŒãŸã‹ã©ã†ã‹
â—
Whether intercept() was called
<td>
ï¼ˆåŒã˜~taskã®å†…å´ã§ï¼‰
å½“ã®~sessionå±¥æ­´ãŒæ›´æ–°ã•ã‚Œã‚‹ã¾ã§
â—
Until the session history is updated (inside that same task)
<td>
`scroll$mb ~optionã«ä¸ãˆã‚‰ã‚ŒãŸæŒ™å‹•ãŒå„ªå…ˆã•ã‚Œã‚‹å ´åˆã«ï¼Œé€šå¸¸ã®~scrollå¾©æ—§~logicã‚’æŠ‘æ­¢ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚
â—
So that we can suppress the normal scroll restoration logic in favor of the behavior given by the scroll option
</table>

<p>
æ¬¡ã®ã‚ˆã†ãª~webé–‹ç™ºè€…~codeã«å› ã‚Šã€ï¼»
æ‰€ä¸ã®æ™‚ç‚¹ã§è¦è«‹ã•ã‚ŒãŸ~naviã¯ï¼Œä¸€ã¤ã—ã‹ãªã„
ï¼½ã¨ã¯è¦‹åšã›ãªã„ï¼š
â—
We also cannot assume there is only a single navigation requested at any given time, due to web developer code such as:
</p>

<pre class="js-code">
const %p1 = navigation.navigate(%url1).finished;
const %p2 = navigation.navigate(%url2).finished;
</pre>

<p>
ã™ãªã‚ã¡ï¼Œã“ã®å±€é¢ã§ã¯ã€
%url2 ã¸~navigateã—ã¦ã„ã‚‹é–“ã‚‚ï¼»
~promise %p1 ã‚’å´ä¸‹ã§ãã‚‹ã‚ˆã†ï¼Œ %p1 ãŒå±…ç¶šã‘ã‚‹
ï¼½ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
2 åº¦ç›®ã® `navigate()$mN ãŒ~callã•ã‚ŒãŸæ™‚ç‚¹ã§ï¼Œ
é€²è¡Œä¸­ãª~naviç”¨ã®~promiseã‚’å˜ã«æ¨ã¦ç½®ãã‚ã‘ã«ã¯ã„ã‹ãªã„ã€‚
â—
That is, in this scenario, we need to ensure that while navigating to url2, we still have the promise p1 around so that we can reject it. We can't just get rid of any ongoing navigation promises the moment the second call to navigate() happens.
</p>

<p>
ã“ã‚Œã‚’ã™ã¹ã¦æˆé‚ã’ã‚‹ãŸã‚ã€
å„ `Navigation$I ã«ã¯ï¼Œæ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ã‚’çµä»˜ã‘ã‚‹ã“ã¨ã«ãªã£ãŸï¼š
â—
We end up accomplishing all this by associating the following with each Navigation:
</p>
<ul>
	<li>
`é€²è¡Œä¸­ãª~navigate_ev~event@
â‡’
`NavigateEvent$I ï¼ ~NULL
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Ongoing navigate event, a NavigateEvent or null, initially null.
</li>
	<li>
`é€²è¡Œä¸­ãª~naviã®é–“ã«~focusã¯å¤‰åŒ–ã—ãŸã‹@
â‡’
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
Focus changed during ongoing navigation, a boolean, initially false.
</li>
	<li>
`é€²è¡Œä¸­ãª~naviã®é–“ã¯é€šå¸¸ã®~scrollå¾©æ—§ã‚’æŠ‘æ­¢ã™ã‚‹ã‹@
â‡’
çœŸå½å€¤
â€” åˆæœŸ~æ™‚ã¯ ~F ã¨ã™ã‚‹ã€‚
â—
Suppress normal scroll restoration during ongoing navigation, a boolean, initially false.
</li>
	<li>
`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­@
â‡’
`~navi~API~methodè¿½è·¡å­$ï¼ ~NULL
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Ongoing API method tracker, a navigation API method tracker or null, initially null.
</li>
	<li>
`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­@
â‡’
`~navi~API~methodè¿½è·¡å­$ï¼ ~NULL
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Upcoming non-traverse API method tracker, a navigation API method tracker or null, initially null.
</li>
	<li>
`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤@
â‡’
æ–‡å­—åˆ—ã‹ã‚‰`~navi~API~methodè¿½è·¡å­$ã¸ã®`æœ‰é †åº~map$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
â—
Upcoming traverse API method trackers, an ordered map from strings to navigation API method trackers, initially empty.
</li>
</ul>

<p class="note">æ³¨è¨˜ï¼š
ã“ã“ã«æŒ™ã’ãŸçŠ¶æ…‹ã®ã†ã¡ï¼»
`~navi~API~methodè¿½è·¡å­$å†…ã«æ ¼ç´ã•ã‚Œãªã„ã‚‚ã®
ï¼½ã¯ã€ï¼»
~navi~API~methodã‚’ä»‹ã—ã¦èµ·å‹•ã•ã‚ŒãŸã‚‚ã®ä»¥å¤–ã®~navi
ï¼½ç”¨ã«ã‚‚ï¼Œè¿½è·¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
â—
The state here that is not stored in navigation API method trackers is state which needs to be tracked even for navigations that are not initiated via navigation API methods.
</p>

<p>
`~navi~API~methodè¿½è·¡å­@
ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹`~item$sctã‚’ä¼´ã†`æ§‹é€ ä½“$ã§ã‚ã‚‹ï¼š
â—
A navigation API method tracker is a struct with the following items:
</p>
<ul>
	<li>
`~navi~obj@amT
â‡’
ã‚ã‚‹ `Navigation$I
â—
A navigation object, a Navigation
</li>
	<li>
`~key@amT
â‡’
~NULL ï¼ã‚ã‚‹æ–‡å­—åˆ—
â—
A key, a string or null
</li>
	<li>
`å ±@amT
â‡’
ã‚ã‚‹~JSå€¤
â—
An info, a JavaScript value
</li>
	<li>
`ç›´åˆ—å½¢ã®çŠ¶æ…‹@amT
â‡’
~NULL ï¼ã‚ã‚‹`ç›´åˆ—å½¢ã®çŠ¶æ…‹$
â—
A serialized state, a serialized state or null
</li>
	<li>
<p>
`~commitå…ˆ~entry@amT
â‡’
~NULL ï¼ã‚ã‚‹ `NavigationHistoryEntry$I
</p>

<p class="trans-note">ã€
~NULL ã§ãªã„ãªã‚‰ã°ã€
æ–°ãŸã«`~naviã®ç¾åœ¨ã®~entry$ã«ãªã‚‹`~naviå±¥æ­´~entry$ã‚’è¡¨ç¾ã™ã‚‹ã€‚
ã€‘</p>
â—
A committed-to entry, a NavigationHistoryEntry or null
</li>
	<li>
<p>
`~commitæ™‚ã®~promise@amT
â‡’
ã‚ã‚‹~promise
</p>

<p class="trans-note">ã€
ã“ã‚Œã¯ã€
å´ä¸‹ã•ã‚Œãªã„ãªã‚‰ã°ï¼Œ~commitå…ˆ~entryã§è§£æ±ºã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
`å®Œé‚-æ™‚ã®~promise$amTãŒæ±ºç€ã—ãŸã¨ãã‚‚ï¼Œ
ãã‚Œä¼´ã„ï¼ˆã¾ã æ±ºç€ã—ã¦ã„ãªã„ãªã‚‰ã°ï¼‰æ±ºç€ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ã€‘</p>
â—
A committed promise, a promise
</li>
	<li>
<p>
`å®Œé‚-æ™‚ã®~promise@amT
â‡’
ã‚ã‚‹~promise
</p>

<p class="trans-note">ã€
~naviãŒ â€œå®Œé‚ã—ãŸâ€ ã¨ãã«æ±ºç€ã™ã‚‹~promiseã€‚
ã€‘</p>
â—
A finished promise, a promise
</li>
</ul>

<p>
ã“ã‚Œã‚‰ã™ã¹ã¦ã®çŠ¶æ…‹ã¯ã€
ä»¥ä¸‹ã«ä¸ãˆã‚‹~algoãŸã¡ã‚’ä»‹ã—ã¦ç®¡ç†ã•ã‚Œã‚‹ã€‚
â—
All this state is then managed via the following algorithms.
</p>

<div class="algo">
<p>
`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­ã‚’å¿…è¦ãªã‚‰è¨­å®šã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`Navigation$I %~navi,
~JSå€¤ %å ±,
ï¼» `ç›´åˆ—å½¢ã®çŠ¶æ…‹$ï¼ ~NULL ï¼½ %ç›´åˆ—å½¢ã®çŠ¶æ…‹
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To maybe set the upcoming non-traverse API method tracker given a Navigation navigation, a JavaScript value info, and a serialized state-or-null serializedState:
</p>
<ol>
	<li>
%~commitæ™‚ã®~promise ~LET `æ–°ãŸãª~promise$( %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let committedPromise andï¼¼
</li>
	<li>
%å®Œé‚-æ™‚ã®~promise ~LET `æ–°ãŸãª~promise$( %~navi ã«`é–¢é€£ãª~realm$ )
â—
finishedPromise be new promises created in navigation's relevant realm.
</li>
	<li>
<p>
`~promiseã‚’å–æ‰±æ¸ˆã¿ã¨ã—ã¦~markã™ã‚‹$( %å®Œé‚-æ™‚ã®~promise )
â—
Mark as handled finishedPromise.
</p>

<div class="note">
<p id="note-mark-as-handled-navigation-api-finished">
~webé–‹ç™ºè€…ã¯ã€
%å®Œé‚-æ™‚ã®~promise ãŒå´ä¸‹ã•ã‚Œã‚‹ã“ã¨ã«ã¤ã„ã¦~careã™ã‚‹ã¨ã¯é™ã‚‰ãªã„ï¼š
â—
The web developer doesnâ€™t necessarily care about finishedPromise being rejected:
</p>
		<ul>
			<li>
é–‹ç™ºè€…ã¯ã€
%~commitæ™‚ã®~promise ã«é™ã‚Š~careã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
â—
They might only care about committedPromise.
</li>
			<li>
é–‹ç™ºè€…ã¯ã€
åŒã˜~taskã®ä¸­ã§è¤‡æ•°ã®~naviã‚’åŒæœŸçš„ã«è¡Œã†ã“ã¨ã‚‚ã‚ã‚‹ã€‚
ãã®äº‹ä¾‹ã§ã¯ã€
æœ€å¾Œã®~naviä»¥å¤–ã¯ï¼Œã™ã¹ã¦ä¸­æ­¢ã•ã‚Œã‚‹ï¼ˆãã‚Œã‚‰ã® %å®Œé‚-æ™‚ã®~promise ã‚’å´ä¸‹ã•ã›ã‚‹ï¼‰ã“ã¨ã«ãªã‚‹ã€‚
ã“ã‚Œã¯ã€
~appã®~bugã§ã‚ã‚‹å ´åˆã‚‚ã‚ã‚ã†ãŒï¼Œå˜ã«å½“ã®~appã‚’æˆã™ï¼»
äº’ã„ã®å‹•ä½œã‚’ä¸Šæ›¸ãã—ã¦ã„ã‚‹ç•°ç¨®ãªå„éƒ¨
ï¼½ã‚’æˆã™å‰µç™ºçš„ãªç‰¹èƒ½ã§ã‚ã‚‹å ´åˆã‚‚ã‚ã‚‹ã€‚
â—
They could be doing multiple synchronous navigations within the same task, in which case all but the last will be aborted (causing their finishedPromise to reject). This could be an application bug, but also could just be an emergent feature of disparate parts of the application overriding each others' actions.
</li>
			<li>
é–‹ç™ºè€…ã¯ã€ï¼»
é·ç§»ã®å¤±æ•—ã«ã¤ã„ã¦ã®é€šé”ã‚’ %å®Œé‚-æ™‚ã®~promise ä»¥å¤–ã®ã‚‚ã®ã§~listenã™ã‚‹
ï¼½ã“ã¨ã‚’é¸å¥½ã™ã‚‹ã“ã¨ã‚‚ã‚ã‚ã†
â€” ä¾‹
â‡’ï¼ƒ
`navigateerror$et ~eventï¼
`navigation.transition.finished$c ãŒè¿”ã™~promise
â—
They might prefer to listen to other transition-failure signals instead of finishedPromise, e.g., the navigateerror event, or the navigation.transition.finished promise.
</li>
		</ul>
<p>
ãã®ã‚ˆã†ãªã‚ã‘ã§ã€
%å®Œé‚-æ™‚ã®~promise ã‚’
â€” ãã‚ŒãŒ `unhandledrejection$et ~eventã‚’æ±ºã—ã¦èª˜ç™ºã—ãªã„ã‚ˆã† â€”
å–æ‰±æ¸ˆã¿ã¨ã—ã¦~markã™ã‚‹ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ã€‚
â—
As such, we mark it as handled to ensure that it never triggers unhandledrejection events.
</p>
</div>
	</li>
	<li>
%~API~methodè¿½è·¡å­ ~LET æ–°ãŸãª`~navi~API~methodè¿½è·¡å­$
â€” ãã®
â‡’ï¼ƒ
`~navi~obj$amT ~SET %~navi,
`~key$amT ~SET ~NULL,
`å ±$amT ~SET %å ±,
`ç›´åˆ—å½¢ã®çŠ¶æ…‹$amT ~SET %ç›´åˆ—å½¢ã®çŠ¶æ…‹,
`~commitå…ˆ~entry$amT ~SET ~NULL,
`~commitæ™‚ã®~promise$amT ~SET %~commitæ™‚ã®~promise,
`å®Œé‚-æ™‚ã®~promise$amT ~SET %å®Œé‚-æ™‚ã®~promise
â—
Let apiMethodTracker be a new navigation API method tracker with:
â—
navigation object
â€¢ navigation
key
â€¢ null
info
â€¢ info
serialized state
â€¢ serializedState
committed-to entry
â€¢ null
committed promise
â€¢ committedPromise
finished promise
â€¢ finishedPromise
</li>
	<li>
~Assertï¼š
%~navi ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~EQ ~NULL
â—
Assert: navigation's upcoming non-traverse API method tracker is null.
</li>
	<li id="dont-always-set-upcoming-non-traverse-api-method-tracker">
<p>
~IFï¼»
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ãªã„
ï¼½
â‡’
%~navi ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~SET %~API~methodè¿½è·¡å­
â—
If navigation does not have entries and events disabled, then set navigation's upcoming non-traverse API method tracker to apiMethodTracker.
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹å ´åˆï¼š
â—
If navigation has entries and events disabled, thenï¼¼
</p>
		<ul>
			<li>
ï¼»
%~commitæ™‚ã®~promise, %å®Œé‚-æ™‚ã®~promise
ï¼½ã¯æ±ºã—ã¦å……è¶³ã•ã‚Œãªããªã‚‹
ï¼ˆãã®ã‚ˆã†ãª`æ–‡æ›¸$ç”¨ã«ã¯ã€
`NavigationHistoryEntry$I ~objã¯æ±ºã—ã¦ä½œæˆã•ã‚Œãªã„ã®ã§ï¼Œãã‚Œã‚‰ã‚’è§£æ±ºã™ã‚‹ã‚‚ã®ã‚‚ç„¡ã„ï¼‰
â—
committedPromise and finishedPromise will never fulfill (since we never create a NavigationHistoryEntry object for such Documents, and so we have nothing to resolve them with);ï¼¼
</li>
			<li>
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ã‚’é©ç”¨ã™ã‚‹ `NavigationHistoryEntry$I ã¯ç„¡ã„ã€‚
â—
there is no NavigationHistoryEntry to apply serializedState to;ï¼¼
</li>
			<li>
%å ± ã‚’å«ã‚ã‚‹ `navigate$et ~eventã¯ç„¡ã„ã€‚
â—
and there is no navigate event to include info with.ï¼¼
</li>
		</ul>
<p>
ãªã®ã§ã€
çµå±€ï¼Œã“ã®~API~method~callã‚’è¿½è·¡ã™ã‚‹å¿…è¦ã‚‚ç„¡ããªã‚‹ã€‚
â—
So, we don't need to track this API method call after all.
</p>
</div>
	</li>
	<li>
~RET %~API~methodè¿½è·¡å­
â—
Return apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­ã‚’è¿½åŠ ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi, æ–‡å­—åˆ— %è¡Œå…ˆ~key, ~JSå€¤ %å ± )
ã«å¯¾ã—ï¼š
â—
To add an upcoming traverse API method tracker given a Navigation navigation, a string destinationKey, and a JavaScript value info:
</p>
<ol>
	<li>
%~commitæ™‚ã®~promise ~LET `æ–°ãŸãª~promise$( %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let committedPromise andï¼¼
</li>
	<li>
%å®Œé‚-æ™‚ã®~promise ~LET `æ–°ãŸãª~promise$( %~navi ã«`é–¢é€£ãª~realm$ )
â—
finishedPromise be new promises created in navigation's relevant realm.
</li>
	<li>
<p>
`~promiseã‚’å–æ‰±æ¸ˆã¿ã¨ã—ã¦~markã™ã‚‹$( %å®Œé‚-æ™‚ã®~promise )
â—
Mark as handled finishedPromise.
</p>

<p class="note">æ³¨è¨˜ï¼š
ãªãœã“ã‚Œã‚’è¡Œã†ã‹ã«ã¤ã„ã¦ã¯ã€
`ä¸Šã®è«–ç‚¹ï¼ #note-mark-as-handled-navigation-api-finished$ã‚’è¦‹ã‚ˆã€‚
â—
See the previous discussion about why this is done.
</p>
	</li>
	<li>
%~API~methodè¿½è·¡å­ ~LET æ–°ãŸãª`~navi~API~methodè¿½è·¡å­$
â€” ãã®
â‡’ï¼ƒ
`~navi~obj$amT ~SET %~navi,
`~key$amT ~SET %è¡Œå…ˆ~key,
`å ±$amT ~SET %å ±,
`ç›´åˆ—å½¢ã®çŠ¶æ…‹$amT ~SET ~NULL,
`~commitå…ˆ~entry$amT ~SET ~NULL,
`~commitæ™‚ã®~promise$amT ~SET %~commitæ™‚ã®~promise,
`å®Œé‚-æ™‚ã®~promise$amT ~SET %å®Œé‚-æ™‚ã®~promise
â—
Let apiMethodTracker be a new navigation API method tracker with:
â—
navigation object
â€¢ navigation
key
â€¢ destinationKey
info
â€¢ info
serialized state
â€¢ null
committed-to entry
â€¢ null
committed promise
â€¢ committedPromise
finished promise
â€¢ finishedPromise
</li>
	<li>
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %è¡Œå…ˆ~key ] ~SET %~API~methodè¿½è·¡å­
â—
Set navigation's upcoming traverse API method trackers[destinationKey] to apiMethodTracker.
</li>
	<li>
~RET %~API~methodè¿½è·¡å­
â—
Return apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`æ¥ãŸã‚‹~API~methodè¿½è·¡å­ã‚’é€²è¡Œä¸­ã«ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi, ï¼»
æ–‡å­—åˆ—ï¼ ~NULL
ï¼½ %è¡Œå…ˆ~key )
ã«å¯¾ã—ï¼š
â—
To promote an upcoming API method tracker to ongoing given a Navigation navigation and a string-or-null destinationKey:
</p>
<ol>
	<li>
~Assertï¼š
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~EQ ~NULL
â—
Assert: navigation's ongoing API method tracker is null.
</li>
	<li>
<p>
~IFï¼»
%è¡Œå…ˆ~key ~NEQ ~NULL
ï¼½ï¼š
â—
If destinationKey is not null, then:
</p>
		<ol>
			<li>
~Assertï¼š
%~navi ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~EQ ~NULL
â—
Assert: navigation's upcoming non-traverse API method tracker is null.
</li>
			<li>
<p>
~IFï¼»
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %è¡Œå…ˆ~key ] ~NEQ Îµ
ï¼½ï¼š
â—
If navigation's upcoming traverse API method trackers[destinationKey] exists, then:
</p>
				<ol>
					<li>
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~SET %~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %è¡Œå…ˆ~key ]
â—
Set navigation's ongoing API method tracker to navigation's upcoming traverse API method trackers[destinationKey].
</li>
					<li>
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %è¡Œå…ˆ~key ] ~SET Îµ
â—
Remove navigation's upcoming traverse API method trackers[destinationKey].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
		<ol>
			<li>
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~SET %~navi ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$
â—
Set navigation's ongoing API method tracker to navigation's upcoming non-traverse API method tracker.
</li>
			<li>
%~navi ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~SET ~NULL
â—
Set navigation's upcoming non-traverse API method tracker to null.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`è¿½è·¡å­ã‚’ç‰‡ä»˜ã‘ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~navi~API~methodè¿½è·¡å­$ %~API~methodè¿½è·¡å­ )
ã«å¯¾ã—ï¼š
â—
To clean up a navigation API method tracker apiMethodTracker:
</p>
<ol>
	<li>
%~navi ~LET %~API~methodè¿½è·¡å­ ã®`~navi~obj$amT
â—
Let navigation be apiMethodTracker's navigation object.
</li>
	<li>
~IFï¼»
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~EQ %~API~methodè¿½è·¡å­
ï¼½
â‡’
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~SET ~NULL
â—
If navigation's ongoing API method tracker is apiMethodTracker, then set navigation's ongoing API method tracker to null.
</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
		<ol>
			<li>
%~key ~LET %~API~methodè¿½è·¡å­ ã®`~key$amT
â—
Let key be apiMethodTracker's key.
</li>
			<li>
~Assertï¼š
%~key ~NEQ ~NULL
â—
Assert: key is not null.
</li>
			<li>
~Assertï¼š
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %~key ] ~NEQ Îµ
â—
Assert: navigation's upcoming traverse API method trackers[key] exists.
</li>
			<li>
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$[ %~key ] ~SET Îµ
â—
Remove navigation's upcoming traverse API method trackers[key].
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~commitå…ˆ~entryã«ã¤ã„ã¦é€šçŸ¥ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`~navi~API~methodè¿½è·¡å­$ %~API~methodè¿½è·¡å­
`NavigationHistoryEntry$I %~NHE
â—çµ‚
ã«å¯¾ã—ï¼š
â—
To notify about the committed-to entry given a navigation API method tracker apiMethodTracker and a NavigationHistoryEntry nhe:
</p>
<ol>
	<li>
%~API~methodè¿½è·¡å­ ã®`~commitå…ˆ~entry$amT ~SET %~NHE
â—
Set apiMethodTracker's committed-to entry to nhe.
</li>
	<li>
<p>
~IFï¼»
%~API~methodè¿½è·¡å­ ã®`ç›´åˆ—å½¢ã®çŠ¶æ…‹$amT ~NEQ ~NULL
ï¼½
â‡’
%~NHE ã®`~sessionå±¥æ­´~entry$nheã®`~navi~APIçŠ¶æ…‹$shE ~SET %~API~methodè¿½è·¡å­ ã®`ç›´åˆ—å½¢ã®çŠ¶æ…‹$amT
â—
If apiMethodTracker's serialized state is not null, then set nhe's session history entry's navigation API state to apiMethodTracker's serialized state.
</p>

<p class="note">æ³¨è¨˜ï¼š
~NULL ã®å ´åˆã€
`navigation.traverseTo()$c ã‚’ä»‹ã—ã¦ %~NHE ã¸è¾¿ã£ã¦ã„ã‚‹
â€” ãã®å ´åˆã€
çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯è¨±å®¹ã•ã‚Œãªã„ã€‚
â—
If it's null, then we're traversing to nhe via navigation.traverseTo(), which does not allow changing the state.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ™‚ç‚¹ã§ã€
%~API~methodè¿½è·¡å­ ã®`ç›´åˆ—å½¢ã®çŠ¶æ…‹$amTã¯ï¼Œã‚‚ã¯ã‚„å¿…è¦ãªããªã‚‹
â€” å®Ÿè£…ã¯ã€
`~navi~API~methodè¿½è·¡å­$ãŒå­˜ç¶šã™ã‚‹é™ã‚Š ãã‚ŒãŒç”Ÿå­˜ã—ç¶šã‘ãªã„ã‚ˆã†ï¼Œ
ãã‚Œã‚’~clearã—ãŸã„ã¨æ±‚ã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚ã†ã€‚
â—
At this point, apiMethodTracker's serialized state is no longer needed. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the navigation API method tracker.
</p>
	</li>
	<li>
<p>
`~promiseã‚’è§£æ±ºã™ã‚‹$( %~API~methodè¿½è·¡å­ ã®`~commitæ™‚ã®~promise$amT, %~NHE )
â—
Resolve apiMethodTracker's committed promise with nhe.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ™‚ç‚¹ã§ã€
%~API~methodè¿½è·¡å­ ã®`~commitæ™‚ã®~promise$amTãŒå¿…è¦ã«ãªã‚‹ã®ã¯ï¼Œ
ãã‚ŒãŒ ã¾ã ä½œè€…~codeã¸è¿”ã•ã‚Œã¦ãªã„äº‹ä¾‹ã«é™ã‚‰ã‚Œã‚‹ã€‚
å®Ÿè£…ã¯ã€
`~navi~API~methodè¿½è·¡å­$ãŒå­˜ç¶šã™ã‚‹é™ã‚Š ãã‚ŒãŒç”Ÿå­˜ã—ç¶šã‘ãªã„ã‚ˆã†ï¼Œ
ãã‚Œã‚’~clearã—ãŸã„ã¨æ±‚ã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚ã†ã€‚
â—
At this point, apiMethodTracker's committed promise is only needed in cases where it has not yet been returned to author code. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the navigation API method tracker.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`å®Œé‚-æ™‚ã®~promiseã‚’è§£æ±ºã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~navi~API~methodè¿½è·¡å­$ %~API~methodè¿½è·¡å­ )
ã«å¯¾ã—ï¼š
â—
To resolve the finished promise for a navigation API method tracker apiMethodTracker:
</p>
<ol>
	<li>
%~commitå…ˆ~entry ~LET %~API~methodè¿½è·¡å­ ã®`~commitå…ˆ~entry$amT
â—
â†“</li>
	<li>
~Assertï¼š
%~commitå…ˆ~entry ~NEQ ~NULL
â—
Assert: apiMethodTracker's committed-to entry is not null.
</li>
	<li>
`~promiseã‚’è§£æ±ºã™ã‚‹$( %~API~methodè¿½è·¡å­ ã®`å®Œé‚-æ™‚ã®~promise$amT, %~commitå…ˆ~entry )
â—
Resolve apiMethodTracker's finished promise with its committed-to entry.
</li>
	<li>
`è¿½è·¡å­ã‚’ç‰‡ä»˜ã‘ã‚‹$( %~API~methodè¿½è·¡å­ )
â—
Clean up apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~navi~API~methodè¿½è·¡å­$ %~API~methodè¿½è·¡å­, ~JSå€¤ %ä¾‹å¤– )
ã«å¯¾ã—ï¼š
â—
To reject the finished promise for a navigation API method tracker apiMethodTracker with a JavaScript value exception:
</p>
<ol>
	<li>
<p>
`~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­ ã®`~commitæ™‚ã®~promise$amT, %ä¾‹å¤– )
â—
Reject apiMethodTracker's committed promise with exception.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€
ã“ã“ã¾ã§ã«ï¼»
%~API~methodè¿½è·¡å­ ã®`~commitæ™‚ã®~promise$amTãŒ
`~commitå…ˆ~entryã«ã¤ã„ã¦é€šçŸ¥ã™ã‚‹$ã“ã¨ã‚’ä»‹ã—ã¦è§£æ±ºã•ã‚ŒãŸ
ï¼½å ´åˆã«ã¯ï¼Œä½•ã‚‚ã—ãªã„ã“ã¨ã«ãªã‚‹ã€‚
â—
This will do nothing if apiMethodTracker's committed promise was previously resolved via notify about the committed-to entry.
</p>
	</li>
	<li>
`~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­ ã®`å®Œé‚-æ™‚ã®~promise$amT, %ä¾‹å¤– )
â—
Reject apiMethodTracker's finished promise with exception.
</li>
	<li>
`è¿½è·¡å­ã‚’ç‰‡ä»˜ã‘ã‚‹$( %~API~methodè¿½è·¡å­ )
â—
Clean up apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi, `DOMException$I %~error ~DF Îµ )
ã«å¯¾ã—ï¼š
â—
To abort the ongoing navigation given a Navigation navigation and an optional DOMException error:
</p>
<ol>
	<li>
%~event ~LET %~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$
â—
Let event be navigation's ongoing navigate event.
</li>
	<li>
~Assertï¼š
%~event ~NEQ ~NULL
â—
Assert: event is not null.
</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã«~focusã¯å¤‰åŒ–ã—ãŸã‹$ ~SET ~F
â—
Set navigation's focus changed during ongoing navigation to false.
</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã¯é€šå¸¸ã®~scrollå¾©æ—§ã‚’æŠ‘æ­¢ã™ã‚‹ã‹$ ~SET ~F
â—
Set navigation's suppress normal scroll restoration during ongoing navigation to false.
</li>
	<li>
~IFï¼»
%~error ~EQ Îµ
ï¼½
â‡’
%~error ~SET %~navi ã«`é–¢é€£ãª~realm$å†…ã«ä½œæˆã•ã‚Œã‚‹æ–°ãŸãª `AbortError$E ä¾‹å¤–
â—
If error was not given, then let error be a new "AbortError" DOMException created in navigation's relevant realm.
</li>
	<li>
~IFï¼»
%~event ã®`é…é€-ä¸­ã‹$ev ~EQ ~T
ï¼½
â‡’
%~event ã®`å–æ¶ˆã•ã‚ŒãŸã‹$ev ~SET ~T
â—
If event's dispatch flag is set, then set event's canceled flag to true.
</li>
	<li>
`~navigate_ev~eventã‚’ä¸­æ­¢ã™ã‚‹$( %~event, ã€ %~error ï¼Ÿã€‘ )
â—
Abort event.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate_ev~eventã‚’ä¸­æ­¢ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I %~event, %äº‹ç”± )
ã«å¯¾ã—ï¼š
â—
To abort a NavigateEvent event given reason:
</p>
<ol>
	<li>
%~navi ~LET %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã®`~navi~API$
â—
Let navigation be event's relevant global object's navigation API.
</li>
	<li>
`ä¸­æ­¢-ã‚’é€šé”ã™ã‚‹$aC( %~event ã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEv, %äº‹ç”± )
â—
Signal abort on event's abort controller given reason.
</li>
	<li>
<p>
%~errorå ± ~LET `~erroræƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹$( %äº‹ç”± )
â—
Let errorInfo be the result of extracting error information from reason.
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
%~errorå ± ã‚’æˆã™~propãŸã¡ã¯ã€
ä¾‹ãˆã°ï¼š
</p>
		<ul>
			<li>
`window.stop()ï¼ ~WINDOW#dom-window-stop$c ã‚’~callã—ãŸã“ã¨ã«ã‚ˆã‚Šï¼Œ
ã“ã®~algoã«é”ã—ãŸå ´åˆ
â‡’
ãŠãã‚‰ãï¼Œ~scriptã‚’æˆã™ï¼»
å½“ã® `window.stop()^c ã‚’~callã—ãŸè¡Œl
ï¼½ã«åŸºã¥ã„ã¦åˆæœŸåŒ–ã•ã‚Œã‚‹ã€‚
</li>
			<li>
åˆ©ç”¨è€…ãŒåœæ­¢-~buttonã‚’~clickã—ãŸã“ã¨ã«ã‚ˆã‚Šï¼Œ
ã“ã®~algoã«é”ã—ãŸå ´åˆ
â‡’
ãŠãã‚‰ãï¼Œï¼»
ç©º~æ–‡å­—åˆ—ã‚„ 0 ã®æ§˜ãªæ—¢å®šã®å€¤
ï¼½ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ã€‚
</li>
		</ul>
â—
For example, if this algorithm is reached because of a call to window.stop(), these properties would probably end up initialized based on the line of script that called window.stop().ï¼¼
But if it's because the user clicked the stop button, these properties would probably end up with default values like the empty string or 0.
</div>
	</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ ~SET ~NULL
â—
Set navigation's ongoing navigate event to null.
</li>
	<li>
<p>
~IFï¼»
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~NEQ ~NULL
ï¼½
â‡’
`å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­, %~errorâ€  )
</p>

<p class="trans-note">ã€â€ 
æœªå®šç¾©ãªå¤‰æ•°
â€” %äº‹ç”±, %~errorå ± ã©ã¡ã‚‰ã‹ãŒæ„å›³ã•ã‚Œã‚‹ã¨æ€ã‚ã‚Œã‚‹ï¼ˆä»¥ä¸‹ã‚‚åŒæ§˜ï¼‰ã€‚
ã€‘</p>
â—
If navigation's ongoing API method tracker is non-null, then reject the finished promise for apiMethodTracker with error.
</li>
	<li>
`~eventã‚’ç™ºç«ã™ã‚‹$( %~navi, `navigateerror$et, `ErrorEvent$I )
â€” æ¬¡ã®ã‚ˆã†ã«åˆæœŸåŒ–ã—ã¦
â‡’ï¼ƒ
`ErrorEvent$I ã«ã‚ˆã‚‹è¿½åŠ çš„ãªå„~å±æ€§ã‚’ %~errorå ± ã«å‰‡ã£ã¦è¨­å®šã™ã‚‹
â—
Fire an event named navigateerror at navigation using ErrorEvent, with additional attributes initialized according to errorInfo.
</li>
	<li>
~IFï¼»
%~navi ã®`é·ç§»$ ~EQ ~NULL
ï¼½
â‡’
~RET
â—
If navigation's transition is null, then return.
</li>
	<li>
`~promiseã‚’å´ä¸‹ã™ã‚‹$( %~navi ã®`é·ç§»$ã®`~commitæ™‚ã®~promise$nTr, %~error )
â—
Reject navigation's transition's committed promise with error.
</li>
	<li>
`~promiseã‚’å´ä¸‹ã™ã‚‹$( %~navi ã®`é·ç§»$ã®`å®Œé‚-æ™‚ã®~promise$nTr, %~error )
â—
Reject navigation's transition's finished promise with error.
</li>
	<li>
%~navi ã®`é·ç§»$ ~SET ~NULL
â—
Set navigation's transition to null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~naviã‚’ä¸­æ­¢ã—ãŸã“ã¨ã«ã¤ã„ã¦~navi~APIã«ä¼ãˆã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~navigable$ %~navigable )
ã«å¯¾ã—ï¼š
â—
To inform the navigation API about aborting navigation in a navigable navigable:
</p>
<ol>
	<li>
%~window ~LET %~navigable ã«ã¦`ä½œå‹•ä¸­ãª~window$nav
â—
â†“</li>
	<li>
~IFï¼»
ã“ã®~algoã¯ %~window ã«`é–¢é€£ãª~agent$ã®`~event~loop$aGä¸Šã§èµ°ã£ã¦ã„ã‚‹
ï¼½
â‡’
ä¸‹ã«ä¸ãˆã‚‹ `ä¸­æ­¢-ç”¨ã®æ‰‹ç¶šã^i()
â—
If this algorithm is running on navigable's active window's relevant agent's event loop, then continue on to the following steps.ï¼¼
</li>
	<li>
<p>
~ELSE
â‡’
`å¤§åŸŸ~taskã‚’~queueã™ã‚‹$( `~naviã¨è¾¿ã‚Š~task~source$, %~window, ä¸‹ã«ä¸ãˆã‚‹ `ä¸­æ­¢-ç”¨ã®æ‰‹ç¶šã^i )
â—
Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to run the following steps.
</p>
	</li>
</ol>

<div class="algo">
<p>
ä¸Šã§åˆ©ç”¨ã•ã‚Œã‚‹ `ä¸­æ­¢-ç”¨ã®æ‰‹ç¶šã^i ã¯ï¼š
â—
â†‘</p>
<ol>
	<li>
%~navi ~LET %~navigable ã«ã¦`ä½œå‹•ä¸­ãª~window$nav ã®`~navi~API$
â—
Let navigation be navigable's active window's navigation API.
</li>
	<li>
~IFï¼»
%~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ ~EQ ~NULL
ï¼½
â‡’
~RET
â—
If navigation's ongoing navigate event is null, then return.
</li>
	<li>
`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹$( %~navi )
â—
Abort the ongoing navigation given navigation.
</li>
</ol>
</div>
</div>

<div class="algo">
<p>
`å­~navigableã®ç ´å£Šã«ã¤ã„ã¦~navi~APIã«ä¼ãˆã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `~navigable$ %~navigable )
ã«å¯¾ã—ï¼š
â—
To inform the navigation API about child navigable destruction given a navigable navigable:
</p>
<ol>
	<li>
`~naviã‚’ä¸­æ­¢ã—ãŸã“ã¨ã«ã¤ã„ã¦~navi~APIã«ä¼ãˆã‚‹$( %~navigable )
â—
Inform the navigation API about aborting navigation in navigable.
</li>
	<li>
%~navi ~LET %~navigable ã«ã¦`ä½œå‹•ä¸­ãª~window$nav ã®`~navi~API$
â—
Let navigation be navigable's active window's navigation API.
</li>
	<li>
%è¾¿ã‚Š~API~methodè¿½è·¡å­~ç¾¤ ~LET %~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$ã‚’`~cloneã™ã‚‹$
â—
Let traversalAPIMethodTrackers be a clone of navigation's upcoming traverse API method trackers.
</li>
	<li>
%è¾¿ã‚Š~API~methodè¿½è·¡å­~ç¾¤ ã‚’æˆã™
~EACH( %~API~methodè¿½è·¡å­ )
ã«å¯¾ã—
â‡’
`å®Œé‚-æ™‚ã®~promiseã‚’å´ä¸‹ã™ã‚‹$( %~API~methodè¿½è·¡å­, %~navi ã«`é–¢é€£ãª~realm$å†…ã«ä½œæˆã•ã‚Œã‚‹æ–°ãŸãª `AbortError$E ä¾‹å¤– )
â—
For each apiMethodTracker of traversalAPIMethodTrackers: reject the finished promise for apiMethodTracker with a new "AbortError" DOMException created in navigation's relevant realm.
</li>
</ol>
</div>

<hr>

<p>
é€²è¡Œä¸­ãª~naviã®æ¦‚å¿µã¯ã€
~webé–‹ç™ºè€…ã«ã¯ï¼Œ
`navigation.transition$c ~propã‚’é€šã—ã¦æœ€ã‚‚ç›´ã«å…¬é–‹ã•ã‚Œã‚‹
â€” ãã‚Œã¯ã€
ã€å½“ã®~naviã®`é·ç§»$ã‚’è¡¨ç¾ã™ã‚‹ã€‘
`NavigationTransition$I ~interfaceã®~instanceã§ã‚ã‚‹ï¼š
â—
The ongoing navigation concept is most-directly exposed to web developers through the navigation.transition property, which is an instance of the NavigationTransition interface:
</p>

<pre class="idl">
[Exposed=Window]
interface `NavigationTransition@I {
  readonly attribute `NavigationType$I `navigationType$mT;
  readonly attribute `NavigationHistoryEntry$I `from$mT;
  readonly attribute `Promise$&lt;undefined&gt; `committed$mT;
  readonly attribute `Promise$&lt;undefined&gt; `finished$mT;
};
</pre>

<dl class="domintro">
	<dt>`navigation$m.`transition$mN</dt>
	<dd>
ï¼»
`navigatesuccess$et ï¼ `navigateerror$et
ï¼½ã‚’ç™ºç«ã™ã‚‹æ®µéšã«ã¾ã é”ã—ã¦ãªã„é€²è¡Œä¸­ãª~naviã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ `NavigationTransition$I
â€” ãã®ã‚ˆã†ãª`é·ç§»$ã¯é€²è¡Œä¸­ã§ãªã„ãªã‚‰ã°ï¼Œ ~NULL ã€‚
â—
A NavigationTransition representing any ongoing navigation that hasn't yet reached the navigatesuccess or navigateerror stage, if one exists; or null, if there is no such transition ongoing.
</dd>
	<dd>
`navigation.currentEntry$c
ï¼ˆãŠã‚ˆã³ `location.hrefï¼ ~WINDOW#dom-location-href$c ã®æ§˜ãªä»–ã®~propï¼‰
ã¯ï¼Œ~naviã®éš›ã«å³æ™‚ã«æ›´æ–°ã•ã‚Œã‚‹ã®ã§ã€
`navigation.transition$c ~propã¯ã€
ãã®ã‚ˆã†ãª~naviãŒï¼»
ã€ï¼navigateEvent.intercept()ã«æ¸¡ã•ã‚ŒãŸ~handlerãŸã¡ã€‘
`~navi~handler~promise$ãŸã¡ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰ã«å‰‡ã£ã¦ï¼Œã¾ã å…¨éƒ¨çš„ã«æ±ºç€ã—ã¦ã„ãªã„ã¨ã
ï¼½ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«æœ‰ç”¨ã«ãªã‚‹ã€‚
â—
Since navigation.currentEntry (and other properties like location.href) are updated immediately upon navigation, this navigation.transition property is useful for determining when such navigations are not yet fully settled, according to any handlers passed to navigateEvent.intercept().
</dd>

	<dt>`navigation$m.`transition$mN.`navigationType$mT</dt>
	<dd>
ã“ã®`é·ç§»$ã®ç¨®åˆ¥ã‚’æŒ‡ç¤ºã™ã‚‹æ–‡å­—åˆ—ã‚’æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã¨ã—ã¦è¿”ã™
â‡’ï¼ƒ
`push$l ï¼
`replace$l ï¼
`reload$l ï¼
`traverse$l
â—
One of "push", "replace", "reload", or "traverse", indicating what type of navigation this transition is for.
</dd>

	<dt>`navigation$m.`transition$mN.`from$mT</dt>
	<dd>
ã“ã®é·ç§»ãŒ ã©ã®~entryã‹ã‚‰æ¥ã¦ã„ã‚‹ã‹ã‚’è¡¨ã™ `NavigationHistoryEntry$I ã‚’è¿”ã™ã€‚
ã“ã‚Œã¯ã€
`navigation.currentEntry$c ã¨æ¯”è¼ƒã™ã‚‹ã¨ãã«æœ‰ç”¨ã«ãªã‚Šå¾—ã‚‹ã€‚
â—
The NavigationHistoryEntry from which the transition is coming. This can be useful to compare against navigation.currentEntry.
</dd>

	<dt>`navigation$m.`transition$mN.`committed$mT</dt>
	<dd>
ï¼»
`navigation.currentEntry$c, `~URL$doc
ï¼½ãŒå¤‰æ›´ã•ã‚ŒãŸãªã‚‰å……è¶³ã•ã‚Œã‚‹~promiseã€‚
ã“ã‚Œã¯ã€
ãã® ã™ã¹ã¦ã®~precommit~handlerï¼ˆ `precommitHandler$mb ï¼‰
ã€ `navigation$m ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ã®`~navi~precommit~handler~list$nEvã‚’æˆã™å„~handlerãŒè¿”ã—ãŸ~promiseã€‘
ãŒå……è¶³ã•ã‚ŒãŸå¾Œã«ç”Ÿã˜ã‚‹
â€” ã„ãšã‚Œã‹ãŒå´ä¸‹ã•ã‚ŒãŸå ´åˆã€
å´ä¸‹ã•ã‚Œã‚‹ã€‚
â—
A promise which fulfills once the navigation.currentEntry and URL change. This occurs after all of its precommit handlers are fulfilled. The promise rejects if one or more of the precommit handlers rejects.
</dd>

	<dt>`navigation$m.`transition$mN.`finished$mT</dt>
	<dd>
ï¼»
`navigatesuccess$et ï¼ `navigateerror$et 
ï¼½~eventã®ç™ºç«ã¨åŒæ™‚ã«ï¼»
å……è¶³ã•ã‚Œã‚‹ï¼å´ä¸‹ã•ã‚Œã‚‹
ï¼½~promiseã€‚
â—
A promise which fulfills at the same time as the navigatesuccess fires, or rejects at the same time the navigateerror event fires.
</dd>
</dl>

<p>
å„ `Navigation$I ã«ã¯
`é·ç§»@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â€” ãã‚Œã¯ã€ï¼»
`NavigationTransition$I ï¼ ~NULL
ï¼½ã§ã‚ã‚Šï¼ŒåˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Each Navigation has a transition, which is a NavigationTransition or null, initially null.
</p>

<div class="algo">
`transition@mN
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`é·ç§»$
â—
The transition getter steps are to return this's transition.
</div>

<p>
å„ `NavigationTransition$I ã«ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
â†“</p>
<ul>
	<li>
`~naviç¨®åˆ¥@nTr
â‡’
ã‚ã‚‹ `NavigationType$I
â—
Each NavigationTransition has an associated navigation type, which is a NavigationType.
</li>
	<li>
`~from~entry@nTr
â‡’
ã‚ã‚‹ `NavigationHistoryEntry$I
â—
Each NavigationTransition has an associated from entry, which is a NavigationHistoryEntry.
</li>
	<li>
`~commitæ™‚ã®~promise@nTr
â‡’
ã‚ã‚‹~promise
â—
Each NavigationTransition has an associated committed promise, which is a promise.
</li>
	<li>
`å®Œé‚-æ™‚ã®~promise@nTr
â‡’
ã‚ã‚‹~promise
â—
Each NavigationTransition has an associated finished promise, which is a promise.
</li>
</ul>

<div class="algo">
`navigationType@mT
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~naviç¨®åˆ¥$nTr
â—
The navigationType getter steps are to return this's navigation type.
</div>

<div class="algo">
`from@mT
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~from~entry$nTr
â—
The from getter steps are to return this's from entry.
</div>

<div class="algo">
`committed@mT
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~commitæ™‚ã®~promise$nTr
â—
The committed getter steps are to return this's committed promise.
</div>

<div class="algo">
`finished@mT
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`å®Œé‚-æ™‚ã®~promise$nTr
â—
The finished getter steps are to return this's finished promise.
</div>

				</section>
				<section id="navigation-activation-interface">
<h5 title="The NavigationActivation interface">7.2.6.9. `NavigationActivation^I ~interface</h5>

<pre class="idl">[Exposed=Window]
interface `NavigationActivation@I {
  readonly attribute `NavigationHistoryEntry$I? `from$mNA;
  readonly attribute `NavigationHistoryEntry$I `entry$mNA;
  readonly attribute `NavigationType$I `navigationType$mNA;
};
</pre>

<dl class="domintro">
	<dt>`navigation$m.`activation$mN</dt>
	<dd>
ï¼»
ç¾åœ¨ã®`æ–‡æ›¸$ã€ï¼this Documentã€‘ã‚’ â€œä½œå‹•åŒ–ã—ãŸâ€ æœ€ã‚‚è¿‘éå»ãªéåŒä¸€-æ–‡æ›¸~navi
ï¼½ã«ã¤ã„ã¦ã®æƒ…å ±ã‚’åŒ…å«ã—ã¦ã„ã‚‹ `NavigationActivation$I ã‚’è¿”ã™ã€‚
â—
A NavigationActivation containing information about the most recent cross-document navigation, the navigation that "activated" this Document.
</dd>
	<dd>
ï¼»
`currentEntry$mN, å½“ã®`æ–‡æ›¸$ã®`~URL$doc
ï¼½ã¯ï¼ŒåŒä¸€-æ–‡æ›¸~naviã«å› ã‚Šå¸¸æ™‚~æ›´æ–°ã•ã‚Œå¾—ã‚‹ä¸€æ–¹ã§ã€
`activation$mN ã¯ä¸€å®šã§ã‚ã‚Šç¶šã‘ï¼Œ
ãã®å„~propã¯å½“ã®`æ–‡æ›¸$ãŒå±¥æ­´ã‹ã‚‰`ä½œå‹•åŒ–ã—ç›´ã•ã‚Œï¼ ~HTMLnav#reactivate-a-document$ãŸå ´åˆã«é™ã‚Šæ›´æ–°ã•ã‚Œã‚‹ã€‚
â—
While navigation.currentEntry and the Document's URL can be updated regularly due to same-document navigations, navigation.activation stays constant, and its properties are only updated if the Document is reactivated from history.
</dd>

	<dt>`navigation$m.`activation$mN.`entry$mNA</dt>
	<dd>
ç¾åœ¨ã®`æ–‡æ›¸$ã€ï¼the Documentã€‘ãŒä½œå‹•åŒ–ã•ã‚ŒãŸæ™‚ç‚¹ã«ãŠã‘ã‚‹ `currentEntry$mN ~propã®å€¤ã«ç­‰ä¾¡ãª `NavigationHistoryEntry$I ã‚’è¿”ã™ã€‚
â—
A NavigationHistoryEntry, equivalent to the value of the navigation.currentEntry property at the moment the Document was activated.
</dd>

	<dt>`navigation$m.`activation$mN.`from$mNA</dt>
	<dd>
ç¾åœ¨ã®`æ–‡æ›¸$ã®ç›´å‰ã«ä½œå‹•ä¸­ã§ã‚ã£ãŸ`æ–‡æ›¸$ãŒï¼»
æ¬¡ã‚’æº€ãŸã—ã¦ã„ãŸãªã‚‰ã° ãã‚Œã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ `NavigationHistoryEntry$I ï¼
~ELSE_ ~NULL
ï¼½ã‚’è¿”ã™
â‡’
ï¼»
ç¾åœ¨ã®æ–‡æ›¸ã¨`åŒä¸€-ç”Ÿæˆå…ƒ$ã§ã‚ã‚‹
ï¼½~ANDï¼»
ãã®`åˆæœŸ~about_blankã‹$doc ~EQ ~F
ï¼½
â—
A NavigationHistoryEntry, representing the Document that was active right before the current Document. This will have a value null in case the previous Document was not same origin with this one or if it was the initial about:blank Document.
</dd>
	<dd>
ï¼»
`from$mNA ï¼ `entry$mNA
ï¼½ãŒè¿”ã™ `NavigationHistoryEntry$I ~objã€ãŒè¡¨ç¾ã™ã‚‹`~naviå±¥æ­´~entry$ã€‘ã¯ã€
å±¥æ­´~å†…ã«ç¶­æŒã•ã‚Œãªã„äº‹ä¾‹ã‚‚ã‚ã‚‹
â€” ãã®å ´åˆã€
`traverseTo()$mN ~methodç”¨ã®~targetã«ãªã‚Šå¾—ãªã„ã€‚
ä¾‹ãˆã°ï¼Œ
å½“ã®`æ–‡æ›¸$ã¯ `location.replace()ï¼ #dom-location-replace$c ã‚’åˆ©ç”¨ã—ã¦ä½œå‹•åŒ–ã•ã‚Œå¾—ã‚‹ï¼
å±¥æ­´ã®åˆæœŸ~entryã¯ `history.replaceState()ï¼ #dom-history-replacestate$c ã«ã‚ˆã‚Šç½®æ›ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ãã‚Œã§ã‚‚ã€
ãã‚Œã‚‰ã®~entryã®ï¼»
`url$mH ~prop, `getState()$mH ~method
ï¼½ã¯~accesså¯èƒ½ã«ãªã‚‹ã€‚
â—
There are some cases in which either the from or entry NavigationHistoryEntry objects would not be viable targets for the traverseTo() method, as they might not be retained in history. For example, the Document can be activated using location.replace() or its initial entry could be replaced by history.replaceState(). However, those entries' url property and getState() method are still accessible.
</dd>

	<dt>`navigation$m.`activation$mN.`navigationType$mNA</dt>
	<dd>
ç¾åœ¨ã®`æ–‡æ›¸$ã€ï¼this Documentã€‘ã‚’ä½œå‹•åŒ–ã—ãŸ~naviã®ç¨®åˆ¥ã‚’æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã¨ã—ã¦æŒ‡ç¤ºã™ã‚‹
â‡’ï¼ƒ
`push$l,
`replace$l,
`reload$l,
`traverse$l
â—
One of "push", "replace", "reload", or "traverse", indicating what type of navigation activated this Document.
</dd>
</dl>

<p>
å„ `Navigation$I ã«ã¯
`ä½œå‹•åŒ–@
ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹
â€” ãã‚Œã¯ã€ï¼»
~NULL ï¼ `NavigationActivation$I ~obj
ï¼½ã§ã‚ã‚Šï¼ŒåˆæœŸ~æ™‚ã¯~NULLã¨ã™ã‚‹ã€‚
â—
Each Navigation has an associated activation, which is null or a NavigationActivation object, initially null.
</p>

<p>
å„ `NavigationActivation$I ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ã‚’æœ‰ã™ã‚‹ï¼š
â—
Each NavigationActivation has:
</p>
<ul>
	<li>
`æ—§-~entry@nA
â‡’
~NULL ï¼ ã‚ã‚‹ `NavigationHistoryEntry$I
â—
old entry, null or a NavigationHistoryEntry.
</li>
	<li>
`æ–°-~entry@nA
â‡’
~NULL ï¼ ã‚ã‚‹ `NavigationHistoryEntry$I
â—
new entry, null or a NavigationHistoryEntry.
</li>
	<li>
`~naviç¨®åˆ¥@nA
â‡’
ã‚ã‚‹ `NavigationType$I
â—
navigation type, a NavigationType.
</li>
</ul>

<div class="algo">
`activation@mN
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`ä½œå‹•åŒ–$
â—
The activation getter steps are to return this's activation.
</div>

<div class="algo">
`from@mNA
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`æ—§-~entry$nA
â—
The from getter steps are to return this's old entry.
</div>

<div class="algo">
`entry@mNA
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`æ–°-~entry$nA
â—
The entry getter steps are to return this's new entry.
</div>

<div class="algo">
`navigationType@mNA
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`~naviç¨®åˆ¥$nA
â—
The navigationType getter steps are to return this's navigation type.
</div>

				</section>
				<section id="the-navigate-event">
<h5 title="The navigate event">7.2.6.10. `navigate^et ~event</h5>

<p>
~navi~APIã‚’æˆã™ä¸»è¦ãªç‰¹èƒ½ã¯ã€
`navigate$et ~eventã§ã‚ã‚‹ã€‚
ã“ã®~eventã¯ã€
ï¼ˆ`ç¨®åˆ¥ã‚’å•ã‚ãšï¼ #navigationtype$ï¼‰
ã©ã®~naviã«å¯¾ã—ã¦ã‚‚ç™ºç«ã•ã‚Œï¼Œ
å¤–ã¸è¡Œã~naviã‚’ç›£è¦–ã™ã‚‹ã“ã¨ã‚’~webé–‹ç™ºè€…ã«è¨±å®¹ã™ã‚‹ã€‚
å¤šãã®äº‹ä¾‹ã§ã¯ã€
ã“ã®~eventã® `cancelable$m ã¯ ~T ï¼ˆå–æ¶ˆ-å¯èƒ½ï¼‰ã§ã‚ã‚Šï¼Œ
å½“ã®~naviãŒèµ·ã“ã‚‹ã®ã‚’é˜²æ­¢ã™ã‚‹ã“ã¨ã‚’è¨±å®¹ã™ã‚‹ã€‚
ä»–ã®äº‹ä¾‹ã«ãŠã„ã¦ã¯ã€
å½“ã®~naviã‚’ `NavigateEvent$I ~classã® `intercept()$mE ~methodã‚’åˆ©ç”¨ã—ã¦æ¨ªå–ã™ã‚‹ã“ã¨ã§ï¼ŒåŒä¸€-æ–‡æ›¸ã¸ã®~naviã«ç½®æ›ã§ãã‚‹ã€‚
â—
A major feature of the navigation API is the navigate event. This event is fired on any navigation (in the broad sense of the word), allowing web developers to monitor such outgoing navigations. In many cases, the event is cancelable, which allows preventing the navigation from happening. And in others, the navigation can be intercepted and replaced with a same-document navigation by using the intercept() method of the NavigateEvent class.
</p>

					<section id="the-navigateevent-interface">
<h6 title="The NavigateEvent interface">7.2.6.10.1. `NavigateEvent^I ~interface</h6>

<pre class="idl">
[Exposed=Window]
interface `NavigateEvent@I : `Event$I {
  constructor(DOMString type, `NavigateEventInit$I eventInitDict);

  readonly attribute `NavigationType$I `navigationType$mE;
  readonly attribute `NavigationDestination$I `destination$mE;
  readonly attribute boolean `canIntercept$mE;
  readonly attribute boolean `userInitiated$mE;
  readonly attribute boolean `hashChange$mE;
  readonly attribute `AbortSignal$I `signal$mE;
  readonly attribute `FormData$I? `formData$mE;
  readonly attribute DOMString? `downloadRequest$mE;
  readonly attribute any `info$mE;
  readonly attribute boolean `hasUAVisualTransition$mE;
  readonly attribute Element? `sourceElement$mE;

  undefined `intercept$mE(optional `NavigationInterceptOptions$I options = {});
  undefined `scroll$mE();
};

dictionary `NavigateEventInit@I : `EventInit$I {
  `NavigationType$I `navigationType@mb = `push$l;
  required `NavigationDestination$I `destination@mb;
  boolean `canIntercept@mb = false;
  boolean `userInitiated@mb = false;
  boolean `hashChange@mb = false;
  required `AbortSignal$I `signal@mb;
  `FormData$I? `formData@mb = null;
  DOMString? `downloadRequest@mb = null;
  any `info@mb;
  boolean `hasUAVisualTransition@mb = false;
  `Element$I? `sourceElement@mb = null;
};

dictionary `NavigationInterceptOptions@I {
  `NavigationPrecommitHandler$I `precommitHandler@mb;
  `NavigationInterceptHandler$I `handler@mb;
  `NavigationFocusReset$I `focusReset@mb;
  `NavigationScrollBehavior$I `scroll@mb;
};

enum `NavigationFocusReset@I {
  `after-transition@lF,
  `manual@lF
};

enum `NavigationScrollBehavior@I {
  `after-transition@lS,
  `manual@lS
};

callback `NavigationInterceptHandler@I = `Promise$&lt;undefined&gt; ();
</pre>

<dl class="domintro">
	<dt>%event.`navigationType$mE</dt>
	<dd>
å½“ã®~naviã®ç¨®åˆ¥ã‚’æŒ‡ç¤ºã™ã‚‹æ–‡å­—åˆ—ã‚’æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã¨ã—ã¦è¿”ã™
â‡’ï¼ƒ
`push$l ï¼
`replace$l ï¼
`reload$l ï¼
`traverse$l
â—
One of "push", "replace", "reload", or "traverse", indicating what type of navigation this is.
</dd>

	<dt>%event.`destination$mE</dt>
	<dd>
å½“ã®~naviã®è¡Œå…ˆã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ `NavigationDestination$I ã‚’è¿”ã™ã€‚
â—
A NavigationDestination representing the destination of the navigation.
</dd>

	<dt>%event.`canIntercept$mE</dt>
	<dd>
ã“ã®~naviã‚’æ¨ªå–ã§ãã‚‹
â€” `intercept()$mE ã‚’~callã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€
åŒä¸€-æ–‡æ›¸ã¸ã®~naviã«å¤‰æ›ã—ã¦ï¼Œé€šä¾‹çš„ãªæŒ™å‹•ã‚’ç½®æ›ã§ãã‚‹ â€”
å ´åˆã€
~T ã«ãªã‚‹ã€‚
ä»–ã®å ´åˆã€
~F ã«ãªã‚‹ã€‚
â—
True if intercept() can be called to intercept this navigation and convert it into a same-document navigation, replacing its usual behavior; false otherwise.
</dd>
	<dd>
ã“ã‚Œã¯ï¼Œä¸€èˆ¬çš„ã«è¨€ãˆã°
â€” ã™ãªã‚ã¡ã€
ç¾åœ¨ã®`æ–‡æ›¸$ã®~URLã‚’è¡Œå…ˆ~URLã«`æ›¸ç›´ã›ã‚‹ï¼ ~WINDOW#can-have-its-url-rewritten$ã¨ãã¯ â€”
~T ã«ãªã‚‹ã€‚
ãŸã ã—ã€
éåŒä¸€-æ–‡æ›¸ã¸ã® `traverse$l ~naviã®äº‹ä¾‹ã§ã¯ï¼Œ
å¸¸ã« ~F ã«ãªã‚‹ã€‚
â—
Generally speaking, this will be true whenever the current Document can have its URL rewritten to the destination URL, except for in the case of cross-document "traverse" navigations, where it will always be false.
</dd>

	<dt>%event.`userInitiated$mE</dt>
	<dd>
ã“ã®~naviãŒï¼»
åˆ©ç”¨è€…ãŒæ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã‚’è¡Œã£ãŸ
ï¼½ã“ã¨ã«å› ã‚Šç”Ÿã˜ãŸå ´åˆã¯ ~T ã«ãªã‚Šã€
ä»–ã®å ´åˆã¯ ~F ã«ãªã‚‹
â‡’ï¼ƒ
`a$e è¦ç´ ã‚’~clickã—ãŸï¼
`form$e è¦ç´ ã‚’æå‡ºã—ã¦ã„ã‚‹ï¼
`~browser~UIï¼ ~HTMLsl#nav-traversal-ui$ã‚’åˆ©ç”¨ã—ã¦~navigateã—ãŸ
â—
True if this navigation was due to a user clicking on an a element, submitting a form element, or using the browser UI to navigate; false otherwise.
</dd>

	<dt>%event.`hashChange$mE</dt>
	<dd>
`ç´ ç‰‡ã¸ã®~navi$ã§ã‚ã‚‹å ´åˆã¯ ~T ã«ãªã‚Šã€
ä»–ã®å ´åˆã¯ ~F ã«ãªã‚‹ã€‚
â—
True for a fragment navigation; false otherwise.
</dd>

	<dt>%event.`signal$mE</dt>
	<dd>
å½“ã®~naviãŒå–æ¶ˆã•ã‚ŒãŸå ´åˆ
â€” ä¾‹ï¼šæ¬¡ã«æŒ™ã’ã‚‹å ´åˆ â€”
ã«ã¯ä¸­æ­¢ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ `AbortSignal$I
â‡’ï¼ƒ
åˆ©ç”¨è€…ãŒ~browserã® â€œåœæ­¢-â€ ~buttonã‚’æŠ¼ã—ãŸï¼
åˆ¥ã®~naviãŒï¼Œã“ã®~naviã‚’ä¸­æ–­ã—ã¦ã„ã‚‹
â—
An AbortSignal which will become aborted if the navigation gets canceled, e.g., by the user pressing their browser's "Stop" button, or by another navigation interrupting this one.
</dd>
	<dd>
é–‹ç™ºè€…~å‘ã‘ã«æœŸå¾…ã•ã‚Œã‚‹~patternã¯ã€
ã“ã‚Œã‚’ä½•ã‚‰ã‹ã®éåŒæœŸcãªæ¼”ç®—
â€” `fetch()$m ãªã© â€”
ã«æ¸¡ã—ã¦ï¼Œãã‚Œã‚’ï¼»
ã“ã®~naviã‚’å–æ‰±ã†ã¨ãã®ä¸€éƒ¨ã¨ã—ã¦é‚è¡Œã™ã‚‹
ï¼½ã“ã¨ã§ã‚ã‚‹ã€‚
â—
The expected pattern is for developers to pass this along to any async operations, such as fetch(), which they perform as part of handling this navigation.
</dd>

	<dt>%event.`formData$mE</dt>
	<dd>
ã“ã®~naviãŒï¼»
`push$l ï¼ `replace$l
ï¼½~naviã§ã‚ã£ã¦ï¼Œï¼»
~POSTã‚’ä¼´ã†`~formæå‡ºï¼ ~HTMLforms#concept-form-submit$
ï¼½ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹å ´åˆã€ï¼»
ã“ã®~naviç”¨ã«æå‡ºã•ã‚ŒãŸ~form~entryãŸã¡ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ `FormData$I
ï¼½ã«ãªã‚‹ã€‚
ä»–ã®å ´åˆã€
~NULL ã«ãªã‚‹ã€‚
â—
The FormData representing the submitted form entries for this navigation, if this navigation is a "push" or "replace" navigation representing a POST form submission; null otherwise.
</dd>
	<dd>
ï¼ˆã“ã‚Œã¯ã€ï¼»
`reload$l ï¼ `traverse$l
ï¼½~naviç”¨ã«ã¯ ~NULL ã«ãªã‚‹ã“ã¨ã«æ³¨æ„
â€” ãã‚ŒãŒï¼»
å…ƒã€…ã¯~formæå‡ºã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸ`~sessionå±¥æ­´~entry$
ï¼½ã‚’è¨ªå•ã—ç›´ã—ã¦ã„ã‚‹å ´åˆã§ã‚‚ã€‚ï¼‰
â—
(Notably, this will be null even for "reload" or "traverse" navigations that are revisiting a session history entry that was originally created from a form submission.)
</dd>

	<dt>%event.`downloadRequest$mE</dt>
	<dd>
<p>
ã“ã®~naviãŒï¼»
`a$e ï¼ `area$e
ï¼½è¦ç´ ã® `download$a å±æ€§ã‚’åˆ©ç”¨ã—ã¦~downloadã‚’è¦è«‹ã—ãŸã‹ã©ã†ã‹ã‚’è¡¨ç¾ã™ã‚‹
â€” ~downloadãŒï¼š
â—
Represents whether or not this navigation was requested to be a download, by using an a or area element's download attribute:
</p>
		<ul>
			<li>
è¦è«‹ã•ã‚Œãªã‹ã£ãŸå ´åˆã€
ã“ã®~prop ã¯ ~NULL ã«ãªã‚‹ã€‚
â—
If a download was not requested, then this property is null.
</li>
			<li>
è¦è«‹ã•ã‚ŒãŸå ´åˆã€
`download$a å±æ€§ã®å€¤ã¨ã—ã¦çµ¦ã•ã‚ŒãŸ~filenameï¼ˆç©º~æ–‡å­—åˆ—ã‚‚ã¨ã‚Šå¾—ã‚‹ï¼‰ã‚’è¿”ã™ã€‚
â—
If a download was requested, returns the filename that was supplied as the download attribute's value. (This could be the empty string.)
</li>
		</ul>
	</dd>
	<dd>
<p>
~downloadãŒè¦è«‹ã•ã‚ŒãŸã¨ã—ã¦ã‚‚ã€
å¸¸ã«~downloadãŒèµ·ã“ã‚‹ã“ã¨ã¯æ„å‘³ã—ãªã„ã“ã¨ã«æ³¨æ„ã€‚
ä¾‹ãˆã°ã€
~downloadã¯ï¼š
</p>
		<ul>
			<li>
~browserã®~securityæ–½ç­–ã«ã‚ˆã‚Šï¼Œ
é˜»æ­¢ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</li>
			<li>
<span class="XXX">`æœªæŒ‡å®šãªç†ç”±ï¼ ~HTMLissue/7718$ã«ã‚ˆã‚Š</span>ï¼Œ
çµæœçš„ã« `push$hH ~naviã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</li>
		</ul>
â—
Note that a download being requested does not always mean that a download will happen: for example, a download might be blocked by browser security policies, or end up being treated as a "push" navigation for unspecified reasons.
</dd>
	<dd>
é¡ä¼¼ã«ï¼Œ~downloadãŒè¦è«‹ã•ã‚Œãªã‹ã£ãŸå ´åˆã§ã‚‚ã€
çµæœã¯~downloadã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„
â€” ~naviã«å¯¾ã—ï¼»
è¡Œå…ˆ~serverãŒ `Content-Disposition$h ~headerã§å¿œç­”ã™ã‚‹
ï¼½ã“ã¨å› ã‚Šã€‚
â—
Similarly, a navigation might end up being a download even if it was not requested to be one, due to the destination server responding with a `Content-Disposition: attachment` header.
</dd>
	<dd>
~browser~UI~affordanceã‚’åˆ©ç”¨ã—ã¦èµ·å‹•ã•ã‚ŒãŸ~downloadç”¨ã«ã¯ã€
`navigate$et ~eventã¯ï¼Œã¾ã£ãŸãç™ºç«ã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„
â€” ä¾‹ï¼šå³~clickã—ã¦~linkã®~targetã‚’ä¿å­˜ã™ã‚‹ã“ã¨ã‚’é¸ã‚“ã å ´åˆã€‚
â—
Finally, note that the navigate event will not fire at all for downloads initiated using browser UI affordances, e.g., those created by right-clicking and choosing to save the target of a link.
</dd>

	<dt>%event.`info$mE</dt>
	<dd>
ã“ã®~naviãŒï¼Œã„ãšã‚Œã‹ã®`~navi~API~methodï¼ #navigation-api-initiating-navigations$ã‚’ä»‹ã—ã¦èµ·å‹•ã•ã‚ŒãŸå ´åˆã€
ãã‚Œã«æ¸¡ã•ã‚ŒãŸä»»æ„ãª~JSå€¤ã«ãªã‚‹ã€‚
ï¼»
åˆ©ç”¨è€…ï¼ç•°ãªã‚‹~API
ï¼½ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸå ´åˆã€
`undefined^jv ã«ãªã‚‹ã€‚
â—
An arbitrary JavaScript value passed via one of the navigation API methods which initiated this navigation, or undefined if the navigation was initiated by the user or by a different API.
</dd>

	<dt>%event.`hasUAVisualTransition$mE</dt>
	<dd>
~UAãŒï¼»
ã“ã®~eventã‚’é…é€ã™ã‚‹å‰ã«ï¼Œã“ã®~naviç”¨ã«è¦–è¦šçš„ãªé·ç§»ã‚’é‚è¡Œã—ãŸ
ã€ãŠãã‚‰ãï¼Œ `CSSVIEWTRANSITIONS$r ã‚’æŒ‡ã™ã€‘
ï¼½ãªã‚‰ã° ~T ã‚’è¿”ã™ã€‚
~T ã®å ´åˆã€
ä½œè€…ã¯ï¼Œï¼»
~naviå¾Œã®çŠ¶æ…‹ã¨åŒæœŸçš„ã«~DOMã‚’æ›´æ–°ã™ã‚‹
ï¼½ãªã‚‰ã°æœ€è‰¯ãªåˆ©ç”¨è€…~ä½“é¨“ã‚’ä¸ãˆã‚‹ã“ã¨ã«ãªã‚‹ã€‚
â—
Returns true if the user agent performed a visual transition for this navigation before dispatching this event. If true, the best user experience will be given if the author synchronously updates the DOM to the post-navigation state.
</dd>

	<dt>%event.`sourceElement$mE</dt>
	<dd>
ã“ã®~naviã‚’æ‹…å½“ã—ã¦ã„ãŸ`è¦ç´ $ã‚’è¿”ã™ã€‚
çµæœã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã«ã‚‚ãªã‚Šå¾—ã‚‹
â‡’ï¼ƒ
`a$e è¦ç´ ï¼
`area$e è¦ç´ ï¼
`æå‡º-~button$ï¼
æå‡ºã•ã‚ŒãŸ `form$e è¦ç´ 
â—
Returns the Element responsible for this navigation. This can be an aor area element, a submit button, or a submitted form element.
</dd>

	<dt>%event.`intercept$mE({ `precommitHandler$mb, `handler$mb, `focusReset$mb, `scroll$mb })</dt>
	<dd>
ã“ã®~naviã‚’æ¨ªå–ã™ã‚‹
â€” ã“ã®~naviã«å¯¾ã™ã‚‹é€šå¸¸ã®å–æ‰±ã„ã‚’é˜²æ­¢ã—ã¦ã€
ä»£ã‚ã‚Šã«ï¼Œãã‚Œã‚’åŒã˜ç¨®åˆ¥ã®ï¼»
è¡Œå…ˆ~URLã¨åŒä¸€-æ–‡æ›¸ã¸ã®~navi
ï¼½ã«å¤‰æ›ã™ã‚‹ã€‚
â—
Intercepts this navigation, preventing its normal handling and instead converting it into a same-document navigation of the same type to the destination URL.
</dd>
	<dd>
`precommitHandler$mb ~optionã¯ã€
`NavigationPrecommitController$I ã‚’å—å®¹ã—ã¦~promiseã‚’è¿”ã™é–¢æ•°ã‚’ã¨ã‚Šå¾—ã‚‹ã€‚
~precommit~handleré–¢æ•°ã¯ï¼Œï¼»
`navigate$et ~eventã®ç™ºç«ãŒå®Œé‚ã—ãŸå¾Œ
ï¼½ã‹ã¤ï¼»
`currentEntry$mN ~propãŒæ›´æ–°ã•ã‚Œã‚‹å‰
ï¼½ã«èµ°ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
å´ä¸‹ã•ã‚Œã‚‹~promiseã‚’è¿”ã—ãŸå ´åˆã€
å½“ã®~navi, ãã®åŠ¹æœ
â€” ~URLã‚„~sessionå±¥æ­´ã‚’æ›´æ–°ã™ã‚‹ãªã© â€”
ã¯ä¸­æ­¢ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ã™ã¹ã¦ã®~precommit~handlerãŒå……è¶³ã•ã‚ŒãŸå¾Œã«ã¯ã€
å½“ã®~naviã‚’ï¼»
~commitã—ã¦ï¼Œæ®‹ã‚Šã®~handlerãŸã¡ã€`~navi~handler~list$nEvï¼Ÿã€‘ã‚’~callã™ã‚‹
ï¼½ã‚ˆã†ç¶šè¡Œã§ãã‚‹ã€‚
`precommitHandler$mb ~optionã¯ã€
%eventã€ï¼ the `NavigateEvent$I ~eventã€‘ ã® `cancelable$m ãŒ ~T ã‚’ã¨ã‚‹ã¨ãã«ã—ã‹æ¸¡ã›ãªã„
â€” ã•ã‚‚ãªã‘ã‚Œã°ã€ï¼trying to ...ã€‘ã€
`SecurityError$E ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚Œã‚‹ã€‚
â—
The precommitHandler option can be a function that accepts a NavigationPrecommitController and returns a promise. The precommit handler function will run after the navigate event has finished firing, but before the navigation.currentEntry property has been updated. Returning a rejected promise will abort the navigation and its effect, such as updating the URL and session history. After all the precommit handlers are fulfilled, the navigation can proceed to commit and call the rest of the handlers. The precommitHandler option can only be passed when the event is cancelable: trying to pass a precommitHandler to a non-cancelable NavigateEvent will throw a "SecurityError" DOMException.
</dd>
	<dd>
`handler$mb ~optionã¯ã€
~promiseã‚’è¿”ã™é–¢æ•°ã‚’ã¨ã‚Šå¾—ã‚‹ã€‚
ã“ã®é–¢æ•°ã¯ã€ï¼»
`navigate$et ~eventã®ç™ºç«ãŒå®Œé‚ã—ã¦ï¼Œ
`navigation.currentEntry$c ~propãŒæ›´æ–°ã•ã‚ŒãŸå¾Œ
ï¼½ã«èµ°ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
è¿”ã•ã‚ŒãŸ~promiseã¯ã€
å½“ã®~naviã®ï¼»
æ‰€è¦æ™‚é–“, æˆå¦
ï¼½ã‚’é€šé”ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ã€‚
~browserã¯ã€
ãã‚ŒãŒæ±ºç€ã—ãŸå¾Œã«ï¼Œ
å½“ã®~naviãŒå®Œé‚ã—ãŸã“ã¨ã‚’åˆ©ç”¨è€…ã¸é€šé”ã™ã‚‹
ï¼ˆä¾‹ï¼šï¼»
èª­è¾¼nä¸­ã‚’è¡¨ã™~UIï¼æ”¯æ´æŠ€è¡“
ï¼½ã‚’ä»‹ã—ã¦ï¼‰
ã“ã¨ã«åŠ ãˆã€
å½“ã®~web~appã‚’æˆã™ä»–ã®å„éƒ¨ãŒå¿œç­”ã§ãã‚‹ã‚ˆã†ï¼Œï¼»
`navigatesuccess$et, `navigateerror$et
ï¼½~eventã®ã†ã¡é©åˆ‡ãªæ–¹ã‚’ç™ºç«ã™ã‚‹ã€‚
â—
The handler option can be a function that returns a promise. The handler function will run after the navigate event has finished firing and the navigation.currentEntry property has been updated. This returned promise is used to signal the duration, and success or failure, of the navigation. After it settles, the browser signals to the user (e.g., via a loading spinner UI, or assistive technology) that the navigation is finished. Additionally, it fires navigatesuccess or navigateerror events as appropriate, which other parts of the web application can respond to.
</dd>
	<dd>
<p>
æ—¢å®šã§ã¯ã€
ã“ã®~methodã‚’åˆ©ç”¨ã™ã‚‹ã¨ï¼š
â—
â†“</p>
		<ul>
			<li>
~handlerãŒè¿”ã—ãŸ~promiseãŒæ±ºç€ã™ã‚‹ã¨ãï¼Œ~focusã‚’è¨­å®šã—ç›´ã™ã“ã¨ã«ãªã‚‹ã€‚
~focusã¯ã€
`autofocus$a å±æ€§ã‚’æœ‰ã™ã‚‹è¦ç´ ãŒï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã‚Œã‚‰ã®ã†ã¡æœ€åˆã®ã‚‚ã® ï¼
ç„¡ã„ãªã‚‰ã°`~bodyè¦ç´ $
ï¼½ã«è¨­å®šã—ç›´ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
`focusReset$mb ~optionã‚’ `manual$lF ã«è¨­å®šã™ã‚Œã°ã€
ã“ã®æŒ™å‹•ã‚’é¿ã‘ã‚Œã‚‹ã€‚
â—
By default, using this method will cause focus to reset when any handlers' returned promises settle. Focus will be reset to the first element with the autofocus attribute set, or the body element if the attribute isn't present. The focusReset option can be set to "manual" to avoid this behavior.
</li>
			<li>
<p>
~handlerãŒè¿”ã—ãŸ~promiseãŒæ±ºç€ã™ã‚‹ã¾ã§ï¼Œæ¬¡ã‚’é…å»¶ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼š
</p>
				<ul>
					<li>
ï¼»
`traverse$l ï¼ `reload$l
ï¼½~naviç”¨ã«ã¯ã€
~browserã®~scrollå¾©æ—§~logic
</li>
					<li>
ï¼»
`push$l ï¼ `replace$l
ï¼½~naviç”¨ã«ã¯ã€
~browserã®ï¼»
~scrollã‚’è¨­å®šã—ç›´ã™ï¼ç´ ç‰‡ã¸~scrollã™ã‚‹
ï¼½ãŸã‚ã®~logic
</li>
				</ul>
<p>
`scroll$mb ~optionã‚’ `manual$lS ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€
ã“ã®~naviç”¨ã®ï¼»
~browseré§†å‹•ãª~scrollç”¨ã®æŒ™å‹•
ï¼½ã‚’ã¾ã‚‹ã”ã¨ã‚ªãƒ•ã«ã§ãã‚‹ã€‚
æ±ºç€ã™ã‚‹å‰ã« `scroll()$mE ã‚’~callã™ã‚Œã°ã€
ã“ã®æŒ™å‹•ã‚’æ—©æœŸã«èª˜ç™ºã§ãã‚‹ã€‚
</p>
â—
By default, using this method will delay the browser's scroll restoration logic for "traverse" or "reload" navigations, or its scroll-reset/scroll-to-a-fragment logic for "push" or "replace" navigations, until any handlers' returned promises settle. The scroll option can be set to "manual" to turn off any browser-driven scroll behavior entirely for this navigation, or scroll() can be called before the promise settles to trigger this behavior early.
</li>
		</ul>
	</dd>
	<dd>
ã“ã®~methodã¯ã€ï¼»
`canIntercept$mE ~EQ ~F ï¼
`isTrusted$m ~EQ ~F
ï¼½ã®å ´åˆã«ã¯ï¼Œ
`SecurityError$E ä¾‹å¤–ã‚’æŠ•å‡ºã™ã‚‹ã€‚
~eventé…é€ã®é–“ã«åŒæœŸçš„ã«~callã•ã‚Œãªã‹ã£ãŸå ´åˆã«ã¯ï¼Œ
`InvalidStateError$E ä¾‹å¤–ã‚’æŠ•å‡ºã™ã‚‹ã€‚
â—
This method will throw a "SecurityError" DOMException if canIntercept is false, or if isTrusted is false. It will throw an "InvalidStateError" DOMException if not called synchronously, during event dispatch.
</dd>

	<dt>%event.`scroll$mE()</dt>
	<dd>
ï¼»
`traverse$l ï¼ `reload$l
ï¼½~naviç”¨ã«ã¯
â‡’
~browserã®é€šä¾‹çš„ãª~scrollå¾©æ—§~logicã‚’åˆ©ç”¨ã—ã¦ï¼Œ~scrollä½ç½®ã‚’å¾©æ—§ã™ã‚‹ã€‚
â—
For "traverse" or "reload" navigations, restores the scroll position using the browser's usual scroll restoration logic.
</dd>
	<dd>
ï¼»
`push$l ï¼ `replace$l
ï¼½~naviç”¨ã«ã¯
â‡’ï¼ƒ
`url$mD ãŒ`ç´ ç‰‡$urlã‚’ä¼´ã†å ´åˆï¼Œãã“ã¸~scrollã™ã‚‹ï¼
ä»–ã®å ´åˆï¼Œ~scrollä½ç½®ã‚’æ–‡æ›¸ã®ä¸Šç«¯ã«è¨­å®šã—ç›´ã™
â—
For "push" or "replace" navigations, either resets the scroll position to the top of the document or scrolls to the fragment specified by destination.url if there is one.
</dd>
	<dd>
<p>
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹ã«è©²å½“ã™ã‚‹å ´åˆã€
`InvalidStateError$E ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚Œã‚‹ï¼š
</p>
		<ul>
			<li>
è¤‡æ•°å›~callã•ã‚ŒãŸ
</li>
			<li>
`scroll$mb ~optionãŒ `after-transition$lS ã®ã¾ã¾ã«ã•ã‚ŒãŸ
ã€ `intercept()$mE ~methodã«æ¸¡ã—ãŸ %options ã® `scroll$mb ~memberãŒ `after-transition$lS ã«è¨­å®šã•ã‚ŒãŸã‹ï¼Œçœç•¥ã•ã‚ŒãŸã€‘
ã“ã¨ã«å› ã‚Šèµ·ããŸï¼»
é·ç§»~å¾Œã®è‡ªå‹•çš„ãª~scrollå‡¦ç†
ï¼½ã®å¾Œã«~callã•ã‚ŒãŸ
</li>
			<li>
~naviãŒ~commitã•ã‚Œã‚‹å‰ã«~callã•ã‚ŒãŸ
</li>
		</ul>
â—
If called more than once, or called after automatic post-transition scroll processing has happened due to the scroll option being left as "after-transition", or called before the navigation has committed, this method will throw an "InvalidStateError" DOMException.
</dd>
</dl>

<p>
å„ `NavigateEvent$I ã«ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ãŒçµä»˜ã‘ã‚‰ã‚Œã‚‹ï¼š
â—
â†“</p>
<ul>
	<li>
<p>
`æ¨ªå–~çŠ¶æ…‹@nEv
â‡’
æ¬¡ã«æŒ™ã’ã‚‹ã„ãšã‚Œã‹
â€” åˆæœŸ~æ™‚ã¯ `none^l ã¨ã™ã‚‹
â‡’ï¼ƒ
`none^l ï¼
`intercepted^l ï¼
`committed^l ï¼
`scrolled^l ï¼
`finished^l
</p>

<p class="trans-note">ã€
ã“ã®çŠ¶æ…‹ã¯ã€
æŒ™ã’ã‚‰ã‚ŒãŸé †ã«
â€” å ´åˆã«ã‚ˆã£ã¦ã¯ï¼Œã†ã¡ã„ãã¤ã‹ã‚’é£›ã°ã—ã¦ â€”
é·ç§»ã™ã‚‹ã€‚
ã€‘ã€
ã“ã®ä»•æ§˜ã«ç¾ã‚Œã‚‹ â€œï¼ˆ~naviãŒï¼‰~commitã•ã‚ŒãŸâ€ ã¨ã¯ã€ï¼»
~naviã®`é€²è¡Œä¸­ãª~navigate_ev~event$ã®`æ¨ªå–~çŠ¶æ…‹$nEvãŒ `committed^l ã«ãªã£ãŸ
ï¼½ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã¨æ€ã‚ã‚Œã‚‹ã€‚
ã€‘</p>
â—
Each NavigateEvent has an interception state, which is either "none", "intercepted", "committed", "scrolled", or "finished", initially "none".
</li>
	<li>
`~navi~precommit~handler~list@nEv
â‡’
`NavigationPrecommitHandler$I ~callbackãŸã¡ãŒæˆã™`~list$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
â—
Each NavigateEvent has a navigation precommit handler list, a list of NavigationPrecommitHandler callbacks, initially empty.
</li>
	<li>
<p>
`~navi~handler~list@nEv
â‡’
`NavigationInterceptHandler$I ~callbackãŸã¡ãŒæˆã™`~list$
â€” åˆæœŸ~æ™‚ã¯ç©ºã¨ã™ã‚‹ã€‚
</p>

<p class="trans-note">ã€
ã“ã®~listã¯ã€
å½“ã® `NavigateEvent$I ã«å¯¾ã™ã‚‹å„ `intercept()$mE ã®~callã«æ¸¡ã—ãŸ `handler$mb ~optionã«ã‚ˆã‚Šï¼Œæ‹¡å……ã•ã‚Œã‚‹ã€‚
ãã‚Œã‚‰ã®~callbackãŒè¿”ã™~promiseã‚’ç·ç§°ã—ã¦ã€
ã“ã®è¨³ã§ã¯
`~navi~handler~promise@
ã¨ç§°ã™ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚
ã€‘</p>
â—
Each NavigateEvent has a navigation handler list, a list of NavigationInterceptHandler callbacks, initially empty.
</li>
	<li>
`~focusã‚’è¨­å®šã—ç›´ã™æŒ™å‹•@nEv
â‡’
~NULL ï¼ã‚ã‚‹ `NavigationFocusReset$I
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Each NavigateEvent has a focus reset behavior, a NavigationFocusReset-or-null, initially null.
</li>
	<li>
`~scrollç”¨ã®æŒ™å‹•@nEv
â‡’
~NULL ï¼ã‚ã‚‹ `NavigationScrollBehavior$I
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Each NavigateEvent has a scroll behavior, a NavigationScrollBehavior-or-null, initially null.
</li>
	<li>
`ä¸­æ­¢-åˆ¶å¾¡å™¨@nEv
â‡’
~NULL ï¼ã‚ã‚‹ `AbortController$I
â€” åˆæœŸ~æ™‚ã¯ ~NULL ã¨ã™ã‚‹ã€‚
â—
Each NavigateEvent has an abort controller, an AbortController-or-null, initially null.
</li>
	<li>
<p>
`å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹@nEv
â‡’
~NULL ï¼ã‚ã‚‹`ç›´åˆ—å½¢ã®çŠ¶æ…‹$
â—
Each NavigateEvent has a classic history API state, a serialized state or null.ï¼¼
</p>

<p>
ã“ã‚Œã¯ã€
ä¸€éƒ¨ã®äº‹ä¾‹
â€” å½“ã®~eventã® `navigationType$mE ãŒï¼»
`push$l ï¼ `replace$l
ï¼½ã§ã‚ã‚‹å ´åˆ â€”
ã«é™ã‚Šåˆ©ç”¨ã•ã‚Œï¼Œ
å½“ã®~eventãŒ`ç™ºç«ã•ã‚Œã‚‹ï¼ ~DOM4#concept-event-fire$ã¨ãã«é©åˆ‡ã«è¨­å®šã•ã‚Œã‚‹
â—
It is only used in some cases where the event's navigationType is "push" or "replace", and is set appropriately when the event is fired.
</p>
	</li>
</ul>

<p>
æ¬¡ã«æŒ™ã’ã‚‹å±æ€§ã¯ã€
åˆæœŸåŒ–~æ™‚ã®å€¤ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«
â‡’ï¼ƒ
`navigationType@mE,
`destination@mE,
`canIntercept@mE,
`userInitiated@mE,
`hashChange@mE,
`signal@mE,
`formData@mE,
`downloadRequest@mE,
`info@mE,
`hasUAVisualTransition@mE,
`sourceElement@mE
â—
The navigationType, destination, canIntercept, userInitiated, hashChange, signal, formData, downloadRequest, info, hasUAVisualTransition, and sourceElement attributes must return the values they are initialized to.
</p>

<div class="algo">
<p>
`intercept(options)@mE
~methodæ‰‹ç¶šãã¯ï¼š
â—
The intercept(options) method steps are:
</p>
<ol>
	<li>
`å…±ç”¨~æ¤œæŸ»ã‚’é‚è¡Œã™ã‚‹$( ã‚³ãƒ¬ )
â—
Perform shared checks given this.
</li>
	<li>
~IFï¼»
ã‚³ãƒ¬ã® `canIntercept$mE å±æ€§ ~EQ ~F
ï¼½
â‡’
~THROW `SecurityError$E
â—
If this's canIntercept attribute was initialized to false, then throw a "SecurityError" DOMException.
</li>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`é…é€-ä¸­ã‹$ev ~EQ ~F
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If this's dispatch flag is unset, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%~precommit~handler ~LET %options[ "`precommitHandler$mb" ]
â—
â†“</li>
	<li>
<p>
~IFï¼»
%~precommit~handler ~NEQ Îµ
ï¼½ï¼š
â—
If options["precommitHandler"] exists, then:
</p>
		<ol>
			<li>
~IFï¼»
ã‚³ãƒ¬ã® `cancelable$m å±æ€§ ~EQ ~F
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If this's cancelable attribute is initialized to false, then throw an "InvalidStateError" DOMException.
</li>
			<li>
ã‚³ãƒ¬ã®`~navi~precommit~handler~list$nEvã« %~precommit~handler ã‚’`ä»˜åŠ ã™ã‚‹$
â—
Append options["precommitHandler"] to this's navigation precommit handler list.
</li>
		</ol>
	</li>
	<li>
~Assertï¼š
ã‚³ãƒ¬ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~IN { `none^l, `intercepted^l }
â—
Assert: this's interception state is either "none" or "intercepted".
</li>
	<li>
ã‚³ãƒ¬ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~SET `intercepted^l
â—
Set this's interception state to "intercepted".
</li>
	<li>
%handler ~SET %options[ "`handler$mb" ]
â—
â†“</li>
	<li>
~IFï¼»
%handler ~NEQ Îµ
ï¼½
â‡’
ã‚³ãƒ¬ã®`~navi~handler~list$nEvã« %handler ã‚’`ä»˜åŠ ã™ã‚‹$
â—
If options["handler"] exists, then append it to this's navigation handler list.
</li>
	<li>
%focusReset ~LET %options[ "`focusReset$mb" ] 
â—
â†“</li>
	<li>
<p>
~IFï¼»
%focusReset ~NEQ Îµ
ï¼½ï¼š
â—
If options["focusReset"] exists, then:
</p>
		<ol>
			<li>
~IFï¼»
ã‚³ãƒ¬ã®`~focusã‚’è¨­å®šã—ç›´ã™æŒ™å‹•$nEv ~NIN { ~NULL, %focusReset }
ï¼½
â‡’
ä»»æ„é¸æŠã§
â‡’
`~consoleã«è­¦å‘Šã‚’å ±å‘Šã™ã‚‹$( â†“ )
â‡’
â€œ`intercept()$mE ã«å¯¾ã™ã‚‹ä»¥å‰ã®~callã«ä¸ãˆãŸ `focusReset$mb ~optionã¯ã€
ã“ã®æ–°ãŸãªå€¤ã«ã‚ˆã‚Šä¸Šæ›¸ãã•ã‚Œï¼Œç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚â€
â—
If this's focus reset behavior is not null, and it is not equal to options["focusReset"], then the user agent may report a warning to the console indicating that the focusReset option for a previous call to intercept() was overridden by this new value, and the previous value will be ignored.
</li>
			<li>
ã‚³ãƒ¬ã®`~focusã‚’è¨­å®šã—ç›´ã™æŒ™å‹•$nEv ~SET %focusReset
â—
Set this's focus reset behavior to options["focusReset"].
</li>
		</ol>
	</li>
	<li>
%scroll ~LET %options[ "`scroll$mb" ]
â—
â†“</li>
	<li>
<p>
~IFï¼»
%scroll ~NEQ Îµ
ï¼½ï¼š
â—
If options["scroll"] exists, then:
</p>
		<ol>
			<li>
~IFï¼»
ã‚³ãƒ¬ã®`~scrollç”¨ã®æŒ™å‹•$nEv ~NIN { ~NULL, %scroll }
ï¼½
â‡’
ä»»æ„é¸æŠã§
â‡’
`~consoleã«è­¦å‘Šã‚’å ±å‘Šã™ã‚‹$( â†“ )
â‡’
â€œ`intercept()$mE ã«å¯¾ã™ã‚‹ä»¥å‰ã®~callã«ã¦ä¸ãˆãŸ `scroll$mb ~optionã¯ã€
ã“ã®æ–°ãŸãªå€¤ã«ã‚ˆã‚Šä¸Šæ›¸ãã•ã‚Œï¼Œç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚â€
â—
If this's scroll behavior is not null, and it is not equal to options["scroll"], then the user agent may report a warning to the console indicating that the scroll option for a previous call to intercept() was overridden by this new value, and the previous value will be ignored.
</li>
			<li>
ã‚³ãƒ¬ã®`~scrollç”¨ã®æŒ™å‹•$nEv ~SET %scroll
â—
Set this's scroll behavior to options["scroll"].
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`scroll()@mE
~methodæ‰‹ç¶šãã¯ï¼š
â—
The scroll() method steps are:
</p>
<ol>
	<li>
`å…±ç”¨~æ¤œæŸ»ã‚’é‚è¡Œã™ã‚‹$( ã‚³ãƒ¬ )
â—
Perform shared checks given this.
</li>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `committed^l
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If this's interception state is not "committed", then throw an "InvalidStateError" DOMException.
</li>
	<li>
`~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹$( ã‚³ãƒ¬ )
â—
Process scroll behavior given this.
</li>
</ol>
</div>

<div class="algo">
<p>
`å…±ç”¨~æ¤œæŸ»ã‚’é‚è¡Œã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I %~event )
ã«å¯¾ã—ï¼š
â—
To perform shared checks for a NavigateEvent event:
</p>
<ol>
	<li>
~IFï¼»
%~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If event's relevant global object's associated Document is not fully active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IFï¼»
%~event ã®`isTrusted$m å±æ€§ ~EQ ~F
ï¼½
â‡’
~THROW `SecurityError$E
â—
If event's isTrusted attribute was initialized to false, then throw a "SecurityError" DOMException.
</li>
	<li>
~IFï¼»
%~event ã®`å–æ¶ˆã•ã‚ŒãŸã‹$ev ~EQ ~T
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If event's canceled flag is set, then throw an "InvalidStateError" DOMException.
</li>
</ol>
</div>

					</section>
					<section id="the-navigationprecommitcontroller-interface">
<h6 title="The NavigationPrecommitController interface">7.2.6.10.2. `NavigationPrecommitController^I ~interface</h6>

<pre class="idl">
[Exposed=Window]
  interface `NavigationPrecommitController@I {
    undefined `redirect$m(USVString %url, optional `NavigationNavigateOptions$I %options = {});
  };

  callback `NavigationPrecommitHandler@I = `Promise$&lt;undefined&gt; (`NavigationPrecommitController$I controller);
</pre>

	<dl class="domintro">
	<dt>
%precommitController.`redirect(url, options)$m
â—
precommitController.redirect(USVString url, NavigationNavigateOptions options)
</dt>
	<dd>
<p>
ï¼»
`push$l ï¼ `replace$l
ï¼½~naviç”¨ã«ã¯ã€
ã€`~event$pCCã®ã€‘ `destination.url$c ã‚’ %url ã«è¨­å®šã™ã‚‹ã€‚
%options ã‚’æˆã™ï¼š
</p>
		<ul>
			<li>
`info$mbN ã¯ï¼ˆåœ¨ã‚‹ãªã‚‰ã°ï¼‰ã€
ã€`~event$pCCã®ã€‘ `info$mE ã‚’è¨­å®šã™ã‚‹ã€‚
</li>
			<li>
`state$mbN ã¯ï¼ˆåœ¨ã‚‹ãªã‚‰ã°ï¼‰ã€
çµæœã® `NavigationHistoryEntry$I ã®`çŠ¶æ…‹$nDt ã‚’è¨­å®šã™ã‚‹ã€‚
</li>
			<li>
`history$mbN ã¯ã€
~naviç¨®åˆ¥ã‚’ `push$l, `replace$l ã©ã¡ã‚‰ã‹ã«åˆ‡æ›¿ãˆã‚Œã‚‹ã€‚
</li>
		</ul>
â—
For "push" or "replace" navigations, sets the destination.url to url.
â—
If options is given, also sets the info and the resulting NavigationHistoryEntry's state to options's info and state, if they are present. The history option can also switch between "push" or "replace" navigations types.
</dd>
	<dd>
ï¼»
`reload$l ï¼ `traverse$l
ï¼½~naviç”¨ã«ã¯ã€
`InvalidStateError$E ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚Œã‚‹ã€‚
â—
For "reload" or "traverse" navigations, an "InvalidStateError" will be thrown.
</dd>
	<dd>
ç¾åœ¨ã®`æ–‡æ›¸$ã®~URLã‚’ %url ã«`æ›¸ç›´ã›ãªã„ï¼ ~WINDOW#can-have-its-url-rewritten$å ´åˆã€
`SecurityError$E ä¾‹å¤–ãŒæŠ•å‡ºã•ã‚Œã‚‹ã€‚
â—
If the current Document cannot have its URL rewritten to url, a "SecurityError" DOMException will be thrown.
</dd>
</dl>

<p>
å„ `NavigationPrecommitController$I ã¯ã€
`~event@pCC
â€” ã‚ã‚‹ `NavigateEvent$I ~event â€”
ã‚’æœ‰ã™ã‚‹ã€‚
â—
Each NavigationPrecommitController has a NavigateEvent event.
</p>

<div class="algo" j="">
<p>
`redirect(url, options)@m
~methodæ‰‹ç¶šãã¯ï¼š
â—
The redirect(url, options) method steps are:
</p>
<ol>
	<li>
%~event ~LET ã‚³ãƒ¬ã®`~event$pCC
â—
â†“</li>
	<li>
~Assertï¼š
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `none^l
â—
Assert: this's event's interception state is not "none".
</li>
	<li>
`å…±ç”¨~æ¤œæŸ»ã‚’é‚è¡Œã™ã‚‹$( %~event )
â—
Perform shared checks given this's event.
</li>
	<li>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `intercepted^l
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If this's event's interception state is not "intercepted", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IFï¼»
%~event ã® `navigationType$mE ~NIN { `push$l, `replace$l }
ï¼½
â‡’
~THROW `InvalidStateError$E
â—
If this's event's navigationType is neither "push" nor "replace", then throw an "InvalidStateError" DOMException.
</li>
	<li>
%æ–‡æ›¸ ~LET ã‚³ãƒ¬ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be this's relevant global object's associated Document.
</li>
	<li>
%è¡Œå…ˆ~URL ~LET `~URLã‚’ç›¸å¯¾çš„ã«æ§‹æ–‡è§£æã™ã‚‹$( %url, %æ–‡æ›¸ )
â—
Let destinationURL be the result of parsing url given document.
</li>
	<li>
~IFï¼»
%è¡Œå…ˆ~URL ~EQ `å¤±æ•—^i
ï¼½
â‡’
~THROW `SyntaxError$E
â—
If destinationURL is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IFï¼»
`æ–‡æ›¸ã®~URLã¯æ›¸ç›´ã›ã‚‹ã‹å¦ã‹$( %æ–‡æ›¸, %è¡Œå…ˆ~URL ) ~EQ ~F
ï¼½
â‡’
~THROW `SecurityError$E
â—
If document cannot have its URL rewritten to destinationURL, then throw a "SecurityError" DOMException.
</li>
	<li>
~IFï¼»
%options[ "`history$mbN" ] ~IN { `push$hH, `replace$hH }
ï¼½
â‡’
%~event ã® `navigationType$mE ~SET %options[ "`history$mbN" ]
â—
If options["history"] is "push" or "replace", then set this's event's navigationType to options["history"].
</li>
	<li>
<p>
~IFï¼»
%options[ "`state$mbN" ] ~NEQ Îµ
ï¼½ï¼š
â—
If options["state"] exists, then:
</p>
		<ol>
			<li>
%ç›´åˆ—å½¢ã®çŠ¶æ…‹ ~LET `StructuredSerializeForStorage$jA( %options[ "`state$mbR" ] )
ï¼ˆä¾‹å¤–ãŒæŠ•å‡ºã•ã‚Œå¾—ã‚‹ã€‚ï¼‰
â—
Let serializedState be the result of calling StructuredSerializeForStorage(options["state"]). This may throw an exception.
</li>
			<li>
%~event ã® `destination$mE ã®`çŠ¶æ…‹$nDt ~SET %ç›´åˆ—å½¢ã®çŠ¶æ…‹
â—
Set this's event's destination's state to serializedState.
</li>
			<li>
%~event ã®`~target$ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ã®`ç›´åˆ—å½¢ã®çŠ¶æ…‹$amT ~SET %ç›´åˆ—å½¢ã®çŠ¶æ…‹
â—
Set this's event's target's ongoing API method tracker's serialized state to serializedState.
</li>
		</ol>
	</li>
	<li>
%~event ã® `destination$mE ã®`~URL$nDt ~SET %è¡Œå…ˆ~URL
â—
Set this's event's destination's URL to destinationURL.
</li>
	<li>
~IFï¼»
%options[ "`info$mbN" ] ~NEQ Îµ
ï¼½
â‡’
%~event ã® `info$mE ~SET %options[ "`info$mbN" ]
â—
If options["info"] exists, then set this's event's info to options["info"].
</li>
</ol>
</div>

					</section>
					<section id="the-navigationdestination-interface">
<h6 title="The NavigationDestination interface">7.2.6.10.3. `NavigationDestination^I ~interface</h6>

<pre class="idl">
[Exposed=Window]
interface `NavigationDestination@I {
  readonly attribute USVString `url$mD;
  readonly attribute DOMString `key$mD;
  readonly attribute DOMString `id$mD;
  readonly attribute long long `index$mD;
  readonly attribute boolean `sameDocument$mD;

  any `getState$mD();
};
</pre>

<dl class="domintro">
	<dt>%event.`destination$mE.`url$mD</dt>
	<dd>
~navigateå…ˆã®~URLã€‚
â—
The URL being navigated to.
</dd>

	<dt>%event.`destination$mE.`key$mD</dt>
	<dd>
`traverse$l ~naviã§ã‚ã‚‹å ´åˆ
â‡’
è¡Œå…ˆã‚’æˆã™ `NavigationHistoryEntry$I ã® `key$mH ~propã®å€¤
â—
The value of the key property of the destination NavigationHistoryEntry, if this is a "traverse" navigation,ï¼¼
</dd>
	<dd>
ä»–ã®å ´åˆ
â‡’
ç©º~æ–‡å­—åˆ—
â—
or the empty string otherwise.
</dd>

	<dt>%event.`destination$mE.`id$mD</dt>
	<dd>
`traverse$l ~naviã§ã‚ã‚‹å ´åˆ
â‡’
è¡Œå…ˆã‚’æˆã™ `NavigationHistoryEntry$I ã® `id$mH ~propã®å€¤
â—
The value of the id property of the destination NavigationHistoryEntry, if this is a "traverse" navigation,ï¼¼
</dd>
	<dd>
ä»–ã®å ´åˆ
â‡’
ç©º~æ–‡å­—åˆ—
â—
or the empty string otherwise.
</dd>

	<dt>%event.`destination$mE.`index$mD</dt>
	<dd>
`traverse$l ~naviã§ã‚ã‚‹å ´åˆ
â‡’
è¡Œå…ˆã‚’æˆã™ `NavigationHistoryEntry$I ã® `index$mH ~propã®å€¤
â—
The value of the index property of the destination NavigationHistoryEntry, if this is a "traverse" navigation,ï¼¼
</dd>
	<dd>
ä»–ã®å ´åˆ
â‡’
âˆ’1
â—
or âˆ’1 otherwise.
</dd>

	<dt>%event.`destination$mE.`sameDocument$mD</dt>
	<dd>
ã“ã®~naviã¯ï¼ŒåŒä¸€-æ–‡æ›¸ã¸ã®~naviï¼ˆç¾åœ¨ã®`æ–‡æ›¸$ã¨åŒã˜`æ–‡æ›¸$ã¸ã®~naviï¼‰ã‹å¦ã‹ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚
ä¾‹ãˆã°ã€ï¼»
`ç´ ç‰‡ã¸ã®~navi$ï¼
`history.pushState()ï¼ ~WINDOW#dom-history-pushstate$c ã«ã‚ˆã‚‹~navi
ï¼½ã®äº‹ä¾‹ã«ãŠã„ã¦ã¯ ~T ã«ãªã‚‹ã€‚
â—
Indicates whether or not this navigation is to the same Document as the current one, or not.ï¼¼
This will be true, for example, in the case of fragment navigations or history.pushState() navigations.
</dd>
	<dd>
ã“ã®~propã¯ã€
å½“ã®~naviã®å…ƒã®è³‡è³ªã‚’æŒ‡ç¤ºã™ã‚‹ã“ã¨ã«æ³¨æ„ã€‚
éåŒä¸€-æ–‡æ›¸ã¸ã®~naviãŒ `intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ã‚’åˆ©ç”¨ã—ã¦åŒä¸€-æ–‡æ›¸ã¸ã®~naviã«å¤‰æ›ã•ã‚ŒãŸå ´åˆã€
ã“ã®~propã®å€¤ã¯å¤‰åŒ–ã—ãªã„ã€‚
â—
Note that this property indicates the original nature of the navigation. If a cross-document navigation is converted into a same-document navigation using navigateEvent.intercept(), that will not change the value of this property.
</dd>

	<dt>%event.`destination$mE.`getState$mD()</dt>
	<dd>
`traverse$l ~naviç”¨ã«ã¯ã€
æ¬¡ã‚’è¿”ã™
â‡’
è¡Œå…ˆã‚’æˆã™`~sessionå±¥æ­´~entry$å†…ã«æ ¼ç´ã•ã‚ŒãŸçŠ¶æ…‹ã®`é€†ç›´åˆ—åŒ–$
â—
For "traverse" navigations, returns the deserialization of the state stored in the destination session history entry.
</dd>
	<dd>
<p>
ï¼»
`push$l ~naviï¼ `replace$l ~navi
ï¼½ç”¨ã«ã¯ã€
æ¬¡ã‚’è¿”ã™ï¼š
</p>
		<ul>
			<li>
å½“ã®~naviã¯ `navigation.navigate()$c ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸå ´åˆ
â‡’
ãã®~methodã«æ¸¡ã•ã‚ŒãŸçŠ¶æ…‹ã®`é€†ç›´åˆ—åŒ–$
</li>
			<li>
ä»–ã®å ´åˆ
â‡’
`undefined^jv
</li>
		</ul>
â—
For "push" or "replace" navigations, returnsï¼¼
â—
the deserialization of the state passed to navigation.navigate(), if the navigation was initiated by that method,ï¼¼
â—
or undefined it if it wasn't.
</dd>
	<dd>
<p>
`reload$l ~naviç”¨ã«ã¯ã€
æ¬¡ã‚’è¿”ã™ï¼š
â—
For "reload" navigations, returnsï¼¼
</p>
		<ul>
			<li>
å½“ã®~naviã¯ `navigation.reload()$c ã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸå ´åˆ
â‡’
ãã®~methodã«æ¸¡ã•ã‚ŒãŸçŠ¶æ…‹ã®`é€†ç›´åˆ—åŒ–$
â—
the deserialization of the state passed to navigation.reload(), if the reload was initiated by that method,ï¼¼
</li>
			<li>
ä»–ã®å ´åˆ
â‡’
`undefined^jv
â—
or undefined it if it wasn't.
</li>
		</ul>
	</dd>
</dl>

<p>
å„ `NavigationDestination$I ã¯ã€
æ¬¡ã«æŒ™ã’ã‚‹ã‚‚ã®ã‚’æœ‰ã™ã‚‹ï¼š
â—
â†“</p>
<ul>
	<li>
`~URL@nDt
â‡’
`~URL$
â—
Each NavigationDestination has a URL, which is a URL.
</li>
	<li>
<p>
`~entry@nDt
â‡’
`NavigationHistoryEntry$I ï¼ ~NULL
â—
Each NavigationDestination has an entry, which is a NavigationHistoryEntry or null.
</p>

<p class="note">æ³¨è¨˜ï¼š
~NULL ä»¥å¤–ã«ãªã‚‹ã®ã¯ã€
`NavigationDestination$I ãŒ `traverse$l ~naviã«å¯¾å¿œã™ã‚‹å ´åˆï¼Œãã®å ´åˆã«é™ã‚‰ã‚Œã‚‹ã€‚
â—
It will be non-null if and only if the NavigationDestination corresponds to a "traverse" navigation.
</p>
	</li>
	<li>
`çŠ¶æ…‹@nDt
â‡’
`ç›´åˆ—å½¢ã®çŠ¶æ…‹$
â—
Each NavigationDestination has a state, which is a serialized state.
</li>
	<li>
`åŒä¸€-æ–‡æ›¸ã‹@nDt
â‡’
çœŸå½å€¤
â—
Each NavigationDestination has an is same document, which is a boolean.
</li>
</ul>

<hr>

<div class="algo">
`url@mD
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET `~URLã‚’ç›´åˆ—åŒ–ã™ã‚‹$( ã‚³ãƒ¬ã®`~URL$nDt )
â—
The url getter steps are to return this's URL, serialized.
</div>

<div class="algo">
<p>
`key@mD
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The key getter steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`~entry$nDt ~EQ ~NULL
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If this's entry is null, then return the empty string.
</li>
	<li>
~RET ã‚³ãƒ¬ã®`~entry$nDtã®`~key$nE
â—
Return this's entry's key.
</li>
</ol>
</div>

<div class="algo">
<p>
`id@mD
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The id getter steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`~entry$nDt ~EQ ~NULL
ï¼½
â‡’
~RET ç©º~æ–‡å­—åˆ—
â—
If this's entry is null, then return the empty string.
</li>
	<li>
~RET ã‚³ãƒ¬ã®`~entry$nDtã®`~ID$nE
â—
Return this's entry's ID.
</li>
</ol>
</div>

<div class="algo">
<p>
`index@mD
å–å¾—å­~æ‰‹ç¶šãã¯ï¼š
â—
The index getter steps are:
</p>
<ol>
	<li>
~IFï¼»
ã‚³ãƒ¬ã®`~entry$nDt ~EQ ~NULL
ï¼½
â‡’
~RET âˆ’1
â—
If this's entry is null, then return âˆ’1.
</li>
	<li>
~RET ã‚³ãƒ¬ã®`~entry$nDtã®`~index$nE
â—
Return this's entry's index.
</li>
</ol>
</div>

<div class="algo">
`sameDocument@mD
å–å¾—å­~æ‰‹ç¶šãã¯
â‡’
~RET ã‚³ãƒ¬ã®`åŒä¸€-æ–‡æ›¸ã‹$nDt
â—
The sameDocument getter steps are to return this's is same document.
</div>

<div class="algo">
<p>
`getState()@mD
~methodæ‰‹ç¶šãã¯
â‡’
~RET `StructuredDeserialize$jA( ã‚³ãƒ¬ã®`çŠ¶æ…‹$nDt )
â—
The getState() method steps are to return StructuredDeserialize(this's state).
</p>
</div>

					</section>
					<section id="navigate-event-firing">
<h6 title="Firing the event">7.2.6.10.4. ~eventã®ç™ºç«-æ³•</h6>

<p>
ã“ã®æ¨™æº–ã‚’æˆã™ä»–ã®å„éƒ¨ã¯ã€
ã“ã®ç¯€ã«ã¦ä¸ãˆã‚‹~wrapper~algoã‚’é€šã—ã¦ï¼Œ
`navigate$et ~eventã‚’ç™ºç«ã™ã‚‹ã€‚
â—
Other parts of the standard fire the navigate event, through a series of wrapper algorithms given in this section.
</p>

<div class="algo">
<div class="p">
<p>
`è¾¿-ç”¨ã®~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi )
ãŠã‚ˆã³ï¼Œæ‰€ä¸ã®
</p>
<ul>
	<li id="fire-navigate-traverse-destinationshe">
`~sessionå±¥æ­´~entry$ %è¡Œå…ˆ~å±¥æ­´~entry
</li>
	<li id="fire-navigate-traverse-userinvolvement">
`~naviã«å¯¾ã™ã‚‹åˆ©ç”¨è€…-é–¢ä¸i$ %åˆ©ç”¨è€…-é–¢ä¸i ~DF `ãªã—$i
</li>
</ul>
<p>
ã«å¯¾ã—ï¼š
</p>
â—
To fire a traverse navigate event at a Navigation navigation given a session history entry destinationSHE and an optional user navigation involvement userInvolvement (default "none"):
</div>
<ol>
	<li>
%~event ~LET `~eventã‚’ä½œæˆã™ã‚‹$( `NavigateEvent$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let event be the result of creating an event given NavigateEvent, in navigation's relevant realm.
</li>
	<li>
%~event ã®`å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹$nEv ~SET ~NULL
â—
Set event's classic history API state to null.
</li>
	<li>
%è¡Œå…ˆ ~LET `æ–°ãŸãª~obj$( `NavigationDestination$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let destination be a new NavigationDestination created in navigation's relevant realm.
</li>
	<li>
%è¡Œå…ˆ ã®`~URL$nDt ~SET %è¡Œå…ˆ~å±¥æ­´~entry ã®`~URL$shE
â—
Set destination's URL to destinationSHE's URL.
</li>
	<li>
%è¡Œå…ˆ~NHE ~LET %~navi ã®`~entry~list$nV å†…ã«æ¬¡ã‚’æº€ãŸã™ `NavigationHistoryEntry$I ã¯ï¼»
åœ¨ã‚‹ãªã‚‰ã° ãã‚Œï¼
ç„¡ã„ãªã‚‰ã°
ï¼½
â‡’
ãã®`~sessionå±¥æ­´~entry$nhe ~EQ %è¡Œå…ˆ~å±¥æ­´~entry
â—
Let destinationNHE be the NavigationHistoryEntry in navigation's entry list whose session history entry is destinationSHE, or null if no such NavigationHistoryEntry exists.
</li>
	<li>
<p>
~IFï¼»
%è¡Œå…ˆ~NHE ~NEQ ~NULL
ï¼½ï¼š
â—
If destinationNHE is non-null, then:
</p>
		<ol>
			<li>
%è¡Œå…ˆ ã®`~entry$nDt ~SET %è¡Œå…ˆ~NHE
â—
Set destination's entry to destinationNHE.
</li>
			<li>
%è¡Œå…ˆ ã®`çŠ¶æ…‹$nDt ~SET %è¡Œå…ˆ~å±¥æ­´~entry ã®`~navi~APIçŠ¶æ…‹$shE
â—
Set destination's state to destinationSHE's navigation API state.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise,
</p>
		<ol>
			<li>
%è¡Œå…ˆ ã®`~entry$nDt ~SET ~NULL
â—
Set destination's entry to null.
</li>
			<li>
%è¡Œå…ˆ ã®`çŠ¶æ…‹$nDt ~SET `StructuredSerializeForStorage$jA( ~NULL )
â—
Set destination's state to StructuredSerializeForStorage(null).
</li>
		</ol>
	</li>
	<li>
%è¡Œå…ˆ ã®`åŒä¸€-æ–‡æ›¸ã‹$nDt ~SET ~ISï¼»
%è¡Œå…ˆ~å±¥æ­´~entry ã®`æ–‡æ›¸$shE ~EQ %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
ï¼½
â—
Set destination's is same document to true if destinationSHE's document is equal to navigation's relevant global object's associated Document; otherwise false.
</li>
	<li>
~RET `~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo$( â†“ )
â‡’ï¼ƒ
%~navi, `traverse$l,
%~event,
%è¡Œå…ˆ,
%åˆ©ç”¨è€…-é–¢ä¸i,
~NULL,
~NULL,
~NULL
â—
Return the result of performing the inner navigate event firing algorithm given navigation, "traverse", event, destination, userInvolvement, null, null, and null.
</li>
</ol>
</div>

<div class="algo">
<div class="p">
<p>
`~pushï¼ç½®æ›-ï¼å†èª­è¾¼ã¿ç”¨ã®~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi )
ãŠã‚ˆã³ï¼Œæ‰€ä¸ã®ï¼š
</p>
<ul>
	<li id="fire-navigate-prr-navigationtype">
`NavigationType$I %~naviç¨®åˆ¥
</li>
	<li id="fire-navigate-prr-destinationurl">
`~URL$ %è¡Œå…ˆ~URL
</li>
	<li id="fire-navigate-prr-issamedocument">
çœŸå½å€¤ %åŒä¸€-æ–‡æ›¸ã‹
</li>
	<li id="fire-navigate-prr-userinvolvement">
`~naviã«å¯¾ã™ã‚‹åˆ©ç”¨è€…-é–¢ä¸i$ %åˆ©ç”¨è€…-é–¢ä¸i ~DF `ãªã—$i
</li>
	<li id="fire-navigate-prr-sourceelement">
`è¦ç´ $ %~sourceè¦ç´  ~DF ~NULL
</li>
	<li id="fire-navigate-prr-formdataentrylist">
`~entry~list$ %~form~data~entry~list ~DF ~NULL
</li>
	<li id="fire-navigate-prr-navigationapistate">
`ç›´åˆ—å½¢ã®çŠ¶æ…‹$ %~navi~APIçŠ¶æ…‹ ~DF `StructuredSerializeForStorage$jA( ~NULL )
</li>
	<li id="fire-navigate-prr-classichistoryapistate">
`ç›´åˆ—å½¢ã®çŠ¶æ…‹$ %å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹ ~DF ~NULL
</li>
</ul>
<p>
ã«å¯¾ã—ï¼š
</p>
â—
To fire a push/replace/reload navigate event at a Navigation navigation given a NavigationType navigationType, a URL destinationURL, a boolean isSameDocument, an optional user navigation involvement userInvolvement (default "none"), an optional Element-or-null sourceElement (default null), an optional entry list-or-null formDataEntryList (default null), an optional serialized state navigationAPIState (default StructuredSerializeForStorage(null)), and an optional serialized state-or-null classicHistoryAPIState (default null):
</div>
<ol>
	<li>
<p>
~IFï¼»
%åŒä¸€-æ–‡æ›¸ã‹ ~EQ ~T
ï¼½ï¼š
â—
If isSameDocument is true:
</p>
		<ol>
			<li>
<p>
~WHILEï¼»
%~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ ~NEQ ~NULL
ï¼½
â‡’
`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹$( %~navi )
â—
While navigation's ongoing navigate event is not null:
â€¢ Abort the ongoing navigation given navigation.
</p>

<div class="note">
<p>æ³¨è¨˜ï¼š
ã“ã®æ®µã¯ã€ï¼»
é€²è¡Œä¸­ãªéåŒä¸€-æ–‡æ›¸ãª~navi
ï¼½ãŒåœ¨ã‚‹å ´åˆã«ã¯ï¼Œï¼»
ãã‚ŒãŒä¸­æ­¢ã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦ï¼Œ~navi~APIã¸é€šé”ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹
ï¼½ã“ã¨ã‚’æ„å‘³ã™ã‚‹
ï¼ˆä¾‹ï¼š `navigateerror$et ~eventã‚’ç™ºç«ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šï¼‰ã€‚
ã“ã‚Œã¯ã€
ã„ãã¶ã‚“æ­£ç¢ºaã§ã‚ã‚‹
â€” å½“ã®`æ–‡æ›¸$ãŒçµŒé¨“ã™ã‚‹æ¬¡å›ã®~naviã¯ã€
ã“ã®åŒä¸€-æ–‡æ›¸ãª~naviã«ãªã‚‹ã®ã§ã€‚
ãªã®ã§ï¼Œï¼»
æ¬¡å›ã®~naviå®Œäº†ãŒéåŒä¸€-æ–‡æ›¸ãª~naviã®ãã‚Œã«ãªã‚‹
ï¼½ã‚‚ã®ã¨æœŸå¾…ã—ã¦ã„ãŸé–‹ç™ºè€…ã¯ã€
ãã‚ŒãŒèµ·ã“ã‚‰ãªã‹ã£ãŸã¨ã„ã†æœ‰ç”¨ãªé€šé”ã‚’å–å¾—ã™ã‚‹ã€‚
ã—ã‹ã—ãªãŒã‚‰ï¼Œã„ãã¶ã‚“ä¸æ­£ç¢ºã§ã‚‚ã‚ã‚‹
â€” ~browserã¯ã€ï¼»
é€²è¡Œä¸­ãªéåŒä¸€-æ–‡æ›¸ãª~navi
ï¼½ã‚’å‡¦ç†ã—ç¶šã‘ã‚‹ã®ã§
ï¼ˆã“ã®åŒä¸€-æ–‡æ›¸ãª~naviãŒåŒæœŸçš„ã«å®Œé‚ã—ãŸå¾Œã«ï¼Œãã‚Œã‚’é©ç”¨ã™ã‚‹ã‚ˆã†ï¼‰ã€‚
â—
If there is an ongoing cross-document navigation, this means it will be signaled to the navigation API as aborted, e.g., by firing navigateerror events. This is somewhat accurate, since the next navigation the Document experiences will be this same-document navigation, so a developer which was expecting the next navigation completion to be that of the cross-document navigation gets a useful signal that this did not happen. However, it is also somewhat inaccurate, as the browser will continue to process the ongoing cross-document navigation (applying it after this same-document one synchronously finishes).
</p>

<p>
æœ€çµ‚çš„ã«ã¯ã€
~navi~APIã¯ï¼Œï¼»
éåŒä¸€-æ–‡æ›¸ãª~navi, åŒä¸€-æ–‡æ›¸ãª~navi
ï¼½ãŒé‡åˆã™ã‚‹ã“ã¨ã§å°‘ã—æ•£ã‚‰ã‹ã£ã¦ã„ã‚‹
â€” `é€²è¡Œä¸­~naviè¿½è·¡ï¼ #ongoing-navigation-tracking$ã®ï¼»
æ©Ÿæ§‹, ~API
ï¼½ã¯ã€
é€²è¡Œä¸­ãª~naviã‚’ä¸€ã¤ã—ã‹å…¬é–‹ã—ãªã„ã‚ˆã†ç¯‰ã‹ã‚ŒãŸã®ã§ã€‚
~webé–‹ç™ºè€…ã¯ã€
ãã®ã‚ˆã†ãªé‡åˆã—ã¦ã„ã‚‹çŠ¶æ³ã‚’ä½œæˆã—ãªã‘ã‚Œã°ï¼Œæœ€å–„ã«~serveã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹
â€” ä¾‹ï¼š
æ–°ãŸãª~naviã‚’é–‹å§‹ã™ã‚‹å‰ã«
`navigation.navigate()$c ã‹ã‚‰è¿”ã•ã‚ŒãŸ~promiseã‚’ï¼ˆ `await^c ã§ï¼‰å¾…å—ã‘ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€‚
â—
Ultimately, the navigation API gets a bit messy with overlapping cross- and same-document navigations, as the ongoing navigation tracking machinery and APIs are built to expose only a single ongoing navigation. Web developers will be best-served if they do not create such overlapping situations, e.g., by awaiting promises returned from navigation.navigate() before starting new navigations.
</p>
</div>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ®µãŒ~loopã«ãªã£ã¦ã„ã‚‹ã®ã¯ã€
`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹$ã“ã¨ã«ä¼´ã„~JSãŒèµ°ã£ãŸå ´åˆã«
ï¼ˆä¾‹ï¼š `navigateerror$et ~eventã‚’ä»‹ã—ã¦ï¼‰ï¼Œ
ãã‚ŒãŒæ–°ãŸãª~naviã‚’é–‹å§‹ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ãã®ã‚ˆã†ã«é–‹å§‹ã•ã‚ŒãŸ~naviã¯ï¼Œï¼»
ã“ã®~naviã®å®Œäº†ã«ã‚ˆã‚Šå–ã£ã¦ä»£ã‚ã‚‰ã‚Œã‚‹
ï¼½ã“ã¨ã«ãªã‚‹ã®ã§ã€
~navi~APIã¸ã¯ï¼Œä¸­æ­¢ã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦é€šé”ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
â—
This is a loop, since abort the ongoing navigation can run JavaScript (e.g., via the navigateerror event), which might start a new navigation. Since such a newly-started navigation will be superseded by the completion of this navigation, it gets signaled to the navigation API as aborted.
</p>
			</li>
		</ol>
	</li>
	<li>
%~event ~LET `~eventã‚’ä½œæˆã™ã‚‹$( `NavigateEvent$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let event be the result of creating an event given NavigateEvent, in navigation's relevant realm.
</li>
	<li>
%~event ã®`å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹$nEv ~SET %å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹
â—
Set event's classic history API state to classicHistoryAPIState.
</li>
	<li>
%è¡Œå…ˆ ~LET `æ–°ãŸãª~obj$( `NavigationDestination$I, %~navi ã«`é–¢é€£ãª~realm$ )
â€” ãã®
â‡’ï¼ƒ
`~URL$nDt ~SET %è¡Œå…ˆ~URL,
`~entry$nDt ~SET ~NULL,
`çŠ¶æ…‹$nDt ~SET  %~navi~APIçŠ¶æ…‹,
`åŒä¸€-æ–‡æ›¸ã‹$nDt ~SET %åŒä¸€-æ–‡æ›¸ã‹
â—
Let destination be a new NavigationDestination created in navigation's relevant realm.
â—
Set destination's URL to destinationURL.
â—
Set destination's entry to null.
â—
Set destination's state to navigationAPIState.
â—
Set destination's is same document to isSameDocument.
</li>
	<li>
~RET `~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo$( â†“ )
â‡’ï¼ƒ
%~navi,
%~naviç¨®åˆ¥,
%~event,
%è¡Œå…ˆ,
%åˆ©ç”¨è€…-é–¢ä¸i,
%~sourceè¦ç´ 
%~form~data~entry~list,
~NULL
â—
Return the result of performing the inner navigate event firing algorithm given navigation, navigationType, event, destination, userInvolvement, sourceElement, formDataEntryList, and null.
</li>
</ol>
</div>

<div class="algo">
<div class="p">
<p>
`~downloadè¦è«‹~ç”¨ã®~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Navigation$I %~navi )
ãŠã‚ˆã³ï¼Œæ‰€ä¸ã®ï¼š
</p>
<ul>
	<li id="fire-navigate-download-destinationurl">
`~URL$ %è¡Œå…ˆ~URL
</li>
	<li id="fire-navigate-download-userinvolvement">
`~naviã«å¯¾ã™ã‚‹åˆ©ç”¨è€…-é–¢ä¸i$ %åˆ©ç”¨è€…-é–¢ä¸i
</li>
	<li id="fire-navigate-download-sourceelement">
ï¼» `è¦ç´ $ï¼ ~NULL ï¼½ %~sourceè¦ç´ 
</li>
	<li id="fire-navigate-download-filename">
æ–‡å­—åˆ— %~filename
</li>
</ul>
<p>
ã«å¯¾ã—ï¼š
</p>
â—
To fire a download request navigate event at a Navigation navigation given a URL destinationURL, a user navigation involvement userInvolvement, an Element-or-null sourceElement, and a string filename:
</div>
<ol>
	<li>
%~event ~LET `~eventã‚’ä½œæˆã™ã‚‹$( `NavigateEvent$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let event be the result of creating an event given NavigateEvent, in navigation's relevant realm.
</li>
	<li>
%~event ã®`å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹$nEv ~SET ~NULL
â—
Set event's classic history API state to null.
</li>
	<li>
%è¡Œå…ˆ ~LET `æ–°ãŸãª~obj$( `NavigationDestination$I, %~navi ã«`é–¢é€£ãª~realm$ )
â€” ãã®
â‡’ï¼ƒ
`~URL$nDt ~SET %è¡Œå…ˆ~URL,
`~entry$nDt ~SET ~NULL,
`çŠ¶æ…‹$nDt ~SET `StructuredSerializeForStorage$jA( ~NULL ),
`åŒä¸€-æ–‡æ›¸ã‹$nDt ~SET ~F
â—
Let destination be a new NavigationDestination created in navigation's relevant realm.
â—
Set destination's URL to destinationURL.
â—
Set destination's entry to null.
â—
Set destination's state to StructuredSerializeForStorage(null).
â—
Set destination's is same document to false.
</li>
	<li>
~RET `~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo$( â†“ )
â‡’ï¼ƒ
%~navi,
`push$l,
%~event,
%è¡Œå…ˆ,
%åˆ©ç”¨è€…-é–¢ä¸i,
%~sourceè¦ç´ ,
~NULL,
%~filename
â—
Return the result of performing the inner navigate event firing algorithm given navigation, "push", event, destination, userInvolvement, sourceElement, null, and filename.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate_ev~eventã‚’ç™ºç«ã™ã‚‹å†…ç¸~algo@
ã¯ã€
æ‰€ä¸ã®
â‡’ï¼ƒ
`Navigation$I %~navi,
`NavigationType$I %~naviç¨®åˆ¥,
`NavigateEvent$I %~event,
`NavigationDestination$I %è¡Œå…ˆ,
`~naviã«å¯¾ã™ã‚‹åˆ©ç”¨è€…-é–¢ä¸i$ %åˆ©ç”¨è€…-é–¢ä¸i,
ï¼» `è¦ç´ $ï¼ ~NULL ï¼½ %~sourceè¦ç´ ,
ï¼» `~entry~list$ï¼ ~NULL ï¼½ %~form~data~entry~list,
ï¼» æ–‡å­—åˆ—ï¼ ~NULL ï¼½ %~downloadè¦è«‹~filename
â—çµ‚
ã«å¯¾ã—ï¼š
â—
The inner navigate event firing algorithm consists of the following steps, given a Navigation navigation, a NavigationType navigationType, a NavigateEvent event, a NavigationDestination destination, a user navigation involvement userInvolvement, an Element-or-null sourceElement, an entry list-or-null formDataEntryList, and a string-or-null downloadRequestFilename:
</p>
<ol>
	<li>
<p>
~IFï¼»
%~navi ã®`~entryã‚„~eventã¯ä¸èƒ½åŒ–ã•ã‚Œã¦$ã„ã‚‹
ï¼½ï¼š
â—
If navigation has entries and events disabled, then:
</p>
		<ol>
			<li>
~Assertï¼š
%~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$ ~EQ ~NULL
â—
Assert: navigation's ongoing API method tracker is null.
</li>
			<li>
~Assertï¼š
%~navi ã®`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ ~EQ ~NULL
â—
Assert: navigation's upcoming non-traverse API method tracker is null.
</li>
			<li>
~Assertï¼š
%~navi ã®`æ¥ãŸã‚‹è¾¿-~API~methodè¿½è·¡å­~ç¾¤$ã¯`ç©º$ã§ã‚ã‚‹
â—
Assert: navigation's upcoming traverse API method trackers is empty.
</li>
			<li>
~RET ~T
â—
Return true.
</li>
		</ol>

<p class="note">æ³¨è¨˜ï¼š
ã“ã‚Œã‚‰ã®è¡¨æ˜ãŒæº€ãŸã•ã‚Œã‚‹ã®ã¯ã€
~entryã‚„~eventãŒä¸èƒ½åŒ–ã•ã‚ŒãŸã¨ãã¯ï¼Œï¼»
`traverseTo()$mN ï¼ `back()$mN ï¼ `forward()$mN
ï¼½ãŒå³æ™‚ã«å¤±æ•—ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚Š
ï¼ˆè¾¿-å…ˆã‚’æˆã™~entryã¯ç„¡ã„ã®ã§ï¼‰ã€
ä»£ã‚ã‚Šã«ï¼»
`navigate()$mN ï¼ `reload()$mN
ï¼½ã‹ã‚‰é–‹å§‹ã—ãŸã§ã‚‚ï¼Œã¾ãšæœ€åˆã«`æ¥ãŸã‚‹é-è¾¿-~API~methodè¿½è·¡å­$ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚’`é¿ã‘ãŸï¼ #dont-always-set-upcoming-non-traverse-api-method-tracker$ã‹ã‚‰ã§ã‚ã‚‹ã€‚
â—
These assertions holds because traverseTo(), back(), and forward() will immediately fail when entries and events are disabled (since there are no entries to traverse to), and if our starting point is instead navigate() or reload(), then we avoided setting the upcoming non-traverse API method tracker in the first place.
</p>
	</li>
	<li>
%è¡Œå…ˆ~key ~LET ~NULL
â—
Let destinationKey be null.
</li>
	<li>
~IFï¼»
%è¡Œå…ˆ ã®`~entry$nDt ~NEQ ~NULL
ï¼½
â‡’
%è¡Œå…ˆ~key ~SET %è¡Œå…ˆ ã®`~entry$nDtã®`~key$nE
â—
If destination's entry is non-null, then set destinationKey to destination's entry's key.
</li>
	<li>
~Assertï¼š
%è¡Œå…ˆ~key ~NEQ ç©º~æ–‡å­—åˆ—
â—
Assert: destinationKey is not the empty string.
</li>
	<li>
`æ¥ãŸã‚‹~API~methodè¿½è·¡å­ã‚’é€²è¡Œä¸­ã«ã™ã‚‹$( %~navi, %è¡Œå…ˆ~key )
â—
Promote an upcoming API method tracker to ongoing given navigation and destinationKey.
</li>
	<li>
%~API~methodè¿½è·¡å­ ~LET %~navi ã®`é€²è¡Œä¸­ãª~API~methodè¿½è·¡å­$
â—
Let apiMethodTracker be navigation's ongoing API method tracker.
</li>
	<li>
%~navigable ~LET %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`å¯¾å¿œã™ã‚‹~navigable$
â—
Let navigable be navigation's relevant global object's navigable.
</li>
	<li>
%æ–‡æ›¸ ~LET %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be navigation's relevant global object's associated Document.
</li>
	<li>
<p>
%~event ã®å„ç¨®~å±æ€§ã‚’ä»¥ä¸‹ã«å¾“ã£ã¦åˆæœŸåŒ–ã™ã‚‹ï¼š
</p>
		<ol>
			<li>
<p>
%~event ã® `canIntercept$mE ~SET ~IS ~ANDâ†“ï¼š
</p>
				<ul>
					<li>
`æ–‡æ›¸ã®~URLã¯æ›¸ç›´ã›ã‚‹ã‹å¦ã‹$( %æ–‡æ›¸, %è¡Œå…ˆ ã®`~URL$nDt ) ~EQ ~T
</li>
					<li>
ï¼»
%è¡Œå…ˆ ã®`åŒä¸€-æ–‡æ›¸ã‹$nDt~EQ ~T
ï¼½~ORï¼»
%~naviç¨®åˆ¥ ~NEQ `traverse$l
ï¼½
</li>
				</ul>
â—
If document can have its URL rewritten to destination's URL, and either destination's is same document is true or navigationType is not "traverse", then initialize event's canIntercept to true. Otherwise, initialize it to false.
</li>
			<li>
<p>
%~event ã®`cancelable$m ~SET ~IS ~ORâ†“ï¼š
</p>
				<ul>
					<li>
%~naviç¨®åˆ¥ ~NEQ `traverse$l
</li>
					<li id="navigate-event-traverse-can-be-canceled">
<p>
~ANDâ†“ï¼š
</p>
						<ul>
							<li>
%~navigable ã¯`~top-levelè¾¿å¯èƒ½$ã§ã‚ã‚‹
</li>
							<li>
%è¡Œå…ˆ ã®`åŒä¸€-æ–‡æ›¸ã‹$nDt~EQ ~T
</li>
							<li>
ï¼»
%åˆ©ç”¨è€…-é–¢ä¸i ~NEQ `~browser~UI$i
ï¼½~ORï¼»
%~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã¯`å±¥æ­´~å‹•ä½œã«ã‚ˆã‚‹ä½œå‹•åŒ–ã‚’æœ‰ã—ã¦$ã„ã‚‹
ï¼½
</li>
						</ul>
					</li>
				</ul>
â—
Let traverseCanBeCanceled be true if all of the following are true:
â€¢ navigable is a top-level traversable;
â€¢ destination's is same document is true; and
â€¢ either userInvolvement is not "browser UI", or navigation's relevant global object has history-action activation.
â—
Otherwise, let it be false.
â—
If either:
â€¢ navigationType is not "traverse"; or
â€¢ traverseCanBeCanceled is true,
â—
then initialize event's cancelable to true. Otherwise, initialize it to false.
</li>
			<li>
%~event ã®
â‡’ï¼ƒ
`type$m ~SET "`navigate$et",
`navigationType$mE ~SET %~naviç¨®åˆ¥,
`destination$mE ~SET %è¡Œå…ˆ,
`downloadRequest$mE ~SET %~downloadè¦è«‹~filename
â—
Initialize event's type to "navigate".
â—
Initialize event's navigationType to navigationType.
â—
Initialize event's destination to destination.
â—
Initialize event's downloadRequest to downloadRequestFilename.
</li>
			<li>
<p>
%~event ã® `info$mE ~SET ï¼»
%~API~methodè¿½è·¡å­ ~NEQ ~NULL ãªã‚‰ã° %~API~methodè¿½è·¡å­ ã®`å ±$amT ï¼
~ELSE_ `undefined^jv
ï¼½
â—
If apiMethodTracker is not null, then initialize event's info to apiMethodTracker's info. Otherwise, initialize it to undefined.
</p>

<p class="note">æ³¨è¨˜ï¼š
ã“ã®æ™‚ç‚¹ã§ã€
%~API~methodè¿½è·¡å­ ã®`å ±$amT ã¯ï¼Œã‚‚ã¯ã‚„å¿…è¦ãªããªã‚‹
â€” å®Ÿè£…ã¯ã€
å½“ã®`~navi~API~methodè¿½è·¡å­$ãŒå­˜ç¶šã™ã‚‹é™ã‚Š ãã‚ŒãŒç”Ÿå­˜ã—ç¶šã‘ãªã„ã‚ˆã†ï¼Œ
ãã‚Œã‚’ ~NULL åŒ–ã§ãã‚‹ã€‚
â—
At this point apiMethodTracker's info is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the navigation API method tracker.
</p>
			</li>
			<li>
%~event ã® `hasUAVisualTransition$mE ~SET ~ISï¼»
~UAã¯~cacheã—ã¦ã‚ã£ãŸï¼»
%æ–‡æ›¸ ã®`æœ€è¿‘ã®~entry$ãŒæç”»ã•ã‚ŒãŸçŠ¶æ…‹
ï¼½ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®è¦–è¦šçš„ãªé·ç§»ã‚’è¡Œã£ãŸ
ï¼½
â—
Initialize event's hasUAVisualTransition to true if a visual transition, to display a cached rendered state of the document's latest entry, was done by the user agent. Otherwise, initialize it to false.
</li>
			<li>
%~event ã® `sourceElement$mE ~SET %~sourceè¦ç´ 
â—
Initialize event's sourceElement to sourceElement.
</li>
			<li>
%~event ã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEv ~SET `æ–°ãŸãª~obj$( `AbortController$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Set event's abort controller to a new AbortController created in navigation's relevant realm.
</li>
			<li>
%~event ã®`signal$mE ~SET %~event ã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEvã®`é€šé”$aC
â—
Initialize event's signal to event's abort controller's signal.
</li>
			<li>
%ç¾åœ¨ã®~URL ~LET %æ–‡æ›¸ ã®`~URL$doc
â—
Let currentURL be document's URL.
</li>
			<li>
<p>
%~event ã®`hashChange$mE ~SET ~IS ~ANDâ†“ï¼š
</p>
				<ul>
					<li>
%~event ã®`å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹$nEv ~EQ ~NULL
</li>
					<li>
%è¡Œå…ˆ ã®`åŒä¸€-æ–‡æ›¸ã‹$nDt~EQ ~T ;
</li>
					<li>
( %è¡Œå…ˆ ã®`~URL$nDt, %ç¾åœ¨ã®~URL )
ã¯ã€
`ç´ ç‰‡ã¯é™¤å¤–ã™ã‚‹^i ä¸‹ã§`åŒç­‰ãª~URL$ã§ã‚ã‚‹
</li>
					<li>
%è¡Œå…ˆ ã®`~URL$nDtã®`ç´ ç‰‡$url ~NEQ %ç¾åœ¨ã®~URL ã®`ç´ ç‰‡$url
</li>
				</ul>

<p class="note">æ³¨è¨˜ï¼š
ä¸Šã®æœ€åˆã®æ¡ä»¶ã¯ã€
`hashChange$mE ã¯ï¼»
`ç´ ç‰‡ã¸ã®~navi$ç”¨ã«ã¯ ~T ã«ãªã‚‹
ï¼½ãŒï¼»
`history.pushState(undefined, "", "#fragment")^c ã®æ§˜ãªäº‹ä¾‹ã§ã¯ ~F ã«ãªã‚‹
ï¼½ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
</p>
â—
If all of the following are true:
â€¢ event's classic history API state is null;
â€¢ destination's is same document is true;
â€¢ destination's URL equals currentURL with exclude fragments set to true; and
â€¢ destination's URL's fragment is not identical to currentURL's fragment,
â—
then initialize event's hashChange to true. Otherwise, initialize it to false.
â—
The first condition here means that hashChange will be true for fragment navigations, but false for cases like history.pushState(undefined, "", "#fragment").
</li>
			<li>
%~event ã® `userInitiated$mE ~SET ~ISï¼»
%åˆ©ç”¨è€…-é–¢ä¸i ~NEQ `ãªã—$i
ï¼½
â—
If userInvolvement is not "none", then initialize event's userInitiated to true. Otherwise, initialize it to false.
</li>
			<li>
%~event ã®`formData$mE ~SET ~NULL
â—
â†“</li>
			<li>
~IFï¼»
%~form~data~entry~list ~NEQ ~NULL
ï¼½
â‡’
%~event ã®`formData$mE ~SET `æ–°ãŸãª~obj$( `FormData$I, %~navi ã«`é–¢é€£ãª~realm$ )
â€” ãã®
â‡’ï¼ƒ
ã€`~entry~list$ ~SET ã€‘%~form~data~entry~list
â—
If formDataEntryList is not null, then initialize event's formData to a new FormData created in navigation's relevant realm, associated to formDataEntryList. Otherwise, initialize it to null.
</li>
		</ol>
	</li>
	<li>
~Assertï¼š
%~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ ~EQ ~NULL
â—
Assert: navigation's ongoing navigate event is null.
</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ ~SET %~event
â—
Set navigation's ongoing navigate event to event.
</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã«~focusã¯å¤‰åŒ–ã—ãŸã‹$ ~SET ~F
â—
Set navigation's focus changed during ongoing navigation to false.
</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã¯é€šå¸¸ã®~scrollå¾©æ—§ã‚’æŠ‘æ­¢ã™ã‚‹ã‹$ ~SET ~F
â—
Set navigation's suppress normal scroll restoration during ongoing navigation to false.
</li>
	<li>
%é…é€-çµæœ ~LET `~eventã‚’é…é€ã™ã‚‹$( %~navi, %~event )
â—
Let dispatchResult be the result of dispatching event at navigation.
</li>
	<li>
<p>
~IFï¼»
%é…é€-çµæœ ~EQ ~F
ï¼½ï¼š
â—
If dispatchResult is false:
</p>
		<ol>
			<li>
~IFï¼»
%~naviç¨®åˆ¥ ~EQ `traverse$l
ï¼½
â‡’
`å±¥æ­´~å‹•ä½œã«ã‚ˆã‚‹ä½œå‹•åŒ–ã‚’æ¶ˆè²»ã™ã‚‹$( %~navi ã«`é–¢é€£ãªå¤§åŸŸ~obj$ )
â—
If navigationType is "traverse", then consume history-action user activation given navigation's relevant global object.
</li>
			<li>
~IFï¼»
%~event ã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEvã®`é€šé”$aCã¯`ä¸­æ­¢-æ¸ˆã¿$aBã§ãªã„
ï¼½
â‡’
`é€²è¡Œä¸­ãª~naviã‚’ä¸­æ­¢ã™ã‚‹$( %~navi )
â—
If event's abort controller's signal is not aborted, then abort the ongoing navigation given navigation.
</li>
			<li>
~RET ~F
â—
Return false.
</li>
		</ol>
	</li>
	<li>
<p>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `none^l
ï¼½ï¼š
â—
If event's interception state is not "none":
</p>
		<ol>
			<li>
%~from~NHE ~LET `~naviã®ç¾åœ¨ã®~entry$( %~navi )
â—
Let fromNHE be the current entry of navigation.
</li>
			<li>
~Assertï¼š
%~from~NHE ~NEQ ~NULL
â—
Assert: fromNHE is not null.
</li>
			<li>
%~navi ã®`é·ç§»$ ~SET `æ–°ãŸãª~obj$( `NavigationTransition$I, %~navi ã«`é–¢é€£ãª~realm$ )
â€” ãã®
â‡’ï¼ƒ
`~naviç¨®åˆ¥$nTr ~SET %~naviç¨®åˆ¥,
`~from~entry$nTr ~SET %~from~NHE,
`~commitæ™‚ã®~promise$nTr ~SET `æ–°ãŸãª~promise$( %~navi ã«`é–¢é€£ãª~realm$ ),
`å®Œé‚-æ™‚ã®~promise$nTr ~SET `æ–°ãŸãª~promise$( %~navi ã«`é–¢é€£ãª~realm$ )
â—
Set navigation's transition to a new NavigationTransition created in navigation's relevant realm, with
â€¢ navigation type
â€¢â€¢ navigationType
â€¢ from entry
â€¢ fromNHE
â€¢ committed promise
â€¢â€¢ a new promise created in navigation's relevant realm
â€¢ finished promise
â€¢â€¢ a new promise created in navigation's relevant realm
</li>
			<li>
<p>
`~promiseã‚’å–æ‰±æ¸ˆã¿ã¨ã—ã¦~markã™ã‚‹$( %~navi ã®`é·ç§»$ã®`å®Œé‚-æ™‚ã®~promise$nTr )
â—
Mark as handled navigation's transition's finished promise.
</p>

<p class="note">æ³¨è¨˜ï¼š
ãªãœã“ã‚ŒãŒè¡Œã‚ã‚Œã‚‹ã‹ç†è§£ã™ã‚‹ã«ã¯ã€
`ä»–ã®å®Œé‚-æ™‚ã®~promiseã«ã¤ã„ã¦ã®è«–ç‚¹ï¼ #note-mark-as-handled-navigation-api-finished$ã‚’è¦‹ã‚ˆã€‚
â—
See the discussion about other finished promises to understand why this is done.
</p>
			</li>
			<li>
`~promiseã‚’å–æ‰±æ¸ˆã¿ã¨ã—ã¦~markã™ã‚‹$( %~navi ã®`é·ç§»$ã®`~commitæ™‚ã®~promise$nTr )
â—
Mark as handled navigation's transition's committed promise.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~event ã®`~navi~precommit~handler~list$nEvã¯`ç©º$ã§ã‚ã‚‹
ï¼½
â‡’
`~navigate_ev~eventã‚’~commitã™ã‚‹$( %~event, %~API~methodè¿½è·¡å­ )
â—
If event's navigation precommit handler list is empty then run commit event given apiMethodTracker.
</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
		<ol>
			<li>
%~precommitåˆ¶å¾¡å™¨ ~LET `æ–°ãŸãª~obj$( `NavigationPrecommitController$I, %~navi ã«`é–¢é€£ãª~realm$ )
â—
Let precommitController be a new NavigationPrecommitController created in navigation's relevant realm,ï¼¼
</li>
			<li>
%~precommitåˆ¶å¾¡å™¨ ã®`~event$pCC ~SET %~event
â—
whose event is event.
</li>
			<li>
%~precommit~promise~list ~LET æ–°ãŸãª`~list$
â—
Let precommitPromisesList be an empty list.
</li>
			<li>
%~event ã®`~navi~precommit~handler~list$nEvã‚’æˆã™
~EACH( %~handler )
ã«å¯¾ã—
â‡’
%~precommit~promise~list ã«æ¬¡ã®çµæœã‚’`ä»˜åŠ ã™ã‚‹$
â‡’
`~callbacké–¢æ•°ã‚’å‘¼å‡ºã™$( %~handler, Â« %~precommitåˆ¶å¾¡å™¨ Â», Îµ )
â—
For each handler of event's navigation precommit handler list:
â€¢ Append the result of invoking handler with Â« precommitController Â» to precommitPromisesList.
</li>
			<li>
<p>
`ã™ã¹ã¦ã®~promiseã‚’å¾…æ©Ÿã™ã‚‹$( %~precommit~promise~list )
â€” æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼š
â—
Wait for all precommitPromisesList withï¼¼
</p>
				<ul>
					<li class="algo">
`æˆåŠŸ~æ‰‹ç¶šã^i ã¯
â‡’
`~navigate_ev~eventã‚’~commitã™ã‚‹$( %~event, %~API~methodè¿½è·¡å­ )
â—
the following success steps: commit event given apiMethodTracker,ï¼¼
</li>
					<li class="algo">
`å¤±æ•—~æ‰‹ç¶šã^i ã¯ã€
æ‰€ä¸ã®
( %äº‹ç”± )
ã«å¯¾ã—
â‡’
`~navigate_ev~event~handlerã®å¤±æ•—ã‚’å‡¦ç†ã™ã‚‹$( %~event, %äº‹ç”± )
â—
and the following failure step given reason: process navigate event handler failure given event and reason.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET ~ISï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~EQ `none^l
ï¼½
â—
If event's interception state is "none", then return true.
â—
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate_ev~eventã‚’~commitã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I ~obj %~event, `~navi~API~methodè¿½è·¡å­$ %~API~methodè¿½è·¡å­ )
ã«å¯¾ã—ï¼š
â—
To commit a navigate event given a NavigateEvent object event and a navigation API method tracker apiMethodTracker:
</p>
<ol>
	<li>
%~navi ~LET %~event ã®`~target$
â—
Let navigation be event's target.
</li>
	<li>
%~navigable ~LET %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`å¯¾å¿œã™ã‚‹~navigable$
â—
Let navigable be event's relevant global object's navigable.
</li>
	<li>
~IFï¼»
%~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET
â—
If event's relevant global object's associated Document is not fully active, then return.
</li>
	<li>
~IFï¼»
%~event ã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEvã®`é€šé”$aCã¯`ä¸­æ­¢-æ¸ˆã¿$aBã§ã‚ã‚‹
ï¼½
â‡’
~RET
â—
If event's abort controller's signal is aborted, then return.
</li>
	<li>
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~SET `committed^l
â—
Set event's interception state to "committed".
</li>
	<li>
%çµ‚äº†~çµæœã¯åŒä¸€-æ–‡æ›¸ã‹ ~LET ~ISï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `none^l
ï¼½~ORï¼»
%~event ã®`destination$mE ã®`åŒä¸€-æ–‡æ›¸ã‹$nDt~EQ ~T
ï¼½
â—
Let endResultIsSameDocument be true if event's interception state is not "none" or event's destination's is same document is true.
</li>
	<li>
<p>
`~scriptã‚’èµ°ã‚‰ã™ãŸã‚ã«æº–å‚™ã™ã‚‹$( %~navi ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$ )
â—
Prepare to run script given navigation's relevant settings object.
</p>

<div class="note" id="note-suppress-microtasks-during-navigation-events">
<p>æ³¨è¨˜ï¼š
ã“ã‚Œã¯ã€ï¼»
ã™ãã«èµ·ã“ã‚‹ã“ã¨ã‚‚ã‚ã‚‹`~URLã¨å±¥æ­´ã‚’æ›´æ–°ã™ã‚‹$æ‰‹ç¶šã
ï¼½ã®çµæœï¼Œï¼»
`currententrychange$et ~event~handlerãŒèµ°ã£ãŸç›´å¾Œ
ï¼½ã«ï¼»
`~JSå®Ÿè¡Œ~æ–‡è„ˆ~stack$ãŒç©ºã«ãªã‚‹
ï¼½ã®ã‚’é¿ã‘ã‚‹ãŸã‚ã«è¡Œã‚ã‚Œã‚‹ã€‚
ãã®æ™‚ç‚¹ã§~stackãŒç©ºã«ãªã£ãŸå ´åˆã€
å³æ™‚ã«`å°task~checkpointã‚’é‚è¡Œã™ã‚‹$ã“ã¨ã«ãªã‚‹çµæœï¼Œ
æ§˜ã€…ãª~promiseã®å……è¶³~handlerã‚’ï¼»
`currententrychange$et ~event~handlerãŸã¡ã«å·®æŒŸã‚“ã§ ï¼
`intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ã«æ¸¡ã•ã‚ŒãŸ~handlerãŸã¡ã‚ˆã‚Šå‰ã«
ï¼½èµ°ã‚‰ã™ã“ã¨ã«ãªã‚Šï¼Œæœ›ã¾ã—ããªã„
â€” ãã‚Œã¯ã€ï¼»
~promise~handler,
`currententrychange$et ~event~handler,
`intercept()$mE ~handler
ï¼½ã®é †åºä»˜ã‘ãŒï¼»
å½“ã®~naviãŒèµ·ãã¦ã„ã‚‹ã®ã¯`~JSå®Ÿè¡Œ~æ–‡è„ˆ~stack$ãŒï¼»
ç©ºãªã¨ã
ï¼ˆä¾‹ï¼šåˆ©ç”¨è€…ãŒ~naviã‚’èµ·å‹•ã—ãŸãŸã‚ï¼‰ï¼
ç©ºã§ãªã„ã¨ã
ï¼ˆä¾‹ï¼šå½“ã®~naviã¯~JS~API~callã«ã‚ˆã‚Šèµ·å‹•ã•ã‚ŒãŸãŸã‚ï¼‰
ï¼½ã©ã¡ã‚‰ãªã®ã‹
ï¼½ã«ä¾å­˜ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã®ã§ã€‚
â—
This is done to avoid the JavaScript execution context stack becoming empty right after any currententrychange event handlers run as a result of the URL and history update steps that could soon happen. If the stack were to become empty at that time, then it would immediately perform a microtask checkpoint, causing various promise fulfillment handlers to run interleaved with the event handlers and before any handlers passed to navigateEvent.intercept(). This is undesirable since it means promise handler ordering vs. currententrychange event handler ordering vs. intercept() handler ordering would be dependent on whether the navigation is happening with an empty JavaScript execution context stack (e.g., because the navigation was user-initiated) or with a nonempty one (e.g., because the navigation was caused by a JavaScript API call).
</p>

<p>
ã“ã®æ®µã§ï¼Œä»–ã§ã¯ä¸å¿…è¦ãª`~JSå®Ÿè¡Œ~æ–‡è„ˆ$ã‚’~stackã«æŒ¿å…¥ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€
æœ¬è³ªçš„ã«ï¼Œ
`å°task~checkpointã‚’é‚è¡Œã™ã‚‹$~algoã‚’å¾Œã®æ™‚ç‚¹ã¾ã§æŠ‘æ­¢ã™ã‚‹
â€” ã—ãŸãŒã£ã¦ã€
å„ç¨®~handlerã¯ï¼Œå¸¸ã«æ¬¡ã®é †ã«èµ°ã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ãŒç¢ºä¿ã•ã‚Œã‚‹
â‡’ï¼ƒ
`currententrychange$et ~event~handlerãŸã¡,
`intercept()$mE ~handlerãŸã¡,
~promise~handlerãŸã¡
â—
By inserting an otherwise-unnecessary JavaScript execution context onto the stack in this step, we essentially suppress the perform a microtask checkpoint algorithm until later, thus ensuring that the sequence is always: currententrychange event handlers, then intercept() handlers, then promise handlers.
</p>
</div>
	</li>
	<li>
~IFï¼»
%~navi ã®`é·ç§»$ ~NEQ ~NULL
ï¼½
â‡’
`~promiseã‚’è§£æ±ºã™ã‚‹$( %~navi ã®`é·ç§»$ã®`~commitæ™‚ã®~promise$nTr )
â—
If navigation's transition is not null, then resolve navigation's transition's committed promise with undefined.
</li>
	<li>
<p>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `none^l
ï¼½ï¼š
â—
If event's interception state is not "none":
</p>
		<ol>
			<li>
<p>
%~event ã® `navigationType$mE ã«å¿œã˜ã¦ï¼š
â—
Switch on event's navigationType:
</p>
				<dl class="switch">
					<dt>`push$l</dt>
					<dt>`replace$l</dt>
					<dd>
`~URLã¨å±¥æ­´ã‚’æ›´æ–°ã™ã‚‹$( %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$, %~event ã® `destination$mE ã®`~URL$nDtã€ï¼`url$mDã€‘ )
â€” æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§
â‡’ï¼ƒ
`ç›´åˆ—å½¢ã®~data^i ~SET %~event ã®`å¤å…¸~å±¥æ­´~APIç”¨ã®çŠ¶æ…‹$nEv,
`å±¥æ­´~å–æ‰±ã„^i ~SET %~event ã® `navigationType$mE
â—
Run the URL and history update steps given event's relevant global object's associated Document and event's destination's URL, with serializedData set to event's classic history API state and historyHandling set to event's navigationType.
</dd>

					<dt>`reload$l</dt>
					<dd>
`åŒä¸€-æ–‡æ›¸~naviç”¨ã«~navi~API~entryç¾¤ã‚’æ›´æ–°ã™ã‚‹$( %~navi, %~navigable ã«ã¦`ä½œå‹•ä¸­ãª~entry$nav, `reload$l )
â—
Update the navigation API entries for a same-document navigation given navigation, navigable's active session history entry, and "reload".
</dd>

					<dt>`traverse$l</dt>
					<dd>
						<ol>
							<li>
<p>
%~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã¯é€šå¸¸ã®~scrollå¾©æ—§ã‚’æŠ‘æ­¢ã™ã‚‹ã‹$ ~SET ~T
â—
Set navigation's suppress normal scroll restoration during ongoing navigation to true.
</p>

<p class="note">æ³¨è¨˜ï¼š
%~event ã®`~scrollç”¨ã®æŒ™å‹•$nEvãŒ `after-transition$lS ã«è¨­å®šã•ã‚ŒãŸå ´åˆã€
~scrollå¾©æ—§ã¯ã€
é–¢é€£ãª `NavigateEvent$I ã‚’`å®Œé‚ã™ã‚‹ï¼ #navigateevent-finish$ã¨ãã®ä¸€éƒ¨ã¨ã—ã¦èµ·ã“ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
ä»–ã®å ´åˆã€
~scrollå¾©æ—§ã¯ç„¡ã„ã€‚
ã™ãªã‚ã¡ã€
`intercept()$mE ã«ã‚ˆã‚Šæ¨ªå–ã•ã‚ŒãŸ~naviã¯ï¼Œ
é€šå¸¸ã®~scrollå¾©æ—§~å‡¦ç†nã‚’çµŒãªã„
â€” ãã®ã‚ˆã†ãª~naviç”¨ã®~scrollå¾©æ—§ã¯ã€
~webé–‹ç™ºè€…ã«ã‚ˆã‚Šæ‰‹å‹•ã§è¡Œã‚ã‚Œã‚‹ã‹ï¼Œå½“ã®é·ç§»ã‚ˆã‚Šå¾Œã«è¡Œã‚ã‚Œã‚‹ã€‚
â—
If event's scroll behavior was set to "after-transition", then scroll restoration will happen as part of finishing the relevant NavigateEvent. Otherwise, there will be no scroll restoration. That is, no navigation which is intercepted by intercept() goes through the normal scroll restoration process; scroll restoration for such navigations is either done manually, by the web developer, or is done after the transition.
</p>
							</li>
							<li>
%åˆ©ç”¨è€…-é–¢ä¸i ~LET `ãªã—$i
â—
Let userInvolvement be "none".
</li>
	<li>
~IFï¼»
%~event ã® `userInitiated$mE ~EQ ~T
ï¼½
â‡’
%åˆ©ç”¨è€…-é–¢ä¸i ~SET `ä½œå‹•åŒ–$i
â—
If event's userInitiated is true, then set userInvolvement to "activation".
</p>

<p class="note">æ³¨è¨˜ï¼š
æ¨ªå–~å¾Œã«ãŠã‘ã‚‹ ã“ã®æ™‚ç‚¹ã§ã¯ã€
å½“ã®ä½œå‹•åŒ–ãŒ~browser~UIã®çµæœã§ã‚ã£ãŸã¨ã—ã¦ã‚‚ï¼Œ
å¸°çµã¯åŒã˜ã«ãªã‚‹ã€‚
â—
At this point after interception, it is not consequential whether the activation was a result of browser UI.
</p>
							</li>
							<li>
`~sessionå±¥æ­´~è¾¿ã‚Šæ‰‹ç¶šãã‚’ä»˜åŠ ã™ã‚‹$( %~navigable ã®`è¾¿å¯èƒ½ãª~navigable$nav, æ¬¡ã®æ‰‹ç¶šã )
â—
Append the following session history traversal steps to navigable's traversable navigable:
</p>

<div class="algo">
æ‰‹ç¶šãã¯
â‡’
`è¾¿-ç”¨ã«å±¥æ­´~stepã‚’é©ç”¨ã™ã‚‹ã“ã¨ã‚’å†é–‹ã™ã‚‹$( â†“ )
â‡’ï¼ƒ
%~event ã® `destination$mE ã®`~entry$nDtã®`~sessionå±¥æ­´~entry$nhe ã®`~step$shE,
%~navigable ã®`è¾¿å¯èƒ½ãª~navigable$nav,
%åˆ©ç”¨è€…-é–¢ä¸i
â—
â€¢ Resume applying the traverse history step given event's destination's entry's session history entry's step, navigable's traversable navigable, and userInvolvement.
</div>
							</li>
						</ol> 
					</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
~IFï¼»
%çµ‚äº†~çµæœã¯åŒä¸€-æ–‡æ›¸ã‹ ~EQ ~T
ï¼½ï¼š
â—
If endResultIsSameDocument is true:
</p>
		<ol>
			<li>
%~promise~list ~LET æ–°ãŸãª`~list$
â—
Let promisesList be an empty list.
</li>
			<li>
%~event ã®`~navi~handler~list$nEvã‚’æˆã™
~EACH( %~handler )
ã«å¯¾ã—
â‡’
%~promise~list ã«æ¬¡ã®çµæœã‚’`ä»˜åŠ ã™ã‚‹$
â‡’
`~callbacké–¢æ•°ã‚’å‘¼å‡ºã™$( %~handler, Â« Â», Îµ )
â—
For each handler of event's navigation handler list:
â€¢ Append the result of invoking handler with an empty arguments list to promisesList.
</li>
			<li>
~IFï¼»
%~promise~list ã®`~size$ ~EQ 0
ï¼½
â‡’
%~promise~list ~SET Â« `è§£æ±ºã•ã‚Œã‚‹~promise$( `undefined^jv ) Â»
â—
If promisesList's size is 0, then set promisesList to Â« a promise resolved with undefined Â».
</p>

<p class="note">æ³¨è¨˜ï¼š
`ã™ã¹ã¦ã®~promiseã‚’å¾…æ©Ÿã™ã‚‹$é–“ã«ï¼Œãã®ï¼»
æˆåŠŸ~æ‰‹ç¶šã, å¤±æ•—~æ‰‹ç¶šã
ï¼½ã‚’ã©ã†~scheduleã™ã‚‹ã‹ã«é–¢ã—ã¦ã€
æ‰€ä¸ã®~promiseãŒï¼»
ç„¡ã„ã¨ã, 1 å€‹ä»¥ä¸Šã‚ã‚‹ã¨ã
ï¼½ã§å¾®å¦™ãªæ™‚æ©Ÿã®ç›¸é•ãŒã‚ã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€
`ã™ã¹ã¦ã®~promiseã‚’å¾…æ©Ÿã™ã‚‹$ã»ã¨ã‚“ã©ã®åˆ©ç”¨ã«ãŠã„ã¦ã¯å•ã‚ã‚Œãªã„ã€‚
ã—ã‹ã—ãªãŒã‚‰ã€
ã“ã®~APIã«ã¯ï¼ŒåŒæ™‚æœŸã«ç™ºç«ã™ã‚‹ã“ã¨ã‚‚ã‚ã‚‹ï¼»
~event~handler, ~promise~handler
ï¼½ãŒã„ãã¤ã‚‚ã‚ã‚‹ã®ã§ã€
ãã®ç›¸é•ã¯ã‹ãªã‚Šå®¹æ˜“ã«è¦³æ¸¬-å¯èƒ½ã«ãªã‚‹
â€” ãã‚Œã¯ã€
ã“ã‚Œã‚‰ã®~handlerãŒèµ°ã‚‹é †åºã‚’å¤‰ãˆå¾—ã‚‹ã®ã§ã€‚
æ¬¡ã«æŒ™ã’ã‚‹ï¼»
~eventï¼~promise
ï¼½ã¯ã€
ãã“ã«å­•ã¾ã‚Œã‚‹
â‡’ï¼ƒ
`navigatesuccess$et,
`navigateerror$et,
`currententrychange$et,
`dispose$et,
%~API~methodè¿½è·¡å­ ã®~promise,
`navigation.transition.finished$c ~promise
â—
There is a subtle timing difference between how waiting for all schedules its success and failure steps when given zero promises versus â‰¥1 promises. For most uses of waiting for all, this does not matter. However, with this API, there are so many events and promise handlers which could fire around the same time that the difference is pretty easily observable: it can cause the event/promise handler sequence to vary. (Some of the events and promises involved include: navigatesuccess / navigateerror, currententrychange, dispose, apiMethodTracker's promises, and the navigation.transition.finished promise.)
</p>
			</li>
			<li>
`ã™ã¹ã¦ã®~promiseã‚’å¾…æ©Ÿã™ã‚‹$( %~promise~list )
â€” æ¬¡ã‚’ä¸ãˆã‚‹ä¸‹ã§ï¼š
â—
Wait for all of promisesList, withï¼¼
</p>
				<ul>
					<li class="algo">
<p>
`æˆåŠŸ~æ‰‹ç¶šã^i ã¯ï¼š
â—
the following success steps:
</p>
						<ol>
							<li>
~IFï¼»
%~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET
â—
If event's relevant global object is not fully active, then abort these steps.
</li>
							<li>
If event's abort controller's signal is aborted, then abort these steps.
</li>
							<li>
~Assertï¼š
%~event ~EQ %~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$
â—
Assert: event equals navigation's ongoing navigate event.
</li>
							<li>
%~navi ã®`é€²è¡Œä¸­ãª~navigate_ev~event$ ~SET ~NULL
â—
Set navigation's ongoing navigate event to null.
</li>
							<li>
`~navigate_ev~eventã‚’å®Œé‚ã™ã‚‹$( %~event, ~T )
â—
Finish event given true.
</li>
							<li>
~IFï¼»
%~API~methodè¿½è·¡å­ ~NEQ ~NULL
ï¼½
â‡’
`å®Œé‚-æ™‚ã®~promiseã‚’è§£æ±ºã™ã‚‹$( %~API~methodè¿½è·¡å­ )
â—
If apiMethodTracker is non-null, then resolve the finished promise for apiMethodTracker.
</li>
							<li>
`~eventã‚’ç™ºç«ã™ã‚‹$( %~navi, `navigatesuccess$et )
â—
Fire an event named navigatesuccess at navigation.
</li>
							<li>
~IFï¼»
%~navi ã®`é·ç§»$ ~NEQ ~NULL
ï¼½
â‡’
`~promiseã‚’è§£æ±ºã™ã‚‹$( %~navi ã®`é·ç§»$ã®`å®Œé‚-æ™‚ã®~promise$nTr )
â—
If navigation's transition is not null, then resolve navigation's transition's finished promise with undefined.
</li>
							<li>
%~navi ã®`é·ç§»$ ~SET ~NULL
â—
Set navigation's transition to null.
</li>
						</ol>
					</li>
					<li class="algo">
<p>
`å¤±æ•—~æ‰‹ç¶šã^i ã¯ã€
æ‰€ä¸ã®
( %äº‹ç”± )
ã«å¯¾ã—
â‡’
`~navigate_ev~event~handlerã®å¤±æ•—ã‚’å‡¦ç†ã™ã‚‹$( %~event, %äº‹ç”± )
â—
and the following failure step given reason: process navigate event handler failure given event and reason.
</p>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~ELIFï¼»
%~API~methodè¿½è·¡å­ ~NEQ ~NULL
ï¼½
â‡’
`è¿½è·¡å­ã‚’ç‰‡ä»˜ã‘ã‚‹$( %~API~methodè¿½è·¡å­ )
â—
Otherwise, if apiMethodTracker is non-null, then clean up apiMethodTracker.
</li>
	<li>
`èµ°ã‚‰ã›ãŸ~scriptã‚’ç‰‡ä»˜ã‘ã‚‹$( %~navi ã«`é–¢é€£ãªè¨­å®šç¾¤~obj$ )
â—
Clean up after running script given navigation's relevant settings object.
</p>

<p class="note">æ³¨è¨˜ï¼š
`ä¸Šã®æ³¨è¨˜ï¼ #note-suppress-microtasks-during-navigation-events$ã®ä¸€ç’°ã¨ã—ã¦ã€
ã“ã‚Œã¯ï¼Œã“ã®æ™‚ç‚¹ã§ã€
~promise~handlerç”¨ã®å°taskï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰ã‚’æŠ‘æ­¢ã™ã‚‹ã“ã¨ã‚’æ­¢ã‚ã¦ï¼Œ
ãã‚ŒãŒèµ°ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
â—
Per the previous note, this stops suppressing any potential promise handler microtasks, causing them to run at this point or later.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate_ev~event~handlerã®å¤±æ•—ã‚’å‡¦ç†ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I ~obj %~event, %äº‹ç”± )
ã«å¯¾ã—ï¼š
â—
To process navigate event handler failure given a NavigateEvent object event and a reason:
</p>
<ol>
	<li>
~IFï¼»
%~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$ã¯`å…¨éƒ¨çš„ã«ä½œå‹•ä¸­$ã§ãªã„
ï¼½
â‡’
~RET
â—
If event's relevant global object's associated Document is not fully active, then return.
</li>
	<li>
~IFï¼»
%~event ã®`ä¸­æ­¢-åˆ¶å¾¡å™¨$nEvã®`é€šé”$aCã¯`ä¸­æ­¢-æ¸ˆã¿$aBã§ã‚ã‚‹
ï¼½
â‡’
~RET
â—
If event's abort controller's signal is aborted, then return.
</li>
	<li>
~Assertï¼š
%~event ~EQ %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã®`~navi~API$ã®`é€²è¡Œä¸­ãª~navigate_ev~event$
â—
Assert: event is event's relevant global object's navigation API's ongoing navigate event.
</li>
	<li>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `intercepted^l
ï¼½
â‡’
`~navigate_ev~eventã‚’å®Œé‚ã™ã‚‹$( %~event, ~F )
â—
If event's interception state is not "intercepted", then finish event given false.
</li>
	<li>
`~navigate_ev~eventã‚’ä¸­æ­¢ã™ã‚‹$( %~event, %äº‹ç”± )
â—
Abort event given reason.
</li>
</ol>
</div>

					</section>
					<section id="navigate-event-scroll-focus">
<h6 title="Scroll and focus behavior">7.2.6.10.5. ~scrollã¨~focusã®æŒ™å‹•</h6>

<p>
`intercept()$mEã€ï¼navigateEvent.intercept()ã€‘ ã‚’~callã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€
~webé–‹ç™ºè€…ã¯ï¼Œ
åŒä¸€-æ–‡æ›¸ã¸ã®~naviç”¨ã«ã¯ï¼Œé€šå¸¸ã®ï¼»
~scrollç”¨ã®æŒ™å‹•ï¼~focusç”¨ã®æŒ™å‹•
ï¼½ã‚’æŠ‘æ­¢ã™ã‚‹ä»£ã‚ã‚Šã«ï¼Œå¾Œã®æ™‚ç‚¹ã«ã¦ï¼»
éåŒä¸€-æ–‡æ›¸ã¸ã®~naviã®æ§˜ãªæŒ™å‹•
ï¼½ã‚’å‘¼å‡ºã›ã‚‹ã€‚
ã“ã®ç¯€ã«ä¸ãˆã‚‹å„~algoã¯ã€
ãã®ã‚ˆã†ãªé©åˆ‡ãªå¾Œã®æ™‚ç‚¹ã«~callã•ã‚Œã‚‹ã€‚
â—
By calling navigateEvent.intercept(), web developers can suppress the normal scroll and focus behavior for same-document navigations, instead invoking cross-document navigation-like behavior at a later time. The algorithms in this section are called at those appropriate later points.
</p>

<div class="algo">
<p>
`~navigate_ev~eventã‚’å®Œé‚ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I %~event, çœŸå½å€¤ %å……è¶³-æ¸ˆã¿ã‹ )
ã«å¯¾ã—ï¼š
â—
To finish a NavigateEvent event, given a boolean didFulfill:
</p>
<ol>
	<li>
~Assertï¼š
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~NEQ `finished^l
â—
Assert: event's interception state is not "finished".
</li>
	<li>
<p>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~EQ `intercepted^l
ï¼½ï¼š
â—
If event's interception state is "intercepted", then:
</p>
		<ol>
			<li>
~Assertï¼š
%å……è¶³-æ¸ˆã¿ã‹ ~EQ ~F
â—
Assert: didFulfill is false.
</li>
			<li>
<p>
~Assertï¼š
%~event ã®`~navi~precommit~handler~list$nEvã¯`ç©º$ã§ã‚ã‚‹ã€‚
â—
Assert: event's navigation precommit handler list is not empty.
</p>

<p class="note">æ³¨è¨˜ï¼š
~naviã‚’~commitã•ã‚Œã‚‹å‰ã«å–æ¶ˆã›ã‚‹ã‚‚ã®ã¯ã€
~precommit~handlerã«é™ã‚‰ã‚Œã‚‹ã€‚
â—
Only precommit handlers can cancel a navigation before it is committed.
</p>
			</li>
			<li>
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~SET `finished^l
â—
Set event's interception state to "finished".
</li>
			<li>
~RET
â—
Return.
</li>
		</ol>
	</li>
	<li>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~EQ `none^l
ï¼½
â‡’
~RET
â—
If event's interception state is "none", then return.
</li>
	<li>
`å¿…è¦ãªã‚‰~focusã‚’è¨­å®šã—ç›´ã™$( %~event )
â—
Potentially reset the focus given event.
</li>
	<li>
~IFï¼»
%å……è¶³-æ¸ˆã¿ã‹ ~EQ ~T
ï¼½
â‡’
`å¿…è¦ãªã‚‰~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹$( %~event )
â—
If didFulfill is true, then potentially process scroll behavior given event.
</li>
	<li>
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~SET `finished^l
â—
Set event's interception state to "finished".
</li>
</ol>
</div>

<div class="algo">
<p>
`å¿…è¦ãªã‚‰~focusã‚’è¨­å®šã—ç›´ã™@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I %~event )
ã«å¯¾ã—ï¼š
â—
To potentially reset the focus given a NavigateEvent event:
</p>
<ol>
	<li>
~Assertï¼š
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~IN { `committed^l, `scrolled^l }
â—
Assert: event's interception state is "committed" or "scrolled".
</li>
	<li>
%~navi ~LET %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã®`~navi~API$
â—
Let navigation be event's relevant global object's navigation API.
</li>
	<li>
%~focusã¯å¤‰åŒ–ã—ãŸã‹ ~LET %~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã«~focusã¯å¤‰åŒ–ã—ãŸã‹$
â—
Let focusChanged be navigation's focus changed during ongoing navigation.
</li>
	<li>
%~navi ã®`é€²è¡Œä¸­ãª~naviã®é–“ã«~focusã¯å¤‰åŒ–ã—ãŸã‹$ ~SET ~F
â—
Set navigation's focus changed during ongoing navigation to false.
</li>
	<li>
~IFï¼»
%~focusã¯å¤‰åŒ–ã—ãŸã‹ ~EQ ~T
ï¼½
â‡’
~RET
â—
If focusChanged is true, then return.
</li>
	<li>
<p>
~IFï¼»
%~event ã®`~focusã‚’è¨­å®šã—ç›´ã™æŒ™å‹•$nEv ~EQ `manual$lF
ï¼½
â‡’
~RET
â—
If event's focus reset behavior is "manual", then return.
</p>

<p class="note">æ³¨è¨˜ï¼š
~NULL ã®ã¾ã¾ã«ã•ã‚ŒãŸå ´åˆã€
`after-transition$lF ã¨ã—ã¦æ‰±ã£ãŸä¸Šã§ä»¥é™ã‚’ç¶™ç¶šã™ã‚‹ã€‚
â—
If it was left as null, then we treat that as "after-transition", and continue onward.
</p>
	</li>
	<li>
%æ–‡æ›¸ ~LET %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be event's relevant global object's associated Document.
</li>
	<li>
%~focus~target ~LET `è‡ªå‹•focuså§”ä»»-å…ˆ$( %æ–‡æ›¸ )
â—
Let focusTarget be the autofocus delegate for document.
</li>
	<li>
~IFï¼»
%~focus~target ~EQ ~NULL
ï¼½
â‡’
%~focus~target ~SET %æ–‡æ›¸ ã®`~bodyè¦ç´ $
â—
If focusTarget is null, then set focusTarget to document's body element.
</li>
	<li>
~IFï¼»
%~focus~target ~EQ ~NULL
ï¼½
â‡’
%~focus~target ~SET %æ–‡æ›¸ ã®`æ–‡æ›¸~è¦ç´ $
â—
If focusTarget is null, then set focusTarget to document's document element.
</li>
	<li>
`~objã‚’~focusã™ã‚‹$( %~focus~target, %æ–‡æ›¸ ã®`è¡¨ç¤ºåŸŸ$ )
â—
Run the focusing steps for focusTarget, with document's viewport as the fallback target.
</li>
	<li>
`é€£åˆ—çš„~focus~naviã®å§‹ç‚¹$ ~SET %~focus~target
â—
Move the sequential focus navigation starting point to focusTarget.
</li>
</ol>
</div>

<div class="algo">
<p>
`å¿…è¦ãªã‚‰~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I %~event )
ã«å¯¾ã—ï¼š
â—
To potentially process scroll behavior given a NavigateEvent event:
</p>
<ol>
	<li>
~Assertï¼š
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~IN { `committed^l, `scrolled^l }
â—
Assert: event's interception state is "committed" or "scrolled".
</li>
	<li>
~IFï¼»
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~EQ `scrolled^l
ï¼½
â‡’
~RET
â—
If event's interception state is "scrolled", then return.
</li>
	<li>
<p>
~IFï¼»
%~event ã®`~scrollç”¨ã®æŒ™å‹•$nEv ~EQ `manual$lS
ï¼½
â‡’
~RET
â—
If event's scroll behavior is "manual", then return.
</p>

<p class="note">æ³¨è¨˜ï¼š
~NULL ã®ã¾ã¾ã«ã•ã‚ŒãŸå ´åˆã€
`after-transition$lS ã¨ã—ã¦æ‰±ã£ãŸä¸Šã§ä»¥é™ã‚’ç¶™ç¶šã™ã‚‹ã€‚
â—
If it was left as null, then we treat that as "after-transition", and continue onward.
</p>
	</li>
	<li>
`~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹$( %~event )
â—
Process scroll behavior given event.
</li>
</ol>
</div>

<div class="algo">
<p>
`~scrollç”¨ã®æŒ™å‹•ã‚’å‡¦ç†ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `NavigateEvent$I %~event )
ã«å¯¾ã—ï¼š
â—
To process scroll behavior given a NavigateEvent event:
</p>
<ol>
	<li>
~Assertï¼š
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~EQ `committed^l
â—
Assert: event's interception state is "committed".
</li>
	<li>
%~event ã®`æ¨ªå–~çŠ¶æ…‹$nEv ~SET `scrolled^l
â—
Set event's interception state to "scrolled".
</li>
	<li>
~IFï¼»
%~event ã® `navigationType$mE ~IN { `traverse$l, `reload$l }
ï¼½
â‡’
`~scrollä½ç½®~dataã‚’å¾©æ—§ã™ã‚‹$( %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`å¯¾å¿œã™ã‚‹~navigable$ã«ã¦`ä½œå‹•ä¸­ãª~entry$nav )
â—
If event's navigationType was initialized to "traverse" or "reload", then restore scroll position data given event's relevant global object's navigable's active session history entry.
</li>
	<li>
<p>
~ELSEï¼š
â—
Otherwise:
</p>
		<ol>
			<li>
%æ–‡æ›¸ ~LET %~event ã«`é–¢é€£ãªå¤§åŸŸ~obj$ã«`çµä»˜ã‘ã‚‰ã‚ŒãŸæ–‡æ›¸$
â—
Let document be event's relevant global object's associated Document.
</li>
			<li>
~IFï¼»
%æ–‡æ›¸ ã®`æŒ‡ç¤ºã•ã‚ŒãŸéƒ¨ä½$doc ~EQ ~NULL
ï¼½
â‡’
`æ–‡æ›¸ã®å…ˆé ­ã¸~scrollã™ã‚‹$( %æ–‡æ›¸ )
`CSSOMVIEW$r
â—
If document's indicated part is null, then scroll to the beginning of the document given document. [CSSOMVIEW]
</li>
			<li>
~ELSE
â‡’
`ç´ ç‰‡ã¸~scrollã™ã‚‹$( %æ–‡æ›¸ )
â—
Otherwise, scroll to the fragment given document.
</li>
		</ol>
	</li>
</ol>
</div>

					</section>
				</section>
			</section>
			<section id="nav-traversal-event-interfaces">
<h4 title="Event interfaces">7.2.7. ~event~interface</h4>

<p class="trans-note">ã€
ã“ã®ç¯€ã‚’æˆã™ä»–ã®ä¸‹ä½ç¯€ã®å†…å®¹ã¯ã€
`åˆ¥~pageã«ã¦ï¼ ~WINDOW#nav-traversal-event-interfaces$
ã€‘</p>

				<section id="the-navigationcurrententrychangeevent-interface">
<h5 title="The NavigationCurrentEntryChangeEvent interface">7.2.7.1. `NavigationCurrentEntryChangeEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `NavigationCurrentEntryChangeEvent@I : `Event$I {
  constructor(DOMString type, `NavigationCurrentEntryChangeEventInit$I eventInitDict);

  readonly attribute `NavigationType$I? `~navigationType0$m;
  readonly attribute `NavigationHistoryEntry$I `from$m;
};

dictionary `NavigationCurrentEntryChangeEventInit@I : `EventInit$I {
  `NavigationType$I? `~navigationType0@mb = null;
  required `NavigationHistoryEntry$I `from@mb;
};
</pre>

<dl class="domintro">
	<dt>%event.`~navigationType0$m</dt>
	<dd>
ç¾åœ¨ã®~entryãŒï¼»
~naviã«å› ã‚Šå¤‰åŒ–ã—ãŸãªã‚‰ã° ãã®ç¨®åˆ¥ï¼
`navigation.updateCurrentEntry()$c ã«å› ã‚Šå¤‰åŒ–ã—ãŸãªã‚‰ã° ~NULL
ï¼½ã‚’è¿”ã™ã€‚
â—
Returns the type of navigation which caused the current entry to change, or null if the change is due to navigation.updateCurrentEntry().
</dd>

	<dt>%event.`from$m</dt>
	<dd>
ç¾åœ¨ã®~entryãŒå¤‰åŒ–ã™ã‚‹å‰ã«ãŠã‘ã‚‹ `navigation.currentEntry$c ã®å€¤ã‚’è¿”ã™ã€‚
â—
Returns the previous value of navigation.currentEntry, before the current entry changed.
</dd>
	<dd>
ï¼»
`~navigationType0$m ~IN { ~NULL, `reload$l }
ï¼½ã®å ´åˆã€
ã“ã®å€¤ã¯ `navigation.currentEntry$c ã¨åŒã˜ã«ãªã‚‹ã€‚
ãã®äº‹ä¾‹ã§ã¯ã€
å½“ã®~eventã¯ï¼Œå½“ã®~entryã®å†…å®¹ãŒå¤‰åŒ–ã—ãŸã“ã¨ã‚’è¡¨ã™
â€” ï¼»
æ–°ãŸãª~entryã¸ç§»å‹•ã—ãŸï¼ç¾åœ¨ã®~entryã‚’ç½®æ›ã—ãŸ
ï¼½ã¨ãã§ãªãã¦ã‚‚ã€‚
â—
If navigationType is null or "reload", then this value will be the same as navigation.currentEntry. In that case, the event signifies that the contents of the entry changed, even if we did not move to a new entry or replace the current one.
</dd>
</dl>

<div>
<p>
`~navigationType0@m
å±æ€§ã¯ã€
åˆæœŸåŒ–-æ™‚ã®å€¤ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>

<p>
`from@m
å±æ€§ã¯ã€
åˆæœŸåŒ–-æ™‚ã®å€¤ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
</p>
â—
The navigationType and from attributes must return the values they were initialized to.
</div>

				</section>
				<section id="the-pageswapevent-interface">
<h5 title="The PageSwapEvent interface">7.2.7.4. `PageSwapEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageSwapEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageSwapEventInit$I %eventInitDict = {});
  readonly attribute `NavigationActivation$I? `activation$mPSe;
  readonly attribute `ViewTransition$I? `viewTransition$mPSe;
};

dictionary `PageSwapEventInit@I : `EventInit$I {
  `NavigationActivation$I? `activation@mb = null;
  `ViewTransition$I? `viewTransition@mb = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`activation$mPSe</dt>
	<dd>
éåŒä¸€-æ–‡æ›¸ãª~naviã®è¡Œå…ˆã¨ç¨®åˆ¥ã‚’è¡¨ç¾ã™ã‚‹ `NavigationActivation$I ~objã‚’è¿”ã™ã€‚
ãŸã ã—ã€
éåŒä¸€-ç”Ÿæˆå…ƒãª~naviç”¨ã«ã¯ ~NULL ã‚’è¿”ã™ã€‚
â—
A NavigationActivation object representing the destination and type of the cross-document navigation. This would be null for cross-origin navigations.
</dd>

	<dt>%event.`activation$mPSe.`entry$mNA</dt>
	<dd>
ä½œå‹•ä¸­ã«ãªã‚Šã¤ã¤ã‚ã‚‹`æ–‡æ›¸$ã‚’è¡¨ç¾ã™ã‚‹ `NavigationHistoryEntry$I ~objã‚’è¿”ã™ã€‚
â—
A NavigationHistoryEntry, representing the Document that is about to become active.
</dd>

	<dt>%event.`activation$mPSe.`from$mNA</dt>
	<dd>
å½“ã®~eventãŒç™ºç«ã•ã‚Œã‚‹æ™‚ç‚¹ã«ãŠã‘ã‚‹ `currentEntry$mN ~propã®å€¤ã¨ç­‰ä¾¡ãª `NavigationHistoryEntry$I ã‚’è¿”ã™ã€‚
â—
A NavigationHistoryEntry, equivalent to the value of the navigation.currentEntry property at the moment the event is fired.
</dd>

	<dt>%event.`activation$mPSe.`navigationType$mNA</dt>
	<dd>
`pageswap^et ã«ã‚ˆã‚‹çµæœã®~naviã®ç¨®åˆ¥ã‚’æŒ‡ç¤ºã™ã‚‹å€¤ã¨ã—ã¦ã€ï¼»
`push$l ï¼
`replace$l ï¼
`reload$l ï¼
`traverse$l
ï¼½ã‚’è¿”ã™ã€‚
â—
One of "push", "replace", "reload", or "traverse", indicating what type of navigation that is about to result in a page swap.
</dd>

	<dt>%event.`viewTransition$mPSe</dt>
	<dd>
å½“ã®~eventãŒç™ºç«ã•ã‚Œã‚‹æ™‚ç‚¹ã§ï¼Œå¤–ã¸å‡ºã‚‹â€ éåŒä¸€-æ–‡æ›¸ãª~viewé·ç§»ãŒä½œå‹•ä¸­ãªã‚‰ã°ã€
ãã‚Œã‚’è¡¨ç¾ã™ã‚‹ `ViewTransition$I ~objã‚’è¿”ã™ã€‚
ä»–ã®å ´åˆã¯ ~NULLã‚’è¿”ã™ã€‚
â—
Returns the ViewTransition object that represents an outbound cross-document view transition, if such transition is active when the event is fired. Otherwise, returns null.
</dd>
	<dd class="trans-note">ã€â€ 
â€œå¤–ã¸å‡ºã‚‹ ï¼ˆ `outbound^en ï¼‰â€ ã¨ã¯ã€
2 ã¤ã‚ã‚‹~viewé·ç§»
â€” æ—§-æ–‡æ›¸ã«ãŠã‘ã‚‹ãã‚Œ, æ–°-æ–‡æ›¸ã«ãŠã‘ã‚‹ãã‚Œ â€”
ã®ã†ã¡ï¼Œå‰è€…ã«å±ã™ã‚‹æ–¹ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€‘</dd>
</dl>

<p>
`activation@mPSe
ï¼
`viewTransition@mPSe
å±æ€§ã¯ã€
åˆæœŸåŒ–-æ™‚ã®å€¤ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The activation and viewTransition attributes must return the values they were initialized to.
</p>

				</section>
				<section id="the-pagerevealevent-interface">
<h5 title="The PageRevealEvent interface">7.2.7.5. `PageRevealEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageRevealEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageRevealEventInit$I %eventInitDict = {});
  readonly attribute `ViewTransition$I? `viewTransition$mPRe;
};

dictionary `PageRevealEventInit@I : `EventInit$I {
  `ViewTransition$I? `viewTransitionï¼ #dom-pagerevealeventinit-viewtransition@mb = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`viewTransition$mPRe</dt>
	<dd>
å½“ã®~eventãŒç™ºç«ã•ã‚ŒãŸæ™‚ç‚¹ã§å†…ã¸æ¥ã‚‹â€ éåŒä¸€-æ–‡æ›¸ãª~viewé·ç§»ãŒä½œå‹•ä¸­ã§ã‚ã‚‹ãªã‚‰ã°ï¼Œ
ãã‚Œã‚’è¡¨ç¾ã™ã‚‹ `ViewTransition$I ~objã‚’è¿”ã™
â€” ä»–ã®å ´åˆã€
~NULL ã‚’è¿”ã™ã€‚
â—
Returns the ViewTransition object that represents an inbound cross-document view transition, if such transition is active when the event is fired. Otherwise, returns null.
</dd>
	<dd class="trans-note">ã€â€ 
â€œå†…ã¸æ¥ã‚‹ ï¼ˆ `inbound^en ï¼‰â€ ã¨ã¯ã€
2 ã¤ã‚ã‚‹~viewé·ç§»
â€” æ—§-æ–‡æ›¸ã«ãŠã‘ã‚‹ãã‚Œ, æ–°-æ–‡æ›¸ã«ãŠã‘ã‚‹ãã‚Œ â€”
ã®ã†ã¡ï¼Œå¾Œè€…ã«å±ã™ã‚‹æ–¹ã‚’æ„å‘³ã™ã‚‹ã€‚
ã€‘</dd>
</dl>

<p>
`viewTransition@mPRe
å–å¾—å­ã¯ã€
åˆæœŸåŒ–-æ™‚ã®å€¤ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
The viewTransition attribute must return the value it was initialized to.
</p>

				</section>
				<section id="the-pagetransitionevent-interface">
<h5 title="The PageTransitionEvent interface">7.2.7.6. `PageTransitionEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageTransitionEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageTransitionEventInit$I %eventInitDict = {});

  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event.`persisted$m</dt>
	<dd>
`pageshow$et ~eventã«å¯¾ã—ã¦ã¯ã€ï¼»
å½“ã®~pageãŒæ–°ãŸã«èª­è¾¼ã¾ã‚Œã¤ã¤ã‚ã‚‹ï¼ˆã—ãŸãŒã£ã¦ `load$et ~eventãŒç™ºç«ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ï¼‰ãªã‚‰ã° ~F ï¼
~ELSE_ ~T
ï¼½ã‚’è¿”ã™ã€‚
â—
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventã«å¯¾ã—ã¦ã¯ã€ï¼»
å½“ã®~pageãŒæœ€å¾Œã«æ¶ˆãˆå»ã‚‹ã¨ãã«ã¯ ~F ï¼
~ELSE_ ~T
ï¼½ã‚’è¿”ã™ã€‚
~T ã¯ã€
ã“ã®~pageã¯ï¼Œåˆ©ç”¨è€…ãŒã“ã®~pageã«~navigateã—ã¦æˆ»ã£ãŸå ´åˆã«
ï¼ˆã‹ã¤ï¼Œå½“ã®`æ–‡æ›¸$ã®`å›å¾©å¯èƒ½~çŠ¶æ…‹$docãŒ ~T ã®ã¾ã¾ã§ã‚ã‚Œã°ï¼‰
å†åˆ©ç”¨ã•ã‚Œå¾—ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
â—
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that the page might be reused if the user navigates back to this page (if the Document's salvageable state stays true).
</dd>
	<dd>
<p>
~pageã‚’å›å¾©å¯èƒ½ã§ãªãã™ã‚‹ã‚‚ã®ã«ã¯ã€
æ¬¡ãŒå«ã¾ã‚Œã‚‹ï¼š
â—
Things that can cause the page to be unsalvageable include:
</p>
		<ul>
			<li>
~UAã¯ã€
å½“ã®`æ–‡æ›¸ã‚’~unloadï¼ ~HTMLlifecycle#unload-a-document$ã—ãŸå¾Œã«ï¼Œï¼»
ãã®æ–‡æ›¸ã¯ï¼Œ`~sessionå±¥æ­´~entry$å†…ã§ç”Ÿå­˜ã—ç¶šã‘ãªã„
ï¼½ã‚‚ã®ã¨è£å®šã—ãŸ
â—
The user agent decided to not keep the Document alive in a session history entry after unload
</li>
			<li>
`å›å¾©å¯èƒ½ï¼ ~HTMLlifecycle#concept-document-salvageable$ã§ãªã„ `iframe$e ãŒã‚ã‚‹ã¨ã
â—
Having iframes that are not salvageable
</li>
			<li>
ä½œå‹•ä¸­ãª `WebSocket$I ~objãŒã‚ã‚‹ã¨ã
â—
Active WebSocket objects
</li>
			<li>
`æ–‡æ›¸ã‚’ä¸­æ­¢ã—ãŸï¼ ~HTMLlifecycle#abort-a-document$ã¨ã
â—
Aborting a Document
</li>
		</ul>
	</dd>
</dl>

<dl class="idl-def">
	<dt>
`persisted@m
â—
The persisted attributeï¼¼
</dt>
	<dd>
å–å¾—å­ã¯ã€
åˆæœŸåŒ–-æ™‚ã®å€¤ã‚’è¿”ã™ãƒ¢ãƒãƒˆã‚¹ãƒ«ã€‚
â—
must return the value it was initialized to.ï¼¼
</dd>
	<dd>
ã“ã‚Œã¯~eventã®æ–‡è„ˆ~æƒ…å ±ã‚’è¡¨ç¾ã™ã‚‹ã€‚
â—
It represents the context information for the event.
</dd>
</dl>

<div class="algo">
<p>
`~pageé·ç§»~eventã‚’ç™ºç«ã™ã‚‹@
~algoã¯ã€
æ‰€ä¸ã®
( `Window$I %~window, %~eventå, çœŸå½å€¤ %æŒç¶šã•ã‚Œã‚‹ã‹ )
ã«å¯¾ã—
â‡’
`~eventã‚’ç™ºç«ã™ã‚‹$( %~window, %~eventå, `PageTransitionEvent$I )
â€” `~targetã‚’ä¸Šæ›¸ãã™ã‚‹^i ä¸‹ã§ï¼ŒãŠã‚ˆã³æ¬¡ã®ã‚ˆã†ã«åˆæœŸåŒ–ã—ã¦
â‡’ï¼ƒ
`persisted$m å±æ€§ ~SET %æŒç¶šã•ã‚Œã‚‹ã‹,
`cancelable$m å±æ€§ ~SET ~T,
`bubbles$m å±æ€§ ~SET ~T
â—
To fire a page transition event named eventName at a Window window with a boolean persisted, fire an event named eventName at window, using PageTransitionEvent, with the persisted attribute initialized to persisted, the cancelable attribute initialized to true, the bubbles attribute initialized to true, and legacy target override flag set.
</p>

<p class="note">æ³¨è¨˜ï¼š
`cancelable$m, `bubbles$m ç”¨ã®å€¤ã¯ã€
ã‚¤ãƒŸã‚’æˆã•ãªã„
â€” å½“ã®~eventã‚’å–æ¶ˆã—ã¦ã‚‚ä½•ã‚‚ã—ãªã„ã—ï¼Œ
`Window$I ~objã‚’éãã¦æµ®ä¸Šã™ã‚‹ã“ã¨ã¯ã‚¢ãƒªã§ãªã„ã®ã§ã€‚
ã“ã‚Œã‚‰ãŒ ~T ã«è¨­å®šã•ã‚Œã‚‹ã®ã¯ã€
æ­´å²çš„ãªç†ç”±ã«ã‚ˆã‚‹ã€‚
â—
The values for cancelable and bubbles don't make any sense, since canceling the event does nothing and it's not possible to bubble past the Window object. They are set to true for historical reasons.
</p>
</div>

				</section>
			</section>
</main>
