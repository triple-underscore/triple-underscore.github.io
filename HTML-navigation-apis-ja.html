<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — The navigation API （ 日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
@supports (grid-template-columns: subgrid) and (display: contents) {

._nav-tracking {
	grid-template-columns: 4em 1fr;
	min-width:30em;
}

._nav-tracking tr {
	grid-template-areas:
		"状態 状態"
		". 期間"
		". 説明"
	;
}

._nav-tracking tr > *:nth-child(1) {
	grid-area: 状態;
	border-left-width: 0;
}

._nav-tracking tr > *:nth-child(2) {
	grid-area: 期間;
}

._nav-tracking tr > *:nth-child(3) {
	grid-area: 説明;
}
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'lS':
case 'lF':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'm':
case 'mD':
case 'mE':
case 'mN':
case 'mH':
case 'mT':
case 'mNA':
case 'mPSe':
case 'mPRe':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2024-08-29
trans_update:2024-08-07
source_checked:240620
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/nav-history-apis.html
	abbr_url:HTMLnavAPI
nav_prev:WINDOW
nav_next:HTMLds
site_nav:browsers,html
trans_1st_pub:2023-07-09


●●class_map
E:error
sl:js-slot
e:element
a:attr
et:event-type
sc:scheme
E:error
sl:js-slot
U:code-point
v:value
h:header
jA:abstract
jv:js-value
sl:js-slot
hst:status

●●tag_map
I:code
E:code
m:code
mD:code
mE:code
mN:code
mH:code
mT:code
mb:code
mbC:code
mbN:code
mbR:code
mNA:code
mPSe:code
mPRe:code
c:code
e:code
a:code
et:code
v:code
h:code
jv:code
sl:span
jA:span
hst:code
sub:sub
i:i
em:em


●●original_urls

pagetransitionevent:API/PageTransitionEvent

●●words_table1
CONSOLE:console-ja.html

about_blank:about:blank
navigate_ev: <code class="event-type">navigate</code> 
beforeunload_ev: <code class="event-type">beforeunload</code> 
navigationType0:navigationType

●●words_table

	●名称
UUID:

	●navi/session
POST:
step:
unload:
from:
commit:
	~commit先:committed-to
committed:
	完遂-時の:finished
	~commit時の:committed
差分:delta:~
横取:interception::横取り
横取-:intercept::横取り
	横取されない:non-intercepted
処分-:dispose::~
BF:
	~BF~cache:bfcache
追跡子:tracker::~::トラッカー
直列形の:serialized::~::シリアル形の
復旧-:restore::~
復旧:restoration::~
読込直す:reloadする::読み込み直す::リロードする
再読込み:reload::再読み込み::リロード
書直せ:rewriteでき::書き直せ
	〜を書直せる:can have its 〜 rewritten
連続的:contiguous:~
最近の:latest:~
回復可能:salvage 可能:~

	起動元は許容されない^i:"initiator-disallowed"
	~beforeunload_evにより取消された^i:"canceled-by-beforeunload"
	~navigate_evにより取消された^i:"canceled-by-navigate"
	外へ行く:outgoing
	訪問し直して:revisit
	戻るよう~navigateする:navigating back
	連れて行った:took us
	素片へ~scrollする:scroll-to-a-fragment
	~navi履歴~entry~list:navigation history list
	~navi履歴~entry~list:navigation history entry list
	非同一-〜へ行く:crossing
	前方に在る:forward
	後方に在る:previous

	●UI
支援技術:assistive technology:~
隠して:hideして:~
逐次的:sequential::~
始点:starting point:~
自動focus:autofocus::自動 focus:自動フォーカス
保存-:save:~
affordance:

	右~click:right click
	押した:press
	示され:shown
	示す:show
	読込n中を表す~UI:loading spinner UI
	代わりの何か:placeholder
	~pageは読込n中であることを表すもの:spinner or loading page
	読込n中を表す何か:loading spinner

	●処理一般
片付ける:clean upする:~
params::::パラメタ群
小task:microtask::小 task:小タスク
checkpoint:
wrapper:
捕捉-:capture::~
生残る:surviveする:生き残る
生存-:alive:~
	生存し続ける:keeping it alive
早期:early:~
処理待ち:pending:~
決着-:settle::~
逆直列化-:deserialize::~::逆シリアル化
逆直列化:deserialization::~::逆シリアル化
process::::プロセス
schedule::::スケジュール
取扱済み:handled:取り扱い済み
警告:warning::~
成否:success or failure:~
来たる:upcoming:~
差挟んで:interleaveされ:差し挟んで
遂げる:carry outする:~
	それに見合う〜:see fit to carry out
遂げて:carry outして:~
遂げら:carry outさ:~
来たる:upcoming:~
処する:dealする:~
処した:dealした:~
給され:supplyされ:~
差挟まれ:interleaveされ:差し挟まれ
時機:timing::~
追跡期間:duration:~
	いる間:duration
新規:fresh:~
先行-:preceed:~
渡す:passする:~
渡され:passされ:~
渡した:passした:~
渡して:passして:~

	段階:stage
	順に走る:the sequence
	し続ける:keep
	走る順序:sequence
	同時期:around the same time
	時点:moment
	間:during
	後の時点:later
	後の時点:later time
	後の時点:later points
	この時点で:at this point
	この時点で〜ようにする:this point or later
	すぐに~soon
	経ない no 〜 goes through
	と同時に:at the same time
	この道がとられる:This path is taken
	〜されなかったことになる:was never fired
	直後:right after
	~~達する:ever getting to
	抜け出た:bailed out
	〜にする:promote
	存続する限り:lifetime
	比して古くなっていた:was outdated compared to
	短い期間内:for brief periods
	優先される場合:in favor of
	以降を:onward
	止める:stop
	かなり:pretty
	（もしあれば）:potential
	その後すぐに:shortly after
	任せる:let
	まず最初に:in the first place
	その結果，:which in turn
	から開始した:starting point
	居続ける:around
	~fall-back:falling off the back of
	~networkまたは~cacheから読込直す:performing a from-network-or-cache reload
	~EQ:was initialized to
	オフ:turn off
	~clear:clear out
	〜のままに:left as
	設定された（または省略された）:left as
	巡った:trip through
	場を占める:taking place
	結果〜なる:end up
	-:rethrowing any exceptions

	●変数
新-:new:~
旧-:old:~
SHE:
NHE:

	%e:e
	%~API~method追跡子:apiMethodTracker
	%~NHE:nhe
	%~URL~record:urlRecord
	%~commit時の~promise:committedPromise
	%~download要請~filename:downloadRequestFilename
	%~error:error
	%~error報:errorInfo
	%~event:event
	%~filename:filename
	%完遂-時の~promise:finishedPromise
	%~focus~target:focusTarget
	%~focusは変化したか:focusChanged
	%~form~data~entry~list:formDataEntryList
	%~from~NHE:fromNHE
	%~index:i
	%~index:index
	%~key:key
	%~navi:navigation
	%~navigable:navigable
	%~navigableの履歴~entry群:navigableSHEs
	%~navi~API状態:navigationAPIState
	%~navi種別:navigationType
	%~navi種別:navigationType
	%~option群:options
	%~promise~list:promisesList
	%~source~snapshot~params:sourceSnapshotParams
	%~target履歴~entry:targetSHE
	%作動化し直される履歴~entry:reactivatedSHE
	%例外:exception
	%充足-済みか:didFulfill
	%処分される~NHE:disposedNHE
	%処分される~NHE群:disposedNHEs
	%初期~履歴~entry:initialSHE
	%利用者-関与i:userInvolvement
	%却下~事由:rejectionReason
	%古典~履歴~API用の状態:classicHistoryAPIState
	%同一-文書か:isSameDocument
	%報:info
	%履歴~entry:she
	%履歴~entry:she
	%新-~NHE:newNHE
	%新-~NHE群:newNHEs
	%新-履歴~entry:newSHE
	%新-履歴~entry群:newSHEs
	%旧-~NHE:matchingOldNHE
	%旧-~NHE群:oldNHEs
	%旧-現在の~NHE:oldCurrentNHE
	%状態:state
	%現在の~URL:currentURL
	%現在の~entry:current
	%直列形の状態:serializedState
	%終了~結果は同一-文書か:endResultIsSameDocument
	%結果:result
	%行先:destination
	%行先~NHE:destinationNHE
	%行先~URL:destinationURL
	%行先~key:destinationKey
	%行先~履歴~entry:destinationSHE
	%辿-は取消せるか:traverseCanBeCanceled
	%辿り~API~method追跡子~群:traversalAPIMethodTrackers
	%辿可能:traversable
	%配送-結果:dispatchResult
	%~event名:eventName
	%持続されるか:persisted


	●仕様
元々は:originalには:~
古典的:classic::~::クラシック
注力-:focus:~
異種:disparate:~
創発的:emergent:~
微妙:subtle:~
後継:successor:~
理論:theory:~
	理論~上は:in theory
注力-:focus:~
	〜に注力した:-focused

	主要:major:~
	必要なら:potentially
	必要なら:maybe
	同類の~API:friends
	注記-:note
	一般的には:Generally speaking
	いくつもある:so many
	に注意:Notably,
	結局:after all
	主な:main
	このこと:this overlap
	単に捨て置くわけにはいかない:can't just get rid of
	利用が最も適する:is best used
	まだ指定されてない:underspecified
	種別を問わず:in the broad sense of the word
	唯一の:singular
	複雑になること:complication
	~~諸々:stuff
	一環として:per
	知る:know
	それに加え:plus
	Recall that:-
	要として:key
	選ぶ:chooseする
	~~影響:matter:~
	任意選択で:then the user agent may
	なり得ない:would not be viable
	それでも:however 〜 still

	●未分類
body:
agent:
序数:ordinal:~
帰属-:attribute
	どこに帰属するか:about attributing
付随-:accompany:~
	付随-:acccompany
非-:non-:~
近過去:recent:~
常時:regularに:~
一定:constant:~
維持-:retain:~
	`pageswap^et:page swap

	含む:include
	記事:article
	一連の:a series of
	満たされる:hold
	~NULL 化:nulled out
	空でない:nonempty
	利用者が:user-
	したことによる:caused by
	により起動された:caused by
	複数回:more than once
	〜後の:post-
	（もしあれば）:any
	対応-:correspond
	全体を通して:throughout
	途中で:along the way
	無いときと 1 個以上あるとき:0 promises versus ≥ 1 promises
	互いの:each others'
	他へ:along
	〜駆動な:-driven
	大抵は:Much of the time
	どの~entryから来ているか:from which 〜 is coming
	十分:enough
	で占める場所:place
	またがって:across
	他では:otherwise-
	巨大:large
	各部:parts
	ここまでに／前回の／以前の／上の
	直前の:the previous
	直前:right before
	後者の:previous
	現在の文書:this one
	最も近い:closest
	変える:vary
	Finally:-
	来:come
	時点:at the moment
	あり続ける:stay
	外へ出る:outbound

●●original_id_map

dom-window-navigation:dom-navigation

●●mdn_urls
navigation:API/Navigation
navigateevent:API/NavigateEvent
navigationdestination:API/NavigationDestination
navigationhistoryentry:API/NavigationHistoryEntry
navigationtransition:API/NavigationTransition

●●link_map

	●IDL
E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror

Promise:~WEBIDL#idl-promise

I.ErrorEvent:~WAPI#errorevent
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.FormData:~XHR#formdata

I.Navigation:#navigation
I.NavigateEvent:#navigateevent
I.NavigateEventInit:#navigateeventinit
I.NavigationActivation:#navigationactivation
I.NavigationCurrentEntryChangeEvent:~WINDOW#navigationcurrententrychangeevent
I.NavigationDestination:#navigationdestination
I.NavigationFocusReset:#navigationfocusreset
I.NavigationHistoryBehavior:#navigationhistorybehavior
I.NavigationHistoryEntry:#navigationhistoryentry
I.NavigationInterceptHandler:#navigationintercepthandler
I.NavigationInterceptOptions:#navigationinterceptoptions
I.NavigationNavigateOptions:#navigationnavigateoptions
I.NavigationOptions:#navigationoptions
I.NavigationReloadOptions:#navigationreloadoptions
I.NavigationResult:#navigationresult
I.NavigationScrollBehavior:#navigationscrollbehavior
I.NavigationTransition:#navigationtransition
I.NavigationType:#navigationtype
I.NavigationUpdateCurrentEntryOptions:#navigationupdatecurrententryoptions
I.PageSwapEvent:#pageswapevent
I.PageSwapEventInit:#pageswapeventinit
I.PageRevealEvent:#pagerevealevent
I.PageRevealEventInit:#pagerevealeventinit
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.ViewTransition:~CSSVT#viewtransition
I.WebSocket:~WEBSOCKET#websocket

I.AbortController:~DOM4#abortcontroller
I.AbortSignal:~DOM4#abortsignal
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.DOMException:~WEBIDL#dfn-DOMException
	I.Document:~HTMLdom#document → 文書
文書:~HTMLdom#the-document-object

I.Window:~WINDOW#window

mbC.state:#dom-navigationupdatecurrententryoptions-state

mbN.info:#dom-navigationoptions-info
mbN.state:#dom-navigationnavigateoptions-state
mbN.history:#dom-navigationnavigateoptions-history

mbR.state:#dom-navigationreloadoptions-state

mb.committed:#dom-navigationresult-committed
mb.finished:#dom-navigationresult-finished

m.persisted:#dom-pagetransitionevent-persisted

c.window.navigation:#dom-window-navigation
m.navigation:#dom-window-navigation
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.fetch:~FETCH#dom-global-fetch
m.from:~WINDOW#dom-navigationcurrententrychangeevent-from
m.isTrusted:~DOM4#dom-event-istrusted
m.preventDefault:~DOM4#dom-event-preventdefault
m.type:~DOM4#dom-event-type
m.~navigationType0:~WINDOW#dom-navigationcurrententrychangeevent-navigationtype

mH.url:#dom-navigationhistoryentry-url
mH.key:#dom-navigationhistoryentry-key
mH.id:#dom-navigationhistoryentry-id
mH.index:#dom-navigationhistoryentry-index
mH.sameDocument:#dom-navigationhistoryentry-samedocument
mH.getState:#dom-navigationhistoryentry-getstate
c.navigation.currentEntry.getState():#dom-navigationhistoryentry-getstate
mH.ondispose:#handler-navigationhistoryentry-ondispose

mN.onnavigate:#handler-navigation-onnavigate
mN.onnavigatesuccess:#handler-navigation-onnavigatesuccess
mN.onnavigateerror:#handler-navigation-onnavigateerror
mN.oncurrententrychange:#handler-navigation-oncurrententrychange
mN.entries:#dom-navigation-entries
c.navigation.entries():#dom-navigation-entries
c.navigation.currentEntry:#dom-navigation-currententry
mN.currentEntry:#dom-navigation-currententry
mN.updateCurrentEntry:#dom-navigation-updatecurrententry
c.navigation.updateCurrentEntry():#dom-navigation-updatecurrententry
c.navigation.canGoBack:#dom-navigation-cangoback
mN.canGoBack:#dom-navigation-cangoback
mN.canGoForward:#dom-navigation-cangoforward
c.navigation.navigate():#dom-navigation-navigate
mN.navigate:#dom-navigation-navigate
mN.reload:#dom-navigation-reload
c.navigation.reload():#dom-navigation-reload
mN.traverseTo:#dom-navigation-traverseto
c.navigation.traverseTo():#dom-navigation-traverseto
mN.back:#dom-navigation-back
mN.forward:#dom-navigation-forward
mN.transition:#dom-navigation-transition
c.navigation.transition:#dom-navigation-transition
mN.activation:#dom-navigation-activation

mNA.from:#dom-navigationactivation-from
mNA.entry:#dom-navigationactivation-entry
mNA.navigationType:#dom-navigationactivation-navigationtype

l.push:#dom-navigationtype-push
l.replace:#dom-navigationtype-replace
l.reload:#dom-navigationtype-reload
l.traverse:#dom-navigationtype-traverse

mT.navigationType:#dom-navigationtransition-navigationtype
mT.from:#dom-navigationtransition-from
mT.finished:#dom-navigationtransition-finished
c.navigation.transition.finished:#dom-navigationtransition-finished

mb.navigationType:#dom-navigateeventinit-navigationtype
mb.destination:#dom-navigateeventinit-destination
mb.canIntercept:#dom-navigateeventinit-canintercept
mb.userInitiated:#dom-navigateeventinit-userinitiated
mb.hashChange:#dom-navigateeventinit-hashchange
mb.signal:#dom-navigateeventinit-signal
mb.formData:#dom-navigateeventinit-formdata
mb.downloadRequest:#dom-navigateeventinit-downloadrequest
mb.info:#dom-navigateeventinit-info
mb.hasUAVisualTransition:#dom-navigateeventinit-hasuavisualtransition

mb.handler:#dom-navigationinterceptoptions-handler
mb.focusReset:#dom-navigationinterceptoptions-focusreset
mb.scroll:#dom-navigationinterceptoptions-scroll

lF.after-transition:#dom-navigationfocusreset-after-transition
lF.manual:#dom-navigationfocusreset-manual

lS.after-transition:#dom-navigationscrollbehavior-after-transition
lS.manual:#dom-navigationscrollbehavior-manual

mE.navigationType:#dom-navigateevent-navigationtype
mE.destination:#dom-navigateevent-destination
mE.canIntercept:#dom-navigateevent-canintercept
mE.userInitiated:#dom-navigateevent-userinitiated
mE.hashChange:#dom-navigateevent-hashchange
mE.signal:#dom-navigateevent-signal
mE.formData:#dom-navigateevent-formdata
mE.downloadRequest:#dom-navigateevent-downloadrequest
mE.info:#dom-navigateevent-info
mE.hasUAVisualTransition:#dom-navigateevent-hasuavisualtransition
mE.intercept:#dom-navigateevent-intercept
mE.scroll:#dom-navigateevent-scroll

mD.url:#dom-navigationdestination-url
mD.key:#dom-navigationdestination-key
mD.id:#dom-navigationdestination-id
mD.index:#dom-navigationdestination-index
mD.sameDocument:#dom-navigationdestination-samedocument
mD.getState:#dom-navigationdestination-getstate

mPSe.activation:#dom-pageswapevent-activation
mPSe.viewTransition:#dom-pageswapevent-viewtransition
mb.activation:#dom-pageswapeventinit-activation
mb.viewTransition:#dom-pageswapeventinit-viewtransition

mPRe.viewTransition:#dom-pagerevealevent-viewtransition
	mb.viewTransition:＠#dom-pagerevealeventinit-viewtransition


nV.~entry~list:#navigation-entry-list
~navi履歴~entry~list:#navigation-entry-list
nV.現在の~entry~index:#navigation-current-entry-index
~naviの現在の~entry:#navigation-current-entry

h.Content-Disposition:https://httpwg.org/specs/rfc6266.html

hH.auto:~HTMLnav#navigationhistorybehavior-auto
hH.push:~HTMLnav#navigationhistorybehavior-push
hH.replace:~HTMLnav#navigationhistorybehavior-replace

et.currententrychange:~HTMLindex#event-currententrychange
et.dispose:~HTMLindex#event-dispose
et.load:~HTMLindex#event-load
et.navigate:~HTMLindex#event-navigate
et.navigateerror:~HTMLindex#event-navigateerror
et.navigatesuccess:~HTMLindex#event-navigatesuccess
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.unhandledrejection:~HTMLindex#event-unhandledrejection

e.a:~HEtextlevel#the-a-element
e.area:~HEimages#the-area-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element

a.autofocus:~HTMLinteraction#attr-fe-autofocus
a.download:~HTMLlinks#attr-hyperlink-download


	●用語
~entryや~eventは不能化されたか:#has-entries-and-events-disabled
~navi~API~entry~indexを取得する:#getting-the-navigation-api-entry-index
~navi~API:#window-navigation-api

nhe.~session履歴~entry:#nhe-she
~navi履歴~entry:#nhe-she
nE.~key:#concept-navigationhistoryentry-key
nE.~ID:#concept-navigationhistoryentry-id
nE.~index:#concept-navigationhistoryentry-index

~navi~API用の辿りを遂行する:#performing-a-navigation-api-traversal
早期~error結果:#navigation-api-early-error-result
~navi~API~method追跡子:#navigation-api-method-tracker
~navi~API~method追跡子から導出される結果:#navigation-api-method-tracker-derived-result
進行中な~navigate_ev~event:#ongoing-navigate-event
進行中な~API~method追跡子:#ongoing-api-method-tracker
来たる非-辿-~API~method追跡子:#upcoming-non-traverse-api-method-tracker
来たる辿-~API~method追跡子~群:#upcoming-traverse-api-method-trackers

amT.~navi~obj:#navigation-api-method-tracker-navigation
amT.~key:#navigation-api-method-tracker-key
amT.報:#navigation-api-method-tracker-info
amT.直列形の状態:#navigation-api-method-tracker-state
amT.~commit先~entry:#navigation-api-method-tracker-committed-to-entry
amT.~commit時の~promise:#navigation-api-method-tracker-committed
amT.完遂-時の~promise:#navigation-api-method-tracker-finished

来たる非-辿-~API~method追跡子を必要なら設定する:#maybe-set-the-upcoming-non-traverse-api-method-tracker
来たる辿-~API~method追跡子を追加する:#add-an-upcoming-traverse-api-method-tracker
来たる~API~method追跡子を進行中にする:#promote-an-upcoming-api-method-tracker-to-ongoing

追跡子を片付ける:#navigation-api-method-tracker-clean-up
~commit先~entryについて通知する:#notify-about-the-committed-to-entry
完遂-時の~promiseを解決する:#resolve-the-finished-promise
完遂-時の~promiseを却下する:#reject-the-finished-promise
進行中な~naviの間に~focusは変化したか:#focus-changed-during-ongoing-navigation
進行中な~naviを中止する:#abort-the-ongoing-navigation
進行中な~naviの間は通常の~scroll復旧を抑止するか:#suppress-normal-scroll-restoration-during-ongoing-navigation

新たな文書~用に~navi~API~entry群を初期化する:#initialize-the-navigation-api-entries-for-a-new-document
~entryや~eventは不能化されて:#has-entries-and-events-disabled
辿-用の~navigate_ev~eventを発火する:#fire-a-traverse-navigate-event
	arg:#fire-navigate-traverse-destinationshe
	arg:#fire-navigate-traverse-userinvolvement
~push／置換-／再読込み用の~navigate_ev~eventを発火する:#fire-a-push/replace/reload-navigate-event
	arg:#fire-navigate-prr-navigationtype
	arg:#fire-navigate-prr-issamedocument
	arg:#fire-navigate-prr-destinationurl
	arg:#fire-navigate-prr-classichistoryapistate
	arg:#fire-navigate-prr-userinvolvement
	arg:#fire-navigate-prr-navigationapistate
	arg:#fire-navigate-prr-formdataentrylist
~download要請~用の~navigate_ev~eventを発火する:#fire-a-download-request-navigate-event
	arg:#fire-navigate-download-destinationurl
	arg:#fire-navigate-download-userinvolvement
	arg:#fire-navigate-download-filename
~navigate_ev~eventを発火する内縁~algo:#inner-navigate-event-firing-algorithm
~navigate_ev~eventを完遂する:#navigateevent-finish

子~navigableの破壊について~navi~APIに伝える:#inform-the-navigation-api-about-child-navigable-destruction
~naviを中止したことについて~navi~APIに伝える:#inform-the-navigation-api-about-aborting-navigation
再~作動化~用に~navi~API~entry群を更新する:#update-the-navigation-api-entries-for-reactivation
同一-文書~navi用に~navi~API~entry群を更新する:#update-the-navigation-api-entries-for-a-same-document-navigation

遷移:#concept-navigation-transition
nTr.~navi種別:#concept-navigationtransition-navigationtype
nTr.~from~entry:#concept-navigationtransition-from
nTr.完遂-時の~promise:#concept-navigationtransition-finished

作動化:#navigation-activation
nA.旧-~entry:#nav-activation-old-entry
nA.新-~entry:#nav-activation-new-entry
nA.~navi種別:#nav-activation-navigation-type

nEv.横取~状態:#concept-navigateevent-interception-state
nEv.~navi~handler~list:#concept-navigateevent-navigation-handler-list
nEv.~focusを設定し直す挙動:#concept-navigateevent-focusreset
nEv.~scroll用の挙動:#concept-navigateevent-scroll
nEv.中止-制御器:#concept-navigateevent-abort-controller
nEv.古典~履歴~API用の状態:#concept-navigateevent-classic-history-api-state

~navi~handler~promise:#_navigation-handler-promise

共用~検査を遂行する:#navigateevent-perform-shared-checks

nDt.~URL:#concept-navigationdestination-url
nDt.~entry:#concept-navigationdestination-entry
nDt.状態:#concept-navigationdestination-state
nDt.同一-文書か:#concept-navigationdestination-samedocument

必要なら~focusを設定し直す:#potentially-reset-the-focus
必要なら~scroll用の挙動を処理する:#potentially-process-scroll-behavior
~scroll用の挙動を処理する:#process-scroll-behavior

~page遷移~eventを発火する:#fire-a-page-transition-event

	●用語（HTML

~BF~cache:~HTMLnav#_bf-cache
	~HTMLnav#note-bfcache
最近の~entry:~HTMLnav#latest-entry

~body要素:~HTMLdom#the-body-element-2

~entry~list:~HTMLforms#entry-list
	＠:~HTMLforms#concept-form-submit

直列化-可能:~HTMLcloning#serializable-objects
~URLを相対的に構文解析する:~HTMLurl#parse-a-url

~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
履歴~動作による作動化を有して:~HTMLinteraction#history-action-activation
履歴~動作による作動化を消費する:~HTMLinteraction#consume-history-action-user-activation
自動focus委任-先:~HTMLinteraction#autofocus-delegate


不透明な生成元:~ORIGIN#concept-origin-opaque
同じ生成元~domain:~ORIGIN#same-origin-domain
同一-生成元:~ORIGIN#same-origin
sub.生成元:~ORIGIN#same-origin
生成元:~ORIGIN#concept-origin

対応する~navigable:~WINDOW#window-navigable
文書の~URLは書直せるか:~WINDOW#can-have-its-url-rewritten
結付けられた文書:~WINDOW#concept-document-window

nav.~session履歴~辿り~queue:~HTMLds#tn-session-history-traversal-queue
nav.作動中な~entry:~HTMLds#nav-active-history-entry
nav.作動中な~window:~HTMLds#nav-window
nav.現在の~session履歴~entry:~HTMLds#nav-current-history-entry
nav.親:~HTMLds#nav-parent
nav.辿可能な~navigable:~HTMLds#nav-traversable
~navigable:~HTMLds#navigable
~navigable容器:~HTMLds#navigable-container
~node~navigable:~HTMLds#node-navigable
~top-level辿可能:~HTMLds#top-level-traversable
全部的に作動中:~HTMLds#fully-active
子~navigable:~HTMLds#child-navigable

shE.~URL:~HTMLnav#she-url
shE.~navi~API~ID:~HTMLnav#she-navigation-api-id
shE.~navi~API~key:~HTMLnav#she-navigation-api-key
shE.~navi~API状態:~HTMLnav#she-navigation-api-state
shE.~step:~HTMLnav#she-step
shE.文書:~HTMLnav#she-document
shE.文書~状態:~HTMLnav#she-document-state
~URLと履歴を更新する:~HTMLnav#url-and-history-update-steps
~navi~algo:~HTMLnav#navigate
~navigateする:~HTMLnav#navigate
~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navigableを読込直す:~HTMLnav#reload
~navigateすることは~sandbox法により許容され:~HTMLnav#allowed-to-navigate
~navi~API用に~session履歴~entry群を取得-:~HTMLnav#getting-session-history-entries-for-the-navigation-api
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
~naviは置換-になるモノトスルか？:~HTMLnav#the-navigation-must-be-a-replace
~scroll位置~dataを復旧する:~HTMLnav#restore-scroll-position-data
~session履歴~entry:~HTMLnav#session-history-entry
~session履歴~entry群を取得する:~HTMLnav#getting-session-history-entries
~session履歴~辿り手続きを付加する:~HTMLnav#tn-append-session-history-traversal-steps
~source~snapshot~paramsを~snapshotする:~HTMLnav#snapshotting-source-snapshot-params
履歴~取扱いの挙動:~HTMLnav#history-handling-behavior
履歴を差分だけ辿る:~HTMLnav#traverse-the-history-by-a-delta
文書を作動化し直す:~HTMLnav#reactivate-a-document
直列形の状態:~HTMLnav#serialized-state
素片への~navi:~HTMLnav#navigate-fragid
	素片へ~navigateする:~HTMLnav#navigate-fragid
素片へ~scrollする:~HTMLnav#scroll-to-the-fragment-identifier
辿-用に履歴~stepを適用する:~HTMLnav#apply-the-traverse-history-step

~unload~counter:~HTMLlifecycle#unload-counter
doc.回復可能~状態:~HTMLlifecycle#concept-document-salvageable

aG.~event~loop:~WAPI#concept-agent-event-loop
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~naviと辿り~task~source:~WAPI#navigation-and-traversal-task-source
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
~error情報を抽出する:~WAPI#extract-error
大域~taskを~queueする:~WAPI#queue-a-global-task
小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
走らせた~scriptを片付ける:~WAPI#clean-up-after-running-script
関連な~agent:~WAPI#relevant-agent
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object

序数~値:~HEgrouping#ordinal-value

	●引数＊

	%~navi~API状態:~HTMLnav#navigation-navigation-api-state
	%例外を可能化するか:~HTMLnav#exceptions-enabled
	%履歴~取扱い:~HTMLnav#navigation-hh
	%~navi~API状態:~HTMLnav#reload-navigation-api-state
	%履歴~取扱い:~HTMLnav#uhus-historyhandling
	%直列形の~data:~HTMLnav#uhus-serializeddata

	●用語（外部
url.素片:~URL1#concept-url-fragment
~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer
同等な~URL:~URL1#concept-url-equals
	素片は除外する:~URL1#url-equals-exclude-fragments

sct.~item:~INFRA#struct-item
	~Assert:~INFRA#assert
	~EACH:~INFRA#list-iterate
	~IN:~INFRA#list-contain
	~WHILE:~INFRA#iteration-while
~cloneする:~INFRA#list-clone
~entryを除去する:~INFRA#map-remove
~list:~INFRA#list
有順序~map:~INFRA#ordered-map
	~map内に存在する:~INFRA#map-exists
~size:~INFRA#list-size
	一致する:~INFRA#string-is → ~NEQ
付加する:~INFRA#list-append
構造体:~INFRA#struct
空:~INFRA#list-is-empty
除去する:~INFRA#list-remove

新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
~promiseを取扱済みとして~markする:~WEBIDLjs#mark-a-promise-as-handled
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
却下される~promise:~WEBIDLjs#a-promise-rejected-with
新たな~obj:~WEBIDLjs#new
解決される~promise:~WEBIDLjs#a-promise-resolved-with
すべての~promiseを待機する:~WEBIDLjs#wait-for-all
	コレ:~WEBIDL#this

aB.中止-済み:~DOM4#abortsignal-aborted
aC.中止-を通達する:~DOM4#abortcontroller-signal-abort
aC.通達:~DOM4#abortcontroller-signal
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
ev.取消されたか:~DOM4#canceled-flag
ev.配送-中か:~DOM4#dispatch-flag
~eventを作成する:~DOM4#concept-event-create
~eventを発火する:~DOM4#concept-event-fire
~eventを配送する:~DOM4#concept-event-dispatch
文書~要素:~DOM4#document-element

doc.初期~about_blankか:~HTMLdom#is-initial-about:blank

dS.生成元:~HTMLnav#document-state-origin
dS.要請~referrer施策:~HTMLnav#document-state-request-referrer-policy
doc.指示された部位:~HTMLnav#the-indicated-part-of-the-document
i.~browser~UI:~HTMLnav#uni-browser-ui
i.なし:~HTMLnav#uni-none

逆直列化:~HTMLcloning#structureddeserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage


rs.状態s:~FETCH#concept-response-status

~JS実行~文脈:~TC39#sec-execution-contexts
~JS実行~文脈~stack:~TC39#execution-context-stack

~consoleに警告を報告する:~CONSOLE#report-a-warning-to-the-console

~referrer施策:~REFERRER-POLICY#referrer-policy

文書の開始位置に~scrollする:~CSSOMVIEW#scroll-to-the-beginning-of-the-document
表示域:~CSS2J#viewport

●●html_code_list

■navigation-api-intro-1
<button onclick="navigation.reload()">Reload</button>
％
<input type="url" id="navigationURL">
<button onclick="navigation.navigate(navigationURL.value)">Navigate</button>
％
<button id="backButton" onclick="navigation.back()">Back</button>
<button id="forwardButton" onclick="navigation.forward()">Forward</button>
％
<select id="traversalDestinations"></select>
<button id="goButton" onclick="navigation.traverseTo(%traversalDestinations.value)">Traverse To</button>
％
<％script>
%backButton.disabled = !navigation.canGoBack;
%forwardButton.disabled = !navigation.canGoForward;
％
for (const %entry of navigation.entries()) {
  %traversalDestinations.append(new Option(%entry.url, %entry.key));
}
</％script>

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL#nav-traversal-apis">§ The navigation API</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — ナビ API</h1>
<p>The navigation API</p>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
			<section id="navigation-api">
<h4 title="The navigation API">7.2.6. ~navi~API</h4>

<p class="trans-note">【
この~APIは比較的新しいので、
`~supportする~browser＠https://developer.mozilla.org/en-US/docs/Web/API/Navigation#browser_compatibility$は，まだ限られている。
】</p>

				<section id="navigation-api-intro">
<h5 title="Introduction">7.2.6.1 序論</h5>

◎非規範的

<p>
~navi~APIは、
大域的な `navigation$m ~propにより供され，
~naviと履歴~entryを管理するための［
現代の, ~web~appに注力した仕方
］を供する。
それは、
古典的な［
`location＠~WINDOW#dom-location$c,
`history＠~WINDOW#dom-history$c
］~APIの後継である。
◎
The navigation API, provided by the global navigation property, provides a modern and web application-focused way of managing navigations and history entries. It is a successor to the classic location and history APIs.
</p>

<p>
この~APIが供する能として
`~session履歴~entry$を検分することが挙げられる。
例えば，次の~codeは、
各~entryの~URLを有順序~list内に表示することになる：
◎
One ability the API provides is inspecting session history entries. For example, the following will display the entries' URLs in an ordered list:
</p>

<pre class="lang-js">
const %ol = document.createElement("ol");
%ol.start = 0; /* <span class="comment">
各~list~itemの`序数~値$が~entryの~indexと合致するようにする
◎
so that the list items' ordinal values match up with the entry indices
</span> */

for (const %entry of navigation.entries()) {
  const %li = document.createElement("li");

  if (%entry.index &lt; navigation.currentEntry.index) {
    %li.className = "backward";
  } else if (%entry.index &gt; navigation.currentEntry.index) {
    %li.className = "forward";
  } else {
    %li.className = "current";
  }

  %li.textContent = %entry.url;
  %ol.append(%li);
}
</pre>

<p>
`navigation.entries()$c が返す配列は、
`NavigationHistoryEntry$I ~instanceたちを包含する。
それらは、
ここに示される［
`url$mH, `index$mH
］~propに加えて，他の有用な~propも有する。
この配列が包含する `NavigationHistoryEntry$I ~objは：
◎
The navigation.entries() array contains NavigationHistoryEntry instances, which have other useful properties in addition to the url and index properties shown here.＼
</p>
<ul>
	<li>
現在の`~navigable$を表現するものに限られるので、
その内容は［
`iframe$e など，`~navigable容器$の内側にある~navi／
当の~navi~APIが `iframe$e の内側で利用されている事例では`親$navの~navi
］により影響iされないことに注意。
◎
Note that the array only contains NavigationHistoryEntry objects that represent the current navigable, and thus its contents are not impacted by navigations inside navigable containers such as iframes, or by navigations of the parent navigable in cases where the navigation API is itself being used inside an iframe.＼
</li>
	<li>
同一-`生成元$に属する`~session履歴~entry$を表現しているものに限られる
— すなわち、
利用者が現在の~entryより前／後にある他の生成元へ訪問した場合，
そこには対応する `NavigationHistoryEntry$I は無い。
◎
Additionally, it only contains NavigationHistoryEntry objects representing same-origin session history entries, meaning that if the user has visited other origins before or after the current one, there will not be corresponding NavigationHistoryEntrys.
</li>
</ul>

<hr>

<p>
~navi~APIは、
履歴を通して［
~navigateする／読込直す／辿る
］ためにも利用できる：
◎
The navigation API can also be used to navigate, reload, or traverse through the history:
</p>

`navigation-api-intro-1^xCode

<p>
ここでも、
辿りは，同一-`生成元$に属する行先に制限されることに注意。
すなわち、
例えば `navigation.canGoBack$c は，
直前の`~session履歴~entry$が別の生成元に属する~page用である場合には
~F になる。
◎
Note that traversals are again limited to same-origin destinations, meaning that, for example, navigation.canGoBack will be false if the previous session history entry is for a page from another origin.
</p>

<hr>

<p>
~navi~APIを成す最も強力な部分は、
`navigate$et ~eventである
— それは、
現在の`~navigable$において，ほぼ どの［
~navi／辿り
］が生じても発火される：
◎
The most powerful part of the navigation API is the navigate event, which fires whenever almost any navigation or traversal occurs in the current navigable:
</p>

<pre class="lang-js">
%navigation.onnavigate = %event =&gt; {
  console.log(%event.navigationType); /* <span class="comment">
`push^l ／ `replace^l ／ `reload^l ／ `traverse^l
◎
"push", "replace", "reload", or "traverse"
</span> */
  console.log(%event.destination.url);
  console.log(%event.userInitiated);
  /* <span class="comment">
…および，`他の有用な~prop＠#the-navigateevent-interface$
◎
... and other useful properties
</span> */
};
</pre>

<p>
（この~eventは、［
`~URL~barから起動された＠~HTMLlifecycle#nav-traversal-ui$／
他の~windowから起動された／
行先が新たな文書になる
］~navi用には，発火されない。）
◎
(The event will not fire for location bar-initiated navigations, or navigations initiated from other windows, when the destination of the navigation is a new document.)
</p>

<p>
この~eventの `cancelable$m ~propは、
大抵は ~T になる
— すなわち、
`preventDefault()$m を利用して取消せる：
◎
Much of the time, the event's cancelable property will be true, meaning this event can be canceled using preventDefault():
</p>

<pre>
navigation.onnavigate = %event =&gt; {
  if (%event.cancelable &amp;&amp; isDisallowedURL(%event.destination.url)) {
    alert(``^お願いだから ${%event.destination.url} へは行かないで🙏``^);
    %event.preventDefault();
  }
};
</pre>

<p>
`cancelable$m ~propは、
一部の `traverse$l ~navi用には ~F になる
— 次に挙げる場合など：
◎
The cancelable property will be false for some "traverse" navigations, such as＼
</p>
<ul>
	<li>
`子~navigable$の内側で場を占めるもの。
◎
those taking place inside child navigables,＼
</li>
	<li>
新たな非同一-生成元へ行くもの。
◎
those crossing to new origins,＼
</li>
	<li>
利用者が［
以前に `preventDefault()$m の~callにより辿ることを防止されたとき
］から，その後すぐに再び辿るよう試みたとき。
◎
or when the user attempts to traverse again shortly after a previous call to preventDefault() prevented them from doing so.
</li>
</ul>

<p>
`NavigateEvent$I の `intercept()$mE ~methodは、
~naviを横取して，それを同一-文書への~naviに変換することを許容する：
◎
The NavigateEvent's intercept() method allows intercepting a navigation and converting it into a same-document navigation:
</p>

<pre class="lang-js">
navigation.addEventListener("navigate", %e =&gt; {
  /* <span class="comment">
一部の~naviは，横取できない
— 例：非同一-生成元への~navi。
それらは、
通常に取扱うよう~browserに任せる。
◎
Some navigations, e.g. cross-origin navigations, we cannot intercept. Let the browser handle those normally.
</span> */
  if (!%e.canIntercept) {
    return;
  }

  /* <span class="comment">
類似に、
素片への~naviや~downloadは，横取しない。
◎
Similarly, don't intercept fragment navigations or downloads.
</span> */
  if (%e.hashChange || %e.downloadRequest !== null) {
    return;
  }

  const %url = new URL(%event.destination.url);

  if (%url.pathname.startsWith("/articles/")) {
    %e.intercept({
      async handler() {
        /* <span class="comment">
~URLは，すでに変化したので、
新たな内容を~fetchしている間は，代わりの何か
— ~pageは読込n中であることを表すものなど —
を示す。
◎
The URL has already changed, so show a placeholder while fetching the new content, such as a spinner or loading page.
</span> */
        renderArticlePagePlaceholder();

        /* <span class="comment">
新たな内容を~fetchして，
準備済みになったとき表示する。
◎
Fetch the new content and display when ready.
</span> */
        const %articleContent = await getArticleContent(%url.pathname, { signal: %e.signal });
        renderArticlePage(%articleContent);
      }
    });
  }
});
</pre>

<p>
`handler$mb 関数は、
当の~naviの［
非同期的な進捗／成否
］を表現する~promiseを返せることに注意。
~promiseが依然として処理待ちにある間、
~browser~UIは，~naviを進行中として扱える
（例：読込n中を表す何かを呈示することにより）。
~navi~APIを成す他の各部も，これらの~promise
— `navigation.navigate()$c の返り値など —
に敏感である：
◎
Note that the handler function can return a promise to represent the asynchronous progress, and success or failure, of the navigation. While the promise is still pending, browser UI can treat the navigation as ongoing (e.g., by presenting a loading spinner). Other parts of the navigation API are also sensitive to these promises, such as the return value of navigation.navigate():
</p>
<pre class="lang-js">
const { %committed, %finished } = await navigation.navigate("/articles/the-navigation-api-is-cool");

/* <span class="comment">
~commit時の~promise（ %committed ）は、
~URLが変化したなら，充足されることになる
— それは、
（ `NavigateEvent^I が取消されなかったなら）
即時に起こる。
◎
The committed promise will fulfill once the URL has changed, which happens immediately (as long as the NavigateEvent wasn't canceled).
</span> */
await %committed;

/* <span class="comment">
完遂-時の~promise（ %finished ）は、
`handler()^c が返した~promise【！Promise】が充足されたなら，充足されることになる
— それは、
当の記事（ `articles/...^l ）が~downloadされ，具現化されたとき起こる。
（あるいは、
`handler()^c が途中で失敗した場合には，却下されることになる）。
◎
The finished promise will fulfill once the Promise returned by handler() has fulfilled, which happens once the article is downloaded and rendered. (Or, it will reject, if handler() fails along the way).
</span> */
await %finished;
</pre>

				</section>
				<section id="navigation-interface">
<h5 title="The Navigation interface">7.2.6.2. `Navigation^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `Navigation@I : `EventTarget$I {
  sequence&lt;`NavigationHistoryEntry$I&gt; `entries$mN();
  readonly attribute `NavigationHistoryEntry$I? `currentEntry$mN;
  undefined `updateCurrentEntry$mN(`NavigationUpdateCurrentEntryOptions$I options);
  readonly attribute `NavigationTransition$I? `transition$mN;
  readonly attribute `NavigationActivation$I? `activation$mN;

  readonly attribute boolean `canGoBack$mN;
  readonly attribute boolean `canGoForward$mN;

  `NavigationResult$I `navigate$mN(USVString url, optional `NavigationNavigateOptions$I options = {});
  `NavigationResult$I `reload$mN(optional `NavigationReloadOptions$I options = {});

  `NavigationResult$I `traverseTo$mN(DOMString key, optional `NavigationOptions$I options = {});
  `NavigationResult$I `back$mN(optional `NavigationOptions$I options = {});
  `NavigationResult$I `forward$mN(optional `NavigationOptions$I options = {});

  attribute `EventHandler$I `onnavigate$mN;
  attribute `EventHandler$I `onnavigatesuccess$mN;
  attribute `EventHandler$I `onnavigateerror$mN;
  attribute `EventHandler$I `oncurrententrychange$mN;
};

dictionary `NavigationUpdateCurrentEntryOptions@I {
  required any `state@mbC;
};

dictionary `NavigationOptions@I {
  any `info@mbN;
};

dictionary `NavigationNavigateOptions@I : `NavigationOptions$I {
  any `state@mbN;
  `NavigationHistoryBehavior$I `history@mbN = `auto$hH;
};

dictionary `NavigationReloadOptions@I : `NavigationOptions$I {
  any `state@mbR;
};

dictionary `NavigationResult@I {
  `Promise$&lt;`NavigationHistoryEntry$I&gt; `committed@mb;
  `Promise$&lt;`NavigationHistoryEntry$I&gt; `finished@mb;
};

enum `NavigationHistoryBehavior@I {
  `auto$hH,
  `push$hH,
  `replace$hH
};
</pre>

<p>
各 `Window$I ~obj %~window には、
`~navi~API@
— ある `Navigation$I ~obj —
が結付けられる。
%~window の作成~時には、
その`~navi~API$を次の結果に設定するモノトスル
⇒
`新たな~obj$( `Navigation$I, %~window に`関連な~realm$ )
◎
Each Window has an associated navigation API, which is a Navigation object. Upon creation of the Window object, its navigation API must be set to a new Navigation object created in the Window object's relevant realm.
</p>

<div class="algo">
`Window$I の
`navigation@m
取得子~手続きは
⇒
~RET コレの`~navi~API$
◎
The navigation getter steps are to return this's navigation API.
</div>

<p>
`Navigation$I ~interfaceを実装しているすべての~objは、
次に挙げる`~event~handler$
（および，対応している`~event~handler~event型$）
を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the Navigation interface:
</p>

<table><thead>
<tr><th>
`~event~handler$
◎
Event handler
<th>
`~event~handler~event型$
◎
Event handler event type
<tbody>

<tr><td>`onnavigate@mN
<td>`navigate$et
<tr><td>`onnavigatesuccess@mN
<td>`navigatesuccess$et
<tr><td>`onnavigateerror@mN
<td>`navigateerror$et
<tr><td>`oncurrententrychange@mN
<td>`currententrychange$et
</table>

				</section>
				<section id="navigation-api-core">
<h5 title="Core infrastructure">7.2.6.3. 中核~基盤</h5>

<p>
各 `Navigation$I には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
<p>
`~entry~list@nV
⇒
`NavigationHistoryEntry$I ~objたちが成す`~list$
— 初期~時は空とする。
</p>

<p class="trans-note">【
この~listが表現する［
`~session履歴~entry$nheたちが成す~list
］は、
“~navi履歴~entry~list”
と称される。
】</p>
◎
Each Navigation has an associated entry list, a list of NavigationHistoryEntry objects, initially empty.
</li>
	<li>
`現在の~entry~index@nV
⇒
整数
— 初期~時は −1 とする。
◎
Each Navigation has an associated current entry index, an integer, initially −1.
</li>
</ul>

<div class="algo">
<p>
`~naviの現在の~entry@
は、
所与の
( `Navigation$I %~navi )
に対し：
◎
The current entry of a Navigation navigation is the result of running the following steps:
</p>
<ol>
	<li>
~IF［
%~navi の`~entryや~eventは不能化されて$いる
］
⇒
~RET ~NULL
◎
If navigation has entries and events disabled, then return null.
</li>
	<li>
~Assert：
%~navi の`現在の~entry~index$nV ~NEQ −1
◎
Assert: navigation's current entry index is not −1.
</li>
	<li>
~RET %~navi の`~entry~list$nV[ %~navi の`現在の~entry~index$nV ]
◎
Return navigation's entry list[navigation's current entry index].
</li>
</ol>
</div>

<div class="algo">
<p>
`Navigation$I %~navi の
`~entryや~eventは不能化されて@
いるとは、［
%~navi に`関連な大域~obj$に`結付けられた文書$
］が ~OR↓ を満たすことをいう：
</p>
<ul>
	<li>
`全部的に作動中$でない
</li>
	<li>
その`初期~about_blankか$doc ~EQ ~T
</li>
	<li>
その`生成元$docは`不透明な生成元$である
</li>
</ul>
◎
A Navigation navigation has entries and events disabled if the following steps return true:
• Let document be navigation's relevant global object's associated Document.
• If document is not fully active, then return true.
• If document's is initial about:blank is true, then return true.
• If document's origin is opaque, then return true.
• Return false.
</div>

<div class="algo">
<p>
`~navi~API~entry~indexを取得する@
ときは、
所与の
( `Navigation$I %~navi, `~session履歴~entry$ %履歴~entry )
に対し：
◎
To get the navigation API entry index of a session history entry she within a Navigation navigation:
</p>
<ol>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
<p>
%~navi の`~entry~list$nVを成す
~EACH( %~NHE )
に対し：
◎
For each nhe of navigation's entry list:
</p>
		<ol>
			<li>
~IF［
%~NHE の`~session履歴~entry$nhe ~EQ %履歴~entry
］
⇒
~RET %~index
◎
If nhe's session history entry is equal to she, then return index.
</li>
			<li>
%~index ~INCBY 1
◎
Increment index by 1.
</li>
		</ol>
	</li>
	<li>
~RET −1
◎
Return −1.
</li>
</ol>
</div>

<hr>

<p>
`NavigationType$I 列挙は、
~navi~API全体を通して［
要として利用される種別
］を与える：
◎
A key type used throughout the navigation API is the NavigationType enumeration:
</p>

<pre class="idl">
enum `NavigationType@I {
 `push$l,
 `replace$l,
 `reload$l,
 `traverse$l
};
</pre>

<p>
これは、
~web開発者から可視な “~navi” の主な種別を捕捉する
— それは、
（`他所にて注記された＠~HTMLnav#note-meaning-of-navigate$とおり）
この標準を成す唯一の`~navi~algo$に正確には対応していない。
各~値の意味は：
◎
This captures the main web developer-visible types of "navigations", which (as noted elsewhere) do not exactly correspond to this standard's singular navigate algorithm. The meaning of each value is the following:
</p>

<dl>
	<dt>`push@l</dt>
	<dd>
<p>
`~navigateする$各~callのうち［
次に挙げるいずれかに該当するもの
］に対応する：
</p>
		<ul>
			<li>
`履歴~取扱いの挙動$は `push$hH になるもの
</li>
			<li>
`history.pushState()＠~WINDOW#dom-history-pushstate$c によるもの
</li>
		</ul>
◎
Corresponds to calls to navigate where the history handling behavior ends up as "push", or to history.pushState().
</dd>

	<dt>`replace@l</dt>
	<dd>
<p>
`~navigateする$各~callのうち［
次に挙げるいずれかに該当するもの
］に対応する：
</p>
		<ul>
			<li>
`履歴~取扱いの挙動$は `replace$hH になるもの
</li>
			<li>
`history.replaceState()＠~WINDOW#dom-history-pushstate$c によるもの
</li>
		</ul>
◎
Corresponds to calls to navigate where the history handling behavior ends up as "replace", or to history.replaceState().
</dd>

	<dt>`reload@l</dt>
	<dd>
`~navigableを読込直す$各~callに対応する。
◎
Corresponds to calls to reload.
</dd>

	<dt>`traverse@l</dt>
	<dd>
`履歴を差分だけ辿る$各~callに対応する。
◎
Corresponds to calls to traverse the history by a delta.
</dd>
</dl>

<p class="note">注記：
`NavigationType$I 列挙を成す値~空間は、
この仕様の内部的な`履歴~取扱いの挙動$用の種別を成す値~空間の上位集合である。
この標準を成す各部は、
`NavigationType$I を期待する~algoに`履歴~取扱いの挙動$を渡すことにより，
このことを用立てる。
◎
The value space of the NavigationType enumeration is a superset of the value space of the specification-internal history handling behavior type. Several parts of this standard make use of this overlap, by passing in a history handling behavior to an algorithm that expects a NavigationType.
</p>

				</section>
				<section id="navigation-api-entry-updates">
<h5 title="Initializing and updating the entry list">7.2.6.4. ~entry~listの初期化-法と更新-法</h5>

<div class="algo">
<p>
`新たな文書~用に~navi~API~entry群を初期化する@
ときは、
所与の
⇒＃
`Navigation$I %~navi,
`~session履歴~entry$たちが成す`~list$ %新-履歴~entry群,
`~session履歴~entry$ %初期~履歴~entry
◎終
に対し：
◎
To initialize the navigation API entries for a new document given a Navigation navigation, a list of session history entries newSHEs, and a session history entry initialSHE:
</p>
<ol>
	<li>
~Assert：
%~navi の`~entry~list$nVは`空$である。
◎
Assert: navigation's entry list is empty.
</li>
	<li>
~Assert：
%~navi の`現在の~entry~index$nV ~EQ −1
◎
Assert: navigation's current entry index is −1.
</li>
	<li>
~IF［
%~navi の`~entryや~eventは不能化されて$いる
］
⇒
~RET
◎
If navigation has entries and events disabled, then return.
</li>
	<li>
<p>
%新-履歴~entry群 を成す
~EACH( %新-履歴~entry )
に対し：
◎
For each newSHE of newSHEs:
</p>
		<ol>
			<li>
%新-~NHE ~LET `新たな~obj$( `NavigationHistoryEntry$I, %~navi に`関連な~realm$ )
◎
Let newNHE be a new NavigationHistoryEntry created in the relevant realm of navigation.
</li>
			<li>
%新-~NHE の`~session履歴~entry$nhe ~SET %新-履歴~entry
◎
Set newNHE's session history entry to newSHE.
</li>
			<li>
%~navi の`~entry~list$nVに %新-~NHE を`付加する$
◎
Append newNHE to navigation's entry list.
</li>
		</ol>

<p class="note">注記：
%新-履歴~entry群 は，
元々は`~navi~API用に~session履歴~entry群を取得-$した結果なので、
それを成す~entryたち【！各 %新-履歴~entry】は，
%初期~履歴~entry と連続的に`同一-生成元$になる。
◎
newSHEs will have originally come from getting session history entries for the navigation API, and thus each newSHE will be contiguous same origin with initialSHE.
</p>
	</li>
	<li>
%~navi の`現在の~entry~index$nV ~SET `~navi~API~entry~indexを取得する$( %~navi, %初期~履歴~entry ）
◎
Set navigation's current entry index to the result of getting the navigation API entry index of initialSHE within navigation.
</li>
</ol>
</div>

<div class="algo">
<p>
`再~作動化~用に~navi~API~entry群を更新する@
ときは、
所与の
⇒＃
`Navigation$I %~navi,
`~session履歴~entry$たちが成す`~list$ %新-履歴~entry群,
`~session履歴~entry$ %作動化し直される履歴~entry
◎終
に対し：
◎
To update the navigation API entries for reactivation given a Navigation navigation, a list of session history entries newSHEs, and a session history entry reactivatedSHE:
</p>
<ol>
	<li>
~IF［
%~navi の`~entryや~eventは不能化されて$いる
］
⇒
~RET
◎
If navigation has entries and events disabled, then return.
</li>
	<li>
%新-~NHE群 ~LET 新たな空`~list$
◎
Let newNHEs be a new empty list.
</li>
	<li>
%旧-~NHE群 ~LET %~navi の`~entry~list$nVを`~cloneする$
◎
Let oldNHEs be a clone of navigation's entry list.
</li>
	<li>
<p>
%新-履歴~entry群 を成す
~EACH( %新-履歴~entry )
に対し：
◎
For each newSHE of newSHEs:
</p>
		<ol>
			<li>
%新-~NHE ~LET ~NULL
◎
Let newNHE be null.
</li>
			<li>
<p>
%旧-~NHE群 を成す
~EACH( `NavigationHistoryEntry$I %旧-~NHE )
に対し：
</p>
				<ol>
					<li>
~IF［
%旧-~NHE の`~session履歴~entry$nhe ~NEQ %新-履歴~entry
］
⇒
~CONTINUE
</li>
					<li>
%新-~NHE ~SET %旧-~NHE
</li>
					<li>
%旧-~NHE群 から %旧-~NHE を`除去する$
</li>
				</ol>
◎
If oldNHEs contains a NavigationHistoryEntry matchingOldNHE whose session history entry is newSHE, then:
• Set newNHE to matchingOldNHE.
• Remove matchingOldNHE from oldNHEs.
</li>
			<li>
<p>
~IF［
%新-~NHE ~EQ ~NULL
］：
◎
Otherwise:
</p>
				<ol>
					<li>
%新-~NHE ~SET `新たな~obj$( `NavigationHistoryEntry$I, %~navi に`関連な~realm$ )
◎
Set newNHE to a new NavigationHistoryEntry created in the relevant realm of navigation.
</li>
					<li>
%新-~NHE の`~session履歴~entry$nhe ~SET %新-履歴~entry
◎
Set newNHE's session history entry to newSHE.
</li>
				</ol>
			</li>
			<li>
%新-~NHE群 に %新-~NHE を`付加する$
◎
Append newNHE to newNHEs.
</li>
		</ol>

<p class="note">注記：
%新-履歴~entry群 は，
元々は`~navi~API用に~session履歴~entry群を取得-$した結果なので、
それを成す~entryたち【！各 %新-履歴~entry】は，
%作動化し直される履歴~entry と連続的に`同一-生成元$になる。
◎
newSHEs will have originally come from getting session history entries for the navigation API, and thus each newSHE will be contiguous same origin with reactivatedSHE.
</p>

<p class="note">注記：
この~loopの終了まで %旧-~NHE群 内にあり続ける `NavigationHistoryEntry$I は、
すべて，当の`文書$が`~BF~cache$内に在った間に処分された`~session履歴~entry$を表現する。
◎
By the end of this loop, all NavigationHistoryEntrys that remain in oldNHEs represent session history entries which have been disposed while the Document was in bfcache.
</p>
	</li>
	<li>
%~navi の`~entry~list$ ~SET %新-~NHE群
◎
Set navigation's entry list to newNHEs.
</li>
	<li>
%~navi の`現在の~entry~index$nV ~SET `~navi~API~entry~indexを取得する$( %~navi, %作動化し直される履歴~entry )
◎
Set navigation's current entry index to the result of getting the navigation API entry index of reactivatedSHE within navigation.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navi に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the navigation and traversal task source given navigation's relevant global object to run the following steps:
</p>

<div class="algo">
手続きは
⇒
%旧-~NHE群 を成す
~EACH( %処分される~NHE )
に対し
⇒
`~eventを発火する$( %処分される~NHE, `dispose$et )
◎
For each disposedNHE of oldNHEs:
• Fire an event named dispose at disposedNHE.
</div>

<div class="note">
<p>注記：
この手続きを~taskへ遅延するのは、［
`dispose$et ~eventが `pageshow$et ~eventより後に発火される
］ことを確保するためである。
これは、［
`文書を作動化し直す$際に~pageが受取る最初の~event
］が `pageshow$et になることを確保する。
◎
We delay these steps by a task to ensure that dispose events will fire after the pageshow event. This ensures that pageshow is the first event a page receives upon reactivation.
</p>

<p>
（しかしながら，この~algoを成す他の部分は、
`pageshow$et ~eventが発火される前に走る。
これにより、
`pageshow$et ~event~handlerの間に，［
`navigation.entries()$c ／ `navigation.currentEntry$c
］が正しく更新された値を得るようになることが確保される。）
◎
(However, the rest of this algorithm runs before the pageshow event fires. This ensures that navigation.entries() and navigation.currentEntry will have correctly-updated values during any pageshow event handlers.)
</p>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`同一-文書~navi用に~navi~API~entry群を更新する@
ときは、
所与の
⇒＃
`Navigation$I %~navi,
`~session履歴~entry$ %行先~履歴~entry,
`NavigationType$I %~navi種別
◎終
に対し：
◎
To update the navigation API entries for a same-document navigation given a Navigation navigation, a session history entry destinationSHE, and a NavigationType navigationType:
</p>
<ol>
	<li>
~IF［
%~navi の`~entryや~eventは不能化されて$いる
］
⇒
~RET
◎
If navigation has entries and events disabled, then return.
</li>
	<li>
%旧-現在の~NHE ~LET `~naviの現在の~entry$( %~navi )
◎
Let oldCurrentNHE be the current entry of navigation.
</li>
	<li>
%処分される~NHE群 ~LET 新たな`~list$
◎
Let disposedNHEs be a new empty list.
</li>
	<li>
<p>
~IF［
%~navi種別 ~EQ `traverse$l
］：
◎
If navigationType is "traverse", then:
</p>
		<ol>
			<li>
%~navi の`現在の~entry~index$nV ~SET `~navi~API~entry~indexを取得する$( %~navi, %行先~履歴~entry )
◎
Set navigation's current entry index to the result of getting the navigation API entry index of destinationSHE within navigation.
</li>
			<li>
~Assert：
%~navi の`現在の~entry~index$nV ~NEQ −1
◎
Assert: navigation's current entry index is not −1.
</li>
		</ol>

<p class="note">注記：
この~algoは、
同一-文書への辿り用に限り~callされる。
非同一-文書への辿りは、
代わりに，次のいずれかを~callすることになる
⇒＃
`新たな文書~用に~navi~API~entry群を初期化する$／
`再~作動化~用に~navi~API~entry群を更新する$
◎
This algorithm is only called for same-document traversals. Cross-document traversals will instead call either initialize the navigation API entries for a new document or update the navigation API entries for reactivation.
</p>
	</li>
	<li>
<p>
~ELIF［
%~navi種別 ~EQ `push$l
］：
◎
Otherwise, if navigationType is "push", then:
</p>
		<ol>
			<li>
%~navi の`現在の~entry~index$nV ~INCBY 1
◎
Set navigation's current entry index to navigation's current entry index + 1.
</li>
			<li>
%~index ~LET %~navi の`現在の~entry~index$nV
◎
Let i be navigation's current entry index.
</li>
			<li>
<p>
~WHILE［
%~index ~LT %~navi の`~entry~list$nVの`~size$
］：
◎
While i &lt; navigation's entry list's size:
</p>
				<ol>
					<li>
%処分される~NHE群 に %~navi の`~entry~list$nV[ %~index ] を`付加する$
◎
Append navigation's entry list[i] to disposedNHEs.
</li>
					<li>
%~index ~INCBY 1
◎
Set i to i + 1.
</li>
				</ol>
			</li>
			<li>
%処分される~NHE群 を成す
~EACH( %~item )
に対し
⇒
%~navi の`~entry~list$nV から %~item を`除去する$
◎
Remove all items in disposedNHEs from navigation's entry list.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%~navi種別 ~EQ `replace$l
］
⇒
%処分される~NHE群 に %旧-現在の~NHE を`付加する$
◎
Otherwise, if navigationType is "replace", then:
• Append oldCurrentNHE to disposedNHEs.
</li>
	<li>
<p>
~IF［
%~navi種別 ~IN { `push$l, `replace$l }
］：
◎
If navigationType is "push" or "replace", then:
</p>
		<ol>
			<li>
%新-~NHE ~LET `新たな~obj$( `NavigationHistoryEntry$I, %~navi に`関連な~realm$ )
◎
Let newNHE be a new NavigationHistoryEntry created in the relevant realm of navigation.
</li>
			<li>
%新-~NHE の`~session履歴~entry$nhe ~SET %行先~履歴~entry
◎
Set newNHE's session history entry to destinationSHE.
</li>
			<li>
%~navi の`~entry~list$nV[ %~navi の`現在の~entry~index$nV ] ~SET %新-~NHE
◎
Set navigation's entry list[navigation's current entry index] to newNHE.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~navi の`進行中な~API~method追跡子$ ~NEQ ~NULL
］
⇒
`~commit先~entryについて通知する$( %~navi の`進行中な~API~method追跡子$, `~naviの現在の~entry$( %~navi ) )
◎
If navigation's ongoing API method tracker is non-null, then notify about the committed-to entry given navigation's ongoing API method tracker and the current entry of navigation.
</p>

<p class="note">注記：
これは［
`dispose$et ／ `currententrychange$et
］~eventを発火する前に行うことが重要である
— ~event~handlerは、［
別の~naviを開始する，あるいは
%~navi の`進行中な~API~method追跡子$の値を変更する
］こともできるので。
◎
It is important to do this before firing the dispose or currententrychange events, since event handlers could start another navigation, or otherwise change the value of navigation's ongoing API method tracker.
</p>
	</li>
	<li>
<p>
`~scriptを走らすために準備する$( %~navi に`関連な設定群~obj$ )
◎
Prepare to run script given navigation's relevant settings object.
</p>

<p class="note">注記：
なぜこれを行うか理解するには、
`他の~navi~API~event用の論点＠#note-suppress-microtasks-during-navigation-events$を見よ。
◎
See the discussion for other navigation API events to understand why we do this.
</p>
	</li>
	<li>
`~eventを発火する$( %~navi, `currententrychange$et, `NavigationCurrentEntryChangeEvent$I )
— 次のように初期化して
⇒＃
`~navigationType0$m 属性 ~SET %~navi種別,
`from$m 属性 ~SET %旧-現在の~NHE
◎
Fire an event named currententrychange at navigation using NavigationCurrentEntryChangeEvent, with its navigationType attribute initialized to navigationType and its from initialized to oldCurrentNHE.
</li>
	<li>
%処分される~NHE群 を成す
~EACH( %処分される~NHE )
に対し
⇒
`~eventを発火する$( %処分される~NHE, `dispose$et )
◎
For each disposedNHE of disposedNHEs:
• Fire an event named dispose at disposedNHE.
</li>
	<li>
`走らせた~scriptを片付ける$( %~navi に`関連な設定群~obj$ )
◎
Clean up after running script given navigation's relevant settings object.
</li>
</ol>
</div>

<p class="XXX">
同一-文書への~naviは，実装においては、
~session履歴~entry~listに~fall-backする【！falling off the back of】ことにより，
`~session履歴~entry$を処分させれる。
上の~algo（およびこの標準を成す他の部分）は、
まだ，これを取扱っていない。
そのような事例において正しい挙動を定義することについては、
`課題 #8620＠~HTMLissue/8620$
にて，進捗を追跡できる。
◎
In implementations, same-document navigations can cause session history entries to be disposed by falling off the back of the session history entry list. This is not yet handled by the above algorithm (or by any other part of this standard). See issue #8620 to track progress on defining the correct behavior in such cases.
</p>

				</section>
				<section id="the-navigationhistoryentry-interface">
<h5 title="The NavigationHistoryEntry interface">7.2.6.5. `NavigationHistoryEntry^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `NavigationHistoryEntry@I : `EventTarget$I {
  readonly attribute USVString? `url$mH;
  readonly attribute DOMString `key$mH;
  readonly attribute DOMString `id$mH;
  readonly attribute long long `index$mH;
  readonly attribute boolean `sameDocument$mH;

  any `getState$mH();

  attribute `EventHandler$I `ondispose$mH;
};
</pre>

  <dl class="domintro">
	<dt>%entry.`url$mH</dt>
	<dd>
この`~navi履歴~entry$の~URL。
◎
The URL of this navigation history entry.
</dd>
	<dd>
これが ~NULL を返し得るのは、
%entry に対応する`文書$ %文書 が［
現在の~entryに対応する`文書$とは異なる
（すなわち %entry の `sameDocument$mH ~EQ ~F ）
］かつ［
`~referrer施策$ ~IN { `no-referrer^l, `origin^l } を伴って~fetchされた
］場合である
— それは、
%文書 【！the Document in question】が
自身の~URLを
— 同一-生成元に属する他の~pageからも —
隠していることを指示するので。
◎
This can return null if the entry corresponds to a different Document than the current one (i.e., if sameDocument is false), and that Document was fetched with a referrer policy of "no-referrer" or "origin", since that indicates the Document in question is hiding its URL even from other same-origin pages.
</dd>

	<dt>%entry.`key$mH</dt>
	<dd>
［
この`~navi履歴~entry$が`~navi履歴~entry~list$内で占める場所
］を表現している［
~UAが生成した~randomな~UUID文字列
］。
この値は、
他の `NavigationHistoryEntry$I ~instanceのうち［
`replace$l ~naviに因り，この~entryを置換するもの
］により再利用され，
再読込みや~session復旧-を経ても生残ることになる。
◎
A user agent-generated random UUID string representing this navigation history entry's place in the navigation history list. This value will be reused by other NavigationHistoryEntry instances that replace this one due to "replace" navigations, and will survive reloads and session restores.
</dd>
	<dd>
これは、
`navigation.traverseTo()$c を利用して［
`~navi履歴~entry~list$内で，この~entryへ戻るよう~navigateする
］ために有用になる。
◎
This is useful for navigating back to this entry in the navigation history list, using navigation.traverseTo(key).
</dd>

	<dt>%entry.`id$mH</dt>
	<dd>
この【！specific】`~navi履歴~entry$を表現している［
~UAが生成した~randomな~UUID文字列
］。
この値は、
他の `NavigationHistoryEntry$I ~instanceにより`再利用されない^em。
この値は、［
再読込みや~session復旧-
］を経ても生残ることになる。
◎
A user agent-generated random UUID string representing this specific navigation history entry. This value will not be reused by other NavigationHistoryEntry instances. This value will survive reloads and session restores.
</dd>
	<dd>
これは、［
他の~storage~APIを利用して，この`~navi履歴~entry$に~dataを結付ける
］ために有用になる。
◎
This is useful for associating data with this navigation history entry using other storage APIs.
</dd>

	<dt>%entry.`index$mH</dt>
	<dd>
`navigation.entries()$c の中での，この`~navi履歴~entry$【！＊`NavigationHistoryEntry$I 】の~index。
この~entryが`~navi履歴~entry~list$内に無い場合、
−1 になる。
◎
The index of this NavigationHistoryEntry within navigation.entries(), or −1 if the entry is not in the navigation history entry list.
</dd>

	<dt>%entry.`sameDocument$mH</dt>
	<dd>
この`~navi履歴~entry$が，現在の`文書$と同じ文書~用のものか否かを指示する。
例えば、
この~entryが［
素片への~navi／単-~page~appにおける~navi
］を表現するときは， ~T になる。
◎
Indicates whether or not this navigation history entry is for the same Document as the current one, or not. This will be true, for example, when the entry represents a fragment navigation or single-page app navigation.
</dd>

	<dt>%entry.`getState$mH()</dt>
	<dd>
この~entry内に格納された状態の`逆直列化$を返す
— それは、［
`navigation.navigate()$c ／
`navigation.updateCurrentEntry()$c
］を利用して~entryに追加されたものである。
この状態は、
再読込みや~session復旧-を経ても生残る。
◎
Returns the deserialization of the state stored in this entry, which was added to the entry using navigation.navigate() or navigation.updateCurrentEntry(). This state survives reloads and session restores.
</dd>
	<dd>
一般に，状態~値が~primitiveでない場合、［
`entry.getState() !== entry.getState()^c
］が満たされることに注意
— 各~回ごとに新規な逆直列化が返されるので。
◎
Note that in general, unless the state value is a primitive, entry.getState() !== entry.getState(), since a fresh deserialization is returned each time.
</dd>
	<dd>
この状態は、
古典的な履歴~APIの `history.state＠~WINDOW#dom-history-state$c とは無関係である。
◎
This state is unrelated to the classic history API's history.state.
</dd>
</dl>

<p>
各 `NavigationHistoryEntry$I には、
`~session履歴~entry@nhe
— ある`~session履歴~entry$ —
が結付けられる。
【 “~navi履歴~entry” とも称される。】
◎
Each NavigationHistoryEntry has an associated session history entry, which is a session history entry.
</p>

<p>
所与の `NavigationHistoryEntry$I %~NHE に対し：
◎
↓</p>
<ul>
	<li class="algo">
<p>
%~NHE の
`~key@nE
は、
次の結果を返す：
◎
The key of a NavigationHistoryEntry nhe is given by the return value of the following algorithm:
</p>
		<ol>
			<li>
~IF［
%~NHE に`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~RET 空~文字列
◎
If nhe's relevant global object's associated Document is not fully active, then return the empty string.
</li>
			<li>
~RET %~NHE の`~session履歴~entry$nheの`~navi~API~key$shE
◎
Return nhe's session history entry's navigation API key.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%~NHE の
`~ID@nE
は、
次の結果を返す：
◎
The ID of a NavigationHistoryEntry nhe is given by the return value of the following algorithm:
</p>
		<ol>
			<li>
~IF［
%~NHE に`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~RET 空~文字列
◎
If nhe's relevant global object's associated Document is not fully active, then return the empty string.
</li>
			<li>
~RET %~NHE の`~session履歴~entry$nheの`~navi~API~ID$shE
◎
Return nhe's session history entry's navigation API ID.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%~NHE の
`~index@nE
は、
次の結果を返す：
◎
The index of a NavigationHistoryEntry nhe is given by the return value of the following algorithm:
</p>
		<ol>
			<li>
~IF［
%~NHE に`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~RET −1
◎
If nhe's relevant global object's associated Document is not fully active, then return −1.
</li>
			<li>
~RET `~navi~API~entry~indexを取得する$( %~NHE に`関連な大域~obj$の`~navi~API$, %~NHE の`~session履歴~entry$nhe )
◎
Return the result of getting the navigation API entry index of this's session history entry within this's relevant global object's navigation API.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
<p>
`url@mH
取得子~手続きは：
◎
The url getter steps are:
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET 空~文字列
◎
If document is not fully active, then return the empty string.
</li>
	<li>
%履歴~entry ~LET コレの`~session履歴~entry$nhe
◎
Let she be this's session history entry.
</li>
	<li>
~IF［
%履歴~entry の`文書$shE ~NEQ %文書
］~AND［
%履歴~entry の`文書~状態$shEの`要請~referrer施策$dS ~IN { `no-referrer^l, `origin^l }
］
⇒
~RET ~NULL
◎
If she's document does not equal document, and she's document state's request referrer policy is "no-referrer" or "origin", then return null.
</li>
	<li>
~RET `~URLを直列化する$( %履歴~entry の`~URL$shE )
◎
Return she's URL, serialized.
</li>
</ol>
</div>

<div class="algo">
`key@mH
取得子~手続きは
⇒
~RET コレの`~key$nE
◎
The key getter steps are to return this's key.
</div>

<div class="algo">
`id@mH
取得子~手続きは
⇒
~RET コレの`~ID$nE
◎
The id getter steps are to return this's ID.
</div>

<div class="algo">
`index@mH
取得子~手続きは
⇒
~RET コレの`~index$nE
◎
The index getter steps are to return this's index.
</div>

<div class="algo">
<p>
`sameDocument@mH
取得子~手続きは：
◎
The sameDocument getter steps are:
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET ~F
◎
If document is not fully active, then return false.
</li>
	<li>
~RET ~IS［
コレの`~session履歴~entry$nheの`文書$shE ~EQ %文書
］
◎
Return true if this's session history entry's document equals document, and false otherwise.
</li>
</ol>
</div>

<div class="algo">
<p>
`getState()@mH
~method手続きは：
◎
The getState() method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~RET `undefined^jv
◎
If this's relevant global object's associated Document is not fully active, then return undefined.
</li>
	<li>
<p>
~RET `StructuredDeserialize$jA( コレの`~session履歴~entry$nheの`~navi~API状態$shE )
【！Rethrow any exceptions】
◎
Return StructuredDeserialize(this's session history entry's navigation API state). Rethrow any exceptions.
</p>

<p class="note">注記：
これは、
理論~上は例外を投出し得る
— 十分な~memoryが可用でないときに巨大な `ArrayBuffer$I を逆直列化しようと試みた場合に。
◎
This can in theory throw an exception, if attempting to deserialize a large ArrayBuffer when not enough memory is available.
</p>
	</li>
</ol>
</div>

<p>
`NavigationHistoryEntry$I ~interfaceを実装しているすべての~objは、
次に挙げるを`~event~handler$
（および，対応している`~event~handler~event型$）
を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the NavigationHistoryEntry interface:
</p>

<table><thead>
<tr><th>
`~event~handler$
◎
Event handler
<th>
`~event~handler~event型$
◎
Event handler event type
<tbody>

<tr><td>`ondispose@mH
<td>`dispose$et
</table>

				</section>
				<section id="the-history-entry-list">
<h5 title="The history entry list">7.2.6.6. 履歴~entry~list</h5>

<dl class="domintro">
	<dt>%entries = `navigation$m.`entries()$mN</dt>
	<dd>
現在の`~navi履歴~entry~list$を表現する［
`NavigationHistoryEntry$I ~instanceたちが成す配列
］を返す。
すなわち、
この`~navigable$用の`~session履歴~entry$のうち，［
`現在の~session履歴~entry$navと連続的に`同一-生成元$であるもの
］すべてからなる。
◎
Returns an array of NavigationHistoryEntry instances represent the current navigation history entry list, i.e., all session history entries for this navigable that are same origin and contiguous to the current session history entry.
</dd>

	<dt>`navigation$m.`currentEntry$mN</dt>
	<dd>
`現在の~session履歴~entry$navに対応している `NavigationHistoryEntry$I を返す。
◎
Returns the NavigationHistoryEntry corresponding to the current session history entry.
</dd>

	<dt>`navigation$m.`updateCurrentEntry$mN({ `state$mbC })</dt>
	<dd>
`現在の~session履歴~entry$navの`~navi~API状態$shEを更新する
— `navigation.reload()$c が行う様な~naviを遂行することなく。
◎
Updates the navigation API state of the current session history entry, without performing a navigation like navigation.reload() would do.
</dd>
	<dd>
この~methodの利用が最も適するのは、
~pageに対しすでに起きた更新を捕捉して，
~navi~API状態の中へ反映する必要がある場合である。
状態~更新が~page更新を駆動することが意味される事例には、
代わりに［
`navigation.navigate()$c ／ `navigation.reload()$c
］を利用すること
— これらは、
`navigate$et ~eventを誘発することになる。
◎
This method is best used to capture updates to the page that have already happened, and need to be reflected into the navigation API state. For cases where the state update is meant to drive a page update, instead use navigation.navigate() or navigation.reload(), which will trigger a navigate event.
</dd>

	<dt>`navigation$m.`canGoBack$mN</dt>
	<dd>
`現在の~session履歴~entry$nav（すなわち `currentEntry$mN ）が［
`~navi履歴~entry~list$（すなわち `entries()$mN ）内に在る最初のもの
］でない場合、
~T を返す。
このことは、
この`~navigable$用に［
【その`~session履歴~内＠~HTMLnav#getting-session-history-entries$で】
次を満たす`~session履歴~entry$が直前に在る
］ことを意味する
⇒
その`文書~状態$shEの`生成元$dS ~EQ`生成元$sub 現在の`文書$の`生成元$doc
◎
Returns true if the current current session history entry (i.e., currentEntry) is not the first one in the navigation history entry list (i.e., in entries()). This means that there is a previous session history entry for this navigable, and its document state's origin is same origin with the current Document's origin.
</dd>

	<dt>`navigation$m.`canGoForward$mN</dt>
	<dd>
`現在の~session履歴~entry$nav（すなわち `currentEntry$mN ）が［
`~navi履歴~entry~list$（すなわち `entries()$mN ）内にある最後のもの
］でない場合、
~T を返す。
このことは、
この`~navigable$用に［
【その`~session履歴~内＠~HTMLnav#getting-session-history-entries$で】
次を満たす`~session履歴~entry$が直後に在る
］ことを意味する
⇒
その`文書~状態$shEの`生成元$dS ~EQ`生成元$sub 現在の`文書$の`生成元$doc
◎
Returns true if the current current session history entry (i.e., currentEntry) is not the last one in the navigation history entry list (i.e., in entries()). This means that there is a next session history entry for this navigable, and its document state's origin is same origin with the current Document's origin.
</dd>
</dl>

<div class="algo">
<p>
`entries()@mN
~method手続きは：
◎
The entries() method steps are:
</p>
<ol>
	<li>
~IF［
コレの`~entryや~eventは不能化されて$いる
］
⇒
~RET 新たな~list
◎
If this has entries and events disabled, then return the empty list.
</li>
	<li>
<p>
~RET コレの`~entry~list$nV
◎
Return this's entry list.
</p>

<p class="note">注記：
~Web~IDLの`連列~型~用の変換~規則＠~WEBIDLjs#sequence-to-es$から、
これは，各~callごとに新たな~JS配列~objを作成する。
すなわち，次が満たされる
⇒
<code>navigation.entries() !== navigation.entries()</code>
◎
Recall that because of Web IDL's sequence type conversion rules, this will create a new JavaScript array object on each call. That is, navigation.entries() !== navigation.entries().
</p>
	</li>
</ol>
</div>

<div class="algo">
`currentEntry@mN
取得子~手続きは
⇒
~RET `~naviの現在の~entry$( コレ )
◎
The currentEntry getter steps are to return the current entry of this.
</div>

<div class="algo">
<p>
`updateCurrentEntry(options)@mN
~method手続きは：
◎
The updateCurrentEntry(options) method steps are:
</p>
<ol>
	<li>
%現在の~entry ~LET `~naviの現在の~entry$( コレ )
◎
Let current be the current entry of this.
</li>
	<li>
~IF［
%現在の~entry ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
◎
If current is null, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%直列形の状態 ~LET `StructuredSerializeForStorage$jA( %options[ "`state$mbC" ] )
【！rethrowing any exceptions】
◎
Let serializedState be StructuredSerializeForStorage(options["state"]), rethrowing any exceptions.
</li>
	<li>
%現在の~entry の`~session履歴~entry$nheの`~navi~API状態$shE ~SET %直列形の状態
◎
Set current's session history entry's navigation API state to serializedState.
</li>
	<li>
`~eventを発火する$( コレ, `currententrychange$et, `NavigationCurrentEntryChangeEvent$I )
— 次のように初期化して
⇒＃
`~navigationType0$m 属性 ~SET ~NULL,
`from$m 属性 ~SET %現在の~entry
◎
Fire an event named currententrychange at this using NavigationCurrentEntryChangeEvent, with its navigationType attribute initialized to null and its from initialized to current.
</li>
</ol>
</div>

<div class="algo">
<p>
`canGoBack@mN
取得子~手続きは：
◎
The canGoBack getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`~entryや~eventは不能化されて$いる
］
⇒
~RET ~F
◎
If this has entries and events disabled, then return false.
</li>
	<li>
~Assert：
コレの`現在の~entry~index$nV ~NEQ −1
◎
Assert: this's current entry index is not −1.
</li>
	<li>
~RET ~IS［
コレの`現在の~entry~index$nV ~NEQ 0
］
◎
If this's current entry index is 0, then return false.
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`canGoForward@mN
取得子~手続きは：
◎
The canGoForward getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`~entryや~eventは不能化されて$いる
］
⇒
~RET ~F
◎
If this has entries and events disabled, then return false.
</li>
	<li>
~Assert：
コレの`現在の~entry~index$nV ~NEQ −1
◎
Assert: this's current entry index is not −1.
</li>
	<li>
~RET ~IS［
コレの`現在の~entry~index$nV ~NEQ コレの`~entry~list$nVの`~size$ ~MINUS 1
］
◎
If this's current entry index is equal to this's entry list's size − 1, then return false.
◎
Return true.
</li>
</ol>
</div>

				</section>
				<section id="navigation-api-initiating-navigations">
<h5 title="Initiating navigations">7.2.6.7. ~naviの起動-法</h5>

<dl class="domintro">
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`navigate$mN(%url)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`navigate$mN(%url, %options)</dt>
	<dd>
<p>
現在の~pageから所与の %url へ`~navigateする$。
%options は次に挙げる値を包含し得る：
◎
Navigates the current page to the given url. options can contain the following values:
</p>
		<ul>
			<li>
`history$mbN
⇒
`replace$hH に設定すれば、
~pushする代わりに，現在の~session履歴~entryを新たなものに置換できる。
◎
history can be set to "replace" to replace the current session history entry, instead of pushing a new one.
</li>
			<li>
`info$mbN
⇒
任意の値を設定できる
— それは、
対応している `NavigateEvent$I の `info$mE ~propを拡充することになる。
◎
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</li>
			<li>
`state$mbN
⇒
`直列化-可能$な任意の値に設定できる
— それは、
同一-文書への~navi用には，当の~naviが完了したとき，
`navigation.currentEntry.getState()$c
により検索取得される状態を拡充することになる。
（結果が非同一-文書への~naviになる場合、
無視される。）
◎
state can be set to any serializable value; it will populate the state retrieved by navigation.currentEntry.getState() once the navigation completes, for same-document navigations. (It will be ignored for navigations that end up cross-document.)
</li>
		</ul>
<p>
既定では、
これは，全部的な~naviを遂行することになる
（すなわち、
所与の~URLが現在の~URLと`素片$urlに限り相違する場合を除き，
非同一-文書への~naviになる）。
`intercept()$mE【！navigateEvent.intercept()】 ~methodを利用すれば、
それを同一-文書への~naviに変換できる。
◎
By default this will perform a full navigation (i.e., a cross-document navigation, unless the given URL differs only in a fragment from the current one). The navigateEvent.intercept() method can be used to convert it into a same-document navigation.
</p>
	</dd>
	<dd>
<p>
返される~promiseたちは、
次に従って挙動することになる：
◎
The returned promises will behave as follows:
</p>
		<ul>
			<li>
~naviが中止された場合
⇒
どちらの~promiseも `AbortError$E 例外で却下される。
◎
For navigations that get aborted, both promises will reject with an "AbortError" DOMException.
</li>
			<li>
<p>
同一-文書への~naviになる場合：
◎
For same-document navigations＼
</p>
				<ul>
					<li>
<p>
当の~naviは `intercept()$mE【！navigateEvent.intercept()】 ~methodを利用して作成された場合：
◎
created by using the navigateEvent.intercept() method,＼
</p>
						<ul>
							<li>
`committed$mb は即時に充足される。
◎
committed will fulfill immediately,＼
</li>
							<li>
`finished$mb は、
`~navi~handler~promise$たち【！promsies】に則って，充足されるか却下される。
◎
and finished will fulfill or reject according to any promsies returned by handlers passed to intercept().
</li>
						</ul>
					</li>
					<li>
他の場合（例：横取されない`素片への~navi$）
⇒
どちらの~promiseも即時に充足される。
◎
For other same-document navigations (e.g., non-intercepted fragment navigations), both promises will fulfill immediately.
</li>
				</ul>
			</li>
			<li>
<p>
非同一-文書への~naviの場合
⇒
どちらの~promiseも，決して決着しない。
</p>

<p>
これには、
~naviの結果，~serverから次のいずれかが返された場合も含まれる：
</p>
				<ul>
					<li>
`状態s$rs ~IN { `204^hst, `205^hst }
</li>
					<li>
値 `attachment^bl を伴う `Content-Disposition$h ~header
（したがって、
実際には~navigateしない）
</li>
				</ul>

◎
For cross-document navigations, or navigations that result in 204 or 205 statuses or `Content-Disposition: attachment` header fields from the server (and thus do not actually navigate), both promises will never settle.
</li>
		</ul>
<p>
どの事例においても、
返された~promiseが充足されるときは，
その~navigate先であった `NavigationHistoryEntry$I で解決される。
◎
In all cases, when the returned promises fulfill, it will be with the NavigationHistoryEntry that was navigated to.
</p>
	</dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`reload$mN(%options)</dt>
	<dd>
現在の~pageを`読込直す＠~HTMLnav#reload$。
%options は［
`info$mbN ／ `state$mbR
］を包含し得る
— これらは、
上に述べたとおりに挙動する。
◎
Reloads the current page. options can contain info and state, which behave as described above.
</dd>
	<dd>
現在の~pageに対し，~networkまたは~cacheから読込直すときは、
`intercept()$mE【！navigateEvent.intercept()】 ~methodを利用して，
既定の挙動を上書きできる。
そうすることは、
次を意味する
⇒
この~callが行うのは、
状態を更新するか，適切な `info$mbN を他へ渡すことに限られる。
それに加え， `navigate$et ~event用の~handlerは、
何であれ【！whater】それに見合う動作を遂行する。
◎
The default behavior of performing a from-network-or-cache reload of the current page can be overriden by the using the navigateEvent.intercept() method. Doing so will mean this call only updates state or passes along the appropriate info, plus performing whater actions the navigate event handlers see fit to carry out.
</dd>
	<dd>
<p>
返される~promiseたちは、
次に従って挙動することになる：
◎
The returned promises will behave as follows:
</p>
		<ul>
			<li>
<p>
当の再読込みが `intercept()$mE【！navigateEvent.intercept()】 ~methodを利用して横取された場合：
</p>
				<ul>
					<li>
`committed$mb は、
即時に充足される。
</li>
					<li>
`finished$mb は、
`~navi~handler~promise$たち【！promsies】に則って［
充足される／却下される
］。
</li>
				</ul>
◎
If the reload is intercepted by using the navigateEvent.intercept() method, committed will fulfill immediately, and finished will fulfill or reject according to any promsies returned by handlers passed to intercept().
</li>
			<li>
他の場合、
どちらの~promiseも決して決着しない。
◎
Otherwise, both promises will never settle.
</li>
		</ul>
   </dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`traverseTo$mN(%key)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`traverseTo$mN(%key, { `info$mbN })</dt>
	<dd>
次を満たす`~navi履歴~entry$が在るならば，
それらのうち最も近いものへ`辿る＠~HTMLnav#apply-the-traverse-history-step$
⇒
［
`navigation.entries()$c 内のある `NavigationHistoryEntry$I の`~session履歴~entry$nheである
］~AND［
その`~navi~API~key$shE ~EQ %key
］
◎
Traverses to the closest session history entry that matches the NavigationHistoryEntry with the given key.＼
</dd>
	<dd>
`info$mbN には任意の値を設定できる
— それは、
対応している `NavigateEvent$I の `info$mE ~propを拡充することになる。
◎
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</dd>
	<dd>
前述の条件を満たす履歴~entryへの進捗-中な辿りが，すでに在る場合、
これは，その辿り用の~promiseを返すことになり、
`info$mE は無視されることになる。
◎
If a traversal to that session history entry is already in progress, then this will return the promises for that original traversal, and info will be ignored.
</dd>
	<dd>
<p>
返される~promiseたちは、
次に従って挙動することになる：
◎
The returned promises will behave as follows:
</p>
		<ul>
			<li>
前述の条件を満たす履歴~entryは無い場合
⇒
どちらの~promiseも `InvalidStateError$E 例外で却下される。
◎
If there is no NavigationHistoryEntry in navigation.entries() whose key matches key, both promises will reject with an "InvalidStateError" DOMException.
</li>
			<li>
<p>
同一-文書への辿りである場合：
◎
For same-document traversals＼
</p>
				<ul>
					<li>
<p>
`intercept()$mE【！navigateEvent.intercept()】 ~methodにより横取された場合：
◎
intercepted by the navigateEvent.intercept() method,＼
</p>
						<ul>
							<li>
`committed$mb は、［
当の辿りが処理され，
`navigation.currentEntry$c が更新される
］に伴い，充足される。
◎
committed will fulfill as soon as the traversal is processed and navigation.currentEntry is updated,＼
</li>
							<li>
`finished$mb は、
`~navi~handler~promise$たち【！promsies】に則って［
充足される／却下される
］。
◎
and finished will fulfill or reject according to any promsies returned by the handlers passed to intercept().
</li>
						</ul>
					</li>
					<li>
他の場合
⇒
どちらの~promiseも、［
当の辿り【！travesal】が処理され，
`navigation.currentEntry$c が更新される
］に伴い，充足される。
◎
For non-intercepted same-document travesals, both promises will fulfill as soon as the traversal is processed and navigation.currentEntry is updated.
</li>
				</ul>
			</li>
			<li>
<p>
非同一-文書への辿りである場合
⇒
どちらの~promiseも決して決着しない
</p>

<p>
これには、
~serverから次のいずれかが返された場合も含まれる：
</p>
				<ul>
					<li>
`状態s$rs ~IN { `204^hst, `205^hst }
</li>
					<li>
値 `attachment^bl を伴う `Content-Disposition$h ~header
（したがって、
実際には辿らない）
</li>
				</ul>
◎
For cross-document traversals, including attempted cross-document traversals that end up resulting in a 204 or 205 statuses or `Content-Disposition: attachment` header fields from the server (and thus do not actually traverse), both promises will never settle.
</li>
		</ul>
	</dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`back$mN(【！%key】)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`back$mN(【！%key, 】{ `info$mbN })</dt>
	<dd>
後方に在る`~session履歴~entry$のうち，この`~navigable$を辿らせるもの
— すなわち、
異なる `NavigationHistoryEntry$I に対応するもの
（したがって、
`navigation.currentEntry$c を変化させるもの） —
のうち最も近いものへ辿る。
◎
Traverses to the closest previous session history entry which results in this navigable traversing, i.e., which corresponds to a different NavigationHistoryEntry and thus will cause navigation.currentEntry to change.＼
</dd>
	<dd>
`info$mbN には任意の値を設定できる
— それは、
対応している `NavigateEvent$I の `info$mE ~propを拡充することになる。
◎
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</dd>
	<dd>
そのような`~session履歴~entry$への進捗-中な辿りが，すでに在る場合、
これは，その辿り用の~promiseを返すことになり、
`info$mE は無視されることになる。
◎
If a traversal to that session history entry is already in progress, then this will return the promises for that original traversal, and info will be ignored.
</dd>
	<dd>
返される各~promiseは、
`traverseTo()$mN が返すものと等価に挙動する。
◎
The returned promises behave equivalently to those returned by traverseTo().
</dd>

	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`forward$mN(%key)</dt>
	<dt>{ `committed$mb, `finished$mb } = `navigation$m.`forward$mN(%key, { `info$mbN })</dt>
	<dd>
前方に在る`~session履歴~entry$のうち，この`~navigable$を辿らせるもの
— すなわち、
異なる `NavigationHistoryEntry$I に対応するもの
（したがって、
`navigation.currentEntry$c を変化させるもの） —
のうち最も近いものへ辿る。
◎
Traverses to the closest forward session history entry which results in this navigable traversing, i.e., which corresponds to a different NavigationHistoryEntry and thus will cause navigation.currentEntry to change.＼
</dd>
	<dd>
`info$mbN には任意の値を設定できる
— それは、
対応している `NavigateEvent$I の `info$mE ~propを拡充することになる。
◎
info can be set to any value; it will populate the info property of the corresponding NavigateEvent.
</dd>
	<dd>
そのような`~session履歴~entry$への進捗-中な辿りが，すでに在る場合、
これは，その辿り用の~promiseを返すことになり、
`info$mE は無視されることになる。
◎
If a traversal to that session history entry is already in progress, then this will return the promises for that original traversal, and info will be ignored.
</dd>
	<dd>
返される各~promiseは、
`traverseTo()$mN が返すものと等価に挙動する。
◎
The returned promises behave equivalently to those returned by traverseTo().
</dd>
</dl>

<div class="algo">
<p>
`navigate(url, options)@mN
~method手続きは：
◎
The navigate(url, options) method steps are:
</p>
<ol>
	<li>
%~URL~record ~LET `~URLを相対的に構文解析する$( %url, コレに`関連な設定群~obj$ )
◎
Let urlRecord be the result of parsing a URL given url, relative to this's relevant settings object.
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET `早期~error結果$( `SyntaxError$E 例外 )
◎
If urlRecord is failure, then return an early error result for a "SyntaxError" DOMException.
</li>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this's relevant global object's associated Document.
</li>
	<li>
~IF［
%options[ "`history$mbN" ] ~EQ `push$hH
］~AND［
`~naviは置換-になるモノトスルか？$( %~URL~record, %文書 ) ~EQ ~T
］
⇒
~RET `早期~error結果$( `NotSupportedError$E 例外 )
◎
If options["history"] is "push", and the navigation must be a replace given urlRecord and document, then return an early error result for a "NotSupportedError" DOMException.
</li>
	<li>
%state ~LET %options[ "`state$mbN" ]
◎
↓</li>
	<li>
~IF［
%state ~EQ ε
］
⇒
%state ~SET `undefined^jv
◎
Let state be options["state"], if it exists; otherwise, undefined.
</li>
	<li>
<p>
%直列形の状態 ~LET `StructuredSerializeForStorage$jA( %state )
◎
Let serializedState be StructuredSerializeForStorage(state).＼
</p>

<p>
例外が投出された場合
⇒
~RET `早期~error結果$( その例外 )
◎
If this throws an exception, then return an early error result for that exception.
</p>

<p class="note">注記：
この段は、
早期に遂行することが重要になる。
直列化は，~web開発者~codeを呼出すこともあり、
その結果，後の段で検査する様々なものを変更するかもしれないので。
◎
It is importantly to perform this step early, since serialization can invoke web developer code, which in turn might change various things we check in later steps.
</p>
	</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If document is not fully active, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%文書 の`~unload~counter$ ~GT 0
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If document's unload counter is greater than 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%info ~LET %options[ "`info$mbN" ]
◎
↓</li>
	<li>
~IF［
%info ~EQ ε
］
⇒
%info ~SET `undefined^jv
◎
Let info be options["info"], if it exists; otherwise, undefined.
</li>
	<li>
%~API~method追跡子 ~LET `来たる非-辿-~API~method追跡子を必要なら設定する$( コレ, %info, %直列形の状態 )
◎
Let apiMethodTracker be the result of maybe setting the upcoming non-traverse API method tracker for this given info and serializedState.
</li>
	<li>
<p>
`~navigableを~URLへ~navigateする$( %文書 の`~node~navigable$, %~URL~record, %文書 )
— 次も与える下で
⇒＃
`履歴~取扱い^i ~SET %options[ "`history$mbN" ],
`~navi~API状態^i ~SET %直列形の状態
◎
Navigate document's node navigable to urlRecord using document, with historyHandling set to options["history"] and navigationAPIState set to serializedState.
</p>

<p class="note">注記：
［
`同じ生成元~domain$境界をまたがって公開される
`location.assign()＠~WINDOW#dom-location-assign$c や同類の~API
］と違って、［
`navigation.navigate()$c に~accessし得る~code
］は，［
`window.navigation$c ~propに対し，直にかつ同期的に~accessするもの
］に限られる。
したがって，［
当の~naviに渡される %~source文書 がどこに帰属するか
］について複雑になるのは避けられ、［
`~navigateすることは~sandbox法により許容され$るか否かの検査
］および［
それに付随している `例外を可能化するか＠~HTMLnav#exceptions-enabled$i
］を処する必要はなくなる。
すべての~naviは、
この `Navigation$I ~obj自身（すなわち，コレ）に対応している`文書$（すなわち %文書 ）から来たかのように扱うだけで済む。
◎
Unlike location.assign() and friends, which are exposed across origin-domain boundaries, navigation.navigate() can only be accessed by code with direct synchronous access to the window.navigation property. Thus, we avoid the complications about attributing the source document of the navigation, and we don't need to deal with the allowed by sandboxing to navigate check and its acccompanying exceptionsEnabled flag. We just treat all navigations as if they come from the Document corresponding to this Navigation object itself (i.e., document).
</p>
	</li>
	<li>
<p>
~IF［
コレの`来たる非-辿-~API~method追跡子$ ~EQ %~API~method追跡子
］：
◎
If this's upcoming non-traverse API method tracker is apiMethodTracker, then:
</p>

<p class="note">注記：
この時点でも，この条件が満たされる場合、
`~navi~algo$は，`~navigate_ev~eventを発火する内縁~algo$
（それは、
`来たる~API~method追跡子を進行中にする$）
へ~~達する前に抜け出たことを意味する。
◎
If the upcoming non-traverse API method tracker is still apiMethodTracker, this means that the navigate algorithm bailed out before ever getting to the inner navigate event firing algorithm which would promote that upcoming API method tracker to ongoing.
</p>
		<ol>
			<li>
コレの`来たる非-辿-~API~method追跡子$ ~SET ~NULL
◎
Set this's upcoming non-traverse API method tracker to null.
</li>
			<li>
~RET `早期~error結果$( `AbortError$E 例外 )
◎
Return an early error result for an "AbortError" DOMException.
</li>
		</ol>
	</li>
	<li>
~RET `~navi~API~method追跡子から導出される結果$( %~API~method追跡子 )
◎
Return a navigation API method tracker-derived result for apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`reload(options)@mN
~method手続きは：
◎
The reload(options) method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this's relevant global object's associated Document.
</li>
	<li>
%直列形の状態 ~LET `StructuredSerializeForStorage$jA( `undefined^jv )
◎
Let serializedState be StructuredSerializeForStorage(undefined).
</li>
	<li>
%state ~LET %options[ "`state$mbR" ]
◎
↓</li>
	<li>
<p>
~IF［
%state ~NEQ ε
］
⇒
%直列形の状態 ~SET `StructuredSerializeForStorage$jA( %state )
◎
If options["state"] exists, then set serializedState to StructuredSerializeForStorage(options["state"]).＼
</p>

<p>
例外が投出された場合
⇒
~RET `早期~error結果$( その例外 )
◎
If this throws an exception, then return an early error result for that exception.
</p>

<p class="note">注記：
この段は、
早期に遂行することが重要になる。
直列化は，~web開発者~codeを呼出すこともあり、
その結果，後の段で検査する様々なものを変更するかもしれないので。
◎
It is importantly to perform this step early, since serialization can invoke web developer code, which in turn might change various things we check in later steps.
</p>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%現在の~entry ~LET `~naviの現在の~entry$( コレ )
◎
Let current be the current entry of this.
</li>
			<li>
~IF［
%現在の~entry ~NEQ ~NULL
］
⇒
%直列形の状態 ~SET %現在の~entry の`~session履歴~entry$nheの`~navi~API状態$shE
◎
If current is not null, then set serializedState to current's session history entry's navigation API state.
</li>
		</ol>
	</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If document is not fully active, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%文書 の`~unload~counter$ ~GT 0
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If document's unload counter is greater than 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%info ~LET %options[ "`info$mbN" ]
◎
↓</li>
	<li>
~IF［
%info ~EQ ε
］
⇒
%info ~SET `undefined^jv
◎
Let info be options["info"], if it exists; otherwise, undefined.
</li>
	<li>
%~API~method追跡子 ~LET `来たる非-辿-~API~method追跡子を必要なら設定する$( コレ, %info, %直列形の状態 )
◎
Let apiMethodTracker be the result of maybe setting the upcoming non-traverse API method tracker for this given info and serializedState.
</li>
	<li>
`~navigableを読込直す$( %文書 の`~node~navigable$, %直列形の状態 )
◎
Reload document's node navigable with navigationAPIState set to serializedState.
</li>
	<li>
~RET `~navi~API~method追跡子から導出される結果$( %~API~method追跡子 )
◎
Return a navigation API method tracker-derived result for apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`traverseTo(key, options)@mN
~method手続きは：
◎
The traverseTo(key, options) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`現在の~entry~index$nV ~EQ −1
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If this's current entry index is −1, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
コレの`~entry~list$nVを成す
~EACH( %~entry )
に対し
⇒
~IF［
%~entry の`~session履歴~entry$nheの`~navi~API~key$shE ~EQ %key
］
⇒
~RET `~navi~API用の辿りを遂行する$( コレ, %key, %options )
◎
If this's entry list does not contain a NavigationHistoryEntry whose session history entry's navigation API key equals key, then return an early error result for an "InvalidStateError" DOMException.
◎
Return the result of performing a navigation API traversal given this, key, and options.
</li>
	<li>
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`back(options)@mN
~method手続きは：
◎
The back(options) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`現在の~entry~index$nV ~IN { −1, 0 }
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If this's current entry index is −1 or 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%~key ~LET コレの`~entry~list$nV[ コレの`現在の~entry~index$nV ~MINUS 1 ] の`~session履歴~entry$nheの`~navi~API~key$shE
◎
Let key be this's entry list[this's current entry index − 1]'s session history entry's navigation API key.
</li>
	<li>
~RET `~navi~API用の辿りを遂行する$( コレ, %~key, %options )
◎
Return the result of performing a navigation API traversal given this, key, and options.
</li>
</ol>
</div>

<div class="algo">
<p>
`forward(options)@mN
~method手続きは：
◎
The forward(options) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`現在の~entry~index$nV ~IN { −1, コレの`~entry~list$nVの`~size$ ~MINUS 1 }
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If this's current entry index is −1 or is equal to this's entry list's size − 1, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%~key ~LET コレの`~entry~list$nV[ コレの`現在の~entry~index$nV ~PLUS 1] の`~session履歴~entry$nheの`~navi~API~key$shE
◎
Let key be this's entry list[this's current entry index + 1]'s session history entry's navigation API key.
</li>
	<li>
~RET `~navi~API用の辿りを遂行する$( コレ, %~key, %options )
◎
Return the result of performing a navigation API traversal given this, key, and options.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi~API用の辿りを遂行する@
ときは、
所与の
⇒＃
`Navigation$I %~navi,
文字列 %~key,
`NavigationOptions$I %~option群
◎終
に対し：
◎
To perform a navigation API traversal given a Navigation navigation, a string key, and a NavigationOptions options:
</p>
<ol>
	<li>
%文書 ~LET %~navi に`関連な大域~obj$に`結付けられた文書$
◎
Let document be navigation's relevant global object's associated Document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If document is not fully active, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%文書 の`~unload~counter$ ~GT 0
］
⇒
~RET `早期~error結果$( `InvalidStateError$E 例外 )
◎
If document's unload counter is greater than 0, then return an early error result for an "InvalidStateError" DOMException.
</li>
	<li>
%現在の~entry ~LET `~naviの現在の~entry$( %~navi )
◎
Let current be the current entry of navigation.
</li>
	<li>
~IF［
%~key ~EQ %現在の~entry の`~session履歴~entry$nheの`~navi~API~key$shE
］
⇒
~RET «[ 次に挙げる~entry ]»
⇒＃
"`committed$mb" → `解決される~promise$( %現在の~entry ),
"`finished$mb" → `解決される~promise$( %現在の~entry )
◎
If key equals current's session history entry's navigation API key, then return «[ "committed" → a promise resolved with current, "finished" → a promise resolved with current ]».
</li>
	<li>
~IF［
%~navi の`来たる辿-~API~method追跡子~群$[ %~key ] ~NEQ ε
］
⇒
~RET `~navi~API~method追跡子から導出される結果$( %~navi の`来たる辿-~API~method追跡子~群$[ %~key ] )
◎
If navigation's upcoming traverse API method trackers[key] exists, then return a navigation API method tracker-derived result for navigation's upcoming traverse API method trackers[key].
</li>
	<li>
%info ~LET %~option群[ "`info$mbN" ]
◎
↓</li>
	<li>
~IF［
%info ~EQ ε
］
⇒
%info ~SET `undefined^jv
◎
Let info be options["info"], if it exists; otherwise, undefined.
</li>
	<li>
%~API~method追跡子 ~LET `来たる辿-~API~method追跡子を追加する$( %~navi, %~key, %info )
◎
Let apiMethodTracker be the result of adding an upcoming traverse API method tracker for navigation given key and info.
</li>
	<li>
%~navigable ~LET %文書 の`~node~navigable$
◎
Let navigable be document's node navigable.
</li>
	<li>
%辿可能 ~LET %~navigable の`辿可能な~navigable$nav
◎
Let traversable be navigable's traversable navigable.
</li>
	<li>
%~source~snapshot~params ~LET `~source~snapshot~paramsを~snapshotする$( %文書 )
◎
Let sourceSnapshotParams be the result of snapshotting source snapshot params given document.
</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history traversal steps to traversable:
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%~navigableの履歴~entry群 ~LET `~session履歴~entry群を取得する$( %~navigable )
◎
Let navigableSHEs be the result of getting session history entries given navigable.
</li>
			<li>
%~target履歴~entry ~LET ε
◎
↓</li>
			<li>
%~navigableの履歴~entry群 を成す
~EACH( `~session履歴~entry$ %履歴~entry )
に対し
⇒
~IF［
%履歴~entry の`~navi~API~key$shE ~EQ %~key
］
⇒＃
%~target履歴~entry ~SET %履歴~entry；
~BREAK
◎
Let targetSHE be the session history entry in navigableSHEs whose navigation API key is key.＼
</li>
			<li>
<p>
~IF［
%~target履歴~entry ~EQ ε
］：
◎
If no such entry exists, then:
</p>
				<ol>
					<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navi に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the navigation and traversal task source given navigation's relevant global object to＼
</p>

<div class="algo">
手続きは
⇒
`完遂-時の~promiseを却下する$( %~API~method追跡子, `InvalidStateError$E 例外 )
◎
reject the finished promise for apiMethodTracker with an "InvalidStateError" DOMException.
</div>
					</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>

<p class="note">注記：
この道がとられるのは、
%~navi の`~entry~list$nVが %~navigableの履歴~entry群 に比して古くなっていた場合である
— これが生じ得るのは、［
関連な［
~thread, ~process
］すべてが履歴~変更に対する反応において同期されている間
］を成す短い期間内である。
◎
This path is taken if navigation's entry list was outdated compared to navigableSHEs, which can occur for brief periods while all the relevant threads and processes are being synchronized in reaction to a history change.
</p>
			</li>
			<li>
<p>
~IF［
%~target履歴~entry ~EQ %~navigable にて`作動中な~entry$nav
］
⇒
~RET
◎
If targetSHE is navigable's active session history entry, then abort these steps.
</p>

<p class="note">注記：
これが生じ得るのは、
以前に`~queueされ＠~HTMLnav#tn-append-session-history-traversal-steps$た辿りが，すでに この`~session履歴~entry$へ連れて行った場合である。
その事例では、
以前の辿りが， %~API~method追跡子 をすでに処したことになる。
◎
This can occur if a previously queued traversal already took us to this session history entry. In that case the previous traversal will have dealt with apiMethodTracker already.
</p>
			</li>
			<li>
%結果 ~LET `辿-用に履歴~stepを適用する$( ↓ )
⇒＃
%~target履歴~entry の`~step$shE,
%辿可能,
%~source~snapshot~params,
%~navigable,
`なし$i
◎
Let result be the result of applying the traverse history step given by targetSHE's step to traversable, given sourceSnapshotParams, navigable, and "none".
</li>
			<li>
<p>
~IF［
%結果 ~EQ `~beforeunload_evにより取消された^i
］
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navi に`関連な大域~obj$, 次の手続き )
◎
If result is "canceled-by-beforeunload", then queue a global task on the navigation and traversal task source given navigation's relevant global object to＼
</p>

<div class="algo">
手続きは
⇒
`完遂-時の~promiseを却下する$( %~API~method追跡子, %~navi に`関連な~realm$内に作成される新たな `AbortError$E 例外 )
◎
reject the finished promise for apiMethodTracker with a new "AbortError" DOMException created in navigation's relevant realm.
</div>
			</li>
			<li>
<p>
~IF［
%結果 ~EQ `起動元は許容されない^i
］
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navi に`関連な大域~obj$, 次の手続き )
◎
If result is "initiator-disallowed", then queue a global task on the navigation and traversal task source given navigation's relevant global object to＼
</p>

<div class="algo">
手続きは
⇒
`完遂-時の~promiseを却下する$( %~API~method追跡子, %~navi に`関連な~realm$内に作成される新たな `SecurityError$E 例外 )
◎
reject the finished promise for apiMethodTracker with a new "SecurityError" DOMException created in navigation's relevant realm.
</div>

<div class="note">
<p>注記：
%結果 が［
`~beforeunload_evにより取消された^i ／ `起動元は許容されない^i
］の場合、
`navigate$et ~eventは発火されなかったことになるので，
`進行中な~naviを中止する$のは不正になる
— その結果、
`navigateerror$et ~eventを［
先行する `navigate$et ~eventを伴わずに発火する
］ことになる。
◎
When result is "canceled-by-beforeunload" or "initiator-disallowed", the navigate event was never fired, aborting the ongoing navigation would not be correct; it would result in a navigateerror event without a preceding navigate event.
</p>

<p>
%結果 が `~navigate_evにより取消された^i になる事例では、
`navigate$et ~eventは`発火される^emが，
`~navigate_ev~eventを発火する内縁~algo$が`進行中な~naviを中止する$よう~careすることになる。
◎
In the "canceled-by-navigate" case, navigate is fired, but the inner navigate event firing algorithm will take care of aborting the ongoing navigation.
</p>
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
~RET `~navi~API~method追跡子から導出される結果$( %~API~method追跡子 )
◎
Return a navigation API method tracker-derived result for apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`早期~error結果@
は、
所与の
( 例外 %e )
に対し
⇒
~RET  «[ 次に挙げる~entry ]» として与えられる `NavigationResult$I 辞書~instance
⇒＃
"`committed$mb" → `却下される~promise$( %e ),
"`finished$mb" → `却下される~promise$( %e )
◎
An early error result for an exception e is a NavigationResult dictionary instance given by «[ "committed" → a promise rejected with e, "finished" → a promise rejected with e ]».
</p>
</div>

<div class="algo">
<p>
`~navi~API~method追跡子から導出される結果@
は、
所与の
( `~navi~API~method追跡子$ )
に対し
⇒
~RET  «[ 次に挙げる~entry ]» として与えられる `NavigationResult$I 辞書~instance
⇒＃
"`committed$mb" → %~API~method追跡子 の`~commit時の~promise$amT,
"`finished$mb" → %~API~method追跡子 の`完遂-時の~promise$amT
◎
A navigation API method tracker-derived result for a navigation API method tracker is a NavigationResult dictionary instance given by «[ "committed" → apiMethodTracker's committed promise, "finished" → apiMethodTracker's finished promise ]».
</p>
</div>

				</section>
				<section id="ongoing-navigation-tracking">
<h5 title="Ongoing navigation tracking">7.2.6.8. 進行中な~naviの追跡-法</h5>

<p>
（`種別を問わず＠#navigationtype$）
所与の~naviの間、
`Navigation$I ~objは，以下に挙げるものを追跡し続ける必要がある：
◎
During any given navigation (in the broad sense of the word), the Navigation object needs to keep track of the following:
</p>

<table class="_nav-tracking grid-table">
<caption>
すべての~navi用
◎
For all navigations
</caption>
<thead>
<tr><th>
状態
◎
State
<th>
追跡期間
◎
Duration
<th>
説明
◎
Explanation
<tbody>

<tr><td>
`NavigateEvent$I
◎
The NavigateEvent
<td>
~eventを発火している間
◎
For the duration of event firing
<td>
当の~eventを発火している間に当の~naviが取消された場合に，
当の~eventを`取消せる＠~DOM4#canceled-flag$ようにするため
◎
So that if the navigation is canceled while the event is firing, we can cancel the event
<tr><td>
~eventの`中止-制御器$nEv
◎
The event's abort controller
<td>
すべての`~navi~handler~promise$が決着するまで
◎
Until all promises returned from handlers passed to intercept() have settled
<td>
当の~naviが取消された場合に`中止-を通達できる＠~DOM4#abortcontroller-signal-abort$ようにするため
◎
So that if the navigation is canceled, we can signal abort

<tr><td>
新たに`~focusされ＠~HTMLinteraction#focusing-steps$た要素があるかどうか
◎
Whether a new element was focused
<td>
すべての`~navi~handler~promise$が決着するまで
◎
Until all promises returned from handlers passed to intercept() have settled
<td>
そのような要素がある場合、
`~focusを設定し直さない＠#potentially-reset-the-focus$ようにするため
◎
So that if one was, focus is not reset
<tr><td>
~navigateされている `NavigationHistoryEntry$I
◎
The NavigationHistoryEntry being navigated to
<td>
それが決定されたときから，
すべての`~navi~handler~promise$が決着するまで
◎
From when it is determined, until all promises returned from handlers passed to intercept() have settled
<td>
［
`committed$mb ／ `finished$mb
］~promise（もしあれば）を何で解決するか知るため
◎
So that we know what to resolve any committed and finished promises with
<tr><td>
返された `finished$mb ~promise（もしあれば）
◎
Any finished promise that was returned
<td>
すべての`~navi~handler~promise$が決着するまで
◎
Until all promises returned from handlers passed to intercept() have settled
<td>
それを適切に［
解決できる／却下できる
］ようにするため
◎
So that we can resolve or reject it appropriately
</table>

<table class="_nav-tracking grid-table">
<caption>
非- `traverse$l ~navi用
◎
For "traverse" navigationsState
</caption>
<thead>
<tr><th>
状態
◎
State
<th>
追跡期間
◎
Duration
<th>
説明
◎
Explanation
<tbody>

<tr><td>
`state$mbN
（もしあれば）
◎
Any state
<td>
~eventを発火している間
◎
For the duration of event firing
<td>
当の~event発火が`取消される＠~DOM4#canceled-flag$ことなく完遂した場合に，
現在の~entryの`~navi~API状態$shEを更新できるようにするため
◎
So that we can update the current entry's navigation API state if the event finishes firing without being canceled
</table>

<table class="_nav-tracking grid-table">
<caption>
`traverse$l ~navi用
◎
For "traverse" navigationsState
</caption>
<thead>
<tr><th>
状態
◎
State
<th>
追跡期間
◎
Duration
<th>
説明
◎
Explanation
<tbody>

<tr><td>
`info$mbN
（もしあれば）
◎
Any info
<td>
`navigate$et ~eventを発火する~taskが~queueされるまで
◎
Until the task is queued to fire the navigate event
<td>
当の`~session履歴~辿り~queue$navを巡った後に，
それを利用して `navigate$et を発火できるようにするため。
◎
So that we can use it to fire the navigate after the trip through the session history traversal queue.
<tr><td>
返された `committed$mb ~promise
（もしあれば）
◎
Any committed promise that was returned
<td>
（同じ~taskの内側で）
当の~session履歴が更新されるまで
◎
Until the session history is updated (inside that same task)
<td>
それを適切に［
解決できる／却下できる
］ようにするため
◎
So that we can resolve or reject it appropriately
<tr><td>
`intercept()$mE は~callされたかどうか
◎
Whether intercept() was called
<td>
（同じ~taskの内側で）
当の~session履歴が更新されるまで
◎
Until the session history is updated (inside that same task)
<td>
`scroll$mb ~optionに与えられた挙動が優先される場合に，通常の~scroll復旧~logicを抑止できるようにするため
◎
So that we can suppress the normal scroll restoration logic in favor of the behavior given by the scroll option
</table>

<p>
次のような~web開発者~codeに因り、［
所与の時点で要請された~naviは，一つしかない
］とは見做せない：
◎
We also cannot assume there is only a single navigation requested at any given time, due to web developer code such as:
</p>

<pre class="js-code">
const %p1 = navigation.navigate(%url1).finished;
const %p2 = navigation.navigate(%url2).finished;
</pre>

<p>
すなわち，この局面では、
%url2 へ~navigateしている間も［
~promise %p1 を却下できるよう， %p1 が居続ける
］ことを確保する必要がある。
2 度目の `navigate()$mN が~callされた時点で，
進行中な~navi用の~promiseを単に捨て置くわけにはいかない。
◎
That is, in this scenario, we need to ensure that while navigating to url2, we still have the promise p1 around so that we can reject it. We can't just get rid of any ongoing navigation promises the moment the second call to navigate() happens.
</p>

<p>
これをすべて成遂げるため、
各 `Navigation$I には，次に挙げるものを結付けることになった：
◎
We end up accomplishing all this by associating the following with each Navigation:
</p>
<ul>
	<li>
`進行中な~navigate_ev~event@
⇒
`NavigateEvent$I ／ ~NULL
— 初期~時は ~NULL とする。
◎
Ongoing navigate event, a NavigateEvent or null, initially null.
</li>
	<li>
`進行中な~naviの間に~focusは変化したか@
⇒
真偽値
— 初期~時は ~F とする。
◎
Focus changed during ongoing navigation, a boolean, initially false.
</li>
	<li>
`進行中な~naviの間は通常の~scroll復旧を抑止するか@
⇒
真偽値
— 初期~時は ~F とする。
◎
Suppress normal scroll restoration during ongoing navigation, a boolean, initially false.
</li>
	<li>
`進行中な~API~method追跡子@
⇒
`~navi~API~method追跡子$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
Ongoing API method tracker, a navigation API method tracker or null, initially null.
</li>
	<li>
`来たる非-辿-~API~method追跡子@
⇒
`~navi~API~method追跡子$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
Upcoming non-traverse API method tracker, a navigation API method tracker or null, initially null.
</li>
	<li>
`来たる辿-~API~method追跡子~群@
⇒
文字列から`~navi~API~method追跡子$への`有順序~map$
— 初期~時は空とする。
◎
Upcoming traverse API method trackers, an ordered map from strings to navigation API method trackers, initially empty.
</li>
</ul>

<p class="note">注記：
ここに挙げた状態のうち［
`~navi~API~method追跡子$内に格納されないもの
］は、［
~navi~API~methodを介して起動されたもの以外の~navi
］用にも，追跡する必要があるものである。
◎
The state here that is not stored in navigation API method trackers is state which needs to be tracked even for navigations that are not initiated via navigation API methods.
</p>

<p>
`~navi~API~method追跡子@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A navigation API method tracker is a struct with the following items:
</p>
<ul>
	<li>
`~navi~obj@amT
⇒
`Navigation$I
◎
A navigation object, a Navigation
</li>
	<li>
`~key@amT
⇒
文字列／~NULL
◎
A key, a string or null
</li>
	<li>
`報@amT
⇒
~JS値
◎
An info, a JavaScript value
</li>
	<li>
`直列形の状態@amT
⇒
`直列形の状態$／~NULL
◎
A serialized state, a serialized state or null
</li>
	<li>
<p>
`~commit先~entry@amT
⇒
`NavigationHistoryEntry$I ／ ~NULL
</p>

<p class="trans-note">【
~NULL でないならば、
新たに`~naviの現在の~entry$になる`~navi履歴~entry$を表現する。
】</p>
◎
A committed-to entry, a NavigationHistoryEntry or null
</li>
	<li>
<p>
`~commit時の~promise@amT
⇒
~promise
</p>

<p class="trans-note">【
これは、
却下されないならば，~commit先~entryで解決されることになる。
`完遂-時の~promise$amTが決着したときも，
それ伴い（まだ決着していないならば）決着することになる。
】</p>
◎
A committed promise, a promise
</li>
	<li>
<p>
`完遂-時の~promise@amT
⇒
~promise
</p>

<p class="trans-note">【
~naviが “完遂した” ときに決着する~promise。
】</p>
◎
A finished promise, a promise
</li>
</ul>

<p>
これらすべての状態は、
以下に与える~algoたちを介して管理される。
◎
All this state is then managed via the following algorithms.
</p>

<div class="algo">
<p>
`来たる非-辿-~API~method追跡子を必要なら設定する@
ときは、
所与の
⇒＃
`Navigation$I %~navi,
~JS値 %報,
［ `直列形の状態$ ／ ~NULL ］ %直列形の状態
◎終
に対し：
◎
To maybe set the upcoming non-traverse API method tracker given a Navigation navigation, a JavaScript value info, and a serialized state-or-null serializedState:
</p>
<ol>
	<li>
%~commit時の~promise ~LET `新たな~promise$( %~navi に`関連な~realm$ )
◎
Let committedPromise and＼
</li>
	<li>
%完遂-時の~promise ~LET `新たな~promise$( %~navi に`関連な~realm$ )
◎
finishedPromise be new promises created in navigation's relevant realm.
</li>
	<li>
<p>
`~promiseを取扱済みとして~markする$( %完遂-時の~promise )
◎
Mark as handled finishedPromise.
</p>

<div class="note">
<p id="note-mark-as-handled-navigation-api-finished">
~web開発者は、
%完遂-時の~promise が却下されることについて~careするとは限らない：
◎
The web developer doesn’t necessarily care about finishedPromise being rejected:
</p>
		<ul>
			<li>
開発者は、
%~commit時の~promise に限り~careするかもしれない。
◎
They might only care about committedPromise.
</li>
			<li>
開発者は、
同じ~taskの中で複数の~naviを同期的に行うこともある。
その事例では、
最後の~navi以外は，すべて中止される（それらの %完遂-時の~promise を却下させる）ことになる。
これは、
~appの~bugである場合もあろうが，単に当の~appを成す［
互いの動作を上書きしている異種な各部
］を成す創発的な特能である場合もある。
◎
They could be doing multiple synchronous navigations within the same task, in which case all but the last will be aborted (causing their finishedPromise to reject). This could be an application bug, but also could just be an emergent feature of disparate parts of the application overriding each others' actions.
</li>
			<li>
開発者は、［
遷移の失敗についての通達を %完遂-時の~promise 以外のもので~listenする
］ことを選好することもあろう
— 例
⇒＃
`navigateerror$et ~event／
`navigation.transition.finished$c が返す~promise
◎
They might prefer to listen to other transition-failure signals instead of finishedPromise, e.g., the navigateerror event, or the navigation.transition.finished promise.
</li>
		</ul>
<p>
そのようなわけで、
%完遂-時の~promise を
— それが `unhandledrejection$et ~eventを決して誘発しないよう —
取扱済みとして~markすることを確保する。
◎
As such, we mark it as handled to ensure that it never triggers unhandledrejection events.
</p>
</div>
	</li>
	<li>
%~API~method追跡子 ~LET 新たな`~navi~API~method追跡子$
— その
⇒＃
`~navi~obj$amT ~SET %~navi,
`~key$amT ~SET ~NULL,
`報$amT ~SET %報,
`直列形の状態$amT ~SET %直列形の状態,
`~commit先~entry$amT ~SET ~NULL,
`~commit時の~promise$amT ~SET %~commit時の~promise,
`完遂-時の~promise$amT ~SET %完遂-時の~promise
◎
Let apiMethodTracker be a new navigation API method tracker with:
◎
navigation object
• navigation
key
• null
info
• info
serialized state
• serializedState
comitted-to entry
• null
comitted promise
• committedPromise
finished promise
• finishedPromise
</li>
	<li>
~Assert：
%~navi の`来たる非-辿-~API~method追跡子$ ~EQ ~NULL
◎
Assert: navigation's upcoming non-traverse API method tracker is null.
</li>
	<li id="dont-always-set-upcoming-non-traverse-api-method-tracker">
<p>
~IF［
%~navi の`~entryや~eventは不能化されて$いない
］
⇒
%~navi の`来たる非-辿-~API~method追跡子$ ~SET %~API~method追跡子
◎
If navigation does not have entries and events disabled, then set navigation's upcoming non-traverse API method tracker to apiMethodTracker.
</p>

<div class="note">
<p>注記：
%~navi の`~entryや~eventは不能化されて$いる場合：
◎
If navigation has entries and events disabled, then＼
</p>
		<ul>
			<li>
［
%~commit時の~promise, %完遂-時の~promise
］は決して充足されなくなる
（そのような`文書$用には、
`NavigationHistoryEntry$I ~objは決して作成されないので，それらを解決するものも無い）
◎
committedPromise and finishedPromise will never fulfill (since we never create a NavigationHistoryEntry object for such Documents, and so we have nothing to resolve them with);＼
</li>
			<li>
%直列形の状態 を適用する `NavigationHistoryEntry$I は無い。
◎
there is no NavigationHistoryEntry to apply serializedState to;＼
</li>
			<li>
%報 を含める `navigate$et ~eventは無い。
◎
and there is no navigate event to include info with.＼
</li>
		</ul>
<p>
なので、
結局，この~API~method~callを追跡する必要も無くなる。
◎
So, we don't need to track this API method call after all.
</p>
</div>
	</li>
	<li>
~RET %~API~method追跡子
◎
Return apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`来たる辿-~API~method追跡子を追加する@
ときは、
所与の
( `Navigation$I %~navi, 文字列 %行先~key, ~JS値 %報 )
に対し：
◎
To add an upcoming traverse API method tracker given a Navigation navigation, a string destinationKey, and a JavaScript value info:
</p>
<ol>
	<li>
%~commit時の~promise ~LET `新たな~promise$( %~navi に`関連な~realm$ )
◎
Let committedPromise and＼
</li>
	<li>
%完遂-時の~promise ~LET `新たな~promise$( %~navi に`関連な~realm$ )
◎
finishedPromise be new promises created in navigation's relevant realm.
</li>
	<li>
<p>
`~promiseを取扱済みとして~markする$( %完遂-時の~promise )
◎
Mark as handled finishedPromise.
</p>

<p class="note">注記：
なぜこれを行うかについては、
`上の論点＠#note-mark-as-handled-navigation-api-finished$を見よ。
◎
See the previous discussion about why this is done.
</p>
	</li>
	<li>
%~API~method追跡子 ~LET 新たな`~navi~API~method追跡子$
— その
⇒＃
`~navi~obj$amT ~SET %~navi,
`~key$amT ~SET %行先~key,
`報$amT ~SET %報,
`直列形の状態$amT ~SET ~NULL,
`~commit先~entry$amT ~SET ~NULL,
`~commit時の~promise$amT ~SET %~commit時の~promise,
`完遂-時の~promise$amT ~SET %完遂-時の~promise
◎
Let apiMethodTracker be a new navigation API method tracker with:
◎
navigation object
• navigation
key
• destinationKey
info
• info
serialized state
• null
comitted-to entry
• null
comitted promise
• committedPromise
finished promise
• finishedPromise
</li>
	<li>
%~navi の`来たる辿-~API~method追跡子~群$[ %~key ] ~SET %~API~method追跡子
◎
Set navigation's upcoming traverse API method trackers[key] to apiMethodTracker.
</li>
	<li>
~RET %~API~method追跡子
◎
Return apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`来たる~API~method追跡子を進行中にする@
ときは、
所与の
( `Navigation$I %~navi, ［
文字列 ／ ~NULL
］ %行先~key )
に対し：
◎
To promote an upcoming API method tracker to ongoing given a Navigation navigation and a string-or-null destinationKey:
</p>
<ol>
	<li>
~Assert：
%~navi の`進行中な~API~method追跡子$ ~EQ ~NULL
◎
Assert: navigation's ongoing API method tracker is null.
</li>
	<li>
<p>
~IF［
%行先~key ~NEQ ~NULL
］：
◎
If destinationKey is not null, then:
</p>
		<ol>
			<li>
~Assert：
%~navi の`来たる非-辿-~API~method追跡子$ ~EQ ~NULL
◎
Assert: navigation's upcoming non-traverse API method tracker is null.
</li>
			<li>
<p>
~IF［
%~navi の`来たる辿-~API~method追跡子~群$[ %行先~key ] ~NEQ ε
］：
◎
If navigation's upcoming traverse API method trackers[destinationKey] exists, then:
</p>
				<ol>
					<li>
%~navi の`進行中な~API~method追跡子$ ~SET %~navi の`来たる辿-~API~method追跡子~群$[ %行先~key ]
◎
Set navigation's ongoing API method tracker to navigation's upcoming traverse API method trackers[destinationKey].
</li>
					<li>
%~navi の`来たる辿-~API~method追跡子~群$[ %行先~key ] ~SET ε
◎
Remove navigation's upcoming traverse API method trackers[destinationKey].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~navi の`進行中な~API~method追跡子$ ~SET %~navi の`来たる非-辿-~API~method追跡子$
◎
Set navigation's ongoing API method tracker to navigation's upcoming non-traverse API method tracker.
</li>
			<li>
%~navi の`来たる非-辿-~API~method追跡子$ ~SET ~NULL
◎
Set navigation's upcoming non-traverse API method tracker to null.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`追跡子を片付ける@
ときは、
所与の
( `~navi~API~method追跡子$ %~API~method追跡子 )
に対し：
◎
To clean up a navigation API method tracker apiMethodTracker:
</p>
<ol>
	<li>
%~navi ~LET %~API~method追跡子 の`~navi~obj$amT
◎
Let navigation be apiMethodTracker's navigation object.
</li>
	<li>
~IF［
%~navi の`進行中な~API~method追跡子$ ~EQ %~API~method追跡子
］
⇒
%~navi の`進行中な~API~method追跡子$ ~SET ~NULL
◎
If navigation's ongoing API method tracker is apiMethodTracker, then set navigation's ongoing API method tracker to null.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~key ~LET %~API~method追跡子 の`~key$amT
◎
Let key be apiMethodTracker's key.
</li>
			<li>
~Assert：
%~key ~NEQ ~NULL
◎
Assert: key is not null.
</li>
			<li>
~Assert：
%~navi の`来たる辿-~API~method追跡子~群$[ %~key ] ~NEQ ε
◎
Assert: navigation's upcoming traverse API method trackers[key] exists.
</li>
			<li>
%~navi の`来たる辿-~API~method追跡子~群$[ %~key ] ~SET ε
◎
Remove navigation's upcoming traverse API method trackers[key].
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~commit先~entryについて通知する@
ときは、
所与の
⇒＃
`~navi~API~method追跡子$ %~API~method追跡子
`NavigationHistoryEntry$I %~NHE
◎終
に対し：
◎
To notify about the committed-to entry given a navigation API method tracker apiMethodTracker and a NavigationHistoryEntry nhe:
</p>
<ol>
	<li>
%~API~method追跡子 の`~commit先~entry$amT ~SET %~NHE
◎
Set apiMethodTracker's committed-to entry to nhe.
</li>
	<li>
<p>
~IF［
%~API~method追跡子 の`直列形の状態$amT ~NEQ ~NULL
］
⇒
%~NHE の`~session履歴~entry$nheの`~navi~API状態$shE ~SET %~API~method追跡子 の`直列形の状態$amT
◎
If apiMethodTracker's serialized state is not null, then set nhe's session history entry's navigation API state to apiMethodTracker's serialized state.
</p>

<p class="note">注記：
~NULL の場合、
`navigation.traverseTo()$c を介して %~NHE へ辿っている
— その場合、
状態を変更することは許容されない。
◎
If it's null, then we're traversing to nhe via navigation.traverseTo(), which does not allow changing the state.
</p>

<p class="note">注記：
この時点で、
%~API~method追跡子 の`直列形の状態$amTは，もはや必要なくなる
— 実装は、
`~navi~API~method追跡子$が存続する限り それが生存し続けないよう，
それを~clearしたいと求めることもあろう。
◎
At this point, apiMethodTracker's serialized state is no longer needed. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the navigation API method tracker.
</p>
	</li>
	<li>
<p>
`~promiseを解決する$( %~API~method追跡子 の`~commit時の~promise$amT, %~NHE )
◎
Resolve apiMethodTracker's committed promise with nhe.
</p>

<p class="note">注記：
この時点で、
%~API~method追跡子 の`~commit時の~promise$amTが必要になるのは，
それが まだ作者~codeへ返されてない事例に限られる。
実装は、
`~navi~API~method追跡子$が存続する限り それが生存し続けないよう，
それを~clearしたいと求めることもあろう。
◎
At this point, apiMethodTracker's committed promise is only needed in cases where it has not yet been returned to author code. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the navigation API method tracker.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`完遂-時の~promiseを解決する@
ときは、
所与の
( `~navi~API~method追跡子$ %~API~method追跡子 )
に対し：
◎
To resolve the finished promise for a navigation API method tracker apiMethodTracker:
</p>
<ol>
	<li>
%~commit先~entry ~LET %~API~method追跡子 の`~commit先~entry$amT
◎
↓</li>
	<li>
<p>
`~promiseを解決する$( %~API~method追跡子 の`~commit時の~promise$amT, %~commit先~entry )
◎
Resolve apiMethodTracker's committed promise with its committed-to entry.
</p>

<p class="note">注記：
通例的には、
ここまでに %~API~method追跡子 に対し`~commit先~entryについて通知する$が~callされるので，これは何もしないことになる。
しかしながら，`完遂-時の~promiseを解決する$が直に~callされる事例もあり、
その事例では，この段が必要yである。
◎
Usually, notify about the committed-to entry has previously been called on apiMethodTracker, and so this will do nothing. However, in some cases resolve the finished promise is called directly, in which case this step is necessary.
</p>
	</li>
	<li>
`~promiseを解決する$( %~API~method追跡子 の`完遂-時の~promise$amT, %~commit先~entry )
◎
Resolve apiMethodTracker's finished promise with its committed-to entry.
</li>
	<li>
`追跡子を片付ける$( %~API~method追跡子 )
◎
Clean up apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`完遂-時の~promiseを却下する@
ときは、
所与の
( `~navi~API~method追跡子$ %~API~method追跡子, ~JS値 %例外 )
に対し：
◎
To reject the finished promise for a navigation API method tracker apiMethodTracker with a JavaScript value exception:
</p>
<ol>
	<li>
<p>
`~promiseを却下する$( %~API~method追跡子 の`~commit時の~promise$amT, %例外 )
◎
Reject apiMethodTracker's committed promise with exception.
</p>

<p class="note">注記：
これは、
ここまでに［
%~API~method追跡子 の`~commit時の~promise$amTが
`~commit先~entryについて通知する$ことを介して解決された
］場合には，何もしないことになる。
◎
This will do nothing if apiMethodTracker's committed promise was previously resolved via notify about the committed-to entry.
</p>
	</li>
	<li>
`~promiseを却下する$( %~API~method追跡子 の`完遂-時の~promise$amT, %例外 )
◎
Reject apiMethodTracker's finished promise with exception.
</li>
	<li>
`追跡子を片付ける$( %~API~method追跡子 )
◎
Clean up apiMethodTracker.
</li>
</ol>
</div>

<div class="algo">
<p>
`進行中な~naviを中止する@
ときは、
所与の
( `Navigation$I %~navi, `DOMException$I %~error （省略時は ε ） )
に対し：
◎
To abort the ongoing navigation given a Navigation navigation and an optional DOMException error:
</p>
<ol>
	<li>
%~event ~LET %~navi の`進行中な~navigate_ev~event$
◎
Let event be navigation's ongoing navigate event.
</li>
	<li>
~Assert：
%~event ~NEQ ~NULL
◎
Assert: event is not null.
</li>
	<li>
%~navi の`進行中な~naviの間に~focusは変化したか$ ~SET ~F
◎
Set navigation's focus changed during ongoing navigation to false.
</li>
	<li>
%~navi の`進行中な~naviの間は通常の~scroll復旧を抑止するか$ ~SET ~F
◎
Set navigation's suppress normal scroll restoration during ongoing navigation to false.
</li>
	<li>
~IF［
%~error ~EQ ε
］
⇒
%~error ~SET %~navi に`関連な~realm$内に作成される新たな `AbortError$E 例外
◎
If error was not given, then let error be a new "AbortError" DOMException created in navigation's relevant realm.
</li>
	<li>
~IF［
%~event の`配送-中か$ev ~EQ ~T
］
⇒
%~event の`取消されたか$ev ~SET ~T
◎
If event's dispatch flag is set, then set event's canceled flag to true.
</li>
	<li>
`中止-を通達する$aC( %~event の`中止-制御器$nEv, %~error )
◎
Signal abort on event's abort controller given error.
</li>
	<li>
%~navi の`進行中な~navigate_ev~event$ ~SET ~NULL
◎
Set navigation's ongoing navigate event to null.
</li>
	<li>
%~error報 ~LET `~error情報を抽出する$( %~error )
◎
Let errorInfo be the result of extracting error information from error.
</li>
	<li>
<p>
`~eventを発火する$( %~navi, `navigateerror$et, `ErrorEvent$I )
— 次のように初期化して
⇒＃
`ErrorEvent$I による追加的な各~属性を %~error報 に則って設定する
</p>

<div class="note">
<p>注記：
これらの属性【！~prop】は：
</p>
		<ul>
			<li>
例えば `window.stop()＠~WINDOW#dom-window-stop$c を~callしたことにより，この~algoに達した場合、
おそらく［
~scriptを成す `window.stop()＠~WINDOW#dom-window-stop$c を~callした行l
］に基づいて初期化される。
</li>
			<li>
一方で、
利用者が停止-~buttonを~clickしたことにより，この~algoに達した場合、
おそらく，［
空~文字列 や 0 の様な既定の値
］に初期化される。
</li>
		</ul>
</div>

◎
For example, if this algorithm is reached because of a call to window.stop(), these properties would probably end up initialized based on the line of script that called window.stop().＼
But if it's because the user clicked the stop button, these properties would probably end up with default values like the empty string or 0.
◎
Fire an event named navigateerror at navigation using ErrorEvent, with additional attributes initialized according to errorInfo.
</li>
	<li>
~IF［
%~navi の`進行中な~API~method追跡子$ ~NEQ ~NULL
］
⇒
`完遂-時の~promiseを却下する$( %~API~method追跡子, %~error )
◎
If navigation's ongoing API method tracker is non-null, then reject the finished promise for apiMethodTracker with error.
</li>
	<li>
<p>
~IF［
%~navi の`遷移$ ~NEQ ~NULL
］：
◎
If navigation's transition is not null, then:
</p>
		<ol>
			<li>
`~promiseを却下する$( %~navi の`遷移$の`完遂-時の~promise$nTr, %~error )
◎
Reject navigation's transition's finished promise with error.
</li>
			<li>
%~navi の`遷移$ ~SET ~NULL
◎
Set navigation's transition to null.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~naviを中止したことについて~navi~APIに伝える@
ときは、
所与の
( `~navigable$ %~navigable )
に対し：
◎
To inform the navigation API about aborting navigation in a navigable navigable:
</p>
<ol>
	<li>
%~window ~LET %~navigable にて`作動中な~window$nav
◎
↓</li>
	<li>
~IF［
この~algoは %~window に`関連な~agent$の`~event~loop$aG上で走っている
］
⇒
下に与える `中止-用の手続き^i()
◎
If this algorithm is running on navigable's active window's relevant agent's event loop, then continue on to the following steps.＼
</li>
	<li>
<p>
~ELSE
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~window, 下に与える `中止-用の手続き^i )
◎
Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to run the following steps.
</p>
	</li>
</ol>

<div class="algo">
<p>
上で利用される `中止-用の手続き^i は：
◎
↑</p>
<ol>
	<li>
%~navi ~LET %~navigable にて`作動中な~window$nav の`~navi~API$
◎
Let navigation be navigable's active window's navigation API.
</li>
	<li>
~IF［
%~navi の`進行中な~navigate_ev~event$ ~EQ ~NULL
］
⇒
~RET
◎
If navigation's ongoing navigate event is null, then return.
</li>
	<li>
`進行中な~naviを中止する$( %~navi )
◎
Abort the ongoing navigation given navigation.
</li>
</ol>
</div>
</div>

<div class="algo">
<p>
`子~navigableの破壊について~navi~APIに伝える@
ときは、
所与の
( `~navigable$ %~navigable )
に対し：
◎
To inform the navigation API about child navigable destruction given a navigable navigable:
</p>
<ol>
	<li>
`~naviを中止したことについて~navi~APIに伝える$( %~navigable )
◎
Inform the navigation API about aborting navigation in navigable.
</li>
	<li>
%~navi ~LET %~navigable にて`作動中な~window$nav の`~navi~API$
◎
Let navigation be navigable's active window's navigation API.
</li>
	<li>
%辿り~API~method追跡子~群 ~LET %~navi の`来たる辿-~API~method追跡子~群$を`~cloneする$
◎
Let traversalAPIMethodTrackers be a clone of navigation's upcoming traverse API method trackers.
</li>
	<li>
%辿り~API~method追跡子~群 を成す
~EACH( %~API~method追跡子 )
に対し
⇒
`完遂-時の~promiseを却下する$( %~API~method追跡子, %~navi に`関連な~realm$内に作成される新たな `AbortError$E 例外 )
◎
For each apiMethodTracker of traversalAPIMethodTrackers: reject the finished promise for apiMethodTracker with a new "AbortError" DOMException created in navigation's relevant realm.
</li>
</ol>
</div>

<hr>

<p>
進行中な~naviの概念は、
~web開発者には，
`navigation.transition$c ~propを通して最も直に公開される
— それは、
【当の~naviの`遷移$を表現する】
`NavigationTransition$I ~interfaceの~instanceである：
◎
The ongoing navigation concept is most-directly exposed to web developers through the navigation.transition property, which is an instance of the NavigationTransition interface:
</p>

<pre class="idl">
[Exposed=Window]
interface `NavigationTransition@I {
  readonly attribute `NavigationType$I `navigationType$mT;
  readonly attribute `NavigationHistoryEntry$I `from$mT;
  readonly attribute `Promise$&lt;undefined&gt; `finished$mT;
};
</pre>

<dl class="domintro">
	<dt>`navigation$m.`transition$mN</dt>
	<dd>
［
`navigatesuccess$et ／ `navigateerror$et
］を発火する段階にまだ達してない進行中な~naviを表現している `NavigationTransition$I
— そのような`遷移$は進行中でないならば， ~NULL 。
◎
A NavigationTransition representing any ongoing navigation that hasn't yet reached the navigatesuccess or navigateerror stage, if one exists; or null, if there is no such transition ongoing.
</dd>
	<dd>
`navigation.currentEntry$c
（および `location.href＠~WINDOW#dom-location-href$c の様な他の~prop）
は，~naviの際に即時に更新されるので、
`navigation.transition$c ~propは、
そのような~naviが［
【！navigateEvent.intercept()に渡された~handlerたち】
`~navi~handler~promise$たち（もしあれば）に則って，まだ全部的に決着していないとき
］を決定するために有用になる。
◎
Since navigation.currentEntry (and other properties like location.href) are updated immediately upon navigation, this navigation.transition property is useful for determining when such navigations are not yet fully settled, according to any handlers passed to navigateEvent.intercept().
</dd>

	<dt>`navigation$m.`transition$mN.`navigationType$mT</dt>
	<dd>
この`遷移$の種別を指示する文字列を次に挙げるいずれかとして返す
⇒＃
`push$l ／
`replace$l ／
`reload$l ／
`traverse$l
◎
One of "push", "replace", "reload", or "traverse", indicating what type of navigation this transition is for.
</dd>

	<dt>`navigation$m.`transition$mN.`from$mT</dt>
	<dd>
この遷移が どの~entryから来ているかを表す `NavigationHistoryEntry$I を返す。
これは、
`navigation.currentEntry$c と比較するときに有用になり得る。
◎
The NavigationHistoryEntry from which the transition is coming. This can be useful to compare against navigation.currentEntry.
</dd>

	<dt>`navigation$m.`transition$mN.`finished$mT</dt>
	<dd>
［
`navigatesuccess$et ／ `navigateerror$et 
］~eventの発火と同時に［
充足される／却下される
］~promise。
◎
A promise which fulfills at the same time as the navigatesuccess fires, or rejects at the same time the navigateerror event fires.
</dd>
</dl>

<p>
各 `Navigation$I には
`遷移@
が結付けられる
— それは、［
`NavigationTransition$I ／ ~NULL
］であり，初期~時は ~NULL とする。
◎
Each Navigation has a transition, which is a NavigationTransition or null, initially null.
</p>

<div class="algo">
`transition@mN
取得子~手続きは
⇒
~RET コレの`遷移$
◎
The transition getter steps are to return this's transition.
</div>

<p>
各 `NavigationTransition$I には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`~navi種別@nTr
⇒
`NavigationType$I
◎
Each NavigationTransition has an associated navigation type, which is a NavigationType.
</li>
	<li>
`~from~entry@nTr
⇒
`NavigationHistoryEntry$I
◎
Each NavigationTransition has an associated from entry, which is a NavigationHistoryEntry.
</li>
	<li>
`完遂-時の~promise@nTr
⇒
~promise
◎
Each NavigationTransition has an associated finished promise, which is a promise.
</li>
</ul>

<div class="algo">
`navigationType@mT
取得子~手続きは
⇒
~RET コレの`~navi種別$nTr
◎
The navigationType getter steps are to return this's navigation type.
</div>

<div class="algo">
`from@mT
取得子~手続きは
⇒
~RET コレの`~from~entry$nTr
◎
The from getter steps are to return this's from entry.
</div>

<div class="algo">
`finished@mT
取得子~手続きは
⇒
~RET コレの`完遂-時の~promise$nTr
◎
The finished getter steps are to return this's finished promise.
</div>

				</section>
				<section id="navigation-activation-interface">
<h5 title="The NavigationActivation interface">7.2.6.9. `NavigationActivation^I ~interface</h5>

<pre class="idl">[Exposed=Window]
interface `NavigationActivation@I {
  readonly attribute `NavigationHistoryEntry$I? `from$mNA;
  readonly attribute `NavigationHistoryEntry$I `entry$mNA;
  readonly attribute `NavigationType$I `navigationType$mNA;
};
</pre>

<dl class="domintro">
	<dt>`navigation$m.`activation$mN</dt>
	<dd>
［
現在の`文書$【！this Document】を “作動化した” 最も近過去な非同一-文書~navi
］についての情報を包含している `NavigationActivation$I を返す。
◎
A NavigationActivation containing information about the most recent cross-document navigation, the navigation that "activated" this Document.
</dd>
	<dd>
［
`currentEntry$mN, 当の`文書$の`~URL$doc
］は，同一-文書~naviに因り常時~更新され得る一方で、
`activation$mN は一定であり続け，
その各~propは当の`文書$が履歴から`作動化し直され＠~HTMLnav#reactivate-a-document$た場合に限り更新される。
◎
While navigation.currentEntry and the Document's URL can be updated regularly due to same-document navigations, navigation.activation stays constant, and its properties are only updated if the Document is reactivated from history.
</dd>

	<dt>`navigation$m.`activation$mN.`entry$mNA</dt>
	<dd>
現在の`文書$【！the Document】が作動化された時点における `currentEntry$mN ~propの値に等価な `NavigationHistoryEntry$I を返す。
◎
A NavigationHistoryEntry, equivalent to the value of the navigation.currentEntry property at the moment the Document was activated.
</dd>

	<dt>`navigation$m.`activation$mN.`from$mNA</dt>
	<dd>
現在の`文書$の直前に作動中であった`文書$が［
次を満たしていたならば それを表現している `NavigationHistoryEntry$I ／
~ELSE_ ~NULL
］を返す
⇒
［
現在の文書と`同一-生成元$である
］~AND［
その`初期~about_blankか$doc ~EQ ~F
］
◎
A NavigationHistoryEntry, representing the Document that was active right before the current Document. This will have a value null in case the previous Document was not same origin with this one or if it was the initial about:blank Document.
</dd>
	<dd>
［
`from$mNA ／ `entry$mNA
］が返す `NavigationHistoryEntry$I ~obj【が表現する`~navi履歴~entry$】は、
履歴~内に維持されない事例もある
— その場合、
`traverseTo()$mN ~method用の~targetになり得ない。
例えば，
当の`文書$は `location.replace()＠#dom-location-replace$c を利用して作動化され得る／
履歴の初期~entryは `history.replaceState()＠#dom-history-replacestate$c により置換することもできる。
それでも、
それらの~entryの［
`url$mH ~prop, `getState()$mH ~method
］は~access可能になる。
◎
There are some cases in which either the from or entry NavigationHistoryEntry objects would not be viable targets for the traverseTo() method, as they might not be retained in history. For example, the Document can be activated using location.replace() or its initial entry could be replaced by history.replaceState(). However, those entries' url property and getState() method are still accessible.
</dd>

	<dt>`navigation$m.`activation$mN.`navigationType$mNA</dt>
	<dd>
現在の`文書$【！this Document】を作動化した~naviの種別を次に挙げるいずれかとして指示する
⇒＃
`push$l,
`replace$l,
`reload$l,
`traverse$l
◎
One of "push", "replace", "reload", or "traverse", indicating what type of navigation activated this Document.
</dd>
</dl>

<p>
各 `Navigation$I には
`作動化@
が結付けられる
— それは、［
~NULL ／ `NavigationActivation$I ~obj
］であり，初期~時は~NULLとする。
◎
Each Navigation has an associated activation, which is null or a NavigationActivation object, initially null.
</p>

<p>
各 `NavigationActivation$I は、
次に挙げるものを有する：
◎
Each NavigationActivation has:
</p>
<ul>
	<li>
`旧-~entry@nA
⇒
~NULL ／ ある `NavigationHistoryEntry$I
◎
old entry, null or a NavigationHistoryEntry.
</li>
	<li>
`新-~entry@nA
⇒
~NULL ／ ある `NavigationHistoryEntry$I
◎
new entry, null or a NavigationHistoryEntry.
</li>
	<li>
`~navi種別@nA
⇒
ある `NavigationType$I
◎
navigation type, a NavigationType.
</li>
</ul>

<div class="algo">
`activation@mN
取得子~手続きは
⇒
~RET コレの`作動化$
◎
The activation getter steps are to return this's activation.
</div>

<div class="algo">
`from@mNA
取得子~手続きは
⇒
~RET コレの`旧-~entry$nA
◎
The from getter steps are to return this's old entry.
</div>

<div class="algo">
`entry@mNA
取得子~手続きは
⇒
~RET コレの`新-~entry$nA
◎
The entry getter steps are to return this's new entry.
</div>

<div class="algo">
`navigationType@mNA
取得子~手続きは
⇒
~RET コレの`~navi種別$nA
◎
The navigationType getter steps are to return this's navigation type.
</div>

				</section>
				<section id="the-navigate-event">
<h5 title="The navigate event">7.2.6.10. `navigate^et ~event</h5>

<p>
~navi~APIを成す主要な特能は、
`navigate$et ~eventである。
この~eventは、
（`種別を問わず＠#navigationtype$）
どの~naviに対しても発火され，
外へ行く~naviを監視することを~web開発者に許容する。
多くの事例では、
この~eventの `cancelable$m は ~T （取消-可能）であり，
当の~naviが起こるのを防止することを許容する。
他の事例においては、
当の~naviを `NavigateEvent$I ~classの `intercept()$mE ~methodを利用して横取することで，同一-文書への~naviに置換できる。
◎
A major feature of the navigation API is the navigate event. This event is fired on any navigation (in the broad sense of the word), allowing web developers to monitor such outgoing navigations. In many cases, the event is cancelable, which allows preventing the navigation from happening. And in others, the navigation can be intercepted and replaced with a same-document navigation by using the intercept() method of the NavigateEvent class.
</p>

					<section id="the-navigateevent-interface">
<h6 title="The NavigateEvent interface">7.2.6.10.1. `NavigateEvent^I ~interface</h6>

<pre class="idl">
[Exposed=Window]
interface `NavigateEvent@I : `Event$I {
  constructor(DOMString type, `NavigateEventInit$I eventInitDict);

  readonly attribute `NavigationType$I `navigationType$mE;
  readonly attribute `NavigationDestination$I `destination$mE;
  readonly attribute boolean `canIntercept$mE;
  readonly attribute boolean `userInitiated$mE;
  readonly attribute boolean `hashChange$mE;
  readonly attribute `AbortSignal$I `signal$mE;
  readonly attribute `FormData$I? `formData$mE;
  readonly attribute DOMString? `downloadRequest$mE;
  readonly attribute any `info$mE;
  readonly attribute boolean `hasUAVisualTransition$mE;

  undefined `intercept$mE(optional `NavigationInterceptOptions$I options = {});
  undefined `scroll$mE();
};

dictionary `NavigateEventInit@I : `EventInit$I {
  `NavigationType$I `navigationType@mb = `push$l;
  required `NavigationDestination$I `destination@mb;
  boolean `canIntercept@mb = false;
  boolean `userInitiated@mb = false;
  boolean `hashChange@mb = false;
  required `AbortSignal$I `signal@mb;
  `FormData$I? `formData@mb = null;
  DOMString? `downloadRequest@mb = null;
  any `info@mb;
  boolean `hasUAVisualTransition@mb = false;
};

dictionary `NavigationInterceptOptions@I {
  `NavigationInterceptHandler$I `handler@mb;
  `NavigationFocusReset$I `focusReset@mb;
  `NavigationScrollBehavior$I `scroll@mb;
};

enum `NavigationFocusReset@I {
  `after-transition@lF,
  `manual@lF
};

enum `NavigationScrollBehavior@I {
  `after-transition@lS,
  `manual@lS
};

callback `NavigationInterceptHandler@I = `Promise$&lt;undefined&gt; ();
</pre>

<dl class="domintro">
	<dt>%event.`navigationType$mE</dt>
	<dd>
当の~naviの種別を指示する文字列を次に挙げるいずれかとして返す
⇒＃
`push$l ／
`replace$l ／
`reload$l ／
`traverse$l
◎
One of "push", "replace", "reload", or "traverse", indicating what type of navigation this is.
</dd>

	<dt>%event.`destination$mE</dt>
	<dd>
当の~naviの行先を表現している `NavigationDestination$I を返す。
◎
A NavigationDestination representing the destination of the navigation.
</dd>

	<dt>%event.`canIntercept$mE</dt>
	<dd>
この~naviを横取できる
— `intercept()$mE を~callすることにより、
同一-文書への~naviに変換して，通例的な挙動を置換できる —
場合、
~T になる。
他の場合、
~F になる。
◎
True if intercept() can be called to intercept this navigation and convert it into a same-document navigation, replacing its usual behavior; false otherwise.
</dd>
	<dd>
これは，一般的に言えば
— すなわち、
現在の`文書$の~URLを行先~URLに`書直せる＠~WINDOW#can-have-its-url-rewritten$ときは —
~T になる。
ただし、
非同一-文書への `traverse$l ~naviの事例では，
常に ~F になる。
◎
Generally speaking, this will be true whenever the current Document can have its URL rewritten to the destination URL, except for in the case of cross-document "traverse" navigations, where it will always be false.
</dd>

	<dt>%event.`userInitiated$mE</dt>
	<dd>
この~naviが［
利用者が次に挙げるいずれかを行った
］ことに因り生じた場合は ~T になり、
他の場合は ~F になる
⇒＃
`a$e 要素を~clickした／
`form$e 要素を提出している／
`~browser~UI＠~HTMLlifecycle#nav-traversal-ui$を利用して~navigateした
◎
True if this navigation was due to a user clicking on an a element, submitting a form element, or using the browser UI to navigate; false otherwise.
</dd>

	<dt>%event.`hashChange$mE</dt>
	<dd>
`素片への~navi$である場合は ~T になり、
他の場合は ~F になる。
◎
True for a fragment navigation; false otherwise.
</dd>

	<dt>%event.`signal$mE</dt>
	<dd>
当の~naviが取消された場合
— 例：次に挙げる場合 —
には中止されることになる `AbortSignal$I
⇒＃
利用者が~browserの “停止-” ~buttonを押した／
別の~naviが，この~naviを中断している
◎
An AbortSignal which will become aborted if the navigation gets canceled, e.g., by the user pressing their browser's "Stop" button, or by another navigation interrupting this one.
</dd>
	<dd>
開発者~向けに期待される~patternは、
これを何らかの非同期cな演算
— `fetch()$m など —
に渡して，それを［
この~naviを取扱うときの一部として遂行する
］ことである。
◎
The expected pattern is for developers to pass this along to any async operations, such as fetch(), which they perform as part of handling this navigation.
</dd>

	<dt>%event.`formData$mE</dt>
	<dd>
この~naviが［
`push$l ／ `replace$l
］~naviであって，［
~POSTを伴う`~form提出＠~HTMLforms#concept-form-submit$
］を表現している場合、［
この~navi用に提出された~form~entryたちを表現している `FormData$I
］になる。
他の場合、
~NULL になる。
◎
The FormData representing the submitted form entries for this navigation, if this navigation is a "push" or "replace" navigation representing a POST form submission; null otherwise.
</dd>
	<dd>
（これは、［
`reload$l ／ `traverse$l
］~navi用には ~NULL になることに注意
— それが［
元々は~form提出により作成された`~session履歴~entry$
］を訪問し直している場合でも。）
◎
(Notably, this will be null even for "reload" or "traverse" navigations that are revisiting a session history entry that was originally created from a form submission.)
</dd>

	<dt>%event.`downloadRequest$mE</dt>
	<dd>
<p>
この~naviが［
`a$e ／ `area$e
］要素の `download$a 属性を利用して~downloadを要請したかどうかを表現する
— ~downloadが：
◎
Represents whether or not this navigation was requested to be a download, by using an a or area element's download attribute:
</p>
		<ul>
			<li>
要請されなかった場合、
この~prop は ~NULL になる。
◎
If a download was not requested, then this property is null.
</li>
			<li>
要請された場合、
`download$a 属性の値として給された~filename（空~文字列もとり得る）を返す。
◎
If a download was requested, returns the filename that was supplied as the download attribute's value. (This could be the empty string.)
</li>
		</ul>
	</dd>
	<dd>
<p>
~downloadが要請されたとしても、
常に~downloadが起こることは意味しないことに注意。
例えば、
~downloadは：
</p>
		<ul>
			<li>
~browserの~security施策により，
阻止されるかもしれない。
</li>
			<li>
<span class="XXX">`未指定な理由＠~HTMLissue/7718$により</span>，
結果的に `push$hH ~naviとして扱われるかもしれない。
</li>
		</ul>
◎
Note that a download being requested does not always mean that a download will happen: for example, a download might be blocked by browser security policies, or end up being treated as a "push" navigation for unspecified reasons.
</dd>
	<dd>
類似に，~downloadが要請されなかった場合でも、
結果は~downloadになるかもしれない
— ~naviに対し［
行先~serverが `Content-Disposition$h ~headerで応答する
］こと因り。
◎
Similarly, a navigation might end up being a download even if it was not requested to be one, due to the destination server responding with a `Content-Disposition: attachment` header.
</dd>
	<dd>
~browser~UI~affordanceを利用して起動された~download用には、
`navigate$et ~eventは，まったく発火されないことに注意
— 例：右~clickして~linkの~targetを保存することを選んだ場合。
◎
Finally, note that the navigate event will not fire at all for downloads initiated using browser UI affordances, e.g., those created by right-clicking and choosing to save the target of a link.
</dd>

	<dt>%event.`info$mE</dt>
	<dd>
この~naviが，いずれかの`~navi~API~method＠#navigation-api-initiating-navigations$を介して起動された場合、
それに渡された任意な~JS値になる。
［
利用者／異なる~API
］により起動された場合、
`undefined^jv になる。
◎
An arbitrary JavaScript value passed via one of the navigation API methods which initiated this navigation, or undefined if the navigation was initiated by the user or by a different API.
</dd>

	<dt>%event.`hasUAVisualTransition$mE</dt>
	<dd>
~UAが［
この~eventを配送する前に，この~navi用に視覚的な遷移を遂行した
【おそらく， `CSSVIEWTRANSITIONS$r を指す】
］ならば ~T を返す。
~T の場合、
作者は，［
~navi後の状態と同期的に~DOMを更新する
］ならば最良な利用者~体験を与えることになる。
◎
Returns true if the user agent performed a visual transition for this navigation before dispatching this event. If true, the best user experience will be given if the author synchronously updates the DOM to the post-navigation state.
</dd>

	<dt>%event.`intercept$mE({ `handler$mb, `focusReset$mb, `scroll$mb })</dt>
	<dd>
この~naviを横取する
— この~naviに対する通常の取扱いを防止して、
代わりに，それを同じ種別の［
行先~URLと同一-文書への~navi
］に変換する。
◎
Intercepts this navigation, preventing its normal handling and instead converting it into a same-document navigation of the same type to the destination URL.
</dd>
	<dd>
`handler$mb ~optionは、
~promiseを返す関数をとり得る。
この関数は、［
`navigate$et ~eventの発火が完遂して，
`navigation.currentEntry$c ~propが同期的に更新された後
］に走ることになる。
返された~promiseは、
当の~naviの［
所要時間, 成否
］を通達するために利用される。
~browserは、
それが決着した後に，
当の~naviが完遂したことを利用者へ通達する
（例：［
読込n中を表す~UI／支援技術
］を介して）
ことに加え、
当の~web~appを成す他の各部が応答できるよう，［
`navigatesuccess$et, `navigateerror$et
］~eventのうち適切な方を発火する。
◎
The handler option can be a function that returns a promise. The handler function will run after the navigate event has finished firing, and the navigation.currentEntry property has been synchronously updated. This returned promise is used to signal the duration, and success or failure, of the navigation. After it settles, the browser signals to the user (e.g., via a loading spinner UI, or assistive technology) that the navigation is finished. Additionally, it fires navigatesuccess or navigateerror events as appropriate, which other parts of the web application can respond to.
</dd>
	<dd>
<p>
既定では、
この~methodを利用すると：
◎
↓
</p>
		<ul>
			<li>
~handlerが返した~promiseが決着するとき，~focusを設定し直すことになる。
~focusは、
`autofocus$a 属性を有する要素が［
在るならば それらのうち最初のもの ／
無いならば`~body要素$
］に設定し直されることになる。
`focusReset$mb ~optionを `manual$lF に設定すれば、
この挙動を避けれる。
◎
By default, using this method will cause focus to reset when any handlers' returned promises settle. Focus will be reset to the first element with the autofocus attribute set, or the body element if the attribute isn't present. The focusReset option can be set to "manual" to avoid this behavior.
</li>
			<li>
~handlerが返した~promiseが決着するまで，［［
`traverse$l ／ `reload$l
］~navi用には［
~browserの~scroll復旧
］~logic ／ ［［
`push$l ／ `replace$l
］~navi用には~browser［
~scrollを設定し直す ／ 素片へ~scrollする
］ための~logic
］を遅延することになる。
`scroll$mb ~optionを `manual$lS に設定することで、
この~navi用の［
~browser駆動な~scroll用の挙動
］をまるごとオフにできる。
決着する前に `scroll()$mE を~callすれば、
この挙動を早期に誘発できる。
◎
By default, using this method will delay the browser's scroll restoration logic for "traverse" or "reload" navigations, or its scroll-reset/scroll-to-a-fragment logic for "push" or "replace" navigations, until any handlers' returned promises settle. The scroll option can be set to "manual" to turn off any browser-driven scroll behavior entirely for this navigation, or scroll() can be called before the promise settles to trigger this behavior early.
</li>
		</ul>
	</dd>
	<dd>
この~methodは、［
`canIntercept$mE ~EQ ~F ／
`isTrusted$m ~EQ ~F
］の場合には，
`SecurityError$E 例外を投出する。
~event配送の間に同期的に~callされなかった場合には，
`InvalidStateError$E 例外を投出する。
◎
This method will throw a "SecurityError" DOMException if canIntercept is false, or if isTrusted is false. It will throw an "InvalidStateError" DOMException if not called synchronously, during event dispatch.
</dd>

	<dt>%event.`scroll$mE()</dt>
	<dd>
［
`traverse$l ~navi／ `reload$l ~navi
］の場合、
~browserの通例的な~scroll復旧~logicを利用して
~scroll位置を復旧する。
◎
For "traverse" or "reload" navigations, restores the scroll position using the browser's usual scroll restoration logic.
</dd>
	<dd>
［
`push$l ~navi／ `replace$l ~navi
］の場合
⇒＃
`url$mD が`素片$urlを伴う場合は，そこへ~scrollする／
他の場合は，~scroll位置を文書の上端に設定し直す
◎
For "push" or "replace" navigations, either resets the scroll position to the top of the document or scrolls to the fragment specified by destination.url if there is one.
</dd>
	<dd>
<p>
次に挙げるいずれかに該当する場合、
`InvalidStateError$E 例外が投出される：
</p>
		<ul>
			<li>
複数回~callされた
</li>
			<li>
`scroll$mb ~optionが `after-transition$lS のままにされた
【 `intercept()$mE ~methodに渡した %options の `scroll$mb ~memberが `after-transition$lS に設定されたか，省略された】
ことに因り起きた［
遷移~後の自動的な~scroll処理
］の後に~callされた
</li>
			<li>
~naviが~commitされる前に~callされた
</li>
		</ul>
◎
If called more than once, or called after automatic post-transition scroll processing has happened due to the scroll option being left as "after-transition", or called before the navigation has committed, this method will throw an "InvalidStateError" DOMException.
</dd>
</dl>

<p>
各 `NavigateEvent$I には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
<p>
`横取~状態@nEv
⇒
次に挙げるいずれか
— 初期~時は `none^l とする
⇒＃
`none^l ／
`intercepted^l ／
`committed^l ／
`scrolled^l ／
`finished^l
</p>

<p class="trans-note">【
この状態は、
挙げられた順に
— 場合によっては，うちいくつかを飛ばして —
遷移する。
】【
この仕様に現れる “（~naviが）~commitされた” とは、［
~naviの`進行中な~navigate_ev~event$の`横取~状態$nEvが `committed^l になった
］ことを意味すると思われる。
】</p>
◎
Each NavigateEvent has an interception state, which is either "none", "intercepted", "committed", "scrolled", or "finished", initially "none".
</li>
	<li>
<p>
`~navi~handler~list@nEv
⇒
`NavigationInterceptHandler$I ~callbackたちが成す`~list$
— 初期~時は空とする。
</p>

<p class="trans-note">【
この~listは、
当の `NavigateEvent$I に対する各 `intercept()$mE の~callに渡した `handler$mb ~optionにより，拡充される。
それらの~callbackが返す~promiseを総称して、
この訳では
`~navi~handler~promise@
と称することにする。
】</p>
◎
Each NavigateEvent has a navigation handler list, a list of NavigationInterceptHandler callbacks, initially empty.
</li>
	<li>
`~focusを設定し直す挙動@nEv
⇒
`NavigationFocusReset$I ／ ~NULL
— 初期~時は ~NULL とする。
◎
Each NavigateEvent has a focus reset behavior, a NavigationFocusReset-or-null, initially null.
</li>
	<li>
`~scroll用の挙動@nEv
⇒
`NavigationScrollBehavior$I ／ ~NULL
— 初期~時は ~NULL とする。
◎
Each NavigateEvent has a scroll behavior, a NavigationScrollBehavior-or-null, initially null.
</li>
	<li>
`中止-制御器@nEv
⇒
`AbortController$I ／ ~NULL
— 初期~時は ~NULL とする。
◎
Each NavigateEvent has an abort controller, an AbortController-or-null, initially null.
</li>
	<li>
<p>
`古典~履歴~API用の状態@nEv
⇒
`直列形の状態$／ ~NULL
◎
Each NavigateEvent has a classic history API state, a serialized state or null.＼
</p>

<p>
これは、
当の~eventの `navigationType$mE が［
`push$l, `replace$l
］いずれかである，一部の事例に限り利用され、
当の~eventが`発火される＠~DOM4#concept-event-fire$ときに適切に設定される
◎
It is only used in some cases where the event's navigationType is "push" or "replace", and is set appropriately when the event is fired.
</p>
	</li>
</ul>

<p>
次に挙げる属性は、
初期化~時の値を返すモノトスル
⇒＃
`navigationType@mE,
`destination@mE,
`canIntercept@mE,
`userInitiated@mE,
`hashChange@mE,
`signal@mE,
`formData@mE,
`downloadRequest@mE,
`info@mE,
`hasUAVisualTransition@mE
◎
The navigationType, destination, canIntercept, userInitiated, hashChange, signal, formData, downloadRequest, info, and hasUAVisualTransition attributes must return the values they are initialized to.
</p>

<div class="algo">
<p>
`intercept(options)@mE
~method手続きは：
◎
The intercept(options) method steps are:
</p>
<ol>
	<li>
`共用~検査を遂行する$( コレ )
◎
Perform shared checks given this.
</li>
	<li>
~IF［
コレの `canIntercept$mE 属性 ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If this's canIntercept attribute was initialized to false, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
コレの`配送-中か$ev ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If this's dispatch flag is unset, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~Assert：
コレの`横取~状態$nEv ~IN { `none^l, `intercepted^l }
◎
Assert: this's interception state is either "none" or "intercepted".
</li>
	<li>
コレの`横取~状態$nEv ~SET `intercepted^l
◎
Set this's interception state to "intercepted".
</li>
	<li>
%handler ~SET %options[ "`handler$mb" ]
◎
↓</li>
	<li>
~IF［
%handler ~NEQ ε
］
⇒
コレの`~navi~handler~list$nEvに %handler を`付加する$
◎
If options["handler"] exists, then append it to this's navigation handler list.
</li>
	<li>
%focusReset ~LET %options[ "`focusReset$mb" ] 
◎
↓</li>
	<li>
<p>
~IF［
%focusReset ~NEQ ε
］：
◎
If options["focusReset"] exists, then:
</p>
		<ol>
			<li>
~IF［
コレの`~focusを設定し直す挙動$nEv ~NIN { ~NULL, %focusReset }
］
⇒
任意選択で
⇒
`~consoleに警告を報告する$( ↓ )
⇒
“`intercept()$mE に対する以前の~callに与えた `focusReset$mb ~optionは、
この新たな値により上書きされ，無視されることになる。”
◎
If this's focus reset behavior is not null, and it is not equal to options["focusReset"], then the user agent may report a warning to the console indicating that the focusReset option for a previous call to intercept() was overridden by this new value, and the previous value will be ignored.
</li>
			<li>
コレの`~focusを設定し直す挙動$nEv ~SET %focusReset
◎
Set this's focus reset behavior to options["focusReset"].
</li>
		</ol>
	</li>
	<li>
%scroll ~LET %options[ "`scroll$mb" ]
◎
↓</li>
	<li>
<p>
~IF［
%scroll ~NEQ ε
］：
◎
If options["scroll"] exists, then:
</p>
		<ol>
			<li>
~IF［
コレの`~scroll用の挙動$nEv ~NIN { ~NULL, %scroll }
］
⇒
任意選択で
⇒
`~consoleに警告を報告する$( ↓ )
⇒
“`intercept()$mE に対する以前の~callにて与えた `scroll$mb ~optionは、
この新たな値により上書きされ，無視されることになる。”
◎
If this's scroll behavior is not null, and it is not equal to options["scroll"], then the user agent may report a warning to the console indicating that the scroll option for a previous call to intercept() was overridden by this new value, and the previous value will be ignored.
</li>
			<li>
コレの`~scroll用の挙動$nEv ~SET %scroll
◎
Set this's scroll behavior to options["scroll"].
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`scroll()@mE
~method手続きは：
◎
The scroll() method steps are:
</p>
<ol>
	<li>
`共用~検査を遂行する$( コレ )
◎
Perform shared checks given this.
</li>
	<li>
~IF［
コレの`横取~状態$nEv ~NEQ `committed^l
］
⇒
~THROW `InvalidStateError$E
◎
If this's interception state is not "committed", then throw an "InvalidStateError" DOMException.
</li>
	<li>
`~scroll用の挙動を処理する$( コレ )
◎
Process scroll behavior given this.
</li>
</ol>
</div>

<div class="algo">
<p>
`共用~検査を遂行する@
ときは、
所与の
( `NavigateEvent$I %~event )
に対し：
◎
To perform shared checks for a NavigateEvent event:
</p>
<ol>
	<li>
~IF［
%~event に`関連な大域~obj$に`結付けられた文書$は`全部的に作動中$でない
］
⇒
~THROW `InvalidStateError$E
◎
If event's relevant global object's associated Document is not fully active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%~event の`isTrusted$m 属性 ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If event's isTrusted attribute was initialized to false, then throw a "SecurityError" DOMException.
</li>
	<li>
~IF［
%~event の`取消されたか$ev ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If event's canceled flag is set, then throw an "InvalidStateError" DOMException.
</li>
</ol>
</div>

					</section>
					<section id="the-navigationdestination-interface">
<h6 title="The NavigationDestination interface">7.2.6.10.2. `NavigationDestination^I ~interface</h6>

<pre class="idl">
[Exposed=Window]
interface `NavigationDestination@I {
  readonly attribute USVString `url$mD;
  readonly attribute DOMString `key$mD;
  readonly attribute DOMString `id$mD;
  readonly attribute long long `index$mD;
  readonly attribute boolean `sameDocument$mD;

  any `getState$mD();
};
</pre>

<dl class="domintro">
	<dt>%event.`destination$mE.`url$mD</dt>
	<dd>
~navigate先の~URL。
◎
The URL being navigated to.
</dd>

	<dt>%event.`destination$mE.`key$mD</dt>
	<dd>
`traverse$l ~naviである場合
⇒
行先を成す `NavigationHistoryEntry$I の `key$mH ~propの値
◎
The value of the key property of the destination NavigationHistoryEntry, if this is a "traverse" navigation,＼
</dd>
	<dd>
他の場合
⇒
空~文字列
◎
or the empty string otherwise.
</dd>

	<dt>%event.`destination$mE.`id$mD</dt>
	<dd>
`traverse$l ~naviである場合
⇒
行先を成す `NavigationHistoryEntry$I の `id$mH ~propの値
◎
The value of the id property of the destination NavigationHistoryEntry, if this is a "traverse" navigation,＼
</dd>
	<dd>
他の場合
⇒
空~文字列
◎
or the empty string otherwise.
</dd>

	<dt>%event.`destination$mE.`index$mD</dt>
	<dd>
`traverse$l ~naviである場合
⇒
行先を成す `NavigationHistoryEntry$I の `index$mH ~propの値
◎
The value of the index property of the destination NavigationHistoryEntry, if this is a "traverse" navigation,＼
</dd>
	<dd>
他の場合
⇒
−1
◎
or −1 otherwise.
</dd>

	<dt>%event.`destination$mE.`sameDocument$mD</dt>
	<dd>
この~naviは，同一-文書への~navi（現在の`文書$と同じ`文書$への~navi）か否かを指示する。
例えば、［
素片への~navi ／
`history.pushState()＠~WINDOW#dom-history-pushstate$c による~navi
］の事例においては ~T になる。
◎
Indicates whether or not this navigation is to the same Document as the current one, or not.＼
This will be true, for example, in the case of fragment navigations or history.pushState() navigations.
</dd>
	<dd>
この~propは、
当の~naviの元の資質を指示することに注意。
非同一-文書への~naviが `intercept()$mE【！navigateEvent.intercept()】 を利用して同一-文書への~naviに変換された場合、
この~propの値は変化しない。
◎
Note that this property indicates the original nature of the navigation. If a cross-document navigation is converted into a same-document navigation using navigateEvent.intercept(), that will not change the value of this property.
</dd>

	<dt>%event.`destination$mE.`getState$mD()</dt>
	<dd>
`traverse$l ~navi用には、
次を返す
⇒
行先を成す`~session履歴~entry$内に格納された状態の`逆直列化$
◎
For "traverse" navigations, returns the deserialization of the state stored in the destination session history entry.
</dd>
	<dd>
<p>
［
`push$l ~navi／ `replace$l ~navi
］用には、
次を返す：
</p>
		<ul>
			<li>
当の~naviは `navigation.navigate()$c により起動された場合
⇒
その~methodに渡された状態の`逆直列化$
</li>
			<li>
他の場合
⇒
`undefined^jv
</li>
		</ul>
◎
For "push" or "replace" navigations, returns＼
◎
the deserialization of the state passed to navigation.navigate(), if the navigation was initiated by that method,＼
◎
or undefined it if it wasn't.
</dd>
	<dd>
<p>
`reload$l ~navi用には、
次を返す：
◎
For "reload" navigations, returns＼
</p>
		<ul>
			<li>
当の~naviは `navigation.reload()$c により起動された場合
⇒
その~methodに渡された状態の`逆直列化$
◎
the deserialization of the state passed to navigation.reload(), if the reload was initiated by that method,＼
</li>
			<li>
他の場合
⇒
`undefined^jv
◎
or undefined it if it wasn't.
</li>
		</ul>
	</dd>
</dl>

<p>
各 `NavigationDestination$I は、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`~URL@nDt
⇒
`~URL$
◎
Each NavigationDestination has a URL, which is a URL.
</li>
	<li>
<p>
`~entry@nDt
⇒
`NavigationHistoryEntry$I ／ ~NULL
◎
Each NavigationDestination has an entry, which is a NavigationHistoryEntry or null.
</p>

<p class="note">注記：
~NULL 以外になるのは、
`NavigationDestination$I が `traverse$l ~naviに対応する場合，その場合に限られる。
◎
It will be non-null if and only if the NavigationDestination corresponds to a "traverse" navigation.
</p>
	</li>
	<li>
`状態@nDt
⇒
`直列形の状態$
◎
Each NavigationDestination has a state, which is a serialized state.
</li>
	<li>
`同一-文書か@nDt
⇒
真偽値
◎
Each NavigationDestination has an is same document, which is a boolean.
</li>
</ul>

<hr>

<div class="algo">
`url@mD
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレの`~URL$nDt )
◎
The url getter steps are to return this's URL, serialized.
</div>

<div class="algo">
<p>
`key@mD
取得子~手続きは：
◎
The key getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`~entry$nDt ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's entry is null, then return the empty string.
</li>
	<li>
~RET コレの`~entry$nDtの`~key$nE
◎
Return this's entry's key.
</li>
</ol>
</div>

<div class="algo">
<p>
`id@mD
取得子~手続きは：
◎
The id getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`~entry$nDt ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this's entry is null, then return the empty string.
</li>
	<li>
~RET コレの`~entry$nDtの`~ID$nE
◎
Return this's entry's ID.
</li>
</ol>
</div>

<div class="algo">
<p>
`index@mD
取得子~手続きは：
◎
The index getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`~entry$nDt ~EQ ~NULL
］
⇒
~RET −1
◎
If this's entry is null, then return −1.
</li>
	<li>
~RET コレの`~entry$nDtの`~index$nE
◎
Return this's entry's index.
</li>
</ol>
</div>

<div class="algo">
`sameDocument@mD
取得子~手続きは
⇒
~RET コレの`同一-文書か$nDt
◎
The sameDocument getter steps are to return this's is same document.
</div>

<div class="algo">
<p>
`getState()@mD
~method手続きは
⇒
~RET `StructuredDeserialize$jA( コレの`状態$nDt )
◎
The getState() method steps are to return StructuredDeserialize(this's state).
</p>
</div>

					</section>
					<section id="navigate-event-firing">
<h6 title="Firing the event">7.2.6.10.3. ~eventの発火-法</h6>

<p>
この標準を成す他の各部は、
この節にて与える~wrapper~algoを通して，
`navigate$et ~eventを発火する。
◎
Other parts of the standard fire the navigate event, through a series of wrapper algorithms given in this section.
</p>

<div class="algo">
<div class="p">
<p>
`辿-用の~navigate_ev~eventを発火する@
ときは、
所与の
( `Navigation$I %~navi )
および，所与の
</p>
<ul>
	<li id="fire-navigate-traverse-destinationshe">
`~session履歴~entry$ %行先~履歴~entry
</li>
	<li id="fire-navigate-traverse-userinvolvement">
`~naviに対する利用者-関与i$ %利用者-関与i
（省略時は `なし$i ）
</li>
</ul>
<p>
に対し：
</p>
◎
To fire a traverse navigate event at a Navigation navigation given a session history entry destinationSHE and an optional user navigation involvement userInvolvement (default "none"):
</div>
<ol>
	<li>
%~event ~LET `~eventを作成する$( `NavigateEvent$I, %~navi に`関連な~realm$ )
◎
Let event be the result of creating an event given NavigateEvent, in navigation's relevant realm.
</li>
	<li>
%~event の`古典~履歴~API用の状態$nEv ~SET ~NULL
◎
Set event's classic history API state to null.
</li>
	<li>
%行先 ~LET `新たな~obj$( `NavigationDestination$I, %~navi に`関連な~realm$ )
◎
Let destination be a new NavigationDestination created in navigation's relevant realm.
</li>
	<li>
%行先 の`~URL$nDt ~SET %行先~履歴~entry の`~URL$shE
◎
Set destination's URL to destinationSHE's URL.
</li>
	<li>
%行先~NHE ~LET %~navi の`~entry~list$nV 内に次を満たす `NavigationHistoryEntry$I は［
在るならば それ／
無いならば
］
⇒
その`~session履歴~entry$nhe ~EQ %行先~履歴~entry
◎
Let destinationNHE be the NavigationHistoryEntry in navigation's entry list whose session history entry is destinationSHE, or null if no such NavigationHistoryEntry exists.
</li>
	<li>
<p>
~IF［
%行先~NHE ~NEQ ~NULL
］：
◎
If destinationNHE is non-null, then:
</p>
		<ol>
			<li>
%行先 の`~entry$nDt ~SET %行先~NHE
◎
Set destination's entry to destinationNHE.
</li>
			<li>
%行先 の`状態$nDt ~SET %行先~履歴~entry の`~navi~API状態$shE
◎
Set destination's state to destinationSHE's navigation API state.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
%行先 の`~entry$nDt ~SET ~NULL
◎
Set destination's entry to null.
</li>
			<li>
%行先 の`状態$nDt ~SET `StructuredSerializeForStorage$jA( ~NULL )
◎
Set destination's state to StructuredSerializeForStorage(null).
</li>
		</ol>
	</li>
	<li>
%行先 の`同一-文書か$nDt ~SET ~IS［
%行先~履歴~entry の`文書$shE ~EQ %~navi に`関連な大域~obj$に`結付けられた文書$
］
◎
Set destination's is same document to true if destinationSHE's document is equal to navigation's relevant global object's associated Document; otherwise false.
</li>
	<li>
~RET `~navigate_ev~eventを発火する内縁~algo$( ↓ )
⇒＃
%~navi, `traverse$l,
%~event,
%行先,
%利用者-関与i,
~NULL,
~NULL
◎
Return the result of performing the inner navigate event firing algorithm given navigation, "traverse", event, destination, userInvolvement, null, and null.
</li>
</ol>
</div>

<div class="algo">
<div class="p">
<p>
`~push／置換-／再読込み用の~navigate_ev~eventを発火する@
ときは、
所与の
( `Navigation$I %~navi )
および，所与の：
</p>
<ul>
	<li id="fire-navigate-prr-navigationtype">
`NavigationType$I %~navi種別
</li>
	<li id="fire-navigate-prr-destinationurl">
`~URL$ %行先~URL
</li>
	<li id="fire-navigate-prr-issamedocument">
真偽値 %同一-文書か
</li>
	<li id="fire-navigate-prr-userinvolvement">
`~naviに対する利用者-関与i$ %利用者-関与i
（省略時は `なし$i ）
</li>
	<li id="fire-navigate-prr-formdataentrylist">
［
`~entry~list$ ／ ~NULL
］ %~form~data~entry~list
（省略時は ~NULL ）
</li>
	<li id="fire-navigate-prr-navigationapistate">
`直列形の状態$ %~navi~API状態
（省略時は`StructuredSerializeForStorage$jA( ~NULL ) ）
</li>
	<li id="fire-navigate-prr-classichistoryapistate">
［ `直列形の状態$ ／ ~NULL ］ %古典~履歴~API用の状態（省略時は ~NULL ）
</li>
</ul>
<p>
に対し：
</p>
◎
To fire a push/replace/reload navigate event at a Navigation navigation given a NavigationType navigationType, a URL destinationURL, a boolean isSameDocument, an optional user navigation involvement userInvolvement (default "none"), an optional entry list-or-null formDataEntryList (default null), an optional serialized state navigationAPIState (default StructuredSerializeForStorage(null)), and an optional serialized state-or-null classicHistoryAPIState (default null):
</div>
<ol>
	<li>
%~event ~LET `~eventを作成する$( `NavigateEvent$I, %~navi に`関連な~realm$ )
◎
Let event be the result of creating an event given NavigateEvent, in navigation's relevant realm.
</li>
	<li>
%~event の`古典~履歴~API用の状態$nEv ~SET %古典~履歴~API用の状態
◎
Set event's classic history API state to classicHistoryAPIState.
</li>
	<li>
%行先 ~LET `新たな~obj$( `NavigationDestination$I, %~navi に`関連な~realm$ )
— その
⇒＃
`~URL$nDt ~SET %行先~URL,
`~entry$nDt ~SET ~NULL,
`状態$nDt ~SET  %~navi~API状態,
`同一-文書か$nDt ~SET %同一-文書か
◎
Let destination be a new NavigationDestination created in navigation's relevant realm.
◎
Set destination's URL to destinationURL.
◎
Set destination's entry to null.
◎
Set destination's state to navigationAPIState.
◎
Set destination's is same document to isSameDocument.
</li>
	<li>
~RET `~navigate_ev~eventを発火する内縁~algo$( ↓ )
⇒＃
%~navi,
%~navi種別,
%~event,
%行先,
%利用者-関与i,
%~form~data~entry~list,
~NULL
◎
Return the result of performing the inner navigate event firing algorithm given navigation, navigationType, event, destination, userInvolvement, formDataEntryList, and null.
</li>
</ol>
</div>

<div class="algo">
<div class="p">
<p>
`~download要請~用の~navigate_ev~eventを発火する@
ときは、
所与の
( `Navigation$I %~navi )
および，所与の：
</p>
<ul>
	<li id="fire-navigate-download-destinationurl">
`~URL$ %行先~URL
</li>
	<li id="fire-navigate-download-userinvolvement">
`~naviに対する利用者-関与i$ %利用者-関与i
</li>
	<li id="fire-navigate-download-filename">
文字列 %~filename
</li>
</ul>
<p>
に対し：
</p>
◎
To fire a download request navigate event at a Navigation navigation given a URL destinationURL, a user navigation involvement userInvolvement, and a string filename:
</div>
<ol>
	<li>
%~event ~LET `~eventを作成する$( `NavigateEvent$I, %~navi に`関連な~realm$ )
◎
Let event be the result of creating an event given NavigateEvent, in navigation's relevant realm.
</li>
	<li>
%~event の`古典~履歴~API用の状態$nEv ~SET ~NULL
◎
Set event's classic history API state to null.
</li>
	<li>
%行先 ~LET `新たな~obj$( `NavigationDestination$I, %~navi に`関連な~realm$ )
— その
⇒＃
`~URL$nDt ~SET %行先~URL,
`~entry$nDt ~SET ~NULL,
`状態$nDt ~SET `StructuredSerializeForStorage$jA( ~NULL ),
`同一-文書か$nDt ~SET ~F
◎
Let destination be a new NavigationDestination created in navigation's relevant realm.
◎
Set destination's URL to destinationURL.
◎
Set destination's entry to null.
◎
Set destination's state to StructuredSerializeForStorage(null).
◎
Set destination's is same document to false.
</li>
	<li>
~RET `~navigate_ev~eventを発火する内縁~algo$( ↓ )
⇒＃
%~navi,
`push$l,
%~event,
%行先,
%利用者-関与i,
~NULL,
%~filename
◎
Return the result of performing the inner navigate event firing algorithm given navigation, "push", event, destination, userInvolvement, null, and filename.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate_ev~eventを発火する内縁~algo@
は、
所与の
⇒＃
`Navigation$I %~navi,
`NavigationType$I %~navi種別,
`NavigateEvent$I %~event,
`NavigationDestination$I %行先,
`~naviに対する利用者-関与i$ %利用者-関与i,
［ `~entry~list$ ／ ~NULL ］ %~form~data~entry~list,
［ 文字列 ／ ~NULL ］ %~download要請~filename
◎終
に対し：
◎
The inner navigate event firing algorithm consists of the following steps, given a Navigation navigation, a NavigationType navigationType, a NavigateEvent event, a NavigationDestination destination, a user navigation involvement userInvolvement, an entry list-or-null formDataEntryList, and a string-or-null downloadRequestFilename:
</p>
<ol>
	<li>
<p>
~IF［
%~navi の`~entryや~eventは不能化されて$いる
］：
◎
If navigation has entries and events disabled, then:
</p>
		<ol>
			<li>
~Assert：
%~navi の`進行中な~API~method追跡子$ ~EQ ~NULL
◎
Assert: navigation's ongoing API method tracker is null.
</li>
			<li>
~Assert：
%~navi の`来たる非-辿-~API~method追跡子$ ~EQ ~NULL
◎
Assert: navigation's upcoming non-traverse API method tracker is null.
</li>
			<li>
~Assert：
%~navi の`来たる辿-~API~method追跡子~群$は`空$である
◎
Assert: navigation's upcoming traverse API method trackers is empty.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
</ol>

<p class="note">注記：
これらの表明が満たされるのは、
~entryや~eventが不能化されたときは，［
`traverseTo()$mN ／ `back()$mN ／ `forward()$mN
］が即時に失敗するからであり
（辿-先を成す~entryは無いので）、
代わりに［
`navigate()$mN ／ `reload()$mN
］から開始したでも，まず最初に`来たる非-辿-~API~method追跡子$を設定することを`避けた＠#dont-always-set-upcoming-non-traverse-api-method-tracker$からである。
◎
These assertions holds because traverseTo(), back(), and forward() will immediately fail when entries and events are disabled (since there are no entries to traverse to), and if our starting point is instead navigate() or reload(), then we avoided setting the upcoming non-traverse API method tracker in the first place.
</p>
	</li>
	<li>
%行先~key ~LET ~NULL
◎
Let destinationKey be null.
</li>
	<li>
~IF［
%行先 の`~entry$nDt ~NEQ ~NULL
］
⇒
%行先~key ~SET %行先 の`~entry$nDtの`~key$nE
◎
If destination's entry is non-null, then set destinationKey to destination's entry's key.
</li>
	<li>
~Assert：
%行先~key ~NEQ 空~文字列
◎
Assert: destinationKey is not the empty string.
</li>
	<li>
`来たる~API~method追跡子を進行中にする$( %~navi, %行先~key )
◎
Promote an upcoming API method tracker to ongoing given navigation and destinationKey.
</li>
	<li>
%~API~method追跡子 ~LET %~navi の`進行中な~API~method追跡子$
◎
Let apiMethodTracker be navigation's ongoing API method tracker.
</li>
	<li>
%~navigable ~LET %~navi に`関連な大域~obj$に`対応する~navigable$
◎
Let navigable be navigation's relevant global object's navigable.
</li>
	<li>
%文書 ~LET %~navi に`関連な大域~obj$に`結付けられた文書$
◎
Let document be navigation's relevant global object's associated Document.
</li>
	<li>
<p>
%~event の各種~属性を以下に従って初期化する：
</p>
		<ol>
			<li>
<p>
%~event の `canIntercept$mE ~SET ~IS ~AND↓：
</p>
				<ul>
					<li>
`文書の~URLは書直せるか$( %文書, %行先 の`~URL$nDt ) ~EQ ~T
</li>
					<li>
［
%行先 の`同一-文書か$nDt~EQ ~T
］~OR［
%~navi種別 ~NEQ `traverse$l
］
</li>
				</ul>
◎
If document can have its URL rewritten to destination's URL, and either destination's is same document is true or navigationType is not "traverse", then initialize event's canIntercept to true. Otherwise, initialize it to false.
</li>
			<li id="navigate-event-traverse-can-be-canceled">
<p>
%辿-は取消せるか ~LET ~IS ~AND↓：
</p>
				<ul>
					<li>
%~navigable は`~top-level辿可能$である
</li>
					<li>
%行先 の`同一-文書か$nDt~EQ ~T
</li>
					<li>
［
%利用者-関与i ~NEQ `~browser~UI$i
］~OR［
%~navi に`関連な大域~obj$は`履歴~動作による作動化を有して$いる
］
</li>
				</ul>
◎
Let traverseCanBeCanceled be true if all of the following are true:
• navigable is a top-level traversable;
• destination's is same document is true; and
• either userInvolvement is not "browser UI", or navigation's relevant global object has history-action activation.
◎
Otherwise, let it be false.
</li>
			<li>
%~event の`cancelable$m ~SET ~IS［
%~navi種別 ~NEQ `traverse$l
］~OR［
%辿-は取消せるか ~EQ ~T
］
◎
If either:
• navigationType is not "traverse"; or
• traverseCanBeCanceled is true,
◎
then initialize event's cancelable to true. Otherwise, initialize it to false.
</li>
			<li>
%~event の
⇒＃
`type$m ~SET "`navigate$et",
`navigationType$mE ~SET %~navi種別,
`destination$mE ~SET %行先,
`downloadRequest$mE ~SET %~download要請~filename
◎
Initialize event's type to "navigate".
◎
Initialize event's navigationType to navigationType.
◎
Initialize event's destination to destination.
◎
Initialize event's downloadRequest to downloadRequestFilename.
</li>
			<li>
<p>
%~event の `info$mE ~SET ［
%~API~method追跡子 ~NEQ ~NULL ならば %~API~method追跡子 の`報$amT ／
~ELSE_ `undefined^jv
］
◎
If apiMethodTracker is not null, then initialize event's info to apiMethodTracker's info. Otherwise, initialize it to undefined.
</p>

<p class="note">注記：
この時点で、
%~API~method追跡子 の`報$amT は，もはや必要なくなる
— 実装は、
当の`~navi~API~method追跡子$が存続する限り それが生存し続けないよう，
それを ~NULL 化できる。
◎
At this point apiMethodTracker's info is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the navigation API method tracker.
</p>
			</li>
			<li>
%~event の `hasUAVisualTransition$mE ~SET ~IS［
~UAは~cacheしてあった［
%文書 の`最近の~entry$が描画された状態
］を表示するための視覚的な遷移を行った
］
◎
Initialize event's hasUAVisualTransition to true if a visual transition, to display a cached rendered state of the document's latest entry, was done by the user agent. Otherwise, initialize it to false.
</li>
			<li>
%~event の`中止-制御器$nEv ~SET `新たな~obj$( `AbortController$I, %~navi に`関連な~realm$ )
◎
Set event's abort controller to a new AbortController created in navigation's relevant realm.
</li>
			<li>
%~event の`signal$mE ~SET %~event の`中止-制御器$nEvの`通達$aC
◎
Initialize event's signal to event's abort controller's signal.
</li>
			<li>
%現在の~URL ~LET %文書 の`~URL$doc
◎
Let currentURL be document's URL.
</li>
			<li>
<p>
%~event の`hashChange$mE ~SET ~IS ~AND↓：
</p>
				<ul>
					<li>
%~event の`古典~履歴~API用の状態$nEv ~EQ ~NULL
</li>
					<li>
%行先 の`同一-文書か$nDt~EQ ~T ;
</li>
					<li>
( %行先 の`~URL$nDt, %現在の~URL )
は、
`素片は除外する^i 下で`同等な~URL$である
</li>
					<li>
%行先 の`~URL$nDtの`素片$url ~NEQ %現在の~URL の`素片$url
</li>
				</ul>

<p class="note">注記：
上の最初の条件は、
`hashChange$mE は［
`素片への~navi$用には ~T になる
］が［
`history.pushState(undefined, "", "#fragment")^c の様な事例では ~F になる
］ことを意味する。
</p>
◎
If all of the following are true:
• event's classic history API state is null;
• destination's is same document is true;
• destination's URL equals currentURL with exclude fragments set to true; and
• destination's URL's fragment is not identical to currentURL's fragment,
◎
then initialize event's hashChange to true. Otherwise, initialize it to false.
◎
The first condition here means that hashChange will be true for fragment navigations, but false for cases like history.pushState(undefined, "", "#fragment").
</li>
			<li>
%~event の `userInitiated$mE ~SET ~IS［
%利用者-関与i ~NEQ `なし$i
］
◎
If userInvolvement is not "none", then initialize event's userInitiated to true. Otherwise, initialize it to false.
</li>
			<li>
%~event の`formData$mE ~SET ~NULL
◎
↓</li>
			<li>
~IF［
%~form~data~entry~list ~NEQ ~NULL
］
⇒
%~event の`formData$mE ~SET `新たな~obj$( `FormData$I, %~navi に`関連な~realm$ )
— その
⇒＃
【`~entry~list$ ~SET 】%~form~data~entry~list
◎
If formDataEntryList is not null, then initialize event's formData to a new FormData created in navigation's relevant realm, associated to formDataEntryList. Otherwise, initialize it to null.
</li>
		</ol>
	</li>
	<li>
~Assert：
%~navi の`進行中な~navigate_ev~event$ ~EQ ~NULL
◎
Assert: navigation's ongoing navigate event is null.
</li>
	<li>
%~navi の`進行中な~navigate_ev~event$ ~SET %~event
◎
Set navigation's ongoing navigate event to event.
</li>
	<li>
%~navi の`進行中な~naviの間に~focusは変化したか$ ~SET ~F
◎
Set navigation's focus changed during ongoing navigation to false.
</li>
	<li>
%~navi の`進行中な~naviの間は通常の~scroll復旧を抑止するか$ ~SET ~F
◎
Set navigation's suppress normal scroll restoration during ongoing navigation to false.
</li>
	<li>
%配送-結果 ~LET `~eventを配送する$( %~navi, %~event )
◎
Let dispatchResult be the result of dispatching event at navigation.
</li>
	<li>
<p>
~IF［
%配送-結果 ~EQ ~F
］：
◎
If dispatchResult is false:
</p>
		<ol>
			<li>
~IF［
%~navi種別 ~EQ `traverse$l
］
⇒
`履歴~動作による作動化を消費する$( %~navi に`関連な大域~obj$ )
◎
If navigationType is "traverse", then consume history-action user activation given navigation's relevant global object.
</li>
			<li>
~IF［
%~event の`中止-制御器$nEvの`通達$aCは`中止-済み$aBでない
］
⇒
`進行中な~naviを中止する$( %~navi )
◎
If event's abort controller's signal is not aborted, then abort the ongoing navigation given navigation.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
%終了~結果は同一-文書か ~LET ~IS［
%~event の`横取~状態$nEv ~NEQ `none^l
］~OR［
%~event の`destination$mE の`同一-文書か$nDt~EQ ~T
］
◎
Let endResultIsSameDocument be true if event's interception state is not "none" or event's destination's is same document is true.
</li>
	<li>
<p>
`~scriptを走らすために準備する$( %~navi に`関連な設定群~obj$ )
◎
Prepare to run script given navigation's relevant settings object.
</p>

<div class="note" id="note-suppress-microtasks-during-navigation-events">
<p>注記：
これは、［
すぐに起こることもある`~URLと履歴を更新する$手続き
］の結果，［
`currententrychange$et ~event~handlerが走った直後
］に［
`~JS実行~文脈~stack$が空になる
］のを避けるために行われる。
その時点で~stackが空になった場合、
即時に`小task~checkpointを遂行する$ことになる結果，
様々な~promiseの充足~handlerを［
`currententrychange$et ~event~handlerたちに差挟んで ／
`intercept()$mE【！navigateEvent.intercept()】 に渡された~handlerたちより前に
］走らすことになり，望ましくない
— それは、［
~promise~handler,
`currententrychange$et ~event~handler,
`intercept()$mE ~handler
］の順序付けが［
当の~naviが起きているのは`~JS実行~文脈~stack$が［
空なとき
（例：利用者が~naviを起動したため）／
空でないとき
（例：当の~naviは~JS~API~callにより起動されたため）
］どちらなのか
］に依存することを意味するので。
◎
This is done to avoid the JavaScript execution context stack becoming empty right after any currententrychange event handlers run as a result of the URL and history update steps that could soon happen. If the stack were to become empty at that time, then it would immediately perform a microtask checkpoint, causing various promise fulfillment handlers to run interleaved with the event handlers and before any handlers passed to navigateEvent.intercept(). This is undesirable since it means promise handler ordering vs. currententrychange event handler ordering vs. intercept() handler ordering would be dependent on whether the navigation is happening with an empty JavaScript execution context stack (e.g., because the navigation was user-initiated) or with a nonempty one (e.g., because the navigation was caused by a JavaScript API call).
</p>

<p>
この段で，他では不必要な`~JS実行~文脈$を~stackに挿入することにより、
本質的に，
`小task~checkpointを遂行する$~algoを後の時点まで抑止する
— したがって、
各種~handlerは，常に次の順に走るようになることが確保される
⇒＃
`currententrychange$et ~event~handlerたち,
`intercept()$mE ~handlerたち,
~promise~handlerたち
◎
By inserting an otherwise-unnecessary JavaScript execution context onto the stack in this step, we essentially suppress the perform a microtask checkpoint algorithm until later, thus ensuring that the sequence is always: currententrychange event handlers, then intercept() handlers, then promise handlers.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%~event の`横取~状態$nEv ~NEQ `none^l
］：
◎
If event's interception state is not "none":
</p>
		<ol>
			<li>
%~event の`横取~状態$nEv ~SET `committed^l
◎
Set event's interception state to "committed".
</li>
			<li>
%~from~NHE ~LET `~naviの現在の~entry$( %~navi )
◎
Let fromNHE be the current entry of navigation.
</li>
			<li>
~Assert：
%~from~NHE ~NEQ ~NULL
◎
Assert: fromNHE is not null.
</li>
			<li>
%~navi の`遷移$ ~SET `新たな~obj$( `NavigationTransition$I, %~navi に`関連な~realm$ )
— その
⇒＃
`~navi種別$nTr ~SET %~navi種別,
`~from~entry$nTr ~SET %~from~NHE,
`完遂-時の~promise$nTr ~SET `新たな~promise$( %~navi に`関連な~realm$ )
◎
Set navigation's transition to a new NavigationTransition created in navigation's relevant realm, whose navigation type is navigationType, whose from entry is fromNHE, and whose finished promise is a new promise created in navigation's relevant realm.
</li>
			<li>
<p>
`~promiseを取扱済みとして~markする$( %~navi の`遷移$の`完遂-時の~promise$nTr )
◎
Mark as handled navigation's transition's finished promise.
</p>

<p class="note">注記：
なぜこれが行われるか理解するには、
`他の完遂-時の~promiseについての論点＠#note-mark-as-handled-navigation-api-finished$を見よ。
◎
See the discussion about other finished promises to understand why this is done.
</p>
			</li>
			<li>
<p>
~IF［
%~navi種別 ~EQ `traverse$l
］
⇒
%~navi の`進行中な~naviの間は通常の~scroll復旧を抑止するか$ ~SET ~T
◎
If navigationType is "traverse", then set navigation's suppress normal scroll restoration during ongoing navigation to true.
</p>

<p class="note">注記：
%~event の`~scroll用の挙動$nEvが `after-transition$lS に設定された場合、
~scroll復旧は、
関連な `NavigateEvent$I を`完遂する＠#navigateevent-finish$ときの一部として起こることになる。
他の場合、
~scroll復旧は無い。
すなわち、
`intercept()$mE により横取された~naviは，
通常の~scroll復旧~処理nを経ない
— そのような~navi用の~scroll復旧は、
~web開発者により手動で行われるか，当の遷移より後に行われる。
◎
If event's scroll behavior was set to "after-transition", then scroll restoration will happen as part of finishing the relevant NavigateEvent. Otherwise, there will be no scroll restoration. That is, no navigation which is intercepted by intercept() goes through the normal scroll restoration process; scroll restoration for such navigations is either done manually, by the web developer, or is done after the transition.
</p>
			</li>
			<li>
<p>
~IF［
%~navi種別 ~IN { `push$l, `replace$l }
］
⇒
`~URLと履歴を更新する$( %文書, %~event の`destination$mE の`url$mD )
— 次を与える下で
⇒＃
`直列形の~data^i ~SET %~event の`古典~履歴~API用の状態$nEv,
`履歴~取扱い^i ~SET %~navi種別
◎
If navigationType is "push" or "replace", then run the URL and history update steps given document and event's destination's URL, with serialiedData set to event's classic history API state and historyHandling set to navigationType.
</p>

<div class="note">
<p>注記：
%~navi種別 が：
◎
↓</p>
				<ul>
					<li>
`reload$l の場合、
`再読込み＠~HTMLnav#reload$を “同一-文書への再読込み” に変換している
— この場合、
`~URLと履歴を更新する$手続きは適切にならない。
それでも、
~navi~APIに関係する~~諸々は起こる
— ［
それが `navigation.reload()$c を~callしたことによる場合に、
`作動中な~entry$nav の`~navi~API状態$shEを更新すること
］や［
すべての`進行中な~naviを追跡する＠#ongoing-navigation-tracking$こと
］など。
◎
If navigationType is "reload", then we are converting a reload into a "same-document reload", for which the URL and history update steps are not appropriate. Navigation API-related stuff still happens, such as＼
updating the active session history entry's navigation API state if this was caused by a call to navigation.reload(),＼
and all the ongoing navigation tracking.
</li>
					<li>
`traverse$l の場合、
この~event発火は，
`辿-用に履歴~stepを適用する$一部として起きている
— その処理nが
適切な~session履歴~entry更新を遂行するよう~careすることになる。
◎
If navigationType is "traverse", then this event firing is happening as part of the traversal process, and that process will take care of performing the appropriate session history entry updates.
</li>
				</ul>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%終了~結果は同一-文書か ~EQ ~T
］：
◎
If endResultIsSameDocument is true:
</p>
		<ol>
			<li>
%~promise~list ~LET 新たな`~list$
◎
Let promisesList be an empty list.
</li>
			<li>
%~event の`~navi~handler~list$nEvを成す
~EACH( %~handler )
に対し
⇒
%~promise~list に次の結果を`付加する$
⇒
`~callback関数を呼出す$( %~handler, « », ε )
◎
For each handler of event's navigation handler list:
• Append the result of invoking handler with an empty arguments list to promisesList.
</li>
			<li>
<p>
~IF［
%~promise~list の`~size$ ~EQ 0
］
⇒
%~promise~list ~SET « `解決される~promise$( `undefined^jv ) »
◎
If promisesList's size is 0, then set promisesList to « a promise resolved with undefined ».
</p>

<p class="note">注記：
`すべての~promiseを待機する$間に，その［
成功~手続き, 失敗~手続き
］をどう~scheduleするかに関して、
所与の~promiseが［
無いとき, 1 個以上あるとき
］で微妙な時機の相違がある。
これは、
`すべての~promiseを待機する$ほとんどの利用には~~影響しない。
しかしながら、
この~APIには，同時期に発火することもある［
~event~handler, ~promise~handler
］がいくつもあるので、
その相違はかなり容易に観測-可能になる
— それは、［
~event／~promise
］~handlerが走る順序を変え得るので。
（そこに孕まれる［
~event／~promise
］には次が含まれる
⇒＃
`navigatesuccess$et ／
`navigateerror$et ／
`currententrychange$et ／
`dispose$et ／
%~API~method追跡子 の~promise／
`navigation.transition.finished$c ~promise）
◎
There is a subtle timing difference between how waiting for all schedules its success and failure steps when given zero promises versus ≥1 promises. For most uses of waiting for all, this does not matter. However, with this API, there are so many events and promise handlers which could fire around the same time that the difference is pretty easily observable: it can cause the event/promise handler sequence to vary. (Some of the events and promises involved include: navigatesuccess / navigateerror, currententrychange, dispose, apiMethodTracker's promises, and the navigation.transition.finished promise.)
</p>
			</li>
			<li>
<p>
`すべての~promiseを待機する$( %~promise~list )
— 次を与える下で：
◎
Wait for all of promisesList, with＼
</p>
				<ul>
					<li class="algo">
<p>
`成功~手続き^i は：
◎
the following success steps:
</p>
						<ol>
							<li>
~IF［
%~event に`関連な大域~obj$は`全部的に作動中$でない
］
⇒
~RET
◎
If event's relevant global object is not fully active, then abort these steps.
</li>
							<li>
~IF［
%~event の`中止-制御器$nEvの`通達$aCは`中止-済み$aBである
］
⇒
~RET
◎
If event's abort controller's signal is aborted, then abort these steps.
</li>
							<li>
~Assert：
%~event ~EQ %~navi の`進行中な~navigate_ev~event$
◎
Assert: event equals navigation's ongoing navigate event.
</li>
							<li>
%~navi の`進行中な~navigate_ev~event$ ~SET ~NULL
◎
Set navigation's ongoing navigate event to null.
</li>
							<li>
`~navigate_ev~eventを完遂する$( %~event, ~T )
◎
Finish event given true.
</li>
							<li>
`~eventを発火する$( %~navi, `navigatesuccess$et )
◎
Fire an event named navigatesuccess at navigation.
</li>
							<li>
~IF［
%~navi の`遷移$ ~NEQ ~NULL
］
⇒
`~promiseを解決する$( %~navi の`遷移$の`完遂-時の~promise$nTr )
◎
If navigation's transition is not null, then resolve navigation's transition's finished promise with undefined.
</li>
							<li>
%~navi の`遷移$ ~SET ~NULL
◎
Set navigation's transition to null.
</li>
							<li>
~IF［
%~API~method追跡子 ~NEQ ~NULL
］
⇒
`完遂-時の~promiseを解決する$( %~API~method追跡子 )
◎
If apiMethodTracker is non-null, then resolve the finished promise for apiMethodTracker.
</li>
						</ol>
					</li>
					<li class="algo">
<p>
`失敗~手続き^i は、
所与の
( %却下~事由 )
に対し：
◎
and the following failure steps given reason rejectionReason:
</p>
						<ol>
							<li>
~IF［
%~event に`関連な大域~obj$は`全部的に作動中$でない
］
⇒
~RET
◎
If event's relevant global object is not fully active, then abort these steps.
</li>
							<li>
~IF［
%~event の`中止-制御器$nEvの`通達$aCは`中止-済み$aBである
］
⇒
~RET
◎
If event's abort controller's signal is aborted, then abort these steps.
</li>
							<li>
~Assert：
%~event ~EQ %~navi の`進行中な~navigate_ev~event$
◎
Assert: event equals navigation's ongoing navigate event.
</li>
							<li>
%~navi の`進行中な~navigate_ev~event$ ~SET ~NULL
◎
Set navigation's ongoing navigate event to null.
</li>
							<li>
`~navigate_ev~eventを完遂する$( %~event, ~F )
◎
Finish event given false.
</li>
							<li>
%~error報 ~LET `~error情報を抽出する$( %却下~事由 )
◎
Let errorInfo be the result of extracting error information from rejectionReason.
</li>
							<li>
`~eventを発火する$( %~navi, `navigateerror$et, `ErrorEvent$I )
— 次のように初期化して
⇒＃
`ErrorEvent$I による追加的な各~属性を %~error報 に則って設定する
◎
Fire an event named navigateerror at navigation using ErrorEvent, with additional attributes initialized according to errorInfo.
</li>
							<li>
~IF［
%~navi の`遷移$ ~NEQ ~NULL
］
⇒
`~promiseを却下する$( %~navi の`遷移$の`完遂-時の~promise$nTr, %却下~事由 )
◎
If navigation's transition is not null, then reject navigation's transition's finished promise with rejectionReason.
</li>
							<li>
%~navi の`遷移$ ~SET ~NULL
◎
Set navigation's transition to null.
</li>
							<li>
~IF［
%~API~method追跡子 ~NEQ ~NULL
］
⇒
`完遂-時の~promiseを却下する$( %~API~method追跡子, %却下~事由 )
◎
If apiMethodTracker is non-null, then reject the finished promise for apiMethodTracker with rejectionReason.
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~ELIF［
%~API~method追跡子 ~NEQ ~NULL
］
⇒
`追跡子を片付ける$( %~API~method追跡子 )
◎
Otherwise, if apiMethodTracker is non-null, then clean up apiMethodTracker.
</li>
	<li>
<p>
`走らせた~scriptを片付ける$( %~navi に`関連な設定群~obj$ )
◎
Clean up after running script given navigation's relevant settings object.
</p>

<p class="note">注記：
`上の注記＠#note-suppress-microtasks-during-navigation-events$の一環として、
これは，この時点で、
~promise~handler用の小task（もしあれば）を抑止することを止めて，
それが走れるようにする。
◎
Per the previous note, this stops suppressing any potential promise handler microtasks, causing them to run at this point or later.
</p>
	</li>
	<li>
~RET ~IS［
%~event の`横取~状態$nEv ~EQ `none^l
］
◎
If event's interception state is "none", then return true.
◎
Return false.
</li>
</ol>
</div>

					</section>
					<section id="navigate-event-scroll-focus">
<h6 title="Scroll and focus behavior">7.2.6.10.4. ~scrollと~focusの挙動</h6>

<p>
`intercept()$mE【！navigateEvent.intercept()】 を~callすることにより、
~web開発者は，
同一-文書への~navi用には，通常の［
~scroll用の挙動／~focus用の挙動
］を抑止する代わりに，後の時点にて［
非同一-文書への~naviの様な挙動
］を呼出せる。
この節に与える各~algoは、
そのような適切な後の時点に~callされる。
◎
By calling navigateEvent.intercept(), web developers can suppress the normal scroll and focus behavior for same-document navigations, instead invoking cross-document navigation-like behavior at a later time. The algorithms in this section are called at those appropriate later points.
</p>

<div class="algo">
<p>
`~navigate_ev~eventを完遂する@
ときは、
所与の
( `NavigateEvent$I %~event, 真偽値 %充足-済みか )
に対し：
◎
To finish a NavigateEvent event, given a boolean didFulfill:
</p>
<ol>
	<li>
~Assert：
%~event の`横取~状態$nEv ~NIN { `intercepted^l, `finished^l }
◎
Assert: event's interception state is not "intercepted" or "finished".
</li>
	<li>
~IF［
%~event の`横取~状態$nEv ~EQ `none^l
］
⇒
~RET
◎
If event's interception state is "none", then return.
</li>
	<li>
`必要なら~focusを設定し直す$( %~event )
◎
Potentially reset the focus given event.
</li>
	<li>
~IF［
%充足-済みか ~EQ ~T
］
⇒
`必要なら~scroll用の挙動を処理する$( %~event )
◎
If didFulfill is true, then potentially process scroll behavior given event.
</li>
	<li>
%~event の`横取~状態$nEv ~SET `finished^l
◎
Set event's interception state to "finished".
</li>
</ol>
</div>

<div class="algo">
<p>
`必要なら~focusを設定し直す@
ときは、
所与の
( `NavigateEvent$I %~event )
に対し：
◎
To potentially reset the focus given a NavigateEvent event:
</p>
<ol>
	<li>
~Assert：
%~event の`横取~状態$nEv ~IN { `committed^l, `scrolled^l }
◎
Assert: event's interception state is "committed" or "scrolled".
</li>
	<li>
%~navi ~LET %~event に`関連な大域~obj$の`~navi~API$
◎
Let navigation be event's relevant global object's navigation API.
</li>
	<li>
%~focusは変化したか ~LET %~navi の`進行中な~naviの間に~focusは変化したか$
◎
Let focusChanged be navigation's focus changed during ongoing navigation.
</li>
	<li>
%~navi の`進行中な~naviの間に~focusは変化したか$ ~SET ~F
◎
Set navigation's focus changed during ongoing navigation to false.
</li>
	<li>
~IF［
%~focusは変化したか ~EQ ~T
］
⇒
~RET
◎
If focusChanged is true, then return.
</li>
	<li>
<p>
~IF［
%~event の`~focusを設定し直す挙動$nEv ~EQ `manual$lF
］
⇒
~RET
◎
If event's focus reset behavior is "manual", then return.
</p>

<p class="note">注記：
~NULL のままにされた場合、
`after-transition$lF として扱った上で以降を継続する。
◎
If it was left as null, then we treat that as "after-transition", and continue onward.
</p>
	</li>
	<li>
%文書 ~LET %~event に`関連な大域~obj$に`結付けられた文書$
◎
Let document be event's relevant global object's associated Document.
</li>
	<li>
%~focus~target ~LET `自動focus委任-先$( %文書 )
◎
Let focusTarget be the autofocus delegate for document.
</li>
	<li>
~IF［
%~focus~target ~EQ ~NULL
］
⇒
%~focus~target ~SET %文書 の`~body要素$
◎
If focusTarget is null, then set focusTarget to document's body element.
</li>
	<li>
~IF［
%~focus~target ~EQ ~NULL
］
⇒
%~focus~target ~SET %文書 の`文書~要素$
◎
If focusTarget is null, then set focusTarget to document's document element.
</li>
	<li>
`~objを~focusする$( %~focus~target, %文書 の`表示域$ )
◎
Run the focusing steps for focusTarget, with document's viewport as the fallback target.
</li>
	<li>
`逐次的~focus~naviの始点$ ~SET %~focus~target
◎
Move the sequential focus navigation starting point to focusTarget.
</li>
</ol>
</div>

<div class="algo">
<p>
`必要なら~scroll用の挙動を処理する@
ときは、
所与の
( `NavigateEvent$I %~event )
に対し：
◎
To potentially process scroll behavior given a NavigateEvent event:
</p>
<ol>
	<li>
~Assert：
%~event の`横取~状態$nEv ~IN { `committed^l, `scrolled^l }
◎
Assert: event's interception state is "committed" or "scrolled".
</li>
	<li>
~IF［
%~event の`横取~状態$nEv ~EQ `scrolled^l
］
⇒
~RET
◎
If event's interception state is "scrolled", then return.
</li>
	<li>
<p>
~IF［
%~event の`~scroll用の挙動$nEv ~EQ `manual$lS
］
⇒
~RET
◎
If event's scroll behavior is "manual", then return.
</p>

<p class="note">注記：
~NULL のままにされた場合、
`after-transition$lS として扱った上で以降を継続する。
◎
If it was left as null, then we treat that as "after-transition", and continue onward.
</p>
	</li>
	<li>
`~scroll用の挙動を処理する$( %~event )
◎
Process scroll behavior given event.
</li>
</ol>
</div>

<div class="algo">
<p>
`~scroll用の挙動を処理する@
ときは、
所与の
( `NavigateEvent$I %~event )
に対し：
◎
To process scroll behavior given a NavigateEvent event:
</p>
<ol>
	<li>
~Assert：
%~event の`横取~状態$nEv ~EQ `committed^l
◎
Assert: event's interception state is "committed".
</li>
	<li>
%~event の`横取~状態$nEv ~SET `scrolled^l
◎
Set event's interception state to "scrolled".
</li>
	<li>
~IF［
%~event の `navigationType$mE ~IN { `traverse$l, `reload$l }
］
⇒
`~scroll位置~dataを復旧する$( %~event に`関連な大域~obj$に`対応する~navigable$にて`作動中な~entry$nav )
◎
If event's navigationType was initialized to "traverse" or "reload", then restore scroll position data given event's relevant global object's navigable's active session history entry.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%文書 ~LET %~event に`関連な大域~obj$に`結付けられた文書$
◎
Let document be event's relevant global object's associated Document.
</li>
			<li>
~IF［
%文書 の`指示された部位$doc ~EQ ~NULL
］
⇒
`文書の開始位置に~scrollする$( %文書 )
`CSSOMVIEW$r
◎
If document's indicated part is null, then scroll to the beginning of the document given document. [CSSOMVIEW]
</li>
			<li>
~ELSE
⇒
`素片へ~scrollする$( %文書 )
◎
Otherwise, scroll to the fragment given document.
</li>
		</ol>
	</li>
</ol>
</div>

					</section>
				</section>
			</section>
			<section id="nav-traversal-event-interfaces">
<h4 title="Event interfaces">7.2.7. ~event~interface</h4>

<p class="trans-note">【
この節を成す他の下位節の内容は、
`別~pageにて＠~WINDOW#nav-traversal-event-interfaces$
】</p>

				<section id="the-pageswapevent-interface">
<h5 title="The PageSwapEvent interface">7.2.7.4. `PageSwapEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageSwapEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageSwapEventInit$I %eventInitDict = {});
  readonly attribute `NavigationActivation$I? `activation$mPSe;
  readonly attribute `ViewTransition$I? `viewTransition$mPSe;
};

dictionary `PageSwapEventInit@I : `EventInit$I {
  `NavigationActivation$I? `activation@mb = null;
  `ViewTransition$I? `viewTransition@mb = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`activation$mPSe</dt>
	<dd>
非同一-文書な~naviの行先と種別を表現する `NavigationActivation$I ~objを返す。
ただし、
非同一-生成元な~navi用には ~NULL を返す。
◎
A NavigationActivation object representing the destination and type of the cross-document navigation. This would be null for cross-origin navigations.
</dd>

	<dt>%event.`activation$mPSe.`entry$mNA</dt>
	<dd>
作動中になりつつある`文書$を表現する `NavigationHistoryEntry$I ~objを返す。
◎
A NavigationHistoryEntry, representing the Document that is about to become active.
</dd>

	<dt>%event.`activation$mPSe.`from$mNA</dt>
	<dd>
当の~eventが発火される時点における `currentEntry$mN ~propの値と等価な `NavigationHistoryEntry$I を返す。
◎
A NavigationHistoryEntry, equivalent to the value of the navigation.currentEntry property at the moment the event is fired.
</dd>

	<dt>%event.`activation$mPSe.`navigationType$mNA</dt>
	<dd>
`pageswap^et による結果の~naviの種別を指示する値として、［
`push$l ／
`replace$l ／
`reload$l ／
`traverse$l
］を返す。
◎
One of "push", "replace", "reload", or "traverse", indicating what type of navigation that is about to result in a page swap.
</dd>

	<dt>%event.`viewTransition$mPSe</dt>
	<dd>
当の~eventが発火される時点で，外へ出る†非同一-文書な~view遷移が作動中ならば、
それを表現する `ViewTransition$I ~objを返す。
他の場合は ~NULLを返す。
◎
Returns the ViewTransition object that represents an outbound cross-document view transition, if such transition is active when the event is fired. Otherwise, returns null.
</dd>
	<dd class="trans-note">【†
“外へ出る （ `outbound^en ）” とは、
2 つある~view遷移
— 旧-文書におけるそれ, 新-文書におけるそれ —
のうち，前者に属する方を意味する。
】</dd>
</dl>

<p>
`activation@mPSe
／
`viewTransition@mPSe
属性は、
初期化-時の値を返すモノトスル。
◎
The activation and viewTransition attributes must return the values they were initialized to.
</p>

				</section>
				<section id="the-pagerevealevent-interface">
<h5 title="The PageRevealEvent interface">7.2.7.5. `PageRevealEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageRevealEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageRevealEventInit$I %eventInitDict = {});
  readonly attribute `ViewTransition$I? `viewTransition$mPRe;
};

dictionary `PageRevealEventInit@I : `EventInit$I {
  `ViewTransition$I? `viewTransition＠#dom-pagerevealeventinit-viewtransition@mb = null;
};
</pre>

<dl class="domintro">
	<dt>%event.`viewTransition$mPRe</dt>
	<dd>
当の~eventが発火された時点で内へ来る†非同一-文書な~view遷移が作動中であるならば，
それを表現する `ViewTransition$I ~objを返す
— 他の場合、
~NULL を返す。
◎
Returns the ViewTransition object that represents an inbound cross-document view transition, if such transition is active when the event is fired. Otherwise, returns null.
</dd>
	<dd class="trans-note">【†
“内へ来る （ `inbound^en ）” とは、
2 つある~view遷移
— 旧-文書におけるそれ, 新-文書におけるそれ —
のうち，後者に属する方を意味する。
】</dd>
</dl>

<p>
`viewTransition@mPRe
取得子は、
初期化-時の値を返すモノトスル。
◎
The viewTransition attribute must return the value it was initialized to.
</p>

				</section>
				<section id="the-pagetransitionevent-interface">
<h5 title="The PageTransitionEvent interface">7.2.7.6. `PageTransitionEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageTransitionEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageTransitionEventInit$I %eventInitDict = {});

  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event.`persisted$m</dt>
	<dd>
`pageshow$et ~eventに対しては、［
当の~pageが新たに読込まれつつある（したがって `load$et ~eventが発火されることになる）ならば ~F ／
~ELSE_ ~T
］を返す。
◎
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventに対しては、［
当の~pageが最後に消え去るときには ~F ／
~ELSE_ ~T
］を返す。
~T は、
この~pageは，利用者がこの~pageに~navigateして戻った場合に
（かつ，当の`文書$の`回復可能~状態$docが ~T のままであれば）
再利用され得ることを意味する。
◎
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that the page might be reused if the user navigates back to this page (if the Document's salvageable state stays true).
</dd>
	<dd>
<p>
~pageを回復可能でなくするものには、
次が含まれる：
◎
Things that can cause the page to be unsalvageable include:
</p>
		<ul>
			<li>
~UAは、
当の`文書を~unload＠~HTMLlifecycle#unload-a-document$した後に，［
その文書は，`~session履歴~entry$内で生存し続けない
］ものと裁定した
◎
The user agent decided to not keep the Document alive in a session history entry after unload
</li>
			<li>
`回復可能＠~HTMLlifecycle#concept-document-salvageable$でない `iframe$e があるとき
◎
Having iframes that are not salvageable
</li>
			<li>
作動中な `WebSocket$I ~objがあるとき
◎
Active WebSocket objects
</li>
			<li>
`文書を中止した＠~HTMLlifecycle#abort-a-document$とき
◎
Aborting a Document
</li>
		</ul>
	</dd>
</dl>

<dl class="idl-def">
	<dt>
`persisted@m
◎
The persisted attribute＼
</dt>
	<dd>
取得子は、
初期化-時の値を返すモノトスル。
◎
must return the value it was initialized to.＼
</dd>
	<dd>
これは~eventの文脈~情報を表現する。
◎
It represents the context information for the event.
</dd>
</dl>

<div class="algo">
<p>
`~page遷移~eventを発火する@
ときは、
所与の
( `Window$I %~window, %~event名, 真偽値 %持続されるか )
に対し
⇒
`~eventを発火する$( %~window, %~event名, `PageTransitionEvent$I )
— `~targetを上書きする^i 下で，および次のように初期化して
⇒＃
`persisted$m 属性 ~SET %持続されるか,
`cancelable$m 属性 ~SET ~T,
`bubbles$m 属性 ~SET ~T
◎
To fire a page transition event named eventName at a Window window with a boolean persisted, fire an event named eventName at window, using PageTransitionEvent, with the persisted attribute initialized to persisted, the cancelable attribute initialized to true, the bubbles attribute initialized to true, and legacy target override flag set.
</p>

<p class="note">注記：
`cancelable$m, `bubbles$m 用の値は、
イミを成さない
— 当の~eventを取消しても何もしないし，
`Window$I ~objを過ぎて浮上することはアリでないので。
これらが ~T に設定されるのは、
歴史的な理由による。
◎
The values for cancelable and bubbles don't make any sense, since canceling the event does nothing and it's not possible to bubble past the Window object. They are set to true for historical reasons.
</p>
</div>

				</section>
			</section>
</main>
