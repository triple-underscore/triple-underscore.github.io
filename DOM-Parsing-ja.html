<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>DOM Parsing and Serialization （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`;
	break;
case 'U':
	text = `<span class="code-point">U+${key}</span> (<span class="char-symbol">&#x${key};</span>)`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-02-28
trans_update:2025-03-01
source_checked:171103
original_url:https://w3c.github.io/DOM-Parsing/
spec_status:ED
ref_id_prefix:bib-
copyright:2025,permissive
trans_1st_pub:2017-08-03


●●class_map
E:error
P:production
v:value
e:element
a:attr
	U:code-point

●●tag_map
I:code
E:code
m:code
mA:code
P:code
e:code
a:code
c:code
	U:span
i:i
v:code
V:var


●●words_table1

SPACE:<span class="code-point">U+0020</span> <span class="cp-name">SPACE</span>
XML10:https://www.w3.org/TR/xml/


●●words_table

	●markup／ns／構文／往復
ns:namespace:::名前空間
	局所~名:localname
	局所的に定義されlocally-defined
有修飾:qualified::~
XMLNS:
XHTML:
void:
整形式:well-formed::~
直列形の:serialized::~::シリアル形の
	再~宣言-:redeclare
未宣言に:undeclare::~
	終端-:end

	●DOM／データ構造／データ操作
template:
変形-:transform::~

	組:pair
	有順序:ordered
	組:tuple
	leaf-node:
	attr
	先祖たち:ancestry
	On getting
	association
	associated
	操作する:manipulation

	●一般処理
渡され:passされ:~
渡して:passして:~
	渡し
	invoking
	-:conditional
	-:visit


	●仕様
昇格基準:exit criteria:~
理想的:ideal:~
一律:uniform:~
単体的:monolithic:~
合法:legal:~

	要約-:summary
	〜得る:possible
	~~合法:legitimate
	~~条件:qualifications
	flavor
	込み入って:tricky
	参考:informative
	謝意:thank
	に感謝:acknowledge with gratitude
	より深い:greater
	かまわない:OK
	~~作者:you

	●仕様（動詞
仕事:work:~
	従う:as follows
	-:provide
競合-:conflict:~
	-:applicable
	編成し直した:Editorial restructuring
	されないようにする:side-effect of avoiding
	-:assume
	-:in a conforming XML parser

	●未分類（動詞
連結:concatenation::~
遭遇-:encounter:~
代用-:substitute:~
	~~代用され:substitute

	予約-済み:reserved
	~~代用の:replacement
	生き残る:survive
	出くわした:seen
	見られる:seen
	失われ:loss
	近くなる:get closer
	見せかけた:made to look like
	ことになる:get


	●未分類
同一性:identity:~
	~memory内:in-memory
	perror:parse error::構文解析 error:構文解析エラー:パースエラー
	-:label
候補:candidate:~
近過去:recent:~
	-:per
	-:passing
	-:caller
	-:Re-throw
	map:mapping
	followed
	この時点で／:At this point
	seen
	potentially
	-:iterating
	-:beginning
	-:at least
	most recently used
	MRU
	OK
	-:together
	-:consisting
	-:furthermore
	-:occurrence
	LESS-THAN SIGN
	QUESTION MARK
	GREATER-THAN
	WHATWG
	we
	数値 numerical value
	-:respective
	-:wereas
	-:additionally
	taken
	-:go
	並び:adjacent


	●指示語
	より早く:earlier
	次:next
	各種:various
	他方:wereas
	任意個数の:any number
	高々:at most
	それまでに:previously
	直前／前回／-:previous
	以降の／remaining
	即:immediate
	より~~過去の:older


●●original_id_map

	xml-serializing-an-element-node:dfn-xml-serializing-an-element-node
	xml-serializing-a-comment-node:dfn-xml-serializing-a-comment-node
	xml-serializing-a-document-node:dfn-xml-serializing-a-document-node
	xml-serializing-a-documentfragment-node:dfn-xml-serializing-a-documentfragment-node
	xml-serializing-a-documenttype-node:dfn-xml-serializing-a-documenttype-node
	xml-serializing-a-processinginstruction-node:dfn-xml-serializing-a-processinginstruction-node
	xml-serializing-a-text-node:dfn-xml-serializing-a-text-node


●●mdn_urls
xmlserializer:API/XMLSerializer

●●link_map

	●IDL

E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
E.InvalidStateError:~WEBIDL#invalidstateerror

I.Attr:~DOM4#attr
I.Comment:~DOM4#comment
I.Document:~DOM4#document
I.DocumentFragment:~DOM4#documentfragment
I.DocumentType:~DOM4#documenttype
I.Element:~DOM4#element
I.Node:~DOM4#node
I.ProcessingInstruction:~DOM4#processinginstruction
I.Text:~DOM4#text

m.innerHTML:~HTMLdynamic#dom-element-innerhtml

	＠~HTMLdynamic#dom-element-outerhtml
	＠~DOM4#dom-element-setattribute
	＠~DOM4#dom-element-namespaceuri
	＠~HTMLdynamic#dom-element-insertadjacenthtml
	＠~HTMLdynamic#dom-xmlserializer-constructor
	＠~HTMLdynamic#dom-xmlserializer-serializetostring

e.script:~HEscripting#the-script-element
e.template:~HEscripting#the-template-element

P.AttValue:~XML10#NT-AttValue
P.Char:~XML10#NT-Char
P.EmptyElemTag:~XML10#NT-EmptyElemTag
P.Name:~XML10#NT-Name
P.PubidChar:~XML10#NT-PubidChar


	●用語
構文解析:#dfn-parsing
直列化-:#dfn-serializing
~XML直列化:#dfn-xml-serialization
往復-:#dfn-round-tripping

属性~値を直列化する:#dfn-serializing-an-attribute-value
~XMLに直列化する:#dfn-xml-serialization-algorithm
~nodeを~XMLに直列化する:#dfn-xml-serialization-algorithm
型の~nodeを~XMLに直列化する:#dfn-producing-an-xml-serialization-of-a-dom-node
要素の属性たちを~XMLに直列化する:#dfn-xml-serialization-of-the-attributes

	i.Loop:#dfn-loop
	i.Main:#dfn-main

	:#dfn-found-a-suitable-namespace-prefix

~ns接頭辞~map:#dfn-namespace-prefix-map
~ns接頭辞~list:#dfn-list

接頭辞が見出されるか否か:#dfn-found
~ns接頭辞~mapを複製する:#dfn-copy-a-namespace-prefix-map
接頭辞を生成する:#dfn-generating-a-prefix
	~ns接頭辞~生成-用~index:#dfn-generated-namespace-prefix-index
接頭辞~mapに追加する:#dfn-add

要素の~ns情報を記録する:#dfn-recording-the-namespace-information
選好される接頭辞~文字列を検索取得する:#dfn-retrieving-a-preferred-prefix-string

V.有修飾~名:#dfn-qualified-name
V.文脈~ns:#dfn-context-namespace
	V.文脈~ns:#dfn-namespace
V.~ns定義~属性を無視するか:#dfn-ignore-namespace-definition-attribute
V.接頭辞~map:#dfn-prefix-map
	V.継承される~ns:#dfn-inherited-ns
V.局所的な既定の~ns:#dfn-local-default-namespace
V.局所~接頭辞~map:#dfn-local-prefixes-map
V.接頭辞~index:#dfn-prefix-index
V.整形式が要求されるか:#dfn-require-well-formed
	＊#dfn-skip-end-tag

	●用語（DOM
~node:~DOM4#concept-node
文書:~DOM4#concept-document
~HTML文書:~DOM4#html-document
doc.種別:~DOM4#concept-document-type

属性:~DOM4#concept-attribute
A.値:~DOM4#concept-attribute-value
A.~ns:~DOM4#concept-attribute-namespace
A.~ns接頭辞:~DOM4#concept-attribute-namespace-prefix
A.局所~名:~DOM4#concept-attribute-local-name
A.有修飾~名:~DOM4#concept-attribute-qualified-name
	mA.name

要素:~DOM4#concept-element
属性~list:~DOM4#concept-element-attribute
eL.~ns接頭辞:~DOM4#concept-element-namespace-prefix
eL.~ns:~DOM4#concept-element-namespace
eL.局所~名:~DOM4#concept-element-local-name

	doctype:#dfn-doctype
	:~DOM4#dom-document-doctype
dT.名前:~DOM4#concept-doctype-name
dT.公な~ID:~DOM4#concept-doctype-publicid
dT.~system~ID:~DOM4#concept-doctype-systemid

~data:~DOM4#concept-cd-data
pI.~target:~DOM4#concept-pi-target
文書~要素:~DOM4#document-element
子:~DOM4#concept-tree-child
子~群:~DOM4#concept-tree-child
~tree順序:~DOM4#concept-tree-order

	●用語（他
~map:~INFRA#ordered-map
map.~key群:~INFRA#map-getting-the-keys
~list:~INFRA#list
~cloneする:~INFRA#list-clone
~ASCII大小無視:~INFRA#ascii-case-insensitive
~HTML~ns:~INFRA#html-namespace
~XML~ns:~INFRA#xml-namespace
~XMLNS~ns:~INFRA#xmlns-namespace

~template内容:~HEscripting#template-contents

~HTML構文解析器:~HTMLparsing#html-parser
文脈~要素:~HTMLparsing#concept-frag-parse-context
~void要素:~HTMLwriting#void-elements

~XHTML文書を構文解析-:~HTMLxml#parsing-xhtml-documents
~XML構文解析器:~HTMLxml#xml-parser

空~要素~tag:~XML10#dt-eetag


●●ref_normative

[DOM4]
    ＜DOM Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMA-262]
    ＜ECMAScript Language Specification＞.  Ecma International. URL: https://tc39.es/ecma262/multipage/
[HTML5]
    ＜HTML5＞. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O'Connor; Silvia Pfeiffer.  W3C. 27 March 2018. W3C Recommendation. URL: https://www.w3.org/TR/html5/
[WEBIDL]
    ＜Web IDL Standard＞. Edgar Chen; Timothy Gu.  WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/
[XML10]
    ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. Tim Bray; Jean Paoli; Michael Sperberg-McQueen; Eve Maler; François Yergeau et al.  W3C. 26 November 2008. W3C Recommendation. URL: https://www.w3.org/TR/xml/

●●ref_additional
[HTML]
    ＜HTML Standard＞. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters.  WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    ＜Infra Standard＞. Anne van Kesteren; Domenic Denicola.  WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">DOM Parsing and Serialization</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/DOM-Parsing/
編集者草案
	https://w3c.github.io/DOM-Parsing/

編集
	<a href="mailto:travis.leithead@microsoft.com">Travis Leithead</a> (Microsoft)

テスト一式
	http://w3c-test.org/domparsing/
	http://w3c-test.org/html/syntax/

Participate:
	<a href="https://github.com/w3c/DOM-Parsing">We are on Github.</a>
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?component=DOM%20Parsing%20and%20Serialization&amp;list_id=44989&amp;product=WebAppsWG&amp;resolution=---">Bugzilla Bug list.</a>
	<a href="https://github.com/w3c/DOM-Parsing/issues">Github Issues.</a>
	<a href="https://github.com/w3c/DOM-Parsing/commits">Commit history.</a>
	<a href="https://lists.w3.org/Archives/Public/www-dom/">Mailing list.</a>

</script>

<!-- 原文 id／link

I.DOMException:#dfn-domexception
I.DOMException:~DOM4#domexception

E.TypeError:#dfn-typeerror
E.InvalidStateError:#dfn-invalidstateerror
E.InvalidStateError:~DOM4#invalidstateerror

I.Attr:~DOM4#interface-attr
I.Attr:#dfn-attr
I.Comment:#dfn-comment
I.Comment:~DOM4#interface-comment
I.Document:#dfn-document
I.DocumentFragment:#dfn-documentfragment
	~doctype:~DOM4#concept-doctype
I.DocumentType:#dfn-documenttype
I.DocumentType:~DOM4#interface-documenttype
I.Element:#dfn-element
I.Node:#dfn-node
~node:#dfn-node
I.ProcessingInstruction:#dfn-processinginstruction
I.ProcessingInstruction:~DOM4#interface-processinginstruction
I.Text:#dfn-text
I.Text:~DOM4#interface-text

m.setAttribute:#dfn-setattribute
m.createContextualFragment:#idl-def-range-createcontextualfragment%28fragment%29
e.script:#dfn-script
e.script:~TR/html5/single-page.html#script
e.template:#dfn-template
e.template:~TR/html5/single-page.html#the-template-element

P.AttValue:#dfn-attvalue
P.Char:#dfn-char
P.EmptyElemTag:#dfn-emptyelemtag
P.Name:#dfn-name
P.PubidChar:#dfn-pubidchar


	●

	#dfn-xml-serializing
コレ:#dfn-context-object
:#dfn-skip-end-tag
空~要素~tag:#dfn-empty-element-tag
例外を投出-:#dfn-exception
~ASCII大小無視:#dfn-ascii-case-insensitive
~ASCII大小無視:~TR/dom/#ascii-case-insensitive
~HTML~ns:#dfn-html-namespace
~XML~ns:#dfn-xml-namespace
~XMLNS~ns:#dfn-xmlns-namespace
case-sensitive:#dfn-case-sensitive
case-sensitive:~TR/dom/#case-sensitive


	■HTML5
~template内容:#dfn-template-contents
~template内容:~TR/html5/single-page.html#template-contents
~HTML構文解析器:#dfn-html-parser
~HTML構文解析器:~TR/html5/single-page.html#html-parser
~XHTML文書を構文解析-:#dfn-parsing-xhtml-documents
~XHTML文書を構文解析-:~TR/html5/single-page.html#parsing-xhtml-documents
~XML構文解析器:#dfn-xml-parser
~XML構文解析器:~TR/html5/single-page.html#xml-parser

~void要素:#dfn-void-elements
~void要素:~TR/html5/single-page.html#void-elements
文脈~要素:#dfn-context
文脈~要素:~TR/html5/single-page.html#concept-frag-parse-context


	●DOM

属性~list:~DOM4#concept-element-attribute
m.attributes:~DOM4#dom-element-attributes
m.attributes:#dfn-attributes

A.値:~DOM4#concept-attribute-value
mA.value:~DOM4#dom-attr-value
mA.value:#dfn-attr.value
A.~ns:~DOM4#concept-attribute-namespace
mA.namespaceURI:~DOM4#dom-attr-namespaceuri
mA.namespaceURI:#dfn-attr.namespaceuri
A.~ns接頭辞:~DOM4#concept-attribute-namespace-prefix
mA.prefix:~DOM4#dom-attr-prefix
mA.prefix:#dfn-attr.prefix
A.局所~名:~DOM4#concept-attribute-local-name
mA.localName:~DOM4#dom-attr-localname
mA.localName:#dfn-attr.localname
A.有修飾~名:~DOM4#concept-attribute-qualified-name
mA.name

eL.~ns接頭辞:~DOM4#concept-element-namespace-prefix
m.prefix:~DOM4#dom-element-prefix
m.prefix:#dfn-element.prefix

eL.~ns:~DOM4#concept-element-namespace
m.namespaceURI:~DOM4#dom-element-namespaceuri
m.namespaceURI:#dfn-element.namespaceuri
eL.局所~名:~DOM4#concept-element-local-name
m.localName:~DOM4#dom-element-localname
m.localName:#dfn-element.localname

dT.~system~ID:~DOM4#concept-doctype-systemid
m.systemId:~DOM4#dom-documenttype-systemid
m.systemId:#dfn-systemid
dT.公な~ID:~DOM4#concept-doctype-publicid
m.publicId:~DOM4#dom-documenttype-publicid
m.publicId:#dfn-publicid
dT.名前:~DOM4#concept-doctype-name
m.name:~DOM4#dom-documenttype-name

~data:~DOM4#concept-cd-data
m.data:~DOM4#dom-characterdata-data
m.data:#dfn-data

文書~要素:~DOM4#document-element
m.documentElement:~DOM4#dom-document-documentelement
m.documentElement:#dfn-documentelement

pI.~target:~DOM4#concept-pi-target
m.target:~DOM4#dom-processinginstruction-target
m.target:#dfn-target
doctype:#dfn-doctype
doctype:~DOM4#dom-document-doctype
m.name:~DOM4#dom-documenttype-name
m.name:#dfn-doctype.name

m.innerHTML:~HTMLdynamic#dom-element-innerhtml
m.innerHTML:#dfn-innerhtml

子:#dfn-children
doc.種別:~DOM4#concept-document-type
~HTML文書:#dfn-html-document
局所~名:#dfn-local-name
~ns:#dfn-namespace-concept
置換-:#dfn-replace
~tree順序:#dfn-tree-order

 -->



</head>

<body>

<header>
	<hgroup>
<h1>DOM の構文解析と直列化 — DOM Parsing and Serialization</h1>
<p title="DOMParser, XMLSerializer, innerHTML, and similar APIs"><code >DOMParser</code>, <code>XMLSerializer</code>, <code>innerHTML</code> などの API</p>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は、
~web~app用に，［
~HTML／~XML
］に基づく~DOM~nodeを［
構文解析する, 直列化する
］ための~APIを定義する。
◎
This specification defines APIs for the parsing and serializing of HTML and XML-based DOM nodes for web applications.
</p>

<p class="trans-note">【
と述べられているが、
~XML直列化~algo以外は，`~HTML標準へ移動された＠#apis-for-parsing-and-serializing-dom$。
】</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下，この節の他の内容は、~SOTD-W3Cに移譲。】
</p>

<!-- 
This document was published by the Web Platform Working Group as an Editor's Draft. If you wish to make comments regarding this document, please send them to www-dom@w3.org (subscribe, archives) with DOM-Parsing at the start of your email's subject. All comments are welcome.
 -->

	</section>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
加えて，この訳では：
</p>

<ul>
	<li>
原文にて（すでに退役した） `HTML5$r による定義を参照している用語は、
便宜のため，現行の `HTML$r （の和訳）を参照している。
</li>
	<li>
同様に，原文による各種~nsの定義は、
`INFRA$r への参照に代えている（ `~XMLNS~ns$など）。
</li>
	<li>
この仕様が課す要件の対象は，常に~UAなので、
“~UA” は省略する。
</li>
	<li>
原文の~IDL属性を通して述べられている箇所の多くは、
当の~IDL属性が表現する下層~modelの用語で述べる
（例：要素の `namespaceURI＠~DOM4#dom-element-namespaceuri$m → 要素の`~ns$eL）。
</li>
</ul>


	</section>
	<section id="crec">
<h2 title="Candidate Recommendation Exit Criteria">勧告候補からの昇格基準</h2>

<p>
【この節の内容の和訳は省略する。】
◎
This specification will not advance to Proposed Recommendation before the spec's test suite is completed and two or more independent implementations pass each test, although no single implementation must pass each test. We expect to meet this criteria no sooner than 24 October 2014. The group will also create an Implementation Report.
</p>

	</section>
	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
文書~obj~model（~DOM）は、
それぞれが~treeに接続されている各種~型の`~node$たちが成す，~memory内~表現である。
~DOMとその`~node$のより深い詳細は、
`HTML$r【！[HTML5]】 および `DOM4$r 仕様に述べられる。
◎
A document object model (DOM) is an in-memory representation of various types of Nodes where each Node is connected in a tree. The [HTML5] and [DOM4] specifications describe DOM and its Nodes is greater detail.
</p>

<p>
用語［
`構文解析@
は，
~DOMの文字列~表現を実際の~DOMへ変換するとき／
`直列化-@
は，~DOMを文字列へ変形して戻すとき
］に利用される用語である。
この仕様~自身は、
~DOMを［
構文解析する／直列化する
］ための各種~APIを定義することを扱う。
◎
Parsing is the term used for converting a string representation of a DOM into an actual DOM, and Serializing is the term used to transform a DOM back into a string. This specification concerns itself with defining various APIs for both parsing and serializing a DOM.
</p>

<div class="example">

<p>
例えば `innerHTML$m ~APIは、［
~DOMを直列化する／~DOMに構文解析する
］共通的な仕方を与える
（それは、この両方とも行える）。
特定0の`~node$の~memory内~DOMが次であったとする：
◎
For example: the innerHTML API is a common way to both parse and serialize a DOM (it does both). If a particular Node, has the following in-memory DOM:
</p>

<div>
<ol><li>`HTMLDivElement^I （ `nodeName^m ~EQ `div^l ）
	<ol><li>`HTMLSpanElement^I （ `nodeName^m ~EQ `span^l)
		<ol><li>`Text^I （ `data^m ~EQ `ある^l ）
		</li></ol>
	</li><li>`HTMLElement^I （ `nodeName^m ~EQ `em^l ）
		<ol><li>`Text^I （ `data^m ~EQ `文章。^l ）
		</li></ol>
	</li></ol>
</li></ol>

<pre lang="en" class="_en">
HTMLDivElement (nodeName: `div^l)
┃
┣━ HTMLSpanElement (nodeName: `span^l)
┃  ┃
┃  ┗━ Text (data: `some ^l)
┃
┗━ HTMLElement (nodeName: `em^l)
   ┃
   ┗━ Text (data: `text!^l)
</pre>

</div>

<p>
`HTMLDivElement^I ~nodeの子たちを直列化するためには、
単純に`要素$の `innerHTML$m ~propを<em>取得する</em>（読取る）
（これは、直列化を誘発する）：
◎
And the HTMLDivElement node is stored in a variable myDiv, then to serialize myDiv's children simply get (read) the Element's innerHTML property (this triggers the serialization):
</p>

<pre class="lang-js">
var %myDiv = /* <span class="comment">
`HTMLDivElement^I ~node
</span> */
var %serializedChildren = %myDiv.innerHTML;
/* <span class="comment">
結果は `&lt;span&gt;ある&lt;/span&gt;&lt;em&gt;文章。&lt;/em&gt;^l になる。
◎
serializedChildren has the value: "&lt;span&gt;some &lt;/span&gt;&lt;em&gt;text!&lt;/em&gt;"
</span>
</pre>

<p>
文字列から
%myDiv 用の（その既存の子たちを置換して）新たな子を構文解析するためには、
単純に `innerHTML$m ~propを<em>設定する</em>
（これは、
アテガわれた文字列の構文解析を誘発する）：
◎
To parse new children for myDiv from a string (replacing its existing children), simply set the innerHTML property (this triggers parsing of the assigned string):
</p>

<pre class="lang-js">
%myDiv.innerHTML = `&lt;span&gt;new&lt;/span&gt;&lt;em&gt;children!&lt;/em&gt;^l;
</pre>

</div>

<p>
［
~HTML ／ ~XML（ ~XHTMLは~XMLの一種である）
］における［
`構文解析$, `直列化-$
］は、
各自の~markup言語の規則に従う。
上の例は，~HTMLの［
構文解析／直列化
］を示しているが、
それらに特有な~algoは `HTML$r【！[HTML5]】 仕様に定義される。
この仕様は、
~XMLを直列化するための~algoを与える。
~XMLを構文解析するための文法は、
`XML10$r 仕様に述べられる。
◎
This specification describes two flavors of parsing and serializing: HTML and XML (with XHTML being a type of XML). Each follows the rules of its respective markup language. The above example shows HTML parsing and serialization. The specific algorithms for HTML parsing and serializing are defined in the [HTML5] specification. This specification contains the algorithm for XML serializing. The grammar for XML parsing is described in the [XML10] specification.
</p>

<p>
`往復-@
するとは、
~DOMを直列化した結果の文字列を，即~構文解析して~DOMに戻す
【または、そうしたときに元と同じに保たれる】
ことを意味する。
理想的には、
この処理-による結果の~DOM内のどの`~node$においても，その属性の~dataは失われることなく同一性が保たれるべきである。
が，~XMLにおいて`往復-$することは、
直列化しても`~node$の~nsの同一性が保全されるよう配慮しなければナラナイ点で，
とりわけ込み入っている
（他方、
~HTMLにおいては，~nsは無視される）。
◎
Round-tripping a DOM means to serialize and then immediately parse the serialized string back into a DOM. Ideally, this process does not result in any data loss with respect to the identity and attributes of the Node in the DOM. Round-tripping is especially tricky for an XML serialization, which must be concerned with preserving the Node's namespace identity in the serialization (wereas namespaces are ignored in HTML).
</p>

<div class="example">

<p>
次の~memory内~DOMに対する~XML直列化を考える：
◎
Consider the XML serialization of the following in-memory DOM:
</p>

<div>
<ol><li>`Element^I （ `nodeName^m ~EQ `root^l ）
	<ol><li>`HTMLScriptElement^I （ `nodeName^m ~EQ `script^l)
		<ol><li>`Text^I （ `data^m ~EQ `alert('hello world') ^l ）
		</li></ol>
	</li></ol>
</li></ol>

<pre lang="en" class="_en">
Element (nodeName: "root")
┃
┗━ HTMLScriptElement (nodeName: "script")
   ┃
   ┗━ Text (data: "alert('hello world')")
</pre>

</div>

<p>
`script^e 要素の同一性を保全するため、
~XML直列化は，
`HTMLScriptElement^I `~node$の `文脈~ns$V を含むこと，および
直列化された文字列は、
~XML構文解析器を通して`往復-$することを許容しなければナラナイ。
上の `root^l 要素が，次の変数 %root にあてがわれたとするとき：
◎
An XML serialization must include the HTMLScriptElement Node's namespace in order to preserve the identity of the script element, and to allow the serialized string to round-trip through an XML parser. Assuming that root is in a variable named root:
</p>

<pre class="lang-js">
var %root = /* <span class="comment">`root^l `Element^I</span> */
var %xmlSerialization = `new XMLSerializer()＠~HTMLdynamic#dom-xmlserializer-constructor$m.`serializeToString(root)＠~HTMLdynamic#dom-xmlserializer-serializetostring$m;
</pre>

<p>
その結果は
⇒
`&lt;root&gt;&lt;script xmlns="http://www.w3.org/1999/xhtml"&gt;alert('hello world')&lt;/script&gt;&lt;/root&gt;^l
◎
/* xmlSerialization has the value:
"&lt;root&gt;&lt;script xmlns="http://www.w3.org/1999/xhtml"&gt;alert('hello world')&lt;/script&gt;&lt;/root&gt;" */
</p>

</div>

<p>
用語 文脈~objは…。
以下に挙げる~nsは…。
【以下、`この節を成す内容の和訳は省略する＠#_conventions$。】
◎
The term context object means the object on which the API being discussed was called.
◎
The following terms are understood to represent their respective namespaces in this specification (and makes it easier to read):
◎
The HTML namespace is http://www.w3.org/1999/xhtml
◎
The XML namespace is http://www.w3.org/XML/1998/namespace
◎
The XMLNS namespace is http://www.w3.org/2000/xmlns/
</p>

	</section>
	<section id="apis-for-parsing-and-serializing-dom">
<h2 title="APIs for parsing and serializing DOM">2. ~DOMを構文解析する／直列化するための~API</h2>

		<section id="the-domparser-interface">
<h3 title="The DOMParser interface">2.1. `DOMParser^I ~interface</h3>

<p id="dom-domparser">
<span id="dom-domparser-parsefromstring"></span>
<span id="idl-def-supportedtype"></span>
<span id="dom-supportedtype-text/html"></span>
<span id="dom-supportedtype-text/xml"></span>
<span id="dom-supportedtype-application/xml"></span>
<span id="dom-supportedtype-application/xhtml+xml"></span>
<span id="dom-supportedtype-image/svg+xml"></span>
`DOMParser^I の定義は、
`~HTML標準＠~HTMLdynamic#domparser$へ移動された。
◎
The definition of DOMParser has moved to the HTML Standard.
</p>

		</section>
		<section id="the-xmlserializer-interface">
<h3 title="The XMLSerializer interface">2.2. `XMLSerializer^I ~interface</h3>

<p>
<span id="dom-xmlserializer"></span>
<span id="dom-xmlserializer-constructor"></span>
<span id="dom-xmlserializer-serializetostring"></span>
`XMLSerializer^I の定義は、
`~HTML標準＠~HTMLdynamic#xmlserializer$へ移動された。
◎
The definition of XMLSerializer has moved to the HTML Standard.
</p>

		</section>
		<section id="the-innerhtml-mixin">
<h3 title="The InnerHTML mixin">2.3. `InnerHTML^I ~mixin</h3>

<p>
`InnerHTML^I 【~mixinは除去され，その `innerHTML^m 】の定義は、
`~HTML標準＠~HTMLdynamic#the-innerhtml-property$へ移動された。
◎
The definition of InnerHTML has moved to the HTML Standard.
</p>

		</section>
		<section id="extensions-to-the-element-interface">
<h3 title="Extensions to the Element interface">2.4. `Element^I ~interfaceに対する拡張</h3>

<p>
`outerHTML^m の定義は、
`~HTML標準＠~HTMLdynamic#the-outerhtml-property$へ移動された。
◎
The definition of outerHTML has moved to the HTML Standard.
</p>

<p>
`insertAdjacentHTML^m の定義は、
`~HTML標準＠~HTMLdynamic#the-insertadjacenthtml()-method$へ移動された。
◎
The definition of insertAdjacentHTML has moved to the HTML Standard.
</p>

		</section>
		<section id="extensions-to-the-range-interface">
<h3 title="Extensions to the Range interface">2.5. `Range^I ~interfaceに対する拡張</h3>

<p>
`createContextualFragment^m の定義は、
`~HTML標準＠~HTMLdynamic#the-createcontextualfragment()-method$へ移動された。
◎
The definition of createContextualFragment has moved to the HTML Standard.
</p>
		</section>
	</section>
	<section id="algorithms-for-parsing-and-serializing">
<h2 title="Algorithms for parsing and serializing">3. 素片~用の構文解析-法と直列化-法</h2>

		<section id="parsing">
<h3 title="Parsing">3.1. 構文解析-法</h3>

<p id="dfn-fragment-parsing-algorithm">
素片を構文解析する~algoの定義は、
`~HTML標準＠~HTMLdynamic#fragment-parsing-algorithm-steps$へ移動された。
◎
The definition of fragment parsing algorithm has moved to the HTML Standard.
</p>

		</section>
		<section id="serializing">
<h3 title="Serializing">3.2. 直列化-法</h3>

<p id="dfn-fragment-serializing-algorithm">
素片に直列化する~algoの定義は、
`~HTML標準＠~HTMLdynamic#fragment-serializing-algorithm-steps$へ移動された。
◎
The definition of fragment serializing algorithm has moved to the HTML Standard.
</p>

		</section>
	</section>
	<section id="xml-serialization">
<h2 title="XML Serialization">4. ~XML直列化</h2>

<p class="trans-note">【
この節は，原文では § 3.2 の下位節として与えられているが、
この訳では独立な節に分離する。
この節が、
この仕様が定義する~modelの主要な部分を成すので。
】</p>

<p>
`~XML直列化$は、
次に挙げる仕方において，~HTML直列化から相違する：
◎
An XML serialization differs from an HTML serialization in the following ways:
</p>
<ul>
	<li>
［
`要素$ ／ `属性~list$
］を直列化するときは、
その［
`~ns$eL ／ `~ns$A
］は，常に保全される。
このことは、
一部の事例では，それらの既存の［
~ns接頭辞 ／ 接頭辞~宣言を与える属性 ／ 既定の~ns宣言を与える属性
］は、［
落とされたり, 代用されたり, 変更される
］こともあることを意味する。
~HTML直列化は、
~nsを保全するよう試みない。
◎
Elements and attributes will always be serialized such that their namespaceURI is preserved. In some cases this means that an existing prefix, prefix declaration attribute or default namespace declaration attribute might be dropped, substituted or changed. An HTML serialization does not attempt to preserve the namespaceURI.
</li>
	<li>
`~HTML~ns$に属さない`要素$のうち，`子$を包含していないものは、
`空~要素~tag$構文を利用して（すなわち，~XML `EmptyElemTag$P 生成規則に則って）直列化される。
◎
Elements not in the HTML namespace containing no children, are serialized using the empty-element tag syntax (i.e., according to the XML EmptyElemTag production).
</li>
</ul>

<p>
他の点では、
`~XML直列化$を生産する~algoは，`~HTML構文解析器$と互換な直列化を生産するよう設計されている。
例えば，`~HTML~ns$に属する要素のうち`子$を包含しないものは、
`空~要素~tag$構文を利用することなく，明示的な［
開始~tag, 終了~tag
］を伴って直列化される。
◎
Otherwise, the algorithm for producing an XML serialization is designed to produce a serialization that is compatible with the HTML parser. For example, elements in the HTML namespace that contain no child nodes are serialized with an explicit begin and end tag rather than using the empty-element tag syntax.
</p>

<p class="note" id="issue-container-generatedID">注記：
`DOM4$r により， `Attr$I ~objは `Node$I を継承しない†ので、
~nodeを`~XMLに直列化する$ことでは直列化できず，
そうするよう試みた場合の結果は空~文字列になる。
【†この記述は，今や~~正しくないが、いずれにせよそうなるであろう。】
◎
Note

Per [DOM4], Attr objects do not inherit from Node, and thus cannot be serialized by the XML serialization algorithm. An attempt to serialize an Attr object will result in an empty string.
</p>

<div class="algo">
<p>
`~XML直列化@
を生産する手続きは、
所与の
( 直列化する`~node$ %~node, 真偽値 `整形式が要求されるか@V )
に対し，以下を走らす
— この手続きにおいては：
◎
To produce an XML serialization of a Node node given a flag require well-formed, run the following steps:
</p>

<ul>
	<li>
`整形式が要求されるか$V ~EQ ~T の下では、
結果が［
整形式にならない／合法に往復できない
］ときには，例外が投出される。
この~flagは、［
この~algoの文脈~下で呼出される，この節に定義される各種~algo
］すべてから参照され, 変化しない。
◎
↓↓</li>
	<li>
<p>
この手続きが呼出す［
各種 `型の~nodeを~XMLに直列化する$
］手続きには、
現在の既定の~nsを追跡する，
`文脈~ns@V
が（値~渡しで）渡される。
これは、
初期~時には ~NULL （~nsなしを表す）であり，次が生じたときに変更される：
◎
Let namespace be a context namespace with value null. The context namespace tracks the XML serialization algorithm's current default namespace. The context namespace is changed when either＼
</p>
		<ul>
			<li>
出くわした`要素$が既定の~ns宣言を有するとき
◎
an Element Node has a default namespace declaration, or＼
</li>
			<li>
~algoが、
出くわした`要素$の自前の~nsに合致する既定の~ns宣言を生成するとき
◎
the algorithm generates a default namespace declaration for the Element Node to match its own namespace. The algorithm assumes no namespace (null) to start.
</li>
		</ul>
	</li>
</ul>

<ol>
	<li>
`接頭辞~map$V ~LET 新たな`~ns接頭辞~map$
◎
Let prefix map be a new namespace prefix map.
</li>
	<li>
`接頭辞~mapに追加する$( `接頭辞~map$V, `xml^l, `~XML~ns$ )
◎
Add the XML namespace with prefix value "xml" to prefix map.
</li>
	<li id="dfn-generated-namespace-prefix-index">
<p>
`接頭辞~index@V ~LET 1
◎
Let prefix index be a generated namespace prefix index with value 1.＼
</p>

<p>
これは、［
%~node の`~ns$eL（または %~node の属性の`~ns$A ）を直列化するときに，
相応しい既存の~ns接頭辞が可用でない
］ときに，新たな, かつ一意な`接頭辞を生成する$ために利用され、
この~algoによる直列化~文脈~全体にわたり共有される。
◎
The generated namespace prefix index is used to generate a new unique prefix value when no suitable existing namespace prefix is available to serialize a node's namespaceURI (or the namespaceURI of one of node's attributes). See the generate a prefix algorithm.
</p>
	</li>
	<li>
<p>
~RET %~node を`~XMLに直列化する$( ~NULL, `接頭辞~map$V )
</p>

<p>
この段で `TypeError$E でない【！＊】例外が投出されたときは、
~catchして
⇒
~THROW `InvalidStateError$E
</p>
◎
Return the result of running the XML serialization algorithm on node passing the context namespace namespace, namespace prefix map prefix map, generated namespace prefix index reference to prefix index, and the flag require well-formed. If an exception occurs during the execution of the algorithm, then catch that exception and throw an "InvalidStateError" DOMException.
</li>
</ol>
</div>

<p>
所与の
`型の~nodeを~XMLに直列化する@
ための各種~algoは、
直列化する入力 %~node に加え，次の引数をとるように定義される：
◎
Each of the following algorithms for producing an XML serialization of a DOM node take as input a node to serialize and the following arguments:
</p>

<ul>
	<li>
`文脈~ns$V
◎
A context namespace namespace
</li>
	<li>
`接頭辞~map@V
— `~ns接頭辞~map$
◎
A namespace prefix map prefix map
◎
↑↑A generated namespace prefix index prefix index
◎
↑↑The require well-formed flag
</li>
</ul>

<div class="algo">
<p>
%~node を
`~XMLに直列化する@
~algoは
⇒
~RET ［
%~node の~interface型に応じて，次に与える ある`型の~nodeを~XMLに直列化する$~algo
］に［
受取った引数たち
］をそのまま渡して走らせた結果：
◎
The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based on the node's interface type. Each referenced algorithm is to be passed the arguments as they were recieved by the caller and return their result to the caller. Re-throw any exceptions. If node's interface is:
</p>

<dl class="switch">
	<dt>`Element$I</dt>
	<dd>
`Element^I ~nodeを`~XMLに直列化する＠#xml-serializing-an-element-node$
◎
Run the algorithm for XML serializing an Element node node.
</dd>

	<dt>`Document$I</dt>
	<dd>
`Document^I ~nodeを`~XMLに直列化する＠#xml-serializing-a-document-node$
◎
Run the algorithm for XML serializing a Document node node.
</dd>

	<dt>`Comment$I</dt>
	<dd>
`Comment^I ~nodeを`~XMLに直列化する＠#xml-serializing-a-comment-node$
<!--

	<dt><code><a>CDATASection</a></code>
	<dd>Run the algorithm for <a>XML serializing a CDATASection node</a> <var>node</var>.-->

◎
Run the algorithm for XML serializing a Comment node node.
</dd>

	<dt>`Text$I</dt>
	<dd>
`Text^I ~nodeを`~XMLに直列化する＠#xml-serializing-a-text-node$
◎
Run the algorithm for XML serializing a Text node node.
</dd>

	<dt>`DocumentFragment$I</dt>
	<dd>
`DocumentFragment^I ~nodeを`~XMLに直列化する＠#xml-serializing-a-documentfragment-node$
◎
Run the algorithm for XML serializing a DocumentFragment node node.
</dd>

	<dt>`DocumentType$I</dt>
	<dd>
`DocumentType^I ~nodeを`~XMLに直列化する＠#xml-serializing-a-documenttype-node$
◎
Run the algorithm for XML serializing a DocumentType node node.
</dd>

	<dt>`ProcessingInstruction$I</dt>
	<dd>
`ProcessingInstruction^I ~nodeを`~XMLに直列化する＠#xml-serializing-a-processinginstruction-node$
◎
Run the algorithm for XML serializing a ProcessingInstruction node node.
</dd>

	<dt>
`Attr$I
◎
An Attr object
</dt>
	<dd>
次を走らす~algo
⇒
~RET 空~文字列
◎
Return an empty string.
</dd>

	<dt>
その他
◎
Anything else
</dt>
	<dd>
次を走らす~algo
⇒
~THROW `TypeError$E
◎
Throw a TypeError.＼
</dd>
	<dd>
（この~algoが直列化できるのは `Node$I ／ `Attr$I ~objに限られる。）
◎
Only Nodes and Attr objects can be serialized by this algorithm.
</dd>
</dl>
</div>

<p>
上で参照された各~algoの詳細は、
以下の各~下位節に与える。
◎
Each of the above referenced algorithms are detailed in the sections that follow.
</p>

		<section id="xml-serializing-an-element-node">
<h3 title="XML serializing an Element node">4.1. 要素を~XMLに直列化する</h3>

<div class="algo">
<p>
`Element$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type Element is as follows:
</p>

<p class="trans-note">【
簡潔にするため、
この~algoの一部には（等価なふるまいになるよう）手を加えている。
】</p>

<ol>
	<li>
%要素 ~LET %~node
【この段は、以下を読み易くするための，この訳による追加（単なる名称変更）。】
</li>
	<li>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
%要素 の`局所~名$eLは、［
`003A^U を包含する
］~OR［
~XML `Name$P 生成規則に合致しない
］］
⇒
~THROW 例外
⇒
%要素 の直列化は、
整形式な要素にならない。
◎
If the require well-formed flag is set (its value is true), and this node's localName attribute contains the character ":" (U+003A COLON) or does not match the XML Name production, then throw an exception; the serialization of this node would not be a well-formed element.
◎
↓↓Let markup be the string "&lt;" (U+003C LESS-THAN SIGN).
◎
↓↓Let qualified name be an empty string.
◎
↓↓Let skip end tag be a boolean flag with value false.
◎
↓↓Let ignore namespace definition attribute be a boolean flag with value false.
【！ dfn-skip-end-tag 】
</li>
	<li>
%~map ~LET `~ns接頭辞~mapを複製する$( `接頭辞~map$V )
◎
Given prefix map, copy a namespace prefix map and let map be the result.
</li>
	<li>
<div class="p">
<p>
`局所~接頭辞~map@V
~LET 新たな空`~map$
— この~mapを成す各~entryは：
</p>
		<ul>
			<li>
~ns接頭辞を与える文字列を~keyとする。
</li>
			<li>
~nsを与える文字列を値とする。
この値においては、
~NULL ~nsは空~文字列で表現される。
</li>
		</ul>
◎
Let local prefixes map be an empty map. The map has unique Node prefix strings as its keys, with corresponding namespaceURI Node values as the map's key values (in this map, the null namespace is represented by the empty string).
</div>

<div class="note">
<p>注記：
この~mapは、
要素ごとに局所的であり，次のために利用される：
</p>
		<ul>
			<li>
~ns接頭辞~定義を与える属性が必要で，そのために新たな`接頭辞を生成する$べきときに、
他の接頭辞と競合しないことを確保する。
</li>
			<li>
当の`要素の属性たちを~XMLに直列化する$ときに，
重複する接頭辞~定義を飛ばせるようにする。
</li>
			<li>
`~ns接頭辞~map$内の接頭辞のうち［
当の要素に局所的に定義されるもの, そうでないもの
］を，この~algoが判別できるようにする。
</li>
		</ul>

◎
Note

This map is local to each element. It is used to ensure there are no conflicting prefixes should a new namespace prefix attribute need to be generated. It is also used to enable skipping of duplicate prefix definitions when writing an element's attributes: the map allows the algorithm to distinguish between a prefix in the namespace prefix map that might be locally-defined (to the current Element) and one that is not.
</div>
	</li>
	<li>
<p>
`局所的な既定の~ns@V
~LET `要素の~ns情報を記録する$( %要素, %~map, `局所~接頭辞~map$V )
◎
Let local default namespace be the result of recording the namespace information for node given map and local prefixes map.
</p>

<p class="note">注記：
この段は %~map も更新することに加え、
%要素 上に見出された~ns接頭辞~定義を， `局所~接頭辞~map$V に追加する。
`局所的な既定の~ns$V は、
%要素 上に既定の~nsを与える属性が［
在れば それが定義する~ns ／
無ければ ε
］になる。
◎
Note

The above step will update map with any found namespace prefix definitions, add the found prefix definitions to the local prefixes map and return a local default namespace value defined by a default namespace attribute if one exists. Otherwise it returns null.
</p>
	</li>
	<li>
`~ns定義~属性を無視するか@V ~LET ~F
◎
↑↑</li>
	<li>
%~ns ~LET %要素 の`~ns$eL
◎
Let inherited ns be a copy of namespace.
◎
Let ns be the value of node's namespaceURI attribute.
</li>
	<li>
%接頭辞 ~LET %要素 の`~ns接頭辞$eL
【~NULL に設定された場合、接頭辞は直列化されない。】
◎
↓</li>
	<li>
%~ns宣言~markup ~LET 空~文字列
【これは、接頭辞~宣言／既定の~ns宣言が必要になったとき，他の値に設定される。】
◎
↓</li>
	<li>
<p>
~IF［
%~ns ~EQ `文脈~ns$V
］：
◎
If inherited ns is equal to ns, then:
</p>
		<ol>
			<li>
~IF［
`局所的な既定の~ns$V ~NEQ ε
］
⇒
`~ns定義~属性を無視するか$V ~SET ~T
◎
If local default namespace is not null, then set ignore namespace definition attribute to true.
</li>
			<li>
<p>
%接頭辞 ~SET［［
%~ns ~EQ `~XML~ns$
］ならば `xml^l ／
~ELSE_ ~NULL
］
◎
If ns is the XML namespace, then append to qualified name the concatenation of the string "xml:" and the value of node's localName.
◎
Otherwise, append to qualified name the value of node's localName. The node's prefix if it exists, is dropped.
</p>

<p class="note">注記：
`~XML~ns$に属さない場合、
%要素 に`~ns接頭辞$eLが存在しても，落とされる。
◎
Append the value of qualified name to markup.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
<!-- The serialization algorithm must differentiate this node's namespace from it's parent's default namespace. There are two ways to do this: (1) [preferred due to assumed minimum length] use a namespace prefix if one is available or (2) use a default namespace declaration. Both cases can run into conflicts with existing attributes on the element and are handled accordingly. -->

◎
Otherwise, inherited ns is not equal to ns (the node's own namespace is different from the context namespace of its parent). Run these sub-steps:
</p>
		<ol>
			<li>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
%接頭辞 ~EQ `xmlns^l
］
⇒
~THROW 例外
⇒
%要素 は合法に往復しない。
◎
Let prefix be the value of node's prefix attribute.
</li>
			<li>
<p>
%候補~接頭辞 ~LET ［［
%接頭辞 ~NEQ `xmlns^l
］ならば `選好される接頭辞~文字列を検索取得する$( %~map, %~ns, %接頭辞 ) ／
~ELSE_ `xmlns^l
］
</p>

<p class="note">注記：
%~map の`~key群$mapが %~ns を含んでいない場合、
~NULL が返される。
</p>

<!-- Found a suitable prefix to use, either locally, or inherited through a parent node that matches the node's namespaceURI. This prefix will be used in serialization even if the node doesn't have a real prefix. -->

◎
Let candidate prefix be the result of retrieving a preferred prefix string prefix from map given namespace ns.
◎
Note

The above may return null if no namespace key ns exists in map.
◎
If the value of prefix matches "xmlns", then run the following steps:
• If the require well-formed flag is set, then throw an error. An Element with prefix "xmlns" will not legally round-trip in a conforming XML parser.
• Let candidate prefix be the value of prefix.
</li>
			<li>
<p id="dfn-found-a-suitable-namespace-prefix">
~IF［
%候補~接頭辞 ~NEQ ~NULL
（この接頭辞は %~ns へ対応付けるよう定義されている）
］：
◎
Found a suitable namespace prefix: if candidate prefix is not null (a namespace prefix is defined which maps to ns), then:
</p>

<p class="note">注記：
%候補~接頭辞 が直列化されることになる
— それは、
%要素 の自前の`~ns接頭辞$eLとは異なり得る。
<!-- ＊？
しかしながら，可能なら
すでに
選好される接頭辞~文字列を検索取得する$ ~algoにて 既存の接頭辞に合致するよう試行された。
 -->
◎
Note

The following may serialize a different prefix than the Element's existing prefix if it already had one. However, the retrieving a preferred prefix string algorithm already tried to match the existing prefix if possible.
</p>

		<ol>
			<li>
<p>
%接頭辞 ~SET %候補~接頭辞
</p>

<p class="note">注記：
%要素 または そのいずれかの先祖に、
%要素 の~nsを定義する~ns接頭辞~定義が存在する。
</p>
◎
Append to qualified name the concatenation of candidate prefix, ":" (U+003A COLON), and node's localName. There exists on this node or the node's ancestry a namespace prefix definition that defines the node's namespace.
</li>
			<li>
<p>
`局所的な既定の~ns$V に応じて：
</p>
				<ul>
					<li>
<p>
ε ／ `~XML~ns$
⇒
何もしない
</p>

<p class="note">注記：
`~XML~ns$を定義するような［
既定の~ns定義／~ns接頭辞
］は、
在っても， %要素 の属性たちを直列化するときには省略される。
</p>
					</li>
					<li>
空~文字列
⇒
`文脈~ns$V ~SET ~NULL
</li>
					<li>
<p>
その他
⇒
`文脈~ns$V ~SET `局所的な既定の~ns$V
</p>

<p class="note">注記：
`文脈~ns$V は、
%要素 の自前の~nsではなく，
宣言された既定の~nsに変更される。
</p>
				</li>
				</ul>
◎
If the local default namespace is not null (there exists a locally-defined default namespace declaration attribute) and its value is not the XML namespace, then let inherited ns get the value of local default namespace unless the local default namespace is the empty string in which case let it get null＼
◎
(the context namespace is changed to the declared default, rather than this node's own namespace).
◎
Note

Any default namespace definitions or namespace prefixes that define the XML namespace are omitted when serializing this node's attributes.
◎
Append the value of qualified name to markup.
</li>
		</ol>

	</li>
	<li>
<p>
~ELIF［
%接頭辞 ~NEQ ~NULL
］：
◎
Otherwise, if prefix is not null, then:
</p>

<div class="note">
<p>
注記：
この時点で、
%要素 にも, そのどの先祖にも［
%接頭辞 を定義する~ns／
%接頭辞 を~nsへ対応付ける宣言
］は無い。
以降の手続きは、
次を確保する：
</p>
		<ul>
			<li>
%接頭辞 用に新たな~ns接頭辞~宣言を作成する。
</li>
			<li>
%接頭辞 は［
%要素 の`属性~list$内に既存の~ns接頭辞~宣言
【！ ＊？同じ localName の】
］とは競合しない。
</li>
		</ul>
◎
Note

By this step, there is no namespace or prefix mapping declaration in this node (or any parent node visited by this algorithm) that defines prefix otherwise the step labelled Found a suitable namespace prefix would have been followed. The sub-steps that follow will create a new namespace prefix declaration for prefix and ensure that prefix does not conflict with an existing namespace prefix declaration of the same localName in node's attribute list.
</div>

		<ol>
			<li>
~IF［
`局所~接頭辞~map$V[ %接頭辞 ] ~NEQ ε
］
⇒
%接頭辞 ~SET `接頭辞を生成する$( %~map, %~ns )
◎
If the local prefixes map contains a key matching prefix, then let prefix be the result of generating a prefix providing as input map, ns, and prefix index.
</li>
			<li>
`接頭辞~mapに追加する$( %~map, %接頭辞, %~ns )
◎
Add prefix to map given namespace ns.
◎
Append to qualified name the concatenation of prefix, ":" (U+003A COLON), and node's localName.
◎
Append the value of qualified name to markup.
</li>
			<li>
<p>
%~ns宣言~markup ~SET 次を順に連結した結果：
</p>

<p class="note">注記：
これは、
%接頭辞 に対応する~ns接頭辞~宣言を直列化する。
</p>

<ol><li>~SPACE
</li><li>`xmlns:^l
</li><li>%接頭辞
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %~ns )
</li><li>`0022^U
</li></ol>

◎
Append the following to markup, in the order listed:
◎
Note

The following serializes a namespace prefix declaration for prefix which was just added to the map.
◎
• " " (U+0020 SPACE);
• The string "xmlns:";
• The value of prefix;
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given ns and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK).
</li>
			<li>
~IF［
`局所的な既定の~ns$V ~NEQ ε
【！＊ (there exists a locally-defined default namespace declaration attribute)】
］
⇒
`文脈~ns$V ~SET ［
`局所的な既定の~ns$V ~NEQ 空~文字列 ならば `局所的な既定の~ns$V ／
~ELSE_ ~NULL
］
◎
If local default namespace is not null (there exists a locally-defined default namespace declaration attribute), then let inherited ns get the value of local default namespace unless the local default namespace is the empty string in which case let it get null.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
`局所的な既定の~ns$V ~NEQ %~ns
］：
◎
Otherwise, if local default namespace is null, or local default namespace is not null and its value is not equal to ns, then:
</p>

<p class="note">注記：
%要素 用の~nsは，依然として直列化される必要があるが、
この時点では， %接頭辞 も %候補~接頭辞 も可用でない。
そのため、
この段では，既定の~ns宣言を利用して~nsを定義する
— 既存の既定の~ns宣言が在る場合、
それは置換される。
◎
Note

At this point, the namespace for this node still needs to be serialized, but there's no prefix (or candidate prefix) availble; the following uses the default namespace declaration to define the namespace--optionally replacing an existing default declaration if present.
</p>

		<ol>
			<li>
`~ns定義~属性を無視するか$V ~SET ~T
◎
Set the ignore namespace definition attribute flag to true.
◎
Append to qualified name the value of node's localName.
</li>
			<li>
<p>
`文脈~ns$V ~SET %~ns
◎
Let the value of inherited ns be ns.
</p>
<p class="note">注記：
新たな既定の~nsは、
直列化において %要素 の~nsを定義するときに利用され，
その`子$たち用の `文脈~ns$V として動作することになる。
◎
Note

The new default namespace will be used in the serialization to define this node's namespace and act as the context namespace for its children.
</p>

					</li>
					<li>
<p>
%~ns宣言~markup ~SET 次を順に連結した結果：
◎
Append the value of qualified name to markup.
◎
Append the following to markup, in the order listed:
</p>

<p class="note">注記：
これは、
新たな（または~~代用の）既定の~ns定義を直列化する。
◎
Note

The following serializes the new (or replacement) default namespace definition.
</p>

<div>
<ol><li>~SPACE
</li><li>`xmlns^l
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %~ns )
</li><li>`0022^U
</li></ol>
◎
• " " (U+0020 SPACE);
• The string "xmlns";
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given ns and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK). 
</div>

					</li>
				</ol>
【！ Finally, regardless of prefix, the node has a local default namespace that matches 'ns'. So, we'll just use that and drop the prefix】
			</li>
			<li>
<p>
~ELSE（ `局所的な既定の~ns$V ~EQ %~ns ~NEQ ε ）：
◎
Otherwise, the node has a local default namespace that matches ns. Append to qualified name the value of node's localName,＼
</p>
				<ol>
					<li>
`文脈~ns$V ~SET %~ns
◎
let the value of inherited ns be ns, and append the value of qualified name to markup.
</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
%~ns ~NEQ `文脈~ns$V になる組合nは，すべて上で取扱われ、
%要素 は，その元の`~ns$eLを保全するよう直列化されることになる。
◎
Note

All of the combinations where ns is not equal to inherited ns are handled above such that node will be serialized preserving its original namespaceURI.
</p>
	</li>
	<li>
%局所~名 ~LET %要素 の`局所~名$eL
</li>
	<li>
<p>
`有修飾~名@V
~LET ［
%接頭辞 ~EQ ~NULL ならば %局所~名 ／
~ELSE_ 次を順に連結した結果
]：
</p>

<ol ><li>%接頭辞
</li><li>`003A^U
</li><li>%局所~名
</li></ol>

◎
↑↑</li>
	<li>
<p>
%~markup ~LET 次を順に連結した結果：
</p>
<ol ><li>`003C^U
</li><li>`有修飾~名$V
</li><li>%~ns宣言~markup
</li></ol>

◎
↑↑</li>
	<li>
%~markup に次の結果を付加する
⇒
`要素の属性たちを~XMLに直列化する$( %要素, %~map, `局所~接頭辞~map$V, `~ns定義~属性を無視するか$V )
◎
Append to markup the result of the XML serialization of node's attributes given map, prefix index, local prefixes map, ignore namespace definition attribute flag, and require well-formed flag.
</li>
	<li>
<p>
~IF［
%要素 の`子~群$は空である
］~AND［
~OR↓
］…
</p>
		<ul>
			<li>
%~ns ~NEQ `~HTML~ns$
</li>
			<li>
［
%~ns ~EQ `~HTML~ns$
］~AND［
%局所~名 ~IN {
`area^l , `base^l , `basefont^l , `bgsound^l , `br^l , `col^l , `embed^l , `frame^l , `hr^l , `img^l , `input^l , `keygen^l , `link^l , `menuitem^l , `meta^l , `param^l , `source^l , `track^l , `wbr^l
} （これらは`~void要素$の~tag名を与える）
］
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
~IF［
%~ns ~EQ `~HTML~ns$
］
⇒
%~markup に ~SPACE を付加する
</li>
			<li>
<p>
%~markup に次を順に連結した結果を付加する：
</p>

<ol><li>`002F^U
</li><li>`003E^U
</li></ol>
			</li>
			<li>
~RET %~markup
</li>
		</ol>

◎
If ns is the HTML namespace, and the node's list of children is empty, and the node's localName matches any one of the following void elements: "area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"; then append the following to markup, in the order listed:
◎
" " (U+0020 SPACE);
◎
"/" (U+002F SOLIDUS).
◎
and set the skip end tag flag to true.
◎
If ns is not the HTML namespace, and the node's list of children is empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.
◎
Append "&gt;" (U+003E GREATER-THAN SIGN) to markup.
◎
If the value of skip end tag is true, then return the value of markup and skip the remaining steps. The node is a leaf-node.
</li>
	<li>
%~markup に `003E^U を付加する
◎
↑</li>
	<li>

<p>
~IF［
%~ns ~EQ `~HTML~ns$
］~AND［
%局所~名 ~EQ `template^l
］
⇒
%~markup に次の結果を付加する
⇒
%要素 の`~template内容$を`~XMLに直列化する$( `文脈~ns$V, %~map )
◎
If ns is the HTML namespace, and the node's localName matches the string "template", then this is a template element. Append to markup the result of XML serializing a DocumentFragment node given the template element's template contents (a DocumentFragment), providing inherited ns, map, prefix index, and the require well-formed flag.
</p>

<p class="note">注記：
%要素 は `template$e 要素であり、
その`~template内容$は `DocumentFragment$I である。
これは、
`~XHTML文書を構文解析-$する規則の下でも，`~template内容$が往復できるようにする。
◎
Note

This allows template content to round-trip , given the rules for parsing XHTML documents.
</p>

	</li>
	<li>
~ELSE
⇒
%要素 の`子~群$を成す
~EACH( %子 )
に対し，`~tree順序$で
⇒
%~markup に次の結果を付加する
⇒
%子 を`~XMLに直列化する$( `文脈~ns$V, %~map )
◎
Otherwise, append to markup the result of running the XML serialization algorithm on each of node's children, in tree order, providing inherited ns, map, prefix index, and the require well-formed flag.
</li>
	<li>
<p>
%~markup に次を順に連結した結果を付加する：
</p>
<ol><li>`003C^U
</li><li>`002F^U
</li><li>`有修飾~名$V
</li><li>`003E^U
</li></ol>
◎
Append the following to markup, in the order listed:
◎
• "&lt;/" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
• The value of qualified name;
• "&gt;" (U+003E GREATER-THAN SIGN). 
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>
</div>

			<section id="recording-the-namespace">
<h4 title="Recording the namespace">4.1.1. ~nsの記録-法</h4>

<p>
次の~algoは、
要素に局所的な~ns接頭辞~定義を出して，
それらを `局所~接頭辞~map$V （初期~時は空）に追加した上で，
それらで`~ns接頭辞~map$も更新する。
加えて、
要素に局所的な既定の~ns宣言が［
在るならば それが与える~ns ／
無いならば ε
］を返す。
◎
This following algorithm will update the namespace prefix map with any found namespace prefix definitions, add the found prefix definitions to the local prefixes map, and return a local default namespace value defined by a default namespace attribute if one exists. Otherwise it returns null.
</p>

<div class="algo">
<p>
`要素の~ns情報を記録する@
~algoは、
所与の
( `要素$ %要素, `~ns接頭辞~map$ %~map, `局所~接頭辞~map$V )
に対し：
◎
When recording the namespace information for an Element element, given a namespace prefix map map and a local prefixes map (initially empty), the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%既定の~ns属性~値 ~LET ε
◎
Let default namespace attr value be null.
</p>

<p class="trans-note">【
この訳では、
原文の ~NULL に代えて ε を利用する。
“~NULL ~ns” と混同しやすいので
（原文のこの~algoが返す ~NULL は、
~NULL ~nsを表現する値ではない）。
】</p>

	</li>
	<li>
<p id="dfn-main">
%要素 の`属性~list$を成す
~EACH( `属性$ %属性 )
に対し：
◎
Main: For each attribute attr in element's attributes, in the order they are specified in the element's attribute list:
</p>

<p class="note">注記：
この段を成す手続きは、
`~XMLNS~ns$に属する属性のみを考慮する下で，~ns接頭辞を見出す
（例えば，
<code>`setAttribute＠~DOM4#dom-element-setattribute$m( `xmlns:pretend-prefix^l, `pretend-namespace^l )</code>
などを介して ~ns宣言に見せかけた属性は、
含まれない）。
◎
Note

The following conditional steps find namespace prefixes. Only attributes in the XMLNS namespace are considered (e.g., attributes made to look like namespace declarations via setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not included).
</p>
		<ol>
			<li>
( %属性~ns, %属性~接頭辞, %属性~値 )
~LET %属性 の
( `~ns$A, `~ns接頭辞$A, `値$A )
◎
Let attribute namespace be the value of attr's namespaceURI value.
◎
Let attribute prefix be the value of attr's prefix.
</li>
			<li>
~IF［
%属性~ns ~NEQ `~XMLNS~ns$
］
⇒
~CONTINUE
◎
If the attribute namespace is the XMLNS namespace, then:
</li>
			<li>
<p>
~IF［
%属性~接頭辞 ~EQ ~NULL
］：
</p>
<ol ><li>~Assert：%属性 は既定の~ns宣言である。
</li><li>%既定の~ns属性~値 ~SET %属性~値
</li><li>~CONTINUE
</li></ol>

◎
If attribute prefix is null, then attr is a default namespace declaration. Set the default namespace attr value to attr's value and stop running these steps, returning to Main to visit the next attribute.
</li>
			<li>
~Assert：
%属性 は~ns接頭辞~定義である。
◎
Otherwise, the attribute prefix is not null and attr is a namespace prefix definition. Run the following steps:
</li>
			<li>
%接頭辞 ~LET %属性 の`局所~名$A
◎
Let prefix definition be the value of attr's localName.
</li>
			<li>
%~ns ~LET %属性~値
◎
Let namespace definition be the value of attr's value.
</li>
			<li>
<p>
~IF［
%~ns ~EQ `~XML~ns$
］
⇒
~CONTINUE
◎
If namespace definition is the XML namespace, then stop running these steps, and return to Main to visit the next attribute.
</p>

<p class="note">注記：
`~XML~ns$を定義するような接頭辞は、
完全に無視される
（接頭辞が競合し得るときの不必要な作業を避けるため）。
`~XML~ns$に属する要素は、
常に［
要素の局所~名に予約-済み接頭辞 `xml^l を接頭する
］よう，一律に（また、必要yなら上書きするように）取扱われる。
◎
Note

XML namespace definitions in prefixes are completely ignored (in order to avoid unnecessary work when there might be prefix conflicts). XML namespaced elements are always handled uniformly by prefixing (and overriding if necessary) the element's localname with the reserved "xml" prefix.
</p>
			</li>
			<li>
~IF［
%~ns ~EQ 空~文字列（どの~nsにも属さないことの宣言的な形）
］
⇒
%~ns ~SET ~NULL
◎
If namespace definition is the empty string (the declarative form of having no namespace), then let namespace definition be null instead.
</li>
			<li>
<p>
~IF［
`接頭辞が見出されるか否か$( %~map, %接頭辞, %~ns ) ~EQ ~T
］
⇒
~CONTINUE
◎
If prefix definition is found in map given the namespace namespace definition, then stop running these steps, and return to Main to visit the next attribute.
</p>

<p class="note">注記：
この段は、
同じ~nsに対応する接頭辞~定義が，
%~map 内に重ねて追加されるのを避ける。
これは、
後に，子孫~nodeにおける~ns接頭辞~宣言が重ねて直列化されないようにする。
◎
Note

This step avoids adding duplicate prefix definitions for the same namespace in the map. This has the side-effect of avoiding later serialization of duplicate namespace prefix declarations in any descendant nodes.
</p>
			</li>
			<li>
`接頭辞~mapに追加する$( %~map, %接頭辞, %~ns )
◎
Add the prefix prefix definition to map given namespace namespace definition.
</li>
			<li>
`局所~接頭辞~map$V[ %接頭辞 ] ~SET %~ns に応じて
⇒＃
~NULL ならば 空~文字列／
~ELSE_ %~ns
◎
Add the value of prefix definition as a new key to the local prefixes map, with the namespace definition as the key's value replacing the value of null with the empty string if applicable.
</li>
		</ol>
	</li>
	<li>
<p>
~RET %既定の~ns属性~値
◎
Return the value of default namespace attr value.
</p>

<p class="note">注記：
空~文字列は ε【！~NULL】 に変換されない
— それも、
%既定の~ns属性~値 として~~合法なので。
◎
Note

The empty string is a legitimate return value and is not converted to null.
</p>
	</li>
</ol>
</div>

			</section>
			<section id="the-namespace-prefix-map">
<h4 title="The Namespace Prefix Map">4.1.2. ~ns接頭辞~map</h4>

<div class="p">
<p>
`~ns接頭辞~map@
は、
`~map$であり，それを成す各~entryの：
</p>
<ul>
	<li>
~keyは、［
文字列／ ~NULL
］である。
文字列は、
~nsを与える。
~NULL は、
どの~nsにも属さないことを表現する。
</li>
	<li>
値は、
`~ns接頭辞~list@
— ~ns接頭辞たちが成す`~list$ —
である。
</li>
</ul>

<p>
これらの~entryの~keyは、
所与の~nodeとその先祖たちにて，それまでに出くわした~nsで拡充され、
各~keyに対応する値は，それまでに遭遇した［
~keyを与える~nsを結付けている接頭辞たち
］で拡充されることになる。
</p>

◎
A namespace prefix map is a map that associates namespaceURI and namespace prefix lists, where namespaceURI values are the map's unique keys (which can include the null value representing no namespace), and ordered lists of associated prefix values are the map's key values. The namespace prefix map will be populated by previously seen namespaceURIs and all their previously encountered prefix associations for a given node and its ancestors.
</div>

<p class="note">注記：
`~ns接頭辞~list$を成す接頭辞たちの順序は、
出くわした順になる。
この~listは、
対応する~nsが与えられたとき，それに合致し得る接頭辞を見出すときに探索される。
見出されなかった場合、
当の~listを成す最後の接頭辞が利用される。
追加的な詳細は、［
`~ns接頭辞~mapを複製する$,
`選好される接頭辞~文字列を検索取得する$
］を見よ。
◎
Note

Note: the last seen prefix for a given namespaceURI is at the end of its respective list. The list is searched to find potentially matching prefixes, and if no matches are found for the given namespaceURI, then the last prefix in the list is used. See copy a namespace prefix map and retrieve a preferred prefix string for additional details.
</p>

<div class="algo">
<p>
`~ns接頭辞~mapを複製する@
~algoは、
所与の
( `~ns接頭辞~map$ %~map )
に対し：
</p>
<ol>
	<li>
%複製 ~LET 新たな`~map$
</li>
	<li>
%~map を成す
~EACH( %~key → %値 )
に対し
⇒
%複製[ %~key ] ~SET %値 を`~cloneする$
</li>
	<li>
~RET %複製
</li>
</ol>
◎
To copy a namespace prefix map map means to copy the map's keys into a new empty namespace prefix map, and to copy each of the values in the namespace prefix list associated with each keys' value into a new list which should be associated with the respective key in the new map.
</div>

<div class="algo">
<p>
`選好される接頭辞~文字列を検索取得する@
~algoは、
所与の
( `~ns接頭辞~map$ %~map, %~ns, %選好される接頭辞 )
に対し，次に従うベキである：
◎
To retrieve a preferred prefix string preferred prefix from the namespace prefix map map given a namespace ns, the user agent should:
</p>

<p class="trans-note">【
（この節の他の~algoも含め，）なぜ “ベキ（ `should^en ）” ？
】</p>

<ol>
	<li>
%接頭辞~list ~LET %~map[ %~ns ]
◎
Let candidates list be the result of retrieving a list from map where there exists a key in map that matches the value of ns or＼
</li>
	<li>
~IF［
%接頭辞~list ~EQ ε
］
⇒
~RET ~NULL
◎
if there is no such key, then stop running these steps, and return the null value.
</li>
	<li>
~Assert：
%接頭辞~list は空でない。
◎
↓</li>
	<li>
~IF［
%選好される接頭辞 ~IN %接頭辞~list
］
⇒
~RET %選好される接頭辞
◎
Otherwise, for each prefix value prefix in candidates list, iterating from beginning to end:
• Note

There will always be at least one prefix value in the list.
• If prefix matches preferred prefix, then stop running these steps and return prefix.
• If prefix is the last item in the candidates list, then stop running these steps and return prefix.
</li>
	<li>
~RET %接頭辞~list を成す最後の~item
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`接頭辞が見出されるか否か@
を検査する~algoは、
所与の
( `~ns接頭辞~map$ %~map, %接頭辞, %~ns )
に対し，次に従うベキである：
◎
To check if a prefix string prefix is found in a namespace prefix map map given a namespace ns, the user agent should:
</p>

<ol>
	<li>
%接頭辞~list ~LET %~map[ %~ns ]
◎
Let candidates list be the result of retrieving a list from map where there exists a key in map that matches the value of ns or＼
</li>
	<li>
~IF［
%接頭辞~list ~EQ ε
］
⇒
~RET ~F
◎
if there is no such key, then stop running these steps, and return false.
</li>
	<li>
~IF［
%接頭辞 ~IN %接頭辞~list
］
⇒
~RET ~T
◎
If the value of prefix occurs at least once in candidates list, return true,＼
</li>
	<li>
~RET ~F
◎
otherwise return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`接頭辞~mapに追加する@
~algoは、
所与の
( `~ns接頭辞~map$ %~map, %接頭辞, %~ns )
に対し，次に従うベキである：
◎
To add a prefix string prefix to the namespace prefix map map given a namespace ns, the user agent should:
</p>

<ol>
	<li>
~IF［
%~map[ %~ns ] ~EQ ε
］
⇒
%~map[ %~ns ] ~SET %接頭辞 のみからなる新たな`~ns接頭辞~list$
◎
Let candidates list be the result of retrieving a list from map where there exists a key in map that matches the value of ns or if there is no such key, then let candidates list be null.
◎
If candidates list is null, then create a new list with prefix as the only item in the list, and associate that list with a new key ns in map.
</li>
	<li>
~ELSE
⇒
%~map[ %~ns ] に %接頭辞 を付加する
◎
Otherwise, append prefix to the end of candidates list.
</li>
</ol>
</div>

<p class="note">注記：
`選好される接頭辞~文字列を検索取得する$手続きは、
`~ns接頭辞~list$を利用して，［
所与の~nsを結付けている接頭辞のうち，最も近過去に利用されたもの†
］を追跡する
— 当の~listを成す最後の接頭辞がそれになる。
この~listは、
より早く出くわした同じ接頭辞を重複して包含し得る（そうなってもかまわない）。
【†原文には <abbr>MRU</abbr> （ `most recently used^en ）という略称も付記されている）。】
◎
Note

The steps in retrieve a preferred prefix string use the list to track the most recently used (MRU) prefix associated with a given namespace, which will be the prefix at the end of the list. This list may contain duplicates of the same prefix value seen earlier (and that's OK).
</p>

			</section>
			<section id="serializing-an-element-s-attributes">
<h4 title="Serializing an Element's attributes">4.1.3. 要素の属性たちの直列化-法</h4>

<div class="algo">
<p>
`要素の属性たちを~XMLに直列化する@
~algoは、
所与の
( `要素$ %要素, `~ns接頭辞~map$ %~map, `局所~接頭辞~map$V, `~ns定義~属性を無視するか$V )
に対し：
◎
The XML serialization of the attributes of an Element element together with a namespace prefix map map, a generated namespace prefix index prefix index reference, a local prefixes map, a ignore namespace definition attribute flag, and a require well-formed flag, is the result of the following algorithm:
</p>

<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%局所~名~集合 ~LET 新たな空~集合
◎
Let localname set be a new empty namespace localname set.＼
</p>

<p>
この集合は、
%要素 の各 `属性$が処理されるに伴い，
`属性$の ( `~ns$A, `局所~名$A ) が成す一意な組たちで拡充されることになる。
◎
This localname set will contain tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is processed.＼
</p>

<p class="note">
注記：
この集合は、［［
要素の 2 個の属性は同じ ( `~ns$A, `局所~名$A ) を有し得ない
］とする整形式~拘束
］を任意選択で施行するために利用される。
これが生じ得るのは、
要素が［
接頭辞のみ相違する 2 個の属性を有するとき
］である。
◎
This set is used to [optionally] enforce the well-formed constraint that an element cannot have two attributes with the same namespaceURI and localName. This can occur when two otherwise identical attributes on the same element differ only by their prefix values.
</p>
	</li>
	<li>
<p id="dfn-loop">
%要素 の`属性~list$を成す
~EACH( `属性$ %属性 )
に対し:
◎
Loop: For each attribute attr in element's attributes, in the order they are specified in the element's attribute list:
</p>
		<ol>
			<li>
( %局所~名, %~ns, %値, %接頭辞 )
~LET %属性 の
( `局所~名$A, `~ns$A, `値$A, `~ns接頭辞$A )
◎
↓</li>
			<li>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
組 ( %~ns, %局所~名 ) ~IN %局所~名~集合
］
⇒
~THROW 例外
⇒
%属性 を直列化すると，要素は整形式にならなくなる。
◎
If the require well-formed flag is set (its value is true), and the localname set contains a tuple whose values match those of a new tuple consisting of attr's namespaceURI attribute and localName attribute, then throw an exception; the serialization of this attr would fail to produce a well-formed element serialization.
</li>
	<li>
%局所~名~集合 に 組 ( %~ns, %局所~名 ) を追加する
◎
Create a new tuple consisting of attr's namespaceURI attribute and localName attribute, and add it to the localname set.
</li>
	<li>
%候補~接頭辞 ~LET ~NULL
【！ Check for an unregistered attribute namespace, and if so, serialize a definition for it】
◎
Let attribute namespace be the value of attr's namespaceURI value.
◎
Let candidate prefix be null.
</li>
	<li>
<p>
~IF［
%~ns ~NEQ ~NULL
］：
◎
If attribute namespace is not null, then run these sub-steps:
</p>
		<ol>
			<li>
%候補~接頭辞 ~LET `選好される接頭辞~文字列を検索取得する$( %~map, %~ns, %接頭辞 )
◎
Let candidate prefix be the result of retrieving a preferred prefix string from map given namespace attribute namespace with preferred prefix being attr's prefix value.
</li>
			<li>
<p>
~IF［
%~ns ~EQ `~XMLNS~ns$
］：
◎
If the value of attribute namespace is the XMLNS namespace, then run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following are true, then stop running these steps and goto Loop to visit the next attribute:
</p>
						<ul>
							<li>
<p>
%値 ~EQ `~XML~ns$
◎
the attr's value is the XML namespace;
</p>

<p class="note">注記：
`~XML~ns$は、
宣言し直せないので，`往復-$時にも生き残る
（それが接頭辞 `xml^l を定義するものでない限り）。
この問題を避けるため，この~algoは、
`~XML~ns$に属する要素には，常に `xml^l を接頭することに加え、
上の条件に見られるとおり，関係する定義を落とす。
◎
Note

The XML namespace cannot be redeclared and survive round-tripping (unless it defines the prefix "xml"). To avoid this problem, this algorithm always prefixes elements in the XML namespace with "xml" and drops any related definitions as seen in the above condition.
</p>
							</li>
							<li>
［
%接頭辞 ~EQ ~NULL
］~AND［
`~ns定義~属性を無視するか$V ~EQ ~T
（ %要素 の既定の~ns属性は，飛ばされるべきである）
］
◎
the attr's prefix is null and the ignore namespace definition attribute flag is true (the Element's default namespace attribute should be skipped);
</li>
							<li>
<p>
~AND↓：
</p>
								<ul>
									<li>
%接頭辞 ~NEQ ~NULL
◎
the attr's prefix is not null and either
</li>
									<li>
`局所~接頭辞~map$V[ %局所~名 ] ~IN { ε, %値 }
◎
the attr's localName is not a key contained in the local prefixes map, or
◎
the attr's localName is present in the local prefixes map but the value of the key does not match attr's value
</li>
									<li>
`接頭辞が見出されるか否か$( `~ns接頭辞~map$, %局所~名, %値 ) ~EQ ~T
◎
and furthermore that the attr's localName (as the prefix to find) is found in the namespace prefix map given the namespace consisting of the attr's value＼
</li>
								</ul>

<p>
（現在の~ns接頭辞~定義は、
%要素 のある先祖~上で定義されたものである。）
◎
(the current namespace prefix definition was exactly defined previously--on an ancestor element not the current element whose attributes are being processed).
</p>
							</li>
						</ul>
<p>
…ならば
⇒
~CONTINUE
◎
↑</p>
					</li>
					<li>
<p>
~IF［
`整形式が要求されるか$V ~EQ ~T
］：
◎
↓</p>
						<ol>
							<li>
<p>
~IF［
%値 ~EQ `~XMLNS~ns$
］
⇒
~THROW 例外
⇒
この属性の直列化は、
妥当でない~XMLを生産する
— `~XMLNS~ns$は、
予約-済みであり，
~XML構文解析を介しては要素の~nsとして適用できないので。
◎
If the require well-formed flag is set (its value is true), and the value of attr's value attribute matches the XMLNS namespace, then throw an exception;＼
the serialization of this attribute would produce invalid XML because the XMLNS namespace is reserved and cannot be applied as an element's namespace via XML parsing.
</p>

<p class="note">注記：
~DOM~APIは、
厳密な~~条件の下で，`~XMLNS~ns$に属する要素の作成を許容する。
◎
Note

DOM APIs do allow creation of elements in the XMLNS namespace but with strict qualifications.
</p>
							</li>
							<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~THROW 例外
⇒
~ns接頭辞~宣言は、
~nsを未宣言にする用途には利用できない
（代わりに既定の~ns宣言を利用すること）。
◎
If the require well-formed flag is set (its value is true), and the value of attr's value attribute is the empty string, then throw an exception;＼
namespace prefix declarations cannot be used to undeclare a namespace (use a default namespace declaration instead).
</li>
						</ol>
					</li>
					<li>
【！ ＊原文 if 抜け】
~IF［
%接頭辞 ~EQ `xmlns^l
］
⇒
%候補~接頭辞 ~LET `xmlns^l
◎
the attr's prefix matches the string "xmlns", then let candidate prefix be the string "xmlns".
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %~ns ~NEQ `~XMLNS~ns$ ）：
◎
Otherwise, the attribute namespace in not the XMLNS namespace. Run these steps:
</p>
				<ol>
					<li>
%候補~接頭辞 ~LET `接頭辞を生成する$( %~map, %~ns )
◎
Let candidate prefix be the result of generating a prefix providing map, attribute namespace, and prefix index as input.
</li>
					<li>
<p>
%結果 に次を順に連結した結果を付加する：
</p>

<ol><li>~SPACE
</li><li>`xmlns:^l
</li><li>%候補~接頭辞
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %~ns )
</li><li>`0022^U
</li></ol>

◎
Append the following to result, in the order listed:
• " " (U+0020 SPACE);
• The string "xmlns:";
• The value of candidate prefix;
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given attribute namespace and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK). 
</li>
				</ol>
			</li>
		</ol>
【！ A namespace prefix has been set by this point if it needed to be set】
	</li>
	<li>
%結果 に ~SPACE を付加する
◎
Append a " " (U+0020 SPACE) to result.
</li>
	<li>
<p>
~IF［
%候補~接頭辞 ~NEQ ~NULL
］
⇒
%結果 に次を順に連結した結果を付加する：
</p>
<ol><li>%候補~接頭辞
</li><li>`003A^U 
</li></ol>
◎
If candidate prefix is not null, then append to result the concatenation of candidate prefix with ":" (U+003A COLON).
</li>
	<li>
<p>
~IF［
~AND↓
］…
</p>
		<ul>
			<li>
`整形式が要求されるか$V ~EQ ~T
</li>
			<li>
<p>
%局所~名 は ~OR↓ を満たす：
</p>

				<ul>
					<li>
`003A^U を包含する
</li>
					<li>
~XML `Name$P 生成規則に合致しない文字列を包含する
</li>
					<li>
%局所~名 ~EQ `xmlns^l
</li>
				</ul>
			</li>
			<li>
%~ns ~EQ ~NULL
</li>
		</ul>
<p>
…ならば
⇒
~THROW 例外
⇒
%属性 の直列化は、
整形式な属性にならない。
</p>
◎
If the require well-formed flag is set (its value is true), and this attr's localName attribute contains the character ":" (U+003A COLON) or does not match the XML Name production or equals "xmlns" and attribute namespace is null, then throw an exception; the serialization of this attr would not be a well-formed attribute.
</li>
	<li>
<p>
%結果 に次を順に連結した結果を付加する：
</p>

<ol ><li>%局所~名
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %値 )
</li><li>`0022^U
</li></ol>

◎
Append the following strings to result, in the order listed:
• The value of attr's localName;
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given attr's value attribute and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK). 
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return the value of result.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性~値を直列化する@
~algoは、
所与の
( %値 )
に対し：
◎
When serializing an attribute value given an attribute value and require well-formed flag, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
%値 内には~XML `Char$P 生成規則に合致しない文字がある
］
⇒
~THROW 例外
⇒
%値 の直列化は、
整形式な要素~直列化を生産することに失敗する。
◎
If the require well-formed flag is set (its value is true), and attribute value contains characters that are not matched by the XML Char production, then throw an exception; the serialization of this attribute value would fail to produce a well-formed element serialization.
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If attribute value is null, then return the empty string.
</li>
	<li>
%結果 ~LET 空~文字列
◎
Otherwise, attribute value is a string.＼
</li>
	<li>
<p>
%値 を成す
~EACH( %文字 )
に対し，順に
⇒
%結果 に ［
%文字 に応じて，次に与える文字列
］を付加する
⇒＃
`0026^U ならば `&amp;amp;^l ／
`0022^U ならば `&amp;quot;^l ／
`003C^U ならば `&amp;lt;^l ／
`003E^U ならば `&amp;gt;^l ／
~ELSE_ %文字
◎
Return the value of attribute value, first replacing any occurrences of the following:
◎
"&amp;" with "&amp;amp;"
◎
""" with "&amp;quot;"
◎
"&lt;" with "&amp;lt;"
◎
"&gt;" with "&amp;gt;"
</p>

<p class="note">注記：
これは、
各種~browserの挙動に合致する。
また， `003E^U も置換することにより、
~XML仕様の `AttValue$P 生成規則による文法を超える要件を課す。
◎
Note

This matches behavior present in browsers, and goes above and beyond the grammar requirement in the XML specification's AttValue production by also replacing "&gt;" characters.
</p>
	</li>
	<li>
~RET %結果
◎
↑</li>
</ol>
</div>

			</section>
			<section id="generating-namespace-prefixes">
<h4 title="Generating namespace prefixes">4.1.4. ~ns接頭辞の生成-法</h4>

<div class="algo">
<p>
`接頭辞を生成する@
~algoは、
所与の
( `~ns接頭辞~map$ %~map, 文字列 %新たな~ns )
に対し：
◎
To generate a prefix given a namespace prefix map map, a string new namespace, and a reference to a generated namespace prefix index prefix index, the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%生成された接頭辞 ~LET 次を順に連結した結果：
</p>

<ol ><li>`ns^l
</li><li>`接頭辞~index$V の数値を直列化した結果
【正確にどう直列化するかは述べられていない。】
</li></ol>

◎
Let generated prefix be the concatenation of the string "ns" and＼
◎
the current numerical value of prefix index.
</li>
	<li>
`接頭辞~index$V ~INCBY 1
◎
Let the value of prefix index be incremented by one.
</li>
	<li>
`接頭辞~mapに追加する$( %~map, %生成された接頭辞, %新たな~ns )
◎
Add to map the generated prefix given the new namespace namespace.
</li>
	<li>
~RET %生成された接頭辞
◎
Return the value of generated prefix.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="xml-serializing-a-document-node">
<h3 title="XML serializing a Document node">4.2. 文書を~XMLに直列化する</h3>

<div class="algo">
<p>
`Document$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type Document is as follows:
</p>

<ol>
	<li>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
%~node の`文書~要素$ ~EQ ~NULL
］
⇒
~THROW 例外
⇒
%~node の直列化は、
整形式な文書にならない。
◎
If the require well-formed flag is set (its value is true), and this node has no documentElement (the documentElement attribute's value is null), then throw an exception; the serialization of this node would not be a well-formed document.
</li>
	<li>
%直列形の文書 ~LET 空~文字列
◎
Otherwise, run the following steps:
◎
Let serialized document be an empty string.
</li>
	<li>
<p>
%~node の`子~群$を成す
~EACH( %子 )
に対し，`~tree順序$で
⇒
%直列形の文書 に次の結果を付加する
⇒
%子 を`~XMLに直列化する$( `文脈~ns$V, `接頭辞~map$V )
◎
For each child child of node, in tree order, run the XML serialization algorithm on the child passing along the provided arguments, and append the result to serialized document.
</p>

<p class="note">注記：
これは、
`文書~要素$の前後にある任意個数の［
`ProcessingInstruction$I ／ `Comment$I
］~node, および
高々 1 個の `DocumentType$I ~nodeも，直列化することになる。
（ `Text$I ~nodeは、
`文書$の子としては許容されない。）
◎
Note

This will serialize any number of ProcessingInstruction and Comment nodes both before and after the Document's documentElement node, including at most one DocumentType node. (Text nodes are not allowed as children of the Document.)
</p>

	</li>
	<li>
~RET %直列形の文書
◎
Return the value of serialized document.
</li>
</ol>
</div>

		</section>
		<section id="xml-serializing-a-comment-node">
<h3 title="XML serializing a Comment node">4.3. `Comment^I ~nodeを~XMLに直列化する</h3>

<div class="algo">
<p>
`Comment$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type Comment is as follows:
</p>

<ol>
	<li>
%~data ~LET %~node の`~data$
◎
↓</li>
	<li>
<p>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
%~data は ~OR↓ を満たす
］…
</p>

<ul ><li>~XML `Char$P 生成規則に合致しない文字がある
</li><li>2 個の `002D^U が成す並びを包含する 
</li><li>`002D^U で終端している
</li></ul>
<p>
…ならば
⇒
~THROW 例外
⇒
%~data の直列化は、
整形式にならない。
</p>
◎
If the require well-formed flag is set (its value is true), and node's data contains characters that are not matched by the XML Char production or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception; the serialization of this node's data would not be well-formed.
</li>
	<li>
<p>
~RET 次を順に連結した結果：
</p>
<ol><li>`&lt;!--^l
</li><li>%~data
</li><li>`--&gt;^l
</li></ol>

◎
Otherwise, return the concatenation of "&lt;!--", node's data, and "--&gt;".
</li>
</ol>
</div>

		</section>
		<section id="xml-serializing-a-text-node">
<h3 title="XML serializing a Text node">4.4. `Text^I ~nodeを~XMLに直列化する</h3>

<div class="algo">
<p>
`Text$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type Text is as follows:
</p>

<ol>
	<li>
%~data ~LET %~node の`~data$
</li>
	<li>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
%~data 内には~XML `Char$P 生成規則に合致しない文字がある
］
⇒
~THROW 例外
⇒
%~data の直列化は、
整形式にならない。
◎
If the require well-formed flag is set (its value is true), and node's data contains characters that are not matched by the XML Char production, then throw an exception; the serialization of this node's data would not be well-formed.
</li>
	<li>
%~markup ~LET 空~文字列
◎
Let markup be the value of node's data.
</li>
	<li>
%~data を成す
~EACH( %文字 )
に対し，順に
⇒
%~markup に ［
%文字 に応じて，次に与える文字列
］を付加する
⇒＃
`0026^U ならば `&amp;amp;^l ／
`003C^U ならば `&amp;lt;^l ／
`003E^U ならば `&amp;gt;^l ／
~ELSE_ %文字
◎
Replace any occurrences of "&amp;" in markup by "&amp;amp;".
◎
Replace any occurrences of "&lt;" in markup by "&amp;lt;".
◎
Replace any occurrences of "&gt;" in markup by "&amp;gt;".
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>
</div>

		</section>
		<section id="xml-serializing-a-documentfragment-node">
<h3 title="XML serializing a DocumentFragment node">4.5. `DocumentFragment^I ~nodeを~XMLに直列化する</h3>

<div class="algo">
<p>
`DocumentFragment$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type DocumentFragment is as follows:
</p>

<ol>
	<li>
%~markup ~LET 空~文字列
◎
Let markup the empty string.
</li>
	<li>
%~node の`子~群$を成す
~EACH( %子 )
に対し，`~tree順序$で
⇒
%~markup に次の結果を付加する
⇒
%子 を`~XMLに直列化する$( `文脈~ns$V, `接頭辞~map$V )
◎
For each child child of node, in tree order, run the XML serialization algorithm on the child given namespace, prefix map, a reference to prefix index, and flag require well-formed. Concatenate the result to markup.
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>
</div>

		</section>
		<section id="xml-serializing-a-documenttype-node">
<h3 title="XML serializing a DocumentType node">4.6. `DocumentType^I ~nodeを~XMLに直列化する</h3>

<div class="algo">
<p>
`DocumentType$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type DocumentType is as follows:
</p>

<ol>
	<li>
( %公な~ID, %~system~ID )
~LET
%~node の ( `公な~ID$dT, `~system~ID$dT )
◎
↓</li>
	<li>
<p>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
~OR↓
］…
</p>
		<ul>
			<li>
%公な~ID 内に［
~XML `PubidChar$P 生成規則に合致しない文字
］がある
</li>
			<li>
%~system~ID 内に［
~XML `Char$P 生成規則に合致しない文字
］がある
</li>
			<li>
%~system~ID 内に［
`0022^U, `0027^U
］の両者がある
</li>
		</ul>
<p>
…ならば
⇒
~THROW 例外
⇒
%~node の直列化は、
整形式の文書~型~宣言にならない。
</p>

◎
If the require well-formed flag is true and the node's publicId attribute contains characters that are not matched by the XML PubidChar production, then throw an exception; the serialization of this node would not be a well-formed document type declaration.
◎
If the require well-formed flag is true and the node's systemId attribute contains characters that are not matched by the XML Char production or that contains both a """ (U+0022 QUOTATION MARK) and a "'" (U+0027 APOSTROPHE), then throw an exception; the serialization of this node would not be a well-formed document type declaration.
</li>
	<li>
<p>
%~markup ~LET 次を順に連結した結果：
</p>
<ol ><li>`003C^U
</li><li>`0021^U
</li><li>`DOCTYPE^l
</li><li>~SPACE
</li><li>%~node の`名前$dT【！ ＊原文誤 Name】
— %~node が`~HTML文書$に属する場合、
この値は小文字のみからなる
</li></ol>

◎
Let markup be an empty string.
◎
Append the string "&lt;!DOCTYPE" to markup.
◎
Append " " (U+0020 SPACE) to markup.
◎
Append the value of the node's name attribute to markup. For a node belonging to an HTML document, the value will be all lowercase.
</li>
	<li>
<p>
~IF［
%公な~ID ~NEQ 空~文字列
］
⇒
%~markup に次を順に連結した結果を付加する：
</p>

<ol><li>~SPACE
</li><li>`PUBLIC^l
</li><li>~SPACE
</li><li>`0022^U
</li><li>%公な~ID
</li><li>`0022^U
</li></ol>

◎
If the node's publicId is not the empty string then append the following, in the order listed, to markup:
• " " (U+0020 SPACE);
• The string "PUBLIC";
• " " (U+0020 SPACE);
• """ (U+0022 QUOTATION MARK);
• The value of the node's publicId attribute;
• """ (U+0022 QUOTATION MARK). 
</li>
	<li>
<p>
~IF［
%~system~ID ~NEQ 空~文字列
］~AND［
%公な~ID ~EQ 空~文字列
］
⇒
%~markup に次を順に連結した結果を付加する：
</p>
<ol><li>~SPACE
</li><li>`SYSTEM^l
</li></ol>
◎
If the node's systemId is not the empty string and the node's publicId is set to the empty string, then append the following, in the order listed, to markup:
• " " (U+0020 SPACE);
• The string "SYSTEM".
</li>
	<li>
<p>
~IF［
%~system~ID ~NEQ 空~文字列
］
⇒
%~markup に次を順に連結した結果を付加する：
</p>
<ol><li>~SPACE
</li><li>`0022^U
</li><li>%~system~ID
</li><li>`0022^U
</li></ol>
◎
If the node's systemId is not the empty string then append the following, in the order listed, to markup:
• " " (U+0020 SPACE);
• """ (U+0022 QUOTATION MARK);
• The value of the node's systemId attribute;
• """ (U+0022 QUOTATION MARK).
</li>

<!-- Removing internalSubset serialization steps as this property is not supported by DOM4. Also,
optional requirements don't help improve interoperability:

<li>Optional: if the <var>node</var> has an (historical) <code><a>internalSubset</a></code> and
the <code><a>internalSubset</a></code> attribute's value is a non-empty string, then append the
following, in the order listed, to <var>markup</var>:
<ol>

<li>"<code> </code>" (U+0020 SPACE);

<li>"<code>[</code>" (U+005B LEFT SQUARE BRACKET);

<li>The value of the <var>node</var>'s <code><a>internalSubset</a></code> attribute;

<li>"<code>]</code>" (U+005D RIGHT SQUARE BRACKET);
</ol>

<p class=note>A <var>node</var> belonging to an <a>HTML document</a> will never have an
<code><a>internalSubset</a></code> because any <code><a>internalSubset</a></code> markup is
ignored by the HTML parser.</p>
-->

	<li>
%~markup に `003E^U を付加する
◎
Append "&gt;" (U+003E GREATER-THAN SIGN) to markup.
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>
</div>

		</section>
		<section id="xml-serializing-a-processinginstruction-node">
<h3 title="XML serializing a ProcessingInstruction node">4.7. `ProcessingInstruction^I ~nodeを~XMLに直列化する</h3>

<div class="algo">
<p>
`ProcessingInstruction$I `型の~nodeを~XMLに直列化する$
~algoは：
◎
The algorithm for producing an XML serialization of a DOM node of type ProcessingInstruction is as follows:
</p>

<ol>
	<li>
( %~target, %~data )
~LET %~node の
( `~target$pI, `~data$ )
◎
↓</li>
	<li>
<p>
~IF［
`整形式が要求されるか$V ~EQ ~T
］~AND［
~OR↓
］…
</p>

<ul ><li>%~target 内に `003A^U がある
</li><li>%~target は`~ASCII大小無視$で `xml^l に合致する
</li><li>%~data 内に~XML `Char$P 生成規則に合致しない文字がある
</li><li>%~data 内に `?&gt;^l （ `003F^U `003E^U ）がある
</li></ul>

<p>
…ならば
⇒
~THROW 例外
⇒
［
%~target ／ %~data
］の直列化は、
整形式にならない。
</p>

◎
If the require well-formed flag is set (its value is true), and node's target contains a ":" (U+003A COLON) character or is an ASCII case-insensitive match for the string "xml", then throw an exception; the serialization of this node's target would not be well-formed.
◎
If the require well-formed flag is set (its value is true), and node's data contains characters that are not matched by the XML Char production or contains the string "?&gt;" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization of this node's data would not be well-formed.
</li>
	<li>
<p>
~RET 次を順に連結した結果：
</p>
<ol ><li>`003C^U
</li><li>`003F^U
</li><li>%~target
</li><li>~SPACE
</li><li>%~data
</li><li>`003F^U
</li><li>`003E^U
</li></ol>
◎
Let markup be the concatenation of the following, in the order listed:
◎
• "&lt;?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
• The value of node's target;
• " " (U+0020 SPACE);
• The value of node's data;
• "?&gt;" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN). 
◎
Return the value of markup.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="dependencies">
<h2 title="A. Dependencies">依存関係</h2>

<p>
【`この節を成す内容の和訳は省略する＠#_conventions$。】
</p>

	</section>
	<section id="revision-history">
<h2 title="B. Revision History">改訂~履歴</h2>

<p>
この仕様の最後の公表からの変更点（参考）を以下に要約する。
この仕様の編集者草案の完全な改訂~履歴は
`W3C Github Repository＠https://github.com/w3c/DOM-Parsing/commits/gh-pages$
にて見出せる。
より~~過去の改訂は、
`W3C Mercurial server＠https://dvcs.w3.org/hg/innerhtml/summary/$
にある。
◎
The following is an informative summary of the changes since the last publication of this specification. A complete revision history of the Editor's Drafts of this specification can be found at the W3C Github Repository and older revisions at the W3C Mercurial server.
</p>

<ul>
	<li>
2016 年 6 月の作業草案にて、
文書を編成し直した：
単体的な~XML直列化~algoは、
数節に~~分解した。
依存関係を明確化した。
~XML直列化~algoは、
相互運用可能な~browserの挙動に近くなるよう更新された。
◎
2016-06 WD - Editorial restructuring of the document; monolithic XML serialization algorithm factored into sections. Dependencies clarified. XML Serialization algorithm updated to get closer to interoperable browser behavior.
</li>
	<li>
`前回の Last Call 文書からの規範的でない変更点＠https://dvcs.w3.org/hg/innerhtml/raw-file/tip/LC2_comments.html$
を組入れた。
◎
Incorporated non-normative changes from previous Last Call document.
</li>
</ul>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様が基づいている元の
DOM Parsing and Serialization Living Standard
を作成して保守された［
Ms2ger 氏と WHATWG の他の方々による元の仕事
］に感謝する：
◎
We acknowledge with gratitude the original work of Ms2ger and others at the WHATWG, who created and maintained the original DOM Parsing and Serialization Living Standard upon which this specification is based.
</p>

<p lang="en">
Thanks to C. Scott Ananian, Victor Costan, Aryeh Gregor, Anne van Kesteren, Arkadiusz Michalski, Simon Pieters, Henri Sivonen, Josh Soref and Boris Zbarsky, for their useful comments.
</p>

<p>
`HTML5$r にて
`innerHTML$m, `outerHTML＠~HTMLdynamic#dom-element-outerhtml$m 属性,
`insertAdjacentHTML()＠~HTMLdynamic#dom-element-insertadjacenthtml$m ~methodを最初に定義され，有用な~commentを書かれた Ian Hickson 氏に特別な謝意を。
◎
Special thanks to Ian Hickson for first defining the innerHTML and outerHTML attributes, and the insertAdjacentHTML method in [HTML5] and his useful comments.
</p>

	</section>
</main></div>
