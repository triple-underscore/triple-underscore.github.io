<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>DOM Parsing and Serialization （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 161114 spec
}

function expand(){

	var class_map = {
		E: 'error',
		P: 'production',
		v: 'value',
		e: 'element',
		a: 'attr',
		U: 'code-point',
	};

	var tag_map = {
		I: 'code',
		E: 'code',
		m: 'code',
		mA: 'code',
		P: 'code',
		e: 'code',
		a: 'code',
		c: 'code',
		U: 'span',
		i: 'i',
		v: 'code',
		V: 'var',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
	 // IDL member
case 'm':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l': // literal
	return '"<code class="literal">' + text + '</code>"'
	break;
case 'U': // 
	text = '<span class="code-point">U+' + key + '</span> (<span class="char-symbol">&#x' + key + ';</span>)';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2017-10-11
trans_update:2017-10-30
original_url:https://w3c.github.io/DOM-Parsing/
spec_status:ED
ref_id_prefix:bib-
copyright:2016,permissive
trans_1st_pub:2017-08-03


●●original_id_map


●●words_table1


SPACE:<span class="code-point">U+0020</span> SPACE
XML10:https://www.w3.org/TR/xml/


●●words_table



	●markup／ns
ns:namespace:::名前空間
名前:name::~
名:name::~
値:value::~
接頭辞:prefix::~
接頭-:prefix::~
局所的:local::~::ローカル
局所:local::~::ローカル
	局所~名:localname
	局所的に定義されlocally-defined
有修飾:qualified::~
文脈:context::~
既定の:default::~::デフォルト
既定:default::~::デフォルト
MIME:
DOM:
XML:
XMLNS:
XHTML:
HTML:
markup::::マークアップ
publicID:public ID::public 識別子
systemID:system ID::system 識別子
終了tag:end tag::終了 tag:終了タグ
開始tag:start tag::開始 tag:開始タグ
tag::::タグ
void:
target:
ASCII:
UTF-8:
Unicode:
妥当:valid::~
	妥当でない:invalid
小文字:lowercase::~
	数:number:~
整形式:well-formed::~
文字:character::~
文字列:string::~
文法:grammar::~
構文:syntax::~
素片:fragment::~
終端-:end:~


	●往来
stream::::ストリーム
往来:round-trip::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
直列形の:serialized::~::シリアル形の
生成規則:production:~
生産-:produce:~
	再~宣言-:redeclare
宣言-:declare:~
宣言:declaration:~
宣言的:declarative:~
未宣言に:undeclare:~
記録-:record::~
選好-:prefer::~

開始済み:already started::~
解析器挿入:parser-inserted::~::パーサ挿入

	●DOM
node::::ノード
	leaf-node:
obj:object:::オブジェクト
template:
comment::::コメント
text::::テキスト
data::::データ
型:type::~
同胞:sibling::~
子:child::~
子たち:children::~
子孫:descendant::~
属性:attribute::~
	attr
文書:document::~
木:tree::~::ツリー
根:root::~::ルート
先祖:ancestor::~
	先祖たち:ancestry
要素:element::~
親:parent::~
内容:content::~


	●仕様
API:
UA:user agent:UA
algo:algorithm:::アルゴリズム
app:application:::アプリ
browser::::ブラウザ
model::::モデル
明示的:explicit:~
条件:condition:~
条件付き:conditional:~
正しく:correct に:~
正確:exact:~
特別な:special:~
特有の:specific な:~
用語:term:~
発行版:publication:~
編集者草案:Editor’s Drafts:~
勧告候補:Candidate Recommendation:~
作業草案:Working Draft:~
昇格基準:exit criteria:~
相互運用可能:interoperable:~
相応しい:suitable な:~
規則:rule:~
詳細:details:~
実際:actual:~
事例:case:~
互換:compatible:~
仕方:way:~
仕様:specification:~
共通的な:common:よくある
副作用:side-effect:~
単純:simple:~
厳格:strict:~
有用:useful:~
可用:available:~
問題:problem:~
手段:means:~
手続き:steps:~
	sub-steps
	下位~手続き
段:step:~
理想的:ideal:~
資質:nature:~
一律:uniform:~
単体的:monolithic:~
規範的:normative:~
	規範的でない:non-normative
要件:requirements:~
	要件:requirement:~
情報:information:~
履歴:history:~
合法:legal:~
	例:example:~
	可能:possible
	~~合法:legitimate
	~~条件:qualifications
	要約:summary／Abstract
	任意選択で:optionally:
	flavor
	違って:unlike
	込み入って:tricky
	参考:informative
	~~分解-:factor:~
	謝意:thank
	に感謝:acknowledge with gratitude
	より深い:greater
	織り込まれ:account
	必要:need
	必要とされ:necessary
	不必要な:unnecessary:~
	依然として:still
	〜に基づく:based
	しかしながら，:however
	したがって:thus
	とりわけ:especially
	に関して with respect to
	べき:should
	かまわない:OK

	●仕様（動詞
support::::サポート
定義-:define:~
定義:definition:~
保守-:maintain:~
意味-:mean:~
	扱う／配慮-:concern:~
	則って:according:~
組入れた:incorporate した:組み入れた
仕事:work:~
作業:work:~
変更点:changes:~
	従う:as follows
拘束:constraint:~
挙動:behavior:ふるまい
	-:provide
改訂:revision:~
施行-:enforce:~
明確化-:clarify:~
望む:wish:~
検査-:check:~
無視-:ignore:~
相違-:differ:~
省略-:omit:~
確保-:ensure:~
競合-:conflict:~
考慮-:consider:~
考える:consider する:~
	見よ:see:~
見做され:assume され:~
設計-:design:~
許容-:allow:~
試み:attempt:~
試行-:try:~
述べる:describe する:~
述べら:describe さ:~
適合-:conform:~
適合:conforming:~
適用-:apply:~
適用可能:applicable:~
避ける:avoid する:~
防止-:prevent:~
取扱われ:handle され:取り扱われ
取扱い:handling:取り扱い
結付けて:associate して:結び付けて
	association
	associated
依存関係:dependencies:~
	編成し直した:Editorial restructuring
拡張:extension:~


	●未分類（動詞
取得-:get::~
取得子:getter::~
	On getting
設定-:set::~
設定子:setter::~
	On setting:~
付加-:append::~
作成-:create::~
作成:creation::~
処理-:process::~
可能化-:enable::~
不能化-:disable::~
不能化:disabled::~
合致-:match::~
投出:throw::~
拡充-:populate:~
検索取得-:retrieve::~
構築子:constructor::~::コンストラクタ
構築-:construct::~
生成-:generate::~
作動中の:active な::~::アクティブな

訪問:visit:~
探索-:search:~
上書き:override:~
予約-:reserve:~
	予約-済み:reserved
判別-:distinguish:~
利用-:use:~
動作-:act:~
包含-:contain:~
参照-:reference:~
保全-:preserve:~
入力:input:~
被呼出時:被 invoke 時:~
呼出され:invoke され:~
	invoking

受信-:recieve:~
変更-:change:~
失敗-:fail:~
成功-:success:~
	successful
存在-:exist:~
既存の:exist している:~
完全:complete:~
	対応ing:corresponding:~
	得-:obtain:~
	戻-:back:~

指定-:specify:~
挿入-:insert::~

接続-:connect:~

変形-:transform::~
変換-:convert::~

操作-:manipulate:~
	manipulation
更新-:update:~
有順序:ordered:~

組合せ:combination:~
置換-:replace:~
表現-:represent::~
表現:representation::~

継承-:inherit::~
符号化方式:encoding::~::エンコーディング
複製:copy:~
見出す:find する:~
見出して:find して:~
見出され:find され:~
見出せる:find できる:~

誘発-:trigger::~
読取る:read する:~
走らせ:run し:~
走らす:run する:~
追加-:add:~
追加の:additional:~
追跡-:track:~
連結:concatenation::~
遭遇-:encounter:~
開始-:start:~
始端:start:~
関係-:relate:~
飛ばす:skip する:~
	返す:return:~
	示す:show:~
	含-:include:~
	含めて:including:~
	在-:present:~
	渡-:pass:~
	生じ:occur:~
	落とされ:drop
	代用の:replacement:#1
	代用され:substitute
	生き残る:survive:
	出くわした:seen
	見られる:seen
	失われ:loss
	近くなる:get closer
	見せかけた:made to look like
	ことになる:get
	〜の代わりに:instead
	あてがう:assign


	●未分類
IDL:
URL:
catch:
map:
entry:
error::::エラー
flag::::フラグ
item::::
key::::
pair::::ペア
prop:property::::プロパティ
index::::
interface::::インタフェース
list::::リスト
method::::メソッド
空:empty:~
一意:unique:~
例外:exception:~
引数:argument:~
集合:set:~
順序:order:~
列挙:enumeration:~
	組:tuple



memory::::メモリ
	~memory内:in-memory
	perror:parse error::構文解析 error:構文解析エラー:パースエラー
	-:label
mark::::マーク
script::::スクリプト
scripting::::スクリプト処理
web:
同一性:identity:~
位置:position:~
候補:candidate:~
内側:inside:~
初期:initial:~
	初期~時には:initially
直接的:direct:~
等価:equivalent:~
言語:language:~
実行不能:unexecutable:~

	Assert:assert
	-:per
	-:passing
	-:caller
	-:Re-throw
	map:mapping
	followed
	この時点で／:At this point
	seen
	potentially
	-:iterating
	-:beginning
	-:at least
	most recently used
	MRU
	OK
	-:together
	-:consisting
	-:furthermore
	-:occurrence
	超える:beyond
	LESS-THAN SIGN
	QUESTION MARK
	GREATER-THAN
	WHATWG
	we
	形:form
	数値 numerical value
	一致:identical
	等し:equal:~
	節:section:~
	重複／重ねて:duplicate:~
	-:respective
	-:wereas
	-:additionally
	taken
	-:go
	並び:adjacent


	●指示語
新たな:new:~
所与の:given:~
	与-:give:~
現在の:current:~
特定0の:particular:ある特定の
自前の:own:~
元の:original:~
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	その他:others
	それら:they
	それらの:their
	それらの:those
	上:above
	両者:both
	介:via
	他の:other
	他の場合:otherwise
	前:before
	各:each
	合間:between
	同じ:same
	常に:always
	後:after
	新たに:newly
	より早く:earlier
	最初の:first
	最後の:last
	次0:next
	異なる:different
	各種:various
	結果:result
	結果の:resulting
	自身:itself
	個の:one／two
	他方:wereas
	任意個数の:any number
	高々:at most
	それまでに:previously
	直前／前回／-:previous
	後で:later
	以降の／remaining
	ほとんどの:most
	即:immediate
	より~~過去の:older
	通:through:~


●●link_map



	●IDL
CEReactions:~HEcustom#cereactions
Constructor:~WEBIDL#Constructor
Exposed:~WEBIDL#Exposed

DOMString:~WEBIDL#idl-DOMString
NewObject:~WEBIDL#NewObject
TreatNullAs:~WEBIDL#TreatNullAs

	＊
	I.DOMException:~WEBIDL#

E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NoModificationAllowedError:~WEBIDL#nomodificationallowederror
E.SyntaxError:~WEBIDL#syntaxerror

I.DOMParser:#dom-domparser
I.XMLSerializer:#dom-xmlserializer
I.Range:~DOM4#range
I.XMLDocument:~DOM4#xmldocument
I.SupportedType:#idl-def-supportedtype

I.Attr:~DOM4#attr
I.Comment:~DOM4#comment
I.Document:~DOM4#document
I.DocumentFragment:~DOM4#documentfragment
I.DocumentType:~DOM4#documenttype
I.Element:~DOM4#element
I.Node:~DOM4#node
I.ProcessingInstruction:~DOM4#processinginstruction
I.Text:~DOM4#text

m.DOMParser:#dom-domparser
m.XMLSerializer:#dom-xmlserializer
m.setAttribute:~DOM4#dom-element-setattribute
	#dfn-setattribute
m.innerHTML:#dom-element-innerhtml
m.outerHTML:#dom-element-outerhtml
m.insertAdjacentHTML:#dom-element-insertadjacenthtml
m.parseFromString:#dom-domparser-parsefromstring
m.serializeToString:#dom-xmlserializer-serializetostring
m.createContextualFragment:#dfn-createcontextualfragment-fragment
m.location:~HISTORY#dom-document-location
m.namespaceURI:~DOM4#dom-element-namespaceuri
	m.data:~DOM4#dom-characterdata-data

e.meta:~HEmetadata#the-meta-element
e.noscript:~HEscripting#the-noscript-element
e.script:~HEscripting#the-script-element
e.template:~HEscripting#the-template-element

l.application/xhtml+xml:#dom-supportedtype-application/xhtml+xml
l.application/xml:#dom-supportedtype-application/xml
l.image/svg+xml:#dom-supportedtype-image/svg+xml
l.text/html:#dom-supportedtype-text/html
l.text/xml:#dom-supportedtype-text/xml

P.AttValue:~XML10#NT-AttValue
P.Char:~XML10#NT-Char
P.EmptyElemTag:~XML10#NT-EmptyElemTag
P.Name:~XML10#NT-Name
P.PubidChar:~XML10#NT-PubidChar


	●

構文解析:#dfn-parsing
直列化-:#dfn-serializing
~HTML直列化:#dfn-html-serialization
~XML直列化:#dfn-xml-serialization

素片を構文解析する:#dfn-fragment-parsing-algorithm
素片を直列化する:#dfn-fragment-serializing-algorithm
属性~値を直列化する:#dfn-serializing-an-attribute-value

~XMLに直列化する:#dfn-xml-serialization-algorithm
~nodeを~XMLに直列化する:#dfn-xml-serialization-algorithm
型の~nodeを~XMLに直列化する:#dfn-producing-an-xml-serialization-of-a-dom-node

属性たちを~XMLに直列化する:#dfn-xml-serialization-of-the-attributes

	i.Loop:#dfn-loop
	i.Main:#dfn-main
	:#dfn-found-a-suitable-namespace-prefix
	:#xml-serializing-an-element-node
	:#xml-serializing-a-comment-node
	:#xml-serializing-a-document-node
	:#xml-serializing-a-documentfragment-node
	:#xml-serializing-a-documenttype-node
	:#xml-serializing-a-processinginstruction-node
	:#xml-serializing-a-text-node

接頭辞は見出される:#dfn-found
~ns接頭辞~mapを複製する:#dfn-copy-a-namespace-prefix-map
接頭辞を生成する:#dfn-generate-a-prefix
	~ns接頭辞~生成-用~index:#dfn-generated-namespace-prefix-index

V.有修飾~名:#dfn-qualified-name
~ns接頭辞~list:#dfn-namespace-prefix-lists
~ns接頭辞~map:#dfn-namespace-prefix-map
~ns情報を記録する:#dfn-recording-the-namespace-information
選好される接頭辞~文字列を検索取得する:#dfn-retrieve-a-preferred-prefix-string

V.文脈~ns:#dfn-context-namespace
	V.文脈~ns:#dfn-namespace
V.~ns定義~属性は無視する~flag:#dfn-ignore-namespace-definition-attribute
V.接頭辞~map:#dfn-prefix-map
	V.継承される~ns:#dfn-inherited-ns
V.局所的な既定の~ns:#dfn-local-default-namespace
V.局所~接頭辞~map:#dfn-local-prefixes-map
V.接頭辞~index:#dfn-prefix-index
V.要~整形式~flag:#dfn-require-well-formed
	＊#dfn-skip-end-tag

往来-:#dfn-round-tripping
空~要素~tag:~XML10#dt-eetag

	■INFRA
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~HTML~ns:~INFRA#html-namespace
~XML~ns:~INFRA#xml-namespace
~XMLNS~ns:~INFRA#xmlns-namespace


	■HTML5
作動中の文書:~BROWSERS#active-document
~template内容:~HEscripting#template-contents

開始済み~flag:~HEscripting#already-started
解析器挿入~flag:~HEscripting#parser-inserted

~HTML素片を構文解析する:~HTMLparsing#html-fragment-parsing-algorithm
~HTML素片を直列化-:~HTMLwriting#html-fragment-serialisation-algorithm
~HTML構文解析器:~HTMLparsing#html-parser
~XHTML文書を構文解析-:~HTMLxml#parsing-xhtml-documents
~XML素片を構文解析する:~HTMLxml#xml-fragment-parsing-algorithm
~XML素片を直列化-:~HTMLxml#xml-fragment-serialisation-algorithm
~XML構文解析器:~HTMLxml#xml-parser

~XML~scriptingの~supportは不能化-:~HTMLxml#xml-scripting-support-disabled
~scripting~flag:~HTMLparsing#scripting-flag
~void要素:~HTMLwriting#void-elements

文脈~要素:~HTMLparsing#concept-frag-parse-context

	●DOM
~node:~DOM4#concept-node
~node文書:~DOM4#concept-node-document

文書:~DOM4#concept-document
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
doc.~URL:~DOM4#concept-document-url
doc.種別:~DOM4#concept-document-type
doc.内容~型:~DOM4#concept-document-content-type
doc.符号化方式:~DOM4#concept-document-encoding

属性:~DOM4#concept-attribute
A.値:~DOM4#concept-attribute-value
A.~ns:~DOM4#concept-attribute-namespace
A.~ns接頭辞:~DOM4#concept-attribute-namespace-prefix
A.局所~名:~DOM4#concept-attribute-local-name
A.有修飾~名:~DOM4#concept-attribute-qualified-name
	mA.name

要素:~DOM4#concept-element
属性~list:~DOM4#concept-element-attribute
eL.~ns接頭辞:~DOM4#concept-element-namespace-prefix
eL.~ns:~DOM4#concept-element-namespace
eL.局所~名:~DOM4#concept-element-local-name

	doctype:#dfn-doctype
	:~DOM4#dom-document-doctype
dT.~systemID:~DOM4#concept-doctype-systemid
dT.~publicID:~DOM4#concept-doctype-publicid
dT.名前:~DOM4#concept-doctype-name

~data:~DOM4#concept-cd-data
pI.~target:~DOM4#concept-pi-target


要素を作成する:~DOM4#concept-create-element
文書~要素:~DOM4#document-element
親:~DOM4#concept-tree-parent
子:~DOM4#concept-tree-child
最初の子:~DOM4#concept-tree-first-child
次の同胞:~DOM4#concept-tree-next-sibling
接頭辞~mapに追加する:#dfn-add
~nodeを子の前に挿入する:~DOM4#concept-node-insert
全~内容を~nodeで置換する:~DOM4#concept-node-replace-all
すべて置換-:~DOM4#concept-node-replace-all
子を~nodeに置換する:~DOM4#concept-node-replace
~nodeを付加する:~DOM4#concept-node-append
木~順序:~DOM4#concept-tree-order
始端~node:~DOM4#concept-range-start-node

~map:~INFRA#ordered-map


●●spec_metadata



最新発行バージョン
	https://www.w3.org/TR/DOM-Parsing/

編集者草案
	https://w3c.github.io/DOM-Parsing/

編集
    Travis Leithead, Microsoft, <a href="mailto:travis.leithead@microsoft.com">travis.leithead@microsoft.com</a>

テスト一式
	http://w3c-test.org/domparsing/
	http://w3c-test.org/html/syntax/

Participate:
	<a href="https://github.com/w3c/DOM-Parsing">We are on Github.</a>
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?component=DOM%20Parsing%20and%20Serialization&amp;list_id=44989&amp;product=WebAppsWG&amp;resolution=---">Bugzilla Bug list.</a>
	<a href="https://github.com/w3c/DOM-Parsing/issues">Github Issues.</a>
	<a href="https://github.com/w3c/DOM-Parsing/commits">Commit history.</a>
	<a href="http://lists.w3.org/Archives/Public/www-dom/">Mailing list.</a>


●●ref_normative
[DOM4]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML5]
    HTML5. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O'Connor; Silvia Pfeiffer. W3C. 28 October 2014. W3C Recommendation. URL: https://www.w3.org/TR/html5/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WEBIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/


●●ref_informative
[ECMA-262]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.github.io/ecma262/ 
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[XML10]
    Extensible Markup Language (XML) 1.0 (Fifth Edition). Tim Bray; Jean Paoli; Michael Sperberg-McQueen; Eve Maler; François Yergeau et al. W3C. 26 November 2008. W3C Recommendation. URL: https://www.w3.org/TR/xml


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">DOM Parsing and Serialization</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

<!-- 原文 id／link

I.DOMException:#dfn-domexception
I.DOMException:~DOM4#domexception

E.TypeError:#dfn-typeerror
E.InvalidStateError:#dfn-invalidstateerror
E.InvalidStateError:~DOM4#invalidstateerror
E.NoModificationAllowedError:#dfn-nomodificationallowederror
E.NoModificationAllowedError:~DOM4#nomodificationallowederror
E.SyntaxError:#dfn-syntaxerror
E.SyntaxError:~DOM4#syntaxerror

I.Range:#dom-range
I.XMLDocument:#dfn-xmldocument
I.Attr:~DOM4#interface-attr
I.Attr:#dfn-attr
I.Comment:#dfn-comment
I.Comment:~DOM4#interface-comment
I.Document:#dfn-document
I.DocumentFragment:#dfn-documentfragment
	~doctype:~DOM4#concept-doctype
I.DocumentType:#dfn-documenttype
I.DocumentType:~DOM4#interface-documenttype
I.Element:#dom-element
I.Node:#dfn-node
~node:#dfn-node
I.ProcessingInstruction:#dfn-processinginstruction
I.ProcessingInstruction:~DOM4#interface-processinginstruction
I.Text:#dfn-text
I.Text:~DOM4#interface-text

m.setAttribute:#dfn-setattribute
m.createContextualFragment:#idl-def-range-createcontextualfragment%28fragment%29
e.meta:#dfn-meta
e.meta:~TR/html5/single-page.html#meta
e.noscript:#dfn-noscript
e.noscript:~TR/html5/single-page.html#the-noscript-element
e.script:#dfn-script
e.script:~TR/html5/single-page.html#script
e.template:#dfn-template
e.template:~TR/html5/single-page.html#the-template-element

P.AttValue:#dfn-attvalue
P.Char:#dfn-char
P.EmptyElemTag:#dfn-emptyelemtag
P.Name:#dfn-name
P.PubidChar:#dfn-pubidchar


	●

	#dfn-xml-serializing
此れ:#dfn-context-object
:#dfn-skip-end-tag
空~要素~tag:#dfn-empty-element-tag
例外を投出-:#dfn-exception
~ASCII大小無視:#dfn-ascii-case-insensitive
~ASCII大小無視:~TR/dom/#ascii-case-insensitive
~HTML~ns:#dfn-html-namespace
~XML~ns:#dfn-xml-namespace
~XMLNS~ns:#dfn-xmlns-namespace
case-sensitive:#dfn-case-sensitive
case-sensitive:~TR/dom/#case-sensitive


	■HTML5
作動中の文書:#dfn-active-document
作動中の文書:~TR/html5/single-page.html#active-document
~template内容:#dfn-template-contents
~template内容:~TR/html5/single-page.html#template-contents

~HTML素片を構文解析する:#dfn-html-fragment-parsing-algorithm
~HTML素片を構文解析する:~TR/html5/single-page.html#html-fragment-parsing-algorithm
~HTML素片を直列化-:#dfn-html-fragment-serialization-algorithm
~HTML素片を直列化-:~TR/html5/single-page.html#html-fragment-serialization-algorithm
~HTML構文解析器:#dfn-html-parser
~HTML構文解析器:~TR/html5/single-page.html#html-parser
~XHTML文書を構文解析-:#dfn-parsing-xhtml-documents
~XHTML文書を構文解析-:~TR/html5/single-page.html#parsing-xhtml-documents
~XML素片を構文解析する:#dfn-xml-fragment-parsing-algorithm
~XML素片を構文解析する:~TR/html5/single-page.html#xml-fragment-parsing-algorithm
~XML素片を直列化-:#dfn-xml-fragment-serialization-algorithm
~XML素片を直列化-:~TR/html5/single-page.html#xml-fragment-serialization-algorithm
~XML構文解析器:#dfn-xml-parser
~XML構文解析器:~TR/html5/single-page.html#xml-parser

~scripting~flag:#dfn-scripting-flag
~scripting~flag:~TR/html5/single-page.html#scripting-flag
~void要素:#dfn-void-elements
~void要素:~TR/html5/single-page.html#void-elements
m.location:#dfn-location
m.location:~TR/html5/single-page.html#location
文脈~要素:#dfn-context
文脈~要素:~TR/html5/single-page.html#concept-frag-parse-context


	●DOM

属性~list:~DOM4#concept-element-attribute
m.attributes:~DOM4#dom-element-attributes
m.attributes:#dfn-attributes

A.値:~DOM4#concept-attribute-value
mA.value:~DOM4#dom-attr-value
mA.value:#dfn-attr.value
A.~ns:~DOM4#concept-attribute-namespace
mA.namespaceURI:~DOM4#dom-attr-namespaceuri
mA.namespaceURI:#dfn-attr.namespaceuri
A.~ns接頭辞:~DOM4#concept-attribute-namespace-prefix
mA.prefix:~DOM4#dom-attr-prefix
mA.prefix:#dfn-attr.prefix
A.局所~名:~DOM4#concept-attribute-local-name
mA.localName:~DOM4#dom-attr-localname
mA.localName:#dfn-attr.localname
A.有修飾~名:~DOM4#concept-attribute-qualified-name
mA.name

eL.~ns接頭辞:~DOM4#concept-element-namespace-prefix
m.prefix:~DOM4#dom-element-prefix
m.prefix:#dfn-element.prefix

eL.~ns:~DOM4#concept-element-namespace
m.namespaceURI:~DOM4#dom-element-namespaceuri
m.namespaceURI:#dfn-element.namespaceuri
eL.局所~名:~DOM4#concept-element-local-name
m.localName:~DOM4#dom-element-localname
m.localName:#dfn-element.localname

dT.~systemID:~DOM4#concept-doctype-systemid
m.systemId:~DOM4#dom-documenttype-systemid
m.systemId:#dfn-systemid
dT.~publicID:~DOM4#concept-doctype-publicid
m.publicId:~DOM4#dom-documenttype-publicid
m.publicId:#dfn-publicid
dT.名前:~DOM4#concept-doctype-name
m.name:~DOM4#dom-documenttype-name

~data:~DOM4#concept-cd-data
m.data:~DOM4#dom-characterdata-data
m.data:#dfn-data

文書~要素:~DOM4#document-element
m.documentElement:~DOM4#dom-document-documentelement
m.documentElement:#dfn-documentelement

pI.~target:~DOM4#concept-pi-target
m.target:~DOM4#dom-processinginstruction-target
m.target:#dfn-target
doctype:#dfn-doctype
doctype:~DOM4#dom-document-doctype
m.name:~DOM4#dom-documenttype-name
m.name:#dfn-doctype.name


子:#dfn-children
最初の子:#dfn-first-child
次の同胞:#dfn-next-sibling
親:#dfn-parent
doc.種別:~DOM4#concept-document-type
doc.内容~型:#dfn-content-type
doc.符号化方式:#dfn-encoding
~HTML文書:#dfn-html-document
~XML文書:#dfn-xml-document
局所~名:#dfn-local-name
~ns:#dfn-namespace-concept
~node文書:#dfn-node-document
~nodeを子の前に挿入する:#dfn-insert
全~内容を~nodeで置換する:#dfn-replace-all
置換-:#dfn-replace
~nodeを付加する:#dfn-append
木~順序:#dfn-tree-order
始端~node:#dfn-start-node
doc.~URL:#dfn-url

 -->



</head>

<body>

<header>



	<hgroup>
<h1>DOM の構文解析と直列化 — DOM Parsing and Serialization</h1>
<h2 title="DOMParser, XMLSerializer, innerHTML, and similar APIs"><code >DOMParser</code>, <code >XMLSerializer</code>, <code >innerHTML</code> などの API</h2>

	</hgroup>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、
~HTML／~XML
に基づく~DOM~nodeを構文解析する／直列化するための，~web~app用~APIを定義する。
◎
This specification defines APIs for the parsing and serializing of HTML and XML-based DOM nodes for web applications.
</p>

	</section>
	<section id="sotd">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<!-- 
This document was published by the Web Platform Working Group as an Editor's Draft. If you wish to make comments regarding this document, please send them to www-dom@w3.org (subscribe, archives) with DOM-Parsing at the start of your email's subject. All comments are welcome.
 -->

	</section>

<main id="MAIN0">


	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<ul>
	<li>
 原文にて［
`HTML51$r ／ `DOM4$r
］による定義を参照している用語は、便宜のため，この訳では WHATWG による［
HTML ／ DOM
］標準（の和訳）による定義への参照に代えている。
</li>
	<li>
同様に，原文による各種~nsの定義は、
WHATWG Infra 標準によるそれらへの参照に代えている（ `~XMLNS~ns$など）。
</li>
	<li>
この仕様が課す要件の対象は常に~UAなので、 “~UA” は省略する。
</li>
	<li>
原文の~IDL属性を通して述べられている箇所の多くは、当の~IDL属性が表現する下層~modelの用語で述べる（例えば、要素の `namespaceURI$m → 要素の`~ns$eL）。
</li>
</ul>



	</section>
	<section id="crec">
<h2 title="Candidate Recommendation Exit Criteria">勧告候補からの昇格基準</h2>

<p>
【この節の内容の和訳は省略する。】
◎
This specification will not advance to Proposed Recommendation before the spec's test suite is completed and two or more independent implementations pass each test, although no single implementation must pass each test. We expect to meet this criteria no sooner than 24 October 2014. The group will also create an Implementation Report.
</p>

	</section>
	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
文書~obj~model（~DOM）は、それぞれが木に接続されている各種~型の`~node$たちが成す，~memory内~表現である。
~DOMとその`~node$のより深い詳細は
`HTML5$r ／ `DOM4$r
仕様に述べられる。
◎
A document object model (DOM) is an in-memory representation of various types of Nodes where each Node is connected in a tree. The [HTML5] and [DOM4] specifications describe DOM and its Nodes is greater detail.
</p>

<p>
用語
`構文解析@
は、~DOMの文字列~表現を実際の~DOMへ変換するときに利用され、
`直列化-@
は~DOMを文字列へ変形して戻すときに利用される用語である。
この仕様~自身は、~DOMを
構文解析する／直列化する
ための各種~APIを定義することを扱う。
◎
Parsing is the term used for converting a string representation of a DOM into an actual DOM, and Serializing is the term used to transform a DOM back into a string. This specification concerns itself with defining various APIs for both parsing and serializing a DOM.
</p>

<div class="example">

<p>
例えば `innerHTML$m ~APIは、［
~DOMを直列化する ／ ~DOMに構文解析する
］共通的な仕方を与える（それは、この両方とも行える）。
特定0の`~node$の~memory内~DOMが次であったとする：
◎
For example: the innerHTML API is a common way to both parse and serialize a DOM (it does both). If a particular Node, has the following in-memory DOM:
</p>

<div>
<ol><li>`HTMLDivElement^I （ `nodeName^m ~EQ `div^l ）
	<ol><li>`HTMLSpanElement^I （ `nodeName^m ~EQ `span^l)
		<ol><li>`Text^I （ `data^m ~EQ `ある^l ）
		</li></ol>
	</li><li>`HTMLElement^I （ `nodeName^m ~EQ `em^l ）
		<ol><li>`Text^I （ `data^m ~EQ `文章。^l ）
		</li></ol>
	</li></ol>
</li></ol>

<pre lang="en">HTMLDivElement (nodeName: `div^l)
┃
┣━ HTMLSpanElement (nodeName: `span^l)
┃  ┃
┃  ┗━ Text (data: `some ^l)
┃
┗━ HTMLElement (nodeName: `em^l)
   ┃
   ┗━ Text (data: `text!^l)
</pre>

</div>

<p>
`HTMLDivElement^I ~nodeの子たちを直列化するためには、単純に`要素$の `innerHTML$m ~propを<em>取得する</em>（読取る）
（これは、直列化を誘発する）：
◎
And the HTMLDivElement node is stored in a variable myDiv, then to serialize myDiv's children simply get (read) the Element's innerHTML property (this triggers the serialization):
</p>

<pre>
var %myDiv = /* <span class="comment">
`HTMLDivElement^I ~node
</span> */
var %serializedChildren = %myDiv.innerHTML;
/* <span class="comment">
結果は `&lt;span&gt;ある&lt;/span&gt;&lt;em&gt;文章。&lt;/em&gt;^l になる。
◎
serializedChildren has the value: "&lt;span&gt;some &lt;/span&gt;&lt;em&gt;text!&lt;/em&gt;"
</span>
</pre>


<p>
文字列から
%myDiv 用の（その既存の子たちを置換して）新たな子を構文解析するためには、単純に
`innerHTML$m ~propを<em>設定-</em>する
（これは、あてがわれた文字列の構文解析を誘発する）：
◎
To parse new children for myDiv from a string (replacing its existing children), simply set the innerHTML property (this triggers parsing of the assigned string):
</p>

<pre>%myDiv.innerHTML = `&lt;span&gt;new&lt;/span&gt;&lt;em&gt;children!&lt;/em&gt;^l;
</pre>

</div>


<p>
［
~HTML ／ ~XML（ ~XHTMLは~XMLの一種である）
］における［
`構文解析$, `直列化-$
］は、それぞれの~markup言語の規則に従う。
上の例は，~HTMLの［
構文解析／直列化
］を示しているが、それらに特有の~algoは `HTML5$r 仕様に定義される。
この仕様は、~XMLを直列化するための~algoを与える。
~XMLを構文解析するための文法は、 `XML10$r 仕様に述べられる。
◎
This specification describes two flavors of parsing and serializing: HTML and XML (with XHTML being a type of XML). Each follows the rules of its respective markup language. The above example shows HTML parsing and serialization. The specific algorithms for HTML parsing and serializing are defined in the [HTML5] specification. This specification contains the algorithm for XML serializing. The grammar for XML parsing is described in the [XML10] specification.
</p>

<p>
`往来-@
するとは、~DOMを直列化した結果の文字列を，即~構文解析して~DOMに戻す
【または、そうしたときに元と同じに保たれる】
ことを意味する。
理想的には、この処理-による結果の~DOM内のどの`~node$においても，その属性の~dataは失われることなく同一性が保たれるべきである。
が，~XMLにおける`往来-$は、直列化しても`~node$の~nsの同一性が保全されるよう配慮し~MUST点で，とりわけ込み入っている（他方、~HTMLにおいては，~nsは無視される）。
◎
Round-tripping a DOM means to serialize and then immediately parse the serialized string back into a DOM. Ideally, this process does not result in any data loss with respect to the identity and attributes of the Node in the DOM. Round-tripping is especially tricky for an XML serialization, which must be concerned with preserving the Node's namespace identity in the serialization (wereas namespaces are ignored in HTML).
</p>


<div class="example">

<p>
次の~memory内~DOMに対する~XML直列化を考える：
◎
Consider the XML serialization of the following in-memory DOM:
</p>

<div>
<ol><li>`Element^I （ `nodeName^m ~EQ `root^l ）
	<ol><li>`HTMLScriptElement^I （ `nodeName^m ~EQ `script^l)
		<ol><li>`Text^I （ `data^m ~EQ `alert('hello world') ^l ）
		</li></ol>
	</li></ol>
</li></ol>

<pre lang="en">
Element (nodeName: "root")
┃
┗━ HTMLScriptElement (nodeName: "script")
   ┃
   ┗━ Text (data: "alert('hello world')")
</pre>

</div>


<p>
`script^e 要素の同一性を保全するため、~XML直列化は，
`HTMLScriptElement^I `~node$の `文脈~ns$V を含むこと，および
直列化された文字列は、~XML構文解析器を通して`往来-$することを許容し~MUST。
上の `root^l 要素が、次の変数 %root にあてがわれるとするとき：
◎
An XML serialization must include the HTMLScriptElement Node's namespace in order to preserve the identity of the script element, and to allow the serialized string to round-trip through an XML parser. Assuming that root is in a variable named root:
</p>


<pre>
var %root = /* <span class="comment">`root^l `Element^I</span> */
var %xmlSerialization = new `XMLSerializer()$m.`serializeToString(root)$m;
</pre>

<p>
その結果は、次のようになる：
`&lt;root&gt;&lt;script xmlns="http://www.w3.org/1999/xhtml"&gt;alert('hello world')&lt;/script&gt;&lt;/root&gt;^l

◎
/* xmlSerialization has the value:
"&lt;root&gt;&lt;script xmlns="http://www.w3.org/1999/xhtml"&gt;alert('hello world')&lt;/script&gt;&lt;/root&gt;" */
</p>

</div>

<p>
用語 文脈~objは…。
以下に挙げる~nsは…。
【以下、<a href="#_conventions">この節の内容の和訳は省略する。</a>】
◎
The term context object means the object on which the API being discussed was called.
◎
The following terms are understood to represent their respective namespaces in this specification (and makes it easier to read):
◎
The HTML namespace is http://www.w3.org/1999/xhtml
◎
The XML namespace is http://www.w3.org/XML/1998/namespace
◎
The XMLNS namespace is http://www.w3.org/2000/xmlns/
</p>

	</section>
	<section id="apis-for-parsing-and-serializing-dom">
<h2 title="APIs for parsing and serializing DOM">2. ~DOMを構文解析する／直列化するための~API</h2>

		<section id="the-domparser-interface">
<h3 title="The DOMParser interface">2.1. `DOMParser^I ~interface</h3>


<pre class="idl">
[`Constructor$, `Exposed$=Window]
interface `DOMParser$I {
    [`NewObject$] `Document$I `parseFromString$m(`DOMString$ %str, `SupportedType$I %type);
};

enum SupportedType {
    `text/html$l,
    `text/xml$l,
    `application/xml$l,
    `application/xhtml+xml$l,
    `image/svg+xml$l
};
</pre>

<dl class="idl-def">
	<dt>`DOMParser()@m</dt>
	<dd>
この構築子の被呼出時には、新たな `DOMParser$I ~objを返さ~MUST。
◎
domparser = new DOMParser()
◎
Constructs a new DOMParser object.
</dd>

	<dt>`parseFromString(str, type)@m</dt>
	<dd class="note">
<p>
［
%type に与えられる，~supportされる~MIME型（~XML, ~HTMLのいずれか）
］に合致する構文解析器を用いて %str を構文解析した上で、［
成功した場合は その結果を内容とする`文書$ ／
失敗した場合は その~errorを述べる`文書$
］を返す。
◎
document = domparser . parseFromString( str, type )
◎
Parse str using a parser that matches type's supported MIME types (either XML or HTML), and return a Document object contained the parsed content if successful. If not successful, returns a Document describing the error.
</p>
<p>
%type が `SupportedType$I 列挙~内のどの値にも合致しない場合、例外が投出される
`WEBIDL$r 。
◎
If type does not match a value in the SupportedType enumeration, an exception is thrown [WEBIDL].
◎
The DOMParser constructor must return a new DOMParser object.
</p>
	</dd>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The parseFromString(str, type) method must run these steps, depending on type:
</p>

		<ol>
			<li>
<p>
%文書 ~LET %type に応じて、次で与えられる，新たな`文書$：
</p>
				<dl class="switch">
					<dt>`text/html@l</dt>
					<dd>
［
`~scripting~flag$ ~SET `不能化^i
］とする下で， %str を`~HTML構文解析器$で構文解析した結果
◎
Parse str with an HTML parser, and return the newly created Document.
◎
The scripting flag must be set to "disabled".
</dd>
					<dd class="note">注記：
`meta$e 要素が利用される符号化方式に織り込まれることはない
— 構文解析器には、~Unicode~streamが渡されるので。
◎
meta elements are not taken into account for the encoding used, as a Unicode stream is passed into the parser.
</dd>
					<dd class="note">注記：
`script$e 要素は 実行不能として~markされ、
`noscript$e の内容は ~markupとして構文解析されることになる。
◎
script elements get marked unexecutable and the contents of noscript get parsed as markup.
</dd>

					<dt>`text/xml@l</dt>
					<dt>`application/xml@l</dt>
					<dt>`application/xhtml+xml@l</dt>
					<dt>`image/svg+xml@l</dt>
					<dd>
<p>
次の下位~手続きを走らせた結果：
</p>

						<ol>
							<li>
<p>
%文書 ~LET %str を［
~nsが可能化された，`~XML構文解析器$
］で構文解析した結果
◎
Parse str with a namespace-enabled XML parser.
</p>

<p class="note">注記：
どの~XHTML `script$e 要素も，［
`~XML~scriptingの~supportは不能化-$された，`~XML構文解析器$
<!-- the equivalent of the scripting flag -->
］を用いて構文解析され~MUST。
◎
For all XHTML script elements parsed using the XML parser, the equivalent of the scripting flag must be set to "disabled".
</p>
							</li>
							<li>
~IF［
%文書 は~errorでない（ `Document$I である）
］
⇒
~RET %文書
◎
If the previous step didn't return an error, return the newly created Document.
</li>
							<li>
<p>
%文書 ~LET 新たな`~XML文書$
</p>

<p class="note">注記：
%文書 が利用する~interfaceは `XMLDocument$I ではなく `Document$I になる。
</p>

◎
Let document be a newly-created XML Document. The document will use the Document interface rather than the XMLDocument interface.
</li>
							<li>
%根 ~LET `要素を作成する$( %文書, `parsererror^l, `http://www.mozilla.org/newlayout/xml/parsererror.xml^l )
◎
Let root be a new Element, with its local name set to "parsererror" and its namespace set to "http://www.mozilla.org/newlayout/xml/parsererror.xml".
</li>
							<li>
任意選択で
⇒
%根 にいくつかの`~nodeを付加する$
— 例えば，当の~errorの資質を述べるような
◎
At this point user agents may append nodes to root, for example to describe the nature of the error.
</li>
							<li>
%文書 に`~nodeを付加する$( %根 )
◎
Append root to document.
</li>
							<li>
~RET %文書
◎
Return the value of document.
</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%文書 の`内容~型$doc ~SET %type
◎
In any case, the returned Document's content type must be the type argument.＼
</li>
			<li>
%文書 の`~URL$doc ~SET `作動中の文書$の`~URL$doc
◎
Additionally, the Document must have a URL value equal to the URL of the active document,＼
</li>
			<li>
%文書 の `location$m は ~NULL を返すようにする
◎
and a location value of null.
</li>
			<li>
~RET %文書
</li>
		</ol>

<p class="note">注記：
返される`文書$の`符号化方式$docは、既定の~UTF-8になる。
◎
The returned Document's encoding is the default, UTF-8.
</p>

	</dd>
</dl>


		</section>
		<section id="the-xmlserializer-interface">
<h3 title="The XMLSerializer interface">2.2. `XMLSerializer^I ~interface</h3>

<pre class="idl">
[`Constructor$, `Exposed$=Window]
interface `XMLSerializer$I {
    `DOMString$ `serializeToString$m(`Node$I %root);
};
</pre>

<dl class="idl-def">
	<dt>`XMLSerializer()@m</dt>
	<dd>
この構築子の被呼出時には、新たな `XMLSerializer$I ~objを返さ~MUST。
◎
xmlserializer = new XMLSerializer()
◎
Constructs a new XMLSerializer object.
</dd>

	<dt>`serializeToString(root)@m</dt>
	<dd class="note">
~XML直列化を用いて、
%root を文字列に直列化する。
%root は［
`Node$I ／ `Attr$I
］~objでない場合、
`TypeError$E 例外が投出される。
◎
string = xmlserializer . serializeToString(root)
◎
Serializes root into a string using an XML serialization. Throws a TypeError exception if root is not a Node or an Attr object.
◎
The XMLSerializer() constructor must return a new XMLSerializer object.
</dd>
	<dd>
被呼出時には、`~XML直列化$( %root, ~OFF ) を返さ~MUST
◎
The serializeToString(root) method must produce an XML serialization of root passing a value of false for the require well-formed parameter, and return the result.
</dd>
</dl>

		</section>
		<section id="extensions-to-the-element-interface">
<h3 title="Extensions to the Element interface">2.3. `Element^I ~interfaceに対する拡張</h3>

<pre class="idl">
partial interface `Element$I {
    [`CEReactions$, `TreatNullAs$=EmptyString] attribute `DOMString$ `innerHTML$m;
    [`CEReactions$, `TreatNullAs$=EmptyString] attribute `DOMString$ `outerHTML$m;
    [`CEReactions$] void `insertAdjacentHTML$m(`DOMString$ %position, `DOMString$ %text);
};
</pre>

<dl class="idl-def">
	<dt>`innerHTML@m</dt>
	<dd>
`要素$の内容を成す~markupを表現する。
◎
The innerHTML IDL attribute represents the markup of the Element's contents.
</dd>
	<dd class="note">
<p>
要素の内容を表現する，
~HTML／~XML
素片を返す。
◎
element . innerHTML [ = value ]
◎
Returns a fragment of HTML or XML that represents the element's contents.
</p>
<p>
設定して、所与の文字列を構文解析した結果の~nodeたちで，要素の内容を置換できる。
◎
Can be set, to replace the contents of the element with nodes parsed from the given string.
</p>

<p>
`~XML文書$の事例では：
`要素$を~XMLに直列化できない場合は
`InvalidStateError$E 例外が投出される ／
所与の文字列は整形式でない場合は
`SyntaxError$E 例外が投出される。
◎
In the case of an XML document, throws a "InvalidStateError" DOMException if the Element cannot be serialized to XML, or a "SyntaxError" DOMException if the given string is not well-formed.
</p>
	</dd>

	<dd>
取得子は、次を走らせた結果を返さ~MUST
⇒
`素片を直列化する$( 此れ, ~ON )
（例外を投出し得る）
◎
On getting, return the result of invoking the fragment serializing algorithm on the context object providing true for the require well-formed flag (this might throw an exception instead of returning a string).
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
On setting, these steps must be run:
</p>

		<ol>
			<li>
%素片 ~LET `素片を構文解析する$( 所与の値, 此れ )
◎
Let fragment be the result of invoking the fragment parsing algorithm with the new value as markup, and the context object as the context element.
</li>
			<li>
<p>
%~node ~LET ［
此れは `template$e 要素であるならば 此れの`~template内容$（ `DocumentFragment$I ）／
~ELSE_ 此れ
］
◎
If the context object is a template element, then let context object be the template's template contents (a DocumentFragment).
</p>

<p class="note">注記：
`template$e 要素~上で `innerHTML$m を設定した場合、その`子$ではなく，
その`~template内容$の内容すべてを置換することになる。
◎
Setting innerHTML on a template element will replace all the nodes in its template contents (template.content) rather than its children.
</p>

			</li>
			<li>
%~node の`全~内容を~nodeで置換する$( %素片 )
◎
Replace all with fragment within the context object.
</li>
		</ol>
	</dd>

	<dt>`outerHTML@m</dt>
	<dd>
`要素$とその内容の~markupを表現する。
◎
The outerHTML IDL attribute represents the markup of the Element and its contents.
</dd>
	<dd class="note">
<p>
要素とその内容を表現する
~HTML／~XML
素片を返す。
◎
element . outerHTML [ = value ]
◎
Returns a fragment of HTML or XML that represents the element and its contents.
</p>
<p>
設定して、所与の文字列を構文解析した結果の~nodeたちで，要素を置換できる。
◎
Can be set, to replace the element with nodes parsed from the given string.
</p>
<p>
`~XML文書$の事例では、要素を~XMLに直列化できない場合，
`InvalidStateError$E 例外が投出され、所与の文字列は整形式でない場合，
`SyntaxError$E 例外が投出される。
◎
In the case of an XML document, throws a "InvalidStateError" DOMException if the element cannot be serialized to XML, or a "SyntaxError" DOMException if the given string is not well-formed.
</p>

<p>
要素の親は`文書$である場合、
`NoModificationAllowedError$E 例外が投出される。
◎
Throws a "NoModificationAllowedError" DOMException if the parent of the element is a Document.
</p>
	</dd>
	<dd>
取得子は、次を走らせた結果を返さ~MUST（これは、例外を投出し得る）
⇒
`素片を直列化する$( 此れのみを子とする `DocumentFragment$I ~node†, ~ON )
◎
On getting, return the result of invoking the fragment serializing algorithm on a fictional node whose only child is the context object providing true for the require well-formed flag (this might throw an exception instead of returning a string).
</dd>
	<dd class="trans-note">【†
原文には “fictional node” としか記されていないが、
`DocumentFragment$I で用を成すであろう。
】</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
On setting, the following steps must be run:
</p>
		<ol>
			<li>
%親 ~LET 此れの`親$
◎
Let parent be the context object's parent.
</li>
			<li>
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
— 以降の手続きを走らせても，作成される~nodeへの参照-を得る仕方はないので。
◎
If parent is null, terminate these steps. There would be no way to obtain a reference to the nodes created even if the remaining steps were run.
</li>
			<li>
~IF［
%親 は`文書$である
］
⇒
~THROW `NoModificationAllowedError$E
◎
If parent is a Document, throw a "NoModificationAllowedError" DOMException.
</li>
			<li>
<p>
~IF［
%親 は `DocumentFragment$I である
］
⇒
%親 ~LET `要素を作成する$( 此れの`~node文書$, `body^l, `~HTML~ns$ )
◎
If parent is a DocumentFragment, let parent be a new Element with:
• body as its local name,
• The HTML namespace as its namespace, and
• The context object's node document as its node document.
</li>
			<li>
%素片 ~LET `素片を構文解析する$( 新たな値, %親 )
◎
Let fragment be the result of invoking the fragment parsing algorithm with the new value as markup, and parent as the context element.
</li>
			<li>
此れの`親$の中で`子を~nodeに置換する$( 此れ, %素片 )
◎
Replace the context object with fragment within the context object's parent.
</li>
</ol>
	</dd>


	<dt>`insertAdjacentHTML(position, text)@m</dt>
	<dd class="note">
<p>
文字列 %text を［
~HTML／~XML
］として構文解析した上で、その結果の~nodeを［
%position に応じて次に与える位置
］に挿入する
◎
element . insertAdjacentHTML(position, text)
◎
Parses the given string text as HTML or XML and inserts the resulting nodes into the tree in the position given by the position argument, as follows:
</p>
		<dl>

			<dt>`beforebegin^l</dt>
			<dd>
この要素の前（直前の同胞との合間）
◎
Before the element itself (i.e., after element's previous sibling)
</dd>

			<dt>`afterbegin^l</dt>
			<dd>
この要素の内側の先頭（最初の子の前）
◎
Just inside the element, before its first child.
</dd>

			<dt>`beforeend^l</dt>
			<dd>
この要素の内側の末尾（最後の子の後）
◎
Just inside the element, after its last child.
</dd>

			<dt>`afterend^l</dt>
			<dd>
この要素の後（直後の同胞との合間）
◎
After the element itself (i.e., before element's next sibling)
</dd>
		</dl>
<p>
引数の値が妥当でない場合、
`SyntaxError$E 例外が投出される。
（例： `~XML文書$の事例では、所与の文字列が整形式でない場合。）
◎
Throws a "SyntaxError" DOMException if the arguments have invalid values (e.g., in the case of an XML document, if the given string is not well-formed).
</p>

<p>
所与の位置に挿入できない場合、
`NoModificationAllowedError$E 例外が投出される。
（例： `文書$の根~要素の後に要素を挿入しようとしたとき。）
◎
Throws a "NoModificationAllowedError" DOMException if the given position isn't possible (e.g. inserting elements after the root element of a Document).
</p>

	</dd>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertAdjacentHTML(position, text) method must run these steps:
</p>
		<ol>
			<li>
<p>
`~ASCII小文字~化する$( %position ) の結果に応じて：
◎
Use the first matching item from this list:
</p>

				<dl class="switch">
					<dt>`beforebegin^l
◎
If position is an ASCII case-insensitive match for the string "beforebegin"
</dt>
					<dt>`afterend^l
◎
If position is an ASCII case-insensitive match for the string "afterend"
</dt>
					<dd>
<p>
%文脈~node ~LET 此れの`親$
◎
Let context be the context object's parent.
</p>

<p>
~IF［
%文脈~node ~EQ ~NULL
］~OR［
%文脈~node は`文書$である
］
⇒
~THROW `NoModificationAllowedError$E
◎
If context is null or a Document, throw a "NoModificationAllowedError" DOMException.
</p>
					</dd>
					<dt>`afterbegin^l
◎
If position is an ASCII case-insensitive match for the string "afterbegin"
</dt>
					<dt>`beforeend^l
◎
If position is an ASCII case-insensitive match for the string "beforeend"
</dt>
					<dd>
%文脈~node ~LET 此れ
◎
Let context be the context object.
</dd>
					<dt>
他の場合
◎
Otherwise
</dt>
					<dd>
~THROW `SyntaxError$E
◎
Throw a "SyntaxError" DOMException.
</dd>
				</dl>
			</li>
			<li>
<p>
~IF［
%文脈~node は`要素$でない
］~OR［
%文脈~node は次をすべて満たす`要素$である
］…：
◎
If context is not an Element or the following are all true:
</p>
				<ul>
					<li>
`~node文書$は`~HTML文書$である
◎
context's node document is an HTML document,
</li>
					<li>
`局所~名$eL ~EQ `html^l
◎
context's local name is "html", and
</li>
					<li>
`~ns$eL ~EQ `~HTML~ns$
◎
context's namespace is the HTML namespace;
</li>
				</ul>

<p>
…ならば
⇒
%文脈~node ~LET `要素を作成する$( 此れの`~node文書$, `body^l, `~HTML~ns$ )
◎
let context be a new Element with
• body as its local name,
• The HTML namespace as its namespace, and
• The context object's node document as its node document.
</p>
			</li>
			<li>
%素片 ~LET `素片を構文解析する$( %~text, %文脈~node )
◎
Let fragment be the result of invoking the fragment parsing algorithm with text as markup, and context as the context element.
</li>
			<li>
<p>
`~ASCII小文字~化する$( %position ) の結果に応じて：
◎
Use the first matching item from this list:
</p>
				<dl class="switch">
				<dt>
`beforebegin^l
◎
If position is an ASCII case-insensitive match for the string "beforebegin"
</dt>
	<dd>
此れの`親$の中で`~nodeを子の前に挿入する$( %素片, 此れ )
◎
Insert fragment into the context object's parent before the context object.
</dd>

				<dt>
`afterbegin^l
◎
If position is an ASCII case-insensitive match for the string "afterbegin"
</dt>
	<dd>
此れの中で`~nodeを子の前に挿入する$( %素片, 此れの`最初の子$ )
◎
Insert fragment into the context object before its first child.
</dd>

				<dt>
`beforeend^l
◎
If position is an ASCII case-insensitive match for the string "beforeend"
</dt>
	<dd>
此れに`~nodeを付加する$( %素片 )
◎
Append fragment to the context object.
</dd>

				<dt>
`afterend^l
◎
If position is an ASCII case-insensitive match for the string "afterend"
</dt>
	<dd>
此れの`親$の中で`~nodeを子の前に挿入する$( %素片, 此れの`次の同胞$ )
◎
Insert fragment into the context object's parent before the context object's next sibling.
</dd>
				</dl>
			</li>
		</ol>
	</dd>
</dl>


<p class="note">注記：
上の［
`afterbegin^l ／ `beforeend^l
］の事例には、 `template$e 要素~用の特別な取扱いは含まれていない。
直接的に`~node$を操作する他の~APIと同じく（および `innerHTML$m とは違って ）、
`insertAdjacentHTML()$m は， `template$e 要素に対する特別な取扱いを含まない。
ほとんどの事例では、作者は `template$e 要素の`子$を直接的に操作せずに，
`~template内容$の `insertAdjacentHTML()$m を利用したいと望むことになるであろう。
◎
No special handling for template elements is included in the above "afterbegin" and "beforeend" cases. As with other direct Node-manipulation APIs (and unlike innerHTML), insertAdjacentHTML does not include any special handling for template elements. In most cases you will wish to use template.content.insertAdjacentHTML instead of directly manipulating the child nodes of a template element.
</p>



		</section>
		<section id="extensions-to-the-range-interface">
<h3 title="Extensions to the Range interface">2.4. `Range^I ~interfaceに対する拡張</h3>

<pre class="idl">
partial interface `Range$I {
    [`CEReactions$, `NewObject$] `DocumentFragment$I `createContextualFragment$m(`DOMString$ %fragment);
};
</pre>


<dl class="idl-def">
	<dt>`createContextualFragment(fragment)@m</dt>
	<dd class="note">
~markup文字列 %fragment から作成される `DocumentFragment$I を返す
— %fragment を構文解析する際の %文脈~要素 には %range の`始端~node$を用いて。
◎
docFragment = range . createContextualFragment( fragment )
◎
Returns a DocumentFragment, created from the markup string fragment using range's start node as the context in which fragment is parsed.
</dd>

	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createContextualFragment(fragment) method must run these steps:
</p>
		<ol>
			<li>
%~node ~LET 此れの`始端~node$
◎
Let node be the context object's start node.
</li>
			<li>
<p>
%要素 ~LET %~node の~interfaceに応じて，次で与えられる~node：
◎
Let element be as follows, depending on node's interface:
</p>
				<dl class="switch">
					<dt>`Document$I</dt>
					<dt>`DocumentFragment$I</dt>
					<dd>
~NULL
</dd>

					<dt>`Element$I</dt>
					<dd>
%~node
</dd>

					<dt>`Text$I</dt>
					<dt>`Comment$I</dt>
					<dd>
%~node の`親$
◎
node's parent element
</dd>

					<dt>`DocumentType$I</dt>
					<dt>`ProcessingInstruction$I</dt>
					<dd>
この事例は `DOM4$r により防止される。†
◎
[DOM4] prevents this case.
</dd>
					<dd class="trans-note">【†
`ProcessingInstruction^I を特に防止する要件は `DOM4$r には見当たらない（ `Text^I と同様になる筈）。
】</dd>
				</dl>
			</li>
			<li>
<p>
~IF［
%要素 ~EQ ~NULL
］~OR［
%要素 は次をすべて満たす`要素$である
］…：
◎
If either element is null or the following are all true:
</p>
				<ul>
					<li>
`~node文書$は`~HTML文書$である
◎
element's node document is an HTML document,
</li>
					<li>
`局所~名$eL ~EQ `html^l
◎
element's local name is "html", and
</li>
					<li>
`~ns$eL ~EQ `~HTML~ns$
◎
element's namespace is the HTML namespace;
</li>
				</ul>

<p>
…ならば
⇒
%要素 ~LET `要素を作成する$( 此れの`~node文書$, `body^l, `~HTML~ns$ )
◎
let element be a new Element with
◎
"body" as its local name,
◎
The HTML namespace as its namespace, and
◎
The context object's node document as its node document.
</p>
			</li>
			<li>
%素片~node ~LET `素片を構文解析する$( %fragment, %要素 )
◎
Let fragment node be the result of invoking the fragment parsing algorithm with fragment as markup, and element as the context element.
</li>
			<li>
<p>
%素片~node 内の~EACH ( `script$e 要素 %~script ) に対し
⇒
%~script の
( `開始済み~flag$, `解析器挿入~flag$ ) ~SET ( ~ON, ~ON )
</p>

【この段は訳者による補完も入っている（原文には参照先が与えられていない）】
◎
Unmark all scripts in fragment node as "already started" and as "parser-inserted".
</li>
			<li>
~RET %素片~node
◎
Return the value of fragment node.
</li>
		</ol>
	</dd>
</dl>


		</section>
	</section>
	<section id="algorithms-for-parsing-and-serializing">
<h2 title="Algorithms for parsing and serializing">3. 素片を構文解析する／直列化する~algo</h2>

		<section id="parsing">
<h3 title="Parsing">3.1. 構文解析-法</h3>

<p class="algo-head">
`素片を構文解析する@
~algoは、所与の
( 文字列 %~markup, `要素$ %文脈~要素 )
に対し，次の手続きを走らす：
◎
The following steps form the fragment parsing algorithm, whose arguments are a markup string and a context element:
</p>

<ol>
	<li>
<p>
%子~list ~LET %文脈~要素 の`~node文書$に応じて，次で与えられる結果：
</p>
		<dl class="switch">
			<dt>`~HTML文書$である</dt>
			<dd>
`~HTML素片を構文解析する$( %文脈~要素, %~markup )
</dd>
			<dt>`~XML文書$である</dt>
			<dd>
`~XML素片を構文解析する$( %文脈~要素, %~markup )
</dd>
		</dl>
◎
If the context element's node document is an HTML document: let algorithm be the HTML fragment parsing algorithm.
◎
If the context element's node document is an XML document: let algorithm be the XML fragment parsing algorithm.
◎
Let new children be the result of invoking algorithm with markup as the input, and context element as the context element.
</li>
	<li>
%素片 ~LET 新たな `DocumentFragment$I
◎
↓</li>
	<li>
%素片 の`~node文書$ ~SET %文脈~要素 の`~node文書$
◎
Let fragment be a new DocumentFragment whose node document is context element's node document.
</li>
	<li>
<p>
%子~list 内の~EACH( %~node ) に対し
⇒
%素片 に`~nodeを付加する$( %~node )
◎
Append each Node in new children to fragment (in tree order).
</p>

<p class="note">注記：
これは、 %~node の`~node文書$が正しくなることを確保する。
◎
This ensures the node document for the new nodes is correct.
</p>

	</li>
	<li>
~RET %素片
◎
Return the value of fragment.
</li>
</ol>

		</section>
		<section id="serializing">
<h3 title="Serializing">3.2. 直列化-法</h3>

<p class="algo-head">
`素片を直列化する@
~algoは、所与の
( `~node$ %~node, `要~整形式~flag$V )
に対し，次の手続きを走らす：
◎
The following steps form the fragment serializing algorithm, whose arguments are a Node node and a flag require well-formed:
</p>

<ol>
	<li>
<p>
%~node の`~node文書$に応じて：
<!-- の種別$doc -->
◎
Let context document be the value of node's node document.
</p>
		<dl class="switch">
			<dt>
`~HTML文書$
◎
If context document is an HTML document,＼
</dt>
			<dd>
~RET %~node の`~HTML直列化$
◎
return an HTML serialization of node.
</dd>

			<dt>
`~XML文書$
◎
Otherwise, context document is an XML document;＼
</dt>
			<dd>
~RET `~XML直列化$( %~node, `要~整形式~flag$V )
◎
return an XML serialization of node passing the flag require well-formed.
</dd>

				<dd class="note">注記：
この文書にて定義される`~XML直列化$は、
`HTML5$r に定義される`~XML素片を直列化-$する~algoの要件に適合する。
◎
The XML serialization defined in this document conforms to the requirements of the XML fragment serialization algorithm defined in [HTML5].
</dd>
		</dl>
	</li>
</ol>


<p class="algo-head">
`~node$ %~node の
`~HTML直列化@
を生産するときは、所与の %~node に対し，`~HTML素片を直列化-$して生産される文字列を返さ~MUST。
◎
To produce an HTML serialization of a Node node, the user agent must run the HTML fragment serialization algorithm on node and return the string produced.
</p>

		</section>
	</section>
	<section id="xml-serialization">
<h2 title="XML Serialization">4. ~XML直列化</h2>

<p class="trans-note">【
この節は，原文では前節（ 3.2 ）の下位節として与えられているが、この訳では独立の節に分離する。
この節が、この仕様が定義する~modelの主要な部分を成すので。
】</p>

<p>
`~XML直列化$は、次の仕方で，`~HTML直列化$から相違する：
◎
An XML serialization differs from an HTML serialization in the following ways:
</p>

<ul>
	<li>
［
`要素$ ／ `属性~list$
］を直列化するときは、その［
`~ns$eL ／ `~ns$A
］は，常に保全される。
このことは、一部の事例では，それらの既存の［
~ns接頭辞 ／ 接頭辞~宣言を与える属性 ／ 既定の~ns宣言を与える属性
］は、［
落とされたり, 代用されたり, 変更される
］こともあることを意味する。
`~HTML直列化$は、~nsを保全しようとは試みない。
◎
Elements and attributes will always be serialized such that their namespaceURI is preserved. In some cases this means that an existing prefix, prefix declaration attribute or default namespace declaration attribute might be dropped, substituted or changed. An HTML serialization does not attempt to preserve the namespaceURI.
</li>
	<li>
`~HTML~ns$に属さない`要素$のうち，`子$を包含していないものは、`空~要素~tag$構文を用いて（すなわち，~XML `EmptyElemTag$P 生成規則に則って）直列化される。
◎
Elements not in the HTML namespace containing no children, are serialized using the empty-element tag syntax (i.e., according to the XML EmptyElemTag production).
</li>
</ul>

<p>
他の点では、`~XML直列化$を生産する~algoは，`~HTML構文解析器$と互換な直列化を生産するよう設計されている。
例えば，`~HTML~ns$に属する要素のうち`子$を包含しないものは、`空~要素~tag$構文を用いることなく，明示的な［
開始tag, 終了tag
］を伴って直列化される。
◎
Otherwise, the algorithm for producing an XML serialization is designed to produce a serialization that is compatible with the HTML parser. For example, elements in the HTML namespace that contain no child nodes are serialized with an explicit begin and end tag rather than using the empty-element tag syntax.
</p>


<p class="note">注記：
`DOM4$r により， `Attr$I ~objは `Node$I を継承しない
【この記述は、今や正しくない】
ので、~nodeを`~XMLに直列化する$ことでは直列化できず，そうしようと試みた場合の結果は空~文字列になる。
◎
Per [DOM4], Attr objects do not inherit from Node, and thus cannot be serialized by the XML serialization algorithm. An attempt to serialize an Attr object will result in an empty string.
</p>


<p class="algo-head">
`~XML直列化@
を生産する手続きは、以下に与えられる：
◎
To produce an XML serialization of＼
</p>

<ul>
	<li>
<p>
この手続きは、次を入力にとる：
</p>

		<ul>
			<li>
%~node
— 直列化する`~node$。
</li>
			<li>
`要~整形式~flag@V
— ~ON または ~OFF 。
~ON の場合、結果が［
整形式にならない／合法に往来できない
］ときには、例外が投出される。
この~flagは、［
この~algoの文脈~下で呼出される，この節に定義される各種~algo
］すべてから参照され, 変化しない。
</li>
		</ul>
◎
a Node node given a flag require well-formed, run the following steps:
</li>
	<li>
<p>
この手続きが呼出す［
各種 `型の~nodeを~XMLに直列化する$
］手続きには、現在の既定の~nsを追跡する，
`文脈~ns@V
が（値~渡しで）渡される。
これは、初期~時には ~NULL （~nsなしを表す）であり，次が生じたときに変更される：
◎
Let namespace be a context namespace with value null. The context namespace tracks the XML serialization algorithm's current default namespace. The context namespace is changed when either＼
</p>

		<ul>
			<li>
`要素$が既定の~ns宣言を有するとき
◎
an Element Node has a default namespace declaration, or＼
</li>
			<li>
~algoが、`要素$の自前の~nsに合致する既定の~ns宣言を生成するとき
◎
the algorithm generates a default namespace declaration for the Element Node to match its own namespace. The algorithm assumes no namespace (null) to start.
</li>
		</ul>
	</li>
</ul>

<ol>
	<li>
`接頭辞~map$V ~LET 新たな`~ns接頭辞~map$
◎
Let prefix map be a new namespace prefix map.
</li>
	<li>
`接頭辞~mapに追加する$( `接頭辞~map$V, `xml^l, `~XML~ns$ )
◎
Add the XML namespace with prefix value "xml" to prefix map.
</li>
	<li id="dfn-generated-namespace-prefix-index">
<p>
`接頭辞~index@V ~LET 1
</p>

<p>
これは、［
%~node の`~ns$eL（または %~node の属性の`~ns$A ）を直列化するときに，相応しい既存の~ns接頭辞が可用でない
］ときに，新たな, かつ一意な`接頭辞を生成する$ために利用され、この~algoによる直列化~文脈~全体にわたり共有される。
</p>

◎
Let prefix index be a generated namespace prefix index with value 1. The generated namespace prefix index is used to generate a new unique prefix value when no suitable existing namespace prefix is available to serialize a node's namespaceURI (or the namespaceURI of one of node's attributes). See the generate a prefix algorithm.
</li>
	<li>
<p>
~RET %~node を`~XMLに直列化する$( ~NULL, `接頭辞~map$V )
</p>

<p>
この段で `TypeError$E でない<!-- ＊ -->例外が投出されたときは、~catchして
⇒
~THROW `InvalidStateError$E
</p>
◎
Return the result of running the XML serialization algorithm on node passing the context namespace namespace, namespace prefix map prefix map, generated namespace prefix index reference to prefix index, and the flag require well-formed. If an exception occurs during the execution of the algorithm, then catch that exception and throw an "InvalidStateError" DOMException.
</li>
</ol>

<p>
所与の
`型の~nodeを~XMLに直列化する@
ための各種~algoは、直列化する入力 %~node に加え，次の引数をとるように定義される：
◎
Each of the following algorithms for producing an XML serialization of a DOM node take as input a node to serialize and the following arguments:
</p>

<ul>
	<li>
`文脈~ns$V
◎
A context namespace namespace
</li>
	<li>
`接頭辞~map@V
— `~ns接頭辞~map$
◎
A namespace prefix map prefix map
◎
↑↑A generated namespace prefix index prefix index
◎
↑↑The require well-formed flag
</li>
</ul>

<p class="algo-head">
%~node を
`~XMLに直列化する@
ときは、［
%~node の~interface型に応じて，次に与える ある`型の~nodeを~XMLに直列化する$~algo
］に，渡された引数たちをそのまま渡して走らせた結果を返す：
◎
The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based on the node's interface type. Each referenced algorithm is to be passed the arguments as they were recieved by the caller and return their result to the caller. Re-throw any exceptions. If node's interface is:
</p>


<dl class="switch">
	<dt>`Element$I</dt>
	<dd>
<a href="#xml-serializing-an-element-node">`Element^I ~nodeを~XMLに直列化する</a>
◎
Run the algorithm for XML serializing an Element node node.
</dd>

	<dt>`Document$I</dt>
	<dd>
<a href="#xml-serializing-a-document-node">`Document^I ~nodeを~XMLに直列化する</a>
◎
Run the algorithm for XML serializing a Document node node.
</dd>

	<dt>`Comment$I</dt>
	<dd>
<a href="#xml-serializing-a-comment-node">`Comment^I ~nodeを~XMLに直列化する</a>
<!--

	<dt><code><a>CDATASection</a></code>
	<dd>Run the algorithm for <a>XML serializing a CDATASection node</a> <var>node</var>.-->

◎
Run the algorithm for XML serializing a Comment node node.
</dd>

	<dt>`Text$I</dt>
	<dd>
<a href="#xml-serializing-a-text-node">`Text^I ~nodeを~XMLに直列化する</a>
◎
Run the algorithm for XML serializing a Text node node.
</dd>

	<dt>`DocumentFragment$I</dt>
	<dd>
<a href="#xml-serializing-a-documentfragment-node">`DocumentFragment^I ~nodeを~XMLに直列化する</a>
◎
Run the algorithm for XML serializing a DocumentFragment node node.
</dd>

	<dt>`DocumentType$I</dt>
	<dd>
<a href="#xml-serializing-a-documenttype-node">`DocumentType^I ~nodeを~XMLに直列化する</a>
◎
Run the algorithm for XML serializing a DocumentType node node.
</dd>

	<dt>`ProcessingInstruction$I</dt>
	<dd>
<a href="#xml-serializing-a-processinginstruction-node">`ProcessingInstruction^I ~nodeを~XMLに直列化する</a>
◎
Run the algorithm for XML serializing a ProcessingInstruction node node.
</dd>

	<dt>
`Attr$I
◎
An Attr object
</dt>
	<dd>
次を走らす~algo
⇒
~RET 空~文字列
◎
Return an empty string.
</dd>

	<dt>
その他
◎
Anything else
</dt>
	<dd>
次を走らす~algo
⇒
~THROW `TypeError$E
◎
Throw a TypeError.＼
</dd>
	<dd>
（この~algoにより直列化できるのは `Node$I ／ `Attr$I ~objに限られる。）
◎
Only Nodes and Attr objects can be serialized by this algorithm.
</dd>
</dl>


<p>
上で参照された各~algoの詳細は、以下の各 節に与える。
◎
Each of the above referenced algorithms are detailed in the sections that follow.
</p>

		<section id="xml-serializing-an-element-node">
<h3 title="XML serializing an Element node">4.1. 要素を~XMLに直列化する</h3>


<p>
`Element$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type Element is as follows:
</p>

<p class="trans-note">【
簡潔にするため、この~algoの一部には（等価なふるまいになるよう）手を加えている。
】</p>

<ol>
	<li>
%要素 ~LET %~node
【この段は、以下を読み易くするための，この訳による追加（実質的には，単なる名称変更）。】
</li>
	<li>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%要素 の`局所~名$eLは［
`003A^U を包含する
~OR
~XML `Name$P 生成規則に合致しない
］］
⇒
~THROW 例外
— %要素 の直列化は整形式~要素にならない。
◎
If the require well-formed flag is set (its value is true), and this node's localName attribute contains the character ":" (U+003A COLON) or does not match the XML Name production, then throw an exception; the serialization of this node would not be a well-formed element.
◎
↓↓Let markup be the string "&lt;" (U+003C LESS-THAN SIGN).
◎
↓↓Let qualified name be an empty string.
◎
↓↓Let skip end tag be a boolean flag with value false.
◎
↓↓Let ignore namespace definition attribute be a boolean flag with value false.
<!-- dfn-skip-end-tag -->
</li>
	<li>
%~map ~LET `~ns接頭辞~mapを複製する$( `接頭辞~map$V )
◎
Given prefix map, copy a namespace prefix map and let map be the result.
</li>
	<li>
<div class="p">
<p>
`局所~接頭辞~map@V
~LET 新たな空`~map$
— この~mapを成す各~entryは：
</p>

<ul ><li>~ns接頭辞を与える文字列を~keyとする。
</li><li>~nsを与える文字列を値とする。
この値においては、 ~NULL ~nsは空~文字列で表現される。
</li></ul>
◎
Let local prefixes map be an empty map. The map has unique Node prefix strings as its keys, with corresponding namespaceURI Node values as the map's key values (in this map, the null namespace is represented by the empty string).
</div>

<div class="note">
<p>注記：
この~mapは、要素ごとに局所的であり，次のために利用される：
</p>

<ul><li>~ns接頭辞~定義を与える属性が必要で，そのために新たな`接頭辞を生成する$べきときに、他の接頭辞と競合しないことを確保する。
</li><li>%要素 の`属性たちを~XMLに直列化する$ときに，重複する接頭辞~定義を飛ばせるようにする。
</li><li>`~ns接頭辞~map$内の接頭辞のうち［
%要素 に局所的に定義されるもの, そうでないもの
］を，この~algoが判別できるようにする。
</li></ul>

◎
This map is local to each element. It is used to ensure there are no conflicting prefixes should a new namespace prefix attribute need to be generated. It is also used to enable skipping of duplicate prefix definitions when writing an element's attributes: the map allows the algorithm to distinguish between a prefix in the namespace prefix map that might be locally-defined (to the current Element) and one that is not.
</div>
	</li>
	<li>
<p>
`局所的な既定の~ns@V
~LET %要素 の`~ns情報を記録する$( %~map, `局所~接頭辞~map$V )
◎
Let local default namespace be the result of recording the namespace information for node given map and local prefixes map.
</p>

<p class="note">注記：
この段は %~map も更新することに加え、
%要素 上に見出された~ns接頭辞~定義を， `局所~接頭辞~map$V に追加する。
`局所的な既定の~ns$V は、 %要素 上に既定の~nsを与える属性が［
在れば それが定義する~ns ／
無ければ ε
］になる。
◎
The above step will update map with any found namespace prefix definitions, add the found prefix definitions to the local prefixes map and return a local default namespace value defined by a default namespace attribute if one exists. Otherwise it returns null.
</p>
	</li>
	<li>
`~ns定義~属性は無視する~flag@V ~LET ~OFF
◎
↑↑</li>
	<li>
%~ns ~LET %要素 の`~ns$eL
◎
Let inherited ns be a copy of namespace.
◎
Let ns be the value of node's namespaceURI attribute.
</li>
	<li>
%接頭辞 ~LET %要素 の`~ns接頭辞$eL
【~NULL に設定された場合、接頭辞は直列化されない。】
◎
↓</li>
	<li>
%~ns宣言~markup ~LET 空~文字列
【これは、接頭辞~宣言／既定の~ns宣言が必要になったとき，他の値に設定される。】
◎
↓</li>
	<li>
<p>
~IF［
%~ns ~EQ `文脈~ns$V
］：
◎
If inherited ns is equal to ns, then:
</p>
		<ol>
			<li>
~IF［
`局所的な既定の~ns$V ~NEQ ε
］
⇒
`~ns定義~属性は無視する~flag$V ~SET ~ON
◎
If local default namespace is not null, then set ignore namespace definition attribute to true.
</li>
			<li>
<p>
%接頭辞 ~SET［［
%~ns ~EQ `~XML~ns$
］ならば `xml^l ／
~ELSE_ ~NULL
］
◎
If ns is the XML namespace, then append to qualified name the concatenation of the string "xml:" and the value of node's localName.
◎
Otherwise, append to qualified name the value of node's localName. The node's prefix if it exists, is dropped.
</p>

<p class="note">注記：
`~XML~ns$に属さない場合、 %要素 に`~ns接頭辞$eLが存在しても，落とされる。
◎
Append the value of qualified name to markup.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
<!-- The serialization algorithm must differentiate this node's namespace from it's parent's default namespace. There are two ways to do this: (1) [preferred due to assumed minimum length] use a namespace prefix if one is available or (2) use a default namespace declaration. Both cases can run into conflicts with existing attributes on the element and are handled accordingly. -->

◎
Otherwise, inherited ns is not equal to ns (the node's own namespace is different from the context namespace of its parent). Run these sub-steps:
</p>
		<ol>
			<li>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%接頭辞 ~EQ `xmlns^l
］
⇒
~THROW 例外
— %要素 は合法に往来しない。
◎
Let prefix be the value of node's prefix attribute.
</li>
			<li>
<p>
%候補~接頭辞 ~LET ［［
%接頭辞 ~NEQ `xmlns^l
］ならば `選好される接頭辞~文字列を検索取得する$( %~map, %~ns, %接頭辞 ) ／
~ELSE_ `xmlns^l
］
</p>

<p class="note">注記：
%~map の~keyたちに %~ns が無い場合、 ~NULL が返される。
</p>

<!-- Found a suitable prefix to use, either locally, or inherited through a parent node that matches the node's namespaceURI. This prefix will be used in serialization even if the node doesn't have a real prefix. -->

◎
Let candidate prefix be the result of retrieving a preferred prefix string prefix from map given namespace ns.
◎
The above may return null if no namespace key ns exists in map.
◎
If the value of prefix matches "xmlns", then run the following steps:
• If the require well-formed flag is set, then throw an error. An Element with prefix "xmlns" will not legally round-trip in a conforming XML parser.
• Let candidate prefix be the value of prefix.
</li>
			<li>
<p id="dfn-found-a-suitable-namespace-prefix">
~IF［
%候補~接頭辞 ~NEQ ~NULL （この接頭辞は %~ns に~mapするよう定義されている）
］：
◎
Found a suitable namespace prefix: if candidate prefix is not null (a namespace prefix is defined which maps to ns), then:
</p>

<p class="note">注記：
%候補~接頭辞 が直列化されることになる
— それは、 %要素 の自前の`~ns接頭辞$eLと異なり得る。
<!-- ＊？
しかしながら，可能なら
すでに
選好される接頭辞~文字列を検索取得する$ ~algoにて 既存の接頭辞に合致しようと試行された。
 -->
◎
The following may serialize a different prefix than the Element's existing prefix if it already had one. However, the retrieving a preferred prefix string algorithm already tried to match the existing prefix if possible.
</p>

		<ol>
			<li>
<p>
%接頭辞 ~SET %候補~接頭辞
</p>

<p class="note">注記：
%要素 または そのいずれかの先祖に、
%要素 の~nsを定義する~ns接頭辞~定義が存在する。
</p>
◎
Append to qualified name the concatenation of candidate prefix, ":" (U+003A COLON), and node's localName. There exists on this node or the node's ancestry a namespace prefix definition that defines the node's namespace.
</li>
			<li>
<p>
~IF［
`局所的な既定の~ns$V ~NIN { ε, `~XML~ns$ }
］
⇒
`文脈~ns$V ~SET ［
`局所的な既定の~ns$V ~NEQ 空~文字列 ならば `局所的な既定の~ns$V ／
~ELSE_ ~NULL
］
（`文脈~ns$V は、 %要素 の自前の~nsではなく，宣言された既定の~nsに変更される。）
◎
If the local default namespace is not null (there exists a locally-defined default namespace declaration attribute) and its value is not the XML namespace, then let inherited ns get the value of local default namespace unless the local default namespace is the empty string in which case let it get null (the context namespace is changed to the declared default, rather than this node's own namespace).
</p>

<p class="note">注記：
`~XML~ns$を定義するような［
既定の~ns定義／~ns接頭辞
］は、あっても， %要素 の属性たちを直列化するときには省略される。
◎
Any default namespace definitions or namespace prefixes that define the XML namespace are omitted when serializing this node's attributes.
◎
Append the value of qualified name to markup.
</p>
			</li>
		</ol>

	</li>
	<li>
<p>
~ELIF［
%接頭辞 ~NEQ ~NULL
］：
◎
Otherwise, if prefix is not null, then:
</p>

<div class="note">
<p>
注記：
この時点で、 %要素 にも, そのどの先祖にも［
%接頭辞 を定義する~ns ／ %接頭辞 を~nsに~mapする宣言
］はない。
以降の手続きは、次を確保する：
</p>

<ul ><li>%接頭辞 用に新たな~ns接頭辞~宣言を作成する
</li><li>%接頭辞 は［
%要素 の`属性~list$内に既存の~ns接頭辞~宣言
<!-- ＊？同じ localName の -->
］とは競合しない。
</li></ul>
◎
By this step, there is no namespace or prefix mapping declaration in this node (or any parent node visited by this algorithm) that defines prefix otherwise the step labelled Found a suitable namespace prefix would have been followed. The sub-steps that follow will create a new namespace prefix declaration for prefix and ensure that prefix does not conflict with an existing namespace prefix declaration of the same localName in node's attribute list.
</div>

		<ol>
			<li>
~IF［
`局所~接頭辞~map$V[ %接頭辞 ] ~NEQ ε
］
⇒
%接頭辞 ~SET `接頭辞を生成する$( %~map, %~ns )
◎
If the local prefixes map contains a key matching prefix, then let prefix be the result of generating a prefix providing as input map, ns, and prefix index.
</li>
			<li>
`接頭辞~mapに追加する$( %~map, %接頭辞, %~ns )
◎
Add prefix to map given namespace ns.
◎
Append to qualified name the concatenation of prefix, ":" (U+003A COLON), and node's localName.
◎
Append the value of qualified name to markup.
</li>
			<li>
<p>
%~ns宣言~markup ~SET 次の連結：
</p>

<p class="note">注記：
これは、 %接頭辞 に対応する~ns接頭辞~宣言を直列化する。
</p>

<ol><li>~SPACE
</li><li>`xmlns:^l
</li><li>%接頭辞
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %~ns )
</li><li>`0022^U
</li></ol>

◎
Append the following to markup, in the order listed:
◎
The following serializes a namespace prefix declaration for prefix which was just added to the map.
◎
• " " (U+0020 SPACE);
• The string "xmlns:";
• The value of prefix;
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given ns and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK).
</li>
			<li>
~IF［
`局所的な既定の~ns$V ~NEQ ε
<!--＊ (there exists a locally-defined default namespace declaration attribute) -->
］
⇒
`文脈~ns$V ~SET ［
`局所的な既定の~ns$V ~NEQ 空~文字列 ならば `局所的な既定の~ns$V ／
~ELSE_ ~NULL
］
◎
If local default namespace is not null (there exists a locally-defined default namespace declaration attribute), then let inherited ns get the value of local default namespace unless the local default namespace is the empty string in which case let it get null.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
`局所的な既定の~ns$V ~NEQ %~ns
］：
◎
Otherwise, if local default namespace is null, or local default namespace is not null and its value is not equal to ns, then:
</p>

<p class="note">注記：
%要素 用の~nsは 依然として直列化される必要があるが、この時点では %接頭辞 も %候補~接頭辞 も可用でない。
そのため、この段では，既定の~ns宣言を用いて~nsを定義する
— 既存の既定の~ns宣言が在れば，それは置換される。
◎
At this point, the namespace for this node still needs to be serialized, but there's no prefix (or candidate prefix) availble; the following uses the default namespace declaration to define the namespace--optionally replacing an existing default declaration if present.
</p>

		<ol>
			<li>
`~ns定義~属性は無視する~flag$V ~SET ~ON
◎
Set the ignore namespace definition attribute flag to true.
◎
Append to qualified name the value of node's localName.
</li>
			<li>
<p>
`文脈~ns$V ~SET %~ns
◎
Let the value of inherited ns be ns.
</p>
<p class="note">注記：
新たな既定の~nsは、直列化において， %要素 の~nsを定義するときに利用され、その`子$用の `文脈~ns$V として動作することになる。
◎
The new default namespace will be used in the serialization to define this node's namespace and act as the context namespace for its children.
</p>

					</li>
					<li>
<p>
%~ns宣言~markup ~SET 次の連結：
◎
Append the value of qualified name to markup.
◎
Append the following to markup, in the order listed:
</p>

<p class="note">注記：
これは、新たな（または代用の）既定の~ns定義を直列化する。
◎
The following serializes the new (or replacement) default namespace definition.
</p>

<div>
<ol><li>~SPACE
</li><li>`xmlns^l
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %~ns )
</li><li>`0022^U
</li></ol>
◎
• " " (U+0020 SPACE);
• The string "xmlns";
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given ns and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK). 
</div>

					</li>
				</ol>
<!-- Finally, regardless of prefix, the node has a local default namespace that matches 'ns'. So, we'll just use that and drop the prefix -->
			</li>
			<li>
<p>
~ELSE（ `局所的な既定の~ns$V ~EQ %~ns ~NEQ ε ）：
◎
Otherwise, the node has a local default namespace that matches ns. Append to qualified name the value of node's localName,＼
</p>
				<ol>
					<li>
`文脈~ns$V ~SET %~ns
◎
let the value of inherited ns be ns, and append the value of qualified name to markup.
</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
%~ns ~NEQ `文脈~ns$V になるような すべての組合せは，上で取扱われ、
%要素 は，その元の`~ns$eLを保全するように直列化されることになる。
◎
All of the combinations where ns is not equal to inherited ns are handled above such that node will be serialized preserving its original namespaceURI.
</p>
	</li>
	<li>
%局所~名 ~LET %要素 の`局所~名$eL
</li>
	<li>
<p>
`有修飾~名@V
~LET ［
%接頭辞 ~EQ ~NULL ならば %局所~名 ／
~ELSE_ 次の連結
]：
</p>

<ol ><li>%接頭辞
</li><li>`003A^U
</li><li>%局所~名
</li></ol>

◎
↑↑</li>
	<li>
<p>
%~markup ~LET 次の連結：
</p>
<ol ><li>`003C^U
</li><li>`有修飾~名$V
</li><li>%~ns宣言~markup
</li></ol>

◎
↑↑</li>
	<li>
%~markup に次の結果を付加する
⇒
%要素 の`属性たちを~XMLに直列化する$( %~map, `局所~接頭辞~map$V, `~ns定義~属性は無視する~flag$V )
◎
Append to markup the result of the XML serialization of node's attributes given map, prefix index, local prefixes map, ignore namespace definition attribute flag, and require well-formed flag.
</li>
	<li>
<p>
~IF［
%要素 は`子$を持たない
］~AND［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%~ns ~NEQ `~HTML~ns$
</li>
			<li>
［
%~ns ~EQ `~HTML~ns$
］~AND［
%局所~名 ~IN {
`area^l , `base^l , `basefont^l , `bgsound^l , `br^l , `col^l , `embed^l , `frame^l , `hr^l , `img^l , `input^l , `keygen^l , `link^l , `menuitem^l , `meta^l , `param^l , `source^l , `track^l , `wbr^l
} （これらは`~void要素$の~tag名を与える）
］
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
~IF［
%~ns ~EQ `~HTML~ns$
］
⇒
%~markup に ~SPACE を付加する
</li>
			<li>
<p>
%~markup に次の連結を付加する：
</p>

<ol><li>`002F^U
</li><li>`003E^U
</li></ol>
			</li>
			<li>
~RET %~markup
</li>
		</ol>

◎
If ns is the HTML namespace, and the node's list of children is empty, and the node's localName matches any one of the following void elements: "area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"; then append the following to markup, in the order listed:
◎
" " (U+0020 SPACE);
◎
"/" (U+002F SOLIDUS).
◎
and set the skip end tag flag to true.
◎
If ns is not the HTML namespace, and the node's list of children is empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.
◎
Append "&gt;" (U+003E GREATER-THAN SIGN) to markup.
◎
If the value of skip end tag is true, then return the value of markup and skip the remaining steps. The node is a leaf-node.
</li>
	<li>
%~markup に `003E^U を付加する
◎
↑</li>
	<li>

<p>
~IF［
%~ns ~EQ `~HTML~ns$
］~AND［
%局所~名 ~EQ `template^l
］
⇒
%~markup に次の結果を付加する
⇒
%要素 の`~template内容$を`~XMLに直列化する$( `文脈~ns$V, %~map )
◎
If ns is the HTML namespace, and the node's localName matches the string "template", then this is a template element. Append to markup the result of XML serializing a DocumentFragment node given the template element's template contents (a DocumentFragment), providing inherited ns, map, prefix index, and the require well-formed flag.
</p>

<p class="note">注記：
%要素 は `template$e 要素であり、その`~template内容$は `DocumentFragment$I である。
これは、`~XHTML文書を構文解析-$する規則の下でも，`~template内容$が往来できるようにする。
◎
This allows template content to round-trip , given the rules for parsing XHTML documents.
</p>

	</li>
	<li>
~ELSE
⇒
%要素 の ~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
%~markup に次の結果を付加する
⇒
%子 を`~XMLに直列化する$( `文脈~ns$V, %~map )
◎
Otherwise, append to markup the result of running the XML serialization algorithm on each of node's children, in tree order, providing inherited ns, map, prefix index, and the require well-formed flag.
</li>
	<li>
<p>
%~markup に次の連結を付加する：
</p>
<ol><li>`003C^U
</li><li>`002F^U
</li><li>`有修飾~名$V
</li><li>`003E^U
</li></ol>
◎
Append the following to markup, in the order listed:
◎
• "&lt;/" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
• The value of qualified name;
• "&gt;" (U+003E GREATER-THAN SIGN). 
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>

			<section id="recording-the-namespace">
<h4 title="Recording the namespace">4.1.1. ~nsの記録-法</h4>

<p>
次の~algoは、要素に局所的な~ns接頭辞~定義を出して，それらを `局所~接頭辞~map$V （初期~時は空）に追加した上で，それらで`~ns接頭辞~map$も更新する。
加えて、要素に局所的な既定の~ns宣言が［
在れば それが与える~ns ／
無ければ ε
］を返す。
◎
This following algorithm will update the namespace prefix map with any found namespace prefix definitions, add the found prefix definitions to the local prefixes map, and return a local default namespace value defined by a default namespace attribute if one exists. Otherwise it returns null.
</p>

<p class="algo-head">
%要素 の
`~ns情報を記録する@
ときは、所与の
(`~ns接頭辞~map$ %~map, `局所~接頭辞~map$V )
に対し，次を走らす：
◎
When recording the namespace information for an Element element, given a namespace prefix map map and a local prefixes map (initially empty), the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%既定の~ns属性~値 ~LET ε
◎
Let default namespace attr value be null.
</p>

<p class="trans-note">【
この訳では、原文の ~NULL に代えて ε を用いる。
“~NULL 名前空間” と混同しやすいので（原文のこの~algoが返す ~NULL は、 ~NULL 名前空間を表現する値ではない）。
】</p>

	</li>
	<li>
<p id="dfn-main">
%要素 の`属性~list$内の ~EACH( `属性$ %属性 ) に対し：
◎
Main: For each attribute attr in element's attributes, in the order they are specified in the element's attribute list:
</p>

<p class="note">注記：
この段の手続きは、`~XMLNS~ns$に属する属性のみを考慮する下で，~ns接頭辞を見出す（例えば，
<code>`setAttribute$m( `xmlns:pretend-prefix^l, `pretend-namespace^l )</code>
などを介して ~ns宣言に見せかけた属性は、含まれない）。
◎
The following conditional steps find namespace prefixes. Only attributes in the XMLNS namespace are considered (e.g., attributes made to look like namespace declarations via setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not included).
</p>

		<ol>
			<li>
( %属性~ns, %属性~接頭辞, %属性~値 )
~LET %属性 の
( `~ns$A, `~ns接頭辞$A, `値$A )
◎
Let attribute namespace be the value of attr's namespaceURI value.
◎
Let attribute prefix be the value of attr's prefix.
</li>
			<li>
~IF［
%属性~ns ~NEQ `~XMLNS~ns$
］
⇒
~CONTINUE
◎
If the attribute namespace is the XMLNS namespace, then:
</li>
			<li>
<p>
~IF［
%属性~接頭辞 ~EQ ~NULL
］：
</p>
<ol ><li>~Assert：%属性 は既定の~ns宣言である。
</li><li>%既定の~ns属性~値 ~SET %属性~値
</li><li>~CONTINUE
</li></ol>

◎
If attribute prefix is null, then attr is a default namespace declaration. Set the default namespace attr value to attr's value and stop running these steps, returning to Main to visit the next attribute.
</li>
			<li>
~Assert：
%属性 は~ns接頭辞~定義である。
◎
Otherwise, the attribute prefix is not null and attr is a namespace prefix definition. Run the following steps:
</li>
			<li>
%接頭辞 ~LET %属性 の`局所~名$A
◎
Let prefix definition be the value of attr's localName.
</li>
			<li>
%~ns ~LET %属性~値
◎
Let namespace definition be the value of attr's value.
</li>
			<li>
<p>
~IF［
%~ns ~EQ `~XML~ns$
］
⇒
~CONTINUE
◎
If namespace definition is the XML namespace, then stop running these steps, and return to Main to visit the next attribute.
</p>

<p class="note">注記：
`~XML~ns$を定義するような接頭辞は、完全に無視される（接頭辞が競合し得るときの不必要な作業を避けるため）。
`~XML~ns$に属する要素は、常に［
要素の局所~名に予約-済み接頭辞 `xml^l を接頭する
］よう，一律に（また、必要とされれば上書きするように）取扱われる。
◎
XML namespace definitions in prefixes are completely ignored (in order to avoid unnecessary work when there might be prefix conflicts). XML namespaced elements are always handled uniformly by prefixing (and overriding if necessary) the element's localname with the reserved "xml" prefix.
</p>
			</li>
			<li>
~IF［
%~ns ~EQ 空~文字列（どの~nsにも属さないことの宣言的な形）
］
⇒
%~ns ~SET ~NULL
◎
If namespace definition is the empty string (the declarative form of having no namespace), then let namespace definition be null instead.
</li>
			<li>
<p>
~IF［
`接頭辞は見出される$( %~map, %接頭辞, %~ns ) ~EQ ~T
］
⇒
~CONTINUE
◎
If prefix definition is found in map given the namespace namespace definition, then stop running these steps, and return to Main to visit the next attribute.
</p>

<p class="note">注記：
この段は、同じ~nsに対応する接頭辞~定義が，%~map 内に重ねて追加されるのを避ける。
これは、後に，子孫~nodeにおける~ns接頭辞~宣言が重ねて直列化されないようにする。
◎
This step avoids adding duplicate prefix definitions for the same namespace in the map. This has the side-effect of avoiding later serialization of duplicate namespace prefix declarations in any descendant nodes.
</p>
			</li>
			<li>
`接頭辞~mapに追加する$( %~map, %接頭辞, %~ns )
◎
Add the prefix prefix definition to map given namespace namespace definition.
</li>
			<li>
`局所~接頭辞~map$V[ %接頭辞 ] ~SET ［
%~ns ~NEQ ~NULL ならば %~ns ／
~ELSE_ 空~文字列
］
◎
Add the value of prefix definition as a new key to the local prefixes map, with the namespace definition as the key's value replacing the value of null with the empty string if applicable.
</li>
		</ol>
	</li>
	<li>
<p>
~RET %既定の~ns属性~値
◎
Return the value of default namespace attr value.
</p>

<p class="note">注記：
空~文字列は ~NULL には変換されない
— それも、 %既定の~ns属性~値 として~~合法なので。
◎
The empty string is a legitimate return value and is not converted to null.
</p>
	</li>
</ol>

			</section>
			<section id="the-namespace-prefix-map">
<h4 title="The Namespace Prefix Map">4.1.2. ~ns接頭辞~map</h4>

<div class="p">
<p>
`~ns接頭辞~map@
は、`~map$であり，その各~entryは：
</p>

<ul>
	<li>
［
~nsを与える文字列, または ~NULL
］を~keyとする。
この ~NULL は、どの~nsにも属さないことを表現する。
</li>
	<li>
`~ns接頭辞~list@
— 一連の~ns接頭辞からなる~list —
を値とする。
</li>
</ul>

<p>
これらの~entryの~keyたちは、所与の~nodeとその先祖たちにて，それまでに出くわした~nsで拡充され、各~keyに対応する値は，それまでに遭遇した［
~keyを与える~nsを結付けている接頭辞たち
］で拡充されることになる。
</p>

◎
A namespace prefix map is a map that associates namespaceURI and namespace prefix lists, where namespaceURI values are the map's unique keys (which can include the null value representing no namespace), and ordered lists of associated prefix values are the map's key values. The namespace prefix map will be populated by previously seen namespaceURIs and all their previously encountered prefix associations for a given node and its ancestors.
</div>

<p class="note">注記：
`~ns接頭辞~list$を成す接頭辞たちの順序は、出くわした順になる。
この~listは、対応する~nsが与えられたとき，それに合致し得る接頭辞を見出すときに探索される。
見出されなかった場合、~list内の最後の接頭辞が利用される。
追加の詳細は、［
`~ns接頭辞~mapを複製する$,
`選好される接頭辞~文字列を検索取得する$
］を見よ。
◎
Note: the last seen prefix for a given namespaceURI is at the end of its respective list. The list is searched to find potentially matching prefixes, and if no matches are found for the given namespaceURI, then the last prefix in the list is used. See copy a namespace prefix map and retrieve a preferred prefix string for additional details.
</p>

<p class="algo-head">
`~ns接頭辞~mapを複製する@
ときは、所与の`~ns接頭辞~map$を
— その各~entryの値を与える`~ns接頭辞~list$も含め —
複製する。
◎
To copy a namespace prefix map map means to copy the map's keys into a new empty namespace prefix map, and to copy each of the values in the namespace prefix list associated with each keys' value into a new list which should be associated with the respective key in the new map.
</p>

<p class="algo-head">
`選好される接頭辞~文字列を検索取得する@
ときは、所与の
( `~ns接頭辞~map$ %~map, %~ns, %選好される接頭辞 )
に対し，次を走らすべきである：
◎
To retrieve a preferred prefix string preferred prefix from the namespace prefix map map given a namespace ns, the user agent should:
</p>

<p class="trans-note">【
（この節の他の~algoも含め，）なぜ “べき（ should ）” ？
】</p>


<ol>
	<li>
%接頭辞~list ~LET %~map[ %~ns ]
◎
Let candidates list be the result of retrieving a list from map where there exists a key in map that matches the value of ns or＼
</li>
	<li>
~IF［
%接頭辞~list ~EQ ε
］
⇒
~RET ~NULL
◎
if there is no such key, then stop running these steps, and return the null value.
</li>
	<li>
~Assert：
%接頭辞~list は空でない。
◎
↓</li>
	<li>
~IF［
%選好される接頭辞 ~IN %接頭辞~list
］
⇒
~RET %選好される接頭辞
◎
Otherwise, for each prefix value prefix in candidates list, iterating from beginning to end:
• There will always be at least one prefix value in the list.
• If prefix matches preferred prefix, then stop running these steps and return prefix.
• If prefix is the last item in the candidates list, then stop running these steps and return prefix.
</li>
	<li>
~RET %接頭辞~list 内の最後の~item
◎
↑</li>
</ol>


<p class="algo-head">
`接頭辞は見出される@
かどうか検査するときは、所与の
( `~ns接頭辞~map$ %~map, %接頭辞, %~ns )
に対し，次を走らすべきである：
◎
To check if a prefix string prefix is found in a namespace prefix map map given a namespace ns, the user agent should:
</p>

<ol>
	<li>
%接頭辞~list ~LET %~map[ %~ns ]
◎
Let candidates list be the result of retrieving a list from map where there exists a key in map that matches the value of ns or＼
</li>
	<li>
~IF［
%接頭辞~list ~EQ ε
］
⇒
~RET ~F
◎
if there is no such key, then stop running these steps, and return false.
</li>
	<li>
~IF［
%接頭辞 ~IN %接頭辞~list
］
⇒
~RET ~T
◎
If the value of prefix occurs at least once in candidates list, return true,＼
</li>
	<li>
~RET ~F
◎
otherwise return false.
</li>

</ol>

<p class="algo-head">
`接頭辞~mapに追加する@
ときは、所与の
( `~ns接頭辞~map$ %~map, %接頭辞, %~ns )
に対し，次を走らすべきである：
◎
To add a prefix string prefix to the namespace prefix map map given a namespace ns, the user agent should:
</p>

<ol>
	<li>
~IF［
%~map[ %~ns ] ~EQ ε
］
⇒
%~map[ %~ns ] ~SET %接頭辞 のみからなる新たな`~ns接頭辞~list$
◎
Let candidates list be the result of retrieving a list from map where there exists a key in map that matches the value of ns or if there is no such key, then let candidates list be null.
◎
If candidates list is null, then create a new list with prefix as the only item in the list, and associate that list with a new key ns in map.
</li>
	<li>
~ELSE
⇒
%~map[ %~ns ] に %接頭辞 を付加する
◎
Otherwise, append prefix to the end of candidates list.
</li>
</ol>

<p class="note">注記：
`選好される接頭辞~文字列を検索取得する$手続きは、`~ns接頭辞~list$を利用して，［
所与の~nsを結付けている接頭辞のうち，最も近過去に利用されたもの†
］を追跡する
— ~list内の最後の接頭辞がそれになる。
この~listは、より早く出くわした同じ接頭辞を重複して包含し得る（そうなってもかまわない）。
【†原文には MRU （ most recently used ）という略称も付記されている）。】
◎
The steps in retrieve a preferred prefix string use the list to track the most recently used (MRU) prefix associated with a given namespace, which will be the prefix at the end of the list. This list may contain duplicates of the same prefix value seen earlier (and that's OK).
</p>

			</section>
			<section id="serializing-an-element-s-attributes">
<h4 title="Serializing an Element's attributes">4.1.3. 要素の属性たちの直列化-法</h4>

<p class="algo-head">
`要素$ %要素 の
`属性たちを~XMLに直列化する@
ときは、所与の
( `~ns接頭辞~map$ %~map, `局所~接頭辞~map$V, `~ns定義~属性は無視する~flag$V )
に対し，次を走らせた結果を返す：
◎
The XML serialization of the attributes of an Element element together with a namespace prefix map map, a generated namespace prefix index prefix index reference, a local prefixes map, a ignore namespace definition attribute flag, and a require well-formed flag, is the result of the following algorithm:
</p>

<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%局所~名~集合 ~LET 新たな空~集合
◎
Let localname set be a new empty namespace localname set.＼
</p>

<p>
この集合は、 %要素 の各 `属性$が処理されるに伴い，`属性$の ( `~ns$A, `局所~名$A ) が成す一意な組たちで拡充されることになる。
◎
This localname set will contain tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is processed.＼
</p>

<p class="note">
注記：
この集合は、［［
要素の 2 個の属性が同じ ( `~ns$A, `局所~名$A ) を有する
］ことはないとする整形式~拘束
］を，任意選択で施行するために利用される。
これが生じ得るのは、要素が，接頭辞のみ相違するような 2 個の属性を有するときである。
◎
This set is used to [optionally] enforce the well-formed constraint that an element cannot have two attributes with the same namespaceURI and localName. This can occur when two otherwise identical attributes on the same element differ only by their prefix values.
</p>
	</li>
	<li>
<p id="dfn-loop">
%要素 の`属性~list$内の~EACH( `属性$ %属性 ) に対し:
◎
Loop: For each attribute attr in element's attributes, in the order they are specified in the element's attribute list:
</p>

		<ol>
			<li>
( %局所~名, %~ns, %値, %接頭辞 )
~LET %属性 の
( `局所~名$A, `~ns$A, `値$A, `~ns接頭辞$A )
◎
↓</li>
			<li>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
組 ( %~ns, %局所~名 ) ~IN %局所~名~集合
］
⇒
~THROW 例外
— %属性 を直列化すると要素は整形式にならなくなる。
◎
If the require well-formed flag is set (its value is true), and the localname set contains a tuple whose values match those of a new tuple consisting of attr's namespaceURI attribute and localName attribute, then throw an exception; the serialization of this attr would fail to produce a well-formed element serialization.
</li>
	<li>
%局所~名~集合 に 組 ( %~ns, %局所~名 ) を追加する
◎
Create a new tuple consisting of attr's namespaceURI attribute and localName attribute, and add it to the localname set.
</li>
	<li>
%候補~接頭辞 ~LET ~NULL
<!-- Check for an unregistered attribute namespace, and if so, serialize a definition for it -->
◎
Let attribute namespace be the value of attr's namespaceURI value.
◎
Let candidate prefix be null.
</li>
	<li>
<p>
~IF［
%~ns ~NEQ ~NULL
］：
◎
If attribute namespace is not null, then run these sub-steps:
</p>
		<ol>
			<li>
%候補~接頭辞 ~LET `選好される接頭辞~文字列を検索取得する$( %~map, %~ns, %接頭辞 )
◎
Let candidate prefix be the result of retrieving a preferred prefix string from map given namespace attribute namespace with preferred prefix being attr's prefix value.
</li>
			<li>
<p>
~IF［
%~ns ~EQ `~XMLNS~ns$
］：
◎
If the value of attribute namespace is the XMLNS namespace, then run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~CONTINUE
◎
If any of the following are true, then stop running these steps and goto Loop to visit the next attribute:
</p>
						<ul>
							<li>
<p>
%値 ~EQ `~XML~ns$
◎
the attr's value is the XML namespace;
</p>

<p class="note">注記：
`~XML~ns$は、再~宣言できず，`往来-$時にも生き残る（それが接頭辞 `xml^l を定義していない限り）。
この問題を避けるため，この~algoは、`~XML~ns$に属する要素には，常に `xml^l を接頭し、上の条件に見られるように，関係する定義は落とす。
◎
The XML namespace cannot be redeclared and survive round-tripping (unless it defines the prefix "xml"). To avoid this problem, this algorithm always prefixes elements in the XML namespace with "xml" and drops any related definitions as seen in the above condition.
</p>
							</li>
							<li>
［
%接頭辞 ~EQ ~NULL
］~AND［
`~ns定義~属性は無視する~flag$V ~EQ ~ON （ %要素 の既定の~ns属性は，飛ばされるべきである）
］
◎
the attr's prefix is null and the ignore namespace definition attribute flag is true (the Element's default namespace attribute should be skipped);
</li>
							<li>
<p>
次がすべて満たされる：
</p>
								<ul>
									<li>
%接頭辞 ~NEQ ~NULL
◎
the attr's prefix is not null and either
</li>
									<li>
`局所~接頭辞~map$V[ %局所~名 ] ~IN { ε, %値 }
◎
the attr's localName is not a key contained in the local prefixes map, or
◎
the attr's localName is present in the local prefixes map but the value of the key does not match attr's value
</li>
									<li>
`接頭辞は見出される$( `~ns接頭辞~map$, %局所~名, %値 ) ~EQ ~T
◎
and furthermore that the attr's localName (as the prefix to find) is found in the namespace prefix map given the namespace consisting of the attr's value＼
</li>
								</ul>

<p>
（現在の~ns接頭辞~定義は、 %要素 のある先祖~上で定義されたものである。）
◎
(the current namespace prefix definition was exactly defined previously--on an ancestor element not the current element whose attributes are being processed).
</p>
							</li>
						</ul>
					</li>
					<li>
<p>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%値 ~IN { `~XMLNS~ns$†, 空~文字列†† }
］
⇒
~THROW 例外
◎
↓</p>

						<ul>
							<li>
<p>†
この属性の直列化は妥当でない~XMLを生産する
— `~XMLNS~ns$は予約-済みであり，~XML構文解析を介しては要素の~nsとして適用できないので。
◎
If the require well-formed flag is set (its value is true), and the value of attr's value attribute matches the XMLNS namespace, then throw an exception; the serialization of this attribute would produce invalid XML because the XMLNS namespace is reserved and cannot be applied as an element's namespace via XML parsing.
</p>

<p class="note">注記：
~DOM~APIは、厳格な~~条件の下で，`~XMLNS~ns$に属する要素の作成を許容する。
◎
DOM APIs do allow creation of elements in the XMLNS namespace but with strict qualifications.
</p>
							</li>
							<li>
††
~ns接頭辞~宣言は，~nsを未宣言にする用途には利用できない（代わりに既定の~ns宣言を利用すること）。
◎
If the require well-formed flag is set (its value is true), and the value of attr's value attribute is the empty string, then throw an exception; namespace prefix declarations cannot be used to undeclare a namespace (use a default namespace declaration instead).
</li>
						</ul>
					</li>
					<li>
<!-- ＊原文 if 抜け -->
~IF［
%接頭辞 ~EQ `xmlns^l
］
⇒
%候補~接頭辞 ~LET `xmlns^l
◎
the attr's prefix matches the string "xmlns", then let candidate prefix be the string "xmlns".
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %~ns ~NEQ `~XMLNS~ns$ ）：
◎
Otherwise, the attribute namespace in not the XMLNS namespace. Run these steps:
</p>
				<ol>
					<li>
%候補~接頭辞 ~LET `接頭辞を生成する$( %~map, %~ns )
◎
Let candidate prefix be the result of generating a prefix providing map, attribute namespace, and prefix index as input.
</li>
					<li>
<p>
%結果 に次の連結を付加する：
</p>

<ol><li>~SPACE
</li><li>`xmlns:^l
</li><li>%候補~接頭辞
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %~ns )
</li><li>`0022^U
</li></ol>

◎
Append the following to result, in the order listed:
• " " (U+0020 SPACE);
• The string "xmlns:";
• The value of candidate prefix;
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given attribute namespace and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK). 
</li>
				</ol>
			</li>
		</ol>
<!-- A namespace prefix has been set by this point if it needed to be set -->
	</li>
	<li>
%結果 に ~SPACE を付加する
◎
Append a " " (U+0020 SPACE) to result.
</li>
	<li>
<p>
~IF［
%候補~接頭辞 ~NEQ ~NULL
］
⇒
%結果 に次の連結を付加する：
</p>
<ol><li>%候補~接頭辞
</li><li>`003A^U 
</li></ol>
◎
If candidate prefix is not null, then append to result the concatenation of candidate prefix with ":" (U+003A COLON).
</li>
	<li>
<p>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
次がすべて満たされる
］：
</p>

		<ul>
			<li>
<p>
%局所~名 は次のいずれかを満たす：
</p>

				<ul>
					<li>
`003A^U を包含する
</li>
					<li>
~XML `Name$P 生成規則に合致しない文字列を包含する
</li>
					<li>
%局所~名 ~EQ `xmlns^l
</li>
				</ul>
			</li>
			<li>
%~ns ~EQ ~NULL
</li>
		</ul>
<p>
…ならば
⇒
~THROW 例外
— %属性 の直列化は整形式~属性にならない。
</p>
◎
If the require well-formed flag is set (its value is true), and this attr's localName attribute contains the character ":" (U+003A COLON) or does not match the XML Name production or equals "xmlns" and attribute namespace is null, then throw an exception; the serialization of this attr would not be a well-formed attribute.
</li>
	<li>
<p>
%結果 に次の連結を付加する：
</p>

<ol ><li>%局所~名
</li><li>`003D^U
</li><li>`0022^U
</li><li>`属性~値を直列化する$( %値 )
</li><li>`0022^U
</li></ol>

◎
Append the following strings to result, in the order listed:
• The value of attr's localName;
• "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
• The result of serializing an attribute value given attr's value attribute and the require well-formed flag as input;
• """ (U+0022 QUOTATION MARK). 
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return the value of result.
</li>
</ol>

<p class="algo-head">
`属性~値を直列化する@
ときは、所与の
( %値 )
に対し，次を走らす：
◎
When serializing an attribute value given an attribute value and require well-formed flag, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%値 内には~XML `Char$P 生成規則に合致しない文字がある
］
⇒
~THROW 例外
— %値 の直列化は整形式~要素~直列化を生産するのに失敗する。
◎
If the require well-formed flag is set (its value is true), and attribute value contains characters that are not matched by the XML Char production, then throw an exception; the serialization of this attribute value would fail to produce a well-formed element serialization.
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If attribute value is null, then return the empty string.
</li>
	<li>
%結果 ~LET 空~文字列
◎
Otherwise, attribute value is a string.＼
</li>
	<li>
<p>
%値 内の~EACH( %文字 ) に対し，順に
⇒
%結果 に ［
%文字 に応じて，次に与える文字列
］を付加する
⇒
`0026^U ならば `&amp;amp;^l ／
`0022^U ならば `&amp;quot;^l ／
`003C^U ならば `&amp;lt;^l ／
`003E^U ならば `&amp;gt;^l ／
~ELSE_ %文字
◎
Return the value of attribute value, first replacing any occurrences of the following:
◎
"&amp;" with "&amp;amp;"
◎
""" with "&amp;quot;"
◎
"&lt;" with "&amp;lt;"
◎
"&gt;" with "&amp;gt;"
</p>

<p class="note">注記：
これは、~browserたちの挙動に合致する。
また， `003E^U も置換することにより、~XML仕様の `AttValue$P 生成規則による文法を超える要件を課す。
◎
This matches behavior present in browsers, and goes above and beyond the grammar requirement in the XML specification's AttValue production by also replacing "&gt;" characters.
</p>
	</li>
	<li>
~RET %結果
◎
↑</li>
</ol>

			</section>
			<section id="generating-namespace-prefixes">
<h4 title="Generating namespace prefixes">4.1.4. ~ns接頭辞の生成-法</h4>

<p class="algo-head">
`接頭辞を生成する@
ときは、所与の
( `~ns接頭辞~map$ %~map, 文字列 %新たな~ns )
に対し，次を走らす：
◎
To generate a prefix given a namespace prefix map map, a string new namespace, and a reference to a generated namespace prefix index prefix index, the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%生成された接頭辞 ~LET 次の連結：
</p>

<ol ><li>`ns^l
</li><li>`接頭辞~index$V の数値を直列化した結果
【正確にどう直列化するかは述べられていない。】
</li></ol>

◎
Let generated prefix be the concatenation of the string "ns" and＼
◎
the current numerical value of prefix index.
</li>
	<li>
`接頭辞~index$V ~INCBY 1
◎
Let the value of prefix index be incremented by one.
</li>
	<li>
`接頭辞~mapに追加する$( %~map, %生成された接頭辞, %新たな~ns )
◎
Add to map the generated prefix given the new namespace namespace.
</li>
	<li>
~RET %生成された接頭辞
◎
Return the value of generated prefix.
</li>
</ol>

			</section>
		</section>
		<section id="xml-serializing-a-document-node">
<h3 title="XML serializing a Document node">4.2. 文書を~XMLに直列化する</h3>


<p class="algo-head">
`Document$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type Document is as follows:
</p>

<ol>
	<li>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%~node の`文書~要素$ ~EQ ~NULL
］
⇒
~THROW 例外
— %~node の直列化は整形式~文書にならない。
◎
If the require well-formed flag is set (its value is true), and this node has no documentElement (the documentElement attribute's value is null), then throw an exception; the serialization of this node would not be a well-formed document.
</li>
	<li>
%直列形の文書 ~LET 空~文字列
◎
Otherwise, run the following steps:
◎
Let serialized document be an empty string.
</li>
	<li>
<p>
%~node の~EACH( `子$ %子 ) に対し，`木~順序$で
⇒
%直列形の文書 に次の結果を付加する
⇒
%子 を`~XMLに直列化する$( `文脈~ns$V, `接頭辞~map$V )
◎
For each child child of node, in tree order, run the XML serialization algorithm on the child passing along the provided arguments, and append the result to serialized document.
</p>

<p class="note">注記：
これは、`文書~要素$の前後にある任意個数の［
`ProcessingInstruction$I ／ `Comment$I
］~node, および
高々 1 個の `DocumentType$I ~nodeも，直列化することになる。
（ `Text$I ~nodeは`文書$の子には許容されない。）
◎
This will serialize any number of ProcessingInstruction and Comment nodes both before and after the Document's documentElement node, including at most one DocumentType node. (Text nodes are not allowed as children of the Document.)
</p>

	</li>
	<li>
~RET %直列形の文書
◎
Return the value of serialized document.
</li>
</ol>

		</section>
		<section id="xml-serializing-a-comment-node">
<h3 title="XML serializing a Comment node">4.3. `Comment^I ~nodeを~XMLに直列化する</h3>


<p class="algo-head">
`Comment$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type Comment is as follows:
</p>

<ol>
	<li>
%~data ~LET %~node の`~data$
◎
↓</li>
	<li>
<p>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%~data は次のいずれかを満たす
］…：
</p>

<ul ><li>~XML `Char$P 生成規則に合致しない文字がある
</li><li>2 個の `002D^U 並びを包含する 
</li><li>`002D^U で終端している
</li></ul>
<p>
…ならば
⇒
~THROW 例外
— %~data の直列化は整形式にならない。
</p>
◎
If the require well-formed flag is set (its value is true), and node's data contains characters that are not matched by the XML Char production or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception; the serialization of this node's data would not be well-formed.
</li>
	<li>
<p>
~RET 次の連結：
</p>
<ol><li>`&lt;!--^l
</li><li>%~data
</li><li>`--&gt;^l
</li></ol>

◎
Otherwise, return the concatenation of "&lt;!--", node's data, and "--&gt;".
</li>
</ol>

		</section>
		<section id="xml-serializing-a-text-node">
<h3 title="XML serializing a Text node">4.4. `Text^I ~nodeを~XMLに直列化する</h3>


<p class="algo-head">
`Text$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type Text is as follows:
</p>

<ol>
	<li>
%~data ~LET %~node の`~data$
</li>
	<li>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
%~data 内には~XML `Char$P 生成規則に合致しない文字がある
］
⇒
~THROW 例外
— %~data の直列化は整形式にならない。
◎
If the require well-formed flag is set (its value is true), and node's data contains characters that are not matched by the XML Char production, then throw an exception; the serialization of this node's data would not be well-formed.
</li>
	<li>
%~markup ~LET 空~文字列
◎
Let markup be the value of node's data.
</li>
	<li>
%~data 内の~EACH( %文字 ) に対し，順に
⇒
%~markup に ［
%文字 に応じて，次に与える文字列
］を付加する
⇒
`0026^U ならば `&amp;amp;^l ／
`003C^U ならば `&amp;lt;^l ／
`003E^U ならば `&amp;gt;^l ／
~ELSE_ %文字
◎
Replace any occurrences of "&amp;" in markup by "&amp;amp;".
◎
Replace any occurrences of "&lt;" in markup by "&amp;lt;".
◎
Replace any occurrences of "&gt;" in markup by "&amp;gt;".
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>

		</section>
		<section id="xml-serializing-a-documentfragment-node">
<h3 title="XML serializing a DocumentFragment node">4.5. `DocumentFragment^I ~nodeを~XMLに直列化する</h3>


<p class="algo-head">
`DocumentFragment$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type DocumentFragment is as follows:
</p>

<ol>
	<li>
%~markup ~LET 空~文字列
◎
Let markup the empty string.
</li>
	<li>
%~node の~EACH( `子$ %子 ) に対し，`木~順序$で
⇒
%~markup に次の結果を付加する
⇒
%子 を`~XMLに直列化する$( `文脈~ns$V, `接頭辞~map$V )
◎
For each child child of node, in tree order, run the XML serialization algorithm on the child given namespace, prefix map, a reference to prefix index, and flag require well-formed. Concatenate the result to markup.
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li>
</ol>

		</section>
		<section id="xml-serializing-a-documenttype-node">
<h3 title="XML serializing a DocumentType node">4.6. `DocumentType^I ~nodeを~XMLに直列化する</h3>


<p class="algo-head">
`DocumentType$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type DocumentType is as follows:
</p>

<ol>
	<li>
( %~publicID, %~systemID )
~LET
%~node の ( `~publicID$dT, `~systemID$dT )
◎
↓</li>
	<li>
<p>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
次のいずれかが満たされる
］…：
</p>

<ul ><li>%~publicID 内に［
~XML `PubidChar$P 生成規則に合致しない文字
］がある
</li><li>%~systemID 内に［
~XML `Char$P 生成規則に合致しない文字
］がある
</li><li>%~systemID 内に［
`0022^U, `0027^U
］の両者がある
</li></ul>


<p>
…ならば
⇒
~THROW 例外
— %~node の直列化は整形式の文書~型~宣言にならない。
</p>

◎
If the require well-formed flag is true and the node's publicId attribute contains characters that are not matched by the XML PubidChar production, then throw an exception; the serialization of this node would not be a well-formed document type declaration.
◎
If the require well-formed flag is true and the node's systemId attribute contains characters that are not matched by the XML Char production or that contains both a """ (U+0022 QUOTATION MARK) and a "'" (U+0027 APOSTROPHE), then throw an exception; the serialization of this node would not be a well-formed document type declaration.
</li>
	<li>
<p>
%~markup ~LET 次の連結：
</p>

<ol ><li>`003C^U
</li><li>`0021^U
</li><li>`DOCTYPE^l
</li><li>~SPACE
</li><li>%~node の`名前$dT<!-- ＊原文誤 Name -->
— %~node が`~HTML文書$に属する場合、この値は小文字のみからなる
</li></ol>

◎
Let markup be an empty string.
◎
Append the string "&lt;!DOCTYPE" to markup.
◎
Append " " (U+0020 SPACE) to markup.
◎
Append the value of the node's name attribute to markup. For a node belonging to an HTML document, the value will be all lowercase.
</li>
	<li>
<p>
~IF［
%~publicID ~NEQ 空~文字列
］
⇒
%~markup に次の連結を付加する：
</p>

<ol><li>~SPACE
</li><li>`PUBLIC^l
</li><li>~SPACE
</li><li>`0022^U
</li><li>%~publicID
</li><li>`0022^U
</li></ol>

◎
If the node's publicId is not the empty string then append the following, in the order listed, to markup:
• " " (U+0020 SPACE);
• The string "PUBLIC";
• " " (U+0020 SPACE);
• """ (U+0022 QUOTATION MARK);
• The value of the node's publicId attribute;
• """ (U+0022 QUOTATION MARK). 
</li>
	<li>
<p>
~IF［
%~systemID ~NEQ 空~文字列
］~AND［
%~publicID ~EQ 空~文字列
］
⇒
%~markup に次の連結を付加する：
</p>
<ol><li>~SPACE
</li><li>`SYSTEM^l
</li></ol>
◎
If the node's systemId is not the empty string and the node's publicId is set to the empty string, then append the following, in the order listed, to markup:
• " " (U+0020 SPACE);
• The string "SYSTEM".
</li>
	<li>
<p>
~IF［
%~systemID ~NEQ 空~文字列
］
⇒
%~markup に次の連結を付加する：
</p>
<ol><li>~SPACE
</li><li>`0022^U
</li><li>%~systemID
</li><li>`0022^U
</li></ol>
◎
If the node's systemId is not the empty string then append the following, in the order listed, to markup:
• " " (U+0020 SPACE);
• """ (U+0022 QUOTATION MARK);
• The value of the node's systemId attribute;
• """ (U+0022 QUOTATION MARK).
</li>


<!-- Removing internalSubset serialization steps as this property is not supported by DOM4. Also,
optional requirements don't help improve interoperability:

<li>Optional: if the <var>node</var> has an (historical) <code><a>internalSubset</a></code> and
the <code><a>internalSubset</a></code> attribute's value is a non-empty string, then append the
following, in the order listed, to <var>markup</var>:
<ol>

<li>"<code> </code>" (U+0020 SPACE);


<li>"<code>[</code>" (U+005B LEFT SQUARE BRACKET);


<li>The value of the <var>node</var>'s <code><a>internalSubset</a></code> attribute;


<li>"<code>]</code>" (U+005D RIGHT SQUARE BRACKET);
</ol>

<p class=note>A <var>node</var> belonging to an <a>HTML document</a> will never have an
<code><a>internalSubset</a></code> because any <code><a>internalSubset</a></code> markup is
ignored by the HTML parser.</p>
-->

	<li>
%~markup に `003E^U を付加する
◎
Append "&gt;" (U+003E GREATER-THAN SIGN) to markup.
</li>
	<li>
~RET %~markup
◎
Return the value of markup.
</li></ol>

		</section>
		<section id="xml-serializing-a-processinginstruction-node">
<h3 title="XML serializing a ProcessingInstruction node">4.7. `ProcessingInstruction^I ~nodeを~XMLに直列化する</h3>


<p class="algo-head">
`ProcessingInstruction$I `型の~nodeを~XMLに直列化する$ときは、次に従う：
◎
The algorithm for producing an XML serialization of a DOM node of type ProcessingInstruction is as follows:
</p>

<ol>
	<li>
( %~target, %~data )
~LET %~node の
( `~target$pI, `~data$ )
◎
↓</li>
	<li>
<p>
~IF［
`要~整形式~flag$V ~EQ ~ON
］~AND［
次のいずれかが満たされる
］…：
</p>

<ul ><li>%~target 内に `003A^U がある
</li><li>%~target は`~ASCII大小無視$で `xml^l に合致する
</li><li>%~data 内に~XML `Char$P 生成規則に合致しない文字がある
</li><li>%~data 内に `?&gt;^l （ `003F^U `003E^U ）がある
</li></ul>

<p>
…ならば
⇒
~THROW 例外
— %~target ／ %~data の直列化は整形式にならない。
</p>

◎
If the require well-formed flag is set (its value is true), and node's target contains a ":" (U+003A COLON) character or is an ASCII case-insensitive match for the string "xml", then throw an exception; the serialization of this node's target would not be well-formed.
◎
If the require well-formed flag is set (its value is true), and node's data contains characters that are not matched by the XML Char production or contains the string "?&gt;" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization of this node's data would not be well-formed.
</li>
	<li>
<p>
~RET 次の連結：
</p>

<ol ><li>`003C^U
</li><li>`003F^U
</li><li>%~target
</li><li>~SPACE
</li><li>%~data
</li><li>`003F^U
</li><li>`003E^U
</li></ol>
◎
Let markup be the concatenation of the following, in the order listed:
◎
• "&lt;?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
• The value of node's target;
• " " (U+0020 SPACE);
• The value of node's data;
• "?&gt;" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN). 
◎
Return the value of markup.
</li>
</ol>

		</section>
	</section>
	<section id="dependencies">
<h2 title="A. Dependencies">依存関係</h2>

<p>
【<a href="#_conventions">この節の内容の和訳は省略する。</a>】
</p>

	</section>
	<section id="revision-history">
<h2 title="B. Revision History">改訂~履歴</h2>

<p>
この仕様の最後の発行版からの変更点（参考）を以下に~~要約する。
この仕様の編集者草案の完全な改訂~履歴は
<a href="https://github.com/w3c/DOM-Parsing/commits/gh-pages">W3C Github Repository</a>
にて見出せる。
より~~過去の改訂は、
<a href="https://dvcs.w3.org/hg/innerhtml/summary/">W3C Mercurial server</a>
にある。
◎
The following is an informative summary of the changes since the last publication of this specification. A complete revision history of the Editor's Drafts of this specification can be found at the W3C Github Repository and older revisions at the W3C Mercurial server.
</p>

<ul>
	<li>
2016 年 6 月の作業草案にて、文書を編成し直した：
単体的な~XML直列化~algoは、数節に~~分解した。
依存関係を明確化した。
~XML直列化~algoは、相互運用可能な~browserの挙動に近くなるよう更新された。
◎
2016-06 WD - Editorial restructuring of the document; monolithic XML serialization algorithm factored into sections. Dependencies clarified. XML Serialization algorithm updated to get closer to interoperable browser behavior.
</li>
	<li>
<a href="https://dvcs.w3.org/hg/innerhtml/raw-file/tip/LC2_comments.html">前回の Last Call 文書からの規範的でない変更点</a>
を組入れた。
◎
Incorporated non-normative changes from previous Last Call document.
</li>
</ul>


	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様が基づいている元の
DOM Parsing and Serialization Living Standard
を作成して保守された［
Ms2ger 氏と WHATWG の他の方々による元の仕事
］に感謝する：
◎
We acknowledge with gratitude the original work of Ms2ger and others at the WHATWG, who created and maintained the original DOM Parsing and Serialization Living Standard upon which this specification is based.
</p>

<p lang="en-x-a0">
Thanks to C. Scott Ananian, Victor Costan, Aryeh Gregor, Anne van Kesteren, Arkadiusz Michalski, Simon Pieters, Henri Sivonen, Josh Soref and Boris Zbarsky, for their useful comments.
</p>

<p>
`HTML5$r にて
`innerHTML$m, `outerHTML$m 属性,
`insertAdjacentHTML()$m ~methodを最初に定義され，有用な~commentを書かれた Ian Hickson 氏に特別な謝意を。
◎
Special thanks to Ian Hickson for first defining the innerHTML and outerHTML attributes, and the insertAdjacentHTML method in [HTML5] and his useful comments.
</p>


	</section>
</main></div>
