<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>XMLHttpRequest Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = () => {
	const source_data = {
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:XMLHttpRequest
spec_date:2025-03-11
trans_update:2025-03-14
source_checked:230927
original_url:https://xhr.spec.whatwg.org/
spec_status:LS
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,storage,security
copyright:,whatwg
trans_1st_pub:2012-10-25


●●class_map
e:element
a:attr
et:event-type
E:error
sc:scheme
AO:abstract
hm:method
X:hex-value

●●tag_map
I:code
m:code
mb:code
c:code
e:code
a:code
et:code
E:code
hm:code
v:var
i:i
AO:span
X:span

●●words_table1

open_async:open
type0:type
send_:<code>send()</code> 
w3cML:https://lists.w3.org/Archives/Public

●●words_table

	●データ／型／構造
数量-:numeric:~
昇順:ascending order:~
無符号:unsigned:~

	●構文
	MIME:mime
backtick::::バッククォート
予走査:prescan::~
確定的:definite:~
整形式性:well formedness::~
	settings object

	●XHR／network／stream
予行:preflight::~::プリフライト
伝送量:transmitted::~
	本体の終端:end-of-body
username::::ユーザ名
password::::パスワード
活動:activity::~
最終-:final::~
開いて:openして::~
	load:::

chunk::::チャンク
close:
open:
	~openした:opened:
未送信:unsent::~
	読込n中:loading
	全~headerを受信した:headers received
	済み:done
済んだ:done:~
~done:

	headers::::ヘッダリスト
	~network用:networking
	受信-済み:received
	結合-済み:combined

	●一般処理
	発火-法:firing
時間切れ:timed out::~
	時間~切れ:preset time expiring
制限時間:timeout::~
経過-:pass:~
	-:fallback
	現~時刻:present time
	今:now
並列:parallel::~
静止-:pause:~
増分的:incremental::~
完結-:finalize::~

	●仕様
opt-in::::オプトイン
末端利用者:end user:~:::エンドユーザ
節:section:~
要覧:summary:~
中止:aborted::~
	中止-済み:aborted
移管-:move:~
併合-:merge:~
観点:perspective:~
	experiment
過程:process:~
警告-:warn:~
精巧:elaborate:~

	typographic
	specification
	旧来のものでない:non-legacy
	施策により制御され:policy-controlled
	~~機能:working
	用例:example
	引用:
	当初:
	成果:

	全般:Throughout
	不具合が生じた:went wrong
	~~互換性
	調べる:check
	~~調整:tune
	~~問題に馴染みのある人達の意見を汲む:ensure input from people familiar with the subject
	何年も:many years
	メーリングリスト
	可能
	同様
	同類
	経緯
	~~規定:set forth
	かまわない:free to
	単純にする:simplicity
	この仕様:XMLHttpRequest Standard

	●未分類
割振る:allocateする:割り振る
絞込まれ:filterされ::絞り込まれ
	interaction
集める:gatherする:~
露呈-:reveal:~
XSLT:
担当の:responsible::~
排他的:mutually exclusive:~
milli::::ミリ
	~milli秒:milliseconds
	~milli秒:ms
	~milli秒数:in milliseconds
	-:relative
	-:variable
	数
	括弧内
	単位
	範囲:range
	際限のない:infinite
	追従-済:have been followed
	過ぎた:passed
	出現
	始ま:begin:

	●変数
	%構文解析した~URL:parsedURL
	%抽出された内容~型:extractedContentType
	%元の作者~内容~型:originalAuthorContentType
	%内容~型~record:contentTypeRecord
	%~parameter群:parameters
	%内容~型:-
	%要請:req
	%要請:request
	%伝送量:transmitted
	%長さ:length
	%応答:response
	%本体:-
	%本体と型:bodyWithType
	%~chunk:chunk
	%制限時間:-
	%~promise:promise
	%~byte列:bytes
	%XHR:xhr
	%~event型:event
	%例外:exception
	%~URL:url
	%出力:output
	%~header~list:headers
	%a:a
	%b:b
	%~header:header
	%~MIME型:mimeType
	%上書き~MIME型:-
	%~label:label
	%符号化法:encoding
	%charset:charset
	%最終-~MIME型:finalMIME
	%文書:document
	%W
	%~JSON~obj:jsonObject
	%名前:name
	%値:value
	%~entry:entry
	%~list:list
	%target:target
	%e:e
	-:responseMIME
	%要請の本体~chunk長さの処理n:processRequestBodyChunkLength
	%要請の本体~終了~時の処理n:processRequestEndOfBody
	%応答の処理n:processResponse
	%応答の本体を消費する処理n:processResponseConsumeBody
	%応答は処理したか:processedResponse
	%本体~chunkの処理n:processBodyChunk
	%本体~終了~時の処理n:processEndOfBody
	%本体~errorの処理n:processBodyError
	%~NULLまたは失敗または~byte列:nullOrFailureOrBytes
	%~byte列~長さ:bytesLength
	%伝送-済み要請~本体:requestBodyTransmitted
	%要請~本体~長さ:requestBodyLength


	●指示語
	無
	〜の後:after
	一連
	一部
	以下
	以上
	各種
	唯一
	全体:
	回
	個
	時点
	最終的
	時機:when
	回数:times
	場合
	重ねて:twice
	非:non


●●original_id_map

dom-formdata-iterable:
	handle-response-end-of-body:handle-response-end-of-file
	_entries:concept-formdata-entry
	_entries:concept-formdata-entry-name
	_entries:concept-formdata-entry-value
	_entries:create-an-entry

●●mdn_urls
formdata:API/FormData
formdataentryvalue:API/FormDataEntryValue
progressevent:API/ProgressEvent
xmlhttprequest:API/XMLHttpRequest
xmlhttprequesteventtarget:API/XMLHttpRequestEventTarget
xmlhttprequestresponsetype:API/XMLHttpRequestResponseType
	xmlhttprequestupload:API/XMLHttpRequestUpload
	progresseventinit:API/ProgressEventInit

event-xhr-abort:API/XMLHttpRequest/abort_event
event-xhr-error:API/XMLHttpRequest/error_event
event-xhr-load:API/XMLHttpRequest/load_event
event-xhr-loadend:API/XMLHttpRequest/loadend_event
event-xhr-loadstart:API/XMLHttpRequest/loadstart_event
event-xhr-progress:API/XMLHttpRequest/progress_event
event-xhr-timeout:API/XMLHttpRequest/timeout_event
	event-xhr-readystatechange:API/？/readystatechange_event

●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject

E.AbortError:~WEBIDL#aborterror
E.SyntaxError:~WEBIDL#syntaxerror
E.SecurityError:~WEBIDL#securityerror
E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TimeoutError:~WEBIDL#timeouterror
E.NetworkError:~WEBIDL#networkerror
E.TypeError:~WEBIDL#exceptiondef-typeerror
E.NotFoundError:~WEBIDL#notfounderror

USVString:~WEBIDL#idl-USVString
I.USVString:~WEBIDL#idl-USVString
ByteString:~WEBIDL#idl-ByteString
DOMString:~WEBIDL#idl-DOMString
undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
double:~WEBIDL#idl-double
sequence:~WEBIDL#idl-sequence
any:~WEBIDL#idl-any


I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.FormData:#formdata
I.FormDataEntryValue:#formdataentryvalue
I.ProgressEvent:#progressevent
I.ProgressEventInit:#progresseventinit
I.XMLHttpRequest:#xmlhttprequest
I.XMLHttpRequestEventTarget:#xmlhttprequesteventtarget
I.XMLHttpRequestResponseType:#xmlhttprequestresponsetype
I.XMLHttpRequestUpload:#xmlhttprequestupload
I.XMLHttpRequestBodyInit:~FETCH#typedefdef-xmlhttprequestbodyinit
	I.Window:~WINDOW#window → ~window
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLFormElement:~HEforms#htmlformelement


I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer


m.new XMLHttpRequest:#dom-xmlhttprequest
m.new FormData:#dom-formdata
	m.new ProgressEvent:#dom-progressevent-progressevent
mc.ProgressEvent:#dom-progressevent-progressevent

m.DONE:#dom-xmlhttprequest-done
m.HEADERS_RECEIVED:#dom-xmlhttprequest-headers_received
m.LOADING:#dom-xmlhttprequest-loading
m.OPENED:#dom-xmlhttprequest-opened
m.UNSENT:#dom-xmlhttprequest-unsent

m.onabort:#handler-xhr-onabort
m.onerror:#handler-xhr-onerror
m.onload:#handler-xhr-onload
m.onloadend:#handler-xhr-onloadend
m.onloadstart:#handler-xhr-onloadstart
m.onprogress:#handler-xhr-onprogress
m.onreadystatechange:#handler-xhr-onreadystatechange
m.ontimeout:#handler-xhr-ontimeout

m.abort:#dom-xmlhttprequest-abort
m.timeout:#dom-xmlhttprequest-timeout
m.type:~DOM4#dom-event-type
m.~type0:~FILEAPI#dfn-type
m.append:#dom-formdata-append
	#dom-formdata-append-blob
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.delete:#dom-formdata-delete
m.get:#dom-formdata-get
m.getAll:#dom-formdata-getall
m.getAllResponseHeaders:#dom-xmlhttprequest-getallresponseheaders
m.getResponseHeader:#dom-xmlhttprequest-getresponseheader
m.has:#dom-formdata-has
m.iterable:#dom-formdata-iterable
m.lengthComputable:#dom-progressevent-lengthcomputable
m.loaded:#dom-progressevent-loaded
m.open:#dom-xmlhttprequest-open
m.~open_async:#dom-xmlhttprequest-open-method-url-async-username-password
m.overrideMimeType:#dom-xmlhttprequest-overridemimetype
m.readyState:#dom-xmlhttprequest-readystate
m.response:#dom-xmlhttprequest-response
m.responseText:#dom-xmlhttprequest-responsetext
m.responseType:#dom-xmlhttprequest-responsetype
m.responseURL:#dom-xmlhttprequest-responseurl
m.responseXML:#dom-xmlhttprequest-responsexml
m.send:#dom-xmlhttprequest-send
m.set:#dom-formdata-set
	#dom-formdata-set-blob
m.setRequestHeader:#dom-xmlhttprequest-setrequestheader
m.status:#dom-xmlhttprequest-status
m.statusText:#dom-xmlhttprequest-statustext
m.total:#dom-progressevent-total
m.upload:#dom-xmlhttprequest-upload
m.withCredentials:#dom-xmlhttprequest-withcredentials

mb.lengthComputable:#dom-progresseventinit-lengthcomputable
mb.loaded:#dom-progresseventinit-loaded
mb.total:#dom-progresseventinit-total

	l.#dom-xmlhttprequestresponsetype
l.arraybuffer:#dom-xmlhttprequestresponsetype-arraybuffer
l.blob:#dom-xmlhttprequestresponsetype-blob
l.document:#dom-xmlhttprequestresponsetype-document
l.json:#dom-xmlhttprequestresponsetype-json
l.text:#dom-xmlhttprequestresponsetype-text

et.abort:#event-xhr-abort
et.progress:#event-xhr-progress
et.error:#event-xhr-error
et.load:#event-xhr-load
et.loadend:#event-xhr-loadend
et.loadstart:#event-xhr-loadstart
et.readystatechange:#event-xhr-readystatechange
et.timeout:#event-xhr-timeout

e.progress:~HEforms#the-progress-element

h.Content-Type:~HTTPsem#field.content-type
hm.GET:~HTTPsem#GET
hm.HEAD:~HTTPsem#HEAD

	●用語
xhr.~upload~obj:#upload-object
xhr.状態:#concept-xmlhttprequest-state
xhr.~send_~flag:#send-flag
xhr.制限時間:#timeout
xhr.非同一-生成元~向け資格証ありか:#cross-origin-credentials
xhr.要請~method:#request-method
xhr.要請~URL:#request-url
xhr.作者~要請~header~list:#author-request-headers
xhr.要請~本体:#request-body
xhr.同期的か:#synchronous-flag
xhr.~uploadは完了したか:#upload-complete-flag
xhr.~upload~listenerはあるか:#upload-listener-flag
xhr.時間切れか:#timed-out-flag
xhr.応答:#response
xhr.受信した~byte列:#received-bytes
xhr.応答~種別:#response-type
xhr.応答~obj:#response-object
xhr.~fetch制御器:#xmlhttprequest-fetch-controller
xhr.上書き~MIME型:#override-mime-type
最終-~MIME型を取得する:#final-mime-type
応答~MIME型を取得する:#response-mime-type
最終-符号化法を取得する:#final-charset
文書~応答を設定する:#document-response
~text応答を取得する:#text-response

進捗~eventを発火する:#concept-event-fire-progress

fD.~entry~list:#concept-formdata-entry-list

要請~error手続きを走らす:#request-error-steps
~errorを取扱う:#handle-errors
応答~本体の終端を取扱う:#handle-response-end-of-body


	＊:#legacy-uppercased-byte-less-than

	●用語（外部
i.応答の処理n:~FETCH#process-response
i.応答の本体を消費する処理n:~FETCH#process-response-end-of-body
i.要請の本体~chunk長さの処理n:~FETCH#process-request-body
i.要請の本体~終了~時の処理n:~FETCH#process-request-end-of-body
i.並列~queueを利用するか:~FETCH#fetch-useparallelqueue

~CORS予行~要請:~FETCH#cors-preflight-request

~fetchを中止する:~FETCH#fetch-controller-abort
~fetchを終了する:~FETCH#fetch-controller-terminate
~fetchする:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
本体と型を安全に抽出する:~FETCH#bodyinit-safely-extract
~header~listから~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
~method:~FETCH#concept-method
禁止~method:~FETCH#forbidden-method
禁止~要請~header:~FETCH#forbidden-request-header
~header名:~FETCH#header-name
~header値:~FETCH#header-value
hd.名前:~FETCH#concept-header-name
hd.値:~FETCH#concept-header-value
値を正規化する:~FETCH#concept-header-value-normalize
~header~listから値を取得する:~FETCH#concept-header-list-get
~header~listから長さを抽出する:~FETCH#header-list-extract-a-length
~header:~FETCH#concept-header
~header~list:~FETCH#concept-header-list
~headerを設定する:~FETCH#concept-header-list-set
~headerを結合する:~FETCH#concept-header-list-combine
~header~listを~sortして結合する:~FETCH#concept-header-list-sort-and-combine
~network~error:~FETCH#concept-network-error
~methodを正規化する:~FETCH#concept-method-normalize

bwT.本体:~FETCH#body-with-type-body
bwT.型:~FETCH#body-with-type-type

要請:~FETCH#concept-request
rq.~header~list:~FETCH#concept-request-header-list
rq.本体:~FETCH#concept-request-body
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag
rq.起動元~種別:~FETCH#request-initiator-type
rq.~client:~FETCH#concept-request-client
rq.安全でない要請か:~FETCH#unsafe-request-flag
rq.~CORS予行を利用するか:~FETCH#use-cors-preflight-flag
rq.済んだか:~FETCH#done-flag

応答:~FETCH#concept-response
rs.中止されたか:~FETCH#concept-response-aborted
rs.~URL:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.状態s~message:~FETCH#concept-response-status-message

~CORS~protocol:~FETCH#cors-protocol

bd.長さ:~FETCH#concept-body-total-bytes

資格証:~FETCH#credentials
本体を増分的に読取る:~FETCH#body-incrementally-read
計時を完結して報告する:~FETCH#finalize-and-report-timing
~fetch制御器:~FETCH#fetch-controller

~byte列:~INFRA#byte-sequence
byte.長さ:~INFRA#byte-sequence-length
~byte文字大小無視:~INFRA#byte-case-insensitive
~ASCII大小無視:~INFRA#ascii-case-insensitive
~JSON~byte列を~JS値に構文解析する:~INFRA#parse-json-bytes-to-a-javascript-value
~byte大文字~化する:~INFRA#byte-uppercase
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
小なり~algo:~INFRA#_less-than-algorithm
未満の~byte列:~INFRA#byte-less-than

~list:~INFRA#list
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
置換する:~INFRA#list-replace
~scalar値~文字列に変換する:~INFRA#javascript-string-convert

~event:~DOM4#concept-event
~event~listener:~DOM4#concept-event-listener
~eventを発火する:~DOM4#concept-event-fire
配送-:~DOM4#concept-event-dispatch
文書:~DOM4#concept-document
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document

doc.符号化法:~DOM4#concept-document-encoding
doc.内容~型:~DOM4#concept-document-content-type
doc.~URL:~DOM4#concept-document-url
doc.種別:~DOM4#concept-document-type
doc.生成元:~DOM4#concept-document-origin

~UTF-8:~ENCODING#utf-8
~UTF-8符号化-:~ENCODING#utf-8-encode
~UTF-8符号化する:~ENCODING#utf-8-encode
~Unicodeに復号する:~ENCODING#decode
~labelから符号化法を取得する:~ENCODING#concept-encoding-get

反復される値~pair群:~WEBIDL#dfn-value-pairs-to-iterate-over
新たな:~WEBIDLjs#new
~interface~obj:~WEBIDLjs#dfn-interface-object

~URL:~URL1#concept-url
url.~host:~URL1#concept-url-host
~URLを直列化する:~URL1#concept-url-serializer
~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password
資格証を含む:~URL1#include-credentials

	HTML
提出-~button:~HEforms#concept-submit-button

~entryを作成する:~HTMLforms#create-an-entry
fD.~entry:~HTMLforms#form-entry
fD.名:~HTMLforms#form-entry-name
fD.値:~HTMLforms#form-entry-value
~form所有者:~HTMLforms#form-owner

~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url

~task:~WAPI#concept-task
~task~source:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~event~handler:~WAPI#event-handlers
~event~handler ~event型:~WAPI#event-handler-event-type
静止する:~WAPI#pause

現在の大域~obj:~WAPI#current-global-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
	廃）enV.担当の文書:~WAPI#responsible-document

全部的に作動中:~HTMLds#fully-active

結付けられた文書:~WINDOW#concept-document-window
~window:~WINDOW#the-window-object

~entry~list:~HTMLforms#entry-list
~entry~listを構築する:~HTMLforms#constructing-the-form-data-set
並列的:~HTMLINFRA#in-parallel

	:~HTMLparsing#a-known-definite-encoding
	:~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding
	:~HTMLxml#xml-parser
	:~HTMLxml#xml-scripting-support-disabled


~MIME型:~MIMESNIFF#mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type
~byte列から~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type-from-bytes
~MIME型を~byte列に直列化する:~MIMESNIFF#serialize-a-mime-type-to-bytes
~parameter群:~MIMESNIFF#parameters
素片に直列化する:~HTMLdynamic#fragment-serializing-algorithm-steps

_acks1:#_acks1
_ipr1:#_ipr1

●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[DOM-PARSING]
    Travis Leithead. ＜DOM Parsing and Serialization＞. URL: https://w3c.github.io/DOM-Parsing/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[FILEAPI]
    Marijn Kruisselbrink. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MIMESNIFF]
    Gordon P. Hemsley. ＜MIME Sniffing Standard＞. Living Standard. URL: https://mimesniff.spec.whatwg.org/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBDRIVER-BIDI]
    James Graham; Alex Rudenko; Maksim Sadym. ＜WebDriver BiDi＞. URL: https://w3c.github.io/webdriver-bidi/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/
[XML-NAMES]
    Tim Bray; et al. ＜Namespaces in XML 1.0 (Third Edition)＞. 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.whatwg.org/">WHATWG</a>
による
<a href="~SPEC_URL">XMLHttpRequest Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/xhr">GitHub whatwg/xhr</a> (<a href="https://github.com/whatwg/xhr/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/xhr/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/xhr/commits
	<a href="https://xhr.spec.whatwg.org/commit-snapshots/4a6401c65333d504235fee794f63ed1aa40a3b41/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/xhrstandard">@xhrstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/xhr">web-platform-tests xhr/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/xhr">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>
<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgc3Ryb2tlLXdpZHRoPSIxMCIgZmlsbD0iI2ZmZiIvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgZD0iTTE3LDY2QzIxLDYzLDQzLDc2LDM3LDY4TTMzLDc1YTgsOCwwLDAsMTYsOE01MCw4NEM2OCw0OSw1Nyw5MCw2Myw3Nyw2Niw1OCw3NSw4Nyw3MSw2OSw2OCw2Miw3NCw2NSw3OCw2Nk02NSw2MkM1Nyw2NCw2NCw3MSw2Nyw2NE00Nyw2MEw0Myw2OSw0NCw2OSw1MSw2Nk01MCw1MkM0Nyw2MCw1Myw1NCw1Miw2MCw1MCw2OCw2Miw2MCw1Nyw2Miw1OCw1NCw2NSw2MCw1OSw1NCw0OCw0MiwyMCwyNSwyOSwzN00yOSw0MEMyMyw1MCwyNyw0NywyOSw0OE0zMywzN0MyOCw0MiwzNywzOCwzNSw0MiwzNCw0NCwzMCwzOCwzMiw0OCwzMSw1MCwzNiw1MiwyOCw1ME0zMiw1M0wyOCw1Mk0zMCw1M0MyOCw1NSwyNSw1NywzMCw2MSwzMiw2MiwzMiw2NSwzOCw2Miw0MCw2MSw0Myw2Myw0NCw1Nyw0NCw1Niw0OCw1Miw0NCw0OEw0NSw0NSw0MSw0Miw0MCw0Myw0MSw0NywzOSw1MCwzNSw1MU0zMiwzMUM0MywzMCw1MCwxNiw2NCwyM000MywzN0M1NCwyOCw0OSw1Niw2OSw0OCw4Miw0MCw3OCwyMSw2OCwyMEw2OCwyNkM3MiwyOSw3MiwyOSw3MiwzMyIvPgo8L3N2Zz4K"
></a>
	<hgroup>
<h1>XMLHttpRequest</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、
~client↔~server間で~dataを転送するための，
~client側の~script機能性を供する~APIを定義する。
◎
The XMLHttpRequest Standard defines an API that provides scripted client functionality for transferring data between a client and a server.
</p>
	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
`XMLHttpRequest$I ~objは、`~fetching$用の~APIである。
◎
The XMLHttpRequest object is an API for fetching resources.
</p>

<p>
`XMLHttpRequest$I という名前は歴史的なものであり、
【 “XML” の部分は】
その機能性と何ら関わりは無い。
◎
The name XMLHttpRequest is historical and has no bearing on its functionality.
</p>

<div class="example" id="example-xhr">

<p>
~network越しに~fetchされた~XML文書の~dataに対し何かを行う，単純な~code：
◎
Some simple code to do something with data from an XML document fetched over the network:
</p>

<pre class="lang-js">
function processData(%data) {
  /* <span class="comment">
~dataを~~処理する
◎
taking care of data
</span> */
}

function handler() {
  if(this.status == 200 &amp;&amp;
    this.responseXML != null &amp;&amp;
    this.responseXML.getElementById('test').textContent) {
    /* <span class="comment">
成功！
◎
success!
</span> */
    processData(this.responseXML.getElementById('test').textContent);
  } else {
    /* <span class="comment">
何らかの不具合が生じている
◎
something went wrong
</span> */
    …
  }
}

var %client = new XMLHttpRequest();
%client.onload = handler;
%client.open("GET", "unicorn.xml");
%client.send();
</pre>

<p>
単に~serverに~messageを残す：
◎
If you just want to log a message to the server:
</p>

<pre class="lang-js">
function log(%message) {
  var %client = new XMLHttpRequest();
  %client.open("POST", "/log");
  %client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
  %client.send(%message);
}
</pre>

<p>
あるいは、~serverにある文書の状態sを調べる：
◎
Or if you want to check the status of a document on the server:
</p>

<pre class="lang-js">
function fetchStatus(%address) {
  var %client = new XMLHttpRequest();
  %client.onload = function() {
    /* <span class="comment">
~network~errorが生じている場合、依拠-可能な結果は得られないであろう。
◎
in case of network errors this might not give reliable results
</span> */
    returnStatus(this.status);
  }
  %client.open("HEAD", %address);
  %client.send();
}
</pre>

</div>

		<section id="specification-history">
<h3 title="Specification history">1.1. 仕様の歴史</h3>

<p>
`XMLHttpRequest$I ~objは、当初は WHATWG による， HTML の（何年も前の、 Microsoft による実装に基づく）成果として定義された。
それは 2006 年には W3C に移管された。
`XMLHttpRequest$I に対する拡張（すなわち、進捗~event, 非同一-生成元（ cross-origin ）要請）は、 2011 年の終わりまでは別の草案（ XMLHttpRequest Level 2 ）の下で開発されていたが、その時点でこの 2 つの草案は `XMLHttpRequest$I に併合され，標準の観点から再び一つになった。
2012 年の終わりに，また WHATWG の下に移管されることとなった。
◎
The XMLHttpRequest object was initially defined as part of the WHATWG’s HTML effort. (Based on Microsoft’s implementation many years prior.) It moved to the W3C in 2006. Extensions (e.g., progress events and cross-origin requests) to XMLHttpRequest were developed in a separate draft (XMLHttpRequest Level 2) until end of 2011, at which point the two drafts were merged and XMLHttpRequest became a single entity again from a standards perspective. End of 2012 it moved back to the WHATWG.
</p>

<p>
現在の草案までに至る経緯は、
次に挙げるメーリングリストにて見られる
⇒＃
<a href="~w3cML/public-whatwg-archive/">whatwg@whatwg.org</a>,
<a href="~w3cML/public-webapps/">public-webapps@w3.org</a>,
<a href="~w3cML/public-webapi/">public-webapi@w3.org</a>,
<a href="~w3cML/public-appformats/">public-appformats@w3.org</a>
◎
Discussion that led to the current draft can be found in the following mailing list archives:
• whatwg@whatwg.org
• public-webapps@w3.org
• public-webapi@w3.org
• public-appformats@w3.org
</p>

		</section>
	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、次に挙げる仕様による各種用語を利用する
⇒
`DOM$r
`DOM-PARSING$r
`ENCODING$r
`FETCH$r
`FILEAPI$r
`HTML$r
`URL$r
`WEBIDL$r
`XML$r
`XML-NAMES$r
◎
This specification uses terminology from DOM, DOM Parsing and Serialization, Encoding, Fetch, File API, HTML, URL, Web IDL, and XML.
◎
[DOM] [DOM-PARSING] [ENCODING] [FETCH] [FILEAPI] [HTML] [URL] [WEBIDL] [XML] [XML-NAMES]
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="interface-xmlhttprequest">
<h2 title="Interface XMLHttpRequest">3. ~interface `XMLHttpRequest^I</h2>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestEventTarget@I : `EventTarget$I {
  // <span class="comment">`~event~handler＠#event-handlers$</span>
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `ontimeout$m;
  attribute `EventHandler$I `onloadend$m;
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestUpload@I : `XMLHttpRequestEventTarget$I {
};

enum `XMLHttpRequestResponseType@I {
  <dfn id="#dom-xmlhttprequestresponsetype">""</dfn>,
  `arraybuffer@l,
  `blob@l,
  `document@l,
  `json@l,
  `text@l
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequest@I : `XMLHttpRequestEventTarget$I {
  `XMLHttpRequest$mc();

  // <span class="comment">`~event~handler＠#event-handlers$</span>
  attribute `EventHandler$I `onreadystatechange$m;

  // <span class="comment">状態</span>
  const `unsigned short$ `UNSENT$m = 0;
  const `unsigned short$ `OPENED$m = 1;
  const `unsigned short$ `HEADERS_RECEIVED$m = 2;
  const `unsigned short$ `LOADING$m = 3;
  const `unsigned short$ `DONE$m = 4;
  readonly attribute `unsigned short$ `readyState$m;

  // <span class="comment">要請</span>
  `undefined$ `open$m(`ByteString$ %method, `USVString$ %url);
  `undefined$ `~open_async$m(
      `ByteString$ %method,
      `USVString$ %url,
      `boolean$ %async,
      optional `USVString$? %username = null,
      optional `USVString$? %password = null
  );
  `undefined$ `setRequestHeader$m(`ByteString$ %name, `ByteString$ %value);
           attribute `unsigned long$ `timeout$m;
           attribute `boolean$ `withCredentials$m;
  [`SameObject$] readonly attribute `XMLHttpRequestUpload$I `upload$m;
  `undefined$ `send$m(optional (`Document$I or `XMLHttpRequestBodyInit$I)? %body = null);
  `undefined$ `abort$m();

  // <span class="comment">応答</span>
  readonly attribute `USVString$ `responseURL$m;
  readonly attribute `unsigned short$ `status$m;
  readonly attribute `ByteString$ `statusText$m;
  `ByteString$? `getResponseHeader$m(`ByteString$ %name);
  `ByteString$ `getAllResponseHeaders$m();
  `undefined$ `overrideMimeType$m(`DOMString$ %mime);
           attribute `XMLHttpRequestResponseType$I `responseType$m;
  readonly attribute `any$ `response$m;
  readonly attribute `USVString$ `responseText$m;
  [`Exposed$=Window] readonly attribute `Document$I? `responseXML$m;
};
</pre>

<p>
各 `XMLHttpRequest$I ~objには、次に挙げるものが結付けられる：
◎
An XMLHttpRequest object has an associated:
</p>
<dl class="def-list">
	<dt>
`~upload~obj@xhr
◎
upload object
</dt>
	<dd>
`XMLHttpRequestUpload$I ~obj。
◎
An XMLHttpRequestUpload object.
</dd>

	<dt>
`状態@xhr
◎
state
</dt>
	<dd>
次に挙げるいずれか
— 初期~時は `未送信^i とする
⇒＃
`未送信^i ／
`~openした^i ／
`全~headerを受信した^i ／
`読込n中^i ／
`済み^i
◎
One of unsent, opened, headers received, loading, and done; initially unsent.
</dd>

	<dt>
`~send_~flag@xhr
◎
send() flag
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`制限時間@xhr
◎
timeout
</dt>
	<dd>
無符号~整数【~milli秒数】
— 初期~時は 0 とする。
◎
An unsigned integer, initially 0.
</dd>

	<dt>
`非同一-生成元~向け資格証ありか@xhr
◎
cross-origin credentials
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A boolean, initially false.
</dd>

	<dt>
`要請~method@xhr
◎
request method
</dt>
	<dd>
`~method$
◎
A method.
</dd>

	<dt>
`要請~URL@xhr
◎
request URL
</dt>
	<dd>
`~URL$。
◎
A URL.
</dd>

	<dt>
`作者~要請~header~list@xhr
◎
author request headers
</dt>
	<dd>
`~header~list$
— 初期~時は空とする。
◎
A header list, initially empty.
</dd>

	<dt>
`要請~本体@xhr
◎
request body
</dt>
	<dd>
初期~時は ~NULL とする。
◎
Initially null.
</dd>

	<dt>
`同期的か@xhr
◎
synchronous flag
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`~uploadは完了したか@xhr
◎
upload complete flag
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`~upload~listenerはあるか@xhr
◎
upload listener flag
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`時間切れか@xhr
◎
timed out flag
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`応答@xhr
◎
response
</dt>
	<dd>
`応答$
— 初期~時は`~network~error$とする。
◎
A response, initially a network error.
</dd>

	<dt>
`受信した~byte列@xhr
◎
received bytes
</dt>
	<dd>
`~byte列$
— 初期~時は空~byte列とする。
◎
A byte sequence, initially the empty byte sequence.
</dd>

	<dt>
`応答~種別@xhr
◎
response type
</dt>
	<dd>
次に挙げるいずれか
— 初期~時は空~文字列とする
⇒＃
空~文字列 ／
`arraybuffer^l ／
`blob^l ／
`document^l ／
`json^l ／
`text^l
◎
One of the empty string, "arraybuffer", "blob", "document", "json", and "text"; initially the empty string.
</dd>

	<dt>
`応答~obj@xhr
◎
response object
</dt>
	<dd>
次に挙げるいずれか
— 初期~時は ~NULL とする
⇒＃
~obj【これは、`応答$xhrの本体~dataを表現する】／
`失敗^i ／
~NULL
◎
An object, failure, or null, initially null.
</dd>

	<dt>
`~fetch制御器@xhr
◎
fetch controller
</dt>
	<dd>
`~fetch制御器$
— 初期~時は新たな`~fetch制御器$とする。
◎
A fetch controller, initially a new fetch controller.＼
</dd>
	<dd class="note">注記：
`send()$m ~methodは，
これを有用な`~fetch制御器$に設定するが、
単純にするため，これは常に ある`~fetch制御器$を保持する。
◎
The send() method sets it to a useful fetch controller, but for simplicity it always holds a fetch controller.
</dd>

	<dt>
`上書き~MIME型@xhr
◎
override MIME type
</dt>
	<dd>
`~MIME型$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
A MIME type or null, initially null.＼
</dd>
	<dd class="note">注記：
`overrideMimeType()$m を呼出したときに，非 ~NULL にされ得る。
◎
Can get a value when overrideMimeType() is invoked.
</dd>
</dl>

		<section id="constructors">
<h3 title="Constructors">3.1. 構築子</h3>

<dl class="domintro">
	<dt>%client = `new XMLHttpRequest()$m</dt>
	<dd>
新たな `XMLHttpRequest$I ~objを返す。
◎
Returns a new XMLHttpRequest object.
</dd>
</dl>

<div class="algo">
`new XMLHttpRequest()@m
構築子~手続きは
⇒
コレの`~upload~obj$xhr ~SET `新たな$ `XMLHttpRequestUpload$I ~obj
◎
The new XMLHttpRequest() constructor steps are:
• Set this’s upload object to a new XMLHttpRequestUpload object.
</div>

		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">3.2. ~garbage収集</h3>

<p>
`XMLHttpRequest$I ~objは、
~AND↓ を満たしている間は，~garbage収集しないモノトスル：
◎
An XMLHttpRequest object must not be garbage collected if＼
</p>
<ul>
	<li>
<p>
~OR↓：
</p>
		<ul>
			<li>
［
`状態$xhr ~EQ `~openした^i
］~AND［
`~send_~flag$xhr ~EQ ~T
］
</li>
			<li>
`状態$xhr ~IN { `全~headerを受信した^i, `読込n中^i }
</li>
		</ul>
◎
its state is either opened with the send() flag set, headers received, or loading,＼
</li>
	<li>
次に挙げるいずれかの型の~event用に`~event~listener$が登録されている
⇒
`readystatechange$et,
`progress$et,
`abort$et,
`error$et,
`load$et,
`timeout$et,
`loadend$et
◎
and it has one or more event listeners registered whose type is one of readystatechange, progress, abort, error, load, timeout, and loadend.
</li>
</ul>

<p>
`XMLHttpRequest$I ~obj %XHR が，その接続がまだ開いているにも関わらず~garbage収集された場合、
~UAは，次を遂行するモノトスル
⇒
`~fetchを終了する$( %XHR の`~fetch制御器$xhr )
◎
If an XMLHttpRequest object is garbage collected while its connection is still open, the user agent must terminate the XMLHttpRequest object’s fetch controller.
</p>

		</section>
		<section id="event-handlers">
<h3 title="Event handlers">3.3. ~event~handler</h3>

<p>
`XMLHttpRequestEventTarget$I を継承する~interfaceを実装する~objは、次の`~event~handler$（およびそれらに対応する`~event~handler ~event型$）を属性として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on objects implementing an interface that inherits from XMLHttpRequestEventTarget as attributes:
</p>

<table><thead>
<tr><th>`~event~handler$
◎
event handler
<th>`~event~handler ~event型$
◎
event handler event type
<tbody>

<tr><td>`onloadstart@m
<td>`loadstart$et

<tr><td>`onprogress@m
<td>`progress$et

<tr><td>`onabort@m
<td>`abort$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onload@m
<td>`load$et

<tr><td>`ontimeout@m
<td>`timeout$et

<tr><td>`onloadend@m
<td>`loadend$et
</table>

<p>
`XMLHttpRequest$I ~objにおいては、次の`~event~handler$（および対応する
`~event~handler ~event型$）も属性として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported as attribute solely by the XMLHttpRequest object:
</p>

<table><thead>
<tr><th>
`~event~handler$
◎
event handler
<th>
`~event~handler ~event型$
◎
event handler event type
<tbody>

<tr><td>`onreadystatechange@m
<td>`readystatechange$et
</table>

		</section>
		<section id="states">
<h3 title="States">3.4. 状態</h3>

<dl class="domintro">
	<dt>%client . `readyState$m</dt>
	<dd>
`状態$xhrを返す。
◎
Returns client’s state.
</dd>
</dl>

<div class="algo">
<p>
`readyState@m
取得子~手続きは
⇒
~RET コレの`状態$xhrが次の表tの 1 列目に挙げる どれに等しいかに応じて，同じ行の 2 列目に示される値：
◎
The readyState getter steps are to return the value from the table below in the cell of the second column, from the row where the value in the cell in the first column is this’s state:
</p>

<table><thead>
<tr><th>`状態$xhr
<th>値（ 数量-値 ）
<th>記述
<tbody>

<tr><td>`未送信^i
<td>`UNSENT@m （ 0 ）
<td>
~objは構築-済みである。
◎
The object has been constructed.

<tr><td>`~openした^i
<td>`OPENED@m （ 1 ）
<td>
`open()$m ~methodは成功裡に呼出された。
この状態~下では、
`setRequestHeader$m を利用して要請~headerを設定でき，
`send$m ~methodを利用して~fetchを起動できる。
◎
The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the fetch can be initiated using the send() method.

<tr><td>`全~headerを受信した^i
<td>`HEADERS_RECEIVED@m （ 2 ）
<td>
すべての~redirect（もしあれば）は追従-済みであり，かつ
応答のすべての~headerは受信-済みである。
◎
All redirects (if any) have been followed and all headers of a response have been received.

<tr><td>`読込n中^i
<td>`LOADING@m （ 3 ）
<td>
応答~本体を受信-中にある。
◎
The response body is being received.

<tr><td>`済み^i
<td>`DONE@m （ 4 ）
<td>
~data転送が完了しているか, または転送~中に何らかの不具合が生じた（例えば，際限のない~redirect）。
◎
The data transfer has been completed or something went wrong during the transfer (e.g., infinite redirects).
</table>
</div>

		</section>
		<section id="request">
<h3 title="Request">3.5. 要請</h3>

<p class="note" id="event-listeners-and-preflight">注記：
`XMLHttpRequestUpload$I ~obj上に 1 個~以上の~event~listenerを登録すると，`~CORS予行~要請$が為されることになる。
（~event~listenerが登録されると`~upload~listenerはあるか$xhrは ~T になり，それにより`~CORS予行を利用するか$rqも ~T になるので。）
◎
Registering one or more event listeners on an XMLHttpRequestUpload object will result in a CORS-preflight request. (That is because registering an event listener causes the upload listener flag to be set, which in turn causes the use-CORS-preflight flag to be set.)
</p>

			<section id="the-open()-method">
<h4 title="The open() method">3.5.1. `open()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `open$m(%method, %url [, %async = true [, %username = null [, %password = null]]])</dt>
	<dd>
［
`要請~method$xhr,
`要請~URL$xhr,
`同期的か$xhr
］を設定する。
◎
Sets the request method, request URL, and synchronous flag.
</dd>
	<dd>
次のいずれかに該当する場合、
`SyntaxError$E 例外が投出される
⇒＃
%method は妥当な~methodでない／
%url を構文解析できない
◎
Throws a "SyntaxError" DOMException if either method is not a valid method or url cannot be parsed.
</dd>
	<dd>
次に該当する場合、
`SecurityError$E 例外が投出される
⇒
%method は次のいずれかに文字大小無視で合致する
⇒
`CONNECT^h ／ `TRACE^h ／ `TRACK^h
◎
Throws a "SecurityError" DOMException if method is a case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.
</dd>
	<dd>
<p>
~AND↓ が満たされている下では、
`InvalidAccessError$E 例外が投出される：
</p>
		<ul>
			<li>
%async ~EQ ~F
</li>
			<li>
`現在の大域~obj$は`~window$である
</li>
			<li>
［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空~文字列
］
</li>
		</ul>
◎
Throws an "InvalidAccessError" DOMException if async is false, the current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
</dd>
</dl>

<p class="critical" id="sync-warning">
~worker以外での同期的 `XMLHttpRequest$I は、末端利用者をひどく待たせることになりかねないので， Web ~platformから除去されつつある過程にある（何年もかかるであろう）。
開発者は、［
`現在の大域~obj$は`~window$である
］場合には， %async 引数に ~F を渡してはナラナイ。
~UA には、開発者~用~toolにおいて，その種の用法に対し警告することが強く奨励される
— 
それが生じたときに，
`InvalidAccessError$E 例外を投出するように、試験的に実装してもよい。
◎
Synchronous XMLHttpRequest outside of workers is in the process of being removed from the web platform as it has detrimental effects to the end user’s experience. (This is a long process that takes many years.) Developers must not pass false for the async argument when the current global object is a Window object. User agents are strongly encouraged to warn about such usage in developer tools and may experiment with throwing an "InvalidAccessError" DOMException when it occurs.
</p>

<div class="algo">
<p>
`open(method, url)@m
／
`~open_async(method, url, async, username, password)@m
~method手続きは：
◎
The open(method, url) and open(method, url, async, username, password) method steps are:
</p>
<ol>
	<li>
~IF［
コレに`関連な大域~obj$は`~window$であって, それに`結付けられた文書$は`全部的に作動中$ではない
］
⇒
~THROW `InvalidStateError$E
◎
If this’s relevant global object is a Window object and its associated Document is not fully active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%method は`~method$でない
］
⇒
~THROW `SyntaxError$E
◎
If method is not a method, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%method は`禁止~method$である
］
⇒
~THROW `SecurityError$E
◎
If method is a forbidden method, then throw a "SecurityError" DOMException.
</li>
	<li>
%method ~SET `~methodを正規化する$( %method )
◎
Normalize method.
</li>
	<li>
%構文解析した~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( %url, コレに`関連な設定群~obj$ )
◎
Let parsedURL be the result of encoding-parsing a URL url, relative to this’s relevant settings object.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
<p>
~IF［
%async ~EQ ε
］
⇒
( %async, %username, %password ) ~SET ( true, ~NULL, ~NULL )
◎
If the async argument is omitted, set async to true, and set username and password to null.
</p>

<p class="note">注記：
あいにく，旧来の内容と~~互換性を得るため、 %async 引数に `undefined^c が渡された場合と省略された場合とを，同じに扱うわけにはいかない。
◎
Unfortunately legacy content prevents treating the async argument being undefined identical from it being omitted.
</p>
	</li>
	<li>
<p>
~IF［
%構文解析した~URL の`~host$url ~NEQ ~NULL
］：
◎
If parsedURL’s host is non-null, then: 
</p>
		<ol>
			<li>
~IF［
%username ~NEQ ~NULL
］
⇒
`~URLの~usernameを設定する$( %構文解析した~URL, %username )
◎
If the username argument is not null, set the username given parsedURL and username.
</li>
			<li>
~IF［
%password ~NEQ ~NULL
］
⇒
`~URLの~passwordを設定する$( %構文解析した~URL, %password )
◎
If the password argument is not null, set the password given parsedURL and password.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
</p>
		<ul>
			<li>
%async ~EQ ~F
</li>
			<li>
`現在の大域~obj$は`~window$である
</li>
			<li>
［
コレの`制限時間$xhr ~NEQ 0
］~OR［
コレの`応答~種別$xhr ~NEQ 空~文字列
］
</li>
		</ul>
<p>
…ならば
⇒
~THROW `InvalidAccessError$E
</p>

◎
If async is false, the current global object is a Window object, and either this’s timeout is not 0 or this’s response type is not the empty string, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
<p>
`~fetchを終了する$( コレの`~fetch制御器$xhr )
◎
Terminate this’s fetch controller.
</p>

<p class="note">注記：
この時点から，`~fetching$は進行中になり得るようになる。
◎
A fetch can be ongoing at this point.
</p>
	</li>
	<li>
<p>
コレの
⇒＃
`~send_~flag$xhr ~SET ~F,
`~upload~listenerはあるか$xhr ~SET ~F,
`要請~method$xhr ~SET %method,
`要請~URL$xhr ~SET %構文解析した~URL,
`同期的か$xhr ~SET ~IS［ %async ~EQ ~F ］,
`応答$xhr ~SET `~network~error$,
`受信した~byte列$xhr ~SET 空~byte列,
`応答~obj$xhr ~SET ~NULL
◎
Set variables associated with the object as follows:
• Unset this’s send() flag.
• Unset this’s upload listener flag.
• Set this’s request method to method.
• Set this’s request URL to parsedURL.
• Set this’s synchronous flag if async is false; otherwise unset this’s synchronous flag.
• Empty this’s author request headers.
• Set this’s response to a network error.
• Set this’s received bytes to the empty byte sequence.
• Set this’s response object to null.
</p>

<p class="note">注記：
`上書き~MIME型$xhrは、ここでは上書きされない
— `open()^m ~methodより前に `overrideMimeType()$m ~methodが呼出されることもあるので。
◎
Override MIME type is not overridden here as the overrideMimeType() method can be invoked before the open() method.
</p>
	</li>
	<li>
コレの`作者~要請~header~list$xhrを空にする
◎
↑</li>
	<li>
<p>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］：
◎
If this’s state is not opened, then:
</p>
		<ol>
			<li>
コレの`状態$xhr ~SET `~openした^i
◎
Set this’s state to opened.
</li>
			<li>
`~eventを発火する$( コレ, `readystatechange$et )
◎
Fire an event named readystatechange at this.
</li>
		</ol>
	</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there are two open() methods defined is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

			</section>
			<section id="the-setrequestheader()-method">
<h4 title="The setRequestHeader() method">3.5.2. `setRequestHeader()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `setRequestHeader(name, value)$m</dt>
	<dd>
<p>
%name を名前に伴う既存の要請~headerに %value を付加する
— 無い場合、
新たなそれを追加する。
◎
Appends a value to an existing request header or adds a new request header.
</dd>
	<dd>
~OR↓ が満たされる場合、
`InvalidStateError$E 例外が投出される
⇒＃
`状態$xhr ~NEQ `~openした^i ／
`~send_~flag$xhr ~EQ ~T
◎
Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
</dd>
	<dd>
~OR↓ が満たされる場合、
`SyntaxError$E 例外が投出される
⇒＃
%name は~header名でない／
%value は~header値でない
◎
Throws a "SyntaxError" DOMException if name is not a header name or if value is not a header value.
</dd>
</dl>

<div class="algo">
<p>
`setRequestHeader(name, value)@m
~method手続きは：
◎
The setRequestHeader(name, value) method must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~send_~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%value ~SET `値を正規化する$( %value )
◎
Normalize value.
</li>
	<li>
<p>
~IF［
%name は`~header名$でない
］~OR［
%value は`~header値$でない
］
⇒
~THROW `SyntaxError$E
◎
If name is not a header name or value is not a header value, then throw a "SyntaxError" DOMException.
</p>

<p class="note">注記：
空~byte列は空な`~header値$を表現する。
◎
An empty byte sequence represents an empty header value.
</p>
	</li>
	<li>
~IF［
( %name, %value ) は`禁止~要請~header$を成す
］
⇒
~RET
◎
If (name, value) is a forbidden request-header, then return.
</li>
	<li>
コレの`作者~要請~header~list$xhr内で`~headerを結合する$(
( %name, %value )
)
◎
Combine (name, value) in this’s author request headers.
</li>
</ol>
</div>

<div class="example" id="example-setting-header-twice">

<p>
同じ~headerを重ねて設定した場合に何が起こるかデモるための，単純な~code：
◎
Some simple code demonstrating what happens when setting the same header twice:
◎
// The following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open('GET', 'demo.cgi');
%client.setRequestHeader('X-Test', 'one');
%client.setRequestHeader('X-Test', 'two');
%client.send();
</pre>

<p>
この~scriptによる結果、次の~headerが送信される：
◎
// …results in the following header being sent:
</p>

<pre class="lang-http">
X-Test: one, two
</pre>
</div>

			</section>
			<section id="the-timeout-attribute">
<h4 title="The timeout getter and setter">3.5.3. `timeout^m 取得子／設定子</h4>

<dl class="domintro">
	<dt>%client . `timeout$m</dt>
	<dd>
時間を~milli秒数で設定できる。
0 でない値に設定された場合、所与の時間が経過した時点で，`~fetching$は終了させられる。
その時点で要請がまだ完了していない場合、コレの`同期的か$xhrに応じて［
~F ならば `timeout$et ~eventが`配送-$される／
~T ならば `TimeoutError$E 例外が投出される
］ことになる（ `send()$m ~methodに対して）。
◎
Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and this’s synchronous flag is unset, a timeout event will then be dispatched, or a "TimeoutError" DOMException will be thrown otherwise (for the send() method).
</dd>
	<dd>
設定子は、
次が満たされている下では，
`InvalidAccessError$E 例外を投出する
⇒
［
`同期的か$xhr ~EQ ~T
］~AND［
`現在の大域~obj$は`~window$である
］
◎
When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and the current global object is a Window object.
</dd>
</dl>

<div class="algo">
`timeout@m
取得子~手続きは
⇒
~RET コレの`制限時間$xhr
◎
The timeout getter steps are to return this’s timeout.
</div>

<div class="algo">
<p>
`timeout$m 設定子~手続きは：
◎
The timeout setter steps are:
</p>
<ol>
	<li>
~IF［
`現在の大域~obj$は`~window$である
］~AND［
コレの`同期的か$xhr ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If the current global object is a Window object and this’s synchronous flag is set, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
コレの`制限時間$xhr ~SET 所与の値
◎
Set this’s timeout to the given value.
</li>
</ol>

<p class="note">注記：
これにより，`~fetching$が進捗~中にある間でも、
`timeout$m 属性を設定-可能になる。
設定しても、測定する~~起点（`~fetching$の開始）が改められることはない。
◎
This implies that the timeout attribute can be set while fetching is in progress. If that occurs it will still be measured relative to the start of fetching.
</p>
</div>

			</section>
			<section id="the-withcredentials-attribute">
<h4 title="The withCredentials getter and setter">3.5.4. `withCredentials^m 取得子／設定子</h4>

<dl class="domintro">
	<dt>%client . `withCredentials$m</dt>
	<dd>
`資格証$が非同一-生成元~要請に含められることになるときは ~T。
非同一-生成元~要請から除外され，その応答における~cookieは無視されることになるときは ~F。
初期~時は ~F 。
◎
True when credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
</dd>
	<dd>
設定子は、
~OR↓ が満たされる下では，
`InvalidStateError$E 例外を投出する
⇒＃
`状態$xhr ~NIN { `未送信^i, `~openした^i } ／
`~send_~flag$xhr ~EQ ~T
◎
When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.
</dd>
</dl>

<div class="algo">
`withCredentials@m
取得子~手続きは
⇒
~RET コレの`非同一-生成元~向け資格証ありか$xhr
◎
The withCredentials getter steps are to return this’s cross-origin credentials.
</div>

<div class="algo">
<p>
`withCredentials$m 設定子~手続きは：
◎
The withCredentials setter steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~NIN
{ `未送信^i, `~openした^i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not unsent or opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~send_~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`非同一-生成元~向け資格証ありか$xhr ~SET 所与の値
◎
Set this’s cross-origin credentials to the given value.
</li>
</ol>
</div>

			</section>
			<section id="the-upload-attribute">
<h4 title="The upload getter">3.5.5. `upload^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `upload$m</dt>
	<dd>
結付けられた `XMLHttpRequestUpload$I ~objを返す。
これを利用すれば、~serverへ向けて~dataが転送されるときに，伝送~情報を集めることができる。
◎
Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server.
</dd>
</dl>

<div class="algo">
`upload@m
取得子~手続きは
⇒
~RET コレの`~upload~obj$xhr
◎
The upload getter steps are to return this’s upload object.
</div>

			</section>
			<section id="the-send()-method">
<h4 title="The send() method">3.5.6. `send()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `send$m([%body = null])</dt>
	<dd>
要請を起動させる。
%body 引数は、`要請~本体$xhrを供する（もしあれば）。
`要請~method$xhrが `GET$hm や `HEAD$hm の場合、この引数は無視される。
◎
Initiates the request. The body argument provides the request body, if any, and is ignored if the request method is GET or HEAD.
</dd>
	<dd>
~OR↓ が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒＃
`状態$xhr ~NEQ `~openした^i ／
`~send_~flag$xhr ~EQ ~T
◎
Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
</dd>
</dl>

<div class="algo">
<p>
`send(body)@m
~method手続きは：
◎
The send(body) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~send_~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`要請~method$xhr ~IN
{ `GET$hm, `HEAD$hm }
］
⇒
%body ~SET ~NULL
◎
If this’s request method is `GET` or `HEAD`, then set body to null.
</li>
	<li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is not null, then:
</p>
		<ol>
			<li>
%抽出された内容~型 ~LET ~NULL
◎
Let extractedContentType be null.
</li>
			<li>
~IF［
%body は `Document$I である
］
⇒
コレの`要請~本体$xhr ~SET `~UTF-8符号化する$( `~scalar値~文字列に変換する$( `素片に直列化する$( %body【, ~F？】 ) ) )
◎
If body is a Document, then set this’s request body to body, serialized, converted, and UTF-8 encoded.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%本体と型 ~LET `本体と型を安全に抽出する$( %body )
◎
Let bodyWithType be the result of safely extracting body.
</li>
					<li>
コレの`要請~本体$xhr ~SET %本体と型 の`本体$bwT
◎
Set this’s request body to bodyWithType’s body.
</li>
					<li>
%抽出された内容~型 ~SET %本体と型 の`型$bwT
◎
Set extractedContentType to bodyWithType’s type.
</li>
				</ol>
			</li>
			<li>
%元の作者~内容~型 ~LET `~header~listから値を取得する$( コレの`作者~要請~header~list$xhr, `Content-Type^h )
◎
Let originalAuthorContentType be the result of getting `Content-Type` from this’s author request headers.
</li>
			<li>
<p>
~IF［
%元の作者~内容~型 ~NEQ ~NULL
］：
◎
If originalAuthorContentType is non-null, then:
</p>
				<ol>
					<li>
<p>
~IF［
%body は［
`Document$I ／ `USVString$I
］である
］：
◎
If body is a Document or a USVString, then:
</p>
						<ol>
							<li>
%内容~型~record ~LET `~byte列から~MIME型を構文解析する$( %元の作者~内容~型 の`値$hd )
◎
Let contentTypeRecord be the result of parsing originalAuthorContentType.
</li>
							<li>
<p>
~IF［
%内容~型~record ~NEQ 失敗
］：
◎
If contentTypeRecord is not failure,＼
</p>
								<ol>
									<li>
%~parameter群 ~LET %内容~型~record の`~parameter群$
◎
↓</li>
									<li>
<p>
~IF［
%~parameter群[ `charset^l ] ~NEQ ε
］~AND［
%~parameter群[ `charset^l ] は`~ASCII大小無視$で `UTF-8^l に合致しない
］：
◎
contentTypeRecord’s parameters["charset"] exists, and parameters["charset"] is not an ASCII case-insensitive match for "UTF-8", then:
</p>
										<ol>
											<li>
%~parameter群[ `charset^l ] ~SET `UTF-8^l
◎
Set contentTypeRecord’s parameters["charset"] to "UTF-8".
</li>
											<li>
`作者~要請~header~list$xhr内で`~headerを設定する$(
( `Content-Type^h, `~MIME型を~byte列に直列化する$( %内容~型~record ) )
)
◎
Let newContentTypeSerialized be the result of serializing contentTypeRecord.
◎
Set (`Content-Type`, newContentTypeSerialized) in this’s author request headers.
</li>
										</ol>
									</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
◎
Otherwise:
</p>
				<ol>
					<li>
%内容~型 ~LET %body に応じて
⇒＃
`~HTML文書$であるならば `text/html;charset=UTF-8^bl ／
`~XML文書$であるならば `application/xml;charset=UTF-8^bl ／
~ELSE_ %抽出された内容~型
◎
If body is an HTML document, then set (`Content-Type`, `text/html;charset=UTF-8`) in this’s author request headers.
◎
Otherwise, if body is an XML document, set (`Content-Type`, `application/xml;charset=UTF-8`) in this’s author request headers.
◎
Otherwise, if extractedContentType is not null, set (`Content-Type`, extractedContentType) in this’s author request headers.
</li>
					<li>
~IF［
%内容~型 ~NEQ ~NULL
］
⇒
コレの`作者~要請~header~list$xhr内で`~headerを設定する$(
( `Content-Type^h, %内容~型 )
)
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
コレの`~upload~obj$xhrに登録されている~event~listenerは在る
］
⇒
コレの`~upload~listenerはあるか$xhr ~SET ~T
◎
If one or more event listeners are registered on this’s upload object, then set this’s upload listener flag.
</li>
	<li>
<p>
%要請 ~LET 次に従って初期化された新たな`要請$：
◎
Let req be a new request, initialized as follows:
</p>
		<ul>
			<li>
`~method$rq~SET コレの`要請~method$xhr
◎
method
• This’s request method.
</li>
			<li>
`~URL$rq ~SET コレの`要請~URL$xhr
◎
URL
• This’s request URL.
</li>
			<li>
`~header~list$rq ~SET コレの`作者~要請~header~list$xhr
◎
header list
• This’s author request headers.
</li>
			<li>
`安全でない要請か$rq ~SET ~T
◎
unsafe-request flag
• Set.
</li>
			<li>
`本体$rq ~SET コレの`要請~本体$xhr
◎
body
• This’s request body.
</li>
			<li>
`~client$rq ~SET コレに`関連な設定群~obj$
◎
client
• This’s relevant settings object.
</li>
			<li>
`~mode$rq ~SET `cors^l
◎
mode
• "cors".
</li>
			<li>
`~CORS予行を利用するか$rq ~SET コレの`~upload~listenerはあるか$xhr
◎
use-CORS-preflight flag
• Set if this’s upload listener flag is set.
</li>
			<li>
`資格証~mode$rq ~SET コレの`非同一-生成元~向け資格証ありか$xhrに応じて
⇒＃
~T ならば `include^l ／
~F ならば `same-origin^l
◎
credentials mode
• If this’s cross-origin credentials is true, then "include"; otherwise "same-origin".
</li>
			<li>
`~URL資格証を利用するか$rq ~SET ~IS［
コレの`要請~URL$xhrは`資格証を含む$
］
◎
use-URL-credentials flag
• Set if this’s request URL includes credentials.
</li>
			<li>
`起動元~種別$rq ~SET `xmlhttprequest^l
◎
initiator type
• "xmlhttprequest".
</li>
		</ul>
	</li>
	<li>
コレの`~uploadは完了したか$xhr ~SET ~IS［
%要請 の`本体$rq ~EQ ~NULL
］
◎
Unset this’s upload complete flag.
◎
Unset this’s timed out flag.
◎
If req’s body is null, then set this’s upload complete flag.
</li>
	<li>
コレの`時間切れか$xhr ~SET ~F
◎
↑</li>
	<li>
コレの`~send_~flag$xhr ~SET ~T
◎
Set this’s send() flag.
</li>
	<li>
<p>
~IF［
コレの`同期的か$xhr ~EQ ~F
］：
◎
If this’s synchronous flag is unset, then:
</p>
		<ol>
			<li>
`進捗~eventを発火する$( コレ, `loadstart$et, 0, 0 )
◎
Fire a progress event named loadstart at this with 0 and 0.
</li>
			<li>
%伝送-済み要請~本体 ~LET 0
◎
Let requestBodyTransmitted be 0.
</li>
			<li>
%要請~本体~長さ ~LET 

%要請 の`本体$rq ~NEQ ~NULL ならば %要請 の`本体$rqの`長さ$bd／
~ELSE_ 0
◎
Let requestBodyLength be req’s body’s length, if req’s body is non-null; otherwise 0.
</li>
			<li>
~Assert：
%要請~本体~長さ は整数である。
◎
Assert: requestBodyLength is an integer.
</li>
			<li>
~IF［
コレの`~uploadは完了したか$xhr ~EQ ~F
］~AND［
コレの`~upload~listenerはあるか$xhr ~EQ ~T
］
⇒
`進捗~eventを発火する$( コレの`~upload~obj$xhr, `loadstart$et, %伝送-済み要請~本体, %要請~本体~長さ )
◎
If this’s upload complete flag is unset and this’s upload listener flag is set, then fire a progress event named loadstart at this’s upload object with requestBodyTransmitted and requestBodyLength.
</li>
			<li>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］~OR［
コレの`~send_~flag$xhr ~EQ ~F
］
⇒
~RET
◎
If this’s state is not opened or this’s send() flag is unset, then return.
</li>
			<li class="algo">
<p>
%要請の本体~chunk長さの処理n ~LET 所与の
( %~byte列~長さ )
に対し，次を走らす手続き：
◎
Let processRequestBodyChunkLength, given a bytesLength, be these steps:
</p>
				<ol>
					<li>
%伝送-済み要請~本体 ~INCBY %~byte列~長さ
◎
Increase requestBodyTransmitted by bytesLength.
</li>
					<li>
~IF［
この手続きが最後に呼出されたときから経過した~milli秒数は、
およそ 50 以下である
］
⇒
~RET
◎
If not roughly 50ms have passed since these steps were last invoked, then return.
</li>
					<li>
~IF［
コレの`~upload~listenerはあるか$xhr ~EQ ~T
］
⇒
`進捗~eventを発火する$( コレの`~upload~obj$xhr, `progress$et, %伝送-済み要請~本体, %要請~本体~長さ )
◎
If this’s upload listener flag is set, then fire a progress event named progress at this’s upload object with requestBodyTransmitted and requestBodyLength.
</li>
</ol>

<p class="note">注記：
この手続きは、新たな~byteが伝送されたときに限り，呼出される。
◎
These steps are only invoked when new bytes are transmitted.
</p>

			</li>
			<li class="algo">
<p>
%要請の本体~終了~時の処理n ~LET 次を走らす手続き：
◎
Let processRequestEndOfBody be these steps:
</p>
				<ol>
					<li>
コレの`~uploadは完了したか$xhr ~SET ~T
◎
Set this’s upload complete flag.
</li>
					<li>
~IF［
コレの`~upload~listenerはあるか$xhr ~EQ ~T
］
⇒
~RET
◎
If this’s upload listener flag is unset, then return.
</li>
					<li>
`進捗~eventを発火する$( コレの`~upload~obj$xhr, `progress$et, %伝送-済み要請~本体, %要請~本体~長さ )
◎
Fire a progress event named progress at this’s upload object with requestBodyTransmitted and requestBodyLength.
</li>
					<li>
`進捗~eventを発火する$( コレの`~upload~obj$xhr, `load$et, %伝送-済み要請~本体, %要請~本体~長さ )
◎
Fire a progress event named load at this’s upload object with requestBodyTransmitted and requestBodyLength.
</li>
					<li>
`進捗~eventを発火する$( コレの`~upload~obj$xhr, `loadend$et, %伝送-済み要請~本体, %要請~本体~長さ )
◎
Fire a progress event named loadend at this’s upload object with requestBodyTransmitted and requestBodyLength.
</li>
				</ol>
			</li>
			<li class="algo">
<p>
%応答の処理n ~LET 所与の
( %応答 )
に対し，次を走らす手続き：
◎
Let processResponse, given a response, be these steps:
</p>
				<ol>
					<li>
コレの`応答$xhr ~SET %応答
◎
Set this’s response to response.
</li>
					<li>
`~errorを取扱う$( コレ )
◎
Handle errors for this.
</li>
					<li>
~IF［
コレの`応答$xhr は`~network~error$である
］
⇒
~RET
◎
If this’s response is a network error, then return.
</li>
					<li>
コレの`状態$xhr ~SET `全~headerを受信した^i
◎
Set this’s state to headers received.
</li>
					<li>
`~eventを発火する$( コレ, `readystatechange$et )
◎
Fire an event named readystatechange at this.
</li>
					<li>
~IF［
コレの`状態$xhr ~NEQ `全~headerを受信した^i
］
⇒
~RET
◎
If this’s state is not headers received, then return.
</li>
					<li>
~IF［
%応答 の`本体$rs ~EQ ~NULL
］
⇒＃
`応答~本体の終端を取扱う$( コレ )；
~RET
◎
If this’s response’s body is null, then run handle response end-of-body for this and return.
</li>
					<li>
%長さ ~LET `~header~listから長さを抽出する$( コレの`応答$xhrの`~header~list$rs )
◎
Let length be the result of extracting a length from this’s response’s header list.
</li>
					<li>
~IF［
%長さ は整数でない
］
⇒
%長さ ~SET 0
◎
If length is not an integer, then set it to 0.
</li>
					<li class="algo">
<p>
%本体~chunkの処理n ~LET 所与の
( %~byte列 )
に対し，次を走らす手続き：
◎
Let processBodyChunk given bytes be these steps:
</p>
						<ol>
							<li>
コレの`受信した~byte列$xhrに %~byte列 を付加する
◎
Append bytes to this’s received bytes.
</li>
							<li>
~IF［
この手続きが前回に呼出されたときから経過した~milli秒数は、
およそ 50 以下である
］
⇒
~RET
◎
If not roughly 50ms have passed since these steps were last invoked, then return.
</li>
							<li>
~IF［
コレの`状態$xhr ~EQ `全~headerを受信した^i
］
⇒
コレの`状態$xhr ~SET `読込n中^i
◎
If this’s state is headers received, then set this’s state to loading.
</li>
							<li>
<p>
`~eventを発火する$( コレ, `readystatechange$et )
◎
Fire an event named readystatechange at this.
</p>

<p class="note">注記：
コレの`状態$xhrが変化しなくても，
`readystatechange$et が余分に発火されるのは、~Web互換性の理由による。
◎
Web compatibility is the reason readystatechange fires more often than this’s state changes.
</p>
							</li>
							<li>
`進捗~eventを発火する$( コレ, `progress$et, コレの`受信した~byte列$xhrの`長さ$byte, %長さ )
◎
Fire a progress event named progress at this with this’s received bytes’s length and length.
</li>
						</ol>
					</li>
					<li class="algo">
%本体~終了~時の処理n ~LET 次を走らす手続き
⇒
`応答~本体の終端を取扱う$( コレ )
◎
Let processEndOfBody be this step: run handle response end-of-body for this.
</li>
					<li class="algo">
<p>
%本体~errorの処理n ~LET 次を走らす手続き：
◎
Let processBodyError be these steps:
</p>
						<ol>
							<li>
コレの`応答$xhr ~SET `~network~error$,
◎
Set this’s response to a network error.
</li>
							<li>
`~errorを取扱う$( コレ )
◎
Run handle errors for this.
</li>
						</ol>
					</li>
					<li>
`本体を増分的に読取る$( コレの`応答$xhrの`本体$rs, %本体~chunkの処理n, %本体~終了~時の処理n, %本体~errorの処理n, コレに`関連な大域~obj$ )
◎
Incrementally read this’s response’s body, given processBodyChunk, processEndOfBody, processBodyError, and this’s relevant global object.
</li>
				</ol>
			</li>
			<li>
コレの`~fetch制御器$xhr ~LET %要請 を`~fetchする$
— 次を与える下で
⇒＃
`要請の本体~chunk長さの処理n$i ~SET %要請の本体~chunk長さの処理n,
`要請の本体~終了~時の処理n$i ~SET %要請の本体~終了~時の処理n,
`応答の処理n$i ~SET %応答の処理n
◎
Set this’s fetch controller to the result of fetching req with processRequestBodyChunkLength set to processRequestBodyChunkLength, processRequestEndOfBody set to processRequestEndOfBody, and processResponse set to processResponse.
</li>
			<li>
%今 ~LET 現~時刻
◎
Let now be the present time.
</li>
			<li>
<p>
この段は`並列的$に走らす：
◎
Run these steps in parallel:
</p>
				<ol>
					<li>
<p>
~OR↓ が満たされるまで待機する：
◎
Wait until either＼
</p>
						<ul>
							<li>
%要請 の`済んだか$rq ~EQ ~T
◎
req’s done flag is set or＼
</li>
							<li>
［
コレの`制限時間$xhr ~NEQ 0
］~AND［
%今 からコレの`制限時間$xhr ~milli秒~以上~経過した
］
◎
this’s timeout is not 0 and this’s timeout milliseconds have passed since now.
</li>
						</ul>
					</li>
					<li>
~IF［
%要請 の`済んだか$rq ~EQ ~F
］
⇒＃
コレの`時間切れか$xhr ~SET ~T；
`~fetchを終了する$( コレの`~fetch制御器$xhr )
◎
If req’s done flag is unset, then set this’s timed out flag and terminate this’s fetch controller.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
（ コレの`同期的か$xhr ~EQ ~T ）：
◎
Otherwise, if this’s synchronous flag is set:
</p>
		<ol>
			<li>
%応答は処理したか ~LET ~F
◎
Let processedResponse be false.
</li>
			<li class="algo">
<p>
%応答の本体を消費する処理n ~LET 所与の
( %応答, %~NULLまたは失敗または~byte列 )
に対し，次を走らす手続き：
◎
Let processResponseConsumeBody, given a response and nullOrFailureOrBytes, be these steps:
</p>
				<ol>
					<li>
~IF［
%~NULLまたは失敗または~byte列 ~NEQ `失敗^i
］
⇒
コレの`応答$xhr ~SET %応答
◎
If nullOrFailureOrBytes is not failure, then set this’s response to response.
</li>
					<li>
~IF［
%~NULLまたは失敗または~byte列 は`~byte列$である
］
⇒
コレの`受信した~byte列$xhrに %~NULLまたは失敗または~byte列 を付加する
◎
If nullOrFailureOrBytes is a byte sequence, then append nullOrFailureOrBytes to this’s received bytes.
</li>
					<li>
%応答は処理したか ~SET ~T
◎
Set processedResponse to true.
</li>
				</ol>
			</li>
			<li>
コレの`~fetch制御器$xhr ~LET %要請 を`~fetchする$
— 次を与える下で
⇒＃
`応答の本体を消費する処理n$i ~SET %応答の本体を消費する処理n,
`並列~queueを利用するか$i ~SET ~T
◎
Set this’s fetch controller to the result of fetching req with processResponseConsumeBody set to processResponseConsumeBody and useParallelQueue set to true.
</li>
			<li>
%今 ~LET 現~時刻
◎
Let now be the present time.
</li>
			<li>
<p>
~OR↓ が満たされるまで`静止する$：
◎
Pause until either＼
</p>
				<ul>
					<li>
%応答は処理したか ~EQ ~T
◎
processedResponse is true or＼
</li>
					<li>
［
コレの`制限時間$xhr ~NEQ 0
］~AND［
%今 からコレの`制限時間$xhr ~milli秒~以上~経過した
］
◎
this’s timeout is not 0 and this’s timeout milliseconds have passed since now.
</li>
				</ul>
			</li>
			<li>
~IF［
%応答は処理したか ~EQ ~F
］
⇒＃
コレの`時間切れか$xhr ~SET ~T；
`~fetchを終了する$( コレの`~fetch制御器$xhr )
◎
If processedResponse is false, then set this’s timed out flag and terminate this’s fetch controller.
</li>
			<li>
`計時を完結して報告する$( コレの`~fetch制御器$xhr, `現在の大域~obj$ )
◎
Report timing for this’s fetch controller given the current global object.
</li>
			<li>
`応答~本体の終端を取扱う$( コレ )
◎
Run handle response end-of-body for this.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p id="handle-response-end-of-file">
`応答~本体の終端を取扱う@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To handle response end-of-body for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
`~errorを取扱う$( %XHR )
◎
Handle errors for xhr.
</li>
	<li>
~IF［
%XHR の`応答$xhrは`~network~error$である
］
⇒
~RET
◎
If xhr’s response is a network error, then return.
</li>
	<li>
%伝送量 ~LET %XHR の`受信した~byte列$xhrの`長さ$byte
◎
Let transmitted be xhr’s received bytes’s length.
</li>
	<li>
%長さ ~LET `~header~listから長さを抽出する$( コレの`応答$xhrの`~header~list$rs )
◎
Let length be the result of extracting a length from this’s response’s header list.
</li>
	<li>
~IF［
%長さ は整数でない
］
⇒
%長さ ~SET 0
◎
If length is not an integer, then set it to 0.
</li>
	<li>
~IF［
%XHR の`同期的か$xhr ~EQ ~F
］
⇒
`進捗~eventを発火する$( %XHR, `progress$et, %伝送量, %長さ )
◎
If xhr’s synchronous flag is unset, then fire a progress event named progress at xhr with transmitted and length.
</li>
	<li>
%XHR の`状態$xhr ~SET `済み^i
◎
Set xhr’s state to done.
</li>
	<li>
%XHR の`~send_~flag$xhr ~SET ~F
◎
Unset xhr’s send() flag.
</li>
	<li>
`~eventを発火する$( %XHR, `readystatechange$et )
◎
Fire an event named readystatechange at xhr.
</li>
	<li>
`進捗~eventを発火する$( %XHR, `load$et, %伝送量, %長さ )
◎
Fire a progress event named load at xhr with transmitted and length.
</li>
	<li>
`進捗~eventを発火する$( %XHR, `loadend$et, %伝送量, %長さ )
◎
Fire a progress event named loadend at xhr with transmitted and length.
</li>
</ol>
</div>

<div class="algo">
<p>
`~errorを取扱う@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To handle errors for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
~IF［
%XHR の`~send_~flag$xhr ~EQ ~F
］
⇒
~RET
◎
If xhr’s send() flag is unset, then return.
</li>
	<li>
~IF［
%XHR の`時間切れか$xhr ~EQ ~T
］
⇒
`要請~error手続きを走らす$( %XHR, `timeout$et, `TimeoutError$E 例外 )
◎
If xhr’s timed out flag is set, then run the request error steps for xhr, timeout, and "TimeoutError" DOMException.
</li>
	<li>
~ELIF［
%XHR の`応答$xhrの`中止されたか$rs ~EQ ~T
］
⇒
`要請~error手続きを走らす$( %XHR, `abort$et, `AbortError$E 例外 )
◎
Otherwise, if xhr’s response’s aborted flag is set, run the request error steps for xhr, abort, and "AbortError" DOMException.
</li>
	<li>
~ELIF［
%XHR の`応答$xhrは`~network~error$である
］
⇒
`要請~error手続きを走らす$( %XHR, `error$et, `NetworkError$E 例外 )
◎
Otherwise, if xhr’s response is a network error, then run the request error steps for xhr, error, and "NetworkError" DOMException.
</li>
</ol>
</div>

<div class="algo">
<p>
`要請~error手続きを走らす@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR, %~event型, %例外（省略時は ε ）)
に対し：
◎
The request error steps for an XMLHttpRequest object xhr, event, and optionally exception are:
</p>
<ol>
	<li>
%XHR の`状態$xhr ~SET `済み^i
◎
Set xhr’s state to done.
</li>
	<li>
%XHR の`~send_~flag$xhr ~SET ~F
◎
Unset xhr’s send() flag.
</li>
	<li>
%XHR の`応答$xhr ~SET `~network~error$
◎
Set xhr’s response to a network error.
</li>
	<li>
<p>
~IF［
%XHR の`同期的か$xhr ~EQ ~T
］：
</p>
		<ol>
			<li>
~Assert：
%例外 ~NEQ ε
【この段は、この訳による補完。】
</li>
			<li>
~THROW %例外
</li>
		</ol>

◎
If xhr’s synchronous flag is set, then throw exception.
</li>
	<li>
<p>
`~eventを発火する$( %XHR, `readystatechange$et ) 
◎
Fire an event named readystatechange at xhr.
</p>

<p class="note">注記：
この時点で明らかに
%XHR の`同期的か$xhr ~EQ ~F
◎
At this point it is clear that xhr’s synchronous flag is unset.
</p>
	</li>
	<li>
<p>
~IF［
%XHR の`~uploadは完了したか$xhr ~EQ ~F
］：
◎
If xhr’s upload complete flag is unset, then:
</p>
		<ol>
			<li>
%XHR の`~uploadは完了したか$xhr ~SET ~T
◎
Set xhr’s upload complete flag.
</li>
			<li>
<p>
~IF［
%XHR の`~upload~listenerはあるか$xhr ~EQ ~T
］：
◎
If xhr’s upload listener flag is set, then:
</p>
				<ol>
					<li>
`進捗~eventを発火する$( %XHR の`~upload~obj$xhr, %~event型, 0, 0 )
◎
Fire a progress event named event at xhr’s upload object with 0 and 0.
</li>
					<li>
`進捗~eventを発火する$( %XHR の`~upload~obj$xhr, `loadend$et, 0, 0 )
◎
Fire a progress event named loadend at xhr’s upload object with 0 and 0.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`進捗~eventを発火する$( %XHR, %~event型, 0, 0 )
◎
Fire a progress event named event at xhr with 0 and 0.
</li>
	<li>
`進捗~eventを発火する$( %XHR, `loadend$et, 0, 0 )
◎
Fire a progress event named loadend at xhr with 0 and 0.
</li>
</ol>
</div>

			</section>
			<section id="the-abort()-method">
<h4 title="The abort() method">3.5.7. `abort()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `abort()$m</dt>
	<dd>
~network活動をすべて取消す。
◎
Cancels any network activity.
</dd>
</dl>

<div class="algo">
<p>
`abort()@m
~method手続きは：
◎
The abort() method steps are:
</p>
<ol>
	<li>
`~fetchを中止する$( コレの`~fetch制御器$xhr )
◎
Abort this’s fetch controller.
</li>
	<li>
~IF［［
コレの`状態$xhr ~EQ `~openした^i
］~AND［
コレの`~send_~flag$xhr ~EQ ~T
］］~OR［
コレの`状態$xhr ~IN { `全~headerを受信した^i, `読込n中^i }
］
⇒
`要請~error手続きを走らす$( コレ, `abort$et )
◎
If this’s state is opened with this’s send() flag set, headers received, or loading, then run the request error steps for this and abort.
</li>
	<li>
<p>
~IF［
コレの`状態$xhr ~EQ `済み^i
］
⇒
コレの`状態$xhr ~SET `未送信^i；
コレの`応答$xhr ~SET `~network~error$
◎
If this’s state is done, then set this’s state to unsent and this’s response to a network error.
</p>

<p class="note">注記：
`readystatechange$et ~eventは配送されない。
◎
No readystatechange event is dispatched.
</p>
	</li>
</ol>
</div>

			</section>
		</section>
		<section id="xmlhttprequest-response">
<h3 title="Response">3.6. 応答</h3>

			<section id="the-responseurl-attribute">
<h4 title="The responseURL getter">3.6.1. `responseURL^m 取得子</h4>

<div class="algo">
<p>
`responseURL@m
取得子~手続きは：
</p>
<ol>
	<li>
%~URL ~LET `応答$xhrの`~URL$rs
</li>
	<li>
~IF［
%~URL ~EQ ~NULL
］
⇒
~RET 空~文字列
</li>
	<li>
~RET `~URLを直列化する$( %~URL, `素片は除外する^i )
</li>
</ol>
◎
The responseURL getter steps are to return the empty string if this’s response’s URL is null; otherwise its serialization with the exclude fragment flag set.
</div>

			</section>
			<section id="the-status-attribute">
<h4 title="The status getter">3.6.2. `status^m 取得子</h4>

<div class="algo">
`status@m
取得子~手続きは
⇒
~RET コレの`応答$xhrの`状態s$rs
◎
The status getter steps are to return this’s response’s status.
</div>

			</section>
			<section id="the-statustext-attribute">
<h4 title="The statusText getter">3.6.3. `statusText^m 取得子</h4>

<div class="algo">
`statusText@m
取得子~手続きは
⇒
~RET コレの`応答$xhrの`状態s~message$rs
◎
The statusText getter steps are to return this’s response’s status message.
</div>

			</section>
			<section id="the-getresponseheader()-method">
<h4 title="The getResponseHeader() method">3.6.4. `getResponseHeader()^m ~method</h4>

<div class="algo">
<p>
`getResponseHeader(name)@m
~method手続きは
⇒
~RET `~header~listから値を取得する$( コレの`応答$xhrの`~header~list$rs, %name )
◎
The getResponseHeader(name) method steps are to return the result of getting name from this’s response’s header list.
</p>

<p class="note">注記：
コレの`応答$xhrに公開される`~header~list$rsは、
Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters this’s response’s header list. [FETCH]
</p>
</div>

<div class="example" id="example-getresponseheader">

<p>
次の~scriptにおいては：
◎
For the following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open("GET", "unicorns-are-awesome.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(%client.getResponseHeader("Content-Type"));
  }
}
</pre>

<p>
`print()^c 関数は、次と同様の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre class="lang-http">
text/plain; charset=UTF-8
</pre>

</div>

			</section>
			<section id="the-getallresponseheaders()-method">
<h4 title="The getAllResponseHeaders() method">3.6.5. `getAllResponseHeaders()^m ~method</h4>

<div class="algo">
<p>
`getAllResponseHeaders()@m
~method手続きは：
◎
↓↓A byte sequence a is legacy-uppercased-byte less than a byte sequence b if the following steps return true:
• Let A be a, byte-uppercased.
• Let B be b, byte-uppercased.
• Return A is byte less than B.
◎
The getAllResponseHeaders() method steps are:
</p>
<ol>
	<li>
%出力 ~LET 空~byte列
◎
Let output be an empty byte sequence.
</li>
	<li>
%初期~header~list ~LET `~header~listを~sortして結合する$( コレの`応答$xhrの`~header~list$rs )
◎
Let initialHeaders be the result of running sort and combine with this’s response’s header list.
</li>
	<li>
<p>
%~header~list ~LET `~listを昇順に~sortする$( %初期~header~list, 次に与える`小なり~algo$ )
⇒
<a id="legacy-uppercased-byte-less-than">小なり~algo</a>は、
所与の 2 つの~header ( %a, %b ) に対し
⇒
~RET ~IS［
`~byte大文字~化する$( %a の`名前$hd )
は
`~byte大文字~化する$( %b の`名前$hd )
`未満の~byte列$である
］
◎
Let headers be the result of sorting initialHeaders in ascending order,＼
with a being less than b if a’s name is legacy-uppercased-byte less than b’s name.
</p>

<p class="note">注記：
あいにく，この段は、配備-済み内容との互換性を得るため必要になる。
◎
Unfortunately, this is needed for compatibility with deployed content.
</p>
	</li>
	<li>
<p>
%~header~list 内の~EACH( %~header ) に対し
⇒
%出力 に次を順に付加する
⇒＃
%~header の`名前$hd,
~byte対 `3A^X `20^X,
%~header の`値$hd,
~byte対 `0D^X `0A^X
◎
For each header in headers, append header’s name, followed by a 0x3A 0x20 byte pair, followed by header’s value, followed by a 0x0D 0x0A byte pair, to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
コレの`応答$xhrに公開される`~header~list$rsは、
Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters this’s response’s header list. [FETCH]
</p>

</div>

<div class="example" id="example-getresponseheaders">

<p>
次の~scriptに対し：
◎
For the following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open("GET", "narwhals-too.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(this.getAllResponseHeaders());
  }
}
</pre>

<p>
`print()^c 関数は、次と同類の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre class="lang-http">
connection: Keep-Alive
content-type: text/plain; charset=utf-8
date: Sun, 24 Oct 2004 04:58:38 GMT
keep-alive: timeout=15, max=99
server: Apache/1.3.31 (Unix)
transfer-encoding: chunked
</pre>

</div>

			</section>
			<section id="response-body">
<h4 title="Response body">3.6.6. 応答~本体</h4>

<div class="algo">
<p>
`応答~MIME型を取得する@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To get a response MIME type for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %XHR の`応答$xhrの`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from xhr’s response’s header list.
</li>
	<li>
~IF［
%~MIME型 ~EQ `失敗^i
］
⇒
%~MIME型 ~SET `text/xml^c
【 `~MIME型を構文解析する$( `text/xml^l ) 】
◎
If mimeType is failure, then set mimeType to text/xml.
</li>
	<li>
~RET %~MIME型
◎
Return mimeType.
</li>
</ol>
</div>

<div class="algo">
<p>
`最終-~MIME型を取得する@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To get a final MIME type for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
%上書き~MIME型 ~LET %XHR の`上書き~MIME型$xhr
◎
↓</li>
	<li>
~IF［
%上書き~MIME型 ~EQ ~NULL
］
⇒
~RET `応答~MIME型を取得する$( %XHR )
◎
If xhr’s override MIME type is null, return the result of get a response MIME type for xhr.
</li>
	<li>
~RET %上書き~MIME型
◎
Return xhr’s override MIME type.
</li>
</ol>
</div>

<div class="algo">
<p>
`最終-符号化法を取得する@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To get a final encoding for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
%~label ~LET ε
◎
Let label be null.
</li>
	<li>
~IF［
%XHR の`上書き~MIME型$xhr ~NEQ ~NULL
］
⇒
%~label ~SET %XHR の`上書き~MIME型$xhrの`~parameter群$[ `charset^l ]
◎
↓</li>
	<li>
~IF［
%~label ~EQ ε
］
⇒
%~label ~SET 次の結果の`~parameter群$[ `charset^l ]
⇒
`応答~MIME型を取得する$( %XHR )
◎
Let responseMIME be the result of get a response MIME type for xhr.
◎
If responseMIME’s parameters["charset"] exists, then set label to it.
◎
If xhr’s override MIME type’s parameters["charset"] exists, then set label to it.
</li>
	<li>
~IF［
%~label ~EQ ε
］
⇒
~RET ~NULL
◎
If label is null, then return null.
</li>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~RET %符号化法 に応じて
⇒＃
`失敗^i ならば ~NULL／
~ELSE_ %符号化法
◎
If encoding is failure, then return null.
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
上の手続きが`最終-~MIME型を取得する$を利用しないのは、意図的である
— そうすると~web互換でなくなるので。
◎
The above steps intentionally do not use the get a final MIME type as it would not be web compatible.
</p>
</div>

<hr>

<div class="algo">
<p>
`文書~応答を設定する@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To set a document response for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
~IF［
%XHR の`応答$xhrの`本体$rs ~EQ ~NULL,
］
⇒
~RET
◎
If xhr’s response’s body is null, then return.
</li>
	<li>
%charset ~LET ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%最終-~MIME型 ~LET `最終-~MIME型を取得する$( %XHR )
◎
Let finalMIME be the result of get a final MIME type for xhr.
</li>
	<li>
<p>
%最終-~MIME型 に応じて：
◎
↓↓If finalMIME is not an HTML MIME type or an XML MIME type, then return.
</p>
		<ul class="switch">
			<li>
<p>
`~HTML~MIME型$である：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
%XHR の`応答~種別$xhr ~EQ 空~文字列
］
⇒
~RET
◎
If xhr’s response type is the empty string and＼
finalMIME is an HTML MIME type, then return.
</p>

<p class="note">注記：
旧来の内容を非互換化するのを防止するため、
%XHR の`応答~種別$xhrは，ここでは `document^l に制約される。
◎
This is restricted to xhr’s response type being "document" in order to prevent breaking legacy content.
</p>
					</li>
					<li>
%charset ~SET `最終-符号化法を取得する$( %XHR )
◎
↑If finalMIME is an HTML MIME type, then:
◎
Let charset be the result of get a final encoding for xhr.
</li>
					<li>
~IF［
%charset ~EQ ~NULL
］
⇒
~IF［
%XHR の`受信した~byte列$xhrの最初の 1024 ~byteを`予走査して＠~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding$，成功裡に結果を得られた
］
⇒
%charset ~LET その結果
◎
If charset is null, prescan the first 1024 bytes of xhr’s received bytes and if that does not terminate unsuccessfully then let charset be the return value.
</li>
					<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
					<li>
%文書 ~LET 次の結果を表現する`文書$
⇒
~HTML標準の~HTML構文解析器に~~規定される規則に従って，［
~scriptは不能化する,
`既知かつ確定的な符号化法＠~HTMLparsing#a-known-definite-encoding$として %charset を与える
］下で， %XHR の`受信した~byte列$xhrを構文解析した結果
`HTML$r
◎
Let document be a document that represents the result parsing xhr’s received bytes following the rules set forth in the HTML Standard for an HTML parser with scripting disabled and a known definite encoding charset. [HTML]
</li>
					<li>
%文書 の`種別$doc ~SET `html^l
◎
Flag document as an HTML document.
</li>
				</ol>
			</li>
			<li>
<p>
`~XML~MIME型$である
⇒
%文書 ~LET 次の結果を表現する`文書$
⇒
`~XML~scripting~supportを不能化する＠~HTMLxml#xml-scripting-support-disabled$下で，
%XHR の`受信した~byte列$xhrを`~XML構文解析器＠~HTMLxml#xml-parser$にかけた結果
`HTML$r
⇒
~IF［
構文解析に失敗した（例：未~supportな文字~符号化法, 名前空間~整形式性~error, 等々）
］
⇒
~RET ~NULL
◎
Otherwise, let document be a document that represents the result of running the XML parser with XML scripting support disabled on xhr’s received bytes. If that fails (unsupported character encoding, namespace well-formedness error, etc.), then return null. [HTML]
</p>

<p class="note">注記：
文書から参照されている資源は読込まれず，文書に結付けられた~XSLTは適用されない。
◎
Resources referenced will not be loaded and no associated XSLT will be applied.
</p>
			</li>
			<li>
その他~MIME型
⇒
~RET
◎
↑↑</li>
		</ul>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
	<li>
%文書 の
⇒＃
`符号化法$doc ~SET %charset,
`内容~型$doc ~SET %最終-~MIME型,
`~URL$doc ~SET %XHR の`応答$xhrの`~URL$rs,
`生成元$doc ~SET %XHR に`関連な設定群~obj$の`生成元$enV
◎
Set document’s encoding to charset.
◎
Set document’s content type to finalMIME.
◎
Set document’s URL to xhr’s response’s URL.
◎
Set document’s origin to xhr’s relevant settings object’s origin.
</li>
	<li>
%XHR の`応答~obj$xhr ~SET %文書
◎
Set xhr’s response object to document.
</li>
</ol>
</div>

<div class="algo">
<p>
`~text応答を取得する@
~algoは、
所与の
( `XMLHttpRequest$I ~obj %XHR )
に対し：
◎
To get a text response for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
~IF［
%XHR の`応答$xhrの`本体$rs ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If xhr’s response’s body is null, then return the empty string.
</li>
	<li>
%charset ~LET `最終-符号化法を取得する$( %XHR )
◎
Let charset be the result of get a final encoding for xhr.
</li>
	<li>
<p>
~IF［
%XHR の`応答~種別$xhr ~EQ 空~文字列
］~AND［
%charset ~EQ ~NULL
］：
◎
If xhr’s response type is the empty string, charset is null,＼
</p>
		<ol>
			<li>
%最終-~MIME型 ~LET `最終-~MIME型を取得する$( %XHR )
◎
and the result of get a final MIME type for xhr＼
</li>
			<li>
~IF［
%最終-~MIME型 は`~XML~MIME型$である
］
⇒
%charset ~LET
~XML仕様に~~規定される規則に従って決定される符号化法
`XML$r
`XML-NAMES$r
◎
is an XML MIME type, then use the rules set forth in the XML specifications to determine the encoding. Let charset be the determined encoding. [XML] [XML-NAMES]
</li>
		</ol>

<p class="note">注記：
旧来のものでない`応答~種別$xhr用の値 `text^l を単純なままに保つため、
%XHR の`応答~種別$xhrは，ここでは空~文字列に制約される。
◎
This is restricted to xhr’s response type being the empty string to keep the non-legacy response type value "text" simple.
</p>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
	<li>
~RET `~Unicodeに復号する$( %XHR の`受信した~byte列$xhr, %charset )
◎
Return the result of running decode on xhr’s received bytes using fallback encoding charset.
</li>
</ol>

<p class="note">注記：
作者には、資源を符号化する際には，常に`~UTF-8$を利用することが強く奨励される。
◎
Authors are strongly encouraged to always encode their resources using UTF-8.
</p>
</div>

			</section>
			<section id="the-overridemimetype()-method">
<h4 title="The overrideMimeType() method">3.6.7. `overrideMimeType()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `overrideMimeType(mime)$m</dt>
	<dd>
応答の `Content-Type$h ~header値が %mime であったかのように動作する（その~headerを変更することなく）。
◎
Acts as if the `Content-Type` header value for a response is mime. (It does not change the header.)
</dd>
	<dd>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`状態$xhr ~IN { `読込n中^i, `済み^i }
◎
Throws an "InvalidStateError" DOMException if state is loading or done.
</dd>
</dl>

<div class="algo">
<p>
`overrideMimeType(mime)@m
~method手続きは：
◎
The overrideMimeType(mime) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~IN { `読込n中^i, `済み^i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is loading or done, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`上書き~MIME型$xhr ~SET `~MIME型を構文解析する$( %mime )
◎
Set this’s override MIME type to the result of parsing mime.
</li>
	<li>
~IF［
コレの`上書き~MIME型$xhr ~EQ `失敗^i
］
⇒
コレの`上書き~MIME型$xhr ~SET `application/octet-stream^bl
◎
If this’s override MIME type is failure, then set this’s override MIME type to application/octet-stream.
</li>
</ol>
</div>

			</section>
			<section id="the-responsetype-attribute">
<h4 title="The responseType getter and setter">3.6.8. `responseType^m 取得子／設定子</h4>

<dl class="domintro">
	<dt>%client . `responseType$m [ = %value ]</dt>
	<dd>
応答の種別を返す。
◎
Returns the response type.
</dd>
	<dd>
設定して、応答の種別を変更できる。
値は次のいずれか
⇒
空~文字列 （既定）,
`arraybuffer^l,
`blob^l,
`document^l,
`json^l,
`text^l
◎
Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
</dd>
	<dd>
<p>
設定子においては：
◎
↓</p>
		<ul>
			<li>
`現在の大域~obj$は`~window$でない場合、
`document^l に設定しても無視される。
◎
When set: setting to "document" is ignored if the current global object is not a Window object.
</li>
			<li>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`状態$xhr ~IN { `読込n中^i, `済み^i }
◎
When set: throws an "InvalidStateError" DOMException if state is loading or done.
</li>
			<li>
次が満たされている下では、
`InvalidAccessError$E 例外が投出される
⇒
［
`同期的か$xhr ~EQ ~T
］~AND［
`現在の大域~obj$は`~window$である
］
◎
When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and the current global object is a Window object.
</li>
		</ul>
	</dd>
</dl>

<div class="algo">
`responseType@m
取得子~手続きは
⇒
~RET コレの`応答~種別$xhr
◎
The responseType getter steps are to return this’s response type.
</div>

<div class="algo">
<p>
`responseType$m 設定子~手続きは：
◎
The responseType setter steps are:
</p>
<ol>
	<li>
%W ~LET ~IS［
`現在の大域~obj$は`~window$である
］
◎
↓</li>
	<li>
~IF［
%W ~EQ ~F
］~AND［
所与の値 ~EQ `document^l
］
⇒
~RET
◎
If the current global object is not a Window object and the given value is "document", then return.
</li>
	<li>
~IF［
コレの`状態$xhr ~IN { `読込n中^i, `済み^i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is loading or done, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%W ~EQ ~T
］~AND［
コレの`同期的か$xhr ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If the current global object is a Window object and this’s synchronous flag is set, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
コレの`応答~種別$xhr ~SET 所与の値
◎
Set this’s response type to the given value.
</li>
</ol>
</div>

			</section>
			<section id="the-response-attribute">
<h4 title="The response getter">3.6.9. `response^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `response$m</dt>
	<dd>
応答の本体を返す。
◎
Returns the response body.
</dd>
</dl>

<div class="algo">
<p>
`response@m
取得子~手続きは：
◎
The response getter steps are:
</p>
<ol>
	<li>
<p>
~IF［
コレの`応答~種別$xhr ~IN { 空~文字列, `text^l }
］：
◎
If this’s response type is the empty string or "text", then:
</p>
		<ol>
			<li>
~IF［
コレの`状態$xhr ~NIN { `読込n中^i, `済み^i }
］
⇒
~RET 空~文字列
◎
If this’s state is not loading or done, then return the empty string.
</li>
			<li>
~RET `~text応答を取得する$( コレ )
◎
Return the result of getting a text response for this.
</li>
		</ol>
	</li>
	<li>
~IF［
コレの`状態$xhr ~NEQ `済み^i
］
⇒
~RET ~NULL
◎
If this’s state is not done, then return null.
</li>
	<li>
~IF［
コレの`応答~obj$xhr ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If this’s response object is failure, then return null.
</li>
	<li>
~IF［
コレの`応答~obj$xhr ~NEQ ~NULL
］
⇒
~RET コレの`応答~obj$xhr
◎
If this’s response object is non-null, then return it.
</li>
	<li>
<p>
コレの`応答~種別$xhrに応じて：
◎
↓</p>
		<dl class="switch">
			<dt id="arraybuffer-response">
`arraybuffer^l
◎
If this’s response type is "arraybuffer", then＼
</dt>
			<dd>
コレの`応答~obj$xhr ~SET コレの`受信した~byte列$xhrを表現する，`新たな$ `ArrayBuffer$I ~obj
◎
set this’s response object to a new ArrayBuffer object representing this’s received bytes.＼
</dd>
			<dd>
例外が投出されたときは
⇒＃
コレの`応答~obj$xhr ~SET `失敗^i；
~RET ~NULL
◎
If this throws an exception, then set this’s response object to failure and return null.
</dd>
			<dd class="note">注記：
`ArrayBuffer$I ~objを割振ることの成功-は、保証されない。
`ECMASCRIPT$r
◎
Allocating an ArrayBuffer object is not guaranteed to succeed. [ECMASCRIPT]
</dd>

			<dt id="blob-response">
`blob^l
◎
Otherwise, if this’s response type is "blob",＼
</dt>
			<dd>
コレの`応答~obj$xhr ~SET 次のようにされた，コレの`受信した~byte列$xhrを表現する`新たな$ `Blob$I ~obj
⇒
`~type0$m ~SET `最終-~MIME型を取得する$( コレ )
◎
set this’s response object to a new Blob object representing this’s received bytes with type set to the result of get a final MIME type for this.
</dd>

			<dt>
`document^l
◎
Otherwise, if this’s response type is "document",＼
</dt>
			<dd>
`文書~応答を設定する$( コレ )
◎
set a document response for this.
</dd>

			<dt id="json-response">
`json^l
◎
Otherwise:
◎
Assert: this’s response type is "json".
</dt>
			<dd>
				<ol>
					<li>
~IF［
コレの`応答$xhrの`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If this’s response’s body is null, then return null.
</li>
					<li>
%~JSON~obj ~LET `~JSON~byte列を~JS値に構文解析する$( コレの`受信した~byte列$xhr )
⇒
例外が投出されたときは
⇒
~RET ~NULL
◎
Let jsonObject be the result of running parse JSON from bytes on this’s received bytes. If that threw an exception, then return null.
</li>
					<li>
コレの`応答~obj$xhr ~SET %~JSON~obj
◎
Set this’s response object to jsonObject.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET コレの`応答~obj$xhr
◎
Return this’s response object.
</li>
</ol>
</div>

			</section>
			<section id="the-responsetext-attribute">
<h4 title="The responseText getter">3.6.10. `responseText^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `responseText$m</dt>
	<dd>
応答を~textとして返す。
◎
Returns response as text.
</dd>
	<dd>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`応答~種別$xhr【！`responseType$m】 ~NIN { 空~文字列, `text^l }
◎
Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".
</dd>
</dl>

<div class="algo">
<p>
`responseText@m
取得子~手続きは：
◎
The responseText getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`応答~種別$xhr ~NIN { 空~文字列, `text^l }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s response type is not the empty string or "text", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`状態$xhr ~NIN { `読込n中^i, `済み^i }
］
⇒
~RET 空~文字列
◎
If this’s state is not loading or done, then return the empty string.
</li>
	<li>
~RET `~text応答を取得する$( コレ )
◎
Return the result of getting a text response for this.
</li>
</ol>
</div>

			</section>
			<section id="the-responsexml-attribute">
<h4 title="The responseXML getter">3.6.11. `responseXML^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `responseXML$m</dt>
	<dd>
応答を文書として返す。
◎
Returns the response as document.
</dd>
	<dd>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`応答~種別$xhr【！`responseType$m】 ~NIN { 空~文字列, `document^l }
◎
Throws an "InvalidStateError" DOMException if responseType is not the empty string or "document".
</dd>
</dl>

<div class="algo">
<p>
`responseXML@m
取得子~手続きは：
◎
The responseXML getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`応答~種別$xhr ~NIN { 空~文字列, `document^l }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s response type is not the empty string or "document", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`状態$xhr ~NEQ `済み^i
］
⇒
~RET ~NULL
◎
If this’s state is not done, then return null.
</li>
	<li>
~Assert：
コレの`応答~obj$xhr ~NEQ `失敗^i
◎
Assert: this’s response object is not failure.
</li>
	<li>
~IF［
コレの`応答~obj$xhr ~NEQ ~NULL
］
⇒
~RET コレの`応答~obj$xhr
◎
If this’s response object is non-null, then return it.
</li>
	<li>
`文書~応答を設定する$( コレ )
◎
Set a document response for this.
</li>
	<li>
~RET コレの`応答~obj$xhr
◎
Return this’s response object.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="events">
<h3 title="Events summary">3.7. ~event要覧</h3>

◎非規範的

<p>
以下の~eventが［
`XMLHttpRequest$I ／ `XMLHttpRequestUpload$I
］~objに向けて配送される：
◎
The following events are dispatched on XMLHttpRequest or XMLHttpRequestUpload objects:
</p>

<table><thead>
<tr><th>~event名
◎
Event name
<th>~interface
◎
Interface
<th>配送-時機
◎
Dispatched when…
<tbody>

<tr><td>`readystatechange@et
<td>`Event$I
<td>
`readyState$m 属性の値が変化したとき。
ただし， `UNSENT$m に変化したときは除く。
◎
The readyState attribute changes value, except when it changes to UNSENT.

<tr><td>`loadstart@et
<td>`ProgressEvent$I
<td>
~fetchが起動されたとき。
◎
The fetch initiates.

<tr><td>`progress@et
<td>`ProgressEvent$I
<td>
~dataを伝送しているとき。
◎
Transmitting data.

<tr><td>`abort@et
<td>`ProgressEvent$I
<td>
~fetchが中止されたとき。
例えば， `abort()$m ~methodの呼出ngなど。
◎
When the fetch has been aborted. For instance, by invoking the abort() method.

<tr><td>`error@et
<td>`ProgressEvent$I
<td>
~fetchに失敗したとき。
◎
The fetch failed.

<tr><td>`load@et
<td>`ProgressEvent$I
<td>
~fetchに成功したとき。
◎
The fetch succeeded.

<tr><td>`timeout@et
<td>`ProgressEvent$I
<td>
~fetchが完了する前に `timeout$m に指定される時間を過ぎたとき。
◎
The author specified timeout has passed before the fetch completed.

<tr><td>`loadend@et
<td>`ProgressEvent$I
<td>
~fetchが完了したとき（成功, 失敗, いずれに関わらず）。
◎
The fetch completed (success or failure).
</table>

		</section>
	</section>
	<section id="interface-formdata">
<h2 title="Interface FormData">4. ~interface `FormData^I</h2>

<pre class="idl">
typedef (`File$I or `USVString$) `FormDataEntryValue@I;

[`Exposed$=(Window,Worker)]
interface `FormData@I {
  `FormData$mc(optional `HTMLFormElement$I %form, optional `HTMLElement$I? %submitter = null);

  `undefined$ `append$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `append$m(`USVString$ %name, `Blob$I %value, optional `USVString$ %filename);
  `undefined$ `delete$m(`USVString$ %name);
  `FormDataEntryValue$I? `get$m(`USVString$ %name);
  `sequence$&lt;`FormDataEntryValue$I&gt; `getAll$m(`USVString$ %name);
  `boolean$ `has$m(`USVString$ %name);
  `undefined$ `set$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `set$m(`USVString$ %name, `Blob$I %value, optional `USVString$ %filename);
  `iterable$m&lt;`USVString$, `FormDataEntryValue$I&gt;;
};
</pre>

<p>
各 `FormData$I ~objには、
`~entry~list@fD
が結付けられる
— それは、`~entry~list$であり，初期~時は空とする。
◎
Each FormData object has an associated entry list (an entry list). It is initially empty.
</p>

<p class="note" id="_entries">注記：
この節は，［
~entry~listを成す`~entry$fD, その`名$fDと`値$fD,
`~entryを作成する$~algo
］を定義していたが、
それらは~HTML標準へ移動された。
`HTML$r
◎
This section used to define entry, an entry’s name and value, and the create an entry algorithm. These definitions have been moved to the HTML Standard. [HTML]
</p>

<div class="algo">
<p>
`new FormData(form, submitter)@m
構築子~手続きは：
◎
The new FormData(form, submitter) constructor steps are:
</p>
<ol>
	<li>
~IF［
%form ~EQ ε
］
⇒
~RET
◎
If form is given, then:
</li>
	<li>
<p>
~IF［
%submitter ~NEQ ~NULL
］：
◎
If submitter is non-null, then:
</p>
		<ol>
			<li>
~IF［
%submitter は`提出-~button$でない
］
⇒
~THROW `TypeError$E
◎
If submitter is not a submit button, then throw a TypeError.
</li>
			<li>
~IF［
%submitter の`~form所有者$ ~NEQ %form
］
⇒
~THROW `NotFoundError$E
◎
If submitter’s form owner is not form, then throw a "NotFoundError" DOMException.
</li>
		</ol>
	</li>
	<li>
%~list ~LET `~entry~listを構築する$( %form, %submitter )
◎
Let list be the result of constructing the entry list for form and submitter.
</li>
	<li>
~IF［
%~list ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
◎
If list is null, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`~entry~list$fD ~SET %~list
◎
Set this’s entry list to list.
</li>
</ol>
</div>

<div class="algo">
<p>
`append(name, value, filename)@m
~method手続きは：
◎
The append(name, value) and append(name, blobValue, filename) method steps are:
• Let value be value if given; otherwise blobValue.
</p>
<ol>
	<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
	<li>
コレの`~entry~list$fDに %~entry を`付加する$
◎
Append entry to this’s entry list.
</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

<div class="algo">
`delete(name)@m
~method手続きは
⇒
コレの`~entry~list$fDから 次を満たす`~entry$fDをすべて`除去する$
⇒
`名$fD ~EQ %name
◎
The delete(name) method steps are to remove all entries whose name is name from this’s entry list.
</div>

<div class="algo">
`get(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fD内に 次を満たす`~entry$fDは［
在るならば それらのうち最初のものの`値$fD ／
無いならば ~NULL
］
⇒
`名$fD ~EQ %name
◎
The get(name) method steps are:
• If there is no entry whose name is name in this’s entry list, then return null.
• Return the value of the first entry whose name is name from this’s entry list.
</div>

<div class="algo">
`getAll(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fD内の［
次を満たす`~entry$fDすべての`値$fD
］からなる同順の~list（無ければ空~list）
⇒
`名$fD ~EQ %name
◎
The getAll(name) method steps are:
• If there is no entry whose name is name in this’s entry list, then return the empty list.
• Return the values of all entries whose name is name, in order, from this’s entry list.
</div>

<div class="algo">
`has(name)@m
~method手続きは
⇒
~RET ~IS［
コレの`~entry~list$fD内に 次を満たす`~entry$fDは在る
］
⇒
`名$fD ~EQ %name
◎
The has(name) method steps are to return true if there is an entry whose name is name in this’s entry list; otherwise false.
</div>

<div class="algo">
<p>
`set(name, value, filename)@m
~method手続きは：
◎
The set(name, value) and set(name, blobValue, filename) method steps are:
• Let value be value if given; otherwise blobValue.
</p>
<ol>
	<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
	<li>
~IF［
コレの`~entry~list$fD内に次を満たす`~entry$fDは在る
］…
⇒
`名$fD ~EQ %name
◎終
…ならば
⇒
該当する`~entry$fDのうち
⇒＃
最初のものは %~entry に`置換する$,
他のものはすべて`除去する$
◎
If there are entries in this’s entry list whose name is name, then replace the first such entry with entry and remove the others.
</li>
	<li>
~ELSE
⇒
コレの`~entry~list$fDに %~entry を`付加する$
◎
Otherwise, append entry to this’s entry list.
</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

<p>
`iterable@m
における`反復される値~pair群$を成す各~pairを成す
( ~key, 値 )
は、コレの`~entry~list$fDを成す各`~entry$fDの
( `名$fD, `値$fD )
で与えられるとする。
◎
The value pairs to iterate over are this’s entry list’s entries with the key being the name and the value being the value.
</p>

	</section>
	<section id="interface-progressevent">
<h2 title="Interface ProgressEvent">5. ~interface `ProgressEvent^I</h2>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `ProgressEvent@I : `Event$I {
  `ProgressEvent@mc(`DOMString$ %type, optional `ProgressEventInit$I %eventInitDict = {});

  readonly attribute `boolean$ `lengthComputable$m;
  readonly attribute `double$ `loaded$m;
  readonly attribute `double$ `total$m;
};

dictionary `ProgressEventInit@I : `EventInit$I {
  `boolean$ `lengthComputable@mb = false;
  `double$ `loaded@mb = 0;
  `double$ `total@mb = 0;
};
</pre>

<p>
`ProgressEvent$I ~interfaceを利用する`~event$は、何らかの進捗を指示する。
◎
Events using the ProgressEvent interface indicate some kind of progression.
</p>

<div class="algo">
`lengthComputable@m,
`loaded@m,
`total@m
取得子~手続きは、いずれも，各自の初期化-時の値を返す。
◎
The lengthComputable, loaded, and total getter steps are to return the value they were initialized to.
</div>

		<section id="firing-events-using-the-progressevent-interface">
<h3 title="Firing events using the ProgressEvent interface">5.1. `ProgressEvent^I ~interfaceを利用する~eventの発火-法</h3>

<div class="algo">
<p>
`進捗~eventを発火する@
~algoは、
所与の
( %target, %e, %伝送量, %長さ )
に対し
⇒
`~eventを発火する$( %target, %e, `ProgressEvent$I )
— 次のように初期化して
⇒＃
`loaded$m 属性 ~SET %伝送量,
`lengthComputable$m 属性 ~SET ~IS［ %長さ ~NEQ 0 ］,
`total$m 属性 ~SET %長さ
◎
To fire a progress event named e at target, given transmitted and length, means to fire an event named e at target, using ProgressEvent, with the loaded attribute initialized to transmitted, and if length is not 0, with the lengthComputable attribute initialized to true and the total attribute initialized to length.
</p>
</div>

		</section>
		<section id="suggested-names-for-events-using-the-progressevent-interface">
<h3 title="Suggested names for events using the ProgressEvent interface">5.2. `ProgressEvent^I ~interfaceを利用する~eventに示唆される名前</h3>

◎非規範的

<p>
下の表tに，
`ProgressEvent$I ~interfaceを利用する`~event$に示唆される `type$m 属性の値を要約する。
仕様の編集者が，その仕様に特有な局面に応じて~~調整してもかまわないが、
~~問題に馴染みのある人達からの~~意見を汲むために，
その用法について WHATWG ~communityにて論を交わすことが強く奨励される。
◎
The suggested type attribute values for use with events using the ProgressEvent interface are summarized in the table below. Specification editors are free to tune the details to their specific scenarios, though are strongly encouraged to discuss their usage with the WHATWG community to ensure input from people familiar with the subject.
</p>

<table><thead>
<tr><th>
`type$m
◎
type attribute value
<th>
記述
◎
Description
<th>
回数
◎
Times
<th>
時機
◎
When
<tbody>

<tr><th>`loadstart$et
<td>
進捗が始まった。
◎
Progress has begun.
<td>1 回
◎
Once.
<td>最初。
◎
First.

<tr><th>`progress$et
<td>
進捗~中。
◎
In progress.
<td>1 回以上
◎
Once or more.
<td>
`loadstart$et が`配送-$された後。
◎
After loadstart has been dispatched.

<tr><th>`error$et
<td>進捗に失敗した。
◎
Progression failed.
<td rowspan="4" style="min-width:6em;">
高々 1 回<br>
（排他的）
◎
Zero or once (mutually exclusive).
<td rowspan="4">
最後の `progress$et が`配送-$された後。
◎
After the last progress has been dispatched.

<tr><th>`abort$et
<td>進捗は中止された【！終了した】。
◎
Progression is terminated.

<tr><th>`timeout$et
<td>
進捗は時間~切れに因り終了した。
◎
Progression is terminated due to preset time expiring.

<tr><th>`load$et
<td>進捗は成功裡に終わった。
◎
Progression is successful.

<tr><th>`loadend$et
<td>進捗は停止された。
◎
Progress has stopped.
<td>1 回
◎
Once.
<td>
`error$et, `abort$et, `timeout$et, `load$et のいずれかが`配送-$された後。
◎
After one of error, abort, timeout or load has been dispatched.
</table>

<p>
~event型
`error$et, `abort$et, `timeout$et, `load$et
は、互いに排他的である。
<!-- 
【これら 4 種のいずれかは 1 回 生じる】
 -->
◎
The error, abort, timeout, and load event types are mutually exclusive.
</p>

<p>
Web ~platform全般に渡り，~event型
`error$et, `abort$et, `timeout$et, `load$et
の `bubbles$m および `cancelable$m 属性は、 ~F に初期化される。
従って，一貫性を保つため、 `ProgressEvent$I ~interfaceを利用するすべての`~event$も同様にすることが示唆される。
◎
Throughout the web platform the error, abort, timeout and load event types have their bubbles and cancelable attributes initialized to false, so it is suggested that for consistency all events using the ProgressEvent interface do the same.
</p>

		</section>
		<section id="security-considerations">
<h3 title="Security considerations">5.3. ~securityの考慮点</h3>

<p>
非同一-生成元~要請に対しては、例えば 
Fetch 標準にて定義される`~CORS~protocol$
などの，ある種の~opt-inが、 `ProgressEvent$I ~interfaceを利用する`~event$が`配送-$される前に利用される必要がある。
そうすると、他では得せない情報（例：~size）まで露呈されるので。
`FETCH$r
◎
For cross-origin requests some kind of opt-in, e.g., the CORS protocol defined in the Fetch Standard, has to be used before events using the ProgressEvent interface are dispatched as information (e.g., size) would be revealed that cannot be obtained otherwise. [FETCH]
</p>

		</section>
		<section id="example">
<h3 title="Example">5.4. 用例</h3>

<div class="example" id="example-progress-events">

<p>
次の例では、 `XMLHttpRequest$I に，前~節にて定義された概念が組合され、`~fetching$の過程の表示に~HTML `progress$e 要素が利用される。
◎
In this example XMLHttpRequest, combined with concepts defined in the sections before, and the HTML progress element are used together to display the process of fetching a resource.
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;title&gt;Waiting for Magical Unicorns&lt;/title&gt;
&lt;progress id=p&gt;&lt;/progress&gt;
&lt;script&gt;
  var %progressBar = document.getElementById("p"),
      %client = new XMLHttpRequest()
  %client.open("GET", "magical-unicorns")
  %client.onprogress = function(%pe) {
    if(%pe.lengthComputable) {
      %progressBar.max = %pe.total
      %progressBar.value = %pe.loaded
    }
  }
  %client.onloadend = function(%pe) {
    %progressBar.value = %pe.loaded
  }
  %client.send()
&lt;/script&gt;
</pre>

<p>
もちろん，全部的に~~機能する~codeは、より精巧かつ，~network~errorや末端利用者からの終了-要請など，より多くの局面に対応するものになるだろうが。
◎
Fully working code would of course be more elaborate and deal with more scenarios, such as network errors or the end user terminating the request.
</p>

</div>

		</section>
	</section>
	<section id="acknowledgments">
<h2>謝辞</h2>

<p>
この標準に貢献された、次の方々に感謝する：
</p>

`_acks1@

<p>
Windows Internet Explorer にて初めて実装し，
`XMLHttpRequest$I ~interfaceを最初に広めた Microsoft の開発者たちに特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented the XMLHttpRequest interface, which was first widely deployed by the Windows Internet Explorer browser.
</p>

<p>
HTML Standard （ Web Applications 1.0 ）にて、この仕様の初期~versionを草案~化された Ian Hickson 氏に特別な謝意を。
`HTML$r
◎
Special thanks to Ian Hickson for drafting an initial version of this specification in the HTML Standard (then Web Applications 1.0). [HTML]
</p>

<p>
`SVG Micro DOM＠https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/svgudom.html$
の一部として、
元々の `ProgressEvent^I ~classの草案を作成した W3C SVG WG に特別な謝意を。
◎
Special thanks to the W3C SVG WG for drafting the original ProgressEvent class as part of the SVG Micro DOM.
</p>

<p lang="en">
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>

<div lang="en" id="_acks1">
Thanks to

Addison Phillips,
Adrian Bateman,
Ahmed Kamel,
Alan Thomas,
Alex Hopmann,
Alex Vincent,
Alexey Proskuryakov,
Ali Alabbas,
Andrea Marchesini,
Asbjørn Ulsberg,
Bertrand Guay-Paquet,
Björn Höhrmann,
Boris Zbarsky,
Caitlin Potter,
Cameron McCormack,
白丞祐 (Cheng-You Bai),
Chris Marrin,
Christophe Jolif,
Charles McCathieNevile,
Chirag S Kumar,
Dan Winship,
David Andersson,
David Flanagan,
David Håsäther,
David Levin,
Dean Jackson,
Denis Sureau,
Domenic Denicola,
Dominik Röttsches,
Doug Schepers,
Douglas Livingstone,
Elliott Sprehn,
Elliotte Harold,
Eric Lawrence,
Eric Uhrhane,
Erik Arvidsson,
Erik Dahlström,
Feras Moussa,
Gideon Cohn,
Glenn Adams,
Gorm Haug Eriksen,
Gregory Terzian,
Håkon Wium Lie,
Hallvord R. M. Steen,
Henri Sivonen,
Hiroshige Hayashizaki,
Huub Schaeks,
Ian Clelland,
Ian Davis,
Ian Hickson,
Ivan Herman,
Jake Archibald,
Jared Jacobs,
Jarred Nicholls,
Jeff Walden,
Jens Lindström,
Jim Deegan,
Jim Ley,
Joe Farro,
Jonas Sicking,
Julian Reschke,
송정기 (Jungkee Song),
呂康豪 (Kang-Hao Lu),
Karl Dubost,
Keith Yeung,
田村健人 (Kent TAMURA),
Lachlan Hunt,
Maciej Stachowiak,
Magnus Kristiansen,
Manish Goregaokar,
Marc Hadley,
Marcos Caceres,
Mark Baker,
Mark Birbeck,
Mark Nottingham,
Mark S. Miller,
Martin Hassman,
Mike Pennisi,
Mohamed Zergaoui,
Ms2ger,
Noam Rosenthal,
Odin Hørthe Omdal,
Olli Pettay,
Pawel Glowacki,
Peter Michaux,
Philip Jägenstedt,
Philip Taylor,
Rashika Jaggi,
Robin Berjon,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ruud Steltenpool,
Ryo Onodera,
Sam Sneddon,
Sergiu Dumitriu,
Shivakumar Jagalur Matt,
Sigbjørn Finne,
Simon Pieters,
Stewart Brodie,
Sunava Dutta,
Takeshi Kurosawa,
Takeshi Yoshino,
Thomas Roessler,
Thomas Wisniewski,
Tom Magliery,
Travis Leithead,
triple-underscore,
Yaron Tausky,
Yehuda Katz,
Youenn Fablet, and
Zhenbin Xu

for their contributions to this standard.
</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://xhr.spec.whatwg.org/review-drafts/2024-02/">Living Standard Review Draft</a>.
</p>
</div>

</div>

