<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>XMLHttpRequest Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
.critical {
    margin: 1em;
    border: thick double #F00;
    padding: 1em;
    background: none repeat scroll 0% 0% #FFC;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = () => {
	const source_data = {
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:XMLHttpRequest
spec_date:2020-09-30
trans_update:2020-10-02
source_checked:200930
original_url:https://xhr.spec.whatwg.org/
spec_status:LS
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,storage,security
copyright:,whatwg
trans_1st_pub:2012-10-25


●●class_map
e:element
a:attr
et:event-type
E:error
sc:scheme
AO:abstract
hm:method
X:hex-value

●●tag_map
I:code
m:code
mb:code
c:code
e:code
a:code
et:code
E:code
hm:code
v:var
i:i
AO:span
X:span

●●words_table1

open_async:open
type0:type
send_:<code>send()</code> 

●●words_table

	●データ／型／IDL／演算
scalar::::スカラー
数量-:numeric:~
昇順:ascending order:~
無符号:unsigned:~

	●構文
	MIME:mime
backtick::::バッククォート
予走査:prescan::~
確定的:definite:~
名前空間整形式:namespace well formedness:名前空間 整形式
	settings object

	●XHR／network／stream
予行:preflight::~::プリフライト
伝送量:transmitted::~
本体終端:end-of-body:body 終端:~::ボディ終端
username::::ユーザ名
password::::パスワード
活動:activity::~
非安全:unsafe::~
結合-:combine::~
	結合-済み:combined
最終-:final::~
filename:::file 名:ファイル名
開いて:openして::~
	load:::

chunk::::チャンク
読取る:readする::読み取る
読取n:read::読み取り
読取器:reader::読み取り器::リーダ
close:
open:
	~openした:opened:
未送信:unsent::~
	読込n中:loading
	全~headerを受信した:headers received
	済み:done
done:

	headers::::ヘッダリスト
	~network用:networking
	受信-済み:received
	伝送-済み:transmitted

	●一般処理
	発火-法:firing
進行中の:ongoing:~
進行中:ongoing:~
終了-:terminate::~
時間切れ:timed out::~
	時間~切れ:preset time expiring
制限時間:timeout::~::タイムアウト
時間:time:~
経過-:pass:~
	-:fallback

	●仕様
opt-in::::オプトイン
末端利用者:end user:~:::エンドユーザ
節:section:~
要覧:summary:~
中止:aborted::~
	中止-済み:aborted
壊さな:breakしな:~
移管-:move:~
併合-:merge:~
観点:perspective:~
	experiment
過程:process:~
警告-:warn:~
許容list:allowlist:許容 list::許容リスト
精巧:elaborate:~

	typographic
	specification
	旧来のものでない:non-legacy
	施策により制御され:policy-controlled
	~~機能:working
	用例:example
	自由:free
	引用:
	当初:
	成果:
	固有の仔細:specific scenarios

	全般:Throughout
	不具合が生じた:went wrong
	~~互換性
	調べる:check
	~~調整:tune
	~~問題に馴染みのある人達の意見を汲む:ensure input from people familiar with the subject
	何年も:many years
	メーリングリスト
	一覧:table
	可能
	同様
	同類
	経緯
	~~規定:set forth

	●未分類（動詞
割振る:allocateする:割り振る
絞込まれ:filterされ::絞り込まれ
	interaction
集める:gatherする:~
	壊-:breaking
露呈-:reveal:~
	追従-済:have been followed
	過ぎた:passed
	出現
	開始:start, initiate, begin:

	●未分類
XSLT:
担当の:responsible::~
排他的:mutually exclusive:~
milli::::ミリ
	~milli秒:millisecond
	-:relative
	-:variable
	単位/数
	括弧内
	単位
	範囲:range
	計測:measure
	際限のない:infinite

	●変数
	%設定群~obj:settingsObject
	%解析済み~URL:parsedURL
	%抽出された内容~型:extractedContentType
	%元の作者~内容~型:originalAuthorContentType
	%内容~型~record:contentTypeRecord
	%~parameters:parameters
	%内容~型:-
	%要請:req
	%要請:request
	%伝送量:transmitted
	%長さ:length
	%応答:response
	%本体:-
	%読取n要請:readRequest
	%~chunk:chunk
	%読取器:reader
	%制限時間:-
	%~promise:promise
	%~byte列:bytes
	%xhr:xhr
	%~event型:event
	%例外:exception
	%url:-
	%出力:output
	%~header~list:headers
	%a:a
	%b:b
	%~header:header
	%~MIME型:mimeType
	%上書き~MIME型:-
	%~label:label
	%符号化法:encoding
	%charset:charset
	%最終-~MIME型:finalMIME
	%文書:document
	%W
	%~JSON~obj:jsonObject
	%名前:name
	%値:value
	%~filename:filename
	%~entry:entry
	%~list:list
	%target:target
	%e:e
	-:responseMIME


	●指示語
	無
	〜の後:after
	一連
	一部
	以下
	以上
	各種
	唯一
	全体:
	回
	個
	時点
	最終的
	時機:when
	回数:times
	場合
	重ねて:twice
	非:non


●●original_id_map

dom-formdata-iterable:
	handle-response-end-of-body:handle-response-end-of-file

●●mdn_urls
formdata:API/FormData
formdataentryvalue:API/FormDataEntryValue
progressevent:API/ProgressEvent
xmlhttprequest:API/XMLHttpRequest
xmlhttprequesteventtarget:API/XMLHttpRequestEventTarget
xmlhttprequestresponsetype:API/XMLHttpRequestResponseType
	xmlhttprequestupload:API/XMLHttpRequestUpload
	progresseventinit:API/ProgressEventInit

event-xhr-abort:API/XMLHttpRequest/abort_event
event-xhr-error:API/XMLHttpRequest/error_event
event-xhr-load:API/XMLHttpRequest/load_event
event-xhr-loadend:API/XMLHttpRequest/loadend_event
event-xhr-loadstart:API/XMLHttpRequest/loadstart_event
event-xhr-progress:API/XMLHttpRequest/progress_event
event-xhr-timeout:API/XMLHttpRequest/timeout_event
	event-xhr-readystatechange:API/？/readystatechange_event

●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject

E.AbortError:~WEBIDL#aborterror
E.SyntaxError:~WEBIDL#syntaxerror
E.SecurityError:~WEBIDL#securityerror
E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TimeoutError:~WEBIDL#timeouterror
E.NetworkError:~WEBIDL#networkerror

USVString:~WEBIDL#idl-USVString
I.USVString:~WEBIDL#idl-USVString
ByteString:~WEBIDL#idl-ByteString
DOMString:~WEBIDL#idl-DOMString
undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
unsigned long long:~WEBIDL#idl-unsigned-long-long
sequence:~WEBIDL#idl-sequence
any:~WEBIDL#idl-any


I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.FormData:#formdata
I.FormDataEntryValue:#formdataentryvalue
I.ProgressEvent:#progressevent
I.ProgressEventInit:#progresseventinit
I.XMLHttpRequest:#xmlhttprequest
I.XMLHttpRequestEventTarget:#xmlhttprequesteventtarget
I.XMLHttpRequestResponseType:#xmlhttprequestresponsetype
I.XMLHttpRequestUpload:#xmlhttprequestupload
I.XMLHttpRequestBodyInit:~FETCH#typedefdef-xmlhttprequestbodyinit
I.Window:~WINDOW#window
I.HTMLFormElement:~HEforms#htmlformelement


I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer


m.new XMLHttpRequest:#dom-xmlhttprequest
m.new FormData:#dom-formdata
	m.new ProgressEvent:#dom-progressevent-progressevent
mc.ProgressEvent:#dom-progressevent-progressevent

m.DONE:#dom-xmlhttprequest-done
m.HEADERS_RECEIVED:#dom-xmlhttprequest-headers_received
m.LOADING:#dom-xmlhttprequest-loading
m.OPENED:#dom-xmlhttprequest-opened
m.UNSENT:#dom-xmlhttprequest-unsent

m.onabort:#handler-xhr-onabort
m.onerror:#handler-xhr-onerror
m.onload:#handler-xhr-onload
m.onloadend:#handler-xhr-onloadend
m.onloadstart:#handler-xhr-onloadstart
m.onprogress:#handler-xhr-onprogress
m.onreadystatechange:#handler-xhr-onreadystatechange
m.ontimeout:#handler-xhr-ontimeout

m.abort:#dom-xmlhttprequest-abort
m.timeout:#dom-xmlhttprequest-timeout
m.type:~DOM4#dom-event-type
m.~type0:~FILEAPI#dfn-type
m.append:#dom-formdata-append
	#dom-formdata-append-blob
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.delete:#dom-formdata-delete
m.get:#dom-formdata-get
m.getAll:#dom-formdata-getall
m.getAllResponseHeaders:#dom-xmlhttprequest-getallresponseheaders
m.getResponseHeader:#dom-xmlhttprequest-getresponseheader
m.has:#dom-formdata-has
m.iterable:#dom-formdata-iterable
m.lengthComputable:#dom-progressevent-lengthcomputable
m.loaded:#dom-progressevent-loaded
m.name:~FILEAPI#dfn-name
m.open:#dom-xmlhttprequest-open
m.~open_async:#dom-xmlhttprequest-open-method-url-async-username-password
m.overrideMimeType:#dom-xmlhttprequest-overridemimetype
m.readyState:#dom-xmlhttprequest-readystate
m.response:#dom-xmlhttprequest-response
m.responseText:#dom-xmlhttprequest-responsetext
m.responseType:#dom-xmlhttprequest-responsetype
m.responseURL:#dom-xmlhttprequest-responseurl
m.responseXML:#dom-xmlhttprequest-responsexml
m.send:#dom-xmlhttprequest-send
m.set:#dom-formdata-set
	#dom-formdata-set-blob
m.setRequestHeader:#dom-xmlhttprequest-setrequestheader
m.status:#dom-xmlhttprequest-status
m.statusText:#dom-xmlhttprequest-statustext
m.total:#dom-progressevent-total
m.upload:#dom-xmlhttprequest-upload
m.withCredentials:#dom-xmlhttprequest-withcredentials

mb.lengthComputable:#dom-progresseventinit-lengthcomputable
mb.loaded:#dom-progresseventinit-loaded
mb.total:#dom-progresseventinit-total

	l.#dom-xmlhttprequestresponsetype
l.arraybuffer:#dom-xmlhttprequestresponsetype-arraybuffer
l.blob:#dom-xmlhttprequestresponsetype-blob
l.document:#dom-xmlhttprequestresponsetype-document
l.json:#dom-xmlhttprequestresponsetype-json
l.text:#dom-xmlhttprequestresponsetype-text

l.sync-xhr:#sync-xhr

et.abort:#event-xhr-abort
et.progress:#event-xhr-progress
et.error:#event-xhr-error
et.load:#event-xhr-load
et.loadend:#event-xhr-loadend
et.loadstart:#event-xhr-loadstart
et.readystatechange:#event-xhr-readystatechange
et.timeout:#event-xhr-timeout

e.progress:~HEforms#the-progress-element

h.Content-Type:~HTTPsem#field.content-type
hm.GET:~HTTPsem#GET
hm.HEAD:~HTTPsem#HEAD

	●用語
xhr.~upload~obj:#upload-object
xhr.状態:#concept-xmlhttprequest-state
xhr.~send_~flag:#send-flag
xhr.制限時間:#timeout
xhr.非同一-生成元~向け資格証あり？:#cross-origin-credentials
xhr.要請~method:#request-method
xhr.要請~URL:#request-url
xhr.作者~要請~header~list:#author-request-headers
xhr.要請~本体:#request-body
xhr.同期~flag:#synchronous-flag
xhr.~upload完了-~flag:#upload-complete-flag
xhr.~upload~listener~flag:#upload-listener-flag
xhr.時間切れ~flag:#timed-out-flag
xhr.応答:#response
xhr.受信した~byte列:#received-bytes
xhr.応答~種別:#response-type
xhr.応答~obj:#response-object
xhr.上書き~MIME型:#override-mime-type


最終-~MIME型を取得する:#final-mime-type
応答~MIME型を取得する:#response-mime-type
最終-符号化法を取得する:#final-charset
文書~応答を設定する:#document-response
~text応答を取得する:#text-response

進捗~eventを発火する:#concept-event-fire-progress

fe.~entry~list:#concept-formdata-entry-list
fe.~entry:#concept-formdata-entry
fe.名前:#concept-formdata-entry-name
fe.値:#concept-formdata-entry-value
~entryを作成する:#create-an-entry

要請~error手続きを走らす:#request-error-steps
~errorを取扱う:#handle-errors
本体終端を取扱う:#handle-response-end-of-body


	＊:#legacy-uppercased-byte-less-than

	●用語（外部
応答を処理する:~FETCH#process-response
要請の本体を処理する:~FETCH#process-request-body
要請の本体終端を処理する:~FETCH#process-request-end-of-body

~CORS予行~要請:~FETCH#cors-preflight-request

~fetchを終了-:~FETCH#concept-fetch-terminate
~fetchを終了させる:~FETCH#concept-fetch-terminate
~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
本体と内容~型を安全に抽出する:~FETCH#bodyinit-safely-extract
~header~listから~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
~method:~FETCH#concept-method
禁止~method:~FETCH#forbidden-method
禁止~header名:~FETCH#forbidden-header-name
hd.名前:~FETCH#concept-header-name
hd.値:~FETCH#concept-header-value
値を正規化する:~FETCH#concept-header-value-normalize
~header~listから値を取得する:~FETCH#concept-header-list-get
~header:~FETCH#concept-header
~header~list:~FETCH#concept-header-list
~headerを設定する:~FETCH#concept-header-list-set
~headerを付加する:~FETCH#concept-header-list-append
~headerを結合する:~FETCH#concept-header-list-combine
~header~listを~sortして結合する:~FETCH#concept-header-list-sort-and-combine
~network~error:~FETCH#concept-network-error
~methodを正規化する:~FETCH#concept-method-normalize

要請:~FETCH#concept-request
rq.~header~list:~FETCH#concept-request-header-list
rq.本体:~FETCH#concept-request-body
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.同期~flag:~FETCH#synchronous-flag
rq.非安全~要請~flag:~FETCH#unsafe-request-flag
rq.~CORS予行~利用~flag:~FETCH#use-cors-preflight-flag
rq.~done~flag:~FETCH#done-flag

応答:~FETCH#concept-response
rs.中止~flag:~FETCH#concept-response-aborted
rs.~URL:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.状態s~message:~FETCH#concept-response-status-message

~CORS~protocol:~FETCH#cors-protocol

bd.伝送-済み~byte数:~FETCH#concept-body-transmitted
bd.総~byte数:~FETCH#concept-body-total-bytes
bd.~stream:~FETCH#concept-body-stream

資格証:~FETCH#credentials

読取n要請:~STREAMS#read-request
rR.~chunk手続き:~STREAMS#read-request-chunk-steps
rR.~close手続き:~STREAMS#read-request-close-steps
rR.~error手続き:~STREAMS#read-request-error-steps
RS.読取器を取得する:~STREAMS#readablestream-get-a-reader
RS.~errorした:~STREAMS#readablestream-errored
RSR.すべての~byteを読取る:~STREAMS#readablestreamdefaultreader-read-all-bytes
readablestream
RSR.~chunkを読取る:~STREAMS#readablestreamdefaultreader-read-a-chunk

~byte列:~INFRA#byte-sequence
~byte文字大小無視:~INFRA#byte-case-insensitive
~ASCII大小無視:~INFRA#ascii-case-insensitive
~JSON~byte列を~JS値に構文解析する:~INFRA#parse-json-bytes-to-a-javascript-value
	廃）~byte列を~JSONとして構文解析する:~INFRA#parse-json-from-bytes
~byte大文字~化する:~INFRA#byte-uppercase
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
小なり~algo:~INFRA#_less-than-algorithm
未満の~byte列:~INFRA#byte-less-than

~list:~INFRA#list
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
置換する:~INFRA#list-replace
~scalar値~文字列に変換する:~INFRA#javascript-string-convert

~event:~DOM4#concept-event
~event~listener:~DOM4#concept-event-listener
~eventを発火する:~DOM4#concept-event-fire
配送-:~DOM4#concept-event-dispatch
文書:~DOM4#concept-document
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document

doc.符号化法:~DOM4#concept-document-encoding
doc.内容~型:~DOM4#concept-document-content-type
doc.~URL:~DOM4#concept-document-url
doc.種別:~DOM4#concept-document-type
doc.生成元:~DOM4#concept-document-origin

~UTF-8:~ENCODING#utf-8
~UTF-8符号化-:~ENCODING#utf-8-encode
~UTF-8符号化する:~ENCODING#utf-8-encode
~Unicodeに復号する:~ENCODING#decode
~labelから符号化法を取得する:~ENCODING#concept-encoding-get

反復される値~pairたち:~WEBIDL#dfn-value-pairs-to-iterate-over
新たな:~WEBIDLjs#new
~interface~obj:~WEBIDLjs#dfn-interface-object

~URL:~URL1#concept-url
url.~host:~URL1#concept-url-host
~URLを直列化する:~URL1#concept-url-serializer
~URL構文解析する:~URL1#concept-url-parser
~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password
資格証を含む:~URL1#include-credentials

	HTML

特能の利用は許容されて:~HEembed#allowed-to-use

~task:~WAPI#concept-task
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
~event~handler:~WAPI#event-handlers
~event~handler ~event型:~WAPI#event-handler-event-type
~network用~task源:~WAPI#networking-task-source

現在の大域~obj:~WAPI#current-global-object
関連な設定群~obj:~WAPI#relevant-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
enV.担当の文書:~WAPI#responsible-document
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~API用~URL文字~符号化法:~WAPI#api-url-character-encoding

全部的に作動中:~BROWSERS#fully-activ

~entry~listを構築する:~HTMLforms#constructing-the-form-data-set
並列的:~HTMLINFRA#in-parallel

	:~HTMLparsing#a-known-definite-encoding
	:~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding
	:~HTMLxml#xml-parser
	:~HTMLxml#xml-scripting-support-disabled


施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature
既定の許容list:~PERMISSIONS-POLICY#default-allowlist

~MIME型:~MIMESNIFF#mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type
~byte列から~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type-from-bytes
~MIME型を~byte列に直列化する:~MIMESNIFF#serialize-a-mime-type-to-bytes
~parameters:~MIMESNIFF#parameters

素片を直列化する:~DOM-Parsing#dfn-fragment-serializing-algorithm

_acks1:#_acks1
_ipr1:#_ipr1

●●ref_normative

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[DOM-PARSING]
    Travis Leithead. DOM Parsing and Serialization. URL: https://w3c.github.io/DOM-Parsing/ 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.es/ecma262/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FEATURE-POLICY]
    Ian Clelland. Permissions Policy. URL: https://w3c.github.io/webappsec-permissions-policy/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FILEAPI]
    Marijn Kruisselbrink; Arun Ranganathan. File API. URL: https://w3c.github.io/FileAPI/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[STREAMS]
    Adam Rice; Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml/ 
[XML-NAMES]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/ 

●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.whatwg.org/">WHATWG</a>
による
<a href="~SPEC_URL">XMLHttpRequest Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/xhr">GitHub whatwg/xhr</a> (<a href="https://github.com/whatwg/xhr/issues/new">new issue</a>, <a href="https://github.com/whatwg/xhr/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/xhr/commits
	<a href="https://xhr.spec.whatwg.org/commit-snapshots/17980b7ac6586761baee2124bc240bacd10435db/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/xhrstandard">@xhrstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/xhr">web-platform-tests xhr/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/xhr">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>
<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgc3Ryb2tlLXdpZHRoPSIxMCIgZmlsbD0iI2ZmZiIvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgZD0iTTE3LDY2QzIxLDYzLDQzLDc2LDM3LDY4TTMzLDc1YTgsOCwwLDAsMTYsOE01MCw4NEM2OCw0OSw1Nyw5MCw2Myw3Nyw2Niw1OCw3NSw4Nyw3MSw2OSw2OCw2Miw3NCw2NSw3OCw2Nk02NSw2MkM1Nyw2NCw2NCw3MSw2Nyw2NE00Nyw2MEw0Myw2OSw0NCw2OSw1MSw2Nk01MCw1MkM0Nyw2MCw1Myw1NCw1Miw2MCw1MCw2OCw2Miw2MCw1Nyw2Miw1OCw1NCw2NSw2MCw1OSw1NCw0OCw0MiwyMCwyNSwyOSwzN00yOSw0MEMyMyw1MCwyNyw0NywyOSw0OE0zMywzN0MyOCw0MiwzNywzOCwzNSw0MiwzNCw0NCwzMCwzOCwzMiw0OCwzMSw1MCwzNiw1MiwyOCw1ME0zMiw1M0wyOCw1Mk0zMCw1M0MyOCw1NSwyNSw1NywzMCw2MSwzMiw2MiwzMiw2NSwzOCw2Miw0MCw2MSw0Myw2Myw0NCw1Nyw0NCw1Niw0OCw1Miw0NCw0OEw0NSw0NSw0MSw0Miw0MCw0Myw0MSw0NywzOSw1MCwzNSw1MU0zMiwzMUM0MywzMCw1MCwxNiw2NCwyM000MywzN0M1NCwyOCw0OSw1Niw2OSw0OCw4Miw0MCw3OCwyMSw2OCwyMEw2OCwyNkM3MiwyOSw3MiwyOSw3MiwzMyIvPgo8L3N2Zz4K"
></a>
	<hgroup>
<h1 id="title">XMLHttpRequest</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
XMLHttpRequest Standard は、~clientと~server間の~data転送~用の，~client側の~script機能性を供する~APIを定義する。
◎
The XMLHttpRequest Standard defines an API that provides scripted client functionality for transferring data between a client and a server.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
`XMLHttpRequest$I ~objは、`~fetching$用の~APIである。
◎
The XMLHttpRequest object is an API for fetching resources.
</p>

<p>
`XMLHttpRequest$I という名前は歴史的なものであり、
【 “XML” の部分は】
その機能性と何ら関わりは無い。
◎
The name XMLHttpRequest is historical and has no bearing on its functionality.
</p>

<div class="example" id="example-xhr">

<p>
~network越しに~fetchされた~XML文書の~dataに対し何かを行う，単純な~code：
◎
Some simple code to do something with data from an XML document fetched over the network:
</p>

<pre class="lang-js">
function processData(%data) {
  /* <span class="comment">
~dataを~~処理する
◎
taking care of data
</span> */
}

function handler() {
  if(this.status == 200 &amp;&amp;
    this.responseXML != null &amp;&amp;
    this.responseXML.getElementById('test').textContent) {
    /* <span class="comment">
成功！
◎
success!
</span> */
    processData(this.responseXML.getElementById('test').textContent);
  } else {
    /* <span class="comment">
何らかの不具合が生じている
◎
something went wrong
</span> */
    …
  }
}

var %client = new XMLHttpRequest();
%client.onload = handler;
%client.open("GET", "unicorn.xml");
%client.send();
</pre>

<p>
単に~serverに~messageを残す：
◎
If you just want to log a message to the server:
</p>

<pre class="lang-js">
function log(%message) {
  var %client = new XMLHttpRequest();
  %client.open("POST", "/log");
  %client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
  %client.send(%message);
}
</pre>

<p>
あるいは、~serverにある文書の状態sを調べる：
◎
Or if you want to check the status of a document on the server:
</p>

<pre class="lang-js">
function fetchStatus(%address) {
  var %client = new XMLHttpRequest();
  %client.onload = function() {
    /* <span class="comment">
~network~errorが生じている場合、依拠-可能な結果は得られないであろう。
◎
in case of network errors this might not give reliable results
</span> */
    returnStatus(this.status);
  }
  %client.open("HEAD", %address);
  %client.send();
}
</pre>

</div>

		<section id="specification-history">
<h3 title="Specification history">1.1. 仕様の歴史</h3>

<p>
`XMLHttpRequest$I ~objは、当初は WHATWG による， HTML の（何年も前の、 Microsoft による実装に基づく）成果として定義された。
それは 2006 年には W3C に移管された。
`XMLHttpRequest$I に対する拡張（すなわち、進捗~event, 非同一-生成元（ cross-origin ）要請）は、 2011 年の終わりまでは別の草案（ XMLHttpRequest Level 2 ）の下で開発されていたが、その時点でこの 2 つの草案は `XMLHttpRequest$I に併合され，標準の観点から再び一つになった。
2012 年の終わりに，また WHATWG の下に移管されることとなった。
◎
The XMLHttpRequest object was initially defined as part of the WHATWG’s HTML effort. (Based on Microsoft’s implementation many years prior.) It moved to the W3C in 2006. Extensions (e.g., progress events and cross-origin requests) to XMLHttpRequest were developed in a separate draft (XMLHttpRequest Level 2) until end of 2011, at which point the two drafts were merged and XMLHttpRequest became a single entity again from a standards perspective. End of 2012 it moved back to the WHATWG.
</p>

<p>
現在の草案までに至る経緯は、次のメーリングリストにて見られる：
◎
Discussion that led to the current draft can be found in the following mailing list
archives:
</p>

<ul><li><a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/">whatwg@whatwg.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-webapi/">public-webapi@w3.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-appformats/">public-appformats@w3.org</a>
</li></ul>

		</section>
	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、次に挙げる仕様による各種用語を利用する
⇒
`DOM$r
`DOM-PARSING$r
`ENCODING$r
`FEATURE-POLICY$r
`FETCH$r
`FILEAPI$r
`HTML$r
`URL$r
`WEBIDL$r
`XML$r
`XML-NAMES$r
◎
This specification uses terminology from DOM, DOM Parsing and Serialization, Encoding, Feature Policy, Fetch, File API, HTML, URL, Web IDL, and XML.
◎
[DOM] [DOM-PARSING] [ENCODING] [FEATURE-POLICY] [FETCH] [FILEAPI] [HTML] [URL] [WEBIDL] [XML] [XML-NAMES]
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="interface-xmlhttprequest">
<h2 title="Interface XMLHttpRequest">3. ~interface `XMLHttpRequest^I</h2>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestEventTarget@I : `EventTarget$I {
  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `ontimeout$m;
  attribute `EventHandler$I `onloadend$m;
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestUpload@I : `XMLHttpRequestEventTarget$I {
};

enum `XMLHttpRequestResponseType@I {
  <dfn id="#dom-xmlhttprequestresponsetype">""</dfn>,
  `arraybuffer@l,
  `blob@l,
  `document@l,
  `json@l,
  `text@l
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequest@I : `XMLHttpRequestEventTarget$I {
  `XMLHttpRequest$mc();

  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onreadystatechange$m;

  // <span class="comment">状態</span>
  const `unsigned short$ `UNSENT$m = 0;
  const `unsigned short$ `OPENED$m = 1;
  const `unsigned short$ `HEADERS_RECEIVED$m = 2;
  const `unsigned short$ `LOADING$m = 3;
  const `unsigned short$ `DONE$m = 4;
  readonly attribute `unsigned short$ `readyState$m;

  // <span class="comment">要請</span>
  `undefined$ `open$m(`ByteString$ %method, `USVString$ %url);
  `undefined$ `~open_async$m(
      `ByteString$ %method,
      `USVString$ %url,
      `boolean$ %async,
      optional `USVString$? %username = null,
      optional `USVString$? %password = null
  );
  `undefined$ `setRequestHeader$m(`ByteString$ %name, `ByteString$ %value);
           attribute `unsigned long$ `timeout$m;
           attribute `boolean$ `withCredentials$m;
  [`SameObject$] readonly attribute `XMLHttpRequestUpload$I `upload$m;
  `undefined$ `send$m(optional (`Document$I or `XMLHttpRequestBodyInit$I)? %body = null);
  `undefined$ `abort$m();

  // <span class="comment">応答</span>
  readonly attribute `USVString$ `responseURL$m;
  readonly attribute `unsigned short$ `status$m;
  readonly attribute `ByteString$ `statusText$m;
  `ByteString$? `getResponseHeader$m(`ByteString$ %name);
  `ByteString$ `getAllResponseHeaders$m();
  `undefined$ `overrideMimeType$m(`DOMString$ %mime);
           attribute `XMLHttpRequestResponseType$I `responseType$m;
  readonly attribute `any$ `response$m;
  readonly attribute `USVString$ `responseText$m;
  [`Exposed$=Window] readonly attribute `Document$I? `responseXML$m;
};
</pre>

<p>
各 `XMLHttpRequest$I ~objには、次に挙げるものが結付けられる：
◎
An XMLHttpRequest object has an associated:
</p>
<dl class="def-list">
	<dt>
`~upload~obj@xhr
◎
upload object
</dt>
	<dd>
`XMLHttpRequestUpload$I ~obj。
◎
An XMLHttpRequestUpload object.
</dd>

	<dt>
`状態@xhr
◎
state
</dt>
	<dd>
次に挙げるいずれか
— 初期~時には `未送信^i とする
⇒＃
`未送信^i ／
`~openした^i ／
`全~headerを受信した^i ／
`読込n中^i ／
`済み^i
◎
One of unsent, opened, headers received, loading, and done; initially unsent.
</dd>

	<dt>
`~send_~flag@xhr
◎
send() flag
</dt>
	<dd>
真偽値
— 初期~時には ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`制限時間@xhr
◎
timeout
</dt>
	<dd>
無符号~整数【~milli秒~~単位】
— 初期~時には 0 とする。
◎
An unsigned integer, initially 0.
</dd>

	<dt>
`非同一-生成元~向け資格証あり？@xhr
◎
cross-origin credentials
</dt>
	<dd>
真偽値
— 初期~時には ~F とする。
◎
A boolean, initially false.
</dd>

	<dt>
`要請~method@xhr
◎
request method
</dt>
	<dd>
`~method$
◎
A method.
</dd>

	<dt>
`要請~URL@xhr
◎
request URL
</dt>
	<dd>
`~URL$。
◎
A URL.
</dd>

	<dt>
`作者~要請~header~list@xhr
◎
author request headers
</dt>
	<dd>
`~header~list$
— 初期~時には空とする。
◎
A header list, initially empty.
</dd>

	<dt>
`要請~本体@xhr
◎
request body
</dt>
	<dd>
初期~時には~NULL とする。
◎
Initially null.
</dd>

	<dt>
`同期~flag@xhr
◎
synchronous flag
</dt>
	<dd>
真偽値
— 初期~時には ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`~upload完了-~flag@xhr
◎
upload complete flag
</dt>
	<dd>
真偽値
— 初期~時には ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`~upload~listener~flag@xhr
◎
upload listener flag
</dt>
	<dd>
真偽値
— 初期~時には ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`時間切れ~flag@xhr
◎
timed out flag
</dt>
	<dd>
真偽値
— 初期~時には ~F とする。
◎
A flag, initially unset.
</dd>

	<dt>
`応答@xhr
◎
response
</dt>
	<dd>
`応答$
— 初期~時には`~network~error$とする。
◎
A response, initially a network error.
</dd>

	<dt>
`受信した~byte列@xhr
◎
received bytes
</dt>
	<dd>
`~byte列$
— 初期~時には空~byte列とする。
◎
A byte sequence, initially the empty byte sequence.
</dd>

	<dt>
`応答~種別@xhr
◎
response type
</dt>
	<dd>
次に挙げるいずれか
— 初期~時には空~文字列とする
⇒＃
空~文字列 ／
`arraybuffer^l ／
`blob^l ／
`document^l ／
`json^l ／
`text^l
◎
One of the empty string, "arraybuffer", "blob", "document", "json", and "text"; initially the empty string.
</dd>

	<dt>
`応答~obj@xhr
◎
response object
</dt>
	<dd>
次に挙げるいずれか
— 初期~時には ~NULL とする
⇒＃
~obj【これは、`応答$xhrの本体~dataを表現する】／
`失敗^i ／
~NULL
◎
An object, failure, or null, initially null.
</dd>

	<dt>
`上書き~MIME型@xhr
◎
override MIME type
</dt>
	<dd>
`~MIME型$または ~NULL
— 初期~時には ~NULL とする。
◎
A MIME type or null, initially null.＼
</dd>
	<dd class="note">注記：
`overrideMimeType()$m を呼出したときに，非 ~NULL にされ得る。
◎
Can get a value when overrideMimeType() is invoked.
</dd>
</dl>

		<section id="constructors">
<h3 title="Constructors">3.1. 構築子</h3>

<dl class="domintro">
	<dt>%client = `new XMLHttpRequest()$m</dt>
	<dd>
新たな `XMLHttpRequest$I ~objを返す。
◎
Returns a new XMLHttpRequest object.
</dd>
</dl>

<div class="algo">
`new XMLHttpRequest()@m
構築子~手続きは
⇒
コレの`~upload~obj$xhr ~SET `新たな$ `XMLHttpRequestUpload$I ~obj
◎
The new XMLHttpRequest() constructor steps are:
• Set this’s upload object to a new XMLHttpRequestUpload object.
</div>

		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">3.2. ~garbage収集</h3>

<p>
`XMLHttpRequest$I ~objは、次をいずれも満たしている間は，~garbage収集しないモノトスル：
◎
An XMLHttpRequest object must not be garbage collected if＼
</p>
<ul>
	<li>
<p>
次のいずれかを満たしている：
</p>
		<ul>
			<li>
［
`状態$xhr ~EQ `~openした^i
］~AND［
`~send_~flag$xhr ~EQ ~T
］
</li>
			<li>
`状態$xhr ~IN { `全~headerを受信した^i, `読込n中^i }
</li>
		</ul>
◎
its state is either opened with the send() flag set, headers received, or loading,＼
</li>
	<li>
次に挙げるいずれかの型の~event用に`~event~listener$が登録されている
⇒
`readystatechange$et,
`progress$et,
`abort$et,
`error$et,
`load$et,
`timeout$et,
`loadend$et
◎
and it has one or more event listeners registered whose type is one of readystatechange, progress, abort, error, load, timeout, and loadend.
</li>
</ul>

<p>
`XMLHttpRequest$I ~objが，その接続がまだ開いているにも関わらず~garbage収集された場合、~UAは，~objが演算している進行中の`~fetchを終了-$させるモノトスル。
◎
If an XMLHttpRequest object is garbage collected while its connection is still open, the user agent must terminate the ongoing fetch operated by the XMLHttpRequest object. 
</p>

		</section>
		<section id="event-handlers">
<h3 title="Event handlers">3.3. ~event~handler</h3>

<p>
`XMLHttpRequestEventTarget$I を継承する~interfaceを実装する~objは、次の`~event~handler$（およびそれらに対応する`~event~handler ~event型$）を属性として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on objects implementing an interface that inherits from XMLHttpRequestEventTarget as attributes:
</p>

<table><thead>
<tr><th>`~event~handler$
◎
event handler
<th>`~event~handler ~event型$
◎
event handler event type
</thead><tbody>

<tr><td>`onloadstart@m
<td>`loadstart$et

<tr><td>`onprogress@m
<td>`progress$et

<tr><td>`onabort@m
<td>`abort$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onload@m
<td>`load$et

<tr><td>`ontimeout@m
<td>`timeout$et

<tr><td>`onloadend@m
<td>`loadend$et

</tbody></table>

<p>
`XMLHttpRequest$I ~objにおいては、次の`~event~handler$（および対応する
`~event~handler ~event型$）も属性として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported as attribute solely by the XMLHttpRequest object:
</p>

<table><thead>
<tr><th>`~event~handler$
◎
event handler
<th>`~event~handler ~event型$
◎
event handler event type
</thead><tbody>

<tr><td>`onreadystatechange@m
<td>`readystatechange$et

</tbody></table>

		</section>
		<section id="states">
<h3 title="States">3.4. 状態</h3>

<dl class="domintro">
	<dt>%client . `readyState$m</dt>
	<dd>
`状態$xhrを返す。
◎
Returns client’s state.
</dd>
</dl>

<div class="algo">
<p>
`readyState@m
取得子~手続きは
⇒
~RET コレの`状態$xhrが下の表の 1 列目のいずれであるかに応じて，同じ行の 2 列目に示される値：
◎
The readyState getter steps are to return the value from the table below in the cell of the second column, from the row where the value in the cell in the first column is this’s state:
</p>

<table><thead>
<tr><th>`状態$xhr
<th>値（ 数量-値 ）
<th>記述
</thead><tbody>

<tr><td>`未送信^i
<td>`UNSENT@m （ 0 ）
<td>
~objは構築-済みである。
◎
The object has been constructed.

<tr><td>`~openした^i
<td>`OPENED@m （ 1 ）
<td>
`open()$m ~methodは成功裡に呼出された。
この状態~下では、
`setRequestHeader$m を利用して要請~headerを設定でき，
`send$m ~methodを利用して~fetchを起動できる。
◎
The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the fetch can be initiated using the send() method.

<tr><td>`全~headerを受信した^i
<td>`HEADERS_RECEIVED@m （ 2 ）
<td>
すべての~redirect（もしあれば）は追従-済みであり，かつ
応答のすべての~headerは受信-済みである。
◎
All redirects (if any) have been followed and all headers of a response have been received.

<tr><td>`読込n中^i
<td>`LOADING@m （ 3 ）
<td>
応答~本体を受信-中にある。
◎
The response body is being received.

<tr><td>`済み^i
<td>`DONE@m （ 4 ）
<td>
~data転送が完了しているか, または転送~中に何らかの不具合が生じた（例えば，際限のない~redirect）。
◎
The data transfer has been completed or something went wrong during the transfer (e.g., infinite redirects).

</tbody></table>
</div>

		</section>
		<section id="request">
<h3 title="Request">3.5. 要請</h3>

<p class="note" id="event-listeners-and-preflight">注記：
`XMLHttpRequestUpload$I ~obj上に 1 個~以上の~event~listenerを登録すると，`~CORS予行~要請$が発行されることになる。
（~event~listenerが登録されると`~upload~listener~flag$xhrは ~T になり，それにより`~CORS予行~利用~flag$rqも ~T になるので。）
◎
Registering one or more event listeners on an XMLHttpRequestUpload object will result in a CORS-preflight request. (That is because registering an event listener causes the upload listener flag to be set, which in turn causes the use-CORS-preflight flag to be set.)
</p>

			<section id="the-open()-method">
<h4 title="The open() method">3.5.1. `open()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `open$m(%method, %url [, %async = true [, %username = null [, %password = null]]])</dt>
	<dd>
［
`要請~method$xhr,
`要請~URL$xhr,
`同期~flag$xhr
］を設定する。
◎
Sets the request method, request URL, and synchronous flag.
</dd>
	<dd>
次のいずれかに該当する場合、
`SyntaxError$E 例外が投出される
⇒＃
%method は妥当な~methodでない／
%url を構文解析できない
◎
Throws a "SyntaxError" DOMException if either method is not a valid method or url cannot be parsed.
</dd>
	<dd>
次に該当する場合、
`SecurityError$E 例外が投出される
⇒
%method は次のいずれかに文字大小無視で合致する
⇒
`CONNECT^h ／ `TRACE^h ／ `TRACK^h
◎
Throws a "SecurityError" DOMException if method is a case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.
</dd>
	<dd>
<p>
次のすべてが満たされている下では、
`InvalidAccessError$E 例外が投出される：
</p>
<ul ><li>%async ~EQ ~F
</li><li>`現在の大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空~文字列
］
</li></ul>

◎
Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
</dd>
</dl>

<p class="critical" id="sync-warning">
~worker以外での同期的 `XMLHttpRequest$I は、末端利用者をひどく待たせることになりかねないので， Web ~platformから除去されつつある過程にある（何年もかかるであろう）。
開発者は、［
`現在の大域~obj$は `Window$I ~objである
］場合には， %async 引数に ~F を渡してはナラナイ。
~UA には、開発者~用~toolにおいて，その種の用法に対し警告することが強く奨励される
— 
それが生じたときに，
`InvalidAccessError$E 例外を投出するように、試験的に実装してもよい。
◎
Synchronous XMLHttpRequest outside of workers is in the process of being removed from the web platform as it has detrimental effects to the end user’s experience. (This is a long process that takes many years.) Developers must not pass false for the async argument when current global object is a Window object. User agents are strongly encouraged to warn about such usage in developer tools and may experiment with throwing an "InvalidAccessError" DOMException when it occurs.
</p>

<div class="algo">
<p>
`open(method, url)@m
／
`~open_async(method, url, async, username, password)@m
~method手続きは：
◎
The open(method, url) and open(method, url, async, username, password) method steps are:
</p>
<ol>
	<li>
%設定群~obj ~LET コレに`関連な設定群~obj$
◎
Let settingsObject be this’s relevant settings object.
</li>
	<li>
~IF［
%設定群~obj には`担当の文書$enVがあって，それは`全部的に作動中$ではない
］
⇒
~THROW `InvalidStateError$E
◎
If settingsObject has a responsible document and it is not fully active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%method は`~method$でない
］
⇒
~THROW `SyntaxError$E
◎
If method is not a method, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%method は`禁止~method$である
］
⇒
~THROW `SecurityError$E
◎
If method is a forbidden method, then throw a "SecurityError" DOMException.
</li>
	<li>
%method ~SET `~methodを正規化する$( %method )
◎
Normalize method.
</li>
	<li>
%解析済み~URL ~LET `~URL構文解析する$( %url, %設定群~obj の`~API用~URL文字~符号化法$enV )
◎
Let parsedURL be the result of parsing url with settingsObject’s API base URL and settingsObject’s API URL character encoding.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
<p>
~IF［
%async ~EQ ε
］
⇒
( %async, %username, %password ) ~SET ( true, ~NULL, ~NULL )
◎
If the async argument is omitted, set async to true, and set username and password to null.
</p>

<p class="note">注記：
あいにく，旧来の内容と~~互換性を得るため、 %async 引数に `undefined^c が渡された場合と省略された場合とを，同じに扱うわけにはいかない。
◎
Unfortunately legacy content prevents treating the async argument being undefined identical from it being omitted.
</p>
	</li>
	<li>
<p>
~IF［
%解析済み~URL の`~host$url ~NEQ ~NULL
］：
◎
If parsedURL’s host is non-null, then: 
</p>
		<ol>
			<li>
~IF［
%username ~NEQ ~NULL
］
⇒
`~URLの~usernameを設定する$( %解析済み~URL, %username )
◎
If the username argument is not null, set the username given parsedURL and username.
</li>
			<li>
~IF［
%password ~NEQ ~NULL
］
⇒
`~URLの~passwordを設定する$( %解析済み~URL, %password )
◎
If the password argument is not null, set the password given parsedURL and password.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次がいずれも満たされる
］…：
</p>
		<ul>
			<li>
%async ~EQ ~F
</li>
			<li>
`現在の大域~obj$は `Window$I ~objである
</li>
			<li>
［
コレの`制限時間$xhr ~NEQ 0
］~OR［
コレの`応答~種別$xhr ~NEQ 空~文字列
］
</li>
		</ul>
<p>
…ならば
⇒
~THROW `InvalidAccessError$E
</p>

◎
If async is false, the current global object is a Window object, and either this’s timeout is not 0 or this’s response type is not the empty string, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
<p>
コレが演算している進行中の`~fetchを終了させる$
◎
Terminate the ongoing fetch operated by the XMLHttpRequest object. 
</p>

<p class="note">注記：
この時点から，`~fetching$は進行中になり得るようになる。
◎
A fetch can be ongoing at this point.
</p>
	</li>
	<li>
<p>
コレの
⇒＃
`~send_~flag$xhr ~SET ~F,
`~upload~listener~flag$xhr ~SET ~F,
`要請~method$xhr ~SET %method,
`要請~URL$xhr ~SET %解析済み~URL,
`同期~flag$xhr ~SET ［ %async ~EQ ~F ならば ~T ／ ~ELSE_ ~F ］,
`応答$xhr ~SET `~network~error$,
`受信した~byte列$xhr ~SET 空~byte列,
`応答~obj$xhr ~SET ~NULL
◎
Set variables associated with the object as follows:
• Unset this’s send() flag.
• Unset this’s upload listener flag.
• Set this’s request method to method.
• Set this’s request URL to parsedURL.
• Set this’s synchronous flag if async is false; otherwise unset this’s synchronous flag.
• Empty this’s author request headers.
• Set this’s response to a network error.
• Set this’s received bytes to the empty byte sequence.
• Set this’s response object to null.
</p>

<p class="note">注記：
`上書き~MIME型$xhrは、ここでは上書きされない
— `open()^m ~methodより前に `overrideMimeType()$m ~methodが呼出されることもあるので。
◎
Override MIME type is not overridden here as the overrideMimeType() method can be invoked before the open() method.
</p>
	</li>
	<li>
コレの`作者~要請~header~list$xhrを空にする
◎
↑</li>
	<li>
<p>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］：
◎
If this’s state is not opened, then:
</p>
		<ol>
			<li>
コレの`状態$xhr ~SET `~openした^i
◎
Set this’s state to opened.
</li>
			<li>
コレに向けて，名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</li>
		</ol>
	</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there are two open() methods defined is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

			</section>
			<section id="the-setrequestheader()-method">
<h4 title="The setRequestHeader() method">3.5.2. `setRequestHeader()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `setRequestHeader(name, value)$m</dt>
	<dd>
<p>
`作者~要請~header~list$xhrの中で，所与の %name の`~header$に %value を結合する
◎
Combines a header in author request headers.
</dd>
	<dd>
次のいずれかが満たされる場合、
`InvalidStateError$E 例外が投出される
⇒＃
`状態$xhr ~NEQ `~openした^i ／
`~send_~flag$xhr ~EQ ~T
◎
Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
</dd>
	<dd>
次のいずれかが満たされる場合、
`SyntaxError$E 例外が投出される
⇒＃
%name は~header名でない／
%value は~header値でない
◎
Throws a "SyntaxError" DOMException if name is not a header name or if value is not a header value.
</dd>
</dl>

<div class="algo">
<p>
`setRequestHeader(name, value)@m
~method手続きは：
◎
The setRequestHeader(name, value) method must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~send_~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%value ~SET `値を正規化する$( %value )
◎
Normalize value.
</li>
	<li>
<p>
~IF［
%name は`名前$hdでない
］~OR［
%value は`値$hdでない
］
⇒
~THROW `SyntaxError$E
◎
If name is not a name or value is not a value, then throw a "SyntaxError" DOMException.
</p>

<p class="note">注記：
空~byte列は空な`~header$ `値$hdを表現する。
◎
An empty byte sequence represents an empty header value.
</p>
	</li>
	<li>
~IF［
%name は`禁止~header名$である
］
⇒
~RET
◎
If name is a forbidden header name, then return.
</li>
	<li>
コレの`作者~要請~header~list$xhr内で`~headerを結合する$( %name / %value )
◎
Combine name/value in this’s author request headers.
</li>
</ol>
</div>

<div class="example" id="example-setting-header-twice">

<p>
同じ~headerを重ねて設定した場合に何が起こるかデモるための，単純な~code：
◎
Some simple code demonstrating what happens when setting the same header twice:
◎
// The following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open('GET', 'demo.cgi');
%client.setRequestHeader('X-Test', 'one');
%client.setRequestHeader('X-Test', 'two');
%client.send();
</pre>

<p>
この~scriptによる結果、次の~headerが送信される：
◎
// …results in the following header being sent:
</p>

<pre class="lang-http">
X-Test: one, two
</pre>
</div>

			</section>
			<section id="the-timeout-attribute">
<h4 title="The timeout getter and setter">3.5.3. `timeout^m 取得子／設定子</h4>

<dl class="domintro">
	<dt>%client . `timeout$m</dt>
	<dd>
時間を~milli秒~~単位で設定できる。
0 でない値に設定された場合、所与の時間が経過した時点で，`~fetching$は終了させられる。
その時点で要請がまだ完了していない場合、コレの`同期~flag$xhrが［
~F ならば `timeout$et ~eventが`配送-$される／
~T ならば `TimeoutError$E 例外が投出される
］ことになる（ `send()$m ~methodに対して）。
◎
Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and this’s synchronous flag is unset, a timeout event will then be dispatched, or a "TimeoutError" DOMException will be thrown otherwise (for the send() method).
</dd>
	<dd>
設定子は、次が満たされている下では，
`InvalidAccessError$E 例外を投出する
⇒
［
`同期~flag$xhr ~EQ ~T
］~AND［
`現在の大域~obj$は `Window$I ~objである
］
◎
When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
</dd>
</dl>

<div class="algo">
`timeout@m
取得子~手続きは
⇒
~RET コレの`制限時間$xhr
◎
The timeout getter steps are to return this’s timeout.
</div>

<div class="algo">
<p>
`timeout$m 設定子~手続きは：
◎
The timeout setter steps are:
</p>
<ol>
	<li>
~IF［
`現在の大域~obj$は `Window$I ~objである
］~AND［
コレの`同期~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If the current global object is a Window object and this’s synchronous flag is set, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
コレの`制限時間$xhr ~SET 所与の値
◎
Set this’s timeout to the given value.
</li>
</ol>

<p class="note">注記：
これにより，`~fetching$が進捗~中にある間でも、
`timeout$m 属性を設定-可能になる。
設定しても、計測の起点（ `~fetching$が開始された時点）が改められることはない。
◎
This implies that the timeout attribute can be set while fetching is in progress. If that occurs it will still be measured relative to the start of fetching.
</p>
</div>

			</section>
			<section id="the-withcredentials-attribute">
<h4 title="The withCredentials getter and setter">3.5.4. `withCredentials^m 取得子／設定子</h4>

<dl class="domintro">
	<dt>%client . `withCredentials$m</dt>
	<dd>
`資格証$が非同一-生成元~要請に含められることになるときは ~T。
非同一-生成元~要請から除外され，その応答における~cookieは無視されることになるときは ~F。
初期~時は ~F 。
◎
True when credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
</dd>
	<dd>
設定子は、次のいずれかが満たされる下では，
`InvalidStateError$E 例外を投出する
⇒＃
`状態$xhr ~NIN { `未送信^i, `~openした^i } ／
`~send_~flag$xhr ~EQ ~T
◎
When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.
</dd>
</dl>

<div class="algo">
`withCredentials@m
取得子~手続きは
⇒
~RET コレの`非同一-生成元~向け資格証あり？$xhr
◎
The withCredentials getter steps are to return this’s cross-origin credentials.
</div>

<div class="algo">
<p>
`withCredentials$m 設定子~手続きは：
◎
The withCredentials setter steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~NIN
{ `未送信^i, `~openした^i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not unsent or opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~send_~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`非同一-生成元~向け資格証あり？$xhr ~SET 所与の値
◎
Set this’s cross-origin credentials to the given value.
</li>
</ol>
</div>

			</section>
			<section id="the-upload-attribute">
<h4 title="The upload getter">3.5.5. `upload^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `upload$m</dt>
	<dd>
結付けられている `XMLHttpRequestUpload$I ~objを返す。
これを利用すれば、~serverへ向けて~dataが転送されるときに，伝送~情報を集めることができる。
◎
Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server.
</dd>
</dl>

<div class="algo">
`upload@m
取得子~手続きは
⇒
~RET コレの`~upload~obj$xhr
◎
The upload getter steps are to return this’s upload object.
</div>

			</section>
			<section id="the-send()-method">
<h4 title="The send() method">3.5.6. `send()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `send$m([%body = null])</dt>
	<dd>
要請を起動させる。
%body 引数は、`要請~本体$xhrを供する（もしあれば）。
`要請~method$xhrが `GET$hm や `HEAD$hm の場合、この引数は無視される。
◎
Initiates the request. The body argument provides the request body, if any, and is ignored if the request method is GET or HEAD.
</dd>
	<dd>
次のいずれかが満たされている下では、
`InvalidStateError$E 例外が投出される
⇒＃
`状態$xhr ~NEQ `~openした^i ／
`~send_~flag$xhr ~EQ ~T
◎
Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
</dd>
</dl>

<div class="algo">
<p>
`send(body)@m
~method手続きは：
◎
The send(body) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is not opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`~send_~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If this’s send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`要請~method$xhr ~IN
{ `GET$hm, `HEAD$hm }
］
⇒
%body ~SET ~NULL
◎
If this’s request method is `GET` or `HEAD`, then set body to null.
</li>
	<li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is not null, then:
</p>
		<ol>
			<li>
%抽出された内容~型 ~LET ~NULL
◎
Let extractedContentType be null.
</li>
			<li>
~IF［
%body は `Document$I である
］
⇒
コレの`要請~本体$xhr ~SET `~UTF-8符号化する$( `~scalar値~文字列に変換する$( `素片を直列化する$( %body ) ) )
◎
If body is a Document, then set this’s request body to body, serialized, converted, and UTF-8 encoded.
</li>
			<li>
~ELSE
⇒
( コレの`要請~本体$xhr, %抽出された内容~型 ) ~SET `本体と内容~型を安全に抽出する$( %body )
◎
Otherwise, set this’s request body and extractedContentType to the result of safely extracting body.
</li>
			<li>
%元の作者~内容~型 ~LET `~header~listから値を取得する$( コレの`作者~要請~header~list$xhr, `Content-Type^h )
◎
Let originalAuthorContentType be the result of getting `Content-Type` from this’s author request headers.
</li>
			<li>
<p>
~IF［
%元の作者~内容~型 ~NEQ ~NULL
］：
◎
If originalAuthorContentType is non-null, then:
</p>
				<ol>
					<li>
<p>
~IF［
%body は［
`Document$I ／ `USVString$I
］である
］：
◎
If body is a Document or a USVString, then:
</p>
						<ol>
							<li>
%内容~型~record ~LET `~byte列から~MIME型を構文解析する$( %元の作者~内容~型 の`値$hd )
◎
Let contentTypeRecord be the result of parsing originalAuthorContentType.
</li>
							<li>
<p>
~IF［
%内容~型~record ~NEQ 失敗
］：
◎
If contentTypeRecord is not failure,＼
</p>
								<ol>
									<li>
%~parameters ~LET %内容~型~record の`~parameters$
◎
↓</li>
									<li>
<p>
~IF［
%~parameters[ `charset^l ] ~NEQ ε
］~AND［
%~parameters[ `charset^l ] は`~ASCII大小無視$で `UTF-8^l に合致しない
］：
◎
contentTypeRecord’s parameters["charset"] exists, and parameters["charset"] is not an ASCII case-insensitive match for "UTF-8", then:
</p>
										<ol>
											<li>
%~parameters[ `charset^l ] ~SET `UTF-8^l
◎
Set contentTypeRecord’s parameters["charset"] to "UTF-8".
</li>
											<li>
`作者~要請~header~list$xhr内で`~headerを設定する$( `Content-Type^h / `~MIME型を~byte列に直列化する$( %内容~型~record ) )
◎
Let newContentTypeSerialized be the result of serializing contentTypeRecord.
◎
Set `Content-Type`/newContentTypeSerialized in this’s author request headers.
</li>
										</ol>
									</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
◎
Otherwise:
</p>
				<ol>
					<li>
%内容~型 ~LET 次で与えられる値
⇒＃
%body は`~HTML文書$であるならば `text/html;charset=UTF-8^bl ／
~ELSE_ %body は`~XML文書$であるならば `application/xml;charset=UTF-8^bl ／
~ELSE_ %抽出された内容~型
◎
If body is an HTML document, set `Content-Type`/`text/html;charset=UTF-8` in this’s author request headers.
◎
Otherwise, if body is an XML document, set `Content-Type`/`application/xml;charset=UTF-8` in this’s author request headers.
◎
Otherwise, if extractedContentType is not null, set `Content-Type`/extractedContentType in this’s author request headers.
</li>
					<li>
~IF［
%内容~型 ~NEQ ~NULL
］
⇒
コレの`作者~要請~header~list$xhr内で`~headerを設定する$( `Content-Type^h / %内容~型 )
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
コレの`~upload~obj$xhrに登録されている~event~listenerは在る
］
⇒
コレの`~upload~listener~flag$xhr ~SET ~T
◎
If one or more event listeners are registered on this’s upload object, then set this’s upload listener flag.
</li>
	<li>
<p>
%要請 ~LET 次に従って初期化された新たな`要請$：
◎
Let req be a new request, initialized as follows:
</p>
		<ul>
			<li>
`~method$rq~SET コレの`要請~method$xhr
◎
method
• This’s request method.
</li>
			<li>
`~URL$rq ~SET コレの`要請~URL$xhr
◎
URL
• This’s request URL.
</li>
			<li>
`~header~list$rq ~SET コレの`作者~要請~header~list$xhr
◎
header list
• This’s author request headers.
</li>
			<li>
`非安全~要請~flag$rq ~SET ~T
◎
unsafe-request flag
• Set.
</li>
			<li>
`本体$rq ~SET コレの`要請~本体$xhr
◎
body
• This’s request body.
</li>
			<li>
`~client$rq ~SET コレに`関連な設定群~obj$
◎
client
• This’s relevant settings object.
</li>
			<li>
`同期~flag$rq ~SET コレの`同期~flag$xhr
◎
synchronous flag
• Set if this’s synchronous flag is set.
</li>
			<li>
`~mode$rq ~SET `cors^l
◎
mode
• "cors".
</li>
			<li>
`~CORS予行~利用~flag$rq ~SET コレの`~upload~listener~flag$xhr
◎
use-CORS-preflight flag
• Set if this’s upload listener flag is set.
</li>
			<li>
`資格証~mode$rq ~SET コレの`非同一-生成元~向け資格証あり？$xhrに応じて
⇒＃
~T ならば `include^l ／
~F ならば `same-origin^l
◎
credentials mode
• If this’s cross-origin credentials is true, then "include"; otherwise "same-origin".
</li>
			<li>
`~URL資格証~利用~flag$rq ~SET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
コレの`要請~URL$xhrは`資格証を含む$
◎
use-URL-credentials flag
• Set if this’s request URL includes credentials.
</li>
		</ul>
	</li>
	<li>
コレの`~upload完了-~flag$xhr ~SET %要請 の`本体$rqに応じて
⇒
~NULL ならば ~T ／
~ELSE_ ~F
◎
Unset this’s upload complete flag.
◎
Unset this’s timed out flag.
◎
If req’s body is null, then set this’s upload complete flag.
</li>
	<li>
コレの`時間切れ~flag$xhr ~SET ~F
◎
↑</li>
	<li>
コレの`~send_~flag$xhr ~SET ~T
◎
Set this’s send() flag.
</li>
	<li>
<p>
~IF［
コレの`同期~flag$xhr ~EQ ~F
］：
◎
If this’s synchronous flag is unset, then: 
</p>
		<ol>
			<li>
コレに向けて名前 `loadstart$et の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named loadstart at this with 0 and 0.
</li>
			<li>
~IF［
コレの`~upload完了-~flag$xhr ~EQ ~F
］~AND［
コレの`~upload~listener~flag$xhr ~EQ ~T
］
⇒
コレの`~upload~obj$xhrに向けて，名前 `loadstart$et の`進捗~eventを発火する$( 0, %要請 の`本体$rqの`総~byte数$bd )
◎
If this’s upload complete flag is unset and this’s upload listener flag is set, then fire a progress event named loadstart at this’s upload object with 0 and req’s body’s total bytes.
</li>
			<li>
~IF［
コレの`状態$xhr ~NEQ `~openした^i
］~OR［
コレの`~send_~flag$xhr ~EQ ~F
］
⇒
~RET
◎
If this’s state is not opened or this’s send() flag is unset, then return.
</li>
			<li>
<p>
%要請 を`~fetch$する
— それにより`~network用~task源$から`~queueされ$た`~task$は、以下に従って取扱う
◎
Fetch req. Handle the tasks queued on the networking task source per below.
</p>

<div class="algo">
<p>
次の下位手続きを`並列的$に走らす：
◎
Run these steps in parallel:
</p>
				<ol>
					<li>
<p>
次のいずれかが満たされるまで待機する：
◎
↓</p>
						<ul>
							<li>
%要請 の`~done~flag$rq ~EQ ~T
◎
Wait until either req’s done flag is set or＼
</li>
							<li>
コレの`制限時間$xhr ~NEQ 0
◎
this’s timeout is not 0＼
</li>
							<li>
この下位手続きを開始してからコレの`制限時間$xhr ~milli秒~以上~経過した
◎
and this’s timeout milliseconds have passed since these steps started.
</li>
						</ul>
					</li>
					<li>
<p>
~IF［
%要請 の`~done~flag$rq ~EQ ~F
］：
</p>
<ol><li>コレの`時間切れ~flag$xhr ~SET ~T
</li><li>この`~fetchを終了させる$
</li></ol>
◎
If req’s done flag is unset, then set this’s timed out flag and terminate fetching.
</li>
				</ol>
</div>

<p>
【以下に定義される各種 下位手続き（ “〜を処理する” ）は、`~fetching$の中で~queueされる~taskになる（これらは，非同期的に呼出される callback である）。】
</p>

<div class="algo">
<p>
`要請の本体を処理する$ときは、所与の
( %要請 )
に対し，次の下位手続きを走らす：
◎
To process request body for request, run these steps:
</p>
<ol>
	<li>
~IF［
この手続きが最後に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these steps were last invoked, terminate these steps.
</li>
	<li>
~IF［
コレの`~upload~listener~flag$xhr ~EQ ~T
］
⇒
コレの`~upload~obj$xhrに向けて，名前 `progress$et の`進捗~eventを発火する$( %要請 の`本体$rqの`伝送-済み~byte数$bd, %要請 の`本体$rqの`総~byte数$bd )
◎
If this’s upload listener flag is set, then fire a progress event named progress at this’s upload object with request’s body’s transmitted bytes and request’s body’s total bytes.
</li>
</ol>

<p class="note">注記：
この下位手続きは、新たな~byteが伝送されたときに限り，呼出される。
◎
These steps are only invoked when new bytes are transmitted.
</p>
</div>

<div class="algo">
<p>
`要請の本体終端を処理する$ときは、所与の
( %要請 )
に対し，次の下位手続きを走らす：
◎
To process request end-of-body for request, run these steps:
</p>
				<ol>
					<li>
コレの`~upload完了-~flag$xhr ~SET ~T
◎
Set this’s upload complete flag.
</li>
					<li>
~IF［
コレの`~upload~listener~flag$xhr ~EQ ~T
］
⇒
~RET
◎
If this’s upload listener flag is unset, then terminate these steps.
</li>
					<li>
%伝送量 ~LET
%要請 の`本体$rqの`伝送-済み~byte数$bd
◎
Let transmitted be request’s body’s transmitted bytes.
</li>
					<li>
%長さ ~LET
%要請 の`本体$rqの`総~byte数$bd
◎
Let length be request’s body’s total bytes.
</li>
					<li>
コレの`~upload~obj$xhrに向けて，名前 `progress$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named progress at this’s upload object with transmitted and length.
</li>
					<li>
コレの`~upload~obj$xhrに向けて，名前 `load$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named load at this’s upload object with transmitted and length.
</li>
					<li>
コレの`~upload~obj$xhrに向けて，名前 `loadend$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named loadend at this’s upload object with transmitted and length.
</li>
				</ol>
</div>

<div class="algo">
<p>
`応答を処理する$ときは、所与の
( %応答 )
に対し，次の下位手続きを走らす：
◎
To process response for response, run these steps:
</p>
				<ol>
					<li>
コレの`応答$xhr ~SET %応答
◎
Set this’s response to response.
</li>
					<li>
`~errorを取扱う$( コレ, %応答 )
◎
Handle errors fo this and response.
</li>
					<li>
~IF［
コレの`応答$xhr は`~network~error$である
］
⇒
~RET
◎
If this’s response is a network error, then return.
</li>
					<li>
コレの`状態$xhr ~SET `全~headerを受信した^i
◎
Set this’s state to headers received.
</li>
					<li>
コレに向けて名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</li>
					<li>
~IF［
コレの`状態$xhr ~NEQ `全~headerを受信した^i
］
⇒
~RET
◎
If this’s state is not headers received, then return.
</li>
					<li>
%本体 ~LET %応答 の`本体$rs
◎
↓</li>
					<li>
<p>
~IF［
%本体 ~EQ ~NULL
］：
</p>
<ol><li>`本体終端を取扱う$( コレ, %応答 )
</li><li>~RET
</li></ol>
◎
If this’s response’s body is null, then run handle response end-of-body for this and this’s response, and then return.
</li>
					<li>
<p>
%読取器 ~LET %本体 の`~stream$bd用の`読取器を取得する$RS()
◎
Let reader be the result of getting a reader for this’s response’s body’s stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
					</li>
					<li>
<p>
%読取n要請 ~LET 次を伴う新たな`読取n要請$：
◎
Let readRequest be the following read request:
</p>
						<ul>
							<li class="algo">
<p>
その`~chunk手続き$rRは、所与の
( %~chunk )
に対し：
◎
chunk steps, given chunk
</p>
								<ol>
									<li>
コレの`受信した~byte列$xhrに %~chunk を付加する
◎
Append chunk to this’s received bytes.
</li>
									<li>
~IF［
この手続きが前回に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these steps were last invoked, then abort these steps.
</li>
									<li>
~IF［
コレの`状態$xhr ~EQ `全~headerを受信した^i
］
⇒
コレの`状態$xhr ~SET `読込n中^i
◎
If this’s state is headers received, then set this’s state to loading.
</li>
									<li>
<p>
コレに向けて名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</p>

<p class="note">注記：
コレの`状態$xhrが変化しなくても，
`readystatechange$et が余分に発火されるのは、~Web互換性の理由による。
◎
Web compatibility is the reason readystatechange fires more often than this’s state changes.
</p>
									</li>
									<li>
%本体 ~LET コレの`応答$xhrの`本体$rs
◎
↓</li>
									<li>
コレに向けて名前 `progress$et の`進捗~eventを発火する$( %本体 の`伝送-済み~byte数$bd, %本体 の`総~byte数$bd )
◎
Fire a progress event named progress at this with this’s response’s body’s transmitted bytes and this’s response’s body’s total bytes.
</li>
								</ol>
							</li>
							<li class="algo">
その`~close手続き$rRは
⇒
`本体終端を取扱う$( コレ, コレの`応答$xhr )
◎
close steps
• Run handle response end-of-body for this and this’s response.
</li>
							<li class="algo">
その`~error手続き$rRは
⇒
`~errorを取扱う$( コレ, コレの`応答$xhr )
◎
error steps
• Run handle errors for this and this’s response.
</li>
						</ul>
					</li>
					<li>
%読取器 から`~chunkを読取る$RSR( %読取n要請 )
◎
Read a chunk from reader given readRequest.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
（ コレの`同期~flag$xhr ~EQ ~T ）：
◎
Otherwise, if this’s synchronous flag is set:
</p>
		<ol>
			<li>
~IF［
コレに`関連な設定群~obj$には`担当の文書$enVがあって，それには
`sync-xhr$l `特能の利用は許容されて$いない
］
⇒＃
`本体終端を取扱う$( コレ, `~network~error$ )；
~RET
◎
If this’s relevant settings object has a responsible document which is not allowed to use the "sync-xhr" feature, then run handle response end-of-body for this and a network error, and then return.
</li>
			<li>
<p>
%応答 ~LET %要請 を`~fetch$した結果
◎
Let response be the result of fetching req.
</p>

<div class="p">
<p>
~IF［
コレの`制限時間$xhr %制限時間 ~NEQ 0
］~AND［
この`~fetching$は %制限時間 ~milli秒内に返らなかった
］：
</p>
<ol><li>コレの`時間切れ~flag$xhr ~SET ~T
</li><li>この`~fetchを終了させる$
</li></ol>

◎
If this’s timeout is not 0, then set this’s timed out flag and terminate fetching if it has not returned within this’s timeout milliseconds.
</div>

			</li>
			<li>
~IF［
%応答 の`本体$rs ~EQ ~NULL
］
⇒＃
`本体終端を取扱う$( コレ, %応答 )；
~RET
◎
If response’s body is null, then run handle response end-of-body for this and response, and then return.
</li>
			<li>
<p>
%読取器 ~LET %応答 の`本体$rsの`~stream$bd用の`読取器を取得する$RS()
◎
Let reader be the result of getting a reader for response’s body’s stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
			</li>
			<li>
%~promise ~LET %読取器 から`すべての~byteを読取る$RSR()
◎
Let promise be the result of reading all bytes from reader.
</li>
			<li>
%~promise が充足されるか却下されるまで待機する
⇒
~IF［
%~promise は %~byte列 で充足された
］
⇒
コレの`受信した~byte列$xhrに %~byte列 を付加する
◎
Wait for promise to be fulfilled or rejected.
◎
If promise is fulfilled with bytes, then append bytes to this’s received bytes.
</li>
			<li>
`本体終端を取扱う$( コレ, %応答 )
◎
Run handle response end-of-body for this and response.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p id="handle-response-end-of-file">
`本体終端を取扱う@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr, `応答$ %応答 )
に対し，次を走らす：
◎
To handle response end-of-body for an XMLHttpRequest object xhr and a response response, run these steps:
</p>
<ol>
	<li>
~IF［
%xhr の`同期~flag$xhr ~EQ ~T
］
⇒
%xhr の`応答$xhr ~SET %応答
◎
If xhr’s synchronous flag is set, then set xhr’s response to response.
</li>
	<li>
`~errorを取扱う$( %xhr, %応答 )
◎
Handle errors for xhr and response.
</li>
	<li>
~IF［
%xhr の`応答$xhrは`~network~error$である
］
⇒
~RET
◎
If xhr’s response is a network error, then return.
</li>
	<li>
~IF［
%xhr の`同期~flag$xhr ~EQ ~F
］
⇒
%応答 を利用して %xhr の`応答$xhrの`本体$rsを更新する
◎
If xhr’s synchronous flag is unset, then update xhr’s response’s body using response.
</li>
	<li>
%伝送量 ~LET %応答 の`本体$rsの`伝送-済み~byte数$bd
◎
Let transmitted be response’s body’s transmitted bytes.
</li>
	<li>
%長さ ~LET %応答 の`本体$rsの`総~byte数$bd
◎
Let length be response’s body’s total bytes.
</li>
	<li>
~IF［
%xhr の`同期~flag$xhr ~EQ ~F
］
⇒
%xhr に向けて名前 `progress$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
If xhr’s synchronous flag is unset, then fire a progress event named progress at xhr with transmitted and length.
</li>
	<li>
%xhr の`状態$xhr ~SET `済み^i
◎
Set xhr’s state to done.
</li>
	<li>
%xhr の`~send_~flag$xhr ~SET ~F
◎
Unset xhr’s send() flag.
</li>
	<li>
%xhr に向けて名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at xhr.
</li>
	<li>
%xhr に向けて名前 `load$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named load at xhr with transmitted and length.
</li>
	<li>
%xhr に向けて名前 `loadend$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named loadend at xhr with transmitted and length.
</li>
</ol>
</div>

<div class="algo">
<p>
`~errorを取扱う@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr, `応答$ %応答 )
に対し，次を走らす：
◎
To handle errors for an XMLHttpRequest object xhr and a response response, run these steps:
</p>
<ol>
	<li>
~IF［
%xhr の`~send_~flag$xhr ~EQ ~F
］
⇒
~RET
◎
If xhr’s send() flag is unset, then return.
</li>
	<li>
~IF［
%xhr の`時間切れ~flag$xhr ~EQ ~T
］
⇒
`要請~error手続きを走らす$( %xhr, `timeout$et, `TimeoutError$E 例外 )
◎
If xhr’s timed out flag is set, then run the request error steps for xhr, timeout, and "TimeoutError" DOMException.
</li>
	<li>
~IF［
%応答 は`~network~error$である
］
⇒
`要請~error手続きを走らす$( %xhr, `error$et, `NetworkError$E 例外 )
◎
If response is a network error, then run the request error steps for xhr, error, and "NetworkError" DOMException.
</li>
	<li>
<p>
~ELIF［
%応答 の`本体$rsの`~stream$bdは`~errorした$RS
］：
◎
Otherwise, if response’s body’s stream is errored, then:
</p>
		<ol>
			<li>
%xhr の`状態$xhr ~SET `済み^i
◎
Set xhr’s state to done.
</li>
			<li>
%xhr の`~send_~flag$xhr ~SET ~F
◎
Unset xhr’s send() flag.
</li>
			<li>
%xhr の`応答$xhr ~SET `~network~error$
◎
Set xhr’s response to a network error.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%xhr の`応答$xhrの`中止~flag$rs ~EQ ~T
］
⇒
`要請~error手続きを走らす$( %xhr, `abort$et, `AbortError$E 例外 )
◎
Otherwise, if xhr’s response’s aborted flag is set, then run the request error steps for xhr, abort, and "AbortError" DOMException.
</li>
</ol>
</div>

<div class="algo">
<p>
`要請~error手続きを走らす@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr, %~event型, %例外（省略時は ε ）)
に対し，次を走らす：
◎
The request error steps for an XMLHttpRequest object xhr, event, and optionally exception are:
</p>
<ol>
	<li>
%xhr の`状態$xhr ~SET `済み^i
◎
Set xhr’s state to done.
</li>
	<li>
%xhr の`~send_~flag$xhr ~SET ~F
◎
Unset xhr’s send() flag.
</li>
	<li>
%xhr の`応答$xhr ~SET `~network~error$
◎
Set xhr’s response to a network error.
</li>
	<li>
<p>
~IF［
%xhr の`同期~flag$xhr ~EQ ~T
］：
</p>
		<ol>
			<li>
~Assert：
%例外 ~NEQ ε
【この段は、この訳による補完。】
</li>
			<li>
~THROW %例外
</li>
		</ol>

◎
If xhr’s synchronous flag is set, then throw exception.
</li>
	<li>
<p>
%xhr に向けて名前 `readystatechange$et の`~eventを発火する$ 
◎
Fire an event named readystatechange at xhr.
</p>

<p class="note">注記：
この時点で明らかに
%xhr の`同期~flag$xhr ~EQ ~F
◎
At this point it is clear that xhr’s synchronous flag is unset.
</p>
	</li>
	<li>
<p>
~IF［
%xhr の`~upload完了-~flag$xhr ~EQ ~F
］：
◎
If xhr’s upload complete flag is unset, then:
</p>
		<ol>
			<li>
%xhr の`~upload完了-~flag$xhr ~SET ~T
◎
Set xhr’s upload complete flag.
</li>
			<li>
<p>
~IF［
%xhr の`~upload~listener~flag$xhr ~EQ ~T
］：
◎
If xhr’s upload listener flag is set, then:
</p>
				<ol>
					<li>
%xhr の`~upload~obj$xhrに向けて，名前 %~event型 の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named event at xhr’s upload object with 0 and 0.
</li>
					<li>
%xhr の`~upload~obj$xhrに向けて，名前 `loadend$et の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named loadend at xhr’s upload object with 0 and 0.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%xhr に向けて名前 %~event型 の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named event at xhr with 0 and 0.
</li>
	<li>
%xhr に向けて名前 `loadend$et の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named loadend at xhr with 0 and 0.
</li>
</ol>
</div>

			</section>
			<section id="the-abort()-method">
<h4 title="The abort() method">3.5.7. `abort()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `abort()$m</dt>
	<dd>
~network活動をすべて取消す。
◎
Cancels any network activity.
</dd>
</dl>

<div class="algo">
<p>
`abort()@m
~method手続きは：
◎
The abort() method steps are:
</p>
<ol>
	<li>
進行中の`~fetchを終了させる$( `中止する^i )
◎
Terminate the ongoing fetch with the aborted flag set.
</li>
	<li>
~IF［［
コレの`状態$xhr ~EQ `~openした^i
］~AND［
コレの`~send_~flag$xhr ~EQ ~T
］］~OR［
コレの`状態$xhr ~IN { `全~headerを受信した^i, `読込n中^i }
］
⇒
`要請~error手続きを走らす$( コレ, `abort$et )
◎
If this’s state is opened with this’s send() flag set, headers received, or loading, then run the request error steps for this and abort.
</li>
	<li>
<p>
~IF［
コレの`状態$xhr ~EQ `済み^i
］
⇒
コレの`状態$xhr ~SET `未送信^i；
コレの`応答$xhr ~SET `~network~error$
◎
If this’s state is done, then set this’s state to unsent and this’s response to a network error.
</p>

<p class="note">注記：
`readystatechange$et ~eventは配送されない。
◎
No readystatechange event is dispatched.
</p>
	</li>
</ol>
</div>

			</section>
		</section>
		<section id="xmlhttprequest-response">
<h3 title="Response">3.6. 応答</h3>

			<section id="the-responseurl-attribute">
<h4 title="The responseURL getter">3.6.1. `responseURL^m 取得子</h4>

<div class="algo">
<p>
`responseURL@m
取得子~手続きは：
</p>
<ol>
	<li>
%url ~LET `応答$xhrの`~URL$rs
</li>
	<li>
~IF［
%url ~EQ ~NULL
］
⇒
~RET 空~文字列
</li>
	<li>
~RET `~URLを直列化する$( %url, `素片は除外する^i )
</li>
</ol>
◎
The responseURL getter steps are to return the empty string if this’s response’s URL is null; otherwise its serialization with the exclude fragment flag set.
</div>

			</section>
			<section id="the-status-attribute">
<h4 title="The status getter">3.6.2. `status^m 取得子</h4>

<div class="algo">
`status@m
取得子~手続きは
⇒
~RET コレの`応答$xhrの`状態s$rs
◎
The status getter steps are to return this’s response’s status.
</div>

			</section>
			<section id="the-statustext-attribute">
<h4 title="The statusText getter">3.6.3. `statusText^m 取得子</h4>

<div class="algo">
`statusText@m
取得子~手続きは
⇒
~RET コレの`応答$xhrの`状態s~message$rs
◎
The statusText getter steps are to return this’s response’s status message.
</div>

			</section>
			<section id="the-getresponseheader()-method">
<h4 title="The getResponseHeader() method">3.6.4. `getResponseHeader()^m ~method</h4>

<div class="algo">
<p>
`getResponseHeader(name)@m
~method手続きは
⇒
~RET `~header~listから値を取得する$( コレの`応答$xhrの`~header~list$rs, %name )
◎
The getResponseHeader(name) method steps are to return the result of getting name from this’s response’s header list.
</p>

<p class="note">注記：
コレの`応答$xhrに公開される`~header~list$rsは、
Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters this’s response’s header list. [FETCH]
</p>
</div>

<div class="example" id="example-getresponseheader">

<p>
次の~scriptにおいては：
◎
For the following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open("GET", "unicorns-are-awesome.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(%client.getResponseHeader("Content-Type"));
  }
}
</pre>

<p>
`print()^c 関数は、次と同様の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre class="lang-http">
text/plain; charset=UTF-8
</pre>

</div>

			</section>
			<section id="the-getallresponseheaders()-method">
<h4 title="The getAllResponseHeaders() method">3.6.5. `getAllResponseHeaders()^m ~method</h4>

<div class="algo">
<p>
`getAllResponseHeaders()@m
~method手続きは：
◎
↓↓A byte sequence a is legacy-uppercased-byte less than a byte sequence b if the following steps return true:
• Let A be a, byte-uppercased.
• Let B be b, byte-uppercased.
• Return A is byte less than B.
◎
The getAllResponseHeaders() method steps are:
</p>
<ol>
	<li>
%出力 ~LET 空~byte列
◎
Let output be an empty byte sequence.
</li>
	<li>
%初期~header~list ~LET `~header~listを~sortして結合する$( コレの`応答$xhrの`~header~list$rs )
◎
Let initialHeaders be the result of running sort and combine with this’s response’s header list.
</li>
	<li>
<p>
%~header~list ~LET `~listを昇順に~sortする$( %初期~header~list, 次に与える`小なり~algo$ )
◎
Let headers be the result of sorting initialHeaders in ascending order, with＼
</p>

<p id="legacy-uppercased-byte-less-than">
この小なり~algoは、所与の 2 つの~header ( %a, %b ) に対し，［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返す
⇒
`~byte大文字~化する$( %a の`名前$hd )
は
`~byte大文字~化する$( %b の`名前$hd )
`未満の~byte列$である
◎
↑↑a being less than b if a’s name is legacy-uppercased-byte less than b’s name.
</p>

<p class="note">注記：
あいにく，この段は、配備-済み内容との互換性を得るため必要になる。
◎
Unfortunately, this is needed for compatibility with deployed content.
</p>
	</li>
	<li>
<p>
%~header~list 内の~EACH( %~header ) に対し
⇒
%出力 に次を順に付加する
⇒＃
%~header の`名前$hd,
~byte対 `3A^X `20^X,
%~header の`値$hd,
~byte対 `0D^X `0A^X
◎
For each header in headers, append header’s name, followed by a 0x3A 0x20 byte pair, followed by header’s value, followed by a 0x0D 0x0A byte pair, to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
コレの`応答$xhrに公開される`~header~list$rsは、
Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters this’s response’s header list. [FETCH]
</p>

</div>

<div class="example" id="example-getresponseheaders">

<p>
次の~scriptに対し：
◎
For the following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open("GET", "narwhals-too.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(this.getAllResponseHeaders());
  }
}
</pre>

<p>
`print()^c 関数は、次と同類の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre class="lang-http">
connection: Keep-Alive
content-type: text/plain; charset=utf-8
date: Sun, 24 Oct 2004 04:58:38 GMT
keep-alive: timeout=15, max=99
server: Apache/1.3.31 (Unix)
transfer-encoding: chunked
</pre>

</div>

			</section>
			<section id="response-body">
<h4 title="Response body">3.6.6. 応答~本体</h4>

<div class="algo">
<p>
`応答~MIME型を取得する@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr )
に対し，次を走らす：
◎
To get a response MIME type for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %xhr の`応答$xhrの`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from xhr’s response’s header list.
</li>
	<li>
~IF［
%~MIME型 ~EQ `失敗^i
］
⇒
%~MIME型 ~SET `text/xml^c
【 `~MIME型を構文解析する$( `text/xml^l ) 】
◎
If mimeType is failure, then set mimeType to text/xml.
</li>
	<li>
~RET %~MIME型
◎
Return mimeType.
</li>
</ol>
</div>

<div class="algo">
<p>
`最終-~MIME型を取得する@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr )
に対し，次を走らす：
◎
To get a final MIME type for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
%上書き~MIME型 ~LET %xhr の`上書き~MIME型$xhr
◎
↓</li>
	<li>
~IF［
%上書き~MIME型 ~EQ ~NULL
］
⇒
~RET `応答~MIME型を取得する$( %xhr )
◎
If xhr’s override MIME type is null, return the result of get a response MIME type for xhr.
</li>
	<li>
~RET %上書き~MIME型
◎
Return xhr’s override MIME type.
</li>
</ol>
</div>

<div class="algo">
<p>
`最終-符号化法を取得する@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr )
に対し，次を走らす：
◎
To get a final encoding for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
%~label ~LET ε
◎
Let label be null.
</li>
	<li>
~IF［
%xhr の`上書き~MIME型$xhr ~NEQ ~NULL
］
⇒
%~label ~SET %xhr の`上書き~MIME型$xhrの`~parameters$[ `charset^l ]
◎
↓</li>
	<li>
~IF［
%~label ~EQ ε
］
⇒
%~label ~SET 次の結果の`~parameters$[ `charset^l ]
⇒
`応答~MIME型を取得する$( %xhr )
◎
Let responseMIME be the result of get a response MIME type for xhr.
◎
If responseMIME’s parameters["charset"] exists, then set label to it.
◎
If xhr’s override MIME type’s parameters["charset"] exists, then set label to it.
</li>
	<li>
~IF［
%~label ~EQ ε
］
⇒
~RET ~NULL
◎
If label is null, then return null.
</li>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~RET %符号化法 に応じて
⇒＃
`失敗^i ならば ~NULL／
~ELSE_ %符号化法
◎
If encoding is failure, then return null.
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
上の手続きが`最終-~MIME型を取得する$を利用しないのは、意図的である
— そうすると~web互換でなくなるので。
◎
The above steps intentionally do not use the get a final MIME type as it would not be web compatible.
</p>
</div>

<hr>

<div class="algo">
<p>
`文書~応答を設定する@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr )
に対し，次を走らす：
◎
To set a document response for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
~IF［
%xhr の`応答$xhrの`本体$rs ~EQ ~NULL,
］
⇒
~RET
◎
If xhr’s response’s body is null, then return.
</li>
	<li>
%charset ~LET ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%最終-~MIME型 ~LET `最終-~MIME型を取得する$( %xhr )
◎
Let finalMIME be the result of get a final MIME type for xhr.
</li>
	<li>
<p>
%最終-~MIME型 に応じて：
◎
↓↓If finalMIME is not an HTML MIME type or an XML MIME type, then return.
</p>
		<ul class="switch">
			<li>
<p>
`~HTML~MIME型$である：
◎
↓</p>
				<ol>
					<li>
<p>
~IF［
%xhr の`応答~種別$xhr ~EQ 空~文字列
］
⇒
~RET
◎
If xhr’s response type is the empty string and＼
finalMIME is an HTML MIME type, then return.
</p>

<p class="note">注記：
旧来の内容を壊さないようにするため、
%xhr の`応答~種別$xhrは，ここでは `document^l に制約される。
◎
This is restricted to xhr’s response type being "document" in order to prevent breaking legacy content.
</p>
					</li>
					<li>
%charset ~SET `最終-符号化法を取得する$( %xhr )
◎
↑If finalMIME is an HTML MIME type, then:
◎
Let charset be the result of get a final encoding for xhr.
</li>
					<li>
~IF［
%charset ~EQ ~NULL
］
⇒
~IF［
%xhr の`受信した~byte列$xhrの最初の 1024 ~byteを
<a href="~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding">予走査して</a>
成功裡に結果を得られた
］
⇒
%charset ~LET その結果
◎
If charset is null, prescan the first 1024 bytes of xhr’s received bytes and if that does not terminate unsuccessfully then let charset be the return value.
</li>
					<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
					<li>
%文書 ~LET 次の結果を表現する`文書$
⇒
~HTML標準の~HTML構文解析器に~~規定される規則に従って，［
~scriptは不能化する,
<a href="~HTMLparsing#a-known-definite-encoding">既知かつ確定的な符号化法</a>として 
%charset を与える
］下で， %xhr の`受信した~byte列$xhrを構文解析した結果
`HTML$r
◎
Let document be a document that represents the result parsing xhr’s received bytes following the rules set forth in the HTML Standard for an HTML parser with scripting disabled and a known definite encoding charset. [HTML]
</li>
					<li>
%文書 の`種別$doc ~SET `html^l
◎
Flag document as an HTML document.
</li>
				</ol>
			</li>
			<li>
<p>
`~XML~MIME型$である
⇒
%文書 ~LET 次の結果を表現する`文書$
⇒
<a href="~HTMLxml#xml-scripting-support-disabled">~XML~scripting~supportを不能化する</a>下で，
%xhr の`受信した~byte列$xhrを
<a href="~HTMLxml#xml-parser">~XML構文解析器</a>
にかけた結果
`HTML$r
⇒
~IF［
構文解析に失敗した（例：未~supportな文字~符号化法, 名前空間整形式~error, 等々）
］
⇒
~RET ~NULL
◎
Otherwise, let document be a document that represents the result of running the XML parser with XML scripting support disabled on xhr’s received bytes. If that fails (unsupported character encoding, namespace well-formedness error, etc.), then return null. [HTML]
</p>

<p class="note">注記：
文書から参照されている資源は読込まれず，文書に結付けられている~XSLTは適用されない。
◎
Resources referenced will not be loaded and no associated XSLT will be applied.
</p>
			</li>
			<li>
その他~MIME型
⇒
~RET
◎
↑↑</li>
		</ul>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
	<li>
%文書 の
⇒＃
`符号化法$doc ~SET %charset,
`内容~型$doc ~SET %最終-~MIME型,
`~URL$doc ~SET %xhr の`応答$xhrの`~URL$rs,
`生成元$doc ~SET %xhr に`関連な設定群~obj$の`生成元$enV
◎
Set document’s encoding to charset.
◎
Set document’s content type to finalMIME.
◎
Set document’s URL to xhr’s response’s URL.
◎
Set document’s origin to xhr’s relevant settings object’s origin.
</li>
	<li>
%xhr の`応答~obj$xhr ~SET %文書
◎
Set xhr’s response object to document.
</li>
</ol>
</div>

<div class="algo">
<p>
`~text応答を取得する@
ときは、所与の
( `XMLHttpRequest$I ~obj %xhr )
に対し，次を走らす：
◎
To get a text response for an XMLHttpRequest object xhr, run these steps:
</p>
<ol>
	<li>
~IF［
%xhr の`応答$xhrの`本体$rs ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If xhr’s response’s body is null, then return the empty string.
</li>
	<li>
%charset ~LET `最終-符号化法を取得する$( %xhr )
◎
Let charset be the result of get a final encoding for xhr.
</li>
	<li>
<p>
~IF［
%xhr の`応答~種別$xhr ~EQ 空~文字列
］~AND［
%charset ~EQ ~NULL
］：
◎
If xhr’s response type is the empty string, charset is null,＼
</p>
		<ol>
			<li>
%最終-~MIME型 ~LET `最終-~MIME型を取得する$( %xhr )
◎
and the result of get a final MIME type for xhr＼
</li>
			<li>
~IF［
%最終-~MIME型 は`~XML~MIME型$である
］
⇒
%charset ~LET
~XML仕様に~~規定される規則に従って決定される符号化法
`XML$r
`XML-NAMES$r
◎
is an XML MIME type, then use the rules set forth in the XML specifications to determine the encoding. Let charset be the determined encoding. [XML] [XML-NAMES]
</li>
		</ol>

<p class="note">注記：
旧来のものでない`応答~種別$xhr用の値 `text^l を単純なままに保つため、
%xhr の`応答~種別$xhrは，ここでは空~文字列に制約される。
◎
This is restricted to xhr’s response type being the empty string to keep the non-legacy response type value "text" simple.
</p>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
	<li>
~RET `~Unicodeに復号する$( %xhr の`受信した~byte列$xhr, %charset )
◎
Return the result of running decode on xhr’s received bytes using fallback encoding charset.
</li>
</ol>

<p class="note">注記：
作者には、資源を符号化する際には，常に`~UTF-8$を利用することが強く奨励される。
◎
Authors are strongly encouraged to always encode their resources using UTF-8.
</p>
</div>

			</section>
			<section id="the-overridemimetype()-method">
<h4 title="The overrideMimeType() method">3.6.7. `overrideMimeType()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `overrideMimeType(mime)$m</dt>
	<dd>
応答の `Content-Type$h ~header値が %mime であったかのように動作する（その~headerを変更することなく）。
◎
Acts as if the `Content-Type` header value for a response is mime. (It does not change the header.)
</dd>
	<dd>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`状態$xhr ~IN { `読込n中^i, `済み^i }
◎
Throws an "InvalidStateError" DOMException if state is loading or done.
</dd>
</dl>

<div class="algo">
<p>
`overrideMimeType(mime)@m
~method手続きは：
◎
The overrideMimeType(mime) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`状態$xhr ~IN { `読込n中^i, `済み^i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is loading or done, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`上書き~MIME型$xhr ~SET `~MIME型を構文解析する$( %mime )
◎
Set this’s override MIME type to the result of parsing mime.
</li>
	<li>
~IF［
コレの`上書き~MIME型$xhr ~EQ `失敗^i
］
⇒
コレの`上書き~MIME型$xhr ~SET `application/octet-stream^bl
◎
If this’s override MIME type is failure, then set this’s override MIME type to application/octet-stream.
</li>
</ol>
</div>

			</section>
			<section id="the-responsetype-attribute">
<h4 title="The responseType getter and setter">3.6.8. `responseType^m 取得子／設定子</h4>

<dl class="domintro">
	<dt>%client . `responseType$m [ = %value ]</dt>
	<dd>
応答の種別を返す。
◎
Returns the response type.
</dd>
	<dd>
設定して、応答の種別を変更できる。
値は次のいずれか
⇒
空~文字列 （既定）,
`arraybuffer^l,
`blob^l,
`document^l,
`json^l,
`text^l
◎
Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
</dd>
	<dd>
<p>
設定子においては：
◎
↓</p>
		<ul>
			<li>
`現在の大域~obj$は `Window$I ~objでない場合、
`document^l に設定しても無視される。
◎
When set: setting to "document" is ignored if current global object is not a Window object.
</li>
			<li>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`状態$xhr ~IN { `読込n中^i, `済み^i }
◎
When set: throws an "InvalidStateError" DOMException if state is loading or done.
</li>
			<li>
次が満たされている下では、
`InvalidAccessError$E 例外が投出される
⇒
［
`同期~flag$xhr ~EQ ~T
］~AND［
`現在の大域~obj$は `Window$I ~objである
］
◎
When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
</li>
		</ul>
	</dd>
</dl>

<div class="algo">
`responseType@m
取得子~手続きは
⇒
~RET コレの`応答~種別$xhr
◎
The responseType getter steps are to return this’s response type.
</div>

<div class="algo">
<p>
`responseType$m 設定子~手続きは：
◎
The responseType setter steps are:
</p>
<ol>
	<li>
%W ~LET ［
`現在の大域~obj$は `Window$I ~objであるならば ~T ／
~ELSE_ ~F
］
◎
↓</li>
	<li>
~IF［
%W ~EQ ~F
］~AND［
所与の値 ~EQ `document^l
］
⇒
~RET
◎
If the current global object is not a Window object and the given value is "document", then return.
</li>
	<li>
~IF［
コレの`状態$xhr ~IN { `読込n中^i, `済み^i }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s state is loading or done, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%W ~EQ ~T
］~AND［
コレの`同期~flag$xhr ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If the current global object is a Window object and this’s synchronous flag is set, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
コレの`応答~種別$xhr ~SET 所与の値
◎
Set this’s response type to the given value.
</li>
</ol>
</div>

			</section>
			<section id="the-response-attribute">
<h4 title="The response getter">3.6.9. `response^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `response$m</dt>
	<dd>
応答の本体を返す。
◎
Returns the response body.
</dd>
</dl>

<div class="algo">
<p>
`response@m
取得子~手続きは：
◎
The response getter steps are:
</p>
<ol>
	<li>
<p>
~IF［
コレの`応答~種別$xhr ~IN { 空~文字列, `text^l }
］：
◎
If this’s response type is the empty string or "text", then:
</p>
		<ol>
			<li>
~IF［
コレの`状態$xhr ~NIN { `読込n中^i, `済み^i }
］
⇒
~RET 空~文字列
◎
If this’s state is not loading or done, then return the empty string.
</li>
			<li>
~RET `~text応答を取得する$( コレ )
◎
Return the result of getting a text response for this.
</li>
		</ol>
	</li>
	<li>
~IF［
コレの`状態$xhr ~NEQ `済み^i
］
⇒
~RET ~NULL
◎
If this’s state is not done, then return null.
</li>
	<li>
~IF［
コレの`応答~obj$xhr ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If this’s response object is failure, then return null.
</li>
	<li>
~IF［
コレの`応答~obj$xhr ~NEQ ~NULL
］
⇒
~RET コレの`応答~obj$xhr
◎
If this’s response object is non-null, then return it.
</li>
	<li>
<p>
コレの`応答~種別$xhrに応じて：
◎
↓</p>
		<dl class="switch">
			<dt id="arraybuffer-response">
`arraybuffer^l
◎
If this’s response type is "arraybuffer", then＼
</dt>
			<dd>
コレの`応答~obj$xhr ~SET コレの`受信した~byte列$xhrを表現する，`新たな$ `ArrayBuffer$I ~obj
◎
set this’s response object to a new ArrayBuffer object representing this’s received bytes.＼
</dd>
			<dd>
例外が投出されたときは
⇒＃
コレの`応答~obj$xhr ~SET `失敗^i；
~RET ~NULL
◎
If this throws an exception, then set this’s response object to failure and return null.
</dd>
			<dd class="note">注記：
`ArrayBuffer$I ~objを割振ることの成功-は、保証されない。
`ECMASCRIPT$r
◎
Allocating an ArrayBuffer object is not guaranteed to succeed. [ECMASCRIPT]
</dd>

			<dt id="blob-response">
`blob^l
◎
Otherwise, if this’s response type is "blob",＼
</dt>
			<dd>
コレの`応答~obj$xhr ~SET 次のようにされた，コレの`受信した~byte列$xhrを表現する`新たな$ `Blob$I ~obj
⇒
`~type0$m ~SET `最終-~MIME型を取得する$( コレ )
◎
set this’s response object to a new Blob object representing this’s received bytes with type set to the result of get a final MIME type for this.
</dd>

			<dt>
`document^l
◎
Otherwise, if this’s response type is "document",＼
</dt>
			<dd>
`文書~応答を設定する$( コレ )
◎
set a document response for this.
</dd>

			<dt id="json-response">
`json^l
◎
Otherwise:
◎
Assert: this’s response type is "json".
</dt>
			<dd>
				<ol>
					<li>
~IF［
コレの`応答$xhrの`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If this’s response’s body is null, then return null.
</li>
					<li>
%~JSON~obj ~LET `~JSON~byte列を~JS値に構文解析する$( コレの`受信した~byte列$xhr )
⇒
例外が投出されたときは
⇒
~RET ~NULL
◎
Let jsonObject be the result of running parse JSON from bytes on this’s received bytes. If that threw an exception, then return null.
</li>
					<li>
コレの`応答~obj$xhr ~SET %~JSON~obj
◎
Set this’s response object to jsonObject.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET コレの`応答~obj$xhr
◎
Return this’s response object.
</li>
</ol>
</div>

			</section>
			<section id="the-responsetext-attribute">
<h4 title="The responseText getter">3.6.10. `responseText^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `responseText$m</dt>
	<dd>
応答を~textとして返す。
◎
Returns response as text.
</dd>
	<dd>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`応答~種別$xhr【！`responseType$m】 ~NIN { 空~文字列, `text^l }
◎
Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".
</dd>
</dl>

<div class="algo">
<p>
`responseText@m
取得子~手続きは：
◎
The responseText getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`応答~種別$xhr ~NIN { 空~文字列, `text^l }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s response type is not the empty string or "text", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`状態$xhr ~NIN { `読込n中^i, `済み^i }
］
⇒
~RET 空~文字列
◎
If this’s state is not loading or done, then return the empty string.
</li>
	<li>
~RET `~text応答を取得する$( コレ )
◎
Return the result of getting a text response for this.
</li>
</ol>
</div>

			</section>
			<section id="the-responsexml-attribute">
<h4 title="The responseXML getter">3.6.11. `responseXML^m 取得子</h4>

<dl class="domintro">
	<dt>%client . `responseXML$m</dt>
	<dd>
応答を文書として返す。
◎
Returns the response as document.
</dd>
	<dd>
次が満たされている下では、
`InvalidStateError$E 例外が投出される
⇒
`応答~種別$xhr【！`responseType$m】 ~NIN { 空~文字列, `document^l }
◎
Throws an "InvalidStateError" DOMException if responseType is not the empty string or "document".
</dd>
</dl>

<div class="algo">
<p>
`responseXML@m
取得子~手続きは：
◎
The responseXML getter steps are:
</p>
<ol>
	<li>
~IF［
コレの`応答~種別$xhr ~NIN { 空~文字列, `document^l }
］
⇒
~THROW `InvalidStateError$E
◎
If this’s response type is not the empty string or "document", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
コレの`状態$xhr ~NEQ `済み^i
］
⇒
~RET ~NULL
◎
If this’s state is not done, then return null.
</li>
	<li>
~Assert：
コレの`応答~obj$xhr ~NEQ `失敗^i
◎
Assert: this’s response object is not failure.
</li>
	<li>
~IF［
コレの`応答~obj$xhr ~NEQ ~NULL
］
⇒
~RET コレの`応答~obj$xhr
◎
If this’s response object is non-null, then return it.
</li>
	<li>
`文書~応答を設定する$( コレ )
◎
Set a document response for this.
</li>
	<li>
~RET コレの`応答~obj$xhr
◎
Return this’s response object.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="events">
<h3 title="Events summary">3.7. ~event要覧</h3>

~INFORMATIVE

<p>
以下の~eventが［
`XMLHttpRequest$I ／ `XMLHttpRequestUpload$I
］~objに向けて配送される：
◎
The following events are dispatched on XMLHttpRequest or XMLHttpRequestUpload objects:
</p>

<table><thead>
<tr><th>~event名
◎
Event name
<th>~interface
◎
Interface
<th>配送-時機
◎
Dispatched when…
</thead><tbody>

<tr><td>`readystatechange@et
<td>`Event$I
<td>
`readyState$m 属性の値が変化したとき。
ただし， `UNSENT$m に変化したときは除く。
◎
The readyState attribute changes value, except when it changes to UNSENT.

<tr><td>`loadstart@et
<td>`ProgressEvent$I
<td>
~fetchが起動されたとき。
◎
The fetch initiates.

<tr><td>`progress@et
<td>`ProgressEvent$I
<td>
~dataを伝送-中のとき。
◎
Transmitting data.

<tr><td>`abort@et
<td>`ProgressEvent$I
<td>
~fetchが中止されたとき。
例えば， `abort()$m ~methodの呼出ngなど。
◎
When the fetch has been aborted. For instance, by invoking the abort() method.

<tr><td>`error@et
<td>`ProgressEvent$I
<td>
~fetchに失敗したとき。
◎
The fetch failed.

<tr><td>`load@et
<td>`ProgressEvent$I
<td>
~fetchに成功したとき。
◎
The fetch succeeded.

<tr><td>`timeout@et
<td>`ProgressEvent$I
<td>
~fetchが完了する前に `timeout$m に指定される時間を過ぎたとき。
◎
The author specified timeout has passed before the fetch completed.

<tr><td>`loadend@et
<td>`ProgressEvent$I
<td>
~fetchが完了したとき（成功, 失敗, いずれに関わらず）。
◎
The fetch completed (success or failure).

</tbody>
</table>

		</section>
		<section id="feature-policy-integration">
<h3 title="Feature Policy Integration">3.8. 許可~施策【！特能~施策】の統合</h3>

<p>
この仕様は、［
文字列
`sync-xhr@l
で識別される，`施策により制御される特能$
］を定義する。
その`既定の許容list$は `*^c とする。
◎
This specification defines a policy-controlled feature identified by the string "sync-xhr". Its default allowlist is *.
</p>

		</section>
	</section>
	<section id="interface-formdata">
<h2 title="Interface FormData">4. ~interface `FormData^I</h2>

<pre class="idl">
typedef (`File$I or `USVString$) `FormDataEntryValue@I;

[`Exposed$=(Window,Worker)]
interface `FormData@I {
  `FormData$mc(optional `HTMLFormElement$I %form);

  `undefined$ `append$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `append$m(`USVString$ %name, `Blob$I %value, optional `USVString$ %filename);
  `undefined$ `delete$m(`USVString$ %name);
  `FormDataEntryValue$I? `get$m(`USVString$ %name);
  `sequence$&lt;`FormDataEntryValue$I&gt; `getAll$m(`USVString$ %name);
  `boolean$ `has$m(`USVString$ %name);
  `undefined$ `set$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `set$m(`USVString$ %name, `Blob$I %value, optional `USVString$ %filename);
  `iterable$m&lt;`USVString$, `FormDataEntryValue$I&gt;;
};
</pre>

<p>
各 `FormData$I ~objには、
`~entry~list@fe
が結付けられる
— それは、何個かの`~entry$feからなる`~list$であり，初期~時には空とする。
◎
Each FormData object has an associated entry list (a list of entries). It is initially the empty list.
</p>

<p>
各
`~entry@fe
は、
`名前@fe,
`値@fe
からなる。
◎
An entry consists of a name and a value.
</p>

<p>
他の~algoとヤリトリする目的においては、`~entry$feの~filenameは［
`~entry$feの`値$feが `File$I ~objであるならば その `name$m 属性~値 ／
~ELSE_ 空~文字列
］とする。
◎
For the purposes of interaction with other algorithms, an entry’s filename is the empty string if value is not a File object, and otherwise its filename is the value of entry’s value’s name attribute.
</p>

<div class="algo">
<p>
`~entryを作成する@
ときは、所与の
( %名前, %値, %~filename （省略-時は ε ）)
に対し，次を走らす：
◎
To create an entry for name, value, and optionally a filename, run these steps:
</p>
<ol>
	<li>
%~entry ~LET 新たな`~entry$fe
◎
Let entry be a new entry.
</li>
	<li>
%~entry の`名前$fe ~SET %名前
◎
Set entry’s name to name.
</li>
	<li>
<p>
~IF［
%値 は `Blob$I ~objである
］~AND［［
%値 は `File$I ~objでない
］~OR［
%~filename ~NEQ ε
］］：
</p>
		<ol>
			<li>
%値 ~SET  %値 と同じ~byte列を表現する新たな `File$I ~obj
</li>
			<li>
%値 の `name$m 属性~値 ~SET ［
%~filename ~NEQ ε ならば %~filename ／
~ELSE_ `blob^l
］
</li>
		</ol>

◎
If value is a Blob object and not a File object, then set value to a new File object, representing the same bytes, whose name attribute value is "blob".
◎
If value is (now) a File object and filename is given, then set value to a new File object, representing the same bytes, whose name attribute value is filename.
</li>
	<li>
%~entry の`値$fe ~SET %値
◎
Set entry’s value to value.
</li>
	<li>
~RET %~entry
◎
Return entry.
</li>
</ol>
</div>

<div class="algo">
<p>
`new FormData(form)@m
構築子~手続きは：
◎
The new FormData(form) constructor steps are:
</p>
<ol>
	<li>
~IF［
%form ~EQ ε
］
⇒
~RET
◎
If form is given, then:
</li>
	<li>
%~list ~LET `~entry~listを構築する$( %form )
◎
Let list be the result of constructing the entry list for form.
</li>
	<li>
~IF［
%~list ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
◎
If list is null, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`~entry~list$fe ~SET ~SET %~list
◎
Set this’s entry list to list.
</li>
</ol>
</div>

<div class="algo">
<p>
`append(name, value, filename)@m
~method手続きは：
◎
The append(name, value) and append(name, blobValue, filename) method steps are:
• Let value be value if given; otherwise blobValue.
</p>
<ol>
	<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
	<li>
コレの`~entry~list$feに %~entry を`付加する$
◎
Append entry to this’s entry list.
</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

<div class="algo">
`delete(name)@m
~method手続きは
⇒
コレの`~entry~list$feから 次を満たす`~entry$feをすべて`除去する$
⇒
`名前$fe ~EQ %name
◎
The delete(name) method steps are to remove all entries whose name is name from this’s entry list.
</div>

<div class="algo">
`get(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fe内に 次を満たす`~entry$feは［
在るならば それらのうち最初のものの`値$fe ／
無いならば ~NULL
］
⇒
`名前$fe ~EQ %name
◎
The get(name) method steps are:
• If there is no entry whose name is name in this’s entry list, then return null.
• Return the value of the first entry whose name is name from this’s entry list.
</div>

<div class="algo">
`getAll(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fe内の［
次を満たす`~entry$feすべての`値$fe
］からなる同順の~list（無ければ空~list）
⇒
`名前$fe ~EQ %name
◎
The getAll(name) method steps are:
• If there is no entry whose name is name in this’s entry list, then return the empty list.
• Return the values of all entries whose name is name, in order, from this’s entry list.
</div>

<div class="algo">
`has(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fe内に 次を満たす`~entry$feは［
在るならば ~T ／
無いならば ~F
］
⇒
`名前$fe ~EQ %name
◎
The has(name) method steps are to return true if there is an entry whose name is name in this’s entry list; otherwise false.
</div>

<div class="algo">
<p>
`set(name, value, filename)@m
~method手続きは：
◎
The set(name, value) and set(name, blobValue, filename) method steps are:
• Let value be value if given; otherwise blobValue.
</p>
<ol>
	<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
	<li>
<p>
~IF［
コレの`~entry~list$fe内に次を満たす`~entry$feは在る
］…
⇒
`名前$fe ~EQ %name
</p>

<p>
…ならば
⇒
該当する`~entry$feのうち
⇒＃
最初のものは %~entry に`置換する$,
他のものはすべて`除去する$
</p>
◎
If there are entries in this’s entry list whose name is name, then replace the first such entry with entry and remove the others.
</li>
	<li>
~ELSE
⇒
コレの`~entry~list$feに %~entry を`付加する$
◎
Otherwise, append entry to this’s entry list.
</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

<p>
`iterable@m
における`反復される値~pairたち$を成す各~pairを成す
( ~key, 値 )
は、コレの`~entry~list$feを成す各`~entry$feの
( `名前$fe, `値$fe )
で与えられるとする。
◎
The value pairs to iterate over are this’s entry list’s entries with the key being the name and the value being the value.
</p>

	</section>
	<section id="interface-progressevent">
<h2 title="Interface ProgressEvent">5. ~interface `ProgressEvent^I</h2>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `ProgressEvent@I : `Event$I {
  `ProgressEvent@mc(`DOMString$ %type, optional `ProgressEventInit$I %eventInitDict = {});

  readonly attribute `boolean$ `lengthComputable$m;
  readonly attribute `unsigned long long$ `loaded$m;
  readonly attribute `unsigned long long$ `total$m;
};

dictionary `ProgressEventInit@I : `EventInit$I {
  `boolean$ `lengthComputable@mb = false;
  `unsigned long long$ `loaded@mb = 0;
  `unsigned long long$ `total@mb = 0;
};
</pre>

<p>
`ProgressEvent$I ~interfaceを利用する`~event$は、何らかの進捗を指示する。
◎
Events using the ProgressEvent interface indicate some kind of progression.
</p>

<div class="algo">
`lengthComputable@m,
`loaded@m,
`total@m
取得子~手続きは、いずれも，各自の初期化-時の値を返す。
◎
The lengthComputable, loaded, and total getter steps are to return the value they were initialized to.
</div>

		<section id="firing-events-using-the-progressevent-interface">
<h3 title="Firing events using the ProgressEvent interface">5.1. `ProgressEvent^I ~interfaceを利用する~eventの発火-法</h3>

<p>
%target に向けて，名前 %e の
`進捗~eventを発火する@
ときは、所与の
( %伝送量, %長さ )
に対し
⇒
%target に向けて，名前 %e の`~eventを発火する$
— `ProgressEvent$I を利用し，次のように初期化して
⇒＃
`loaded$m 属性~値 ~SET %伝送量,
`lengthComputable$m 属性~値 ~SET ［ %長さ ~NEQ 0 ならば ~T ／ ~ELSE_ ~F ］,
`total$m 属性~値 ~SET %長さ
◎
To fire a progress event named e at target, given transmitted and length, means to fire an event named e at target, using ProgressEvent, with the loaded attribute initialized to transmitted, and if length is not 0, with the lengthComputable attribute initialized to true and the total attribute initialized to length.
</p>

		</section>
		<section id="suggested-names-for-events-using-the-progressevent-interface">
<h3 title="Suggested names for events using the ProgressEvent interface">5.2. `ProgressEvent^I ~interfaceを利用する~eventに示唆される名前</h3>

~INFORMATIVE

<p>
`ProgressEvent$I ~interfaceを利用する`~event$に示唆される， `type$m 属性の値を、下の一覧に要約する。
仕様の編集者が，その仕様に固有の仔細に応じて~~調整することは自由であるが、~~問題に馴染みのある人達からの~~意見を汲むために，その用法について WHATWG ~communityにて論を交わすことが強く奨励される。
◎
The suggested type attribute values for use with events using the ProgressEvent interface are summarized in the table below. Specification editors are free to tune the details to their specific scenarios, though are strongly encouraged to discuss their usage with the WHATWG community to ensure input from people familiar with the subject.
</p>

<table><thead>
<tr><th>`type$m
◎
type attribute value
<th>記述
◎
Description
<th>回数
◎
Times
<th>時機
◎
When
</thead><tbody>

<tr><th>`loadstart$et
<td>
進捗が~~開始された。
◎
Progress has begun.
<td>1 回
◎
Once.
<td>最初。
◎
First.

<tr><th>`progress$et
<td>
進捗~中。
◎
In progress.
<td>1 回以上
◎
Once or more.
<td>
`loadstart$et が`配送-$された後。
◎
After loadstart has been dispatched.

<tr><th>`error$et
<td>進捗に失敗した。
◎
Progression failed.
<td rowspan="4" style="min-width:6em;">
高々 1 回<br>
（排他的）
◎
Zero or once (mutually exclusive).
<td rowspan="4">
最後の `progress$et が`配送-$された後。
◎
After the last progress has been dispatched.

<tr><th>`abort$et
<td>進捗は終了された。
◎
Progression is terminated.

<tr><th>`timeout$et
<td>
進捗は時間~切れに因り終了された。
◎
Progression is terminated due to preset time expiring.

<tr><th>`load$et
<td>進捗は成功裡に終わった。
◎
Progression is successful.

<tr><th>`loadend$et
<td>進捗は停止された。
◎
Progress has stopped.
<td>1 回
◎
Once.
<td>
`error$et, `abort$et, `timeout$et, `load$et のいずれかが`配送-$された後。
◎
After one of error, abort, timeout or load has been dispatched.

</tbody></table>

<p>
~event型
`error$et, `abort$et, `timeout$et, `load$et
は、互いに排他的である。
<!-- 
【これら 4 種のいずれかは 1 回 生じる】
 -->
◎
The error, abort, timeout, and load event types are mutually exclusive.
</p>

<p>
Web ~platform全般に渡り，~event型
`error$et, `abort$et, `timeout$et, `load$et
の `bubbles$m および `cancelable$m 属性は、 ~F に初期化される。
従って，一貫性を保つため、 `ProgressEvent$I ~interfaceを利用するすべての`~event$も同様にすることが示唆される。
◎
Throughout the web platform the error, abort, timeout and load event types have their bubbles and cancelable attributes initialized to false, so it is suggested that for consistency all events using the ProgressEvent interface do the same.
</p>

		</section>
		<section id="security-considerations">
<h3 title="Security considerations">5.3. ~securityの考慮点</h3>

<p>
非同一-生成元~要請に対しては、例えば 
Fetch 標準にて定義される`~CORS~protocol$
などの，ある種の~opt-inが、 `ProgressEvent$I ~interfaceを利用する`~event$が`配送-$される前に利用される必要がある。
そうすると、他では得せない情報（例：~size）まで露呈されるので。
`FETCH$r
◎
For cross-origin requests some kind of opt-in, e.g., the CORS protocol defined in the Fetch Standard, has to be used before events using the ProgressEvent interface are dispatched as information (e.g., size) would be revealed that cannot be obtained otherwise. [FETCH]
</p>

		</section>
		<section id="example">
<h3 title="Example">5.4. 用例</h3>

<div class="example" id="example-progress-events">

<p>
次の例では、 `XMLHttpRequest$I に，前~節にて定義された概念が組合され、`~fetching$の過程の表示に~HTML `progress$e 要素が利用される。
◎
In this example XMLHttpRequest, combined with concepts defined in the sections before, and the HTML progress element are used together to display the process of fetching a resource.
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;title&gt;Waiting for Magical Unicorns&lt;/title&gt;
&lt;progress id=p&gt;&lt;/progress&gt;
&lt;script&gt;
  var %progressBar = document.getElementById("p"),
      %client = new XMLHttpRequest()
  %client.open("GET", "magical-unicorns")
  %client.onprogress = function(%pe) {
    if(%pe.lengthComputable) {
      %progressBar.max = %pe.total
      %progressBar.value = %pe.loaded
    }
  }
  %client.onloadend = function(%pe) {
    %progressBar.value = %pe.loaded
  }
  %client.send()
&lt;/script&gt;
</pre>

<p>
もちろん，全部的に~~機能する~codeは、より精巧かつ，~network~errorや末端利用者からの終了-要請など，より多くの局面に対応するものになるだろうが。
◎
Fully working code would of course be more elaborate and deal with more scenarios, such as network errors or the end user terminating the request.
</p>

</div>

		</section>
	</section>
	<section id="acknowledgments">
<h2>謝辞</h2>

<p>
この標準に貢献された、次の方々に感謝する：
</p>

`_acks1@

<p>
Windows Internet Explorer にて初めて実装し，
`XMLHttpRequest$I ~interfaceを最初に広めた Microsoft の開発者たちに特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented the XMLHttpRequest interface, which was first widely deployed by the Windows Internet Explorer browser.
</p>

<p>
HTML Standard （ Web Applications 1.0 ）にて、この仕様の初期~versionを草案~化された Ian Hickson 氏に特別な謝意を。
`HTML$r
◎
Special thanks to Ian Hickson for drafting an initial version of this specification in the HTML Standard (then Web Applications 1.0). [HTML]
</p>

<p>
<a href="https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/svgudom.html">SVG Micro DOM</a>
の一部として、元々の `ProgressEvent^I ~classの草案を作成した W3C SVG WG に特別な謝意を。
◎
Special thanks to the W3C SVG WG for drafting the original ProgressEvent class as part of the SVG Micro DOM.
</p>

<p lang="en-x-a0">
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>

<div lang="en-x-a0" id="_acks1">
Thanks to

Addison Phillips,
Adrian Bateman,
Ahmed Kamel,
Alan Thomas,
Alex Hopmann,
Alex Vincent,
Alexey Proskuryakov,
Ali Alabbas,
Andrea Marchesini,
Asbjørn Ulsberg,
Bertrand Guay-Paquet,
Björn Höhrmann,
Boris Zbarsky,
Caitlin Potter,
Cameron McCormack,
白丞祐 (Cheng-You Bai),
Chris Marrin,
Christophe Jolif,
Charles McCathieNevile,
Dan Winship,
David Andersson,
David Flanagan,
David Håsäther,
David Levin,
Dean Jackson,
Denis Sureau,
Domenic Denicola,
Dominik Röttsches,
Doug Schepers,
Douglas Livingstone,
Elliott Sprehn,
Elliotte Harold,
Eric Lawrence,
Eric Uhrhane,
Erik Arvidsson,
Erik Dahlström,
Feras Moussa,
Gideon Cohn,
Glenn Adams,
Gorm Haug Eriksen,
Gregory Terzian,
Håkon Wium Lie,
Hallvord R. M. Steen,
Henri Sivonen,
Hiroshige Hayashizaki,
Huub Schaeks,
Ian Clelland,
Ian Davis,
Ian Hickson,
Ivan Herman,
Jake Archibald,
Jared Jacobs,
Jarred Nicholls,
Jeff Walden,
Jens Lindström,
Jim Deegan,
Jim Ley,
Joe Farro,
Jonas Sicking,
Julian Reschke,
송정기 (Jungkee Song),
呂康豪 (Kang-Hao Lu),
Karl Dubost,
Keith Yeung,
田村健人 (Kent TAMURA),
Lachlan Hunt,
Maciej Stachowiak,
Magnus Kristiansen,
Manish Goregaokar,
Marc Hadley,
Marcos Caceres,
Mark Baker,
Mark Birbeck,
Mark Nottingham,
Mark S. Miller,
Martin Hassman,
Mike Pennisi,
Mohamed Zergaoui,
Ms2ger,
Odin Hørthe Omdal,
Olli Pettay,
Pawel Glowacki,
Peter Michaux,
Philip Jägenstedt,
Philip Taylor,
Robin Berjon,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ruud Steltenpool,
Ryo Onodera,
Sam Sneddon,
Sergiu Dumitriu,
Shivakumar Jagalur Matt,
Sigbjørn Finne,
Simon Pieters,
Stewart Brodie,
Sunava Dutta,
Takeshi Kurosawa,
Takeshi Yoshino,
Thomas Roessler,
Thomas Wisniewski,
Tom Magliery,
Travis Leithead,
triple-underscore,
Yaron Tausky,
Yehuda Katz,
Youenn Fablet, and
Zhenbin Xu

for their contributions to this standard.
</div>

<div lang="en-x-a0" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://xhr.spec.whatwg.org/review-drafts/2020-08/">Living Standard Review Draft</a>.
</p>
</div>

</div>

