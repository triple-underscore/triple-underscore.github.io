<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Long Tasks API （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Long Tasks API
spec_date:2023-11-26
trans_update:2023-12-04
source_checked:201202
page_state_key:TIMING
original_url:https://w3c.github.io/longtasks/
	abbr_url:LONGTASKS
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
copyright:2023,permissive
trans_1st_pub:2019-03-06

●●class_map
E:error
a:attr
e:element
et:event-type

●●tag_map
I:code
m:code
a:code
e:code
et:code
c:code
E:code
v:var
V:var
b:b
i:i

●●original_id_map

●●mdn_urls
performancelongtasktiming:API/PerformanceLongTaskTiming
taskattributiontiming:API/TaskAttributionTiming

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default

object:~WEBIDL#idl-object
FrozenArray:~WEBIDL#idl-frozen-array
DOMString:~WEBIDL#idl-DOMString

I.PerformanceEntry:~TIMELINE#the-performanceentry-interface
I.PerformanceLongTaskTiming:#performancelongtasktiming
I.PerformanceLongAnimationFrameTiming:#performancelonganimationframetiming
I.TaskAttributionTiming:#taskattributiontiming
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.PerformanceEntry:~TIMELINE#dom-performanceentry
~window:~WINDOW#the-window-object
	I.Window:~WINDOW#window
I.Cache:~SW1#cache

m.attribution:#dom-performancelongtasktiming-attribution
	m.toJSON:#dom-performancelongtasktiming-tojson

m.containerType:#dom-taskattributiontiming-containertype
m.containerName:#dom-taskattributiontiming-containername
m.containerId:#dom-taskattributiontiming-containerid
m.containerSrc:#dom-taskattributiontiming-containersrc
	m.toJSON:dom-taskattributiontiming-tojson

m.duration:~TIMELINE#dom-performanceentry-duration
m.entryType:~TIMELINE#dom-performanceentry-entrytype
m.name:~TIMELINE#dom-performanceentry-name
m.startTime:~TIMELINE#dom-performanceentry-starttime
m.supportedEntryTypes:~TIMELINE#supportedentrytypes-attribute

m.renderStart:#dom-performancelonganimationframetiming-renderstart
m.styleAndLayoutStart:#dom-performancelonganimationframetiming-styleandlayoutstart
m.blockingDuration:#dom-performancelonganimationframetiming-blockingduration
	m.toJSON:#dom-performancelonganimationframetiming-tojson

m.requestIdleCallback:~REQUESTIDLECALLBACK#dom-window-requestidlecallback
m.requestAnimationFrame:~HTMLGAPI#dom-animationframeprovider-requestanimationframe

m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes

l.unknown:#unknown
l.self:#self
l.same-origin-ancestor:#same-origin-ancestor
l.same-origin-descendant:#same-origin-descendant
l.same-origin:#same-origin
l.cross-origin-ancestor:#cross-origin-ancestor
l.cross-origin-descendant:#cross-origin-descendant
l.cross-origin-unreachable:#cross-origin-unreachable
l.multiple-contexts:#multiple-contexts

e.iframe:~HEembed#the-iframe-element
e.object:~HEembed#the-object-element
e.embed:~HEembed#the-embed-element
e.frame:~HTMLobs#frame


a.name:~HEembed#attr-iframe-name
a.~nameO:~HEembed#attr-object-name
a.src:~HEembed#attr-iframe-src
a.~srcE:~HEembed#attr-embed-src

a.data:~HEembed#attr-object-data

	●用語
長い~task:#long-task
元凶~閲覧~文脈~容器:#culprit-browsing-context-container
	container:#culprit-browsing-context-container
	culprit閲覧~文脈:#culprit-browsing-context-container
閲覧~文脈~容器:#browsing-context-container

帰属:#attribution
極小な元凶~帰属:#minimal-culprit-attribution

長い~taskを報告する:#report-long-tasks


	●用語（~animation~frame
長い~animation~frame:#long-animation-frame
計時~報:#performancelonganimationframetiming-timing-info
~frame計時~報:#frame-timing-info
ftI.開始~時刻:#frame-timing-info-start-time
ftI.現在の~taskの開始~時刻:#frame-timing-info-current-task-start-time
ftI.描画~更新の開始~時刻:#frame-timing-info-update-the-rendering-start-time
ftI.~styleと~layoutの開始~時刻:#frame-timing-info-style-and-layout-start-time
ftI.終了~時刻:#frame-timing-info-end-time
ftI.最も長い~task所要時間:#frame-timing-info-longest-task-duration

doc.現在の~frame計時~報:#current-frame-timing-info
同一-生成元に属する最も近い根:#nearest-same-origin-root
関連な~frame計時~報:#relevant-frame-timing-info
~task開始~時刻を報告する:#report-task-start-time
~task終了~時刻を報告する:#report-task-end-time
描画~時刻を報告する:#report-rendering-time
~frame計時を書出す:#flush-frame-timing


	●用語（外部
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

~realm:~TC39#sec-code-realms

~ID:~DOM4#concept-id
文書:~DOM4#concept-document
	I.Document:~DOM4#document
doc.生成元:~DOM4#concept-document-origin

処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
~supportする~entry型~群:~TIMELINE#dfn-frozen-array-of-supported-entry-types

~navigable:~HTMLds#navigable
nav.作動中な文書:~HTMLds#nav-document
nav.容器:~HTMLds#nav-container
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
~node~navigable:~HTMLds#node-navigable
先祖~navigable:~HTMLds#ancestor-navigables
先祖~navigable群:~HTMLds#ancestor-navigables
閲覧~文脈:~HTMLds#browsing-context
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
先祖~閲覧~文脈:~HTMLds#ancestor-browsing-context
閲覧~文脈~group:~HTMLds#browsing-context-group
	廃）互いに関係する閲覧~文脈~群:~BROWSERS#unit-of-related-browsing-contexts

bc.容器:~BROWSERS#bc-container
子孫~閲覧~文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
子孫~閲覧~文脈:~BROWSERS#list-of-the-descendant-browsing-contexts

同一-生成元:~ORIGIN#same-origin

~task:~WAPI#concept-task
~event~loop処理~model:~WAPI#event-loop-processing-model
~event~loop:~WAPI#event-loop
小task:~WAPI#microtask
enV.生成元:~WAPI#concept-settings-object-origin
enV.大域~obj:~WAPI#concept-settings-object-global
	enV.担当の閲覧~文脈:~WAPI#responsible-browsing-context
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
関連な~realm:~WAPI#concept-relevant-realm
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な~agent:~WAPI#relevant-agent

対応する閲覧~文脈:~WINDOW#window-bc

描画を更新する段:~WAPI#update-the-rendering
~script評価 環境~設定群~obj集合:~WAPI#script-evaluation-environment-settings-object-set

~agent~cluster:~WAPI#integration-with-the-javascript-agent-cluster-formalism

	単位~of関係する閲覧~文脈s:https://html.spec.whatwg.org/multipage/#unit-of-related-browsing-contexts

新たな~obj:~WEBIDLjs#new
凍結d配列を作成する:~WEBIDLjs#dfn-create-frozen-array

時刻を粗化する:~HRTIME#dfn-coarsen-time
所要時間:~HRTIME#dfn-duration
所要時間を得る:~HRTIME#dfn-duration-from
相対的な高分解能~時刻:~HRTIME#dfn-relative-high-resolution-time
安全でない共有される現在の時刻:~HRTIME#dfn-unsafe-shared-current-time
	1.安全でない現在の時刻:~HRTIME#monotonic-clock-unsafe-current-time
安全でない~moment:~HRTIME#dfn-unsafe-moment

●●words_table1
REQUESTIDLECALLBACK:requestidlecallback-ja.html
nameO:name
srcE:src

●●words_table


	●処理一般
poll:
	~pollし続ける:polling
小task:microtask::小 task:小タスク
main::::メイン
checkpoint:
	直後の:follows immediately afterwards
process::::プロセス

満了:expiration:~
	各~満了から次回の満了まで:between the successive expirations
丸める:roundする:~
揺らぎ:jitter:~
分解能:resolution::~
粒度:granularity:~
書出す:flushする::書き出す

	%元凶~設定群:culpritSettings
	%閲覧~文脈:bc
	%行先~設定群:destinationSettings
	%行先~realm群:destinationRealms
	%行先~realm:destinationRealm
	%元凶~閲覧~文脈:culpritBC
	%T:topmostBC
	%~top-level閲覧~文脈~群:top-level browsing contexts
	-:descendantBCs
	子孫:descendantBC
	行先~閲覧~文脈:destinationBC
	-:destinationOrigin
	新たな~entry:newEntry
	%非同一-生成元~能力は隔離されるか:crossOriginIsolatedCapability
	%作業~所要時間:workDuration
	%描画-所要時間:renderDuration
	%文書:document
	%先祖~群:ancestors
	%先祖~navigable:ancestorNavigable
	%安全でない~task開始~時刻:unsafeTaskStartTime
	%根:root
	%安全でない~task終了~時刻:unsafeTaskEndTime
	%計時~報:timingInfo
	%安全な~task終了~時刻:safeTaskEndTime
	%安全な~task開始~時刻:safeTaskStartTime
	%現在の~task所要時間:currentTaskDuration
	%安全でない~styleと~layoutの開始~時刻:unsafeStyleAndLayoutStart
	%安全でない終了~時刻:unsafeEndTime
	%大域~obj:global
	%~frame所要時間:frameDuration

	●計時／long task／animation frame task
極小:minimal:~
帰属:attribution::~
長い:long::~
	長い~task:longtask
出自に:originate:~
元凶:culprit::~
timer::::タイマー
経過-:elapse::~
静止:pause::~
遊休:idle::~

	“静止期間”:quiescence
	遊休~時に走らす~codeに割り当てられる “静止期間” が細切れになる:prevents quiescence and long idle blocks
schedule::::スケジュール
周期:period:~
	期間:period
周期的:periodic:~
	長期間:extended periods of time
	以内:in under
超過-:exceed:~
閾値:threshold:~
粗化-:coarsen:粗く
高分解能:high-resolution::~
moment:
輻輳:congestion:~
計量:metric:~
多忙:busy:~
相:phase:~

	以内:threshold
	になる時機:time to
	速く:faster
	長い~task用の~API:Long Tasks API
	長い~animation~frame用の~API:Long Animation Frames API
	ms:millisecond
	^en:the sequence
	^en:a sequence

	●UI
critical:
scrolling::::スクロール処理
touch::::タッチ
	^en:tap, click, scroll, wheel
活動:activity:~
	-:〜 interactions
応答性:responsiveness::~
知覚-:preceive:~
	ヤリトリ可能:interactive
	締め出され:locked up
	~~長い:high
	可変:variable
	即応しない:janky／:yields janky
	非即応性:jank
	可視でなくなる:hidden

	●保安
悪用-:exploit:~
side-channel::::サイドチャネル
脆弱:vulnerable:~
推測-:guess:~
露呈-:reveal:露わに
展示:gallery:~
隠され:hideされ:~
絵図:picture:~
年齢:age:~
	20 代の:of age 20-30
性別:gender:~
関心事:interests:~
女性:female:~
username::::ユーザ名
social::::ソーシャル
permalink:
私的:private::~::プライベート
対象層:demographic:~
利用量:usage:~
	~~丸める:clampする
適格:eligible:~
忠実度:fidelity:~

	信用されない:untrusted
	非同一-生成元:cross origin
	同一-生成元に属さない:非同一-生成元に属する
	生成元~安全:origin-safe

	軽減-:mitigation
	抗する／対し:against
	ぼやかす:obfuscate

	●仕様
	~web~site:website
寄与-:contribute:~
	予測-不能:unpredictable

協調:coordination:~
独占-:monopolize:~
今日:today:~
拙く:poorに:~
参考な:informativeな:規範的でない
必要十分:adequate:~
捕捉-:capture:~
表面化-:surface:~
	短命:bad for battery life
	~~悪影響を及ぼす:bad 〜 implications
側面f:facet:側面
改修-:revamp:~
現象:phenomenon:~
補償-:remedy:~
説明書き:explainer:~
中心な:-centricな:~
相関-:correlate:~
	もっと相関する:better correlation
	~~相関する:independent
	できなく:prevent
	~~目的:target
	ことになるはず:should
	用例:usage example
	大体は:mostly
	今の所は:for now
	見込みが高い:high likelihood
	であろう:likely
	易くする:help
	知られ:known
	知る:know
	知れる／知る:see
	指す:refer
	称され:referred
	〜版:iterations
	~~連携:tie up
	よくある:frequent
	~~関与-:be implicated
	~~原因がどこにあるか:where the blame rests for
	不能:unable
	~~実像を~~描く:paint the picture
	~~調べる:look up
	もの:occurrence
	抵触する:prevent 〜 from hitting
	どこからも〜ない:nobody
	〜し難くする:harder to 〜
	組みで:AND
	生じさせ:causing／:caused
	それを超える:afterwards
	より高-:higher
	問わず:regardless
	例として:for instance
	逆に:conversely
	すべて:everything else
	一貫性に欠く:inconsistency
	保たれ:keepされ
	廃された:outdated
	委ねられる部分がある:term is somewhat of
	この仕様が追加する:addition

	●未分類
agent:
iframe:
解析:analytics:~
battery::::バッテリー
背後:behind:~
組成器:compositor::~
分量:volume:~
深く:deepに:~

	後続して:followed by
	^cite:Long Tasks
	^m:setTimeout
	空~文字列:""
	指すもの:pointing to
	わたる:span
	含めて:including
	起こる:happen
	短い:short
	担当していた:responsible
	と:plus
	等し:equal
	~MINUS:minus
	~LT:less than
	-:as follows
	^et:onload
	:unset
	:unit of related browsing contexts
	可視になる:gain visibility

	少数の:a couple of
	大多数の:major
	全体的に:on the whole
	いずれか:one of
	1 個ずつ:one-by-one
	一つも〜ない:no single
	合間:between
	-:back
	様々な:various
	次回の:next
	次の／次に挙げる:the-following
	等:and so on
	超える:greater than
	読込まれた〜:afterwards
	それを超える:afterwards
	全体の中での:overall
	組みで:together
	より高い:higher
	最も近い:nearest
	これまで:previous
	違い:vs
	何も無い:nothing
	ときから〜ときまでを成す:begins when 〜 end when
	指す:refer
	内部状態管理:bookkeeping detail
	:,after which

●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[HR-TIME-2]
    Ilya Grigorik. ＜High Resolution Time Level 2＞. URL: https://w3c.github.io/hr-time/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PERFORMANCE-TIMELINE]
    Nicolas Pena Moreno. ＜Performance Timeline＞. URL: https://w3c.github.io/performance-timeline/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Long Tasks API</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/longtasks-1/
公表履歴
	https://www.w3.org/standards/history/longtasks-1/
テスト一式
	http://w3c-test.org/longtask-timing/
課題追跡
	<a href="https://github.com/w3c/longtasks/issues/">GitHub</a>
編集
	<a href="mailto:nrosenthal@google.com">Noam Rosenthal</a> (Google)
前任編集者
	<a href="mailto:panicker@chromium.org">Shubhie Panicker</a> (Google)
	<a href="mailto:igrigorik@chromium.org">Ilya Grigorik</a> (Google)
	<a href="mailto:domenic@chromium.org">Domenic Denicola</a> (Google)
commit 履歴
	https://github.com/w3c/longtasks/commits/main/
公表者
	<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
メーリングリスト／フィードバック
	<a href="mailto:public-web-perf@w3.org?subject=%5BLongTasks%5D">public-web-perf@w3.org</a> (<a href="mailto:public-web-perf-request@w3.org?subject=subscribe">subscribe</a>, <a href="https://lists.w3.org/Archives/Public/public-web-perf/">archives</a>)

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Long Tasks API</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、
~web~page作者が “長い~task” が在ることを検出するために利用できる~APIを定義する
— ~UI~threadを長期間~独占して，他の~criticalな~task（例：利用者~入力に反応するなど）を実行するのを阻むような。
◎
This document defines an API that web page authors can use to detect presence of "long tasks" that monopolize the UI thread for extended periods of time and block other critical tasks from being executed - e.g. reacting to user input.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~pageが読込まれるに伴い, および利用者が読込まれた~pageとヤリトリする間、［
~app, ~browser
］の両者とも，後で~browserにより実行されるような様々な~eventを~queueする
— 例えば：
~UAは、
利用者の活動に基づいて入力~eventを~scheduleする ／
~appは、
`requestAnimationFrame()$m 用の~callbackや他の~callback, 等々を~scheduleする。
~queueされたこれらの~eventは、
~browserにより 1 個ずつ~dequeueされ, 実行される。
◎
As the page is loading and while the user is interacting with the page afterwards, both the application and browser queue various events that are then executed by the browser -- e.g. user agent schedules input events based on user’s activity, the application schedules callbacks for requestAnimationFrame and other callbacks, etc. Once in the queue, the browser dequeues these events one-by-one and executes them.
</p>

<p>
しかしながら，~taskには長い時間（複数の~frame）かかり得るものもあり、
それが起きた場合／とき，
~UI~threadは阻まれ，他のすべての~taskも阻まれる結果になり得る。
これは、
利用者からは［
利用者~入力に対し~browserが応答-不能になり，~pageから “締め出される”
］ことにより，共通的に可視になる。
今日における~web上の不良な利用者~体験の大多数は、
それが~sourceにある：
◎
However, some tasks can take a long time (multiple frames) and if/when that happens, the UI thread may become blocked and block all other tasks as well. To the user, this is commonly visible as a "locked up" page where the browser is unable to respond to user input; this is a major source of bad user experience on the web today:
</p>

<dl>
	<dt>
“ヤリトリ可能になる時機” が遅延される：
◎
Delayed "time to Interactive":
</dt>
	<dd>
~pageが読込まれる間，あるいは視覚的には完全に具現化されていても、
長い~taskは~main~thread†と~~連携することが多い
— その結果、
利用者は~pageとヤリトリできなくなる。
よくある元凶として、
拙く設計された第三者-主体の内容が挙げられる。
◎
while the page is loading, or even completely visually rendered, long tasks often tie up the main thread and prevent the user from interacting with the page. Poorly designed third-party content is frequently the culprit.
</dd>
	<dd class="trans-note">【†
`~event~loopの処理＠~WAPI#event-loop-processing-model$を遂行する~thread
（`概略的な説明＠https://developer.mozilla.org/docs/Glossary/Main_thread$）。
】</dd>

	<dt>
入力の待時間が~~長い／可変：
◎
High/variable input latency:
</dt>
	<dd>
~criticalな利用者~対話~event
（例： `tap^en, `click^en, `scroll^en, `wheel^en, 等々）
は、
長い~taskの背後に~queueされ，即応しない
— その結果、
利用者~体験は予測-不能になる。
◎
critical user-interaction events (e.g. tap, click, scroll, wheel, etc.) are queued behind long tasks which yields janky and unpredictable user experience.
</dd>

	<dt>
~event取扱いの待時間が~~長い／可変：
◎
High/variable event handling latency:
</dt>
	<dd>
入力~同様、
~event~callback（例： `onload^et ~event, 等々）の処理は，
~appの更新を遅延する。
◎
like input, processing event callbacks (e.g. onload events, etc.) delay application updates.
</dd>

	<dt>
即応しない［
~animation／~scrolling
］：
◎
Janky animations and scrolling:
</dt>
	<dd>
一部の［
~animation／~scrolling
］は、
組成器と~main~threadとの間の協調を要求する
— 長い~taskが~main~threadを阻んでいる場合、［
~animation／~scrolling
］の応答性に影響し得る。
◎
some animation and scrolling interactions require coordination between compositor and main threads; if a long task is blocking the main thread it can affect responsiveness of animations and scrolling.
</dd>
</dl>

<p>
一部の~app
（および `RUM＠https://en.wikipedia.org/wiki/Real_user_monitoring$ ~vendor
【 `real user monitoring^en ／ “現実の利用者~体験の監視” 】
）は、
すでに， “長い~task” が起こる事例を識別して追跡しようと試みている。
一例として、
短い周期的な~timerを~installした上で，各~満了から次回の満了までに経過した時間を検分する~patternが知られている。
経過した時間が~timer周期を超えるならば、
1 個~以上の長い~taskが~event~loopの実行を遅延させた見込みが高いことになる。
この~approachは、
大体は働くが，いくつかの点で処理能に~~悪影響を及ぼす：
◎
Some applications (and RUM vendors) are already attempting to identify and track cases where "long tasks" happen. For example, one known pattern is to install a ~short periodic timer and inspect the elapsed time between the successive expirations: if the elapsed time is greater than the timer period, then there is high likelihood that one or more long tasks have delayed execution of the event loop. This approach mostly works but has several bad performance implications:＼
</p>
<ul>
	<li>
長い~taskを検出するために~pollし続けることにより、
~appが遊休~時に走らす~codeに割り当てられる “静止期間” が細切れになる
（ `requestIdleCallback()$m を見よ）。
◎
by polling to detect long tasks, the application prevents quiescence and long idle blocks (see requestIdleCallback);＼
</li>
	<li>
~batteryが短命になる。
◎
it’s bad for battery life;＼
</li>
	<li>
何が遅延させているか知るすべが無い
（例：当事者-主体, 第三者-主体 どちらの~codeか？）。
◎
there is no way to know what is causing the delay (e.g. first party or third party code).
</li>
</ul>

<p>
`RAIL＠https://developers.google.com/web/fundamentals/performance/rail$
（ `Response Animation Idle Load^en ）処理能~modelから、［
~appは，利用者~入力に対し 100ms 以内に応答するべきである
］と示唆されている
（~touchによる移動-や~scrollingにおいては 16ms 以内）。
この~APIの目標は、
この~~目的に抵触し得る~taskについての通知を表面化することである。
この~APIは、
50ms 以上かかる~taskを表面化する。
そのような~taskを伴わない~web~siteならば、
利用者~入力に対し
— それを受信した時点で実行-中の~taskが完遂するまで 50ms 未満,
それに反応する~taskを実行するのも 50ms 未満になるので —
100ms 以内に応答することになるはずである。
◎
The RAIL performance model suggests that applications should respond to user input in less than 100ms (for touch move and scrolling, the threshold is 16ms). The goal of this API is to surface notifications about tasks that may prevent the application from hitting these targets. This API surfaces tasks that take 50ms or more. A website without these tasks should respond to user input in under 100ms: it will take less than 50ms to finish the task that is being executed when the user input is received and less than 50ms to execute the task to react to such user input.
</p>

		<section id="example">
<h3 title="Usage Example">1.1. 用例</h3>

<pre class="example lang-js">
const %observer = new PerformanceObserver(function(%list) {
    for (const %entry of %list.getEntries()) {
        /* <span class="comment">
長い~task通知を処理する：解析と監視~用に報告する…
◎
Process long task notifications: report back for analytics and monitoring ...
</span> */
    }
});
/* <span class="comment">
これまで, および未来における長い~taskの通知~用に，観測器を登録する
◎
Register observer for previous and future long task notifications.
</span> */
%observer.observe({type: "longtask", buffered: true});
/* <span class="comment">
以降，長い~script実行が生じたときは、
観測器にて `longtask^l ~entryが~queueされ，受信されるようになる。
◎
Long script execution after this will result in queueing and receiving "longtask" entries in the observer.
</span> */

/* <span class="comment">
これまで, および未来における長い~animation~frameの通知~用に観測器を登録する。
以降，
~main~threadが長い期間~多忙な所では、
観測器にて `long-animation-frame^l ~entryが~queueされ，受信されるようになる。
◎
Register observer for previous and future long animation frame notifications. After this, long periods where the main thread is busy will result in queueing and receiving "long-animation-frame" entries in the observer.
</span> */
%observer.observe({type: "long-animation-frame", buffered: true});
</pre>

		</section>
		<section id="loaf-vs-longtasks">
<h3 title="Long Animation Frames vs. Long Tasks">1.2. 長い~animation~frameと長い~taskの違い</h3>

<p>
長い~taskも, 長い~animation~frameも，輻輳や非即応性（ `jank^en ）を測定するが、
長い~animation~frameは，
この種の輻輳を利用者が どう知覚するかに もっと相関する情報を供する
— 長い~animation~frameは、
~main~threadが遊休になったときから［
当の~frameが描画されるか，~UAが描画するものは何も無いと裁定する
］ときまでを成す `a sequence^en を測定するので。
◎
While both long tasks and long animation frames measure congestion and jank, long animation frames provide information that has a better correlation with how user preceive this type of congestion. That’s because long animation frames measure a sequence that begins when the main thread is idle, and end when the frame either renders or the user agents decides there is nothing to render.
</p>

<p>
`~task$には、
実装の詳細に委ねられる部分がある。
この仕様が追加する長い~animation~frame用の~APIは、
それを補償するよう試みる
— 同じ［
~main~threadの［
輻輳／非即応性
］を成す現象
］に関して，もっと利用者~中心な計量を導入することにより。
◎
The task term is somewhat of an implementation detail, and the long animation frame addition attempts to remedy that by introducing a more user-centric metric of the same phenomenon of main thread congestion/jank.
</p>

<p>
長い~animation~frameは，
1 回の描画~相にかかる最大を有することが保証されるので、
描画~相~自体について追加的な情報を公開するためにも利用できる
— `renderStart$m や `styleAndLayoutStart$m など。
◎
Because long animation frames are guaranteed to have a maximum of one rendering phase, we can also use them to expose additional information about the rendering phase itself, such as renderStart and styleAndLayoutStart.
</p>

<p>
長い~animation~frameについての詳細な説明は、
`説明書き＠https://github.com/w3c/longtasks/blob/main/loaf-explainer.md$
を見よ。
◎
For a detailed explanation about long animation frames, see the explainer.
</p>

		</section>
	</section>
	<section id="sec-terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
`長い~task@
（ `long task^en ）とは、
次に挙げるもののうち，所要時間が 50ms を超過するものを指す：
◎
Long task refers to any of the following occurrences whose duration exceeds 50ms:
</p>

<ul>
	<li>
~event~loop`~task$
【`~event~loop処理~model$の最初の段で選ばれる~task】
と直後の`小task~checkpointを遂行する$ 段。
これは、
ある~event~loop`~task$の所要時間を
— それに結付けられた`小task$も含めて —
捕捉する。
◎
An event loop task plus the perform a microtask checkpoint that follows immediately afterwards. This captures the duration of an event loop task, including its associated microtasks.
</li>
	<li>
`~event~loop処理~model$の中の`描画を更新する段$。
◎
An update the rendering step within the event loop processing model.
</li>
	<li>
`~event~loop処理~model$の最後の段から次回の最初の段までにおける静止。
これは、［
`~event~loop$の外側にある~UAの~UI~thread
］内で~UAが遂行する作業を捕捉する。
◎
A pause between the last step and the next first step of the event loop processing model. This captures any work that the user agent performs in its UI thread outside of the event loop.
</li>
</ul>

<p>
所与の`閲覧~文脈$ %閲覧~文脈 用の
`閲覧~文脈~容器@
は、
%閲覧~文脈 にて`作動中な文書$navの`~node~navigable$の`容器$navである。
◎
The browsing context container for a browsing context bc is bc’s active document's node navigable's container.
</p>

<p class="note">注記：
これは，【~HTMLから】廃された用語であり、
この仕様を改修するときには，新たな用語が再利用されるべきである。
◎
Note: This term is outdated, and the new terms should be reused when revamping this.
</p>

<p class="trans-note">【
この仕様には、［
他にも，実質的に廃された用語を利用している箇所／
`閲覧~文脈$と`~navigable$を一緒くたに
（およそ、
`~navigable$と，それにて`作動中な閲覧~文脈$navを同一視するような形で）
扱っている箇所
］がいくつかある。
】</p>

<p>
`元凶~閲覧~文脈~容器@
（ `culprit browsing context container^en ）とは、
ある`長い~task$に全体的に~~関与している`閲覧~文脈~容器$（ `iframe$e, `object$e, 等々）を指す。
◎
Culprit browsing context container refers to the browsing context container (iframe, object, etc.) that is being implicated, on the whole, for a long task.
</p>

<p>
`長い~task$の
`帰属@
（ `attribution^en ）とは、
次を識別するものを指す
⇒
長い~taskに有意に寄与した作業の種別（ ~script, ~layoutなど）, および
その作業を担当していた`元凶~閲覧~文脈~容器$
◎
Attribution refers to identifying the type of work (such as script, layout etc.) that contributed significantly to the long task, as well as identifying which culprit browsing context container is responsible for that work.
</p>

<p>
`長い~animation~frame@
とは、［
`描画を更新する段$で描画を更新することが必要yあり得る`~task$
］のうち，［
必要yでないものは，そのことが判明するまで／
必要yであるものは，当の~taskの終了まで
］の所要時間が 50ms を超過するものを指す。
◎
Long animation frame refers to any of the following occurrences whose duration exceeds 50ms:
• A task, after which updating the rendering is not necessary.
• A task after which updating the rendering is necessary, up until rendering is updated.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
ms は、
ミリ秒単位（ `milliseconds^en ）を表す。
</p>

	</section>
	<section id="sec-longtask-timing">
<h2 title="Long Task Timing">3. 長い~taskの計時</h2>

<p>
長い~taskの計時は、
この節に与える新たな~interfaceを孕む。
◎
Long Task timing involves the following new interfaces:
</p>

		<section id="sec-PerformanceLongTaskTiming">
<h3 title="PerformanceLongTaskTiming interface">3.1. `PerformanceLongTaskTiming^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `PerformanceLongTaskTiming@I : `PerformanceEntry$I {
    readonly attribute `FrozenArray$&lt;`TaskAttributionTiming$I&gt; `attribution$m;
    [`Default$] `object$ `toJSON＠#dom-performancelongtasktiming-tojson@m();
};
</pre>

<p>
`PerformanceLongTaskTiming$I の各種 属性の値は、
`長い~taskを報告する$処理~modelにて設定される。
それらがどう設定されるかについて，参考な要約を以下に供する：
◎
The values of the attributes of a PerformanceLongTaskTiming are set in the processing model in § 5.1 Report long tasks. The following provides an informative summary of how they will be set.
</p>

<ul>
	<li>
<p>
`name$m
属性の取得子は、［
当の長い~taskが出自にしているのは、
どの`閲覧~文脈$の中の~event~loop`~task$か
］に応じて，次に挙げるいずれかの文字列を返すことになる：
◎
The name attribute’s getter will return one of the following strings:
</p>
		<dl>
			<dt>`unknown@l</dt>
			<dd>
~UAが`~event~loop$の外側で遂行した作業
◎
The long task originated from work that the user agent performed outside of the event loop.
</dd>

			<dt>`self@l</dt>
			<dd>
この`閲覧~文脈$。
◎
The long task originated from an event loop task within this browsing context.
</dd>

			<dt>`same-origin-ancestor@l</dt>
			<dd>
`同一-生成元$に属する`先祖~navigable$。
◎
The long task originated from an event loop task within a same-origin ancestor navigable.
</dd>

			<dt>`same-origin-descendant@l</dt>
			<dd>
`同一-生成元$に属する`子孫~閲覧~文脈$。
◎
The long task originated from an event loop task within a same-origin descendant browsing context.
</dd>

			<dt>`same-origin@l</dt>
			<dd>
`同一-生成元$に属するが，先祖でも子孫でもない`閲覧~文脈$。
◎
The long task originated from an event loop task within a same-origin browsing context that is not an ancestor or descendant.
</dd>

			<dt>`cross-origin-ancestor@l</dt>
			<dd>
`同一-生成元$に属さない`先祖~navigable$。
◎
The long task originated from an event loop task within a cross-origin ancestor navigable.
</dd>

			<dt>`cross-origin-descendant@l</dt>
			<dd>
`同一-生成元$に属さない`子孫~閲覧~文脈$。
◎
The long task originated from an event loop task within a cross-origin descendant browsing context.
</dd>

			<dt>`cross-origin-unreachable@l</dt>
			<dd>
`同一-生成元$に属さない, かつ先祖でも子孫でもない`閲覧~文脈$。
◎
The long task originated from an event loop task within a cross-origin browsing context that is not an ancestor or descendant.
</dd>

			<dt>`multiple-contexts@l</dt>
			<dd>
~event~loop`~task$のうち，複数の`閲覧~文脈$を孕んでいるもの。
◎
The long task originated from an event loop task involving multiple browsing contexts.
</dd>
		</dl>

<p class="note">注記：
これらの名前には、
一貫性に欠くものがある
— `-unreachable^l, `-contexts^l 接尾辞など。
これらの名前は、
後方-互換性の理由から保たれる。
◎
Note: There are some inconsistencies across these names, such as the "-unreachable" and the "-contexts" suffixes. These names are kept for backward compatibility reasons.
</p>
	</li>
	<li>
`entryType$m 属性の取得子は、
`longtask^l を返す。
◎
The entryType attribute’s getter will return "longtask".
</li>
	<li>
`startTime$m 属性の取得子は、
当の~taskが開始された時点を表す `DOMHighResTimeStamp$I 値を返す。
◎
The startTime attribute’s getter will return a DOMHighResTimeStamp of when the task started.
</li>
	<li>
`duration$m 属性の取得子は、
当の~taskの開始から終了までに経過した時間を粒度 1ms で表す `DOMHighResTimeStamp$I 値を返す。
◎
The duration attribute’s getter will return a DOMHighResTimeStamp equal to the elapsed time between the start and end of task, with a 1 ms granularity.
</li>
	<li>
`attribution@m
属性の取得子は、
一連の `TaskAttributionTiming$I ~entryからなる凍結d配列を返す。
◎
The attribution attribute’s getter will return a frozen array of TaskAttributionTiming entries.
</li>
</ul>

		</section>
		<section id="sec-TaskAttributionTiming">
<h3 title="TaskAttributionTiming interface">3.2. `TaskAttributionTiming^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `TaskAttributionTiming@I : `PerformanceEntry$I {
    readonly attribute `DOMString$ `containerType$m;
    readonly attribute `DOMString$ `containerSrc$m;
    readonly attribute `DOMString$ `containerId$m;
    readonly attribute `DOMString$ `containerName$m;
    [`Default$] `object$ `toJSON＠dom-taskattributiontiming-tojson@m();
};
</pre>

<p>
`TaskAttributionTiming$I の各種~属性の値は、
`長い~taskを報告する$処理~modelにて設定される。
それらがどう設定されるかについて，参考な要約を以下に供する：
◎
The values of the attributes of a TaskAttributionTiming are set in the processing model in § 5.1 Report long tasks. The following provides an informative summary of how they will be set.
</p>

<ul>
	<li>
`name$m 属性の取得子は、
常に `unknown^l を返す。
◎
The name attribute’s getter will always return "unknown".
</li>
	<li>
`entryType$m 属性の取得子は、
常に `taskattribution^l を返す。
◎
The entryType attribute’s getter will always return "taskattribution".
</li>
	<li>
`startTime$m 属性の取得子は、
常に 0 を返す。
◎
The startTime attribute’s getter will always return 0.
</li>
	<li>
`duration$m 属性の取得子は、
常に 0 を返す。
◎
The duration attribute’s getter will always return 0.
</li>
	<li>
`containerType@m
属性の取得子は、
`元凶~閲覧~文脈~容器$の型を返す
— `iframe^l, `embed^l, `object^l など。
`元凶~閲覧~文脈~容器$は一つも見出されない場合、
`window^l を返すことになる。
◎
The containerType attribute’s getter will return the type of the culprit browsing context container, such as "iframe", "embed", or "object". If no single culprit browsing context container is found, it will return "window".
</li>
	<li>
`containerName@m
属性の取得子は、
`元凶~閲覧~文脈~容器$の `name^a 内容~属性の値を返す。
`元凶~閲覧~文脈~容器$は一つも見出されない場合、
空~文字列を返すことになる。
◎
The containerName attribute’s getter will return the value of the container’s name content attribute. If no single culprit browsing context container is found, it will return the empty string.
</li>
	<li>
`containerId@m
属性の取得子は、
`元凶~閲覧~文脈~容器$の `id^a 内容~属性の値を返す。
`元凶~閲覧~文脈~容器$は一つも見出されない場合、
空~文字列を返すことになる。
◎
The containerId attribute’s getter will return the value of the container’s id content attribute. If no single culprit browsing context container is found, it will return the empty string.
</li>
	<li>
`containerSrc@m
属性の取得子は、
`元凶~閲覧~文脈~容器$の `src^a 内容~属性の値を返す。
`元凶~閲覧~文脈~容器$は一つも見出されない場合、
空~文字列を返すことになる。
◎
The containerSrc attribute’s getter will return the value of the container’s src content attribute. If no single culprit browsing context container is found, it will return the empty string.
</li>
</ul>

		</section>
		<section id="sec-PointingToCulprit">
<h3 title="Pointing to the culprit">3.3. 元凶を指すもの</h3>

◎非規範的

<p>
`長い~task$は、
異なる種別の作業（~script, ~layout, ~style等々など）を孕み得る。
また、
異なる`閲覧~文脈$の中で実行されることもあれば，大域的な資質を備えるものにもなり得る
— ［
`~agent~cluster$ ／ 互いに関係する閲覧~文脈~群【`閲覧~文脈~group$】
］全体にわたる長い~garbage収集など。
◎
A long task can involve different types of work (such as script, layout, style etc), and it could be executed within different browsing contexts, or it could be global in nature such as a long garbage collection that spans the entire agent cluster or unit of related browsing contexts.
</p>

<p>
したがって，`帰属$が指すものには少数の側面fがある：
◎
Thus attribution has a couple of facets:
</p>

<ul>
	<li>
当の長い~taskの生成元や`元凶~閲覧~文脈~容器$の［
全体の中での所在
］
— これは、
`極小な元凶~帰属@
（ `minimal culprit attribution^en ）と称され，
`name$m ~fieldにて捕捉される。
◎
Pointing to the origin of the long task and/or the overall location of the culprit browsing context: this is referred to as minimal culprit attribution and is captured in the name field.
</li>
	<li>
`長い~task$が孕む作業の種別, およびそれに結付けられた`元凶~閲覧~文脈~容器$
— これは、
`PerformanceLongTaskTiming$I の `attribution$m ~field内の各 `TaskAttributionTiming$I ~objにて捕捉される。
◎
Pointing to the type of work involved in the long task, and its associated culprit browsing context container: this is captured in TaskAttributionTiming objects in the attribution field of PerformanceLongTaskTiming.
</li>
</ul>

<p>
したがって， `PerformanceLongTaskTiming$I 上の［
`name$m,
`attribution$m
］~fieldの組は、
長い~taskの~~原因がどこにあるか~~実像を~~描く。
この情報を送達するときには、
~Webの同一-生成元~施策を固守するモノトスル。
◎
Therefore, name and attribution fields on PerformanceLongTaskTiming together paint the picture for where the blame rests for a long task. When delivering this information the Web’s same-origin policy must be adhered to.
</p>

<p>
これらの~fieldは~~相関する
— どう関係するかの概観を次に与える：
◎
These fields are not independent. The following gives an overview of how they are related:
</p>

<div>

<table><thead>
<tr><th>`name$m
<th>`attribution$m
（`帰属$）に~~関与している`元凶~閲覧~文脈~容器$
<tbody>

<tr><td>`self$l
<td>空

<tr><td>`same-origin-ancestor$l
<td>元凶は同一-生成元に属する

<tr><td>`same-origin-descendant$l
<td>元凶は同一-生成元に属する

<tr><td>`same-origin$l
<td>元凶は同一-生成元に属する

<tr><td>`cross-origin-ancestor$l
<td>空

<tr><td>`cross-origin-descendant$l
<td>空

<tr><td>`cross-origin-unreachable$l
<td>空

<tr><td>`multiple-contexts$l
<td>空

<tr><td>`unknown$l
<td>空
</table>

◎
name 	Culprit browsing context container implicated by attribution
"self" 	empty
"same-origin-ancestor" 	same-origin culprit
"same-origin-descendant" 	same-origin culprit
"same-origin" 	same-origin culprit
"cross-origin-ancestor" 	empty
"cross-origin-descendant" 	empty
"cross-origin-unreachable" 	empty
"multiple-contexts" 	empty
"unknown" 	empty
</div>

		</section>
	</section>
	<section id="sec-loaf-timing">
<h2 title="Long Animation Frame Timing">4. 長い~animation~frameの計時</h2>

<p>
長い~animation~frameの計時は、
この節に与える新たな~interfaceを孕む。
◎
Long Animation Frame timing involves the following new interfaces:
</p>

		<section id="sec-PerformanceLongAnimationFrameTiming">
<h3 title="PerformanceLongAnimationFrameTiming interface">4.1. `PerformanceLongAnimationFrameTiming^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `PerformanceLongAnimationFrameTiming@I : `PerformanceEntry$I {
    readonly attribute `DOMHighResTimeStamp$I `renderStart$m;
    readonly attribute `DOMHighResTimeStamp$I `styleAndLayoutStart$m;
    readonly attribute `DOMHighResTimeStamp$I `blockingDuration$m;

    [`Default$] `object$ `toJSON＠#dom-performancelonganimationframetiming-tojson@m();
};
</pre>

<p>
各 `PerformanceLongAnimationFrameTiming$I ~objは、
`計時~報@
を有する
— それは、
`~frame計時~報$である。
◎
A PerformanceLongAnimationFrameTiming has a frame timing info timing info.
</p>

<p class="trans-note">【
以下で利用される`相対的な高分解能~時刻$が返す`所要時間$には，特定の単位は含意されないが、
この仕様においては，常に `DOMHighResTimeStamp$I と同じ ms 単位であると見做される。
】</p>

<div class="algo">
`entryType$m 取得子~手続きは
⇒
~RET `long-animation-frame^l
◎
The entryType attribute’s getter step is to return "long-animation-frame".
</div>

<div class="algo">
`name$m 取得子~手続きは
⇒
~RET `long-animation-frame^l
◎
The name attribute’s getter step is to return "long-animation-frame".
</div>

<div class="algo">
`startTime$m 取得子~手続きは
⇒
~RET `相対的な高分解能~時刻$( コレの`計時~報$の`開始~時刻$ftI, コレに`関連な大域~obj$ )
◎
The startTime attribute’s getter step is to return the relative high resolution time given this's timing info's start time and this's relevant global object.
</div>

<div class="algo">
`duration$m 取得子~手続きは
⇒
~RET `所要時間を得る$( ↓ )
⇒＃
コレの `startTime$m が返す値,
`相対的な高分解能~時刻$( コレの`計時~報$の`終了~時刻$ftI, コレに`関連な大域~obj$ )
◎
The duration attribute’s getter step is to return the duration between this's startTime and the relative high resolution time given this's timing info's end time and this's relevant global object.
</div>

<div class="algo">
`renderStart@m
取得子~手続きは
⇒
~RET `相対的な高分解能~時刻$( コレの`計時~報$の`描画~更新の開始~時刻$ftI, コレに`関連な大域~obj$ )
◎
The renderStart attribute’s getter step is to return the relative high resolution time given this's timing info's update the rendering start time and this's relevant global object.
</div>

<div class="algo">
`styleAndLayoutStart@m
取得子~手続きは
⇒
~RET `相対的な高分解能~時刻$( コレの`計時~報$の`~styleと~layoutの開始~時刻$ftI, コレに`関連な大域~obj$ )
◎
The styleAndLayoutStart attribute’s getter step is to return the relative high resolution time given this's timing info's style and layout start time and this's relevant global object.
</div>

<div class="algo">
<p>
`blockingDuration@m
取得子~手続きは：
◎
The blockingDuration attribute’s getter steps are:
</p>
<ol>
	<li>
%作業~所要時間 ~LET コレの`計時~報$の`最も長い~task所要時間$ftI
◎
Let workDuration be this's timing info's longest task duration.
</li>
	<li>
%描画-所要時間 ~LET 0
◎
Let renderDuration be the 0.
</li>
	<li>
~IF［
コレの`計時~報$の`描画~更新の開始~時刻$ftI ~NEQ 0
］
⇒
%描画-所要時間 ~SET `所要時間を得る$( ↓ )
⇒＃
コレの `renderStart$m が返す値,
`相対的な高分解能~時刻$( コレの`計時~報$の`終了~時刻$ftI )
◎
If this's timing info's update the rendering start time is not zero, then:
• Set renderDuration to the duration between this's renderStart and the relative high resolution time given this's timing info's end time.
</li>
	<li>
~IF［
%作業~所要時間 ~PLUS %描画-所要時間 ~GT 50
］
⇒
~RET %作業~所要時間 ~PLUS %描画-所要時間 ~MINUS 50ms
◎
If workDuration + renderDuration is greater than 50, then return workDuration + renderDuration - 50 milliseconds.
</li>
	<li>
~RET 0
◎
Return 0.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="sec-processing-model">
<h2 title="Processing model">5. 処理~model</h2>

<p class="note">注記：
［
長い~task／
長い~animation~frame
］用の~APIを実装している~UAは、
その~supportを検出することを開発者に許容するよう，
`~window$が`~supportする~entry型~群$【！`supportedEntryTypes$m】に［
`longtask^l ／
`long-animation-frame^l
］を含める必要がある。
◎
Note: A user agent implementing the Long Tasks or Long Animation Frame API would need to include "longtask" or "long-animation-frame" in supportedEntryTypes for Window contexts, respectively.
◎
This allows developers to detect support for long tasks.
</p>

		<section id="report-long-tasks">
<h3 title="Report long tasks">5.1. 長い~taskを報告する</h3>

<div class="algo">
<p>
所与の
( %開始~時刻, %終了~時刻, %~top-level閲覧~文脈~群, %~task )
に対し，次の~algoを遂行する：
◎
Given start time, end time, top-level browsing contexts, and task, perform the following algorithm:
</p>
<ol>
	<li>
~IF［
%終了~時刻 ~MINUS %開始~時刻 ~LT 50ms（長い~taskの閾値）
］
⇒
~RET
◎
If end time minus start time is less than the long tasks threshold of 50 ms, abort these steps.
</li>
	<li>
%行先~realm群 ~LET 空~集合
◎
Let destinationRealms be an empty set.
</li>
	<li>
<p>
（この段は、
報告の送達-先になる`~realm$の集合を決定する。）
</p>

<p>
%~top-level閲覧~文脈~群 を成す
~EACH( `~top-level閲覧~文脈$ %T )
に対し：
</p>
		<ol>
			<li>
%~top-level文書 ~LET %T にて`作動中な文書$nav
</li>
			<li>
%文書~群 ~LET %~top-level文書 のみからなる集合
</li>
			<li>
%~top-level文書 の`子孫~閲覧~文脈~list$を成す
~EACH( %子孫 )
に対し
⇒
%文書~群 に %子孫 にて`作動中な文書$navを追加する
</li>
			<li>
%文書~群 を成す
~EACH( %文書 )
に対し
⇒
%行先~realm群 に次の~tupleを追加する
⇒
( %文書 に`関連な~realm$, %文書 に`関連な設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV )
</li>
		</ol>
◎
Determine the set of JavaScript Realms to which reports will be delivered:
◎
For each top-level browsing context topmostBC in top-level browsing contexts:
• Add topmostBC’s active document's relevant Realm to destinationRealms.
• Let descendantBCs be topmostBC’s active document's list of the descendant browsing contexts.
• Let document be descendantBC’s active document.（この段は次の段の一部）
• For each descendantBC in descendantBCs, add (document’s relevant Realm, document’s relevant settings object's cross-origin isolated capability) to destinationRealms.
</li>
	<li>
<p>
~UAは、
%行先~realm群 から一部の`~realm$を除去してもヨイ
◎
A user agent may remove some JavaScript Realms from destinationRealms.
</p>

<p class="note">注記：
この除去は、［
~UAが別々な~processで取扱っている長い~task
］を`~realm$用に報告するのを避けるために利用できる。
しかしながら、
この概念は精確には指定されていない。
◎
Note: this removal could be used to avoid reporting long tasks for JavaScript Realms that the user agent handles in a separate process. However, this concept is not specified precisely.
</p>

<p class="issue">
［
どの`文書$から，どの長い~taskが可視になるか
］の視野に関して進行中な論点がある。
なので、
この~logicは，将来に変更され得る。
[`課題 #75＠https://github.com/w3c/longtasks/issues/75$]
◎
there is some ongoing discussion regarding the scope of which Documents gain visibility over which long tasks, so this logic could change in the future. [Issue #75]
</p>
	</li>
	<li>
<p>
%行先~realm群 を成す
~EACH( ( %行先~realm, %非同一-生成元~能力は隔離されるか ) )
に対し【順序は言及されていない】：
◎
For each (destinationRealm, crossOriginIsolatedCapability) in destinationRealms:
</p>
		<ol>
			<li>
%名前 ~LET 空~文字列
（これは、
以下で`極小な元凶~帰属$を報告するために利用されることになる）
◎
Let name be the empty string. This will be used to report minimal culprit attribution, below.
</li>
			<li>
%元凶~設定群 ~LET ~NULL
◎
Let culpritSettings be null.
</li>
			<li>
%設定群たち ~LET %~task の`~script評価 環境~設定群~obj集合$
◎
↓</li>
			<li>
<p>
この段は、
%設定群たち を処理して，［
%名前, %元凶~設定群
］を決定する：
◎
Process task’s script evaluation environment settings object set to determine name and culpritSettings as follows:
</p>
				<ol>
					<li>
~IF［
%設定群たち は空である
］
⇒
%名前 ~SET `unknown$l
◎
If task’s script evaluation environment settings object set is empty: set name to "unknown" and culpritSettings to null.
</li>
					<li>
~ELIF［
%設定群たち の長さ ~GT 1
］
⇒
%名前 ~SET `multiple-contexts$l
◎
Otherwise, if task’s script evaluation environment settings object set's length is greater than one: set name to "multiple-contexts" and culpritSettings to null.
</li>
					<li>
<p>
~ELSE（ %設定群たち の長さ ~EQ 1 ）：
◎
Otherwise, i.e. if task’s script evaluation environment settings object set's length is one:
</p>
						<ol>
							<li>
%元凶~設定群 ~SET %設定群たち を成す単独の~item
◎
Set culpritSettings to the single item in task’s script evaluation environment settings object set.
</li>
							<li>
%行先~設定群 ~LET %行先~realm に`関連な設定群~obj$
◎
Let destinationSettings be destinationRealm’s relevant settings object.
◎
↓Let destinationOrigin be destinationSettings’s origin.
</li>
							<li>
%行先~閲覧~文脈 ~LET %行先~設定群 の`大域~obj$enVに`対応する閲覧~文脈$
◎
Let destinationBC be destinationSettings’s global object's browsing context.
</li>
							<li>
%元凶~閲覧~文脈 ~LET %元凶~設定群 の`大域~obj$enVに`対応する閲覧~文脈$
◎
Let culpritBC be culpritSettings’s global object's browsing context.
</li>
							<li>
~Assert：
%元凶~閲覧~文脈 ~NEQ ~NULL
◎
Assert: culpritBC is not null.
</li>
							<li>
~IF［
%元凶~設定群 ~EQ %行先~設定群
］
⇒
%名前 ~SET `self$l
◎
If culpritSettings is the same as destinationSettings, set name to "self".
</li>
							<li>
<p>
~ELIF［
( %元凶~設定群 の`生成元$enV, %行先~設定群 の`生成元$enV )
は`同一-生成元$である
］：
◎
Otherwise, if culpritSettings’s origin and destinationOrigin are same origin:
</p>
								<ol>
									<li>
~IF［
%行先~閲覧~文脈 ~EQ ~NULL
］
⇒
%名前 ~SET `same-origin$l
◎
If destinationBC is null, set name to "same-origin".
</li>
									<li>
~ELIF［
%元凶~閲覧~文脈 は %行先~閲覧~文脈 の`先祖~閲覧~文脈$である
］
⇒
%名前 ~SET `same-origin-ancestor$l
◎
Otherwise, if culpritBC is an ancestor of destinationBC, set name to "same-origin-ancestor".
</li>
									<li>
~ELIF［
%行先~閲覧~文脈 は %元凶~閲覧~文脈 の`先祖~閲覧~文脈$である
］
⇒
%名前 ~SET `same-origin-descendant$l
◎
Otherwise, if destinationBC is an ancestor of culpritBC, set name to "same-origin-descendant".
</li>
									<li>
~ELSE
⇒
%名前 ~SET `same-origin$l
◎
Otherwise, set name to "same-origin".
</li>
								</ol>
							</li>
							<li>
<p>
~ELSE：
◎
Otherwise:
</p>
								<ol>
									<li>
~IF［
%行先~閲覧~文脈 ~EQ ~NULL
］
⇒
%名前 ~SET `cross-origin-unreachable$l
◎
If destinationBC is null, set name to "cross-origin-unreachable".
</li>
									<li>
<p>
~IF［
%元凶~閲覧~文脈 は %行先~閲覧~文脈 の`先祖~閲覧~文脈$である
］
⇒＃
%名前 ~SET `cross-origin-ancestor$l；
%元凶~設定群 ~SET ~NULL
◎
Otherwise, if culpritBC is an ancestor of destinationBC, set name to "cross-origin-ancestor" and set culpritSettings to null.
</p>

<p class="note">注記：
~securityのため、
これは報告されない。
開発者は、
自身でこれを~~調べるべきである。
◎
NOTE: this is not reported because of security. Developers should look this up themselves.
</p>
									</li>
									<li>
~ELIF［
%行先~閲覧~文脈 は %元凶~閲覧~文脈 の`先祖~閲覧~文脈$である
］
⇒
%名前 ~SET `cross-origin-descendant$l
◎
Otherwise, if destinationBC is an ancestor of culpritBC, set name to "cross-origin-descendant".
</li>
									<li>
~ELSE
⇒
%名前 ~SET `cross-origin-unreachable$l
◎
Otherwise, set name to "cross-origin-unreachable".
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%帰属 ~LET %行先~realm 内の新たな `TaskAttributionTiming$I ~obj
◎
Let attribution be a new TaskAttributionTiming object with destinationRealm＼
</li>
			<li>
<p>
%帰属 の
⇒＃
`name$m 属性 ~SET `unknown^l【！`unknown$l】,
`entryType$m 属性 ~SET `taskattribution^l,
`startTime$m 属性 ~SET 0,
`duration$m 属性 ~SET 0,
`containerType$m 属性 ~SET `window^l,
`containerName$m 属性 ~SET 空~文字列,
`containerSrc$m 属性 ~SET 空~文字列,
【`containerId$m 属性 ~SET 空~文字列？】
</p>

<p class="note">注記：
この~APIの将来~版では， `name$m 属性~用に他の値も追加することになるが、
今の所は一種類の値しかとり得ない。
</p>

◎
and set its attributes as follows:
• Set attribution’s name attribute to "unknown".
• NOTE: future iterations of this API will add more values to the name attribute of a TaskAttributionTiming object, but for now it can only be a single value.
• Set attribution’s entryType attribute to "taskattribution".
• Set attribution’s startTime and duration to 0.
• Set attribution’s containerType attribute to "window".
• Set attribution’s containerName and containerSrc attributes to the empty string.
</li>
			<li>
<p>
~IF［
%元凶~設定群 ~NEQ ~NULL
］：
◎
If culpritSettings is not null:
</p>
				<ol>
					<li>
%元凶~閲覧~文脈 ~LET %元凶~設定群 の`大域~obj$enVに`対応する閲覧~文脈$ 
◎
Let culpritBC be culpritSettings’s global object's browsing context.
</li>
					<li>
~Assert：
%元凶~閲覧~文脈 ~NEQ ~NULL
◎
Assert: culpritBC is not null.
</li>
					<li>
%容器 ~LET %元凶~閲覧~文脈 の`容器$bc
◎
Let container be culpritBC’s browsing context container.
</li>
					<li>
~Assert：
%容器 ~NEQ ~NULL
◎
Assert: container is not null.
</li>
					<li>
%帰属 の `containerId$m 属性 ~SET ［
%容器 の`~ID$ ~NEQ ε ならば それ ／
~ELSE_ 空~文字列
］
◎
Set attribution’s containerId attribute to the value of container’s ID, or the empty string if the ID is unset.
</li>
					<li>
<p>
この段の目的においては、
所与の名前 %foo に対する
“%foo 内容~属性~値”
という表記は，次の略記である
⇒＃
%容器 は %foo 内容~属性を有するならば その値 ／
~ELSE_ 空~文字列
◎
↓</p>

<p>
%容器 に応じて：
◎
↓</p>
						<dl class="switch">
							<dt>
`iframe$e 要素
◎
If container is an iframe element:
</dt>
							<dd>
%帰属 の
⇒＃
`containerType$m 属性 ~SET `iframe^l,
`containerName$m 属性 ~SET `name$a 内容~属性~値,
`containerSrc$m 属性 ~SET `src$a 内容~属性~値
◎
• Set attribution’s containerType attribute to "iframe".
• Set attribution’s containerName attribute to the value of container’s name content attribute, or the empty string if the attribute is absent.
• Set attribution’s containerSrc attribute to the value of container’s src content attribute, or the empty string if the attribute is absent.
</dd>
							<dd class="note">注記：
ここで~frameの現在の~URLではなく，
`src$a 属性を記録するのは、
意図的である
— これは，首に~frameを識別し易くすることが意味されていることに加え、
非同一-生成元~iframeの現在の~URLの発見を許容することは，~security問題になるので。
◎
NOTE: it is intentional that we record the frame’s src attribute here, and not its current URL, as this is meant primarily to help identify frames, and allowing discovery of the current URL of a cross-origin iframe is a security problem.
</dd>

							<dt>
`frame$e 要素
◎
If container is a frame element:
</dt>
							<dd>
%帰属 の
⇒＃
`containerType$m 属性 ~SET `frame^l,
`containerName$m 属性 ~SET `name^a 内容~属性~値,
`containerSrc$m 属性 ~SET `src^a 内容~属性~値
◎
• Set attribution’s containerType attribute to "frame".
• Set attribution’s containerName attribute to the value of container’s name content attribute, or the empty string if the attribute is absent.
• Set attribution’s containerSrc attribute to the value of container’s src content attribute, or the empty string if the attribute is absent.
</dd>

							<dt>
`object$e 要素
◎
If container is an object element:
</dt>
							<dd>
%帰属 の
⇒＃
`containerType$m 属性 ~SET `object^l,
`containerName$m 属性 ~SET `~nameO$a 内容~属性~値,
`containerSrc$m 属性 ~SET `data$a 内容~属性~値,
◎
• Set attribution’s containerType attribute to "object".
• Set attribution’s containerName attribute to the value of container’s name content attribute, or the empty string if the attribute is absent.
• Set attribution’s containerSrc attribute to the value of container’s data content attribute, or the empty string if the attribute is absent.
</dd>

							<dt>
`embed$e 要素
◎
If container is an embed element:
</dt>
							<dd>
%帰属 の
⇒＃
`containerType$m 属性 ~SET `embed^l,
`containerName$m 属性 ~SET 空~文字列,
`containerSrc$m 属性 ~SET `~srcE$a 内容~属性~値
◎
• Set attribution’s containerType attribute to "embed".
• Set attribution’s containerName attribute to the empty string.
• Set attribution’s containerSrc attribute to the value of container’s src content attribute, or the empty string if the attribute is absent.
</dd>

						</dl>
					</li>
				</ol>
			</li>
			<li>
%開始 ~SET `時刻を粗化する$( %開始~時刻, %非同一-生成元~能力は隔離されるか )
◎
↓</li>
			<li>
%終了 ~SET `時刻を粗化する$( %終了~時刻, %非同一-生成元~能力は隔離されるか )
◎
↓</li>
			<li>
%新たな~entry ~LET
%行先~realm 内の新たな `PerformanceLongTaskTiming$I ~obj
◎
Create a new PerformanceLongTaskTiming object newEntry with destinationRealm＼
</li>
			<li>
<p>
%新たな~entry の
⇒＃
`name$m 属性 ~SET %名前,
`entryType$m 属性 ~SET `longtask^l,
`startTime$m 属性 ~SET %開始,
`duration$m 属性 ~SET ［ %終了 ~MINUS %開始 ］の整数~部,
`attribution$m 属性 ~SET `凍結d配列を作成する$( « %帰属 » )【！不要：If attribution is not null,】
◎
and set its attributes as follows:
• Set newEntry’s name attribute to name.
• Set newEntry’s entryType attribute to "longtask".
• Set newEntry’s startTime attribute to the result of coarsening start time given crossOriginIsolatedCapability.
• Let dur be the result of coarsening end time given crossOriginIsolatedCapability, minus newEntry’s startTime.
• Set newEntry’s duration attribute to the integer part of dur.
• If attribution is not null, set newEntry’s attribution attribute to a new frozen array containing the single value attribution.
</p>

<p class="note">注記：
この~APIの将来~版では， `attribution$m 属性に他の値も追加することになるが、
今の所は 1 個の値しか包含しない。
◎
NOTE: future iterations of this API will add more values to the attribution attribute, but for now it only contains a single value.
</p>
			</li>
			<li>
`処理能~entryを~queueする$( %新たな~entry )
◎
Queue the PerformanceEntry newEntry.
</li>
		</ol>
	</li>
</ol>

</div>

		</section>
		<section id="sec-frame-timing-info">
<h3 title="Frame Timing Info">5.2. ~frame計時~報</h3>

<p>
`~frame計時~報@
は、
次に挙げる`~item$sctを有する`構造体$であり，
長い~animation~frame用の~algoにおいて内部状態管理に利用される：
◎
frame timing info is a struct used as a bookkeeping detail by the long animation frame algorithms. It has the following items:
</p>
<dl>
	<dt>
`開始~時刻@ftI
◎
start time
</dt>
	<dt>
`現在の~taskの開始~時刻@ftI
◎
current task start time
</dt>
	<dt>
`描画~更新の開始~時刻@ftI
◎
update the rendering start time
</dt>
	<dt>
`~styleと~layoutの開始~時刻@ftI
◎
style and layout start time
</dt>
	<dt>
`終了~時刻@ftI
◎
end time
</dt>
	<dd>
いずれも，ある `DOMHighResTimeStamp$I
— 初期~時は 0 とする。
◎
A DOMHighResTimeStamp, initially 0.＼
</dd>
	<dd class="note">
注記：
いずれも，`安全でない~moment$【！[=monotonic~clock/unsafe current time=|unsafe=]】なので、
~APIを介して公開する際には，`時刻を粗化する$ベキである。
◎
Note: all the above are [=monotonic clock/unsafe current time=|unsafe=], and should be coarsened when exposed via an API.
</dd>

	<dt>
`最も長い~task所要時間@ftI
◎
longest task duration
</dt>
	<dd>
`DOMHighResTimeStamp$I
— 初期~時は 0 とする。
◎
A DOMHighResTimeStamp, initially 0.
</dd>
</dl>

<p>
各`文書$は
`現在の~frame計時~報@doc
を有する
— それは、［
~NULL／`~frame計時~報$
］であり，
初期~時は~NULLとする。
◎
A Document has a null or frame timing info current frame timing info, initially null.
</p>

		</section>
		<section id="loaf-processing-model">
<h3 title="Report Long Animation Frames">5.3. 長い~animation~frameを報告する</h3>

<div class="algo">
<p>
所与の
( `文書$ %文書 )
と
`同一-生成元に属する最も近い根@
は：
◎
To get the nearest same-origin root for a Document document:
</p>
<ol>
	<li>
%先祖~群 ~LET %文書 の`先祖~navigable群$
◎
Let ancestors be the ancestor navigables of document.
</li>
	<li>
%先祖~群 を成す
~EACH( %先祖~navigable )
に対し
⇒
~IF［
( %先祖~navigable にて`作動中な文書$navの`生成元$doc, %文書 の`生成元$doc )
は`同一-生成元$である
］~AND［
%先祖~navigable にて`作動中な文書$navに`関連な~agent$ ~EQ %文書 に`関連な~agent$
］
⇒
~RET %先祖~navigable にて`作動中な文書$nav
◎
For each ancestorNavigable in ancestors: If ancestorNavigable’s active document's origin is same origin with document’s origin, and ancestorNavigable’s active document's relevant agent is document’s relevant agent, then return ancestorNavigable’s active document.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の
( `文書$ %文書 )
に
`関連な~frame計時~報@
は
⇒
~RET %文書 と`同一-生成元に属する最も近い根$の`現在の~frame計時~報$doc
◎
The relevant frame timing info for a Document document is its nearest same-origin root's current frame timing info.
</p>
</div>

<div class="algo">
<p>
`~task開始~時刻を報告する@
ときは、
所与の
( `DOMHighResTimeStamp$I %安全でない~task開始~時刻, `文書$ %文書 )
に対し：
◎
To report task start time given a DOMHighResTimeStamp unsafeTaskStartTime, and a Document document:
</p>
<ol>
	<li>
%根 ~LET %文書 と`同一-生成元に属する最も近い根$
◎
Let root be document’s nearest same-origin root.
</li>
	<li>
~IF［
%根 の`現在の~frame計時~報$doc ~EQ ~NULL
］
⇒
%根 の`現在の~frame計時~報$doc ~SET 新たな`~frame計時~報$
— その
⇒＃
`開始~時刻$ftI ~SET %安全でない~task開始~時刻
◎
If root’s current frame timing info is null, then set root’s current frame timing info to a new frame timing info whose start time is unsafeTaskStartTime.
</li>
	<li>
%計時~報 ~LET %根 の`現在の~frame計時~報$doc
◎
↓</li>
	<li>
%計時~報 の`現在の~taskの開始~時刻$ftI ~SET %安全でない~task開始~時刻
◎
Set root’s current frame timing info's current task start time to unsafeTaskStartTime.
</li>
	<li>
~IF［
%計時~報 の`開始~時刻$ftI ~EQ 0
］
⇒
%計時~報 の`開始~時刻$ftI ~SET %安全でない~task開始~時刻
◎
If root’s current frame timing info's 's start time is 0, then set root’s current frame timing info's start time to unsafeTaskStartTime.
</li>
</ol>
</div>

<div class="algo">
<p>
`~task終了~時刻を報告する@
ときは、
所与の
( `DOMHighResTimeStamp$I %安全でない~task終了~時刻, `文書$ %文書 )
に対し：
◎
To report task end time given an DOMHighResTimeStamp unsafeTaskEndTime, and a Document document:
</p>
<ol>
	<li>
%計時~報 ~LET %文書 に`関連な~frame計時~報$
◎
Let timingInfo be document’s relevant frame timing info.
</li>
	<li>
<p>
~IF［
%計時~報 ~EQ ~NULL
］
⇒
~RET
◎
If timingInfo is null, then return.
</p>

<p class="note">注記：
これは、
~browserが `the sequence^en の間に可視でなくなる場合に生じ得る。
◎
Note: This can occur if the browser becomes hidden during the sequence.
</p>
	</li>
	<li>
%安全な~task終了~時刻 ~LET `相対的な高分解能~時刻$( %安全でない~task終了~時刻, %文書 に`関連な大域~obj$ )
◎
Let safeTaskEndTime be the relative high resolution time given unsafeTaskEndTime and document’s relevant global object.
</li>
	<li>
%安全な~task開始~時刻 ~LET `相対的な高分解能~時刻$( %計時~報 の`現在の~taskの開始~時刻$ftI, %文書 に`関連な大域~obj$ )
◎
Let safeTaskStartTime be the relative high resolution time given timingInfo’s current task start time and document’s relevant global object.
</li>
	<li>
%現在の~task所要時間 ~LET `所要時間を得る$( ↓ )
⇒＃
%安全な~task開始~時刻,
%安全な~task終了~時刻
◎
Let currentTaskDuration be the duration between safeTaskStartTime and safeTaskEndTime.
</li>
	<li>
~IF［
%現在の~task所要時間 ~GT %計時~報 の`最も長い~task所要時間$ftI
］
⇒
%計時~報 の`最も長い~task所要時間$ftI ~SET %現在の~task所要時間
◎
If currentTaskDuration is greater than timingInfo’s longest task duration, then set timingInfo’s longest task duration to currentTaskDuration.
</li>
	<li>
<p>
~IF［
~UAは、
%文書 の`~node~navigable$の描画を更新しても，可視な効果は無いものと予見する
］
⇒
`~frame計時を書出す$( %文書 )【！~RET】
◎
If the user agent believes that updating the rendering of document’s node navigable would have no visible effect, then flush frame timing given document and return.
</p>

<p class="note">注記：
ここでは、
実際には視覚的な更新が不要であったとしても，`長い~animation~frame$を~markする
— `because it would be blocking^en in ある局面 `where it coincided with^en ある無関係な視覚的~更新【？】。
◎
Note: even though there was no actual visual update, we mark a long animation frame here because it would be blocking in a scenario where it coincided with an unrelated visual update.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`描画~時刻を報告する@
ときは、
所与の
( `文書$ %文書, `DOMHighResTimeStamp$I %安全でない~styleと~layoutの開始~時刻 )
に対し：
◎
To report rendering time given a Document document, and a DOMHighResTimeStamp unsafeStyleAndLayoutStart:
</p>
<ol>
	<li>
%計時~報 ~LET %文書 に`関連な~frame計時~報$
◎
Let timingInfo be document’s relevant frame timing info.
</li>
	<li>
<p>
~IF［
%計時~報 ~EQ ~NULL
］
⇒
~RET
◎
If timingInfo is null, then return.
</p>

<p class="note">注記：
これは、
~browserが `the sequence^en の間に可視でなくなる場合に生じ得る。
◎
Note: This can occur if the browser becomes hidden during the sequence.
</p>
	</li>
	<li>
%計時~報 の`描画~更新の開始~時刻$ftI ~SET %計時~報 の`現在の~taskの開始~時刻$ftI
◎
Set timingInfo’s update the rendering start time to timingInfo’s current task start time.
</li>
	<li>
%計時~報 の`~styleと~layoutの開始~時刻$ftI ~SET %安全でない~styleと~layoutの開始~時刻
◎
Set timingInfo’s style and layout start time to unsafeStyleAndLayoutStart.
</li>
	<li>
`~frame計時を書出す$( %文書, `安全でない共有される現在の時刻$ )
◎
Flush frame timing given document and the unsafe shared current time.
</li>
</ol>
</div>

<div class="algo">
<p>
`~frame計時を書出す@
ときは、
所与の
( `文書$ %文書, `DOMHighResTimeStamp$I %安全でない終了~時刻 )
に対し：
◎
To flush frame timing given a Document document and a DOMHighResTimeStamp unsafeEndTime:
</p>
<ol>
	<li>
%計時~報 ~LET %文書 に`関連な~frame計時~報$
◎
Let timingInfo be document’s relevant frame timing info.
</li>
	<li>
~Assert：
%計時~報 ~NEQ ~NULL
◎
Assert: timingInfo is not null.
</li>
	<li>
%大域~obj ~LET %文書 に`関連な大域~obj$
◎
Let global be document’s relevant global object.
</li>
	<li>
%~frame所要時間 ~LET `所要時間を得る$( ↓ )
⇒＃
`相対的な高分解能~時刻$( %計時~報 の`開始~時刻$ftI, %大域~obj ),
`相対的な高分解能~時刻$( %安全でない終了~時刻, %大域~obj )
◎
Let frameDuration be the duration between the relative high resolution time given timingInfo’s start time and global, and the relative high resolution time given unsafeEndTime and global.
</li>
	<li>
<p>
~IF［
%~frame所要時間 ~GT 50ms
］：
</p>
		<ol>
			<li>
%処理能~entry ~LET `新たな~obj$( `PerformanceLongAnimationFrameTiming$I, %文書 に`関連な~realm$ )
</li>
			<li>
%処理能~entry の`計時~報$ ~SET %計時~報
</li>
			<li>
`処理能~entryを~queueする$( %処理能~entry )
</li>
		</ol>
◎
If frameDuration is greater than 50 milliseconds, then Queue a new PerformanceLongAnimationFrameTiming in document’s relevant realm, whose timing info is timingInfo.
</li>
	<li>
%文書 と`同一-生成元に属する最も近い根$の`現在の~frame計時~報$doc ~SET ~NULL
◎
set document’s nearest same-origin root's current frame timing info to null.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="priv-sec">
<h2 title="Security &amp; privacy considerations">6. ~securityと~privacyの考慮点</h2>

<p>
長い~task用の~APIは、［
長い~taskの~sourceについて，生成元~安全な帰属~情報を含める
］ことにより，同一-生成元~施策を固守する。
また、
長い~task用には閾値 50ms がある。
所要時間は 1ms までの粒度で供される。
これらは組みで、
非同一-生成元への漏洩-に抗する必要十分な保護を供する。
【閾値 50ms は、~security用に導入されたものではないが，それでも。】
◎
Long Tasks API adheres to the same-origin policy by including origin-safe attribution information about the source of the long task. There is a 50ms threshold for long tasks. Durations are only provided in 1 ms granularity. Together this provides adequate protection against cross-origin leaks.
</p>

<p>
この~APIは、［
利用者により実行される~taskの所要時間と種別についての計時~情報
］および［
関数~callを生じさせた閲覧~文脈などの`帰属$
］を供する。
これは、
攻撃者が~side-channel計時~攻撃を遂行して，［
利用者の動作を推測する／利用者を識別する
］ことも可能化し得る。
例えば，長い~scriptに後続して長い具現化を併せる~patternで、
利用者による~social~widgetとのヤリトリを推測することもできる。
詳細な［
関数~callの`帰属$
］は、
利用者の動作を決定するために利用されることになろう。
◎
The Long Tasks API provides timing information about the duration and type of tasks executed by the user, as well as attribution such as the browsing context causing the function calls. This could enable an attacker to perform side-channel timing attacks to guess the user’s action, or identify the user. For example, a pattern of long script followed by a long render could be put together to guess user’s interaction with a social widget. Detailed function call attribution would be used to determine the user’s action.
</p>

<p>
この~APIは、
新たな~privacy攻撃は導入しないが，既存の~privacy攻撃を速くすることもできる。
そのための軽減策はアリであり、
必要に応じて実装できる：
◎
While the API doesn’t introduce any new privacy attacks, it could make existing privacy attacks faster. Mitigations for this are possible and can be implemented as needed:
</p>
<ul>
	<li>
~APIが供する長い~taskの所要時間に対し，更に、
それを~~丸めたり~randomな揺らぎを追加して，攻撃から悪用され難くする。
◎
Further clamp or add random jitter to the long task duration provided by the API to make attacks harder to exploit.
</li>
	<li>
長い~taskを~APIに公開する生成元の個数を制限して、
それを超える~taskの帰属をぼやかす。
一例として，~pageに 5 個の~iframeが伴われる場合、
それらの~iframeのうち 3 個からは ~taskの帰属を受信して，他の 2 個からは~taskの帰属を受信しないようにする
（ 【`PerformanceLongTaskTiming$I の】 `name$m を `unknown$l に設定する）
こともできる。
◎
Limit the number of origins for which longtasks are exposed by the API, and obfuscate the attribution of any tasks afterwards. For instance, a page with 5 iframes could receive only attribution for tasks from 3 of those iframes, and would receive no attribution (name set to unknown") for tasks from the other 2.
</li>
	<li>
一定の閾値の後には、［
元凶／帰属
］情報を落とすことも許容する。
一例として，長い~taskが 10 個を超えて以降は、
どの~entryも，帰属を受信することなく それらの `name$m を `unknown$l にする。
◎
Allow dropping the culprit/attribution information after a certain threshold. For instance, after 10 longtasks all entries would receive no attribution and their name would be "unknown".
</li>
	<li>
公開される計時~情報に組込みの遅延を追加して、
長い~taskの分量に依存している攻撃を実行し難くする。
◎
Add a built-in delay to the timing information exposed to make attacks dependent on longtask volume harder to execute.
</li>
</ul>

		<section id="what-is-exposed">
<h3 title="What is Exposed to Observers?">6.1. 何が観測器に公開されるのか？</h3>

<p>
~top-level~pageの中にある すべての観測器
（すなわち，~pageと~main~frame内のすべての~iframe）
は、
長い~taskが在ることについて通知を受信することになる。
それは、
当の~taskの［
開始~時刻, 所要時間, 元凶~frameへの~pointer
］を公開する
（所要時間は粒度 1ms で）。
この情報は、
今日においてすでに，
`setTimeout()^m を利用して より高-分解能に観測できる
【それは、閾値 50ms により制限されない】
。
攻撃者は、［
~page上のすべてを~clearしてから，非同一-生成元に属する脆弱な資源を追加することで、
`setTimeout()^m からの遅延が，その資源により生じることを確保する
］ことにより，これを行える。
【元凶とは】異なる~page（~UItabや~UIwindow）内の観測器は、
~UAの~architectureを問わず，通知【において`帰属$】を受信するベキでない。
◎
All observers within the top level page (i.e. all iframes in the page and the main frame) will receive notifications about presence of long tasks. We expose the start time of the task, its duration (with 1 ms granularity), and a pointer to the culprit frame. This information can already be observed today, and with higher resolution, using setTimeout. An attacker can do this by clearing everything else on the page and adding the vulnerable cross-origin resource to ensure that delays from the setTimeout are caused by that resource. Observers in other different pages (tabs or windows) should not receive notifications, regardless of the architecture of the user agent.
</p>

<p>
非同一-生成元に何が公開されるかに関する規則：
◎
Cross origin rules for what is exposed:
</p>
<ul>
	<li>
非同一-生成元に属する観測器は、
元凶が在る方向を知り得る
— 例：
当の元凶は深く入子にされた~iframeである場合、
それを~hostしている~pageは，自身と元凶の合間にある最初の非同一-生成元を知れる。
◎
Cross-origin observers may see the direction of the culprit e.g if the culprit is a deeply nested iframe, then the host page can see the first cross-origin between itself and the culprit.
</li>
	<li>
逆に，元凶の方が~top-level~pageである場合、
深く埋込まれた~iframeは，［
非同一-生成元に属する先祖~内で，ある長い~taskが生じたこと
］を知れるが，それについての情報は受信しない。
◎
Conversely, if the culprit is the top level page, then a deeply embedded iframe can see that a longtask occurrred in its cross-origin ancestor but does not receive any information about it.
</li>
</ul>

		</section>
		<section id="attack-scenarios">
<h3 title="Attack Scenarios Considered">6.2. 考慮される攻撃~局面</h3>

<p>
考慮される計時~攻撃には次に挙げるものがある：
◎
The following are the timing attacks considered:
</p>
<ul>
	<li>
伝統的な計時~攻撃
⇒
外部~資源の読込nにかかる時間を利用して，私的~dataの~sizeを露呈する。
例として、
ある展示における隠された絵図の個数, ~usernameは妥当かどうか, 等々。
`例＠http://crypto.stanford.edu/%7edabo/papers/webtiming.pdf$
を見よ。
◎
Traditional timing attacks: using external resource load time to reveal the size of private data. For instance the number of hidden pictures in a gallery, whether username is valid, etc. See an example.
</li>
	<li>
~side-channel計時~攻撃
⇒
［
動画~構文解析／
~script構文解析／
~app~cache読取n【この特能は~HTMLから廃された】／
`Cache$I ~API（~sw）
］の利用量に関する時間を利用して、
利用者を一意に識別するか, 利用者の［
年齢, 性別, 所在, 関心事, 等々
］の~profileを作成する。
`一例として＠https://tom.vg/papers/timing-attacks_ccs2015.pdf$，
~social~network内の ある~permalink用の~pageからの状態s更新は、
一定の対象層（例： 20 代の女性）に制限-【するように公開-】され得る。
その~permalink~pageの~file~sizeは、
利用者は当の対象層に属するかどうか決定するために利用され得る。
【対象層に属さないならば、当の~pageを読込まないので，時間がかからない。】
◎
Side-channel timing attacks: using time for video parsing, script parsing, App Cache reads or Cache API (service workers) usage to uniquely identify a user, or to create a profile of the user’s age, gender, location, and interests etc. For instance, status updates from a social network can be limited to certain demographic (eg. females of age 20-30) the file size of the permalink page can be used to determine whether the user is in the target demographic.
</li>
</ul>

<p>
これらの局面は、［
50ms 閾値, 非同一-生成元に関する境界
］の組みで取組まれる。
すなわち、
信用されない非同一-生成元に属する観測器には，~taskの種別や追加的な帰属は示されない。
◎
These scenarios are addressed by the 50ms threshold AND respecting cross-origin boundary i.e. not showing task type or additional attribution to untrusted cross origin observers.
</p>
		</section>
		<section id="loaf-sec-priv">
<h3 title="Additional information exposed by the Long Animation Frames API">6.3. 長い~animation~frame~APIにより公開される追加的な情報</h3>

<p>
非同一-生成元に属するいくつかの文書が同じ~event~loopを共有し得るので、
それらも， `the same sequence^en を成す一部として描画され得る
— その結果、
互いの描画~時刻に波及する。
これらの計時は，すでに非同一-生成元からも いくぶん観測-可能であるが
（例：~animation~frameを要請して，遅延されたか否か観測することにより）、
長い~animation~frame~API【！this】は，より高い忠実度でそれらを公開する。
◎
Since several cross-origin documents can share the same event loop, they can also render as part of the same frame sequence and influence each other’s rendering time. This makes it so that these timings are already somewhat observable cross-origin, e.g. by requesting an animation frame and observing if it is delayed, though long animation frames exposes them at a higher fidelity.
</p>

<p>
これを軽減するため、
長い~animation~frameの報告-先は， “関与している局所的な根” に限られる：
◎
To mitigate this, long animation frames are only reported to "participating local roots":＼
</p>
<ul>
	<li>
長い~animation~frameを観測する文書として適格になるものは、［
`the sequence^en に寄与した ある作業~taskに結付けられたもの／
当の~frameを成す一部として描画されたもの
］に限られる。
◎
only documents that are associated with a work task that contributed to the sequence, or that were rendered as part of the frame, are eligible to observe the long animation frame,＼
</li>
	<li>
長い~animation~frameが可用になる文書は、
前項の文書と`同一-生成元に属する最も近い根$に限られる。
【！前項の文書の先祖のうち［その親は［無い／非同一-生成元に属する］もの］のうち文書に最も近いもの】
◎
and that long animation frame would be available only in their nearest ancestor that is either topmost or has a cross-origin parent.
</li>
</ul>

		</section>
	</section>
</main></div>
