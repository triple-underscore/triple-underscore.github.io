<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — The document element, Document metadata（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<style>
@supports (grid-template-columns: subgrid) and (display: contents) {

#table-http-equiv {
	grid-template-columns: 4em 9em 1fr;
	min-width: 28em;
	max-width: 42em;
	tr {
		grid-template-areas:
			"keyword keyword keyword"
			". 適合 状態"
			". 記述 記述"
		;
		> *:nth-child(1) {
			grid-area: keyword;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 適合;
		}
		> *:nth-child(3) {
			grid-area: 状態;
		}
		> *:nth-child(4) {
			grid-area: 記述;
			padding: 0.5em;
		}
	}
}
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'semantics',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/❝.|%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return (
`<span class="code-point">U+00${match[1].charCodeAt(0).toString(16).toUpperCase()}</span> (<span class="char-symbol">${match[1]}</span>)`
		);
	default: //'%'
		return `<var>${match.slice(1)}</var>`
	}
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 't':
	text = `&lt;${text}&gt;`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">作者~向け</a>／<a href="~HTMLAAM#el-${key}">実装者~向け</a>`;
	break;
case 'obsMb':
	text = '廃用にされた~memberもある';
	href= `~HTMLLS/obsolete.html#${key}-partial`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-11-21
trans_update:2025-11-23
source_checked:240712
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/semantics.html
	abbr_url:HEmetadata
nav_prev:HTMLdom
nav_next:HEsections
trans_1st_pub:2016-09-03

●●class_map
e:element
a:attr
aL:attr
et:event-type
P:production
p:property
d:descriptor
dir:directive
t:type
st:attr-state
hst:status
v:value
sl:js-slot
at:css
obsMb:comment

●●tag_map
I:code
m:code
mL:code
c:code
et:code
e:code
a:code
aL:code
P:code
dir:code
st:i
hst:code
p:code
d:code
t:var
v:code
V:var
sl:span
i:i
at:code
cite:cite
obsMb:span
em:em

●●original_id_map
	charset1024:charset512

●●mdn_urls
the-base-element:HTML/Element/base
the-head-element:HTML/Element/head
the-html-element:HTML/Element/html
the-link-element:HTML/Element/link
the-meta-element:HTML/Element/meta
the-style-element:HTML/Element/style
the-title-element:HTML/Element/title

htmlhtmlelement:API/HTMLHtmlElement
htmlheadelement:API/HTMLHeadElement
htmltitleelement:API/HTMLTitleElement
htmlbaseelement:API/HTMLBaseElement
htmllinkelement:API/HTMLLinkElement
htmlmetaelement:API/HTMLMetaElement
htmlstyleelement:API/HTMLStyleElement


●●link_map

CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor
Reflect:~HTMLcdom#xattr-reflect
ReflectSetter:~HTMLcdom#xattr-reflectsetter
ReflectURL:~HTMLcdom#xattr-reflecturl

h.Set-Cookie:~HTTPcookie#sane-set-cookie
h.Link:~HTTPweblink#field.link
h.Content-Language:~HTTPsem#field.content-language
h.Refresh:~HTMLsl#refresh

I.HTMLHtmlElement:#htmlhtmlelement
I.HTMLHeadElement:#htmlheadelement
I.HTMLTitleElement:#htmltitleelement
I.HTMLBaseElement:#htmlbaseelement
I.HTMLLinkElement:#htmllinkelement
I.HTMLMetaElement:#htmlmetaelement
I.HTMLStyleElement:#htmlstyleelement

I.DOMTokenList:~DOM4#interface-domtokenlist
I.Document:~HTMLdom#document
I.HTMLElement:~HTMLdom#htmlelement
I.LinkStyle:~CSSOM1#the-linkstyle-interface

m.content:#dom-meta-content
m.media:#dom-meta-media
m.document.title:~HTMLdom#dom-document-title
m.href:#dom-base-href
m.httpEquiv:#dom-meta-httpequiv
m.~mediaS:#dom-style-media
m.~disabledS:#dom-style-disabled
m.~blockingS:#dom-style-blocking
m.name:#dom-meta-name
m.target:#dom-base-target
m.text:#dom-title-text
m.value:~DOM4#dom-domtokenlist-value
m.supports:~DOM4#dom-domtokenlist-supports

mL.as:#dom-link-as
mL.blocking:#dom-link-blocking
mL.crossOrigin:#dom-link-crossorigin
mL.disabled:#dom-link-disabled
mL.fetchPriority:#dom-link-fetchpriority
mL.href:#dom-link-href
mL.hreflang:#dom-link-hreflang
mL.media:#dom-link-media
mL.integrity:#dom-link-integrity
mL.referrerPolicy:#dom-link-referrerpolicy
mL.rel:#dom-link-rel
mL.relList:#dom-link-rellist
mL.sizes:#dom-link-sizes
mL.imageSrcset:#dom-link-imagesrcset
mL.imageSizes:#dom-link-imagesizes
mL.type:#dom-link-type

e.html:#the-html-element
e.head:#the-head-element
e.title:#the-title-element
e.base:#the-base-element
e.link:#the-link-element
e.meta:#the-meta-element
	e.meta:#meta
e.style:#the-style-element

e.a:~HEtextlevel#the-a-element
e.body:~HEsections#the-body-element
e.img:~HEimages#the-img-element
e.noscript:~HEscripting#the-noscript-element
e.picture:~HEimages#the-picture-element
e.script:~HEscripting#the-script-element
e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.form:~HEforms#the-form-element

a.~blockingS:#attr-style-blocking
a.charset:#attr-meta-charset
a.content:#attr-meta-content
a.media:#attr-meta-media
a.href:#attr-base-href
a.http-equiv:#attr-meta-http-equiv
a.lang:~HTMLdom#attr-lang
a.name:#attr-meta-name
a.nonce:~HTMLurl#attr-nonce
a.rel:~HTMLlinks#attr-hyperlink-rel
a.target:#attr-base-target
a.title:~HTMLdom#attr-title
a.~titleS:#attr-style-title
a.type:~HTMLobs#attr-style-type
a.~mediaS:#attr-style-media
a.hreflang:~HTMLlinks#attr-hyperlink-hreflang
a.srcset:~HEimages#attr-img-srcset
a.sizes:~HEimages#attr-img-sizes

aL.as:#attr-link-as
aL.blocking:#attr-link-blocking
aL.color:#attr-link-color
aL.crossorigin:#attr-link-crossorigin
aL.disabled:#attr-link-disabled
aL.fetchpriority:#attr-link-fetchpriority
aL.href:#attr-link-href
aL.hreflang:#attr-link-hreflang
aL.imagesizes:#attr-link-imagesizes
aL.imagesrcset:#attr-link-imagesrcset
aL.integrity:#attr-link-integrity
aL.media:#attr-link-media
aL.referrerpolicy:#attr-link-referrerpolicy
aL.rel:#attr-link-rel
aL.sizes:#attr-link-sizes
aL.title:#attr-link-title
aL.type:#attr-link-type

a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute

v.application-name:#meta-application-name
v.author:#meta-author
v.description:#meta-description
v.generator:#meta-generator
v.keywords:#meta-keywords
v.referrer:#meta-referrer
v.theme-color:#meta-theme-color
v.color-scheme:#meta-color-scheme

v.content-language:#attr-meta-http-equiv-keyword-content-language
v.content-type:#attr-meta-http-equiv-keyword-content-type
v.default-style:#attr-meta-http-equiv-keyword-default-style
v.refresh:#attr-meta-http-equiv-keyword-refresh
v.set-cookie:#attr-meta-http-equiv-keyword-set-cookie
v.x-ua-compatible:#attr-meta-http-equiv-keyword-x-ua-compatible
v.content-security-policy:#attr-meta-http-equiv-keyword-content-security-policy

v.any:~HTMLlinks#attr-link-sizes-any
v.alternate:~HTMLlinks#rel-alternate
v.canonical:~HTMLlinks#link-type-canonical
v.dns-prefetch:~HTMLlinks#link-type-dns-prefetch
v.expect:~HTMLlinks#link-type-expect
v.icon:~HTMLlinks#rel-icon
v.next:~HTMLlinks#link-type-next
v.pingback:~HTMLlinks#link-type-pingback
v.preconnect:~HTMLlinks#link-type-preconnect
v.prefetch:~HTMLlinks#link-type-prefetch
v.preload:~HTMLlinks#link-type-preload
v.manifest:~HTMLlinks#link-type-manifest
v.modulepreload:~HTMLlinks#link-type-modulepreload
v.search:~HTMLlinks#link-type-search
v.stylesheet:~HTMLlinks#link-type-stylesheet

v.no-referrer:~REFERRER-POLICY#referrer-policy-no-referrer
v.origin-when-cross-origin:~REFERRER-POLICY#referrer-policy-origin-when-cross-origin
v.unsafe-url:~REFERRER-POLICY#referrer-policy-unsafe-url



et.error:~HTMLindex#event-error
et.load:~HTMLindex#event-load

dir.frame-ancestors:~CSP3#frame-ancestors
dir.report-uri:~CSP3#report-uri
dir.sandbox:~CSP3#sandbox
dir.style-src:~CSP3#style-src

c.text/css:~HTMLindex#text/css
c.text/plain:~RFCx/rfc2046#section-4.1.3

p.color-scheme:~CSSCOLORADJUST#propdef-color-scheme
	p.color-scheme:~CSSCOLORADJUST#color-scheme-prop
t.color:~CSSCOLOR#typedef-color
d.prefers-color-scheme:~MQ5#descdef-media-prefers-color-scheme

sl.CryptographicNonce:~HTMLurl#cryptographicnonce

V.meta:#_meta-elem
V.content:#_content-attr-value

hst.103:~HTTPearlyhints#early-hints

	●用語
st.内容~言語:#attr-meta-http-equiv-content-language
st.~CSP:#attr-meta-http-equiv-content-security-policy
st.Set-Cookie:#attr-meta-http-equiv-set-cookie
st.既定の~style:#attr-meta-http-equiv-default-style
st.符号化法~宣言:#attr-meta-http-equiv-content-type
st.~refresh:#attr-meta-http-equiv-refresh
st.~X-UA-Compatible:#attr-meta-http-equiv-x-ua-compatible
st.自動:~HTMLurl#attr-fetchpriority-auto-state
st.~CORSなし:~HTMLurl#attr-crossorigin-none

明示的に可能化されるか:#explicitly-enabled

~scriptを阻んでいる~stylesheet集合:#script-blocking-style-sheet-set
~scriptを阻んでいる~stylesheetを供与して:#contributes-a-script-blocking-style-sheet
~scriptを阻んでいる~stylesheetは在るか？:#has-a-style-sheet-that-is-blocking-scripts
	#has-no-style-sheet-that-is-blocking-scripts → #has-a-style-sheet-that-is-blocking-scripts

~body内に許容され:#allowed-in-the-body
符号化法~宣言:#character-encoding-declaration

凍結d基底~URL:#frozen-base-url
凍結d基底~URLを設定する:#set-the-frozen-base-url
	set:#set-the-frozen-base-url

~link要請を作成する:#create-a-link-request
~link先の資源を~fetchして処理する:#fetch-and-process-the-linked-resource
~link先の資源~fetch用に設定しておく:#linked-resource-fetch-setup-steps
~link先の資源を~fetchして処理する既定の~algo:#default-fetch-and-process-the-linked-resource
~link先の資源を処理する:#process-the-linked-resource
早期~hint:#early-hints-2
早期~hint~header群を処理する:#process-early-hint-headers

~link処理~option群:#link-processing-options
lO.基底~URL:#link-options-base-url
lO.~CORS状態:#link-options-crossorigin
lO.行先:#link-options-destination
lO.文書:#link-options-document
lO.環境:#link-options-environment
lO.href:#link-options-href
lO.起動元:#link-options-initiator
lO.完全性~metadata:#link-options-integrity
lO.文書~準備済み時の手続き:#link-options-on-document-ready
lO.生成元:#link-options-origin
lO.施策~容器:#link-options-policy-container
lO.~source集合:#link-options-source-set
lO.~MIME型:#link-options-type
lO.~referrer施策:#link-options-referrer-policy
lO.暗号用~nonce~metadata:#link-options-nonce
lO.~fetch優先度:#link-options-fetch-priority
~link~header群を処理する:#process-link-headers
~header群から~link群を抽出する:#extract-links-from-headers
~link~headerから構文解析した属性~群を~option群に適用する:#apply-link-options-from-parsed-header-attributes
要素から~link~option群を作成する:#create-link-options-from-element
~link~headerを処理する手続き:#process-a-link-header

~pragma集合の既定の言語:#pragma-set-default-language
~style~blockを更新する:#update-a-style-block
宣言的に~refreshするか:#will-declaratively-refresh
共用~宣言的~refresh手続き:#shared-declarative-refresh-steps
要素の~targetを取得する:#get-an-element's-target

	●HTML
即時:~HTMLINFRA#immediately
接続されたとき:~HTMLINFRA#becomes-connected
切断されたとき:~HTMLINFRA#becomes-disconnected
文書の中へ挿入された:~HTMLINFRA#insert-an-element-into-a-document
文書から除去された:~HTMLINFRA#remove-an-element-from-a-document
必須な下位資源:~HTMLINFRA#critical-subresources

~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2
i.利用者-関与i:~HTMLlinks#following-userinvolvement
~HTML~link型:~HTMLlinks#linkTypes
外部~資源~link:~HTMLlinks#external-resource-link
他種の~link型:~HTMLlinks#other-link-types
~body-ok:~HTMLlinks#body-ok
~hyperlink:~HTMLlinks#hyperlink
~preloadされる資源~群が成す~map:~HTMLlinks#map-of-preloaded-resources
~preloadの行先を翻訳する:~HTMLlinks#translate-a-preload-destination

反映する:~HTMLcdom#reflect
既知な値のみに制限される:~HTMLcdom#limited-to-only-known-values

~referrer施策~属性:~HTMLurl#referrer-policy-attribute
~CORSになり得る要請を作成する:~HTMLurl#create-a-potential-cors-request
~CORS設定群~属性:~HTMLurl#cors-settings-attribute
~Content-Type~metadata:~HTMLurl#content-type
~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
文書~基底~URL:~HTMLurl#document-base-url
~fallback基底~URL:~HTMLurl#fallback-base-url
基底~URLの変化に応答する:~HTMLurl#respond-to-base-url-changes
妥当な~URL（前後~空白~可）:~HTMLurl#valid-url-potentially-surrounded-by-spaces
妥当かつ空でない~URL（前後~空白~可）:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces
具現化を阻む能性:~HTMLurl#potentially-render-blocking
暗黙的に具現化を阻む能性:~HTMLurl#implicitly-potentially-render-blocking
他を阻む属性:~HTMLurl#blocking-attribute
~fetch優先度~属性:~HTMLurl#fetch-priority-attribute

真偽-属性:~HTMLcms#boolean-attribute
列挙d属性:~HTMLcms#enumerated-attribute
環境に合致して:~HTMLcms#matches-the-environment
負でない整数として構文解析する:~HTMLcms#rules-for-parsing-non-negative-integers
~commaで分離された~token集合:~HTMLcms#set-of-comma-separated-tokens
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens
妥当な媒体~query~list:~HTMLcms#valid-media-query-list
妥当な負でない整数:~HTMLcms#valid-non-negative-integer
欠落~値~用の既定の状態:~HTMLcms#missing-value-default
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default

~navigable:~HTMLds#navigable
~node~navigable:~HTMLds#node-navigable
nav.容器~文書:~HTMLds#nav-container-document
	:~HTMLds#nav-container
妥当な~navigable~target名または~keyword:~HTMLds#valid-navigable-target-name-or-keyword
生成元:~ORIGIN#concept-origin
施策~容器:~ORIGIN#policy-container
作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧~文脈~sandbox化( 自動的な特能 )~flag:~ORIGIN#sandboxed-automatic-features-browsing-context-flag
pC.~referrer施策:~ORIGIN#policy-container-referrer-policy
~fetch応答から施策~容器を作成する:~ORIGIN#creating-a-policy-container-from-a-fetch-response

~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navi:~HTMLnav#navigate
	i.履歴~取扱い:~HTMLnav#navigation-hh
hH.replace:~HTMLnav#navigationhistorybehavior-replace
i.~browser~UI:~HTMLnav#uni-browser-ui
	＠~HTMLnav#the-javascript:-url-special-case

完全に読込まれた時刻:~HTMLlifecycle#completely-loaded-time

分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~accessibilityの考慮点:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
大域~属性:~HTMLdom#global-attributes
~metadata内容:~HTMLdom#metadata-content-2
句ng内容:~HTMLdom#phrasing-content-2
~flow内容:~HTMLdom#flow-content-2
見出し内容:~HTMLdom#heading-content-2
なし:~HTMLdom#concept-content-nothing
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
~text:~HTMLdom#text-content
文書:~HTMLdom#the-document-object
要素間~空白:~HTMLdom#inter-element-whitespace
言語:~HTMLdom#language
doc.施策~容器:~HTMLdom#concept-document-policy-container
表現-:~HTMLdom#represents
方向性:~HTMLdom#the-directionality
具現化を阻む:~HTMLdom#block-rendering
具現化を阻まなくする:~HTMLdom#unblock-rendering
具現化を阻んで:~HTMLdom#render-blocking

環境:~WAPI#environment
~network用~task~source:~WAPI#networking-task-source
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
~event~loop:~WAPI#event-loop
要素~taskを~queueする:~WAPI#queue-an-element-task
	step 1:~WAPI#step1
描画を更新する:~WAPI#update-the-rendering

~HTML構文解析器:~HTMLparsing#html-parser
~XML構文解析器:~HTMLxml#xml-parser

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document

文字~参照:~HTMLwriting#syntax-charref
~comment:~HTMLwriting#syntax-comments
終了~tag:~HTMLwriting#syntax-end-tag
開始~tag:~HTMLwriting#syntax-start-tag

遅延-:~HTMLparsing#delay-the-load-event
~open要素~stack:~HTMLparsing#stack-of-open-elements

~form提出:~HTMLforms#form-submission
~form:~HEforms#the-form-element

可用な画像~list:~HEimages#list-of-available-images
画像~候補~文字列:~HEimages#image-candidate-string
画像~source:~HEimages#image-source
~sizes属性:~HEimages#sizes-attribute
~source集合:~HEimages#source-set
~source集合を作成する:~HEimages#create-a-source-set
~source~size:~HEimages#source-size-2
~srcset属性:~HEimages#srcset-attribute
横幅~記述子:~HEimages#width-descriptor
~art-direction:~HEimages#art-direction

	●外部
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
~ASCII空白:~INFRA#ascii-whitespace
~ASCII~tabや~ASCII改行文字:~INFRA#ascii-tab-or-newline
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~commaで分割する:~INFRA#split-on-commas
位置~変数:~INFRA#string-position-variable
符号位置:~INFRA#code-point
~byte列:~INFRA#byte-sequence
~map:~INFRA#ordered-map
~list:~INFRA#list
空:~INFRA#list-is-empty
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
拡張する:~INFRA#list-extend
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

~CSS~stylesheet集合:~CSSOM1#css-style-sheet-set
~CSS~stylesheet集合~名:~CSSOM1#css-style-sheet-set-name
選好される~CSS~stylesheet集合~名を変更する:~CSSOM1#change-the-preferred-css-style-sheet-set-name
~CSS~stylesheetを作成する:~CSSOM1#create-a-css-style-sheet
~CSS~stylesheetを除去する:~CSSOM1#remove-a-css-style-sheet
結付けられた~CSS~stylesheet:~CSSOM1#associated-css-style-sheet
ss.代替-か:~CSSOM1#concept-css-style-sheet-alternate-flag
ss.不能化されるか:~CSSOM1#concept-css-style-sheet-disabled-flag
ss.所在:~CSSOM1#concept-css-style-sheet-location
ss.媒体:~CSSOM1#concept-css-style-sheet-media
ss.生成元cleanか:~CSSOM1#concept-css-style-sheet-origin-clean-flag
ss.所有者~CSS規則:~CSSOM1#concept-css-style-sheet-owner-css-rule
ss.所有者~node:~CSSOM1#concept-css-style-sheet-owner-node
ss.親~CSS~stylesheet:~CSSOM1#concept-css-style-sheet-parent-css-style-sheet
ss.~title:~CSSOM1#concept-css-style-sheet-title
ss.種別:~CSSOM1#concept-css-style-sheet-type
ss.~CSS規則~list:~CSSOM1#concept-css-style-sheet-css-rules

適合t~stylesheet:~CSSSNAPSHOT#conform-classes
	~CSSSYN#conform-classes

成分~値~listを構文解析する:~CSSSYN#parse-a-list-of-component-values

~CSS色~値を構文解析する:~CSSCOLOR#parse-a-css-color-value

色~scheme:~CSSCOLORADJUST#color-scheme
~pageが~supportする色~scheme群:~CSSCOLORADJUST#pages-supported-color-schemes

~CSP:~CSP3#content-security-policy-object
施策を施行-:~CSP3#enforced
施行-:~CSP3#enforced
文書に対する基底は許容されるか？:~CSP3#allow-base-for-document
要素における~inline型の挙動は~CSPにより阻止されるべきか？:~CSP3#should-block-inline
指令:~CSP3#directives
直列形の~CSPを構文解析する:~CSP3#parse-serialized-policy
妥当な~CSP:~CSP3#grammardef-serialized-policy

~fetch:~FETCH#concept-fetch
~fetchする:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
i.応答の本体を消費する処理n:~FETCH#process-response-end-of-body
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split
要請:~FETCH#concept-request
応答:~FETCH#concept-response
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.暗号用~nonce~metadata:~FETCH#concept-request-nonce-metadata
rq.施策~容器:~FETCH#concept-request-policy-container
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
rq.具現化を阻んでいるか:~FETCH#request-render-blocking
rq.起動元~種別:~FETCH#request-initiator-type
rq.同期~flag:~HTMLdep#synchronous-flag
	廃）rq.同期~flag:~FETCH#synchronous-flag
~ok状態s:~FETCH#ok-status
rs.状態s:~FETCH#concept-response-status
rs.~header~list:~FETCH#concept-response-header-list
rs.~URL:~FETCH#concept-response-url
rq.優先度:~FETCH#request-priority
~header~list:~FETCH#concept-header-list
行先~種別:~FETCH#destination-type
行先の素:~FETCH#concept-potential-destination
~scriptに類する行先:~FETCH#request-destination-script-like

~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
doc.生成元:~DOM4#concept-document-origin
文書~要素:~DOM4#document-element
文書~tree内:~DOM4#in-a-document-tree
根:~DOM4#concept-tree-root
~supportする~token:~DOM4#concept-supported-tokens
作動化の挙動:~DOM4#eventtarget-activation-behavior
~eventを発火する:~DOM4#concept-event-fire
子~text内容:~DOM4#concept-child-text-content
子~群~変更-時の手続き:~DOM4#concept-node-children-changed-ext
全~内容を文字列に置換する:~DOM4#string-replace-all
接続されて:~DOM4#connected

~UTF-8:~ENCODING#utf-8
符号化法:~ENCODING#encoding
符号化法~label:~ENCODING#label

~URL:~URL1#concept-url
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
妥当な~URL文字列:~URL1#valid-url-string
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer

~referrer施策:~REFERRER-POLICY#referrer-policy
既定の~referrer施策:~REFERRER-POLICY#default-referrer-policy

~MIME型:~MIMESNIFF#mime-type
妥当な~MIME型~文字列:~MIMESNIFF#valid-mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
画像を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-images-specifically
給された~MIME型:~MIMESNIFF#supplied-mime-type

c.~xml-stylesheet:https://www.w3.org/TR/xml-stylesheet/#the-xml-stylesheet-processing-instruction

最終-応答:~HTTPsem#final-response

~link関係~型:~HTTPweblink#_link-relation-types
~link~target:~HTTPweblink#_link-target
~target属性~群:~HTTPweblink#_attributes
	構文解析-:~HTTPweblink#parse-fv


	WHATWG Wiki MetaExtensions page:https://wiki.whatwg.org/wiki/MetaExtensions
	WHATWG Wiki PragmaExtensions page:https://wiki.whatwg.org/wiki/PragmaExtensions

定義済み~metadata名の集合に対する拡張:#concept-meta-extensions
定義済み~link型の集合に対する拡張:~HTMLlinks#concept-rel-extensions
	~metadata名:#concept-meta-extensions
	~style付け~modelに供与する外部~資源~link:~HTMLlinks#link-type-stylesheet


	●

●●words_table1

HTTPearlyhints:http-status-code-103-ja.html
HTTPbcp:http-app-bcp-ja.html
mediaS:media
titleS:title
disabledS:disabled
blockingS:blocking
xml-stylesheet:&lt;?xml-stylesheet?&gt;

●●words_table

	●network／保安／navi
DNS:
HTTP11:HTTP/1.1
HTTP2:HTTP/2
Content-Type:
XSS:cross-site scripting:XSS
body-ok:
refresh:
directory::::ディレクトリ
追う:followする:~
sniff:
spam::::スパム
timer::::タイマー
時限:timed::~
load:
commit:
preload:
早期:early::~
	早期~hint:Early-hint／:Early hint／:early hint
最終-:final:~
投機的:speculative::~
到着-:arrive:~
読込直す:reloadする::読み込み直す::リロードする
読込直-:reload::読み込み直::リロード
低速:slow:~
	crossorigin
生成元clean:origin-clean::生成元-clean::オリジン-clean
暗号用:cryptographic::~
nonce::::ナンス
ok:
	阻止される^i:blocked
	完全性~metadata:integrity
	~MIME型:type

	●構文
BOM:
	-:literal
直列形の:serialized::~::シリアル形の
自由形:free-form:~

部分文字列:substring::~
	符号化法:character encoding
読飛ばす:skipする:読み飛ばす
剥ぐ:stripする::~
省略:omission:~
要素間:inter-element:~
省略不可:omissibleでない:~


	●型／構造／操作
名値:name-value::名-値
切断-:disconnect::~
body:
生の:raw:~
相:phase:~
内包-:include:~
	子たち:children
	文書~level:document-level

	●処理
切替器:switcher::~
経過-:elapse::~
優先度:priority::~

	後から来る:late
	始まる:begin
	戻って来た:comes back
	何もしない:no-op
	あきらめる:give up
	渡す:pass
	渡-:-

	%~URL:url
	%~URL~record:url
	%~URL~record:urlRecord
	%文書:doc
	%生の~link~header群:rawLinkHeaders
	%~link~header:linkHeader
	%~link~obj:linkObject
	%文書:document
	%~option群:options
	%関係~型:rel
	%属性~群:attribs
	%行先の素:-
	%行先:destination
	%期待される相:expectedPhase
	%~header群:headers
	%~link群:links
	%予約-済み環境:reservedEnvironment
	%早期~施策~容器:earlyPolicyContainer
	%早期~hint群:earlyHints
	%早期~要請:earlyRequest
	%応答:res
	%応答:response
	%crossorigin:crossorigin
	%integrity:-
	%本体~byte列:bodyBytes
	%~stylesheet:-
	%適用されたか:-

	●内容／意味論／呈示／UI
必須:critical::~
microdata:
	スライドショー:slide
	最上位の:top-level／first
	-:cell
	列:column
分類:categories:~
句ng:phrasing::句::フレージング
art-direction:art direction::art 演出:アート演出
見出し:heading:~
編集:edit:~
翻訳-:translate:~
翻訳:translation:~
英語:English:~
license::::ライセンス
強勢:stress emphasis:~
周囲の:surrounding:~
bookmark::::ブックマーク
italic:
強調:highlight:~
閲覧履歴:history:~
発話合成:speech-synthesis:~
発音:pronunciation:~
	~style付け:styling
	緑:green
	黒:black
暗な:darkな:暗い
明な:lightな:明るい
高解像度:high-resolution:~
display::::ディスプレイ
monitor::::モニタ
contrast::::コントラスト
sizes:
srcset:
	色~scheme:color-scheme

	●仕様
theme::::テーマ
必要十分:adequate:~
最適:optimum:~
自立的:stand-alone:~
同義語:synonym:~
有害:harmful:~
概略的:brief::~
地位:status::~
Wiki:
理論的:theoretic:~
伝えて:informして:~
戸惑う:wonderする:~
準拠:compliant:~
査読:peer review:~
重複:duplicate:~
使用中止:discontinued::~
批准-:ratify:~
	批准-済み:ratified
	提案-済み:proposed
付随-:accompany:~
衝突-:clash:~
究明-:investigate:~
手助け:facilitate:~
尊重-:respect:~
能性:potential:~
打切られ:discontinueされ:打ち切られ
企てて:contemplateして:~
不一致:mismatch:~
用心深く:cautiousに:~
切替n:switch:切り替え
事故:accident:~
定着-:perpetuate:~
劇的:dramatic:~

	かまわない:free to
	help
	助け:helpful
	主題:subject matter
	-:reason
	かぶる:redundant
	得る:possible
	semantic
	ought to:されるべき
	まずない:quite unlikely
	より高~level:higher-level
	より，〜必要yである:necessitate 
	紛らわしい:confusingly similar
	時期が来た:have come due
	対照的に／:contrast
	対比-:contrasted with
	:~insufficient
	見込みが高い:likely
	単に:merely
	:nothing
	:official
	~~規範的に:prescriptive
	相当するもの:counterpart
	くまなく:thoroughly
	し易くするため:helps
	approval
	期待-:with the expectation that
	期待されない:unexpected
	ただし:exception
	あてにならない／:unreliable
	水準に満たない:wanting
	満たす:satisfy／
	判明した:found
	~~落とし込まれる:kick in
	移行:migration
	誤解させる:misleading
	ことにする:opt
	:~say
	:written
	結果になる:end up
	道を誤る:make poor choice
	~AND↓ を満た:meet the following criteria
	ようにするとき:how
	とは反対に:opposite to
	に注意:importantly
	当面の間:meantime
	~~別々に:differently
	〜されても応答しない:not responsive
	素早く:quickに
	促す:encourage
	より後に現れてはナラナイ:must come before
	とは逆に:as opposed
	誰か:someone
	全くではないが，:almost, but not quite
	まるっきり異なる:entirely unlike
	まるっきり:entirely
	指定-:present
	2 種類:Two categories
	兼ね合いを図る:balance the likelihood of
	他のものに加えて:as with anything
	あてになるかどうか疑わしい:there is insufficient confidence in the reliability
	誰もが:anyone
	前述した／:aforementioned
	いずれにせよ:nonetheless
	越したことはない:best off
	にもかかわらず:despite
	~~考える:think
	書く者:writer
	方が良くなる:the better choice
	適用されない::un-applied
	方へ進む:will go

	●未分類
供与-:contribute:~
editor::::エディタ
open:
集積者:aggregator::~
PNG:
X-UA-Compatible:
pragma:
	~pragma集合:pragma-set
	担当する:responsible な
ranking::::ランキング
処理命令:processing instruction:~
	処理命令:PI
disk::::ディスク
email::::メール
iframe-srcdoc:iframe srcdoc
package::::パッケージ
	~link先の:target
候補:candidate:~
種類:kind:~
近過去:recent:~
	最も近過去に:most-recently-
manifest::::マニフェスト

	deployment
	暗くした:darker
	-:leaving
	指す:refer
	現れる:seen
	受けて:receive して
	-:deciding
	~~検索する:look for
	選ぶ:choose
	取り出され:take out
	とされ:mark
	American:米国
	British:英国
	Latin
	Salsa
	Waltz
	件名:Subject-line
	aforementioned
	anything

	ダンス:dance
	サルサ:Salsa
	ワルツ:Waltz

	become
	用の:aim
	-:authoritative
	閉じら:close さ
	現れ:come
	数えられ:count
	扉:front
	ような:labeled
	大規模:large-scale
	-:moment
	時点で:moment
	高速道路:motorway
	news-organization:news organization:::ニュース配信組織
	〜以上〜ままにある:period
	:~point
	:potential
	すでに:previously
	事前に:pro-actively
	対応する:respective
	~styleをあてがい直す:restyling
	:site-specific
	-:typeface
	~network接続の不確実性:use of unreliable network connectivity
	:very
	広くから:wide
	数:number
	明るい:bright
	短い:short
	近く:closely
	に代えて:in preference to
	終わるまで何もしない:doing nothing while waiting for 〜 to finish
	~rankingを不当に操ろうと:game its ranking mechanism
	近いうち:soon will be
	挙げる:list
	秒数:time
	後に生じた方の時点:as soon as the later of
	ニュース配信サイトの第一面:A news organization's front page
	'
	他の~markupに先立つ先頭:very top
	総量に上限は無い:large or small
	項:entry::::エントリ
	に等しい:just an
	~~整数:number
	狭い:small
	%構文解析した結果:parsed
	先頭から順に:successive
	アテガっても:assignment
	~redirect後の最終-応答:The late
	読込まれたとしても:comes after the request to fetch the style has already been performed
	当の~link型が現れたとき:in appearing
	〜以上の~version:or above
	Internet Explorer
	-:certain
	最終的:eventual
	:against
	先頭近く:the top of
	1 ヶ月:a month
	一方で:whereas
	:next
	一つ:one
	一体として:whole
	後の:later
	早々に:prematurely
	各種／異なる:different
	する際に:upon
	部位:part
	一連の:sequence
	~link先:in question
	当の:in question
	再度:re-


●●html_code_list



■html-1
<!DOCTYPE html>
＜<html lang="ja">＞
<head>
<title>歌の交換</title>
</head>
<body>
％<h1>歌の交換</h1>
<p>今夜は、友人たちとの間で各自が書いた歌を交換しあった。書いた歌が共有されるのはうれしい。</p>
</body>
＜</html>＞

<!DOCTYPE html>
<html lang="en">
<head>
<title>Swapping Songs</title>
</head>
<body>
<h1>Swapping Songs</h1>
<p>Tonight I swapped some of the songs I wrote with some friends, who
gave me some of the songs they wrote. I love sharing my music.</p>
</body>
</html>

■head-1
<!doctype html>
<html lang=ja>
 <head>
  <title>head が短い文書</title>
 </head>
 <body>
 ...

  <title>A document with a short head</title>

■head-2
<!doctype html>
<html lang="ja">
 <head>
  <meta charset="utf-8">
  <base href="https://www.example.com/">
  <title>もうちょい head が長いアプリ</title>
  <link rel="stylesheet" href="default.css">
  <link rel="stylesheet alternate" href="big.css" title="big text">
  <％script src="support.js"><％/script>
  <meta name="application-name" content="もうちょい head が長いアプリ">
 </head>
 <body>
 ...

  <TITLE>An application with a long head</TITLE>


■title-1
<title>ミツバチの仲間どうしの儀式的ダンス — 序説</title>
  ...
％<h1>序</h1>
<p>はじめに、著名な本
<cite>中世の養蜂 — 序説</cite> をとり挙げよう...

  <title>Introduction to The Mating Rituals of Bees</title>
    ...
  <h1>Introduction</h1>
  <p>This companion guide to the highly successful
  <cite>Introduction to Medieval Bee-Keeping</cite> book is...

■title-2
<title>ミツバチの仲間どうしの儀式的ダンス</title>
  ...
％<h1>ダンス</h1>

  <title>Dances used during bee mating rituals</title>
    ...
  <h1>The Dances</h1>

■base-1
<!DOCTYPE html>
<html lang="ja">
    <head>
        <title>&lt;base&gt; 要素の例</title>
        <base href="https://www.example.com/news/index.html">
    </head>
    <body>
        <p><a href="archives.html">アーカイブ</a>もあります。</p>
    </body>
</html>

<title>This is an example for the &lt;base&gt; element</title>
<p>Visit the <a href="archives.html">archives</a>.</p>

■link-1
<link rel="author license" href="/about">

■link-2
<link rel="preload" as="image"
      imagesrcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w, wolf_1600px.jpg 1600w"
      imagesizes="50vw">
％
<!-- ... たぶん、後で動的に挿入される ... -->
<img src="wolf.jpg" alt="A rad wolf"
     srcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w, wolf_1600px.jpg 1600w"
     sizes="50vw">

later, or perhaps inserted dynamically

■link-3
<link rel="preload" as="image"
      imagesrcset="dog-cropped-1x.jpg, dog-cropped-2x.jpg 2x"
      media="(max-width: 800px)">
<link rel="preload" as="image"
      imagesrcset="dog-wide-1x.jpg, dog-wide-2x.jpg 2x"
      media="(min-width: 801px)">
％
<!-- ... たぶん、後で動的に挿入される ... -->
<picture>
  <source srcset="dog-cropped-1x.jpg, dog-cropped-2x.jpg 2x"
          media="(max-width: 800px)">
  <img src="dog-wide-1x.jpg" srcset="dog-wide-2x.jpg 2x"
       alt="An awesome dog">
</picture>

■link-4
<link disabled rel="alternate stylesheet" href="css/pooh">


■link-stylesheet-1
<link rel="stylesheet" href="A" type="text/plain">
<link rel="stylesheet" href="B" type="text/css">
<link rel="stylesheet" href="C">

■meta-generator-1
<meta name=generator content="Frontweaver 8.2">

■meta-keywords-1
<!DOCTYPE HTML>
<html lang="ja">
 <head>
  <title>日本の高速道路標識</title>
  <meta name="keywords"
    content="道路,高速,標識,本標識,補助標識,案内,予告,方面"
  >
 </head>
 <body>
  ...

<!DOCTYPE HTML>
<html lang="en-GB">
 <head>
  <title>Typefaces on UK motorways</title>
  <meta name="keywords"
    content="british,type face,font,fonts,highway,highways"
  >
 </head>
 <body>
  ...

■meta-theme-color-1
<!DOCTYPE HTML>
<title>HTML Standard</title>
<meta name="theme-color" content="#3c790a">
...

■meta-theme-color-2
<!DOCTYPE HTML>
<title>HTML Standard</title>
<meta name="theme-color" content="#3c790a" media="(prefers-color-scheme: dark)">
...

■meta-color-scheme-1
<meta name="color-scheme" content="dark">

■meta-refresh-1
<meta http-equiv="Refresh" content="300">

■meta-refresh-2
<meta http-equiv="Refresh" content="20; URL=page4.html">

■meta-csp-1
<meta
   http-equiv="Content-Security-Policy"
   content="script-src 'self'; object-src 'none'"
>

■meta-charset-1
<meta charset="utf-8">

■xml-encoding-1
<?xml version="1.0" encoding="utf-8"?>

■style-1
<!DOCTYPE html>
<html lang="ja">
 <head>
  <title>好きな本</title>
  <style>
   body { color: black; background: white; }
   em { font-style: normal; color: red; }
  </style>
 </head>
 <body>
  <p><em>今まで</em>で最も<em>好きな</em>本は、 P. ラーメルさんが書いた<cite>ネコの一生</cite>です。その本には、人間社会における<i>イエネコ</i>について述べられています。</p>
 </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
 <head>
  <title>My favorite book</title>
  <style>
   body { color: black; background: white; }
   em { font-style: normal; color: red; }
  </style>
 </head>
 <body>
  <p>My <em>favorite</em> book of all time has <em>got</em> to be
  <cite>A Cat's Life</cite>. It is a book by P. Rahmel that talks
  about the <i lang="la">Felis catus</i> in modern human society.</p>
 </body>
</html>
	'


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ The document element, および § Document metadata</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>

<body>

<header>
	<hgroup>
<h1>HTML — 文書要素, 文書メタデータ</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="semantics">
<h2 title="The elements of HTML">4. ~HTMLの要素</h2>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

		</section>
		<section id="the-root-element">
<h3 title="The document element">4.1. 文書~要素</h3>

			<section id="the-html-element">
<h4 title="The html element">4.1.1. `html^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
（なし）
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
文書の`文書~要素$として。
◎
As document's document element.
</dd>
	<dd>
`Wherever a subdocument fragment is allowed in a compound document.^en†
</dd>
	<dd class="trans-note">【†
訳すなら、
“複合-文書~内で，下位文書片が許容されている所。”
となるが，意図不明。
~inline~SVGにおける
`foreignObject＠~SVGembedded#elementdef-foreignObject$e 要素~内での利用を指しているのかもしれない。
（ “複合-文書” とは
`Compound Document＠https://www.w3.org/TR/CDR/$ 仕様のそれを指すようにも思われるが、
その仕様の策定は打切られた。）
】</dd>

	<dt>`内容~model$</dt>
	<dd>
1 個の `head$e 要素,
1 個の `body$e 要素
からなる並び。
◎
A head element followed by a body element.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`html$e 要素の`開始~tag$は、
要素の内側にある最初のものが`~comment$でないならば，省略できる。
◎
An html element's start tag can be omitted if the first thing inside the html element is not a comment.
</dd>
	<dd>
`html$e 要素の`終了~tag$は、
要素の直後に`~comment$が続かないならば，省略できる。
◎
An html element's end tag can be omitted if the html element is not immediately followed by a comment.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`html$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLHtmlElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  // `HTMLHtmlElement$obsMb
};
</pre>

	</dd>
</dl>

<p>
`html$e 要素は、
~HTML文書の根を`表現-$する。
◎
The html element represents the root of an HTML document.
</p>

<p>
作者には、
根 `html$e 要素に `lang$a 属性を指定して，文書の言語を与えることが奨励される。
これは、
発話合成~toolが利用する発音を決定する,
翻訳~toolが利用する規則を決定する,
等々を援助する。
◎
Authors are encouraged to specify a lang attribute on the root html element, giving the document's language. This aids speech synthesis tools to determine what pronunciations to use, translation tools to determine what rules to use, and so forth.
</p>

<div class="example">
<p>
次の例における `html$e 要素は、
文書の言語が日本語であることを宣言する。
◎
The html element in the following example declares that the document's language is English.
</p>

`html-1^xCode
</div>

			</section>
		</section>
		<section id="document-metadata">
<h3 title="Document metadata">4.2. 文書~metadata</h3>

			<section id="the-head-element">
<h4 title="The head element">4.2.1. `head^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
（なし）
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`html$e 要素~内の最初の要素として。
◎
As the first element in an html element.
</dd>

	<dt>`内容~model$</dt>
	<dd>
文書が`~iframe-srcdoc文書$である場合 ／
~title情報がより高~levelな~protocolから可用である場合：
0 個~以上の`~metadata内容$要素
— そのうち `title$e, `base$e 要素は各 1 個まで。
◎
If the document is an iframe srcdoc document or if title information is available from a higher-level protocol: Zero or more elements of metadata content, of which no more than one is a title element and no more than one is a base element.
</dd>
	<dd>
他の場合：
1 個以上の`~metadata内容$要素
— そのうち `title$e, `base$e 要素は各 1 個まで。
◎
Otherwise: One or more elements of metadata content, of which exactly one is a title element and no more than one is a base element.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`head$e 要素の`開始~tag$は、
要素は空であるか, または
要素の内側にある最初のものは要素であるならば，省略できる。
◎
A head element's start tag can be omitted if the element is empty, or if the first thing inside the head element is an element.
</dd>
	<dd>
`head$e 要素の`終了~tag$は、
要素の直後に［
`~ASCII空白$／`~comment$
］が続かないならば，省略できる。
◎
A head element's end tag can be omitted if the head element is not immediately followed by ASCII whitespace or a comment.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`head$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLHeadElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();
};
</pre>
	</dd>
</dl>

<p>
`head$e 要素は、
`文書$に対する~metadataたちが成す~collectionを`表現-$する。
◎
The head element represents a collection of metadata for the Document.
</p>

<div class="example">
<p>
`head$e 要素~内の~metadataの総量に上限は無い。
ごく短い例：
◎
The collection of metadata in a head element can be large or small. Here is an example of a very short one:
</p>

`head-1^xCode

<p>
より長い例：
◎
Here is an example of a longer one:
</p>

`head-2^xCode
</div>

<p class="note">注記：
ほとんどの状況では `title$e 要素が子に要求されるが、
より高~levelな~protocolが~title情報を供している場合は， `title$e 要素を省略できる
— 例えば、
~email著作~形式として~HTMLが利用されている下で，~emailの `件名^i が~title情報を供している場合など。
◎
The title element is a required child in most situations, but when a higher-level protocol provides title information, e.g., in the subject line of an email when HTML is used as an email authoring format, the title element can be omitted.
</p>

			</section>
			<section id="the-title-element">
<h4 title="The title element">4.2.2. `title^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~metadata内容$
◎
Metadata content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
他の `title$e 要素を包含していない `head$e 要素~内。
◎
In a head element containing no other title elements.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`要素間~空白$でない`~text$。
◎
Text that is not inter-element whitespace.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`title$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLTitleElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `text$m;
};
</pre>
	</dd>
</dl>

<p>
`title$e 要素は、
文書の~titleあるいは名前を`表現-$する。
作者は、
文書を識別するときには，文書が文脈の外で利用されるとき
— 例えば，利用者の閲覧履歴や~bookmark, 探索-結果において —
でも，~titleを利用するベキである。
文書の~titleは、
最上位の見出し（文書~全体に適用される`見出し内容$）と異なることが多い
— 最上位の見出しは、
文脈の外に取り出されたときに自立的になる必要はないので。
◎
The title element represents the document's title or name. Authors should use titles that identify their documents even when they are used out of context, for example in a user's history or bookmarks, or in search results. The document's title is often different from its first heading, since the first heading does not have to stand alone when taken out of context.
</p>

<p>
`title$e 要素は文書ごとに 1 個まででなければナラナイ。
◎
There must be no more than one title element per document.
</p>

<p class="note">注記：
`文書$が~titleを持たないことが適理な場合、
`title$e 要素はおそらく要求されない。
`head$e 要素の内容~modelにおける，この要素がいつ要求されるかの記述を見よ。
◎
If it's reasonable for the Document to have no title, then the title element is probably not required. See the head element's content model for a description of when the element is required.
</p>

<dl class="domintro">
	<dt>%title.`text$m [ = %value ]</dt>
	<dd>
要素の`子~text内容$を返す。
◎
Returns the child text content of the element.
</dd>
	<dd>
設定して，要素の子たちを所与の値に置換できる。
◎
Can be set, to replace the element's children with the given value.
</dd>
</dl>

<div class="algo">
`text@m
取得子~手続きは
⇒
~RET コレの`子~text内容$
◎
The text attribute's getter must return this title element's child text content.
</div>

<div class="algo">
`text$m 設定子~手続きは
⇒
コレの`全~内容を文字列に置換する$( 所与の値 )
◎
The text attribute's setter must string replace all with the given value within this title element.
</div>

<div class="example">
<p>
以下に、
適切な~titleの例を，最上位の見出しと対比させながら挙げる。
◎
Here are some examples of appropriate titles, contrasted with the top-level headings that might be used on those same pages.
</p>

`title-1^xCode

<p>
同じ~siteには、
次のような~pageもあるかもしれない。
~titleが当の主題を一義的に述べていることに注意。
一方で，最上位の見出しは、
読者が当の文脈が何であるかすでに知っている
— ダンスがサルサやワルツかも…などと戸惑うことはない —
ものと見做している：
◎
The next page might be a part of the same site. Note how the title describes the subject matter unambiguously, while the first heading assumes the reader knows what the context is and therefore won't wonder if the dances are Salsa or Waltz:
</p>

`title-2^xCode
</div>

<p>
文書の~titleとして利用する文字列は、
`document.title$m ~IDL属性により与えられる。
◎
The string to use as the document's title is given by the document.title IDL attribute.
</p>

<p>
~UAは、
~UI内で文書を指すときは，文書の~titleを利用するベキである。
`title$e 要素の内容を~UIに利用する場合、
その方向性には，要素の`方向性$を利用するベキである。
◎
User agents should use the document's title when referring to the document in their user interface. When the contents of a title element are used in this way, the directionality of that title element should be used to set the directionality of the document's title in the user interface.
</p>

			</section>
			<section id="the-base-element">
<h4 title="The base element">4.2.3. `base^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~metadata内容$
◎
Metadata content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
他の `base$e 要素を包含していない `head$e 要素~内。
◎
In a head element containing no other base elements.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`href$a
— `文書~基底~URL$を与える。
◎
href — Document base URL
</dd>
	<dd>
`target$a
— ［
`~hyperlink$による`~navi$ ／ `~form提出$
］用の既定の`~navigable$を与える。
◎
target — Default navigable for hyperlink navigation and form submission
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`base$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLBaseElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$, `ReflectSetter$] attribute USVString `href$m;
  [`CEReactions$, `Reflect$] attribute DOMString `target@m;
};
</pre>

	</dd>
</dl>

<p>
`base$e 要素は、
次を作者に許容する：
◎
The base element allows authors＼
</p>
<ul>
	<li>
`~URL$を構文解析する目的で，`文書~基底~URL$を指定する。
◎
to specify the document base URL for the purposes of parsing URLs,＼
</li>
	<li>
`~hyperlinkを追う$目的で，既定の`~navigable$の名前を指定する。
◎
and the name of the default navigable for the purposes of following hyperlinks.＼
</li>
</ul>

<p>
この要素は、
上に挙げたもの以外の内容を`表現-$しない。
◎
The element does not represent any content beyond this information.
</p>

<p>
同じ文書~内に `base$e 要素が複数個~在ってはナラナイ。
◎
There must be no more than one base element per document.
</p>

<p>
`base$e 要素は、［
`href$a, `target$a
］いずれかの属性は有していなければナラナイ。
◎
A base element must have either an href attribute, a target attribute, or both.
</p>

<p>
`href@a
内容~属性に指定する値は、
`妥当な~URL（前後~空白~可）$でなければナラナイ。
◎
The href content attribute, if specified, must contain a valid URL potentially surrounded by spaces.
</p>

<p>
`href$a 属性を有する `base$e 要素は、
同じ文書~tree内の他の［
`~URL$を値にとるものと定義された属性を有する要素
］よりも後に現れてはナラナイ。
◎
A base element, if it has an href attribute, must come before any other elements in the tree that have attributes defined as taking URLs.
</p>

<p class="note">注記：
`href$a 属性を有する `base$e 要素が複数個ある場合、
最初のそれ以外はすべて無視される。
◎
If there are multiple base elements with href attributes, all but the first are ignored.
</p>

<p>
`target@a
属性に指定する値は、
`妥当な~navigable~target名または~keyword$を包含していなければナラナイ。
それは、
`文書$内の`~hyperlink$や`~form$により`~navi$が生じるときに，既定で利用される`~navigable$を指定する。
◎
The target attribute, if specified, must contain a valid navigable target name or keyword, which specifies which navigable is to be used as the default when hyperlinks and forms in the Document cause navigation.
</p>

<p>
`target$a 属性を有する `base$e 要素は、
同じ文書~tree内の［
`~hyperlink$を表現する要素
］よりも後に現れてはナラナイ。
◎
A base element, if it has a target attribute, must come before any elements in the tree that represent hyperlinks.
</p>

<p class="note">注記：
`target$a 属性を有する `base$e 要素が複数個ある場合、
最初のそれ以外はすべて無視される。
◎
If there are multiple base elements with target attributes, all but the first are ignored.
</p>

<div class="algo">
<p>
`要素の~targetを取得する@
~algoは、
所与の
( %要素, 文字列 %~target ~DF ~NULL )
に対し：
◎
To get an element's target, given an a, area, or form element element, and an optional string-or-null target (default null), run these steps:
</p>
<ol>
	<li>
~Assert：
%要素 は［
`a$e ／ `area$e ／ `form$e
］要素である。
◎
↑</li>
	<li>
<p>
~IF［
%~target ~EQ ~NULL
］：
◎
If target is null, then:
</p>
		<ol>
			<li>
~IF［
%要素 は `target^a 属性を有する
］
⇒
%~target ~SET %要素 の `target^a 属性の値
◎
If element has a target attribute, then set target to that attribute's value.
</li>
			<li>
~ELSE
⇒
%要素 の`~node文書$が包含する
~EACH( `base$e 要素 %base )
に対し，`~tree順序$で
⇒
~IF［
%base は `target$a 属性を有する
］
⇒＃
%~target ~SET %base の `target$a 属性の値；
~BREAK
◎
Otherwise, if element's node document contains a base element with a target attribute, set target to the value of the target attribute of the first such base element.
</li>
		</ol>
	</li>
	<li>
~IF［
%~target ~NEQ ~NULL
］~AND［
%~target は`~ASCII~tabや~ASCII改行文字$を包含する
］~AND［
%~target は
<span class="code-point">U+003C</span> (<span class="char-symbol">&lt;</span>)
を包含する
］
⇒
%~target ~SET `_blank^l
◎
If target is not null, and contains an ASCII tab or newline and a U+003C (&lt;), then set target to "_blank".
</li>
	<li>
~RET %~target
◎
Return target.
</li>
</ol>
</div>

<hr>

<div class="p">
<p>
次の条件を満たす `base$e 要素は、
`凍結d基底~URL@
を持つとされる：
</p>
<ul>
	<li>
`href$a 内容~属性を有する, かつ
</li>
	<li>
`文書~tree内$にある, かつ
</li>
	<li>
前 2 条件を満たす `base$e 要素のうち，`~tree順序$で最初のものである
</li>
</ul>
◎
A base element that is the first base element with an href content attribute in a document tree has a frozen base URL.＼
</div>

<p>
~UAは、
`base$e 要素において，次のいずれかの状況が生じたときは、
`即時$に，要素の`凍結d基底~URLを設定する$モノトスル：
◎
The frozen base URL must be immediately set for an element whenever any of the following situations occur:
</p>

<ul>
	<li>
上の条件を満たしていない `base$e 要素が，上の条件を満たすようになったとき。
◎
The base element becomes the first base element in tree order with an href content attribute in its Document.
</li>
	<li>
上の条件を満たしている `base$e 要素の `href$a 内容~属性が変化したとき。
◎
The base element is the first base element in tree order with an href content attribute in its Document, and its href content attribute is changed.
</li>
</ul>

<div class="algo">
<p>
`base$e 要素 %要素 の
`凍結d基底~URLを設定する@
~algoは：
◎
To set the frozen base URL for an element element:
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
<p>
%~URL~record ~LET 
`~URL構文解析する$( %要素 の `href$a 内容~属性の値, `~fallback基底~URL$( %文書 ), %文書 の`符号化法$doc )
</p>
<p>
（したがって、
`base$e 要素の `href$a 内容~属性は，自他の `base$e 要素からは影響されない。）
</p>
◎
Let urlRecord be the result of parsing the value of element's href content attribute with document's fallback base URL, and document's character encoding. (Thus, the base element isn't affected by itself.)
</li>
	<li>
<p>
%要素 の`凍結d基底~URL$ ~SET ［
~AND↓ ならば %~URL~record ／
~ELSE_ `~fallback基底~URL$( %文書 )
］：
</p>
		<ul>
			<li>
%~URL~record ~NEQ `失敗^i
</li>
			<li>
%~URL~record の`~scheme$url ~NIN { `data^l, `javascript^l }
</li>
			<li>
`文書に対する基底は許容されるか？$( %~URL~record, %文書 )
~EQ `許容される^i
</li>
		</ul>
◎
If any of the following are true:
• urlRecord is failure;
• urlRecord's scheme is "data" or "javascript"; or
• running Is base allowed for Document? on urlRecord and document returns "Blocked",
◎
then set element's frozen base URL to document's fallback base URL and return.
◎
Set element's frozen base URL to urlRecord.
</li>
	<li>
`基底~URLの変化に応答する$( %文書 )
◎
Respond to base URL changes given document.
</li>
</ol>
</div>

<div class="algo">
<p>
`href@m
取得子~手続きは：
◎
The href IDL attribute, on getting, must return the result of running the following algorithm:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let document be element's node document.
</li>
	<li>
%~URL ~LET コレは `href$a 属性を［
有するならば その値 ／
有さないならば 空~文字列
］
◎
Let url be the value of the href attribute of this element, if it has one, and the empty string otherwise.
</li>
	<li>
<p>
%~URL~record ~LET
`~URL構文解析する$( %~URL, `~fallback基底~URL$( %文書 ), %文書 の`符号化法$doc )
</p>
<p>
（したがって、
`base$e 要素の `href$a 内容~属性は，自他の `base$e 要素からは影響されない。）
</p>
◎
Let urlRecord be the result of parsing url with document's fallback base URL, and document's character encoding. (Thus, the base element isn't affected by other base elements or itself.)
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET %~URL
◎
If urlRecord is failure, return url.
</li>
	<li>
~RET `~URLを直列化する$( %~URL~record )
◎
Return the serialization of urlRecord.
</li>
</ol>
</div>

<div class="example">
<p>
`base$e 要素を利用して，`文書~基底~URL$を設定する例：
◎
In this example, a base element is used to set the document base URL:
</p>

`base-1^xCode

<p>
上の例の~linkは、
`https://www.example.com/news/archives.html^l
を指すことになる。
◎
The link in the above example would be a link to "https://www.example.com/news/archives.html".
</p>
</div>

			</section>
			<section id="the-link-element">
<h4 title="The link element">4.2.4. `link^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~metadata内容$
◎
Metadata content.
</dd>
	<dd>
要素が`~body内に許容され$る場合に限り：
`~flow内容$／`句ng内容$。
◎
If the element is allowed in the body: flow content.
◎
If the element is allowed in the body: phrasing content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`~metadata内容$が期待される所。
◎
Where metadata content is expected.
</dd>
	<dd>
`head$e 要素の子である `noscript$e 要素~内。
◎
In a noscript element that is a child of a head element.
</dd>
	<dd>
要素が`~body内に許容され$る場合に限り：
`句ng内容$が期待される所。
◎
If the element is allowed in the body: where phrasing content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`href$aL
— `~hyperlink$の~addressを与える。
◎
href — Address of the hyperlink
</dd>
	<dd>
`crossorigin$aL
— 要素が非同一-生成元の要請をどう取扱うかを与える。
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>
`rel$aL
— ~hyperlinkを包含している文書と行先~資源との関係性を与える。
◎
rel — Relationship between the document containing the hyperlink and the destination resource
</dd>
	<dd>
`media$aL
— 適用-可能な媒体を与える。
◎
media — Applicable media
</dd>
	<dd>
`integrity$aL
— `Subresource Integrity^cite（下位資源の完全性）検査に利用される完全性~metadataを与える。
`SRI$r
◎
integrity — Integrity metadata used in Subresource Integrity checks [SRI]
</dd>
	<dd>
`hreflang$aL
— ~link先~資源の言語を与える。
◎
hreflang — Language of the linked resource
</dd>
	<dd>
`type$aL
— 参照-先~資源の型に関する~hintを与える。
◎
type — Hint for the type of the referenced resource
</dd>
	<dd>
`referrerpolicy$aL
— 要素により起動される`~fetch$用の`~referrer施策$を与える。
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>
	<dd>
`sizes$aL
— ~iconの~sizeを与える。
（ <code>`rel$aL="`icon$v"</code> 用）
◎
sizes — Sizes of the icons (for rel="icon")
</dd>
	<dd>
`imagesrcset$aL
— 種々の状況
（例：高解像度~display, 狭い~monitor, 等々）
に応じて利用する一連の画像
（ <code>`rel$aL="`preload$v"</code> 用）
◎
imagesrcset — Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel="preload")
</dd>
	<dd>
`imagesizes$aL
— 種々の~page~layout用の画像~size
（ <code>`rel$aL="`preload$v"</code> 用）
◎
imagesizes — Image sizes for different page layouts (for rel="preload")
</dd>
	<dd>
`as$aL
— ~preload要請~用の`行先の素$を与える。
（
<code>`rel$aL="`preload$v"</code> ／
<code>`rel$aL="`modulepreload$v"</code>
用）
◎
as — Potential destination for a preload request (for rel="preload" and rel="modulepreload")
</dd>
	<dd>
`blocking$aL
— 要素は`具現化を阻む能性$があるかどうか。
◎
blocking — Whether the element is potentially render-blocking
</dd>
	<dd>
`color$aL
— ~siteの~iconを~custom化するときに利用する色
（ <code>`rel$aL="`mask-icon^v"</code> 用）。
◎
color — Color to use when customizing a site's icon (for rel="mask-icon")
</dd>
	<dd>
`disabled$aL
— ~linkは不能化されるかどうか
◎
disabled — Whether the link is disabled
</dd>
	<dd>
`fetchpriority$aL
— 要素により起動される`~fetch$用の`優先度$rqを設定する。
◎
fetchpriority — Sets the priority for fetches initiated by the element
</dd>
	<dd>
この要素の `title$aL 属性には，
`特別な意味論＠#attr-link-title$もあり、［
~linkの~title ／ `~CSS~stylesheet集合~名$
］を与える。
◎
Also, the title attribute has special semantics on this element: Title of the link; CSS style sheet set name
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`link$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLLinkElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$, `ReflectURL$] attribute USVString `href@mL;
  [`CEReactions$] attribute DOMString? `crossOrigin$mL;
  [`CEReactions$, `Reflect$] attribute DOMString `rel@mL;
  [`CEReactions$] attribute DOMString `as$mL;
  [SameObject, PutForwards=`value$m, `Reflect$="`rel$aL"] readonly attribute `DOMTokenList$I `relList@mL;
  [`CEReactions$, `Reflect$] attribute DOMString `media@mL;
  [`CEReactions$, `Reflect$] attribute DOMString `integrity@mL;
  [`CEReactions$, `Reflect$] attribute DOMString `hreflang@mL;
  [`CEReactions$, `Reflect$] attribute DOMString `type@mL;
  [SameObject, PutForwards=`value$m, `Reflect$] readonly attribute `DOMTokenList$I `sizes@mL;
  [`CEReactions$, `Reflect$] attribute USVString `imageSrcset@mL;
  [`CEReactions$, `Reflect$] attribute DOMString `imageSizes@mL;
  [`CEReactions$] attribute DOMString `referrerPolicy$mL;
  [SameObject, PutForwards=`value$m, `Reflect$] readonly attribute `DOMTokenList$I `blocking@mL;
  [`CEReactions$, `Reflect$] attribute boolean `disabled@mL;
  [`CEReactions$] attribute DOMString `fetchPriority$mL;

  // `HTMLLinkElement$obsMb
};

`HTMLLinkElement$I includes `LinkStyle$I;
</pre>

	</dd>
</dl>

<p>
`link$e 要素により、
作者は，自身の文書から他の資源への~linkをあてがえるようになる。
◎
The link element allows authors to link their document to other resources.
</p>

<p>
`href@aL
属性が，~link（たち）の~addressを与える。
在るならば、
その値は`妥当かつ空でない~URL（前後~空白~可）$でなければナラナイ。
`link$e 要素は、
この属性か `imagesrcset$aL 属性を有していなければナラナイ。
◎
The address of the link(s) is given by the href attribute. If the href attribute is present, then its value must be a valid non-empty URL potentially surrounded by spaces. One or both of the href or imagesrcset attributes must be present.
</p>

<p>
［
`href$aL, `imagesrcset$aL
］両~属性とも無い場合、
当の要素は~linkを定義しない。
◎
If both the href and imagesrcset attributes are absent, then the element does not define a link.
</p>

<p>
`rel@aL
属性の値が，~linkの型（関係性）を指示する。
在るならば、
その値は`~space等で分離された~token集合$（一意）でなければナラナイ。
それを成す各~tokenとして許容される~keyword, それらの意味は、
§ `~HTML~link型$にて定義される。
当の要素が `rel$aL 属性を有さないか, 有するが［
この仕様による定義に則って許容される~keyword
］を一つも含まない場合、
当の要素は~linkを作成しない。
◎
The types of link indicated (the relationships) are given by the value of the rel attribute, which, if present, must have a value that is a unordered set of unique space-separated tokens. The allowed keywords and their meanings are defined in a later section. If the rel attribute is absent, has no keywords, or if none of the keywords used are allowed according to the definitions in this specification, then the element does not create any links.
</p>

<div>
<p>
~AND↓ を満たすものが `rel$aL が`~supportする~token$であるとされる：
</p>
<ul>
	<li>
§ `~HTML~link型$にて定義される~keywordのうち，
`link$e 要素に許容されるものである。
</li>
	<li>
~UAが~supportする。
</li>
	<li>
~UAによる処理~modelに影響iする。
</li>
</ul>

<p>
`~supportする~token$は、
アリなものとして次が挙げられるが，これらのうち~UAが処理~modelを実装するものに限るモノトスル
⇒＃
`alternate$v,
`dns-prefetch$v,
`expect$v,
`icon$v,
`manifest$v,
`modulepreload$v,
`next$v,
`pingback$v,
`preconnect$v,
`prefetch$v,
`preload$v,
`search$v,
`stylesheet$v
</p>

◎
rel's supported tokens are the keywords defined in HTML link types which are allowed on link elements, impact the processing model, and are supported by the user agent. The possible supported tokens are alternate, dns-prefetch, expect, icon, manifest, modulepreload, next, pingback, preconnect, prefetch, preload, search, and stylesheet. rel's supported tokens must only include the tokens from this list that the user agent implements the processing model for.
</div>

<p class="note">注記：
理論的には、
~UAは， `canonical$v ~keyword用の処理~modelも~supportできる
— ~UAが~JSを実行する探索~engineであったなら。
が，そのような実施はまずないので、
ほとんどの事例では，
`canonical$v は `rel$aL が`~supportする~token$に含めるべきでない。
◎
Theoretically a user agent could support the processing model for the canonical keyword — if it were a search engine that executed JavaScript. But in practice that's quite unlikely. So in most cases, canonical ought not be included in rel's supported tokens.
</p>

<p>
`link$e 要素は、［
`rel$aL, `itemprop$a
］属性のうち，片方のみを有していなければナラナイ。
◎
A link element must have either a rel attribute or an itemprop attribute, but not both.
</p>

<div >
<p>
~OR↓ を満たす `link$e 要素は、
`~body内に許容され@
るという
— これは、
`句ng内容$が期待される所で要素を利用できることを意味する：
</p>
<ul>
	<li>
`itemprop$a 属性を有する。
</li>
	<li>
`rel$aL 属性を有していて，
その値は`~body-ok$なる~keywordのみを包含する。
</li>
</ul>

◎
If a link element has an itemprop attribute, or has a rel attribute that contains only keywords that are body-ok, then the element is said to be allowed in the body. This means that the element can be used where phrasing content is expected.
</div>

<p class="note">注記：
要素が `rel$aL 属性を有する場合、
`その値によっては^note
要素が利用できる所が，~pageの `body$e 内に限られる場合もある。
要素が `itemprop$a 属性を有する場合、
要素は ~pageの `head$e 要素~内にも `body$e 内にも利用できるようになり，~microdata~modelによる拘束の~subjectになる。
◎
If the rel attribute is used, the element can only sometimes be used in the body of the page. When used with the itemprop attribute, the element can be used both in the head element and in the body of the page, subject to the constraints of the microdata model.
</p>

<hr>

<p>
`link$e 要素を利用して， 2 種類の~link
— `外部~資源~link$, `~hyperlink$ —
を作成できる。
特定0の~link型がこのどちらになるかは、
§ `~HTML~link型$にて定義される。
1 個の `link$e 要素から，複数個の~linkを作成できる
（それらには、
外部~資源~linkと~hyperlinkを~~混在させられる）。
作成される~linkの正確な個数は、
`rel$aL 属性~内に与えられる~keywordたちに依存する。
~UAは、
その各~linkを，要素ごとにではなく, ~linkごとに処理するモノトスル。
◎
Two categories of links can be created using the link element: links to external resources and hyperlinks. The link types section defines whether a particular link type is an external resource or a hyperlink. One link element can create multiple links (of which some might be external resource links and some might be hyperlinks); exactly which and how many links are created depends on the keywords given in the rel attribute. User agents must process the links on a per-link basis, not a per-element basis.
</p>

<p class="note">注記：
`link$e 要素により作成される各~linkは、
別々に取扱われる。
一例として、
`rel="stylesheet"^c
を伴う 2 個の `link$e 要素がある場合、
【それらが同じ資源を指していようが】
互いに別々な外部~資源として数えられ, 各~要素の自前の属性により独立に影響される。
同様に、
単独の `link$e 要素が `rel$aL 属性を有していて，その値が `next stylesheet^v であれば、
（~keyword `next$v に対する）`~hyperlink$と,
（~keyword `stylesheet$v に対する）`外部~資源~link$
が作成され、
それぞれ，他の属性（ `media$aL や `title$aL など）から~~別々に影響される。
◎
Each link created for a link element is handled separately. For instance, if there are two link elements with rel="stylesheet", they each count as a separate external resource, and each is affected by its own attributes independently. Similarly, if a single link element has a rel attribute with the value next stylesheet, it creates both a hyperlink (for the next keyword) and an external resource link (for the stylesheet keyword), and they are affected by other attributes (such as media or title) differently.
</p>

<div class="example">
<p>
例えば次の `link$e 要素は、
（同じ~pageを指す） 2 個の~hyperlinkを作成する：
◎
For example, the following link element creates two hyperlinks (to the same page):
</p>

`link-1^xCode

<p>
この要素により、
次の意味論を持つ 2 つの~linkが作成される：
`author^v に対しては，~link先の~pageには現在の~pageの作者についての情報があること、
および
`license^v に対しては，現在の~pageが~link先の~pageに与えられる~licenseの下で供されていること。
◎
The two links created by this element are one whose semantic is that the target page has information about the current page's author, and one whose semantic is that the target page has information regarding the license under which the current page is provided.
</p>
</div>

<p>
`link$e 要素とその `rel$aL 属性で作成される各~hyperlinkは、
文書に一体として適用される。
対照的に［
`a$e ／ `area$e
］要素の `rel$a 属性
— それらも~linkの型を指示するが —
の文脈は、
文書の中での当の~linkの所在により与えられる。
◎
Hyperlinks created with the link element and its rel attribute apply to the whole document. This contrasts with the rel attribute of a and area elements, which indicates the type of a link whose context is given by the link's location within the document.
</p>

<p>
`link$e 要素により作成される`~hyperlink$は，［
`a$e ／ `area$e
］要素により作成されるものと違って、
`示唆される既定の具現化を~supportする~UA＠~HTMLINFRA#renderingUA$においては，
既定では文書の一部として表示されず、
~CSSを利用して表示するよう強制されても，`作動化の挙動$は無い。
それらは代わりに、
首に［
当の~page, あるいは その内容を消費する他の~software
］から利用され得る意味論上の情報を供する。
加えて，~UAは、
そのような
`~hyperlinkを追うための自前の~UIを供せる＠#providing-users-with-a-means-to-follow-hyperlinks-created-using-the-link-element$
。
◎
Unlike those created by a and area elements, hyperlinks created by link elements are not displayed as part of the document by default, in user agents that support the suggested default rendering. And even if they are force-displayed using CSS, they have no activation behavior. Instead, they primarily provide semantic information which might be used by the page or by other software that consumes the page's contents. Additionally, the user agent can provide its own UI for following such hyperlinks.
</p>

<p>
外部~資源~linkの正確な挙動は、
関連な~link型に定義される正確な関係性に依存する。
◎
The exact behavior for links to external resources depends on the exact relationship, as defined for the relevant link type.
</p>

<hr>

<p>
`crossorigin@aL
属性は、
`~CORS設定群~属性$であり，外部~資源~link用に意図される。
◎
The crossorigin attribute is a CORS settings attribute. It is intended for use with external resource links.
</p>

<p>
`media@aL
属性は、
資源がどの媒体に適用されるかを述べる。
その値は、
`妥当な媒体~query~list$でなければナラナイ。
◎
The media attribute says which media the resource applies to. The value must be a valid media query list.
</p>

<p>
`integrity@aL
属性は、［
この要素が担当する要請
］の`完全性~metadata$rq `SRI$r を表現する。
値は~textである。
この属性は、
次を満たさない `link$e 要素には，指定してはナラナイ
⇒
`rel$aL 属性を有していて，その値は［
`stylesheet$v ／ `preload$v ／ `modulepreload$v
］~keywordを包含する。
◎
The integrity attribute represents the integrity metadata for requests which this element is responsible for. The value is text. The attribute must only be specified on link elements that have a rel attribute that contains the stylesheet, preload, or modulepreload keyword. [SRI]
</p>

<p>
`link$e 要素の
`hreflang@aL
属性の意味論は、
`a$e 要素の `hreflang$a 属性と同じである。
◎
The hreflang attribute on the link element has the same semantics as the hreflang attribute on the a element.
</p>

<p>
`type@aL
属性は、
~link先の資源の`~MIME型$を与える
— この属性は：
◎
The type attribute gives the MIME type of the linked resource.＼
</p>

<ul>
	<li>
純粋に助言的である。
◎
It is purely advisory.＼
</li>
	<li>
指定する値は、
`妥当な~MIME型~文字列$でなければナラナイ。
◎
The value must be a valid MIME type string.
</li>
	<li>
`外部~資源~link$に対しては、
その値は，~UAへの~hintとして利用され、
~UAが~supportしない資源に対し，その~fetchingを避けれるようにする。
◎
For external resource links, the type attribute is used as a hint to user agents so that they can avoid fetching resources they do not support.
</li>
</ul>

<p>
`referrerpolicy@aL
属性は、
`~referrer施策~属性$であり，外部~資源~link用に意図される。
それは、［
`~link先の資源を~fetchして処理する$際に利用する`~referrer施策$
］を設定し易くするためにある。
`REFERRERPOLICY$r
◎
The referrerpolicy attribute is a referrer policy attribute. It is intended for use with external resource links, where it helps set the referrer policy used when fetching and processing the linked resource. [REFERRERPOLICY]
</p>

<p>
`title@aL
属性は、
~linkの~titleを与える。
値は~textである。
この属性は、
純粋に助言的である
— ただし，`文書~tree内$にある~stylesheet~linkに対しては、
この属性は `~CSS~stylesheet集合$を定義する。
◎
The title attribute gives the title of the link. With one exception, it is purely advisory. The value is text. The exception is for style sheet links that are in a document tree, for which the title attribute defines CSS style sheet sets.
</p>

<p class="note">注記：
`title$aL 属性を有さない `link$e 要素は、
親~要素の~titleを継承しない
— 要素による~linkは、
単に~titleを持たなくなる。
この `title$aL 属性は、
この点で，他のほとんどの要素の大域~属性である `title$a 属性から相違する。
◎
The title attribute on link elements differs from the global title attribute of most other elements in that a link without a title does not inherit the title of the parent element: it merely has no title.
</p>

<hr>

<p>
`imagesrcset@aL
属性は、
`~srcset属性$である。
在るならば、
`href$aL 属性とともに，`~source集合$に`画像~source$を供与する
（`横幅~記述子$を利用していないならば）。
◎
The imagesrcset attribute may be present, and is a srcset attribute.
◎
The imagesrcset and href attributes (if width descriptors are not used) together contribute the image sources to the source set.
</p>

<p>
`imagesizes@aL
属性は、
`~sizes属性$であり，`~source集合$に`~source~size$を供与する。
この属性は、
次を満たす `link$e 要素には，指定しなければナラナイ
⇒
`imagesrcset$aL 属性を有していて，その値は［
`横幅~記述子$を利用している`画像~候補~文字列$
］である
◎
If the imagesrcset attribute is present and has any image candidate strings using a width descriptor, the imagesizes attribute must also be present, and is a sizes attribute. The imagesizes attribute contributes the source size to the source set.
</p>

<p>
［
`imagesrcset$aL ／ `imagesizes$aL
］属性は、
次を満たさない `link$e 要素には，指定してはナラナイ
⇒
［
`rel$aL 属性を有していて，その値は `preload$v ~keywordを指定している
］~AND［
`as$aL 属性の状態 ~EQ `image^l 
］
◎
The imagesrcset and imagesizes attributes must only be specified on link elements that have both a rel attribute that specifies the preload keyword, as well as an as attribute in the "image" state.
</p>

<div class="example">
<p>
これらの属性は、［
`img$e 要素のうち［
`srcset$a, `sizes$a
］属性~用に対応する値を有するもの
］により［
後で利用される適切な資源を~preloadする
］ことを許容する：
◎
These attributes allow preloading the appropriate resource that is later used by an img element that has the corresponding values for its srcset and sizes attributes:
</p>

`link-2^xCode

<p>
`href$aL 属性は省略されていることに注意
— それが関連するのは， `imagesrcset$aL を~supportしない~browser用に限られ、
そのような事例では，不正な画像を~preloadさせる見込みが高い。
◎
Note how we omit the href attribute, as it would only be relevant for browsers that do not support imagesrcset, and in those cases it would likely cause the incorrect image to be preloaded.
</p>
</div>

<div class="example">
<p>
`imagesrcset$aL 属性を `media$aL 属性と組合せれば、
`~art-direction$用に，［
`picture$e 要素の~sourceから選定される適切な資源
］を~preloadできる：
◎
The imagesrcset attribute can be combined with the media attribute to preload the appropriate resource selected from a picture element's sources, for art direction:
</p>

`link-3^xCode
</div>

<hr>

<p>
`sizes@aL
属性は、
視覚-媒体~用の~iconの~sizeたちを与える
— この属性は：
◎
The sizes attribute gives the sizes of icons for visual media.＼
</p>

<ul>
	<li>
在るとしても、
その値は助言的でしかない。
◎
Its value, if present, is merely advisory.＼
</li>
	<li>
~UAは、
複数個の~iconが可用なときは，その値を利用して利用する~icon（たち）を決めてもヨイ。
◎
User agents may use the value to decide which icon(s) to use if multiple icons are available.＼
</li>
	<li>
<p>
指定する値は、
`~space等で分離された~token集合$（大小無視で一意）であって，
それを成す各~tokenは ~OR↓ を満たしていなければナラナイ：
◎
If specified, the attribute must have a value that is an unordered set of unique space-separated tokens which are ASCII case-insensitive. Each value must be either＼
</p>
		<ul>
			<li>
`~ASCII大小無視$で文字列 `any$v に合致する
◎
an ASCII case-insensitive match for the string "any", or＼
</li>
			<li>
<p>
次を満たす文字列［
%w, %x, %h
］が成す並びである：
</p>
				<ul>
					<li>
%w, %h は、
どちらも，次を満たす
⇒
［
`妥当な負でない整数$である
］~AND［
最初の文字 ~NEQ ❝0
］
</li>
					<li>
%x ~IN { ❝x, ❝X }
</li>
				</ul>
◎
a value that consists of two valid non-negative integers that do not have a leading U+0030 DIGIT ZERO (0) character and that are separated by a single U+0078 LATIN SMALL LETTER X or U+0058 LATIN CAPITAL LETTER X character.＼
</li>
		</ul>
	</li>
	<li>
<p>
次を満たさない `link$e 要素には，指定してはナラナイ
⇒
`rel$aL 属性を有していて，その値は［
`icon$v ／ `apple-touch-icon^v
］~keywordを指定している
◎
The attribute must only be specified on link elements that have a rel attribute that specifies the icon keyword or the apple-touch-icon keyword.
</p>

<p class="note">注記：
`apple-touch-icon^v ~keywordは，`定義済み~link型の集合に対する拡張$に登録されてはいるが、
~UAには，その~supportは要求されない。
◎
The apple-touch-icon keyword is a registered extension to the predefined set of link types, but user agents are not required to support it in any way.
</p>
	</li>
</ul>

<hr>

<p>
`as@aL
属性は、［
`href$aL 属性に所与の資源
］に対する~preload要請~用の`行先の素$ `FETCH$r を指定する。
この属性は、
`列挙d属性$である
— 各 `行先の素$は、
この属性~用の~keywordを与え，同じ名前の状態に対応付けられる。
この属性は、
当の `link$e 要素が：
◎
The as attribute specifies the potential destination for a preload request for the resource given by the href attribute. It is an enumerated attribute. Each potential destination is a keyword for this attribute, mapping to a state of the same name.＼
</p>
<ul>
	<li>
次を満たすならば、
指定しなければナラナイ
⇒
`rel$aL 属性を有していて，その値は `preload$v ~keywordを包含する
◎
The attribute must be specified on link elements that have a rel attribute that contains the preload keyword.＼
</li>
	<li>
次を満たすならば、
指定してもヨイ
— この事例では、
その値は`~scriptに類する行先$でなければナラナイ
⇒
`rel$aL 属性を有していて，その値は `modulepreload$v ~keywordを包含する
◎
It may be specified on link elements that have a rel attribute that contains the modulepreload keyword; in such cases it must have a value which is a script-like destination.＼
</li>
	<li>
他の場合、
指定してはナラナイ。
◎
For other link elements, it must not be specified.
</li>
</ul>

<p>
`as$aL 属性がどう利用されるかの処理~modelは、
個々の~link型の［
`~link先の資源を~fetchして処理する$
］~algoにて与えられる。
◎
The processing model for how the as attribute is used is given in an individual link type's fetch and process the linked resource algorithm.
</p>

<p>
`as$aL 属性の［
`欠落~値~用の既定の状態$, `妥当でない値~用の既定の状態$
］は、
いずれも ε とする。
◎
The attribute does not have a missing value default or invalid value default, meaning that invalid or missing values for the attribute map to no state.＼
</p>

<div class="note">
<p>注記：
状態 ε は、
処理~modelに織り込まれる：
◎
This is accounted for in the processing model.＼
</p>
<ul>
	<li>
`preload$v ~link用には、
ε は~errorになる。
◎
For preload links, both conditions are an error;＼
</li>
	<li>
`modulepreload$v ~link用には、
欠落~値による ε は `script^l として扱われる。
◎
for modulepreload links, a missing value will be treated as "script".
</li>
</ul>
</div>

<hr>

<p>
`blocking@aL
属性は、
`他を阻む属性$であり，
~link型［
`stylesheet$v ／ `expect$v
］により利用される。
この属性は、
次を満たさない `link$e 【！~link】要素には，指定してはナラナイ
⇒
`rel$aL 属性を有していて，
その値は これらいずれかの~keywordを包含する
◎
The blocking attribute is a blocking attribute. It is used by link types stylesheet and expect, and it must only be specified on link elements that have a rel attribute containing those keywords.
</p>

<hr>

<p>
`color@aL
属性は、
~link型 `mask-icon^v と併用される。
この属性は：
◎
The color attribute is used with the mask-icon link type.＼
</p>

<ul>
	<li>
次を満たさない `link$e 要素には，指定してはナラナイ
⇒
`rel$aL 属性を有していて，その値は `mask-icon^v ~keywordを包含する
◎
The attribute must only be specified on link elements that have a rel attribute that contains the mask-icon keyword.＼
</li>
	<li>
その値は、
~CSS `color$t 生成規則に合致する文字列でなければナラナイ。
◎
The value must be a string that matches the CSS &lt;color&gt; production,＼
</li>
	<li>
その値は、［
次の表示を~custom化するとき，~UAが利用できる色
］として示唆するものを定義する
⇒
利用者が、
当の~siteをどこかに留めた（ `pin^en した）ときに見ることになる~icon
◎
defining a suggested color that user agents can use to customize the display of the icon that the user sees when they pin your site.
</li>
</ul>

<p class="note">注記：
この仕様は、
~UAに対しては，
`color$aL 属性~用の要件は何も課さない。
◎
This specification does not have any user agent requirements for the color attribute.
</p>

<p class="note">注記：
~keyword `mask-icon^v は、
`定義済み~link型の集合に対する拡張$に登録されてはいるが、
~UAには，その~supportは要求されない。
◎
The mask-icon keyword is a registered extension to the predefined set of link types, but user agents are not required to support it in any way.
</p>

<hr>

<p>
各 `link$e 要素には、
真偽値をとる
`明示的に可能化されるか@
が結付けられ，初期~時は ~F とする。
◎
link elements have an associated explicitly enabled boolean. It is initially false.
</p>

<p>
`disabled@aL
属性は、
`真偽-属性$であり，
~link型 `stylesheet$v と伴に利用される。
この属性は、
次を満たさない `link$e 要素には，指定してはナラナイ
⇒
`rel$aL 属性を有していて，その値は `stylesheet$v ~keywordを包含する
◎
The disabled attribute is a boolean attribute that is used with the stylesheet link type. The attribute must only be specified on link elements that have a rel attribute that contains the stylesheet keyword.
</p>

<p>
`link$e 要素 %link の `disabled$aL 属性が除去されたときは
⇒
%link の`明示的に可能化されるか$ ~SET ~T
◎
Whenever the disabled attribute is removed, set the link element's explicitly enabled attribute to true.
</p>

<div class="example">
<p>
`disabled$aL 属性を動的に除去すれば
（例：
`document.querySelector("link").removeAttribute("disabled")^c
を利用して）、
~stylesheetを~fetchして適用することになる：
◎
Removing the disabled attribute dynamically, e.g., using document.querySelector("link").removeAttribute("disabled"), will fetch and apply the style sheet:
</p>

`link-4^xCode
</div>

<p>
`fetchpriority@aL
属性は、
`~fetch優先度~属性$であり，
`外部~資源~link$と伴に利用することが意図される
— そこでは、［
`~link先の資源を~fetchして処理する$ときに利用される`優先度$rq
］を設定するために利用される。
◎
The fetchpriority attribute is a fetch priority attribute that is intended for use with external resource links, where it is used to set the priority used when fetching and processing the linked resource.
</p>

<hr>

<p class="note">注記：
`color$aL 属性を反映する~IDL属性は無いが、
後で追加されるかもしれない。
◎
There is no reflecting IDL attribute for the color attribute, but this might be added later.
</p>

<p>
`as@mL
~IDL属性は、
`既知な値のみに制限される$下で，
`as$aL 内容~属性を`反映する$モノトスル。
◎
The as IDL attribute must reflect the as content attribute, limited to only known values.
</p>

<p>
`crossOrigin@mL
~IDL属性は、
`既知な値のみに制限される$下で，
`crossorigin$aL 内容~属性を`反映する$モノトスル。
◎
The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.
</p>

<p>
`referrerPolicy@mL
~IDL属性は、
`既知な値のみに制限される$下で，
`referrerpolicy$aL 内容~属性を`反映する$モノトスル。
◎
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</p>

<p>
`fetchPriority@mL
~IDL属性は、
`既知な値のみに制限される$下で，
`fetchpriority$aL 内容~属性を`反映する$モノトスル。
◎
The fetchPriority IDL attribute must reflect the fetchpriority content attribute, limited to only known values.
</p>

<p class="note">注記：
`relList$mL 属性は、
特能~検出~用に利用できる
— その `supports()$m ~methodを~callして，どの`~HTML~link型$が~supportされるか検査することにより。
◎
The relList attribute can be used for feature detection, by calling its supports() method to check which types of links are supported.
</p>

				<section id="processing-the-media-attribute">
<h5 title="Processing the media attribute">4.2.4.1. `media^aL 属性の処理</h5>

<p>
`media$aL 属性は、
当の~linkが：
◎
↓</p>
<ul>
	<li>
`~hyperlink$である場合、
純粋に助言的であり，~link先の文書が どの媒体~用に設計されていたかを述べる。
◎
If the link is a hyperlink then the media attribute is purely advisory, and describes for which media the document in question was designed.
</li>
	<li>
`外部~資源~link$である場合、
~~規範的になる。
~UAは、［
この属性の値が`環境に合致して$いて, かつ関連な他の条件にも該当する
］ときは，外部~資源を適用し、
他の場合は適用しないモノトスル。
◎
However, if the link is an external resource link, then the media attribute is prescriptive. The user agent must apply the external resource when the media attribute's value matches the environment and the other relevant conditions apply, and must not apply it otherwise.
</li>
</ul>

<p id="default-media">
`media$aL 属性が省略された場合の既定は `all^l であり、
その~linkは既定で すべての媒体に適用されることを意味する。
◎
The default, if the media attribute is omitted, is "all", meaning that by default links apply to all media.
</p>

<p class="note">注記：
外部~資源には、
その適用能を制限するような更なる制約も定義され得る。
例えば，~CSS~stylesheetは、
`media^at ~blockを有することもある。
この仕様は、
そのような更なる制約や要件は，上書きしない。
◎
The external resource might have further restrictions defined within that limit its applicability. For example, a CSS style sheet might have some @media blocks. This specification does not override such further restrictions or requirements.
</p>

				</section>
				<section id="processing-the-type-attribute">
<h5 title="Processing the type attribute">4.2.4.2. `type^aL 属性の処理</h5>

<div class="algo">
<p>
`type$aL 属性に対しては、
~UAは，次に従って処理するモノトスル：
◎
If the type attribute is present, then the user agent must＼
</p>

<ol>
	<li>
<p>
資源の型 %型 を［
`type$aL 属性が在るかどうかに応じて，次に与える型
］と見做す：
</p>
		<ul class="switch">
			<li>
在る場合
⇒
属性の値が与える型
（空~文字列など，それが`妥当な~MIME型~文字列$でない場合でも）。
</li>
			<li>
無い場合
⇒＃
外部~資源~link型に既定の型が定義されているならば，その既定の型 ／
~ELSE_ `未知^i
</li>
		</ul>
◎
assume that the resource is of the given type (even if that is not a valid MIME type string, e.g. the empty string). If the attribute is omitted, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type.＼
</li>
	<li>
<p>
%型 ~NEQ `未知^i の場合、
~UAが %型 を~supportするかどうかに応じて：
</p>
		<ul class="switch">
			<li>
~supportしない場合
⇒
~UAは、
`~link先の資源を~fetchして処理する$ベキではない。
</li>
			<li>
~supportする場合
⇒
~UAは、
%型 により指定される適切な時点に，`~link先の資源を~fetchして処理する$ベキである。
【！の特定0の型に対し】
</li>
		</ul>
◎
If the UA does not support the given MIME type for the given link relationship, then the UA should not fetch and process the linked resource; if the UA does support the given MIME type for the given link relationship, then the UA should fetch and process the linked resource at the appropriate time as specified for the external resource link's particular type.＼
</li>
	<li>
%型 ~EQ `未知^i の場合、［
仮に，~UAが %型 を~supportするとした場合には、
`~link先の資源を~fetchして処理する$ことになる
］ならば
⇒
~UAは、
資源の実際の型も~supportすることになると見做して，`~link先の資源を~fetchして処理する$ベキである。
◎
If the attribute is omitted, and the external resource link type does not have a default type defined, but the user agent would fetch and process the linked resource if the type was known and supported, then the user agent should fetch and process the linked resource under the assumption that it will be supported.
</li>
</ol>
</div>

<p>
~UAは、
実際の型を決定するときには，
`type$aL 属性を
— ［
それは、
資源の実際の型を与えるとは限らない【！authoritative】
］と見なして —
利用しないモノトスル。
資源を`適用する^emかどうか決定するときには、
前述した見做された型ではなく，次に定義する実際の型のみを利用すること。
◎
User agents must not consider the type attribute authoritative — upon fetching the resource, user agents must not use the type attribute to determine its actual type. Only the actual type (as defined in the next paragraph) is used to determine whether to apply the resource, not the aforementioned assumed type.
</p>

<div class="algo">
<p id="concept-link-type-sniffing">
~UAは、
資源の実際の型を次に従って決定するモノトスル：
◎
↓</p>
<ol>
	<li>
<p>
~IF［
外部~資源~link型に，
資源の`~Content-Type~metadata$を処理する規則が定義されている
］
⇒
~RET その規則を適用した結果の型
</p>

<p class="trans-note">【
したがって、
そのような規則は，~Content-Type~metadataが無い場合も受持つことになろう
（ “既定の型” など）。
】</p>
◎
If the external resource link type defines rules for processing the resource's Content-Type metadata, then those rules apply.＼
</li>
	<li>
<p>
~IF［
資源は画像であると期待される
］
⇒
任意選択で
⇒
~RET `画像を特定的に~sniffするための規則$を
— 資源の`~Content-Type~metadata$から決定される型を `official type^V 【おそらく，`給された~MIME型$】として —
適用することにより`算出される~MIME型$
◎
Otherwise, if the resource is expected to be an image, user agents may apply the image sniffing rules, with the official type being the type determined from the resource's Content-Type metadata, and use the resulting computed type of the resource as if it was the actual type.＼
</li>
	<li>
~IF［
資源には`~Content-Type~metadata$が在る
］
⇒
~RET それ利用して決定される型
◎
Otherwise, if neither of these conditions apply or if the user agent opts not to apply the image sniffing rules, then the user agent must use the resource's Content-Type metadata to determine the type of the resource.＼
</li>
	<li>
~IF［
外部~資源~link型に，既定の型が定義されている
］
⇒
~RET その型
◎
If there is no type metadata, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type.
</li>
	<li>
【この段に達した場合、下の記述に従って，資源を無視することになる。】
</li>
</ol>
</div>

<p class="note">注記：
`stylesheet$v ~link型については、
資源の`~Content-Type~metadata$を処理するための規則が定義されている。
◎
The stylesheet link type defines rules for processing the resource's Content-Type metadata.
</p>

<p>
資源の型が確立されたなら、
~UAは［
その型を~supportする, かつ
関連な他の条件にも該当する
］ならば，資源を適用するモノトスル。
他の場合，その資源を無視するモノトスル。
◎
Once the user agent has established the type of the resource, the user agent must apply the resource if it is of a supported type and the other relevant conditions apply, and must ignore the resource otherwise.
</p>

<div class="example">
<p>
文書が次のような~stylesheet~linkを包含する場合：
◎
If a document contains style sheet links labeled as follows:
</p>

`link-stylesheet-1^xCode

<p>
~CSS~stylesheetのみを~supportする準拠~UAは、
~file B, C を~fetchして，~file A は飛ばすことになる
（ `text/plain$c は、
~CSS~stylesheet用の`~MIME型$ではないので）。
◎
...then a compliant UA that supported only CSS style sheets would fetch the B and C files, and skip the A file (since text/plain is not the MIME type for CSS style sheets).
</p>

<p>
次に、
~file B, C に対し，~serverから返された実際の型を検査することになる。
それらのうち
`text/css$c として送信されたものに対しては，~styleを適用する一方で、
`text/plain$c など他の型に対しては，適用しないことになる。
◎
For files B and C, it would then check the actual types returned by the server. For those that are sent as text/css, it would apply the styles, but for those labeled as text/plain, or any other type, it would not.
</p>

<p>
返された~fileのうち，`~Content-Type~metadata$を［
伴わないもの ／
伴うが構文上は不正な型であるもの
（例： `Content-Type:&nbsp;"null"^c ）
］は、
`stylesheet$v ~link用の既定の型 `text/css$c に~~落とし込まれ、
いずれにせよ，~stylesheetは`適用される^emことになる。
◎
If one of the two files was returned without a Content-Type metadata, or with a syntactically incorrect type like Content-Type: "null", then the default type for stylesheet links would kick in. Since that default type is text/css, the style sheet would nonetheless be applied.
</p>
</div>

				</section>
				<section id="fetching-and-processing-a-resource-from-a-link-element">
<h5 title="Fetching and processing a resource from a link element">4.2.4.3. `link^e 要素から資源を~fetchして処理する</h5>

<p id="concept-link-obtain">
すべての`外部~資源~link$には、
`~link先の資源を~fetchして処理する@
~algoがあり，
( `link$e 要素 )
が渡される。
また、
`~link先の資源~fetch用に設定しておく@
~algoもあり，
( `link$e 要素, `要請$ )
が渡される。
個々の~link型には，自前の`~link先の資源を~fetchして処理する$
~algoを供するものもあるが、
明示的に言明されない限り，`~link先の資源を~fetchして処理する既定の~algo$を利用する。
同様に，個々の~link型には，自前の`~link先の資源~fetch用に設定しておく$
~algoを供するものもあるが、
明示的に言明されない限り，その手続きは単に ~T を返すとする。
◎
All external resource links have a fetch and process the linked resource algorithm, which takes a link element el. They also have linked resource fetch setup steps which take a link element el and request request. Individual link types may provide their own fetch and process the linked resource algorithm, but unless explicitly stated, they use the default fetch and process the linked resource algorithm. Similarly, individual link types may provide their own linked resource fetch setup steps, but unless explicitly stated, these steps just return true.
</p>

<div class="algo">
<p>
`~link先の資源を~fetchして処理する既定の~algo@
は、
所与の
( `link$e 要素 %link )
に対し，以下に従う：
◎
The default fetch and process the linked resource, given a link element el, is as follows:
</p>
<ol>
	<li>
%~option群 ~LET `要素から~link~option群を作成する$( %link )
◎
Let options be the result of creating link options from el.
</li>
	<li>
%要請 ~LET `~link要請を作成する$( %~option群 )
◎
Let request be the result of creating a link request given options.
</li>
	<li>
~IF［
%要請 ~EQ ~NULL
］
⇒
~RET
◎
If request is null, then return.
</li>
	<li>
%要請 の`同期~flag$rq ~SET ~T
◎
Set request's synchronous flag.
</li>
	<li>
~IF［
`~link先の資源~fetch用に設定しておく$( %link, %要請 ) ~EQ ~F
］
⇒
~RET
◎
Run the linked resource fetch setup steps, given el and request. If the result is false, then return.
</li>
	<li>
%要請 の`起動元~種別$rq ~SET ［
次が満たされるならば `css^l ／
~ELSE_ `link^l
］
⇒
%link は `rel$aL 属性を有していて，その値は~keyword `stylesheet$v を包含する
◎
Set request's initiator type to "css" if el's rel attribute contains the keyword stylesheet; "link" otherwise.
</li>
	<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request with＼
</p>
		<ul>
			<li class="algo">
<p>
`応答の本体を消費する処理n$i ~SET 所与の
( `応答$ %応答, ［
~NULL ／ `失敗^i ／ `~byte列$
］ %本体~byte列 )
に対し，次を走らす手続き：
◎
processResponseConsumeBody set to the following steps given response response and null, failure, or a byte sequence bodyBytes:
</p>
				<ol>
					<li>
%成功か ~LET ~T
◎
Let success be true.
</li>
					<li>
<p>
~IF［
%本体~byte列 ~IN { ~NULL, `失敗^i }
］~OR［
%応答 の`状態s$rs は`~ok状態s$でない
］
⇒
%成功か ~SET ~F
◎
If any of the following are true:
• bodyBytes is null or failure; or
• response's status is not an ok status,
then set success to false.
</p>

<p class="note">注記：
内容に特有な~error
— 例：~CSS構文解析-時や~PNG復号-時の~errorなど —
は、
%成功か には影響しない。
◎
Note that content-specific errors, e.g., CSS parse errors or PNG decoding errors, do not affect success.
</p>
					</li>
					<li>
<p>
~ELSE
⇒
`外部~資源~link$の`必須な下位資源$が読込ngを完遂するまで待機する
◎
Otherwise, wait for the link resource's critical subresources to finish loading.
</p>

<p class="XXX">
~link型の`必須な下位資源$を定義する仕様（例：~CSS）には、［
これらの下位資源がどう~fetchされ, 処理されるか述べる
］ものと期待される。
しかしながらこれは，現時点では明示的でないので、
この仕様は，［
`外部~資源~link$の`必須な下位資源$が~fetchされ処理されるのを待機して，それが正しく行われる
］ものとしか述べない。
◎
The specification that defines a link type's critical subresources (e.g., CSS) is expected to describe how these subresources are fetched and processed. However, since this is not currently explicit, this specification describes waiting for a link resource's critical subresources to be fetched and processed, with the expectation that this will be done correctly.
</p>
					</li>
					<li>
`~link先の資源を処理する$( %link, %成功か, %応答, %本体~byte列 )
◎
Process the linked resource given el, success, response, and bodyBytes.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~link要請を作成する@
~algoは、
所与の
( `~link処理~option群$ %~option群 )
に対し：
◎
To create a link request given a link processing options options:
</p>
<ol>
	<li>
~Assert：
%~option群 の `href$lO ~NEQ 空~文字列
◎
Assert: options's href is not the empty string.
</li>
	<li>
<p>
%~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( %~option群 の `href$lO, %~option群 の`基底~URL$lO )
◎
Let url be the result of encoding-parsing a URL given options's href, relative to options's base URL.
</p>

<p class="XXX">
［
文書／環境
］の代わりに基底~URLを渡しているが、
それは，`課題 #9715＠~HTMLissue/9715$ にて追跡される。
◎
Passing the base URL instead of a document or environment is tracked by issue #9715.
</p>
	</li>
	<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If url is failure, then return null.
</li>
	<li>
%要請 ~LET `~CORSになり得る要請を作成する$( %~URL, %~option群 の`行先$lO, %~option群 の`~CORS状態$lO )
◎
Let request be the result of creating a potential-CORS request given url, options's destination, and options's crossorigin.
</li>
	<li>
%要請 の
⇒＃
`施策~容器$rq ~SET %~option群 の`施策~容器$lO,
`完全性~metadata$rq ~SET %~option群 の`完全性~metadata$lO,
`暗号用~nonce~metadata$rq ~SET %~option群 の`暗号用~nonce~metadata$lO,
`~referrer施策$rq ~SET %~option群 の`~referrer施策$lO,
`~client$rq ~SET %~option群 の`環境$lO,
`優先度$rq ~SET %~option群 の`~fetch優先度$lO
◎
Set request's policy container to options's policy container.
◎
Set request's integrity metadata to options's integrity.
◎
Set request's cryptographic nonce metadata to options's cryptographic nonce metadata.
◎
Set request's referrer policy to options's referrer policy.
◎
Set request's client to options's environment.
◎
Set request's priority to options's fetch priority.
</li>
	<li>
~RET %要請
◎
Return request.
</li>
</ol>
</div>

<p>
~UAは、
そのような資源を，［
必要なときに限り，
`~fetchして処理-＠#fetch-and-process-the-linked-resource$しようと試行する
］ことにしてもヨイ
— 適用されていないものも含め，すべての`外部~資源~link$を事前に~fetchする代わりに。
◎
User agents may opt to only try to fetch and process such resources when they are needed, instead of pro-actively fetching all the external resources that are not applied.
</p>

<p>
`~link先の資源を~fetchして処理する$
~algoと類似に、
すべての`外部~資源~link$には
`~link先の資源を処理する@
~algoがあり，
( `link$e 要素, 真偽値, `応答$, `~byte列$【！bodyBytes】 )
が渡される。
個々の~link型は，自前の~algoを`~link先の資源を処理する$ためとして供してもヨイが、
明示的に言明されない限り，この~algoは何もしない。
◎
Similar to the fetch and process the linked resource algorithm, all external resource links have a process the linked resource algorithm which takes a link element el, boolean success, a response response, and a byte sequence bodyBytes. Individual link types may provide their own process the linked resource algorithm, but unless explicitly stated, that algorithm does nothing.
</p>

<p>
`rel$aL に与えられた~keyword用に他が指定されない限り，要素の`~node文書$に対する~load~eventは、
要素による`~link先の資源を~fetchして処理する$試み, および その`必須な下位資源$がすべて完了するまで，`遅延-$されるモノトスル。
（~UAがまだ~fetchして処理しようと試みていない資源
— 例えば 資源が必要になるまで待機しているためなど —
により、
~load~eventが`遅延-$されることはない。）
◎
Unless otherwise specified for a given rel keyword, the element must delay the load event of the element's node document until all the attempts to fetch and process the linked resource and its critical subresources are complete. (Resources that the user agent has not yet attempted to fetch and process, e.g., because it is waiting for the resource to be needed, do not delay the load event.)
</p>

				</section>
				<section id="processing-link-headers">
<h5 title="Processing Link headers">4.2.4.4. `Link^h ~headerの処理</h5>

<p>
各~link型のうち，`外部~資源~link$になり得るものは、
`~link~headerを処理する手続き@
を定義する。
この~algoは、
`~link処理~option群$をとり，
~HTTP `Link$h 応答~header内に当の~link型が現れたとき［
反応するかどうか, どう反応するか
］を定義する。
◎
All link types that can be external resource links define a process a link header algorithm, which takes a link processing options. This algorithm defines whether and how they react to appearing in an HTTP `Link` response header.
</p>

<p class="note">注記：
この~algoは、
ほとんどの~link型に対しては何もしない。
`要約~表t＠~HTMLlinks#table-link-relations$が，［
どの~link型に`~link~headerを処理する手続き$が定義されたか
］を素早く知る良い参照を与える。
◎
For most link types, this algorithm does nothing. The summary table is a good reference to quickly know whether a link type has defined process a link header steps.
</p>

<p>
`~link処理~option群@
は、
`構造体$であり，次に挙げる`~item$sctからなる：
◎
A link processing options is a struct. It has the following items:
</p>
<ul>
	<li>
`href@lO
⇒
ある文字列
（既定は空~文字列）
◎
href (default the empty string)
</li>
	<li>
`起動元@lO
⇒
ある文字列
（既定は `link^l ）
◎
initiator (default "link")
</li>
	<li>
`完全性~metadata@lO
⇒
ある文字列
（既定は空~文字列）
◎
integrity (default the empty string)
</li>
	<li>
`~MIME型@lO
⇒
ある文字列
（既定は空~文字列）
◎
type (default the empty string)
</li>
	<li>
`暗号用~nonce~metadata@lO
⇒
ある文字列
（既定は空~文字列）
◎
cryptographic nonce metadata (default the empty string)
• A string
</li>
	<li>
`行先@lO
⇒
ある`行先~種別$
（既定は空~文字列）
◎
destination (default the empty string)
• A destination type.
</li>
	<li>
`~CORS状態@lO
⇒
`~CORS設定群~属性$がとり得る状態
（既定は `~CORSなし$st ）
◎
crossorigin (default No CORS)
• A CORS settings attribute state
</li>
	<li>
`~referrer施策@lO
⇒
ある`~referrer施策$
（既定は空~文字列）
◎
referrer policy (default the empty string)
• A referrer policy
</li>
	<li>
`~source集合@lO
⇒
~NULL ／ある`~source集合$
（既定は ~NULL ）
◎
source set (default null)
• Null or a source set
</li>
	<li>
`基底~URL@lO
⇒
ある`~URL$
◎
base URL
• A URL
</li>
	<li>
`生成元@lO
⇒
ある`生成元$
◎
origin
• An origin
</li>
	<li>
`環境@lO
⇒
ある`環境$
◎
environment
• An environment
</li>
	<li>
`施策~容器@lO
⇒
ある`施策~容器$
◎
policy container
• A policy container
</li>
	<li>
`文書@lO
⇒
~NULL ／ある`文書$
（既定は ~NULL ）
◎
document (default null)
• Null or a Document
</li>
	<li>
`文書~準備済み時の手続き@lO
⇒
~NULL ／［
`文書$を受容する ある~algo
］
（既定は ~NULL ）
◎
on document ready (default null)
• Null or an algorithm accepting a Document
</li>
	<li>
`~fetch優先度@lO
⇒ 
`~fetch優先度~属性$がとり得る状態
（既定は`自動$st）
◎
fetch priority (default Auto)
• A fetch priority attribute state
</li>
</ul>

<p class="note">注記：
`~link処理~option群$が，構文解析された~URLではなく［
`基底~URL$lO, `href$lO
］を伴うのは、
~option群の`~source集合$lOの結果が~URLを成すこともあるからである。
◎
A link processing options has a base URL and an href rather than a parsed URL because the URL could be a result of the options's source set.
</p>

<div class="algo">
<p>
`要素から~link~option群を作成する@
~algoは、
所与の
( `link$e 要素 %link )
に対し：
◎
To create link options from element given a link element el:
</p>
<ol>
	<li>
%文書 ~LET %link の`~node文書$
◎
Let document be el's node document.
</li>
	<li>
%~option群 ~LET 新たな`~link処理~option群$
— その
⇒＃
`~CORS状態$lO ~SET %link の `crossorigin$aL 内容~属性の状態,
`~referrer施策$lO ~SET %link の `referrerpolicy$aL 内容~属性の状態,
`~source集合$lO ~SET %link の`~source集合$,
`基底~URL$lO ~SET `文書~基底~URL$( %文書 ),
`生成元$lO ~SET %文書 の`生成元$doc,
`環境$lO ~SET %文書 に`関連な設定群~obj$,
`施策~容器$lO ~SET %文書 の`施策~容器$doc,
`文書$lO ~SET %文書,
`暗号用~nonce~metadata$lO ~SET %link の `CryptographicNonce$sl 内部~slotの現在の値,
`~fetch優先度$lO ~SET %link の `fetchpriority$aL 内容~属性の状態
◎
Let options be a new link processing options with
◎
crossorigin
• the state of el's crossorigin content attribute
referrer policy
• the state of el's referrerpolicy content attribute
source set
• el's source set
base URL
• document's document base URL
origin
• document's origin
environment
• document's relevant settings object
policy container
• document's policy container
document
• document
cryptographic nonce metadata
• the current value of el's [[CryptographicNonce]] internal slot
fetch priority
• the state of el's fetchpriority content attribute
</li>
	<li>
~IF［
%link は `href$aL 属性を有する
］
⇒
%~option群 の `href$lO ~SET %link の `href$aL 属性の値
◎
If el has an href attribute, then set options's href to the value of el's href attribute.
</li>
	<li>
~IF［
%link は `integrity$aL 属性を有する
］
⇒
%~option群 の`完全性~metadata$lO ~SET %link の `integrity$aL 属性の値
◎
If el has an integrity attribute, then set options's integrity to the value of el's integrity content attribute.
</li>
	<li>
~IF［
%link は `type$aL 属性を有する
］
⇒
%~option群 の`~MIME型$lO ~SET %link の `type$aL 内容~属性の値
◎
If el has a type attribute, then set options's type to the value of el's type attribute.
</li>
	<li>
<p>
~Assert：
［
%~option群 の `href$lO ~NEQ 空~文字列
］~OR［
%~option群 の`~source集合$lO ~NEQ ~NULL
］
◎
Assert: options's href is not the empty string, or options's source set is not null.
</p>

<p>
`href$aL, `imagesrcset$aL どちらも有さない `link$e 要素は、
~linkを表現しない。
◎
A link element with neither an href or an imagesrcset does not represent a link.
</p>
	</li>
	<li>
~RET %~option群
◎
Return options.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header群から~link群を抽出する@
~algoは、
所与の
( `~header~list$ %~header群 )
に対し：
◎
To extract links from headers given a header list headers:
</p>
<ol>
	<li>
%~link群 ~LET 新たな`~list$
◎
Let links be a new list.
</li>
	<li>
%生の~link~header群 ~LET `~header~listから値を取得して復号して分割する$( %~header群, `Link^h【！`link$e】 )
◎
Let rawLinkHeaders be the result of getting, decoding, and splitting `Link` from headers.
</li>
	<li>
<p>
%生の~link~header群 を成す
~EACH( %~link~header )
に対し：
◎
For each linkHeader of rawLinkHeaders:
</p>
		<ol>
			<li>
<p>
%~link~obj ~LET %~link~header を
`WEBLINK$r <a href="~HTTPweblink#parse-fv">§ `Link^h ~field値の構文解析-法</a>
に則って構文解析した結果
`WEBLINK$r
◎
Let linkObject be the result of parsing linkHeader. [WEBLINK]
</p>

<p class="trans-note">【
これは、
実際には~link~objたちが成す~listを返す。
`WEBLINK$r による~algoは、
この~algoの 2 段~目も包摂する形で記されていて分割できないことに加え，
%~link~header 自身も複数個の`~link関係~型$を包含し得る
（その結果、
複数個の~link~objを内包し得る）。
したがって，以下は、
結果の~listを成す各~link~objに対し遂行するものと解釈する必要があろう。
】</p>

<p class="trans-note">【
以下の各所で利用される
%~link~obj の`~target属性~群$は，
この仕様においては`~map$であるかのように扱われているが、
`Link^h の構文解析-法 `WEBLINK$r に従うなら，［
( 名前, 値 ) が成す~tuple
］たちが成す~listであり、
実質的には，同じ~key（名前）を伴う~entryが複数個あり得る~mapになる
（一部の特別に扱われる~key（ "`media$aL" など）を除いて）。
同じ~keyを伴う~entryが複数個ある場合に，どれを利用するかは、
この仕様には述べられていない。
】</p>

			</li>
			<li>
<p>
~IF［
%~link~obj の`~link~target$は無い【！[ target_uri ] は~map内に存在しない】
］
⇒
~CONTINUE
◎
If linkObject["target_uri"] does not exist, then continue.
</p>

<p class="trans-note">【
`Link^h の構文解析-法 `WEBLINK$r に従うなら、
`~link~target$は常に在るはずなので，この段は不要なはず。
】</p>

			</li>
			<li>
%~link群 に %~link~obj を`付加する$
◎
Append linkObject to links.
</li>
		</ol>
	</li>
	<li>
~RET %~link群
◎
Return links.
</li>
</ol>
</div>

<div class="algo">
<p>
`~link~header群を処理する@
~algoは、
所与の
( `文書$ %文書, `応答$ %応答, %相 ~IN { `pre-media^l, `media^l } )
に対し：
◎
To process link headers given a Document doc, a response response, and a "pre-media" or "media" phase:
</p>
<ol>
	<li>
%~link群 ~LET `~header群から~link群を抽出する$( %応答 の`~header~list$rs )
◎
Let links be the result of extracting links from response's header list.
</li>
	<li>
<p>
%~link群 を成す
~EACH( %~link~obj )
に対し：
◎
For each linkObject in links:
</p>
		<ol>
			<li>
%関係~型 ~LET %~link~obj の`~link関係~型$【！relation_type】
◎
Let rel be linkObject["relation_type"].
</li>
			<li>
%属性~群 ~LET %~link~obj の`~target属性~群$【！target_attributes】
◎
Let attribs be linkObject["target_attributes"].
</li>
			<li>
%期待される相 ~LET ［
次が満たされるならば `media^l ／
~ELSE_ `pre-media^l
］
⇒
%属性~群 を成すある~entryは次を満たす
⇒
その~key ~IN { "`srcset$a", "`imagesrcset$aL", "`media$aL" }
◎
Let expectedPhase be "media" if either "srcset", "imagesrcset", or "media" exist in attribs; otherwise "pre-media".
</li>
			<li>
~IF［
%期待される相 ~NEQ %相
］
⇒
~CONTINUE
◎
If expectedPhase is not phase, then continue.
</li>
			<li>
%media ~LET %属性~群[ "`media$aL" ]
◎
↓</li>
			<li>
~IF［
%media ~NEQ ε
］~AND［
%media は`環境に合致して$いない
］
⇒
~CONTINUE
◎
If attribs["media"] exists and attribs["media"] does not match the environment, then continue.
</li>
			<li>
%~option群 ~LET 新たな`~link処理~option群$
— その
⇒＃
`href$lO ~SET %~link~obj の`~link~target$【！[ target_uri ]】,
`基底~URL$lO ~SET `文書~基底~URL$( %文書 ),
`生成元$lO ~SET %文書 の`生成元$doc,
`環境$lO ~SET %文書 に`関連な設定群~obj$,
`施策~容器$lO ~SET %文書 の`施策~容器$doc,
`文書$lO ~SET %文書
◎
Let options be a new link processing options with
◎
href
• linkObject["target_uri"]
base URL
• doc's document base URL
origin
• doc's origin
environment
• doc's relevant settings object
policy container
• doc's policy container
document
• doc
</li>
			<li>
%適用されたか ~LET `~link~headerから構文解析した属性~群を~option群に適用する$( %~option群, %属性~群, %関係~型 )
◎
Apply link options from parsed header attributes to options given attribs and rel.＼
</li>
			<li>
~IF［
%適用されたか ~EQ ~F
］
⇒
~RET
◎
If that returned false, then return.
</li>
			<li>
%imagesrcset ~LET %属性~群[ "`imagesrcset$aL" ]
◎
↓</li>
			<li>
%imagesizes ~LET %属性~群[ "`imagesizes$aL" ]
◎
↓</li>
			<li>
~IF［
%imagesrcset ~NEQ ε
］~AND［
%imagesizes ~NEQ ε
］
⇒
%~option群 の`~source集合$lO ~SET `~source集合を作成する$( %~link~obj の`~link~target$【！[ target_uri ]】, %imagesrcset, %imagesizes, ~NULL )
◎
If attribs["imagesrcset"] exists and attribs["imagesizes"] exists, then set options's source set to the result of creating a source set given linkObject["target_uri"], attribs["imagesrcset"], attribs["imagesizes"], and null.
</li>
			<li>
%関係~型 用の`~link~headerを処理する手続き$( %~option群 )
◎
Run the process a link header steps for rel given options.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~link~headerから構文解析した属性~群を~option群に適用する@
~algoは、
所与の
( `~link処理~option群$ %~option群, %属性~群, 文字列 %関係~型 )
に対し：
◎
To apply link options from parsed header attributes to a link processing options options given attribs and a string rel:
</p>
<ol>
	<li>
<p>
~IF［
%関係~型 ~EQ "`preload$v"
］：
◎
If rel is "preload":
</p>
		<ol>
			<li>
%行先の素 ~LET %属性~群[ "`as$aL" ]
◎
↓</li>
			<li>
~IF［
%行先の素 ~EQ ε
］
⇒
~RET ~F
◎
If attribs["as"] does not exist, then return false.
</li>
			<li>
%行先 ~LET `~preloadの行先を翻訳する$( %行先の素 )
◎
Let destination be the result of translating attribs["as"].
</li>
			<li>
~IF［
%行先 ~EQ ~NULL
］
⇒
~RET ~F
◎
If destination is null, then return false.
</li>
			<li>
%~option群 の`行先$lO ~SET %行先
◎
Set options's destination to destination.
</li>
		</ol>
	</li>
	<li>
%crossorigin ~LET %属性~群[ "`crossorigin$aL" ]
◎
↓</li>
	<li>
~IF［
%crossorigin ~NEQ ε
］~AND［
%crossorigin は`~CORS設定群~属性$用のいずれかの~keywordに`~ASCII大小無視$で合致する
］
⇒
%~option群 の`~CORS状態$lO ~SET %crossorigin を`~CORS設定群~属性$の値として解釈した結果の状態
◎
If attribs["crossorigin"] exists and is an ASCII case-insensitive match for one of the CORS settings attribute keywords, then set options's crossorigin to the CORS settings attribute state corresponding to that keyword.
</li>
	<li>
~IF［
%属性~群[ "`integrity$aL" ] ~NEQ ε
］
⇒
%~option群 の`完全性~metadata$lO ~SET %属性~群[ "`integrity$aL" ]
◎
If attribs["integrity"] exists, then set options's integrity to attribs["integrity"].
</li>
	<li>
%~referrer施策 ~LET %属性~群[ "`referrerpolicy$aL" ]
◎
↓</li>
	<li>
~IF［
%~referrer施策 ~NEQ ε
］~AND［
%~referrer施策 は`~referrer施策$用のいずれかの値 %値 に`~ASCII大小無視$で合致する
］
⇒
%~option群 の`~referrer施策$lO ~SET %値
◎
If attribs["referrerpolicy"] exists and is an ASCII case-insensitive match for some referrer policy, then set options's referrer policy to that referrer policy.
</li>
	<li>
~IF［
%属性~群[ "`nonce$a" ] ~NEQ ε
］
⇒
%~option群 の`暗号用~nonce~metadata$lO ~SET %属性~群[ "`nonce$a" ]
◎
If attribs["nonce"] exists, then set options's nonce to attribs["nonce"].
</li>
	<li>
~IF［
%属性~群[ "`type$aL" ] ~NEQ ε
］
⇒
%~option群 の`~MIME型$lO ~SET %属性~群[ "`type$aL" ]
◎
If attribs["type"] exists, then set options's type to attribs["type"].
</li>
	<li>
%優先度 ~LET %属性~群[ "`fetchpriority$aL" ]
◎
↓</li>
	<li>
~IF［
%優先度 ~NEQ ε
］~AND［
%優先度 は`~fetch優先度~属性$用のいずれかの~keywordに`~ASCII大小無視$で合致する
］
⇒
%~option群 の`~fetch優先度$lO ~SET %優先度 を`~fetch優先度~属性$の値として解釈した結果の状態
◎
If attribs["fetchpriority"] exists and is an ASCII case-insensitive match for a fetch priority attribute keyword, then set options's fetch priority to that fetch priority attribute keyword.
Return true.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

				</section>
				<section id="early-hints">
<h5 title="Early hints">4.2.4.5. 早期~hint</h5>

<p>
`早期~hint@
（ `early hint^en ）は、
ある演算を遂行することを~UAに許容する
— ある文書への~navi要請において、［
当の文書により利用される見込みが高い資源
］を［
当の要請が~serverにより全部的に取扱われ，応答~codeが~serveされる
］より前に投機的に読込むなど。
`~server＠~HTTPinfra#server$は、［
`最終-応答$【！最終-`応答$】を~serveする前に，
“早期~hint応答”
— 状態s~code `103$hst を伴う応答【！`応答$】 —
を~serveする
］ことにより，早期~hintを指示できる。
`RFC8297$r
◎
Early hints allow user-agents to perform some operations, such as to speculatively load resources that are likely to be used by the document, before the navigation request is fully handled by the server and a response code is served. Servers can indicate early hints by serving a response with a 103 status code before serving the final response.[RFC8297]
</p>

<p class="note">注記：
互換性の理由から、
早期~hintは，概して`~HTTP2以上の~version越しに送達される＠~HTTPearlyhints#security-considerations$が、
可読性を得るため，以下では~HTTP11~styleによる記法を利用する。
◎
For compatibility reasons early hints are typically delivered over HTTP/2 or above, but for readability we use HTTP/1.1-style notation below.
</p>

<div class="example">
<p>
例えば、
次に与える一連の応答に対しては：
◎
For example, given the following sequence of responses:
</p>

<pre class="lang-http">
103 Early Hint
Link: &lt;/image.png&gt;; `rel$aL=`preload$v; `as$aL=image
</pre>

<pre class="lang-http">
200 OK
Content-Type: text/html

&lt;!DOCTYPE html&gt;
...
&lt;img src="/image.png"&gt;
</pre>

<p>
画像（ `/image.png^c ）の読込ngは、
~HTML内容が到着する前に開始することになる。
◎
the image will start loading before the HTML content arrives.
</p>
</div>

<p class="note">注記：
［
当の~naviの間に~serveされる早期~hint応答
］のうち最初のものに限り，取扱われる
— それは、
ある非同一-生成元~redirectにより成功した場合には，破棄される。
◎
Only the first early hint response served during the navigation is handled, and it is discarded if it is succeeded by a cross-origin redirect.
</p>

<p>
`103^hst 応答は、
`Link$h ~headerに加えて，
`~CSP$~header
【 `Content-Security-Policy^h ／ `Content-Security-Policy-Report-Only^h 】
を包含することもアリである
— それは、
早期~hintを処理するとき，施行される。
◎
In addition to the `Link` headers, it is possible that the 103 response contains a Content Security Policy header, which is enforced when processing the early hint.
</p>

<div class="example">
<p>
例えば、
次に与える一連の応答に対しては：
◎
For example, given the following sequence of responses:
</p>

<pre class="lang-http">
103 Early Hint
Content-Security-Policy: `style-src$dir: 'self'【！self】;
Link: &lt;/style.css&gt;; `rel$aL=`preload$v; `as$aL=style
</pre>

<pre class="lang-http">
103 Early Hint
Link: &lt;/image.png&gt;; `rel$aL=`preload$v; `as$aL=image
</pre>

<pre class="lang-http">
302 Redirect
Location: /alternate.html
</pre>

<pre class="lang-http">
200 OK
Content-Security-Policy: `style-src$dir: 'none'【！none】;
Link: &lt;/font.ttf&gt;; `rel$aL=`preload$v; `as$aL=font
</pre>

<p>
~font（ `/font.ttf^c ）と~style（ `/style.css^c ）は，読込まれることになるが、
画像（ `/image.png^c ）は破棄されることになる
— 最終-~redirect連鎖における最初の早期~hint応答に限り，尊重されるので。
加えて、
~styleは
— 読込まれたとしても —
~redirect後の最終-応答の`~CSP$~headerにより，
当の文書から~access可能にならない。
◎
The font and style would be loaded, and the image will be discarded, as only the first early hint response in the final redirect chain is respected. The late Content Security Policy header comes after the request to fetch the style has already been performed, but the style will not be accessible to the document.
</p>
</div>

<div class="algo">
<p>
`早期~hint~header群を処理する@
~algoは、
所与の
( `応答$ %応答, `環境$ %予約-済み環境 )
に対し：
◎
To process early hint headers given a response response and an environment reservedEnvironment:
</p>

<p class="note">注記：
［
早期~hint応答~内の `Link$h ~header,
`最終-応答$【！最終-`応答$】内の `Link$h ~header,
`link$e 要素
］は、
常に，この順序で処理される。
これは、
`文書$ の `head$e 要素に［
これらの~headerの内容【を伴う `link$e 要素】
］を
— この順序に従うよう —
前付加することに等価になる。
◎
Early-hint `Link` headers are always processed before `Link` headers from the final response, followed by link elements. This is equivalent to prepending the contents of the early and final `Link` headers to the Document's head element, in respective order.
</p>
<ol>
	<li>
<p>
%早期~施策~容器 ~LET `~fetch応答から施策~容器を作成する$( %応答, %予約-済み環境 )
◎
Let earlyPolicyContainer be the result of creating a policy container from a fetch response given response and reservedEnvironment.
</p>

<p class="note">注記：
これは、
早期~hint応答が`~CSP$を内包することを許容する
— この~CSPは、
早期~hint用の`要請$を~fetchするとき，`施行-$される。
◎
This allows the early hint response to include a Content Security Policy which would be enforced when fetching the early hint request.
</p>
	</li>
	<li>
%~link群 ~LET `~header群から~link群を抽出する$( %応答 の`~header~list$rs )
◎
Let links be the result of extracting links from response's header list.
</li>
	<li>
%早期~hint群 ~LET 新たな`~list$
◎
Let earlyHints be an empty list.
</li>
	<li>
<p>
%~link群 を成す
~EACH( %~link~obj )
に対し：
◎
For each linkObject in links:
</p>

<p class="note">注記：
%早期~要請 の`~fetching$は、
当の早期~hint~link~headerを受信した時点で始まる。
対する`応答$ %応答 が，当の`文書$ %文書 が作成される前に戻って来た場合、
%早期~応答 は %応答 に設定され，
%文書 が作成されたなら~commitされる
（それが `link$e 要素【により起動される要請に対する応答】であったかのように，
%応答 を`~preloadされる資源~群が成す~map$にて可用にすることにより）。
%文書 が先に作成された場合、
%応答 は，可用になった時点で~commitされる。
◎
The moment we receive the early hint link header, we begin fetching earlyRequest. If it comes back before the Document is created, we set earlyResponse to the response of that fetch and once the Document is created we commit it (by making it available in the map of preloaded resources as if it was a link element). If the Document is created first, the response is committed as soon as it becomes available.
</p>

<p class="trans-note">【
この注記は、
この~algo全体が更新された結果，意図が不明瞭になっている
（例えば， %早期~要請, %早期~応答 が何を指すかなど）。
】</p>

		<ol>
			<li>
%関係~型 ~LET %~link~obj の`~link関係~型$【！relation_type】
◎
Let rel be linkObject["relation_type"].
</li>
			<li>
%~option群 ~LET 新たな`~link処理~option群$
— その
⇒＃
`href$lO ~SET %~link~obj の`~link~target$【！[ target_uri ]】,
`起動元$lO ~SET `early-hint^l,
`基底~URL$lO ~SET %応答 の`~URL$rs,
`生成元$lO ~SET %応答 の`~URL$rsの`生成元$url,
`環境$lO ~SET %予約-済み環境,
`施策~容器$lO ~SET %早期~施策~容器
◎
Let options be a new link processing options with
◎
href
• linkObject["target_uri"]
initiator
• "early-hint"
base URL
• response's URL
origin
• response's URL's origin
environment
• reservedEnvironment
policy container
• earlyPolicyContainer
</li>
			<li>
<p>
%属性~群 ~LET %~link~obj の`~target属性~群$【！target_attributes】
◎
Let attribs be linkObject["target_attributes"].
</p>

<p class="note">注記：
早期~hint処理の一部として取扱われるのは、［
`as$aL,
`crossorigin$aL,
`integrity$aL,
`type$aL
］属性に限られる。
他の属性
— 特に［
`blocking$aL, `imagesrcset$aL, `imagesizes$aL, `media$aL
］ —
は、
`文書$が作成された後に限り，適用-可能になる。
◎
Only the as, crossorigin, integrity, and type attributes are handled as part of early hint processing. The other ones, in particular blocking, imagesrcset, imagesizes, and media are only applicable once a Document is created.
</p>
			</li>
			<li>
%適用されたか ~LET `~link~headerから構文解析した属性~群を~option群に適用する$( %~option群, %属性~群, %関係~型 )
◎
Apply link options from parsed header attributes to options given attribs and rel.＼
</li>
			<li>
~IF［
%適用されたか ~EQ ~F
］
⇒
~RET
◎
If that returned false, then return.
</li>
			<li>
%関係~型 用の`~link~headerを処理する手続き$( %~option群 )
◎
Run the process a link header steps for rel given options.
</li>
			<li>
%早期~hint群 に %~option群 を`付加する$
◎
Append options to earlyHints.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
~RET 所与の
( `文書$ %文書 )
に対し，次を走らす手続き：
◎
Return the following substeps given Document doc:＼
</p>
		<ol>
			<li>
<p>
%早期~hint群 を成す
~EACH( %~option群 )
に対し：
◎
for each options in earlyHints:
</p>
				<ol>
					<li>
%手続き ~LET %~option群 の`文書~準備済み時の手続き$lO
◎
↓</li>
					<li>
~IF［
%手続き ~EQ ~NULL
］
⇒
%~option群 の`文書$lO ~SET %文書
◎
If options's on document ready is null, then set options's document to doc.
</li>
					<li>
~ELSE
⇒
%手続き( %文書 )
◎
Otherwise, call options's on document ready with doc.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

				</section>
				<section id="providing-users-with-a-means-to-follow-hyperlinks-created-using-the-link-element">
<h5 title="Providing users with a means to follow hyperlinks created using the link element">4.2.4.6. `link^e 要素を用いて作成された~hyperlinkを追う手段を利用者に供するとき</h5>

<p id="linkui">
ヤリトリありな~UAは、［
文書~内の各 `link$e 要素
］に対し［
それを利用して作成された`~hyperlinkを追う$手段
］を［
~UIの中のどこか
］で利用者に供してもヨイ。
そのような`~hyperlinkを追う$ ~algoの呼出nは、
その引数 %利用者-関与i に `~browser~UI$i を渡すモノトスル。
正確な~UIは，この仕様では定義されないが、
次に挙げる，何らかの形による（場合によっては単純~化して）情報
（要素の各種~属性から得されるそれ（下に定義される））
も含み得る
（以下， %資源 は当の~hyperlinkが指している資源とする）：
◎
Interactive user agents may provide users with a means to follow the hyperlinks created using the link element, somewhere within their user interface. Such invocations of the follow the hyperlink algorithm must set the userInvolvement argument to "browser UI". The exact interface is not defined by this specification, but it could include the following information (obtained from the element's attributes, again as defined below), in some form or another (possibly simplified), for each hyperlink created with each link element in the document:
</p>
<ul>
	<li>
この文書と %資源 との関係性
（ `rel$aL 属性により与えられる）
◎
The relationship between this document and the resource (given by the rel attribute)
</li>
	<li>
%資源 の~title
（ `title$aL 属性により与えられる）
◎
The title of the resource (given by the title attribute).
</li>
	<li>
%資源 の~address
（ `href$aL 属性により与えられる）
◎
The address of the resource (given by the href attribute).
</li>
	<li>
%資源 の言語
（ `hreflang$aL 属性により与えられる）
◎
The language of the resource (given by the hreflang attribute).
</li>
	<li>
%資源 用の最適な媒体
（ `media$aL 属性により与えられる）
◎
The optimum media for the resource (given by the media attribute).
</li>
</ul>

<p>
~UAは、
他の情報も含ませれる
— 資源の型など
（ `type$aL 属性により与えられる）。
◎
User agents could also include other information, such as the type of the resource (as given by the type attribute).
</p>

				</section>
			</section>
			<section id="the-meta-element">
<h4 title="The meta element">4.2.5. `meta^e 要素</h4>

<span id="meta"></span>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~metadata内容$
◎
Metadata content.
</dd>
	<dd>
`itemprop$a 属性を有する場合に限り：
`~flow内容$／`句ng内容$
◎
If the itemprop attribute is present: flow content.
◎
If the itemprop attribute is present: phrasing content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`charset$a 属性を有する場合に限り：
`head$e 要素~内。
◎
↓</dd>
	<dd>
`http-equiv$a 属性を有する場合に限り：
`head$e 要素~内。
◎
If the charset attribute is present, or if the element's http-equiv attribute is in the Encoding declaration state: in a head element.
◎
If the http-equiv attribute is present but not in the Encoding declaration state: in a head element.
</dd>
	<dd>
［
`http-equiv$a 属性を有していて，その状態 ~NEQ `符号化法~宣言$st
］の場合に限り：
`head$e 要素の子である `noscript$e 要素~内。
◎
If the http-equiv attribute is present but not in the Encoding declaration state: in a noscript element that is a child of a head element.
</dd>
	<dd>
`name$a 属性を有する場合に限り：
`~metadata内容$が期待される所。
◎
If the name attribute is present: where metadata content is expected.
</dd>
	<dd>
`itemprop$a 属性を有する場合に限り：
［
`~metadata内容$ ／ `句ng内容$
］が期待される所。
◎
If the itemprop attribute is present: where metadata content is expected.
◎
If the itemprop attribute is present: where phrasing content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`name$a
— ~metadata名を与える。
◎
name — Metadata name
</dd>
	<dd>
`http-equiv$a
— ~pragma指令を与える。
◎
http-equiv — Pragma directive
</dd>
	<dd>
`content$a
— 要素の値を与える。
◎
content — Value of the element
</dd>
	<dd>
`charset$a
— `符号化法~宣言$を与える。
◎
charset — Character encoding declaration
</dd>
	<dd>
`media$a
— 適用-可能な媒体を与える。
◎
media — Applicable media
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`meta$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window]
interface `HTMLMetaElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$, `Reflect$] attribute DOMString `name@m;
  [`CEReactions$, `Reflect$="`http-equiv$a"] attribute DOMString `httpEquiv@m;
  [`CEReactions$, `Reflect$] attribute DOMString `content@m;
  [`CEReactions$, `Reflect$] attribute DOMString `media@m;
};

  // `HTMLMetaElement$obsMb
</pre>
	</dd>
</dl>

<p>
`meta$e 要素は、［
`title$e ／ `base$e ／ `link$e ／ `style$e ／ `script$e
］要素では表出できないような，様々な種類の~metadataを`表現-$する。
◎
The meta element represents various kinds of metadata that cannot be expressed using the title, base, link, style, and script elements.
</p>

<div class="p">
<p>
`meta$e 要素は、
その各種 属性により，次を表現できる：
</p>

<ul>
	<li>
`name$a 属性による文書~levelの~metadata
</li>
	<li>
`http-equiv$a 属性による~pragma指令
</li>
	<li>
`charset$a 属性による，~HTML文書が文字列~形に直列化されるとき
（例：~network越しの伝送 ／ ~disk~storage用）
の~fileの`符号化法~宣言$。
</li>
</ul>

◎
The meta element can represent document-level metadata with the name attribute, pragma directives with the http-equiv attribute, and the file's character encoding declaration when an HTML document is serialized to string form (e.g. for transmission over the network or for disk storage) with the charset attribute.
</div>

<p>
この要素には、
次に挙げる属性のうち，
どれか 1 つだけを指定しなければナラナイ
⇒＃
`name$a,
`http-equiv$a,
`charset$a,
`itemprop$a
◎
Exactly one of the name, http-equiv, charset, and itemprop attributes must be specified.
</p>

<p>
［
`name$a ／ `http-equiv$a ／ `itemprop$a
］を指定した場合、
`content$a 属性も指定しなければナラナイ
— 他の場合、
省略しなければナラナイ。
◎
If either name, http-equiv, or itemprop is specified, then the content attribute must also be specified. Otherwise, it must be omitted.
</p>

<p>
`charset@a
属性は、
文書に利用される符号化法を指定する。
これは、
`符号化法~宣言$である。
属性が在るならば、
その値は文字列 `utf-8^l に`~ASCII大小無視$で合致しなければナラナイ。
◎
The charset attribute specifies the character encoding used by the document. This is a character encoding declaration. If the attribute is present, its value must be an ASCII case-insensitive match for the string "utf-8".
</p>

<p class="note">注記：
`meta$e 要素の `charset$a 属性は、
~XML文書には効果はないが，
~XMLから／への移行を手助けするためとして~XML文書に許容される。
◎
The charset attribute on the meta element has no effect in XML documents, but is allowed in XML documents in order to facilitate migration to and from XML.
</p>

<p>
同じ文書~内に 次を満たす `meta$e 要素が複数個~在ってはナラナイ
⇒
`charset$a 属性を有する
◎
There must not be more than one meta element with a charset attribute per document.
</p>

<p>
`content@a
属性は、
要素が［
文書~metadata／~pragma指令
］目的に利用されるときに，その値を与える。
許容される値は、
後続な各~節にて述べるとおり，正確な文脈に依存する。
◎
The content attribute gives the value of the document metadata or pragma directive when the element is used for those purposes. The allowed values depend on the exact context, as described in subsequent sections of this specification.
</p>

<p>
`meta$e 要素が
`name@a
属性を有する場合、
それは文書~metadataを設定する。
文書~metadataは、
名値~pairを通して表出される。
要素の［
`name$a, `content$a
］属性が，順に［
名前, 値
］を与える。
名前は、
~metadataのどの側面が設定されているかを指定する。
妥当な名前, および それらの値の意味は、
以下の各~節に述べる。
`meta$e 要素が `content$a 属性を有さない場合、
その~metadataの名値~pairの値~~成分は，空~文字列になる。
◎
If a meta element has a name attribute, it sets document metadata. Document metadata is expressed in terms of name-value pairs, the name attribute on the meta element giving the name, and the content attribute on the same element giving the value. The name specifies what aspect of metadata is being set; valid names and the meaning of their values are described in the following sections. If a meta element has no content attribute, then the value part of the metadata name-value pair is the empty string.
</p>

<p>
`media@a
属性は、
当の~metadataがどの媒体に適用されるかを述べる。
その値は，`妥当な媒体~query~list$でなければナラナイ。
`name$a 属性が `theme-color$v 以外の場合、
`media$a 属性には，処理~modelに対する効果は無い
— 作者は利用してはナラナイ。
◎
The media attribute says which media the metadata applies to. The value must be a valid media query list. Unless the name is theme-color, the media attribute has no effect on the processing model and must not be used by authors.
</p>

				<section id="standard-metadata-names">
<h5 title="Standard metadata names">4.2.5.1. 標準な~metadata名</h5>

<p>
この仕様は、
`meta$e 要素に対する `name$a 属性~用に，
以下に挙げる少数の名前を定義する。
◎
This specification defines a few names for the name attribute of the meta element.
</p>

<p>
各~名前は、
`~ASCII大小無視$で比較するモノトスル。
◎
Names are case-insensitive, and must be compared in an ASCII case-insensitive manner.
</p>

<p class="trans-note">【
以下に現れる “値” は、
`content$a 属性の値を指す
— これらの名前を利用した場合、
暗黙的に， `content^a 属性の値も指定することが要求されよう。
】</p>

<dl>
	<dt>`application-name@v</dt>
	<dd>
値は、
短い自由形な【すなわち，特に追加的な制約はない】文字列であり，
当の~pageが表現する~web~appの名前を与えていなければナラナイ。
この~metadata名は、
当の~pageが~web~appでない場合には，利用してはナラナイ。
名前の言語を指定する `lang$a 属性を利用して，~web~app名の翻訳を与えてもヨイ。
◎
The value must be a short free-form string giving the name of the web application that the page represents. If the page is not a web application, the application-name metadata name must not be used. Translations of the web application's name may be given, using the lang attribute to specify the language of each name.
</dd>
	<dd class="trans-note">【
何が “~web~app” を成すかは定義されていないが、
`~app~manifest＠~APPMANIFEST#dfn-manifest$が適用される~pageは該当しよう
（ `manifest$v も見よ）。
】</dd>
	<dd>
同じ文書~内に 次を満たす `meta$e 要素が複数個~在ってはナラナイ
⇒
［
互いに同じ`言語$を伴う
］~AND［
`name$a 属性を有していて，その値は`~ASCII大小無視$で `application-name$v に合致する
］
◎
There must not be more than one meta element with a given language and where the name attribute value is an ASCII case-insensitive match for application-name per document.
</dd>
	<dd>
~UAは、
~UIにおいて，~pageの `title$e に代えて~app名を利用してもヨイ
—
~titleは、
~app名のみならず，［
特定0の時点における~pageの状態sに関連な様な~message
］も含むかもしれないので。
◎
User agents may use the application name in UI in preference to the page's title, since the title might include status messages and the like relevant to the status of the page at a particular moment in time instead of just being the name of the application.
</dd>
	<dd class="algo">
<div>
<p>
~UAは、
所与の［
言語たちが成す`有順序~集合$【！ordered list】 %言語~群
（例： 英国~英語, 米国~英語, 英語）
］から，利用する~app名を見出すときは、
次の手続きを走らすモノトスル
— 結果が ε になるときは、
~app名は与えられない：
</p>
		<ol>
			<li>
%文書 ~LET 当の`文書$
</li>
			<li>
%既定の言語 ~LET %文書 の`文書~要素$の`言語$
</li>
			<li>
~IF［
%既定の言語 ~NEQ 空~文字列
（すなわち，未知でない）
【！不要］~AND［%既定の言語 ~NIN %言語~群】
］
⇒
%言語~群 に %既定の言語 を`付加する$set
</li>
			<li>
%言語~群 を成す
~EACH( %言語 )
に対し
⇒
%文書 内の
~EACH( `meta$e 要素 %要素 )
に対し，`~tree順序$で
⇒
~IF［
%要素 の`言語$ ~EQ %言語
］~AND［
%要素 は `name$a 属性を有していて，その値は`~ASCII大小無視$で `application-name$v に合致する
］~AND［
%要素 は `content$a 属性を有する
］
⇒
~RET %要素 の `content$a 属性の値
</li>
			<li>
~RET ε
</li>
		</ol>
◎
To find the application name to use given an ordered list of languages (e.g. British English, American English, and English), user agents must run the following steps:
• Let languages be the list of languages.
• Let default language be the language of the Document's document element, if any, and if that language is not unknown.
• If there is a default language, and if it is not the same language as any of the languages in languages, append it to languages.
• Let winning language be the first language in languages for which there is a meta element in the Document where the name attribute value is an ASCII case-insensitive match for application-name and whose language is the language in question.
• If none of the languages have such a meta element, then return; there's no given application name.
• Return the value of the content attribute of the first meta element in the Document in tree order where the name attribute value is an ASCII case-insensitive match for application-name and whose language is winning language.
</div>

<p class="note">注記：
この~algoは、
~pageの名前
— 一例として，~bookmarkの~labelなど —
を必要とする~browserにより利用されることになる。
~algoには、
利用者が選好する言語が供されることになる。
◎
This algorithm would be used by a browser when it needs a name for the page, for instance, to label a bookmark. The languages it would provide to the algorithm would be the user's preferred languages.
</p>

	</dd>

	<dt>`author@v</dt>
	<dd>
値は、
自由形な文字列であり，
~pageの作者たちのうち，いずれかの名前を与えていなければナラナイ。
◎
The value must be a free-form string giving the name of one of the page's authors.
</dd>

	<dt>`description@v</dt>
	<dd>
値は、
自由形な文字列であり，
~pageについて述べるものでなければナラナイ。
値は、
~pageの~directoryにおける利用
— 例えば探索~engine —
用に適切でなければナラナイ。
◎
The value must be a free-form string that describes the page. The value must be appropriate for use in a directory of pages, e.g. in a search engine.＼
</dd>
	<dd>
同じ文書~内に次を満たす `meta$e 要素が複数個~在ってはナラナイ
⇒
`name$a 属性を有していて，その値は`~ASCII大小無視$で `description$v に合致する
◎
There must not be more than one meta element where the name attribute value is an ASCII case-insensitive match for description per document.
</dd>

	<dt>`generator@v</dt>
	<dd>
値は、
自由形な文字列であり，［
文書を生成するために利用された~software~package
］のうちいずれかを識別するものでなければナラナイ。
この~metadata名【！値】は、
~softwareから~markupが生成されていない~page
— 例：~text~editorで書かれた~page —
には，利用してはナラナイ。
◎
The value must be a free-form string that identifies one of the software packages used to generate the document. This value must not be used on pages whose markup is not generated by software, e.g. pages whose markup was written by a user in a text editor.
</dd>
	<dd class="example">

<p>
“Frontweaver” と称される~toolが，~pageの `head$e 要素~内に［
当の~pageを生成した~toolとして自身を識別する名前
］を出力する例：
◎
Here is what a tool called "Frontweaver" could include in its output, in the page's head element, to identify itself as the tool used to generate the page:
</p>

`meta-generator-1^xCode

	</dd>

	<dt>`keywords@v</dt>
	<dd>
値は、
~pageに関連な~keywordたちが成す`~commaで分離された~token集合$でなければナラナイ。
◎
The value must be a set of comma-separated tokens, each of which is a keyword relevant to the page.
</dd>
	<dd class="example">
<p>
ある高速道路標識についての~pageが， `meta$e 要素を利用して［
利用者が~page内を~~検索するときに利用し得る~keywordたち
］を指定する例：
◎
This page about typefaces on British motorways uses a meta element to specify some keywords that users might use to look for the page:
</p>

`meta-keywords-1^xCode

</dd>
	<dd class="note">注記：
多くの探索~engineは、
これらの~keywordを考慮しない。
この特能は、
歴史的に
— 結果として利用者の助けにならなくなるような —
あてにならない, あるいは探索~engineを誤解させるような~spamにすら利用されてきたので。
◎
Many search engines do not consider such keywords, because this feature has historically been used unreliably and even misleadingly as a way to spam search engine results in a way that is not helpful for users.
</dd>
	<dd class="algo">
<p>
作者が~pageに適用-可能なものとして指定した~keywordたちが成す~listを得するときは、
~UAは，次の手続きを走らすモノトスル：
◎
To obtain the list of keywords that the author has specified as applicable to the page, the user agent must run the following steps:
</p>

		<ol>
			<li>
%~keyword群 ~LET 新たな`~list$
◎
Let keywords be an empty list.
</li>
			<li>
当の`文書$内の
~EACH( `meta$e 要素 %要素 )
に対し
⇒
~IF［
%要素 は `name$a 属性を有していて，その値は`~ASCII大小無視$で `keywords$v に合致する
］~AND［
%要素 は `content$a を有する
］
⇒
%~keyword群 を次の結果で`拡張する$
⇒
`~commaで分割する$( %要素 の `content^a 属性の値 )
◎
For each meta element with a name attribute and a content attribute and where the name attribute value is an ASCII case-insensitive match for keywords:
◎
Split the value of the element's content attribute on commas.
◎
Add the resulting tokens, if any, to keywords.
</li>
			<li>
%~keyword群 から重複するものを除去する
◎
Remove any duplicates from keywords.
</li>
			<li>
~RET %~keyword群
◎
Return keywords. This is the list of keywords that the author has specified as applicable to the page.
</li>
		</ol>
	</dd>
	<dd>
<p>
~UAは、
この値があてになるかどうか疑わしいときは，この情報を利用するベキでない。
◎
User agents should not use this information when there is insufficient confidence in the reliability of the value.
</p>

<p class="example">
一例として、
内容~管理~systemにとっては，［
~siteに特有な探索~engine用~indexを拡充するために，~systemの中で~pageの~keyword情報を利用する
］ことは適理になろう。
一方で、
この情報を利用する大規模な内容~集積者は，［
不適切な~keywordの利用を通して~rankingを不当に操ろうと試行する利用者
］を見出す見込みが高いであろう。
◎
For instance, it would be reasonable for a content management system to use the keyword information of pages within the system to populate the index of a site-specific search engine, but a large-scale content aggregator that used this information would likely find that certain users would try to game its ranking mechanism through the use of inappropriate keywords.
</p>

	</dd>

	<dt>`referrer@v</dt>
	<dd>
値は、
`~referrer施策$でなければナラナイ。
それは、
`文書$に対する既定の`~referrer施策$を定義する。
`REFERRERPOLICY$r
◎
The value must be a referrer policy, which defines the default referrer policy for the Document. [REFERRERPOLICY]
</dd>
	<dd class="algo">
<p>
`meta$e 要素 %要素 に対し［
%要素 が`文書の中へ挿入された$／
%要素 の［
`name$a ／ `content$a
］内容~属性が変化した
］ときは、
~UAは，次の~algoを走らすモノトスル：
◎
If any meta element element is inserted into the document, or has its name or content attributes changed, user agents must run the following algorithm:
</p>
		<ol>
			<li>
<p>
~IF［
%要素 は ~OR↓ を満たさない
］…
</p>
				<ul>
					<li>
`文書~tree内$にある
</li>
					<li>
`name$a 属性を有していて，その値は`~ASCII大小無視$で `referrer$v に合致する
</li>
					<li>
`content$a 属性を有していて，その値 ~NEQ 空~文字列
</li>
				</ul>
<p>
…ならば
⇒
~RET
</p>
◎
If element is not in a document tree, then return.
◎
If element does not have a name attribute whose value is an ASCII case-insensitive match for "referrer", then return.
◎
If element does not have a content attribute, or that attribute's value is the empty string, then return.
</li>
			<li>
%値 ~LET `~ASCII小文字~化する$( %要素 の`content$a 属性の値 )
◎
Let value be the value of element's content attribute, converted to ASCII lowercase.
</li>
			<li>
<p>
~IF［
%値 は次の表tの 1 列目に挙げるいずれかである
］
⇒
%値 ~SET 同じ行の 2 列目に与える値
◎
If value is one of the values given in the first column of the following table, then set value to the value given in the second column:
</p>

<div>
<table>
<thead><tr><th>旧来の値
<th>~referrer施策
<tbody>

<tr><td>`never^v
<td>`no-referrer$v

<tr><td>`default^v
<td>`既定の~referrer施策$

<tr><td>`always^v
<td>`unsafe-url$v

<tr><td>`origin-when-crossorigin^v
<td>`origin-when-cross-origin$v
</table>
◎
Legacy value｜Referrer policy
never｜no-referrer
default｜the default referrer policy
always｜unsafe-url
origin-when-crossorigin｜origin-when-cross-origin
</div>
			</li>
			<li>
~IF［
%値 は`~referrer施策$である
］
⇒
%要素 の`~node文書$の`施策~容器$docの`~referrer施策$pC ~SET %値
◎
If value is a referrer policy, then set element's node document's policy container's referrer policy to policy.
</li>
		</ol>

<p class="note">注記：
歴史的な理由から、
`referrer$v 用の処理~modelは
— 他の標準な~metadata名と違って —
要素が除去されても応答しないし，`~tree順序$も利用しない。
この状態にある `meta$e 要素は、
最も近過去に挿入されたか改変されたものに限り，効果がある。
◎
For historical reasons, unlike other standard metadata names, the processing model for referrer is not responsive to element removals, and does not use tree order. Only the most-recently-inserted or most-recently-modified meta element in this state has an effect.
</p>
	</dd>

	<dt>`theme-color@v</dt>
	<dd>
値は、
~CSS `color$t 生成規則に合致する文字列でなければナラナイ。
◎
The value must be a string that matches the CSS &lt;color&gt; production,＼
</dd>
	<dd>
これは、［
~UAが~pageや周囲の~UIの表示を~custom化するときに利用するべき色
］として示唆されるものを定義する。
例えば，~browserは、
指定された色を［
~pageの~title~bar／
~UItab~barや~task切替器における強調~色
］に利用するかもしれない。
◎
defining a suggested color that user agents should use to customize the display of the page or of the surrounding user interface. For example, a browser might color the page's title bar with the specified value, or use it as a color highlight in a tab bar or task switcher.
</dd>
	<dd>
同じ~HTML文書の中に次を満たす `meta$e 要素が複数個~在ってはナラナイ
⇒
［
`name$a 属性を有していて，その値は`~ASCII大小無視$で `theme-color$v に合致する
］~AND［
`media$a 属性を有していて，その値は互いに異なる
］
◎
Within an HTML document, the media attribute value must be unique amongst all the meta elements with their name attribute value set to an ASCII case-insensitive match for theme-color.
</dd>
	<dd class="example">
<p>
この標準~自身【すなわち，この和訳の原文】も、
~theme色として
“WHATWG green”
を利用している：
◎
This standard itself uses "WHATWG green" as its theme color:
</p>

`meta-theme-color-1^xCode

	</dd>
	<dd>
`media$a 属性を利用すれば、
当の文脈には供された色が利用されるべきであることを述べれる。
◎
The media attribute may be used to describe the context in which the provided color should be used.
</dd>
	<dd class="example">
<p>
暗な~modeにて，この標準の~theme色 “WHATWG green” のみを利用したいと求めるなら、
`prefers-color-scheme$d 媒体~特能を利用することもできる。
◎
If we only wanted to use "WHATWG green" as this standard's theme color in dark mode, we could use the prefers-color-scheme media feature:
</p>

`meta-theme-color-2^xCode

	</dd>

	<dd class="algo">
<p>
~pageの~theme色を得するときは、
次の手続きを走らすモノトスル：
◎
To obtain a page's theme color, user agents must run the following steps:
</p>

		<ol>
			<li>
<p>
%候補~要素~list ~LET ~AND↓ を満たす `meta$e 要素たちが成す`~tree順序$による~list：
◎
Let candidate elements be the list of all meta elements that meet the following criteria, in tree order:
</p>
				<ul>
					<li>
`文書~tree内$にある
◎
the element is in a document tree;
</li>
					<li>
`name$a 属性を有していて，その値は`~ASCII大小無視$で `theme-color$v に合致する
◎
the element has a name attribute, whose value is an ASCII case-insensitive match for theme-color; and
</li>
					<li>
`content$a 属性を有する
◎
the element has a content attribute.
</li>
				</ul>
			</li>
			<li>
<p>
%候補~要素~list を成す
~EACH( %要素 )
に対し：
◎
For each element in candidate elements:
</p>

				<ol>
					<li>
~IF［
%要素 は`media$a 属性を有していて，その値は`環境に合致して$いない
］
⇒
~CONTINUE
◎
If element has a media attribute and the value of element's media attribute does not match the environment, then continue.
</li>
					<li>
%値 ~LET `前後の~ASCII空白~列を剥ぐ$( %要素 の`content$a 属性の値 )
◎
Let value be the result of stripping leading and trailing ASCII whitespace from the value of element's content attribute.
</li>
					<li>
%色 ~LET `~CSS色~値を構文解析する$( %値 )
◎
Let color be the result of parsing value.
</li>
					<li>
~IF［
%色 ~NEQ `失敗^i
］
⇒
~RET %色
◎
If color is not failure, then return color.
</li>
				</ol>
			</li>
			<li>
~RET ε
（~pageには~theme色は無い。）
◎
Return nothing (the page has no theme color).
</li>
		</ol>
	</dd>
	<dd>
<p>
ある `meta$e 要素について，次のいずれかがが生じたときは、
~UAは上の~algoを再度~走らせて，その結果を影響される~UIに適用するモノトスル：
</p>
		<ul>
			<li>
`文書の中へ挿入された$とき
</li>
			<li>
`文書から除去された$とき
</li>
			<li>
その `name$a 属性が変化したとき
</li>
			<li>
その `content$a 属性が変化したとき
</li>
			<li>
その `media$a 属性が変化したとき
</li>
			<li>
`media$a 属性を有している下で，その値が`環境に合致して$いるかどうかが変化したとき
</li>
		</ul>
◎
If any meta elements are inserted into the document or removed from the document, or existing meta elements have their name, content, or media attributes changed, or if the environment changes such that any meta element's media attribute's value may now or may no longer match the environment, user agents must re-run the above algorithm and apply the result to any affected UI.
</dd>
	<dd>
~UAは、
~theme色を~UIに利用するときは、
より相応しくなるよう，実装に特有な仕方で調整してもヨイ。
例えば、
~UAが~theme色を背景に利用していて，その上に白い~textで表示することを意図する場合、
必要十分な~contrastを確保するため，~UIのその部位には~theme色を暗くした色を利用するなど。
◎
When using the theme color in UI, user agents may adjust it in implementation-specific ways to make it more suitable for the UI in question. For example, if a user agent intends to use the theme color as a background and display white text over it, it might use a darker variant of the theme color in that part of the UI, to ensure adequate contrast.
</dd>

	<dt>`color-scheme@v</dt>
	<dd>
~UAが~pageの背景を欲される`色~scheme$で即時に
（~page内のすべての~CSSを読込むまで待機することなく）
描画するのを援助するため、
`meta$e 要素~内には `color-scheme$p 用の値を供せる。
◎
To aid user agents in rendering the page background with the desired color scheme immediately (rather than waiting for all CSS in the page to load), a 'color-scheme' value can be provided in a meta element.
</dd>
	<dd>
値は、
~CSS `color-scheme$p ~prop用の値の構文に合致する文字列でなければナラナイ。
それは、
`~pageが~supportする色~scheme群$を決定する。
◎
The value must be a string that matches the syntax for the CSS 'color-scheme' property value. It determines the page's supported color-schemes.
</dd>
	<dd>
<p>
同じ文書~内に 次を満たす `meta$e 要素が複数個~在ってはナラナイ
⇒
`name$a 属性を有していて，その値は`~ASCII大小無視$で `color-scheme$v に合致する
◎
There must not be more than one meta element with its name attribute value set to an ASCII case-insensitive match for color-scheme per document.
</p>

<p class="trans-note">【
しかしながら、
下の注記では，複数個の用法が示唆されている。
この（適合性）要件は本当に要求されるのか？
】</p>

	</dd>
	<dd class="example">
<p>
次の宣言は、
当の~pageは［
暗な背景~色, 明な前景~色
］を伴う色~schemeを自覚して取扱えることを指示する：
◎
The following declaration indicates that the page is aware of and can handle a color scheme with dark background colors and light foreground colors:
</p>

`meta-color-scheme-1^xCode

	</dd>
	<dd class="algo">
<p>
`~pageが~supportする色~scheme群$を得するときは、
次の手続きを走らすモノトスル：
◎
To obtain a page's supported color-schemes, user agents must run the following steps:
</p>
		<ol>
			<li>
<p>
%候補~要素~list ~LET ~AND↓ を満たす `meta$e 要素たちが成す`~tree順序$による~list：
◎
Let candidate elements be the list of all meta elements that meet the following criteria, in tree order:
</p>
				<ul>
					<li>
`文書~tree内$にある
◎
the element is in a document tree;
</li>
					<li>
`name$a 属性を有していて，その値は`~ASCII大小無視$で `color-scheme$v に合致する
◎
the element has a name attribute, whose value is an ASCII case-insensitive match for color-scheme; and
</li>
					<li>
`content$a 属性を有する
◎
the element has a content attribute.
</li>
				</ul>
			</li>
			<li>
<p>
%候補~要素~list を成す
~EACH( %要素 )
に対し：
◎
For each element in candidate elements:
</p>
				<ol>
					<li>
%構文解析した結果 ~LET `成分~値~listを構文解析する$( %要素 の `content$a 属性の値 )
◎
Let parsed be the result of parsing a list of component values given the value of element's content attribute.
</li>
					<li>
~IF［
%構文解析した結果 は妥当な~CSS `color-scheme$p ~prop値である
］
⇒
~RET %構文解析した結果
◎
If parsed is a valid CSS 'color-scheme' property value, then return parsed.
</li>
				</ol>
			</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>
	<dd>
<p>
ある `meta$e 要素が［
`文書の中へ挿入された$ ／ `文書から除去された$
］とき, または
既存の `meta$e 要素の［
`name$a ／ `content$a 
］属性が変化したときは、
~UAは上の~algoを再度~走らすモノトスル。
◎
If any meta elements are inserted into the document or removed from the document, or existing meta elements have their name or content attributes changed, user agents must re-run the above algorithm.
</p>

<p class="note">注記：
これらの規則【色~schemeを得するとき】は，［
合致する `meta$e 要素を見出すまで，先頭から順に検査する
］ので、
作者は，そのような要素を複数個~供することで旧来の~UA用の~fallbackを取扱える。
それらの要素は
— ~CSSにおいて，~propの~fallbackが働くようにするときとは反対に —
旧来の値が新たな値より`後^emに来るよう配列する必要がある。
◎
Because these rules check successive elements until they find a match, an author can provide multiple such values to handle fallback for legacy user agents. Opposite to how CSS fallback works for properties, the multiple meta elements needs to be arranged with the legacy values after the newer values.
</p>
	</dd>
</dl>

				</section>
				<section id="other-metadata-names">
<h5 title="Other metadata names">4.2.5.2. 他の~metadata名</h5>

<p>
誰もが、
自前の
`定義済み~metadata名の集合に対する拡張@
を作成して利用できる。
そのような拡張を登録するための要件はない。
◎
Anyone can create and use their own extensions to the predefined set of metadata names. There is no requirement to register such extensions.
</p>

<p>
しかしながら，次のいずれかに該当する場合、
新たな~metadata名は作成されるベキでない：
◎
However, a new metadata name should not be created in any of the following cases:
</p>

<ul>
	<li>
［
当の名前, または それに付随する `content$a 属性の値
］は`~URL$である場合。
この事例では、
`定義済み~link型の集合に対する拡張$として登録することが奨励される
（新たな~metadata名は作成せずに）。
◎
If either the name is a URL, or the value of its accompanying content attribute is a URL; in those cases, registering it as an extension to the predefined set of link types is encouraged (rather than creating a new metadata name).
</li>
	<li>
当の名前には、
~UAにおける何らかの処理~要件が期待される場合。
この事例では、
標準~化されるべきである。
◎
If the name is for something expected to have processing requirements in user agents; in that case it ought to be standardized.
</li>
</ul>

<p>
また、
新たな~metadata名を作成して利用する前に，
`WHATWG Wiki MetaExtensions ~page＠https://wiki.whatwg.org/wiki/MetaExtensions$
— 以下，“この~Wiki~page” と略記する —
に諮ることが奨励される
— すでに利用-中にある~metadata名［
を選ぶ／と目的が重複する
］のを避けるため，および［
選んだ名前が，新たな標準~化された名前と衝突する
］のを避けるため。
`WHATWGWIKI$r
◎
Also, before creating and using a new metadata name, consulting the WHATWG Wiki MetaExtensions page is encouraged — to avoid choosing a metadata name that's already in use, and to avoid duplicating the purpose of any metadata names that are already in use, and to avoid new standardized names clashing with your chosen name. [WHATWGWIKI]
</p>

<p>
誰もが，いつでも、
この~Wiki~pageを編集して，~metadata名を追加してもかまわない。
新たな名前は、
次の情報も伴わせて指定できる：
◎
Anyone is free to edit the WHATWG Wiki MetaExtensions page at any time to add a metadata name. New metadata names can be specified with the following information:
</p>

<dl>
	<dt>
~keyword
（ `Keyword^en ）
</dt>
	<dd>
定義される実際の~metadata名。
定義-済みな他の名前と紛らわしいものは、
避けるベキである
（例： 文字大小のみ相違するなど）。
◎
The actual name being defined. The name should not be confusingly similar to any other defined name (e.g. differing only in case).
</dd>

	<dt>
概略的な記述
（ `Brief description^en ）
</dt>
	<dd>
~metadata名の意味についての，規範的でない短い記述
— 値に要求される形式も含め。
◎
A short non-normative description of what the metadata name's meaning is, including the format the value is required to be in.
</dd>

	<dt>
仕様
（ `Specification^en ）
</dt>
	<dd>
~metadata名の意味論と要件についての詳細な記述への~link。
この~Wikiの別の~pageや外部~pageへの~linkにもなり得る。
◎
A link to a more detailed description of the metadata name's semantics and requirements. It could be another page on the wiki, or a link to an external page.
</dd>

	<dt>
同義語
（ `Synonyms^en ）
</dt>
	<dd>
処理~要件が正確に同じであるような，他の~metadata名たちが成す~list。
作者は、
同義語による名前を定義して利用するベキでない
（その意図は、
~UAが旧来の内容を~supportできるようにするために限られる）。
誰もが、
実施に利用されていない同義語を除去してもヨイ。
この仕方で登録されるのは、
旧来の内容との互換性のため，同義語として処理される必要がある~metadata名に限られる。
◎
A list of other names that have exactly the same processing requirements. Authors should not use the names defined to be synonyms (they are only intended to allow user agents to support legacy content). Anyone may remove synonyms that are not used in practice; only names that need to be processed as synonyms for compatibility with legacy content are to be registered in this way.
</dd>

	<dt>
地位
（ `Status^en ）
</dt>
	<dd>
<p>
次のいずれか：
◎
One of the following:
</p>
		<dl>
			<dt>
提案-済み
（ `Proposed^en ）
</dt>
			<dd>
~metadata名は、
まだ，広くから査読を受けてないか認可されていない。
誰かがそれを提案していて、
それを利用しているか，近いうちに利用することになる。
◎
The name has not received wide peer review and approval. Someone has proposed it and is, or soon will be, using it.
</dd>
			<dt>
批准-済み
（ `Ratified^en ）
</dt>
			<dd>
~metadata名は、
広くから査読を受け，認可された。
~metadata名を利用している~pageを取扱う方法を
— 不正な仕方で利用された場合も含め —
一義的に定義する仕様がある。
◎
The name has received wide peer review and approval. It has a specification that unambiguously defines how to handle pages that use the name, including when they use it in incorrect ways.
</dd>

			<dt>
使用中止
（ `Discontinued^en ）
</dt>
			<dd>
この~metadata名は、
広くから査読を受けた上で，水準に満たないものと判明した。
既存の~pageが この~metadata名を利用していても、
新たな~pageには避けるベキである。
作者が代わりに利用すベキものは、
（もしあれば）
“概略的な記述 ” と “仕様”
の項に詳細が与えられることになる。
◎
The metadata name has received wide peer review and it has been found wanting. Existing pages are using this metadata name, but new pages should avoid it. The "brief description" and "specification" entries will give details of what authors should use instead, if anything.
</dd>
		</dl>
	</dd>
	<dd>
~metadata名が，既存の値とかぶると判明した場合、
除去された上で，既存の値に対する同義語として~listされるベキである。
◎
If a metadata name is found to be redundant with existing values, it should be removed and listed as a synonym for the existing value.
</dd>
	<dd>
~metadata名が “提案-済み” の地位で追加されてから， 1 ヶ月~以上
利用されない／指定されない
ままにある場合、
この~Wiki~pageから除去されてヨイ。
◎
If a metadata name is added in the "proposed" state for a period of a month or more without being used or specified, then it may be removed from the WHATWG Wiki MetaExtensions page.
</dd>
	<dd>
“提案-済み” の地位で追加された~metadata名が，既存の値とかぶるものと判明した場合、
除去された上で，既存の値に対する同義語として~listされるベキである。
“提案-済み” の地位で追加された~metadata名が，有害と判明した場合、
“使用中止” の地位に変更されるベキである。
◎
If a metadata name is added with the "proposed" status and found to be redundant with existing values, it should be removed and listed as a synonym for the existing value. If a metadata name is added with the "proposed" status and found to be harmful, then it should be changed to "discontinued" status.
</dd>
	<dd>
誰もがいつでも地位を変更できるが、
上の定義に則る限りにおいて，そうするベキである。
◎
Anyone can change the status at any time, but should only do so in accordance with the definitions above.
</dd>
</dl>

				</section>
				<section id="pragma-directives">
<h5 title="Pragma directives">4.2.5.3. ~pragma指令</h5>

<p>
`http-equiv@a
属性が指定されている `meta$e 要素は、
~pragma指令になる。
◎
When the http-equiv attribute is specified on a meta element, the element is a pragma directive.
</p>

<div class="warning" id="warning-http-equiv-unrelated-to-http-headers">
<p>
その名前 `http-equiv$a にもかかわらず、
~pragma指令は，~HTTP~headerとは ほぼ無関係である。
［
実装者／~web開発者
］は、［
それらが まるっきり別々なものであり，この名前は歴史的な事故である
］と~~考えるに越したことはない。
◎
Despite the name http-equiv, pragma directives are almost entirely unrelated to HTTP headers. Implementers and web developers are best off thinking of them as entirely separate, and the name as being a historical accident.
</p>

<p>
より詳細~には、
`~refresh$stの処理~modelは，対応する `Refresh$h ~headerと同じだが、
他の標準~化された~pragma指令の挙動は，
類似に命名された~headerとは少なくとも少しは異なる
（通例的には，劇的に異なる）。
◎
In more detail, although the refresh keyword has the same processing model as the corresponding `Refresh` header, every other standardized pragma directive has at least slightly different behavior than the similarly-named header. (And usually dramatically-different behavior.)
</p>

<p>
［
新たな文書~levelの~pragma／~HTTP~headerにより制御される切替n
］を追加するよう企てている［
実装者, 仕様を書く者
］どちらも，この不一致について用心深くなるベキであり、
既存の混同が定着しないよう，［
~HTTP~headerと `http-equiv$a ~pragma
］どちらにも同じ
— あるいは類似な —
挙動を追加することを避けるベキである。
代わりに，次を考慮すること：
◎
Implementers or specification writers contemplating adding new document-level pragmas or HTTP header-controlled switches should be cautious about this mismatch, and avoid perpetuating the existing confusion by adding the same or similar behavior to both an HTTP header and an http-equiv pragma. Instead, consider＼
</p>
<ul>
	<li>
~HTTP~headerに限り供する。
◎
providing only an HTTP header,＼
</li>
	<li>
<p>
あるいは，文書~内~pragmaが必要になる場合、
`meta$e に新たな
— `charset$a 属性に利用される~modelに類似な —
属性を追加する。
◎
or if an in-document pragma is needed, consider adding a new attribute to meta similar to the model used by the charset attribute.＼
</p>

<p>
（~DOMは変異-可能なので、
文書~内~pragmaは，避けた方が良くなることが多いことに注意。
開発者が `meta$e 要素を［
追加-／除去-／変異-
］しない単純な事例においても、
当の施策【そのような要素が指示する施策？ そのような要素を取扱うための施策？】は，［
構文解析の間は適用されない
］から［
その間でも適用される
］方へ進むことになる
— それは、
複階的な含意を伴い得る。）
◎
(Note that avoiding in-document pragmas is often the better choice, since the DOM is mutable. Thus, even in the simple case where the developer does not add, remove, or mutate meta elements, the policy will go from un-applied to applied during parsing, which can have complex implications.)
</p>
	</li>
</ul>
</div>

<p>
`http-equiv$a 属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The http-equiv attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table class="grid-table" id="table-http-equiv"><thead>
<tr><th>~keyword
<th>適合か
<th>状態
<th>概略的な記述
<tbody>

<tr><td>`content-language@v
<td>❌
<td>`内容~言語$st
<td>`~pragma集合の既定の言語$を設定する。

<tr><td>`content-type@v
<td>✅
<td>`符号化法~宣言$st
<td>`charset$a 設定の代替な形。

<tr><td>`default-style@v
<td>✅
<td>`既定の~style$st
<td>既定の`~CSS~stylesheet集合$の`~CSS~stylesheet集合~名$を設定する。

<tr><td>`refresh@v
<td>✅
<td>`~refresh$st
<td>時限~redirectとして動作する。

<tr><td>`set-cookie@v
<td>❌
<td>`Set-Cookie$st
<td>効果なし。

<tr><td>`x-ua-compatible@v
<td>✅
<td>`~X-UA-Compatible$st
<td>実施において， Internet Explorer が この仕様にもっと近く従うよう促す。
【が、仕様においては無視することが要求される。】

<tr><td>`content-security-policy@v
<td>✅
<td>`~CSP$st
<td>`文書$に対し`~CSP$を`施行する＠~CSP3#enforced$。
</table>

◎
Keyword｜Conforming｜State｜Brief description
content-language｜No｜Content language｜Sets the pragma-set default language.
content-type｜｜Encoding declaration｜An alternative form of setting the charset.
default-style｜｜Default style｜Sets the name of the default CSS style sheet set.
refresh｜｜Refresh｜Acts as a timed redirect.
set-cookie｜No｜Set-Cookie｜Has no effect.
x-ua-compatible｜｜X-UA-Compatible｜In practice, encourages Internet Explorer to more closely follow the specifications.
content-security-policy｜｜Content security policy｜Enforces a Content Security Policy on a Document.
</div>

<div class="p">
<p>
`meta$e 要素が`文書の中へ挿入された$とき，要素が［
上のいずれかの状態を表現する `http-equiv$a 属性
］を有する場合、
~UAは，その状態に応じて，以下の~listに述べる適切な~algoを走らすモノトスル：
</p>

<p>
以下、
この節においては：
</p>
<ul>
	<li>
`meta@V
は、
当の `meta$e 要素を表すとする。
</li>
	<li>
`content@V
は、
`meta$V が `content$a 属性を［
有するならば その値 ／
有さないならば ε
］とする。
</li>
</ul>

◎
When a meta element is inserted into the document, if its http-equiv attribute is present and represents one of the above states, then the user agent must run the algorithm appropriate for that state, as described in the following list:
</div>

<dl>
	<dt>
`内容~言語@st 
（ <code>`http-equiv^a="`content-language$v"</code> ）
◎
Content language state (http-equiv="content-language")
</dt>
	<dd class="note">注記：
この特能は不適合である。
作者には、
代わりに `lang$a 属性を利用することが奨励される。
◎
This feature is non-conforming. Authors are encouraged to use the lang attribute instead.
</dd>
	<dd class="algo">
<p>
この状態にある~pragmaは、
`~pragma集合の既定の言語@
を設定する。
この~pragmaが成功裡に処理されるまでは、
`~pragma集合の既定の言語$は無い：
◎
This pragma sets the pragma-set default language. Until such a pragma is successfully processed, there is no pragma-set default language.
</p>
		<ol>
			<li>
~IF［
`content$V ~EQ ε
］
⇒
~RET
◎
If the meta element has no content attribute, then return.
</li>
			<li>
~IF［
`content$V は ❝, を包含する
］
⇒
~RET
◎
If the element's content attribute contains a U+002C COMMA character (,), then return.
</li>
			<li>
%入力 ~LET `content$V
◎
Let input be the value of the element's content attribute.
</li>
			<li>
%位置 ~LET %入力 の最初の文字を指している`位置~変数$
◎
Let position point at the first character of input.
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
			<li>
%候補 ~LET
%入力 内の %位置 から
`~ASCII空白$以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not ASCII whitespace from input given position.
◎
Let candidate be the string that resulted from the previous step.
</li>
			<li>
~IF［
%候補 ~EQ 空~文字列
］
⇒
~RET
◎
If candidate is the empty string, return.
</li>
			<li>
<p>
`~pragma集合の既定の言語$ ~SET %候補
◎
Set the pragma-set default language to candidate.
</p>

<p class="note">注記：
値が，~space等で分離された複数個の~tokenからなる場合、
最初の~tokenを除くすべての~tokenは無視される。
◎
If the value consists of multiple space-separated tokens, tokens after the first are ignored.
</p>
			</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~pragmaは、
全くではないが，
同じ名前の ~HTTP `Content-Language$h ~headerと まるっきり異なる。
`HTTP$r
◎
This pragma is almost, but not quite, entirely unlike the HTTP `Content-Language` header of the same name. [HTTP]
</dd>

	<dt>
`符号化法~宣言@st 
（ <code>`http-equiv^a="`content-type$v"</code> ）
◎
Encoding declaration state (http-equiv="content-type")
</dt>
	<dd>
この状態は、
`charset$a 属性の代替な形であり，その属性を設定することに等しい。
すなわち、
`符号化法~宣言$を与える。
この状態に課される~UA要件すべては、
この仕様の § 構文解析により取扱われる。
◎
The Encoding declaration state is just an alternative form of setting the charset attribute: it is a character encoding declaration. This state's user agent requirements are all handled by the parsing section of the specification.
</dd>
	<dd>
`http-equiv$a 属性が`符号化法~宣言$st状態にある下では、
`content$V は［
次の並びに`~ASCII大小無視$で合致する文字列
］でなければナラナイ
⇒＃
`text/html;^l,
0 個~以上の`~ASCII空白$,
`charset=utf-8^l
◎
For meta elements with an http-equiv attribute in the Encoding declaration state, the content attribute must have a value that is an ASCII case-insensitive match for a string that consists of: "text/html;", optionally followed by any number of ASCII whitespace, followed by "charset=utf-8".
</dd>
	<dd>
同じ文書~内に 次を満たす 2 つの `meta$e 要素が在ってはナラナイ
⇒
一方は［
`符号化法~宣言$st状態にある `http-equiv$a 属性
］を有していて,
他方は `charset$a 属性を有する
◎
A document must not contain both a meta element with an http-equiv attribute in the Encoding declaration state and a meta element with the charset attribute present.
</dd>
	<dd>
［
`符号化法~宣言$st状態にある `http-equiv$a 属性を有する `meta$e 要素
］は、
`~HTML文書$には利用してもヨイが，`~XML文書$に利用してはナラナイ。
◎
The Encoding declaration state may be used in HTML documents, but elements with an http-equiv attribute in that state must not be used in XML documents.
</dd>

	<dt>
`既定の~style@st 
（ <code>`http-equiv^a="`default-style$v"</code> ）
◎
Default style state (http-equiv="default-style")
</dt>
	<dd class="algo">
<p>
この~pragmaは、
既定の`~CSS~stylesheet集合~名$を設定する：
◎
This pragma sets the name of the default CSS style sheet set.
</p>
		<ol>
			<li>
~IF［
`content$V ~IN { ε,  空~文字列 }
］
⇒
~RET
◎
If the meta element has no content attribute, or if that attribute's value is the empty string, then return.
</li>
			<li>
`選好される~CSS~stylesheet集合~名を変更する$( `content$V )
`CSSOM$r
◎
Change the preferred CSS style sheet set name with the name being the value of the element's content attribute. [CSSOM]
</li>
		</ol>
	</dd>

	<dt>
`~refresh@st
（ <code>`http-equiv^a="`refresh$v"</code> ）
◎
Refresh state (http-equiv="refresh")
</dt>
	<dd>
この~pragmaは、
時限~redirectとして動作する。
◎
This pragma acts as a timed redirect.
</dd>
	<dd>
各 `文書$には、
真偽値
`宣言的に~refreshするか@
が結付けられ、
初期~時は ~F とする。
◎
A Document object has an associated will declaratively refresh (a boolean). It is initially false.
</dd>
	<dd class="algo">
		<ol>
			<li>
~IF［
`content$V ~IN { ε,  空~文字列 }
］
⇒
~RET
◎
If the meta element has no content attribute, or if that attribute's value is the empty string, then return.
</li>
			<li>
`共用~宣言的~refresh手続き$( `meta$V の`~node文書$, `content$V, `meta$V )
◎
Let input be the value of the element's content attribute.
◎
Run the shared declarative refresh steps with the meta element's node document, input, and the meta element.
</li>
		</ol>
	</dd>
	<dd class="algo">
<p>
`共用~宣言的~refresh手続き@
は、
所与の
( `文書$ %文書, 文字列 %入力, `meta$e 要素 %meta ~DF ε )
に対し：
◎
The shared declarative refresh steps, given a Document object document, string input, and optionally a meta element meta, are as follows:
</p>
		<ol>
			<li>
~IF［
%文書 の`宣言的に~refreshするか$ ~EQ ~T
］
⇒
~RET
◎
If document's will declaratively refresh is true, then return.
</li>
			<li>
%位置 ~LET %入力 の最初の`符号位置$を指している`位置~変数$
◎
Let position point at the first code point of input.
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
			<li>
%秒数 ~LET 0
◎
Let time be 0.
</li>
			<li>
%秒数~文字列 ~LET
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position, and let timeString be the result.
</li>
			<li>
~IF［
%秒数~文字列 ~EQ 空~文字列
］
⇒
~IF［
%位置↗ ~NEQ ❝.
］
⇒
~RET
◎
If timeString is the empty string, then:
◎
• If the code point in input pointed to by position is not U+002E (.), then return.
</li>
			<li>
~ELSE
⇒
%秒数 ~LET `負でない整数として構文解析する$( %秒数~文字列 )
◎
Otherwise, set time to the result of parsing timeString using the rules for parsing non-negative integers.
</li>
			<li>
%入力 内の %位置 から
{ `~ASCII数字$, ❝. }
からなる`符号位置~並びを収集する$
— 結果は無視する。
◎
Collect a sequence of code points that are ASCII digits and U+002E FULL STOP characters (.) from input given position. Ignore any collected characters.
</li>
			<li>
%~URL~record ~LET %文書 の`~URL$doc
◎
Let urlRecord be document's URL.
</li>
			<li>
<p>
~IF［
%位置↗ ~NEQ ε
］：
◎
If position is not past the end of input, then:
</p>
				<ol>
					<li>
~IF［
%位置↗ ~NIN { ❝;, ❝,, `~ASCII空白$ }
］
⇒
~RET
◎
If the code point in input pointed to by position is not U+003B (;), U+002C (,), or ASCII whitespace, then return.
</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
					<li>
~IF［
%位置↗ ~IN { ❝;, ❝, }
］
⇒
%位置 ~INCBY 1
◎
If the code point in input pointed to by position is U+003B (;) or U+002C (,), then advance position to the next code point.
</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%位置↗ ~NEQ ε
］：
◎
If position is not past the end of input, then:
</p>
				<ol>
					<li>
%~URL文字列 ~LET
%入力 内の %位置 以降の`符号位置$たちが成す部分文字列
◎
Let urlString be the substring of input from the code point at position to the end of the string.
</li>
					<li>
~IF［
%位置↗ ~NIN { ❝U, ❝u }
］
⇒
~GOTO `引用符を飛ばす^i
◎
If the code point in input pointed to by position is U+0055 (U) or U+0075 (u), then advance position to the next code point. Otherwise, jump to the step labeled skip quotes.
</li>
					<li>
~IF［
( %位置 + 1 )↗ ~NIN { ❝R, ❝r }
］
⇒
~GOTO `構文解析-^i
◎
If the code point in input pointed to by position is U+0052 (R) or U+0072 (r), then advance position to the next code point. Otherwise, jump to the step labeled parse.
</li>
					<li>
~IF［
( %位置 + 2 ) ↗ ~NIN { ❝L, ❝l }
］
⇒
~GOTO `構文解析-^i
◎
If the code point in input pointed to by position is U+004C (L) or U+006C (l), then advance position to the next code point. Otherwise, jump to the step labeled parse.
</li>
					<li>
%位置 ~INCBY 3
◎
↑</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
					<li>
~IF［
%位置↗ ~NEQ ❝=
］
⇒
~GOTO `構文解析-^i
◎
If the code point in input pointed to by position is U+003D (=), then advance position to the next code point. Otherwise, jump to the step labeled parse.
</li>
					<li>
%位置 ~INCBY 1
◎
↑</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
					<li>
<p>
`引用符を飛ばす^i：<br>
~IF［
%位置↗ ~IN { ❝', ❝" }
］：
</p>
						<ol>
							<li>
%引用符 ~LET %位置↗
</li>
							<li>
%位置 ~INCBY 1
</li>
							<li>
%~URL文字列 ~SET
%入力 内の %位置 から
%引用符 以外の`符号位置~並びを収集する$
</li>
						</ol>

◎
Skip quotes: If the code point in input pointed to by position is U+0027 (') or U+0022 ("), then let quote be that code point, and advance position to the next code point. Otherwise, let quote be the empty string.
◎
Set urlString to the substring of input from the code point at position to the end of the string.
◎
If quote is not the empty string, and there is a code point in urlString equal to quote, then truncate urlString at that code point, so that it and all subsequent code points are removed.
</li>
					<li>
`構文解析-^i：<br>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %~URL文字列, %文書 )
◎
Parse: Set urlRecord to the result of encoding-parsing a URL given urlString, relative to document.
</li>
					<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET
◎
If urlRecord is failure, then return.
</li>
					<li>
~IF［
%~URL~record の`~scheme$url ~EQ `javascript＠~HTMLnav#the-javascript:-url-special-case$l
］
⇒
~RET
◎
If urlRecord's scheme is "javascript", then return.
</li>
				</ol>
			</li>
			<li>
%文書 の`宣言的に~refreshするか$ ~SET ~T
◎
Set document's will declaratively refresh to true.
</li>
			<li>
<p>
任意選択で［
次に挙げる (A), (B), (C), (D) のうち，いずれか一つ
］を遂行する：
◎
Perform one or more of the following steps:
</p>
				<ul>
					<li>
<p>
(A) ：
</p>
						<ol>
							<li>
~IF［
`閲覧~文脈~sandbox化( 自動的な特能 )~flag$ ~IN %文書 の`作動中な~sandbox法~flag集合$
］
⇒
~RET
</li>
							<li>
<p>
次のうち，`後に^em生じた方の時点から，ある秒数だけ経過するまで待機する：
</p>
<ul>
	<li>
%文書 が`完全に読込まれた時刻$
</li>
	<li>
%meta ~NEQ ε の場合に限り， %meta がこの`文書の中へ挿入された$とき
</li>
</ul>

<p>
この段における秒数は、
利用者／~UA による選好も織り込んで，調整された結果とする。
【！ある秒数が 2 つの時点ごとに個別に調整されるとしても、調整に統合されると見なせば論理的に同じ】
</p>

<p class="note">注記：
ここでは、
%文書 
— すなわち、
この手続きの初期~時における %meta の`~node文書$ —
を利用するのが重要になる。
この時点の %meta の~node文書は、
来たる~refreshに備えて，すでに変化しているかもしれず、
%meta は常に与えられるとは限らない
（~HTTP `Refresh$h ~headerの事例では）。
</p>

<p class="trans-note">【
%~URL~record が %文書 自身の~URLの場合、
同じ文書~資源の~refreshが際限なく繰返され得ることになる。
】</p>
							</li>
							<li>
~IF［
%meta ~NEQ ε
］~AND［
利用者は~redirectを取消した
］
⇒
~RET
</li>
							<li>
`~navigableを~URLへ~navigateする$( %文書 の`~node~navigable$, %~URL~record, %文書 )
— 次も与える下で
⇒＃
`履歴~取扱い^i ~SET `replace$hH
</li>
						</ol>

◎
After the refresh has come due (as defined below), if the user has not canceled the redirect and, if meta is given, document's active sandboxing flag set does not have the sandboxed automatic features browsing context flag set, then navigate document's node navigable to urlRecord using document, with historyHandling set to "replace".
◎
For the purposes of the previous paragraph, a refresh is said to have come due as soon as the later of the following two conditions occurs:
◎
• At least time seconds have elapsed since document's completely loaded time, adjusted to take into account user or user agent preferences.
◎
• If meta is given, at least time seconds have elapsed since meta was inserted into the document document, adjusted to take into account user or user agent preferences.
◎
It is important to use document here, and not meta's node document, as that might have changed between the initial set of steps and the refresh coming due and meta is not always given (in case of the HTTP `Refresh` header).
</li>
					<li>
(B)
⇒
利用者に~~許可を請う~UIを供した上で，利用者から~~許可されたなら次を行う
⇒
`~navigableを~URLへ~navigateする$( %文書 の`~node~navigable$, %~URL~record, %文書 )
◎
Provide the user with an interface that, when selected, navigates document's node navigable to urlRecord using document.
</li>
					<li>
(C)
⇒
(A) を遂行しつつ，待機している間に並行して (B) も遂行する。
◎
↑</li>
					<li>
(D)
⇒
何もしない。
◎
Do nothing.
</li>
				</ul>

<p>
加えて，~UAは、
利用者に その演算の一部または全部の側面を（他のものに加えて）伝えてもヨイ
— 例えば、
~timerの状態, ~redirectの行先, 等々。
◎
In addition, the user agent may, as with anything, inform the user of any and all aspects of its operation, including the state of any timers, the destinations of any timed redirects, and so forth.
</p>

<div>
<p id="conformance-attr-meta-http-equiv-refresh">
`http-equiv$a 属性が`~refresh$st状態にある下では、
`content$V は次のいずれかでなければナラナイ：
</p>
				<ul>
					<li>
(1) `妥当な負でない整数$
— これは、
現在の~pageが読込直されるまでの秒~数を表現する。
</li>
					<li>
<p>
(2) 次の並び：
</p>
						<ol>
							<li>
`妥当な負でない整数$
</li>
							<li>
1 個の ❝;
</li>
							<li>
1 個~以上の`~ASCII空白$
</li>
							<li>
文字列 `URL^l に`~ASCII大小無視$で合致する文字列
</li>
							<li>
1 個の ❝=
</li>
							<li>
`妥当な~URL文字列$であって，その先頭の文字 ~NIN { ❝', ❝" } なるもの
</li>
						</ol>
<p>
これは、
現在の~pageが［
並びの最後に与えられる`~URL$にある~pageに置換されるまで
］の秒~数を表現する。
</p>
					</li>
				</ul>
◎
For meta elements with an http-equiv attribute in the Refresh state, the content attribute must have a value consisting either of:
• just a valid non-negative integer, or
• a valid non-negative integer, followed by a U+003B SEMICOLON character (;), followed by one or more ASCII whitespace, followed by a substring that is an ASCII case-insensitive match for the string "URL", followed by a U+003D EQUALS SIGN character (=), followed by a valid URL string that does not start with a literal U+0027 APOSTROPHE (') or U+0022 QUOTATION MARK (") character.
◎
In the former case, the integer represents a number of seconds before the page is to be reloaded; in the latter case the integer represents a number of seconds before the page is to be replaced by the page at the given URL.
</div>
			</li>
		</ol>
	</dd>
	<dd class="example">
<p>
`head$e 要素~内の~markup例
— 5 分ごとに~pageを~serverから自動的に読込直すようにする
（ニュース配信サイトの第一面など）：
◎
A news organization's front page could include the following markup in the page's head element, to ensure that the page automatically reloads from the server every five minutes:
</p>

`meta-refresh-1^xCode

	</dd>
	<dd class="example">
<p>
別の~pageに自動的に~refreshさせる~markup例
（スライドショー用に，一連の~pageを順々に示すときなど）：
◎
A sequence of pages could be used as an automated slide show by making each page refresh to the next page in the sequence, using markup such as the following:
</p>

`meta-refresh-2^xCode

	</dd>

	<dt>
`Set-Cookie@st
（ <code>`http-equiv^a="`set-cookie$v"</code> ）
◎
Set-Cookie state (http-equiv="set-cookie") 
</dt>
	<dd>
この~pragmaは不適合であり、
効果は無い。
◎
This pragma is non-conforming and has no effect.
</dd>
	<dd>
~UAには、
この~pragmaを無視することが要求される。
◎
User agents are required to ignore this pragma.
</dd>

	<dt>
`~X-UA-Compatible@st
（ <code>`http-equiv^a="`x-ua-compatible$v"</code> ）
◎
X-UA-Compatible state (http-equiv="x-ua-compatible")
</dt>
	<dd>
この~pragmaは、
実施においては，
Internet Explorer が この仕様にもっと近く従うよう促す。
◎
In practice, this pragma encourages Internet Explorer to more closely follow the specifications.
</dd>
	<dd>
`http-equiv$a 属性が`~X-UA-Compatible$st状態にある下では、
`content$V は，［
`IE=edge^l に`~ASCII大小無視$で合致する文字列
］でなければナラナイ。
◎
For meta elements with an http-equiv attribute in the X-UA-Compatible state, the content attribute must have a value that is an ASCII case-insensitive match for the string "IE=edge".
</dd>
	<dd>
~UAには、
この~pragmaを無視することが要求される。
◎
User agents are required to ignore this pragma.
</dd>

	<dt>
`~CSP@st
（ <code>`http-equiv^a="`content-security-policy$v"</code> ）
◎
Content security policy state (http-equiv="content-security-policy")
</dt>
	<dd class="algo">
<p>
この~pragmaは、
`文書$に対し`~CSP$を`施行-$する
`CSP$r
— その~algoは：
◎
This pragma enforces a Content Security Policy on a Document. [CSP]
</p>
		<ol>
			<li>
~IF［
`meta$V は `head$e 要素の子でない
］
⇒
~RET
◎
If the meta element is not a child of a head element, return.
</li>
			<li>
~IF［
`content$V ~IN { ε,  空~文字列 }
］
⇒
~RET
◎
If the meta element has no content attribute, or if that attribute's value is the empty string, then return.
</li>
			<li>
%施策 ~LET `直列形の~CSPを構文解析する$( `content$V, `meta^l, `enforce^l )
◎
Let policy be the result of executing Content Security Policy's parse a serialized Content Security Policy algorithm on the meta element's content attribute's value, with a source of "meta", and a disposition of "enforce".
</li>
			<li>
%施策 からすべての［
`report-uri$dir,
`frame-ancestors$dir,
`sandbox$dir
］`指令$を除去する
◎
Remove all occurrences of the report-uri, frame-ancestors, and sandbox directives from policy.
</li>
			<li>
%施策 を`施行-$する
◎
Enforce the policy policy.
</li>
		</ol>
	</dd>
	<dd>
<p>
`http-equiv$a 属性が`~CSP$st状態にある下では、
`content$V は：
</p>
		<ul>
			<li>
`妥当な~CSP$でなければナラナイ。
</li>
			<li>
次に挙げる`指令$を包含してはナラナイ
⇒＃
`report-uri$dir,
`frame-ancestors$dir,
`sandbox$dir
</li>
		</ul>
<p>
この`~CSP$は、
現在の文書に対し`施行-$されることになる。
`CSP$r
</p>
◎
For meta elements with an http-equiv attribute in the Content security policy state, the content attribute must have a value consisting of a valid Content Security Policy, but must not contain any report-uri, frame-ancestors, or sandbox directives. The Content Security Policy given in the content attribute will be enforced upon the current document. [CSP]
	</dd>
	<dd class="note">注記：
一部の資源は、
`meta$e 要素を文書に挿入する時点で，すでに~fetch済みになることもアリである。
例えば、［
`~CSP$st 状態にある `http-equiv$a 属性を伴う `meta$e 要素
］を動的に挿入するに先立って，
当の画像は`可用な画像~list$に格納-済みかもしれない。
そのような~fetch済み資源が，後で`施行-$される`~CSP$により阻止されることは、
保証されない。
◎
At the time of inserting the meta element to the document, it is possible that some resources have already been fetched. For example, images might be stored in the list of available images prior to dynamically inserting a meta element with an http-equiv attribute in the Content security policy state. Resources that have already been fetched are not guaranteed to be blocked by a Content Security Policy that's enforced late.
</dd>
	<dd class="example">
<p>
`meta$e 要素による施策を利用して，［
~inline~JSの実行を防止する ／ すべての~plugin内容を阻止する
］ことにより、
~XSS攻撃の~riskを軽減する例：
◎
A page might choose to mitigate the risk of cross-site scripting attacks by preventing the execution of inline JavaScript, as well as blocking all plugin content, using a policy such as the following:
</p>

`meta-csp-1^xCode

</dd>
</dl>

<p>
同じ文書~内の複数個の `meta$e 要素が同時に次を満たしてはナラナイ
⇒
`http-equiv$a 属性を有していて，互いに同じ状態にある
◎
There must not be more than one meta element with any particular state in the document at a time.
</p>

				</section>
				<section id="charset">
<h5 title="Specifying the document's character encoding">4.2.5.4. 文書の符号化法の指定-法</h5>

<p>
`符号化法~宣言@
は、［
文書を格納する／伝送するために利用される`符号化法$
］を指定する仕組みである。
【この訳では、 “文字~符号化法” を，単に “符号化法” と略記する。】
◎
A character encoding declaration is a mechanism by which the character encoding used to store or transmit a document is specified.
</p>

<p>
Encoding 標準は、
`~UTF-8$`符号化法$の利用，および
それを識別するためとして `utf-8^l `符号化法~label$の利用を要求する。
それらの要件により、
文書の`符号化法~宣言$は，存在するならば［
`~ASCII大小無視$で `utf-8^l に合致する`符号化法~label$を指定する
］ことが必要yである。
この宣言の有無に関わらず，文書を符号化するときに利用される実際の`符号化法$docは、
`~UTF-8$でなければナラナイ。
`ENCODING$r
◎
The Encoding standard requires use of the UTF-8 character encoding and requires use of the "utf-8" encoding label to identify it. Those requirements necessitate that the document's character encoding declaration, if it exists, specifies an encoding label using an ASCII case-insensitive match for "utf-8". Regardless of whether a character encoding declaration is present or not, the actual character encoding used to encode the document must be UTF-8. [ENCODING]
</p>

<p>
上の規則を施行するためには、
著作~toolは，新たに作成する文書には既定では`~UTF-8$を利用しなければナラナイ。
◎
To enforce the above rules, authoring tools must default to using UTF-8 for newly-created documents.
</p>

<p>
加えて、
符号化法~宣言を直列化する際には：
◎
The following restrictions also apply:
</p>
<ul>
	<li>
いかなる種類の`文字~参照$や文字~escapeも利用してはナラナイ。
◎
The character encoding declaration must be serialized without the use of character references or character escapes of any kind.
</li>
	<li id="charset1024">
当の宣言を包含している要素~全体が文書の先頭から 1024 ~byteまでに現れなければナラナイ。
◎
The element containing the character encoding declaration must be serialized completely within the first 1024 bytes of the document.
</li>
</ul>

<p>
加えて、
`meta$e 要素に課される制約に因り，文書~内の `meta$e による符号化法~宣言は 1 個までに限られる。
◎
In addition, due to a number of restrictions on meta elements, there can only be one meta-based character encoding declaration per document.
</p> 

<div class="p">
<p>
`~HTML文書$が ~AND↓ を満たす場合：
</p>
<ul>
	<li>
その~fileは，~BOMから開始されていない
</li>
	<li>
その`符号化法$は`~Content-Type~metadata$により明示的に与えられていない
</li>
	<li>
`~iframe-srcdoc文書$でない
</li>
</ul>

<p>
当の文書には、
次のいずれかの属性を有する `meta$e 要素を利用して，符号化法を指定しなければナラナイ
⇒＃
`charset$a 属性 ／
`符号化法~宣言$st 状態にある `http-equiv$a 属性
</p>

◎
If an HTML document does not start with a BOM, and its encoding is not explicitly given by Content-Type metadata, and the document is not an iframe srcdoc document, then the encoding must be specified using a meta element with a charset attribute or a meta element with an http-equiv attribute in the Encoding declaration state.
</div>

<div class="note">
<p>注記：
すべての文字が~ASCII範囲に符号化される場合でも，符号化法~宣言は要求される
（`~Content-Type~metadata$内に, または明示的に~file内に）。
符号化法は、
利用者が~formに手入力した非~ASCII文字, ~scriptにより生成される~URL, 等々
を処理するために必要になるので。
◎
A character encoding declaration is required (either in the Content-Type metadata or explicitly in the file) even when all characters are in the ASCII range, because a character encoding is needed to process non-ASCII characters entered by the user in forms, in URLs generated by scripts, and so forth.
</p>

<p>
~UTF-8でない符号化法を利用した場合、
~form提出や~URLの符号化-時に，期待されない結果をもたらし得る
— それらは、
既定では文書の`符号化法$docを利用するので。
◎
Using non-UTF-8 encodings can have unexpected results on form submission and URL encodings, which use the document's character encoding by default.
</p>
</div>

<p>
`~iframe-srcdoc文書$である文書には、
`符号化法~宣言$が在ってはナラナイ
（この事例では、
当の文書は当の `iframe$e を包含した文書の一部を成すので，
その~sourceはすでに復号-済みである）。
◎
If the document is an iframe srcdoc document, the document must not have a character encoding declaration. (In this case, the source is already decoded, since it is part of the document that contained the iframe.)
</p>

<p>
~XMLにおいては、
必要yなら，~XML宣言を利用して 符号化法の情報を~inlineに与えるベキである。
◎
In XML, the XML declaration should be used for inline character encoding information, if necessary.
</p>

<div class="example">
<p>
~HTMLにおいては、
作者は，次の~markupを文書の先頭近く（の `head$e 要素~内）に含めることで，
符号化法を`~UTF-8$に宣言できる：
◎
In HTML, to declare that the character encoding is UTF-8, the author could include the following markup near the top of the document (in the head element):
</p>

`meta-charset-1^xCode

<p>
~XMLにおいては、
他の~markupに先立つ先頭に~XML宣言を利用することになる：
◎
In XML, the XML declaration would be used instead, at the very top of the markup:
</p>

`xml-encoding-1^xCode
</div>

				</section>
			</section>
			<section id="the-style-element">
<h4 title="The style element">4.2.6. `style^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~metadata内容$
◎
Metadata content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`~metadata内容$が期待される所。
◎
Where metadata content is expected.
</dd>
	<dd>
`head$e 要素の子である `noscript$e 要素~内。
◎
In a noscript element that is a child of a head element.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`適合t~stylesheet$を与える`~text$。
◎
Text that gives a conformant style sheet.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`~mediaS$a
— 適用-可能な媒体を与える。
◎
media — Applicable media
</dd>
	<dd>
`~blockingS$a
— 要素は`具現化を阻む能性$があるかどうか。
◎
blocking — Whether the element is potentially render-blocking
</dd>
	<dd>
この要素の `~titleS$a 属性には，
`特別な意味論＠#attr-style-title$もあり、
`~CSS~stylesheet集合~名$を与える。
◎
Also, the title attribute has special semantics on this element: CSS style sheet set name
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`style$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLStyleElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  attribute boolean `~disabledS$m;
  [`CEReactions$, `Reflect$] attribute DOMString `~mediaS@m;
  [SameObject, PutForwards=`value$m, `Reflect$] readonly attribute `DOMTokenList$I `~blockingS@m;

  // `HTMLStyleElement$obsMb
};

`HTMLStyleElement$I includes `LinkStyle$I;
</pre>

	</dd>
</dl>

<p>
`style$e 要素は、［
文書~内に~CSS~stylesheetを埋込む
］ことを作者に許容する。
この要素は、
~style付け処理~modelへの入力の一種であり，利用者向けの内容は`表現-$しない。
◎
The style element allows authors to embed CSS style sheets in their documents. The style element is one of several inputs to the styling processing model. The element does not represent content for the user.
</p>

<div class="algo">
<p>
`~disabledS@m
取得子~手続きは：
◎
The disabled getter steps are:
</p>
<ol>
	<li>
%~stylesheet ~LET コレに`結付けられた~CSS~stylesheet$
◎
↓</li>
	<li>
~IF［
%~stylesheet ~EQ ~NULL
］
⇒
~RET ~F
◎
If this does not have an associated CSS style sheet, return false.
</li>
	<li>
~RET %~stylesheet の`不能化されるか$ss
◎
If this's associated CSS style sheet's disabled flag is set, return true.
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~disabledS$m
設定子~手続きは：
◎
The disabled setter steps are:
</p>
<ol>
	<li>
%~stylesheet ~LET コレに`結付けられた~CSS~stylesheet$
◎
↓</li>
	<li>
~IF［
%~stylesheet ~EQ ~NULL
］
⇒
~RET
◎
If this does not have an associated CSS style sheet, return.
</li>
	<li>
%~stylesheet の`不能化されるか$ss ~SET 所与の値
◎
If the given value is true, set this's associated CSS style sheet's disabled flag. Otherwise, unset this's associated CSS style sheet's disabled flag.
</li>
</ol>
</div>

<div class="example">
<p>
当の `style$e 要素に`結付けられた~CSS~stylesheet$が無いときに
`~disabledS$m 属性に値をアテガっても，効果は無いことに注意：
◎
Importantly, disabled attribute assignments only take effect when the style element has an associated CSS style sheet:
</p>

<pre class="lang-js">
const %style = document.createElement('style');
%style.disabled = true;
%style.textContent = 'body { background-color: red; }';
document.body.append(%style);
console.log(%style.disabled); // false
</pre>
</div>

<p>
`~mediaS@a
属性は、
~styleをどの媒体に適用するかを述べる。
この属性に指定する値は、
`妥当な媒体~query~list$でなければナラナイ。
~UAは、［
`~mediaS$a 属性の値が`環境に合致して$いて, かつ関連な他の条件にも該当する
］ならば，~styleを適用し、
他の場合は適用しないモノトスル。
◎
The media attribute says which media the styles apply to. The value must be a valid media query list. The user agent must apply the styles when the media attribute's value matches the environment and the other relevant conditions apply, and must not apply them otherwise.
</p>

<p class="note">注記：
~styleの視野は、
例えば ~CSS内の `media^at ~blockの利用により，更に制限され得る。
この仕様は、
そのような更なる制約や要件は上書きしない。
◎
The styles might be further limited in scope, e.g. in CSS with the use of @media blocks. This specification does not override such further restrictions or requirements.
</p>

<p id="style-default-media">
`~mediaS$a 属性が省略された場合の既定は、
値 `all^l であり，~styleはすべての媒体に既定で適用されることを意味する。
◎
The default, if the media attribute is omitted, is "all", meaning that by default styles apply to all media.
</p>

<p>
`~blockingS@a
属性は、
`他を阻む属性$である。
◎
The blocking attribute is a blocking attribute.
</p>

<p id="title-on-style">
`style$e 要素の
`~titleS@a
属性は、
`~CSS~stylesheet集合$ `CSSOM$r を定義する†。
要素が `~titleS$a 属性を有さない場合，その~titleも無い††。
`style$e 要素には、
先祖の `title$a 属性は適用されない。
また，要素が`文書~tree内$に無い場合、
その `~titleS$a 属性は無視される。
◎
The title attribute on style elements defines CSS style sheet sets. If the style element has no title attribute, then it has no title; the title attribute of ancestors does not apply to the style element. If the style element is not in a document tree, then the title attribute is ignored. [CSSOM]
</p>

<p class="trans-note">【†
すなわち、
要素が表現する~stylesheetの`~CSS~stylesheet集合~名$を与える。
この記述は、
要素に指定された~style付け言語は~CSSであることを前提にしている。
】【††
~style付け言語が~CSSならば、
“~titleが無い” とは［
~stylesheetの`~title$ss ~EQ 空~文字列
］を意味する。
】</p>

<p class="note">注記：
`link$e 要素の `title$aL 属性と同様、
`~titleS$a 属性を有さない `style$e 要素は、
親の `title$a 属性を継承せず，その~style~blockは単に~titleを持たなくなる
— この `~titleS$a 属性は、
その点で，他のほとんどの要素の大域~属性である `title$a 属性から相違する。
◎
The title attribute on style elements, like the title attribute on link elements, differs from the global title attribute in that a style block without a title does not inherit the title of the parent element: it merely has no title.
</p>

<p>
`style$e 要素の`子~text内容$は、
`適合t~stylesheet$を与えなければナラナイ。
◎
The child text content of a style element must be that of a conformant style sheet.
</p>

<p>
`style$e 要素のうち，その`~node文書$の構文解析器により作成されたものは、
`暗黙的に具現化を阻む能性$があるとする。
◎
A style element is implicitly potentially render-blocking if the element was created by its node document's parser.
</p>

<hr>

<p>
`style$e 要素 %要素 に対し，次に挙げるいずれかが生じたときは、
~UAは，
%要素 の`~style~blockを更新する$~algoを走らすモノトスル：
◎
The user agent must run the update a style block algorithm whenever any of the following conditions occur:
</p>
<ul>
	<li>
<p>
%要素 は、
ある`~stack^iから~popされたとき。
</p>

<p>
`~stack^iとは、
次項のそれも含め，［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$を表すとする。
</p>

◎
The element is popped off the stack of open elements of an HTML parser or XML parser.
</li>
	<li>
%要素 は どの`~stack^i上にも無い下で、［
`接続されたとき$ ／ `切断されたとき$
］。
◎
The element is not on the stack of open elements of an HTML parser or XML parser, and it becomes connected or disconnected.
</li>
	<li>
%要素 の`子~群~変更-時の手続き$が走るとき。
◎
The element's children changed steps run.
</li>
</ul>

<div class="algo">
<p>
`~style~blockを更新する@
~algoは：
◎
The update a style block algorithm is as follows:
</p>

<ol>
	<li>
%要素 ~LET 当の `style$e 要素
◎
Let element be the style element.
</li>
	<li>
%~stylesheet ~LET %要素 に`結付けられた~CSS~stylesheet$
◎
↓</li>
	<li>
~IF［
%~stylesheet ~NEQ ~NULL
］
⇒
`~CSS~stylesheetを除去する$( %~stylesheet )
◎
If element has an associated CSS style sheet, remove the CSS style sheet in question.
</li>
	<li>
~IF［
%要素 は`接続されて$いない
］
⇒
~RET
◎
If element is not connected, then return.
</li>
	<li>
<p>
~IF［
%要素 は `type$a 属性を有していて，その値は`~ASCII大小無視$で［
空~文字列, `text/css^l
］いずれにも合致しない
］
⇒
~RET
◎
If element's type attribute is present and its value is neither the empty string nor an ASCII case-insensitive match for "text/css", then return.
</p>

<p class="note">注記：
特に、
~parameterを伴う `type$a 値
— `text/css; charset=utf-8^l など —
は、
この~algoを早くに ~RET させる。
◎
In particular, a type value with parameters, such as "text/css; charset=utf-8", will cause this algorithm to return early.
</p>
	</li>
	<li>
~IF［
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$
( %要素, `style^l, %要素 の`子~text内容$ )
の結果 ~EQ `阻止される^i
`CSP$r
］
⇒
~RET
◎
If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the style element, "style", and the style element's child text content, then return. [CSP]
</li>
	<li>
<p>
`~CSS~stylesheetを作成する$
— 次に挙げる~propを伴うよう：
◎
Create a CSS style sheet with the following properties:
</p>
		<ul>
			<li>
`種別$ss ~SET `text/css$c
◎
type
• text/css
</li>
			<li>
`所有者~node$ss ~SET %要素
◎
owner node
• element
</li>
			<li>
<p>
`媒体$ss ~SET %要素 の `~mediaS$a 属性
◎
media
• The media attribute of element.
</p>

<p class="note">注記：
これは、
属性の現在の値の複製ではなく，
（場合によってはこの時点では無い）属性への参照である。
`CSSOM^cite が，属性が動的に［
設定- ／ 変更- ／ 除去-
］されたときに何が起こるかを定義する。
◎
This is a reference to the (possibly absent at this time) attribute, rather than a copy of the attribute's current value. CSSOM defines what happens when the attribute is dynamically set, changed, or removed.
</p>
			</li>
			<li>
<p id="the-style-element:concept-css-style-sheet-title">
`~title$ss ~SET ［
次が満たされるならば %要素 の `~titleS$a 属性 ／
~ELSE_ 空~文字列
］
⇒
%要素 は`文書~tree内$に在る
◎
title
• The title attribute of element, if element is in a document tree, or the empty string otherwise.
</p>

<p class="note">注記：
これも属性への`参照^emである。
◎
Again, this is a reference to the attribute.
</p>
			</li>
			<li>
`代替-か$ss ~SET ~F
◎
alternate flag
• Unset.
</li>
			<li>
`生成元cleanか$ss ~SET ~T
◎
origin-clean flag
• Set.
</li>
			<li>
`所在$ss ~SET ~NULL
◎
location
• ↓
</li>
			<li>
`親~CSS~stylesheet$ss ~SET ~NULL
◎
parent CSS style sheet
• ↓
</li>
			<li>
`所有者~CSS規則$ss ~SET ~NULL
◎
owner CSS rule
• null
</li>
			<li>
`不能化されるか$ss ~SET その既定の値【すなわち，~F】
◎
disabled flag
• Left at its default value.
</li>
			<li>
<p>
`~CSS規則~list$ss
⇒
初期化されないまま。
◎
CSS rules
• Left uninitialized.
</p>

<p class="XXX">
これは~~正しく見えない。
%要素 の`子~text内容$を利用しているはずなので。
`課題 #2997＠~HTMLissue/2997$ を見よ。
◎
This doesn't seem right. Presumably we should be using the element's child text content? Tracked as issue #2997.
</p>
			</li>
		</ul>
	</li>
	<li>
~IF［
%要素 は`~scriptを阻んでいる~stylesheetを供与して$いる
］
⇒
%要素 の`~node文書$の`~scriptを阻んでいる~stylesheet集合$に %要素 を`付加する$set
◎
If element contributes a script-blocking style sheet, append element to its node document's script-blocking style sheet set.
</li>
	<li>
~IF［
%要素 の `~mediaS$a 属性の値は`環境に合致して$いる
］~AND［
%要素 は`具現化を阻む能性$がある
］
⇒
`具現化を阻む$( %要素 )
◎
If element's media attribute's value matches the environment and element is potentially render-blocking, then block rendering on element.
</li>
</ol>
</div>

<div class="algo">
<p>
［
~stylesheetに`必須な下位資源$が在る下で，それを得する試みが完了した
］か［
~stylesheetに`必須な下位資源$は無い下で，~stylesheetは構文解析され処理された
］なら、
~UAは，次の手続きを走らすモノトスル：
◎
Once the attempts to obtain the style sheet's critical subresources, if any, are complete, or, if the style sheet has no critical subresources, once the style sheet has been parsed and processed, the user agent must run these steps:
</p>

<p class="XXX">
`必須な下位資源$の~fetchingは、
きちんと定義されていない
— おそらく、
`課題 #968＠~HTMLissue/968$ が，それ用の最善な解決になろう。
当面の間は、
`必須な下位資源$への`要請$の`具現化を阻んでいるか$rqは，
~IS［
当の `style$e 要素は現在`具現化を阻んで$いる
］に設定されるべきである。
◎
Fetching the critical subresources is not well-defined; probably issue #968 is the best resolution for that. In the meantime, any critical subresource request should have its render-blocking set to whether or not the style element is currently render-blocking.
</p>

<ol>
	<li>
%要素 ~LET 当の~stylesheetに結付けられた `style$e 要素
◎
Let element be the style element associated with the style sheet in question.
</li>
	<li>
%成功か ~LET ~T
◎
Let success be true.
</li>
	<li>
<p>
~IF［
~stylesheetの ある`必須な下位資源$を得する試みは、
何らかの理由により失敗した
（例：
~DNS~error ／
~HTTP 404 応答 ／
接続が早々に閉じられた ／
~Content-Typeは~supportされていない）
］
⇒
%成功か ~SET ~F
◎
If the attempts to obtain any of the style sheet's critical subresources failed for any reason (e.g., DNS error, HTTP 404 response, a connection being prematurely closed, unsupported Content-Type), set success to false.
</p>

<p class="note">注記：
内容に特有な~error
— 例：~CSS構文解析-時や~PNG復号-時の~errorなど —
は、
%成功か には影響しない。
◎
Note that content-specific errors, e.g., CSS parse errors or PNG decoding errors, do not affect success.
</p>
	</li>
	<li>
<p>
`要素~taskを~queueする$( `~network用~task~source$, %要素, 次の手続き )：
◎
Queue an element task on the networking task source given element and the following steps:
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
~IF［
%成功か ~EQ ~T
］
⇒
`~eventを発火する$( %要素, `load$et )
◎
If success is true, fire an event named load at element.
</li>
			<li>
~ELSE
⇒
`~eventを発火する$( %要素, `error$et )
◎
Otherwise, fire an event named error at element.
</li>
			<li>
<p>
~IF［
%要素 は`~scriptを阻んでいる~stylesheetを供与して$いる
］：
◎
If element contributes a script-blocking style sheet:
</p>
				<ol>
					<li>
%~stylesheet集合 ~LET %要素 の`~node文書$の`~scriptを阻んでいる~stylesheet集合$
◎
↓</li>
					<li>
~Assert：
%要素 ~IN %~stylesheet集合
◎
Assert: element's node document's script-blocking style sheet set contains element.
</li>
					<li>
%~stylesheet集合 から %要素 を`除去する$
◎
Remove element from its node document's script-blocking style sheet set.
</li>
				</ol>
			</li>
			<li>
`具現化を阻まなくする$( %要素 )
◎
Unblock rendering on element.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<p>
`style$e 要素に対しては、
当の~stylesheetに`必須な下位資源$が在るならば
⇒
それを得するすべての試みが完了するまで、
当の要素の`~node文書$に対する~load~eventを`遅延-$するモノトスル。
◎
The element must delay the load event of the element's node document until all the attempts to obtain the style sheet's critical subresources, if any, are complete.
</p>

<p class="note">注記：
この仕様は，~style~systemを指定しないが、
ほとんどの~web~browserは，~CSSを~supportするものと期待される。
`CSS$r
◎
This specification does not specify a style system, but CSS is expected to be supported by most web browsers. [CSS]
</p>

<p>
この要素も `LinkStyle$I ~interface `CSSOM$r を実装する。
◎
The LinkStyle interface is also implemented by this element. [CSSOM]
</p>

<div class="example">
<p>
適切な要素を利用すれば、
文書に~styleをあてがい直すことも容易になる。
次の文書では、
他の部分は既定の~styleに保ちながら，
`em^e で強勢された~textには，~italicでなくした上で明るい赤にする~styleがあてがわれている。
◎
The following document has its stress emphasis styled as bright red text rather than italics text, while leaving titles of works and Latin words in their default italics. It shows how using appropriate elements enables easier restyling of documents.
</p>

`style-1^xCode
</div>

			</section>
			<section id="interactions-of-styling-and-scripting">
<h4 title="Interactions of styling and scripting">4.2.7. ~style付けと~scriptingとの相互作用</h4>

<p>
~stylesheetは他の資源を参照していない場合
（例： `style$e 要素に与された内部~stylesheetであって，
`import^at 規則を含んでいない）、
~style規則は，`即時$に~scriptに可用にされるモノトスル。
他の場合、
~style規則は、
`~event~loop$が`描画を更新する$ 段に達した時点で~scriptに可用にされるモノトスル。
◎
If the style sheet referenced no other resources (e.g., it was an internal style sheet given by a style element with no @import rules), then the style rules must be immediately made available to script; otherwise, the style rules must only be made available to script once the event loop reaches its update the rendering step.
</p>

<p id="a-style-sheet-that-is-blocking-scripts">
［
`~HTML構文解析器$／`~XML構文解析器$
］の`文書$の文脈~下にある要素 %要素 が
`~scriptを阻んでいる~stylesheetを供与して@
いるとは、
~AND↓ が満たされることをいう：
◎
An element el in the context of a Document of an HTML parser or XML parser contributes a script-blocking style sheet if all of the following are true:
</p>
<ul>
	<li>
%要素 は、
%構文解析器 により作成された
◎
el was created by that Document's parser.
</li>
	<li>
%要素 は、
次を満たす［
`style$e ／ `link$e
］要素である
⇒
その作成-時には`~style付け~modelに供与する外部~資源~link＠~HTMLlinks#link-type-stylesheet$であった
◎
el is either a style element or a link element that was an external resource link that contributes to the styling processing model when the el was created by the parser.
</li>
	<li>
%要素 の `media^a 属性の値は、
`環境に合致して$いる
◎
el's media attribute's value matches the environment.
</li>
	<li>
%構文解析器 が %要素 を作成した時点で、
%要素 による~stylesheetは可能化された
◎
el's style sheet was enabled when the element was created by the parser.
</li>
	<li>
`~event~loop$の`最初の段＠~WAPI#step1$に最後に達した時点で［
%要素 の`根$ ~EQ %文書
］であった
◎
The last time the event loop reached step 1, el's root was that Document.
</li>
	<li>
<p>
~UAは %要素 による~stylesheetの読込ngをまだ あきらめていない
— ~UAは、
~stylesheetの読込ngをいつでも あきらめてヨイ。
◎
The user agent hasn't given up on loading that particular style sheet yet. A user agent may give up on loading a style sheet at any time.
</p>

<p class="trans-note">【
“あきらめる（ `give up^en ）” とは、
下の注記から，
当の~stylesheetの処理を放棄するとは限らず，後回しにすることも含むようだ。
】</p>

<p class="note">注記：
~stylesheetを その読込nより前に あきらめることは、
それが最終的に読込まれるとするなら，
~scriptが不正な情報で演算する結果になることを意味する。
例えば、
その~stylesheetは，ある要素の色を緑に設定するとする。
結果の~styleを検分する~scriptは、
~stylesheetが読込まれる前に実行され，
当の要素は黒（あるいは何であれ既定の色）であると見出すことになる結果、
道を誤るかもしれない
（~pageの他所にて，緑に代えて黒を利用するよう裁定するなど）。
実装者は、［
~scriptが不正な情報を利用すること
］と［
低速な~network要請が終わるまで何もしないことによる処理能への影響i
］との兼ね合いを図る必要がある。
◎
Giving up on a style sheet before the style sheet loads, if the style sheet eventually does still load, means that the script might end up operating with incorrect information. For example, if a style sheet sets the color of an element to green, but a script that inspects the resulting style is executed before the sheet is loaded, the script will find that the element is black (or whatever the default color is), and might thus make poor choices (e.g., deciding to use black as the color elsewhere on the page, instead of green). Implementers have to balance the likelihood of a script using incorrect information with the performance impact of doing nothing while waiting for a slow network request to finish.
</p>
	</li>
</ul>

<p class="XXX">
上の規則に相当するものは、
`~xml-stylesheet$c 処理命令にも適用するものと期待される。
しかしながら、
まだ くまなく究明されていない。
◎
It is expected that counterparts to the above rules also apply to &lt;?xml-stylesheet?&gt; PIs. However, this has not yet been thoroughly investigated.
</p>

<p>
各 `文書$は、
`~scriptを阻んでいる~stylesheet集合@
を有する
— それは、
`有順序~集合$であり，初期~時は`空$とする。
◎
A Document has a script-blocking style sheet set, which is an ordered set, initially empty.
</p>

<div class="algo">
<p>
`~scriptを阻んでいる~stylesheetは在るか？@
は、
所与の
( `文書$ %文書 )
に対し，
~IS［
~OR↓
］を返す：
◎
A Document document has a style sheet that is blocking scripts if the following steps return true:
</p>
<ul>
	<li>
%文書 の`~scriptを阻んでいる~stylesheet集合$は`空$でない
◎
If document's script-blocking style sheet set is not empty, then return true.
</li>
	<li>
［
%文書 の`~node~navigable$ %N ~NEQ ~NULL
］~AND［
%N の`容器~文書$nav %D ~NEQ ~NULL
］~AND［
%D の`~scriptを阻んでいる~stylesheet集合$は`空$でない
］
◎
If document's node navigable is null, then return false.
◎
Let containerDocument be document's node navigable's container document.
◎
If containerDocument is non-null and containerDocument's script-blocking style sheet set is not empty, then return true.
◎
Return false.
</li>
</ul>

<p class="trans-note">【
%D に対しても再帰的に容器~文書を検査してはいないことに注意。
】</p>
</div>

<p>
【！不要】
◎
A Document has no style sheet that is blocking scripts if it does not have a style sheet that is blocking scripts.
</p>

			</section>
		</section>
	</section>
</main>
