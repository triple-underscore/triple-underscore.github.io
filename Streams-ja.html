<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Streams Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1') },
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'sec':
	text = ` § ${key}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'Ax'://＊
	href = `~TC39#sec-${key.toLowerCase()}`;
	break;
case 'A':
	{
		const i = key.indexOf('(');
		if(i > 0) {
			key = key.slice(0, i);
			text = key + text.slice(i).replace(/([^~])\b([A-Za-z]\w*)/g, '$1<var>$2</var>');
		}
		href = '#' + key.replace(/BYOB/g, "-byob-").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
	}
	break;
case 'm':
case 'rs':
case 'ws':
case 'dr':
case 'dw':
case 'rsdc':
case 'wsdc':
case 'byob':
case 'bbrq':
case 'rbsc':
case 'ts':
case 'tsdc':
case 'usk':
case 'usc':
case 'tf':
case 'qs':
case 'blqs':
case 'cqs':
	{
		const i = key.indexOf('(');
		if(i > 0) {
			key = key.slice(0, i);
			text = key + text.slice(i).replace(/([^~])\b([A-Za-z]\w*)/g, '$1<var>$2</var>');
		}
	}
	break;
case 'mc':
	text = 'constructor';
	href = link_map[`m.new ${key}`];
	break;
case 'jI':
	text = `%${key}%`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;
	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Streams
spec_date:2020-07-27
trans_update:2020-07-28
	source_checked:200625
spec_status:LS
original_url:https://streams.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:,whatwg
trans_1st_pub:2015-01-19


●●class_map
A:abstract
Ax:abstract
e:element
et:event-type
E:error
sl:js-slot
jI:js-intrinsic
jE:error
jv:js-value
jT:js-type
op:op

●●tag_map
i:i
sl:span
c:code
m:code
rs:code
dr:code
dw:code
ws:code
ts:code
tsdc:code
byob:code
bbrq:code
rbsc:code
rsdc:code
wsdc:code
usk:code
usc:code
spo:code
rsgo:code
rsio:code
tf:code
qs:code
qsi:code
rwp:code
blqs:code
cqs:code
brr:code
drr:code
I:code
A:span
Ax:span
v:var
e:code
et:code
E:code
strong:strong
em:em
jI:code
jE:code
jv:code
jT:code
op:span

●●original_id_map

acquire-readable-stream-default-reader:acquire-readable-stream-reader
extract-high-water-mark:validate-and-normalize-high-water-mark
extract-size-algorithm:make-size-algorithm-from-size-function
readable-stream-default-controller-has-backpressure:rs-default-controller-has-backpressure
transform-stream-default-source-pull-algorithm:transform-stream-default-source-pull

	rs-asynciterator:rs-asynciterator-prototype
	rs-asynciterator:default-reader-asynciterator-prototype-internal-slots

●●mdn_urls
bytelengthqueuingstrategy:API/ByteLengthQueuingStrategy
countqueuingstrategy:API/CountQueuingStrategy
readablebytestreamcontroller:API/ReadableByteStreamController
readablestream:API/ReadableStream
readablestreambyobreader:API/ReadableStreamBYOBReader
readablestreambyobrequest:API/ReadableStreamBYOBRequest
readablestreamdefaultreader:API/ReadableStreamDefaultReader
readablestreamdefaultcontroller:API/ReadableStreamDefaultController
writablestream:API/WritableStream
writablestreamdefaultwriter:API/WritableStreamDefaultWriter
writablestreamdefaultcontroller:API/WritableStreamDefaultController
transformstream:API/TransformStream
	transformstreamdefaultcontroller:API/TransformStreamDefaultController

●●link_map

	●IDL
EnforceRange:~WEBIDLjs#EnforceRange
Exposed:~WEBIDLjs#Exposed

unsigned long long:~WEBIDL#idl-unsigned-long-long
unrestricted double:~WEBIDL#idl-unrestricted-double
any:~WEBIDL#idl-any
object:~WEBIDL#idl-object
boolean:~WEBIDL#idl-boolean
I.unsigned long long:~WEBIDL#idl-unsigned-long-long
I.unrestricted double:~WEBIDL#idl-unrestricted-double
I.any:~WEBIDL#idl-any

E.AbortError:~WEBIDL#aborterror
E.RangeError:~WEBIDL#exceptiondef-rangeerror

I.ReadableStream:#readablestream
I.ReadableStreamDefaultReader:#readablestreamdefaultreader
I.ReadableStreamDefaultReadResult:#dictdef-readablestreamdefaultreadresult
I.ReadableStreamDefaultController:#readablestreamdefaultcontroller
I.ReadableByteStreamController:#readablebytestreamcontroller
I.ReadableStreamBYOBReader:#readablestreambyobreader
I.ReadableStreamBYOBRequest:#readablestreambyobrequest
I.ReadableStreamBYOBReadResult:#dictdef-readablestreambyobreadresult

I.WritableStream:#writablestream
I.WritableStreamDefaultWriter:#writablestreamdefaultwriter
I.WritableStreamDefaultController:#writablestreamdefaultcontroller

I.TransformStream:#transformstream
I.TransformStreamDefaultController:#transformstreamdefaultcontroller

I.ByteLengthQueuingStrategy:#bytelengthqueuingstrategy
I.CountQueuingStrategy:#countqueuingstrategy
I.QueuingStrategy:#dictdef-queuingstrategy

I.QueuingStrategySize:#callbackdef-queuingstrategysize
I.TransformerFlushCallback:#callbackdef-transformerflushcallback
I.TransformerStartCallback:#callbackdef-transformerstartcallback
I.TransformerTransformCallback:#callbackdef-transformertransformcallback
I.UnderlyingSinkAbortCallback:#callbackdef-underlyingsinkabortcallback
I.UnderlyingSinkCloseCallback:#callbackdef-underlyingsinkclosecallback
I.UnderlyingSinkStartCallback:#callbackdef-underlyingsinkstartcallback
I.UnderlyingSinkWriteCallback:#callbackdef-underlyingsinkwritecallback
I.UnderlyingSourceCancelCallback:#callbackdef-underlyingsourcecancelcallback
I.UnderlyingSourcePullCallback:#callbackdef-underlyingsourcepullcallback
I.UnderlyingSourceStartCallback:#callbackdef-underlyingsourcestartcallback

I.QueuingStrategyInit:#dictdef-queuingstrategyinit
I.ReadableStreamGetReaderOptions:#dictdef-readablestreamgetreaderoptions
I.ReadableStreamIteratorOptions:#dictdef-readablestreamiteratoroptions
I.ReadableWritablePair:#dictdef-readablewritablepair
I.StreamPipeOptions:#dictdef-streampipeoptions
I.Transformer:#dictdef-transformer
I.UnderlyingSink:#dictdef-underlyingsink
I.UnderlyingSource:#dictdef-underlyingsource

I.ReadableStreamReaderMode:#enumdef-readablestreamreadermode
I.ReadableStreamType:#enumdef-readablestreamtype

I.ReadableStreamController:#typedefdef-readablestreamcontroller
I.ReadableStreamReader:#typedefdef-readablestreamreader

I.ArrayBufferView:~WEBIDL#ArrayBufferView

I.Response:~FETCH#response
I.WebSocket:~WEBSOCKET#websocket
I.ArrayBuffer:~TC39#sec-arraybuffer-objects
I.Uint8Array:~TC39#sec-typedarray-objects
I.DataView:~TC39#sec-dataview-objects
I.AbortSignal:~DOM4#abortsignal
I.AbortController:~DOM4#abortcontroller
I.Function:~WEBIDL#Function

m.fetch:~FETCH#dom-global-fetch
m.bufferedAmount:~WEBSOCKET#dom-websocket-bufferedamount


jT.Number:~TC39#sec-ecmascript-language-types-number-type

	●#ws- #rs- #byob- #default-reader- #default-writer-
m.new ReadableStream:#rs-constructor
rs.locked:#rs-locked
rs.cancel:#rs-cancel
rs.getReader:#rs-get-reader
rs.pipeThrough:#rs-pipe-through
rs.pipeTo:#rs-pipe-to
rs.tee:#rs-tee

m.new ReadableStreamDefaultController:#rs-default-controller-constructor
rsdc.desiredSize:#rs-default-controller-desired-size
rsdc.close:#rs-default-controller-close
rsdc.enqueue:#rs-default-controller-enqueue
rsdc.error:#rs-default-controller-error
rsdc.[[CancelSteps]]:#rs-default-controller-private-cancel
rsdc.[[PullSteps]]:#rs-default-controller-private-pull

m.new ReadableStreamDefaultReader:#default-reader-constructor
dr.closed:#default-reader-closed
dr.cancel:#default-reader-cancel
dr.read:#default-reader-read
dr.releaseLock:#default-reader-release-lock

m.new ReadableByteStreamController:#rbs-controller-constructor
rbsc.byobRequest:#rbs-controller-byob-request
rbsc.desiredSize:#rbs-controller-desired-size
rbsc.close:#rbs-controller-close
rbsc.enqueue:#rbs-controller-enqueue
rbsc.error:#rbs-controller-error
rbsc.[[CancelSteps]]:#rbs-controller-private-cancel
rbsc.[[PullSteps]]:#rbs-controller-private-pull

m.new ReadableStreamBYOBReader:#byob-reader-constructor
byob.closed:#byob-reader-closed
byob.cancel:#byob-reader-cancel
byob.read:#byob-reader-read
byob.releaseLock:#byob-reader-release-lock

bbrq.view:#rs-byob-request-view
bbrq.respond:#rs-byob-request-respond
bbrq.respondWithNewView:#rs-byob-request-respond-with-new-view

drr.done:#dom-readablestreamdefaultreadresult-done
drr.value:#dom-readablestreamdefaultreadresult-value

brr.done:#dom-readablestreambyobreadresult-done
brr.value:#dom-readablestreambyobreadresult-value

m.new WritableStream:#ws-constructor
ws.locked:#ws-locked
ws.abort:#ws-abort
ws.close:#ws-close
ws.getWriter:#ws-get-writer

m.new WritableStreamDefaultWriter:#default-writer-constructor
dw.closed:#default-writer-closed
dw.close:#default-writer-close
dw.desiredSize:#default-writer-desired-size
dw.ready:#default-writer-ready
dw.abort:#default-writer-abort
dw.releaseLock:#default-writer-release-lock
dw.write:#default-writer-write

m.new WritableStreamDefaultController:#ws-default-controller-constructor
wsdc.error:#ws-default-controller-error

wsdc.[[AbortSteps]]:#ws-default-controller-private-abort
wsdc.[[ErrorSteps]]:#ws-default-controller-private-error

m.new TransformStream:#ts-constructor
ts.readable:#ts-readable
ts.writable:#ts-writable

m.new TransformStreamDefaultController:#ts-default-controller-constructor
tsdc.desiredSize:#ts-default-controller-desired-size
tsdc.enqueue:#ts-default-controller-enqueue
tsdc.error:#ts-default-controller-error
tsdc.terminate:#ts-default-controller-terminate

tf.flush:#dom-transformer-flush
tf.start:#dom-transformer-start
tf.transform:#dom-transformer-transform
tf.readableType:#dom-transformer-readabletype
tf.writableType:#dom-transformer-writabletype

qs.highWaterMark:#dom-queuingstrategy-highwatermark
qs.size:#dom-queuingstrategy-size

m.new ByteLengthQueuingStrategy:#blqs-constructor
blqs.size:#blqs-size
blqs.highWaterMark:#blqs-high-water-mark

m.new CountQueuingStrategy:#cqs-constructor
cqs.size:#cqs-size
cqs.highWaterMark:#cqs-high-water-mark

usk.abort:#dom-underlyingsink-abort
usk.close:#dom-underlyingsink-close
usk.start:#dom-underlyingsink-start
usk.write:#dom-underlyingsink-write
usk.type:#dom-underlyingsink-type

usc.autoAllocateChunkSize:#dom-underlyingsource-autoallocatechunksize
usc.cancel:#dom-underlyingsource-cancel
usc.pull:#dom-underlyingsource-pull
usc.start:#dom-underlyingsource-start
usc.type:#dom-underlyingsource-type

spo.preventAbort:#dom-streampipeoptions-preventabort
spo.preventCancel:#dom-streampipeoptions-preventcancel
spo.preventClose:#dom-streampipeoptions-preventclose
spo.signal:#dom-streampipeoptions-signal

qsi.highWaterMark:#dom-queuingstrategyinit-highwatermark
rsio.preventCancel:#dom-readablestreamiteratoroptions-preventcancel
rsgo.mode:#dom-readablestreamgetreaderoptions-mode
rwp.readable:#dom-readablewritablepair-readable
rwp.writable:#dom-readablewritablepair-writable

l.byob:#dom-readablestreamreadermode-byob
l.bytes:#dom-readablestreamtype-bytes

	●IDL 引数
	#dom-underlyingsourcestartcallback-controller
	#dom-underlyingsourcepullcallback-controller
	#dom-underlyingsourcecancelcallback-reason
	#dom-readablestreamdefaultreader-readablestreamdefaultreader-stream-stream
	#dom-readablestreamdefaultreader-cancel-reason-reason
	#dom-readablestreambyobreader-readablestreambyobreader-stream-stream
	#dom-readablestreambyobreader-cancel-reason-reason
	#dom-readablestreambyobreader-read-view-view
	#dom-readablestreamdefaultcontroller-enqueue-chunk-chunk
	#dom-readablestreamdefaultcontroller-error-e-e
	#dom-readablebytestreamcontroller-enqueue-chunk-chunk
	#dom-readablebytestreamcontroller-error-e-e
	#dom-readablestreambyobrequest-respond-byteswritten-byteswritten
	#dom-readablestreambyobrequest-respondwithnewview-view-view
	#dom-underlyingsinkstartcallback-controller
	#dom-underlyingsinkwritecallback-controller
	#dom-underlyingsinkwritecallback-chunk
	#dom-underlyingsinkabortcallback-reason
	#dom-writablestream-writablestream-underlyingsink-strategy-underlyingsink
	#dom-writablestream-writablestream-underlyingsink-strategy-strategy
	#dom-writablestream-abort-reason-reason
	#dom-writablestreamdefaultwriter-writablestreamdefaultwriter-stream-stream
	#dom-writablestreamdefaultwriter-abort-reason-reason
	#dom-writablestreamdefaultwriter-write-chunk-chunk
	#dom-writablestreamdefaultcontroller-error-e-e
	#dom-transformstream-transformstream-transformer-writablestrategy-readablestrategy-transformer
	#dom-transformstream-transformstream-transformer-writablestrategy-readablestrategy-writablestrategy
	#dom-transformstream-transformstream-transformer-writablestrategy-readablestrategy-readablestrategy
	#dom-transformerstartcallback-controller
	#dom-transformerflushcallback-controller
	#dom-transformertransformcallback-controller
	#dom-transformertransformcallback-chunk
	#dom-transformstreamdefaultcontroller-enqueue-chunk-chunk
	#dom-transformstreamdefaultcontroller-error-reason-reason
	#dom-queuingstrategysize-chunk
	#dom-bytelengthqueuingstrategy-bytelengthqueuingstrategy-init-init
	#dom-countqueuingstrategy-countqueuingstrategy-init-init
	#dom-readablestream-readablestream-underlyingsource-strategy-underlyingsource
	#dom-readablestream-readablestream-underlyingsource-strategy-strategy
	#dom-readablestream-cancel-reason-reason
	#dom-readablestream-getreader-options-options
	#dom-readablestream-pipethrough-transform-options-transform
	#dom-readablestream-pipethrough-transform-options-options
	#dom-readablestream-pipeto-destination-options-destination
	#dom-readablestream-pipeto-destination-options-options
	#dom-readablestream-options

	●抽象演算

sl.CancelSteps:#abstract-opdef-readablestreamcontroller-cancelsteps
sl.PullSteps:#abstract-opdef-readablestreamcontroller-pullsteps
sl.AbortSteps:#abstract-opdef-writablestreamcontroller-abortsteps
sl.ErrorSteps:#abstract-opdef-writablestreamcontroller-errorsteps

A.Type:~TC39#sec-ecmascript-data-types-and-values
A.StructuredDeserialize:~HTMLcloning#structureddeserialize
A.StructuredSerialize:~HTMLcloning#structuredserialize
	A.TransformStreamDefaultSourcePullAlgorithm:#transform-stream-default-source-pull-algorithm

	■ TC39（Ax.XXX:~TC39#sec-xxx ( lowercase )
	Ax.CloneArrayBuffer
	Ax.Construct
	Ax.CopyDataBlockBytes
	Ax.CreateArrayFromList
	Ax.CreateBuiltinFunction
	Ax.DetachArrayBuffer
	Ax.GetV
	Ax.IsDetachedBuffer
	Ax.IsInteger
	Ax.SetFunctionLength
	Ax.SetFunctionName

	●用語
~chunk:#chunk
可読~stream:#readable-stream
下層~源:#underlying-source
~pull源:#pull-source
~push源:#push-source
消費器:#consumer
取消す:#cancel-a-readable-stream
取消され:#cancel-a-readable-stream
取消して:#cancel-a-readable-stream
取消n:#cancel-a-readable-stream
二叉化-:#tee-a-readable-stream
分岐:#branches-of-a-readable-stream-tee
下層~byte源:#underlying-byte-source
可読~byte~stream:#readable-byte-stream
可書~stream:#writable-stream
下層~槽:#underlying-sink
生産器:#producer
中止-:#abort-a-writable-stream
中止する:#abort-a-writable-stream

形式変換~stream:#transform-stream
~identity形式変換~stream:#identity-transform-stream
可書~側:#writable-side
可読~側:#readable-side
形式変換器:#transformer

~pipeする:#piping
~pipe:#piping
~pipe鎖:#pipe-chain
元の源:#original-source
最終~槽:#ultimate-sink
背圧:#backpressure
内部~queue:#internal-queues
~queuing策:#queuing-strategy
~byte長さ~queuing策~size関数:#byte-length-queuing-strategy-size-function
~count~queuing策~size関数:#count-queuing-strategy-size-function
限界水位:#high-water-mark
~streamの内部~queueの残り~size:#desired-size-to-fill-a-streams-internal-queue

可読~stream読取器:#reader
読取器:#reader
非同期c読取器:#readablestream-async-iterator-reader
取消-を防止する？:#readablestream-async-iterator-prevent-cancel
既定の読取器:#default-readers
~BYOB読取器:#byob-readers

可書~stream書込器:#writer
書込器:#writer

作動中:#active

~lock:#lock
~lockされて:#lock
~lockを解放-:#release-a-lock
解放-:#release-a-lock

完結する:#rs-pipeTo-finalize
~shutdownする:#rs-pipeTo-shutdown-with-action
	#rs-pipeTo-shutdown
転送され:#transfer-array-buffer

可読~byte~stream用の~queue~entry:#readable-byte-stream-queue-entry
qE.~buffer:#readable-byte-stream-queue-entry-buffer
qE.~byte~offset:#readable-byte-stream-queue-entry-byte-offset
qE.~byte長さ:#readable-byte-stream-queue-entry-byte-length

~pull~into記述子:#pull-into-descriptor
pD.~buffer:#pull-into-descriptor-buffer
pD.~byte~offset:#pull-into-descriptor-byte-offset
pD.~byte長さ:#pull-into-descriptor-byte-length
pD.~fill済み~byte数:#pull-into-descriptor-bytes-filled
pD.要素~size:#pull-into-descriptor-element-size
pD.~view構築子:#pull-into-descriptor-view-constructor
pD.読取器~型:#pull-into-descriptor-reader-type

処理待ち中止-要請:#pending-abort-request
aR.~promise:#pending-abort-request-promise
aR.事由:#pending-abort-request-reason
aR.すでに~errorした:#pending-abort-request-was-already-erroring

i.~close~sentinel:#close-sentinel

~sizeを伴う値:#value-with-size
Vs.値:#value-with-size-value
Vs.~size:#value-with-size-size

中へ読取する要請:#read-into-request
riR.~chunk手続き:#read-into-request-chunk-steps
riR.~close手続き:#read-into-request-close-steps
riR.~error手続き:#read-into-request-error-steps
読取n要請:#read-request
rR.~chunk手続き:#read-request-chunk-steps
rR.~close手続き:#read-request-close-steps
rR.~error手続き:#read-request-error-steps

	●§
sec.個別~size付き~queue:#queue-with-sizes
sec.制御器との~interface法:#rs-abstract-ops-used-by-controllers
sec.下層~push源を伴う可読~stream（背圧~supportなし）:#example-rs-push-no-backpressure
sec.下層~pull源を伴う可読~stream:#example-rs-pull
sec.下層~push源を伴う可読~stream（背圧~supportあり）:#example-rs-push-backpressure
sec.下層~push源を伴う可読~byte~stream（背圧~supportなし）:#example-rbs-push
sec.下層~pull源を伴う可読~byte~stream:#example-rbs-pull
sec.下層~槽~API:#underlying-sink-api
sec.下層~源~API:#underlying-source-api
sec.~queuing策~API:#qs-api
sec.背圧や成功の通達を伴わない可書~stream:#example-ws-no-backpressure
sec.背圧や成功の通達を伴う可書~stream:#example-ws-backpressure
sec.形式変換器~API:#transformer-api
sec.~template内の~tagを置換する形式変換~stream:#example-ts-lipfuzz


	●用語（外部
	●ES6
c.Array.prototype.map:~TC39#sec-array.prototype.map
jE.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

jI.ArrayBuffer:~TC39#sec-arraybuffer-constructor
jI.Uint8Array:~TC39#sec-typedarray-objects
jI.DataView:~TC39#sec-dataview-constructor

有型~配列:~TC39#sec-typedarray-objects
現在の~Realm:~TC39#current-realm
大域~obj:~TC39#global-object
~realm:~TC39#realm
完了~record:~TC39#sec-completion-record-specification-type
抽象-演算:~TC39#sec-algorithm-conventions-abstract-operations
内部~slot:~TC39#sec-object-internal-methods-and-internal-slots
	中途完了:~TC39#sec-completion-record-specification-type

	●WEBIDL/promise
~platform~obj:~WEBIDL#dfn-platform-object
~callback文脈:~WEBIDL#dfn-callback-context
i.反復~終端-:~WEBIDL#end-of-iteration
非同期~反復子の~return手続き:~WEBIDL#asynchronous-iterator-return
非同期~反復子の初期化~手続き:~WEBIDL#asynchronous-iterator-initialization-steps
次回の反復~結果を取得する手続き:~WEBIDL#dfn-get-the-next-iteration-result

新たな~promise:~WEBIDLjs#a-new-promise
却下する:~WEBIDLjs#reject
解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決される~promise:~WEBIDLjs#a-promise-resolved-with
すべてを待機する~promiseを取得する:~WEBIDLjs#waiting-for-all-promise
充足-時:~WEBIDLjs#upon-fulfillment
却下-時:~WEBIDLjs#upon-rejection
反応-:~WEBIDLjs#dfn-perform-steps-once-promise-is-settled
切離され:~WEBIDLjs#dfn-detach

新たな:~WEBIDLjs#new
実装しない:~WEBIDLjs#implements
実装する:~WEBIDLjs#implements
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
~methodを呼出せる:~WEBIDLjs#invoke-a-callback-function
	~callback~this値:~WEBIDLjs#dfn-callback-this-value
~IDL値に変換-:~WEBIDLjs#dfn-convert-ecmascript-to-idl-value

~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

要請~本体:~FETCH#concept-request-body

並列的:~HTMLINFRA#in-parallel
	転送する:~HTMLcloning#transferable-objects
直列化-可能:~HTMLcloning#serializable-objects

aB.中止-済み~flag:~DOM4#abortsignal-aborted-flag
通達に~algoを追加する:~DOM4#abortsignal-add
通達から~algoを除去する:~DOM4#abortsignal-remove

大域~obj:~WAPI#global-object
関連な~Realm:~WAPI#concept-relevant-realm
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
小taskを~queueする:~WAPI#queue-a-microtask

e.img:~HEimages#the-img-element
et.fetch:~SW1#service-worker-global-scope-fetch-event
et.unhandledrejection:~HTMLindex#event-unhandledrejection

	:#example-manual-write-batch
	:#note-web-socket-wrapping-examples
	:#example-manual-write-batch
	:https://github.com/w3c/webrtc-pc/issues/1732#issuecomment-358428651
	:#note-web-socket-wrapping-examples

_acks1:#_acks1

●●words_table1

●●words_table


	●stream
streaming::::ストリーミング
BYOB:
書込させ:writeさせ::書込ませ
書込され:writeされ::書込まれ
書込し:writeし::書込み
書込した:writeした::書込んだ
書込して:writeして::書込んで
書込しな:writeしな::書込まな
書込しよ:writeしよ::書込も
書込する:writeする::書込む
書込でき:writeでき::書込め
書込み:writing::書込み
書込n:write::書込み
書込器:writer::書込み器
可書:writable::書込める

読取させ:readさせ::読取らせ
読取され:readされ::読取られ
読取しま:readしま::読取りま
読取した:readした::読取った
読取して:readして::読取って
読取しな:readしな::読取らな
読取しよ:readしよ::読取ろ
読取する:readする::読取る
読取でき:readでき::読取れ
読取り:reading::読取り
読取n:read::読取り
読取器:reader::読取り器
可読:readable::読取れる
	読取n可能:readable
	write:::::
	read:::::
	readable:::::
	reader:::::
	reading:::::
形式変換:transform::~
形式変換n:transformation::形式変換
形式変換器:transformer::~
identity:
pipe::::パイプ
	配管する／管
piping::::パイプ
	~pipeする処理n:piping process
in-flight:
	
二叉化-:tee::~
二叉化:teeing::~
分岐:branch::~::ブランチ
分岐-:branch::~::ブランチ

鎖:chain::~::チェイン
槽:sink::~::シンク
最終:ultimate::~
	~lock法:locking
	~lock中にある:locking
	錠
解放-:release::~
獲得-:acquire::~
	施錠
	開錠／解錠
側:side:~
包装-:wrap::~
包装:wrapping::~
	包装を外す:unwrapping
入出力:I/O:~
静止-:pause::~
close:::::クローズ
	closed:
	errored:
	~cancel:::::キャンセル
	cancellation:::::キャンセル
終了-:terminate::~
排他的:exclusive::~

制御器:controller::~::コントローラ
制御先の:controlled::~
消費-:consume::~::コンシューム
消費:consumption::~
消費器:consumer::~::コンシューマ
生産-:produce::~::プロデュース
生産器:producer::~::プロデューサ
生産:production::~::プロダクション
変換器:converter::~::コンバータ
状態machine:state machine::状態 machine:状態マシン
	:ステートマシン

	作成する間:during creation of
翻訳-:translate::~
圧縮-:compress::~
	圧縮-済み:compressed
未圧縮の:uncompressed::~
圧縮器:compressor::~
解凍-:decompress::~
解凍:decompression::~
復号処理:decoding::~::デコード処理

	listen:::::
割振り:allocation:割り振り
割振っ:allocateし:割り振っ
割振る:allocateする:割り振る

中間的:intermediate::~
配給-:vend:供給
給-:supply:~
shutdown:
shut-down:shut down
closing:
	~closeし終える:closing down／finishes closing
closure:
into:
	~pull~into:pull-into
sentinel:::番

旅する:travelする:~
測定-:measure:~
	~~湧き出:comes out
	~~流れ込む:goes in
	送り込む:forward

	●queuing strategy
策:strategy::~::ストラテジー
	strategy
	合図
背圧:backpressure::~
正常化:normalize:~

満杯:full::~
	溢れる:over-full
	溢れ:overflowing
	落ち込んだ:dips
限界水位:high-water mark::~
chunk::::チャンク
enqueue:
fill:
	~fill済み~byte数:bytes filled
count:
queue:
queuing:
	~queueしておく:queue up
	個別~size付き~queue:queue-with-sizes
	~sizeを伴う値:value-with-size
合計:total::~
rate::::レート
流入:incoming:流入してくる
buffering::::バッファ処理
流す:flowする:~:::フローする
流れ:flow:~:::フロー
回送-:forward::~
増分的:incremental::~
高速:fast:~

	slower
減速-:slow down:~
止める:stopする::~
	数え:count
	~chunk数による:count
正解の:rightな:~
	使用量:usage

	手を止めて:back off
	捨てら:throw away さ
	減らす:cut down
	素早く:quickly
	時間あたりの流量は低下:low throughput
	~byte数による:byte-length
	~byte数:number of bytes
	~byte数:bytes

	●promise
promise-calling:
	用の~promise:promise-for-
	却下-時:upon rejection
	充足-時:upon fulfillment
決着-:settle:~
処理待ち:pending::~
	順番待ちの
成否:success or failure::~

	●idl／js／データ型／データ操作

	設定しておけば:this setup
	設定しておく:set up／setup
作成子:creator::~::クリエータ
truthy:
無名:anonymous:~

prototype::::プロトタイプ
	投出し直-:re-throw

集成-:aggregate::~
組立てる:composeする:~
	composition
組立可能:compose 可能:組立て可能
	組立可能:composable
加算-:add::~
累積-:accumulate::~
累積:accumulation::~
置換s-:substitute::置換
置換s:substitution::置換
普通の:ordinary::~
切離され:detachされ::切り離され
	そのまま:unchanged

	●処理一般
return:
弱い:weakな::~
中途完了:abrupt completion::~
中途で:abruptに::~
遷移:transition::~
開始処理:starting::~
	~~再開:restart
差挟まれ:interleaveされ:差し挟まれ
差挟む:interleaveする:差し挟む
	interruption
	し終える:finish
片付けれ:clean upでき::~
片付けて:clean upして::~
片付ける:clean upする::~
完結-:finalize::~
再入:reentrant::~
進行中の:ongoing::~
監視-:monitor::~
致命的:fatal::~
	~catchせずに:un-caught
断続的:continual:~
多形態的:polymorphic::~
速度:speed:~
円滑:smooth:~
	円滑に変速する:smooth out variations in the speed
実時間:real time:::リアルタイム
自動-:auto-::~
	効率的でない:inefficient
絶えず:constantに:~
冪等:idempotent::~
移行-:move::~
memory::::メモリ
契約:contract::~
小task:microtask::小 task:小タスク
切替える:switchする:切り替える

	~call元:caller
	calling
	~callした
	引き続き~call:call through
	渡-:pass
	通過:pass through
	遡って:back through
	不具合:gone wrong
	不具合が生じた:goes wrong
	失った:loss した
	済み:done
	行われ:done
	伝える:tell する／inform する
	伝わり:inform され
	開始時:startup-time
	何も返さない:not return anything
	何もせず黙する:silently do nothing
	何もしない:do nothing
	何もしない:no-op
	不定期の間:indefinitely
	成り行き:outcome
	より早く:sooner
	事前に:ahead of time
	先んじて:ahead of
	吸い取る:swallow
	投出し直す:rethrow

	●仕様
WebIDL:Web IDL
framework::::フレームワーク
ecosystem::::エコシステム
polyfill:
基準:reference:~
規範:reference:~
句:phrase:~
創出-:create:~
略記:shorthand:~
方式f:fashion:方式
	目的をもって:purposefully
基本的な:base:~
基礎:basis:~
土台:foundation:~
選択的:selective:~
部品:part:~
方法:how:~
変種:variant:~
仮説上の:hypothetical:仮想の
無差別的:indiscriminate:~
手動的:manual:~
演習:exercise:~
柔軟性:flexibility:~
柔軟:flexible:~
非対称性:asymmetry:~
活動:activity:~
裁量:discretion:~
事前条件:preconditions:~
役立たず:useless:~
堅牢性:robustness:~
自明:trivial:~
良実践:good practice:良い実践
簡潔:concise:~
現実の:real:~
非生産的:counterproductive:~
変則的:strange:~
背景情報:background:~
背景:background:~
	直な

	主に:mainly
	抽象-化して見えなくする:abstract away
	経緯:scenario
	ごく~~普通にあり得る:quite possible
	場合もある:possibly
	切り離され:decouple
	扱いにくい:awkward
	区別:distinction:
	必要:has to
	沿う:along
	〜に基づかない:non-〜-based
	-:fairly
	thank
	ほとんどは:mostly
	次のようになる:it would look like
	手間をかけず:without much ceremony
	もちろん:of course
	当の:in question
	以降を通して:throughout the rest:
	ほぼ同様:much like
	注目すべきは:Notably
	打開策:breakthrough idea
	〜限り:as long as／so long as
	何であれ，:regardless of
	に文書化されている:stated in the documentation for
	相当部分:large swathes
	何故なら:because
	本質的には，:In essence,
	当面の間は，:in the meantime,
	〜を利用すれば、:We can then use 〜
	これを使えば、With this in hand,
	但し書き:caveats
	~~構成:factoring
	以降の:future
	多様になり得る:potentially-varying
	なり得る:potential
	裏で:Under the covers,
	裏では:backing
	裏:backing
	満ちている:full of
	別として:apart from
	上述とは別方向の:go in the other direction
	〜は別として:apart from
	要る:-
	誰か:people
	いずれにせよ:regardless
	言うまでもなく、〜に注意:It’s also worth noting that
	:editor
	:we
	に応じて:aware
	~~重複する:redundant
	追加されなくとも:But even without that factor
	であろう:likely
	これについて:subject
	べきである:ought to
	~~際どい:edge
	するわけにはいかない:cannot let 〜 happen

refactor::::リファクター
	refactoring
encapsulate::::カプセル化
働き:work:~
	reusable
統一化-:unify:~
統一的な:single, unified:~
	きちんと設計されたwell-designed:
実体化-:embody:~
具象-:concrete:~
	具体的には:concretely
希望-:hope:~
尊重-:respect:~
確信-:believe:~
拡張d:extended:拡張
拡張p-:expand:拡張
成長-:grow:~
適応-:adapt:~
適応:adaptation:~
	interference
集中-:centralize:~
注力-:concern:~
続行-:proceed:~
迂回-:bypass:~
浪費-:waste:~
関心:interest:~
警告:warning:~
寄与-:contribute:~
集中-:centralize:~
承認-:acknowledge:~
外来の:foreignな:~
機構:machinery:~
理論上の:theoreticalな:~

	可能になる／可能にする／〜になれる
	不意に:unexpectedly
	単純にするため:for simplicity
	略して:simply
	要する
	予め決定-済み:predetermined
	とする:assuming
	specialization
	不可避になる:unavoidably result
	contribution
	ensuring:
	ヤリトリ:interact with
	やりとりする:interface する
	要因になる:factored in to
	別法として:alternatively
	もたらす:introduce
	外から見える:noticeable
	興味を引く:interesting
	想起:evocative
	至らせ:lead
	先駆的:pioneering
	気にする:regardする
	についての:regarding
	〜し易くする:help
	心配する:worry
	手入れ:take care
	~~対処-:deal with
	~~扱う:dealing with
	にあたる:consult する
	面する:-facing
	呼ばれ:refer／call／known
	待って:wait して
	言-:say
	力点を置いて:focus して
	尊重:ensure 〜 respect
	~~想定:imagine／-
	involvement
	made
	cause
	causing
	regard
	-:consider
	~~働き:serve
	橋渡し:bridging the gap
	話す:talk
	〜に注意:remember
	もっとはっきりさせる:further emphasize
	~~露わになる:manifesting
	~~問題:matter
	そうなり得る:could become so
	それに伴われる:come along for the ride
	整理:clean up
	ままにしておく:leave
	促進させる:encouraging
	動機にある:motivated
	多分に:largely
	失われ:lose
	~~便利用:utility
	書くとき:writing
	~~利用する:usage
	-:equal
	各種:various
	寄せ集め:grab-bag
	主要な:major
	情報片:piece
	低~levelな:low-level
	より低~level:lower-level
	高~levelな:high-level
	高~levelから:higher level
	より高~level:higher level
	^en:out of the box
	に代えて:in lieu of
	-:In what follows
	価する:worth

	●未分類
install::::インストール
seek::::シーク
	observing
	観測-不能:unobservable
	観測-可能でない:not observable
	等価に観測される:observably equivalent
書出す:flushする:書き出す
書出し:flushing:書き出し
	探されlook for

	転換-:turn into
遭遇-:encounter:~
保存-:save:~
連絡-:entangle::~
接頭-:prefix:~
接尾-:suffix:~
見出し:heading:~
増やす:increaseする:~
増やさ:increaseさ:~
維持-:retain:~
表面化-:surface:~
領域:region:~
ECMAScript:
TCP:
	URL:
	PNG:
	HTTP:
	GZIP:
	CSV:
	Object:
archive::::アーカイブ
bitmap::::ビットマップ
clean:
disk::::ディスク
effect::効果
handle::::ハンドル
	~interface化する:interfacing
kernel::::カーネル
lifecycle:
mod:
multimedia::::マルチメディア
polling::::ポーリング
public:::公開::パブリック
random::::ランダム
remote::::リモート
socket:::::ソケット
stateful:
video::::ビデオ
窓:window::~::ウィンドウ
一覧:table:表
記憶域:memory::~::メモリ
複合的:composite::~
帯域外:out-of-band:~
最終的:eventual:~
	~~最終的:final
量:amount:~
展示:gallery:~
透過的:transparent::~
不可分:atomic::~
単位:unit:~
背後:behind:~
機会:chance:~
遠隔の:remote::~
形:form:~
log::::ログ

	見る:looking at
	現れる:appear する
	done
	見えなくさせられる hide
	doing
	going
	表す:express
	become
	置-:put
	放置:leave
	come
	go
	~~代入:alias
	~~要請~listen
	あり続ける:stay
	追跡し続ける:keep track
	運び続ける:shuttling
	保つ:keep
	destructuring
	再び／-:back to
	-:present
	与えられていない:missing
	なる:become
	置く:place／put
	先頭へ一つずらす:shifting all other elements downward
	させ:cause
	同じようになる:look the same,
	放った:leaving
	そのまま:letting
	し続ける:continue
	%大域~obj:globalObject
	ε:missing
	引数をとらない:no-argument
	片:fragment

	~LTE 0:non-positive
	0 以下:non-positive
	~GT 0:is positive

	変異-可能:not immutable
	大域~obj間:inter-global
	負でも `NaN^jvでもない:non-negative, non-NaN

number:
精度:precision::~
倍精度:double-precision::~
浮動小数点:floating-point::~
算術:arithmetic::~
変動幅:variance:~
	数 100 京 個の:trillions
	莫大:huge
	丸め誤差:rounding error
	限りがある:limit
正規表現:regular expression::~
template::::テンプレート
	unescaped／escaping
mapper:

	OS:OS
	組み:trio
	片:piece
	行:line
	連なり:successive
	各部:portions
	形:form
	数:number
	負でない:nonnegative
	false
	his
	中身:what type of ~ under the cover
	WHILE:repeat
	ロゴ:logo
	小さ:small
	大き:large
	低く:low

	●指示語
再度:again:再び
以前:previous:~
以前の:previous:~
	それまで:previously
後方:backward:~
前方:forward:~
次回の:next:~
余分:extra:~
繰返し:repeatedly:繰り返し

	様々な:variety
	〜を成す大部分:most of
	-:at least one
	後続の:all other
	後続して:subsequently
	間:duration
	まだ:still
	まだ:yet
	〜次第:whenever
	when
	以降:rest of／
	稀:rare
	周りで:around
	2 回目~以降:After the first time
	部位:part
	多い:frequently
	総計〜程の: 〜 worth of
	extent
	nobody
	point
	special
	higher
	ever
	until
	全く:at all
	per
	once
	like
	いくつかの:couple
	この時点で:At this point
	の場合には:time
	-:time
	同時に:at the same time,
	各回に 1 個ずつ:one at a time
	一度に:at a time
	一度に:one go
	一度も:without 〜 ever
	一度でも:ever
	先頭:first
	末尾:final
	ちょうど~~同じく:just asに
	どこかで:ever
	それ全体として:in its entirety
	順に:in sequence
	その他の:miscellaneous
	外側:outside
	種々の:various
	一定の:certain
	それはまた、:finally
	入るまで:before〜finally
	何か他のもの:something else
	総:overall
	前述の:the earlier
	さもなければ:otherwise
	何らかの／多少の:some
	-:originally
	何回:how many times
	毎回:each time／At each step
	ときどき:sometimes
	ごく:very
	高い:larger
	互いに:together
	一部分:portion
	一種:a type of
	〜中の:in the middle of being
	〜したなら:once
	-:eventually
	'／'／同順:respective／:respectively
	〜すぎる:too


●●ref_normative

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.es/ecma262/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[IEEE-754]
    IEEE Standard for Floating-Point Arithmetic. 29 August 2008. URL: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[WebIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[SERVICE-WORKERS]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGにより公開された
<a href="https://streams.spec.whatwg.org/">Streams Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/streams">GitHub whatwg/streams</a> (<a href="https://github.com/whatwg/streams/issues/new">new issue</a>, <a href="https://github.com/whatwg/streams/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	<a href="https://github.com/whatwg/streams/commits">GitHub whatwg/streams/commits</a>
	<a href="https://streams.spec.whatwg.org/commit-snapshots/505edd79173cb4a348df094c4e21d15928964602" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/streamsstandard">@streamsstandard</a>

テスト
	<a href="https://github.com/web-platform-tests/wpt/tree/master/streams">web-platform-tests streams/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/streams">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）
デモ
	https://streams.spec.whatwg.org/demos/

</script>

</head>

<body class="whatwg">

	<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KCjxjaXJjbGUKCWN4PSI1MCIgY3k9IjUwIiByPSI0NSIKCWZpbGw9IiNmZmYiCglzdHJva2U9IiMzYzc5MGEiCglzdHJva2Utd2lkdGg9IjEwIgovPgoKCTxnIHN0cm9rZT0iIzNjNzkwYSIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiPgo8IS0tIG91dGxpbmUgLS0+CjxwYXRoIHN0cm9rZS13aWR0aD0iMyIgZD0iCk04LDMwLjUgaDQyCk04LDY5LjUgaDQyCk00OS41LDI2LjUgaDEzIHY0NyBoLTEzIHoKIiAvPgoKPCEtLSBpbm5lciBsaW5lcyAtLT4KPHBhdGggc3Ryb2tlLXdpZHRoPSIxMiIgZD0iTTgsNTcgaDQyIiAvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjE0IiBkPSJNNTAsNTcgaDEwIiAvPgoKPHBhdGggc3Ryb2tlLXdpZHRoPSIyIiBkPSJNOCwzNiBoNDIgbTAsLTIgaDEwIiAvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjEiIGQ9IgpNOCw0OC41IGg0MgptMCwtMSBoOS41IHYyNQpNNTkuNSwyNyB2NwoiIC8+Cgo8IS0tIGhhbGYtdG9uZSBzaGFkaW5nIC0tPgo8cGF0aAoJc3Ryb2tlLWRhc2hhcnJheT0iMSwxIgoJZD0iCk04LDYzLjUgaDQwCm0wLDEgaC00MAptMCwxIGg0MAptMCwxIGgtNDAKbTAsMSBoNDAKCk01OSw2NC41IGgtOAptMCwxIGg4Cm0wLDEgaC04Cm0wLDEgaDgKbTAsMSBoLTgKbTAsMSBoOAoiIC8+Cgk8L2c+Cgo8L3N2Zz4K"
></a>
	<hgroup>
<h1 id="title">Streams</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
この仕様は、~data~streamを
— 低~levelな入出力~primitiveに効率的に対応付けるように —
［
作成する／組立てる／消費する
］ための~APIを，供する。
◎
This specification provides APIs for creating, composing, and consuming streams of data that map efficiently to low-level I/O primitives.
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~platformの相当部分は、~streaming~data上に築かれている：
すなわち，~dataは、全部を記憶域~内に読取することなく，増分的な方式fで、作成され, 処理され, 消費される。
Streams 標準は、そのような~streaming~dataを作成したり, それを~interface化するための，共通な~APIの集合を供する
— それは
`可読~stream$,
`可書~stream$,
`形式変換~stream$
として実体化される。
◎
Large swathes of the web platform are built on streaming data: that is, data that is created, processed, and consumed in an incremental fashion, without ever reading all of it into memory. The Streams Standard provides a common set of APIs for creating and interfacing with such streaming data, embodied in readable streams, writable streams, and transform streams.
</p>

<p>
これらの~APIは、低~levelな入出力~primitiveに効率的に対応付けられるよう，設計されている
— 適切な所では~byte~stream用に特化することも含めて。
それは、複数の~streamからなる`~pipe鎖$を容易に組立てることや，
`読取器$／`書込器$を介して直に利用することを可能にする。
それはまた、`背圧$と~queuingを自動的に供するよう，設計されている。
◎
These APIs have been designed to efficiently map to low-level I/O primitives, including specializations for byte streams where appropriate. They allow easy composition of multiple streams into pipe chains, or can be used directly via readers and writers. Finally, they are designed to automatically provide backpressure and queuing.
</p>

<p>
この標準は、~web~platformを成す各~部品が，自身の~streaming~dataを公開するために利用できるような、基本的な~stream~primitiveを供する。
例えば `FETCH$r は、 `Response$I 本体を `ReadableStream$I ~instanceとして公開する。
より一般的には、~platformは、~streamへの抽象-化を待っている ~streamingに満ちている：
~multimedia~stream, ~file~stream, 大域~obj間の通信, 等々…
— すべてを記憶域~内に~bufferして，一度に処理する代わりに、~dataを増分的に処理できることから より便益が得られるような。
Streams Standard は、これらの~stream用の土台を供して，開発者たちに公開することにより、次の様な利用事例を可能化する：
◎
This standard provides the base stream primitives which other parts of the web platform can use to expose their streaming data. For example, [FETCH] exposes Response bodies as ReadableStream instances. More generally, the platform is full of streaming abstractions waiting to be expressed as streams: multimedia streams, file streams, inter-global communication, and more benefit from being able to process data incrementally instead of buffering it all into memory and processing it in one go. By providing the foundation for these streams to be exposed to developers, the Streams Standard enables use cases like:
</p>

<ul>
	<li>
~video~effect：
形式変換~streamを通して~pipeすることで，
可読~video~streamに対し実時間に~effectを適用する。
◎
Video effects: piping a readable video stream through a transform stream that applies effects in real time.
</li>
	<li>
解凍：
~file~streamを形式変換~streamを通すように~pipeすることで，
<kbd>.tgz</kbd> ~archiveの~fileを選択的に解凍する
— 利用者が画像の展示を~scrollするのに伴って，それらを `img$e 要素に転換する。
◎
Decompression: piping a file stream through a transform stream that selectively decompresses files from a .tgz archive, turning them into img elements as the user scrolls through an image gallery.
</li>
	<li>
画像の復号処理：
HTTP 応答~streamを，［
~byte列を~bitmap~dataに復号する，形式変換~stream
］を通してから［
~bitmapを PNG に翻訳する別の形式変換
］を通すように~pipeする。
~swの `fetch$et ~hookの内側に~installした場合、開発者は 新たな画像~形式を透過的に~polyfillできるようになる。
`SERVICE-WORKERS$r
◎
Image decoding: piping an HTTP response stream through a transform stream that decodes bytes into bitmap data, and then through another transform that translates bitmaps into PNGs. If installed inside the fetch hook of a service worker, this would allow developers to transparently polyfill new image formats. [SERVICE-WORKERS]
</li>
</ul>

<p>
ここに述べる~APIを利用すれば、~Web開発者は，［
~platformが供するものと同じ~APIを備えるような，自前の~stream
］も作成できる
— 他の開発者は、~platformが供する~streamと, ~libraryから給される~streamとを，透過的に組立てることが可能になる。
ここに述べる~APIは、すべての~streamを統一化するための抽象-化を供して、このような仕方で，この［
共有され, 組立可能な~interface
］の周りで成長する~ecosystemを促進させる。
◎
Web developers can also use the APIs described here to create their own streams, with the same APIs as those provided by the platform. Other developers can then transparently compose platform-provided streams with those supplied by libraries. In this way, the APIs described here provide unifying abstraction for all streams, encouraging an ecosystem to grow around these shared and composable interfaces.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ε, ~LET, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
尚、この仕様~自身も~~末尾に自前の<a href="#conventions">表記規約</a>を備えていることに注意。
</p>

	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>

<p>
`~chunk@
とは、~stream［
へ書込される／から読取される
］ような，単独の~data片である。
それは，どのような型にもなり得る
— ~streamは、型が互いに異なる~chunkたちを包含し得る。
~chunkは、所与の~streamにおける不可分な~data単位にならないことも多い
— 例えば，~byte~streamは、単独の~byte列の代わりに，それぞれが［
16 KiB の `Uint8Array$I
］であるような~chunk列を包含することもある。
◎
A chunk is a single piece of data that is written to or read from a stream. It can be of any type; streams can even contain chunks of different types. A chunk will often not be the most atomic unit of data for a given stream; for example a byte stream might contain chunks consisting of 16 KiB Uint8Arrays, instead of single bytes.
</p>

		<section id="rs-model">
<h3 title="Readable streams">2.1. 可読~stream</h3>

<p>
`可読~stream@
（ `readable stream^en ）は、そこから読取できるような，~dataの源を表現する。
言い換えれば、~dataは，可読~streamから`~~湧き出る^em。
可読~streamは、具体的には， `ReadableStream$I ~classの~instanceである。
◎
A readable stream represents a source of data, from which you can read. In other words, data comes out of a readable stream. Concretely, a readable stream is an instance of the ReadableStream class.
</p>

<p>
可読~streamは，任意な挙動を伴わせて作成できるが、ほとんどの可読~streamは，［
`下層~源@
（ `underlying source^en ）と~~呼ばれる，より低~levelな入出力~源
］を包装する。
下層~源には、 2 種の型
— `~push源$と`~pull源$ —
がある。
◎
Although a readable stream can be created with arbitrary behavior, most readable streams wrap a lower-level I/O source, called the underlying source. There are two types of underlying source: push sources and pull sources.
</p>

<p>
`~push源@
は、要請の有無にかかわらず，~dataを~pushしてくるような`下層~源$である。
それは、~dataの流れを
静止させる／再開させる
ための仕組みを供することもある。
~push源の例には，~TCP~socketがある
— そこでは、~dataは，~OS~levelから絶えず~pushされ続ける
— ~TCP窓~sizeを変更することで制御できるような~rateで。
◎
Push sources push data at you, whether or not you are listening for it. They may also provide a mechanism for pausing and resuming the flow of data. An example push source is a TCP socket, where data is constantly being pushed from the OS level, at a rate that can be controlled by changing the TCP window size.
</p>

<p>
`~pull源@
は、~dataを得るためには要請を要するような`下層~源$である。
~dataは、同期的に可用になることもあれば（例： ~OSの記憶域~bufferに保持されている場合），非同期的に可用になることもある（例：~diskからの読取nを要する場合）。
~pull源の例には，~file~handleがある
— そこでは、特定の所在へ~seekして，特定の量を読取する。
◎
Pull sources require you to request data from them. The data may be available synchronously, e.g. if it is held by the operating system’s in-memory buffers, or asynchronously, e.g. if it has to be read from disk. An example pull source is a file handle, where you seek to specific locations and read specific amounts.
</p>

<p>
可読~streamは、どちらの型の源も，統一的な~interfaceの背後に包装するように設計されている。
~web開発者により作成される~stream用の源については、その実装の詳細は，［
`new ReadableStream()$m 構築子に渡された，
<a href="#underlying-source-api">一定の~method, ~propを伴う~obj</a>
］により供される。
◎
Readable streams are designed to wrap both types of sources behind a single, unified interface. For web developer–created streams, the implementation details of a source are provided by an object with certain methods and properties that is passed to the ReadableStream() constructor.
</p>

<p>
`~chunk$たちは、`下層~源$から~streamの中へ~enqueueされる。
~chunkたちは、~streamの~public~interfaceを介して
— 特に、~streamの `getReader()$rs ~methodを利用して獲得した，`可読~stream読取器$を利用して —
各回に 1 個ずつ読取できる。
◎
Chunks are enqueued into the stream by the stream’s underlying source. They can then be read one at a time via the stream’s public interface, in particular by using a readable stream reader acquired using the stream’s getReader() method.
</p>

<p>
可読~streamから その~public~interfaceを利用して読取する~codeは、
`消費器@
（ `consumer^en ）と呼ばれている。
◎
Code that reads from a readable stream using its public interface is known as a consumer.
</p>

<p>
消費器は、
`cancel()$rs ~methodを利用して可読~streamを
`取消す@
（ `cancel^en する）能も備える。
これは、［
消費器が~streamへの関心を失った
］こと，および［
即時に~streamを~closeして,
~queueされた`~chunk$たちは捨てて,
`下層~源$に取消nの仕組みがあればそれを実行する
］ことを指示する。
◎
Consumers also have the ability to cancel a readable stream, using its cancel() method. This indicates that the consumer has lost interest in the stream, and will immediately close the stream, throw away any queued chunks, and execute any cancellation mechanism of the underlying source.
</p>

<p>
消費器は、
`tee()$rs ~methodを利用して可読~streamを
`二叉化-@
する（ `tee^en する†）こともできる。
これは、~streamを`~lock$して，それ以上 直に利用できなくする一方で、
`分岐@
（ `branch^en ）と呼ばれる，独立に消費される 2 個の新たな~streamを作成する。
◎
Consumers can also tee a readable stream using its tee() method. This will lock the stream, making it no longer directly usable; however, it will create two new streams, called branches, which can be consumed independently.
</p>

<p class="trans-note">【†
“tee する” という呼称は、 CUI における tee コマンドの “tee”
— T 字型 分岐の “T” —
に由来すると見られる。
】</p>

<p>
~byte列を表現する~stream用には、`可読~stream$の拡張d~versionが供される
— それは特に、複製を最小限にして，~byte列を効率的に取扱うためにある。
そのような可読~stream用の`下層~源$は、
`下層~byte源@
とも呼ばれる。
`下層~源$が`下層~byte源$でもあるような`可読~stream$は、
`可読~byte~stream@
とも呼ばれる。
可読~byte~streamの消費器は、~streamの `getReader()$rs ~methodを利用して，`~BYOB読取器$を獲得できる。
◎
For streams representing bytes, an extended version of the readable stream is provided to handle bytes efficiently, in particular by minimizing copies. The underlying source for such a readable stream is called an underlying byte source. A readable stream whose underlying source is an underlying byte source is sometimes called a readable byte stream. Consumers of a readable byte stream can acquire a BYOB reader using the stream’s getReader() method.
</p>

		</section>
		<section id="ws-model">
<h3 title="Writable streams">2.2. 可書~stream</h3>

<p>
`可書~stream@
（ `writable stream^en ）は、そこへ書込できるような，~dataの行先を表現する。
言い換えれば、~dataは，可書~streamへ`~~流れ込む^em。
可書~streamは、具体的には， `WritableStream$I ~classの~instanceである。
◎
A writable stream represents a destination for data, into which you can write. In other words, data goes in to a writable stream. Concretely, a writable stream is an instance of the WritableStream class.
</p>

<p>
可読~streamと相似的に、ほとんどの可書~streamは，
`下層~槽@
（ `underlying sink^en ）と呼ばれる より低~levelな入出力~槽を包装する。
可書~streamは、一連の書込nを~queueして 下層~槽に 1 個ずつ送達することにより，下層~槽の複階性の一部を抽象-化して見えなくするように働く。
◎
Analogously to readable streams, most writable streams wrap a lower-level I/O sink, called the underlying sink. Writable streams work to abstract away some of the complexity of the underlying sink, by queuing subsequent writes and only delivering them to the underlying sink one by one.
</p>

<p>
`~chunk$たちは、~streamの~public~interfaceを介して ~streamへ書込され，各回に 1 個ずつ~streamの`下層~槽$に渡される。
~web開発者により作成される~stream用の槽については、その実装の詳細は，［
`new WritableStream()$m 構築子に渡された，
<a href="#underlying-sink-api">一定の~method, ~propを伴う~obj</a>
］が供する。
◎
Chunks are written to the stream via its public interface, and are passed one at a time to the stream’s underlying sink. For web developer-created streams, the implementation details of the sink are provided by an object with certain methods that is passed to the WritableStream() constructor.
</p>

<p>
可書~streamの中へ，その~public~interfaceを利用して書込する~codeは、
`生産器@
（ `producer^en ）と呼ばれている。
◎
Code that writes into a writable stream using its public interface is known as a producer.
</p>

<p>
`生産器$は、
`abort()$ws ~methodを利用して 可書~streamを
`中止する@
（ `abort^en する）能も備える。
これは、［
生産器が 何か不具合があると確信したこと，したがって 以降の書込nは継続されるべきでないこと
］を指示する。
これは、`下層~槽$からの通達がなくとも，~streamを~error状態に置くことに加え、~streamの`内部~queue$内にある すべての書込nを破棄する。
◎
Producers also have the ability to abort a writable stream, using its abort() method. This indicates that the producer believes something has gone wrong, and that future writes should be discontinued. It puts the stream in an errored state, even without a signal from the underlying sink, and it discards all writes in the stream’s internal queue.
</p>

		</section>
		<section id="ts-model">
<h3 title="Transform streams">2.3. 形式変換~stream</h3>

<p>
`形式変換~stream@
（ `transform stream^en ）は、~streamの~pair
—
`可書~側@
と称される`可書~stream$,
`可読~側@
と称される`可読~stream$
—
からなる。
当の形式変換~streamに特有な方式で，可書~側へ書込される結果、新たな~dataが可読~側から読取されて可用になる。
◎
A transform stream consists of a pair of streams: a writable stream, known as its writable side, and a readable stream, known as its readable side. In a manner specific to the transform stream in question, writes to the writable side result in new data being made available for reading from the readable side.
</p>

<p>
具体的には、［
`writable^m, `readable^m
］両~propを伴うような どの~objも、形式変換~streamとして~~働き得る。
しかしながら、標準な `TransformStream$I ~classが，適正に連絡された そのような~pairをずっと容易に作成する。
それは、［
遂行される特定の形式変換n用の~algoを定義する，
`形式変換器@
（ `transformer^en ）~obj
］を包装する。
~web開発者により作成される~stream用の`形式変換器$については、その実装の詳細は，［
`new TransformStream()$m 構築子に渡された，
<a href="#transformer-api">一定の~method, ~propを伴う~obj</a>
］により供される。
◎
Concretely, any object with a writable property and a readable property can serve as a transform stream. However, the standard TransformStream class makes it much easier to create such a pair that is properly entangled. It wraps a transformer, which defines algorithms for the specific transformation to be performed. For web developer–created streams, the implementation details of a transformer are provided by an object with certain methods and properties that is passed to the TransformStream() constructor.
</p>

<p>
`~identity形式変換~stream@
は、形式変換~streamの一種であり，`可書~側$に書込された`~chunk$をそのまま`可読~側$に送り込む。
これは、<a href="#example-transform-identity">様々な局面</a>で有用になる。
`形式変換器$~objに `transform()$tf ~methodが無いときの既定では、
`TransformStream$I 構築子は，~identity形式変換~streamを作成することになる。
◎
An identity transform stream is a type of transform stream which forwards all chunks written to its writable side to its readable side, without any changes. This can be useful in a variety of scenarios. By default, the TransformStream constructor will create an identity transform stream, when no transform() method is present on the transformer object.
</p>

<p>
形式変換~streamになり得る例：
◎
Some examples of potential transform streams include:
</p>

<ul>
	<li>
GZIP 圧縮器 —
未圧縮の~byte列が そこへ書込され，圧縮-済み~byte列が そこから読取される。
◎
A GZIP compressor, to which uncompressed bytes are written and from which compressed bytes are read;
</li>
	<li>
~video復号器 —
符号化された~byte列が そこへ書込され，未圧縮の~video~frameたちが そこから読取される。
◎
A video decoder, to which encoded bytes are written and from which uncompressed video frames are read;
</li>
	<li>
~text復号器
— ~byte列が そこへ書込され，文字列たちが そこから読取される。
◎
A text decoder, to which bytes are written and from which strings are read;
</li>
	<li>
CSV-to-JSON 変換器
— CSV ~fileを成す各~行を表現する文字列たちが そこへ書込され、対応する~JS~objたちが そこから読取される。
◎
A CSV-to-JSON converter, to which strings representing lines of a CSV file are written and from which corresponding JavaScript objects are read.
</li>
</ul>

		</section>
		<section id="pipe-chains">
<h3 title="Pipe chains and backpressure">2.4. ~pipe鎖と背圧</h3>

<p>
~streamたちは首に，互いに
`~pipe@
して利用される。
可読~streamは、
`pipeTo()$rs ~methodを利用して，直に可書~streamに~pipeすることも、その~~前に
`pipeThrough()$rs ~methodを利用して，いくつかの形式変換~streamを通してから ~pipeすることもできる。
◎
Streams are primarily used by piping them to each other. A readable stream can be piped directly to a writable stream, using its pipeTo() method, or it can be piped through one or more transform streams first, using its pipeThrough() method.
</p>

<p>
この仕方で互いに~pipeされた一連の~streamは、
`~pipe鎖@
（ `pipe chain^en ）と呼ばれる。
~pipe鎖の先頭にある可読~streamの`下層~源$を
`元の源@
（ `original source^en ）と呼び、末尾にある可書~streamの`下層~槽$を
`最終~槽@
（ `ultimate sink^en ）と呼ぶ。
◎
A set of streams piped together in this way is referred to as a pipe chain. In a pipe chain, the original source is the underlying source of the first readable stream in the chain; the ultimate sink is the underlying sink of the final writable stream in the chain.
</p>

<p>
`~pipe鎖$が構築されたなら、それを通して［
`~chunk$たちをどの~~程度 高速に流すべきかについての通達
］を伝播することになる。
鎖のある段が~chunkをまだ受容できない場合、~pipe鎖を通して後方へ, 最終的に元の源まで，通達が伝播され、元の源に ~chunkの生産-を止めるよう伝えることになる。
この，［
鎖がどの~~程度 高速に~chunkを処理できるかに則って，元の源からの流れを正常化する処理n
］は、
`背圧@
（ `backpressure^en ）と呼ばれる。
◎
Once a pipe chain is constructed, it will propagate signals regarding how fast chunks should flow through it. If any step in the chain cannot yet accept chunks, it propagates a signal backwards through the pipe chain, until eventually the original source is told to stop producing chunks so fast. This process of normalizing flow from the original source according to how fast the chain can process chunks is called backpressure.
</p>

<p>
具体的には、`元の源$が~dataを流す~rateは，
<code>%controller.`desiredSize$rsdc</code>
（または 
<code>%byteController.`desiredSize$rbsc</code>
）から与えられる値に則って調整できる。
この値は、`最終~槽$に対応している
<code>%writer.`desiredSize$dw</code>
から導出され，最終~槽への`~chunk$の書込みが完遂する度に更新される。
`pipeTo()$rs ~methodは、この鎖を自動的に構築するために利用され，この情報が`~pipe鎖$を遡って伝播することを確保する。
◎
Concretely, the original source is given the controller.desiredSize (or byteController.desiredSize) value, and can then adjust its rate of data flow accordingly. This value is derived from the writer.desiredSize corresponding to the ultimate sink, which gets updated as the ultimate sink finishes writing chunks. The pipeTo() method used to construct the chain automatically ensures this information propagates back through the pipe chain.
</p>

<p>
可読~streamが`二叉化-$されたときは、その両`分岐$からの`背圧$通達は，両~分岐とも読取できないときには 集成された上で、元の~streamの`下層~源$へ送信されることになる。
◎
When teeing a readable stream, the backpressure signals from its two branches will aggregate, such that if neither branch is read from, a backpressure signal will be sent to the underlying source of the original stream.
</p>

<p>
~pipeすることにより，［
可読, 可書
］~streamは、`~lock$され，~pipe演算の間は操作できなくされる。
これにより，実装は、［
中間的な~queueの多くを迂回して，~dataを下層~源から下層~槽へ直に~~運び続ける
］などの重要な最適化を，遂行できるようになる。
◎
Piping locks the readable and writable streams, preventing them from being manipulated for the duration of the pipe operation. This allows the implementation to perform important optimizations, such as directly shuttling data from the underlying source to the underlying sink while bypassing many of the intermediate queues.
</p>

		</section>
		<section id="queuing-strategies">
<h3 title="Internal queues and queuing strategies">2.5. 内部~queueと~queuing策</h3>

<p>
可読~stream, 可書~stream
のいずれも，
`内部~queue@
（ `internal queue^en ）を保守し，類似な目的に利用する。
可読~streamの内部~queueは、［
`下層~源$により~enqueueされたが，`消費器$からはまだ読取されていない
］ような`~chunk$たちを包含する。
可書~streamの内部~queueは、［
`生産器$により~streamに書込され，承認されたが、まだ`下層~槽$により処理されていない
］ような`~chunk$たちを包含する。
◎
Both readable and writable streams maintain internal queues, which they use for similar purposes. In the case of a readable stream, the internal queue contains chunks that have been enqueued by the underlying source, but not yet read by the consumer. In the case of a writable stream, the internal queue contains chunks which have been written to the stream by the producer, but not yet processed and acknowledged by the underlying sink.
</p>

<p>
`~queuing策@
（ `queuing strategy^en ）とは、~streamが［
自身の`内部~queue$の状態に基づいて，`背圧$を どのように通達すべきか
］を決定するような，~objである。
~queuing策は、各`~chunk$に~sizeをアテガって，［
~queue内のすべての~chunkの合計~size
］と［
`限界水位@
（ `high-water mark^en ）と呼ばれる，指定された~number
］とを比較する。
結果の差分 ~EQ ［
限界水位 ~MINUS 合計~size
］は、
`~streamの内部~queueの残り~size@
（ `desired size to fill the stream’s queue^en ）を決定するために利用される。
◎
A queuing strategy is an object that determines how a stream should signal backpressure based on the state of its internal queue. The queuing strategy assigns a size to each chunk, and compares the total size of all chunks in the queue to a specified number, known as the high water mark. The resulting difference, high water mark minus total size, is used to determine the desired size to fill the stream’s queue.
</p>

<p>
可読~streamにおいては、下層~源は，この残り~sizeを［
~chunk生成を減速させる背圧~通達
］に利用できる
— 残り~sizeを 0 以上に保とうとするために。
可書~streamにおいては、生産器は，類似に挙動できる
— 残り~sizeが負になる前に書込nを避けるために。
◎
For readable streams, an underlying source can use this desired size as a backpressure signal, slowing down chunk generation so as to try to keep the desired size above or at zero. For writable streams, a producer can behave similarly, avoiding writes that would cause the desired size to go negative.
</p>

<p>
<a href="#qs-api">具体的には</a>、
`highWaterMark$qs ~propを伴う どの~JS~objも，~web開発者により作成される~stream用の~queuing策を与える。
~byte~stream用の `highWaterMark^qs は常に~byte単位になる。
他の~stream用の既定は`~chunk$単位になるが、~queuing策~obj内に［
所与の~chunkに対し その~sizeを返す `size()$qs 関数
］を含めれば， `highWaterMark^qs に任意な浮動小数点~単位を指定することを許可できる。
◎
Concretely, a queuing strategy for web developer–created streams is given by any JavaScript object with a highWaterMark property. For byte streams the highWaterMark always has units of bytes. For other streams the default unit is chunks, but a size() function can be included in the strategy object which returns the size for a given chunk. This permits the highWaterMark to be specified in arbitrary floating-point units.
</p>

<div class="example">

<p>
~queuing策の単純な例には、各`~chunk$ごとに~size 1 をアテガって，`限界水位$は一定数にするものが挙げられる。
これは、~streamが背圧を適用する前に［
可読~stream内に~enqueueできる／
可書~streamに書込できる
］~chunk数は，その一定数までに限られることを意味する。
◎
A simple example of a queuing strategy would be one that assigns a size of one to each chunk, and has a high water mark of three. This would mean that up to three chunks could be enqueued in a readable stream, or three chunks written to a writable stream, before the streams are considered to be applying backpressure.
</p>

<p>
~JSにおいては、そのような策は、
`{ highWaterMark: 3, size() { return 1; }}^c
のように手動で書くことも，
組込みの `CountQueuingStrategy$I ~classを利用して
`new CountQueuingStrategy({ highWaterMark: 3 })^c
のように書くこともできる。
◎
In JavaScript, such a strategy could be written manually as { highWaterMark: 3, size() { return 1; }}, or using the built-in CountQueuingStrategy class, as new CountQueuingStrategy({ highWaterMark: 3 }).
</p>
</div>

		</section>
		<section id="locking">
<h3 title="Locking">2.6. ~lock法</h3>

<p>
`可読~stream読取器@
または略して
<dfn>読取器</dfn>
（ `reader^en ）とは、`可読~stream$から直に`~chunk$を読取できるようにする~objである。
読取器がない下で，`消費器$が遂行できることは、可読~stream上の高~levelな演算
— ~streamを`取消す$か, または 可読~streamから可書~streamへ`~pipeする$ —
に限られる。
読取器は、~streamの `getReader()$rs ~methodを介して獲得される。
◎
A readable stream reader, or simply reader, is an object that allows direct reading of chunks from a readable stream. Without a reader, a consumer can only perform high-level operations on the readable stream: canceling the stream, or piping the readable stream to a writable stream. A reader is acquired via the stream’s getReader() method.
</p>

<p>
`可読~byte~stream$には、 2 種の型の読取器［
`既定の読取器@
と
`~BYOB読取器@
］を配給する能がある。
~BYOB（
“`Bring Your Own Buffer^en” — “開発者が~bufferを給する”
）読取器は、開発者から給される~bufferの中へ読取できるようにして，~dataの複製を最小限にする。
可読~byte~stream以外の可読~streamが配給できるのは、既定の読取器に限られる。
既定の読取器は， `ReadableStreamDefaultReader$I ~classの~instanceである一方、~BYOB読取器は， `ReadableStreamBYOBReader$I ~classの~instanceである。
◎
A readable byte stream has the ability to vend two types of readers: default readers and BYOB readers. BYOB ("bring your own buffer") readers allow reading into a developer-supplied buffer, thus minimizing copies. A non-byte readable stream can only vend default readers. Default readers are instances of the ReadableStreamDefaultReader class, while BYOB readers are instances of ReadableStreamBYOBReader.
</p>

<p>
同様に，
`可書~stream書込器@
または略して
<dfn>書込器</dfn>
（ `writer^en ）とは、`可書~stream$に直に`~chunk$を書込できるようにする~objである。
書込器がない下で，`生産器$が遂行できることは、可書~stream上の高~levelな演算
— ~streamを中止するか, 可読~streamから可書~streamへ`~pipeする$ —
に限られる。
書込器は、 `WritableStreamDefaultWriter$I ~classで表現される。
◎
Similarly, a writable stream writer, or simply writer, is an object that allows direct writing of chunks to a writable stream. Without a writer, a producer can only perform the high-level operations of aborting the stream or piping a readable stream to the writable stream. Writers are represented by the WritableStreamDefaultWriter class.
</p>

<p class="note">注記：
これらの高~levelな演算は、実際には［
読取器／書込器
］を裏で利用する。
◎
Under the covers, these high-level operations actually use a reader or writer themselves.
</p>

<p>
所与の［
可読／可書
］~streamを利用している［
読取器／書込器
］がある間は、他のどの［
読取器／書込器
］も，その~streamを利用できない。
このことを，~streamは
`~lockされて@
いる（ `is locked^en ）と言い、［
読取器／書込器
］は
`作動中@
（ `active^en ）と言う。
この状態は、［
<code>%readableStream.`locked$rs</code> ／
<code>%writableStream.`locked$ws</code>
］~propを利用して決定できる。
◎
A given readable or writable stream only has at most one reader or writer at a time. We say in this case the stream is locked, and that the reader or writer is active. This state can be determined using the readableStream.locked or writableStream.locked properties.
</p>

<p>
［
読取器／書込器
］は、その~lockを
`解放-@
（ `release^en ）する能力も持つ。
それにより，［
読取器／書込器
］は`作動中$でなくなり、他の［
読取器／書込器
］は，当の~streamの~lockを獲得できるようになる。
これは、［
<code>%defaultReader.`releaseLock()$dr</code>,
<code>%byobReader.`releaseLock()$byob</code>,
<code>%writer.`releaseLock()$dw</code>
］いずれか適切な~methodを介して行える。
◎
A reader or writer also has the capability to release its lock, which makes it no longer active, and allows further readers or writers to be acquired. This is done via the defaultReader.releaseLock(), byobReader.releaseLock(), or writer.releaseLock() method, as appropriate.
</p>

		</section>
	</section>
	<section id="conventions">
<h2 title="Conventions">3. 規約</h2>

<p>
この仕様は、 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、その内部~algo用に，~JS仕様による`抽象-演算$の概念を利用する。
これは、それらの返り値を`完了~record$として扱った上で，完了~recordを包装を外すための［
~NOABRUPT ／ ~ABRUPT
］接頭辞の利用を含む。
`ECMASCRIPT$r
◎
This specification uses the abstract operation concept from the JavaScript specification for its internal algorithms. This includes treating their return values as completion records, and the use of ! and ? prefixes for unwrapping those completion records. [ECMASCRIPT]
</p>

<p class="trans-note">
【概略的には、抽象-演算を~callする所で】
⇒＃
~NOABRUPT が接頭されていれば 決して`中途完了^にならず，完了~recordの `Value^sl が返される／
~ABRUPT が接頭されていれば `中途完了^に対しては例外が投出される／
何も接頭されていない場合、結果の完了~recordに対する明示的な取扱いを要する
</p>

<p>
この仕様はまた、~JS仕様による`内部~slot$の概念と記法を利用する（内部~slotは、~JS~objではなく，~Web~IDLの`~platform~obj$上にあるが。）
◎
This specification also uses the internal slot concept and notation from the JavaScript specification. (Although, the internal slots are on Web IDL platform objects instead of on JavaScript objects.)
</p>

<p class="note">注記：
これらの外来の~JS仕様~規約を~~利用する理由は、多分に歴史的である。
自前の~web仕様を書く策定者には、この仕様の例に従うのは避けることが督促される。
◎
The reasons for the usage of these foreign JavaScript specification conventions are largely historical. We urge you to avoid following our example when writing your own web specifications.
</p>

<p>
この仕様におけるすべての~numberは、（~JS `Number$jT ／ ~Web~IDL `unrestricted double$I 型の様に）倍精度 64-bit IEEE 754 浮動小数点~値として表現され、それらに対し遂行されるすべての算術-演算は、そのような値~用の標準な仕方で行うモノトスル。
これは、特に`個別~size付き~queue$secにて述べられる~data構造~用に重要になる。
`IEEE-754$r
◎
In this specification, all numbers are represented as double-precision 64-bit IEEE 754 floating point values (like the JavaScript Number type or Web IDL unrestricted double type), and all arithmetic operations performed on them must be done in the standard way for such values. This is particularly important for the data structure described in § 8.1 Queue-with-sizes. [IEEE-754]
</p>

	</section>
	<section id="rs">
<h2 title="Readable streams">4. 可読~stream</h2>

		<section id="rs-intro">
<h3 title="Using readable streams">4.1. 可読~streamの利用-法</h3>

<div class="example" id="example-basic-pipe-intro">

<p>
可読~streamを消費する最も単純な仕方は、単純にそれを`可書~stream$へ`~pipeする$ことである。
これにより，その`背圧$が尊重されるようになり、（書込みでも読取りでも）~errorが生じれば`~pipe鎖$を通して伝播される：
◎
The simplest way to consume a readable stream is to simply pipe it to a writable stream. This ensures that backpressure is respected, and any errors (either writing or reading) are propagated through the chain:
</p>

<pre class="lang-js">
%readableStream.pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>
<!-- 
"All data successfully written!"
"Something went wrong!"
-->
</div>

<div class="example" id="example-pipe-as-chunks-receiver">

<p>
可読~streamからの各 新たな~chunkを，単純に改めたいと欲するならば、それを，［
その目的に~customに作成した，新たな`可書~stream$
］へ`~pipeする$こともできる：
◎
If you simply want to be alerted of each new chunk from a readable stream, you can pipe it to a new writable stream that you custom-create for that purpose:
</p>

<pre class="lang-js">
%readableStream.pipeTo(new WritableStream({
  write(%chunk) {
    console.log(`~chunkが受信されました^l, %chunk);
  },
  close() {
    console.log(`すべての~dataを成功裡に読取しました^l);
  },
  abort(%e) {
    console.error(`何かまずいことが起きたようです^l, %e);
  }
}));

<!-- 
"Chunk received"
"All data successfully read!"
"Something went wrong!"
-->
</pre>

<p>
~~自前の `write()$usk 実装から~promiseを返すことにより、可読~streamに向けて`背圧$を通達できる。
◎
By returning promises from your write() implementation, you can signal backpressure to the readable stream.
</p>

</div>

<div class="example" id="example-manual-read">

<p>
可読~streamは、通例的に，可書~streamへ~pipeするために利用されるが、直に読取することもできる
— `読取器$を獲得してから，その `read()^m ~methodを利用して ~chunkの連なりを取得することにより。
例えば，次の~codeは、~stream内の次回の`~chunk$が可用なら，その~logをとる：
◎
Although readable streams will usually be used by piping them to a writable stream, you can also read them directly by acquiring a reader and using its read() method to get successive chunks. For example, this code logs the next chunk in the stream, if available:
</p>

<pre class="lang-js">
const %reader = %readableStream.getReader();

%reader.read().then(
  ({ %value, %done }) =&gt; {
    if (%done) {
      console.log(`~streamはすでに~closeされています^l);
    } else {
      console.log(%value);
    }
  },
  %e =&gt; console.error(`~streamに~errorが生じたので読取できません^l, %e)
);
</pre>

<!-- 
"The stream was already closed"
"The stream became errored and cannot be read from"
-->
<p>
この~methodは、~streamを より手動的に読取するとき
— 主に~library作者にとって、［
`~pipe$する／`二叉化-$する
］ことから供されるものを超えるような，~stream上に新たな高~levelな演算を築くとき —
に有用になる。
◎
This more manual method of reading a stream is mainly useful for library authors building new high-level operations on streams, beyond the provided ones of piping and teeing.
</p>

</div>

<div class="example" id="example-manual-read-bytes">

<p>
上の例では，可読~streamの`既定の読取器$の利用を示したが、~streamが`可読~byte~stream$である場合は，それ用の`~BYOB読取器$も獲得できる
— それにより、複製を避けるよう，~bufferの割振りを より精確に制御できるようになる。
例えば次の~codeは、~streamから最初の 1024 ~byteを，単独の記憶域~bufferの中に読取する：
◎
The above example showed using the readable stream’s default reader. If the stream is a readable byte stream, you can also acquire a BYOB reader for it, which allows more precise control over buffer allocation in order to avoid copies. For example, this code reads the first 1024 bytes from the stream into a single memory buffer:
</p>

<pre class="lang-js">
const %reader = readableStream.getReader({ mode: `byob^l });

let %startingAB = new ArrayBuffer(1024);
readInto(%startingAB)
  .then(%buffer =&gt; console.log(`最初の 1024 ~byte:^l, %buffer))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));

function readInto(%buffer, %offset = 0) {
  if (%offset === %buffer.byteLength) {
    return Promise.resolve(%buffer);
  }

  const %view = new Uint8Array(%buffer, %offset, %buffer.byteLength - %offset);
  return %reader.read(%view).then(%newView =&gt; {
    return readInto(%newView.buffer, %offset + %newView.byteLength);
  });
}
</pre>
<!-- 
"The first 1024 bytes:"
"Something went wrong!"
 -->

<p>
ここで重要なことは、~~最終的な %buffer 値は %startingAB と異なるが、それら（および すべての中間的~buffer）は，裏では同じ記憶域の割振りを共有することである。
~bufferは、毎回 新たな `ArrayBuffer$I ~objに`転送され$る。
%newView は、各種~propが次のように設定された，新たな `Uint8Array$I になる
⇒＃
`buffer^m ~SET 当の `ArrayBuffer$I ~obj；
`byteOffset^m ~SET 書込された~byte列の~offset；
`byteLength^m ~SET 書込された~byte数
◎
An important thing to note here is that the final buffer value is different from the startingAB, but it (and all intermediate buffers) shares the same backing memory allocation. At each step, the buffer is transferred to a new ArrayBuffer object. The newView is a new Uint8Array, with that ArrayBuffer object as its buffer property, the offset that bytes were written to as its byteOffset property, and the number of bytes that were written as its byteLength property.
</p>

</div>

		</section>
		<section id="rs-class">
<h3 title="The ReadableStream class">4.2. `ReadableStream^I ~class</h3>

<p>
`ReadableStream$I ~classは、`可読~stream$の一般~概念の具象-~instanceを成す。
それは、どのような`~chunk$型にも適応-可能であり，［
`下層~源$から給されたが, まだ消費器から読取されていない~data
］を追跡し続けるための内部~queueを保守する。
◎
The ReadableStream class is a concrete instance of the general readable stream concept. It is adaptable to any chunk type, and maintains an internal queue to keep track of data supplied by the underlying source but not yet read by any consumer.
</p>

			<section id="rs-class-definition">
<h4 title="Interface definition">4.2.1. ~interface定義</h4>

<p>
`ReadableStream$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ReadableStream class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ReadableStream@I {
  `ReadableStream$mc(optional `object$ %underlyingSource, optional `QueuingStrategy$I %strategy = {});

  readonly attribute `boolean$ `locked$rs;

  Promise&lt;void&gt; `cancel$rs(optional any %reason);
  `ReadableStreamReader$I `getReader$rs(optional `ReadableStreamGetReaderOptions$I %options = {});
  `ReadableStream$I `pipeThrough$rs(`ReadableWritablePair$I %transform, optional `StreamPipeOptions$I %options = {});
  Promise&lt;void&gt; `pipeTo$rs(`WritableStream$I %destination, optional `StreamPipeOptions$I %options = {});
  sequence&lt;`ReadableStream$I&gt; `tee$rs();

  async iterable&lt;any&gt;(optional `ReadableStreamIteratorOptions$I %options = {});
};

typedef (`ReadableStreamDefaultReader$I or `ReadableStreamBYOBReader$I) `ReadableStreamReader@I;

enum `ReadableStreamReaderMode@I { `byob@l };

dictionary `ReadableStreamGetReaderOptions@I {
  `ReadableStreamReaderMode$I `mode@rsgo;
};

dictionary `ReadableStreamIteratorOptions@I {
  `boolean$ `preventCancel@rsio = false;
};

dictionary `ReadableWritablePair@I {
  required `ReadableStream$I `readable@rwp;
  required `WritableStream$I `writable@rwp;
};

dictionary `StreamPipeOptions@I {
  `boolean$ `preventClose@spo = false;
  `boolean$ `preventAbort@spo = false;
  `boolean$ `preventCancel@spo = false;
  `AbortSignal$I `signal@spo;
};
</pre>

			</section>
			<section id="rs-internal-slots">
<h4 title="Internal slots">4.2.2. 内部~slot</h4>

<p>
`ReadableStream$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStream are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`disturbed^sl
<td>
真偽~flag
— ~streamから何か読取されたか, ~streamが取消されたとき， ~T に設定される。
◎
A boolean flag set to true when the stream has been read from or canceled

<tr><td>`readableStreamController^sl
<td>
［
この~streamの状態と~queueを制御する能
］を伴って作成される［
`ReadableStreamDefaultController$I または `ReadableByteStreamController$I
］。
◎
A ReadableStreamDefaultController or ReadableByteStreamController created with the ability to control the state and queue of this stream

<tr><td>`reader^sl
<td>
この~streamを`~lock$している`読取器$
— `ReadableStreamDefaultReader$I ／ `ReadableStreamBYOBReader$I —
の~instanceは［
在るならば それ ／
無いならば `undefined^jv
］。
◎
A ReadableStreamDefaultReader or ReadableStreamBYOBReader instance, if the stream is locked to a reader, or undefined if it is not

<tr><td>`state^sl
<td>
内部的に利用される，~streamの現在の状態を表す文字列
— 次のいずれか：
`readable^l, `closed^l, `errored^l
◎
A string containing the stream’s current state, used internally; one of "readable", "closed", or "errored"

<tr><td>`storedError^sl
<td>
~streamが どのように失敗したかを指示する値
— ~errorした~streamに対し演算しようと試行しているときに、失敗~事由か例外として与えられることになる。
◎
A value indicating how the stream failed, to be given as a failure reason or exception when trying to operate on an errored stream
</tbody></table>

			</section>
			<section id="underlying-source-api">
<h4 title="The underlying source API">4.2.3. 下層~source~API</h4>

<p>
`new ReadableStream()$m 構築子は、 1 個目の引数に［
`下層~源$を表現している~JS~obj
］を受容する。
そのような~objには、次に挙げる~propを包含させられる：
◎
The ReadableStream() constructor accepts as its first argument a JavaScript object representing the underlying source. Such objects can contain any of the following properties:
</p>

<pre class="idl">
dictionary `UnderlyingSource@I {
  `UnderlyingSourceStartCallback$I `start$usc;
  `UnderlyingSourcePullCallback$I `pull$usc;
  `UnderlyingSourceCancelCallback$I `cancel$usc;
  `ReadableStreamType$I `type$usc;
  [`EnforceRange$] `unsigned long long$ `autoAllocateChunkSize$usc;
};

typedef (`ReadableStreamDefaultController$I or `ReadableByteStreamController$I) `ReadableStreamController@I;

callback `UnderlyingSourceStartCallback@I = any (`ReadableStreamController$I %controller);
callback `UnderlyingSourcePullCallback@I = Promise&lt;void&gt; (`ReadableStreamController$I %controller);
callback `UnderlyingSourceCancelCallback@I = Promise&lt;void&gt; (optional any %reason);

enum `ReadableStreamType@I { `bytes$l };
</pre>

<dl>
	<dt>
`start(controller)@usc
（ `UnderlyingSourceStartCallback$I 型）
◎
start(controller), of type UnderlyingSourceStartCallback
</dt>
	<dd>
この関数は、 `ReadableStream$I を作成する間に即時に~callされる。
◎
A function that is called immediately during creation of the ReadableStream.
</dd>
	<dd>
これは、概して，次のために利用される：
関連な~event~listenerを設定しておくことにより，`~push源$を適応させる（その例は、`下層~push源を伴う可読~stream（背圧~supportなし）$secに見れる）／
`~pull源$への~accessを獲得する（その例は、`下層~pull源を伴う可読~stream$secに見れる）。
◎
Typically this is used adapt a push source by setting up relevant event listeners, as in the example of § 9.1 A readable stream with an underlying push source (no backpressure support), or to acquire access to a pull source, as in § 9.4 A readable stream with an underlying pull source.
</dd>
	<dd>
この設定しておく処理nが非同期的になる場合、この関数は，成否を通達する~promiseを返すようにすることもできる：
却下される~promiseは、~streamを~errorにすることになる。
投出された例外は、
`new ReadableStream()$m
構築子により投出し直されることになる。
◎
If this setup process is asynchronous, it can return a promise to signal success or failure; a rejected promise will error the stream. Any thrown exceptions will be re-thrown by the ReadableStream() constructor.
</dd>

	<dt>
`pull(controller)@usc
,
（ `UnderlyingSourcePullCallback$I 型）
◎
pull(controller), of type UnderlyingSourcePullCallback
</dt>
	<dd>
この関数は、~chunkたちが成す~streamの`内部~queue$が満杯でなくなり次第
— すなわち、~queueの`~streamの内部~queueの残り~size$ ~GT 0 になり次第 —
~callされる。
一般に，~queueは`限界水位$に達するまで（すなわち，`~streamの内部~queueの残り~size$ ~LTE 0 になるまで），繰返し~callされることになる。
◎
A function that is called whenever the stream’s internal queue of chunks becomes not full, i.e. whenever the queue’s desired size becomes positive. Generally, it will be called repeatedly until the queue reaches its high water mark (i.e. until the desired size becomes non-positive).
</dd>
	<dd>
`~push源$に対しては、この関数は，静止された流れを再開するためにも利用され得る（その例は、`下層~push源を伴う可読~stream（背圧~supportあり）$secに見れる）。
`~pull源$に対しては、~streamの中へ~enqueueする新たな`~chunk$を獲得するために利用される（その例は、`下層~pull源を伴う可読~stream$secに見れる）。
◎
For push sources, this can be used to resume a paused flow, as in § 9.2 A readable stream with an underlying push source and backpressure support. For pull sources, it is used to acquire new chunks to enqueue into the stream, as in § 9.4 A readable stream with an underlying pull source.
</dd>
	<dd>
この関数は、 `start()$usc が成功裡に完了するまでは，~callされない。
加えて，繰返し~callされるのは、それが［
1 個以上の~chunkを~enqueueするか, ~BYOB要請を充足する
］場合に限られる
— 何もしない `pull()$usc 実装は、断続的に~callされることはない。
◎
This function will not be called until start() successfully completes. Additionally, it will only be called repeatedly if it enqueues at least one chunk or fulfills a BYOB request; a no-op pull() implementation will not be continually called.
</dd>
	<dd>
この関数が~promiseを返した場合、その~promiseが充足されるまでは，再度~callされることはない（この~promiseが却下された場合、~streamは~errorにされることになる）。
これは、主に，~pull源の事例で利用される
— そこで返される~promiseは、新たな~chunkを獲得する処理nを表現する。
例外を投出した場合、却下される~promiseを返すのと同じに扱われる。
◎
If the function returns a promise, then it will not be called again until that promise fulfills. (If the promise rejects, the stream will become errored.) This is mainly used in the case of pull sources, where the promise returned represents the process of acquiring a new chunk. Throwing an exception is treated the same as returning a rejected promise.
</dd>

	<dt>
`cancel(reason)@usc
（ `UnderlyingSourceCancelCallback$I 型）
◎
cancel(reason), of type UnderlyingSourceCancelCallback
</dt>
	<dd>
この関数は、~streamが`消費器$により［
<code>%stream.`cancel()$rs</code> ／
<code>%defaultReader.`cancel()$dr</code> ／
<code>%byobReader.`cancel()$byob</code>
］を介して`取消され$次第，~callされる。
その引数は、消費器がそれらの~methodに渡したのと同じ値をとる。
◎
A function that is called whenever the consumer cancels the stream, via stream.cancel(), defaultReader.cancel(), or byobReader.cancel(). It takes as its argument the same value as was passed to those methods by the consumer.
</dd>
	<dd>
加えて，可読~streamは、`~pipeする$間に，一定の条件~下で取消されることもある
— 詳細は、 `pipeTo()$rs ~methodの定義を見よ。
◎
Readable streams can additionally be canceled under certain conditions during piping; see the definition of the pipeTo() method for more details.
</dd>
	<dd>
この関数は，どの~streamにおいても、一般に，下層~資源への~accessを解放するために利用される
— 例えば`下層~push源を伴う可読~stream（背圧~supportなし）$secを見よ。
◎
For all streams, this is generally used to release access to the underlying resource; see for example § 9.1 A readable stream with an underlying push source (no backpressure support).
</dd>
	<dd>
この~shutdown処理nが非同期的になる場合、この関数は，成否を通達する~promiseを返すようにすることもできる：
その結果は、前述の各種 `cancel()^c ~methodの返り値を介して，その~call元（消費器）へ通信されることになる。
加えて，却下される~promiseは、~streamを
— そのまま~closeさせずに —
~errorにすることになる。
例外を投出した場合、却下される~promiseを返すのと同じに扱われる。
◎
If the shutdown process is asynchronous, it can return a promise to signal success or failure; the result will be communicated via the return value of the cancel() method that was called. Additionally, a rejected promise will error the stream, instead of letting it close. Throwing an exception is treated the same as returning a rejected promise.
</dd>

	<dt>
`type@usc
（~byte~stream用に限る）
（ `ReadableStreamType$I 型）
◎
type (byte streams only), of type ReadableStreamType
</dt>
	<dd>
`bytes@l
に設定すれば、構築される `ReadableStream$I は`可読~byte~stream$であることを通達できる。
これは、［
結果の `ReadableStream$I が
— その `getReader()$rs ~methodを介して —
`~BYOB読取器$を成功裡に配給-可能にする
］ことを確保する。
また、下に与える［
`start()$usc ／ `pull()$usc
］~methodに渡される %controller 引数にも影響する。
◎
Can be set to "bytes" to signal that the constructed ReadableStream is a readable byte stream. This ensures that the resulting ReadableStream will successfully be able to vend BYOB readers via its getReader() method. It also affects the controller argument passed to the start() and pull() methods; see below.
</dd>
	<dd>
可読~byte~streamを設定しておく方法の例は
— 異なる制御器~interfaceを利用することも含め —
`下層~push源を伴う可読~byte~stream（背圧~supportなし）$secに見れる。
◎
For an example of how to set up a readable byte stream, including using the different controller interface, see § 9.3 A readable byte stream with an underlying push source (no backpressure support).
</dd>
	<dd>
［
`bytes$l ／ `undefined^jv
］以外の値に設定した場合、
`new ReadableStream()$m 構築子は例外を投出することになる。
◎
Setting any value other than "bytes" or undefined will cause the ReadableStream() constructor to throw an exception.
</dd>

	<dt>
`autoAllocateChunkSize@usc
（~byte~stream用に限る）
（ `unsigned long long$I 型）
◎
autoAllocateChunkSize (byte streams only), of type unsigned long long
</dt>
	<dd>
正な整数に設定すれば、［
実装が、下層~源の~code用に，書込n用の~bufferを自動的に割振る
］ようにできる。
この事例では、`消費器$が`既定の読取器$を利用しているときは、~stream実装は，所与の~sizeの `ArrayBuffer$I を自動的に割振る
— ［
消費器は`~BYOB読取器$を利用していた
］かのように，常に
<code>%controller.`byobRequest$rbsc</code>
が在るようにするため。
◎
Can be set to a positive integer to cause the implementation to automatically allocate buffers for the underlying source code to write into. In this case, when a consumer is using a default reader, the stream implementation will automatically allocate an ArrayBuffer of the given size, so that controller.byobRequest is always present, as if the consumer was using a BYOB reader.
</dd>
	<dd>
これは，一般に、［
既定の読取器を利用する消費器
］を取扱うために必要な~code量も減らすために利用される
— 次の 2 つを比較されたし
⇒＃
自動-割振りを伴わない`下層~push源を伴う可読~byte~stream（背圧~supportなし）$sec,
自動-割振りを伴う`下層~pull源を伴う可読~byte~stream$sec
◎
This is generally used to cut down on the amount of code needed to handle consumers that use default readers, as can be seen by comparing § 9.3 A readable byte stream with an underlying push source (no backpressure support) without auto-allocation to § 9.5 A readable byte stream with an underlying pull source with auto-allocation.
</dd>
</dl>

<p>
［
`start()$usc ／ `pull()$usc
］~methodに渡される %controller 引数の型は，
`type$usc ~optionの値に依存し、それに応じて
⇒＃
`undefined^jv （または省略された）ならば `ReadableStreamDefaultController$I になる ／
`bytes$l ならば `ReadableByteStreamController$I になる
◎
The type of the controller argument passed to the start() and pull() methods depends on the value of the type option. If type is set to undefined (including via omission), then controller will be a ReadableStreamDefaultController. If it’s set to "bytes", then controller will be a ReadableByteStreamController.
</p>

			</section>
			<section id="rs-prototype">
<h4 title="Constructor, methods, and properties">4.2.4. 構築子／~method／~prop</h4>

<dl class="domintro">
	<dt>%stream = `new ReadableStream(underlyingSource[, strategy])$m</dt>
	<dd>
供された`下層~源$を包装している新たな `ReadableStream$I を作成する。
%underlyingSource 引数についての詳細は、`下層~源~API$secを見よ。
◎
Creates a new ReadableStream wrapping the provided underlying source. See § 4.2.3 The underlying source API for more details on the underlyingSource argument.
</dd>
	<dd>
%strategy 引数は
— `~queuing策~API$secにて述べるように —
~streamの`~queuing策$を表現する。
供されなかった場合の既定の挙動は、`限界水位$ 1 にされた `CountQueuingStrategy$I と同じになる。
◎
The strategy argument represents the stream’s queuing strategy, as described in § 7.1 The queuing strategy API. If it is not provided, the default behavior will be the same as a CountQueuingStrategy with a high water mark of 1.
</dd>

	<dt>%isLocked = %stream.`locked$rs</dt>
	<dd>
可読~streamが読取器に`~lockされて$いるかどうかを返す。
◎
Returns whether or not the readable stream is locked to a reader.
</dd>

	<dt>await %stream.`cancel([ reason ])$rs</dt>
	<dd>
~streamを`取消して$，［
`消費器$が~streamへの関心を失った
］ことを通達する。
給された %reason 引数は、`下層~槽$の `cancel()$usc ~methodに~~渡される
— 利用されるとは限らないが。
◎
Cancels the stream, signaling a loss of interest in the stream by a consumer. The supplied reason argument will be given to the underlying source’s cancel() method, which might or might not use it.
</dd>
	<dd>
返される~promiseは、［
~streamは成功裡に~shut-downされた場合には充足される／
当の`下層~槽$から そうするときに~errorしたことが通達された場合には却下される
］ことになる。
加えて，当の~streamは現在`~lockされて$いる場合には、
`TypeError$jE で却下されることになる（当の~streamを取消すよう試みることなく）。
◎
The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying source signaled that there was an error doing so. Additionally, it will reject with a TypeError (without attempting to cancel the stream) if the stream is currently locked.
</dd>

	<dt>%reader = %stream.`getReader()$rs</dt>
	<dd>
`ReadableStreamDefaultReader$I を作成して返すと同時に，~streamを その新たな読取器に`~lock$する。
~streamが`~lockされて$いる間は、`解放-$されるまで，他の読取器は~lockを獲得できなくなる。
◎
Creates a ReadableStreamDefaultReader and locks the stream to the new reader. While the stream is locked, no other reader can be acquired until this one is released.
</dd>
	<dd>
この機能性は、［［
~streamを，それ全体として消費する能
］を欲するような，抽象-化
］を創出するときに，とりわけ有用になる。
利用者は、~stream用の読取器を取得することにより，［
他から［
読取nが差挟まれたり，~streamが取消される
］ことにより，自身による抽象-化が干渉される
］ことがないことを確保できる。
◎
This functionality is especially useful for creating abstractions that desire the ability to consume a stream in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours or cancel the stream, which would interfere with your abstraction.
</dd>

	<dt>%reader = %stream.`getReader$rs({ `mode$rsgo: `byob$l })</dt>
	<dd>
`ReadableStreamBYOBReader$I を作成して返すと同時に，~streamを その新たな読取器に`~lock$する。
◎
Creates a ReadableStreamBYOBReader and locks the stream to the new reader.
</dd>
	<dd>
この~callは、引数をとらない変種と同じ仕方で挙動する
— `可読~byte~stream$（すなわち、
“開発者が~bufferを給する”
読取りを取扱う能を特定的に備えるように構築された~stream）に限り，働くことを除いて。
返される`~BYOB読取器$は、その `read()$byob ~methodを介して，［
~streamから開発者から給された~bufferの中へ 個々の`~chunk$を直に読取する能
］を供して、~bufferの割振りをより精確に制御できるようにする。
◎
This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle "bring your own buffer" reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.
</dd>

	<dt>%readable = %stream.`pipeThrough$rs({ `writable$rwp, `readable$rwp }[, { `preventClose$spo, `preventAbort$spo, `preventCancel$spo, `signal$spo }])</dt>
	<dd>
［
`形式変換~stream$（または，他の
<code>{ %writable, %readable }</code>
~pair）を通して，この`可読~stream$を`~pipeする$
］ための，簡便かつ連鎖-可能な仕方を供する。
それは 単純に、給された~pairの可書~側へ~streamを~pipeして，更なる利用のために 可読~側を返す。
◎
Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other { writable, readable } pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
</dd>
	<dd>
~streamが~pipeされている間は、他の消費器が読取器を獲得できないように，~streamは`~lock$される。
◎
Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
</dd>

	<dt>await %stream.`pipeTo$rs(%destination[, { `preventClose$spo, `preventAbort$spo, `preventCancel$spo, `signal$spo }])</dt>
	<dd>
この`可読~stream$を，所与の`可書~stream$ %destination に`~pipeする$。
~pipeする処理nにおける 種々の~error条件の下での挙動は、渡された~optionsにより~custom化できる。
この~methodは、~promiseを返す
— それは、~pipeする処理nが
⇒＃
成功裡に完了したときは充足される／
何らかの~errorに遭遇したときは却下される
◎
Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.
</dd>
	<dd>
~streamが~pipeされている間は、他の消費器が読取器を獲得できないよう，~streamは`~lock$される。
◎
Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
</dd>
	<dd>
<p>
源の`可読~stream$ %source,
行先の`可書~stream$ %destination
における［
~error／~closure
］は、次に従って伝播する：
◎
Errors and closures of the source and destination streams propagate as follows:
</p>
		<ul>
			<li>
%source における~errorは、［
`preventAbort$spo が~truthy
］でない限り，
%destination を`中止する$ことになる。
返される~promiseは、［
%destination を中止する間に~errorが生じたなら その~error ／
~ELSE_ %source における~error
］で却下されることになる。
◎
An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source’s error, or with any error that occurs during aborting the destination.
</li>
			<li>
%destination における~errorは、［
`preventCancel$spo が~truthy
］でない限り，
%source を`取消す$ことになる。
返される~promiseは、［
%source を取消す間に~errorが生じたなら その~error ／
~ELSE_ %dest における~error
］で却下されることになる。
◎
An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination’s error, or with any error that occurs during canceling the source.
</li>
			<li>
%source が~closeしたときは、［
`preventClose$spo が~truthy
］でない限り，
%destination も~closeさせることになる。
返される~promiseは、［
%destination を~closeしている間に~errorに遭遇したなら その~errorで却下される ／
~ELSE_ この処理nが完了した時点で充足される
］ことになる。
◎
When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.
</li>
			<li>
%destination が［
~closeされ始めたとき ／ ~close中にある
］場合、［
`preventCancel$spo が~truthy【！~EQ ~T】
］でない限り，
%source は`取消され$ることになる。
返される~promiseは，［
%source を取消す間に~errorが生じたなら  その~error ／
~ELSE_ ~streamは~closeされたため~pipeするのに失敗したことを指示する~error
］で却下されることになる。
◎
If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.
</li>
		</ul>
<p>
`signal$spo ~optionに `AbortSignal$I を設定すれば、進行中の~pipe演算を対応する `AbortController$I を介して中止できるようになる。
この事例では、［
`preventCancel$spo ／ `preventAbort$spo
］~optionが ~T に設定されない限り，［
%source は`取消され$る ／ %destination は`中止-$される
］ことになる。
◎
The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.
</p>
	</dd>

	<dt>[%branch1, %branch2] = %stream.`tee()$rs</dt>
	<dd>
この可読~streamを`二叉化-$して、結果の 2 個の`分岐$
— いずれも，新たな `ReadableStream$I ~instanceを成す —
からなる，~~長さ 2 の配列を返す。
◎
Tees this readable stream, returning a two-element array containing the two resulting branches as new ReadableStream instances.
</dd>
	<dd>
~streamを二叉化すると、`~lock$され，他の消費器は読取器を獲得できなくなる。
~streamを`取消す$ためには、結果の分岐を両者とも取消す
— その結果、この複合的な取消n事由が，~streamの`下層~源$まで伝播されることになる。
◎
Teeing a stream will lock it, preventing any other consumer from acquiring a reader. To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be propagated to the stream’s underlying source.
</dd>
	<dd>
各~分岐~内で見える`~chunk$たちは 同じ~objになるので、~chunkが変異-可能な場合， 2 個の分岐~間で互いに干渉し合うことも許容されることに注意。
◎
Note that the chunks seen in each branch will be the same object. If the chunks are not immutable, this could allow interference between the two branches.
</dd>
</dl>

<div class="algo">
<p>
`new ReadableStream(underlyingSource, strategy)@m
構築子~手続きは：
◎
The ReadableStream(underlyingSource, strategy) constructor steps are:
</p>
<ol>
	<li>
~IF［
%underlyingSource ~EQ ε
］
⇒
%underlyingSource ~SET ~NULL
◎
If underlyingSource is missing, set it to null.
</li>
	<li>
<p>
%underlyingSourceDict ~LET %underlyingSource を `UnderlyingSource$I 型の`~IDL値に変換-$した結果
◎
Let underlyingSourceDict be underlyingSource, converted to an IDL value of type UnderlyingSource.
</p>

<p class="note">注記：
%underlyingSource 引数を `UnderlyingSource$I 型として直に宣言できないのは、元の~objへの参照が失われるからである。
~obj上の各種~methodを`~methodを呼出せる$よう、~objは維持する必要がある。
◎
We cannot declare the underlyingSource argument as having the UnderlyingSource type directly, because doing so would lose the reference to the original object. We need to retain the object so we can invoke the various methods on it.
</p>
	</li>
	<li>
~NOABRUPT `InitializeReadableStream$A( コレ )
◎
Perform ! InitializeReadableStream(this).
</li>
	<li>
<p>
~IF［
%underlyingSourceDict[ "`type$usc" ] ~EQ `bytes$l
］：
◎
If underlyingSourceDict["type"] is "bytes":
</p>
		<ol>
			<li>
~IF［
%size ~NEQ `undefined^jv
］
⇒
~THROW `RangeError$E
◎
If strategy["size"] exists, throw a RangeError exception.
</li>
			<li>
%highWaterMark ~LET
~ABRUPT `ExtractHighWaterMark$A( %strategy, 0 )
◎
Let highWaterMark be ? ExtractHighWaterMark(strategy, 0).
</li>
			<li>
~ABRUPT `SetUpReadableByteStreamControllerFromUnderlyingSource$A( コレ, %underlyingSource, %underlyingSourceDict, %highWaterMark )
◎
Perform ? SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, underlyingSourceDict, highWaterMark).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%underlyingSourceDict[ "`type$usc" ] ~EQ ε
◎
Assert: underlyingSourceDict["type"] does not exist.
</li>
			<li>
%sizeAlgorithm ~LET
~ABRUPT `ExtractSizeAlgorithm$A( %strategy )
◎
Let sizeAlgorithm be ! ExtractSizeAlgorithm(strategy).
</li>
			<li>
%highWaterMark ~LET
~ABRUPT `ExtractHighWaterMark$A( %strategy, 1 )
◎
Let highWaterMark be ? ExtractHighWaterMark(strategy, 1).
</li>
			<li>
~ABRUPT `SetUpReadableStreamDefaultControllerFromUnderlyingSource$A( コレ, %underlyingSource, %underlyingSourceDict, %highWaterMark, %sizeAlgorithm )
◎
Perform ? SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, underlyingSourceDict, highWaterMark, sizeAlgorithm).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`locked@rs
取得子~手続きは：
◎
The locked attribute’s getter steps are:
</p>
<ol>
	<li>
~RET
~NOABRUPT `IsReadableStreamLocked$A( コレ )
◎
Return ! IsReadableStreamLocked(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`cancel(reason)@rs
~method~手続きは：
◎
The cancel(reason) method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( コレ ) ~EQ ~T
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If ! IsReadableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `ReadableStreamCancel$A( コレ, %reason )
◎
Return ! ReadableStreamCancel(this, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`getReader(options)@rs
~method~手続きは：
◎
The getReader(options) method steps are:
</p>
<ol>
	<li>
~IF［
%options[ "`mode$rsgo" ] ~EQ ε
］
⇒
~RET
~ABRUPT `AcquireReadableStreamDefaultReader$A( コレ )
◎
If options["mode"] does not exist, return ? AcquireReadableStreamDefaultReader(this).
</li>
	<li>
~Assert：
%options[ "`mode$rsgo" ] ~EQ `byob$l
◎
Assert: options["mode"] is "byob".
</li>
	<li>
~RET
~ABRUPT `AcquireReadableStreamBYOBReader$A( コレ )
◎
Return ? AcquireReadableStreamBYOBReader(this).
</li>
</ol>

<div class="example" id="example-read-all-chunks">

<p>
読取器を利用すれば便益を得られるであろう抽象-化の例として、可読~stream全体を`~chunk$の配列として記憶域の中に読取するように設計された，次のような関数がある：
◎
An example of an abstraction that might benefit from using a reader is a function like the following, which is designed to read an entire readable stream into memory as an array of chunks.
</p>

<pre class="lang-js">
function readAllChunks(%readableStream) {
  const %reader = %readableStream.getReader();
  const %chunks = [];

  return pump();

  function pump() {
    return %reader.read().then(({ %value, %done }) =&gt; {
      if (%done) {
        return %chunks;
      }

      %chunks.push(%value);
      return pump();
    });
  }
}
</pre>

<p>
最初に 読取器を得することで、読取器を排他的に利用していることに注意。
これにより、他の消費器は，［
~chunkを読取したり, ~streamを`取消す$ことにより，~streamに干渉する
］ことはできなくなる。
◎
Note how the first thing it does is obtain a reader, and from then on it uses the reader exclusively. This ensures that no other consumer can interfere with the stream, either by reading chunks or by canceling the stream.
</p>
</div>
</div>

<div class="algo">
<p>
`pipeThrough(transform, options)@rs
~method~手続きは：
◎
The pipeThrough(transform, options) method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( コレ ) ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If ! IsReadableStreamLocked(this) is true, throw a TypeError exception.
</li>
	<li>
~IF［
~NOABRUPT `IsWritableStreamLocked$A( %transform[ "`writable$rwp" ] ) ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If ! IsWritableStreamLocked(transform["writable"]) is true, throw a TypeError exception.
</li>
	<li>
%signal ~LET %options[ "`signal$spo" ]
◎
Let signal be options["signal"]＼
</li>
	<li>
~IF［
%signal ~EQ ε
］
⇒
%signal ~SET `undefined^jv
◎
if it exists, or undefined otherwise.
</li>
	<li>
%promise ~LET
~NOABRUPT `ReadableStreamPipeTo$A(
コレ,
%transform[ "`writable$rwp" ],
%options[ "`preventClose$spo" ],
%options[ "`preventAbort$spo" ],
%options[ "`preventCancel$spo" ],
%signal
)
◎
Let promise be ! ReadableStreamPipeTo(this, transform["writable"], options["preventClose"], options["preventAbort"], options["preventCancel"], signal).
</li>
	<li>
%promise.`PromiseIsHandled^sl ~SET ~T
◎
Set promise.[[PromiseIsHandled]] to true.
</li>
	<li>
~RET %transform[ "`readable$rwp" ]
◎
Return transform["readable"].
</li>
</ol>

<div class="example" id="example-pipe-chain">

<p>
`pipeThrough(transform, options)$rs
を利用して`~pipe鎖$を構築する代表的な例：
◎
A typical example of constructing pipe chain using pipeThrough(transform, options) would look like
</p>

<pre class="lang-js">
%httpResponseBody
  .pipeThrough(%decompressorTransform)
  .pipeThrough(%ignoreNonImageFilesTransform)
  .pipeTo(%mediaGallery);
</pre>
</div>
</div>

<div class="algo">
<p>
`pipeTo(destination, options)@rs
~method~手続きは：
◎
The pipeTo(destination, options) method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( コレ ) ~EQ ~T
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If ! IsReadableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF［
~NOABRUPT `IsWritableStreamLocked$A( %destination ) ~EQ ~T
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If ! IsWritableStreamLocked(destination) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
%signal ~LET %options[ "`signal$spo" ]
◎
Let signal be options["signal"]＼
</li>
	<li>
~IF［
%signal ~EQ ε
］
⇒
%signal ~SET `undefined^jv
◎
if it exists, or undefined otherwise.
</li>
	<li>
~RET
~NOABRUPT `ReadableStreamPipeTo$A(
コレ,
%destination,
%options[ "`preventClose$spo" ],
%options[ "`preventAbort$spo" ],
%options[ "`preventCancel$spo" ],
%signal
)
◎
Return ! ReadableStreamPipeTo(this, destination, options["preventClose"], options["preventAbort"], options["preventCancel"], signal).
</li>
</ol>
</div>

<div class="example">
<p>
`AbortSignal$I を利用すれば、進行中の`~pipe$演算を次のように停止できる：
◎
An ongoing pipe operation can be stopped using an AbortSignal, as follows:
</p>

<pre class="lang-js">
const %controller = new AbortController();
%readable.pipeTo(%writable, { signal: %controller.signal });

/* <span class="comment">
… しばらく後で …
◎
... some time later ...
</span> */
%controller.abort();
</pre>

<p>
（上では `pipeTo()$rs から返される~promise用の~errorの取扱いを省略している。
加えて，［
`preventAbort$spo ／ `preventCancel$spo
］~optionも、~pipingの停止-時に何が起こるかに影響iがあり，考慮するに価する。）
◎
(The above omits error handling for the promise returned by pipeTo(). Additionally, the impact of the preventAbort and preventCancel options what happens when piping is stopped are worth considering.)
</p>
</div>

<div class="example">

<p>
上の技法は、同じ `WritableStream$I の中へ書込している間に，~pipeされている `ReadableStream$I を切替えるときにも利用できる：
◎
The above technique can be used to switch the ReadableStream being piped, while writing into the same WritableStream:
</p>

<pre class="lang-js">
const %controller = new AbortController();
const %pipePromise = %readable1.pipeTo(%writable, { preventAbort: true, signal: %controller.signal });

/* <span class="comment">
… しばらく後で …
◎
... some time later ...
</span> */
%controller.abort();

/* <span class="comment">
新たな~pipeを開始する前に，当の~pipeが完了するまで待機する：
◎
Wait for the pipe to complete before starting a new one:
</span> */
try {
 await %pipePromise;
} catch (%e) {
 /* <span class="comment">
予期される `AbortError^E 例外に限り，ここで吸い取る
— 他の失敗は投出し直す。
◎
Swallow "AbortError" DOMExceptions as expected, but rethrow any unexpected failures.
</span> */
 if (%e.name !== "AbortError") {
  throw %e;
 }
}

/* <span class="comment">
新たな~pipeを開始する。
◎
Start the new pipe!
</span> */
%readable2.pipeTo(%writable);
</pre>
</div>

<div class="algo">
<p>
`tee()@rs
~method~手続きは：
◎
The tee() method steps are:
</p>
<ol>
	<li>
~RET
~ABRUPT `ReadableStreamTee$A( コレ, ~F )
◎
Return ? ReadableStreamTee(this, false).
</li>
</ol>

<div class="example" id="example-tee-and-pipe">

<p>
~streamの二叉化は、~streamを 2 個の独立な消費器から並列的に
— たぶん異なる速度で —
読取させたいと望むときに最も有用になる。
例えば、［
~disk上の~fileを表現している可書~stream %cacheEntry
］と, ［
~remote~serverへの~uploadを表現している別の可書~stream %httpRequestBody
］が与えられたとき、同じ可読~streamを，同時に両~行先へ~pipeすることもできる：
◎
Teeing a stream is most useful when you wish to let two independent consumers read from the stream in parallel, perhaps even at different speeds. For example, given a writable stream cacheEntry representing an on-disk file, and another writable stream httpRequestBody representing an upload to a remote server, you could pipe the same readable stream to both destinations at once:
</p>

<pre class="lang-js">
const [%forLocal, %forRemote] = %readableStream.tee();
Promise.all([
  %forLocal.pipeTo(%cacheEntry),
  %forRemote.pipeTo(%httpRequestBody)
])
.then(() =&gt; console.log(
    `~streamは ~cacheに保存され, ~uploadされました^l))
.catch(%e =&gt; console.error(
    `~cache時または~upload時に失敗しました: ^l, %e));
</pre>
<!-- 
"Saved the stream to the cache and also uploaded it!"
"Either caching or uploading failed: "
 -->
</div>
</div>

			</section>
			<section id="rs-asynciterator">
<h4 title="Asynchronous iteration">4.2.5. 非同期的な反復</h4>

<dl class="domintro">
	<dt>for await (const %chunk of %stream) { ... }</dt>
	<dt>for await (const %chunk of %stream.values({ `preventCancel$rsio: true })) { ... }</dt>
	<dd>
当の~streamの`内部~queue$内にある`~chunk$たちを非同期的に反復する。
◎
Asynchronously iterates over the chunks in the stream’s internal queue.
</dd>
	<dd>
当の~streamを非同期的に反復する間は、他の消費器が読取器を獲得できないよう，~streamは`~lock$されることになる。
この~lockは、非同期c反復子の `return()^c ~methodが~callされたとき，解放されることになる
— 例： `for^c ~loopから `break^c して出ることにより。
◎
Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader. The lock will be released if the async iterator’s return() method is called, e.g. by breaking out of the loop.
</dd>
	<dd>
既定では、非同期c反復子の `return()^c ~methodを~callすると，当の~streamも`取消す$ことになる。
これを防止するには、~streamの `values()^c ~methodを
— その `preventCancel$rsio ~optionに ~T を渡して —
利用する。
◎
By default, calling the async iterator’s return() method will also cancel the stream. To prevent this, use the stream’s values() method, passing true for the preventCancel option.
</dd>
</dl>

<div class="algo">
<p id="rs-get-iterator">
`ReadableStream$I 用の`非同期~反復子の初期化~手続き$は、所与の
( %stream, %iterator, %args )
に対し：
◎
The asynchronous iterator initialization steps for a ReadableStream, given stream, iterator, and args, are:
</p>
<ol>
	<li>
%reader ~LET
~ABRUPT `AcquireReadableStreamDefaultReader$A( %stream )
◎
Let reader be ? AcquireReadableStreamDefaultReader(stream).
</li>
	<li>
%iterator の
`非同期c読取器@
~SET %reader
◎
Set iterator’s reader to reader.
</li>
	<li>
%preventCancel ~LET %args[0][ "`preventCancel$rsio" ]
◎
Let preventCancel be args[0]["preventCancel"].
</li>
	<li>
%iterator の
`取消-を防止する？@
~SET %preventCancel
◎
Set iterator’s prevent cancel to preventCancel.
</li>
</ol>
</div>

<div class="algo">
<p id="rs-asynciterator-prototype-next">
`ReadableStream$I 用の`次回の反復~結果を取得する手続き$は、所与の
( %stream, %iterator )
に対し：
◎
The get the next iteration result steps for a ReadableStream, given stream and iterator, are:
</p>
<ol>
	<li>
%reader ~LET %iterator の`非同期c読取器$
◎
Let reader be iterator’s reader.
</li>
	<li>
~IF［
%reader.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError$jE で`却下される~promise$
◎
If reader.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
%readRequest ~LET 次に挙げる`~item$sctを伴う，新たな`読取n要請$
:
◎
Let readRequest be a new read request with the following items:
</p>
		<ul>
			<li>
`~chunk手続き$rRは、所与の
( %chunk )
に対し
⇒
%chunk で %promise を`解決する$
◎
chunk steps, given chunk
• Resolve promise with chunk.
</li>
			<li>
<p>
`~close手続き$rRは：
◎
close steps
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( %reader )
◎
Perform ! ReadableStreamReaderGenericRelease(reader).
</li>
					<li>
`反復~終端-$i で %promise を`解決する$
◎
Resolve promise with end of iteration.
</li>
				</ol>
			</li>
			<li>
<p>
`~error手続き$rRは、所与の
( %e )
に対し：
◎
error steps, given e
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( %reader )
◎
Perform ! ReadableStreamReaderGenericRelease(reader).
</li>
					<li>
%e で %promise を`却下する$
◎
Reject promise with e.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~NOABRUPT `ReadableStreamDefaultReaderRead$A( コレ, %readRequest )
◎
Perform ! ReadableStreamDefaultReaderRead(this, readRequest).
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">

<p id="rs-asynciterator-prototype-return">
`ReadableStream$I 用の`非同期~反復子の~return手続き$は、所与の
( %stream, %iterator, %arg )
に対し：
◎
The asynchronous iterator return steps for a ReadableStream, given stream, iterator, and arg, are:
</p>
<ol>
	<li>
%reader ~LET %iterator の`非同期c読取器$
◎
Let reader be iterator’s reader.
</li>
	<li>
~IF［
%reader.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET `undefined^jv で`解決される~promise$
◎
If reader.[[ownerReadableStream]] is undefined, return a promise resolved with undefined.
</li>
	<li>
~Assert：
%reader.`readRequests^sl は`空$である
— `next()^c に対する以前の~callは、非同期c反復子の機構により，これが~callされる前に決着することが保証されるので。
◎
Assert: reader.[[readRequests]] is empty, as the async iterator machinery guarantees that any previous calls to next() have settled before this is called.
</li>
	<li>
<p>
~IF［
%iterator の`取消-を防止する？$ ~EQ ~F
］：
◎
If iterator’s prevent cancel is false:
</p>
		<ol>
			<li>
%result ~LET
~NOABRUPT `ReadableStreamReaderGenericCancel$A( %reader, %arg )
◎
Let result be ! ReadableStreamReaderGenericCancel(reader, arg).
</li>
			<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( %reader )
◎
Perform ! ReadableStreamReaderGenericRelease(reader).
</li>
			<li>
~RET %result
◎
Return result.
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( %reader )
◎
Perform ! ReadableStreamReaderGenericRelease(reader).
</li>
	<li>
~RET `undefined^jv で`解決される~promise$
◎
Return a promise resolved with undefined.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="default-reader-class">
<h3 title="The ReadableStreamDefaultReader class">4.3. `ReadableStreamDefaultReader^I ~class</h3>

<p>
`ReadableStreamDefaultReader$I ~classは、［
`ReadableStream$I ~instanceから配給されるように設計された `既定の読取器$
］を表現する。
◎
The ReadableStreamDefaultReader class represents a default reader designed to be vended by a ReadableStream instance.
</p>

			<section id="default-reader-class-definition">
<h4 title="Interface definition">4.3.1. ~interface定義</h4>

<p>
`ReadableStreamDefaultReader$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ReadableStreamDefaultReader class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ReadableStreamDefaultReader@I {
  `ReadableStreamDefaultReader$mc(`ReadableStream$I %stream);

  readonly attribute Promise&lt;void&gt; `closed$dr;

  Promise&lt;void&gt; `cancel$dr(optional any %reason);
  Promise&lt;`ReadableStreamDefaultReadResult$I&gt; `read$dr();
  void `releaseLock$dr();
};

dictionary `ReadableStreamDefaultReadResult@I {
  any `value@drr;
  `boolean$ `done@drr;
};
</pre>

			</section>
			<section id="default-reader-internal-slots">
<h4 title="Internal slots">4.3.2. 内部~slot</h4>

<p>
`ReadableStreamDefaultReader$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamDefaultReader are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`closedPromise^sl
<td>
この読取器の `closed$dr 取得子から返される~promise。
◎
A promise returned by the reader’s closed getter

<tr><td>`ownerReadableStream^sl
<td>
この読取器を所有する `ReadableStream$I ~instance
◎
A ReadableStream instance that owns this reader

<tr><td>`readRequests^sl
<td>
`読取n要請$たちが成す`~list$
— `消費器$が，可用になるより早く`~chunk$たちを要請するとき利用される
◎
A list of read requests, used when a consumer requests chunks sooner than they are available

</tbody></table>

<p>
`読取n要請@
は、`構造体$であり，次に挙げる`~item$sctを伴う
— これらの~itemは、`可読~stream$の［
`内部~queue$が~fillされた／状態が変化した
］ときに対する反応として遂行される~algoを与える：
◎
A read request is a struct containing three algorithms to perform in reaction to filling the readable stream's internal queue or changing its state. It has the following items:
</p>

<dl class="def-list">
	<dt>
`~chunk手続き@rR
◎
chunk steps
</dt>
	<dd>
1 個の`~chunk$をとる~algo
— ~chunkが読取り用に可用になったとき~callされる。
◎
An algorithm taking a chunk, called when a chunk is available for reading
</dd>

	<dt>
`~close手続き@rR
◎
close steps
</dt>
	<dd>
引数をとらない~algo
— ~streamは~closeされたため，可用な`~chunk$は無いとき~callされる。
◎
An algorithm taking no arguments, called when no chunks are available because the stream is closed
</dd>

	<dt>
`~error手続き@rR
◎
error steps
</dt>
	<dd>
~JS値をとる~algo
— ~streamは~errorしたため，可用な`~chunk$は無いとき~callされる。
◎
An algorithm taking a JavaScript value, called when no chunks are available because the stream is errored
</dd>
</dl>

			</section>
			<section id="default-reader-prototype">
<h4 title="Constructor, methods, and properties">4.3.3. 構築子／~method／~prop</h4>

<dl class="domintro">
	<dt>%reader = `new ReadableStreamDefaultReader(stream)$m</dt>
	<dd>
これは、
<code>%stream.`getReader()$rs</code>
を~callするのと等価になる。
◎
This is equivalent to calling stream.getReader().
</dd>

	<dt>await %reader.`closed$dr</dt>
	<dd>
~promiseを返す
— それは、~streamが~closeされたときは 充足され，［
~streamがどこかで~errorしたとき ／
~streamが~closeし終える前に読取器の~lockが`解放-$されたとき
］は 却下されることになる。
◎
Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or the reader’s lock is released before the stream finishes closing.
</dd>

	<dt>await %reader.`cancel([ reason ])$dr</dt>
	<dd>
当の読取器は`作動中$である場合、
<code>%stream.`cancel(reason)$rs</code>
と同じに挙動する。
◎
If the reader is active, behaves the same as stream.cancel(reason).
</dd>

	<dt>{ %value, %done } = await %reader.`read()$dr</dt>
	<dd>
<p>
［
~streamの内部~queueから，次回の可用な`~chunk$に~accessできる
］ようにする，~promiseを返す
— この~promiseは：
◎
Returns a promise that allows access to the next chunk from the stream’s internal queue, if available.
</p>
		<ul>
			<li>
可用な~chunkが無くなったときは、
`{ value: theChunk, done: false }^c
の形による~objで充足されることになる。
◎
If the chunk does become available, the promise will be fulfilled with an object of the form { value: theChunk, done: false }.
</li>
			<li>
~streamが~closeされたときは、
`{ value: undefined, done: true }^c
の形による~objで充足されることになる。
◎
If the stream becomes closed, the promise will be fulfilled with an object of the form { value: undefined, done: true }.
</li>
			<li>
~streamが~errorしたときは、関連な~errorで却下されることになる。
◎
If the stream becomes errored, the promise will be rejected with the relevant error.
</li>
		</ul>
<p>
~chunkの読取りにより~queueが空になったときは、`下層~源$から更に~dataが~pullされることになる。
◎
If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
</p>
	</dd>

	<dt>%reader.`releaseLock()$dr</dt>
	<dd>
対応する~stream上の読取器の`~lockを解放-$する。
解放されたなら、読取器は`作動中$でなくなる。
~lockが解放された時点から、読取器は，［
結付けられている~streamが~errorした場合は~errorしたように／
他の場合は~closeされたように
］現れるようになる。
◎
Releases the reader’s lock on the corresponding stream. After the lock is released, the reader is no longer active. If the associated stream is errored when the lock is released, the reader will appear errored in the same way from now on; otherwise, the reader will appear closed.
</dd>
	<dd>
読取器の~lockは、処理待ちにある読取n要請が まだある間
— すなわち，読取器の `read()$dr ~methodから返された~promiseがまだ決着していない間 —
は、解放できない。
そのような試みは、 `TypeError$jE を投出させ，~streamは読取器に~lockされたままになる。
◎
A reader’s lock cannot be released while it still has a pending read request, i.e., if a promise returned by the reader’s read() method has not yet been settled. Attempting to do so will throw a TypeError and leave the reader locked to the stream.
</dd>
</dl>

<div class="algo">
<p>
`new ReadableStreamDefaultReader(stream)@m
構築子~手続きは：
◎
The ReadableStreamDefaultReader(stream) constructor steps are:
</p>
<ol>
	<li>
~ABRUPT `SetUpReadableStreamDefaultReader$A(コレ, %stream).
◎
Perform ? SetUpReadableStreamDefaultReader(this, stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`closed@dr
取得子~手続きは：
◎
The closed getter steps are:
</p>
<ol>
	<li>
~RET コレ.`closedPromise^sl
◎
Return this.[[closedPromise]].
</li>
</ol>
</div>

<div class="algo">
<p>
`cancel(reason)@dr
~method~手続きは：
◎
The cancel(reason) method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `ReadableStreamReaderGenericCancel$A( コレ, %reason )
◎
Return ! ReadableStreamReaderGenericCancel(this, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`read()@dr
~method~手続きは：
◎
The read() method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
%readRequest ~LET 次に挙げる`~item$sctを伴う，新たな`読取n要請$
:
◎
Let readRequest be a new read request with the following items:
</p>
		<ul>
			<li>
`~chunk手続き$rRは、所与の
( %chunk )
に対し
⇒
«[ "`value$drr" → %chunk, "`done$drr" → ~F ]»
で %promise を`解決する$
◎
chunk steps, given chunk
• Resolve promise with «[ "value" → chunk, "done" → false ]».
</li>
			<li>
`~close手続き$rRは
⇒
«[ "`value$drr" → `undefined^jv, "`done$drr" → ~T ]»
で %promise を`解決する$
◎
close steps
• Resolve promise with «[ "value" → undefined, "done" → true ]».
</li>
			<li>
`~error手続き$rRは、所与の
( %e )
に対し
⇒
%e で %promise を`却下する$
◎
error steps, given e
• Reject promise with e.
</li>
		</ul>
	</li>
	<li>
~RET
~NOABRUPT `ReadableStreamDefaultReaderRead$A( コレ, %readRequest )
◎
Perform ! ReadableStreamDefaultReaderRead(this, readRequest).
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`releaseLock()@dr
~method~手続きは：
◎
The releaseLock() method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET
◎
If this.[[ownerReadableStream]] is undefined, return.
</li>
	<li>
~IF［
コレ.`readRequests^sl は`空$でない
］
⇒
~THROW `TypeError^jE
◎
If this.[[readRequests]] is not empty, throw a TypeError exception.
</li>
	<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( コレ )
◎
Perform ! ReadableStreamReaderGenericRelease(this).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="byob-reader-class">
<h3 title="The ReadableStreamBYOBReader class">4.4. `ReadableStreamBYOBReader^I ~class</h3>

<p>
`ReadableStreamBYOBReader$I ~classは、［
`ReadableStream$I ~instanceにより配給されるように設計された `~BYOB読取器$
］を表現する。
◎
The ReadableStreamBYOBReader class represents a BYOB reader designed to be vended by a ReadableStream instance.
</p>

			<section id="byob-reader-class-definition">
<h4 title="Interface definition">4.4.1. ~interface定義</h4>

<p>
`ReadableStreamBYOBReader$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ReadableStreamBYOBReader class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ReadableStreamBYOBReader@I {
  `ReadableStreamBYOBReader$mc(`ReadableStream$I %stream);

  readonly attribute Promise&lt;void&gt; `closed$byob;

  Promise&lt;void&gt; `cancel$byob(optional any %reason);
  Promise&lt;`ReadableStreamBYOBReadResult$I&gt; `read$byob(`ArrayBufferView$I %view);
  void `releaseLock$byob();
};

dictionary `ReadableStreamBYOBReadResult@I {
 `ArrayBufferView$I `value@brr;
 `boolean$ `done@brr;
};
</pre>

			</section>
			<section id="byob-reader-internal-slots">
<h4 title="Internal slots">4.4.2. 内部~slot</h4>

<p>
`ReadableStreamBYOBReader$I
の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamBYOBReader are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`closedPromise^sl
<td>
この読取器の `closed$byob 取得子から返される~promise。
◎
A promise returned by the reader’s closed getter

<tr><td>`ownerReadableStream^sl
<td>
この読取器を所有する `ReadableStream$I ~instance
◎
A ReadableStream instance that owns this reader

<tr><td>`readIntoRequests^sl
<td>
`中へ読取する要請$たちが成す`~list$
— `消費器$が，可用になるより早く`~chunk$たちを要請するとき利用される
◎
A list of read-into requests, used when a consumer requests chunks sooner than they are available

</tbody></table>

<p>
`中へ読取する要請@
は、`構造体$であり，次に挙げる`~item$sctを伴う
— これらの~itemは、`可読~byte~stream$の［
`内部~queue$が~fillされた／状態が変化した
］ときに対する反応として遂行される~algoを与える：
◎
A read-into request is a struct containing three algorithms to perform in reaction to filling the readable byte stream's internal queue or changing its state. It has the following items:
</p>
<dl class="def-list">
	<dt>
`~chunk手続き@riR
◎
chunk steps
</dt>
	<dd>
`~chunk$をとる~algo
— ~chunkが読取り用に可用になったとき~callされる。
◎
An algorithm taking a chunk, called when a chunk is available for reading
</dd>

	<dt>
`~close手続き@riR
◎
close steps
</dt>
	<dd>
`~chunk$をとる~algo
— ~streamは~closeされたため，可用な`~chunk$は無いとき~callされる。
◎
An algorithm taking a chunk, called when no chunks are available because the stream is closed
</dd>

	<dt>
`~error手続き@riR
◎
error steps
</dt>
	<dd>
~JS値をとる~algo
— ~streamは~errorしたため可用な`~chunk$は無いとき~callされる。
◎
An algorithm taking a JavaScript value, called when no chunks are available because the stream is errored
</dd>
</dl>

<p class="note">注記：
`~close手続き$riRが`~chunk$をとるのは、アリなら，~call元に裏~memoryを返せるようにするためである。
例えば
<code>%byobReader.`read(chunk)$byob</code>
は、~closeされた~streamに対しては
— より伝統的な
`{ value: undefined, done: true }^c
ではなく —
<code>{ value: %newViewOnSameMemory, done: true }</code>
で充足されることになる。
◎
The close steps take a chunk so that it can return the backing memory to the caller if possible. For example, byobReader.read(chunk) will fulfill with { value: newViewOnSameMemory, done: true } for closed streams, instead of the more traditional { value: undefined, done: true }.
</p>

			</section>
			<section id="byob-reader-prototype">
<h4 title="Constructor, methods, and properties">4.4.3. 構築子／~method／~prop</h4>

<dl class="domintro">
	<dt>%reader = `new ReadableStreamBYOBReader(stream)$m</dt>
	<dd>
これは、
<code>%stream.`getReader$rs({ `mode$rsgo: `byob$l })</code>
を~callするのと等価になる。
◎
This is equivalent to calling stream.getReader({ mode: "byob" }).
</dd>

	<dt>await %reader.`closed$byob</dt>
	<dd>
~promiseを返す
— それは、~streamが~closeされたときは 充足され，［
~streamがどこかで~errorしたとき ／
~streamが~closeし終える前に読取器の~lockが`解放-$されたとき
］は 却下されることになる。
◎
Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or the reader’s lock is released before the stream finishes closing.
</dd>

	<dt>await %reader.`cancel([ reason ])$byob</dt>
	<dd>
当の読取器は`作動中$である場合、
<code>%stream.`cancel(reason)$rs</code>
と同じに挙動する。
◎
If the reader is active, behaves the same stream.cancel(reason).
</dd>

	<dt>{ %value, %done } = await %reader.`read(view)$byob</dt>
	<dd>
<p>
~byte列を %view の中に読取しようと試みて、その結果で解決される~promiseを返す：
◎
Attempts to reads bytes into view, and returns a promise resolved with the result:
</p>
		<ul>
			<li>
可用な~chunkが無くなったときは、
<code>{ value: %theChunk, done: false }</code>
の形による~objで充足されることになる。
この事例では、 %view は`切離され$るので，もはや利用-可能でなくなるが、
%theChunk は同じ裏~memory領域への新たな（かつ同じ型の）~viewになり，~chunkの~dataは その中へ書込されるようになる。
◎
If the chunk does become available, the promise will be fulfilled with an object of the form { value: theChunk, done: false }. In this case, view will be detached and no longer usable, but theChunk will be a new view (of the same type) onto the same backing memory region, with the chunk’s data written into it.
</li>
			<li>
~streamが~closeされたときは、
<code>{ value: %theChunk, done: true }</code>
の形による~objで充足されることになる。
この事例では %view は`切離され$，もはや利用-可能でなくなるが、
%theChunk は同じ裏~memory領域への新たな（かつ同じ型の）~viewになる
— その~memoryが~call元に返されることを確保するため，改変を加えずに。
◎
If the stream becomes closed, the promise will be fulfilled with an object of the form { value: theChunk, done: true }. In this case, view will be detached and no longer usable, but theChunk will be a new view (of the same type) onto the same backing memory region, with no modifications, to ensure the memory is returned to the caller.
</li>
			<li>
~streamが~errorしたときは、関連な~errorで却下されることになる。
◎
If the stream becomes errored, the promise will be rejected with the relevant error.
</li>
		</ul>
<p>
~chunkの読取りにより~queueが空になったときは、`下層~源$から更に~dataが~pullされることになる。
◎
If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
</p></dd>

	<dt>%reader.`releaseLock()$byob</dt>
	<dd>
対応する~stream上の読取器の`~lockを解放-$する。
解放されたなら、読取器は`作動中$でなくなる。
~lockが解放された時点から、読取器は，［
結付けられている~streamが~errorした場合は~errorしたように／
他の場合は~closeされたように
］現れるようになる。
◎
Releases the reader’s lock on the corresponding stream. After the lock is released, the reader is no longer active. If the associated stream is errored when the lock is released, the reader will appear errored in the same way from now on; otherwise, the reader will appear closed.
</dd>
	<dd>
読取器の~lockは、処理待ちにある読取n要請が まだある間
— すなわち，読取器の `read()$byob ~methodから返された~promiseがまだ決着していない間 —
は、解放できない。
そのような試みは、 `TypeError$jE を投出させ，~streamは読取器に~lockされたままになる。
◎
A reader’s lock cannot be released while it still has a pending read request, i.e., if a promise returned by the reader’s read() method has not yet been settled. Attempting to do so will throw a TypeError and leave the reader locked to the stream.
</dd>
</dl>

<div class="algo">
<p>
`new ReadableStreamBYOBReader(stream)@m
構築子~手続きは：
◎
The ReadableStreamBYOBReader(stream) constructor steps are:
</p>
<ol>
	<li>
~ABRUPT `SetUpReadableStreamBYOBReader$A(コレ, %stream).
◎
Perform ? SetUpReadableStreamBYOBReader(this, stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`closed@byob
取得子~手続きは：
◎
The closed getter steps are:
</p>
<ol>
	<li>
~RET コレ.`closedPromise^sl
◎
Return this.[[closedPromise]].
</li>
</ol>
</div>

<div class="algo">
<p>
`cancel(reason)@byob
~method~手続きは：
◎
The cancel(reason) method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `ReadableStreamReaderGenericCancel$A( コレ, %reason )
◎
Return ! ReadableStreamReaderGenericCancel(this, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`read(view)@byob
~method~手続きは：
◎
The read(view) method steps are:
</p>
<ol>
	<li>
~IF［
%view.`ByteLength^sl ~EQ 0
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If view.[[ByteLength]] is 0, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF［
%view.`ViewedArrayBuffer^sl.`ArrayBufferByteLength^sl ~EQ 0
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If view.[[ViewedArrayBuffer]].[[ArrayBufferByteLength]] is 0, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF［
コレ.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>

	<li>
<p>
%readIntoRequest ~LET 次に挙げる`~item$sctを伴う，新たな`中へ読取する要請$：
◎
Let readIntoRequest be a new read-into request with the following items:
</p>
		<ul>
			<li>
`~chunk手続き$riRは、所与の
( %chunk )
に対し
⇒
«[ "`value$brr" → %chunk, "`done$brr" → ~F ]»
で %promise を`解決する$
◎
chunk steps, given chunk
• Resolve promise with «[ "value" → chunk, "done" → false ]».
</li>
			<li>
`~close手続き$riRは、所与の
( %chunk )
に対し
⇒
«[ "`value$brr" → %chunk, "`done$brr" → ~T ]»
で %promise を`解決する$
◎
close steps, given chunk
• Resolve promise with «[ "value" → chunk, "done" → true ]».
</li>
			<li>
`~error手続き$riRは、所与の
( %e )
に対し
⇒
%e で %promise を`却下する$
◎
error steps, given e
• Reject promise with e.
</li>
		</ul>
	</li>
	<li>
~RET
~NOABRUPT `ReadableStreamBYOBReaderRead$A( コレ, %view )
◎
Perform ! ReadableStreamBYOBReaderRead(this, view).
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`releaseLock()@byob
~method~手続きは：
◎
The releaseLock() method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerReadableStream^sl ~EQ `undefined^jv
］
⇒
~RET
◎
If this.[[ownerReadableStream]] is undefined, return.
</li>
	<li>
~IF［
コレ.`readIntoRequests^sl は`空$でない
］
⇒
~THROW `TypeError^jE
◎
If this.[[readIntoRequests]] is not empty, throw a TypeError exception.
</li>
	<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( コレ )
◎
Perform ! ReadableStreamReaderGenericRelease(this).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="rs-default-controller-class">
<h3 title="The ReadableStreamDefaultController class">4.5. `ReadableStreamDefaultController^I ~class</h3>

<p>
`ReadableStreamDefaultController$I ~classは、
`ReadableStream$I の状態と`内部~queue$を制御できるようにする~methodを持つ。
`可読~byte~stream$でない `ReadableStream$I を構築するときは、`下層~源$には，操作するための 対応する `ReadableStreamDefaultController$I ~instanceが与えられる。
◎
The ReadableStreamDefaultController class has methods that allow control of a ReadableStream's state and internal queue. When constructing a ReadableStream that is not a readable byte stream, the underlying source is given a corresponding ReadableStreamDefaultController instance to manipulate.
</p>

			<section id="rs-default-controller-class-definition">
<h4 title="Interface definition">4.5.1. ~interface定義</h4>

<p>
`ReadableStreamDefaultController$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ReadableStreamDefaultController class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ReadableStreamDefaultController@I {
  readonly attribute `unrestricted double$? `desiredSize$rsdc;

  void `close$rsdc();
  void `enqueue$rsdc(optional any %chunk);
  void `error$rsdc(optional any %e);
};
</pre>

			</section>
			<section id="rs-default-controller-internal-slots">
<h4 title="Internal slots">4.5.2. 内部~slot</h4>

<p>
`ReadableStreamDefaultController$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamDefaultController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`cancelAlgorithm^sl
<td>
1 個の引数（取消n事由）をとり，~promiseを返す~algo
— それは、要請された取消nを`下層~源$に通信する。
◎
A promise-returning algorithm, taking one argument (the cancel reason), which communicates a requested cancelation to the underlying source

<tr><td>`closeRequested^sl
<td>
真偽~flag
— ［
~streamは`下層~源$により~closeされたが，その内部~queueには 読取されていない`~chunk$がまだある
］かどうかを指示する。
◎
A boolean flag indicating whether the stream has been closed by its underlying source, but still has chunks in its internal queue that have not yet been read

<tr><td>`controlledReadableStream^sl
<td>
制御先の `ReadableStream$I の~instance。
◎
The ReadableStream instance controlled

<tr><td>`pullAgain^sl
<td>
真偽~flag
— 更に~dataを~pullするために，~streamの仕組みにて`下層~源$の~pull~algoが要請されたが、以前の~callがまだ実行-中にあるため，まだ~pullを行えない間は ~T に設定される。
◎
A boolean flag set to true if the stream’s mechanisms requested a call to the underlying source's pull algorithm to pull more data, but the pull could not yet be done since a previous call is still executing

<tr><td>`pullAlgorithm^sl
<td>
~promiseを返す~algo
— それは、`下層~源$から~dataを~pullする。
◎
A promise-returning algorithm that pulls data from the underlying source

<tr><td>`pulling^sl
<td>
真偽~flag
— `下層~源$の~pull~algoは実行-中にあるが，それが返した~promiseはまだ充足されていない間は ~T に設定される。
これは、再入~callを防止するために利用される。
◎
A boolean flag set to true while the underlying source's pull algorithm is executing and the returned promise has not yet fulfilled, used to prevent reentrant calls

<tr><td>`queue^sl
<td>
~streamの［
`~chunk$たちからなる内部~queue
］を表現する`~list$。
◎
A list representing the stream’s internal queue of chunks

<tr><td>`queueTotalSize^sl
<td>
`queue^sl 内に格納されている すべての~chunkの合計~size（`個別~size付き~queue$secを見よ）
◎
The total size of all the chunks stored in [[queue]] (see § 8.1 Queue-with-sizes)

<tr><td>`started^sl
<td>
真偽~flag
— ［
`下層~源$が開始処理を完遂した
］かどうかを指示する。
◎
A boolean flag indicating whether the underlying source has finished starting

<tr><td>`strategyHWM^sl
<td>
~streamの`~queuing策$の一部として，構築子に給された~number
— それを境に，~streamが`下層~源$に`背圧$を適用することになるような。
【 HWM ＝ `High-Water Mark^en （`限界水位$） 】
◎
A number supplied to the constructor as part of the stream’s queuing strategy, indicating the point at which the stream will apply backpressure to its underlying source

<tr><td>`strategySizeAlgorithm^sl
<td>
~streamの`~queuing策$の一部として，~enqueueされた`~chunk$たちの~sizeを計算する~algo。
◎
An algorithm to calculate the size of enqueued chunks, as part of the stream’s queuing strategy

</tbody></table>

			</section>
			<section id="rs-default-controller-prototype">
<h4 title="Methods and properties">4.5.3. ~method／~prop</h4>

<dl class="domintro">
	<dt>%desiredSize = %controller.`desiredSize$rsdc</dt>
	<dd>
制御先の`~streamの内部~queueの残り~size$を返す。
それは、負にもなり得る
— ~queueを溢れた場合に。
`下層~源$が`背圧$をいつどのように適用するかを決定するときは、この情報が利用されるべきである。
◎
Returns the desired size to fill the controlled stream’s internal queue. It can be negative, if the queue is over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
</dd>

	<dt>%controller.`close()$rsdc</dt>
	<dd>
制御先の可読~streamを~closeする。
`消費器$は依然として，それまでに~enqueueされた`~chunk$たちを~streamから読取できるが、それらが読取されたなら，~streamは~closeされる。
◎
Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from the stream, but once those are read, the stream will become closed.
</dd>

	<dt>%controller.`enqueue(chunk)$rsdc</dt>
	<dd>
所与の`~chunk$ %chunk を制御先の可読~stream内に~enqueueする。
◎
Enqueues the given chunk chunk in the controlled readable stream.
</dd>

	<dt>%controller.`error(e)$rsdc</dt>
	<dd>
制御先の可読~streamを~errorにする
— 以降のヤリトリは、すべて所与の~error %e で失敗させる。
◎
Errors the controlled readable stream, making all future interactions with it fail with the given error e.
</dd>
</dl>

<div class="algo">
<p>
`desiredSize@rsdc
取得子~手続きは：
◎
The desiredSize attribute’s getter steps are:
</p>
<ol>
	<li>
~RET
~NOABRUPT `ReadableStreamDefaultControllerGetDesiredSize$A( コレ )
◎
Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`close()@rsdc
~method~手続きは：
◎
The close() method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerCanCloseOrEnqueue$A( コレ ) ~EQ ~F
］
⇒
~THROW `TypeError^jE
◎
If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false, throw a TypeError exception.
</li>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerClose$A( コレ )
◎
Perform ! ReadableStreamDefaultControllerClose(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`enqueue(chunk)@rsdc
~method~手続きは：
◎
The enqueue(chunk) method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerCanCloseOrEnqueue$A( コレ ) ~EQ ~F
］
⇒
~THROW `TypeError^jE
◎
If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(this) is false, throw a TypeError exception.
</li>
	<li>
~ABRUPT `ReadableStreamDefaultControllerEnqueue$A( コレ, %chunk )
◎
Perform ? ReadableStreamDefaultControllerEnqueue(this, chunk).
</li>
</ol>
</div>

<div class="algo">
<p>
`error(e)@rsdc
~method~手続きは：
◎
The error(e) method steps are:
</p>
<ol>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( コレ, %e )
◎
Perform ! ReadableStreamDefaultControllerError(this, e).
</li>
</ol>
</div>

			</section>
			<section id="rs-default-controller-internal-methods">
<h4 title="Internal methods">4.5.4. 内部~method</h4>

<p>
各 `ReadableStreamDefaultController$I ~instanceは、以下に与える内部~methodを実装する。
可読~streamの実装は、`制御器との~interface法$secにて論じるように，［
それら, または
~BYOB制御器~用の それらに相当するもの
］いずれかを多形態的に~callすることになる。
◎
The following are internal methods implemented by each ReadableStreamDefaultController instance. The readable stream implementation will polymorphically call to either these, or to their counterparts for BYOB controllers, as discussed in § 4.8.2 Interfacing with controllers.
</p>

<div class="algo">
<p>
`[[CancelSteps]]( reason )@rsdc
は、
`CancelSteps$sl の契約を実装する。
それは、次の手続きを遂行する：
◎
[[CancelSteps]](reason) implements the [[CancelSteps]] contract. It performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `ResetQueue$A( コレ )
◎
Perform ! ResetQueue(this).
</li>
	<li>
%result ~LET コレ.`cancelAlgorithm^sl( %reason )
◎
Let result be the result of performing this.[[cancelAlgorithm]], passing reason.
</li>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerClearAlgorithms$A( コレ )
◎
Perform ! ReadableStreamDefaultControllerClearAlgorithms(this).
</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`[[PullSteps]](readRequest)@rsdc
は、
`PullSteps$sl の契約を実装する。
それは、次の手続きを遂行する：
◎
[[PullSteps]](readRequest) implements the [[PullSteps]] contract. It performs the following steps:
</p>
<ol>
	<li>
%stream ~LET コレ.`controlledReadableStream^sl
◎
Let stream be this.[[controlledReadableStream]].
</li>
	<li>
<p>
~IF［
コレ.`queue^sl は`空$でない
］：
◎
If this.[[queue]] is not empty,
</p>
		<ol>
			<li>
%chunk ~LET
~NOABRUPT `DequeueValue$A( コレ )
◎
Let chunk be ! DequeueValue(this).
</li>
			<li>
<p>
~IF［
コレ.`closeRequested^sl ~EQ ~T
］~AND［
コレ.`queue^sl は`空$である
］
◎
If this.[[closeRequested]] is true and this.[[queue]] is empty,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerClearAlgorithms$A( コレ )
◎
Perform ! ReadableStreamDefaultControllerClearAlgorithms(this).
</li>
					<li>
~NOABRUPT `ReadableStreamClose$A( %stream )
◎
Perform ! ReadableStreamClose(stream).
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
~NOABRUPT `ReadableStreamDefaultControllerCallPullIfNeeded$A( コレ )
◎
Otherwise, perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
</li>
			<li>
%readRequest の`~chunk手続き$rR( %chunk )
◎
Perform readRequest’s chunk steps, given chunk.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~NOABRUPT `ReadableStreamAddReadRequest$A( %stream )
◎
Perform ! ReadableStreamAddReadRequest(stream, readRequest).
</li>
			<li>
~NOABRUPT `ReadableStreamDefaultControllerCallPullIfNeeded$A( コレ )
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
		</section>
		<section id="rbs-controller-class">
<h3 title="The ReadableByteStreamController class">4.6. `ReadableByteStreamController^I ~class</h3>

<p>
`ReadableByteStreamController$I ~classは、
`ReadableStream$I の状態と`内部~queue$を制御できるようにする各種~methodを備える。
`可読~byte~stream$である `ReadableStream$I を構築するとき、`下層~源$を操作するために，対応する `ReadableByteStreamController$I ~instanceが与えられる。
◎
The ReadableByteStreamController class has methods that allow control of a ReadableStream's state and internal queue. When constructing a ReadableStream that is a readable byte stream, the underlying source is given a corresponding ReadableByteStreamController instance to manipulate.
</p>

			<section id="rbs-controller-class-definition">
<h4 title="Interface definition">4.6.1. ~interface定義</h4>

<p>
`ReadableByteStreamController$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ReadableByteStreamController class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ReadableByteStreamController@I {
  readonly attribute `ReadableStreamBYOBRequest$I? `byobRequest$rbsc;
  readonly attribute `unrestricted double$? `desiredSize$rbsc;

  void `close$rbsc();
  void `enqueue$rbsc(`ArrayBufferView$I %chunk);
  void `error$rbsc(optional any %e);
};
</pre>

			</section>
			<section id="rbs-controller-internal-slots">
<h4 title="Internal slots">4.6.2. 内部~slot</h4>

<p>
`ReadableByteStreamController$I
の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableByteStreamController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`autoAllocateChunkSize^sl
<td>
自動的な~buffer割振り特能が可能化されているときは、正な整数になり，~bufferに割振る~sizeを指定する。
他の場合は `undefined^jv になる。
◎
A positive integer, when the automatic buffer allocation feature is enabled. In that case, this value specifies the size of buffer to allocate. It is undefined otherwise.

<tr><td>`byobRequest^sl
<td>
現在の~BYOB~pull要請を表現している `ReadableStreamBYOBRequest$I ~instance
— そのような処理待ち要請が無ければ ~NULL になる。
◎
A ReadableStreamBYOBRequest instance representing the current BYOB pull request, or null if there are no pending requests

<tr><td>`cancelAlgorithm^sl
<td>
1 個の引数（取消n事由）をとり，~promiseを返す~algo
— それは、要請された取消nを`下層~byte源$に通信する。
◎
A promise-returning algorithm, taking one argument (the cancel reason), which communicates a requested cancelation to the underlying byte source

<tr><td>`closeRequested^sl
<td>
真偽~flag
— ［
~streamは その`下層~byte源$により~closeされたが，その内部~queueには 読取されていない`~chunk$がまだある
］かどうかを指示する。
◎
A boolean flag indicating whether the stream has been closed by its underlying byte source, but still has chunks in its internal queue that have not yet been read

<tr><td>`controlledReadableStream^sl
<td>
制御先の `ReadableStream$I の~instance。
◎
The ReadableStream instance controlled

<tr><td>`pullAgain^sl
<td>
真偽~flag
— 更に~dataを~pullするために，~streamの仕組みにて`下層~byte源$の~pull~algoを~callするよう要請されたが、以前の~callがまだ実行-中にあるため，まだ~pullを行えない場合に ~T に設定される。
◎
A boolean flag set to true if the stream’s mechanisms requested a call to the underlying byte source's pull algorithm to pull more data, but the pull could not yet be done since a previous call is still executing

<tr><td>`pullAlgorithm^sl
<td>
~promiseを返す~algo
— それは、`下層~byte源$から~dataを~pullする。
◎
A promise-returning algorithm that pulls data from the underlying byte source

<tr><td>`pulling^sl
<td>
真偽~flag
— `下層~byte源$の~pull~algoは実行-中にあり，それが返した~promiseは まだ充足されていない間は ~T に設定される。
これは、再入~callを防止するために利用される。
◎
A boolean flag set to true while the underlying byte source's pull algorithm is executing and the returned promise has not yet fulfilled, used to prevent reentrant calls 

<tr><td>`pendingPullIntos^sl
<td>
`~pull~into記述子$たちが成す`~list$。
◎
A list of pull-into descriptors

<tr><td>`queue^sl
<td>
`可読~byte~stream用の~queue~entry$たちが成す`~list$
— 当の~streamの［
一連の`~chunk$からなる内部~queue
］を表現する。
◎
A list of readable byte stream queue entries representing the stream’s internal queue of chunks

<tr><td>`queueTotalSize^sl
<td>
`queue^sl 内に格納されている すべての~chunkの，~byte数による合計~size（`個別~size付き~queue$secを見よ）。
◎
The total size, in bytes, of all the chunks stored in [[queue]] (see § 8.1 Queue-with-sizes)

<tr><td>`started^sl
<td>
真偽~flag
— `下層~byte源$が開始処理を完遂したかどうかを指示する。
◎
A boolean flag indicating whether the underlying byte source has finished starting

<tr><td>`strategyHWM^sl
<td>
~streamの`~queuing策$の一部として，構築子に給された~number
— それを境に，~streamが`下層~byte源$に`背圧$を適用することになるような。
【 HWM ＝ `High-Water Mark^en （`限界水位$） 】
◎
A number supplied to the constructor as part of the stream’s queuing strategy, indicating the point at which the stream will apply backpressure to its underlying byte source

</tbody></table>

<div class="note">

<p>注記：
`ReadableByteStreamController$I の各~instanceは、
`queue^sl, `queueTotalSize^sl
両~slotを有するが、これらに対しては `個別~size付き~queue$secにおける ほとんどの抽象-演算は利用しない
— この~queueを操作する仕方は、仕様~内の他のものと~~異質なので。
代わりに， 2 つの~slotは、手動で一緒に更新する。
◎
Although ReadableByteStreamController instances have [[queue]] and [[queueTotalSize]] slots, we do not use most of the abstract operations in § 8.1 Queue-with-sizes on them, as the way in which we manipulate this queue is rather different than the others in the spec. Instead, we update the two slots together manually.
</p>

<p>
これは、将来，仕様を~refactorするときに整理されるであろう。
◎
This might be cleaned up in a future spec refactoring.
</p>

</div>

<p>
`可読~byte~stream用の~queue~entry@
は、`可読~byte~stream$に特有な事例~用に`~chunk$を成す重要な側面を~encapsulateする`構造体$であり，次に挙げる`~item$sctからなる：
◎
A readable byte stream queue entry is a struct encapsulating the important aspects of a chunk for the specific case of readable byte streams. It has the following items:
</p>

<dl class="def-list">
	<dt>
`~buffer@qE
◎
buffer
</dt>
	<dd>
`ArrayBuffer$I
— それは、`下層~byte源$により元々給されたものの`転送され$た~versionになる。
◎
An ArrayBuffer, which will be a transferred version of the one originally supplied by the underlying byte source
</dd>

	<dt>
`~byte~offset@qE
◎
byte offset
</dt>
	<dd>
負でない整数
— `下層~byte源$により元々給された~viewから導出された，~byte~offsetを与える
◎
A nonnegative integer number giving the byte offset derived from the view originally supplied by the underlying byte source
</dd>

	<dt>
`~byte長さ@qE
◎
byte length
</dt>
	<dd>
負でない整数
— `下層~byte源$により元々給された~viewから導出された，~byte長さを与える
◎
A nonnegative integer number giving the byte length derived from the view originally supplied by the underlying byte source
</dd>
</dl>

<p>
`~pull~into記述子@
は、処理待ち~BYOB~pull要請を表現するために利用される`構造体$であり、次に挙げる`~item$sctからなる：
◎
A pull-into descriptor is a struct used to represent pending BYOB pull requests. It has the following items:
</p>

<dl class="def-list">
	<dt>
`~buffer@pD
◎
buffer
</dt>
	<dd>
`ArrayBuffer$I
◎
An ArrayBuffer
</dd>

	<dt>
`~byte~offset@pD
◎
byte offset
</dt>
	<dd>
負でない整数
— `~buffer$pDの中を指す~byte~offsetを表す。
`下層~byte源$は、そこから書込みを開始することになる。
◎
A nonnegative integer byte offset into the buffer where the underlying byte source will start writing
</dd>

	<dt>
`~byte長さ@pD
◎
byte length
</dt>
	<dd>
負でない整数
— `~buffer$pDの中へ書込できる~byte数を表す。
◎
A nonnegative integer number of bytes which can be written into the buffer
</dd>

	<dt>
`~fill済み~byte数@pD
◎
bytes filled
</dt>
	<dd>
負でない整数
— それまでに`~buffer$pDの中に書込された~byte数を表す。
◎
A nonnegative integer number of bytes that have been written into the buffer so far
</dd>

	<dt>
`要素~size@pD
◎
element size
</dt>
	<dd>
正な整数
— `~view構築子$pDが述べる型の~viewを利用して，`~buffer$pDの中に一度に書込できる~byte数を表現する。
◎
A positive integer representing the number of bytes that can be written into the buffer at a time, using views of the type described by the view constructor
</dd>

	<dt>
`~view構築子@pD
◎
view constructor
</dt>
	<dd>
<a href="~TC39#table-49">有型~配列~構築子</a> または `DataView$jI
— ［
`~buffer$pDの中に書込するために用いる【配列~buffer】~view
］を構築するときに利用されることになる。
◎
A typed array constructor or %DataView%, which will be used for constructing a view with which to write into the buffer
</dd>

	<dt>
`読取器~型@pD
◎
reader type
</dt>
	<dd>
この要請を起動した`読取器$の型を指示する
— 次のいずれか
⇒
`default^l ／
`byob^l
◎
Either "default" or "byob", indicating what type of readable stream reader initiated this request
</dd>
</dl>

			</section>
			<section id="rbs-controller-prototype">
<h4 title="Methods and properties">4.6.3. ~method／~prop</h4>

<dl class="domintro">
	<dt>%byobRequest = %controller.`byobRequest$rbsc</dt>
	<dd>
現在の~BYOB~pull要請は［
在るならばそれ／
無いならば ~NULL
］を返す。
◎
Returns the current BYOB pull request, or null if there isn’t one.
</dd>

	<dt>%desiredSize = %controller.`desiredSize$rbsc</dt>
	<dd>
`desiredSize^rbsc 取得子は、制御先の`~streamの内部~queueの残り~size$を返す。
それは、負にもなり得る
— ~queueを溢れた場合に。
`下層~byte源$が`背圧$をいつどのように適用するかを決定するときは、この情報が利用されるべきである。
◎
Returns the desired size to fill the controlled stream’s internal queue. It can be negative, if the queue is over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
</dd>

	<dt>%controller.`close()$rbsc</dt>
	<dd>
制御先の可読~streamを~closeする。
`消費器$は依然として，それまでに~enqueueされた`~chunk$たちを~streamから読取できるが、それらが読取されたなら，~streamは~closeされる。
◎
Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from the stream, but once those are read, the stream will become closed.
</dd>

	<dt>%controller.`enqueue(chunk)$rbsc</dt>
	<dd>
所与の`~chunk$ %chunk を制御先の可読~stream内に~enqueueする。
%chunk には `ArrayBufferView$I の~instanceを与える必要があり、さもなければ
`TypeError$jE が投出されることになる。
◎
Enqueues the given chunk chunk in the controlled readable stream. The chunk has to be an ArrayBufferView instance, or else a TypeError will be thrown.
</dd>

	<dt>%controller.`error(e)$rbsc</dt>
	<dd>
制御先の可書~streamを~errorにする
— 以降のヤリトリは、すべて所与の~error %e で失敗させる。
◎
Errors the controlled readable stream, making all future interactions with it fail with the given error e.
</dd>
</dl>

<div class="algo">
<p>
`byobRequest@rbsc
取得子~手続きは：
◎
The byobRequest attribute’s getter steps are:
</p>
<ol>
	<li>
<p>
~IF［
コレ.`byobRequest^sl ~EQ ~NULL
］~AND［
コレ.`pendingPullIntos^sl は`空$でない
］：
◎
If this.[[byobRequest]] is null and this.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%firstDescriptor ~LET コレ.`pendingPullIntos^sl[0]
◎
Let firstDescriptor be this.[[pendingPullIntos]][0].
</li>
			<li>
%view ~LET
~NOABRUPT `Construct$Ax( `Uint8Array$jI,
« %firstDescriptor の`~buffer$pD,
( %firstDescriptor の`~byte~offset$pD ~PLUS %firstDescriptor の`~fill済み~byte数$pD ),
( %firstDescriptor の`~byte長さ$pD ~MINUS %firstDescriptor の`~fill済み~byte数$pD ) »
)
◎
Let view be ! Construct(%Uint8Array%, « firstDescriptor’s buffer, firstDescriptor’s byte offset + firstDescriptor’s bytes filled, firstDescriptor’s byte length − firstDescriptor’s bytes filled »).
</li>
			<li>
%byobRequest ~LET `新たな$ `ReadableStreamBYOBRequest$I
◎
Let byobRequest be a new ReadableStreamBYOBRequest.
</li>
			<li>
%byobRequest.`controller^sl ~SET コレ
◎
Set byobRequest.[[controller]] to this.
</li>
			<li>
%byobRequest.`view^sl ~SET %view
◎
Set byobRequest.[[view]] to view.
</li>
			<li>
コレ.`byobRequest^sl ~SET %byobRequest
◎
Set this.[[byobRequest]] to byobRequest.
</li>
		</ol>
	</li>
	<li>
~RET コレ.`byobRequest^sl
◎
Return this.[[byobRequest]].
</li>
</ol>
</div>

<div class="algo">
<p>
`desiredSize@rbsc
取得子~手続きは：
◎
The desiredSize attribute’s getter steps are:
</p>
<ol>
	<li>
~RET
~NOABRUPT `ReadableByteStreamControllerGetDesiredSize$A( コレ )
◎
Return ! ReadableByteStreamControllerGetDesiredSize(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`close()@rbsc
~method~手続きは：
◎
The close() method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`closeRequested^sl ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If this.[[closeRequested]] is true, throw a TypeError exception.
</li>
	<li>
~IF［
コレ.`controlledReadableStream^sl.`state^sl ~NEQ `readable^l
］
⇒
~THROW `TypeError^jE
◎
If this.[[controlledReadableStream]].[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
~ABRUPT `ReadableByteStreamControllerClose$A( コレ )
◎
Perform ? ReadableByteStreamControllerClose(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`enqueue(chunk)@rbsc
~method~手続きは：
◎
The enqueue(chunk) method steps are:
</p>
<ol>
	<li>
~IF［
%chunk.`ByteLength^sl ~EQ 0
］
⇒
~THROW `TypeError^jE
◎
If chunk.[[ByteLength]] is 0, throw a TypeError exception.
</li>
	<li>
~IF［
%chunk.`ViewedArrayBuffer^sl.`ArrayBufferByteLength^sl ~EQ 0
］
⇒
~THROW `TypeError^jE
◎
If chunk.[[ViewedArrayBuffer]].[[ArrayBufferByteLength]] is 0, throw a TypeError exception.
</li>
	<li>
~IF［
コレ.`closeRequested^sl ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If this.[[closeRequested]] is true, throw a TypeError exception.
</li>
	<li>
~IF［
コレ.`controlledReadableStream^sl.`state^sl ~NEQ `readable^l
］
⇒
~THROW `TypeError^jE
◎
If this.[[controlledReadableStream]].[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `ReadableByteStreamControllerEnqueue$A( コレ, %chunk )
◎
Return ! ReadableByteStreamControllerEnqueue(this, chunk).
</li>
</ol>
</div>

<div class="algo">
<p>
`error(e)@rbsc
~method~手続きは：
◎
The error(e) method steps are:
</p>
<ol>
	<li>
~NOABRUPT `ReadableByteStreamControllerError$A( コレ, %e )
◎
Perform ! ReadableByteStreamControllerError(this, e).
</li>
</ol>
</div>

			</section>
			<section id="rbs-controller-internal-methods">
<h4 title="Internal methods">4.6.4. 内部~method</h4>

<p>
各 `ReadableByteStreamController$I ~instanceは、以下に与える内部~methodを実装する。
可読~streamの実装は、`制御器との~interface法$secにて論じるように，［
それら, または
既定の制御器~用の それらに相当するもの
］いずれかを多形態的に~callすることになる。
◎
The following are internal methods implemented by each ReadableByteStreamController instance. The readable stream implementation will polymorphically call to either these, or to their counterparts for default controllers, as discussed in § 4.8.2 Interfacing with controllers.
</p>

<div class="algo">
<p>
`[[CancelSteps]]( reason )@rbsc
は、
`CancelSteps$sl の契約を実装する。
それは、次の手続きを遂行する：
◎
[[CancelSteps]](reason) implements the [[CancelSteps]] contract. It performs the following steps:
</p>
<ol>
	<li>
<p>
~IF［
コレ.`pendingPullIntos^sl は`空$でない
］：
◎
If this.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%firstDescriptor ~LET コレ.`pendingPullIntos^sl[0]
◎
Let firstDescriptor be this.[[pendingPullIntos]][0].
</li>
			<li>
%firstDescriptor の`~fill済み~byte数$pD ~SET 0
◎
Set firstDescriptor’s bytes filled to 0.
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ResetQueue$A( コレ )
◎
Perform ! ResetQueue(this).
</li>
	<li>
%result ~LET コレ.`cancelAlgorithm^sl( %reason )
◎
Let result be the result of performing this.[[cancelAlgorithm]], passing in reason.
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerClearAlgorithms$A( コレ )
◎
Perform ! ReadableByteStreamControllerClearAlgorithms(this).
</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>
</div>


<div class="algo">
<p>
`[[PullSteps]](readRequest)@rbsc
は、
`PullSteps$sl の契約を実装する。
それは、次の手続きを遂行する：
◎
[[PullSteps]](readRequest) implements the [[PullSteps]] contract. It performs the following steps:
</p>
<ol>
	<li>
%stream ~LET コレ.`controlledReadableStream^sl
◎
Let stream be this.[[controlledReadableStream]].
</li>
	<li>
~Assert：
~NOABRUPT `ReadableStreamHasDefaultReader$A( %stream ) ~EQ ~T
◎
Assert: ! ReadableStreamHasDefaultReader(stream) is true.
</li>
	<li>
<p>
~IF［
コレ.`queueTotalSize^sl ~GT 0
］：
◎
If this.[[queueTotalSize]] &gt; 0,
</p>
		<ol>
			<li>
~Assert：
~NOABRUPT `ReadableStreamGetNumReadRequests$A( %stream ) ~EQ 0：
◎
Assert: ! ReadableStreamGetNumReadRequests(stream) is 0.
</li>
			<li>
%entry ~LET コレ.`queue^sl[0]
◎
Let entry be this.[[queue]][0].
</li>
			<li>
コレ.`queue^sl から %entry を`除去する$
◎
Remove entry from this.[[queue]].
</li>
			<li>
コレ.`queueTotalSize^sl ~DECBY %entry の`~byte長さ$qE
◎
Set this.[[queueTotalSize]] to this.[[queueTotalSize]] − entry’s byte length.
</li>
			<li>
~NOABRUPT `ReadableByteStreamControllerHandleQueueDrain$A( コレ )
◎
Perform ! ReadableByteStreamControllerHandleQueueDrain(this).
</li>
			<li>
%view ~LET
~NOABRUPT `Construct$Ax( `Uint8Array$jI, « %entry の`~buffer$qE, %entry の`~byte~offset$qE, %entry の`~byte長さ$qE » )
◎
Let view be ! Construct(%Uint8Array%, « entry’s buffer, entry’s byte offset, entry’s byte length »).
</li>
			<li>
%readRequest の`~chunk手続き$rR( %view )
◎
Perform readRequest’s chunk steps, given view.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%autoAllocateChunkSize ~LET コレ.`autoAllocateChunkSize^sl
◎
Let autoAllocateChunkSize be this.[[autoAllocateChunkSize]].
</li>
	<li>
<p>
~IF［
%autoAllocateChunkSize ~NEQ `undefined^jv
］：
◎
If autoAllocateChunkSize is not undefined,
</p>
		<ol>
			<li>
%buffer ~LET `Construct$Ax( `ArrayBuffer$jI, « %autoAllocateChunkSize » )
◎
Let buffer be Construct(%ArrayBuffer%, « autoAllocateChunkSize »).
</li>
			<li>
<p>
~IF［
%buffer は`中途完了^である
］：
◎
If buffer is an abrupt completion,
</p>
				<ol>
					<li>
%readRequest の`~error手続き$rR( %buffer.`Value^sl )
◎
Perform readRequest’s error steps, given buffer.[[Value]].
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%pullIntoDescriptor ~LET 次を伴う，新たな`~pull~into記述子$
⇒＃
`~buffer$pD ~SET %buffer.`Value^sl,
`~byte~offset$pD ~SET 0,
`~byte長さ$pD ~SET %autoAllocateChunkSize,
`~fill済み~byte数$pD ~SET 0,
`要素~size$pD ~SET 1,
`~view構築子$pD ~SET `Uint8Array$jI,
`読取器~型$pD ~SET `default^l
◎
Let pullIntoDescriptor be a new pull-into descriptor with buffer buffer.[[Value]], byte offset 0, byte length autoAllocateChunkSize, bytes filled 0, element size 1, view constructor %Uint8Array%, and reader type "default".
</li>
			<li>
コレ.`pendingPullIntos^sl に %pullIntoDescriptor を`付加する$
◎
Append pullIntoDescriptor to this.[[pendingPullIntos]].
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ReadableStreamAddReadRequest$A( %stream, %readRequest )
◎
Perform ! ReadableStreamAddReadRequest(stream, readRequest).[
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( コレ )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(this).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="rs-byob-request-class">
<h3 title="The ReadableStreamBYOBRequest class">4.7. `ReadableStreamBYOBRequest^I ~class</h3>

<p>
`ReadableStreamBYOBRequest$I ~classは、
`ReadableByteStreamController$I 内の［
中へ~pullする要請
］を表現する。
◎
The ReadableStreamBYOBRequest class represents a pull-into request in a ReadableByteStreamController.
</p>

			<section id="rs-byob-request-class-definition">
<h4 title="Interface definition">4.7.1. ~interface定義</h4>

<p>
`ReadableStreamBYOBRequest$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ReadableStreamBYOBRequest class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ReadableStreamBYOBRequest@I {
  readonly attribute `ArrayBufferView$I? `view$bbrq;

  void `respond$bbrq([`EnforceRange$] `unsigned long long$ %bytesWritten);
  void `respondWithNewView$bbrq(`ArrayBufferView$I %view);
};
</pre>

			</section>
			<section id="rs-byob-request-internal-slots">
<h4 title="Internal slots">4.7.2. 内部~slot</h4>

<p>
`ReadableStreamBYOBRequest$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamBYOBRequest are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`controller^sl
<td>
親の `ReadableByteStreamController$I ~instance
◎
The parent ReadableByteStreamController instance

<tr><td>`view^sl
<td>
行先~領域を表現する `Uint8Array$I または ~NULL
— 制御器は、生成される~dataをその領域に書込できる。
当の~BYOB要請が無効化されて以降は、~NULLになる。
◎
A typed array representing the destination region to which the controller can write generated data, or null after the BYOB request has been invalidated.

</tbody></table>

			</section>
			<section id="rs-byob-request-prototype">
<h4 title="Methods and properties">4.7.3. ~method／~prop</h4>

<dl class="domintro">
	<dt>%view = %byobRequest.`view$bbrq</dt>
	<dd>
中に書込するための~viewを返す
— 当の~BYOB要請は すでに応答していた場合、 ~NULL を返す。
◎
Returns the view for writing in to, or null if the BYOB request has already been responded to.
</dd>

	<dt>%byobRequest.`respond(bytesWritten)$bbrq</dt>
	<dd>
結付けられている`可読~byte~stream$に次を指示する
⇒
`view$bbrq の中へは %bytesWritten 個の~byteが書込して【！were written】，その結果を`消費器$に表面化させる
◎
Indicates to the associated readable byte stream that bytesWritten bytes were written into view, causing the result be surfaced to the consumer.
</dd>
	<dd>
この~methodが~callされた後には、
`view$bbrq は`転送され$，もはや改変-可能でなくなる。
◎
After this method is called, view will be transferred and no longer modifiable.
</dd>

	<dt>%byobRequest.`respondWithNewView(view)$bbrq</dt>
	<dd>
結付けられている`可読~byte~stream$に次を指示する
⇒
`view$bbrq の中へ書込する代わりに、`下層~byte源$は 新たな `ArrayBufferView$I を供して【！is providing】，それを`可読~byte~stream$の`消費器$に与える。
◎
Indicates to the associated readable byte stream that instead of writing into view, the underlying byte source is providing a new ArrayBufferView, which will be given to the consumer of the readable byte stream.
</dd>
	<dd>
この~methodが~callされた後には、
%view は`転送され$，もはや改変-可能でなくなる。
◎
After this method is called, view will be transferred and no longer modifiable.
</dd>
</dl>

<div class="algo">
<p>
`view@bbrq
取得子~手続きは：
◎
The view attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレ.`view^sl
◎
Return this.[[view]].
</li>
</ol>
</div>

<div class="algo">
<p>
`respond(bytesWritten)@bbrq
~method~手続きは：
◎
The respond(bytesWritten) method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`controller^sl ~EQ `undefined^jv
］
⇒
~THROW `TypeError^jE
◎
If this.[[controller]] is undefined, throw a TypeError exception.
</li>
	<li>
~IF［
【~NOABRUPT】`IsDetachedBuffer$Ax( コレ.`view^sl.`ArrayBuffer^sl ) ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If IsDetachedBuffer(this.[[view]].[[ArrayBuffer]]) is true, throw a TypeError exception.
</li>
	<li>
~Assert：
コレ.`view^sl.`ByteLength^sl ~GT 0
◎
Assert: this.[[view]].[[ByteLength]] &gt; 0.
</li>
	<li>
~Assert：
コレ.`view^sl.`ViewedArrayBuffer^sl.`ByeLength^sl ~GT 0
◎
Assert: this.[[view]].[[ViewedArrayBuffer]].[[ByeLength]] &gt; 0.
</li>
	<li>
~ABRUPT `ReadableByteStreamControllerRespond$A( コレ.`controller^sl, %bytesWritten )
◎
Perform ? ReadableByteStreamControllerRespond(this.[[controller]], bytesWritten).
</li>
</ol>
</div>

<div class="algo">
<p>
`respondWithNewView(view)@bbrq
~method~手続きは：
◎
The respondWithNewView(view) method steps are:
</p>
<ol>
	<li>
~IF［
%view.`ByteLength^sl ~EQ 0
］
⇒
~THROW `TypeError^jE
◎
If view.[[ByteLength]] is 0, throw a TypeError exception.
</li>
	<li>
~IF［
%view.`ViewedArrayBuffer^sl.`ArrayBufferByteLength^sl ~EQ 0
］
⇒
~THROW `TypeError^jE
◎
If view.[[ViewedArrayBuffer]].[[ArrayBufferByteLength]] is 0, throw a TypeError exception.
</li>
	<li>
~IF［
コレ.`controller^sl ~EQ `undefined^jv
］
⇒
~THROW `TypeError^jE
◎
If this.[[controller]] is undefined, throw a TypeError exception.
</li>
	<li>
~RET
~ABRUPT `ReadableByteStreamControllerRespondWithNewView$A( コレ.`controller^sl, %view)
◎
Return ? ReadableByteStreamControllerRespondWithNewView(this.[[controller]], view).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="rs-all-abstract-ops">
<h3 title="Abstract operations">4.8. 抽象-演算</h3>

			<section id="rs-abstract-ops">
<h3 title="Working with readable streams">4.8.1. 可読~streamとの作業-法</h3>

<p>
以下に与える抽象-演算は、
`ReadableStream$I ~instanceに対し高~levelから演算する。
一部のものは、一般に，他の仕様においても有用になるよう意味されている。
◎
The following abstract operations operate on ReadableStream instances at a higher level. Some are even meant to be generally useful by other specifications.
</p>

<div class="algo">
<p>
`AcquireReadableStreamBYOBReader(stream)@A
は、所与の~streamから`~BYOB読取器$を獲得したいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
 AcquireReadableStreamBYOBReader(stream) is meant to be called from other specifications that wish to acquire a BYOB reader for a given stream. It performs the following steps:
</p>
<ol>
	<li>
%reader ~LET `新たな$ `ReadableStreamBYOBReader$I
◎
Let reader be a new ReadableStreamBYOBReader.
</li>
	<li>
~ABRUPT `SetUpReadableStreamBYOBReader$A( %reader, « %stream » )
◎
Perform ? SetUpReadableStreamBYOBReader(reader, stream).
</li>
	<li>
~RET %reader
◎
Return reader.
</li>
</ol>
</div>

<div class="algo">
<p>
`AcquireReadableStreamDefaultReader(stream)@A
は、所与の~streamから`既定の読取器$を獲得したいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
AcquireReadableStreamDefaultReader(stream) is meant to be called from other specifications that wish to acquire a default reader for a given stream. It performs the following steps:
</p>
<ol>
	<li>
%reader ~LET `新たな$ `ReadableStreamDefaultReader$I
◎
Let reader be a new ReadableStreamDefaultReader.
</li>
	<li>
【~ABRUPT】 `SetUpReadableStreamDefaultReader$A( %reader, « %stream » )
◎
Perform SetUpReadableStreamDefaultReader(reader, stream).
</li>
	<li>
~RET %reader
◎
Return reader.
</li>
</ol>
</div>

<div class="algo">
<p>
`CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm[, highWaterMark[, sizeAlgorithm ] ])@A
は、
`ReadableStream$I ~instanceを作成したいと望む，他の仕様から~callされる用途に意味されている。
◎
CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm[, highWaterMark, [, sizeAlgorithm]]) is meant to be called from other specifications that wish to create ReadableStream instances.＼
</p>
<ul>
	<li>
［
%pullAlgorithm ／ %cancelAlgorithm
］は、~promiseを返す~algoでなければナラナイ。
◎
The pullAlgorithm and cancelAlgorithm algorithms must return promises;＼
◎
</li>
	<li>
%sizeAlgorithm は、給されるならば，`~chunk$~objを受容して ~numberを返す~algoでなければナラナイ。
◎
if supplied, sizeAlgorithm must be an algorithm accepting chunk objects and returning a number;＼
</li>
	<li>
%highWaterMark は、給されるならば，負でも `NaN^jv でもない ~numberでなければナラナイ。
◎
and if supplied, highWaterMark must be a non-negative, non-NaN number.
</li>
</ul>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~IF［
%highWaterMark は渡されていない
］
⇒
%highWaterMark ~SET 1
◎
If highWaterMark was not passed, set it to 1.
</li>
	<li>
~IF［
%sizeAlgorithm は渡されていない
］
⇒
%sizeAlgorithm ~SET 次を走らす~algo
⇒
~RET 1
◎
If sizeAlgorithm was not passed, set it to an algorithm that returns 1.
</li>
	<li>
~Assert：
~NOABRUPT `IsNonNegativeNumber$A( %highWaterMark ) ~EQ ~T
◎
Assert: ! IsNonNegativeNumber(highWaterMark) is true.
</li>
	<li>
%stream ~LET `新たな$ `ReadableStream$I
◎
Let stream be a new ReadableStream.
</li>
	<li>
~NOABRUPT `InitializeReadableStream$A( %stream )
◎
Perform ! InitializeReadableStream(stream).
</li>
	<li>
%controller ~LET `新たな$ `ReadableStreamDefaultController$I
◎
Let controller be a new ReadableStreamDefaultController.
</li>
	<li>
~ABRUPT `SetUpReadableStreamDefaultController$A( %stream, %controller, %startAlgorithm, %pullAlgorithm, %cancelAlgorithm, %highWaterMark, %sizeAlgorithm )
◎
Perform ? SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm).
</li>
	<li>
~RET %stream
◎
Return stream.
</li>
</ol>

<p class="note">注記：
この抽象-演算は、給された %startAlgorithm が投出するとき, そのときに限り例外を投出することになる。
◎
This abstract operation will throw an exception if and only if the supplied startAlgorithm throws.
</p>

</div>

<div class="algo">
<p>
`CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm[, highWaterMark[, autoAllocateChunkSize ] ])@A
は、`可読~byte~stream$を表現する `ReadableStream$I ~instanceを作成したいと望む，他の仕様から~callされる用途に意味されている。
◎
CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm[, highWaterMark, [, autoAllocateChunkSize]]) is meant to be called from other specifications that wish to create ReadableStream instances that represent readable byte streams.＼
</p>
<ul>
	<li>
［
%pullAlgorithm ／ %cancelAlgorithm
］は、~promiseを返す~algoでなければナラナイ。
◎
The pullAlgorithm and cancelAlgorithm algorithms must return promises;＼
</li>
	<li>
%highWaterMark は、給されるならば，負でも `NaN^jv でもない ~numberでなければナラナイ。
◎
if supplied, highWaterMark must be a non-negative, non-NaN number, and,＼
</li>
	<li>
%autoAllocateChunkSize は、給されるならば，正な整数でなければナラナイ。
◎
if supplied, autoAllocateChunkSize must be a positive integer.
</li>
</ul>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~IF［
%highWaterMark は渡されていない
］
⇒
%highWaterMark ~SET 0
◎
If highWaterMark was not passed, set it to 0.
</li>
	<li>
~IF［
%autoAllocateChunkSize は渡されていない
］
⇒
%autoAllocateChunkSize ~SET `undefined^jv
◎
If autoAllocateChunkSize was not passed, set it to undefined.
</li>
	<li>
~Assert：
~NOABRUPT `IsNonNegativeNumber$A( %highWaterMark ) ~EQ ~T
◎
Assert: ! IsNonNegativeNumber(highWaterMark) is true.
</li>
	<li>
<p>
~IF［
%autoAllocateChunkSize ~NEQ `undefined^jv
］：
◎
If autoAllocateChunkSize is not undefined,
</p>
		<ol>
			<li>
~Assert：
~NOABRUPT `IsInteger$Ax( %autoAllocateChunkSize ) ~EQ ~T
◎
Assert: ! IsInteger(autoAllocateChunkSize) is true.
</li>
			<li>
~Assert：
%autoAllocateChunkSize ~GT 0
◎
Assert: autoAllocateChunkSize is positive.
</li>
		</ol>
	</li>
	<li>
%stream ~LET `新たな$ `ReadableStream$I
◎
Let stream be a new ReadableStream.
</li>
	<li>
~NOABRUPT `InitializeReadableStream$A( %stream )
◎
Perform ! InitializeReadableStream(stream).
</li>
	<li>
%controller ~LET `新たな$ `ReadableByteStreamController$I
◎
Let controller be a new ReadableByteStreamController.
</li>
	<li>
~ABRUPT `SetUpReadableByteStreamController$A( %stream, %controller, %startAlgorithm, %pullAlgorithm, %cancelAlgorithm, %highWaterMark, %autoAllocateChunkSize )
◎
Perform ? SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize).
</li>
	<li>
~RET %stream
◎
Return stream.
</li>
</ol>

<p class="note">注記：
この抽象-演算は、給された %startAlgorithm が投出するとき, そのときに限り例外を投出することになる。
◎
This abstract operation will throw an exception if and only if the supplied startAlgorithm throws.
</p>
</div>

<div class="algo">
<p>
`InitializeReadableStream(stream)@A
は、次の手続きを遂行する：
◎
InitializeReadableStream(stream) performs the following steps:
</p>
<ol>
	<li>
%stream の
⇒＃
.`state^sl ~SET `readable^l,
.`reader^sl ~SET `undefined^jv,
.`storedError^sl ~SET `undefined^jv,
.`disturbed^sl ~SET ~F
◎
Set stream.[[state]] to "readable".
◎
Set stream.[[reader]] and stream.[[storedError]] to undefined.
◎
Set stream.[[disturbed]] to false.
</li>
</ol>
</div>

<div class="algo">
<p>
`IsReadableStreamDisturbed(stream)@A
は、［
可読~streamは一度でも読取されたか取消されたかどうか
］を~queryしたいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
IsReadableStreamDisturbed(stream) is meant to be called from other specifications that wish to query whether or not a readable stream has ever been read from or canceled. It performs the following steps:
</p>
<ol>
	<li>
~RET %stream.`disturbed^sl
◎
Return stream.[[disturbed]].
</li>
</ol>
</div>

<div class="algo">
<p>
`IsReadableStreamLocked(stream)@A
は、［
可読~streamが読取器に`~lockされて$いるかどうか
］を~queryしたいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
IsReadableStreamLocked(stream) is meant to be called from other specifications that wish to query whether or not a readable stream is locked to a reader.
</p>
<ol>
	<li>
~IF［
%stream.`reader^sl ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If stream.[[reader]] is undefined, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel[, signal])@A
は、所与の可読~streamを行先の`可書~stream$へ`~pipe$したいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel[, signal]) is meant to be called from other specifications that wish to pipe a given readable stream to a destination writable stream. It performs the following steps:
</p>
<ol>
	<li>
~Assert：
%source は `ReadableStream$I を`実装する$。
◎
Assert: source implements ReadableStream.
</li>
	<li>
~Assert：
%dest は `WritableStream$I を`実装する$。
◎
Assert: dest implements WritableStream.
</li>
	<li>
~Assert：
［
%preventClose,
%preventAbort,
%preventCancel
］は、どれも真偽値である。
◎
Assert: preventClose, preventAbort, and preventCancel are all booleans.
</li>
	<li>
~IF［
%signal は与えられていない
］
⇒
%signal ~SET `undefined^jv
◎
If signal is not given, let signal be undefined.
</li>
	<li>
~Assert：
［
%signal ~EQ `undefined^jv
］~OR［
%signal は `AbortSignal$I を`実装する$
］
◎
Assert: either signal is undefined, or signal implements AbortSignal.
</li>
	<li>
~Assert：
~NOABRUPT `IsReadableStreamLocked$A( %source ) ~EQ ~F
◎
Assert: ! IsReadableStreamLocked(source) is false.
</li>
	<li>
~Assert：
~NOABRUPT `IsWritableStreamLocked$A( %dest ) ~EQ ~F
◎
Assert: ! IsWritableStreamLocked(dest) is false.
</li>
	<li>
%reader ~LET ε
◎
↓</li>
	<li>
~IF［
%source は `ReadableByteStreamController$I を`実装する$
］
⇒
%reader ~SET ~UAの裁量で，次のいずれかを遂行した結果
⇒＃
~NOABRUPT `AcquireReadableStreamBYOBReader$A( %source ) ／
~NOABRUPT `AcquireReadableStreamDefaultReader$A( %source )
◎
If source.[[readableStreamController]] implements ReadableByteStreamController, let reader be either ! AcquireReadableStreamBYOBReader(source) or ! AcquireReadableStreamDefaultReader(source), at the user agent’s discretion.
</li>
	<li>
~ELSE
⇒
%reader ~SET
~NOABRUPT `AcquireReadableStreamDefaultReader$A( %source )
◎
Otherwise, let reader be ! AcquireReadableStreamDefaultReader(source).
</li>
	<li>
%writer ~LET
~NOABRUPT `AcquireWritableStreamDefaultWriter$A( %dest )
◎
Let writer be ! AcquireWritableStreamDefaultWriter(dest).
</li>
	<li>
%source.`disturbed^sl ~SET ~T
◎
Set source.[[disturbed]] to true.
</li>
	<li>
%shuttingDown ~LET ~F
◎
Let shuttingDown be false.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
~IF［
%signal ~NEQ `undefined^jv
］：
◎
If signal is not undefined,
</p>
		<ol>
			<li>
<p>
%abortAlgorithm ~LET 次を走らす手続き：
◎
Let abortAlgorithm be the following steps:
</p>
				<ol>
					<li>
%error ~LET 新たな `AbortError$E 例外
◎
Let error be a new "AbortError" DOMException.
</li>
					<li>
%actions ~LET 新たな`有順序~集合$
◎
Let actions be an empty ordered set.
</li>
					<li>
<p>
~IF［
%preventAbort ~EQ ~F
］
⇒
%actions に次を走らす動作を`付加する$set：
◎
If preventAbort is false, append the following action to actions:
</p>
						<ol>
							<li>
~IF［
%dest.`state^sl ~EQ `writable^l
］
⇒
~RET
~NOABRUPT `WritableStreamAbort$A( %dest, %error )
◎
If dest.[[state]] is "writable", return ! WritableStreamAbort(dest, error).
</li>
							<li>
~RET `undefined^jv で`解決される~promise$
◎
Otherwise, return a promise resolved with undefined.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%preventCancel ~EQ ~F
］
⇒
%actions に次を走らす動作を`付加する$set：
◎
If preventCancel is false, append the following action action to actions:
</p>
						<ol>
							<li>
~IF［
%source.`state^sl ~EQ `readable^l
］
⇒
~RET
~NOABRUPT `ReadableStreamCancel$A( %source, %error )
◎
If source.[[state]] is "readable", return ! ReadableStreamCancel(source, error).
</li>
							<li>
~RET `undefined^jv で`解決される~promise$
◎
Otherwise, return a promise resolved with undefined.
</li>
						</ol>
					</li>
					<li>
`~shutdownする$( %error, 次を走らす動作 )
⇒
`すべてを待機する~promiseを取得する$( %actions 内の動作たち )
◎
Shutdown with an action consisting of getting a promise to wait for all of the actions in actions, and with error.
</li>
				</ol>
			</li>
			<li>
~IF［
%signal の`中止-済み~flag$aB ~EQ ~T
］
⇒＃
%abortAlgorithm を遂行する；
~RET %promise
◎
If signal’s aborted flag is set, perform abortAlgorithm and return promise.
</li>
			<li>
`通達に~algoを追加する$( %signal, %abortAlgorithm )
◎
Add abortAlgorithm to signal.
</li>
		</ol>
	</li>
	<li>
<p>
( %reader, %writer )
を利用して，`並列的$に
<span class="issue">
本当はそうでない
— <a href="https://github.com/whatwg/streams/issues/905">課題 #905</a>
を見よ —
</span>
%source から すべての`~chunk$を読取して %dest に書込する。
これが起こる正確な方式は、
( 読取器, 書込器 )
が供する~lock法に因り，作者~codeからは観測-可能でない。
よって，~UAには これを柔軟に行う余地があるが、利用される正確な~algoが何であれ，以下の拘束が適用される：
◎
In parallel but not really; see #905, using reader and writer, read all chunks from source and write them to dest. Due to the locking provided by the reader and writer, the exact manner in which this happens is not observable to author code, and so there is flexibility in how this is done. The following constraints apply regardless of the exact algorithm used:
</p>
		<ul>
			<li>
`~public~APIは利用しないモノトスル^strong：
— ［
読取り／書込み
］の間, および
以下に挙げる演算を遂行している間は、何かを改変-可能な~JSの［
読取器, 書込器, ~stream~API
］（すなわち，適切な~prototype上の各種~method）は、利用しないモノトスル
— ~streamは，直に操作するモノトスル。
◎
Public API must not be used: while reading or writing, or performing any of the operations below, the JavaScript-modifiable reader, writer, and stream APIs (i.e. methods on the appropriate prototypes) must not be used. Instead, the streams must be manipulated directly.
</li>
			<li>
<p>
`背圧は施行するモノトスル^strong
— ~UAは：
◎
Backpressure must be enforced:
</p>
				<ul>
					<li>
`WritableStreamDefaultWriterGetDesiredSize$A( %writer ) の結果が［
0 以下, または ~NULL
］になる間は、 %reader から読取しないモノトスル
◎
While WritableStreamDefaultWriterGetDesiredSize(writer) is ≤ 0 or is null, the user agent must not read from reader.
</li>
					<li>
<p>
%reader が`~BYOB読取器$である場合、
%reader から読取する~chunkの~sizeを決定するときには，
`WritableStreamDefaultWriterGetDesiredSize$A( %writer )
をその基礎に利用するべきである。
◎
If reader is a BYOB reader, WritableStreamDefaultWriterGetDesiredSize(writer) should be used as a basis to determine the size of the chunks read from reader.
</p>

<p class="note">注記：
小さすぎる／大きすぎる~chunkたちを読取するのは、効率的でないことが多い。
他の情報も、最適な~chunk~sizeを決定する要因になるかもしれない。
◎
It’s frequently inefficient to read chunks that are too small or too large. Other information might be factored in to determine the optimal chunk size.
</p>
					</li>
					<li>
<p>
読取nや書込nは、背圧~通達~以外の理由で遅延されるべきでない。
◎
Reads or writes should not be delayed for reasons other than these backpressure signals.
</p>

<p class="example" id="example-bad-backpressure">
次回の 読取n／書込n 演算を続行する前に，各 書込nが成功裡に完了するのを待機するような実装は、この推奨に違反する。
そのような実装では、 %dest の`内部~queue$は，常に高々 1 個の`~chunk$しか包含せず，役立たずになるので。
◎
An implementation that waits for each write to successfully complete before proceeding to the next read/write operation violates this recommendation. In doing so, such an implementation makes the internal queue of dest useless, as it ensures dest always contains at most one queued chunk.
</p>
					</li>
				</ul>
			</li>
			<li>
`~shutdownは、活動を停止させるモノトスル^strong
— %shuttingDown が ~T になって以降は、~UAは，それ以上 %reader からの読取nを起動しないモノトスル。
また、以下に述べるように，すでに読取された~chunkの書込nのみを遂行するモノトスル。
特に，~UAは、［
読取n／書込n
］を遂行する前に，以下の条件を検査するモノトスル
— それらは、即時に~shutdownに至らせることもあるので。
◎
Shutdown must stop activity: if shuttingDown becomes true, the user agent must not initiate further reads from reader, and must only perform writes of already-read chunks, as described below. In particular, the user agent must check the below conditions before performing any reads or writes, since they might lead to immediate shutdown.
</li>
			<li>
<p>
`~error／~close状態は伝播するモノトスル^strong
— 以下の条件は、挙げられた順に適用するモノトスル：
◎
Error and close states must be propagated: the following conditions must be applied in order.
</p>
				<ol>
					<li>
<p>
`~errorは前方へ伝播するモノトスル^strong
— %source.`state^sl ~EQ `errored^l のとき, または そうなったときは：
◎
Errors must be propagated forward: if source.[[state]] is or becomes "errored", then
</p>
						<ol>
							<li>
~IF［
%preventAbort ~EQ ~F
］
⇒
`~shutdownする$( %source.`storedError^sl, 次を行う動作 )
⇒
~NOABRUPT `WritableStreamAbort$A( %dest, %source.`storedError^sl )
◎
If preventAbort is false, shutdown with an action of ! WritableStreamAbort(dest, source.[[storedError]]) and with source.[[storedError]].
</li>
							<li>
~ELSE
⇒
`~shutdownする$( %source.`storedError^sl, ε )
◎
Otherwise, shutdown with source.[[storedError]].
</li>
						</ol>
					</li>
					<li>
<p>
`~errorは後方へ伝播するモノトスル^strong
— %dest.`state^sl ~EQ `errored^l のとき, または そうなったときは：
◎
Errors must be propagated backward: if dest.[[state]] is or becomes "errored", then
</p>
						<ol>
							<li>
~IF［
%preventCancel ~EQ ~F
］
⇒
`~shutdownする$( %dest.`storedError^sl, 次を行う動作 )
⇒
~NOABRUPT `ReadableStreamCancel$A( %source, %dest.`storedError^sl )

◎
If preventCancel is false, shutdown with an action of ! ReadableStreamCancel(source, dest.[[storedError]]) and with dest.[[storedError]].
</li>
							<li>
~ELSE
⇒
`~shutdownする$( %dest.`storedError^sl, ε )
◎
Otherwise, shutdown with dest.[[storedError]].
</li>
						</ol>
					</li>
					<li>
<p>
`~closingは前方へ伝播するモノトスル^strong
— %source.`state^sl ~EQ `closed^l のとき, または そうなったときは：
◎
Closing must be propagated forward: if source.[[state]] is or becomes "closed", then
</p>
						<ol>
							<li>
~IF［
%preventClose ~EQ ~F
］
⇒
`~shutdownする$( ε, 次を行う動作 )
⇒
~NOABRUPT `WritableStreamDefaultWriterCloseWithErrorPropagation$A( %writer )
◎
If preventClose is false, shutdown with an action of ! WritableStreamDefaultWriterCloseWithErrorPropagation(writer).
</li>
							<li>
~ELSE
⇒
`~shutdownする$( ε, ε )
◎
Otherwise, shutdown.
</li>
						</ol>
					</li>
					<li>
<p>
`~closingは後方へ伝播するモノトスル^strong
—
［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %dest ) ~EQ ~T
］~OR［
%dest.`state^sl ~EQ `closed^l
］のときは：
◎
Closing must be propagated backward: if ! WritableStreamCloseQueuedOrInFlight(dest) is true or dest.[[state]] is "closed", then
</p>
						<ol>
							<li>
~Assert：
［
読取した／書込した
］`~chunk$はない
◎
Assert: no chunks have been read or written.
</li>
							<li>
%destClosed ~LET 新たな `TypeError^jE
◎
Let destClosed be a new TypeError.
</li>
							<li>
~IF［
%preventCancel ~EQ ~F
］
⇒
`~shutdownする$( %destClosed, 次を行う動作 )
⇒
~NOABRUPT `ReadableStreamCancel$A( %source, %destClosed )
◎
If preventCancel is false, shutdown with an action of ! ReadableStreamCancel(source, destClosed) and with destClosed.
</li>
							<li>
~ELSE
⇒
`~shutdownする$( %destClosed, ε )
◎
Otherwise, shutdown with destClosed.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p id="rs-pipeTo-shutdown">
上のいずれかの要件／手続きにより，
`~shutdownする@
よう依頼されたときは、所与の
( %error, %action )
に対し，次の下位手続きを遂行する：
◎
Shutdown with an action: if any of the above requirements ask to shutdown with an action action, optionally with an error originalError, then:
</p>
				<ol>
					<li>
~IF［
%shuttingDown ~EQ ~T
］
⇒
~RET
◎
If shuttingDown is true, abort these substeps.
</li>
					<li>
%shuttingDown ~SET ~T
◎
Set shuttingDown to true.
</li>
					<li>
<p>
~IF［
%dest.`state^sl ~EQ `writable^l
］~AND［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %dest ) ~EQ ~F
］：
◎
If dest.[[state]] is "writable" and ! WritableStreamCloseQueuedOrInFlight(dest) is false,
</p>
						<ol>
							<li>
~IF［
読取されたがまだ書込されていない`~chunk$はある
］
⇒
それらを %dest に書込する
◎
If any chunks have been read but not yet written, write them to dest.
</li>
							<li>
読取されたすべての`~chunk$が書込されるまで（すなわち，対応する~promiseは決着するまで）待機する
◎
Wait until every chunk that has been read has been written (i.e. the corresponding promises have settled).
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%action ~EQ ε
］：
</p>
						<ol>
							<li>
`完結する$( %error )
</li>
							<li>
~RET
</li>
						</ol>
◎
↓↓</li>
					<li>
<p>
%p ~LET %action を遂行した結果：
◎
Let p be the result of performing action.
</p>
						<ul>
							<li>
%p の`充足-時$には
⇒
`完結する$( %error )
◎
Upon fulfillment of p, finalize, passing along originalError if it was given.
</li>
							<li>
事由 %newError による %p の`却下-時$には
⇒
`完結する$( %newError )
◎
Upon rejection of p with reason newError, finalize with newError.
</li>
						</ul>
					</li>
				</ol>

<div class="p">
<p class="trans-note">【
この手続きは、原文では， 2 つに分けて記されているが（ %action ~EQ ε の場合と 非 ε の場合）、表記の都合により この訳では一つに集約している。
】
</p>
◎
Shutdown: if any of the above requirements or steps ask to shutdown, optionally with an error error, then:
• If shuttingDown is true, abort these substeps.
• Set shuttingDown to true.
• If dest.[[state]] is "writable" and ! WritableStreamCloseQueuedOrInFlight(dest) is false,
•• If any chunks have been read but not yet written, write them to dest.
•• Wait until every chunk that has been read has been written (i.e. the corresponding promises have settled).
• Finalize, passing along error if it was given.
</div>
			</li>
			<li>
<p>
`完結する@
下位手続きは、所与の
( %error )
に対し，次を遂行する：
◎
Finalize: both forms of shutdown will eventually ask to finalize, optionally with an error error, which means to perform the following steps:
</p>
				<ol>
					<li>
~NOABRUPT `WritableStreamDefaultWriterRelease$A( %writer )
◎
Perform ! WritableStreamDefaultWriterRelease(writer).
</li>
					<li>
~NOABRUPT `ReadableStreamReaderGenericRelease$A( %reader )
◎
Perform ! ReadableStreamReaderGenericRelease(reader).
</li>
					<li>
~IF［
%signal ~NEQ `undefined^jv
］
⇒
`通達から~algoを除去する$( %signal, %abortAlgorithm )
◎
If signal is not undefined, remove abortAlgorithm from signal.
</li>
					<li>
~IF［
%error ~NEQ ε
］
⇒
%error で %promise を`却下する$
◎
If error was given, reject promise with error.
</li>
					<li>
~ELSE
⇒
`undefined^jv で %promise を`解決する$
◎
Otherwise, resolve promise with undefined.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<p class="note">注記：
ここで遂行される種々の抽象-演算では，~objが作成され（~promiseを成すものが多い）、それらの~obj用には，通例的に~realmを指定することが要求される。
しかしながら，~lock中にあるので、それらの~objは 作者~codeからは観測され得ない。
そのようなわけで、それらの作成-時に利用する~realmが~~問題になることはない。
◎
Various abstract operations performed here include object creation (often of promises), which usually would require specifying a realm for the created object. However, because of the locking, none of these objects can be observed by author code. As such, the realm used to create them does not matter.
</p>

<div class="algo">
<p>
`ReadableStreamTee(stream, cloneForBranch2)@A
は、所与の可読~streamを`二叉化-$したいと望む，他の仕様から~callされる用途に意味されている。
◎
ReadableStreamTee(stream, cloneForBranch2) is meant to be called from other specifications that wish to tee a given readable stream.
</p>

<p>
2 個目の引数 %cloneForBranch2 は、［
元の~streamからの~dataは、
2 個目の分岐~内に現れる前に~cloneされるかどうか
］を統治する（ `HTML$r による，`直列化-可能$な~obj用の~frameworkを利用して）。
これは、両 分岐が消費されるとき，［
~chunkを<a href="~HTMLcloning#transferable-objects">転送する</a>ことにより，互いに干渉しあうおそれがある局面
］で有用になる。
しかしながら、両 分岐の間に 外から見える非対称性も導入され，アリな`~chunk$も直列化-可能なものに制限されることになる。
◎
The second argument, cloneForBranch2, governs whether or not the data from the original stream will be cloned (using HTML’s serializable objects framework) before appearing in the second of the returned branches. This is useful for scenarios where both branches are to be consumed in such a way that they might otherwise interfere with each other, such as by transferring their chunks. However, it does introduce a noticeable asymmetry between the two branches, and limits the possible chunks to serializable ones. [HTML]
</p>

<p class="note">注記：
この標準においては、
`ReadableStreamTee$A が~callされるときは，常に %cloneForBranch2 は ~F に設定される。
他の仕様は ~T を渡す。
◎
In this standard ReadableStreamTee is always called with cloneForBranch2 set to false; other specifications pass true.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream は `ReadableStream$I を`実装する$。
◎
Assert: stream implements ReadableStream.
</li>
	<li>
~Assert：
%cloneForBranch2 は真偽値である。
◎
Assert: cloneForBranch2 is a boolean.
</li>
	<li>
%reader ~LET
~ABRUPT `AcquireReadableStreamDefaultReader$A( %stream )
◎
Let reader be ? AcquireReadableStreamDefaultReader(stream).
</li>
	<li>
%reading ~LET ~F
◎
Let reading be false.
</li>
	<li>
%canceled1 ~LET ~F
◎
Let canceled1 be false.
</li>
	<li>
%canceled2 ~LET ~F
◎
Let canceled2 be false.
</li>
	<li>
%reason1 ~LET `undefined^jv
◎
Let reason1 be undefined.
</li>
	<li>
%reason2 ~LET `undefined^jv
◎
Let reason2 be undefined.
</li>
	<li>
%branch1 ~LET `undefined^jv
◎
Let branch1 be undefined.
</li>
	<li>
%branch2 ~LET `undefined^jv
◎
Let branch2 be undefined.
</li>
	<li>
%cancelPromise ~LET `新たな~promise$
◎
Let cancelPromise be a new promise.
</li>
	<li>
<p>
%pullAlgorithm ~LET 次を走らす手続き：
◎
Let pullAlgorithm be the following steps:
</p>
		<ol>
			<li>
~IF［
%reading ~EQ ~T
］
⇒
~RET `undefined^jv で`解決される~promise$
◎
If reading is true, return a promise resolved with undefined.
</li>
			<li>
%reading ~SET ~T
◎
Set reading to true.
</li>
			<li>
<p>
%readRequest ~LET 次に挙げる`~item$sctを伴う，`読取n要請$：
◎
Let readRequest be a read request with the following items:
</p>
				<ul>
					<li>
<p>
`~chunk手続き$rRは、所与の
( %value )
に対し，次の手続きを遂行する`小taskを~queueする$：
◎
chunk steps, given value
• Queue a microtask to perform the following steps:
</p>
						<ol>
							<li>
%reading ~SET ~F
◎
Set reading to false.
</li>
							<li>
%value1 ~LET %value
◎
↓</li>
							<li>
%value2 ~LET %value
◎
Let value1 and value2 be value.
</li>
							<li>
~IF［
%canceled2 ~EQ ~F
］~AND［
%cloneForBranch2 ~EQ ~T
］
⇒
%value2 ~SET
~ABRUPT `StructuredDeserialize$A( ~ABRUPT `StructuredSerialize$A( %value2 ), `現在の~Realm$ )
◎
If canceled2 is false and cloneForBranch2 is true, set value2 to ? StructuredDeserialize(? StructuredSerialize(value2), the current Realm).
</li>
							<li>
~IF［
%canceled1 ~EQ ~F
］
⇒
~ABRUPT `ReadableStreamDefaultControllerEnqueue$A( %branch1.`readableStreamController^sl, %value1 )
◎
If canceled1 is false, perform ? ReadableStreamDefaultControllerEnqueue(branch1.[[readableStreamController]], value1).
</li>
							<li>
~IF［
%canceled2 ~EQ ~F
］
⇒
~ABRUPT `ReadableStreamDefaultControllerEnqueue$A( %branch2.`readableStreamController^sl, %value2 )
◎
If canceled2 is false, perform ? ReadableStreamDefaultControllerEnqueue(branch2.[[readableStreamController]], value2).
</li>
						</ol>

<p class="note">注記：
ここでの小taskによる遅延は、必要とされる
— 下にて %reader.`closedPromise^sl を利用するとき、少なくとも，~errorを検出する小taskがかかるので。
%stream における~errorは，両~分岐とも即時に~errorにすることが求まれるので、非同期的に可用な~errorに先んじて，成功裡な読取nを同期的に可用にするわけにはいかない。
◎
The microtask delay here is necessary because it takes at least a microtask to detect errors, when we use reader.[[closedPromise]] below. We want errors in stream to error both branches immediately, so we cannot let successful synchronously-available reads happen ahead of asynchronously-available errors.
</p>
					</li>
					<li>
<p>
`~close手続き$rRは：
◎
close steps
</p>
						<ol>
							<li>
%reading ~SET ~F
◎
Set reading to false.
</li>
							<li>
~IF［
%canceled1 ~EQ ~F
］
⇒
~NOABRUPT `ReadableStreamDefaultControllerClose$A( %branch1.`readableStreamController^sl )
◎
If canceled1 is false, perform ! ReadableStreamDefaultControllerClose(branch1.[[readableStreamController]]).
</li>
							<li>
~IF［
%canceled2 ~EQ ~F
］
⇒
~NOABRUPT `ReadableStreamDefaultControllerClose$A( %branch2.`readableStreamController^sl )
◎
If canceled2 is false, perform ! ReadableStreamDefaultControllerClose(branch2.[[readableStreamController]]).
</li>
						</ol>
					</li>
					<li>
`~error手続き$rRは
⇒
%reading ~SET ~F
◎
error steps
• Set reading to false.
</li>
				</ul>
			</li>
			<li>
~NOABRUPT `ReadableStreamDefaultReaderRead$A( %reader, %readRequest )
◎
Perform ! ReadableStreamDefaultReaderRead(reader, readRequest).
</li>

			<li>
~RET `undefined^jv で`解決される~promise$
◎
Return a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
<p>
%cancel1Algorithm ~LET 所与の ( %reason ) に対し，次を走らす手続き：
◎
Let cancel1Algorithm be the following steps, taking a reason argument:
</p>
		<ol>
			<li>
%canceled1 ~SET ~T
◎
Set canceled1 to true.
</li>
			<li>
%reason1 ~SET %reason
◎
Set reason1 to reason.
</li>
			<li>
<p>
~IF［
%canceled2 ~EQ ~T
］：
◎
If canceled2 is true,
</p>
				<ol>
					<li>
%compositeReason ~LET
~NOABRUPT `CreateArrayFromList$Ax( « %reason1, %reason2 » )
◎
Let compositeReason be ! CreateArrayFromList(« reason1, reason2 »).
</li>
					<li>
%cancelResult ~LET
~NOABRUPT `ReadableStreamCancel$A( %stream, %compositeReason )
◎
Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
</li>
					<li>
%cancelResult で
%cancelPromise を`解決する$
◎
Resolve cancelPromise with cancelResult.
</li>
				</ol>
			</li>
			<li>
~RET %cancelPromise
◎
Return cancelPromise.
</li>
		</ol>
	</li>
	<li>
<p>
%cancel2Algorithm ~LET 所与の ( %reason ) に対し，次を走らす手続き：
◎
Let cancel2Algorithm be the following steps, taking a reason argument:
</p>
		<ol>
			<li>
%canceled2 ~SET ~T
◎
Set canceled2 to true.
</li>
			<li>
%reason2 ~SET %reason
◎
Set reason2 to reason.
</li>
			<li>
<p>
~IF［
%canceled1 ~EQ ~T
］：
◎
If canceled1 is true,
</p>
				<ol>
					<li>
%compositeReason ~LET
~NOABRUPT `CreateArrayFromList$Ax( « %reason1, %reason2 » )
◎
Let compositeReason be ! CreateArrayFromList(« reason1, reason2 »).
</li>
					<li>
%cancelResult ~LET
~NOABRUPT `ReadableStreamCancel$A( %stream, %compositeReason )
◎
Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
</li>
					<li>
%cancelResult で
%cancelPromise を`解決する$
◎
Resolve cancelPromise with cancelResult.
</li>
				</ol>
			</li>
			<li>
~RET %cancelPromise
◎
Return cancelPromise.
</li>
		</ol>
	</li>
	<li>
%startAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv
◎
Let startAlgorithm be an algorithm that returns undefined.
</li>
	<li>
%branch1 ~SET
~NOABRUPT `CreateReadableStream$A( %startAlgorithm, %pullAlgorithm, %cancel1Algorithm)
◎
Set branch1 to ! CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm).
</li>
	<li>
%branch2 ~SET
~NOABRUPT `CreateReadableStream$A( %startAlgorithm, %pullAlgorithm, %cancel2Algorithm)
◎
Set branch2 to ! CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm).
</li>
	<li>
<p>
事由 %r による
%reader.`closedPromise^sl の`却下-時$には：
◎
Upon rejection of reader.[[closedPromise]] with reason r,
</p>
		<ol>
			<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %branch1.`readableStreamController^sl, %r )
◎
Perform ! ReadableStreamDefaultControllerError(branch1.[[readableStreamController]], r).
</li>
			<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %branch2.`readableStreamController^sl, %r )
◎
Perform ! ReadableStreamDefaultControllerError(branch2.[[readableStreamController]], r).
</li>
		</ol>
	</li>
	<li>
~RET « %branch1, %branch1 »
◎
Return « branch1, branch2 ».
</li>
</ol>
</div>

			</section>
			<section id="rs-abstract-ops-used-by-controllers">
<h4 title="Interfacing with controllers">4.8.2. 制御器との~interface法</h4>

<p>
仕様の~~構成においては、多様になり得る~logicを成す大部分を 2 種の制御器~class［
`ReadableStreamDefaultController$I, `ReadableByteStreamController$I
］の内側に集中させることにより、単純な［
`可読~stream$, `可読~byte~stream$
］両者の挙動が，単独の `ReadableStream$I ~classの中に~encapsulateされている。
これらの制御器~classは、［
~streamの`内部~queue$を管理する方法, および ~streamの［
`下層~源$／`下層~byte源$
］とやりとりするための［
~statefulな内部~slotを成す大部分, および抽象-演算
］を定義する。
◎
In terms of specification factoring, the way that the ReadableStream class encapsulates the behavior of both simple readable streams and readable byte streams into a single class is by centralizing most of the potentially-varying logic inside the two controller classes, ReadableStreamDefaultController and ReadableByteStreamController. Those classes define most of the stateful internal slots and abstract operations for how a stream’s internal queue is managed and how it interfaces with its underlying source or underlying byte source.
</p>

<p>
各~制御器~classは、 2 つの内部~methodを定義する
— それらは、 `ReadableStream$I の各種~algoから~callされる：
◎
Each controller class defines two internal methods, which are called by the ReadableStream algorithms:
</p>

<dl>
	<dt>`CancelSteps@sl(%reason)</dt>
	<dd>
~streamが`取消され$たときの反応として走らす，制御器の手続き。
制御器に格納されている状態を片付けて，`下層~源$に伝えるために利用される。
◎
The controller’s steps that run in reaction to the stream being canceled, used to clean up the state stored in the controller and inform the underlying source.
</dd>

	<dt>`PullSteps@sl(%readRequest)</dt>
	<dd>
`既定の読取器$から読取されるときに走らす，制御器の手続き。
［
~queue済みの`~chunk$を制御器から~pullする ／
もっと~chunkを取得するため`下層~源$から~pullする
］ために利用される。
◎
The controller’s steps that run when a default reader is read from, used to pull from the controller any queued chunks, or pull from the underlying source to get more chunks.
</dd>
</dl>

<p>
（これらは、制御器の型に応じて分岐させることなく，各種 `ReadableStream$I ~algoから多形態的に~callできるよう、抽象-演算としてではなく，内部~methodとして定義される。）
◎
(These are defined as internal methods, instead of as abstract operations, so that they can be called polymorphically by the ReadableStream algorithms, without having to branch on which type of controller is present.)
</p>

<p>
この節の以降では、上述とは別方向の抽象-演算について注力する：
それらは、制御器~実装により，それぞれに結付けられている `ReadableStream$I ~objに影響させるために利用される。
これは、制御器における内部~状態~変化を， `ReadableStream$I の~public~APIを通して開発者に可視になる結果に翻訳する。
◎
The rest of this section concerns abstract operations that go in the other direction: they are used by the controller implementations to affect their associated ReadableStream object. This translates internal state changes of the controller into developer-facing results visible through the ReadableStream's public API.
</p>

<div class="algo">
<p>
`ReadableStreamAddReadIntoRequest(stream, readRequest)@A
は、次の手続きを遂行する：
◎
ReadableStreamAddReadIntoRequest(stream, readRequest) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`reader^sl は `ReadableStreamBYOBReader$I を`実装する$。
◎
Assert: stream.[[reader]] implements ReadableStreamBYOBReader.
</li>
	<li>
~Assert：
%stream.`state^sl ~IN { `readable^l, `closed^l }
◎
Assert: stream.[[state]] is "readable" or "closed".
</li>
	<li>
%stream.`reader^sl.`readIntoRequests^sl に %readRequest を`付加する$
◎
Append readRequest to stream.[[reader]].[[readIntoRequests]].
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamAddReadRequest(stream, readRequest)@A
は、次の手続きを遂行する：
◎
ReadableStreamAddReadRequest(stream, readRequest performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`reader^sl は `ReadableStreamDefaultReader$I を`実装する$。
◎
Assert: stream.[[reader]] implements ReadableStreamDefaultReader.
</li>
	<li>
~Assert：
%stream.`state^sl ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%stream.`reader^sl.`readRequests^sl に %readRequest を`付加する$
◎
Append readRequest to stream.[[reader]].[[readRequests]].
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamCancel(stream, reason)@A
は、次の手続きを遂行する：
◎
ReadableStreamCancel(stream, reason) performs the following steps:
</p>
<ol>
	<li>
%stream.`disturbed^sl ~SET ~T
◎
Set stream.[[disturbed]] to true.
</li>
	<li>
~IF［
%stream.`state^sl ~EQ `closed^l
］
⇒
~RET `undefined^jv で`解決される~promise$
◎
If stream.[[state]] is "closed", return a promise resolved with undefined.
</li>
	<li>
~IF［
%stream.`state^sl ~EQ `errored^l
］
⇒
~RET %stream.`storedError^sl で`却下される~promise$
◎
If stream.[[state]] is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~NOABRUPT `ReadableStreamClose$A( %stream )
◎
Perform ! ReadableStreamClose(stream).
</li>
	<li>
%sourceCancelPromise ~LET
~NOABRUPT %stream.`readableStreamController^sl.``CancelSteps^sl$A( %reason )
◎
Let sourceCancelPromise be ! stream.[[readableStreamController]].[[CancelSteps]](reason).
</li>
	<li>
~RET ［
`undefined^jv を返す充足~手続き
］で %sourceCancelPromise に`反応-$した結果
◎
Return the result of reacting to sourceCancelPromise with a fulfillment step that returns undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamClose(stream)@A
は、次の手続きを遂行する：
◎
ReadableStreamClose(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`state^sl ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%stream.`state^sl ~SET `closed^l
◎
Set stream.[[state]] to "closed".
</li>
	<li>
%reader ~LET %stream.`%reader^sl
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF［
%reader ~EQ `undefined^jv
］
⇒
~RET
◎
If reader is undefined, return.
</li>
	<li>
<p>
~IF［
%reader は `ReadableStreamDefaultReader$I を`実装する$
］：
◎
If reader implements ReadableStreamDefaultReader,
</p>
		<ol>
			<li>
%reader.`readRequests^sl を成す
~EACH( %readRequest )
に対し
⇒
%readRequest の`~close手続き$rR()
◎
For each readRequest of reader.[[readRequests]],
• Perform readRequest’s close steps.
</li>
			<li>
%reader.`readRequests^sl ~SET 空`~list$
◎
Set reader.[[readRequests]] to an empty list.
</li>
		</ol>
	</li>
	<li>
`undefined^jv で
%reader.`closedPromise^sl を`解決する$
◎
Resolve reader.[[closedPromise]] with undefined.
</li>
</ol>

<p class="note">
［
%stream.`state^sl ~EQ `closed^l
］でありつつ［
%stream.`closeRequested^sl ~EQ ~F
］である事例は、~streamが，その制御器の `close()^m 関数が一度も~callされずに~closeされたとき
— すなわち， ~streamが `cancel(reason)$rs の~callにより~closeされた場合 —
に起こる。
この事例では、制御器の `close()^m ~methodが~callされても，何もせず黙することも許容される
— 取消nは下層~源の制御の外なので。
◎
The case where stream.[[state]] is "closed", but stream.[[closeRequested]] is false, will happen if the stream was closed without its controller’s close method ever being called: i.e., if the stream was closed by a call to cancel(reason). In this case we allow the controller’s close() method to be called and silently do nothing, since the cancelation was outside the control of the underlying source.
</p>
</div>

<div class="algo">
<p>
`ReadableStreamError(stream, e)@A
は、次の手続きを遂行する：
◎
ReadableStreamError(stream, e) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`state^sl ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%stream.`state^sl ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.`storedError^sl ~SET %e
◎
Set stream.[[storedError]] to e.
</li>
	<li>
%reader ~LET %stream.`reader^sl
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF［
%reader ~EQ `undefined^jv
］
⇒
~RET
◎
If reader is undefined, return.
</li>
	<li>
<p>
~IF［
%reader は `ReadableStreamDefaultReader$I を`実装する$
］：
◎
If reader implements ReadableStreamDefaultReader,
</p>
		<ol>
			<li>
%reader.`readRequests^sl を成す
~EACH( %readRequest )
に対し
⇒
%readRequest の`~error手続き$rR( %e )
◎
For each readRequest of reader.[[readRequests]],
• Perform readRequest’s error steps, given e.
</li>
			<li>
%reader.`readRequests^sl ~SET 新たな空`~list$
◎
Set reader.[[readRequests]] to a new empty list.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%reader は `ReadableStreamBYOBReader$I を`実装する$。
◎
Assert: reader implements ReadableStreamBYOBReader.
</li>
			<li>
%reader.`readIntoRequests^sl を成す
~EACH( %readIntoRequest )
に対し
⇒
%readIntoRequest の`~error手続き$riR( %e )
◎
For each readIntoRequest of reader.[[readIntoRequests]],
• Perform readIntoRequest’s error steps, given e.
</li>
			<li>
%reader.`readIntoRequests^sl ~SET 新たな空`~list$
◎
Set reader.[[readIntoRequests]] to a new empty list.
</li>
		</ol>
	</li>
	<li>
%e で
%reader.`closedPromise^sl を`却下する$
◎
Reject reader.[[closedPromise]] with e.
</li>
	<li>
%reader.`closedPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamFulfillReadIntoRequest(stream, chunk, done)@A
は、次の手続きを遂行する：
◎
ReadableStreamFulfillReadIntoRequest(stream, chunk, done) performs the following steps:
</p>
<ol>
	<li>
%reader ~LET %stream.`reader^sl
◎
Let reader be stream.[[reader]].
</li>
	<li>
~Assert：
%reader.`readIntoRequests^sl は`空$でない。
◎
Assert: reader.[[readIntoRequests]] is not empty.
</li>
	<li>
%readIntoRequest ~LET %reader.`readIntoRequests^sl[0]
◎
Let readIntoRequest be reader.[[readIntoRequests]][0].
</li>
	<li>
%reader.`readIntoRequests^sl から %readIntoRequest を`除去する$
◎
Remove readIntoRequest from reader.[[readIntoRequests]].
</li>
	<li>
~IF［
%done ~EQ ~T
］
⇒
%readIntoRequest の`~close手続き$riR( %chunk )
◎
If done is true, perform readIntoRequest’s close steps, given chunk.
</li>
	<li>
~ELSE
⇒
%readIntoRequest の`~chunk手続き$riR( %chunk )
◎
Otherwise, perform readIntoRequest’s chunk steps, given chunk.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamFulfillReadRequest(stream, chunk, done)@A
は、次の手続きを遂行する：
◎
ReadableStreamFulfillReadRequest(stream, chunk, done) performs the following steps:
</p>
<ol>
	<li>
%reader ~LET %stream.`reader^sl
◎
Let reader be stream.[[reader]].
</li>
	<li>
~Assert：
%reader.`readRequests^sl は`空$でない。
◎
Assert: reader.[[readRequests]] is not empty.
</li>
	<li>
%readRequest ~LET %reader.`readRequests^sl[0]
◎
Let readRequest be reader.[[readRequests]][0].
</li>
	<li>
%reader.`readRequests^sl から %readRequest を`除去する$
◎
Remove readRequest from reader.[[readRequests]].
</li>
	<li>
~IF［
%done ~EQ ~T
］
⇒
%readRequest の`~close手続き$rR()
◎
If done is true, perform readRequest’s close steps.
</li>
	<li>
~ELSE
⇒
%readRequest の`~chunk手続き$rR( %chunk )
◎
Otherwise, perform readRequest’s chunk steps, given chunk.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamGetNumReadIntoRequests(stream)@A
は、次の手続きを遂行する：
◎
ReadableStreamGetNumReadIntoRequests(stream) performs the following steps:
</p>
<ol>
	<li>
~RET %stream.`reader^sl.`readIntoRequests^sl の`~size$
◎
Return stream.[[reader]].[[readIntoRequests]]'s size.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamGetNumReadRequests(stream)@A
は、次の手続きを遂行する：
◎
ReadableStreamGetNumReadRequests(stream) performs the following steps:
</p>
<ol>
	<li>
~RET %stream.`reader^sl.`readRequests^sl の`~size$
◎
Return stream.[[reader]].[[readRequests]]'s size.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamHasBYOBReader(stream)@A
は、次の手続きを遂行する：
◎
ReadableStreamHasBYOBReader(stream) performs the following steps:
</p>
<ol>
	<li>
%reader ~LET %stream.`reader^sl
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF［
%reader ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If reader is undefined, return false.
</li>
	<li>
~IF［
%reader は `ReadableStreamBYOBReader$I を`実装する$。
］
⇒
~RET ~T
◎
If reader implements ReadableStreamBYOBReader, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamHasDefaultReader(stream)@A
は、次の手続きを遂行する：
◎
ReadableStreamHasDefaultReader(stream) performs the following steps:
</p>
<ol>
	<li>
%reader ~LET %stream.`reader^sl
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF［
%reader ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If reader is undefined, return false.
</li>
	<li>
~IF［
%reader は `ReadableStreamDefaultReader$I を`実装する$
］
⇒
~RET ~T
◎
If reader implements ReadableStreamDefaultReader, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

			</section>
			<section id="rs-reader-abstract-ops">
<h4 title="Readers">4.8.3. 読取器</h4>

<p>
以下に与える抽象-演算は、［
`ReadableStreamDefaultReader$I ／
`ReadableStreamBYOBReader$I
］~instanceの実装と操作を~supportする。
◎
The following abstract operations support the implementation and manipulation of ReadableStreamDefaultReader and ReadableStreamBYOBReader instances.
</p>

<div class="algo">
<p>
`ReadableStreamReaderGenericCancel(reader, reason)@A
は、次の手続きを遂行する：
◎
ReadableStreamReaderGenericCancel(reader, reason) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %reader.`ownerReadableStream^sl
◎
Let stream be reader.[[ownerReadableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
~RET
~NOABRUPT `ReadableStreamCancel$A( %stream, %reason )
◎
Return ! ReadableStreamCancel(stream, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamReaderGenericInitialize(reader, stream)@A
は、次の手続きを遂行する：
◎
ReadableStreamReaderGenericInitialize(reader, stream) performs the following steps:
</p>
<ol>
	<li>
%reader.`ownerReadableStream^sl ~SET %stream
◎
Set reader.[[ownerReadableStream]] to stream.
</li>
	<li>
%stream.`reader^sl ~SET %reader
◎
Set stream.[[reader]] to reader.
</li>
	<li>
<p>
~IF［
%stream.`state^sl ~EQ `readable^l
］：
◎
If stream.[[state]] is "readable",
</p>
		<ol>
			<li>
%reader.`closedPromise^sl ~SET `新たな~promise$
◎
Set reader.[[closedPromise]] to a new promise.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%stream.`state^sl ~EQ `closed^l
］：
◎
Otherwise, if stream.[[state]] is "closed",
</p>
		<ol>
			<li>
%reader.`closedPromise^sl ~SET `undefined^jv で`解決される~promise$
◎
Set reader.[[closedPromise]] to a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%stream.`state^sl ~EQ `errored^l
◎
Assert: stream.[[state]] is "errored".
</li>
			<li>
%reader.`closedPromise^sl ~SET
%stream.`storedError^sl で`却下される~promise$
◎
Set reader.[[closedPromise]] to a promise rejected with stream.[[storedError]].
</li>
			<li>
%reader.`closedPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamReaderGenericRelease(reader)@A
は、次の手続きを遂行する：
◎
ReadableStreamReaderGenericRelease(reader) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%reader.`ownerReadableStream^sl ~NEQ `undefined^jv
◎
Assert: reader.[[ownerReadableStream]] is not undefined.
</li>
	<li>
~Assert：
%reader.`ownerReadableStream^sl.`reader^sl ~EQ %reader
◎
Assert: reader.[[ownerReadableStream]].[[reader]] is reader.
</li>
	<li>
~IF［
%reader.`ownerReadableStream^sl.`state^sl ~EQ `readable^l
］
⇒
`TypeError^jE で %reader.`closedPromise^sl を`却下する$
◎
If reader.[[ownerReadableStream]].[[state]] is "readable", reject reader.[[closedPromise]] with a TypeError exception.
</li>
	<li>
~ELSE
⇒
%reader.`closedPromise^sl ~SET
`TypeError^jE で`却下される~promise$
◎
Otherwise, set reader.[[closedPromise]] to a promise rejected with a TypeError exception.
</li>
	<li>
%reader.`closedPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
	<li>
%reader.`ownerReadableStream^sl.`reader^sl ~SET `undefined^jv
◎
Set reader.[[ownerReadableStream]].[[reader]] to undefined.
</li>
	<li>
%reader.`ownerReadableStream^sl ~SET `undefined^jv
◎
Set reader.[[ownerReadableStream]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamBYOBReaderRead(reader, view, readIntoRequest)@A
は、次の手続きを遂行する：
◎
ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %reader.`ownerReadableStream^sl
◎
Let stream be reader.[[ownerReadableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
%stream.`disturbed^sl ~SET ~T
◎
Set stream.[[disturbed]] to true.
</li>
	<li>
~IF［
%stream.`state^sl ~EQ `errored^l
］
⇒
%readIntoRequest の`~error手続き$riR( %stream.`storedError^sl  )
◎
If stream.[[state]] is "errored", perform readIntoRequest’s error steps given stream.[[storedError]].
</li>
	<li>
~RET
~NOABRUPT `ReadableByteStreamControllerPullInto$A( %stream.`readableStreamController^sl, %view, %readIntoRequest )
◎
Return ! ReadableByteStreamControllerPullInto(stream.[[readableStreamController]], view, readIntoRequest).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultReaderRead(reader, readRequest)@A
は、次の手続きを遂行する：
◎
ReadableStreamDefaultReaderRead(reader, readRequest) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %reader.`ownerReadableStream^sl
◎
Let stream be reader.[[ownerReadableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
%stream.`disturbed^sl ~SET ~T
◎
Set stream.[[disturbed]] to true.
</li>
	<li>
~IF［
%stream.`state^sl ~EQ `closed^l
］
⇒
%readRequest の`~close手続き$rR()
◎
If stream.[[state]] is "closed", perform readRequest’s close steps.
</li>
	<li>
~ELIF［
%stream.`state^sl ~EQ `errored^l
］
⇒
%readRequest の`~error手続き$rR( %stream.`storedError^sl )
◎
Otherwise, if stream.[[state]] is "errored", perform readRequest’s error steps given stream.[[storedError]].
</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%stream.`state^sl ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
			<li>
~NOABRUPT %stream.`readableStreamController^sl.`PullSteps$sl( %readRequest )
◎
Perform ! stream.[[readableStreamController]].[[PullSteps]](readRequest).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpReadableStreamBYOBReader(reader, stream)@A
は、次の手続きを遂行する：
◎
SetUpReadableStreamBYOBReader(reader, stream) performs the following steps:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( %stream ) ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If ! IsReadableStreamLocked(stream) is true, throw a TypeError exception.
</li>
	<li>
~IF［
%stream.`readableStreamController^sl は `ReadableByteStreamController$I を`実装しない$
］
⇒
~THROW `TypeError^jE
◎
If stream.[[readableStreamController]] does not implement ReadableByteStreamController, throw a TypeError exception.
</li>
	<li>
~NOABRUPT `ReadableStreamReaderGenericInitialize$A( %reader, %stream )
◎
Perform ! ReadableStreamReaderGenericInitialize(reader, stream).
</li>
	<li>
%reader.`readIntoRequests^sl ~SET 新たな空`~list$
◎
Set reader.[[readIntoRequests]] to a new empty list.
</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpReadableStreamDefaultReader(reader, stream)@A
は、次の手続きを遂行する：
◎
SetUpReadableStreamDefaultReader(reader, stream) performs the following steps:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( %stream ) ~EQ ~T
］
⇒
~THROW `TypeError^jE
◎
If ! IsReadableStreamLocked(stream) is true, throw a TypeError exception.
</li>
	<li>
~NOABRUPT `ReadableStreamReaderGenericInitialize$A( %reader, %stream )
◎
Perform ! ReadableStreamReaderGenericInitialize(reader, stream).
</li>
	<li>
%reader.`readRequests^sl ~SET 新たな空`~list$
◎
Set reader.[[readRequests]] to a new empty list.
</li>
</ol>
</div>

			</section>
			<section id="rs-default-controller-abstract-ops">
<h4 title="Default controllers">4.8.4. 既定の制御器</h4>

<p>
以下に与える抽象-演算は、
`ReadableStreamDefaultController$I ~classの実装を~supportする。
◎
The following abstract operations support the implementation of the ReadableStreamDefaultController class.
</p>

<div class="algo">
<p>
`ReadableStreamDefaultControllerCallPullIfNeeded(controller)@A
は、次の手続きを遂行する：
◎
ReadableStreamDefaultControllerCallPullIfNeeded(controller) performs the following steps:
</p>
<ol>
	<li>
%shouldPull ~LET
~NOABRUPT `ReadableStreamDefaultControllerShouldCallPull$A( %controller )
◎
Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
</li>
	<li>
~IF［
%shouldPull ~EQ ~F
］
⇒
~RET
◎
If shouldPull is false, return.
</li>
	<li>
<p>
~IF［
%controller.`pulling^sl ~EQ ~T
］：
◎
If controller.[[pulling]] is true,
</p>
		<ol>
			<li>
%controller.`pullAgain^sl ~SET ~T
◎
Set controller.[[pullAgain]] to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%controller .`pullAgain^sl ~EQ ~F
◎
Assert: controller.[[pullAgain]] is false.
</li>
	<li>
%controller.`pulling^sl ~SET ~T
◎
Set controller.[[pulling]] to true.
</li>
	<li>
<p>
%pullPromise ~LET %controller.`pullAlgorithm^sl()
◎
Let pullPromise be the result of performing controller.[[pullAlgorithm]].
</p>
		<ul>
			<li>
<p>
%pullPromise の`充足-時$には：
◎
Upon fulfillment of pullPromise,
</p>
				<ol>
					<li>
%controller.`pulling^sl ~SET ~F
◎
Set controller.[[pulling]] to false.
</li>
					<li>
<p>
~IF［
%controller.`pullAgain^sl ~EQ ~T
］：
◎
If controller.[[pullAgain]] is true,
</p>
						<ol>
							<li>
%controller.`pullAgain^sl ~SET ~F
◎
Set controller.[[pullAgain]] to false.
</li>
							<li>
~NOABRUPT `ReadableStreamDefaultControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
事由 %e による %pullPromise の`却下-時$には：
◎
Upon rejection of pullPromise with reason e,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %controller, %e )
◎
Perform ! ReadableStreamDefaultControllerError(controller, e).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerShouldCallPull(controller)@A
は、次の手続きを遂行する：
◎
ReadableStreamDefaultControllerShouldCallPull(controller) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerCanCloseOrEnqueue$A( %controller ) ~EQ ~F
］
⇒
~RET ~F
◎
If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return false.
</li>
	<li>
~IF［
%controller.`started^sl ~EQ ~F
］
⇒
~RET ~F
◎
If controller.[[started]] is false, return false.
</li>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( %stream ) ~EQ ~T
］~AND［
~NOABRUPT `ReadableStreamGetNumReadRequests$A( %stream ) ~GT 0
］
⇒
~RET ~T
◎
If ! IsReadableStreamLocked(stream) is true and ! ReadableStreamGetNumReadRequests(stream) &gt; 0, return true.
</li>
	<li>
%desiredSize ~LET
~NOABRUPT `ReadableStreamDefaultControllerGetDesiredSize$A( %controller )
◎
Let desiredSize be ! ReadableStreamDefaultControllerGetDesiredSize(controller).
</li>
	<li>
~Assert：
%desiredSize ~NEQ ~NULL
◎
Assert: desiredSize is not null.
</li>
	<li>
~IF［
%desiredSize ~GT 0
］
⇒
~RET ~T
◎
If desiredSize &gt; 0, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerClearAlgorithms(controller)@A
は、~streamが~closeされるか~errorして，各種~algoが それ以上~実行されなくなったときに~callされる。
これは、各種~algoへの参照を除去することにより，`下層~源$（ `ReadableStream$I ~obj）自身が
— まだ参照されていても —
~garbage収集されることを許可する。
◎
ReadableStreamDefaultControllerClearAlgorithms(controller) is called once the stream is closed or errored and the algorithms will not be executed any more. By removing the algorithm references it permits the underlying source object to be garbage collected even if the ReadableStream itself is still referenced.
</p>

<p class="note">注記：
これは、<a href="https://github.com/tc39/proposal-weakrefs/">弱い参照</a>を利用すれば観測-可能になる。
詳細は
<a href="https://github.com/tc39/proposal-weakrefs/issues/31">tc39/proposal-weakrefs#31</a>
を見よ。
◎
This is observable using weak references. See tc39/proposal-weakrefs#31 for more detail.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%controller.`pullAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[pullAlgorithm]] to undefined.
</li>
	<li>
%controller.`cancelAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[cancelAlgorithm]] to undefined.
</li>
	<li>
%controller.`strategySizeAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[strategySizeAlgorithm]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerClose(controller)@A
は、可読~streamを~closeしたいと望む他の仕様から~callされ得る
— 開発者が作成した~streamが［
それに結付けられた制御器~objにより~closeされる
］のと同じ仕方で。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを行う`べきでない^em。
◎
ReadableStreamDefaultControllerClose(controller) can be called by other specifications that wish to close a readable stream, in the same way a developer-created stream would be closed by its associated controller object. Specifications should not do this to streams or controllers they did not create.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerCanCloseOrEnqueue$A( %controller ) ~EQ ~F
］
⇒
~RET
◎
If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
</li>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%controller.`closeRequested^sl ~SET ~T
◎
Set controller.[[closeRequested]] to true.
</li>
	<li>
<p>
~IF［
%controller.`queue^sl は`空$である
］：
◎
If controller.[[queue]] is empty,
</p>
		<ol>
			<li>
~NOABRUPT `ReadableStreamDefaultControllerClearAlgorithms$A( %controller )
◎
Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
</li>
			<li>
~NOABRUPT `ReadableStreamClose$A( %stream )
◎
Perform ! ReadableStreamClose(stream).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerEnqueue(controller, chunk)@A
は、可読~stream内に`~chunk$たちを~enqueueしたいと望む他の仕様から~callされ得る
— 開発者が［
~streamに結付けられた制御器~objを利用して，~chunkたちを~enqueueする
］のと同じ仕方で。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを行う`べきでない^em。
◎
ReadableStreamDefaultControllerEnqueue(controller, chunk) can be called by other specifications that wish to enqueue chunks in a readable stream, in the same way a developer would enqueue chunks using the stream’s associated controller object. Specifications should not do this to streams or controllers they did not create.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerCanCloseOrEnqueue$A( %controller ) ~EQ ~F
］
⇒
~RET
◎
If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) is false, return.
</li>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
~NOABRUPT `IsReadableStreamLocked$A( %stream ) ~EQ ~T
］~AND［
~NOABRUPT `ReadableStreamGetNumReadRequests$A( %stream ) ~GT 0
］
⇒
~NOABRUPT `ReadableStreamFulfillReadRequest$A( %stream, %chunk, ~F )
◎
If ! IsReadableStreamLocked(stream) is true and ! ReadableStreamGetNumReadRequests(stream) &gt; 0, perform ! ReadableStreamFulfillReadRequest(stream, chunk, false).
</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
%result ~LET 次を遂行した結果を`完了~record$として解釈した結果
⇒
%controller.`strategySizeAlgorithm^sl( %chunk )
◎
Let result be the result of performing controller.[[strategySizeAlgorithm]], passing in chunk, and interpreting the result as a completion record.
</li>
			<li>
<p>
~IF［
%result は`中途完了^である
］：
◎
If result is an abrupt completion,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %controller, %result.`Value^sl )
◎
Perform ! ReadableStreamDefaultControllerError(controller, result.[[Value]]).
</li>
					<li>
~RET %result
◎
Return result.
</li>
				</ol>
			</li>
			<li>
%chunkSize ~LET %result.`Value^sl
◎
Let chunkSize be result.[[Value]].
</li>
			<li>
%enqueueResult ~LET
`EnqueueValueWithSize$A( %controller, %chunk, %chunkSize )
◎
Let enqueueResult be EnqueueValueWithSize(controller, chunk, chunkSize).
</li>
			<li>
<p>
~IF［
%enqueueResult は`中途完了^である
］：
◎
If enqueueResult is an abrupt completion,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %controller, %enqueueResult.`Value^sl )
◎
Perform ! ReadableStreamDefaultControllerError(controller, enqueueResult.[[Value]]).
</li>
					<li>
~RET %enqueueResult
◎
Return enqueueResult.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerError(controller, e)@A
は、可読~streamを~error状態へ移行させたいと望む他の仕様から~callされ得る
— 開発者が［
~streamに結付けられた制御器~objを利用して，~streamを~errorにする
］のと同じ仕方で。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを行う`べきでない^em。
◎
ReadableStreamDefaultControllerError(controller, e) can be called by other specifications that wish to move a readable stream to an errored state, in the same way a developer would error a stream using its associated controller object. Specifications should not do this to streams or controllers they did not create.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
%stream.`state^sl ~NEQ `readable^l
］
⇒
~RET
◎
If stream.[[state]] is not "readable", return.
</li>
	<li>
~NOABRUPT `ResetQueue$A( %controller )
◎
Perform ! ResetQueue(controller).
</li>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerClearAlgorithms$A( %controller )
◎
Perform ! ReadableStreamDefaultControllerClearAlgorithms(controller).
</li>
	<li>
~NOABRUPT `ReadableStreamError$A( %stream, %e )
◎
Perform ! ReadableStreamError(stream, e).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerGetDesiredSize(controller)@A
は、この`~streamの内部~queueの残り~size$を決定したいと望む他の仕様から~callされ得る
— 開発者が［
~streamに結付けられている制御器~objの `desiredSize^rsdc ~prop
］にあたるときと同様に。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを利用する`べきでない^em。
◎
ReadableStreamDefaultControllerGetDesiredSize(controller) can be called by other specifications that wish to determine the desired size to fill this stream’s internal queue, similar to how a developer would consult the desiredSize property of the stream’s associated controller object. Specifications should not use this on streams or controllers they did not create.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~EQ `errored^l
］
⇒
~RET ~NULL
◎
If state is "errored", return null.
</li>
	<li>
~IF［
%state ~EQ `closed^l
］
⇒
~RET 0
◎
If state is "closed", return 0.
</li>
	<li>
~RET %controller.`strategyHWM^sl ~MINUS %controller.`queueTotalSize^sl
◎
Return controller.[[strategyHWM]] − controller.[[queueTotalSize]].
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerHasBackpressure(controller)@A
は、 `TransformStream$I の実装に利用される。
それは、次の手続きを遂行する：
◎
ReadableStreamDefaultControllerHasBackpressure(controller) is used in the implementation of TransformStream. It performs the following steps:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerShouldCallPull$A( %controller ) ~EQ ~T
］
⇒
~RET ~F
◎
If ! ReadableStreamDefaultControllerShouldCallPull(controller) is true, return false.
</li>
	<li>
~RET ~T
◎
Otherwise, return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)@A
は、次の手続きを遂行する：
◎
ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) performs the following steps:
</p>
<ol>
	<li>
%state ~LET %controller.`controlledReadableStream^sl.`state^sl
◎
Let state be controller.[[controlledReadableStream]].[[state]].
</li>
	<li>
~IF［
%controller.`closeRequested^sl ~EQ ~F
］~AND［
%state ~EQ `readable^l
］
⇒
~RET ~T
◎
If controller.[[closeRequested]] is false and state is "readable", return true.
</li>
	<li>
~RET ~F
◎
Otherwise, return false.
</li>
</ol>

<div class="note">
<p>注記：
［
%controller.`closeRequested^sl ~EQ ~F
］でありつつ［
%state ~NEQ `readable^l
］になる事例は、次のときに起こる：
◎
The case where controller.[[closeRequested]] is false, but state is not "readable", happens when＼
</p>
<ul>
	<li>
<code>%controller.`error(e)$rsdc</code>
を介して，~streamが~errorにされたとき
◎
the stream is errored via controller.error(), or＼
</li>
	<li>
<code>%controller.`close()$rsdc</code>
が一度も~callされずに，~streamが
— 例：
<code>%stream.`cancel(reason)$rs</code>
の~callにより —
~closeされたとき
◎
when it is closed without its controller’s controller.close() method ever being called: e.g., if the stream was closed by a call to stream.cancel().
</li>
</ul>
</div>
</div>


<div class="algo">
<p>
`SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm)@A
は、次の手続きを遂行する：
◎
SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`readableStreamController^sl ~EQ `undefined^jv
◎
Assert: stream.[[readableStreamController]] is undefined.
</li>
	<li>
%controller.`controlledReadableStream^sl ~SET %stream
◎
Set controller.[[controlledReadableStream]] to stream.
</li>
	<li>
~NOABRUPT `ResetQueue$A( %controller )
◎
Perform ! ResetQueue(controller).
</li>
	<li>
%controller の
⇒＃
.`started^sl ~SET ~F,
.`closeRequested^sl ~SET ~F,
.`pullAgain^sl ~SET ~F,
.`pulling^sl ~SET ~F,
.`strategySizeAlgorithm^sl ~SET %sizeAlgorithm,
.`strategyHWM^sl ~SET %highWaterMark,
.`pullAlgorithm^sl ~SET %pullAlgorithm,
.`cancelAlgorithm^sl ~SET %cancelAlgorithm
◎
Set controller.[[started]], controller.[[closeRequested]], controller.[[pullAgain]], and controller.[[pulling]] to false.
◎
Set controller.[[strategySizeAlgorithm]] to sizeAlgorithm and controller.[[strategyHWM]] to highWaterMark.
◎
Set controller.[[pullAlgorithm]] to pullAlgorithm.
◎
Set controller.[[cancelAlgorithm]] to cancelAlgorithm.
</li>
	<li>
%stream.`readableStreamController^sl ~SET %controller
◎
Set stream.[[readableStreamController]] to controller.
</li>
	<li>
%startResult ~LET %startAlgorithm()
（これは、例外を投出するかもしれない）
◎
Let startResult be the result of performing startAlgorithm. (This might throw an exception.)
</li>
	<li>
<p>
%startPromise ~LET %startResult で`解決される~promise$
◎
Let startPromise be a promise resolved with startResult.
</p>

		<ul>
			<li>
<p>
%startPromise の`充足-時$には：
◎
Upon fulfillment of startPromise,
</p>
				<ol>
					<li>
%controller.`started^sl ~SET ~T
◎
Set controller.[[started]] to true.
</li>
					<li>
~Assert：
%controller.`pulling^sl ~EQ ~F
◎
Assert: controller.[[pulling]] is false.
</li>
					<li>
~Assert：
%controller.`pullAgain^sl ~EQ ~F
◎
Assert: controller.[[pullAgain]] is false.
</li>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r による %startPromise の`却下-時$には：
◎
Upon rejection of startPromise with reason r,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %controller, %r )
◎
Perform ! ReadableStreamDefaultControllerError(controller, r).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, controller, underlyingSource, underlyingSourceDict, highWaterMark, sizeAlgorithm)@A
は、次の手続きを遂行する：
◎
SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, controller, underlyingSource, underlyingSourceDict, highWaterMark, sizeAlgorithm) performs the following steps:
</p>
<ol>
	<li>
%controller ~LET `新たな$ `ReadableStreamDefaultController$I
◎
Let controller be a new ReadableStreamDefaultController.
</li>
	<li>
%startAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv
◎
Let startAlgorithm be an algorithm that returns undefined.
</li>
	<li>
%pullAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let pullAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
%cancelAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let cancelAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
~IF［
%underlyingSourceDict[ "`start$usc" ] ~NEQ ε
］
⇒
%startAlgorithm ~SET 次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSourceDict[ "`start$usc" ], « %controller »,  %underlyingSource )
◎
If underlyingSourceDict["start"] exists, then set startAlgorithm to an algorithm which returns the result of invoking underlyingSourceDict["start"] with argument list « controller » and callback this value underlyingSource.
</li>
	<li>
~IF［
%underlyingSourceDict[ "`pull$usc" ] ~NEQ ε
］
⇒
%pullAlgorithm ~SET に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSourceDict[ "`pull$usc" ], « %controller », %underlyingSource
◎
If underlyingSourceDict["pull"] exists, then set pullAlgorithm to an algorithm which returns the result of invoking underlyingSourceDict["pull"] with argument list « controller » and callback this value underlyingSource.
</li>
	<li>
~IF［
%underlyingSourceDict[ "`cancel$usc" ] ~NEQ ε
］
⇒
%cancelAlgorithm ~SET 所与の ( %reason ) に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSourceDict[ "`cancel$usc" ], « %reason », %underlyingSource )
◎
If underlyingSourceDict["cancel"] exists, then set cancelAlgorithm to an algorithm which takes an argument reason and returns the result of invoking underlyingSourceDict["cancel"] with argument list « reason » and callback this value underlyingSource.
</li>
	<li>
~ABRUPT `SetUpReadableStreamDefaultController$A( %stream, %controller, %startAlgorithm, %pullAlgorithm, %cancelAlgorithm, %highWaterMark, %sizeAlgorithm )
◎
Perform ? SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm).
</li>
</ol>
</div>

			</section>
			<section id="rbs-controller-abstract-ops">
<h4 title="Byte stream controllers">4.8.5. ~byte~stream制御器</h4>

<div class="algo">
<p>
`ReadableByteStreamControllerCallPullIfNeeded(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerCallPullIfNeeded(controller) performs the following steps:
</p>
<ol>
	<li>
%shouldPull ~LET
~NOABRUPT `ReadableByteStreamControllerShouldCallPull$A( %controller )
◎
Let shouldPull be ! ReadableByteStreamControllerShouldCallPull(controller).
</li>
	<li>
~IF［
%shouldPull ~EQ ~F
］
⇒
~RET
◎
If shouldPull is false, return.
</li>
	<li>
<p>
~IF［
%controller.`pulling^sl ~EQ ~T
］：
◎
If controller.[[pulling]] is true,
</p>
		<ol>
			<li>
%controller.`pullAgain^sl ~SET ~T
◎
Set controller.[[pullAgain]] to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%controller.`pullAgain^sl ~EQ ~F
◎
Assert: controller.[[pullAgain]] is false.
</li>
	<li>
%controller.`pulling^sl ~SET ~T
◎
Set controller.[[pulling]] to true.
</li>
	<li>
<p>
%pullPromise ~LET %controller.`pullAlgorithm^sl()
◎
Let pullPromise be the result of performing controller.[[pullAlgorithm]].
</p>

		<ul>
			<li>
<p>
%pullPromise の`充足-時$には：
◎
Upon fulfillment of pullPromise,
</p>
				<ol>
					<li>
%controller.`pulling^sl ~SET ~F
◎
Set controller.[[pulling]] to false.
</li>
					<li>
<p>
~IF［
%controller.`pullAgain^sl ~EQ ~T
］：
◎
If controller.[[pullAgain]] is true,
</p>
						<ol>
							<li>
%controller.`pullAgain^sl ~SET ~F
◎
Set controller.[[pullAgain]] to false.
</li>
							<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
事由 %e による
%pullPromise の`却下-時$には：
◎
Upon rejection of pullPromise with reason e,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableByteStreamControllerError$A( %controller, %e )
◎
Perform ! ReadableByteStreamControllerError(controller, e).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerClearAlgorithms(controller)@A
は、~streamが~closeされるか~errorして，各種~algoが それ以上~実行されなくなったときに~callされる。
これは、各種~algoへの参照を除去して，［
`ReadableStream$I ~obj自体は まだ参照されていても，`下層~byte源$は~garbage収集される
］ことを許可する。
◎
ReadableByteStreamControllerClearAlgorithms(controller) is called once the stream is closed or errored and the algorithms will not be executed any more. By removing the algorithm references it permits the underlying byte source object to be garbage collected even if the ReadableStream itself is still referenced.
</p>

<p class="note">注記：
これは、<a href="https://github.com/tc39/proposal-weakrefs/">弱い参照</a>を利用すると観測-可能になる。
詳細は
<a href="https://github.com/tc39/proposal-weakrefs/issues/31">tc39/proposal-weakrefs#31</a>
を見よ。
◎
This is observable using weak references. See tc39/proposal-weakrefs#31 for more detail.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%controller.`pullAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[pullAlgorithm]] to undefined.
</li>
	<li>
%controller.`cancelAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[cancelAlgorithm]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerClearPendingPullIntos(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerClearPendingPullIntos(controller) performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `ReadableByteStreamControllerInvalidateBYOBRequest$A( %controller )
◎
Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
</li>
	<li>
%controller.`pendingPullIntos^sl ~SET 新たな空`~list$
◎
Set controller.[[pendingPullIntos]] to a new empty list.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerClose(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerClose(controller) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
%controller.`closeRequested^sl ~EQ ~T
］~OR［
%stream.`state^sl ~NEQ `readable^l
］
⇒
~RET
◎
If controller.[[closeRequested]] is true or stream.[[state]] is not "readable", return.
</li>
	<li>
<p>
~IF［
%controller.`queueTotalSize^sl ~GT 0
］：
◎
If controller.[[queueTotalSize]] &gt; 0,
</p>
		<ol>
			<li>
%controller.`closeRequested^sl ~SET ~T
◎
Set controller.[[closeRequested]] to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%controller.`pendingPullIntos^sl は空でない
］：
◎
If controller.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%firstPendingPullInto ~LET %controller.`pendingPullIntos^sl[0]
◎
Let firstPendingPullInto be controller.[[pendingPullIntos]][0].
</li>
			<li>
<p>
~IF［
%firstPendingPullInto の`~fill済み~byte数$pD ~GT 0
］：
◎
If firstPendingPullInto’s bytes filled &gt; 0,
</p>
				<ol>
					<li>
%e ~LET 新たな `TypeError^jE 例外
◎
Let e be a new TypeError exception.
</li>
					<li>
~NOABRUPT `ReadableByteStreamControllerError$A( %controller, %e )
◎
Perform ! ReadableByteStreamControllerError(controller, e).
</li>
					<li>
~THROW %e
◎
Throw e.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerClearAlgorithms$A( %controller )
◎
Perform ! ReadableByteStreamControllerClearAlgorithms(controller).
</li>
	<li>
~NOABRUPT `ReadableStreamClose$A( %stream )
◎
Perform ! ReadableStreamClose(stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`state^sl ~NEQ `errored^l
◎
Assert: stream.[[state]] is not "errored".
</li>
	<li>
%done ~LET ~F
◎
Let done be false.
</li>
	<li>
<p>
~IF［
%stream.`state^sl ~EQ `closed^l
］：
◎
If stream.[[state]] is "closed",
</p>
		<ol>
			<li>
~Assert：
%pullIntoDescriptor の`~fill済み~byte数$pD ~EQ 0
◎
Assert: pullIntoDescriptor’s bytes filled is 0.
</li>
			<li>
%done ~SET ~T
◎
Set done to true.
</li>
		</ol>
	</li>
	<li>
%filledView ~LET
~NOABRUPT `ReadableByteStreamControllerConvertPullIntoDescriptor$A( %pullIntoDescriptor )
◎
Let filledView be ! ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor).
</li>
	<li>
<p>
~IF［
%pullIntoDescriptor の`読取器~型$pD ~EQ `default^l
］：
◎
If pullIntoDescriptor’s reader type is "default",
</p>
		<ol>
			<li>
~NOABRUPT `ReadableStreamFulfillReadRequest$A( %stream, %filledView, %done )
◎
Perform ! ReadableStreamFulfillReadRequest(stream, filledView, done).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%pullIntoDescriptor の`読取器~型$pD ~EQ `byob^l
：
◎
Assert: pullIntoDescriptor’s reader type is "byob".
</li>
			<li>
~NOABRUPT `ReadableStreamFulfillReadIntoRequest$A( %stream, %filledView, %done )
◎
Perform ! ReadableStreamFulfillReadIntoRequest(stream, filledView, done).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) performs the following steps:
</p>
<ol>
	<li>
%bytesFilled ~LET %pullIntoDescriptor の`~fill済み~byte数$pD
◎
Let bytesFilled be pullIntoDescriptor’s bytes filled.
</li>
	<li>
%elementSize ~LET %pullIntoDescriptor の`要素~size$pD
◎
Let elementSize be pullIntoDescriptor’s element size.
</li>
	<li>
~Assert：
%bytesFilled ~LTE %pullIntoDescriptor の`~byte長さ$pD
◎
Assert: bytesFilled ≤ pullIntoDescriptor’s byte length.
</li>
	<li>
~Assert：
( %bytesFilled `mod^op %elementSize ) ~EQ 0
◎
Assert: bytesFilled mod elementSize is 0.
</li>
	<li>
~RET
~NOABRUPT `Construct$Ax( %pullIntoDescriptor の`~view構築子$pD, « %pullIntoDescriptor の`~buffer$pD, %pullIntoDescriptor の`~byte~offset$pD, %bytesFilled ~DIV %elementSize » )
◎
Return ! Construct(pullIntoDescriptor’s view constructor, « pullIntoDescriptor’s buffer, pullIntoDescriptor’s byte offset, bytesFilled ÷ elementSize »).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerEnqueue(controller, chunk)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerEnqueue(controller, chunk) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
%controller.`closeRequested^sl ~EQ ~T
］~OR［
%stream.`state^sl ~NEQ `readable^l
］
⇒
~RET
◎
If controller.[[closeRequested]] is true or stream.[[state]] is not "readable", return.
</li>
	<li>
%buffer ~LET %chunk.`ViewedArrayBuffer^sl
◎
Let buffer be chunk.[[ViewedArrayBuffer]].
</li>
	<li>
%byteOffset ~LET %chunk.`ByteOffset^sl
◎
Let byteOffset be chunk.[[ByteOffset]].
</li>
	<li>
%byteLength ~LET %chunk.`ByteLength^sl
◎
Let byteLength be chunk.[[ByteLength]].
</li>
	<li>
%transferredBuffer ~LET
~NOABRUPT `TransferArrayBuffer$A( %buffer )
◎
Let transferredBuffer be ! TransferArrayBuffer(buffer).
</li>
	<li>
<p>
~IF［
~NOABRUPT `ReadableStreamHasDefaultReader$A( %stream ) ~EQ ~T
］：
◎
If ! ReadableStreamHasDefaultReader(stream) is true
</p>
		<ol>
			<li>
<p>
~IF［
~NOABRUPT `ReadableStreamGetNumReadRequests$A( %stream ) ~EQ 0
］：
◎
If ! ReadableStreamGetNumReadRequests(stream) is 0,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %transferredBuffer, %byteOffset, %byteLength )
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength).
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise,
</p>
				<ol>
					<li>
~Assert：
%controller.`queue^sl は`空$である
◎
Assert: controller.[[queue]] is empty.
</li>
					<li>
%transferredView ~LET
~NOABRUPT `Construct$Ax( `Uint8Array$jI, « %transferredBuffer, %byteOffset, %byteLength » )
◎
Let transferredView be ! Construct(%Uint8Array%, « transferredBuffer, byteOffset, byteLength »).
</li>
					<li>
~NOABRUPT `ReadableStreamFulfillReadRequest$A( %stream, %transferredView, ~F )
◎
Perform ! ReadableStreamFulfillReadRequest(stream, transferredView, false).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
~NOABRUPT `ReadableStreamHasBYOBReader$A( %stream ) ~EQ ~T
］：
◎
Otherwise, if ! ReadableStreamHasBYOBReader(stream) is true,
</p>
		<ol>
			<li>
~NOABRUPT `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %transferredBuffer, %byteOffset, %byteLength )
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength).
</li>
			<li>
~NOABRUPT `ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue$A( %controller )
◎
Perform ! ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
~NOABRUPT `IsReadableStreamLocked$A( %stream ) ~EQ ~F
◎
Assert: ! IsReadableStreamLocked(stream) is false.
</li>
			<li>
~NOABRUPT `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %transferredBuffer, %byteOffset, %byteLength )
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength).
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) performs the following steps:
</p>
<ol>
	<li>
%controller.`queue^sl に［
次を伴う，新たな`可読~byte~stream用の~queue~entry$
］を`付加する$
⇒＃
`~buffer$qE ~SET %buffer,
`~byte~offset$qE ~SET %byteOffset,
`~byte長さ$qE ~SET %byteLength
◎
Append a new readable byte stream queue entry with buffer buffer, byte offset byteOffset, and byte length byteLength to controller.[[queue]].
</li>
	<li>
%controller.`queueTotalSize^sl ~INCBY %byteLength
◎
Set controller.[[queueTotalSize]] to controller.[[queueTotalSize]] + byteLength.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerError(controller, e)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerError(controller, e) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
%stream.`state^sl ~NEQ `readable^l
］
⇒
~RET
◎
If stream.[[state]] is not "readable", return.
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerClearPendingPullIntos$A( %controller )
◎
Perform ! ReadableByteStreamControllerClearPendingPullIntos(controller).
</li>
	<li>
~NOABRUPT `ResetQueue$A( %controller )
◎
Perform ! ResetQueue(controller).
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerClearAlgorithms$A( %controller )
◎
Perform ! ReadableByteStreamControllerClearAlgorithms(controller).
</li>
	<li>
~NOABRUPT `ReadableStreamError$A( %stream, %e )
◎
Perform ! ReadableStreamError(stream, e).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) performs the following steps:
</p>
<ol>
	<li>
~Assert：［
%controller.`pendingPullIntos^sl は`空$である
］~OR［
%controller.`pendingPullIntos^sl[0] ~EQ %pullIntoDescriptor
］
◎
Assert: either controller.[[pendingPullIntos]] is empty, or controller.[[pendingPullIntos]][0] is pullIntoDescriptor.
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerInvalidateBYOBRequest$A( %controller )
◎
Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
</li>
	<li>
%pullIntoDescriptor の`~fill済み~byte数$pD ~INCBY %size
◎
Set pullIntoDescriptor’s bytes filled to bytes filled + size.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) performs the following steps:
</p>
<ol>
	<li>
%elementSize ~LET %pullIntoDescriptor の`要素~size$pD【！[[elementSize]]】
◎
Let elementSize be pullIntoDescriptor.[[elementSize]].
</li>
	<li>
%currentAlignedBytes ~LET
( %pullIntoDescriptor の`~fill済み~byte数$pD ~MINUS ( %pullIntoDescriptor の`~fill済み~byte数$pD `mod^op %elementSize ) )
◎
Let currentAlignedBytes be pullIntoDescriptor’s bytes filled − (pullIntoDescriptor’s bytes filled mod elementSize).
</li>
	<li>
%maxBytesToCopy ~LET
`min^op( %controller.`queueTotalSize^sl,
( %pullIntoDescriptor の`~byte長さ$pD ~MINUS %pullIntoDescriptor の`~fill済み~byte数$pD )
)
◎
Let maxBytesToCopy be min(controller.[[queueTotalSize]], pullIntoDescriptor’s byte length − pullIntoDescriptor’s bytes filled).
</li>
	<li>
%maxBytesFilled ~LET
( %pullIntoDescriptor の`~fill済み~byte数$pD ~PLUS %maxBytesToCopy )
◎
Let maxBytesFilled be pullIntoDescriptor’s bytes filled + maxBytesToCopy.
</li>
	<li>
%maxAlignedBytes ~LET
( %maxBytesFilled ~MINUS ( %maxBytesFilled `mod^op %elementSize ) )
◎
Let maxAlignedBytes be maxBytesFilled − (maxBytesFilled mod elementSize).
</li>
	<li>
%totalBytesToCopyRemaining ~LET %maxBytesToCopy
◎
Let totalBytesToCopyRemaining be maxBytesToCopy.
</li>
	<li>
%ready ~LET ~F
◎
Let ready be false.
</li>
	<li>
<p>
~IF［
%maxAlignedBytes ~GT %currentAlignedBytes
］：
◎
If maxAlignedBytes &gt; currentAlignedBytes,
</p>
		<ol>
			<li>
%totalBytesToCopyRemaining ~SET %maxAlignedBytes ~MINUS %pullIntoDescriptor の`~fill済み~byte数$pD
◎
Set totalBytesToCopyRemaining to maxAlignedBytes − pullIntoDescriptor’s bytes filled.
</li>
			<li>
%ready ~SET ~T
◎
Set ready to true.
</li>
		</ol>
	</li>
	<li>
%queue ~LET %controller.`queue^sl
◎
Let queue be controller.[[queue]].
</li>
	<li>
<p>
~WHILE［
%totalBytesToCopyRemaining ~GT 0
］：
◎
While totalBytesToCopyRemaining &gt; 0,
</p>
		<ol>
			<li>
%headOfQueue ~LET %queue[0]
◎
Let headOfQueue be queue[0].
</li>
			<li>
%bytesToCopy ~LET
`min^op( %totalBytesToCopyRemaining, %headOfQueue の`~byte長さ$qE )
◎
Let bytesToCopy be min(totalBytesToCopyRemaining, headOfQueue’s byte length).
</li>
			<li>
%destStart ~LET
( %pullIntoDescriptor の`~byte~offset$pD ~PLUS %pullIntoDescriptor の`~fill済み~byte数$pD )
◎
Let destStart be pullIntoDescriptor’s byte offset + pullIntoDescriptor’s bytes filled.
</li>
			<li>
~NOABRUPT `CopyDataBlockBytes$Ax( %pullIntoDescriptor の`~buffer$pD.`ArrayBufferData^sl, %destStart, %headOfQueue の`~buffer$qE.`ArrayBufferData^sl, %headOfQueue の`~byte~offset$qE, %bytesToCopy )
◎
Perform ! CopyDataBlockBytes(pullIntoDescriptor’s buffer.[[ArrayBufferData]], destStart, headOfQueue’s buffer.[[ArrayBufferData]], headOfQueue’s byte offset, bytesToCopy).
</li>
			<li>
<p>
~IF［
%headOfQueue の`~byte長さ$qE ~EQ %bytesToCopy
］：
◎
If headOfQueue’s byte length is bytesToCopy,
</p>
				<ol>
					<li>
%queue[0] を`除去する$
◎
Remove queue[0].
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise,
</p>
				<ol>
					<li>
%headOfQueue の`~byte~offset$qE ~INCBY %bytesToCopy
◎
Set headOfQueue’s byte offset to headOfQueue’s byte offset + bytesToCopy.
</li>
					<li>
%headOfQueue の`~byte長さ$qE ~DECBY %bytesToCopy
◎
Set headOfQueue’s byte length to headOfQueue’s byte length − bytesToCopy.
</li>
				</ol>
			</li>
			<li>
%controller.`queueTotalSize^sl ~DECBY %bytesToCopy
◎
Set controller.[[queueTotalSize]] to controller.[[queueTotalSize]] − bytesToCopy.
</li>
			<li>
~NOABRUPT `ReadableByteStreamControllerFillHeadPullIntoDescriptor$A( %controller, %bytesToCopy, %pullIntoDescriptor )
◎
Perform ! ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor).
</li>
			<li>
%totalBytesToCopyRemaining ~DECBY %bytesToCopy
◎
Set totalBytesToCopyRemaining to totalBytesToCopyRemaining − bytesToCopy.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%ready ~EQ ~F
］：
◎
If ready is false,
</p>
		<ol>
			<li>
~Assert：
%controller.`queueTotalSize^sl ~EQ 0
◎
Assert: controller.[[queueTotalSize]] is 0.
</li>
			<li>
~Assert：
%pullIntoDescriptor の`~fill済み~byte数$pD ~GT 0
◎
Assert: pullIntoDescriptor’s bytes filled &gt; 0.
</li>
			<li>
~Assert：
%pullIntoDescriptor の`~fill済み~byte数$pD ~LT %pullIntoDescriptor の`要素~size$pD
◎
Assert: pullIntoDescriptor’s bytes filled &lt; pullIntoDescriptor’s element size.
</li>
		</ol>
	</li>
	<li>
~RET %ready
◎
Return ready.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerGetDesiredSize(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerGetDesiredSize(controller) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~EQ `errored^l
］
⇒
~RET ~NULL
◎
If state is "errored", return null.
</li>
	<li>
~IF［
%state ~EQ `closed^l
］
⇒
~RET 0
◎
If state is "closed", return 0.
</li>

	<li>
~RET %controller.`strategyHWM^sl ~MINUS %controller.`queueTotalSize^sl
◎
Return controller.[[strategyHWM]] − controller.[[queueTotalSize]].
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerHandleQueueDrain(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerHandleQueueDrain(controller) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%controller.`controlledReadableStream^sl.`state^sl ~EQ `readable^l
◎
Assert: controller.[[controlledReadableStream]].[[state]] is "readable".
</li>
	<li>
<p>
~IF［
%controller.`queueTotalSize^sl ~EQ 0
］~AND［
%controller.`closeRequested^sl ~EQ ~T
］：
◎
If controller.[[queueTotalSize]] is 0 and controller.[[closeRequested]] is true,
</p>
		<ol>
			<li>
~NOABRUPT `ReadableByteStreamControllerClearAlgorithms$A( %controller )
◎
Perform ! ReadableByteStreamControllerClearAlgorithms(controller).
</li>
			<li>
~NOABRUPT `ReadableStreamClose$A( %controller.`controlledReadableStream^sl )
◎
Perform ! ReadableStreamClose(controller.[[controlledReadableStream]]).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerInvalidateBYOBRequest(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerInvalidateBYOBRequest(controller) performs the following steps:
</p>
<ol>
	<li>
~IF［
%controller.`byobRequest^sl ~EQ ~NULL
］
⇒
~RET
◎
If controller.[[byobRequest]] is null, return.
</li>
	<li>
%controller.`byobRequest^sl.`controller^sl ~SET `undefined^jv
◎
Set controller.[[byobRequest]].[[controller]] to undefined.
</li>
	<li>
%controller.`byobRequest^sl.`view^sl ~SET ~NULL
◎
Set controller.[[byobRequest]].[[view]] to null.
</li>
	<li>
%controller.`byobRequest^sl ~SET ~NULL
◎
Set controller.[[byobRequest]] to null.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%controller.`closeRequested^sl ~EQ ~F
◎
Assert: controller.[[closeRequested]] is false.
</li>
	<li>
<p>
~WHILE［
%controller.`pendingPullIntos^sl は`空$でない
］：
◎
While controller.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
~IF［
%controller.`queueTotalSize^sl ~EQ 0
］
⇒
~RET
◎
If controller.[[queueTotalSize]] is 0, return.
</li>
			<li>
%pullIntoDescriptor ~LET %controller.`pendingPullIntos^sl[0]
◎
Let pullIntoDescriptor be controller.[[pendingPullIntos]][0].
</li>
			<li>
<p>
~IF［
~NOABRUPT `ReadableByteStreamControllerFillPullIntoDescriptorFromQueue$A( %controller, %pullIntoDescriptor ) ~EQ ~T
］：
◎
If ! ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) is true,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableByteStreamControllerShiftPendingPullInto$A( %controller )
◎
Perform ! ReadableByteStreamControllerShiftPendingPullInto(controller).
</li>
					<li>
~NOABRUPT `ReadableByteStreamControllerCommitPullIntoDescriptor$A( %controller.`controlledReadableStream^sl, %pullIntoDescriptor)
◎
Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(controller.[[controlledReadableStream]], pullIntoDescriptor).
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerPullInto(controller, view, readIntoRequest)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%elementSizem ~LET 1
◎
Let elementSize be 1.
</li>
	<li>
%ctor ~LET `DataView$jI
◎
Let ctor be %DataView%.
</li>
	<li>
~IF［
%view は `TypedArrayName^sl 内部~slotを持つ（すなわち， `DataView$I ではない）
］
⇒
( %elementSizem, %ctor ) ~SET
<a href="~TC39#sec-dataview-objects">有型~配列 構築子 table</a>
に指定される，
%view.`TypedArrayName^sl 用の ( 要素~size, 構築子 )
◎
If view has a [[TypedArrayName]] internal slot (i.e., it is not a DataView),
◎
Set elementSize to the element size specified in the typed array constructors table for view.[[TypedArrayName]].
◎
Set ctor to the constructor specified in the typed array constructors table for view.[[TypedArrayName]].
</li>
	<li>
%byteOffset ~LET %view.`ByteOffset^sl
◎
Let byteOffset be view.[[ByteOffset]].
</li>
	<li>
%byteLength ~LET %view.`ByteLength^sl
◎
Let byteLength be view.[[ByteLength]].
</li>
	<li>
%buffer ~LET
~NOABRUPT `TransferArrayBuffer$A( %view.`ViewedArrayBuffer^sl )
◎
Let buffer be ! TransferArrayBuffer(view.[[ViewedArrayBuffer]]).
</li>
	<li>
%pullIntoDescriptor ~LET 次を伴う，新たな`~pull~into記述子$
⇒＃
`~buffer$pD ~SET %buffer,
`~byte~offset$pD ~SET %byteOffset,
`~byte長さ$pD ~SET %byteLength,
`~fill済み~byte数$pD ~SET 0,
`要素~size$pD ~SET %elementSize,
`~view構築子$pD ~SET %ctor,
`読取器~型$pD ~SET `byob^l
◎
Let pullIntoDescriptor be a new pull-into descriptor with buffer buffer, byte offset byteOffset, byte length byteLength, bytes filled 0, element size elementSize, view constructor ctor, and reader type "byob".
</li>
	<li>
<p>
~IF［
%controller.`pendingPullIntos^sl は空でない
］：
◎
If controller.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%controller.`pendingPullIntos^sl に %pullIntoDescriptor を`付加する$
◎
Append pullIntoDescriptor to controller.[[pendingPullIntos]].
</li>
			<li>
~NOABRUPT `ReadableStreamAddReadIntoRequest$A( %stream, %readIntoRequest )
◎
Perform ! ReadableStreamAddReadIntoRequest(stream, readIntoRequest).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%stream.`state^sl ~EQ `closed^l
］：
◎
If stream.[[state]] is "closed",
</p>
		<ol>
			<li>
%emptyView ~LET
~NOABRUPT `Construct$Ax( %ctor, « %pullIntoDescriptor の`~buffer$pD, %pullIntoDescriptor の`~byte~offset$pD, 0 » )
◎
Let emptyView be ! Construct(ctor, « pullIntoDescriptor’s buffer, pullIntoDescriptor’s byte offset, 0 »).
</li>
			<li>
%readIntoRequest の`~close手続き$riR( %emptyView )
◎
Perform readIntoRequest’s close steps, given emptyView.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%controller.`queueTotalSize^sl ~GT 0
］：
◎
If controller.[[queueTotalSize]] &gt; 0,
</p>
		<ol>
			<li>
<p>
~IF［
~NOABRUPT `ReadableByteStreamControllerFillPullIntoDescriptorFromQueue$A( %controller, %pullIntoDescriptor ) ~EQ ~T
］：
◎
If ! ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) is true,
</p>
				<ol>
					<li>
%filledView ~LET
~NOABRUPT `ReadableByteStreamControllerConvertPullIntoDescriptor$A( %pullIntoDescriptor )
◎
Let filledView be ! ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor).
</li>
					<li>
~NOABRUPT `ReadableByteStreamControllerHandleQueueDrain$A( %controller )
◎
Perform ! ReadableByteStreamControllerHandleQueueDrain(controller).
</li>
					<li>
%readIntoRequest の`~chunk手続き$riR( %filledView )
◎
Perform readIntoRequest’s chunk steps, given filledView.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%controller.`closeRequested^sl ~EQ ~T
］：
◎
If controller.[[closeRequested]] is true,
</p>
				<ol>
					<li>
%e ~LET `TypeError^jE 例外
◎
Let e be a TypeError exception.
</li>
					<li>
~NOABRUPT `ReadableByteStreamControllerError$A( %controller, %e )
◎
Perform ! ReadableByteStreamControllerError(controller, e).
</li>
					<li>
%readIntoRequest の`~error手続き$riR( %e )
◎
Perform readIntoRequest’s error steps, given e.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%controller.`pendingPullIntos^sl に %pullIntoDescriptor を`付加する$
◎
Append pullIntoDescriptor to controller.[[pendingPullIntos]].
</li>
	<li>
~NOABRUPT `ReadableStreamAddReadIntoRequest$A( %stream, %readIntoRequest )
◎
Perform ! ReadableStreamAddReadIntoRequest(stream, readIntoRequest).
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerRespond(controller, bytesWritten)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerRespond(controller, bytesWritten) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%controller.`pendingPullIntos^sl は空でない
◎
Assert: controller.[[pendingPullIntos]] is not empty.
</li>
	<li>
~ABRUPT `ReadableByteStreamControllerRespondInternal$A( %controller, %bytesWritten )
◎
Perform ? ReadableByteStreamControllerRespondInternal(controller, bytesWritten).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) performs the following steps:
</p>
<ol>
	<li>
%firstDescriptor の`~buffer$pD ~SET
~NOABRUPT `TransferArrayBuffer$A( %firstDescriptor の`~buffer$pD )
◎
Set firstDescriptor’s buffer to ! TransferArrayBuffer(firstDescriptor’s buffer).
</li>
	<li>
~Assert：
%firstDescriptor の`~fill済み~byte数$pD ~EQ 0
◎
Assert: firstDescriptor’s bytes filled is 0.
</li>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
<p>
~IF［
~NOABRUPT `ReadableStreamHasBYOBReader$A( %stream ) ~EQ ~T
］：
◎
If ! ReadableStreamHasBYOBReader(stream) is true,
</p>
		<ol>
			<li>
<p>
~WHILE［
~NOABRUPT `ReadableStreamGetNumReadIntoRequests$A( %stream ) ~GT 0
］：
◎
While ! ReadableStreamGetNumReadIntoRequests(stream) &gt; 0,
</p>
				<ol>
					<li>
%pullIntoDescriptor ~LET
~NOABRUPT `ReadableByteStreamControllerShiftPendingPullInto$A( %controller )
◎
Let pullIntoDescriptor be ! ReadableByteStreamControllerShiftPendingPullInto(controller).
</li>
					<li>
~NOABRUPT `ReadableByteStreamControllerCommitPullIntoDescriptor$A( %stream, %pullIntoDescriptor)
◎
Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor).
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) performs the following steps:
</p>
<ol>
	<li>
~IF［
( %pullIntoDescriptor の`~fill済み~byte数$pD ~PLUS %bytesWritten ) ~GT
%pullIntoDescriptor の`~byte長さ$pD
］
⇒
~THROW `RangeError$E
◎
If pullIntoDescriptor’s bytes filled + bytesWritten &gt; pullIntoDescriptor’s byte length, throw a RangeError exception.
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerFillHeadPullIntoDescriptor$A( %controller, %bytesWritten, %pullIntoDescriptor )
◎
Perform ! ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor).
</li>
	<li>
~IF［
%pullIntoDescriptor の`~fill済み~byte数$pD ~LT %pullIntoDescriptor の`要素~size$pD
］
⇒
~RET
◎
If pullIntoDescriptor’s bytes filled &lt; pullIntoDescriptor’s element size, return.
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerShiftPendingPullInto$A( %controller )
◎
Perform ! ReadableByteStreamControllerShiftPendingPullInto(controller).
</li>
	<li>
%remainderSize ~LET
( %pullIntoDescriptor の`~fill済み~byte数$pD `mod^op %pullIntoDescriptor の`要素~size$pD )
◎
Let remainderSize be pullIntoDescriptor’s bytes filled mod pullIntoDescriptor’s element size.
</li>
	<li>
<p>
~IF［
%remainderSize ~GT 0
］：
◎
If remainderSize &gt; 0,
</p>
		<ol>
			<li>
%end ~LET
( %pullIntoDescriptor の`~byte~offset$pD ~PLUS %pullIntoDescriptor の`~fill済み~byte数$pD )
◎
Let end be pullIntoDescriptor’s byte offset + pullIntoDescriptor’s bytes filled.
</li>
			<li>
%remainder ~LET
~ABRUPT `CloneArrayBuffer$Ax( %pullIntoDescriptor の`~buffer$pD, ( %end ~MINUS %remainderSize ), %remainderSize, `ArrayBuffer$jI )
◎
Let remainder be ? CloneArrayBuffer(pullIntoDescriptor’s buffer, end − remainderSize, remainderSize, %ArrayBuffer%).
</li>
			<li>
~NOABRUPT `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %remainder, 0, %remainder.`ByteLength^sl )
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.[[ByteLength]]).
</li>
		</ol>
	</li>
	<li>
%pullIntoDescriptor の`~buffer$pD ~SET
~NOABRUPT `TransferArrayBuffer$A( %pullIntoDescriptor の`~buffer$pD )
◎
Set pullIntoDescriptor’s buffer to ! TransferArrayBuffer(pullIntoDescriptor’s buffer).
</li>
	<li>
%pullIntoDescriptor の`~fill済み~byte数$pD ~SET
%pullIntoDescriptor の`~fill済み~byte数$pD ~MINUS %remainderSize
◎
Set pullIntoDescriptor’s bytes filled to pullIntoDescriptor’s bytes filled − remainderSize.
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerCommitPullIntoDescriptor$A( %controller.`controlledReadableStream^sl, %pullIntoDescriptor )
◎
Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(controller.[[controlledReadableStream]], pullIntoDescriptor).
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue$A( %controller )
◎
Perform ! ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerRespondInternal(controller, bytesWritten)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerRespondInternal(controller, bytesWritten) performs the following steps:
</p>
<ol>
	<li>
%firstDescriptor ~LET %controller.`pendingPullIntos^sl[0]
◎
Let firstDescriptor be controller.[[pendingPullIntos]][0].
</li>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
<p>
~IF［
%stream.`state^sl ~EQ `closed^l
］：
◎
If stream.[[state]] is "closed",
</p>
		<ol>
			<li>
~IF［
%bytesWritten ~NEQ 0
］
⇒
~THROW `TypeError^jE
◎
If bytesWritten is not 0, throw a TypeError exception.
</li>
			<li>
~NOABRUPT `ReadableByteStreamControllerRespondInClosedState$A( %controller, %firstDescriptor )
◎
Perform ! ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%stream.`state^sl ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
			<li>
~ABRUPT `ReadableByteStreamControllerRespondInReadableState$A( %controller, %bytesWritten, %firstDescriptor )
◎
Perform ? ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor).
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerRespondWithNewView(controller, view)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerRespondWithNewView(controller, view) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%controller.`pendingPullIntos^sl は`空$でない
◎
Assert: controller.[[pendingPullIntos]] is not empty.
</li>
	<li>
%firstDescriptor ~LET %controller.`pendingPullIntos^sl[0]
◎
Let firstDescriptor be controller.[[pendingPullIntos]][0].
</li>
	<li>
~IF［
( %firstDescriptor の`~byte~offset$pD ~PLUS %firstDescriptor の`~fill済み~byte数$pD ) ~NEQ %view.`ByteOffset^sl
］
⇒
~THROW `RangeError$E
◎
If firstDescriptor’s byte offset + firstDescriptor’ bytes filled is not view.[[ByteOffset]], throw a RangeError exception.
</li>
	<li>
~IF［
%firstDescriptor の`~byte長さ$pD ~NEQ %view.`ByteLength^sl
］
⇒
~THROW `RangeError$E
◎
If firstDescriptor’s byte length is not view.[[ByteLength]], throw a RangeError exception.
</li>
	<li>
%firstDescriptor の`~buffer$pD ~SET %view.`ViewedArrayBuffer^sl
◎
Set firstDescriptor’s buffer to view.[[ViewedArrayBuffer]].
</li>
	<li>
~ABRUPT `ReadableByteStreamControllerRespondInternal$A( %controller, %view.`ByteLength^sl )
◎
Perform ? ReadableByteStreamControllerRespondInternal(controller, view.[[ByteLength]]).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerShiftPendingPullInto(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerShiftPendingPullInto(controller) performs the following steps:
</p>
<ol>
	<li>
%descriptor ~LET %controller.`pendingPullIntos^sl[0]
◎
Let descriptor be controller.[[pendingPullIntos]][0].
</li>
	<li>
%controller.`pendingPullIntos^sl から %descriptor を`除去する$
◎
Remove descriptor from controller.[[pendingPullIntos]].
</li>
	<li>
~NOABRUPT `ReadableByteStreamControllerInvalidateBYOBRequest$A( %controller )
◎
Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
</li>
	<li>
~RET %descriptor
◎
Return descriptor.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableByteStreamControllerShouldCallPull(controller)@A
は、次の手続きを遂行する：
◎
ReadableByteStreamControllerShouldCallPull(controller) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledReadableStream^sl
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
%stream.`state^sl ~NEQ `readable^l
］
⇒
~RET ~F
◎
If stream.[[state]] is not "readable", return false.
</li>
	<li>
~IF［
%controller.`closeRequested^sl ~EQ ~T
］
⇒
~RET ~F
◎
If controller.[[closeRequested]] is true, return false.
</li>
	<li>
~IF［
%controller.`started^sl ~EQ ~F
］
⇒
~RET ~F
◎
If controller.[[started]] is false, return false.
</li>
	<li>
~IF［
~NOABRUPT `ReadableStreamHasDefaultReader$A( %stream ) ~EQ ~T
］~AND［
~NOABRUPT `ReadableStreamGetNumReadRequests$A( %stream ) ~GT 0
］
⇒
~RET ~T
◎
If ! ReadableStreamHasDefaultReader(stream) is true and ! ReadableStreamGetNumReadRequests(stream) &gt; 0, return true.
</li>
	<li>
~IF［
~NOABRUPT `ReadableStreamHasBYOBReader$A( %stream ) ~EQ ~T
］~AND［
~NOABRUPT `ReadableStreamGetNumReadIntoRequests$A( %stream ) ~GT 0
］
⇒
~RET ~T
◎
If ! ReadableStreamHasBYOBReader(stream) is true and ! ReadableStreamGetNumReadIntoRequests(stream) &gt; 0, return true.
</li>
	<li>
%desiredSize ~LET
~NOABRUPT `ReadableByteStreamControllerGetDesiredSize$A( %controller )
◎
Let desiredSize be ! ReadableByteStreamControllerGetDesiredSize(controller).
</li>
	<li>
~Assert：
%desiredSize ~NEQ ~NULL
◎
Assert: desiredSize is not null.
</li>
	<li>
~IF［
%desiredSize ~GT 0
］
⇒
~RET ~T
◎
If desiredSize &gt; 0, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize)@A
は、次の手続きを遂行する：
◎
SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`readableStreamController^sl ~EQ `undefined^jv
◎
Assert: stream.[[readableStreamController]] is undefined.
</li>
	<li>
<p>
~IF［
%autoAllocateChunkSize ~NEQ `undefined^jv
］：
◎
If autoAllocateChunkSize is not undefined,
</p>
		<ol>
			<li>
~Assert：
~NOABRUPT `IsInteger$Ax( %autoAllocateChunkSize ) ~EQ ~T
◎
Assert: ! IsInteger(autoAllocateChunkSize) is true.
</li>
			<li>
~Assert：
%autoAllocateChunkSize ~GT 0
◎
Assert: autoAllocateChunkSize is positive.
</li>
		</ol>
	</li>
	<li>
%controller の
⇒＃
.`controlledReadableStream^sl ~SET %stream
.`pullAgain^sl ~SET ~F,
.`pulling^sl ~SET ~F,
.`byobRequest^sl ~SET ~NULL
◎
Set controller.[[controlledReadableStream]] to stream.
◎
Set controller.[[pullAgain]] and controller.[[pulling]] to false.
◎
Set controller.[[byobRequest]] to null.
</li>
	<li>
~NOABRUPT `ResetQueue$A( %controller )
◎
Perform ! ResetQueue(controller).
</li>
	<li>
%controller の
⇒＃
.`closeRequested^sl ~SET ~F,
.`started^sl ~SET ~F,
.`strategyHWM^sl ~SET %highWaterMark,
.`pullAlgorithm^sl ~SET %pullAlgorithm,
.`cancelAlgorithm^sl ~SET %cancelAlgorithm,
.`autoAllocateChunkSize^sl ~SET %autoAllocateChunkSize,
.`pendingPullIntos^sl ~SET 新たな空`~list$
◎
Set controller.[[closeRequested]] and controller.[[started]] to false.
◎
Set controller.[[strategyHWM]] to highWaterMark.
◎
Set controller.[[pullAlgorithm]] to pullAlgorithm.
◎
Set controller.[[cancelAlgorithm]] to cancelAlgorithm.
◎
Set controller.[[autoAllocateChunkSize]] to autoAllocateChunkSize.
◎
Set controller.[[pendingPullIntos]] to a new empty list.
</li>
	<li>
%stream.`readableStreamController^sl ~SET %controller
◎
Set stream.[[readableStreamController]] to controller.
</li>
	<li>
%startResult ~LET %startAlgorithm()
◎
Let startResult be the result of performing startAlgorithm.
</li>
	<li>
<p>
%startPromise ~LET %startResult で`解決される~promise$
◎
Let startPromise be a promise resolved with startResult.
</p>
		<ul>
			<li>
<p>
%startPromise の`充足-時$には：
◎
Upon fulfillment of startPromise,
</p>
				<ol>
					<li>
%controller.`started^sl ~SET ~T
◎
Set controller.[[started]] to true.
</li>
					<li>
~Assert：
%controller.`pulling^sl ~EQ ~F
◎
Assert: controller.[[pulling]] is false.
</li>
					<li>
~Assert：
%controller.`pullAgain^sl ~EQ ~F
◎
Assert: controller.[[pullAgain]] is false.
</li>
					<li>
~NOABRUPT `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r による %startPromise の`却下-時$には：
◎
Upon rejection of startPromise with reason r,
</p>
				<ol>
					<li>
~NOABRUPT `ReadableByteStreamControllerError$A( %controller, %r )
◎
Perform ! ReadableByteStreamControllerError(controller, r).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingSource, underlyingSourceDict, highWaterMark)@A
は、次の手続きを遂行する：
◎
SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingSource, underlyingSourceDict, highWaterMark) performs the following steps:
</p>
<ol>
	<li>
%controller ~LET `新たな$ `ReadableByteStreamController$I
◎
Let controller be a new ReadableByteStreamController.
</li>
	<li>
%startAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv
◎
Let startAlgorithm be an algorithm that returns undefined.
</li>
	<li>
%pullAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let pullAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
%cancelAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let cancelAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
~IF［
%underlyingSourceDict[ "`start$usc" ] ~NEQ ε
］
⇒
%startAlgorithm ~SET 次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSourceDict[ "`start$usc" ], « %controller », %underlyingSource )
◎
If underlyingSourceDict["start"] exists, then set startAlgorithm to an algorithm which returns the result of invoking underlyingSourceDict["start"] with argument list « controller » and callback this value underlyingSource.
</li>
	<li>
~IF［
%underlyingSourceDict[ "`pull$usc" ] ~NEQ ε
］
⇒
%pullAlgorithm ~SET 次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSourceDict[ "`pull$usc" ], « %controller », %underlyingSource )
◎
If underlyingSourceDict["pull"] exists, then set pullAlgorithm to an algorithm which returns the result of invoking underlyingSourceDict["pull"] with argument list « controller » and callback this value underlyingSource.
</li>
	<li>
~IF［
%underlyingSourceDict[ "`cancel$usc" ] ~NEQ ε
］
⇒
%cancelAlgorithm ~SET 所与の ( %reason ) に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSourceDict[ "`cancel$usc" ], « %reason », %underlyingSource )
◎
If underlyingSourceDict["cancel"] exists, then set cancelAlgorithm to an algorithm which takes an argument reason and returns the result of invoking underlyingSourceDict["cancel"] with argument list « reason » and callback this value underlyingSource.
</li>
	<li>
%autoAllocateChunkSize ~LET %underlyingSourceDict[ "`autoAllocateChunkSize$usc" ]
◎
Let autoAllocateChunkSize be underlyingSourceDict["autoAllocateChunkSize"], if it exists,＼
</li>
	<li>
~IF［
%autoAllocateChunkSize ~EQ ε
］
⇒
%autoAllocateChunkSize ~SET `undefined^jv
◎
or undefined otherwise.
</li>
	<li>
~ABRUPT `SetUpReadableByteStreamController$A( %stream, %controller, %startAlgorithm, %pullAlgorithm, %cancelAlgorithm, %highWaterMark, %autoAllocateChunkSize )
◎
Perform ? SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize).
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="ws">
<h2 title="Writable streams">5. 可書~stream</h2>

		<section id="ws-intro">
<h3 title="Using writable streams">5.1. 可書~streamの利用-法</h3>

<div class="example" id="example-basic-pipe-to-2">

<p>
`可読~stream$へ書込する通例の仕方は、単純に，可読~streamをそれに`~pipeする$ことである。
これにより、その`背圧$が尊重されるようになる
— 可書~streamの`下層~槽$が，可読~streamが生産できるほど高速に~dataを受容できない場合に、可読~streamにその旨が伝わり，その~data生産を減速させる機会を得られるようになる。
◎
The usual way to write to a writable stream is to simply pipe a readable stream to it. This ensures that backpressure is respected, so that if the writable stream’s underlying sink is not able to accept data as fast as the readable stream can produce it, the readable stream is informed of this and has a chance to slow down its data production.
</p>

<pre class="lang-js">
readableStream.pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>
<!-- 
"All data successfully written!"
"Something went wrong!"
 -->
</div>

<div class="example" id="example-manual-write-batch">

<p>
`書込器$を獲得して，その
`write()$dw ／ `close()$dw
~methodを利用すれば、可書~streamに直に書込することもできる。
それらは、［
流入~書込nを，~queueした上で`下層~槽$へ順に回送する
］ことを，内部的に手入れするので、手間をかけず無差別的に，可書~streamへ書込できる：
◎
You can also write directly to writable streams by acquiring a writer and using its write() and close() methods. Since writable streams queue any incoming writes, and take care internally to forward them to the underlying sink in sequence, you can indiscriminately write to a writable stream without much ceremony:
</p>

<pre class="lang-js">
function writeArrayToStream(%array, %writableStream) {
  const %writer = %writableStream.getWriter();
  %array.forEach(%chunk =&gt; %writer.write(%chunk).catch(() =&gt; {}));

  return %writer.close();
}

writeArrayToStream([1, 2, 3, 4, 5], %writableStream)
  .then(() =&gt; console.log(`すべて済みました^l))
  .catch(%e =&gt; console.error(`~streamに~errorが生じました: ^l + %e));
</pre>

<p>
`.catch(() =&gt; {})^c を利用して， `write()$dw ~methodからの却下を抑止していることに注意
— 致命的~errorは， `close()$dw ~methodの却下を介して通知されることになり、~catchせずに放った場合［
`unhandledrejection$et ~event ／ ~consoleに警告
］を生じさせ得る。
◎
Note how we use .catch(() =&gt; {}) to suppress any rejections from the write() method; we’ll be notified of any fatal errors via a rejection of the close() method, and leaving them un-caught would cause potential unhandledrejection events and console warnings.
</p>

</div>

<div class="example" id="example-manual-write-with-error-handling">

<p>
これまでの例では、書込器（ %writer ）の `close()$dw ~methodから返された~promiseを見ることで，~stream全体の成否についてのみに注目していた。
その~promiseは、~streamにて
— その初期化-時, それへの書込み時, その~close時にて —
何らかの不具合が生じたときに却下されることになり、また，~streamが成功裡に~closeされたなら 充足されることになる。
多くの場合、これについて~careしておけば済む。
◎
In the previous example we only paid attention to the success or failure of the entire stream, by looking at the promise returned by the writer’s close() method. That promise will reject if anything goes wrong with the stream—initializing it, writing to it, or closing it. And it will fulfill once the stream is successfully closed. Often this is all you care about.
</p>

<p>
が、特定の`~chunk$に対し，書込みの成功について~careする場合は、書込器の `write()$dw ~methodから返される~promiseを利用できる：
◎
However, if you care about the success of writing a specific chunk, you can use the promise returned by the writer’s write() method:
</p>

<pre class="lang-js">
%writer.write(`~data内のある~chunk^l)
  .then(() =&gt; console.log(`~chunkは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(%e));
</pre>
<!-- 
"i am a chunk of data"
"chunk successfully written!"
-->

<p>
“成功” が何を意味するかは、所与の~stream~instance（より精確には, その`下層~槽$）が裁定する。
例えば，~file~streamに対してなら、単純に~OSが書込nを受容したことを意味し，`~chunk$を~diskへ書出すことは必要とされないであろう。
そのような通達を与える~~能が全くない~streamもあるかもしれない
— その事例では、返される~promiseは即時に充足されることになる。
◎
What "success" means is up to a given stream instance (or more precisely, its underlying sink) to decide. For example, for a file stream it could simply mean that the OS has accepted the write, and not necessarily that the chunk has been flushed to disk. Some streams might not be able to give such a signal at all, in which case the returned promise will fulfill immediately.
</p>
</div>

<div class="example" id="example-manual-write-with-backpressure">

<p>
`書込器$の［
`desiredSize$dw, `ready$dw
］~propにより、`生産器$は，~streamからの流れ制御の通達に より精確に応答して，記憶域の使用量を ~streamに指定された`限界水位$より下に保ち続けれるようになる。
次の例は、無限に続く~randomな~byte列を~streamに書込する
— その際に、 `desiredSize$dw を利用して，所与の時点に何~byte生成するかを決定し、 `ready$dw を利用して，`背圧$が収まるまで待機する。
◎
The desiredSize and ready properties of writable stream writers allow producers to more precisely respond to flow control signals from the stream, to keep memory usage below the stream’s specified high water mark. The following example writes an infinite sequence of random bytes to a stream, using desiredSize to determine how many bytes to generate at a given time, and using ready to wait for the backpressure to subside.
</p>

<pre class="lang-js">
async function writeRandomBytesForever(%writableStream) {
  const %writer = %writableStream.getWriter();

  while (true) {
    await %writer.ready;

    const %bytes = new Uint8Array(%writer.desiredSize);
    crypto.getRandomValues(%bytes);

    /* <span class="comment">
次では、目的をもって `await^c しない
—
<code>%writer.ready</code>
を `await^c するので十分なので。
◎
Purposefully don’t await; awaiting writer.ready is enough.
</span> */
    %writer.write(%bytes).catch(() => {});
  }
}

writeRandomBytesForever(myWritableStream).catch(
    e =&gt; console.error(`何か不具合が生じたようです^l, e)
);
</pre>
<!--
"Something broke"
 -->

<p>
`write()$dw から返される~promiseを `await^c していないことに注意
— それは、 `ready$dw ~promiseを `await^c するのと~~重複するので。
加えて，<a href="#example-manual-write-batch">以前の例</a>と同様に、
`write()$dw から返される~promiseに対しては， `.catch(() =&gt; {})^c ~patternも利用している
— この事例では、どの失敗も `ready$dw ~promiseを `await^c するときに通知されるので。
◎
Note how we don’t await the promise returned by write(); this would be redundant with awaiting the ready promise. Additionally, similar to a previous example, we use the .catch(() =&gt; {}) pattern on the promises returned by write(); in this case we’ll be notified about any failures awaiting the ready promise.
</p>

</div>

<div class="example" id="example-manual-write-dont-await">

<p>
`write()$dw から返される~promiseを `await^c するのが，どうして不良な案になるのか、もっとはっきりさせるため，上の例の改変を考える
— そこでも、 `WritableStreamDefaultWriter$I ~interfaceは直に利用し続けるが，所与の時点で書込する~byte数は制御しない。
その事例でも、`背圧$を尊重している~codeは同じようになる：
◎
To further emphasize how it’s a bad idea to await the promise returned by write(), consider a modification of the above example, where we continue to use the WritableStreamDefaultWriter interface directly, but we don’t control how many bytes we have to write at a given time. In that case, the backpressure-respecting code looks the same:
</p>

<pre class="lang-js">
async function writeSuppliedBytesForever(%writableStream, %getBytes) {
  const %writer = %writableStream.getWriter();

  while (true) {
    await %writer.ready;

    const %bytes = %getBytes();
    %writer.write(%bytes).catch(() =&gt; {});
  }
}
</pre>

<p>
以前の例では、毎回~常に，正確に
<code>%writer.`desiredSize$dw</code>
個の~byteを書込していたので，［
`write()$dw が返す~promise,
`ready$dw ~promise
］は同期していたが、この事例では、前者の前に後者の~promiseが充足されることも，ごく~~普通にあり得る。
`ready$dw ~promiseは、［
`~streamの内部~queueの残り~size$ ~GT 0
］になったとき，充足されることに注意
— それは，書込nが成功する前になるかもしれない（とりわけ、`限界水位$が高い事例では）。
◎
Unlike the previous example, where—because we were always writing exactly writer.desiredSize bytes each time—the write() and ready promises were synchronized, in this case it’s quite possible that the ready promise fulfills before the one returned by write() does. Remember, the ready promise fulfills when the desired size becomes positive, which might be before the write succeeds (especially in cases with a larger high water mark).
</p>

<p>
言い換えれば、 `write()$dw の返り値を `await^c することは、［
~streamの`内部~queue$内には，書込nは決して~queueしておかれない代わりに、以前の書込nが成功した後に限り，書込nを実行する
］ことを意味する
— その結果、時間あたりの流量は低下し得る。
◎
In other words, awaiting the return value of write() means you never queue up writes in the stream’s internal queue, instead only executing a write after the previous one succeeds, which can result in low throughput.
</p>

</div>

		</section>
		<section id="ws-class">
<h3 title="The WritableStream class">5.2. `WritableStream^I ~class</h3>

<p>
`WritableStream$I は、`可書~stream$を表現する。
◎
The WritableStream represents a writable stream.
</p>

			<section id="ws-class-definition">
<h4 title="Interface definition">5.2.1. ~interface定義</h4>

<p>
`WritableStream$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the WritableStream class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `WritableStream@I {
  `WritableStream$mc(optional `object$ %underlyingSink, optional `QueuingStrategy$I %strategy = {});

  readonly attribute `boolean$ `locked$ws;

  Promise&lt;void&gt; `abort$ws(optional any %reason);
  Promise&lt;void&gt; `close$ws();
  `WritableStreamDefaultWriter$I `getWriter$ws();
};
</pre>

			</section>
			<section id="ws-internal-slots">
<h4 title="Internal slots">5.2.2. 内部~slot</h4>

<p>
`WritableStream$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of WritableStream are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`backpressure^sl
<td>
制御器により設定される~背圧~通達を指示する真偽値
◎
A boolean indicating the backpressure signal set by the controller

<tr><td>`closeRequest^sl
<td>
書込器の `close()$dw ~methodから~返される~promise
◎
The promise returned from the writer’s close() method

<tr><td>`inFlightWriteRequest^sl
<td>
この~slotは、`下層~槽$の書込n~algoが まだ実行-中で充足されていない間に，現在の~in-flight 【“~~処理中にある”】書込n演算~用の~promiseに設定される。
これは、再入~callを防止するために利用される。
◎
A slot set to the promise for the current in-flight write operation while the underlying sink's write algorithm is executing and has not yet fulfilled, used to prevent reentrant calls

<tr><td>`inFlightCloseRequest^sl
<td>
この~slotは、`下層~槽$の `close()^m ~methodが まだ~実行-中で~充足されていない間に，現在の~in-flight~close~algo用の~promiseに設定される。
これは、 `abort()$dw ~methodにより~closeが中断されるのを防止するために利用される。
◎
A slot set to the promise for the current in-flight close operation while the underlying sink's close algorithm is executing and has not yet fulfilled, used to prevent the abort() method from interrupting close

<tr><td>`pendingAbortRequest^sl
<td>
`処理待ち中止-要請$
◎
A pending abort request

<tr><td>`state^sl
<td>
内部に利用される ~streamの現在の状態を包含している文字列
— 次のいずれか
⇒
`writable^l,
`closed^l,
`erroring^l,
`errored^l
◎
A string containing the stream’s current state, used internally; one of "writable", "closed", "erroring", or "errored"

<tr><td>`storedError^sl
<td>
~streamが どのように失敗したかを指示する値
— ［
`errored^l 状態にある~stream上に演算しようと試行している
］ときに、失敗~事由か例外として与えられることになる。
◎
A value indicating how the stream failed, to be given as a failure reason or exception when trying to operate on the stream while in the "errored" state

<tr><td>`writableStreamController^sl
<td>
［
この~streamの状態と~queueを制御する能
］を伴って作成される `WritableStreamDefaultController$I 。
◎
A WritableStreamDefaultController created with the ability to control the state and queue of this stream

<tr><td>`writer^sl
<td>
~streamが書込器に`~lockされて$［
いるならば `WritableStreamDefaultWriter$I の~instance ／
いないならば `undefined^jv
］。
◎
A WritableStreamDefaultWriter instance, if the stream is locked to a writer, or undefined if it is not

<tr><td>`writeRequests^sl
<td>
一連の［
`下層~槽$がまだ処理していない書込n要請に対する~promise
］からなる，~streamの内部~queueを表現する`~list$。
◎
A list of promises representing the stream’s internal queue of write requests not yet processed by the underlying sink

</tbody></table>

<p class="note">注記：
`inFlightCloseRequest^sl ~slot,
`closeRequest^sl ~slotは、互いに排他的である。
また、［
`inFlightWriteRequest^sl ~NEQ `undefined^jv
］の間に `writeRequests^sl から要素が除去されることはない。
実装は、これらの不変則に基づいて これらの~slot用の~storageを最適化できる。
◎
The [[inFlightCloseRequest]] slot and [[closeRequest]] slot are mutually exclusive. Similarly, no element will be removed from [[writeRequests]] while [[inFlightWriteRequest]] is not undefined. Implementations can optimize storage for these slots based on these invariants.
</p>

<p>
`処理待ち中止-要請@
は、~streamを中止する要請を その処理に入るまで追跡するために利用される`構造体$であり、次に挙げる`~item$sctからなる：
◎
A pending abort request is a struct used to track a request to abort the stream before that request is finally processed. It has the following items:
</p>

<dl class="def-list">
	<dt>
`~promise@aR
◎
promise
</dt>
	<dd>
`WritableStreamAbort()$A から返された~promise。
◎
A promise returned from WritableStreamAbort
</dd>

	<dt>
`事由@aR
◎
reason
</dt>
	<dd>
中止-事由として `WritableStreamAbort()$A に渡された~JS値
◎
A JavaScript value that was passed as the abort reason to WritableStreamAbort
</dd>

	<dt>
`すでに~errorした@aR
◎
was already erroring
</dt>
	<dd>
`WritableStreamAbort()$A を~callした時点で、当の~streamは `erroring^l 状態にあったかどうかを指示する真偽値
— それは、中止-要請の成り行きに影響iする。
◎
A boolean indicating whether or not the stream was in the "erroring" state when WritableStreamAbort was called, which impacts the outcome of the abort request
</dd>
</dl>

			</section>
			<section id="underlying-sink-api">
<h4 title="The underlying sink API">5.2.3. 下層~槽~API</h4>

<p>
`new WritableStream()$m
構築子は、 1 個目の引数に［
`下層~槽$を表現している~JS~obj
］を受容する。
そのような~objには、次に挙げる~propを包含させ得る：
◎
The WritableStream() constructor accepts as its first argument a JavaScript object representing the underlying sink. Such objects can contain any of the following properties:
</p>

<pre class="idl">
dictionary `UnderlyingSink@I {
  `UnderlyingSinkStartCallback$I `start$usk;
  `UnderlyingSinkWriteCallback$I `write$usk;
  `UnderlyingSinkCloseCallback$I `close$usk;
  `UnderlyingSinkAbortCallback$I `abort$usk;
  any `type$usk;
};

callback `UnderlyingSinkStartCallback@I = any (`WritableStreamDefaultController$I %controller);
callback `UnderlyingSinkWriteCallback@I = Promise&lt;void&gt; (any %chunk, `WritableStreamDefaultController$I %controller);
callback `UnderlyingSinkCloseCallback@I = Promise&lt;void&gt; ();
callback `UnderlyingSinkAbortCallback@I = Promise&lt;void&gt; (optional any %reason);
</pre>

<dl>
	<dt>
`start(controller)@usk
（ `UnderlyingSinkStartCallback$I 型）
◎
start(controller), of type UnderlyingSinkStartCallback
</dt>
	<dd>
この関数は、 `WritableStream$I を作成する間に即時に~callされる。
◎
A function that is called immediately during creation of the WritableStream.
</dd>
	<dd>
これは概して、資源が表現されている`下層~槽$への~accessを獲得するために利用される。
◎
Typically this is used to acquire access to the underlying sink resource being represented.
</dd>
	<dd>
ここで何かを設定しておく処理nが非同期的になる場合、この関数は，成否を通達する~promiseを返すようにすることもできる
⇒＃
却下される~promiseは、~streamを~errorにすることになる。
投出された例外は、
`new WritableStream()$m 構築子により投出し直されることになる。
◎
If this setup process is asynchronous, it can return a promise to signal success or failure; a rejected promise will error the stream. Any thrown exceptions will be re-thrown by the WritableStream() constructor.
</dd>

	<dt>
`write(chunk, controller)@usk
（ `UnderlyingSinkWriteCallback$I 型）
◎
write(chunk, controller), of type UnderlyingSinkWriteCallback
</dt>
	<dd>
この関数は、［
`下層~槽$へ書込される~dataを成す，新たな`~chunk$
］が準備済みになったときに~callされる。
~stream実装は、この関数が~callされるのは、以前の書込nが成功した後に限られ, かつ［
`start()$usk が成功する前 ／［
`close()$usk ／ `abort()$usk
］が~callされた後
］には決してならないことを保証する。
◎
A function that is called when a new chunk of data is ready to be written to the underlying sink. The stream implementation guarantees that this function will be called only after previous writes have succeeded, and never before start() has succeeded or after close() or abort() have been called.
</dd>
	<dd>
この関数は、`下層~槽$により呈示される資源に，実際に~dataを
— 例えば，より低~levelな~APIを~callして —
送信するために利用される。
◎
This function is used to actually send the data to the resource presented by the underlying sink, for example by calling a lower-level API.
</dd>
	<dd>
~dataを書込する処理nが非同期的になる場合、この関数は
— ~API利用者に成否の通達を通信するために —
成否を通達する~promiseを返すようにすることもでき、返された~promiseは，
<code>%writer.`write()$dw</code>
の~call元へ
— それが個々の書込nを監視できるよう —
通信されることになる。
例外を投出した場合、却下される~promiseを返すのと同じに扱われる。
◎
If the process of writing data is asynchronous, and communicates success or failure signals back to its user, then this function can return a promise to signal success or failure. This promise return value will be communicated back to the caller of writer.write(), so they can monitor that individual write. Throwing an exception is treated the same as returning a rejected promise.
</dd>
	<dd>
そのような通達は、常に可用になるとは限らないことに注意。
そのような事例では、何も返さないのが最良になる
— 次の 2 つを比較されたし
⇒＃
`背圧や成功の通達を伴わない可書~stream$sec,
`背圧や成功の通達を伴う可書~stream$sec
◎
Note that such signals are not always available; compare e.g. § 9.6 A writable stream with no backpressure or success signals with § 9.7 A writable stream with backpressure and success signals. In such cases, it’s best to not return anything.
</dd>
	<dd>
<p>
この関数が返す~promiseは、［
`~streamの内部~queueの残り~size$を算出する目的
］において，［
所与の~chunkを，書込されるに伴い数えるかどうか
］も統治し得る。
すなわち：
</p>
		<ul>
			<li>
<code>%writer.`desiredSize$dw</code>
は、~promiseが決着するまでの間は，以前の値であり続ける。
</li>
			<li>
もっと~chunkを欲することを通達するために増やされるのは、書込nが成功した場合に限られる。
</li>
		</ul>
◎
The promise potentially returned by this function also governs whether the given chunk counts as written for the purposes of computed the desired size to fill the stream’s internal queue. That is, during the time it takes the promise to settle, writer.desiredSize will stay at its previous value, only increasing to signal the desire for more chunks once the write succeeds.
</dd>

	<dt>
`close()@usk
（ `UnderlyingSinkCloseCallback$I 型）
◎
close(), of type UnderlyingSinkCloseCallback
</dt>
	<dd>
この関数は、`生産器$が
<code>%writer.`close()$dw</code>
を介して，次を通達した後に~callされる
⇒
生産器による，一連の`~chunk$の~streamへの書込みは済み、後続して，~queueしておかれた すべての書込nは成功裡に完了した
◎
A function that is called after the producer signals, via writer.close(), that they are done writing chunks to the stream, and subsequently all queued-up writes have successfully completed.
</dd>
	<dd>
次に必要とされる動作があれば、この関数~内で遂行できる
⇒＃
`下層~槽$への書込nを完結する／
`下層~槽$への書込nを書出す／
保持されている資源への~accessを解放する
◎
This function can perform any actions necessary to finalize or flush writes to the underlying sink, and release access to any held resources.
</dd>
	<dd>
<p>
この~shutdown処理nが非同期的になる場合、この関数は，成否を通達する~promiseを返すようにすることもできる：
</p>
		<ul>
			<li>
その結果は、
<code>%writer.`close()$dw</code>
~methodの返り値を介して，その~call元（生産器）へ通信されることになる。
</li>
			<li>
加えて，却下される~promiseは、~streamを
— そのまま成功裡に~closeさせずに —
~errorにすることになる。
</li>
		</ul>
<p>
例外を投出した場合、却下される~promiseを返すのと同じに扱われる。
</p>
◎
If the shutdown process is asynchronous, the function can return a promise to signal success or failure; the result will be communicated via the return value of the called writer.close() method. Additionally, a rejected promise will error the stream, instead of letting it close successfully. Throwing an exception is treated the same as returning a rejected promise.
</dd>

	<dt>
`abort(reason)@usk
（ `UnderlyingSinkAbortCallback$I 型）
◎
abort(reason), of type UnderlyingSinkAbortCallback
</dt>
	<dd>
この関数は、`生産器$が［
~streamを`中止-$したいと望む
］ことを
— ［
<code>%stream.`abort()$ws</code>
／
<code>%writer.`abort()$dw</code>
］を介して —
通達した後に~callされる。
その引数は、生産器がそれらの~methodに渡したのと同じ値をとる。
◎
A function that is called after the producer signals, via stream.abort() or writer.abort(), that they wish to abort the stream. It takes as its argument the same value as was passed to those methods by the producer.
</dd>
	<dd>
加えて，可書~streamは、`~pipeする$間に，一定の条件~下で中止されることもある
— 詳細は、 `pipeTo()$rs ~methodの定義を見よ。
◎
Writable streams can additionally be aborted under certain conditions during piping; see the definition of the pipeTo() method for more details.
</dd>
	<dd>
この関数は、保持されている資源があれば
— `close()$usk とほぼ同様に —
片付けれるが、たぶん何か~customな取扱いも伴われる。
◎
This function can clean up any held resources, much like close(), but perhaps with some custom handling.
</dd>
	<dd>
この~shutdown処理nが非同期的になる場合、この関数は，成否を通達する~promiseを返すようにすることもできる
— その結果は、
<code>%writer.`abort()$dw</code>
~methodの返り値を介して，その~call元（生産器）へ通信されることになる。
例外を投出した場合、却下される~promiseを返すのと同じに扱われる。
いずれにせよ、~streamは
— 中止されたことを指示する，新たな `TypeError$jE で —
~errorにされることになる。
◎
If the shutdown process is asynchronous, the function can return a promise to signal success or failure; the result will be communicated via the return value of the called writer.abort() method. Throwing an exception is treated the same as returning a rejected promise. Regardless, the stream will be errored with a new TypeError indicating that it was aborted.
</dd>

	<dt>
`type@usk
（ `any$I 型）
◎
type, of type any
</dt>
	<dd>
この~propは，将来の利用-用に予約されており、値を給するどの試みに対しても，例外を投出することになる。
◎
This property is reserved for future use, so any attempts to supply a value will throw an exception.
</dd>
</dl>

<p>
［
`start()$usk ／ `write()$usk
］に渡される %controller 引数は、 `WritableStreamDefaultController$I の~instanceであり，~streamを~errorにする能を備える。
これは主に、~promiseに基づかない~APIと橋渡しするために利用される。
その例は、`背圧や成功の通達を伴わない可書~stream$secに見れる。
◎
The controller argument passed to start() and write() is an instance of WritableStreamDefaultController, and has the ability to error the stream. This is mainly used for bridging the gap with non-promise-based APIs, as seen for example in § 9.6 A writable stream with no backpressure or success signals.
</p>

			</section>
			<section id="ws-prototype">
<h4 title="Constructor, methods, and properties">5.2.4. 構築子／~method／~prop</h4>

<dl class="domintro">
	<dt>%stream = `new WritableStream(underlyingSink[, strategy])$m</dt>
	<dd>
供された`下層~槽$を包装している新たな `WritableStream$I を作成する。
%underlyingSink 引数についての詳細は、`下層~槽~API$secを見よ。
◎
Creates a new WritableStream wrapping the provided underlying sink. See § 5.2.3 The underlying sink API for more details on the underlyingSink argument.
</dd>
	<dd>
%strategy 引数は
— `~queuing策~API$secにて述べるように —
~streamの`~queuing策$を表現する。
供されなかった場合の既定の挙動は、`限界水位$ 1 にされた `CountQueuingStrategy$I と同じになる。
◎
The strategy argument represents the stream’s queuing strategy, as described in § 7.1 The queuing strategy API. If it is not provided, the default behavior will be the same as a CountQueuingStrategy with a high water mark of 1.
</dd>

	<dt>%isLocked = %stream.`locked$ws</dt>
	<dd>
可書~streamが書込器に`~lockされて$いるかどうかを返す。
◎
Returns whether or not the writable stream is locked to a writer.
</dd>

	<dt>await %stream.`abort([ reason ])$ws</dt>
	<dd>
~streamを`中止する$。
それは、生産器は もはや成功裡に~streamに書込できないことを通達する
— 書込nが~queueしておかれたときは、破棄した上で，即時に~error状態に移行することになる。
これはまた、`下層~槽$の中止する仕組みも実行することになる。
◎
Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort mechanism of the underlying sink.
</dd>
	<dd>
返される~promiseは、［
~streamは成功裡に~shut-down場合には充足される／
`下層~槽$から そうするときに~errorしたことが通達された場合には却下される
］ことになる。
加えて，当の~streamは現在`~lockされて$いる場合には、
`TypeError$jE で却下されることになる（当の~streamを取消すよう試みることなく）。
◎
The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled that there was an error doing so. Additionally, it will reject with a TypeError (without attempting to cancel the stream) if the stream is currently locked.
</dd>

	<dt>await %stream.`close()$ws</dt>
	<dd>
~streamを~closeする。
`下層~槽$は、自身を~closeする挙動を呼出す前に，それまでに書込された`~chunk$を処理し終えることになる。
その間，更に書込しようとする試みは、失敗することになる（~streamを~errorにすることなく）。
◎
Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its close behavior. During this time any further attempts to write will fail (without erroring the stream).
</dd>
	<dd>
この~methodは、~promiseを返す
— それは、［
残りの`~chunk$すべてが成功裡に書込され，~streamは成功裡に~closeされた場合
］には充足され，［
この処理nの間に~errorに遭遇した場合
］には却下される。
加えて，当の~streamは現在`~lockされて$いる場合には、
`TypeError$jE で却下されることになる（当の~streamを取消すよう試みることなく）。
◎
The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with a TypeError (without attempting to cancel the stream) if the stream is currently locked.
</dd>

	<dt>%writer = %stream.`getWriter()$ws</dt>
	<dd>
`書込器$（ `WritableStreamDefaultWriter$I の~instance）を作成して，~streamをこの新たな書込器に`~lock$する。
~streamが~lockされている間は、他の書込器は，この~lockが`解放-$されるまで獲得できない。
◎
Creates a writer (an instance of WritableStreamDefaultWriter) and locks the stream to the new writer. While the stream is locked, no other writer can be acquired until this one is released.
</dd>
	<dd>
この機能性は、［
他から中断されたり書込nが差挟まれることなく~streamに書込する能を欲するような，抽象-化
］を創出するときに，とりわけ有用になる。
~stream用の書込器を取得することにより，［
他から同時に書込されて，書込した~dataが予測-不能になり，役立たずになる
］ことはないことを確保できる。
◎
This functionality is especially useful for creating abstractions that desire the ability to write to a stream without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at the same time, which would cause the resulting written data to be unpredictable and probably useless.
</dd>
</dl>

<div class="algo">
<p>
`new WritableStream(underlyingSink, strategy)@m
構築子~手続きは：
◎
The WritableStream(underlyingSink, strategy) constructor steps are:
</p>
<ol>
	<li>
~IF［
%underlyingSink ~EQ ε
］
⇒
%underlyingSink ~SET ~NULL
◎
If underlyingSink is missing, set it to null.
</li>
	<li>
<p>
%underlyingSinkDict ~LET %underlyingSink を `UnderlyingSink$I 型の`~IDL値に変換-$した結果
◎
Let underlyingSinkDict be underlyingSink, converted to an IDL value of type UnderlyingSink.
</p>

<p class="note">注記：
%underlyingSink 引数を `UnderlyingSink$I 型として直に宣言できないのは、元の~objへの参照が失われるからである。
~obj上の各種~methodを`~methodを呼出せる$よう、~objは維持する必要がある。
◎
We cannot declare the underlyingSink argument as having the UnderlyingSink type directly, because doing so would lose the reference to the original object. We need to retain the object so we can invoke the various methods on it.
</p>
	</li>
	<li>
<p>
~IF［
%underlyingSinkDict[ "`type$usk" ] ~NEQ ε
］
⇒
~THROW `RangeError$E
◎
If underlyingSinkDict["type"] exists, throw a RangeError exception.
</p>

<p class="note">注記：
これは、後方-互換性を懸念することなく，将来に新たな型を追加できるようにする。
◎
This is to allow us to add new potential types in the future, without backward-compatibility concerns.
</p>
	</li>
	<li>
~NOABRUPT `InitializeWritableStream$A( コレ )
◎
Perform ! InitializeWritableStream(this).
</li>
	<li>
%sizeAlgorithm ~LET
~ABRUPT `ExtractSizeAlgorithm$A( %strategy )
◎
Let sizeAlgorithm be ! ExtractSizeAlgorithm(strategy).
</li>
	<li>
%highWaterMark ~LET
~ABRUPT `ExtractHighWaterMark$A( %strategy, 1 )
◎
Let highWaterMark be ? ExtractHighWaterMark(strategy, 1).
</li>
	<li>
~ABRUPT `SetUpWritableStreamDefaultControllerFromUnderlyingSink$A( コレ, %underlyingSink, %underlyingSinkDict, %highWaterMark, %sizeAlgorithm )
◎
Perform ? SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, underlyingSinkDict, highWaterMark, sizeAlgorithm).
</li>
</ol>
</div>

<div class="algo">
<p>
`locked@ws
取得子~手続きは：
◎
The locked attribute’s getter steps are:
</p>
<ol>
	<li>
~RET
~NOABRUPT `IsWritableStreamLocked$A( コレ )
◎
Return ! IsWritableStreamLocked(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`abort(reason)@ws
~method~手続きは：
◎
The abort(reason) method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsWritableStreamLocked$A( コレ ) ~EQ ~T
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If ! IsWritableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamAbort$A( コレ, %reason )
◎
Return ! WritableStreamAbort(this, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`close()@ws
~method~手続きは：
◎
The close() method steps are:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsWritableStreamLocked$A( コレ ) ~EQ ~T
］
⇒ 
~RET `TypeError^jE 例外で`却下される~promise$
◎
If ! IsWritableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( コレ ) ~EQ ~T
］
⇒ 
~RET `TypeError^jE 例外で`却下される~promise$
◎
If ! WritableStreamCloseQueuedOrInFlight(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET 
~NOABRUPT `WritableStreamClose$A( コレ )
◎
Return ! WritableStreamClose(this).
</li>
</ol>
</div>


<div class="algo">
<p>
`getWriter()@ws
~method~手続きは：
◎
The getWriter() method steps are:
</p>
<ol>
	<li>
~RET
~ABRUPT `AcquireWritableStreamDefaultWriter$A( コレ )
◎
Return ? AcquireWritableStreamDefaultWriter(this).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="default-writer-class">
<h3 title="The WritableStreamDefaultWriter class">5.3. `WritableStreamDefaultWriter^I ~class</h3>

<p>
`WritableStreamDefaultWriter$I ~classは、［
`WritableStream$I ~instanceから配給されるように設計された`可書~stream書込器$
］を表現する。
◎
The WritableStreamDefaultWriter class represents a writable stream writer designed to be vended by a WritableStream instance.
</p>

			<section id="default-writer-class-definition">
<h4 title="Interface definition">5.3.1. ~interface定義</h4>

<p>
`WritableStreamDefaultWriter$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the WritableStreamDefaultWriter class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `WritableStreamDefaultWriter@I {
  `WritableStreamDefaultWriter$mc(`WritableStream$I %stream);

  readonly attribute Promise&lt;void&gt; `closed$dw;
  readonly attribute `unrestricted double$? `desiredSize$dw;
  readonly attribute Promise&lt;void&gt; `ready$dw;

  Promise&lt;void&gt; `abort$dw(optional any %reason);
  Promise&lt;void&gt; `close$dw();
  void `releaseLock$dw();
  Promise&lt;void&gt; `write$dw(optional any %chunk);
};
</pre>

			</section>
			<section id="default-writer-internal-slots">
<h4 title="Internal slots">5.3.2. 内部~slot</h4>

<p>
`WritableStreamDefaultWriter$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of WritableStreamDefaultWriter are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`closedPromise^sl
<td>
書込器の `closed()$dw 取得子から返される~promise
◎
A promise returned by the writer’s closed getter

<tr><td>`ownerWritableStream^sl
<td>
この書込器【！読取器】を所有する `WritableStream$I の~instance
◎
A WritableStream instance that owns this reader

<tr><td>`readyPromise^sl
<td>
書込器の `ready$dw 取得子から返される~promise
◎
A promise returned by the writer’s ready getter
</tbody></table>

			</section>
			<section id="default-writer-prototype">
<h4 title="Constructor, methods, and properties">5.3.3. 構築子／~method／~prop</h4>

<dl class="domintro">
	<dt>%writer = `new WritableStreamDefaultWriter(stream)$m</dt>
	<dd>
これは、
<code>%stream.`getWriter()$ws</code>
を~callするのと等価になる。
◎
This is equivalent to calling stream.getWriter().
</dd>

	<dt>await %writer.`closed$dw</dt>
	<dd>
~promiseを返す
— それは、~streamが~closeされたときは充足され，［
どこかで~errorした ／
~streamが~closeし終える前に書込器の~lockが`解放-$された
］ときは却下される。
◎
Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or the writer’s lock is released before the stream finishes closing.
</dd>

	<dt>%desiredSize = %writer.`desiredSize$dw</dt>
	<dd>
`~streamの内部~queueの残り~size$を返す。
~queueを溢れている場合の結果は、負になる。
`生産器$は、書込する正解の~data量を決定するときに，この情報を利用できる。
◎
Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full. A producer can use this information to determine the right amount of data to write.
</dd>
	<dd>
~streamを成功裡に書込できない場合（~errorになったか~queueしておくのが中止されたことに因り）、 ~NULL になる。
~streamが~closeされた場合、 0 になる。
この取得子が，書込器の~lockが`解放-$されている間に呼出された場合、例外を投出する。
◎
It will be null if the stream cannot be successfully written to (due to either being errored, or having an abort queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when the writer’s lock is released.
</dd>

	<dt>await %writer.`ready$dw</dt>
	<dd>
~promiseを返す
— それは、`~streamの内部~queueの残り~size$が 0 以下から正へ遷移したときに充足され，`背圧$は もう適用されないことを通達することになる。
`~streamの内部~queueの残り~size$が再び 0 以下に落ち込んだときには、取得子は，［
次回の遷移まで処理待ちであり続ける，`新たな~promise$
］を返すことになる。
◎
Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips back to zero or below, the getter will return a new promise that stays pending until the next transition.
</dd>
	<dd>
~streamが~errorになったか中止された, または
書込器の~lockが`解放-$された場合、返された~promiseは，却下されることになる。
◎
If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become rejected.
</dd>

	<dt>await %writer.`abort([ reason ])$dw</dt>
	<dd>
当の読取器は`作動中$である場合、
<code>%stream.`abort(reason)$ws</code>
と同じに挙動する。
◎
If the reader is active, behaves the same as stream.abort(reason).
</dd>

	<dt>await %writer.`close()$dw</dt>
	<dd>
当の読取器は`作動中$である場合、
<code>%stream.`close()$ws</code>
と同じに挙動する。
◎
If the reader is active, behaves the same as stream.close().
</dd>

	<dt>%writer.`releaseLock()$dw</dt>
	<dd>
書込器による対応する~stream上の~lockを`解放-$する。
~lockが解放されて以降は、当の書込器は，もはや`作動中$でなくなる。
~lockが解放される時点で，結付けられている~streamが~error状態にある場合、それ以降も，書込器はそれを引き継ぐように~errorしたように現れる。
他の場合、書込器は~closeされたように現れる。
◎
Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active. If the associated stream is errored when the lock is released, the writer will appear errored in the same way from now on; otherwise, the writer will appear closed.
</dd>
	<dd>
まだ完遂してない進行中の書込nがあるときでも（すなわち、前回の `write()$dw ~callから返された~promiseが決着していなくとも）、~lockは解放できることに注意。
書込n中に書込器に対する~lockを保持することは、必要とされない
— ~lockは、単純に，他の`生産器$が差挟むような方式で書込するのを防止するためにある。
◎
Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the promises returned from previous calls to write() have not yet settled). It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents other producers from writing in an interleaved manner.
</dd>

	<dt>await %writer.`write(chunk)$dw</dt>
	<dd>
所与の`~chunk$を可書~streamに書込する
— 以前の書込nがあれば それが成功裡に完遂するまで待機した上で，`下層~槽$の `write()$usk ~methodに`~chunk$を送信することにより。
この~methodは、~promiseを返す
— それは、書込nが成功したときは `undefined^jv で充足され，［
書込nに失敗した, または書込み処理nが起動される前に~streamが~errorした場合
］は 却下される。
◎
Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully, and then sending the chunk to the underlying sink's write() method. It will return a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes errored before the writing process is initiated.
</dd>
	<dd>
“成功” が 何を意味するかは，`下層~槽$に委ねられることに注意。
それは、単純に`~chunk$が受容されたことを指示するだけかもしれない
— それが最終~行先に安全に保存されることは，必要とされない。
◎
Note that what "success" means is up to the underlying sink; it might indicate simply that the chunk has been accepted, and not necessarily that it is safely saved to its ultimate destination.
</dd>
</dl>

<div class="algo">
<p>
`new WritableStreamDefaultWriter(stream)@m
構築子~手続きは：
◎
The WritableStreamDefaultWriter(stream) constructor steps are:
</p>
<ol>
	<li>
~ABRUPT `SetUpWritableStreamDefaultWriter$A(コレ, %stream).
◎
Perform ? SetUpWritableStreamDefaultWriter(this, stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`closed@dw
取得子~手続きは：
◎
The closed getter steps are:
</p>
<ol>
	<li>
~RET コレ.`closedPromise^sl
◎
Return this.[[closedPromise]].
</li>
</ol>
</div>

<div class="algo">
<p>
`desiredSize@dw
取得子~手続きは：
◎
The desiredSize getter steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerWritableStream^sl ~EQ `undefined^jv
］
⇒
~THROW `TypeError^jE
◎
If this.[[ownerWritableStream]] is undefined, throw a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamDefaultWriterGetDesiredSize$A( コレ )
◎
Return ! WritableStreamDefaultWriterGetDesiredSize(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`ready@dw
取得子~手続きは：
◎
The ready getter steps are:
</p>
<ol>
	<li>
~RET コレ.`readyPromise^sl
◎
Return this.[[readyPromise]].
</li>
</ol>
</div>

<div class="algo">
<p>
`abort(reason)@dw
~method~手続きは：
◎
The abort(reason) method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerWritableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If this.[[ownerWritableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamDefaultWriterAbort$A( コレ, %reason )
◎
Return ! WritableStreamDefaultWriterAbort(this, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`close()@dw
~method~手続きは：
◎
The close() method steps are:
</p>
<ol>
	<li>
%stream ~LET コレ.`ownerWritableStream^sl
◎
Let stream be this.[[ownerWritableStream]].
</li>
	<li>
~IF［
%stream ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If stream is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~T
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamDefaultWriterClose$A( コレ )
◎
Return ! WritableStreamDefaultWriterClose(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`releaseLock()@dw
~method~手続きは：
◎
The releaseLock() method steps are:
</p>
<ol>
	<li>
%stream ~LET コレ.`ownerWritableStream^sl
◎
Let stream be this.[[ownerWritableStream]].
</li>
	<li>
~IF［
%stream ~EQ `undefined^jv
］
⇒
~RET
◎
If stream is undefined, return.
</li>
	<li>
~Assert：
%stream.`writer^sl ~NEQ `undefined^jv
◎
Assert: stream.[[writer]] is not undefined.
</li>
	<li>
~NOABRUPT `WritableStreamDefaultWriterRelease$A( コレ )
◎
Perform ! WritableStreamDefaultWriterRelease(this).
</li>
</ol>
</div>

<div class="algo">
<p>
`write()@dw
~method~手続きは：
◎
The write(chunk) method steps are:
</p>
<ol>
	<li>
~IF［
コレ.`ownerWritableStream^sl ~EQ `undefined^jv
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If this.[[ownerWritableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamDefaultWriterWrite$A( コレ, %chunk )
◎
Return ! WritableStreamDefaultWriterWrite(this, chunk).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="ws-default-controller-class">
<h3 title="The WritableStreamDefaultController class">5.4. `WritableStreamDefaultController^I ~class</h3>

<p>
`WritableStreamDefaultController$I ~classは、
`WritableStream$I の状態を制御~可能にする，各種~methodを持つ。
`WritableStream$I の構築-時には、`下層~槽$には，操作するための対応する `WritableStreamDefaultController$I の~instanceが与えられる。
◎
The WritableStreamDefaultController class has methods that allow control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.
</p>

			<section id="ws-default-controller-class-definition">
<h4 title="Interface definition">5.4.1. ~interface定義</h4>

<p>
`WritableStreamDefaultController$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the WritableStreamDefaultController class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `WritableStreamDefaultController@I {
  void `error$wsdc(optional any %e);
};
</pre>

			</section>
			<section id="ws-default-controller-internal-slots">
<h4 title="Internal slots">5.4.2. 内部~slot</h4>

<p>
`WritableStreamDefaultController$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of WritableStreamDefaultController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`abortAlgorithm^sl
<td>
1 個の引数（中止-事由）をとり，~promiseを返す~algo
— それは、要請された中止-を`下層~槽$に通信する。
◎
A promise-returning algorithm, taking one argument (the abort reason), which communicates a requested abort to the underlying sink

<tr><td>`closeAlgorithm^sl
<td>
~promiseを返す~algo
— それは、要請された~closeを`下層~槽$に通信する。
◎
A promise-returning algorithm which communicates a requested close to the underlying sink

<tr><td>`controlledWritableStream^sl
<td>
制御される `WritableStream$I の~instance
◎
The WritableStream instance controlled

<tr><td>`queue^sl
<td>
~streamの［
`~chunk$たちからなる内部~queue
］を表現する`~list$。
◎
A list representing the stream’s internal queue of chunks

<tr><td>`queueTotalSize^sl
<td>
`queue^sl 内に格納されている すべての~chunkの合計~size（`個別~size付き~queue$secを見よ）
◎
The total size of all the chunks stored in [[queue]] (see § 8.1 Queue-with-sizes)

<tr><td>`started^sl
<td>
真偽~flag
— `下層~槽$が開始処理【 `start()^c 】を完遂したかどうかを指示する。
◎
A boolean flag indicating whether the underlying sink has finished starting

<tr><td>`strategyHWM^sl
<td>
~streamの`~queuing策$の一部として，~streamの作成子から給された~number
— ~streamがその`下層~槽$に`背圧$を適用することになる~~基準を指示する。
◎
A number supplied by the creator of the stream as part of the stream’s queuing strategy, indicating the point at which the stream will apply backpressure to its underlying sink

<tr><td>`strategySizeAlgorithm^sl
<td>
~streamの`~queuing策$の一部として，~enqueueされた`~chunk$たちの~sizeを計算する~algo。
◎
An algorithm to calculate the size of enqueued chunks, as part of the stream’s queuing strategy

<tr><td>`writeAlgorithm^sl
<td>
1 個の引数（書込する~chunk）をとり，~promiseを返す~algo
— それは、`下層~槽$に~dataを書込する。
◎
A promise-returning algorithm, taking one argument (the chunk to write), which writes data to the underlying sink

</tbody></table>

<p>
`~close~sentinel@i
（ `close sentinel^en ）は、~streamは~closeされたことを通達する一意な値であり，`~chunk$に代えて `queue^sl の中に~enqueueされる。
それは、内部に限り利用され，~web開発者に公開されることは決してない。
◎
The close sentinel is a unique value enqueued into [[queue]], in lieu of a chunk, to signal that the stream is closed. It is only used internally, and is never exposed to web developers.
</p>

			</section>
			<section id="ws-default-controller-prototype">
<h4 title="Methods">5.4.3. ~method</h4>

<dl class="domintro">
	<dt>%controller.`error(e)$wsdc</dt>
	<dd>
制御先の可書~streamを~closeする
— 以降のヤリトリは、すべて所与の~error %e で失敗させる。
◎
Closes the controlled writable stream, making all future interactions with it fail with the given error e.
</dd>
	<dd>
この~methodは、稀にしか利用されない
— 通例的には、`下層~槽$のいずれかの~methodから，却下される~promiseを返すだけで足りるので。
しかしながら、`下層~槽$とのヤリトリによる通常の~lifecycleの外側にある~eventに呼応して~streamが突如~shut-downされる場合には，有用になり得る。
◎
This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the normal lifecycle of interactions with the underlying sink.
</dd>
</dl>

<div class="algo">
<p>
`error(e)@wsdc
~method~手続きは：
◎
The error(e) method steps are:
</p>
<ol>
	<li>
%state ~LET コレ.`controlledWritableStream^sl.`state^sl
◎
Let state be this.[[controlledWritableStream]].[[state]].
</li>
	<li>
~IF［
%state ~NEQ `writable^l
］
⇒
~RET
◎
If state is not "writable", return.
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerError$A( コレ, %e )
◎
Perform ! WritableStreamDefaultControllerError(this, e).
</li>
</ol>
</div>

			</section>
			<section id="ws-default-controller-internal-methods">
<h4 title="Internal methods">5.4.4. 内部~method</h4>

<p>
各 `WritableStreamDefaultController$I ~instanceは、以下に与える内部~methodを実装する。
可書~stream実装は、これらの中へ~callすることになる。
◎
The following are internal methods implemented by each WritableStreamDefaultController instance. The writable stream implementation will call into these.
</p>

<p class="note">注記：
これらが抽象-演算ではなく，~methodの形をとる理由は、可書~stream実装が制御器~実装から切り離され，将来には 他の制御器で拡張pされることを明瞭にするためである
— それらの制御器がこれらの内部~methodを実装する限りにおいて。
同様の経緯は，可読~streamにも見られ（`制御器との~interface法$secを見よ）、そこでは，［
各種 内部~methodに相当するように，多形態的に利用される制御器~型
］が実際に複数ある。
◎
The reason these are in method form, instead of as abstract operations, is to make it clear that the writable stream implementation is decoupled from the controller implementation, and could in the future be expanded with other controllers, as long as those controllers implemented such internal methods. A similar scenario is seen for readable streams (see § 4.8.2 Interfacing with controllers), where there actually are multiple controller types and as such the counterpart internal methods are used polymorphically.
</p>

<div class="algo">
<p>
`[[AbortSteps]]( reason )@wsdc
は、
`AbortSteps$sl の契約を実装する。
それは、次の手続きを遂行する：
◎
[[AbortSteps]](reason) implements the [[AbortSteps]] contract. It performs the following steps:
</p>
<ol>
	<li>
%result ~LET コレ.`abortAlgorithm^sl( %reason )
◎
Let result be the result of performing this.[[abortAlgorithm]], passing reason.
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerClearAlgorithms$A( コレ )
◎
Perform ! WritableStreamDefaultControllerClearAlgorithms(this).
</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`[[ErrorSteps]]()@wsdc
は
`ErrorSteps$sl の契約を実装する。
それは、次の手続きを遂行する：
◎
[[ErrorSteps]]() implements the [[ErrorSteps]] contract. It performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `ResetQueue$A( コレ )
◎
Perform ! ResetQueue(this).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="ws-all-abstract-ops">
<h3 title="Abstract operations">5.5. 抽象-演算</h3>

			<section id="ws-abstract-ops">
<h4 title="Working with writable streams">5.5.1. 可書~streamとの作業-法</h4>

<p>
以下に与える抽象-演算は、
`WritableStream$I ~instanceに対し高~levelから演算する。
一部のものは、一般に，他の仕様においても有用になるよう意味されている。
◎
The following abstract operations operate on WritableStream instances at a higher level. Some are even meant to be generally useful by other specifications.
</p>

<div class="algo">
<p>
`AcquireWritableStreamDefaultWriter(stream)@A
は、`可書~stream$用の`書込器$を獲得したいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
AcquireWritableStreamDefaultWriter(stream) is meant to be called from other specifications that wish to acquire a writer for a given writable stream. It performs the following steps:
</p>
<ol>
	<li>
%writer ~LET `新たな$ `WritableStreamDefaultWriter$I
◎
Let writer be a new WritableStreamDefaultWriter.
</li>
	<li>
~ABRUPT `SetUpWritableStreamDefaultWriter$A( %writer, %stream )
◎
Perform ? SetUpWritableStreamDefaultWriter(writer, stream).
</li>
	<li>
~RET %writer
◎
Return writer.
</li>
</ol>
</div>

<div class="algo">
<p>
`CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm[, highWaterMark[, sizeAlgorithm ] ])@A
は、
`WritableStream$I ~instanceを作成したいと望む，他の仕様から~callされる用途に意味されている。
◎
CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm[, highWaterMark[, sizeAlgorithm]]) is meant to be called from other specifications that wish to create WritableStream instances.＼
</p>
<ul>
	<li>
［
%writeAlgorithm ／ %closeAlgorithm ／ %abortAlgorithm
］は、~promiseを返す~algoでなければナラナイ。
◎
The writeAlgorithm, closeAlgorithm, and abortAlgorithm algorithms must return promises;＼
</li>
	<li>
%sizeAlgorithm は、給されるならば，`~chunk$~objを受容して ~numberを返す~algoでなければナラナイ。
◎
if supplied, sizeAlgorithm must be an algorithm accepting chunk objects and returning a number;＼
</li>
	<li>
%highWaterMark は、給されるならば，負でも `NaN^jv でもない ~numberでなければナラナイ。
◎
and if supplied, highWaterMark must be a non-negative, non-NaN number.
</li>
</ul>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~IF［
%highWaterMark は渡されていない
］
⇒
%highWaterMark ~SET 1
◎
If highWaterMark was not passed, set it to 1.
</li>
	<li>
~IF［
%sizeAlgorithm は渡されていない
］
⇒
%sizeAlgorithm ~SET 次を走らす~algo
⇒
~RET 1
◎
If sizeAlgorithm was not passed, set it to an algorithm that returns 1.
</li>
	<li>
~Assert：
~NOABRUPT `IsNonNegativeNumber$A( %highWaterMark ) ~EQ ~T
◎
Assert: ! IsNonNegativeNumber(highWaterMark) is true.
</li>
	<li>
%stream ~LET `新たな$ `WritableStream$I
◎
Let stream be a new WritableStream.
</li>
	<li>
~NOABRUPT `InitializeWritableStream$A( %stream )
◎
Perform ! InitializeWritableStream(stream).
</li>
	<li>
%controller ~LET `新たな$ `WritableStreamDefaultController$I
◎
Let controller be a new WritableStreamDefaultController.
</li>
	<li>
~ABRUPT `SetUpWritableStreamDefaultController$A( %stream, %controller, %startAlgorithm, %writeAlgorithm, %closeAlgorithm, %abortAlgorithm, %highWaterMark, %sizeAlgorithm )
◎
Perform ? SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm).
</li>
	<li>
~RET %stream
◎
Return stream.
</li>
</ol>

<p class="note">注記：
この抽象-演算は、給された %startAlgorithm が投出するとき, そのときに限り例外を投出することになる。
◎
This abstract operation will throw an exception if and only if the supplied startAlgorithm throws.
</p>
</div>

<div class="algo">
<p>
`InitializeWritableStream(stream)@A
は、次の手続きを遂行する：
◎
InitializeWritableStream(stream) performs the following steps:
</p>
<ol>
	<li>
%stream の
⇒＃
.`state^sl ~SET `writable^l,
.`storedError^sl ~SET `undefined^jv,
.`writer^sl ~SET `undefined^jv,
.`writableStreamController^sl ~SET `undefined^jv,
.`inFlightWriteRequest^sl ~SET `undefined^jv,
.`closeRequest^sl ~SET `undefined^jv,
.`inFlightCloseRequest^sl ~SET `undefined^jv,
.`pendingAbortRequest^sl ~SET `undefined^jv,
.`writeRequests^sl ~SET 新たな空`~list$,
.`backpressure^sl ~SET ~F
◎
Set stream.[[state]] to "writable".
◎
Set stream.[[storedError]], stream.[[writer]], stream.[[writableStreamController]], stream.[[inFlightWriteRequest]], stream.[[closeRequest]], stream.[[inFlightCloseRequest]] and stream.[[pendingAbortRequest]] to undefined.
◎
Set stream.[[writeRequests]] to a new empty list.
◎
Set stream.[[backpressure]] to false.
</li>
</ol>
</div>

<div class="algo">
<p>
`IsWritableStreamLocked(stream)@A
は、［
可書~streamが書込器に`~lockされて$いるかどうか
］を~queryしたいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
IsWritableStreamLocked(stream) is meant to be called from other specifications that wish to query whether or not a writable stream is locked to a writer. It performs the following steps:
</p>
<ol>
	<li>
~IF［
%stream.`writer^sl ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If stream.[[writer]] is undefined, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpWritableStreamDefaultWriter(writer, stream)@A
は、次の手続きを遂行する：
◎
SetUpWritableStreamDefaultWriter(writer, stream) performs the following steps:
</p>
<ol>
	<li>
~IF［
~NOABRUPT `IsWritableStreamLocked$A( %stream ) ~EQ ~T
］
⇒
~THROW `TypeError$jE
◎
If ! IsWritableStreamLocked(stream) is true, throw a TypeError exception.
</li>
	<li>
%writer.`ownerWritableStream^sl ~SET %stream
◎
Set writer.[[ownerWritableStream]] to stream.
</li>
	<li>
%stream.`writer^sl ~SET %writer
◎
Set stream.[[writer]] to writer.
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
<p>
~IF［
%state ~EQ `writable^l
］：
◎
If state is "writable",
</p>
		<ol>
			<li>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~F
］~AND［
%stream.`backpressure^sl ~EQ ~T
］
⇒ 
%writer.`readyPromise^sl ~SET `新たな~promise$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[backpressure]] is true, set writer.[[readyPromise]] to a new promise.
</li>
			<li>
~ELSE
⇒
%writer.`readyPromise^sl ~SET `undefined^jv で`解決される~promise$
◎
Otherwise, set writer.[[readyPromise]] to a promise resolved with undefined.
</li>
			<li>
%writer.`closedPromise^sl ~SET `新たな~promise$
◎
Set writer.[[closedPromise]] to a new promise.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%state ~EQ `erroring^l
］
⇒
◎
Otherwise, if state is "erroring",
</p>
		<ol>
			<li>
%writer.`readyPromise^sl ~SET %stream.`storedError^sl で`却下される~promise$
◎
Set writer.[[readyPromise]] to a promise rejected with stream.[[storedError]].
</li>
			<li>
%writer.`readyPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
			<li>
%writer.`closedPromise^sl ~SET `新たな~promise$
◎
Set writer.[[closedPromise]] to a new promise.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%state ~EQ `closed^l
］
⇒
◎
Otherwise, if state is "closed",
</p>
		<ol>
			<li>
%writer.`readyPromise^sl ~SET `undefined^jv で`解決される~promise$
◎
Set writer.[[readyPromise]] to a promise resolved with undefined.
</li>
			<li>
%writer.`closedPromise^sl ~SET `undefined^jv で`解決される~promise$
◎
Set writer.[[closedPromise]] to a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%state ~EQ `errored^l
◎
Assert: state is "errored".
</li>
			<li>
%storedError ~LET %stream.`storedError^sl
◎
Let storedError be stream.[[storedError]].
</li>
			<li>
%writer.`readyPromise^sl ~SET %storedError で`却下される~promise$
◎
Set writer.[[readyPromise]] to a promise rejected with storedError.
</li>
			<li>
%writer.`readyPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
			<li>
%writer.`closedPromise^sl ~SET %storedError で`却下される~promise$
◎
Set writer.[[closedPromise]] to a promise rejected with storedError.
</li>
			<li>
%writer.`closedPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set writer.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamAbort(stream, reason)@A
は、次の手続きを遂行する：
◎
WritableStreamAbort(stream, reason) performs the following steps:
</p>
<ol>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~IN { `closed^l, `errored^l }
］
⇒
~RET `undefined^jv で`解決される~promise$
◎
If state is "closed" or "errored", return a promise resolved with undefined.
</li>
	<li>
~IF［
%stream.`pendingAbortRequest^sl ~NEQ `undefined^jv
］
⇒
~RET %stream.`pendingAbortRequest^sl の`~promise$aR
◎
If stream.[[pendingAbortRequest]] is not undefined, return stream.[[pendingAbortRequest]]'s promise.
</li>
	<li>
~Assert：
%state ~IN { `writable^l, `erroring^l }
◎
Assert: state is "writable" or "erroring".
</li>
	<li>
%wasAlreadyErroring ~LET ~F
◎
Let wasAlreadyErroring be false.
</li>
	<li>
<p>
~IF［
%state ~EQ `erroring^l
］：
◎
If state is "erroring",
</p>
		<ol>
			<li>
%wasAlreadyErroring ~SET ~T
◎
Set wasAlreadyErroring to true.
</li>
			<li>
%reason ~SET `undefined^jv
◎
Set reason to undefined.
</li>
		</ol>
	</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%stream.`pendingAbortRequest^sl ~SET 次を伴う，新たな`処理待ち中止-要請$
⇒＃
`~promise$aR ~SET %promise,
`事由$aR ~SET %reason,
`すでに~errorした$aR ~SET %wasAlreadyErroring
◎
Set stream.[[pendingAbortRequest]] to a new pending abort request whose promise is promise, reason is reason, and was already erroring is wasAlreadyErroring.
</li>
	<li>
~IF［
%wasAlreadyErroring ~EQ ~F
］
⇒
~NOABRUPT `WritableStreamStartErroring$A( %stream, %reason )
◎
If wasAlreadyErroring is false, perform ! WritableStreamStartErroring(stream, reason).
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamClose(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamClose(stream) performs the following steps:
</p>
<ol>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~IN { `closed^l, `errored^l }
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If state is "closed" or "errored", return a promise rejected with a TypeError exception.
</li>
	<li>
~Assert：
%state ~IN { `writable^l, `erroring^l }
◎
Assert: state is "writable" or "erroring".
</li>
	<li>
~Assert：
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~F
◎
Assert: ! WritableStreamCloseQueuedOrInFlight(stream) is false.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%stream.`closeRequest^sl ~SET %promise
◎
Set stream.[[closeRequest]] to promise.
</li>
	<li>
%writer ~LET %stream.`writer^sl
◎
Let writer be stream.[[writer]].
</li>
	<li>
~IF［
%writer ~NEQ `undefined^jv
］~AND［
%stream.`backpressure^sl ~EQ ~T
］~AND［
%state ~EQ `writable^l
］
⇒
`undefined^jv で
%writer.`readyPromise^sl を`解決する$
◎
If writer is not undefined, and stream.[[backpressure]] is true, and state is "writable", resolve writer.[[readyPromise]] with undefined.
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerClose$A( %stream.`writableStreamController^sl )
◎
Perform ! WritableStreamDefaultControllerClose(stream.[[writableStreamController]]).
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

			</section>
			<section id="ws-abstract-ops-used-by-controllers">
<h4 title="Interfacing with controllers">5.5.2. 制御器との~interface法</h4>

<p>
将来に，挙動が異なる可書~stream（既定の可読~streamと`可読~byte~stream$との間の区別に類似な）も追加できるよう柔軟性を得るため、`可書~stream$の内部~状態の多くの部分は，
`WritableStreamDefaultController$I ~classにより~encapsulateされる。
◎
To allow future flexibility to add different writable stream behaviors (similar to the distinction between default readable streams and readable byte streams), much of the internal state of a writable stream is encapsulated by the WritableStreamDefaultController class.
</p>

<p>
各~制御器~classは、 2 つの内部~methodを定義する
— それらは、 `WritableStream$I の各種~algoから~callされる：
◎
Each controller class defines two internal methods, which are called by the WritableStream algorithms:
</p>

<dl>
	<dt>`AbortSteps@sl(%reason)</dt>
	<dd>
~streamが`中止-$されたときの反応として走らす，制御器の手続き。
制御器に格納されている状態を片付けて，`下層~槽$に伝えるために利用される。
◎
The controller’s steps that run in reaction to the stream being aborted, used to clean up the state stored in the controller and inform the underlying sink. 
</dd>

	<dt>`ErrorSteps@sl()</dt>
	<dd>
~streamが~errorしたときの反応として走らす，制御器の手続き。
制御器に格納されている状態を片付けるために利用される。
◎
The controller’s steps that run in reaction to the stream being errored, used to clean up the state stored in the controller.
</dd>
</dl>

<p>
（これらは、制御器の型に応じて分岐することなく，各種 `WritableStream$I ~algoから多形態的に~callできるよう、抽象-演算としてではなく，内部~methodとして定義される。
（まだ `WritableStreamDefaultController$I しか存在しないので、今の所は理論上のものになっているが。）
◎
(These are defined as internal methods, instead of as abstract operations, so that they can be called polymorphically by the WritableStream algorithms, without having to branch on which type of controller is present. This is a bit theoretical for now, given that only WritableStreamDefaultController exists so far.)
</p>

<p>
この節の以降では、上述とは別方向の抽象-演算について注力する：
それらは、制御器~実装により，それぞれに結付けられている `WritableStream$I ~objに影響させるために利用される。
これは、制御器における内部~状態~変化を， `WritableStream$I の~public~APIを通して開発者に可視になる結果に翻訳する。
◎
The rest of this section concerns abstract operations that go in the other direction: they are used by the controller implementation to affect its associated WritableStream object. This translates internal state changes of the controllerinto developer-facing results visible through the WritableStream's public API.
</p>

<div class="algo">
<p>
`WritableStreamAddWriteRequest(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamAddWriteRequest(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
~NOABRUPT `IsWritableStreamLocked$A( %stream ) ~EQ ~T
◎
Assert: ! IsWritableStreamLocked(stream) is true.
</li>
	<li>
~Assert：
%stream.`state^sl ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%stream.`writeRequests^sl に %promise を`付加する$
◎
Append promise to stream.[[writeRequests]].
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamCloseQueuedOrInFlight(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamCloseQueuedOrInFlight(stream) performs the following steps:
</p>
<ol>
	<li>
~IF［
%stream.`closeRequest^sl ~EQ `undefined^jv
］~AND［
%stream.`inFlightCloseRequest^sl ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If stream.[[closeRequest]] is undefined and stream.[[inFlightCloseRequest]] is undefined, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDealWithRejection(stream, error)@A
は、次の手続きを遂行する：
◎
WritableStreamDealWithRejection(stream, error) performs the following steps:
</p>
<ol>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
<p>
~IF［
%state ~EQ `writable^l
］：
◎
If state is "writable",
</p>
		<ol>
			<li>
~NOABRUPT `WritableStreamStartErroring$A( %stream, %error )
◎
Perform ! WritableStreamStartErroring(stream, error).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%state ~EQ `erroring^l
◎
Assert: state is "erroring".
</li>
	<li>
~NOABRUPT `WritableStreamFinishErroring$A( %stream )
◎
Perform ! WritableStreamFinishErroring(stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamFinishErroring(stream, reason)@A
は、次の手続きを遂行する：
◎
WritableStreamFinishErroring(stream, reason) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`state^sl ~EQ `erroring^l
◎
Assert: stream.[[state]] is "erroring".
</li>
	<li>
~Assert：
~NOABRUPT `WritableStreamHasOperationMarkedInFlight$A( %stream ) ~EQ ~F
◎
Assert: ! WritableStreamHasOperationMarkedInFlight(stream) is false.
</li>
	<li>
%stream.`state^sl ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
~NOABRUPT %stream.`writableStreamController^sl.`ErrorSteps^sl()
◎
Perform ! stream.[[writableStreamController]].[[ErrorSteps]]().
</li>
	<li>
%storedError ~LET %stream.`storedError^sl
◎
Let storedError be stream.[[storedError]].
</li>
	<li>
<p>
%stream.`writeRequests^sl を成す
~EACH( %writeRequest )
に対し：
◎
For each writeRequest of stream.[[writeRequests]]:
</p>
		<ol>
			<li>
%storedError で %writeRequest を`却下する$
◎
Reject writeRequest with storedError.
</li>
		</ol>
	</li>
	<li>
%stream.`writeRequests^sl ~SET 空`~list$
◎
Set stream.[[writeRequests]] to an empty list.
</li>
	<li>
<p>
~IF［
%stream.`pendingAbortRequest^sl ~EQ `undefined^jv
］：
◎
If stream.[[pendingAbortRequest]] is undefined,
</p>
		<ol>
			<li>
~NOABRUPT `WritableStreamRejectCloseAndClosedPromiseIfNeeded$A( %stream)
◎
Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%abortRequest ~LET %stream.`pendingAbortRequest^sl
◎
Let abortRequest be stream.[[pendingAbortRequest]].
</li>
	<li>
%stream.`pendingAbortRequest^sl ~SET `undefined^jv
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
	<li>
<p>
~IF［
%abortRequest の`すでに~errorした$aR ~EQ ~T
］：
◎
If abortRequest’s was already erroring is true,
</p>
		<ol>
			<li>
%storedError で %abortRequest の`~promise$aRを`却下する$
◎
Reject abortRequest’s promise with storedError.
</li>
			<li>
~NOABRUPT `WritableStreamRejectCloseAndClosedPromiseIfNeeded$A( %stream)
◎
Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
%promise ~LET
~NOABRUPT %stream.`writableStreamController^sl.`AbortSteps^sl( %abortRequest の`事由$aR )
◎
Let promise be ! stream.[[writableStreamController]].[[AbortSteps]](abortRequest’s reason).
</p>
		<ul>
			<li>
<p>
%promise の`充足-時$には
◎
Upon fulfillment of promise,
</p>
				<ol>
					<li>
`undefined^jv で
%abortRequest の`~promise$aRを`解決する$
◎
Resolve abortRequest’s promise with undefined.
</li>
					<li>
~NOABRUPT `WritableStreamRejectCloseAndClosedPromiseIfNeeded$A( %stream)
◎
Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %reason による
%promise の`却下-時$には：
◎
Upon rejection of promise with reason reason,
</p>
				<ol>
					<li>
%reason で
%abortRequest の`~promise$aRを`却下する$
◎
Reject abortRequest’s promise with reason.
</li>
					<li>
~NOABRUPT `WritableStreamRejectCloseAndClosedPromiseIfNeeded$A( %stream)
◎
Perform ! WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamFinishInFlightClose(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamFinishInFlightClose(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`inFlightCloseRequest^sl ~NEQ `undefined^jv
◎
Assert: stream.[[inFlightCloseRequest]] is not undefined.
</li>
	<li>
`undefined^jv で
%stream.`inFlightCloseRequest^sl を`解決する$
◎
Resolve stream.[[inFlightCloseRequest]] with undefined.
</li>
	<li>
%stream.`inFlightCloseRequest^sl ~SET `undefined^jv
◎
Set stream.[[inFlightCloseRequest]] to undefined.
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~Assert：
%stream.`state^sl ~IN { `writable^l, `erroring^l }
◎
Assert: stream.[[state]] is "writable" or "erroring".
</li>
	<li>
<p>
~IF［
%state ~EQ `erroring^l
］：
◎
If state is "erroring",
</p>
		<ol>
			<li>
%stream.`storedError^sl ~SET `undefined^jv
◎
Set stream.[[storedError]] to undefined.
</li>
			<li>
<p>
~IF［
%stream.`pendingAbortRequest^sl ~NEQ `undefined^jv
］：
◎
If stream.[[pendingAbortRequest]] is not undefined,
</p>
				<ol>
					<li>
`undefined^jv で
%stream.`pendingAbortRequest^sl の`~promise$aRを`解決する$
◎
Resolve stream.[[pendingAbortRequest]]'s promise with undefined.
</li>
					<li>
%stream.`pendingAbortRequest^sl ~SET `undefined^jv
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%stream.`state^sl ~SET `closed^l
◎
Set stream.[[state]] to "closed".
</li>
	<li>
%writer ~LET %stream.`writer^sl
◎
Let writer be stream.[[writer]].
</li>
	<li>
~IF［
%writer ~NEQ `undefined^jv
］
⇒
`undefined^jv で
%writer.`closedPromise^sl を`解決する$
◎
If writer is not undefined, resolve writer.[[closedPromise]] with undefined.
</li>
	<li>
~Assert：
%stream.`pendingAbortRequest^sl ~EQ `undefined^jv
◎
Assert: stream.[[pendingAbortRequest]] is undefined.
</li>
	<li>
~Assert：
%stream.`storedError^sl ~EQ `undefined^jv
◎
Assert: stream.[[storedError]] is undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamFinishInFlightCloseWithError(stream, error)@A
は、次の手続きを遂行する：
◎
WritableStreamFinishInFlightCloseWithError(stream, error) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`inFlightCloseRequest^sl ~NEQ `undefined^jv
◎
Assert: stream.[[inFlightCloseRequest]] is not undefined.
</li>
	<li>
%error で
%stream.`inFlightCloseRequest^sl を`却下する$
◎
Reject stream.[[inFlightCloseRequest]] with error.
</li>
	<li>
%stream.`inFlightCloseRequest^sl ~SET `undefined^jv
◎
Set stream.[[inFlightCloseRequest]] to undefined.
</li>
	<li>
~Assert：
%stream.`state^sl ~IN { `writable^l, `erroring^l }
◎
Assert: stream.[[state]] is "writable" or "erroring".
</li>
	<li>
<p>
~IF［
%stream.`pendingAbortRequest^sl ~NEQ `undefined^jv
］：
◎
If stream.[[pendingAbortRequest]] is not undefined,
</p>
		<ol>
			<li>
%error で
%stream.`pendingAbortRequest^sl の`~promise$aRを`却下する$
◎
Reject stream.[[pendingAbortRequest]]'s promise with error.
</li>
			<li>
%stream.`pendingAbortRequest^sl ~SET `undefined^jv
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `WritableStreamDealWithRejection$A( %stream, %error )
◎
Perform ! WritableStreamDealWithRejection(stream, error).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamFinishInFlightWrite(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamFinishInFlightWrite(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`inFlightWriteRequest^sl ~NEQ `undefined^jv
◎
Assert: stream.[[inFlightWriteRequest]] is not undefined.
</li>
	<li>
`undefined^jv で
%stream.`inFlightWriteRequest^sl を`解決する$
◎
Resolve stream.[[inFlightWriteRequest]] with undefined.
</li>
	<li>
%stream.`inFlightWriteRequest^sl ~SET `undefined^jv
◎
Set stream.[[inFlightWriteRequest]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamFinishInFlightWriteWithError(stream, error)@A
は、次の手続きを遂行する：
◎
WritableStreamFinishInFlightWriteWithError(stream, error) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`inFlightWriteRequest^sl ~NEQ `undefined^jv
◎
Assert: stream.[[inFlightWriteRequest]] is not undefined.
</li>
	<li>
%error で
%stream.`inFlightWriteRequest^sl を`却下する$
◎
Reject stream.[[inFlightWriteRequest]] with error.
</li>
	<li>
%stream.`inFlightWriteRequest^sl ~SET `undefined^jv
◎
Set stream.[[inFlightWriteRequest]] to undefined.
</li>
	<li>
~Assert：
%stream.`state^sl ~IN { `writable^l, `erroring^l }
◎
Assert: stream.[[state]] is "writable" or "erroring".
</li>
	<li>
~NOABRUPT `WritableStreamDealWithRejection$A( %stream, %error )
◎
Perform ! WritableStreamDealWithRejection(stream, error).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamHasOperationMarkedInFlight(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamHasOperationMarkedInFlight(stream) performs the following steps:
</p>
<ol>
	<li>
~IF［
%stream.`inFlightWriteRequest^sl ~EQ `undefined^jv
］~AND［
%stream.`writableStreamController^sl.`inFlightCloseRequest^sl ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If stream.[[inFlightWriteRequest]] is undefined and stream.[[writableStreamController]].[[inFlightCloseRequest]] is undefined, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamMarkCloseRequestInFlight(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamMarkCloseRequestInFlight(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`inFlightCloseRequest^sl ~EQ `undefined^jv
◎
Assert: stream.[[inFlightCloseRequest]] is undefined.
</li>
	<li>
~Assert：
%stream.`closeRequest^sl ~NEQ `undefined^jv
◎
Assert: stream.[[closeRequest]] is not undefined.
</li>
	<li>
%stream.`inFlightCloseRequest^sl ~SET %stream.`closeRequest^sl
◎
Set stream.[[inFlightCloseRequest]] to stream.[[closeRequest]].
</li>
	<li>
%stream.`closeRequest^sl ~SET `undefined^jv
◎
Set stream.[[closeRequest]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamMarkFirstWriteRequestInFlight(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamMarkFirstWriteRequestInFlight(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`inFlightWriteRequest^sl ~EQ `undefined^jv
◎
Assert: stream.[[inFlightWriteRequest]] is undefined.
</li>
	<li>
~Assert：
%stream.`writeRequests^sl は`空$でない
◎
Assert: stream.[[writeRequests]] is not empty.
</li>
	<li>
%writeRequest ~LET %stream.`writeRequests^sl[0]
◎
Let writeRequest be stream.[[writeRequests]][0].
</li>
	<li>
%stream.`writeRequests^sl から %writeRequest を`除去する$
◎
Remove writeRequest from stream.[[writeRequests]].
</li>
	<li>
%stream.`inFlightWriteRequest^sl ~SET %writeRequest
◎
Set stream.[[inFlightWriteRequest]] to writeRequest.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)@A
は、次の手続きを遂行する：
◎
WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`state^sl ~EQ `errored^l
◎
Assert: stream.[[state]] is "errored".
</li>
	<li>
<p>
~IF［
%stream.`pendingCloseRequest^sl ~NEQ `undefined^jv
］：
◎
If stream.[[closeRequest]] is not undefined,
</p>
		<ol>
			<li>
~Assert：
%stream.`inFlightCloseRequest^sl ~EQ `undefined^jv
◎
Assert: stream.[[inFlightCloseRequest]] is undefined.
</li>
			<li>
%stream.`storedError^sl で %stream.`closeRequest^sl を`却下する$
◎
Reject stream.[[closeRequest]] with stream.[[storedError]].
</li>
			<li>
%stream.`closeRequest^sl ~SET `undefined^jv
◎
Set stream.[[closeRequest]] to undefined.
</li>
		</ol>
	</li>
	<li>
%writer ~LET %stream.`writer^sl
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF［
%writer ~NEQ `undefined^jv
］：
◎
If writer is not undefined,
</p>
		<ol>
			<li>
%stream.`storedError^sl で
%writer.`closedPromise^sl を`却下する$
◎
Reject writer.[[closedPromise]] with stream.[[storedError]].
</li>
			<li>
%writer.`closedPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set writer.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamStartErroring(stream, reason)@A
は、次の手続きを遂行する：
◎
WritableStreamStartErroring(stream, reason) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`storedError^sl ~EQ `undefined^jv
◎
Assert: stream.[[storedError]] is undefined.
</li>
	<li>
~Assert：
%stream.`state^sl ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
%controller ~LET %stream.`writableStreamController^sl
◎
Let controller be stream.[[writableStreamController]].
</li>
	<li>
~Assert：
%controller ~NEQ `undefined^jv
◎
Assert: controller is not undefined.
</li>
	<li>
%stream.`state^sl ~SET `erroring^l
◎
Set stream.[[state]] to "erroring".
</li>
	<li>
%stream.`storedError^sl ~SET %reason
◎
Set stream.[[storedError]] to reason.
</li>
	<li>
%writer ~LET %stream.`writer^sl
◎
Let writer be stream.[[writer]].
</li>
	<li>
~IF［
%writer ~NEQ `undefined^jv
］
⇒
~NOABRUPT `WritableStreamDefaultWriterEnsureReadyPromiseRejected$A( %writer, %reason )
◎
If writer is not undefined, perform ! WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason).
</li>
	<li>
~IF［
~NOABRUPT `WritableStreamHasOperationMarkedInFlight$A( %stream ) ~EQ ~F
］~AND［
%controller.`started^sl ~EQ ~T
］
⇒
~NOABRUPT `WritableStreamFinishErroring$A( %stream )
◎
If ! WritableStreamHasOperationMarkedInFlight(stream) is false and controller.[[started]] is true, perform ! WritableStreamFinishErroring(stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamUpdateBackpressure(stream, backpressure)@A
は、次の手続きを遂行する：
◎
WritableStreamUpdateBackpressure(stream, backpressure) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`state^sl ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
~Assert：
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~F
◎
Assert: ! WritableStreamCloseQueuedOrInFlight(stream) is false.
</li>
	<li>
%writer ~LET %stream.`writer^sl
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF［
%writer ~NEQ `undefined^jv
］~AND［
%backpressure ~NEQ %stream.`backpressure^sl
］：
◎
If writer is not undefined and backpressure is not stream.[[backpressure]],
</p>
		<ol>
			<li>
~IF［
%backpressure ~EQ ~T
］
⇒
%writer.`readyPromise^sl ~SET `新たな~promise$
◎
If backpressure is true, set writer.[[readyPromise]] to a new promise.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise,
</p>
				<ol>
					<li>
~Assert：
%backpressure ~EQ ~F
◎
Assert: backpressure is false.
</li>
					<li>
`undefined^jv で
%writer.`readyPromise^sl を`解決する$
◎
Resolve writer.[[readyPromise]] with undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%stream.`backpressure^sl ~SET %backpressure
◎
Set stream.[[backpressure]] to backpressure.
</li>
</ol>
</div>

			</section>
			<section id="ws-writer-abstract-ops">
<h4 title="Writers">5.5.3. 書込器</h4>

<p>
以下に与える抽象-演算は、
`WritableStreamDefaultWriter$I ~instanceの実装と操作を~supportする。
◎
The following abstract operations support the implementation and manipulation of WritableStreamDefaultWriter instances.
</p>

<div class="algo">
<p>
`WritableStreamDefaultWriterAbort(writer, reason)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterAbort(writer, reason) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %writer.`ownerWritableStream^sl
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamAbort$A( %stream, %reason )
◎
Return ! WritableStreamAbort(stream, reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterClose(writer)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterClose(writer) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %writer.`ownerWritableStream^sl
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamClose$A( %stream )
◎
Return ! WritableStreamClose(stream).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterCloseWithErrorPropagation(writer)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterCloseWithErrorPropagation(writer) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %writer.`ownerWritableStream^sl
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~T
］~OR［
%state ~EQ `closed^l
］
⇒
~RET `undefined^jv で`解決される~promise$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is true or state is "closed", return a promise resolved with undefined.
</li>
	<li>
~IF［
%state ~EQ `errored^l
］
⇒
~RET %stream.`storedError^sl で`却下される~promise$
◎
If state is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~Assert：
%state ~IN { `writable^l, `erroring^l }
◎
Assert: state is "writable" or "erroring".
</li>
	<li>
~RET
~NOABRUPT `WritableStreamDefaultWriterClose$A( %writer )
◎
Return ! WritableStreamDefaultWriterClose(writer).
</li>
</ol>

<p class="note">注記：
この抽象-演算は、 `ReadableStream$I の `pipeTo()$rs における~error伝播の意味論を実装し易くするためにある。
◎
This abstract operation helps implement the error propagation semantics of ReadableStream's pipeTo().
</p>

</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) performs the following steps:
</p>
<ol>
	<li>
~IF［
%writer.`closedPromise^sl.`PromiseState^sl ~EQ `pending^l
］
⇒
%error で %writer.`closedPromise^sl を`却下する$
◎
If writer.[[closedPromise]].[[PromiseState]] is "pending", reject writer.[[closedPromise]] with error.
</li>
	<li>
~ELSE
⇒
%writer.`closedPromise^sl ~SET %error で`却下される~promise$
◎
Otherwise, set writer.[[closedPromise]] to a promise rejected with error.
</li>
	<li>
%writer.`closedPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set writer.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) performs the following steps:
</p>
<ol>
	<li>
~IF［
%writer.`readyPromise^sl.`PromiseState^sl ~EQ `pending^l
］
⇒
%error で %writer.`readyPromise^sl を`却下する$
◎
If writer.[[readyPromise]].[[PromiseState]] is "pending", reject writer.[[readyPromise]] with error.
</li>
	<li>
~ELSE
⇒
%writer.`readyPromise^sl ~SET %error で`却下される~promise$
◎
Otherwise, set writer.[[readyPromise]] to a promise rejected with error.
</li>
	<li>
%writer.`readyPromise^sl.`PromiseIsHandled^sl ~SET ~T
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterGetDesiredSize(writer)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterGetDesiredSize(writer) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %writer.`ownerWritableStream^sl
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~IN { `errored^l, `erroring^l }
］
⇒
~RET ~NULL
◎
If state is "errored" or "erroring", return null.
</li>
	<li>
~IF［
%state ~EQ `closed^l
］
⇒
~RET 0
◎
If state is "closed", return 0.
</li>
	<li>
~RET
~NOABRUPT `WritableStreamDefaultControllerGetDesiredSize$A( %stream.`writableStreamController^sl )
◎
Return ! WritableStreamDefaultControllerGetDesiredSize(stream.[[writableStreamController]]).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterRelease(writer)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterRelease(writer) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %writer.`ownerWritableStream^sl
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
~Assert:
%stream.`writer^sl ~EQ %writer
◎
Assert: stream.[[writer]] is writer.
</li>
	<li>
%releasedError ~LET 新たな `TypeError^jE
◎
Let releasedError be a new TypeError.
</li>
	<li>
~NOABRUPT `WritableStreamDefaultWriterEnsureReadyPromiseRejected$A( %writer, %releasedError)
◎
Perform ! WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError).
</li>
	<li>
~NOABRUPT `WritableStreamDefaultWriterEnsureClosedPromiseRejected$A( %writer, %releasedError)
◎
Perform ! WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError).
</li>
	<li>
%stream.`writer^sl ~SET `undefined^jv
◎
Set stream.[[writer]] to undefined.
</li>
	<li>
%writer.`ownerWritableStream^sl ~SET `undefined^jv
◎
Set writer.[[ownerWritableStream]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultWriterWrite(writer, chunk)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultWriterWrite(writer, chunk) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %writer.`ownerWritableStream^sl
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ `undefined^jv
◎
Assert: stream is not undefined.
</li>
	<li>
%controller ~LET %stream.`writableStreamController^sl
◎
Let controller be stream.[[writableStreamController]].
</li>
	<li>
%chunkSize ~LET
~NOABRUPT `WritableStreamDefaultControllerGetChunkSize$A(%controller, %chunk)
◎
Let chunkSize be ! WritableStreamDefaultControllerGetChunkSize(controller, chunk).
</li>
	<li>
~IF［
%stream ~NEQ %writer.`ownerWritableStream^sl
］
⇒
~RET `TypeError^jE で`却下される~promise$
◎
If stream is not equal to writer.[[ownerWritableStream]], return a promise rejected with a TypeError exception.
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~EQ `errored^l
］
⇒
~RET %stream.`storedError^sl で`却下される~promise$
◎
If state is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~T
］~OR［
%state ~NEQ `closed^l
］
⇒
~RET `TypeError^jE で`却下される~promise$
— これは、~streamは~close中にあるか~closeされたことを指示する。
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is true or state is "closed", return a promise rejected with a TypeError exception indicating that the stream is closing or closed.
</li>
	<li>
~IF［
%state ~EQ `erroring^l
］
⇒
~RET %stream.`storedError^sl で`却下される~promise$
◎
If state is "erroring", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
%promise ~LET
~NOABRUPT `WritableStreamAddWriteRequest$A( %stream )
◎
Let promise be ! WritableStreamAddWriteRequest(stream).
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerWrite$A( %controller, %chunk, %chunkSize )
◎
Perform ! WritableStreamDefaultControllerWrite(controller, chunk, chunkSize).
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

			</section>
			<section id="ws-default-controller-abstract-ops">
<h4 title="Default controllers">5.5.4. 既定の制御器</h4>

<p>
以下に与える抽象-演算は、
`WritableStreamDefaultController$I ~classの実装を~supportする。
◎
The following abstract operations support the implementation of the WritableStreamDefaultController class.
</p>

<div class="algo">
<p>
`SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm)@A
は、次の手続きを遂行する：
◎
SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream は `WritableStream$I を`実装する$。
◎
Assert: stream implements WritableStream.
</li>
	<li>
~Assert：
%stream.`writableStreamController^sl ~EQ `undefined^jv
◎
Assert: stream.[[writableStreamController]] is undefined.
</li>
	<li>
%controller.`controlledWritableStream^sl ~SET %stream
◎
Set controller.[[controlledWritableStream]] to stream.
</li>
	<li>
%stream.`writableStreamController^sl ~SET %controller
◎
Set stream.[[writableStreamController]] to controller.
</li>
	<li>
~NOABRUPT `ResetQueue$A( %controller )
◎
Perform ! ResetQueue(controller).
</li>
	<li>
%controller の
⇒＃
.`started^sl ~SET ~F,
.`strategySizeAlgorithm^sl ~SET %sizeAlgorithm,
.`strategyHWM^sl ~SET %highWaterMark,
.`writeAlgorithm^sl ~SET %writeAlgorithm,
.`closeAlgorithm^sl ~SET %closeAlgorithm,
.`abortAlgorithm^sl ~SET %abortAlgorithm
◎
Set controller.[[started]] to false.
◎
Set controller.[[strategySizeAlgorithm]] to sizeAlgorithm.
◎
Set controller.[[strategyHWM]] to highWaterMark.
◎
Set controller.[[writeAlgorithm]] to writeAlgorithm.
◎
Set controller.[[closeAlgorithm]] to closeAlgorithm.
◎
Set controller.[[abortAlgorithm]] to abortAlgorithm.
</li>
	<li>
%backpressure ~LET
~NOABRUPT `WritableStreamDefaultControllerGetBackpressure$A( %controller )
◎
Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(controller).
</li>
	<li>
~NOABRUPT `WritableStreamUpdateBackpressure$A( %stream, %backpressure )
◎
Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
</li>
	<li>
%startResult ~LET %startAlgorithm()
（これは、例外を投出するかもしれない）
◎
Let startResult be the result of performing startAlgorithm. (This may throw an exception.)
</li>
	<li>
<p>
%startPromise ~LET %startResult で`解決される~promise$
◎
Let startPromise be a promise resolved with startResult.
</p>
		<ul>
			<li>
<p>
%startPromise の`充足-時$には：
◎
Upon fulfillment of startPromise,
</p>
				<ol>
					<li>
~Assert：
%stream.`state^sl ~IN { `writable^l, `erroring^l }
◎
Assert: stream.[[state]] is "writable" or "erroring".
</li>
					<li>
%controller.`started^sl ~SET ~T
◎
Set controller.[[started]] to true.
</li>
					<li>
~NOABRUPT `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r による %startPromise の`却下-時$には：
◎
Upon rejection of startPromise with reason r,
</p>
				<ol>
					<li>
~Assert：
%stream.`state^sl ~IN { `writable^l, `erroring^l }
◎
Assert: stream.[[state]] is "writable" or "erroring".
</li>
					<li>
%controller.`started^sl ~SET ~T
◎
Set controller.[[started]] to true.
</li>
					<li>
~NOABRUPT `WritableStreamDealWithRejection$A( %stream, %r )
◎
Perform ! WritableStreamDealWithRejection(stream, r).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, underlyingSinkDict, highWaterMark, sizeAlgorithm)@A
は、次の手続きを遂行する：
◎
SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, underlyingSinkDict, highWaterMark, sizeAlgorithm) performs the following steps:
</p>
<ol>
	<li>
%controller ~LET `新たな$ `WritableStreamDefaultController$I
◎
Let controller be a new WritableStreamDefaultController.
</li>
	<li>
%startAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv
◎
Let startAlgorithm be an algorithm that returns undefined.
</li>
	<li>
%writeAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let writeAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
%closeAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let closeAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
%abortAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let abortAlgorithm be an algorithm that returns a promise resolved with undefined.
</li>
	<li>
~IF［
%underlyingSinkDict[ "`start$usk" ] ~NEQ ε
］
⇒
%startAlgorithm ~SET 次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSinkDict[ "`start$usk" ], « %controller », %underlyingSink )
◎
If underlyingSinkDict["start"] exists, then set startAlgorithm to an algorithm which returns the result of invoking underlyingSinkDict["start"] with argument list « controller » and callback this value underlyingSink.
</li>
	<li>
~IF［
%underlyingSinkDict[ "`write$usk" ] ~NEQ ε
］
⇒
%writeAlgorithm ~SET 所与の ( %chunk ) に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSinkDict[ "`write$usk" ], 
引数~list « %chunk, %controller », %underlyingSink )
。
◎
If underlyingSinkDict["write"] exists, then set writeAlgorithm to an algorithm which takes an argument chunk and returns the result of invoking underlyingSinkDict["write"] with argument list « chunk, controller » and callback this value underlyingSink.
</li>
	<li>
~IF［
%underlyingSinkDict[ "`close$usk" ] ~NEQ ε
］
⇒
%closeAlgorithm ~SET 次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSinkDict[ "`close$usk" ], «», %underlyingSink )
◎
If underlyingSinkDict["close"] exists, then set closeAlgorithm to an algorithm which returns the result of invoking underlyingSinkDict["close"] with argument list «» and callback this value underlyingSink.
</li>
	<li>
~IF［
%underlyingSinkDict[ "`abort$usk" ] ~NEQ ε
］
⇒
%abortAlgorithm ~SET 所与の ( %reason ) に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %underlyingSinkDict[ "`abort$usk" ], « %reason », %underlyingSink )
◎
If underlyingSinkDict["abort"] exists, then set abortAlgorithm to an algorithm which takes an argument reason and returns the result of invoking underlyingSinkDict["abort"] with argument list « reason » and callback this value underlyingSink.
</li>
	<li>
~ABRUPT `SetUpWritableStreamDefaultController$A( %stream, %controller, %startAlgorithm, %writeAlgorithm, %closeAlgorithm, %abortAlgorithm, %highWaterMark, %sizeAlgorithm )
◎
Perform ? SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledWritableStream^sl
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
~IF［
%controller.`started^sl ~EQ ~F
］
⇒
~RET
◎
If controller.[[started]] is false, return.
</li>
	<li>
~IF［
%stream.`inFlightWriteRequest^sl ~NEQ `undefined^jv
］
⇒
~RET
◎
If stream.[[inFlightWriteRequest]] is not undefined, return.
</li>
	<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
	<li>
~Assert：
%state ~NIN { `closed^l, `errored^l }
◎
Assert: state is not "closed" or "errored".
</li>
	<li>
<p>
~IF［
%state ~EQ `erroring^l
］：
◎
If state is "erroring",
</p>
		<ol>
			<li>
~NOABRUPT `WritableStreamFinishErroring$A( %stream )
◎
Perform ! WritableStreamFinishErroring(stream).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~IF［
%controller.`queue^sl は空である
］
⇒
~RET
◎
If controller.[[queue]] is empty, return.
</li>
	<li>
%value ~LET 
~NOABRUPT `PeekQueueValue$A( %controller )
◎
Let value be ! PeekQueueValue(controller).
</li>
	<li>
~IF［
%value ~EQ `~close~sentinel$i
］
⇒
~NOABRUPT `WritableStreamDefaultControllerProcessClose$A( %controller )
◎
If value is the close sentinel, perform ! WritableStreamDefaultControllerProcessClose(controller).
</li>
	<li>
~ELSE
⇒
~NOABRUPT `WritableStreamDefaultControllerProcessWrite$A( %controller, %value )
◎
Otherwise, perform ! WritableStreamDefaultControllerProcessWrite(controller, value).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerClearAlgorithms(controller)@A
は、~streamが~closeされるか~errorして，各種~algoが それ以上~実行されなくなったときに~callされる。
これは、各種~algoへの参照を除去することにより，`下層~槽$（ `WritableStream$I ~obj）自身が
— まだ参照されていても —
~garbage収集されることを許可する。
◎
WritableStreamDefaultControllerClearAlgorithms(controller) is called once the stream is closed or errored and the algorithms will not be executed any more. By removing the algorithm references it permits the underlying sink object to be garbage collected even if the WritableStream itself is still referenced.
</p>

<p class="note">注記：
これは、<a href="https://github.com/tc39/proposal-weakrefs/">弱い参照</a>を利用すると観測-可能になる。
詳細は
<a href="https://github.com/tc39/proposal-weakrefs/issues/31">tc39/proposal-weakrefs#31</a>
を見よ。
◎
This is observable using weak references. See tc39/proposal-weakrefs#31 for more detail.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%controller の
⇒＃
.`writeAlgorithm^sl ~SET `undefined^jv,
.`closeAlgorithm^sl ~SET `undefined^jv,
.`abortAlgorithm^sl ~SET `undefined^jv,
.`strategySizeAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[writeAlgorithm]] to undefined.
◎
Set controller.[[closeAlgorithm]] to undefined.
◎
Set controller.[[abortAlgorithm]] to undefined.
◎
Set controller.[[strategySizeAlgorithm]] to undefined.
</li>
</ol>

<p class="note">
この~algoは、一部の~~際どい事例では複数回 遂行されることになるが，
2 回目~以降は何もしない。
◎
This algorithm will be performed multiple times in some edge cases. After the first time it will do nothing.
</p>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerClose(controller)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerClose(controller) performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `EnqueueValueWithSize$A( %controller, `~close~sentinel$i, 0 )
◎
Perform ! EnqueueValueWithSize(controller, close sentinel, 0).
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerError(controller, error)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerError(controller, error) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledWritableStream^sl
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
~Assert：
%stream.`state^sl ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerClearAlgorithms$A( %controller )
◎
Perform ! WritableStreamDefaultControllerClearAlgorithms(controller).
</li>
	<li>
~NOABRUPT `WritableStreamStartErroring$A( %stream, %error )
◎
Perform ! WritableStreamStartErroring(stream, error).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerErrorIfNeeded(controller, error)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerErrorIfNeeded(controller, error) performs the following steps:
</p>
<ol>
	<li>
~IF［
%controller.`controlledWritableStream^sl.`state^sl ~EQ `writable^l
］
⇒
~NOABRUPT `WritableStreamDefaultControllerError$A( %controller, %error )
◎
If controller.[[controlledWritableStream]].[[state]] is "writable", perform ! WritableStreamDefaultControllerError(controller, error).
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerGetBackpressure(controller)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerGetBackpressure(controller) performs the following steps:
</p>
<ol>
	<li>
%desiredSize ~LET
~NOABRUPT `WritableStreamDefaultControllerGetDesiredSize$A( %controller )
◎
Let desiredSize be ! WritableStreamDefaultControllerGetDesiredSize(controller).
</li>
	<li>
~RET 次が満たされるならば ~T ／
~ELSE_ ~F
⇒
%desiredSize ~LTE 0
◎
Return true if desiredSize ≤ 0, or false otherwise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerGetChunkSize(controller, chunk)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerGetChunkSize(controller, chunk) performs the following steps:
</p>
<ol>
	<li>
%returnValue ~LET 次を遂行した結果を`完了~record$として解釈した結果
⇒
%controller.`strategySizeAlgorithm^sl( %chunk )
◎
Let returnValue be the result of performing controller.[[strategySizeAlgorithm]], passing in chunk, and interpreting the result as a completion record.
</li>
	<li>
<p>
~IF［
%returnValue は`中途完了^である
］：
◎
If returnValue is an abrupt completion,
</p>
		<ol>
			<li>
~NOABRUPT `WritableStreamDefaultControllerErrorIfNeeded$A( %controller, %returnValue.`Value^sl )
◎
Perform ! WritableStreamDefaultControllerErrorIfNeeded(controller, returnValue.[[Value]]).
</li>
			<li>
~RET 1
◎
Return 1.
</li>
		</ol>
	</li>
	<li>
~RET %returnValue.`Value^sl
◎
Return returnValue.[[Value]].
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerGetDesiredSize(controller)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerGetDesiredSize(controller) performs the following steps:
</p>
<ol>
	<li>
~RET %controller.`strategyHWM^sl ~MINUS %controller.`queueTotalSize^sl
◎
Return controller.[[strategyHWM]] − controller.[[queueTotalSize]].
</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerProcessClose(controller)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerProcessClose(controller) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledWritableStream^sl
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
~NOABRUPT `WritableStreamMarkCloseRequestInFlight$A( %stream )
◎
Perform ! WritableStreamMarkCloseRequestInFlight(stream).
</li>
	<li>
~NOABRUPT `DequeueValue$A( %controller )
◎
Perform ! DequeueValue(controller).
</li>
	<li>
~Assert：
%controller.`queue^sl は空である
◎
Assert: controller.[[queue]] is empty.
</li>
	<li>
%sinkClosePromise ~LET %controller.`closeAlgorithm^sl()
◎
Let sinkClosePromise be the result of performing controller.[[closeAlgorithm]].
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerClearAlgorithms$A( %controller )
◎
Perform ! WritableStreamDefaultControllerClearAlgorithms(controller).
</li>
	<li>
		<ul>
			<li>
<p>
%sinkClosePromise の`充足-時$には：
◎
Upon fulfillment of sinkClosePromise,
</p>
				<ol>
					<li>
~NOABRUPT `WritableStreamFinishInFlightClose$A( %stream )
◎
Perform ! WritableStreamFinishInFlightClose(stream).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %reason による
%sinkClosePromise の`却下-時$には：
◎
Upon rejection of sinkClosePromise with reason reason,
</p>
				<ol>
					<li>
~NOABRUPT `WritableStreamFinishInFlightCloseWithError$A( %stream, %reason )
◎
Perform ! WritableStreamFinishInFlightCloseWithError(stream, reason).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerProcessWrite(controller, chunk)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerProcessWrite(controller, chunk) performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledWritableStream^sl
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
~NOABRUPT `WritableStreamMarkFirstWriteRequestInFlight$A( %stream )
◎
Perform ! WritableStreamMarkFirstWriteRequestInFlight(stream).
</li>
	<li>
<p>
%sinkWritePromise ~LET %controller.`writeAlgorithm^sl( %chunk )
◎
Let sinkWritePromise be the result of performing controller.[[writeAlgorithm]], passing in chunk.
</p>

		<ul>
			<li>
<p>
%sinkWritePromise の`充足-時$には：
◎
Upon fulfillment of sinkWritePromise,
</p>
				<ol>
					<li>
~NOABRUPT `WritableStreamFinishInFlightWrite$A( %stream )
◎
Perform ! WritableStreamFinishInFlightWrite(stream).
</li>
					<li>
%state ~LET %stream.`state^sl
◎
Let state be stream.[[state]].
</li>
					<li>
~Assert：
%state ~IN { `writable^l, `erroring^l }
◎
Assert: state is "writable" or "erroring".
</li>
					<li>
~NOABRUPT `DequeueValue$A( %controller )
◎
Perform ! DequeueValue(controller).
</li>
					<li>
<p>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A(stream) ~EQ ~F
］~AND［
%state ~EQ `writable^l
］：
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false and state is "writable",
</p>
						<ol>
							<li>
%backpressure ~LET
~NOABRUPT `WritableStreamDefaultControllerGetBackpressure$A( %controller )
◎
Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(controller).
</li>
							<li>
~NOABRUPT `WritableStreamUpdateBackpressure$A( %stream, %backpressure )
◎
Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
</li>
						</ol>
					</li>
					<li>
~NOABRUPT `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %reason による
%sinkWritePromise の`却下-時$には：
◎
Upon rejection of sinkWritePromise with reason,
</p>
				<ol>
					<li>
~IF［
%stream.`state^sl ~EQ `writable^l
］
⇒
~NOABRUPT `WritableStreamDefaultControllerClearAlgorithms$A( %controller )
◎
If stream.[[state]] is "writable", perform ! WritableStreamDefaultControllerClearAlgorithms(controller).
</li>
					<li>
~NOABRUPT `WritableStreamFinishInFlightWriteWithError$A( %stream, %reason )
◎
Perform ! WritableStreamFinishInFlightWriteWithError(stream, reason).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`WritableStreamDefaultControllerWrite(controller, chunk, chunkSize)@A
は、次の手続きを遂行する：
◎
WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) performs the following steps:
</p>
<ol>
	<li>
%enqueueResult ~LET
`EnqueueValueWithSize$A( %controller, %chunk, %chunkSize )
◎
Let enqueueResult be EnqueueValueWithSize(controller, chunk, chunkSize).
</li>
	<li>
<p>
~IF［
%enqueueResult は`中途完了^である
］：
◎
If enqueueResult is an abrupt completion,
</p>
		<ol>
			<li>
~NOABRUPT `WritableStreamDefaultControllerErrorIfNeeded$A( %controller, %enqueueResult.`Value^sl )
◎
Perform ! WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueResult.[[Value]]).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%stream ~LET %controller.`controlledWritableStream^sl
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
<p>
~IF［
~NOABRUPT `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~F
］~AND［
%stream.`state^sl ~EQ `writable^l
］
：
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[state]] is "writable",
</p>
		<ol>
			<li>
%backpressure ~LET
~NOABRUPT `WritableStreamDefaultControllerGetBackpressure$A( %controller )
◎
Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(controller).
</li>
			<li>
~NOABRUPT `WritableStreamUpdateBackpressure$A( %stream, %backpressure )
◎
Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
</li>
		</ol>
	</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="ts">
<h2 title="Transform streams">6. 形式変換~stream</h2>

		<section id="ts-intro">
<h3 title="Using transform streams">6.1. 形式変換~streamの利用-法</h3>

<div class="example" id="example-basic-pipe-through">

<p>
形式変換~streamを利用する自然な仕方は、それを`可読~stream$と`可書~stream$の間の`~pipe$に置くことである。
`可読~stream$から`可書~stream$へ旅する`~chunk$たちは、形式変換~streamを通過する際に形式変換されることになる。
`背圧$は尊重されるので、形式変換して消費できるより高速に~dataが読取されることはない。
◎
The natural way to use a transform stream is to place it in a pipe between a readable stream and a writable stream. Chunks that travel from the readable stream to the writable stream will be transformed as they pass through the transform stream. Backpressure is respected, so data will not be read faster than it can be transformed and consumed.
</p>

<pre class="lang-js">
%readableStream
  .pipeThrough(%transformStream)
  .pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に形式変換されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>
</div>

<!-- 
All data successfully transformed!
 -->

<div class="example" id="example-transform-stream-properties">

<p>
形式変換~streamの［
`readable$ts ／ `writable$ts
］~propを利用すれば、［
`可読~stream$ ／ `可書~stream$
］を成す通例の~interfaceに直に~accessできる。
この例では、~streamの`書込器$~interfaceを利用して，`可書~側$に~dataを給してから、`可読~側$を %anotherWritableStream に~pipeする。
◎
You can also use the readable and writable properties of a transform stream directly to access the usual interfaces of a readable stream and writable stream. In this example we supply data to the writable side of the stream using its writer interface. The readable side is then piped to anotherWritableStream.
</p>

<pre class="lang-js">
const %writer = %transformStream.writable.getWriter();
%writer.write(`input chunk^l);
%transformStream.readable.pipeTo(%anotherWritableStream);
</pre>

</div>

<div class="example" id="example-transform-identity">

<p>
`~identity形式変換~stream$には、可読~streamと可書~streamとの間を容易に変換する利用がある。
例えば `fetch()$m ~APIは、`要請~本体$を可読~streamとして受容するが、
可書~stream~interfaceを介して~upload用の~dataを書込できれば，もっと簡便になる。
~identity形式変換~streamは、これに取組む：
◎
One use of identity transform streams is to easily convert between readable and writable streams. For example, the fetch() API accepts a readable stream request body, but it can be more convenient to write data for uploading via a writable stream interface. Using an identity transform stream addresses this:
</p>

<pre class="lang-js">
const { %writable, %readable } = new TransformStream();
fetch(`...^l, { body: %readable }).then(%response =&gt; /* ... */);

const %writer = %writable.getWriter();
%writer.write(new Uint8Array([0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x73, 0x21]));
%writer.close();
</pre>

<p>
~identity形式変換~streamの別の利用は、追加的な~bufferingを`~pipe$に追加することである。
この例では、 %readableStream と %writableStream の間に余分な~bufferingを追加する。
◎
Another use of identity transform streams is to add additional buffering to a pipe. In this example we add extra buffering between readableStream and writableStream.
</p>

<pre class="lang-js">
const %writableStrategy = new ByteLengthQueuingStrategy({ highWaterMark: 1024 * 1024 });

%readableStream
  .pipeThrough(new TransformStream(undefined, %writableStrategy))
  .pipeTo(%writableStream);
</pre>

</div>

		</section>
		<section id="ts-class">
<h3 title="The TransformStream class">6.2. `TransformStream^I ~class</h3>

<p>
`TransformStream$I ~classは、`形式変換~stream$の一般~概念の具象-~instanceを成す。
◎
The TransformStream class is a concrete instance of the general transform stream concept.
</p>

			<section id="ts-class-definition">
<h4 title="Interface definition">6.2.1. ~interface定義</h4>

<p>
`TransformStream$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the TransformStream class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `TransformStream@I {
  `TransformStream$mc(optional `object$ %transformer,
              optional `QueuingStrategy$I %writableStrategy = {},
              optional `QueuingStrategy$I %readableStrategy = {});

  readonly attribute `ReadableStream$I `readable$ts;
  readonly attribute `WritableStream$I `writable$ts;
};
</pre>

			</section>
			<section id="ts-internal-slots">
<h4 title="Internal slots">6.2.2. 内部~slot</h4>

<p>
`TransformStream$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of TransformStream are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`backpressure^sl
<td>
最後に観測された時点で `readable^sl 上に背圧があったかどうか。
◎
Whether there was backpressure on [[readable]] the last time it was observed

<tr><td>`backpressureChangePromise^sl
<td>
`backpressure^sl の値が変更されるたびに，充足され, 置換される~promise。
◎
A promise which is fulfilled and replaced every time the value of [[backpressure]] changes

<tr><td>`readable^sl
<td>
この~objにより制御される `ReadableStream$I ~instance
◎
The ReadableStream instance controlled by this object

<tr><td>`transformStreamController^sl
<td>
`readable^sl, `writable^sl
を制御する能を伴って作成される，ある `TransformStreamDefaultController$I
。
◎
A TransformStreamDefaultController created with the ability to control [[readable]] and [[writable]]

<tr><td>`writable^sl
<td>
この~objにより制御される `WritableStream$I ~instance
◎
The WritableStream instance controlled by this object
</tbody></table>

			</section>
			<section id="transformer-api">
<h4 title="The transformer API">6.2.3. 形式変換器~API</h4>

<p>
`new TransformStream()$m
構築子は、 1 個目の引数に［
`形式変換器$を表現している~JS~obj
］を受容する。
そのような~objには、次に挙げる~methodを包含させられる：
◎
The TransformStream() constructor accepts as its first argument a JavaScript object representing the transformer. Such objects can contain any of the following methods:
</p>

<pre class="idl">
dictionary `Transformer@I {
  `TransformerStartCallback$I `start$tf;
  `TransformerTransformCallback$I `transform$tf;
  `TransformerFlushCallback$I `flush$tf;
  any `readableType$tf;
  any `writableType$tf;
};

callback `TransformerStartCallback@I = any (`TransformStreamDefaultController$I %controller);
callback `TransformerFlushCallback@I = Promise&lt;void&gt; (`TransformStreamDefaultController$I %controller);
callback `TransformerTransformCallback@I = Promise&lt;void&gt; (any %chunk, `TransformStreamDefaultController$I %controller);
</pre>

<dl>
	<dt>
`start(controller)@tf
（ `TransformerStartCallback$I 型）
◎
start(controller), of type TransformerStartCallback
</dt>
	<dd>
この関数は、 `TransformStream$I を作成する間に即時に~callされる。
◎
A function that is called immediately during creation of the TransformStream.
</dd>
	<dd>
これは概して、［
<code>%controller.`enqueue()$tsdc</code>
を利用して，接頭-`~chunk$を~enqueueする
］ために利用される。
それらの~chunkは、`可読~側$から読取されるが，`可書~側$へのどの書込nにも依存しないことになる。
◎
Typically this is used to enqueue prefix chunks, using controller.enqueue(). Those chunks will be read from the readable side but don’t depend on any writes to the writable side.
</dd>
	<dd>
この処理nが非同期的になる場合
— 例えば、接頭-~chunkたちを獲得するのに 多少の労が~~要るために —
この関数は，成否を通達する~promiseを返すようにすることもできる：
却下される~promiseは、~streamを~errorにすることになる。
投出された例外は、
`new TransformStream()$m
構築子により投出し直されることになる。
◎
If this initial process is asynchronous, for example because it takes some effort to acquire the prefix chunks, the function can return a promise to signal success or failure; a rejected promise will error the stream. Any thrown exceptions will be re-thrown by the TransformStream() constructor.
</dd>

	<dt>
`transform(chunk, controller)@tf
（ `TransformerTransformCallback$I 型）
◎
transform(chunk, controller), of type TransformerTransformCallback
</dt>
	<dd>
この関数は、［
元々は`可書~側$に書込された新たな`~chunk$が，形式変換~用に準備済みになった
］とき，~callされる。
~stream実装は、この関数が~callされるのは，以前の形式変換が成功した後に限られ, かつ［
`start()$tf が完了する前 ／
`flush()$tf ~callされた後
］には決してならないことを保証する。
◎
A function called when a new chunk originally written to the writable side is ready to be transformed. The stream implementation guarantees that this function will be called only after previous transforms have succeeded, and never before start() has completed or after flush() has been called.
</dd>
	<dd>
この関数は、形式変換~streamにおける実際の形式変換n作業を遂行する。
その結果は、
<code>%controller.`enqueue()$tsdc</code>
を利用して，~enqueueできる。
ここでは、［
可書~側に 1 個の~chunkが書込されたときの結果が，`可読~側$では 0 個または複数個の~chunkになる
］ことも許可される
— 
<code>%controller.`enqueue()$tsdc</code>
が何回~callされたかに依存して。
`~template内の~tagを置換する形式変換~stream$secでは、ときどき 0 個の~chunkを~enqueueして，これをデモっている。
◎
This function performs the actual transformation work of the transform stream. It can enqueue the results using controller.enqueue(). This permits a single chunk written to the writable side to result in zero or multiple chunks on the readable side, depending on how many times controller.enqueue() is called. § 9.9 A transform stream that replaces template tags demonstrates this by sometimes enqueuing zero chunks.
</dd>
	<dd>
形式変換~処理nが非同期的になる場合、この関数は，形式変換nの成否を通達する~promiseを返すようにすることもできる：
却下される~promiseは、形式変換~streamの可読~側, 可書~側 両方を~errorにすることになる。
◎
If the process of transforming is asynchronous, this function can return a promise to signal success or failure of the transformation. A rejected promise will error both the readable and writable sides of the transform stream.
</dd>
	<dd>
`transform()$tf ~methodが給されなかった場合、~identity形式変換が利用される
— それは、可書~側からの~chunkをそのまま可読~側に~enqueueする。
◎
If no transform() method is supplied, the identity transform is used, which enqueues chunks unchanged from the writable side to the readable side.
</dd>

	<dt>
`flush(controller)@tf
（ `TransformerFlushCallback$I 型）
◎
flush(controller), of type TransformerFlushCallback
</dt>
	<dd>
この関数は、［
`可書~側$にすべての`~chunk$が書込され,
`transform()$tf を成功裡に通過して形式変換された後，可書~側が~closeされつつある
］とき，~callされる。
◎
A function called after all chunks written to the writable side have been transformed by successfully passing through transform(), and the writable side is about to be closed.
</dd>
	<dd>
これは概して、`可読~側$に
— それも~closeされる前に —
接尾-~chunkたちを~enqueueするために利用される。
その例は、`~template内の~tagを置換する形式変換~stream$secに見れる。
◎
Typically this is used to enqueue suffix chunks to the readable side, before that too becomes closed. An example can be seen in § 9.9 A transform stream that replaces template tags.
</dd>
	<dd>
この書出し処理nが非同期的になる場合、この関数は，成否を通達する~promiseを返すようにすることもできる：
その結果は、
<code>%stream.`writable$ts.`write()$dw</code>
の~call元へ通信されることになる。
加えて，却下される~promiseは、可読~側, 可書~側の両~streamとも~errorにすることになる。
例外を投出した場合、却下される~promiseを返すのと同じに扱われる。
◎
If the flushing process is asynchronous, the function can return a promise to signal success or failure; the result will be communicated to the caller of stream.writable.write(). Additionally, a rejected promise will error both the readable and writable sides of the stream. Throwing an exception is treated the same as returning a rejected promise.
</dd>
	<dd>
（
`flush()$tf の内側で
<code>%controller.`terminate()$tsdc</code>
を~callする必要は無いことに注意。
~streamは，すでに成功裡に~closeし終える処理nにあり、それを終了するのは非生産的になる）。
◎
(Note that there is no need to call controller.terminate() inside flush(); the stream is already in the process of successfully closing down, and terminating it would be counterproductive.)
</dd>

	<dt>
`readableType@tf
（ `any$I 型）
◎
readableType, of type any
</dt>
	<dd>
この~propは，将来の利用-用に予約されており、値を給するどの試みに対しても，例外を投出することになる。
◎
This property is reserved for future use, so any attempts to supply a value will throw an exception.
</dd>

	<dt>
`writableType@tf
（ `any$I 型）
◎
writableType, of type any
</dt>
	<dd>
この~propは，将来の利用-用に予約されており、値を給するどの試みに対しても，例外を投出することになる。
◎
This property is reserved for future use, so any attempts to supply a value will throw an exception.
</dd>
</dl>

<p>
［
`start()$tf ／ `transform()$tf ／ `flush()$tf
］に渡される %controller ~objは、
`TransformStreamDefaultController$I の~instanceであり，次に挙げる能を備える
⇒＃
`~chunk$を`可読~側$に~enqueueする／
~streamを終了する／
~streamを~errorにする
◎
The controller object passed to start(), transform(), and flush() is an instance of TransformStreamDefaultController, and has the ability to enqueue chunks to the readable side, or to terminate or error the stream.
</p>

			</section>
			<section id="ts-prototype">
<h4 title="Constructor and properties">6.2.4. 構築子, ~prop</h4>

<dl class="domintro">
	<dt>%stream = `new TransformStream([transformer[, writableStrategy[, readableStrategy]]])$m</dt>
	<dd>
供された`形式変換器$を包装している新たな `TransformStream$I を作成する。
%transformer 引数についての詳細は、`形式変換器~API$secを見よ。
◎
Creates a new TransformStream wrapping the provided transformer. See § 6.2.3 The transformer API for more details on the transformer argument.
</dd>
	<dd>
%transformer 引数が給されなかった場合、結果は`~identity形式変換~stream$になる。
それが有用になり得る事例は、<a href="#example-transform-identity">この例</a>を見よ。
◎
If no transformer argument is supplied, then the result will be an identity transform stream. See this example for some cases where that can be useful.
</dd>
	<dd>
［
%writableStrategy ／ %readableStrategy
］引数（以下同順）は［
可書~側／可読~側
］用の`~queuing策$~objを与える。
これらは，［
`WritableStream$I ／ `ReadableStream$I
］~objの構築に利用され、［［
形式変換nを円滑に変速したり, `~pipe$内に~bufferする量を増やす
］ために， `TransformStream$I に~bufferingを追加する
］ときにも利用され得る。
それぞれ，供されなかった場合の既定の挙動は、`限界水位$［
1 ／ 0
］にされた `CountQueuingStrategy$I と同じになる。
◎
The writableStrategy and readableStrategy arguments are the queuing strategy objects for the writable and readable sides respectively. These are used in the construction of the WritableStream and ReadableStream objects and can be used to add buffering to a TransformStream, in order to smooth out variations in the speed of the transformation, or to increase the amount of buffering in a pipe. If they are not provided, the default behavior will be the same as a CountQueuingStrategy, with respective high water marks of 1 and 0.
</dd>

	<dt>%readable = %stream.`readable$ts</dt>
	<dd>
この形式変換~streamの`可読~側$を表現している `ReadableStream$I を返す。
◎
Returns a ReadableStream representing the readable side of this transform stream.
</dd>

	<dt>%writable = %stream.`writable$ts</dt>
	<dd>
この形式変換~streamの`可書~側$を表現している `WritableStream$I を返す。
◎
Returns a WritableStream representing the writable side of this transform stream.
</dd>
</dl>

<div class="algo">
<p>
`new TransformStream(transformer, writableStrategy, readableStrategy)@m
構築子~手続きは：
◎
The TransformStream(transformer, writableStrategy, readableStrategy) constructor steps are:
</p>
<ol>
	<li>
~IF［
%transformer ~EQ ε
］
⇒
%transformer ~SET ~NULL
◎
If transformer is missing, set it to null.
</li>
	<li>
<p>
%transformerDict ~LET %transformer を `Transformer$I 型の`~IDL値に変換-$した結果
◎
Let transformerDict be transformer, converted to an IDL value of type Transformer.
</p>

<p class="note">注記：
%transformer 引数を `Transformer$I 型として直に宣言できないのは、元の~objへの参照が失われるからである。
~obj上の各種`~methodを呼出せる$よう、~objは維持する必要がある。
◎
We cannot declare the transformer argument as having the Transformer type directly, because doing so would lose the reference to the original object. We need to retain the object so we can invoke the various methods on it.
</p>
	</li>
	<li>
~IF［
%transformerDict[ "`readableType$tf" ] ~NEQ ε
］
⇒
~THROW `RangeError$E
◎
If transformerDict["readableType"] exists, throw a RangeError exception.
</li>
	<li>
~IF［
%transformerDict[ "`writableType$tf" ] ~NEQ ε
］
⇒
~THROW `RangeError$E
◎
If transformerDict["writableType"] exists, throw a RangeError exception.
</li>
	<li>
%readableHighWaterMark ~LET
~ABRUPT `ExtractHighWaterMark$A( %readableStrategy, 0)
◎
Let readableHighWaterMark be ? ExtractHighWaterMark(readableStrategy, 0).
</li>
	<li>
%readableSizeAlgorithm ~LET
~NOABRUPT `ExtractSizeAlgorithm$A( %readableStrategy )
◎
Let readableSizeAlgorithm be ! ExtractSizeAlgorithm(readableStrategy).
</li>
	<li>
%writableHighWaterMark ~LET
~ABRUPT `ExtractHighWaterMark$A( %writableStrategy, 1)
◎
Let writableHighWaterMark be ? ExtractHighWaterMark(writableStrategy, 1).
</li>
	<li>
%writableSizeAlgorithm ~LET
~NOABRUPT `ExtractSizeAlgorithm$A( %writableStrategy )
◎
Let writableSizeAlgorithm be ! ExtractSizeAlgorithm(writableStrategy).
</li>
	<li>
%startPromise ~LET `新たな~promise$
◎
Let startPromise be a new promise.
</li>
	<li>
~NOABRUPT `InitializeTransformStream$A(
コレ,
%startPromise,
%writableHighWaterMark,
%writableSizeAlgorithm,
%readableHighWaterMark,
%readableSizeAlgorithm
)
◎
Perform ! InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm).
</li>
	<li>
~ABRUPT `SetUpTransformStreamDefaultControllerFromTransformer$A( コレ, %transformer, %transformerDict )
◎
Perform ? SetUpTransformStreamDefaultControllerFromTransformer(this, transformer, transformerDict).
</li>
	<li>
%startPromise ~LET `新たな~promise$
◎
Let startPromise be a new promise.
</li>
	<li>
%結果 ~LET `undefined^jv
◎
↓</li>
	<li>
~IF［
%transformerDict[ "`start$tf" ] ~NEQ ε
］
⇒
%結果 ~SET `~callback関数を呼出す$( %transformerDict[ "`start$tf" ], « コレ.`transformStreamController^sl », %transformer )
◎
If transformerDict["start"] exists, then resolve startPromise with the result of invoking transformerDict["start"] with argument list « this.[[transformStreamController]] » and callback this value transformer.
</li>
	<li>
%結果 で %startPromise を`解決する$
◎
Otherwise, resolve startPromise with undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`readable@ts
取得子~手続きは：
◎
The readable attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレ.`readable^sl
◎
Return this.[[readable]].
</li>
</ol>
</div>

<div class="algo">
<p>
`writable@ts
取得子~手続きは：
◎
The writable attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレ.`writable^sl
◎
Return this.[[writable]].
</li>
</ol>
</div>

			</section>
		</section>
		<section id="ts-default-controller-class">
<h3 title="The TransformStreamDefaultController class">6.3. `TransformStreamDefaultController^I ~class</h3>

<p>
`TransformStreamDefaultController$I ~classは、それに結付けられている［
`ReadableStream$I ／ `WritableStream$I
］の操作を許容する~methodを備える。
`TransformStream$I を構築するとき、`形式変換器$~objには，対応する `TransformStreamDefaultController$I ~instanceが操作するものとして与えられる。
◎
The TransformStreamDefaultController class has methods that allow manipulation of the associated ReadableStream and WritableStream. When constructing a TransformStream, the transformer object is given a corresponding TransformStreamDefaultController instance to manipulate.
</p>

			<section id="ts-default-controller-class-definition">
<h4 title="Interface definition">6.3.1. ~interface定義</h4>

<p>
`TransformStreamDefaultController$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the TransformStreamDefaultController class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `TransformStreamDefaultController@I {
  readonly attribute `unrestricted double$? `desiredSize$tsdc;

  void `enqueue$tsdc(optional any %chunk);
  void `error$tsdc(optional any %reason);
  void `terminate$tsdc();
};
</pre>

			</section>
			<section id="ts-default-controller-internal-slots">
<h4 title="Internal slots">6.3.2. 内部~slot</h4>

<p>
`TransformStreamDefaultController$I の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of TransformStreamDefaultController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th>
内部~slot
◎
Internal Slot
<th>
記述（`規範的でない^em）
◎
Description (non-normative)
</thead><tbody>

<tr><td>`controlledTransformStream^sl
<td>
制御先の `TransformStream$I ~instance。
◎
The TransformStream instance controlled

<tr><td>`flushAlgorithm^sl
<td>
~promiseを返す~algo
— それは、要請された~closeを`形式変換器$に通信する。
◎
A promise-returning algorithm which communicates a requested close to the transformer

<tr><td>`transformAlgorithm^sl
<td>
1 個の引数（形式変換への`~chunk$）をとり，~promiseを返す~algo
— それは、`形式変換器$に形式変換nを遂行するよう要請する。
◎
A promise-returning algorithm, taking one argument (the chunk to transform), which requests the transformer perform its transformation

</tbody></table>

			</section>
			<section id="ts-default-controller-prototype">
<h4 title="Methods and properties ">6.3.3. ~method／~prop</h4>

<dl class="domintro">
	<dt>%desiredSize = %controller.`desiredSize$tsdc</dt>
	<dd>
`~streamの内部~queueの残り~size$を返す。
それは、負になり得る
— ~queueが溢れた場合に。
◎
Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
</dd>

	<dt>%controller.`enqueue(chunk)$tsdc</dt>
	<dd>
所与の`~chunk$ %chunk を制御先の形式変換~streamの`可読~側$に~enqueueする。
◎
Enqueues the given chunk chunk in the readable side of the controlled transform stream.
</dd>

	<dt>%controller.`error(e)$tsdc</dt>
	<dd>
制御先の`形式変換~stream$の［
`可読~側$, `可書~側$
］どちらも~errorにする
— 以降のヤリトリは、すべて所与の~error %e で失敗し，形式変換n用に~queueされたどの`~chunk$も破棄されることになる。
◎
Errors the both the readable side and the writable side of the controlled transform stream, making all future interactions with it fail with the given error e. Any chunks queued for transformation will be discarded.
</dd>

	<dt>%controller.`terminate()$tsdc</dt>
	<dd>
制御先の`形式変換~stream$の`可読~側$を~closeして, `可書~側$を~errorにする。
これは、`形式変換器$が［
`可書~側$に書込された`~chunk$たちの一部分だけ消費する必要がある
］ときに有用になる。
◎
Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the transformer only needs to consume a portion of the chunks written to the writable side.
</dd>
</dl>

<div class="algo">
<p>
`desiredSize@tsdc
取得子~手続きは：
◎
The desiredSize attribute’s getter steps are:
</p>
<ol>
	<li>
%readableController ~LET コレ.`controlledTransformStream^sl.`readable^sl.`readableStreamController^sl
◎
Let readableController be this.[[controlledTransformStream]].[[readable]].[[readableStreamController]].
</li>
	<li>
~RET
~NOABRUPT `ReadableStreamDefaultControllerGetDesiredSize$A( %readableController )
◎
Return ! ReadableStreamDefaultControllerGetDesiredSize(readableController).
</li>
</ol>
</div>

<div class="algo">
<p>
`enqueue(chunk)@tsdc
~method~手続きは：
◎
The enqueue(chunk) method steps are:
</p>
<ol>
	<li>
~ABRUPT `TransformStreamDefaultControllerEnqueue$A( コレ, %chunk )
◎
Perform ? TransformStreamDefaultControllerEnqueue(this, chunk).
</li>
</ol>
</div>

<div class="algo">
<p>
`error(e)@tsdc
~method~手続きは：
◎
The error(e) method steps are:
</p>
<ol>
	<li>
~ABRUPT `TransformStreamDefaultControllerError$A( コレ, %e )
◎
Perform ? TransformStreamDefaultControllerError(this, e).
</li>
</ol>
</div>

<div class="algo">
<p>
`terminate()@tsdc
~method~手続きは：
◎
The terminate() method steps are:
</p>
<ol>
	<li>
~ABRUPT `TransformStreamDefaultControllerTerminate$A( コレ )
◎
Perform ? TransformStreamDefaultControllerTerminate(this).
</li>
</ol>
</div>

			</section>
		</section>
		<section id="ts-all-abstract-ops">
<h3 title="Abstract operations">6.4. 抽象-演算</h3>

			<section id="ts-abstract-ops">
<h4 title="Working with transform streams">6.4.1. 形式変換~streamとの作業-法</h4>

<p>
以下に与える抽象-演算は、
`TransformStream$I ~instanceに対し高~levelから演算する。
一部のものは、一般に，他の仕様においても有用になるよう意味されている。
◎
The following abstract operations operate on TransformStream instances at a higher level. Some are even meant to be generally useful by other specifications.
</p>

<div class="algo">
<p>
`CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm[, writableHighWaterMark[, writableSizeAlgorithm[, readableHighWaterMark[, readableSizeAlgorithm]]]])@A
は、 `TransformStream$I ~instanceを作成したいと望む，他の仕様から~callされる用途に意味されている。
それは、次の手続きを遂行する：
◎
CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm[, writableHighWaterMark[, writableSizeAlgorithm[, readableHighWaterMark[, readableSizeAlgorithm]]]])
is meant to be called from other specifications that wish to create TransformStream instances.＼
</p>
<ul>
	<li>
［
%transformAlgorithm ／ %flushAlgorithm
］は、~promiseを返す~algoでなければナラナイ。
◎
The transformAlgorithm and flushAlgorithm algorithms must return promises;＼
</li>
	<li>
［
%writableHighWaterMark ／ %readableHighWaterMark
］は、給されるならば，負でも `NaN^jv でもない ~numberでなければナラナイ。
◎
if supplied, writableHighWaterMark and readableHighWaterMark must be non-negative, non-NaN numbers;＼
</li>
	<li>
［
%writableSizeAlgorithm ／ %readableSizeAlgorithm
］は、給されるならば，`~chunk$~objを受容して ~numberを返す~algoでなければナラナイ。
◎
and if supplied, writableSizeAlgorithm and readableSizeAlgorithm must be algorithms accepting chunk objects and returning numbers.
</li>
</ul>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~IF［
%writableHighWaterMark は渡されていない
］
⇒
%writableHighWaterMark ~SET 1
◎
If writableHighWaterMark was not passed, set it to 1.
</li>
	<li>
~IF［
%writableSizeAlgorithm は渡されていない
］
⇒
%writableSizeAlgorithm ~SET 次を走らす~algo
⇒
~RET 1
◎
If writableSizeAlgorithm was not passed, set it to an algorithm that returns 1.
</li>
	<li>
~IF［
%readableHighWaterMark は渡されていない
］
⇒
%readableHighWaterMark~SET 0
◎
If readableHighWaterMark was not passed, set it to 0.
</li>
	<li>
~IF［
%readableSizeAlgorithm は渡されていない
］
⇒
%readableSizeAlgorithm~SET 次を走らす~algo
⇒
~RET 1
◎
If readableSizeAlgorithm was not passed, set it to an algorithm that returns 1.
</li>
	<li>
~Assert：
~NOABRUPT `IsNonNegativeNumber$A( %writableHighWaterMark ) ~EQ ~T
◎
Assert: ! IsNonNegativeNumber(writableHighWaterMark) is true.
</li>
	<li>
~Assert：
~NOABRUPT `IsNonNegativeNumber$A( %readableHighWaterMark ) ~EQ ~T
◎
Assert: ! IsNonNegativeNumber(readableHighWaterMark) is true.
</li>
	<li>
%stream ~LET `新たな$ `TransformStream$I
◎
Let stream be a new TransformStream.
</li>
	<li>
%startPromise ~LET `新たな~promise$
◎
Let startPromise be a new promise.
</li>
	<li>
~NOABRUPT `InitializeTransformStream$A( %stream, %startPromise, %writableHighWaterMark, %writableSizeAlgorithm, %readableHighWaterMark, %readableSizeAlgorithm )
◎
Perform ! InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm).
</li>
	<li>
%controller ~LET `新たな$ `TransformStreamDefaultController$I
◎
Let controller be a new TransformStreamDefaultController.
</li>
	<li>
~NOABRUPT `SetUpTransformStreamDefaultController$A( %stream, %controller, %transformAlgorithm, %flushAlgorithm )
◎
Perform ! SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm).
</li>
	<li>
%startResult ~LET %startAlgorithm()
（これは、例外を投出するかもしれない）
◎
Let startResult be the result of performing startAlgorithm. (This may throw an exception.)
</li>
	<li>
%startResult で %startPromise を`解決する$
◎
Resolve startPromise with startResult.
</li>
	<li>
~RET %stream
◎
Return stream.
</li>
</ol>

<p class="note">注記：
この抽象-演算は、給された %startAlgorithm が投出するとき, そのときに限り例外を投出することになる。
◎
This abstract operation will throw an exception if and only if the supplied startAlgorithm throws.
</p>
</div>

<div class="algo">
<p>
`InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm)@A
は、次の手続きを遂行する：
◎
InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) performs the following steps:
</p>
<ol>
	<li>
%startAlgorithm ~LET 次を走らす~algo
⇒
~RET %startPromise
◎
Let startAlgorithm be an algorithm that returns startPromise.
</li>
	<li>
%writeAlgorithm ~LET 所与の ( %chunk ) に対し，次を走らす手続き
⇒
~RET
~NOABRUPT `TransformStreamDefaultSinkWriteAlgorithm$A( %stream, %chunk )
◎
Let writeAlgorithm be the following steps, taking a chunk argument:
• Return ! TransformStreamDefaultSinkWriteAlgorithm(stream, chunk).
</li>
	<li>
%abortAlgorithm ~LET 所与の ( %reason ) に対し，次を走らす手続き
⇒
~RET
~NOABRUPT `TransformStreamDefaultSinkAbortAlgorithm$A( %stream, %reason )
◎
Let abortAlgorithm be the following steps, taking a reason argument:
• Return ! TransformStreamDefaultSinkAbortAlgorithm(stream, reason).
</li>
	<li>
%closeAlgorithm ~LET 次を走らす手続き
⇒
~RET
~NOABRUPT `TransformStreamDefaultSinkCloseAlgorithm$A( %stream )
◎
Let closeAlgorithm be the following steps:
• Return ! TransformStreamDefaultSinkCloseAlgorithm(stream).
</li>
	<li>
%stream.`writable^sl ~SET
~NOABRUPT `CreateWritableStream$A( %startAlgorithm, %writeAlgorithm, %closeAlgorithm, %abortAlgorithm, %writableHighWaterMark, %writableSizeAlgorithm )
◎
Set stream.[[writable]] to ! CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm).
</li>
	<li>
%pullAlgorithm ~LET 次を走らす手続き
⇒
~RET
~NOABRUPT `TransformStreamDefaultSourcePullAlgorithm$A( %stream )
◎
Let pullAlgorithm be the following steps:
• Return ! TransformStreamDefaultSourcePullAlgorithm(stream).
</li>
	<li>
<p>
%cancelAlgorithm ~LET 所与の ( %reason ) に対し，次を走らす手続き：
◎
Let cancelAlgorithm be the following steps, taking a reason argument:
</p>
		<ol>
			<li>
~NOABRUPT `TransformStreamErrorWritableAndUnblockWrite$A( %stream, %reason )
◎
Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, reason).
</li>
			<li>
~RET `undefined^jv で`解決される~promise$
◎
Return a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
%stream.`readable^sl ~SET
~NOABRUPT `CreateReadableStream$A( %startAlgorithm, %pullAlgorithm, %cancelAlgorithm, %readableHighWaterMark, %readableSizeAlgorithm )
◎
Set stream.[[readable]] to ! CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm).
</li>
	<li>
<p>
%stream の
⇒＃
.`backpressure^sl ~SET `undefined^jv,
.`backpressureChangePromise^sl ~SET `undefined^jv
◎
Set stream.[[backpressure]] and stream.[[backpressureChangePromise]] to undefined.
</p>

<p class="note">注記：
`backpressure^sl ~slotは、
`TransformStreamSetBackpressure$A により初期化できるよう，
`undefined^jv に設定される。
別法として，実装は、 `backpressure^sl 用に厳密な真偽~値を利用して，初期化される仕方を変更できる。
これは、初期化が［
当の形式変換器の `start()$tf ~methodが~callされる前
］に正しく完了される限り，利用者~codeからは可視にならない。
◎
The [[backpressure]] slot is set to undefined so that it can be initialized by TransformStreamSetBackpressure. Alternatively, implementations can use a strictly boolean value for [[backpressure]] and change the way it is initialized. This will not be visible to user code so long as the initialization is correctly completed before the transformer’s start() method is called.
</p>
	</li>
	<li>
~NOABRUPT `TransformStreamSetBackpressure$A( %stream, ~T )
◎
Perform ! TransformStreamSetBackpressure(stream, true).
</li>
	<li>
%stream.`transformStreamController^sl ~SET `undefined^jv
◎
Set stream.[[transformStreamController]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamError(stream, e)@A
は、次の手続きを遂行する：
◎
TransformStreamError(stream, e) performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerError$A( %stream.`readable^sl.`readableStreamController^sl, %e )
◎
Perform ! ReadableStreamDefaultControllerError(stream.[[readable]].[[readableStreamController]], e).
</li>
	<li>
~NOABRUPT `TransformStreamErrorWritableAndUnblockWrite$A( %stream, %e )
◎
Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, e).
</li>
</ol>
</div>

<p class="note">注記：
この演算は、両方／片方の側が すでに~errorしたときは，正しく働く。
結果として，~call元~の~algoは、~error条件に応答するときに~stream状態を検査する必要がなくなる。
◎
This operation works correctly when one or both sides are already errored. As a result, calling algorithms do not need to check stream states when responding to an error condition.
</p>

<div class="algo">
<p>
`TransformStreamErrorWritableAndUnblockWrite(stream, e)@A
は、次の手続きを遂行する：
◎
TransformStreamErrorWritableAndUnblockWrite(stream, e) performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `TransformStreamDefaultControllerClearAlgorithms$A( %stream.`transformStreamController^sl)
◎
Perform ! TransformStreamDefaultControllerClearAlgorithms(stream.[[transformStreamController]]).
</li>
	<li>
~NOABRUPT `WritableStreamDefaultControllerErrorIfNeeded$A( %stream.`writable^sl.`writableStreamController^sl, %e )
◎
Perform ! WritableStreamDefaultControllerErrorIfNeeded(stream.[[writable]].[[writableStreamController]], e).
</li>
	<li>
~IF［
%stream.`backpressure^sl ~EQ ~T
］
⇒
~NOABRUPT `TransformStreamSetBackpressure$A( %stream, ~F )
◎
If stream.[[backpressure]] is true, perform ! TransformStreamSetBackpressure(stream, false).
</li>
</ol>
</div>

<p class="note">注記：
`TransformStreamDefaultSinkWriteAlgorithm$A 抽象-演算は、
`backpressureChangePromise^sl ~slotに格納された~promiseが解決されるまで，待機することもある。
`TransformStreamSetBackpressure$A への~callは、~promiseが常に解決されることを確保する。
◎
The TransformStreamDefaultSinkWriteAlgorithm abstract operation could be waiting for the promise stored in the [[backpressureChangePromise]] slot to resolve. The call to TransformStreamSetBackpressure ensures that the promise always resolves.
</p>

<div class="algo">
<p>
`TransformStreamSetBackpressure(stream, backpressure)@A
は、次の手続きを遂行する：
◎
TransformStreamSetBackpressure(stream, backpressure) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`backpressure^sl ~NEQ %backpressure
◎
Assert: stream.[[backpressure]] is not backpressure.
</li>
	<li>
~IF［
%stream.`backpressureChangePromise^sl ~NEQ `undefined^jv
］
⇒
`undefined^jv で
%stream.`backpressureChangePromise^sl を`解決する$
◎
If stream.[[backpressureChangePromise]] is not undefined, resolve stream.[[backpressureChangePromise]] with undefined.
</li>
	<li>
%stream.`backpressureChangePromise^sl ~SET `新たな~promise$
◎
Set stream.[[backpressureChangePromise]] to a new promise.
</li>
	<li>
%stream.`backpressure^sl ~SET %backpressure
◎
Set stream.[[backpressure]] to backpressure.
</li>
</ol>
</div>

			</section>
			<section id="ts-default-controller-abstract-ops">
<h3 title="Default controllers">6.4.2. 既定の制御器</h3>

<p>
以下に与える抽象-演算は、
`TransformStreamDefaultController$I ~classの実装を~supportする。
◎
The following abstract operations support the implementaiton of the TransformStreamDefaultController class.
</p>

<div class="algo">
<p>
`SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm)@A
は、次の手続きを遂行する：
◎
SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream は `TransformStream$I を`実装する$。
◎
Assert: stream implements TransformStream.
</li>
	<li>
~Assert：
%stream.`transformStreamController^sl ~EQ `undefined^jv
◎
Assert: stream.[[transformStreamController]] is undefined.
</li>
	<li>
%controller.`controlledTransformStream^sl ~SET %stream
◎
Set controller.[[controlledTransformStream]] to stream.
</li>
	<li>
%stream.`transformStreamController^sl ~SET %controller
◎
Set stream.[[transformStreamController]] to controller.
</li>
	<li>
%controller.`transformAlgorithm^sl ~SET %transformAlgorithm
◎
Set controller.[[transformAlgorithm]] to transformAlgorithm.
</li>
	<li>
%controller.`flushAlgorithm^sl ~SET %flushAlgorithm
◎
Set controller.[[flushAlgorithm]] to flushAlgorithm.
</li>
</ol>
</div>

<div class="algo">
<p>
`SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer, transformerDict)@A
は、次の手続きを遂行する：
◎
SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer, transformerDict) performs the following steps:
</p>
<ol>
	<li>
%controller ~LET `新たな$ `TransformStreamDefaultController$I
◎
Let controller be a new TransformStreamDefaultController.
</li>
	<li>
<p>
%transformAlgorithm ~LET 所与の ( %chunk ) に対し，次を走らす手続き：
◎
Let transformAlgorithm be the following steps, taking a chunk argument:
</p>
		<ol>
			<li>
%result ~LET
`TransformStreamDefaultControllerEnqueue$A( %controller, %chunk )
◎
Let result be TransformStreamDefaultControllerEnqueue(controller, chunk).
</li>
			<li>
~IF［
%result は`中途完了^である
］
⇒
~RET %result.`Value^sl で`却下される~promise$
◎
If result is an abrupt completion, return a promise rejected with result.[[Value]].
</li>
			<li>
~RET `undefined^jv で`解決される~promise$
◎
Otherwise, return a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
%flushAlgorithm ~LET 次を走らす~algo
⇒
~RET `undefined^jv で`解決される~promise$
◎
Let flushAlgorithm be an algorithm which returns a promise resolved with undefined.
</li>
	<li>
~IF［
%transformerDict[ "`transform$tf" ] ~NEQ ε
］
⇒
%transformAlgorithm ~SET 所与の ( %chunk ) に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %transformerDict[ "`transform$tf" ], « %chunk, %controller », %transformer )
◎
If transformerDict["transform"] exists, set transformAlgorithm to an algorithm which takes an argument chunk and returns the result of invoking transformerDict["transform"] with argument list « chunk, controller ») and callback this value transformer.
</li>
	<li>
~IF［
%transformerDict[ "`flush$tf" ] ~NEQ ε
］
⇒
%flushAlgorithm ~SET 次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %transformerDict[ "`flush$tf" ], « %controller », %transformer )
◎
If transformerDict["flush"] exists, set flushAlgorithm to an algorithm which returns the result of invoking transformerDict["flush"] with argument list « controller » and callback this value transformer.
</li>
	<li>
~NOABRUPT `SetUpTransformStreamDefaultController$A( %stream, %controller, %transformAlgorithm, %flushAlgorithm )
◎
Perform ! SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm).
</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultControllerClearAlgorithms(controller)@A
は、~streamが~closeされるか~errorして，各種~algoが それ以上~実行されなくなったときに~callされる。
これは、各種~algoへの参照を除去することにより，`形式変換器$（ `TransformStream$I ~obj）自身が
— まだ参照されていても —
~garbage収集されることを許可する。
◎
TransformStreamDefaultControllerClearAlgorithms(controller) is called once the stream is closed or errored and the algorithms will not be executed any more. By removing the algorithm references it permits the transformer object to be garbage collected even if the TransformStream itself is still referenced.
</p>

<p class="note">
これは、<a href="https://github.com/tc39/proposal-weakrefs/">弱い参照</a>を利用すると観測-可能になる。
詳細は
<a href="https://github.com/tc39/proposal-weakrefs/issues/31">tc39/proposal-weakrefs#31</a>
を見よ。
◎
This is observable using weak references. See tc39/proposal-weakrefs#31 for more detail.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%controller.`transformAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[transformAlgorithm]] to undefined.
</li>
	<li>
%controller.`flushAlgorithm^sl ~SET `undefined^jv
◎
Set controller.[[flushAlgorithm]] to undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultControllerEnqueue(controller, chunk)@A
は、`~chunk$たちを`可読~側$に~enqueueしたいと望む，他の仕様から~callされる用途に意味されている
— 開発者が［
~streamに結付けられた制御器~objを利用して~chunkたちを~enqueueする
］のと同じ仕方で。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを行う`べきでない^em。
◎
TransformStreamDefaultControllerEnqueue(controller, chunk) is meant to be called by other specifications that wish to enqueue chunks in the readable side, in the same way a developer would enqueue chunks using the stream’s associated controller object. Specifications should not do this to streams or controllers they did not create.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledTransformStream^sl
◎
Let stream be controller.[[controlledTransformStream]].
</li>
	<li>
%readableController ~LET %stream.`readable^sl.`readableStreamController^sl
◎
Let readableController be stream.[[readable]].[[readableStreamController]].
</li>
	<li>
~IF［
~NOABRUPT `ReadableStreamDefaultControllerCanCloseOrEnqueue$A( %readableController ) ~EQ ~F
］
⇒
~THROW `TypeError^jE
◎
If ! ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) is false, throw a TypeError exception.
</li>
	<li>
%enqueueResult ~LET `ReadableStreamDefaultControllerEnqueue$A( %readableController, %chunk )
◎
Let enqueueResult be ReadableStreamDefaultControllerEnqueue(readableController, chunk).
</li>
	<li>
<p>
~IF［
%enqueueResult は`中途完了^である
］：
◎
If enqueueResult is an abrupt completion,
</p>
		<ol>
			<li>
~NOABRUPT `TransformStreamErrorWritableAndUnblockWrite$A( %stream, %enqueueResult.`Value^sl )
◎
Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, enqueueResult.[[Value]]).
</li>
			<li>
~THROW %stream.`readable^sl.`storedError^sl
◎
Throw stream.[[readable]].[[storedError]].
</li>
		</ol>
	</li>
	<li>
%backpressure ~LET
~NOABRUPT `ReadableStreamDefaultControllerHasBackpressure$A( %readableController )
◎
Let backpressure be ! ReadableStreamDefaultControllerHasBackpressure(readableController).
</li>
	<li>
<p>
~IF［
%backpressure ~NEQ %stream.`backpressure^sl
］：
◎
If backpressure is not stream.[[backpressure]],
</p>
		<ol>
	<li>
~Assert：
%backpressure ~EQ ~T
◎
Assert: backpressure is true.
</li>
	<li>
~NOABRUPT `TransformStreamSetBackpressure$A( %stream, ~T )
◎
Perform ! TransformStreamSetBackpressure(stream, true).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultControllerError(controller, e)@A
は、形式変換~streamを~errorした状態に移行させたいと望む，他の仕様から~callされる用途に意味されている
— 開発者が［
~streamに結付けられた制御器~objを利用して，~errorにする
］のと同じ仕方で。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを行う`べきでない^em。
◎
TransformStreamDefaultControllerError(controller, e) is meant to be called by other specifications that wish to move the transform stream to an errored state, in the same way a developer would error the stream using the stream’s associated controller object. Specifications should not do this to streams or controllers they did not create. 
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `TransformStreamError$A( %controller.`controlledTransformStream^sl, %e )
◎
Perform ! TransformStreamError(controller.[[controlledTransformStream]], e).
</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultControllerPerformTransform(controller, chunk)@A
は、次の手続きを遂行する：
◎
TransformStreamDefaultControllerPerformTransform(controller, chunk) performs the following steps:
</p>
<ol>
	<li>
%transformPromise ~LET %controller.`transformAlgorithm^sl( %chunk )
◎
Let transformPromise be the result of performing controller.[[transformAlgorithm]], passing chunk.
</li>
	<li>
<p>
~RET ［
所与の ( %r ) に対し，次を走らす却下~手続き
］で %transformPromise に`反応-$した結果：
◎
Return the result of reacting to transformPromise with the following rejection steps given the argument r:
</p>
		<ol>
			<li>
~NOABRUPT `TransformStreamError$A( %controller.`controlledTransformStream^sl, %r )
◎
Perform ! TransformStreamError(controller.[[controlledTransformStream]], r).
</li>
			<li>
~THROW %r
◎
Throw r.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultControllerTerminate(controller)@A
は、形式変換~streamを終了したいと望む，他の仕様から~callされる用途に意味されている
— 開発者が作成した~streamが［
それに結付けられた制御器~objにより終了される
］のと同じ仕方で。
仕様は、自身が作成しなかった［
~stream／制御器
］に対し，これを行う`べきでない^em。
◎
TransformStreamDefaultControllerTerminate(controller) is meant to be called by other specifications that wish to terminate the transform stream, in the same way a developer-created stream would be terminated by its associated controller object. Specifications should not do this to streams or controllers they did not create.
</p>

<p>
それは、次の手続きを遂行する：
◎
It performs the following steps:
</p>
<ol>
	<li>
%stream ~LET %controller.`controlledTransformStream^sl
◎
Let stream be controller.[[controlledTransformStream]].
</li>
	<li>
%readableController ~LET %stream.`readable^sl.`readableStreamController^sl
◎
Let readableController be stream.[[readable]].[[readableStreamController]].
</li>
	<li>
~NOABRUPT `ReadableStreamDefaultControllerClose$A( %readableController )
◎
Perform ! ReadableStreamDefaultControllerClose(readableController).
</li>
	<li>
%error ~LET
~streamは終了されたことを指示する， `TypeError^jE 例外
◎
Let error be a TypeError exception indicating that the stream has been terminated.
</li>
	<li>
~NOABRUPT `TransformStreamErrorWritableAndUnblockWrite$A( %stream, %error )
◎
Perform ! TransformStreamErrorWritableAndUnblockWrite(stream, error).
</li>
</ol>
</div>

			</section>
			<section id="ts-default-sink-abstract-ops">
<h3 title="Default sinks">6.4.3. 既定の槽</h3>

<p>
以下に与える抽象-演算は、`形式変換~stream$の`可書~側$用の`下層~槽$を実装するために利用される。
◎
The following abstract operations are used to implement the underlying sink for the writable side of transform streams.
</p>

<div class="algo">
<p>
`TransformStreamDefaultSinkWriteAlgorithm(stream, chunk)@A
は、次の手続きを遂行する：
◎
TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`writable^sl.`state^sl ~EQ `writable^l
◎
Assert: stream.[[writable]].[[state]] is "writable".
</li>
	<li>
%controller ~LET %stream.`transformStreamController^sl
◎
Let controller be stream.[[transformStreamController]].
</li>
	<li>
<p>
~IF［
%stream.`backpressure^sl ~EQ ~T
］：
◎
If stream.[[backpressure]] is true,
</p>
		<ol>
			<li>
%backpressureChangePromise ~LET %stream.`backpressureChangePromise^sl
◎
Let backpressureChangePromise be stream.[[backpressureChangePromise]].
</li>
			<li>
~Assert：
%backpressureChangePromise ~NEQ `undefined^jv
◎
Assert: backpressureChangePromise is not undefined.
</li>
			<li>
<p>
~RET ［
次を走らす充足~手続き
］で %backpressureChangePromise に`反応-$した結果：
◎
Return the result of reacting to backpressureChangePromise with the following fulfillment steps:
</p>
				<ol>
					<li>
%writable ~LET %stream.`writable^sl
◎
Let writable be stream.[[writable]].
</li>
					<li>
%state ~LET %writable.`state^sl
◎
Let state be writable.[[state]].
</li>
					<li>
~IF［
%state ~EQ `erroring^l
］
⇒
~THROW %writable.`storedError^sl
◎
If state is "erroring", throw writable.[[storedError]].
</li>
					<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
					<li>
~RET
~NOABRUPT `TransformStreamDefaultControllerPerformTransform$A( %controller, %chunk )
◎
Return ! TransformStreamDefaultControllerPerformTransform(controller, chunk).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET
~NOABRUPT `TransformStreamDefaultControllerPerformTransform$A( %controller, %chunk )
◎
Return ! TransformStreamDefaultControllerPerformTransform(controller, chunk).
</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultSinkAbortAlgorithm(stream, reason)@A
は、次の手続きを遂行する：
◎
TransformStreamDefaultSinkAbortAlgorithm(stream, reason) performs the following steps:
</p>
<ol>
	<li>
~NOABRUPT `TransformStreamError$A( %stream, %reason )
◎
Perform ! TransformStreamError(stream, reason).
</li>
	<li>
~RET `undefined^jv で`解決される~promise$
◎
Return a promise resolved with undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`TransformStreamDefaultSinkCloseAlgorithm(stream)@A
は、次の手続きを遂行する：
◎
TransformStreamDefaultSinkCloseAlgorithm(stream) performs the following steps:
</p>
<ol>
	<li>
%readable ~LET %stream.`readable^sl
◎
Let readable be stream.[[readable]].
</li>
	<li>
%controller ~LET %stream.`transformStreamController^sl
◎
Let controller be stream.[[transformStreamController]].
</li>
	<li>
%flushPromise ~LET %controller.`flushAlgorithm^sl()
◎
Let flushPromise be the result of performing controller.[[flushAlgorithm]].
</li>
	<li>
~NOABRUPT `TransformStreamDefaultControllerClearAlgorithms$A( %controller )
◎
Perform ! TransformStreamDefaultControllerClearAlgorithms(controller).
</li>
	<li>
<p>
~RET 次に与える［
充足~手続き, 却下~手続き
］で %flushPromise に`反応-$した結果：
◎
Return the result of reacting to flushPromise:
</p>
		<ul>
			<li>
<p>
%flushPromise が充足されたときは：
◎
If flushPromise was fulfilled, then:
</p>
				<ol>
					<li>
~IF［
%readable.`state^sl ~EQ `errored^l
］
⇒
~THROW %readable.`storedError^sl
◎
If readable.[[state]] is "errored", throw readable.[[storedError]].
</li>
					<li>
~NOABRUPT `ReadableStreamDefaultControllerClose$A( %readable.`readableStreamController^sl )
◎
Perform ! ReadableStreamDefaultControllerClose(readable.[[readableStreamController]]).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r で %flushPromise が却下されたときは：
◎
If flushPromise was rejected with reason r, then:
</p>
				<ol>
					<li>
~NOABRUPT `TransformStreamError$A( %stream, %r )
◎
Perform ! TransformStreamError(stream, r).
</li>
					<li>
~THROW %readable.`storedError^sl
◎
Throw readable.[[storedError]].
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

			</section>
			<section id="ts-default-source-abstract-ops">
<h3 title="Default sources">6.4.4. 既定の源</h3>

<p>
以下に与える抽象-演算は、`形式変換~stream$の`可読~側$用の`下層~源$を実装するために利用される。
◎
The following abstract operation is used to implement the underlying source for the readable side of transform streams.
</p>

<div class="algo">
<p>
`TransformStreamDefaultSourcePullAlgorithm(stream)@A
は、次の手続きを遂行する：
◎
TransformStreamDefaultSourcePullAlgorithm(stream) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%stream.`backpressure^sl ~EQ ~T
◎
Assert: stream.[[backpressure]] is true.
</li>
	<li>
~Assert：
%stream.`backpressureChangePromise^sl ~NEQ `undefined^jv
◎
Assert: stream.[[backpressureChangePromise]] is not undefined.
</li>
	<li>
~NOABRUPT `TransformStreamSetBackpressure$A( %stream, ~F )
◎
Perform ! TransformStreamSetBackpressure(stream, false).
</li>
	<li>
~RET %stream.`backpressureChangePromise^sl
◎
Return stream.[[backpressureChangePromise]].
</li>
</ol>
</div>

			</section>
		</section>
	</section>
	<section id="qs">
<h2 title="Queuing strategies">7. ~queuing策</h2>

		<section id="qs-api">
<h3 title="The queuing strategy API">7.1. ~queuing策~API</h3>

<p>
［
`new ReadableStream()$m ／
`new WritableStream()$m ／
`new TransformStream()$m
］構築子は、どれも［
作成されている~stream用に適切な`~queuing策$
］を表現している引数を受容する。
そのような~objは、次に挙げる~propを包含する：
◎
The ReadableStream(), WritableStream(), and TransformStream() constructors all accept at least one argument representing an appropriate queuing strategy for the stream being created. Such objects contain the following properties:
</p>

<pre class="idl">
dictionary `QueuingStrategy@I {
  `unrestricted double$ `highWaterMark$qs;
  `QueuingStrategySize$I `size$qs;
};

callback `QueuingStrategySize@I = `unrestricted double$ (optional any %chunk);
</pre>

<dl>
	<dt>
`highWaterMark@qs
（ `unrestricted double$I 型）
◎
highWaterMark, of type unrestricted double
</dt>
	<dd>
負でない~number。
この~queuing策を利用している~streamの`限界水位$を指示する。
◎
A non-negative number indicating the high water mark of the stream using this queuing strategy.
</dd>

	<dt>
`size(chunk)@qs
（非~byte~stream用に限る）
（ `QueuingStrategySize$I 型）
◎
size(chunk) (non-byte streams only), of type QueuingStrategySize
</dt>
	<dd>
この関数は、所与の`~chunk$値の有限かつ負でない~sizeを算出した結果を返す。
◎
A function that computes and returns the finite non-negative size of the given chunk value.
</dd>
	<dd>
結果は、`背圧$を決定するために利用される。
それは、適切な `desiredSize^c ~prop
— ~queuing策がどこで利用されているかに依存して，［
<code>%defaultController.`desiredSize$rsdc</code>,
<code>%byteController.`desiredSize$rbsc</code>,
<code>%writer.`desiredSize$dw</code>
］のいずれか —
を介して~~露わになる。
それは，可読~stream用には、`下層~源$の `pull()$usc ~methodがいつ~callされるかも統治する。
◎
The result is used to determine backpressure, manifesting via the appropriate desiredSize property: either defaultController.desiredSize, byteController.desiredSize, or writer.desiredSize, depending on where the queuing strategy is being used. For readable streams, it also governs when the underlying source's pull() method is called.
</dd>
	<dd>
この関数は、冪等かつ, 副作用は生じないようにする必要がある。
さもなければ、ごく変則的な結果が生じ得る。
◎
This function has to be idempotent and not cause side effects; very strange results can occur otherwise.
</dd>
	<dd>
この関数は、`可読~byte~stream$には利用されない
— ~chunkたちは、常に~byte数で測定されるので。
◎
For readable byte streams, this function is not used, as chunks are always measured in bytes.
</dd>
</dl>

<p>
~queuing策~objが期待される所では、これらの~propを伴うどの~objも利用できる。
しかしながら，ある種の事例~用に共通的な語彙を供するためとして、組込みの~queuing策~class
— `ByteLengthQueuingStrategy$I, `CountQueuingStrategy$I —
も供される。
どちらも，その構築子~用に次の~Web~IDL片を用立てる：
◎
Any object with these properties can be used when a queuing strategy object is expected. However, we provide two built-in queuing strategy classes that provide a common vocabulary for certain cases: ByteLengthQueuingStrategy and CountQueuingStrategy. They both make use of the following Web IDL fragment for their constructors:
</p>

<pre class="idl">
dictionary `QueuingStrategyInit@I {
  required `unrestricted double$ `highWaterMark@qsi;
};
</pre>

		</section>
		<section id="blqs-class">
<h3 title="The ByteLengthQueuingStrategy class">7.2. `ByteLengthQueuingStrategy^I ~class</h3>

<p>
~byte列を~~扱うときに共通的な`~queuing策$は、流入`~chunk$たちの `byteLength^m ~propの累積が，指定された`限界水位$に達するまで、待機することである。
そのようなわけで，これは、~streamを構築するときに利用できるような，組込みの`~queuing策$として供される。
◎
A common queuing strategy when dealing with bytes is to wait until the accumulated byteLength properties of the incoming chunks reaches a specified high-water mark. As such, this is provided as a built-in queuing strategy that can be used when constructing streams.
</p>

<div class="example" id="example-blqs">

<p>
`可読~stream$／`可書~stream$を作成する際には、~byte数による~queuing策を直に給せる：
◎
When creating a readable stream or writable stream, you can supply a byte-length queuing strategy directly:
</p>

<pre class="lang-js">
const %stream = new ReadableStream(
  { ... },
  new ByteLengthQueuingStrategy({ %highWaterMark: 16 * 1024 })
);
</pre>

<p>
この事例では、可読~stream実装が 下層~源へ`背圧$通達の送信を開始するまでに、可読~streamの`下層~源$に~~総計 16 KiB 程の`~chunk$たちを~enqueueできる。
◎
In this case, 16 KiB worth of chunks can be enqueued by the readable stream’s underlying source before the readable stream implementation starts sending backpressure signals to the underlying source.
</p>

<pre class="lang-js">
const %stream = new WritableStream(
  { ... },
  new ByteLengthQueuingStrategy({ %highWaterMark: 32 * 1024 })
);
</pre>

<p>
この事例では、`下層~槽$への以前の書込nが完遂するまで待機する間，可書~streamが `生産器$へ向けて`背圧$通達の送信を開始するまでに、~~総計 32 KiB 程の`~chunk$たちを可書~streamの内部~queue内に累積できる。
◎
In this case, 32 KiB worth of chunks can be accumulated in the writable stream’s internal queue, waiting for previous writes to the underlying sink to finish, before the writable stream starts sending backpressure signals to any producers.
</p>
</div>

<p class="note">注記：
`可読~byte~stream$には、 `ByteLengthQueuingStrategy$I の利用は必要とされない
— その~chunk数は常に~byte数で測定されるので。
`ByteLengthQueuingStrategy$I で~byte~streamを構築しようと試みても，失敗することになる。
◎
It is not necessary to use ByteLengthQueuingStrategy with readable byte streams, as they always measure chunks in bytes. Attempting to construct a byte stream with a ByteLengthQueuingStrategy will fail.
</p>


			<section id="blqs-class-definition">
<h4 title="Interface definition">7.2.1. ~interface定義</h4>

<p>
`ByteLengthQueuingStrategy$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the ByteLengthQueuingStrategy class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `ByteLengthQueuingStrategy@I {
  `ByteLengthQueuingStrategy$mc(`QueuingStrategyInit$I %init);

  readonly attribute `unrestricted double$ `highWaterMark$blqs;
  readonly attribute `Function$I `size$blqs;
};
</pre>

			</section>
			<section id="blqs-internal-slots">
<h4 title="Internal slots">7.2.2. 内部~slot</h4>

<p>
`ByteLengthQueuingStrategy$I の各~instanceには，
`highWaterMark^sl 内部~slotがあり，構築子に与えられた値を格納する。
◎
Instances of ByteLengthQueuingStrategy have a [[highWaterMark]] internal slot, storing the value given in the constructor.
</p>

<div class="algo">
<p>
加えて，どの`大域~obj$ %大域~obj にも
`~byte長さ~queuing策~size関数@
が結付けられる。
その値は `Function$I であり、次に従って初期化されるモノトスル：
◎
Additionally, every global object globalObject has an associated byte length queuing strategy size function, which is a Function whose value must be initialized as follows:
</p>
<ol>
	<li>
%手続き ~LET 所与の ( %chunk ) に対し，次を走らす手続き
⇒
~RET
~ABRUPT `GetV$Ax( %chunk, `byteLength^l )
◎
Let steps be the following steps, given chunk:
• Return ? GetV(chunk, "byteLength").
</li>
	<li>
%F ~LET
~NOABRUPT `CreateBuiltinFunction$Ax( %手続き, « », %大域~obj に`関連な~Realm$ )
◎
Let F be ! CreateBuiltinFunction(steps, « », globalObject’s relevant Realm).
</li>
	<li>
~NOABRUPT `SetFunctionName$Ax( %F, `size^l )
◎
Perform ! SetFunctionName(F, "size").
</li>
	<li>
~NOABRUPT `SetFunctionLength$Ax( %F, 1 )
◎
Perform ! SetFunctionLength(F, 1).
</li>
	<li>
%大域~obj の`~byte長さ~queuing策~size関数$ ~SET %F への参照を表現する `Function$I
— その`~callback文脈$は、%大域~obj に`関連な設定群~obj$になるとする
◎
Set globalObject’s byte length queuing strategy size function to a Function that represents a reference to F, with callback context equal to globalObject’s relevant settings object.
</li>
</ol>

<p class="note">注記：
この設計は、いくぶん歴史的である。
その動機は、 `size$blqs は関数であって~methodではない
— すなわち，その `this^jv 値を検査しない —
ことを確保したいと欲されることにある。
更なる背景は、
<a href="https://github.com/whatwg/streams/issues/1005">課題 #1005</a>,
<a href="https://github.com/heycam/webidl/issues/819">heycam/webidl#819</a>
を見よ。
◎
This design is somewhat historical. It is motivated by the desire to ensure that size is a function, not a method, i.e. it does not check its this value. See whatwg/streams#1005 and heycam/webidl#819 for more background.
</p>
</div>

			</section>
			<section id="blqs-prototype">
<h4 title="Constructor and properties">7.2.3. 構築子, ~prop</h4>

<dl class="domintro">
	<dt>%strategy = `new ByteLengthQueuingStrategy$m({ `highWaterMark$qsi })</dt>
	<dd>
供された`限界水位$を伴う新たな `ByteLengthQueuingStrategy$I を作成する。
◎
Creates a new ByteLengthQueuingStrategy with the provided high water mark.
</dd>
	<dd>
供された`限界水位$は、事前に検証されないことに注意。
それが［
~numberでない／
`NaN^jv または負な~numberである
］場合、結果の `ByteLengthQueuingStrategy$I は，対応する~stream構築子にて例外を投出させることになる。
◎
Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.
</dd>

	<dt>%highWaterMark = %strategy.`highWaterMark$blqs</dt>
	<dd>
構築子に供された`限界水位$を返す。
◎
Returns the high water mark provided to the constructor.
</dd>

	<dt>%strategy.`size(chunk)$blqs</dt>
	<dd>
`byteLength^c ~propの値を返すことにより，
%chunk の~sizeを測定する。
◎
Measures the size of chunk by returning the value of its byteLength property.
</dd>
</dl>

<div class="algo">
<p>
`new ByteLengthQueuingStrategy(init)@m
構築子~手続きは：
◎
The ByteLengthQueuingStrategy(init) constructor steps are:
</p>
<ol>
	<li>
コレ.`highWaterMark^sl ~SET %init[ "`highWaterMark$qsi" ]
◎
Set this.[[highWaterMark]] to init["highWaterMark"].
</li>
</ol>
</div>

<div class="algo">
<p>
`highWaterMark@blqs
取得子~手続きは：
◎
The highWaterMark attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレ.`highWaterMark^sl
◎
Return this.[[highWaterMark]].
</li>
</ol>
</div>

<div class="algo">
<p>
`size@blqs
取得子~手続きは：
◎
The size attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレに`関連な大域~obj$の`~byte長さ~queuing策~size関数$
。
◎
Return this's relevant global object's byte length queuing strategy size function.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="cqs-class">
<h3 title="The CountQueuingStrategy class">7.3. `CountQueuingStrategy^I ~class</h3>

<p>
汎用~objの~streamを~~扱うときに共通的な`~queuing策$は、単純に，［
累積した`~chunk$の個数を，指定された`限界水位$に達するまで数え続ける
］ものである。
そのようなわけで、この策も `out of the box^en で供される。
◎
A common queuing strategy when dealing with streams of generic objects is to simply count the number of chunks that have been accumulated so far, waiting until this number reaches a specified high-water mark. As such, this strategy is also provided out of the box.
</p>

<div class="example" id="example-cqs">

<p>
`可読~stream$／`可書~stream$を作成するときは、~chunk数による~queuing策を直に給せる：
◎
When creating a readable stream or writable stream, you can supply a count queuing strategy directly:
</p>

<pre class="lang-js">
const %stream = new ReadableStream(
  { ... },
  new CountQueuingStrategy({ %highWaterMark: 10 })
);
</pre>

<p>
この事例では、可読~stream実装が `下層~源$へ向けて`背圧$通達の送信を開始するまでに、（種類は問わず） 10 個の`~chunk$を，可読~streamの`下層~源$に~enqueueできる。
◎
In this case, 10 chunks (of any kind) can be enqueued by the readable stream’s underlying source before the readable stream implementation starts sending backpressure signals to the underlying source.
</p>

<pre class="lang-js">
const %stream = new WritableStream(
  { ... },
  new CountQueuingStrategy({ %highWaterMark: 5 })
);
</pre>

<p>
この事例では、`下層~槽$への以前の書込nが完遂するまで待機している間，可書~streamが `生産器$へ向けて`背圧$通達の送信を開始するまでに、可書~streamの内部~queue内に（種類は問わず） 5 個の`~chunk$を累積できる。
◎
In this case, five chunks (of any kind) can be accumulated in the writable stream’s internal queue, waiting for previous writes to the underlying sink to finish, before the writable stream starts sending backpressure signals to any producers.
</p>
</div>

			<section id="cqs-class-definition">
<h4 title="Interface definition">7.3.1. ~interface定義</h4>

<p>
`CountQueuingStrategy$I ~class用の~Web~IDL定義は：
◎
The Web IDL definition for the CountQueuingStrategy class is given as follows:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker,Worklet)]
interface `CountQueuingStrategy@I {
  `CountQueuingStrategy$mc(`QueuingStrategyInit$I %init);

  readonly attribute `unrestricted double$ `highWaterMark$cqs;
  readonly attribute `Function$I `size$cqs;
};
</pre>

			</section>
			<section id="cqs-internal-slots">
<h4 title="Internal slots">7.3.2. 内部~slot</h4>

<p>
`CountQueuingStrategy$I の各~instanceには，
`highWaterMark^sl 内部~slotがあり、構築子に与えられた値を格納する。
◎
Instances of CountQueuingStrategy have a [[highWaterMark]] internal slot, storing the value given in the constructor.
</p>

<div class="algo">
<p>
加えて，どの`大域~obj$ %大域~obj にも
`~count~queuing策~size関数@
が結付けられる。
その値は `Function$I であり、次に従って初期化されるモノトスル：
◎
Additionally, every global object globalObject has an associated count queuing strategy size function, which is a Function whose value must be initialized as follows:
</p>
<ol>
	<li>
%手続き ~LET 次を走らす手続き
⇒
~RET 1
◎
Let steps be the following steps:
• Return 1.
</li>
	<li>
%F ~LET
~NOABRUPT `CreateBuiltinFunction$Ax( %手続き, « », %大域~obj に`関連な~Realm$ )
◎
Let F be ! CreateBuiltinFunction(steps, « », globalObject’s relevant Realm).
</li>
	<li>
~NOABRUPT `SetFunctionName$Ax( %F, `size^l )
◎
Perform ! SetFunctionName(F, "size").
</li>
	<li>
~NOABRUPT `SetFunctionLength$Ax( %F, 0 )
◎
Perform ! SetFunctionLength(F, 0).
</li>
	<li>
%大域~obj の`~count~queuing策~size関数$ ~SET 
%F への参照を表現する `Function$I
— その`~callback文脈$は、%大域~obj に`関連な設定群~obj$になるとする
◎
Set globalObject’s count queuing strategy size function to a Function that represents a reference to F, with callback context equal to globalObject’s relevant settings object.
</li>
</ol>

<p class="note">注記：
この設計は、いくぶん歴史的である。
その動機は、
`size$cqs は関数であって~methodではない
— すなわち，その `this^jv 値を検査しない —
ことを確保したいと欲されることにある。
更なる背景は、
<a href="https://github.com/whatwg/streams/issues/1005">課題 #1005</a>,
<a href="https://github.com/heycam/webidl/issues/819">heycam/webidl#819</a>
を見よ。
◎
This design is somewhat historical. It is motivated by the desire to ensure that size is a function, not a method, i.e. it does not check its this value. See whatwg/streams#1005 and heycam/webidl#819 for more background.
</p>
</div>

			</section>
			<section id="cqs-prototype">
<h4 title="Constructor and properties">7.3.3. 構築子, ~prop</h4>

<dl class="domintro">
	<dt>%strategy = `new CountQueuingStrategy$m({ `highWaterMark$qsi })</dt>
	<dd>
供された`限界水位$を伴う新たな `CountQueuingStrategy$I を作成する。
◎
Creates a new CountQueuingStrategy with the provided high water mark.
</dd>
	<dd>
供された`限界水位$は、事前に検証されないことに注意。
それが［
~numberでない／
`NaN^jv または負な~numberである
］場合、結果の `CountQueuingStrategy$I は，対応する~stream構築子にて例外を投出させることになる。
◎
Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting CountQueuingStrategy will cause the corresponding stream constructor to throw.
</dd>

	<dt>%highWaterMark = %strategy.`highWaterMark$cqs</dt>
	<dd>
構築子に供された`限界水位$を返す。
◎
Returns the high water mark provided to the constructor.
</dd>

	<dt>%strategy.`size(chunk)$cqs</dt>
	<dd>
常に 1 を返すことにより，
%chunk の~sizeを測定する。
これは、合計~queue~sizeは~queue内にある`~chunk$の個数になることを確保する。
◎
Measures the size of chunk by always returning 1. This ensures that the total queue size is a count of the number of chunks in the queue.
</dd>
</dl>

<div class="algo">
<p>
`new CountQueuingStrategy(init)@m
構築子~手続きは：
◎
The CountQueuingStrategy(init) constructor steps are:
</p>
<ol>
	<li>
コレ.`highWaterMark^sl ~SET %init[ "`highWaterMark$qsi" ]
◎
Set this.[[highWaterMark]] to init["highWaterMark"].
</li>
</ol>
</div>

<div class="algo">
<p>
`highWaterMark@cqs
取得子~手続きは：
◎
The highWaterMark attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレ.`highWaterMark^sl
◎
Return this.[[highWaterMark]].
</li>
</ol>
</div>

<div class="algo">
<p>
`size@cqs
取得子~手続きは：
◎
The size attribute’s getter steps are:
</p>
<ol>
	<li>
~RET コレに`関連な大域~obj$の`~count~queuing策~size関数$
◎
Return this's relevant global object's count queuing strategy size function.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="qs-abstract-ops">
<h3 title="Abstract operations">7.4. 抽象-演算</h3>

<p>
以下に与える~algoは、~stream構築子により利用され，
`QueuingStrategy$I 辞書から関連な情報片を抽出する。
◎
The following algorithms are used by the stream constructors to extract the relevant pieces from a QueuingStrategy dictionary.
</p>

<div class="algo">
<p>
`ExtractHighWaterMark(strategy, defaultHWM)@A
は、次の手続きを遂行する：
◎
ExtractHighWaterMark(strategy, defaultHWM) performs the following steps:
</p>
<ol>
	<li>
~IF［
%strategy[ "`highWaterMark$qs" ] ~EQ ε
］
⇒
~RET %defaultHWM
◎
If strategy["highWaterMark"] does not exist, return defaultHWM.
</li>
	<li>
%highWaterMark ~LET %strategy[ "`highWaterMark$qs" ]
◎
Let highWaterMark be strategy["highWaterMark"].
</li>
	<li>
~IF［
%highWaterMark ~EQ `NaN^jv
］~OR［
%highWaterMark ~LT 0
］
⇒
~THROW `RangeError$E
◎
If highWaterMark is NaN or highWaterMark &lt; 0, throw a RangeError exception.
</li>
	<li>
~RET %highWaterMark
◎
Return highWaterMark.
</li>
</ol>

<p class="note">注記：
`+∞^jv は、妥当な`限界水位$として明示的に許容され，`背圧$は決して適用されないようにする。
◎
+∞ is explicitly allowed as a valid high water mark. It causes backpressure to never be applied.
</p>
</div>

<div class="algo">
<p>
`ExtractSizeAlgorithm(strategy)@A
は、次の手続きを遂行する：
◎
ExtractSizeAlgorithm(strategy) performs the following steps:
</p>
<ol>
	<li>
~IF［
%strategy[ "`size$qs" ] ~EQ ε
］
⇒
~RET 次を走らす~algo
⇒
~RET 1
◎
If strategy["size"] does not exist, return an algorithm that returns 1.
</li>
	<li>
<p>
~RET 所与の ( %chunk ) に対し，次を走らす~algo
⇒
~RET `~callback関数を呼出す$( %strategy[ "`size$qs" ], « %chunk » )
◎
Return an algorithm that performs the following steps, taking a chunk argument:
• Return the result of invoking strategy["size"] with argument list « chunk ».
</li>
</ol>
</div>

		</section>
	</section>
	<section id="other-stuff">
<h2 title="Supporting abstract operations">8. ~support用の抽象-演算</h2>

<p>
以下に与える各~抽象-演算は、複数の型の~streamの実装を~supportするので，主要な節の下に置かれていない。
◎
The following abstract operations each support the implementation of more than one type of stream, and as such are not grouped under the major sections above.
</p>

		<section id="queue-with-sizes">
<h3 title="Queue-with-sizes">8.1. 個別~size付き~queue</h3>

<p>
この仕様における各種~streamは、
“個別~size付き~queue”
（ `queue-with-sizes^en ）と称される~data構造を利用して，~queueしておかれた値を, それに決定された~sizeと伴に格納する。
個別~size付き~queueは、仕様~levelの様々な~objに包含され，常に［
`queue^sl, `queueTotalSize^sl
と命名され，~pairにされる 2 つの内部~slot
］を持つ~objとして表現される。
`queue^sl は，`~sizeを伴う値$たちが成す`~list$であり、
`queueTotalSize^sl は，~JS `Number$jT
— すなわち，倍精度~浮動小数点~number —
をとる。
◎
The streams in this specification use a "queue-with-sizes" data structure to store queued up values, along with their determined sizes. Various specification objects contain a queue-with-sizes, represented by the object having two paired internal slots, always named [[queue]] and [[queueTotalSize]]. [[queue]] is a list of value-with-sizes, and [[queueTotalSize]] is a JavaScript Number, i.e. a double-precision floating point number.
</p>

<p>
個別~size付き~queueを包含する~obj上で演算するときには、
この 2 つの内部~slotが同期し続けることを確保するため，以下の抽象-演算が利用される。
◎
The following abstract operations are used when operating on objects that contain queues-with-sizes, in order to ensure that the two internal slots stay synchronized.
</p>

<p class="warning">
ここに指定される~frameworkは，合計が `queueTotalSize^sl ~slotに~~収まり続けるようにするが、浮動小数点 算術の精度には限りがあるため，
`queue^sl 内の すべての`~chunk$の~sizeを加算していくことに`等価ではない^em。
（しかしながら，この相違が生じるのは、~chunkたちの~sizeの変動幅が莫大になるとき（ 〜 10<sup>15</sup> ）か, 数 100 京 個の~chunkが~enqueueされたときに限られる。）
◎
Due to the limited precision of floating-point arithmetic, the framework specified here, of keeping a running total in the [[queueTotalSize]] slot, is not equivalent to adding up the size of all chunks in [[queue]]. (However, this only makes a difference when there is a huge (~1015) variance in size between chunks, or when trillions of chunks are enqueued.)
</p>

<p>
`~sizeを伴う値@
は、次に挙げる`~item$sctからなる`構造体$である
⇒＃
`値@Vs,
`~size@Vs
◎
In what follows, a value-with-size is a struct with the two items value and size.
</p>

<div class="algo">
<p>
`DequeueValue(container)@A
は、次を遂行する：
◎
DequeueValue(container) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%container は
`queue^sl, `queueTotalSize^sl
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
~Assert：
%container.`queue^sl は`空$でない
◎
Assert: container.[[queue]] is not empty.
</li>
	<li>
%valueWithSize ~LET %container.`queue^sl[0]
◎
Let valueWithSize be container.[[queue]][0].
</li>
	<li>
%container.`queue^sl から %valueWithSize を`除去する$
◎
Remove valueWithSize from container.[[queue]].
</li>
	<li>
%container.`queueTotalSize^sl ~SET %container.`queueTotalSize^sl ~MINUS %valueWithSize の`~size$Vs
◎
Set container.[[queueTotalSize]] to container.[[queueTotalSize]] − valueWithSize’s size.
</li>
	<li>
~IF［
%container.`queueTotalSize^sl ~LT 0 （これは丸め誤差に因り生じ得る）
］
⇒
%container.`queueTotalSize^sl ~SET 0
◎
If container.[[queueTotalSize]] &lt; 0, set container.[[queueTotalSize]] to 0. (This can occur due to rounding errors.)
</li>
	<li>
~RET %valueWithSize の`値$Vs
◎
Return valueWithSize’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
`EnqueueValueWithSize(container, value, size)@A
は、次を遂行する：
◎
EnqueueValueWithSize(container, value, size) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%container は
`queue^sl, `queueTotalSize^sl
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
~IF［
~NOABRUPT `IsNonNegativeNumber$A( %size ) ~EQ ~F
］
⇒
~THROW `RangeError$E
◎
If ! IsNonNegativeNumber(size) is false, throw a RangeError exception.
</li>
	<li>
~IF［
%size ~EQ `+∞^jv
］
⇒
~THROW `RangeError$E
◎
If size is +∞, throw a RangeError exception.
</li>
	<li>
%container.`queue^sl に［
次を伴う，新たな`~sizeを伴う値$
］を`付加する$
⇒＃
`値$Vs ~SET %value,
`~size$Vs ~SET %size
◎
Append a new value-with-size with value value and size size to container.[[queue]].
</li>
	<li>
%container.`queueTotalSize^sl ~INCBY %size
◎
Set container.[[queueTotalSize]] to container.[[queueTotalSize]] + size.
</li>
</ol>
</div>

<div class="algo">
<p>
`PeekQueueValue(container)@A
は、次を遂行する：
◎
PeekQueueValue(container) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%container は
`queue^sl, `queueTotalSize^sl
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
~Assert：
%container.`queue^sl は`空$でない
◎
Assert: container.[[queue]] is not empty.
</li>
	<li>
%valueWithSize ~LET %container.`queue^sl[0]
◎
Let valueWithSize be container.[[queue]][0].
</li>
	<li>
~RET %valueWithSize の`値$Vs
◎
Return valueWithSize’s value.
</li>
</ol>
</div>

<div class="algo">
<p>
`ResetQueue(container)@A
は、次を遂行する：
◎
ResetQueue(container) performs the following steps:
</p>
<ol>
	<li>
~Assert：
%container は
`queue^sl, `queueTotalSize^sl
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
%container.`queue^sl ~SET 新たな空`~list$
◎
Set container.[[queue]] to a new empty list.
</li>
	<li>
%container.`queueTotalSize^sl ~SET 0
◎
Set container.[[queueTotalSize]] to 0.
</li>
</ol>
</div>

		</section>
		<section id="misc-abstract-ops">
<h3 title="Miscellaneous">8.2. 諸々の演算</h3>

<p>
以下に与える抽象-演算は、~~便利用の寄せ集めである。
◎
The following abstract operations are a grab-bag of utilities.
</p>

<div class="algo">
<p>
`IsNonNegativeNumber(v)@A
は、次を遂行する：
◎
IsNonNegativeNumber(v) performs the following steps:
</p>
<ol>
	<li>
~IF［
`Type$A( %v ) ~NEQ `Number$jT
］
⇒
~RET ~F
◎
If Type(v) is not Number, return false.
</li>
	<li>
~IF［
%v ~EQ `NaN^jv
］
⇒
~RET ~F
◎
If v is NaN, return false.
</li>
	<li>
~IF［
%v ~LT 0
］
⇒
~RET ~F
◎
If v &lt; 0, return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>


<div class="algo">
<p>
`TransferArrayBuffer(O)@A
は、次を遂行する：
◎
TransferArrayBuffer(O) performs the following steps:
</p>
<ol>
	<li>
~Assert：`Type$A( %O ) ~EQ `Object^jT
◎
Assert: Type(O) is Object.
</li>
	<li>
~Assert：
%O は `ArrayBufferData^sl 内部~slotを持つ
◎
Assert: O has an [[ArrayBufferData]] internal slot.
</li>
	<li>
~Assert：
~NOABRUPT `IsDetachedBuffer$Ax( %O ) ~EQ ~F
◎
Assert: ! IsDetachedBuffer(O) is false.
</li>
	<li>
%arrayBufferData ~LET %O.`ArrayBufferData^sl
◎
Let arrayBufferData be O.[[ArrayBufferData]].
</li>
	<li>
%arrayBufferByteLength ~LET %O.`ArrayBufferByteLength^sl
◎
Let arrayBufferByteLength be O.[[ArrayBufferByteLength]].
</li>
	<li>
~NOABRUPT `DetachArrayBuffer$Ax( %O )
◎
Perform ! DetachArrayBuffer(O).
</li>
	<li>
~RET 新たな `ArrayBuffer$I ~obj
— `現在の~Realm$内に作成され, 次のように設定された
⇒＃
`ArrayBufferData^sl 内部~slot ~SET %arrayBufferData,
`ArrayBufferByteLength^sl 内部~slot ~SET %arrayBufferByteLength
◎
Return a new ArrayBuffer object, created in the current Realm, whose [[ArrayBufferData]] internal slot value is arrayBufferData and whose [[ArrayBufferByteLength]] internal slot value is arrayBufferByteLength.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="creating-examples">
<h2 title="Examples of creating streams">9. ~streamを作成する例</h2>

<p>
`この節とその各下位節すべては、規範的でない。^em
◎
This section, and all its subsections, are non-normative.
</p>

<p>
これまでの例では、~streamを利用する方法に力点を置いていた。
ここでは、［
`ReadableStream$I ／ `WritableStream$I ／ `TransformStream$I
］の構築子を利用して，~streamを作成する方法を示す。
◎
The previous examples throughout the standard have focused on how to use streams. Here we show how to create a stream, using the ReadableStream, WritableStream, and TransformStream constructors.
</p>

		<section id="example-rs-push-no-backpressure">
<h3 title="A readable stream with an underlying push source (no backpressure support)">9.1. 下層~push源を伴う可読~stream（背圧~supportなし）</h3>

<p>
次の関数は、 `WebSocket$I ~instance `HTML$r を包装する可読~streamを作成する。
それは、背圧~通達を~supportしない`~push源$である。
【！ It illustrates how,】
`~push源$に適応させるとき、通例的に，働きを成す大部分は `start()$usc ~methodにて起きるようにされる。
◎
The following function creates readable streams that wrap WebSocket instances [HTML], which are push sources that do not support backpressure signals. It illustrates how, when adapting a push source, usually most of the work happens in the start() method.
</p>

<pre class="lang-js">
function makeReadableWebSocketStream(%url, %protocols) {
  const %ws = new WebSocket(%url, %protocols);
  %ws.binaryType = `arraybuffer^l;

  return new ReadableStream({
    start(%controller) {
      %ws.onmessage =
          %event =&gt; %controller.enqueue(%event.data);
      %ws.onclose =
          () =&gt; %controller.close();
      %ws.onerror =
          () =&gt; %controller.error(new Error(`WebSocket に~errorが生じました^l));
    },

    cancel() {
      %ws.close();
    }
  });
}
</pre>

<!-- 
The WebSocket errored!
-->
<p>
この関数を利用すれば、~web~socket用の可読~streamを作成して，それを任意な可書~streamへ~pipeできるようになる：
◎
We can then use this function to create readable streams for a web socket, and pipe that stream to an arbitrary writable stream:
</p>

<pre class="lang-js">
const %webSocketStream =
    makeReadableWebSocketStream(`wss://example.com:443/^l, `protocol^l);

webSocketStream.pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>

<div class="note" id="note-web-socket-wrapping-examples">

<p>
~web~socketをこのように包装する~styleは、~web~socket~messageを，直に`~chunk$として解釈する。
これは、簡便な抽象-化になり得る
— 例えば、各~web~socket~messageが［
消費する／形式変換する
］~chunkとしてイミを成すように［
`可書~stream$／`形式変換~stream$
］へ`~pipeする$とき。
◎
This specific style of wrapping a web socket interprets web socket messages directly as chunks. This can be a convenient abstraction, for example when piping to a writable stream or transform stream for which each web socket message makes sense as a chunk to consume or transform.
</p>

<p>
しかしながら，誰かが
“~web~socketに~stream~supportを追加する”
ことについて話すときは、代わりに［
個々の~web~socket~messageを，~streaming方式fで送信する
］ような新たな能力を希望していることが多い
— 例えば、~fileを［
そのすべての内容を~client側の記憶域~内に保持する
］ことなく，単独の~message内に転送できるような。
この目標を成遂げるためには、個々の~web~socket~message自身が `ReadableStream$I ~instanceになれることが求まれる。
それは、上の例に示したものではない。
◎
However, often when people talk about "adding streams support to web sockets", they are hoping instead for a new capability to send an individual web socket message in a streaming fashion, so that e.g. a file could be transferred in a single message without holding all of its contents in memory on the client side. To accomplish this goal, we’d instead want to allow individual web socket messages to themselves be ReadableStream instances. That isn’t what we show in the above example.
</p>

<p>
背景情報については、
<a href="https://github.com/w3c/webrtc-pc/issues/1732#issuecomment-358428651">この論点</a>
を見よ。
◎
For more background, see this discussion.
</p>
</div>

		</section>
		<section id="example-rs-push-backpressure">
<h3 title="A readable stream with an underlying push source and backpressure support">9.2. 下層~push源を伴う可読~stream（背圧~supportあり）</h3>

<p>
次の関数は、 “背圧~socket” を包装する`可読~stream$を返す
— 背圧~socketは、~web~socketと同じ~APIを持つ仮説上の~objであるが，［
`readStop^m ／ `readStart^m
］~methodにより，~dataの流れを［
静止する／再開する
］能も供する。
この例は、そうすることで，背圧を~supportする`下層~源$にそれを適用する方法を示すものになる。
◎
The following function returns readable streams that wrap "backpressure sockets," which are hypothetical objects that have the same API as web sockets, but also provide the ability to pause and resume the flow of data with their readStop and readStart methods. In doing so, this example shows how to apply backpressure to underlying sources that support it.
</p>

<pre class="lang-js">
function makeReadableBackpressureSocketStream(%host, %port) {
  const %socket = createBackpressureSocket(%host, %port);

  return new ReadableStream({
    start(%controller) {
      %socket.ondata = %event =&gt; {
        %controller.enqueue(%event.data);

        if (%controller.desiredSize &lt;= 0) {
          /* <span class="comment">
内部~queueは満杯なので，下層~源へ背圧~通達を伝播させる。
◎
The internal queue is full, so propagate the backpressure signal to the underlying source.
</span> */
          socket.readStop();
        }
      };

      %socket.onend =
          () =&gt; %controller.close();
      %socket.onerror =
          () =&gt; %controller.error(new Error(`~socketに~errorが生じました^l));
    },

    pull() {
      /* <span class="comment">
内部~queueが空になったが，~streamの消費器は まだ更なる~dataを求めている場合に~callされる。
その場合、それまで静止していたなら~dataの流れを~~再開する。
◎
This is called if the internal queue has been emptied, but the stream’s consumer still wants more data. In that case, restart the flow of data if we have previously paused it.
</span> */
      %socket.readStart();
    },

    cancel() {
      %socket.close();
    }
  });
}
</pre>

<!-- 
"The socket errored!"
-->

<p>
この関数を利用すれば、~web~socketのときと同じ仕方で，そのような “背圧~socket” 用の可読~streamを作成できるようになる。
しかしながら，この場合には、［
~socketが生産するほど高速には~dataを受容できないような行先へ~pipeされたとき
］, あるいは［
しばらくの間~streamから読取することなく放置したとき
］は，［
背圧~通達がその~socketに向けて送信される
］ことになる。
◎
We can then use this function to create readable streams for such "backpressure sockets" in the same way we do for web sockets. This time, however, when we pipe to a destination that cannot accept data as fast as the socket is producing it, or if we leave the stream alone without reading from it for some time, a backpressure signal will be sent to the socket.
</p>

		</section>
		<section id="example-rbs-push">
<h3 title="A readable byte stream with an underlying push source (no backpressure support)">9.3. 下層~push源を伴う可読~byte~stream（背圧~supportなし）</h3>

<p>
次の関数は、仮説上の UDP ~socket~APIを包装する`可読~byte~stream$を返す
— それは、 POSIX `select(2)^c ~system~callを想起するよう意味された，~promiseを返す `select2()^c ~methodを含む。
◎
The following function returns readable byte streams that wraps a hypothetical UDP socket API, including a promise-returning select2() method that is meant to be evocative of the POSIX select(2) system call.
</p>

<p>
UDP ~protocolには組込みの背圧~supportはないので、 `desiredSize$rbsc が与える背圧~通達は無視される。
~streamは、~socketからの~dataが可用になったが，開発者からはまだ要請されていないときには、~streamの`内部~queue$に~enqueueして，~kernel空間の~queueから溢れないようにすることも確保する。
◎
Since the UDP protocol does not have any built-in backpressure support, the backpressure signal given by desiredSize is ignored, and the stream ensures that when data is available from the socket but not yet requested by the developer, it is enqueued in the stream’s internal queue, to avoid overflow of the kernel-space queue and a consequent loss of data.
</p>

<p>
これには、`消費器$と~streamとの間のヤリトリについて興味を引く帰結がある。
消費器が~socketが生産するほど高速に~dataを読取しない場合、`~chunk$たちは，不定期の間~streamの`内部~queue$に残り続ける。
その場合，`~BYOB読取器$を利用すると，~dataを~streamの内部~queueから開発者が給する~bufferへ移動するときに，余分な複製が生じることになる。
一方で，消費器が~dataを十分~素早く消費した場合、`~BYOB読取器$においては，
開発者から給される~bufferへ複製なしに直に読取できるようになる。
◎
This has some interesting consequences for how consumers interact with the stream. If the consumer does not read data as fast as the socket produces it, the chunks will remain in the stream’s internal queue indefinitely. In this case, using a BYOB reader will cause an extra copy, to move the data from the stream’s internal queue to the developer-supplied buffer. However, if the consumer consumes the data quickly enough, a BYOB reader will allow zero-copy reading directly into developer-supplied buffers.
</p>

<p>
（この例より複階的な~version
— `desiredSize$rbsc を利用して［
帯域外の，背圧を通達する仕組み
］（例えば，~socketに向けて ~dataの送信~rateを調整するような~messageを送信するなど）を伝えるなど —
も~~想定できるが、それについては，読者への演習に残しておく。）
◎
(You can imagine a more complex version of this example which uses desiredSize to inform an out-of-band backpressure signaling mechanism, for example by sending a message down the socket to adjust the rate of data being sent. That is left as an exercise for the reader.)
</p>

<pre class="lang-js">
const %DEFAULT_CHUNK_SIZE = 65536;

function makeUDPSocketStream(%host, %port) {
  const %socket = createUDPSocket(%host, %port);

  return new ReadableStream({
    type: `bytes^l,

    start(%controller) {
      readRepeatedly().catch(%e =&gt; %controller.error(%e));

      function readRepeatedly() {
        return %socket.select2().then(() =&gt; {
          /* <span class="comment">
処理待ち~BYOB要請（ `byobRequest$rbsc ）がないときでも， %socket は読取n可能になり得るので、両~事例とも取扱う必要がある。
◎
Since the socket can become readable even when there’s no pending BYOB requests, we need to handle both cases.
</span> */
          let %bytesRead;
          if (%controller.byobRequest) {
            const %v = %controller.byobRequest.view;
            %bytesRead = %socket.readInto(%v.buffer, %v.byteOffset, v.byteLength);
            %controller.byobRequest.respond(%bytesRead);
          } else {
            const %buffer = new ArrayBuffer(%DEFAULT_CHUNK_SIZE);
            %bytesRead = %socket.readInto(buffer, 0, %DEFAULT_CHUNK_SIZE);
            %controller.enqueue(new Uint8Array(%buffer, 0, %bytesRead));
          }

          if (%bytesRead === 0) {
            %controller.close();
            return;
          }

          return readRepeatedly();
        });
      }
    },

    cancel() {
      %socket.close();
    }
  });
}
</pre>

<p>
この関数から返される `ReadableStream$I ~instanceは、今や，前に示したすべての便益と但し書きを伴うような `~BYOB読取器$を配給できる。
◎
ReadableStream instances returned from this function can now vend BYOB readers, with all of the aforementioned benefits and caveats.
</p>

		</section>
		<section id="example-rs-pull">
<h3 title="A readable stream with an underlying pull source">9.4. 下層~pull源を伴う可読~stream</h3>

<p>
次の関数は、（それ自身 直に C 言語の［
`fopen()^m, `fread()^m, `fclose()^m
］組みへ対応付けている）
<a href="https://nodejs.org/api/fs.html">Node.js file system API</a>
の各部を包装する，`可読~stream$を返す。
~fileは `~pull源$の代表的な例である。
`~push源$を伴う例とは対照的に、ここでの働きを成す大部分は、
`start()$usc 関数の開始時ではなく，
`pull()$usc 関数~内でその時々に起きることに注意。
◎
The following function returns readable streams that wrap portions of the Node.js file system API (which themselves map fairly directly to C’s fopen, fread, and fclose trio). Files are a typical example of pull sources. Note how in contrast to the examples with push sources, most of the work here happens on-demand in the pull() function, and not at startup time in the start() function.
</p>

<pre class="lang-js">
const %fs = require("fs").promises;
const %CHUNK_SIZE = 1024;

function makeReadableFileStream(%filename) {
  let %fileHandle;
  let %position = 0;

  return new ReadableStream({
    async start() {
      %fileHandle = await %fs.open(%filename, "r");
    },

    async pull(%controller) {
      const %buffer = new ArrayBuffer(%CHUNK_SIZE);

      const { %bytesRead } = await %fileHandle.read(%buffer, 0, %CHUNK_SIZE, %position);
      if (%bytesRead === 0) {
        await %fileHandle.close();
        %controller.close();
      } else {
        %position += %bytesRead;
        %controller.enqueue(new Uint8Array(%buffer, 0, %bytesRead));
      }
    },

    cancel() {
      return %fileHandle.close();
    }
  });
}
</pre>

<p>
これを利用すれば、前に~socketに対しできたときとちょうど~~同じく，~file用の可読~streamを作成して利用できるようになる。
◎
We can then create and use readable streams for files just as we could before for sockets.
</p>

		</section>
		<section id="example-rbs-pull">
<h3 title="A readable byte stream with an underlying pull source">9.5. 下層~pull源を伴う可読~byte~stream</h3>

<p>
次の関数は，
<a href="https://nodejs.org/api/fs.html">Node.js file system API</a>
を再度~利用して`可読~byte~stream$を返すが、今度は，~fileを複製することなく効率的に読取できるようにする。
それは、予め決定-済みの~chunk~size 1024 を利用する代わりに，開発者から給された~bufferを~fillしようと試みることで、全部的に制御できるようにする。
◎
The following function returns readable byte streams that allow efficient zero-copy reading of files, again using the Node.js file system API. Instead of using a predetermined chunk size of 1024, it attempts to fill the developer-supplied buffer, allowing full control.
</p>

<pre class="lang-js">
const %fs = require("fs").promises;
const %DEFAULT_CHUNK_SIZE = 1024;

function makeReadableByteFileStream(%filename) {
 let %fileHandle;
 let %position = 0;

  return new ReadableStream({
    type: "bytes",

    async start() {
      %fileHandle = await %fs.open(%filename, "r");
    },

    pull(%controller) {
      /* <span class="leaf comment">
消費器が既定の読取器を利用していても，自動-割振り特能は、~bufferを割振って，それを `byobRequest$rbsc を介して渡してくれる。
◎
Even when the consumer is using the default reader, the auto-allocation feature allocates a buffer and passes it to us via byobRequest.
</span> */
      const %v = %controller.byobRequest.view;

      const { %bytesRead } = await %fileHandle.read(%v.buffer, %v.byteOffset, %v.byteLength);
      if (%bytesRead === 0) {
        await %fileHandle.close();
        %controller.close();
      } else {
        %position += %bytesRead;
        %controller.byobRequest.respond(%bytesRead);
      }
    },

    cancel() {
      return %fs.close(%fd);
    },

    autoAllocateChunkSize: %DEFAULT_CHUNK_SIZE
  });
}
</pre>

<p>
これを使えば、返された `ReadableStream$I 用の`~BYOB読取器$を作成して利用できるようになる。
一方で、それを［
通例通り，単純かつ汎用的な方式
］で利用して，`既定の読取器$を作成することもできる。
［
低~levelな，ここに示す`下層~byte源$に対する~byteの追跡
］と［
より高~levelな，~chunkに基づく`既定の読取器$による消費
］との間の適応は、すべて，~stream実装により自動的に~careされる。
`autoAllocateChunkSize$usc ~optionを介する自動-割振り特能は、［
`下層~push源を伴う可読~byte~stream（背圧~supportなし）$sec
のように手動的に分岐する
］のに比して，必要な~code量も少なく済ませられる。
◎
With this in hand, we can create and use BYOB readers for the returned ReadableStream. But we can also create default readers, using them in the same simple and generic manner as usual. The adaptation between the low-level byte tracking of the underlying byte source shown here, and the higher-level chunk-based consumption of a default reader, is all taken care of automatically by the streams implementation. The auto-allocation feature, via the autoAllocateChunkSize option, even allows us to write less code, compared to the manual branching in § 9.3 A readable byte stream with an underlying push source (no backpressure support).
</p>

		</section>
		<section id="example-ws-no-backpressure">
<h3 title="A writable stream with no backpressure or success signals">9.6. 背圧や成功の通達を伴わない可書~stream</h3>

<p>
次の関数は、 `WebSocket$I `HTML$r を包装する`可書~stream$を返す。
~web~socketは［
所与の~dataの`~chunk$が いつ成功裡に送信されたか
］を伝える仕方を供さない（扱いにくい `bufferedAmount$m の~pollingを行わない限り
— それについては，読者への演習に残しておく）。
そのようなわけで、この可書~streamは，その`生産器$に［
正確aな背圧~通達や 書込nの成否
］を通信する能を持たない。
すなわち、その`書込器$の［
`write()$dw ~method ／ `ready$dw 取得子
］から返される~promiseは、常に即時に充足されることになる。
◎
The following function returns a writable stream that wraps a WebSocket [HTML]. Web sockets do not provide any way to tell when a given chunk of data has been successfully sent (without awkward polling of bufferedAmount, which we leave as an exercise to the reader). As such, this writable stream has no ability to communicate accurate backpressure signals or write success/failure to its producers. That is, the promises returned by its writer's write() method and ready getter will always fulfill immediately.
</p>

<pre class="lang-js">
function makeWritableWebSocketStream(%url, %protocols) {
  const %ws = new WebSocket(%url, %protocols);

  return new WritableStream({
    start(%controller) {

      %ws.onerror = () =&gt; {
        %controller.error(new Error(`WebSocket に~errorが生じました^l));
        %ws.onclose = null;
      };
      %ws.onclose = () =&gt; {
        %controller.error(new Error(`接続は不意に~serverにより~closeされました^l));
      }
      return new Promise(%resolve =&gt; %ws.onopen = %resolve);
    },

    write(%chunk) {
      %ws.send(%chunk);
        /* <span class="comment">
即時に返る
— ~web~socketでは，書込nがいつ完了するかを伝える容易な仕方はないので。
◎
Return immediately, since the web socket gives us no easy way to tell when the write completes.
</span> */
    },

    close() {
      return closeWS(1000);
    },

    abort(%reason) {
      return closeWS(4000, %reason && %reason.message);
    },
  });

  function closeWS(%code, %reasonString) {
    return new Promise((%resolve, %reject) =&gt; {
      %ws.onclose = %e =&gt; {
        if (%e.wasClean) {
          %resolve();
        } else {
          %reject(new Error(`接続は~cleanに~closeされませんでした^l));
        }
      };
      %ws.close(%code, %reasonString);
    });
  }
}
</pre>
<!-- 
The server closed the connection unexpectedly
The connection was not closed cleanly
-->

<p>
この関数を利用すれば、~web~socket用の可書~streamを作成して，任意な可読~streamをそれに~pipeできるようになる：
◎
We can then use this function to create writable streams for a web socket, and pipe an arbitrary readable stream to it:
</p>

<pre class="lang-js">
const %webSocketStream = makeWritableWebSocketStream(
    `wss://example.com:443/^l, `protocol^l);

readableStream.pipeTo(%webSocketStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>

<p class="note">注記：
この~styleで~web~socketを~streamの中に包装することについては、
<a href="#note-web-socket-wrapping-examples">前述の注記</a>
を見よ。
◎
See the earlier note about this style of wrapping web sockets into streams.
</p>

		</section>
		<section id="example-ws-backpressure">
<h3 title="A writable stream with backpressure and success signals">9.7. 背圧や成功の通達を伴う可書~stream</h3>

<p>
次の関数は、（それ自身 直に C 言語の［
`fopen^m, `fwrite^m, `fclose^m
］組みへ対応付けている）
<a href="https://nodejs.org/api/fs.html">Node.js file system API</a>
の各部を包装する，`可書~stream$を返す。
その~APIは、所与の書込nが成功したときにそれを伝える仕方を供するので、この~streamは，個々の書込nの成否も込みで，`背圧$通達を通信できる。
◎
The following function returns writable streams that wrap portions of the Node.js file system API (which themselves map fairly directly to C’s fopen, fwrite, and fclose trio). Since the API we are wrapping provides a way to tell when a given write succeeds, this stream will be able to communicate backpressure signals as well as whether an individual write succeeded or failed.
</p>

<pre class="lang-js">
const %fs = require("fs").promises;

function makeWritableFileStream(%filename) {
  let %fileHandle;

  return new WritableStream({
    async start() {
      %fileHandle = await %fs.open(%filename, "w");
    },

    write(%chunk) {
      return %fileHandle.write(%chunk, 0, %chunk.length);
    },

    close() {
      return %fs.close(%fd);
    },

    abort() {
      return %fs.close(%fd);
    }
  });
}
</pre>

<p>
この関数を利用すれば、~file用の可書~streamを作成して，個々の~data`~chunk$を書込できるようになる：
◎
We can then use this function to create a writable stream for a file, and write individual chunks of data to it:
</p>

<pre class="lang-js">
const %fileStream = makeWritableFileStream(`/example/path/on/fs.txt^l);
const %writer = %fileStream.getWriter();

%writer.write(`~streamするか, しないか、\n^l);
%writer.write(`それが~~問題だ。\n^l);

%writer.close()
  .then( () =&gt; console.log(
      `~chunkたちは書込され, ~streamは成功裡に~closeされました^l
  ))
  .catch(%e =&gt; console.error(%e));
</pre>

<!-- 
"To stream, or not to stream\n"
"That is the question\n"
"chunks written and stream closed successfully!"
-->

<p>
特定0の `fileHandle.write^m ~callにて時間がかかる場合、返される~promiseは，~~後に充足されることになることに注意。
当面の間は，追加的な書込nを~queueしておける
— それらは~streamの内部~queueに格納される。
この~queueにおける`~chunk$たちの累積により、~streamは， `ready$dw 取得子が処理待ち~promiseを返すように変化し得る
— それは、~streamの`生産器$に［
アリなら，手を止めて書込みを停止することで、便益を得ることになる
］ことを通達する。
◎
Note that if a particular call to fileHandle.write takes a longer time, the returned promise will fulfill later. In the meantime, additional writes can be queued up, which are stored in the stream’s internal queue. The accumulation of chunks in this queue can change the stream to return a pending promise from the ready getter, which is a signal to producers that they would benefit from backing off and stopping writing, if possible.
</p>

<p>
この事例においては、可書~streamが書込nを~queueしておく仕方が，とりわけ重要になる
—
<a href="https://nodejs.org/api/fs.html#fs_filehandle_write_buffer_offset_length_position">`fileHandle.write^m にて文書化されている</a>
ように：
<q>
~promiseを待機することなく，同じ~file上で
`fileHandle.write^m を複数回 利用することは安全でない</q>
ので。
しかしながら、 `makeWritableFileStream^m 関数を書くときは，それについて心配する必要はない
— ~stream実装が，次を保証してくれる
⇒
`下層~槽$の `write()$usk ~methodは、［
以前の~callにより返された~promiseがあれば，それが充足される
］までは~callされない
◎
The way in which the writable stream queues up writes is especially important in this case, since as stated in the documentation for fileHandle.write, "it is unsafe to use filehandle.write multiple times on the same file without waiting for the promise." But we don’t have to worry about that when writing the makeWritableFileStream function, since the stream implementation guarantees that the underlying sink's write() method will not be called until any promises returned by previous calls have fulfilled!
</p>

		</section>
		<section id="example-both">
<h3 title="A { readable, writable } stream pair wrapping the same underlying resource">9.8.  同じ下層~資源を包装する { 可読, 可書 } ~stream~pair</h3>

<p>
次の関数は
`{ readable, writable }^c
の形による~objを返す
—
`readable^m ~propは可読~streamを,
`writable^m ~propは可書~streamを包含していて、両~streamとも同じ下層~web~socket資源を包装するような。
これは、本質的には，［
`下層~push源を伴う可読~stream（背圧~supportなし）$sec
］と［
`背圧や成功の通達を伴わない可書~stream$sec
］を組合せる。
◎
The following function returns an object of the form { readable, writable }, with the readable property containing a readable stream and the writable property containing a writable stream, where both streams wrap the same underlying web socket resource. In essence, this combines § 9.1 A readable stream with an underlying push source (no backpressure support) and § 9.6 A writable stream with no backpressure or success signals.
</p>

<p>
~JS~classを利用して、再利用-可能な
`下層~槽$／`下層~源$
の抽象-化を作成する方法を~~示す：
◎
While doing so, it illustrates how you can use JavaScript classes to create reusable underlying sink and underlying source abstractions.
</p>

<pre class="lang-js">
function streamifyWebSocket(%url, %protocol) {
  const %ws = new WebSocket(%url, %protocols);
  %ws.binaryType = `arraybuffer^l;

  return {
    readable: new ReadableStream(new WebSocketSource(%ws)),
    writable: new WritableStream(new WebSocketSink(%ws))
  };
}

class WebSocketSource {
  constructor(%ws) {
    this._ws = %ws;
  }

  start(%controller) {
    this._ws.onmessage =
        %event =&gt; %controller.enqueue(%event.data);
    this._ws.onclose =
        () =&gt; %controller.close();

    this._ws.addEventListener(`error^l, () =&gt; {
      %controller.error(new Error(`WebSocket に~errorが生じました^l));
    });
  }

  cancel() {
    this._ws.close();
  }
}

class WebSocketSink {
  constructor(%ws) {
    this._ws = %ws;
  }

  start(%controller) {
    this._ws.onclose = () =&gt; {
      %controller.error(new Error(`接続は不意に~serverにより~closeされました^l));
    }
    this._ws.addEventListener(`error^l, () =&gt; {
      %controller.error(new Error(`WebSocket に~errorが生じました^l));
      this._ws.onclose = null;
    });

    return new Promise(%resolve =&gt; this._ws.onopen = %resolve);
  }

  write(%chunk) {
    this._ws.send(%chunk);
  }

  close() {
    return this._closeWS(1000);
  }

  abort(%reason) {
    return this._closeWS(4000, %reason &amp;&amp; %reason.message);
  }

  _closeWS(%code, %reasonString) {
    return new Promise((%resolve, %reject) =&gt; {
      this._ws.onclose = %e =&gt; {
        if (%e.wasClean) {
          %resolve();
        } else {
          %reject(new Error(`接続は~cleanに~closeされませんでした^l));
        }
      };
      this._ws.close(%code, %reasonString);
    });
  }
}
</pre>

<p>
この関数で作成された~objを利用すれば、標準~stream~APIを利用して，遠隔の~web~socketと通信できるようになる：
◎
We can then use the objects created by this function to communicate with a remote web socket, using the standard stream APIs:
</p>

<pre class="lang-js">
const %streamyWS =
    streamifyWebSocket(`wss://example.com:443/^l, `protocol^l);
const %writer = %streamyWS.writable.getWriter();
const %reader = %streamyWS.readable.getReader();

%writer.write(`どうも、^l);
%writer.write(`web socket さん。^l);

%reader.read().then(({ %value, %done }) =&gt; {
  console.log(`こちらこそ、どうもです：^l, %value);
});
</pre>

<!-- 
"Hello"
"web socket"
"The web socket says: "
-->

<p>
このように設定しておけば、［
`readable^m 側を取消すと，暗黙的に `writable^m 側が~closeされ
］，同様に［
`writable^m 側を~closeする／中止すると，暗黙的に `readable^m 側が~closeされる
］ようになることに注意。
◎
Note how in this setup canceling the readable side will implicitly close the writable side, and similarly, closing or aborting the writable side will implicitly close the readable side.
</p>

<p class="note">注記：
この~styleで~web~socketを~streamの中に包装することについては、
<a href="#note-web-socket-wrapping-examples">前述の注記</a>
を見よ。
◎
See the earlier note about this style of wrapping web sockets into streams.
</p>

		</section>
		<section id="example-ts-lipfuzz">
<h3 title="A transform stream that replaces template tags">9.9. ~template内の~tagを置換する形式変換~stream</h3>

<p>
~dataが成す~stream上の~tagたちを変数に置換sすることが有用になることは多い
— 置換される必要がある部品たちが、総~data~sizeに比較して小さい所では。
この例は、それを行う単純な仕方を呈示する。
それは、文字列を文字列に対応付ける
— 例えば，
`Time: {{time}} Message: {{message}}^l
の様な~templateを
`Time: 15:36 Message: hello^l
の様に形式変換して（
`LipFuzzTransformer^I には、
%substitutions ~parameter内に
<code>{ time: `15:36^l, message: `hello^l }</code>
が渡されたとする）。
◎
It’s often useful to substitute tags with variables on a stream of data, where the parts that need to be replaced are small compared to the overall data size. This example presents a simple way to do that. It maps strings to strings, transforming a template like "Time: {{time}} Message: {{message}}" to "Time: 15:36 Message: hello" assuming that { time: "15:36", message: "hello" } was passed in the substitutions parameter to LipFuzzTransformer.
</p>

<p>
この例は、［
さらに~dataが受信されるまで，~chunkを形式変換できないような、部分的な~data
］を包含する状況に~~対処する仕方もデモる。
この事例では、部分的な~template~tagは、~tagの終端が見出されるか，~streamの終端に達するまで， `partialChunk^c ~prop内に累積されることになる。
◎
This example also demonstrates one way to deal with a situation where a chunk contains partial data that cannot be transformed until more data is received. In this case, a partial template tag will be accumulated in the partialChunk property until either the end of the tag is found or the end of the stream is reached.
</p>

<pre class="lang-js">
class LipFuzzTransformer {
  constructor(%substitutions) {
    this.substitutions = %substitutions;
    this.partialChunk = "";
    this.lastIndex = undefined;
  }

  transform(%chunk, %controller) {
    %chunk = this.partialChunk + %chunk;
    this.partialChunk = "";
    /* <span class="comment">
`lastIndex^c は、最後の置換s後の，最初の文字の~index
◎
lastIndex is the index of the first character after the last substitution.
</span> */
    this.lastIndex = 0;
    %chunk = %chunk.replace(/\{\{([a-zA-Z0-9_-]+)\}\}/g, this.replaceTag.bind(this));
    /* <span class="comment">
文字列の終端にある不完全な~template用の正規表現
◎
Regular expression for an incomplete template at the end of a string.
</span> */
    const %partialAtEndRegexp = /\{(\{([a-zA-Z0-9_-]+(\})?)?)?$/g;
    /* <span class="comment">
すでに置換sされた文字は見ないようにする
◎
Avoid looking at any characters that have already been substituted.
</span> */
    %partialAtEndRegexp.lastIndex = this.lastIndex;
    this.lastIndex = undefined;
    const %match = partialAtEndRegexp.exec(%chunk);
    if (%match) {
      this.partialChunk = %chunk.substring(%match.index);
      %chunk = %chunk.substring(0, %match.index);
    }
    %controller.enqueue(%chunk);
  }

  flush(%controller) {
    if (this.partialChunk.length &gt; 0) {
      %controller.enqueue(this.partialChunk);
    }
  }

  replaceTag(%match, %p1, %offset) {
    let %replacement = this.substitutions[%p1];
    if (%replacement === undefined) {
      %replacement = "";
    }
    this.lastIndex = %offset + %replacement.length;
    return %replacement;
  }
}
</pre>

<p>
この事例では、~classとして `TransformStream$I 構築子に渡される，`形式変換器$を定義する。
これは、追跡する~instance~dataがあるときに，有用になる。
◎
In this case we define the transformer to be passed to the TransformStream constructor as a class. This is useful when there is instance data to track.
</p>

<p>
この~classは、次の様な~codeに利用されることになる：
◎
The class would be used in code like:
</p>

<pre class="lang-js">
const %data = { %userName, %displayName, %icon, %date };
const %ts = new TransformStream(new LipFuzzTransformer(%data));

%fetchEvent.respondWith(
  fetch(%fetchEvent.request.url).then(%response => {
    const %transformedBody = %response.body
      /* <span class="comment">
~binaryに符号化された応答~本体を文字列に復号する
◎
Decode the binary-encoded response to string
</span> */
      .pipeThrough(new TextDecoderStream())
      /* <span class="comment">
%LipFuzzTransformer を適用する
◎
Apply the LipFuzzTransformer
</span> */
      .pipeThrough(%ts)
      /* <span class="comment">
形式変換された文字列を符号化する
◎
Encode the transformed string
</span> */
      .pipeThrough(new TextEncoderStream());
    return new Response(%transformedBody);
  })
);
</pre>

<p class="warning">
単純にするため、
`LipFuzzTransformer^I は，~text置換sに際し~escapeしていない。
現実の応用においては、文脈に応じて~escapeする~template~systemの方が，~securityや堅牢性に関して良実践になる。
◎
For simplicity, LipFuzzTransformer performs unescaped text substitutions. In real applications, a template system that performs context-aware escaping is good practice for security and robustness.
</p>

		</section>
		<section id="example-ts-sync-mapper">
<h3 title="A transform stream created from a sync mapper function">9.10. 同期c~mapper関数から作成される形式変換~stream</h3>

<p>
次の関数は、通常は `Array.prototype.map$c に渡すような型の同期的な “~mapper” 関数から，新たな `TransformStream$I ~instanceを作成-可能にする。
それは、自明な形式変換に対しても，~APIは簡潔になることをデモる。
◎
The following function allows creating new TransformStream instances from synchronous "mapper" functions, of the type you would normally pass to Array.prototype.map. It demonstrates that the API is concise even for trivial transforms.
</p>

<pre class="lang-js">
function mapperTransformStream(%mapperFunction) {
  return new TransformStream({
    transform(%chunk, %controller) {
      %controller.enqueue(mapperFunction(%chunk));
    }
  });
}
</pre>

<p>
この関数を利用すれば、すべての入力を大文字~化する `TransformStream$I を作成できる：
◎
This function can then be used to create a TransformStream that uppercases all its inputs:
</p>

<pre class="lang-js">
const %ts = mapperTransformStream(%chunk =&gt; %chunk.toUpperCase());
const %writer = %ts.writable.getWriter();
const %reader = %ts.readable.getReader();

writer.write(`No need to shout^l);

/* <span class="comment">
これは `NO NEED TO SHOUT^l を~logする：
◎
Logs "NO NEED TO SHOUT":
</span> */
reader.read().then(({ %value }) =&gt; console.log(%value));
</pre>

<p>
同期的な形式変換は、背圧~自体は決して生じさせず，背圧がないときに限り ~chunkたちを形式変換するので、資源が浪費されることはない。
◎
Although a synchronous transform never causes backpressure itself, it will only transform chunks as long as there is no backpressure, so resources will not be wasted.
</p>

<p>
例外が生じたときは、~streamを自然な仕方で~errorにする：
◎
Exceptions error the stream in a natural way:
</p>

<pre class="lang-js">
const %ts = mapperTransformStream(%chunk =&gt; JSON.parse(%chunk));
const %writer = %ts.writable.getWriter();
const %reader = %ts.readable.getReader();

writer.write(`[1, ^l);

/* <span class="comment">
`SyntaxError^jE を重ねて~logする：
◎
Logs a SyntaxError, twice:
</span> */
%reader.read().catch(%e =&gt; console.error(%e));
%writer.write(`{}^l).catch(%e =&gt; console.error(%e));
</pre>

		</section>
	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次に挙げる方々のみならず、この仕様に貢献された すべての方々に感謝する。
彼らなくしては、この仕様は成し得なかったであろう：
</p>

`_acks1@
	</section>
</main></div>

<div hidden>
<div lang="en-x-a0" id="_acks1">
<p>
The editors would like to thank

Anne van Kesteren,
AnthumChris,
Arthur Langereis,
Ben Kelly,
Bert Belder,
Brian di Palma,
Calvin Metcalf,
Dominic Tarr,
Ed Hager,
Forbes Lindesay,
Forrest Norvell,
Gary Blackwood,
Gorgi Kosev,
Gus Caplan,
<span lang="zh">贺师俊</span> (hax),
Isaac Schlueter,
isonmad,
Jake Archibald,
Jake Verbaten,
Janessa Det,
Jason Orendorff,
Jens Nockert,
Lennart Grahl,
Mangala Sadhu Sangeet Singh Khalsa,
Marcos Caceres,
Marvin Hagemeister,
Mattias Buelens,
Michael Mior,
Mihai Potra,
Romain Bellessort,
Simon Menke,
Stephen Sugden,
Surma,
Tab Atkins,
Tanguy Krotoff,
Thorsten Lorenz,
Till Schneidereit,
Tim Caswell,
Trevor Norris,
tzik,
Will Chan,
Youenn Fablet,
<span lang="ja">平野裕</span> (Yutaka Hirano),
and Xabier Rodríguez

for their contributions to this specification. Community involvement in this specification has been above and beyond; we couldn’t have done it without you.
</p>

<p>
This standard is written by Adam Rice (<a href="https://google.com">Google</a>, <a href="mailto:ricea@chromium.org">ricea@chromium.org</a>), <a href="https://domenic.me/">Domenic Denicola</a> (<a href="https://google.com">Google</a>, <a href="mailto:d@domenic.me">d@domenic.me</a>), and 
<span lang="ja">吉野剛史</span> (Takeshi Yoshino, <a href="https://google.com">Google</a>, <a href="mailto:tyoshino@chromium.org">tyoshino@chromium.org</a>).
</p>

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

</div>
</div>
