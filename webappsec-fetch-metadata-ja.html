<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Fetch Metadata Request Headers（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>
samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

pre.http-code {
	background: #EEE;
}
pre.html-code {
	background: #FFE;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	return `"<code class="literal">${key}</code>"`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Fetch Metadata Request Headers
spec_date:2019-06-27
trans_update:2019-07-06
	source_checked:
page_state_key:WEBAPPSEC
	original_url:https://w3c.github.io/webappsec-fetch-metadata/
original_url:https://www.w3.org/TR/fetch-metadata/
spec_status:WD
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2019,use
trans_1st_pub:2019-07-06


●●class_map
P:production
h:header
e:element
a:attr

●●tag_map
P:code
h:code
e:code
a:code
c:code
s:samp
i:i
em:em

●●words_table


	●network
CDN:
CSRF:
Fetch:
HPACK:
http:

Service-Worker:Service Worker
Sec-Fetch-Dest:
Sec-Fetch-Mode:
Sec-Fetch-Site:
Sec-Fetch-Site:
Sec-Fetch-User:

端点:endpoint::~
intranet::::イントラネット
main:
連鎖:chain::~
redirect::::リダイレクト
registry::::レジストリ
外向けの:outgoing:~
層:layer:::~:レイヤ
発行-:make:~
backend::::バックエンド

	●保安
計時:timing::~
受動的:passive::~
銀行:bank:~
計測:measurement:~
露呈-:reveal:露わに
偽造-:forge::~
特権:privilege::~
	利用者が有する特権:privileged position
仕向ける:convinceする:~
仕向けら:convinceさ:~
	^en:ambient

	●UI
打込んだ:typeした:打ち込んだ
開かれ:openされ:~
開く:openする:~
bookmark::::ブックマーク
copy::::コピー
paste::::ペースト
tab::::タブ
bar::::バー
menu::::メニュー
drag::::ドラッグ
drag-and-drop::::ドラッグ＆ドロップ
window::::ウインドウ

	Ctrl-click

	●仕様
アタられ:consultされ:あたられ
先天的:a priori:~
関心事:interesting:~
	関心事になる:interested in
賢い:intelligentな:~
助け:helpful:~
正当:legitimate:~
目指す:aimする:~
濫用:abuse:~
	アリでない:impossible
事前条件:precondition:~
素早く:quickに:~
適理:reasonable:~
拡げる:expandする:~
単直:straightforward:簡単
賛同-:agree:~
理想的:ideal:~
恒久的:permanent:~
結論:conclusion:~
拙く:poorに:~
句:phrase:~
探索:search:検索
主旨:argument:~
ナゾれる:traceできる:辿れる
一式:suite:~
位置付け:status:~
担当した:responsibleな:~
論題:topic:~
優れた:excellentな:~
揃えた:alignした:~
分類:category:~
実用的:practical:~
働n:work:働き
確信:confidence:~
IANA:
変更管理者:change controller:~

	はず:should
	まずあり得ない:pretty unlikely
	考えにくい:unlikely that 〜 
	まったくもって:whatsoever
	面したとき:in the face of
	まだ未知な:as-yet-unknown
	さしあたり:for the moment
	相互運用可能に:interoperably
	予期されない:unexpected
	なり得る:potentially
	~web的:webby
	確かめて:ascertain
	~~過去の:earlier
	生じた:caused
	利する:behalf
	判明して:turns out
	されたし:please
	少しは:bit more
	在る下では:presence
	~~引用:pull
	~~明文化:spell-out
	関し:around
	および:as well as
	難しい:hard
	切り替えた／切り替わる:shift
	該当する:fall into
	何らかの~~形で:somehow
	~~相当な:substantial
	~~版:iteration
	-:interesting
	~web~page上での:web-facing
	~~価する:worth
	~~先送り:punting
	編集者:me
	非常に:very
	感謝-:thank
	-:we
	はず:should
	とする:demarcate
	見込まれる／であろう:likely
	教わる:taught
	ベキ:should
	-:follow
	-:end up


	●未分類
自動化-:automate:~
圧縮:compression:~
広告-:advertise:~
接頭-:prefix::~
預金全部:all my money:~
肥大化:bloat:~
monkey-patch:monkey patch

持上げる:lift upする:持ち上げる
	戻る:back
	`同じ~site$でない:cross-site
	`同じ~site$:same-site
	巡り巡って~~元の:all the way back to
	一巡-:walk

	●言い換え
	利用者が起動した:user-initiated
	~webに公開される:web-exposed
	~server側:server-side
	改変-不能:unmodifiable
	同じ~site:~same-site
	非同一-~site:~cross-site
	登録-可能:registrable
	信用に価し得る:potentially trustworthy
	~redirect:redirection
	~web~site:website
	妥当でない:invalid


	●指示語
	その他:others
	一連の:set of
	多数の:a large number of
	別個の:distinct
	離れて:away
	この種の:this kind of
	逆:reverse
	一連の:set of
	-:entirely
	最終:final

●●original_id_map
biblio-i-d.ietf-httpbis-header-structure:biblio-i-dietf-httpbis-header-structure

●●words_table1
HEADER-STRUCTURE:https://tools.ietf.org/html/draft-ietf-httpbis-header-structure

●●link_map

h.Sec-Fetch-Dest:#http-headerdef-sec-fetch-dest
h.Sec-Fetch-Mode:#http-headerdef-sec-fetch-mode
h.Sec-Fetch-Site:#http-headerdef-sec-fetch-site
h.Sec-Fetch-User:#http-headerdef-sec-fetch-user

e.img:e.img:~HEimages#the-img-element
e.picture:~HEimages#the-picture-element
e.iframe:~HEembed#the-iframe-element

c.window.location:~HISTORY#dom-window-location
c.fetch():~FETCH#dom-global-fetch
c.new Worker():~WORKERS#dom-worker

	r.I-D.ietf-httpbis-header-structure:#biblio-i-dietf-httpbis-header-structure

~fetch~metadata~header:#fetch-metadata-headers
要請~用に~fetch~metadata~headerを設定する:#abstract-opdef-set-the-fetch-metadata-headers-for-a-request
~Sec-Fetch-Dest~headerを設定する:#abstract-opdef-set-dest
~Sec-Fetch-Mode~headerを設定する:#abstract-opdef-set-mode
~Sec-Fetch-Site~headerを設定する:#abstract-opdef-set-site
~Sec-Fetch-User~headerを設定する:#abstract-opdef-set-user
利用者~作動化~flag:#request-user-activation-flag


有構造~header:~HEADER-STRUCTURE#
hs.~token:~HEADER-STRUCTURE#section-3.9
hs.真偽値:~HEADER-STRUCTURE#section-3.11
hs.直列化-:~HEADER-STRUCTURE#section-4.1
hs.辞書:~HEADER-STRUCTURE#section-3.1


同じ~site:~URL1#host-same-site
登録-可能な~domain:~URL1#host-registrable-domain
url.生成元:~URL1#concept-url-origin

~headerを設定する:~FETCH#concept-header-list-set
禁止~header名:~FETCH#forbidden-header-name
~main~fetch:~FETCH#concept-main-fetch
~navi要請:~FETCH#navigation-request
要請:~FETCH#concept-request
rq.~header~list:~FETCH#concept-request-header-list
rq.~mode:~FETCH#concept-request-mode
rq.生成元:~FETCH#concept-request-origin
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.~URL:~FETCH#concept-request-url
rq.~URL~list:~FETCH#concept-request-url-list
rq.行先:~FETCH#concept-request-destination
rq.現在の~URL:~FETCH#concept-request-current-url


環境:~WAPI#environment
入子の閲覧文脈:~BROWSERS#nested-browsing-context
同一-生成元:~ORIGIN#same-origin
~navigate~fetchを処理する:~NAVI#process-a-navigate-fetch
	:~NAVI#navigating-across-documents
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
利用者の作動化により誘発され:~HTMLinteraction#triggered-by-user-activation


信用に価し得る~URL:~SECURE-CONTEXT#potentially-trustworthy-url


	https://github.com/mikewest/sec-metadata/issues/16:https://github.com/mikewest/sec-metadata/issues/16
	https://github.com/whatwg/fetch/issues/885:https://github.com/whatwg/fetch/issues/885


	r.I-D.ietf-httpbis-header-structure:#biblio-i-dietf-httpbis-header-structure

	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue

	w3ctag/design-reviews#280:https://github.com/w3ctag/design-reviews/issues/280
	whatwg/fetch#755:https://github.com/whatwg/fetch/issues/755

	§:#sec-fetch-dest-header
	§:#sec-fetch-mode-header
	§:#sec-fetch-site-header
	§:#sec-fetch-user-header
	§:#fetch-integration
	§:#directly-user-initiated

●●ref_normative

[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[I-D.ietf-httpbis-header-structure]
    Mark Nottingham; Poul-Henning Kamp. Structured Headers for HTTP. ID. URL: https://tools.ietf.org/html/draft-ietf-httpbis-header-structure 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC3864]
    G. Klyne; M. Nottingham; J. Mogul. Registration Procedures for Message Header Fields. September 2004. Best Current Practice. URL: https://tools.ietf.org/html/rfc3864 
[SECURE-CONTEXTS]
    Mike West. Secure Contexts. 15 September 2016. CR. URL: https://www.w3.org/TR/secure-contexts/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 

●●ref_informative

[MNOT-DESIGNING-HEADERS]
    Mark Nottingham. Designing Headers for HTTP Compression. URL: https://www.mnot.net/blog/2018/11/27/header_compression 
[RFC7231]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより初公開 作業草案として公開された
<a href="~SPEC_URL">Fetch Metadata Request Headers</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

このバージョン
	https://www.w3.org/TR/2019/WD-fetch-metadata-20190627/
最新発行バージョン
	https://www.w3.org/TR/fetch-metadata/
編集者草案
	https://w3c.github.io/webappsec-fetch-metadata/
	https://github.com/w3c/webappsec-fetch-metadata/
バージョン履歴
	https://github.com/w3c/webappsec-fetch-metadata/commits/master/index.bs 

フィードバック
	<a href="mailto:public-webappsec@w3.org?subject=%5Bfetch-metadata%5D%20YOUR%20TOPIC%20HERE">public-webappsec@w3.org</a> with subject line “<kbd>[fetch-metadata] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webappsec/" rel="discussion">archives</a>)
Issue Tracking:
	<a href="https://github.com/w3c/webappsec-fetch-metadata/issues/">GitHub</a>
編集
	<a href="mailto:mkwst@google.com">Mike West</a> (Google Inc.) 
Explainer
	https://github.com/w3c/webappsec-fetch-metadata 
Participate
	<a href="https://github.com/w3c/webappsec-fetch-metadata/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-fetch-metadata/issues">open issues</a>)
Tests
	<a href="https://github.com/web-platform-tests/wpt/tree/master/fetch/sec-metadata">web-platform-tests fetch/sec-metadata/</a>
発行者
	<a href="https://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>

</script>
<!-- 
mailto:public-webappsec@w3.org?Subject=%5Bfetch-metadata%5D%20PUT%20SUBJECT%20HERE"
-->

</head>
<body>

<header>
	<hgroup>
<h1>Fetch Metadata Request Headers</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">

~ABSTRACT

<p>
この文書は、一連の~fetch~metadata要請~headerを定義する。
それは、［
要請に対し，［
それが発行された仕方,
それが利用されることになる文脈
］に基づいて~serviceするかどうか
］について，先天的に裁定を下すために十分な情報を~serverに供することを目指す。
◎
This document defines a set of Fetch metadata request headers that aim to provide servers with enough information to make a priori decisions about whether or not to service a request based on the way it was made, and the context in which it will be used.
</p>

	</section>
	<section id="status">
~STATUSofTHIS

<p>
この節では、発行時点における…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>／冒頭の仕様~metadataに委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
【！Interesting】
~web~appは、一般に，~webに公開される多数の端点
— ［
利用者についての敏感な~dataを露呈する／
利用者に利する動作をとる
］かもしれない端点 —
を伴うことになる。
利用者の~browserは，［
それらの端点への要請を発行するよう，容易に仕向けられ得ることに加え，利用者の `ambient^en な【当の環境に暗黙に備わる】資格証（ ~cookie, ~intranet内で利用者が有する特権, 等々）を含む
］ので、濫用を避けるためには，~appは［
それらの端点が働く仕方について，非常に注意深くある
］必要がある。
◎
Interesting web applications generally end up with a large number of web-exposed endpoints that might reveal sensitive data about a user, or take action on a user’s behalf. Since users' browsers can be easily convinced to make requests to those endpoints, and to include the users' ambient credentials (cookies, privileged position on an intranet, etc), applications need to be very careful about the way those endpoints work in order to avoid abuse.
</p>

<p>
注意深くあることは、［
一部の事例（“単純な” ~CSRF）においては難しく、その他の事例（非同一-~site探索, 計時~攻撃, 等々）においては，実用的にはアリでない
］ものと判明している。
後者の分類には、ある種の応答を生成するために必要とされる~server側~処理と長さの計測に基づく計時~攻撃が含まれる（~web~page上での計時~攻撃を介するものも，受動的な~network攻撃者も含まれる）。
◎
Being careful turns out to be hard in some cases ("simple" CSRF), and practically impossible in others (cross-site search, timing attacks, etc). The latter category includes timing attacks based on the server-side processing necessary to generate certain responses, and length measurements (both via web-facing timing attacks and passive network attackers).
</p>

<p>
後者の分類を軽減するため、~serverが，所与の要請に応答するかどうかについて［
要請が発行された仕方に基づいて，もっと賢い裁定を下せる
］ならば、助けになるであろう。
例えば，ある銀行の~server上の “預金全部を転送する” 端点が `img$e ~tagから参照されることを期待することは、まずあり得ないと見受けられる。
同様に
`evil.com^s
が正当な要請を発行してくるとはまったくもって考えにくい。
~serverがこれらの要請を
— ~app~backendへ送達することなく —
先天的に却下できれば理想的である。
◎
It would be helpful if servers could make more intelligent decisions about whether or not to respond to a given request based on the way that it’s made in order to mitigate the latter category. For example, it seems pretty unlikely that a "Transfer all my money" endpoint on a bank’s server would expect to be referenced from an img tag, and likewise unlikely that evil.com is going to be making any legitimate requests whatsoever. Ideally, the server could reject these requests a priori rather than delivering them to the application backend.
</p>

<p>
ここでは、［
~UAが，外向けの要請に追加的な文脈を追加することにより、~serverがこの種の裁定を下すことを可能化する
］ための仕組みを述べる。
それは、［
~serverへ，一連の`~fetch~metadata~header$内に~metadataを伴わせて送達する
］ことにより，［
~appが，一連の事前条件を~testした結果に基づいて要請を素早く却下する
］ことを可能化する。
その働nは、欲されるなら，~app層の上（逆~proxy, ~CDN, 等々）に持上げることさえできる。
◎
Here, we describe a mechanims by which user agents can enable this kind of decision-making by adding additional context to outgoing requests. By delivering metadata to a server in a set of fetch metadata headers, we enable applications to quickly reject requests based on testing a set of preconditions. That work can even be lifted up above the application layer (to reverse proxies, CDNs, etc) if desired.
</p>

		<section id="examples">
<h3 title="Examples">1.1. 例</h3>

<p>
`picture$e 要素により生成された要請は、次の~HTTP要請~headerを包含することになる：
◎
A request generated by a picture element would result in a request containing the following HTTP request headers:
</p>

<pre class="http-code">
Sec-Fetch-Dest: image
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: cross-site
</pre>

<p>
~page内の~linkを利用者が~clickして生じた
`https://example.com^s
から
`https://example.com/^s
への
~top-level~naviによる結果の要請は、次の~HTTP要請~headerを包含することになる：
◎
A top-level navigation from https://example.com to https://example.com/ caused by a user’s click on an in-page link would result in a request containing the following HTTP request header:
</p>

<pre class="http-code">
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
</pre>

		</section>
	</section>
	<section id="framework">
<h2 title="Fetch Metadata Headers">2. ~fetch~metadata~header</h2>

<p>
以下の各~節では、各種
`~fetch~metadata~header@
を定義する。
それぞれ、~serverにとって関心事になる`要請$ 属性を公開する。
◎
The following sections define several fetch metadata headers, each of which exposes an interesting request attribute to a server.
</p>

		<section id="sec-fetch-dest-header">
<h3 title="The Sec-Fetch-Dest HTTP Request Header">2.1. `Sec-Fetch-Dest^h ~HTTP要請~header</h3>

<p class="issue">
この~headerが供することになる値には、懸念がある
— 特に，~Service-Workerによる~cache済み応答を予期されない仕方で利用する能に面したとき。
それは、将来~~版へ~~先送りするに~~価するかもしれない。
<a href="https://github.com/mikewest/sec-metadata/issues/16">https://github.com/mikewest/sec-metadata/issues/16</a>
◎
There are some concerns about the value this header would provide, particularly in the face of a Service Worker’s ability to use cached responses in unexpected ways. It might be worth punting it to a future iteration. &lt;https://github.com/mikewest/sec-metadata/issues/16&gt;
</p>

<p>
`Sec-Fetch-Dest@h
~HTTP要請~headerは、`要請$の`行先$rqを~serverに公開する。
それは、`~token$hsを値とする`有構造~header$
`I-D.ietf-httpbis-header-structure$r
でなければナラナイ。
その~ABNFは：
◎
The Sec-Fetch-Dest HTTP request header exposes a request's destination to a server. It is a Structured Header whose value MUST be a token. [I-D.ietf-httpbis-header-structure] Its ABNF is:
</p>

<pre class="ABNF">
Sec-Fetch-Dest = sh-token
</pre>

<p>
次に挙げるものが、妥当な `Sec-Fetch-Dest^h 値になる
⇒＃
`audio^l,
`audioworklet^l,
`document^l,
`embed^l,
`empty^l,
`font^l,
`image^l,
`manifest^l,
`object^l,
`paintworklet^l,
`report^l,
`script^l,
`serviceworker^l,
`sharedworker^l,
`style^l,
`track^l,
`video^l,
`worker^l,
`xslt^l,
`nested-document^l
◎
Valid Sec-Fetch-Dest values include "audio", "audioworklet", "document", "embed", "empty", "font", "image", "manifest", "object", "paintworklet", "report", "script", "serviceworker", "sharedworker", "style", "track", "video", "worker", "xslt", and "nested-document".
</p>

<p>
まだ未知な要請~種別との前方-互換性を~supportするため、~serverは，妥当でない値を包含する場合には この~headerを無視するベキである。
◎
In order to support forward-compatibility with as-yet-unknown request types, servers SHOULD ignore this header if it contains an invalid value.
</p>

<div class="example">
<ul>
	<li>
`fetch()$c の行先は空~文字列になる【 `empty^l に対応する（下記）】
⇒
`Sec-Fetch-Dest: empty^s
◎
// fetch()'s destination is the empty string:
Sec-Fetch-Dest: empty
</li>
	<li>
`img$e の行先は `image^l になる
⇒
`Sec-Fetch-Dest: image^s
◎
// &lt;img&gt;'s destination is "image"
Sec-Fetch-Dest: image
</li>
	<li>
`new Worker()$c の行先は `worker^l になる
⇒
`Sec-Fetch-Dest: worker^s
◎
// new Worker()'s destination is "worker"
Sec-Fetch-Dest: worker
</li>
	<li>
~top-level~naviの行先は `document^l になる
⇒
`Sec-Fetch-Dest: document^s
◎
// Top-level navigations' destinations are "document"
Sec-Fetch-Dest: document
</li>
	<li>
`iframe$e による~naviの行先は `document^l になる
⇒
`Sec-Fetch-Dest: document^s
◎
// &lt;iframe&gt; navigations' destinations are "document"
Sec-Fetch-Dest: document
</li>
</ul>

</div>


<div class="algorithm">

<p>
`~Sec-Fetch-Dest~headerを設定する@
ときは、所与の
( `要請$ %要請 )
に対し：
◎
To set the Sec-Fetch-Dest header for a request r:
</p>

<ol>
	<li>
~Assert：
%要請 の`~URL$rqは`信用に価し得る~URL$である。
◎
Assert: r’s url is a potentially trustworthy URL.
</li>
	<li>
%~header ~LET `~token$hsを値とする`有構造~header$
◎
Let header be a Structured Header whose value is a token.
</li>
	<li>
<p>
%~header の値 ~SET ［
%要請 の`行先$rq ~EQ 空~文字列ならば `empty^l ／
~ELSE_ %要請 の`行先$rq
］
◎
If r’s destination is the empty string, set header’s value to the string "empty". Otherwise, set header’s value to r’s destination.
</p>

<p class="note">注記：
処理を単純~化するため、~Fetchの`行先$rqに対する空~文字列は，`~token$hs `empty^l に明示的に対応付ける。
◎
Note: We map Fetch’s empty string destination onto an explicit "empty" token in order to simplify processing.
</p>
	</li>
	<li>
%値 ~LET %~header を`直列化-$hsした結果
◎
Let value be the result of serializing header.
</li>
	<li>
%要請 の`~header~list$rq内で`~headerを設定する$( `Sec-Fetch-Dest$h / %値 )
◎
Set `Sec-Fetch-Dest`/value in r’s header list.
</li>
</ol>
</div>

		</section>
		<section id="sec-fetch-mode-header">
<h3 title="The Sec-Fetch-Mode HTTP Request Header">2.2. `Sec-Fetch-Mode^h ~HTTP要請~header</h3>

<p>
`Sec-Fetch-Mode@h
~HTTP要請~headerは、`要請$の`~mode$rqを~serverに公開する。
それは、`~token$hsを値とする`有構造~header$
`I-D.ietf-httpbis-header-structure$r
である。
その~ABNFは：
◎
The Sec-Fetch-Mode HTTP request header exposes a request's mode to a server. It is a Structured Header whose value is a token. [I-D.ietf-httpbis-header-structure] Its ABNF is:
</p>

<pre class="ABNF">
Sec-Fetch-Mode = sh-token
</pre>

<p>
次に挙げるものが、妥当な `Sec-Fetch-Mode^h 値になる
⇒＃
`cors^l,
`navigate^l,
`nested-navigate^l,
`no-cors^l,
`same-origin^l,
`websocket^l
◎
Valid Sec-Fetch-Mode values include "cors", "navigate", "nested-navigate", "no-cors", "same-origin", and "websocket".＼
</p>

<p>
まだ未知な要請~種別との前方-互換性を~supportするため、~serverは，妥当でない値を包含する場合には この~headerを無視するベキである。
◎
In order to support forward-compatibility with as-yet-unknown request types, servers SHOULD ignore this header if it contains an invalid value.
</p>

<div class="algorithm">

<p>
`~Sec-Fetch-Mode~headerを設定する@
ときは、所与の
( `要請$ %要請 )
に対し：
◎
To set the Sec-Fetch-Mode header for a request r:
</p>

<ol>
	<li>
~Assert：
%要請 の`~URL$rqは`信用に価し得る~URL$である。
◎
Assert: r’s url is a potentially trustworthy URL.
</li>
	<li>
%~header ~LET `~token$hsを値とする`有構造~header$
◎
Let header be a Structured Header whose value is a token.
</li>
	<li>
%~header の値 ~SET %要請 の`~mode$rq
◎
Set header’s value to r’s mode.
</li>
	<li>
<p>
~IF［
%~header の値 ~EQ `navigate^l
］~AND［［
%要請 の`予約-済み~client$rq ~EQ ~NULL
］~OR［
%要請 の`予約-済み~client$rqは`環境$であって，その`~target閲覧文脈$enVは`入子の閲覧文脈$である
］
］］
⇒
%~header の値 ~SET `nested-navigate^l
◎
If header’s value is "navigate", and r’s reserved client is either null or an environment whose target browsing context is a nested browsing context, set header’s to "nested-navigate".
</p>

<p class="note">注記：
この作業を行なっているわけは、
~Fetchは現時点では `nested-navigate^l を定義していないので。
<a href="#fetch-integration">§ ~Fetch, ~HTMLとの統合</a>
を見よ。
◎
NOTE: We’re doing this work because Fetch does not currently define nested-navigate. See §3 Integration with Fetch and HTML.
</p></li>
	<li>
%値 ~LET %~header を`直列化-$hsした結果
◎
Let value be the result of serializing header.
</li>
	<li>
%要請 の`~header~list$rq内で`~headerを設定する$( `Sec-Fetch-Mode$h / %値 )
◎
Set `Sec-Fetch-Mode`/value in r’s header list.
</li>
</ol>
</div>

		</section>
		<section id="sec-fetch-site-header">
<h3 title="The Sec-Fetch-Site HTTP Request Header">2.3. `Sec-Fetch-Site^h ~HTTP要請~header</h3>

<p>
`Sec-Fetch-Site@h
~HTTP要請~headerは、［
`要請$の起動元の生成元,
`要請$の~targetの生成元
］の関係性を公開する。
それは、`~token$hsを値とする`有構造~header$
`I-D.ietf-httpbis-header-structure$r
である。
その~ABNFは：
◎
The Sec-Fetch-Site HTTP request header exposes the relationship between a request initiator’s origin and its target’s origin. It is a Structured Header whose value is a token. [I-D.ietf-httpbis-header-structure] Its ABNF is:
</p>

<pre class="ABNF">
Sec-Fetch-Site = sh-token
</pre>

<p>
次に挙げるものが、妥当な `Sec-Fetch-Site^h 値になる
⇒＃
`cross-site^l,
`same-origin^l,
`same-site^l,
`none^l
◎
Valid Sec-Fetch-Site values include "cross-site", "same-origin", "same-site", and "none".＼
</p>

<p>
まだ未知な要請~種別との前方-互換性を~supportするため、~serverは，妥当でない値を包含する場合には この~headerを無視するベキである。
◎
In order to support forward-compatibility with as-yet-unknown request types, servers SHOULD ignore this header if it contains an invalid value.
</p>

<div class="algorithm">

<p>
`~Sec-Fetch-Site~headerを設定する@
ときは、所与の
( `要請$ %要請 )
に対し：
◎
To set the Sec-Fetch-Site header for a request r:
</p>

<ol>
	<li>
~Assert：
%要請 の`~URL$rqは`信用に価し得る~URL$である。
◎
Assert: r’s url is a potentially trustworthy URL.
</li>
	<li>
%~header ~LET `~token$hsを値とする`有構造~header$
◎
Let header be a Structured Header whose value is a token.
</li>
	<li>
%~header の値 ~SET `same-origin^l
◎
Set header’s value to same-origin.
</li>
	<li>
<p>
~IF［
%要請 は`~navi要請$であって、利用者が~UAと明示的にヤリトリして生じた（例：直に~addressを打込んだ, ~bookmarkを~clickした, 等々）
］
⇒
%~header の値 ~SET `none^l
◎
If r is a navigation request that was explicitly caused by a user’s interaction with the user agent (by typing an address into the user agent directly, for example, or by clicking a bookmark, etc.), then set header’s value to none.
</p>

<p class="note">注記：
いくぶん拙く定義された この段についての詳細は
<a href="#directly-user-initiated">§ 利用者が直に起動した要請</a>
を見よ。
◎
Note: See §4.3 Directly User-Initiated Requests for more detail on this somewhat poorly-defined step.
</p>
	</li>
	<li>
<p>
~IF［
%~header の値 ~NEQ `none^l
］
⇒
%要請 の`~URL~list$rq内の
~EACH( %~url )
に対し：
◎
If header’s value is not none, then for each url in r’s url list:
</p>
		<ol>
			<li>
~IF［
( %~url 【の`生成元$url】, %要請 の`生成元$rq )
は`同一-生成元$である
］
⇒
~CONTINUE
◎
If url is same origin with r’s origin, continue.
</li>
			<li>
~IF［
%要請 の`生成元$rqの`登録-可能な~domain$ ~NEQ %~url の`登録-可能な~domain$
］
⇒＃
%~header の値 ~SET `cross-site^l；
~BREAK
◎
If r’s origin's registrable domain is not the same as url’s registrable domain, set header’s value to cross-site and break.
</li>
			<li>
%~header の値 ~SET `same-site^l
◎
Set header’s value to same-site.
</li>
		</ol>
	</li>
	<li>
%値 ~LET %~header を`直列化-$hsした結果
◎
Let value be the result of serializing header.
</li>
	<li>
%要請 の`~header~list$rq内で`~headerを設定する$( `Sec-Fetch-Site$h / %値 )
◎
Set `Sec-Fetch-Site`/value in r’s header list.
</li>
</ol>
</div>

		</section>
		<section id="sec-fetch-user-header">
<h3 title="The Sec-Fetch-User HTTP Request Header">2.4. `Sec-Fetch-User^h ~HTTP要請~header</h3>

<p>
`Sec-Fetch-User@h
~HTTP要請~headerは、
`~navi要請$は`利用者の作動化により誘発され$たかどうかを公開する。
それは、`真偽値$hsを値とする`有構造~header$
`I-D.ietf-httpbis-header-structure$r
である。
その~ABNFは：
◎
The Sec-Fetch-User HTTP request header exposes whether or not a navigation request was triggered by user activation. It is a Structured Header whose value is a boolean. [I-D.ietf-httpbis-header-structure] Its ABNF is:
</p>

<pre class="ABNF">
Sec-Fetch-User = sh-boolean
</pre>

<p class="note">注記：
この~headerは、`~navi要請$用に限り，その値が真【 `?1^l 】のときに限り送達される。
将来においては、この~headerの視野を，下位資源~要請も一般に含むよう拡げることも適理かもしれない
— その情報を公開することにより改善されるような一部の利用-事例を~~明文化できれば（かつ，関心事になる すべての下位資源~要請~種別~用に状態sを定義する仕方について賛同されれば）—
が、さしあたり，~navi要請には明瞭な利用-事例があり、相互運用可能に定義するのは，単直と見受けられる。
◎
Note: The header is delivered only for navigation requests, and only when its value is true. It might be reasonable to expand the headers' scope in the future to include subresource requests generally if we can spell out some use cases that would be improved by exposing that information (and if we can agree on ways to define that status for all the subresource request types we’d be interested in), but for the moment, navigation requests have clear use cases, and seem straightforward to define interoperably.
</p>

<div class="algorithm">

<p>
`~Sec-Fetch-User~headerを設定する@
ときは、所与の
( `要請$ %要請 )
に対し：
◎
To set the Sec-Fetch-User header for a request r:
</p>
<ol>
	<li>
~Assert：
%要請 の`~URL$rqは`信用に価し得る~URL$である。
◎
Assert: r’s url is a potentially trustworthy URL.
</li>
	<li>
~IF［
%要請 は`~navi要請$でない
］~OR［
%要請 の`利用者~作動化~flag$ ~NEQ ~F
］
⇒
~RET
◎
If r is not a navigation request, or if r’s user activation flag is false, return.
</li>
	<li>
%~header ~LET `~token$hsを値とする`有構造~header$
◎
Let header be a Structured Header whose value is a token.
</li>
	<li>
<p>
%~header の値 ~SET  %要請 の`利用者~作動化~flag$
◎
Set header’s value to the value of r’s user activation flag.
</p>

<p class="issue">
この~flagは、ここ
<a href="#fetch-integration">§ ~Fetch, ~HTMLとの統合</a>
に定義される。
~monkey-patchするより，~Fetchへ移動できれば、理想的である。
<a href="https://github.com/whatwg/fetch/issues/885">https://github.com/whatwg/fetch/issues/885</a>
◎
This flag is defined here, in §3 Integration with Fetch and HTML. Ideally, we can move it to Fetch rather than monkey-patching. &lt;https://github.com/whatwg/fetch/issues/885&gt;
</p>
	</li>
	<li>
%値 ~LET %~header を`直列化-$hsした結果
◎
Let value be the result of serializing header.
</li>
	<li>
%要請 の`~header~list$rq内で`~headerを設定する$( `Sec-Fetch-User$h / %値 )
◎
Set `Sec-Fetch-User`/value in r’s header list.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="fetch-integration">
<h2 title="Integration with Fetch and HTML">3. ~Fetch, ~HTMLとの統合</h2>

<p>
`Sec-Fetch-User^h を~supportするためには、`要請$は，`利用者の作動化により誘発され$たかどうか教わる必要がある：
◎
To support Sec-Fetch-User, request needs to be taught about requests which were triggered by user activation:
</p>

<blockquote>

<p>
<strong>`FETCH$r に対する~monkey-patch：</strong>
◎
Monkeypatching [FETCH]:
</p>

<p>
各`要請$は、真偽値をとる
`利用者~作動化~flag@
を持つ。
他が言明されない限り， ~F をとるとする。
◎
A request has a boolean user activation flag. Unless stated otherwise, it is false.
</p>

<p class="note">注記：
この~flagは、`~navi要請$用に限り利用され、所与の~naviが`利用者の作動化により誘発され$たかどうかを反映する。
◎
Note: This is only used for navigation requests, and reflects whether a given navigation was triggered by user activation.
</p>
</blockquote>

<p>
この~flagは、~HTMLの`~navigate~fetchを処理する$ ~algoにて拡充することもできる
— たぶん，現在の その~algoの段 2 の後に次の段を挿入することにより：
◎
This flag could be populated from HTML’s process a navigate fetch algorithm, perhaps by inserting the following step after the current algorithm’s step 2:
</p>

<blockquote>

<p>
<strong>`HTML$r に対する~monkey-patch：</strong>
◎
Monkeypatching [HTML]:
</p>

<ol start="3">
	<li>
~IF［
この~algoは`利用者の作動化により誘発され$た
］
⇒
%要請 の`利用者~作動化~flag$ ~SET ~T
◎
If this algorithm was triggered by user activation, set request’s user activation flag to true.
</li>
</ol>

</blockquote>

<p>
また， `Sec-Fetch-Mode^h を~supportするため、
<a href="https://github.com/whatwg/fetch/issues/755">whatwg/fetch#755</a>
を解決して， `nested-navigate^l ~modeを追加するよう求まれる。
◎
We’ll also want to resolve whatwg/fetch#755 to add a "nested-navigate" mode to support Sec-Fetch-Mode.
</p>

<div class="algorithm">

<p>
`要請~用に~fetch~metadata~headerを設定する@
ときは、所与の
( `要請$ %要請 )
に対し：
◎
To set the Fetch metadata headers for a request, given request r:
</p>

<ol>
	<li>
~IF［
%要請 の`~URL$rqは`信用に価し得る~URL$でない
］
⇒
~RET
◎
If r’s url is not an potentially trustworthy URL, return.
</li>
	<li>
`~Sec-Fetch-Dest~headerを設定する$( %要請 )
◎
Set the Sec-Fetch-Dest header for r.
</li>
	<li>
`~Sec-Fetch-Mode~headerを設定する$( %要請 )
◎
Set the Sec-Fetch-Mode header for r.
</li>
	<li>
`~Sec-Fetch-Site~headerを設定する$( %要請 )
◎
Set the Sec-Fetch-Site header for r.
</li>
	<li>
`~Sec-Fetch-User~headerを設定する$( %要請 )
◎
Set the Sec-Fetch-User header for r.
</li>
</ol>
</div>

<p>
~fetchは、その`~main~fetch$~algoの中で上の~algoを~callすることになる。
統合の詳細~については、その仕様 `FETCH$r にアタられたし。
◎
Fetch will call into the algorithm above from within its main fetch algorithm. Please consult that specification for integration details [FETCH].
</p>

<p class="issue">
~monkey-patchを何とかする。
<a href="https://github.com/whatwg/fetch/issues/885">https://github.com/whatwg/fetch/issues/885</a>
◎
Monkey patching! &lt;https://github.com/whatwg/fetch/issues/885&gt;
</p>

	</section>
	<section id="sec-priv-considerations">
<h2 title="Security and Privacy Considerations">4. ~securityと~privacyの考慮点</h2>

		<section id="redirects">
<h3 title="Redirects">4.1. ~redirect</h3>

<p>
~UAは、~redirect連鎖を成す各~要請に伴って `Sec-Fetch-Site$h ~headerを送信することになる。
混同を軽減するため、この~headerの値は，［
非同一-生成元／非同一-~site
］への~redirectが在る下では，切り替わることになる。
◎
The user agent will send a Sec-Fetch-Site header along with each request in a redirect chain. The header’s value will shift in the presence of cross-origin or cross-site redirection in order to mitigate confusion.
</p>

<p>
`~Sec-Fetch-Site~headerを設定する$~algoは`要請$の`~URL~list$rq全体を一巡して
— 要請の`現在の~URL$rq %現~URL に対し：
◎
The algorithm to set the Sec-Fetch-Site header walks the request's entire url list, and will send＼
</p>

<ul>
	<li>
~list内のある~URLが %現~URL と非同一-~siteである【`同じ~site$でない】場合に限り，
`cross-site^l を送信することになる
◎
cross-site if any URL in the list is cross-site to the request’s current url,＼
</li>
	<li>
~list内のすべての~URLは %現~URL と`同じ~site$である場合に限り，
`same-site^l を送信することになる
◎
same-site only if all URLs in the list are same-site with the request’s current url, and＼
</li>
	<li>
~list内のすべての~URLは %現~URL と`同一-生成元$である場合に限り，
`same-origin^l を送信することになる
◎
same-origin only if all URLs in the list are same-origin with the request’s current url.
</li>
</ul>

<div class="example">
<p>
例えば
`https://example.com/^s
が
`https://example.com/redirect^s
を要請したとする：
◎
For example, if https://example.com/ requests https://example.com/redirect,＼
</p>

<ol>
	<li>
初期~要請の `Sec-Fetch-Site^h 値は
`same-origin^l になる。
◎
the initial request’s Sec-Fetch-Site value would be same-origin.＼
</li>
	<li>
前段の応答が
`https://subdomain.example.com/redirect^s
へ~redirectされた場合、対する要請の `Sec-Fetch-Site^h 値は `same-site^l になる（
`https://subdomain.example.com/^s,
`https://example.com/^s
の`登録-可能な~domain$は同じなので）。
◎
If that response redirected to https://subdomain.example.com/redirect, that request’s Sec-Fetch-Site value would be same-site (as https://subdomain.example.com/ and https://example.com/ have the same registrable domain).＼
</li>
	<li>
前段の応答が
`https://example.net/redirect^s
へ~redirectされた場合、対する要請の `Sec-Fetch-Site^h 値は
`cross-site^l になる（
`https://example.net/^s
は［
`https://example.com/^s ／ `https://subdomain.example.com/^s
］と`同じ~site$でないので）。
◎
If that response redirected to https://example.net/redirect, that request’s Sec-Fetch-Site value would be cross-site (as https://example.net/ is not same-site with https://example.com/ and https://subdomain.example.com/).＼
</li>
	<li>
前段の応答が，巡り巡って~~元の
`https://example.com/^s
へ~redirectされた場合でも、最終~要請の `Sec-Fetch-Site^h 値は，依然として `cross-site^l になる（~redirect連鎖は
`https://example.net/^s
を含むが，それは依然として他の~URLと`同じ~site$ではないので）。
◎
If that response redirects all the way back to https://example.com/, the final request’s Sec-Fetch-Site value would still be cross-site (as the redirect chain includes https://example.net/, which is still not same-site with the other URLs.
</li>
</ol>
</div>

		</section>
		<section id="sec-prefix">
<h3 title="The Sec- Prefix">4.2. `Sec-^h 接頭辞</h3>

<p>
この文書に定義される各~headerは、どれも `Sec-^h が接頭され，`禁止~header名$になるので、~JSからは改変-不能になる。
したがって、［
悪意的な~web~siteが、偽造した~metadataを要請に伴わせて送信するよう，~UAを仕向ける
］ことは，防止される。
これにより、~siteは［
自身による，広告された情報に対し適理に応答する能
］に少しは確信を持てるようになるはずである。
◎
Each of the headers defined in this document is prefixed with Sec-, which makes them all forbidden header names, and therefore unmodifiable from JavaScript. This will prevent malicious websites from convincing user agents to send forged metadata along with requests, which should give sites a bit more confidence in their ability to respond reasonably to the advertised information.
</p>

		</section>
		<section id="directly-user-initiated">
<h3 title="Directly User-Initiated Requests">4.3. 利用者が直に起動した要請</h3>

<p>
`~Sec-Fetch-Site~headerを設定する$とき、~UAは，当の~navi要請が
“利用者のヤリトリにより明示的に生じたもの”
かどうか判別するよう依頼される。
このいくぶん拙く定義された句は、
<a href="~NAVI#navigating-across-documents">~HTMLから~~引用した示唆</a>
による：
“~UAは、この仕様に定義されるものに加えて，閲覧文脈を明示的に~navigateさせる様々な仕方を利用者~向けに供してもヨイ。”
◎
When setting the Sec-Fetch-Site header, user agents are asked to distinguish between navigation requests that are "explicitly caused by a user’s interaction". This somewhat poorly defined phrase is pulled from HTML, which suggests that "A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification."
</p>

<p>
目標は、所与の（悪意的にもなり得る）~web~siteにより制御された “~web的な” ~navi（例：
~link, `window.location$c 設定子, ~form提出, 等々）と，そうでないもの（例：
利用者が~UAの~address~bar, ~bookmark, 等々とヤリトリして生じたもの）とを判別することにある。
前者は、`Sec-Fetch-Site^h ~headerに値［
`same-origin^l, `same-site^l, `cross-site^l
］のうち適切なものを伴わせて送達することになる。
後者は、値 `none^l で判別されることになる
— 当の要請は、それを実際に担当した特定の~siteは無く，利用者による直な意図を何らかの~~形で表現するものであり、信用-済みとして扱うことを~serverに許容することは，イミを成すので。
◎
The goal is to distinguish between "webby" navigations that are controlled by a given (potentially malicious!) website (e.g. links, the window.location setter, form submissions, etc.), and those that are not (e.g. user interaction with a user agent’s address bar, bookmarks, etc). The former will be delivered with a Sec-Fetch-Site header whose value is same-origin, same-site, or cross-site, as appropriate. The latter will be distinguished with a value of none, as no specific site is actually responsible for the request, and it makes sense to allow servers to treat them as trusted, as they somehow represent a user’s direct intent.
</p>

<p>
各~UAは、別個の各種ヤリトリを備えると見込まれる。
それらは， 1 つ以上の分類に該当するかもしれず、それらの事例~用に自動化された~test一式を共有するのは難しくなる。
しかしながら、共通な挙動については，揃えた方が理想的になるであろう。
いくつか例を挙げる：
◎
Each user agent is likely to have a distinct set of interactions which might fall into one or the other category, and it will be hard to share an automated test suite for these cases. Still, it would be ideal to align on behavior for those which are likely to be common. Sme examples follow:
</p>

<ul>
	<li>
~address~barからの~navi：
一般~事例においては、この種の~naviは，利用者が直に起動したものと扱って
`Sec-Fetch-Site: none^s
を含めるベキである。
~UAにとっては、~address~barの中へ値を~pasteすることに関し，そのような~naviを利用者が自身で打込んだときとは別個に扱う経験則を含めることも適理になり得る（とりわけ，特定の生成元まで “~copy” 動作をナゾれる場合には）。
◎
Navigation from the address bar: In the general case, this kind of navigation should be treated as directly user-initiated, and include Sec-Fetch-Site: none. It may be reasonable for user agents to include heuristics around pasting values into the address bar (especially if the "copy" action can be traced to a specific origin), and to treat such navigations distinctly from those which the user types themselves.
</li>
	<li>
~UAに備わる~UIからの~navi（ ~bookmark, 新たな~tab~page, 等々）:
そのような~UIにおいて利用者が~linkとヤリトリしたときは、［
~UAの~address~barにおける入力と同様に扱って，
`Sec-Fetch-Site: none^s
を含める
］ことにより、~naviを利用者が起動したものとするベキである。
◎
Navigation from user agent UI (bookmarks, new tab page, etc): A user’s interaction with links in user agent UI should be treated similarly to their input in the user agent’s address bar, including Sec-Fetch-Site: none to demarcate the navigation as user-initiated.
</li>
	<li>
~linkの文脈~menuからの~navi（例： “新たな~window内に開く”）：
~linkの~targetは，それを呈示した~pageにより制御されるので、~UAはその~naviを~siteが制御しているものと扱って，~linkを制御している~siteと開かれた~siteとの関係性~用に
`Sec-Fetch-Site^h ~headerを適切に設定するベキである。
◎
Navigation from a link’s context menu (e.g. "Open in new window"): as the link’s target is controlled by the page on which the link is present, user agents should treat the navigation as site-controlled, and set the Sec-Fetch-Site header appropriately for the relationship between the site which controls the link and the site which is being opened.
</li>
	<li>
~link上での <kbd>Ctrl</kbd>＋~click：
前項で論じた~linkの文脈~menuに適用されるものと同じ主旨と結論が適用される。
◎
Ctrl-click on a link: the same arguments and conclusions apply here as apply to a link’s context menu, discussed directly above.
</li>
	<li>
履歴を通した~navi（例：~UAの “戻る” ~button）：
【まだ何も記されていない】
◎
Navigation through history (e.g. a user agent’s "back" button):
</li>
	<li>
~drag-and-drop：
ここでの挙動は、~dragされた内容の~sourceに基づいて判別することが適理に見受けられる。
内容が，ある~tabから~dragされた場合、~UAは，その生成元を確かめられるはずなので、それに則って `Sec-Fetch-Site^h を設定する。
内容が他所から~dragされた場合（例：~UAの~bookmark~barや，別の~appから, 等々）、
`Sec-Fetch-Site: none^s
が適切になるであろう。
◎
Drag-and-drop: It seems reasonable to distinguish behavior here based upon the source of the dragged content. If content is dragged from a tab, the user agent should be able to ascertain its origin, and set Sec-Fetch-Site accordingly. If content is dragged from elsewhere (the user agent’s bookmark bar, another app entirely, etc), then Sec-Fetch-Site: none may be appropriate.
</li>
</ul>

		</section>
	</section>
	<section id="deployment-considerations">
<h2 title="Deployment Considerations">5. 配備~上の考慮点</h2>

		<section id="vary">
<h3 title="Vary">5.1. `Vary^h</h3>

<p>
所与の端点の応答が ~clientから`~fetch~metadata~header$内に送達された値に依存する場合、開発者は
— ~cacheが応答を適切に取扱うことを確保するため —
適切な `Vary^h ~header `RFC7231$r を含むよう注意深くなるベキである。
例えば：
`Vary: Accept-Encoding, Sec-Fetch-Site^s
◎
If a given endpoint’s response depends upon the values the client delivers in a Fetch metadata header, developers should be careful to include an appropriate Vary header [RFC7231], in order to ensure that caches handle the response appropriately. For example, Vary: Accept-Encoding, Sec-Fetch-Site.
</p>

		</section>
		<section id="bloat">
<h3 title="Header Bloat">5.2. ~headerの肥大化</h3>

<p>
この文書の~~過去の~versionでは、単独の `Sec-Metadata^h ~headerは、`辞書$hsを内容とするよう定義していた。
後続の論（および `Mark Nottingham^en 氏による優れた `mnot-designing-headers$r ）から、単独の辞書から離れて，［
それぞれが単独の`~token$hsのみを包含する，一連の単純な~header
］とするよう設計を切り替えた。
この設計は、~HTTPの現在の~HPACK圧縮~algoの下では，有意により良く遂行されるはずである。
◎
An earlier version of this document defined a single Sec-Metadata header, whose contents were a dictionary. Subsequent discussion (as well as Mark Nottingham’s excellent [mnot-designing-headers]) shifted the design away from a single dictionary to a series of simple headers, each of which contains only a single token. This design should perform significantly better under HTTP’s current HPACK compression algorithms.
</p>

<p>
この論題についての更なる論は
<a href="https://github.com/w3ctag/design-reviews/issues/280">w3ctag/design-reviews#280</a>
にて考査されている。
◎
Further discussion on the topic can be found on the review thread in w3ctag/design-reviews#280.
</p>

		</section>
	</section>
	<section id="iana">
<h2 title="IANA Considerations">6. ~IANA考慮点</h2>

<p>
恒久的~message~header~field~registryは、次に与える`~fetch~metadata~header$用の登録で更新されるベキである
`RFC3864$r
【この訳では、各~headerを一括して示す】
：
◎
The permanent message header field registry should be updated with the following registrations for Fetch metadata headers: [RFC3864]
</p>

<div>

<dl>
	<dt>~header~field名</dt>
	<dd id="sec-fetch-dest-reg">
`Sec-Fetch-Dest^h
</dd>
	<dd id="sec-fetch-mode-reg">
`Sec-Fetch-Mode^h
</dd>
	<dd id="sec-fetch-site-reg">
`Sec-Fetch-Site^h
</dd>
	<dd id="sec-fetch-user-reg">
`Sec-Fetch-User^h
</dd>

	<dt>適用-可能な~protocol</dt>
	<dd>
~http
</dd>

	<dt>位置付け</dt>
	<dd>
標準
</dd>

	<dt>作者</dt>
	<dt>変更管理者</dt>
	<dd>
編集者
</dd>

	<dt>仕様~文書</dt>
	<dd>
この仕様
— 次に挙げる各~節
⇒＃
<a href="#sec-fetch-dest-header">§ `Sec-Fetch-Dest^h ~HTTP要請~header</a>,
<a href="#sec-fetch-mode-header">§ `Sec-Fetch-Mode^h ~HTTP要請~header</a>,
<a href="#sec-fetch-site-header">§ `Sec-Fetch-Site^h ~HTTP要請~header</a>,
<a href="#sec-fetch-user-header">§ `Sec-Fetch-User^h ~HTTP要請~header</a>
</dd>
</dl>

◎
6.1. Sec-Fetch-Dest Registration
◎
Header field name
• Sec-Fetch-Dest
Applicable protocol
• http
Status
• standard
Author/Change controller
• Me
Specification document
• This specification (See §2.1 The Sec-Fetch-Dest HTTP Request Header)
◎
6.2. Sec-Fetch-Mode Registration
◎
Header field name
• Sec-Fetch-Mode
Applicable protocol
• http
Status
• standard
Author/Change controller
• Me
Specification document
• This specification (See §2.2 The Sec-Fetch-Mode HTTP Request Header)
◎
6.3. Sec-Fetch-Site Registration
◎
Header field name
• Sec-Fetch-Site
Applicable protocol
• http
Status
• standard
Author/Change controller
• Me
Specification document
• This specification (See §2.3 The Sec-Fetch-Site HTTP Request Header)
◎
6.4. Sec-Fetch-User Registration
◎
Header field name
• Sec-Fetch-User
Applicable protocol
• http
Status
• standard
Author/Change controller
• Me
Specification document
• This specification (See §2.4 The Sec-Fetch-User HTTP Request Header)
</div>

	</section>
	<section id="acks">
<h2 title="Acknowledgements">7. 謝辞</h2>

<p>
この仕組みの設計に~~相当な~supportを供された，次の方々に感謝する：
◎
Thanks to Anne van Kesteren, Artur Janc, Dan Veditz, Łukasz Anforowicz, Mark Nottingham, and Roberto Clapis, who all provided substantial support in the design of this mechanism.
</p>

<div lang="en-x-a0">
Thanks to Anne van Kesteren, Artur Janc, Dan Veditz, Łukasz Anforowicz, Mark Nottingham, and Roberto Clapis, who all provided substantial support in the design of this mechanism.
</div>

	</section>
</main></div>
