<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP — Digest Fields（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<style>
figure > pre {
	margin: 0;
}

@supports (display: grid) and (display: contents) {

#_hash-algorithm-table {
	min-width:25em;
}

#_hash-algorithm-table tr {
	grid-template-areas:
		"key 位置付け 参照"
		"key 記述 記述"
	;
	grid-template-columns: 10em 8em 1fr;
}

#_hash-algorithm-table tr > *:nth-child(1) {
	grid-area: key;
	border-left-width: 0;
}

#_hash-algorithm-table tr > *:nth-child(2) {
	grid-area: 位置付け;
}

#_hash-algorithm-table tr > *:nth-child(3) {
	grid-area: 記述;
}

#_hash-algorithm-table tr > *:nth-child(4) {
	grid-area: 参照;
}

}
</style>


<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Digest Fields
spec_date:2023-07-05
trans_update:2023-07-08
source_checked:230308
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html
abbr_url:HTTPdigest
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2021-06-15

●●class_map

●●tag_map

●●original_id_map

references:
normative:
informative:

	iana-hash-algorithm-table:name-initial-hash-algorithms

●●mdn_urls

●●link_map

h.Repr-Digest:#representation-digest
h.Content-Digest:#content-digest
h.Want-Repr-Digest:#want-fields
h.Want-Content-Digest:#want-fields
h.Digest:~RFCx/rfc3230#section-4.3.2
h.Want-Digest:~RFCx/rfc3230#section-4.3.1

c.sha-256:#digest-sha-256
	i.SHA-256:#digest-sha-256
c.sha-512:#digest-sha-512
	i.SHA-512:#digest-sha-512
c.md5:#digest-md5
	i.MD5:#digest-md5
c.sha:#digest-sha
	i.SHA:#digest-sha
i.SHA-1:#digest-sha
c.unixsum:#digest-unixsum
	i.UNIXsum:#digest-unixsum
c.unixcksum:#digest-unixcksum
	i.UNIXcksum:#digest-unixcksum
c.adler:#digest-adler
i.ADLER32:#digest-adler
c.crc32c:#digest-crc32c
i.CRC32c:#digest-crc32c

~SBS-ST:#SBS-ST

完全性~field:#integrity-field
完全性~選好~field:#integrity-preference-field

形式変換ng~proxy:~HTTPsem#transforming-proxy

有構造~field:~STRUCTURED-FIELDS#structured-field
~sf真偽値:~STRUCTURED-FIELDS#sf-boolean
~sf~list:~STRUCTURED-FIELDS#sf-list
~sf辞書:~STRUCTURED-FIELDS#sf-dictionary
~sf~byte列:~STRUCTURED-FIELDS#sf-binary
~sf整数:~STRUCTURED-FIELDS#sf-integer

cite.~HTTP~digest~field用~hash~algo~registry:#_hash-algo-registry
	~IANA-a/http-digest-hash-alg/
	~IANA-a/http-structured-dig-alg/

~hashing~algo:#algorithms
選定された表現~data:#selected-representation-data
~algo~key:#algorithm-key
位置付け:#algorithm-status

	●§
1:#introduction
1.1:#document-structure
1.2:#concept-overview
1.3:#obsolete-3230
1.4:#notational-conventions
2:#content-digest
3:#representation-digest
3.1:#state-changing-requests
3.2:#digest-and-content-location
4:#want-fields
5:#algorithms
6:#security
6.1:#sec-limitations
6.2:#end-to-end-integrity
6.3:#usage-in-signatures
6.4:#usage-in-trailer-fields
6.5:#variations-within-content-encoding
6.6:#sec-agility
6.7:#sec-exhaustion
7:#iana-considerations
7.1:#http-field-name-registration
7.2:#establish-hash-algorithm-registry
7.3:#deprecate-the-hypertext-transfer-protocol-http-digest-algorithm-values-registry

A:#resource-representation
B:#examples-unsolicited
B.1:#example-full-representation
B.2:#server-returns-no-representation-data
B.3:#server-returns-partial-representation-data
B.4:#client-and-server-provide-full-representation-data
B.5:#client-provides-full-representation-data-server-provides-no-representation-data
B.6:#client-and-server-provide-full-representation-data-1
B.7:#post-not-request-uri
B.8:#post-referencing-status
B.9:#digest-with-patch
B.10:#error-responses
B.11:#use-with-trailer-fields-and-transfer-coding
C:#examples-solicited
C.1:#server-selects-clients-least-preferred-algorithm
C.2:#ex-server-selects-unsupported-algorithm
C.3:#server-does-not-support-client-algorithm-and-returns-an-error
D:#sample-digest-values
E:#migrating
	:#faq
	:#acknowledgements
	:#code-samples
	:#changes
	:#authors-addresses

●●words_table1

sf:<sub>sf-</sub>
SBS-ST:NOTE: '\' line wrapping per RFC 8792

●●words_table

	●略語
UNIX:
MICE:
python3:

	●digest
base64:
SHA:
checksum::::チェックサム
nonce::::ナンス
digital::::デジタル
hashing::::ハッシュ化
GZIP:

	^i:Base64
	^i:Brotli
	^i:SHA-256
	^i:SHA-512
	^i:MD5
	^i:SHA-1
	^i:CRC32c
	^i:ADLER32
	^i:MICE
	`内容$:message content

	●構文
不正形な:malformedな:不正な形の
不正形:malformed:不正な形
印字不能:non-printable:~
字下げ:indentation:~
後続-:follow:~

	文字大小-法:casing
	小文字:lower-case
	引用符で括られ:quote
	〜形式にされ:formatted
	形式~化:formatting
	字下げ:2 spaces of leading indentation
	重複〜を除去する:de-duplication
	急ぐ:eager
	折返し法:folding strategies

	●処理
弄る:mangleする:~
診断:diagnosis:~
発行-:issue:~
有符号化-:code::~::コード

	通過する:pass across
	手渡す:handing off

	●保安
暗号用:cryptographic::~
破損:corruption:~
衝突:collision::~
耐性:resistance::~
原像:preimage::~
改ざん:tampering:~
晒し:exposeし:~
敵対者:adversary:~
	敵対者に~~晒され得る:potentially adversarial
	敵対者に~~晒される:adversarial
真正性:authenticity::~
署名-:sign::~
署名:signature::~
代用:substitution::~
出自:origin::~
事故:accident:~

	第一-:first-
	第二-:second-
	暗号化されてない:unencrypted
	抗する:against
	非~secure:insecure
	~secureでない:insecure
	最も弱い:weakest
	~~保険をかける:providing coverage
	破られた:broken
	残す:leave

	●仕様
順応-:adapt:~
刷新-:refresh:~
	能が無い:inability
動作者:actor:~
概略的:brief:~
単直:straightforward:簡単
請求-:solicite:~
	請求されない:unsolicited
証明:proof:~
浪費-:waste:~
枯渇:exhaustion:~
簡潔:compact:~
発展-:evolve:~
	様々な:population of
相:phase:~
合法的:legitimate:~
偉業:great work:~
即応性:agility::~
移行:migration:~
移行-:migrate:~
移行t:transition:移行
	離れるよう移行t:transitioning away
特質:properties:~
束ねら:tieさ:~
欠陥:fault:~
倣う:alignする:~
尊重-:respect:~
発生-:arise:~
構成:structure:~
	構成:structured
助け:help:~
関心:interest:~
興味深い:interestingな:~
	興味深いことに:interestingly
	関心~group:interest group
固定的:fixed:~
指向な:-oriented:~
有用性:utility:~
普遍的:universal:~
有益:beneficial:~
廃用d:obsoleted:廃用
取代され:supersedされ:取って代わられ
誤り:error:~
定めな:prescribeしな:~
指名-:designate:~
専門家:expert:~
暫定的:provisional:~
workflow::::ワークフロー
見解:opinion:~
雛形:template:~
設けら:set outさ:~
標準開発組織:SDO:~
立証-:prove:~
	立証されてない:unprove
多様性:variation:~
閉鎖-:close:~
否定-:negate:~
免除-:exempt:~

	至らす:cause
	至らす:leading
	併せて:in conjunction with
	他の場面でも:Other places
	〜ないと見込まれる:less likely
	見込みが高い:likely
	基づくこと:basing
	一方では:on one hand
	十分:enough
	謝意:thank
	欲されない:undesired
	問わない:agnostic
	選ぶ:choose
	選ぶ:make a choice
	どの〜選ぶか:choice
	選んで:chooseして
	類の:sort of
	発生-:arose
	はず:should
	対照:contrast
	いずれにせよ:anyway
	最終的:eventual
	とても:very
	であったとしても:would have been 〜 too
	~~説明する:help illustrate
	示す:illustrate
	価値はある:valuable
	価値ある:valuable
	してもかまわない:free to
	試験的^i:"experimental"
	とは言え、:Endpoints are advised that
	より低:lower
	〜できなくなる:prevents
	〜群:set of
	一覧:table
	^en:Specification Required
	参照:Reference
	賢い:smart
	質問をして:asking 〜 question
	~~義務はない:not obliged to 
	別法として:alternatively
	適用した結果:application
	関係する所:in relation to
	新造した:coined
	時を経て:time has
	と今や称されるもの:what we now call
	と総称される:collectively termed
	総称:collective
	廃用~化:obsoleting
	一貫性がなかった:inconsistently
	非-一貫性~inconsistencies
	適合しないこと:non-conformance
	かそうでないのか:or unintentional
	明瞭に表す:clearly articulate
	アリ性:possibility
	用意がある:willing to
	~~必要とされる:demand
	~~自前の:it also defined
	後に，has since
	に伴って:alongside
	願って:would like
	用例:worked example
	結付けるよう:in association with
	~~根拠:grounds
	注意を払う:pay attention
	〜ことから:By virtue of
	次に挙げるいずれか:The options are
	すなわち:meaning that
	多様なもの:wide variety of
	混在していた:mix of
	広範な:broad
	目的をもった:purposeful
	反対の:opposite
	は別として:aside from
	かなり:quite
	たいした〜無い:negligible
	必要以上に:undue
	~~被る:caused by

	●言い換え
中継点:hop::~
	いくつかの中継点を通過する:across multiple hops
	最も選好しない:Least Preferred
	場合に備える:should
	能力はない:not capable of
	ある種の:certain kinds of
	〜からの変更点:Changes Compared to
	~transport層:transport-layer
	~message法:messaging
	予め処理する:preprocess
	内容~符号法:content-coding
	内容:payload
	内容:body
	有構造~field:Structured Fields
	~parameter化:parameterized
	参照-先の:referenced
	~base64に符号化された:base64-encoded
	符号化されていない:unencoded
	〜を含めて:inclusive
	それらに:in this set
	とは異なる:different compared to
	〜で呈示される場合もある:For presentation purposes, ...
	行l長さの~~都合により...:fit completely within the line-length limits...
	受信者$:receiver
	識別するもの:identification of
	~trailer節:trailers
	段階:stage
	-:finally
	内容は伴わない:empty content
	短い:short
	選好~度:ascending, relative, weighted preference
	値が大きいものほど選好される: 〜 least preferred, 〜 most preferred
	{ 〜 }:inclusive
	確立して，初期~登録を与える:bootstrap
	複数行からなる:multiline
	算出し直-:recomputation

	●未分類
消費:consumption::~
返信-:reply:~
再生器:player::~::プレイヤー
patch::::パッチ
計算l:computational:計算
折返され:wrapされ:折り返され
旅する:travelする:~
逆順に:reverse orderで:~

	改行:-
	この:the present
	添える:attach
	切り離す:decouple
	部分的にしか:fully or partially
	端点どうし:between peers
	大きくなる:larger
	全体が:whole
	一体として:in whole
	全体:the whole
	だけ:alone
	各部:parts
	各部ごと:in part
	何も:anything
	回数:number of
	全体を通して:throughout
	0 でない:non-zero
	一部が:partly
	のうち いくつを:all, some, or none of
	またがる:across
	〜までに:extent
	各部:parts
	それまで:previously
	演算~上の:operational

	●語形
	^r:Single UNIX Specification, version 2
	^en:Internet Assigned Numbers Authority
	^i:identity
	`~digest認証^cite:Digest Authentication
	~HTTP~field名~registry^cite:"Hypertext Transfer Protocol (HTTP) Field Name Registry"
	表現~digest:Representation Digest
	表現~data:representation-data
	範囲~要請:Range Request
	~field値:field-value
	~digest値:digest-value
	~MIME型:media-type



●●ref_key_map
PATCH:RFC5789

●●ref_normative

[FOLDING]
    Watsen, K., Auerswald, E., Farrel, A., and Q. Wu, "Handling Long Lines in Content of Internet-Drafts and RFCs", ~RFC8792, June 2020
[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
    URL: https://httpwg.org/specs/rfc9110.html
[RFC1321]
    Rivest, R., ＜The MD5 Message-Digest Algorithm＞, ~RFC1321, April 1992
[RFC1950]
    Deutsch, P. and J. Gailly, ＜ZLIB Compressed Data Format Specification version 3.3＞, ~RFC1950, May 1996
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC3174]
    Eastlake 3rd, D. and P. Jones, ＜US Secure Hash Algorithm 1 (SHA1)＞, ~RFC3174, September 2001
[RFC4648]
    Josefsson, S., ＜The Base16, Base32, and Base64 Data Encodings＞, ~RFC4648, October 2006
[RFC5234]
    Crocker, D., Ed. and P. Overell, ＜Augmented BNF for Syntax Specifications: ABNF＞, STD 68, ~RFC5234, January 2008
[RFC6234]
    Eastlake 3rd, D. and T. Hansen, ＜US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)＞, ~RFC6234, May 2011
[RFC7405]
    Kyzivat, P., ＜Case-Sensitive String Support in ABNF＞, ~RFC7405, December 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, ＜Guidelines for Writing an IANA Considerations Section in RFCs＞, BCP 26, ~RFC8126, June 2017
[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[STRUCTURED-FIELDS]
    Nottingham, M. and P. Kamp, ＜Structured Field Values for HTTP＞, ~RFC8941, February 2021

●●ref_informative

[CMU-836068]
    Carnegie Mellon University, Software Engineering Institute, ＜MD5 Vulnerable to collision attacks＞, 31 December 2008
    URL: https://www.kb.cert.org/vuls/id/836068/
[HTTP/1.1]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP/1.1＞, STD 99, ~RFC9112
    URL: https://httpwg.org/specs/rfc9112.html
[I-D.thomson-http-mice]
    Thomson, M. and J. Yasskin, ＜Merkle Integrity Content Encoding＞, Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-thomson-http-mice
[IACR-2020-014]
    Leurent, G. and T. Peyrin, ＜SHA-1 is a Shambles＞, 5 January 2020
    URL: https://eprint.iacr.org/2020/014.pdf
[NIST800-32]
    National Institute of Standards and Technology, U.S. Department of Commerce, ＜Introduction to Public Key Technology and the Federal PKI Infrastructure＞, February 2001
    URL: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-32.pdf
[NO-MD5]
    Turner, S. and L. Chen, ＜Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms＞, ~RFC6151, March 2011
[NO-SHA]
    Polk, T., Chen, L., Turner, S., and P. Hoffman, ＜Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms＞, ~RFC6194, March 2011
[PATCH]
    Dusseault, L. and J. Snell, ＜PATCH Method for HTTP＞, ~RFC5789, March 2010
[RFC3230]
    Mogul, J. and A. Van Hoff, ＜Instance Digests in HTTP＞, ~RFC3230, January 2002
[RFC6211]
    Schaad, J., ＜Cryptographic Message Syntax (CMS) Algorithm Identifier Protection Attribute＞, ~RFC6211, April 2011
[RFC7396]
    Hoffman, P. and J. Snell, ＜JSON Merge Patch＞, ~RFC7396, October 2014
[RFC7696]
    Housley, R., ＜Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms＞, BCP 201, ~RFC7696, November 2015
[RFC7807]
    Nottingham, M. and E. Wilde, ＜Problem Details for HTTP APIs＞, ~RFC7807, March 2016
[RFC8188]
    Thomson, M., ＜Encrypted Content-Encoding for HTTP＞, ~RFC8188, June 2017
[RFC9260]
    Stewart, R., Tüxen, M., and K. Nielsen, ＜Stream Control Transmission Protocol＞, ~RFC9260, June 2022
[SIGNATURES]
    Backman, A., Richer, J., and M. Sporny, ＜HTTP Message Signatures＞, Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures
[TLS]
    Rescorla, E., ＜The Transport Layer Security (TLS) Protocol Version 1.3＞, ~RFC8446, August 2018
[UNIX]
    The Open Group, ＜The Single UNIX Specification, Version 2 - 6 Vol Set for UNIX 98＞, February 1997


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公表された，
<a href="~SPEC_URL">Digest Fields</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

公表者
	<a href="https://httpwg.org/">HTTP Working Group</a>
位置付け
	Internet-Draft
廃用
	<a href="https://datatracker.ietf.org/doc/html/rfc3230">3230</a> （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	Roberto Polli, Team Digitale, Italian Government, Italy, Email: <a href="mailto:robipolli@gmail.com">robipolli@gmail.com</a>
	Lucas Pardue, Cloudflare, Email: <a href="mailto:lucaspardue.24.7@gmail.com">lucaspardue.24.7@gmail.com</a>

課題追跡
	https://github.com/httpwg/http-extensions/labels/digest-headers
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-digest-headers/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-digest-headers.md

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
現在の Internet-Draft のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>

<header>
	<hgroup>
<h1 title="Digest Fields">HTTP — ダイジェストフィールド</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section>
◎要約

<p>
この文書は、
完全性~digestを~supportする~HTTP`~field$として，次に挙げるものを定義する：
◎
This document defines HTTP fields that support integrity digests.＼
</p>
<ul>
	<li>
`Content-Digest$h ~fieldは、
~HTTP~message`内容$の完全性~用に利用できる。
◎
The Content-Digest field can be used for the integrity of HTTP message content.＼
</li>
	<li>
`Repr-Digest$h ~fieldは、
~HTTP`表現$の完全性~用に利用できる。
◎
The Repr-Digest field can be used for the integrity of HTTP representations.＼
</li>
	<li>
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］~fieldは、
`完全性~field$を受信することに関する`送信者$の［
関心と選好
］を指示するために利用できる。
◎
Want-Content-Digest and Want-Repr-Digest can be used to indicate a sender's interest and preferences for receiving the respective Integrity fields.
</li>
</ul>

<p>
この文書は、
~RFC 3230, および［
`Digest^h, `Want-Digest^h
］`~field$を廃用にする。
◎
This document obsoletes RFC 3230 and the Digest and Want-Digest HTTP fields.
</p>

	</section>
	<section>
<h2 title="About This Document">この文書について</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#about-this-draft$に移譲。
】</p>

<!-- 
Source for this draft and an issue tracker can be found at https://github.com/httpwg/http-extensions/labels/digest-headers.
 -->

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTPは、［
`内容$／`表現$
］を成す~dataの完全性を保護するための手段は定義しない。
~HTTP`~message$が端点~間で転送されるとき、
より低~層な特能や特質
— ~TCP~checksumや~TLS~record `TLS$r など —
は，何らかの完全性~保護を供し得る。
しかしながら，~transport指向な完全性が供する有用性は制限される
— それは，応用~層からは不透明であり、
それが受持つのは，単独の接続までに限られるので。
~HTTP~messageは，別々な接続の連鎖~越しに旅することが多く、
接続どうしの合間にて~data破損を~~被るアリ性がある。
~HTTPによる完全性の仕組みは、［
端点／~HTTPを利用している応用
］用に［
~data破損を検出して，それに対し動作する方法について選ぶ
］ための手段を供せる。
利用事例の例として、
~system境界にまたがる欠陥~検出とその診断を援助することが挙げられる。
◎
HTTP does not define the means to protect the data integrity of content or representations. When HTTP messages are transferred between endpoints, lower layer features or properties such as TCP checksums or TLS records [TLS] can provide some integrity protection. However, transport-oriented integrity provides a limited utility because it is opaque to the application layer and only covers the extent of a single connection. HTTP messages often travel over a chain of separate connections. In between connections there is a possibility for data corruption. An HTTP integrity mechanism can provide the means for endpoints, or applications using HTTP, to detect data corruption and make a choice about how to act on it. An example use case is to aid fault detection and diagnosis across system boundaries.
</p>

<p>
この文書は、
~HTTP用の~digest完全性の仕組みとして，次に挙げる 2 つを定義する：
◎
This document defines two digest integrity mechanisms for HTTP.＼
</p>
<ul>
	<li>
内容の完全性は、
伝達される`内容$に対し動作する。
◎
First, content integrity, which acts on conveyed content (Section 6.4 of [HTTP]).＼
</li>
	<li>
表現~dataの完全性は、
`表現~data$に対し動作する。
これは、
高度な利用事例を~supportする
— ［
複数の［
要請／接続
］を利用して検索取得された各部から構築し直された資源
］に対し，その完全性を検証することなど。
◎
Second, representation data integrity, which acts on representation data (Section 8.1 of [HTTP]). This supports advanced use cases such as validating the integrity of a resource that was reconstructed from parts retrieved using multiple requests or connections.
</li>
</ul>

<p>
この文書は、
~RFC 3230
— したがって［
`Digest^h, `Want-Digest^h
］`~field$も —
を廃用にする。
`1.3§ を見よ。
◎
This document obsoletes RFC 3230 and therefore the Digest and Want-Digest HTTP fields; see Section 1.3.
</p>

		<section id="document-structure">
<h3 title="Document Structure">1.1. この文書の構成</h3>

<p>
この文書の構成は：
◎
This document is structured as follows:
</p>
<ul>
	<li>
次に挙げる新たな【！［要請／応答］［~header／~trailer］】~fieldを定義する
⇒＃
`2§） `Content-Digest$h,
`3§） `Repr-Digest$h,
`4§） `Want-Content-Digest$h, `Want-Repr-Digest$h
◎
New request and response header and trailer field definitions.
• Section 2 (Content-Digest),
• Section 3 (Repr-Digest), and
• Section 4 (Want-Content-Digest and Want-Repr-Digest).
</li>
	<li>
<p>
表現~dataの完全性に特有な考慮点：
◎
Considerations specific to representation data integrity.
</p>
		<ul>
			<li>
`3.1§）状態変更~要請における `Repr-Digest$h の利用-法
◎
Section 3.1 (State-changing requests),
</li>
			<li>
`3.2§）応答~内の `Repr-Digest$h と `Content-Location$h
◎
Section 3.2 (Content-Location),
</li>
			<li>
`A§）~message交換における`表現~data$の用例
◎
Appendix A contains worked examples of Representation data in message exchanges, and
</li>
	<li>
`B§, `C§）
~message交換における［
`Repr-Digest$h ／ `Want-Repr-Digest$h
］~fieldの用例
◎
Appendix B and Appendix C contain worked examples of Repr-Digest and Want-Repr-Digest fields in message exchanges.
</li>
		</ul>
	</li>
	<li>
`5§）
~hash~algo用に新たな~IANA~registryを確立して，初期~登録を与える。
将来の~entry用の登録~手続-を定義する。
◎
Section 5 bootstraps a new IANA registry hash algorithms and defines registration procedures for future entries.
</li>
</ul>

		</section>
		<section id="concept-overview">
<h3 title="Concept Overview">1.2. 概念の概観</h3>

<p>
この文書にて定義される`~field$は、
~HTTP完全性のために利用できる。
`送信者$は、
ある`~hashing~algo$を選んで，
当の~HTTP`~message$に関係する入力から~digestを計算する。
当の~algoの識別子と結果の~digestは、
`~field$内に伝送される。
`受信者$は、
完全性の目的で，その~digestを検証できる。
`~hashing~algo$は、
`~HTTP~digest~field用~hash~algo~registry$cite
内に登録される（ `7.2§ を見よ）。
◎
The HTTP fields defined in this document can be used for HTTP integrity. Senders choose a hashing algorithm and calculate a digest from an input related to the HTTP message. The algorithm identifier and digest are transmitted in an HTTP field. Receivers can validate the digest for integrity purposes. Hashing algorithms are registered in the "Hash Algorithms for HTTP Digest Fields" registry (see Section 7.2).
</p>

<p>
~digestを どの~dataに対し計算するか選定することは、
~HTTP~messageの利用事例に依存する。
この文書は、
~HTTPの`表現~data$用と`内容$用に異なる~fieldを供する。
◎
Selecting the data on which digests are calculated depends on the use case of HTTP messages. This document provides different fields for HTTP representation data and HTTP content.
</p>

<p>
`内容$を成す~byte列の単純な~digestが要求される利用事例もある。
`Content-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldは，
`内容$の~digestを~supportするために定義される。
`2§ を見よ。
◎
There are use cases where a simple digest of the HTTP content bytes is required. The Content-Digest request and response header and trailer field is defined to support digests of content (Section 6.4 of [HTTP]); see Section 2.
</p>

<p>
より高度な利用事例~用には、
`Repr-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldが定義される（ `3§ ）。
それは、［
`選定された表現~data$に対し，ある`~hashing~algo$を適用する
］ことにより算出された~digest値を包含する。
`Repr-Digest$h を`選定された表現$に基づくようにすることは、
次に挙げる利用事例に，それを適用することを単直にする：
◎
For more advanced use cases, the Repr-Digest request and response header and trailer field (Section 3) is defined. It contains a digest value computed by applying a hashing algorithm to selected representation data (Section 8.1 of [HTTP]). Basing Repr-Digest on the selected representation makes it straightforward to apply it to use cases where＼
</p>
<ul>
	<li>
`内容$が`資源$の`表現$と見なされるものに何らかの類の操作を要求する所
◎
the message content requires some sort of manipulation to be considered as representation of the resource＼
</li>
	<li>
`内容$が`資源$の部分的な表現を伝達する所
— `範囲~要請$ `HTTP$r【！§ 14.2】 など
◎
or content conveys a partial representation of a resource, such as Range Requests (see Section 14 of [HTTP]).
</li>
</ul>

<p>
［
`Content-Digest$h ／ `Repr-Digest$h
］~fieldは、
`~hashing~algo$の即応性【 `6.6§ 】を~supportする。
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］~fieldは、［
`Content-Digest$h ／ `Repr-Digest$h
］に対する関心, および［
どの~algoを選好するか
］を表出することを端点に許容する。
◎
Content-Digest and Repr-Digest support hashing algorithm agility. The Want-Content-Digest and Want-Repr-Digest fields allow endpoints to express interest in Content-Digest and Repr-Digest respectively, and to express algorithm preferences in either.
</p>

<p>
［
`Content-Digest$h ／ `Repr-Digest$h
］を総称して，
`完全性~field@
（ `Integrity field^en ）という。
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］を総称して，
`完全性~選好~field@
（ `Integrity preference field^en ）という。
◎
Content-Digest and Repr-Digest are collectively termed Integrity fields. Want-Content-Digest and Want-Repr-Digest are collectively termed Integrity preference fields.
</p>

<p>
`完全性~field$の計算は、［
`Content-Encoding$h, `Content-Type$h
］~headerに束ねられる。
したがって、所与の`資源$が~HTTPで転送されるとき，複数個の異なる~digest値があり得る。
◎
Integrity fields are tied to the Content-Encoding and Content-Type header fields. Therefore, a given resource may have multiple different digest values when transferred with HTTP.
</p>

<p>
`完全性~field$は、
~HTTP［
`内容$／`表現$
］に適用され，~HTTP［
`~message$／`~field$
］には適用されない。
しかしながら，それは、
~HTTP交換に欲される各部を［
一体として／各部ごとに
］保護するためとして，［
~metadataを保護する他の仕組み
］を成す各~相
— ~digital署名など —
と組合できる。
例えば、
`~HTTP~message署名^cite `SIGNATURES$r を利用して，
`完全性~field$を署名する
— したがって，［
`内容$／`表現~data$
］用に~~保険をかける —
こともできる。
◎
Integrity fields apply to HTTP message content or HTTP representations. They do not apply to HTTP messages or fields. However, they can be combined with other mechanisms that protect metadata, such as digital signatures, in order to protect the phases of an HTTP exchange in whole or in part. For example, HTTP Message Signatures [SIGNATURES] could be used to sign Integrity fields, thus providing coverage for HTTP content or representation data.
</p>

<p>
この仕様は、［
認証／権限付与／~privacy
］用の手段は定義しない。
◎
This specification does not define means for authentication, authorization, or privacy.
</p>

		</section>
		<section id="obsolete-3230">
<h3 title="Obsoleting RFC 3230">1.3. ~RFC 3230 の廃用~化</h3>

<p>
`RFC3230$r は
~HTTP完全性~用に 2 つの~field
— `Digest^h, `Want-Digest^h —
を定義した。
それはまた、今や［
~HTTP意味論として，もっと普遍的に定義され, 実装された概念
］
— `選定された表現~data$など —
を説明するために，用語［
“~instance”, “~instance操作”
］も新造した。
◎
[RFC3230] defined the Digest and Want-Digest HTTP fields for HTTP integrity. It also coined the term "instance" and "instance manipulation" in order to explain concepts that are now more universally defined, and implemented, as HTTP semantics such as selected representation data (Section 8.1 of [HTTP]).
</p>

<p>
`RFC3230$r の実装は、
“~instance” の意味をどう解釈するか一貫性がなかったため，相互運用能の課題へ至らすことが経験から示された。
最も共通的な課題は、
~digestを計算する際に
— 元々意図された，`表現~data$（と今や称されるもの）ではなく —
~messageの`内容$（と今や称されるもの）を利用するものと誤解していたことに関係する。
興味深いことに、
時を経て，`内容$の~digestも 一部の利用-事例では有益になることも示された。
なので、
`RFC3230$r に適合しないことが意図的かそうでないのか検出するのは，困難である。
◎
Experience has shown that implementations of [RFC3230] have interpreted the meaning of "instance" inconsistently, leading to interoperability issues. The most common issue relates to the mistake of calculating the digest using (what we now call) message content, rather than using (what we now call) representation data as was originally intended. Interestingly, time has also shown that a digest of message content can be beneficial for some use cases. So it is difficult to detect if non-conformance to [RFC3230] is intentional or unintentional.
</p>

<p>
［
`Digest^h ／ `Want-Digest^h
］の各~実装にまたがる非-一貫性と多義性に取組むため、
この文書は， `RFC3230$r を廃用する。
この文書にて定義される各種［
`完全性~field$（ `2§, `3§ ）／
`完全性~選好~field$（ `4§ ）
］は、
現在の~HTTP意味論にもっと良く倣うようにされ，
意図される用法を もっと明瞭に表すよう命名された。
◎
In order to address potential inconsistencies and ambiguity across implementations of Digest and Want-Digest, this document obsoletes [RFC3230]. The Integrity fields (Sections 2 and 3) and Integrity preference fields (Section 4) defined in this document are better aligned with current HTTP semantics and have names that more clearly articulate the intended usages.
</p>

		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.4. 表記規約</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
この文書は、
`RFC5234$r に定義され，
`RFC7405$r にて更新された~ABNFを利用する。
これには、
規則［
`CR$P,
`LF$P,
`CRLF$P
］も含まれる。
◎
This document uses the Augmented BNF defined in [RFC5234] and updated by [RFC7405]. This includes the rules: CR (carriage return), LF (line feed), and CRLF (CR LF).
</p>

<p>
この文書は、
構文と構文解析-法を指定するため，
次に挙げる型を利用する【！terminology from Section 3 of】
`STRUCTURED-FIELDS$r
⇒＃
`~sf真偽値$,
`~sf~byte列$,
`~sf辞書$,
`~sf整数$,
`~sf~list$
◎
This document uses the following terminology from Section 3 of [STRUCTURED-FIELDS] to specify syntax and parsing: Boolean, Byte Sequence, Dictionary, Integer, and List.
</p>

<p>
この文書における次に挙げる用語は、
`HTTP$r に述べられるとおりに解釈すること
⇒＃
`表現$,
`選定される表現$,
`表現~data$,
`表現~metadata$,
`~UA$,
`内容$
◎
The definitions "representation", "selected representation", "representation data", "representation metadata", "user agent", and "content" in this document are to be interpreted as described in [HTTP].
</p>

<p class="trans-note">【
用語
`選定された表現~data@
（ `selected representation data^en ）も［
`選定された表現$の`表現~data$
］の略記として利用される。
】</p>

<p id="SBS-ST">
この文書は、
`FOLDING$r にて述べられる行l折返し法を利用する†。
◎
This document uses the line folding strategies described in [FOLDING].
</p>

<p class="trans-note">【†
一部の~code例の最初の行lに出現する `~SBS-ST^c により指示される。
それは、
`FOLDING$r `7＠~RFCx/rfc8792#section-7§ に則って［
長過ぎる行lが折返されたことを指示するためとして、
行lの末尾に "`\^c" が利用されている
］ことを表す
（それら
（ "`NOTE:…^c" および "`\^c" （と後続する改行文字, 字下げ））
は、
当の~codeの一部を成さない）。
】</p>

<p>
`~hashing~algo$の名前は、
それらを定義する文書に利用される文字大小-法を尊重する
（例： `SHA-1$i, `CRC32c$i ）。
◎
Hashing algorithm names respect the casing used in their definition document (e.g., SHA-1, CRC32c).
</p>

<p>
~HTTP`~message$は、
`~algo~key$を利用して，`~hashing~algo$を指示する。
文書の注釈文において`~algo~key$を指す所では、
引用符で括られる
（例： "`sha$c", "`crc32c$c" ）。
◎
HTTP messages indicate hashing algorithms using an Algorithm Key (algorithms). Where the document refers to an Algorithm Key in prose, it is quoted (e.g., "sha", "crc32c").
</p>

<p>
用語
`~checksum^dfn
は、
~byte列に ある~algoを適用した結果の出力を述べる。
一方で，用語
`~digest^dfn
は、
【~checksumと同様であるが，】
当の`~field$に包含される値に関係する所に限り利用される。
◎
The term "checksum" describes the output of the application of an algorithm to a sequence of bytes, whereas "digest" is only used in relation to the value contained in the fields.
</p>

<p>
用語 `完全性~field$は、［
`Content-Digest$h ／ `Repr-Digest$h
］の総称である。
◎
Integrity fields: collective term for Content-Digest and Repr-Digest
</p>

<p>
用語 `完全性~選好~field$は、［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］の総称である。
◎
Integrity preference fields: collective term for Want-Repr-Digest and Want-Content-Digest
</p>

		</section>
	</section>
	<section id="content-digest">
<h2 title="The Content-Digest Field">2. `Content-Digest^h ~field</h2>

<p>
`Content-Digest^h `~field$は、
要請, 応答どちらにも利用でき，
実際の`内容$に`~hashing~algo$を適用して計算された~digestを通信する。
◎
The Content-Digest HTTP field can be used in requests and responses to communicate digests that are calculated using a hashing algorithm applied to the actual message content (see Section 6.4 of [HTTP]).＼
</p>

<p>
`Content-Digest^h は、
`有構造~field$であり，`~sf辞書$を値にとる
— 各~memberの：
◎
It is a Dictionary (see Section 3.2 of [STRUCTURED-FIELDS]) where each:
</p>
<ul>
	<li>
~keyは、
当の~digestを算出するときに利用された`~hashing~algo$を伝達する
（ `5§ を見よ）。
◎
key conveys the hashing algorithm (see Section 5) used to compute the digest;
</li>
	<li>
値は、
`~sf~byte列$であり，［
~digest計算により生産された~byte出力
］を符号化した~versionを伝達する。
◎
value is a Byte Sequence (Section 3.3.5 of [STRUCTURED-FIELDS]), that conveys an encoded version of the byte output produced by the digest calculation.
</li>
</ul>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
`~SBS-ST$

Content-Digest: \
  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\
  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:
</pre>
</div>

<p>
この`~sf辞書$型を利用すれば、
例えば，能力が［
相異なる／発展している
］様々な端点を~supportするために［
異なる`~hashing~algo$を利用して計算された，複数の~digest
］を添えれる。
そのような~approachは、
より弱い~algoから離れるよう移行tすることも~supportし得る
（ `6.6§ を見よ）。
◎
The Dictionary type can be used, for example, to attach multiple digests calculated using different hashing algorithms in order to support a population of endpoints with different or evolving capabilities. Such an approach could support transitions away from weaker algorithms (see Section 6.6).
</p>

<div class="example">
<pre class="lang-http">
`~SBS-ST$

Content-Digest: \
  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:,\
  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\
  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:
</pre>
</div>

<p>
`受信者$は、
受信した各~digestに対し，どれを無視してもヨイ。
応用に特有な挙動や局所的な施策は、
伝達された~digestの処理や検証の実施に対し，追加的な拘束を設定してもヨイ。
~securityの考慮点は、［
~digestを無視すること／複数の~digestを検証すること
］に関係する課題のうち一部を受持つ
（［
`6.6§ ／ `6.7§
］を見よ）。
◎
A recipient MAY ignore any or all digests. Application-specific behavior or local policy MAY set additional constraints on the processing and validation practices of the conveyed digests. The security considerations covers some of the issues related to ignoring digests (see Section 6.6) and validating multiple digests (see Section 6.7).
</p>

<p>
`送信者$は、
~digestを
— `受信者$が所与の`~hashing~algo$を［
~supportする／無視することになる
］かどうか知ることなく —
送信してもヨイ。
◎
A sender MAY send a digest without knowing whether the recipient supports a given hashing algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Content-Digest^h は、
`~trailer節$内にも送信できる。
この事例では、
`Content-Digest^h は`~header節$の中へ併合してもヨイ
— `HTTP$r `~trailerの利用に対する制限＠~HTTPinfra#trailers.limitations§を見よ。
◎
Content-Digest can be sent in a trailer section. In this case, Content-Digest MAY be merged into the header section; see Section 6.5.1 of [HTTP].
</p>

	</section>
	<section id="representation-digest">
<h2 title="The Repr-Digest Field">3. `Repr-Digest^h ~field</h2>

<p>
`Repr-Digest^h `~field$は、
要請, 応答どちらにも利用でき，
`選定された表現~data$全体に`~hashing~algo$を適用して計算された~digestを通信する。
【 "Repr" は `Representation^en（表現）の略称。】
◎
The Repr-Digest HTTP field can be used in requests and responses to communicate digests that are calculated using a hashing algorithm applied to the entire selected representation data (see Section 8.1 of [HTTP]).
</p>

<p>
`表現$は、
~messageに対する~HTTP意味論の効果も織り込む。
例えば、
`内容$は，［
`範囲~要請$／ `HEAD$m などの~method
］により影響され得ることに加え、
内容が “伝送路” 上で転送される仕方は，他の`形式変換$に依存する
（例： ~HTTP11用の`転送~符号法$
— `HTTP/1.1$r `Transfer-Encoding§h を見よ）。
`A§ にて、
`表現$の概念を~~説明する例がいくつか供される。
◎
Representations take into account the effect of the HTTP semantics on messages. For example, the content can be affected by Range Requests or methods such as HEAD, while the way the content is transferred "on the wire" is dependent on other transformations (e.g., transfer codings for HTTP/1.1 - see Section 6.1 of [HTTP/1.1]). To help illustrate HTTP representation concepts, several examples are provided in Appendix A.
</p>

<p>
~messageに`表現~data$が無いときでも、
空~文字列から~digestを算出して，［
`表現~data$は送信されなかったことを表明する
］ことはアリである
（ `6.3§ を見よ）。
◎
When a message has no representation data it is still possible to assert that no representation data was sent by computing the digest on an empty string (see Section 6.3).
</p>

<p>
`Repr-Digest^h は、
`有構造~field$であり，`~sf辞書$を値にとる
— 各~memberの：
◎
Repr-Digest is a Dictionary (see Section 3.2 of [STRUCTURED-FIELDS]) where each:
</p>
<ul>
	<li>
~keyは、
当の~digestを算出するときに利用した`~hashing~algo$を伝達する
（ `5§ を見よ）。
◎
key conveys the hashing algorithm (see Section 5) used to compute the digest;
</li>
	<li>
値は、
`~sf~byte列$であり，［
~digest計算により生産された~byte出力
］を符号化した~versionを伝達する。
◎
value is a Byte Sequence, that conveys an encoded version of the byte output produced by the digest calculation.
</li>
</ul>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
`~SBS-ST$

Repr-Digest: \
  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\
  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:
</pre>
</div>

<p>
この`~sf辞書$型を利用すれば、
例えば，能力が［
相異なる／発展している
］様々な端点を~supportするために［
異なる`~hashing~algo$を利用して計算された，複数の~digest
］を添えれる。
そのような~approachは、
より弱い~algoから離れるよう移行tすることも~supportし得る
（ `6.6§ を見よ）。
◎
The Dictionary type can be used, for example, to attach multiple digests calculated using different hashing algorithms in order to support a population of endpoints with different or evolving capabilities. Such an approach could support transitions away from weaker algorithms (see Section 6.6).
</p>

<div class="example">
<pre class="lang-http">
`~SBS-ST$

Repr-Digest: \
  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:,\
  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\
  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:
</pre>
</div>

<p>
`受信者$は、
受信した各~digestに対し，どれを無視してもヨイ。
応用に特有な挙動や局所的な施策は、
伝達された~digestの処理や検証の実施に対し，追加的な拘束を設定してもヨイ。
~securityの考慮点は、［
~digestを無視すること／複数の~digestを検証すること
］に関係する課題のうち一部を受持つ
（［
`6.6§ ／ `6.7§
］を見よ）。
◎
A recipient MAY ignore any or all digests. Application-specific behavior or local policy MAY set additional constraints on the processing and validation practices of the conveyed digests. The security considerations covers some of the issues related to ignoring digests (see Section 6.6) and validating multiple digests (see Section 6.7).
</p>

<p>
`送信者$は、
~digestを
— `受信者$が所与の`~hashing~algo$を［
~supportする／無視することになる
］かどうか知ることなく —
送信してもヨイ。
◎
A sender MAY send a digest without knowing whether the recipient supports a given hashing algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Repr-Digest^h は、
`~trailer節$内にも送信できる。
この事例では、
`Repr-Digest^h を`~header節$の中へ併合してもヨイ
— `HTTP$r `~trailerの利用に対する制限＠~HTTPinfra#trailers.limitations§を見よ。
◎
Repr-Digest can be sent in a trailer section. In this case, Repr-Digest MAY be merged into the header section; see Section 6.5.1 of [HTTP].
</p>

		<section id="state-changing-requests">
<h3 title="Using Repr-Digest in State-Changing Requests">3.1. 状態変更~要請における `Repr-Digest^h の利用-法</h3>

<p>
状態変更~要請~内に同封された表現が`~target資源$を述べるものでないときは、
表現~digestは，`表現~data$から算出されなければナラナイ。
これは、唯一アリな選択になる
— 表現~digestは、完全な`表現~metadata$を要求するので
（ `3§ を見よ）。
◎
When the representation enclosed in a state-changing request does not describe the target resource, the representation digest MUST be computed on the representation data. This is the only possible choice because representation digest requires complete representation metadata (see Section 3).
</p>

<p>
応答においては：
◎
In responses,
</p>
<ul>
	<li>
当の`表現$が要請の状態sを述べる場合、
`Repr-Digest$h は，同封された`表現$から算出されなければナラナイ
（ `B.8§ を見よ）
◎
if the representation describes the status of the request, Repr-Digest MUST be computed on the enclosed representation (see Appendix B.8);
</li>
	<li>
参照-先の`資源$が在る場合、
`Repr-Digest$h は，その資源に`選定される表現$から算出されなければナラナイ
— それが当の`~target資源$と異なっていようが。
`Repr-Digest$h は、
同封された`表現$から算出された結果であることも，
そうでないこともある。
◎
if there is a referenced resource Repr-Digest MUST be computed on the selected representation of the referenced resource even if that is different from the target resource. That might or might not result in computing Repr-Digest on the enclosed representation.
</li>
</ul>

<p>
後者の事例は、
所与の`~method$の意味論に則って行われる
— 例えば， `Content-Location$h ~header `HTTP$r を利用して。
対照的に，
`Location$h ~headerは、
`表現~metadata$ではないので，
`Repr-Digest$h には影響しない。
◎
The latter case is done according to the HTTP semantics of the given method, for example using the Content-Location header field (see Section 8.7 of [HTTP]). In contrast, the Location header field does not affect Repr-Digest because it is not representation metadata.
</p>

<p>
例えば `PATCH$m 要請においては、
表現~digestは~patch文書から算出されることになる
— `表現~metadata$は、
`~target資源$ではなく，~patch文書を指すので
（ `PATCH$r `PATCH§m を見よ）。
対する応答においては、
表現~digestは，代わりに~patchされた`資源$用に`選定された表現$から算出されることになる。
◎
For example, in PATCH requests, the representation digest will be computed on the patch document because the representation metadata refers to the patch document and not to the target resource (see Section 2 of [PATCH]). In responses, instead, the representation digest will be computed on the selected representation of the patched resource.
</p>

		</section>
		<section id="digest-and-content-location">
<h3 title="Repr-Digest and Content-Location in Responses">3.2. 応答~内の `Repr-Digest^h と `Content-Location^h</h3>

<p>
ある状態変更~methodに対する応答が `Content-Location$h ~headerを返すとき、
応答に同封された表現は，その`~field値$により識別される`資源$を指す
— `Repr-Digest$h はそれに則って算出される。
その例は `B.7§ にて与える。
◎
When a state-changing method returns the Content-Location header field, the enclosed representation refers to the resource identified by its value and Repr-Digest is computed accordingly. An example is given in Appendix B.7.
</p>

		</section>
	</section>
	<section id="want-fields">
<h2 title="Integrity preference fields">4. 完全性~選好~field</h2>

<p>
`送信者$は、［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］~fieldを利用して，自身による［
`完全性~field$への関心, `~hashing~algo$の選好
］を指示できる。
両~fieldとも、
要請, 応答どちらにも利用できる。
◎
Senders can indicate their interest in Integrity fields and hashing algorithm preferences using the Want-Content-Digest or Want-Repr-Digest fields. These can be used in both requests and responses.
</p>

<p>
`Want-Content-Digest^h ~fieldは、
次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，［
`Content-Digest$h ~fieldを利用している内容~digest
］を受信したいと願っている。
◎
Want-Content-Digest indicates that the sender would like to receive a content digest on messages associated with the request URI and representation metadata, using the Content-Digest field.
</p>

<p>
`Want-Repr-Digest^h ~fieldは、
次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，［
`Repr-Digest$h ~fieldを利用している表現~digest
］を受信したいと願っている。
◎
Want-Repr-Digest indicates that the sender would like to receive a representation digest on messages associated with the request URI and representation metadata, using the Repr-Digest field.
</p>

<p>
［
`Want-Content-Digest^h ／ `Want-Repr-Digest^h
］が応答~内に利用された場合、
次を指示する
⇒
`~server$は、［
`~client$が，対応する`完全性~field$を未来の要請にて供する
］よう願っている。
◎
If Want-Content-Digest or Want-Repr-Digest are used in a response, it indicates that the server would like the client to provide the respective Integrity field on future requests.
</p>

<p>
`完全性~選好~field$は、
~hintでしかない。
当の~fieldの`受信者$は、
それを無視でき，［
他の何らかの~algoを利用している`完全性~選好~field$を送信する／
`完全性~選好~field$を まるごと省略する
］こともできる。
例えば， `C.2§ を見よ。
選好が無視されたとしても，~protocol~errorではない。
［
`完全性~field$を利用する応用／
完全性に関する選好
］は、
この仕様に加えて運用する［
期待／拘束
］を定義し得る。
選好が無視される懸念は、
応用に特有である。
◎
Integrity preference fields are only a hint. The receiver of the field can ignore it and send an Integrity field using any algorithm or omit the field entirely, for example see Appendix C.2. It is not a protocol error if preferences are ignored. Applications that use Integrity fields and Integrity preferences can define expectations or constraints that operate in addition to this specification. Ignored preferences are an application-specific concern.
</p>

<p>
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］は、
`有構造~field$であり，`~sf辞書$を値にとる
— 各~memberの：
◎
Want-Content-Digest and Want-Repr-Digest are of type Dictionary where each:
</p>
<ul>
	<li>
~keyは、
当の`~hashing~algo$を伝達する。
◎
key conveys the hashing algorithm (see Section 5);
</li>
	<li>
値は、
`~sf整数$をとり，
【~keyに指示された~hashing~algoの】選好~度を伝達する。
値は、
範囲 { 0 〜 10 } に入らなければナラナイ。
各~memberのうち，値が大きいものほど選好されるが、
値 0 は “受容-可能でない” ことを意味する。
◎
value is an Integer (Section 3.3.1 of [STRUCTURED-FIELDS]) that conveys an ascending, relative, weighted preference. It must be in the range 0 to 10 inclusive. 1 is the least preferred, 10 is the most preferred, and a value of 0 means "not acceptable".
</li>
</ul>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
Want-Repr-Digest: sha-256=1
Want-Repr-Digest: sha-512=3, sha-256=10, unixsum=0
Want-Content-Digest: sha-256=1
Want-Content-Digest: sha-512=3, sha-256=10, unixsum=0
</pre>
</div>

	</section>
	<section id="algorithms">
<h2 title="Hash Algorithm Considerations and Registration">5. ~hash~algoの考慮点と登録</h2>

<p>
完全性の目的に利用できる~hashing~algoには、
多様なものがある。
~algoの選択は、
次に挙げるものなど，いくつかの要因に依存する
⇒＃
完全性の利用-事例／
実装における必要性や拘束／
応用の設計と~workflow
◎
There are a wide variety of hashing algorithms that can be used for the purposes of integrity. The choice of algorithm depends on several factors such as the integrity use case, implementation needs or constraints, or application design and workflows.
</p>

<p>
~algoたちが成す初期~集合は、
~IANAにおいて
`~HTTP~digest~field用~hash~algo~registry$cite
内に登録されることになる
— `7.2§を見よ。
追加的な~algoは、
この節にて設けられる施策に則って登録できる。
◎
An initial set of algorithms will be registered with IANA in the "Hash Algorithms for HTTP Digest Fields" registry; see Section 7.2. Additional algorithms can be registered in accordance with the policies set out in this section.
</p>

<p>
各~algoには、
`位置付け$がある
— それは、
実装における選定を援助することが意図される。
◎
Each algorithm has a status field, which is intended to provide an aid to implementation selection.
</p>

<p>
`位置付け$ `標準^i を伴う~algoは、
多くの目的に相応しくなる
— 応用には、
これらの~algoを利用することが`推奨される^2119。
これらは、
敵対者に~~晒される状況にも利用できる
— そこでは、
~hash関数は，［
衝突~攻撃, 第一-原像~攻撃, 第二-原像~攻撃
］に対する耐性を供する必要があるかもしれない。
そのような状況において， `標準^i を伴う~algoのうち どれを選定することが受容-可能かは、
当の状況下で~~必要とされる保護~levelに依存することになる。
さらなる考慮点は、
`6.6§ にて呈示される。
◎
Algorithms with a status value of "standard" are suitable for many purposes and it is RECOMMENDED that applications use these algorithms. These can be used in adversarial situations where hash functions might need to provide resistance to collision, first-preimage and second-preimage attacks. For adversarial situations, selecting which of the "standard" algorithms are acceptable will depend on the level of protection the circumstances demand. More considerations are presented in Section 6.6.
</p>

<p>
`位置付け$ `非~secure^i を伴う~algoは、
これらの特質を何も供さないか，弱いことが既知である
（ `NO-MD5$r, `NO-SHA$r を見よ）。
これらの~algoは，破損に抗する完全性を保全するためとして利用してもヨイが、
敵対者に~~晒され得る設定においては，利用してはナラナイ
— 例えば、
真正性を得るために`完全性~field$の値を署名するとき。
これらの~algoの利用を許可することは、
一部の応用には助けになることもある
— 例えば、
それまで `RFC3230$r を利用していた応用を，この仕様へ移行するとき（ `E§ ）／
既存の［
算出された~digest値たちが成す格納-済みな~collection
］を［
より~secureな他の~algoを利用して算出し直すこと
］により必要以上に演算~上の~overheadを~~被ることを避けるため。
そのような応用であっても，この節の要件は免除されない。
さらには、
そのような［
旧来のもの／歴史
］を伴わない応用は，
`位置付け$ `標準^i を伴う~algoを利用するための指導に従う~OUGHT。
◎
Algorithms with a status value of "insecure" either provide none of these properties, or are known to be weak (see [NO-MD5] and [NO-SHA]). These algorithms MAY be used to preserve integrity against corruption, but MUST NOT be used in a potentially adversarial setting; for example, when signing Integrity fields' values for authenticity. Permitting the use of these algorithms can help some applications, for example, those that previously used [RFC3230], are migrating to this specification (Appendix E), and have existing stored collections of computed digest values avoid undue operational overhead caused by recomputation using other more-secure algorithms. Such applications are not exempt from the requirements in this section. Furthermore, applications without such legacy or history ought to follow the guidance for using algorithms with the status value "standard".
</p>

<p>
~algo即応性の論点は、
`6.6§ にて呈示される。
◎
Discussion of algorithm agility is presented in Section 6.6.
</p>

<p>
`~HTTP~digest~field用~hash~algo~registry$cite
用の登録~要請は、
“仕様が要求される” とする施策（ `8126/4.6$rfc ）を利用する。
要請は、
次の雛形を利用するべきである：
◎
Registration requests for the "Hash Algorithms for HTTP Digest Fields" registry use the Specification Required policy (Section 4.6 of [RFC8126]). Requests should use the following template:
</p>
<ul>
	<li>
`~algo~key@
（ `Algorithm Key^en ）
⇒
次に挙げる`有構造~field$において，
`~sf辞書$を成す各~memberの~keyとして利用される値
⇒＃
`Content-Digest$h,
`Repr-Digest$h,
`Want-Content-Digest$h
`Want-Repr-Digest$h
◎
Algorithm Key: the Structured Fields key value used in Content-Digest, Repr-Digest, Want-Content-Digest, or Want-Repr-Digest field Dictionary member keys
</li>
	<li>
<p>
`位置付け@
（ `Status^en ）
⇒
当の~algoの位置付け
— 次に挙げるいずれかとする：
◎
Status: the status of the algorithm. The options are:
</p>
		<ul>
			<li>
`標準^i（ `standard^en ）
⇒
標準~化され，既知な問題を伴わない~algo用
◎
"standard" - for standardized algorithms without known problems,
</li>
			<li>
`暫定的^i
⇒
［
標準でない／【~secureかどうか】立証されてない
］~algo用
◎
"provisional" - for non-standard or unproven algorithms,
</li>
			<li>
`非~secure^i （ `insecure^en ）
⇒
~secureでない~algo用
◎
"insecure" - for insecure algorithms,
</li>
		</ul>
	</li>
	<li>
記述
（ `Description^en ）
⇒
当の~algoについての短い記述
◎
Description: a short description of the algorithm
</li>
	<li>
参照
（ `Reference(s)^en ）
⇒
次を定義している首な文書~群への~pointer
⇒＃
当の~algoの~key／
当の~algoの技術的な詳細
◎
Reference(s): pointer(s) to the primary document(s) defining the Algorithm Key and technical details of the algorithm
</li>
</ul>

<p>
指名された専門家（たち）は，
登録~要請を考査する際には、
要請された`位置付け$に注意を払うべきである。
`位置付け$は、
標準~化の状態sおよび［
関連な関心~group
— ~IETF／~securityに関係する標準開発組織など —
からの広範な見解
］を反映するべきである。
`位置付け$ `標準^i は、［
弱い／破られた（ `broken^en ）／試験的である
］ことが既知な~algoには，相応でない。
登録~要請が，そのような~algoを `標準^i として登録しようと試みた場合、
指名された専門家（たち）は，代替な`位置付け$
— `非~secure^i か `暫定的^i —
を示唆するべきである。
◎
When reviewing registration requests, the designated expert(s) should pay attention to the requested status. The status value should reflect standardization status and the broad opinion of relevant interest groups such as the IETF or security-related SDOs. The "standard" status is not suitable for an algorithm that is known to be weak, broken, or experimental. If a registration request attempts to register such an algorithm as "standard", the designated expert(s) should suggest an alternative status of "insecure" or "provisional".
</p>

<p>
指名された専門家（たち）は，
登録~要請を考査する際には、
却下の~~根拠として，`位置付け$［
`非~secure^i ／ `暫定的^i
］を利用することはできない。
◎
When reviewing registration requests, the designated expert(s) cannot use a status of "insecure" or "provisional" as grounds for rejection.
</p>

<p>
既存の登録~内の~fieldを［
更新する／変更する
］要請は許可される。
例えば、
~algoの`位置付け$を［
~security環境が発展するに伴い，
`標準^i から `非~secure^i へ移行tする
］ことも許容され得る。
◎
Requests to update or change the fields in an existing registration are permitted. For example, this could allow for the transition of an algorithm status from "standard" to "insecure" as the security environment evolves.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">6. ~securityの考慮点</h2>

		<section id="sec-limitations">
<h3 title="HTTP Messages Are Not Protected In Full">6.1. ~HTTP~messageは全部的には保護されない</h3>

<p>
この文書は、
ある~data完全性の仕組みを指定する。
それは、
~HTTP［
`表現~data$／`内容$
］を保護するが，~HTTP［
~headerや~trailer
］を ある種の破損から保護するものではない。
◎
This document specifies a data integrity mechanism that protects HTTP representation data or content, but not HTTP header and trailer fields, from certain kinds of corruption.
</p>

<p>
`完全性~field$には、［
~HTTP~messageに対する悪意的な改ざんに抗する一般的な保護
］は意図されない。
追加的な~securityの仕組みが無い下では、
経路上の悪意的な動作者は，~digest値を［
除去して／計算し直して
］代用し得る。
この攻撃は、
この文書にて述べた仕組みを他の~approach
— ~transport層の~securityや~digital署名など
（例えば `~HTTP~message署名^cite `SIGNATURES$r ） —
と組合せることにより，軽減できる。
◎
Integrity fields are not intended to be a general protection against malicious tampering with HTTP messages. In the absence of additional security mechanisms, an on-path, malicious actor can remove or recalculate and substitute a digest value. This attack can be mitigated by combining mechanisms described in this document with other approaches such as transport-layer security or digital signatures (for example, HTTP Message Signatures [SIGNATURES]).
</p>

		</section>
		<section id="end-to-end-integrity">
<h3 title="End-to-End Integrity">6.2. 端点間の完全性</h3>

<p>
`完全性~field$は［
実装~error／
欲されない`形式変換ng~proxy$ `HTTP$r ／
~dataが いくつかの［
中継点／~system境界
］を通過するときに伴われる他の動作
］に因る`表現~metadata$の改変を検出する助けになり得る。
［
`端点間$における［
`表現~data$／`内容$
］の完全性
］用の単純な仕組みであっても，価値はある
— ~UAは、［
~HTML構文解析器や動画~再生器, 等々
］に構文解析~用に手渡す前に，資源の検索取得に成功したことを検証できるので。
◎
Integrity fields can help detect representation data or content modification due to implementation errors, undesired "transforming proxies" (see Section 7.7 of [HTTP]) or other actions as the data passes across multiple hops or system boundaries. Even a simple mechanism for end-to-end representation data integrity is valuable because a user agent can validate that resource retrieval succeeded before handing off to an HTML parser, video player etc. for parsing.
</p>

<p>
これらの仕組みだけを利用しても，`端点間$における~HTTP~message【全体】の完全性は
— 中継点を経ている場合には —
供さないことに注意
— その~metadataは、どの段階でも操作され得るので。
~metadataを保護する手法は、
`6.3§ にて論じられる。
◎
Note that using these mechanisms alone does not provide end-to-end integrity of HTTP messages over multiple hops, since metadata could be manipulated at any stage. Methods to protect metadata are discussed in Section 6.3.
</p>

		</section>
		<section id="usage-in-signatures">
<h3 title="Usage in Signatures">6.3. 署名における用法</h3>

<p>
~digital署名は、
ある種の［
~messageの出自を識別するもの
］を供するためとして，
~checksumと一緒に広く利用される
`NIST800-32$r
。
そのような署名は、
1 個以上の`~field$を保護し得る
— それらに`完全性~field$も含まれるときには、
追加的な考慮点がある。
◎
Digital signatures are widely used together with checksums to provide the certain identification of the origin of a message [NIST800-32]. Such signatures can protect one or more HTTP fields and there are additional considerations when Integrity fields are included in this set.
</p>

<p>
`完全性~field$と伴に利用できる~digital署名の［
型／形式
］に設置される制約は無い。
アリな~approachの一つは、
それらを `~HTTP~message署名^cite `SIGNATURES$r と組合せることである。
◎
There are no restrictions placed on the type or format of digital signature that Integrity fields can be used with. One possible approach is to combine them with HTTP Message Signatures [SIGNATURES].
</p>

<p>
~digestは、
`表現~metadata$
（例：`Content-Type$h, `Content-Encoding$h, 等々の値）
に明示的に依存する。
`完全性~field$は保護しつつ他の`表現~metadata$は保護しない署名は、
当の通信を改ざんに晒し得る。
例えば，ある動作者は、
`Content-Type$h `~field値$を操作して，
`受信者$における~digest検証を失敗に至らすこともでき、
当の応用が`表現$へ~accessするのを防止する。
そのような攻撃は、
両~端点の資源を消費する。
`3.2§ も見よ。
◎
Digests explicitly depend on the "representation metadata" (e.g., the values of Content-Type, Content-Encoding etc.). A signature that protects Integrity fields but not other "representation metadata" can expose the communication to tampering. For example, an actor could manipulate the Content-Type field-value and cause a digest validation failure at the recipient, preventing the application from accessing the representation. Such an attack consumes the resources of both endpoints. See also Section 3.2.
</p>

<p>
署名は、
`完全性~field$を適用するときに，敵対者に~~晒される見込みが高いと判断される
— `5§ を見よ。
`Repr-Digest$h は、
署名と組合されたときに，興味深いアリ性を提供する。
送信する`内容$が無い局面では，
当の~message内に空~文字列の~digestを内包でき、
署名された場合は，受信者が［
内容が何らかの［
事故，あるいは目的をもった操作
］による結果として追加されたか否か
］を検出する助けになり得る。
反対の局面も~supportされる
— 内容~用の`完全性~field$を内包して，それを署名すれば、
受信者が［
当の内容が，どこで除去されたか
］を検出する助けになり得る。
◎
Signatures are likely to be deemed an adversarial setting when applying Integrity fields; see Section 5. Repr-Digest offers an interesting possibility when combined with signatures. In the scenario where there is no content to send, the digest of an empty string can be included in the message and, if signed, can help the recipient detect if content was added either as a result of accident or purposeful manipulation. The opposite scenario is also supported; including an Integrity field for content, and signing it, can help a recipient detect where the content was removed.
</p>

<p>
`完全性~field$を弄ることは、
署名の検証に影響するかもしれない
— 例：
重複している`~field行l値$を除去する【！de-duplication】 ／
複数個の`~field行l値$を`結合-$するなど
（ `HTTP$r `~field行lと結合-済みな~field値＠~HTTPinfra#field.lines§を見よ）。
◎
Any mangling of Integrity fields, including digests' de-duplication or combining different field values (see Section 5.2 of [HTTP]) might affect signature validation.
</p>

		</section>
		<section id="usage-in-trailer-fields">
<h3 title="Usage in Trailer Fields">6.4. ~trailerにおける用法</h3>

<p>
`送信者$は、
`~trailer節$内に`完全性~field$を送信する前に，次について考慮するべきである
⇒
`中継者$には、
どの`~trailer$も落とすことが明示的に許容されている
（ `HTTP$r `~trailerの処理＠~HTTPinfra#trailers.processing§を見よ）。
◎
Before sending Integrity fields in a trailer section, the sender should consider that intermediaries are explicitly allowed to drop any trailer (see Section 6.5.2 of [HTTP]).
</p>

<p>
`完全性~field$が`~trailer節$内で利用される場合、
その`~field値$は，`内容$より後に受信される。
`~trailer節$より前に内容の処理を急ぐと，~digestは検証できなくなり、
場合によっては，無効な~dataの処理に至らせ得る。
◎
When Integrity fields are used in a trailer section, the field-values are received after the content. Eager processing of content before the trailer section prevents digest validation, possibly leading to processing of invalid data.
</p>

<p>
`完全性~field$を`~trailer節$内で利用することには、
~byte列を送信するたびに，その~hashingを許容する便益がある。
しかしながら、
`~hashing~algo$は，［
この便益を否定する仕方で内容を処理すること
］を要求するよう設計することもアリである。
例えば， `I-D.thomson-http-mice$r は、
内容を逆順に処理するよう要求する。
すなわち，完全な~dataが予め可用になる必要があり、
`完全性~field$を［
`~header節$内, `~trailer節$内
］どちらで送信しても，その処理にたいした相違は無いことを意味する。
◎
One of the benefits of using Integrity fields in a trailer section is that it allows hashing of bytes as they are sent. However, it is possible to design a hashing algorithm that requires processing of content in such a way that would negate these benefits. For example, Merkle Integrity Content Encoding [I-D.thomson-http-mice] requires content to be processed in reverse order. This means the complete data needs to be available, which means there is negligible processing difference in sending an Integrity field in a header or trailer section.
</p>

		</section>
		<section id="variations-within-content-encoding">
<h3 title="Variations Within Content Encoding">6.5. 内容~符号化法の中の多様性</h3>

<p>
`内容~符号法$の仕組みは、
様々な符号化~parameterを~supportし得る
— すなわち、
同じ入力~内容から生産される出力は，~parameterに応じて異なり得る。
例えば、
~GZIPは，複数の圧縮~levelを~supportする。
そのような符号化~parameterは、
一般に，`表現~metadata$としては通信されない。
一例として、
異なる圧縮~levelは，どれも
同じ "`Content-Encoding: gzip^c" ~fieldを利用することになろう。
他の例として、
~nonceや時刻印に依拠する符号化法も挙げられる
— `RFC8188$r にて定義される `aes128gcm^c `内容~符号法$など。
◎
Content coding mechanisms can support different encoding parameters, meaning that the same input content can produce different outputs. For example, GZIP supports multiple compression levels. Such encoding parameters are generally not communicated as representation metadata. For instance, different compression levels would all use the same "Content-Encoding: gzip" field. Other examples include where encoding relies on nonces or timestamps, such as the aes128gcm content coding defined in [RFC8188].
</p>

<p>
同じ`内容~符号法$の中にも多様性があり得るので、
完全性~fieldにより伝達される~checksumは，
“残りの部分（ `at rest^en ）” 【？】における完全性の証明も供するためには利用し得ない
— 当の`内容$が一体として持続されない限り。
◎
Since it is possible for there to be variation within content coding, the checksum conveyed by the integrity fields cannot be used to provide a proof of integrity "at rest" unless the whole content is persisted.
</p>

		</section>
		<section id="sec-agility">
<h3 title="Algorithm Agility">6.6. ~algo即応性</h3>

<p>
`~hashing~algo$の~securityの特質は、
固定的でない【時を経れば変化し得る】。
`~algo即応性^cite（ `Algorithm Agility^en, `RFC7696$r ）は、［
`~hashing~algo$を［
`~HTTP~digest~field用~hash~algo~registry$cite（ `7.2§ ）
］から選ぶ柔軟性
］を備える実装を供することにより達成される。
◎
The security properties of hashing algorithms are not fixed. Algorithm Agility (see [RFC7696]) is achieved by providing implementations with flexibility to choose hashing algorithms from the IANA Hash Algorithms for HTTP Digest Fields registry; see Section 7.2.
</p>

<p>
弱い~algoからの移行tは、［
`~hashing~algo$を［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］を利用して折衝する／
複数個の~digestを送信して，その中から`受信者$【！receiver】に選んでもらう
］ことにより~supportされる。
とは言え，資源を消費して複数個の値を送信しても、
`受信者$【！receiver】から無視された場合には，浪費されることになる
（ `3§ を見よ）。
~security用に~digestに依存する`受信者$【！receiver】は、［
自身が受容する用意がある~algoのうち最も弱いもの
］に対する攻撃に対し脆弱になる。
◎
Transition from weak algorithms is supported by negotiation of hashing algorithm using Want-Content-Digest or Want-Repr-Digest (see Section 4) or by sending multiple digests from which the receiver chooses. A receiver that depends on a digest for security will be vulnerable to attacks on the weakest algorithm it is willing to accept. Endpoints are advised that sending multiple values consumes resources, which may be wasted if the receiver ignores them (see Section 3).
</p>

<p>
~algo即応性は、
より強い~algoへの移行を許容する一方で，より弱い~algoの利用を防止しない。
`完全性~field$は、
`~hashing~algo$の［
降格~攻撃／代用~攻撃
］（`6211/1$rfc を見よ）に対しては，いかなる軽減策も供さない。
端点は、
そのような攻撃に抗して保護するためとして，［
自身が~supportする~algoの集合を より強いものに制約して、
~TLSや~digital署名を利用することにより~field値を保護する
］こともできる。
◎
While algorithm agility allows the migration to stronger algorithms it does not prevent the use of weaker algorithms. Integrity fields do not provide any mitigations for downgrade or substitution attacks (see Section 1 of [RFC6211]) of the hashing algorithm. To protect against such attacks, endpoints could restrict their set of supported algorithms to stronger ones and protect the fields value by using TLS and/or digital signatures.
</p>

		</section>
		<section id="sec-exhaustion">
<h3 title="Resource exhaustion">6.7. 資源の枯渇</h3>

<p>
`完全性~field$の検証は、計算l資源を消費する。
実装は、
資源の枯渇を避けるためとして，［
~algoの種別, 検証の回数, `内容$の~size
］の検証を制約できる。
これらの事例では、
より選好される~algoの［
検証をまるごと飛ばす／
検証における失敗を無視する
］と，降格~攻撃のアリ性を残すことになる
（ `6.6§ を見よ）。
◎
Integrity fields validation consumes computational resources. In order to avoid resource exhaustion, implementations can restrict validation of the algorithm types, number of validations, or the size of content. In these cases, skipping validation entirely or ignoring validation failure of a more-preferred algorithm leaves the possibility of a downgrade attack (see Section 6.6).
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">7. ~IANA考慮点</h2>

		<section id="http-field-name-registration">
<h3 title="HTTP Field Name Registration">7.1. ~HTTP~field名の登録</h3>

<p>
~IANAには、
下の表に則って，
`~HTTP~field名~registry＠~IANA-a/http-fields$cite `HTTP$r を更新するよう依頼される：
◎
IANA is asked to update the "Hypertext Transfer Protocol (HTTP) Field Name Registry" registry ([HTTP]) according to the table below:
</p>

<div>
<table id="table-1">
<caption>表 1</caption>
<thead>
<tr><th>`~field名$
<th>位置付け
<th>参照
<tbody>

<tr><td>`Content-Digest$h
<td>`恒久的^i
<td>この文書の `2§

<tr><td>`Repr-Digest$h
<td>`恒久的^i
<td>この文書の `3§

<tr><td>`Want-Content-Digest$h
<td>`恒久的^i
<td>この文書の `4§

<tr><td>`Want-Repr-Digest$h
<td>`恒久的^i
<td>この文書の `4§

<tr><td>`Digest$h
<td>`廃用d^i
<td>`RFC3230$r, この文書の `1.3§

<tr><td>`Want-Digest$h
<td>`廃用d^i
<td>`RFC3230$r, この文書の `1.3§
</table>
◎
Table 1
◎
Field Name｜Status｜Reference
Content-Digest｜permanent｜Section 2 of this document
Repr-Digest｜permanent｜Section 3 of this document
Want-Content-Digest｜permanent｜Section 4 of this document
Want-Repr-Digest｜permanent｜Section 4 of this document
Digest｜obsoleted｜[RFC3230], Section 1.3 of this document
Want-Digest｜obsoleted｜[RFC3230], Section 1.3 of this document
</div>

		</section>
		<section id="establish-hash-algorithm-registry">
<h3 title="Establish the Hash Algorithms for HTTP Digest Fields Registry">7.2. ~HTTP~digest~field用~hash~algo~registryを確立する</h3>

<p>
~IANAには、
新たな
`~HTTP~digest~field用~hash~algo~registry@cite
を作成して†，それを
`次の表＠#iana-hash-algorithm-table$内の~entryで拡充するよう要請される。
新たな登録~用の手続-は、
`5§にて供される。
◎
IANA is requested to create the new "Hash Algorithms for HTTP Digest Fields" registry at https://www.iana.org/assignments/http-digest-hash-alg/ and populate it with the entries in Table 2. The procedure for new registrations is provided in Section 5.
</p>

<p class="trans-note">【†
~IANA-a/http-digest-hash-alg/
にて可用になる予定にある。
】</p>

<div>
<table id="_hash-algorithm-table" class="grid-table">
<caption id="iana-hash-algorithm-table">
表 2
— 初期~hash~algo
</caption>
<thead>
<tr><th>`~algo~key$
<th>`位置付け$
<th>記述
<th>参照
<tbody>

<tr><td>`sha-512@c
<td>`標準^i
<td>`SHA-512^i ~algo。
<td>
`RFC6234$r, `RFC4648$r, この文書

<tr><td>`sha-256@c
<td>`標準^i
<td>`SHA-256^i ~algo。
<td>
`RFC6234$r, `RFC4648$r, この文書

<tr><td>`md5@c
<td>`非~secure^i
<td>`MD5^i ~algo。
これは、衝突~攻撃に脆弱である
— `NO-MD5$r, `CMU-836068$r を見よ。
<td>
`RFC1321$r, `RFC4648$r, この文書

<tr><td>`sha@c
<td>`非~secure^i
<td>`SHA-1^i ~algo。
これは、衝突~攻撃に脆弱である
— `NO-SHA$r, `IACR-2020-014$r を見よ
<td>
`RFC3174$r, `RFC4648$r, `RFC6234$r この文書

<tr><td>`unixsum@c
<td>`非~secure^i
<td>~UNIX "sum" ~commandに利用される~algo。
<td>
`RFC4648$r, `RFC6234$r, `UNIX$r, この文書

<tr><td>`unixcksum@c
<td>`非~secure^i
<td>~UNIX "cksum" ~commandに利用される~algo。
<td>
`RFC4648$r, `RFC6234$r, `UNIX$r, この文書

<tr><td>`adler@c
<td>`非~secure^i
<td>`ADLER32^i ~algo。
<td>
`RFC1950$r, この文書

<tr><td>`crc32c@c
<td>`非~secure^i
<td>`CRC32c^i ~algo。
<td>
`RFC9260$r 付録 A, この文書
</table>

◎
Table 2: Initial Hash Algorithms Algorithms
◎
Algorithm Key｜Status｜Description｜Reference(s)
sha-512｜standard｜The SHA-512 algorithm.｜[RFC6234], [RFC4648], this document.
sha-256｜standard｜The SHA-256 algorithm.｜[RFC6234], [RFC4648], this document.
md5｜insecure｜The MD5 algorithm. It is vulnerable to collision attacks; see [NO-MD5] and [CMU-836068]｜[RFC1321], [RFC4648], this document.
sha｜insecure｜The SHA-1 algorithm. It is vulnerable to collision attacks; see [NO-SHA] and [IACR-2020-014]｜[RFC3174], [RFC4648], [RFC6234] this document.
unixsum｜insecure｜The algorithm used by the UNIX "sum" command.｜[RFC4648], [RFC6234], [UNIX], this document.
unixcksum｜insecure｜The algorithm used by the UNIX "cksum" command.｜[RFC4648], [RFC6234], [UNIX], this document.
adler｜insecure｜The ADLER32 algorithm.｜[RFC1950], this document.
crc32c｜insecure｜The CRC32c algorithm.｜[RFC9260] appendix A, this document.
</div>

		</section>
		<section id="deprecate-the-hypertext-transfer-protocol-http-digest-algorithm-values-registry">
<h3 title="Deprecate the Hypertext Transfer Protocol (HTTP) Digest Algorithm Values Registry">7.3. `~HTTP~digest~algo値~registry^cite を非推奨にする</h3>

<p>
~IANAには、
`~HTTP~digest~algo値~registry＠~IANA-a/http-dig-alg/$cite
を非推奨にして，この~registryに対する注記を次の~textに置換するよう要請される
⇒
<q>
この~registryは非推奨にされた。
それは， `RFC3230$r 【！https://www.iana.org/】にて定義された［
`Digest$h, `Want-Digest$h
］~fieldと伴に利用し得る~algoを~listするが、
それらの~fieldは，
`RFC<var>この文書にあてがわれることになる~RFC番号</var>^r
により廃用にされたので。
登録は，まだ閉鎖されないが、
新たな登録は，代わりに
`~HTTP~digest~field用~hash~algo~registry$cite
【！ ↑↑https://www.iana.org/assignments/http-digest-hash-alg/】
を利用することが奨励される。
</q>
◎
IANA is requested to deprecate the "Hypertext Transfer Protocol (HTTP) Digest Algorithm Values" registry at https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml and replace the note on this registry with the following text:
◎
"This registry is deprecated since it lists the algorithms that can be used with the Digest and Want-Digest fields defined in [RFC3230]https://www.iana.org/, which has been obsoleted by [rfc-to-be-this-document]. While registration is not closed, new registrations are encouraged to use the [Hash Algorithms for HTTP Digest Fields]https://www.iana.org/assignments/http-digest-hash-alg/ registry instead.
</p>

		</section>
	</section>
	<section id="resource-representation">
<h2 title="Appendix A. Resource Representation and Representation Data">付録 A. 資源~表現と表現~data</h2>

<p>
この節において以下に挙げる例は、［
`表現~metadata$, `内容$の`形式変換$, `~method$
］が~messageと`内容$にどう影響iするかを示す。
これらの例は、
網羅的ではない。
◎
This section following examples show how representation metadata, content transformations, and method impacts on the message and content. These examples a not exhaustive.
</p>

<p>
他が指示されない限り、
以下に挙げる各~例は，［
~JSON~obj `{"hello": "world"}^c と後続する 1 個の `LF$P
］に基づく。
以下において，`内容$が印字不能な文字を包含するときは
（例：符号化されたとき）、
~hexに符号化された~byte列として示される。
◎
Unless otherwise indicated, the examples are based on the JSON object {"hello": "world"} followed by an LF. When the content contains non-printable characters (e.g., when it is encoded) it is shown as a sequence of hex-encoded bytes.
</p>

<div class="example">
<figure id="name-request-containing-a-json-o">
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Length: 19

{"hello": "world"}
</pre>
<figcaption>
`内容~符号法$を伴わない~JSON~objを伴う要請
◎
Figure 1: Request containing a JSON object without any content coding
</figcaption></figure>
</div>

<p>
しかしながら、
`内容~符号法$の利用は，かなり共通的にある。
~clientは、
同じ~dataを `gzip$c 符号法 `HTTP$r【！§ 8.4.1.3】 で~uploadすることもできる。
この事例では、
当の符号法の~overheadに因り，
`Content-Length$h が包含する値は大きくなることに注意。
◎
However, the use of content coding is quite common. The client could also upload the same data with a gzip coding (Section 8.4.1.3 of [HTTP]). Note that in this case, the Content-Length contains a larger value due to the coding overheads.
</p>

<div class="example">
<figure id="name-request-containing-a-gzip-e">
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Encoding: gzip
Content-Length: 39

1F 8B 08 00 88 41 37 64 00 FF
AB 56 CA 48 CD C9 C9 57 B2 52
50 2A CF 2F CA 49 51 AA E5 02
00 D9 E4 31 E7 13 00 00 00
</pre>
<figcaption>
`gzip$c で符号化された~JSON~objを包含している要請
◎
Figure 2: Request containing a gzip-encoded JSON object
</figcaption></figure>
</div>

<p>
`gzip$c で有符号化された~dataを `Content-Encoding$h を介して指示することなく送信することは、
当の内容は不正形であることを意味する。
この事例では、
`~server$は~errorで返信できる。
◎
Sending the gzip coded data without indicating it via Content-Encoding means that the content is malformed. In this case, the server can reply with an error.
</p>

<div class="example">
<figure id="name-request-containing-malforme">
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Length: 39

1F 8B 08 00 88 41 37 64 00 FF
AB 56 CA 48 CD C9 C9 57 B2 52
50 2A CF 2F CA 49 51 AA E5 02
00 D9 E4 31 E7 13 00 00 00
</pre>
<figcaption>
不正形な~JSONを包含している要請
◎
Figure 3: Request containing malformed JSON
</figcaption></figure>

<figure id="name-an-error-response-for-a-mal">
<pre class="lang-http">
HTTP/1.1 400 Bad Request
</pre>
<figcaption>
不正形な内容に対する~error応答
◎
Figure 4: An error response for a malformed content
</figcaption></figure>
</div>

<p>
`範囲~要請$は、
転送される`内容$に影響する。
次の例では、
`~client$は，
`/entries/1234^c に在る`資源$
— ~JSON~obj `{"hello": "world"}^c と後続する 1 個の `LF$P —
に~accessしているが、
選好される`内容~符号法$と特定の~byte範囲も指示した。
◎
A Range-Request affects the transferred message content. In this example, the client is accessing the resource at /entries/1234, which is the JSON object {"hello": "world"} followed by an LF. However, the client has indicated a preferred content coding and a specific byte range.
</p>

<div class="example">
<figure id="name-request-for-partial-content">
<pre class="lang-http">
GET /entries/1234 HTTP/1.1
Host: foo.example
Accept-Encoding: gzip
Range: bytes=1-7
</pre>
<figcaption>
部分的な内容に対する要請
◎
Figure 5: Request for partial content
</figcaption></figure>
</div>

<p>
対して`~server$は、
（`上の 2 個目の例＠#name-request-containing-a-gzip-e$にて全体が表示された~JSON~objを成す最初の 10 ~byteに等価な）
部分的な表現で応答することにより，
~client要請を満足する。
◎
The server satisfies the client request by responding with a partial representation (equivalent to the first 10 of the JSON object displayed in whole in Figure 2).
</p>

<div class="example">
<figure id="name-partial-response-from-a-gzi">
<pre class="lang-http">
HTTP/1.1 206 Partial Content
Content-Encoding: gzip
Content-Type: application/json
Content-Range: bytes 0-9/39

1F 8B 08 00 A5 B4 BD 62 02 FF
</pre>
<figcaption>
`gzip$c で符号化された表現からの`部分的な応答$
◎
Figure 6: Partial response from a gzip-encoded representation
</figcaption></figure>
</div>

<p>
［
`内容~符号法$／`範囲~要請$
］は別として、
~methodは，転送される`内容$に影響することもある。
例えば， `HEAD$m 要請に対する応答は`内容$を運ばないが、
この例の事例では，
`Content-Length$h `HTTP$r【！§ 8.6】 を内包する。
◎
Aside from content coding or range requests, the method can also affect the transferred message content. For example, the response to a HEAD request does not carry content but in this example case does include a Content-Length; see Section 8.6 of [HTTP].
</p>

<div class="example">
<figure id="name-head-request">
<pre class="lang-http">
HEAD /entries/1234 HTTP/1.1
Host: foo.example
Accept: application/json
Accept-Encoding: gzip

</pre>
<figcaption>
`HEAD$m 要請
◎
Figure 7: HEAD request
</figcaption></figure>

<figure id="name-response-to-head-request-em">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: gzip
Content-Length: 39

</pre>
<figcaption>
対する応答は、
`内容$を伴わない
◎
Figure 8: Response to HEAD request (empty content)
</figcaption></figure>
</div>

<p>
応答の意味論は、
`~target~URI$を同封された表現から切り離すかもしれない。
次の例では、
`~client$は，
`/authors/^c へ~directされる `POST$m 要請を発行するが、
対する応答は，
`Content-Location$h ~headerを内包していて［
同封された表現は、
`/authors/123^c にて可用な資源を指す
］ことを指示する。
この例では、
`Content-Length$h は送信されないことに注意。
◎
Finally, the semantics of a response might decouple the target URI from the enclosed representation. In the example below, the client issues a POST request directed to /authors/ but the response includes a Content-Location header field that indicates the enclosed representation refers to the resource available at /authors/123. Note that Content-Length is not sent in this example.
</p>

<div class="example">
<figure id="name-post-request">
<pre class="lang-http">
POST /authors/ HTTP/1.1
Host: foo.example
Accept: application/json
Content-Type: application/json

{"author": "Camilleri"}
</pre>
<figcaption>
`POST$m 要請
◎
Figure 9: POST request
</figcaption></figure>

<figure id="name-response-with-content-locat">
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /authors/123
Location: /authors/123

{"id": "123", "author": "Camilleri"}
</pre>
<figcaption>
`Content-Location$h ~headerを伴う応答
◎
Figure 10: Response with Content-Location header
</figcaption></figure>
</div>

	</section>
	<section id="examples-unsolicited">
<h2 title="Appendix B. Examples of Unsolicited Digest">付録 B. 請求されない~digestの例</h2>

<p>
以下に挙げる例は、
`~client$が［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］を利用するよう請求しなかったときでも，
`~server$が［
`Content-Digest$h ／ `Repr-Digest$h
］~fieldで応答するときのヤリトリをデモる。
◎
The following examples demonstrate interactions where a server responds with a Content-Digest or Repr-Digest fields even though the client did not solicit one using Want-Content-Digest or Want-Repr-Digest.
</p>

<p>
例のうちいくつかは、
`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaces of leading indentation.
</p>

<p>
この文書にて定義される~checksumの仕組みは、
`~MIME型$を問わないことに加え，特定の形式~用の正準-化~algoは供さない。
各~例は、【対象の~data内の】
~spaceも含めて計算される。
［
`Content-Digest$h, `Repr-Digest$h
］両~fieldを含む例もあるが、
これらは，独立に返され得る。
◎
Checksum mechanisms defined in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space. While examples can include both fields, Content-Digest and Repr-Digest can be returned independently.
</p>

		<section id="example-full-representation">
<h3 title="Server Returns Full Representation Data">B.1. ~serverは全部的な表現~dataを返す例</h3>

<p>
この例では、
~messageの`内容$は完全な`表現~data$を伝達する。
すなわち，応答~内の［
`Content-Digest$h, `Repr-Digest$h
］は、
どちらも［
~JSON~obj `{"hello": "world"}^c と後続する 1 個の `LF$P
］から計算されるので，同じ値をとる。
◎
In this example, the message content conveys complete representation data. This means that in the response, Content-Digest and Repr-Digest are both computed over the JSON object {"hello": "world"} followed by an LF, and thus have the same value.
</p>

<div class="example">
<figure id="figure-name-get-request-for-an-item">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example

</pre>
<figcaption>
ある~itemに対する `GET$m 要請
◎
Figure 11: GET request for an item
</figcaption></figure>

<figure id="figure-name-response-with-identical-rep">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 19
Content-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
互いに一致する［
`Content-Digest$h, `Repr-Digest$h
］を伴う
◎
Figure 12: Response with identical Repr-Digest and Content-Digest
</figcaption></figure>
</div>

		</section>
		<section id="server-returns-no-representation-data">
<h3 title="Server Returns No Representation Data">B.2. ~serverは表現~dataを返さない例</h3>

<p>
この例では、
`HEAD$m 要請を利用して`資源$の~checksumを検索取得する。
◎
In this example, a HEAD request is used to retrieve the checksum of a resource.
</p>

<p>
対する応答の `Content-Digest$h は、
空な`内容$に対し算出される。
`Repr-Digest$h は，［
~JSON~obj `{"hello": "world"}^c と後続する 1 個の `LF$P
］から計算されるが、
応答の`内容$は無いので，当の~JSON~objは そこには示されない。
◎
The response Content-Digest field-value is computed on empty content. Repr-Digest is calculated over the JSON object {"hello": "world"} followed by an LF, which is not shown because there is no content.
</p>

<div class="example">
<figure id="figure-name-head-request-for-an-item">
<pre class="lang-http">
HEAD /items/123 HTTP/1.1
Host: foo.example

</pre>
<figcaption>
ある~itemに対する `HEAD$m 要請
◎
Figure 13: HEAD request for an item
</figcaption></figure>

<figure id="figure-name-response-with-both-content-">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Digest: \
  sha-256=:47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=:
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:
</pre>
<figcaption>
対する応答は、
`Content-Digest$h, `Repr-Digest$h 両者を伴うが，`内容$は伴わない
◎
Figure 14: Response with both Content-Digest and Digest; empty content
</figcaption></figure>
</div>

		</section>
		<section id="server-returns-partial-representation-data">
<h3 title="Server Returns Partial Representation Data">B.3. ~serverは部分的な表現~dataを返す例</h3>

<p>
この例では、
`~client$は、`範囲~要請$を為す
— 対して`~server$は、
部分的な内容で応答する。
◎
In this example, the client makes a range request and the server responds with partial content.
</p>

<div class="example">
<figure id="figure-name-request-for-partial-content-2">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Range: bytes=10-18

</pre>
<figcaption>
部分的な内容に対する要請
◎
Figure 15: Request for partial content
</figcaption></figure>

<figure id="figure-name-partial-response-with-both-">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 206 Partial Content
Content-Type: application/json
Content-Range: bytes 10-18/19
Content-Digest: \
  sha-256=:jjcgBDWNAtbYUXI37CVG3gRuGOAjaaDRGpIUFsdyepQ=:
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:

"world"}
</pre>
<figcaption>
`Content-Digest$h, `Repr-Digest$h 両者を伴う`部分的な応答$
◎
Figure 16: Partial response with both Content-Digest and Repr-Digest
</figcaption></figure>
</div>

<p>
上の応答~messageにおける［
`Content-Digest$h, `Repr-Digest$h
］は、
異なることに注意：
◎
In the response message above, note that the Repr-Digest and Content-Digests are different.＼
</p>
<ul>
	<li>
`Repr-Digest$h の`~field値$は、［
~JSON~obj全体 `{"hello": "world"}^c と後続する 1 個の `LF$P
］から計算される
⇒
`sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:^c
◎
The Repr-Digest field-value is calculated across the entire JSON object {"hello": "world"} followed by an LF, and the field is
◎
NOTE: '\' line wrapping per RFC 8792

Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:
</li>
	<li>
一方で， `Content-Digest$h の`~field値$は、［
当の~messageの`内容$は、
`bytes 10-18^c
【 0 から数えて 10 番 から 18 番までの`~byte範囲$】
に拘束される
］ので，［
~byte列 `"world"}^c と後続する 1 個の `LF$P
］から計算される
⇒
`sha-256=:jjcgBDWNAtbYUXI37CVG3gRuGOAjaaDRGpIUFsdyepQ=:^c
◎
However, since the message content is constrained to bytes 10-18, the Content-Digest field-value is calculated over the sequence "world"} followed by an LF, thus resulting in

◎
NOTE: '\' line wrapping per RFC 8792

Content-Digest: \
  sha-256=:jjcgBDWNAtbYUXI37CVG3gRuGOAjaaDRGpIUFsdyepQ=:
</li>
</ul>

		</section>
		<section id="client-and-server-provide-full-representation-data">
<h3 title="Client and Server Provide Full Representation Data">B.4. ~client, ~serverどちらも全部的な表現~dataを供する例</h3>

<p>
要請は、同封された表現から計算された `Repr-Digest$h `~field値$を包含する。
また，`~client$は、
当の要請に値 `br^c を伴う `Accept-Encoding$h ~headerを内包して，
`Brotli^i 符号化法を~supportすることを広告する。
◎
The request contains a Repr-Digest field-value calculated on the enclosed representation. It also includes an Accept-Encoding: br header field that advertises the client supports Brotli encoding.
</p>

<p>
対する応答は、
値 `br^c を伴う `Content-Encoding$h ~headerを内包する
— それは、`選定された表現$は `Brotli^i に符号化されたことを指示する。
したがって `Repr-Digest$h `~field値$は，要請のそれとは異なる。
◎
The response includes a Content-Encoding: br that indicates the selected representation is Brotli-encoded. The Repr-Digest field-value is therefore different compared to the request.
</p>

<p>
応答の`内容$は、
印字不能な文字を包含するので，
呈示~目的においては
~hexに符号化された~byte列として表示される。
◎
For presentation purposes, the response body is displayed as a sequence of hex-encoded bytes because it contains non-printable characters.
</p>

<div class="example">
<figure id="figure-name-put-request-with-digest">
<pre class="lang-http">
`~SBS-ST$

PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=:

{"hello": "world"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `PUT$m 要請
◎
Figure 17: PUT Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-enc">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Location: /items/123
Content-Encoding: br
Content-Length: 23
Repr-Digest: \
  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:

8B 08 80 7B 22 68 65 6C 6C 6F
22 3A 20 22 77 6F 72 6C 64 22
7D 0A 03
</pre>
<figcaption>
対する応答は、
符号化された内容【！応答】の `Repr-Digest$h を伴う
◎
Figure 18: Response with Digest of encoded response
</figcaption></figure>
</div>

		</section>
		<section id="client-provides-full-representation-data-server-provides-no-representation-data">
<h3 title="Client Provides Full Representation Data, Server Provides No Representation Data">B.5. ~clientは全部的な表現~dataを供する, ~serverは表現~dataを供さない例</h3>

<p>
要請の `Repr-Digest$h `~field値$は、
同封された`内容$
— ~JSON~obj `{"hello": "world"}^c と後続する 1 個の `LF$P —
から計算される。
◎
The request Repr-Digest field-value is calculated on the enclosed content, which is the JSON object {"hello": "world"} followed by an LF
</p>

<p>
対する応答の `Repr-Digest$h `~field値$は、
応答が`内容$を包含しないときでも，`表現~header$【！表現~metadata~header】に依存する
— この例では、［
値 `br^c を伴う `Content-Encoding$h ~header
］もそれに含まれる。
◎
The response Repr-Digest field-value depends on the representation metadata header fields, including Content-Encoding: br even when the response does not contain content.
</p>

<div class="example">
<figure>
<pre class="lang-http">
`~SBS-ST$

PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Length: 19
Accept-Encoding: br
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:

{"hello": "world"}
</pre>
<figcaption>
内容の `Repr-Digest$h を伴う要請
◎
</figcaption></figure>

<figure id="figure-name-empty-response-with-digest">
<pre class="lang-http">
HTTP/1.1 204 No Content
Content-Type: application/json
Content-Encoding: br
Repr-Digest: sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:

</pre>
<figcaption>
対する応答は、
`Repr-Digest$h を伴うが，内容は伴わない
◎
Figure 19: Empty response with Digest
</figcaption></figure>
</div>

		</section>
		<section id="client-and-server-provide-full-representation-data-1">
<h3 title="Client and Server Provide Full Representation Data">B.6. ~client, ~serverどちらも全部的な表現~dataを供する例</h3>

<p>
応答は、
異なる~algoを利用して， 2 個の~digest値を包含する：
◎
The response contains two digest values using different algorithms.
</p>

<p>
応答の`内容$は、
印字不能な文字を包含するので，
呈示~目的においては
~hexに符号化された~byte列として表示される。
◎
For presentation purposes, the response body is displayed as a sequence of hex-encoded bytes because it contains non-printable characters.
</p>

<div class="example">
<figure id="figure-name-put-request-with-digest-2">
<pre class="lang-http">
`~SBS-ST$

PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:

{"hello": "world"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `PUT$m 要請
◎
Figure 20: PUT Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-enco">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: br
Content-Location: /items/123
Repr-Digest: \
  sha-256=:d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=:,\
  sha-512=:db7fdBbgZMgX1Wb2MjA8zZj+rSNgfmDCEEXM8qLWfpfoNY0sCpHAzZbj\
  09X1/7HAb7Od5Qfto4QpuBsFbUO3dQ==:

8B 08 80 7B 22 68 65 6C 6C 6F
22 3A 20 22 77 6F 72 6C 64 22
7D 0A 03
</pre>
<figcaption>
対する応答は、
符号化された内容の `Repr-Digest$h を伴う
◎
Figure 21: Response with Digest of Encoded Content
</figcaption></figure>
</div>

		</section>
		<section id="post-not-request-uri">
<h3 title="POST Response does not Reference the Request URI">B.7. `POST^m に対する応答は要請~URIを参照しない例</h3>

<p>
要請の `Repr-Digest$h `~field値$は、
同封された表現
— ~JSON~obj `{"title": "New Title"}^c と後続する 1 個の `LF$P —
から算出される
（ `3.1§ を見よ）。
◎
The request Repr-Digest field-value is computed on the enclosed representation (see Section 3.1), which is the JSON object {"title": "New Title"} followed by an LF.
</p>

<p>
応答~内に同封された表現は、
複数行からなる~JSON~objと後続する 1 個の `LF$P
であり，
`Content-Location$h により識別される`資源$を指す
（ `HTTP$r `内容の識別-法＠~HTTPinfra#identifying.content§を見よ）。
したがって，応用は、
`Repr-Digest$h を［
`Content-Location$h により参照された`資源$
］に結付けるよう利用できる。
◎
The representation enclosed in the response is a multiline JSON object followed by an LF. It refers to the resource identified by Content-Location (see Section 6.4.2 of [HTTP]); an application can thus use Repr-Digest in association with the resource referenced by Content-Location.
</p>

<div class="example">
<figure id="figure-name-post-request-with-digest">
<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Repr-Digest: sha-256=:mEkdbO7Srd9LIOegftO0aBX+VPTVz7/CSHes2Z27gc4=:

{"title": "New Title"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `POST$m 要請
◎
Figure 22: POST Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-res">
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /books/123
Location: /books/123
Repr-Digest: sha-256=:uVSlinTTdQUwm2On4k8TJUikGN1bf/Ds8WPX4oe0h9I=:

{
  "id": "123",
  "title": "New Title"
}
</pre>
<figcaption>
対する応答は、
資源の `Repr-Digest$h を伴う
◎
Figure 23: Response with Digest of Resource
</figcaption></figure>
</div>

		</section>
		<section id="post-referencing-status">
<h3 title="POST Response Describes the Request Status">B.8. `POST^m に対する応答は要請の状態sを述べる例</h3>

<p>
要請の `Repr-Digest$h `~field値$は、
同封された表現
— ~JSON~obj `{"title": "New Title"}^c と後続する 1 個の `LF$P —
から算出される
（ `3.1§ を見よ）。
◎
The request Repr-Digest field-value is computed on the enclosed representation (see Section 3.1), which is the JSON object {"title": "New Title"} followed by an LF.
</p>

<p>
対する応答~内に同封された`表現$は、
要請の状態sを述べるので、
`Repr-Digest$h は，その同封された表現
— 複数行からなる~JSON~objと後続する 1 個の `LF$P —
から算出される。
◎
The representation enclosed in the response describes the status of the request, so Repr-Digest is computed on that enclosed representation. It is a multiline JSON object followed by an LF.
</p>

<p>
応答の `Repr-Digest$h には、
`Location$h により参照された`資源$との明示的な関係は無い。
◎
Response Repr-Digest has no explicit relation with the resource referenced by Location.
</p>

<div class="example">
<figure id="figure-name-post-request-with-digest-2">
<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Repr-Digest: sha-256=:mEkdbO7Srd9LIOegftO0aBX+VPTVz7/CSHes2Z27gc4=:

{"title": "New Title"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `POST$m 要請
◎
Figure 24: POST Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-rep">
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Repr-Digest: sha-256=:yXIGDTN5VrfoyisKlXgRKUHHMs35SNtyC3szSz1dbO8=:
Location: /books/123

{
  "status": "created",
  "id": "123",
  "ts": 1569327729,
  "instance": "/books/123"
}
</pre>
<figcaption>
対する応答は、
表現の `Repr-Digest$h を伴う
◎
Figure 25: Response with Digest of Representation
</figcaption></figure>
</div>

		</section>
		<section id="digest-with-patch">
<h3 title="Digest with PATCH">B.9. `PATCH^m を伴う~digest</h3>

<p>
この事例は、
`~target資源$が`~target~URI$を反映する所では，
`POST$m 要請に相似的である。
◎
This case is analogous to a POST request where the target resource reflects the target URI.
</p>

<p>
`PATCH$m 要請は、
`RFC7396$r にて定義される`~MIME型$
`application/merge-patch+json^c
を利用する。
要請の`内容$が，当の~patch文書に対応する。
`Repr-Digest$h は、
その内容
— ~JSON~obj `{"title": "New Title"}^c と後続する 1 個の `LF$P —
から計算される。
◎
The PATCH request uses the application/merge-patch+json media type defined in [RFC7396]. Repr-Digest is calculated on the content, which corresponds to the patch document and is the JSON object {"title": "New Title"} followed by an LF.
</p>

<p>
対する応答の `Repr-Digest$h `~field値$は、
~patchされた`資源$の完全な表現
— 複数行からなる~JSON~objと後続する 1 個の `LF$P —
から算出される。
◎
The response Repr-Digest field-value is computed on the complete representation of the patched resource. It is a multiline JSON object followed by an LF.
</p>

<div class="example" id="fig-patch">
<figure id="name-patch-request-with-digest">
<pre class="lang-http">
PATCH /books/123 HTTP/1.1
Host: foo.example
Content-Type: application/merge-patch+json
Accept: application/json
Accept-Encoding: identity
Repr-Digest: sha-256=:mEkdbO7Srd9LIOegftO0aBX+VPTVz7/CSHes2Z27gc4=:

{"title": "New Title"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `PATCH$m 要請
◎
Figure 26: PATCH Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-repr">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Repr-Digest: sha-256=:uVSlinTTdQUwm2On4k8TJUikGN1bf/Ds8WPX4oe0h9I=:

{
  "id": "123",
  "title": "New Title"
}
</pre>
<figcaption>
対する応答は、
表現の `Repr-Digest$h を伴う。
◎
Figure 27: Response with Digest of Representation
</figcaption></figure>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、
同じ `Repr-Digest$h `~field値$を伴うなら合法的になることに注意。
その事例では、
`Content-Digest$h は，空な`内容$に対し算出した結果になろう。
◎
Note that a 204 No Content response without content but with the same Repr-Digest field-value would have been legitimate too. In that case, Content-Digest would have been computed on an empty content.
</p>

		</section>
		<section id="error-responses">
<h3 title="Error responses">B.10. ~error応答</h3>

<p>
~error応答【 `4xx$st ／ `5xx$st 】においては、
`表現~data$は`~target資源$を指すとは限らない。
代わりに，~errorの表現を指す。
◎
In error responses, the representation data does not necessarily refer to the target resource. Instead, it refers to the representation of the error.
</p>

<p>
以下の例では、`~client$は，
`/books/123^c
に所在する資源に~patchするために
`B.9§ の例【！ Figure 26】と同じ要請を送信する。
しかしながら，そこには資源は存在しなかったので、
`~server$は
— `RFC7807$r に則って —
~errorを述べる`内容$を伴う `404$st0 応答を生成する。
◎
In the following example, a client sends the same request from Figure 26 to patch the resource located at /books/123. However, the resource does not exist and the server generates a 404 response with a body that describes the error in accordance with [RFC7807].
</p>

<p>
応答の `Repr-Digest$h `~field値$は、
この同封された表現
— 複数行からなる~JSON~objと後続する 1 個の `LF$P —
から算出される。
◎
The response Repr-Digest field-value is computed on this enclosed representation. It is a multiline JSON object followed by an LF.
</p>

<div class="example">
<figure id="figure-name-response-with-digest-of-err">
<pre class="lang-http">
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
Repr-Digest: sha-256=:EXB0S2VF2H7ijkAVJkH1Sm0pBho0iDZcvVUHHXTTZSA=:

{
  "title": "Not Found",
  "detail": "Cannot PATCH a non-existent resource",
  "status": 404
}
</pre>
<figcaption>
対する応答は、
~error表現の `Repr-Digest$h を伴う
◎
Figure 28: Response with Digest of Error Representation
</figcaption></figure>
</div>

		</section>
		<section id="use-with-trailer-fields-and-transfer-coding">
<h3 title="Use with Trailer Fields and Transfer Coding">B.11. ~trailerと転送~符号法との利用</h3>

<p>
ここでは，
`生成元~server$は `Repr-Digest$h を`~trailer$として送信するので、
内容を~streamしている間に~digest値を計算でき，
したがって資源の消費を軽減する。
`Repr-Digest$h `~field値$は、
`B.1§ と同じになる
— `Repr-Digest$h は、
`転送~符号法$の利用とは独立に設計されるので
（ `3§ を見よ）。
◎
An origin server sends Repr-Digest as trailer field, so it can calculate digest-value while streaming content and thus mitigate resource consumption. The Repr-Digest field-value is the same as in Appendix B.1 because Repr-Digest is designed to be independent of the use of one or more transfer codings (see Section 3).
</p>

<p>
以下において、
応答の`内容$における文字列 "`\r\n^c" は，
`CRLF$P を表現する。
◎
In the response content below, the string "\r\n" represent the bytes CRLF.
</p>

<div class="example">
<figure id="figure-name-get-request">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example

</pre>
<figcaption>
`GET$m 要請
◎
Figure 29: GET Request
</figcaption></figure>

<figure id="figure-name-chunked-response-with-diges">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Trailer: Digest

8\r\n
{"hello"\r\n
8\r\n
: "world\r\n
3\r\n
"}\n\r\n
0\r\n
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:\r\n
</pre>
<figcaption>
`Repr-Digest$h を伴う~chunked応答
【数字は~spaceの個数を表すと思われる（実際の`内容$を成す文字ではなく）。】
◎
Figure 30: Chunked Response with Digest
</figcaption></figure>
</div>

		</section>
	</section>
	<section id="examples-solicited">
<h2 title="Appendix C. Examples of Want-Repr-Digest Solicited Digest">付録 C. `Want-Repr-Digest^h により請求される `Repr-Digest^h の例</h2>

<p>
以下に挙げる例は、
`~client$が `Want-Repr-Digest$h を利用して `Repr-Digest$h を請求するときのヤリトリをデモる。
`Content-Digest$h と `Want-Content-Digest$h の挙動は一致する。
◎
The following examples demonstrate interactions where a client solicits a Repr-Digest using Want-Repr-Digest. The behavior of Content-Digest and Want-Content-Digest is identical.
</p>

<p>
例のうちいくつかは、
`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaces of leading indentation.
</p>

<p>
この文書にて述べられる~checksumの仕組みは、
`~MIME型$を問わないことに加え，特定の形式~用の正準-化~algoは供さない。
各~例は、
~spaceも含めて計算される。
◎
Checksum mechanisms described in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space.
</p>

		<section id="server-selects-clients-least-preferred-algorithm">
<h3 title="Server Selects Client's Least Preferred Algorithm">C.1. ~serverは~clientが最も選好しない~algoを選定する例</h3>

<p>
`~client$は、
"`sha$c" を選好している~digestを要請する。
いずれにせよ、
`~server$は "`sha-256$c" で返信してもかまわない。
◎
The client requests a digest, preferring "sha". The server is free to reply with "sha-256" anyway.
</p>

<div class="example">
<figure id="figure-name-get-request-with-want-repr-">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Repr-Digest: sha-256=3, sha=10

</pre>
<figcaption>
`Want-Repr-Digest$h を伴う `GET$m 要請
◎
Figure 31: GET Request with Want-Repr-Digest
</figcaption></figure>

<figure id="figure-name-response-with-different-alg">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Repr-Digest: \
  sha-256=:RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg==:

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
異なる~algoを伴う
◎
Figure 32: Response with Different Algorithm
</figcaption></figure>
</div>

		</section>
		<section id="ex-server-selects-unsupported-algorithm">
<h3 title="Server Selects Algorithm Unsupported by Client">C.2. ~serverは~clientが~supportしない~algoを選定する例</h3>

<p>
`~client$は、
自身が唯一~supportする "`sha$c" ~digestを要請する。
`~server$は、
"`sha$c" ~digestを包含している応答を生産する~~義務はないので，
代わりに異なる~algoを利用する。
◎
The client requests a "sha" digest because that is the only algorithm it supports. The server is not obliged to produce a response containing a "sha" digest, it instead uses a different algorithm.
</p>

<div class="example">
<figure id="figure-name-get-request-with-want-repr-d">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Repr-Digest: sha=10

</pre>
<figcaption>
`Want-Repr-Digest$h を伴う `GET$m 要請
◎
Figure 33: GET Request with Want-Repr-Digest
</figcaption></figure>

<figure id="figure-name-response-with-unsupported-a">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Repr-Digest: \
  sha-512=:YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP+pgk4vf2aCs\
  yRZOtw8MjkM7iw7yZ/WkppmM44T3qg==:

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
~supportされない~algoを伴う
◎
Figure 34: Response with Unsupported Algorithm
</figcaption></figure>
</div>

		</section>
		<section id="server-does-not-support-client-algorithm-and-returns-an-error">
<h3 title="Server Does Not Support Client Algorithm and Returns an Error">C.3. ~serverは~client~algoを~supportしないので~errorを返す例</h3>

<p>
`C.2§ では、［
~clientが選好した~digest~algo
］を~serverが無視する例を与えた。
別法として，`~server$は、
要請を却下して，［
`4xx$st0 ／ `5xx$st0
］などの~error`状態s~code$を伴う応答を返すこともできる。
この仕様は、
状態s~codeの選定には何も要件を定めない
— 以下の例は、
アリな~optionの一つを示す。
◎
Appendix C.2 is an example where a server ignores the client's preferred digest algorithm. Alternatively a server can also reject the request and return a response with error status code such as 4xx or 5xx. This specification does not prescribe any requirement on status code selection; the follow example illustrates one possible option.
</p>

<p>
この例では、
`~client$は， "`sha$c" `Repr-Digest$h を要請するが，
`~server$は，問題の詳細 `RFC7807$r を伴う~errorを返す。
問題の詳細は、
~errorの`内容$に包含され，
~serverが~supportする~hashing~algoの~listを包含する。
これは純粋に例であり、
そのような内容~用の形式や要件は，この仕様では定義されない。
◎
In this example, the client requests a "sha" Repr-Digest, and the server returns an error with problem details [RFC7807] contained in the content. The problem details contain a list of the hashing algorithms that the server supports. This is purely an example, this specification does not define any format or requirements for such content.
</p>

<div class="example">
<figure id="figure-name-get-request-with-want-repr-di">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Repr-Digest: sha=10

</pre>
<figcaption>
`Want-Repr-Digest$h を伴う `GET$m 要請
◎
Figure 35: GET Request with Want-Repr-Digest
</figcaption></figure>

<figure id="figure-name-response-advertising-the-su">
<pre class="lang-http">
HTTP/1.1 400 Bad Request
Content-Type: application/problem+json

{
  "title": "Bad Request",
  "detail": "Supported hashing algorithms: sha-256, sha-512",
  "status": 400
}
</pre>
<figcaption>
対する応答は、
~supportされる~algoを広告する。
◎
Figure 36: Response advertising the supported algorithms
</figcaption></figure>
</div>

		</section>
	</section>
	<section id="sample-digest-values">
<h2 title="Appendix D. Sample Digest Values">付録 D. 見本~digest値</h2>

<p>
この節は、
各種~hashing~algoによる~digest値の例を示す。
入力~値は、
~JSON~obj `{"hello": "world"}^c である。
各~digest値は、［
入力に対し，関連な~hashing~algoを走らせた結果の出力~byte列
］を［
`STRUCTURED-FIELDS$r `§ ~sf~byte列の直列化-法＠~STRUCTURED-FIELDS#ser-binary$に従って直列化する
］ことにより生産される。
◎
This section shows examples of digest values for different hashing algorithms. The input value is the JSON object {"hello": "world"}. The digest values are each produced by running the relevant hashing algorithm over the input and running the output bytes through Byte Sequence serialization; see Section 4.1.8 of [STRUCTURED-FIELDS].
</p>

<pre>
`~SBS-ST$

sha-512 -   :WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+\
            AbwAgBWnrIiYllu7BNNyealdVLvRwEmTHWXvJwew==:

sha-256 -   :X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

md5 -       :Sd/dVLAcvNLSq16eXua5uQ==:

sha -       :07CavjDP4u3/TungoUHJO/Wzr4c=:

unixsum -   :GQU=:

unixcksum - :7zsHAA==:

adler -     :OZkGFw==:

crc32c -    :Q3lHIA==:
</pre>

	</section>
	<section id="migrating">
<h2 title="Appendix E. Migrating from RFC 3230">付録 E. ~RFC 3230 からの移行-法</h2>

<p>
~HTTP~digestは、
入力~dataに~hashing~algoを適用することにより算出される。
~RFC 3230 は、
入力~dataを~~自前の用語 “~instance” として定義した。
~instanceの概念は、
後に，~HTTPの意味論上の用語 “`表現$” に取代された。
“~instance” を`~message$の`内容$を意味すると誤解したのは、
~RFC 3230 の一部の実装と解されている。
`Digest$h ~fieldを`内容$に対し利用することは、
誤りであり，~RFC 3230 を実装する端点どうしを相互運用能の問題へ導く。
◎
HTTP digests are computed by applying a hashing algorithm to input data. RFC 3230 defined the input data as an "instance", a term it also defined. The concept of instance has since been superseded by the HTTP semantic term "representation". It is understood that some implementations of RFC 3230 mistook "instance" to mean HTTP content. Using content for the Digest field is an error that leads to interoperability problems between peers that implement RFC 3230.
</p>

<p>
~RFC 3230 は、［
~HTTPが，今や`選定された表現~data$として定義するもの
］に限り利用することを意図していた。
［
~digest, 表現
］の意味論上の概念は、
`3§ にて， `Repr-Digest^h の定義に伴って説明される。
◎
RFC 3230 was only ever intended to use what HTTP now defines as selected representation data. The semantic concept of digest and representation are explained alongside the definition of the Repr-Digest field (Section 3).
</p>

<p>
`Digest$h と `Repr-Digest$h の構文は異なるが、
この文書が `Repr-Digest$h 用に与える考慮点と一連の例は，
`Digest^h にも等しく適用される
— それらは、
同じ入力~dataに対し演算するので。
`3.1§, `6§, `6.3§ を見よ。
◎
While the syntax of Digest and Repr-Digest are different, the considerations and examples this document gives for Repr-Digest apply equally to Digest because they operate on the same input data; see Sections 3.1, 6 and 6.3.
</p>

<p>
~RFC 3230 は、
`Digest$h ~field内で`内容$の~digestも通信できるようにするものでは，決してない
— その能力は、
今や `Content-Digest$h が供する。
◎
RFC 3230 could never communicate the digest of HTTP message content in the Digest field; Content-Digest now provides that capability.
</p>

<p>
~RFC 3230 は、
`Digest$h ~fieldと伴に利用するためとして，
~algoが出力~符号化~形式も定義することを許容していた。
その結果、［
~base64, ~hex, ~decimal
］などの形式が混在していた。
［
`Content-Digest$h ／ `Repr-Digest$h
］は、
`有構造~field$を利用することから，利用する符号化~形式は一つに限られる。
更なる説明と例は、
`D§ にて供される。
◎
RFC 3230 allowed algorithms to define their output encoding format for use with the Digest field. This resulted in a mix of formats such as base64, hex or decimal. By virtue of using Structured fields, Content-Digest and Repr-Digest use only a single encoding format. Further explanation and examples are provided in Appendix D.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この文書は `RFC3230$r による案に基づく
— その偉業を成された［
`Jeff Mogul^en, `Arthur Van Hoff^en
］両氏に謝意を。
`RFC3230$r を刷新する元の案は、
`MICE^i `内容~符号法$を考査したときに［
`Mark Nottingham^en,
`Jeffrey Yasskin^en,
`Martin Thomson^en
］各氏との興味深い論点から発生した。
◎
This document is based on ideas from [RFC3230], so thanks to Jeff Mogul and Arthur Van Hoff for their great work. The original idea of refreshing RFC3230 arose from an interesting discussion with Mark Nottingham, Jeffrey Yasskin, and Martin Thomson when reviewing the MICE content coding.
</p>

<p>
この文書に価値ある貢献をなされた `Julian Reschke^en 氏に謝意を。
［
~bugを報告して／
賢い質問をして／
~textを草案~化あるいは考査して／
~open課題を評価して
］この仕様の改善に助力された，次に挙げる貢献者たちにも
⇒
`Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, Justin Richer, and Erik Wilde^en
◎
Thanks to Julian Reschke for his valuable contributions to this document, and to the following contributors that have helped improve this specification by reporting bugs, asking smart questions, drafting or reviewing text, and evaluating open issues: Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, Justin Richer, and Erik Wilde.
</p>

	</section>
	<section id="code-samples">
<h2 title="Code Samples">~code見本</h2>

<p>
`この節は、~RFCとして公表する前に除去されることになる^em。
◎
This section is to be removed before publishing as an RFC.
</p>

<p>
この節では、この文書~全体を通して各~例にて示される~digest値
— ［
~JSON~obj `{"hello": "world"}^c と後続する 1 個の `LF$P
］から算出されたそれ —
を，どう［
生成する／検証する
］かを与える。
◎
How can I generate and validate the digest values, computed over the JSON object {"hello": "world"} followed by an LF, shown in the examples throughout this document?
</p>

<p>
次の~python3~codeを利用すれば、
ある範囲の符号化法に対し，各種~SHA~algoを利用して~JSON~obj用の~digestを生成できる。
これらは、~base64形式にされることに注意。
この関数は、他の~algoに順応することもできる
— その場合、それらに特有な形式~化~規則を織り込むべきである。
◎
The following python3 code can be used to generate digests for JSON objects using SHA algorithms for a range of encodings. Note that these are formatted as base64. This function could be adapted to other algorithms and should take into account their specific formatting rules.
</p>

<div>
<pre>
import base64, json, hashlib, brotli, logging
log = logging.getLogger()

def digest_bytes(bytes_, algorithm=hashlib.sha256):
    checksum_bytes = algorithm(bytes_).digest()
    log.warning("Log bytes: \n[`%r^]", bytes_)
    return base64.encodebytes(checksum_bytes).strip()

def digest(bytes_, encoding=lambda x: x, algorithm=hashlib.sha256):
    content_encoded = encoding(bytes_)
    return digest_bytes(content_encoded, algorithm)

bytes_ = b'{"hello": "world"}\n'

print("Encoding | hashing algorithm | digest-value")
print("Identity | sha256 |", digest(bytes_))
# Encoding | hashing algorithm | digest-value
# Identity | sha256 | RK/0qy18MlBSVnWgjwz6lZEWjP/lF5HF9bvEF8FabDg=

print("Encoding | hashing algorithm | digest-value")
print("Brotli | sha256 |", digest(bytes_, encoding=brotli.compress))
# Encoding | hashing algorithm | digest-value
# Brotli | sha256 | d435Qo+nKZ+gLcUHn7GQtQ72hiBVAgqoLsZnZPiTGPk=

print("Encoding | hashing algorithm | digest-value")
print("Identity | sha512 |", digest(bytes_, algorithm=hashlib.sha512))
print("Brotli | sha512 |", digest(bytes_, algorithm=hashlib.sha512,
                                    encoding=brotli.compress))
# Encoding | hashing algorithm | digest-value
# Identity | sha512 |b'YMAam51Jz/jOATT6/zvHrLVgOYTGFy1d6GJiOHTohq4yP'
#                     '+pgk4vf2aCsyRZOtw8MjkM7iw7yZ/WkppmM44T3qg=='

# Brotli | sha512 | b'db7fdBbgZMgX1Wb2MjA8zZj+rSNgfmDCEEXM8qLWfpfoNY'
#                    '0sCpHAzZbj09X1/7HAb7Od5Qfto4QpuBsFbUO3dQ=='

</pre>
</div>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
`この節は、~RFCとして公表する前に除去されることになる^em。
【以下，この節の内容は、未訳。】
◎
This section is to be removed before publishing as an RFC.
</p>

	</section>
</main></div>

