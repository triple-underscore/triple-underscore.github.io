<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP — Digest Fields（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">

<style>
figure > pre {
	margin: 0;
}

@supports (display: grid) and (display: contents) {

#_hash-algorithm-table {
	min-width:25em;
}

#_hash-algorithm-table tr {
	grid-template-areas:
		"key 位置付け 参照"
		"key 記述 記述"
	;
	grid-template-columns: 10em 8em 1fr;
}

#_hash-algorithm-table tr > *:nth-child(1) {
	grid-area: key;
	border-left-width: 0;
}

#_hash-algorithm-table tr > *:nth-child(2) {
	grid-area: 位置付け;
}

#_hash-algorithm-table tr > *:nth-child(3) {
	grid-area: 記述;
}

#_hash-algorithm-table tr > *:nth-child(4) {
	grid-area: 参照;
}

}
</style>


<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Digest Fields
spec_date:2022-06-14
trans_update:2022-06-01
source_checked:220425
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html
abbr_url:HTTPdigest
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2021-06-15

●●class_map

●●tag_map

●●original_id_map

references:
normative:
informative:

	iana-hash-algorithm-table:name-initial-hash-algorithms

●●mdn_urls

●●link_map

h.Repr-Digest:#representation-digest
h.Content-Digest:#content-digest
h.Want-Repr-Digest:#want-fields
h.Want-Content-Digest:#want-fields
h.Digest:~RFCx/rfc3230#section-4.3.2
h.Want-Digest:~RFCx/rfc3230#section-4.3.1

c.sha-256:#digest-sha-256
	i.SHA-256:#digest-sha-256
c.sha-512:#digest-sha-512
	i.SHA-512:#digest-sha-512
c.md5:#digest-md5
	i.MD5:#digest-md5
c.sha:#digest-sha
	i.SHA:#digest-sha
i.SHA-1:#digest-sha
c.unixsum:#digest-unixsum
	i.UNIXsum:#digest-unixsum
c.unixcksum:#digest-unixcksum
	i.UNIXcksum:#digest-unixcksum
c.adler:#digest-adler
i.ADLER32:#digest-adler
c.crc32c:#digest-crc32c
i.CRC32c:#digest-crc32c

~SBS-ST:#SBS-ST

完全性~field:#integrity-field
完全性~選好~field:#integrity-preference-field

形式変換ng~proxy:~HTTPsem#transforming-proxy

有構造~field:~STRUCTURED-FIELDS#structured-field
~sf真偽値:~STRUCTURED-FIELDS#sf-boolean
~sf~list:~STRUCTURED-FIELDS#sf-list
~sf辞書:~STRUCTURED-FIELDS#sf-dictionary
~sf~byte列:~STRUCTURED-FIELDS#sf-binary
~sf整数:~STRUCTURED-FIELDS#sf-integer

cite.~HTTP~digest~field用~hash~algo~registry:~IANA-a/http-dig-alg/
	~IANA-a/http-structured-dig-alg/

~hashing~algo:#algorithms
選定された表現~data:#selected-representation-data

	●§
1:#introduction
1.1:#document-structure
1.2:#concept-overview
1.3:#obsolete-3230
1.4:#notational-conventions
2:#content-digest
3:#representation-digest
3.1:#state-changing-requests
3.2:#digest-and-content-location
4:#want-fields
5:#algorithms
6:#security
6.1:#sec-limitations
6.2:#end-to-end-integrity
6.3:#usage-in-signatures
6.4:#usage-in-trailer-fields
6.5:#usage-with-encryption
6.6:#sec-agility
6.7:#resource-exhaustion
7:#iana-considerations
7.1:#http-field-name-registration
7.2:#establish-hash-algorithm-registry

A:#resource-representation
B:#examples-unsolicited
B.1:#example-full-representation
B.2:#server-returns-no-representation-data
B.3:#server-returns-partial-representation-data
B.4:#client-and-server-provide-full-representation-data
B.5:#client-provides-full-representation-data-server-provides-no-representation-data
B.6:#client-and-server-provide-full-representation-data-1
B.7:#post-not-request-uri
B.8:#post-referencing-status
B.9:#digest-with-patch
B.10:#error-responses
B.11:#use-with-trailer-fields-and-transfer-coding
C:#examples-solicited
C.1:#server-selects-clients-least-preferred-algorithm
C.2:#ex-server-selects-unsupported-algorithm
C.3:#server-does-not-support-client-algorithm-and-returns-an-error

	:#faq
	:#acknowledgements
	:#code-samples
	:#changes
	:#authors-addresses

●●words_table1

sf:<sub>sf-</sub>
SBS-ST:NOTE: '\' line wrapping per RFC 8792

●●words_table

	●略語
UNIX:
MICE:
python3:

	●digest
base64:
SHA:
checksum::::チェックサム
digital::::デジタル
hashing::::ハッシュ化

	^i:Base64
	^i:Brotli
	^i:SHA-256
	^i:SHA-512
	^i:MD5
	^i:SHA-1
	^i:CRC32c
	^i:ADLER32
	^i:MICE

	●構文
不正形な:malformedな:不正な形の
印字不能:non-printable:~
字下げ:indentation:~

	文字大小-法:casing
	小文字:lower-case
	引用符で括られ:quote
	〜形式にされ:formatted
	形式~化:formatting
	字下げ:2 spaced of leading indentation
	重複〜を除去する:de-duplication
	急ぐ:eager

	●処理
弄る:mangleする:~
剥がさ:stripさ:~
診断:diagnosis:~

	通過する:pass across
	手渡す:handing off

	●保安
暗号用:cryptographic::~
破損:corruption:~
衝突:collision::~
耐性:resistance::~
原像:preimage::~
改ざん:tampering:~
晒し:exposeし:~
敵対者:adversary:~
	敵対者に~~晒され得る:potentially adversarial
	敵対者に~~晒される:adversarial
真正性:authenticity::~
署名-:sign::~
署名:signature::~
代用:substitution::~
出自:origin::~

	第一-:first-
	第二-:second-
	暗号化されてない:unencrypted
	抗する:against
	非~secure:insecure
	~secureでなくなる:insecure
	~secureでない:insecure
	最も弱い:weakest
	~~保険をかける:providing coverage

	●仕様
順応-:adapt:~
刷新-:refresh:~
	能が無い:inability
動作者:actor:~
概略的:brief:~
単直:straightforward:簡単
請求-:solicite:~
	請求されない:unsolicited
証明:proof:~
浪費-:waste:~
枯渇:exhaustion:~
簡潔:compact:~
発展-:evolve:~
	様々な:population of
相:phase:~
合法的:legitimate:~
偉業:great work:~
即応性:agility::~
移行:migration:~
移行-:migrate:~
移行t:transition:移行
	離れるよう移行t:transitioning away
特質:properties:~
束ねら:tieさ:~
欠陥:fault:~
倣う:alignする:~
尊重-:respect:~
発生-:arise:~
構成:structure:~
	構成:structured
助け:help:~
関心:interest:~
	興味深い:interesting
	興味深いことに:interestingly
固定的:fixed:~
指向な:-oriented:~
有用性:utility:~
普遍的:universal:~
有益:beneficial:~
廃用d:obsoleted:廃用
取代され:supersedされ:取って代わられ
誤り:error:~

	至らす:cause
	至らす:leading
	併せて:in conjunction with
	他の場面でも:Other places
	〜ないと見込まれる:less likely
	見込みが高い:likely
	基づくこと:basing
	一方では:on one hand
	十分:enough
	謝意:thank
	欲されない:undesired
	問わない:agnostic
	選ぶ:choose
	選ぶ:make a choice
	選んで:chooseして
	類の:sort of
	発生-:arose
	はず:should
	対照:contrast
	いずれにせよ:anyway
	最終的:eventual
	とても:very
	であったとしても:would have been 〜 too
	~~説明する:help illustrate
	価値はある:valuable
	価値ある:valuable
	してもかまわない:free to
	試験的^i:"experimental"
	とは言え、:Endpoints are advised that
	より低:lower
	〜できなくなる:prevents
	〜群:set of
	一覧:table
	^en:Specification Required
	参照:Reference
	賢い:smart
	質問をして:asking 〜 question
	~~義務はない:not obliged to 
	別法として:alternatively
	適用した結果:application
	関係する所:in relation to
	新造した:coined
	時を経て:time has
	と今や称されるもの:what we now call
	と総称される:collectively termed
	総称:collective
	廃用~化:obsoleting
	一貫性がなかった:inconsistently
	非-一貫性~inconsistencies
	適合しないこと:non-conformance
	かそうでないのか:unintentional
	明瞭に表す:clearly articulate
	可能性:possibility
	用意がある:willing to
	~~必要とされる:demand
	~~自前の:it also defined
	後に，has since
	に伴って:alongside
	願って:would like


	●未分類
消費:consumption::~
返信-:reply:~
再生器:player::~::プレイヤー
patch::::パッチ
計算l:computational:計算
折返され:wrapされ:折り返され
旅する:travelする:~

	改行:-
	この:the present
	添える:attach
	切り離す:decouple
	部分的にしか:fully or partially
	端点どうし:between peers

	●語形
	^r:Single UNIX Specification, version 2
	^en:Internet Assigned Numbers Authority
	^i:identity
	`~digest認証^cite:Digest Authentication
	~HTTP~field名~registry^cite:"Hypertext Transfer Protocol (HTTP) Field Name Registry"
	表現~digest:Representation Digest
	表現~data:representation-data
	範囲~要請:Range Request
	~field値:field-value
	~digest値:digest-value
	~MIME型:media-type

	●言い換え
中継点:hop::~
	いくつかの中継点を通過する:across multiple hops
	~target~URI:effective request URI
	最も選好しない:Least Preferred
	場合に備える:should
	能力はない:not capable of
	ある種の:certain kinds of
	〜からの変更点:Changes Compared to
	~transport層:transport-layer
	~message法:messaging
	予め処理する:pre-process
	内容~符号法:content-coding
	内容:payload
	内容:body
	有構造~field:Structured Fields
	~parameter化:parameterized
	参照-先の:referenced
	~base64に符号化された:base64-encoded
	符号化されていない:unencoded
	〜を含めて:inclusive
	それらに:in this set
	とは異なる:different compared to
	〜で呈示される場合もある:For presentation purposes, ...
	行l長さの~~都合により...:fit completely within the line-length limits...
	受信者:receiver
	識別するもの:identification of
	~trailer節:trailers
	段階:stage
	-:finally
	内容は伴わない:empty content
	短い:short
	選好~度:ascending, relative, weighted preference
	値が大きいものほど選好される: 〜 least preferred, 〜 most preferred
	{ 〜 }:inclusive


	●指示
	一体として:in whole
	全体:the whole
	だけ:alone
	各部:parts
	各部ごと:in part
	何も:anything
	回数:number of
	全体を通して:throughout
	0 でない:non-zero
	一部が:partly
	のうち いくつを:all, some, or none of
	またがる:across
	〜までに:extent
	各部:parts


●●ref_key_map
PATCH:RFC5789

●●ref_normative

[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
    URL: https://httpwg.org/specs/rfc9110.html
[RFC1321]
    Rivest, R., ＜The MD5 Message-Digest Algorithm＞, ~RFC1321, April 1992
[RFC1950]
    Deutsch, P. and J-L. Gailly, ＜ZLIB Compressed Data Format Specification version 3.3＞, ~RFC1950, May 1996
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC3174]
    Eastlake 3rd, D. and P. Jones, ＜US Secure Hash Algorithm 1 (SHA1)＞, ~RFC3174, September 2001
[RFC4648]
    Josefsson, S., ＜The Base16, Base32, and Base64 Data Encodings＞, ~RFC4648, October 2006
[RFC5234]
    Crocker, D., Ed. and P. Overell, ＜Augmented BNF for Syntax Specifications: ABNF＞, STD 68, ~RFC5234, January 2008
[RFC6234]
    Eastlake 3rd, D. and T. Hansen, ＜US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)＞, ~RFC6234, May 2011
[RFC7405]
    Kyzivat, P., ＜Case-Sensitive String Support in ABNF＞, ~RFC7405, December 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, ＜Guidelines for Writing an IANA Considerations Section in RFCs＞, BCP 26, ~RFC8126, June 2017
[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[STRUCTURED-FIELDS]
    Nottingham, M. and P-H. Kamp, ＜Structured Field Values for HTTP＞, ~RFC8941, February 2021

●●ref_informative

[CMU-836068]
    Carnagie Mellon University, Software Engineering Institute, ＜MD5 Vulnerable to collision attacks＞, 31 December 2008
    URL: https://www.kb.cert.org/vuls/id/836068/
[HTTP/1.1]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP/1.1＞, STD 99, ~RFC9112
    URL: https://httpwg.org/specs/rfc9112.html
[I-D.thomson-http-mice]
    Thomson, M. and J. Yasskin, ＜Merkle Integrity Content Encoding＞, Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-thomson-http-mice
[IACR-2020-014]
    Leurent, G. and T. Peyrin, ＜SHA-1 is a Shambles＞, 5 January 2020
    URL: https://eprint.iacr.org/2020/014.pdf
[NIST800-32]
    National Institute of Standards and Technology, U.S. Department of Commerce, ＜Introduction to Public Key Technology and the Federal PKI Infrastructure＞, February 2001
    URL: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-32.pdf
[NO-MD5]
    Turner, S. and L. Chen, ＜Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms＞, ~RFC6151, March 2011
[NO-SHA]
    Polk, T., Chen, L., Turner, S., and P. Hoffman, ＜Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms＞, ~RFC6194, March 2011
[PATCH]
    Dusseault, L. and J. Snell, ＜PATCH Method for HTTP＞, ~RFC5789, March 2010
[RFC3230]
    Mogul, J. and A. Van Hoff, ＜Instance Digests in HTTP＞, ~RFC3230, January 2002
[RFC6211]
    Schaad, J., ＜Cryptographic Message Syntax (CMS) Algorithm Identifier Protection Attribute＞, ~RFC6211, April 2011
[RFC7396]
    Hoffman, P. and J. Snell, ＜JSON Merge Patch＞, ~RFC7396, October 2014
[RFC7696]
    Housley, R., ＜Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms＞, BCP 201, ~RFC7696, November 2015
[RFC7807]
    Nottingham, M. and E. Wilde, ＜Problem Details for HTTP APIs＞, ~RFC7807, March 2016
[RFC9260]
    Stewart, R., Tüxen, M., and K. Nielsen, ＜Stream Control Transmission Protocol＞, ~RFC9260, June 2022
[SIGNATURES]
    Backman, A., Richer, J., and M. Sporny, ＜HTTP Message Signatures＞, Work in Progress, Internet-Draft, 26 May 2022
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures-10
[TLS]
    Rescorla, E., ＜The Transport Layer Security (TLS) Protocol Version 1.3＞, ~RFC8446, August 2018
[UNIX]
    The Open Group, ＜The Single UNIX Specification, Version 2 - 6 Vol Set for UNIX 98＞, February 1997


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公表された，
<a href="~SPEC_URL">Digest Fields</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

公表者
	<a href="https://httpwg.org/">HTTP Working Group</a>
位置付け
	Internet-Draft
廃用
	<a href="https://datatracker.ietf.org/doc/html/rfc3230">3230</a> （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	Roberto Polli, Team Digitale, Italian Government, Italy, Email: <a href="mailto:robipolli@gmail.com">robipolli@gmail.com</a>
	Lucas Pardue, Cloudflare, Email: <a href="mailto:lucaspardue.24.7@gmail.com">lucaspardue.24.7@gmail.com</a>

課題追跡
	https://github.com/httpwg/http-extensions/labels/digest-headers
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-digest-headers/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-digest-headers.md

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
現在の Internet-Draft のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>

<header>
	<hgroup>
<h1 title="Digest Fields">HTTP — ダイジェストフィールド</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section>
~ABSTRACT

<p>
この文書は、
完全性~digestを~supportする~HTTP`~field$として，次に挙げるものを定義する：
◎
This document defines HTTP fields that support integrity digests.＼
</p>
<ul>
	<li>
`Content-Digest$h ~fieldは、
~HTTP~message`内容$の完全性~用に利用できる。
◎
The Content-Digest field can be used for the integrity of HTTP message content.＼
</li>
	<li>
`Repr-Digest$h ~fieldは、
~HTTP`表現$の完全性~用に利用できる。
◎
The Repr-Digest field can be used for the integrity of HTTP representations.＼
</li>
	<li>
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］~fieldは、
`完全性~field$を受信することに関する`送信者$の［
関心と選好
］を指示するために利用できる。
◎
Want-Content-Digest and Want-Repr-Digest can be used to indicate a sender's interest and preferences for receiving the respective Integrity fields.
</li>
</ul>

<p>
この文書は、
~RFC 3230, および［
`Digest^h, `Want-Digest^h
］`~field$を廃用にする。
◎
This document obsoletes RFC 3230 and the Digest and Want-Digest HTTP fields.
</p>

	</section>
	<section>
<h2 title="About This Document">この文書について</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#about-this-draft$に移譲。
】</p>

<!-- 
Source for this draft and an issue tracker can be found at https://github.com/httpwg/http-extensions/labels/digest-headers.
 -->

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTPは、［
`内容$／`表現$
］を成す~dataの完全性を保護するための手段は定義しない。
~HTTP`~message$が端点~間で転送されるとき、
より低~層な特能や特質
— ~TCP~checksumや~TLS~record `TLS$r など —
は，何らかの完全性~保護を供し得る。
しかしながら，~transport指向な完全性が供する有用性は制限される
— それは，応用~層からは不透明であり、
それが受持つのは，単独の接続までに限られるので。
~HTTP~messageは，別々な接続の連鎖~越しに旅することが多く、
接続どうしの合間にて［
意図されない／悪意的な
］~data破損を~~被る可能性がある。
~HTTPによる完全性の仕組みは、［
端点／~HTTPを利用している応用
］用に［
~data破損を検出して，それに対し動作する方法について選ぶ
］ための手段を供せる。
利用事例の例として、
~system境界にまたがる欠陥~検出とその診断を援助することが挙げられる。
◎
HTTP does not define the means to protect the data integrity of content or representations. When HTTP messages are transferred between endpoints, lower layer features or properties such as TCP checksums or TLS records [RFC2818] can provide some integrity protection. However, transport-oriented integrity provides a limited utility because it is opaque to the application layer and only covers the extent of a single connection. HTTP messages often travel over a chain of separate connections, in between connections there is a possibility for unintended or malicious data corruption. An HTTP integrity mechanism can provide the means for endpoints, or applications using HTTP, to detect data corruption and make a choice about how to act on it. An example use case is to aid fault detection and diagnosis across system boundaries.
</p>

<p>
この文書は、
~HTTP用の~digest完全性の仕組みとして，次に挙げる 2 つを定義する：
◎
This document defines two digest integrity mechanisms for HTTP.＼
</p>
<ul>
	<li>
内容の完全性は、
伝達される`内容$に対し動作する。
◎
First, content integrity, which acts on conveyed content (Section 6.4 of [HTTP]).＼
</li>
	<li>
表現~dataの完全性は、
`表現~data$に対し動作する。
これは、
高度な利用事例を~supportする
— ［
複数の［
要請／接続
］を利用して検索取得された各部から構築し直された資源
］に対し，その完全性を検証することなど。
◎
Second, representation data integrity, which acts on representation data (Section 3.2 of [HTTP]). This supports advanced use cases such as validating the integrity of a resource that was reconstructed from parts retrieved using multiple requests or connections.
</li>
</ul>

<p>
この文書は、
~RFC 3230
— したがって［
`Digest^h, `Want-Digest^h
］`~field$も —
を廃用にする。
`1.3§ を見よ。
◎
This document obsoletes RFC 3230 and therefore the Digest and Want-Digest HTTP fields; see Section 1.3.
</p>

		<section id="document-structure">
<h3 title="Document Structure">1.1. この文書の構成</h3>

<p>
この文書の構成は：
◎
This document is structured as follows:
</p>
<ul>
	<li>
`2§ では、
`Content-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 2 defines the Content-Digest request and response header and trailer field,
</li>
	<li>
`3§ では、
`Repr-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 3 defines the Repr-Digest request and response header and trailer field,
</li>
	<li>
`4§ では、［
`Want-Repr-Digest$h, `Want-Content-Digest$h
］【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 4 defines the Want-Repr-Digest and Want-Content-Digest request and response header and trailer field,
</li>
	<li>
`5§ では、
各種~hashing~algo, および それらと この文書にて定義される各種~fieldとの関係を述べる。
◎
Section 5 describes algorithms and their relation to the fields defined in this document,
</li>
	<li>
`3.1§ では、
表現~digestの算出-法の詳細を与える。
◎
Section 3.1 details computing representation digests,
</li>
	<li>
［
`B§ ／ `C§
］では、［
`Repr-Digest$h ／ `Want-Repr-Digest$h
］を利用する例を供する。
◎
Appendix B and Appendix C provide examples of using Repr-Digest and Want-Repr-Digest.
</li>
</ul>

		</section>
		<section id="concept-overview">
<h3 title="Concept Overview">1.2. 概念の概観</h3>

<p>
この文書にて定義される`~field$は、
~HTTP完全性のために利用できる。
`送信者$は、
ある`~hashing~algo$を選んで，
当の~HTTP`~message$に関係する入力から~digestを計算する。
当の~algoの識別子と結果の~digestは、
`~field$内に伝送される。
`受信者$は、
完全性の目的で，その~digestを検証できる。
`~hashing~algo$は、
`~HTTP~digest~field用~hash~algo~registry^cite（ `5§ ）に登録される。
◎
The HTTP fields defined in this document can be used for HTTP integrity. Senders choose a hashing algorithm and calculate a digest from an input related to the HTTP message, the algorithm identifier and digest are transmitted in an HTTP field. Receivers can validate the digest for integrity purposes. Hashing algorithms are registered in the "Hash Algorithms for HTTP Digest Fields" (see Section 5).
</p>

<p>
~digestを どの~dataに対し計算するか選定することは、
~HTTP~messageの利用事例に依存する。
この文書は、
~HTTPの`表現~data$用と`内容$用に異なる~headerを供する。
◎
Selecting the data on which digests are calculated depends on the use case of HTTP messages. This document provides different headers for HTTP representation data and HTTP content.
</p>

<p>
`内容$を成す~byte列の単純な~digestが要求される利用事例もある。
`Content-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldは，
`内容$【！？Section 3.2 of [HTTP])】の~digestを~supportするために定義される。
`2§ を見よ。
◎
There are use-cases where a simple digest of the HTTP content bytes is required. The Content-Digest request and response header and trailer field is defined to support digests of content (Section 3.2 of [HTTP]); see Section 2.
</p>

<p>
より高度な利用事例~用には、
`Repr-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldが定義される（ `3§ ）。
それは、［
`選定された表現~data$に対し，ある`~hashing~algo$を適用する
］ことにより算出された~digest値を包含する。
`Repr-Digest$h を`選定された表現$に基づくようにすることは、
次に挙げる利用事例に，それを適用することを単直にする：
◎
For more advanced use-cases, the Repr-Digest request and response header and trailer field (Section 3) is defined. It contains a digest value computed by applying a hashing algorithm to selected representation data (Section 3.2 of [HTTP]). Basing Repr-Digest on the selected representation makes it straightforward to apply it to use-cases where＼
</p>
<ul>
	<li>
`内容$が`資源$の`表現$と見なされるものに何らかの類の操作を要求する所
◎
the message content requires some sort of manipulation to be considered as representation of the resource＼
</li>
	<li>
`内容$が`資源$の部分的な表現を伝達する所
— `範囲~要請$ `HTTP$r【！§ 14.2】など
◎
or content conveys a partial representation of a resource, such as Range Requests (see Section 14.2 of [HTTP]).
</li>
</ul>

<p>
［
`Content-Digest$h ／ `Repr-Digest$h
］~fieldは、
`~hashing~algo$の即応性【 `6.6§ 】を~supportする。
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］~fieldは、［
`Content-Digest$h ／ `Repr-Digest$h
］に対する関心, および［
どの~algoを選好するか
］を表出することを端点に許容する。
◎
Content-Digest and Repr-Digest support hashing algorithm agility. The Want-Content-Digest and Want-Repr-Digest fields allow endpoints to express interest in Content-Digest and Repr-Digest respectively, and to express algorithm preferences in either.
</p>

<p>
［
`Content-Digest$h ／ `Repr-Digest$h
］を総称して，
`完全性~field@
（ `Integrity field^en ）という。
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］を総称して，
`完全性~選好~field@
（ `Integrity preference field^en ）という。
◎
Content-Digest and Repr-Digest are collectively termed Integrity fields. Want-Content-Digest and Want-Repr-Digest are collectively termed Integrity preference fields.
</p>

<p>
`完全性~field$の計算は、［
`Content-Encoding$h, `Content-Type$h
］~headerに束ねられる。
したがって、所与の`資源$が~HTTPで転送されるとき，複数個の異なる~digest値があり得る。
◎
Integrity fields are tied to the Content-Encoding and Content-Type header fields. Therefore, a given resource may have multiple different digest values when transferred with HTTP.
</p>

<p>
`完全性~field$は［
`~message$【全体】／`~field$たち
］の完全性は供さない。
しかしながら，それは、
~HTTP交換に欲される各部を［
一体として／各部ごとに
］保護するためとして，［
~metadataを保護する他の仕組み
］を成す各~相
— ~digital署名など —
と組合できる。
例えば、
`~HTTP~message署名^cite `SIGNATURES$r を利用して，
`完全性~field$を署名する
— したがって，［
`内容$／`表現~data$
］用に~~保険をかける —
こともできる。
◎
Integrity fields do not provide integrity for HTTP messages or fields. However, they can be combined with other mechanisms that protect metadata, such as digital signatures, in order to protect the phases of an HTTP exchange in whole or in part. For example, HTTP Message Signatures [SIGNATURES] could be used to sign Integrity fields, thus providing coverage for HTTP content or representation data.
</p>

<p>
この仕様は、［
認証／権限付与／~privacy
］用の手段は定義しない。
◎
This specification does not define means for authentication, authorization or privacy.
</p>

		</section>
		<section id="obsolete-3230">
<h3 title="Obsoleting RFC 3230">1.3. ~RFC 3230 の廃用~化</h3>

<p>
`RFC3230$r は
~HTTP完全性~用に 2 つの~field
— `Digest^h, `Want-Digest^h —
を定義した。
それはまた、今や［
~HTTP意味論として，もっと普遍的に定義され, 実装された概念
］
— `選定された表現~data$など —
を説明するために，用語［
“~instance”, “~instance操作”
］も新造した。
◎
[RFC3230] defined the Digest and Want-Digest HTTP fields for HTTP integrity. It also coined the term "instance" and "instance manipulation" in order to explain concepts that are now more universally defined, and implemented, as HTTP semantics such as selected representation data (Section 3.2 of [HTTP]).
</p>

<p>
`RFC3230$r の実装は、
“~instance” の意味をどう解釈するか一貫性がなかったため，相互運用能の課題へ至らすことが経験から示された。
最も共通的な誤解は、
~digestの計算に
— 元々意図された，`表現~data$（と今や称されるもの）ではなく —
~messageの`内容$（と今や称されるもの）を利用することであった。
興味深いことに、
時を経て，~message`内容$の~digestも 一部の利用-事例では有益になることも示された。
なので、
`RFC3230$r に適合しないことが意図的かそうでないのか検出するのは，困難である。
◎
Experience has shown that implementations of [RFC3230] have interpreted the meaning of "instance" inconsistently, leading to interoperability issues. The most common mistake being the calculation of the digest using (what we now call) message content, rather than using (what we now call) representation data as was originally intended. Interestingly, time has also shown that a digest of message content can be beneficial for some use cases. So it is difficult to detect if non-conformance to [RFC3230] is intentional or unintentional.
</p>

<p>
［
`Digest^h ／ `Want-Digest^h
］の各~実装にまたがる非-一貫性と多義性に取組むため、
この文書は， `RFC3230$r を廃用する。
この文書にて定義される各種［
`完全性~field$（ `2§, `3§ ）／
`完全性~選好~field$（ `4§ ）
］は、
現在の~HTTP意味論にもっと良く倣うようにされ，
意図される用法を もっと明瞭に表すよう命名された。
◎
In order to address potential inconsistencies and ambiguity across implementations of Digest and Want-Digest, this document obsoletes [RFC3230]. The Integrity fields (Section 3 and Section 2) and Integrity preference fields (Section 4) defined in this document are better aligned with current HTTP semantics and have names that more clearly articulate the intended usages.
</p>

		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.4. 表記規約</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
この文書は、
`RFC5234$r に定義され，
`RFC7405$r にて更新された~ABNFを利用する。
◎
This document uses the Augmented BNF defined in [RFC5234] and updated by [RFC7405].
</p>

<p>
この文書は、
構文と構文解析-法を指定するため，
次に挙げる型を利用する【！terminology from Section 3 of】
`STRUCTURED-FIELDS$r
⇒＃
`~sf真偽値$,
`~sf~byte列$,
`~sf辞書$,
`~sf整数$,
`~sf~list$
◎
This document uses the following terminology from Section 3 of [STRUCTURED-FIELDS] to specify syntax and parsing: Boolean, Byte Sequence, Dictionary, Integer, and List.
</p>

<p>
この文書における次に挙げる用語は、
`HTTP$r に述べられるとおりに解釈すること
⇒＃
`表現$,
`選定される表現$,
`表現~data$,
`表現~metadata$,
`~UA$,
`内容$
◎
The definitions "representation", "selected representation", "representation data", "representation metadata", "user agent" and "content" in this document are to be interpreted as described in [HTTP].
</p>

<p class="trans-note">【
用語
`選定された表現~data@
（ `selected representation data^en ）も［
`選定された表現$の`表現~data$
］の略記として利用される。
】</p>

<p>
`~hashing~algo$の名前は、
それらを定義する文書に利用される文字大小-法を尊重する
（例： `SHA-1$i, `CRC32c$i ）。
一方で，`~hashing~algo$の~keyは、
引用符で括られる
（例： "`sha$c", "`crc32c$c" ）。
◎
Hashing algorithm names respect the casing used in their definition document (e.g. SHA-1, CRC32c) whereas hashing algorithm keys are quoted (e.g. "sha", "crc32c").
</p>

<p>
用語
`~checksum^dfn
は、
~byte列に ある~algoを適用した結果の出力を述べる。
一方で，用語
`~digest^dfn
は、
【~checksumと同様であるが，】
当の~fieldに包含される値に関係する所に限り利用される。
◎
The term "checksum" describes the output of the application of an algorithm to a sequence of bytes, whereas "digest" is only used in relation to the value contained in the fields.
</p>

<p>
用語 `完全性~field$は、［
`Content-Digest$h ／ `Repr-Digest$h
］の総称である。
◎
Integrity fields: collective term for Content-Digest and Repr-Digest
</p>

<p>
用語 `完全性~選好~field$は、［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］の総称である。
◎
Integrity preference fields: collective term for Want-Repr-Digest and Want-Content-Digest
</p>

<p id="SBS-ST">
一部の~code例の最初の行lに出現する
`~SBS-ST^c
は、
当の~code例には， `8792/7$rfc に則って［
長過ぎる行lが折返されたことを指示するためとして、
行lの末尾に "`\^c" が利用されている
］ことを表す
（それら
（ "`NOTE:…^c" および "`\^c" （と後続する改行文字, 字下げ））
は、
当の~codeの一部を成さない）。
【この段落は、この訳による追加。】
</p>

		</section>
	</section>
	<section id="content-digest">
<h2 title="The Content-Digest Field">2. `Content-Digest^h ~field</h2>

<p>
`Content-Digest^h `~field$は、
要請, 応答どちらにも利用でき，
実際の~message`内容$に`~hashing~algo$を適用して計算された~digestを通信する。
◎
The Content-Digest HTTP field can be used in requests and responses to communicate digests that are calculated using a hashing algorithm applied to the actual message content (see Section 6.4 of [HTTP]).＼
</p>

<p>
`Content-Digest^h は、
`有構造~field$であり，`~sf辞書$を値にとる
— 各~memberの：
◎
It is a Dictionary (see Section 3.2 of [STRUCTURED-FIELDS]) where each:
</p>
<ul>
	<li>
~keyは、
当の~digestを算出するときに利用された`~hashing~algo$を伝達する
（ `5§ を見よ）。
◎
key conveys the hashing algorithm (see Section 5) used to compute the digest;
</li>
	<li>
値は、
当の~digest計算の出力を包含する`~sf~byte列$をとる。
◎
value is a Byte Sequence (Section 3.3.5 of [STRUCTURED-FIELDS]), that contains the output of the digest calculation.
</li>
</ul>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
`~SBS-ST$

Content-Digest: \
  sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrI\
  iYllu7BNNyealdVLvRwEmTHWXvJwew==:
</pre>
</div>

<p>
この`~sf辞書$型を利用すれば、
例えば，能力が［
相異なる／発展している
］様々な端点を~supportするために［
異なる`~hashing~algo$を利用して計算された，複数の~digest
］を添えれる。
そのような~approachは、
より弱い~algoから離れるよう移行tすることも~supportし得る
（ `6.6§ を見よ）。
◎
The Dictionary type can be used, for example, to attach multiple digests calculated using different hashing algorithms in order to support a population of endpoints with different or evolving capabilities. Such an approach could support transitions away from weaker algorithms (see Section 6.6).
</p>

<div class="example">
<pre class="lang-http">
`~SBS-ST$

Repr-Digest: \
  sha-256=:4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=:,\
  sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrI\
  iYllu7BNNyealdVLvRwEmTHWXvJwew==:
</pre>
</div>

<p>
`受信者$は、
受信した各~digestに対し，どれを無視してもヨイ。
すなわち，`受信者$には、
~digestすべてを検証yせずに，
一部の`~hashing~algo$に限って検証~用に利用することも許容される。
◎
A recipient MAY ignore any or all digests. This allows the recipient to choose which hashing algorithm(s) to use for validation instead of verifying every digest.
</p>

<p>
`送信者$は、
~digestを
— `受信者$が所与の`~hashing~algo$を［
~supportする／無視することになる
］かどうか知ることなく —
送信してもヨイ。
◎
A sender MAY send a digest without knowing whether the recipient supports a given hashing algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Content-Digest^h は、
`~trailer節$内にも送信できる。
この事例では、
`Content-Digest^h は`~header節$の中へ併合してもヨイ
— `HTTP$r `~trailerの利用に対する制限＠~HTTPinfra#trailers.limitations§を見よ。
◎
Content-Digest can be sent in a trailer section. In this case, Content-Digest MAY be merged into the header section; see Section 6.5.1 of [HTTP].
</p>

	</section>
	<section id="representation-digest">
<h2 title="The Repr-Digest Field">3. `Repr-Digest^h ~field</h2>

<p>
`Repr-Digest^h `~field$は、
要請, 応答どちらにも利用でき，
`選定された表現~data$全体に`~hashing~algo$を適用して計算された~digestを通信する。
【 "Repr" は `Representation^en（表現）の略称。】
◎
The Repr-Digest HTTP field can be used in requests and responses to communicate digests that are calculated using a hashing algorithm applied to the entire selected representation data (see Section 8.1 of [HTTP]).
</p>

<p>
`表現$は、
~messageに対する~HTTP意味論の効果も織り込む。
例えば、
`内容$は，［
`範囲~要請$／ `HEAD$m などの~method
］により影響され得ることに加え、
内容が “伝送路” 上で転送される仕方は，他の`形式変換$に依存する
（例： ~HTTP11用の`転送~符号法$
— `HTTP/1.1$r `Transfer-Encoding§h を見よ）。
`A§ にて、
`表現$の概念を~~説明する例がいくつか供される。
◎
Representations take into account the effect of the HTTP semantics on messages. For example, the content can be affected by Range Requests or methods such as HEAD, while the way the content is transferred "on the wire" is dependent on other transformations (e.g. transfer codings for HTTP/1.1 - see Section 6.1 of [HTTP/1.1]). To help illustrate HTTP representation concepts, several examples are provided in Appendix A.
</p>

<p>
~messageに`表現~data$が無いときでも、
空~文字列に対する~digestを算出して，［
`表現~data$は送信されなかったことを表明する
］ことはアリである
（ `6.3§ を見よ）。
◎
When a message has no representation data it is still possible to assert that no representation data was sent by computing the digest on an empty string (see Section 6.3).
</p>

<p>
`Repr-Digest^h は、
`有構造~field$であり，`~sf辞書$を値にとる
— 各~memberの：
◎
Repr-Digest is a Dictionary (see Section 3.2 of [STRUCTURED-FIELDS]) where each:
</p>
<ul>
	<li>
~keyは、
当の~digestを算出するとき利用された`~hashing~algo$を伝達する
（ `5§ を見よ）。
◎
key conveys the hashing algorithm (see Section 5) used to compute the digest;
</li>
	<li>
値は、
当の~digest計算の出力を包含する`~sf~byte列$をとる。
◎
value is a Byte Sequence that contains the output of the digest calculation.
</li>
</ul>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
`~SBS-ST$

Repr-Digest: \
  sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrI\
  iYllu7BNNyealdVLvRwEmTHWXvJwew==:
</pre>
</div>

<p>
この`~sf辞書$型を利用すれば、
例えば，能力が［
相異なる／発展している
］様々な端点を~supportするために［
異なる`~hashing~algo$を利用して計算された，複数の~digest
］を添えれる。
そのような~approachは、
より弱い~algoから離れるよう移行tすることも~supportし得る
（ `6.6§ を見よ）。
◎
The Dictionary type can be used, for example, to attach multiple digests calculated using different hashing algorithms in order to support a population of endpoints with different or evolving capabilities. Such an approach could support transitions away from weaker algorithms (see Section 6.6).
</p>

<div class="example">
<pre class="lang-http">
`~SBS-ST$

Repr-Digest: \
  sha-256=:4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=:,\
  sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrI\
  iYllu7BNNyealdVLvRwEmTHWXvJwew==:
</pre>
</div>

<p>
`受信者$は、
受信した各~digestに対し，どれを無視してもヨイ。
すなわち，`受信者$には、
~digestすべてを検証yせずに，
一部の`~hashing~algo$に限って検証~用に利用することも許容される。
◎
A recipient MAY ignore any or all digests. This allows the recipient to choose which hashing algorithm(s) to use for validation instead of verifying every digest.
</p>

<p>
`送信者$は、
~digestを
— `受信者$が所与の`~hashing~algo$を［
~supportする／無視することになる
］かどうか知ることなく —
送信してもヨイ。
◎
A sender MAY send a digest without knowing whether the recipient supports a given hashing algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Repr-Digest^h は、
`~trailer節$内にも送信できる。
この事例では、
`Repr-Digest^h は`~header節$の中へ併合してもヨイ
— `HTTP$r `~trailerの利用に対する制限＠~HTTPinfra#trailers.limitations§を見よ。
◎
Repr-Digest can be sent in a trailer section. In this case, Repr-Digest MAY be merged into the header section; see Section 6.5.1 of [HTTP].
</p>

		<section id="state-changing-requests">
<h3 title="Using Repr-Digest in State-Changing Requests">3.1. 状態変更~要請における `Repr-Digest^h の利用-法</h3>

<p>
状態変更~要請~内に同封された表現が`~target資源$を述べるものでないときは、
表現~digestは，`表現~data$から算出されなければナラナイ。
これは、唯一アリな選択になる
— 表現~digestは、完全な`表現~metadata$を要求するので
（ `3§ を見よ）。
◎
When the representation enclosed in a state-changing request does not describe the target resource, the representation digest MUST be computed on the representation data. This is the only possible choice because representation digest requires complete representation metadata (see Section 3).
</p>

<p>
応答においては：
◎
In responses,
</p>
<ul>
	<li>
当の`表現$が要請の状態sを述べる場合、
`Repr-Digest$h は，同封された`表現$から算出されなければナラナイ
（ `B.8§ を見よ）
◎
if the representation describes the status of the request, Repr-Digest MUST be computed on the enclosed representation (see Appendix B.8 );
</li>
	<li>
参照-先の`資源$が在る場合、
`Repr-Digest$h は，その資源に`選定される表現$から算出されなければナラナイ
— それが当の`~target資源$と異なっていようが。
`Repr-Digest$h は、
同封された`表現$から算出された結果であることも，
そうでないこともある。
◎
if there is a referenced resource Repr-Digest MUST be computed on the selected representation of the referenced resource even if that is different from the target resource. That might or might not result in computing Repr-Digest on the enclosed representation.
</li>
</ul>

<p>
後者の事例は、
所与の`~method$の意味論に則って行われる
— 例えば， `Content-Location$h ~header `HTTP$r を利用して。
対照的に，
`Location$h ~headerは、
`表現~metadata$ではないので，
`Repr-Digest$h には影響しない。
◎
The latter case is done according to the HTTP semantics of the given method, for example using the Content-Location header field (see Section 8.7 of [HTTP]). In contrast, the Location header field does not affect Repr-Digest because it is not representation metadata.
</p>

<p>
例えば `PATCH$m 要請においては、
表現~digestは~patch文書から算出されることになる
— `表現~metadata$は、
`~target資源$ではなく，~patch文書を指すので
（ `PATCH$r `PATCH§m を見よ）。
対する応答においては、
表現~digestは，代わりに~patchされた`資源$の`選定された表現$から算出されることになる。
◎
For example, in PATCH requests, the representation digest will be computed on the patch document because the representation metadata refers to the patch document and not to the target resource (see Section 2 of [PATCH]). In responses, instead, the representation digest will be computed on the selected representation of the patched resource.
</p>

		</section>
		<section id="digest-and-content-location">
<h3 title="Repr-Digest and Content-Location in Responses">3.2. 応答~内の `Repr-Digest^h と `Content-Location^h</h3>

<p>
ある状態変更~methodに対する応答が `Content-Location$h ~headerを返すとき、
応答に同封された表現は，その`~field値$により識別される`資源$を指す
— `Repr-Digest$h はそれに則って算出される。
その例は `B.7§ にて与える。
◎
When a state-changing method returns the Content-Location header field, the enclosed representation refers to the resource identified by its value and Repr-Digest is computed accordingly. An example is given in Appendix B.7.
</p>

		</section>
	</section>
	<section id="want-fields">
<h2 title="Integrity preference fields">4. 完全性~選好~field</h2>

<p>
`送信者$は、［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］~fieldを利用して，自身による［
`完全性~field$への関心, `~hashing~algo$の選好
］を指示できる。
両~fieldとも、
要請, 応答どちらにも利用できる。
◎
Senders can indicate their interest in Integrity fields and hashing algorithm preferences using the Want-Content-Digest or Want-Repr-Digest fields. These can be used in both requests and responses.
</p>

<p>
`Want-Content-Digest^h ~fieldは、
次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，［
`Content-Digest$h ~fieldを利用している内容~digest
］を受信したいと願っている。
◎
Want-Content-Digest indicates that the sender would like to receive a content digest on messages associated with the request URI and representation metadata, using the Content-Digest field.
</p>

<p>
`Want-Repr-Digest^h ~fieldは、
次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，［
`Repr-Digest$h ~fieldを利用している表現~digest
］を受信したいと願っている。
◎
Want-Repr-Digest indicates that the sender would like to receive a representation digest on messages associated with the request URI and representation metadata, using the Repr-Digest field.
</p>

<p>
［
`Want-Content-Digest^h ／ `Want-Repr-Digest^h
］が応答~内に利用された場合、
次を指示する
⇒
`~server$は、［
`~client$が，対応する`完全性~field$を未来の要請にて供する
］よう願っている。
◎
If Want-Content-Digest or Want-Repr-Digest are used in a response, it indicates that the server would like the client to provide the respective Integrity field on future requests.
</p>

<p>
［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］は、
`有構造~field$であり，`~sf辞書$を値にとる
— 各~memberの：
◎
Want-Content-Digest and Want-Repr-Digest are of type Dictionary where each:
</p>
<ul>
	<li>
~keyは、
当の`~hashing~algo$を伝達する。
◎
key conveys the hashing algorithm (see Section 5);
</li>
	<li>
値は、
`~sf整数$をとり，
【~keyに指示された~hashing~algoの】選好~度を伝達する。
値は、
範囲 { 0 〜 10 } に入らなければナラナイ。
各~memberのうち，値が大きいものほど選好されるが、
値 0 は “受容-可能でない” ことを意味する。
◎
value is an Integer (Section 3.3.1 of [STRUCTURED-FIELDS]) that conveys an ascending, relative, weighted preference. It must be in the range 0 to 10 inclusive. 1 is the least preferred, 10 is the most preferred, and a value of 0 means "not acceptable".
</li>
</ul>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
Want-Repr-Digest: sha-256=1
Want-Repr-Digest: sha-512=3, sha-256=10, unixsum=0
Want-Content-Digest: sha-256=1
Want-Content-Digest: sha-512=3, sha-256=10, unixsum=0
</pre>
</div>

	</section>
	<section id="algorithms">
<h2 title="Hash Algorithms for HTTP Digest Fields Registry">5. ~HTTP~digest~field用~hash~algoの~registry</h2>

<p>
~IANAにより保守される
`~HTTP~digest~field用~hash~algo~registry$citeは、［
`完全性~field$, `完全性~選好~field$
］と伴に利用される各種~algoを登録する。
◎
The "Hash Algorithms for HTTP Digest Fields", maintained by IANA at https://www.iana.org/assignments/http-dig-alg/, registers algorithms for use with the Integrity and Integrity preference fields defined in this document.
</p>

<p>
この~registryは、
`Specification Required^en 施策（ `8126/4.6$rfc ）を利用する。
◎
This registry uses the Specification Required policy (Section 4.6 of [RFC8126]).
</p>

<p>
各 登録は、
次に挙げる~fieldを含まなければナラナイ：
◎
Registrations MUST include the following fields:
</p>
<dl>
	<dt>
~algo~key
◎
Algorithm Key:＼
</dt>
	<dd>
次に挙げる`有構造~field$において，
`~sf辞書$を成す各~memberの~keyとして利用される値
⇒＃
`Content-Digest$h,
`Repr-Digest$h,
`Want-Content-Digest$h
`Want-Repr-Digest$h,
◎
the Structured Fields key value used in Content-Digest, Repr-Digest, Want-Content-Digest, or Want-Repr-Digest field Dictionary member keys
</dd>
	<dt>
位置付け
◎
Status:＼
</dt>
	<dd>
当の~algoの位置付け
— 次に挙げるいずれかを利用すること：
◎
the status of the algorithm.＼
<p>
		<ul>
			<li>
`標準^i（ `standard^en ）
⇒
当の~algoは、
標準~化されていて，
既知な問題を伴わない場合には。
◎
Use "standard" for standardized algorithms without known problems;＼
</li>
			<li>
`試験的^i（ `experimental^en ）その他~何らかの適切な値
⇒
例えば、
当の~algoを定義した首な文書の種別と位置付けに則って。
◎
"experimental" or some other appropriate value＼
- e.g. according to the type and status of the primary document in which the algorithm is defined;＼
</li>
			<li>
`非~secure^i （ `insecure^en ）
⇒
当の~algoが~secureでなくなったときには。
◎
"insecure" when the algorithm is insecure;＼
</li>
			<li>
`予約-済み^i （ `reserved^en ）
⇒
当の~algoが予約-済みな~token値を参照するときには。
◎
"reserved" when the algorithm references a reserved token value
</li>
		</ul>
	</dd>

	<dt>
記述
◎
Description:＼
</dt>
	<dd>
当の~algoについての短い記述
◎
a short description of the algorithm
</dd>

	<dt>
参照
◎
Reference(s):＼
</dt>
	<dd>
当の~algo, その~keyを定義している首な文書~群への~pointer。
◎
a set of pointers to the primary documents defining the algorithm and key
</dd>
</dl>

<p>
~secureでない~hashing~algoは、
破損に抗する完全性を保全するためとして利用してもヨイが、
敵対者に~~晒され得る設定においては，利用してはナラナイ
— 例えば、
真正性を得るために`完全性~field$の値を署名するとき。
◎
Insecure hashing algorithms MAY be used to preserve integrity against corruption, but MUST NOT be used in a potentially adversarial setting; for example, when signing Integrity fields' values for authenticity.
</p>

<p>
この文書が登録する~entryは、
`表 1＠#iana-hash-algorithm-table$ に挙げられる。
◎
The entries in Table 1 are registered by this document.
</p>

<div>
<table id="_hash-algorithm-table" class="grid-table">
<caption id="iana-hash-algorithm-table">
表 1
— 初期~hash~algo
</caption>
<thead><tr>
<th>~algo~key
<th>位置付け
<th>記述
<th>参照

</thead><tbody>

<tr><td>`sha-512@c
<td>`標準^i
<td>`SHA-512^i ~algo。
<td>
`RFC6234$r, `RFC4648$r, この文書

<tr><td>`sha-256@c
<td>`標準^i
<td>`SHA-256^i ~algo。
<td>
`RFC6234$r, `RFC4648$r, この文書

<tr><td>`md5@c
<td>`非~secure^i
<td>`MD5^i ~algo。
これは、衝突~攻撃に脆弱である
— `NO-MD5$r, `CMU-836068$r を見よ。
<td>
`RFC1321$r, `RFC4648$r, この文書

<tr><td>`sha@c
<td>`非~secure^i
<td>`SHA-1^i ~algo。
これは、衝突~攻撃に脆弱である
— `NO-SHA$r, `IACR-2020-014$r を見よ
<td>
`RFC3174$r, `RFC4648$r, `RFC6234$r この文書

<tr><td>`unixsum@c
<td>`非~secure^i
<td>~UNIX "sum" ~commandに利用される~algo。
<td>
`RFC4648$r, `RFC6234$r, `UNIX$r, この文書

<tr><td>`unixcksum@c
<td>`非~secure^i
<td>~UNIX "cksum" ~commandに利用される~algo。
<td>
`RFC4648$r, `RFC6234$r, `UNIX$r, この文書

<tr><td>`adler@c
<td>`非~secure^i
<td>`ADLER32^i ~algo。
<td>
`RFC1950$r, この文書

<tr><td>`crc32c@c
<td>`非~secure^i
<td>`CRC32c^i ~algo。
<td>
`RFC9260$r 付録 B, この文書

</tbody>
</table>

◎
Table 1: Initial Hash Algorithms Algorithm
◎
Algorithm Key｜Status｜Description｜Reference(s)
sha-512｜standard｜The SHA-512 algorithm.｜[RFC6234], [RFC4648], this document.
sha-256｜standard｜The SHA-256 algorithm.｜[RFC6234], [RFC4648], this document.
md5｜insecure｜The MD5 algorithm. It is vulnerable to collision attacks; see [NO-MD5] and [CMU-836068]｜[RFC1321], [RFC4648], this document.
sha｜insecure｜The SHA-1 algorithm. It is vulnerable to collision attacks; see [NO-SHA] and [IACR-2020-014]｜[RFC3174], [RFC4648], [RFC6234] this document.
unixsum｜insecure｜The algorithm used by the UNIX "sum" command.｜[RFC4648], [RFC6234], [UNIX], this document.
unixcksum｜insecure｜The algorithm used by the UNIX "cksum" command.｜[RFC4648], [RFC6234], [UNIX], this document.
adler｜insecure｜The ADLER32 algorithm.｜[RFC1950], this document.
crc32c｜insecure｜The CRC32c algorithm.｜[RFC9260] appendix B, this document.
</div>

	</section>
	<section id="security">
<h2 title="Security Considerations">6. ~securityの考慮点</h2>

		<section id="sec-limitations">
<h3 title="HTTP Messages Are Not Protected In Full">6.1. ~HTTP~messageは全部的には保護されない</h3>

<p>
この文書は、
ある~data完全性の仕組みを指定する。
それは、
~HTTP［
`表現~data$／`内容$
］を保護するが，~HTTP［
~headerや~trailer
］を ある種の破損から保護するものではない。
◎
This document specifies a data integrity mechanism that protects HTTP representation data or content, but not HTTP header and trailer fields, from certain kinds of corruption.
</p>

<p>
`完全性~field$には、［
~HTTP~messageに対する悪意的な改ざんに抗する一般的な保護
］は意図されない。
それは、［
~transport層の~securityや~digital署名
］など，他の~approachと組合せることで達成できる
（例えば、 `~HTTP~message署名^cite `SIGNATURES$r ）。
◎
Integrity fields are not intended to be a general protection against malicious tampering with HTTP messages. This can be achieved by combining it with other approaches such as transport-layer security or digital signatures (for example, HTTP Message Signatures [SIGNATURES]).
</p>

		</section>
		<section id="end-to-end-integrity">
<h3 title="End-to-End Integrity">6.2. 端点間の完全性</h3>

<p>
`完全性~field$は［
実装~error／
欲されない`形式変換ng~proxy$ `HTTP$r ／
~dataが いくつかの［
中継点／~system境界
］を通過するときに伴われる他の動作
］に因る`表現~metadata$の改変を検出する助けになり得る。
［
`端点間$における［
`表現~data$／`内容$
］の完全性
］用の単純な仕組みであっても，価値はある
— ~UAは、［
~HTML構文解析器や動画~再生器, 等々
］に構文解析~用に手渡す前に，資源の検索取得に成功したことを検証できるので。
◎
Integrity fields can help detect representation data or content modification due to implementation errors, undesired "transforming proxies" (see Section 7.7 of [HTTP]) or other actions as the data passes across multiple hops or system boundaries. Even a simple mechanism for end-to-end representation data integrity is valuable because a user agent can validate that resource retrieval succeeded before handing off to a HTML parser, video player etc. for parsing.
</p>

<p>
これらの仕組みだけを利用しても，`端点間$における~HTTP~message【全体】の完全性は
— 中継点を経ている場合には —
供さないことに注意
— その~metadataは、どの段階でも操作され得るので。
~metadataを保護する手法は、
`6.3§ にて論じられる。
◎
Note that using these mechanisms alone does not provide end-to-end integrity of HTTP messages over multiple hops, since metadata could be manipulated at any stage. Methods to protect metadata are discussed in Section 6.3.
</p>

		</section>
		<section id="usage-in-signatures">
<h3 title="Usage in Signatures">6.3. 署名における用法</h3>

<p>
~digital署名は、
ある種の［
~messageの出自を識別するもの
］を供するためとして，
~checksumと一緒に広範に利用される
`NIST800-32$r
。
そのような署名は、
1 個以上の`~field$を保護し得る
— それらに`完全性~field$も含まれるときには、
追加的な考慮点がある。
◎
Digital signatures are widely used together with checksums to provide the certain identification of the origin of a message [NIST800-32]. Such signatures can protect one or more HTTP fields and there are additional considerations when Integrity fields are included in this set.
</p>

<p>
`完全性~field$と伴に利用できる~digital【！~digitial】署名の［
型／形式
］に設置される制約は無い。
アリな~approachの一つは、
それらを `~HTTP~message署名^cite `SIGNATURES$r と組合せることである。
◎
There are no restrictions placed on the type or format of digitial signature that Integrity fields can be used with. One possible approach is to combine them with HTTP Message Signatures [SIGNATURES].
</p>

<p>
~digestは、
`表現~metadata$
（例：`Content-Type$h, `Content-Encoding$h, 等々の値）
に明示的に依存する。
`完全性~field$は保護しつつ他の`表現~metadata$は保護しない署名は、
当の通信を改ざんに晒し得る。
例えば，ある動作者は、
`Content-Type$h `~field値$を操作して，
`受信者$における~digest検証を失敗に至らすこともでき、
当の応用が`表現$へ~accessするのを防止する。
そのような攻撃は、
両~端点の資源を消費する。
`3.2§ も見よ。
◎
Digests explicitly depend on the "representation metadata" (e.g. the values of Content-Type, Content-Encoding etc). A signature that protects Integrity fields but not other "representation metadata" can expose the communication to tampering. For example, an actor could manipulate the Content-Type field-value and cause a digest validation failure at the recipient, preventing the application from accessing the representation. Such an attack consumes the resources of both endpoints. See also Section 3.2.
</p>

<p>
署名は、
`完全性~field$を適用するときに，敵対者に~~晒される見込みが高いと判断される
— `5§ を見よ。
署名を利用して，空な表現の~checksumを保護することは、［
最終的な`内容$において，何かが剥がされたり追加されたかどうか検出する
］ことを，受信している端点に許容する。
◎
Signatures are likely to be deemed an adversarial setting when applying Integrity fields; see Section 5. Using signatures to protect the checksum of an empty representation allows receiving endpoints to detect if an eventual payload has been stripped or added.
</p>

<p>
`完全性~field$を弄ることは、
署名の検証に影響するかもしれない
— 例：
重複している`~field行l値$を除去する【！de-duplication】 ／
複数個の`~field行l値$を`結合-$するなど
（ `HTTP$r `~field行lと結合-済みな~field値＠~HTTPinfra#field.lines§を見よ）。
◎
Any mangling of Integrity fields, including digests' de-duplication or combining different field values (see Section 5.2 of [HTTP]) might affect signature validation.
</p>

		</section>
		<section id="usage-in-trailer-fields">
<h3 title="Usage in Trailer Fields">6.4. ~trailerにおける用法</h3>

<p>
`送信者$は、
`~trailer節$内に`完全性~field$を送信する前に，次について考慮するべきである
⇒
`中継者$には、
どの`~trailer$も落とすことが明示的に許容されている
（ `HTTP$r `~trailerの処理＠~HTTPinfra#trailers.processing§を見よ）。
◎
Before sending Integrity fields in a trailer section, the sender should consider that intermediaries are explicitly allowed to drop any trailer (see Section 6.5.2 of [HTTP]).
</p>

<p>
`完全性~field$が`~trailer節$内で利用される場合、
その`~field値$は，`内容$より後に受信される。
`~trailer節$より前に内容の処理を急ぐと，~digestは検証できなくなり、
場合によっては，無効な~dataの処理へ導き得る。
◎
When Integrity fields are used in a trailer section, the field-values are received after the content. Eager processing of content before the trailer section prevents digest validation, possibly leading to processing of invalid data.
</p>

<p>
`~hashing~algo$には，`~trailer節$内の利用には相応でないものもある
— うち一部は、
~messageを送信する前に，`内容$全体を予め処理することを要求することもある
（例： `I-D.thomson-http-mice$r を見よ）。
◎
Not every hashing algorithm is suitable for use in the trailer section, some may require to pre-process the whole payload before sending a message (e.g. see [I-D.thomson-http-mice]).
</p>

		</section>
		<section id="usage-with-encryption">
<h3 title="Usage with Encryption">6.5. 暗号化を伴う用法</h3>

<p>
暗号化された`内容$の~checksumは、
利用される暗号化~algoに依存して，
各~messageごとに変化し得る
— そのような事例では、その値は，
“残りの部分（ `at rest^en ）” 【？】における完全性の証明も供するために利用することはできない
— 当の`内容$（例：符号化されたそれ）が一体として持続されない限り。
◎
The checksum of an encrypted payload can change between different messages depending on the encryption algorithm used; in those cases its value could not be used to provide a proof of integrity "at rest" unless the whole (e.g. encoded) content is persisted.
</p>

		</section>
		<section id="sec-agility">
<h3 title="Algorithm Agility">6.6. ~algo即応性</h3>

<p>
`~hashing~algo$の~securityの特質は、
固定的でない【時を経れば変化し得る】。
`~algo即応性^cite（ `Algorithm Agility^en, `RFC7696$r ）は、［
`~hashing~algo$を［
`~HTTP~digest~field用~hash~algo~registry$cite（ `7.2§ ）
］から選ぶ柔軟性
］を備える実装を供することにより達成される。
◎
The security properties of hashing algorithms are not fixed. Algorithm Agility (see [RFC7696]) is achieved by providing implementations with flexibility to choose hashing algorithms from the IANA Hash Algorithms for HTTP Digest Fields registry; see Section 7.2.
</p>

<p>
この文書~内に挙げられる `標準^i ~algoは、
多くの目的に相応しくなる
— 敵対者に~~晒される状況も含めて
（そこでは、~hash関数は，［
衝突~攻撃, 第一-原像~攻撃, 第二-原像~攻撃
］に対する耐性を供する必要があるかもしれない）。
`非~secure^i として挙げられる~algoは、
これらの特質を何も供さないか，弱いことが既知である
（ `NO-MD5$r, `NO-SHA$r を見よ）。
◎
The "standard" algorithms listed in this document are suitable for many purposes, including adversarial situations where hash functions might need to provide resistance to collision, first-preimage and second-preimage attacks. Algorithms listed as "insecure" either provide none of these properties, or are known to be weak (see [NO-MD5] and [NO-SHA]).
</p>

<p>
敵対者に~~晒される状況において，
`標準^i ~algoのうち どれが受容-可能かは、
当の状況下で~~必要とされる保護~levelに依存することになる。
折衝は無いので、
~security用の~digestに依存する端点は，［
受容する用意がある~algoのうち最も弱いもの
］に対する攻撃に対し脆弱になる。
◎
For adversarial situations, which of the "standard" algorithms are acceptable will depend on the level of protection the circumstances demand. As there is no negotiation, endpoints that depend on a digest for security will be vulnerable to attacks on the weakest algorithm they are willing to accept.
</p>

<p>
弱い~algoからの移行tは、［
`~hashing~algo$を［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］を利用して折衝する／
複数個の~digestを送信して，その中から`受信者$【！receiver】に選んでもらう
］ことにより~supportされる。
とは言え，資源を消費して複数個の値を送信しても、
`受信者$【！receiver】から無視された場合には，浪費されることになる
（ `3§ を見よ）。
◎
Transition from weak algorithms is supported by negotiation of hashing algorithm using Want-Content-Digest or Want-Repr-Digest (see Section 4) or by sending multiple digests from which the receiver chooses. Endpoints are advised that sending multiple values consumes resources, which may be wasted if the receiver ignores them (see Section 3).
</p>

<p>
~algo即応性は、
より強い~algoへの移行を許容する一方で，より弱い~algoの利用を防止しない。
`完全性~field$は、
`~hashing~algo$の［
降格~攻撃／代用~攻撃
］（`6211/1$rfc を見よ）に対しては，いかなる軽減策も供さない。
端点は、
そのような攻撃に抗して保護するためとして，［
自身が~supportする~algoの集合を より強いものに制約して、
~TLSや~digital署名を利用することにより~field値を保護する
］こともできる。
◎
While algorithm agility allows the migration to stronger algorithms it does not prevent the use of weaker algorithms. Integrity fields do not provide any mitigiations for downgrade or substitution attacks (see Section 1 of [RFC6211]) of the hashing algorithm. To protect against such attacks, endpoints could restrict their set of supported algorithms to stronger ones and protect the fields value by using TLS and/or digital signatures.
</p>

		</section>
		<section id="resource-exhaustion">
<h3 title="Resource exhaustion">6.7. 資源の枯渇</h3>

<p>
`完全性~field$の検証は、計算l資源を消費する。
実装は、資源の枯渇を避けるためとして，［
~algoの種別, 検証の回数, `内容$の~size
］の検証を制約できる。
◎
Integrity fields validation consumes computational resources. In order to avoid resource exhaustion, implementations can restrict validation of the algorithm types, number of validations, or the size of content.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">7. ~IANA考慮点</h2>

		<section id="http-field-name-registration">
<h3 title="HTTP Field Name Registration">7.1. ~HTTP~field名の登録</h3>

<p>
~IANAには、
下の表に則って，
`~HTTP~field名~registry^cite `HTTP$r を更新するよう依頼される：
◎
IANA is asked to update the "Hypertext Transfer Protocol (HTTP) Field Name Registry" registry ([HTTP]) according to the table below:
</p>

<div>
<table id="table-2">
<caption>表 2</caption>
<thead><tr>
<th>`~field名$
<th>位置付け
<th>参照
</thead><tbody>

<tr><td>`Content-Digest$h
<td>`恒久的^i
<td>この文書の `2§

<tr><td>`Repr-Digest$h
<td>`恒久的^i
<td>この文書の `3§

<tr><td>`Want-Content-Digest$h
<td>`恒久的^i
<td>この文書の `4§

<tr><td>`Want-Repr-Digest$h
<td>`恒久的^i
<td>この文書の `4§

<tr><td>`Digest$h
<td>`廃用d^i
<td>`RFC3230$r, この文書の `1.3§

<tr><td>`Want-Digest$h
<td>`廃用d^i
<td>`RFC3230$r, この文書の `1.3§

</tbody></table>
◎
Table 2
◎
Field Name｜Status｜Reference
Content-Digest｜permanent｜Section 2 of this document
Repr-Digest｜permanent｜Section 3 of this document
Want-Content-Digest｜permanent｜Section 4 of this document
Want-Repr-Digest｜permanent｜Section 4 of this document
Digest｜obsoleted｜[RFC3230], Section 1.3 of this document
Want-Digest｜obsoleted｜[RFC3230], Section 1.3 of this document
</div>

		</section>
		<section id="establish-hash-algorithm-registry">
<h3 title="Establish the Hash Algorithms for HTTP Digest Fields Registry">7.2. ~HTTP~digest~field用~hash~algo~registryを確立する</h3>

<p>
このメモは、
この仕様が［
`5§ にて定義される
`~HTTP~digest~field用~hash~algo~registry$cite
【！~IANA-a/http-structured-dig-alg/】
］用の文書を確立するものと設定する。
◎
This memo sets this specification to be the establishing document for the Hash Algorithms for HTTP Digest Fields registry defined in Section 5.
</p>

<p>
~IANAには、
`表 1＠#iana-hash-algorithm-table$
を成す~entry群で，
当の~registryを初期化することが依頼される。
◎
IANA is asked to initialize the registry with the entries in Table 1.
</p>

		</section>
	</section>
	<section id="resource-representation">
<h2 title="Appendix A. Resource Representation and Representation Data">付録 A. 資源~表現と表現~data</h2>

<p>
以下に挙げる例は、［
`表現~metadata$, `内容$の`形式変換$, `~method$
］が~messageと`内容$にどう影響iするかを示す。
以下において，`内容$が印字不能な文字を包含するとき（例：圧縮されているとき）は、
`Base64^i に符号化された文字列として示される。
◎
The following examples show how representation metadata, payload transformations and method impacts on the message and content. When the content contains non-printable characters (e.g. when it is compressed) it is shown as a Base64-encoded string.
</p>

<div class="example">
<figure id="figure-name-request-containing-a-json-o">
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json

{"hello": "world"}
</pre>
<figcaption>
`内容~符号法$を伴わない~JSON~objを伴う要請
◎
Figure 1: Request containing a JSON object without any content coding
</figcaption></figure>
</div>

<div class="example">
<figure id="figure-name-request-containing-a-gzip-e">
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Encoding: gzip

H4sIAItWyFwC/6tWSlSyUlAypANQqgUAREcqfG0AAAA=
</pre>
<figcaption>
`gzip$c で符号化された~JSON~objを包含している要請
◎
Figure 2: Request containing a gzip-encoded JSON object
</figcaption></figure>
</div>

<p>
一方で，次の要請は、`内容$は上と同じでも，不正形な~JSON~objを伝達する
— それは、`内容~符号法$を指示していないので。
◎
Now the same content conveys a malformed JSON object, because the request does not indicate a content coding.
</p>

<div class="example">
<figure id="figure-name-request-containing-malforme">
<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json

H4sIAItWyFwC/6tWSlSyUlAypANQqgUAREcqfG0AAAA=
</pre>
<figcaption>
不正形な~JSONを包含している要請
◎
Figure 3: Request containing malformed JSON
</figcaption></figure>
</div>

<p>
`範囲~要請$は、
`内容$を改めて，部分的な表現を伝達する【よう要請する】。
◎
A Range-Request alters the content, conveying a partial representation.
</p>

<div class="example">
<figure id="figure-name-request-for-partial-content">
<pre class="lang-http">
GET /entries/1234 HTTP/1.1
Host: foo.example
Range: bytes=1-7

</pre>
<figcaption>
部分的な内容に対する要請
◎
Figure 4: Request for partial content
</figcaption></figure>

<figure id="figure-name-partial-response-from-a-gzi">
<pre class="lang-http">
HTTP/1.1 206 Partial Content
Content-Encoding: gzip
Content-Type: application/json
Content-Range: bytes 1-7/18

iwgAla3RXA==
</pre>
<figcaption>
`gzip$c で符号化された表現からの`部分的な応答$
◎
Figure 5: Partial response from a gzip-encoded representation
</figcaption></figure>
</div>

<p>
~methodは`内容$を改めることもある。
例えば `HEAD$m 要請に対する応答は、`内容$を運ばない。
◎
The method can also alter the content. For example, the response to a HEAD request does not carry content.
</p>

<div class="example">
<figure id="figure-name-head-request">
<pre class="lang-http">
HEAD /entries/1234 HTTP/1.1
Host: foo.example
Accept: application/json
Accept-Encoding: gzip

</pre>
<figcaption>
`HEAD$m 要請
◎
Figure 6: HEAD request
</figcaption></figure>

<figure id="figure-name-response-to-head-request-em">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: gzip

</pre>
<figcaption>
対する応答は、
`内容$を伴わない
◎
Figure 7: Response to HEAD request (empty content)
</figcaption></figure>
</div>

<p>
~HTTP応答の意味論は、
`~target~URI$を同封された表現から切り離すかもしれない。
下に与える応答の例では、
`Content-Location$h ~headerは、［
同封された表現は `/authors/123^c にて可用な資源を指す
］ことを指示する
— 当の要請は `/authors/^c へ~directされていても。
◎
Finally, the semantics of an HTTP response might decouple the effective request URI from the enclosed representation. In the example response below, the Content-Location header field indicates that the enclosed representation refers to the resource available at /authors/123, even though the request is directed to /authors/.
</p>

<div class="example">
<figure id="figure-name-post-request">
<pre class="lang-http">
POST /authors/ HTTP/1.1
Host: foo.example
Accept: application/json
Content-Type: application/json

{"author": "Camilleri"}
</pre>
<figcaption>
`POST$m 要請
◎
Figure 8: POST request
</figcaption></figure>

<figure id="figure-name-response-with-content-locat">
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /authors/123
Location: /authors/123

{"id": "123", "author": "Camilleri"}
</pre>
<figcaption>
`Content-Location$h ~headerを伴う応答
◎
Figure 9: Response with Content-Location header
</figcaption></figure>
</div>

	</section>
	<section id="examples-unsolicited">
<h2 title="Appendix B. Examples of Unsolicited Digest">付録 B. 請求されない~digestの例</h2>

<p>
以下に挙げる例は、
`~client$が［
`Want-Content-Digest$h ／ `Want-Repr-Digest$h
］を利用するよう請求しなかったときでも，
`~server$が［
`Content-Digest$h ／ `Repr-Digest$h
］~fieldで応答するときのヤリトリをデモる。
◎
The following examples demonstrate interactions where a server responds with a Content-Digest or Repr-Digest fields even though the client did not solicit one using Want-Content-Digest or Want-Repr-Digest.
</p>

<p>
例のうちいくつかは、
`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.
</p>

<p>
この文書にて定義される~checksumの仕組みは、
`~MIME型$を問わないことに加え，特定の形式~用の正準-化~algoは供さない。
各~例は、【対象の~data内の】
~spaceも含めて計算される。
［
`Content-Digest$h, `Repr-Digest$h
］両~fieldを含む例もあるが、
これらは，独立に返され得る。
◎
Checksum mechanisms defined in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space. While examples can include both fields, Content-Digest and Repr-Digest can be returned independently.
</p>

		<section id="example-full-representation">
<h3 title="Server Returns Full Representation Data">B.1. ~serverは全部的な表現~dataを返す例</h3>

<p>
この例では、
~messageの`内容$は完全な`表現~data$を伝達する。
すなわち，応答~内の［
`Content-Digest$h, `Repr-Digest$h
］は、
どちらも~JSON~obj
`{"hello": "world"}^c
から計算されるので，同じ値をとる。
◎
In this example, the message content conveys complete representation data. This means that in the response, Content-Digest and Repr-Digest are both computed over the JSON object {"hello": "world"}, and thus have the same value.
</p>

<div class="example">
<figure id="figure-name-get-request-for-an-item">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example

</pre>
<figcaption>
ある~itemに対する `GET$m 要請
◎
Figure 10: GET request for an item
</figcaption></figure>

<figure id="figure-name-response-with-identical-rep">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Digest: \
  sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:
Repr-Digest: \
  sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
互いに一致する［
`Content-Digest$h, `Repr-Digest$h
］を伴う
◎
Figure 11: Response with identical Repr-Digest and Content-Digest
</figcaption></figure>
</div>

		</section>
		<section id="server-returns-no-representation-data">
<h3 title="Server Returns No Representation Data">B.2. ~serverは表現~dataを返さない例</h3>

<p>
この例では、
`HEAD$m 要請を利用して`資源$の~checksumを検索取得する。
◎
In this example, a HEAD request is used to retrieve the checksum of a resource.
</p>

<p>
対する応答の `Content-Digest$h は、
空な`内容$に対し算出される。
`Repr-Digest$h は，~JSON~obj
`{"hello": "world"}^c
から計算されるが、
応答の`内容$は無いので，当の~JSONは そこには示されない。
◎
The response Content-Digest field-value is computed on empty content. Repr-Digest is calculated over the JSON object {"hello": "world"}, which is not shown because there is no payload data.
</p>

<div class="example">
<figure id="figure-name-head-request-for-an-item">
<pre class="lang-http">
HEAD /items/123 HTTP/1.1
Host: foo.example

</pre>
<figcaption>
ある~itemに対する `HEAD$m 要請
◎
Figure 12: HEAD request for an item
</figcaption></figure>

<figure id="figure-name-response-with-both-content-">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Digest: \
  sha-256=:47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=:
Repr-Digest: \
  sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:
</pre>
<figcaption>
対する応答は、
`Content-Digest$h, `Repr-Digest$h 両者を伴うが，`内容$は伴わない
◎
Figure 13: Response with both Content-Digest and Digest; empty content
</figcaption></figure>
</div>

		</section>
		<section id="server-returns-partial-representation-data">
<h3 title="Server Returns Partial Representation Data">B.3. ~serverは部分的な表現~dataを返す例</h3>

<p>
この例では、
`~client$は、`範囲~要請$を為す
— 対して`~server$は、
部分的な内容で応答する。
◎
In this example, the client makes a range request and the server responds with partial content.
</p>

<div class="example">
<figure id="figure-name-request-for-partial-content-2">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Range: bytes=1-7

</pre>
<figcaption>
部分的な内容に対する要請
◎
Figure 14: Request for partial content
</figcaption></figure>

<figure id="figure-name-partial-response-with-both-">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 206 Partial Content
Content-Type: application/json
Content-Range: bytes 1-7/18
Content-Digest: \
  sha-256=:Wqdirjg/u3J688ejbUlApbjECpiUUtIwT8lY/z81Tno=:
Repr-Digest: \
  sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

"hello"
</pre>
<figcaption>
`Content-Digest$h, `Repr-Digest$h 両者を伴う`部分的な応答$
◎
Figure 15: Partial response with both Content-Digest and Repr-Digest
</figcaption></figure>
</div>

<p>
上の応答~messageにおける［
`Content-Digest$h, `Repr-Digest$h
］は、
異なることに注意：
◎
In the response message above, note that the Repr-Digest and Content-Digests are different.＼
</p>
<ul>
	<li>
`Repr-Digest$h の`~field値$は、
~JSON~obj全体
`{"hello": "world"}^c
から計算される
⇒
`sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:^c【！`】
◎
The Repr-Digest field-value is calculated across the entire JSON object {"hello": "world"}, and the field is
◎
Repr-Digest: sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:`
</li>
	<li>
一方で， `Content-Digest$h の`~field値$は、［
当の~messageの`内容$は、
`bytes 1-7^c 【 0 から数えて 1 番 から 7 番までの，~byte単位による範囲】
に拘束される
］ので，
~byte列 `"hello"^c から計算される
⇒
`sha-256=:Wqdirjg/u3J688ejbUlApbjECpiUUtIwT8lY/z81Tno=:^c
◎
However, since the message content is constrained to bytes 1-7, the Content-Digest field-value is calculated over the byte sequence "hello", thus resulting in
◎
NOTE: '\' line wrapping per RFC 8792

Content-Digest: \
  sha-256=:Wqdirjg/u3J688ejbUlApbjECpiUUtIwT8lY/z81Tno=:
</li>
</ul>

		</section>
		<section id="client-and-server-provide-full-representation-data">
<h3 title="Client and Server Provide Full Representation Data">B.4. ~client, ~serverどちらも全部的な表現~dataを供する例</h3>

<p>
要請は、同封された表現から計算された `Repr-Digest$h `~field値$を包含する。
また，`~client$は、
当の要請に値 `br^c を伴う `Accept-Encoding$h ~headerを内包して，
`Brotli^i 符号化法を~supportすることを広告する。
◎
The request contains a Repr-Digest field-value calculated on the enclosed representation. It also includes an Accept-Encoding: br header field that advertises the client supports Brotli encoding.
</p>

<p>
対する応答は、
値 `br^c を伴う `Content-Encoding$h ~headerを内包する
— それは、`選定された表現$は `Brotli^i に符号化されたことを指示する。
したがって `Repr-Digest$h `~field値$は，要請のそれとは異なる。
◎
The response includes a Content-Encoding: br that indicates the selected representation is Brotli-encoded. The Repr-Digest field-value is therefore different compared to the request.
</p>

<p>
応答の`内容$は、
印字不能な文字を包含するので，
呈示~目的においては `Base64^i に符号化された文字列として表示される。
◎
For presentation purposes, the response body is displayed as a Base64-encoded string because it contains non-printable characters.
</p>

<div class="example">
<figure id="figure-name-put-request-with-digest">
<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Repr-Digest: sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

{"hello": "world"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `PUT$m 要請
◎
Figure 16: PUT Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-enc">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Location: /items/123
Content-Encoding: br
Content-Length: 22
Repr-Digest: sha-256=:4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=:

iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==
</pre>
<figcaption>
対する応答は、
符号化された内容【！応答】の `Repr-Digest$h を伴う
◎
Figure 17: Response with Digest of encoded response
</figcaption></figure>
</div>

		</section>
		<section id="client-provides-full-representation-data-server-provides-no-representation-data">
<h3 title="Client Provides Full Representation Data, Server Provides No Representation Data">B.5. ~clientは全部的な表現~dataを供する, ~serverは表現~dataを供さない例</h3>

<p>
要請の `Repr-Digest$h `~field値$は、
同封された`内容$から計算される。
◎
The request Repr-Digest field-value is calculated on the enclosed payload.
</p>

<p>
対する応答の `Repr-Digest$h `~field値$は、
応答が`内容$を包含しないときでも，`表現~header$【！表現~metadata~header】に依存する
— この例では、［
値 `br^c を伴う `Content-Encoding$h ~header
］もそれに含まれる。
◎
The response Repr-Digest field-value depends on the representation metadata header fields, including Content-Encoding: br even when the response does not contain content.
</p>

<div class="example">
<figure>
<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Length: 18
Accept-Encoding: br
Repr-Digest: sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

{"hello": "world"}
</pre>
<figcaption>
内容の `Repr-Digest$h を伴う要請
◎
</figcaption></figure>

<figure id="figure-name-empty-response-with-digest">
<pre class="lang-http">
HTTP/1.1 204 No Content
Content-Type: application/json
Content-Encoding: br
Repr-Digest: sha-256=:4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=:

</pre>
<figcaption>
対する応答は、
`Repr-Digest$h を伴うが，内容は伴わない
◎
Figure 18: Empty response with Digest
</figcaption></figure>
</div>

		</section>
		<section id="client-and-server-provide-full-representation-data-1">
<h3 title="Client and Server Provide Full Representation Data">B.6. ~client, ~serverどちらも全部的な表現~dataを供する例</h3>

<p>
応答は、
異なる~algoを利用して， 2 個の~digest値を包含する：
◎
The response contains two digest values using different algorithms.
</p>

<p>
応答の`内容$は、印字不能な文字を包含するので，ここでは~base64に符号化された文字列として表示されている。
◎
As the response body contains non-printable characters, it is displayed as a base64-encoded string.
</p>

<div class="example">
<figure id="figure-name-put-request-with-digest-2">
<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Repr-Digest: sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

{"hello": "world"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `PUT$m 要請
◎
Figure 19: PUT Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-enco">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: br
Content-Location: /items/123
Repr-Digest: \
  sha-256=:4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=:,\
  sha-512=:pxo7aYzcGI88pnDnoSmAnaOEVys0MABhgvHY9+VI+ElE60jBCwnMPyA/\
  s3NF3ZO5oIWA7lf8ukk+5KJzm3p5og==:

iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==
</pre>
<figcaption>
対する応答は、
符号化された内容の `Repr-Digest$h を伴う
◎
Figure 20: Response with Digest of Encoded Content
</figcaption></figure>
</div>

		</section>
		<section id="post-not-request-uri">
<h3 title="POST Response does not Reference the Request URI">B.7. `POST^m に対する応答は要請~URIを参照しない例</h3>

<p>
要請 `Repr-Digest$h `~field値$は、
同封された表現から算出される
（ `3.1§ を見よ）。
◎
The request Repr-Digest field-value is computed on the enclosed representation (see Section 3.1).
</p>

<p>
応答~内に同封された表現は
`Content-Location$h により識別される`資源$を指す
（ `HTTP$r `内容の識別-法＠~HTTPinfra#identifying.content§を見よ）。
したがって， `Repr-Digest$h は、
同封された表現から算出される。
◎
The representation enclosed in the response refers to the resource identified by Content-Location (see Section 6.4.2 of [HTTP]). Repr-Digest is thus computed on the enclosed representation.
</p>

<div class="example">
<figure id="figure-name-post-request-with-digest">
<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Repr-Digest: sha-256=:bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=:

{"title": "New Title"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `POST$m 要請
◎
Figure 21: POST Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-res">
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /books/123
Location: /books/123
Repr-Digest: sha-256=:yxOAqEeoj+reqygSIsLpT0LhumrNkIds5uLKtmdLyYE=:

{
  "id": "123",
  "title": "New Title"
}
</pre>
<figcaption>
対する応答は、
資源の `Repr-Digest$h を伴う
◎
Figure 22: Response with Digest of Resource
</figcaption></figure>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、
同じ `Repr-Digest$h `~field値$を伴うなら合法的になることに注意。
その事例では、
`Content-Digest$h は，空な`内容$に対し算出した結果になろう。
◎
Note that a 204 No Content response without content but with the same Repr-Digest field-value would have been legitimate too. In that case, Content-Digest would have been computed on an empty content.
</p>

		</section>
		<section id="post-referencing-status">
<h3 title="POST Response Describes the Request Status">B.8. `POST^m に対する応答は要請の状態sを述べる例</h3>

<p>
要請 `Repr-Digest$h `~field値$は、
同封された表現から算出される
（ `3.1§ を見よ）。
◎
The request Repr-Digest field-value is computed on the enclosed representation (see Section 3.1).
</p>

<p>
対する応答~内に同封された`表現$は、
要請の状態sを述べるので、
`Repr-Digest$h は，その同封された表現から算出される。
◎
The representation enclosed in the response describes the status of the request, so Repr-Digest is computed on that enclosed representation.
</p>

<p>
応答の `Repr-Digest$h には、
`Location$h により参照された`資源$との明示的な関係は無い。
◎
Response Repr-Digest has no explicit relation with the resource referenced by Location.
</p>

<div class="example">
<figure id="figure-name-post-request-with-digest-2">
<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Repr-Digest: sha-256=:bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=:

{"title": "New Title"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `POST$m 要請
◎
Figure 23: POST Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-rep">
<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Repr-Digest: sha-256=:2LBp5RKZGpsSNf8BPXlXrX4Td4Tf5R5bZ9z7kdi5VvY=:
Location: /books/123

{
  "status": "created",
  "id": "123",
  "ts": 1569327729,
  "instance": "/books/123"
}
</pre>
<figcaption>
対する応答は、
表現の `Repr-Digest$h を伴う
◎
Figure 24: Response with Digest of Representation
</figcaption></figure>
</div>

		</section>
		<section id="digest-with-patch">
<h3 title="Digest with PATCH">B.9. `PATCH^m を伴う~digest</h3>

<p>
この事例は、
`~target資源$が`~target~URI$を反映する所では，
`POST$m 要請に相似的である。
◎
This case is analogous to a POST request where the target resource reflects the effective request URI.
</p>

<p>
`PATCH$m 要請は、
`RFC7396$r にて定義される`~MIME型$
`application/merge-patch+json^c
を利用する。
◎
The PATCH request uses the application/merge-patch+json media type defined in [RFC7396].
</p>

<p>
`Repr-Digest$h は、
要請に同封された`内容$から計算される
— それは、~patch文書に対応する。
◎
Repr-Digest is calculated on the enclosed payload, which corresponds to the patch document.
</p>

<p>
対する応答の `Repr-Digest$h `~field値$は、
~patchされた`資源$の完全な表現から算出される。
◎
The response Repr-Digest field-value is computed on the complete representation of the patched resource.
</p>

<div class="example" id="fig-patch">
<figure id="name-patch-request-with-digest">
<pre class="lang-http">
PATCH /books/123 HTTP/1.1
Host: foo.example
Content-Type: application/merge-patch+json
Accept: application/json
Accept-Encoding: identity
Repr-Digest: sha-256=:bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=:

{"title": "New Title"}
</pre>
<figcaption>
`Repr-Digest$h を伴う `PATCH$m 要請
◎
Figure 25: PATCH Request with Digest
</figcaption></figure>

<figure id="figure-name-response-with-digest-of-repr">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Repr-Digest: sha-256=:yxOAqEeoj+reqygSIsLpT0LhumrNkIds5uLKtmdLyYE=:

{
  "id": "123",
  "title": "New Title"
}
</pre>
<figcaption>
対する応答は、
表現の `Repr-Digest$h を伴う。
◎
Figure 26: Response with Digest of Representation
</figcaption></figure>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、
同じ `Repr-Digest$h `~field値$を伴うなら合法的になることに注意。
◎
Note that a 204 No Content response without content but with the same Repr-Digest field-value would have been legitimate too.
</p>

		</section>
		<section id="error-responses">
<h3 title="Error responses">B.10. ~error応答</h3>

<p>
~error応答†においては、
`表現~data$は`~target資源$を指すとは限らない。
代わりに，~errorの表現を指す。
【†この例では `4xx$st だが、 `5xx$st も含まれるかもしれない。】
◎
In error responses, the representation data does not necessarily refer to the target resource. Instead, it refers to the representation of the error.
</p>

<p>
以下の例では、`~client$は，
`/books/123^c
に所在する資源に~patchするために
`B.9§ の例【！ Figure 25】と同じ要請を送信する。
しかしながら，そこには資源は存在しなかったので、
`~server$は
— `RFC7807$r に則って —
~errorを述べる`内容$を伴う `404$st0 応答を生成する。
◎
In the following example, a client sends the same request from Figure 25 to patch the resource located at /books/123. However, the resource does not exist and the server generates a 404 response with a body that describes the error in accordance with [RFC7807].
</p>

<p>
応答の `Repr-Digest$h `~field値$は、
この同封された表現から算出される。
◎
The response Repr-Digest field-value is computed on this enclosed representation.
</p>

<div class="example">
<figure id="figure-name-response-with-digest-of-err">
<pre class="lang-http">
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
Repr-Digest: sha-256=:KPqhVXAT25LLitV1w0O167unHmVQusu+fpxm65zAsvk=:

{
  "title": "Not Found",
  "detail": "Cannot PATCH a non-existent resource",
  "status": 404
}
</pre>
<figcaption>
対する応答は、
~error表現の `Repr-Digest$h を伴う
◎
Figure 27: Response with Digest of Error Representation
</figcaption></figure>
</div>

		</section>
		<section id="use-with-trailer-fields-and-transfer-coding">
<h3 title="Use with Trailer Fields and Transfer Coding">B.11. ~trailerと転送~符号法との利用</h3>

<p>
ここでは，
`生成元~server$は `Repr-Digest$h を`~trailer$として送信するので、
内容を~streamしている間に~digest値を計算でき，
したがって資源の消費を軽減する。
`Repr-Digest$h `~field値$は、
`B.1§ と同じになる
— `Repr-Digest$h は、`転送~符号法$の利用とは独立に設計されるので
（ `3§ を見よ）。
◎
An origin server sends Repr-Digest as trailer field, so it can calculate digest-value while streaming content and thus mitigate resource consumption. The Repr-Digest field-value is the same as in Appendix B.1 because Repr-Digest is designed to be independent from the use of one or more transfer codings (see Section 3).
</p>

<div class="example">
<figure id="figure-name-get-request">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example

</pre>
<figcaption>
`GET$m 要請
◎
Figure 28: GET Request
</figcaption></figure>

<figure id="figure-name-chunked-response-with-diges">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Trailer: Digest

8\r\n
{"hello"\r\n
8
: "world\r\n
2\r\n
"}\r\n
0\r\n
Repr-Digest: sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

</pre>
<figcaption>
`Repr-Digest$h を伴う~chunked応答
【 `\r\n^c は改行, 数字は~spaceの個数を表すと思われる（実際の`内容$を成す文字ではなく）。】
◎
Figure 29: Chunked Response with Digest
</figcaption></figure>
</div>

		</section>
	</section>
	<section id="examples-solicited">
<h2 title="Appendix C. Examples of Want-Repr-Digest Solicited Digest">付録 C. `Want-Repr-Digest^h により請求される `Repr-Digest^h の例</h2>

<p>
以下に挙げる例は、
`~client$が `Want-Repr-Digest$h を利用して `Repr-Digest$h を請求するときのヤリトリをデモる。
`Content-Digest$h と `Want-Content-Digest$h の挙動は一致する。
◎
The following examples demonstrate interactions where a client solicits a Repr-Digest using Want-Repr-Digest. The behavior of Content-Digest and Want-Content-Digest is identical.
</p>

<p>
例のうちいくつかは、
`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.
</p>

<p>
この文書にて述べられる~checksumの仕組みは、
`~MIME型$を問わないことに加え，特定の形式~用の正準-化~algoは供さない。
各~例は、
~spaceも含めて計算される。
◎
Checksum mechanisms described in this document are media-type agnostic and do not provide canonicalization algorithms for specific formats. Examples are calculated inclusive of any space.
</p>

		<section id="server-selects-clients-least-preferred-algorithm">
<h3 title="Server Selects Client's Least Preferred Algorithm">C.1. ~serverは~clientが最も選好しない~algoを選定する例</h3>

<p>
`~client$は、
"`sha$c" を選好している~digestを要請する。
いずれにせよ、
`~server$は "`sha-256$c" で返信してもかまわない。
◎
The client requests a digest, preferring "sha". The server is free to reply with "sha-256" anyway.
</p>

<div class="example">
<figure id="figure-name-get-request-with-want-repr-">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Repr-Digest: sha-256=3, sha=10

</pre>
<figcaption>
`Want-Repr-Digest$h を伴う `GET$m 要請
◎
Figure 30: GET Request with Want-Repr-Digest
</figcaption></figure>

<figure id="figure-name-response-with-different-alg">
<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Repr-Digest: sha-256=:X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=:

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
異なる~algoを伴う
◎
Figure 31: Response with Different Algorithm
</figcaption></figure>
</div>

		</section>
		<section id="ex-server-selects-unsupported-algorithm">
<h3 title="Server Selects Algorithm Unsupported by Client">C.2. ~serverは~clientが~supportされない~algoを選定する例</h3>

<p>
`~client$は、
自身が唯一~supportする "`sha$c" ~digestを要請する。
`~server$は、
"`sha$c" ~digestを包含している応答を生産する~~義務はないので，
代わりに異なる~algoを利用する。
◎
The client requests a "sha" digest because that is the only algorithm it supports. The server is not obliged to produce a response containing a "sha" digest, it instead uses a different algorithm.
</p>

<div class="example">
<figure id="figure-name-get-request-with-want-repr-d">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Repr-Digest: sha=10

</pre>
<figcaption>
`Want-Repr-Digest$h を伴う `GET$m 要請
◎
Figure 32: GET Request with Want-Repr-Digest
</figcaption></figure>

<figure id="figure-name-response-with-unsupported-a">
<pre class="lang-http">
`~SBS-ST$

HTTP/1.1 200 OK
Content-Type: application/json
Repr-Digest: \
  sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrI\
  iYllu7BNNyealdVLvRwEmTHWXvJwew==:

{"hello": "world"}
</pre>
<figcaption>
対する応答は、
~supportされない~algoを伴う
◎
Figure 33: Response with Unsupported Algorithm
</figcaption></figure>
</div>

		</section>
		<section id="server-does-not-support-client-algorithm-and-returns-an-error">
<h3 title="Server Does Not Support Client Algorithm and Returns an Error">C.3. ~serverは~client~algoを~supportしないので~errorを返す例</h3>

<p>
`C.2§ では、［
~clientが選好した~digest~algo
］を~serverが無視する例を与えた。
別法として，`~server$は、要請を却下して~errorを返すこともできる。
◎
Appendix C.2 is an example where a server ignores the client's preferred digest algorithm. Alternatively a server can also reject the request and return an error.
</p>

<p>
この例では、
`~client$は， "`sha$c" `Repr-Digest$h を要請するが，
`~server$は，問題の詳細 `RFC7807$r を伴う~errorを返す。
問題の詳細は、
~errorの`内容$に包含され，
~serverが~supportする~hashing~algoの~listを包含する。
これは純粋に例であり、
そのような内容~用の形式や要件は，この仕様では定義されない。
◎
In this example, the client requests a "sha" Repr-Digest, and the server returns an error with problem details [RFC7807] contained in the content. The problem details contain a list of the hashing algorithms that the server supports. This is purely an example, this specification does not define any format or requirements for such content.
</p>

<div class="example">
<figure id="figure-name-get-request-with-want-repr-di">
<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Repr-Digest: sha=10

</pre>
<figcaption>
`Want-Repr-Digest$h を伴う `GET$m 要請
◎
Figure 34: GET Request with Want-Repr-Digest
</figcaption></figure>

<figure id="figure-name-response-advertising-the-su">
<pre class="lang-http">
HTTP/1.1 400 Bad Request
Content-Type: application/problem+json

{
  "title": "Bad Request",
  "detail": "Supported hashing algorithms: sha-256, sha-512",
  "status": 400
}
</pre>
<figcaption>
対する応答は、
~supportされる~algoを広告する。
◎
Figure 35: Response advertising the supported algorithms
</figcaption></figure>
</div>

		</section>
	</section>
	<section id="migrating-from-rfc-3230">
<h2 title="Appendix D. Migrating from RFC 3230">付録 D. ~RFC 3230 からの移行-法</h2>

<p>
~HTTP~digestは、
入力~dataに~hashing~algoを適用することにより算出される。
~RFC 3230 は、
入力~dataを~~自前の用語 “~instance” として定義した。
~instanceの概念は、
後に，~HTTPの意味論上の用語`表現$に取代された。
“~instance” を`~message$の`内容$を意味すると誤解したのは、
~RFC 3230 の一部の実装と解されている。
`Digest$h ~fieldを`内容$に対し利用することは、
誤りであり，~RFC 3230 を実装する端点どうしを相互運用能の問題へ導く。
◎
HTTP digests are computed by applying a hashing algorithm to input data. RFC 3230 defined the input data as an "instance", a term it also defined. The concept of instance has since been superseded by the HTTP semantic term "representation". It is understood that some implementations of RFC 3230 mistook "instance" to mean HTTP content. Using content for the Digest field is an error that leads to interoperability problems between peers that implement RFC 3230.
</p>

<p>
~RFC 3230 は、［
~HTTPが，今や`選定された表現~data$として定義するもの
］に限り利用することを意図していた。
［
~digest, 表現
］の意味論上の概念は、
`3§ にて， `Repr-Digest^h の定義に伴って説明される。
◎
RFC 3230 was only ever intended to use what HTTP now defines as selected representation data. The semantic concept of digest and representation are explained alongside the definition of the Repr-Digest field (Section 3).
</p>

<p>
`Digest$h と `Repr-Digest$h の構文は異なるが、
この文書が `Repr-Digest$h 用に与える考慮点と一連の例は，
`Digest^h にも等しく適用される
— それらは、
同じ入力~dataに対し演算するので。
`3.1§, `6§, `6.3§ を見よ。
◎
While the syntax of Digest and Repr-Digest are different, the considerations and examples this document gives for Repr-Digest apply equally to Digest because they operate on the same input data; see Section 3.1, Section 6 and Section 6.3.
</p>

<p>
~RFC 3230 は、
`Digest$h ~field内で~message`内容$の~digestも通信できるようにするものでは，決してない
— その能力は、
今や `Content-Digest$h が供する。
◎
RFC 3230 could never communicate the digest of HTTP message content in the Digest field; Content-Digest now provides that capability.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この文書は `RFC3230$r による案に基づく
— その偉業を成された［
`Jeff Mogul^en, `Arthur Van Hoff^en
］両氏に謝意を。
`RFC3230$r を刷新する元の案は、
`MICE^i `内容~符号法$を考査したときに［
`Mark Nottingham^en,
`Jeffrey Yasskin^en,
`Martin Thomson^en
］各氏との興味深い論点から発生した。
◎
This document is based on ideas from [RFC3230], so thanks to Jeff Mogul and Arthur Van Hoff for their great work. The original idea of refreshing RFC3230 arose from an interesting discussion with Mark Nottingham, Jeffrey Yasskin and Martin Thomson when reviewing the MICE content coding.
</p>

<p>
この文書に価値ある貢献をなされた `Julian Reschke^en 氏に謝意を。
［
~bugを報告して／
賢い質問をして／
~textを草案~化あるいは考査して／
~open課題を評価して
］この仕様の改善に助力された，次に挙げる貢献者たちにも
⇒
`Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, Justin Richer, and Erik Wilde^en
◎
Thanks to Julian Reschke for his valuable contributions to this document, and to the following contributors that have helped improve this specification by reporting bugs, asking smart questions, drafting or reviewing text, and evaluating open issues: Mike Bishop, Brian Campbell, Matthew Kerwin, James Manger, Tommy Pauly, Sean Turner, Justin Richer, and Erik Wilde.
</p>

	</section>
	<section id="code-samples">
<h2 title="Code Samples">~code見本</h2>

<p>
`この節は、~RFCとして公表する前に除去されることになる^em。
◎
This section is to be removed before publishing as an RFC.
</p>

<p>
この節では、この文書~全体を通して各~例にて示される `Repr-Digest$h 値を，どう［
生成する／検証する
］かを与える。
◎
How can I generate and validate the Repr-Digest values shown in the examples throughout this document?
</p>

<p>
次の~python3~codeを利用すれば、
ある範囲の符号化法に対し，各種~SHA~algoを利用して~JSON~obj用の~digestを生成できる。
これらは、~base64形式にされることに注意。
この関数は、他の~algoに順応することもできる
— その場合、それらに特有な形式~化~規則を織り込むべきである。
◎
The following python3 code can be used to generate digests for JSON objects using SHA algorithms for a range of encodings. Note that these are formatted as base64. This function could be adapted to other algorithms and should take into account their specific formatting rules.
</p>

<div>
<pre>
import base64, json, hashlib, brotli, logging
log = logging.getLogger()

def encode_item(item, encoding=lambda x: x):
    indent = 2 if isinstance(item, dict) and len(item) &gt; 1 else None
    json_bytes = json.dumps(item, indent=indent).encode()
    return encoding(json_bytes)

def digest_bytes(bytes_, algorithm=hashlib.sha256):
    checksum_bytes = algorithm(bytes_).digest()
    log.warning("Log bytes: \n[`%r^]", bytes_)
    return base64.encodebytes(checksum_bytes).strip()

def digest(item, encoding=lambda x: x, algorithm=hashlib.sha256):
    content_encoded = encode_item(item, encoding)
    return digest_bytes(content_encoded, algorithm)

item = {"hello": "world"}

print("Encoding | hashing algorithm | digest-value")
print("Identity | sha256 |", digest(item))
# Encoding | hashing algorithm | digest-value
# Identity | sha256 | X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

print("Encoding | hashing algorithm | digest-value")
print("Brotli | sha256 |", digest(item, encoding=brotli.compress))
# Encoding | hashing algorithm | digest-value
# Brotli | sha256 | 4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=

print("Encoding | hashing algorithm | digest-value")
print("Identity | sha512 |", digest(item, algorithm=hashlib.sha512))
print("Brotli | sha512 |", digest(item, algorithm=hashlib.sha512,
                                    encoding=brotli.compress))
# Encoding | hashing algorithm | digest-value
# Identity | sha512 |b'WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm'
#                     '+AbwAgBWnrIiYllu7BNNyealdVLvRwEmTHWXvJwew=='
# Brotli | sha512 | b'pxo7aYzcGI88pnDnoSmAnaOEVys0MABhgvHY9+VI+ElE6'
#                   '0jBCwnMPyA/s3NF3ZO5oIWA7lf8ukk+5KJzm3p5og=='

</pre>
</div>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
`この節は、~RFCとして公表する前に除去されることになる^em。
【以下，この節の内容は、未訳。】
◎
This section is to be removed before publishing as an RFC.
</p>

	</section>
</main></div>

