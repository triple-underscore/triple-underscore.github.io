<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'editing',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ー々]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2023-02-23
trans_update:2023-02-23
source_checked:230127
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/popover.html
	abbr_url:HTMLpopover
site_nav:uievents,html
nav_prev:HTMLdnd
nav_next:ORIGIN
trans_1st_pub:2023-01-30

●●class_map
e:element
a:attr
et:event-type
p:property
st:attr-state
v:value
E:error

●●tag_map
I:code
m:code
E:code
c:code
e:code
a:code
et:code
st:span
p:code
v:code
i:i
em:em
cite:cite

●●original_id_map
_popover-target-attribute:the-popover-target-attributes

●●mdn_urls

●●link_map


	●idl

CEReactions:~HEcustom#cereactions

E.InvalidStateError:~WEBIDL#invalidstateerror

I.PopoverTargetElement:#popovertargetelement
I.ToggleEvent:#toggleevent
I.ToggleEventInit:#toggleeventinit
I.PointerEvent:~POINTEREVENTS#pointerevent-interface
	I.Element:~DOM4#interface-element → 要素
	I.Document:~HTMLdom#document → 文書
	I.Node:~DOM4#interface-node → ~node$
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.HTMLCollection:~DOM4#interface-htmlcollection

m.popover:#dom-popover
m.showPopover:#dom-showpopover
m.hidePopover:#dom-hidepopover
m.togglePopover:#dom-togglepopover
m.popoverToggleTargetElement:#dom-popovertoggletargetelement
m.popoverHideTargetElement:#dom-popoverhidetargetelement
m.popoverShowTargetElement:#dom-popovershowtargetelement
m.newState:#dom-toggleevent-newstate
m.oldState:#dom-toggleevent-oldstate

m.cancelable:~DOM4#dom-event-cancelable
m.isTrusted:~DOM4#dom-event-istrusted
m.type:~DOM4#dom-event-type

	●code

e.button:~HEforms#the-button-element
e.dialog:~HEinteractive#the-dialog-element
e.map:~HEimages#the-map-element

a.popover:#attr-popover
a.popoverhidetarget:#attr-popover-hide-target
a.popovershowtarget:#attr-popover-show-target
a.popovertoggletarget:#attr-popover-toggle-target
a.open:~HEinteractive#attr-details-open

v.auto:#attr-popover-auto-keyword
v.manual:#attr-popover-manual-keyword

et.pointerdown:~POINTEREVENTS#the-pointerdown-event
et.pointerup:~POINTEREVENTS#the-pointerup-event
et.beforetoggle:~HTMLindex#event-beforetoggle
et.toggle:~HTMLindex#event-toggle

p.display:~CSSDISP#propdef-display

	●用語
~popover:#_popover-element

st.自動:#attr-popover-auto-state
st.手動:#attr-popover-manual-state
st.~popoverなし:#attr-popover-none-state
~popover可視性~状態:#popover-visibility-state
i.隠している:#popover-hidden-state
i.示している:#popover-showing-state
doc.自動~popover~list:#auto-popover-list
doc.~popover~pointerdown~target:#popover-pointerdown-target
elm.~popover呼出元:#popover-invoker
elm.~popover~toggle~task:#popover-toggle-task
~popover呼出元~群:#popover-invokers
~popover~target属性:#_popover-target-attribute
poT.~task:#popover-toggle-task-task
poT.旧-状態:#popover-toggle-task-old-state
~popover~toggle~event~taskを~queueする:#queue-a-popover-toggle-event-task
~popoverを示す:#show-popover
~popoverを隠す:#hide-popover-algorithm
すべての~popoverを隠す:#hide-all-popovers
すべての~popoverをあるときまで隠す:#hide-all-popovers-until
最上層の~popover先祖:#topmost-popover-ancestor
最上層の自動~popoverを見出す:#topmost-auto-popover
最上層の自動~popover:#topmost-auto-popover
~popoverを~focusする:#popover-focusing-steps
~popoverの妥当性を検査する:#check-popover-validity
~popover~target属性~作動化の挙動:#popover-target-attribute-activation-behavior
~popover~target要素:#popover-target-element
開な~popoverたちを軽く退ける:#light-dismiss-open-popovers
最上層の~clickされた~popover:#topmost-clicked-popover
広義-先祖のうち最も近い開な~popover:#nearest-inclusive-open-popover
呼出元~用の最も近い広義-~target~popover:#nearest-inclusive-target-popover-for-invoker
軽く退ける:#popover-light-dismiss

	●用語（HTML
	~DOM~interface:~HTMLdom#concept-element-dom
文書:~HTMLdom#the-document-object

~HTML要素:~HTMLINFRA#html-elements
切断-:~HTMLINFRA#becomes-disconnected

列挙d属性:~HTMLcms#enumerated-attribute
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
値なし用の既定の状態:~HTMLcms#missing-value-default

既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values
反映する:~HTMLcdom#reflect

~button:~HEforms#concept-button
提出-~button:~HEforms#concept-submit-button

不能化されて:~HTMLforms#concept-fe-disabled
~form所有者:~HTMLforms#form-owner

前回に~focusされた要素:~HEinteractive#previously-focused-element

~DOM~anchor:~HTMLinteraction#dom-anchor
自動focus候補~群:~HTMLinteraction#autofocus-candidates
自動focusは処理-済みか:~HTMLinteraction#autofocus-processed-flag
~focus委任-先:~HTMLinteraction#focus-delegate
~objを~focusする:~HTMLinteraction#focusing-steps
doc.指名する被focus区画:~HTMLinteraction#focused-area-of-the-document

同一-生成元:~ORIGIN#same-origin

bc.作動中の文書:~HTMLds#active-document
属する閲覧~文脈:~HTMLds#concept-document-bc
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context

要素~taskを~queueする:~WAPI#queue-an-element-task
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue
利用者~対話~task源:~WAPI#user-interaction-task-source
~event~handler:~WAPI#event-handlers

	●用語（外部
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
~list:~INFRA#list
空にする:~INFRA#list-empty
空:~INFRA#list-is-empty
set.付加する:~INFRA#set-append
構造体:~INFRA#struct
有順序~map:~INFRA#ordered-map

~node:~DOM4#concept-node
要素:~DOM4#concept-element
~tree順序:~DOM4#concept-tree-order
属性~変更-時の手続き:~DOM4#concept-element-attributes-change-ext
接続されて:~DOM4#connected
子孫:~DOM4#concept-tree-descendant
~eventを発火する:~DOM4#concept-event-fire
~ID:~DOM4#concept-id
~node文書:~DOM4#concept-node-document
doc.生成元:~DOM4#concept-document-origin
根:~DOM4#concept-tree-root
~target:~DOM4#event-target
	誤）~target:~DOM4#concept-event-target

平坦~tree:~CSSSCOPING#flat-tree
表示域:~CSS2VISUREN#viewport

~fullscreenか:~FULLSCREEN#fullscreen-flag
上端~層:~FULLSCREEN#top-layer

	コレ:~WEBIDL#this

●●words_table1

●●words_table

	●UI／呈示
popover:
自動:auto:~
自動focus:autofocus::自動 focus:自動フォーカス
開な:openな:開いた
開いた:openした:開いた
	開いたまま残され:stay open
	最初に開いた方:the first one to open
開かれ:openされ:~
開け:openでき:
閉な:closedな:閉じた
閉じる:closeする:~
閉じな:closeしな:~
閉じれ:closeでき:~
toggle:
示す:showする:~
示して:showして:~
	示している:showing
示され:showされ:~
	示されない:non-showing

隠す:hideする:~
隠し:hideし:~
	隠している:hidden
退ける:dismissする:~
	軽く退けるふるまい:light dismiss
	軽く退ける:light dismiss
	軽く退ける:light-dismiss
被focus:focused::被 focus:被フォーカス
pointerdown:
fullscreen::::全スクリーン
押下げる:pressする:~
touch::::タッチ

	軽い:light
	最も “高い”:highest
	“低く”:lower

	●構造／関係
呼出元:invoker:呼び出し元
広義-:inclusive:~
終端点:endpoint:~
循環な:cyclicな:循環する
最上層の:topmost:~
	上層:top of
指名-:designate::~
anchor::::アンカー
	~popover~target属性$:anchor attribute
	~popover~target属性$:anchor
先祖-:ancestral::~
経路:path:~
	指して:pointing
	自身を指している:points back

	●処理
旧-:old:~
新-:new:~
候補:candidate:~
切断-:disconnect::~
復旧-:restore:~

	起:happen

	%名前空間:namespace
	%局所~名:localName
	%旧-値:oldValue
	%値:value
	%要素:element
	%要素:this element
	%例外を投出するか:throwExceptions
	%文書:~document
	%元の種別:~originalType:#1
	%先祖:~ancestor0:#1
	%元々~focusされた要素:originallyFocusedElement
	%旧-状態:oldState
	%新-状態:newState
	%前回に~focusした要素を~focusするか:focusPreviousElement
	%~eventを発火するか:fireEvents
	%前回に~focusされた要素:previouslyFocusedElement
	%開な~popoverをすべて閉じる:closeAllOpenPopovers
	%~popover:popover
	%隠し残した~popover:lastToHide
	%終端点を見出したか:foundEndpoint
	%新たな~popover:newPopover
	%呼出元:invoker
	%~popover位置~群:popoverPositions
	%~index:~index
	%最上層の~popover先祖:topmostPopoverAncestor
	%先祖を検査する:checkAncestor
	%候補:candidate
	%候補~先祖:candidateAncestor
	%候補~位置:candidatePosition
	%~focusを復旧するべきか:shouldRestoreFocus
	%~node:node
	%~node:currentNode
	%~subject:~subject
	%~control:~control0
	%~top-level文書:topDocument
	%期待される可視性~状態:expectedToBeShowing
	%~ID参照:idref
	%~popover要素:popoverElement
	%~event:~event
	%~target:~target
	%最上層の~popover:topmostPopover
	%同じ~targetか:sameTarget
	%~clickされた~popover:clickedPopover
	%呼出元~popover:invokerPopover
	%~stack位置を取得する:~getStackPosition
	%~popover~list:~popoverList
	%~target~popover:targetPopover
	%終端点:endpoint
	%取消されたか:-
	%~toggle~task:-
	%~task:the just queued task
	%最も近い開な~popover:-

	●仕様
排-:eliminate:~
	きちんと:well-
	表:table
	と称する:call it

	●未分類
	起:happen
	いずれかの:two
	どこか:anywhere

●●html_code_list

■popover-target-attribute-1
<div popover=auto id="foo">
  This is a popover!
</div>
％
<button popovershowtarget="foo">
  Show a popover
</button>

■popover-target-attribute-2
<div popover=manual id="foo">
  This is a popover!
</div>
％
<button popovertoggletarget="foo">
  Show or hide a popover
</button>

●●images

●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ The popover attribute</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — <code class="attr">popover</code> 属性</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ε, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="the-popover-attribute">
<h3 title="The popover attribute">6.11. `popover^a 属性</h3>

<p>
`popover@a
内容~属性は、
どの`~HTML要素$に設定してもヨイ。
指定された場合、
当の要素は，［
示されるようになる
］まで具現化されなくなり、
そうなった時点で，他の~page内容の上層に具現化される。
◎
All HTML elements may have the popover content attribute set. When specified, the element won't be rendered until it becomes shown, at which point it will be rendered on top of other page content.
</p>

<p class="trans-note">【
`popover^en の意味：
他のもの越しに（ `over^en ）飛び出る（ `pop^en ）。
】【
既定の具現化-法（~UA~stylesheet）は、
`§ 具現化 内の § ~flow内容＠~HTMLrendering#flow-content-3$にて見出せる。
具現化（~layout）を もっと詳細に制御する方法は、
従来からある `CSS Positioned Layout＠~CSSPOS$cite に加えて，
`CSS Anchor Positioning＠~CSSWG/css-anchor-position-1/$cite
が受持つことになろう。
】</p>

<p>
`popover$a 属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The popover attribute is an enumerated attribute. The following table lists the states for this attribute:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
</thead><tbody>

<tr><td>`auto@v
<td>`自動$st

<tr><td>空~文字列
<td>`自動$st

<tr><td>`manual@v
<td>`手動$st

<tr><td>
<td>`~popoverなし$st
</tbody></table>

<p>
この属性は、
省略してもヨイ。
`妥当でない値~用の既定の状態$は、
`手動$stとする。
`値なし用の既定の状態$は、
`~popoverなし$stとする。
</p>

<p>
上に挙げた各~状態は、
次を意味する：
</p>
<ul>
	<li>
`自動@st
⇒
開かれたときは、
他の~popoverを閉じることに加え，
`軽く退ける$ふるまいを伴う。

	<li>
`手動@st
⇒
他の~popoverを閉じないことに加え，
`軽く退ける$ふるまいを伴わない。

	<li>
`~popoverなし@st
⇒
【~popoverとして挙動しない。】
</li>
</ul>

<p>
`~popover@
を伴う要素とは、
`~HTML要素$のうち［
その `popover$a 属性の状態 ~NEQ `~popoverなし$st
］を満たすものをいう
（その否定は、
“~popoverを伴わない” ）。
【この定義は、他所を簡便に述べるための，この訳による追加。】
</p>

◎
State｜Keywords｜Description
Auto state｜auto｜Closes other popovers when opened; has light dismiss.
｜The empty string｜
Manual state｜manual｜Does not close other popovers; does not light dismiss.
◎
The attribute may be omitted. The invalid value default is the manual state. The missing value default is the no popover state.
</div>

<p>
`popover@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`popover$a 属性を`反映する$モノトスル。
◎
The popover IDL attribute must reflect the popover attribute, limited to only known values.
</p>

<p>
各`~HTML要素$には、
`~popover可視性~状態@
がある
— その値は，［
`隠している@i
／
`示している@i
］いずれかであり、
初期~時は， `隠している$i とする。
◎
Every HTML element has a popover visibility state, initially hidden, with these potential values:
• hidden
• showing
</p>

<p>
各`文書$は、
次に挙げるものを有する
◎
↓</p>
<ul>
	<li>
`自動~popover~list@doc
⇒
`~list$
— 初期~時は`空$とする。
◎
The Document has an auto popover list, which is a list, initially empty.
</li>
	<li>
`~popover~pointerdown~target@doc
⇒
ある`~HTML要素$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
The Document has a popover pointerdown target, which is an HTML element or null, initially null.
</li>
</ul>

<p>
各`~HTML要素$は、
次に挙げるものを有する
◎
↓</p>
<ul>
	<li>
`~popover呼出元@elm
⇒
`~HTML要素$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
Every HTML element has a popover invoker, which is an HTML element or null, initially set to null.
</li>
	<li>
<p>
`~popover~toggle~task@elm
⇒
~NULL ／ `構造体$
— 初期~時は ~NULLとする。
◎
Every HTML element has a popover toggle task, initially null, which is either null or a struct＼
</p>

<p>
この`構造体$は、
次に挙げる~itemからなる：
◎
which has:
</p>
		<ul>
			<li>
`~task@poT
⇒
`~task$
— `ToggleEvent$I を発火するための。
◎
Task
• A task which fires a ToggleEvent.
</li>
			<li>
`旧-状態@poT
⇒
文字列
— `~task$poTにより発火される~eventの `oldState$m 属性~用の値を表現する。
◎
Old state
• A string which represents the task's event's value for the oldState attribute.
</li>
		</ul>
	</li>
</ul>

<div class="algo">
<p>
すべての`~HTML要素$は、
`属性~変更-時の手続き$として次を利用する
— それは、
所与の
( %局所~名, %旧-値, %値, %名前空間 )
に対し：
◎
The following attribute change steps are used for all HTML elements:
</p>
<ol>
	<li>
~IF［
%名前空間 ~NEQ ~NULL
］
⇒
~RET
◎
If namespace is not null, then return.
</li>
	<li>
~IF［
%局所~名 ~NEQ "`popover$a"
］
⇒
~RET
◎
If localName is not popover, then return.
</li>
	<li>
~IF［
`popover$a 属性が［
%旧-値 をとるときの状態, %値 をとるときの状態
］は異なる
］
⇒
`~popoverを隠す$( %要素, ~T, ~T, ~F )
◎
If oldValue and value are in different states, then run the hide popover algorithm given element, true, true, and false.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%element.`showPopover()$m</dt>
	<dd>
`~popover$を伴う %element を`上端~層$に追加することにより，
%element を示す。
%element の `popover$a 属性の状態 ~EQ `自動$stならば、
これは，同じ状態にある他の要素のうち［
`最上層の~popover先祖$を見出す~algoに則って，
%element の先祖であるもの
］を除くすべてを閉じることになる。
◎
Shows the popover element by adding it to the top layer. If element's popover attribute is in the auto state, then this will also close all other auto popovers unless they are an ancestor of element according to the topmost popover ancestor algorithm.
</dd>

	<dt>%element.`hidePopover()$m</dt>
	<dd>
`~popover$を伴う %element を`上端~層$から除去した上で、［
%element に
<code class="css">`display$p: `none^v</code>
を適用する
］ことにより，
%element を隠す。
◎
Hides the popover element by removing it from the top layer and applying display: none to it.
</dd>

	<dt>%element.`togglePopover()$m</dt>
	<dd>
`~popover$を伴う %element を［
隠しているならば示す／
示しているならば隠す
］。
◎
If the popover element is not showing, then this method shows it. Otherwise, this method hides it.
</dd>
</dl>

<div class="algo">
`showPopover()@m
~method手続きは
⇒
`~popoverを示す$( コレ, ~T )
◎
The showPopover() method steps are:
• Run show popover given this and true.
</div>

<div class="algo">
<p>
`~popoverを示す@
ときは、
所与の
( `~HTML要素$ %要素, 真偽値 %例外を投出するか )
に対し：
◎
To show popover, given an HTML element element and a boolean throwExceptions:
</p>
<ol>
	<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `隠している$i ) ~EQ ~F
］：
◎
If the result of running check popover validity given element and false is false, then:
</p>
		<ol>
			<li>
~Assert：
%例外を投出するか ~EQ ~T
◎
Assert: throwExceptions is true.
</li>
			<li>
~THROW `InvalidStateError$E
◎
Throw an "InvalidStateError" DOMException.
</li>
		</ol>
	</li>
	<li>
~Assert：
%要素 ~NIN %要素 の`~node文書$の`上端~層$
◎
Assert: element is not in element's node document's top layer.
</li>
	<li>
%取消されたか ~LET `~eventを発火する$( %要素, `beforetoggle$et, `ToggleEvent$I )
— 次のように初期化して
⇒＃
`cancelable$m 属性 ~SET ~T
`oldState$m 属性 ~SET `closed^l,
`newState$m 属性 ~SET `open^l
◎
↓</li>
	<li>
~IF［
%取消されたか ~EQ ~F
］
⇒
~RET
◎
If the result of firing an event named beforetoggle, using ToggleEvent, with the cancelable attribute initialized to true, the oldState attribute initialized to "closed", and the newState attribute initialized to "open" at element is false, then return.
</li>
	<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `隠している$i ) ~EQ ~F
］：
◎
If the result of running check popover validity given element and false is false:
</p>
		<ol>
			<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If throwExceptions is true, then throw an "InvalidStateError" DOMException.
</li>
			<li>
~RET
◎
Otherwise, return.
</li>
		</ol>

<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、［
上で発火した `beforetoggle$et ~event
］用の`~event~handler$が［
%要素 を`切断-$し得る／
%要素 の `popover$a 属性を変更し得る
］からである。
◎
Check popover validity is called again because firing the beforetoggle event could have disconnected this element or changed its popover attribute.
</p>
	</li>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
%~focusを復旧するべきか ~LET ~F
◎
Let shouldRestoreFocus be false.
</li>
	<li>
<p>
~IF［
%要素 の `popover$a 属性の状態 ~EQ `自動$st
］：
◎
If element's popover attribute is in the auto state, then:
</p>
		<ol>
			<li>
%元の種別 ~LET %要素 の `popover$a 属性の値
◎
Let originalType be the value of element's popover attribute.
</li>
			<li>
%先祖 ~LET `最上層の~popover先祖$( %要素 )
◎
Let ancestor be the result of running the topmost popover ancestor algorithm given element.
</li>
			<li>
~IF［
%先祖 ~EQ ~NULL
］
⇒
%先祖 ~SET %文書
◎
If ancestor is null, then set ancestor to document.
</li>
			<li>
`すべての~popoverをあるときまで隠す$( %先祖, ~F, ~T )
◎
Run hide all popovers until given ancestor, false, and true.
</li>
			<li>
<p>
~IF［
%元の種別 ~NEQ %要素 の `popover$a 属性の値
］~OR［
`~popoverの妥当性を検査する$( %要素, `隠している$i ) ~EQ ~F
］：
◎
If originalType is not equal to the value of element's popover attribute, or if the result of running check popover validity given element and false is false:
</p>
				<ol>
					<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If throwExceptions is true, then throw an "InvalidStateError" DOMException.
</li>
					<li>
~RET
◎
Otherwise, return.
</li>
				</ol>
<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、［
上で`すべての~popoverをあるときまで隠す$ときに発火され得る `beforetoggle$et ~event
］用の`~event~handler$が［
%要素 を`切断-$し得る／
%要素 に対し `showPopover()$m を~callし得る
］からである。
◎
Check popover validity is called again because running hide all popovers until above could have fired the beforetoggle event, and an event handler could have disconnected this element or called showPopover() on this element.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`最上層の自動~popover$( %文書 ) ~EQ ~NULL
］
⇒
%~focusを復旧するべきか ~SET ~T
◎
If the result of running topmost auto popover on document is null, then set shouldRestoreFocus to true.
</p>

<p class="note">注記：
これは、［
当の~stackを成す最初の~popover用に限り，
前回に~focusした要素に~focusを返す
］ことを確保する。
◎
This ensures that focus is returned to the previously-focused element only for the first popover in a stack.
</p>
	</li>
	<li>
%文書 の`自動~popover~list$docに %要素 を`付加する$【！Add】
◎
Add element to document's auto popover list.
</li>
	<li>
%要素 の`前回に~focusされた要素$ ~SET ~NULL
◎
Set element's previously focused element to null.
</li>
	<li>
%元々~focusされた要素 ~LET %文書 が`指名する被focus区画$docの`~DOM~anchor$
◎
Let originallyFocusedElement be document's focused area of the document's DOM anchor.
</li>
	<li>
%文書 の`上端~層$に %要素 を`付加する$set【！Add】
◎
Add element to document's top layer.
</li>
	<li>
%要素 の`~popover可視性~状態$ ~SET `示している$i
◎
Set element's popover visibility state to showing.
</li>
	<li>
`~popoverを~focusする$( %要素 )
◎
Run the popover focusing steps given element.
</li>
	<li>
~IF［
%~focusを復旧するべきか ~EQ ~T
］~AND［
%要素 は`~popover$を伴う
］
⇒
%要素 の`前回に~focusされた要素$ ~SET %元々~focusされた要素
◎
If shouldRestoreFocus is true and element's popover attribute is not in the no popover state, then set element's previously focused element to originallyFocusedElement.
</li>
	<li>
`~popover~toggle~event~taskを~queueする$( %要素, `closed^l, `open^l )
◎
Queue a popover toggle event task given element, "closed", and "open".
</li>
</ol>
</div>

<div class="algo">
<p>
`~popover~toggle~event~taskを~queueする@
ときは、
所与の
( 要素 %要素, 文字列 %旧-状態, 文字列 %新-状態 )
に対し：
◎
To queue a popover toggle event task given an element element, a string oldState, and a string newState:
</p>
<ol>
	<li>
%~toggle~task ~LET %要素 の`~popover~toggle~task$elm
◎
↓</li>
	<li>
<p>
~IF［
%~toggle~task ~NEQ ~NULL
］：
◎
If element's popover toggle task is not null, then:
</p>
		<ol>
			<li>
%旧-状態 ~SET %~toggle~task の`旧-状態$poT
◎
Set oldState to element's popover toggle task's old state.
</li>
			<li>
%~toggle~task の`~task$poTを【それが属する】`~task~queue$から除去する
◎
Remove element's popover toggle task's task from its task queue.
</li>
			<li>
%要素 の`~popover~toggle~task$elm ~SET ~NULL
◎
Set element's popover toggle task to null.
</li>
		</ol>
	</li>
	<li>
<p>
%~task ~LET `要素~taskを~queueする$( `利用者~対話~task源$, %要素, 次の手続き )
◎
Queue an element task given the user interaction task source and element＼
</p>

<div class="algo">
<p>
手続きは、
次を走らす：
◎
to run the following steps:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `toggle$et, `ToggleEvent$I )
— 次のように初期化して
⇒＃
`oldState$m 属性 ~SET %旧-状態,
`newState$m 属性 ~SET %新-状態
◎
fire an event named toggle, using ToggleEvent, with the oldState attribute initialized to oldState, and the newState attribute initialized to newState at element.
</li>
			<li>
%要素 の`~popover~toggle~task$elm ~SET ~NULL
◎
Set element's popover toggle task to null.
</li>
		</ol>
</div>
	</li>
	<li>
%要素 の`~popover~toggle~task$elm ~SET 次に挙げる~itemからなる`構造体$
⇒＃
`~task$poT ~SET %~task,
`旧-状態$poT ~SET %旧-状態
◎
Set element's popover toggle task to a struct with task set to the just-queued task and old state set to oldState.
</li>
</ol>
</div>

<div class="algo">
<p>
`hidePopover()@m
~method手続きは：
◎
The hidePopover() method steps are:
</p>
<ol>
	<li>
`~popoverを隠す$( コレ, ~T, ~T, ~T )
◎
Run the hide popover algorithm given this, true, true, and true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popoverを隠す@
ときは、
所与の
⇒＃
`~HTML要素$ %要素,
真偽値 %前回に~focusした要素を~focusするか,
真偽値 %~eventを発火するか,
真偽値 %例外を投出するか
◎終
に対し：
◎
To hide a popover given an HTML element element, a boolean focusPreviousElement, a boolean fireEvents, and a boolean throwExceptions:
</p>
<ol>
	<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `示している$i ) ~EQ ~F
］：
◎
If the result of running check popover validity given element and true is false:
</p>
		<ol>
			<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If throwExceptions is true, then throw an "InvalidStateError" DOMException.
</li>
			<li>
~RET
◎
Otherwise, return.
</li>
		</ol>
	</li>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
<p>
~IF［
%要素 の `popover$a 属性の状態 ~EQ `自動$st
］：
◎
If element's popover attribute is in the auto state, then:
</p>
		<ol>
			<li>
`すべての~popoverをあるときまで隠す$( ↓ )
⇒＃
%要素,
%前回に~focusした要素を~focusするか,
%~eventを発火するか
◎
Run hide all popovers until given element, focusPreviousElement, and fireEvents.
</li>
			<li>
<p>
~IF［
%要素 ~NIN %文書 の`自動~popover~list$doc
］：
◎
If element is not in document's auto popover list:
</p>
				<ol>
					<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If throwExceptions is true, then throw an "InvalidStateError" DOMException.
</li>
					<li>
~RET
◎
Otherwise, return.
</li>
				</ol>
			</li>
			<li>
~Assert：
%文書 の`自動~popover~list$docを成す最後の~item ~EQ %要素
◎
Assert: The last item in document's auto popover list is element.
</li>
			<li>
%文書 の`自動~popover~list$docから %要素 を`除去する$
◎
Remove element from document's auto popover list.
</li>
		</ol>
	</li>
	<li>
%要素 の`~popover呼出元$elm ~SET ~NULL
◎
Set element's popover invoker to null.
</li>
	<li>
<p>
~IF［
%~eventを発火するか ~EQ ~T
］：
◎
If fireEvents is true:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `beforetoggle$et, `ToggleEvent$I )
— 次のように初期化して
⇒＃
`oldState$m 属性 ~SET `open^l,
`newState$m 属性 ~SET `closed^l
◎
Fire an event named beforetoggle, using ToggleEvent, with the oldState attribute initialized to "open", and the newState attribute initialized to "closed" at element.
</li>
			<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `示している$i ) ~EQ ~F
］：
◎
If the result of running check popover validity given element and true is false:
</p>
				<ol>
					<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If throwExceptions is true, then throw an "InvalidStateError" DOMException.
</li>
					<li>
~RET
◎
Otherwise, return.
</li>
				</ol>

<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、［
上で発火した `beforetoggle$et ~event
］用の`~event~handler$が［
%要素 を`切断-$し得る／
%要素 の `popover$a 属性を変更し得る
］からである。
◎
Check popover validity is called again because firing the beforetoggle event could have disconnected this element or changed its popover attribute.
</p>
			</li>
		</ol>
	</li>
	<li>
`上端~層$から %要素 を`除去する$
◎
Remove element from the top layer.
</li>
	<li>
%要素 の`~popover可視性~状態$ ~SET `隠している$i
◎
Set element's popover visibility state to hidden.
</li>
	<li>
~IF［
%~eventを発火するか ~EQ ~T
］
⇒
`~popover~toggle~event~taskを~queueする$( %要素, `open^l, `closed^l )
◎
If fireEvents is true, then queue a popover toggle event task given element, "open", and "closed".
</li>
	<li>
%前回に~focusされた要素 ~LET %要素 の`前回に~focusされた要素$
◎
Let previouslyFocusedElement be element's previously focused element.
</li>
	<li>
<p>
~IF［
%前回に~focusされた要素 ~NEQ ~NULL
］：
◎
If previouslyFocusedElement is not null, then:
</p>
		<ol>
			<li>
%要素 の`前回に~focusされた要素$ ~SET ~NULL
◎
Set element's previously focused element to null.
</li>
			<li>
<p>
~IF［
%前回に~focusした要素を~focusするか ~EQ ~T
］
⇒
`~objを~focusする$( %前回に~focusされた要素 )
◎
If focusPreviousElement is true, then run the focusing steps for previouslyFocusedElement;＼
</p>

<p>
この段を行うときは、
`表示域$は~scrollされるベキでない。
◎
the viewport should not be scrolled by doing this step.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`togglePopover(force)@m
~method手続きは：
◎
The togglePopover(force) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`~popover可視性~状態$ ~EQ `示している$i
］~AND［
%force ~IN { ε, ~F }
］
⇒
`~popoverを隠す$( コレ, ~T, ~T, ~T )
◎
If this's popover visibility state is showing, and force is not present or false, then run the hide popover algorithm given this, true, true, and true.
</li>
	<li>
~ELIF［
%force ~IN { ε, ~T }
］
⇒
`~popoverを示す$( コレ, ~T )
◎
Otherwise, if force is not present or true, then run show popover given this and true.
</li>
</ol>
</div>

<div class="algo">
<p>
`すべての~popoverをあるときまで隠す@
ときは、
所与の
⇒＃
［`~HTML要素$／`文書$］ %終端点,
真偽値 %前回に~focusした要素を~focusするか,
真偽値 %~eventを発火するか
◎終
に対し：
◎
To hide all popovers until, given an HTML element or Document endpoint, a boolean focusPreviousElement, and a boolean fireEvents:
</p>
<ol>
	<li>
%文書 ~LET %終端点 の`~node文書$
◎
Let document be endpoint's node document.
</li>
	<li class="algo">
<p>
%開な~popoverをすべて閉じる ~LET 次の手続きを遂行する~algo：
◎
Let closeAllOpenPopovers be an algorithm which performs the following steps:
</p>
		<ol>
			<li>
<p>
~WHILE 無条件：
</p>
				<ol>
					<li>
%~popover ~LET %文書 の`最上層の自動~popover$
</li>
					<li>
~IF［
%~popover ~EQ ~NULL
］
⇒
~BREAK
</li>
					<li>
`~popoverを隠す$( ↓ )
⇒＃
%~popover,
%前回に~focusした要素を~focusするか,
%~eventを発火するか,
~F
</li>
				</ol>
◎
Let popover be document's topmost auto popover.
◎
While popover is not null:
• Run the hide popover algorithm given popover, focusPreviousElement, fireEvents, and false.
• Set popover to document's topmost auto popover.
</li>
		</ol>
	</li>
	<li>
~IF［
%終端点 ~EQ ~NULL
］
⇒＃
%開な~popoverをすべて閉じる()；
~RET
◎
If endpoint is null, then run closeAllOpenPopovers and return.
</li>
	<li>
%隠し残した~popover ~LET ~NULL
◎
Let lastToHide be null.
</li>
	<li>
%終端点を見出したか ~LET ~F
◎
Let foundEndpoint be false.
</li>
	<li>
<p>
%文書 の`自動~popover~list$docを成す
~EACH( %~popover )
に対し：
◎
For each popover in document's auto popover list:
</p>
		<ol>
			<li>
~IF［
%~popover ~EQ %終端点
］
⇒
%終端点を見出したか ~SET ~T
◎
If popover is endpoint, then set foundEndpoint to true.
</li>
			<li>
~ELIF［
%終端点を見出したか ~EQ ~T
］
⇒＃
%隠し残した~popover ~SET %~popover；
~BREAK
◎
Otherwise, if foundEndpoint is true, then set lastToHide to popover and break.
</li>
		</ol>
	</li>
	<li>
~IF［
%終端点を見出したか ~EQ ~F
］
⇒＃
%開な~popoverをすべて閉じる()；
~RET
◎
If foundEndpoint is false, then run closeAllOpenPopovers and return.
</li>
	<li>
<p>
~WHILE［
%隠し残した~popover ~NEQ ~NULL
］~AND［
%隠し残した~popover の`~popover可視性~状態$ ~EQ `示している$i
］~AND［
%文書 の`自動~popover~list$docは`空$でない
］
⇒
`~popoverを隠す$( ↓ )
⇒＃
%文書 の`自動~popover~list$docを成す最後の要素,
%前回に~focusした要素を~focusするか,
%~eventを発火するか,
~F
◎
While lastToHide is not null and lastToHide's popover visibility state is showing and document's auto popover list is not empty:
• Run the hide popover algorithm given document's auto popover list's last element, focusPreviousElement, fireEvents, and false.
</li>
</ol>

<p class="note">注記：
`すべての~popoverをあるときまで隠す$
は、
いくつかの事例で，~popoverのうち［
何かが起きたときでも，開いたまま残されるもの
］以外のもの すべてを隠すために利用される。
例えば，この~algoは、
~popoverを`軽く退ける$間は，~popoverのうち［
利用者により~clickされた~nodeに関係しないもの
］に限り閉じることを確保する。
◎
The hide all popovers until algorithm is used in several cases to hide all popovers that don't stay open when something happens. For example, during light-dismiss of a popover, this algorithm ensures that we close only the popovers that aren't related to the node clicked by the user.
</p>
</div>

<div class="algo">
<p>
`すべての~popoverを隠す@
ときは、
所与の
( `文書$ %文書 )
に対し
⇒
`すべての~popoverをあるときまで隠す$( %文書, ~F, ~F )
◎
To hide all popovers, given a Document document, run hide all popovers until given document, false, and false.
</p>
</div>

<div class="algo">
<p>
`最上層の~popover先祖@
を見出すときは、
所与の
( `~node$ %新たな~popover )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To find the topmost popover ancestor, given a Node newPopover, perform the following steps. They return an HTML element or null.
</p>

<div class="note">
<p>注記：
`最上層の~popover先祖$
~algoは、
供された~popover用に最上層の
（`自動~popover~list$doc内で最も “高い” 【手前に描画される／~list内で後に来る】）
先祖~popoverを返すことになる。
~popoverたちは、
いくつかの仕方で互いに関係し得ることにより，それらが成す~treeを作成する。
ある~popover（以下では “子” ~popoverと称する）は、
次に挙げる経路を通して，
先祖~popover（以下では “親” ~popover と称する）を有し得る：
◎
The topmost popover ancestor algorithm will return the topmost (highest in the auto popover list) ancestor popover for the provided popover. Popovers can be related to each other in several ways, creating a tree of popovers. There are two paths through which one popover (call it the "child" popover) can have an ancestor popover (call it the "parent" popover):
</p>
<ul>
	<li>
~DOM~treeの中で，ある~popoverを別の~popoverが入子にしているとき。
この事例では、
前者が “子”, 後者が “親” になる。
◎
The popovers are nested within each other in the DOM tree. In this case, the descendant popover is the "child" and its ancestor popover is the "parent".
</li>
	<li>
何かを呼出している要素 %要素 （例： `button$e ）が，
ある`~popover~target属性$（例： `popovertoggletarget$a ）を有していて、
それは，ある~popoverを指しているとき。
この事例では、
当の~popoverが “子” になり， %要素 を包含している ある~popoverが “親” になる。
呼出元【すなわち，%要素 】は、
~DOM内で ある~popover内に在って，ある開な~popoverを参照していなければならない。
◎
An invoking element (e.g. a button) has one of the invoking attributes (e.g. popovertoggletarget) pointing to a popover. In this case, the popover is the "child", and the DOM-contained popover of the invoking element is the "parent". The invoker must be in a popover and reference an open popover.
</li>
</ul>

<p>
上により形成される各~関係性において、
親~popoverは，
`自動~popover~list$doc内で，子~popoverより厳密に “低く” ならなければならない
— さもなければ、
妥当な先祖-関係性を形成しない。
これは、［
示されない~popover／
自己-~pointer
（例：自身を指している`~popover~target属性$を有する~popover）
］を排することに加え，［
（場合によっては循環な）接続たちが成す~graphから，きちんと形成された~treeを構築する
］ことを許容する。
例えば， 2 つの~popoverが互いに他方を指している`~popover~target属性$を有する場合、
妥当な関係性は，［
最初に【他方を】開いた方の~popoverが “親”, もう一方が “子” である場合
］に限られる。
ここで考慮されるのは、［
`popover$a 属性の状態 ~EQ `自動$st
］を満たす~popoverに限られる。
◎
In each of the relationships formed above, the parent popover must be strictly lower in the auto popover list than the child popover, or it does not form a valid ancestral relationship. This eliminates non-showing popovers and self-pointers (e.g. a popover with an anchor attribute that points back to the same popover), and it allows for the construction of a well-formed tree from the (possibly cyclic) graph of connections. For example, if two popovers have anchors pointing to each other, the only valid relationship is that the first one to open is the "parent" and the second is the "child". Only auto popovers are considered.
</p>
</div>

<ol>
	<li>
%~popover位置~群 ~LET 新たな`有順序~map$【！~HEimages#the-map-element】
◎
Let popoverPositions be an empty map.
</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
%文書 ~LET %新たな~popover の`~node文書$
◎
Let document be newPopover's node document.
</li>
	<li>
<p>
%文書 の`自動~popover~list$docを成す
~EACH( %~popover )
に対し：
◎
For each popover in document's auto popover list:
</p>
		<ol>
			<li>
%~popover位置~群[ %~popover ] ~SET %~index
◎
Set popoverPositions[popover] to index.
</li>
			<li>
%~index ~INCBY 1
◎
Increment index by 1.
</li>
		</ol>
	</li>
	<li>
%~popover位置~群[ %新たな~popover ] ~SET %~index
◎
Set popoverPositions[newPopover] to index.
</li>
	<li>
%~index ~INCBY 1
◎
Increment index by 1.
</li>
	<li>
%最上層の~popover先祖 ~LET ~NULL
◎
Let topmostPopoverAncestor be null.
</li>
	<li class="algo">
<p>
%先祖を検査する ~LET 所与の
( %候補 )
に対し，次の手続きを遂行する~algo：
◎
Let checkAncestor be an algorithm which performs the following steps given candidate:
</p>
		<ol>
			<li>
~IF［
%候補 ~EQ ~NULL
］
⇒
~RET
◎
If candidate is null, then return.
</li>
			<li>
%候補~先祖 ~LET `広義-先祖のうち最も近い開な~popover$( %候補 )
◎
Let candidateAncestor be the result of running nearest inclusive open popover given candidate.
</li>
			<li>
~IF［
%候補~先祖 ~EQ ~NULL
］
⇒
~RET
◎
If candidateAncestor is null, then return.
</li>
			<li>
%候補~位置 ~LET %~popover位置~群[ %候補~先祖 ]
◎
Let candidatePosition be popoverPositions[candidateAncestor].
</li>
			<li>
~IF［
%最上層の~popover先祖 ~EQ ~NULL
］~OR［
%~popover位置~群[ %最上層の~popover先祖 ] ~LT %候補~位置
］
⇒
%最上層の~popover先祖 ~SET %候補~先祖
◎
If topmostPopoverAncestor is null or popoverPositions[topmostPopoverAncestor] is less than candidatePosition, then set topmostPopoverAncestor to candidateAncestor.
</li>
		</ol>
	</li>
	<li>
%最も近い開な~popover ~LET `広義-先祖のうち最も近い開な~popover$( `平坦~tree$における %新たな~popover の親~node )
◎
↓</li>
	<li>
%先祖を検査する( %最も近い開な~popover )
◎
Run checkAncestor given the result of running nearest inclusive open popover given newPopover's parent node within the flat tree.
</li>
	<li>
%文書 の`~popover呼出元~群$を成す
~EACH( %呼出元 )
に対し
⇒
~IF［
%呼出元 の`~popover~target要素$ ~EQ %新たな~popover
］
⇒
%先祖を検査する( %呼出元 )
◎
For each invoker in document's popover invokers:
• If invoker's popover target element is newPopover, then run checkAncestor given invoker.
</li>
	<li>
~RET %最上層の~popover先祖
◎
return topmostPopoverAncestor.
</li>
</ol>
</div>

<div class="algo">
<p>
`広義-先祖のうち最も近い開な~popover@
を見出すときは、
所与の
( `~node$ %~node )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To find the nearest inclusive open popover given a Node node, perform the following steps. They return an HTML element or null.
•↓ Let currentNode be node.
</p>
<ol>
	<li>
<p>
~WHILE［
%~node ~NEQ ~NULL
］：
◎
While currentNode is not null:
</p>
		<ol>
			<li>
~IF［
%~node の `popover$a 属性の状態 ~EQ `自動$st
］~AND［
%~node の`~popover可視性~状態$ ~EQ `示している$i
］
⇒
~RET %~node
◎
If currentNode's popover attribute is in the auto state and currentNode's popover visibility state is showing, then return currentNode.
</li>
			<li>
%~node ~SET `平坦~tree$における %~node の親
◎
Set currentNode to currentNode's parent in the flat tree.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`最上層の自動~popover@
は、
所与の
( `文書$ %文書 )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To find the topmost auto popover given a Document document, perform the following steps. They return an HTML element or null.
</p>
<ol>
	<li>
~IF［
%文書 の`自動~popover~list$docは`空$でない
］
⇒
~RET %文書 の`自動~popover~list$docの最後の要素
◎
If document's auto popover list is not empty, then return document's auto popover list's last element.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popoverを~focusする@
ときは、
所与の
( `~HTML要素$ %~subject )
に対し：
◎
To perform the popover focusing steps for an HTML element subject:
</p>
<ol>
	<li>
%~control ~LET `~focus委任-先$( %~subject, `other^l, ~T )
◎
Let control be the focus delegate of subject given "other" and true.
</li>
	<li>
~IF［
%~control ~EQ ~NULL
］
⇒
~RET
◎
If control is null, then return.
</li>
	<li>
`~objを~focusする$( %~control )
◎
Run the focusing steps given control.
</li>
	<li>
%~top-level文書 ~LET %~control の`~node文書$が`属する閲覧~文脈$の`~top-level閲覧~文脈$にて`作動中の文書$bc
◎
Let topDocument be the active document of control's node document's browsing context's top-level browsing context.
</li>
	<li>
~IF［
( %~control の`~node文書$の`生成元$doc, %~top-level文書 の`生成元$doc )
は`同一-生成元$でない
］
⇒
~RET
◎
If control's node document's origin is not the same as the origin of topDocument, then return.
</li>
	<li>
%~top-level文書 の`自動focus候補~群$を`空にする$
◎
Empty topDocument's autofocus candidates.
</li>
	<li>
%~top-level文書 の`自動focusは処理-済みか$ ~SET ~T
◎
Set topDocument's autofocus processed flag to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popoverの妥当性を検査する@
ときは、
所与の
( `~HTML要素$ %要素,
%期待される可視性~状態 ~IN { `示している$i, `隠している$i } )
に対し，［
次のいずれかが満たされるならば ~F ／
~ELSE_ ~T
］を返す：
◎
To check popover validity for an HTML element element given a boolean expectedToBeShowing, perform the following steps. They return a boolean.
</p>
<ul>
	<li>
%要素 は`~popover$を伴わない
◎
• If element's popover attribute is in the no popover state, then return false.
</li>
	<li>
%要素 は`接続されて$いない
◎
• If element is not connected, then return false.
</li>
	<li>
%期待される可視性~状態 ~NEQ %要素 の`~popover可視性~状態$
◎
• If expectedToBeShowing is true and element's popover visibility state is not showing, then return false.
◎
• If expectedToBeShowing is false and element's popover visibility state is not hidden, then return false.
</li>
	<li>
［
%要素 は `dialog$e 要素である
］~AND［
%要素 は `open$a 属性を有する
］
◎
• If element is a dialog element and has the open attribute, then return false.
</li>
	<li>
%要素 の`~fullscreenか$ ~EQ ~T
◎
• If element's fullscreen flag is set, then return false.
◎
Return true.
</li>
</ul>

<p class="trans-note">【
%期待される可視性~状態 は，原文では真偽値をとるが、
明快にするため，`~popover可視性~状態$がとり得る値をとるよう改める。
】</p>
</div>

			</section>
			<section id="the-popover-target-attributes">
<h4 title="The popover target attributes">6.11.1. ~popover~target属性</h4>

<p>
各`~button$は、
次に挙げる各~内容~属性を有してもヨイ
— これらは、
`~popover~target属性@
と総称される
⇒＃
`popovertoggletarget@a,
`popoverhidetarget@a,
`popovershowtarget@a
◎
Buttons may have the following content attributes, known as the popover target attributes:
• popovertoggletarget
• popoverhidetarget
• popovershowtarget
</p>

<p>
`~popover~target属性$は、
ある種の~buttonが［
`popover$a 属性を伴う要素
］を［
示す／隠す
］ことを許容する。
`~popover~target属性$に指定する値は、
ある［
`popover$a 属性を伴う要素
］の`~ID$でなければナラナイ。
◎
The popover target attributes allow certain types of buttons to show and hide element with the popover attribute. If a popover target attribute is specified, then that attribute's value must be the ID of element with the popover attribute.
</p>

<div class="example">
<p>
`popovershowtarget$a を 開な~popoverにどう利用できるかを次に示す：
◎
The following shows how popovershowtarget can be used to open a popover:
</p>

`popover-target-attribute-1^xCode

<p>
`popovertoggletarget$a が［
`軽く退ける$ことでは閉じれない手動~popover
］をどう［
開ける／閉じれる
］かを次に示す：
◎
The following shows how popovertoggletarget can open and close a manual popover, which can't be closed with light dismiss:
</p>

`popover-target-attribute-2^xCode

</div>

<p>
【！`~DOM~interface$】
◎
DOM interface:
</p>

<pre class="idl">
interface mixin `PopoverTargetElement@I {
  [`CEReactions$] attribute Element? `popoverToggleTargetElement$m;
  [`CEReactions$] attribute Element? `popoverHideTargetElement$m;
  [`CEReactions$] attribute Element? `popoverShowTargetElement$m;
};
</pre>

<p>
`popoverToggleTargetElement@m
~IDL属性は、
`popovertoggletarget$a 属性を`反映する$モノトスル。
◎
The popoverToggleTargetElement IDL attribute must reflect the popovertoggletarget attribute.
</p>

<p>
`popoverHideTargetElement@m
~IDL属性は、
`popoverhidetarget$a 属性を`反映する$モノトスル。
◎
The popoverHideTargetElement IDL attribute must reflect the popoverhidetarget attribute.
</p>

<p>
`popoverShowTargetElement@m
~IDL属性は、
`popovershowtarget$a 属性を`反映する$モノトスル。
◎
The popoverShowTargetElement IDL attribute must reflect the popovershowtarget attribute.
</p>

<div class="algo">
<p>
`~popover~target属性~作動化の挙動@
は、
所与の
( `~node$ %~node )
に対し，次を走らす：
◎
To run the popover target attribute activation behavior given a Node node:
</p>
<ol>
	<li>
%~popover ~LET %~node の`~popover~target要素$
◎
Let popover be node's popover target element.
</li>
	<li>
~IF［
%~popover ~EQ ~NULL
］
⇒
~RET
◎
If popover is null, then return.
</li>
	<li>
<p>
~IF［
%~node は `popovertoggletarget$a 属性を有さない
］：
◎
If node doesn't have the popovertoggletarget attribute, then:
</p>
		<ol>
			<li>
~IF［
%~node は `popovershowtarget$a 属性を有する
］~AND［
%~popover の`~popover可視性~状態$ ~EQ `示している$i
］
⇒
~RET
◎
If node has a popovershowtarget attribute and popover's popover visibility state is showing, then return.
</li>
			<li>
~IF［
%~node は `popoverhidetarget$a 属性を有する
］~AND［
%~popover の`~popover可視性~状態$ ~EQ `隠している$i
］
⇒
~RET
◎
If node has a popoverhidetarget attribute and popover's popover visibility state is hidden, then return.
</li>
		</ol>
	</li>
	<li>
~IF［
%~popover の`~popover可視性~状態$ ~EQ `示している$i
］~AND［
`~popoverの妥当性を検査する$( %~popover, `示している$i ) ~EQ ~T
］
⇒
`~popoverを隠す$( %~popover, ~T, ~T, ~F )
◎
If popover's popover visibility state is showing and the result of running check popover validity given popover and true is true, then run the hide popover algorithm given popover, true, true, and false.
</li>
	<li>
<p>
~ELIF［
%~popover の`~popover可視性~状態$ ~EQ `隠している$i
］~AND［
`~popoverの妥当性を検査する$( %~popover, `隠している$i ) ~EQ ~T
］：
◎
Otherwise, if popover's popover visibility state is hidden and the result of running check popover validity given popover and false is true:
</p>
		<ol>
			<li>
%~popover の`~popover呼出元$elm ~SET %~node
◎
Set popover's popover invoker to node.
</li>
			<li>
`~popoverを示す$( %~popover, ~F )
◎
Run show popover given popover and false.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~popover~target要素@
を取得するときは、
所与の
( `~node$ %~node )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To get the popover target element given a Node node, perform the following steps. They return an HTML element or null.
</p>
<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%~node は`~button$でない
</li>
			<li>
%~node は`不能化されて$いる
</li>
			<li>
［
%~node の`~form所有者$ ~NEQ ~NULL
］~AND［
%~node は`提出-~button$である
］
</li>
		</ul>
<p>
…ならば
⇒
~RET
</p>
◎
If node is not a button, then return null.
◎
If node is disabled, then return null.
◎
If node has a form owner and node is a submit button, then return null.
</li>
	<li>
%~ID参照 ~LET ~NULL
◎
Let idref be null.
</li>
	<li>
~IF［
%~node は `popovertoggletarget$a 属性を有する
］
⇒
%~ID参照 ~SET %~node の `popovertoggletarget$a 属性の値
◎
If node has a popovertoggletarget attribute, then set idref to the value of node's popovertoggletarget attribute.
</li>
	<li>
~ELIF［
%~node は `popovershowtarget$a 属性を有する
］
⇒
%~ID参照 ~SET %~node の `popovershowtarget$a 属性の値
◎
Otherwise, if node has a popovershowtarget attribute, then set idref to the value of node's popovershowtarget attribute.
</li>
	<li>
~ELIF［
%~node は `popoverhidetarget$a 属性を有する
］
⇒
%~ID参照 ~SET %~node の `popoverhidetarget$a 属性の値
◎
Otherwise, if node has a popoverhidetarget attribute, then set idref to the value of node's popoverhidetarget attribute.
</li>
	<li>
~IF［
%~ID参照 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If idref is null, then return null.
</li>
	<li>
%~popover要素 ~LET ［
%~node の`根$の`子孫$のうち［
`要素$であって，その`~ID$ ~EQ %~ID参照
］を満たすもの
］は［
在るならば それらのうち `~tree順序$で最初のもの／
無いならば ~NULL
］
⇒

◎
Let popoverElement be the first element in tree order, within node's root's descendants, whose ID is idref; otherwise, if there is no such element, null.
</li>
	<li>
~IF［
%~popover要素 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If popoverElement is null, then return null.
</li>
	<li>
~IF［
%~popover要素 は`~popover$を伴わない
］
⇒
~RET ~NULL
◎
If popoverElement's popover attribute is in the no popover state, then return null.
</li>
	<li>
~RET %~popover要素
◎
Return popoverElement.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popover呼出元~群@
を取得するときは、
所与の
( `文書$ %文書 )
に対し：
◎
To get the popover invokers given a Document document:
</p>
<ol>
	<li>
~RET 次のようにされた `HTMLCollection$I
⇒＃
根 ~SET %文書,
~filterは`~button$である要素に合致する
◎
Return an HTMLCollection rooted at document whose filter matches elements which are buttons.
</li>
</ol>
</div>

			</section>
			<section id="popover-light-dismiss">
<h4 title="Popover light dismiss">6.11.2. ~popoverを軽く退ける</h4>

<p class="note">注記：
“軽く退ける（ `light dismiss^en ）” とは、
次を意味する
⇒
`~popover$を伴う要素のうち［
その `popover$a 属性の状態 ~EQ `自動$st
］を満たすものに対し［
<kbd>Esc</kbd> ~UIkeyを押下げる／
当の~popoverの外側を~clickする
］と，当の~popoverを閉じることになる。
◎
"Light dismiss" means that pressing the Esc key or clicking outside of a popover whose popover attribute is in the auto state will close the popover.
</p>

<div class="algo">
<p>
`~popoverの取消-法＠#canceling-popovers@
⇒
`文書$の`最上層の自動~popover$を示しているときは、
~UAは，［
その作動化に際して次を行う~UI
］を供してもヨイ
⇒
`要素~taskを~queueする$( `利用者~対話~task源$, `最上層の自動~popover$, 次の手続き )
</p>

<p class="algo">
手続きは
⇒
`~popoverを隠す$( `最上層の自動~popover$, ~T, ~T, ~F )
</p>
◎
Canceling popovers: when Document has a topmost auto popover showing, user agents may provide a user interface that, upon activation, queues an element task on the user interaction task source given topmost auto popover to run the hide popover algorithm given the topmost auto popover, true, true, and false.
</div>

<div class="algo">
<p>
`開な~popoverたちを軽く退ける@
ときは、
所与の
( `Event$I %~event )
に対し：
◎
To light dismiss open popovers, given an Event event:
</p>
<ol>
	<li>
~Assert：
%~event の `isTrusted$m 属性 ~EQ ~T
◎
Assert: event's isTrusted attribute is true.
</li>
	<li>
%~target ~LET %~event の`~target$
◎
Let target be event's target.
	<li>
~Assert：
%~target ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%文書 ~LET %~target の`~node文書$
◎
↓</li>
	<li>
%最上層の~popover ~LET `最上層の自動~popover$( %文書 )
【原文では引数として %~target を渡しているが、型が合致しない。】
◎
Let topmostPopover be the result of running topmost auto popover given target.
</li>
	<li>
~IF［
%最上層の~popover ~EQ ~NULL
］
⇒
~RET
◎
If topmostPopover is null, then return.
◎
↑Let document be target's node document.
</li>
	<li>
~IF［
%~event は `PointerEvent$I ~objでない
］
⇒
~RET
◎
↓</li>
	<li>
<p>
%~event の `type$m に応じて
</p>
		<ul>
			<li>
"`pointerdown$et"
⇒
%文書 の`~popover~pointerdown~target$doc ~SET 
`最上層の~clickされた~popover$( %~target, `inclusive^l )
【引数 `inclusive^l は余計？】
◎
If event is a PointerEvent and event's type is pointerdown, then:
• Set document's popover pointerdown target to the result of running topmost clicked popover given target and "inclusive".
</li>
			<li>
<p>
"`pointerup$et" ：
◎
If event is a PointerEvent and event's type is pointerup, then:
</p>
				<ol>
					<li>
%先祖 ~LET `最上層の~clickされた~popover$( %~target )
◎
Let ancestor be the result of running topmost clicked popover given target.
</li>
					<li>
%同じ~targetか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%先祖 ~EQ %文書 の`~popover~pointerdown~target$doc
◎
Let sameTarget be true if ancestor is document's popover pointerdown target.
</li>
					<li>
%文書 の`~popover~pointerdown~target$doc ~SET ~NULL
◎
Set document's popover pointerdown target to null.
</li>
					<li>
~IF［
%先祖 ~EQ ~NULL
］
⇒
%先祖 ~SET %文書
◎
If ancestor is null, then set ancestor to document.
</li>
					<li>
~IF［
%同じ~targetか ~EQ ~T
］
⇒
`すべての~popoverをあるときまで隠す$( %先祖, ~F, ~T )
◎
If sameTarget is true, then run hide all popovers until given ancestor, false, and true.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>

<p class="XXX">
`開な~popoverたちを軽く退ける$は、
`Pointer Events 仕様＠https://github.com/w3c/pointerevents/pull/460$
により，利用者が~page上のどこかを［
~clickした／~touchした
］とき~callされることになる。
◎
Light dismiss open popovers will be called by the Pointer Events spec when the user clicks or touches anywhere on the page.
</p>
</div>

<div class="algo">
<p>
`最上層の~clickされた~popover@
を見出すときは、
所与の
( `~node$ %~node )
に対し：
◎
To find the topmost clicked popover, given a Node node:
</p>
<ol>
	<li>
%~clickされた~popover ~LET `広義-先祖のうち最も近い開な~popover$( %~node )
◎
Let clickedPopover be the result of running nearest inclusive open popover given node.
</li>
	<li>
%呼出元~popover ~LET `呼出元~用の最も近い広義-~target~popover$( %~node )
◎
Let invokerPopover be the result of running nearest inclusive target popover for invoker given node.
</li>
			<li>
%~popover~list ~LET %~node【！%~popover】 の`~node文書$の`自動~popover~list$doc
◎
↓</li>
	<li class="algo">
%~stack位置を取得する ~LET 所与の
( `~HTML要素$ %~popover )
に対し，次の手続きを遂行する~algo
⇒
~RET ［
%~popover ~NIN %~popover~list ならば 0 ／
~ELSE_ ( %~popover~list 内での %~popover の~index ) ~PLUS 1
］
◎
Let getStackPosition be an algorithm which performs the following steps given an HTML element popover:
• ↑Let popoverList be popover's node document's auto popover list.
• If popover is in popoverList, then return the index of popover in popoverList + 1.
• Return 0.
</li>
	<li>
~RET ［
次が満たされるならば %~clickされた~popover ／
~ELSE_ %呼出元~popover
］
⇒
［
%~stack位置を取得する( %~clickされた~popover )
~GT
%~stack位置を取得する( %呼出元~popover )
］
◎
If the result of running getStackPosition given clickedPopover is greater than the result of running getStackPosition given invokerPopover, then return clickedPopover.
◎
Return invokerPopover.
</li>
</ol>
</div>

<div class="algo">
<p>
`呼出元~用の最も近い広義-~target~popover@
を見出すときは、
所与の
( `~node$ %~node )
に対し：
◎
To find the nearest inclusive target popover for invoker given a Node node:
•↓ Let currentNode be node.
</p>
<ol>
	<li>
<p>
~WHILE［
%~node ~NEQ ~NULL
］：
◎
While currentNode is not null:
</p>
		<ol>
			<li>
%~target~popover ~LET %~node の`~popover~target要素$
◎
Let targetPopover be currentNode's popover target element.
</li>
			<li>
~IF［
%~target~popover ~NEQ ~NULL
］~AND［
%~target~popover の `popover$a 属性の状態 ~EQ `自動$st
］~AND［
%~target~popover の`~popover可視性~状態$ ~EQ `示している$i
］
⇒
~RET %~target~popover
◎
If targetPopover is not null and targetPopover's popover attribute is in the auto state and targetPopover's popover visibility state is showing, then return targetPopover.
</li>
			<li>
%~node ~SET `平坦~tree$における %~node の先祖
【どの先祖？ “親” の誤記？】
◎
Set currentNode to currentNode's ancestor in the flat tree.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="the-toggleevent-interface">
<h4 title="The ToggleEvent interface">6.11.3. `ToggleEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `ToggleEvent@I : `Event$I {
  constructor(DOMString type, optional `ToggleEventInit$I %eventInitDict = {});
  readonly attribute DOMString `oldState$m;
  readonly attribute DOMString `newState$m;
};

dictionary `ToggleEventInit@I : `EventInit$I {
  DOMString oldState = "";
  DOMString newState = "";
};
</pre>

<dl class="domintro">
	<dt>%event.`oldState$m</dt>
	<dd>
［
閉な状態から開な状態へ遷移しているときは `closed^l ／ 
逆へ遷移しているときは `open^l 
］に設定される。
◎
Set to "closed" when transitioning from closed to open, or set to "open" when transitioning from open to closed.
</dd>
	<dt>%event.`newState$m</dt>
	<dd>
［
開な状態から閉な状態へ遷移しているときは `closed^l ／
逆へ遷移しているときは `open^l 
］に設定される。
◎
Set to "open" when transitioning from closed to open, or set to "closed" when transitioning from open to closed.
</dd>
</dl>

<p>
`oldState@m
属性は、
初期化~時の値を返すモノトスル。
それは、
当の`~popover$を伴う要素の`~popover可視性~状態$に応じて，［
`示している$i ならば `open^l ／
`隠している$i ならば `closed^l
］に初期化される。
◎
The oldState attribute must return the value it was initialized to. It is initialized to "open" if the element with the popover attribute's popover visibility state is showing; otherwise "closed".
</p>

<p>
`newState@m
属性は、
初期化~時の値を返すモノトスル。
それは、
当の`~popover$を伴う要素の`~popover可視性~状態$に応じて，［
`示している$i ならば `closed^l ／
`隠している$i ならば `open^l
］に初期化される。
◎
The newState attribute must return the value it was initialized to. It is initialized to "closed" if the element with the popover attribute's popover visibility state is showing; otherwise "open".
</p>

			</section>
</main>
