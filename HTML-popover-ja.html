<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'editing',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ー々]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2023-05-08
trans_update:2023-05-09
source_checked:230127
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/popover.html
	abbr_url:HTMLpopover
site_nav:uievents,html
nav_prev:HTMLdnd
nav_next:ORIGIN
trans_1st_pub:2023-01-30

●●class_map
e:element
a:attr
et:event-type
p:property
st:attr-state
v:value
E:error

●●tag_map
I:code
m:code
E:code
c:code
e:code
a:code
et:code
st:i
p:code
v:code
i:i
em:em
cite:cite

●●original_id_map
_popover-target-attribute:the-popover-target-attributes

●●mdn_urls

●●link_map


	●idl

CEReactions:~HEcustom#cereactions

E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror

I.PopoverInvokerElement:#popoverinvokerelement
I.ToggleEvent:#toggleevent
I.ToggleEventInit:#toggleeventinit
I.PointerEvent:~POINTEREVENTS#pointerevent-interface
	I.Element:~DOM4#interface-element → 要素
	I.Document:~HTMLdom#document → 文書
	I.Node:~DOM4#interface-node → ~node$
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit

m.popover:#dom-popover
m.showPopover:#dom-showpopover
m.hidePopover:#dom-hidepopover
m.togglePopover:#dom-togglepopover
m.popoverTargetElement:#dom-popovertargetelement
m.popoverTargetAction:#dom-popovertargetaction
m.newState:#dom-toggleevent-newstate
m.oldState:#dom-toggleevent-oldstate

m.cancelable:~DOM4#dom-event-cancelable
m.isTrusted:~DOM4#dom-event-istrusted
m.type:~DOM4#dom-event-type

	●code

e.button:~HEforms#the-button-element
e.dialog:~HEinteractive#the-dialog-element
e.div:~HEgrouping#the-div-element
e.map:~HEimages#the-map-element
e.output:~HEforms#the-output-element

a.popover:#attr-popover
a.popovertarget:#attr-popovertarget
a.popovertargetaction:#attr-popovertargetaction
a.open:~HEinteractive#attr-details-open
a.autofocus:~HTMLinteraction#attr-fe-autofocus

v.auto:#attr-popover-auto
v.manual:#attr-popover-manual
v.show:#attr-popovertargetaction-show
v.hide:#attr-popovertargetaction-hide
v.toggle:#attr-popovertargetaction-toggle

et.pointerdown:~POINTEREVENTS#the-pointerdown-event
et.pointerup:~POINTEREVENTS#the-pointerup-event
et.beforetoggle:~HTMLindex#event-beforetoggle
et.toggle:~HTMLindex#event-toggle

p.display:~CSSDISP#propdef-display

	●用語
~popover要素:#_popover-element

st.自動:#attr-popover-auto-state
st.手動:#attr-popover-manual-state
st.~popoverなし:#attr-popover-none-state
st.示す:#attr-popovertargetaction-show-state
st.隠す:#attr-popovertargetaction-hide-state
st.~toggleする:#attr-popovertargetaction-toggle-state

~popover可視性~状態:#popover-visibility-state
i.隠している:#popover-hidden-state
i.示している:#popover-showing-state
doc.自動~popover~list:#auto-popover-list
doc.~popover~pointerdown~target:#popover-pointerdown-target
elm.~popover呼出元:#popover-invoker
elm.~popover~toggle~task:#popover-toggle-task
~popover~target属性:#_popover-target-attribute
poT.~task:#popover-toggle-task-task
poT.旧-状態:#popover-toggle-task-old-state
~popover~toggle~event~taskを~queueする:#queue-a-popover-toggle-event-task
~popoverを示す:#show-popover
~popoverを隠す:#hide-popover-algorithm
すべての~popoverを隠す:#hide-all-popovers
ある所までの~popoverをすべて隠す:#hide-all-popovers-until
最上層な~popover先祖:#topmost-popover-ancestor
最上層な自動~popoverを見出す:#topmost-auto-popover
最上層な自動~popover:#topmost-auto-popover
~popoverを~focusする:#popover-focusing-steps
~popoverの妥当性を検査する:#check-popover-validity
~popover~target属性~作動化の挙動:#popover-target-attribute-activation-behavior
~popover~target要素:#popover-target-element
開な~popoverたちを軽く退ける:#light-dismiss-open-popovers
最上層な~clickされた~popover:#topmost-clicked-popover
広義-先祖のうち最も近い開な~popover:#nearest-inclusive-open-popover
呼出元~用の最も近い広義-~target~popover:#nearest-inclusive-target-popover-for-invoker
軽く退ける:#popover-light-dismiss

	●用語（HTML
	~DOM~interface:~HTMLdom#concept-element-dom
文書:~HTMLdom#the-document-object

~HTML要素:~HTMLINFRA#html-elements
切断-:~HTMLINFRA#becomes-disconnected

列挙d属性:~HTMLcms#enumerated-attribute
妥当でない値~用の既定の状態:~HTMLcms#invalid-value-default
値なし用の既定の状態:~HTMLcms#missing-value-default

既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values
反映する:~HTMLcdom#reflect
結付けられた要素:~HTMLcdom#attr-associated-element

~button:~HEforms#concept-button
提出-~button:~HEforms#concept-submit-button

不能化されて:~HTMLforms#concept-fe-disabled
~form所有者:~HTMLforms#form-owner

前回に~focusされた要素:~HEinteractive#previously-focused-element
~dialogを~focusする:~HEinteractive#dialog-focusing-steps

~DOM~anchor:~HTMLinteraction#dom-anchor
自動focus候補~群:~HTMLinteraction#autofocus-candidates
自動focusは処理-済みか:~HTMLinteraction#autofocus-processed-flag
~focus委任-先:~HTMLinteraction#focus-delegate
~objを~focusする:~HTMLinteraction#focusing-steps
doc.指名する被focus区画:~HTMLinteraction#focused-area-of-the-document

同一-生成元:~ORIGIN#same-origin

bc.作動中の文書:~HTMLds#active-document
属する閲覧~文脈:~HTMLds#concept-document-bc
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context

要素~taskを~queueする:~WAPI#queue-an-element-task
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue
利用者~対話~task源:~WAPI#user-interaction-task-source
~event~handler:~WAPI#event-handlers

	●用語（外部
除去する:~INFRA#list-remove
~list:~INFRA#list
空にする:~INFRA#list-empty
空:~INFRA#list-is-empty
set.付加する:~INFRA#set-append
構造体:~INFRA#struct
有順序~map:~INFRA#ordered-map

~tree:~DOM4#concept-tree
~node:~DOM4#concept-node
属性~変更-時の手続き:~DOM4#concept-element-attributes-change-ext
接続されて:~DOM4#connected
~eventを発火する:~DOM4#concept-event-fire
~ID:~DOM4#concept-id
~node文書:~DOM4#concept-node-document
doc.生成元:~DOM4#concept-document-origin
~target:~DOM4#event-target
	誤）~target:~DOM4#concept-event-target

平坦~tree:~CSSSCOPING#flat-tree
表示域:~CSS2J#viewport

~fullscreenか:~FULLSCREEN#fullscreen-flag
上端~層:~FULLSCREEN#top-layer

	コレ:~WEBIDL#this

●●words_table1

●●words_table

	●UI／呈示／accessibility
popover:
自動:auto:~
自動focus:autofocus::自動 focus:自動フォーカス
開な:openな:開いた
開いた:openした:開いた
	開な:opened
	開いたまま残され:stay open
	最初に開いた方:the first one to open
開かれ:openされ:~
開け:openでき:~
閉な:closedな:閉じた
閉じる:closeする:~
閉じな:closeしな:~
閉じれ:closeでき:~
toggle:
示す:showする:~
示して:showして:~
	示している:showing
示され:showされ:~
	示されない:non-showing

隠す:hideする:~
隠し:hideし:~
	隠している:hidden
退ける:dismissする:~
	軽く退けるふるまい:light dismiss
	軽く退ける:light dismiss
	軽く退ける:light-dismiss
被focus:focused::被 focus:被フォーカス
pointerdown:
fullscreen::::全スクリーン
押下げる:pressする:~
touch::::タッチ
矢印:arrow:~
露呈-:reveal:露わに
発声-:announce:~
ARIA:
支援技術:assistive technology:~
reader::::リーダ
確認-:confirm:~

	軽い:light
	最も後に来る:latest
	先に来る:earlier
	煩わしい:annoying
	~menu~item:menuitem

	●構造／関係
呼出元:invoker:呼び出し元
広義-:inclusive:~
終端点:endpoint:~
循環な:cyclicな:循環する
最上層:topmost:~
	上層:top of
指名-:designate::~
	~popover~target属性$:anchor attribute
	~popover~target属性$:anchor
先祖-:ancestral::~
経路:path:~
	指して:pointing
	自身を指している:points back

	●処理
旧-:old:~
新-:new:~
候補:candidate:~
切断-:disconnect::~
復旧-:restore:~

	起:happen

	%名前空間:namespace
	%局所~名:localName
	%旧-値:oldValue
	%値:value
	%要素:element
	%要素:this element
	%例外を投出するか:throwExceptions
	%文書:document
	%元の種別:~originalType:#1
	%先祖:~ancestor0:#1
	%元々~focusされた要素:originallyFocusedElement
	%旧-状態:oldState
	%新-状態:newState
	%前回に~focusした要素を~focusするか:focusPreviousElement
	%~eventを発火するか:fireEvents
	%前回に~focusされた要素:previouslyFocusedElement
	%開な~popoverをすべて閉じる:closeAllOpenPopovers
	%~popover:popover
	%隠し残した~popover:lastToHide
	%終端点を見出したか:foundEndpoint
	%新たな~popover:newPopover
	%~popover位置~群:popoverPositions
	%~index:~index
	%最上層な~popover先祖:topmostPopoverAncestor
	%先祖を検査する:checkAncestor
	%候補:candidate
	%候補~先祖:candidateAncestor
	%候補~位置:candidatePosition
	%~focusを復旧するべきか:shouldRestoreFocus
	%~node:node
	%~node:currentNode
	%~subject:~subject
	%~control:~control0
	%~top-level文書:topDocument
	%期待される可視性~状態:expectedToBeShowing
	%~popover要素:popoverElement
	%~event:~event
	%~target:~target
	%最上層な~popover:topmostPopover
	%同じ~targetか:sameTarget
	%~clickされた~popover:clickedPopover
	%呼出元~popover:invokerPopover
	%呼出元:invoker
	%~stack位置を取得する:~getStackPosition
	%~popover~list:~popoverList
	%~target~popover:targetPopover
	%終端点:endpoint
	%取消されたか:-
	%~toggle~task:-
	%~task:the just queued task
	%最も近い開な~popover:-
	%属性~状態:-
	%可視性~状態:-
	%期待される文書:expectedDocument

	●仕様
排-:eliminate:~
概略的:brief:~
柔軟性:flexibility:~
基底的:baseline:~

	きちんと:well-
	表:table
	と称する:call it
	助け:help

	●未分類
頻度:frequency:~

	起:happen
	いずれかの:two
	どこか:anywhere
	直後:immediately after
	成否:success

●●html_code_list

■popover-attribute-1
<ul>
  <li>
    <a href=...>すべての製品</a>
    <button popovertarget=sub-nav>
     <img src=down-arrow.png alt="Product pages">
    </button>
    <ul popover id=sub-nav>
     <li><a href=...>シャツ</a>
     <li><a href=...>靴</a>
     <li><a href=...>帽子その他</a>
    </ul>
  </li>
  <!-- 他のリストアイテムとリンク -->
</ul>

<ul>
  <li>
    <a href=...>All Products</a>
    <button popovertarget=sub-nav>
     <img src=down-arrow.png alt="Product pages">
    </button>
    <ul popover id=sub-nav>
     <li><a href=...>Shirts</a>
     <li><a href=...>Shoes</a>
     <li><a href=...>Hats etc.</a>
    </ul>
  </li>
  <!-- other list items and links here -->
</ul>

■popover-attribute-2
<button popovertarget=menu aria-haspopup=menu>動作</button>
 <div role=menu id=menu popover>
  <button role=menuitem tabindex=-1 autofocus>編集する</button>
  <button role=menuitem tabindex=-1>隠す</button>
  <button role=menuitem tabindex=-1>削除する</button>
</div>

<button popovertarget=menu aria-haspopup=menu>Actions</button>
 <div role=menu id=menu popover>
  <button role=menuitem tabindex=-1 autofocus>Edit</button>
  <button role=menuitem tabindex=-1>Hide</button>
  <button role=menuitem tabindex=-1>Delete</button>
</div>

■popover-target-attribute-1
<button popovertarget="foo" popovertargetaction="show">
  Show a popover
</button>
％
<article popover=auto id="foo">
  This is a popover article!
  <button popovertarget="foo" popovertargetaction="close">Close</button>
</article>

■popover-target-attribute-2
<input type="button" popovertarget="foo" value="Toggle the popover">
％
<div popover=manual id="foo">
  This is a popover!
</div>

●●images

●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ The popover attribute</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — <code class="attr">popover</code> 属性</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ε, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="the-popover-attribute">
<h3 title="The popover attribute">6.11. `popover^a 属性</h3>

<p>
`popover@a
内容~属性は、
どの`~HTML要素$に設定してもヨイ。
指定された場合、
当の要素は，［
示されるようになる
］まで具現化されなくなり、
そうなった時点で，他の~page内容の上層に具現化される。
◎
All HTML elements may have the popover content attribute set. When specified, the element won't be rendered until it becomes shown, at which point it will be rendered on top of other page content.
</p>

<p class="trans-note">【
`popover^en の意味：
他のもの越しに（ `over^en ）飛び出る（ `pop^en ）。
】【
既定の具現化-法（~UA~stylesheet）は、
`§ 具現化 内の § ~flow内容＠~HTMLrendering#flow-content-3$にて見出せる。
具現化（~layout）を もっと詳細に制御する方法は、
従来からある `CSS Positioned Layout＠~CSSPOS$cite に加えて，
`CSS Anchor Positioning＠~CSSANCHOR$cite
が受持つことになろう。
】</p>

<div class="example">
<p>
`popover$a 属性は、
大域~属性であり，［
~popoverの機能性を最も関連な意味論を伴う要素に適用できるようにする
］ことを確保する柔軟性を作者に許容する。
◎
The popover attribute is a global attribute that allows authors flexibility to ensure popover functionality can be applied to elements with the most relevant semantics.
</p>

<p>
［
~web~site用の大域的な~navi
］の中に~popover下位-~navi用の［
~linkたちが成す~list
］をどう作成するかを次にデモる：
◎
The following demonstrates how one might create a popover sub-navigation list of links, within the global navigation for a website.
</p>

`popover-attribute-1^xCode
</div>

<p>
作者は、
~accessibilityの意味論を伴わない要素
— 一例として `div$e 要素 —
に対し `popover$a を利用するときには、
適切な~ARIA属性を利用して，
当の~popoverが~access可能になることを確保するベキである。
◎
When using popover on elements without accessibility semantics, for instance the div element, authors should use the appropriate ARIA attributes to ensure the popover is accessible.
</p>

<div class="example">
<p>
~custom~menu（ `menu^v ）用の~popoverを作成する基底的~markupを次に示す
— そこでは、
~popoverが呼出されたとき，
1 個目の~menu~item（ `menuitem^v ）が［
`autofocus$a 属性の利用に因り，~keyboard~focusを受取る
］ことになる。
それでも、［
矢印~UIkeyで各~menu~itemへ~navigateすること
］および［
各~menu~item用の作動化の挙動
］には，作者による~scriptingが必要になる。
◎
The following shows the baseline markup to create a custom menu popover, where the first menuitem will receive keyboard focus when the popover is invoked due to the use of the autofocus attribute. Navigating the menuitems by arrow keys, and activation behaviors would still need author scripting.
</p>

`popover-attribute-2^xCode

<p>
~popoverは［
状態s~messageを具現化する／
利用者が遂行した動作を確認する
］ためにも有用になり得る。
`output$e 要素~内に~popoverを露呈する方法を次にデモる。
◎
A popover can be useful for rendering a status message, confirming the action performed by the user. The following demonstrates how one could reveal a popover in an output element.
</p>

<pre class="lang-html">
&lt;button id=submit&gt;Submit&lt;/button&gt;
&lt;p&gt;&lt;output&gt;&lt;span popover=manual&gt;&lt;/span&gt;&lt;/output&gt;&lt;/p&gt;

&lt;script&gt;
 const %sBtn = document.getElementById('submit');
 const %outSpan = document.querySelector('output [popover=manual]');
 let %successMessage;
 let %errorMessage;

 /* <span class="comment">
動作の成否を決定するための~logicを定義して，利用する適切な［
成功／~error
］~messageを決定する。
◎
define logic for determining success of action and determining the appropriate success or error messages to use
</span> */

 %sBtn.addEventListener('click', ()=&gt; {
  if ( %success ) {
   %outSpan.textContent = %successMessage;
  }
  else {
   %outSpan.textContent = %errorMessage;
  }
  %outSpan.showPopover();

  setTimeout(function () {
   %outSpan.hidePopover();
  }, 10000);
 });
&lt;script&gt;
</pre>
</div>

<p class="note">注記：
`output$e 要素の中へ~popover要素を挿入すると、
一般に，［
それが可視になるとき，~screen~readerに内容を発声させる
］ことになる。
これは、
これらの支援技術の利用者にとって
— 内容の複階性や可視になる頻度に依存して —
有用にも煩わしくもなり得る。
`output$e 要素~その他の~ARIA~live領域を利用しているときは、
このことを念頭に置いて，最良な利用者~体験を確保すること。
◎
Inserting a popover element into an output element will generally cause screen readers to announce the content when it becomes visible. Depending on the complexity or frequency of the content, this could be either useful or annoying to users of these assistive technologies. Keep this in mind when using the output element or other ARIA live regions to ensure the best user experience.
</p>

<p>
`popover$a 属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The popover attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead>
<tr><th>~keyword
<th>状態
<th>概略的な記述
</thead><tbody>

<tr><td>`auto@v
<td rowspan="2">`自動@st
<td rowspan="2">
開かれたときは、
他の~popoverを閉じることに加え，
`軽く退ける$ふるまいを伴う。

<tr><td>空~文字列

<tr><td>`manual@v
<td>`手動@st
<td>
他の~popoverを閉じないことに加え，
`軽く退ける$ふるまいを伴わない。

<tr><td>
<td>`~popoverなし@st
<td>
【~popoverとして挙動しない。】
</tbody></table>

<p>
`popover$a 属性の
⇒＃
`妥当でない値~用の既定の状態$は， `手動$st とする。
`値なし用の既定の状態$は， `~popoverなし$st とする。
</p>

<p>
`~popover要素@
とは、
`~HTML要素$のうち［
その `popover$a 属性の状態 ~NEQ `~popoverなし$st
］を満たすもの
（言い換えれば， `popover$a 属性を有するもの）をいう。
【この用語は、他所を簡便に述べるための，この訳による追加。】
</p>

◎
Keyword｜State｜Brief description
auto｜auto｜Closes other popovers when opened; has light dismiss.
The empty string｜｜
manual｜manual｜Does not close other popovers; does not light dismiss.
◎
The popover attribute's invalid value default is the manual state and its missing value default is the no popover state.
</div>

<p>
`popover@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`popover$a 属性を`反映する$モノトスル。
◎
The popover IDL attribute must reflect the popover attribute, limited to only known values.
</p>

<p>
各`~HTML要素$には、
`~popover可視性~状態@
がある
— その値は，［
`隠している@i
／
`示している@i
］いずれかであり、
初期~時は， `隠している$i とする。
◎
Every HTML element has a popover visibility state, initially hidden, with these potential values:
• hidden
• showing
</p>

<p>
各`文書$は、
次に挙げるものを有する
◎
↓</p>
<ul>
	<li>
`自動~popover~list@doc
⇒
当の`文書$の`上端~層$内の要素のうち［
その `popover$a 属性の状態 ~EQ `自動$st
］を満たすものすべてからなる同じ順序の`~list$。
◎
The Document has an auto popover list, which is a list of all the elements in the Document's top layer whose popover attribute is in the auto state, in the same order.
</li>
	<li>
`~popover~pointerdown~target@doc
⇒
ある`~HTML要素$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
The Document has a popover pointerdown target, which is an HTML element or null, initially null.
</li>
</ul>

<p>
各`~HTML要素$は、
次に挙げるものを有する
◎
↓</p>
<ul>
	<li>
`~popover呼出元@elm
⇒
`~HTML要素$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
Every HTML element has a popover invoker, which is an HTML element or null, initially set to null.
</li>
	<li>
<p>
`~popover~toggle~task@elm
⇒
~NULL ／ `構造体$
— 初期~時は ~NULLとする。
◎
Every HTML element has a popover toggle task, initially null, which is either null or a struct＼
</p>

<p>
この`構造体$は、
次に挙げる~itemからなる：
◎
which has:
</p>
		<ul>
			<li>
`~task@poT
⇒
`~task$
— `ToggleEvent$I を発火するための。
◎
Task
• A task which fires a ToggleEvent.
</li>
			<li>
`旧-状態@poT
⇒
文字列
— `~task$poTにより発火される~eventの `oldState$m 属性~用の値を表現する。
◎
Old state
• A string which represents the task's event's value for the oldState attribute.
</li>
		</ul>
	</li>
</ul>

<div class="algo">
<p>
すべての`~HTML要素$ %要素 は、
`属性~変更-時の手続き$として次を利用する
— それは、
所与の
( %局所~名, %旧-値, %値, %名前空間 )
に対し：
◎
The following attribute change steps, given element, localName, oldValue, value, and namespace, are used for all HTML elements:
</p>
<ol>
	<li>
~IF［
%名前空間 ~NEQ ~NULL
］
⇒
~RET
◎
If namespace is not null, then return.
</li>
	<li>
~IF［
%局所~名 ~NEQ "`popover$a"
］
⇒
~RET
◎
If localName is not popover, then return.
</li>
	<li>
~IF［
`popover$a 属性が［
%旧-値 をとるときの状態, %値 をとるときの状態
］は異なる
］
⇒
`~popoverを隠す$( %要素, ~T, ~T, ~F )
◎
If oldValue and value are in different states, then run the hide popover algorithm given element, true, true, and false.
</li>
</ol>
</div>

<dl class="domintro">
	<dt>%element.`showPopover()$m</dt>
	<dd>
`~popover要素$ %element を`上端~層$に追加することにより，
%element を示す。
%element の `popover$a 属性の状態 ~EQ `自動$stならば、
これは，同じ状態にある他の要素のうち［
`最上層な~popover先祖$を見出す~algoに則って，
%element の先祖であるもの
］を除くすべてを閉じることになる。
◎
Shows the popover element by adding it to the top layer. If element's popover attribute is in the auto state, then this will also close all other auto popovers unless they are an ancestor of element according to the topmost popover ancestor algorithm.
</dd>

	<dt>%element.`hidePopover()$m</dt>
	<dd>
`~popover要素$ %element を`上端~層$から除去した上で、［
%element に
<code class="css">`display$p: `none^v</code>
を適用する
］ことにより，
%element を隠す。
◎
Hides the popover element by removing it from the top layer and applying display: none to it.
</dd>

	<dt>%element.`togglePopover()$m</dt>
	<dd>
`~popover要素$ %element を［
隠しているならば示す／
示しているならば隠す
］。
◎
If the popover element is not showing, then this method shows it. Otherwise, this method hides it.
</dd>
</dl>

<div class="algo">
`showPopover()@m
~method手続きは
⇒
`~popoverを示す$( コレ, ~T, ~NULL )
◎
The showPopover() method steps are to run show popover given this, true, and null.
</div>

<div class="algo">
<p>
`~popoverを示す@
ときは、
所与の
( `~HTML要素$ %要素, 真偽値 %例外を投出するか, ［
`~HTML要素$ ／ ~NULL
］ %呼出元 )
に対し：
◎
To show popover, given an HTML element element, a boolean throwExceptions, and an HTML element or null invoker:
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
%要素 の`~popover呼出元$elm ~SET %呼出元
◎
Set element's popover invoker to invoker.
</li>
	<li>
~IF［
`~popoverの妥当性を検査する$( %要素, `隠している$i, %例外を投出するか, ~NULL ) ~EQ ~F
］
⇒
~RET
◎
If the result of running check popover validity given element, false, throwExceptions, and null is false, then return.
</li>
	<li>
~Assert：
%要素 ~NIN %文書 の`上端~層$
◎
Assert: element is not in document's top layer.
</li>
	<li>
%取消されたか ~LET `~eventを発火する$( %要素, `beforetoggle$et, `ToggleEvent$I )
— 次のように初期化して
⇒＃
`cancelable$m 属性 ~SET ~T
`oldState$m 属性 ~SET `closed^l,
`newState$m 属性 ~SET `open^l
◎
If the result of firing an event named beforetoggle, using ToggleEvent, with the cancelable attribute initialized to true, the oldState attribute initialized to "closed", and the newState attribute initialized to "open" at element is false, then return.
</li>
	<li>
~IF［
%取消されたか ~EQ ~F
］
⇒
~RET
◎
↑</li>
	<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `隠している$i, %例外を投出するか, %文書 ) ~EQ ~F
］
⇒
~RET
◎
If the result of running check popover validity given element, false, throwExceptions, and document is false, then return.
</p>

<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、［
上で発火した `beforetoggle$et ~event
］用の`~event~handler$が［
%要素 を`切断-$し得る／
%要素 の `popover$a 属性を変更し得る
］からである。
◎
Check popover validity is called again because firing the beforetoggle event could have disconnected this element or changed its popover attribute.
</p>
	</li>
	<li>
%~focusを復旧するべきか ~LET ~F
◎
Let shouldRestoreFocus be false.
</li>
	<li>
<p>
~IF［
%要素 の `popover$a 属性の状態 ~EQ `自動$st
］：
◎
If element's popover attribute is in the auto state, then:
</p>
		<ol>
			<li>
%元の種別 ~LET %要素 の `popover$a 属性の値
◎
Let originalType be the value of element's popover attribute.
</li>
			<li>
%先祖 ~LET `最上層な~popover先祖$( %要素 )
◎
Let ancestor be the result of running the topmost popover ancestor algorithm given element.
</li>
			<li>
~IF［
%先祖 ~EQ ~NULL
］
⇒
%先祖 ~SET %文書
◎
If ancestor is null, then set ancestor to document.
</li>
			<li>
`ある所までの~popoverをすべて隠す$( %先祖, ~F, ~T )
◎
Run hide all popovers until given ancestor, false, and true.
</li>
			<li>
<p>
~IF［
%元の種別 ~NEQ %要素 の `popover$a 属性の値
］~OR［
`~popoverの妥当性を検査する$( %要素, `隠している$i, %例外を投出するか, %文書 ) ~EQ ~F
］
⇒
~RET
◎
If originalType is not equal to the value of element's popover attribute, or if the result of running check popover validity given element, false, throwExceptions, and document is false, then return.
</p>

<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、［
上で`ある所までの~popoverをすべて隠す$ときに発火され得る `beforetoggle$et ~event
］用の`~event~handler$が［
%要素 を`切断-$し得る／
%要素 に対し `showPopover()$m を~callし得る
］からである。
◎
Check popover validity is called again because running hide all popovers until above could have fired the beforetoggle event, and an event handler could have disconnected this element or called showPopover() on this element.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`最上層な自動~popover$( %文書 ) ~EQ ~NULL
］
⇒
%~focusを復旧するべきか ~SET ~T
◎
If the result of running topmost auto popover on document is null, then set shouldRestoreFocus to true.
</p>

<p class="note">注記：
これは、［
当の~stackを成す最初の~popover用に限り，
前回に~focusした要素に~focusを返す
］ことを確保する。
◎
This ensures that focus is returned to the previously-focused element only for the first popover in a stack.
</p>
	</li>
	<li>
%要素 の`前回に~focusされた要素$ ~SET ~NULL
◎
Set element's previously focused element to null.
</li>
	<li>
%元々~focusされた要素 ~LET %文書 が`指名する被focus区画$docの`~DOM~anchor$
◎
Let originallyFocusedElement be document's focused area of the document's DOM anchor.
</li>
	<li>
%文書 の`上端~層$に %要素 を`付加する$set【！Add】
◎
Add element to document's top layer.
</li>
	<li>
%要素 の`~popover可視性~状態$ ~SET `示している$i
◎
Set element's popover visibility state to showing.
</li>
	<li>
`~popoverを~focusする$( %要素 )
◎
Run the popover focusing steps given element.
</li>
	<li>
~IF［
%~focusを復旧するべきか ~EQ ~T
］~AND［
%要素 は`~popover要素$である
］
⇒
%要素 の`前回に~focusされた要素$ ~SET %元々~focusされた要素
◎
If shouldRestoreFocus is true and element's popover attribute is not in the no popover state, then set element's previously focused element to originallyFocusedElement.
</li>
	<li>
`~popover~toggle~event~taskを~queueする$( %要素, `closed^l, `open^l )
◎
Queue a popover toggle event task given element, "closed", and "open".
</li>
</ol>
</div>

<div class="algo">
<p>
`~popover~toggle~event~taskを~queueする@
ときは、
所与の
( 要素 %要素, 文字列 %旧-状態, 文字列 %新-状態 )
に対し：
◎
To queue a popover toggle event task given an element element, a string oldState, and a string newState:
</p>
<ol>
	<li>
%~toggle~task ~LET %要素 の`~popover~toggle~task$elm
◎
↓</li>
	<li>
<p>
~IF［
%~toggle~task ~NEQ ~NULL
］：
◎
If element's popover toggle task is not null, then:
</p>
		<ol>
			<li>
%旧-状態 ~SET %~toggle~task の`旧-状態$poT
◎
Set oldState to element's popover toggle task's old state.
</li>
			<li>
%~toggle~task の`~task$poTを【それが属する】`~task~queue$から除去する
◎
Remove element's popover toggle task's task from its task queue.
</li>
			<li>
%要素 の`~popover~toggle~task$elm ~SET ~NULL
◎
Set element's popover toggle task to null.
</li>
		</ol>
	</li>
	<li>
<p>
%~task ~LET `要素~taskを~queueする$( `利用者~対話~task源$, %要素, 次の手続き )
◎
Queue an element task given the user interaction task source and element＼
</p>

<div class="algo">
<p>
手続きは、
次を走らす：
◎
to run the following steps:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `toggle$et, `ToggleEvent$I )
— 次のように初期化して
⇒＃
`oldState$m 属性 ~SET %旧-状態,
`newState$m 属性 ~SET %新-状態
◎
fire an event named toggle, using ToggleEvent, with the oldState attribute initialized to oldState, and the newState attribute initialized to newState at element.
</li>
			<li>
%要素 の`~popover~toggle~task$elm ~SET ~NULL
◎
Set element's popover toggle task to null.
</li>
		</ol>
</div>
	</li>
	<li>
%要素 の`~popover~toggle~task$elm ~SET 次に挙げる~itemからなる`構造体$
⇒＃
`~task$poT ~SET %~task,
`旧-状態$poT ~SET %旧-状態
◎
Set element's popover toggle task to a struct with task set to the just-queued task and old state set to oldState.
</li>
</ol>
</div>

<div class="algo">
<p>
`hidePopover()@m
~method手続きは：
◎
The hidePopover() method steps are:
</p>
<ol>
	<li>
`~popoverを隠す$( コレ, ~T, ~T, ~T )
◎
Run the hide popover algorithm given this, true, true, and true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popoverを隠す@
ときは、
所与の
⇒＃
`~HTML要素$ %要素,
真偽値 %前回に~focusした要素を~focusするか,
真偽値 %~eventを発火するか,
真偽値 %例外を投出するか
◎終
に対し：
◎
To hide a popover given an HTML element element, a boolean focusPreviousElement, a boolean fireEvents, and a boolean throwExceptions:
</p>
<ol>
	<li>
~IF［
`~popoverの妥当性を検査する$( %要素, `示している$i, %例外を投出するか, ~NULL ) ~EQ ~F
］
⇒
~RET
◎
If the result of running check popover validity given element, true, throwExceptions, and null is false, then return.
</li>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
<p>
~IF［
%要素 の `popover$a 属性の状態 ~EQ `自動$st
］：
◎
If element's popover attribute is in the auto state, then:
</p>
		<ol>
			<li>
`ある所までの~popoverをすべて隠す$( ↓ )
⇒＃
%要素,
%前回に~focusした要素を~focusするか,
%~eventを発火するか
◎
Run hide all popovers until given element, focusPreviousElement, and fireEvents.
</li>
			<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `示している$i, %例外を投出するか, ~NULL ) ~EQ ~F
］
⇒
~RET
◎
If the result of running check popover validity given element, true, throwExceptions, and null is false, then return.
</p>

<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、
上で`ある所までの~popoverをすべて隠す$ときに［
%要素 を`切断-$し得る／
%要素 の `popover$a 属性を変更し得る
］からである。
◎
Check popover validity is called again because running hide all popovers until could have disconnected element or changed its popover attribute.
</p>
			</li>
			<li>
~Assert：
%文書 の`自動~popover~list$docを成す最後の~item ~EQ %要素
◎
Assert: the last item in document's auto popover list is element.
</li>
		</ol>
	</li>
	<li>
%要素 の`~popover呼出元$elm ~SET ~NULL
◎
Set element's popover invoker to null.
</li>
	<li>
<p>
~IF［
%~eventを発火するか ~EQ ~T
］：
◎
If fireEvents is true:
</p>
		<ol>
			<li>
`~eventを発火する$( %要素, `beforetoggle$et, `ToggleEvent$I )
— 次のように初期化して
⇒＃
`oldState$m 属性 ~SET `open^l,
`newState$m 属性 ~SET `closed^l
◎
Fire an event named beforetoggle, using ToggleEvent, with the oldState attribute initialized to "open", and the newState attribute initialized to "closed" at element.
</li>
			<li>
<p>
~IF［
`~popoverの妥当性を検査する$( %要素, `示している$i, %例外を投出するか, ~NULL ) ~EQ ~F
］：
◎
If the result of running check popover validity given element, true, throwExceptions, and null is false, then return.
</p>

<p class="note">注記：
ここで再び`~popoverの妥当性を検査する$わけは、［
上で発火した `beforetoggle$et ~event
］用の`~event~handler$が［
%要素 を`切断-$し得る／
%要素 の `popover$a 属性を変更し得る
］からである。
◎
Check popover validity is called again because firing the beforetoggle event could have disconnected element or changed its popover attribute.
</p>
			</li>
		</ol>
	</li>
	<li>
`上端~層$から %要素 を`除去する$
◎
Remove element from the top layer.
</li>
	<li>
%要素 の`~popover可視性~状態$ ~SET `隠している$i
◎
Set element's popover visibility state to hidden.
</li>
	<li>
~IF［
%~eventを発火するか ~EQ ~T
］
⇒
`~popover~toggle~event~taskを~queueする$( %要素, `open^l, `closed^l )
◎
If fireEvents is true, then queue a popover toggle event task given element, "open", and "closed".
</li>
	<li>
%前回に~focusされた要素 ~LET %要素 の`前回に~focusされた要素$
◎
Let previouslyFocusedElement be element's previously focused element.
</li>
	<li>
<p>
~IF［
%前回に~focusされた要素 ~NEQ ~NULL
］：
◎
If previouslyFocusedElement is not null, then:
</p>
		<ol>
			<li>
%要素 の`前回に~focusされた要素$ ~SET ~NULL
◎
Set element's previously focused element to null.
</li>
			<li>
<p>
~IF［
%前回に~focusした要素を~focusするか ~EQ ~T
］
⇒
`~objを~focusする$( %前回に~focusされた要素 )
◎
If focusPreviousElement is true, then run the focusing steps for previouslyFocusedElement;＼
</p>

<p>
この段を行うときは、
`表示域$は~scrollされるベキでない。
◎
the viewport should not be scrolled by doing this step.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`togglePopover(force)@m
~method手続きは：
◎
The togglePopover(force) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`~popover可視性~状態$ ~EQ `示している$i
］~AND［
%force ~IN { ε, ~F }
］
⇒
`~popoverを隠す$( コレ, ~T, ~T, ~T )
◎
If this's popover visibility state is showing, and force is not present or false, then run the hide popover algorithm given this, true, true, and true.
</li>
	<li>
~ELIF［
%force ~IN { ε, ~T }
］
⇒
`~popoverを示す$( コレ, ~T, ~NULL )
◎
Otherwise, if force is not present or true, then run show popover given this true, and null.
</li>
</ol>
</div>

<div class="algo">
<p>
`ある所までの~popoverをすべて隠す@
ときは、
所与の
⇒＃
［`~HTML要素$／`文書$］ %終端点,
真偽値 %前回に~focusした要素を~focusするか,
真偽値 %~eventを発火するか
◎終
に対し：
◎
To hide all popovers until, given an HTML element or Document endpoint, a boolean focusPreviousElement, and a boolean fireEvents:
</p>
<ol>
	<li>
%文書 ~LET %終端点 の`~node文書$
◎
Let document be endpoint's node document.
</li>
	<li class="algo">
<p>
%開な~popoverをすべて閉じる ~LET 次の手続きを遂行する~algo：
◎
Let closeAllOpenPopovers be an algorithm which performs the following steps:
</p>
		<ol>
			<li>
<p>
~WHILE 無条件：
</p>
				<ol>
					<li>
%~popover ~LET %文書 の`最上層な自動~popover$
</li>
					<li>
~IF［
%~popover ~EQ ~NULL
］
⇒
~BREAK
</li>
					<li>
`~popoverを隠す$( ↓ )
⇒＃
%~popover,
%前回に~focusした要素を~focusするか,
%~eventを発火するか,
~F
</li>
				</ol>
◎
Let popover be document's topmost auto popover.
◎
While popover is not null:
• Run the hide popover algorithm given popover, focusPreviousElement, fireEvents, and false.
• Set popover to document's topmost auto popover.
</li>
		</ol>
	</li>
	<li>
~IF［
%終端点 は`文書$である
］
⇒＃
%開な~popoverをすべて閉じる()；
~RET
◎
If endpoint is a Document, then run closeAllOpenPopovers and return.
</li>
	<li>
%隠し残した~popover ~LET ~NULL
◎
Let lastToHide be null.
</li>
	<li>
%終端点を見出したか ~LET ~F
◎
Let foundEndpoint be false.
</li>
	<li>
<p>
%文書 の`自動~popover~list$docを成す
~EACH( %~popover )
に対し：
◎
For each popover in document's auto popover list:
</p>
		<ol>
			<li>
~IF［
%~popover ~EQ %終端点
］
⇒
%終端点を見出したか ~SET ~T
◎
If popover is endpoint, then set foundEndpoint to true.
</li>
			<li>
~ELIF［
%終端点を見出したか ~EQ ~T
］
⇒＃
%隠し残した~popover ~SET %~popover；
~BREAK
◎
Otherwise, if foundEndpoint is true, then set lastToHide to popover and break.
</li>
		</ol>
	</li>
	<li>
~IF［
%終端点を見出したか ~EQ ~F
］
⇒＃
%開な~popoverをすべて閉じる()；
~RET
◎
If foundEndpoint is false, then run closeAllOpenPopovers and return.
</li>
	<li>
<p>
~WHILE［
%隠し残した~popover ~NEQ ~NULL
］~AND［
%隠し残した~popover の`~popover可視性~状態$ ~EQ `示している$i
］~AND［
%文書 の`自動~popover~list$docは`空$でない
］
⇒
`~popoverを隠す$( ↓ )
⇒＃
%文書 の`自動~popover~list$docを成す最後の要素,
%前回に~focusした要素を~focusするか,
%~eventを発火するか,
~F
◎
While lastToHide is not null and lastToHide's popover visibility state is showing and document's auto popover list is not empty:
• Run the hide popover algorithm given document's auto popover list's last element, focusPreviousElement, fireEvents, and false.
</li>
</ol>

<p class="note">注記：
`ある所までの~popoverをすべて隠す$
は、
いくつかの事例で，~popoverのうち［
何かが起きたときでも，開いたまま残されるもの
］以外のもの すべてを隠すために利用される。
例えば，この~algoは、
~popoverを`軽く退ける$間は，~popoverのうち［
利用者により~clickされた~nodeに関係しないもの
］に限り閉じることを確保する。
◎
The hide all popovers until algorithm is used in several cases to hide all popovers that don't stay open when something happens. For example, during light-dismiss of a popover, this algorithm ensures that we close only the popovers that aren't related to the node clicked by the user.
</p>
</div>

<div class="algo">
<p>
`すべての~popoverを隠す@
ときは、
所与の
( `文書$ %文書 )
に対し
⇒
`ある所までの~popoverをすべて隠す$( %文書, ~F, ~F )
◎
To hide all popovers, given a Document document, run hide all popovers until given document, false, and false.
</p>
</div>

<div class="algo">
<p>
`最上層な~popover先祖@
を見出すときは、
所与の
( `~node$ %新たな~popover )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To find the topmost popover ancestor, given a Node newPopover, perform the following steps. They return an HTML element or null.
</p>

<div class="note">
<p>注記：
`最上層な~popover先祖$
~algoは、
供された~popover用に最上層な
（`自動~popover~list$doc内で最も後に来る）
先祖~popoverを返すことになる。
~popoverたちは、
いくつかの仕方で互いに関係し得ることにより，それらが成す~treeを作成する。
ある~popover（以下では “子” ~popoverと称する）は、
次に挙げる経路を通して，
ある最上層な先祖~popover（以下では “親” ~popover と称する）を有し得る：
◎
The topmost popover ancestor algorithm will return the topmost (latest in the auto popover list) ancestor popover for the provided popover. Popovers can be related to each other in several ways, creating a tree of popovers. There are two paths through which one popover (call it the "child" popover) can have a topmost ancestor popover (call it the "parent" popover):
</p>
<ul>
	<li>
~node~treeの中で，ある~popoverを別の~popoverが入子にしているとき。
この事例では、
子孫である~popoverが “子”, その最上層な先祖である~popoverが “親” になる。
◎
The popovers are nested within each other in the node tree. In this case, the descendant popover is the "child" and its topmost ancestor popover is the "parent".
</li>
	<li>
何かを呼出している要素 %要素 （例： `button$e ）が，
`popovertarget$a 属性を有していて、
それは，ある~popoverを指しているとき。
この事例では、
当の~popoverが “子” になり，
%要素 を包含している~popover下位treeが “親” になる
— %要素 【！invoker】は［
ある~popover内に在って，ある開な~popoverを参照する
］必要がある。
◎
An invoking element (e.g., a button) has a popovertarget attribute pointing to a popover. In this case, the popover is the "child", and the popover subtree the invoking element is in is the "parent". The invoker has to be in a popover and reference an open popover.
</li>
</ul>

<p>
上により形成される各~関係性において、
親~popoverは，
`自動~popover~list$doc内で，子~popoverより厳密に先に来る必要がある
— さもなければ、
妥当な先祖-関係性を形成しない。
これは、［
示されない~popover／
自己-~pointer
（例：上に挙げた 2 つ目の関係性において、
%要素 が指している~popoverと %要素 を包含している~popoverが同じである）
］を排することに加え，［
（場合によっては循環な）接続たちが成す~graphから，きちんと形成された~treeを構築する
］ことを許容する。
ここで考慮されるのは、［
`popover$a 属性の状態 ~EQ `自動$st
］を満たす~popoverに限られる。
◎
In each of the relationships formed above, the parent popover has to be strictly earlier in the auto popover list than the child popover, or it does not form a valid ancestral relationship. This eliminates non-showing popovers and self-pointers (e.g., a popover containing an invoking element that points back to the containing popover), and it allows for the construction of a well-formed tree from the (possibly cyclic) graph of connections. Only auto popovers are considered.
</p>
</div>

<ol>
	<li>
%~popover位置~群 ~LET 新たな`有順序~map$
◎
Let popoverPositions be an empty ordered map.
</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
%文書 ~LET %新たな~popover の`~node文書$
◎
Let document be newPopover's node document.
</li>
	<li>
<p>
%文書 の`自動~popover~list$docを成す
~EACH( %~popover )
に対し：
◎
For each popover in document's auto popover list:
</p>
		<ol>
			<li>
%~popover位置~群[ %~popover ] ~SET %~index
◎
Set popoverPositions[popover] to index.
</li>
			<li>
%~index ~INCBY 1
◎
Increment index by 1.
</li>
		</ol>
	</li>
	<li>
%~popover位置~群[ %新たな~popover ] ~SET %~index
◎
Set popoverPositions[newPopover] to index.
</li>
	<li>
%~index ~INCBY 1
◎
Increment index by 1.
</li>
	<li>
%最上層な~popover先祖 ~LET ~NULL
◎
Let topmostPopoverAncestor be null.
</li>
	<li class="algo">
<p>
%先祖を検査する ~LET 所与の
( %候補 )
に対し，次の手続きを遂行する~algo：
◎
Let checkAncestor be an algorithm which performs the following steps given candidate:
</p>
		<ol>
			<li>
~IF［
%候補 ~EQ ~NULL
］
⇒
~RET
◎
If candidate is null, then return.
</li>
			<li>
%候補~先祖 ~LET `広義-先祖のうち最も近い開な~popover$( %候補 )
◎
Let candidateAncestor be the result of running nearest inclusive open popover given candidate.
</li>
			<li>
~IF［
%候補~先祖 ~EQ ~NULL
］
⇒
~RET
◎
If candidateAncestor is null, then return.
</li>
			<li>
%候補~位置 ~LET %~popover位置~群[ %候補~先祖 ]
◎
Let candidatePosition be popoverPositions[candidateAncestor].
</li>
			<li>
~IF［
%最上層な~popover先祖 ~EQ ~NULL
］~OR［
%~popover位置~群[ %最上層な~popover先祖 ] ~LT %候補~位置
］
⇒
%最上層な~popover先祖 ~SET %候補~先祖
◎
If topmostPopoverAncestor is null or popoverPositions[topmostPopoverAncestor] is less than candidatePosition, then set topmostPopoverAncestor to candidateAncestor.
</li>
		</ol>
	</li>
	<li>
%最も近い開な~popover ~LET `広義-先祖のうち最も近い開な~popover$( `平坦~tree$における %新たな~popover の親~node )
◎
↓</li>
	<li>
%先祖を検査する( %最も近い開な~popover )
◎
Run checkAncestor given the result of running nearest inclusive open popover given newPopover's parent node within the flat tree.
</li>
	<li>
%先祖を検査する( %新たな~popover の`~popover呼出元$elm )
◎
Run checkAncestor given newPopover's popover invoker.
</li>
	<li>
~RET %最上層な~popover先祖
◎
return topmostPopoverAncestor.
</li>
</ol>
</div>

<div class="algo">
<p>
`広義-先祖のうち最も近い開な~popover@
を見出すときは、
所与の
( `~node$ %~node )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To find the nearest inclusive open popover given a Node node, perform the following steps. They return an HTML element or null.
•↓ Let currentNode be node.
</p>
<ol>
	<li>
<p>
~WHILE［
%~node ~NEQ ~NULL
］：
◎
While currentNode is not null:
</p>
		<ol>
			<li>
~IF［
%~node の `popover$a 属性の状態 ~EQ `自動$st
］~AND［
%~node の`~popover可視性~状態$ ~EQ `示している$i
］
⇒
~RET %~node
◎
If currentNode's popover attribute is in the auto state and currentNode's popover visibility state is showing, then return currentNode.
</li>
			<li>
%~node ~SET `平坦~tree$における %~node の親
◎
Set currentNode to currentNode's parent in the flat tree.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`最上層な自動~popover@
は、
所与の
( `文書$ %文書 )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To find the topmost auto popover given a Document document, perform the following steps. They return an HTML element or null.
</p>
<ol>
	<li>
~IF［
%文書 の`自動~popover~list$docは`空$でない
］
⇒
~RET %文書 の`自動~popover~list$docの最後の要素
◎
If document's auto popover list is not empty, then return document's auto popover list's last element.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popoverを~focusする@
ときは、
所与の
( `~HTML要素$ %~subject )
に対し：
◎
To perform the popover focusing steps for an HTML element subject:
</p>
<ol>
	<li>
~IF［
%~subject は `dialog$e 要素である
］
⇒＃
`~dialogを~focusする$( %~subject, ~T )；
~RET
◎
If subject is a dialog element, then run the dialog focusing steps given subject and true, and return.
</li>
	<li>
%~control ~LET `~focus委任-先$( %~subject, `other^l, ~T )
◎
Let control be the focus delegate of subject given "other" and true.
</li>
	<li>
~IF［
%~control ~EQ ~NULL
］
⇒
~RET
◎
If control is null, then return.
</li>
	<li>
`~objを~focusする$( %~control )
◎
Run the focusing steps given control.
</li>
	<li>
%~top-level文書 ~LET %~control の`~node文書$が`属する閲覧~文脈$の`~top-level閲覧~文脈$にて`作動中の文書$bc
◎
Let topDocument be the active document of control's node document's browsing context's top-level browsing context.
</li>
	<li>
~IF［
( %~control の`~node文書$の`生成元$doc, %~top-level文書 の`生成元$doc )
は`同一-生成元$でない
］
⇒
~RET
◎
If control's node document's origin is not the same as the origin of topDocument, then return.
</li>
	<li>
%~top-level文書 の`自動focus候補~群$を`空にする$
◎
Empty topDocument's autofocus candidates.
</li>
	<li>
%~top-level文書 の`自動focusは処理-済みか$ ~SET ~T
◎
Set topDocument's autofocus processed flag to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popoverの妥当性を検査する@
ときは、
所与の
⇒＃
`~HTML要素$ %要素,
%期待される可視性~状態 ~IN { `示している$i, `隠している$i },
真偽値 %例外を投出するか,
［ `文書$／ ~NULL ］ %期待される文書
◎終
に対し，
例外を投出するか真偽値を返す：
◎
To check popover validity for an HTML element element given a boolean expectedToBeShowing, a boolean throwExceptions, and a Document or null expectedDocument perform the following steps. They throw an exception or return a boolean.
</p>
<ol>
	<li>
<p>
~IF［
%要素 は`~popover要素$でない
］：
◎
If element's popover attribute is in the no popover state, then:
</p>
		<ol>
			<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `NotSupportedError$E
◎
If throwExceptions is true, then throw a "NotSupportedError" DOMException.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次に挙げるいずれかが満たされる
］…：
◎
If one of the following conditions is true
</p>
		<ul>
			<li>
%要素 は`接続されて$いない
◎
element is not connected
</li>
			<li>
%期待される文書 ~NIN { ~NULL, %要素 の`~node文書$ }
◎
expectedDocument is not null and element's node document is not expectedDocument
</li>
			<li>
%期待される可視性~状態 ~NEQ %要素 の`~popover可視性~状態$
◎
expectedToBeShowing is true and element's popover visibility state is not showing
◎
expectedToBeShowing is false and element's popover visibility state is not hidden
</li>
			<li>
［
%要素 は `dialog$e 要素である
］~AND［
%要素 は `open$a 属性を有する
］
◎
element is a dialog element and has an open attribute
</li>
			<li>
%要素 の`~fullscreenか$ ~EQ ~T
◎
element's fullscreen flag is set
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
~IF［
%例外を投出するか ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If throwExceptions is true, then throw a "InvalidStateError" DOMException.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

<p class="trans-note">【
%期待される可視性~状態 は，原文では真偽値をとるが、
明快にするため，`~popover可視性~状態$がとり得る値をとるよう改める。
】</p>
</div>

			</section>
			<section id="the-popover-target-attributes">
<h4 title="The popover target attributes">6.11.1. ~popover~target属性</h4>

<p>
各`~button$は、
次に挙げる各~内容~属性を有してもヨイ
— これらは、
`~popover~target属性@
と総称される
⇒＃
`popovertarget@a,
`popovertargetaction@a
◎
Buttons may have the following content attributes:
• popovertarget
• popovertargetaction
</p>

<p>
`popovertarget$a 属性に指定する値は、
次を満たす要素の`~ID$でなければナラナイ
⇒
［
`popover$a 属性を有する
］~AND［
当の`~button$と同じ`~tree$内にある
］
◎
If specified, the popovertarget attribute value must be the ID of an element with a popover attribute in the same tree as the button with the popovertarget attribute.
</p>

<p>
`popovertargetaction$a 属性は，`列挙d属性$であり、
次に挙げる~keyword, とり得る状態, それらの対応付けが定義される：
◎
The popovertargetaction attribute is an enumerated attribute with the following keywords and states:
</p>

<div>
<table><thead><tr>
<th>~keyword
<th>状態
<th>概略的な記述
</thead><tbody>

<tr><td>`toggle@v
<td>`~toggleする@st
<td>~targetにされた~popover要素を［
示す／隠す
］。
<tr><td>`show@v
<td>`示す@st
<td>~targetにされた~popover要素を示す。
<tr><td>`hide@v
<td>`隠す@st
<td>~targetにされた~popover要素を隠す。
</tbody></table>
◎
The popovertargetaction attribute is an enumerated attribute with the following keywords and states:
◎
Keyword｜State｜Brief description
toggle｜toggle｜Shows or hides the targeted popover element.
show｜show｜Shows the targeted popover element.
hide｜hide｜Hides the targeted popover element.
</div>

<p>
`popovertargetaction$a 属性の［
`妥当でない値~用の既定の状態$／
`値なし用の既定の状態$
］は， `~toggleする$st とする。
◎
The popovertargetaction attribute's invalid value default and missing value default are both the toggle state.
</p>

<p class="note">注記：
アリなときは、
~DOM内で［
~popover要素が，それを誘発している要素の直後に配置される
］ことを確保すること。
そうすれば、［
~screen~readerなどの支援~技術の利用者
］に対し［
当の~popoverが，論理的~program的な読取り順序で公開される
］ことを確保する助けになる。
◎
Whenever possible ensure the popover element is placed immediately after its triggering element in the DOM. Doing so will help ensure that the popover is exposed in a logical programmatic reading order for users of assistive technology, such as screen readers.
</p>

<div class="example">
<p>
`popovertarget$a 属性を `popovertargetaction$a 属性と組合せて，
~popoverを［
示す, 閉じる
］ために どう利用できるかを次に示す：
◎
The following shows how the popovertarget attribute in combination with the popovertargetaction attribute can be used to show and close a popover:
</p>

`popover-target-attribute-1^xCode

<p>
`popovertargetaction$a 属性が指定されなかった場合、
結付けられた~popoverを~toggleすることが既定の動作になる。
それを呼出している~buttonに `popovertarget$a 属性を指定するだけで，
`手動$stな~popoverの［
開な状態, 閉な状態
］を~toggleできる様子を次に示す。
手動な~popoverは、
`軽く退ける$ふるまいを伴わない：
◎
If a popovertargetaction attribute is not specified, the default action will be to toggle the associated popover. The following shows how only specifying the popovertarget attribute on its invoking button can toggle a manual popover between its opened and closed states. A manual popover will not light dismiss:
</p>

`popover-target-attribute-2^xCode

</div>

<p>
【！`~DOM~interface$】
◎
DOM interface:
</p>

<pre class="idl">
interface mixin `PopoverInvokerElement@I {
  [`CEReactions$] attribute Element? `popoverTargetElement$m;
  [`CEReactions$] attribute DOMString `popoverTargetAction$m;
}
</pre>

<p>
`popoverTargetElement@m
~IDL属性は、
`popovertarget$a 属性を`反映する$モノトスル。
◎
The popoverTargetElement IDL attribute must reflect the popovertarget attribute.
</p>

<p>
`popoverTargetAction@m
~IDL属性は、
`既知な値のみに制限され$る下で，
`popovertargetaction$a 属性を`反映する$モノトスル。
◎
The popoverTargetAction IDL attribute must reflect the popovertargetaction attribute, limited to only known values.
</p>

<div class="algo">
<p>
`~popover~target属性~作動化の挙動@
は、
所与の
( `~node$ %~node )
に対し，次を走らす：
◎
To run the popover target attribute activation behavior given a Node node:
</p>
<ol>
	<li>
%~popover ~LET %~node の`~popover~target要素$
◎
Let popover be node's popover target element.
</li>
	<li>
%属性~状態 ~LET %~node の `popovertargetaction$a 属性の状態
◎
↓</li>
	<li>
%可視性~状態 ~LET %~popover の`~popover可視性~状態$
◎
↓</li>
	<li>
~IF［
%~popover ~EQ ~NULL
］
⇒
~RET
◎
If popover is null, then return.
</li>
	<li>
~IF［
%属性~状態 ~EQ `示す$st【！`show$v】
］~AND［
%可視性~状態 ~EQ `示している$i
］
⇒
~RET
◎
If node's popovertargetaction attribute is in the show state and popover's popover visibility state is showing, then return.
</li>
	<li>
~IF［
%属性~状態 ~EQ `隠す$st【！`hide$v】
］~AND［
%可視性~状態 ~EQ `隠している$i
］
⇒
~RET
◎
If node's popovertargetaction attribute is in the hide state and popover's popover visibility state is hidden, then return.
</li>
	<li>
~IF［
%可視性~状態 ~EQ `示している$i
］
⇒
`~popoverを隠す$( %~popover, ~T, ~T, ~F )
◎
If popover's popover visibility state is showing, then run the hide popover algorithm given popover, true, true, and false.
</li>
	<li>
~ELIF［
%可視性~状態 ~EQ `隠している$i
］~AND［
`~popoverの妥当性を検査する$( %~popover, `隠している$i, ~F, ~NULL ) ~EQ ~T
］
⇒
`~popoverを示す$( %~popover, ~F, %~node )
◎
Otherwise, if popover's popover visibility state is hidden and the result of running check popover validity given popover, false, false, and null is true, then run show popover given popover, false, and node.
</li>
</ol>
</div>

<div class="algo">
<p>
`~popover~target要素@
を取得するときは、
所与の
( `~node$ %~node )
に対し，次の手続きを遂行する
— これは、［
`~HTML要素$ ／ ~NULL
］を返す：
◎
To get the popover target element given a Node node, perform the following steps. They return an HTML element or null.
</p>
<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%~node は`~button$でない
</li>
			<li>
%~node は`不能化されて$いる
</li>
			<li>
［
%~node の`~form所有者$ ~NEQ ~NULL
］~AND［
%~node は`提出-~button$である
］
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>
◎
If node is not a button, then return null.
◎
If node is disabled, then return null.
◎
If node has a form owner and node is a submit button, then return null.
</li>
	<li>
%~popover要素 ~LET %~node の `popovertarget^c【 `popoverTargetElement$m 】 用に`結付けられた要素$
◎
Let popoverElement be node's popovertarget-associated element.
</li>
	<li>
~IF［
%~popover要素 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If popoverElement is null, then return null.
</li>
	<li>
~IF［
%~popover要素 は`~popover要素$でない
］
⇒
~RET ~NULL
◎
If popoverElement's popover attribute is in the no popover state, then return null.
</li>
	<li>
~RET %~popover要素
◎
Return popoverElement.
</li>
</ol>
</div>

			</section>
			<section id="popover-light-dismiss">
<h4 title="Popover light dismiss">6.11.2. ~popoverを軽く退ける</h4>

<p class="note">注記：
“軽く退ける（ `light dismiss^en ）” とは、
次を意味する
⇒
`~popover要素$のうち［
その `popover$a 属性の状態 ~EQ `自動$st
］を満たすものに対し［
<kbd>Esc</kbd> ~UIkeyを押下げる／
当の~popoverの外側を~clickする
］と，当の~popoverを閉じることになる。
◎
"Light dismiss" means that pressing the Esc key or clicking outside of a popover whose popover attribute is in the auto state will close the popover.
</p>

<div class="algo">
<p>
`~popoverの取消-法＠#canceling-popovers@
⇒
`文書$の`最上層な自動~popover$を示しているときは、
~UAは，［
その作動化に際して次を行う~UI
］を供してもヨイ
⇒
`要素~taskを~queueする$( `利用者~対話~task源$, `最上層な自動~popover$, 次の手続き )
</p>

<p class="algo">
手続きは
⇒
`~popoverを隠す$( `最上層な自動~popover$, ~T, ~T, ~F )
</p>
◎
Canceling popovers: when Document has a topmost auto popover showing, user agents may provide a user interface that, upon activation, queues an element task on the user interaction task source given topmost auto popover to run the hide popover algorithm given the topmost auto popover, true, true, and false.
</div>

<div class="algo">
<p>
`開な~popoverたちを軽く退ける@
ときは、
所与の
( `Event$I %~event )
に対し：
◎
To light dismiss open popovers, given an Event event:
</p>
<ol>
	<li>
~Assert：
%~event の `isTrusted$m 属性 ~EQ ~T
◎
Assert: event's isTrusted attribute is true.
</li>
	<li>
%~target ~LET %~event の`~target$
◎
Let target be event's target.
	<li>
~Assert：
%~target ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%文書 ~LET %~target の`~node文書$
◎
↓</li>
	<li>
%最上層な~popover ~LET `最上層な自動~popover$( %文書 )
【原文では引数として %~target を渡しているが、型が合致しない。】
◎
Let topmostPopover be the result of running topmost auto popover given target.
</li>
	<li>
~IF［
%最上層な~popover ~EQ ~NULL
］
⇒
~RET
◎
If topmostPopover is null, then return.
◎
↑Let document be target's node document.
</li>
	<li>
~IF［
%~event は `PointerEvent$I ~objでない
］
⇒
~RET
◎
↓</li>
	<li>
<p>
%~event の `type$m に応じて
</p>
		<ul>
			<li>
"`pointerdown$et"
⇒
%文書 の`~popover~pointerdown~target$doc ~SET 
`最上層な~clickされた~popover$( %~target )
◎
If event is a PointerEvent and event's type is pointerdown, then: set document's popover pointerdown target to the result of running topmost clicked popover given target.
</li>
			<li>
<p>
"`pointerup$et" ：
◎
If event is a PointerEvent and event's type is pointerup, then:
</p>
				<ol>
					<li>
%先祖 ~LET `最上層な~clickされた~popover$( %~target )
◎
Let ancestor be the result of running topmost clicked popover given target.
</li>
					<li>
%同じ~targetか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%先祖 ~EQ %文書 の`~popover~pointerdown~target$doc
◎
Let sameTarget be true if ancestor is document's popover pointerdown target.
</li>
					<li>
%文書 の`~popover~pointerdown~target$doc ~SET ~NULL
◎
Set document's popover pointerdown target to null.
</li>
					<li>
~IF［
%先祖 ~EQ ~NULL
］
⇒
%先祖 ~SET %文書
◎
If ancestor is null, then set ancestor to document.
</li>
					<li>
~IF［
%同じ~targetか ~EQ ~T
］
⇒
`ある所までの~popoverをすべて隠す$( %先祖, ~F, ~T )
◎
If sameTarget is true, then run hide all popovers until given ancestor, false, and true.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>

<p class="XXX">
`開な~popoverたちを軽く退ける$は、
`Pointer Events 仕様＠https://github.com/w3c/pointerevents/pull/460$
により，利用者が~page上のどこかを［
~clickした／~touchした
］とき~callされることになる。
◎
Light dismiss open popovers will be called by the Pointer Events spec when the user clicks or touches anywhere on the page.
</p>
</div>

<div class="algo">
<p>
`最上層な~clickされた~popover@
を見出すときは、
所与の
( `~node$ %~node )
に対し：
◎
To find the topmost clicked popover, given a Node node:
</p>
<ol>
	<li>
%~clickされた~popover ~LET `広義-先祖のうち最も近い開な~popover$( %~node )
◎
Let clickedPopover be the result of running nearest inclusive open popover given node.
</li>
	<li>
%呼出元~popover ~LET `呼出元~用の最も近い広義-~target~popover$( %~node )
◎
Let invokerPopover be the result of running nearest inclusive target popover for invoker given node.
</li>
			<li>
%~popover~list ~LET %~node【！%~popover】 の`~node文書$の`自動~popover~list$doc
◎
↓</li>
	<li class="algo">
%~stack位置を取得する ~LET 所与の
( `~HTML要素$ %~popover )
に対し，次の手続きを遂行する~algo
⇒
~RET ［
%~popover ~NIN %~popover~list ならば 0 ／
~ELSE_ ( %~popover~list 内での %~popover の~index ) ~PLUS 1
］
◎
Let getStackPosition be an algorithm which performs the following steps given an HTML element popover:
• ↑Let popoverList be popover's node document's auto popover list.
• If popover is in popoverList, then return the index of popover in popoverList + 1.
• Return 0.
</li>
	<li>
~RET ［
次が満たされるならば %~clickされた~popover ／
~ELSE_ %呼出元~popover
］
⇒
［
%~stack位置を取得する( %~clickされた~popover )
~GT
%~stack位置を取得する( %呼出元~popover )
］
◎
If the result of running getStackPosition given clickedPopover is greater than the result of running getStackPosition given invokerPopover, then return clickedPopover.
◎
Return invokerPopover.
</li>
</ol>
</div>

<div class="algo">
<p>
`呼出元~用の最も近い広義-~target~popover@
を見出すときは、
所与の
( `~node$ %~node )
に対し：
◎
To find the nearest inclusive target popover for invoker given a Node node:
•↓ Let currentNode be node.
</p>
<ol>
	<li>
<p>
~WHILE［
%~node ~NEQ ~NULL
］：
◎
While currentNode is not null:
</p>
		<ol>
			<li>
%~target~popover ~LET %~node の`~popover~target要素$
◎
Let targetPopover be currentNode's popover target element.
</li>
			<li>
~IF［
%~target~popover ~NEQ ~NULL
］~AND［
%~target~popover の `popover$a 属性の状態 ~EQ `自動$st
］~AND［
%~target~popover の`~popover可視性~状態$ ~EQ `示している$i
］
⇒
~RET %~target~popover
◎
If targetPopover is not null and targetPopover's popover attribute is in the auto state and targetPopover's popover visibility state is showing, then return targetPopover.
</li>
			<li>
%~node ~SET `平坦~tree$における %~node の先祖
【どの先祖？ “親” の誤記？】
◎
Set currentNode to currentNode's ancestor in the flat tree.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="the-toggleevent-interface">
<h4 title="The ToggleEvent interface">6.11.3. `ToggleEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `ToggleEvent@I : `Event$I {
  constructor(DOMString type, optional `ToggleEventInit$I %eventInitDict = {});
  readonly attribute DOMString `oldState$m;
  readonly attribute DOMString `newState$m;
};

dictionary `ToggleEventInit@I : `EventInit$I {
  DOMString oldState = "";
  DOMString newState = "";
};
</pre>

<dl class="domintro">
	<dt>%event.`oldState$m</dt>
	<dd>
［
閉な状態から開な状態へ遷移しているときは `closed^l ／ 
逆へ遷移しているときは `open^l 
］に設定される。
◎
Set to "closed" when transitioning from closed to open, or set to "open" when transitioning from open to closed.
</dd>
	<dt>%event.`newState$m</dt>
	<dd>
［
開な状態から閉な状態へ遷移しているときは `closed^l ／
逆へ遷移しているときは `open^l 
］に設定される。
◎
Set to "open" when transitioning from closed to open, or set to "closed" when transitioning from open to closed.
</dd>
</dl>

<p>
`oldState@m
属性は、
初期化~時の値を返すモノトスル。
それは、
当の`~popover要素$の`~popover可視性~状態$に応じて，［
`示している$i ならば `open^l ／
`隠している$i ならば `closed^l
］に初期化される。
◎
The oldState attribute must return the value it was initialized to. It is initialized to "open" if the element with the popover attribute's popover visibility state is showing; otherwise "closed".
</p>

<p>
`newState@m
属性は、
初期化~時の値を返すモノトスル。
それは、
当の`~popover要素$の`~popover可視性~状態$に応じて，［
`示している$i ならば `closed^l ／
`隠している$i ならば `open^l
］に初期化される。
◎
The newState attribute must return the value it was initialized to. It is initialized to "closed" if the element with the popover attribute's popover visibility state is showing; otherwise "open".
</p>

			</section>
</main>
