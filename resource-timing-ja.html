<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
#_time-table {
	display: flex;
	flex-flow: column;
	gap: 0.5em;
	background: var(--example-bg-color);
	padding: 0.5em;
}
x-tt-box {
	display: block;
	border: thin solid var(--N-color);
	position: relative;
	padding: 0.5em;
	width: 11em;
}

x-tt-delay {
	display: block;
	position: relative;
	width: 12em;
	text-align: center;
}

x-tt-attr {
	position: absolute;
	left: 12.5em;
	min-width: 20em;
	white-space: nowrap;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key.replace(/!.*/, '');

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'at':
	text = `@${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `https://github.com/w3c/resource-timing/issues/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-08-05
trans_update:2025-08-16
source_checked:221110
page_state_key:TIMING
original_url:https://w3c.github.io/resource-timing/
	abbr_url:RESOURCE-TIMING
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
copyright:2025,permissive
trans_1st_pub:2013-01-23

●●class_map
h:header
e:element
a:attr
et:event-type
P:production
v:value
at:at-rule
d:descriptor
css:css
st:status

●●tag_map
I:code
m:code
c:code
h:code
e:code
a:code
et:code
P:code
at:code
d:code
css:code
v:code
st:code
i:i

●●original_id_map

dom-performanceresourcetiming-requestend:dfn-requestend

●●mdn_urls
dfn-timing-allow-origin:HTTP/Headers/Timing-Allow-Origin

dom-performanceresourcetiming:API/PerformanceResourceTiming
dom-performance-clearresourcetimings:API/Performance/clearResourceTimings
dom-performance-setresourcetimingbuffersize:API/Performance/setResourceTimingBufferSize
dom-performance-onresourcetimingbufferfull:API/Performance/onresourcetimingbufferfull
dom-performanceresourcetiming-connectend:API/PerformanceResourceTiming/connectEnd
dom-performanceresourcetiming-connectstart:API/PerformanceResourceTiming/connectStart
dom-performanceresourcetiming-decodedbodysize:API/PerformanceResourceTiming/decodedBodySize
dom-performanceresourcetiming-responsestatus:API/PerformanceResourceTiming/responseStatus
dom-performanceresourcetiming-domainlookupend:API/PerformanceResourceTiming/domainLookupEnd
dom-performanceresourcetiming-domainlookupstart:API/PerformanceResourceTiming/domainLookupStart
dom-performanceresourcetiming-encodedbodysize:API/PerformanceResourceTiming/encodedBodySize
dom-performanceresourcetiming-fetchstart:API/PerformanceResourceTiming/fetchStart
dom-performanceresourcetiming-initiatortype:API/PerformanceResourceTiming/initiatorType
dom-performanceresourcetiming-nexthopprotocol:API/PerformanceResourceTiming/nextHopProtocol
dom-performanceresourcetiming-redirectend:API/PerformanceResourceTiming/redirectEnd
dom-performanceresourcetiming-redirectstart:API/PerformanceResourceTiming/redirectStart
dom-performanceresourcetiming-requeststart:API/PerformanceResourceTiming/requestStart
dom-performanceresourcetiming-finalresponseheadersstart:API/PerformanceResourceTiming/finalResponseHeadersStart
	dom-performanceresourcetiming-firstinterimresponsestart:API/PerformanceResourceTiming/firstInterimResponseStart
dom-performanceresourcetiming-responseend:API/PerformanceResourceTiming/responseEnd
dom-performanceresourcetiming-responsestart:API/PerformanceResourceTiming/responseStart
dom-performanceresourcetiming-secureconnectionstart:API/PerformanceResourceTiming/secureConnectionStart
dom-performanceresourcetiming-tojson:API/PerformanceResourceTiming/toJSON
dom-performanceresourcetiming-transfersize:API/PerformanceResourceTiming/transferSize
dom-performanceresourcetiming-workerstart:API/PerformanceResourceTiming/workerStart
	dom-performanceresourcetiming-renderblockingstatus:API/PerformanceResourceTiming/renderBlockingStatus

_resourcetimingbufferfull:API/Performance/resourcetimingbufferfull_event

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default

DOMString:~WEBIDL#idl-DOMString
ByteString:~WEBIDL#idl-ByteString
undefined:~WEBIDL#idl-undefined
object:~WEBIDL#idl-object
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
unsigned short:~WEBIDL#idl-unsigned-short
DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp

I.PerformanceResourceTiming:#dom-performanceresourcetiming
I.RenderBlockingStatusType:#dom-renderblockingstatustype
I.XMLHttpRequest:~XHR#xmlhttprequest
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	~TR/hr-time-2/#domhighrestimestamp
I.Performance:~HRTIME#dom-performance
I.PerformanceEntry:~TIMELINE#dom-performanceentry
I.PerformanceObserver:~TIMELINE#dom-performanceobserver
I.EventHandler:~WAPI#eventhandler
	I.Document
I.Worker:~WORKERS#worker
I.EventSource:~HTMLsse#eventsource

m.toJSON:#dom-performanceresourcetiming-tojson
m.initiatorType:#dom-performanceresourcetiming-initiatortype
m.deliveryType:#dom-performanceresourcetiming-deliverytype
m.nextHopProtocol:#dom-performanceresourcetiming-nexthopprotocol
m.workerStart:#dom-performanceresourcetiming-workerstart
m.redirectStart:#dom-performanceresourcetiming-redirectstart
m.redirectEnd:#dom-performanceresourcetiming-redirectend
m.fetchStart:#dom-performanceresourcetiming-fetchstart
m.domainLookupStart:#dom-performanceresourcetiming-domainlookupstart
m.domainLookupEnd:#dom-performanceresourcetiming-domainlookupend
m.connectStart:#dom-performanceresourcetiming-connectstart
m.connectEnd:#dom-performanceresourcetiming-connectend
m.secureConnectionStart:#dom-performanceresourcetiming-secureconnectionstart
m.requestStart:#dom-performanceresourcetiming-requeststart
m.finalResponseHeadersStart:#dom-performanceresourcetiming-finalresponseheadersstart
m.firstInterimResponseStart:#dom-performanceresourcetiming-firstinterimresponsestart
m.responseStart:#dom-performanceresourcetiming-responsestart
m.responseEnd:#dom-performanceresourcetiming-responseend
m.transferSize:#dom-performanceresourcetiming-transfersize
m.encodedBodySize:#dom-performanceresourcetiming-encodedbodysize
m.decodedBodySize:#dom-performanceresourcetiming-decodedbodysize
m.responseStatus:#dom-performanceresourcetiming-responsestatus
m.renderBlockingStatus:#dom-performanceresourcetiming-renderblockingstatus
m.contentType:#dom-performanceresourcetiming-contenttype
m.contentEncoding:#dom-performanceresourcetiming-contentencoding

m.clearResourceTimings:#dom-performance-clearresourcetimings
m.setResourceTimingBufferSize:#dom-performance-setresourcetimingbuffersize
m.onresourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull

m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes
m.startTime:~TIMELINE#dom-performanceentry-starttime
m.duration:~TIMELINE#dom-performanceentry-duration

m.fetch:~FETCH#dom-global-fetch
m.sendBeacon:~BEACON#dom-navigator-sendbeacon

l.blocking:#dom-renderblockingstatustype-blocking
l.non-blocking:#dom-renderblockingstatustype-non-blocking

	●code 他

e.a:~HEtextlevel#the-a-element
e.audio:~HEmedia#the-audio-element
	e.audio:~HEmedia#audio
e.body:~HEsections#the-body-element
e.frame:~HTMLobs#frame
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.link:~HEmetadata#the-link-element
e.object:~HEembed#the-object-element
e.track:~HEtrack#the-track-element
e.video:~HEmedia#the-video-element
	~HEmedia#video
e.script:~HEscripting#the-script-element
	e.script:~HEscripting#script
e.image:~SVGembedded#elementdef-image
	#ImageElement
e.svg:~SVGstruct#elementdef-svg
	e.svg:~SVG11/struct.html#SVGElement

a.poster:~HEmedia#attr-video-poster
a.srcset:~HEimages#attr-img-srcset
a.ping:~HTMLlinks#ping
a.type:~HEinput#attr-input-type
a.src!embed:~HEembed#attr-embed-src
a.src!media:~HEmedia#attr-media-src
a.src!track:~HEtrack#attr-track-src
a.src!img:~HEimages#attr-img-src
a.src!iframe:~HEembed#attr-iframe-src

at.font-face:~CSSFONT#at-font-face-rule

et.resourcetimingbufferfull:#_resourcetimingbufferfull

h.Timing-Allow-Origin:#dfn-timing-allow-origin
	h.Origin:~RFCx/rfc6454#section-4
st.103:~HTTPearlyhints#early-hints

P.origin-or-null:~FETCH#origin-header
P.wildcard:~FETCH#http-new-header-syntax

v.stylesheet:~HTMLlinks#link-type-stylesheet
v.url():~CSSVAL#funcdef-url
v.image:~HEinput#attr-input-type-image-keyword
	st.Image:~HEinput#image-button-state-(type=image)

	●用語

資源~計時~bufferの~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~bufferの現-~size:#dfn-resource-timing-buffer-current-size
資源~計時~buffer満杯~eventは処理待ちか:#dfn-resource-timing-buffer-full-event-pending-flag
資源~計時~副-~buffer:#dfn-resource-timing-secondary-buffer
資源~計時~副-~bufferの現-~size:#dfn-resource-timing-secondary-buffer-current-size

処理能~entry~bufferに~entryを追加する:#dfn-add-a-performanceresourcetiming-entry
資源~計時~entryを追加でき:#dfn-can-add-resource-timing-entry
~buffer満杯~eventを発火する:#dfn-fire-a-buffer-full-event
副-~buffer内の~entryを移動する:#dfn-copy-secondary-buffer

処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer
処理能~entry~buffer~map:~TIMELINE#dfn-performance-entry-buffer-map
処理能~時列線:~TIMELINE#performance-timeline
	#sec-performance-timeline
	Performance:~TR/navigation-timing-2/#performance
処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
処理能~時列線~task~source:~TIMELINE#dfn-performance-timeline-task-source
PE.初期化する:~TIMELINE#dfn-initialize-a-performanceentry

~fetch時刻印を変換する:#dfn-convert-fetch-timestamp
資源~計時を~markする:#dfn-mark-resource-timing
資源~計時~entryを設定しておく:#dfn-setup-the-resource-timing-entry

pT.起動元~種別:#dfn-initiator-type
pT.送達~種別:#dfn-delivery-type
pT.要請~URL:#dfn-requested-url
pT.~cache~mode:#dfn-cache-mode
pT.計時~報:#dfn-timing-info
pT.資源~情報:#dfn-resource-info
pT.応答~状態s:#dfn-response-status
pT.具現化を阻むか:#dfn-render-blocking-status

	●用語（外部

要請:~FETCH#concept-request
~navi要請:~FETCH#navigation-request
rq.~client:~FETCH#concept-request-client
rq.~mode:~FETCH#concept-request-mode
不透明な絞込み応答:~FETCH#concept-filtered-response-opaque

~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~HTTP~fetch:~FETCH#concept-http-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~TAO検査:~FETCH#concept-tao-check
	§ ~TAO検査:~FETCH#tao-check

cT.折衝した~ALPN~protocol~ID:~FETCH#connection-timing-info-alpn-negotiated-protocol
cT.接続~終了~時刻:~FETCH#connection-timing-info-connection-end-time
cT.接続~開始~時刻:~FETCH#connection-timing-info-connection-start-time
cT.~domain検索~終了~時刻:~FETCH#connection-timing-info-domain-lookup-end-time
cT.~domain検索~開始~時刻:~FETCH#connection-timing-info-domain-lookup-start-time
cT.~secure接続~開始~時刻:~FETCH#connection-timing-info-secure-connection-start-time

~fetch計時~報:~FETCH#fetch-timing-info
fT.終了~時刻:~FETCH#fetch-timing-info-end-time
fT.最終-~network要請~開始~時刻:~FETCH#fetch-timing-info-final-network-request-start-time
fT.最初の非最終-~network応答~開始~時刻:~FETCH#fetch-timing-info-first-interim-network-response-start-time
fT.最終-~network応答~開始~時刻:~FETCH#fetch-timing-info-final-network-response-start-time
fT.最終-~sw開始~時刻:~FETCH#fetch-timing-info-final-service-worker-start-time
fT.最終-接続~計時~報:~FETCH#fetch-timing-info-final-connection-timing-info
fT.~redirect後からの開始~時刻:~FETCH#fetch-timing-info-post-redirect-start-time
fT.~redirect終了~時刻:~FETCH#fetch-timing-info-redirect-end-time
fT.~redirect開始~時刻:~FETCH#fetch-timing-info-redirect-start-time
fT.開始~時刻:~FETCH#fetch-timing-info-start-time

応答~本体~報:~FETCH#response-body-info
fT.符号化された~size:~FETCH#fetch-timing-info-encoded-body-size
fT.復号した~size:~FETCH#fetch-timing-info-decoded-body-size
fT.具現化を阻んでいるか:~FETCH#fetch-timing-info-render-blocking
状態s:~FETCH#concept-status
fT.内容~型:~FETCH#response-body-info-content-type
fT.内容~符号化法:~FETCH#response-body-info-content-encoding

接続~計時~報を記録する:~FETCH#record-connection-timing-info

既定の~toJSON手続き:~WEBIDLjs#default-tojson-steps

	data: URI:~RFCx/rfc2397
同一-生成元:~ORIGIN#same-origin
	生成元:~ORIGIN#concept-origin

~eventを発火する:~DOM4#concept-event-fire

作動中な~worker:~SW1#dfn-active-worker

相対的な粗い高分解能~時刻:~HRTIME#dfn-relative-high-resolution-coarse-time

大域~obj:~WAPI#concept-settings-object-global
enV.大域~obj:~WAPI#concept-settings-object-global
~taskを~queueする:~WAPI#queue-a-task
gL.~realm:~WAPI#concept-global-object-realm
関連な大域~obj:~WAPI#concept-relevant-global
~script:~WAPI#concept-script
古典~script:~WAPI#classic-script
~module~script:~WAPI#module-script


同型に復号する:~INFRA#isomorphic-decode
文字列:~INFRA#string

コレ:~WEBIDL#this

~header節:~HTTPinfra#header-section

	-:#dfn-dom
	-:#dfn-getting
	-:#dfn-setting
	-:#dfn-javascript
	-:#dom



●●words_table1
HTTPearlyhints:http-status-code-103-ja.html
BEACON:beacon-ja.html

●●words_table

	●fetch／HTTP/network
TLS:
DNS:
TCP:
QUIC:
ALPN:
検索:lookup::~
端点間:end-to-end::~::エンドツーエンド
符号法:coding::~::コーディング
network-or-cache::::ネットワーク-or-キャッシュ
	送信し直:resend
事前条件:precondition::~
再検証-:revalidate::~
再検証:revalidation::~

hit::::ヒット
miss::::ミス
到着-:arrive:~
preload:
prefetch:
早期:early::~

	●計時
高分解能:high resolution::~
最終-:final::~
非最終-:interim::~
粗い:coarseな:~
時機:timing::~
時区間:interval::~
相:phase:~

	かかった時間:time it takes to
	費やされ:takes／spent
	処理能~時列線:Performance Timeline
	開始-時:right at the start

	●処理一般
満杯:full::~
処理待ち:pending:~
同型:isomorphic::~
現-:current:~
副-:secondary:~
絞込み:filtered::絞り込み::フィルタ済み

	総:total
	定数:constant number
	伝送途上にある:in-flight

	%~buffer:buffer
	%~entry:new entry
	%~entry:entry
	%計時~報:timingInfo
	%要請された~URL:requestedURL
	%起動元~種別:initiatorType
	%時刻印:ts
	%大域~obj:global
	%~cache~mode:cacheMode
	%移動したか:-
	%本体~報:bodyInfo
	%応答~状態s:responseStatus
	%送達~種別:deliveryType

	●保安
統計的:statistical:~
mask::::マスク
TAO:
露呈-:reveal:露わに

	●仕様
包括的:comprehensive:~
様相:picture:~
暫定的:provisional:~
上限:limit:~
benchmark::::ベンチマーク
流儀:fashion:~
拡げら:expandさ:~

	必要性:need:~
	~~手段:instrumentation
	仕立て上げ:be modified to
	足りる:sufficiently
	しておく:make sure
	方法:-
	図式:graph
	内訳
	とする:suppose
	更なる情報:for more info

	●未分類
内包-:include:~
知覚-:perceive:~
	JS:ECMAScript
品質:quality:~
	正準-形が同じになる:canonical URL
toJSON:
列挙型:enum::~

	文字列$:DOMString
	文字列$:DOMStrring

	-:underline
	可能
	移動できなかった~entryは:does not add more room in the buffer than it adds resources to it
	-:excess
	number of excess entries
	後続-:follow
	対象にする:included
	〜内の~entryを移動する:copy
	無けれ:if not present
	時点
	個数:number of／:how many
	最初の:oldest
	見込まれ:might
	末尾:the end
	有無:presence
	何箇所か:places
	^P:wildcard


●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HR-TIME]
    High Resolution Time. Yoav Weiss. W3C. 7 November 2024. W3C Working Draft. URL: https://www.w3.org/TR/hr-time-3/ 
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Dominic Farolino; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Yoav Weiss; Noam Rosenthal. W3C. 13 February 2025. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/ 
[PERFORMANCE-TIMELINE-2]
    Performance Timeline. Nicolas Pena Moreno. W3C. 21 May 2025. CRD. URL: https://www.w3.org/TR/performance-timeline/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC2397]
    The "data" URL scheme. L. Masinter. IETF. August 1998. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc2397 
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc5234 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[RFC9110]
    HTTP Semantics. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed. IETF. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9110.html 
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 

●●ref_informative

[BEACON]
    Beacon. Ilya Grigorik; Alois Reitbauer. W3C. 3 August 2022. CRD. URL: https://www.w3.org/TR/beacon/ 
[CSS-VALUES]
    CSS Values and Units Module Level 3. Tab Atkins Jr.; Elika Etemad. W3C. 22 March 2024. CRD. URL: https://www.w3.org/TR/css-values-3/ 
[css-values-4]
    CSS Values and Units Module Level 4. Tab Atkins Jr.; Elika Etemad. W3C. 12 March 2024. W3C Working Draft. URL: https://www.w3.org/TR/css-values-4/ 
[EARLY_HINTS]
    Early hints. URL: https://httpwg.org/specs/rfc8297.html 
[INCREMENTAL_FONT_TRANSFER]
    Incremental Font Transfer. URL: https://www.w3.org/TR/IFT/ 
[SVG11]
    Scalable Vector Graphics (SVG) 1.1 (Second Edition). Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. W3C. 16 August 2011. W3C Recommendation. URL: https://www.w3.org/TR/SVG11/ 
[SVG2]
    Scalable Vector Graphics (SVG) 2. Amelia Bellamy-Royds; Bogdan Brinza; Chris Lilley; Dirk Schulze; David Storey; Eric Willigers. W3C. 4 October 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/SVG2/ 
[XHR]
    XMLHttpRequest Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://xhr.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、
~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Resource Timing</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/resource-timing/
編集者草案
	https://w3c.github.io/resource-timing/
公表履歴
	https://www.w3.org/standards/history/resource-timing/
commit 履歴
	https://github.com/w3c/resource-timing/commits/
実装報告
	https://w3c.github.io/test-results/resource-timing/all.html
編集
	<a href="https://blog.yoav.ws/">Yoav Weiss</a> (Google)
	<a href="mailto:nrosenthal@chromium.org">Noam Rosenthal</a> (Google)
前任編集者
	<a href="mailto:igrigorik@gmail.com">Ilya Grigorik</a> (Google) (Until January 2021)
	<a href="mailto:toddreif@microsoft.com">Todd Reifsteck</a> (Microsoft Corp.) (Until January 2021)
	<a href="mailto:arvind@google.com">Arvind Jain</a> (Google Inc.) (Until December 2014)
	<a href="mailto:jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until February 2014)
	Zhiheng Wang (Google Inc.) (Until July 2012)
	Anderson Quach (Microsoft Corp.) (Until March 2011)
フィードバック
	<a href="https://github.com/w3c/resource-timing/">GitHub w3c/resource-timing</a> (<a href="https://github.com/w3c/resource-timing/pulls/">pull requests</a>, <a href="https://github.com/w3c/resource-timing/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/resource-timing/issues/">open issues</a>)
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>

ブラウザサポート
	https://caniuse.com/resource-timing
公表者
	<a href="https://www.w3.org/groups/wg/webperf">Web Performance WG</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1>リソースの計時 — Resource Timing</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約
<p>
この仕様は、
~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、公表~時点における…
【以下、この他の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
利用者が知覚し得る待時間は Web ~appにとり重要な品質~benchmarkである。
~JSに基づく仕組みは、
~appにおける利用者~側の待時間を測定するための包括的な~~手段を供せるが、
端点間の待時間については，多くの事例で，完全な様相を供せない。
この仕様は、
`PerformanceResourceTiming$I ~interfaceを導入する。
それは、
~JSにより，文書~上の資源に関係する完全な計時~情報を収集するための仕組みである。
`NAVIGATION-TIMING-2$r は、
この仕様を拡張して，~naviに関わる追加的な計時~情報を供する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. This document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document. Navigation Timing 2 [NAVIGATION-TIMING-2] extends this specification to provide additional timing information associated with a navigation.
</p>

<div class="example">
<p>
例えば、
次のような~JSで，
資源~fetchにかかった時間を単純に測定しようと試みた場合：
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %start = new Date().getTime();
   var %image1 = new Image();
   var %resourceTiming = function() {
       var %now = new Date().getTime();
       var %latency = %now - %start;
       alert("End to end resource fetch: " + %latency);
   };

   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源~fetchに要した時間は測定できるが、
その内訳を成す各~相に費やされた時間は測定できない。
更に、
~markupにより記述された資源に費やされた時間を，
この~scriptで測定することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に取組むため、
この文書は `PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、
~JSによる［
~client側~appにおける待時間の完全な測定を可能にする仕組み
］を供する。
この~interfaceにより、
前の例は，利用者が知覚する資源の読込n時間を測定-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、
~markupにより定義されたものまで含め，
~page内の各~資源~fetchに要した時間の~~長さを計算する。
この例は、
~pageが <samp>https://www.w3.org</samp> の下に~hostされていると見做している。
その気になれば、
`PerformanceResourceTiming$I ~interfaceを利用して，
資源~fetchingの各~相に要した時間も測定できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on https://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %image1 = new Image();
   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var %resourceList = window.performance.getEntriesByType("resource");
    for (%i = 0; %i &lt; %resourceList.length; i++) {
       if (%resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( %resourceList[i].responseEnd  - %resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>
	<section id="conformance">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
`~W3C日本語訳 共通~page＠~W3Ccommon#conformance$
に移譲。
】</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
この節の内容の和訳は、
省略する。
】
◎
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo.
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME]. For example, the start of navigation of the document occurs at time 0.
◎
Note

This definition of time is based on the High Resolution Time specification [HR-TIME] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING-2], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

		</section>
	</section>
	<section id="sec-resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>

		<section id="introduction-0">
<h3 title="Introduction">4.1. 序論</h3>

◎非規範的

<div class="p">
<p>
`PerformanceResourceTiming$I ~interfaceは、
`~fetch$される `http(s)＠~FETCH#http-scheme$ 資源の計時~測定を手助けする。
例えば、
次に挙げるものに利用できる：
</p>
<ul>
	<li>
`XMLHttpRequest$I ~obj `XHR$r
</li>
	<li>
`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v を伴う `link$e
］などの~HTML要素 `HTML$r
</li>
	<li>
`svg$e などの~SVG要素 `SVG11$r
</li>
	<li>
`EventSource$I
</li>
</ul>
◎
The PerformanceResourceTiming interface facilitates timing measurement of fetched http(s) resources. For example, this interface is available for XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed and link with the link type of stylesheet, SVG elements [SVG11] such as svg, and EventSource.
</div>

		</section>
		<section id="resources-included-in-the-performanceresourcetiming-interface">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源</h3>

◎非規範的

<p>
~NULL でない`~client$rqからの`要請$により`~fetch$される すべての資源
— ~HTTP~cache【あるいは~sw】から検索取得されたものも含む —
は、
`~fetching$の一部として除外されない限り，
`PerformanceResourceTiming$I ~objとして`~client$rqの`大域~obj$の`処理能~時列線$に含まれる。
~fetchにより起動されたが後で中止された資源は
（例：~network~errorなどに因り）、
その［
開始, 終了
］の計時を伴って，`処理能~時列線$に含まれる。
◎
Resource Requests fetched by a non-null client are included as PerformanceResourceTiming objects in the client's global object's Performance Timeline, unless excluded from the timeline as part of the fetching process. Resources that are retrieved from HTTP cache are included as PerformanceResourceTiming objects in the Performance Timeline. Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) are included as PerformanceResourceTiming objects in the Performance Timeline, with their start and end timing.
</p>

<div class="example">
<p>
例えば：
◎
Examples:
</p>
<ul>
	<li>
複数の~HTML `img$e 要素の `src^a 属性に，正準-形が同じになる~URL（ `the same canonical URL^en 
【すなわち，同じ資源を指す~URL】
）が利用されている場合、［
最初に資源`~fetch$を起動した `img^e 要素
］の方が［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになろう。
~UAは、
2 個目以降の `img^e 要素の~URLに対しては、
再~要請することなく，
最初に起動された方による既存の~downloadを利用すると見込まれるので。
この場合，`処理能~時列線$には、
最初に起動された `img^e 要素に対する資源`~fetch$による結果のみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element would be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
~HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、
元々の資源`~fetch$のみならず，新たな~URLへの`~fetch$も［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
~HTML `iframe$e 要素の~markupに `src^a 属性が指定されていない場合、
~UAは `about:blank^c 文書を読込むことになる。
後で~scriptから `src^a 属性が動的に変更された場合、
その新たな~URLの資源へ`~fetch$されることになる。
この場合、新たな~URLによる`~fetch$のみが［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
正準-形が同じになる~URL用に，複数の `XMLHttpRequest$I が生成された場合、
いずれの資源`~fetch$も［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになる
— 後続する資源~fetch要請には、
先行する要請による~downloadを再利用できないので。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
~page内の~HTML `iframe$e 要素に内包された文書により要請される下位資源は、
親~文書の`処理能~時列線$ではなく，内包された文書の`処理能~時列線$に含められる。
`iframe^e に対し`処理能~時列線$に含められるのは、
その `src^a 属性により要請される資源に限られる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素の~sourceが `data: URI＠~RFCx/rfc2397.html$ `RFC2397$r である場合、
その資源は，`処理能~時列線$には含められない。
`PerformanceResourceTiming$I ~entryは、
`http(s)＠~FETCH#http-scheme$ 資源~用に限り報告される。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. PerformanceResourceTiming entries are only reported for http(s) resources.
</li>
	<li>
資源`~fetch$が~network~error（ ~DNS, ~TCP, ~TLS ~errorなど）に因り中止された場合、
その~fetchは，
`PerformanceResourceTiming$I ~objとして
— ［
`startTime$m, `fetchStart$m, `duration$m, `responseEnd$m
］に限り，設定された上で —
`処理能~時列線$に含められることになる。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch will be included as a PerformanceResourceTiming object in the Performance Timeline with only the startTime, fetchStart, duration and responseEnd set.
</li>
	<li>
資源`~fetch$が事前条件
（例： 混在内容（ `mixed content^en ）, ~CORS制約, ~CSP施策, など）
に失敗したことにより中止された場合、
その資源については，`処理能~時列線$には含められないことになる。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
</ul>
</div>

		</section>
		<section id="sec-performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute `DOMString$ `initiatorType$m;
  readonly attribute `DOMString$ `deliveryType$m;
  readonly attribute `ByteString$ `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$ `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$ `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$ `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$ `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$ `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$ `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$ `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$ `finalResponseHeadersStart$m;
  readonly attribute `DOMHighResTimeStamp$ `firstInterimResponseStart$m;
  readonly attribute `DOMHighResTimeStamp$ `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$ `responseEnd$m;
  readonly attribute `unsigned long long$ `transferSize$m;
  readonly attribute `unsigned long long$ `encodedBodySize$m;
  readonly attribute `unsigned long long$ `decodedBodySize$m;
  readonly attribute `unsigned short$ `responseStatus$m;
  readonly attribute `RenderBlockingStatusType$I `renderBlockingStatus$m;
  readonly attribute `DOMString$ `contentType$m;
  readonly attribute `DOMString$ `contentEncoding$m;
  [`Default$] `object$ `toJSON$m();
};
</pre>

<p>
各 `PerformanceResourceTiming$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`起動元~種別@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString initiator type.
</li>
	<li>
`送達~種別@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString delivery type.
</li>
	<li>
`要請~URL@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString requested URL.
</li>
	<li>
`~cache~mode@pT
⇒
`文字列$
— 次のいずれか
⇒＃
空~文字列 ／
`local^l ／
`validated^l
◎
A PerformanceResourceTiming has an associated DOMString cache mode (the empty string, "local", or "validated").
</li>
	<li>
`計時~報@pT
⇒
`~fetch計時~報$
◎
A PerformanceResourceTiming has an associated fetch timing info timing info.
</li>
	<li>
`資源~情報@pT
⇒
`応答~本体~報$
◎
A PerformanceResourceTiming has an associated response body info resource info. 
</li>
	<li>
`応答~状態s@pT
⇒
`状態s$
◎
A PerformanceResourceTiming has an associated status response status.
</li>
	<li>
`具現化を阻むか@pT
⇒
`RenderBlockingStatusType$I 値
◎
A PerformanceResourceTiming has an associated RenderBlockingStatusType render-blocking status.
</li>
</ul>

<div class="algo">
<p>
`toJSON()@m
は、
`PerformanceResourceTiming$I 用の`既定の~toJSON手続き$ `WEBIDL$r を走らす。
◎
When toJSON is called, run the default toJSON steps for PerformanceResourceTiming.
</p>
</div>

<div class="algo">
<p>
`initiatorType@m
取得子~手続きは
⇒
~RET コレの`起動元~種別$pT
◎
initiatorType getter steps are to return the initiator type for this.
</p>

<div class="note">
<p>注記：
`initiatorType$m は、
次に挙げるいずれかの値を返す：
◎
Note

initiatorType returns one of the following values:
</p>
<ul>
	<li>
`navigation^l
⇒
当の要請は、
`~navi要請$である場合
◎
"navigation", if the request is a navigation request;
</li>
	<li>
`body^l
⇒
当の要請は、
`body$e 要素の［
すでに廃用にされた `background＠~HTMLobs#attr-background$a 属性
］を処理した結果である場合
◎
"body", if the request is a result of processing the body element's background attribute that's already obsolete.
</li>
	<li>
<p>
`css^l
⇒
当の要請は、
ある~CSS `url()$v 指令 `CSS-VALUES$r
— `@import url()^css や `background: url()^css など —
を処理した結果である場合
◎
"css", if the request is a result of processing a CSS url() directive such as @import url() or background: url(); [CSS-VALUES]
</p>

<p>注記：
~CSS内の `font-face$at 規則で指定された~font資源への要請は，
~CSS指令【当の規則の `src^d 記述子に指定されたそれ】を処理した結果なので、
そのような資源~用の `initiatorType$m は `css^l になる
【以下に述べる `font^l ではなく】。
◎
Note: the request for a font resource specified with @font-face in CSS is a result of processing a CSS directive. Therefore, the initiatorType for this font resource is "css".
</p>
	</li>
	<li>
<p>
`script^l
⇒
当の要請は、
`~script$
（ `古典~script$ ／ `~module~script$ ／ `Worker$I ）
を読込むもの【！読込んだ結果】である場合
</p>

<p class="trans-note">【
~module~scriptには、
~CSS~module~scriptも含まれる。
字義通り解釈するなら、
これも `css^l ではなく `script^l を返すことになる。
】</p>
◎
"script", if the request is a result of loading any script (a classic script, a module script, or a Worker).
</li>
	<li>
<p>
`font^l
⇒
当の要請は、
~fontを処理した結果である場合
— これは、
~fontが後続な資源を要請したときに起こり得る
（例：
`INCREMENTAL_FONT_TRANSFER$r が利用されたとき）。
◎
"font", if the request is the result of processing fonts.＼
This can happen when fonts request subsequent resources, e.g, when Incremental Font Transfer is used.
</p>
	</li>
	<li>
`xmlhttprequest^l
⇒
当の要請は、
`XMLHttpRequest$I を処理した結果である場合
◎
"xmlhttprequest", if the request is a result of processing an XMLHttpRequest;
</li>
	<li>
`fetch^l
⇒
当の要請は、
`fetch()$m ~methodを処理した結果である場合
◎
"fetch", if the request is the result of processing the fetch() method;
</li>
	<li>
`beacon^l
⇒
当の要請は、
`sendBeacon()$m ~method `BEACON$r を処理した結果である場合
◎
"beacon", if the request is the result of processing the sendBeacon() method; [BEACON]
</li>
	<li>
`video^l
⇒
当の要請は、
`video$e 要素の［
`poster$a ／ `src!media$a
］属性を処理した結果である場合
◎
"video", if the request is the result of processing the video element's poster or src.
</li>
	<li>
`audio^l
⇒
当の要請は、
`audio$e 要素の `src!media$a 属性を処理した結果である場合
◎
"audio", if the request is the result of processing the audio element's src.
</li>
	<li>
`track^l
⇒
当の要請は、
`track$e 要素の `src!track$a 属性を処理した結果である場合
◎
"track", if the request is the result of processing the track element's src.
</li>
	<li>
`img^l
⇒
当の要請は、
`img$e 要素の［
`src!img$a ／ `srcset$a
］属性を処理した結果である場合
◎
"img", if the request is the result of processing the img element's src or srcset.
</li>
	<li>
`image^l
⇒
当の要請は、
`image$e 要素 `SVG2$r を処理した結果である場合
◎
"image", if the request is the result of processing the image element. [SVG2]
</li>
	<li>
`input^l
⇒
当の要請は、
`input$e 要素のうち［
`type$a 属性が `image$v 状態にあるもの
］を処理した結果である場合
◎
"input", if the request is the result of processing an input element of type image.
</li>
	<li>
`ping^l
⇒
当の要請は、
`a$e 要素の `ping$a 属性を処理した結果である場合
◎
"ping", if the request is the result of processing an a element's ping. 
</li>
	<li>
`iframe^l
⇒
当の要請は、
`iframe$e の `src!iframe$a 属性を処理した結果である場合
◎
"iframe", if the request is the result of processing an iframe's src.
</li>
	<li>
`frame^l
⇒
当の要請は、
`frame$e を読込むもの【！読込んだ結果】である場合
◎
"frame", if the request is the result of loading a frame.
</li>
	<li>
`embed^l
⇒
当の要請は、
`embed$e 要素の `src!embed$a 属性を処理した結果である場合
◎
"embed", if the request is the result of processing an embed element's src.
</li>
	<li>
`link^l
⇒
当の要請は、
`link$e 要素を処理した結果である場合
◎
"link", if the request is the result of processing an link element.
</li>
	<li>
`object^l
⇒
当の要請は、
`object$e 要素を処理した結果である場合
◎
"object", if the request is the result of processing an object element.
</li>
	<li>
`early-hints^l
⇒
当の要請は、
`早期~hint＠~HTTPearlyhints$ `EARLY_HINTS$r 応答を処理した結果である場合
◎
"early-hints", if the request is the result of processing an Early hints response.
</li>
	<li>
`other^l
⇒
上に挙げた どの条件にも合致しない場合
◎
"other", if none of the above conditions match.
</li>
</ul>
</div>

<p class="note">注記：
`initiatorType^m は、［
資源~計時~entryが報告される，異なる何箇所
］かで設定される
— `~fetching$ `FETCH$r など。
◎
Note

The setting of initiatorType is done at the different places where a resource timing entry is reported, such as the fetch standard.
</p>
</div>

<div class="algo">
`deliveryType@m
取得子~手続きは
⇒
~RET コレの`送達~種別$pT
◎
deliveryType getter steps are to return the delivery type for this.
</div>

<div class="note">
<p>注記：
`deliveryType$m は、
次に挙げるいずれかの値を返す：
◎
Note

deliveryType returns one of the following values:
</p>
<ul>
	<li>
`cache^l
⇒
`~cache~mode$pT ~NEQ 空~文字列 の場合
◎
"cache", if the cache mode is not the empty string.
</li>
	<li>
空~文字列
⇒
上に挙げた どの条件にも合致しない場合
◎
the empty string "", if none of the above conditions match.
</li>
</ul>

<p>
これは、
この仕様に対する将来の更新により拡げられるものと期待される
— 例：
~preloadされた資源や~prefetchされた~navi要請を消費したことを述べるために。
◎
This is expected to be expanded by future updates to this specification, e.g. to describe consuming preloaded resources and prefetched navigation requests.
</p>
</div>

<div class="algo">
<p>
`workerStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-~sw開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The workerStart getter steps are to convert fetch timestamp for this's timing info's final service worker start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`redirectStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`~redirect開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The redirectStart getter steps are to convert fetch timestamp for this's timing info's redirect start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~redirect~fetch$を見よ。
◎
See HTTP-redirect fetch for more info.
</p>
</div>

<div class="algo">
<p>
`redirectEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`~redirect終了~時刻$fT, コレに`関連な大域~obj$ )
◎
The redirectEnd getter steps are to convert fetch timestamp for this's timing info's redirect end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~redirect~fetch$を見よ。
◎
See HTTP-redirect fetch for more info.
</p>
</div>

<div class="algo">
<p>
`fetchStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`~redirect後からの開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The fetchStart getter steps are to convert fetch timestamp for this's timing info's post-redirect start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`domainLookupStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-接続~計時~報$fTの`~domain検索~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The domainLookupStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's domain lookup start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時~報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`domainLookupEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-接続~計時~報$fTの`~domain検索~終了~時刻$cT, コレに`関連な大域~obj$ )
◎
The domainLookupEnd getter steps are to convert fetch timestamp for this's timing info's final connection timing info's domain lookup end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時~報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`connectStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-接続~計時~報$fTの`接続~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The connectStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's connection start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時~報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`connectEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-接続~計時~報$fTの`接続~終了~時刻$cT, コレに`関連な大域~obj$ )
◎
The connectEnd getter steps are to convert fetch timestamp for this's timing info's final connection timing info's connection end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時~報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`secureConnectionStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-接続~計時~報$fTの`~secure接続~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The secureConnectionStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's secure connection start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時~報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`nextHopProtocol@m
取得子~手続きは
⇒
~RET `同型に復号する$( コレの`計時~報$pTの`最終-接続~計時~報$fTの`折衝した~ALPN~protocol~ID$cT )
◎
The nextHopProtocol getter steps are to isomorphic decode this's timing info's final connection timing info's ALPN negotiated protocol.＼
</p>

<p class="note">
更なる情報は、
`接続~計時~報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<p class="note">注記：
`221$issue にて，
`nextHopProtocol^m 用の~supportを除去するよう示唆されている
— それは、
利用者の~network環境設定についての詳細を露呈し得るので。
◎
Note

Issue 221 suggests to remove support for nextHopProtocol, as it can reveal details about the user's network configuration.
</p>

<div class="algo">
<p>
`requestStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-~network要請~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The requestStart getter steps are to convert fetch timestamp for this's timing info's final network-request start time and the relevant global object for this.＼
</p>

<p class="note">注記：
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`firstInterimResponseStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最初の非最終-~network応答~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The firstInterimResponseStart getter steps are to convert fetch timestamp for this's timing info's first interim network-response start time and the relevant global object for this.＼
</p>

<p class="note">注記：
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`finalResponseHeadersStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`最終-~network応答~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The finalResponseHeadersStart getter steps are to convert fetch timestamp for this's timing info's final network-response start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`responseStart@m
取得子~手続きは：
</p>
<ol>
	<li>
%最初の非最終-応答~開始 ~LET コレの `firstInterimResponseStart$m
</li>
	<li>
~IF［
%最初の非最終-応答~開始 ~NEQ 0
］
⇒
~RET %最初の非最終-応答~開始
</li>
	<li>
~RET コレの `finalResponseHeadersStart$m
</li>
</ol>
◎
The responseStart getter steps are to return this's firstInterimResponseStart if it is not 0; Otherwise this's finalResponseHeadersStart.
</div>

<div class="algo">
<p>
`responseEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時~報$pTの`終了~時刻$fT, コレに`関連な大域~obj$ )
◎
The responseEnd getter steps are to convert fetch timestamp for this's timing info's end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~fetch$を見よ。
◎
See fetch for more info.
</p>
</div>

<div class="algo">
<p>
`encodedBodySize@m
取得子~手続きは
⇒
~RET コレの`資源~情報$pTの`符号化された~size$fT
◎
The encodedBodySize getter steps are to return this's resource info's encoded size.
</p>
</div>

<div class="algo">
<p>
`decodedBodySize@m
取得子~手続きは
⇒
~RET コレの`資源~情報$pTの`復号した~size$fT
◎
The decodedBodySize getter steps are to return this's resource info's decoded size.
</p>
</div>

<div class="algo">
<p>
`transferSize@m
取得子~手続きは：
◎
The transferSize getter steps are:
</p>
<ol>
	<li>
<p>
~RET コレの`~cache~mode$pT に応じて
⇒＃
`local^l ならば 0 ／
`validated^l ならば 300 ／
~ELSE_ コレの`資源~情報$pT【！response body info】の`符号化された~size$fT ~PLUS 300 †
◎
If this's cache mode is "local", then return 0.
◎
If this's cache mode is "validated", then return 300.
◎
Return this's response body info's encoded size plus 300.
</p>

<p class="note">注記†：
~sizeに加算される定数 300 は、
~HTTP~messageの`~header節$の総~byte~sizeを置換するものであり，
ある種の~cookieの有無が公開されないようにするためである。
`課題 #238＠https://github.com/w3c/resource-timing/issues/238$
を見よ。
◎
Note

The constant number added to transferSize replaces exposing the total byte size of the HTTP headers, as that may expose the presence of certain cookies. See this issue.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`responseStatus@m
取得子~手続きは
⇒
~RET コレの`応答~状態s$pT
◎
The responseStatus getter steps are to return this's response status.
</p>

<p class="note">注記：
`responseStatus$m は`~fetch$内で決定される。
それは、
`要請$が非同一-生成元で［
`~mode$rq ~EQ `no-cors^l【！~FETCH#dom-requestmode-no-cors】
］の場合には 0 になる
— 対する応答は、
`不透明な絞込み応答$になるので。
◎
Note

responseStatus is determined in Fetch. For a cross-origin no-cors request it would be 0 because the response would be an opaque filtered response.
</p>
</div>

<div class="algo">
<p>
`contentType@m
取得子~手続きは
⇒
~RET コレの`計時~報$pTの`内容~型$fT
◎
The contentType getter steps are to return this's resource info's content type. 
</p>
</div>

<div class="algo">
<p>
`contentEncoding@m
取得子~手続きは
⇒
~RET コレの`資源~情報$pTの`内容~符号化法$fT
◎
The contentEncoding getter steps are to return this's resource info 's content encoding.
</p>
</div>

<div class="algo">
<p>
`renderBlockingStatus@m
取得子~手続きは
⇒
~RET コレの`計時~報$pTの`具現化を阻んでいるか$fTに応じて
⇒＃
~T ならば `blocking$l ／
~F ならば `non-blocking$l
◎
The renderBlockingStatus getter steps are to return blocking if this's timing info's render-blocking is true; otherwise non-blocking.
</p>
</div>

<p class="note">注記：
`PerformanceResourceTiming$I を実装する~UAは、
その~supportを開発者が検出できるよう，
`supportedEntryTypes$m 内に `resource^l を含める必要がある。
◎
Note

A user agent implementing PerformanceResourceTiming would need to include "resource" in supportedEntryTypes. This allows developers to detect support for Resource Timing.
</p>

			<section id="sec-render-blocking-status-types">
<h4 title="RenderBlockingStatusType enum ">4.3.1. `RenderBlockingStatusType^I 列挙型</h4>

<pre class="idl">
enum `RenderBlockingStatusType@I {
    `blocking$l,
    `non-blocking$l
};
</pre>

<p>
値は、
次に従って定義される：
◎
The values are defined as follows:
</p>

<dl>
	<dt>`blocking@l</dt>
	<dd>
当の資源は、
具現化を阻むものになり得る。
◎
The resource can potentially block rendering.
</dd>

	<dt>
`non-blocking@l
</dt>
	<dd>
当の資源は、
具現化を阻まない。
◎
The resource will not block rendering.
</dd>
</dl>

			</section>
		</section>
		<section id="sec-extensions-performance-interface">
<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>

<p>
~UAは、
`PerformanceResourceTiming$I ~objとして`処理能~時列線$ `PERFORMANCE-TIMELINE-2$r に含み得る資源の個数を制限してもヨイ。
この節では、
`Performance$I ~interfaceを拡張して，
格納される `PerformanceResourceTiming$I ~objの個数について制御できるようにする。
◎
The user agent MAY choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. This section extends the Performance interface to allow controls over the number of PerformanceResourceTiming objects stored.
</p>

<p>
推奨される `PerformanceResourceTiming$I ~objの最小~個数は 250 である
— ~UAはこれを変更してもヨイが。
この上限は、
`setResourceTimingBufferSize()$m を~callすることにより，変更を要請できる。
◎
The recommended minimum number of PerformanceResourceTiming objects is 250, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>

<p>
各`~JS環境＠~WEBIDLjs#js-environment$【！ECMAScript global environment】は、
次に挙げるものを持つ：
◎
Each ECMAScript global environment has:
</p>

<dl class="def-list">
	<dt>
`資源~計時~bufferの~size上限@
◎
A resource timing buffer size limit＼
</dt>
	<dd>
初期~時は 250 以上【が推奨される】。
◎
which should initially be 250 or greater.
<dd>

	<dt>
`資源~計時~bufferの現-~size@
◎
A resource timing buffer current size＼
</dt>
	<dd>
0 以上の整数
— 初期~時は 0 とする。
◎
which is initially 0.
</dd>

	<dt>
`資源~計時~buffer満杯~eventは処理待ちか@
◎
A resource timing buffer full event pending flag＼
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
◎
which is initially false.
</dd>

	<dt>
`資源~計時~副-~bufferの現-~size@
◎
A resource timing secondary buffer current size which is initially 0.
</dt>
	<dd class="trans-note">【
`資源~計時~副-~buffer$を成す~entryの個数を表すが、
この訳では，この用語は利用しない。
代わりに，~algoの記述にて等価に表現する
（`副-~buffer内の~entryを移動する$における，真偽値 %移動したか ）。
そうした方が簡潔かつ簡明に記述できるので。
】</dd>

	<dt>
`資源~計時~副-~buffer@
◎
A resource timing secondary buffer＼
</dt>
	<dd>
`PerformanceResourceTiming$I ~objたちが成す~list
— 初期~時は空とする。
◎
to store PerformanceResourceTiming objects that is initially empty.
</dd>
</dl>

<pre class="idl">
partial interface `Performance$I {
  `undefined$ `clearResourceTimings()$m;
  `undefined$ `setResourceTimingBufferSize$m(`unsigned long$ %maxSize);

  attribute `EventHandler$I `onresourcetimingbufferfull$m;
};
</pre>

<p>
`Performance$I ~interfaceは
`HR-TIME$r にて定義される。
◎
The Performance interface is defined in [HR-TIME].
</p>

<div class="algo">
<p>
`clearResourceTimings()@m
~method手続きは：
◎
The method clearResourceTimings runs the following steps:
</p>
<ol>
	<li>
`処理能~entry~buffer$から 次を満たす~entryをすべて除去する
⇒
`PerformanceResourceTiming$I ~objである
◎
Remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
	<li>
`資源~計時~bufferの現-~size$ ~SET 0
◎
Set resource timing buffer current size to 0.
</li>
</ol>
</div>

<div class="algo">
<p>
`setResourceTimingBufferSize(maxSize)@m
~method手続きは
⇒
`資源~計時~bufferの~size上限$ ~SET %maxSize
◎
The setResourceTimingBufferSize method runs the following steps:
• Set resource timing buffer size limit to the maxSize parameter.＼
</p>

<p class="note">注記：
［
%maxSize ~LT `資源~計時~bufferの現-~size$
］であっても，`処理能~entry~buffer$から `PerformanceResourceTiming$I ~objは除去されない。
◎
If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</p>
</div>

<p>
`onresourcetimingbufferfull@m
は、
`resourcetimingbufferfull@et
~event用の~event~handlerである。
【`~buffer満杯~eventを発火する$を見よ。】
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event described below.
</p>

<div class="algo">
<p>
`資源~計時~entryを追加でき@
るとは、
次が満たされることをいう
⇒
`資源~計時~bufferの現-~size$ ~LT `資源~計時~bufferの~size上限$
◎
To check if can add resource timing entry, run the following steps:
• If resource timing buffer current size is smaller than resource timing buffer size limit, return true.
• Return false.
</p>
</div>

<div class="algo">
<p>
`処理能~entry~bufferに~entryを追加する@
~algoは、
所与の
( `処理能~entry~buffer$ %~buffer, `PerformanceResourceTiming$I ~obj %新たな~entry )
に対し：
◎
To add a PerformanceResourceTiming entry new entry into the performance entry buffer, run the following steps:
</p>
<ol>
	<li>
<p>
~IF［
`資源~計時~entryを追加でき$る
］~AND［
`資源~計時~buffer満杯~eventは処理待ちか$ ~EQ ~F
］：
◎
If can add resource timing entry returns true and resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
%~buffer に %新たな~entry を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~bufferの現-~size$ ~INCBY 1
◎
Increase resource timing buffer current size by 1.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`資源~計時~buffer満杯~eventは処理待ちか$ ~EQ ~F
］：
◎
If resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
`資源~計時~buffer満杯~eventは処理待ちか$ ~SET ~T
◎
Set resource timing buffer full event pending flag to true.
</li>
			<li>
<p>
`~taskを~queueする$( `処理能~時列線~task~source$, 次の手続き )
</p>
<div class="algo">
手続きは
⇒
`~buffer満杯~eventを発火する$()
</div>
◎
Queue a task on the performance timeline task source to run fire a buffer full event.
</li>
		</ol>
	</li>
	<li>
`資源~計時~副-~buffer$に %新たな~entry を付加する
◎
Add new entry to the resource timing secondary buffer.
◎
Increase resource timing secondary buffer current size by 1.
</li>
</ol>
</div>

<div class="algo">
<p>
`副-~buffer内の~entryを移動する@
~algoは：
◎
To copy secondary buffer, run the following steps:
</p>
<ol>
	<li>
%移動したか ~LET ~F
◎
↓↓</li>
	<li>
<p>
~WHILE［
`資源~計時~副-~buffer$は空でない
］~AND［
`資源~計時~entryを追加でき$る
］：
◎
While resource timing secondary buffer is not empty and can add resource timing entry returns true, run the following substeps:
</p>
		<ol>
			<li>
%~entry ~LET `資源~計時~副-~buffer$内の最初の（最も旧い） `PerformanceResourceTiming$I ~obj
◎
Let entry be the oldest PerformanceResourceTiming in resource timing secondary buffer.
</li>
			<li>
`処理能~entry~buffer$の末尾に %~entry を追加する
◎
Add entry to the end of performance entry buffer.
</li>
			<li>
`資源~計時~bufferの現-~size$ ~INCBY 1
◎
Increment resource timing buffer current size by 1.
</li>
			<li>
`資源~計時~副-~buffer$から %~entry を除去する
◎
Remove entry from resource timing secondary buffer.
</li>
			<li>
%移動したか ~SET ~T
◎
Decrement resource timing secondary buffer current size by 1.
</li>
		</ol>
	</li>
	<li>
~RET %移動したか
</li>
</ol>
</div>

<div class="algo">
<p>
`~buffer満杯~eventを発火する@
~algoは：
◎
To fire a buffer full event, run the following steps:
</p>
<ol>
	<li>
<p>
~WHILE［
`資源~計時~副-~buffer$は空でない
］：
◎
While resource timing secondary buffer is not empty, run the following substeps:
</p>
		<ol>
			<li>
~IF［
`資源~計時~entryを追加でき$ない
］
⇒
`~eventを発火する$( `Performance$I ~obj, `resourcetimingbufferfull$et )
◎
Let number of excess entries before be resource timing secondary buffer current size.
◎
If can add resource timing entry returns false, then fire an event named resourcetimingbufferfull at the Performance object.
</li>
			<li>
%移動したか ~LET `副-~buffer内の~entryを移動する$()
◎
Run copy secondary buffer.
</li>
			<li>
~IF［
%移動したか ~EQ ~F
］
⇒＃
`資源~計時~副-~buffer$からすべての~entryを除去する†；
~BREAK
◎
Let number of excess entries after be resource timing secondary buffer current size.
◎
If number of excess entries before is lower than or equals number of excess entries after, then remove all entries from resource timing secondary buffer, set resource timing secondary buffer current size to 0, and abort these steps.
</li>
		</ol>
	</li>
	<li>
`資源~計時~buffer満杯~eventは処理待ちか$ ~SET ~F
◎
Set resource timing buffer full event pending flag to false.
</li>
</ol>

<p class="note">注記：†
移動できなかった~entryは、
~bufferから落とされる。
開発者は、
`resourcetimingbufferfull$et ~event用の~event~handler内で，
次のいずれかをしておくべきである
⇒＃
`clearResourceTimings()$m を~callする／
`setResourceTimingBufferSize()$m を~callして，~bufferが足りるよう拡張する
◎
Note

This means that if the resourcetimingbufferfull event handler does not add more room in the buffer than it adds resources to it, excess entries will be dropped from the buffer. Developers should make sure that resourcetimingbufferfull event handlers call clearResourceTimings or extend the buffer sufficiently (by calling setResourceTimingBufferSize).
</p>
</div>

		</section>
		<section id="sec-cross-origin-resources">
<h3 title="Cross-origin Resources">4.5. 非同一-生成元~資源</h3>

<div class="note">
<p>注記：
`FETCH$r にて詳細されるとおり、
非同一-生成元~資源への要請は，
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる。
非同一-生成元~資源に対し`~TAO検査$に失敗した場合、
`当の~entryは不透明になる＠~FETCH#create-an-opaque-timing-info$。
そのような~entryのほとんどの属性は、
他では公開されない非同一-生成元~dataが漏洩するのを防止するため，~maskされる
— すなわち，不透明な~entryの属性のうち：
◎
Note

As detailed in Fetch, requests for cross-origin resources are included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a cross-origin resource, the entry will be an opaque entry. Such entries have most of their attributes masked in order to prevent leaking cross-origin data that isn't otherwise exposed. So, for an opaque entry,＼
</p>
<ul>
	<li>
次に挙げるものは、
0 に設定される
⇒＃
`redirectStart$m,
`redirectEnd$m,
`workerStart$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`firstInterimResponseStart$m,
`finalResponseHeadersStart$m,
`responseStart$m,
`secureConnectionStart$m,
`transferSize$m,
`encodedBodySize$m,
`decodedBodySize$m
◎
the following attributes will be set to zero: redirectStart, redirectEnd, workerStart, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, firstInterimResponseStart, finalResponseHeadersStart, responseStart, secureConnectionStart, transferSize, encodedBodySize, and decodedBodySize.＼
</li>
	<li>
`nextHopProtocol$m は、
空~文字列に設定される。
◎
Further, the nextHopProtocol attribute will be set to the empty string.
</li>
</ul>
</div>

<p>
~server側~appは、
`Timing-Allow-Origin$h ~HTTP応答~header返してもヨイ
— 上に挙げた［
非同一-生成元に対する制約に因り，値が 0 にされる属性
］すべてを［
~header内に指定された文書~生成元（たち）に公開する
］ことを~UAに許容するためとして。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to those cross-origin restrictions.
</p>

			<section id="sec-timing-allow-origin">
<h4 title="Timing-Allow-Origin Response Header">4.5.1. `Timing-Allow-Origin^h 応答~header</h4>

<p>
`Timing-Allow-Origin@h
~HTTP応答~headerを利用すれば、［［
非同一-生成元に対する制約に因り 0 にされていた属性
］の値を見ることが許容され得る生成元（たち）
］を指示する施策を通信できる。
この~headerの値は、
次の~ABNF `RFC5234$r と`その~list拡張＠~HTTPinfra#abnf.extension$
`RFC9110$r を利用して表現される：
◎
The Timing-Allow-Origin HTTP response header field can be used to communicate a policy indicating origin(s) that may be allowed to see values of attributes that would have been zero due to the cross-origin restrictions. The header's value is represented by the following ABNF [RFC5234] (using List Extension, [RFC9110]):
</p>

<pre class="bnf">
Timing-Allow-Origin
	= 1#( `origin-or-null$P / `wildcard$P )
</pre>

<p>
送信者は、
複数個の `Timing-Allow-Origin$h ~headerを生成してもヨイ。
受信者は、
複数個の `Timing-Allow-Origin$h ~headerに対しては，
それらの~headerの値を順に~commaで分離して連結して 1 個の~headerに結合してもヨイ。
◎
The sender MAY generate multiple Timing-Allow-Origin header fields. The recipient MAY combine multiple Timing-Allow-Origin header fields by appending each subsequent field value to the combined field value in order, separated by a comma.
</p>

<p>
~UAは，
`Timing-Allow-Origin$h ~headerを受信した【！with HTTP response header fields】場合でも、
非同一-生成元に対する制約を施行して，［
`transferSize$m, `encodedBodySize$m, `decodedBodySize$m
］属性を 0 に設定してもヨイ
— そうする場合、
`deliveryType$m も空~文字列に設定してヨイ。
◎
The user agent MAY still enforce cross-origin restrictions and set transferSize, encodedBodySize, and decodedBodySize attributes to zero, even with Timing-Allow-Origin HTTP response header fields. If it does, it MAY also set deliveryType to "".
</p>

<p>
`Timing-Allow-Origin$h
~headerは、
`~TAO検査$にて処理され，各 属性は それに則って算出される。
◎
The Timing-Allow-Origin headers are processed in FETCH to compute the attributes accordingly.
</p>

<p class="note">注記：
`Timing-Allow-Origin$h ~headerは、
~cacheされた応答の一部として到着することもある。
~cache再検証の事例では、
`~HTTP~cache法に則って＠~HTTPcache#freshening.responses$
【！~RFCx/rfc7234#section-4.3.4】，~headerの値は［
再検証~応答，そこに無ければ~cacheされた元の資源
］から来ることもある。
◎
Note

The Timing-Allow-Origin header may arrive as part of a cached response. In case of cache revalidation, according to RFC 7234, the header's value may come from the revalidation response, or if not present there, from the original cached resource.
</p>

<p class="note">注記：
`222$issue, `223$issue にて，
`Timing-Allow-Origin$h から `wildcard^P の~supportを除去するよう示唆されている
— それの利用を制約するため。
◎
Note

Issues 222 and 223 suggest to remove wildcard support from Timing-Allow-Origin in order to restrict its use.
</p>

			</section>
			<section id="sec-iana-considerations">
<h4 title="IANA Considerations">4.5.2. IANA 考慮点</h4>

<p>
この節では、
`Timing-Allow-Origin$h を`暫定的な~message~header＠~HTTPinfra#fields.registry$【！~RFCx/rfc3864.html#section-4.2.2】として登録する。
◎
This section registers Timing-Allow-Origin as a Provisional Message Header.
</p>

<ul>
	<li>
~header~field名
⇒
`Timing-Allow-Origin^h
◎
Header field name:
• Timing-Allow-Origin
</li>
	<li>
適用-可能な~protocol
⇒
http
◎
Applicable protocol:
• http
</li>
	<li>
位置付け
⇒
暫定的
◎
Status:
• provisional
</li>
	<li>
著作者／変更~制御者
⇒
`W3C＠https://www.w3.org/$
◎
Author/Change controller:
• W3C
</li>
	<li>
仕様~文書
⇒
<a href="#sec-timing-allow-origin">§ `Timing-Allow-Origin^h 応答~header</a>
◎
Specification document:
• § 4.5.1 Timing-Allow-Origin Response Header
</li>
</ul>

			</section>
		</section>
		<section id="attribute-descriptions">
<h3 title="Resource Timing Attributes">4.6. 資源~計時~属性</h3>

◎非規範的

<p>
`PerformanceResourceTiming$I ~interfaceに定義される各種 計時~属性を次の図式に示す。
括弧内の属性は、
資源が非同一-生成元から`~fetch$されているときは可用でない。
~UAは、
規範的でない時区間を許容するために，
各 計時の合間に内部~処理を行ってもヨイ。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis may not be available when fetching cross-origin resources. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure><figcaption>
各種 計時~属性を示す図式（時間は下に向かって進行する）。
括弧内の属性は、
当の資源が`~TAO検査$に失敗した場合は，可用でなくされ得ることを指示する。
◎
Figure 1 This figure illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis indicate that they may not be available if the resource fails the timing allow check algorithm.
</figcaption>

<div style="font-size: smaller;">
<div id="_time-table">
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← `startTime$m ／ ( `redirectStart$m )</x-tt-attr>
~redirect
<x-tt-attr style="bottom:-0.5em">← ( `redirectEnd$m )</x-tt-attr>
	</x-tt-box>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `workerStart$m )</x-tt-attr>
~sw初期化
	</x-tt-box>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `fetchStart$m )</x-tt-attr>
~sw~fetch~event
	</x-tt-box>
	<x-tt-box>
~HTTP~cache
	</x-tt-box>
	<x-tt-delay>⁝</x-tt-delay>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `domainLookupStart$m )</x-tt-attr>
~DNS
<x-tt-attr style="bottom:-0.5em">← ( `domainLookupEnd$m )</x-tt-attr>
	</x-tt-box>
	<x-tt-delay>⁝</x-tt-delay>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `connectStart$m )</x-tt-attr>
~TCP†
	</x-tt-box>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `secureConnectionStart$m )</x-tt-attr>
~TLS†
<x-tt-attr style="bottom:-0.5em">← ( `connectEnd$m )</x-tt-attr>
	</x-tt-box>
	<x-tt-delay>⁝</x-tt-delay>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `requestStart$m ††)</x-tt-attr>
要請
	</x-tt-box>
	<x-tt-box style="border-style:dashed">
<x-tt-attr style="top:-0.5em">← ( `firstInterimResponseStart$m )( `responseStart$m †††)</x-tt-attr>
早期~hint（ `103$st ）
	</x-tt-box>
	<x-tt-box>
<x-tt-attr style="top:-0.5em">← ( `finalResponseHeadersStart$m )( `responseStart$m †††)</x-tt-attr>
応答
<x-tt-attr style="bottom:-0.5em">← `responseEnd$m</x-tt-attr>
	</x-tt-box>
</div>

<ul>
	<li>†
~QUICの場合、
それが~TCPと~TLSに取って代わる
— その場合の `secureConnectionStart$m は、
~QUICの開始-時になる。
</li>
	<li>††
`requestStart$m は `connectEnd$m より前に生じることもある
（例： `TCP fast open^en ）
</li>
	<li>†††
`responseStart$m は［
`firstInterimResponseStart$m は 0 でないならば それ／
他の場合は `finalResponseHeadersStart$m
］に等しくなる。
</li>
	<li>⁝
［
~DNS,
［
~TCP／~QUIC
］,
要請
］相の前には、
~client側に遅延が生じ得る
（例：接続や伝送途上にある要請に対する制限【個数の上限？】に因り）。
</li>
</ul>

◎
Resource Timing attributes
</div>
【！ timestamp-diagram.svg 】

<p class="trans-note">【
この訳では、
原文の図式（ ~SVG ）を~HTMLと~CSSによる等価な図式に差し替えている。
】</p>
</figure>

		</section>
		<section id="marking-resource-timing">
<h3 title="Creating a resource timing entry">4.7. 資源~計時~entryの作成-法</h3>

<div class="algo">
<p>
`資源~計時を~markする@
~algoは、
所与の
⇒＃
`~fetch計時~報$ %計時~報,
`文字列$ %要請された~URL,
`文字列$ %起動元~種別,
`大域~obj$enV %大域~obj,
`文字列$ %~cache~mode,
`応答~本体~報$ %本体~報,
`状態s$ %応答~状態s,
文字列 %送達~種別 ~DF 空~文字列
◎終
に対し：
◎
To mark resource timing given a fetch timing info timingInfo, a DOMString requestedURL, a DOMString initiatorType a global object global, a string cacheMode, a response body info bodyInfo, a status responseStatus, and an optional string deliveryType (by default, the empty string), perform the following steps:
</p>
<ol>
	<li>
%~entry ~LET %大域~obj の`~realm$gLに属する新たな `PerformanceResourceTiming$I ~obj
◎
Create a PerformanceResourceTiming object entry in global's realm.
</li>
	<li>
`資源~計時~entryを設定しておく$( ↓ )
⇒＃
%~entry,
%起動元~種別,
%要請された~URL,
%計時~報,
%~cache~mode,
%本体~報,
%応答~状態s,
%送達~種別
◎
Setup the resource timing entry for entry, given initiatorType, requestedURL, timingInfo, cacheMode, bodyInfo, responseStatus, and deliveryType. 
 and responseStatus.
</li>
	<li id="dfn-step-final-queue">
`処理能~entryを~queueする$( %~entry )
◎
Queue entry.
</li>
	<li>
`処理能~entry~bufferに~entryを追加する$( %~entry, %大域~obj 
【の`処理能~entry~buffer~map$[ `resource^l ] 】
の`処理能~entry~buffer$ )
◎
Add entry to global's performance entry buffer.
</li>
</ol>
</div>

<div class="algo">
<p>
`資源~計時~entryを設定しておく@
~algoは、
所与の
⇒＃
`PerformanceResourceTiming$I %~entry,
`文字列$ %起動元~種別,
`文字列$ %要請された~URL,
`~fetch計時~報$ %計時~報,
`文字列$ %~cache~mode,
`応答~本体~報$ %本体~報,
`状態s$ %応答~状態s,
文字列 %送達~種別 ~DF 空~文字列
◎終
に対し：
◎
To setup the resource timing entry for PerformanceResourceTiming entry given DOMString initiatorType, DOMString requestedURL, fetch timing info timingInfo, a DOMString cacheMode, a response body info bodyInfo, a status responseStatus, and an optional DOMString deliveryType (by default, the empty string), perform the following steps: 
</p>
<ol>
	<li>
~Assert：
%~cache~mode ~IN { 空~文字列, `local^l, `validated^l }
◎
Assert that cacheMode is the empty string, "local", or "validated".
</li>
	<li>
%大域~obj ~LET %~entry に`関連な大域~obj$
◎
Let global be entry's relevant global object.
</li>
	<li>
%~entry を`初期化する$PE( ↓ )
⇒＃
`~fetch時刻印を変換する$( %計時~報 の`開始~時刻$fT, %大域~obj ),
`resource^l,
%要請された~URL,
`~fetch時刻印を変換する$( %計時~報 の`終了~時刻$fT, %大域~obj )
◎
Initialize entry given the result of converting timingInfo's start time given global, "resource", requestedURL, and the result of converting timingInfo's end time given global.
</li>
	<li>
~IF［
%送達~種別 ~EQ 空~文字列
］~AND［
%~cache~mode ~NEQ 空~文字列
］
⇒
%送達~種別 ~SET `cache^l
◎
↓</li>
	<li>
%~entry の
⇒＃
`起動元~種別$pT ~SET %起動元~種別,
`要請~URL$pT ~SET %要請された~URL,
`計時~報$pT ~SET %計時~報,
`資源~情報$pT【！response body info】 ~SET %本体~報,
`~cache~mode$pT ~SET %~cache~mode,
`応答~状態s$pT ~SET %応答~状態s,
`送達~種別$pT ~SET %送達~種別
◎
Set entry's initiator type to initiatorType.
◎
Set entry's requested URL to requestedURL.
◎
Set entry's timing info to timingInfo.
◎
Set entry's response body info to bodyInfo.
◎
Set entry's cache mode to cacheMode.
◎
Set entry's response status to responseStatus.
◎
If deliveryType is the empty string and cacheMode is not, then set deliveryType to "cache".
◎
Set entry's delivery type to deliveryType.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetch時刻印を変換する@
~algoは、
所与の
( `DOMHighResTimeStamp$I %時刻印, `大域~obj$enV %大域~obj )
に対し
⇒
~RET ［
%時刻印 ~EQ 0 ならば 0 ／
~ELSE_ 次の結果
］
⇒
`相対的な粗い高分解能~時刻$( %時刻印, %大域~obj )
◎
To convert fetch timestamp given DOMHighResTimeStamp ts and global object global, do the following:
• If ts is zero, return zero.
• Otherwise, return the relative high resolution coarse time given ts and global.
</p>
</div>

		</section>
		<section id="sec-security">
<h3 title="Security Considerations">4.8. ~securityの考慮点</h3>

◎非規範的

<p>
`PerformanceResourceTiming$I ~interfaceは、
資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、
既定では`同一-生成元$ 施策が施行される。
その結果，一部の属性は、
`~HTTP~fetch$にて述べられるとおり，
0 に設定される。
資源を供する側は、［
`Timing-Allow-Origin$h ~HTTP応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定する
］ことにより，資源~用のすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in HTTP fetch. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

		</section>
		<section id="sec-privacy">
<h3 title="Privacy Considerations">4.9. ~privacyの考慮点</h3>

◎非規範的

<p>
悪意的な~web~siteは、
第三者-主体~web~site内の資源に対する~cache［
~hit／~miss
］の時機を測定することにより，
利用者が第三者-主体~siteを訪問したかどうかを決定し得る
— そのような~privacyの懸念は、
統計的~指紋収集（ `statistical fingerprinting^en ）と称される。
`PerformanceResourceTiming$I ~interfaceは，
文書~内の資源の計時~情報を供するが、
すでに，資源に対する `load^et ~eventにより
— 制限された流儀ではあるが —
時機を測定して~cache［
~hit／~miss
］を決定できることに加え、
`~HTTP~fetch$における非同一-生成元に対する制約により，
追加的な情報の漏洩eは防止される。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the load event on resources can already measure timing to determine cache hits and misses in a limited fashion, and the cross-origin restrictions in HTTP Fetch prevent the leakage of any additional information.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に貢献された次の方々に謝意を：
</p>

<p lang="en">
Thanks to

Anne Van Kesteren,
Annie Sullivan,
Arvind Jain,
Boris Zbarsky,
Darin Fisher,
Jason Weber,
Jonas Sicking,
James Simonsen,
Karen Anderson,
Kyle Scholz,
Nic Jansma,
Philippe Le Hegaret,
Sigbjørn Vik,
Steve Souders,
Todd Reifsteck,
Tony Gentilcore,
William Chan,
and Alex Christensen

for their contributions to this work.
</p>

	</section>
</main></div>
