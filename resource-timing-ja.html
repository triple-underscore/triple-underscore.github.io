<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing Level 2 — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
#_time-table {
	background: #eef1fc;
	padding: 0.5em;
	font-size: smaller;
}
#_time-table > div {
	border: thin solid gray;
	position: relative;
	padding: 0.5em;
	height: 3em;
	width: 10em;
	margin: 1em 0;
}
#_time-table > div > div {
	position: absolute;
	left: 11.5em;
	min-width: 20em;
	white-space: nowrap;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2020-01-23
trans_update:2020-01-26
source_checked:191128
page_state_key:TIMING
original_url:https://w3c.github.io/resource-timing/
	abbr_url:RESOURCE-TIMING
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
copyright:2020,permissive
trans_1st_pub:2013-01-23


●●class_map
h:header
e:element
a:attr
st:status
et:event-type
P:production
v:value
css:css
hm:method

●●tag_map
I:code
m:code
c:code
h:code
e:code
a:code
et:code
st:code
P:code
css:code
v:code
hm:code
i:i

●●original_id_map

dom-performanceresourcetiming-requestend:dfn-requestend

●●mdn_urls
dfn-timing-allow-origin:HTTP/Headers/Timing-Allow-Origin

dom-performanceresourcetiming:API/PerformanceResourceTiming
dom-performance-clearresourcetimings:API/Performance/clearResourceTimings
dom-performance-setresourcetimingbuffersize:API/Performance/setResourceTimingBufferSize
dom-performance-onresourcetimingbufferfull:API/Performance/onresourcetimingbufferfull
dom-performanceresourcetiming-connectend:API/PerformanceResourceTiming/connectEnd
dom-performanceresourcetiming-connectstart:API/PerformanceResourceTiming/connectStart
dom-performanceresourcetiming-decodedbodysize:API/PerformanceResourceTiming/decodedBodySize
dom-performanceresourcetiming-domainlookupend:API/PerformanceResourceTiming/domainLookupEnd
dom-performanceresourcetiming-domainlookupstart:API/PerformanceResourceTiming/domainLookupStart
dom-performanceresourcetiming-encodedbodysize:API/PerformanceResourceTiming/encodedBodySize
dom-performanceresourcetiming-fetchstart:API/PerformanceResourceTiming/fetchStart
dom-performanceresourcetiming-initiatortype:API/PerformanceResourceTiming/initiatorType
dom-performanceresourcetiming-nexthopprotocol:API/PerformanceResourceTiming/nextHopProtocol
dom-performanceresourcetiming-redirectend:API/PerformanceResourceTiming/redirectEnd
dom-performanceresourcetiming-redirectstart:API/PerformanceResourceTiming/redirectStart
dom-performanceresourcetiming-requestend:API/PerformanceResourceTiming/requestEnd
dom-performanceresourcetiming-requeststart:API/PerformanceResourceTiming/requestStart
dom-performanceresourcetiming-responseend:API/PerformanceResourceTiming/responseEnd
dom-performanceresourcetiming-responsestart:API/PerformanceResourceTiming/responseStart
dom-performanceresourcetiming-secureconnectionstart:API/PerformanceResourceTiming/secureConnectionStart
dom-performanceresourcetiming-tojson:API/PerformanceResourceTiming/toJSON
dom-performanceresourcetiming-transfersize:API/PerformanceResourceTiming/transferSize
dom-performanceresourcetiming-workerstart:API/PerformanceResourceTiming/workerStart

dfn-resourcetimingbufferfull:API/Performance/resourcetimingbufferfull_event

●●link_map

	●IDL
Exposed:~WEBIDL#Exposed
Default:~WEBIDL#Default

DOMString:~WEBIDL#idl-DOMString
object:~WEBIDL#idl-object
	unsigned long long:~WEBIDL#idl-unsigned-long-long
	unsigned long:~WEBIDL#idl-unsigned-long

I.PerformanceResourceTiming:#dom-performanceresourcetiming
I.XMLHttpRequest:~XHR#xmlhttprequest
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	~TR/hr-time-2/#domhighrestimestamp
I.Performance:~HRTIME#dfn-performance
I.PerformanceEntry:~TIMELINE#the-performanceentry-interface
I.PerformanceObserver:~TIMELINE#the-performanceobserver-interface

I.EventHandler:~WAPI#eventhandler
	I.Document

m.toJSON:#dom-performanceresourcetiming-tojson
m.initiatorType:#dom-performanceresourcetiming-initiatortype
m.nextHopProtocol:#dom-performanceresourcetiming-nexthopprotocol
m.workerStart:#dom-performanceresourcetiming-workerstart
m.redirectStart:#dom-performanceresourcetiming-redirectstart
m.redirectEnd:#dom-performanceresourcetiming-redirectend
m.fetchStart:#dom-performanceresourcetiming-fetchstart
m.domainLookupStart:#dom-performanceresourcetiming-domainlookupstart
m.domainLookupEnd:#dom-performanceresourcetiming-domainlookupend
m.connectStart:#dom-performanceresourcetiming-connectstart
m.connectEnd:#dom-performanceresourcetiming-connectend
m.secureConnectionStart:#dom-performanceresourcetiming-secureconnectionstart
m.requestStart:#dom-performanceresourcetiming-requeststart
m.requestEnd:#dom-performanceresourcetiming-requestend
m.responseStart:#dom-performanceresourcetiming-responsestart
m.responseEnd:#dom-performanceresourcetiming-responseend
m.transferSize:#dom-performanceresourcetiming-transfersize
m.encodedBodySize:#dom-performanceresourcetiming-encodedbodysize
m.decodedBodySize:#dom-performanceresourcetiming-decodedbodysize

m.clearResourceTimings:#dom-performance-clearresourcetimings
m.setResourceTimingBufferSize:#dom-performance-setresourcetimingbuffersize
m.onresourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull

m.name:#dfn-name
m.entryType:#dfn-entrytype
m.startTime:#dfn-starttime
m.duration:#dfn-duration

m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes

	https://www.w3.org/TR/beacon/
m.sendBeacon:~BEACON#sec-sendBeacon-method
m.fetch:~FETCH#fetch-method

l.css:#dfn-css
l.navigation:#dfn-navigation
l.xmlhttprequest:#dfn-xmlhttprequest
l.fetch:#dfn-fetch
l.beacon:#dfn-beacon
l.other:#dfn-other

	●e
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.link:~HEmetadata#the-link-element
e.script:~HEscripting#the-script-element
e.object:~HEembed#the-object-element
e.svg:~SVGstruct#elementdef-svg
	e.svg:~SVG11/struct.html#SVGElement

et.resourcetimingbufferfull:#dfn-resourcetimingbufferfull

h.Timing-Allow-Origin:#dfn-timing-allow-origin
	h.Origin:~IETF/rfc6454#section-4

css.url():~CSSSYN#consume-a-url-token

P.origin-or-null:~FETCH#origin-header
P.wildcard:~FETCH#http-new-header-syntax


応答~code:~RFC7231#section-6
st.1xx:~RFC7231#section-6.2
st.3XX:~RFC7231#section-6.4
	#rfc.section.6.4
st.204:~RFC7231#section-6.3.5
	HTTP 204 (No Content):#status.204
hm.GET:~7231#section-4.3.1
hm.POST:~7231#section-4.3.3
安全:~RFC7231#safe.methods


処理~model:#processing-model

i.~obj作成:#dfn-step-create-object
i.~fetch開始:#dfn-step-fetch-start
i.収集~開始:#dfn-step-collection-start
i.接続-開始:#dfn-step-connect-start
i.要請~開始:#dfn-step-request-start
i.応答~開始:#dfn-step-response-start
i.応答~終止:#dfn-step-response-end
i.最終~記録-:#dfn-step-final-record
	-:#dfn-step-final-queue

	●
~redirect等:#_redirect-or-equivalents
局所~cache等:#_cache-or-local
満杯:#_full

資源:#dfn-resource
非同一-生成元:#dfn-cross-origin
現-文書:#dfn-current-document
現-時刻:#dfn-current-time
応答~終止~時刻を取得する:#dfn-get-response-end-time

計時~許可検査:#dfn-timing-allow-check

資源~計時~buffer~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~buffer現size:#dfn-resource-timing-buffer-current-size
資源~計時~buffer満杯~event処理待ち~flag:#dfn-resource-timing-buffer-full-event-pending-flag
資源~計時~副buffer:#dfn-resource-timing-secondary-buffer
資源~計時~副buffer現size:#dfn-resource-timing-secondary-buffer-current-size

処理能~entry~bufferに~entryを追加する:#dfn-add-a-performanceresourcetiming-entry
資源~計時~entryを追加でき:#dfn-can-add-resource-timing-entry
~buffer満杯~eventを発火する:#dfn-fire-a-buffer-full-event
副buffer内の~entryを移動する:#dfn-copy-secondary-buffer

時刻起点:~HRTIME#dfn-time-origin


処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer
処理能時列線:~TIMELINE#performance-timeline
	#sec-performance-timeline
	Performance:~TR/navigation-timing-2/#performance
処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry

~ASCII符号化する:~INFRA#ascii-encode


要請:~FETCH#concept-request
rq.行先:~FETCH#concept-request-destination
rq.~client:~FETCH#concept-request-client
rq.生成元:~FETCH#concept-request-origin
rq.~window:~FETCH#concept-request-window

~HTTP~network~fetch:~FETCH#http-network-fetch
~HTTP~network-or-cache~fetch:~FETCH#http-network-or-cache-fetch
~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~navi要請:~FETCH#navigation-request

~HTTP~cache:~RFC7234#section-1
~HTTP2:~IETF/rfc7540
	~IETF/draft-ietf-httpbis-http2-16
	ALPN〜:https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids

~ES大域~環境:~WEBIDL#es-environment
既定の~toJSON演算:~WEBIDL#default-tojson-operation


閲覧文脈:~BROWSERS#browsing-context
	~HTML50/browsers.html#browsing-context
結付けられている文書:~WINDOW#concept-document-window
	~WINDOW#dom-document-2
大域~obj:~WAPI#concept-settings-object-global
環境~設定群~obj:~WAPI#environment-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker

doc.生成元:~DOM#concept-document-origin

関連な~app~cache:~HTMLLS/offline.html#relevant-application-cache
	~HTML50/...

解決-済み~URL:~HTMLurl#resulting-url-string
	~HTMLurl#parse-a-url
	＊#resolve-a-url
	~URL1#

v.stylesheet:~HTMLlinks#link-type-stylesheet

	data: URI:~IETF/rfc2397
同一-生成元:~ORIGIN#same-origin
	生成元:~ORIGIN#concept-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

内容~符号法たち:~RFC7231#section-3.1.2.1
	http://httpwg.github.io/specs/rfc7231.html#content.codings

転送~符号法:~RFC7230#section-4
持続的~接続:~RFC7230#section-6.3
非同期に~close:~RFC7230#section-6.5
~message本体:~RFC7230#section-3.3
~payload本体:~RFC7230#section-3.3
~chunked符号法:~RFC7230#section-4.1

要素:~DOM4#concept-element
局所~名:~DOM4#concept-element-local-name
	m.localName:~DOM4#concept-element-local-name
~eventを発火する:~DOM4#concept-event-fire

~taskを~queueする:~WAPI#queue-a-task

走らす:~SW1#run-service-worker
	＊~SW1#service-worker-concept
作動中の~worker:~SW1#dfn-active-worker
合致する作動中の~worker:~SW1#dfn-containing-service-worker-registration
~sw登録:~SW1#dfn-service-worker-registration
名前~fetch_evの~eventを発火する:~SW1#on-fetch-request-algorithm

~TR/html5/infrastructure.html#http-response-codes
	＊:~TR/html5/infrastructure.html#or-equivalent
	:~RFC7230#section-7

	-:#dom-PerformanceNavigationTiming-startTime
	-:https://www.w3.org/TR/navigation-timing-2/#dom-PerformanceNavigationTiming-startTime
	-:conforming IDL fragments:https://www.w3.org/TR/2016/REC-WebIDL-1-20161215/#dfn-conforming-set-of-idl-fragments

	-:#dfn-dom
	-:#dfn-getting
	-:#dfn-setting
	-:#dfn-javascript
	-:#dom

●●words_table1

	SW:https://www.w3.org/TR/service-workers-1/
BEACON:beacon-ja.html
fetch_ev: <code class="event-type">fetch</code>


●●words_table

	●fetch／HTTP/network
TLS:
DNS:
TCP:
SOCKS:
	^i:TLS False Start
	^i:Finished
	early-data
HTTP2:HTTP/2
	HTTP/1.1
download::::ダウンロード
payload::::ペイロード
事前読込み:preload::事前読み込み:事前ロード
open:
	~openし直:reopen
close:
redirect::::リダイレクト
	~redirect:redirection
検索:lookup::~
tunnel::::トンネル
handshake::::ハンドシェイク
	~handshake:handshare
chunked::::チャンク化
端点間:end-to-end::~::エンドツーエンド
符号法:coding::~::コーディング
network-or-cache::::ネットワーク-or-キャッシュ
連鎖:chain::~
受信:receiving::~
受信者:recipient::~
	送信し直:resend
送信者:sender::~
持続的:persistent::~
確立ng:establishing:確立
確立:establishment:~
低層の:lower-layer::~
事前条件:precondition::~
出自に:originate:~
再検証-:revalidate::~
再検証:revalidation::~
結合-:combine::~

hit::::ヒット
miss::::ミス
到着-:arrive:~
early-data:early data
	~app~cache:application cache


	●計時
処理能時列線:Performance Timeline::~::パフォーマンスタイムライン
時列線:timeline::~::タイムライン
	時系列順:
	milliseconds:::ミリ秒~数
時計:clock::~::クロック
skew::::スキュー
時刻:time::~
時間:time::~
計時:timing::~
時機:timing::~
時刻起点:time origin::~
時区間:interval::~
	要した時間:time interval／:time it takes to
	要する時間:time needed
経過時間:time elapsed::~
	経過:since

計測:measurement:~
計測-:measure:~
測定:measurement:~
測定-:measure:~
単調増加:monotonic::~
単調増加-:monotonic に increase:~

	費やさ:takes／spent

	●syntax
octet::::オクテット
percent::::パーセント
comma::::カンマ
改行文字:newline::~
数字:digit::~
	~~復号:remove
正準形:canonical な形:~

	●保安
認証:authentication::~
challenge::::チャレンジ
	challenge応答:challenge-response
	統計的指紋収集:statistical fingerprinting

	●DOM ／ IDL／データ構造
toJSON:
根元:root::~

	●環境

	●処理一般
overhead::::オーバーヘッド
副buffer:secondary buffer:副 buffer::副バッファ
満杯:full::~
開始:start:~
終止:end:終了
許可検査:allow check::~
処理待ち:pending:~
合格-:pass::~
逐次的:sequential::~

	●仕様
包括的:comprehensive:~
様相:picture:~
必要性:need:~
	必要
暫定的:provisional:~
適理な:reasonableな:理に適う
背景:background:~
理想的:ideal:~

encapsulation::::カプセル化
上限:limit:~
表面化-:surface:~
記述的:descriptive:~
再試行:retry:~
被った:incurした:~
未登録の:non-registered:~
registry::::レジストリ
位置付け:status:~
文書化-:document:~
収束-:converge:~
目指す:aimする:~
相互運用:interop:~
現実世界:real-world:~

	~~手段:instrumentation
	も:additional
	仕立て上げ:be modified to
	登録-済み:registered
	~risk下:at risk
	~~手法:-
	足りる:sufficiently
	しておく:make sure
	により:according to
	こともある:possible
	方法:-
	今日:today
	図式:graph
	内訳
	~~測定:telemetry
	助かる:helpful
	ありがたい:It would be great
	とする:suppose
	十分:enough

	●未分類（動詞
内包-:include:~
知覚-:perceive:~
	-:excess
	number of excess entries
	後続-:follow
	対象にする:included
	前に生じる:preceed
	からなる:compose
	〜内の~entryを移動する:copy
	無けれ:if not present

	●未分類
成分:
ALPN:
ES:ECMAScript
benchmark::::ベンチマーク
kernel::::カーネル
品質:quality:~
差分:difference:~

	-:underline
	可能
	各段階
	移動できなかった~entryは:does not add more room in the buffer than it adds resources to it

	●指示語
現size:current size:現 size::現サイズ
現-:current:~

	開始時点:at the beginning
	起点:since
	時点
	個数:number of／:how many
	最初の:oldest
	一方
	当
	該当
	直前／直後:immediately
	見込まれ:might
	部分
	最終:final
	以前は:Formally
	末尾:the end


●●ref_normative

[BEACON]
    Beacon. Ilya Grigorik; Alois Reitbauer; Arvind Jain; Jatinder Mann. W3C. 13 April 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/beacon/
[CSS-SYNTAX-3]
    CSS Syntax Module Level 3. Tab Atkins Jr.; Simon Sapin. W3C. 16 July 2019. W3C Candidate Recommendation. URL: https://www.w3.org/TR/css-syntax-3/
[DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.es/ecma262/
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik. W3C. 21 November 2019. W3C Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 15 July 2019. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/
[PERFORMANCE-TIMELINE-2]
    Performance Timeline Level 2. Ilya Grigorik. W3C. 24 October 2019. W3C Working Draft. URL: https://www.w3.org/TR/performance-timeline-2/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[RFC2397]
    The "data" URL scheme. L. Masinter. IETF. August 1998. Proposed Standard. URL: https://tools.ietf.org/html/rfc2397
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234
[RFC5246]
    The Transport Layer Security (TLS) Protocol Version 1.2. T. Dierks; E. Rescorla. IETF. August 2008. Proposed Standard. URL: https://tools.ietf.org/html/rfc5246
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html
[RFC7231]
    Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7231.html
[RFC7234]
    Hypertext Transfer Protocol (HTTP/1.1): Caching. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7234.html
[RFC7301]
    Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension. S. Friedl; A. Popov; A. Langley; E. Stephan. IETF. July 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7301
[RFC7918]
    Transport Layer Security (TLS) False Start. A. Langley; N. Modadugu; B. Moeller. IETF. August 2016. Informational. URL: https://tools.ietf.org/html/rfc7918
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://tools.ietf.org/html/rfc8174
[RFC8470]
    Using Early Data in HTTP. M. Thomson; M. Nottingham; W. Tarreau. IETF. September 2018. Proposed Standard. URL: https://httpwg.org/specs/rfc8470.html
[service-workers-1]
    Service Workers 1. Alex Russell; Jungkee Song; Jake Archibald; Marijn Kruisselbrink. W3C. 19 November 2019. W3C Candidate Recommendation. URL: https://www.w3.org/TR/service-workers-1/
[SVG11]
    Scalable Vector Graphics (SVG) 1.1 (Second Edition). Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. W3C. 16 August 2011. W3C Recommendation. URL: https://www.w3.org/TR/SVG11/
[WEBIDL]
    Web IDL. Boris Zbarsky. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/
[XHR]
    XMLHttpRequest Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://xhr.spec.whatwg.org/

●●ref_informative

[service-workers-nightly]
    Service Workers Nightly. Alex Russell; Jungkee Song; Jake Archibald; Marijn Kruisselbrink. W3C. LS. URL: https://w3c.github.io/ServiceWorker/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Resource Timing Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/resource-timing-2/
最新の編集者草案
	https://w3c.github.io/resource-timing/
編集
	<a href="toddreif@microsoft.com">Todd Reifsteck</a> (Microsoft Corp.)
	<a href="igrigorik@gmail.com">Ilya Grigorik</a> (Google)
	<a href="yoav@yoav.ws">Yoav Weiss</a> (Google) 
前任編集者
	<a href="arvind@google.com">Arvind Jain</a> (Google Inc.) (Until December 2014)
	<a href="jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until February 2014)
	Zhiheng Wang (Google Inc.) (Until July 2012)
	Anderson Quach (Microsoft Corp.) (Until March 2011)
Participate
	<a href="https://github.com/w3c/resource-timing/">GitHub w3c/resource-timing </a>
	<a href="https://github.com/w3c/resource-timing/issues">File a bug</a>
	<a href="https://github.com/w3c/resource-timing/commits/gh-pages/index.html">Commit history</a>
	<a href="https://github.com/w3c/resource-timing/pulls/">Pull requests</a>
ブラウザサポート
	https://caniuse.com/#feat=resource-timing
Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>
発行者
	<a href="https://www.w3.org/webperf/">Web Performance</a> Working Group

</script>

</head>

<body>

<header>
	<hgroup>
<h1>リソースの計時 — Resource Timing Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT
<p>
この仕様は、~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは編集者草案の公の複製です…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status">W3C 日本語訳 共通ページ</a>／冒頭の仕様メタデータに委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が知覚し得る待時間は Web ~appにとり重要な品質~benchmarkである。
~JSに基づく仕組みは、~appにおける利用者~側の待時間を測定するための包括的な~~手段を供せるが、端点間の待時間については，多くの事例で，完全な様相を供せない。
この仕様は、 `PerformanceResourceTiming$I ~interfaceを導入する。
それは、~JSにより，文書~上の資源に関係する完全な計時~情報を収集するための仕組みである。
`NAVIGATION-TIMING-2$r は、この仕様を拡張して，~naviに関わる追加的な計時~情報を供する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. This document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document. Navigation Timing 2 [NAVIGATION-TIMING-2] extends this specification to provide additional timing information associated with a navigation.
</p>

<div class="example">
<p>
例えば，次の~JSは、単純な方法により，資源~fetchに要した時間を計測しようと試みる：
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %start = new Date().getTime();
   var %image1 = new Image();
   var %resourceTiming = function() {
       var %now = new Date().getTime();
       var %latency = %now - %start;
       alert("End to end resource fetch: " + %latency);
   };

   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源~fetchに要した時間は計測できるが、その内訳の各段階に費やされた時間は計測できない。
更に、~markupにより記述された資源に費やされた時間を，この~scriptで計測することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に取組むため、この文書は
`PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、~client側~appにおける待時間の完全な計測を可能にする，~JSによる仕組みを供する。
この~interfaceにより、前の例は，利用者が知覚する資源の読込n時間を計測-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、~markupにより定義されたものまで含め，~page内のそれぞれの資源~fetchに要した時間の~~長さを計算する。
この例は、~pageが
<samp >https://www.w3.org</samp>
下に~hostされていると見做している。
その気になれば
`PerformanceResourceTiming$I
~interfaceを利用して、資源~fetchingの各段階ごとに要した時間も計測できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on https://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %image1 = new Image();
   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var %resourceList = window.performance.getEntriesByType("resource");
    for (%i = 0; %i &lt; %resourceList.length; i++) {
       if (%resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( %resourceList[i].responseEnd  - %resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>

	<section id="conformance">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#terminology" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<p>
この仕様を通して、以下の用語が用いられる：
</p>

<dl class="def-list">
	<dt>`資源@（ `resource^en ）</dt>
	<dd>
<p>
要素その他 利用者により起動される~fetchを指す。
例えば資源は、次に挙げるものを出自にし得る：
</p>

<ul ><li>`XMLHttpRequest$I ~obj `XHR$r
</li><li>`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v の `link$e
］などの，~HTML要素 `HTML$r
</li><li>`svg$e などの~SVG要素 `SVG11$r
</li></ul>
◎
The term resource is used to refer to elements and any other user-initiated fetches throughout this specification. For example, a resource could originate from XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</dd>

	<dt>`非同一-生成元@（ `cross origin^en ）</dt>
	<dd>
`同一-生成元$でないことを意味する。
◎
The term cross-origin is used to mean non same origin.
</dd>

	<dt>`現-文書@（ `current document^en ）</dt>
	<dd>
`Window^I ~objに`結付けられている文書$を指す。
◎
The term current document refers to the document associated with the Window object's newest Document object.
</dd>

	<dt>`現-時刻@（ `current time^en ）</dt>
	<dd id="_measured-since">
時刻~値は，
<a href="~NAV-TIMING#dom-performancenavigationtiming-starttime">文書の~naviの開始</a>
を起点としてミリ秒~単位で計測されるものとする
`HR-TIME-2$r
。
例えば，文書の~naviの開始は、時刻 0 で生じる。
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME-2]. For example, the start of navigation of the document occurs at time 0.
</dd>
	<dd>
`現-時刻$は、文書の~naviの開始から その時点までに経過した，ミリ秒~数による時刻を指す。
◎
The term current time refers to the number of milliseconds since the start of navigation of the document until the current moment in time.
</dd>
	<dd class="note">注記：
この，時刻の定義は、 `HR-TIME-2$r 仕様に基づくものであり、
1970 年 1 月 1 日 0 時 0 分 0 秒 (UTC) を起点としていた，
`NAVIGATION-TIMING-2$r 仕様による定義
【実際には、旧 Level 1 仕様による定義】
とは異なる。
◎
Note
This definition of time is based on the High Resolution Time specification [HR-TIME-2] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING-2], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</dd>
</dl>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>
<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
簡潔に記すため、次の非公式な用語も導入する：
</p>

<dl class="def-list">
	<dt>`~redirect等@</dt>
	<dd>
~HTTP~redirect応答または（他の~protocolにおける）
<a href="~TR/html5/infrastructure.html#http-response-codes">それに等価なもの</a>
を指す総称。
この定義は、この仕様の以前の~versionによる参照先（過去の~HTML仕様）に基づく
— 現在の原文における<a href="~HTMLLS/#or-equivalent">この用語の参照先</a>は、存在しない（廃された）。
単に，~HTTP~redirect応答にされるべきように思われる
— 同族の `NAVIGATION-TIMING-2$r 仕様では、そう更新されているので。
</dd>

	<dt>`局所~cache等@</dt>
	<dd>
［
`関連な~app~cache$, または局所~資源
］を指す総称。
何をもって局所~資源とされるかは、この仕様には述べられていない。
`file://^P ~URLの資源や`~HTTP~cache$などが含まれそうだが（しかしながら、一部の箇所だけ明示的に “~HTTP~cacheも含む” などと注釈されているため，不明瞭になっている）。
</dd>
</dl>

		</section>
	</section>
	<section id="sec-resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>

		<section id="introduction-0">
<h3 title="Introduction">4.1. 序論</h3>

~INFORMATIVE

<div class="p">
<p>
`PerformanceResourceTiming$I
~interfaceは、~download可能な資源の計時~測定を手助けする。
例えば、次のものに利用できる：
</p>

<ul ><li>`XMLHttpRequest$I ~obj `XHR$r
</li><li>`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v の `link$e
］などの，~HTML要素 `HTML$r
</li><li>`svg$e などの~SVG要素 `SVG11$r
</li></ul>

◎
The PerformanceResourceTiming interface facilitates timing measurement of downloadable resources. For example, this interface is available for XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</div>

		</section>
		<section id="resources-included-in-the-performanceresourcetiming-interface">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源</h3>

<p>
~NULL でない`~client$rqからの`要請$により`~fetch$されたすべての資源は、
`局所~cache等$から検索取得された資源も含め
— `処理~model$の一部として除外されない限り —
`PerformanceResourceTiming$I ~objとして，`~client$rqの`大域~obj$の`処理能時列線$に含めるモノトスル。
ただし，~fetchにより起動されたが（~network~errorなどに因り）後で中止された資源は、`処理能時列線$に含めなくてもヨイ
— 含める場合、各種~属性の値は`処理~model$による手続き（後述）の中で初期化するモノトスル。
◎
All resource Requests fetched by a non-null client MUST be included as PerformanceResourceTiming objects in the client's global object's Performance Timeline, unless excluded from the timeline as part of the processing model. Resources that are retrieved from relevant application caches or local resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) MAY be included as PerformanceResourceTiming objects in the Performance Timeline and MUST contain initialized attribute values for processed substeps of the processing model.
</p>

<p>
この節の残りの部分は規範的ではない。
◎
The rest of this section is non-normative.
</p>

<p>
例：
◎
Examples:
</p>

<ul>
	<li>
複数の~HTML `img$e 要素の `src^a 属性に，正準形が同じになる~URL（ `the same canonical URL^en 
【すなわち，同じ資源を指す~URL】
）が利用されている場合、［
最初に資源`~fetch$を起動させた `img^e 要素
］の方が `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められるベキである。
~UAは、 2 個目以降の `img^e 要素の~URLに対しては、再~要請することなく，最初に起動された方による既存の~downloadを利用すると見込まれるので。
この場合，`処理能時列線$には、最初に起動された， `img^e 要素に対する資源`~fetch$による結果のみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element SHOULD be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
~HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、元々の資源`~fetch$のみならず，新たな~URLへの`~fetch$も， `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められることになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
~HTML `iframe$e 要素の~markupに `src^a 属性が指定されていない場合、~UAは `about:blank^c 文書を読込むことになる。
後で~scriptから `src^a 属性が動的に変更された場合，その新たな~URLの資源へ`~fetch$されることになる。
この場合、新たな~URLによる`~fetch$のみが， `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められることになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
正準形が同じになる~URL用に，複数の `XMLHttpRequest$I が生成された場合、いずれの資源`~fetch$も， `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められることになる
— 後続する資源~fetch要請には、先行する要請による~downloadを再利用できないので。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
~page内の~HTML `iframe$e 要素に内包された文書により要請される下位資源は、親~文書の`処理能時列線$ではなく，内包された文書の`処理能時列線$に含められる。
`iframe^e に対し`処理能時列線$に含められるのは、その `src^a 属性により要請される資源に限られる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素が~sourceとして
<a href="~IETF/rfc2397">data: URI</a> `RFC2397$r
を持つ場合、その資源は，`処理能時列線$には含められない。
data: URI は埋込d~dataであり、`~fetch$を要さないものと定義されているので。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. By definition data: URI contains embedded data and does not require a fetch.
</li>
	<li>
資源`~fetch$が~network~error（ ~DNS, ~TCP, ~TLS ~errorなど）に因り中止された場合、その~fetchは，失敗した時点までの属性~値で初期化された `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められてヨイ
— 例えば~TCP~handshake~errorは、 要請~用の~DNS時刻印を報告するべきである, 等々。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch MAY be included as a PerformanceResourceTiming object in the Performance Timeline with initialized attribute values up to the point of failure - e.g. a TCP handshake error should report DNS timestamps for the request, and so on.
</li>
	<li>
資源`~fetch$が，事前条件（例： 混在内容（ `mixed content^en ）, ~CORS制約, ~CSP施策, など）に失敗したことにより中止された場合、その資源については，`処理能時列線$には含められるベキでない。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource SHOULD NOT not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
</ul>

		</section>
		<section id="sec-performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>

<p>
`PerformanceResourceTiming$I ~interfaceは、`処理能時列線$に関与し，次に挙げる
`PerformanceEntry$I ~interfaceの属性を拡張する：
◎
The PerformanceResourceTiming interface participates in the Performance Timeline and extends the following attributes of the PerformanceEntry interface:
</p>

<dl class="idl-def">
	<dt>`name@m</dt>
    <dd>
取得子は、要請された資源の`解決-済み~URL$を返すモノトスル。
この属性は、`~fetch$先が異なる~URLに~redirectされても，変化しないモノトスル。
◎
This attribute MUST return the resolved URL of the requested resource. This attribute MUST NOT change even if the fetch redirected to a different URL.
</dd>

	<dt>`entryType@m</dt>
	<dd>
取得子は、 `resource^l を返すモノトスル。
◎
The entryType attribute MUST return the DOMString "resource".
</dd>

	<dt>`startTime@m</dt>
	<dd>
取得子は、［
~UAが資源`~fetching$を~queueする直前の時刻
］を表す，［
`DOMHighResTimeStamp$I 型 `HR-TIME-2$r の値
］を返すモノトスル。
資源~fetchの間に`~redirect等$が生じたときは、次に与える値を返すモノトスル
⇒＃
`計時~許可検査$に合格するならば、 `redirectStart$m と同じ値 ／
~ELSE_ `fetchStart$m と同じ値
◎
The startTime attribute MUST return a DOMHighResTimeStamp [HR-TIME-2] with the time immediately before the user agent starts to queue the resource for fetching. If there are HTTP redirects or equivalent when fetching the resource, and if the timing allow check algorithm passes, this attribute MUST return the same value as redirectStart. Otherwise, this attribute MUST return the same value as fetchStart.
</dd>

	<dt>`duration@m</dt>
	<dd>
取得子は、［
`responseEnd$m の `startTime$m からの差分
］を表す `DOMHighResTimeStamp$I を返すモノトスル
【！ ＊,respectively 】
◎
The duration attribute MUST return a DOMHighResTimeStamp equal to the difference between responseEnd and startTime, respectively.
◎
DOMHighResTimeStamp is defined in [HR-TIME-2].
</dd>
</dl>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute `DOMString$ `initiatorType$m;
  readonly attribute `DOMString$ `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$I `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$I `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseEnd$m;
  readonly attribute unsigned long long `transferSize$m;
  readonly attribute unsigned long long `encodedBodySize$m;
  readonly attribute unsigned long long `decodedBodySize$m;
  [`Default$] `object$ `toJSON$m();
};
</pre>

<dl class="idl-def">
	<dt>`toJSON()@m</dt>
	<dd>
~call時には、 `WebIDL$r による`既定の~toJSON演算$を走らす。
◎
When toJSON is called, run [WEBIDL]'s default toJSON operation.
</dd>

	<dt>`initiatorType@m</dt>
	<dd>
<p>
取得子は、何が資源の~fetch要請を生じさせたかに応じて，次を返すモノトスル：
◎
On getting, the initiatorType attribute MUST return one of the following DOMString values:
</p>

		<ul>
			<li>
要請は`要素$を処理した結果による場合
⇒
当の要素の`局所~名$
◎
The same value as the localName of that element [DOM], if the request is a result of processing the element;
</li>
			<li>
要請は
`url()$css による指令（
`@import url()^css や `background: url()^css
など）
`CSS-SYNTAX-3$r
を処理した結果による場合
⇒
`css@l
◎
"css", if the request is a result of processing a CSS url() directive [CSS-SYNTAX-3], such as @import url() or background: url();
</li>
			<li>
要請は
`~navi要請$である場合
⇒
`navigation@l
◎
"navigation", if the request is a navigation request;
</li>
			<li>
要請は `XMLHttpRequest$I ~obj `XHR$r を処理した結果による場合
⇒
`xmlhttprequest@l
◎
"xmlhttprequest", if the request is a result of processing an XMLHttpRequest object [XHR];
</li>
			<li>
要請は
`fetch()$m ~method
`FETCH$r
を処理した結果による場合
⇒
`fetch@l
◎
"fetch", if the request is the result of processing the Fetch method [FETCH];
</li>
			<li>
要請は
`sendBeacon()$m ~method
`BEACON$r
を処理した結果による場合
⇒
`beacon@l
◎
"beacon", if the request is the result of processing the sendBeacon method [BEACON];
</li>
			<li>
上に挙げたどれにも該当しない場合
⇒
`other@l
◎
"other", if none of the above conditions match.
</li>
		</ul>
	</dd>

	<dt>`nextHopProtocol@m</dt>
	<dd>
<p>
取得子は、［
当の資源が`局所~cache等$から検索取得されているならば 空~文字列 ／
~ELSE_ 
~ALPN~protocol~ID
— `ALPN Protocol ID^en `RFC7301$r —
として識別される，資源~fetchに利用された~network~protocol
］を返すモノトスル。
~proxyが環境設定されている下では、次を返すモノトスル：
</p>
		<ul>
			<li>
~tunnel接続が確立された場合
⇒
その~tunnelされた~protocolの~ALPN~protocol~ID
</li>
			<li>
他の場合
⇒
~proxyへの最初の hop の~ALPN~protocol~ID
</li>
		</ul>

<p>
~ALPN~protocol~IDを精確に表現するため、次の拘束も適用される：
</p>
		<ul>
			<li>
~ALPN~protocol内の~octetのうち， `%^l を除く妥当な~token文字は~percent符号化しないモノトスル。
</li>
			<li>
~percent符号化法には，大文字の 16 進~数字を利用するモノトスル。
</li>
		</ul>
◎
On getting, the attribute nextHopProtocol returns the network protocol used to fetch the resource, as identified by the ALPN Protocol ID [RFC7301]; resources retrieved from relevant application caches or local resources, return an empty string. When a proxy is configured, if a tunnel connection is established then this attribute MUST return the ALPN Protocol ID of the tunneled protocol, otherwise it MUST return the ALPN Protocol ID of the first hop to the proxy. In order to have precisely one way to represent any ALPN protocol ID, the following additional constraints apply: octets in the ALPN protocol MUST NOT be percent-encoded if they are valid token characters except "%", and when using percent-encoding, uppercase hex digits MUST be used.
</dd>
	<dd>
登録-済み~ALPN~protocol~IDは、以前は IANA により文書化されていた。
~UAは、試験的な未登録の~protocolを利用している事例では，~ALPN用に折衝されている値があれば それを利用するモノトスル
— ~ALPNは~protocol折衝~用に利用されていない場合、別の記述的な文字列を利用してもヨイ
◎
Formally registered ALPN protocol IDs are documented by IANA. In case the user agent is using an experimental, non-registered protocol, the user agent MUST use the ALPN negotiated value if any. If ALPN was not used for protocol negotiations, the user agent MAY use another descriptive string.
Note
</dd>
	<dd class="note">注記：
~ALPN~ID `h3^l は、
`HTTP/3 Internet Draft^en
内の
`HTTP/3 protocol^en
の最終~version用に定義されている。
◎
The "h3" ALPN ID is defined for the final version of the HTTP/3 protocol in the HTTP/3 Internet Draft.
</dd>
	<dd>
この属性は、実際にどう折衝されたかに関わらず，~fetch用に利用~中の~network~protocolを識別するためとして意図されていることに注意。
すなわち、~network~protocolを折衝するために~ALPNが利用されていなくても、この属性は，依然として，~ALPN~protocol~IDを利用して利用~中の~protocolを指示する。
◎
Note that the nextHopProtocol attribute is intended to identify the network protocol in use for the fetch regardless of how it was actually negotiated; that is, even if ALPN is not used to negotiate the network protocol, this attribute still uses the ALPN Protocol ID's to indicate the protocol in use.
</dd>

	<dt>`workerStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the workerStart attribute MUST return as follows:
</p>
		<ol>
			<li>
%worker ~LET 此れに`関連な設定群~obj$にて`作動中の~sw$enV
◎
↓</li>
			<li>
<p>
~IF［
%worker ~NEQ ~NULL
］~AND［［
資源は`計時~許可検査$に合格した
］~OR［
資源`要請$の`行先$rq ~NEQ `document^l
］］：
◎
If the active service worker of the context object's relevant settings object is not null and if the resource passes the timing allow check algorithm or the resource Request's destination does not equal "document":
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である
］
⇒
~RET ~UAが［
 %worker に向けて，`名前~fetch_evの~eventを発火する$
］直前の時刻
◎
the time immediately before the user agent fires an event named fetch at the active worker if the worker is available.
</li>
					<li>
~RET ~UAが［
%worker を`走らす$
］直前の時刻
◎
the time immediately before the user agent runs the worker required to service the request.
</li>
				</ol>
			</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
~workerの`時刻起点$の定義により、~naviにおける事前読込み（ `preload^en ）要請
【用の `PerformanceResourceTiming$I ~obj】
の一部の属性は，負な `DOMHighResTimeStamp$I 値をとることもある。
【時刻起点より前に~fetchが起動され得るので（<a href="https://github.com/w3c/resource-timing/issues/139">詳細</a>）。】
◎
Note
Note that according to the definition of time origin in workers, it is possible that some attributes of navigation preload requests will have negative DOMHighResTimeStamp values.
</dd>

	<dt>`redirectStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the redirectStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源`~fetching$において`~redirect等$が生じている
］~AND［
資源は`計時~許可検査$に合格した
］
⇒
~RET ［
~redirectを起動させた`~fetch$を開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the resource that initiates the redirect, if there are HTTP redirects or equivalent when fetching the resource and the resource passes the timing allow check algorithm.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dt>`redirectEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the redirectEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源`~fetching$において`~redirect等$が生じている
］~AND［
資源は`計時~許可検査$に合格した
］
⇒
~RET ［
最後の~redirectに対する応答の最後の~byteを受信した
］直後の時刻
◎
The time immediately after receiving the last byte of the response of the last redirect, if there are HTTP redirects or equivalent when fetching the resource and the resource passes the timing allow check algorithm.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dt>`fetchStart@m</dt>
	<dd>

<p>
取得子は、次を走らすモノトスル：
◎
On getting, the fetchStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
`~redirect等$が生じている
］
⇒
~RET ~UAが［
~redirectされなかった最後の資源`~fetch$を開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the final resource in the redirection, if there are HTTP redirects or equivalent.
</li>
			<li>
~RET ~UAが［
資源`~fetch$を開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the resource otherwise.
</li>
		</ol>
	</dd>

	<dt>`domainLookupStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the domainLookupStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源は`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if the resource fails the timing allow check algorithm.
</li>
			<li>
~IF［
資源を~fetchする際に~domain検索は要求されていない（例：
`持続的~接続$ `RFC7230$r が利用されている／
資源は`局所~cache等$から検索取得された）
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if no domain lookup was required to fetch the resources (e.g. if a persistent connection [RFC7230] was used or in case the resource was retrieved from relevant application caches or local resources).
</li>
			<li>
~IF［
~UAの~cache内に~domain情報が在る
］
⇒
~RET ~UAが［
~domain情報~cacheから~domain~dataの検索取得を開始した
］直前の時刻
◎
The time immediately after the user agent starts the domain data retrieval from the domain information cache, if the user agent has the domain information in cache.
</li>
			<li>
~RET ~UAが［
資源~用の~domain名~検索を開始した
］直前の時刻
◎
The time immediately before the user agent starts the domain name lookup for the resource, otherwise.
</li>
		</ol>
	</dd>

	<dt>`domainLookupEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the domainLookupEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源は`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if the resource fails the timing allow check algorithm.
</li>
			<li>
~IF［
資源を~fetchする際に~domain検索は要求されていない（例：
`持続的~接続$ `RFC7230$r が利用されている／
資源は`局所~cache等$から検索取得された）
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if no domain lookup was required to fetch the resources (e.g. if a persistent connection [RFC7230] was used or in case the resource was retrieved from relevant application caches or local resources).
</li>
			<li>
~IF［
~UAの~cache内に~domain情報が在る
］
⇒
~RET ~UAが［
~domain情報~cacheからの~domain~dataの検索取得を終えた
］直後の時刻
◎
The time immediately after the user agent ends the domain data retrieval from the domain information cache, if the user agent has the domain information in cache.
</li>
			<li>
~RET ~UAが［
資源~用の~domain名~検索を完遂した
］直後の時刻
◎
The time immediately after the user agent finishes the domain name lookup for the resource, otherwise.
</li>
		</ol>
	</dd>

	<dt>`connectStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the connectStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源は`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if the resource fails the timing allow check algorithm.
</li>
			<li>
~IF［
`持続的~接続$ `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
<p>
~RET ~UAが［
資源を検索取得するために，~serverとの接続の確立ngを開始した
］直前の時刻
◎
The time immediately before the user agent start establishing the connection to the server to retrieve the resource, otherwise.
</p>

<p>
~transport接続が失敗して，~UAが接続を~openし直した場合、
`connectStart$m は，新たな接続に対応する値を返すベキである。
◎
If the transport connection fails and the user agent reopens a connection, connectStart SHOULD return the corresponding value of the new connection.
</p>
			</li>
		</ol>
	</dd>

	<dt>`connectEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the connectEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源は`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if the resource fails the timing allow check algorithm.
</li>
			<li>
~IF［
`持続的~接続$ `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
<p>
~RET ~UAが［
資源を検索取得するために，~serverとの接続の確立ngを完遂した
］直後の時刻
— ~UAは、この属性が返す時刻までの時区間には：
◎
The time immediately after the user agent finish establishing the connection to the server to retrieve the resource, otherwise.
</p>
				<ul>
					<li>
次に要した時間を含めるモノトスル
⇒＃
~transport接続を確立する／
~SOCKS認証などの他のもの／
資源を要請するためとして十分な~TLS~handshakeを完了する
◎
The returned time MUST include the time interval to establish the transport connection, as well as other time intervals such as SOCKS authentication. It MUST include the time interval to complete enough of the TLS handshake to request the resource.
</li>
					<li>
この接続~用に `TLS False Start^i `RFC7918$r を利用した場合には、~serverの `Finished^i ~messageを受信するために要する時間は含めないモノトスル。
◎
If the user agent used TLS False Start [RFC7918] for this connection, this interval MUST NOT include the time needed to receive the server's Finished message.
</li>
					<li>
~handshakeを全部的に完了するのを待機することなく~early-data `RFC8470$r を伴う要請を送信した場合には、~serverの `ServerHello^i ~messageを受信するために要する時間は含めないモノトスル。
◎
If the user agent sends the request with early data [RFC8470] without waiting for the full handshare to complete, this interval MUST NOT include the time needed to receive the server's ServerHello message.
</li>
					<li>
要請を送信するまでに，~handshakeの全部的な完了を待機した場合には
— ~early-dataを利用して，この接続~上に他の要請を送信した場合でも —
全部的な~TLS~handshakeを含めるとする。
◎
If the user agent waits for full handshake completion to send the request, this interval includes the full TLS handshake even if other requests were sent using early data on this connection.
</li>
				</ul>

<p class="note">注記：
例えば~UAは、~TLS 1.3 越しに~HTTP2接続を確立して，
`GET$hm 要請と `POST$hm 要請を送信するとする。
~UAは、時刻 %t1 に `ClientHello^i を送信してから，~early-dataを伴う `GET^hm 要請を送信するとする。
`POST^hm 要請は`安全$でない `RFC7231$r （ § 4.2.1）ので、~UAは，それを送信する前に~handshakeが完了する時刻 %t2 まで待機することになる。
両~要請とも同じ接続を利用しているが、
`GET^hm 要請は `connectEnd^m 値として %t1 を報告する一方で，
`POST^hm 要請は `connectEnd^m 値として %t2 を報告することになる。
◎
Example: Suppose the user agent establishes an HTTP/2 connection over TLS 1.3 to send a GET request and a POST request. It sends the ClientHello at time t1 and then sends the GET request with early data. The POST request is not safe [RFC7231] (section 4.2.1), so the user agent waits to complete the handshake at time t2 before sending it. Although both requests used the same connection, the GET request reports a connectEnd value of t1, while the POST request reports a connectEnd value for t2.
</p>

<p>
~transport接続が失敗して，~UAが接続を~openし直した場合、
`connectEnd$m は，新たな接続に対応する値を返すベキである。
◎
If the transport connection fails and the user agent reopens a connection, connectEnd SHOULD return the corresponding value of the new connection.
</p>

			</li>
		</ol>
	</dd>

	<dt>`secureConnectionStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the secureConnectionStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
~secure~transportは利用されていない
］~OR［
資源は`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if a secure transport is not used or if the resource fails the timing allow check algorithm.
</li>
			<li>
~IF［
`持続的~接続$ `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
~RET ~UAが［
現在の接続を~secureにする~handshake処理を開始した
］直前の時刻
◎
The time immediately before the user agent starts the handshake process to secure the current connection, otherwise.
</li>
		</ol>
	</dd>

	<dt>`requestStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the requestStart attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
資源は`計時~許可検査$に合格した
］
⇒
~RET
~UAが［［
`局所~cache等$, または ~server
］に向けて，その資源~要請を開始した
］直前の時刻
◎
The time immediately before the user agent starts requesting the resource from the server, or from relevant application caches or from local resources, if the resource passes the timing allow check algorithm.
</p>

<p>
要請の送信-後に~transport接続が失敗して，~UAが接続を~openし直して要請を送信し直した場合、その新たな要請に対応する値を返すモノトスル。
◎
If the transport connection fails after a request is sent and the user agent reopens a connection and resend the request, requestStart MUST return the corresponding values of the new request.
</p>
			</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dd class="note">
<p>注記：
この~interfaceは、要請の送信~完了を表現する
“`requestEnd^m” の類の属性は含まない。
◎
Note
This interface does not include an attribute to represent the completion of sending the request, e.g. requestEnd.
</p>

		<ul>
			<li>
~UAからの要請の送信~完了は、［
その種の属性が最も役立つ，~network~transportにおける 対応する完了~時刻
］を常に指示するものではない。
◎
Completion of sending the request from the user agent does not always indicate the corresponding completion time in the network transport, which brings most of the benefit of having such an attribute.
</li>
			<li>
一部の~UAは、~HTTP層の~encapsulationに因り，実際の完了~時刻を決定する~costが高くつく。
◎
Some user agents have high cost to determine the actual completion time of sending the request due to the HTTP layer encapsulation.
</li>
		</ul>
	</dd>

	<dt>`responseStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the responseStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源は`計時~許可検査$に合格した
］
⇒
~RET ~UAの~HTTP構文解析器が［
`局所~cache等$, または~server
］から［
応答の最初の~byte（例：
~HTTP2用には ~frame~headerの~byte列 ／
HTTP/1.x 用には 応答の状態s行l
）
］を受信した直後の時刻
◎
The time immediately after the user agent's HTTP parser receives the first byte of the response (e.g. frame header bytes for HTTP/2, or response status line for HTTP/1.x) from relevant application caches, or from local resources or from the server, if the resource passes the timing allow check algorithm.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
何が “最初の~byteを受信した” かの定義には、
~kernel,
~browserの~network~stack,
~HTTP構文解析器, 
具現化器,
等々，いくつか適理なものが在る。
上では~HTTP構文解析器と定めているので、それが~dataを受信する前に［
~clientの~kernel~buffer, その他の手続き
］の内側にて~dataを~queueする時間も含まれ得る。
◎
Note
There are many reasonable definitions of "receipt of first byte": as seen by the kernel, by the browsers network stack / HTTP parser, by the renderer, and so on. The above definition is with respect to the HTTP parser, and thus may include queuing time inside of client's kernel buffers and other steps that may preceed receipt of data by the HTTP parser.
</dd>
	<dd class="note">注記：
~fetchが複数の要請からなる場合（例：
予行（ `preflight^en ）,
認証~challenge応答,
~redirect,
等々）、報告される `responseStart^m 値は，最後の要請のそれになる。
また、要請に対する応答が複数~在る場合
— すなわち， `1xx$st ( Informational ) 応答が在る場合 —
報告される `responseStart^m 値は，最後の要請に対する最初の応答のそれになる。
◎
Note
For fetches composed of multiple requests (e.g. preflights, authentication challenge-response, redirects, and so on), the reported responseStart value is that of the last request. In the case where more than one response is available for a request, due to an Informational 1xx response, the reported responseStart value is that of the first response to the last request.
</dd>

	<dt>`responseEnd@m</dt>
	<dd>
取得子は、次の結果を返すモノトスル
⇒
`応答~終止~時刻を取得する$
◎
On getting, the responseEnd attribute MUST return the result of running the algorithm to get response end time.
</dd>
	<dd class="algorithm">
<p>
`応答~終止~時刻を取得する@
ときは、次を走らすモノトスル：
◎
When requested to run the get response end time algorithm, the user agent must run the following steps:
</p>
		<ol>
			<li>
~IF［
~UAは~network~errorにより~fetchを中止した
］
⇒
~RET 中止した直前の時刻
◎
If the fetch was aborted due to a network error, return the time immediately before the user agent aborts the fetch.
</li>
			<li>
<p>
~RET 次のうち，早い方の時刻
</p>
				<ul>
					<li>
~UAが［
`局所~cache等$, または~server
］から，資源の最後の~byteを受信した直後の時刻
</li>
					<li>
~transport接続が~closeされる直前の時刻
</li>
				</ul>
◎
Otherwise, return the time immediately after the user agent receives the last byte of the response or immediately before the transport connection is closed, whichever comes first. The resource here can be received either from relevant application caches, local resources, or from the server.
</li>
		</ol>

<p class="trans-note">【
この手続きは、
<a href="https://wicg.github.io/element-timing/">Element Timing API</a>
からも利用される。
】</p>

	</dd>

	<dt>`transferSize@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the transferSize attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
資源は`計時~許可検査$に合格した
］
⇒
~RET ［
`~HTTP~network~fetch$から受信された，応答の［
一連の~header, および`~payload本体$ `RFC7230$r
］に消費された~size
］
◎
the size, in octets received from a HTTP-network fetch, consumed by the response header fields and the response payload body [RFC7230], if the resource passes the timing allow check algorithm.
</p>

<p>
~navigateするときに`~redirect等$があって，すべての`~redirect等$が`同一-生成元$に属する場合、それらの~redirectにより被った~HTTP~overheadも含まれるベキである。
◎
If there are HTTP redirects or equivalent when navigating and if all the redirects or equivalent are same origin, this attribute SHOULD include the HTTP overhead of incurred redirects.
</p>

<p>
この属性は、~HTTPによる~overhead（
HTTP/1.1 における，`~chunked符号法$や~headerの前後の空白（改行文字も含む） ／
`~HTTP2$ における，同じ~stream上の 他の［
~serverから~clientへの~frame
］による~overhead）を含めるベキである一方、低層の~protocolにおける~overhead（
~TLS `RFC5246$r や~TCP
によるものなど）は，含めるベキでない。
◎
This attribute SHOULD include HTTP overhead (such as HTTP/1.1 chunked encoding and whitespace around header fields, including newlines, and HTTP/2 frame overhead, along with other server-to-client frames on the same stream), but SHOULD NOT include lower-layer protocol overhead (such as TLS [RFC5246]or TCP).
</p>

<p class="note">注記：
`transferSize$m 値が `encodedBodySize$m より低くなることもある：
~cache済みの応答が成功裡に再検証されたとき、
`transferSize$m は，再検証する際に被った~HTTP応答~headerたちの~sizeを報告し、
`encodedBodySize$m は，以前に検索取得された~payload本体の~sizeを報告する。
◎
Note
It is possible for transferSize value to be lower than encodedBodySize: when a cached response is successfully revalidated the transferSize reports the size of the response HTTP headers incurred during the revalidation, and encodedBodySize reports the size of the previously retrieved payload body.
</li>
			<li>
~RET 0
— 資源が`局所~cache等$から検索取得された場合も含め
◎
zero otherwise, including for resources retrieved from relevant application caches or from local resources.
</li>
		</ol>

	</dd>

	<dt>`encodedBodySize@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the encodedBodySize attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源は`計時~許可検査$に合格した
］
⇒
~RET
`~HTTP~network-or-cache~fetch$から受信された
`~payload本体$ `RFC7230$r の~octet数による~size
— 適用されている`内容~符号法たち$ `RFC7231$r があれば それを~~復号する前の
◎
The size, in octets, received from a HTTP-network-or-cache fetch, of the payload body [RFC7230], prior to removing any applied content-codings [RFC7231], if the resource passes the timing allow check algorithm.
</li>
			<li>
~IF［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET
~payload本体の~octet数による~size
— 適用されている`内容~符号法たち$があれば それを~~復号する前の
◎
The size, in octets, of the payload body prior to removing any applied content-codings if the resource is retrieved from relevant application caches or from local resources.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>

	</dd>
	<dd class="note">注記：
`encodedBodySize^m は、`応答~code$に依存して 0 にもなることもある
— 例えば~HTTP `204$st (No Content), `3XX$st, 等々。
◎
Note
The encodedBodySize may be zero depending on the response code - e.g. HTTP 204 (No Content), 3XX, etc.
</dd>

	<dt>`decodedBodySize@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the decodedBodySize attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
資源は`計時~許可検査$に合格した
］
⇒
~RET
`~HTTP~network-or-cache~fetch$から受信された`~message本体$ † `RFC7230$r の~octet数による~size
— 適用されている`内容~符号法たち$ `RFC7231$r を~~復号した後の
</p>

<p class="trans-note">【†
厳密には，`~payload本体$であろう（それ以前に`転送~符号法$も~~復号される必要がある筈なので）
】</p>

◎
The size, in octets, received from a HTTP-network-or-cache fetch, of the message body [RFC7230], after removing any applied content-codings [RFC7231], if the resource passes the timing allow check algorithm.
</li>
			<li>
~IF［
資源は`局所~cache等$から検索取得された
］
⇒
~RET
~payloadの~size
— 適用されている`内容~符号法たち$があればそれを~~復号した後の
◎
The size, in octets, of the payload after removing any applied content-codings, if the resource is retrieved from relevant application caches or from local resources.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
`PerformanceResourceTiming$I を実装する~UAは、その~supportを開発者が検出できるよう，
`supportedEntryTypes$m 内に `resource^l を含める必要がある。
◎
Note
A user agent implementing PerformanceResourceTiming would need to include "resource" in supportedEntryTypes. This allows developers to detect support for Resource Timing.
</p>

		</section>
		<section id="sec-extensions-performance-interface">
<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>

<p>
~UAは、 `PerformanceResourceTiming$I ~objとして`処理能時列線$ `PERFORMANCE-TIMELINE-2$r に含み得る資源の個数を制限してもヨイ。
この節では、 `Performance$I ~interfaceを拡張して，格納される `PerformanceResourceTiming$I ~objの個数について制御できるようにする。
◎
The user agent MAY choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. This section extends the Performance interface to allow controls over the number of PerformanceResourceTiming objects stored.
</p>

<p>
推奨される `PerformanceResourceTiming$I ~objの最小~個数は 250 である
— ~UAはこれを変更してもヨイが。
この上限は、
`setResourceTimingBufferSize()$m を~callすることにより，変更を要請できる。
◎
The recommended minimum number of PerformanceResourceTiming objects is 250, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>

<p>
各 `~ES大域~環境$は、次のものを持つ：
◎
Each ECMAScript global environment has:
</p>

<dl class="def-list">
	<dt>
`資源~計時~buffer~size上限@
◎
A resource timing buffer size limit＼
</dt>
	<dd>
初期~時は 250 以上【が推奨される】。
◎
which should initially be 250 or greater.
<dd>

	<dt>
`資源~計時~buffer現size@
◎
A resource timing buffer current size＼
</dt>
	<dd>
0 以上の整数。
初期~時は 0 。
◎
which is initially 0.
</dd>

	<dt>
`資源~計時~buffer満杯~event処理待ち~flag@
◎
A resource timing buffer full event pending flag＼
</dt>
	<dd>
初期~時は ~F とする。
◎
which is initially false.
</dd>

	<dt>
`資源~計時~副buffer現size@
◎
A resource timing secondary buffer current size which is initially 0.
</dt>
	<dd class="trans-note">【
`資源~計時~副buffer$を成す~entryの個数を表すが、この訳では，この用語は利用しない。
代わりに，~algoの記述にて等価に表現する（`副buffer内の~entryを移動する$における，真偽値 %移動した ）。
そうした方が簡潔かつ簡明に記述できるので。
】</dd>

	<dt>
`資源~計時~副buffer@
◎
A resource timing secondary buffer＼
</dt>
	<dd>
0 個以上の `PerformanceResourceTiming$I ~objからなる~list。
初期~時は空。
◎
to store PerformanceResourceTiming objects that is initially empty.
</dd>
</dl>

<pre class="idl">
partial interface `Performance$I {
  void `clearResourceTimings()$m;
  void `setResourceTimingBufferSize$m(unsigned long %maxSize);

  attribute `EventHandler$I `onresourcetimingbufferfull$m;
};
</pre>

<p>
`Performance$I ~interfaceは
`HR-TIME-2$r にて定義される。
◎
The Performance interface is defined in [HR-TIME-2].
</p>

<dl class="idl-def">

	<dt>`clearResourceTimings()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The method clearResourceTimings runs the following steps:
</p>
		<ol>
			<li>
`処理能~entry~buffer$から 次を満たす~entryをすべて除去する
⇒
`PerformanceResourceTiming$I ~objである
◎
Remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~SET 0
◎
Set resource timing buffer current size to 0.
</li>
		</ol>
	</dd>

	<dt>`setResourceTimingBufferSize(maxSize)@m</dt>
	<dd>
被呼出時には、次を走らすモノトスル
⇒
`資源~計時~buffer~size上限$ ~SET %maxSize
◎
The setResourceTimingBufferSize method runs the following steps:
• Set resource timing buffer size limit to the maxSize parameter.＼
</dd>
	<dd class="note">注記：
［
%maxSize ~LT `資源~計時~buffer現size$
］であっても，`処理能~entry~buffer$から `PerformanceResourceTiming$I ~objは除去されない。
◎
If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</dd>

	<dt>`onresourcetimingbufferfull@m</dt>
	<dd>
`resourcetimingbufferfull@et
~event用の~event~handler。
【`~buffer満杯~eventを発火する$を見よ。】
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event described below.
</dd>
</dl>

<div class="algorithm">
<p>
`資源~計時~entryを追加でき@
るとは、次が満たされることをいう
⇒
`資源~計時~buffer現size$ ~LT `資源~計時~buffer~size上限$
◎
To check if can add resource timing entry, run the following steps:
• If resource timing buffer current size is smaller than resource timing buffer size limit, return true.
• Return false.
</p>
</div>

<div class="algorithm">
<p>
`処理能~entry~bufferに~entryを追加する@
ときは、所与の
( `処理能~entry~buffer$ %~buffer, `PerformanceResourceTiming$I ~obj %~entry )
に対し，次を走らす：
◎
To add a PerformanceResourceTiming entry into the performance entry buffer, run the following steps:
• Let new entry be the input PerformanceEntry to be added.
</p>

<ol>
	<li>
<p>
~IF［
`資源~計時~entryを追加でき$る
］~AND［
`資源~計時~buffer満杯~event処理待ち~flag$ ~EQ ~F
］：
◎
If can add resource timing entry returns true and resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
%~buffer に %~entry を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~INCBY 1
◎
Increase resource timing buffer current size by 1.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`資源~計時~buffer満杯~event処理待ち~flag$ ~EQ ~F
］：
◎
If resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
`資源~計時~buffer満杯~event処理待ち~flag$ ~SET ~T
◎
Set resource timing buffer full event pending flag to true.
</li>
			<li>
次を走らす`~taskを~queueする$
⇒
`~buffer満杯~eventを発火する$
◎
Queue a task to run fire a buffer full event.
</li>
		</ol>
	</li>
	<li>
`資源~計時~副buffer$に %~entry を付加する
◎
Add new entry to the resource timing secondary buffer.
◎
Increase resource timing secondary buffer current size by 1.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`副buffer内の~entryを移動する@
ときは、次を走らす：
◎
To copy secondary buffer, run the following steps:
</p>

<ol>
	<li>
%移動した ~LET ~F
◎
↓↓</li>
	<li>
<p>
~WHILE［
`資源~計時~副buffer$は空でない
］~AND［
`資源~計時~entryを追加でき$る
］：
◎
While resource timing secondary buffer is not empty and can add resource timing entry returns true, run the following substeps:
</p>
		<ol>
			<li>
%~entry ~LET `資源~計時~副buffer$内の最初の（最も古い） `PerformanceResourceTiming$I ~obj
◎
Let entry be the oldest PerformanceResourceTiming in resource timing secondary buffer.
</li>
			<li>
`処理能~entry~buffer$の末尾に %~entry を追加する
◎
Add entry to the end of performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~INCBY 1
◎
Increment resource timing buffer current size by 1.
</li>
			<li>
`資源~計時~副buffer$から %~entry を除去する
◎
Remove entry from resource timing secondary buffer.
</li>
			<li>
%移動した ~SET ~T
◎
Decrement resource timing secondary buffer current size by 1.
</li>
		</ol>
	</li>
	<li>
~RET %移動した
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~buffer満杯~eventを発火する@
ときは、次を走らす：
◎
To fire a buffer full event, run the following steps:
</p>

<ol>
	<li>
<p>
~WHILE［
`資源~計時~副buffer$は空でない
］：
◎
While resource timing secondary buffer is not empty, run the following substeps:
</p>
		<ol>
			<li>
~IF［
`資源~計時~entryを追加でき$ない
］
⇒
`Performance$I ~objに向けて，名前 `resourcetimingbufferfull$et の`~eventを発火する$
◎
Let number of excess entries before be resource timing secondary buffer current size.
◎
If can add resource timing entry returns false, then fire an event named resourcetimingbufferfull at the Performance object.
</li>
			<li>
%移動した ~LET `副buffer内の~entryを移動する$
◎
Run copy secondary buffer.
</li>
			<li>
~IF［
%移動した ~EQ ~F
］
⇒＃
`資源~計時~副buffer$からすべての~entryを除去する†；
~BREAK
◎
Let number of excess entries after be resource timing secondary buffer current size.
◎
If number of excess entries before is lower than or equals number of excess entries after, then remove all entries from resource timing secondary buffer, set resource timing secondary buffer current size to 0, and abort these steps.
</li>
		</ol>
	</li>
	<li>
`資源~計時~buffer満杯~event処理待ち~flag$ ~SET ~F
◎
Set resource timing buffer full event pending flag to false.
</li>
</ol>

<p class="note">注記：†
移動できなかった~entryは、~bufferから落とされる。
開発者は、 `resourcetimingbufferfull$et ~event用の~event~handler内で［
`clearResourceTimings()$m を~callするか,
（ `setResourceTimingBufferSize()$m を~callして）~bufferが足りるよう拡張するか
］しておくべきである。
◎
Note
This means that if the resourcetimingbufferfull event handler does not add more room in the buffer than it adds resources to it, excess entries will be dropped from the buffer. Developers should make sure that resourcetimingbufferfull event handlers call clearResourceTimings or extend the buffer sufficiently (by calling setResourceTimingBufferSize).
</p>
</div>

		</section>
		<section id="sec-cross-origin-resources">
<h3 title="Cross-origin Resources">4.5. 非同一-生成元~資源</h3>

<p>
`非同一-生成元$資源は、
`PerformanceResourceTiming$I ~objとして
`処理能時列線$に含めるモノトスル。
資源が`計時~許可検査$に失敗した場合、その
`PerformanceResourceTiming$I ~objの属性のうち，次に挙げるものは、 0 にするモノトスル
⇒＃
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m,
`transferSize$m,
`encodedBodySize$m,
`decodedBodySize$m
◎
Cross-origin resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a resource, these attributes of its PerformanceResourceTiming object MUST be set to zero: redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, secureConnectionStart, transferSize, encodedBodySize and decodedBodySize.
</p>

<p>
~server側~appは， `Timing-Allow-Origin$h ~HTTP応答~header返してもヨイ
— 上に挙げた［
`非同一-生成元$の制約から値が 0 にされる属性
］すべてを［
~headerにて指定された文書~生成元（たち）
］に公開するのを，~UAに許容するためとして。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to the cross-origin restrictions previously specified in this section.
</p>

			<section id="sec-timing-allow-origin">
<h4 title="Timing-Allow-Origin Response Header">4.5.1. `Timing-Allow-Origin^h 応答~header</h4>

<p>
`Timing-Allow-Origin@h
~HTTP応答~headerを利用すれば、［［
非同一-生成元の制約に因り 0 にされていた属性
］の値を見ることが許容される生成元（たち）
］を指示する施策を通信できる。
この~headerの値は、次の ABNF `RFC5234$r と
<a href="~RFC7230#section-7">その~list拡張</a>
`RFC7230$r を利用して表現される：
◎
The Timing-Allow-Origin HTTP response header field can be used to communicate a policy indicating origin(s) that are allowed to see values of attributes that would have been zero due to the cross-origin restrictions. The header's value is represented by the following ABNF [RFC5234] (using List Extension, [RFC7230]):
</p>

<pre class="bnf">
Timing-Allow-Origin = 1#( `origin-or-null$P / `wildcard$P )
</pre>

<p>
送信者は、複数個の `Timing-Allow-Origin$h ~headerを生成してもヨイ。
受信者は、複数個の `Timing-Allow-Origin$h ~headerに対しては、それらの~headerの値を順に~commaで区切って連結して， 1 つの~headerに結合してもヨイ。
◎
The sender MAY generate multiple Timing-Allow-Origin header fields. The recipient MAY combine multiple Timing-Allow-Origin header fields by appending each subsequent field value to the combined field value in order, separated by a comma.
</p>

<div class="algorithm">
<p>
`計時~許可検査@
は、所与の資源の計時~情報が`現-文書$と共有し得るかどうかを検査する：
◎
The timing allow check algorithm, which checks whether a resource's timing information can be shared with the current document, is as follows:
</p>

<ol>
	<li>
%~window ~LET 資源の`要請$の`~window$rq
◎
↓</li>
	<li>
%tainted ~LET ~F
◎
Let tainted be false.
</li>
	<li>
~IF［
%~window は`環境~設定群~obj$でない
］
⇒
%tainted ~SET ~T
◎
If the resource's Request's window is not an environment settings object, set tainted to true
</li>
	<li>
%生成元~byte列 ~LET `~ASCII符号化する$( `生成元を直列化する$( `現-文書$の`生成元$doc ) )
◎
↓</li>
	<li>
<p>
資源を`~fetch$するときの~redirect連鎖を成す
~EACH( `要請$ %要請 )
に対し：
◎
For each request in the resource fetch redirection-chain:
</p>
		<ol>
			<li>
~IF［
%tainted ~EQ ~F
］~AND［
( %要請 の`生成元$rq, %~window の`生成元$enV )
は`同一-生成元$でない
］
⇒
%tainted ~SET ~T
◎
If tainted is false and request is cross-origin when compared to the resource's Request's window's origin, set tainted to true.
</li>
			<li>
~IF［
%tainted ~EQ ~T
］~AND［
%要請 に対する応答の `Timing-Allow-Origin$h ~header【が無いか、または在って，その】値~listを成す どの成分も［
`*^l （ `wildcard$P ）または %生成元~byte列
］に一致しない
］
⇒
~RET `失敗した^i
◎
If the Timing-Allow-Origin header value list does not contain a value which is byte-for-byte identical to the serialization of the current document's origin, nor a wildcard ("*"), and tainted is true, return fail.
</li>
		</ol>
	</li>
	<li>
~RET `合格した^i
◎
Return pass.
</li>
</ol>
</div>

<p class="note">注記：
`Timing-Allow-Origin$h ~headerは、~cacheされた応答の一部として到着することもある。
~cache再検証の事例では、
<a href="~RFC7234#section-4.3.4">RFC 7234 に則って</a>，~headerの値は［
再検証~応答，そこに無ければ~cacheされた元の資源
］から来ることもある
◎
Note
The Timing-Allow-Origin header may arrive as part of a cached response. In case of cache revalidation, according to RFC 7234, the header's value may come from the revalidation response, or if not present there, from the original cached resource.
</p>

			</section>
			<section id="sec-iana-considerations">
<h4 title="IANA Considerations">4.5.2. IANA 考慮点</h4>

<p>
この節では、 `Timing-Allow-Origin$h を
<a href="~IETF/rfc3864#section-4.2.2">暫定的な~message~header</a>
として登録する。
◎
This section registers Timing-Allow-Origin as a Provisional Message Header.
</p>

<ul>
	<li>
~header~field名：
`Timing-Allow-Origin^h
◎
Header field name:
Timing-Allow-Origin
</li>
	<li>
適用-可能な~protocol：
http
◎
Applicable protocol:
http
</li>
	<li>
位置付け：
暫定的
◎
Status:
provisional
</li>
	<li>
Author/Change controller：
<a href="https://www.w3.org/">W3C</a>
◎
Author/Change controller:
W3C
</li>
	<li>
仕様~文書：
<a href="#sec-timing-allow-origin">§ `Timing-Allow-Origin^h 応答~header</a>
◎
Specification document:
§ 4.5.1 Timing-Allow-Origin Response Header
</li>
</ul>

			</section>
		</section>
		<section id="sec-process">
<h3 title="Process">4.6. 処理n</h3>

			<section id="processing-model">
<h4 title="Processing Model">4.6.1. 処理~model</h4>

<p>
`PerformanceResourceTiming$I ~interfaceに定義される各種 計時~属性を次の図式に示す。
括弧内の属性は、資源が`非同一-生成元$から`~fetch$されているときは，可用でない。
~UAは、規範的でない時区間を許容するために，各 計時の合間に内部~処理を行ってもヨイ。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis may not be available when fetching cross-origin resources. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure><figcaption>
各種 計時~属性を示す図式（時間は下に向かって進行する）。
括弧内の属性は、資源が`計時~許可検査$に失敗した場合は，可用でなくされ得ることを指示する。
【この訳では、原文の図式（ SVG ）を HTML + CSS による等価な図式に差し替えている。】
◎
Figure 1 This figure illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis indicate that they may not be available if the resource fails the timing allow check algorithm.
</figcaption>

<div id="_time-table">

	<div>
<div style="top:-0.5em">← `startTime$m ／  ( `redirectStart$m )</div>
~redirect
<div style="bottom:-0.5em">← ( `redirectEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← `fetchStart$m</div>
~app~cache
	</div>
	<div>
<div style="top:-0.5em">← ( `domainLookupStart$m )</div>
~DNS
<div style="bottom:-0.5em">← ( `domainLookupEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← ( `connectStart$m )</div>
<div style="top:0.5em">← ( `secureConnectionStart$m )</div>
~TCP
<div style="bottom:-0.5em">← ( `connectEnd$m )</div>
	</div>
	<div style="margin-bottom:0">
<div style="top:-0.5em">← ( `requestStart$m )</div>
要請
	</div>
	<div style="margin-top:0">
<div style="top:-0.5em">← ( `responseStart$m )</div>
応答
<div style="bottom:-0.5em">← `responseEnd$m</div>
	</div>
</div>
【！ timestamp-diagram.svg 】
</figure>

<p>
~NULL でない`~client$rqからの`要請$ %要請 により`~fetch$された
~EACH ( 資源 ) に対し，以下を遂行する：
◎
For each resource whose Request has a non-null client, perform the following steps:
</p>

<ol>
	<li>
<p>
~IF［
資源は
`no-cors^i 施策の下で~fetchされる
非同一-生成元~stylesheetである
］
⇒
~CONTINUE
◎
If the resource is fetched by a cross-origin stylesheet which was fetched with no-cors policy, abort the remaining steps.
</p>

<p class="issue">
この非同一-生成元の除外は、
Fetch registry を介して定義されるべきである：
CSS については、 Fetch の用語, および［
no-CORS CSS 下位資源に対し
何らかの “不透明な要請~flag” のような類の~flagを ~T にすること
］を通して定義される必要がある。
しかる後、 Resource Timing において，資源~fetch~eventを表面化させるために
Fetch registry と~interfaceするべきである。
◎
Above cross-origin exclusion should be defined via Fetch registry: CSS needs to be defined in terms of Fetch and set some kind of "opaque request flag" for no-CORS CSS subresources. In turn, Resource Timing should interface with Fetch registry to surface resource fetch events.
</p>

<p class="note">注記：
上の資源~除外は、~risk下にある
— 現時点では、
<a href="https://wpt.fyi/results/resource-timing/no-entries-for-cross-origin-css-fetched.sub.html?label=experimental">関係する~test</a>
に合格した実装は一つしかないので。
◎
Note
The above resource exclusion is at risk as currently only one implementation passes the related test.
</p>

	</li>
	<li>
~IF［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 は［
<a href="~HEembed#process-the-iframe-attributes">`iframe^e の属性を処理する</a> ／
<a href="~HTMLLS/obsolete.html#process-the-frame-attributes">`frame^e の属性を処理する</a>
］ことにより誘発されたものでない
］
⇒
~RET
◎
If the resource's Request's destination equals to "document", and the Request was not triggered by process the iframe attributes or process the frame attributes, abort the remaining steps.
</li>
	<li>
<p>
`~obj作成@i：
</p>
		<ol>
			<li>
%object ~SET 新たな `PerformanceResourceTiming$I ~obj
◎
↓</li>
			<li>
%object の `entryType$m ~SET `resource^l
◎
Create a new PerformanceResourceTiming object and set entryType to the DOMString resource.
</li>
			<li>
資源の検索取得を~queueする直前に
⇒＃
%object の `startTime$m ~SET `現-時刻$；
%object の `nextHopProtocol$m ~SET 空~文字列
◎
Immediately before the user agent starts to queue the resource for retrieval, record the current time in startTime, and set nextHopProtocol to the empty DOMString.
</li>
			<li>
%object の `initiatorType$m ~SET 資源の起動元
◎
Record the initiator of the resource in initiatorType.
</li>
			<li>
%object の `name$m ~SET 要請した資源の`解決-済み~URL$
◎
Record the resolved URL of the requested resource in name.
</li>
		</ol>
	</li>
	<li>
<p>
`~fetch開始@i
— `~fetching$を開始する直前に：
</p>
		<ol>
			<li>
%fetchStart ~LET `現-時刻$
</li>
			<li>
%object の `fetchStart$m ~SET %fetchStart
</li>
			<li>
次に挙げる %object の属性 ~SET %fetchStart
⇒＃
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
</li>
		</ol>

◎
Fetch start: Immediately before a user agent starts the fetching process, record the current time as fetchStart. Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
	<li>
<p>
`収集~開始@i：
</p>
		<ol>
			<li>
~IF［
~UAは、別の既存の~data, あるいは すでに完了した［
`現-文書$から起動された`~fetch$
］による~dataを再利用することにした
］
⇒
~RET
【その~dataで %object の各~属性を初期化することになると見受けられる】
◎
If the user agent is to reuse the data from another existing or completed fetch initiated from the current document, abort the remaining steps.
</li>
			<li>
<p>
~IF［
現在の［
`閲覧文脈$ ／ ~worker文脈
］に`合致する作動中の~worker$ %worker は在る
`service-workers-1$r
］：
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である
］
⇒
%worker に向けて`名前~fetch_evの~eventを発火する$直前に
⇒
%object の `workerStart$m ~SET `現-時刻$
</li>
					<li>
~ELSE
⇒
%worker を`走らす$直前に
⇒
%object の `workerStart$m ~SET `現-時刻$
</li>
				</ol>
【！ ＊~link先が変？ run a worker ？】
◎
If there is an active worker ([service-workers-1]) matching the current browsing or worker context's, immediately before the user agent runs the worker record the time as workerStart, or if the worker is already available, immediately before the event named fetch is fired at the active worker record the time as workerStart.＼
</li>
			<li>
~ELSE（合致する`~sw登録$は無い）
⇒
%object の `workerStart$m ~SET 0
◎
Otherwise, if there is no matching service worker registration, set workerStart value to zero.
</li>
			<li>
<p>
~IF［
資源は`計時~許可検査$に失敗した
］：
◎
If the resource fails the timing allow check algorithm, the user agent MUST run the following substeps:
</p>
				<ol>
					<li>
~IF［
%要請 の`行先$rq ~EQ `document^l
］
⇒
%object の `workerStart$m ~SET 0
◎
If the resource's Request's destination equals to "document", set workerStart to zero.
</li>
					<li>
次に挙げる %object の属性 ~SET 0
⇒＃
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m
◎
Set redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart and secureConnectionStart to zero.
</li>
					<li>
~GOTO `応答~終止$i
◎
Go to the step labeled response end.
</li>
				</ol>
			</li>
			<li>
次に挙げる %object の属性 ~SET %fetchStart
⇒＃
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
◎
Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
			<li>
~IF［
資源は`局所~cache等$（ `~HTTP~cache$ `RFC7234$r も含む）から~fetchされている
］
⇒
~GOTO `要請~開始$i
◎
If the resource is fetched from the relevant application cache or local resources, including the HTTP cache [RFC7234], go to the step labeled request start.
</li>
			<li>
~IF［
~domain検索は要求されていない
］
⇒
~GOTO `接続-開始$i
◎
↓</li>
			<li>
~domain名~検索を開始する直前に
⇒
%object の `domainLookupStart$m ~SET `現-時刻$
◎
If no domain lookup is required, go to the step labeled connect start. Otherwise, immediately before a user agent starts the domain name lookup, record the time as domainLookupStart.
</li>
			<li>
<p>
~domain名~検索を終えた直後に（~UAは、その前に複数の再試行を要し得る）：
</p>
				<ol>
					<li>
~IF［
検索に成功した
］~OR［
資源は `計時~許可検査$に合格した
］
⇒
%object の `domainLookupEnd$m ~SET `現-時刻$
</li>
					<li>
~IF［
検索に失敗した
］
⇒
~GOTO `最終~記録-$i
</li>
				</ol>
◎
Record the time as domainLookupEnd immediately after the domain name lookup is successfully done. A user agent may need multiple retries before that. If the domain name lookup fails and resource passes the timing allow check record the time as domainLookupEnd and go to the step labeledfinal record.
</li>
		</ol>
	</li>
	<li>
<p>
`接続-開始@i：
</p>
		<ol>
			<li>
~IF［
資源`~fetch$に持続的~transport接続が利用されている
］
⇒
%object の［
`connectStart$m, `connectEnd$m
］ ~SET %object の `domainLookupEnd$m と同じ値
◎
Connect start: If a persistent transport connection is used to fetch the resource, let connectStart and connectEnd be the same value of domainLookupEnd.＼
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
~serverへの接続を起動する直前に
⇒
%object の `connectStart$m ~SET `現-時刻$
</li>
					<li>
<p>
接続の成否が確定した時点で：
</p>
						<ol>
							<li>
~IF［
~serverまたは~proxyへ接続を確立できなかった
］
⇒＃
%object の `connectEnd$m ~SET `現-時刻$；
~GOTO `最終~記録-$i
</li>
							<li>
%object の `connectEnd$m ~SET `現-時刻$（~UAは、接続を確立するために複数回の再試行を要し得るが，成功した接続の時刻印のみを反映するべきである）
</li>
							<li>
%object の `nextHopProtocol$m ~SET 接続に利用されている~ALPN~ID
</li>
						</ol>
					</li>
				</ol>
◎
Otherwise, record the time as connectStart immediately before initiating a successful connection to the server and record the time as connectEnd immediately after the successful connection to the server or proxy is established. A user agent may need multiple retries to establish a successful connection and should reflect the timestamps for the successful connection only. Once connection is established set the value of nextHopProtocol to the ALPN ID used by the connection. If a connection can not be established, record the time up to the connection failure as connectEnd and go to the step labeled final record.
</li>
			<li>
~IF［
~secure~transportが利用されている
］
⇒
接続を~secureにする~handshake処理-の直前に
⇒
%object の `secureConnectionStart$m ~SET `現-時刻$
◎
The user agent MUST set the secureConnectionStart attribute as follows:
◎
When a secure transport is used, the user agent MUST record the time as secureConnectionStart immediately before the handshake process to secure the connection.
</li>
			<li>
~ELSE
⇒
%object の `secureConnectionStart$m ~SET 0
◎
When a secure transport is not used, the user agent MUST set the value of secureConnectionStart to 0.
</li>
		</ol>
	</li>
	<li>
<p>
`要請~開始@i
⇒
資源~用に要請の送信†を開始する直前に
（†要請を送信するために複数回の再試行を要した場合は、最後に試行したときの）
⇒
%object の `requestStart$m ~SET `現-時刻$
◎
Request start: Immediately before a user agent starts sending the request for the resource, record the current time as requestStart. If a user agent needed multiple retries to send the request, record the current time of the last attempt.
</p>

<p class="note">注記：
~network~protocolは、［
接続の確立, ~secureな接続の確立, 要請の送信
］を逐次的な方式で遂行しないこともある。
したがって開発者は、これらの値が常に特定0の順序になると期待するべきでない。
【そうであっても、この~algo自体は，記された順に進行するものと解釈するべきであろう — さもなければ ~GOTO などの~logicがきちんと定義されなくなるので。】
◎
Network protocols may not perform the connection establishment, secure connection establishment and request sending in a sequential manner. Therefore, developers should not expect these values to always be in a particular order.
</p>
	</li>
	<li>
`応答~開始@i
⇒
応答の最初の~byteを受信した直後に
⇒
%object の `responseStart$m ~SET `現-時刻$
◎
Record the time as responseStart immediately after the user agent receives the first byte of the response.
</li>
	<li>
<p>
`応答~終止@i：
</p>
		<ol>
			<li>
<p>
~IF［
要請の送信-, または応答~全体の受信-に失敗したため，接続を~openし直す必要がある
］
⇒
~GOTO `接続-開始$i
◎
Response end: Record the time as responseEnd immediately after receiving the last byte of the response.
↓
◎
Return to the step labeled connect start if the user agent fails to send the request or receive the entire response, and needs to reopen the connection.
</p>

<p class="example">
例えば，`持続的~接続$ `RFC7230$r が可能化されているときは、まず最初に，要請を送信するための~open接続の再利用を（その接続は`非同期に~close$され得るが）試行してヨイ。
そのような場合、［
`connectStart$m,
`connectEnd$m,
`requestStart$m
］は，~openし直した接続において収集された計時~情報を表現するベキである。
◎
When persistent connection [RFC7230] is enabled, a user agent may first try to re-use an open connect to send the request while the connection can be asynchronously closed. In such case, connectStart, connectEnd and requestStart SHOULD represent timing information collected over the re-open connection.
</p>
			</li>
			<li>
応答の最後の~byteを受信した直後に
⇒
%object の `responseEnd$m ~SET `現-時刻$
◎
↑</li>
			<li>
次に挙げる %object の属性 ~SET 各~属性の定義に従う値
— これらは、`計時~許可検査$の~subjectになる
⇒＃
`transferSize$m,
`encodedBodySize$m,
`decodedBodySize$m
◎
Set the value of transferSize, encodedBodySize, decodedBodySize to corresponding values, subject to timing allow check algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
`最終~記録-@i：
</p>
		<ol>
			<li>
~IF［
%object の `responseEnd$m はまだ設定されていない
］
⇒
%object の `responseEnd$m ~SET `現-時刻$
</li>
			<li>
%object の `duration$m ~SET
( %object の `responseEnd$m ) − ( %object の `startTime$m )
</li>
		</ol>
◎
Final record: If responseEnd is not set, set it to the current time. Record the difference between responseEnd and startTime in duration.
</li>
	<li>
<p>
~IF［
資源を~fetchした結果は`~redirect等$になった
］：
◎
If the fetched resource results in an HTTP redirect or equivalent, then
</p>
		<ol>
			<li>
<p>
~IF［
現在の資源は`計時~許可検査$に失敗した†
］
⇒＃
%object の `redirectStart$m ~SET 0；
%object の `redirectEnd$m ~SET 0
◎
If the current resource fails the timing allow check algorithm, set redirectStart and redirectEnd to 0.＼
</p>
<p class="trans-note">【†
現在の資源（~redirect先の資源ではない）への要請に限り、計時~許可検査を行うものと見受けられる。
】</p>
			</li>
			<li>
<p>
~ELSE：
◎
↑↓Then, return to the step labeled Fetch start with the redirected resource.
</p>
				<ol>
					<li>
~IF［
%object の `redirectStart$m の値はまだ設定されていない
］
⇒
%object の `redirectStart$m ~SET %fetchStart
◎
If the value of redirectStart is not set, let it be the value of fetchStart.
</li>
					<li>
%object の `redirectEnd$m ~SET %object の `responseEnd$m の値
◎
Let redirectEnd be the value of responseEnd.
</li>
					<li>
次に挙げるもの以外の %object のすべての属性 ~SET 0
⇒＃
`startTime$m,
`redirectStart$m,
`redirectEnd$m,
`initiatorType$m
◎
Set all the attributes in the PerformanceResourceTiming object to 0 except startTime, redirectStart, redirectEnd, and initiatorType.
</li>
				</ol>
			</li>
			<li>
資源 ~SET ~redirect先の資源
◎
↓</li>
			<li>
~GOTO `~fetch開始$i
◎
Return to the step labeled Fetch start with the redirected resource.
</li>
		</ol>
	</li>
	<li id="dfn-step-final-queue">
`処理能~entryを~queueする$( %object )
◎
Queue the PerformanceResourceTiming object.
</li>
	<li>
`処理能~entry~bufferに~entryを追加する$( %要請 の`~client$rqの`大域~obj$の`処理能~entry~buffer$, %object )
◎
Add the PerformanceResourceTiming object to the Request's client's global object's performance entry buffer.
</li>
</ol>

<p class="issue">
この仕様は、`最終~記録-$i 段, その次の段を［
資源の `load^et ~eventが生じる前, 後のどちらに走らすべきか
］を指定していない。
関係する論点は、次の課題 #82 を見よ。
◎
This specification does not specify whether steps 20 and 21 should run before or after the load event of the resource—see issue 82 for related discussion.
</p>

<div class="issue">
<p>
<a href="https://github.com/w3c/resource-timing/issues/82">課題 #82</a>：
`処理能~entry~buffer$に~entryがいつ追加されるかを明確化する。
◎
Issue 82: Clarify when entry is added to performance entry buffer Clarification|needs tests|requires Fetch integration
</p>

<p>
論点：
<a href="https://www.w3.org/2016/11/30-webperf-minutes.html">https://www.w3.org/2016/11/30-webperf-minutes.html</a>
◎
Discussion: https://www.w3.org/2016/11/30-webperf-minutes.html
</p>

<p>
背景：<a href="https://github.com/w3c/resource-timing/issues/55">課題 #55</a>。
<a href="https://github.com/w3c/resource-timing/pull/79">#79</a> にて
各~browser間での実装の相違についての注記を追加した。
理想的には、一貫した実装に収束することを目指すべきである：
◎
Background: #55. In #79 we added a note to flag the implementation differences across browsers. Ideally, we should aim to converge on a consistent implementation:
</p>
<ul>
	<li>
［
~entryは `load^et ~eventの前, 後どちらで可用にされるか
］について、既存の各~実装が［
どこで／どう
］相違するか識別するための，何らかの相互運用~testがあるとありがたい。
◎
It would be great to get some interop tests to identify where/how existing implementations differ on whether the entry is made available before or after the load event.
</li>
	<li>
開発者が `onload^et の中で~entryを~queryすることに依拠する回数について、現実世界の~~測定があると，とても助かる
◎
Real-world telemetry on how often developers rely on querying entry from within onload would, also, be very helpful.
</li>
</ul>
</div>

			</section>
			<section id="sec-monotonic-clock">
<h4 title="Monotonic Clock">4.6.2. 単調増加~時計</h4>
<p>
計時~属性の値は、資源`~fetch$の間，計時~属性が~system時計~調整により~skewされないように、単調増加するモノトスル。
時系列順に記録された２つの計時~属性の差分は決して負にならないモノトスル。
文書の下位資源も含めた，すべての資源において、~UAは根元の文書~naviの開始時点の~system時計を記録し，後続の計時~属性は、~naviの開始からの経過時間を測定する単調増加~時計の下で定義されるモノトスル。
◎
The value of the timing attributes MUST monotonically increase to ensure timing attributes are not skewed by adjustments to the system clock while fetching the resource. The difference between any two chronologically recorded timing attributes MUST never be negative. For all resources, including subdocument resources, the user agent MUST record the system clock at the beginning of the root document navigation and define subsequent timing attributes in terms of a monotonic clock measuring time elapsed from the beginning of the navigation.
</p>

			</section>
		</section>
		<section id="sec-privacy-security">
<h3 title="Privacy and Security">4.7. ~privacyと~security</h3>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I ~interfaceは、資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、既定では`同一-生成元$ 施策が施行される。
その結果，一部の属性は、
<a href="#sec-cross-origin-resources">§ 非同一-生成元~資源</a>
にて述べたように， 0 に設定される。
資源を供する側は、［
`Timing-Allow-Origin$h ~HTTP応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定する
］ことにより，資源~用のすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in § 4.5 Cross-origin Resources. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

<p>
統計的指紋収集（ `statistical fingerprinting^en ）は、［
悪意的な~web~siteが、第三者主体の~web~site内の資源に対する~cacheの~hit／~missの時機を測定することにより，利用者がその~siteを訪問したかどうかを決定し得る
］点で，~privacyの懸念になる。
`PerformanceResourceTiming$I ~interfaceは，文書~内の資源の計時~情報を供するが、
<a href="#sec-cross-origin-resources">非同一-生成元の制約</a>があるので，この~privacyの懸念を［
今日すでにある，資源に対する `load^et ~eventから時機を測定して~cacheの~hit／~missを決定する~~手法
］より悪化させるものにはならない。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the cross-origin restrictions prevent making this privacy concern any worse than it is today using the load event on resources to measure timing to determine cache hits and misses.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に貢献された次の方々に謝意を：
</p>

<p lang="en-x-a0">
Thanks to
  Anne Van Kesteren,
  Annie Sullivan,
  Arvind Jain,
  Boris Zbarsky,
  Darin Fisher,
  Jason Weber,
  Jonas Sicking,
  James Simonsen,
  Karen Anderson,
  Kyle Scholz,
  Nic Jansma,
  Philippe Le Hegaret,
  Sigbjørn Vik,
  Steve Souders,
  Todd Reifsteck,
  Tony Gentilcore and
  William Chan
for their contributions to this work.
</p>

	</section>

</main></div>
