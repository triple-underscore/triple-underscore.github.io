<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing Level 2 — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
#_time-table {
	background: var(--bg-color-3);
	padding: 0.5em;
	font-size: smaller;
}
#_time-table > div {
	border: thin solid var(--pale-color);
	position: relative;
	padding: 0.5em;
	height: 3em;
	width: 10em;
	margin: 0.5em 0;
}
#_time-table > div > div {
	position: absolute;
	left: 11.5em;
	min-width: 20em;
	white-space: nowrap;
}

#_time-table > ._gap {
	display: block;
	width: 11em;
	padding: 0;
	margin: 0;
	text-align: center;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key.replace(/!.*/, '');
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2022-04-13
trans_update:2022-04-19
source_checked:210408
page_state_key:TIMING
original_url:https://w3c.github.io/resource-timing/
	abbr_url:RESOURCE-TIMING
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
copyright:2021,permissive
trans_1st_pub:2013-01-23

●●class_map
h:header
e:element
a:attr
et:event-type
P:production
v:value
css:css

●●tag_map
I:code
m:code
c:code
h:code
e:code
a:code
et:code
P:code
css:code
v:code
i:i

●●original_id_map

dom-performanceresourcetiming-requestend:dfn-requestend

●●mdn_urls
dfn-timing-allow-origin:HTTP/Headers/Timing-Allow-Origin

dom-performanceresourcetiming:API/PerformanceResourceTiming
dom-performance-clearresourcetimings:API/Performance/clearResourceTimings
dom-performance-setresourcetimingbuffersize:API/Performance/setResourceTimingBufferSize
dom-performance-onresourcetimingbufferfull:API/Performance/onresourcetimingbufferfull
dom-performanceresourcetiming-connectend:API/PerformanceResourceTiming/connectEnd
dom-performanceresourcetiming-connectstart:API/PerformanceResourceTiming/connectStart
dom-performanceresourcetiming-decodedbodysize:API/PerformanceResourceTiming/decodedBodySize
dom-performanceresourcetiming-domainlookupend:API/PerformanceResourceTiming/domainLookupEnd
dom-performanceresourcetiming-domainlookupstart:API/PerformanceResourceTiming/domainLookupStart
dom-performanceresourcetiming-encodedbodysize:API/PerformanceResourceTiming/encodedBodySize
dom-performanceresourcetiming-fetchstart:API/PerformanceResourceTiming/fetchStart
dom-performanceresourcetiming-initiatortype:API/PerformanceResourceTiming/initiatorType
dom-performanceresourcetiming-nexthopprotocol:API/PerformanceResourceTiming/nextHopProtocol
dom-performanceresourcetiming-redirectend:API/PerformanceResourceTiming/redirectEnd
dom-performanceresourcetiming-redirectstart:API/PerformanceResourceTiming/redirectStart
dom-performanceresourcetiming-requestend:API/PerformanceResourceTiming/requestEnd
dom-performanceresourcetiming-requeststart:API/PerformanceResourceTiming/requestStart
dom-performanceresourcetiming-responseend:API/PerformanceResourceTiming/responseEnd
dom-performanceresourcetiming-responsestart:API/PerformanceResourceTiming/responseStart
dom-performanceresourcetiming-secureconnectionstart:API/PerformanceResourceTiming/secureConnectionStart
dom-performanceresourcetiming-tojson:API/PerformanceResourceTiming/toJSON
dom-performanceresourcetiming-transfersize:API/PerformanceResourceTiming/transferSize
dom-performanceresourcetiming-workerstart:API/PerformanceResourceTiming/workerStart

_resourcetimingbufferfull:API/Performance/resourcetimingbufferfull_event

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default

DOMString:~WEBIDL#idl-DOMString
ByteString:~WEBIDL#idl-ByteString
undefined:~WEBIDL#idl-undefined
object:~WEBIDL#idl-object
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp

I.PerformanceResourceTiming:#dom-performanceresourcetiming
I.XMLHttpRequest:~XHR#xmlhttprequest
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	~TR/hr-time-2/#domhighrestimestamp
I.Performance:~HRTIME#dom-performance
I.PerformanceEntry:~TIMELINE#dom-performanceentry
I.PerformanceObserver:~TIMELINE#dom-performanceobserver
I.EventHandler:~WAPI#eventhandler
	I.Document
I.Worker:~WORKERS#worker
I.EventSource:~HTMLsse#eventsource

m.toJSON:#dom-performanceresourcetiming-tojson
m.initiatorType:#dom-performanceresourcetiming-initiatortype
m.nextHopProtocol:#dom-performanceresourcetiming-nexthopprotocol
m.workerStart:#dom-performanceresourcetiming-workerstart
m.redirectStart:#dom-performanceresourcetiming-redirectstart
m.redirectEnd:#dom-performanceresourcetiming-redirectend
m.fetchStart:#dom-performanceresourcetiming-fetchstart
m.domainLookupStart:#dom-performanceresourcetiming-domainlookupstart
m.domainLookupEnd:#dom-performanceresourcetiming-domainlookupend
m.connectStart:#dom-performanceresourcetiming-connectstart
m.connectEnd:#dom-performanceresourcetiming-connectend
m.secureConnectionStart:#dom-performanceresourcetiming-secureconnectionstart
m.requestStart:#dom-performanceresourcetiming-requeststart
m.requestEnd:#dom-performanceresourcetiming-requestend
m.responseStart:#dom-performanceresourcetiming-responsestart
m.responseEnd:#dom-performanceresourcetiming-responseend
m.transferSize:#dom-performanceresourcetiming-transfersize
m.encodedBodySize:#dom-performanceresourcetiming-encodedbodysize
m.decodedBodySize:#dom-performanceresourcetiming-decodedbodysize

m.clearResourceTimings:#dom-performance-clearresourcetimings
m.setResourceTimingBufferSize:#dom-performance-setresourcetimingbuffersize
m.onresourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull

m.name:#dfn-name
m.entryType:#dfn-entrytype
m.startTime:#dfn-starttime
m.duration:#dfn-duration

m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes

m.fetch:~FETCH#dom-global-fetch
m.sendBeacon:~BEACON#dom-navigator-sendbeacon

	●code 他

e.a:~HEtextlevel#the-a-element
e.audio:~HEmedia#the-audio-element
	e.audio:~HEmedia#audio
e.frame:~HTMLobs#frame
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.link:~HEmetadata#the-link-element
e.object:~HEembed#the-object-element
e.track:~HEtrack#the-track-element
e.video:~HEmedia#the-video-element
	~HEmedia#video
e.script:~HEscripting#the-script-element
	e.script:~HEscripting#script
e.image:~SVGembedded#elementdef-image
	#ImageElement
e.svg:~SVGstruct#elementdef-svg
	e.svg:~SVG11/struct.html#SVGElement

a.poster:~HEmedia#attr-video-poster
a.srcset:~HEimages#attr-img-srcset
a.download:~HTMLlinks#attr-hyperlink-download
a.ping:~HTMLlinks#ping
a.type:~HEinput#attr-input-type
a.src!media:~HEmedia#attr-media-src
a.src!track:~HEtrack#attr-track-src
a.src!img:~HEimages#attr-img-src
a.src!iframe:~HEembed#attr-iframe-src


et.resourcetimingbufferfull:#_resourcetimingbufferfull

h.Timing-Allow-Origin:#dfn-timing-allow-origin
	h.Origin:~RFCx/rfc6454#section-4

P.origin-or-null:~FETCH#origin-header
P.wildcard:~FETCH#http-new-header-syntax

v.stylesheet:~HTMLlinks#link-type-stylesheet
v.url():~CSSVAL#funcdef-url
v.image:~HEinput#attr-input-type-image-keyword
	st.Image:~HEinput#image-button-state-(type=image)

	●用語

資源~計時~bufferの~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~bufferの現-~size:#dfn-resource-timing-buffer-current-size
資源~計時~buffer満杯~eventは処理待ちか:#dfn-resource-timing-buffer-full-event-pending-flag
資源~計時~副-~buffer:#dfn-resource-timing-secondary-buffer
資源~計時~副-~bufferの現-~size:#dfn-resource-timing-secondary-buffer-current-size

処理能~entry~bufferに~entryを追加する:#dfn-add-a-performanceresourcetiming-entry
資源~計時~entryを追加でき:#dfn-can-add-resource-timing-entry
~buffer満杯~eventを発火する:#dfn-fire-a-buffer-full-event
副-~buffer内の~entryを移動する:#dfn-copy-secondary-buffer

処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer
処理能~entry~buffer~map:~TIMELINE#dfn-performance-entry-buffer-map
処理能~時列線:~TIMELINE#performance-timeline
	#sec-performance-timeline
	Performance:~TR/navigation-timing-2/#performance
処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
処理能~時列線~task源:~TIMELINE#dfn-performance-timeline-task-source

~fetch時刻印を変換する:#dfn-convert-fetch-timestamp
資源~計時を~markする:#dfn-mark-resource-timing
資源~計時~entryを設定しておく:#dfn-setup-the-resource-timing-entry

pT.起動元~種別:#dfn-initiator-type
pT.要請~URL:#dfn-requested-url
pT.~cache~mode:#dfn-cache-mode
pT.計時情報:#dfn-timing-info

	●用語（外部

要請:~FETCH#concept-request
~navi要請:~FETCH#navigation-request
rq.~client:~FETCH#concept-request-client

~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~HTTP~fetch:~FETCH#concept-http-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~TAO検査:~FETCH#concept-tao-check
	§ ~TAO検査:~FETCH#tao-check

cT.折衝した~ALPN~protocol~ID:~FETCH#connection-timing-info-alpn-negotiated-protocol
cT.接続~終了~時刻:~FETCH#connection-timing-info-connection-end-time
cT.接続~開始~時刻:~FETCH#connection-timing-info-connection-start-time
cT.~domain検索~終了~時刻:~FETCH#connection-timing-info-domain-lookup-end-time
cT.~domain検索~開始~時刻:~FETCH#connection-timing-info-domain-lookup-start-time
cT.~secure接続~開始~時刻:~FETCH#connection-timing-info-secure-connection-start-time

~fetch計時情報:~FETCH#fetch-timing-info
fT.終了~時刻:~FETCH#fetch-timing-info-end-time
fT.最終-~network要請~開始~時刻:~FETCH#fetch-timing-info-final-network-request-start-time
fT.最終-~network応答~開始~時刻:~FETCH#fetch-timing-info-final-network-response-start-time
fT.最終-~sw開始~時刻:~FETCH#fetch-timing-info-final-service-worker-start-time
fT.最終-接続~計時情報:~FETCH#fetch-timing-info-final-connection-timing-info
fT.~redirect後からの開始~時刻:~FETCH#fetch-timing-info-post-redirect-start-time
fT.~redirect終了~時刻:~FETCH#fetch-timing-info-redirect-end-time
fT.~redirect開始~時刻:~FETCH#fetch-timing-info-redirect-start-time
fT.開始~時刻:~FETCH#fetch-timing-info-start-time
fT.符号化された本体の~size:~FETCH#fetch-timing-info-encoded-body-size
fT.復号した本体の~size:~FETCH#fetch-timing-info-decoded-body-size

接続~計時情報を記録する:~FETCH#record-connection-timing-info

~ES大域~環境:~WEBIDLjs#es-environment
既定の~toJSON手続き:~WEBIDLjs#default-tojson-steps

	data: URI:~RFCx/rfc2397
同一-生成元:~ORIGIN#same-origin
	生成元:~ORIGIN#concept-origin

~eventを発火する:~DOM4#concept-event-fire

作動中の~worker:~SW1#dfn-active-worker

細かさを抑えた相対的な高分解能~時刻:~HRTIME#dfn-relative-high-resolution-coarse-time

大域~obj:~WAPI#concept-settings-object-global
enV.大域~obj:~WAPI#concept-settings-object-global
~Realm:~WAPI#concept-global-object-realm
~taskを~queueする:~WAPI#queue-a-task
~realm:~WAPI#concept-global-object-realm
関連な大域~obj:~WAPI#concept-relevant-global
~script:~WAPI#concept-script
古典~script:~WAPI#classic-script
~module~script:~WAPI#module-script


同型に復号する:~INFRA#isomorphic-decode
文字列:~INFRA#string

コレ:~WEBIDL#this

~header節:~HTTPinfra#header-section

	-:#dfn-dom
	-:#dfn-getting
	-:#dfn-setting
	-:#dfn-javascript
	-:#dom



●●words_table1
BEACON:beacon-ja.html

●●words_table

	●fetch／HTTP/network
TLS:
DNS:
TCP:
QUIC:
ALPN:
検索:lookup::~
端点間:end-to-end::~::エンドツーエンド
符号法:coding::~::コーディング
network-or-cache::::ネットワーク-or-キャッシュ
受信:receiving::~
受信者:recipient::~
	送信し直:resend
送信者:sender::~
事前条件:precondition::~
再検証-:revalidate::~
再検証:revalidation::~

hit::::ヒット
miss::::ミス
到着-:arrive:~

	●計時
高分解能:high resolution::~
計時情報:timing info::~
最終-:final:~
	細かさを抑えた:coarse
時機:timing::~
時区間:interval::~
	かかった時間:time it takes to
	費やされ:takes／spent
	処理能~時列線:Performance Timeline
	開始-時:right at the start

	●処理一般
満杯:full::~
処理待ち:pending:~
同型:isomorphic::~
mark::::マーク
現-:current:~
副-:secondary:~

	総:total
	定数:constant number

	%~buffer:buffer
	%~entry:entry
	%計時情報:timingInfo
	%要請された~URL:requestedURL
	%起動元~種別:initiatorType
	%時刻印:ts
	%大域~obj:global
	%~cache~mode:cacheMode
	%移動したか:-

	●保安
統計的:statistical:~
mask::::マスク
TAO:

	●仕様
包括的:comprehensive:~
様相:picture:~
暫定的:provisional:~
上限:limit:~
位置付け:status:~
benchmark::::ベンチマーク
流儀:fashion:~
	必要性:need:~
	~~手段:instrumentation
	仕立て上げ:be modified to
	足りる:sufficiently
	しておく:make sure
	方法:-
	図式:graph
	内訳
	とする:suppose
	更なる情報:for more info

	●未分類
内包-:include:~
知覚-:perceive:~
ES:ECMAScript
品質:quality:~
	正準-形が同じになる:canonical URL
古典:classic::~
toJSON:

	文字列$:DOMString
	文字列$:DOMStrring

	-:underline
	可能
	各段階
	移動できなかった~entryは:does not add more room in the buffer than it adds resources to it
	-:excess
	number of excess entries
	後続-:follow
	対象にする:included
	〜内の~entryを移動する:copy
	無けれ:if not present
	時点
	個数:number of／:how many
	最初の:oldest
	見込まれ:might
	末尾:the end
	有無:presence
	何箇所か:places


●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik. W3C. 21 November 2019. W3C Recommendation. URL: https://www.w3.org/TR/hr-time-2/ 
[hr-time-3]
    High Resolution Time. Yoav Weiss. W3C. 28 January 2022. W3C Working Draft. URL: https://www.w3.org/TR/hr-time-3/ 
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Yoav Weiss; Noam Rosenthal. W3C. 10 March 2022. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/ 
[PERFORMANCE-TIMELINE-2]
    Performance Timeline. Nicolas Pena Moreno. W3C. 2 December 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/performance-timeline/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC2397]
    The "data" URL scheme. L. Masinter. IETF. August 1998. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc2397 
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc5234 
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 

●●ref_informative

[BEACON]
    Beacon. Ilya Grigorik; Alois Reitbauer; Arvind Jain; Jatinder Mann. W3C. 13 April 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/beacon/ 
[CSS-VALUES]
    CSS Values and Units Module Level 3. Tab Atkins Jr.; Elika Etemad. W3C. 6 June 2019. W3C Candidate Recommendation. URL: https://www.w3.org/TR/css-values-3/ 
[css-values-4]
    CSS Values and Units Module Level 4. Tab Atkins Jr.; Elika Etemad. W3C. 16 December 2021. W3C Working Draft. URL: https://www.w3.org/TR/css-values-4/ 
[performance-timeline]
    Performance Timeline. Nicolas Pena Moreno. W3C. 2 December 2021. W3C Candidate Recommendation. URL: https://www.w3.org/TR/performance-timeline/ 
[SVG11]
    Scalable Vector Graphics (SVG) 1.1 (Second Edition). Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. W3C. 16 August 2011. W3C Recommendation. URL: https://www.w3.org/TR/SVG11/ 
[SVG2]
    Scalable Vector Graphics (SVG) 2. Amelia Bellamy-Royds; Bogdan Brinza; Chris Lilley; Dirk Schulze; David Storey; Eric Willigers. W3C. 4 October 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/SVG2/ 
[XHR]
    XMLHttpRequest Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://xhr.spec.whatwg.org/


●●trans_metadata
<p>
~THIS_PAGEは、
~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Resource Timing Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/resource-timing-2/
公表履歴
	https://www.w3.org/standards/history/resource-timing-2
編集者草案
	https://w3c.github.io/resource-timing/
commit 履歴
	https://github.com/w3c/resource-timing/commits/
編集
	<a href="https://blog.yoav.ws/">Yoav Weiss</a> (Google)
	<a href="mailto:noam.j.rosenthal@gmail.com">Noam Rosenthal</a> (Invited Expert) 
前任編集者
	<a href="mailto:igrigorik@gmail.com">Ilya Grigorik</a> (Google) (Until January 2021)
	<a href="mailto:toddreif@microsoft.com">Todd Reifsteck</a> (Microsoft Corp.) (Until January 2021)
	<a href="mailto:arvind@google.com">Arvind Jain</a> (Google Inc.) (Until December 2014)
	<a href="mailto:jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until February 2014)
	Zhiheng Wang (Google Inc.) (Until July 2012)
	Anderson Quach (Microsoft Corp.) (Until March 2011)
フィードバック
	<a href="https://github.com/w3c/resource-timing/">GitHub w3c/resource-timing</a> (<a href="https://github.com/w3c/resource-timing/pulls/">pull requests</a>, <a href="https://github.com/w3c/resource-timing/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/resource-timing/issues/">open issues</a>)
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>

ブラウザサポート
	https://caniuse.com/resource-timing
公表者
	<a href="https://www.w3.org/groups/wg/webperf">Web Performance WG</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1>リソースの計時 — Resource Timing Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT
<p>
この仕様は、
~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは編集者草案の公な複製です…
【以下、この他の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が知覚し得る待時間は Web ~appにとり重要な品質~benchmarkである。
~JSに基づく仕組みは、
~appにおける利用者~側の待時間を測定するための包括的な~~手段を供せるが、
端点間の待時間については，多くの事例で，完全な様相を供せない。
この仕様は、
`PerformanceResourceTiming$I ~interfaceを導入する。
それは、
~JSにより，文書~上の資源に関係する完全な計時~情報を収集するための仕組みである。
`NAVIGATION-TIMING-2$r は、
この仕様を拡張して，~naviに関わる追加的な計時~情報を供する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. This document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document. Navigation Timing 2 [NAVIGATION-TIMING-2] extends this specification to provide additional timing information associated with a navigation.
</p>

<div class="example">
<p>
例えば、
次のような~JSで，
資源~fetchにかかった時間を単純に測定しようと試みた場合：
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %start = new Date().getTime();
   var %image1 = new Image();
   var %resourceTiming = function() {
       var %now = new Date().getTime();
       var %latency = %now - %start;
       alert("End to end resource fetch: " + %latency);
   };

   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源~fetchに要した時間は測定できるが、
その内訳の各段階に費やされた時間は測定できない。
更に、
~markupにより記述された資源に費やされた時間を，
この~scriptで測定することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に取組むため、
この文書は `PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、
~JSによる［
~client側~appにおける待時間の完全な測定を可能にする仕組み
］を供する。
この~interfaceにより、
前の例は，利用者が知覚する資源の読込n時間を測定-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、
~markupにより定義されたものまで含め，
~page内のそれぞれの資源~fetchに要した時間の~~長さを計算する。
この例は、
~pageが <samp>https://www.w3.org</samp> の下に~hostされていると見做している。
その気になれば
`PerformanceResourceTiming$I ~interfaceを利用して、
資源~fetchingの各段階ごとに要した時間も測定できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on https://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %image1 = new Image();
   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var %resourceList = window.performance.getEntriesByType("resource");
    for (%i = 0; %i &lt; %resourceList.length; i++) {
       if (%resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( %resourceList[i].responseEnd  - %resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>

	<section id="conformance">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
<a href="~W3Ccommon#conformance">~W3C日本語訳 共通~page</a>
に移譲。
】</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
この節の内容の和訳は、
省略する。
】
◎
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo.
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME-2]. For example, the start of navigation of the document occurs at time 0.
◎
Note

This definition of time is based on the High Resolution Time specification [HR-TIME-2] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING-2], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>
<p>
この訳の，~algoや定義の記述に利用されている各種記号
（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, 等々）
の意味や定義の詳細は、
~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
	</section>
	<section id="sec-resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>

		<section id="introduction-0">
<h3 title="Introduction">4.1. 序論</h3>

~INFORMATIVE

<div class="p">
<p>
`PerformanceResourceTiming$I ~interfaceは、
`~fetch$される <a href="~FETCH#http-scheme">http(s)</a> 資源の計時~測定を手助けする。
例えば、
次に挙げるものに利用できる：
</p>
<ul>
	<li>
`XMLHttpRequest$I ~obj `XHR$r
</li>
	<li>
`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v を伴う `link$e
］などの~HTML要素 `HTML$r
</li>
	<li>
`svg$e などの~SVG要素 `SVG11$r
</li>
	<li>
`EventSource$I
</li>
</ul>
◎
The PerformanceResourceTiming interface facilitates timing measurement of fetched http(s) resources. For example, this interface is available for XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed and link with the link type of stylesheet, SVG elements [SVG11] such as svg, and EventSource.
</div>

		</section>
		<section id="resources-included-in-the-performanceresourcetiming-interface">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源</h3>

~INFORMATIVE

<p>
~NULL でない`~client$rqからの`要請$により`~fetch$される すべての資源
— ~HTTP~cache【あるいは~sw】から検索取得されたものも含む —
は、
`~fetching$の一部として除外されない限り，
`PerformanceResourceTiming$I ~objとして`~client$rqの`大域~obj$の`処理能~時列線$に含まれる。
~fetchにより起動されたが後で中止された資源は
（例：~network~errorなどに因り）、
その［
開始, 終了
］の計時を伴って，`処理能~時列線$に含まれる。
◎
Resource Requests fetched by a non-null client are included as PerformanceResourceTiming objects in the client's global object's Performance Timeline, unless excluded from the timeline as part of the fetching process. Resources that are retrieved from HTTP cache are included as PerformanceResourceTiming objects in the Performance Timeline. Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) are included as PerformanceResourceTiming objects in the Performance Timeline, with their start and end timing.
</p>

<div class="example">
<p>
例えば：
◎
Examples:
</p>
<ul>
	<li>
複数の~HTML `img$e 要素の `src^a 属性に，正準-形が同じになる~URL（ `the same canonical URL^en 
【すなわち，同じ資源を指す~URL】
）が利用されている場合、［
最初に資源`~fetch$を起動した `img^e 要素
］の方が［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになろう。
~UAは、
2 個目以降の `img^e 要素の~URLに対しては、
再~要請することなく，
最初に起動された方による既存の~downloadを利用すると見込まれるので。
この場合，`処理能~時列線$には、
最初に起動された `img^e 要素に対する資源`~fetch$による結果のみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element would be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
~HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、
元々の資源`~fetch$のみならず，新たな~URLへの`~fetch$も［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
~HTML `iframe$e 要素の~markupに `src^a 属性が指定されていない場合、
~UAは `about:blank^c 文書を読込むことになる。
後で~scriptから `src^a 属性が動的に変更された場合、
その新たな~URLの資源へ`~fetch$されることになる。
この場合、新たな~URLによる`~fetch$のみが［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
正準-形が同じになる~URL用に，複数の `XMLHttpRequest$I が生成された場合、
いずれの資源`~fetch$も［
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる
］ことになる
— 後続する資源~fetch要請には、
先行する要請による~downloadを再利用できないので。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
~page内の~HTML `iframe$e 要素に内包された文書により要請される下位資源は、
親~文書の`処理能~時列線$ではなく，内包された文書の`処理能~時列線$に含められる。
`iframe^e に対し`処理能~時列線$に含められるのは、
その `src^a 属性により要請される資源に限られる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素が~sourceとして
<a href="~RFCx/rfc2397.html">data: URI</a> `RFC2397$r
を持つ場合、
その資源は，`処理能~時列線$には含められない。
data: URI は埋込d~dataであり、
`~fetch$を要さないものと定義されているので。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. By definition data: URI contains embedded data and does not require a fetch.
</li>
	<li>
資源`~fetch$が~network~error（ ~DNS, ~TCP, ~TLS ~errorなど）に因り中止された場合、
その~fetchは，
`PerformanceResourceTiming$I ~objとして
— ［
`startTime$m, `fetchStart$m, `duration$m, `responseEnd$m
］に限り，設定された上で —
`処理能~時列線$に含められることになる。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch will be included as a PerformanceResourceTiming object in the Performance Timeline with only the startTime, fetchStart, duration and responseEnd set.
</li>
	<li>
資源`~fetch$が事前条件
（例： 混在内容（ `mixed content^en ）, ~CORS制約, ~CSP施策, など）
に失敗したことにより中止された場合、
その資源については，`処理能~時列線$には含められないことになる。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
</ul>
</div>

		</section>
		<section id="sec-performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute `DOMString$ `initiatorType$m;
  readonly attribute `ByteString$ `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$ `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$ `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$ `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$ `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$ `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$ `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$ `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$ `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$ `responseEnd$m;
  readonly attribute `unsigned long long$ `transferSize$m;
  readonly attribute `unsigned long long$ `encodedBodySize$m;
  readonly attribute `unsigned long long$ `decodedBodySize$m;
  [`Default$] `object$ `toJSON$m();
};
</pre>

<p>
各 `PerformanceResourceTiming$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`起動元~種別@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString initiator type.
</li>
	<li>
`要請~URL@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString requested URL.
</li>
	<li>
`~cache~mode@pT
⇒
`文字列$
— 次のいずれか
⇒＃
空~文字列 ／
`local^l ／
`validated^l
◎
A PerformanceResourceTiming has an associated DOMString cache mode (the empty string, "local", or "validated").
</li>
	<li>
`計時情報@pT
⇒
`~fetch計時情報$
◎
A PerformanceResourceTiming has an associated fetch timing info timing info.
</li>
</ul>

<p id="dfn-performanceentry">
`PerformanceResourceTiming$I ~interfaceは、
`処理能~時列線$に関与し，
次に挙げる `PerformanceEntry$I ~interfaceの属性を拡張する：
◎
The PerformanceResourceTiming interface participates in the Performance Timeline and extends the following attributes of the PerformanceEntry interface:
</p>
<ul>
	<li class="algo">
`name@m
取得子~手続きは
⇒
~RET コレの`要請~URL$pT
◎
The name getter steps are to return this's requested URL.
</li>
	<li class="algo">
`entryType@m
取得子~手続きは
⇒
~RET `文字列$ `resource^l
◎
The entryType getter steps are to return the DOMString "resource".
</li>
	<li class="algo">
<p>
`startTime@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The startTime getter steps are to convert fetch timestamp for this's timing info's start time and this's relevant global object.
</p>

<p class="note">注記：
`startTime$m は、
~fetchの開始-時, ~redirectより前に測定される。
<a href="~FETCH#fetching">~fetching</a>を見よ。
◎
startTime is measured right at the start of the fetch, before any redirects. See fetching.
</p>

	</li>
	<li class="algo">
`duration@m
取得子~手続きは
⇒
~RET コレの`計時情報$pTの`終了~時刻$fT ~MINUS コレの`計時情報$pTの`開始~時刻$fT
◎
The duration getter steps are to return this's timing info's end time minus this's timing info's start time.
</li>
</ul>

<div class="algo">
<p>
`toJSON()@m
は、
`既定の~toJSON手続き$ `WEBIDL$r を走らす。
◎
When toJSON is called, run [WEBIDL]'s default toJSON operation.
</p>
</div>

<div class="algo">
<p>
`initiatorType@m
取得子~手続きは
⇒
~RET コレの`起動元~種別$pT
◎
initiatorType getter steps are to return the initiator type for this.
</p>

<div class="note">
<p>注記：
`initiatorType$m は、
次に挙げるいずれかの値を返す：
◎
Note

initiatorType returns one of the following values:
</p>
<ul>
	<li>
`navigation^l
⇒
当の要請は、
`~navi要請$である場合
◎
"navigation", if the request is a navigation request;
</li>
	<li>
`css^l
⇒
当の要請は、
ある~CSS `url()$v 指令 `CSS-VALUES$r
— `@import url()^css や `background: url()^css など —
を処理した結果である場合
◎
"css", if the request is a result of processing a CSS url() directive such as @import url() or background: url(); [CSS-VALUES]
</li>
	<li>
<p>
`script^l
⇒
当の要請は、
`~script$
（ `古典~script$ ／ `~module~script$ ／ `Worker$I ）
を読込むもの【！読込んだ結果】である場合
</p>

<p class="trans-note">【
~module~scriptには、
~CSS~module~scriptも含まれる。
字義通り解釈するなら、
これも `css^l ではなく `script^l を返すことになる。
】</p>
◎
"script", if the request is a result of loading any script (a classic script, a module script, or a Worker).
</li>
	<li>
`xmlhttprequest^l
⇒
当の要請は、
`XMLHttpRequest$I を処理した結果である場合
◎
"xmlhttprequest", if the request is a result of processing an XMLHttpRequest;
</li>
	<li>
`fetch^l
⇒
当の要請は、
`fetch()$m ~methodを処理した結果である場合
◎
"fetch", if the request is the result of processing the fetch() method;
</li>
	<li>
`beacon^l
⇒
当の要請は、
`sendBeacon()$m ~method `BEACON$r を処理した結果である場合
◎
"beacon", if the request is the result of processing the sendBeacon() method; [BEACON]
</li>
	<li>
`video^l
⇒
当の要請は、
`video$e 要素の［
`poster$a ／ `src!media$a
］属性を処理した結果である場合
◎
"video", if the request is the result of processing the video element's poster or src.
</li>
	<li>
`audio^l
⇒
当の要請は、
`audio$e 要素の `src!media$a 属性を処理した結果である場合
◎
"audio", if the request is the result of processing the audio element's src.
</li>
	<li>
`track^l
⇒
当の要請は、
`track$e 要素の `src!track$a 属性を処理した結果である場合
◎
"track", if the request is the result of processing the track element's src.
</li>
	<li>
`img^l
⇒
当の要請は、
`img$e 要素の［
`src!img$a ／ `srcset$a
］属性を処理した結果である場合
◎
"img", if the request is the result of processing the img element's src or srcset.
</li>
	<li>
`image^l
⇒
当の要請は、
`image$e 要素 `SVG2$r を処理した結果である場合
◎
"image", if the request is the result of processing the image element. [SVG2]
</li>
	<li>
`input^l
⇒
当の要請は、
`input$e 要素のうち［
`type$a 属性が `image$v 状態にあるもの
］を処理した結果である場合
◎
"input", if the request is the result of processing an input element of type image.
</li>
	<li>
`a^l
⇒
当の要請は、
`a$e 要素の［
`download$a ／ `ping$a
］属性を処理した結果である場合
◎
"a", if the request is the result of processing an a element's download or ping.
</li>
	<li>
`iframe^l
⇒
当の要請は、
`iframe$e の `src!iframe$a 属性を処理した結果である場合
◎
"iframe", if the request is the result of processing an iframe's src.
</li>
	<li>
`frame^l
⇒
当の要請は、
`frame$e を読込むもの【！読込んだ結果】である場合
◎
"frame", if the request is the result of loading a frame.
</li>
	<li>
`other^l
⇒
上に挙げた どの条件にも合致しない場合
◎
"other", if none of the above conditions match.
</li>
</ul>
</div>

<p class="note">注記：
`initiatorType^m の設定は、
資源~計時~entryが報告される，異なる何箇所かで行われる。
— `~fetching$ `FETCH$r など。
◎
Note

The setting of initiatorType is done at the different places where a resource timing entry is reported, such as the fetch standard.
</p>
</div>

<div class="algo">
<p>
`workerStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-~sw開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The workerStart getter steps are to convert fetch timestamp for this's timing info's final service worker start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`redirectStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`~redirect開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The redirectStart getter steps are to convert fetch timestamp for this's timing info's redirect start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~redirect~fetch$を見よ。
◎
See HTTP-redirect fetch for more info.
</p>
</div>

<div class="algo">
<p>
`redirectEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`~redirect終了~時刻$fT, コレに`関連な大域~obj$ )
◎
The redirectEnd getter steps are to convert fetch timestamp for this's timing info's redirect end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~redirect~fetch$を見よ。
◎
See HTTP-redirect fetch for more info.
</p>
</div>

<div class="algo">
<p>
`fetchStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`~redirect後からの開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The fetchStart getter steps are to convert fetch timestamp for this's timing info's post-redirect start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`domainLookupStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`~domain検索~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The domainLookupStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's domain lookup start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`domainLookupEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`~domain検索~終了~時刻$cT, コレに`関連な大域~obj$ )
◎
The domainLookupEnd getter steps are to convert fetch timestamp for this's timing info's final connection timing info's domain lookup end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`connectStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`接続~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The connectStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's connection start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`connectEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`接続~終了~時刻$cT, コレに`関連な大域~obj$ )
◎
The connectEnd getter steps are to convert fetch timestamp for this's timing info's final connection timing info's connection end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`secureConnectionStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`~secure接続~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The secureConnectionStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's secure connection start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`nextHopProtocol@m
取得子~手続きは
⇒
~RET `同型に復号する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`折衝した~ALPN~protocol~ID$cT )
◎
The nextHopProtocol getter steps are to isomorphic decode this's timing info's final connection timing info's ALPN negotiated protocol.＼
</p>

<p class="note">
更なる情報は、
`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`requestStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-~network要請~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The requestStart getter steps are to convert fetch timestamp for this's timing info's final network-request start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`responseStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-~network応答~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The responseStart getter steps are to convert fetch timestamp for this's timing info's final network-response start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、
`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`responseEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`終了~時刻$fT, コレに`関連な大域~obj$ )
◎
The responseEnd getter steps are to convert fetch timestamp for this's timing info's end time and the relevant global object for this.＼
</p>
</div>

<div class="algo">
<p>
`encodedBodySize@m
取得子~手続きは
⇒
~RET コレの`計時情報$pTの`符号化された本体の~size$fT
◎
The encodedBodySize getter steps are to return this's timing info's encoded body size.
</p>
</div>

<div class="algo">
<p>
`decodedBodySize@m
取得子~手続きは
⇒
~RET コレの`計時情報$pTの`復号した本体の~size$fT
◎
The decodedBodySize getter steps are to return this's timing info's decoded body size.
</p>
</div>

<div class="algo">
<p>
`transferSize@m
取得子~手続きは：
◎
The transferSize getter steps are to perform the following steps:
</p>
<ol>
	<li>
<p>
~RET コレの`~cache~mode$pT に応じて
⇒＃
`local^l ならば 0 ／
`validated^l ならば 300 ／
~ELSE_ コレの`計時情報$pTの`符号化された本体の~size$fT ~PLUS 300 †
◎
If this's cache mode is "local", then return 0.
◎
If this's cache mode is "validated", then return 300.
◎
Return this's timing info's encoded body size plus 300.
</p>

<p class="note">注記†：
本体の~sizeに加算される定数 300 は、
~HTTP~messageの`~header節$の総~byte~sizeを置換するものであり，
ある種の~cookieの有無が公開されないようにするためである。
<a href="https://github.com/w3c/resource-timing/issues/238">課題 #238</a>
を見よ。
◎
Note

The constant number added to transferSize replaces exposing the total byte size of the HTTP headers, as that may expose the presence of certain cookies. See this issue.
</p>
	</li>
</ol>
</div>

<p class="note">注記：
`PerformanceResourceTiming$I を実装する~UAは、
その~supportを開発者が検出できるよう，
`supportedEntryTypes$m 内に `resource^l を含める必要がある。
◎
Note

A user agent implementing PerformanceResourceTiming would need to include "resource" in supportedEntryTypes. This allows developers to detect support for Resource Timing.
</p>

		</section>
		<section id="sec-extensions-performance-interface">
<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>

<p>
~UAは、
`PerformanceResourceTiming$I ~objとして`処理能~時列線$ `PERFORMANCE-TIMELINE-2$r に含み得る資源の個数を制限してもヨイ。
この節では、
`Performance$I ~interfaceを拡張して，
格納される `PerformanceResourceTiming$I ~objの個数について制御できるようにする。
◎
The user agent MAY choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. This section extends the Performance interface to allow controls over the number of PerformanceResourceTiming objects stored.
</p>

<p>
推奨される `PerformanceResourceTiming$I ~objの最小~個数は 250 である
— ~UAはこれを変更してもヨイが。
この上限は、
`setResourceTimingBufferSize()$m を~callすることにより，変更を要請できる。
◎
The recommended minimum number of PerformanceResourceTiming objects is 250, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>

<p>
各 `~ES大域~環境$は、
次に挙げるものを持つ：
◎
Each ECMAScript global environment has:
</p>

<dl class="def-list">
	<dt>
`資源~計時~bufferの~size上限@
◎
A resource timing buffer size limit＼
</dt>
	<dd>
初期~時は 250 以上【が推奨される】。
◎
which should initially be 250 or greater.
<dd>

	<dt>
`資源~計時~bufferの現-~size@
◎
A resource timing buffer current size＼
</dt>
	<dd>
0 以上の整数。
初期~時は 0 。
◎
which is initially 0.
</dd>

	<dt>
`資源~計時~buffer満杯~eventは処理待ちか@
◎
A resource timing buffer full event pending flag＼
</dt>
	<dd>
真偽値
— 初期~時は ~F 。
◎
which is initially false.
</dd>

	<dt>
`資源~計時~副-~bufferの現-~size@
◎
A resource timing secondary buffer current size which is initially 0.
</dt>
	<dd class="trans-note">【
`資源~計時~副-~buffer$を成す~entryの個数を表すが、
この訳では，この用語は利用しない。
代わりに，~algoの記述にて等価に表現する
（`副-~buffer内の~entryを移動する$における，真偽値 %移動したか ）。
そうした方が簡潔かつ簡明に記述できるので。
】</dd>

	<dt>
`資源~計時~副-~buffer@
◎
A resource timing secondary buffer＼
</dt>
	<dd>
0 個以上の `PerformanceResourceTiming$I ~objからなる~list。
初期~時は空。
◎
to store PerformanceResourceTiming objects that is initially empty.
</dd>
</dl>

<pre class="idl">
partial interface `Performance$I {
  `undefined$ `clearResourceTimings()$m;
  `undefined$ `setResourceTimingBufferSize$m(`unsigned long$ %maxSize);

  attribute `EventHandler$I `onresourcetimingbufferfull$m;
};
</pre>

<p>
`Performance$I ~interfaceは
`HR-TIME-2$r にて定義される。
◎
The Performance interface is defined in [HR-TIME-2].
</p>

<div class="algo">
<p>
`clearResourceTimings()@m
~method手続きは：
◎
The method clearResourceTimings runs the following steps:
</p>
<ol>
	<li>
`処理能~entry~buffer$から 次を満たす~entryをすべて除去する
⇒
`PerformanceResourceTiming$I ~objである
◎
Remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
	<li>
`資源~計時~bufferの現-~size$ ~SET 0
◎
Set resource timing buffer current size to 0.
</li>
</ol>
</div>

<div class="algo">
<p>
`setResourceTimingBufferSize(maxSize)@m
~method手続きは
⇒
`資源~計時~bufferの~size上限$ ~SET %maxSize
◎
The setResourceTimingBufferSize method runs the following steps:
• Set resource timing buffer size limit to the maxSize parameter.＼
</p>

<p class="note">注記：
［
%maxSize ~LT `資源~計時~bufferの現-~size$
］であっても，`処理能~entry~buffer$から `PerformanceResourceTiming$I ~objは除去されない。
◎
If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</p>
</div>

<p>
`onresourcetimingbufferfull@m
は、
`resourcetimingbufferfull@et
~event用の~event~handlerである。
【`~buffer満杯~eventを発火する$を見よ。】
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event described below.
</p>

<div class="algo">
<p>
`資源~計時~entryを追加でき@
るとは、
次が満たされることをいう
⇒
`資源~計時~bufferの現-~size$ ~LT `資源~計時~bufferの~size上限$
◎
To check if can add resource timing entry, run the following steps:
• If resource timing buffer current size is smaller than resource timing buffer size limit, return true.
• Return false.
</p>
</div>

<div class="algo">
<p>
`処理能~entry~bufferに~entryを追加する@
ときは、
所与の
( `処理能~entry~buffer$ %~buffer, `PerformanceResourceTiming$I ~obj %~entry )
に対し，次を走らす：
◎
To add a PerformanceResourceTiming entry into the performance entry buffer, run the following steps:
• Let new entry be the input PerformanceEntry to be added.
</p>

<ol>
	<li>
<p>
~IF［
`資源~計時~entryを追加でき$る
］~AND［
`資源~計時~buffer満杯~eventは処理待ちか$ ~EQ ~F
］：
◎
If can add resource timing entry returns true and resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
%~buffer に %~entry を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~bufferの現-~size$ ~INCBY 1
◎
Increase resource timing buffer current size by 1.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`資源~計時~buffer満杯~eventは処理待ちか$ ~EQ ~F
］：
◎
If resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
`資源~計時~buffer満杯~eventは処理待ちか$ ~SET ~T
◎
Set resource timing buffer full event pending flag to true.
</li>
			<li>
`処理能~時列線~task源$から，次を走らす`~taskを~queueする$
⇒
`~buffer満杯~eventを発火する$
◎
Queue a task on the performance timeline task source to run fire a buffer full event.
</li>
		</ol>
	</li>
	<li>
`資源~計時~副-~buffer$に %~entry を付加する
◎
Add new entry to the resource timing secondary buffer.
◎
Increase resource timing secondary buffer current size by 1.
</li>
</ol>
</div>

<div class="algo">
<p>
`副-~buffer内の~entryを移動する@
ときは、
次を走らす：
◎
To copy secondary buffer, run the following steps:
</p>

<ol>
	<li>
%移動したか ~LET ~F
◎
↓↓</li>
	<li>
<p>
~WHILE［
`資源~計時~副-~buffer$は空でない
］~AND［
`資源~計時~entryを追加でき$る
］：
◎
While resource timing secondary buffer is not empty and can add resource timing entry returns true, run the following substeps:
</p>
		<ol>
			<li>
%~entry ~LET `資源~計時~副-~buffer$内の最初の（最も古い） `PerformanceResourceTiming$I ~obj
◎
Let entry be the oldest PerformanceResourceTiming in resource timing secondary buffer.
</li>
			<li>
`処理能~entry~buffer$の末尾に %~entry を追加する
◎
Add entry to the end of performance entry buffer.
</li>
			<li>
`資源~計時~bufferの現-~size$ ~INCBY 1
◎
Increment resource timing buffer current size by 1.
</li>
			<li>
`資源~計時~副-~buffer$から %~entry を除去する
◎
Remove entry from resource timing secondary buffer.
</li>
			<li>
%移動したか ~SET ~T
◎
Decrement resource timing secondary buffer current size by 1.
</li>
		</ol>
	</li>
	<li>
~RET %移動したか
</li>
</ol>
</div>

<div class="algo">
<p>
`~buffer満杯~eventを発火する@
ときは、
次を走らす：
◎
To fire a buffer full event, run the following steps:
</p>

<ol>
	<li>
<p>
~WHILE［
`資源~計時~副-~buffer$は空でない
］：
◎
While resource timing secondary buffer is not empty, run the following substeps:
</p>
		<ol>
			<li>
~IF［
`資源~計時~entryを追加でき$ない
］
⇒
`~eventを発火する$( `Performance$I ~obj, `resourcetimingbufferfull$et )
◎
Let number of excess entries before be resource timing secondary buffer current size.
◎
If can add resource timing entry returns false, then fire an event named resourcetimingbufferfull at the Performance object.
</li>
			<li>
%移動したか ~LET `副-~buffer内の~entryを移動する$
◎
Run copy secondary buffer.
</li>
			<li>
~IF［
%移動したか ~EQ ~F
］
⇒＃
`資源~計時~副-~buffer$からすべての~entryを除去する†；
~BREAK
◎
Let number of excess entries after be resource timing secondary buffer current size.
◎
If number of excess entries before is lower than or equals number of excess entries after, then remove all entries from resource timing secondary buffer, set resource timing secondary buffer current size to 0, and abort these steps.
</li>
		</ol>
	</li>
	<li>
`資源~計時~buffer満杯~eventは処理待ちか$ ~SET ~F
◎
Set resource timing buffer full event pending flag to false.
</li>
</ol>

<p class="note">注記：†
移動できなかった~entryは、
~bufferから落とされる。
開発者は、
`resourcetimingbufferfull$et ~event用の~event~handler内で，
次のいずれかをしておくべきである
⇒＃
`clearResourceTimings()$m を~callする／
`setResourceTimingBufferSize()$m を~callして，~bufferが足りるよう拡張する
◎
Note

This means that if the resourcetimingbufferfull event handler does not add more room in the buffer than it adds resources to it, excess entries will be dropped from the buffer. Developers should make sure that resourcetimingbufferfull event handlers call clearResourceTimings or extend the buffer sufficiently (by calling setResourceTimingBufferSize).
</p>
</div>

		</section>
		<section id="sec-cross-origin-resources">
<h3 title="Cross-origin Resources">4.5. 非同一-生成元~資源</h3>

<div class="note">
<p>注記：
`FETCH$r にて詳細されるとおり、
非同一-生成元~資源への要請は，
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる。
非同一-生成元~資源に対し`~TAO検査$に失敗した場合、
<a href="~FETCH#create-an-opaque-timing-info">当の~entryは不透明になる</a>。
そのような~entryのほとんどの属性は、
他では公開されない非同一-生成元~dataが漏洩するのを防止するため，~maskされる
— すなわち，不透明な~entryの属性のうち：
◎
Note

As detailed in Fetch, requests for cross-origin resources are included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a cross-origin resource, the entry will be an opaque entry. Such entries have most of their attributes masked in order to prevent leaking cross-origin data that isn't otherwise exposed. So, for an opaque entry,＼
</p>
<ul>
	<li>
次に挙げるものは、
0 に設定される
⇒＃
`redirectStart$m,
`redirectEnd$m,
`workerStart$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m,
`transferSize$m,
`encodedBodySize$m,
`decodedBodySize$m
◎
the following attributes will be set to zero: redirectStart, redirectEnd, workerStart, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, secureConnectionStart, transferSize, encodedBodySize, and decodedBodySize.＼
</li>
	<li>
`nextHopProtocol$m は、
空~文字列に設定される。
◎
Further, the {{PerformanceResourceTiming/nextHopProtocol} attribute will be set to the empty string.
</li>
</ul>
</div>

<p>
~server側~appは、
`Timing-Allow-Origin$h ~HTTP応答~header返してもヨイ
— 上に挙げた［
非同一-生成元に対する制約に因り，値が 0 にされる属性
］すべてを［
~header内に指定された文書~生成元（たち）に公開する
］ことを~UAに許容するためとして。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to those cross-origin restrictions.
</p>

			<section id="sec-timing-allow-origin">
<h4 title="Timing-Allow-Origin Response Header">4.5.1. `Timing-Allow-Origin^h 応答~header</h4>

<p>
`Timing-Allow-Origin@h
~HTTP応答~headerを利用すれば、［［
非同一-生成元に対する制約に因り 0 にされていた属性
］の値を見ることが許容される生成元（たち）
］を指示する施策を通信できる。
この~headerの値は、
次の ABNF `RFC5234$r と
<a href="~HTTPsem#abnf.extension">その~list拡張</a>【！~RFC7230#section-7】
`RFC7230$r を利用して表現される：
◎
The Timing-Allow-Origin HTTP response header field can be used to communicate a policy indicating origin(s) that are allowed to see values of attributes that would have been zero due to the cross-origin restrictions. The header's value is represented by the following ABNF [RFC5234] (using List Extension, [RFC7230]):
</p>

<pre class="bnf">
Timing-Allow-Origin = 1#( `origin-or-null$P / `wildcard$P )
</pre>

<p>
送信者は、
複数個の `Timing-Allow-Origin$h ~headerを生成してもヨイ。
受信者は、
複数個の `Timing-Allow-Origin$h ~headerに対しては，
それらの~headerの値を順に~commaで分離して連結して 1 個の~headerに結合してもヨイ。
◎
The sender MAY generate multiple Timing-Allow-Origin header fields. The recipient MAY combine multiple Timing-Allow-Origin header fields by appending each subsequent field value to the combined field value in order, separated by a comma.
</p>

<p>
`Timing-Allow-Origin$h
~headerは、
`~TAO検査$にて処理され，各 属性は それに則って算出される。
◎
The Timing-Allow-Origin headers are processed in FETCH to compute the attributes accordingly.
</p>

<p class="note">注記：
`Timing-Allow-Origin$h ~headerは、
~cacheされた応答の一部として到着することもある。
~cache再検証の事例では、
<a href="~HTTPcache#freshening.responses">~HTTP~cache法に則って</a>
【！~RFC7234#section-4.3.4】，~headerの値は［
再検証~応答，そこに無ければ~cacheされた元の資源
］から来ることもある
◎
Note

The Timing-Allow-Origin header may arrive as part of a cached response. In case of cache revalidation, according to RFC 7234, the header's value may come from the revalidation response, or if not present there, from the original cached resource.
</p>

			</section>
			<section id="sec-iana-considerations">
<h4 title="IANA Considerations">4.5.2. IANA 考慮点</h4>

<p>
この節では、
`Timing-Allow-Origin$h を
<a href="~RFCx/rfc3864.html#section-4.2.2">暫定的な~message~header</a>
として登録する。
◎
This section registers Timing-Allow-Origin as a Provisional Message Header.
</p>

<ul>
	<li>
~header~field名：
`Timing-Allow-Origin^h
◎
Header field name:
Timing-Allow-Origin
</li>
	<li>
適用-可能な~protocol：
http
◎
Applicable protocol:
http
</li>
	<li>
位置付け：
暫定的
◎
Status:
provisional
</li>
	<li>
Author/Change controller：
<a href="https://www.w3.org/">W3C</a>
◎
Author/Change controller:
W3C
</li>
	<li>
仕様~文書：
<a href="#sec-timing-allow-origin">§ `Timing-Allow-Origin^h 応答~header</a>
◎
Specification document:
§ 4.5.1 Timing-Allow-Origin Response Header
</li>
</ul>

			</section>
		</section>
		<section id="attribute-descriptions">
<h3 title="Resource Timing Attributes">4.6. 資源~計時~属性</h3>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I ~interfaceに定義される各種 計時~属性を次の図式に示す。
括弧内の属性は、
資源が非同一-生成元から`~fetch$されているときは可用でない。
~UAは、
規範的でない時区間を許容するために，
各 計時の合間に内部~処理を行ってもヨイ。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis may not be available when fetching cross-origin resources. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure><figcaption>
各種 計時~属性を示す図式（時間は下に向かって進行する）。
括弧内の属性は、
資源が`~TAO検査$に失敗した場合は，可用でなくされ得ることを指示する。
◎
Figure 1 This figure illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis indicate that they may not be available if the resource fails the timing allow check algorithm.
</figcaption>

<div id="_time-table">
	<div>
<div style="top:-0.5em">← `startTime$m ／  ( `redirectStart$m )</div>
~redirect
<div style="bottom:-0.5em">← ( `redirectEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← ( `workerStart$m )</div>
<div style="top:0.5em">← ( `fetchStart$m )</div>
~sw
	</div>
	<div>
~HTTP~cache
	</div>
	<span class="_gap">⋮</span>
	<div>
<div style="top:-0.5em">← ( `domainLookupStart$m )</div>
~DNS
<div style="bottom:-0.5em">← ( `domainLookupEnd$m )</div>
	</div>
	<span class="_gap">⋮</span>
	<div>
<div style="top:-0.5em">← ( `connectStart$m )</div>
~TCP†
	</div>
	<div>
<div style="top:-0.5em">← ( `secureConnectionStart$m )</div>
~TLS†
<div style="bottom:-0.5em">← ( `connectEnd$m )</div>
	</div>
	<span class="_gap">⋮</span>
	<div>
<div style="top:-0.5em">← ( `requestStart$m ) ††</div>
要請
	</div>
	<div>
<div style="top:-0.5em">← ( `responseStart$m )</div>
応答
<div style="bottom:-0.5em">← `responseEnd$m</div>
	</div>

<p>†
~QUIC の場合、それが~TCPと~TLSに取って代わる
— その場合の `secureConnectionStart$m は、
~QUICの開始-時になる。
</p>

<p>††
`connectEnd$m より前に生じることもある
（例： `TCP fast open^en ）
</p>

◎
Resource Timing attributes
</div>
【！ timestamp-diagram.svg 】

<p class="trans-note">【
この訳では、
原文の図式（ ~SVG ）を~HTMLと~CSSによる等価な図式に差し替えている。
】</p>
</figure>

		</section>
		<section id="marking-resource-timing">
<h3 title="Creating a resource timing entry">4.7. 資源~計時~entryの作成-法</h3>

<div class="algo">
<p>
`資源~計時を~markする@
ときは、所与の
( `~fetch計時情報$ %計時情報, `文字列$ %要請された~URL, `文字列$ %起動元~種別, `大域~obj$enV %大域~obj, `文字列$ %~cache~mode )
に対し：
◎
To mark resource timing given a fetch timing info timingInfo, a DOMString requestedURL, a DOMString initiatorType a global object global, and a string cacheMode, perform the following steps:
</p>
<ol>
	<li>
%~entry ~LET %大域~obj の`~Realm$に属する新たな `PerformanceResourceTiming$I ~obj
◎
Create a PerformanceResourceTiming object entry in global's realm.
</li>
	<li>
`資源~計時~entryを設定しておく$( %~entry, %起動元~種別, %要請された~URL, %計時情報, %~cache~mode )
◎
Setup the resource timing entry for entry, given initiatorType, requestedURL, timingInfo, and cacheMode.
</li>
	<li id="dfn-step-final-queue">
`処理能~entryを~queueする$( %~entry )
◎
Queue entry.
</li>
	<li>
`処理能~entry~bufferに~entryを追加する$( %~entry, %大域~obj 
【の`処理能~entry~buffer~map$[ `resource^l ] 】
の`処理能~entry~buffer$ )
◎
Add entry to global's performance entry buffer.
</li>
</ol>
</div>

<div class="algo">
<p>
`資源~計時~entryを設定しておく@
ときは、所与の
⇒＃
`PerformanceResourceTiming$I %~entry,
`文字列$ %起動元~種別,
`文字列$ %要請された~URL,
`~fetch計時情報$ %計時情報,
`文字列$ %~cache~mode
◎終
に対し，次を遂行する
⇒
◎
To setup the resource timing entry for PerformanceResourceTiming entry given DOMString initiatorType, DOMString requestedURL, fetch timing info timingInfo, and a DOMString cacheMode, perform the following steps:
</p>
<ol>
	<li>
~Assert：
%~cache~mode ~IN { 空~文字列, `local^l }
◎
Assert that cacheMode is the empty string or "local".
</li>
	<li>
%~entry の
⇒＃
`起動元~種別$pT ~SET %起動元~種別,
`要請~URL$pT ~SET %要請された~URL,
`計時情報$pT ~SET %計時情報,
`~cache~mode$pT ~SET %~cache~mode
◎
Set entry's initiator type to initiatorType.
◎
Set entry's requested URL to requestedURL.
◎
Set entry's timing info to timingInfo.
◎
Set entry's cache mode to cacheMode.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetch時刻印を変換する@
ときは、所与の
( `DOMHighResTimeStamp$I %時刻印, `大域~obj$enV %大域~obj )
に対し，次を行う
⇒
~RET ［
%時刻印 ~EQ 0 ならば 0 ／
~ELSE_ 次の結果
］
⇒
`細かさを抑えた相対的な高分解能~時刻$( %時刻印, %大域~obj )
◎
To convert fetch timestamp given DOMHighResTimeStamp ts and global object global, do the following:
• If ts is zero, return zero.
• Otherwise, return the relative high resolution coarse time given ts and global.
</p>
</div>

		</section>
		<section id="sec-security">
<h3 title="Security Considerations">4.8. ~securityの考慮点</h3>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I ~interfaceは、
資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、
既定では`同一-生成元$ 施策が施行される。
その結果，一部の属性は、
`~HTTP~fetch$にて述べられるとおり，
0 に設定される。
資源を供する側は、［
`Timing-Allow-Origin$h ~HTTP応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定する
］ことにより，資源~用のすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in HTTP fetch. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

		</section>
		<section id="sec-privacy">
<h3 title="Privacy Considerations">4.9. ~privacyの考慮点</h3>

~INFORMATIVE

<p>
悪意的な~web~siteは、
第三者主体~web~site内の資源に対する~cache［
~hit／~miss
］の時機を測定することにより，
利用者が第三者主体~siteを訪問したかどうかを決定し得る
— そのような~privacyの懸念は、
統計的~指紋収集（ `statistical fingerprinting^en ）と称される。
`PerformanceResourceTiming$I ~interfaceは，
文書~内の資源の計時~情報を供するが、
すでに，資源に対する `load^et ~eventにより
— 制限された流儀ではあるが —
時機を測定して~cache［
~hit／~miss
］を決定できることに加え、
`~HTTP~fetch$における非同一-生成元に対する制約により，
追加的な情報の漏洩eは防止される。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the load event on resources can already measure timing to determine cache hits and misses in a limited fashion, and the cross-origin restrictions in HTTP Fetch prevent the leakage of any additional information.
</p>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に貢献された次の方々に謝意を：
</p>

<p lang="en">
Thanks to

Anne Van Kesteren,
Annie Sullivan,
Arvind Jain,
Boris Zbarsky,
Darin Fisher,
Jason Weber,
Jonas Sicking,
James Simonsen,
Karen Anderson,
Kyle Scholz,
Nic Jansma,
Philippe Le Hegaret,
Sigbjørn Vik,
Steve Souders,
Todd Reifsteck,
Tony Gentilcore and
William Chan

for their contributions to this work.
</p>

	</section>
</main></div>
