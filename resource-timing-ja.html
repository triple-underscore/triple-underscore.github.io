<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing Level 2 — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
#_time-table {
	background: #eef1fc;
	padding: 0.5em;
	font-size: smaller;
}
#_time-table > div {
	border: thin solid gray;
	position: relative;
	padding: 0.5em;
	height: 3em;
	width: 10em;
	margin: 1em 0;
}
#_time-table > div > div {
	position: absolute;
	left: 11.5em;
	min-width: 20em;
	white-space: nowrap;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2021-04-08
trans_update:2021-04-12
source_checked:210408
page_state_key:TIMING
original_url:https://w3c.github.io/resource-timing/
	abbr_url:RESOURCE-TIMING
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
copyright:2021,permissive
trans_1st_pub:2013-01-23

●●class_map
h:header
e:element
a:attr
et:event-type
P:production
v:value

●●tag_map
I:code
m:code
c:code
h:code
e:code
a:code
et:code
P:code
v:code
i:i

●●original_id_map

dom-performanceresourcetiming-requestend:dfn-requestend

●●mdn_urls
dfn-timing-allow-origin:HTTP/Headers/Timing-Allow-Origin

dom-performanceresourcetiming:API/PerformanceResourceTiming
dom-performance-clearresourcetimings:API/Performance/clearResourceTimings
dom-performance-setresourcetimingbuffersize:API/Performance/setResourceTimingBufferSize
dom-performance-onresourcetimingbufferfull:API/Performance/onresourcetimingbufferfull
dom-performanceresourcetiming-connectend:API/PerformanceResourceTiming/connectEnd
dom-performanceresourcetiming-connectstart:API/PerformanceResourceTiming/connectStart
dom-performanceresourcetiming-decodedbodysize:API/PerformanceResourceTiming/decodedBodySize
dom-performanceresourcetiming-domainlookupend:API/PerformanceResourceTiming/domainLookupEnd
dom-performanceresourcetiming-domainlookupstart:API/PerformanceResourceTiming/domainLookupStart
dom-performanceresourcetiming-encodedbodysize:API/PerformanceResourceTiming/encodedBodySize
dom-performanceresourcetiming-fetchstart:API/PerformanceResourceTiming/fetchStart
dom-performanceresourcetiming-initiatortype:API/PerformanceResourceTiming/initiatorType
dom-performanceresourcetiming-nexthopprotocol:API/PerformanceResourceTiming/nextHopProtocol
dom-performanceresourcetiming-redirectend:API/PerformanceResourceTiming/redirectEnd
dom-performanceresourcetiming-redirectstart:API/PerformanceResourceTiming/redirectStart
dom-performanceresourcetiming-requestend:API/PerformanceResourceTiming/requestEnd
dom-performanceresourcetiming-requeststart:API/PerformanceResourceTiming/requestStart
dom-performanceresourcetiming-responseend:API/PerformanceResourceTiming/responseEnd
dom-performanceresourcetiming-responsestart:API/PerformanceResourceTiming/responseStart
dom-performanceresourcetiming-secureconnectionstart:API/PerformanceResourceTiming/secureConnectionStart
dom-performanceresourcetiming-tojson:API/PerformanceResourceTiming/toJSON
dom-performanceresourcetiming-transfersize:API/PerformanceResourceTiming/transferSize
dom-performanceresourcetiming-workerstart:API/PerformanceResourceTiming/workerStart

dfn-resourcetimingbufferfull:API/Performance/resourcetimingbufferfull_event

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default

DOMString:~WEBIDL#idl-DOMString
undefined:~WEBIDL#idl-undefined
object:~WEBIDL#idl-object
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp

I.PerformanceResourceTiming:#dom-performanceresourcetiming
I.XMLHttpRequest:~XHR#xmlhttprequest
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	~TR/hr-time-2/#domhighrestimestamp
I.Performance:~HRTIME#dfn-performance
I.PerformanceEntry:~TIMELINE#the-performanceentry-interface
	I.PerformanceEntry:#dfn-performanceentry
I.PerformanceObserver:~TIMELINE#the-performanceobserver-interface
I.EventHandler:~WAPI#eventhandler
	I.Document

m.toJSON:#dom-performanceresourcetiming-tojson
m.initiatorType:#dom-performanceresourcetiming-initiatortype
m.nextHopProtocol:#dom-performanceresourcetiming-nexthopprotocol
m.workerStart:#dom-performanceresourcetiming-workerstart
m.redirectStart:#dom-performanceresourcetiming-redirectstart
m.redirectEnd:#dom-performanceresourcetiming-redirectend
m.fetchStart:#dom-performanceresourcetiming-fetchstart
m.domainLookupStart:#dom-performanceresourcetiming-domainlookupstart
m.domainLookupEnd:#dom-performanceresourcetiming-domainlookupend
m.connectStart:#dom-performanceresourcetiming-connectstart
m.connectEnd:#dom-performanceresourcetiming-connectend
m.secureConnectionStart:#dom-performanceresourcetiming-secureconnectionstart
m.requestStart:#dom-performanceresourcetiming-requeststart
m.requestEnd:#dom-performanceresourcetiming-requestend
m.responseStart:#dom-performanceresourcetiming-responsestart
m.responseEnd:#dom-performanceresourcetiming-responseend
m.transferSize:#dom-performanceresourcetiming-transfersize
m.encodedBodySize:#dom-performanceresourcetiming-encodedbodysize
m.decodedBodySize:#dom-performanceresourcetiming-decodedbodysize

m.clearResourceTimings:#dom-performance-clearresourcetimings
m.setResourceTimingBufferSize:#dom-performance-setresourcetimingbuffersize
m.onresourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull

m.name:#dfn-name
m.entryType:#dfn-entrytype
m.startTime:#dfn-starttime
m.duration:#dfn-duration

m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes

	●e
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.link:~HEmetadata#the-link-element
e.script:~HEscripting#the-script-element
e.object:~HEembed#the-object-element
e.svg:~SVGstruct#elementdef-svg
	e.svg:~SVG11/struct.html#SVGElement

et.resourcetimingbufferfull:#dfn-resourcetimingbufferfull

h.Timing-Allow-Origin:#dfn-timing-allow-origin
	h.Origin:~RFCx/rfc6454#section-4

P.origin-or-null:~FETCH#origin-header
P.wildcard:~FETCH#http-new-header-syntax

v.stylesheet:~HTMLlinks#link-type-stylesheet

	●用語

非同一-生成元:#dfn-cross-origin
	不要）現-文書:#dfn-current-document
	不要）現-時刻:#dfn-current-time
	不要）資源:#dfn-resource

資源~計時~bufferの~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~bufferの現-~size:#dfn-resource-timing-buffer-current-size
資源~計時~bufferの満杯~event処理待ち~flag:#dfn-resource-timing-buffer-full-event-pending-flag
資源~計時~副-~buffer:#dfn-resource-timing-secondary-buffer
資源~計時~副-~bufferの現-~size:#dfn-resource-timing-secondary-buffer-current-size

処理能~entry~bufferに~entryを追加する:#dfn-add-a-performanceresourcetiming-entry
資源~計時~entryを追加でき:#dfn-can-add-resource-timing-entry
~buffer満杯~eventを発火する:#dfn-fire-a-buffer-full-event
副-~buffer内の~entryを移動する:#dfn-copy-secondary-buffer

処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer
処理能~entry~buffer~map:~TIMELINE#dfn-performance-entry-buffer-map
処理能~時列線:~TIMELINE#performance-timeline
	#sec-performance-timeline
	Performance:~TR/navigation-timing-2/#performance
処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
処理能~時列線~task源:~TIMELINE#dfn-performance-timeline-task-source

~fetch時刻印を変換する:#dfn-convert-fetch-timestamp
資源~計時を~markする:#dfn-mark-resource-timing
資源~計時~entryを設定しておく:#dfn-setup-the-resource-timing-entry

pT.起動元~種別:#dfn-initiator-type
pT.要請~URL:#dfn-requested-url
pT.計時情報:#dfn-timing-info

	●用語（外部

要請:~FETCH#concept-request
rq.~client:~FETCH#concept-request-client

~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~HTTP~fetch:~FETCH#concept-http-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~TAO検査:~FETCH#concept-tao-check
	§ ~TAO検査:~FETCH#tao-check

cT.折衝した~ALPN~protocol~ID:~FETCH#connection-timing-info-alpn-negotiated-protocol
cT.接続~終了~時刻:~FETCH#connection-timing-info-connection-end-time
cT.接続~開始~時刻:~FETCH#connection-timing-info-connection-start-time
cT.~domain検索~終了~時刻:~FETCH#connection-timing-info-domain-lookup-end-time
cT.~domain検索~開始~時刻:~FETCH#connection-timing-info-domain-lookup-start-time
cT.~secure接続~開始~時刻:~FETCH#connection-timing-info-secure-connection-start-time

~fetch計時情報:~FETCH#fetch-timing-info
fT.終了~時刻:~FETCH#fetch-timing-info-end-time
fT.最終-~network要請~開始~時刻:~FETCH#fetch-timing-info-final-network-request-start-time
fT.最終-~network応答~開始~時刻:~FETCH#fetch-timing-info-final-network-response-start-time
fT.最終-~sw開始~時刻:~FETCH#fetch-timing-info-final-service-worker-start-time
fT.最終-接続~計時情報:~FETCH#fetch-timing-info-final-connection-timing-info
fT.~redirect後からの開始~時刻:~FETCH#fetch-timing-info-post-redirect-start-time
fT.~redirect終了~時刻:~FETCH#fetch-timing-info-redirect-end-time
fT.~redirect開始~時刻:~FETCH#fetch-timing-info-redirect-start-time
fT.開始~時刻:~FETCH#fetch-timing-info-start-time

fT.符号化された本体の~size:~FETCH#fetch-timing-info-encoded-body-size
fT.復号した本体の~size:~FETCH#fetch-timing-info-decoded-body-size

接続~計時情報を記録する:~FETCH#record-connection-timing-info

~ES大域~環境:~WEBIDLjs#es-environment
既定の~toJSON手続き:~WEBIDLjs#default-tojson-steps
大域~obj:~WAPI#concept-settings-object-global

	data: URI:~RFCx/rfc2397
同一-生成元:~ORIGIN#same-origin
	生成元:~ORIGIN#concept-origin
~eventを発火する:~DOM4#concept-event-fire
~taskを~queueする:~WAPI#queue-a-task

作動中の~worker:~SW1#dfn-active-worker

細かさを抑えた相対的な高分解能~時刻:~HRTIME#dfn-relative-high-resolution-coarse-time
	~TR/hr-time-2/#relative-high-resolution-coarse-time

enV.大域~obj:~WAPI#concept-settings-object-global
~realm:~WAPI#concept-global-object-realm
関連な大域~obj:~WAPI#concept-relevant-global
同型に復号する:~INFRA#isomorphic-decode
文字列:~INFRA#string

コレ:~WEBIDL#this
~Realm:~WAPI#concept-global-object-realm

	-:#dfn-dom
	-:#dfn-getting
	-:#dfn-setting
	-:#dfn-javascript
	-:#dom



●●words_table1

●●words_table

	●fetch／HTTP/network
TLS:
DNS:
TCP:
ALPN:
検索:lookup::~
handshake::::ハンドシェイク
端点間:end-to-end::~::エンドツーエンド
符号法:coding::~::コーディング
network-or-cache::::ネットワーク-or-キャッシュ
受信:receiving::~
受信者:recipient::~
	送信し直:resend
送信者:sender::~
事前条件:precondition::~
再検証-:revalidate::~
再検証:revalidation::~

hit::::ヒット
miss::::ミス
到着-:arrive:~
	~app~cache:application cache

	●計時
高分解能:high resolution::~
計時情報:timing info::~
最終-:final:~
	細かさを抑えた:coarse
時機:timing::~
時区間:interval::~
	かかった時間:time it takes to
	費やされ:takes／spent
	処理能~時列線:Performance Timeline

	●処理一般
満杯:full::~
処理待ち:pending:~
同型:isomorphic::~
mark::::マーク
現-:current:~
副-:secondary:~

	●仕様
包括的:comprehensive:~
様相:picture:~
暫定的:provisional:~

上限:limit:~
位置付け:status:~

	必要性:need:~
	~~手段:instrumentation
	仕立て上げ:be modified to
	~~手法:-
	足りる:sufficiently
	しておく:make sure
	方法:-
	今日:today
	図式:graph
	内訳
	とする:suppose
	更なる情報:for more info

	●未分類
内包-:include:~
知覚-:perceive:~
ES:ECMAScript
benchmark::::ベンチマーク
品質:quality:~
	正準-形が同じになる:canonical URL
TAO:
統計的:statistical:~
toJSON:
	文字列$:DOMString
	文字列$:DOMStrring

	-:underline
	可能
	各段階
	移動できなかった~entryは:does not add more room in the buffer than it adds resources to it
	-:excess
	number of excess entries
	後続-:follow
	対象にする:included
	〜内の~entryを移動する:copy
	無けれ:if not present
	時点
	個数:number of／:how many
	最初の:oldest
	見込まれ:might
	末尾:the end

	%~buffer:buffer
	%~entry:entry
	%計時情報:timingInfo
	%要請された~URL:requestedURL
	%起動元~種別:initiatorType
	%時刻印:ts
	%大域~obj:global
	%移動した:-

●●ref_normative

[DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.es/ecma262/
[Fetch]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik. W3C. 21 November 2019. W3C Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[hr-time-3]
    High Resolution Time. Yoav Weiss; Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. 24 March 2021. W3C Working Draft. URL: https://www.w3.org/TR/hr-time-3/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 21 January 2020. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/
[PERFORMANCE-TIMELINE-2]
    Performance Timeline Level 2. Ilya Grigorik. W3C. 24 October 2019. W3C Working Draft. URL: https://www.w3.org/TR/performance-timeline-2/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[RFC2397]
    The "data" URL scheme. L. Masinter. IETF. August 1998. Proposed Standard. URL: https://tools.ietf.org/html/rfc2397
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://tools.ietf.org/html/rfc8174
[SVG11]
    Scalable Vector Graphics (SVG) 1.1 (Second Edition). Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. W3C. 16 August 2011. W3C Recommendation. URL: https://www.w3.org/TR/SVG11/
[WEBIDL]
    Web IDL. Boris Zbarsky. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/
[XHR]
    XMLHttpRequest Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://xhr.spec.whatwg.org/

●●
ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Resource Timing Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/resource-timing-2/
最新の編集者草案
	https://w3c.github.io/resource-timing/

編集
	<a href="yoav@yoav.ws">Yoav Weiss</a> (Google)
	<a href="noam.j.rosenthal@gmail.com">Noam Rosenthal</a> (Invited Expert) 
前任編集者
	<a href="igrigorik@gmail.com">Ilya Grigorik</a> (Google) (Until January 2021)
	<a href="toddreif@microsoft.com">Todd Reifsteck</a> (Microsoft Corp.) (Until January 2021)
	<a href="arvind@google.com">Arvind Jain</a> (Google Inc.) (Until December 2014)
	<a href="jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until February 2014)
	Zhiheng Wang (Google Inc.) (Until July 2012)
	Anderson Quach (Microsoft Corp.) (Until March 2011)

Participate
	<a href="https://github.com/w3c/resource-timing/">GitHub w3c/resource-timing </a>
	<a href="https://github.com/w3c/resource-timing/issues">File a bug</a>
	<a href="https://github.com/w3c/resource-timing/commits/gh-pages/index.html">Commit history</a>
	<a href="https://github.com/w3c/resource-timing/pulls/">Pull requests</a>

ブラウザサポート
	https://caniuse.com/resource-timing
Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>
発行者
	<a href="https://www.w3.org/webperf/">Web Performance WG</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1>リソースの計時 — Resource Timing Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT
<p>
この仕様は、~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは編集者草案の公な複製です…
【以下，この節の他の内容は、<a href="w3c-common-ja.html#status">W3C 日本語訳 共通~page</a>／冒頭の仕様~metadataに委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が知覚し得る待時間は Web ~appにとり重要な品質~benchmarkである。
~JSに基づく仕組みは、~appにおける利用者~側の待時間を測定するための包括的な~~手段を供せるが、端点間の待時間については，多くの事例で，完全な様相を供せない。
この仕様は、 `PerformanceResourceTiming$I ~interfaceを導入する。
それは、~JSにより，文書~上の資源に関係する完全な計時~情報を収集するための仕組みである。
`NAVIGATION-TIMING-2$r は、この仕様を拡張して，~naviに関わる追加的な計時~情報を供する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. This document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document. Navigation Timing 2 [NAVIGATION-TIMING-2] extends this specification to provide additional timing information associated with a navigation.
</p>

<div class="example">
<p>
例えば、次のような~JSで，資源~fetchにかかった時間を単純に測定しようと試みた場合：
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %start = new Date().getTime();
   var %image1 = new Image();
   var %resourceTiming = function() {
       var %now = new Date().getTime();
       var %latency = %now - %start;
       alert("End to end resource fetch: " + %latency);
   };

   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源~fetchに要した時間は測定できるが、その内訳の各段階に費やされた時間は測定できない。
更に、~markupにより記述された資源に費やされた時間を，この~scriptで測定することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に取組むため、この文書は
`PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、~client側~appにおける待時間の完全な測定を可能にする，~JSによる仕組みを供する。
この~interfaceにより、前の例は，利用者が知覚する資源の読込n時間を測定-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、~markupにより定義されたものまで含め，~page内のそれぞれの資源~fetchに要した時間の~~長さを計算する。
この例は、~pageが
<samp >https://www.w3.org</samp>
下に~hostされていると見做している。
その気になれば
`PerformanceResourceTiming$I
~interfaceを利用して、資源~fetchingの各段階ごとに要した時間も測定できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on https://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre class="lang-html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %image1 = new Image();
   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var %resourceList = window.performance.getEntriesByType("resource");
    for (%i = 0; %i &lt; %resourceList.length; i++) {
       if (%resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( %resourceList[i].responseEnd  - %resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>

	<section id="conformance">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#terminology">W3C 日本語訳 共通~page</a>
に委譲
】</p>

<p>
この仕様を通して、
`非同一-生成元@
（ `cross origin^en ）とは、`同一-生成元$でないことを意味する。
【原文には他の用語も挙げられているが、更新により参照されなくなったので，和訳は省略する。】
◎
The term resource is used to refer to elements and any other user-initiated fetches throughout this specification. For example, a resource could originate from XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
◎
The term cross-origin is used to mean non same origin.
◎
The term current document refers to the document associated with the Window object's newest Document object.
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME-2]. For example, the start of navigation of the document occurs at time 0.
◎
The term current time refers to the number of milliseconds since the start of navigation of the document until the current moment in time.
◎
This definition of time is based on the High Resolution Time specification [HR-TIME-2] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING-2], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>
<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
	</section>
	<section id="sec-resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>

		<section id="introduction-0">
<h3 title="Introduction">4.1. 序論</h3>

~INFORMATIVE

<div class="p">
<p>
`PerformanceResourceTiming$I
~interfaceは、~download可能な資源の計時~測定を手助けする。
例えば、次に挙げるもの【により起動される~fetch】に利用できる：
</p>

<ul ><li>`XMLHttpRequest$I ~obj `XHR$r
</li><li>`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v の `link$e
］などの，~HTML要素 `HTML$r
</li><li>`svg$e などの~SVG要素 `SVG11$r
</li></ul>

◎
The PerformanceResourceTiming interface facilitates timing measurement of downloadable resources. For example, this interface is available for XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</div>

		</section>
		<section id="resources-included-in-the-performanceresourcetiming-interface">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源</h3>

<p>
~NULL でない`~client$rqからの`要請$により`~fetch$される すべての資源
— 局所~資源†から検索取得されたものも含む —
は、`~fetching$の一部として除外されない限り
`PerformanceResourceTiming$I ~objとして，`~client$rqの`大域~obj$の`処理能~時列線$に含めるモノトスル。
ただし，~fetchにより起動されたが（~network~errorなどに因り）後で中止された資源は、`処理能~時列線$に含めなくてもヨイ
— 含める場合、各種~属性の値は，`~fetching$や その下位手続きの中で初期化するモノトスル。
◎
All resource Requests fetched by a non-null client MUST be included as PerformanceResourceTiming objects in the client's global object's Performance Timeline, unless excluded from the timeline as part of the fetching process. Resources that are retrieved from relevant application caches or local resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) MAY be included as PerformanceResourceTiming objects in the Performance Timeline and MUST contain initialized attribute values for processed substeps of the fetching process.
</p>

<p class="trans-note">【†
原文には，局所~資源（ `file://^P ~URLや~HTTP~cacheなどが含まれよう）の他に
“関連な~app~cache（ `relevant application cache^en ）”
も挙げられているが、その特能は，~HTMLから廃された。
】</p>

<div class="example">
<p>
例えば：
◎
The rest of this section is non-normative.
◎
Examples:
</p>
<ul>
	<li>
複数の~HTML `img$e 要素の `src^a 属性に，正準-形が同じになる~URL（ `the same canonical URL^en 
【すなわち，同じ資源を指す~URL】
）が利用されている場合、［
最初に資源`~fetch$を起動した `img^e 要素
］の方が `PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められるベキである。
~UAは、 2 個目以降の `img^e 要素の~URLに対しては、再~要請することなく，最初に起動された方による既存の~downloadを利用すると見込まれるので。
この場合，`処理能~時列線$には、最初に起動された， `img^e 要素に対する資源`~fetch$による結果のみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element SHOULD be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
~HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、元々の資源`~fetch$のみならず，新たな~URLへの`~fetch$も， `PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められることになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
~HTML `iframe$e 要素の~markupに `src^a 属性が指定されていない場合、~UAは `about:blank^c 文書を読込むことになる。
後で~scriptから `src^a 属性が動的に変更された場合，その新たな~URLの資源へ`~fetch$されることになる。
この場合、新たな~URLによる`~fetch$のみが， `PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められることになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
正準-形が同じになる~URL用に，複数の `XMLHttpRequest$I が生成された場合、いずれの資源`~fetch$も， `PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められることになる
— 後続する資源~fetch要請には、先行する要請による~downloadを再利用できないので。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
~page内の~HTML `iframe$e 要素に内包された文書により要請される下位資源は、親~文書の`処理能~時列線$ではなく，内包された文書の`処理能~時列線$に含められる。
`iframe^e に対し`処理能~時列線$に含められるのは、その `src^a 属性により要請される資源に限られる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素が~sourceとして
<a href="~RFCx/rfc2397.html">data: URI</a> `RFC2397$r
を持つ場合、その資源は，`処理能~時列線$には含められない。
data: URI は埋込d~dataであり、`~fetch$を要さないものと定義されているので。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. By definition data: URI contains embedded data and does not require a fetch.
</li>
	<li>
資源`~fetch$が~network~error（ ~DNS, ~TCP, ~TLS ~errorなど）に因り中止された場合、その~fetchは，失敗した時点までの属性~値で初期化された `PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められてヨイ
— 例えば~TCP~handshake~errorは、 要請~用の~DNS時刻印を報告するべきである, 等々。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch MAY be included as a PerformanceResourceTiming object in the Performance Timeline with initialized attribute values up to the point of failure - e.g. a TCP handshake error should report DNS timestamps for the request, and so on.
</li>
	<li>
資源`~fetch$が，事前条件（例： 混在内容（ `mixed content^en ）, ~CORS制約, ~CSP施策, など）に失敗したことにより中止された場合、その資源については，`処理能~時列線$には含められるベキでない。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource SHOULD NOT not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
</ul>
</div>

		</section>
		<section id="sec-performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute `DOMString$ `initiatorType$m;
  readonly attribute `DOMString$ `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$ `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$ `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$ `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$ `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$ `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$ `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$ `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$ `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$ `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$ `responseEnd$m;
  readonly attribute `unsigned long long$ `transferSize$m;
  readonly attribute `unsigned long long$ `encodedBodySize$m;
  readonly attribute `unsigned long long$ `decodedBodySize$m;
  [`Default$] `object$ `toJSON$m();
};
</pre>

<p>
各 `PerformanceResourceTiming$I ~objには、次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`起動元~種別@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString initiator type.
</li>
	<li>
`要請~URL@pT
⇒
`文字列$
◎
A PerformanceResourceTiming has an associated DOMString requested URL.
</li>
	<li>
`計時情報@pT
⇒
`~fetch計時情報$
◎
A PerformanceResourceTiming has an associated fetch timing info timing info.
</li>
</ul>

<p id="dfn-performanceentry">
`PerformanceResourceTiming$I ~interfaceは、`処理能~時列線$に関与し，次に挙げる
`PerformanceEntry$I ~interfaceの属性を拡張する：
◎
The PerformanceResourceTiming interface participates in the Performance Timeline and extends the following attributes of the PerformanceEntry interface:
</p>
<ul>
	<li class="algo">
`name@m
取得子~手続きは
⇒
~RET コレの`要請~URL$pT
◎
The name getter steps are to return this's requested URL.
</li>
	<li class="algo">
`entryType@m
取得子~手続きは
⇒
~RET `文字列$ `resource^l
◎
The entryType getter steps are to return the DOMString "resource".
</li>
	<li class="algo">
`startTime@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The startTime getter steps are to convert fetch timestamp for this's timing info's start time and this's relevant global object.
</li>
	<li class="algo">
`duration@m
取得子~手続きは
⇒
~RET コレの`計時情報$pTの`終了~時刻$fT ~MINUS コレの`計時情報$pTの`開始~時刻$fT
◎
The duration getter steps are to return this's timing info's end time minus this's timing info's start time.
</li>
</ul>

<div class="algo">
<p>
`toJSON()@m
は、`既定の~toJSON手続き$ `WEBIDL$r を走らす。
◎
When toJSON is called, run [WEBIDL]'s default toJSON operation.
</p>
</div>

<div class="algo">
<p>
`initiatorType@m
取得子~手続きは
⇒
~RET コレの`起動元~種別$pT
◎
initiatorType getter steps are to return the initiator type for this.
</p>
</div>

<div class="algo">
<p>
`workerStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-~sw開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The workerStart getter steps are to convert fetch timestamp for this's timing info's final service worker start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`redirectStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`~redirect開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The redirectStart getter steps are to convert fetch timestamp for this's timing info's redirect start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~HTTP~redirect~fetch$を見よ。
◎
See HTTP-redirect fetch for more info.
</p>
</div>

<div class="algo">
<p>
`redirectEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`~redirect終了~時刻$fT, コレに`関連な大域~obj$ )
◎
The redirectEnd getter steps are to convert fetch timestamp for this's timing info's redirect end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~HTTP~redirect~fetch$を見よ。
◎
See HTTP-redirect fetch for more info.
</p>
</div>

<div class="algo">
<p>
`fetchStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`~redirect後からの開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The fetchStart getter steps are to convert fetch timestamp for this's timing info's post-redirect start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`domainLookupStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`~domain検索~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The domainLookupStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's domain lookup start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`domainLookupEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`~domain検索~終了~時刻$cT, コレに`関連な大域~obj$ )
◎
The domainLookupEnd getter steps are to convert fetch timestamp for this's timing info's final connection timing info's domain lookup end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`connectStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`接続~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The connectStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's connection start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`connectEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`接続~終了~時刻$cT, コレに`関連な大域~obj$ )
◎
The connectEnd getter steps are to convert fetch timestamp for this's timing info's final connection timing info's connection end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`secureConnectionStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`~secure接続~開始~時刻$cT, コレに`関連な大域~obj$ )
◎
The secureConnectionStart getter steps are to convert fetch timestamp for this's timing info's final connection timing info's secure connection start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`nextHopProtocol@m
取得子~手続きは
⇒
~RET `同型に復号する$( コレの`計時情報$pTの`最終-接続~計時情報$fTの`折衝した~ALPN~protocol~ID$cT )
◎
The nextHopProtocol getter steps are to isomorphic decode this's timing info's final connection timing info's ALPN negotiated protocol.＼
</p>

<p class="note">
更なる情報は、`接続~計時情報を記録する$を見よ。
◎
See Recording connection timing info for more info.
</p>
</div>

<div class="algo">
<p>
`requestStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-~network要請~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The requestStart getter steps are to convert fetch timestamp for this's timing info's final network-request start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`responseStart@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`最終-~network応答~開始~時刻$fT, コレに`関連な大域~obj$ )
◎
The responseStart getter steps are to convert fetch timestamp for this's timing info's final network-response start time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~HTTP~fetch$を見よ。
◎
See HTTP fetch for more info.
</p>
</div>

<div class="algo">
<p>
`responseEnd@m
取得子~手続きは
⇒
~RET `~fetch時刻印を変換する$( コレの`計時情報$pTの`終了~時刻$fT, コレに`関連な大域~obj$ )
◎
The responseEnd getter steps are to convert fetch timestamp for this's timing info's end time and the relevant global object for this.＼
</p>

<p class="note">
更なる情報は、`~fetch$を見よ。
◎
See fetch for more info.
</p>

<p class="note">注記：
`PerformanceResourceTiming$I を実装する~UAは、その~supportを開発者が検出できるよう，
`supportedEntryTypes$m 内に `resource^l を含める必要がある。
◎
Note
A user agent implementing PerformanceResourceTiming would need to include "resource" in supportedEntryTypes. This allows developers to detect support for Resource Timing.
</p>
</div>

<p class="trans-note">【
`transferSize@m ／
`encodedBodySize@m ／
`decodedBodySize@m
取得子~手続きは、未策定（更新により除去された）。
順に，［
~HTTP応答を成す全~data（~headerも含む）の~size／
`計時情報$pTの`符号化された本体の~size$fT／
`計時情報$pTの`復号した本体の~size$fT
］に基づくことになろう。
】</p>


		</section>
		<section id="sec-extensions-performance-interface">
<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>

<p>
~UAは、 `PerformanceResourceTiming$I ~objとして`処理能~時列線$ `PERFORMANCE-TIMELINE-2$r に含み得る資源の個数を制限してもヨイ。
この節では、 `Performance$I ~interfaceを拡張して，格納される `PerformanceResourceTiming$I ~objの個数について制御できるようにする。
◎
The user agent MAY choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. This section extends the Performance interface to allow controls over the number of PerformanceResourceTiming objects stored.
</p>

<p>
推奨される `PerformanceResourceTiming$I ~objの最小~個数は 250 である
— ~UAはこれを変更してもヨイが。
この上限は、
`setResourceTimingBufferSize()$m を~callすることにより，変更を要請できる。
◎
The recommended minimum number of PerformanceResourceTiming objects is 250, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>

<p>
各 `~ES大域~環境$は、次のものを持つ：
◎
Each ECMAScript global environment has:
</p>

<dl class="def-list">
	<dt>
`資源~計時~bufferの~size上限@
◎
A resource timing buffer size limit＼
</dt>
	<dd>
初期~時は 250 以上【が推奨される】。
◎
which should initially be 250 or greater.
<dd>

	<dt>
`資源~計時~bufferの現-~size@
◎
A resource timing buffer current size＼
</dt>
	<dd>
0 以上の整数。
初期~時は 0 。
◎
which is initially 0.
</dd>

	<dt>
`資源~計時~bufferの満杯~event処理待ち~flag@
◎
A resource timing buffer full event pending flag＼
</dt>
	<dd>
初期~時は ~F とする。
◎
which is initially false.
</dd>

	<dt>
`資源~計時~副-~bufferの現-~size@
◎
A resource timing secondary buffer current size which is initially 0.
</dt>
	<dd class="trans-note">【
`資源~計時~副-~buffer$を成す~entryの個数を表すが、この訳では，この用語は利用しない。
代わりに，~algoの記述にて等価に表現する（`副-~buffer内の~entryを移動する$における，真偽値 %移動した ）。
そうした方が簡潔かつ簡明に記述できるので。
】</dd>

	<dt>
`資源~計時~副-~buffer@
◎
A resource timing secondary buffer＼
</dt>
	<dd>
0 個以上の `PerformanceResourceTiming$I ~objからなる~list。
初期~時は空。
◎
to store PerformanceResourceTiming objects that is initially empty.
</dd>
</dl>

<pre class="idl">
partial interface `Performance$I {
  `undefined$ `clearResourceTimings()$m;
  `undefined$ `setResourceTimingBufferSize$m(`unsigned long$ %maxSize);

  attribute `EventHandler$I `onresourcetimingbufferfull$m;
};
</pre>

<p>
`Performance$I ~interfaceは
`HR-TIME-2$r にて定義される。
◎
The Performance interface is defined in [HR-TIME-2].
</p>

<div class="algo">
<p>
`clearResourceTimings()@m
~method手続きは：
◎
The method clearResourceTimings runs the following steps:
</p>
<ol>
	<li>
`処理能~entry~buffer$から 次を満たす~entryをすべて除去する
⇒
`PerformanceResourceTiming$I ~objである
◎
Remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
	<li>
`資源~計時~bufferの現-~size$ ~SET 0
◎
Set resource timing buffer current size to 0.
</li>
</ol>
</div>

<div class="algo">
<p>
`setResourceTimingBufferSize(maxSize)@m
~method手続きは
⇒
`資源~計時~bufferの~size上限$ ~SET %maxSize
◎
The setResourceTimingBufferSize method runs the following steps:
• Set resource timing buffer size limit to the maxSize parameter.＼
</p>

<p class="note">注記：
［
%maxSize ~LT `資源~計時~bufferの現-~size$
］であっても，`処理能~entry~buffer$から `PerformanceResourceTiming$I ~objは除去されない。
◎
If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</p>
</div>

<p>
`onresourcetimingbufferfull@m
は、
`resourcetimingbufferfull@et
~event用の~event~handlerである。
【`~buffer満杯~eventを発火する$を見よ。】
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event described below.
</p>

<div class="algo">
<p>
`資源~計時~entryを追加でき@
るとは、次が満たされることをいう
⇒
`資源~計時~bufferの現-~size$ ~LT `資源~計時~bufferの~size上限$
◎
To check if can add resource timing entry, run the following steps:
• If resource timing buffer current size is smaller than resource timing buffer size limit, return true.
• Return false.
</p>
</div>

<div class="algo">
<p>
`処理能~entry~bufferに~entryを追加する@
ときは、所与の
( `処理能~entry~buffer$ %~buffer, `PerformanceResourceTiming$I ~obj %~entry )
に対し，次を走らす：
◎
To add a PerformanceResourceTiming entry into the performance entry buffer, run the following steps:
• Let new entry be the input PerformanceEntry to be added.
</p>

<ol>
	<li>
<p>
~IF［
`資源~計時~entryを追加でき$る
］~AND［
`資源~計時~bufferの満杯~event処理待ち~flag$ ~EQ ~F
］：
◎
If can add resource timing entry returns true and resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
%~buffer に %~entry を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~bufferの現-~size$ ~INCBY 1
◎
Increase resource timing buffer current size by 1.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`資源~計時~bufferの満杯~event処理待ち~flag$ ~EQ ~F
］：
◎
If resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
`資源~計時~bufferの満杯~event処理待ち~flag$ ~SET ~T
◎
Set resource timing buffer full event pending flag to true.
</li>
			<li>
`処理能~時列線~task源$から，次を走らす`~taskを~queueする$
⇒
`~buffer満杯~eventを発火する$
◎
Queue a task on the performance timeline task source to run fire a buffer full event.
</li>
		</ol>
	</li>
	<li>
`資源~計時~副-~buffer$に %~entry を付加する
◎
Add new entry to the resource timing secondary buffer.
◎
Increase resource timing secondary buffer current size by 1.
</li>
</ol>
</div>

<div class="algo">
<p>
`副-~buffer内の~entryを移動する@
ときは、次を走らす：
◎
To copy secondary buffer, run the following steps:
</p>

<ol>
	<li>
%移動した ~LET ~F
◎
↓↓</li>
	<li>
<p>
~WHILE［
`資源~計時~副-~buffer$は空でない
］~AND［
`資源~計時~entryを追加でき$る
］：
◎
While resource timing secondary buffer is not empty and can add resource timing entry returns true, run the following substeps:
</p>
		<ol>
			<li>
%~entry ~LET `資源~計時~副-~buffer$内の最初の（最も古い） `PerformanceResourceTiming$I ~obj
◎
Let entry be the oldest PerformanceResourceTiming in resource timing secondary buffer.
</li>
			<li>
`処理能~entry~buffer$の末尾に %~entry を追加する
◎
Add entry to the end of performance entry buffer.
</li>
			<li>
`資源~計時~bufferの現-~size$ ~INCBY 1
◎
Increment resource timing buffer current size by 1.
</li>
			<li>
`資源~計時~副-~buffer$から %~entry を除去する
◎
Remove entry from resource timing secondary buffer.
</li>
			<li>
%移動した ~SET ~T
◎
Decrement resource timing secondary buffer current size by 1.
</li>
		</ol>
	</li>
	<li>
~RET %移動した
</li>
</ol>
</div>

<div class="algo">
<p>
`~buffer満杯~eventを発火する@
ときは、次を走らす：
◎
To fire a buffer full event, run the following steps:
</p>

<ol>
	<li>
<p>
~WHILE［
`資源~計時~副-~buffer$は空でない
］：
◎
While resource timing secondary buffer is not empty, run the following substeps:
</p>
		<ol>
			<li>
~IF［
`資源~計時~entryを追加でき$ない
］
⇒
`Performance$I ~objに向けて，名前 `resourcetimingbufferfull$et の`~eventを発火する$
◎
Let number of excess entries before be resource timing secondary buffer current size.
◎
If can add resource timing entry returns false, then fire an event named resourcetimingbufferfull at the Performance object.
</li>
			<li>
%移動した ~LET `副-~buffer内の~entryを移動する$
◎
Run copy secondary buffer.
</li>
			<li>
~IF［
%移動した ~EQ ~F
］
⇒＃
`資源~計時~副-~buffer$からすべての~entryを除去する†；
~BREAK
◎
Let number of excess entries after be resource timing secondary buffer current size.
◎
If number of excess entries before is lower than or equals number of excess entries after, then remove all entries from resource timing secondary buffer, set resource timing secondary buffer current size to 0, and abort these steps.
</li>
		</ol>
	</li>
	<li>
`資源~計時~bufferの満杯~event処理待ち~flag$ ~SET ~F
◎
Set resource timing buffer full event pending flag to false.
</li>
</ol>

<p class="note">注記：†
移動できなかった~entryは、~bufferから落とされる。
開発者は、 `resourcetimingbufferfull$et ~event用の~event~handler内で，次のいずれかをしておくべきである
⇒＃
`clearResourceTimings()$m を~callする／
`setResourceTimingBufferSize()$m を~callして，~bufferが足りるよう拡張する
◎
Note
This means that if the resourcetimingbufferfull event handler does not add more room in the buffer than it adds resources to it, excess entries will be dropped from the buffer. Developers should make sure that resourcetimingbufferfull event handlers call clearResourceTimings or extend the buffer sufficiently (by calling setResourceTimingBufferSize).
</p>
</div>

		</section>
		<section id="sec-cross-origin-resources">
<h3 title="Cross-origin Resources">4.5. 非同一-生成元~資源</h3>

<p>
`FETCH$r にて詳細されるとおり、`非同一-生成元$に属する資源は，
`PerformanceResourceTiming$I ~objとして`処理能~時列線$に含められる。
資源が`~TAO検査$に失敗した場合、その属性のうち次に挙げるものは，
0 に設定される
⇒＃
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m,
`transferSize$m,
`encodedBodySize$m,
`decodedBodySize$m
◎
As detailed in Fetch, cross-origin resources are included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a resource, the following attributes of its PerformanceResourceTiming object are set to zero: redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, secureConnectionStart, transferSize, encodedBodySize, and decodedBodySize.
</p>

<p>
~server側~appは， `Timing-Allow-Origin$h ~HTTP応答~header返してもヨイ
— 上に挙げた［
`非同一-生成元$に対する制約から値が 0 にされる属性
］すべてを［
~headerにて指定された文書~生成元（たち）
］に公開するのを，~UAに許容するためとして。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to the cross-origin restrictions previously specified in this section.
</p>

			<section id="sec-timing-allow-origin">
<h4 title="Timing-Allow-Origin Response Header">4.5.1. `Timing-Allow-Origin^h 応答~header</h4>

<p>
`Timing-Allow-Origin@h
~HTTP応答~headerを利用すれば、［［
非同一-生成元に対する制約に因り 0 にされていた属性
］の値を見ることが許容される生成元（たち）
］を指示する施策を通信できる。
この~headerの値は、次の ABNF `RFC5234$r と
<a href="~HTTPsem#abnf.extension">その~list拡張</a>【！~RFC7230#section-7】
`RFC7230$r を利用して表現される：
◎
The Timing-Allow-Origin HTTP response header field can be used to communicate a policy indicating origin(s) that are allowed to see values of attributes that would have been zero due to the cross-origin restrictions. The header's value is represented by the following ABNF [RFC5234] (using List Extension, [RFC7230]):
</p>

<pre class="bnf">
Timing-Allow-Origin = 1#( `origin-or-null$P / `wildcard$P )
</pre>

<p>
送信者は、複数個の `Timing-Allow-Origin$h ~headerを生成してもヨイ。
受信者は、複数個の `Timing-Allow-Origin$h ~headerに対しては、それらの~headerの値を順に~commaで分離して連結して， 1 個の~headerに結合してもヨイ。
◎
The sender MAY generate multiple Timing-Allow-Origin header fields. The recipient MAY combine multiple Timing-Allow-Origin header fields by appending each subsequent field value to the combined field value in order, separated by a comma.
</p>

<p>
`Timing-Allow-Origin$h
~headerは、`~TAO検査$にて処理され，各 属性は それに則って算出される。
◎
The Timing-Allow-Origin headers are processed in FETCH to compute the attributes accordingly.
</p>

<p class="note">注記：
`Timing-Allow-Origin$h ~headerは、~cacheされた応答の一部として到着することもある。
~cache再検証の事例では、
<a href="~HTTPcache#freshening.responses">~HTTP~cache法に則って</a>【！~RFC7234#section-4.3.4】，~headerの値は［
再検証~応答，そこに無ければ~cacheされた元の資源
］から来ることもある
◎
Note
The Timing-Allow-Origin header may arrive as part of a cached response. In case of cache revalidation, according to RFC 7234, the header's value may come from the revalidation response, or if not present there, from the original cached resource.
</p>

			</section>
			<section id="sec-iana-considerations">
<h4 title="IANA Considerations">4.5.2. IANA 考慮点</h4>

<p>
この節では、 `Timing-Allow-Origin$h を
<a href="~RFCx/rfc3864.html#section-4.2.2">暫定的な~message~header</a>
として登録する。
◎
This section registers Timing-Allow-Origin as a Provisional Message Header.
</p>

<ul>
	<li>
~header~field名：
`Timing-Allow-Origin^h
◎
Header field name:
Timing-Allow-Origin
</li>
	<li>
適用-可能な~protocol：
http
◎
Applicable protocol:
http
</li>
	<li>
位置付け：
暫定的
◎
Status:
provisional
</li>
	<li>
Author/Change controller：
<a href="https://www.w3.org/">W3C</a>
◎
Author/Change controller:
W3C
</li>
	<li>
仕様~文書：
<a href="#sec-timing-allow-origin">§ `Timing-Allow-Origin^h 応答~header</a>
◎
Specification document:
§ 4.5.1 Timing-Allow-Origin Response Header
</li>
</ul>

			</section>
			<section id="attribute-descriptions">
<h4 title="Resource Timing Attributes">4.5.3. 資源~計時~属性</h4>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I ~interfaceに定義される各種 計時~属性を次の図式に示す。
括弧内の属性は、資源が`非同一-生成元$から`~fetch$されているときは，可用でない。
~UAは、規範的でない時区間を許容するために，各 計時の合間に内部~処理を行ってもヨイ。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis may not be available when fetching cross-origin resources. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure><figcaption>
各種 計時~属性を示す図式（時間は下に向かって進行する）。
括弧内の属性は、資源が`~TAO検査$に失敗した場合は，可用でなくされ得ることを指示する。
◎
Figure 1 This figure illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis indicate that they may not be available if the resource fails the timing allow check algorithm.
</figcaption>

<div id="_time-table">
	<div>
<div style="top:-0.5em">← `startTime$m ／  ( `redirectStart$m )</div>
~redirect
<div style="bottom:-0.5em">← ( `redirectEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← `fetchStart$m</div>
~app~cache
	</div>
	<div>
<div style="top:-0.5em">← ( `domainLookupStart$m )</div>
~DNS
<div style="bottom:-0.5em">← ( `domainLookupEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← ( `connectStart$m )</div>
<div style="top:0.5em">← ( `secureConnectionStart$m )</div>
~TCP
<div style="bottom:-0.5em">← ( `connectEnd$m )</div>
	</div>
	<div style="margin-bottom:0">
<div style="top:-0.5em">← ( `requestStart$m )</div>
要請
	</div>
	<div style="margin-top:0">
<div style="top:-0.5em">← ( `responseStart$m )</div>
応答
<div style="bottom:-0.5em">← `responseEnd$m</div>
	</div>
◎
Resource Timing attributes
</div>
【！ timestamp-diagram.svg 】

<p class="trans-note">【
この訳では、原文の図式（ ~SVG ）を~HTMLと~CSSによる等価な図式に差し替えている。
】</p>
</figure>

			</section>
			<section id="marking-resource-timing">
<h4 title="Creating a resource timing entry">4.5.4 資源~計時~entryの作成-法</h4>

<div class="algo">
<p>
`資源~計時を~markする@
ときは、所与の
( `~fetch計時情報$ %計時情報, `文字列$ %要請された~URL, `文字列$ %起動元~種別, `大域~obj$enV %大域~obj )
に対し：
◎
To mark resource timing given a fetch timing info timingInfo, a DOMString requestedURL, a DOMString initiatorType and a global object global:
</p>
<ol>
	<li>
%~entry ~LET %大域~obj の`~Realm$に属する新たな `PerformanceResourceTiming$I ~obj
◎
Create a PerformanceResourceTiming object entry in global's realm.
</li>
	<li>
`資源~計時~entryを設定しておく$( %~entry, %起動元~種別, %要請された~URL, %計時情報 )
◎
Setup the resource timing entry for entry, given initiatorType, requestedURL and timingInfo.
</li>
	<li id="dfn-step-final-queue">
`処理能~entryを~queueする$( %~entry )
◎
Queue entry.
</li>
	<li>
`処理能~entry~bufferに~entryを追加する$( %~entry, %大域~obj 
【の`処理能~entry~buffer~map$[ `resource^l ] 】
の`処理能~entry~buffer$ )
◎
Add entry to global's performance entry buffer.
</li>
</ol>
</div>

<div class="algo">
<p>
`資源~計時~entryを設定しておく@
ときは、所与の
( 
`PerformanceResourceTiming$I %~entry,
`文字列$ %起動元~種別,
`文字列$ %要請された~URL,
`~fetch計時情報$ %計時情報
)
に対し，次を遂行する
⇒
%~entry の
⇒＃
`起動元~種別$pT ~SET %起動元~種別,
`要請~URL$pT ~SET %要請された~URL,
`計時情報$pT ~SET %計時情報
◎
To setup the resource timing entry for PerformanceResourceTiming entry given DOMStrring initiatorType, DOMString requestedURL, and fetch timing info timingInfo, perform the following steps:
• Set entry's initiator type to initiatorType.
• Set entry's requested URL to requestedURL.
• Set entry's timing info to timingInfo.
</p>
</div>

<div class="algo">
<p>
`~fetch時刻印を変換する@
ときは、所与の
( `DOMHighResTimeStamp$I %時刻印, `大域~obj$enV %大域~obj )
に対し，次を行う
⇒
~RET ［
%時刻印 ~EQ 0 ならば 0 ／
~ELSE_ 次の結果
］
⇒
`細かさを抑えた相対的な高分解能~時刻$( %時刻印, %大域~obj )
◎
To convert fetch timestamp given DOMHighResTimeStamp ts and global object global, do the following:
• If ts is zero, return zero.
• Otherwise, return the relative high resolution coarse time given ts and global.
</p>
</div>

			</section>
			<section id="sec-privacy-security">
<h4 title="Privacy and Security">4.5.5. ~privacyと~security</h4>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I ~interfaceは、資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、既定では`同一-生成元$ 施策が施行される。
その結果，一部の属性は、`~HTTP~fetch$にて述べられるとおり，
0 に設定される。
資源を供する側は、［
`Timing-Allow-Origin$h ~HTTP応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定する
］ことにより，資源~用のすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in HTTP fetch. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

<p>
悪意的な~web~siteは、第三者主体~web~site内の資源に対する~cache［
~hit／~miss
］の時機を測定することにより，利用者が第三者主体~siteを訪問したかどうかを決定し得る
— そのような~privacyの懸念は、
統計的~指紋収集（ `statistical fingerprinting^en ）と称される。
`PerformanceResourceTiming$I ~interfaceは，文書~内の資源の計時~情報を供するが、
`~HTTP~fetch$には非同一-生成元に対する制約があるので，この~privacyの懸念を［
今日すでにある，資源に対する `load^et ~eventから時機を測定して~cache［
~hit／~miss
］を決定する~~手法
］より悪化させるものにはならない。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the cross-origin restrictions in in HTTP Fetch prevent making this privacy concern any worse than it is today using the load event on resources to measure timing to determine cache hits and misses.
</p>

			</section>
		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に貢献された次の方々に謝意を：
</p>

<p lang="en-x-a0">
Thanks to

Anne Van Kesteren,
Annie Sullivan,
Arvind Jain,
Boris Zbarsky,
Darin Fisher,
Jason Weber,
Jonas Sicking,
James Simonsen,
Karen Anderson,
Kyle Scholz,
Nic Jansma,
Philippe Le Hegaret,
Sigbjørn Vik,
Steve Souders,
Todd Reifsteck,
Tony Gentilcore and
William Chan

for their contributions to this work.
</p>

	</section>
</main></div>
