<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>URL Pattern （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<style>
.literal,
.char-symbol {
	color: var(--literal-color-2);
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'sT':
	text += `<small>文字列</small>`;
	break;
case 'U':
//	text = `U+${text}`;
	text = `<span class="code-point">U+${text}</span> (<span class="char-symbol">&#x${text}</span>)`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'st':
	text += ' <small>state</small>';
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:URL
spec_date:2024-09-27
trans_update:2024-12-19
source_checked:240927
spec_status:LS
original_url:https://urlpattern.spec.whatwg.org/
	abbr_url:URLPATTERN
ref_id_prefix:biblio-
ref_id_lowercase:true
	site_nav:
copyright:,whatwg
trans_1st_pub:2024-12-09


●●class_map
E:error
st:parser-state
	U:code-point
A:abstract
jc:js-class
cn:cp-name
P:production
t:type

●●tag_map
I:code
m:code
E:code
upI:code
upO:code
upR:code
upC:code
c:code
jc:code
st:span
t:var
P:var
	V:var
	U:span
A:span
i:i
cite:cite
cn:span

●●original_id_map

●●mdn_urls

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
E.TypeError:~WEBIDL#exceptiondef-typeerror
USVString:~WEBIDL#idl-USVString
I.USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean
record:~WEBIDL#idl-record
sequence:~WEBIDL#idl-sequence
undefined:~WEBIDL#idl-undefined

I.URLPatternCompatible:#typedefdef-urlpatterncompatible
I.URLPatternInput:#typedefdef-urlpatterninput
I.URLPatternInit:#dictdef-urlpatterninit
upI.protocol:#dom-urlpatterninit-protocol
upI.username:#dom-urlpatterninit-username
upI.password:#dom-urlpatterninit-password
upI.hostname:#dom-urlpatterninit-hostname
upI.port:#dom-urlpatterninit-port
upI.pathname:#dom-urlpatterninit-pathname
upI.search:#dom-urlpatterninit-search
upI.hash:#dom-urlpatterninit-hash
upI.baseURL:#dom-urlpatterninit-baseurl

I.URLPatternOptions:#dictdef-urlpatternoptions
upO.ignoreCase:#dom-urlpatternoptions-ignorecase

I.URLPatternResult:#dictdef-urlpatternresult
upR.inputs:#dom-urlpatternresult-inputs
upR.protocol:#dom-urlpatternresult-protocol
upR.username:#dom-urlpatternresult-username
upR.password:#dom-urlpatternresult-password
upR.hostname:#dom-urlpatternresult-hostname
upR.port:#dom-urlpatternresult-port
upR.pathname:#dom-urlpatternresult-pathname
upR.search:#dom-urlpatternresult-search
upR.hash:#dom-urlpatternresult-hash

I.URLPatternComponentResult:#dictdef-urlpatterncomponentresult

upC.input:#dom-urlpatterncomponentresult-input
upC.groups:#dom-urlpatterncomponentresult-groups

I.URLPattern:#urlpattern
	%input:#dom-urlpattern-urlpattern-input-baseurl-options-input
	%baseURL:#dom-urlpattern-urlpattern-input-baseurl-options-baseurl
	%options:#dom-urlpattern-urlpattern-input-baseurl-options-options
	%input:#dom-urlpattern-urlpattern-input-options-input
	%options:#dom-urlpattern-urlpattern-input-options-options
	%input:#dom-urlpattern-test-input-baseurl-input
	%baseURL:#dom-urlpattern-test-input-baseurl-baseurl
	%input:#dom-urlpattern-exec-input-baseurl-input
	%baseURL:#dom-urlpattern-exec-input-baseurl-baseurl
m.new URLPattern:#dom-urlpattern-urlpattern
	m.new URLPattern:#dom-urlpattern-urlpattern-input-options
	constructor:#dom-urlpattern-urlpattern
	constructor:#dom-urlpattern-urlpattern-input-options
m.protocol:#dom-urlpattern-protocol
m.username:#dom-urlpattern-username
m.password:#dom-urlpattern-password
m.hostname:#dom-urlpattern-hostname
m.port:#dom-urlpattern-port
m.pathname:#dom-urlpattern-pathname
m.search:#dom-urlpattern-search
m.hash:#dom-urlpattern-hash
m.hasRegExpGroups:#dom-urlpattern-hasregexpgroups
m.test:#dom-urlpattern-test
m.exec:#dom-urlpattern-exec

	protocol:＠~URL1#dom-url-protocol

	●文字列

l.open:#token-type-open
l.close:#token-type-close
l.regexp:#token-type-regexp
l.name:#token-type-name
l.char:#token-type-char
l.escaped-char:#token-type-escaped-char
l.other-modifier:#token-type-other-modifier
l.asterisk:#token-type-asterisk
l.end:#token-type-end
l.invalid-char:#token-type-invalid-char

l.fixed-text:#part-type-fixed-text
l.~regexp0:#part-type-regexp
l.segment-wildcard:#part-type-segment-wildcard
l.full-wildcard:#part-type-full-wildcard

l.none:#part-modifier-none
l.optional:#part-modifier-optional
l.zero-or-more:#part-modifier-zero-or-more
l.one-or-more:#part-modifier-one-or-more

l.init:#constructor-string-parser-state-init
l.protocol:#constructor-string-parser-state-protocol
l.authority:#constructor-string-parser-state-authority
l.username:#constructor-string-parser-state-username
l.password:#constructor-string-parser-state-password
l.hostname:#constructor-string-parser-state-hostname
l.port:#constructor-string-parser-state-port
l.pathname:#constructor-string-parser-state-pathname
l.search:#constructor-string-parser-state-search
l.hash:#constructor-string-parser-state-hash
l.done:#constructor-string-parser-state-done

l.strict:#tokenize-policy-strict
l.lenient:#tokenize-policy-lenient

cite.path-to-regexp:https://github.com/pillarjs/path-to-regexp


	●用語

~URL~pattern:#url-pattern
結付けられた~URL~pattern:#urlpattern-associated-url-pattern
~port成分:#url-pattern-port-component
~pathname成分:#url-pattern-pathname-component
~search成分:#url-pattern-search-component
~hash成分:#url-pattern-hash-component
~protocol成分:#url-pattern-protocol-component
~username成分:#url-pattern-username-component
~password成分:#url-pattern-password-component
~hostname成分:#url-pattern-hostname-component
~URL~patternを作成する:#url-pattern-create

成分:#component
cP.~pattern文字列:#component-pattern-string
cP.正規表現:#component-regular-expression
cP.~group名~list:#component-group-name-list
cP.~regexp~groupを有するか:#component-has-regexp-groups
成分を~compileする:#compile-a-component

~URL~patternを照合する:#url-pattern-match
~URLPatternを初期化する:#urlpattern-initialize
~regexp~groupを有して:#url-pattern-has-regexp-groups
成分~照合-結果を作成する:#create-a-component-match-result
既定の~option群:#default-options
~hostname~option群:#hostname-options
~pathname~option群:#pathname-options
~protocol成分は特別~schemeに合致しているか否か:#protocol-component-matches-a-special-scheme
~hostname~patternは~IPv6~addressか否か:#hostname-pattern-is-an-ipv6-address
か否か

構築子~文字列~構文解析器:#constructor-string-parser
csP.入力:#constructor-string-parser-input
csP.~token~list:#constructor-string-parser-token-list
csP.結果:#constructor-string-parser-result
csP.成分~始端:#constructor-string-parser-component-start
csP.~token~index:#constructor-string-parser-token-index
csP.~token増分:#constructor-string-parser-token-increment
csP.~group深さ:#constructor-string-parser-group-depth
csP.~hostname~IPv6角括弧~深さ:#constructor-string-parser-hostname-ipv6-bracket-depth
csP.~protocolは特別~schemeに合致するか:#constructor-string-parser-protocol-matches-a-special-scheme-flag
csP.状態:#constructor-string-parser-state

構築子~文字列を構文解析する:#parse-a-constructor-string
状態を変更する:#change-state
構文解析器を巻戻す:#rewind
	#rewind-and-set-state → #rewind
安全な~tokenを取得する:#get-a-safe-token

非-特別~pattern文字か否か:#is-a-non-special-pattern-char
~protocol接尾辞か否か:#is-a-protocol-suffix
次回は~authority~slash列か否か:#next-is-authority-slashes
識別情報~終了子か否か:#is-an-identity-terminator
~password接頭辞か否か:#is-a-password-prefix
~port接頭辞か否か:#is-a-port-prefix
~pathname始端か否か:#is-a-pathname-start
~search接頭辞か否か:#is-a-search-prefix
~hash接頭辞か否か:#is-a-hash-prefix
~groupを開くか否か:#is-a-group-open
~groupを閉じるか否か:#is-a-group-close
~IPv6を開くか否か:#is-an-ipv6-open
~IPv6を閉じるか否か:#is-an-ipv6-close

成分~文字列を抽出する:#make-a-component-string
~protocolは特別~schemeに合致するかを算出する:#compute-protocol-matches-a-special-scheme-flag
~pattern文字列:#pattern-string
整形式:#pattern-string-well-formed
~token~list:#token-list

~token:#token
	~token~s:#token
tK.種別:#token-type
tK.~index:#token-index
tK.値:#token-value

~token化~施策:#tokenize-policy

~token化器:#tokenizer
tkz.入力:#tokenizer-input
tkz.施策:#tokenizer-policy
tkz.~token~list:#tokenizer-token-list
tkz.~index:#tokenizer-index
tkz.次回の~index:#tokenizer-next-index
tkz.符号位置:#tokenizer-code-point

~token化する:#tokenize
次回の符号位置を取得する:#get-the-next-code-point
~seekしてから次回の符号位置を取得する:#seek-and-get-the-next-code-point
~tokenを追加する:#add-a-token
既定の長さを伴う~tokenを追加する:#add-a-token-with-default-length
既定の位置と長さを伴う~tokenを追加する:#add-a-token-with-default-position-and-length
~token化時の~errorを処理する:#process-a-tokenizing-error
妥当な名前~符号位置:#is-a-valid-name-code-point
妥当な最初の名前~符号位置:#_is-a-valid-name-first-code-point
	~ASCIIか否か:#is-ascii
	→ `~ASCII符号位置$
~part~list:#part-list

~part:#part
pt.種別:#part-type
pt.値:#part-value
pt.改変子:#part-modifier
pt.名前:#part-name
pt.接頭辞:#part-prefix
pt.接尾辞:#part-suffix

~option群:#options
opt.区切子~符号位置:#options-delimiter-code-point
opt.接頭辞~符号位置:#options-prefix-code-point
opt.文字大小を無視するか:#options-ignore-case

符号化~callback:#encoding-callback

~pattern構文解析器:#pattern-parser
pP.~token~list:#pattern-parser-token-list
pP.符号化~callback:#pattern-parser-encoding-callback
pP.区分~wildcard~regexp:#pattern-parser-segment-wildcard-regexp
pP.~part~list:#pattern-parser-part-list
pP.処理待ち固定d値:#pattern-parser-pending-fixed-value
pP.~index:#pattern-parser-index
pP.次回の数量-名:#pattern-parser-next-numeric-name

~pattern文字列を構文解析する:#parse-a-pattern-string
全部的~wildcard~regexp値:#full-wildcard-regexp-value
区分~wildcard~regexpを生成する:#generate-a-segment-wildcard-regexp
~tokenを消費するよう試行する:#try-to-consume-a-token
改変子~tokenを消費するよう試行する:#try-to-consume-a-modifier-token
~regexp~tokenか~wildcard~tokenを消費するよう試行する:#try-to-consume-a-regexp-or-wildcard-token
要求される~tokenを消費する:#consume-a-required-token
~textを消費する:#consume-text
処理待ち固定d値から~partを追加する:#maybe-add-a-part-from-the-pending-fixed-value
~partを追加する:#add-a-part
重複な名前か否か:#is-a-duplicate-name
正規表現と名前~listを生成する:#generate-a-regular-expression-and-name-list
~regexp文字列を~escapeする:#escape-a-regexp-string
~pattern文字列を生成する:#generate-a-pattern-string
~pattern文字列を~escapeする:#escape-a-pattern-string
文字列を改変子へ変換する:#convert-a-modifier-to-a-string
~protocolを正準-化する:#canonicalize-a-protocol
~usernameを正準-化する:#canonicalize-a-username
~passwordを正準-化する:#canonicalize-a-password
~hostnameを正準-化する:#canonicalize-a-hostname
~IPv6~hostnameを正準-化する:#canonicalize-an-ipv6-hostname
~portを正準-化する:#canonicalize-a-port
~pathnameを正準-化する:#canonicalize-a-pathname
不透明な~pathnameを正準-化する:#canonicalize-an-opaque-pathname
~searchを正準-化する:#canonicalize-a-search
~hashを正準-化する:#canonicalize-a-hash
~URLPatternInitを処理する:#process-a-urlpatterninit
基底~URL文字列を処理する:#process-a-base-url-string
絶対~pathnameか否か:#is-an-absolute-pathname
~init用に~protocolを処理する:#process-protocol-for-init
~init用に~usernameを処理する:#process-username-for-init
~init用に~passwordを処理する:#process-password-for-init
~init用に~hostnameを処理する:#process-hostname-for-init
~init用に~portを処理する:#process-port-for-init
~init用に~pathnameを処理する:#process-pathname-for-init
~init用に~searchを処理する:#process-search-for-init
~init用に~hashを処理する:#process-hash-for-init
~Web~IDL値から~URLPattern~objを築く:#build-a-urlpattern-object-from-a-web-idl-value
~Web~IDL値から~URL~patternを築く:#build-a-url-pattern-from-a-web-idl-value
~Infra値から~URL~patternを築く:#build-a-url-pattern-from-an-infra-value
~HTTP有構造~field値から~URL~patternを築く:#build-a-url-pattern-from-an-http-structured-field-value

構築子~文字列の構文:#constructor-string-parsing

	●用語（外部
	●INFRA
文字:~INFRA#code-point
符号位置:~INFRA#code-point
文字列:~INFRA#string
~scalar値~文字列:~INFRA#scalar-value-string
~ASCII符号位置:~INFRA#ascii-code-point
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII文字列:~INFRA#ascii-string
真偽値:~INFRA#boolean
連結する:~INFRA#string-concatenate
符号位置~長さ:~INFRA#string-code-point-length
符号位置~部分文字列:~INFRA#code-point-substring
成す符号位置~部分文字列:~INFRA#code-point-substring-by-positions
終端までを成す符号位置~部分文字列:~INFRA#code-point-substring-to-the-end-of-the-string
~index群:~INFRA#list-get-the-indices
	不要）str.長さ:~INFRA#string-length
~list:~INFRA#list
~size:~INFRA#list-size
~map:~INFRA#ordered-map
付加する:~INFRA#list-append
map.~cloneする:~INFRA#map-clone
~JSON文字列を~Infra値に構文解析する:~INFRA#parse-a-json-string-to-an-infra-value
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

	~NEQ ε:~INFRA#map-exists
	~Assert:~INFRA#assert
	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue
	~EACH:~INFRA#list-iterate
	~EACH:~INFRA#map-iterate
	~WHILE:~INFRA#iteration-while


	●URL1
I.URL:~URL1#url
	V.~state-override:~URL1#basic-url-parser-state-override
	V.~URL:~URL1#basic-url-parser-url

~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
url.~host:~URL1#concept-url-host
url.~password:~URL1#concept-url-password
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~scheme:~URL1#concept-url-scheme
url.~username:~URL1#concept-url-username
url.素片:~URL1#concept-url-fragment
不透明な~path:~URL1#url-opaque-path
既定~port:~URL1#default-port
特別~scheme:~URL1#special-scheme
基本~URL構文解析器:~URL1#concept-basic-url-parser
~API用に~URL構文解析する:~URL1#_api-url-parser
~URL~pathを直列化する:~URL1#url-path-serializer
~URLの~passwordを設定する:~URL1#set-the-password
~URLの~usernameを設定する:~URL1#set-the-username
~URLを直列化する:~URL1#concept-url-serializer
~URL構文解析する:~URL1#concept-url-parser
整数を直列化する:~URL1#serialize-an-integer
~hostを直列化する:~URL1#concept-host-serializer

st.~hostname:~URL1#hostname-state
st.~path開始:~URL1#path-start-state
st.~port:~URL1#port-state
st.~query:~URL1#query-state
st.不透明~path:~URL1#cannot-be-a-base-url-path-state
st.素片:~URL1#fragment-state

	●WEBIDL
辞書:~WEBIDL#dfn-dictionary
辞書~member:~WEBIDL#dfn-dictionary-member
識別子:~WEBIDL#dfn-identifier
継承した辞書~群:~WEBIDL#dfn-inherited-dictionaries
演算:~WEBIDL#dfn-operation
特有~型:~WEBIDL#dfn-specific-type
	コレ:~WEBIDL#this
新たな~obj:~WEBIDLjs#new

	●TC39
jc.RegExp:~TC39M/text-processing.html#sec-regexp-regular-expression-objects
P.IdentifierPart:~TC39#prod-IdentifierPart
P.IdentifierStart:~TC39#prod-IdentifierStart
A.Get:~TC39M/abstract-operations.html#sec-get-o-p
A.RegExpBuiltinExec:~TC39M/text-processing.html#sec-regexpbuiltinexec
A.RegExpCreate:~TC39M/text-processing.html#sec-regexpcreate
A.ToString:~TC39M/abstract-operations.html#sec-tostring
~realm:~TC39M/executable-code-and-execution-contexts.html#realm

	●HTML
enV.~API用~基底~URL:~WAPI#api-base-url
文書~基底~URL:~HTMLurl#document-base-url
環境~設定群~obj:~WAPI#environment-settings-object
~URLを相対的に構文解析する:~HTMLurl#parse-a-url

	●他
有構造~field:~STRUCTURED-FIELDS#structured-field
	有構造~field値:~STRUCTURED-FIELDS#structured-field-name-value
~sf文字列:~STRUCTURED-FIELDS#sf-string
~sf内縁~list:~STRUCTURED-FIELDS#sf-inner-list


	_acks1:#_acks1
	_ipr1:#_ipr1

●●words_table1
TC39M:https://tc39.es/ecma262/multipage

APPEND: <span class="op">&lt;&lt;</span> 
sf:<sub>sf-</sub>
regexp0:regexp

●●words_table

URLPatternInit:
URLPattern:
Infra:

	●URL成分
	protocol
username::::ユーザ名
password::::パスワード
hostname::::ホスト名
	port
pathname::::パス名
search::::search
search::::クエリ
hash::::ハッシュ
authority:
区分:segment::~
番号:number:~
部分文字列:substring::~
IPv6:
識別情報:identity::~
数量-:numeric:~

	●文字
backslash::::バックスラッシュ
hex::16 進
角括弧:bracket::~
丸括弧:parentheses::~
波括弧:braces::~
dot:

	符号位置$:Unicode code point

	●正規表現
number:
compile::::コンパイル
正規表現:regular expression::~
regexp:
	~regexp:expression
wildcard:
	wildcard::::ワイルドカード
	~wildcard化:wildcarded
捕捉-:capture::~
捕捉:capture::~
	捕捉ありな:capturing
	捕捉ありな有名~group:named captured groups
	捕捉ありな有名~group:named capture groups
	捕捉なしな:non-capturing
	捕捉なしな:non capturing
open:
close:
終了子:terminator::~
改変子:modifier::~
整形式:well-formed::~
固定d:fixed::固定
固定的:fixed::固定
繰返可能:repeat 可能:繰り返し可能
	繰返可能にされた:repeated
	繰返可能になる:repeating
	0 回以上~繰返可能にする:"zero or more"
	1 回以上~繰返可能にする:"one or more"
	省略可能にする:optional
区切れ:deliminateでき:~
	括られ:enclosed
	~group化:grouping
	略式~文字列:shorthand
	略式~文字列:shorthand string
開く:openする:~
開き:open:~
閉じる:closeする:~

	●構文解析／直列化
増分:increment::~
深さ:depth::~
	~escape法:escaping
次回:next:~
次回の:next:~
seek:
part:
piece:
重複:duplicate:~
巻戻す:rewindする::巻き戻す
巻戻して:rewindして::巻き戻して
dummy::仮の
縮約-:collapse:~
字句-:lexical:~
貪欲:greedy::~
	貪欲に:greedily
	~token化法:tokenizing
	直前に:immediately preceding
	特別~scheme:特別~scheme~flag
	~authority~slash列:authority slashes
	抽出する:make
	~token化器:tokenizer
	state override

	●処理
init:
	初化:init:初期化／初期化子
処理待ち:pending:~
形式変換-:transform::~
機械:machine:~
切替える:switchする:切り替える
process::::プロセス
早急:eager:~
捏造な:fakeな:捏造した
入口:entry point:~

	行くことを確かめる:make sure to go to
	特別に扱われ:special case
	事例は、特別に扱われる:special-cased
	な限り早く:as soon as
	何もしない:do nothing
	探す:look for
	直行する:go straight to
	作成-時に:upon creation
	この段:This first section
	この段:This section
	設定し直:reset

	●変数
char:
歩数:skip:~

	%~search:search
	-:this
	%入力:input
	%基底~URL:baseURL
	%~option群:options
	%~init:init
	%処理-済み~init:processedInit
	%~compile~option群:compileOptions
	%~path~compile~option群:pathCompileOptions
	%符号化~callback:encoding callback
	%~part~list:part list
	%正規表現~文字列:regular expression string
	%名前~list:name list
	%~flag群:flags
	%正規表現:regular expression
	%~pattern文字列:pattern string
	%~regexp~groupを有するか:has regexp groups
	%~part:part
	%~pattern:pattern
	%~URL~pattern:urlPattern
	%基底~URL文字列:baseURLString
	%基底~URL文字列:-
	%~protocol:protocol
	%~username:username
	%~password:password
	%~hostname:hostname
	%~port:port
	%~port:-
	%~pathname:pathname
	%~hash:hash
	%入力~群:inputs
	%適用-結果:applyResult
	%~URL:url
	%~protocol実行-結果:protocolExecResult
	%~username実行-結果:usernameExecResult
	%~password実行-結果:passwordExecResult
	%~hostname実行-結果:hostnameExecResult
	%~port実行-結果:portExecResult
	%~pathname実行-結果:pathnameExecResult
	%~search実行-結果:searchExecResult
	%~hash実行-結果:hashExecResult
	%成分:component
	%成分~名:componentName
	%実行-結果:execResult
	%~group群:groups
	%~index:index
	%名前:name
	%値:value
	%~protocol成分:protocol component
	%~scheme:scheme
	%構文解析器:parser
	%固定d値:-
	%次回の状態:next state
	%新たな状態:new state
	%状態:state
	%状態:-
	%最後の~index:last index
	%~token:token
	%名前~token:name token
	%~token~index:-
	%~token~index ~MINUS 1:previous index
	%直前の~token:previous token
	%成分~始端~token:component start token
	-:component start input index
	-:end index
	%~protocol文字列:protocol string
	%施策:policy
	%~token化器:tokenizer
	%~escapeされる~index:escaped index
	%名前~位置:name position
	%名前~始端:name start
	-:first code point
	%妥当な符号位置か:valid code point
	%深さ:depth
	%戻り位置:temporary position
	%~regexp位置:regexp position
	%~regexp始端:regexp start
	%~errorか:error
	%一時的な位置:temporary position
	%~regexp長さ:regexp length
	%種別:type
	%次回の位置:next position
	%値~位置:value position
	%値~長さ:value length
	%算出d長さ:computed length
	%符号位置:code point
	-:first
	%~char~token:char token
	%~regexp~tokenか~wildcard~token:regexp or wildcard token
	%接頭辞:prefix
	%改変子~token:modifier token
	%固定d~token:fixed token
	%開き~token:open token
	%接尾辞:suffix
	%次回の~token:next token
	%符号化-済み値:encoded value
	%改変子:modifier
	%~regexp値:regexp value
	%符号化-済み接頭辞:encoded prefix
	%符号化-済み接尾辞:encoded suffix
	%~index~list:index list
	%前回の~part:previous part
	%次回の~part:next part
	%~custom名か:custom name
	%~group化は必要か:needs grouping
	%~dummy~URL:dummyURL
	%構文解析-結果:parseResult
	%結果:result
	%結果:-
	%~port値:portValue
	%~protocol値:protocolValue
	%先頭は~slashか:leading slash
	%改変-済み値:modified value
	%基底~host:baseHost
	%基底~port:-
	%基底~query:baseQuery
	%基底~素片:baseFragment
	%基底~URL~path:baseURLPath
	%~slash~index:slash index
	%値:strippedValue
	%~pathname値:pathnameValue
	%~realm:realm
	%生な~pattern:rawPattern
	%直列化-済み基底~URL:serializedBaseURL
	%~key:key
	%-:test result
	%-:special scheme list
	%-:input code points
	%歩数:skip

	●仕様
促進-:promote:~
単直:straightforward:簡単
簡潔:concise:~
尊重-:respect:~
分岐-:diverge:~
自明:trivial:~
過度:excessive:~
元々は:originalには:~
難解:esoteric:~
複雑:complicated:~
助言-:advise:~
不作為:inadvertent:~
	不作為に:inadvertantly
普通:ordinary:~
	普通に:ordinarily
普及な:popularな:普及している
立証-:prove:~
警告:warning::~
映出す:mirrorする:映し出す
niche::::ニッチ

	^en:plumb
	主に:largely
	本当に:real
	結果になる:ever end up
	ほぼ見込まれない:unlikely
	ずっと:dramatically more
	見込みが高い:likely
	たぶん:likely
	それなりに:fairly
	余地を残す:leave room
	加わった:gain
	作者が〜を踏まずに済むよう:avoid the need for authors to take
	共通的なものではない:uncommon
	この仕様:URLPattern specification
	かまわない:free to
	できない:prevent us
	外され:lift
	に注意:its important that
	したい:we would like
	代償を払う:paying 〜 penalty
	この標準:URL Pattern Standard
	に由来する:come from
	否定:negated
	問われる:matterする
	捉えれる:be thought of
	アリ性:possibility
	その実装:An implementing algorithm
	そのことから:which has indicated
	良い:good

	●未分類
給-:supply:~

	のと同じく:just as
	一緒に:along with
	どこまで:how far
	省略された場合:in the absence of
	成分ごと:component-by-component basis
	最後に，:finally
	0 個または 1 個:at most one
	より前に現れる:earlier
	現れな:appear
	現れる:appear
	含む:includeする
	対応-:correspond
	-:write
	回:time
	先頭:leading
	先頭:initial
	先頭:at the top
	末尾:final
	次に，:next, we
	1 個だけ:as little as
	1 個まで:at most one
	それまでの:previous
	始まる:begin
	始まる:beginning
	書かれた:written
	な限り短い:shortest
	~inclusive
	を有するようにされる:made
	高-:high-
	アリなものすべて:as much as possible
	どれも，1 個だけ在ることも無いことも:could be zero to all of
	な限り多く:as much
	より厳密でない:less strict
	在るようになった場合:If that changes
	ある 〜 それより:less 〜 more
	何に類する what sorts of
	初めから:readily
	0 個の値:zero values
	非-:non-
	非:non
	他所では:the rest
	一部:part
	別に用意された:parallel

●●ref_normative

[ECMA-262]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC8941]
    M. Nottingham; P-H. Kamp. ＜Structured Field Values for HTTP＞. February 2021. Proposed Standard. URL: https://httpwg.org/specs/rfc8941.html
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[SPECULATION-RULES]
    ＜Speculation Rules＞. Draft Community Group Report. URL: https://wicg.github.io/nav-speculation/speculation-rules.html

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">URL Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/urlpattern">GitHub whatwg/urlpattern</a> (<a href="https://github.com/whatwg/urlpattern/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/urlpattern/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>
Commits:
	<a href="https://github.com/whatwg/urlpattern/commits">GitHub whatwg/urlpattern/commits</a>
	<a href="/commit-snapshots/502f120278199c5558ec38566087bf8ecb184896/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/urlpatterns">@urlpatterns</a>
Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/urlpattern">web-platform-tests urlpattern/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/urlpattern">ongoing work</a>)

各国語翻訳（非規範的）
	<a href="https://htmlspecs.com/urlpattern/" hreflang="zh-hans" lang="zh-hans" rel="alternate">简体中文</a>
	日本語（このページ）

</script>
</head>
<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBzdHJva2U9IiMzYzc5MGEiIHN0cm9rZS13aWR0aD0iOCIgZD0iTTUwIDM0djMyTTM2IDQwbDI4IDIwTTY0IDQwTDM2IDYwIi8+Cjwvc3ZnPgo="
></a>

	<hgroup>
<h1>URL Pattern</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この標準は、
~web~platform用に［
簡便な~pattern構文に基づいて~URLを照合する
］ための~primitiveを供する。
◎
The URL Pattern Standard provides a web platform primitive for matching URLs based on a convenient pattern syntax.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
この仕様に現れる “~number型” の値は、
どれも整数であり，ほとんどは負でない整数しかとり得ないように見受けられるが、
そのことは，各~algoの詳細を追わないと判明しない。
</p>

	</section>

<main id="MAIN0">

	<section id="urlpatterns">
<h2 title="URL patterns">1. ~URL~pattern</h2>

		<section id="introduction">
<h3 title="Introduction">1.1. 序論</h3>

<p>
`~URL~pattern$は、
いくつかの［
`~pattern文字列$を表現する`成分$
］からなる。
各`~pattern文字列$は、
`~URL~record$を成す対応する成分に対し照合することもできる。
◎
A URL pattern consists of several components, each of which represents a pattern which could be matched against the corresponding component of a URL.
</p>

<p>
`~URL~pattern$は
⇒＃
各~成分~用に文字列を利用して構築できる。
`略式~文字列＠#constructor-string-parsing$から構築できる。
任意選択で，ある基底~URLに相対的に解決できる。
◎
It can be constructed using a string for each component, or from a shorthand string. It can optionally be resolved relative to a base URL.
</p>

<div class="example">
<p>
略式~文字列
⇒
`https://example.com/:category/*^l
◎終
に対応する各~成分は：
◎
The shorthand "https://example.com/:category/*" corresponds to the following components:
</p>

<div>
<table><tbody>
<tr><td>`~protocol成分$
</td><td>`https^l

</td></tr><tr><td>`~username成分$
</td><td>`*^l

</td></tr><tr><td>`~password成分$
</td><td>`*^l

</td></tr><tr><td>`~hostname成分$
</td><td>`example.com^l

</td></tr><tr><td>`~port成分$
</td><td>""

</td></tr><tr><td>`~pathname成分$
</td><td>`/:category/*^l

</td></tr><tr><td>`~search成分$
</td><td>`*^l

</td></tr><tr><td>`~hash成分$
</td><td>`*^l
</td></tr></tbody></table>
◎
protocol
• "https"
username
• "*"
password
• "*"
hostname
• "example.com"
port
• ""
pathname
• "/:category/*"
search
• "*"
hash
• "*"
</div>

<p>
それは、
次に挙げる~URLには合致する：
◎
It matches the following URLs:
</p>
<ul>
	<li>
`https://example.com/products/^c
</li>
	<li>
`https://example.com/blog/our-greatest-product-ever^c
</li>
</ul>

<p>
それは、
次に挙げる~URLには合致しない：
◎
It does not match the following URLs:
</p>
<ul>
	<li>
`https://example.com/^c
</li>
	<li>
`http://example.com/products/^c
</li>
	<li>
`https://example.com:8443/blog/our-greatest-product-ever^c
</li>
</ul>

<p>
これは、
それなりに単純な~patternである
— それは、
ほとんどの成分において［
ある文字列に正確に合致するか，どの文字列も許容する（ `*^l ）
］ことを要求する。
`~pathname成分$は、
`/^c で分離された 2 個~以上の~path成分を伴うどの~pathにも合致する
— 1 個目のそれは、
`category^l として捕捉される。
◎
This is a fairly simple pattern which requires most components to either match an exact string, or allows any string ("*"). The pathname component matches any path with at least two /-separated path components, the first of which is captured as "category".
</p>
</div>

<div class="example">
<p>
略式~文字列
⇒
`http{s}?://{:subdomain.}?shop.example/products/:id([0-9]+)#reviews^l
◎終
に対応する各~成分は：
◎
The shorthand "http{s}?://{:subdomain.}?shop.example/products/:id([0-9]+)#reviews" corresponds to the following components:
</p>

<div>
<table><tbody>
<tr><td>`~protocol成分$
</td><td>`http{s}?^l

</td></tr><tr><td>`~username成分$
</td><td>`*^l

</td></tr><tr><td>`~password成分$
</td><td>`*^l

</td></tr><tr><td>`~hostname成分$
</td><td>`{:subdomain.}?shop.example^l

</td></tr><tr><td>`~port成分$
</td><td>""

</td></tr><tr><td>`~pathname成分$
</td><td>`/products/:id([0-9]+)^l

</td></tr><tr><td>`~search成分$
</td><td>""

</td></tr><tr><td>`~hash成分$
</td><td>`reviews^l
</td></tr></tbody></table>
◎
protocol
• "http{s}?"
username
• "*"
password
• "*"
hostname
• "{:subdomain.}?shop.example"
port
• ""
pathname
• "/products/:id([0-9]+)"
search
• ""
hash
• "reviews"
</div>

<p>
それは、
次に挙げる~URLには合致する：
◎
It matches the following URLs:
</p>
<ul>
	<li>
`https://shop.example/products/74205#reviews^c
</li>
	<li>
<code>https://kathryn@voyager.shop.example/products/74656#reviews</code>
</li>
	<li>
`http://insecure.shop.example/products/1701#reviews^c
</li>
</ul>

<p>
それは、
次に挙げる~URLには合致しない：
◎
It does not match the following URLs:
</p>
<ul>
	<li>
`https://shop.example/products/2000^c
</li>
	<li>
`http://shop.example:8080/products/0#reviews^c
</li>
	<li>
`https://nx.shop.example/products/01?speed=5#reviews^c
</li>
	<li>
`https://shop.example/products/chair#reviews^c
</li>
</ul>

<p>
これは、
より複雑な~patternであり，次を含む：
◎
This is a more complicated pattern which includes:
</p>
<ul>
	<li>
`?^c で~markされた 2 個の `optional$l ~part
（波括弧（ `{…}^c ）は、
正確に何が省略可能にされるかを一義的にするため必要になる）。
◎
optional parts marked with ? (braces are needed to make it unambiguous exactly what is optional), and
</li>
	<li>
`id^l と命名された `~regexp0$l ~part
— それは、
何に類する部分文字列に合致するかを定義するために，ある正規表現を利用する
（丸括弧は、［
それが正規表現であり，当の~regexp自体の一部を成さないもの
］として~markするために要求される）。
◎
a regexp part named "id" which uses a regular expression to define what sorts of substrings match (the parentheses are required to mark it as a regular expression, and are not part of the regexp itself).
</li>
</ul>
</div>

<div class="example">
<p>
基底~URL
⇒
`https://discussion.example/forum/?page=2^l
◎終
を伴う下では、
略式~文字列
⇒
`../admin/*^l
◎終
に対応する各~成分は：
◎
The shorthand "../admin/*" with the base URL "https://discussion.example/forum/?page=2" corresponds to the following components:
</p>

<div>
<table><tbody>
<tr><td>`~protocol成分$
</td><td>`https^l

</td></tr><tr><td>`~username成分$
</td><td>`*^l

</td></tr><tr><td>`~password成分$
</td><td>`*^l

</td></tr><tr><td>`~hostname成分$
</td><td>`discussion.example^l

</td></tr><tr><td>`~port成分$
</td><td>""

</td></tr><tr><td>`~pathname成分$
</td><td>`/admin/*^l

</td></tr><tr><td>`~search成分$
</td><td>`*^l

</td></tr><tr><td>`~hash成分$
</td><td>`*^l
</td></tr></tbody></table>
◎
protocol
• "https"
username
• "*"
password
• "*"
hostname
• "discussion.example"
port
• ""
pathname
• "/admin/*"
search
• "*"
hash
• "*"
</div>

<p>
それは、
次に挙げる~URLには合致する：
◎
It matches the following URLs:
</p>
<ul>
	<li>
`https://discussion.example/admin/^c
</li>
	<li>
<code>https://edd:librarian@discussion.example/admin/update?id=1</code>
</li>
</ul>

<p>
それは、
次に挙げる~URLには合致しない：
◎
It does not match the following URLs:
</p>
<ul>
	<li>
`https://discussion.example/forum/admin/^c
</li>
	<li>
`http://discussion.example:8080/admin/update?id=1^c
</li>
</ul>

<p>
この~patternは、
~pathnameが，基底~URLに対し相対的に どう
— 相対~URLと類似な仕方で —
解決されるかをデモる。
◎
This pattern demonstrates how pathnames are resolved relative to a base URL, in a similar way to relative URLs.
</p>
</div>

		</section>
		<section id="urlpattern-class">
<h3 title="The URLPattern class">1.2 `URLPattern^I ~class</h3>

<pre class="idl">
typedef (`USVString$ or `URLPatternInit$I) `URLPatternInput@I;

[`Exposed$=(Window,Worker)]
interface `URLPattern@I {
  `constructor＠#dom-urlpattern-urlpattern$(`URLPatternInput$I %input, `USVString$ %baseURL, optional `URLPatternOptions$I %options = {});
  `constructor＠#dom-urlpattern-urlpattern-input-options$(optional `URLPatternInput$I %input = {}, optional `URLPatternOptions$I %options = {});

  `boolean$ `test$m(optional `URLPatternInput$I %input = {}, optional `USVString$ %baseURL);

  `URLPatternResult$I? `exec$m(optional `URLPatternInput$I %input = {}, optional `USVString$ %baseURL);

  readonly attribute `USVString$ `protocol$m;
  readonly attribute `USVString$ `username$m;
  readonly attribute `USVString$ `password$m;
  readonly attribute `USVString$ `hostname$m;
  readonly attribute `USVString$ `port$m;
  readonly attribute `USVString$ `pathname$m;
  readonly attribute `USVString$ `search$m;
  readonly attribute `USVString$ `hash$m;

  readonly attribute `boolean$ `hasRegExpGroups$m;
};

dictionary `URLPatternInit@I {
  `USVString$ `protocol@upI;
  `USVString$ `username@upI;
  `USVString$ `password@upI;
  `USVString$ `hostname@upI;
  `USVString$ `port@upI;
  `USVString$ `pathname@upI;
  `USVString$ `search@upI;
  `USVString$ `hash@upI;
  `USVString$ `baseURL@upI;
};

dictionary `URLPatternOptions@I {
  `boolean$ `ignoreCase@upO = false;
};

dictionary `URLPatternResult@I {
  `sequence$&lt;`URLPatternInput$I&gt; `inputs@upR;

  `URLPatternComponentResult$I `protocol@upR;
  `URLPatternComponentResult$I `username@upR;
  `URLPatternComponentResult$I `password@upR;
  `URLPatternComponentResult$I `hostname@upR;
  `URLPatternComponentResult$I `port@upR;
  `URLPatternComponentResult$I `pathname@upR;
  `URLPatternComponentResult$I `search@upR;
  `URLPatternComponentResult$I `hash@upR;
};

dictionary `URLPatternComponentResult@I {
  `USVString$ `input@upC;
  `record$&lt;`USVString$, (`USVString$ or `undefined$)&gt; `groups@upC;
};
</pre>

<p>
各 `URLPattern$I ~objには、
それに
`結付けられた~URL~pattern@
と称される，ある`~URL~pattern$が結付けられる。
◎
Each URLPattern has an associated URL pattern, a URL pattern.
</p>

<dl class="domintro">
	<dt>
%urlPattern = `new URLPattern(input, baseURL[, options])$m
◎
↓</dt>
	<dt>
%urlPattern = `new URLPattern([ input[, options] ])＠#dom-urlpattern-urlpattern-input-options$m
◎
↓</dt>
	<dd>
新たな `URLPattern$I ~objを構築する。
◎
urlPattern = new URLPattern(input)
• Constructs a new URLPattern object.＼
</dd>
	<dd>
<p>
%input は、
次のいずれかをとる：
</p>
		<ul>
			<li>
1 個以上の成分~用の~pattern構文を包含している~URL文字列。
</li>
			<li>
各~URL成分（例：~hostname, ~pathname, 等々）用に別々な~patternを包含している~obj
【 `URLPatternInit$I 】。
欠落な各~成分は、
既定では，~wildcard~patternになる。
加えて、
%input は `baseURL$upI ~propを包含し得る
— それは、
欠落な成分~用に静的な~text~patternを供する。
</li>
		</ul>
◎
• The input is an object containing separate patterns for each URL component; e.g. hostname, pathname, etc. Missing components will default to a wildcard pattern. In addition, input can contain a baseURL property that provides static text patterns for any missing components.
◎
urlPattern = new URLPattern(patternString, baseURL)
• Constructs a new URLPattern object.＼
• patternString is a URL string containing pattern syntax for one or more components.＼
</dd>
	<dd>
<p>
%baseURL が供された場合：
◎
• If baseURL is provided,＼
</p>
		<ul>
			<li>
<p>
%input は，それに相対的にし得る。
【 `baseURL$upI ~propと同じに働く。】
◎
then patternString can be relative.＼
</p>

<p class="trans-note">【
この場合、
%input には文字列を与える必要がある
— ~IDLにおいては `URLPatternInit$I もとり得るが。
さもなければ、
例外が投出される。
】</p>
			</li>
			<li>
<p>
構築子は、
どの成分に対しても，
常に，少なくとも空~文字列に設定する
— 当の成分を既定で~wildcard~patternに設定することはない。
◎
This constructor will always set at least an empty string value and does not default any components to wildcard patterns.
</p>

<p class="trans-note">【
すなわち、
%input 内に 当の`成分$用の値が供されなかった場合には，
その`~pattern文字列$cPを空~文字列に設定する。
】</p>
			</li>
		</ul>
	</dd>
	<dd>
%options は、［
各~成分がどう照合されるかに影響し得る，追加的な環境設定~option群
］を包含している~objである。
この~objを成す~propは、
現時点では `ignoreCase$upO しかない
— それを ~T に設定すれば、
文字大小無視な照合-法が可能化される。
他の場合（ %options が省略された場合も）、
常に，文字大小区別で照合されることに注意。
◎
↑ urlPattern = new URLPattern(input, options)
• Constructs a new URLPattern object.＼
◎
• The options is an object containing the additional configuration options that can affect how the components are matched. Currently it has only one property ignoreCase which can be set to true to enable case-insensitive matching.
◎
• Note that by default, that is in the absence of the options argument, matching is always case-sensitive.
◎
↑ urlPattern = new URLPattern(patternString, baseURL, options)
• Constructs a new URLPattern object. This overrides supports a URLPatternOptions object when constructing a pattern from a patternString object, describing the patterns for individual components, and base URL.
</dd>

	<dt>
%matches = %urlPattern.`test(input[, baseURL])$m
◎
↓</dt>
	<dd>
<p>
%urlPattern が所与の引数に合致するか否かを~testする。
</p>

<p>
%input は、
次のいずれかをとる：
</p>
		<ul>
			<li>
~URL文字列。
</li>
			<li>
各~URL成分
（例：~hostname, ~pathname, 等々）
を表現する文字列たちを包含する~obj【 `URLPatternInit$I 】。
欠落な各~成分は、
空~文字列として扱われる。
加えて、
%input は `baseURL$upI ~propを包含し得る
— それは、
欠落な各~成分~用の値を供する。
</li>
		</ul>
<p>
%urlPattern が成分ごとに %input に合致するならば ~T が返され，
他の場合は ~F が返される。
</p>
◎
matches = urlPattern.test(input)
• Tests if urlPattern matches the given arguments. The input is an object containing strings representing each URL component; e.g. hostname, pathname, etc. Missing components are treated as empty strings. In addition, input can contain a baseURL property that provides values for any missing components. If urlPattern matches the input on a component-by-component basis then true is returned. Otherwise, false is returned.
◎
matches = urlPattern.test(url, baseURL)
• Tests if urlPattern matches the given arguments. url is a URL string.＼
</dd>
	<dd>
<p>
%baseURL が供された場合、
%input は，それに相対的にし得る。
</p>

<p class="trans-note">【
この場合、
%input には文字列を与える必要がある
— ~IDLにおいては `URLPatternInit$I もとり得るが。
さもなければ、
例外が投出される。
】</p>
◎
• If baseURL is provided, then url can be relative.
•  If urlPattern matches the input on a component-by-component basis then true is returned. Otherwise, false is returned.
</dd>

	<dt>
%result = %urlPattern.`exec(input[, baseURL])$m
◎
↓</dt>
	<dd>
<p>
所与の引数に対し %urlPattern を実行する。
</p>

<p>
%input は、
次のいずれかをとる：
</p>
		<ul>
			<li>
~URL文字列。
</li>
			<li>
各~URL成分
（例：~hostname, ~pathname, 等々）
を表現する文字列たちを包含する~obj【 `URLPatternInit$I 】。
欠落な各~成分は、
空~文字列として扱われる。
加えて、
%input は `baseURL$upI ~propを包含し得る
— それは、
欠落な各~成分~用の値を供する。
</li>
		</ul>

<p>
%urlPattern が成分ごとに %input に合致するならば結果を包含している~obj【 `URLPatternResult$I 】が返され，
他の場合は ~NULL が返される。
合致した~group値は、
%result ~objの中の成分ごとの~group~obj
（例： 【当の~groupが `id^c と命名されたならば】
<code>%result【！matches】.`pathname$upR.`groups$upC.id</code> ）
内に包含される。
</p>
◎
result = urlPattern.exec(input)
• Executes the urlPattern against the given arguments. The input is an object containing strings representing each URL component; e.g. hostname, pathname, etc. Missing components are treated as empty strings. In addition, input can contain a baseURL property that provides values for any missing components.
• If urlPattern matches the input on a component-by-component basis then an object is returned containing the results. Matched group values are contained in per-component group objects within the result object; e.g. matches.pathname.groups.id. If urlPattern does not match the input, then result is null.
◎
result = urlPattern.exec(url, baseURL)
• Executes the urlPattern against the given arguments. url is a URL string.＼
</dd>
	<dd>
<p>
%baseURL が供された場合、
%input は，それに相対的にし得る。
</p>

<p class="trans-note">【
この場合、
%input には文字列を与える必要がある
— ~IDLにおいては `URLPatternInit$I もとり得るが。
さもなければ、
例外が投出される。
】</p>
◎
• If baseURL is provided, then input can be relative.
• ↑ If urlPattern matches the input on a component-by-component basis then an object is returned containing the results. Matched group values are contained in per-component group objects within the result object; e.g. matches.pathname.groups.id. If urlPattern does not match the input, then result is null.
</dd>

	<dt>%urlPattern.`protocol$m</dt>
	<dd>
%urlPattern の正規化-済み~protocol~pattern文字列を返す。
◎
Returns urlPattern’s normalized protocol pattern string.
</dd>

	<dt>%urlPattern.`username$m</dt>
	<dd>
%urlPattern の正規化-済み~username~pattern文字列を返す。
◎
Returns urlPattern’s normalized username pattern string.
</dd>

	<dt>%urlPattern.`password$m</dt>
	<dd>
%urlPattern の正規化-済み~password~pattern文字列を返す。
◎
Returns urlPattern’s normalized password pattern string.
</dd>

	<dt>%urlPattern.`hostname$m</dt>
	<dd>
%urlPattern の正規化-済み~hostname~pattern文字列を返す。
◎
Returns urlPattern’s normalized hostname pattern string.
</dd>

	<dt>%urlPattern.`port$m</dt>
	<dd>
%urlPattern の正規化-済み~port~pattern文字列を返す。
◎
Returns urlPattern’s normalized port pattern string.
</dd>

	<dt>%urlPattern.`pathname$m</dt>
	<dd>
%urlPattern の正規化-済み~pathname~pattern文字列を返す。
◎
Returns urlPattern’s normalized pathname pattern string.
</dd>

	<dt>%urlPattern.`search$m</dt>
	<dd>
%urlPattern の正規化-済み~search~pattern文字列を返す。
◎
Returns urlPattern’s normalized search pattern string.
</dd>

	<dt>%urlPattern.`hash$m</dt>
	<dd>
%urlPattern の正規化-済み~hash~pattern文字列を返す。
◎
Returns urlPattern’s normalized hash pattern string.
</dd>

	<dt>%urlPattern.`hasRegExpGroups$m</dt>
	<dd>
%urlPattern が正規表現~照合を利用する~group（たち）を包含するか否かを返す。
◎
Returns whether urlPattern contains one or more groups which uses regular expression matching.
</dd>
</dl>

<div>
<div class="algo">
`new URLPattern(input, baseURL, options)@m
構築子~手続きは
⇒
コレ に`結付けられた~URL~pattern$ ~SET `~URL~patternを作成する$( %input, %baseURL, %options )
【！~URLPatternを初期化する】
</div>

<div class="algo">
`new URLPattern(input, options)＠#dom-urlpattern-urlpattern-input-options@m
構築子~手続きは
⇒
コレ に`結付けられた~URL~pattern$ ~SET `~URL~patternを作成する$( %input, ~NULL, %options )
【！~URLPatternを初期化する】
</div>

◎
The new URLPattern(input, baseURL, options) constructor steps are:
• Run initialize given this, input, baseURL, and options.
◎
The new URLPattern(input, options) constructor steps are:
• Run initialize given this, input, null, and options.
◎
To initialize a URLPattern given a URLPattern this, URLPatternInput input, string or null baseURL, and URLPatternOptions options:
• Set this’s associated URL pattern to the result of create given input, baseURL, and options.
</div>

<div class="algo">
`protocol@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~protocol成分$の`~pattern文字列$cP
◎
The protocol getter steps are:
• Return this's associated URL pattern's protocol component's pattern string.
</div>

<div class="algo">
`username@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~username成分$の`~pattern文字列$cP
◎
The username getter steps are:
• Return this's associated URL pattern's username component's pattern string.
</div>

<div class="algo">
`password@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~password成分$の`~pattern文字列$cP
◎
The password getter steps are:
• Return this's associated URL pattern's password component's pattern string.
</div>

<div class="algo">
`hostname@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~hostname成分$の`~pattern文字列$cP
◎
The hostname getter steps are:
• Return this's associated URL pattern's hostname component's pattern string.
</div>

<div class="algo">
`port@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~port成分$の`~pattern文字列$cP
◎
The port getter steps are:
• Return this's associated URL pattern's port component's pattern string.
</div>

<div class="algo">
`pathname@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~pathname成分$の`~pattern文字列$cP
◎
The pathname getter steps are:
• Return this's associated URL pattern's pathname component's pattern string.
</div>

<div class="algo">
`search@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~search成分$の`~pattern文字列$cP
◎
The search getter steps are:
• Return this's associated URL pattern's search component's pattern string.
</div>

<div class="algo">
`hash@m
取得子~手続きは
⇒
~RET コレに`結付けられた~URL~pattern$の`~hash成分$の`~pattern文字列$cP
◎
The hash getter steps are:
• Return this's associated URL pattern's hash component's pattern string.
</div>

<div class="algo">
`hasRegExpGroups@m
取得子~手続きは
⇒
~RET ~IS［
コレに`結付けられた~URL~pattern$は`~regexp~groupを有して$いる
］
◎
The hasRegExpGroups getter steps are:
• If this's associated URL pattern's has regexp groups, then return true.
• Return false.
</div>

<div class="algo">
`test(input, baseURL)@m
~method手続きは
⇒
~RET ~IS［
次の結果 ~NEQ ~NULL
］
⇒
`~URL~patternを照合する$( コレに`結付けられた~URL~pattern$, %input, %baseURL【！if given】 )
◎
The test(input, baseURL) method steps are:
• Let result be the result of match given this's associated URL pattern, input, and baseURL if given.
• If result is null, return false.
• Return true.
</div>

<div class="algo">
`exec(input, baseURL)@m
~method手続きは
⇒
~RET `~URL~patternを照合する$( コレに`結付けられた~URL~pattern$, %input, %baseURL【！if given】 )
◎
The exec(input, baseURL) method steps are:
• Return the result of match given this's associated URL pattern, input, and baseURL if given.
</div>

		</section>
		<section id="url-pattern-struct">
<h3 title="The URL pattern struct">1.3. ~URL~pattern構造体</h3>

<p>
`~URL~pattern@
は、
次に挙げる`~item$sctからなる`構造体$である：
◎
A URL pattern is a struct with the following items:
</p>
<ul>
	<li>
`~protocol成分@
⇒
ある`成分$
◎
protocol component, a component
</li>
	<li>
`~username成分@
⇒
ある`成分$
◎
username component, a component
</li>
	<li>
`~password成分@
⇒
ある`成分$
◎
password component, a component
</li>
	<li>
`~hostname成分@
⇒
ある`成分$
◎
hostname component, a component
</li>
	<li>
`~port成分@
⇒
ある`成分$
◎
port component, a component
</li>
	<li>
`~pathname成分@
⇒
ある`成分$
◎
pathname component, a component
</li>
	<li>
<p>
`~search成分@
⇒
ある`成分$
◎
search component, a component
</p>

<p class="trans-note">【
原文では，
（~APIにおける名前 `search^c と合致するよう）
“`search^en 成分” と記されるが、
~URLの`~query$url成分に対応するので，
この訳では一律に “クエリ” と訳すことにする。
】</p>
	</li>
	<li>
`~hash成分@
⇒
ある`成分$
◎
hash component, a component
</li>
</ul>

<p>
`成分@
は、
次に挙げる`~item$sctからなる`構造体$である：
◎
A component is a struct with the following items:
</p>
<ul>
	<li>
`~pattern文字列@cP
⇒
ある`整形式$な`~pattern文字列$
◎
pattern string, a well formed pattern string
</li>
	<li>
`正規表現@cP
⇒
ある `RegExp$jc
◎
regular expression, a RegExp
</li>
	<li>
`~group名~list@cP
⇒
文字列たちが成すある`~list$
◎
group name list, a list of strings
</li>
	<li>
`~regexp~groupを有するか@cP
⇒
`真偽値$
◎
has regexp groups, a boolean
</li>
</ul>

		</section>
		<section id="high-level-operations">
<h3 title="High-level operations">1.4. 高-~levelな演算</h3>

<div class="algo">
<p>
`~URL~patternを作成する@
~algoは、
所与の
( `URLPatternInput$I %入力, ［
文字列／~NULL
］ %基底~URL, `URLPatternOptions$I %~option群 )
に対し：
◎
To create a URL pattern given a URLPatternInput input, string or null baseURL, and URLPatternOptions options:
</p>
<ol>
	<li>
%~init ~LET ~NULL
◎
Let init be null.
</li>
	<li>
<p>
~IF［
%入力 は `USVString$I 【！`~scalar値~文字列$】である
］：
◎
If input is a scalar value string then:
</p>
		<ol>
			<li>
%~init ~SET `構築子~文字列を構文解析する$( %入力 )
◎
Set init to the result of running parse a constructor string given input.
</li>
			<li>
~IF［
%基底~URL ~EQ ~NULL
］
⇒
~IF［
%~init[ "`protocol$upI" ] ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If baseURL is null and init["protocol"] does not exist, then throw a TypeError.
</li>
			<li>
~ELSE
⇒
%~init[ "`baseURL$upI" ] ~SET %基底~URL
◎
If baseURL is not null, set init["baseURL"] to baseURL.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%入力 は `URLPatternInit$I である
◎
Assert: input is a URLPatternInit.
</li>
			<li>
~IF［
%基底~URL ~NEQ ~NULL
］
⇒
~THROW `TypeError$E
◎
If baseURL is not null, then throw a TypeError.
</li>
			<li>
%~init ~SET %入力
◎
Set init to input.
</li>
		</ol>
	</li>
	<li>
%処理-済み~init ~LET `~URLPatternInitを処理する$( ↓ )
⇒＃
%~init,
`pattern^l,
~NULL,
~NULL,
~NULL,
~NULL,
~NULL,
~NULL,
~NULL,
~NULL
◎
Let processedInit be the result of process a URLPatternInit given init, "pattern", null, null, null, null, null, null, null, and null.
</li>
	<li>
« "`protocol$upI", "`username$upI", "`password$upI", "`hostname$upI", "`port$upI", "`pathname$upI", "`search$upI", "`hash$upI" »
を成す
~EACH( %成分~名 )
に対し
⇒
~IF［
%処理-済み~init[ %成分~名 ] ~EQ ε
］
⇒
%処理-済み~init[ %成分~名 ] ~SET `*^l
◎
For each componentName of « "protocol", "username", "password", "hostname", "port", "pathname", "search", "hash" »:
• If processedInit[componentName] does not exist, then set processedInit[componentName] to "*".
</li>
	<li>
~IF［
%処理-済み~init[ "`protocol$upI" ] は`特別~scheme$である
］~AND［
%処理-済み~init[ "`port$upI" ] ~EQ `整数を直列化する$( %処理-済み~init[ "`protocol$upI" ] 用の`既定~port$ )【！in radix-10 using ASCII digits】
］
⇒
%処理-済み~init[ "`port$upI" ] ~SET 空~文字列
◎
If processedInit["protocol"] is a special scheme and processedInit["port"] is a string which represents its corresponding default port in radix-10 using ASCII digits then set processedInit["port"] to the empty string.
</li>
	<li>
%~URL~pattern ~LET 新たな`~URL~pattern$
◎
Let urlPattern be a new URL pattern.
</li>
	<li>
%~URL~pattern の`~protocol成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
 %処理-済み~init[ "`protocol$upI" ],
`~protocolを正準-化する$,
`既定の~option群$
◎
Set urlPattern’s protocol component to the result of compiling a component given processedInit["protocol"], canonicalize a protocol, and default options.
</li>
	<li>
%~URL~pattern の`~username成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`username$upI" ],
`~usernameを正準-化する$,
`既定の~option群$
◎
Set urlPattern’s username component to the result of compiling a component given processedInit["username"], canonicalize a username, and default options.
</li>
	<li>
%~URL~pattern の`~password成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`password$upI" ],
`~passwordを正準-化する$,
`既定の~option群$
◎
Set urlPattern’s password component to the result of compiling a component given processedInit["password"], canonicalize a password, and default options.
</li>
	<li>
%~hostname ~LET %処理-済み~init[ "`hostname$upI" ]
◎
↓</li>
	<li>
~IF［
`~hostname~patternは~IPv6~addressか否か$( %~hostname ) ~EQ ~T
］
⇒
%~URL~pattern の`~hostname成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%~hostname,
`~IPv6~hostnameを正準-化する$,
`~hostname~option群$
◎
If the result running hostname pattern is an IPv6 address given processedInit["hostname"] is true, then set urlPattern’s hostname component to the result of compiling a component given processedInit["hostname"], canonicalize an IPv6 hostname, and hostname options.
</li>
	<li>
~ELSE
⇒
%~URL~pattern の`~hostname成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%~hostname,
`~hostnameを正準-化する$,
`~hostname~option群$
◎
Otherwise, set urlPattern’s hostname component to the result of compiling a component given processedInit["hostname"], canonicalize a hostname, and hostname options.
</li>
	<li>
%~URL~pattern の`~port成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`port$upI" ],
`~portを正準-化する$,
`既定の~option群$
◎
Set urlPattern’s port component to the result of compiling a component given processedInit["port"], canonicalize a port, and default options.
</li>
	<li>
%~compile~option群 ~LET `既定の~option群$の複製
◎
Let compileOptions be a copy of the default options＼
</li>
	<li>
%~compile~option群 の`文字大小を無視するか$opt ~SET %~option群[ "`ignoreCase$upO" ]
◎
with the ignore case property set to options["ignoreCase"].
</li>
	<li>
<p>
~IF［
`~protocol成分は特別~schemeに合致しているか否か$( %~URL~pattern の`~protocol成分$ ) ~EQ ~T
］：
◎
If the result of running protocol component matches a special scheme given urlPattern’s protocol component is true, then:
</p>
		<ol>
			<li>
%~path~compile~option群 ~LET `~pathname~option群$の複製
◎
Let pathCompileOptions be copy of the pathname options＼
</li>
			<li>
%~path~compile~option群 の`文字大小を無視するか$opt ~SET %~option群[ "`ignoreCase$upO" ]
◎
with the ignore case property set to options["ignoreCase"].
</li>
			<li>
%~URL~pattern の`~pathname成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`pathname$upI" ],
`~pathnameを正準-化する$,
%~path~compile~option群
◎
Set urlPattern’s pathname component to the result of compiling a component given processedInit["pathname"], canonicalize a pathname, and pathCompileOptions.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%~URL~pattern の`~pathname成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`pathname$upI" ],
`不透明な~pathnameを正準-化する$,
%~compile~option群
◎
Otherwise set urlPattern’s pathname component to the result of compiling a component given processedInit["pathname"], canonicalize an opaque pathname, and compileOptions.
</li>
	<li>
%~URL~pattern の`~search成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`search$upI" ],
`~searchを正準-化する$,
%~compile~option群
◎
Set urlPattern’s search component to the result of compiling a component given processedInit["search"], canonicalize a search, and compileOptions.
</li>
	<li>
%~URL~pattern の`~hash成分$ ~SET `成分を~compileする$( ↓ )
⇒＃
%処理-済み~init[ "`hash$upI" ],
`~hashを正準-化する$,
%~compile~option群
◎
Set urlPattern’s hash component to the result of compiling a component given processedInit["hash"], canonicalize a hash, and compileOptions.
</li>
	<li>
~RET %~URL~pattern
◎
Return urlPattern.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URL~patternを照合する@
~algoは、
所与の
( `~URL~pattern$ %~URL~pattern, ［
`URLPatternInput$I ／ `~URL$
］ %入力, 文字列 %基底~URL文字列 ~DF ε )
に対し：
◎
To perform a match given a URL pattern urlPattern, a URLPatternInput or URL input, and an optional string baseURLString:
</p>
<ol>
	<li>
%~protocol ~LET 空~文字列
◎
Let protocol be the empty string.
</li>
	<li>
%~username ~LET 空~文字列
◎
Let username be the empty string.
</li>
	<li>
%~password ~LET 空~文字列
◎
Let password be the empty string.
</li>
	<li>
%~hostname ~LET 空~文字列
◎
Let hostname be the empty string.
</li>
	<li>
%~port ~LET 空~文字列
◎
Let port be the empty string.
</li>
	<li>
%~pathname ~LET 空~文字列
◎
Let pathname be the empty string.
</li>
	<li>
%~search ~LET 空~文字列
◎
Let search be the empty string.
</li>
	<li>
%~hash ~LET 空~文字列
◎
Let hash be the empty string.
</li>
	<li>
%入力~群 ~LET 新たな`~list$
◎
Let inputs be an empty list.
</li>
	<li>
%入力~群 に %入力 を`付加する$
◎
Append input to inputs.
</li>
	<li>
<p>
~IF［
%入力 は `URLPatternInit$I である
］：
◎
If input is a URLPatternInit then:
</p>
		<ol>
			<li>
~IF［
%基底~URL文字列 ~NEQ ε
］
⇒
~THROW `TypeError$E
◎
If baseURLString was given, throw a TypeError.
</li>
			<li>
%適用-結果 ~LET `~URLPatternInitを処理する$( ↓ )
⇒＃
%入力,
`url^l,
%~protocol,
%~username,
%~password,
%~hostname,
%~port,
%~pathname,
%~search,
%~hash
◎終
例外が投出されたときは、
~catchして
⇒
~RET ~NULL
◎
Let applyResult be the result of process a URLPatternInit given input, "url", protocol, username, password, hostname, port, pathname, search, and hash. If this throws an exception, catch it, and return null.
</li>
			<li>
%~protocol ~SET %適用-結果[ "`protocol$upI" ]
◎
Set protocol to applyResult["protocol"].
</li>
			<li>
%~username ~SET %適用-結果[ "`username$upI" ]
◎
Set username to applyResult["username"].
</li>
			<li>
%~password ~SET %適用-結果[ "`password$upI" ]
◎
Set password to applyResult["password"].
</li>
			<li>
%~hostname ~SET %適用-結果[ "`hostname$upI" ]
◎
Set hostname to applyResult["hostname"].
</li>
			<li>
%~port ~SET %適用-結果[ "`port$upI" ]
◎
Set port to applyResult["port"].
</li>
			<li>
%~pathname ~SET %適用-結果[ "`pathname$upI" ]
◎
Set pathname to applyResult["pathname"].
</li>
			<li>
%~search ~SET %適用-結果[ "`search$upI" ]
◎
Set search to applyResult["search"].
</li>
			<li>
%~hash ~SET %適用-結果[ "`hash$upI" ]
◎
Set hash to applyResult["hash"].
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~URL ~LET %入力
◎
Let url be input.
</li>
			<li>
<p>
~IF［
%入力 は `USVString$I である
］：
◎
If input is a USVString:
</p>
				<ol>
					<li>
%基底~URL ~LET ~NULL
◎
Let baseURL be null.
</li>
					<li>
<p>
~IF［
%基底~URL文字列 ~NEQ ε
］：
◎
If baseURLString was given, then:
</p>
						<ol>
							<li>
%基底~URL ~SET `~URL構文解析する$( %基底~URL文字列 )
◎
Set baseURL to the result of parsing baseURLString.
</li>
							<li>
~IF［
%基底~URL ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If baseURL is failure, return null.
</li>
							<li>
%入力~群 に %基底~URL文字列 を`付加する$
◎
Append baseURLString to inputs.
</li>
						</ol>
					</li>
					<li>
%~URL ~SET `~URL構文解析する$( %入力, %基底~URL )
◎
Set url to the result of parsing input given baseURL.
</li>
					<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If url is failure, return null.
</li>
				</ol>
			</li>
			<li>
~Assert：
%~URL は`~URL$である
◎
Assert: url is a URL.
</li>
			<li>
%~protocol ~SET %~URL の`~scheme$url
◎
Set protocol to url’s scheme.
</li>
			<li>
%~username ~SET %~URL の`~username$url
◎
Set username to url’s username.
</li>
			<li>
%~password ~SET %~URL の`~password$url
◎
Set password to url’s password.
</li>
			<li>
%~hostname ~SET %~URL の`~host$url
◎
Set hostname to url’s host＼
</li>
			<li>
%~hostname ~SET %~hostname に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `~hostを直列化する$( %~hostname )
◎
serialized, or the empty string if the value is null.
</li>
			<li>
%~port ~SET %~URL の`~port$url
◎
Set port to url’s port＼
</li>
			<li>
%~port ~SET %~port に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `整数を直列化する$( %~port )
◎
serialized, or the empty string if the value is null.
</li>
			<li>
%~pathname ~SET `~URL~pathを直列化する$( %~URL )
◎
Set pathname to the result of URL path serializing url.
</li>
			<li>
%~search ~SET %~URL の`~query$url
◎
Set search to url’s query＼
</li>

			<li>
~IF［
%~search ~EQ ~NULL
］
⇒
%~search ~SET 空~文字列
◎
or the empty string if the value is null.
</li>
			<li>
%~hash ~SET %~URL の`素片$url
◎
Set hash to url’s fragment＼
</li>
			<li>
~IF［
%~hash ~EQ ~NULL
］
⇒
%~hash ~SET 空~文字列
◎
or the empty string if the value is null.
</li>
		</ol>
	</li>
	<li>
%~protocol実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~protocol成分$の`正規表現$cP, %~protocol )
◎
Let protocolExecResult be RegExpBuiltinExec(urlPattern’s protocol component's regular expression, protocol).
</li>
	<li>
%~username実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~username成分$の`正規表現$cP, %~username )
◎
Let usernameExecResult be RegExpBuiltinExec(urlPattern’s username component's regular expression, username).
</li>
	<li>
%~password実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~password成分$の`正規表現$cP, %~password )
◎
Let passwordExecResult be RegExpBuiltinExec(urlPattern’s password component's regular expression, password).
</li>
	<li>
%~hostname実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~hostname成分$の`正規表現$cP, %~hostname )
◎
Let hostnameExecResult be RegExpBuiltinExec(urlPattern’s hostname component's regular expression, hostname).
</li>
	<li>
%~port実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~port成分$の`正規表現$cP, %~port )
◎
Let portExecResult be RegExpBuiltinExec(urlPattern’s port component's regular expression, port).
</li>
	<li>
%~pathname実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~pathname成分$の`正規表現$cP, %~pathname )
◎
Let pathnameExecResult be RegExpBuiltinExec(urlPattern’s pathname component's regular expression, pathname).
</li>
	<li>
%~search実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~search成分$の`正規表現$cP, %~search )
◎
Let searchExecResult be RegExpBuiltinExec(urlPattern’s search component's regular expression, search).
</li>
	<li>
%~hash実行-結果 ~LET 
`RegExpBuiltinExec$A( %~URL~pattern の`~hash成分$の`正規表現$cP, %~hash )
◎
Let hashExecResult be RegExpBuiltinExec(urlPattern’s hash component's regular expression, hash).
</li>
	<li>
~IF［
~NULL ~IN {
%~protocol実行-結果,
%~username実行-結果,
%~password実行-結果,
%~hostname実行-結果,
%~port実行-結果,
%~pathname実行-結果,
%~search実行-結果,
%~hash実行-結果
}
］
⇒
~RET ~NULL
◎
If protocolExecResult, usernameExecResult, passwordExecResult, hostnameExecResult, portExecResult, pathnameExecResult, searchExecResult, or hashExecResult are null then return null.
</li>
	<li>
%結果 ~LET 新たな `URLPatternResult$I
◎
Let result be a new URLPatternResult.
</li>
	<li>
%結果[ "`inputs$upR" ] ~SET %入力~群
◎
Set result["inputs"] to inputs.
</li>
	<li>
%結果[ "`protocol$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~protocol成分$,
%~protocol,
%~protocol実行-結果
◎
Set result["protocol"] to the result of creating a component match result given urlPattern’s protocol component, protocol, and protocolExecResult.
</li>
	<li>
%結果[ "`username$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~username成分$,
%~username,
%~username実行-結果
◎
Set result["username"] to the result of creating a component match result given urlPattern’s username component, username, and usernameExecResult.
</li>
	<li>
%結果[ "`password$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~password成分$,
%~password,
%~password実行-結果
◎
Set result["password"] to the result of creating a component match result given urlPattern’s password component, password, and passwordExecResult.
</li>
	<li>
%結果[ "`hostname$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~hostname成分$,
%~hostname,
%~hostname実行-結果
◎
Set result["hostname"] to the result of creating a component match result given urlPattern’s hostname component, hostname, and hostnameExecResult.
</li>
	<li>
%結果[ "`port$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~port成分$,
%~port,
%~port実行-結果
◎
Set result["port"] to the result of creating a component match result given urlPattern’s port component, port, and portExecResult.
</li>
	<li>
%結果[ "`pathname$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~pathname成分$,
%~pathname,
%~pathname実行-結果
◎
Set result["pathname"] to the result of creating a component match result given urlPattern’s pathname component, pathname, and pathnameExecResult.
</li>
	<li>
%結果[ "`search$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~search成分$,
%~search,
%~search実行-結果
◎
Set result["search"] to the result of creating a component match result given urlPattern’s search component, search, and searchExecResult.
</li>
	<li>
%結果[ "`hash$upR" ] ~SET `成分~照合-結果を作成する$( ↓ )
⇒＃
%~URL~pattern の`~hash成分$,
%~hash,
%~hash実行-結果
◎
Set result["hash"] to the result of creating a component match result given urlPattern’s hash component, hash, and hashExecResult.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~URL~pattern$ %~URL~pattern は
`~regexp~groupを有して@
いるとは、
次の手続きが ~T を返すことをいう：
◎
A URL pattern urlPattern has regexp groups if the following steps return true:
</p>
<ol>
	<li>
%成分~群 ~LET 順に %~URL~pattern を成す次に挙げる`成分$たちが成す~list
⇒＃
`~protocol成分$,
`~username成分$,
`~password成分$,
`~hostname成分$,
`~port成分$,
`~pathname成分$,
`~search成分$,
`~hash成分$
◎
↓</li>
	<li>
%成分~群 を成す
~EACH( %成分 )
に対し
⇒
~IF［
%成分 の`~regexp~groupを有するか$cP ~EQ ~T
］
⇒
~RET ~T
◎
If urlPattern’s protocol component has regexp groups is true, then return true.
◎
If urlPattern’s username component has regexp groups is true, then return true.
◎
If urlPattern’s password component has regexp groups is true, then return true.
◎
If urlPattern’s hostname component has regexp groups is true, then return true.
◎
If urlPattern’s port component has regexp groups is true, then return true.
◎
If urlPattern’s pathname component has regexp groups is true, then return true.
◎
If urlPattern’s search component has regexp groups is true, then return true.
◎
If urlPattern’s hash component has regexp groups is true, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

		</section>
		<section id="urlpattern-internals">
<h3 title="Internals">1.5. 内部的なもの</h3>

<div class="algo">
<p>
`成分を~compileする@
~algoは、
所与の
⇒＃
文字列 %入力,
`符号化~callback$ %符号化~callback,
`~option群$ %~option群
◎終
に対し：
◎
To compile a component given a string input, encoding callback encoding callback, and options options:
</p>
<ol>
	<li>
%~part~list ~LET 
`~pattern文字列を構文解析する$( %入力, %~option群, %符号化~callback )
◎
Let part list be the result of running parse a pattern string given input, options, and encoding callback.
</li>
	<li>
( %正規表現~文字列, %名前~list ) ~LET `正規表現と名前~listを生成する$( %~part~list, %~option群 )
◎
Let (regular expression string, name list) be the result of running generate a regular expression and name list given part list and options.
</li>
	<li>
%~flag群 ~LET %~option群 の`文字大小を無視するか$optに応じて
⇒＃
~T ならば `vi^l ／
~F ならば `v^l
◎
Let flags be an empty string.
◎
If options’s ignore case is true then set flags to "vi".
◎
Otherwise set flags to "v"
</li>
	<li>
<p>
%正規表現 ~LET `RegExpCreate$A( %正規表現~文字列, %~flag群 )
⇒
例外が投出されたときは、
~catchして
⇒
~THROW `TypeError$E
◎
Let regular expression be RegExpCreate(regular expression string, flags). If this throws an exception, catch it, and throw a TypeError.
</p>

<p class="note">注記：
この仕様は，
遂行するすべての照合に正規表現を利用するが、
このことは義務付けられない。
実装は、
アリなときは，`~part~list$に対し直に照合を遂行してもかまわない
（例： ~customな~regexp照合~groupは無いとき）。
しかしながら，~customな正規表現が在る場合、
それらは`成分を~compileする$ときに即時に評価されるので，
それらいずれかが妥当でない場合には~errorが投出され得ることに注意。
◎
The specification uses regular expressions to perform all matching, but this is not mandated. Implementations are free to perform matching directly against the part list when possible; e.g. when there are no custom regexp matching groups. If there are custom regular expressions, however, its important that they be immediately evaluated in the compile a component algorithm so an error can be thrown if they are invalid.
</p>
	</li>
	<li>
%~pattern文字列 ~LET `~pattern文字列を生成する$( %~part~list, %~option群 )
◎
Let pattern string be the result of running generate a pattern string given part list and options.
</li>
	<li>
%~regexp~groupを有するか ~LET ~F
◎
Let has regexp groups be false.
</li>
	<li>
%~part~list を成す
~EACH( %~part )
に対し
⇒
~IF［
%~part の`種別$pt ~EQ `~regexp0$l
］
⇒
%~regexp~groupを有するか ~SET ~T
◎
For each part of part list:
• If part’s type is "regexp", then set has regexp groups to true.
</li>
	<li>
~RET 新たな`成分$
— その
⇒＃
`~pattern文字列$cP ~SET %~pattern文字列,
`正規表現$cP ~SET %正規表現,
`~group名~list$cP ~SET %名前~list,
`~regexp~groupを有するか$cP ~SET %~regexp~groupを有するか
◎
Return a new component whose pattern string is pattern string, regular expression is regular expression, group name list is name list, and has regexp groups is has regexp groups.
</li>
</ol>
</div>

<div class="algo">
<p>
`成分~照合-結果を作成する@
~algoは、
所与の
( `成分$ %成分, 文字列 %入力, `RegExpBuiltinExec$A の出力を表現している配列 %実行-結果 )
に対し：
◎
To create a component match result given a component component, a string input, and an array representing the output of RegExpBuiltinExec execResult:
</p>
<ol>
	<li>
%結果 ~LET 新たな `URLPatternComponentResult$I
◎
Let result be a new URLPatternComponentResult.
</li>
	<li>
%結果[ "`input$upC" ] ~SET %入力
◎
Set result["input"] to input.
</li>
	<li>
%~group群 ~LET 新たな
<code>`record$&lt;`USVString$, (`USVString$ or `undefined$)&gt;</code>
型の値
◎
Let groups be a record&lt;USVString, (USVString or undefined)&gt;.
</li>
	<li>
%~index ~LET 1
◎
Let index be 1.
</li>
	<li>
<p>
~WHILE［
%~index ~LT `Get$A( %実行-結果, `length^l )
］：
◎
While index is less than Get(execResult, "length"):
</p>
		<ol>
			<li>
%名前 ~LET %成分 の`~group名~list$cP[ %~index ~MINUS 1 ]
◎
Let name be component’s group name list[index − 1].
</li>
			<li>
%値 ~LET `Get$A( %実行-結果, `ToString$A( %~index ) )
◎
Let value be Get(execResult, ToString(index)).
</li>
			<li>
%~group群[ %名前 ] ~SET %値
◎
Set groups[name] to value.
</li>
			<li>
%~index ~INCBY 1
◎
Increment index by 1.
</li>
		</ol>
	</li>
	<li>
%結果[ "`groups$upC" ] ~SET %~group群
◎
Set result["groups"] to groups.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
`既定の~option群@
は
⇒
~RET 新たな`~option群$
— その
⇒＃
`区切子~符号位置$opt ~SET 空~文字列,
`接頭辞~符号位置$opt ~SET 空~文字列
◎
The default options is an options struct with delimiter code point set to the empty string and prefix code point set to the empty string.
</div>

<div class="algo">
`~hostname~option群@
は
⇒
~RET 新たな`~option群$
— その
⇒＃
`区切子~符号位置$opt ~SET `.^l,
`接頭辞~符号位置$opt ~SET 空~文字列
◎
The hostname options is an options struct with delimiter code point set "." and prefix code point set to the empty string.
</div>

<div class="algo">
`~pathname~option群@
は
⇒
~RET 新たな`~option群$
— その
⇒＃
`区切子~符号位置$opt ~SET `/^l,
`接頭辞~符号位置$opt ~SET `/^l
◎
The pathname options is an options struct with delimiter code point set "/" and prefix code point set to "/".
</div>

<div class="algo">
<p>
`~protocol成分は特別~schemeに合致しているか否か@
は、
所与の
( `成分$ %~protocol成分 )
に対し：
◎
To determine if a protocol component matches a special scheme given a component protocol component:
</p>
<ol>
	<li>
~EACH( `特別~scheme$ %~scheme )
に対し
⇒
~IF［
`RegExpBuiltinExec$A( %~protocol成分 の`正規表現$cP, %~scheme ) ~NEQ ~NULL
］
⇒
~RET ~T
◎
Let special scheme list be a list populated with all of the special schemes.
◎
For each scheme of special scheme list:
• Let test result be RegExpBuiltinExec(protocol component’s regular expression, scheme).
• If test result is not null, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~hostname~patternは~IPv6~addressか否か@
は、
所与の
( `~pattern文字列$ %入力 )
に対し：
◎
To determine if a hostname pattern is an IPv6 address given a pattern string input:
</p>
<ol>
	<li>
~IF［
%入力 の`符号位置~長さ$ ~LT 2
］
⇒
~RET ~F
◎
If input’s code point length is less than 2, then return false.
</li>
	<li>
( %一個目, %二個目 ) ~LET %入力 を成す ( 0 番, 1番 ) の`文字$
◎
Let input code points be input interpreted as a list of code points.
</li>
	<li>
<p>
~RET ~IS ~OR↓：
</p>
		<ul>
			<li>
%一個目 ~EQ `005B^U
</li>
			<li>
［
%一個目 ~EQ `007B^U
］~AND［
%二個目 ~EQ `005B^U
］
</li>
			<li>
［
%一個目 ~EQ `005C^U
］~AND［
%二個目 ~EQ `005B^U
］
</li>
		</ul>
◎
If input code points[0] is U+005B ([), then return true.
◎
If input code points[0] is U+007B ({) and input code points[1] is U+005B ([), then return true.
◎
If input code points[0] is U+005C (\) and input code points[1] is U+005B ([), then return true.
◎
Return false.
</li>
</ol>
</div>

		</section>
		<section id="constructor-string-parsing">
<h3 title="Constructor string parsing">1.6. 構築子~文字列の構文解析-法</h3>

<p>
`構築子~文字列~構文解析器@
は、
次に挙げる~itemからなる`構造体$である：
◎
A constructor string parser is a struct.
</p>
<ul>
	<li>
`入力@csP
⇒
文字列
— 作成-時に設定されなければナラナイ。
◎
A constructor string parser has an associated input, a string, which must be set upon creation.
</li>
	<li>
`~token~list@csP
⇒
`~token~list$
— 作成-時に設定されなければナラナイ。
◎
A constructor string parser has an associated token list, a token list, which must be set upon creation.
</li>
	<li>
`結果@csP
⇒
`URLPatternInit$I
— 初期~時は新たな `URLPatternInit$I とする。
◎
A constructor string parser has an associated result, a URLPatternInit, initially set to a new URLPatternInit.
</li>
	<li>
`成分~始端@csP
⇒
ある~number
— 初期~時は 0 とする。
◎
A constructor string parser has an associated component start, a number, initially set to 0.
</li>
	<li>
`~token~index@csP
⇒
ある~number
— 初期~時は 0 とする。
◎
A constructor string parser has an associated token index, a number, initially set to 0.
</li>
	<li>
`~token増分@csP
⇒
ある~number
— 初期~時は 1 とする。
【 0 か 1 しかとり得ない。】
◎
A constructor string parser has an associated token increment, a number, initially set to 1.
</li>
	<li>
`~group深さ@csP
⇒
ある~number
— 初期~時は 0 とする。
◎
A constructor string parser has an associated group depth, a number, initially set to 0.
</li>
	<li>
`~hostname~IPv6角括弧~深さ@csP
⇒
ある~number
— 初期~時は 0 とする。
◎
A constructor string parser has an associated hostname IPv6 bracket depth, a number, initially set to 0.
</li>
	<li>
`~protocolは特別~schemeに合致するか@csP
⇒
ある真偽値
— 初期~時は ~F とする。
◎
A constructor string parser has an associated protocol matches a special scheme flag, a boolean, initially set to false.
</li>
	<li>
<p>
`状態@csP
⇒
文字列
— 初期~時は `init$l とする。
◎
A constructor string parser has an associated state, a string, initially set to "init".＼
</p>

<p>
その値は、
次に挙げるいずれかでなければナラナイ
⇒＃
`init@l ／
`protocol@l ／
`authority@l ／
`username@l ／
`password@l ／
`hostname@l ／
`port@l ／
`pathname@l ／
`search@l ／
`hash@l ／
`done@l
◎
It must be one of the following:
• "init"
• "protocol"
• "authority"
• "username"
• "password"
• "hostname"
• "port"
• "pathname"
• "search"
• "hash"
• "done"
</p>
	</li>
</ul>

<div class="note">
<p>注記：
~URLPattern構築子~文字列~用の構文解析器
— 以下、
“この構文解析器” と称する —
を成す~algoは，`基本~URL構文解析器$†にごく類似するが、
いくつか相違点があるので，後者の~algoを直には利用できない。
◎
The URLPattern constructor string algorithm is very similar to the basic URL parser algorithm, but some differences prevent us from using that algorithm directly.
</p>

<p class="trans-note">【†
この訳では、
`~API用に~URL構文解析する$~algoを通して，それを利用する。
】</p>

<ul>
	<li>
この構文解析器は、［
`~token化~施策$ `lenient^l を利用して生成された`~token$
］に対し演算する。
対照的に、
`基本~URL構文解析器$は，符号位置に対し演算する。
`~token$に対し演算することは、［
この構文解析器が，符号位置のうち［
有意な~pattern構文を成すもの,
~URL成分~分離子かもしれないもの
］をもっと容易に判別する
］ことを許容する。
例えば、［
`https://a.c:hmm.example.com:8080^l 内の `:hmm^l の様な有名~group
］を~port番号と混同しないよう取扱うことは，自明になる。
◎
First, the URLPattern constructor string parser operates on tokens generated using the "lenient" tokenize policy. In constrast, basic URL parser operates on code points. Operating on tokens allows the URLPattern constructor string parser to more easily distinguish between code points that are significant pattern syntax and code points that might be a URL component separator. For example, it makes it trivial to handle named groups like ":hmm" in "https://a.c:hmm.example.com:8080" without getting confused with the port number.
</li>
	<li>
この構文解析器は、［
`基本~URL構文解析器$が行う様な，すべての符号位置に対し~URL正準-化を適用すること
］を避ける必要がある。
代わりに、［
当の~pattern文字列を成す~partのうち，
正準-化を適用しても安全なことが知れたもの
］に限り
— 後で各~成分~pattern文字列を~compileするときに —
正準-化を遂行する。
◎
Second, the URLPattern constructor string parser needs to avoid applying URL canonicalization to all code points like basic URL parser does. Instead we perform canonicalization on only parts of the pattern string we know are safe later when compiling each component pattern string.
</li>
	<li>
この構文解析器は、
`基本~URL構文解析器$の状態~機械を成す いくつかの部分を取扱わない。
例えば、
~backslashを特別に扱わない
— ~backslashは、
すべて~pattern文字として扱われ，過度な~escape法を要求するので。
加えて，この構文解析器は、
~URL構文解析~algoを成す いくつかの難解な
— ~hostnameを伴う `file:^c ~URLの様な —
部分を取扱わないこともある。
この構文解析器の目標は、
最も共通的な~URLを取扱う一方で，［
~nicheな事例は、
代わりに構築子の `URLPatternInit$I 引数 【！URLPatternInit constructor 】を介して取扱われるようになる
］ことを許容することであった【？】。
◎
Finally, the URLPattern constructor string parser does not handle some parts of the basic URL parser state machine. For example, it does not treat backslashes specially as they would all be treated as pattern characters and would require excessive escaping. In addition, this parser might not handle some more esoteric parts of the URL parsing algorithm like file URLs with a hostname. The goal with this parser was to handle the most common URLs while allowing any niche case to be handled instead via the URLPatternInit constructor.
</li>
</ul>
</div>

<div class="note">
<p>注記：
構築子~文字列~用の~algoにおいては、［
~pathname／~search／~hash
］成分は，［
より前に現れる成分たちが指定された下で，指定されなかった場合
］には~wildcard化される。
例えば，【~pattern文字列】 `https://example.com/foo^l は、
どの［
~search／~hash
］にも合致する。
類似に，
`https://example.com^l は、
その生成元に属する どの~URLにも合致する。
これは、
`~URLPatternInitを処理する$~algo内の注記における
“より特有な成分” の観念
（例：~searchは~pathnameよりも特有な成分である）
に相似的であるが、
構築子~構文において［
ある成分を指定することなく，それより特有な成分を指定すること
］がアリになる事例は，少数に限られる。
◎
In the constructor string algorithm, the pathname, search, and hash are wildcarded if earlier components are specified but later ones are not. For example, "https://example.com/foo" matches any search and any hash. Similarly, "https://example.com" matches any URL on that origin. This is analogous to the notion of a more specific component in the notes about process a URLPatternInit (e.g., a search is more specific than a pathname), but the constructor syntax only has a few cases where it is possible to specify a more specific component without also specifying the less specific components.
</p>

<p>
［
~username／~password
］成分は、
明示的に指定されない限り，常に~wildcardになる。
◎
The username and password components are always wildcard unless they are explicitly specified.
</p>

<p>
~hostnameを指定したが，~portを指定しなかった場合、
~portは【所与の~scheme用の】`既定~port$になるものと見做される。
作者は、
どの~portにも合致するよう求めるなら，明示的に `:*^c を与える必要がある。
例えば
⇒＃
`https://*^l は，~port 443 上の どの~HTTPS生成元にも合致する。
`https://*:*^l は，どの~port上の どの~HTTPS生成元にも合致する。
◎
If a hostname is specified and the port is not, the port is assumed to be the default port. If authors want to match any port, they have to write :* explicitly. For example, "https://*" is any HTTPS origin on port 443, and "https://*:*" is any HTTPS origin on any port.
</p>
</div>

<div class="algo">
<p>
`構築子~文字列を構文解析する@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
To parse a constructor string given a string input:
</p>
<ol>
	<li>
%構文解析器 ~LET 新たな`構築子~文字列~構文解析器$
— その
⇒＃
`入力$csP ~SET %入力,
`~token~list$csP ~SET `~token化する$( %入力, `lenient$l )
◎
Let parser be a new constructor string parser whose input is input and token list is the result of running tokenize given input and "lenient".
</li>
	<li>
<p>
~WHILE［
%構文解析器 の`~token~index$csP ~LT %構文解析器 の`~token~list$csPの`~size$
］：
◎
While parser’s token index is less than parser’s token list size:
</p>
		<ol>
			<li>
<p>
%構文解析器 の`~token増分$csP ~SET 1
◎
Set parser’s token increment to 1.
</p>

<p class="note">注記：
この~loopを成す各~反復においては、
%構文解析器 の`~token~index$csPは，
%構文解析器 の`~token増分$csP値により増分されることになる。
この増分は、
概して 1 に設定されるが，ある種の回では 0 に設定される。
`~token増分$csPは、
この~loopを成す先頭にて，常に 1 に設定し直される。
◎
On every iteration of the parse loop the parser’s token index will be incremented by its token increment value. Typically this means incrementing by 1, but at certain times it is set to zero. The token increment is then always reset back to 1 at the top of the loop.
</p>
			</li>
			<li>
<p>
~IF［
%構文解析器 の`~token~list$csP[ %構文解析器 の`~token~index$csP ] の`種別$tK ~EQ `end$l
］：
◎
If parser’s token list[parser’s token index]'s type is "end" then:
</p>
				<ol>
					<li>
<p>
~IF［
%構文解析器 の`状態$csP ~EQ `init$l
］：
◎
If parser’s state is "init":
</p>

<p class="note">注記：
`init$l `状態$csPにおいて文字列の終端に達した場合、
~protocol終了子を見出すのに失敗したことになり，
%入力 を相対的な~URLPattern構築子~文字列とみなす必要がある。
◎
If we reached the end of the string in the "init" state, then we failed to find a protocol terminator and this has to be a relative URLPattern constructor string.
</p>
						<ol>
							<li>
<p>
`構文解析器を巻戻す$( %構文解析器 )
◎
Run rewind given parser.
</p>

<p class="note">注記：
次に，相対~patternが どの成分から始まるかを決定する。
相対~pathnameが最も共通的にあるが、
~URLや~URLPattern構築子~文字列は，［
~search／~hash
］成分から始まることもある。
◎
We next determine at which component the relative pattern begins. Relative pathnames are most common, but URLs and URLPattern constructor strings can begin with the search or hash components as well.
</p>
							</li>
							<li>
~IF［
`~hash接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hash$l, 1 )
◎
If the result of running is a hash prefix given parser is true, then run change state given parser, "hash" and 1.
</li>
							<li>
<p>
~ELIF［
`~search接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `search$l, 1 )
◎
Otherwise if the result of running is a search prefix given parser is true:
• Run change state given parser, "search" and 1.
</li>
							<li>
~ELSE
⇒
`状態を変更する$( %構文解析器, `pathname$l, 0 )
◎
Otherwise:
• Run change state given parser, "pathname" and 0.
</li>
							<li>
%構文解析器 の`~token~index$csP ~INCBY %構文解析器 の`~token増分$csP
◎
Increment parser’s token index by parser’s token increment.
</li>
							<li>
~CONTINUE
◎
Continue.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%構文解析器 の`状態$csP ~EQ `authority$l
］：
◎
If parser’s state is "authority":
</p>

<p class="note">注記：
`authority$l `状態$csPにおいて文字列の終端に達した場合、
`@^l を見出すことに失敗したことになる。
したがって、
~usernameや~passwordは無い。
◎
If we reached the end of the string in the "authority" state, then we failed to find an "@". Therefore there is no username or password.
</p>
						<ol>
							<li>
`構文解析器を巻戻す$( %構文解析器, `hostname$l )
◎
Run rewind and set state given parser, and "hostname".
</li>
							<li>
%構文解析器 の`~token~index$csP ~INCBY %構文解析器 の`~token増分$csP
◎
Increment parser’s token index by parser’s token increment.
</li>
							<li>
~CONTINUE
◎
Continue.
</li>
						</ol>
					</li>
					<li>
`状態を変更する$( %構文解析器, `done$l, 0 )
◎
Run change state given parser, "done" and 0.
</li>
					<li>
~BREAK
◎
Break.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
`~groupを開くか否か$( %構文解析器 ) ~EQ ~T
］：
◎
If the result of running is a group open given parser is true:
</p>

<div class="note">
<p>注記：
`{ ... }^l で~group化された~patternの中の符号位置は、
すべて無視する。
~group化の中に~URL成分の境界を許容することは
（例： `https://example.c{om/fo}o^l ）、
イミを成さないので。
入子な~group化は，`整形式$な`~pattern文字列$の中では~supportされないが、
構文解析器による混同を避けるため，ここで取扱う。
◎
We ignore all code points within "{ ... }" pattern groupings. It would not make sense to allow a URL component boundary to lie within a grouping; e.g. "https://example.c{om/fo}o". While not supported within well formed pattern strings, we handle nested groupings here to avoid parser confusion.
</p>

<p>
［
~regexp／有名~group
］用には、
この~logicを遂行することは必要yでない
— それらの値は、
`~token化する$~algoにより，個々の`~token$の中へ縮約されるので。
◎
It is not necessary to perform this logic for regexp or named groups since those values are collapsed into individual tokens by the tokenize algorithm.
</p>
</div>
				<ol>
					<li>
%構文解析器 の`~group深さ$csP ~INCBY 1
◎
Increment parser’s group depth by 1.
</li>
					<li>
%構文解析器 の`~token~index$csP ~INCBY %構文解析器 の`~token増分$csP
◎
Increment parser’s token index by parser’s token increment.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%構文解析器 の`~group深さ$csP ~GT 0
］：
◎
If parser’s group depth is greater than 0:
</p>
				<ol>
					<li>
~IF［
`~groupを閉じるか否か$( %構文解析器 ) ~EQ ~T
］
⇒
%構文解析器 の`~group深さ$csP ~DECBY 1
◎
If the result of running is a group close given parser is true, then decrement parser’s group depth by 1.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
%構文解析器 の`~token~index$csP ~INCBY %構文解析器 の`~token増分$csP
◎
Increment parser’s token index by parser’s token increment.
</li>
							<li>
~CONTINUE
◎
Continue.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
%構文解析器 の`状態$csPに応じて：
◎
Switch on parser’s state and run the associated steps:
</p>
				<ul class="switch">
					<li>
`init$l
⇒
~IF［
`~protocol接尾辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`構文解析器を巻戻す$( %構文解析器, `protocol$l )
◎
"init"
• If the result of running is a protocol suffix given parser is true:
•• Run rewind and set state given parser and "protocol".
</li>
					<li>
<p>
`protocol$l：
◎
"protocol"
</p>
						<ol>
							<li>
<p>
~IF［
`~protocol接尾辞か否か$( %構文解析器 ) ~EQ ~T
］：
◎
If the result of running is a protocol suffix given parser is true:
</p>
								<ol>
									<li>
<p>
`~protocolは特別~schemeに合致するかを算出する$( %構文解析器 )
◎
Run compute protocol matches a special scheme flag given parser.
</p>

<p class="note">注記：
~protocol成分は、
`特別~scheme$に合致するか否かを決定するため，
早急に~compileする必要がある。
合致した場合、
ある種の特別な規則が適用される。
それは、［
~pathnameが既定では `/^l になるか否か
］および［［
~username, ~password, ~hostname, ~port
］成分を探すことにするか否か
］を決定する。
~authority~slash列も，これらの成分を探すようにし得る。
他の場合、
これを “不透明な~path~URL” として扱って，~pathname成分へ直行する。
◎
We need to eagerly compile the protocol component to determine if it matches any special schemes. If it does then certain special rules apply. It determines if the pathname defaults to a "/" and also whether we will look for the username, password, hostname, and port components. Authority slashes can also cause us to look for these components as well. Otherwise we treat this as an "opaque path URL" and go straight to the pathname component.
</p>
									</li>
									<li>
%次回の状態 ~LET `pathname$l
◎
Let next state be "pathname".
</li>
									<li>
%歩数 ~LET 1
◎
Let skip be 1.
</li>
									<li>
<p>
~IF［
`次回は~authority~slash列か否か$( %構文解析器 ) ~EQ ~T
］：
◎
If the result of running next is authority slashes given parser is true:
</p>
										<ol>
											<li>
%次回の状態 ~SET `authority$l
◎
Set next state to "authority".
</li>
											<li>
%歩数 ~SET 3
◎
Set skip to 3.
</li>
										</ol>
									</li>
									<li>
~ELIF［
%構文解析器 の`~protocolは特別~schemeに合致するか$csP ~EQ ~T
］
⇒
%次回の状態 ~SET `authority$l
◎
Otherwise if parser’s protocol matches a special scheme flag is true, then set next state to "authority".
</li>
									<li>
`状態を変更する$( %構文解析器, %次回の状態, %歩数 )
◎
Run change state given parser, next state, and skip.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
<p>
`authority$l：
◎
"authority"
</p>
						<ol>
							<li>
~IF［
`識別情報~終了子か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`構文解析器を巻戻す$( %構文解析器, `username$l )
◎
If the result of running is an identity terminator given parser is true, then run rewind and set state given parser and "username".
</li>
							<li>
<p>
~ELIF［
~OR↓
］…
◎
Otherwise if any of the following are true:
</p>
								<ul>
									<li>
`~pathname始端か否か$( %構文解析器 ) ~EQ ~T
◎
the result of running is a pathname start given parser;
</li>
									<li>
`~search接頭辞か否か$( %構文解析器 ) ~EQ ~T
◎
the result of running is a search prefix given parser; or
</li>
									<li>
`~hash接頭辞か否か$( %構文解析器 ) ~EQ ~T
◎
the result of running is a hash prefix given parser,
</li>
								</ul>
<p>
…ならば
⇒
`構文解析器を巻戻す$( %構文解析器, `hostname$l )
◎
then run rewind and set state given parser and "hostname".
</p>
							</li>
						</ol>
					</li>
					<li>
<p>
`username$l：
◎
"username"
</p>
						<ol>
							<li>
~IF［
`~password接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `password$l, 1 )
◎
If the result of running is a password prefix given parser is true, then run change state given parser, "password", and 1.
</li>
							<li>
~ELIF［
`識別情報~終了子か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hostname$l, 1 )
◎
Otherwise if the result of running is an identity terminator given parser is true, then run change state given parser, "hostname", and 1.
</li>
						</ol>
					</li>
					<li>
`password$l
⇒
~IF［
`識別情報~終了子か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hostname$l, 1 )
◎
"password"
• If the result of running is an identity terminator given parser is true, then run change state given parser, "hostname", and 1.
</li>
					<li>
<p>
`hostname$l：
◎
"hostname"
</p>
						<ol>
							<li>
~IF［
`~IPv6を開くか否か$( %構文解析器 ) ~EQ ~T
］
⇒
%構文解析器 の`~hostname~IPv6角括弧~深さ$csP ~INCBY 1
◎
If the result of running is an IPv6 open given parser is true, then increment parser’s hostname IPv6 bracket depth by 1.
</li>
							<li>
~ELIF［
`~IPv6を閉じるか否か$( %構文解析器 ) ~EQ ~T
］
⇒
%構文解析器 の`~hostname~IPv6角括弧~深さ$csP ~DECBY 1
◎
Otherwise if the result of running is an IPv6 close given parser is true, then decrement parser’s hostname IPv6 bracket depth by 1.
</li>
							<li>
~ELIF［
`~port接頭辞か否か$( %構文解析器 ) ~EQ ~T
］~AND［
%構文解析器 の`~hostname~IPv6角括弧~深さ$csP ~EQ 0
］
⇒
`状態を変更する$( %構文解析器, `port$l, 1 )
◎
Otherwise if the result of running is a port prefix given parser is true and parser’s hostname IPv6 bracket depth is zero, then run change state given parser, "port", and 1.
</li>
							<li>
~ELIF［
`~pathname始端か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `pathname$l, 0 )
◎
Otherwise if the result of running is a pathname start given parser is true, then run change state given parser, "pathname", and 0.
</li>
							<li>
~ELIF［
`~search接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `search$l, 1 )
◎
Otherwise if the result of running is a search prefix given parser is true, then run change state given parser, "search", and 1.
</li>
							<li>
~ELIF［
`~hash接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hash$l, 1 )
◎
Otherwise if the result of running is a hash prefix given parser is true, then run change state given parser, "hash", and 1.
</li>
						</ol>
					</li>
					<li>
<p>
`port$l：
◎
"port"
</p>
						<ol>
							<li>
~IF［
`~pathname始端か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `pathname$l, 0 )
◎
If the result of running is a pathname start given parser is true, then run change state given parser, "pathname", and 0.
</li>
							<li>
~ELIF［
`~search接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `search$l, 1 )
◎
Otherwise if the result of running is a search prefix given parser is true, then run change state given parser, "search", and 1.
</li>
							<li>
~ELIF［
`~hash接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hash$l, 1 )
◎
Otherwise if the result of running is a hash prefix given parser is true, then run change state given parser, "hash", and 1.
</li>
						</ol>
					</li>
					<li>
<p>
`pathname$l：
◎
"pathname"
</p>
						<ol>
							<li>
~IF［
`~search接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `search$l, 1 )
◎
If the result of running is a search prefix given parser is true, then run change state given parser, "search", and 1.
</li>
							<li>
~ELIF［
`~hash接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hash$l, 1 )
◎
Otherwise if the result of running is a hash prefix given parser is true, then run change state given parser, "hash", and 1.
</li>
						</ol>
					</li>
					<li>
`search$l
⇒
~IF［
`~hash接頭辞か否か$( %構文解析器 ) ~EQ ~T
］
⇒
`状態を変更する$( %構文解析器, `hash$l, 1 )
◎
"search"
• If the result of running is a hash prefix given parser is true, then run change state given parser, "hash", and 1.
</li>
					<li>
`hash$l
⇒
何もしない
◎
"hash"
• Do nothing.
</li>
					<li>
`done$l
⇒
~Assert：
この段には決して到達しない
◎
"done"
• Assert: This step is never reached.
</li>
				</ul>
			</li>
			<li>
%構文解析器 の`~token~index$csP ~INCBY %構文解析器 の`~token増分$csP
◎
Increment parser’s token index by parser’s token increment.
</li>
		</ol>
	</li>
	<li>
%結果 ~LET %構文解析器 の`結果$csP
◎
↓</li>
	<li>
<p>
~IF［
%結果[ "`hostname$upI" ] ~NEQ ε
］~AND［
%結果[ "`port$upI" ] ~EQ ε
］
⇒
%結果[ "`port$upI" ] ~SET 空~文字列
◎
If parser’s result contains "hostname" and not "port", then set parser’s result["port"] to the empty string.
</p>

<p class="note">注記：
この事例は特別に扱われる
— ~portを指定しない作者は、
通例的に，`既定~port$を意図するので。
どの~portも受容-可能である場合、
作者は，それを明示的に~wildcardとして指定できる。
例えば， `https://example.com/*^l は、
`https://example.com:8443/^l で始まる~URL
（それは、異なる生成元に属する）
には，合致しない。
◎
This is special-cased because when an author does not specify a port, they usually intend the default port. If any port is acceptable, the author can specify it as a wildcard explicitly. For example, "https://example.com/*" does not match URLs beginning with "https://example.com:8443/", which is a different origin.
</p>
	</li>
	<li>
~RET %結果
◎
Return parser’s result.
</li>
</ol>
</div>

<div class="algo">
<p>
`状態を変更する@
~algoは、
所与の
( `構築子~文字列~構文解析器$ %構文解析器, `状態$csP %新たな状態, ~number %歩数 )
に対し：
◎
To change state given a constructor string parser parser, a state new state, and a number skip:
</p>
<ol>
	<li>
%状態 ~LET %構文解析器 の`状態$csP
◎
↓</li>
	<li>
%結果 ~LET %構文解析器 の`結果$csP
◎
↓</li>
	<li>
~IF［
%状態 ~NIN { `init$l, `authority$l, `done$l }
］
⇒
%結果[ %状態 ] ~SET `成分~文字列を抽出する$( %構文解析器 )
◎
If parser’s state is not "init", not "authority", and not "done", then set parser’s result[parser’s state] to the result of running make a component string given parser.
</li>
	<li>
<p>
~IF［
%状態 ~NEQ `init$l
］~AND［
%新たな状態 ~NEQ `done$l
］：
◎
If parser’s state is not "init" and new state is not "done", then:
</p>
		<ol>
			<li>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%状態 ~IN { `protocol$l, `authority$l, `username$l, `password$l }
</li>
					<li>
%新たな状態 ~IN { `port$l, `pathname$l, `search$l, `hash$l };
</li>
					<li>
%結果[ "`hostname$upI" ] ~EQ ε
</li>
				</ul>
<p>
…ならば
⇒
%結果[ "`hostname$upI" ] ~SET 空~文字列
</p>
◎
If parser’s state is "protocol", "authority", "username", or "password"; new state is "port", "pathname", "search", or "hash"; and parser’s result["hostname"] does not exist, then set parser’s result["hostname"] to the empty string.
</li>
			<li>
<div>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%状態 ~IN { `protocol$l, `authority$l, `username$l, `password$l, `hostname$l, `port$l }
</li>
					<li>
%新たな状態 ~IN { `search$l, `hash$l }
</li>
					<li>
%結果[ "`pathname$upI" ] ~EQ ε
</li>
				</ul>
<p>
…ならば
⇒
%結果[ "`pathname$upI" ] ~SET ［
次が満たされるならば `/^l ／
~ELSE_ 空~文字列
］
⇒
%構文解析器 の`~protocolは特別~schemeに合致するか$csP ~EQ ~T
</p>
◎
If parser’s state is "protocol", "authority", "username", "password", "hostname", or "port"; new state is "search" or "hash"; and parser’s result["pathname"] does not exist, then:
• If parser’s protocol matches a special scheme flag is true, then set parser’s result["pathname"] to "/".
• Otherwise, set parser’s result["pathname"] to the empty string.
</div>
			</li>
			<li>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%状態 ~IN { `protocol$l, `authority$l, `username$l, `password$l, `hostname$l, `port$l, `pathname$l }
</li>
					<li>
%新たな状態 ~EQ `hash$l
</li>
					<li>
%結果[ "`search$upI" ] ~EQ ε
</li>
				</ul>
<p>
…ならば
⇒
%結果[ "`search$upI" ] ~SET 空~文字列
</p>
◎
If parser’s state is "protocol", "authority", "username", "password", "hostname", "port", or "pathname"; new state is "hash"; and parser’s result["search"] does not exist, then set parser’s result["search"] to the empty string.
</li>
		</ol>
	</li>
	<li>
%構文解析器 の
⇒＃
`状態$csP ~SET %新たな状態
`~token~index$csP ~INCBY %歩数
`成分~始端$csP ~SET %構文解析器 の`~token~index$csP
`~token増分$csP ~SET 0
◎
Set parser’s state to new state.
◎
Increment parser’s token index by skip.
◎
Set parser’s component start to parser’s token index.
◎
Set parser’s token increment to 0.
</li>
</ol>
</div>

<div class="algo">
<p>
`構文解析器を巻戻す@
~algoは、
所与の
( `構築子~文字列~構文解析器$ %構文解析器, `状態$csP %状態 ~DF ε )
に対し：
</p>
<ol>
	<li>
%構文解析器 の`~token~index$csP ~SET %構文解析器 の`成分~始端$csP
</li>
	<li>
%構文解析器 の`~token増分$csP ~SET 0
</li>
	<li>
~IF［
%状態 ~NEQ ε
］
⇒
%構文解析器 の`状態$csP ~SET %状態
</li>
</ol>
◎
To rewind given a constructor string parser parser:
• Set parser’s token index to parser’s component start.
• Set parser’s token increment to 0.
◎
To rewind and set state given a constructor string parser parser and a state state:
• Run rewind given parser.
• Set parser’s state to state.
</div>

<div class="algo">
<p>
`安全な~tokenを取得する@
~algoは、
所与の
( `構築子~文字列~構文解析器$ %構文解析器, ~number %~index )
に対し：
◎
To get a safe token given a constructor string parser parser and a number index:
</p>
<ol>
	<li>
%最後の~index ~LET %構文解析器 の`~token~list$csPの`~size$ ~MINUS 1
◎
↓</li>
	<li>
~IF［
%~index ~LTE %最後の~index
］
⇒
~RET %構文解析器 の`~token~list$csP[ %~index ]
◎
If index is less than parser’s token list's size, then return parser’s token list[index].
</li>
	<li>
~Assert：
%最後の~index ~GTE 0
◎
Assert: parser’s token list's size is greater than or equal to 1.
</li>
	<li>
%~token ~LET %構文解析器 の`~token~list$csP[ %最後の~index ]
◎
Let last index be parser’s token list's size − 1.
◎
Let token be parser’s token list[last index].
</li>
	<li>
~Assert：
%~token の`種別$tK ~EQ `end$l
◎
Assert: token’s type is "end".
</li>
	<li>
~RET %~token
◎
Return token.
</li>
</ol>
</div>

<div class="algo">
<p>
`非-特別~pattern文字か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器, ~number %~index, 文字列 %値 )
に対し：
◎
To run is a non-special pattern char given a constructor string parser parser, a number index, and a string value:
</p>
<ol>
	<li>
%~token ~LET `安全な~tokenを取得する$( %構文解析器, %~index )
◎
Let token be the result of running get a safe token given parser and index.
</li>
	<li>
<p>
~RET ~IS ~AND↓：
</p>
		<ul>
			<li>
%~token の`値$tK ~EQ %値
</li>
			<li>
%~token の`種別$tK ~IN { `char$l, `escaped-char$l, `invalid-char$l }
</li>
		</ul>
◎
If token’s value is not value, then return false.
◎
If any of the following are true:
• token’s type is "char";
• token’s type is "escaped-char"; or
• token’s type is "invalid-char",
◎
then return true.
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`~protocol接尾辞か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run is a protocol suffix given a constructor string parser parser:
</p>
<ol>
	<li>
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `:^l )
◎
Return the result of running is a non-special pattern char given parser, parser’s token index, and ":".
</li>
</ol>
</div>

<div class="algo">
<p>
`次回は~authority~slash列か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run next is authority slashes given a constructor string parser parser:
</p>
<ol>
	<li>
~EACH( %n ~IN « 1, 2 » )
に対し
⇒
~IF［
`非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP ~PLUS %n, `/^l ) ~EQ ~F
］
⇒
~RET ~F
◎
If the result of running is a non-special pattern char given parser, parser’s token index + 1, and "/" is false, then return false.
◎
If the result of running is a non-special pattern char given parser, parser’s token index + 2, and "/" is false, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`識別情報~終了子か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run is an identity terminator given a constructor string parser parser:
</p>
<ol>
	<li>
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `@^l )
◎
Return the result of running is a non-special pattern char given parser, parser’s token index, and "@".
</li>
</ol>
</div>

<div class="algo">
<p>
`~password接頭辞か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run is a password prefix given a constructor string parser parser:
</p>
<ol>
	<li>
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `:^l )
◎
Return the result of running is a non-special pattern char given parser, parser’s token index, and ":".
</li>
</ol>
</div>

<div class="algo">
<p>
`~port接頭辞か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run is a port prefix given a constructor string parser parser:
</p>
<ol>
	<li>
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `:^l )
◎
Return the result of running is a non-special pattern char given parser, parser’s token index, and ":".
</li>
</ol>
</div>

<div class="algo">
<p>
`~pathname始端か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run is a pathname start given a constructor string parser parser:
</p>
<ol>
	<li>
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `/^l )
◎
Return the result of running is a non-special pattern char given parser, parser’s token index, and "/".
</li>
</ol>
</div>

<div class="algo">
<p>
`~search接頭辞か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run is a search prefix given a constructor string parser parser:
</p>
<ol>
	<li>
%~token~index ~LET %構文解析器 の`~token~index$csP
◎
↓</li>
	<li>
~IF［
`非-特別~pattern文字か否か$( %構文解析器, %~token~index, `?^l ) ~EQ ~T
］
⇒
~RET ~T
◎
If result of running is a non-special pattern char given parser, parser’s token index and "?" is true, then return true.
</li>
	<li>
~IF［
%構文解析器 の`~token~list$csP[ %~token~index ] の`値$tK ~NEQ `?^l
］
⇒
~RET ~F
◎
If parser’s token list[parser’s token index]'s value is not "?", then return false.
</li>
	<li>
~IF［
%~token~index ~LT 1
］
⇒
~RET ~T
◎
Let previous index be parser’s token index − 1.
◎
If previous index is less than 0, then return true.
</li>
	<li>
%直前の~token ~LET `安全な~tokenを取得する$( %構文解析器, %~token~index ~MINUS 1 )
◎
Let previous token be the result of running get a safe token given parser and previous index.
</li>
	<li>
~RET ~IS［
%直前の~token の`種別$tK ~NIN { `name$l, `regexp$l, `close$l, `asterisk$l }
］
◎
If any of the following are true, then return false:
• previous token’s type is "name".
• previous token’s type is "regexp".
• previous token’s type is "close".
• previous token’s type is "asterisk".
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
`~hash接頭辞か否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し
⇒
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `#^l )
◎
To run is a hash prefix given a constructor string parser parser:
• Return the result of running is a non-special pattern char given parser, parser’s token index and "#".
</div>

<div class="algo">
`~groupを開くか否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し
⇒
~RET ~IS［
%構文解析器 の`~token~list$csP[ %構文解析器 の`~token~index$csP ] の`種別$tK ~EQ `open$l
］
◎
To run is a group open given a constructor string parser parser:
• If parser’s token list[parser’s token index]'s type is "open", then return true.
• Otherwise return false.
</div>

<div class="algo">
`~groupを閉じるか否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し
⇒
~RET ~IS［
%構文解析器 の`~token~list$csP[ %構文解析器 の`~token~index$csP ] の`種別$tK ~EQ `close$l
］
◎
To run is a group close given a constructor string parser parser:
• If parser’s token list[parser’s token index]'s type is "close", then return true.
• Otherwise return false.
</div>

<div class="algo">
`~IPv6を開くか否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し
⇒
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `[^l )
◎
To run is an IPv6 open given a constructor string parser parser:
• Return the result of running is a non-special pattern char given parser, parser’s token index, and "[".
</div>

<div class="algo">
`~IPv6を閉じるか否か@
は、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し
⇒
~RET `非-特別~pattern文字か否か$( %構文解析器, %構文解析器 の`~token~index$csP, `]^l )
◎
To run is an IPv6 close given a constructor string parser parser:
• Return the result of running is a non-special pattern char given parser, parser’s token index, and "]".
</div>

<div class="algo">
<p>
`成分~文字列を抽出する@
~algoは、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To run make a component string given a constructor string parser parser:
</p>
<ol>
	<li>
~Assert：
%構文解析器 の`~token~index$csP ~LT %構文解析器 の`~token~list$csPの`~size$
◎
Assert: parser’s token index is less than parser’s token list's size.
</li>
	<li>
%~token ~LET %構文解析器 の`~token~list$csP[ %構文解析器 の`~token~index$csP ]
◎
Let token be parser’s token list[parser’s token index].
</li>
	<li>
%成分~始端~token ~LET `安全な~tokenを取得する$( %構文解析器, %構文解析器 の`成分~始端$csP )
◎
Let component start token be the result of running get a safe token given parser and parser’s component start.
</li>
	<li>
~RET %構文解析器 の`入力$csPの中の［
%成分~始端~token の`~index$tK
］から［
%~token の`~index$tK
］までを`成す符号位置~部分文字列$
◎
Let component start input index be component start token’s index.
◎
Let end index be token’s index.
◎
Return the code point substring from component start input index to end index within parser’s input.
</li>
</ol>
</div>

<div class="algo">
<p>
`~protocolは特別~schemeに合致するかを算出する@
~algoは、
所与の
( `構築子~文字列~構文解析器$ %構文解析器 )
に対し：
◎
To compute protocol matches a special scheme flag given a constructor string parser parser:
</p>
<ol>
	<li>
%~protocol文字列 ~LET `成分~文字列を抽出する$( %構文解析器 )
◎
Let protocol string be the result of running make a component string given parser.
</li>
	<li>
%~protocol成分 ~LET `成分を~compileする$( ↓ )
⇒＃
%~protocol文字列,
`~protocolを正準-化する$,
`既定の~option群$
◎
Let protocol component be the result of compiling a component given protocol string, canonicalize a protocol, and default options.
</li>
	<li>
~IF［
`~protocol成分は特別~schemeに合致しているか否か$( %~protocol成分 ) ~EQ ~T
］
⇒
%構文解析器 の`~protocolは特別~schemeに合致するか$csP ~SET ~T
◎
If the result of running protocol component matches a special scheme given protocol component is true, then set parser’s protocol matches a special scheme flag to true.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="pattern-strings">
<h2 title="Pattern strings">2. ~pattern文字列</h2>

<p>
`~pattern文字列@
は、
ある［
~target文字列たちが成す集合
］に合致するよう書かれた文字列である。
特定0の~pattern構文に適合する~pattern文字列は、
`整形式@
であるとされる。
この~pattern構文は、［
普及な `path-to-regexp$cite ~JS~libraryにより利用される構文
］に直に基づく。
◎
A pattern string is a string that is written to match a set of target strings. A well formed pattern string conforms to a particular pattern syntax. This pattern syntax is directly based on the syntax used by the popular path-to-regexp JavaScript library.
</p>

<p>
`~pattern文字列を構文解析する$ことにより，
`~part~list$が生産され得る
— 結果の~listは、
次を述べる
⇒
~pattern文字列に合致するためには、
~target文字列を成す各~成分【！in a component string】として，
何が この~listの順序で現れなければならないか
◎
It can be parsed to produce a part list which describes, in order, what must appear in a component string for the pattern string to match.
</p>

<div class="example">
<p>
~pattern文字列は、
捕捉~groupたちを包含し得る
— それは、
既定では，成分に特有な分離子
（~pathname内では `/^l ／ ~hostname内では `.^l ）
までを成すアリな限り短い文字列に合致する。
例えば、
~pathname用の~pattern `/blog/:title^l は、
`/blog/hello-world^l には合致するが，
`/blog/2012/02^l には合致しない。
◎
Pattern strings can contain capture groups, which by default match the shortest possible string, up to a component-specific separator (/ in the pathname, . in the hostname). For example, the pathname pattern "/blog/:title" will match "/blog/hello-world" but not "/blog/2012/02".
</p>

<p>
代わりに，丸括弧で括られた正規表現も利用できる
— ~pathname用の~pattern `/blog/:year(\\d+)/:month(\\d+)^l は、
`/blog/2012/02^l に合致することになる。
◎
A regular expression enclosed in parentheses can also be used instead, so the pathname pattern "/blog/:year(\\d+)/:month(\\d+)" will match "/blog/2012/02".
</p>

<p>
~groupは、
改変子を利用して［
省略可能／繰返可能
］にされることもある。
例えば，~pathname用の~pattern `/products/:id?^l は、［
`/products^l, `/products/2^l
］どちらにも合致することになる
（が、
`/products/^l には合致しない）。
特定的に，~pathname内では、
~groupは，先頭の `/^c を自動的に要求する
— これを避けるため、
~pathname~pattern内の~groupは，
`/products/{:id}?^l のように明示的に区切れる。
◎
A group can also be made optional, or repeated, by using a modifier. For example, the pathname pattern "/products/:id?" will match both "/products" and "/products/2" (but not "/products/"). In the pathname specifically, groups automatically require a leading /; to avoid this, the group can be explicitly deliminated, as in the pathname pattern "/products/{:id}?".
</p>

<p>
アリなものすべてに合致するものとして，全部的~wildcard `*^c も利用できる
— ~pathname~pattern `/products/*^l のように。
◎
A full wildcard * can also be used to match as much as possible, as in the pathname pattern "/products/*".
</p>
</div>

		<section id="parsing-pattern-strings">
<h3 title="Parsing pattern strings">2.1. ~pattern文字列の構文解析-法</h3>

			<section id="tokens">
<h4 title="Tokens">2.1.1. ~token</h4>

<p>
`~token~list@
は、
`~token$たちが成す`~list$である。
◎
A token list is a list containing zero or more token structs.
</p>

<p>
各
`~token@
は、
次に挙げる~itemからなる`構造体$であり，
`~pattern文字列$の中の 1 個の字句-~tokenを表現する：
◎
A token is a struct representing a single lexical token within a pattern string.
</p>
<ul>
	<li>
<p>
`種別@tK
⇒
ある文字列
— 初期~時は `invalid-char$l とする：
◎
A token has an associated type, a string, initially "invalid-char".＼
</p>

<p>
その値は、
次に挙げるいずれかでなければナラナイ：
◎
It must be one of the following:
</p>
		<dl>
			<dt>`open@l</dt>
			<dd>
当の`~token$は、
符号位置 `007B^U を表現する。
◎
The token represents a U+007B ({) code point.
</dd>

			<dt>`close@l</dt>
			<dd>
当の`~token$は、
符号位置 `007D^U を表現する。
◎
The token represents a U+007D (}) code point.
</dd>

			<dt>`regexp@l</dt>
			<dd>
当の`~token$は、
"<code>(`正規表現^t)</code>"
の形を成す文字列を表現する。
%正規表現 は、
`~ASCII符号位置$のみからなることが要求される。
◎
The token represents a string of the form "(&lt;regular expression&gt;)". The regular expression is required to consist of only ASCII code points.
</dd>

			<dt>`name@l</dt>
			<dd>
当の`~token$は、
"<code>:`名前^t</code>" の形を成す文字列を表現する。
%名前 を成す符号位置たちは、
~JS識別子に整合なものに制約される。
◎
The token represents a string of the form ":&lt;name&gt;". The name value is restricted to code points that are consistent with JavaScript identifiers.
</dd>

			<dt>`char@l</dt>
			<dd>
当の`~token$は、［
特別な構文上の意味を伴わない妥当な~pattern符号位置
］を表現する。
◎
The token represents a valid pattern code point without any special syntactical meaning.
</dd>

			<dt>`escaped-char@l</dt>
			<dd>
当の`~token$は、
~backslashを利用して~escapeされた
（ "<code>\`文字^t</code>" の様な）
符号位置を表現する。
◎
The token represents a code point escaped using a backslash like "\&lt;char&gt;".
</dd>

			<dt>`other-modifier@l</dt>
			<dd>
当の`~token$は、
照合~group改変子
— 符号位置［
`003F^U ／ `002B^U
］ —
を表現する。
◎
The token represents a matching group modifier that is either the U+003F (?) or U+002B (+) code points.
</dd>

			<dt>`asterisk@l</dt>
			<dd>
当の`~token$は、［
~wildcard照合~group／
照合~group改変子
］いずれかになる符号位置 `002A^U を表現する。
◎
The token represents a U+002A (*) code point that can be either a wildcard matching group or a matching group modifier.
</dd>

			<dt>`end@l</dt>
			<dd>
当の`~token$は、
`~pattern文字列$の終端を表現する。
◎
The token represents the end of the pattern string.
</dd>

			<dt>`invalid-char@l</dt>
			<dd>
当の`~token$は、
当の~patternにおいては
— ［
当の符号位置の値~自体／
当の~patternの中での他の構文-要素に相対的な所在
］が妥当でないなどに因り —
妥当でない符号位置を表現する。
◎
The token represents a code point that is invalid in the pattern. This could be because of the code point value itself or due to its location within the pattern relative to other syntactic elements.
</dd>
		</dl>
	</li>
	<li>
<p>
`~index@tK
⇒
ある~number
— 初期~時は 0 とする。
◎
A token has an associated index, a number, initially 0.＼
</p>

<p>
これは、［
当の`~token$により表現される`~pattern文字列$を成す最初の符号位置
］の位置を与える。
◎
It is the position of the first code point in the pattern string represented by the token.
</p>
	</li>
	<li>
<p>
`値@tK
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
A token has an associated value, a string, initially the empty string.＼
</p>

<p>
これは、
当の`~token$により表現される`~pattern文字列$からの符号位置たちを包含する。
◎
It contains the code points from the pattern string represented by the token.
</p>
	</li>
</ul>

			</section>
			<section id="tokenizing">
<h4 title="Tokenizing">2.1.2. ~token化法</h4>

<p>
`~token化~施策@
は、
次に挙げるいずれかの文字列である
⇒
`strict@l
／
`lenient@l
◎
A tokenize policy is a string that must be either "strict" or "lenient".
</p>

<p>
`~token化器@
は、
次に挙げる~itemからなる`構造体$である：
◎
A tokenizer is a struct.
</p>
<ul>
	<li>
`入力@tkz
⇒
ある`~pattern文字列$
— 初期~時は空~文字列とする。
◎
A tokenizer has an associated input, a pattern string, initially the empty string.
</li>
	<li>
`施策@tkz
⇒
ある`~token化~施策$
— 初期~時は `strict$l とする。
◎
A tokenizer has an associated policy, a tokenize policy, initially "strict".
</li>
	<li>
`~token~list@tkz
⇒
ある`~token~list$
— 初期~時は新たな`~list$とする。
◎
A tokenizer has an associated token list, a token list, initially an empty list.
</li>
	<li>
`~index@tkz
⇒
ある~number
— 初期~時は 0 とする。
◎
A tokenizer has an associated index, a number, initially 0.
</li>
	<li>
`次回の~index@tkz
⇒
ある~number
— 初期~時は 0 とする。
◎
A tokenizer has an associated next index, a number, initially 0.
</li>
	<li>
`符号位置@tkz
⇒
ある`符号位置$
— 初期~時は ~NULL とする。
◎
A tokenizer has an associated code point, a Unicode code point, initially null.
</li>
</ul>

<div class="algo">
<p>
`~token化する@
~algoは、
所与の
( 文字列 %入力, `~token化~施策$ %施策 )
に対し：
◎
To tokenize a given string input and tokenize policy policy:
</p>
<ol>
	<li>
%~token化器 ~LET 新たな`~token化器$
— その
⇒＃
`入力$tkz ~SET %入力,
`施策$tkz ~SET %施策
◎
Let tokenizer be a new tokenizer.
◎
Set tokenizer’s input to input.
◎
Set tokenizer’s policy to policy.
</li>
	<li>
<p>
~WHILE［
%~token化器 の`~index$tkz ~LT %~token化器 の`入力$tkzの`符号位置~長さ$
］：
◎
While tokenizer’s index is less than tokenizer’s input's code point length:
</p>
		<ol>
			<li>
`~seekしてから次回の符号位置を取得する$( %~token化器, %~token化器 の`~index$tkz )
◎
Run seek and get the next code point given tokenizer and tokenizer’s index.
</li>
			<li>
<p>
%~token化器 の`符号位置$tkzに応じて：
◎
↓</p>
				<dl class="switch">
					<dt>
`002A^U
◎
If tokenizer’s code point is U+002A (*):
</dt>
					<dd>
						<ol>
							<li>
`既定の位置と長さを伴う~tokenを追加する$( %~token化器, `asterisk$l )
◎
Run add a token with default position and length given tokenizer and "asterisk".
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
`002B^U
◎
If tokenizer’s code point is U+002B (+)＼
</dt>
					<dt>
`003F^U
◎
or U+003F (?):
</dt>
					<dd>
						<ol>
							<li>
`既定の位置と長さを伴う~tokenを追加する$( %~token化器, `other-modifier$l )
◎
Run add a token with default position and length given tokenizer and "other-modifier".
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
`005C^U
◎
If tokenizer’s code point is U+005C (\):
</dt>
					<dd>
						<ol>
							<li>
<p>
~IF［
%~token化器 の`~index$tkz ~EQ %~token化器 の`入力$tkzの`符号位置~長さ$ ~MINUS 1
］：
◎
If tokenizer’s index is equal to tokenizer’s input's code point length − 1:
</p>
								<ol>
									<li>
`~token化時の~errorを処理する$( %~token化器, %~token化器 の`次回の~index$tkz )
◎
Run process a tokenizing error given tokenizer, tokenizer’s next index, and tokenizer’s index.
</li>
									<li>
~CONTINUE
◎
Continue.
</li>
								</ol>
							</li>
							<li>
%~escapeされる~index ~LET %~token化器 の`次回の~index$tkz
◎
Let escaped index be tokenizer’s next index.
</li>
							<li>
`次回の符号位置を取得する$( %~token化器 )
◎
Run get the next code point given tokenizer.
</li>
							<li>
`既定の長さを伴う~tokenを追加する$( ↓ )
⇒＃
%~token化器,
`escaped-char$l,
%~token化器 の`次回の~index$tkz,
%~escapeされる~index
◎
Run add a token with default length given tokenizer, "escaped-char", tokenizer’s next index, and escaped index.
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
`007B^U
◎
If tokenizer’s code point is U+007B ({):
</dt>
					<dd>
						<ol>
							<li>
`既定の位置と長さを伴う~tokenを追加する$( %~token化器, `open$l )
◎
Run add a token with default position and length given tokenizer and "open".
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
`007D^U
◎
If tokenizer’s code point is U+007D (}):
</dt>
					<dd>
						<ol>
							<li>
`既定の位置と長さを伴う~tokenを追加する$( %~token化器, `close$l )
◎
Run add a token with default position and length given tokenizer and "close".
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
`003A^U
◎
If tokenizer’s code point is U+003A (:):
</dt>
					<dd>
						<ol>
							<li>
%名前~位置 ~LET %~token化器 の`次回の~index$tkz
◎
Let name position be tokenizer’s next index.
</li>
							<li>
%名前~始端 ~LET %名前~位置
◎
Let name start be name position.
</li>
							<li>
<p>
~WHILE［
%名前~位置 ~LT %~token化器 の`入力$tkzの`符号位置~長さ$
］：
◎
While name position is less than tokenizer’s input's code point length:
</p>
								<ol>
									<li>
`~seekしてから次回の符号位置を取得する$( %~token化器, %名前~位置 )
◎
Run seek and get the next code point given tokenizer and name position.
</li>
									<li>
<p>
~IF［
~OR↓
］…
</p>
										<ul>
											<li>
［
%名前~位置 ~EQ %名前~始端
］~AND［
%~token化器 の`符号位置$tkzは`妥当な最初の名前~符号位置$でない
］
</li>
											<li>
［
%名前~位置 ~NEQ %名前~始端
］~AND［
%~token化器 の`符号位置$tkzは`妥当な名前~符号位置$でない
］
</li>
										</ul>
<p>
ならば
⇒
~BREAK
</p>
◎
Let first code point be true if name position equals name start and false otherwise.
◎
Let valid code point be the result of running is a valid name code point given tokenizer’s code point and first code point.
◎
If valid code point is false break.
</li>
									<li>
%名前~位置 ~SET %~token化器 の`次回の~index$tkz
◎
Set name position to tokenizer’s next index.
</li>
								</ol>
							</li>
							<li>
<p>
~IF［
%名前~位置 ~LTE %名前~始端
］：
◎
If name position is less than or equal to name start:
</p>
								<ol>
									<li>
`~token化時の~errorを処理する$( %~token化器, %名前~始端 )
◎
Run process a tokenizing error given tokenizer, name start, and tokenizer’s index.
</li>
									<li>
~CONTINUE
◎
Continue.
</li>
								</ol>
							</li>
							<li>
`既定の長さを伴う~tokenを追加する$( ↓ )
⇒＃
%~token化器,
`name$l,
%名前~位置,
%名前~始端
◎
Run add a token with default length given tokenizer, "name", name position, and name start.
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
`0028^U
◎
If tokenizer’s code point is U+0028 (():
</dt>
					<dd>
						<ol>
							<li>
%深さ ~LET 1
◎
Let depth be 1.
</li>
							<li>
%~regexp位置 ~LET %~token化器 の`次回の~index$tkz
◎
Let regexp position be tokenizer’s next index.
</li>
							<li>
%~regexp始端 ~LET %~regexp位置
◎
Let regexp start be regexp position.
</li>
							<li>
%~errorか ~LET ~F
◎
Let error be false.
</li>
							<li>
<p>
~WHILE［
%~regexp位置 ~LT %~token化器 の`入力$tkzの`符号位置~長さ$
］：
◎
While regexp position is less than tokenizer’s input's code point length:
</p>
								<ol>
									<li>
`~seekしてから次回の符号位置を取得する$( %~token化器, %~regexp位置 )
◎
Run seek and get the next code point given tokenizer and regexp position.
</li>
									<li>
<p>
~IF［
%~token化器 の`符号位置$tkzは`~ASCII符号位置$【！#is-ascii】でない
］：
◎
If the result of running is ASCII given tokenizer’s code point is false:
</p>
										<ol>
											<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
											<li>
%~errorか ~SET ~T
◎
Set error to true.
</li>
											<li>
~BREAK
◎
Break.
</li>
										</ol>
									</li>
									<li>
<p>
~IF［
%~regexp位置 ~EQ %~regexp始端
］~AND［
%~token化器 の`符号位置$tkz ~EQ `003F^U
］：
◎
If regexp position equals regexp start and tokenizer’s code point is U+003F (?):
</p>
										<ol>
											<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
											<li>
%~errorか ~SET ~T
◎
Set error to true.
</li>
											<li>
~BREAK
◎
Break.
</li>
										</ol>
									</li>
									<li>
<p>
~IF［
%~token化器 の`符号位置$tkz ~EQ `005C^U
］：
◎
If tokenizer’s code point is U+005C (\):
</p>
										<ol>
											<li>
<p>
~IF［
%~regexp位置 ~EQ %~token化器 の`入力$tkzの`符号位置~長さ$ ~MINUS 1
］：
◎
If regexp position equals tokenizer’s input's code point length − 1:
</p>
												<ol>
													<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
													<li>
%~errorか ~SET ~T
◎
Set error to true.
</li>
													<li>
~BREAK
◎
Break
</li>
												</ol>
											</li>
											<li>
`次回の符号位置を取得する$( %~token化器 )
◎
Run get the next code point given tokenizer.
</li>
											<li>
<p>
~IF［
%~token化器 の`符号位置$tkzは`~ASCII符号位置$【！#is-ascii】でない
］：
◎
If the result of running is ASCII given tokenizer’s code point is false:
</p>												<ol>
													<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
													<li>
%~errorか ~SET ~T
◎
Set error to true.
</li>
													<li>
~BREAK
◎
Break.
</li>
												</ol>
											</li>
											<li>
%~regexp位置 ~SET %~token化器 の`次回の~index$tkz
◎
Set regexp position to tokenizer’s next index.
</li>
											<li>
~CONTINUE
◎
Continue.
</li>
										</ol>
									</li>
									<li>
<p>
~IF［
%~token化器 の`符号位置$tkz ~EQ `0029^U
］：
◎
If tokenizer’s code point is U+0029 ()):
</p>
										<ol>
											<li>
%深さ ~DECBY 1
◎
Decrement depth by 1.
</li>
											<li>
<p>
~IF［
%深さ ~EQ 0
］：
◎
If depth is 0:
</p>
												<ol>
													<li>
%~regexp位置 ~SET %~token化器 の`次回の~index$tkz
◎
Set regexp position to tokenizer’s next index.
</li>
													<li>
~BREAK
◎
Break.
</li>
												</ol>
											</li>
										</ol>
									</li>
									<li>
<p>
~ELIF［
%~token化器 の`符号位置$tkz ~EQ `0028^U
］：
◎
Otherwise if tokenizer’s code point is U+0028 (():
</p>
										<ol>
											<li>
%深さ ~INCBY 1
◎
Increment depth by 1.
</li>
											<li>
<p>
~IF［
%~regexp位置 ~EQ %~token化器 の`入力$tkzの`符号位置~長さ$ ~MINUS 1
］：
◎
If regexp position equals tokenizer’s input's code point length − 1:
</p>
												<ol>
													<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
													<li>
%~errorか ~SET ~T
◎
Set error to true.
</li>
													<li>
~BREAK
◎
Break
</li>
												</ol>
											</li>
											<li>
%戻り位置 ~LET %~token化器 の`次回の~index$tkz
◎
Let temporary position be tokenizer’s next index.
</li>
											<li>
`次回の符号位置を取得する$( %~token化器 )
◎
Run get the next code point given tokenizer.
</li>
											<li>
<p>
~IF［
%~token化器 の`符号位置$tkz ~NEQ `003F^U
］：
◎
If tokenizer’s code point is not U+003F (?):
</p>
												<ol>
													<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
													<li>
%~errorか ~SET ~T
◎
Set error to true.
</li>
													<li>
~BREAK
◎
Break.
</li>
												</ol>
											</li>
											<li>
%~token化器 の`次回の~index$tkz ~SET %戻り位置
◎
Set tokenizer’s next index to temporary position.
</li>
										</ol>
									</li>
									<li>
%~regexp位置 ~SET %~token化器 の`次回の~index$tkz
◎
Set regexp position to tokenizer’s next index.
</li>
								</ol>
							</li>
							<li>
~IF［
%~errorか ~EQ ~T
］
⇒
~CONTINUE
◎
If error is true continue.
</li>
							<li>
<p>
~IF［
%深さ ~NEQ 0
］：
◎
If depth is not zero:
</p>
								<ol>
									<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
									<li>
~CONTINUE
◎
Continue.
</li>
								</ol>
							</li>
							<li>
%~regexp長さ ~LET %~regexp位置 ~MINUS %~regexp始端 ~MINUS 1
◎
Let regexp length be regexp position − regexp start − 1.
</li>
							<li>
<p>
~IF［
%~regexp長さ ~EQ 0
］：
◎
If regexp length is zero:
</p>
								<ol>
									<li>
`~token化時の~errorを処理する$( %~token化器, %~regexp始端 )
◎
Run process a tokenizing error given tokenizer, regexp start, and tokenizer’s index.
</li>
									<li>
~CONTINUE
◎
Continue.
</li>
								</ol>
							</li>
							<li>
`~tokenを追加する$( ↓ )
⇒＃
%~token化器,
`regexp$l,
%~regexp位置,
%~regexp始端,
%~regexp長さ
◎
Run add a token given tokenizer, "regexp", regexp position, regexp start, and regexp length.
◎
Continue.
</li>
						</ol>
					</dd>

					<dt>
その他
◎
↑</dt>
					<dd>
`既定の位置と長さを伴う~tokenを追加する$( %~token化器, `char$l )
◎
Run add a token with default position and length given tokenizer and "char".
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
`既定の長さを伴う~tokenを追加する$( ↓ )
⇒＃
%~token化器,
`end$l,
%~token化器 の`~index$tkz,
%~token化器 の`~index$tkz
◎
Run add a token with default length given tokenizer, "end", tokenizer’s index, and tokenizer’s index.
</li>
	<li>
~RET %~token化器 の`~token~list$tkz
◎
Return tokenizer’s token list.
</li>
</ol>
</div>

<div class="algo">
<p>
`次回の符号位置を取得する@
~algoは、
所与の
( `~token化器$ %~token化器 )
に対し：
◎
To get the next code point for a given tokenizer tokenizer:
</p>
<ol>
	<li>
%~token化器 の`符号位置$tkz ~SET %~token化器 の`入力$tkzを成す［
%~token化器 の`次回の~index$tkz
］番の符号位置
◎
Set tokenizer’s code point to the Unicode code point in tokenizer’s input at the position indicated by tokenizer’s next index.
</li>
	<li>
%~token化器 の`次回の~index$tkz ~INCBY 1
◎
Increment tokenizer’s next index by 1.
</li>
</ol>
</div>

<div class="algo">
<p>
`~seekしてから次回の符号位置を取得する@
~algoは、
所与の
( `~token化器$ %~token化器, ~number %~index )
に対し：
◎
To seek and get the next code point for a given tokenizer tokenizer and number index:
</p>
<ol>
	<li>
%~token化器 の`次回の~index$tkz ~SET %~index
◎
Set tokenizer’s next index to index.
</li>
	<li>
`次回の符号位置を取得する$( %~token化器 )
◎
Run get the next code point given tokenizer.
</li>
</ol>
</div>

<div class="algo">
<p>
`~tokenを追加する@
~algoは、
所与の
⇒＃
`~token化器$ %~token化器,
`種別$tK %種別,
~number %次回の位置,
~number %値~位置,
~number %値~長さ
◎終
に対し：
◎
To add a token for a given tokenizer tokenizer, type type, number next position, number value position, and number value length:
</p>
<ol>
	<li>
%~token ~LET 新たな`~token$
— その
⇒＃
`種別$tK ~SET %種別,
`~index$tK ~SET %~token化器 の`~index$tkz,
`値$tK ~SET `符号位置~部分文字列$( %~token化器 の`入力$tkz, %値~位置, %値~長さ )
◎
Let token be a new token.
◎
Set token’s type to type.
◎
Set token’s index to tokenizer’s index.
◎
Set token’s value to the code point substring from value position with length value length within tokenizer’s input.
</li>
	<li>
%~token化器 の`~token~list$tkz の `to the back of^en 【？】に %~token を`付加する$
◎
Append token to the back of tokenizer’s token list.
</li>
	<li>
%~token化器 の`~index$tK ~SET %次回の位置
◎
Set tokenizer’s index to next position.
</li>
</ol>
</div>

<div class="algo">
<p>
`既定の長さを伴う~tokenを追加する@
~algoは、
所与の
⇒＃
`~token化器$ %~token化器,
`種別$tK %種別,
~number %次回の位置,
~number %値~位置
◎終
に対し：
◎
To add a token with default length for a given tokenizer tokenizer, type type, number next position, and number value position:
</p>
<ol>
	<li>
%算出d長さ ~LET %次回の位置 ~MINUS %値~位置
◎
Let computed length be next position − value position.
</li>
	<li>
`~tokenを追加する$( ↓ )
⇒＃
%~token化器,
%種別,
%次回の位置,
%値~位置,
%算出d長さ
◎
Run add a token given tokenizer, type, next position, value position, and computed length.
</li>
</ol>
</div>

<div class="algo">
`既定の位置と長さを伴う~tokenを追加する@
~algoは、
所与の
( `~token化器$ %~token化器, `種別$tK %種別 )
に対し
⇒
`既定の長さを伴う~tokenを追加する$( ↓ )
⇒＃
%~token化器,
%種別,
%~token化器 の`次回の~index$tkz,
%~token化器 の`~index$tkz
◎
To add a token with default position and length for a given tokenizer tokenizer and type type:
• Run add a token with default length given tokenizer, type, tokenizer’s next index, and tokenizer’s index.
</div>

<div class="algo">
<p>
`~token化時の~errorを処理する@
~algoは、
所与の
⇒＃
`~token化器$ %~token化器,
~number %次回の位置,
~number %値~位置 ~DF %~token化器 の`~index$tkz
◎終
に対し，
%~token化器 の`施策$tkzに応じて：
</p>
<ul class="switch">
	<li>
`strict$l
⇒
~THROW `TypeError$E
</li>
	<li>
`lenient$l
⇒
`既定の長さを伴う~tokenを追加する$( ↓ )
⇒＃
%~token化器,
`invalid-char$l,
%次回の位置,
%値~位置
</li>
	<li>
その他
⇒
~Assert：
この事例は生じない。
</li>
</ul>

<p class="trans-note">【
他所の記述を簡約するため、
この訳では，引数 %値~位置 を省略可能にしてある。
】</p>
◎
To process a tokenizing error for a given tokenizer tokenizer, a number next position, and a number value position:
• If tokenizer’s policy is "strict", then throw a TypeError.
• Assert: tokenizer’s policy is "lenient".
• Run add a token with default length given tokenizer, "invalid-char", next position, and value position.
</div>

<div>
<p>
`妥当な最初の名前~符号位置@
とは、
`IdentifierStart$P 構文に合致する`符号位置$である
</p>

<p>
`妥当な名前~符号位置@
とは、
`IdentifierPart$P 構文に合致する`符号位置$である
</p>
◎
To perform is a valid name code point given a Unicode code point and a boolean first:
• If first is true return the result of checking if code point is contained in the IdentifierStart set of code points.
• Otherwise return the result of checking if code point is contained in the IdentifierPart set of code points.
</div>

<div>
【！#is-ascii → ~ASCII符号位置】
◎
To determine if a Unicode code point is ASCII:
• If code point is between U+0000 and U+007F inclusive, then return true.
• Otherwise return false.
</div>

			</section>
			<section id="parts">
<h4 title="Parts">2.1.3. ~part</h4>

<p>
`~part~list@
は、
`~part$たちが成す`~list$である。
◎
A part list is a list of zero or more parts.
</p>

<p>
各
`~part@
は、
次に挙げる`~item$sctからなる`構造体$であり【！has an associated】，
構文解析器の`~pattern文字列$を成す 1 個の~pieceを表現する。
それは、［
照合~group,
固定的な~text接頭辞,
固定的な~text接尾辞,
改変子
］それぞれを 1 個まで包含し得る。
それは、［
固定的な~text文字列／
照合~group
］のうち一つを 1 個だけ包含し得る：
◎
A part is a struct representing one piece of a parser pattern string. It can contain at most one matching group, a fixed text prefix, a fixed text suffix, and a modifier. It can contain as little as a single fixed text string or a single matching group.
</p>

<ul>
	<li>
<p>
`種別@pt
⇒
ある文字列
— 作成-時に設定されなければナラナイ。
◎
A part has an associated type, a string, which must be set upon creation.＼
</p>

<p>
その値は、
次に挙げるいずれかでなければナラナイ：
◎
It must be one of the following:
</p>
		<dl>
			<dt>`fixed-text@l</dt>
			<dd>
当の`~part$は、
単純な［
固定的な~text文字列
］を表現する。
◎
The part represents a simple fixed text string.
</dd>

			<dt>`~regexp0@l</dt>
			<dd>
当の`~part$は［
~customな正規表現を伴う照合~group
］を表現する。
◎
The part represents a matching group with a custom regular expression.
</dd>

			<dt>`segment-wildcard@l</dt>
			<dd>
当の`~part$は、［
次回の分離子~符号位置までの符号位置たちに合致する照合~group
］を表現する。
これは、
概して， `:foo^l の様な［
~customな正規表現を伴わない有名~group
］に利用される。
◎
The part represents a matching group that matches code points up to the next separator code point. This is typically used for a named group like ":foo" that does not have a custom regular expression.
</dd>

			<dt>`full-wildcard@l</dt>
			<dd>
当の`~part$は、［
すべての符号位置に貪欲に合致する照合~group
］を表現する。
これは、
概して，~wildcard照合~group `*^l 用に利用される。
◎
The part represents a matching group that greedily matches all code points. This is typically used for the "*" wildcard matching group.
</dd>
		</dl>
	</li>
	<li>
`値@pt
⇒
ある文字列
— 作成-時に設定されなければナラナイ。
◎
A part has an associated value, a string, which must be set upon creation.
</li>
	<li>
<p>
`改変子@pt
⇒
ある文字列
— 作成-時に設定されなければナラナイ。
◎
A part has an associated modifier a string, which must be set upon creation.＼
</p>

<p>
その値は、
次に挙げるいずれかでなければナラナイ：
◎
It must be one of the following:
</p>
		<dl>
			<dt>`none@l</dt>
			<dd>
当の`~part$は、
`改変子$ptを有さない。
◎
The part does not have a modifier.
</dd>

			<dt>`optional@l</dt>
			<dd>
当の`~part$は、
符号位置 `003F^U により指示される［
省略可能にする`改変子$pt
］を有する。
◎
The part has an optional modifier indicated by the U+003F (?) code point.
</dd>

			<dt>`zero-or-more@l</dt>
			<dd>
当の`~part$は、
符号位置 `002A^U により指示される［
0 回以上~繰返可能にする`改変子$pt
］を有する。
◎
The part has a "zero or more" modifier indicated by the U+002A (*) code point.
</dd>

			<dt>`one-or-more@l</dt>
			<dd>
当の`~part$は、
符号位置 `002B^U により指示される［
1 回以上~繰返可能にする`改変子$pt
］を有する。
◎
The part has a "one or more" modifier indicated by the U+002B (+) code point.
</dd>
		</dl>
	</li>
	<li>
`名前@pt
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
A part has an associated name, a string, initially the empty string.
</li>
	<li>
`接頭辞@pt
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
A part has an associated prefix, a string, initially the empty string.
</li>
	<li>
`接尾辞@pt
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
A part has an associated suffix, a string, initially the empty string.
</li>
</ul>

			</section>
			<section id="options-header">
<h4 title="Options">2.1.4. ~option群</h4>

<p>
`~option群@
は、［
`~pattern文字列$がどう挙動するかを制御する各種~設定
］を包含する`構造体$である。
これは，元々は `path-to-regexp$cite に由来するが、
この~option群に含まれるものは，うち一部
— この仕様の中で改変される~option —
に限られる。
この仕様は、
比較の目的においては，［
`strict^c, `start^c, `end^c
］が常に ~F に設定された `path-to-regexp$cite の様に動作する。
◎
An options struct contains different settings that control how pattern string behaves. These options originally come from path-to-regexp. We only include the options that are modified within the URLPattern specification and exclude the other options. For the purposes of comparison, this specification acts like path-to-regexp where strict, start, and end are always set to false.
</p>

<p>
各`~option群$は、
次に挙げる~itemからなる：
◎
↓</p>

<ul>
	<li>
<p>
`区切子~符号位置@opt
⇒
ある文字列
— 作成-時に設定されなければナラナイ。
◎
An options has an associated delimiter code point, a string, which must be set upon creation.＼
</p>

<p>
その値は、
1 個の`~ASCII符号位置$からなるか空~文字列でなければナラナイ。
◎
It must contain one ASCII code point or the empty string.＼
</p>

<p>
この符号位置は、
区分~分離子として扱われ，有名~group `:foo^c が［
既定では どこまで合致するべきか
］を決定するために利用される。
例えば，［
`区切子~符号位置$opt ~EQ `/^l
］の下では、
~pattern `/:foo^l は， `/bar^l には合致するが `/bar/baz^l には合致しない。
［
`区切子~符号位置$opt ~EQ 空~文字列
］の下では、
この例の~patternは，どちらの文字列にも合致することになる。
◎
This code point is treated as a segment separator and is used for determining how far a :foo named group should match by default. For example, if the delimiter code point is "/" then "/:foo" will match "/bar", but not "/bar/baz". If the delimiter code point is the empty string then the example pattern would match both strings.
</p>
	</li>
	<li>
<p>
`接頭辞~符号位置@opt
⇒
ある文字列
— 作成-時に設定されなければナラナイ。
◎
An options has an associated prefix code point, a string, which must be set upon creation.＼
</p>

<p>
その値は、
1 個の`~ASCII符号位置$からなるか空~文字列でなければナラナイ。
◎
It must contain one ASCII code point or the empty string.＼
</p>

<p>
この符号位置は、
照合-~groupの直前に見出された場合には，自動的な接頭辞として扱われる。
これは、
ある照合-~groupが［
省略可能になる／繰返可能になる
］よう改変されるときに問われる。
例えば，［
`接頭辞~符号位置$opt ~EQ `/^l
］の下では、
~pattern `/foo/:bar?/baz^l を成す有名~group `:bar^l の直前にある `/^l は、
接頭辞として扱われ，当の有名~groupと一緒に省略可能になる。
なので、
この~patternは `/foo/baz^l に合致することになる。
◎
The code point is treated as an automatic prefix if found immediately preceding a match group. This matters when a match group is modified to be optional or repeating. For example, if prefix code point is "/" then "/foo/:bar?/baz" will treat the "/" before ":bar" as a prefix that becomes optional along with the named group. So in this example the pattern would match "/foo/baz".
</p>
	</li>
	<li>
<p>
`文字大小を無視するか@opt
⇒
ある真偽値
— 初期~時は ~F とする。【！which must be set up upon ...】
◎
An options has an associated ignore case, a boolean, which must be set up upon creation. It defaults to false.＼
</p>

<p>
この~flagは、［
~T ならば文字大小区別／
~F ならば文字大小無視
］で照合することを可能化する。
この文字大小は、
比較の目的においては［
`path-to-regexp$cite における `sensitive^c ~optionの否定
］として捉えれる。
◎
Depending on the set value, true or false, this flag enables case-sensitive or case-insensitive matches, respectively. For the purpose of comparison, this case be thought of as the negated sensitive option in path-to-regexp.
</p>
	</li>
</ul>

			</section>
			<section id="parsing">
<h4 title="Parsing">2.1.5. 構文解析</h4>

<div class="algo">
`符号化~callback@
は、
( 文字列 %入力 )
をとる抽象-~algoである
— %入力 は、
`~pattern文字列$を成す単純な~text~pieceとして与えられる。
その実装は、
%入力 を検証して符号化することになる。
この~algoは、
符号化した文字列を返すか例外を投出しなければナラナイ。
◎
An encoding callback is an abstract algorithm that takes a given string input. The input will be a simple text piece of a pattern string. An implementing algorithm will validate and encode the input. It must return the encoded string or throw an exception.
</div>

<p>
`~pattern構文解析器@
は、
次に挙げる~itemからなる`構造体$である：
◎
A pattern parser is a struct.
</p>
<ul>
	<li>
`~token~list@pP
⇒
ある`~token~list$
— 初期~時は新たな`~list$とする。
◎
A pattern parser has an associated token list, a token list, initially an empty list.
</li>
	<li>
`符号化~callback@pP
⇒
ある`符号化~callback$
— 作成-時に設定されなければナラナイ。
◎
A pattern parser has an associated encoding callback, a encoding callback, that must be set upon creation.
</li>
	<li>
`区分~wildcard~regexp@pP
⇒
ある文字列
— 作成-時に設定されなければナラナイ。
◎
A pattern parser has an associated segment wildcard regexp, a string, that must be set upon creation.
</li>
	<li>
`~part~list@pP
⇒
ある`~part~list$
— 初期~時は新たな`~list$とする。
◎
A pattern parser has an associated part list, a part list, initially an empty list.
</li>
	<li>
`処理待ち固定d値@pP
⇒
ある文字列
— 初期~時は空~文字列とする。
◎
A pattern parser has an associated pending fixed value, a string, initially the empty string.
</li>
	<li>
`~index@pP
⇒
ある~number
— 初期~時は 0 とする。
◎
A pattern parser has an associated index, a number, initially 0.
</li>
	<li>
`次回の数量-名@pP
⇒
ある~number
— 初期~時は 0 とする。
◎
A pattern parser has an associated next numeric name, a number, initially 0.
</li>
</ul>

<div class="algo">
<p>
`~pattern文字列を構文解析する@
~algoは、
所与の
⇒＃
`~pattern文字列$ %入力,
`~option群$ %~option群,
`符号化~callback$ %符号化~callback
◎終
に対し：
◎
To parse a pattern string given a pattern string input, options options, and encoding callback encoding callback:
</p>
<ol>
	<li>
%構文解析器 ~LET 新たな`~pattern構文解析器$
— その
⇒＃
`符号化~callback$pP ~SET %符号化~callback,
`区分~wildcard~regexp$pP ~SET `区分~wildcard~regexpを生成する$( %~option群 )
◎
Let parser be a new pattern parser whose encoding callback is encoding callback and segment wildcard regexp is the result of running generate a segment wildcard regexp given options.
</li>
	<li>
%構文解析器 の`~token~list$pP ~SET `~token化する$( %入力, `strict$l )
◎
Set parser’s token list to the result of running tokenize given input and "strict".
</li>
	<li>
<p>
~WHILE［
%構文解析器 の`~index$pP ~LT %構文解析器 の`~token~list$pPの`~size$
］：
◎
While parser’s index is less than parser’s token list's size:
</p>

<div class="example" id="parse-example-1">
<p>
この段では、
まず，入力から［
`char$l,
`name$l,
`regexp$l,
`other-modifier$l
］`~token$を順に探す。
これらの`~token$は、
どれも， 1 個だけ在ることも無いこともある。
◎
This first section is looking for the sequence: &lt;prefix char&gt;&lt;name&gt;&lt;regexp&gt;&lt;modifier&gt;. There could be zero to all of these tokens.
</p>

<div>
<table><thead><tr>
<th>入力
<th>現れる`~token$【の種別】
<tbody>

<tr><td>`/:foo(bar)?^l
<td>`char$l, `name$l, `regexp$l, `other-modifier$l （上に挙げたすべて）

<tr><td>`/^l
<td>`char$l

<tr><td>`:foo^l
<td>`name$l

<tr><td>`(bar)^l
<td>`regexp$l

<tr><td>`/:foo^l
<td>`char$l, `name$l

<tr><td>`/(bar)^l
<td>`char$l, `regexp$l

<tr><td>`/:foo?^l
<td>`char$l, `name$l, `other-modifier$l

<tr><td>`/(bar)?^l
<td>`char$l, `regexp$l, `other-modifier$l
</table>

◎
"/:foo(bar)?"
• All four tokens.
"/"
• One "char" token.
":foo"
• One "name" token.
"(bar)"
• One "regexp" token.
"/:foo"
• "char" and "name" tokens.
"/(bar)"
• "char" and "regexp" tokens.
"/:foo?"
• "char", "name", and "other-modifier" tokens.
"/(bar)?"
• "char", "regexp", and "other-modifier" tokens.
</div>
</div>

		<ol>
			<li>
%~char~token ~LET `~tokenを消費するよう試行する$( %構文解析器, `char$l )
◎
Let char token be the result of running try to consume a token given parser and "char".
</li>
			<li>
%名前~token ~LET `~tokenを消費するよう試行する$( %構文解析器, `name$l )
◎
Let name token be the result of running try to consume a token given parser and "name".
</li>
			<li>
%~regexp~tokenか~wildcard~token ~LET `~regexp~tokenか~wildcard~tokenを消費するよう試行する$( %構文解析器, %名前~token )
◎
Let regexp or wildcard token be the result of running try to consume a regexp or wildcard token given parser and name token.
</li>
			<li>
<p>
~IF［
%名前~token ~NEQ ~NULL
］~OR［
%~regexp~tokenか~wildcard~token ~NEQ ~NULL
］：
◎
If name token is not null or regexp or wildcard token is not null:
</p>

<p class="note">注記：
照合~groupが在る場合、
即時に`~part$を追加する必要がある。
◎
If there is a matching group, we need to add the part immediately.
</p>
				<ol>
					<li>
%接頭辞 ~LET 空~文字列
◎
Let prefix be the empty string.
</li>
					<li>
~IF［
%~char~token ~NEQ ~NULL
］
⇒
%接頭辞 ~SET %~char~token の`値$tK
◎
If char token is not null then set prefix to char token’s value.
</li>
					<li>
<p>
~IF［
%接頭辞 ~NIN { 空~文字列, %~option群 の`接頭辞~符号位置$opt }
］：
◎
If prefix is not the empty string and not options’s prefix code point:
</p>
						<ol>
							<li>
%構文解析器 の`処理待ち固定d値$pPに %接頭辞 を付加する
◎
Append prefix to the end of parser’s pending fixed value.
</li>
							<li>
%接頭辞 ~SET 空~文字列
◎
Set prefix to the empty string.
</li>
						</ol>
					</li>
					<li>
`処理待ち固定d値から~partを追加する$( %構文解析器 )
◎
Run maybe add a part from the pending fixed value given parser.
</li>
					<li>
%改変子~token ~LET `改変子~tokenを消費するよう試行する$( %構文解析器 )
◎
Let modifier token be the result of running try to consume a modifier token given parser.
</li>
					<li>
`~partを追加する$( ↓ )
⇒＃
%構文解析器,
%接頭辞,
%名前~token,
%~regexp~tokenか~wildcard~token,
空~文字列,
%改変子~token
◎
Run add a part given parser, prefix, name token, regexp or wildcard token, the empty string, and modifier token.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
<p>
%固定d~token ~LET %~char~token
◎
Let fixed token be char token.
</p>

<p class="note">注記：
照合~groupは無かった場合、
固定d~textを~bufferする必要がある（もしあれば）。
それを `fixed-text$l `~part$として追加する前に，
アリな限り多く~textを収集することが求まれる。
◎
If there was no matching group, then we need to buffer any fixed text. We want to collect as much text as possible before adding it as a "fixed-text" part.
</p>
			</li>
			<li>
~IF［
%固定d~token ~EQ ~NULL
］
⇒
%固定d~token ~SET `~tokenを消費するよう試行する$( %構文解析器, `escaped-char$l )
◎
If fixed token is null, then set fixed token to the result of running try to consume a token given parser and "escaped-char".
</li>
			<li>
<p>
~IF［
%固定d~token ~NEQ ~NULL
］：
◎
If fixed token is not null:
</p>
				<ol>
					<li>
%構文解析器 の`処理待ち固定d値$pPに %固定d~token の`値$tKを付加する
◎
Append fixed token’s value to parser’s pending fixed value.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
<p>
%開き~token ~LET `~tokenを消費するよう試行する$( %構文解析器, `open$l )
◎
Let open token be the result of running try to consume a token given parser and "open".
</p>

<div class="example" id="parsing-example-2">

<p>
次に，［
`open$l,
`char$l,
`name$l,
`regexp$l,
`char$l,
`close$l,
`other-modifier$l
］が成す連列を探す。
これらの`~token$のうち
`open$l, `close$l は必要yであるが，
他の~tokenは必要yでない。
◎
Next we look for the sequence &lt;open&gt;&lt;char prefix&gt;&lt;name&gt;&lt;regexp&gt;&lt;char suffix&gt;&lt;close&gt;&lt;modifier&gt;. The open and close are necessary, but the other tokens are not.
</p>

<div>
<table><thead><tr>
<th>入力
<th>現れる`~token$【の種別】
<tbody>

<tr><td>`{a:foo(bar)b}?^l
<td>すべての種別

<tr><td>`{:foo}?^l
<td>`open$l, `name$l, `close$l, `other-modifier$l

<tr><td>`{(bar)}?^l
<td>`open$l, `regexp$l, `close$l, `other-modifier$l

<tr><td>`{ab}?^l
<td>`open$l, `char$l, `close$l, `other-modifier$l
</table>

◎
"{a:foo(bar)b}?"
• All tokens are present.
"{:foo}?"
• "open", "name", "close", and "other-modifier" tokens.
"{(bar)}?"
• "open", "regexp", "close", and "other-modifier" tokens.
"{ab}?"
• "open", "char", "close", and "other-modifier" tokens.
</div>
</div>
			</li>
			<li>
<p>
~IF［
%開き~token ~NEQ ~NULL
］：
◎
If open token is not null:
</p>
				<ol>
					<li>
%接頭辞 ~SET `~textを消費する$( %構文解析器 )
◎
Set prefix be the result of running consume text given parser.
</li>
					<li>
%名前~token ~SET `~tokenを消費するよう試行する$( %構文解析器, `name$l )
◎
Set name token to the result of running try to consume a token given parser and "name".
</li>
					<li>
%~regexp~tokenか~wildcard~token ~SET `~regexp~tokenか~wildcard~tokenを消費するよう試行する$( %構文解析器, %名前~token )
◎
Set regexp or wildcard token to the result of running try to consume a regexp or wildcard token given parser and name token.
</li>
					<li>
%接尾辞 ~LET `~textを消費する$( %構文解析器 )
◎
Let suffix be the result of running consume text given parser.
</li>
					<li>
`要求される~tokenを消費する$( %構文解析器, `close$l )
◎
Run consume a required token given parser and "close".
</li>
					<li>
%改変子~token ~SET `改変子~tokenを消費するよう試行する$( %構文解析器 )
◎
Set modifier token to the result of running try to consume a modifier token given parser.
</li>
					<li>
`~partを追加する$( ↓ )
⇒＃
%構文解析器,
%接頭辞,
%名前~token,
%~regexp~tokenか~wildcard~token,
%接尾辞,
%改変子~token
◎
Run add a part given parser, prefix, name token, regexp or wildcard token, suffix, and modifier token.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
`処理待ち固定d値から~partを追加する$( %構文解析器 )
◎
Run maybe add a part from the pending fixed value given parser.
</li>
			<li>
`要求される~tokenを消費する$( %構文解析器, `end$l )
◎
Run consume a required token given parser and "end".
</li>
		</ol>
	</li>
	<li>
~RET %構文解析器 の`~part~list$pP
◎
Return parser’s part list.
</li>
</ol>
</div>

<p>
`全部的~wildcard~regexp値@
は、
文字列 `.*^l である。
◎
The full wildcard regexp value is the string ".*".
</p>

<div class="algo">
<p>
`区分~wildcard~regexpを生成する@
~algoは、
所与の
( `~option群$ %~option群 )
に対し：
◎
To generate a segment wildcard regexp given an options options:
</p>
<ol>
	<li>
~RET 次を順に`連結する$
⇒＃
`[^l,
`^^l,
`~regexp文字列を~escapeする$( %~option群 の`区切子~符号位置$opt ),
`]+?^l
◎
Let result be "[^".
◎
Append the result of running escape a regexp string given options’s delimiter code point to the end of result.
◎
Append "]+?" to the end of result.
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~tokenを消費するよう試行する@
~algoは、
所与の
( `~pattern構文解析器$ %構文解析器, `種別$tK %種別 )
に対し：
◎
To try to consume a token given a pattern parser parser and type type:
</p>
<ol>
	<li>
~Assert：
%構文解析器 の`~index$pP ~LT %構文解析器 の`~token~list$pPの`~size$
◎
Assert: parser’s index is less than parser’s token list size.
</li>
	<li>
%次回の~token ~LET %構文解析器 の`~token~list$pP[ %構文解析器 の`~index$pP ]
◎
Let next token be parser’s token list[parser’s index].
</li>
	<li>
~IF［
%次回の~token の`種別$tK ~NEQ %種別
］
⇒
~RET ~NULL
◎
If next token’s type is not type return null.
</li>
	<li>
%構文解析器 の`~index$pP ~INCBY 1
◎
Increment parser’s index by 1.
</li>
	<li>
~RET %次回の~token
◎
Return next token.
</li>
</ol>
</div>

<div class="algo">
<p>
`改変子~tokenを消費するよう試行する@
~algoは、
所与の
( `~pattern構文解析器$ %構文解析器 )
に対し：
◎
To try to consume a modifier token given a pattern parser parser:
</p>
<ol>
	<li>
%~token ~LET `~tokenを消費するよう試行する$( %構文解析器, `other-modifier$l )
◎
Let token be the result of running try to consume a token given parser and "other-modifier".
</li>
	<li>
~IF［
%~token ~NEQ ~NULL
］
⇒
~RET %~token
◎
If token is not null, then return token.
</li>
	<li>
~RET `~tokenを消費するよう試行する$( %構文解析器, `asterisk$l )
◎
Set token to the result of running try to consume a token given parser and "asterisk".
◎
Return token.
</li>
</ol>
</div>

<div class="algo">
<p>
`~regexp~tokenか~wildcard~tokenを消費するよう試行する@
~algoは、
所与の
( `~pattern構文解析器$ %構文解析器, `~token$ %名前~token )
に対し：
◎
To try to consume a regexp or wildcard token given a pattern parser parser and token name token:
</p>
<ol>
	<li>
%~token ~LET `~tokenを消費するよう試行する$( %構文解析器, `regexp$l )
◎
Let token be the result of running try to consume a token given parser and "regexp".
</li>
	<li>
~IF［
%名前~token ~EQ ~NULL
］~AND［
%~token ~EQ ~NULL
］
⇒
%~token ~SET `~tokenを消費するよう試行する$( %構文解析器, `asterisk$l )
◎
If name token is null and token is null, then set token to the result of running try to consume a token given parser and "asterisk".
</li>
	<li>
~RET %~token
◎
Return token.
</li>
</ol>
</div>

<div class="algo">
<p>
`要求される~tokenを消費する@
~algoは、
所与の
( `~pattern構文解析器$ %構文解析器, `種別$tK %種別 )
に対し：
◎
To consume a required token given a pattern parser parser and type type:
</p>
<ol>
	<li>
%結果 ~LET `~tokenを消費するよう試行する$( %構文解析器, %種別 )
◎
Let result be the result of running try to consume a token given parser and type.
</li>
	<li>
~IF［
%結果 ~EQ ~NULL
］
⇒
~THROW `TypeError$E
◎
If result is null, then throw a TypeError.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~textを消費する@
~algoは、
所与の
( `~pattern構文解析器$ %構文解析器 )
に対し：
◎
To consume text given a pattern parser parser:
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~token ~LET `~tokenを消費するよう試行する$( %構文解析器, `char$l )
◎
Let token be the result of running try to consume a token given parser and "char".
</li>
			<li>
~IF［
%~token ~EQ ~NULL
］
⇒
%~token ~SET `~tokenを消費するよう試行する$( %構文解析器, `escaped-char$l )
◎
If token is null, then set token to the result of running try to consume a token given parser and "escaped-char".
</li>
			<li>
~IF［
%~token ~EQ ~NULL
］
⇒
~BREAK
◎
If token is null, then break.
</li>
			<li>
%結果 に %~token の`値$tKを付加する
◎
Append token’s value to the end of result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`処理待ち固定d値から~partを追加する@
【！maybe】ときは、
所与の
( `~pattern構文解析器$ %構文解析器 )
に対し：
◎
To maybe add a part from the pending fixed value given a pattern parser parser:
</p>
<ol>
	<li>
%固定d値 ~LET %構文解析器 の`処理待ち固定d値$pP
◎
↓</li>
	<li>
~IF［
%固定d値 ~EQ 空~文字列
］
⇒
~RET
◎
If parser’s pending fixed value is the empty string, then return.
</li>
	<li>
%符号化-済み値 ~LET %構文解析器 の`符号化~callback$pP( %固定d値 )
◎
Let encoded value be the result of running parser’s encoding callback given parser’s pending fixed value.
</li>
	<li>
%構文解析器 の`処理待ち固定d値$pP ~SET 空~文字列
◎
Set parser’s pending fixed value to the empty string.
</li>
	<li>
%~part ~LET 新たな`~part$
— その
⇒＃
`種別$pt ~SET `fixed-text$l,
`値$pt ~SET %符号化-済み値,
`改変子$pt ~SET `none$l
◎
Let part be a new part whose type is "fixed-text", value is encoded value, and modifier is "none".
</li>
	<li>
%構文解析器 の`~part~list$pPに %~part を`付加する$
◎
Append part to parser’s part list.
</li>
</ol>
</div>

<div class="algo">
<p>
`~partを追加する@
~algoは、
所与の
⇒＃
`~pattern構文解析器$ %構文解析器,
文字列 %接頭辞,
`~token$ %名前~token,
`~token$ %~regexp~tokenか~wildcard~token,
文字列 %接尾辞,
`~token$ %改変子~token
◎終
に対し：
◎
To add a part given a pattern parser parser, a string prefix, a token name token, a token regexp or wildcard token, a string suffix, and a token modifier token:
</p>
<ol>
	<li>
<p>
%改変子 ~LET %改変子~token に応じて：
</p>
		<ul class="switch">
			<li>
~NULL ならば `none$l
</li>
			<li>
~ELSE_ %改変子~token の`値$tKに応じて
⇒＃
`?^l ならば `optional$l ／
`*^l ならば `zero-or-more$l ／
`+^l ならば `one-or-more$l ／
~ELSE_ `none$l
</li>
		</ul>
◎
Let modifier be "none".
◎
If modifier token is not null:
• If modifier token’s value is "?" then set modifier to "optional".
• Otherwise if modifier token’s value is "*" then set modifier to "zero-or-more".
• Otherwise if modifier token’s value is "+" then set modifier to "one-or-more".
</li>
	<li>
<p>
~IF［
%名前~token ~EQ ~NULL
］~AND［
%~regexp~tokenか~wildcard~token ~EQ ~NULL
］~AND［
%改変子 ~EQ `none$l
］：
◎
If name token is null and regexp or wildcard token is null and modifier is "none":
</p>

<p class="note">注記：
これ【？】は `{foo}^l の様な~group化であった。
これが［
それまでの／後続な
］~textと結合されるよう，`処理待ち固定d値$pPに これ【？】を付加する【！add】。
◎
This was a "{foo}" grouping. We add this to the pending fixed value so that it will be combined with any previous or subsequent text.
</p>
		<ol>
			<li>
%構文解析器 の`処理待ち固定d値$pP に %接頭辞 を付加する
◎
Append prefix to the end of parser’s pending fixed value.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
`処理待ち固定d値から~partを追加する$( %構文解析器 )
◎
Run maybe add a part from the pending fixed value given parser.
</li>
	<li>
<p>
~IF［
%名前~token ~EQ ~NULL
］~AND［
%~regexp~tokenか~wildcard~token ~EQ ~NULL
］：
◎
If name token is null and regexp or wildcard token is null:
</p>

<p class="note">注記：
これは `{foo}?^l の様な~group化であった。
当の改変子は、
それ【？】を他の~textとは結合できないことを意味する。
したがって，それ【？】を即時に`~part$として追加する。
◎
This was a "{foo}?" grouping. The modifier means we cannot combine it with other text. Therefore we add it as a part immediately.
</p>
		<ol>
			<li>
~Assert：
%接尾辞 ~EQ 空~文字列
◎
Assert: suffix is the empty string.
</li>
			<li>
~IF［
%接頭辞 ~EQ 空~文字列
］
⇒
~RET
◎
If prefix is the empty string, then return.
</li>
			<li>
%符号化-済み値 ~LET %構文解析器 の`符号化~callback$pP( %接頭辞 )
◎
Let encoded value be the result of running parser’s encoding callback given prefix.
</li>
			<li>
%~part ~LET 新たな`~part$
— その
⇒＃
`種別$pt ~SET `fixed-text$l,
`値$pt ~SET %符号化-済み値,
`改変子$pt ~SET %改変子
◎
Let part be a new part whose type is "fixed-text", value is encoded value, and modifier is modifier.
</li>
			<li>
%構文解析器 の`~part~list$pPに %~part を`付加する$
◎
Append part to parser’s part list.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
%~regexp値 ~LET 空~文字列
◎
Let regexp value be the empty string.
</p>

<p class="note">注記：
次に，
%~regexp~tokenか~wildcard~token を正規表現へ変換する
◎
Next, we convert the regexp or wildcard token into a regular expression.
</p>
	</li>
	<li>
~IF［
%~regexp~tokenか~wildcard~token ~EQ ~NULL
］
⇒
%~regexp値 ~SET %構文解析器 の`区分~wildcard~regexp$pP
◎
If regexp or wildcard token is null, then set regexp value to parser’s segment wildcard regexp.
</li>
	<li>
~ELIF［
%~regexp~tokenか~wildcard~token の`種別$tK ~EQ `asterisk$l
］
⇒
%~regexp値 ~SET `全部的~wildcard~regexp値$
◎
Otherwise if regexp or wildcard token’s type is "asterisk", then set regexp value to the full wildcard regexp value.
</li>
	<li>
~ELSE
⇒
%~regexp値 ~SET %~regexp~tokenか~wildcard~token の`値$tK
◎
Otherwise set regexp value to regexp or wildcard token’s value.
</li>
	<li>
<p>
%種別 ~LET `~regexp0$l
◎
Let type be "regexp".
</p>

<p class="note">注記：
次に，
%~regexp値 を`~part$の`種別$ptへ変換する。
まず，ある正規表現へ行くことを確かめる
— 等価な `regexp$l `~token$が［
`name$l ／ `asterisk$l
］`~token$と同じに扱われるよう【？】。
◎
Next, we convert regexp value into a part type. We make sure to go to a regular expression first so that an equivalent "regexp" token will be treated the same as a "name" or "asterisk" token.
</p>
	</li>
	<li>
<p>
~IF［
%~regexp値 ~EQ %構文解析器 の`区分~wildcard~regexp$pP
］：
◎
If regexp value is parser’s segment wildcard regexp:
</p>
		<ol>
			<li>
%種別 ~SET `segment-wildcard$l
◎
Set type to "segment-wildcard".
</li>
			<li>
%~regexp値 ~SET 空~文字列
◎
Set regexp value to the empty string.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%~regexp値 ~EQ `全部的~wildcard~regexp値$
］：
◎
Otherwise if regexp value is the full wildcard regexp value:
</p>
		<ol>
			<li>
%種別 ~SET `full-wildcard$l
◎
Set type to "full-wildcard".
</li>
			<li>
%~regexp値 ~SET 空~文字列
◎
Set regexp value to the empty string.
</li>
		</ol>
	</li>
	<li>
<p>
%名前 ~LET 空~文字列
◎
Let name be the empty string.
</p>

<p class="note">注記：
次に，
`~part$の`名前$ptを決定する。
これは、
`name$l `~token$により明示的に供されることも，
自動的にアテガわれることもある。
◎
Next, we determine the part name. This can be explicitly provided by a "name" token or be automatically assigned.
</p>
	</li>
	<li>
~IF［
%名前~token ~NEQ ~NULL
］
⇒
%名前 ~SET %名前~token の`値$tK
◎
If name token is not null, then set name to name token’s value.
</li>
	<li>
<p>
~ELIF［
%~regexp~tokenか~wildcard~token ~NEQ ~NULL
］：
◎
Otherwise if regexp or wildcard token is not null:
</p>
		<ol>
			<li>
%名前 ~SET `整数を直列化する$( %構文解析器 の`次回の数量-名$pP )
◎
Set name to parser’s next numeric name, serialized.
</li>
			<li>
%構文解析器 の`次回の数量-名$pP ~INCBY 1
◎
Increment parser’s next numeric name by 1.
</li>
		</ol>
	</li>
	<li>
~IF［
`重複な名前か否か$( %構文解析器, %名前 ) ~EQ ~T
］
⇒
~THROW `TypeError$E
◎
If the result of running is a duplicate name given parser and name is true, then throw a TypeError.
</li>
	<li>
<p>
%符号化-済み接頭辞 ~LET %構文解析器 の`符号化~callback$pP( %接頭辞 )
◎
Let encoded prefix be the result of running parser’s encoding callback given prefix.
</p>

<p class="note">注記：
最後に，固定的な~text値を符号化して`~part$を作成する。
◎
Finally, we encode the fixed text values and create the part.
</p>
	</li>
	<li>
%符号化-済み接尾辞 ~LET %構文解析器 の`符号化~callback$pP( %接尾辞 )
◎
Let encoded suffix be the result of running parser’s encoding callback given suffix.
</li>
	<li>
%~part ~LET 新たな`~part$
— その
⇒＃
`種別$pt ~SET %種別,
`値$pt ~SET %~regexp値,
`改変子$pt ~SET %改変子,
`名前$pt ~SET %名前,
`接頭辞$pt ~SET %符号化-済み接頭辞,
`接尾辞$pt ~SET %符号化-済み接尾辞
◎
Let part be a new part whose type is type, value is regexp value, modifier is modifier, name is name, prefix is encoded prefix, and suffix is encoded suffix.
</li>
	<li>
%構文解析器 の`~part~list$pPに %~part を`付加する$
◎
Append part to parser’s part list.
</li>
</ol>
</div>

<div class="algo">
<p>
`重複な名前か否か@
は、
所与の
( `~pattern構文解析器$ %構文解析器, 文字列 %名前 )
に対し：
◎
To determine if a value is a duplicate name given a pattern parser parser and a string name:
</p>
<ol>
	<li>
%構文解析器 の`~part~list$pPを成す
~EACH( %~part )
に対し
⇒
~IF［
%~part の`名前$pt ~EQ %名前
］
⇒
~RET ~T
◎
For each part of parser’s part list:
• If part’s name is name, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="converting-part-lists-to-regular-expressions">
<h3 title="Converting part lists to regular expressions">2.2. ~part~listから正規表現への変換-法</h3>

<div class="algo">
<p>
`正規表現と名前~listを生成する@
~algoは、
所与の
( `~part~list$ %~part~list, `~option群$ %~option群 )
に対し：
◎
To generate a regular expression and name list from a given part list part list and options options:
</p>
<ol>
	<li>
%結果 ~LET `^^l
◎
Let result be "^".
</li>
	<li>
%名前~list ~LET 新たな`~list$
◎
Let name list be a new list.
</li>
	<li>
<p>
%~part~list を成す
~EACH( %~part )
に対し：
◎
For each part of part list:
</p>
		<ol>
			<li>
<p>
~IF［
%~part の`種別$pt ~EQ `fixed-text$l
］：
◎
If part’s type is "fixed-text":
</p>
				<ol>
					<li>
~IF［
%~part の`改変子$pt ~EQ `none$l
］
⇒
%結果 に次の結果を付加する
⇒
 `~regexp文字列を~escapeする$( %~part の`値$pt )
◎
If part’s modifier is "none", then append the result of running escape a regexp string given part’s value to the end of result.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>

<div class="note">
<p>注記：
改変子を伴う `fixed-text$l %~part は、
ある捕捉なしな~groupを利用する。
それは、
次の形を利用する
⇒
"<code>(?:`固定的な~text^t)`改変子^t</code>"
◎
A "fixed-text" part with a modifier uses a non capturing group. It uses the following form.
◎
(?:&lt;fixed text&gt;)&lt;modifier&gt;
</p>
</div>

<p>
%結果 に次を順に付加する
⇒＃
`(?:^l,
`~regexp文字列を~escapeする$( %~part の`値$pt ),
`)^l,
`文字列を改変子へ変換する$( %~part の`改変子$pt )
◎
Append "(?:" to the end of result.
◎
Append the result of running escape a regexp string given part’s value to the end of result.
◎
Append ")" to the end of result.
◎
Append the result of running convert a modifier to a string given part’s modifier to the end of result.
</p>
					</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
~Assert：
%~part の`名前$pt ~NEQ 空~文字列
◎
Assert: part’s name is not the empty string.
</li>
			<li>
<p>
%名前~list に %~part の`名前$ptを`付加する$
◎
Append part’s name to name list.
</p>

<p class="note">注記：
各~照合~group名を別に用意された~list内に収集する。
これは、
主に旧来の
— `path-to-regexp$cite と合致させるための —
理由から行われる。
これを［
正規表現の捕捉ありな有名~groupを利用するよう変換する
］よう試みることもできたが、
この~algoの複階性から，意図されない~bugを導入する~riskが本当にある。
加えて，生成された正規表現が~webに公開される結果になる場合には、
`path-to-regexp$cite との互換性【！compability】を保守したい
— そのことから、
捕捉ありな有名~groupを利用するよう切替えることは，
ほぼ見込まれない。
◎
We collect the list of matching group names in a parallel list. This is largely done for legacy reasons to match path-to-regexp. We could attempt to convert this to use regular expression named captured groups, but given the complexity of this algorithm there is a real risk of introducing unintended bugs. In addition, if we ever end up exposing the generated regular expressions to the web we would like to maintain compability with path-to-regexp which has indicated its unlikely to switch to using named capture groups.
</p>
			</li>
			<li>
%~regexp値 ~LET %~part の`値$pt
◎
Let regexp value be part’s value.
</li>
			<li>
~IF［
%~part の`種別$pt ~EQ `segment-wildcard$l
］
⇒
%~regexp値 ~SET `区分~wildcard~regexpを生成する$( %~option群 )
◎
If part’s type is "segment-wildcard", then set regexp value to the result of running generate a segment wildcard regexp given options.
</li>
			<li>
~ELIF［
%~part の`種別$pt ~EQ `full-wildcard$l
］
⇒
%~regexp値 ~SET `全部的~wildcard~regexp値$
◎
Otherwise if part’s type is "full-wildcard", then set regexp value to full wildcard regexp value.
</li>
			<li>
<p>
~IF［
%~part の`接頭辞$pt ~EQ 空~文字列
］~AND［
%~part の`接尾辞$pt ~EQ 空~文字列
］：
◎
If part’s prefix is the empty string and part’s suffix is the empty string:
</p>

<div class="note">
<p>注記：
［
`接頭辞$pt／`接尾辞$pt
］は無い場合、
生成は，改変子に依存する。
［
改変子は無い ／
省略可能にする改変子だけが在る
］場合、
それは，単純な形を利用する
— 次のような
⇒
"<code>(`~regexp値^t)`改変子^t</code>"
◎
If there is no prefix or suffix then generation depends on the modifier. If there is no modifier or just the optional modifier, it uses the following simple form:
◎
(&lt;regexp value&gt;)&lt;modifier&gt;
</p>

<p>
しかしながら，
繰返可能にする改変子が在る場合、
もっと複階的な形を利用することになる
— 次のような
⇒
"<code>((?:`~regexp値^t)`改変子^t)</code>"
◎
If there is a repeating modifier, however, we will use the more complex form:
◎
((?:&lt;regexp value&gt;)&lt;modifier&gt;)
</p>
</div>
				<ol>
					<li>
~IF［
%~part の`改変子$pt ~IN { `none$l, `optional$l }
］
⇒
%結果 に次を順に付加する
⇒＃
`(^l,
%~regexp値,
`)^l,
`文字列を改変子へ変換する$( %~part の`改変子$pt )
◎
If part’s modifier is "none" or "optional", then:
• Append "(" to the end of result.
• Append regexp value to the end of result.
• Append ")" to the end of result.
• Append the result of running convert a modifier to a string given part’s modifier to the end of result.
</li>
					<li>
~ELSE
⇒
%結果 に次を順に付加する
⇒＃
`((?:^l,
%~regexp値,
`)^l,
`文字列を改変子へ変換する$( %~part の`改変子$pt ),
`)^l
◎
Otherwise:
• Append "((?:" to the end of result.
• Append regexp value to the end of result.
• Append ")" to the end of result.
• Append the result of running convert a modifier to a string given part’s modifier to the end of result.
• Append ")" to the end of result.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~part の`改変子$pt ~IN { `none$l, `optional$l }
］：
◎
If part’s modifier is "none" or "optional":
</p>

<div class="note">
<p>注記：
この段は、
繰返可能にされない~partを
— ［
`接頭辞$pt, `接尾辞$pt
］と伴に —
取扱う。
内縁な捕捉ありな~groupとして，首な %~regexp値 を包含するものが在る
— この~groupは、
外縁な捕捉なしな~group内で［
`接頭辞$pt, `接尾辞$pt
］と結合される。
最後に，改変子が適用される。
結果の形は
⇒
"<code>(?:`接頭辞^t(`~regexp値^t)`接尾辞^t)`改変子^t</code>"
◎
This section handles non-repeating parts with a prefix or suffix. There is an inner capturing group that contains the primary regexp value. The inner group is then combined with the prefix or suffix in an outer non-capturing group. Finally the modifier is applied. The resulting form is as follows.
◎
(?:&lt;prefix&gt;(&lt;regexp value&gt;)&lt;suffix&gt;)&lt;modifier&gt;
</p>
</div>
				<ol>
					<li>
%結果 に次を順に付加する
⇒＃
`(?:^l,
`~regexp文字列を~escapeする$( %~part の`接頭辞$pt ),
`(^l,
%~regexp値,
`)^l,
`~regexp文字列を~escapeする$( %~part の`接尾辞$pt ),
`)^l,
`文字列を改変子へ変換する$( %~part の`改変子$pt ),
◎
• Append "(?:" to the end of result.
• Append the result of running escape a regexp string given part’s prefix to the end of result.
• Append "(" to the end of result.
• Append regexp value to the end of result.
• Append ")" to the end of result.
• Append the result of running escape a regexp string given part’s suffix to the end of result.
• Append ")" to the end of result.
• Append the result of running convert a modifier to a string given part’s modifier to the end of result.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
~Assert：
%~part の`改変子$pt ~IN { `zero-or-more$l, `one-or-more$l }
◎
Assert: part’s modifier is "zero-or-more" or "one-or-more".
</li>
			<li>
<p>
~Assert：
［
%~part の`接頭辞$pt ~NEQ 空~文字列
］~OR［
%~part の`接尾辞$pt ~NEQ 空~文字列
］
◎
Assert: part’s prefix is not the empty string or part’s suffix is not the empty string.
</p>

<div class="note">
<p>注記：
［
`接頭辞$pt／`接尾辞$pt
］を伴う繰返可能にされた~partは、
ずっと複雑である。
繰返される要素たちに対し、［
`接頭辞$pt／`接尾辞$pt
］を［
先頭／末尾
］の要素からは除外する一方で，
各~要素の合間には【逆順に】含めることが求まれる。
これを達成するため、［
`接頭辞$ptが除外された別々な初期~regexp【！expression】
］が供される。
この~regexp【！expression】は、
省略可能かつ繰返可能にされた要素~内でも
— ［
`接頭辞$pt, `接尾辞$pt
］の値を含めた上で —
重複される。
0 個の値が許可される場合、
末尾に省略可能にする改変子が付加される。
結果の形は
⇒
"<code>(?:`接頭辞^t((?:`~regexp値^t)(?:`接尾辞^t`接頭辞^t(?:`~regexp値^t))*)`接尾辞^t)?</code>"
◎
Repeating parts with a prefix or suffix are dramatically more complicated. We want to exclude the initial prefix and the final suffix, but include them between any repeated elements. To achieve this we provide a separate initial expression that excludes the prefix. Then the expression is duplicated with the prefix/suffix values included in an optional repeating element. If zero values are permitted then a final optional modifier can be appended. The resulting form is as follows.
• (?:&lt;prefix&gt;((?:&lt;regexp value&gt;)(?:&lt;suffix&gt;&lt;prefix&gt;(?:&lt;regexp value&gt;))*)&lt;suffix&gt;)?
</p>
</div>
			</li>
			<li>
%結果 に次を順に付加する
⇒＃
`(?:^l,
`~regexp文字列を~escapeする$( %~part の`接頭辞$pt ),
`((?:^l,
%~regexp値,
`)(?:^l,
`~regexp文字列を~escapeする$( %~part の`接尾辞$pt ),
`~regexp文字列を~escapeする$( %~part の`接頭辞$pt ),
`(?:^l,
%~regexp値,
`))*)^l,
`~regexp文字列を~escapeする$( %~part の`接尾辞$pt ),
`)^l,
◎
Append "(?:" to the end of result.
◎
Append the result of running escape a regexp string given part’s prefix to the end of result.
◎
Append "((?:" to the end of result.
◎
Append regexp value to the end of result.
◎
Append ")(?:" to the end of result.
◎
Append the result of running escape a regexp string given part’s suffix to the end of result.
◎
Append the result of running escape a regexp string given part’s prefix to the end of result.
◎
Append "(?:" to the end of result.
◎
Append regexp value to the end of result.
◎
Append "))*)" to the end of result.
◎
Append the result of running escape a regexp string given part’s suffix to the end of result.
◎
Append ")" to the end of result.
</li>
			<li>
~IF［
%~part の`改変子$pt ~EQ `zero-or-more$l
］
⇒
%結果 に `?^l を付加する
◎
If part’s modifier is "zero-or-more" then append "?" to the end of result.
</li>
		</ol>
	</li>
	<li>
%結果 に `$^l を付加する
◎
Append "$" to the end of result.
</li>
	<li>
~RET ( %結果, %名前~list )
◎
Return (result, name list).
</li>
</ol>
</div>

<div class="algo">
<p>
`~regexp文字列を~escapeする@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
To escape a regexp string given a string input:
</p>
<ol>
	<li>
~Assert：
%入力 は`~ASCII文字列$である
◎
Assert: input is an ASCII string.
</li>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%入力 を成す
~EACH( 文字 %c )
に対し，順に：
◎
Let index be 0.
◎
While index is less than input’s length:
• Let c be input[index].
• Increment index by 1.
</p>
		<ol>
			<li>
~IF［
%c ~IN {
`002E^U,
`002B^U,
`002A^U,
`003F^U,
`005E^U,
`0024^U,
`007B^U,
`007D^U,
`0028^U,
`0029^U,
`005B^U,
`005D^U,
`007C^U,
`002F^U,
`005C^U
}
］
⇒
%結果 に `\^l を付加する
◎
If c is one of:
• U+002E (.);
• U+002B (+);
• U+002A (*);
• U+003F (?);
• U+005E (^);
• U+0024 ($);
• U+007B ({);
• U+007D (});
• U+0028 (();
• U+0029 ());
• U+005B ([);
• U+005D (]);
• U+007C (|);
• U+002F (/); or
• U+005C (\),
◎
then append "\" to the end of result.
</li>
			<li>
%結果 に %c を付加する
◎
Append c to the end of result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

		</section>
		<section id="converting-part-lists-to-pattern-strings">
<h3 title="Converting part lists to pattern strings">2.3. ~part~listから~pattern文字列への変換-法</h3>

<div class="algo">
<p>
`~pattern文字列を生成する@
~algoは、
所与の
( `~part~list$ %~part~list, `~option群$ %~option群 )
に対し：
◎
To generate a pattern string from a given part list part list and options options:
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
%~index~list ~LET %~part~list の`~index群$
◎
Let index list be the result of getting the indices for part list.
</li>
	<li>
<p>
%~index~list を成す
~EACH( %~index )
に対し：
◎
For each index of index list:
</p>
		<ol>
			<li>
%~part ~LET %~part~list[ %~index ]
◎
Let part be part list[index].
</li>
			<li>
%前回の~part ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~index ~GT 0
］
⇒
%前回の~part ~SET %~part~list[ %~index ~MINUS 1 ]
◎
Let previous part be part list[index - 1] if index is greater than 0, otherwise let it be null.
</li>
			<li>
%次回の~part ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~index ~LT %~index~list の`~size$ ~MINUS 1
］
⇒
%次回の~part ~SET %~part~list[ %~index ~PLUS 1]
◎
Let next part be part list[index + 1] if index is less than index list’s size - 1, otherwise let it be null.
</li>
			<li>
<p>
~IF［
%~part の`種別$pt ~EQ `fixed-text$l
］：
◎
If part’s type is "fixed-text" then:
</p>
				<ol>
					<li>
<p>
~IF［
%~part の`改変子$pt ~EQ `none$l
］：
◎
If part’s modifier is "none" then:
</p>
						<ol>
							<li>
%結果 に次を付加する
⇒
`~pattern文字列を~escapeする$( %~part の`値$pt )
◎
Append the result of running escape a pattern string given part’s value to the end of result.
</li>
							<li>
~CONTINUE
◎
Continue.
</li>
						</ol>
					</li>
					<li>
%結果 に次を順に付加する
⇒＃
`{^l,
`~pattern文字列を~escapeする$( %~part の`値$pt ),
`}^l,
`文字列を改変子へ変換する$( %~part の`改変子$pt ),
◎
Append "{" to the end of result.
◎
Append the result of running escape a pattern string given part’s value to the end of result.
◎
Append "}" to the end of result.
◎
Append the result of running convert a modifier to a string given part’s modifier to the end of result.
</li>
					<li>
~CONTINUE
◎
Continue.
</li>
				</ol>
			</li>
			<li>
%~custom名か ~LET ~IS［
%~part の`名前$pt[ 0 ] は`~ASCII数字$でない
］
◎
Let custom name be true if part’s name[0] is not an ASCII digit; otherwise false.
</li>
			<li>
<p>
%~group化は必要か ~LET ~IS ~OR↓：
◎
Let needs grouping be true if at least one of the following are true, otherwise let it be false:
</p>
				<ul>
					<li>
%~part の`接尾辞$pt ~NEQ 空~文字列
◎
part’s suffix is not the empty string.
</li>
					<li>
%~part の`接頭辞$pt ~NIN { 空~文字列, %~option群 の`接頭辞~符号位置$opt }
◎
part’s prefix is not the empty string and is not options’s prefix code point.
</li>
				</ul>
			</li>
			<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
				<ul>
					<li>
%~group化は必要か ~EQ ~F
◎
needs grouping is false; and
</li>
					<li>
%~custom名か ~EQ ~T
◎
custom name is true; and
</li>
					<li>
%~part の`種別$pt ~EQ `segment-wildcard$l
◎
part’s type is "segment-wildcard"; and
</li>
					<li>
%~part の`改変子$pt ~EQ `none$l
◎
part’s modifier is "none"; and
</li>
					<li>
%次回の~part ~NEQ ~NULL
◎
next part is not null; and
</li>
					<li>
%次回の~part の`接頭辞$pt ~EQ 空~文字列
◎
next part’s prefix is the empty string; and
</li>
					<li>
%次回の~part の`接尾辞$pt ~EQ 空~文字列
◎
next part’s suffix is the empty string
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
<p>
~IF［
%次回の~part の`種別$pt ~EQ `fixed-text$l
］：
◎
If next part’s type is "fixed-text":
</p>
						<ol>
							<li>
~IF［
%次回の~part の`値$ptを成す最初の`文字$は`妥当な名前~符号位置$である
］
⇒
%~group化は必要か ~SET ~T
◎
Set needs grouping to true if the result of running is a valid name code point given next part’s value's first code point and the boolean false is true.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%次回の~part の`名前$pt[0] は`~ASCII数字$である
］
⇒
%~group化は必要か ~SET ~T
◎
Otherwise:
• Set needs grouping to true if next part’s name[0] is an ASCII digit.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
				<ul>
					<li>
%~group化は必要か ~EQ ~F
◎
needs grouping is false; and
</li>
					<li>
%~part の`接頭辞$pt ~EQ 空~文字列
◎
part’s prefix is the empty string; and
</li>
					<li>
%前回の~part ~NEQ ~NULL
◎
previous part is not null; and
</li>
					<li>
%前回の~part の`種別$pt ~EQ `fixed-text$l
◎
previous part’s type is "fixed-text"; and
</li>
					<li>
%前回の~part の`値$ptを成す最後の`文字$ ~EQ %~option群 の`接頭辞~符号位置$opt
◎
previous part’s value's last code point is options’s prefix code point.
</li>
				</ul>
<p>
…ならば
⇒
%~group化は必要か ~SET ~T
◎
then set needs grouping to true.
</p>
			</li>
			<li>
~Assert：
%~part の`名前$pt ~NIN { 空~文字列, ~NULL }
◎
Assert: part’s name is not the empty string or null.
</li>
			<li>
~IF［
%~group化は必要か ~EQ ~T
］
⇒
%結果 に `{^l を付加する
◎
If needs grouping is true, then append "{" to the end of result.
</li>
			<li>
%結果 に次を付加する
⇒
`~pattern文字列を~escapeする$( %~part の`接頭辞$pt )
◎
Append the result of running escape a pattern string given part’s prefix to the end of result.
</li>
			<li>
~IF［
%~custom名か ~EQ ~T
］
⇒
%結果 に次を順に付加する
⇒＃
`:^l,
%~part の`名前$pt
◎
If custom name is true:
• Append ":" to the end of result.
• Append part’s name to the end of result.
</li>
			<li>
~IF［
%~part の`種別$pt ~EQ `~regexp0$l
］
⇒
%結果 に次を順に付加する
⇒＃
`(^l,
%~part の`値$pt,
`)^l
◎
If part’s type is "regexp" then:
• Append "(" to the end of result.
• Append part’s value to the end of result.
• Append ")" to the end of result.
</li>
			<li>
~ELIF［
%~part の`種別$pt ~EQ `segment-wildcard$l
］~AND［
%~custom名か ~EQ ~F
］
⇒
%結果 に次を順に付加する
⇒＃
`(^l,
`区分~wildcard~regexpを生成する$( %~option群 ),
`)^l
◎
Otherwise if part’s type is "segment-wildcard" and custom name is false:
• Append "(" to the end of result.
• Append the result of running generate a segment wildcard regexp given options to the end of result.
• Append ")" to the end of result.
</li>
			<li>
<p>
~ELIF［
%~part の`種別$pt ~EQ `full-wildcard$l
］：
◎
Otherwise if part’s type is "full-wildcard":
</p>
				<ol>
					<li>
<p>
~IF［
%~custom名か ~EQ ~F
］~AND［
~OR↓
］…
◎
If custom name is false and one of the following is true:
</p>
						<ul>
							<li>
%前回の~part ~EQ ~NULL
◎
previous part is null; or
</li>
							<li>
%前回の~part の`種別$pt ~EQ `fixed-text$l
◎
previous part’s type is "fixed-text"; or
</li>
							<li>
%前回の~part の`改変子$pt ~NEQ `none$l
◎
previous part’s modifier is not "none"; or
</li>
							<li>
%~group化は必要か ~EQ ~T
◎
needs grouping is true; or
</li>
							<li>
%~part の`接頭辞$pt ~NEQ 空~文字列
◎
part’s prefix is not the empty string
</li>
						</ul>
<p>
…ならば
⇒
%結果 に `*^l を付加する
◎
then append "*" to the end of result.
</p>
					</li>
					<li>
~ELSE
⇒
%結果 に次を順に付加する
⇒＃
`(^l,
`全部的~wildcard~regexp値$,
`)^l
◎
Otherwise:
• Append "(" to the end of result.
• Append full wildcard regexp value to the end of result.
• Append ")" to the end of result.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
				<ul>
					<li>
%~part の`種別$pt ~EQ `segment-wildcard$l
◎
part’s type is "segment-wildcard"; and
</li>
					<li>
%~custom名か ~EQ ~T
◎
custom name is true; and
</li>
					<li>
%~part の`接尾辞$pt ~NEQ 空~文字列
◎
part’s suffix is not the empty string; and
</li>
					<li>
%~part の`接尾辞$ptを成す最初の`文字$は`妥当な名前~符号位置$である
◎
The result of running is a valid name code point given part’s suffix's first code point and the boolean false is true
</li>
				</ul>
<p>
…ならば
⇒
%結果 に `005C^U を付加する
◎
then append U+005C (\) to the end of result.
</p>
			</li>
			<li>
%結果 に次を付加する
⇒
`~pattern文字列を~escapeする$( %~part の`接尾辞$pt )
◎
Append the result of running escape a pattern string given part’s suffix to the end of result.
</li>
			<li>
~IF［
%~group化は必要か ~EQ ~T
］
⇒
%結果 に `}^l を付加する
◎
If needs grouping is true, then append "}" to the end of result.
</li>
			<li>
%結果 に次を付加する
⇒
`文字列を改変子へ変換する$( %~part の`改変子$pt )
◎
Append the result of running convert a modifier to a string given part’s modifier to the end of result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~pattern文字列を~escapeする@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
To escape a pattern string given a string input:
</p>
<ol>
	<li>
~Assert：
%入力 は`~ASCII文字列$である
◎
Assert: input is an ASCII string.
</li>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%入力 を成す
~EACH( 文字 %c )
に対し，順に：
◎
Let index be 0.
◎
While index is less than input’s length:
• Let c be input[index].
• Increment index by 1.
</p>
		<ol>
			<li>
~IF［
%c ~IN {
`002B^U,
`002A^U,
`003F^U,
`003A^U,
`007B^U,
`007D^U,
`0028^U,
`0029^U,
`005C^U,
}
］
⇒
%結果 に `005C^U を付加する
◎
If c is one of:
• U+002B (+);
• U+002A (*);
• U+003F (?);
• U+003A (:);
• U+007B ({);
• U+007D (});
• U+0028 (();
• U+0029 ()); or
• U+005C (\),
◎
then append U+005C (\) to the end of result.
</li>
			<li>
%結果 に %c を付加する
◎
Append c to the end of result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
`文字列を改変子へ変換する@
~algoは、
所与の
( `改変子$pt %改変子 )
に対し
⇒
~RET %改変子 に応じて
⇒＃
`zero-or-more$l ならば `*^l ／
`optional$l ならば `?^l ／
`one-or-more$l ならば `+^l
~ELSE_ 空~文字列
◎
To convert a modifier to a string given a modifier modifier:
• If modifier is "zero-or-more", then return "*".
• If modifier is "optional", then return "?".
• If modifier is "one-or-more", then return "+".
• Return the empty string.
</div>

		</section>
	</section>
	<section id="canon">
<h2 title="Canonicalization">3. 正準-化</h2>

		<section id="canon-encoding-callbacks">
<h3 title="Encoding callbacks">3.1. 符号化~callback</h3>

<div class="algo">
<p>
`~protocolを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a protocol given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
%値 に `://dummy.test^l を付加する
◎
↓</li>
	<li>
<p>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %値, %~dummy~URL, ε )
◎
Let parseResult be the result of running the basic URL parser given value followed by "://dummy.test", with dummyURL as url.
</p>

<p class="note">注記：
ここでは、
3 個目の引数（ `上書き state^i ）を利用しない
— それが施行する制約が適切になるのは、
`protocol＠~URL1#dom-url-protocol$m 設定子~用に限られるので。
代わりに，［
%値 に与えられた~protocol
］および［
通常の構文解析の入口†
］を利用して，
%~dummy~URL を構文解析する。
【†この訳では、 ε を与えることにより，それを利用する】
◎
Note, state override is not used here because it enforces restrictions that are only appropriate for the protocol setter. Instead we use the protocol to parse a dummy URL using the normal parsing entry point.
</p>

	</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
~RET %~dummy~URL の`~scheme$url
◎
Return dummyURL’s scheme.
</li>
</ol>
</div>

<div class="algo">
<p>
`~usernameを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a username given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
`~URLの~usernameを設定する$( %~dummy~URL, %値 )
◎
Set the username given dummyURL and value.
</li>
	<li>
~RET %~dummy~URL の`~username$url
◎
Return dummyURL’s username.
</li>
</ol>
</div>

<div class="algo">
<p>
`~passwordを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a password given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
`~URLの~passwordを設定する$( %~dummy~URL, %値 )
◎
Set the password given dummyURL and value.
</li>
	<li>
~RET %~dummy~URL の`~password$url
◎
Return dummyURL’s password.
</li>
</ol>
</div>

<div class="algo">
<p>
`~hostnameを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a hostname given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %値, %~dummy~URL, `~hostname$st )
◎
Let parseResult be the result of running the basic URL parser given value with dummyURL as url and hostname state as state override.
</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
%~host ~LET %~dummy~URL の`~host$url
◎
↓</li>
	<li>
~RET %~host に応じて
⇒＃
~NULL ならば 空~文字列／
~ELSE_ `~hostを直列化する$( %~host )
◎
Return dummyURL’s host, serialized, or empty string if it is null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~IPv6~hostnameを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize an IPv6 hostname given a string value:
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
<p>
%値 を成す
~EACH( %符号位置 )
に対し，順に：
◎
For each code point in value interpreted as a list of code points:
</p>
		<ol>
			<li>
<p>
~IF［
%符号位置 は`~ASCII~hex数字$でない
］~AND［
%符号位置 ~NIN { `005B^U, `005D^U, `003A^U }
］
⇒
~THROW `TypeError$E
◎
If all of the following are true:
• code point is not an ASCII hex digit;
• code point is not U+005B ([);
• code point is not U+005D (]); and
• code point is not U+003A (:),
◎
then throw a TypeError.
</p>
			</li>
			<li>
%結果 に次を付加する
⇒
`~ASCII小文字~化する$( %符号位置 )
◎
Append the result of running ASCII lowercase given code point to the end of result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`~portを正準-化する@
~algoは、
所与の
( 文字列 %~port値, 文字列 %~protocol値 ~DF ε )
に対し：
◎
To canonicalize a port given a string portValue and optionally a string protocolValue:
</p>
<ol>
	<li>
~IF［
%~port値 ~EQ 空~文字列
］
⇒
~RET %~port値
◎
If portValue is the empty string, return portValue.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
<p>
~IF［
%~protocol値 ~NEQ ε
］
⇒
%~dummy~URL の`~scheme$url ~SET %~protocol値
◎
If protocolValue was given, then set dummyURL’s scheme to protocolValue.
</p>

<p class="note">注記：
ここで`~scheme$urlを設定するのは、［
`基本~URL構文解析器$が`既定~port$を認識して正規化する
］ようにするためである。
◎
Note, we set the URL record's scheme in order for the basic URL parser to recognize and normalize default port values.
</p>
	</li>
	<li>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %~port値, %~dummy~URL, `~port$st )
◎
Let parseResult be the result of running basic URL parser given portValue with dummyURL as url and port state as state override.
</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
%~port ~LET %~dummy~URL の`~port$url
◎
↓</li>
	<li>
~RET %~port に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `整数を直列化する$( %~port )
◎
Return dummyURL’s port, serialized, or empty string if it is null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~pathnameを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a pathname given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, then return value.
</li>
	<li>
%先頭は~slashか ~LET ~IS［
%値 を成す最初の`文字$ ~EQ `002F^U
］
◎
Let leading slash be true if the first code point in value is U+002F (/) and otherwise false.
</li>
	<li>
<p>
%改変-済み値 ~LET %先頭は~slashか に応じて
⇒＃
~T ならば 空~文字列 ／
~F ならば `/-^l
◎
Let modified value be "/-" if leading slash is false and otherwise the empty string.
</p>

<div class="note">
<p>注記：
~URL構文解析器は，正準-化される~pathnameに自動的に~slashを接頭する【！prepend】が、
あいにく，ここでは働かない。
この~algoは、
符号化~callbackとして利用されるときには［
~pathname全体ではなく，~pathnameを成す各~piece
］用に~callされるので。
したがって，ここでは、
自前の~slashを挿入して，この接頭-法【！prepending】を不能化する。
ここでは、
追加的な文字【 `-^l 】も挿入する
— 先頭に~dotがあった場合に［
捏造な~slashと伴に `/.^l 連列として解釈されることに因り，不作為に縮約される
］ことを避けるため。
ここで挿入した これらの文字は、
後で結果から除去される。
◎
The URL parser will automatically prepend a leading slash to the canonicalized pathname. This does not work here unfortunately. This algorithm is called for pieces of the pathname, instead of the entire pathname, when used as an encoding callback. Therefore we disable the prepending of the slash by inserting our own. An additional character is also inserted here in order to avoid inadvertantly collapsing a leading dot due to the fake leading slash being interpreted as a "/." sequence. These inserted characters are then removed from the result below.
</p>

<p>
実装は、
各自の~URL構文解析~codeにおいては，
~slashの接頭-法【！prepending】を単純に不能化してもかまわない
— ［
この~algo内で文字たちを挿入してから除去する
］ことによる処理能の代償を払う代わりに。
◎
Note, implementations are free to simply disable slash prepending in their URL parsing code instead of paying the performance penalty of inserting and removing characters in this algorithm.
</p>
</div>
	</li>
	<li>
%改変-済み値 に %値 を付加する
◎
Append value to the end of modified value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %改変-済み値, %~dummy~URL, `~path開始$st )
◎
Let parseResult be the result of running basic URL parser given modified value with dummyURL as url and path start state as state override.
</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
%結果 ~LET `~URL~pathを直列化する$( %~dummy~URL )
◎
Let result be the result of URL path serializing dummyURL.
</li>
	<li>
~IF［
%先頭は~slashか ~EQ ~F
］
⇒
%結果 ~SET %結果 の中の 2 から`終端までを成す符号位置~部分文字列$
◎
If leading slash is false, then set result to the code point substring from 2 to the end of the string within result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`不透明な~pathnameを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize an opaque pathname given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
%~dummy~URL の`~path$url ~SET 空~文字列
◎
Set dummyURL’s path to the empty string.
</li>
	<li>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %値, %~dummy~URL, `不透明~path$st )
◎
Let parseResult be the result of running URL parsing given value with dummyURL as url and opaque path state as state override.
</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
~RET `~URL~pathを直列化する$( %~dummy~URL )
◎
Return the result of URL path serializing dummyURL.
</li>
</ol>
</div>

<div class="algo">
<p>
`~searchを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a search given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
%~dummy~URL の`~query$url ~SET 空~文字列
◎
Set dummyURL’s query to the empty string.
</li>
	<li>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %値, %~dummy~URL, `~query$st )
◎
Let parseResult be the result of running basic URL parser given value with dummyURL as url and query state as state override.
</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
~RET %~dummy~URL の`~query$url
◎
Return dummyURL’s query.
</li>
</ol>
</div>

<div class="algo">
<p>
`~hashを正準-化する@
~algoは、
所与の
( 文字列 %値 )
に対し：
◎
To canonicalize a hash given a string value:
</p>
<ol>
	<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~RET %値
◎
If value is the empty string, return value.
</li>
	<li>
%~dummy~URL ~LET 新たな`~URL~record$
◎
Let dummyURL be a new URL record.
</li>
	<li>
%~dummy~URL の`素片$url ~SET 空~文字列
◎
Set dummyURL’s fragment to the empty string.
</li>
	<li>
%構文解析-結果 ~LET `~API用に~URL構文解析する$( %値, %~dummy~URL, `素片$st )
◎
Let parseResult be the result of running basic URL parser given value with dummyURL as url and fragment state as state override.
</li>
	<li>
~IF［
%構文解析-結果 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parseResult is failure, then throw a TypeError.
</li>
	<li>
~RET %~dummy~URL の`素片$url
◎
Return dummyURL’s fragment.
</li>
</ol>
</div>

		</section>
		<section id="canon-processing-for-init">
<h3 title="URLPatternInit processing">3.2. `URLPatternInit$I の処理-法</h3>

<div class="algo">
<p>
`~URLPatternInitを処理する@
~algoは、
所与の
⇒＃
`URLPatternInit$I %~init,
文字列 %種別,
［文字列／~NULL］ %~protocol,
［文字列／~NULL］ %~username,
［文字列／~NULL］ %~password,
［文字列／~NULL］ %~hostname,
［文字列／~NULL］ %~port,
［文字列／~NULL］ %~pathname,
［文字列／~NULL］ %~search,
［文字列／~NULL］ %~hash
◎終
に対し：
◎
To process a URLPatternInit given a URLPatternInit init, a string type, a string or null protocol, a string or null username, a string or null password, a string or null hostname, a string or null port, a string or null pathname, a string or null search, and a string or null hash:
</p>
<ol>
	<li>
%結果 ~LET 新たな `URLPatternInit$I
◎
Let result be the result of creating a new URLPatternInit.
</li>
	<li>
~IF［
%~protocol ~NEQ ~NULL
］
⇒
%結果[ "`protocol$upI" ] ~SET %~protocol
◎
If protocol is not null, set result["protocol"] to protocol.
</li>
	<li>
~IF［
%~username ~NEQ ~NULL
］
⇒
%結果[ "`username$upI" ] ~SET %~username
◎
If username is not null, set result["username"] to username.
</li>
	<li>
~IF［
%~password ~NEQ ~NULL
］
⇒
%結果[ "`password$upI" ] ~SET %~password
◎
If password is not null, set result["password"] to password.
</li>
	<li>
~IF［
%~hostname ~NEQ ~NULL
］
⇒
%結果[ "`hostname$upI" ] ~SET %~hostname
◎
If hostname is not null, set result["hostname"] to hostname.
</li>
	<li>
~IF［
%~port ~NEQ ~NULL
］
⇒
%結果[ "`port$upI" ] ~SET %~port
◎
If port is not null, set result["port"] to port.
</li>
	<li>
~IF［
%~pathname ~NEQ ~NULL
］
⇒
%結果[ "`pathname$upI" ] ~SET %~pathname
◎
If pathname is not null, set result["pathname"] to pathname.
</li>
	<li>
~IF［
%~search ~NEQ ~NULL
］
⇒
%結果[ "`search$upI" ] ~SET %~search
◎
If search is not null, set result["search"] to search.
</li>
	<li>
~IF［
%~hash ~NEQ ~NULL
］
⇒
%結果[ "`hash$upI" ] ~SET %~hash
◎
If hash is not null, set result["hash"] to hash.
</li>
	<li>
%基底~URL文字列 ~LET %~init[ "`baseURL$upI" ]
◎
Let baseURL be null.
</li>
	<li>
`(A)^i
<p>
~IF［
%基底~URL文字列 ~NEQ ε
］：
◎
If init["baseURL"] exists:
</p>

<div class="note">
<p>注記：
基底~URLは，追加的な文脈を給するために利用され得るが、
各~成分に対し
⇒
基底~URLを成す当の成分は、
%~init が［
当の成分か それより特有な成分
］を含む場合には，継承されない
【すなわち，結果に影響しない】。
◎
The base URL can be used to supply additional context, but for each component, if init includes a component which is at least as specific as one in the base URL, none is inherited.
</p>

<p>
成分どうしは、［
次に挙げる 2 つの~list
（それは、
~URL構文~内に現れる順序と ごく類似する）
いずれかにおいて，後に現れるもの
］ほど，より特有であるとされる：
◎
A component is more specific if it appears later in one of the following two lists (which are very similar to the order they appear in the URL syntax):
</p>
		<ul>
			<li>
~protocol,
~hostname,
~port,
~pathname,
~search,
~hash
◎
protocol, hostname, port, pathname, search, hash
</li>
			<li>
~protocol,
~hostname,
~port,
~username,
~password
◎
protocol, hostname, port, username, password
</li>
		</ul>
<p>
`URLPattern$I を構築するときには、［
~username, ~password
］も，基底~URLからは決して継承されない
（しかしながら，それらは、［
`test()$m ／ `exec()$m
］に対する引数として給された~URLを構文解析するときには，
基底~URLから継承される）。
◎
Username and password are also never inherited from a base URL when constructing a URLPattern. (They are, however, inherited from the base URL when parsing a URL supplied as an argument to test() or exec().)
</p>
</div>
		<ol>
			<li>
%基底~URL ~SET `~URL構文解析する$( %基底~URL文字列 )
◎
Set baseURL to the result of parsing init["baseURL"].
</li>
			<li>
~IF［
%基底~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If baseURL is failure, then throw a TypeError.
</li>
			<li>
~IF［
%~init[ "`protocol$upI" ] ~NEQ ε
］
⇒
~BREAK `(A)^i
◎
↓</li>
			<li>
%結果[ "`protocol$upI" ] ~SET `基底~URL文字列を処理する$( %基底~URL の`~scheme$url, %種別 )
◎
If init["protocol"] does not exist, then set result["protocol"] to the result of processing a base URL string given baseURL’s scheme and type.
◎
↓ If type is not "pattern" and init contains none of "protocol", "hostname", "port" and "username", then set result["username"] to the result of processing a base URL string given baseURL’s username and type.
◎
↓ If type is not "pattern" and init contains none of "protocol", "hostname", "port", "username" and "password", then set result["password"] to the result of processing a base URL string given baseURL’s password and type.
</li>
			<li>
~IF［
%~init[ "`hostname$upI" ] ~NEQ ε
］
⇒
~BREAK `(A)^i
◎
↓</li>
			<li>
%基底~host ~LET %基底~URL の`~host$url
◎
If init contains neither "protocol" nor "hostname", then:
• Let baseHost be baseURL’s host.
</li>
			<li>
~IF［
%基底~host ~EQ ~NULL
］
⇒
%基底~host ~SET 空~文字列
◎
• If baseHost is null, then set baseHost to the empty string.
</li>
			<li>
%結果[ "`hostname$upI" ] ~SET `基底~URL文字列を処理する$( %基底~host, %種別 )
◎
• Set result["hostname"] to the result of processing a base URL string given baseHost and type.
</li>
			<li>
~IF［
%~init[ "`port$upI" ] ~NEQ ε
］
⇒
~BREAK `(A)^i
◎
↓</li>

			<li>
`(B)^i
<p>
~IF［
%種別 ~NEQ `pattern^l
］：
</p>
				<ol>
					<li>
~IF［
%~init[ "`username$upI" ] ~NEQ ε
］
⇒
~BREAK `(B)^i
</li>
					<li>
%結果[ "`username$upI" ] ~SET 
`基底~URL文字列を処理する$( %基底~URL の`~username$url, %種別 )
</li>
					<li>
~IF［
%~init[ "`password$upI" ] ~EQ ε
］
⇒
~BREAK `(B)^i
</li>
					<li>
%結果[ "`password$upI" ] ~SET 
`基底~URL文字列を処理する$( %基底~URL の`~password$url, %種別 )
</li>
				</ol>
◎
↑↑</li>
			<li>
%基底~port ~LET %基底~URL の`~port$url
◎
↓</li>
			<li>
%結果[ "`port$upI" ] ~SET %基底~port に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `整数を直列化する$( %基底~port )
◎
If init contains none of "protocol", "hostname", and "port", then:
• If baseURL’s port is null, then set result["port"] to the empty string.
• Otherwise, set result["port"] to baseURL’s port, serialized.
</li>
			<li>
~IF［
%~init[ "`pathname$upI" ] ~NEQ ε
］
⇒
~BREAK `(A)^i
◎
↓</li>
			<li>
%結果[ "`pathname$upI" ] ~SET 
`基底~URL文字列を処理する$( `~URL~pathを直列化する$( %基底~URL, %種別 ) )
◎
If init contains none of "protocol", "hostname", "port", and "pathname", then set result["pathname"] to the result of processing a base URL string given the result of URL path serializing baseURL and type.
</li>
			<li>
~IF［
%~init[ "`search$upI" ] ~NEQ ε
］
⇒
~BREAK `(A)^i
◎
↓</li>
			<li>
%基底~query ~LET %基底~URL の`~query$url
◎
If init contains none of "protocol", "hostname", "port", "pathname", and "search", then:
• Let baseQuery be baseURL’s query.
</li>
			<li>
~IF［
%基底~query ~EQ ~NULL
］
⇒
%基底~query ~SET 空~文字列
◎
• If baseQuery is null, then set baseQuery to the empty string.
</li>
			<li>
%結果[ "`search$upI" ] ~SET `基底~URL文字列を処理する$( %基底~query, %種別 )
◎
• Set result["search"] to the result of processing a base URL string given baseQuery and type.
</li>
			<li>
~IF［
%~init[ "`hash$upI" ] ~NEQ ε
］
⇒
~BREAK `(A)^i
◎
↓</li>
			<li>
%基底~素片 ~LET %基底~URL の`素片$url
◎
If init contains none of "protocol", "hostname", "port", "pathname", "search", and "hash", then:
• Let baseFragment be baseURL’s fragment.
</li>
			<li>
~IF［
%基底~素片 ~EQ ~NULL
］
⇒
%基底~素片 ~SET 空~文字列
◎
• If baseFragment is null, then set baseFragment to the empty string.
</li>
			<li>
%結果[ "`hash$upI" ] ~SET `基底~URL文字列を処理する$( %基底~素片, %種別 )
◎
• Set result["hash"] to the result of processing a base URL string given baseFragment and type.
</li>
		</ol>
	</li>
	<li>
~IF［
%~init[ "`protocol$upI" ] ~NEQ ε
］
⇒
%結果[ "`protocol$upI" ] ~SET 
`~init用に~protocolを処理する$( %~init[ "`protocol$upI" ], %種別 )
◎
If init["protocol"] exists, then set result["protocol"] to the result of process protocol for init given init["protocol"] and type.
</li>
	<li>
~IF［
%~init[ "`username$upI" ] ~NEQ ε
］
⇒
%結果[ "`username$upI" ] ~SET 
`~init用に~usernameを処理する$( %~init[ "`username$upI" ], %種別 )
◎
If init["username"] exists, then set result["username"] to the result of process username for init given init["username"] and type.
</li>
	<li>
~IF［
%~init[ "`password$upI" ] ~NEQ ε
］
⇒
%結果[ "`password$upI" ] ~SET 
`~init用に~passwordを処理する$( %~init[ "`password$upI" ], %種別 )
◎
If init["password"] exists, then set result["password"] to the result of process password for init given init["password"] and type.
</li>
	<li>
~IF［
%~init[ "`hostname$upI" ] ~NEQ ε
］
⇒
%結果[ "`hostname$upI" ] ~SET 
`~init用に~hostnameを処理する$( %~init[ "`hostname$upI" ], %種別 )
◎
If init["hostname"] exists, then set result["hostname"] to the result of process hostname for init given init["hostname"] and type.
</li>
	<li>
<p>
~IF［
%~init[ "`port$upI" ] ~NEQ ε
］
⇒
%結果[ "`port$upI" ] ~SET 
`~init用に~portを処理する$( %~init[ "`port$upI" ], %結果[ "`protocol$upI" ], %種別 )
◎
If init["port"] exists, then set result["port"] to the result of process port for init given init["port"], result["protocol"], and type.
</p>
	</li>
	<li>
<p>
~IF［
%~init[ "`pathname$upI" ] ~NEQ ε
］：
◎
If init["pathname"] exists:
</p>
		<ol>
			<li>
%結果[ "`pathname$upI" ] ~SET %~init[ "`pathname$upI" ]
◎
Set result["pathname"] to init["pathname"].
</li>
			<li>
<p>
~IF［
~AND↓
］…
◎
If the following are all true:
</p>
				<ul>
					<li>
%基底~URL ~NEQ ε
◎
baseURL is not null;
</li>
					<li>
%基底~URL は`不透明な~path$を持つ
◎
baseURL has an opaque path; and
</li>
					<li>
`絶対~pathnameか否か$( %結果[ "`pathname$upI" ], %種別 ) ~EQ ~F
◎
the result of running is an absolute pathname given result["pathname"] and type is false,
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
%基底~URL~path ~LET `基底~URL文字列を処理する$( `~URL~pathを直列化する$( %基底~URL, %種別 ) )
◎
Let baseURLPath be the result of running process a base URL string given the result of URL path serializing baseURL and type.
</li>
					<li>
%~slash~index ~LET %基底~URL~path の`符号位置~長さ$ ~MINUS 1
◎
↓</li>
					<li>
<p>
~WHILE［
%~slash~index ~GTE 0
］：
</p>
						<ol>
							<li>
~IF［
%基底~URL~path を成す %~slash~index 番の符号位置 ~EQ `002F^U
］
⇒
~BREAK
</li>
							<li>
%~slash~index ~DECBY 1
</li>
						</ol>
◎
Let slash index be the index of the last U+002F (/) code point found in baseURLPath, interpreted as a sequence of code points, or null if there are no instances of the code point.
</li>
					<li>
<p>
~IF［
%~slash~index ~GTE 0
］：
◎
If slash index is not null:
</p>
						<ol>
							<li>
%新たな~pathname ~LET %基底~URL~path の中の 0 から［
%~slash~index ~PLUS 1
］までを`成す符号位置~部分文字列$ 
◎
Let new pathname be the code point substring from 0 to slash index + 1 within baseURLPath.
</li>
							<li>
%新たな~pathname に %結果[ "`pathname$upI" ] を付加する
◎
Append result["pathname"] to the end of new pathname.
</li>
							<li>
%結果[ "`pathname$upI" ] ~SET %新たな~pathname
◎
Set result["pathname"] to new pathname.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%結果[ "`pathname$upI" ] ~SET 
`~init用に~pathnameを処理する$( %結果[ "`pathname$upI" ], %結果[ "`protocol$upI" ], %種別 )
◎
Set result["pathname"] to the result of process pathname for init given result["pathname"], result["protocol"], and type.
</li>
		</ol>
	</li>
	<li>
~IF［
%~init[ "`search$upI" ] ~NEQ ε
］
⇒
%結果[ "`search$upI" ] ~SET 
`~init用に~searchを処理する$( %~init[ "`search$upI" ], %種別 )
◎
If init["search"] exists then set result["search"] to the result of process search for init given init["search"] and type.
</li>
	<li>
~IF［
%~init[ "`hash$upI" ] ~NEQ ε
］
⇒
%結果[ "`hash$upI" ] ~SET 
`~init用に~hashを処理する$( %~init[ "`hash$upI" ], %種別 )
◎
If init["hash"] exists then set result["hash"] to the result of process hash for init given init["hash"] and type.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`基底~URL文字列を処理する@
~algoは、
所与の
( 文字列 %入力, 文字列 %種別 )
に対し：
◎
To process a base URL string given a string input and a string type:
</p>
<ol>
	<li>
~Assert：
%入力 ~NEQ ~NULL
◎
Assert: input is not null.
</li>
	<li>
~IF［
%種別 ~NEQ `pattern^l
］
⇒
~RET %入力
◎
If type is not "pattern" return input.
</li>
	<li>
~RET `~pattern文字列を~escapeする$( %入力 )
◎
Return the result of escaping a pattern string given input.
</li>
</ol>
</div>

<div class="algo">
<p>
`絶対~pathnameか否か@
は、
所与の
( `~pattern文字列$ %入力, 文字列 %種別 )
に対し：
</p>
<ol>
	<li>
%長さ ~LET %入力 の`符号位置~長さ$
</li>
	<li>
<p>
~RET ~IS ~OR↓：
</p>
		<ul>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%長さ ~GTE 1
</li>
					<li>
`符号位置~部分文字列$( %入力, 0, 1 ) ~EQ `/^l
</li>
				</ul>
			</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%種別 ~NEQ `url^l
</li>
					<li>
%長さ ~GTE 2
</li>
					<li>
`符号位置~部分文字列$( %入力, 0, 2 ) ~IN { `\/^l, `{/^l }
</li>
				</ul>
			</li>
		</ul>
	</li>
</ol>
◎
To run is an absolute pathname given a pattern string input and a string type:
• If input is the empty string, then return false.
• If input[0] is U+002F (/), then return true.
• If type is "url", then return false.
• If input’s code point length is less than 2, then return false.
• If input[0] is U+005C (\) and input[1] is U+002F (/), then return true.
• If input[0] is U+007B ({) and input[1] is U+002F (/), then return true.
• Return false.
</div>

<div class="algo">
<p>
`~init用に~protocolを処理する@
~algoは、
所与の
( 文字列 %値, 文字列 %種別 )
に対し：
◎
To process protocol for init given a string value and a string type:
</p>
<ol>
	<li>
~IF［
%値 を成す最初の`文字$ ~EQ `003A^U
］
⇒
%値 ~SET %値 の中の 1 から`終端までを成す符号位置~部分文字列$
◎
Let strippedValue be the given value with a single trailing U+003A (:) removed, if any.
</li>
	<li>
~RET %種別 に応じて
⇒＃
`pattern^l ならば %値 ／
~ELSE_ `~protocolを正準-化する$( %値 )
◎
If type is "pattern" then return strippedValue.
◎
Return the result of running canonicalize a protocol given strippedValue.
</li>
</ol>
</div>

<div class="algo">
`~init用に~usernameを処理する@
~algoは、
所与の
( 文字列 %値, 文字列 %種別 )
に対し
⇒
~RET %種別 に応じて
⇒＃
`pattern^l ならば %値 ／
~ELSE_ `~usernameを正準-化する$( %値 )
◎
To process username for init given a string value and a string type:
• If type is "pattern" then return value.
• Return the result of running canonicalize a username given value.
</div>

<div class="algo">
`~init用に~passwordを処理する@
~algoは、
所与の
( 文字列 %値, 文字列 %種別 )
に対し
⇒
~RET %種別 に応じて
⇒＃
`pattern^l ならば %値 ／
~ELSE_ `~passwordを正準-化する$( %値 )
◎
To process password for init given a string value and a string type:
• If type is "pattern" then return value.
• Return the result of running canonicalize a password given value.
</div>

<div class="algo">
`~init用に~hostnameを処理する@
~algoは、
所与の
( 文字列 %値, 文字列 %種別 )
に対し
⇒
~RET %種別 に応じて
⇒＃
`pattern^l ならば %値 ／
~ELSE_ `~hostnameを正準-化する$( %値 )
◎
To process hostname for init given a string value and a string type:
• If type is "pattern" then return value.
• Return the result of running canonicalize a hostname given value.
</div>

<div class="algo">
`~init用に~portを処理する@
~algoは、
所与の
( 文字列 %~port値, 文字列 %~protocol値, 文字列 %種別 )
に対し
⇒
~RET %種別 に応じて
⇒＃
`pattern^l ならば %~port値 ／
~ELSE_ `~portを正準-化する$( %~port値, %~protocol値 )
◎
To process port for init given a string portValue, a string protocolValue, and a string type:
• If type is "pattern" then return portValue.
• Return the result of running canonicalize a port given portValue and protocolValue.
</div>

<div class="algo">
<p>
`~init用に~pathnameを処理する@
~algoは、
所与の
( 文字列 %~pathname値, 文字列 %~protocol値, 文字列 %種別 )
に対し：
◎
To process pathname for init given a string pathnameValue, a string protocolValue, and a string type:
</p>
<ol>
	<li>
~IF［
%種別 ~EQ `pattern^l
］
⇒
~RET %~pathname値
◎
If type is "pattern" then return pathnameValue.
</li>
	<li>
<p>
~IF［
%~protocol値 は`特別~scheme$である
］~OR［
%~protocol値 ~EQ 空~文字列
］
⇒
~RET `~pathnameを正準-化する$( %~pathname値 )
◎
If protocolValue is a special scheme or the empty string, then return the result of running canonicalize a pathname given pathnameValue.
</p>

<p class="note">注記：
［
%~protocol値 ~EQ 空~文字列
］の場合、
構築子に渡された辞書には `protocol$upI 用の値は供されなかったことになる。
通常は，空~文字列をとる辞書~値は特別に扱われないが、
この事例では，［
最も共通的な~pathnameの正準-化を既定とする
］ために，それを`特別~scheme$と同じに扱う。
◎
If the protocolValue is the empty string then no value was provided for protocol in the constructor dictionary. Normally we do not special case empty string dictionary values, but in this case we treat it as a special scheme in order to default to the most common pathname canonicalization.
</p>
	</li>
	<li>
~RET `不透明な~pathnameを正準-化する$( %~pathname値 )
◎
Return the result of running canonicalize an opaque pathname given pathnameValue.
</li>
</ol>
</div>

<div class="algo">
<p>
`~init用に~searchを処理する@
~algoは、
所与の
( 文字列 %値, 文字列 %種別 )
に対し：
◎
To process search for init given a string value and a string type:
</p>
<ol>
	<li>
~IF［
%値 を成す最初の`文字$ ~EQ `003F^U
］
⇒
%値 ~SET %値 の中の 1 から`終端までを成す符号位置~部分文字列$
◎
Let strippedValue be the given value with a single leading U+003F (?) removed, if any.
</li>
	<li>
~RET %種別 に応じて
⇒＃
`pattern^l ならば %値 ／
~ELSE_ `~searchを正準-化する$( %値 )
◎
If type is "pattern" then return strippedValue.
◎
Return the result of running canonicalize a search given strippedValue.
</li>
</ol>
</div>

<div class="algo">
<p>
`~init用に~hashを処理する@
~algoは、
所与の
( 文字列 %値, 文字列 %種別 )
に対し：
◎
To process hash for init given a string value and a string type:
</p>
<ol>
	<li>
~IF［
%値 を成す最初の文字 ~EQ `0023^U
］
⇒
%値 ~SET %値 の中の 1 から`終端までを成す符号位置~部分文字列$
◎
Let strippedValue be the given value with a single leading U+0023 (#) removed, if any.
</li>
	<li>
~RET %種別 に応じて
⇒＃
`pattern^l ならば %値 ／
~ELSE_ `~hashを正準-化する$( %値 )
◎
If type is "pattern" then return strippedValue.
◎
Return the result of running canonicalize a hash given strippedValue.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="other-specs">
<h2 title="Using URL patterns in other specifications">4. 他の仕様における~URL~patternの利用-法</h2>

<p>
~web~platformの一貫性を促進するため、
この仕様を統合する他の文書は
— 他へ分岐する良い理由が無い限り —
次に挙げる指針を固守するベキである：
◎
To promote consistency on the web platform, other documents integrating with this specification should adhere to the following guidelines, unless there is good reason to diverge.
</p>
<ul>
	<li>
<strong>
略式~文字列を受容すること。
</strong>
作者による~patternは、
ほとんどが単純かつ単直になる。
それに則って，~APIは、
自身に共通的な事例~用に略式~文字列を受容するベキである
— 作者が［
完全な `URLPattern$I ~objへ形式変換する追加的な手続き
］を踏まずに済むよう。
◎
Accept shorthands. Most author patterns will be simple and straightforward. Accordingly, APIs should accept shorthands for those common cases and avoid the need for authors to take additional steps to transform these into complete URLPattern objects.
</li>
	<li>
<strong>
基底~URLを尊重すること。
</strong>
~URLは，一般に［
所与の環境~用の基底~URL
（`文書~基底~URL$が最も共通的にある）
に相対的に構文解析される
］が、
それと同じく，~URL~patternも基底~URLを尊重するベキである。
`URLPattern$I の構築子~自体は、
当の概念~自体を直に公開するので，例外である
（ `URL$I の構築子が，基底~URLを
— ~platformを成す他所では尊重されるとしても —
尊重しないのと類似に）。
◎
Respect the base URL. Just as URLs are generally parsed relative to a base URL for their environment (most commonly, a document base URL), URL patterns should respect this as well. The URLPattern constructor itself is an exception because it directly exposes the concept itself, similar to how the URL constructor does not respect the base URL even though the rest of the platform does.
</li>
	<li>
<p>
<strong>
~regexp~groupについて明瞭にすること。
</strong>
一部の~APIは、［
`~regexp~groupを有して$いない~URL~patternに限り許容する
］ことから便益を得ることもある
— 例えば、
次に挙げる~~理由で：
</p>
		<ul>
			<li>
~UAは、
作者~scriptを実行していない［
~thread／~process
］内で，それを実装する見込みが高い
</li>
			<li>
~securityや処理能の懸念
</li>
			<li>
そこでは、
~JS~engineが普通に走らない
</li>
		</ul>
<p>
そうする場合、
そのことが明瞭に
（ “`~regexp~groupを有して$” への参照を伴って）
文書化されるベキであり，
当の演算はアリな限り早く~errorを報告するベキである
（例：~JS例外を投出することにより）。
アリな場合、
これは，特能~検出-可能になるベキである
— 将来に，この拘束が外されるアリ性を許容するため。
この仕様の編集者に諮ることなく，［
~URL~patternを成す異なる下位集合を作成する
］ことは、
避けること。
</p>
◎
Be clear about regexp groups. Some APIs may benefit from only allowing URL patterns which do not have regexp groups, for example, because user agents are likely to implement them in a different thread or process from those executing author script, and because of security or performance concerns, a JavaScript engine would not ordinarily run there. If so, this should be clearly documented (with reference to has regexp groups) and the operation should report an error as soon as possible (e.g., by throwing a JavaScript exception). If possible, this should be feature-detectable to allow for the possibility of this constraint being lifted in the future. Avoid creating different subsets of URL patterns without consulting the editors of this specification.
</li>
	<li><strong>
~URLとして何が合致するかついて，明瞭にすること。
</strong>
一例として、
何かを~fetchする~algoは，
その間は`素片$urlを伴わない~URLに対し演算する見込みが高い。
そのような場合、
当の仕様は，この事例に該当することを明瞭にするベキであり，［
開発者が合致し得ない~patternを利用した場合には
（例：それは、
空でない素片を要求するので）、
警告を示す
］よう助言してもヨイ。
◎
Be clear about what URLs will be matched. For instance, algorithms during fetching are likely to operate on URLs with no fragment. If so, the specification should be clear that this is the case, and may advise showing a developer warning if a pattern which cannot match (e.g., because it requires a non-empty fragment) is used.
</li>
</ul>

		<section id="other-specs-javascript">
<h3 title="Integrating with JavaScript APIs">4.1. ~JS~APIとの統合-法</h3>

<pre class="idl">
typedef (`USVString$ or `URLPatternInit$I or `URLPattern$I) `URLPatternCompatible@I;
</pre>

<p>
~JS~APIは、
次に挙げるものを受容するベキである：
◎
JavaScript APIs should accept all of:
</p>
<ul>
	<li>
`URLPattern$I ~obj
◎
a URLPattern object
</li>
	<li>
ある~patternを構築するために要求される成分たちを指定する，辞書の様な~obj
◎
a dictionary-like object which specifies the components required to construct a pattern
</li>
	<li>
文字列（`構築子~文字列の構文$に従うもの）
◎
a string (in the constructor string syntax)
</li>
</ul>

<p>
これを成遂げるため、
各~仕様は：
◎
To accomplish this, specifications should＼
</p>
<ul>
	<li>
［
`演算$に対する引数／`辞書~member$
］として，
`URLPatternCompatible$I を受容するベキである。
◎
accept URLPatternCompatible as an argument to an operation or dictionary member,＼
</li>
	<li>
以下に挙げる~algo利用して，
前項を処理するベキである
— %基底~URL として［
適切な`環境~設定群~obj$の`~API用~基底~URL$enV, あるいは それに等価なもの
］を利用する下で。
◎
and process it using the following algorithm, using the appropriate environment settings object's API base URL or equivalent.
</li>
</ul>

<div class="algo">
<p>
`~Web~IDL値から~URLPattern~objを築く@
~algoは、
所与の
( `URLPatternCompatible$I %入力, `~URL~record$ %基底~URL, `~realm$ %~realm )
に対し：
◎
To build a URLPattern object from a Web IDL value URLPatternCompatible input given URL baseURL and realm realm, perform the following steps:
</p>
<ol>
	<li>
~IF［
%入力 の`特有~型$ ~EQ `URLPattern$I
］
⇒
~RET %入力
◎
If the specific type of input is URLPattern:
• Return input.
◎
Otherwise:
</li>
	<li>
%~pattern ~LET `新たな~obj$( `URLPattern$I, %~realm )
◎
Let pattern be a new URLPattern with realm.
</li>
	<li>
%~pattern に`結付けられた~URL~pattern$ ~SET `~Web~IDL値から~URL~patternを築く$( %入力, %基底~URL )
◎
Set pattern’s associated URL pattern to the result of building a URL pattern from a Web IDL value given input and baseURL.
</li>
	<li>
~RET %~pattern
◎
Return pattern.
</ol>
</div>

<div class="algo">
<p>
`~Web~IDL値から~URL~patternを築く@
~algoは、
所与の
( `URLPatternCompatible$I %入力, `~URL~record$ %基底~URL )
に対し：
◎
To build a URL pattern from a Web IDL value URLPatternCompatible input given URL baseURL, perform the following steps:
</p>
<ol>
	<li>
%型 ~LET %入力 の`特有~型$
◎
↓</li>
	<li>
~IF［
%型 ~EQ `URLPattern$I
］
⇒
~RET %入力 に`結付けられた~URL~pattern$
◎
If the specific type of input is URLPattern:
• Return input’s associated URL pattern.
</li>
	<li>
%基底~URL文字列 ~LET `~URLを直列化する$( %基底~URL )
◎
↓</li>
	<li>
<p>
~IF［
%型 ~EQ `URLPatternInit$I
］：
◎
Otherwise, if the specific type of input is URLPatternInit:
</p>
		<ol>
			<li>
%~init ~LET %入力 を`~cloneする$map
◎
Let init be a clone of input.
</li>
			<li>
~IF［
%~init[ "`baseURL$upI" ] ~EQ ε
］
⇒
%~init[ "`baseURL$upI" ] ~SET %基底~URL文字列
◎
If init["baseURL"] does not exist, set it to the serialization of baseURL.
</li>
			<li>
~RET `~URL~patternを作成する$( %~init, ~NULL, 新たな`~map$ )
◎
Return the result of creating a URL pattern given init, null, and an empty map.
</li>
		</ol>
	</li>
	<li>
~Assert：
%型 ~EQ `USVString$I
◎
Otherwise:
◎
• Assert: The specific type of input is USVString.
</li>
	<li>
~RET `~URL~patternを作成する$( %入力, %基底~URL文字列, 新たな`~map$ )
◎
Return the result of creating a URL pattern given input, the serialization of baseURL, and an empty map.
</li>
</ol>
</div>

<p>
これは、［
ほとんどの~patternを簡潔に指定すること
］および［
必要yな場合は、
`構築子＠#dom-urlpattern-urlpattern-input-options$を利用して，
共通的なものではない~optionに~accessすること
］を作者に許容する。
基底~URLの暗黙的な利用は、
`HTML$r の`~URLを相対的に構文解析する$~algoと［
類似する, 一貫する
］。
◎
This allows authors to concisely specify most patterns, and use the constructor to access uncommon options if necessary. The implicit use of the base URL is similar to, and consistent with, HTML’s parse a URL algorithm. [HTML]
</p>

		</section>
		<section id="other-specs-json">
<h3 title="Integrating with JSON data formats">4.2. ~JSON~data形式との統合-法</h3>

<p>
~URL~patternを含んでいる~JSON~data形式は、
`~JS~API＠#other-specs-javascript$の挙動を映出すベキであり，
次をいずれも受容するベキである：
◎
JSON data formats which include URL patterns should mirror the behavior of JavaScript APIs and accept both:
</p>
<ul>
	<li>
［
~patternを構築するために要求される成分
］を指定している~obj
◎
an object which specifies the components required to construct a pattern
</li>
	<li>
文字列（`構築子~文字列の構文$に従うもの）
◎
a string (in the constructor string syntax)
</li>
</ul>

<p>
ある仕様が~Infra値 `INFRA$r
【そのような~JSON~dataに等価な， `INFRA^r にて定義される仕様~levelの型を成す値】
を有する場合
（例： `~JSON文字列を~Infra値に構文解析する$を利用した後に）、
次の~algoを
— 適切な基底~URL
（既定では，当の~JSON資源の~URL）
を利用する下で —
利用すること。
◎
If a specification has an Infra value (e.g., after using parse a JSON string to an Infra value), use the following algorithm, using the appropriate base URL (by default, the URL of the JSON resource). [INFRA]
</p>

<div class="algo">
<p>
`~Infra値から~URL~patternを築く@
~algoは、
所与の
( ~Infra値 %生な~pattern, `~URL~record$ %基底~URL )
に対し：
◎
To build a URL pattern from an Infra value rawPattern given URL baseURL, perform the following steps.
</p>
<ol>
	<li>
%直列化-済み基底~URL ~LET `~URLを直列化する$( %基底~URL )
◎
Let serializedBaseURL be the serialization of baseURL.
</li>
	<li>
<p>
~IF［
%生な~pattern は`文字列$である
］
⇒
~RET `~URL~patternを作成する$( %生な~pattern, %直列化-済み基底~URL, 新たな`~map$ )
◎
If rawPattern is a string, then:
• Return the result of creating a URL pattern given rawPattern, serializedBaseURL, and an empty map.
</p>

<p class="note">注記：
将来には、
ここで，空でない~option群を `plumb^en する【？】ことが必要yあるかもしれない。
◎
• It might become necessary in the future to plumb non-empty options here.
</p>
	</li>
	<li>
<p>
~ELIF［
%生な~pattern は`~map$である
］：
◎
Otherwise, if rawPattern is a map, then:
</p>
		<ol>
			<li>
%~init ~LET «[ "`baseURL$upI"  → %直列化-済み基底~URL ] »
（ `URLPatternInit$I 型の辞書を表現する~map）
◎
Let init be «[ "baseURL" → serializedBaseURL ]», representing a dictionary of type URLPatternInit.
</li>
			<li>
<p>
%生な~pattern を成す
~EACH( %~key → %値 )
に対し：
◎
For each key → value of rawPattern:
</p>
				<ol>
					<li>
<div>
<p>
~IF［
~NOT ~AND↓
］…
</p>
						<ul>
							<li>
%値 は`文字列$である
</li>
							<li>
<p>
［
`URLPatternInit$I, およびそれが`継承した辞書~群$
］を成す辞書として［
~AND↓ を満たす`辞書~member$
］を有するものが在る：
</p>
								<ul>
									<li>
その`識別子$ ~EQ %~key
</li>
									<li>
それに宣言された型は `USVString$I である
</li>
								</ul>
							</li>
						</ul>
<p>
…ならば
⇒
~RET ~NULL
</p>
◎
If key is not the identifier of a dictionary member of URLPatternInit or one of its inherited dictionaries, value is not a string, or the member’s type is not declared to be USVString, then return null.
</div>

<p class="note">注記：
最後に挙げた条件は、
`URLPatternInit$I に他の型の~memberが加わった場合には，更新する必要がある。
◎
This will need to be updated if URLPatternInit gains members of other types.
</p>

<p class="note">注記：
この仕様の将来の~versionは、
より厳密でない~modeも有するかもしれない
— それが，他の仕様に有用になるものと立証されたなら。
◎
A future version of this specification might also have a less strict mode, if that proves useful to other specifications.
</p>
					</li>
					<li>
%~init[ %~key ] ~SET %値
◎
Set init[key] to value.
</li>
				</ol>
			</li>
			<li>
<p>
~RET `~URL~patternを作成する$( %~init, ~NULL, 新たな`~map$ )
◎
Return the result of creating a URL pattern given init, null, and an empty map.
</p>

<p class="note">注記：
将来には、
ここで，空でない~option群を `plumb^en する【？】ことが必要yあるかもしれない。
◎
• It might become necessary in the future to plumb non-empty options here.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Otherwise, return null.
</li>
</ol>
</div>

<p>
各~仕様は、
各自の形式において［
`URLPatternOptions$I 用の~option群を受容する／
基底~URLを上書きする／
他の類似な何かを行う
］ための余地を残すよう望むこともあろう
— ~JS~APIと違って、
この事例では， `URLPattern$I ~objを直に構築することはアリでないので。
例えば， `SPECULATION-RULES$r は、
~keyとして `relative_to^l を受容する
— それは、［
~JSON資源の~URLに代えて，`文書~基底~URL$を利用するよう切替える
］ために利用され得る。
◎
Specifications may wish to leave room in their formats to accept options for URLPatternOptions, override the base URL, or similar, since it is not possible to construct a URLPattern object directly in this case, unlike in a JavaScript API. For example, Speculation Rules accepts a "relative_to" key which can be used to switch to using the document base URL instead of the JSON resource’s URL. [SPECULATION-RULES]
</p>

		</section>
		<section id="other-specs-http">
<h3 title="Integrating with HTTP header fields">4.3. ~HTTP~headerとの統合-法</h3>

<p>
~HTTP~headerのうち，その値に~URL~patternを含むものは、
`構築子~文字列の構文$において文字列を受容するベキである
— そのような~headerは、
`有構造~field$ `RFC8941$r になる見込みが高い。
◎
HTTP headers which include URL patterns should accept a string in the constructor string syntax, likely as part of a structured field [RFC8941].
</p>

<p class="note">注記：
既知な~headerには、
~URL~pattern用の辞書~構文を受容するものは無い。
在るようになった場合、
この仕様は，それを
— たぶん，`~sf内縁~list$ `RFC8941$r の処理により —
定義するよう更新されることになる。
◎
No known header accepts the dictionary syntax for URL patterns. If that changes, this specification will be updated to define it, likely by processing [RFC8941] inner lists.
</p>

<p>
~HTTP~header用の仕様は、
`URLPattern$I ~objではなく
（それは、
~JS`~realm$の存在を含意する），
`~URL~pattern$に対し演算するベキである
（例：`~URL~patternを照合する$~algoを利用して）。
◎
Specifications for HTTP headers should operate on URL patterns (e.g., using the match algorithm) rather than URLPattern objects (which imply the existence of a JavaScript realm).
</p>

<div class="algo">
<p>
`~HTTP有構造~field値から~URL~patternを築く@
~algoは、
所与の
( 有構造~field値 %生な~pattern `~URL~record$ %基底~URL )
に対し：
◎
To build a URL pattern from an HTTP structured field value rawPattern given URL baseURL:
</p>
<ol>
	<li>
%直列化-済み基底~URL ~LET `~URLを直列化する$( %基底~URL )
◎
Let serializedBaseURL be the serialization of baseURL.
</li>
	<li>
~Assert：
%生な~pattern は`~sf文字列$である。
◎
Assert: rawPattern is a string.
</li>
	<li>
~RET `~URL~patternを作成する$( %生な~pattern, %直列化-済み基底~URL, 新たな`~map$ )
◎
Return the result of creating a URL pattern given rawPattern, serializedBaseURL, and an empty map.
</li>
</ol>
</div>

<p class="note">注記：
~patternを評価している仕様は、［
`~regexp~groupを有して$いない~patternに限り受容する
］ことを考慮するかもしれない
— そのような~patternの方が，依拠-可能な処理能が得られるかもしれず、
その場合， `ECMA-262$r 正規表現の実装は要求されないので。
そのことは、
実装において［
~security, ~code~size, その他
］の含意を伴い得る。
他方，~JS~APIは、
そのような実装が初めから可用な環境において走る。
◎
Specifications might consider accepting only patterns which do not have regexp groups if evaluating the pattern, since the performance of such patterns might be more reliable, and may not require a [ECMA-262] regular expression implementation, which may have security, code size, or other implications for implementations. On the other hand, JavaScript APIs run in environments where such an implementation is readily available.
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

`_acks1＠#_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1＠#_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">
<p>
The editors would like to thank Alex Russell, Anne van Kesteren, Asa Kusuma, Blake Embrey, Cyrus Kasaaian, Daniel Murphy, Darwin Huang, Devlin Cronin, Domenic Denicola, Dominick Ng, Jake Archibald, Jeffrey Posnick, Jeremy Roman, Jimmy Shen, Joe Gregorio, Joshua Bell, Kenichi Ishibashi, Kenji Baheux, Kenneth Rohde Christiansen, Kingsley Ngan, Kinuko Yasuda, L. David Baron, Luca Casonato, Łukasz Anforowicz, Makoto Shimazu, Marijn Kruisselbrink, Matt Falkenhagen, Matt Giuca, Michael Landry, R. Samuel Klatchko, Rajesh Jagannathan, Ralph Chelala, Sangwhan Moon, Sayan Pal, Victor Costan, Yoshisato Yanagisawa, and Youenn Fablet for their contributors to this specification.
</p>

<p>
Special thanks to Blake Embrey and the other <a href="https://github.com/pillarjs/path-to-regexp">pillarjs/path-to-regexp</a> <a href="https://github.com/pillarjs/path-to-regexp/graphs/contributors">contributors</a> for building an excellent open source library that so many have found useful.
</p>

<p>
Also, special thanks to Kenneth Rohde Christiansen for his work on the polyfill. He put in extensive work to adapt to the changing <code class="idl"><a data-link-type="idl" href="#urlpattern">URLPattern</a></code> API.
</p>

<p>
This standard is written by Ben Kelly (<a href="https://www.google.com/">Google</a>, <a href="mailto:wanderview@chromium.org">wanderview@chromium.org</a>), Jeremy Roman (<a href="https://www.google.com/">Google</a>, <a href="mailto:jbroman@chromium.org">jbroman@chromium.org</a>), and 宍戸俊哉 (Shunya Shishido, <a href="https://www.google.com/">Google</a>, <a href="mailto:sisidovski@chromium.org">sisidovski@chromium.org</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
This Living Standard was originally developed in the W3C WICG, where it was available under the <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Software and Document License</a>.
</p>

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0
International License</a>. To the extent portions of it are incorporated into source code, such portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>
</div>
</div>

