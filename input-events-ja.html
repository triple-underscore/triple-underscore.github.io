<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">

<title>Input Events Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>

tr {
	border-top: thin solid var(--table-rule-color);
}

#_inputType-overview > tr > td:nth-child(-n+3),
#_data-attr-values > tr > td:first-child {
	white-space: pre-line;
}

@supports (grid-template-columns: subgrid) and (display: contents) {
#_attr-overview {
	grid-template-columns: minmax(8em, 12em) minmax(20em, 1fr) 12em;
	min-width: 40em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"host 入力型 data"
			"host 入力型 dataTransfer"
			"host 入力型 getTargetRanges"
		;
		> *:nth-child(1) {
			grid-area: host;
		}
		> *:nth-child(2) {
			grid-area: 入力型;
		}
		> *:nth-child(3) {
			grid-area: data;
		}
		> *:nth-child(4) {
			grid-area: dataTransfer;
		}
		> *:nth-child(5) {
			grid-area: getTargetRanges;
		}
	}
}

#_inputTypes {
	grid-template-columns: 4em 1fr 6em;
	min-width: 20em;
	max-width: 40em;
	tr {
		grid-template-areas:
			"入力型 入力型 入力型"
			". 表出意図 編集あり"
			". 表出意図 選択状態"
		;
		> *:nth-child(1) {
			grid-area: 入力型;
		}
		> *:nth-child(2) {
			grid-area: 表出意図;
		}
		> *:nth-child(3) {
			grid-area: 編集あり;
			min-height: 1.5em; /* TODO 1lh */
		}
		> *:nth-child(4) {
			grid-area: 選択状態;
			min-height: 1.5em; /* TODO 1lh */
		}
	}
}
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(mapping1){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%[\w~一-鿆]+|`(.*?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'a': // DOM attr name
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-08-14
trans_update:2025-08-16
source_checked:220311
page_state_key:UIEVENTS
original_url:https://w3c.github.io/input-events/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:2024,permissive
	conformance:w3c
site_nav:uievents
trans_1st_pub:2016-05-25

●●navs
イベント:.eventdef

●●class_map
et:event-type
e:element
a:attr
st:attr-state
p:css

●●tag_map
c:code
I:code
m:code
mb:code
et:code
e:code
a:code
p:code
st:span
i:i
v:var
cite:cite

●●original_id_map

normative:normative-references
informative:informative-references


●●mdn_urls
event-type-input:API/HTMLElement/input_event
event-type-beforeinput:API/HTMLElement/beforeinput_event

●●link_map

I.Element:~DOM4#element
I.Range:~DOM4#range
I.Event:~DOM4#event
I.InputEvent:~UIEVENTS#inputevent
I.UIEvent:~UIEVENTS#uievent
I.InputEventInit:~UIEVENTS#dictdef-inputeventinit
I.DataTransfer:~HTMLdnd#the-datatransfer-interface
I.File:~FILEAPI#file

I.Window:~WINDOW#window
I.StaticRange:~DOM4#interface-staticrange

m.inputType:#dom-inputevent-inputtype
m.dataTransfer:#dom-inputevent-datatransfer
m.getTargetRanges():#dom-inputevent-gettargetranges

mb.inputType:~UIEVENTS#dom-inputeventinit-inputtype
mb.dataTransfer:#dom-inputeventinit-datatransfer
mb.targetRanges:#dom-inputeventinit-targetranges


m.getData():~HTMLdnd#dom-datatransfer-getdata

m.cancelable:~DOM4#dom-event-cancelable
	#widl-InputEvent-cancelable
m.data:~UIEVENTS#dom-inputevent-data
m.InputEvent.isComposing:~UIEVENTS#dom-inputevent-iscomposing

m.UIEvent.detail:~UIEVENTS#dom-uievent-detail
m.UIEvent.view:~UIEVENTS#dom-uievent-view

m.contentEditable:~HTMLinteraction#dom-contenteditable

et.beforeinput:#event-type-beforeinput
et.input:#event-type-input
et.compositionstart:~UIEVENTS#event-type-compositionstart
et.compositionupdate:~UIEVENTS#event-type-compositionupdate
et.paste:~TR/clipboard-apis/#clipboard-event-paste
et.keydown:~UIEVENTS#event-type-keydown
et.keypress:~UIEVENTS-A#event-type-keypress

e.textarea:~HEforms#the-textarea-element
e.input:~HEinput#the-input-element
e.br:~HEtextlevel#the-br-element

a.contenteditable:~HTMLinteraction#attr-contenteditable

意図nを表出する:#dfn-express-intention
表出した意図n:#dfn-express-intention
~kill-buffer:#dfn-kill-buffer
内容編集可能:#_contenteditable

	●外部
~UA:~INFRA#user-agent
文書片:~DOM4#interface-documentfragment
配送-:~DOM4#concept-event-dispatch
~text組成~system:~UIEVENTS#text-composition-system
	組成~session:
	作動中な~text一節:
	~target範囲:

~drag~data~store:~HTMLdnd#drag-data-store
i.読専~mode:~HTMLdnd#concept-dnd-ro
ddS.~item~list:~HTMLdnd#drag-data-store-item-list
dI.種類:~HTMLdnd#the-drag-data-item-kind
dI.型~文字列:~HTMLdnd#the-drag-data-item-type-string
dI.実際の~data:~HTMLdnd#_the-drag-data-item-actual-data

st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)

編集中の~host:~HTMLinteraction#editing-host
~EditContextの編集中の~host:~EDITCONTEXT#dfn-editcontext-editing-host
	＠~EDITCONTEXT#dfn-handle-input-for-editcontext
	＠~EDITCONTEXT#dfn-editcontext-handled-inputtype

書記素~cluster:https://www.w3.org/TR/i18n-glossary/#dfn-grapheme-cluster
符号位置:~INFRA#code-points

~CSS成分~値を直列化する:~CSSOM1#serialize-a-css-component-value

~MIME型:~MIMESNIFF#mime-type
~byte列~data:~FILEAPI#_ref-bytes


●●words_table1
UIEVENTS-A:uievents-appendix-ja.html
UTR:https://www.unicode.org/reports
EDITCONTEXT:https://w3c.github.io/edit-context/

●●words_table



	●仕様
協調-:coordinate:~
必要性:needs:~
拡げて:expandして:~
衰退:decline:~
結論-:conclude:~
探求-:seek:~

	buggy
	関係する:related
	協調-:in coordination with
	要約-:summary
	~~緩和:alleviate
	相当量:considerable amount
	上層:on top of
	一部に限り:subset
	様々な:different
	共同作業:collaborative
	画策:laid out
	~~解決-:solve
	モノトスル:responsible for
	-:want
	該当:covered
	入る:takes place
	別として:apart from
	~~扱う:deal with
	至らせ:lead
	〜時には:marked by
	この~level 2:Input Events Level 2 

	●編集
editor::::エディタ
	~text~editor:texteditor
caret::::キャレット
	dead-key::::デッドキー
IME:
richtext::::リッチテキスト
plaintext::::素なテキスト
speech::::スピーチ
bold:
italic:
undo:
redo:
undone:
copy::::コピー
paste::::ペースト
cut::::カット
drag::::ドラッグ
drop::::ドロップ
store::::ストア
EditContext:
起する:initiateする:開始する
整形情報:formatting::~
中央:center::~
両端揃えに:full に justify:~
寄せる:alignする:~
subscript:::下付き文字
superscript:::上付き文字
underline:::下線
stricken:::打消し線
番号付き:numbered::~
番号無し:bulleted::~
水平罫線:horizontal rule::段落区切り罫線
字下げ:indentation::~
	字下げを増やす:indent
	字下げを減らす:outdent
組成:composition::~
組成-:compose::~
	組成し直す:recompose
内容編集可能:contenteditable::~
編集-:edit::~
編集:editing::~
編集中の:editing::~
改行:line break:~
併合-:merge:~
	可能化:enabled
選択:selection::~
	始まり:beginning
	終わり:end
畳まれ:collapseされ:~
	畳まれてない:non-collapsed

書記素:grapheme:~
後方:backward:~
前方:forward:~
用字系:script:~

打込まれ:typeされ:打ち込まれ:::タイプされ
自動訂正:auto-correct:~
書法:writing:書き方
spell-checker:spell checker:::綴り検査器
入替える:transposeする:入れ替える
clipboard::::クリップボード
kill-buffer:kill buffer
種類:kind::~
提-:propose:~
引用文:quotation:~
一節:passage:~
囲む:surroundする:~

	~memory内:in-memory
	一時的に保持する:temporal storage
	引き出す:yank する
	離脱して leave 〜 outside

	●event／DOM
発され:emitされ:~
	取消~可否:cancelability

	-:field
	入力~型:Inputtype

	●未分類
Array:
	high-level
背後:background:~
	その前に:precede

	●指示語
	直前:directly before
	直後:directly after
	following
	~text~editor:texteditor
	follow
	through
	different
	main
	part
	during
	form
	次 next
	several
	first

	starting
	time
	become
	し続け:continue
	thereafter
	taken


●●ref_normative

[CLIPBOARD-APIS]
    Clipboard API and events. Gary Kacmarcik; Anupam Snigdha. W3C. 16 May 2025. W3C Working Draft. URL: https://www.w3.org/TR/clipboard-apis/ 
[CSSOM]
    CSS Object Model (CSSOM). Daniel Glazman; Emilio Cobos Álvarez. W3C. 26 August 2021. W3C Working Draft. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FileAPI]
    File API. Marijn Kruisselbrink. W3C. 4 December 2024. W3C Working Draft. URL: https://www.w3.org/TR/FileAPI/ 
[fingerprinting-guidance]
    Mitigating Browser Fingerprinting in Web Specifications. Nick Doty; Tom Ritter. W3C. 21 March 2025. W3C Working Group Note. URL: https://www.w3.org/TR/fingerprinting-guidance/ 
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Dominic Farolino; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[infra]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[mimesniff]
    MIME Sniffing Standard. Gordon P. Hemsley. WHATWG. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[UI-EVENTS]
    UI Events. Gary Kacmarcik; Travis Leithead. W3C. 7 September 2024. W3C Working Draft. URL: https://www.w3.org/TR/uievents/ 
[WEBIDL]
    Web IDL Standard. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 

●●ref_informative

[i18n-glossary]
    Internationalization Glossary. Richard Ishida; Addison Phillips. W3C. 17 October 2024. W3C Working Group Note. URL: https://www.w3.org/TR/i18n-glossary/ 
[INPUT-EVENTS]
    Input Events Level 1. Johannes Wilm. W3C. 28 September 2023. W3C Working Draft. URL: https://www.w3.org/TR/input-events-1/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Input Events Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/input-events-2/
編集者草案
	https://w3c.github.io/input-events/
公表履歴
	https://www.w3.org/standards/history/input-events-2/
commit 履歴
	https://github.com/w3c/input-events/commits/
編集
	<a href="mailto:johannes@fiduswriter.org">Johannes Wilm</a> (Invited Expert)
前任編集者
	<a href="mailto:BenjamP@microsoft.com">Ben Peters</a> (Microsoft) (until 23 February 2015)
フィードバック
	<a href="https://github.com/w3c/input-events/">GitHub w3c/input-events</a> (<a href="https://github.com/w3c/input-events/pulls/">pull requests</a>, <a href="https://github.com/w3c/input-events/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/input-events/issues/">open issues</a>)
テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/input-events
実装報告
	https://w3c.github.io/test-results/input-events/
Mailing list
	https://lists.w3.org/Archives/Public/public-editing-tf
公表者
	<a href="https://www.w3.org/groups/wg/webediting">Web Editing WG</a>
</script>

</head>
<body>

<header>
	<hgroup>
<h1>入力イベント — Input Events Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、［
~textおよび関係する入力~用の~eventに対する追加
］を定義することにより，［
~textの入力と整形について~~扱う~text~editorその他の~app
］の文脈において［
~browserの既定の挙動を監視して操作する
］ことを許容する。
この仕様は、
`UI-EVENTS$r の上に築かれる。
◎
This specification defines additions to events for text and related input to allow for the monitoring and manipulation of default browser behavior in the context of text editor applications and other applications that deal with text input and text formatting. This specification builds on the UI events spec [UI-EVENTS].
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
<em>この節では、公表~時点における…</em>
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

<p>
この~level 2 は、
最初の~version `INPUT-EVENTS$r を置換することに加え，次を含む：
◎
Input Events Level 2 replaces the first version of Input Events [INPUT-EVENTS] and includes:
</p>
<ul>
	<li>
 `beforeinput$et 用の［
~IME組成の開始と終了に対応する各種~入力~型~event
］により［
~IME組成~処理nを他から隔離する
］ことを許容する。
◎
Inputtypes for beforeinput events for the start and end of IME compositions that allow isolation of the IME composition process.
</li>
	<li>
~IME組成~処理nの中から発されたものは別として、
すべての `beforeinput$et ~eventに対する取消~可否に関するさらなる要件。
◎
More requirements for cancelability of beforeinput events, so that all beforeinput events apart from those being emited within an IME composition process are cancelable.
</li>
</ul>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
この文書は、
`UI-EVENTS$r にて述べられれた 2 つの~event
— `input$et, `beforeinput$et `UI-EVENTS$r —
に対する［
編集に関係する追加
］を述べる。
これらの~eventの目標は、
次を許容することにある
⇒
編集-時の既定の挙動を
— 編集が生じる前と後の両者について —
作者が理解して上書きする
◎
This document describes editing related additions to 2 events - input and beforeinput which are described in the UI events spec [UI-EVENTS]. The goal of these events is to allow authors to understand and/or override default edit behavior both before and after editing occurs.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
この節の内容は
`~W3C日本語訳 共通~page＠~W3Ccommon#conformance$に移譲。
】</p>

	</section>
	<section id="definitions">
<h2 title="Definitions">3. 定義</h2>

<dl>
	<dt>
`意図nを表出する@
（ `express an intention^en ）
◎
express intention
</dt>
	<dd>
利用者は、［
~keyboard, ~IME, ~speech
］などに類する~methodにより［
特定の~編集中の~演算を実行する意図n
］を表出できる。
特定の~入力~動作は、［
~platformに特有な規約に従う意図n
］に対応付けられる。
◎
A user can express an intention to execute a specific editing operation by means of keyboard, IME, speech, or similar method. Specific input actions are mapped to intentions following platform-specific conventions.
</dd>

	<dt>
`~kill-buffer@
（ `kill buffer^en ）
◎
kill buffer
</dt>
	<dd>
この定義は規範的ではない。
◎
This definition is not normative.
</dd>
	<dd>
`~kill-buffer$は、［
~clipboardとは別々な，~memory内に格納された~richtext内容
］である
— それは、［
特定の削除~commandを利用して削除された内容を一時的に保持する
］ことを許容する。
利用者は、［
~kill-bufferを引き出す（ `yank^en する）意図nを指示する
］ことにより，現在の選択を~kill-bufferの内容で置換できる。
◎
A kill buffer is a in-memory store of richtext content that is separate from the clipboard which allows for the temporal storage of content that was deleted using specific deletion commands. The user can replace the current selection with the content held in the kill buffer by indicating an intention to yank the kill buffer.
</dd>

	<dt>
`内容編集可能@
な要素（ `contenteditable^en ）
</dt>
	<dd>
`contenteditable$a 内容~属性に基づいて，利用者が内容を編集できるとされる要素。
</dd>
	<dd class="trans-note">【
この用語
— 原文では、
単に［
“contenteditable 要素” あるいは “`contenteditable^c 要素”
］ —
は、
訳者による追加であり，その定義も訳者の推定による
（なので，いくぶん曖昧な句 “編集できる” で表現しているが、
より厳密には
“`isContentEditable＠~HTMLinteraction#dom-iscontenteditable$m ~IDL属性が ~T を返す要素”
のような定義が意図されているかもしれない）。
】</dd>
</dl>

	</section>
	<section id="problems-solved">
<h2 title="Problems solved">4. ~~解決される問題</h2>

◎非規範的

<p>
~browser~codeの上層に ~webに基づく~text~editorを作成するためには、
他にも相当量の~JSを要する
— なぜなら：
◎
Creating a webbased texteditor requires a considerable amount of JavaScript on top of the browser code, among other things because:
</p>

<ul>
	<li>
すべての~browserが編集~演算を同じ仕方で取扱うわけではない。
◎
Browsers do not handle all editing operations the same way.
</li>
	<li>
編集~演算によっては、
~browserによる取扱いに~bugが多い。
◎
Browsers are often buggy in the way they handle certain editing operations.
</li>
	<li>
編集~演算によっては、
個々の~siteごとに，その取扱いに~custom選好があり得る。
◎
Individual sites may have custom preferences for how they want to handle certain editing operations.
</li>
	<li>
~browserにおける［
高~levelな~text編集~特能
］の開発は、
`Extensible Web Manifesto＠https://extensiblewebmanifesto.org/$cite
に画策された原則に従っていない
— これらの特能の開発は、
~web開発者~communityの必要性と常に協調しているわけではない。
◎
The development of high-level text editing features in browsers has not followed the principles laid out in the Extensible Web Manifesto in that development of these features has not always been in coordination with the needs of the web developer community.
</li>
</ul>

<div class="p">
<p>
この仕様は、［
次の両者について，~web開発者にとって単純な仕方を供する
］ことにより，問題の~~緩和を探求する：
</p>
<ul>
	<li>
［
~text編集に関係する すべての利用者~入力
］に対する~browserによる取扱いを `beforeinput$et ~eventを通して上書きする。
</li>
	<li>
［
利用者~入力に因り，~DOM内の何が変更されたか
］を `input$et ~eventを通して監視する。
</li>
</ul>

◎
This spec seeks to alleviate the problem by providing a simple way for web developers to both override browser handling of all user input related to text editing through the beforeinput event, and to monitor what browsers have changed in the DOM due to user input through the input event.
</div>
	</section>
	<section id="use-cases">
<h2 title="Use cases">5. 利用事例</h2>

◎非規範的

<p>
次を可能にする~JS~text~editorを作成する：
◎
↓</p>
<ol>
	<li>
利用者が~boldとして~markした~textを［
`&lt;b&gt;^e ~tagに代えて `&lt;strong&gt;^e ~tag
］を利用して~markする
— ~browserに組込みの［
~textを~boldとして~markするような仕方【？】
］を利用して，
および既存の~browserすべてに~accessする必要なく【？】。
◎
Creating a JavaScript text editor in which the &lt;strong&gt;-tag is used instead of the &lt;b&gt;-tag to mark text that the user marks as bold, using any browser-builtin way to mark a text as bold, without having access to all existing browsers.
</li>
	<li>
背後の~data~modelに対し作業して，~JSが［
編集により変化した~textを~DOM内に具現化すること
］を~careする。
◎
Creating a JavaScript text editor which works with a data model in the background where JavaScript takes care of rendering changes to the edited text to the DOM.
</li>
	<li>
~richtext編集を一部に限り許容する
（例えば、
~boldは許容するが，~italicは許容しない）。
◎
Creating a JavaScript editor which only allows a subset of richtext editing (for example: bold is allowed, but italic not).
</li>
	<li>
共同作業可能である
— ［
特定の意図nを様々な仕方で表出している，様々な~browser
］を利用している各~利用者の意図nに基づいて，
~JSを利用して変更を~DOM内に具現化するような。
◎
Creating a collaborative editor in which JavaScript is used to render changes to the DOM, based on user intentions with users using different browsers with different ways of expressing specific intentions.
</li>
	<li>
利用者~accessに関して，様々な~optionを備える
— 例えば、
ある利用者に可能なのは，~textを追加したり削除することに限られ、
別の利用者に可能なのは，ある種の整形を追加したり除去することに限られる，など。
◎
Creating a JavaScript editor with different user access options, where some users only can add or delete text and other users only can add or remove certain types of formatting.
</li>
</ol>
	</section>
	<section id="events-inputevents">
<h2 title="Input Event Types">6. 入力~event型</h2>

<p>
入力~eventは、
利用者が~markupを編集するよう試みる前（ `beforeinput$et ~event ）と試みた後（ `input$et ~event）に送信される。
これには、
内容の［
挿入や削除／整形の変更
］も含まれる。
◎
Input events are sent before (beforeinput event) and after (input event) a user attempts to edit the markup. This includes insertion and deletion of content, and formatting changes.
</p>

<p>
入力~eventは、
`編集中の~host$として動作する要素に向けて`配送-$される。
そのような要素には、
次が挙げられる
⇒＃
`contenteditable$a 属性が設定されているもの,
`textarea$e 要素,
~text入力を許容する `input$e 要素
◎
Input events are dispatched on elements that act as editing hosts, including elements with the contenteditable attribute set, textarea elements, and input elements that permit text input.
</p>

		<section id="interface-InputEvent">
<h3 title="Interface InputEvent">6.1. ~interface `InputEvent^I</h3>

<pre class="idl">
partial interface `InputEvent$I {
    readonly attribute `DataTransfer$I? `dataTransfer$m;
    sequence&lt;`StaticRange$I&gt; `getTargetRanges()$m;
};

partial dictionary `InputEventInit$I {
    `DataTransfer$I? `dataTransfer$mb = null;
    sequence&lt;`StaticRange$I&gt; `targetRanges$mb = [];
};
</pre>

<p>
`InputEventInit$I の［
`inputType$mb,
`dataTransfer@mb,
`targetRanges@mb
］~memberは、
`InputEvent$I ~objの対応する属性を初期化する。
◎
The attributes inputType, dataTransfer and targetRanges of InputEventInit initialize the corresponding attributes of the InputEvent object.
</p>

			<section id="overview">
<h4 title="Overview">6.1.1. 概観</h4>

◎非規範的

<p>
次の表tに，［
`data$m 属性や `dataTransfer$m 属性が返す値／
`getTargetRanges()$m ~methodが返す~Array
］が［
`編集中の~host$, `inputType$m
］に基づいて いつ［
~NULL ／ 空
］になるかを要約する。
◎
The following table provides a summary of when the data and dataTransfer attributes contain contents and when they are null as well as when the getTargetRanges() method returns an empty or non-empty Array, based on the inputType.
</p>

<table class="grid-table" id="_attr-overview">

<caption>
1 列目に現れる “~text入力” は、［
`textarea$e 要素／
`Text$st 状態にある `input$e 要素
］の総称を表す。
</caption>
<thead>
<tr><th>`編集中の~host$
<th>`inputType$m
<th>`data$m
<th>`dataTransfer$m
<th>`getTargetRanges()$m
<tbody id="_inputType-overview">

<tr><td>`内容編集可能$
<td>`insertText^l,
`insertCompositionText^l,
`formatSetBlockTextDirection^l,
`formatSetInlineTextDirection^l,
`formatBackColor^l,
`formatFontColor^l,
`formatFontName^l,
`insertLink^l
<td>非~NULL
<td>~NULL
<td>空でない

<tr><td>`内容編集可能$
<td>`insertFromPaste^l,
`insertFromPasteAsQuotation^l,
`insertFromDrop^l,
`insertReplacementText^l,
`insertFromYank^l
<td>~NULL
<td>非~NULL
<td>空でない

<tr><td>~text入力
<td>`insertText^l,
`insertCompositionText^l,
`insertFromPaste^l,
`insertFromPasteAsQuotation^l,
`insertFromDrop^l,
`insertReplacementText^l,
`insertFromYank^l,
`formatSetBlockTextDirection^l,
`formatSetInlineTextDirection^l,
`formatBackColor^l,
`formatFontColor^l,
`formatFontName^l,
`insertLink^l
<td>非~NULL
<td>~NULL
<td>空

<tr><td>すべて
<td>`historyUndo^l,
`historyRedo^l
<td>~NULL
<td>~NULL
<td>空

<tr><td>`内容編集可能$
<td>残りすべて
<td>~NULL
<td>~NULL
<td>空でない

<tr><td>~text入力
<td>残りすべて
<td>~NULL
<td>~NULL
<td>空
</table>

<!-- 
Editing host｜inputType｜data｜dataTransfer｜getTargetRanges()
Contenteditable｜"insertText", "insertCompositionText", "formatSetBlockTextDirection", "formatSetInlineTextDirection", "formatBackColor", "formatFontColor", "formatFontName", "insertLink"｜Yes｜null｜Non-empty Array
Contenteditable｜"insertFromPaste", "insertFromPasteAsQuotation", "insertFromDrop", "insertReplacementText", "insertFromYank"｜null｜Yes｜Non-empty Array
<textarea>, <input type="text">｜"insertText", "insertCompositionText", "insertFromPaste", "insertFromPasteAsQuotation", "insertFromDrop", "insertReplacementText", "insertFromYank", "formatSetBlockTextDirection", "formatSetInlineTextDirection", "formatBackColor", "formatFontColor", "formatFontName", "insertLink"｜Yes｜null｜Empty Array
All｜"historyUndo", "historyRedo"｜null｜null｜Empty Array
Contenteditable｜All Remaining｜null｜null｜Non-empty Array
<textarea>, <input type="text">｜All Remaining｜null｜null｜Empty Array

-->

			</section>
			<section id="interface-InputEvent-Attributes">
<h4 title="Attributes">6.1.2. 各種 属性</h4>

<p>
`~UA$は、
~eventの初期化-時に，
次に挙げる属性を以下に従って拡充するモノトスル：
◎
↓</p>

<dl>
	<dt>`inputType@m</dt>
	<dd class="trans-note">【
この属性は `UI-EVENTS$r にて`定義される＠~UIEVENTS#dom-inputevent-inputtype$。
】</dd>
	<dd>
`beforeinput$et ~eventの取消~可否は，下に与える `inputType$m 値に依存する
— 値が `insertCompositionText^l に初期化される場合は、
取消せない（ `cancelable$m は ~F になる）。
◎
The cancelability of the beforeinput event depends on the inputType.
</dd>
	<dd>
<p>
この属性は、
次の表tの 2, 3, 4 列目に与える［
利用者が`表出した意図n$,
~IME組成の間に編集が生じるかどうか,
選択の状態
］に応じて，表tの 1 列目に与える値に初期化するモノトスル：
◎
The inputType to be picked depends on the user's expression of intention, whether or not the editing takes place during an IME composition and the state of the selection.
◎
This specification defines the inputType values as the values in the inputType column of the following table.
</p>

<p class="trans-note">【
原文の表tには `beforeinput$et ~eventの取消~可否の列もあるが、
この訳ではその列を省略して，上の記述に集約している。
】</p>

<table class="grid-table" id="_inputTypes">
<caption>
<p>
編集？ 列における［
空欄 ／ `あり^i
］は、
~IME組成の間に編集は［
生じない／生じる
］ことを表す。
</p>

<p>
選択~状態 列における［
`畳^i ／ `非畳^i 
］は、
選択は［
畳まれている／畳まれていない
］ことを表す。
空欄は、
選択~状態を問わないことを表す。
</p>
</caption>
<thead>
<tr><th>`inputType$m
<th>利用者が`表出した意図n$
◎
User's expression of intention
<th>編集？
◎
Part of IME composition
<th>選択~状態
◎
State of selection
<tbody>

<tr><td>`insertText^l
<td>
打込まれた素な~textを挿入する
◎
insert typed plain text
<td>
<td>

<tr><td>`insertReplacementText^l
<td>
［
~spell-checker, 自動訂正, 書法の示唆
］などに類する~methodにより，既存の内容［
に何かを挿入する／を置換する
］
◎
insert or replace existing content by means of a spell checker, auto-correct, writing suggestions or similar
<td>
<td>

<tr><td>`insertLineBreak^l
<td>
改行を挿入する
◎
insert a line break
<td>
<td>

<tr><td>`insertParagraph^l
<td>
段落~分断を挿入する
◎
insert a paragraph break
<td>
<td>

<tr><td>`insertOrderedList^l
<td>
番号付き~listを挿入する
◎
insert a numbered list
<td>
<td>

<tr><td>`insertUnorderedList^l
<td>
番号無し~listを挿入する
◎
insert a bulleted list
<td>
<td>

<tr><td>`insertHorizontalRule^l
<td>
水平罫線を挿入する
◎
insert a horizontal rule
<td>
<td>

<tr><td>`insertFromYank^l
<td>
`~kill-buffer$に格納されている内容で，現在の選択を置換する
◎
replace the current selection with content stored in a kill buffer
<td>
<td>

<tr><td>`insertFromDrop^l
<td>
~dropにより，内容を挿入する
◎
insert content by means of drop
<td>
<td>

<tr><td>`insertFromPaste^l
<td>
~clipboardから内容を~pasteする／
~clientが供した画像~libraryから画像を~pasteする
◎
paste content from clipboard or paste image from client provided image library
<td>
<td>

<tr><td>`insertFromPasteAsQuotation^l
<td>
~clipboardから内容を引用文として~pasteする
◎
paste content from the clipboard as a quotation
<td>
<td>

<tr><td>`insertTranspose^l
<td>
手入力された最後の 2 個の`書記素~cluster$を入替える
◎
transpose the last two grapheme cluster. that were entered
<td>
<td>

<tr><td>`insertCompositionText^l
<td>
現在の組成~文字列を置換する
◎
replace the current composition string
<td>`あり^i
<td>

<tr><td>`insertLink^l
<td>
~linkを挿入する
◎
insert a link
<td>
<td>

<tr><td>`deleteWordBackward^l
<td>
~caret位置の直前にある単語を削除する
◎
delete a word directly before the caret position
<td>
<td>`畳^i

<tr><td>`deleteWordForward^l
<td>
~caret位置の直後にある単語を削除する
◎
delete a word directly after the caret position
<td>
<td>`畳^i

<tr><td>`deleteSoftLineBackward^l
<td>
~caret位置からその前にある最も近い視覚的な改行までを削除する
◎
delete from the caret to the nearest visual line break before the caret position
<td>
<td>`畳^i

<tr><td>`deleteSoftLineForward^l
<td>
~caret位置からその後にある最も近い視覚的な改行までを削除する
◎
delete from the caret to the nearest visual line break after the caret position
<td>
<td>`畳^i

<tr><td>`deleteEntireSoftLine^l
<td>
［
~caret位置の前にある最も近い視覚的な改行
］から［
~caret位置の後にある最も近い視覚的な改行
］までを削除する
◎
delete from the nearest visual line break before the caret position to the nearest visual line break after the caret position
<td>
<td>`畳^i

<tr><td>`deleteHardLineBackward^l
<td>
~caret位置からその前にある最も近い［
塊~要素または `br$e 要素
］の始まりまでを削除する
◎
delete from the caret to the nearest beginning of a block element or br element before the caret position
<td>
<td>`畳^i

<tr><td>`deleteHardLineForward^l
<td>
~caret位置からその後にある最も近い［
塊~要素または `br$e 要素
］の終わりまでを削除する
◎
delete from the caret to the nearest end of a block element or br element after the caret position
<td>
<td>`畳^i

<tr><td>`deleteByDrag^l
<td>
~dragにより，~DOMから内容を除去する
◎
remove content from the DOM by means of drag
<td>
<td>

<tr><td>`deleteByCut^l
<td>
~cutの一部として，現在の選択を除去する
◎
remove the current selection as part of a cut
<td>
<td>

<tr><td>`deleteContent^l
<td>
他の `inputType$m 値に該当しない意図nの下で、
削除の方向を指定せずに，選択を削除する
◎
delete the selection without specifying the direction of the deletion and this intention is not covered by another inputType
<td>
<td>`非畳^i

<tr><td>`deleteContentBackward^l
<td>
次のいずれか：
<ul ><li>他の `inputType$m 値に該当しない意図nの下で、
~caret位置の直前にある内容を削除する
</li><li>選択を，削除~後にその始端に畳まれるように削除する
</li></ul>
◎
delete the content directly before the caret position and this intention is not covered by another inputType or delete the selection with the selection collapsing to its start after the deletion
<td>
<td>

<tr><td>`deleteContentForward^l
<td>
次のいずれか：
<ul ><li>他の `inputType$m 値に該当しない意図nの下で、
~caret位置の直後にある内容を削除する
</li><li>選択を，削除~後にその終端に畳まれるように削除する
</li></ul>

◎
delete the content directly after the caret position and this intention is not covered by another inputType or delete the selection with the selection collapsing to its end after the deletion
<td>
<td>

<tr><td>`historyUndo^l
<td>
最後の編集~動作を~undoする
◎
undo the last editing action
<td>
<td>

<tr><td>`historyRedo^l
<td>
最後の~undone編集~動作を~redoする
◎
to redo the last undone editing action
<td>
<td>

<tr><td>`formatBold^l
<td>
~bold~textを起する
◎
initiate bold text
<td>
<td>

<tr><td>`formatItalic^l
<td>
~italic~textを起する
◎
initiate italic text
<td>
<td>

<tr><td>`formatUnderline^l
<td>
~underline~textを起する
◎
initiate underline text
<td>
<td>

<tr><td>`formatStrikeThrough^l
<td>
~stricken~textを起する
◎
initiate stricken through text
<td>
<td>

<tr><td>`formatSuperscript^l
<td>
~superscript~textを起する
◎
initiate superscript text
<td>
<td>

<tr><td>`formatSubscript^l
<td>
~subscript~textを起する
◎
initiate subscript text
<td>
<td>

<tr><td>`formatJustifyFull^l
<td>
現在の選択を両端揃えにする
◎
make the current selection fully justified
<td>
<td>

<tr><td>`formatJustifyCenter^l
<td>
現在の選択を中央に寄せる
◎
center align the current selection
<td>
<td>

<tr><td>`formatJustifyRight^l
<td>
現在の選択を右端に寄せる
◎
right align the current selection
<td>
<td>

<tr><td>`formatJustifyLeft^l
<td>
現在の選択を左端に寄せる
◎
left align the current selection
<td>
<td>

<tr><td>`formatIndent^l
<td>
現在の選択の字下げを増やす
◎
indent the current selection
<td>
<td>

<tr><td>`formatOutdent^l
<td>
現在の選択の字下げを減らす
◎
outdent the current selection
<td>
<td>

<tr><td>`formatRemove^l
<td>
現在の選択からすべての整形情報を除去する
◎
remove all formatting from the current selection
<td>
<td>

<tr><td>`formatSetBlockTextDirection^l
<td>
~text塊~方向を設定する
◎
set the text block direction
<td>
<td>

<tr><td>`formatSetInlineTextDirection^l
<td>
~text行内~方向を設定する
◎
set the text inline direction
<td>
<td>

<tr><td>`formatBackColor^l
<td>
背景~色を変更する
◎
change the background color
<td>
<td>

<tr><td>`formatFontColor^l
<td>
~font色を変更する
◎
change the font color
<td>
<td>

<tr><td>`formatFontName^l
<td>
`font-family^p を変更する
◎
change the font-family
<td>
<td>
</table>

	</dd>
	<dd class="note">注記：
他の仕様は、
この定義を拡げてもヨイ。
◎
Note
◎
Other specifications may expand on this definition.
	</dd>
	<dd class="note">注記：
実装は、
上に挙げられた `inputType$m 値~すべてを~supportするとは限らない。
~UA【！所与の~browser】は［
~DOMを変化させ得る，ある編集~演算
］を~supportする場合には、
対応する［
`beforeinput$et, `input$et
］~eventを`配送-$するモノトスル。
◎
Note
◎
The existence of the above mentioned inputTypes does not mean that any given implementation will support all of these. But if a given browser supports an editing operation which potentially leads to a change of the DOM, it MUST dispatch the corresponding beforeinput and input events.
</dd>
	<dd class="note">注記：
選択が畳まれている場合、
次のいずれにも `deleteContentBackward^l が利用される：
利用者が［
~text~nodeの中で~textを削除する ／
より複階的な要素を削除する ／
~caretが~text~nodeの始端にある場合に 段落を併合する
］意図nを示したとき。
同じ文言は `deleteContentBackward^l にも該当する
— その~~記述の “始端” を “終端” に読み替える下で。
◎
Note
◎
If the selection is collapsed, "deleteContentBackward" will be used both when the user asks for text deletion within a text node, and when the user shows the intention to deletion of more complex elements or merge paragraphs if the caret is at the start of a text node.
◎
Note
◎
If the selection is collapsed, "deleteContentForward" will be used both when the user asks for text deletion within a text node, and when the user shows the intention to deletion of more complex elements or merge paragraphs if the caret is at the end of a text node.
</dd>

	<dt id="dfn-data">`data$m</dt>
	<dd>
<p>
この属性は、
文書に追加されるものに関係する~plaintext~data情報を保持する。
次の表tの 1, 2 列目に与える ［
`inputType$m の値, `編集中の~host$
］に応じて，表tの 3 列目に与える値になる：
◎
data holds information plaintext data related to what is to be added to the document.
</p>

<table><thead>
<tr><th>`inputType$m
<td>`編集中の~host$
<td>`data$m
<tbody id="_data-attr-values">

<tr><td>`insertText^l,
`insertCompositionText^l
<td>任意
<td>
挿入されようとしている~text文字列
◎
the plain text string to be inserted

<tr><td>`insertFromPaste^l,
`insertFromPasteAsQuotation^l,
`insertFromDrop^l,
`insertTranspose^l,
`insertReplacementText^l,
`insertFromYank^l
<td>`input$e ／ `textarea$e
<td>挿入されようとしている~text文字列
◎
the plain text string to be inserted

<tr><td>`formatSetInlineTextDirection^l,
`formatSetBlockTextDirection^l
<td>任意
<td>次のいずれか
⇒
`ltr^l ／
`rtl^l ／
`auto^l ／
`null^l

<tr><td>`formatBackColor^l,
`formatFontColor^l
<td>任意
<td>次の結果の文字列
⇒
`~CSS成分~値を直列化する$( 提された色 )
`CSSOM$r
◎
a string containing a serialized CSS component value [CSSOM] of the proposed color

<tr><td>`formatFontName^l
<td>任意
<td>
`font-family^p ~prop値として提された値
◎
the proposed value of the font-family CSS property

<tr><td>`insertLink^l
<td>任意
<td>
~linkを与える~URLとして提された値
◎
the url of the proposed link

<tr><td>その他
◎
All remaining
<td>任意
<td>~NULL
</table>

	</dd>

	<dt>`dataTransfer@m</dt>
	<dd>
［
文書から取り出される／文書に追加される
］ような，関連な［
~richtextや~plaintext
］の~dataがあれば、
その情報を
`DataTransfer$I ~obj `HTML$r
内に保持する。
◎
dataTransfer holds information about richtext and plaintext data that is to be taken from or added to the document in a DataTransfer object if there is relevant data.
</dd>
	<dd>
<div>
<p>
［
~AND↓ が満たされるならば，
下に与える `DataTransfer$I ~obj／
~ELSE_ ~NULL
］で拡充される：
</p>
		<ul>
			<li>
`編集中の~host$は`内容編集可能$である
</li>
			<li>
`inputType$m ~IN {
`insertFromPaste^l,
`insertFromPasteAsQuotation^l,
`insertFromDrop^l,
`insertTranspose^l,
`insertReplacementText^l,
`insertFromYank^l
}
</li>
		</ul>

◎
inputType ｜ Editing host ｜ dataTransfer
◎
"insertFromPaste", "insertFromPasteAsQuotation", "insertFromDrop", "insertTranspose", "insertReplacementText" or "insertFromYank" ｜ contenteditable ｜ A prepopulated DataTransfer object so that:
</div>

<p>
`DataTransfer$I ~objの場合、
その`~drag~data~store$は， `読専~mode$i になり、
その`~item~list$ddSは，
追加される内容に応じて 次に挙げるものからなる `HTML$r ：
◎
The DataTransfer object's drag data store is in read-only mode. [HTML]＼
</p>
		<ul>
			<li>
~fileである場合
⇒
次のように設定された~item
⇒＃
`型~文字列$dI ~SET 当の~fileの`~MIME型$
`種類$dI ~SET `File^i
`実際の~data$dI ~SET 当の~fileに対応する `File$I ~obj【の`~byte列~data$】
◎
If the pasted content is a file, the DataTransfer object's drag data store item list contains one entry with the drag data item type string being the file's mime type, whose kind is File, and whose data is a File object corresponding to the pasted file. [HTML]
</li>
			<li>
<p>
~textである場合
⇒
次のように設定された 2 個の~item
⇒＃
1 個目の~itemの`実際の~data$dI ~SET 追加される内容の~HTML~表現,
2 個目の~itemの`実際の~data$dI ~SET 追加される内容の素な~text表現,
どちらも，その`型~文字列$dI ~SET `text/html^l,
どちらも，その`種類$dI ~SET `Text^i【！ “Plain Unicode string” から改称された】
</p>
<p>
追加される内容としては、
例えば，次が挙げられる
⇒＃
~clipboard内にあるもの ／
`~kill-buffer$内にあるもの ／
~pasteされたもの ／
~dropされたもの
</p>

◎
The DataTransfer object's drag data store item list contains one entry with the drag data item type string "text/html", whose kind is Plain Unicode string, and whose data is a HTML representation of the content that is in the clipboard, or in the kill buffer, to be dropped or otherwise the content that is to be added. [HTML]
◎
The DataTransfer object's drag data store item list contains one entry with the drag data item type string "text/plain", whose kind is Plain Unicode string, and whose data is a plain text representation of the content that is to be pasted, dropped or otherwise added. [HTML]
</li>
			<li>
~linkである場合
⇒
次のように設定された 1 個の~item
⇒＃
`型~文字列$dI ~SET `text/uri-list^l
`種類$dI ~SET `Text^i
`実際の~data$dI ~SET 当の~linkを表現する素な~text
◎
If the content to be pasted is a link, the DataTransfer object's drag data store item list contains one entry with the drag data item type string "text/uri-list", whose kind is Plain Unicode string, and whose data is a plain text representation of the link that is dropped or otherwise added. [HTML]
◎
↑↑All remaining ｜ Any ｜ null
</li>
		</ul>
<p class="trans-note">【
例えば，複数個の~fileが~pasteされる場合、
`~item~list$ddSは複数個の~itemを含むことになると思われるが、
原文の記述（および~markup）からは，はっきりしない。
（例：~fileと~textの組合nなどもあり得るのか？）
】</p>
	</dd>
</dl>

			</section>
			<section id="interface-InputEvent-Methods">
<h4>6.1.3. ~method</h4>

<dl class="idl-def">
	<dt>`getTargetRanges()@m</dt>
	<dd>
当の`編集中の~host$は［
`内容編集可能$な~node ／
`~EditContextの編集中の~host$
］である場合には、［
~eventが取消されなかった場合に改変されることになる内容
］を表現している `StaticRange$I たちが成す~Arrayを返す
— 他の場合、
`none^en 【空な~Array】を返すことになる。
返される `StaticRange$I たちが受持つ`符号位置$は、
~browserが通常に置換することになるものに限るモノトスル
— それらが`書記素~cluster$の一部しか成さない場合でも。
◎
getTargetRanges() returns an array of StaticRanges representing the content that the event will modify if it is not canceled, if the editing host is contenteditable node or an EditContext editing host. Otherwise this method will return none. The returned StaticRanges MUST cover only the code points that the browser would normally replace, even if they are only part of a grapheme cluster.
</dd>
	<dd class="note">注記：
~scriptや~platformに依存して，
~text~node内を後方や前方へ削除したとき（選択は畳まれているとする）、
書記素~cluster全体に影響する場合も，
それを成す一部の符号位置たちに限り影響する場合もある。
例えば， “café” を包含している~text~node内で後方へ削除すると、
~scriptや~platformに依存して，
文字 “é” 全体を除去することもアクセント符（ `acute accent^en, "´" ）だけを除去することもある。
◎
Note

This note is not normative.
Depending on the script and the platform, deleting backward or forward in a text node with a collapsed selection may affect one or multiple code points or an entire grapheme cluster. For example, deleting backward in a text node containing “café” may remove either the acute accent or the entire “é” character, depending on the script and the platform.
</dd>
	<dd>
<p>
次のいずれかに該当する場合、
返される~Arrayは空になる：
</p>
		<ul>
			<li>
`inputType$m ~IN { `historyUndo^l, `historyRedo^l }
</li>
			<li>
`編集中の~host$は`内容編集可能$でない
</li>
		</ul>

◎
6.1.3 Methods
◎
inputType ｜ Editing host ｜ Response of getTargetRanges()
"historyUndo" or "historyRedo" ｜ Any ｜ empty Array
All remaining ｜ contenteditable ｜ an Array of StaticRanges [DOM] associated with event
All remaining ｜ input or textarea ｜ an empty Array
◎
returns , unless the inputType is "historyUndo" or "historyRedo" or the editing host is not a contenteditable element, in which case it returns an empty Array. 
</dd>
</dl>

			</section>
		</section>
		<section id="event-definitions">
<h3 title="Event definitions">6.2. 各種~eventの定義</h3>

◎イ型 `beforeinput@et
◎界面 `InputEvent$I
◎同期 あり
◎浮上 する
◎標的 `編集中の~host$である任意の要素
◎
Any Element that is an editing host.
◎既定動作

<p>
当の`編集中の~host$ %~host, この~eventの `inputType$m %型 に応じて：
◎
↓</p>
<ul>
	<li>
［
%~host の `contentEditable$m ~EQ `typing^l
］~AND［
%型 ~EQ `insertCompositionText^l
］ならば
⇒
“~DOMを更新する”
◎
For contentEditable=typing editing hosts for inputType "insertCompositionText": 'Update the DOM'.
</li>
	<li>
［
%~host の `contentEditable$m ~EQ `true^l
］ならば、
%型 を問わず
⇒
“~DOMを更新する”
◎
For contentEditable="true" editing hosts for all inputTypes: 'Update the DOM'.
</li>
	<li>
［
%~host は`~EditContextの編集中の~host$である
］~AND［
%型 は`~EditContextが取扱う入力~型＠~EDITCONTEXT#dfn-editcontext-handled-inputtype$である
］ならば
⇒
`~EditContext用の入力を取扱う＠~EDITCONTEXT#dfn-handle-input-for-editcontext$( %~host )
◎
For EditContext editing hosts for EditContext-handled inputTypes: Handle input for EditContext given the editing host element.
</li>
	<li>
他の場合
⇒
なし
◎
None otherwise.
</li>
</ul>

◎文脈

<dl>
	<dt>`data$m</dt>
	<dd>
要素に追加された~dataを包含している文字列。
適用されない場合は ~NULL になる。
◎
InputEvent.data: the string containing the data that was added to the element, which MAY be null if it doesn't apply.
</dd>

	<dt>`dataTransfer$m</dt>
	<dd>
要素［
に追加された／から削除された
］~richtextを包含している文字列。
適用されない場合は ~NULL になる。
◎
InputEvent.dataTransfer: richtext data added or removed from element, which MAY be null if it doesn't apply.
</dd>

	<dt>`getTargetRanges()$m</dt>
	<dd>
取消されなかった場合に、
~DOMに対する変更により影響されることになる `StaticRange$I たちが成す配列を返す。
◎
InputEvent.getTargetRanges(): returns an array of StaticRanges which will be affected by the change to the DOM if it is not canceled.
</dd>
</dl>

◎表終

<p>
`~UA$は、
利用者が`内容編集可能$な要素にて入力を試みたときに，この~eventを`配送-$するモノトスル。
これは、
`~UA$が~DOMを更新することを意味するとは限らない。
◎
A user agent MUST dispatch this event when the user has attempted to input in a contenteditable element. It does not necessarily mean the user agent will then update the DOM.
</p>

<p>
`~UA$は、
~system~eventなど，利用者により試みられた入力~以外に因る~eventに対しては、
この~eventを`配送-$しないモノトスル。
◎
A user agent MUST NOT dispatch this event due to events that are not caused by attempted user input, such as system events.
</p>

◎イ型 `input@et
◎界面 `InputEvent$I
◎同期 あり
◎浮上 する
◎標的 `内容編集可能$である任意の要素
◎
Any Element with contenteditable attribute enabled.
◎既定動作 なし
◎文脈

<dl>

	<dt>`data$m</dt>
	<dd>
要素に追加された~dataを包含している文字列。
適用されない場合は ~NULL になる。
◎
InputEvent.data: the string containing the data that was added to the element, which MAY be null if it doesn't apply.
</dd>

	<dt>`dataTransfer$m</dt>
	<dd>
要素［
に追加された／から削除された
］~richtextを包含している文字列。
適用されない場合は ~NULL になる。
◎
InputEvent.dataTransfer: richtext data added or removed from element, which MAY be null if it doesn't apply.
</dd>

</dl>

◎表終

<p>
`~UA$は、
次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
利用者が［
~browserが取扱った文書~内容
］を変更する意図nを表出したことに因り，~DOMを更新したならば、
その直後に，この~eventを`配送-$する。
◎
A user agent MUST dispatch this event immediately after the DOM has been updated due to user expressed intention to change the document contents which the browser has handled.＼
</li>
	<li>
<p>
［
次に挙げるいずれかにより，~DOMに対する変更を為さなかった場合
］には、
この~eventを`配送-$しない：
</p>
		<ul>
			<li>
当の`編集中の~host$は、
`~EditContextの編集中の~host$である
（それは、
自動的な~DOM変更を行わない）
</li>
			<li>
~DOM変更は必要ないものと結論した
</li>
		</ul>
◎
If the browser makes no DOM change, either because the editing host is an EditContext editing host (which does not do automatic DOM changes) or because the user agent concludes that no DOM change is needed, the user agent MUST NOT dispatch this event.
</li>
</ul>

		</section>
	</section>
	<section id="input-event-order-during-composition">
<h2 title="Input Event Order During Composition">7. ~IME組成の間における入力~event順序</h2>

<p class="trans-note">【
この節に利用される［
組成~session（ `composition session^en ）,
`~text組成~system$（ `text composition system^en ）,
作動中な~text一節（ `active text passage^en ）,
~target範囲（ `target range^en ）
］は、
用語として~mark-upされているが，それらの定義を指す参照は与えられていない。
】</p>

<p>
組成~session【！組成】
【 `UI-EVENTS$r `§ 組成~event＠~UIEVENTS#events-compositionevents$】
の開始~時には、
`compositionstart$et ~eventが配送される。
◎
The start of a composition is marked by dispatching a compositionstart event.
</p>

<p>
組成~sessionの間，
~text組成~systemが作動中な~text一節
【~IMEにより編集されている~text】
を更新するときは、
`compositionupdate$et ~eventが配送される。
◎
During a composition session, whenever a text composition system updates its active text passage, a compositionupdate event is dispatched.
</p>

<p>
各 `compositionupdate$et ~eventの後には、
順に，［
`beforeinput$et, `input$et
］~eventが配送される
— どちらの~eventも：
◎
After each compositionupdate event, a pair of beforeinput and input events are dispatched. The beforeinput and input events:
</p>
<ul>
	<li>
取消-可能でない
◎
Are not cancellable
</li>
	<li>
`inputType$m は `insertCompositionText^l に設定される
◎
Have an inputType set to "insertCompositionText"
</li>
	<li>
`data$m 属性は、
`compositionupdate^et ~eventのそれに等しい。
◎
Have a data attribute equal to that of the compositionupdate event
</li>
	<li>
組成にて作動中な~text一節を囲む~target範囲を伴う
【おそらく， `getTargetRanges()$m の結果を与えるための。】
◎
Have a target range that surrounds the active text passage of the composition
</li>
</ul>

<p>
作動中な~text一節の~DOM内容が更新されるのは、
`beforeinput$et ~eventが配送された後, かつ
`input$et ~eventが配送される前になる。
◎
The DOM contents of the active text passage are updated after the beforeinput event is dispatched and before the input event is dispatched.
</p>

<p>
組成~sessionの終了~時には、
`compositionend^et ~eventが配送される。
◎
The end of a composition session is marked by dispatching a compositionend event.
</p>

	</section>
	<section id="event-order-when-using-insertfrompaste">
<h2 title="Event order when using insertFromPaste">8. `insertFromPaste^l を 利用しているときの~event順序</h2>

<p>
`insertFromPaste^l による `beforeinput$et ~eventを配送するときは、
その前に `paste$et ~event `CLIPBOARD-APIS$r を配送するモノトスル。
◎
When an "insertFromPaste" beforeinput event is dispatched, it MUST be preceded by a paste [CLIPBOARD-APIS] event.
</p>

	</section>
	<section id="privacy-and-security-considerations">
<h2 title="Privacy and security considerations">~security／~privacyの考慮点</h2>

◎非規範的

<p>
既存の~event
— `keydown$et や `keypress$et `UI-EVENTS$r など —
を通して すでに可用な指紋収集~技法 `fingerprinting-guidance$r を超えるような、
この特能による［
~security／~privacy
］に対する影響iとして既知なものは無い。
◎
There are no known security or privacy impacts of this feature beyond fingerprinting [fingerprinting-guidance] techniques that already are available through existing events, such as the keydown and keypress [UI-EVENTS] events.
</p>

<p>
この特能が既存の~eventを置換したなら、
そのような指紋収集~技法を衰退へ至らせ得る
— この特能は、
利用者が`表出した意図n$を記録するが，
そのために利用された特定0の~hardware種別は記録しないので。
◎
If this feature replaces existing events, it MAY lead to a decline in available fingerprinting [fingerprinting-guidance] techniques, as users' intentions are recorded, and not the particular type of hardware they used to express this intention.
</p>

	</section>
</main></div>

	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
次の方々に：
</p>

<div lang="en">
Thanks to:

Michael Aufreiter,
Adrian Bateman,
Oliver Buchtala,
Robin Berjon,
Enrica Casucci,
Bo Cupp,
Domenic Denicola,
Emil Eklund,
Olivier Forget,
Aryeh Gregor,
Marijn Haverbeke,
Yoshifumi Inoue,
Koji Ishii,
Gary Kacmarcik,
Ian Kilpatrick,
Frederico Caldeira Knabben,
Takayoshi Kochi,
Piotrek Koszuliński,
Travis Leithead,
Grisha Lyukshin,
Miles Maxfield,
Chaals McCathie Nevile,
Masayuki Nakano,
Ryosuke Niwa,
Julie Parent,
Ben Peters,
Florian Rivoal,
Morgan Smith,
Hallvord R. M. Steen,
Johan Sörlin,
Cristian Talau,
Dave Tapuska,
Ojan Vafai,
Léonie Watson,
Xiaoqian Wu,
Chong Zhang,
Joanmarie,

and everyone in the Editing Taskforce for their input and feedback.
</div>
	</section>
