<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>Generic Sensor API（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />


<style>
#_ex-lifecycle {
	text-align: center;
	width: 20em;
}
#_ex-lifecycle .ex-state {
	background: #EFE;
	border-radius: 0.3em;
	border: solid 1px rgb(80%,90%,80%);
	padding: 0.3em;
}

#_ex-lifecycle .ex-ends {
	border: dashed 1px silver;
	border-radius: 0.3em;
	color: gray;
}

#_ex-lifecycle .ex-transition {
}

@supports (display: grid) and (display: contents) {
	#sensor-slots {
		min-width: 32em;
		max-width: 60em;
	}
	#sensor-slots tr {
		grid-template-areas:
			"slot 値 初期"
			"slot 記述 記述"
		;
		grid-template-columns: 1fr 1fr 1fr;
	/*
	*/
	}
	
	#sensor-slots tr > *:nth-child(1) {
		grid-area: slot;
	}
	
	#sensor-slots tr > *:nth-child(2) {
		grid-area: 値;
	}
	
	#sensor-slots tr > *:nth-child(3) {
		grid-area: 初期;
	}
	
	#sensor-slots tr > *:nth-child(4) {
		grid-area: 記述;
	}
}

</style>

<style>
.ex-model {
	margin: 1em;
	white-space:nowrap;
	position: relative;
	line-height: 1.4em;
	height: 30em;
}

.ex-model-box {
	position: absolute;
	display: inline-block;
	padding: 0;
}

.ex-model-box > :first-child {
	border-bottom: solid black thin;
	padding: 0.2em;
}

.ex-model-bc {
	position: absolute;
	width:14em;
	height:13em;
	border: solid silver 1px;
	padding: 0.5em;
}

.ex-model li,
.ex-model ul {
	margin: 0;
	display: block;
	padding: 0;
}
.ex-model li::before {
	content: "•";
	padding: 0.2em;
}

.ex-model-line {
	position: absolute;
	display: block;
	border:dashed thin;
	border-color: gray gray transparent transparent;
	transform:scale(1, 1) rotate(45deg);
	transform-origin: center;
}

text {
	fill: white;
	stroke: none;
	font-size: 160px;
	font-family: sans-serif;
	text-anchor: middle;
	dominant-baseline: central;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		collectParts: Util.collectParts,
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'mc':
	text = 'Constructor';
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Generic Sensor API
spec_date:2019-03-19
trans_update:2019-08-22
source_checked:190319
spec_status:ED
original_url:https://w3c.github.io/sensors/
	abbr_url:SENSORS
ref_id_prefix:bib-
ref_id_lowercase:true
page_state_key:SENSORS
site_nav:sensors
ref_id_lowercase:true
copyright:2019,permissive
trans_1st_pub:2019-08-22
	conformance:w3c

●●class_map
E:error
et:event-type
sl:js-slot
e:element
a:attr
hm:method

●●tag_map
I:code
E:code
m:code
c:code
mc:code
mC:code
mb:code
cite:cite
et:code
sl:span
a:code
e:code
i:i
hm:code
em:em

●●original_id_map


●●link_map

	●IDL
I.Sensor:#sensor

SecureContext:~WEBIDL#SecureContext
Exposed:~WEBIDL#Exposed
boolean:~WEBIDL#idl-boolean
double:~WEBIDL#idl-double
DOMString:~WEBIDL#idl-DOMString

E.NotReadableError:~WEBIDL#notreadableerror
E.NotAllowedError:~WEBIDL#notallowederror
E.NotSupportedError:~WEBIDL#notsupportederror
I.DOMException:~WEBIDL#idl-DOMException

I.SensorErrorEvent:#sensorerrorevent
I.SensorErrorEventInit:#dictdef-sensorerroreventinit
I.SensorOptions:#dictdef-sensoroptions
I.MockSensorReadingValues:#dictdef-mocksensorreadingvalues
I.MockSensorType:#enumdef-mocksensortype
I.MockSensorConfiguration:#dictdef-mocksensorconfiguration
I.MockSensor:#dictdef-mocksensor

I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.EventHandler:~WAPI#eventhandler
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.PermissionDescriptor:~PERMISSIONS#dictdef-permissiondescriptor

I.AmbientLightSensor:~AMBIENT-LIGHT#ambient-light-sensor-interface
I.Accelerometer:~ACCELEROMETER#accelerometer-interface
I.LinearAccelerationSensor:~ACCELEROMETER#linearaccelerationsensor-interface
I.GravitySensor:~ACCELEROMETER#gravitysensor-interface
I.Gyroscope:~GYROSCOPE#gyroscope-interface
I.Magnetometer:~MAGNETOMETER#magnetometer-interface
I.UncalibratedMagnetometer:~MAGNETOMETER#uncalibrated-magnetometer-interface
I.AbsoluteOrientationSensor:~ORIENTATION-SENSOR#absoluteorientationsensor-interface
I.RelativeOrientationSensor:~ORIENTATION-SENSOR#relativeorientationsensor-interface
I.GeolocationSensor:~GEOLOCATION-SENSOR#geolocationsensor-interface
I.ProximitySensor:~PROXIMITY#proximity-sensor-interface

mc.SensorErrorEvent:#dom-sensorerrorevent-sensorerrorevent
m.activated:#dom-sensor-activated
m.hasReading:#dom-sensor-hasreading
m.timestamp:#dom-sensor-timestamp
m.start:#dom-sensor-start
m.stop:#dom-sensor-stop
m.onreading:#dom-sensor-onreading
m.onactivate:#dom-sensor-onactivate
m.onerror:#dom-sensor-onerror
m.frequency:#dom-sensoroptions-frequency

m.error:#dom-sensorerrorevent-error
mb.error:#dom-sensorerroreventinit-error

mC.connected:#dom-mocksensorconfiguration-connected
mC.mockSensorType:#dom-mocksensorconfiguration-mocksensortype
mC.maxSamplingFrequency:#dom-mocksensorconfiguration-maxsamplingfrequency
mC.minSamplingFrequency:#dom-mocksensorconfiguration-minsamplingfrequency

m.maxSamplingFrequency:#dom-mocksensor-maxsamplingfrequency
m.minSamplingFrequency:#dom-mocksensor-minsamplingfrequency
m.requestedSamplingFrequency:#dom-mocksensor-requestedsamplingfrequency


l.ambient-light:#dom-mocksensortype-ambient-light
l.accelerometer:#dom-mocksensortype-accelerometer
l.linear-acceleration:#dom-mocksensortype-linear-acceleration
l.gravity:#dom-mocksensortype-gravity
l.gyroscope:#dom-mocksensortype-gyroscope
l.magnetometer:#dom-mocksensortype-magnetometer
l.uncalibrated-magnetometer:#dom-mocksensortype-uncalibrated-magnetometer
l.absolute-orientation:#dom-mocksensortype-absolute-orientation
l.relative-orientation:#dom-mocksensortype-relative-orientation
l.geolocation:#dom-mocksensortype-geolocation
l.proximity:#dom-mocksensortype-proximity
	磁力計:~PERMISSIONS##dom-permissionname-magnetometer

sl.state:#dom-sensor-state-slot
sl.frequency:#dom-sensor-frequency-slot
	provided frequencies:#dom-sensor-frequency-slot
sl.lastEventFiredAt:#dom-sensor-lasteventfiredat-slot
sl.pendingReadingNotification:#dom-sensor-pendingreadingnotification-slot

et.activate:#_event-activate
	et.activated:#_event-activated
et.reading:#_event-reading
et.error:#_event-error

	●用語

~device~sensor:#concept-device-sensor
~platform~sensor:#concept-platform-sensor
既定の~sensor:#default-sensor
空間的~sensor:#spatial-sensor
~sensor融合:#sensor-fusion
高level:#high-level
低level:#low-level
~smart~sensor:#smart-sensors
~sensor~hub:#sensor-hubs
~sensor型:#sensor-type

~sensor許可~名たち:#sensor-permission-names
~sensor許可~revocation~algo:#generic-sensor-permission-revocation-algorithm
~sensor特能~名たち:#sensor-feature-names
~sensor~task源:#sensor-task-source
結付けられている~sensorたち:#associated-sensors
作動化された~sensor~objたち:#activated-sensor-objects
~supportする~sensor~optionたち:#supported-sensor-options

~sensor読取りを公開できる:#can-expose-sensor-readings
~sensor読取り:#sensor-reading
読取り値:#reading-value
読取り時刻印:#reading-timestamp
読取り変化~threshold:#reading-change-threshold
最新な読取り~map:#latest-reading

供した~frequency:#dom-sensor-frequency-slot
標本化~frequency:#sampling-frequency
要請した標本化~frequency:#requested-sampling-frequency
報告ng~frequency:#reporting-frequency
最適な標本化~frequency:#optimal-sampling-frequency

較正:#calibration
義務的な条件:#mandatory-conditions
拡張~仕様:#extension-specification
拡張~sensor~interface:#extension-sensor-interface

局所~座標系:#local-coordinate-system
単軸:#uniaxial
二軸:#biaxial
三軸:#triaxial

	■演算
~sensorに接続する:#connect-to-sensor
~sensor~accessを要請する:#request-sensor-access
~sensor~objを作動化する:#activate-a-sensor-object
~sensor~objを非作動化する:#deactivate-a-sensor-object
~sensor許可を~revokeする:#revoke-sensor-permission
~sensor設定群を設定する:#set-sensor-settings
~sensor~objの報告ng~frequencyを見出す:#find-the-reporting-frequency-of-a-sensor-object
最新な読取りを更新する:#update-latest-reading
最新な読取り~mapから値を取得する:#get-value-from-latest-reading
最新な読取り更新を報告する:#report-latest-reading-updated
新たな読取りを通知する:#notify-new-reading
作動化d状態を通知する:#notify-activated-state
~errorを通知する:#notify-error


	■模擬~sensor
模擬~sensor:#mock-sensor
模擬~sensor読取り:#mock-sensor-reading

模擬~sensor型:#mock-sensor-type
模擬~sensor読取り値たち:#mock-sensor-reading-values
直列形の模擬~sensor:#serialized-mock-sensor

模擬~sensorを作成する:#create-mock-sensor
模擬~sensorを取得する:#get-mock-sensor
模擬~sensor読取りを更新する:#update-mock-sensor-reading
模擬~sensorを削除する:#delete-mock-sensor

接続~flag:#connection-flag

i.模擬~sensorは作成-済み:#mock-sensor-already-created
i.そのような模擬~sensorは無い:#no-such-mock-sensor

特有な条件:#specific-conditions

	§:#create-mock-sensor-command
	§:#update-mock-sensor-reading-command
	§:#feature-detection
	§:#main-privacy-security-threats
	§:#mitigation-strategies
	§:#location-tracking
	§:#eavesdropping
	§:#keystroke-monitoring
	§:#device-fingerprinting
	§:#user-identifying
	§:#limit-max-frequency
	§:#extensibility
	§:#mitigation-strategies
	§:#mitigation-strategies-case-by-case
	§:#model
	§:#sensor-lifecycle
	§:#the-sensor-interface
	§:#event-handlers
	§:#section-extension-commands

	●用語（外部
集合:~INFRA#ordered-set
空:~INFRA#list-is-empty
	~IN:~INFRA#list-contain
	~EACH:~INFRA#list-iterate
~map:~INFRA#ordered-map
~entry:~INFRA#map-entry
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
	~~EACH:~INFRA#map-iterate
set.付加する:~INFRA#set-append
除去する:~INFRA#list-remove
	値を設定する:~INFRA#map-set

~interface:~WEBIDL#dfn-interface
継承した~interfaceたち:~WEBIDL#dfn-inherited-interfaces
継承した辞書たち:~WEBIDL#dfn-inherited-dictionaries
読専:~WEBIDL#dfn-read-only
属性:~WEBIDL#dfn-attribute
識別子:~WEBIDL#dfn-identifier
例外を作成する:~WEBIDL#dfn-create-exception
例外:~WEBIDL#dfn-exception-type
辞書:~WEBIDL#dfn-dictionary
	~THROW:~WEBIDL#dfn-throw
在する:~WEBIDL#dfn-present
辞書~member:~WEBIDL#dfn-dictionary-member
~IDL値に変換する:~WEBIDL#dfn-convert-ecmascript-to-idl-value

文書:~DOM4#concept-document
発火され:~DOM4#concept-event-fire-
~event~listener:~DOM4#concept-event-listener
~event:~DOM4#concept-event
~eventを発火する:~DOM4#concept-event-fire

~secure文脈:~SECURE-CONTEXT#secure-contexts

既定の許容list:~FEATUREPOLICY#default-allowlist

利用は許容されて:~HEembed#allowed-to-use
要請には特能の利用は許容されるべきか？:~FEATUREPOLICY#should-request-be-allowed-to-use-feature
施策により制御される特能:~FEATUREPOLICY#policy-controlled-feature

利用する許可を要請-:~PERMISSIONS#request-permission-to-use
~accessする許可を要請-:~PERMISSIONS#request-permission-to-use
許可~名:~PERMISSIONS#enumdef-permissionname
許可~記述子~型:~PERMISSIONS#permission-descriptor-type
	各種~許可~名:~PERMISSIONS#enumdef-permissionname
許可~状態:~PERMISSIONS#permission-state
強力な特能:~PERMISSIONS#powerful-feature
許可~revocation~algo:~PERMISSIONS#permission-revocation-algorithm

可視性~状態:~PAGE-VISIBILITY#dfn-steps-to-determine-the-visibility-state
	可視性~状態:~PAGE-VISIBILITY#dom-visibilitystate

作動中の文書:~BROWSERS#active-document
同じ生成元~domain:~ORIGIN#same-origin-domain
閲覧文脈:~BROWSERS#browsing-context

現在の被focus区画:~HTMLinteraction#currently-focused-area-of-a-top-level-browsing-context
~focusを得た:~HTMLinteraction#gains-focus

担当の文書:~WAPI#responsible-document
~task~queue:~WAPI#task-queue
~taskを~queueする:~WAPI#queue-a-task

生成元:~ORIGIN#origin-2
時刻~起点:~HRTIME#dfn-time-origin

~task源:~WAPI#task-source
~task:~WAPI#concept-task

~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~loopを回す:~WAPI#spin-the-event-loop

並列的:~HTMLINFRA#in-parallel

同一-生成元~施策~違反:https://w3ctag.github.io/security-questionnaire/#sop-violations

相対~方位~sensor:~MOTION-SENSORS#relative-orientation-sensor
絶対~方位~sensor:~MOTION-SENSORS#absolute-orientation-sensor
地磁気~方位~sensor:~MOTION-SENSORS#geomagnetic-orientation-sensor

	■WEBDRIVER
拡張~command:~WEBDRIVER#dfn-extension-command
現在の閲覧文脈:~WEBDRIVER#dfn-current-browsing-context
~URI~template:~WEBDRIVER#dfn-extension-command-uri-template
~remote端~手続き:~WEBDRIVER#dfn-remote-end-steps

wdr.~error:#_webdriver-error
wdr.成功:#_webdriver-success

~WebDriver~error:~WEBDRIVER#dfn-errors
~WebDriver~error~code:~WEBDRIVER#dfn-error-code
成功:~WEBDRIVER#dfn-success

i.無効な引数:~WEBDRIVER#dfn-invalid-argument
i.そのような~windowは無い:~WEBDRIVER#dfn-no-such-window

もはや開いてない:~WEBDRIVER#dfn-no-longer-open
利用者~promptを取扱う:~WEBDRIVER#dfn-handle-any-user-prompts
~session:~WEBDRIVER#dfn-session
~url変数:~WEBDRIVER#dfn-url-variables
局所~端:~WEBDRIVER#dfn-local-end

sensor_parts1:#_sensor_parts1

	:#robust-example
	~PERMISSIONS#new-information-about-the-users-intent
	~WEBDRIVER#dfn-object
	~WEBDRIVER#handling-errors
	~WEBIDL#Constructor
	~FEATUREPOLICY#iframe-allow-attribute

●●words_table1

WEBDRIVER:https://w3c.github.io/webdriver/
PERMISSIONS:webappsec-permissions-ja.html
MOTION-SENSORS:https://w3c.github.io/motion-sensors/
ORIENTATION-SENSOR:orientation-sensor-ja.html
ACCELEROMETER:accelerometer-ja.html
MAGNETOMETER:magnetometer-ja.html
AMBIENT-LIGHT:ambient-light-ja.html
GYROSCOPE:gyroscope-ja.html
GEOLOCATION-SENSOR:https://w3c.github.io/geolocation-sensor/
PROXIMITY:https://w3c.github.io/proximity/

BQ:`

●●words_table

	^cite:SI Brochure
	^cite:Self-Review Questionnaire on Security and Privacy
	^cite:Secure Contexts
	^en:Least Common Denominator (LCD)
	^en:Open Web Platform
	^en:consistent and cohesive
	^en:cell
	^en:runtime
	^en:compile-time

	許可~API:Permissions API
	汎用~sensor~API:Generic Sensor API

verbose:
warrant:
critical-path:critical path

	●装置
device:
bluetooth:
hub:
CPU:
Kelvin:
Celsius:
GPS:
集積回路:chip::~
基地局三角測量:cell triangulation:~
wifi:
SI:
X:
Y:
Z:
battery:::バッテリ
寿命:life::~
motion::::モーション
温度:temperature::~
方位:orientation::~
時刻:time::~
時間:time::~
	時間的:time
起点:origin::~
歩数計:pedometer::~
気圧:air pressure::~
気圧計:barometer::~
気圧高度計:pressure-altimeter::~
地理所在:geolocation::~
gyroscope::::ジャイロスコープ
磁力計:magnetometer::~
磁場:magnetic field::~
地磁気:geomagnetic::~
角速度:angular velocity::~
高度計:altimeter::~
圧抵抗圧力:resistive piezo-electric pressure:~
圧電:piezo-electric:~
加速度:acceleration::~
加速度計:accelerometer::~
光度:luminosity::~
信号:signal:~
smartphone::::スマホ
touch::::タッチ
近接:proximity::~
装身-:wear:~
	装身-可能:wearable
心拍数:heart-rate::~
携帯:mobile::~
smart::::スマート
hub::::ハブ
laptop::::ノートPC
電力:power:~
製造:manufacturing:~
	製造~時:manufacturing time
製造時:manufacturing:~
meter::::メートル
	meter:-m
産物:product:~
製品:product:~

地球:Earth:~
座標系:coordinate system::~
Cartesian:::直交
軸:axis::~
単軸:uniaxial::~
二軸:biaxial::~
三軸:triaxial::~
直交な:orthogonalな::~
分解能:resolution::~
垂直:perpendicular::~
平行:parallel::~
軸受:bearing::~

	うち一つ:left rear
	左後輪:left rear tire
	空気圧:pressure

	~~頭の~~動き追跡:head-tracking
	~~歩数計:counting steps
	ムラ:imperfections and differences／variations and imperfections

	●sensor／計測
sensor::::センサ
高level:high-level:高 level::高レベル
低level:low-level:低 level::低レベル
計測-:measure::~
計測:measurement::~
物理量:physical quantity::~
	物理量:quantity
scalar::::スカラー
標本化:sampling::~::サンプリング
単位:unit:~
in-Hz:Hz 単位
補償-:compensate::~
較正:calibration::~
milliseconds::::ミリ秒数
最大:maximum:~
最小:minimum:~
	許容される上限:maximum allowed limits

threshold:
	残量以上:below 〜 threshold
noise::::ノイズ
合成:synthetic:~
融合-:fuse::~
融合:fusion::~
空間的:spatial::~
報告ng:reporting::報告
読出し:readout::~
frequency:
rate::::レート
poll:
読取り:reading::読み取り
最新な:latest:~
見積もっ:estimateし:~
見積もら:estimateさ:~
見積もる:estimateする:~
見積もり:estimate:~
正確度:accuracy:正確さ
不正確度:inaccuracy:不正確さ
距離:distance:~
時間差:time deltas:~
最小化-:minimize:~
具体:concrete::~

	●WebDriver
模擬:mock::~
	模擬している:mocking
模倣-:simulate:~
WebDriver:
remote:
端:end::~
template:
command::::コマンド
virtual:

	●仕様
一助:help:~
上品:gracious:~
堅牢:robust:~
定常的:constant:~
定期的:regular:~
念頭:mind:~
成熟-:mature:~
推定-:infer:~
今日:today:~
共存-:coexist:~
分野:area:~
専門分野:domain:~
判定:judgement:~
包括的:comprehensive:~
機能-:function:~
柔軟性:flexibility:~
正され:correctされ:~
特徴付けら:characterizeさ:~
	~~理想である:ideal world
発生-:arise:~
義務的:mandatory:~
資料:resource:~
選択的:selective:~
過程:process:~
退行-:degrade:~
類似な:similarな:~
選ばれ:chooseされ:~
選ぶ:chooseする:~
	ことにして:chooseして
遂げる:carry outする:~
遂げて:carry outして:~
遂げら:carry outさ:~
枠組み:framework:~
演繹-:deduce:~
安全弁付き:defensiveな:~
自動化:automation:~
認知的負担:cognitive burden:~
適応-:accommodate:~
高処理能:performant:~
適理な:reasonableな:理に適う
単直:straightforward:簡単
非依存:agnostic:~
強化-:enhance:~
	〜を強化する:〜-enhancing
最終手段:last-resort solution:~
活用-:leverage:~
構造不明:nondescript:~
中間的:intermediary:~
本物の:realな:~
行使-:exercise:~
歩み:pace:~
	歩みが遅く:slow-paced
尊重-:respect:~
可能性:possibility:~
難題:challenge:~
発展-:evolve:~
手引き:guidance:~
	~~原則:precepts
高度な:advancedな:~
稀:rare:~
青写真:blueprint:~
論題:topic:~
査定-:assess:~
拡張d:extended:拡張
省略可能:optional:~
親密:intimate:~
分類-:categorize:~
分類:category:~
	-:categorization
種類:kind:~
創出-:create:~

	出発点:starting point
	~~実際:indeed
	きちんと:well
	ぼやけている:blurred／:blurry
	に則り、:as per
	こともある:sometimes
	まま:left
	主な:main
	に基づいて:basis
	事例~別:case by case basis
	呼ばれ:called
	委ねられる:up to
	対照的に:in contrast
	導き:lead
	情報:info
	果たさ:serve
	極めて:extremely
	満たされ:satisfied
	に依存する-dependent
	線引き:line
	良い:good
	よくあてはまる:good fit for
	規範的でない:non-normative
	豊富にある:plentiful
	逆に:conversely
	伝え:inform／:tell／:convey
	伝える
	上手く:well
	小さな:minor
	書く:writing
	様変わり:greatly vary
	馴染みのない:unfamiliar
	目的を以って:purposefully
	しようとして:going
	すれば十分:good enough
	~~目的の:sought-after
	~~事前~upfront
	~costがかかる:costly
	されたし:please
	し続ける:keep
	またがって:across
	要る:require
	大別-:distinguish between
	結果:fruits
	説明されている:be found in 〜 explainer documents
	勧められ:advisable
	これまで:so far
	登場当時のそれら:When they are,
	可能性もある:possible
	現時点:currently
	従い:following
	とされる:said to be
	明らか:obvious
	下位節:subsection
	併用:for use with
	名前を継ぐ:named after
	改善:make 〜 improvements
	特に:most notably
	~~相応しく:Right Choice
	気にする:care
	対象になる:target
	活かし:thanks to 〜
	とは言え:that said
	2 つ:twofold
	促す:promoteする
	称され:referred
	区別:distinction
	区別-:make 〜 distinction
	に特有:-specific
	選好され:favored
	~~節約:freeing up
	得る:potentially
	ごく限られる:have little to no
	よくあった:it is often in ways that
	中に〜を取り入れる:use 〜 inline with
	~test用:testing
	それに関係しない:non-〜-related
	~~課す:pose〜 to test
	もたらし得る:potential
	断たれ:severe
	広範な:wide range of
	居座る:sit
	以前に増して:increasingly
	視点:perspective
	視点:point of view
	指す:refer
	を見られたし:please refer to
	~~最新の:up-to-date
	含まれない:is not among
	出自にする:originated from
	-:force
	-:object
	関心がある:interested
	基準:reference
	示す:illustrate
	特能~施策:Feature Policy
	非~SI:Non-SI
	汎用~sensor~API:Generic Sensor API
	発見-用の:discovery

	●保安
revokeする::取り消す
revokeした::取り消した
revocation::取り消し
帯域外:out of band:~
歩き:walking:~
機械学習:machine learning:~
相関-:correlate::~
相関:correlation::~
脅威:threat:~
自己評価質問票:Self-Review Questionnaire:~
訓練-:train:~
軽減:mitigation:~
軽減策:mitigations:~
策:strategy:~
	個人:individual
	個別に:individually
許容list:allowlist::許容 list:許容リスト
random::::ランダム
偏り:bias:~
keystroke::::キーストローク
監視:monitoring:~
password::::パスワード
PIN:
支払い:payment:::~
profile::::プロファイル
購入:purchase:~
盗聴:eavesdropping:~
発話:speech:~
統計的:statistical:~
軌跡:trajectory:~
場当的:ad-hoc:場当たり的
不一致:discrepancies:~
盗読み:skimming:盗み読み
変動:variation:~
開示:disclosure:~
回復-:recover:~
高価値:high-value:~
sandbox::::サンドボックス
同意t:consent:［同意／黙認］
	同意tを得る／同意t法:consenting

	思いがけない:unanticipated
	手短に挙げていく:briefly enumerate
	攻撃が成功する~risk:risk of successful attack
	〜の~~要因になる:might be created
	長期間にわたる:over longer period of time
	~~経過するまで:period of time
	第三者主体:third party

	●未分類
列挙型:enum::~
online::::オンライン
offline::::オフライン
	~onlineにも~offlineにも:on and offline
URI:
WebIDL:
backend:
options:::option 集
消費:consumption:~
結合-:combine::~
観測器:observer::~
解放-:release:~
超過-:exceed:~
量:amount:~
面:surface:~
過去:past:~
遷移:transition:~
構成-:compose:~
	構成され:composed of
半径:radius:~
同時的:simultaneous:~
一時的:temporal:~
	一時的に:temporarily
間隔:interval:~
増幅-:amplify:~
密度:density:~
ナシ:none:なし
切替える:switchする:切り替える
発され:emitされ:~
稼働-:run:~
prompt:
	査定-:perform 〜 assessment of
filter::::フィルタ
	~filterで濾す:filter out
log::::ログ
zoom::::ズーム
bar::::バー
邪魔-:hinder:~
lifecycle:
遊休中:idle::~
作動化d:activated::作動化::アクティブ化
非作動化-:deactivate::~::非アクティブ化
直列形の:serialized::~::シリアル形の
開いて:openして:~
被focus:focused::被 focus:被フォーカス
dialog::::ダイアログ
game::::ゲーム
	~game内:in-game
地図:map:~
	仮想現実:virtual reality:~
	拡張現実:augmented reality:~
個人周辺:personal area:~
実行時:runtime:~
在する:presentする:在る
	用意ができ:ready

	構築-可能:constructible
	構築し直す:reconstruct
	渡-:pass
	環境設定-可能:configurable
	高める／高まり／増やす／増え／増す／増える／速める:increase
	不在:absence
	^I:Gyroscope
	^:POST
	^e:iframe
	~NULL:unset
	~EQ ~NULL:is not set
	~NEQ ~NULL:is set
	~code片:snippet
	~UI:user-interface
	遅める:slow
	抑える:lowering
	減らす:decrease
	変形する:remap
	備えて:carry
	備える:equipped with
	成すことになる:creating
	~instance化:instantiate／:instantiating
	切り詰め:cap
	所在を得る:locate
	所在:location point
	実数:double
	変形する:remap

	●指示語
	まるごと:altogether
	上限, 下限:bounds
	上限:upper limit
	上限:upper bound
	下限:lower bound
	先ず:firstly
	入る:fall in
	回数:number of
	属する:belong
	異なる:different
	それまで:total
	表:table
	間にまたがる:cross-
	限られた数の:limited number of
	回を重ねて:over time
	後続の:subsequent
	周囲の:surrounding
	-:against
	-:amongst
	何も:anything
	より低:lower-
	低-:low-
	低-:low
	高-:high-:~
	高い:higher
	各~計測回:t<sub>n</sub>
	新たに:newly
	更なる:further
	第一に:primarily
	第二に:secondly
	および:as well as
	:sub-step
	どの時点であれ:any time
	有無:presence:~
	複数個:several

	●変数
	-:connected
	%許可~状態:~permission_state
	%作動化された~sensorたち:activated_sensors
	%特能~名:feature_name
	%特能~名たち:feature_names
	%許可~名:permission_name
	%~sensor型:sensor type
	%~sensor型:sensor_type
	%~sensor~instance:sensor_instance
	此れ:sensor_instance
	%~sensor許可たち:~sensor_permissions
	-:sensor_state
	%報告ng~frequency:reportingFrequency
	%報告ng間隔:reportingInterval
	%時刻印~差分:timestampDelta
	%最後に報告された時刻印:lastReportedTimestamp
	-:deferUpdateTime


●●ref_normative

[ACCELEROMETER]
    Anssi Kostiainen; Alexander Shalamov. Accelerometer. URL: https://w3c.github.io/accelerometer/ 
[AMBIENT-LIGHT]
    Anssi Kostiainen. Ambient Light Sensor. URL: https://w3c.github.io/ambient-light/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FEATURE-POLICY]
    Feature Policy. Living Standard. URL: https://wicg.github.io/feature-policy/ 
[GEOLOCATION-SENSOR]
    Anssi Kostiainen; Thomas Steiner. Geolocation Sensor. URL: https://w3c.github.io/geolocation-sensor/ 
[GYROSCOPE]
    Anssi Kostiainen; Mikhail Pozdnyakov. Gyroscope. URL: https://w3c.github.io/gyroscope/ 
[HR-TIME-2]
    Ilya Grigorik; James Simonsen; Jatinder Mann. High Resolution Time Level 2. URL: https://w3c.github.io/hr-time/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MAGNETOMETER]
    Anssi Kostiainen; Rijubrata Bhaumik. Magnetometer. URL: https://w3c.github.io/magnetometer/ 
[ORIENTATION-SENSOR]
    Mikhail Pozdnyakov; et al. Orientation Sensor. URL: https://w3c.github.io/orientation-sensor/ 
[PAGE-VISIBILITY]
    Jatinder Mann; Arvind Jain. Page Visibility (Second Edition). 29 October 2013. REC. URL: https://www.w3.org/TR/page-visibility/ 
[PERMISSIONS]
    Mounir Lamouri; Marcos Caceres; Jeffrey Yasskin. Permissions. URL: https://w3c.github.io/permissions/ 
[POWERFUL-FEATURES]
    Mike West. Secure Contexts. URL: https://w3c.github.io/webappsec-secure-contexts/ 
[PROXIMITY]
    Anssi Kostiainen; Rijubrata Bhaumik. Proximity Sensor. URL: https://w3c.github.io/proximity/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebDriver]
    Simon Stewart; David Burns. WebDriver. URL: https://w3c.github.io/webdriver/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[ACCELPRINT]
    Dey, Sanorita, et al.. AccelPrint: Imperfections of Accelerometers Make Smartphones Trackable. 2014. Informational. URL: http://synrg.csl.illinois.edu/papers/AccelPrint_NDSS14.pdf 
[API-DESIGN-PRINCIPLES]
    Domenic Denicola. API Design Principles. 29 December 2015. URL: https://w3ctag.github.io/design-principles/ 
[COORDINATES-TRANSFORMATION]
    George W. Collins, II. The Foundations of Celestial Mechanics. 2004. Informational. URL: http://ads.harvard.edu/books/1989fcm..book/Chapter2.pdf 
[EXTENNNNSIBLE]
    The Extensible Web Manifesto. 10 June 2013. URL: https://extensiblewebmanifesto.org/ 
[GENERIC-SENSOR-USECASES]
    Rick Waldron, Mikhail Pozdnyakov, Alexander Shalamov. Sensor Use Cases. 2017. Note. URL: https://w3c.github.io/sensors/usecases 
[GEOLOCATION-API]
    Andrei Popescu. Geolocation API Specification 2nd Edition. URL: http://dev.w3.org/geo/api/spec-source.html 
[GYROSPEECHRECOGNITION]
    Michalevsky, Y., Boneh, D. and Nakibly, G.. Gyrophone: Recognizing Speech from Gyroscope Signals. 2014. Informational. URL: https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-michalevsky.pdf 
[MOBILESENSORS]
    Manish J. Gajjar. Mobile Sensors and Context-Aware Computing. 2017. Informational. 
[MOTION-SENSORS]
    Kenneth Christiansen; Alexander Shalamov. Motion Sensors Explainer. URL: https://w3c.github.io/motion-sensors/ 
[ORIENTATION-EVENT]
    Rich Tibbett; et al. DeviceOrientation Event Specification. URL: https://w3c.github.io/deviceorientation/spec-source-orientation.html 
[QUDT]
    Ralph Hodgson; et al. QUDT - Quantities, Units, Dimensions and Data Types Ontologies. 18 March 2014. URL: http://www.qudt.org/ 
[RFC6454]
    A. Barth. The Web Origin Concept. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454 
[SECURITY-PRIVACY-QUESTIONNAIRE]
    Mike West. Self-Review Questionnaire: Security and Privacy. URL: https://w3ctag.github.io/security-questionnaire/ 
[SI]
    SI Brochure: The International System of Units (SI), 8th edition. 2014. URL: http://www.bipm.org/en/publications/si-brochure/ 
[STEALINGPINSVIASENSORS]
    Maryam Mehrnezhad, Ehsan Toreini, Siamak F. Shahandashti, Feng Hao. Stealing PINs via mobile sensors: actual risk versus user perception. 2017. Informational. URL: https://rd.springer.com/article/10.1007/s10207-017-0369-x?wt_mc=Internal.Event.1.SEM.ArticleAuthorOnlineFirst 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより
編集者草案として公開された
<a href="~SPEC_URL">Generic Sensor API</a>
を日本語に翻訳したものです。
~PUB

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/generic-sensor/
以前のバージョン
	https://www.w3.org/TR/2018/CR-generic-sensor-20180320/
フィードバック
	<a href="mailto:public-device-apis@w3.org?subject=%5Bgeneric-sensor%5D%20YOUR%20TOPIC%20HERE">public-device-apis@w3.org</a> with subject line “<kbd>[generic-sensor] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-device-apis/" rel="discussion">archives</a>)
	<a href="https://github.com/w3c/sensors">GitHub</a> (<a href="https://github.com/w3c/sensors/issues/new">new issue</a>, <a href="https://github.com/w3c/sensors/milestone/2">level 1 issues</a>, <a href="https://github.com/w3c/sensors/issues">all issues</a>)

編集
	Rick Waldron (<span class="p-org org">Bocoup, formerly on behalf of JS Foundation)
前任編集者
	<a href="https://intel.com/">Mikhail Pozdnyakov</a> (Intel Corporation)
	<a href="https://intel.com/">Alexander Shalamov</a> (Intel Corporation)
	<a href="https://www.codespeaks.com/">Tobie Langel</a> (Codespeaks, formerly on behalf of Intel Corporation) <a href="mailto:tobie@codespeaks.com">tobie@codespeaks.com</a>
Test Facilitator
	Wanming Lin (Intel Corporation)

テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/generic-sensor
commit 履歴
	https://github.com/w3c/sensors/commits/master/index.bs
mailing list
	<a href="mailto:public-device-apis@w3.org?Subject=%5Bgeneric-sensor%5D%20PUT%20SUBJECT%20HERE">public-device-apis@w3.org</a> (<a href="mailto:public-device-apis-request@w3.org?subject=subscribe">subscribe</a>, <a href="https://lists.w3.org/Archives/Public/public-device-apis/">archives</a>)
発行者
	<a href="https://www.w3.org/das/">Devices and Sensors Working Group</a>
</script>

<!-- 
以前のバージョン履歴
	https://github.com/w3c/sensors/commits/gh-pages/index.bs
-->
</head>
<body>
<!--%resource pool -->
<div id="_persisted_parts" hidden>

<svg
	id="_sensor_parts1"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	width="120"
	height="100"
	viewBox="0 0 1200 1000"
	preserveAspectRatio="xMidYMid"
>

	<defs>
<rect id="pin0" x="0" y="0" width="80" height="80" fill="white" stroke="gray" 
stroke-width="5"/>
	</defs>

	<g transform="translate(100,50)" >
<rect x="0" y="0" width="1000" height="900" fill="black" stroke="none" />
<use href="#pin0" transform="translate(-80,70)" />
<use href="#pin0" transform="translate(-80,210)" />
<use href="#pin0" transform="translate(-80,600)" />
<use href="#pin0" transform="translate(-80,740)" />

<use href="#pin0" transform="translate(1000,70)" />
<use href="#pin0" transform="translate(1000,210)" />
<use href="#pin0" transform="translate(1000,600)" />
<use href="#pin0" transform="translate(1000,740)" />

<circle cx="500" cy="450" r="30" fill="white" stroke="none" />
<circle cx="500" cy="450" r="100" fill="none" stroke="white" stroke-width="10"/>
<path fill="none" stroke="white" stroke-width="10" d="M850,550 v200 h-200" />
<text transform="translate(850, 450)">X</text>
<text transform="translate(550, 750)">Y</text>
<text transform="translate(300, 450)">Z</text>

	</g>
</svg>
</div>

<header>
	<hgroup>
<h1>汎用センサ API — Generic Sensor API</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、~sensor~dataを一貫した仕方で
`Open Web Platform^en に公開するための枠組みを定義する
— 具体~sensorの仕様を［
各種~sensor型に適応するために拡張できる抽象- `Sensor^I ~interface
］とともに書くための青写真を定義することにより。
◎
This specification defines a framework for exposing sensor data to the Open Web Platform in a consistent way. It does so by defining a blueprint for writing specifications of concrete sensors along with an abstract Sensor interface that can be extended to accommodate different sensor types.
</p>

	</section>
	<section id="status">
~STATUSofTHIS

<p>
この節では、発行時点における…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>／冒頭の仕様~metadataに委譲。】
</p>

<!-- 
 This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

If you wish to make comments regarding this document, please send them to public-device-apis@w3.org (subscribe, archives). When sending e-mail, please put the text “generic-sensor” in the subject, preferably like this: “[generic-sensor] …summary of comment…”. All comments are welcome.

This document was produced by the Devices and Sensors Working Group.

This document was produced by a group operating under the W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 February 2018 W3C Process Document. 
-->

	</section>
<main id="MAIN0">

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
原文における用語
“`allowed to use^en”
は、
`FEATURE-POLICY$r による
“`要請には特能の利用は許容されるべきか？$”
を指しているが、（その仕様の更新に伴い）~~意味が通らなくなっているので，この訳では
`HTML$r による
“特能の`利用は許容されて$いる／いない”
に置換している（訳者による推定 — 本質的には同じことを行う）。
</p>

	</section>
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~sensor~dataは、［
地理所在（ `geolocation^en ）／
~~歩数計（ `counting steps^en ）／
~~頭の~~動きの~~追跡（ `head-tracking^en ）
］などの新たな利用-事例を可能化するため，以前に増して~app開発に利用されている。
これはとりわけ、新たな~sensorが定期的に追加される携帯~deviceに該当する。
◎
Increasingly, sensor data is used in application development to enable new use cases such as geolocation, counting steps or head-tracking. This is especially true on mobile devices where new sensors are added regularly.
</p>

<p>
これまで，~sensor~dataを~Webへ公開することは、歩みが遅く場当的でもあった。
少数の~sensorは、すでに~Webに公開されている。
登場当時のそれらは、アリな利用-事例が限られていたこともよくあった（例えば，`高level$過ぎる抽象化を公開した結果，十分~上手く遂行しないなど）。
また，~APIは各種~sensorごとに様変わりするので、~Web~app開発者の認知的負担が増え，開発を遅める。
◎
Exposing sensor data to the Web has so far been both slow-paced and ad-hoc. Few sensors are already exposed to the Web. When they are, it is often in ways that limit their possible use cases (for example by exposing abstractions that are too high-level and which don’t perform well enough). APIs also vary greatly from one sensor to the next which increases the cognitive burden of Web application developers and slows development.
</p>

<p>
汎用~sensor~API（ `Generic Sensor API^en ）の目標は
⇒＃
各種~sensor~APIにまたがる一貫性を促す／
高処理能な`低level$~APIを活かした高度な利用-事例を可能化する／
仕様と実装の過程を単純~化して，新たな~sensorを~Webに公開できる歩みを速める
◎
The goal of the Generic Sensor API is to promote consistency across sensor APIs, enable advanced use cases thanks to performant low-level APIs, and increase the pace at which new sensors can be exposed to the Web by simplifying the specification and implementation processes.
</p>

<p>
［
汎用~sensor~API,
適用-可能な利用-事例,
~code例
］に基づく，具体~sensorの包括的な~listは、
`GENERIC-SENSOR-USECASES$r, `MOTION-SENSORS$r
に説明されている。
◎
A comprehensive list of concrete sensors that are based on Generic Sensor API, applicable use cases, and code examples can be found in [GENERIC-SENSOR-USECASES] and [MOTION-SENSORS] explainer documents.
</p>

	</section>
	<section id="scope">
<h2 title="Scope">2. 視野</h2>

~INFORMATIVE

<p>
この仕様の視野は、現時点では，［
`~device~sensor$から~dataを公開するのを可能化する，~primitive
］を指定することに制限される。
◎
The scope of this specification is currently limited to specifying primitives which enable exposing data from device sensors.
</p>

<p>
~remote~sensorや個人周辺~networkに見出される~sensor（例：~bluetooth）を公開することは、視野の外である。
これらの分野における作業が成熟するに伴い，共通かつ，より低levelな~primitiveが見出される可能性もある
— その事例では、この仕様もそれに則って更新されることになる。
しかしながら，これによる実装に対する効果は、ごく限られるはずである。
◎
Exposing remote sensors or sensors found on personal area networks (e.g. Bluetooth) is out of scope. As work in these areas mature, it is possible that common, lower-level primitives be found, in which case this specification will be updated accordingly. This should have little to no effects on implementations, however.
</p>

<p>
この仕様はまた、現時点では~sensor発見-用の~APIを公開していない。
このことは、現時点で~UAに可用な限られた数の~sensorが，そのような~APIを~warrant【！＊】していないからである。
今の所，
<a href="#feature-detection">§ ~hardware特能の特能~検出に対する注記</a>
に述べられるものなど，特能~検出を利用すれば十分である。
この仕様の後続の~versionは、そのような~APIを指定するかもしれない
— 現在の~APIは、このことを念頭に設計されている。
◎
This specification also does not currently expose a sensor discovery API. This is because the limited number of sensors currently available to user agents does not warrant such an API. Using feature detection, such as described in §3 A note on Feature Detection of Hardware Features, is good enough for now. A subsequent version of this specification might specify such an API, and the current API has been designed with this in mind.
</p>

	</section>
	<section id="feature-detection">
<h2 title="A note on Feature Detection of Hardware Features">3. ~hardware特能の特能~検出に対する注記</h2>

~INFORMATIVE

<p>
特能~検出は、~Web開発において確立された最善な実施である。
この論題についての資料は、~onlineにも~offlineにも，豊富にある
— この節の目的は、それについて更に論じることではなく，それを~hardwareに依存する特能を検出する文脈~内に置くことにある。
◎
Feature detection is an established Web development best practice. Resources on the topic are plentiful on and offline and the purpose of this section is not to discuss it further, but rather to put it in the context of detecting hardware-dependent features.
</p>

<p>
次の特能~検出~例を考える：
◎
Consider the below feature detection examples:
</p>

<div class="example">
<p>
次の単純な例は、［
特定0の~sensor型~用に，~UAが~interfaceを公開するかどうか
］を検査する方法を示す。
堅牢な方式で~errorを取扱う
<a href="#robust-example">後述の例</a>
も見られたし。
◎
This simple example illustrates how to check whether the User Agent exposes an interface for a particular sensor type. To handle errors in a robust manner, please refer to this example. 
</p>

<pre class="js-code">
if (typeof Gyroscope === "function") {
    // run in circles...
}

if ("ProximitySensor" in window) {
    // watch out!
}

if (window.AmbientLightSensor) {
    // go dark...
}

// etc.
</pre>
</div>

<p>
これらすべては、~APIの有無, アリな特徴について何かを伝えるが，次については何も伝えない：
その~APIは実際に本物の~hardware~sensorに接続されているのか？
そうであれば，その~sensorは働くのか？
あるいは、利用者が~accessを許容しようとしているかさえも。
後者については、許可~API（ `Permissions API^en ） `PERMISSIONS$r を利用すれば検査できることに注意。
◎
All of these tell you something about the presence and possible characteristics of an API. They do not tell you anything, however, about whether that API is actually connected to a real hardware sensor, whether that sensor works, if its still connected, or even whether the user is going to allow you to access it. Note you can check the latter using the Permissions API [PERMISSIONS].
</p>

<p>
下層の状態sについての情報は、~~事前に可用になるのが~~理想である。
これに関する問題は、 2 つある。
第一に，この情報を~hardwareから取得するのは、処理能, ~battery両面で時間的な~costがかかり，~critical-path内に居座ることになる。
第二に，下層の~hardwareの状態sは、時間とともに発展し得る：
利用者が許可を~revokeしたり，
~sensorへの接続が断たれたり，
~OSが~sensor用法を一定の~battery残量以上に制限するよう裁定することもある，
等々。
◎
In an ideal world, information about the underlying status would be available upfront. The problem with this is twofold. First, getting this information out of the hardware is costly, in both performance and battery time, and would sit in the critical path. Secondly, the status of the underlying hardware can evolve over time. The user can revoke permission, the connection to the sensor be severed, the operating system may decide to limit sensor usage below a certain battery threshold, etc.
</p>

<p>
したがって，効果的な策は、［
~~目的の~sensor用の~APIが実際に存在するかどうか検査する特能~検出
］と［
次に挙げるような安全弁付き~programming
］を組合せることである：
◎
Therefore, an effective strategy is to combine feature detection, which checks whether an API for the sought-after sensor actually exists, and defensive programming which includes:
</p>

<ol>
	<li>
`Sensor$I ~objを~instance化するときに投出される~errorを検査して、
◎
checking for error thrown when instantiating a Sensor object,
</li>
	<li>
発される~errorを~listenして、
◎
listening to errors emitted by it,
</li>
	<li>
それらすべてを上品に取扱う
— 利用者~体験が~sensorにアリな用法により強化され，その不在により退行しないよう。
◎
handling all of the above graciously so that the user’s experience is enhanced by the possible usage of a sensor, not degraded by its absence.
</li>
</ol>

<div class="example" id="robust-example">
<p>
`Accelerometer^I ~sensorを堅牢な方式で作成する方法を，次の~code片に示す。
~Web~appは、~error取扱い用に異なる~optionも選べる
— 例えば：
通知を示す／
異なる~sensor型を選ぶ／
他の~APIに~fallbackする
◎
The following snippet illustrates how an Accelerometer sensor can be created in a robust manner. Web application may choose different options for error handling, for example, show notification, choose different sensor type or fallback to other API.
</p>

<pre class="js-code">
let %accelerometer = null;
try {
    %accelerometer = new Accelerometer({ frequency: 10 });
    %accelerometer.addEventListener('error', %event =&gt; {
        // <span class="comment">実行時~errorを取扱う：</span>
        if (%event.error.name === 'NotAllowedError') {
            console.log('~sensorへの~access許可は否認されました。');
        } else if (%event.error.name === 'NotReadableError' ) {
            console.log('~sensorに接続できません。');
        }
    });
    %accelerometer.addEventListener('reading', () =&gt; reloadOnShake(%accelerometer));
    %accelerometer.start();
} catch (%error) {
    // <span class="comment">構築~errorを取扱う：</span>
    if (%error.name === 'SecurityError') {
        console.log('~sensor構築は特能~施策により阻止されました。');
    } else if (%error.name === 'ReferenceError') {
        console.log('~UAは、この~sensorを~supportしていません。');
    } else {
        throw %error;
    }
}
</pre>
<!-- 
let accelerometer = null;
try {
    accelerometer = new Accelerometer({ frequency: 10 });
    accelerometer.addEventListener('error', event =&gt; {
		// Handle runtime errors.
        if (event.error.name === 'NotAllowedError') {
            console.log('Permission to access sensor was denied.');
        } else if (event.error.name === 'NotReadableError' ) {
            console.log('Cannot connect to the sensor.');
        }
    });
    accelerometer.addEventListener('reading', () =&gt; reloadOnShake(accelerometer));
    accelerometer.start();
} catch (error) {
    // Handle construction errors.
    if (error.name === 'SecurityError') {
        console.log('Sensor construction was blocked by the Feature Policy.');
    } else if (error.name === 'ReferenceError') {
        console.log('Sensor is not supported by the User Agent.');
    } else {
        throw error;
    }
}
-->
</div>

	</section>
	<section id="security-and-privacy">
<h2 title="Security and privacy considerations">4. ~securityと~privacyの考慮点</h2>

<div class="note" role="note">
<p>
既知な
<a href="#main-privacy-security-threats">脅威を利用者に通信する方法</a>
についての判定は、実装者に委ねられる。
しかしながら、
<a href="#mitigation-strategies">軽減策</a>の実装は義務的である。
◎
The judgement on how to communicate to the user the known threats is up to the implementer. The implementation of the mitigations is mandatory, however.
</p>

<p>
汎用~sensor~API, その`拡張~仕様$は、どの~UI側面にも非依存である。
この仕様は、実装者が
<a href="~PERMISSIONS#new-information-about-the-users-intent">明示的または暗黙的に利用者から同意tを得る</a>
ために利用できる［
許可~API `PERMISSIONS$r 用の<a href="#request-sensor-access">統合~地点</a>
］を定義する。
加えて，実装者には、首尾一貫した（ `consistent^en かつ `cohesive^en な）体験を供するためとして，製品~要件の中に［
~privacyを強化する追加的な仕組み
］を取り入れることが奨励される。
そのような仕組みには、例えば次が挙げられる
⇒＃
大域的あるいは生成元ごとの~access制御 ／
~page情報~dialog／
所在~bar指示子／
その他の開示~UI要素
◎
The Generic Sensor API and its extension specifications are agnostic with respect to any user interface aspects. This specification defines an integration point to the Permissions API [PERMISSIONS] that implementers can use for explicit or implicit user consenting. In addition, implementers are encouraged to use additional privacy-enhancing mechanisms inline with their product requirements to provide a consistent and cohesive experience. Such mechanisms can include, for example, global and per-origin access controls, page info dialogs, location bar indicators, or other disclosure user interface elements.
</p>

<p>
汎用~sensor~APIは、［
利用者~向けの［
同意t法／開示
］に関する~UI設計
］についての裁定を［
具体~sensorに基づいて，必要に応じて下す柔軟性
］を実装者に供する。
◎
The Generic Sensor API provides flexibility to implementers to make user consenting and disclosure user interface design decisions on a concrete sensor basis as needed.
</p>
</div>

<p>
`~sensor読取り$は，敏感な~dataであり、悪意的な~Web~pageからの様々な攻撃の~subjectにもなり得る。
軽減~策を論じる前に，［
`~device~sensor$の~privacy／~security脅威を成す主な型
］について手短に挙げていく。
`MOBILESENSORS$r では、主な脅威を次に挙げるものに分類しており，この仕様にもよくあてはまる
⇒＃
<a href="#location-tracking">所在~追跡</a>,
<a href="#eavesdropping">盗聴</a>,
<a href="#keystroke-monitoring">~keystrokeの監視</a>,
<a href="#device-fingerprinting">~device指紋収集</a>,
<a href="#user-identifying">利用者~識別-法</a>
◎
Sensor readings are sensitive data and could become a subject of various attacks from malicious Web pages. Before discussing the mitigation strategies we briefly enumerate the main types of the sensor's privacy and security threats. The [MOBILESENSORS] categorizes main threats into location tracking, eavesdropping, keystroke monitoring, device fingerprinting, and user identification. This categorization is a good fit for this specification.
</p>

<p>
攻撃が成功する~riskは、`~device~sensor$が他の機能性との組合nで互いに利用されたり，回を重ねて利用されるほど高まり得る
— 特定的には［
~dataの相関, 指紋収集を通した利用者~識別
］の~riskを伴う。
これらの~JS~APIを利用している~web~app開発者は、この情報が他の情報と どう相関され，~privacy~riskの~~要因になるか考慮するベキである。
より長期間にわたる，そのような~dataの収集がもたらし得る~riskも、考慮するベキである。
◎
The risk of successful attack can increase when sensors are used with each other, in combination with other functionality, or when used over time, specifically with the risk of correlation of data and user identification through fingerprinting. Web application developers using these JavaScript APIs should consider how this information might be correlated with other information and the privacy risks that might be created. The potential risks of collection of such data over a longer period of time should also be considered.
</p>

<p>
`~sensor読取り$における変動, および~event発火~rateは、利用者を識別する指紋収集の可能性も提供する。
~UAは、~web~app開発者に可用になる~event~rateを制限することで，~riskを抑制してもヨイ。
◎
Variations in sensor readings as well as event firing rates offer the possibility of fingerprinting to identify users. User agents may reduce the risk by limiting event rates available to web application developers.
</p>

<p>
~sensorの読出しの正確度を最小化することは、一般に，指紋収集の~riskを減らす。
~UAは、不必要に~verboseな~sensor~dataの読出しを供するベキでない。
各`~sensor型$は、個別に査定されるベキである。
◎
Minimizing the accuracy of a sensor’s readout generally decreases the risk of fingerprinting. User agents should not provide unnecessarily verbose readouts of sensors data. Each sensor type should be assessed individually.
</p>

<p>
この~APIを利用して，同じ~device上の異なる~window文脈~内で同じ~JS~codeを同時的に利用できる場合、
その~codeは，それらの文脈にまたがって利用者【についての情報】を相関することもアリになり得る結果，思いがけない追跡の仕組みを創出することになる。
◎
If the same JavaScript code using the API can be used simultaneously in different window contexts on the same device it may be possible for that code to correlate the user across those two contexts, creating unanticipated tracking mechanisms.
</p>

<p>
~UAは、［
`~device~sensor$が利用されたことの指示を利用者に供する ／
~sensorを不能化することを利用者に許容する
］ことを考慮するベキであり、［
過去, および現在の~sensor利用~patternを検証yすることを利用者に許容する
］ことを考慮してもヨイ。
【！要件~levelとして，考慮するベキ／考慮してもヨイとは、何を意味する？】
◎
User agents should consider providing the user an indication of when the sensor is used and allowing the user to disable it. Additionally, user agents may consider allowing the user to verify past and current sensor use patterns.
</p>

<p>
`~device~sensor$を利用する~web~app開発者は、自身の~appによる~privacyへの影響iを
— 当の~appのすべての側面を考慮に入れて —
査定するベキである。
◎
Web application developers that use sensors should perform a privacy impact assessment of their application taking all aspects of their application into consideration.
</p>

<p>
ある~device上で働いている~sensorの集合を全部的に検出する能は、識別子を形成し得るため，指紋収集~用に利用することもできる。
◎
Ability to detect a full working set of sensors on a device can form an identifier and could be used for fingerprinting.
</p>

<p>
選定された~sensorの組合nは、~device間の帯域外~通信~channelを形成するためにも利用され得る。
◎
A combination of selected sensors can potentially be used to form an out of band communication channel between devices.
</p>

<p>
~sensorは、~device間にまたがる~link法や利用者の追跡にも利用され得る。
◎
Sensors can potentially be used in cross-device linking and tracking of a user.
</p>

		<section id="main-privacy-security-threats">
<h3 title="Types of privacy and security threats">4.1. ~privacy／~security脅威の型</h3>

~INFORMATIVE

			<section id="location-tracking">
<h4 title="Location Tracking">4.1.1. 所在~追跡</h4>

<p>
この型の脅威の下では、攻撃は，~GPSその他の所在~sensorを利用することなく，`~sensor読取り$を利用して~deviceの所在を得る。
例えば，加速度計~dataは、~smartphoneの所在を推定するためにも利用できる
— 統計的~modelを利用して軌跡を見積もってから、地図~照合~algoを利用して，所在を予測できる（半径 200 ~meterの中で）
`MOBILESENSORS$r
。
◎
Under this type of threat, the attacks use sensor readings to locate the device without using GPS or any other location sensors. For example, accelerometer data can be used to infer the location of smartphones by using statistical models to obtain estimated trajectory, then map matching algorithms can be used to obtain predicted location points (within a 200-m radius)[MOBILESENSORS].
</p>

			</section>
			<section id="eavesdropping">
<h4 title="Eavesdropping">4.1.2. 盗聴</h4>

<p>
~gyroscope`~sensor読取り$から発話を回復することは、盗聴~攻撃の例である。
`GYROSPEECHRECOGNITION$r
を見よ。
◎
Recovering speech from gyroscope readings is an example of eavesdropping attack. See [GYROSPEECHRECOGNITION].
</p>

			</section>
			<section id="keystroke-monitoring">
<h4 title="Keystroke Monitoring">4.1.3. ~keystrokeの監視</h4>

<p>
多くの利用者~入力は、`~sensor読取り$から推定され得る。
これには、~motion~sensorを利用する，次に対する広範な攻撃を含まれる：
利用者の［
~PIN／~password／~lock~pattern
］（および，~click, ~scroll, ~zoomなどの~touch動作さえも）。
これらの攻撃は、通常は，そのような利用者についての情報を発見するため，機械学習~algoを訓練する。
`STEALINGPINSVIASENSORS$r
を見よ。
◎
Many user inputs can be inferred from sensor readings, this includes a wide range of attacks on user PINs, passwords, and lock patterns (and even touch actions such as click, scroll, and zoom) using motion sensors. These attacks normally train a machine learning algorithm to discover such information about the users. See [STEALINGPINSVIASENSORS].
</p>

			</section>
			<section id="device-fingerprinting">
<h4 title="Device Fingerprinting">4.1.4. ~device指紋収集</h4>

<p>
~sensorは、それらを利用して~deviceを一意に識別できる情報を供し得る。
どの~modelの具体~sensorにも、その~modelの中で一意になるような，小さな製造時のムラがある。
これらの製造時のムラは、~deviceを指紋収集するために利用し得る。
`ACCELPRINT$r
`MOBILESENSORS$r
◎
Sensors can provide information that can uniquely identify the device using those sensors. Every concrete sensor model has minor manufacturing imperfections and differences that will be unique for this model. These manufacturing variations and imperfections can be used to fingerprint the device [ACCELPRINT] [MOBILESENSORS].
</p>

			</section>
			<section id="user-identifying">
<h4 title="User Identifying">4.1.5. 利用者の識別-法</h4>

<p>
`~sensor読取り$は、利用者を識別するためにも利用し得る
— 例えば，~smartphoneや装身-可能な~deviceの~motion~sensorの~dataから、個人の歩き~patternを推定することを介して。
◎
Sensor readings can be used to identify the user, for example via inferring individual walking patterns from smartphone or wearable device motion sensors' data.
</p>

			</section>
		</section>
		<section id="mitigation-strategies">
<h3 title="Mitigation Strategies">4.2. 軽減~策</h3>

~INFORMATIVE

<p>
この節では、この仕様の規範的な各~節にて指定される軽減~策のうち一部について，高levelな呈示【！＊】を与える。
◎
This section gives a high-level presentation of some of the mitigation strategies specified in the normative sections of this specification.
</p>

			<section id="secure-context">
<h4 title="Secure Context">4.2.1. ~secure文脈</h4>

<p>
`~sensor読取り$は、
`Secure Contexts^cite `POWERFUL-FEATURES$r
仕様により明示的に，［
~network攻撃者にとって高価値な~targetである
］ものとされている
【<a href="~SECURE-CONTEXT#threat-risks">~~参照</a>】
。
【！flagged ：<a href="~SECURE-CONTEXT#sandboxed-secure-browsing-context-flag">閲覧文脈~sandbox化( ~secure )~flag</a>？】
したがって，この仕様, その`拡張~仕様$に定義される~interfaceは、どれも`~secure文脈$の中に限り可用になる。
◎
Sensor readings are explicitly flagged by the Secure Contexts specification [POWERFUL-FEATURES] as a high-value target for network attackers. Thus all interfaces defined by this specification or extension specifications are only available within a secure context.
</p>

			</section>
			<section id="feature-policy">
<h4 title="Feature Policy">4.2.2. 特能~施策</h4>
<span id="browsing-context"></span>

<p>
`~sensor読取り$が利用者に馴染みのない文脈と共有されることによる~privacy~riskを避けるため、`~sensor読取り$は，［
所与の`~sensor型$用の`施策により制御される特能$
］の`利用は許容されて$いる`文書$用に限り可用になる。
詳細は `FEATURE-POLICY$r を見よ。
◎
To avoid the privacy risk of sharing sensor readings with contexts unfamiliar to the user, sensor readings are only available for the documents which are allowed to use the policy-controlled features for the given sensor type. See [FEATURE-POLICY] for more details.
</p>

			</section>
			<section id="focused-area">
<h4 title="Focused Area">4.2.3. ~focusされた区画</h4>

<span id="losing-focus"></span>
<p>
`~sensor読取り$は、次を満たす`作動中の文書$に限り可用になる
⇒
その生成元は`現在の被focus区画$が属する文書と`同じ生成元~domain$である。
◎
Sensor readings are only available for active documents whose origin is same origin-domain with the currently focused area document.
</p>

<p>
これは、［
`~focusを得た$要素を包含している`閲覧文脈$に対する盗読み攻撃
］の~riskを軽減するために行われる
— 例えば、利用者が，ある `iframe^e の中で［
第三者主体による支払い~serviceを利用して，~game内での購入を遂げる
］とき。
◎
This is done in order to mitigate the risk of a skimming attack against the browsing context containing an element which has gained focus, for example when the user carries out an in-game purchase using a third party payment service from within an iframe.
</p>

			</section>
			<section id="visibility-state">
<h4 title="Visibility State">4.2.4. 可視性~状態</h4>

<p>
`~sensor読取り$は、次を満たす`作動中の文書$に限り可用になる
⇒
`可視性~状態$ ~EQ `visible^l
◎
Sensor readings are only available for the active documents whose visibility state is "visible".
</p>

			</section>
			<section id="permissions">
<h4 title="Permissions API">4.2.5. 許可~API</h4>

<span id="permissioning"></span>

<p>
`~sensor読取り$への~accessは、
許可~API `PERMISSIONS$r により制御される。
~UAは、`~sensor読取り$への~accessを是認する際に，
<a href="~PERMISSIONS#new-information-about-the-users-intent">いくつかの判定基準</a>
を利用する。
~accessは、利用者に~promptすることなく是認され得ることに注意。
◎
Access to sensor readings are controlled by the Permissions API [PERMISSIONS]. User agents use a number of criteria to grant access to the readings. Note that access can be granted without prompting the user.
</p>

			</section>
		</section>
		<section id="mitigation-strategies-case-by-case">
<h3 title="Mitigation strategies applied on a case by case basis">4.3. 事例~別に適用される軽減~策</h3>

<p>
各`~sensor型$は、個別に査定される必要がある
— ［
それが可能化する各~利用-事例,
それの特定0の脅威~profile
］を織り込んで。
下に与える軽減~策のうち一部は、ある種の~sensor用には効果的になる一方で，ある種の利用-事例を邪魔する／まるごと防止するかもしれない。
◎
Each sensor type will need to be assessed individually, taking into account the use cases it enables and its particular threat profile. While some of the below mitigation strategies are effective for certain sensors, they might also hinder or altogether prevent certain use cases.
</p>

<p class="note">注記：
これらの軽減~策は、定常的にも一時的にも適用できる
— 例えば、利用者が特定の動作を遂げているとき／
脅威の~levelを増幅することが既知な他の~APIが利用-中にあるとき, 等々。
◎
Note: These mitigation strategies can be applied constantly or temporarily, for example when the user is carrying out specific actions, when other APIs which are known to amplify the level of the threat are in use, etc.
</p>

			<section id="limit-max-frequency">
<h4 title="Limit maximum sampling frequency">4.3.1. 最大~標本化~frequencyを制限する</h4>

<p>
~UAは、ある種の脅威を軽減するためとして，最大`標本化~frequency$を制限してもヨイ。
どの上限を選ぶかは、［
`~sensor型$,
~UAが保護しようと試行している脅威の種類,
予期される攻撃者の資源,
等々
］に依存する。
◎
User agents may mitigate certain threats by limiting the maximum sampling frequency. What upper limit to choose depends on the sensor type, the kind of threats the user agent is trying to protect against, the expected resources of the attacker, etc.
</p>

<p>
最大`標本化~frequency$を制限することは、低-待時間や高-密度な~dataに依拠する利用-事例を防止する。
◎
Limiting the maximum sampling frequency prevents use cases which rely on low latency or high data density.
</p>

			</section>
			<section id="stop-sensor">
<h4 title="Stop the sensor altogether">4.3.2. ~sensorをまるごと停止する</h4>

<p>
これは明らかに最終手段ではあるが、一時的であるなら極めて効果的になり得る。
例えば、利用者が異なる［
生成元（ `rfc6454$r ）／~app
］に属する資格証を手入力している間は，~password盗読みの試みを防止するなど。
◎
This is obviously a last-resort solution, but it can be extremely effective if it’s temporal, for example to prevent password skimming attempts when the user is entering credentials on a different origin ([rfc6454]) or in a different application.
</p>

			</section>
			<section id="limit-number-of-delivered-readings">
<h4 title="Limit number of delivered readings">4.3.3. 送達される読取りの回数を制限する</h4>

<p>
<a href="#limit-max-frequency">最大~標本化~frequencyを制限する</a>
代替として
— ~sensorがどの~frequencyで~pollされるかに関わらず —
~Web~app開発者に送達される`~sensor読取り$の回数を制限する。
これは、供される~dataの量を増やすことなく，`標本化~frequency$を高めるため低-待時間が要件にある利用-事例を許容する。
◎
An alternative to limiting the maximum sampling frequency is to limit the number of sensor readings delivered to Web application developer, regardless of what frequency the sensor is polled at. This allows use cases which have low latency requirement to increase sampling frequency without increasing the amount of data provided.
</p>

<p>
中間的な読取りを破棄することは、ある種の利用-事例
— ある種類の~filterに依拠するものなど —
を防止する。
◎
Discarding intermediary readings prevents certain use cases, such as those relying on certain kinds of filters.
</p>

			</section>
			<section id="reduce-accuracy">
<h4 title="Reduce accuracy">4.3.4. 正確度を抑制する</h4>

<p>
`~sensor読取り$や~sensor`読取り時刻印$の正確度を抑制することは、ある種の脅威を軽減する一助になり得る。
したがって，~UAは、~sensor~dataの不必要に~verboseな読出しを供するベキでない。
◎
Reducing the accuracy of sensor readings or sensor reading timestamps might also help mitigate certain threats, thus user agents should not provide unnecessarily verbose readouts of sensors data.
</p>

<p class="note">注記：
不正確度は、［
`~sensor読取り$上で遂げられる演算 ／
`読取り時刻印$から計算される時間差
］においても更に増すので、この軽減~策は，ある種の利用-事例に影響し得る。
◎
Note: Inaccuracies will further increase for operations carried out on the sensor readings, or time deltas calculated from the timestamps. So, this mitigation strategy can affect certain use cases.
</p>

<p class="note">注記：
`~sensor読取り$に~randomな偏りを追加することにも類似な効果があるが、実施には利用されるベキでない
— 追加された~noiseを~filterで濾すのは容易なので。
◎
Note: while adding random bias to sensor readings has similar effects, it shouldn’t be used in practice as it is easy to filter out the added noise.
</p>

			</section>
			<section id="inform-user">
<h4 title="Keep the user informed about API use">4.3.5. ~APIの利用について利用者に伝え続ける</h4>

<p>
~UAは、~APIの［
現在の／過去の
］利用について利用者に伝え続けることにしてもヨイ。
◎
User agents may choose to keep the user informed about current and past use of the API.
</p>

<p class="note">注記：
これは、実際`~sensor読取り$の~logをとり続けることは含意しない
— それには自前の課題がある。
◎
Note: this does not imply keeping a log of the actual sensor readings which would have issues of its own.
</p>

			</section>
		</section>
	</section>
	<section id="concepts">
<h2 title="Concepts">5. 各種~概念</h2>

		<section id="concepts-sensors">
<h3 title="Sensors">5.1. ~sensor</h3>

<p>
用語
`~device~sensor@
は、~deviceの下層の物理的~sensor~instanceを指す。
◎
The term device sensor refers to a device’s underlying physical sensor instance.
</p>

<p>
`~device~sensor$は、物理量を計測して，対応する
`~sensor読取り@
（ `sensor reading^en ）を供する
— それは、環境についての情報の源である。
◎
A device sensor measures a physical quantities and provides a corresponding sensor reading which is a source of information about the environment.
</p>

<p>
各`~sensor読取り$は、`~device~sensor$が［
`読取り時刻印@
と呼ばれる，各~計測回の時刻
］に計測した物理量の
`読取り値@
たちから構成される。
◎
Each sensor reading is composed of the values of the physical quantity measured by the device sensor at time tn which is called the reading timestamp.
</p>

<p>
`~device~sensor$が空間的な計測を遂行する場合（例：加速度, 角速度）、
`~device~sensor$の`~sensor読取り$用の基準~frameを表現する
`局所~座標系@
内に解決するモノトスル。
そのような`~sensor読取り$を供する`~device~sensor$は、
`空間的~sensor@
と称される。
◎
If the device sensor performs a spatial measurement (e.g. acceleration, angular velocity), it must be resolved in a local coordinate system that represents a reference frame for the device sensor's sensor readings. A device sensor that provides such sensor readings is referred to as spatial sensor.
</p>

<p>
`空間的~sensor$は、同時的な計測を遂行できる直交な軸の本数に依存して
`単軸@,
`二軸@,
`三軸@
いずれにもなり得る。
◎
A spatial sensor can be uniaxial, biaxial, or triaxial, depending on the number of orthogonal axes in which it can perform simultaneous measurements.
</p>

<p>
~scalar物理量（例【！i.e.】：温度）は、解決~用の`局所~座標系$を要求しない。
◎
Scalar physical quantities (i.e. temperature) do not require a local coordinate system for resolution.
</p>

<p>
通常は携帯~deviceで利用される`局所~座標系$は、~Cartesian座標系であり，~deviceの~screenに相対的に定義される
,
その ~X軸, ~Y軸は~screenの各 次元に平行になり，~Z軸は~screen面に垂直になる。
◎
The local coordinate system normally used in a mobile device is a Cartesian coordinate system, which is defined relative to the device’s screen, so that X and Y axes are parallel to the screen dimentions and Z axis is perpendicular to the screen surface.
</p>

<p>
用語
`~platform~sensor@
は、~UAが［
1 個~以上の`~device~sensor$を出自にする単独の`~sensor型$
］用に`~sensor読取り$を得るためにヤリトリできるような，~platform~interfaceを指す。
◎
The term platform sensor refers to platform interfaces, with which the user agent interacts to obtain sensor readings for a single sensor type originated from one or more device sensors.
</p>

<p>
`~platform~sensor$は、下層の~platformにより定義される（例：~native~sensor枠組み内で）ことも，~UAにより定義されることもある
— `~device~sensor$への直な~accessを有するならば。
◎
Platform sensor can be defined by the underlying platform (e.g. in a native sensors framework) or by the user agent, if it has a direct access to device sensor.
</p>

<p>
実装の視点からは、`~platform~sensor$は，対応する`~device~sensor$用の~software~proxyとして扱える。
下層の~platformが~supportするならば、複数の`~platform~sensor$が同じ`~device~sensor$に同時的にヤリトリする可能性もある。
◎
From the implementation perspective platform sensor can be treated as a software proxy for the corresponding device sensor. It is possible to have multiple platform sensors simultaneously interacting with the same device sensor if the underlying platform suppports it.
</p>

<p>
単純な事例では，`~platform~sensor$は単独の`~device~sensor$に対応するが、供された`~sensor読取り$が~software内で遂行された`~sensor融合$の産物である場合，`~platform~sensor$は［
`~sensor融合$の処理-に孕まれる`~device~sensor$の集合
］に対応する。
◎
In simple cases, a platform sensor corresponds to a single device sensor, but if the provided sensor readings are a product of sensor fusion performed in software, the platform sensor corresponds to a set of device sensors involved in the sensor fusion process.
</p>

<p>
`~sensor読取り$と［
それに対応する，計測される物理量
］との不一致は、
`較正@
を通して正される
— この不一致は、製造~時に起こり得る。
一部の~sensorは、未知な不一致を補償するため，動的な較正を要求し得る。
◎
Discrepancies between a sensor reading and the corresponding physical quantity being measured are corrected through calibration that can happen at manufacturing time. Some sensors can require dynamic calibration to compensate unknown discrepancies.
</p>

<p class="note">注記：
`~sensor融合$を通して作成される`~platform~sensor$は、~virtual~sensor, あるいは合成な~sensorとも呼ばれる。
しかしながら，実用的には、この仕様は，それらを区別しない。
◎
Note: platform sensors created through sensor fusion are sometimes called virtual or synthetic sensors. However, the specification doesn’t make any practical distinction between them.
</p>

		</section>
		<section id="concepts-sensor-types">
<h3 title="Sensor Types">5.2. ~sensor型</h3>

<p>
計測される物理量は、`~sensor型$ごとに異なる
— 温度, 気圧, 心拍数, 光度など。
◎
Different sensor types measure different physical quantities such as temperature, air pressure, heart-rate, or luminosity.
</p>

<p>
この仕様の目的においては、各`~sensor型$は［
`高level$,
`低level$
］の 2 つに大別される：
◎
For the purpose of this specification we distinguish between high-level and low-level sensor types.
</p>

<ul>
	<li>
~sensorのうち，その実装により特徴付けられる`~sensor型$は、【！＊】
`低level@
な~sensorと称される。
例えば， `Gyroscope^I は`低level$な`~sensor型$である。
◎
Sensor types which are characterized by their implementation are referred to as low-level sensors. For example a Gyroscope is a low-level sensor type.
</li>
	<li>
~sensorのうち，その`~sensor読取り$の名前を継ぐもの【！＊】は、その実装に関わらず，
`高level@
な~sensorであるとされる。
一例として，地理所在~sensorは利用者の所在についての情報を供するが、この~dataが得られる精確な手段は，目的を以って不透明なままにされており（それは、［
~GPS集積回路, ~network基地局三角測量, ~wifi~network, 等々，あるいはこれら任意の組合n
］のどれからも得られ得る）、実装に特有な様々な経験則に依存する。
`高level$な~sensorは、一般に，`低level$な~sensorに何らかの~algoを適用した結果【！fruits】
— 例えば，歩数計は~gyroscopeの出力のみを利用して築ける —
であるか，`~sensor融合$のそれである。
◎
Sensors named after their readings, regardless of the implementation, are said to be high-level sensors. For instance, geolocation sensors provide information about the user’s location, but the precise means by which this data is obtained is purposefully left opaque (it could come from a GPS chip, network cell triangulation, wifi networks, etc. or any combination of the above) and depends on various, implementation-specific heuristics. High-level sensors are generally the fruits of applying algorithms to low-level sensors—for example, a pedometer can be built using only the output of a gyroscope—or of sensor fusion.
</li>
</ul>

<p>
とは言え、`~sensor型$における
`高level$,
`低level$
の区別は，いくぶん恣意的であり、この 2 つの間の線引きは，ぼやけていることが多い。
一例として，気圧を計測する気圧計は、それが［
圧抵抗圧力~sensorと温度~sensorが成す`~sensor融合$
］の産物であっても，最も共通的な目的においては`低level$と見なされる
— それを構成する~sensorを公開しても実用的な目的は果たさないので（圧電~sensorの温度を気にする者は居なかろう）。
気圧高度計も、おそらく同じ分類に入る。
一方，構造不明な高度計は、その~dataを気圧計からも~GPS信号からも取得することがあり、明瞭に，`高level$な`~sensor型$に分類されることになる。
◎
That said, the distinction between high-level and low-level sensor types is somewhat arbitrary and the line between the two is often blurred. For instance, a barometer, which measures air pressure, would be considered low-level for most common purposes, even though it is the product of the sensor fusion of resistive piezo-electric pressure and temperature sensors. Exposing the sensors that compose it would serve no practical purpose; who cares about the temperature of a piezo-electric sensor? A pressure-altimeter would probably fall in the same category, while a nondescript altimeter—which could get its data from either a barometer or a GPS signal—would clearly be categorized as a high-level sensor type.
</p>

<p>
この区別は，いくぶんぼやけているので、この仕様に対する拡張（
<a href="#extensibility">§ 拡張能</a>
を見よ）は、対象になる`~sensor型$用に，その専門分野に特有な［
`高level$, `低level$
］~sensorの定義を供することが奨励される。
◎
Because the distinction is somewhat blurry, extensions to this specification (see §10 Extensibility) are encouraged to provide domain-specific definitions of high-level and low-level sensors for the given sensor types they are targeting.
</p>

<p>
相異なる`~sensor型$からの`~sensor読取り$は、
`~sensor融合@
（ `sensor fusion^en ）と呼ばれる処理-を通して，一緒に結合され得る。
この処理-は、`高level$な, または より正確aな~dataを供する（待時間が増える~costと引き換えになることが多い）。
例えば，［
`三軸$からなる磁力計の`~sensor読取り$
］は、［
そのための正しい軸受を供する，加速度計の`~sensor読取り$
］と結合される必要がある。
◎
Sensor readings from different sensor types can be combined together through a process called sensor fusion. This process provides higher-level or more accurate data (often at the cost of increased latency). For example, the readings of a triaxial magnetometer needs to be combined with the readings of an accelerometer to provide a correct bearing.
</p>

<p>
~sensorには、［
`~smart~sensor@
／
`~sensor~hub@
］と呼ばれる［
~hardware~levelで`較正$と`~sensor融合$を遂げる，組込みの算出-資源
］を備えるものもある。
それは、処理-に割かれる~CPU資源を~~節約し, ~battery消費を抑える。
◎
Smart sensors and sensor hubs have built-in compute resources which allow them to carry out calibration and sensor fusion at the hardware level, freeing up CPU resources and lowering battery consumption in the process.
</p>

<p>
`~sensor融合$は、［
~hardware~levelでは遂行し得ない／~appに特有な`~sensor融合$~algoが要求される
］場合には，~software内で遂げられることもある。
◎
Sensor fusion can also be carried out in software if it cannot be performed at the hardware level or if an application-specific fusion algorithm is required.
</p>

		</section>
		<section id="concepts-default-sensor">
<h3 title="Default sensor">5.3. 既定の~sensor</h3>

<p>
汎用~sensor~APIは、最も共通的な利用-事例を単直にするよう設計されている
— より複階的な利用-事例も可能化しつつ。
◎
The Generic Sensor API is designed to make the most common use cases straightforward while still enabling more complex use cases.
</p>

<p>
今日にて配備されている ほとんどの~deviceは、同じ`~sensor型$の`~sensor読取り$を供する複数個の`~device~sensor$を備えてはいない。
複数個の類似な`~device~sensor$を要求する利用-事例は稀であり、一般に，特定の`~sensor型$
— 2-in-1【一台二役】~laptop内の複数の加速度計など —
に限られる。
◎
Most of devices deployed today do not carry more than one device sensor providing sensor readings of the same type. The use cases which require a set of similar device sensors are rare and generally limited to specific sensor types, such as multiple accelerometers in 2-in-1 laptops.
</p>

<p>
したがって，~deviceの既定の（かつ一意になることが多い）`~device~sensor$とヤリトリするのを容易にするため、この~APIは，各`~sensor型$に対し，単純に対応する［
`Sensor$I の下位class
］を~instance化する。
◎
The API therefore makes it easy to interact with the device’s default (and often unique) sensor for each type simply by instantiating the corresponding Sensor subclass.
</p>

<p>
~~実際，［
所与の`~sensor型$の`~device~sensor$のうち，特定0の一つを識別する
］ような，特有な情報が伴われない下では、~UAが
`既定の~sensor@
を選ぶことになる。
◎
Indeed, without specific information identifying a particular sensor of a given type, the default sensor is chosen by the user agent.
</p>

<p>
下層の~platformが`既定の~sensor$を見出す~interfaceを供する場合、~UAは，~platformから提供された~sensorを選ぶモノトスル。
他の場合、~UA自身が［
~device上に在る`~device~sensor$のうち，どれが`既定の~sensor$になるか
］を定義する。
◎
If the underlying platform provides an interface to find the default sensor, the user agent must choose the sensor offered by the platform, otherwise the user agent itself defines which of the sensors present on the device is the default sensor.
</p>

<div class="example">
<p>
既定の加速度計の変化を~listenする例：
◎
Listening to the default accelerometer changes:
</p>

<pre class="js-code">
let %sensor = new Accelerometer({ frequency: 30 });

%sensor.onreading = () =&gt; { ... }
%sensor.start();
</pre>
</div>

<p class="note">注記：
この仕様に対する拡張は、`既定の~sensor$を定義しないことにしてもヨイ
— そうしてもイミを成さないならば。
例えば，`~sensor型$ `geolocation^l （地理所在）用の既定の`~device~sensor$を明示的に定義しても，イミを成さない
— その~interfaceの実装は、複数の~backendを利用できるので。
◎
Note: extension to this specification may choose not to define a default sensor when doing so wouldn’t make sense. For example, it does not make sense to explicitly define a default sensor for geolocation sensor type as the implementation of its interface can use multiple backends.
</p>

<p>
同じ~device上で，同じ`~sensor型$に対応する`~device~sensor$が複数 共存し得る事例では、拡張~仕様は，それぞれを一意に識別する仕方を定義する必要がある。
◎
In cases where multiple device sensors corresponding to the same type may coexist on the same device, specification extension will have to define ways to uniquely identify each one.
</p>

<div class="example">
<p>
例えば、
`pressure of the left rear tire^en
（空気圧, 左後輪の）を検査するとき：
◎
For example checking the pressure of the left rear tire:
</p>

<pre class="js-code">
var %sensor = new DirectTirePressureSensor(
   { position: "rear", side: "left" }
);
%sensor.onreading = _ =&gt; console.log(%sensor.pressure);
%sensor.start();
</pre>
</div>

		</section>
		<section id="concepts-reading-change-threshold">
<h3 title="Reading change threshold">5.4. 読取り変化~threshold</h3>

<p>
`~platform~sensor$は、`読取り変化~threshold$を考慮する下で，~UAに`~sensor読取り$を報告する。
◎
A platform sensor reports readings to the user agent considering the reading change threshold.
</p>

<p>
`読取り変化~threshold@
は、［
`~device~sensor$の計測における変化は、対応する`~sensor読取り$を更新するほど十分~有意になるかどうか
］を指示する値を指す。
◎
The reading change threshold refers to a value which indicates whether or not the changes in the device sensor's measurements were significant enough to update the corresponding sensor readings.
</p>

<p>
`読取り変化~threshold$
値は、周囲の［
~software／~hardware
］環境による拘束に依存する
— 例：~software電力~消費~最適化や下層の`~device~sensor$の正確度。
◎
The threshold value depends on the surrounding software and hardware environment constraints, e.g., software power consumption optimizations or the underlying device sensor's accuracy.
</p>

		</section>
		<section id="concepts-sampling-and-reporting-frequencies">
<h3 title="Sampling Frequency and Reporting Frequency">5.5. 標本化~frequency, 報告ng~frequency</h3>

<p>
この仕様の目的においては、`~platform~sensor$用の
`標本化~frequency@
は，~UAが下層の~platformから`~sensor読取り$を得る~frequencyとして定義される。
◎
For the purpose of this specification, sampling frequency for a platform sensor is defined as a frequency at which the user agent obtains sensor readings from the underlying platform.
</p>

<p>
~UAは、一定の~rateで`~sensor読取り$を送達するよう，下層の~platformに要請できる
— それは、
`要請した標本化~frequency@
呼ばれる。
◎
The user agent can request the underlying platform to deliver readings at a certain rate which is called requested sampling frequency.
</p>

<p>
`標本化~frequency$は、下層の~platformがそれを~supportできるならば，`要請した標本化~frequency$に等しくなる。
◎
The sampling frequency is equal to the requested sampling frequency if the underlying platform can support it.
</p>

<p>
次に挙げる事例においては、`標本化~frequency$と`要請した標本化~frequency$は相違する：
◎
The sampling frequency differs from the requested sampling frequency in the following cases:
</p>

<ul>
	<li>
`要請した標本化~frequency$は、下層の~platformが~supportする`標本化~frequency$の上限／下限を超過している。
◎
the requested sampling frequency exceeds upper or lower sampling frequency bounds supported by the underlying platform.
</li>
	<li>
`読取り変化~threshold$の値は、［
`~device~sensor$の計測の一部は飛ばされ，`~sensor読取り$は更新されない
］ほどに有意であるとき。
◎
the threshold value is significant so that some of the device sensor's measurements are skipped and the sensor readings are not updated.
</li>
</ul>

<p>
具体【~sensorに対応する】 `Sensor$I ~obj用の
`報告ng~frequency@
は、この~objに向けて `reading$et ~eventが`発火され$る~frequencyとして定義される。
◎
The reporting frequency for a concrete Sensor object is defined as a frequency at which the "reading" event is fired at this object.
</p>

<p>
`Sensor$I ~objは、~UAが下層の~platformから新たな`~sensor読取り$を得るよりも高い~rateでは，それらに~accessし得ない
— したがって，所与の`~sensor型$用の`報告ng~frequency$は、`標本化~frequency$を決して超過しない。
◎
A Sensor object cannot access new readings at a higher rate than the user agent obtains them from the underlying platform, therefore the reporting frequency can never exceed the sampling frequency for the given sensor type.
</p>

		</section>
		<section id="concepts-can-expose-sensor-readings">
<h3 title="Conditions to expose sensor readings">5.6. ~sensor読取りを公開するための条件</h3>

<p>
~UAは、ある`作動中の文書$ %文書 に属する，ある`~sensor型$ %型 の `Sensor$I ~objに
`~sensor読取りを公開できる@
ことを確保するためには，次に挙げる
`義務的な条件@
すべてが満たされることを検証yするモノトスル。
◎
The user agent must verify that all mandatory conditions are satisfied to ensure it can expose sensor readings to the Sensor objects of a certain type that belong to a certain active document.
◎
The mandatory conditions are the following:
</p>

<ul>
	<li>
%文書 は、`~secure文脈$の`担当の文書$である。
◎
The given document is a responsible document of a secure context.
</li>
	<li>
%型 の`~sensor許可~名たち$を成すどの`許可~名$に対しても，対応する【許可~名が識別する`強力な特能$の】`許可~状態$ ~EQ `granted^l
◎
For each permission name from the sensor type's associated sensor permission names set, the corresponding permission’s state is "granted".
</li>
	<li>
%文書 の`可視性~状態$ ~EQ `visible^l
◎
Visibility state of the document is "visible".
</li>
	<li>
%型 に結付けられた どの`施策により制御される特能$ %特能 に対しても，
%文書 には %特能 の`利用は許容されて$いる
◎
The document is allowed to use all the policy-controlled features associated with the given sensor type.
</li>
	<li>
( `現在の被focus区画$が属する文書の生成元, %文書 の生成元 )
は`同じ生成元~domain$である。
◎
Currently focused area belongs to a document whose origin is same origin-domain with the origin of the given active document.
</li>
	<li>
`拡張~仕様$に
`特有な条件@
が満たされる
— `拡張~仕様$が追加する新たな`義務的な条件$は、ここに~hookされる。
◎
Specific conditions: The extension specifications that add new conditions hook into this specification at this point.
</li>
</ul>

<p class="note">注記：
~hardware資源を解放するするため、~UAは，［
`~sensor読取りを公開できる$ようになるまで，新たに可用な読取りについての通知を休止する
］よう，下層の`~platform~sensor$に要請できる／し得る。
◎
Note: In order to release hardware resources, the user agent can request underlying platform sensor to suspend notifications about newly available readings until it can expose sensor readings.
</p>

		</section>
	</section>
	<section id="model">
<h2 title="Model">6. ~model</h2>

		<section id="model-sensor-type">
<h3 title="Sensor Type">6.1. ~sensor型</h3>

<p>
各
`~sensor型@
には、次に挙げるものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`拡張~sensor~interface$たち</dt>
	<dd>
1 個~以上の`拡張~sensor~interface$
◎
A sensor type has one or more associated extension sensor interfaces.
</dd>

	<dt>`結付けられている~sensorたち@</dt>
	<dd>
【`~platform~sensor$たちが成す】`集合$。
◎
A sensor type has a set of associated sensors.
</dd>

	<dt>`既定の~sensor$</dt>
	<dd>
【ある`~device~sensor$, または定義されない場合は ε。】
◎
A sensor type may have a default sensor.
</dd>

	<dt>`~sensor許可~名たち@</dt>
	<dd>
いくつかの`許可~名$からなる`空$でない`集合$
◎
A sensor type has a nonempty set of associated permission names referred to as sensor permission names.
</dd>
	<dd class="note">注記：
複数の`~sensor型$が、同じ`許可~名$を共有し得る。
◎
Note: multiple sensor types may share the same permission name.
</dd>

	<dt>`~sensor許可~revocation~algo@</dt>
	<dd class="algorithm">
<p>
`許可~revocation~algo$
— それは、所与の
( `許可~名$  %許可~名 )
に対し，次を走らす：
◎
A sensor type has a permission revocation algorithm.
◎
To invoke the permission revocation algorithm with PermissionName permission_name, run the following steps:
</p>
		<ol>
			<li>
~EACH( %~sensor型 )
に対し
⇒
~IF［
%許可~名 ~IN %~sensor型 の`~sensor許可~名たち$
］
⇒
%~sensor型 に`結付けられている~sensorたち$を成す
~EACH( %~sensor )
に対し
⇒
`~sensor許可を~revokeする$( %~sensor )
◎
For each sensor_type whose permission names contains permission_name:
• For each sensor in sensor_type’s set of associated sensors,
•• Invoke revoke sensor permission with sensor as argument.
</li>
		</ol>
	</dd>

	<dt>`~sensor特能~名たち@</dt>
	<dd>
結付けられている`施策により制御される特能$を表す~tokenからなる`空$でない`集合$。
◎
A sensor type has a nonempty set of associated policy-controlled feature tokens referred to as sensor feature names.
</dd>
</dl>

		</section>
		<section id="model-sensor">
<h3 title="Sensor">6.2. ~sensor</h3>

<div>
<p>

現在の`閲覧文脈$の`~platform~sensor$には、次が結付けられる：
【“現在の” とは？】
</p>

<dl class="def-list">
	<dt>`作動化された~sensor~objたち@</dt>
	<dd>
【`Sensor$I ~objたちが成す】`集合$であり，初期~時には`空$とする
</dd>

	<dt>`最新な読取り~map@</dt>
	<dd>
最新な［
可用な`~sensor読取り$
］を保持する`~map$。
</dd>
</dl>

◎
The current browsing context's platform sensor has an associated set of activated sensor objects, which is initially empty and an associated latest reading map, which holds the latest available sensor readings.
</div>

<p class="note">注記：
~UAは、異なる`閲覧文脈$の間で，各自の`作動中の文書$の`生成元$は`同じ生成元~domain$である場合に限り［
`最新な読取り~map$,
`作動化された~sensor~objたち$
］を共有できる。
◎
Note: User agents can share the latest reading map and the activated sensor objects set between different contexts only if the origins of these contexts' active documents are same origin-domain.
</p>

<p>
どの時点であれ，`~platform~sensor$用の新たな`~sensor読取り$が得られたときは、次を走らすとする
⇒
~IF［
~UAは、現在の`閲覧文脈$にて`作動中の文書$に`~sensor読取りを公開できる$
］
⇒
`最新な読取りを更新する$( `~platform~sensor$, `~sensor読取り$ )
◎
Any time a new sensor reading for a platform sensor is obtained and if the user agent can expose sensor readings to the current browsing context's active document, the user agent invokes update latest reading with the platform sensor and the sensor reading as arguments.
</p>

<p>
`最新な読取り~map$は、`~entry$として
«[ `timestamp^l → %時刻印 ]»
を包含する。
%時刻印 は、`読取り時刻印$の見積もりを［
`時刻~起点$からの~millisecondsで表出される，高-分解能な時刻印
］として与える。
◎
The latest reading map contains an entry whose key is "timestamp" and whose value is a high resolution timestamp that estimates the reading timestamp expressed in milliseconds since the time origin.
</p>

<p class="note">注記：
`読取り時刻印$の見積もりの正確度は、それを公開する下層の~platform~interfaceに依存する。
◎
Note: The accuracy of the reading timestamp estimate depends on the underlying platform interfaces that expose it.
</p>

<p>
`最新な読取り~map$[ `timestamp^l ] は、初期~時には ~NULL に設定される
— `最新な読取り~map$が，以前の`~sensor読取り$を~cacheしていない限り。
◎
The latest reading["timestamp"] is initially set to null, unless the latest reading map caches a previous reading.
</p>

<p>
`最新な読取り~map$を成す他の`~entry$は、各種`~platform~sensor$により計測された物理量の値を保持する。
これらの`~entry$の`~key$mapは、`~sensor型$に結付けられている`拡張~sensor~interface$に定義される`属性$の`識別子$に合致するモノトスル。
`属性$の取得子の返り値は、次を呼出すことで容易に得られる
⇒
`最新な読取り~mapから値を取得する$( `拡張~sensor~interface$を実装している~obj, `属性$の`識別子$ )
◎
The other entries of the latest reading map hold the values of the different quantities measured by the platform sensor. The keys of these entries must match the attribute identifier defined by the sensor type's associated extension sensor interface. The return value of the attribute getter is easily obtained by invoking get value from latest reading with the object implementing the extension sensor interface and the attribute identifier as arguments.
</p>

<p>
`最新な読取り~map$を成す どの`~entry$も，その`値$mapは、初期~時には ~NULL に設定されるとする。
◎
The value of all latest reading entries is initially set to null.
</p>

<p>
各`~platform~sensor$には、`要請した標本化~frequency$が結付けられる
— それは、初期~時には~NULL とする。
◎
A platform sensor has an associated requested sampling frequency which is initially null.
</p>

<p>
`空$でない`作動化された~sensor~objたち$に対しては、
`要請した標本化~frequency$は
`最適な標本化~frequency@
に等しい
— それは、~UAにより，［
`作動化された~sensor~objたち$が`供した~frequency$と
下層の~platformが定義する`標本化~frequency$の上限, 下限
］を織り込んで見積もられる。
◎
For a nonempty set of activated sensor objects the requested sampling frequency is equal to optimal sampling frequency, which is estimated by the user agent taking into account provided frequencies of activated Sensors and sampling frequency bounds defined by the underlying platform.
</p>

<p class="note">注記：
例えば，~UAは、`最適な標本化~frequency$を［
各 `供した~frequency$が成す集合の
`Least Common Denominator (LCD)^en 【！最小公分母】
］を［
下層の~platformにより定義される`標本化~frequency$の上限, 下限
］で切り詰めた結果として見積もってもよい。
◎
Note: For example, the user agent may estimate optimal sampling frequency as a Least Common Denominator (LCD) for a set of provided frequencies capped by sampling frequency bounds defined by the underlying platform.
</p>

<div class="example">

<p>
<a href="#model">上で述べた~model</a>のアリな実装を，次の例に示す。
◎
This example illustrates a possible implementation of the described Model.
</p>

<p>
下の図式では、異なる 2 つの`閲覧文脈$ それぞれにおいて`作動化された~sensor~objたち$が，単独の`~device~sensor$とヤリトリする。
◎
In the diagram below several activated Sensor objects from two different browsing contexts interact with a single device sensor.
</p>


【！ generic_sensor_model.png 】
<div class="ex-model">
	<div class="ex-model-bc" style="top:0; left:0;">
<div>閲覧文脈 1</div>

		<div class="ex-model-box" style="top:2em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 1 Hz
<li>`state$sl = `activated^l
</ul>
		</div>
		<div class="ex-model-box" style="top:8em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 10 Hz
<li>`state$sl = `activated^l
</ul>
		</div>
	</div>

	<div class="ex-model-line" style="width:4em; height:4em; left:12em; top:4em;"></div>

	<div class="ex-model-box" style="top:2em; left:17em;">
<div>~platform~sensor</div>
<ul>
<li>要請された標本化~frequency = 10 Hz
<li>作動化された~sensor~obj
<li>最新な読取り
</ul>
	</div>

	<div class="ex-model-bc" style="top:15em; left:0;">
<div>閲覧文脈 2</div>
		<div class="ex-model-box" style="top:2em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 1 Hz
<li>`state$sl = `activated^l
</ul>
		</div>
		<div class="ex-model-box" style="top:8em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 1 Hz
<li>`state$sl = `idle^l
</ul>
		</div>
	</div>
	<div class="ex-model-box" style="top:17em; left:17em;">
<div>~platform~sensor</div>
<ul>
<li>要請された標本化~frequency = 1 Hz
<li>作動化された~sensor~obj
<li>最新な読取り
</ul>
	</div>
	<div class="ex-model-line" style="width:4em; height:4em; left:12em; top:19em; border-right-color:transparent;"></div>

	<div class="ex-model-line" style="width:10.5em; height:10.5em; left:23em; top:5em;"></div>

	<div class="ex-model-box" style="top:6em; left:36em;">
<div>~device~sensor</div>
`sensor_parts1@
	</div>

</div>

<p>
<a href="#sensor-lifecycle">遊休中~状態</a>（ `idle^l ）にある `Sensor$I ~objは、`~platform~sensor$にて`作動化された~sensor~objたち$に含まれないので，`~device~sensor$とはヤリトリしない。
◎
The Sensor object in "idle" state is not among the platform sensor's activated sensor objects and thus it does not interact with the device sensor.
</p>

<p>
この例には、`閲覧文脈$ごとに`~platform~sensor$~instanceがある。
◎
In this example there is a platform sensor instance per browsing context.
</p>

<p>
`最新な読取り~map$は、同じ`閲覧文脈$からの `Sensor$I ~obj間で共有され，対応する`~platform~sensor$に`要請した標本化~frequency$に等しい~rateで更新される。
◎
The latest reading map is shared between Sensor objects from the same context and is updated at rate equal to requested sampling frequency of the corresponding platform sensor.
</p>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

		<section id="the-sensor-interface">
<h3 title="The Sensor Interface">7.1. `Sensor^I ~interface</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(DedicatedWorker, Window)]
interface `Sensor@I : `EventTarget$I {
  readonly attribute `boolean$ `activated$m;
  readonly attribute `boolean$ `hasReading$m;
  readonly attribute `DOMHighResTimeStamp$I? `timestamp$m;
  void `start$m();
  void `stop$m();
  attribute `EventHandler$I `onreading$m;
  attribute `EventHandler$I `onactivate$m;
  attribute `EventHandler$I `onerror$m;
};

dictionary `SensorOptions@I {
  `double$ `frequency@m;
};
</pre>

<p>
各 `Sensor$I ~objには、`~platform~sensor$が結付けられる。
◎
A Sensor object has an associated platform sensor.
</p>

<p>
この仕様に言及される`~task$用の`~task源$は、
`~sensor~task源@
とする。
◎
The task source for the tasks mentioned in this specification is the sensor task source.
</p>

<div class="example">
<p>
次の例では、~UAは先ず，`~sensor読取り$に~accessする許可があるかどうか検査してから、加速度計~sensorを構築して，［
新たに可用にされた`~sensor読取り$についての［
`~platform~sensor$の作動化, ~error条件, 通知
］用の`~event$を取得する
］ための`~event~listener$を追加する。
この例は、`~platform~sensor$を~hostしている~deviceの それまでに計測された最大な加速度を~logする。
◎
In the following example, firstly, we check whether the user agent has permission to access sensor readings, then we construct accelerometer sensor and add event listeners to get events for platform sensor activation, error conditions and notifications about newly available sensor readings. The example measures and logs maximum total acceleration of a device hosting the platform sensor.
</p>

<p>
対応する `Sensor$I ~interfaceの`~event~handler$属性~用の`~event~handler~event型$は、
<a href="#event-handlers">§ ~event~handler</a>
に定義される。
◎
The event handler event types for the corresponding Sensor Interface's event handler attributes are defined in Event handlers section.
</p>

<pre class="js-code">
navigator.permissions.query({ name: 'accelerometer' }).then(%result =&gt; {
    if (%result.state === 'denied') {
        console.log('加速度計~sensorを利用する許可は否認されました。');
        return;
    }

    let %acl = new Accelerometer({frequency: 30});
    let %max_magnitude = 0;
    %acl.addEventListener('activate', () =&gt; console.log('計測する用意ができました'));
    %acl.addEventListener('error', %error =&gt; console.log(~BQ~error： ${%error.name}~BQ));
    %acl.addEventListener('reading', () =&gt; {
        let %magnitude = Math.hypot(%acl.x, %acl.y, %acl.z);
        if (%magnitude &gt; %max_magnitude) {
            %max_magnitude = %magnitude;
            console.log(~BQ最大値： ${%max_magnitude} m/s2~BQ);
        }
    });
    %acl.start();
});
</pre>
<!-- 
Permission to use accelerometer sensor is denied.
 -->
</div>

			<section id="sensor-lifecycle">
<h4 title="Sensor lifecycle">7.1.1. `Sensor^I の~lifecycle</h4>


<figure>

<div id="_ex-lifecycle">
	<div class="ex-ends">開始</div>
	<div class="ex-transition">↓<a href="#extension-sensor-interface">構築-</a></div>
	<div class="ex-state">遊休中（ `idle^l ）</div>
	<div class="ex-transition">
<span>↓`start()$m</span>
<span>↑`onerror$m</span>
	</div>
	<div class="ex-state">作動化-中（ `activating^l ）</div>
	<div class="ex-transition">↓</div>
	<div class="ex-state">作動化-済み（ `activated^l ）</div>
	<div class="ex-transition">
<span >↓`stop()$m／`onerror$m</span>
	</div>
	<div class="ex-ends">（ “遊休中” へ戻る）</div>
</div>

<figcaption>
~sensorの~lifecycleを表す図式
◎
Sensor lifecycle
</figcaption>
</figure>

<p class="note">注記：
上の図式~内の各~nodeは、
`Sensor$I ~objの各 状態（括弧内に示される `state$sl 値）を表現する。
それらは、下層の［
`~platform~sensor$／`~device~sensor$
］にアリな状態と混同されるベキでない。
◎
Note: the nodes in the diagram above represent the states of a Sensor object and they should not be confused with the possible states of the underlying platform sensor or device sensor.
</p>

			</section>
			<section id="sensor-garbage-collection">
<h4 title="Sensor garbage collection">7.1.2. `Sensor^I の~garbage収集</h4>

<p>
`Sensor$I ~objは、次のいずれかを満たす間は~garbage収集しないモノトスル：
◎
↓</p>

<ul>
	<li>
［
`state$sl ~EQ `activating^l
］~AND［［
`activate$et【！原文は `activated^et】 ／ `reading$et ／ `error$et
］~event用に登録された~event~listenerがある
◎
A Sensor object whose [[state]] is "activating" must not be garbage collected if there are any event listeners registered for "activated" events, "reading" events, or "error" events.
</li>
	<li>
［
`state$sl ~EQ `activated^l
］~AND［［
`reading$et ／ `error$et
］~event用に登録された~event~listenerがある
］
◎
A Sensor object whose [[state]] is "activated" must not be garbage collected if there are any event listeners registered for "reading" events, or "error" events.
</li>
</ul>

<p>
`Sensor$I ~objのうち［
その `state$sl ~IN { `activated^l, `activating^l }
］を満たすもの %O が~garbage収集されるときは、~UAは次を呼出すモノトスル
⇒
`~sensor~objを非作動化する$( %O )
◎
When a Sensor object whose [[state]] is "activated" or "activating" is garbage collected, the user agent must invoke deactivate a sensor object with this object as argument.
</p>

			</section>
			<section id="sensor-internal-slots">
<h4 title="Sensor internal slots">7.1.3. `Sensor^I の内部~slot</h4>

<p>
`Sensor$I の各~instanceは、次の表に述べる内部~slotを伴って作成される：
◎
Instances of Sensor are created with the internal slots described in the following table:
</p>

<div>
<table id="sensor-slots" class="grid-table"><thead><tr>
<th>内部~slot
<th>値~型
<th>初期~値
<th>記述（規範的でない）
</thead><tbody>

<tr><td>`state@sl
<td>文字列
<td>`idle^l
<td>
`Sensor$I ~objの現在の状態
— 次のいずれかをとる
⇒
`idle^l,
`activating^l,
`activated^l

<tr><td>`frequency@sl
<td>~NULL または `double^c
<td>~NULL
<td>
<p>
~frequencyを~in-Hzで表現する。
［
結付けられた`~platform~sensor$用の`要請した標本化~frequency$を計算する／
この `Sensor$I ~obj用の`報告ng~frequency$の上限を定義する
］ために利用される。
</p>

<p>
この~slotは、供された
`SensorOptions$I の `frequency$m 値を保持する。
</p>

<tr><td>`lastEventFiredAt@sl
<td>~NULL または `double^c
<td>~NULL
<td>
<p>
`Sensor$I ~objの観測器へ送信された最新な`~sensor読取り$の［
`時刻~起点$からの~millisecondsで表出される，高-分解能な時刻印
］。
</p>

<tr><td>`pendingReadingNotification@sl
<td>真偽値
<td>~F
<td>
新たな`~sensor読取り$が報告された後，観測器【すなわち `Sensor$I ~obj】に通知される必要があるかどうかを指示する。
</tbody></table>

◎
Internal Slot
• Description (non-normative)
◎
[[state]]
• The current state of the Sensor object which is one of "idle", "activating", or "activated". It is initially "idle".
◎
[[frequency]]
• A double representing frequency in Hz that is used to calculate the requested sampling frequency for the associated platform sensor and to define the upper bound of the reporting frequency for this Sensor object.
• This slot holds the provided SensorOptions.frequency value. It is initially unset.
◎
[[lastEventFiredAt]]
• The high resolution timestamp of the latest sensor reading that was sent to observers of the Sensor object, expressed in milliseconds that passed since the time origin. It is initially null.
◎
[[pendingReadingNotification]]
• A boolean which indicates whether the observers need to be notified after a new sensor reading was reported. It is initially false.
</div>

			</section>
			<section id="sensor-activated">
<h4>7.1.4. `activated@m</h4>

<p>
取得子は、次を走らすモノトスル：
◎
The getter of the activated attribute must run these steps:
</p>

<ol>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
此れの `state$sl ~EQ `activated^l
◎
If this.[[state]] is "activated", return true.
◎
Otherwise, return false.
</li>
</ol>

			</section>
			<section id="sensor-has-reading">
<h4>7.1.5. `hasReading@m</h4>

<p>
取得子は、次を走らすモノトスル：
◎
The getter of the hasReading attribute must run these steps:
</p>

<ol>
	<li>
%時刻印 ~LET `最新な読取り~mapから値を取得する$( 此れ, `timestamp^l )
◎
Let timestamp be the result of invoking get value from latest reading with this and "timestamp" as arguments.
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%時刻印 ~NEQ ~NULL
◎
If timestamp is not null, return true.
◎
Otherwise, return false.
</li>
</ol>

			</section>
			<section id="sensor-timestamp">
<h4>7.1.6. `timestamp@m</h4>

<p>
`読取り時刻印$を表現する。
取得子は、次の結果を返す
⇒
`最新な読取り~mapから値を取得する$( 此れ, `timestamp^l )
◎
The getter of the timestamp attribute returns the result of invoking get value from latest reading with this and "timestamp" as arguments. It represents a reading timestamp.
</p>

			</section>
			<section id="sensor-start">
<h4>7.1.7. `start()@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The start() method must run these steps:
</p>

<ol>
	<li>
~IF［
此れ . `state$sl ~IN { `activating^l, `activated^l }
］
⇒
~RET
◎
Let sensor_state be the value of sensor_instance.[[state]].
◎
If sensor_state is either "activating" or "activated", then return.
</li>
	<li>
此れ . `state$sl ~SET `activating^l
◎
Set sensor_instance.[[state]] to "activating".
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run these sub-steps in parallel:
</p>
		<ol>
			<li>
<p>
~IF［
`~sensorに接続する$( 此れ ) の結果 ~EQ ~F
］：
◎
let connected be the result of invoking connect to sensor with sensor_instance as argument.
◎
If connected is false, then
</p>
				<ol>
					<li>
%e ~LET `例外を作成する$( `NotReadableError$E )
◎
Let e be the result of creating a "NotReadableError" DOMException.
</li>
					<li>
次を走らす`~taskを~queueする$
⇒
`~errorを通知する$( %e, 此れ )
◎
Queue a task to run notify error with e and sensor_instance as arguments.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%許可~状態 ~LET `~sensor~accessを要請する$( 此れ )
◎
Let permission_state be the result of invoking request sensor access with sensor_instance as argument.
</li>
			<li>
~IF［
%許可~状態 ~EQ `granted^l
］
⇒
`~sensor~objを作動化する$( 此れ )
◎
If permission_state is "granted",
• Invoke activate a sensor object with sensor_instance as argument.
</li>
			<li>
<p>
~ELIF［
%許可~状態 ~EQ `denied^l
］
⇒
◎
Otherwise, if permission_state is "denied",
</p>
				<ol>
					<li>
%e ~LET `例外を作成する$( `NotAllowedError$E )
◎
let e be the result of creating a "NotAllowedError" DOMException.
</li>
					<li>
次を走らす`~taskを~queueする$
⇒
`~errorを通知する$( %e, 此れ )
◎
Queue a task to run notify error with e and sensor_instance as arguments.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="sensor-stop">
<h4>7.1.8. `stop()@m</h4>

<p>
被呼出時には、次を走らすモノトスル：
◎
The stop() method must run these steps:
</p>

<ol>
	<li>
~IF［
此れ . `state$sl ~EQ `idle^l
］
⇒
~RET
◎
If sensor_instance.[[state]] is "idle", then return.
</li>
	<li>
此れ . `state$sl ~SET `idle^l
◎
Set sensor_instance.[[state]] to "idle".
</li>
	<li>
この段は`並列的$に走らす：
⇒
`~sensor~objを非作動化する$( 此れ )
◎
Run these sub-steps in parallel:
• Invoke deactivate a sensor object with sensor_instance as argument.
</li>
</ol>

			</section>
			<section id="sensor-onreading">
<h4>7.1.9. `onreading@m</h4>

<p>
`EventHandler$I であり，新たな`~sensor読取り$が可用であることを通知するために~callされる。
◎
onreading is an EventHandler which is called to notify that new reading is available.
</p>

			</section>
			<section id="sensor-onactivate">
<h4>7.1.10. `onactivate@m</h4>

<p>
`EventHandler$I であり，此れ . `state$sl が `activating^l から `activated^l へ遷移したときに~callされる。
◎
onactivate is an EventHandler which is called when this.[[state]] transitions from "activating" to "activated".
</p>

			</section>
			<section id="sensor-onerror">
<h4>7.1.11. `onerror@m</h4>

<p>
`EventHandler$I であり，`例外$を同期的に取扱えないときに~callされる。
◎
onerror is an EventHandler which is called whenever an exception cannot be handled synchronously.
</p>

			</section>
			<section id="event-handlers">
<h4 title="Event handlers">7.1.12. ~event~handler</h4>

<p>
`Sensor$I ~interfaceを実装している~objは次に挙げる`~event~handler$（および，それぞれに対応する`~event~handler~event型$）を属性として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported as attributes by the objects implementing the Sensor interface:
</p>

<table><thead>
<tr><th>~event~handler
<th>~event~handler~event型
</thead><tbody>

<tr><td>`onreading^m
<td>`reading@et

<tr><td>`onactivate^m
<td>`activate@et

<tr><td>`onerror^m
<td>`error@et
</tbody></table>

			</section>
		</section>
		<section id="the-sensor-error-event-interface">
<h3 title="The SensorErrorEvent Interface">7.2. `SensorErrorEvent^I ~interface</h3>

<pre class="idl">
[`SensorErrorEvent@mc(`DOMString$ %type, `SensorErrorEventInit$I %errorEventInitDict),
 `SecureContext$, `Exposed$=(DedicatedWorker, Window)]
interface `SensorErrorEvent@I : `Event$I {
  readonly attribute `DOMException$I `error@m;
};

dictionary `SensorErrorEventInit@I : `EventInit$I {
  required `DOMException$I `error@mb;
};
</pre>

			<section id="sensor-error-event-error">
<h4 title="SensorErrorEvent.error">7.2.1. `SensorErrorEvent.error^m</h4>

<p>
`SensorErrorEventInit$I に渡された `DOMException$I ~objを取得する。
◎
Gets the DOMException object passed to SensorErrorEventInit.
</p>

			</section>
		</section>
	</section>
	<section id="abstract-operations">
<h2 title="Abstract Operations">8. 抽象-演算</h2>

		<section id="initialize-a-sensor-object">
<h3 title="Initialize a sensor object">8.1. ~sensor~objを初期化する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>
	<dd>
%~options
— `辞書$。
◎
options, a dictionary object.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
%~options を成す
~EACH( %~key → %値 )
に対し
⇒
~IF［
%~key ~NIN %~sensor~instance の型が`~supportする~sensor~optionたち$
］
⇒
~THROW `NotSupportedError$E
◎
For each key → value of options
• If the associated supported sensor options does not contain key
•• Throw "NotSupportedError" DOMException.
</li>
	<li>
<p>
~IF［
%~options . `frequency$m は`在する$
］
⇒
%~sensor~instance . `frequency$sl ~SET %~options . `frequency$m
◎
If options.frequency is present, then
• Set sensor_instance.[[frequency]] to options.frequency.
</p>

<p class="note">注記：
要請された `frequency$m を~UAが尊重できる保証は無い。
実際の`標本化~frequency$は、 `Sensor$I の `timestamp$m 属性を利用して計算できる。
◎
Note: there is not guarantee that the requested options.frequency can be respected. The actual sampling frequency can be calculated using Sensor timestamp attributes.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="check-sensor-policy-controlled-features">
<h3 title="Check sensor policy-controlled features">8.2. ~sensor施策により制御される特能を検査する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor型
— `~sensor型$
◎
sensor_type, a sensor type.
</dd>

	<dt>出力</dt>
	<dd>
~T／~F
◎
True if all of the associated sensor feature names are allowed to use, false otherwise.
</dd>
</dl>

<ol>
	<li>
%~sensor型 の`~sensor特能~名たち$を成す
~EACH( %特能~名 )
に対し
⇒
~IF［
`作動中の文書$には %特能~名 の`利用は許容されて$いない
］
⇒
~RET ~F
◎
Let feature_names be the sensor_type’s associated sensor feature names.
◎
For each feature_name of feature_names,
• If active document is not allowed to use the policy-controlled feature named feature_name, then:
•• Return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

		</section>
		<section id="connect-to-sensor">
<h3 title="Connect to sensor">8.3. ~sensorに接続する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
%~sensor~instance に`~platform~sensor$が結付けられるならば ~T ／
~ELSE_ ~F
◎
True if sensor instance was associated with a platform sensor, false otherwise.
</dd>
</dl>

<div>
<ol>
	<li>
%型 ~LET %~sensor~instance の`~sensor型$
</li>
	<li>
%~sensor ~LET ~deviceが備える［
%型 用の`~sensor読取り$を供せる`~device~sensor$たち
］の個数に応じて
⇒＃
0 個ならば ε／
1 個ならば その唯一の`~device~sensor$に対応する`~platform~sensor$／
複数個ならば %型 の`既定の~sensor$（定義されていなければ ε ）／
</li>
	<li>
~IF［
%~sensor ~EQ ε
］
⇒
~RET ~F
</li>
	<li>
%~sensor~instance に %~sensor を結付ける
</li>
	<li>
~RET ~T
</li>
</ol>

◎
Let type be the sensor type of sensor_instance.
◎
If the device has a single device sensor which can provide readings for type, then
• Associate sensor_instance with a platform sensor corresponding to this device sensor.
• Return true.
◎
If the device has multiple device sensors which can provide readings for type, then
• If type has an associated default sensor, then
•• Associate sensor_instance with a platform sensor corresponding to default sensor.
•• Return true.
◎
Return false.
</div>

</div>

		</section>
		<section id="activate-a-sensor-object">
<h3 title="Activate a sensor object">8.4. ~sensor~objを作動化する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
%~sensor の`作動化された~sensor~objたち$に %~sensor~instance を`付加する$set
◎
Append sensor_instance to sensor’s set of activated sensor objects.
</li>
	<li>
`~sensor設定群を設定する$( %~sensor )
◎
Invoke set sensor settings with sensor as argument.
</li>
	<li>
次を走らす`~taskを~queueする$
⇒
`作動化d状態を通知する$( %~sensor~instance )
◎
Queue a task to run notify activated state with sensor_instance as an argument.
</li>
</ol>
</div>

		</section>
		<section id="deactivate-a-sensor-object">
<h3 title="Deactivate a sensor object">8.5. ~sensor~objを非作動化する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
`~sensor~task源$に結付けられている`~task~queue$から
%~sensor~instance に結付けられている すべての`~task$を除去する
◎
Remove all tasks associated with sensor_instance from the task queue associated with sensor task source.
</li>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
~IF［
%~sensor~instance ~NIN %~sensor の`作動化された~sensor~objたち$
］
⇒
~RET
◎
If sensor’s set of activated sensor objects contains sensor_instance,
</li>
	<li>
%~sensor の`作動化された~sensor~objたち$から %~sensor~instance を`除去する$
◎
Remove sensor_instance from sensor’s set of activated sensor objects.
</li>
	<li>
`~sensor設定群を設定する$( %~sensor )
◎
Invoke set sensor settings with sensor as argument.
</li>
	<li>
%~sensor~instance . `pendingReadingNotification$sl ~SET ~F
◎
Set sensor_instance.[[pendingReadingNotification]] to false.
</li>
	<li>
%~sensor~instance . `lastEventFiredAt$sl ~SET ~NULL
◎
Set sensor_instance.[[lastEventFiredAt]] to null.
</li>
</ol>
</div>

		</section>
		<section id="revoke-sensor-permission">
<h3 title="Revoke sensor permission">8.6. ~sensor許可を~revokeする</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor
— `~platform~sensor$
◎
sensor, a platform sensor.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
%作動化された~sensorたち ~LET %~sensor の`作動化された~sensor~objたち$
◎
Let activated_sensors be sensor’s associated set of activated sensor objects.
</li>
	<li>
<p>
%作動化された~sensorたち を成す
~EACH( %s )
に対し：
◎
For each s of activated_sensors,
</p>
		<ol>
			<li>
`~sensor~objを非作動化する$( %s )
◎
Invoke deactivate a sensor object with s as argument.
</li>
			<li>
%e ~LET `例外を作成する$( `NotAllowedError$E )
◎
Let e be the result of creating a "NotAllowedError" DOMException.
</li>
			<li>
次を走らす`~taskを~queueする$
⇒
`~errorを通知する$( %e, %s )
◎
Queue a task to run notify error with e and s as arguments.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="set-sensor-settings">
<h3 title="Set sensor settings">8.7. ~sensor設定群を設定する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor
— `~platform~sensor$
◎
sensor, a platform sensor.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
<p>
~IF［
%~sensor の`作動化された~sensor~objたち$は`空$である
］
⇒
◎
If sensor’s set of activated sensor objects is empty,
</p>
		<ol>
			<li>
`要請した標本化~frequency$ ~SET ~NULL
◎
Set requested sampling frequency to null.
</li>
			<li>
`最新な読取り~map$を成す
~EACH( %~key → %値 )
に対し
⇒
`最新な読取り~map$[ %~key ] ~SET ~NULL
◎
For each key → value of latest reading.
• Set latest reading[key] to null.
</li>
			<li>
~UAに特有な仕方で更新する
`in which^en
［
`~sensor読取り$は %~sensor から得られる
］から［
`~sensor読取り$をもはや供さない
］へ【？】
◎
Update the user-agent-specific way in which sensor readings are obtained from sensor to no longer provide readings.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
`要請した標本化~frequency$ ~SET `最適な標本化~frequency$
◎
Set requested sampling frequency to optimal sampling frequency.
</li>
</ol>
</div>

		</section>
		<section id="update-latest-reading">
<h3 title="Update latest reading">8.8. 最新な読取りを更新する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor
— `~platform~sensor$
◎
sensor, a platform sensor.
</dd>
	<dd>
%読取り
— `~sensor読取り$
◎
reading, a sensor reading.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
`最新な読取り~map$を成す
~EACH( %~key → %値 )
に対し
⇒
`最新な読取り~map$[ %~key ] ~SET %読取り を成す対応する値
◎
For each key → value of latest reading.
• Set latest reading[key] to the corresponding value of reading.
</li>
	<li>
%作動化された~sensorたち ~LET %~sensor にて`作動化された~sensor~objたち$
◎
Let activated_sensors be sensor’s associated set of activated sensor objects.
</li>
	<li>
この段は`並列的$に走らす
⇒
%作動化された~sensorたち を成す
~EACH( %s )
に対し
⇒
`最新な読取り更新を報告する$( %s )
◎
Run these sub-steps in parallel:
• For each s in activated_sensors,
•• Invoke report latest reading updated with s as an argument.
</li>
</ol>
</div>

		</section>
		<section id="find-the-reporting-frequency-of-a-sensor-object">
<h3 title="Find the reporting frequency of a sensor object">8.9.  ~sensor~objの報告ng~frequencyを見出す</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
~in-Hzによる`報告ng~frequency$
◎
reporting frequency in Hz.
</dd>
</dl>

<ol>
	<li>
%~frequency ~LET ~NULL
◎
Let frequency be null.
</li>
	<li>
%~frequency ~LET ［
%~sensor~instance . `frequency$sl ~NEQ ~NULL ならば それ ／
~ELSE_ ~UAがアテガう適切な値
］
◎
Let f be sensor_instance.[[frequency]].
</li>
	<li>
%~frequency ~SET %~frequency を［
%~sensor~instance の`~platform~sensor$用の`標本化~frequency$の上限, 下限
］で切り詰めた結果
◎
if f is set,
• set frequency to f capped by the upper and lower sampling frequency bounds for the associated platform sensor.
◎
Otherwise,
• user agent can assign frequency to an appropriate value.
</li>
	<li>
~RET %~frequency
◎
return frequency.
</li>
</ol>
</div>

		</section>
		<section id="report-latest-reading-updated">
<h3 title="Report latest reading updated">8.10. 最新な読取り更新を報告する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
~IF［
%~sensor~instance . `pendingReadingNotification$sl ~EQ ~T
］
⇒
~RET
◎
If sensor_instance.[[pendingReadingNotification]] is true,
• Return.
</li>
	<li>
%~sensor~instance . `pendingReadingNotification$sl ~SET ~T
◎
Set sensor_instance.[[pendingReadingNotification]] to true.
</li>
	<li>
%最後に報告された時刻印 ~LET %~sensor~instance . `lastEventFiredAt$sl
◎
Let lastReportedTimestamp be the value of sensor_instance.[[lastEventFiredAt]].
</li>
	<li>
<p>
~IF［
%最後に報告された時刻印 ~EQ ~NULL【！is not set】
］
⇒
◎
If lastReportedTimestamp is not set
</p>
		<ol>
			<li>
次を走らす`~taskを~queueする$
⇒
`新たな読取りを通知する$( %~sensor~instance )
◎
Queue a task to run notify new reading with sensor_instance as an argument.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%報告ng~frequency ~LET `~sensor~objの報告ng~frequencyを見出す$( %~sensor~instance )
◎
Let reportingFrequency be result of invoking Find the reporting frequency of a sensor object.
</li>
	<li>
<p>
~IF［
%報告ng~frequency ~EQ ~NULL
］
⇒
◎
If reportingFrequency is null
</p>
		<ol>
			<li>
次を走らす`~taskを~queueする$
⇒
`新たな読取りを通知する$( %~sensor~instance )
◎
Queue a task to run notify new reading with sensor_instance as an argument.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%報告ng間隔 ~LET 1 ~DIV %報告ng~frequency
◎
Let reportingInterval be the result of 1 / reportingFrequency.
</li>
	<li>
%時刻印~差分 ~LET `最新な読取り~map$[ `timestamp^l ] ~MINUS %最後に報告された時刻印
◎
Let timestampDelta be the result of latest reading["timestamp"] - lastReportedTimestamp.
</li>
	<li>
<p>
~IF［
%時刻印~差分 ~GTE %報告ng間隔
］
⇒
◎
If timestampDelta is greater than or equal to reportingInterval
</p>
		<ol>
			<li>
次を走らす`~taskを~queueする$
⇒
`新たな読取りを通知する$( %~sensor~instance )
◎
Queue a task to run notify new reading with sensor_instance as an argument.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
( %報告ng間隔 ~MINUS %時刻印~差分 )
~~経過するまで`~event~loopを回す$
◎
Let deferUpdateTime be the result of reportingInterval - timestampDelta.
◎
Spin the event loop for a period of time equal to deferUpdateTime.
</li>
	<li>
~IF［
%~sensor~instance . `pendingReadingNotification$sl ~EQ ~T
］
⇒
次を走らす`~taskを~queueする$
⇒
`新たな読取りを通知する$( %~sensor~instance )
◎
If sensor_instance.[[pendingReadingNotification]] is true,
• Queue a task to run notify new reading with sensor_instance as an argument.
</li>
</ol>
</div>

		</section>
		<section id="notify-new-reading">
<h3 title="Notify new reading">8.11. 新たな読取りを通知する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
%~sensor~instance . `pendingReadingNotification$sl ~SET ~F
◎
Set sensor_instance.[[pendingReadingNotification]] to false.
</li>
	<li>
%~sensor~instance . `lastEventFiredAt$sl ~SET `最新な読取り~map$[ `timestamp^l ]
◎
Set sensor_instance.[[lastEventFiredAt]] to latest reading["timestamp"].
</li>
	<li>
%~sensor~instance に向けて，名前 `reading$et の`~eventを発火する$
◎
Fire an event named "reading" at sensor_instance.
</li>
</ol>
</div>

		</section>
		<section id="notify-activated-state">
<h3 title="Notify activated state">8.12. 作動化d状態を通知する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
%~sensor~instance . `state$sl ~SET `activated^l
◎
Set sensor_instance.[[state]] to "activated".
</li>
	<li>
%~sensor~instance に向けて，名前 `activate$et の`~eventを発火する$
◎
Fire an event named "activate" at sensor_instance.
</li>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
~IF［
%~sensor の`最新な読取り~map$[ `timestamp^l ] ~NEQ ~NULL
］
⇒
次を走らす`~taskを~queueする$
⇒
`新たな読取りを通知する$( %~sensor~instance )
◎
If sensor’s latest reading["timestamp"] is not null,
• Queue a task to run notify new reading with sensor_instance as an argument.
</li>
</ol>
</div>

		</section>
		<section id="notify-error">
<h3 title="Notify error">8.13. ~errorを通知する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>
	<dd>
%~error
— `DOMException$I
◎
error, a DOMException.
</dd>

	<dt>出力</dt>
	<dd>
ナシ
◎
None
</dd>
</dl>

<ol>
	<li>
%~sensor~instance . `state$sl ~SET `idle^l
◎
Set sensor_instance.[[state]] to "idle".
</li>
	<li>
%~sensor~instance に向けて，名前 `error$et の`~eventを発火する$
⇒
`SensorErrorEvent$I を利用し，次のように初期化して
⇒
`error$m 属性 ~SET %~error
◎
Fire an event named "error" at sensor_instance using SensorErrorEvent with its error attribute initialized to error.
</li>
</ol>
</div>

		</section>
		<section id="get-value-from-latest-reading">
<h3 title="Get value from latest reading">8.14. 最新な読取りから値を取得する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>
	<dd>
%~key
— 値の名前を表現している文字列
◎
key, a string representing the name of the value.
</dd>

	<dt>出力</dt>
	<dd>
`~sensor読取り$値／~NULL
◎
A sensor reading value or null.
</dd>
</dl>

<ol>
	<li>
<p>
~IF［
%~sensor~instance . `state$sl ~EQ `activated^l
］
⇒
◎
If sensor_instance.[[state]] is "activated",
</p>
		<ol>
			<li>
%読取り~map ~LET %~sensor~instance に関係する`~platform~sensor$の`最新な読取り~map$
◎
Let readings be the latest reading of sensor_instance’s related platform sensor.
</li>
			<li>
~IF［
`拡張~仕様$は %~sensor~instance 用に`局所~座標系$を定義する
］
⇒
%読取り~map を成す各~値を`局所~座標系$内の値に変形する（
`COORDINATES-TRANSFORMATION$r を見よ
)
◎
If the extension specification defines a local coordinate system for sensor_instance,
• Remap (see [COORDINATES-TRANSFORMATION]) readings values to the local coordinate system.
</li>
			<li>
~RET %読取り~map[ %~key ]
◎
Return readings[key].
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET ~NULL
◎
Otherwise, return null.
</li>
</ol>
</div>

		</section>
		<section id="request-sensor-access">
<h3 title="Request sensor access">8.15. ~sensor~accessを要請する</h3>

<div class="algorithm">

<dl>
	<dt>入力</dt>
	<dd>
%~sensor~instance
— `Sensor$I ~obj
◎
sensor_instance, a Sensor object.
</dd>

	<dt>出力</dt>
	<dd>
`許可~状態$
◎
A permission state.
</dd>
</dl>

<ol>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
%~sensor許可たち ~LET %~sensor の`~sensor許可~名たち$
◎
Let sensor_permissions be sensor’s associated set of permission names.
</li>
	<li>†
%~sensor許可たち を成す
~EACH( %許可~名 )
に対し
⇒
%許可~名 を`利用する許可を要請-$して，その結果を待機する
⇒
~IF［
その結果 ~EQ `denied^l
］
⇒
~RET `denied^l
◎
Run these sub-steps in parallel:
◎
For each permission_name in sensor_permissions,
• Let state be the result of requesting permission to use permission_name.
• If state is "denied"
•• Return "denied".
</li>
	<li>
~RET `granted^l
◎
Otherwise, return "granted".
</li>
</ol>

<p class="trans-note">【†
原文では，この段~以降を “`並列的$に走らす” と記されているが、値を返しているので不適切になる
— “待機する” は、それに代わるこの訳による補完（この~algo自体が，並列的に走らされている）。
】</p>

</div>

		</section>
	</section>
	<section id="automation">
<h2 title="Automation">9. 自動化</h2>

<p>
汎用~sensor~API, その`拡張~仕様$は、作者に難題を~~課す
— それらの~interfaceを全部的に行使するためには、予測-可能な仕方で応答する物理的な~hardware~deviceが要るので。
この難題に取組むため、この文書は，
`WebDriver$r 仕様に対し［
~UAが稼働している~host上で`模擬~sensor$を制御するための，いくつかの`拡張~command$
］を定義する。
これらの`拡張~command$により、特定0の~propを伴う~deviceを作成でき，要請に対するそれらの応答はきちんと定義される。
◎
The Generic Sensor API and its extension specifications pose a challenge to test authors, as fully exercising those interfaces requires physical hardware devices that respond in predictable ways. To address this challenge this document defines a number of extension commands to the [WebDriver] specification for controlling mock sensor on the host that the user agent is running on. With these extension commands, devices with particular properties can be created and their responses to requests are well defined.
</p>

		<section id="mock-sensors">
<h3 title="Mock Sensors">9.1. 模擬~sensor</h3>

<p>
`模擬~sensor@
（ `mock sensor^en ）は、`~platform~sensor$の挙動を，制御される仕方で模倣する。
◎
A mock sensor simulates the behavior of a platform sensor in controlled ways.
</p>

<p>
`模擬~sensor$は、対応する
`模擬~sensor読取り@
を
— 環境について模擬している情報の源として —
`Sensor$I ~objへを報告する。
◎
A mock sensor reports a corresponding mock sensor reading, which is a source of mocking information about the environment, to the Sensor objects.
</p>

<p>
`現在の閲覧文脈$の各`模擬~sensor$には、`模擬~sensor読取り$が結付けられる。
◎
The current browsing context's mock sensor has an associated mock sensor reading map.
</p>

<p>
`模擬~sensor読取り$は，次のような`~map$である：
◎
↑↓</p>

<ul>
	<li>
`~entry$として
«[ `timestamp^l → %時刻印 ]»
を包含する。
%時刻印 は、［
`模擬~sensor読取り$が `Sensor$I ~objの観測器へ送信された時刻
］の見積もりを［
`時刻~起点$からの~millisecondsで表出される，高-分解能な時刻印
］として与える。
◎
The mock sensor reading map contains an entry whose key is "timestamp" and whose value is a high resolution timestamp that estimates the time mock sensor reading sent to observers of the Sensor object, expressed in milliseconds since the time origin.
</li>
	<li>
~mapを成す他のどの`~entry$も、その`~key$mapは［
`模擬~sensor型$の `MockSensorReadingValues$I に定義される`辞書~member$を成すある`識別子$
］に合致し，その初期~時の`値$mapは実装に依存する。
◎
The other entries of the mock sensor reading map whose keys must match the dictionary members identifier defined by the mock sensor type's MockSensorReadingValues and whose initial values are implementation-dependent.
</li>
</ul>

<p class="note">注記：
~UAは、初期~時には `Sensor$I ~objに公開された`模擬~sensor読取り$を供するモノトスル。
◎
Note: The user agent must provide the mock sensor reading that are initially exposed to the Sensor objects.
</p>

<p>
`模擬~sensor$には
`要請した標本化~frequency$が結付けられる。
その既定の値は、実装に依存するが，`模擬~sensor$の`標本化~frequency$の［
上限, 下限
］に入るように設定されるモノトスル。
◎
A mock sensor has an associated requested sampling frequency. Its default value is implementation-dependent but must be set within a mock sensor's associated sampling frequency bounds.
</p>

<p>
`模擬~sensor$には、それが~supportする［
上限, 下限
］を伴う`標本化~frequency$が結付けられる。
この［
上限／下限
］の既定の値は、実装に依存する。
◎
A mock sensor has an associated sampling frequency with supported bounds. The default values of supported bounds are implementation-dependent.
</p>

<p>
［
~UAが`現在の閲覧文脈$にて`作動中の文書$に`~sensor読取りを公開できる$
］ならば、`模擬~sensor$は，`模擬~sensor読取り$を`要請した標本化~frequency$の~rateでそれを報告するモノトスル。
◎
A mock sensor must report the mock sensor reading at the rate of its requested sampling frequency if the user agent can expose sensor readings to the current browsing context's active document.
</p>

<p class="note">注記：
この仕様に定義される`模擬~sensor$は、~test用であり，それに関係しない~web内容による利用は意図されない。
~UAは、【自身の環境設定において？】［
`runtime^en ／ `compile-time^en
］~flagが `set^en されたときに限り，`模擬~sensor$~interfaceを公開することにしてもヨイ。
◎
Note: The mock sensor defined in this specification is not intended be used by non-testing-related web content. The UA MAY choose to expose mock sensor interface only when a runtime or compile-time flag has been set.
</p>

			<section id="dictionary-mocksensorconfiguration">
<h4 title="MockSensorConfiguration dictionary">9.1.1. `MockSensorConfiguration^I 辞書</h4>

<pre class="idl">
dictionary `MockSensorConfiguration@I {
  required `MockSensorType$I `mockSensorType@mC;
  `boolean$ `connected@mC = true;
  `double$? `maxSamplingFrequency@mC;
  `double$? `minSamplingFrequency@mC;
};
</pre>

<p>
`MockSensorConfiguration$I 辞書は、`模擬~sensorを作成する$ときに利用される。
◎
The MockSensorConfiguration dictionary is used to create a mock sensor.
</p>

<dl>
	<dt>`mockSensorType$mC</dt>
	<dd>
`MockSensorType$I 値
— `模擬~sensor型$を設定するために利用される。
◎
A MockSensorType that is used to set mock sensor type.
</dd>

	<dt>`connected$mC</dt>
	<dd>
`模擬~sensor$の
`接続~flag@
を指示する真偽値
— `Sensor$I ~objと`模擬~sensor$との接続を切替えるために利用される。
◎
A boolean that indicates a mock sensor's connection flag which is used for switching the connection between Sensor object and mock sensor.＼
</dd>
	<dd>
`接続~flag$に値 %値 が設定されたときは、次を走らすモノトスル
⇒
`~sensorに接続する$( `模擬~sensor$に結付けられている `Sensor$I ~obj, %値 )
◎
When set to false the user agent must force the result of invoking connect to sensor with mock sensor's associated Sensor object as argument to false, otherwise true.
</dd>

	<dt>`maxSamplingFrequency$mC</dt>
	<dd>
~in-Hzによる~frequencyを表現している実数を与える
— 結付けられている`模擬~sensor$用に，それが~supportする最大`標本化~frequency$を設定するために利用される。
◎
A double representing frequency in Hz that is used to set maximum supported sampling frequency for the associated mock sensor.
</dd>

	<dt>`minSamplingFrequency$mC</dt>
	<dd>
~in-Hzによる~frequencyを表現している実数を与える
— 結付けられている`模擬~sensor$用に，それが~supportする最小`標本化~frequency$を設定するために利用される。
◎
A double representing frequency in Hz that is used to set minimum supported sampling frequency for the associated mock sensor.
</dd>
</dl>

			</section>
			<section id="dictionary-mocksensor">
<h4 title="MockSensor dictionary">9.1.2. `MockSensor^I 辞書</h4>

<pre class="idl">
dictionary `MockSensor@I {
  `double$ `maxSamplingFrequency@m;
  `double$ `minSamplingFrequency@m;
  `double$ `requestedSamplingFrequency@m;
};
</pre>

<p>
`MockSensor$I 辞書は、`模擬~sensor$についての情報を供する。
◎
The MockSensor dictionary provides information about a mock sensor.
</p>

<dl>
	<dt>`maxSamplingFrequency$m</dt>
	<dd>
結付けられている`模擬~sensor$それが~supportする最大`標本化~frequency$を~in-Hzで表現している実数を与える。
◎
A double representing frequency in Hz that indicates the maximum supported sampling frequency of the associated mock sensor.
</dd>

	<dt>`minSamplingFrequency$m</dt>
	<dd>
結付けられている`模擬~sensor$それが~supportする最小`標本化~frequency$を~in-Hzで表現している実数を与える。
◎
A double representing frequency in Hz that indicates the minimum supported sampling frequency of the associated mock sensor.
</dd>

	<dt>`requestedSamplingFrequency$m</dt>
	<dd>
結付けられている`模擬~sensor$の`要請した標本化~frequency$を~in-Hzで表現している実数を与える。
◎
A double representing frequency in Hz that indicates the requested sampling frequency of the associated mock sensor.
</dd>
</dl>

<p>
`直列形の模擬~sensor@
は，~JSON <a href="~WEBDRIVER#dfn-object">Object</a> であり、【！＊】
`MockSensor$I 辞書に~listされた`模擬~sensor$の各~fieldは、次を利用して対応付けられる
⇒
`現在の閲覧文脈$内で可用な`模擬~sensor$からの［
`JSON Key^i, 結付けられている~fieldの値
］
◎
A serialized mock sensor is a JSON Object where a mock sensor's fields listed in the MockSensor dictionary are mapped using the JSON Key and the associated field’s value from the available mock sensor in current browsing context.
</p>

			</section>
			<section id="section-mock-sensor-type">
<h4 title="Mock sensor type">9.1.3. 模擬~sensor型</h4>

<p>
`模擬~sensor型@
は、ある`~sensor型$に結付けられている `Sensor$I 下位classに等価である。
◎
A mock sensor type is equivalent to a sensor type's associated Sensor subclass.
</p>

<pre class="idl">
enum `MockSensorType@I {
  `ambient-light$l,
  `accelerometer$l,
  `linear-acceleration$l,
  `gravity$l,
  `gyroscope$l,
  `magnetometer$l,
  `uncalibrated-magnetometer$l,
  `absolute-orientation$l,
  `relative-orientation$l,
  `geolocation$l,
  `proximity$l,
};
</pre>

<div>

<p>
`MockSensorType$I 列挙型における各~列挙~値は、ある`模擬~sensor型$を識別する。
次の表の 1 列目に与える列挙~値は、同じ行の 2 列目に与える
~interfaceの用法に結付けられている`模擬~sensor型$になる：
</p>

<table><tbody>
<tr><td>`ambient-light@l
<td>`AmbientLightSensor$I

<tr><td>`accelerometer@l
<td>`Accelerometer$I

<tr><td>`linear-acceleration@l
<td>`LinearAccelerationSensor$I

<tr><td>`gravity@l
<td>`GravitySensor$I

<tr><td>`gyroscope@l
<td>`Gyroscope$I

<tr><td>`magnetometer@l
<td>`Magnetometer$I

<tr><td>`uncalibrated-magnetometer@l
<td>`UncalibratedMagnetometer$I

<tr><td>`absolute-orientation@l
<td>`AbsoluteOrientationSensor$I

<tr><td>`relative-orientation@l
<td>`RelativeOrientationSensor$I

<tr><td>`geolocation@l
<td>`GeolocationSensor$I

<tr><td>`proximity@l
<td>`ProximitySensor$I
</tbody></table>


◎
Each enumeration value in the MockSensorType enum identifies a mock sensor type.
◎
"ambient-light"
• A mock sensor type associated with the usage of the AmbientLightSensor interface.
"accelerometer"
• A mock sensor type associated with the usage of the Accelerometer interface.
"linear-acceleration"
• A mock sensor type associated with the usage of the LinearAccelerationSensor interface.
"gravity"
• A mock sensor type associated with the usage of the GravitySensor interface.
"gyroscope"
• A mock sensor type associated with the usage of the Gyroscope interface.
"magnetometer"
• A mock sensor type associated with the usage of the Magnetometer interface.
"uncalibrated-magnetometer"
• A mock sensor type associated with the usage of the UncalibratedMagnetometer interface.
"absolute-orientation"
• A mock sensor type associated with the usage of the AbsoluteOrientationSensor interface.
"relative-orientation"
• A mock sensor type associated with the usage of the RelativeOrientationSensor interface.
"geolocation"
• A mock sensor type associated with the usage of the GeolocationSensor interface.
"proximity"
• A mock sensor type associated with the usage of the ProximitySensor interface.
</div>


<p>
各 `模擬~sensor型$には、
`模擬~sensor読取り値たち@
を成す `MockSensorReadingValues$I 【またはそれを継承する】辞書が結付けられる。
それは，利用者が指定した`模擬~sensor読取り$を表現し、
<a href="#update-mock-sensor-reading-command">模擬~sensor読取りを更新する</a>
ときに利用される。
その各~memberは、`~sensor型$に結付けられている`拡張~sensor~interface$に定義される`属性$の`識別子$に合致するモノトスル。
各`模擬~sensor型$には，それに特有な `MockSensorReadingValues$I があり、各`拡張~仕様$ごとに定義される。
◎
Each mock sensor type has a mock sensor reading values dictionary:
◎
MockSensorReadingValues dictionary represents a user-specified mock sensor reading used for updating a mock sensor reading. Its members must match the attribute identifier defined by the sensor type's associated extension sensor interface. Each mock sensor type has a specific MockSensorReadingValues, which is defined in each extension specifications.
</p>

<pre class="idl">
dictionary `MockSensorReadingValues@I {
};
</pre>

			</section>
		</section>
		<section id="section-extension-commands">
<h3 title="Extension Commands">9.2. 拡張~command</h3>

<p class="trans-note">【
簡潔にするため，この訳では、この節において次の表記を用いる：
】</p>

<ul>
	<li>
“`~error@wdr( %~code )”
という表記は、次の略記である
⇒
“`~WebDriver~error~code$に %~code を伴う`~WebDriver~error$”（ “`WebDriver error with WebDriver error code^en %~code” ）
</li>
	<li>
“`成功@wdr( %~data )”
という表記は、次の略記である
⇒
“~data~fieldに %~data を伴う`成功$”（ “`success with data^en %~data” ）”
</li>
</ul>

			<section id="create-mock-sensor-command">
<h4 title="Create mock sensor">9.2.1. 模擬~sensorを作成する</h4>

<table><tbody>
<tr><th>~HTTP~method
<th>`~URI~template$

<tr><td>`POST^hm
<td>`/session/{session id}/sensor^c
</tbody></table>

<div class="algorithm">

<p>
`模擬~sensorを作成する@
`拡張~command$は、新たな`模擬~sensor$を作成する。
◎
The create mock sensor extension command creates a new mock sensor.
</p>

<p>
その`~remote端~手続き$は：
◎
The remote end steps are:
</p>

<ol>
	<li>
%環境設定 ~LET `MockSensorConfiguration$I 型の`~IDL値に変換する$( `the^en 環境設定~parameter【？】 )
⇒
例外が投出されたときは
⇒
~RET `~error$wdr( `無効な引数$i )
◎
Let configuration be the configuration parameter, converted to an IDL value of type MockSensorConfiguration. If this throws an exception, return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
%型 ~LET %環境設定 . `mockSensorType$mC
◎
Let type be the configuration.mockSensorType.＼
</li>
	<li>
~IF［
`現在の閲覧文脈$は，すでに`模擬~sensor型$ %型 の`模擬~sensor$を有している
］
⇒
~RET `~error$wdr( `模擬~sensorは作成-済み$i )
◎
If the current browsing context already has this type of mock sensor, return a WebDriver error with WebDriver error code mock sensor already created.
</li>
	<li>
~IF［
`現在の閲覧文脈$は`もはや開いてない$
］
⇒
~RET `~error$wdr( `そのような~windowは無い$i )
◎
If the current browsing context is no longer open, return a WebDriver error with WebDriver error code no such window.
</li>
	<li>
%結果 ~LET `利用者~promptを取扱う$()
◎
Handle any user prompts,＼
</li>
	<li>
~IF［
%結果 は`~WebDriver~error$である
］
⇒
~RET %結果
◎
and return its value if it is a WebDriver error.
</li>
	<li>
<p>
この段は`並列的$に走らす（`現在の閲覧文脈$内に`模擬~sensor$を作成する）：
◎
Run these sub-steps in parallel to create a mock sensor in the current browsing context:
</p>
		<ol>
			<li>
%模擬~sensor ~LET 新たな`模擬~sensor$
◎
Let mock be a new mock sensor.
</li>
			<li>
%模擬~sensor の`模擬~sensor型$ ~SET %型
◎
Set mock’s mock sensor type to type.
</li>
			<li>
%模擬~sensor の`接続~flag$ ~SET %環境設定 . `connected$mC
◎
Let connected be the configuration.connected, set mock’s associated connection flag to connected.
</li>
			<li>
~IF［
%環境設定 . `maxSamplingFrequency$mC は`在する$
］
⇒
%模擬~sensor が~supportする最大~標本化~frequency ~SET %環境設定 . `maxSamplingFrequency$mC
◎
If configuration.maxSamplingFrequency is present, then:
• Set mock’s maximum supported sampling frequency to configuration.maxSamplingFrequency.
</li>
			<li>
~IF［
%環境設定 . `minSamplingFrequency$mC は`在する$
］
⇒
%模擬~sensor が~supportする最小~標本化~frequency ~SET %環境設定 . `minSamplingFrequency$mC
◎
If configuration.minSamplingFrequency is present, then:
• Set mock’s minimum supported sampling frequency to configuration.minSamplingFrequency.
</li>
			<li>
%~sensor~instance ~LET
%型 に対応する（ `Sensor$I を継承している）~interface型の新たな `Sensor$I ~obj
◎
Let sensor_instance be a type of Sensor object,＼
</li>
			<li>
%~sensor~instance に結付けられている`~platform~sensor$ ~SET %模擬~sensor
◎
set sensor_instance’s associated platform sensor to mock.
</li>
		</ol>
	</li>
	<li>
~RET `成功$wdr( ~NULL )
◎
Return success with data null.
</li>
</ol>
</div>

<div class="example">
<p>
`~session$の`現在の閲覧文脈$内で
~ID 23 を伴う `ambient-light^l 模擬~sensorを作成するためには、`局所~端$は，次の本体を伴う
`/session/23/sensor^c
を `POST^hm することになる：
◎
To create an "ambient-light" mock sensor in the current browsing context of the session with ID 23, the local end would POST to /session/23/sensor with the body:
</p>

<pre class="lang-json">
{
  "mockSensorType": "ambient-light",
  "maxSamplingFrequency": 60,
  "minSamplingFrequency": 5
}
</pre>

<p>
所与の`模擬~sensor型$用に`現在の閲覧文脈$内に作成できる`模擬~sensor$は、 1 個に限られることに自覚するように。
他の場合、
`~error$wdr( `模擬~sensorは作成-済み$i )
が投出されることになる。
◎
Be aware that only one mock sensor of a given mock sensor type can be created in current browsing context, otherwise a WebDriver error with WebDriver error code mock sensor already created will be thrown.
</p>
</div>

			</section>
			<section id="get-mock-sensor-command">
<h4 title="Get mock sensor">9.2.2. 模擬~sensorを取得する</h4>

<table><tbody>
<tr><th>~HTTP~method
<th>`~URI~template$


<tr><td>`GET^hm
<td>`/session/{session id}/sensor/{type}^c
</tbody></table>

<div class="algorithm">

<p>
`模擬~sensorを取得する@
`拡張~command$は、所与の型の`模擬~sensor$についての情報を検索取得する。
◎
The get mock sensor extension command retrieves information about a given type of mock sensor.
</p>

<p>
その`~remote端~手続き$は：
◎
The remote end steps are:
</p>

<ol>
	<li>
%型 ~LET `MockSensorType$I 型の`~IDL値に変換する$( `~url変数$ )
⇒
例外が投出されたときは
⇒
~RET `~error$wdr( `無効な引数$i )
◎
Let type be a url variable, converted to an IDL value of type MockSensorType. If this throws an exception, return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
~IF［
`現在の閲覧文脈$は`もはや開いてない$
］
⇒
~RET `~error$wdr( `そのような~windowは無い$i )
◎
If the current browsing context is no longer open, return a WebDriver error with WebDriver error code no such window.
</li>
	<li>
%結果 ~LET `利用者~promptを取扱う$()
◎
Handle any user prompts,＼
</li>
	<li>
~IF［
%結果 は`~error$wdrである
］
⇒
~RET %結果
◎
and return its value if it is a WebDriver error.
</li>
	<li>
~IF［
`現在の閲覧文脈$に結付けられている`模擬~sensor$であって，その`模擬~sensor型$が %型 に合致するものはある
］
⇒
~RET `成功$wdr( `直列形の模擬~sensor$ )
◎
If type does not match a mock sensor type amongst all associated mock sensors of the current browsing context, return a WebDriver error with WebDriver error code no such mock sensor.
◎
Return success with the serialized mock sensor as data.
</li>
	<li>
~RET `~error$wdr( `そのような模擬~sensorは無い$i )
◎
↑</li>
</ol>
</div>

			</section>
			<section id="update-mock-sensor-reading-command">
<h4 title="Update mock sensor reading">9.2.3. 模擬~sensor読取りを更新する</h4>

<table><tbody>
<tr><th>~HTTP~method
<th>`~URI~template$


<tr><td>`POST^hm
<td>`/session/{session id}/sensor/{type}^c
</tbody></table>

<div class="algorithm">

<p>
`模擬~sensor読取りを更新する@
`拡張~command$は、所与の型の`模擬~sensor$の`模擬~sensor読取り$を更新する。
◎
The update mock sensor reading extension command updates a given type of mock sensor's reading.
</p>

<p>
その`~remote端~手続き$は：
◎
The remote end steps are:
</p>

<ol>
	<li>
%型 ~LET `MockSensorType$I 型の`~IDL値に変換する$( `~url変数$ )
⇒
例外が投出されたときは
⇒
~RET `~error$wdr( `無効な引数$i )
◎
Let type be a url variable, converted to an IDL value of type MockSensorType. If this throws an exception, return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
~IF［
`現在の閲覧文脈$は`もはや開いてない$
］
⇒
~RET `~error$wdr( `そのような~windowは無い$i )
◎
If the current browsing context is no longer open, return a WebDriver error with WebDriver error code no such window.
</li>
	<li>
%結果 ~LET `利用者~promptを取扱う$()
◎
Handle any user prompts,＼
</li>
	<li>
~IF［
%結果 は`~error$wdrである
］
⇒
~RET %結果
◎
and return its value if it is a WebDriver error.
</li>
	<li>
~IF［
`現在の閲覧文脈$に結付けられている`模擬~sensor$であって，その`模擬~sensor型$が %型 に合致するものはない
］
⇒
~RET `~error$wdr( `そのような模擬~sensorは無い$i )
◎
If type does not match a mock sensor type amongst all associated mock sensors of the current browsing context, return a WebDriver error with WebDriver error code no such mock sensor.
</li>
	<li>
%読取り ~LET ［
%型 に結付けられている `MockSensorReadingValues$I 型
］の`~IDL値に変換する$( %読取り 引数【？】 )
⇒
例外が投出されたときは
⇒
~RET `~error$wdr( `無効な引数$i )
◎
Let reading be the reading argument, converted to an IDL value of the type’s associated MockSensorReadingValues. If this throws an exception, return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
%読取り を成す
~EACH( %~key → %値 )
に対し
⇒
`模擬~sensor読取り$[ %~key ] ~SET %読取り を成す対応する値
◎
For each key → value of reading.
• Set mock sensor reading[key] to the corresponding value of reading.
</li>
	<li>
~RET `成功$wdr( ~NULL )
◎
Return success with data null.
</li>
</ol>
</div>

			</section>
			<section id="delete-mock-sensor-command">
<h4 title="Delete mock sensor">9.2.4. 模擬~sensorを削除する</h4>

<table><tbody>
<tr><th>~HTTP~method
<th>`~URI~template$


<tr><td>`DELETE^hm
<td>`/session/{session id}/sensor/{type}^c
</tbody></table>

<div class="algorithm">
<p>
`模擬~sensorを削除する@
`拡張~command$は、所与の型の`模擬~sensor$を削除する。
◎
The delete mock sensor extension command deletes a given type of mock sensor.
</p>

<p>
その`~remote端~手続き$は：
◎
The remote end steps are:
</p>

<ol>
	<li>
%型 ~LET `~url変数$
◎
Let type be a url variable.
</li>
	<li>
~IF［
%型 ~NIN `MockSensorType$I
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If MockSensorType does not contain type, return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
~IF［
`現在の閲覧文脈$は`もはや開いてない$
］
⇒
~RET `~error$wdr( `そのような~windowは無い$i )
◎
If the current browsing context is no longer open, return a WebDriver error with WebDriver error code no such window.
</li>
	<li>
%結果 ~LET `利用者~promptを取扱う$()
◎
Handle any user prompts,＼
</li>
	<li>
~IF［
%結果 は`~error$wdrである
］
⇒
~RET %結果
◎
and return its value if it is a WebDriver error.
</li>
	<li>
~IF［
`現在の閲覧文脈$に結付けられている`模擬~sensor$であって，その`模擬~sensor型$が %型 に合致するものはある
］
⇒＃
その`模擬~sensor$を削除する；
~RET `成功$wdr( ~NULL )
◎
If type does not match a mock sensor type amongst all associated mock sensors of the current browsing context, return a WebDriver error with WebDriver error code no such mock sensor.
◎
Delete type of mock sensor in current browsing context.
◎
Return success with data null.
</li>
	<li>
~RET `~error$wdr( `そのような模擬~sensorは無い$i )
◎
↑</li>
</ol>
</div>

			</section>
		</section>
		<section id="extension-handling-errors">
<h3 title="Handling errors">9.3. ~errorの取扱い</h3>

<p>
この節は、~WebDriverによる
<a href="~WEBDRIVER#handling-errors">~errorの取扱い</a>
を拡張する
— 次の表に，`模擬~sensor$用に特有な，拡張された`~WebDriver~error~code$を定義する：
◎
This section extends the Handling Errors and defines extended WebDriver error codes specific for mock sensor in following table.
</p>

<table class="def" id="mock-sensor-error-code"><thead><tr>
<th>~error~code
<th>~HTTP状態s~code
<th>~JSON~error~code
<th>記述
</thead><tbody>

<tr><td>`そのような模擬~sensorは無い@i
<td>404
<td>`no such mock sensor^c
<td>
所与の型に合致している模擬~sensorは、見出されなかった。
◎
no mock sensor matching the given type was found.

<tr><td>`模擬~sensorは作成-済み@i
<td>500
<td>`mock sensor already created^c
<td>
`模擬~sensor$を作成する<a href="#section-extension-commands">~command</a>は、所与の型の`模擬~sensor$はすでに存在していたので，満たせなかった。
◎
A command to create a mock sensor could not be satisfied because the given type of mock sensor is already existed.
</tbody></table>

		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">10. 拡張能</h2>

~INFORMATIVE

<p class="note">注記：
この節（下位節も含む）は、規範的な言語を利用して`拡張~仕様$の`作者~向け^emの手引きを供する。
`実装者^emの視点からは、この節は規範的でないと見なされる。
◎
Note: This section and its subsections provide guidance to extension specification authors using normative language. From implementers' point of view, this section and its subsections are considered non-normative.
</p>

<p>
この節は、この仕様をどう拡張すれば，各種`~sensor型$用の~APIを指定できるかを述べる。
◎
This section describes how this specification can be extended to specify APIs for different sensor types.
</p>

<p>
そのような
`拡張~仕様@
には、［
単独の`~sensor型$に~focusすること,
`高level$, `低level$
両者とも適切に公開すること
］が奨励される。
◎
Such extension specifications are encouraged to focus on a single sensor type, exposing both high and low level as appropriate.
</p>

<p>
`拡張~仕様$には、`~sensor読取り$に`較正$処理-を適用するかどうか定義することが奨励される。
◎
Extension specifications are encouraged to define whether a calibration process applies to sensor readings.
</p>

<p>
`拡張~仕様$は、結付けられている`~sensor型$用に［
`局所~座標系$を明示的に定義してもヨイ／
`Sensor$I ~objごとに環境設定-可能にしてもヨイ
］。
◎
Extension specifications may explicitly define the local coordinate system for the associated sensor type or make it configurable per Sensor object.
</p>

<p>
`拡張~仕様$の~~最新の~listについては、［
`GENERIC-SENSOR-USECASES$r,
`MOTION-SENSORS$r
］文書を見られたし。
◎
For an up-to-date list of extension specifications, please refer to [GENERIC-SENSOR-USECASES] and [MOTION-SENSORS] documents.
</p>

		<section id="extension-security-and-privacy">
<h3 title="Security and Privacy">10.1. ~securityと~privacy</h3>

<p>
`拡張~仕様$には、次が期待される：
◎
Extension specifications are expected to:
</p>

<ul>
	<li>
汎用な<a href="#mitigation-strategies">軽減~策</a>に適合すること
◎
conform with the generic mitigation strategies,
</li>
	<li>
<a href="#mitigation-strategies-case-by-case">事例~別に適用される軽減~策</a>
を考慮すること
◎
consider mitigation strategies applied on a case by case basis,
</li>
	<li>
`Self-Review Questionnaire on Security and Privacy^cite
`SECURITY-PRIVACY-QUESTIONNAIRE$r
（~securityと~privacyについての自己評価質問票）を評価すること
◎
be evaluated against the Self-Review Questionnaire on Security and Privacy [SECURITY-PRIVACY-QUESTIONNAIRE],
</li>
	<li>
特に，~sensorが［
同一-生成元~施策で統治されない，新たな通信~channel
］を公開する場合に発生し得る，`同一-生成元~施策~違反$に対し評価すること。
◎
and in particular, be evaluated against the same-origin policy violations that can arise if sensors expose a new communication channel not governed by the same-origin policy.
</li>
</ul>

		</section>
		<section id="naming">
<h3 title="Naming">10.2. 命名-法</h3>

<p>
`低level$な~sensor用の `Sensor$I ~interfaceは、それが結付ける`~platform~sensor$の名前を継ぐベキである。
例えば， `gyroscope^en （ ~gyroscope）を結付ける~interfaceは、単純に `Gyroscope^I と命名されるベキである。
`高level$な~sensor用の `Sensor$I ~interfaceは、その`~platform~sensor$が計測する物理量に "Sensor" 接尾辞を組合せて命名されるベキである。
例えば，自身からの距離【 `proximity^en／~~近接度】を計測している`~platform~sensor$を結付ける~interfaceは、
`ProximitySensor^I
と命名されるベキである。
◎
Sensor interfaces for low-level sensors should be named after their associated platform sensor. So for example, the interface associated with a gyroscope should be simply named Gyroscope. Sensor interfaces for high-level sensors should be named by combining the physical quantity the platform sensor measures with the "Sensor" suffix. For example, a platform sensor measuring the distance at which an object is from it may see its associated interface called ProximitySensor.
</p>

<p>
`Sensor$I 下位classの属性のうち，`~sensor読取り$の値たちを保持するものは、これらの値たちを成す全部的な名前を継ぐベキである。
例えば， `Thermometer^I ~interfaceは、`~sensor読取り$の値を `temperature^m 属性~内に保持するベキである（ `value^m や `temp^m 属性ではなく）。
命名のための良い出発点は
`Quantities, Units, Dimensions and Data Types Ontologies^cite
`QUDT$r
にある。
◎
Attributes of the Sensor subclass that hold sensor readings values should be named after the full name of these values. For example, the Thermometer interface should hold the sensor reading's value in a temperature attribute (and not a value or temp attribute). A good starting point for naming are the Quantities, Units, Dimensions and Data Types Ontologies [QUDT].
</p>

		</section>
		<section id="unit">
<h3 title="Unit">10.3. 単位</h3>

<p>
`拡張~仕様$は、`~sensor読取り$の単位を指定しなければナラナイ。
◎
Extension specifications must specify the unit of sensor readings.
</p>

<p>
`Technical Architecture Group^cite (TAG)
による~API設計-原則 `API-DESIGN-PRINCIPLES$r に則り、すべての時間~計測は，~millisecondsになるベキである。
他のすべての単位は、 `SI Brochure^cite `SI$r に述べられるように，選好~順で次に挙げるいずれかを利用して指定されるベキである
⇒＃
~SI単位系（ `International System of Units^en ）,
~SIから導出された単位,
~SIとの併用に受容される非~SI単位
◎終
ただし例外として、温度は，~Kelvin【絶対温度】より~Celsiusの方が選好される。
◎
As per the Technical Architecture Group’s (TAG) API Design Principles [API-DESIGN-PRINCIPLES], all time measurement should be in milliseconds. All other units should be specified using, in order of preference, and with the exception of temperature (for which Celsius should be favored over Kelvin), the International System of Units (SI), SI derived units, and Non-SI units accepted for use with the SI, as described in the SI Brochure [SI].
</p>

		</section>
		<section id="high-vs-low-level">
<h3 title="Exposing High-Level vs. Low-Level Sensors">10.4. 高levelか低levelか，どちらの~sensorを公開するか</h3>

<p>
これまで，~sensorを~Web~platformに公開している仕様は、`高level$な~sensor~APIに~focusしていた。
`GEOLOCATION-API$r
`ORIENTATION-EVENT$r
◎
So far, specifications exposing sensors to the Web platform have focused on high-level sensors APIs. [GEOLOCATION-API] [ORIENTATION-EVENT]
</p>

<p>
これは、いくつかの理由から適理な~approachであった。
~~実際, `高level$な~sensorは：
◎
This was a reasonable approach for a number of reasons. Indeed, high-level sensors:
</p>

<ul>
	<li>
開発者の意図を明瞭に伝える。
◎
convey developer intent clearly,
</li>
	<li>
下層の~hardwareの~sensorがどう機能するかについて親密な知識を要求しない。
◎
do not require intimate knowledge of how the underlying hardware sensors functions,
</li>
	<li>
利用するのが容易である。
◎
are easy to use,
</li>
	<li>
~UAは処理能と~battery寿命を有意に改善できるようになり得る。
◎
may enable the User Agent to make significant performance and battery life improvements,
</li>
	<li>
公開される情報の量や型を減らすことにより，ある種の［
~privacy／~security
］課題を避ける一助になる。
◎
help avoid certain privacy and security issues by decreasing the amount and type of information exposed.
</li>
</ul>

<p>
しかしながら，仮想現実（ `virtual reality^en ）や拡張現実（ `augmented reality^en ）などの利用-事例が数を増やしており、特に処理能の理由から，~sensorへの`低level$な~accessが要求されている。
◎
However, an increasing number of use cases such as virtual and augmented reality require low-level access to sensors, most notably for performance reasons.
</p>

<p>
`低level$な~accessを供することは、~Web~app開発者が［
専門分野に特有な拘束を活用する／
もっと高処理能な~systemを設計する
］ことを可能化する。
◎
Providing low-level access enables Web application developers to leverage domain-specific constraints and design more performant systems.
</p>

<p>
`拡張~仕様$は、
`Extensible Web Manifesto^cite `EXTENNNNSIBLE$r
の~~原則に従い，第一に`低level$な~sensor~APIを公開することに~focusするベキであるが、`高level$な~APIも
— そうすることに明瞭な便益があるときには —
公開するベキである。
◎
Following the precepts of the Extensible Web Manifesto [EXTENNNNSIBLE], extension specifications should focus primarily on exposing low-level sensor APIs, but should also expose high-level APIs when they are clear benefits in doing so.
</p>

		</section>
		<section id="multiple-sensors">
<h3 title="When is Enabling Multiple Sensors of the Same Type Not the Right Choice?">10.5. 同じ型の複数の~sensorを可能化するのは、どのようなとき~~相応しくないか？</h3>

<p>
同じ`~sensor型$の複数の `Sensor$I ~instanceを，等しい構築~parameterを伴わせて構築することは、~hardware資源の不必要な消費を導き得るので，勧められない。
◎
It is not advisable to construct multiple Sensor instances of the same sensor type with equal construction parameters, as it can lead to unnecessary hardware resources consumption.
</p>

<p>
複数の観測器が，新たに可用な`~sensor読取り$の通知に関心がある事例では
— 同じ`~sensor型$の複数の~instanceを作成する代わりに —
単独の `Sensor$I ~instanceに`~event~listener$を追加して，単純な `onreading$m ~event~handlerを利用できる。
◎
In cases when multiple observers are interested in notifications of a newly available sensor reading, an event listener can be added on a single Sensor instance instead of creating multiple instances of the same sensor type and using simple onreading event handler.
</p>

<p>
逆に，異なる設定群での利用を意図するなら、同じ`~sensor型$の複数の `Sensor$I を作成できる
— `要請した標本化~frequency$／正確度／`拡張~仕様$に定義される他の設定群など。
◎
Conversely, multiple Sensors of the same sensor type can be created when they are intended to be used with different settings, such as: requested sampling frequency, accuracy or other settings defined in extension specifications.
</p>

		</section>
		<section id="definition-reqs">
<h3 title="Definition Requirements">10.6. 定義~要件</h3>

<p>
`拡張~仕様$においては、各`~sensor型$に対し，次に挙げる定義を指定しなければナラナイ：
◎
The following definitions must be specified for each sensor type in extension specifications:
</p>

<dl class="def-list">
	<dt>`拡張~sensor~interface@</dt>
	<dd>
<p>
次をすべて満たす`~interface$でなければナラナイ：
</p>
		<ul>
			<li>
`Sensor$I ~IN `継承した~interfaceたち$
</li>
			<li>
<code>[<a href="~WEBIDL#Constructor">Constructor</a>]</code>
拡張d属性を伴う
— すなわち、構築-可能である。
</li>
			<li>
前項の構築子は、次を満たす省略可能な`辞書$を引数にとる
⇒
`SensorOptions$I ~IN `継承した辞書たち$
</li>
</ul>

◎
An extension sensor interface, which is an interface whose inherited interfaces contains Sensor. The extension sensor interface must be constructible. Its [Constructor] must take, as an argument, an optional dictionary whose inherited dictionaries contains SensorOptions.
</dd>
	<dd>
`拡張~sensor~interface$は、
`~supportする~sensor~optionたち@
— それが~supportする一連の~option【の名前】からなる`集合$ —
を持つ。
`拡張~仕様$が他を定義しない限り、
`~supportする~sensor~optionたち$は，単独の~item `frequency^l のみからなるとする。
◎
The extension sensor interface has a set of supported options referred to as supported sensor options. Unless the extension specification defines otherwise, supported sensor options contain a single item which is "frequency".
</dd>
	<dd>
~UAは、所与の`拡張~sensor~interface$用の`~supportする~sensor~optionたち$から，自身が~supportできない各~sensor~optionに対応する~itemを除去するモノトスル。
◎
The user agent must remove items from supported sensor options for a given extension sensor interface if it cannot support the corresponding sensor options.
</dd>
	<dd>
`拡張~sensor~interface$の各`属性$のうち`~sensor読取り$を公開するものは、`読専$であり，それらの取得子は，次を呼出した結果を返すモノトスル
⇒
`最新な読取り~mapから値を取得する$( 此れ, `属性$の`識別子$ )
◎
The extension sensor interface attributes which expose sensor readings are read only and their getters must return the result of invoking get value from latest reading with this and attribute identifier as arguments.
</dd>

	<dt>`~sensor型$</dt>
	<dd>
`~sensor融合$を表現して［
いないならば`許可~名$／
いるならば 融合~源`~sensor型$に結付けられている`許可~名$たち
］を利用しなければナラナイ。
◎
A permission name, if the sensor type is not representing sensor fusion (otherwise, permission names associated with the fusion source sensor types must be used).
</dd>
</dl>

<p>
`拡張~仕様$は、各`~sensor型$に対し，次に挙げる定義を指定してもヨイ：
◎
An extension specification may specify the following definitions for each sensor types:
</p>
<ul>
	<li>
次を満たす`辞書$
⇒
`SensorOptions$I ~IN それが`継承した辞書たち$
◎
A dictionary whose inherited dictionaries contains SensorOptions.
</li>
	<li>
`既定の~sensor$。
~deviceが所与の`~sensor型$用に備える`~platform~sensor$は，一般に 1 つだけなので、`既定の~sensor$を定義することは単直なはずである。
複数の`~device~sensor$が共通的な所では、`拡張~仕様$は，当の`~sensor型$用の`既定の~sensor$を定義しないことにしてもヨイ
— とりわけ，そうしてもイミを成さないときには。
◎
A default sensor. Generally, devices are equipped with a single platform sensor of each type, so defining a default sensor should be straightforward. For sensor types where multiple sensors are common, extension specifications may choose not to define a default sensor, especially when doing so would not make sense.
</li>
</ul>

		</section>
		<section id="extend-automation">
<h3 title="Automation">10.7. 自動化</h3>

<p>
~UAの自動化と~appの~test法を可能化するため、`拡張~仕様$には，次が奨励される：
◎
In order to enable user-agent automation and application testing, extension specifications are encouraged to:
</p>

<ul>
	<li>
`MockSensorType$I 列挙型に［
各 `拡張~sensor~interface$用の新たな`模擬~sensor型$
］を追加する。
◎
Add new mock sensor type for each extension sensor interface to the MockSensorType enum.
</li>
	<li>
`模擬~sensor読取り値たち$を~~表現する辞書を定義する。
◎
Define a mock sensor reading values dictionary.
</li>
</ul>

		</section>
		<section id="permission-api">
<h3 title="Extending the Permission API">10.8. 許可~APIの拡張-法</h3>

<p>
各`~sensor型$用の `Sensor$I ~interfaceの実装は、それによる`~sensor読取り$を，結付けられている［
`許可~名$ ／ `PermissionDescriptor$I【`許可~記述子~型$】
］により保護するモノトスル。
`低level$な `Sensor$I は、`許可~名$として その~interface名を利用してもヨイ（例： `gyroscope^l ／ `accelerometer^l ）。
`~sensor融合$は、融合~源として利用される各~sensorに対し，`~accessする許可を要請-$するモノトスル。
◎
An implementation of the Sensor interface for each sensor type must protect its reading by associated permission name or PermissionDescriptor. A Low-level sensor may use its interface name as a permission name, for instance, "gyroscope" or "accelerometer". Fusion sensors must request permission to access each of the sensors that are used as a source of fusion.
</p>

<p>
融合された~dataから`低level$な`~sensor読取り$を構築し直すのは困難であっても、元の情報の一部は，推定され得る。
例えば［
`絶対~方位~sensor$／`地磁気~方位~sensor$
］が利用されれば，空間における利用者の方位を演繹するのは容易である。
したがって，これらの~sensorは、磁力計を`利用する許可を要請-$するモノトスル
— ~deviceの方位についての情報を地球の磁場との関係で供するので。
対照的に，`相対~方位~sensor$は そのような情報を公開しないので、磁力計を`利用する許可を要請-$する必要はない。
◎
Even though it might be difficult to reconstruct low-level sensor readings from fused data, some of the original information might be inferred. For example, it is easy to deduce user’s orientation in space if absolute or geomagnetic orientation sensors are used, therefore, these sensors must request permission to use magnetometer as it provides information about orientation of device in relation to Earth’s magnetic field. In contrast, relative orientation sensor does not expose such information, thus, it does not need to request permission to use magnetometer.
</p>

<p>
`PermissionDescriptor$I も利用できる
— 正確度または`標本化~frequency$に許容される上限を設定するためとして。
◎
Permission descriptors can also be used to set maximum allowed limits for accuracy or sampling frequency.＼
</p>

<div class="example">
<p>
加速度計~sensor用の許可~APIにアリな拡張の例：
◎
An example for a possible extension of the Permission API for accelerometer sensor is given below.
</p>

<pre class="idl">
dictionary AccelerometerPermissionDescriptor : `PermissionDescriptor$I {
    boolean highAccuracy = false;
    boolean highFrequency = false;
};
</pre>

</div>

		</section>
		<section id="feature-policy-api">
<h3 title="Extending the Feature Policy API">10.9. 特能~施策~APIの拡張-法</h3>

<p>
各`~sensor型$用の `Sensor$I ~interfaceの実装には、
1 個（`~sensor融合$は遂行されない場合）または複数個の，`施策により制御される特能$が結付けられる
— それらは、その実装を文書~内で利用できるかどうかを制御する。
◎
An implementation of the Sensor interface for each sensor type has one (if sensor fusion is not performed) or several policy-controlled features that control whether or not this implementation can be used in a document.
</p>

<p>
これらの各`施策により制御される特能$の`既定の許容list$は、
« `self^l »
とする。
◎
The features' default allowlist is ["self"].
</p>

<p class="trans-note">【
複数の`~sensor型$用の `Sensor$I ~interfaceが同じ特能を共有する場合に、~interfaceごとに異なる`既定の許容list$を指定する必要が生じる~~状況は，今の所は想定されていないようだ。
】</p>

<p class="note">注記：
`既定の許容list$
« `self^l »
は、 `Sensor$I ~interfaceの実装の用法を，［
同一-生成元に属する入子にされた~frame
］には許容するが、［
第三者主体~内容による`~sensor読取り$への~access
］は防止する。
◎
Note: The default allowlist of ["self"] allows Sensor interface implementation usage in same-origin nested frames but prevents third-party content from sensor readings access.
</p>

<p>
`~sensor特能~名たち$は、それに結付けられている［
各`施策により制御される特能$を識別する~token
］からなるモノトスル。
◎
The sensor feature names set must contain policy-controlled feature tokens of every associated feature.
</p>

<p>
`低level$な`~sensor型$は、その~interface名を`施策により制御される特能$用の~tokenとして利用してもヨイ
— 例： `gyroscope^l ／ `accelerometer^l
。
`拡張~仕様$が他を定義しない限り，`~sensor特能~名たち$は、同じ`~sensor型$に結付けられた`~sensor許可~名たち$に合致する。
◎
A Low-level sensor may use its interface name as a policy-controlled feature token, for instance, "gyroscope" or "accelerometer". Unless the extension specification defines otherwise, the sensor feature names matches the same type-associated sensor permission names.
</p>

<div class="example html">
<p>
加速度計~特能は、~frame容器~要素に
<a href="~FEATUREPOLICY#iframe-allow-attribute">`allow^a 属性</a>
を追加することにより，第三者主体の生成元~用に選択的に可能化される：
◎
The accelerometer feature is selectively enabled for third-party origin by adding allow attribute to the frame container element:
</p>

<pre class="js-code">
&lt;iframe src="https://third-party.com" allow="accelerometer"/&gt;&lt;/iframe&gt;
</pre>
</div>

<div class="example">
<p>
~sensor用法は、~HTTP応答~header内に特能~施策を指定することにより，完全に不能化される：
◎
A sensor usage is disabled completely by specifying the feature policy in a HTTP response header:
</p>

<pre class="js-code">
Feature-Policy: {"accelerometer": []}
</pre>
</div>

<p>
`~sensor融合$は、融合~源として利用される各~sensorの`~sensor特能~名たち$を利用するモノトスル。
◎
Fusion sensors must use sensor feature names of the sensors that are used as a source of fusion.
</p>

<div class="example">
<p>
`絶対~方位~sensor$に要求される［
加速度計, 磁力計, ~gyroscope
］特能を利用するのを，第三者主体~生成元に許容する：
◎
Allow third-party origin to use accelerometer, magnetometer and gyroscope features that are required by the absolute orientation sensor.
</p>

<pre class="js-code">
&lt;iframe src="https://third-party.com" allow="accelerometer; magnetometer; gyroscope"/&gt;
</pre>
</div>

		</section>
		<section>
<h3 title="Example WebIDL">10.10. ~WebIDL例</h3>

<div class="example">

<p>
この仕様の拡張としてアリな，近接`~device~sensor$用の~WebIDLの例：
◎
Here’s an example WebIDL for a possible extension of this specification for proximity sensors.
</p>

<pre class="idl">
[Constructor(optional ProximitySensorOptions proximitySensorOptions = {}),
 SecureContext, Exposed=Window]
interface ProximitySensor : Sensor {
    readonly attribute double? distance;
};

dictionary ProximitySensorOptions : SensorOptions {
    double min;
    double max;
    ProximitySensorPosition position;
    ProximitySensorDirection direction;
};

enum ProximitySensorPosition {
    "top-left",
    "top",
    "top-right",
    "middle-left",
    "middle",
    "middle-right",
    "bottom-left",
    "bottom",
    "bottom-right"
};

enum ProximitySensorDirection {
    "front",
    "rear",
    "left",
    "right",
    "top",
    "bottom"
};
</pre>
</div>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">11. 謝辞</h2>


<div lang="en-x-a0">
<p>
First and foremost, I would like to thank Anssi Kostiainen for his continuous and dedicated support and input throughout the development of this specification, as well as Mikhail Pozdnyakov, Alexander Shalamov, Rijubrata Bhaumik, and Kenneth Rohde Christiansen for their invaluable implementation feedback, suggestions, and research that have helped inform the specification work.
</p>

<p>
Special thanks to Rick Waldron for driving the discussion around a generic sensor API design for the Web, sketching the original API on which this is based, providing implementation feedback from his work on Johnny-Five, and continuous input during the development of this specification.
</p>

<p>
Special thanks to Boris Smus, Tim Volodine, and Rich Tibbett for their initial work on exposing sensors to the web with consistency.
</p>

<p>
Thanks to Anne van Kesteren for his tireless help both in person and through IRC.
</p>

<p>
Thanks to Domenic Denicola and Jake Archibald for their help.
</p>

<p>
Thanks also to Frederick Hirsch and Dominique Hazaël-Massieux (via the HTML5Apps project) for both their administrative help and technical input.
</p>

<p>
Thanks to Tab Atkins for making Bikeshed and taking the time to explain its subtleties.
</p>

<p>
Thanks to Lukasz Olejnik and Maryam Mehrnezhad for their contributions around privacy and security.
</p>

<p>
The following people have greatly contributed to this specification through extensive discussions on GitHub: Anssi Kostiainen, Boris Smus, chaals, Claes Nilsson, Dave Raggett, David Mark Clements, Domenic Denicola, Dominique Hazaël-Massieux (via the HTML5Apps project), Francesco Iovine, Frederick Hirsch, gmandyam, Jafar Husain, Johannes Hund, Kris Kowal, Lukasz Olejnik, Marcos Caceres, Marijn Kruisselbrink, Mark Foltz, Mats Wichmann, Matthew Podwysocki, Olli Pettay, pablochacin, Remy Sharp, Rich Tibbett, Rick Waldron, Rijubrata Bhaumik, robman, Sean T. McBeth, Tab Atkins Jr., Virginie Galindo, zenparsing, and Zoltan Kis.
</p>

<p>
We’d also like to thank Anssi Kostiainen, Dominique Hazaël-Massieux, Erik Wilde, and Michael[tm] Smith for their editorial input.
</p>
</div>

	</section>
</main></div>
