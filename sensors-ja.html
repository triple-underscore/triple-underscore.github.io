<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Generic Sensor API（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">


<style>
@supports (grid-template-columns: subgrid) and (display: contents) {
	#sensor-slots {
		grid-template-columns: 5em 1fr 1fr;
		min-width: 20em;
		max-width: 45em;
	}
	#sensor-slots tr {
		grid-template-areas:
			"slot slot slot"
			". 値 初期"
			". 記述 記述"
		;
	}
	
	#sensor-slots tr > *:nth-child(1) {
		grid-area: slot;
	}
	
	#sensor-slots tr > *:nth-child(2) {
		grid-area: 値;
	}
	
	#sensor-slots tr > *:nth-child(3) {
		grid-area: 初期;
	}
	
	#sensor-slots tr > *:nth-child(4) {
		grid-area: 記述;
	}
}

#_ex-lifecycle {
	text-align: center;
	width: 20em;
}
#_ex-lifecycle .ex-state {
	background: var(--bg-color-1);
	border-radius: 0.3em;
	border: thin solid var(--pale-color);
	padding: 0.3em;
}

#_ex-lifecycle .ex-ends {
	border: thin dashed var(--dim-color);
	border-radius: 0.3em;
	color: gray;
}

#_ex-lifecycle .ex-transition {
}

.ex-model {
	margin: 1em;
	white-space:nowrap;
	position: relative;
	line-height: 1.4em;
	height: 30em;
}

.ex-model-box {
	position: absolute;
	display: inline-block;
	padding: 0;
}

.ex-model-box > :first-child {
	border-bottom: solid thin var(--K-color);
	padding: 0.2em;
}

.ex-model-bc {
	position: absolute;
	width:14em;
	height:13em;
	border: thin solid var(--pale-color);
	padding: 0.5em;
}

.ex-model li,
.ex-model ul {
	margin: 0;
	display: block;
	padding: 0;
}
.ex-model li::before {
	content: "•";
	padding: 0.2em;
}

.ex-model-line {
	position: absolute;
	display: block;
	height: 0;
	border: none;
	border-top: dashed thin var(--K-color);
	transform-origin: top right;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'mc':
	text = 'constructor';
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Generic Sensor API
spec_date:2023-11-22
trans_update:2023-11-28
source_checked:231006
spec_status:ED
original_url:https://w3c.github.io/sensors/
	abbr_url:SENSORS
ref_id_prefix:biblio-
ref_id_lowercase:true
page_state_key:SENSORS
site_nav:sensors
conformance:w3c
ref_id_lowercase:true
copyright:2023,permissive
trans_1st_pub:2019-08-22
	conformance:w3c

●●class_map
E:error
et:event-type
sl:js-slot
e:element
a:attr
hm:method
jt:js-type
jv:js-value

●●tag_map
I:code
E:code
m:code
c:code
mc:code
mC:code
mb:code
cite:cite
et:code
sl:span
a:code
e:code
jt:code
jv:code
i:i
hm:code
em:em

●●original_id_map

	dom-sensor-activated:sensor-activated
	sensor-has-reading:dom-sensor-hasreading
	dom-sensor-timestamp:sensor-timestamp
	dom-sensor-start:sensor-start
	dom-sensor-stop:sensor-stop
	dom-sensor-onreading:sensor-onreading
	dom-sensor-onactivate:sensor-onactivate
	dom-sensor-onerror:sensor-onerror

●●mdn_urls
sensor:API/Sensor
sensorerrorevent:API/SensorErrorEvent
	dictdef-sensorerroreventinit:API/SensorErrorEventInit
	dictdef-sensoroptions:API/SensorOptions

●●link_map

	●IDL

SecureContext:~WEBIDLjs#SecureContext
Exposed:~WEBIDLjs#Exposed

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
double:~WEBIDL#idl-double
DOMString:~WEBIDL#idl-DOMString

E.NotReadableError:~WEBIDL#notreadableerror
E.NotAllowedError:~WEBIDL#notallowederror
E.NotSupportedError:~WEBIDL#notsupportederror
I.DOMException:~WEBIDL#idl-DOMException

I.Sensor:#sensor
I.SensorErrorEvent:#sensorerrorevent
I.SensorErrorEventInit:#dictdef-sensorerroreventinit
I.SensorOptions:#dictdef-sensoroptions


I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.EventHandler:~WAPI#eventhandler
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.PermissionDescriptor:~PERMISSIONS#dom-permissiondescriptor

mc.SensorErrorEvent:#dom-sensorerrorevent-sensorerrorevent
m.activated:#dom-sensor-activated
m.hasReading:#dom-sensor-hasreading
m.timestamp:#dom-sensor-timestamp
m.start:#dom-sensor-start
m.stop:#dom-sensor-stop
m.onreading:#dom-sensor-onreading
m.onactivate:#dom-sensor-onactivate
m.onerror:#dom-sensor-onerror
m.frequency:#dom-sensoroptions-frequency

m.error:#dom-sensorerrorevent-error
mb.error:#dom-sensorerroreventinit-error

jt.Array:https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array-objects
jt.Object:https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object-objects
jt.String:https://tc39.es/ecma262/multipage/text-processing.html#sec-string-objects
jt.Boolean:https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-boolean-objects
jt.Number:https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-number-objects

sl.state:#dom-sensor-state-slot
sl.frequency:#dom-sensor-frequency-slot
	provided frequencies:#dom-sensor-frequency-slot
sl.lastEventFiredAt:#dom-sensor-lasteventfiredat-slot
sl.pendingReadingNotification:#dom-sensor-pendingreadingnotification-slot

et.activate:#_event-activate
	et.activated:#_event-activated
et.reading:#_event-reading
et.error:#_event-error

a.allow:~HEembed#attr-iframe-allow

	●用語

~device~sensor:#concept-device-sensor
~platform~sensor:#concept-platform-sensor
既定の~sensor:#default-sensor
空間的~sensor:#spatial-sensor
~sensor融合:#sensor-fusion
高level:#high-level
低level:#low-level
~smart~sensor:#smart-sensors
~sensor型:#sensor-type

~sensor許可~名~群:#sensor-permission-names
~sensor特能~名~群:#sensor-feature-names
~sensor~task~source:#sensor-task-source
作動化された~sensor~obj群:#activated-sensor-objects
~supportする~sensor~option群:#supported-sensor-options

~sensor読取りを公開できる:#can-expose-sensor-readings
~sensor読取り:#sensor-reading
読取り時刻印:#reading-timestamp
読取り変化~threshold:#reading-change-threshold
最新な読取り~map:#latest-reading
属する~sensor型:#_platform-sensor-type
~threshold検査~algo:#threshold-check-algorithm
読取り量子化~algo:#reading-quantization-algorithm

標本化~frequency:#sampling-frequency
最小~標本化~frequency:#sensor-type-minimum-sampling-frequency
最大~標本化~frequency:#sensor-type-maximum-sampling-frequency
dV.最小~標本化~frequency:#device-sensor-minimum-sampling-frequency
dV.最大~標本化~frequency:#device-sensor-maximum-sampling-frequency
報告ng~frequency:#reporting-frequency
~platform~sensorの標本化~限界域を取得する:#get-a-platform-sensors-sampling-bounds

較正:#calibration
拡張~仕様:#extension-specification
特有な条件:#specific-conditions
拡張~sensor~interface:#extension-sensor-interface

局所~座標系:#local-coordinate-system

	■演算
~sensorに接続する:#connect-to-sensor
~sensor~accessを要請する:#request-sensor-access
~sensor~objを作動化する:#activate-a-sensor-object
~sensor~objを非作動化する:#deactivate-a-sensor-object
~sensor設定群を設定する:#set-sensor-settings
最新な読取りを更新する:#update-latest-reading
最新な読取り~mapから値を取得する:#get-value-from-latest-reading
最新な読取り更新を報告する:#report-latest-reading-updated
新たな読取りを通知する:#notify-new-reading
作動化d状態を通知する:#notify-activated-state
~errorを通知する:#notify-error


	■~virtual~sensor
有限な数:#_finite-number
~virtual~sensor型:#virtual-sensor-type
属する~virtual~sensor型:#_virtual-sensor-type
~virtual~sensor:#virtual-sensor
vS.要請された標本化~frequency:#virtual-sensor-requested-sampling-frequency
vS.最小~標本化~frequency:#virtual-sensor-minimum-sampling-frequency
vS.最大~標本化~frequency:#virtual-sensor-maximum-sampling-frequency
vS.読取りを供せるか:#virtual-sensor-can-provide-readings-flag
~virtual~sensor~metadata:#virtual-sensor-metadata
~virtual~sensor対応付け:#virtual-sensor-mapping
読取りを供せるか:#virtual-sensor-can-provide-readings-flag
型ごとの~virtual~sensor~metadata:#per-type-virtual-sensor-metadata
vsM.読取り構文解析~algo:#virtual-sensor-metadata-reading-parsing-algorithm


	＠#feature-detection
	＠#main-privacy-security-threats
	＠#location-tracking
	＠#eavesdropping
	＠#keystroke-monitoring
	＠#device-fingerprinting
	＠#user-identifying
	＠#limit-max-frequency
	＠#extensibility
	＠#mitigation-strategies
	＠#mitigation-strategies-case-by-case
	＠#model
	＠#sensor-lifecycle
	＠#event-handlers
	＠#concepts-sampling-and-reporting-frequencies
	＠#create-virtual-sensor-command
	＠#delete-virtual-sensor-command
	＠#virtual-sensors

	●用語（外部
実装定義:~INFRA#implementation-defined
真偽値:~INFRA#boolean
文字列:~INFRA#string
集合:~INFRA#ordered-set
空:~INFRA#list-is-empty
	~IN:~INFRA#list-contain
	~EACH:~INFRA#list-iterate
	~CONTINUE:~INFRA#iteration-continue
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
~list:~INFRA#list
~item:~INFRA#list-item
~tuple:~INFRA#tuple
~map:~INFRA#ordered-map
有順序~map:~INFRA#ordered-map
~entry:~INFRA#map-entry
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
	~~EACH:~INFRA#map-iterate
set.付加する:~INFRA#set-append
除去する:~INFRA#list-remove
	値を設定する:~INFRA#map-set
	~entryを除去する:~INFRA#map-remove
	~map内に存在する:~INFRA#map-exists

現在の~realm:~TC39#current-realm

~interface:~WEBIDL#dfn-interface
構築子~演算:~WEBIDL#idl-constructors
継承した~interface群:~WEBIDL#dfn-inherited-interfaces
継承した辞書~群:~WEBIDL#dfn-inherited-dictionaries
読専:~WEBIDL#dfn-read-only
属性:~WEBIDL#dfn-attribute
識別子:~WEBIDL#dfn-identifier
例外を作成する:~WEBIDL#dfn-create-exception
辞書:~WEBIDL#dfn-dictionary
	~THROW:~WEBIDL#dfn-throw

文書:~DOM4#concept-document
発火され:~DOM4#concept-event-fire-
~event~listener:~DOM4#concept-event-listener
~event:~DOM4#concept-event
~eventを発火する:~DOM4#concept-event-fire
~event構築子:~DOM4#concept-event-constructor

粗化した~moment:~HRTIME#dfn-moment
1.安全でない現在の時刻:~HRTIME#monotonic-clock-unsafe-current-time
相対的な高分解能~時刻:~HRTIME#dfn-relative-high-resolution-time
安全でない共有される現在の時刻:~HRTIME#dfn-unsafe-shared-current-time
単調増加~時計:~HRTIME#dfn-monotonic-clock

既定の許容list:~PERMISSIONS-POLICY#policy-controlled-feature-default-allowlist

利用は許容されて:~HEembed#allowed-to-use
要請には特能の利用は許容されるべきか？:~PERMISSIONS-POLICY#should-request-be-allowed-to-use-feature
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

利用する許可を要請する:~PERMISSIONS#dfn-request-permission-to-use
~accessする許可を要請する:~PERMISSIONS#dfn-request-permission-to-use
名前:~PERMISSIONS#dfn-name
許可~記述子~型:~PERMISSIONS#dfn-permission-descriptor-type
許可~状態:~PERMISSIONS#dfn-permission-state
強力な特能:~PERMISSIONS#dfn-powerful-feature
許可~revocation~algo:~PERMISSIONS#dfn-permission-revocation-algorithm

doc.可視性~状態:~HTMLinteraction#visibility-state

対応する~navigable:~WINDOW#window-navigable
~navigable:~HTMLds#navigable
~top-level辿可能:~HTMLds#top-level-traversable
nav.~top-level辿可能:~HTMLds#nav-top
bc.作動中な文書:~HTMLds#active-document
	nav.作動中な文書:~HTMLds#nav-document
bc.~top-level辿可能:~HTMLds#bc-traversable
同じ生成元~domain:~ORIGIN#same-origin-domain
閲覧~文脈:~HTMLds#browsing-context

tlT.現在の被focus区画:~HTMLinteraction#currently-focused-area-of-a-top-level-traversable
~focusを得た:~HTMLinteraction#gains-focus
~DOM~anchor:~HTMLinteraction#dom-anchor

大域~obj:~WAPI#global-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
enV.~secureな文脈:~WAPI#secure-context
enV.時刻~起点:~WAPI#concept-settings-object-time-origin
~task~queue:~WAPI#task-queue
~taskを~queueする:~WAPI#queue-a-task
~task~source:~WAPI#task-source
~task:~WAPI#concept-task
~event~handler:~WAPI#event-handlers
~event~handler~event型:~WAPI#event-handler-event-type
~event~loopを回す:~WAPI#spin-the-event-loop
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes

生成元:~ORIGIN#concept-origin
doc.生成元:~DOM4#concept-document-origin
~node文書:~DOM4#concept-node-document

並列的:~HTMLINFRA#in-parallel

同一-生成元~施策~違反:~SECQ#sop-violations

相対~方位~sensor:~MOTION-SENSORS#relative-orientation-sensor
絶対~方位~sensor:~MOTION-SENSORS#absolute-orientation-sensor
地磁気~方位~sensor:~MOTION-SENSORS#geomagnetic-orientation-sensor

許可~要請~algo:~PERMISSION-REQUEST#permission-request-algorithm

	■WEBDRIVER
拡張~command:~WEBDRIVER#dfn-extension-commands
現在の閲覧~文脈:~WEBDRIVER#dfn-current-browsing-context
~URI~template:~WEBDRIVER#dfn-extension-command-uri-template
~remote端~手続き:~WEBDRIVER#dfn-remote-end-steps
~propを取得する:~WEBDRIVER#dfn-getting-properties
既定を伴う~propを取得する:~WEBDRIVER#dfn-getting-the-property-with-default
~session:~WEBDRIVER#dfn-session
~propを設定する:~WEBDRIVER#dfn-set-a-property

wdr.~error:#_webdriver-error
wdr.成功:#_webdriver-success

~WebDriver~error:~WEBDRIVER#dfn-error
~WebDriver~error~code:~WEBDRIVER#dfn-error-code
成功:~WEBDRIVER#dfn-success

i.無効な引数:~WEBDRIVER#dfn-invalid-argument

~url変数:~WEBDRIVER#dfn-url-variables
局所~端:~WEBDRIVER#dfn-local-ends

sensor_parts1:#_sensor_parts1

	:#robust-example
	~PERMISSIONS#dfn-new-information-about-the-user-s-intent
	~WEBDRIVER#dfn-object
	~WEBDRIVER#handling-errors
	~PERMISSIONS-POLICY#iframe-allow-attribute

●●words_table1

WEBDRIVER:https://w3c.github.io/webdriver/
MOTION-SENSORS:motion-sensors-ja.html
ORIENTATION-SENSOR:orientation-sensor-ja.html
ACCELEROMETER:accelerometer-ja.html
MAGNETOMETER:magnetometer-ja.html
AMBIENT-LIGHT:ambient-light-ja.html
GYROSCOPE:gyroscope-ja.html
GEOLOCATION-SENSOR:geolocation-sensor-ja.html
PROXIMITY:proximity-ja.html
PERMISSION-REQUEST:webappsec-permissions-request-ja.html

●●words_table

	^cite:SI Brochure
	^cite:Self-Review Questionnaire on Security and Privacy
	^cite:Secure Contexts
	^en:Least Common Denominator (LCD)
	^en:Open Web Platform
	^en:cell
	^en:runtime
	^en:compile-time

	許可~API:Permissions API
	汎用~sensor~API:Generic Sensor API

warrant:
critical-path:critical path

	●装置
device:
bluetooth:
hub:
CPU:
Kelvin:
Celsius:
GPS:
集積回路:chip::~
基地局三角測量:cell triangulation:~
wifi:
SI:
X:
Y:
Z:
battery:::バッテリ
寿命:life::~
motion::::モーション
温度:temperature::~
起点:origin::~
歩数計:pedometer::~
気圧:air pressure::~
気圧計:barometer::~
気圧高度計:pressure-altimeter::~
地理所在:geolocation::~
gyroscope::::ジャイロスコープ
磁力計:magnetometer::~
磁場:magnetic field::~
地磁気:geomagnetic::~
角速度:angular velocity::~
高度計:altimeter::~
圧抵抗圧力:resistive piezo-electric pressure:~
圧電:piezo-electric:~
加速度:acceleration::~
加速度計:accelerometer::~
光度:luminosity::~
信号:signal:~
smartphone::::スマホ
touch::::タッチ
近接:proximity::~
装身-:wear:~
	装身-可能:wearable
心拍数:heart-rate::~
携帯:mobile::~
smart::::スマート
hub::::ハブ
laptop::::ノートPC
製造:manufacturing:~
	製造~時:manufacturing time
製造時:manufacturing:~
meter::::メートル
	meter:-m
産物:product:~
製品:product:~

地球:Earth:~
Cartesian:::直交
軸:axis::~
単軸:uniaxial::~
二軸:biaxial::~
三軸:triaxial::~
直交な:orthogonalな::~
分解能:resolution::~
垂直:perpendicular::~
平行:parallel::~
軸受:bearing::~

	うち一つ:left rear
	左後輪:left rear tire
	空気圧:pressure

	~~頭の~~動き追跡:head-tracking
	~~歩数計:counting steps
	ムラ:imperfections and differences／variations and imperfections

	●sensor／測定
sensor::::センサー
高level:high-level:高 level::高レベル
低level:low-level:低 level::低レベル
物理量:physical quantity::~
	物理量:quantity
標本化:sampling::~::サンプリング
in-Hz:Hz 単位
補償-:compensate::~
較正:calibration::~
milli::::ミリ
	~milli秒数:milliseconds
	許容される上限:maximum allowed limits
threshold:
	残量以上:below 〜 threshold
noise::::ノイズ
合成な:syntheticな:~
融合-:fuse::~
融合:fusion::~
空間的:spatial::~
報告ng:reporting::報告
読出し:readout::~
frequency:
rate::::レート
polling:
poll:
	~pollしている:polling
最新な:latest:~
見積もっ:estimateし:~
見積もる:estimateする:~
見積もり:estimate:~
正確度:accuracy:正確さ
不正確度:inaccuracy:不正確さ
	正確度に劣る:less accurate
時間差:time deltas:~
量子化:quantization::~
丸めら:roundさ:~
丸める:roundする:~
生な:rawな:~

高分解能:high resolution::~
粗化-:coarsen:粗く
起点:origin::~
moment:
時計:clock::~::クロック
単調増加:monotonic::~
限界域:bounds::~
	上限:upper limit
	上限:upper bound
	下限:lower bound

	●WebDriver
模倣-:simulate:~
真似る:mimicする:~
WebDriver:
端:end::~
template:
virtual:
四元数:quaternion::~
切断-:disconnect:~
	一数:single-value number
xyz:
back:
	~backしている:backing

	●仕様
一助:help:~
上品:gracious:~
堅牢:robust:~
定常的:constant:~
定期的:regular:~
念頭:mind:~
成熟-:mature:~
推定-:infer:~
今日:today:~
共存-:coexist:~
分野:area:~
専門分野:domain:~
判定:judgement:~
包括的:comprehensive:~
機能-:function:~
特徴付けら:characterizeさ:~
	~~理想である:ideal world
発生-:arise:~
義務的:mandatory:~
資料:resource:~
選択的:selective:~
過程:process:~
退行-:degrade:~
選ばれ:chooseされ:~
選ぶ:chooseする:~
	ことにして:chooseして
遂げる:carry outする:~
遂げて:carry outして:~
遂げら:carry outさ:~
演繹-:deduce:~
安全弁付き:defensiveな:~
認知的負担:cognitive burden:~
適応-:accommodate:~
高処理能:performant:~
単直:straightforward:簡単
強化-:enhance:~
最終手段:last-resort solution:~
活用-:leverage:~
構造不明:nondescript:~
中間的:intermediary:~
本物の:realな:~
行使-:exercise:~
歩み:pace:~
	歩みが遅く:slow-paced
尊重-:respect:~
可能性:possibility:~
難題:challenge:~
発展-:evolve:~
	~~原則:precepts
高度な:advancedな:~
稀:rare:~
青写真:blueprint:~
論題:topic:~
査定-:assess:~
親密:intimate:~
分類-:categorize:~
分類:category:~
	-:categorization
種類:kind:~
創出-:create:~
揺籃期:incubation:~
明白:obvious:~
冗漫:verbose:~
措置:measure:~
想定-:suppose:~
保つ:keepする:~
注力-:focus:~
	出発点:starting point
	~~実際:indeed
	ぼやけている:blurred／:blurry
	に則り、:as per
	こともある:sometimes
	まま:left
	主な:main
	に基づいて:basis
	事例~別:case by case basis
	呼ばれ:called
	委ねられる:up to
	対照的に:in contrast
	導き:lead
	情報:info
	果たさ:serve
	極めて:extremely
	満たされ:satisfied
	に依存する-dependent
	線引き:line
	良い:good
	よくあてはまる:good fit for
	規範的でない:non-normative
	豊富にある:plentiful
	逆に:conversely
	伝え:inform／:tell
	上手く:well
	小さな:minor
	書く:writing
	様変わり:greatly vary
	馴染みのない:unfamiliar
	目的を以って:purposefully
	しようとして:going
	すれば十分:good enough
	~~目的の:sought-after
	~~事前~upfront
	~costがかかる:costly
	されたし:please
	し続ける:keep
	またがって:across
	要る:require
	大別-:distinguish between
	結果:fruits
	説明されている:be found in 〜 explainer documents
	勧められ:advisable
	これまで:so far
	登場当時のそれら:When they are,
	可能性もある:possible
	現時点:currently
	従い:following
	とされる:said to be
	下位節:subsection
	併用:for use with
	名前を継ぐ:named after
	改善:make 〜 improvements
	特に:most notably
	~~相応しく:Right Choice
	気にする:care
	対象になる:target
	活かし:thanks to 〜
	とは言え:that said
	2 つ:twofold
	促す:promoteする
	称され:referred
	区別:distinction
	区別-:make 〜 distinction
	に特有:-specific
	選好され:favored
	~~節約:freeing up
	得る:potentially
	ごく限られる:have little to no
	よくあった:it is often in ways that
	~test用:testing
	それに関係しない:non-〜-related
	~~課す:pose〜 to test
	もたらし得る:potential
	断たれ:severe
	広範な:wide range of
	居座る:sit
	以前に増して:increasingly
	視点:perspective
	視点:point of view
	指す:refer
	を見られたし:please refer to
	~~最新な:up-to-date
	含まれない:is not among
	出自にする:originated from
	-:force
	-:object
	関心がある:interested
	基準:reference
	示す:illustrate
	非~SI:Non-SI
	汎用~sensor~API:Generic Sensor API
	発見-用の:discovery
	集め:gather
	伝え:inform
	勧告候補:CR
	進める:advance
	組で，:Together
	互いに補い合う:each other complement
	十分:enough
	とは限らない:may not
	帰結として:consequently
	用立てる:utilization

	●謝辞
献身的:dedicated:~
意見:input:~
貴重:invaluable:~
事実調査:research:~
助力:help:~
多方面:extensive:~
推進-:drive:~
素描-:sketch:~
運営上の:administrativeな:~

	~~直に:in person
	たゆまず:tireless
	作り上げ:making
	詳しく:its subtleties
	割いて:taking
	方々:people
	多大に:greatly
	何よりもまず:First and foremost
	全体を通して:throughout
	感謝-:thanks to
	を巡る:around
	周り:around
	IRC
	Bikeshed
	GitHub
	^en:HTML5Apps project
	^en:Johnny Five

	●保安
revokeする::取り消す
revokeした::取り消した
revocation::取り消し
帯域外:out of band:~
歩き:walking:~
機械学習:machine learning:~
相関-:correlate::~
相関:correlation::~
脅威:threat:~
質問票:questionnaire:~
訓練-:train:~
策:strategy:~
各個人:individual:~
許容list:allowlist::許容 list:許容リスト
偏り:bias:~
keystroke::::キーストローク
password::::パスワード
PIN:
支払い:payment:::~
購入:purchase:~
盗聴:eavesdropping:~
発話:speech:~
統計的:statistical:~
軌跡:trajectory:~
場当的:ad-hoc:場当たり的
不一致:discrepancies:~
盗読み:skimming:盗み読み
変動:variation:~
回復-:recover:~
高価値:high-value:~
現実:real-world:~

	思いがけない:unanticipated
	手短に挙げていく:briefly enumerate
	攻撃が成功する~risk:risk of successful attack
	〜の~~要因になる:might be created
	長期間にわたる:over longer period of time
	~~経過するまで:period of time
	働き続け:continues to work

	●未分類
online::::オンライン
offline::::オフライン
	~onlineにも~offlineにも:on and offline
URI:
	~Web~IDL:WebIDL
backend:
消費:consumption:~
解放-:release:~
超過-:exceed:~
量:amount:~
面:surface:~
過去:past:~
構成-:compose:~
	構成され:composed of
半径:radius:~
同時的:simultaneous:~
一時的:temporal:~
	一時的に:temporarily
間隔:interval:~
増幅-:amplify:~
密度:density:~
ナシ:none:なし
発され:emitされ:~
稼働-:run::~
稼働時の:runtime::~
	査定-:perform 〜 assessment of
	~filterで濾す:filter out
zoom::::ズーム
邪魔-:hinder:~
lifecycle:
遊休中:idle::~
作動化d:activated::作動化::アクティブ化
非作動化-:deactivate::~::非アクティブ化
開いて:openして:~
被focus:focused::被 focus:被フォーカス
game::::ゲーム
	~game内:in-game
地図:map:~
	仮想現実:virtual reality
	拡張現実:augmented reality
個人周辺:personal area:~
	用意ができ:ready
束ねら:tieさ:~

	構築-可能:constructible
	構築し直す:reconstruct
	渡-:pass
	環境設定-可能:configurable
	高める／高まり／増やす／増え／増す／増える／速める:increase
	^I:Gyroscope
	^:POST
	^e:iframe
	~NULL:unset
	~EQ ~NULL:is not set
	~NEQ ~NULL:is set
	~code片:snippet
	~UI:user-interface
	遅める:slow
	抑える:lowering
	減らす:decrease
	変形する:remap
	備えて:carry
	備える:equipped with
	成すことになる:creating
	~instance化:instantiate／:instantiating
	切り詰め:cap
	所在を得る:locate
	所在:location point
	数:number
	変形する:remap
	まるごと:altogether
	先ず:firstly
	入る:fall in
	回数:number of
	属する:belong
	異なる:different
	それまで:total
	間にまたがる:cross-
	限られた数の:limited number of
	回を重ねて:over time
	-:against
	-:amongst
	何も:anything
	より低:lower-
	低-:low-
	低-:low
	高-:high-:~
	高い:higher
	各~測定-回:t<sub>n</sub>
	新たに:newly
	更なる:further
	第一に:primarily
	第二に:secondly
	および:as well as
	:sub-step
	どの時点であれ:any time
	複数個:several
	前回に:previously
	その結果，:the outcome value
	入る／ある:lie
	その結果:in turn
	大きい方の:largest
	小さい方の:smallest
	そのまま:unchanged
	最終的に:ultimately
	とりわけ，:among other things
	型ごとの:per-type
	変わる:vary

	●変数
	%x
	%y
	%z
	%許可~状態:permissionState
	%接続されたか:connected
	%作動化された~sensor群:activated_sensors
	%特能~名:feature_name
	-:feature_names
	%許可~名:permission_name
	%~sensor型:sensor type
	%~sensor型:sensor_type
	%~sensor型:type
	%~sensor~instance:sensor_instance
	コレ:sensor_instance
	-:sensor_permissions
	%読取り:reading
	%報告ng~frequency:reportingFrequency
	%報告ng間隔:reportingInterval
	%時刻印~差分:timestampDelta
	%時刻印:timestamp
	%時刻印:-
	%最後に報告された時刻印:lastReportedTimestamp
	-:deferUpdateTime
	%~platform~sensor:platformSensor
	%最小~frequency:minimumFrequency
	%最大~frequency:maximumFrequency
	%大域~obj:global
	%安全でない時刻印:unsafeTimestamp
	%~sensor:sensor
	( %最小, %最大 ):bounds
	%~key:key
	%値:value
	%~frequency
	-:topLevelTraversable
	%~virtual~sensor:virtualSensor
	%~virtual~sensor型:virtualSensorType
	%~parameter群:parameters
	-:topLevelVirtualSensorMapping
	%最大~標本化~frequency:maxSamplingFrequency
	%最小~標本化~frequency:minSamplingFrequency
	%~virtual~sensor:virtualSensor
	%構文解析した読取り:parsedReading
	%四元数~配列:quaternionArray
	%値の名前:valueName

●●ref_key_map
APIDESIGNPRINCIPLES:DESIGNPRINCIPLES
POWERFULFEATURES:SECURECONTEXTS

●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[HR-TIME]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PERMISSIONS]
    Marcos Caceres; Mike Taylor. ＜Permissions＞. URL: https://w3c.github.io/permissions/
[PERMISSIONS-POLICY]
    Ian Clelland. ＜Permissions Policy＞. URL: https://w3c.github.io/webappsec-permissions-policy/
[PERMISSIONS-REQUEST]
    ＜Requesting Permissions＞. cg-draft. URL: https://wicg.github.io/permissions-request/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[WEBDRIVER2]
    Simon Stewart; David Burns. ＜WebDriver＞. URL: https://w3c.github.io/webdriver/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[ACCELPRINT]
    Dey, Sanorita, et al.. ＜AccelPrint: Imperfections of Accelerometers Make Smartphones Trackable＞. 2014. Informational. URL: http://synrg.csl.illinois.edu/papers/AccelPrint_NDSS14.pdf
[API-DESIGN-PRINCIPLES]
    Sangwhan Moon. ＜Web Platform Design Principles＞. URL: https://w3ctag.github.io/design-principles/
[COORDINATES-TRANSFORMATION]
    George W. Collins, II. ＜The Foundations of Celestial Mechanics＞. 2004. Informational. URL: http://ads.harvard.edu/books/1989fcm..book/Chapter2.pdf
[EXTENNNNSIBLE]
    ＜The Extensible Web Manifesto＞. 10 June 2013. URL: https://extensiblewebmanifesto.org/
[GENERIC-SENSOR-USECASES]
    Rick Waldron, Mikhail Pozdnyakov, Alexander Shalamov. ＜Sensor Use Cases＞. 2017. Note. URL: https://w3c.github.io/sensors/usecases
[GEOLOCATION-API]
    Andrei Popescu. ＜Geolocation API Specification 2nd Edition＞. URL: https://w3c.github.io/geolocation-api/
[GYROSPEECHRECOGNITION]
    Michalevsky, Y., Boneh, D. and Nakibly, G.. ＜Gyrophone: Recognizing Speech from Gyroscope Signals＞. 2014. Informational. URL: https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-michalevsky.pdf
[MOBILESENSORS]
    Manish J. Gajjar. ＜Mobile Sensors and Context-Aware Computing＞. 2017. Informational.
[MOTION-SENSORS]
    Kenneth Christiansen; Alexander Shalamov. ＜Motion Sensors Explainer＞. URL: https://w3c.github.io/motion-sensors/
[ORIENTATION-EVENT]
    Reilly Grant; Raphael Kubo da Costa. ＜DeviceOrientation Event Specification＞. URL: https://w3c.github.io/deviceorientation/
[POWERFUL-FEATURES]
    Mike West. ＜Secure Contexts＞. URL: https://w3c.github.io/webappsec-secure-contexts/
[QUDT]
    Ralph Hodgson; et al. ＜QUDT - Quantities, Units, Dimensions and Data Types Ontologies＞. 18 March 2014. URL: http://www.qudt.org/
[RFC6454]
    A. Barth. ＜The Web Origin Concept＞. December 2011. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6454
[SECURITY-PRIVACY-QUESTIONNAIRE]
    Theresa O'Connor; Peter Snyder. ＜Self-Review Questionnaire: Security and Privacy＞. URL: https://w3ctag.github.io/security-questionnaire/
[SI]
    ＜SI Brochure: The International System of Units (SI), 8th edition＞. 2014. URL: http://www.bipm.org/en/publications/si-brochure/
[STEALINGPINSVIASENSORS]
    Maryam Mehrnezhad, Ehsan Toreini, Siamak F. Shahandashti, Feng Hao. ＜Stealing PINs via mobile sensors: actual risk versus user perception＞. 2017. Informational. URL: https://rd.springer.com/article/10.1007/s10207-017-0369-x?wt_mc=Internal.Event.1.SEM.ArticleAuthorOnlineFirst


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより
編集者草案として公開された
<a href="~SPEC_URL">Generic Sensor API</a>
を日本語に翻訳したものです。
~PUB

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/generic-sensor/
公表履歴
	https://www.w3.org/standards/history/generic-sensor/

フィードバック
	<a href="mailto:public-device-apis@w3.org?subject=%5Bgeneric-sensor%5D%20YOUR%20TOPIC%20HERE">public-device-apis@w3.org</a> with subject line “<kbd>[generic-sensor] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-device-apis/" rel="discussion">archives</a>) <a href="https://github.com/w3c/sensors/issues/">GitHub</a>
実装報告
	https://www.w3.org/wiki/DAS/Implementations

編集
	Rick Waldron (Invited Expert, formerly on behalf of Bocoup and JS Foundation)
前任編集者
	<a href="https://intel.com/">Mikhail Pozdnyakov</a> (Intel Corporation)
	<a href="https://intel.com/">Alexander Shalamov</a> (Intel Corporation)
	<a href="https://www.codespeaks.com/">Tobie Langel</a> (Codespeaks, formerly on behalf of Intel Corporation) <a href="mailto:tobie@codespeaks.com">tobie@codespeaks.com</a>

テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/generic-sensor
commit 履歴
	https://github.com/w3c/sensors/commits/main/index.bs
以前の commit 履歴
	https://github.com/w3c/sensors/commits/gh-pages/index.bs
公表者
	<a href="https://www.w3.org/groups/wg/das">Devices and Sensors WG</a>

</script>

</head>
<body>
<!--%resource pool -->
<template id="_persisted_parts">

<svg
	id="_sensor_parts1"
	xmlns="http://www.w3.org/2000/svg"
	width="120"
	height="100"
	viewBox="0 0 1200 1000"
	preserveAspectRatio="xMidYMid"
>

	<defs>
<rect id="pin0" x="0" y="0" width="80" height="80" fill="white" stroke="gray" 
stroke-width="5"/>
	</defs>

	<g transform="translate(100,50)" >
<rect x="0" y="0" width="1000" height="900" fill="black" stroke="white" stroke-width="10" />
<use href="#pin0" transform="translate(-80,70)" />
<use href="#pin0" transform="translate(-80,210)" />
<use href="#pin0" transform="translate(-80,600)" />
<use href="#pin0" transform="translate(-80,740)" />

<use href="#pin0" transform="translate(1000,70)" />
<use href="#pin0" transform="translate(1000,210)" />
<use href="#pin0" transform="translate(1000,600)" />
<use href="#pin0" transform="translate(1000,740)" />

<circle cx="500" cy="450" r="30" fill="white" stroke="none" />
<circle cx="500" cy="450" r="100" fill="none" stroke="white" stroke-width="10"/>
<path fill="none" stroke="white" stroke-width="10" d="M850,550 v200 h-200" />
		<g style="fill: white; stroke: none; font-size: 160px; font-family: sans-serif; text-anchor: middle; dominant-baseline: central;">
<text transform="translate(850, 450)">X</text>
<text transform="translate(550, 750)">Y</text>
<text transform="translate(300, 450)">Z</text>
		</g>
	</g>
</svg>

</template>

<header>
	<hgroup>
<h1>汎用センサー API — Generic Sensor API</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、~sensor~dataを一貫した仕方で
`Open Web Platform^en に公開するための~frameworkを定義する
— 具象-~sensorの仕様を［
各種~sensor型に適応するために拡張できる抽象- `Sensor^I ~interface
］とともに書くための青写真を定義することにより。
◎
This specification defines a framework for exposing sensor data to the Open Web Platform in a consistent way. It does so by defining a blueprint for writing specifications of concrete sensors along with an abstract Sensor interface that can be extended to accommodate different sensor types.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

<p>
更なる実装~経験が`許可~要請~algo$用に集められており、
その経験から伝えられた仕様の明確化が
`課題 #397＠https://github.com/w3c/sensors/issues/397$
にて論じられている。
~WGは、
`PERMISSIONS-REQUEST$r が揺籃期を超えるまでは，
この仕様を勧告候補より先へ進むものと期待していない。
◎
Further implementation experience is being gathered for the permission request algorithm and specification clarifications informed by this experience are being discussed in GitHub issue #397. The group does not expect to advance this specification beyond CR until [PERMISSIONS-REQUEST] moves beyond incubation.
</p>

	</section>
<main id="MAIN0">

	<section id="_conventions">
<h2 class="trans-note">【この訳に特有な表記規約】</h2>

◎表記記号

<p>
原文における用語
“`allowed to use^en”
は、
`PERMISSIONS-POLICY$r による
“`要請には特能の利用は許容されるべきか？$”
を指しているが、
（引数が合っておらず）~~意味が通らなくなっているので，この訳では
`HTML$r による
“特能の`利用は許容されて$いる／いない”
に置換している（訳者による推定 — 本質的には同じことを行う）。
</p>

<p>
用語 “`可視性~状態$doc” は、
原文では `PAGE-VISIBILITY$r を参照しているが，その仕様は `HTML$r に統合された
— この訳では、~HTMLの用語を参照するよう改める。
</p>

	</section>
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~sensor~dataは、［
地理所在（ `geolocation^en ）／
~~歩数計（ `counting steps^en ）／
~~頭の~~動きの~~追跡（ `head-tracking^en ）
］などの新たな利用事例を可能化するため，以前に増して~app開発に利用されている。
これはとりわけ、
新たな~sensorが定期的に追加される携帯~deviceに該当する。
◎
Increasingly, sensor data is used in application development to enable new use cases such as geolocation, counting steps or head-tracking. This is especially true on mobile devices where new sensors are added regularly.
</p>

<p>
これまで，~sensor~dataを~Webへ公開することは、
歩みが遅く場当的でもあった。
少数の~sensorは、
すでに~Webに公開されている。
登場当時のそれらは、
アリな利用事例が限られていたこともよくあった
（例えば，`高level$過ぎる抽象-化を公開した結果，十分~上手く遂行しないなど）。
また，~APIは各種~sensorごとに様変わりするので、
~Web~app開発者の認知的負担が増え，開発を遅める。
◎
Exposing sensor data to the Web has so far been both slow-paced and ad-hoc. Few sensors are already exposed to the Web. When they are, it is often in ways that limit their possible use cases (for example by exposing abstractions that are too high-level and which don’t perform well enough). APIs also vary greatly from one sensor to the next which increases the cognitive burden of Web application developers and slows development.
</p>

<p>
`汎用~sensor~API^cite（ `Generic Sensor API^en ）の目標は
⇒＃
各種~sensor~APIにまたがる一貫性を促す／
高処理能な`低level$~APIを活かした高度な利用事例を可能化する／
仕様と実装の過程を単純~化して，新たな~sensorを~Webに公開できる歩みを速める
◎
The goal of the Generic Sensor API is to promote consistency across sensor APIs, enable advanced use cases thanks to performant low-level APIs, and increase the pace at which new sensors can be exposed to the Web by simplifying the specification and implementation processes.
</p>

<p>
［
汎用~sensor~API,
適用-可能な利用事例,
~code例
］に基づく，具象-~sensorの包括的な~listは、
`GENERIC-SENSOR-USECASES$r, `MOTION-SENSORS$r
に説明されている。
◎
A comprehensive list of concrete sensors that are based on Generic Sensor API, applicable use cases, and code examples can be found in [GENERIC-SENSOR-USECASES] and [MOTION-SENSORS] explainer documents.
</p>

	</section>
	<section id="scope">
<h2 title="Scope">2. 視野</h2>

◎非規範的

<p>
この仕様の視野は、
現時点では，［
`~device~sensor$から~dataを公開するのを可能化する，~primitive
］を指定することに制限される。
◎
The scope of this specification is currently limited to specifying primitives which enable exposing data from device sensors.
</p>

<p>
~remote~sensorや個人周辺~networkに見出される~sensor（例：~bluetooth）を公開することは、
視野から外れる。
これらの分野における作業が成熟するに伴い、
共通かつ，より低levelな~primitiveが見出される可能性もある
— その事例では、
この仕様もそれに則って更新されることになる。
しかしながら，これによる実装に対する効果は、
ごく限られるはずである。
◎
Exposing remote sensors or sensors found on personal area networks (e.g. Bluetooth) is out of scope. As work in these areas mature, it is possible that common, lower-level primitives be found, in which case this specification will be updated accordingly. This should have little to no effects on implementations, however.
</p>

<p>
この仕様はまた、
現時点では~sensor発見-用の~APIを公開していない。
このことは、
現時点で~UAに可用な限られた数の~sensorが
，そのような~APIを~warrant【！＊】していないからである。
今の所，
`§ ~hardware特能の特能~検出に対する注記＠#feature-detection$
に述べられるものなど，特能~検出を利用すれば十分である。
この仕様の後続な~versionは、
そのような~APIを指定するかもしれない
— 現在の~APIは、
このことを念頭に設計されている。
◎
This specification also does not currently expose a sensor discovery API. This is because the limited number of sensors currently available to user agents does not warrant such an API. Using feature detection, such as described in § 3 A note on Feature Detection of Hardware Features, is good enough for now. A subsequent version of this specification might specify such an API, and the current API has been designed with this in mind.
</p>

	</section>
	<section id="feature-detection">
<h2 title="A note on Feature Detection of Hardware Features">3. ~hardware特能の特能~検出に対する注記</h2>

◎非規範的

<p>
特能~検出は、
~Web開発において確立された最善な実施である。
この論題についての資料は、
~onlineにも~offlineにも，豊富にある
— この節の目的は、
それについて更に論じることではなく，
それを~hardwareに依存する特能を検出する文脈~内に置くことにある。
◎
Feature detection is an established Web development best practice. Resources on the topic are plentiful on and offline and the purpose of this section is not to discuss it further, but rather to put it in the context of detecting hardware-dependent features.
</p>

<p>
次の特能~検出~例を考える：
◎
Consider the below feature detection examples:
</p>

<div class="example">
<p>
次の単純な例は、［
特定0の~sensor型~用に，~UAが~interfaceを公開するかどうか
］を検査する方法を示す。
堅牢な方式で~errorを取扱う`後述の例＠#robust-example$も見られたし。
◎
This simple example illustrates how to check whether the User Agent exposes an interface for a particular sensor type. To handle errors in a robust manner, please refer to this example. 
</p>

<pre class="lang-js">
if (typeof Gyroscope === "function") {
    // run in circles...
}

if ("ProximitySensor" in window) {
    // watch out!
}

if (window.AmbientLightSensor) {
    // go dark...
}

// etc.
</pre>
</div>

<p>
これらすべては、
~APIの有無, アリな特性について何かを伝えるが，
次については何も伝えない：
その~APIは実際に本物の~hardware~sensorに接続されているのか？
そうであれば，その~sensorは働くのか？
あるいは、利用者が~accessを許容しようとしているかさえも。
後者については、
`許可~API^cite（ `Permissions API^en ） `PERMISSIONS$r を利用すれば検査できることに注意。
◎
All of these tell you something about the presence and possible characteristics of an API. They do not tell you anything, however, about whether that API is actually connected to a real hardware sensor, whether that sensor works, if its still connected, or even whether the user is going to allow you to access it. Note you can check the latter using the Permissions API [PERMISSIONS].
</p>

<p>
下層の状態sについての情報は、
~~事前に可用になるのが~~理想である。
これに関する問題は 2 つある。
第一に，この情報を~hardwareから取得するのは、
処理能, ~battery両面で時間~costがかかり，~critical-path内に居座ることになる。
第二に，下層の~hardwareの状態sは、
時間~越しに発展し得る：
利用者が許可を~revokeしたり，
~sensorへの接続が断たれたり，
~OSが~sensor用法を一定の~battery残量以上に制限するよう裁定することもある，
等々。
◎
In an ideal world, information about the underlying status would be available upfront. The problem with this is twofold. First, getting this information out of the hardware is costly, in both performance and battery time, and would sit in the critical path. Secondly, the status of the underlying hardware can evolve over time. The user can revoke permission, the connection to the sensor be severed, the operating system may decide to limit sensor usage below a certain battery threshold, etc.
</p>

<p>
したがって，効果的な策は、［
~~目的の~sensor用の~APIが実際に存在するかどうか検査する特能~検出
］と［
次に挙げるような安全弁付き~programming
］を組合せることである：
◎
Therefore, an effective strategy is to combine feature detection, which checks whether an API for the sought-after sensor actually exists, and defensive programming which includes:
</p>

<ol>
	<li>
`Sensor$I ~objを~instance化するときに投出される~errorを検査して、
◎
checking for error thrown when instantiating a Sensor object,
</li>
	<li>
発される~errorを~listenして、
◎
listening to errors emitted by it,
</li>
	<li>
それらすべてを上品に取扱う
— 利用者~体験が~sensorにアリな用法により強化され，その不在により退行しないよう。
◎
handling all of the above graciously so that the user’s experience is enhanced by the possible usage of a sensor, not degraded by its absence.
</li>
</ol>

<div class="example" id="robust-example">
<p>
`Accelerometer^I ~sensorを堅牢な方式で作成する方法を，次の~code片に示す。
~Web~appは、
~error取扱い用に異なる~optionも選べる
— 例えば：
通知を示す／
異なる~sensor型を選ぶ／
他の~APIに~fallbackする
◎
The following snippet illustrates how an Accelerometer sensor can be created in a robust manner. Web application may choose different options for error handling, for example, show notification, choose different sensor type or fallback to other API.
</p>

<pre class="lang-js">
let %accelerometer = null;
try {
    %accelerometer = new Accelerometer({ frequency: 10 });
    %accelerometer.addEventListener('error', %event =&gt; {
        // <span class="comment">稼働時の~errorを取扱う：</span>
        if (%event.error.name === 'NotAllowedError') {
            console.log('~sensorへの~access許可は否認されました。');
        } else if (%event.error.name === 'NotReadableError' ) {
            console.log('~sensorに接続できません。');
        }
    });
    %accelerometer.addEventListener('reading', () =&gt; reloadOnShake(%accelerometer));
    %accelerometer.start();
} catch (%error) {
    // <span class="comment">構築~errorを取扱う：</span>
    if (%error.name === 'SecurityError') {
        console.log('~sensor構築は許可~施策により阻止されました。');
    } else if (%error.name === 'ReferenceError') {
        console.log('~UAは、この~sensorを~supportしていません。');
    } else {
        throw %error;
    }
}
</pre>
<!-- 
let accelerometer = null;
try {
    accelerometer = new Accelerometer({ frequency: 10 });
    accelerometer.addEventListener('error', event =&gt; {
		// Handle runtime errors.
        if (event.error.name === 'NotAllowedError') {
            console.log('Permission to access sensor was denied.');
        } else if (event.error.name === 'NotReadableError' ) {
            console.log('Cannot connect to the sensor.');
        }
    });
    accelerometer.addEventListener('reading', () =&gt; reloadOnShake(accelerometer));
    accelerometer.start();
} catch (error) {
    // Handle construction errors.
    if (error.name === 'SecurityError') {
        console.log('Sensor construction was blocked by the Permissions Policy.');
    } else if (error.name === 'ReferenceError') {
        console.log('Sensor is not supported by the User Agent.');
    } else {
        throw error;
    }
}
-->
</div>

	</section>
	<section id="security-and-privacy">
<h2 title="Security and privacy considerations">4. ~securityと~privacyの考慮点</h2>

<p class="note">注記：
既知な`脅威を利用者に通信する方法＠#main-privacy-security-threats$についての判定は、
実装者に委ねられる。
しかしながら、
`軽減策＠#mitigation-strategies$の実装は義務的である。
◎
The judgement on how to communicate to the user the known threats is up to the implementer. The implementation of the mitigations is mandatory, however.
</p>

<p>
`~sensor読取り$は，敏感な~dataであり、
悪意的な~Web~pageからの様々な攻撃の~subjectにもなり得る。
軽減~策を論じる前に，［
`~device~sensor$の~privacy／~security脅威を成す主な型
］について手短に挙げていく。
`MOBILESENSORS$r では、
主な脅威を次に挙げるものに分類しており，この仕様にもよくあてはまる
⇒＃
`所在~追跡＠#location-tracking$,
`盗聴＠#eavesdropping$,
`~keystrokeの監視＠#keystroke-monitoring$,
`~device指紋収集＠#device-fingerprinting$,
`利用者~識別-法＠#user-identifying$
◎
Sensor readings are sensitive data and could become a subject of various attacks from malicious Web pages. Before discussing the mitigation strategies we briefly enumerate the main types of the sensor's privacy and security threats. The [MOBILESENSORS] categorizes main threats into location tracking, eavesdropping, keystroke monitoring, device fingerprinting, and user identification. This categorization is a good fit for this specification.
</p>

<p>
攻撃が成功する~riskは、
`~device~sensor$が他の機能性との組合nで互いに利用されたり，回を重ねて利用されるほど高まり得る
— 特定的には［
~dataの相関, 指紋収集を通した利用者~識別
］の~riskを伴う。
これらの~JS~APIを利用している~web~app開発者は、
この情報が他の情報と どう相関され，~privacy~riskの~~要因になるか考慮するベキである。
より長期間にわたる，そのような~dataの収集がもたらし得る~riskも、
考慮するベキである。
◎
The risk of successful attack can increase when sensors are used with each other, in combination with other functionality, or when used over time, specifically with the risk of correlation of data and user identification through fingerprinting. Web application developers using these JavaScript APIs should consider how this information might be correlated with other information and the privacy risks that might be created. The potential risks of collection of such data over a longer period of time should also be considered.
</p>

<p>
`~sensor読取り$における変動, および~event発火~rateは、
利用者を識別する指紋収集の可能性も提供する。
~UAは、
~web~app開発者に可用になる~event~rateを制限することで，~riskを抑制してもヨイ。
◎
Variations in sensor readings as well as event firing rates offer the possibility of fingerprinting to identify users. User agents may reduce the risk by limiting event rates available to web application developers.
</p>

<p>
~sensorの読出しの正確度を最小限にすることは、
一般に，指紋収集の~riskを減らす。
~UAは、
不必要に冗漫な~sensor~dataの読出しを供するベキでない。
各`~sensor型$は、
個別に査定されるベキである。
◎
Minimizing the accuracy of a sensor’s readout generally decreases the risk of fingerprinting. User agents should not provide unnecessarily verbose readouts of sensors data. Each sensor type should be assessed individually.
</p>

<p>
この~APIを利用して，
同じ~device上の異なる~window文脈~内で同じ~JS~codeを同時的に利用できる場合、
その~codeは，［
それらの文脈にまたがって利用者【についての情報】を相関する
］こともアリになり得る結果，
思いがけない追跡の仕組みを創出することになる。
◎
If the same JavaScript code using the API can be used simultaneously in different window contexts on the same device it may be possible for that code to correlate the user across those two contexts, creating unanticipated tracking mechanisms.
</p>

<p>
~UAは、［
`~device~sensor$が利用されたことの指示を利用者に供する ／
~sensorを不能化することを利用者に許容する
］ことを考慮するベキであり、［
過去, および現在の~sensor利用~patternを検証yすることを利用者に許容する
］ことを考慮してもヨイ。
【！要件~levelとして，考慮するベキ／考慮してもヨイとは、何を意味する？】
◎
User agents should consider providing the user an indication of when the sensor is used and allowing the user to disable it. Additionally, user agents may consider allowing the user to verify past and current sensor use patterns.
</p>

<p>
`~device~sensor$を利用する~web~app開発者は、
自身の~appによる~privacyへの影響iを
— 当の~appのすべての側面を考慮に入れて —
査定するベキである。
◎
Web application developers that use sensors should perform a privacy impact assessment of their application taking all aspects of their application into consideration.
</p>

<p>
ある~device上で働いている~sensorの集合を全部的に検出する能は、
識別子を形成し得るため，指紋収集~用に利用することもできる。
◎
Ability to detect a full working set of sensors on a device can form an identifier and could be used for fingerprinting.
</p>

<p>
選定された~sensorの組合nは、
~device間の帯域外~通信~channelを形成するためにも利用され得る。
◎
A combination of selected sensors can potentially be used to form an out of band communication channel between devices.
</p>

<p>
~sensorは、
~device間にまたがる~link法や利用者の追跡にも利用され得る。
◎
Sensors can potentially be used in cross-device linking and tracking of a user.
</p>

		<section id="main-privacy-security-threats">
<h3 title="Types of privacy and security threats">4.1. ~privacy／~security脅威の型</h3>

◎非規範的

			<section id="location-tracking">
<h4 title="Location Tracking">4.1.1. 所在~追跡</h4>

<p>
この型の脅威の下では、
攻撃は，~GPSその他の所在~sensorを利用することなく，`~sensor読取り$を利用して~deviceの所在を得する。
例えば，加速度計~dataは、
~smartphoneの所在を推定するためにも利用できる
— 統計的~modelを利用して軌跡を見積もってから、
地図~照合~algoを利用して，所在を予測できる（半径 200 ~meterの中で）
`MOBILESENSORS$r
。
◎
Under this type of threat, the attacks use sensor readings to locate the device without using GPS or any other location sensors. For example, accelerometer data can be used to infer the location of smartphones by using statistical models to obtain estimated trajectory, then map matching algorithms can be used to obtain predicted location points (within a 200-m radius)[MOBILESENSORS].
</p>

			</section>
			<section id="eavesdropping">
<h4 title="Eavesdropping">4.1.2. 盗聴</h4>

<p>
~gyroscope`~sensor読取り$から発話を回復することは、
盗聴~攻撃の例である。
`GYROSPEECHRECOGNITION$r を見よ。
◎
Recovering speech from gyroscope readings is an example of eavesdropping attack. See [GYROSPEECHRECOGNITION].
</p>

			</section>
			<section id="keystroke-monitoring">
<h4 title="Keystroke Monitoring">4.1.3. ~keystrokeの監視</h4>

<p>
多くの利用者~入力は、
`~sensor読取り$から推定され得る。
これには、
~motion~sensorを利用する，次に対する広範な攻撃を含まれる：
利用者の［
~PIN／~password／~lock~pattern
］（および，~click, ~scroll, ~zoomなどの~touch動作さえも）。
これらの攻撃は、
通常は，そのような利用者についての情報を発見するため，機械学習~algoを訓練する。
`STEALINGPINSVIASENSORS$r
を見よ。
◎
Many user inputs can be inferred from sensor readings, this includes a wide range of attacks on user PINs, passwords, and lock patterns (and even touch actions such as click, scroll, and zoom) using motion sensors. These attacks normally train a machine learning algorithm to discover such information about the users. See [STEALINGPINSVIASENSORS].
</p>

			</section>
			<section id="device-fingerprinting">
<h4 title="Device Fingerprinting">4.1.4. ~device指紋収集</h4>

<p>
~sensorは、
それらを利用して~deviceを一意に識別できる情報を供し得る。
どの~modelの具象-~sensorにも、
その~modelの中で一意になるような，小さな製造時のムラがある。
これらの製造時のムラは、
~deviceを指紋収集するために利用し得る。
`ACCELPRINT$r
`MOBILESENSORS$r
◎
Sensors can provide information that can uniquely identify the device using those sensors. Every concrete sensor model has minor manufacturing imperfections and differences that will be unique for this model. These manufacturing variations and imperfections can be used to fingerprint the device [ACCELPRINT] [MOBILESENSORS].
</p>

			</section>
			<section id="user-identifying">
<h4 title="User Identifying">4.1.5. 利用者の識別-法</h4>

<p>
`~sensor読取り$は、
利用者を識別するためにも利用し得る
— 例えば，~smartphoneや装身-可能な~deviceの~motion~sensorの~dataから、
各個人の歩き~patternを推定することを介して。
◎
Sensor readings can be used to identify the user, for example via inferring individual walking patterns from smartphone or wearable device motion sensors' data.
</p>

			</section>
		</section>
		<section id="mitigation-strategies">
<h3 title="Mitigation Strategies">4.2. 軽減~策</h3>

◎非規範的

<p>
この節では、
この仕様の規範的な各~節にて指定される軽減~策のうち一部について，
高levelな呈示【！＊】を与える。
◎
This section gives a high-level presentation of some of the mitigation strategies specified in the normative sections of this specification.
</p>

			<section id="secure-context">
<h4 title="Secure Context">4.2.1. ~secureな文脈</h4>

<p>
`~sensor読取り$は、
`Secure Contexts^cite `POWERFUL-FEATURES$r
仕様により明示的に，［
~network攻撃者にとって高価値な~targetである
］ものとされている
【`~~参照＠~SECURE-CONTEXT#threat-risks$】
。
【！flagged ：`閲覧~文脈~sandbox化( ~secure )~flag＠~SECURE-CONTEXT#sandboxed-secure-browsing-context-flag$？】
したがって，この仕様, その`拡張~仕様$に定義される~interfaceは、
どれも`~secureな文脈$enVの中に限り可用になる。
◎
Sensor readings are explicitly flagged by the Secure Contexts specification [POWERFUL-FEATURES] as a high-value target for network attackers. Thus all interfaces defined by this specification or extension specifications are only available within a secure context.
</p>

			</section>
			<section id="permissions-policy">
<h4 title="Permissions Policy">4.2.2. 許可~施策</h4>
<span id="browsing-context"></span>

<p>
`~sensor読取り$が利用者に馴染みのない文脈と共有されることによる~privacy~riskを避けるため、
`~sensor読取り$は，［
所与の`~sensor型$用の`施策により制御される特能$
］の`利用は許容されて$いる`文書$用に限り可用になる。
詳細は `PERMISSIONS-POLICY$r を見よ。
◎
To avoid the privacy risk of sharing sensor readings with contexts unfamiliar to the user, sensor readings are only available for the documents which are allowed to use the policy-controlled features for the given sensor type. See [PERMISSIONS-POLICY] for more details.
</p>

			</section>
			<section id="focused-area">
<h4 title="Focused Area">4.2.3. ~focusされた区画</h4>

<span id="losing-focus"></span>
<p>
`~sensor読取り$は、
次を満たす`作動中な文書$bcに限り可用になる
⇒
( その`生成元$doc, `現在の被focus区画$tlTの文書【`~DOM~anchor$の`~node文書$】の`生成元$doc )
は`同じ生成元~domain$である
◎
Sensor readings are only available for active documents whose origin is same origin-domain with the currently focused area document.
</p>

<p>
これは、［
`~focusを得た$要素を包含している`閲覧~文脈$に対する盗読み攻撃
］の~riskを軽減するために行われる
— 例えば、
利用者が，ある `iframe^e の中で［
第三者-主体による支払い~serviceを利用して，~game内での購入を遂げる
］とき。
◎
This is done in order to mitigate the risk of a skimming attack against the browsing context containing an element which has gained focus, for example when the user carries out an in-game purchase using a third party payment service from within an iframe.
</p>

			</section>
			<section id="visibility-state">
<h4 title="Visibility State">4.2.4. 可視性~状態</h4>

<p>
`~sensor読取り$は、
次を満たす`作動中な文書$bcに限り可用になる
⇒
`可視性~状態$doc ~EQ `visible^l
◎
Sensor readings are only available for the active documents whose visibility state is "visible".
</p>

			</section>
			<section id="permissions">
<h4 title="Permissions API">4.2.5. `許可~API^cite</h4>

<span id="permissioning"></span>

<p>
`~sensor読取り$への~accessは、
`許可~API^cite `PERMISSIONS$r により制御される。
◎
Access to sensor readings are controlled by the Permissions API [PERMISSIONS].
</p>

			</section>
		</section>
		<section id="mitigation-strategies-case-by-case">
<h3 title="Mitigation strategies applied on a case by case basis">4.3. 事例~別に適用される軽減~策</h3>

<p>
各`~sensor型$は、
個別に査定される必要がある
— ［
それが可能化する各~利用事例,
それの特定0の脅威~profile
］を織り込んで。
下に与える軽減~策のうち一部は、
ある種の~sensor用には効果的になる一方で，
ある種の利用事例を邪魔する／まるごと防止するかもしれない。
◎
Each sensor type will need to be assessed individually, taking into account the use cases it enables and its particular threat profile. While some of the below mitigation strategies are effective for certain sensors, they might also hinder or altogether prevent certain use cases.
</p>

<p class="note">注記：
これらの軽減~策は、
定常的にも一時的にも適用できる
— 例えば、
利用者が特定の動作を遂げているとき／
脅威の~levelを増幅することが既知な他の~APIが利用-中にあるとき, 等々。
◎
Note: These mitigation strategies can be applied constantly or temporarily, for example when the user is carrying out specific actions, when other APIs which are known to amplify the level of the threat are in use, etc.
</p>

			<section id="limit-max-frequency">
<h4 title="Limit maximum sampling frequency">4.3.1. 最大~標本化~frequencyを制限する</h4>

<p>
［
~UA／`拡張~仕様$
］は、
ある種の脅威を軽減するためとして，
各`~sensor型$の`最大~標本化~frequency$を定義してもヨイ。
◎
User agents and extension specifications may mitigate certain threats by defining a sensor type's maximum sampling frequency.
</p>

<p>
どの上限を選ぶかは、
次に挙げるものに依存する
⇒＃
`~sensor型$,
~UAが保護しようと試行している脅威の種類,
予期される攻撃者の資源,
等々
◎
What upper limit to choose depends on the sensor type, the kind of threats the user agent is trying to protect against, the expected resources of the attacker, etc.
</p>

<p>
`最大~標本化~frequency$を制限することは、
低-待時間や高-密度な~dataに依拠する利用事例を防止する。
◎
Limiting the maximum sampling frequency prevents use cases which rely on low latency or high data density.
</p>

			</section>
			<section id="stop-sensor">
<h4 title="Stop the sensor altogether">4.3.2. ~sensorをまるごと停止する</h4>

<p>
これは明白に最終手段ではあるが、
一時的であるなら極めて効果的になり得る。
例えば、
利用者が異なる［
生成元（ `rfc6454$r ）／~app
］に属する資格証を手入力している間は，
~password盗読みの試みを防止するなど。
◎
This is obviously a last-resort solution, but it can be extremely effective if it’s temporal, for example to prevent password skimming attempts when the user is entering credentials on a different origin ([rfc6454]) or in a different application.
</p>

			</section>
			<section id="limit-number-of-delivered-readings">
<h4 title="Limit number of delivered readings">4.3.3. 送達される読取りの回数を制限する</h4>

<p>
`最大~標本化~frequencyを制限する＠#limit-max-frequency$代替として
— `標本化~frequency$に関わらず —
~Web~app開発者に送達される`~sensor読取り$の回数を制限する。
これは、
供される~dataの量を増やすことなく，
`標本化~frequency$を高めるため低-待時間が要件にある利用事例を許容する。
◎
An alternative to limiting the maximum sampling frequency is to limit the number of sensor readings delivered to Web application developer, regardless of the sampling frequency. This allows use cases which have low latency requirement to increase the sampling frequency without increasing the amount of data provided.
</p>

<p>
中間的な読取りを破棄することは、
ある種の利用事例
— ある種類の~filterに依拠するものなど —
を防止する。
◎
Discarding intermediary readings prevents certain use cases, such as those relying on certain kinds of filters.
</p>

			</section>
			<section id="reduce-accuracy">
<h4 title="Reduce accuracy">4.3.4. 正確度を抑制する</h4>

<p>
`~sensor読取り$や~sensor`読取り時刻印$の正確度を抑制することは、
ある種の脅威を軽減する一助になり得る。
したがって，~UAは、
~sensor~dataの不必要に冗漫な読出しを供するベキでない。
◎
Reducing the accuracy of sensor readings or sensor reading timestamps might also help mitigate certain threats, thus user agents should not provide unnecessarily verbose readouts of sensors data.
</p>

<p>
具象-~sensorの実装は、
次を定義してもヨイ：
◎
↓</p>
<ul>
	<li>
`~threshold検査~algo$
⇒
新たな読取りが`最新な読取り~map$から十分に相違しないとき、
それを破棄するためにある。
◎
Implementations of concrete sensors may define a threshold check algorithm so that new readings that do not differ enough from the latest readings are discarded.
</li>
	<li>
`読取り量子化~algo$
⇒
`~device~sensor$から受信した`~sensor読取り$の正確度を抑制するためにある。
◎
Implementations of concrete sensors may define a reading quantization algorithm to reduce the accuracy of the sensor readings received from a device sensor.
</li>
</ul>

<p class="note">注記：
これら 2 つの軽減~措置は、
互いに補い合うことが多い。
`~threshold検査~algo$しか実行しない実装は、
精確~過ぎる読取りを公開するかもしれない。
一方で，読取りを丸めることしかしない実装は、
生な読取りが異なる値に丸められたとき，
より精確な読取り【があったこと】についての情報を攻撃者に供し得る。
◎
Note: These two mitigation measures often complement each other. An implementation that only executes the threshold check algorithm might expose readings that are too precise, while an implementation that only rounds readings up may provide attackers with information about more precise readings when raw readings are rounded to different values.
</p>

<p class="note">注記：
不正確度は［
`~sensor読取り$上で遂げられる演算 ／
`読取り時刻印$から計算される時間差
］においても更に増すので、
この軽減~策は，ある種の利用事例に影響し得る。
◎
Note: Inaccuracies will further increase for operations carried out on the sensor readings, or time deltas calculated from the timestamps. So, this mitigation strategy can affect certain use cases.
</p>

<p class="note">注記：
`~sensor読取り$に~randomな偏りを追加することにも類似な効果があるが、
実施には利用されるベキでない
— 追加された~noiseを~filterで濾すのは容易なので。
◎
Note: While adding random bias to sensor readings has similar effects, it shouldn’t be used in practice as it is easy to filter out the added noise.
</p>

			</section>
			<section id="inform-user">
<h4 title="Keep the user informed about API use">4.3.5. ~APIの利用について利用者に伝え続ける</h4>

<p>
~UAは、
~APIの［
現在の／過去の
］利用について利用者に伝え続けることにしてもヨイ。
◎
User agents may choose to keep the user informed about current and past use of the API.
</p>

<p class="note">注記：
これは、
実際の`~sensor読取り$の~logをとり続けることは含意しない
— それには自前の課題がある。
◎
Note: This does not imply keeping a log of the actual sensor readings which would have issues of its own.
</p>

			</section>
		</section>
	</section>
	<section id="concepts">
<h2 title="Concepts">5. 各種~概念</h2>

		<section id="concepts-sensors">
<h3 title="Sensors">5.1. ~sensor</h3>

<p>
用語
`~device~sensor@
（ `device sensor^en ）は、
~deviceの下層の物理的~sensor~instanceを指す。
◎
The term device sensor refers to a device’s underlying physical sensor instance.
</p>

<p>
`~device~sensor$は、
物理量を測定して，対応する
`~sensor読取り@
（ `sensor reading^en ）を供する
— それは、
環境についての情報の~sourceである。
◎
A device sensor measures a physical quantities and provides a corresponding sensor reading which is a source of information about the environment.
</p>

<p>
各`~sensor読取り$は、
`~device~sensor$が［
`読取り時刻印@
（ `reading timestamp^en ）と呼ばれる，各~測定-回の時刻
］に測定した物理量の値たちから構成される。
◎
Each sensor reading is composed of the values of the physical quantity measured by the device sensor at time tn which is called the reading timestamp.
</p>

<p>
`~device~sensor$が空間的な測定を遂行する場合（例：加速度, 角速度）、
`~device~sensor$の`~sensor読取り$用の基準~frameを表現する
`局所~座標系@
（ `local coordinate system^en ）内に解決するモノトスル。
そのような`~sensor読取り$を供する`~device~sensor$は、
`空間的~sensor@
（ `spatial sensor^en ）と称される。
◎
If the device sensor performs a spatial measurement (e.g. acceleration, angular velocity), it must be resolved in a local coordinate system that represents a reference frame for the device sensor's sensor readings. A device sensor that provides such sensor readings is referred to as spatial sensor.
</p>

<p>
`空間的~sensor$は、
同時的な測定を遂行できる直交な軸の本数に依存して，［
単軸（ `uniaxial^en ）,
二軸（ `biaxial^en ）,
三軸（ `triaxial^en ）
］いずれにもなり得る。
◎
A spatial sensor can be uniaxial, biaxial, or triaxial, depending on the number of orthogonal axes in which it can perform simultaneous measurements.
</p>

<p>
~scalar物理量（例：温度）は、
解決~用の`局所~座標系$を要求しない。
◎
Scalar physical quantities (e.g. temperature) do not require a local coordinate system for resolution.
</p>

<p>
通常は携帯~deviceで利用される`局所~座標系$は、
~Cartesian座標系であり，~deviceの~screenに相対的に定義される
,
その ~X軸, ~Y軸は~screenの各 次元に平行になり，~Z軸は~screen面に垂直になる。
◎
The local coordinate system normally used in a mobile device is a Cartesian coordinate system, which is defined relative to the device’s screen, so that X and Y axes are parallel to the screen dimentions and Z axis is perpendicular to the screen surface.
</p>

<p>
用語
`~platform~sensor@
（ `platform sensor^en ）は、
~UAが［
1 個~以上の`~device~sensor$を出自にする単独の`~sensor型$
］用に`~sensor読取り$を得するためにヤリトリできるような，~platform~interfaceを指す。
◎
The term platform sensor refers to platform interfaces, with which the user agent interacts to obtain sensor readings for a single sensor type originated from one or more device sensors.
</p>

<p>
`~platform~sensor$は、
下層の~platformにより定義されることもあれば
（例：~native~sensor~framework内で），
~UAにより定義されることもある
— `~device~sensor$への直な~accessを有するならば。
◎
Platform sensor can be defined by the underlying platform (e.g. in a native sensors framework) or by the user agent, if it has a direct access to device sensor.
</p>

<p>
実装の視点からは、
`~platform~sensor$は，対応する`~device~sensor$用の~software~proxyとして扱える。
下層の~platformが~supportするならば、
複数の`~platform~sensor$が同じ`~device~sensor$に同時的にヤリトリする可能性もある。
◎
From the implementation perspective platform sensor can be treated as a software proxy for the corresponding device sensor. It is possible to have multiple platform sensors simultaneously interacting with the same device sensor if the underlying platform suppports it.
</p>

<p>
単純な事例では，`~platform~sensor$は単独の`~device~sensor$に対応するが、
供された`~sensor読取り$が~software内で遂行された`~sensor融合$の産物である場合，`~platform~sensor$は［
`~sensor融合$の処理nに孕まれる`~device~sensor$の集合
］に対応する。
◎
In simple cases, a platform sensor corresponds to a single device sensor, but if the provided sensor readings are a product of sensor fusion performed in software, the platform sensor corresponds to a set of device sensors involved in the sensor fusion process.
</p>

<p>
`~sensor読取り$と［
それに対応する，測定される物理量
］との不一致は、
`較正@
（ `calibration^en ）を通して正される
— この不一致は、
製造~時に起こり得る。
一部の~sensorは、
未知な不一致を補償するため，動的な較正を要求し得る。
◎
Discrepancies between a sensor reading and the corresponding physical quantity being measured are corrected through calibration that can happen at manufacturing time. Some sensors can require dynamic calibration to compensate unknown discrepancies.
</p>

<p class="note">注記：
`~sensor融合$を通して作成される`~platform~sensor$は、
~virtual~sensor, あるいは合成な~sensorとも呼ばれる。
しかしながら，実用的には、
この仕様は，それらを区別しない。
◎
Note: Platform sensors created through sensor fusion are sometimes called virtual or synthetic sensors. However, the specification doesn’t make any practical distinction between them.
</p>

		</section>
		<section id="concepts-sensor-types">
<h3 title="Sensor Types">5.2. ~sensor型</h3>

<p>
測定される物理量は、
`~sensor型$ごとに異なる
— 温度, 気圧, 心拍数, 光度など。
◎
Different sensor types measure different physical quantities such as temperature, air pressure, heart-rate, or luminosity.
</p>

<p>
この仕様の目的においては、
各`~sensor型$は［
`高level$,
`低level$
］の 2 つに大別される：
◎
For the purpose of this specification we distinguish between high-level and low-level sensor types.
</p>

<ul>
	<li>
~sensorのうち，その実装により特徴付けられる`~sensor型$は、【！＊】
`低level@
（ `low-level^en ）な~sensorと称される。
例えば， `Gyroscope^I は`低level$な`~sensor型$である。
◎
Sensor types which are characterized by their implementation are referred to as low-level sensors. For example a Gyroscope is a low-level sensor type.
</li>
	<li>
~sensorのうち，その`~sensor読取り$の名前を継ぐもの【！＊】は、
その実装に関わらず，
`高level@
（ `high-level^en ）な~sensorであるとされる。
一例として，地理所在~sensorは利用者の所在についての情報を供するが、
この~dataが得される精確な手段は，目的を以って不透明なままにされており
（それは、［
~GPS集積回路, ~network基地局三角測量, ~wifi~network, 等々，あるいはこれら任意の組合n
］のどれからも得られ得る）、
実装に特有な様々な経験則に依存する。
`高level$な~sensorは、
一般に，`低level$な~sensorに何らかの~algoを適用した結果【！fruits】
— 例えば，歩数計は~gyroscopeの出力のみを利用して築ける —
であるか，`~sensor融合$のそれである。
◎
Sensors named after their readings, regardless of the implementation, are said to be high-level sensors. For instance, geolocation sensors provide information about the user’s location, but the precise means by which this data is obtained is purposefully left opaque (it could come from a GPS chip, network cell triangulation, wifi networks, etc. or any combination of the above) and depends on various, implementation-specific heuristics. High-level sensors are generally the fruits of applying algorithms to low-level sensors—for example, a pedometer can be built using only the output of a gyroscope—or of sensor fusion.
</li>
</ul>

<p>
とは言え、
`~sensor型$における［
`高level$,
`低level$
］の区別は，いくぶん恣意的であり、
この 2 つの間の線引きは，ぼやけていることが多い。
一例として，気圧を測定する気圧計は、
それが［
圧抵抗圧力~sensorと温度~sensorが成す`~sensor融合$
］の産物であっても，最も共通的な目的においては`低level$と見なされる
— それを構成する~sensorを公開しても実用的な目的は果たさないので
（圧電~sensorの温度を気にする者は居なかろう）。
気圧高度計も、
おそらく同じ分類に入る。
一方，構造不明な高度計は、
その~dataを気圧計からも~GPS信号からも取得することがあり、
明瞭に，`高level$な`~sensor型$に分類されることになる。
◎
That said, the distinction between high-level and low-level sensor types is somewhat arbitrary and the line between the two is often blurred. For instance, a barometer, which measures air pressure, would be considered low-level for most common purposes, even though it is the product of the sensor fusion of resistive piezo-electric pressure and temperature sensors. Exposing the sensors that compose it would serve no practical purpose; who cares about the temperature of a piezo-electric sensor? A pressure-altimeter would probably fall in the same category, while a nondescript altimeter—which could get its data from either a barometer or a GPS signal—would clearly be categorized as a high-level sensor type.
</p>

<p>
この区別は，いくぶんぼやけているので、
この仕様に対する拡張
（ `§ 拡張能＠#extensibility$を見よ）
は、対象になる`~sensor型$用に，その専門分野に特有な［
`高level$, `低level$
］~sensorの定義を供することが奨励される。
◎
Because the distinction is somewhat blurry, extensions to this specification (see § 10 Extensibility) are encouraged to provide domain-specific definitions of high-level and low-level sensors for the given sensor types they are targeting.
</p>

<p>
相異なる`~sensor型$からの`~sensor読取り$は、
`~sensor融合@
（ `sensor fusion^en ）と呼ばれる処理nを通して，一緒に結合され得る。
この処理nは、
`高level$な, または より正確aな~dataを供する
（待時間が増える~costと引き換えになることが多い）。
例えば，［
三軸からなる磁力計の`~sensor読取り$
］は、［
そのための正しい軸受を供する，加速度計の`~sensor読取り$
］と結合される必要がある。
◎
Sensor readings from different sensor types can be combined together through a process called sensor fusion. This process provides higher-level or more accurate data (often at the cost of increased latency). For example, the readings of a triaxial magnetometer needs to be combined with the readings of an accelerometer to provide a correct bearing.
</p>

<p>
~sensorには、［
`~smart~sensor@
（ `smart sensor^en ）／
~sensor~hub
（ `sensor hub^en ）
］と呼ばれる［
~hardware~levelで`較正$と`~sensor融合$を遂げる，組込みの算出-資源
］を備えるものもある。
それは、
処理nに割かれる~CPU資源を~~節約し, ~battery消費を抑える。
◎
Smart sensors and sensor hubs have built-in compute resources which allow them to carry out calibration and sensor fusion at the hardware level, freeing up CPU resources and lowering battery consumption in the process.
</p>

<p>
`~sensor融合$は、［
~hardware~levelでは遂行し得ない／~appに特有な`~sensor融合$~algoが要求される
］場合には，~software内で遂げられることもある。
◎
Sensor fusion can also be carried out in software if it cannot be performed at the hardware level or if an application-specific fusion algorithm is required.
</p>

		</section>
		<section id="concepts-default-sensor">
<h3 title="Default sensor">5.3. 既定の~sensor</h3>

<p>
汎用~sensor~APIは、
最も共通的な利用事例を単直にするよう設計されている
— より複階的な利用事例も可能化しつつ。
◎
The Generic Sensor API is designed to make the most common use cases straightforward while still enabling more complex use cases.
</p>

<p>
今日にて配備されている ほとんどの~deviceは、
同じ`~sensor型$の`~sensor読取り$を供する複数個の`~device~sensor$を備えてはいない。
複数個の類似な`~device~sensor$を要求する利用事例は稀であり、
一般に，特定の`~sensor型$
— 2-in-1【一台二役】~laptop内の複数の加速度計など —
に限られる。
◎
Most of devices deployed today do not carry more than one device sensor providing sensor readings of the same type. The use cases which require a set of similar device sensors are rare and generally limited to specific sensor types, such as multiple accelerometers in 2-in-1 laptops.
</p>

<p>
したがって，~deviceの既定の（かつ一意になることが多い）`~device~sensor$とヤリトリするのを容易にするため、
この~APIは，各`~sensor型$に対し，単純に対応する［
`Sensor$I の下位class
］を~instance化する。
◎
The API therefore makes it easy to interact with the device’s default (and often unique) sensor for each type simply by instantiating the corresponding Sensor subclass.
</p>

<p>
~~実際，［
所与の`~sensor型$の`~device~sensor$のうち，特定0の一つを識別する
］ような，特有な情報が伴われない下では、
~UAが
`既定の~sensor@
（ `default sensor^en ）を選ぶことになる。
◎
Indeed, without specific information identifying a particular sensor of a given type, the default sensor is chosen by the user agent.
</p>

<p>
下層の~platformが`既定の~sensor$を見出す~interfaceを供する場合、
~UAは，~platformから提供された~sensorを選ぶモノトスル。
他の場合、
~UA自身が［
~device上に在る`~device~sensor$のうち，どれが`既定の~sensor$になるか
］を定義する。
◎
If the underlying platform provides an interface to find the default sensor, the user agent must choose the sensor offered by the platform, otherwise the user agent itself defines which of the sensors present on the device is the default sensor.
</p>

<div class="example">
<p>
既定の加速度計の変化を~listenする例：
◎
Listening to the default accelerometer changes:
</p>

<pre class="lang-js">
let %sensor = new Accelerometer({ frequency: 30 });

%sensor.onreading = () =&gt; { ... }
%sensor.start();
</pre>
</div>

<p class="note">注記：
この仕様に対する拡張は、
`既定の~sensor$を定義しないことにしてもヨイ
— そうしてもイミを成さないならば。
例えば，`~sensor型$ `geolocation^l （地理所在）用の既定の`~device~sensor$を明示的に定義しても，イミを成さない
— その~interfaceの実装は、
複数の~backendを利用できるので。
◎
Note: Extensions to this specification may choose not to define a default sensor when doing so wouldn’t make sense. For example, it does not make sense to explicitly define a default sensor for geolocation sensor type as the implementation of its interface can use multiple backends.
</p>

<p>
同じ~device上で，同じ`~sensor型$に対応する複数の`~device~sensor$が共存し得る事例では、
拡張~仕様は，それぞれを一意に識別する仕方を定義する必要がある。
◎
In cases where multiple device sensors corresponding to the same type may coexist on the same device, specification extension will have to define ways to uniquely identify each one.
</p>

<div class="example">
<p>
例えば、
`pressure of the left rear tire^en
（空気圧, 左後輪の）を検査するとき：
◎
For example checking the pressure of the left rear tire:
</p>

<pre class="lang-js">
var %sensor = new DirectTirePressureSensor(
   { position: "rear", side: "left" }
);
%sensor.onreading = _ =&gt; console.log(%sensor.pressure);
%sensor.start();
</pre>
</div>

		</section>
		<section id="concepts-sampling-and-reporting-frequencies">
<h3 title="Sampling Frequency and Reporting Frequency">5.4. 標本化~frequency, 報告ng~frequency</h3>

<p>
この仕様の目的においては、
`~platform~sensor$の
`標本化~frequency@
（ `sampling frequency^en ）は，
`~platform~sensor$が下層の`~device~sensor$から`~sensor読取り$を得する~frequencyとして定義される。
そのような`~sensor読取り$が得される仕方は、
`実装定義$とする。
◎
For the purpose of this specification, a platform sensor's sampling frequency is defined as a frequency at which a platform sensor obtains sensor readings from the underlying device sensor. The way such sensor readings are obtained is implementation-defined.
</p>

<p>
`~platform~sensor$の`標本化~frequency$は、
下層の`~device~sensor$の実際の標本化~rateに対応するとは限らず，
この仕様の目的においては不透明である。
◎
The platform sensor's sampling frequency may not correspond to the device sensor's actual sampling rate, which, for the purpose of this specification, is opaque.
</p>

<p class="note">注記：
［
`~sensor読取り$用の~system~levelの~API
］および［
当の~sensor自身に対する下層の~hardware~interface
］は、
~polling用にも~event用にも築かれ得る。
~pollingに基づく`~device~sensor$用には、
`~platform~sensor$の`標本化~frequency$は，［
~system／~hardware
］から新たな読取りが要請される~rateになる。
~eventに基づく`~device~sensor$用には、
`~platform~sensor$が，要請された標本化~frequencyを［
~system／~hardware
］に供する
— ~eventたちは、
その~frequency以下で生成される。
~eventは、
~sensor読取りが変化しなかった場合には，生成されないこともある。
◎
Note: System-level APIs for sensor readings and the underlying hardware interface to the sensors themselves may be built for polling or events. For a polling-based device sensor, the platform sensor's sampling frequency would be the rate at which a new reading is requested from the system or hardware. For an event-based device sensor, a platform sensor provides a requested sampling frequency to the system or hardware, and events are generated at that frequency or below. Events may not be generated if the sensor reading has not changed.
</p>

<p>
`~device~sensor$は、
自身が`~platform~sensor$から受容できる標本化~frequencyの限界域を［
`最小~標本化~frequency@dV
／
`最大~標本化~frequency@dV
］の形でを供してもヨイ
— 指定されない場合、［
0 ／ 無限大
］をとるとする†。
`~platform~sensor$の`標本化~frequency$は、
下層の`~device~sensor$の［
`最小~標本化~frequency$dV以上,
`最大~標本化~frequency$dV以下
］になるモノトスル。
◎
A device sensor may provide bounds for the sampling frequency value it can accept from a platform sensor in the form of a minimum sampling frequency and a maximum sampling frequency. A platform sensor's sampling frequency must not be less than the device sensor's minimum sampling frequency or greater than its maximum sampling frequency.
</p>

<p class="trans-note">【†
これら “既定の” 値は、
他所の記述を簡素化するための，この訳による追加。
】</p>

<p>
`~platform~sensor$ %~sensor の`標本化~frequency$は、［
%~sensor にて`作動化された~sensor~obj群$を成す各`~item$が供する `frequency$sl
］に基づいて決定される。
この計算は，`実装定義$であるが、
その結果は，次の両者により設定される限界域の中に入るモノトスル：
◎
A platform sensor's sampling frequency is determined based on the provided [[frequency]] of the items in its set of activated sensor objects. The calculation is implementation-defined, but the outcome value must lie within the bounds set by＼
</p>
<ul>
	<li>
%~sensor が`属する~sensor型$の［
`最小~標本化~frequency$, `最大~標本化~frequency$
］
◎
the platform sensor's sensor type's minimum and maximum sampling frequencies and＼
</li>
	<li>
%~sensor の下層の`~device~sensor$の［
`最小~標本化~frequency$dV, `最大~標本化~frequency$dV
］
◎
its device sensor's minimum and maximum sampling frequencies.
</li>
</ul>

<p class="note">注記：
例えば，~UAは、
`標本化~frequency$を［
供された各 `frequency$sl が成す集合の
`Least Common Denominator (LCD)^en 【！最小公分母】
］を［
下層の~platformにより定義される`標本化~frequency$の限界域
］で切り詰めた結果として見積もってもよい。
◎
Note: For example, the user agent may estimate the sampling frequency as a Least Common Denominator (LCD) for a set of provided [[frequency]] capped by sampling frequency bounds defined by the underlying platform.
</p>

<p>
具象-【~sensorに対応する】 `Sensor$I ~obj用の
`報告ng~frequency@
（ `reporting frequency^en ）は、
この~objに向けて `reading$et ~eventが`発火され$る~frequencyとして定義される。
◎
The reporting frequency for a concrete Sensor object is defined as a frequency at which the "reading" event is fired at this object.
</p>

<p>
`Sensor$I ~obj %~sensor は、
~UAが下層の~platformから新たな`~sensor読取り$を得するよりも高い~rateでは，
それらに~accessし得ない。
したがって， %~sensor の`報告ng~frequency$は：
◎
A Sensor object cannot access new readings at a higher rate than the user agent obtains them from the underlying platform, therefore the reporting frequency＼
</p>
<ul>
	<li>
%~sensor に結付けられた`~platform~sensor$ %~platform~sensor の`標本化~frequency$を
— その結果，その下層の（指定されたならば）`~device~sensor$の`最大~標本化~frequency$dVも —
決して超過しない。
◎
can never exceed a platform sensor's sampling frequency, which in turn can never exceed a device sensor's maximum sampling frequency (when specified).
</li>
	<li>
<p>
次に挙げる事例などにおいては、
%~sensor の `frequency$sl と相違する：
◎
The reporting frequency differs from the Sensor's [[frequency]] in cases such as:
</p>
		<ul>
			<li>
要請された `frequency$sl は、
次が返す限界域の外側にある
⇒
`~platform~sensorの標本化~限界域を取得する$( %~platform~sensor )
◎
the requested [[frequency]] lies outside the bounds returned by invoking get a platform sensor’s sampling bounds with Sensor's associated platform sensor.
</li>
			<li>
~OSまたは当の`~device~sensor$が，
前回に報告されたものから（絶対的あるいは相対的に）十分に相違しない読取りを
— ~hardwareや~OSの~filterを介して，自動的に —
破棄している。
◎
the operating system and/or the device sensor automatically discard readings that do not differ enough (in absolute or relative terms) from the previously reported ones via a hardware or operating system filter.
</li>
			<li>
%~platform~sensor が`属する~sensor型$の`~threshold検査~algo$に失敗した
【~algoは ~F を返した】
結果、
%~platform~sensor の`最新な読取り~map$は更新されなかった。
◎
the Sensor instance’s associated sensor type's threshold check algorithm fails and the platform sensor's latest readings are not updated.
</li>
		</ul>
	</li>
</ul>

		</section>
		<section id="concepts-can-expose-sensor-readings">
<h3 title="Conditions to expose sensor readings">5.5. ~sensor読取りを公開するための条件</h3>

<p>
~UAが所与の %文書 において
`~sensor読取りを公開できる@
（ `can expose sensor readings^en ）
のは、
~AND↓ が満たされるとき, そのときに限られる：
◎
The user agent can expose sensor readings to a given document if and only if all of the following are true:
</p>
<ul>
	<li>
%文書 に`関連な設定群~obj$は、
`~secureな文脈$enVである。
◎
document’s relevant settings object is a secure context.
</li>
	<li>
%文書 の`可視性~状態$doc ~EQ `visible^l
◎
document’s visibility state is "visible".
</li>
	<li>
( `現在の被focus区画$tlTの文書【`~DOM~anchor$の`~node文書$】の`生成元$doc, %文書 の`生成元$doc )
は`同じ生成元~domain$である。
◎
The currently focused area belongs to a document whose origin is same origin-domain with document’s origin.
</li>
	<li>
`拡張~仕様$に
`特有な条件@
（ `specific conditions^en ）
— `拡張~仕様$は、
各自の~sensor型~用に，［
より厳密な要件を成す新たな条件
］をこの~listに追加してもヨイ。
◎
Specific conditions: Extension specifications may add new conditions to this list to have stricter requirements for their sensor types.
</li>
</ul>

<p class="note">注記：
上に挙げた条件に加えて，重要な注意は、［
`Sensor$I の各~下位classは、
自身の構築子において
`~sensor施策により制御される特能を検査する＠#check-sensor-policy-controlled-features$こと
］および［
`start()$m ~methodは、
`~sensor~accessを要請する$こと
］である。
これらの検査は、
組で，
`§ 軽減~策＠#mitigation-strategies$
にて述べられる軽減~策に対応する。
◎
Note: In addition to the conditions above, it is important to note that Sensor subclasses invoke the check sensor policy-controlled features operation in their constructors, and § 7.1.7 Sensor.start() invokes request sensor access. Together, these checks correspond to the mitigation strategies described in § 4.2 Mitigation Strategies.
</p>

<p class="note">注記：
~hardware資源を解放するため、
~UAは，［
`~sensor読取りを公開できる$ようになるまで，新たに可用な読取りについての通知を休止する
］よう，下層の`~platform~sensor$に要請できる／し得る。
◎
Note: In order to release hardware resources, the user agent can request underlying platform sensor to suspend notifications about newly available readings until it can expose sensor readings.
</p>

		</section>
	</section>
	<section id="model">
<h2 title="Model">6. ~model</h2>

		<section id="model-sensor-type">
<h3 title="Sensor Type">6.1. ~sensor型</h3>

<p>
各
`~sensor型@
（ `sensor type^en ）には、
次に挙げる~dataが結付けられなければナラナイ：
◎
A sensor type must have the following associated data:
</p>
<ul>
	<li>
1 個~以上の`拡張~sensor~interface$たち。
◎
One or more extension sensor interfaces.
</li>
	<li>
<p>
`~sensor許可~名~群@
（ `sensor permission names^en ）
⇒
`強力な特能$を識別する`名前$たちが成す`空$でない`集合$。
◎
A non-empty ordered set of associated powerful feature names referred to as sensor permission names.
</p>

<p class="note">注記：
複数の`~sensor型$が、
同じ`名前$を共有し得る。
◎
Note: Multiple sensor types may share the same name.
</p>
	</li>
	<li>
`~sensor特能~名~群@
（ `sensor feature names^en ）
⇒
`施策により制御される特能$を識別する~tokenたちが成す`空$でない`集合$。
◎
A non-empty ordered set of associated policy-controlled feature tokens referred to as sensor feature names.
</li>
	<li>
ある`許可~revocation~algo$
◎
A permission revocation algorithm.
</li>
	<li>
`最小~標本化~frequency@
⇒
ある正な数。
これは、
`実装定義$になるか，`拡張~仕様$により定義される。
どちらも設定された場合、
大きい方の値が利用される。
◎
A minimum sampling frequency, a positive number. It is either implementation-defined or defined by an extension specification. If both are set, the largest value is used.
</li>
	<li>
`最大~標本化~frequency@
⇒
ある正な数。
これは、
`実装定義$になるか，`拡張~仕様$により定義される。
どちらも設定された場合、
小さい方の値が利用される。
◎
A maximum sampling frequency, a positive number. It is either implementation-defined or defined by an extension specification. If both are set, the smallest value is used.
</li>
</ul>

<p>
`最小~標本化~frequency$は、
`最大~標本化~frequency$以下になるモノトスル。
◎
The minimum sampling frequency must not be greater than the maximum sampling frequency.
</p>

<p>
各`~sensor型$には、
次に挙げる~dataが結付けられてもヨイ
— いずれも，無い場合は ε をとるとする：
◎
A sensor type may have the following associated data:
</p>
<ul>
	<li>
`既定の~sensor$
⇒
【ある`~device~sensor$／`~platform~sensor$。】
◎
A default sensor.
</li>
	<li>
`~threshold検査~algo@
（ `threshold check algorithm^en ）
⇒
所与の［
別々な 2 個の`~sensor読取り$
］に対し，真偽値を返す~algo。
これは、
2 つの読取りが十分~相違するか否かを決定する
— 当の`~platform~sensor$の`最新な読取り~map$は、
その結果が ~T になる場合に限り，更新される。
◎
A threshold check algorithm, which takes as arguments two separate sensor readings and determines if they differ enough to cause a platform sensor's latest reading map to be updated.
</li>
	<li>
`読取り量子化~algo@
（ `reading quantization algorithm^en ）
⇒
所与の`~sensor読取り$に対し，
正確度に劣る`~sensor読取り$を返す~algo。
◎
A reading quantization algorithm, which takes a sensor reading and returns a less accurate sensor reading.
</li>
	<li>
`属する~virtual~sensor型@
⇒
ある`~virtual~sensor型$
◎
A virtual sensor type.
</li>
</ul>

		</section>
		<section id="model-sensor">
<h3 title="Sensor">6.2. ~sensor</h3>

<p>
現在の`閲覧~文脈$の`~platform~sensor$には、
次に挙げるものが結付けられるモノトスル：
【各~platform~sensor？／“現在の” とは？】
◎
The current browsing context's platform sensor must have:
</p>
<ul>
	<li>
`作動化された~sensor~obj群@
（ `activated sensor objects^en ）
⇒
【`Sensor$I ~objたちが成す】`集合$
— 初期~時は`空$とする
◎
An associated set of activated sensor objects, which is initially empty;
</li>
	<li>
`最新な読取り~map@
（ `latest reading map^en ／ `latest readings^en ／ `latest reading^en ）
⇒
`~map$
— これは、最新な［
可用な`~sensor読取り$
］を保持する
◎
An associated latest reading map, which holds the latest available sensor readings.
</li>
	<li>
`属する~sensor型@
⇒
ある`~sensor型$
◎
An associated sensor type.
</li>
</ul>

<p class="note">注記：
~UAは、［
異なる`閲覧~文脈$の間で，各自の`作動中な文書$bcの`生成元$は`同じ生成元~domain$である場合
］に限り［
`最新な読取り~map$,
`作動化された~sensor~obj群$
］を共有できる。
◎
Note: User agents can share the latest reading map and the activated sensor objects set between different contexts only if the origins of these contexts' active documents are same origin-domain.
</p>

<div class="algo">
<p>
どの時点であれ，`~platform~sensor$用の新たな`~sensor読取り$が得されたときは、
次を走らすとする
⇒
~IF［
~UAは、
現在の`閲覧~文脈$にて`作動中な文書$bcに`~sensor読取りを公開できる$
］
⇒
`最新な読取りを更新する$( `~platform~sensor$, `~sensor読取り$ )
◎
Any time a new sensor reading for a platform sensor is obtained and if the user agent can expose sensor readings to the current browsing context's active document, the user agent invokes update latest reading with the platform sensor and the sensor reading as arguments.
</p>
</div>

<p>
`最新な読取り~map$は、
`~key$mapとして `timestamp^l を伴う`~entry$を包含する。
その`値$mapは、
高-分解能な時刻印であり，
`読取り時刻印$の見積もりを［
~milli秒数で表出される，`安全でない現在の時刻$1
］として与える。
◎
The latest reading map contains an entry whose key is "timestamp" and whose value is a high resolution timestamp that estimates the reading timestamp expressed in milliseconds as an unsafe current time.
</p>

<p>
`最新な読取り~map$[ `timestamp^l ] は、
初期~時は ~NULL に設定される
— `最新な読取り~map$が，以前の`~sensor読取り$を~cacheしていない限り。
◎
Latest reading["timestamp"] is initially set to null, unless the latest reading map caches a previous reading.
</p>

<p>
`最新な読取り~map$を成す他の`~entry$は、
各種`~platform~sensor$により測定された物理量の値を保持する。
これらの`~entry$の`~key$mapは、［
当の`~sensor型$に結付けられた ある`拡張~sensor~interface$ %~interface
］に定義される`属性$ %属性 の`識別子$ %識別子 に合致するモノトスル。
%属性 の取得子の返り値は、
次を呼出すことで容易に得される
⇒
`最新な読取り~mapから値を取得する$( %~interface を実装している~obj, %識別子 )
◎
The other entries of the latest reading map hold the values of the different quantities measured by the platform sensor. The keys of these entries must match the attribute identifier defined by the sensor type's associated extension sensor interface. The return value of the attribute getter is easily obtained by invoking get value from latest reading with the object implementing the extension sensor interface and the attribute identifier as arguments.
</p>

<p>
`最新な読取り~map$を成す どの`~entry$も，その`値$mapは、
初期~時は ~NULL に設定されるとする。
◎
The value of all latest reading entries is initially set to null.
</p>

<div class="algo">
<p>
`~platform~sensorの標本化~限界域を取得する@
ときは、
所与の
( `~platform~sensor$ %~platform~sensor )
に対し：
◎
To get a platform sensor’s sampling bounds given a platform sensor platformSensor:
</p>
<ol>
	<li>
%最小~frequency ~SET 次に挙げる値たちの最大
⇒＃
%~platform~sensor の`~sensor型$の`最小~標本化~frequency$,
%~platform~sensor に接続された`~device~sensor$の`最小~標本化~frequency$dV
◎
Let minimumFrequency be platformSensor’s sensor type's minimum sampling frequency.
◎
If platformSensor’s connected device sensor has a minimum sampling frequency, set minimumFrequency to the maximum of minimumFrequency and this value.
</li>
	<li>
%最大~frequency ~SET 次に挙げる値たちの最小
⇒＃
%~platform~sensor の`~sensor型$の`最大~標本化~frequency$,
%~platform~sensor に接続された`~device~sensor$の`最大~標本化~frequency$dV
◎
Let maximumFrequency be platformSensor’s sensor type's maximum sampling frequency.
◎
If platformSensor’s connected device sensor has a maximum sampling frequency, set maximumFrequency to the minimum of maximumFrequency and this value.
</li>
	<li>
~RET `~tuple$( %最小~frequency, %最大~frequency )
◎
Return a tuple (minimumFrequency, maximumFrequency).
</li>
</ol>
</div>

<div class="example">
<p>
`上で述べた~model＠#model$のアリな実装を，次の例に示す。
◎
This example illustrates a possible implementation of the described Model.
</p>

<p>
下の図式では、［
異なる 2 つの`閲覧~文脈$ それぞれにおいて`作動化された~sensor~obj群$
］が，単独の`~device~sensor$とヤリトリする。
◎
In the diagram below several activated Sensor objects from two different browsing contexts interact with a single device sensor.
</p>

【！ generic_sensor_model.png 】
<div class="ex-model">
	<div class="ex-model-bc" style="top:0; left:0;">
<div>閲覧~文脈 1</div>

		<div class="ex-model-box" style="top:2em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 1 Hz
<li>`state$sl = `activated^l
</ul>
		</div>
		<div class="ex-model-box" style="top:8em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 10 Hz
<li>`state$sl = `activated^l
</ul>
		</div>
	</div>

	<div class="ex-model-line" style="width:2.5em; left:14.5em; top:3em; transform:skewY(0deg)"></div>
	<div class="ex-model-line" style="width:2.5em; left:14.5em; top:3em; transform:skewY(-65deg)"></div>

	<div class="ex-model-box" style="top:2em; left:17em;">
<div>~platform~sensor</div>
<ul>
<li>要請された標本化~frequency = 10 Hz
<li>作動化された~sensor~obj
<li>最新な読取り
</ul>
	</div>

	<div class="ex-model-bc" style="top:15em; left:0;">
<div>閲覧~文脈 2</div>
		<div class="ex-model-box" style="top:2em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 1 Hz
<li>`state$sl = `activated^l
</ul>
		</div>
		<div class="ex-model-box" style="top:8em; left:1em;">
<div>`Accelerometer : Sensor^I</div>
<ul>
<li>~frequency = 1 Hz
<li>`state$sl = `idle^l
</ul>
		</div>
	</div>
	<div class="ex-model-box" style="top:17em; left:17em;">
<div>~platform~sensor</div>
<ul>
<li>要請された標本化~frequency = 1 Hz
<li>作動化された~sensor~obj
<li>最新な読取り
</ul>
	</div>
	<div class="ex-model-line" style="width:2.5em; left:14.5em; top:18em; transform:skewY(0deg)"></div>

	<div class="ex-model-line" style="width:8em; left:28em; top:9em; transform:skewY(36deg)"></div>
	<div class="ex-model-line" style="width:8em; left:28em; top:9em; transform:skewY(-47deg)"></div>

	<div class="ex-model-box" style="top:8em; left:36em;">
<div>~device~sensor</div>
`sensor_parts1@
	</div>
</div>

<p>
`遊休中＠#sensor-lifecycle$（ `idle^l ）状態にある `Sensor$I ~objは、
`~platform~sensor$にて`作動化された~sensor~obj群$に含まれないので，
`~device~sensor$とはヤリトリしない。
◎
The Sensor object in "idle" state is not among the platform sensor's activated sensor objects and thus it does not interact with the device sensor.
</p>

<p>
この例には、
`閲覧~文脈$ごとに`~platform~sensor$~instanceがある。
◎
In this example there is a platform sensor instance per browsing context.
</p>

<p>
`最新な読取り~map$は、
同じ`閲覧~文脈$からの `Sensor$I ~obj間で共有され，
対応する`~platform~sensor$に要請した`標本化~frequency$に等しい~rateで更新される。
◎
The latest reading map is shared between Sensor objects from the same context and is updated at a rate equal to the requested sampling frequency of the corresponding platform sensor.
</p>
</div>

		</section>
	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

		<section id="the-sensor-interface">
<h3 title="The Sensor Interface">7.1. `Sensor^I ~interface</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(DedicatedWorker, Window)]
interface `Sensor@I : `EventTarget$I {
  readonly attribute `boolean$ `activated$m;
  readonly attribute `boolean$ `hasReading$m;
  readonly attribute `DOMHighResTimeStamp$I? `timestamp$m;
  `undefined$ `start$m();
  `undefined$ `stop$m();
  attribute `EventHandler$I `onreading$m;
  attribute `EventHandler$I `onactivate$m;
  attribute `EventHandler$I `onerror$m;
};

dictionary `SensorOptions@I {
  `double$ `frequency@m;
};
</pre>

<p>
各 `Sensor$I ~objには、
ある`~platform~sensor$が結付けられる。
◎
A Sensor object has an associated platform sensor.
</p>

<p>
各~具象- `Sensor$I ~obj %~obj には、
次を満たす ある`~sensor型$ %~sensor型 も結付けられる
⇒
%~obj が実装する ある`~interface$ ~IN %~sensor型 に結付けられた`拡張~sensor~interface$たち
◎
Concrete Sensor objects also have an associated sensor type, which is the sensor type that has their interface among its extension sensor interfaces.
</p>

<p class="trans-note">【
遠回しな定義だが、
それ以上のことは，この仕様からは読み取れない。
該当し得るものが複数ある場合、
どれになるかは，個々の`拡張~仕様$により定義されるのかもしれない。
%~obj に結付けられた`~platform~sensor$が`属する~sensor型$を意図しているかもしれないが、
はっきりしない。
】</p>

<p>
この仕様に言及される`~task$用の`~task~source$は、
`~sensor~task~source@
（ `sensor task source^en ）とする。
◎
The task source for the tasks mentioned in this specification is the sensor task source.
</p>

<div class="example">
<p>
次の例では，~UAは、
先ず`~sensor読取り$に~accessする許可があるかどうか検査してから，
加速度計~sensorを構築して、［
新たに可用にされた`~sensor読取り$についての［
`~platform~sensor$の作動化, ~error条件, 通知
］用の`~event$を取得する
］ための`~event~listener$を追加する。
この例は、［
`~platform~sensor$を~hostしている~deviceの それまでに測定された最大な加速度
］を~logする。
◎
In the following example, firstly, we check whether the user agent has permission to access sensor readings, then we construct accelerometer sensor and add event listeners to get events for platform sensor activation, error conditions and notifications about newly available sensor readings. The example measures and logs maximum total acceleration of a device hosting the platform sensor.
</p>

<p>
対応する `Sensor$I ~interfaceの`~event~handler$属性~用の`~event~handler~event型$は、
`§ ~event~handler＠#event-handlers$
に定義される。
◎
The event handler event types for the corresponding Sensor Interface's event handler attributes are defined in Event handlers section.
</p>

<pre class="lang-js">
navigator.permissions.query({ name: 'accelerometer' }).then(%result =&gt; {
    if (%result.state === 'denied') {
        console.log('加速度計~sensorを利用する許可は否認されました。');
        return;
    }

    let %acl = new Accelerometer({frequency: 30});
    let %max_magnitude = 0;
    %acl.addEventListener('activate', () =&gt; console.log('測定する用意ができました'));
    %acl.addEventListener('error', %error =&gt; console.log(``^~error： ${%error.name}``^));
    %acl.addEventListener('reading', () =&gt; {
        let %magnitude = Math.hypot(%acl.x, %acl.y, %acl.z);
        if (%magnitude &gt; %max_magnitude) {
            %max_magnitude = %magnitude;
            console.log(``^最大値： ${%max_magnitude} m/s2``^);
        }
    });
    %acl.start();
});
</pre>
<!-- 
Permission to use accelerometer sensor is denied.
 -->
</div>

			<section id="sensor-lifecycle">
<h4 title="Sensor lifecycle">7.1.1. `Sensor^I の~lifecycle</h4>

<figure>
<div id="_ex-lifecycle">
	<div class="ex-ends">開始</div>
	<div class="ex-transition">↓`構築-＠#extension-sensor-interface$</div>
	<div class="ex-state">遊休中（ `idle^l ）</div>
	<div class="ex-transition">
<span>↓`start()$m</span>
<span>↑`onerror$m</span>
	</div>
	<div class="ex-state">作動化-中（ `activating^l ）</div>
	<div class="ex-transition">↓</div>
	<div class="ex-state">作動化-済み（ `activated^l ）</div>
	<div class="ex-transition">
<span >↓`stop()$m／`onerror$m</span>
	</div>
	<div class="ex-ends">（ “遊休中” へ戻る）</div>
</div>

<figcaption>
~sensorの~lifecycleを表す図式
◎
Sensor lifecycle
</figcaption>
</figure>

<p class="note">注記：
上の図式~内の各~nodeは、
`Sensor$I ~objの各~状態（ `state$sl 値）を表現する。
それらは、下層の［
`~platform~sensor$／`~device~sensor$
］にアリな状態と混同するべきでない。
◎
Note: The nodes in the diagram above represent the states of a Sensor object and they should not be confused with the possible states of the underlying platform sensor or device sensor.
</p>

			</section>
			<section id="sensor-garbage-collection">
<h4 title="Sensor garbage collection">7.1.2. `Sensor^I の~garbage収集</h4>

<p>
`Sensor$I ~objは、
~OR↓ を満たす間は~garbage収集しないモノトスル：
◎
↓</p>
<ul>
	<li>
［
`state$sl ~EQ `activating^l
］~AND［［
`activate$et【！原文は `activated^et】 ／ `reading$et ／ `error$et
］~event用に登録された~event~listenerがある
◎
A Sensor object whose [[state]] is "activating" must not be garbage collected if there are any event listeners registered for "activated" events, "reading" events, or "error" events.
</li>
	<li>
［
`state$sl ~EQ `activated^l
］~AND［［
`reading$et ／ `error$et
］~event用に登録された~event~listenerがある
］
◎
A Sensor object whose [[state]] is "activated" must not be garbage collected if there are any event listeners registered for "reading" events, or "error" events.
</li>
</ul>

<p>
`Sensor$I ~objのうち［
その `state$sl ~IN { `activated^l, `activating^l }
］を満たすもの %O が~garbage収集されるときは、
~UAは次を呼出すモノトスル
⇒
`~sensor~objを非作動化する$( %O )
◎
When a Sensor object whose [[state]] is "activated" or "activating" is garbage collected, the user agent must invoke deactivate a sensor object with this object as argument.
</p>

			</section>
			<section id="sensor-internal-slots">
<h4 title="Sensor internal slots">7.1.3. `Sensor^I の内部~slot</h4>

<p>
`Sensor$I の各~instanceは、
次の表tに述べる内部~slotを伴って作成される：
◎
Instances of Sensor are created with the internal slots described in the following table:
</p>

<div>
<table id="sensor-slots" class="grid-table"><thead>
<tr><th>内部~slot
<th>値~型
<th>初期~値
<th>記述（規範的でない）
<tbody>

<tr><td>`state@sl
<td>`文字列$
<td>`idle^l
<td>
`Sensor$I ~objの現在の状態
— 次のいずれかをとる
⇒
`idle^l,
`activating^l,
`activated^l

<tr><td>`frequency@sl
<td>~NULL または `double^c
<td>~NULL
<td>
<p>
~frequencyを~in-Hzで表現する。
［
結付けられた`~platform~sensor$用の`標本化~frequency$を計算する／
この `Sensor$I ~obj用の`報告ng~frequency$の上限を定義する
］ために利用される。
</p>

<tr><td>`lastEventFiredAt@sl
<td>~NULL または `double^c
<td>~NULL
<td>
<p>
`Sensor$I ~objの観測器へ送信された最新な`~sensor読取り$の［
`時刻~起点$enVからの~milli秒数で表出される，高-分解能な時刻印
］。
</p>

<tr><td>`pendingReadingNotification@sl
<td>真偽値
<td>~F
<td>
新たな`~sensor読取り$が報告された後，観測器【すなわち `Sensor$I ~obj】に通知される必要があるかどうかを指示する。
</table>

◎
Internal Slot
• Description (non-normative)
◎
[[state]]
• The current state of the Sensor object which is one of "idle", "activating", or "activated". It is initially "idle".
◎
[[frequency]]
• A double representing frequency in Hz that is used to calculate the sampling frequency for the associated platform sensor and to define the upper bound of the reporting frequency for this Sensor object. It is initially null.
◎
[[lastEventFiredAt]]
• The high resolution timestamp of the latest sensor reading that was sent to observers of the Sensor object, expressed in milliseconds that passed since the time origin. It is initially null.
◎
[[pendingReadingNotification]]
• A boolean which indicates whether the observers need to be notified after a new sensor reading was reported. It is initially false.
</div>

			</section>
			<section id="_sensor-members">
<h4>7.1.4〜11. 属性と~method</h4>

<div class="algo">
<p>
`activated@m
取得子~手続きは
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
コレ . `state$sl ~EQ `activated^l
◎
7.1.4. Sensor.activated
◎
The activated getter steps are:
• If this.[[state]] is "activated", return true.
• Otherwise, return false.
</p>
</div>

<div class="algo">
<p>
`hasReading@m
取得子~手続きは：
◎
7.1.5. Sensor.hasReading
◎
The hasReading getter steps are:
</p>

<ol>
	<li>
%時刻印 ~LET `最新な読取り~mapから値を取得する$( コレ, `timestamp^l )
◎
Let timestamp be the result of invoking get value from latest reading with this and "timestamp" as arguments.
</li>
	<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%時刻印 ~NEQ ~NULL
◎
If timestamp is not null, return true.
◎
Otherwise, return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`timestamp@m
取得子~手続きは：
◎
7.1.6. Sensor.timestamp
◎
The timestamp getter steps are:
</p>
<ol>
	<li>
%大域~obj ~LET コレに`関連な大域~obj$
◎
Let global be this's relevant global object.
</li>
	<li>
%安全でない時刻印 ~LET `最新な読取り~mapから値を取得する$( コレ, `timestamp^l )
◎
Let unsafeTimestamp be the result of invoking get value from latest reading with this and "timestamp" as arguments.
</li>
	<li>
~RET `相対的な高分解能~時刻$( %安全でない時刻印, %大域~obj )
◎
Return relative high resolution time with unsafeTimestamp and global.
</li>
</ol>
</div>

<div class="algo">
<p>
`start()@m
~method~手続きは：
◎
7.1.7. Sensor.start()
◎
The start() method steps are:
</p>
<ol>
	<li>
~IF［
コレ . `state$sl ~IN { `activating^l, `activated^l }
］
⇒
~RET
◎
If this.[[state]] is either "activating" or "activated", then return.
</li>
	<li>
コレ . `state$sl ~SET `activating^l
◎
Set this.[[state]] to "activating".
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run these sub-steps in parallel:
</p>
		<ol>
			<li>
%許可~状態 ~LET `~sensor~accessを要請する$( コレ )
◎
Let permissionState be the result of invoking request sensor access with this as argument.
</li>
			<li>
<p>
~IF［
%許可~状態 ~EQ `denied^l
］
⇒
◎
If permissionState is "denied", then:
</p>
				<ol>
					<li>
%e ~LET `例外を作成する$( `NotAllowedError$E )
◎
Let e be the result of creating a "NotAllowedError" DOMException.
</li>
					<li>
<p>
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~errorを通知する$( コレ, %e )
</div>
◎
Queue a task to run notify error with this and e as arguments.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%接続されたか ~LET `~sensorに接続する$( コレ, コレに`関連な大域~obj$ )
◎
Let connected be the result of invoking connect to sensor with this and this's relevant global object as argument.
</li>
			<li>
<p>
~IF［
%接続されたか ~EQ ~F
］：
◎
If connected is false, then
</p>
				<ol>
					<li>
%e ~LET `例外を作成する$( `NotReadableError$E )
◎
Let e be the result of creating a "NotReadableError" DOMException.
</li>
					<li>
<p>
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~errorを通知する$( コレ, %e )
</div>
◎
Queue a task to run notify error with this and e as arguments.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
`~sensor~objを作動化する$( コレ )
◎
Invoke activate a sensor object with this as argument.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`stop()@m
~method~手続きは：
◎
7.1.8. Sensor.stop()
◎
The stop() method steps are:
</p>
<ol>
	<li>
~IF［
コレ . `state$sl ~EQ `idle^l
］
⇒
~RET
◎
If this.[[state]] is "idle", then return.
</li>
	<li>
コレ . `state$sl ~SET `idle^l
◎
Set this.[[state]] to "idle".
</li>
	<li>
この段は`並列的$に走らす
⇒
`~sensor~objを非作動化する$( コレ )
◎
Run these sub-steps in parallel:
• Invoke deactivate a sensor object with this as argument.
</li>
</ol>
</div>

<p>
`onreading@m
は、
`~event~handler~IDL属性$【！ `EventHandler$I 】であり，
新たな`~sensor読取り$が可用であることを通知するために~callされる。
◎
7.1.9. Sensor.onreading
◎
onreading is an EventHandler which is called to notify that new reading is available.
</p>

<p>
`onactivate@m
は、
`~event~handler~IDL属性$【！ `EventHandler$I 】であり，
コレ . `state$sl が `activating^l から `activated^l へ遷移したときに~callされる。
◎
7.1.10. Sensor.onactivate
◎
onactivate is an EventHandler which is called when this.[[state]] transitions from "activating" to "activated".
</p>

<p>
`onerror@m
は、
`~event~handler~IDL属性$【！ `EventHandler$I 】であり，［
抽象-演算／~IDL演算
］における~errorを同期的に取扱えないときに~callされる。
◎
7.1.11. Sensor.onerror
◎
onerror is an EventHandler which is called whenever an error in an abstract or IDL operation cannot be handled synchronously.
</p>

			</section>
			<section id="event-handlers">
<h4 title="Event handlers">7.1.12. ~event~handler</h4>

<p>
`Sensor$I ~interfaceを実装している~objは、
次に挙げる`~event~handler$
（および，それぞれに対応する`~event~handler~event型$）
を属性として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported as attributes by the objects implementing the Sensor interface:
</p>

<table><thead>
<tr><th>~event~handler
<th>~event~handler~event型
<tbody>

<tr><td>`onreading^m
<td>`reading@et

<tr><td>`onactivate^m
<td>`activate@et

<tr><td>`onerror^m
<td>`error@et
</table>

			</section>
		</section>
		<section id="the-sensor-error-event-interface">
<h3 title="The SensorErrorEvent Interface">7.2. `SensorErrorEvent^I ~interface</h3>

<pre class="idl">
[`SecureContext$, `Exposed$=(DedicatedWorker, Window)]
interface `SensorErrorEvent@I : `Event$I {
  `SensorErrorEvent@mc(`DOMString$ %type, `SensorErrorEventInit$I %errorEventInitDict);
  readonly attribute `DOMException$I `error$m;
};

dictionary `SensorErrorEventInit@I : `EventInit$I {
  required `DOMException$I `error@mb;
};
</pre>

<p>
`SensorErrorEvent$I の~instanceは、
`~event構築子$に述べられる手続きに従って構築される。
◎
SensorErrorEvent instances are constructed by following the steps described in Event's constructor.
</p>

<p>
`error@m
取得子は、
初期化-時の値を返すモノトスル。
それは、
`SensorErrorEventInit$I を介して渡された `DOMException$I ~objを表現する。
◎
The error attribute must return the value it was initialized to.＼
It represents the DOMException object passed to SensorErrorEventInit.
</p>

		</section>
	</section>
	<section id="abstract-operations">
<h2 title="Abstract Operations">8. 抽象-演算</h2>

		<section id="initialize-a-sensor-object">
<h3 title="Initialize a sensor object">8.1. ~sensor~objを初期化する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance, `SensorOptions$I 辞書~instance %~option群 )
に対し：
◎
input
• sensor_instance, a Sensor object.
• options, a SensorOptions dictionary instance.
output
• None
</p>
<ol>
	<li>
%~option群 を成す
~EACH( %~key → %値 )
に対し
⇒
~IF［
%~key ~NIN %~sensor~instance の型が`~supportする~sensor~option群$
］
⇒
~THROW `NotSupportedError$E
◎
For each key → value of options
• If the associated supported sensor options does not contain key
•• Throw "NotSupportedError" DOMException.
</li>
	<li>
%~frequency ~LET %~option群[ "`frequency$m" ]
◎
↓</li>
	<li>
<p>
~IF［
%~frequency ~NEQ ε
］
⇒
%~sensor~instance . `frequency$sl ~SET %~frequency
◎
If options["frequency"] exists, then
• Set sensor_instance.[[frequency]] to options["frequency"].
</p>

<p class="note">注記：
要請された `frequency$m を~UAが尊重できる保証は無い。
適用され得る拘束については、
`§ 標本化~frequency, 報告ng~frequency＠#concepts-sampling-and-reporting-frequencies$
を見よ。
◎
Note: There is no guarantee that the requested options["frequency"] can be respected. See § 5.4 Sampling Frequency and Reporting Frequency for constraints that may be applied.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="check-sensor-policy-controlled-features">
<h3 title="Check sensor policy-controlled features">8.2. ~sensor施策により制御される特能を検査する</h3>

<div class="algo">
<p>
所与の
( `~sensor型$ %~sensor型 )
に対し，真偽値を返す：
◎
input
• sensor_type, a sensor type.
output
• True if all of the associated sensor feature names are allowed to use, false otherwise.
</p>
<ol>
	<li>
%~sensor型 の`~sensor特能~名~群$を成す
~EACH( %特能~名 )
に対し
⇒
~IF［
`作動中な文書$bcには %特能~名 の`利用は許容されて$いない
］
⇒
~RET ~F
◎
Let feature_names be the sensor_type’s associated sensor feature names.
◎
For each feature_name of feature_names,
• If active document is not allowed to use the policy-controlled feature named feature_name, then:
•• Return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

		</section>
		<section id="connect-to-sensor">
<h3 title="Connect to sensor">8.3. ~sensorに接続する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor, `大域~obj$ %大域~obj )
に対し，［
%~sensor に ある`~platform~sensor$が結付けられるならば ~T ／
~ELSE_ ~F
］を返す：
◎
input
• sensor, a Sensor object.
• global, a global object.
output
• True if sensor was associated with a platform sensor, false otherwise.
</p>
<ol>
	<li>
%~platform~sensor ~LET ~NULL
◎
Let platformSensor be null.
</li>
	<li>
%~sensor型 ~LET %~sensor が`属する~sensor型$
◎
Let type be sensor’s associated sensor type.
</li>
	<li>
%~virtual~sensor型 ~LET %~sensor型【！%~sensor】 が`属する~virtual~sensor型$
◎
Let virtualSensorType be sensor’s associated virtual sensor type, or null if it is not set.
</li>
	<li>
%~virtual~sensor ~LET ε
◎
↓</li>
	<li>
~IF［
%~virtual~sensor型 ~NEQ ε【！~NULL】
］
⇒
%~virtual~sensor ~SET %大域~obj に`対応する~navigable$の`~top-level辿可能$navの`~virtual~sensor対応付け$[ %~virtual~sensor型 ]
◎
Let topLevelTraversable be global’s navigable's top-level traversable.
◎
↓</li>
	<li>
<p>
~IF［
%~virtual~sensor ~NEQ ε
］
⇒
~IF［
%~virtual~sensor の`読取りを供せるか$ ~EQ ~T
］
⇒
%~platform~sensor ~SET %~virtual~sensor に対応している`~platform~sensor$
◎
If virtualSensorType is not null and topLevelTraversable’s virtual sensor mapping contains virtualSensorType:
• Let virtualSensor be topLevelTraversable’s virtual sensor mapping[virtualSensorType].
• If virtualSensor’s can provide readings flag is true, set platformSensor to a platform sensor corresponding to virtualSensor.
</p>

<p class="note">注記：
`読取りを供せるか$ ~EQ ~F の場合、
%~platform~sensor は ~NULL であり続け，この~algoは ~F を返すことになる。
◎
• Note: If the can provide readings flag is false, platformSensor will remain null and this algorithm will return false.
</p>
	</li>
	<li>
~ELSE
⇒
%~platform~sensor ~LET 当の~deviceが備える［
%~sensor型 用の`~sensor読取り$を供せる`~device~sensor$たち
］の個数に応じて
⇒＃
0 個ならば ~NULL ／
1 個ならば その唯一の`~device~sensor$に対応する`~platform~sensor$／
複数個ならば %~sensor型 用の`既定の~sensor$は定義されて［いるならば それ／いなければ ~NULL］
◎
Otherwise:
• If the device has a single device sensor which can provide readings for type, then
•• Set platformSensor to a platform sensor corresponding to this device sensor.
• If the device has multiple device sensors which can provide readings for type, then
• If type has an associated default sensor, then
•• Set platformSensor to a platform sensor corresponding to this default device sensor.
</li>
	<li>
~IF［
%~platform~sensor ~EQ ~NULL
］
⇒
~RET ~F
◎
If platformSensor is null, return false.
</li>
	<li>
( %最小, %最大 ) ~LET `~platform~sensorの標本化~限界域を取得する$( %~platform~sensor )
◎
Let bounds be the result of invoking get a platform sensor’s sampling bounds with platformSensor.
</li>
	<li>
~IF［
%~sensor . `frequency$sl ~EQ ~NULL
］
⇒
%~sensor . `frequency$sl ~SET %~sensor型 に依存する`実装定義$な値
◎
If sensor.[[frequency]] is null, set it to an implementation-defined value dependent on type.
</li>
	<li>
~IF［
%~sensor . `frequency$sl ~LT %最小
］
⇒
%~sensor . `frequency$sl ~SET %最小
◎
If sensor.[[frequency]] is less than bounds[0], set it to bounds[0].
</li>
	<li>
~IF［
%~sensor . `frequency$sl ~GT %最大
］
⇒
%~sensor . `frequency$sl ~SET %最大
◎
If sensor.[[frequency]] is greater than bounds[1], set it to bounds[1].
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

		</section>
		<section id="activate-a-sensor-object">
<h3 title="Activate a sensor object">8.4. ~sensor~objを作動化する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance )
に対し：
◎
input
• sensor_instance, a Sensor object.
output
• None
</p>
<ol>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
%~sensor にて`作動化された~sensor~obj群$に %~sensor~instance を`付加する$set
◎
Append sensor_instance to sensor’s set of activated sensor objects.
</li>
	<li>
`~sensor設定群を設定する$( %~sensor )
◎
Invoke set sensor settings with sensor as argument.
</li>
	<li>
<p>
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`作動化d状態を通知する$( %~sensor~instance )
</div>
◎
Queue a task to run notify activated state with sensor_instance as an argument.
</li>
</ol>
</div>

		</section>
		<section id="deactivate-a-sensor-object">
<h3 title="Deactivate a sensor object">8.5. ~sensor~objを非作動化する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance )
に対し：
◎
input
• sensor_instance, a Sensor object.
output
• None
</p>
<ol>
	<li>
`~sensor~task~source$に結付けられた`~task~queue$から
%~sensor~instance に結付けられた すべての`~task$を除去する
◎
Remove all tasks associated with sensor_instance from the task queue associated with sensor task source.
</li>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
~IF［
%~sensor~instance ~NIN %~sensor にて`作動化された~sensor~obj群$
］
⇒
~RET
◎
If sensor’s set of activated sensor objects contains sensor_instance,
</li>
	<li>
%~sensor にて`作動化された~sensor~obj群$から %~sensor~instance を`除去する$
◎
Remove sensor_instance from sensor’s set of activated sensor objects.
</li>
	<li>
`~sensor設定群を設定する$( %~sensor )
◎
Invoke set sensor settings with sensor as argument.
</li>
	<li>
%~sensor~instance . `pendingReadingNotification$sl ~SET ~F
◎
Set sensor_instance.[[pendingReadingNotification]] to false.
</li>
	<li>
%~sensor~instance . `lastEventFiredAt$sl ~SET ~NULL
◎
Set sensor_instance.[[lastEventFiredAt]] to null.
</li>
</ol>
</div>

		</section>
		<section id="generic-sensor-permission-revocation-algorithm">
<h3 title="Generic Sensor permission revocation algorithm">8.6. 汎用~sensor許可~revocation~algo</h3>

<div class="algo">
<p>
所与の
( ある`強力な特能$を識別する`名前$ %許可~名 )
に対し：
◎
input
• permissionName, a powerful feature name
output
• None
</p>
<ol>
	<li>
<p>
`現在の~realm$に属する 
~EACH( `Sensor$I ~instance %~sensor )
に対し：
◎
For each Sensor instance sensor in the current realm:
</p>
		<ol>
			<li>
~IF［
%~sensor . `state$sl ~EQ `idle^l
］
⇒
~CONTINUE
◎
If sensor.[[state]] is "idle", then continue.
</li>
			<li>
<p>
~IF［
%許可~名 ~IN %~sensor の`~sensor型$の`~sensor許可~名~群$
］：
◎
If sensor’s sensor type's sensor permission names contains permissionName:
</p>
				<ol>
					<li>
`~sensor~objを非作動化する$( %~sensor )
◎
Invoke deactivate a sensor object with sensor.
</li>
					<li>
%例外 ~LET `例外を作成する$( `NotAllowedError$E )
◎
Let exception be the result of creating a "NotAllowedError" DOMException.
</li>
					<li>
<p>
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~errorを通知する$( %~sensor, %例外 )
</div>
◎
Queue a task to run notify error with sensor and exception.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="set-sensor-settings">
<h3 title="Set sensor settings">8.7. ~sensor設定群を設定する</h3>

<div class="algo">
<p>
所与の
( `~platform~sensor$ %~platform~sensor )
に対し：
◎
input
• platformSensor, a platform sensor.
output
• None
</p>
<ol>
	<li>
<p>
~IF［
%~platform~sensor にて`作動化された~sensor~obj群$は`空$である
］：
◎
If platformSensor’s set of activated sensor objects is empty,
</p>
		<ol>
			<li>
%~platform~sensor の`標本化~frequency$ ~SET ~NULL
◎
Set platformSensor’s sampling frequency to null.
</li>
			<li>
%~platform~sensor の`最新な読取り~map$を成す
~EACH( %~key → %値 )
に対し
⇒
%~platform~sensor の`最新な読取り~map$[ %~key ] ~SET ~NULL
◎
For each key → value of platformSensor’s latest reading.
• Set platformSensor’s latest reading[key] to null.
</li>
			<li>
`実装定義$な仕方で更新する
`in which^en
［
`~sensor読取り$は %~platform~sensor から得される
］から［
`~sensor読取り$をもはや供さない
］へ【？】
◎
Update the implementation-defined way in which sensor readings are obtained from platformSensor to no longer provide readings.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%~platform~sensor の`標本化~frequency$ ~SET ［
%~platform~sensor にて`作動化された~sensor~obj群$を成す各~itemの `frequency$sl 値
］に基づく`実装定義$な値
◎
Set platformSensor’s sampling frequency to an implementation-defined value based on the [[frequency]] values of the items in its activated sensor objects set.
</li>
	<li>
( %最小, %最大 ) ~LET `~platform~sensorの標本化~限界域を取得する$( %~platform~sensor )
◎
Let bounds be the result of invoking get a platform sensor’s sampling bounds with platformSensor.
</li>
	<li>
~Assert：
%最小 ~LTE %~platform~sensor の`標本化~frequency$ ~LTE %最大
◎
Assert: platformSensor’s sampling frequency is greater than or equal to bounds[0] and less than or equal to bounds[1].
</li>
</ol>
</div>

		</section>
		<section id="update-latest-reading">
<h3 title="Update latest reading">8.8. 最新な読取りを更新する</h3>

<div class="algo">
<p>
所与の
( `~platform~sensor$ %~sensor, `~sensor読取り$ %読取り )
に対し：
◎
input
• sensor, a platform sensor.
• reading, a sensor reading.
output
• None
</p>
<ol>
	<li>
%検査~algo ~LET %~sensor が`属する~sensor型$の`~threshold検査~algo$
◎
Let type be sensor’s associated sensor type.
</li>
	<li>
~IF［
%検査~algo ~NEQ ε
］~AND［
%検査~algo( %読取り, %~sensor の`最新な読取り~map$ ) ~EQ ~F
］
⇒
~RET
◎
If type’s threshold check algorithm is defined, then:
• Let result be the result of invoking type’s threshold check algorithm with reading and sensor’s latest reading.
• If result is false, then abort these steps.
</li>
	<li>
%時刻印 ~LET %読取り[ `timestamp^l ]
◎
↓</li>
	<li>
<p>
~IF［
%時刻印 ~NEQ ε
］：
◎
If reading["timestamp"] exists:
</p>
		<ol>
			<li>
<p>
%読取り[ `timestamp^l ] ~SET %時刻印 を`実装定義$な仕方で［
【この手続きを呼出した環境の】
`時刻~起点$enVたちにより共有される同じ`単調増加~時計$の`安全でない現在の時刻$1
］へ変換した結果
◎
Set reading["timestamp"] to the result of converting its current value in an implementation-defined way to an unsafe current time using the same monotonic clock that is shared by time origins.
</p>

<p class="note">注記：
この段の目標は、
%時刻印 が異なる時刻~起点に相対的であった場合でも，［
`HR-TIME$r にて述べられる演算により利用されるものと同じ`単調増加~時計$
］で算出に利用できる値へ変換されることを確保することにある。
◎
Note: The goal of this step is to ensure that a timestamp that may have been relative to a different time origin is converted to a value that can be used in computations with the same monotonic clock used by the operations described in [HR-TIME].
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
%読取り[ `timestamp^l ] ~SET `安全でない共有される現在の時刻$
◎
Otherwise, set reading["timestamp"] to the unsafe shared current time.
</p>

<p class="note">注記：
どちらの事例でも、
`安全でない現在の時刻$1は，~scriptには公開されない。
`Sensor$I の `timestamp$m は、
常に，`時刻~起点$enVに相対的な`粗化した~moment$を返す。
◎
Note: In neither case is an unsafe current time ever exposed to script. Sensor.timestamp always returns a coarsened moment relative to a time origin.
</p>
	</li>
	<li>
`最新な読取り~map$を成す
~EACH( %~key → %値 )
に対し
⇒
`最新な読取り~map$[ %~key ] ~SET %読取り を成す対応する値
◎
For each key → value of latest reading.
• Set latest reading[key] to the corresponding value of reading.
</li>
	<li>
%作動化された~sensor群 ~LET %~sensor にて`作動化された~sensor~obj群$
◎
Let activated_sensors be sensor’s associated set of activated sensor objects.
</li>
	<li>
この段は`並列的$に走らす
⇒
%作動化された~sensor群 を成す
~EACH( %s )
に対し
⇒
`最新な読取り更新を報告する$( %s )
◎
Run these sub-steps in parallel:
• For each s in activated_sensors,
•• Invoke report latest reading updated with s as an argument.
</li>
</ol>
</div>

		</section>
		<section id="report-latest-reading-updated">
<h3 title="Report latest reading updated">8.9. 最新な読取り更新を報告する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance )
に対し：
◎
input
• sensor_instance, a Sensor object.
output
• None
</p>
<ol>
	<li>
~IF［
%~sensor~instance . `pendingReadingNotification$sl ~EQ ~T
］
⇒
~RET
◎
If sensor_instance.[[pendingReadingNotification]] is true,
• Return.
</li>
	<li>
%~sensor~instance . `pendingReadingNotification$sl ~SET ~T
◎
Set sensor_instance.[[pendingReadingNotification]] to true.
</li>
	<li>
%最後に報告された時刻印 ~LET %~sensor~instance . `lastEventFiredAt$sl
◎
Let lastReportedTimestamp be the value of sensor_instance.[[lastEventFiredAt]].
</li>
	<li>
<p>
~IF［
%最後に報告された時刻印 ~EQ ~NULL【！is not set】
］
⇒
◎
If lastReportedTimestamp is not set
</p>
		<ol>
			<li>
<p>
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`新たな読取りを通知する$( %~sensor~instance )
</div>
◎
Queue a task to run notify new reading with sensor_instance as an argument.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%~frequency ~LET %~sensor~instance . `frequency$sl
◎
↓</li>
	<li>
~Assert：
［
%~frequency ~NEQ ~NULL
］~AND［
%~frequency ~GT 0
］
◎
Assert: sensor_instance.[[frequency]] is not null.
◎
Assert: sensor_instance.[[frequency]] is greater than 0.
</li>
	<li>
%報告ng間隔 ~LET 1 ~DIV %~frequency
◎
Let reportingInterval be the result of 1 / sensor_instance.[[frequency]].
</li>
	<li>
%時刻印~差分 ~LET `最新な読取り~map$[ `timestamp^l ] ~MINUS %最後に報告された時刻印
◎
Let timestampDelta be the result of latest reading["timestamp"] - lastReportedTimestamp.
</li>
	<li>
<p>
~IF［
%時刻印~差分 ~GTE %報告ng間隔
］
⇒
◎
If timestampDelta is greater than or equal to reportingInterval
</p>
		<ol>
			<li>
<p>
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`新たな読取りを通知する$( %~sensor~instance )
</div>
◎
Queue a task to run notify new reading with sensor_instance as an argument.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
( %報告ng間隔 ~MINUS %時刻印~差分 )
を~~経過するまで`~event~loopを回す$
◎
Let deferUpdateTime be the result of reportingInterval - timestampDelta.
◎
Spin the event loop for a period of time equal to deferUpdateTime.
</li>
	<li>
<p>
~IF［
%~sensor~instance . `pendingReadingNotification$sl ~EQ ~T
］
⇒
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`新たな読取りを通知する$( %~sensor~instance )
</div>
◎
If sensor_instance.[[pendingReadingNotification]] is true,
• Queue a task to run notify new reading with sensor_instance as an argument.
</li>
</ol>
</div>

		</section>
		<section id="notify-new-reading">
<h3 title="Notify new reading">8.10. 新たな読取りを通知する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance )
に対し：
◎
input
• sensor_instance, a Sensor object.
output
• None
</p>
<ol>
	<li>
%~sensor~instance . `pendingReadingNotification$sl ~SET ~F
◎
Set sensor_instance.[[pendingReadingNotification]] to false.
</li>
	<li>
%~sensor~instance . `lastEventFiredAt$sl ~SET `最新な読取り~map$[ `timestamp^l ]
◎
Set sensor_instance.[[lastEventFiredAt]] to latest reading["timestamp"].
</li>
	<li>
`~eventを発火する$( %~sensor~instance, `reading$et )
◎
Fire an event named "reading" at sensor_instance.
</li>
</ol>
</div>

		</section>
		<section id="notify-activated-state">
<h3 title="Notify activated state">8.11. 作動化d状態を通知する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance )
に対し：
◎
input
• sensor_instance, a Sensor object.
output
• None
</p>
<ol>
	<li>
%~sensor~instance . `state$sl ~SET `activated^l
◎
Set sensor_instance.[[state]] to "activated".
</li>
	<li>
`~eventを発火する$( %~sensor~instance, `activate$et )
◎
Fire an event named "activate" at sensor_instance.
</li>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
<p>
~IF［
%~sensor の`最新な読取り~map$[ `timestamp^l ] ~NEQ ~NULL
］
⇒
`~taskを~queueする$( `~sensor~task~source$, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`新たな読取りを通知する$( %~sensor~instance )
</div>
◎
If sensor’s latest reading["timestamp"] is not null,
• Queue a task to run notify new reading with sensor_instance as an argument.
</li>
</ol>
</div>

		</section>
		<section id="notify-error">
<h3 title="Notify error">8.12. ~errorを通知する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance, `DOMException$I %~error )
に対し：
◎
input
• sensor_instance, a Sensor object.
• error, a DOMException.
output
• None
</p>
<ol>
	<li>
%~sensor~instance . `state$sl ~SET `idle^l
◎
Set sensor_instance.[[state]] to "idle".
</li>
	<li>
`~eventを発火する$( %~sensor~instance, `error$et, `SensorErrorEvent$I )
— 次のように初期化して
⇒
`error$m 属性 ~SET %~error
◎
Fire an event named "error" at sensor_instance using SensorErrorEvent with its error attribute initialized to error.
</li>
</ol>
</div>

		</section>
		<section id="get-value-from-latest-reading">
<h3 title="Get value from latest reading">8.13. 最新な読取りから値を取得する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance, `文字列$ %~key )
に対し，［
`~sensor読取り$値／~NULL
］を返す：
◎
input
• sensor_instance, a Sensor object.
key, a string representing the name of the value.
output
• A sensor reading value or null.
<p>
<ol>
	<li>
<p>
~IF［
%~sensor~instance . `state$sl ~EQ `activated^l
］
⇒
◎
If sensor_instance.[[state]] is "activated",
</p>
		<ol>
			<li>
%~platform~sensor ~LET %~sensor~instance に結付けられた`~platform~sensor$
◎
↓</li>
			<li>
%読取り~map ~LET %~platform~sensor の`最新な読取り~map$
◎
Let readings be the latest reading of sensor_instance’s related platform sensor.
</li>
			<li>
%量子化~algo ~LET %~platform~sensor が`属する~sensor型$の`読取り量子化~algo$
◎
Let type be sensor_instance’s associated sensor type.
</li>
			<li>
~IF［
%量子化~algo ~NEQ ε
］
⇒
%読取り~map ~SET %量子化~algo( %読取り~map )
◎
If type’s reading quantization algorithm is defined, then:
• Set readings to the result of invoking type’s reading quantization algorithm with readings.
</li>
			<li>
~IF［
%~sensor~instance には、
ある`拡張~仕様$により`局所~座標系$ %座標系 が定義されている
］
⇒
%読取り~map を成す各~値を %座標系 内の値に変形する
（ `COORDINATES-TRANSFORMATION$r を見よ）
◎
If the extension specification defines a local coordinate system for sensor_instance,
• Remap (see [COORDINATES-TRANSFORMATION]) readings values to the local coordinate system.
</li>
			<li>
~RET %読取り~map[ %~key ]
◎
Return readings[key].
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET ~NULL
◎
Otherwise, return null.
</li>
</ol>
</div>

		</section>
		<section id="request-sensor-access">
<h3 title="Request sensor access">8.14. ~sensor~accessを要請する</h3>

<div class="algo">
<p>
所与の
( `Sensor$I ~obj %~sensor~instance )
に対し，`許可~状態$を返す：
◎
input
• sensor_instance, a Sensor object.
output
• A permission state.
</p>
<ol>
	<li>
~Assert：
この~algoは`並列的$に走っている。
【この段は、この訳による補完】
</li>
	<li>
%~sensor ~LET %~sensor~instance の`~platform~sensor$
◎
Let sensor be the platform sensor associated with sensor_instance.
</li>
	<li>
%~sensor の`~sensor許可~名~群$を成す
~EACH( %許可~名 )
に対し
⇒
~IF［
`利用する許可を要請する$( %許可~名 ) ~EQ `denied^l
］
⇒
~RET `denied^l
◎
Let sensor_permissions be sensor’s associated set of permission names.
◎
For each permission_name in sensor_permissions,
• Let state be the result of requesting permission to use permission_name.
• If state is "denied"
•• Return "denied".
</li>
	<li>
~RET `granted^l
◎
Return "granted".
</li>
</ol>
</div>

		</section>
	</section>
	<section id="automation">
<h2 title="Automation">9. 自動化</h2>

<p>
汎用~sensor~API, その`拡張~仕様$は、
作者に難題を~~課す
— それらの~interfaceを全部的に行使するためには、
予測-可能な仕方で応答する物理的な~hardware~deviceが要るので。
この難題に取組むため、
この文書は，［
`~device~sensor$の様に挙動する`~virtual~sensor$を定義して制御する
］ことを許容する いくつかの `WEBDRIVER2$r `拡張~command$を定義する。
これらの`~virtual~sensor$は、
特定0の~propを伴う~deviceを表現し，
その読取りは利用者【作者】がまるごと定義できる。
◎
The Generic Sensor API and its extension specifications pose a challenge to test authors, as fully exercising those interfaces requires physical hardware devices that respond in predictable ways. To address this challenge this document defines a number of [WEBDRIVER2] extension commands that allow defining and controlling virtual sensors that behave like device sensors. These virtual sensors represent devices with particular properties and whose readings can be entirely defined by users.
</p>

		<section id="virtual-sensors">
<h3 title="Virtual Sensors">9.1. ~virtual~sensor</h3>

<p>
`~virtual~sensor@
（ `virtual sensor^en ）は、
`~device~sensor$の挙動を制御された仕方で模倣する。
それは、
それに接続された`~platform~sensor$たちが在れば，それらへ`~sensor読取り$を報告する。
◎
A virtual sensor simulates the behavior of a device sensor in controlled ways. It reports sensor readings to zero or more platform sensors connected to it.
</p>

<p>
`~virtual~sensor$には、
次に挙げる~dataが結付けられる：
◎
A virtual sensor has the following associated data:
</p>

<ul>
	<li>
`読取りを供せるか@vS
（ `can provide readings flag^en ）
⇒
`真偽値$
◎
A can provide readings flag (a boolean).
</li>
	<li>
<p>
`要請された標本化~frequency@vS
（ `requested sampling frequency^en ）
⇒
`有限な数$【！number】
◎
A requested sampling frequency (a number).＼
</p>

<p>
これは、
定例の`~device~sensor$の実際の標本化~frequencyと同じく不透明な，`実装定義$な値であり、［
`最小~標本化~frequency$vS,
`最大~標本化~frequency$vS
］により設定された限界域の中にある。
当の`~virtual~sensor$が どの`~platform~sensor$にも読取りを供していない場合、
0 になる。
◎
Just like a regular device sensor's actual sampling frequency is opaque, a virtual sensor's requested sampling frequency is an implementation-defined value that lies within the bounds set by the minimum sampling frequency and the maximum sampling frequency. If a virtual sensor is not providing readings to any platform sensor, its requested sampling frequency is 0.
</p>

<p class="note">注記：
`要請された標本化~frequency$vSの値は、
とりわけ，それに接続された`~platform~sensor$が［
ある種の標本化~frequencyを要請したかどうか
（`~platform~sensor$ごとに相違するかもしれない）や，
当の`~virtual~sensor$を~pollしているかどうか
］に依存する
— 後者の事例では、
標本化~frequencyは，まったく要請されないかもしれない。
◎
Note: Requested sampling frequency's value depends, among other things, on whether connected platform sensors have requested a certain sampling frequency (which might differ per platform sensor), or whether they are polling the virtual sensor, in which case no sampling frequency might have been requested at all.
</p>
	</li>
	<li>
<p>
`最小~標本化~frequency@vS
（ `minimum sampling frequency^en ）
⇒
`有限な数$【！number】
◎
A minimum sampling frequency (a number).＼
</p>

<p>
`~virtual~sensor$は`~device~sensor$でもあるので、
これは，`~device~sensor$の`最小~標本化~frequency$dVに対応する。
◎
A virtual sensor is a device sensor, so this corresponds to the device sensor's minimum sampling frequency.
</p>
	</li>
	<li>
<p>
`最大~標本化~frequency@vS
（ `maximum sampling frequency^en ）
⇒
`有限な数$【！number】
◎
A maximum sampling frequency (a number). ＼
</p>
<p>
`~virtual~sensor$は`~device~sensor$でもあるので、
これは，`~device~sensor$の`最大~標本化~frequency$dVに対応する。
◎
A virtual sensor is a device sensor, so this corresponds to the device sensor's maximum sampling frequency.
</p>
	</li>
</ul>

<p>
`~virtual~sensor型@
（ `virtual sensor type^en ）は、
所与の型の~sensorを表現する`文字列$である。
◎
A virtual sensor type is a string that represents a sensor of a given type.
</p>

<p>
`型ごとの~virtual~sensor~metadata@
（ `per-type virtual sensor metadata^en ）は、
`~virtual~sensor型$から`~virtual~sensor~metadata$への`有順序~map$であり，
初期~時は空とする。
`拡張~仕様$は、
この`~map$内に［
自身が定義する`~sensor型$に対応する 1 個以上の~entry
］を定義するベキである。
◎
The per-type virtual sensor metadata is an ordered map of virtual sensor types to virtual sensor metadata. It is initially empty, and extension specifications should define one or more entries in the map corresponding to the sensor types they define.
</p>

<p>
`~virtual~sensor~metadata@
（ `virtual sensor metadata^en ）は、
次に挙げる`~item$sctからなる`構造体$である：
◎
A virtual sensor metadata is a struct whose items are:
</p>
<ul>
	<li>
`読取り構文解析~algo@vsM
（ `reading parsing algorithm^en ）
⇒
ある~algo
— 所与の~JSON `Object$jt に対し，［
`~sensor読取り$／ `undefined^jv
］を返す。
◎
reading parsing algorithm
• An algorithm that takes a JSON Object and returns a sensor reading or undefined.
</li>
</ul>

<p>
各`~top-level辿可能$は、
`~virtual~sensor対応付け@
（ `virtual sensor mapping^en ）
を有する
— それは、
`~virtual~sensor型$から`~virtual~sensor$への`有順序~map$である。
◎
Each top-level traversable has a virtual sensor mapping, which is an ordered map of virtual sensor types to virtual sensor.
</p>

<p class="note">注記：
`~virtual~sensor対応付け$【！`構造体$】は、
所与の型に属するすべての`~virtual~sensor$に共通な~dataを包含する。
`~virtual~sensor$は、
`~virtual~sensor$を［
作成する／用立てる
］にあたって変わり得る~dataを包含する。
◎
Note: The virtual sensor mapping struct contains data that is common to all virtual sensors of a given type. A virtual sensor contains data that can vary on virtual sensor creation and utilization.
</p>

<p class="note">注記：
`~virtual~sensor対応付け$は、
`~navigable$ではなく`~top-level辿可能$に束ねられる
— 所与の`~sensor型$を伴う`~platform~sensor$は、
どの`~navigable$においても，その`~top-level辿可能$navが同じなら同じ`~virtual~sensor$へ接続することが想定されるので。
これは、
現実における挙動
— 同じ~hardware~sensor（または融合~sensor）が異なる`~navigable$たちへ読取りを供する —
をより良く真似る。
◎
Note: Virtual sensor mappings are tied to top-level traversables rather than any navigable because platform sensors with a given sensor type in all navigables with the same top-level traversable are supposed to connect to the same virtual sensor. This better mimics real-world behavior, where the same hardware (or fusion) sensor provides readings to different navigables.
</p>

<p class="note">注記：
この挙動は、
`web-platform-tests＠https://web-platform-tests.org$
を通して，この仕様の~test法を追加的に援助する
— `testdriver.js を介した~WebDriver通信は、すべて test harness を包含している~frameを通う＠https://web-platform-tests.org/writing-tests/testdriver.html#using-test-driver-in-other-browsing-contexts$
ので。
◎
Note: This behavior additionally aids testing of this specification through web-platform-tests, as all WebDriver communication via testdriver.js goes through the frame containing the test harness.
</p>

		</section>
		<section id="section-extension-commands">
<h3 title="Extension Commands">9.2. 拡張~command</h3>

<p class="trans-note">【
この訳では、
この節に利用される `WEBDRIVER$r その他の用語に以下に挙げる表記を用いる：
】</p>

<dl>
	<dt>
`~error@wdr( %~code )
</dt>
	<dd>
`~WebDriver~error~code$ %~code を伴う`~WebDriver~error$
</dd>

	<dt>
`成功@wdr( %~data )
</dt>
	<dd>
~data~fieldに %~data を伴う`成功$
</dd>
</dl>

<p>
所与の %値 が
`有限な数@
であるとは、
次が満たされることをいう
⇒
［
%値 は `Number$jt である
］~AND［
%値 ~NIN { `NaN^jv, `+∞^jv, `−∞^jv }
］
</p>

			<section id="create-virtual-sensor-command">
<h4 title="Create virtual sensor">9.2.1. ~virtual~sensorを作成する</h4>

<div>
<table><thead>
<tr><th>~HTTP~method
<th>`~URI~template$
<tbody>

<tr><td>`POST^hm
<td>`/session/{session id}/sensor^c
</table>
◎
HTTP Method 	URI Template
POST 	/session/{session id}/sensor
</div>

<p>
この`拡張~command$は、
ある種の`~sensor型$を成す新たな`~virtual~sensor$を作成する。
同じ`~sensor型$の各 `Sensor$I ~instanceに対する `start()$m ~callは、
`~virtual~sensorを削除する~command＠#delete-virtual-sensor-command$が走るまで，
それらを~backしている`~device~sensor$として，この`~virtual~sensor$を利用させることになる。
◎
This extension command creates a new virtual sensor of a certain sensor type. Calls to Sensor.start() from Sensor instances of the same sensor type will cause this virtual sensor to be used as their backing device sensor until § 9.2.4 Delete virtual sensor is run.
</p>

<p class="note">注記：
この`拡張~command$は、［
同じ型の `Sensor$I ~instanceたちが共存しつつ，
各自が異なる`~device~sensor$を有する
］ことを許容する仕方で働く。
そのような~instanceは、
この`拡張~command$が呼出される前に作成され，
本物の~hardware~sensorに接続-済みなこともある
— それは、
働き続け，そこから読取りを受信することに加え、
`~sensorに接続する$が再び呼出された場合に限り，`~virtual~sensor$から読取りを受信する。
◎
Note: The way this extension command works allows Sensor instances of the same type to coexist and have different device sensors. A Sensor sensor may have been created and connected to a real, hardware sensor before this extension command is invoked. It continues to work and receive readings from it, and only receives readings from a virtual sensor if connect to sensor is invoked again.
</p>

<div>
<table>
<caption>
この~algoが利用する引数 %~parameter群 の~prop
</caption>

<thead>
<tr><th>~parameter名
<th>値~型
<th>要求されるか
<tbody>

<tr><td>`type^l
<td>`String$jt
<td>Yes

<tr><td>`connected^l
<td>`Boolean$jt
<td>No

<tr><td>`maxSamplingFrequency^l
<td>`Number$jt
<td>No

<tr><td>`minSamplingFrequency^l
<td>`Number$jt
<td>No
</table>

◎
Properties of the parameters argument used by this algorithm
Parameter name 	Value type 	Required
"type" 	String 	Yes
"connected" 	Boolean 	No
"maxSamplingFrequency" 	Number 	No
"minSamplingFrequency" 	Number 	No
</div>

<div class="algo">
<p>
`~remote端~手続き$は：
◎
The remote end steps are:
</p>
<ol>
	<li>
%~virtual~sensor型 ~LET %~parameter群 から`~propを取得する$( `type^l )
◎
Let virtualSensorType be the result of invoking get a property "type" from parameters.
</li>
	<li>
~IF［
%~virtual~sensor型 は `String$jt でない
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If virtualSensorType is not a String, return error with WebDriver error code invalid argument.
</li>
	<li>
~IF［
`型ごとの~virtual~sensor~metadata$[ %~virtual~sensor型 ] ~EQ ε
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If per-type virtual sensor metadata does not contain virtualSensorType, return error with WebDriver error code invalid argument.
</li>
	<li>
~IF［
`現在の閲覧~文脈$の`~top-level辿可能$bcの`~virtual~sensor対応付け$[ %~virtual~sensor型 ] ~NEQ ε
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
Let topLevelVirtualSensorMapping be the current browsing context's top-level traversable's virtual sensor mapping.
◎
If topLevelVirtualSensorMapping contains virtualSensorType, return error with WebDriver error code invalid argument.
</li>
	<li>
%接続されたか ~LET %~parameter群 から`既定を伴う~propを取得する$( `connected^l , ~T )
◎
Let connected be the result of invoking get a property with default with "connected" and true from parameters.
</li>
	<li>
%最大~標本化~frequency ~LET %~parameter群 から`既定を伴う~propを取得する$( `maxSamplingFrequency^l, `実装定義$な値 )
◎
Let maxSamplingFrequency be the result of invoking get a property with default with "maxSamplingFrequency" and an implementation-defined value from parameters.
</li>
	<li>
~IF［
%最大~標本化~frequency は`有限な数$でない
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If maxSamplingFrequency is not a Number, or its value is NaN, +∞, or −∞, return error with WebDriver error code invalid argument.
</li>
	<li>
%最小~標本化~frequency ~LET %~parameter群 から`既定を伴う~propを取得する$( `minSamplingFrequency^l, `実装定義$な値 )
◎
Let minSamplingFrequency be the result of invoking get a property with default with "minSamplingFrequency" and an implementation-defined value from parameters.
</li>
	<li>
~IF［
%最小~標本化~frequency は`有限な数$でない
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If minSamplingFrequency is not a Number, or its value is NaN, +∞, or −∞, return error with WebDriver error code invalid argument.
</li>
	<li>
~IF［
%最小~標本化~frequency ~GT %最大~標本化~frequency
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If minSamplingFrequency is greater than maxSamplingFrequency, return error with WebDriver error code invalid argument.
</li>
	<li>
%~virtual~sensor ~LET 新たな`~virtual~sensor$
— その
⇒＃
`読取りを供せるか$vS ~SET %接続されたか,
`最小~標本化~frequency$vS ~SET %最小~標本化~frequency,
`最大~標本化~frequency$vS ~SET %最大~標本化~frequency
◎
Let virtualSensor be a new virtual sensor.
◎
Set virtualSensor’s can provide readings flag to connected.
◎
Set virtualSensor’s minimum sampling frequency to minSamplingFrequency.
◎
Set virtualSensor’s maximum sampling frequency to maxSamplingFrequency.
</li>
	<li>
`現在の閲覧~文脈$の`~top-level辿可能$bcの`~virtual~sensor対応付け$[ %~virtual~sensor型 ] ~SET %~virtual~sensor
◎
Set topLevelVirtualSensorMapping[virtualSensorType] to virtualSensor.
</li>
	<li>
~RET `成功$wdr( ~NULL )
◎
Return success with data null.
</li>
</ol>
</div>

<div class="example">
<p>
~ID 23 を伴う`~session$の`現在の閲覧~文脈$内に［
`ambient-light^l ~virtual~sensor
］を作成するためには、
`局所~端$は，次の本体を伴う
`/session/23/sensor^c
を `POST^hm することになる：
◎
To create an "ambient-light" virtual sensor in the current browsing context of the session with ID 23, the local end would POST to /session/23/sensor with the body:
</p>

<pre class="lang-js">
{
  "type": "ambient-light",
  "maxSamplingFrequency": 60,
  "minSamplingFrequency": 5
}
</pre>

<p>
所与の`~sensor型$に対し，`~top-level辿可能$内で作成できる`~virtual~sensor$は、
1 個までに限られることを自覚すること
— さもなければ `~error$wdr( `無効な引数$i ) が返されることになる。
◎
Be aware that only one virtual sensor of a given sensor type can be created in a top-level traversable, otherwise an invalid argument WebDriver error code will be returned.
</p>
</div>

			</section>
			<section id="get-virtual-sensor-information-command">
<h4 title="Get virtual sensor information">9.2.2. ~virtual~sensor情報を取得する</h4>

<div>
<table><thead>
<tr><th>~HTTP~method
<th>`~URI~template$
<tbody>

<tr><td>`GET^hm
<td>`/session/{session id}/sensor/{type}^c
</table>

◎
HTTP Method 	URI Template
GET 	/session/{session id}/sensor/{type}
</div>

<p>
この`拡張~command$は、
所与の［
`~virtual~sensorを作成する~command＠#create-virtual-sensor-command$
により作成された`~virtual~sensor$
］についての情報を検索取得する。
◎
This extension command retrieves information about a given virtual sensor created by § 9.2.1 Create virtual sensor.
</p>

<p>
`成功$wdr( %報 )
が返された場合、
%報 は，次に挙げる~propを伴う `Object$jt になる：
◎
When it returns success, success's associated data is an Object with the following properties:
</p>

<div>
<table><thead>
<tr><th>~prop名
<th>値~型
<th>記述（規範的でない）
<tbody>

<tr><td>`requestedSamplingFrequency^l
<td>`Number$jt
<td>当の`~virtual~sensor$の`標本化~frequency$
</table>

◎
Property name 	Value type 	Description (non-normative)
"requestedSamplingFrequency" 	Number 	The virtual sensor's sampling frequency
</div>

<p class="note">注記：
`標本化~frequency$に対する拘束は
`§ 標本化~frequency, 報告ng~frequency＠#concepts-sampling-and-reporting-frequencies$
を見よ。
なぜ`要請された標本化~frequency$vSが`実装定義$な値になるかについての説明は
`§ ~virtual~sensor＠#virtual-sensors$
を見よ。
一般に，この値に関して安全に見做せることは、
`~virtual~sensor$の［
`最小~標本化~frequency$vS, `最大~標本化~frequency$vS
］により設定された限界域の中にあること以外にない。
◎
Note: See § 5.4 Sampling Frequency and Reporting Frequency for some constraints on sampling frequency as well as the explanation about why a requested sampling frequency is an implementation-defined value in § 9.1 Virtual Sensors. In general, it is only safe to assume that the value lies within the bounds set by the virtual sensor's minimum sampling frequency and maximum sampling frequency.
</p>

<div class="algo">
<p>
`~remote端~手続き$は：
◎
The remote end steps are:
</p>
<ol>
	<li>
%~virtual~sensor型 ~LET `type^c `~url変数$の値
◎
Let virtualSensorType be the value of the type url variable.
</li>
	<li>
%~virtual~sensor ~LET `現在の閲覧~文脈$の`~top-level辿可能$bcの`~virtual~sensor対応付け$[ %~virtual~sensor型 ]
◎
Let topLevelVirtualSensorMapping be the current browsing context's top-level traversable's virtual sensor mapping.
◎
↓</li>
	<li>
~IF［
%~virtual~sensor ~EQ ε
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If topLevelVirtualSensorMapping does not contain virtualSensorType, return error with WebDriver error code invalid argument.
◎
Let virtualSensor be topLevelVirtualSensorMapping[virtualSensorType].
</li>
	<li>
%報 ~LET 新たな `Object$jt
◎
Let info be a new Object.
</li>
	<li>
%報 の`~propを設定する$( `requestedSamplingFrequency^l, %~virtual~sensor の`要請された標本化~frequency$vS )
◎
Invoke set a property on info with "requestedSamplingFrequency" and virtualSensor’s requested sampling frequency.
</li>
	<li>
~RET `成功$wdr( %報 )
◎
Return success with data info.
</li>
</ol>
</div>

			</section>
			<section id="update-virtual-sensor-reading-command">
<h4 title="Update virtual sensor reading">9.2.3. ~virtual~sensor読取りを更新する</h4>

<div>
<table><thead>
<tr><th>~HTTP~method
<th>`~URI~template$
<tbody>

<tr><td>`POST^hm
<td>`/session/{session id}/sensor/{type}^c
</table>

◎
HTTP Method 	URI Template
POST 	/session/{session id}/sensor/{type}
</div>

<p>
この`拡張~command$は、
新たな`~sensor読取り$を`~platform~sensor$から可用にする。
◎
This extension command makes a new sensor reading available to platform sensors.
</p>

<p class="note">注記：
`~virtual~sensor$は`~device~sensor$の様に動作するので、
ここで生産される`~sensor読取り$であっても，`~platform~sensor$により処理される必要がある
— それは、
例えば［
`~sensor型$の`~threshold検査~algo$／
`~sensor読取りを公開できない＠#can-expose-sensor-readings$こと
］に因り，読取りを破棄するかもしれない。
◎
Note: A virtual sensor acts like a device sensor, so the sensor reading produced here still has to be processed by a platform sensor, which might discard it due to, for example, a sensor type's threshold check algorithm or can expose sensor readings's result.
</p>

<div>
<table>
<caption>
この~algoが利用する引数 %~parameter群 の~prop
</caption>
<thead>
<tr><th>~parameter名
<th>値~型
<th>要求されるか
<tbody>

<tr><td>`reading^l
<td>`Object$jt
<td>Yes
</table>

◎
Properties of the parameters argument used by this algorithm
Parameter name 	Value type 	Required
"reading" 	Object 	Yes
</div>

<div class="algo">
<p>
`~remote端~手続き$は：
◎
The remote end steps are:
</p>
<ol>
	<li>
%読取り ~LET %~parameter群 から`~propを取得する$( `reading^l )
◎
Let reading be the result of invoking get a property "reading" from parameters.
</li>
	<li>
~IF［
%読取り は `Object$jt でない
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If reading is not an Object, return error with WebDriver error code invalid argument.
</li>
	<li>
%~virtual~sensor型 ~LET `type^c `~url変数$の値
◎
Let virtualSensorType be the value of the type url variable.
</li>
	<li>
%~metadata ~LET `型ごとの~virtual~sensor~metadata$[ %~virtual~sensor型 ]
◎
↓</li>
	<li>
~IF［
%~metadata ~EQ ε
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If per-type virtual sensor metadata does not contain virtualSensorType, return error with WebDriver error code invalid argument.
◎
Let metadata be per-type virtual sensor metadata[virtualSensorType].
</li>
	<li>
%~virtual~sensor ~LET `現在の閲覧~文脈$の`~top-level辿可能$bcの`~virtual~sensor対応付け$[ %~virtual~sensor型 ]
◎
Let topLevelVirtualSensorMapping be the current browsing context's top-level traversable's virtual sensor mapping.
◎
↓</li>
	<li>
~IF［
%~virtual~sensor ~EQ ε
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If topLevelVirtualSensorMapping does not contain virtualSensorType, return error with WebDriver error code invalid argument.
◎
Let virtualSensor be topLevelVirtualSensorMapping[virtualSensorType].
</li>
	<li>
%構文解析した読取り ~LET %~metadata の`読取り構文解析~algo$vsM( %読取り )
◎
Let parsedReading be the result of invoking metadata’s reading parsing algorithm with reading.
</li>
	<li>
~IF［
%構文解析した読取り ~EQ `undefined^jv
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If parsedReading is undefined, return error with WebDriver error code invalid argument.
</li>
	<li>
%構文解析した読取り を［
%~virtual~sensor に接続された`~platform~sensor$から得せる
］よう，`実装定義$な仕方で可用にする
◎
In an implementation-defined way, make parsedReading available so that it can be obtained by platform sensors connected to virtualSensor.
</li>
	<li>
~RET `成功$wdr( ~NULL )
◎
Return success with data null.
</li>
</ol>
</div>

				<section id="algorithms-for-parsing-readings">
<h5 title="Algorithms for parsing readings">9.2.3.1. 読取りを構文解析する~algo</h5>

<p>
この仕様は、
`拡張~仕様$が［
`型ごとの~virtual~sensor~metadata$において利用するために`~virtual~sensor~metadata$を定義する
］ときに利用できる~algoをいくつか定義する。
◎
This specification defines some algorithms that extension specifications can use when defining a virtual sensor metadata for use in per-type virtual sensor metadata.
</p>

					<section id="parse-single-value-number-reading">
<h6 title="Parse single-value number reading">9.2.3.1.1. 一数の読取りを構文解析する</h6>

<div class="algo">
<p>
所与の
( ~JSON `Object$jt %~parameter群, `文字列$ %値の名前 )
に対し，［
`~sensor読取り$／ `undefined^jv
］を返す：
◎
input
• parameters, a JSON Object
• valueName, a string
output
• A sensor reading or undefined
</p>
<ol>
	<li>
%値 ~LET %~parameter群 から`~propを取得する$( %値の名前 )
◎
Let value be the result of invoking get a property from parameters with valueName.
</li>
	<li>
~IF［
%値 は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If value is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%読取り ~LET 新たな`~sensor読取り$
◎
Let reading be a new sensor reading.
</li>
	<li>
%読取り[ %値の名前 ] ~SET %値
◎
Set reading[valueName] to value.
</li>
	<li>
~RET %読取り
◎
Return reading.
</li>
</ol>
</div>

					</section>
					<section id="parse-xyz-reading">
<h6 title="Parse XYZ reading">9.2.3.1.2. ~xyzの読取りを構文解析する</h6>

<div class="algo">
<p>
所与の
( ~JSON `Object$jt %~parameter群 )
に対し，［
`~sensor読取り$／ `undefined^jv
］を返す：
◎
input
• parameters, a JSON Object
output
• A sensor reading or undefined
</p>

<ol>
	<li>
%x ~LET %~parameter群 から`~propを取得する$( `x^l )
◎
Let x be the result of invoking get a property from parameters with "x".
</li>
	<li>
~IF［
%x は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If x is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%y ~LET %~parameter群 から`~propを取得する$( `y^l )
◎
Let y be the result of invoking get a property from parameters with "y".
</li>
	<li>
~IF［
%y は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If y is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%z ~LET %~parameter群 から`~propを取得する$( `z^l )
◎
Let z be the result of invoking get a property from parameters with "z".
</li>
	<li>
~IF［
%z は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If z is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%読取り ~LET 新たな`~sensor読取り$
◎
Let reading be a new sensor reading.
</li>
	<li>
%読取り[ `x^l ] ~SET %x
◎
Set reading["x"] to x.
</li>
	<li>
%読取り[ `y^l ] ~SET %y
◎
Set reading["y"] to y.
</li>
	<li>
%読取り[ `z^l ] ~SET %z
◎
Set reading["z"] to z.
</li>
	<li>
~RET %読取り
◎
Return reading.
</li>
</ol>
</div>

					</section>
					<section id="parse-quaternion-reading">
<h6 title="Parse quaternion reading">9.2.3.1.3. 四元数の読取りを構文解析する</h6>

<div class="algo">
<p>
所与の
( ~JSON `Object$jt %~parameter群 )
に対し，［
`~sensor読取り$／ `undefined^jv
］を返す：
◎
input
• parameters, a JSON Object
output
• A sensor reading or undefined
</p>
<ol>
	<li>
%四元数~配列 ~LET %~parameter群 から`~propを取得する$( `quaternion^l )
◎
Let quaternionArray be the result of invoking get a property from parameters with "quaternion".
</li>
	<li>
~IF［
%四元数~配列 は `Array$jt でない
］~OR［
%四元数~配列 の `length^l ~prop ~NEQ 4
］
⇒
~RET `undefined^jv
◎
If quaternionArray is not an Array, or if its "length" property is not 4, return undefined.
</li>
	<li>
%x ~LET %四元数~配列 から`~propを取得する$( 0 )
◎
Let x be the result of invoking get a property from quaternionArray with 0.
</li>
	<li>
~IF［
%x は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If x is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%y ~LET %四元数~配列 から`~propを取得する$( 1 )
◎
Let y be the result of invoking get a property from quaternionArray with 1.
</li>
	<li>
~IF［
%y は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If y is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%z ~LET %四元数~配列 から`~propを取得する$( 2 )
◎
Let z be the result of invoking get a property from quaternionArray with 2.
</li>
	<li>
~IF［
%z は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If z is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%w ~LET %四元数~配列 から`~propを取得する$( 3 )
◎
Let w be the result of invoking get a property from quaternionArray with 3.
</li>
	<li>
~IF［
%w は`有限な数$でない
］
⇒
~RET `undefined^jv
◎
If w is not a Number, or its value is NaN, +∞, or −∞, return undefined.
</li>
	<li>
%読取り ~LET 新たな`~sensor読取り$
◎
Let reading be a new sensor reading.
</li>
	<li>
%読取り[ `quaternion^l ] ~SET « %x, %y, %z, %w »
◎
Set reading["quaternion"] be the list « x, y, z, w ».
</li>
	<li>
~RET %読取り
◎
Return reading.
</li>
</ol>
</div>

					</section>
				</section>
			</section>
			<section id="delete-virtual-sensor-command">
<h4 title="Delete virtual sensor">9.2.4. ~virtual~sensorを削除する</h4>

<div>
<table><thead>
<tr><th>~HTTP~method
<th>`~URI~template$
<tbody>

<tr><td>`DELETE^hm
<td>`/session/{session id}/sensor/{type}^c
</table>

◎
HTTP Method 	URI Template
DELETE 	/session/{session id}/sensor/{type}
</div>

<p>
この`拡張~command$は、
所与の型の`~virtual~sensor$を削除する。
◎
This extension command deletes a given type of virtual sensor.
</p>

<div class="algo">
<p>
`~remote端~手続き$は：
◎
The remote end steps are:
</p>
<ol>
	<li>
%~virtual~sensor型 ~LET `type^c `~url変数$の値
◎
Let virtualSensorType be the value of the type url variable.
</li>
	<li>
~IF［
`型ごとの~virtual~sensor~metadata$[ %~virtual~sensor型 ] ~EQ ε
］
⇒
~RET `~error$wdr( `無効な引数$i )
◎
If per-type virtual sensor metadata does not contain virtualSensorType, return error with WebDriver error code invalid argument.
</li>
	<li>
`現在の閲覧~文脈$の`~top-level辿可能$bcの`~virtual~sensor対応付け$[ %~virtual~sensor型 ] ~SET ε
◎
Let topLevelVirtualSensorMapping be the current browsing context's top-level traversable's virtual sensor mapping.
◎
Remove topLevelVirtualSensorMapping[virtualSensorType].
</li>
	<li>
~RET `成功$wdr( ~NULL )
◎
Return success with data null.
</li>
</ol>
</div>

<div class="note">
<p>注記：
利用-中にある`~device~sensor$が可用でなくなったとき
（例：物理的に切断された／~UAには無関係な要因に因り停止した）
における［
`~platform~sensor$／ `Sensor$I ~instance
］の挙動は指定されない。
実装は、
次に挙げるいずれを行なってもヨイ：
</p>
<ul>
	<li>
既存の `Sensor$I ~instanceをそのまま保つ
（それらは、
単純に，新たな読取り報告しなくなる）
</li>
	<li>
`~sensor~objを非作動化する$
</li>
	<li>
`~platform~sensor$に~errorを報告させる
— 最終的に`~errorを通知する$ことになるよう。
</li>
</ul>
◎
Note: The behavior of platform sensors and Sensor instances when a device sensor in use stops being available (e.g. it has been physically disconnected, or stopped due to a factor unrelated to the User Agent) is not specified. Implementations may, among other things, keep existing Sensor instances unchanged (they simply will not report new readings), deactivate a sensor object or cause the platform sensor to report an error that will ultimately result in notify error being invoked.
</div>

			</section>
		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">10. 拡張能</h2>

◎非規範的

<p class="note">注記：
この節（下位節も含む）は、
規範的な言語を利用して`拡張~仕様$の`作者~向け^emの指導を供する。
`実装者^emの視点からは、
この節は規範的でないと見なされる。
◎
Note: This section and its subsections provide guidance to extension specification authors using normative language. From implementers' point of view, this section and its subsections are considered non-normative.
</p>

<p>
この節は、
この仕様をどう拡張すれば，各種`~sensor型$用の~APIを指定できるかを述べる。
◎
This section describes how this specification can be extended to specify APIs for different sensor types.
</p>

<div>
<p>
そのような
`拡張~仕様@
（ `extension specification^en ）には、
次が奨励される：
<ul>
	<li>
単独の`~sensor型$に注力すること
</li>
	<li>
［
`高level$, `低level$
］どちらも適切に公開すること
</li>
	<li>
`~sensor読取り$に`較正$処理-を適用するかどうかを定義すること
</li>
</ul>
◎
Such extension specifications are encouraged to focus on a single sensor type, exposing both high and low level as appropriate.
◎
Extension specifications are encouraged to define whether a calibration process applies to sensor readings.
</div>

<p>
`拡張~仕様$は、
結付けられた`~sensor型$に対し，`局所~座標系$を［
明示的に定義してもヨイ／
`Sensor$I ~objごとに環境設定-可能にしてもヨイ
］。
◎
Extension specifications may explicitly define the local coordinate system for the associated sensor type or make it configurable per Sensor object.
</p>

<p>
`拡張~仕様$たちが成す~~最新な~listは、
次に挙げる文書を見られたし
⇒＃
`GENERIC-SENSOR-USECASES$r,
`MOTION-SENSORS$r
◎
For an up-to-date list of extension specifications, please refer to [GENERIC-SENSOR-USECASES] and [MOTION-SENSORS] documents.
</p>

		<section id="extension-security-and-privacy">
<h3 title="Security and Privacy">10.1. ~securityと~privacy</h3>

<p>
`拡張~仕様$には、
次が期待される：
◎
Extension specifications are expected to:
</p>

<ul>
	<li>
汎用な`軽減~策＠#mitigation-strategies$に適合すること
◎
conform with the generic mitigation strategies,
</li>
	<li>
`事例~別に適用される軽減~策＠#mitigation-strategies-case-by-case$
を考慮すること
◎
consider mitigation strategies applied on a case by case basis,
</li>
	<li>
`~securityと~privacyに関する自己-考査~質問票^cite
`SECURITY-PRIVACY-QUESTIONNAIRE$r
を評価すること
◎
be evaluated against the Self-Review Questionnaire on Security and Privacy [SECURITY-PRIVACY-QUESTIONNAIRE],
</li>
	<li>
特に，`同一-生成元~施策~違反$
— ~sensorが［
同一-生成元~施策で統治されない，新たな通信~channel
］を公開する場合に発生し得るそれ —
に対し評価すること
◎
and in particular, be evaluated against the same-origin policy violations that can arise if sensors expose a new communication channel not governed by the same-origin policy.
</li>
</ul>

		</section>
		<section id="naming">
<h3 title="Naming">10.2. 命名-法</h3>

<p>
`低level$な~sensor用の `Sensor$I ~interfaceは、
それが結付ける`~platform~sensor$の名前を継ぐベキである。
例えば， `gyroscope^en （ ~gyroscope）を結付ける~interfaceは、
単純に `Gyroscope^I と命名されるベキである。
`高level$な~sensor用の `Sensor$I ~interfaceは、
その`~platform~sensor$が測定する物理量に "Sensor" 接尾辞を結合して命名されるベキである。
例えば，自身からの距離【 `proximity^en／~~近接】を測定している`~platform~sensor$を結付ける~interfaceは、
`ProximitySensor^I と命名されるベキである。
◎
Sensor interfaces for low-level sensors should be named after their associated platform sensor. So for example, the interface associated with a gyroscope should be simply named Gyroscope. Sensor interfaces for high-level sensors should be named by combining the physical quantity the platform sensor measures with the "Sensor" suffix. For example, a platform sensor measuring the distance at which an object is from it may see its associated interface called ProximitySensor.
</p>

<p>
`Sensor$I 下位classの属性のうち，`~sensor読取り$の値たちを保持するものは、
これらの値たちを成す全部的な名前を継ぐベキである。
例えば， `Thermometer^I ~interfaceは、
`~sensor読取り$の値を `temperature^m 属性~内に保持するベキである
（ `value^m や `temp^m 属性ではなく）。
命名~用の良い出発点は、
`Quantities, Units, Dimensions and Data Types Ontologies^cite `QUDT$r
にある。
◎
Attributes of the Sensor subclass that hold sensor readings values should be named after the full name of these values. For example, the Thermometer interface should hold the sensor reading's value in a temperature attribute (and not a value or temp attribute). A good starting point for naming are the Quantities, Units, Dimensions and Data Types Ontologies [QUDT].
</p>

		</section>
		<section id="unit">
<h3 title="Unit">10.3. 単位</h3>

<p>
`拡張~仕様$は、
`~sensor読取り$の単位を指定しなければナラナイ。
◎
Extension specifications must specify the unit of sensor readings.
</p>

<p>
TAG（ `Technical Architecture Group^cite ）による~API設計-原則 `API-DESIGN-PRINCIPLES$r に則り、
すべての時間~測定は，~milli秒数になるベキである。
他のすべての単位は、
`SI Brochure^cite `SI$r に述べられるとおり，
選好~順で次に挙げるいずれかを利用して指定されるベキである
⇒＃
~SI単位系（ `International System of Units^en ）,
~SIから導出された単位,
~SIとの併用に受容される非~SI単位
◎終
ただし，例外として、
温度は，~Kelvin【絶対温度】より~Celsiusの方が選好される。
◎
As per the Technical Architecture Group’s (TAG) API Design Principles [API-DESIGN-PRINCIPLES], all time measurement should be in milliseconds. All other units should be specified using, in order of preference, and with the exception of temperature (for which Celsius should be favored over Kelvin), the International System of Units (SI), SI derived units, and Non-SI units accepted for use with the SI, as described in the SI Brochure [SI].
</p>

		</section>
		<section id="high-vs-low-level">
<h3 title="Exposing High-Level vs. Low-Level Sensors">10.4. 高levelか低levelか，どちらの~sensorを公開するか</h3>

<p>
これまで，~sensorを~Web~platformに公開している仕様は、
`高level$な~sensor~APIに注力していた。
`GEOLOCATION-API$r
`ORIENTATION-EVENT$r
◎
So far, specifications exposing sensors to the Web platform have focused on high-level sensors APIs. [GEOLOCATION-API] [ORIENTATION-EVENT]
</p>

<p>
これは、
いくつかの理由から適理な~approachであった。
~~実際, `高level$な~sensorは：
◎
This was a reasonable approach for a number of reasons. Indeed, high-level sensors:
</p>

<ul>
	<li>
開発者の意図を明瞭に伝達する。
◎
convey developer intent clearly,
</li>
	<li>
下層の~hardwareの~sensorがどう機能するかについて親密な知識を要求しない。
◎
do not require intimate knowledge of how the underlying hardware sensors functions,
</li>
	<li>
利用するのが容易である。
◎
are easy to use,
</li>
	<li>
~UAは処理能と~battery寿命を有意に改善できるようになり得る。
◎
may enable the User Agent to make significant performance and battery life improvements,
</li>
	<li>
公開される情報の量や型を減らすことにより，ある種の［
~privacy／~security
］課題を避ける一助になる。
◎
help avoid certain privacy and security issues by decreasing the amount and type of information exposed.
</li>
</ul>

<p>
しかしながら，仮想現実（ `virtual reality^en ）や拡張現実（ `augmented reality^en ）などの利用事例が数を増やしており、
特に処理能の理由から，~sensorへの`低level$な~accessが要求されている。
◎
However, an increasing number of use cases such as virtual and augmented reality require low-level access to sensors, most notably for performance reasons.
</p>

<p>
`低level$な~accessを供することは、
~Web~app開発者が［
専門分野に特有な拘束を活用する／
もっと高処理能な~systemを設計する
］ことを可能化する。
◎
Providing low-level access enables Web application developers to leverage domain-specific constraints and design more performant systems.
</p>

<p>
`拡張~仕様$は、
`Extensible Web Manifesto^cite `EXTENNNNSIBLE$r
の~~原則に従い，
第一に`低level$な~sensor~APIを公開することに注力するベキであるが、
`高level$な~APIも
— そうすることに明瞭な便益があるときには —
公開するベキである。
◎
Following the precepts of the Extensible Web Manifesto [EXTENNNNSIBLE], extension specifications should focus primarily on exposing low-level sensor APIs, but should also expose high-level APIs when they are clear benefits in doing so.
</p>

		</section>
		<section id="multiple-sensors">
<h3 title="When is Enabling Multiple Sensors of the Same Type Not the Right Choice?">10.5. 同じ型の複数の~sensorを可能化するのは、どのようなとき~~相応しくないか？</h3>

<p>
同じ`~sensor型$の複数の `Sensor$I ~instanceを，
等しい構築~parameterを伴わせて構築することは、
~hardware資源の不必要な消費を導き得るので，勧められない。
◎
It is not advisable to construct multiple Sensor instances of the same sensor type with equal construction parameters, as it can lead to unnecessary hardware resources consumption.
</p>

<p>
複数の観測器が，新たに可用な`~sensor読取り$の通知に関心がある事例では
— 同じ`~sensor型$の複数の~instanceを作成する代わりに —
単独の `Sensor$I ~instanceに`~event~listener$を追加して，単純な `onreading$m ~event~handlerを利用できる。
◎
In cases when multiple observers are interested in notifications of a newly available sensor reading, an event listener can be added on a single Sensor instance instead of creating multiple instances of the same sensor type and using simple onreading event handler.
</p>

<p>
逆に，異なる設定群
— `frequency$m ／正確度／`拡張~仕様$に定義される他の設定など —
の下での利用を意図するなら、
同じ`~sensor型$の複数の `Sensor$I を作成できる。
◎
Conversely, multiple Sensors of the same sensor type can be created when they are intended to be used with different settings, such as: frequency, accuracy or other settings defined in extension specifications.
</p>

		</section>
		<section id="definition-reqs">
<h3 title="Definition Requirements">10.6. 定義~要件</h3>

<p>
`拡張~仕様$は、
`§ ~sensor型＠#model-sensor-type$にて［
結付けられなければナラナイものとして挙げられた~data
］すべてを定義しなければナラナイ。
◎
Extension specifications must define all the associated data listed in § 6.1 Sensor Type.
</p>

<p>
この節は、
それらの~dataの一部について，さらに情報を供する。
◎
This section provides more information about some of the associated data that extension specifications must specify.
</p>
<ul>
	<li>
<div>
<p>
`拡張~sensor~interface@
（ `extension sensor interface^en ）は、
~AND↓ を満たす`~interface$でなければナラナイ：
</p>
		<ul>
			<li>
`Sensor$I ~IN 当の~interfaceが`継承した~interface群$
</li>
			<li>
`構築子~演算$を伴う【！[Constructor]】
— すなわち、
構築-可能である。
</li>
			<li>
前項の構築子は、
次を満たす省略可能な`辞書$を引数にとる
⇒
`SensorOptions$I ~IN 当の辞書が`継承した辞書~群$
</li>
</ul>

◎
An extension sensor interface, which is an interface whose inherited interfaces contains Sensor. The extension sensor interface must be constructible. Its [Constructor] must take, as an argument, an optional dictionary whose inherited dictionaries contains SensorOptions.
</div>

<p>
`拡張~sensor~interface$は、
`~supportする~sensor~option群@
（ `supported sensor options^en ）
— それが~supportする一連の~option【の名前】たちが成す`集合$ —
を持つ。
`拡張~仕様$が他を定義しない限り、
`~supportする~sensor~option群$は，単独の~item `frequency^l のみからなるとする。
◎
The extension sensor interface has a set of supported options referred to as supported sensor options. Unless the extension specification defines otherwise, supported sensor options contain a single item which is "frequency".
</p>

<p>
~UAは、
所与の`拡張~sensor~interface$用の`~supportする~sensor~option群$から，
自身が~supportできない各~sensor~optionに対応する~itemを除去するモノトスル。
◎
The user agent must remove items from supported sensor options for a given extension sensor interface if it cannot support the corresponding sensor options.
</p>

<p>
`拡張~sensor~interface$を成す各`属性$のうち`~sensor読取り$を公開するものは、
`読専$であり，それらの取得子は次の結果を返すモノトスル
⇒
`最新な読取り~mapから値を取得する$( コレ, `属性$の`識別子$ )
◎
The extension sensor interface attributes which expose sensor readings are read only and their getters must return the result of invoking get value from latest reading with this and attribute identifier as arguments.
</p>
	</li>
	<li>
当の`~sensor型$が`~sensor融合$を表現している場合、
その`~sensor許可~名~群$を成す各`名前$は，
融合~sourceを成す いずれかの`~sensor型$に結付けられたものでなければナラナイ。
◎
If the sensor type is representing sensor fusion, its sensor permission names must be those associated with the fusion source sensor types.
</li>
</ul>

<p>
`拡張~仕様$は、
各`~sensor型$に対し，次に挙げる定義を指定してもヨイ：
◎
An extension specification may specify the following definitions for each sensor type:
</p>
<ul>
	<li>
次を満たす`辞書$ %辞書
⇒
`SensorOptions$I ~IN %辞書 が`継承した辞書~群$
◎
A dictionary whose inherited dictionaries contains SensorOptions.
</li>
	<li>
`既定の~sensor$。
~deviceが所与の`~sensor型$用に備える`~platform~sensor$は，一般に 1 つだけなので、
その事例では，`既定の~sensor$を定義することは単直である。
複数の`~device~sensor$が共通的な所では、
`拡張~仕様$は，当の`~sensor型$用の`既定の~sensor$を定義しないことにしてもヨイ
— とりわけ，そうしてもイミを成さないときには。
◎
A default sensor. Generally, devices are equipped with a single platform sensor of each type, in which case defining a default sensor is straightforward. For sensor types where multiple sensors are common, extension specifications may choose not to define a default sensor, especially when doing so would not make sense.
</li>
</ul>

		</section>
		<section id="extend-automation">
<h3 title="Automation">10.7. 自動化</h3>

<p>
~UAの自動化と~appの~test法を可能化するため、
`拡張~仕様$には，次が奨励される：
◎
In order to enable user-agent automation and application testing, extension specifications are encouraged to:
</p>
<ul>
	<li>
`型ごとの~virtual~sensor~metadata$に
1 個以上の`~entry$を追加する。
◎
Add one or more entries to per-type virtual sensor metadata.
</li>
	<li>
前項の帰結として，
1 個以上の`~virtual~sensor~metadata$を定義する。
◎
Consequently, define one or more virtual sensor metadata instances.
</li>
	<li>
`~sensor型$が`属する~virtual~sensor型$を指定する
— それは、
追加した いずれかの`~entry$の`~key$map【！対応している`型ごとの~virtual~sensor~metadata$を成す~entryに利用される~key】に合致するベキである。
◎
Specify a sensor type's virtual sensor type, which should match the key used in the corresponding per-type virtual sensor metadata entry.
</li>
</ul>

<div class="example">
<p>
`§ ~Web~IDL 例＠#example-webidl$ にて述べられる近接~sensor用の`拡張~仕様$は、
次のような~textを包含することもできる：
◎
The extension specification for proximity sensors described in § 10.10 Example WebIDL could contain the following text:
</p>

<blockquote>
<p>
`近接~sensor^i は、
次が結付けられる`~sensor型$である：
◎
The Proximity Sensor is a sensor type with＼
</p>
<ul>
	<li>
`拡張~sensor~interface$
⇒
`ProximitySensor^I
◎
one associated extension sensor interface, ProximitySensor.＼
</li>
	<li>
`属する~virtual~sensor型$
⇒
`proximity^l
◎
Its associated virtual sensor type is "proximity". 
</li>
</ul>
<p>
[...]
</p>

<p>
`近接~読取りを構文解析する~algo^i は、
所与の
( ~JSON `Object$jt %~parameter群 )
に対し，次を呼出すモノトスル
⇒
`一数の読取りを構文解析する＠#parse-single-value-number-reading$( %~parameter群, `distance^l )
◎
The proximity reading parsing algorithm, given a JSON Object parameters, must invoke parse single-value number reading with parameters and "distance".
</p>

<p>
`型ごとの~virtual~sensor~metadata$は、
次に挙げる~entryを伴うモノトスル：
◎
The per-type virtual sensor metadata map must have an entry＼
</p>
<ul>
	<li>
~key `proximity^l
⇒
対応する値を与える`~virtual~sensor~metadata$の
⇒＃
`読取り構文解析~algo$vsMは `近接~読取りを構文解析する~algo^i
◎
whose key is "proximity" and whose value is a virtual sensor metadata whose reading parsing algorithm is proximity reading parsing algorithm.
</li>
</ul>
</blockquote>
</div>

		</section>
		<section id="permission-api">
<h3 title="Extending the Permission API">10.8. `許可~API^citeの拡張-法</h3>

<p>
各`~sensor型$用の `Sensor$I ~interfaceの実装は、
それによる`~sensor読取り$を，結付けられた［
`名前$ ／ `PermissionDescriptor$I【`許可~記述子~型$】
］により保護するモノトスル。
`低level$な `Sensor$I は、
`名前$として その~interface名を利用してもヨイ
（例： `gyroscope^l ／ `accelerometer^l ）。
`~sensor融合$は、
融合の~sourceとして利用される各~sensorに対し，`~accessする許可を要請する$モノトスル。
◎
An implementation of the Sensor interface for each sensor type must protect its reading by associated name or PermissionDescriptor. A low-level sensor may use its interface name as a name, for instance, "gyroscope" or "accelerometer". Fusion sensors must request permission to access each of the sensors that are used as a source of fusion.
</p>

<p>
融合された~dataから`低level$な`~sensor読取り$を構築し直すのは困難であっても、
元の情報の一部は，推定され得る。
例えば［
`絶対~方位~sensor$／`地磁気~方位~sensor$
］が利用されれば，空間における利用者の方位を演繹するのは容易である。
したがって，これらの~sensorは、
磁力計を`利用する許可を要請する$モノトスル
— ~deviceの方位についての情報を地球の磁場との関係で供するので。
対照的に，`相対~方位~sensor$は そのような情報を公開しないので、
磁力計を`利用する許可を要請する$必要はない。
◎
Even though it might be difficult to reconstruct low-level sensor readings from fused data, some of the original information might be inferred. For example, it is easy to deduce user’s orientation in space if absolute or geomagnetic orientation sensors are used, therefore, these sensors must request permission to use magnetometer as it provides information about orientation of device in relation to Earth’s magnetic field. In contrast, relative orientation sensor does not expose such information, thus, it does not need to request permission to use magnetometer.
</p>

<p>
`PermissionDescriptor$I も利用できる
— 正確度または`標本化~frequency$に許容される上限を設定するためとして。
◎
Permission descriptors can also be used to set maximum allowed limits for accuracy or sampling frequency.＼
</p>

<div class="example">
<p>
加速度計~sensor用の`許可~API^citeにアリな拡張の例：
◎
An example for a possible extension of the Permission API for accelerometer sensor is given below.
</p>

<pre class="idl">
dictionary AccelerometerPermissionDescriptor : `PermissionDescriptor$I {
    boolean highAccuracy = false;
    boolean highFrequency = false;
};
</pre>
</div>

		</section>
		<section id="permissions-policy-api">
<h3 title="Extending the Permissions Policy API">10.9. `許可~施策~API^citeの拡張-法</h3>

<p>
各`~sensor型$用の `Sensor$I ~interfaceの実装には、
1 個（`~sensor融合$は遂行されない場合）または複数個の，`施策により制御される特能$が結付けられる
— それらは、
その実装を文書~内で利用できるかどうかを制御する。
◎
An implementation of the Sensor interface for each sensor type has one (if sensor fusion is not performed) or several policy-controlled features that control whether or not this implementation can be used in a document.
</p>

<p>
これらの各`施策により制御される特能$の`既定の許容list$は、
`'self'^l とする。
◎
The features' default allowlist is 'self'.
</p>

<p class="trans-note">【
複数の`~sensor型$用の `Sensor$I ~interfaceが同じ特能を共有する場合に、
~interfaceごとに異なる`既定の許容list$を指定する必要が生じる~~状況は，
今の所は想定されていないようだ。
】</p>

<p class="note">注記：
`既定の許容list$ `'self'^l は、
`Sensor$I ~interfaceの実装の用法を，［
同一-生成元に属する入子な~frame
］には許容するが、［
第三者-主体~内容による`~sensor読取り$への~access
］は防止する。
◎
Note: The default allowlist of 'self' allows Sensor interface implementation usage in same-origin nested frames but prevents third-party content from sensor readings access.
</p>

<p>
`~sensor特能~名~群$は、
それに結付けられた［
各`施策により制御される特能$を識別する~token
］からなるモノトスル。
◎
The sensor feature names set must contain policy-controlled feature tokens of every associated feature.
</p>

<p>
`低level$な`~sensor型$は、
その~interface名を`施策により制御される特能$用の~tokenとして利用してもヨイ
— 例： `gyroscope^l ／ `accelerometer^l
。
`拡張~仕様$が他を定義しない限り，`~sensor特能~名~群$は、
同じ`~sensor型$に結付けられた`~sensor許可~名~群$に合致する。
◎
A low-level sensor may use its interface name as a policy-controlled feature token, for instance, "gyroscope" or "accelerometer". Unless the extension specification defines otherwise, the sensor feature names matches the same type-associated sensor permission names.
</p>

<div class="example html">
<p>
加速度計~特能は、
~frame容器~要素に `allow$a 属性を追加することにより，
第三者-主体の生成元~用に選択的に可能化される：
◎
The accelerometer feature is selectively enabled for third-party origin by adding an allow attribute to the frame container element:
</p>

<pre class="lang-html">
&lt;iframe src="https://third-party.com" allow="accelerometer"/&gt;&lt;/iframe&gt;
</pre>
</div>

<div class="example">
<p>
~sensor用法は、
~HTTP応答~header内に許可~施策を指定することにより，完全に不能化される：
◎
A sensor usage is disabled completely by specifying the permissions policy in an HTTP response header:
</p>

<pre class="lang-http">
Permissions-Policy: accelerometer=()
</pre>
</div>

<p>
`~sensor融合$は、
融合の~sourceとして利用される各~sensorの`~sensor特能~名~群$を利用するモノトスル。
◎
Fusion sensors must use sensor feature names of the sensors that are used as a source of fusion.
</p>

<div class="example">
<p>
`絶対~方位~sensor$に要求される［
加速度計, 磁力計, ~gyroscope
］特能を利用するのを，第三者-主体の生成元に許容する：
◎
Allow third-party origin to use accelerometer, magnetometer and gyroscope features that are required by the absolute orientation sensor.
</p>

<pre class="lang-html">
&lt;iframe src="https://third-party.com" allow="accelerometer; magnetometer; gyroscope"/&gt;
</pre>
</div>

		</section>
		<section id="example-webidl">
<h3 title="Example WebIDL">10.10. ~Web~IDL例</h3>

<div class="example">
<p>
この仕様の拡張としてアリな，近接`~device~sensor$用の~Web~IDLの例：
◎
Here’s an example WebIDL for a possible extension of this specification for proximity sensors.
</p>

<pre class="idl">
[SecureContext, Exposed=Window]
interface ProximitySensor : Sensor {
    constructor(optional ProximitySensorOptions proximitySensorOptions = {});
    readonly attribute double? distance;
};

dictionary ProximitySensorOptions : SensorOptions {
    double min;
    double max;
    ProximitySensorPosition position;
    ProximitySensorDirection direction;
};

enum ProximitySensorPosition {
    "top-left",
    "top",
    "top-right",
    "middle-left",
    "middle",
    "middle-right",
    "bottom-left",
    "bottom",
    "bottom-right"
};

enum ProximitySensorDirection {
    "front",
    "rear",
    "left",
    "right",
    "top",
    "bottom"
};
</pre>
</div>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
次に挙げる方々に感謝する：
</p>
<ul>
	<li>
何よりもまず：
`Anssi Kostiainen^en 氏は、
この仕様の開発~全体を通して継続的かつ献身的に~supportと意見を寄せていただいた。
また，
`Mikhail Pozdnyakov^en,
`Alexander Shalamov^en,
`Rijubrata Bhaumik^en,
`Kenneth Rohde Christiansen^en
各氏は、
この仕様に貴重な［
実装~feedback, 示唆, 事実調査
］を伝えて，その作業に助力していただいた。
◎
First and foremost,＼
I would like to thank Anssi Kostiainen for his continuous and dedicated support and input throughout the development of this specification,＼
as well as Mikhail Pozdnyakov, Alexander Shalamov, Rijubrata Bhaumik, and Kenneth Rohde Christiansen for their invaluable implementation feedback, suggestions, and research that have helped inform the specification work.
</li>
	<li>
`Rick Waldron^en 氏は、
~Web用の汎用~sensor~APIの設計を巡る論点を推進して，
この仕様が基づいている元の~APIを素描して，
氏の `Johnny Five^en における作業から実装~feedbackを供して，
この仕様の開発の間に継続的に意見を寄せていただいた。
◎
Special thanks to Rick Waldron for driving the discussion around a generic sensor API design for the Web, sketching the original API on which this is based, providing implementation feedback from his work on Johnny-Five, and continuous input during the development of this specification.
</li>
	<li>
`Boris Smus^en,
`Tim Volodine^en,
`Rich Tibbett^en
各氏は、
一貫性をもって，~sensorを~webに公開するための初期~作業に携わっていただいた。
◎
Special thanks to Boris Smus, Tim Volodine, and Rich Tibbett for their initial work on exposing sensors to the web with consistency.
</li>
	<li>
`Anne van Kesteren^en 氏は、
~~直におよび IRC を通して，たゆまず助力していただいた。
◎
Thanks to Anne van Kesteren for his tireless help both in person and through IRC.
</li>
	<li>
`Domenic Denicola^en,
`Jake Archibald^en
各氏による助力に。
◎
Thanks to Domenic Denicola and Jake Archibald for their help.
</li>
	<li>
`Frederick Hirsch^en,
`Dominique Hazaël-Massieux^en
各氏は、
（ `HTML5Apps project^en を介して）
運営上の助力, 技術的な意見を寄せていただいた。
◎
Thanks also to Frederick Hirsch and Dominique Hazaël-Massieux (via the HTML5Apps project) for both their administrative help and technical input.
</li>
	<li>
`Tab Atkins^en 氏は、
Bikeshed を作り上げ，それを詳しく説明する時間を割いていただいた。
◎
Thanks to Tab Atkins for making Bikeshed and taking the time to explain its subtleties.
</li>
	<li>
`Lukasz Olejnik^en,
`Maryam Mehrnezhad^en
各氏は、
~privacyと~security周りで貢献していただいた。
◎
Thanks to Lukasz Olejnik and Maryam Mehrnezhad for their contributions around privacy and security.
</li>
	<li>
<p>
次に挙げる方々は、
GitHub 上での多方面な論点を通して，この仕様に多大に貢献していただいた：
◎
The following people have greatly contributed to this specification through extensive discussions on GitHub:＼
</p>

<p lang="en">
Anssi Kostiainen, Boris Smus, chaals, Claes Nilsson, Dave Raggett, David Mark Clements, Domenic Denicola, Dominique Hazaël-Massieux (via the HTML5Apps project), Francesco Iovine, Frederick Hirsch, gmandyam, Jafar Husain, Johannes Hund, Kris Kowal, Lukasz Olejnik, Marcos Caceres, Marijn Kruisselbrink, Mark Foltz, Mats Wichmann, Matthew Podwysocki, Olli Pettay, pablochacin, Remy Sharp, Rich Tibbett, Rick Waldron, Rijubrata Bhaumik, robman, Sean T. McBeth, Tab Atkins Jr., Virginie Galindo, zenparsing, and Zoltan Kis.
</p>
	</li>
	<li>
`Anssi Kostiainen^en,
`Dominique Hazaël-Massieux^en,
`Erik Wilde^en,
`Michael[tm] Smith^en
各氏は、
編集上の意見を寄せていただいた。
◎
We’d also like to thank Anssi Kostiainen, Dominique Hazaël-Massieux, Erik Wilde, and Michael[tm] Smith for their editorial input.
</li>
</ul>

	</section>
</main></div>

