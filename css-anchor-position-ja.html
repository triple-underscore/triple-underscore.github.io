<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Anchor Positioning （日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if(i > 0) {
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i + 1)}</code>`;
		}
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'tp':
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">
●●options

spec_title:CSS Anchor Positioning
spec_date:2024-03-11
trans_update:2024-03-12
source_checked:240308
page_state_key:CSS
original_url:https://drafts.csswg.org/css-anchor-position-1/
	abbr_url:CSSANCHOR
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:layouts,css
conformance:css
copyright:2024,permissive
trans_1st_pub:2023-03-06

●●class_map
p:property
at:at-rule
t:type
tp:type
v:value
vA:value
vI:value
vS:value
vOp:value
vOd:value
vPa:value
f:func
pe:pseudo
css:css
e:element
a:attr

●●tag_map
p:code
t:var
tp:var
v:code
vA:code
vI:code
vS:code
vOp:code
vOd:code
vPa:code
css:code
at:code
pe:code
e:code
a:code
c:code
f:code
m:code
I:code
cite:cite
em:em

●●original_id_map

●●mdn_urls
	propdef-anchor-default:CSS/anchor-default
	propdef-anchor-name:CSS/anchor-name

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
CSSOMString:~CSSOM1#cssomstring
SameObject:~WEBIDLjs#SameObject
PutForwards:~WEBIDLjs#PutForwards

I.CSSGroupingRule:~CSSOM1#cssgroupingrule
I.CSSRule:~CSSOM1#cssrule
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration
I.CSSPositionTryRule:#csspositiontryrule
I.ResizeObserver:~CSSWG/resize-observer-1/#resizeobserver

m.cssText:~CSSOM1#dom-cssstyledeclaration-csstext
m.name:#dom-csspositiontryrule-name
m.style:#dom-csspositiontryrule-style

	●css
at.position-try:#at-ruledef-position-try


p.anchor-default:#propdef-anchor-default
p.anchor-name:#propdef-anchor-name
p.anchor-scope:#propdef-anchor-scope
p.inset-area:#propdef-inset-area
p.position:~CSSPOS#propdef-position

p.position-try:#propdef-position-try
p.position-try-options:#propdef-position-try-options
p.position-try-order:#propdef-position-try-order

p.margin-block-start:~CSSLOGICAL#propdef-margin-block-start
p.margin-block-end:~CSSLOGICAL#propdef-margin-block-end
p.margin-inline-start:~CSSLOGICAL#propdef-margin-inline-start
p.right:~CSSPOS#propdef-right
p.bottom:~CSSPOS#propdef-bottom
p.left:~CSSPOS#propdef-left
p.top:~CSSPOS#propdef-top
p.width:~SIZING#propdef-width
p.justify-self:~CSSALIGN#propdef-justify-self
p.align-self:~CSSALIGN#propdef-align-self
p.justify-items:~CSSALIGN#propdef-justify-items
p.align-items:~CSSALIGN#propdef-align-items
p.max-height:~SIZING#propdef-max-height

f.anchor-size:#funcdef-anchor-size
f.anchor:#funcdef-anchor
f.translate:~TRANSFORM#funcdef-transform-translate

t.inset-area:#typedef-inset-area
t.anchor-element:#typedef-anchor-element
t.anchor-side:#typedef-anchor-side
t.anchor-size:#typedef-anchor-size
t.try-size:#typedef-try-size
t.try-tactic:#typedef-position-try-options-try-tactic
t.dashed-ident:~CSSVAL#typedef-dashed-ident
	t.dashed-ident:#valdef-anchor-dashed-ident
	t.dashed-ident:#valdef-anchor-name-dashed-ident
t.declaration-list:~CSSSYN#typedef-declaration-list
t.length-percentage:~CSSVAL#typedef-length-percentage
t.percentage:~CSSVAL#percentage-value
	t.percentage:#valdef-anchor-percentage
t.length:~CSSVAL#length-value

v.block:#valdef-anchor-size-block
v.height:#valdef-anchor-size-height
v.inline:#valdef-anchor-size-inline
v.self-block:#valdef-anchor-size-self-block
v.self-inline:#valdef-anchor-size-self-inline
v.width:#valdef-anchor-size-width

v.~noneN:#valdef-anchor-name-none

v.auto:~CSSPOS#valdef-top-auto
vS.normal:~CSSALIGN#valdef-align-self-normal
vS.anchor-center:#valdef-justify-self-anchor-center
vS.start:~CSSALIGN#valdef-self-position-start
vS.center:~CSSALIGN#valdef-self-position-center
vS.end:~CSSALIGN#valdef-self-position-end
	v.auto:~CSSALIGN#valdef-justify-self-auto

	t.inset-area:#valdef-inset-area-inset-area
vI.none:#valdef-inset-area-none
vI.span-all:#valdef-inset-area-span-all
vI.start:#valdef-inset-area-start
vI.end:#valdef-inset-area-end
vI.self-start:#valdef-inset-area-self-start
vI.self-end:#valdef-inset-area-self-end
vI.center:#valdef-inset-area-center
vI.top:#valdef-inset-area-top
vI.bottom:#valdef-inset-area-bottom
vI.left:#valdef-inset-area-left
vI.right:#valdef-inset-area-right
vI.x-start:#valdef-inset-area-x-start
vI.x-end:#valdef-inset-area-x-end
vI.x-self-start:#valdef-inset-area-x-self-start
vI.x-self-end:#valdef-inset-area-x-self-end
vI.y-start:#valdef-inset-area-y-start
vI.y-end:#valdef-inset-area-y-end
vI.y-self-start:#valdef-inset-area-y-self-start
vI.y-self-end:#valdef-inset-area-y-self-end
vI.block-start:#valdef-inset-area-block-start
vI.block-end:#valdef-inset-area-block-end
vI.block-self-start:#valdef-inset-area-block-self-start
vI.block-self-end:#valdef-inset-area-block-self-end
vI.inline-start:#valdef-inset-area-inline-start
vI.inline-end:#valdef-inset-area-inline-end
vI.inline-self-start:#valdef-inset-area-inline-self-start
vI.inline-self-end:#valdef-inset-area-inline-self-end
vI.span-start:#valdef-inset-area-span-start
vI.span-end:#valdef-inset-area-span-end
vI.span-top:#valdef-inset-area-span-top
vI.span-bottom:#valdef-inset-area-span-bottom
vI.span-y-start:#valdef-inset-area-span-y-start
vI.span-y-end:#valdef-inset-area-span-y-end
vI.span-x-start:#valdef-inset-area-span-x-start
vI.span-x-end:#valdef-inset-area-span-x-end
vI.span-block-start:#valdef-inset-area-span-block-start
vI.span-block-end:#valdef-inset-area-span-block-end
vI.span-inline-start:#valdef-inset-area-span-inline-start
vI.span-inline-end:#valdef-inset-area-span-inline-end

vA.inside:#valdef-anchor-inside
vA.outside:#valdef-anchor-outside
vA.bottom:#valdef-anchor-bottom
vA.center:#valdef-anchor-center
vA.end:#valdef-anchor-end
vA.implicit:#valdef-anchor-implicit
vA.left:#valdef-anchor-left
vA.right:#valdef-anchor-right
vA.self-end:#valdef-anchor-self-end
vA.self-start:#valdef-anchor-self-start
vA.start:#valdef-anchor-start
vA.top:#valdef-anchor-top

v.none:#valdef-anchor-scope-none
v.all:#valdef-anchor-scope-all
	t.dashed-ident:#valdef-anchor-scope-dashed-ident

vOp.none:#valdef-position-try-options-none
vOp.flip-block:#valdef-position-try-options-flip-block
vOp.flip-inline:#valdef-position-try-options-flip-inline
vOp.flip-start:#valdef-position-try-options-flip-start
	t.dashed-ident:#valdef-position-try-options-dashed-ident
	t.try-tactic:#valdef-position-try-options-try-tactic
	#valdef-position-try-options-dashed-ident--try-tactic

vOd.normal:#valdef-position-try-order-normal
vOd.most-width:#valdef-position-try-order-most-width
vOd.most-height:#valdef-position-try-order-most-height
vOd.most-block-size:#valdef-position-try-order-most-block-size
vOd.most-inline-size:#valdef-position-try-order-most-inline-size


pe.part():~CSSSHADOWPARTS#selectordef-part

e.input:~HEinput#the-input-element
e.li:~HEgrouping#the-li-element


	●用語
~anchor要素:#anchor-element
既定の~anchor要素:#default-anchor-element
~anchor関数:#anchor-functions
~anchor名:#anchor-name
~anchor位置決め:#anchor-positioning
~anchor指定子:#anchor-specifier
妥当な~anchor関数:#valid-anchor-function
妥当な~anchor~size関数:#valid-anchor-size-function
暗黙的な~anchor要素:#implicit-anchor-element
位置~option~list:#position-options-list
位置~option:#position-option
位置~optionを適用する:#apply-a-position-option
最後の成功裡な位置~option:#last-successful-position-option
位置~fallback~style群を決定する:#determine-the-position-fallback-styles
~target~anchor要素:#target-anchor-element
~anchor先:#target-anchor-element
既定の~anchor指定子:#default-anchor-specifier
受容-可能な~anchor要素:#acceptable-anchor-element
~scroll調整が必要:#needs-scroll-adjustment
~snapshot済み~scroll~offset:#snapshotted-scroll-offset
受容される~prop:#accepted-position-try-properties
~inset区画~用の格子:#inset-area-grid
~inset区画:#_inset-area
位置~fallback出自:#position-fallback-origin
~styleと~layoutの差挟み:#style--layout-interleave

	●用語（ CSS
~math関数:~CSSVAL#math-function
算出d長さ:~CSSVAL#computed-length

~prop:~CASCADE#css-property
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
出自:~CASCADE#origin
作者~出自:~CASCADE#cascade-origin-author
~animation出自:~CASCADE#cascade-origin-animation

断片:~CSSBREAK#fragment

~insetで改変された包含塊:~CSSPOS#inset-modified-containing-block

自己-整列:~CSSALIGN#self-align
自己-整列~prop:~CSSALIGN#self-alignment-properties

包含塊~連鎖:~CSSDISP#containing-block-chain
包含塊:~CSSDISP#containing-block
要素:~CSSDISP#elements
首要~box:~CSSDISP#principal-box
初期~包含塊:~CSSDISP#initial-containing-block
~box~tree:~CSSDISP#box-tree
~inset~prop:~CSSPOS#inset-properties
	~inset~prop:~CSSLOGICAL#inset-properties

~margin~prop:~CSSBOX#margin-properties
~margin~box:~CSSBOX#margin-box

書字~mode:~CSSWM#writing-mode
始端:~CSSWM#css-start
終端:~CSSWM#css-end
塊-始端:~CSSWM#block-start
行内-始端:~CSSWM#inline-start
塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end
横~軸:~CSSWM#x-axis
縦~軸:~CSSWM#y-axis
塊-軸:~CSSWM#block-axis
行内-軸:~CSSWM#inline-axis

~sizing~prop:~SIZING#sizing-property
可用な空間:~SIZING#available
最後に記憶した~size:~SIZING4#last-remembered
絶対~位置決め:~CSSPOS#absolute-position
固定d位置決め:~CSSPOS#fixed-position
絶対的に位置され:~CSSPOS#absolute-position
有位置:~CSSPOS#positioned-box
上端~層:~CSSPOS4#document-top-layer

~tree視野な参照:~CSSSCOPING#css-tree-scoped-reference
~tree視野な名前:~CSSSCOPING#css-tree-scoped-name

~scroll容器:~CSSOVERFLOW3#scroll-container
~scroll~offset:~CSSOVERFLOW3#scroll-offset
~scrollport:~CSSOVERFLOW3#scrollport
初期~scroll位置:~CSSOVERFLOW3#initial-scroll-position

疑似要素:~SELECTORS4#pseudo-element
出自の要素:~SELECTORS4#originating-element

~style封込め:~CSSCONTAIN#style-containment
~layout封込め:~CSSCONTAIN#layout-containment
視野~付き~prop:~CSSCONTAIN#property-scoped
~query容器:~CSSCONTAIN3#query-container
容器~query:~CSSCONTAIN3#container-query
容器~query長さ単位:~CSSCONTAIN3#container-query-length


	●用語（他
根:~DOM4#concept-tree-root
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order
~shadow~tree:~DOM4#concept-shadow-tree

●●words_table1
CSSSHADOWPARTS:css-shadow-parts-ja.html
SIZING4:https://drafts.csswg.org/css-sizing-4/

noneN:none
noneF:none
noneS:none

●●words_table


	●幾何
限界:bounding::~
限界域:bounds::~
矩形:rectangle:~
	矩形:rect
中心:center::~
中央:center::~
	中央に寄せ:center
	中央~寄せ:centering
ズラされ:shiftされ:ずらされ
縦方向:vertical::~
横方向:horizontal::~
横:horizontal::~
縦:vertical::~
側:side:~
隅:corner:~
対角線:diagonal:~
反対-:opposite:~
	反対-側にある:opposing
	反対-側:opposite
	もう一方の:opposite

	縦幅:tall
	幅広:wide
	横幅:wide
	の距離を成す:separating
	を挟んで鏡写しに:mirroring across 〜 line

	●layout
首要:principal::主要
収まら:fitし:~
scrollport::::スクロール域
	揃う:line up
scrolling::::スクロール処理
重合する:overlapする:重なり合う
固定d:fixed::固定
格子:grid::~::グリッド
線:line:~
逆転-:reverse:~
埋める:fillする:~
伸張-:stretch::~
row:
col:column

	`~scroll容器$:scroller
	〜へ整列するよう:-aligning
	軸が揃えられた:axis-aligned
	移転-:flip
	入れ替わる:flip
	固定d位置決め:fixpos
	内容~box:content-box
	縦横とも 3 分された:3x3
	~screen外:off-screen
	~screen外:offscreen
	~screen外:off screen
	~screen内に収ま:fit on-screen
	-sizeは 0 になる:zero-sized
	占める:occupy
	占める:-
	占める:span
	も占めることを除いて…:Two rows or columns, depending…
	寄りに:-ward
	~inset区画:inset-area
	~inset区画:inset area
	~inset区画:the region
	改変される前の:pre-modification
	改変される前の:pre-modified
	`絶対的に位置され$たもの:abspos
	包含塊:CB
	-:AbsPos
	^em:magic
	空間を 〜 限り広くとる:to have as much space as
	広くなり過ぎる:getting too wide

	●CSS
視野な:scopedな::~
	~tree視野な:tree-scoped
導入部:prelude:~
横組み:horizontal writing mode::~
書字:writing::~
捕捉-:capture:~
変形:transform::~
積層:stacking::~
積層-:stack::~
	そこへ積層され:stacking up on top of each other
出自の:originating::~
隠す:hideする:~
封込め:containment::封じ込め
出自:origin::~

	~anchor先:anchored
	~anchor法:anchoring
	~anchor先に:anchoring
	^en:style-contained

	●UI
tooltip::::ツールチップ
hover:
popover:
popup::::ポップアップ

	~access可能でない:inaccessible

	●処理
切詰める:clampする:切り詰める
安定:stable::~
	安定に:stably
変形n:transformation::変形
記憶-:remember:~
遡及的:retroactive:~
決着-:settle:~
検索:lookup:~

	指数関数的に:in exponential
	この上限:total product
	深過ぎる:get too deep
	-:stuck
	切り替わる:swap
	入れ替える:swap
	入れ替えて:swap
	入れ替わる:flipping
	-:exit
	上書き用の:overriding
	“後戻りしない”:does not "go backward"
	〜を経る:〜 pass
	結果に:gain
	やり直して:to go back

	●変数
	%~query要素:query el
	%要素:el
	%調整-済み~style群:adjusted styles
	%指定子:anchor spec
	%基底~style群:base styles
	%新たな~style群:new styles
	%要素~矩形:el rect
	%包含塊~矩形:cb rect

	●仕様
策:strategy:~
柔軟性:flexibility:~
普通の:ordinaryな:~
流儀:fashion:~
提起-:raise:~
確証:assurance:~
循環依存に:circularに:~
	循環依存になる:is cyclic
循環依存:circularity:~
切替える:switchする:切り替える
過度:excess:~
見出法:finding:見出し方
各利用:usage:~
協調:coordination:~
保つ:keepする:~
素描:sketch:~
機能:function:~
扱い:treatment:~

	ようになった:end up with
	そうなるかどうかは:vary
	仮に〜とする:say
	させたい:would like
	し易く:make it easier
	当の:in question
	生じ得ない:there is no possibly
	他では:otherwise
	およそ:more or less
	さらには〜もっと〜までも:even more
	実装:impl
	編集者:I
	考えて:think
	〜を除いて:save that
	課す:impose
	~~改善:ameliorate
	~~採用:taken as the winner
	~~採用:take
	に基づくように:in terms of
	単に:merely
	優先される:"wins"
	選ぶ:choice
	選んで:chooseして
	選ばれ:chosen
	選べる:chooseでき
	に基づいて:keys off
	ちょうど:exactly
	言い直:rephrase
	〜に基づく:key off
	に関する:around
	これらの:extra
	伴うようになる:gain
	関わることなく:without regard to
	別として:beside
	気にする:worry
	より強い:stronger
	-:aka
	満たす:satisfy
	失うこと:losing
	十分:enough
	極めて:extremely
	に加えて:plus
	設定-法:set-up
	（未策定）:TBD
	未策定:TODO
	捉えれる:can be thought
	できるようにする:lets you
	-:aka
	-:possibly
	~~確かめる:make sure
	に関して正しくなる:stuff is correct
	-:stuff
	`CSS-POSITION-3$r の:CSS Position
	〜されよう:Presumably,
	いずれにせよ:nevertheless
	今の所は:for now
	足りる:suffice
	ある程度は:to some extent
	仕様:spec
	詳細を詰める:way more details filled in
	明らかに:obviously
	~~最善でも:at best
	~~最悪，:at worst

	●未分類
参照r:refer:参照
	に基づく:refer
math:
補償-:compensate:~
時機:timing:~
上限:limit:~
総和:sum:~
付され:attachされ:~
先行-:precede:~
構成-:compose:~
英語:English:~
付-:attach:~
維持-:retain:~
生来:natural:~
差挟み:interleaving:差し挟み
差挟まれ:interleaveされ:差し挟まれ
component::::コンポーネント
衝突:clash:~

	~item:entry
	引き出す:draw
	の距離を成す:separating
	~library:libs
	~tree視野な:tree-scoped
	同時に:at once
	1000:1k
	識別子:ident
	直前の~blockを適用した結果:the previous 〜 successive one
	住まう:living
	現れる:appearする
	一部でも:partially or fully
	無い:none
	以上:at least
	次に，Next,
	来ている:come from
	計算し直す:recalc
	最も近い:closest
	最も近い:nearest
	順に 1 つずつ:one by one
	時点:point
	多数の:bunch of
	3 個目の:final
	最後に:Finally,
	に~~達する前まで:up to but not including
	-:in turn
	-:grandchild
	置く:putting
	Chrome
	^en:make a CQ
	量:amount
	探す:look for
	箇所:place
	どこに在ってもよい:can live anywhere
	~EQ ε:was not passed
	ε:nothing
	基準に:against
	~anchor~size:anchor-size
	~scroll調整-済み:scroll-adjusted
	最~大:largest
	接頭辞を伴わない:plain
	~~保ったまま:as
	軸を指定する〜:unambigous
	他の場合:ambigous
	はみ出る:partially or completely outside of
	今や:now
	所与の:the previous
	当の要素の:its
	時点:at time
	決定し直-:re-determine
	-:variant
	~~後続の:later
	最後の:final

●●images
＠css-anchor-position/
inset-area-example｜width:400px｜｜.png


●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CASCADE-6]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 6＞. URL: https://drafts.csswg.org/css-cascade-6/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-DISPLAY-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-DISPLAY-4]
    ＜CSS Display Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-display-4/
[CSS-LOGICAL-1]
    Rossen Atanassov; Elika Etemad. ＜CSS Logical Properties and Values Level 1＞. URL: https://drafts.csswg.org/css-logical-1/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SIZING-4]
    Tab Atkins Jr.; Elika Etemad; Jen Simmons. ＜CSS Box Sizing Module Level 4＞. URL: https://drafts.csswg.org/css-sizing-4/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RESIZE-OBSERVER-1]
    Aleks Totic; Greg Whitworth. ＜Resize Observer＞. URL: https://drafts.csswg.org/resize-observer/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-CONTAIN-3]
    Tab Atkins Jr.; Florian Rivoal; Miriam Suzanne. ＜CSS Containment Module Level 3＞. URL: https://drafts.csswg.org/css-contain-3/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Anchor Positioning</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-anchor-position-1/
公表履歴
	https://www.w3.org/standards/history/css-anchor-position-1/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-anchor-position-1">CSSWG Issues Repository</a>
編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Apple)
	Ian Kilpatrick (Google)

前任編集者
	<a href="https://twitter.com/jh3yy">Jhey Tompkins</a> (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-anchor-position-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-anchor-position-1
</script>

</head><body>

<header>
	<hgroup>
<h1 title="CSS Anchor Positioning">CSS アンカー位置決め</h1>
<p>CSS Anchor Positioning</p>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は “~anchor位置決め” を定義する。
そこでは、
有位置な要素†が［
~page上の他所にある 1 個以上の “~anchor要素”
］に相対的に，自身を~sizeして位置できる。
◎
This specification defines 'anchor positioning', where a positioned element can size and position itself relative to one or more "anchor elements" elsewhere on the page.
</p>

<p class="trans-note">【†
この仕様における`有位置$な要素は、
実際には，（より限定的な）`絶対的に位置され$た要素の略称である。
】</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSの`絶対~位置決め$は、
要素を~page上のどこにでも
— 要素の包含塊は別として，他の要素の~layoutに関わることなく —
配置することを作者に許容する。
この柔軟性は、
ごく有用になり得るが，ごく制限されてもいる
— 要素を他の`何らかの^em要素に相対的に位置するよう求まれることは多い。
`~anchor位置決め@
は、
`~anchor関数@
— `anchor$f, `anchor-size$f の総称 —
を介して，これを達成することを作者に許容する
— それは、
ある`絶対的に位置され$た要素を［
~page上の他の 1 個以上の要素
］を “~anchor先に” しながら，［
他と重合する／~overflowする
］ことを避ける “最良な” ものを見出すよう［
いくつかのアリな位置を試行する
］ことを許容する。
◎
CSS absolute positioning allows authors to place elements anywhere on the page, without regard to the layout of other elements besides their containing block. This flexibility can be very useful, but also very limiting—often you want to position relative to some other element. Anchor positioning (via the anchor functions anchor() and anchor-size()) allows authors to achieve this, "anchoring" an absolutely-positioned element to one or more other elements on the page, while also allowing them to try several possible positions to find the "best" one that avoids overlap/overflow.
</p>

<div class="example">
<p>
作者は、
ある~tooltip【 `.tooltip^css 】を ~targetにされた要素【 `.anchor^css 】の中央かつ上に
— ただし、
そうすると~screen外に配置される事例では，下に —
位置するよう求めることもあろう。
これは、
次の~CSSで行える：
◎
For example, an author might want to position a tooltip centered and above the targeted element, unless that would place the tooltip offscreen, in which case it should be below the targeted element. This can be done with the following CSS:
</p>

<pre class="lang-css">
.anchor {
  /* <span class="comment">
【`--tooltip^v と命名された`~anchor要素$。】
</span> */
  anchor-name: --tooltip;
}
.tooltip {
  /* <span class="comment">
`固定d位置決め$は、
包含塊の関係性を気にする必要は無いことを意味する
— 当の~tooltipは、
~DOM内のどこに在ってもよい。
◎
Fixpos means we don’t need to worry about containing block relationships; the tooltip can live anywhere in the DOM.
</span> */
  position: fixed;

  /* <span class="comment">
~anchor法の挙動は、
すべて，既定では `--tooltip^v と命名された~anchorを参照rするようにする。
◎
All the anchoring behavior will default to referring to the --tooltip anchor.
</span> */
  anchor-default: --tooltip;

  /* <span class="comment">
~tooltipの下端を~anchorの上端に整列させる。
これはまた、
既定では，~tooltipと~anchorを横方向において中央に整列させる（横組みにおいては）。
◎
Align the tooltip’s bottom to the top of the anchor; this also defaults to horizontally center-aligning the tooltip and the anchor (in horizontal writing modes).
</span> */
  inset-area: block-start;

  /* <span class="comment">
~UIwindowを~overflowする場合、
~tooltipの上端が~anchorの下端に整列するよう，自動的に切り替える。
◎
Automatically swap if this overflows the window so the tooltip’s top aligns to the anchor’s bottom instead.
</span> */
  position-try: flip-block;

  /* <span class="comment">
広くなり過ぎるのを防止する。
◎
Prevent getting too wide
</span> */
  max-inline-size: 20em;
</pre>
</div>

	</section>
	<section id="determining">
<h2 title="Determining the Anchor">2. ~anchorの決定-法</h2>

		<section id="name">
<h3 title="Creating an Anchor: the anchor-name property">2.1. ~anchorの作成-法： `anchor-name^p ~prop</h3>

◎名 `anchor-name@p
◎値 `~noneN$v | `dashed-ident$t#
◎初 `~noneN$v
◎適 `首要~box$を生成するすべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`anchor-name$p ~propは、
要素が
`~anchor要素@
になるものと宣言する。
要素は、
この~propに与えた~listを成す各
`~anchor名@
を通して~targetにされる。
各種 値は、
次に従って定義される：
◎
The anchor-name property declares that an element is an anchor element, and gives it a list of anchor names to be targeted by. Values are defined as follows:
</p>

<dl class="valdef">
	<dt>`~noneN@v</dt>
	<dd>
この~propによる効果は無い。
◎
The property has no effect.
</dd>

	<dt id="valdef-anchor-name-dashed-ident">`dashed-ident$t#</dt>
	<dd>
当の要素は，
`首要~box$を生成するならば、
`~anchor要素$になり，
所与の~listを成す`~anchor名$たちを伴う
— 各`~anchor名$は、
`~tree視野な名前$になる。
◎
If the element generates a principal box, the element is an anchor element, with a list of anchor names as specified. Each anchor name is a tree-scoped name.
</dd>
	<dd>
他の場合、
この~propによる効果は無い。
◎
Otherwise, the property has no effect.
</dd>
</dl>

<p>
`~anchor名$は、
一意になる必要はない。
すべての要素が［
所与の有位置な要素~用の`~anchor要素$になる能力
］を有するとは限らないので、
各利用に対する視野が適切に絞られていれば，同じ名前を複数の箇所で再利用できる。
当の要素が［
`~style封込め$／`~layout封込め$
］を伴う場合、
`anchor-name$p ~propは`視野~付き~prop$になり，
その`視野は下位treeに絞られ＠~CSSCONTAIN#property-scoped-to-a-sub-tree$る。
［
所与の`~anchor名$を伴う妥当な`~anchor要素$
］が複数個ある場合、
【`~tree順序$で】最後のものが選ばれる。
◎
Anchor names do not need to be unique. Not all elements are capable of being anchor elements for a given positioned element, so a name can be reused in multiple places if the usages are scoped appropriately. If the element has either style containment or layout containment, the anchor-name property is scoped to a subtree. If there are still multiple valid anchor elements with the given anchor name, the last one is chosen.
</p>

			<section id="implicit">
<h4 title="Implicit Anchor Elements">2.1.1. 暗黙的な~anchor要素</h4>

<p>
一部の仕様は、
ある種の状況下で［
特定0の要素が，所与の有位置な要素~用の
`暗黙的な~anchor要素@
になる
］ものと定義し得る。
◎
Some specifications can define that, in certain circumstances, a particular element is an implicit anchor element for a given positioned element.
</p>

<p class="example">
<span class="issue">
未策定：`新たな~popover＠#_popover-api$に関係する詳細で，この箇所を埋める。
</span>
これは、
そのように宣言された要素が［
`anchor^a 属性を有する要素~用の`暗黙的な~anchor要素$
］になるようにする。
◎
TODO fill in new popover-related details. This makes the declared element the implicit anchor element for the element with the attribute.
</p>

<p>
`暗黙的な~anchor要素$は、
何らかの `anchor-name$p 値ではなく，
`implicit$vA ~keywordで参照できる。
◎
Implicit anchor elements can be referenced with the implicit keyword, rather than referring to some anchor-name value.
</p>

<p>
`疑似要素$の`暗黙的な~anchor要素$は、
他が指定されない限り，その`出自の要素$のそれと同じになるとする。
◎
Pseudo-elements have the same implicit anchor element as their originating element, unless otherwise specified.
</p>

<p class="note">注記：
これらの疑似要素は，他の仕様により~access可能でないことが多いので、
このようにしないと，これらを`暗黙的な~anchor要素$で位置することができなくなる。
◎
Note: Without this, these pseudo-elements, which are often inaccessible by other specifications, cannot be positioned with implicit anchor elements.
</p>

			</section>
		</section>
		<section id="anchor-scope">
<h3 title="Scoping Anchor Names: the anchor-scope property">2.2. ~anchor名の視野-法： `anchor-scope^p ~prop</h3>

◎名 `anchor-scope@p
◎値 `none^v | `all^v | `dashed-ident$t#
◎初 `none^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
この~propは、
指定された`~anchor名$たちの視野を絞る
— その検索を当の要素の下位treeに限るよう。
`§ ~anchorの決定-法＠#determining$
を見よ。
◎
This property scopes the specified anchor names, and lookups for these anchor names, to this element’s subtree. See § 2 Determining the Anchor.
</p>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt>`none@v</dt>
	<dd>
`~anchor名$の視野における変更は無い。
◎
No changes in anchor name scope.
</dd>

	<dt>`all@v</dt>
	<dd>
<p>
［
当の要素, その各~子孫
］により定義される どの`~anchor名$ %~anchor名 に対しても：
</p>
		<ul>
			<li>
<p>
%~anchor名 を視野に入れるものは†、
当の要素の子孫に限るものと指定する
— %~anchor名 の視野が［
すでに，ある子孫により `anchor-scope$p を利用して制限されていない
］ならば。
</p>

<p class="trans-note">【†
すなわち、
%~anchor名 を通して［
当の要素／その子孫
］を~targetにするもの。
】【
言い換えれば、
所与の %要素 に対し，
`~target~anchor要素$( %要素, %~anchor名 )
の結果が［
当の要素／その子孫
］になるならば、
%要素 は当の要素の子孫になる。
】</p>
			</li>
			<li>
<p>
当の要素の子孫が %~anchor名 を照合する対象†は、
当の要素の下位treeの中††にある`~anchor要素$に限るよう制限する。
</p>

<p class="trans-note">【†
すなわち、
子孫が %~anchor名 を通して~targetにするもの。
】【††
当の要素も含まれる。
】【
言い換えれば、
`~target~anchor要素$( 子孫, %~anchor名 )
の結果は，［
当の要素／その子孫
］になる。
】</p>
			</li>
		</ul>
◎
Specifies that all anchor names defined by this element or its descendants—​whose scope is not already limited by a descendant using anchor-scope—​to be in scope only for this element’s descendants; and limits descendants to only match anchor names to anchor elements within this subtree.
</dd>

	<dt id="valdef-anchor-scope-dashed-ident">`dashed-ident$t#</dt>
	<dd>
対象になる`~anchor名$が［
所与の `dashed-ident$t いずれかに合致するもの
］に限られることを除いて，
`all$v と同じにふるまう。
◎
Specifies that a matching anchor name defined by this element or its descendants—​whose scope is not already limited by a descendant using anchor-scope—​to be in scope only for this element’s descendants; and limits descendants to only match these anchor names to anchor elements within this subtree.
</dd>
</dl>

<p>
この~propには、
`暗黙的な~anchor要素$に対する効果は無い。
◎
This property has no effect on implicit anchor elements.
</p>

<div class="example">
<p>
ある設計~patternが再利用され，
互いに一致する複数の~componentがあるとき、
`anchor-scope$p は，それらに またがる命名の衝突を防止できる。
例えば、
ある~listが各~list~item内に有位置な要素を包含していて，
それらの要素は［
各自が属する~list~itemに相対的に位置する
］よう求まれるとする：
◎
When a design pattern is re-used, anchor-scope can prevent naming clashes across identical components. For example, if a list contains positioned elements in each list item, which want to position themselves relative to the list item they’re in,
</p>

<pre class="lang-css">
li {
  anchor-name: --list-item;
  anchor-scope: --list-item;
}
li .positioned {
  position: absolute;
  anchor-default: --list-item;
  inset-area: inline-start;
}
</pre>

<p>
`anchor-scope$p を伴わない下では、
どの `li$e 要素も，
【それに指定された`~anchor名$は】これら有位置な要素~すべてから可視になる
— その結果、
すべてが`最後の^em `li$e に相対的に位置され，そこへ積層される。
◎
Without anchor-scope, all of the li elements would be visible to all of the positioned elements, and so they’d all positioned themselves relative to the final li, stacking up on top of each other.
</p>
</div>

		</section>
		<section id="target">
<h3 title="Finding an Anchor">2.3. ~anchorの見出法</h3>

<p>
この仕様~内のいくつかのものは、
所与の`~anchor指定子$から`~target~anchor要素$を見出す。
`~anchor指定子@
は、
次に挙げるいずれかである
⇒＃
`dashed-ident$t ／
~keyword `implicit$vA ／
ε （指定子は欠落である）
◎終
`dashed-ident$t は、
~page上の他所における `anchor-name$p 値に合致するべき名前であり，
`~tree視野な参照$である。
◎
Several things in this specification find a target anchor element, given an anchor specifier, which is either a &lt;dashed-ident&gt; (and a tree-scoped reference) that should match an anchor-name value elsewhere on the page, or the keyword implicit, or nothing (a missing specifier).
</p>

<div class="algo">
<p>
`~target~anchor要素@
【略して “~anchor先（ `anchored^en ）” とも称される】
を決定するときは、
所与の
( 【`絶対的に位置され$た】~queryしている要素 %~query要素, `~anchor指定子$ %指定子 （省略時は ε） )
に対し：
◎
To determine the target anchor element given a querying element query el and an optional anchor specifier anchor spec:
</p>
<ol>
	<li>
~IF［
%指定子 ~EQ ε
］
⇒
~RET `~target~anchor要素$( %~query要素, %~query要素 の`既定の~anchor指定子$ )
◎
If anchor spec was not passed, return the target anchor element for query el given the query el’s default anchor specifier.
</li>
	<li>
<p>
~IF［
%指定子 ~EQ `implicit$vA
］：
◎
If anchor spec is implicit:
</p>
		<ol>
			<li>
<p>
~IF［
`Popover API^cite †は、
%~query要素 用に`暗黙的な~anchor要素$ %~anchor要素 を定義している
］~AND［
%~anchor要素 は %~query要素 用に`受容-可能な~anchor要素$である
］
⇒
~RET %~anchor要素
◎
If the Popover API defines an implicit anchor element for query el which is an acceptable anchor element for query el, return that element.
</p>

<p class="trans-note" id="_popover-api">【
`Popover API^cite は、
`HTML$r に定義される`~popover＠~HTMLpopover$を指すと思われる
— そこでは、
`暗黙的な~anchor要素$について（まだ）何も述べていないが
（`関係していそうな課題＠~HTMLissue/9311$）。
】</p>

			</li>
			<li>
~RET ε（該当する要素は無い）
◎
Otherwise, return nothing.
</li>
		</ol>

<p class="note">注記：
【上では `Popover API^cite に限って取扱っているが、】
将来の~APIは、
暗黙的な~anchor要素を定義するかもしれない。
そうなったときは、
他との協調を確保するよう，
この~algo内で明示的に取扱われることになる。
◎
Note: Future APIs might also define implicit anchor elements. When they do, they’ll be explicitly handled in this algorithm, to ensure coordination.
</p>

	</li>
	<li>
~Assert：
%指定子 は `dashed-ident$t である。
◎
Otherwise, anchor spec is a &lt;dashed-ident&gt;.＼
</li>
	<li>
<p>
%~anchor要素~群 ~LET 次を満たす`~anchor要素$ %要素 たちが成す集合
⇒
［
%指定子 ~IN %要素 の`~anchor名$たちが成す集合
］~AND［
%要素 の`~anchor名$たちに結付けられた`~tree$【！の`根$】
~EQ
%指定子 に結付けられた`~tree$【！の`根$】
］
</p>

<p class="note">注記：
`~anchor名$は`~tree視野な名前$である一方、
%指定子 は`~tree視野な参照$である。
</p>
◎
Return the last element el in tree order that satisfies the following conditions:
• el is an anchor element with an anchor name of anchor spec.
• el’s anchor name and anchor spec are both associated with the same tree root.
• Note: The anchor name is a tree-scoped name, while anchor spec is a tree-scoped reference.
• el is an acceptable anchor element for query el.
</li>
	<li>
%~anchor要素~群 を成す
~EACH( %要素 )
に対し，`~tree順序$の逆順で
⇒
~IF［
%要素 は %~query要素 用の`受容-可能な~anchor要素$である
］
⇒
~RET %要素
◎
↑</li>
	<li>
<p>
~RET ε
（該当する要素は無い）
◎
If no element satisfies these conditions, return nothing.
</p>

<p class="note">注記：
`anchor-scope$p は、
ある種の`~anchor名$の可視性を制約し得る
— それは、
所与の検索において，どの要素が`~anchor要素$になり得るかに影響し得る。
◎
Note: anchor-scope can restrict the visibility of certain anchor names, which can affect what elements can be anchor elements for a given lookup.
</p>

<p class="trans-note">【
この注記は、
この手続きの中では，
“〜に結付けられた`~tree$”
として反映されているものと見受けられる。
】</p>
	</li>
</ol>

<p class="note">注記：
これらの条件【どれ？】により捕捉される一般~規則は、［
【結果の？】
%要素 は %~query要素 が~lay-outされる前に全部的に~lay-outされなければならない
【~lay-outする必要が生じるようになる？】
］ことである。
~CSSにおける［
積層~文脈の~layout順序
］用の規則は、
このことについて確証を与える
— 上に挙げた条件たちは、［
~anchor位置決めにおいて，循環依存が生じ得ない
］ことを確保するよう，ちょうど［
積層~文脈~用の規則のうち，この目的に関連なもの
］だけを言い直したものである。
◎
Note: The general rule captured by these conditions is that el must be fully laid out before query el is laid out. CSS’s rules about the layout order of stacking contexts give us assurances about this, and the list of conditions above exactly rephrases the stacking context rules into just what’s relevant for this purpose, ensuring there is no possibly circularity in anchor positioning.
</p>
</div>

<p class="note">注記：
ある`~shadow~tree$内の~style内の `anchor-name$p により定義された`~anchor名$は、
異なる`~shadow~tree$内の~style内の`~anchor関数$からは見えない
（~capsule化を保全するため）。
しかしながら，異なる`~shadow~tree$内にある`要素どうし^emであっても、［
`~anchor名$, `~anchor関数$
］どちらも
— ある~shadowの内側にある要素を `part()$pe を利用して~styleするなどにより —
同じ~tree内の~styleから来ているならば，互いに他を~anchorできる。
（`暗黙的な~anchor要素$は，内在的には単独の~treeに制限されないが、
その詳細は，それをアテガっている~APIに依存することになる。）
◎
Note: An anchor-name defined by styles in one shadow tree won’t be seen by anchor functions in styles in a different shadow tree, preserving encapsulation. However, elements in different shadow trees can still anchor to each other, so long as both the anchor-name and anchor function come from styles in the same tree, such as by using ::part() to style an element inside a shadow. (Implicit anchor elements also aren’t intrinsically limited to a single tree, but the details of that will depend on the API assigning them.)
</p>

<div class="algo">
<p>
所与の
( %要素, `絶対的に位置され$た要素 %~query要素 )
に対し，
%要素 は %~query要素 用の
`受容-可能な~anchor要素@
であるとは、
~AND↓ が満たされることをいう
— 以下における %包含塊 は、
%~query要素 の`包含塊$とする：
◎
An element el is a acceptable anchor element for an absolutely positioned element query el if all of the following are true:
</p>
<ul>
	<li>
%包含塊 ~IN %要素 の`包含塊~連鎖$
◎
Either el is a descendant of query el’s containing block, or query el’s containing block is the initial containing block.
</li>
	<li>
<p>
%~box は［
%要素 の`包含塊$ ~EQ %包含塊 ならば %要素 【の`首要~box$】／
~ELSE_ %要素 の`包含塊~連鎖$を成す`包含塊$のうち %包含塊 に達する前の最後のもの【を確立した~box】
］とするとき、
%~box は ~OR↓ を満たす
</p>
		<ul>
			<li>
`絶対的に位置され$ていない
</li>
			<li>
~tree順序において %~query要素 【の`首要~box$】に先行する
</li>
		</ul>
◎
If el has the same containing block as query el, then either el is not absolutely positioned, or el precedes query el in the tree order.
◎
If el has a different containing block from query el, then the last containing block in el’s containing block chain before reaching query el’s containing block is either not absolutely positioned or precedes query el in the tree order.
</li>
	<li>
<p>
%要素 は`要素$または［
`要素$の様に動作する`疑似要素$
］である
◎
el is either an element, or a pseudo-element that acts like one.
</p>

<p class="issue">
このことを実際に意味する用語を定義する必要がある
— ［
`before^pe, `after^pe, `backdrop^pe, 等々
］いずれかには合致するが，
検出-可能な~boxは無い［
`marker^pe, `placeholder^pe, 等々
］には合致しないような。
◎
define the term that actually means this, matching ::before/after/backdrop/etc (but not ::marker/placeholder/etc whose box is not detectable).
</p>
	</li>
</ul>
</div>

		</section>
		<section id="anchor-default">
<h3 title="Default Anchors: the anchor-default property">2.4. 既定の~anchor： `anchor-default^p ~prop</h3>

◎名 `anchor-default@p
◎値 `anchor-element$t
◎初 `implicit^v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`anchor-default$p ~propは、
当の要素~上のすべての`~anchor関数$用の
`既定の~anchor指定子@
を定義する
— それは、
次を許容する
⇒
複数の要素が，同じ［
`~anchor関数$たちが成す集合,
`位置~option~list$
］を利用しながら，
各自が参照rしている`~anchor要素$を変更する。
◎
The anchor-default property defines the default anchor specifier for all anchor functions on the element, allowing multiple elements to use the same set of anchor functions (and position options lists!) while changing which anchor element each is referring to.
</p>

<p>
`絶対的に位置され$た要素の
`既定の~anchor要素@
は、
`既定の~anchor指定子$により選定される~anchor要素
— すなわち，次の結果を指す
⇒
`~target~anchor要素$( 当の要素 )
◎
The target anchor element selected by the default anchor specifier (if one exists) is the element’s default anchor element.
</p>

<p>
とり得る値は、［
`anchor$f ／ `anchor-size$f
］における `anchor-element$t と一致する。
◎
Its values are identical to the &lt;anchor-element&gt; term in anchor() and anchor-size().
</p>

<div class="example">
<p>
例えば，次の~codeにおける［
`.foo^css, `.bar^css
］要素は、
各自が参照rしている~anchor要素だけを変更しながら，どちらも同じ位置決め~propたちを利用できる：
◎
For example, in the following code both .foo and .bar elements can use the same positioning properties, just changing the anchor element they’re referring to:
</p>

<pre class="lang-css">
.anchored {
  position: absolute;
  top: calc(.5em + anchor(outside));
  /* <span class="comment">
この `anchor^f は、
`~anchor名$【`~anchor指定子$】を指定していないので，
自動的に`既定の~anchor要素$を参照rする。
◎
Since no anchor name was specified, this automatically refers to the default anchor element.
</span> */
}

.foo.anchored {
  anchor-default: --foo;
}
.bar.anchored {
  anchor-default: --bar;
}
</pre>
</div>

		</section>
	</section>
	<section id="positioning">
<h2 title="Anchor-Based Positioning">3. ~anchorに基づく位置決め</h2>

<p>
`絶対的に位置され$た要素は、
自身を~pageの 1 個以上の`~anchor要素$に相対的に位置できる。
◎
An absolutely-positioned element can position itself relative to one or more anchor elements on the page.
</p>

<p>
`inset-area$p ~prop【！function】は、
`既定の~anchor要素$に相対的な位置決め用に，簡便な格子に基づく概念を提供する
— ［
より複階的な位置決め／
複数個の要素に相対的な位置決め
］用には、
`~inset~prop$において［
`~anchor要素$の辺を明示的に参照rする `anchor$f 関数
］を利用できる。
◎
The inset-area function offers a convenient grid-based concept for positioning relative to the default anchor element; for more complex positioning or positioning relative to multiple elements, the anchor() function can be used in the inset properties to explicitly refer to edges of an anchor element.
</p>

		<section id="inset-area">
<h3 title="The inset-area Property">3.1. `inset-area^p ~prop</h3>

◎名 `inset-area@p
◎値 `none$vI | `inset-area$t
◎初 `none$vI
◎適 `既定の~anchor要素$を伴う有位置な要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア （未策定）
◎表終

<p>
~anchor位置決めに共通的な利用事例では、［
有位置な要素の`包含塊$の各~辺,
`既定の~anchor要素$の各~辺
］以外は気にする必要がない場合がほとんどである。
これらの線（辺）は、
縦横とも 3 分された格子
— `~inset区画~用の格子$ —
を定義しているものと捉えれる。
`inset-area$p は、
`~inset区画$
— 有位置な要素を［
この格子を成す どの区画~内に置くことが求まれるか
］ —
を指定することにより，
有位置な要素の`~inset~prop$を容易に設定しておけるようにする。
その構文は：
◎
Most common use-cases of anchor positioning only need to worry about the edges of the positioned element’s containing block, and the edges of the default anchor element. These lines can be thought of as defining a 3x3 grid; inset-area lets you easily set up the positioned element’s inset properties by specifying what area of this inset-area grid you want the positioned element to be in. Its syntax is:
</p>

<pre class="prod">
`inset-area@t
	= Ⓐ || Ⓑ
	| Ⓒ || Ⓓ
	| Ⓔ{1,2}
	| Ⓕ{1,2}
Ⓐ
	= left
	| center
	| right
	| span-left
	| span-right
	| x-start
	| x-end
	| span-x-start
	| span-x-end
	| x-self-start
	| x-self-end
	| span-x-self-start
	| span-x-self-end
	| span-all
Ⓑ
	= top
	| center
	| bottom
	| span-top
	| span-bottom
	| y-start
	| y-end
	| span-y-start
	| span-y-end
	| y-self-start
	| y-self-end
	| span-y-self-start
	| span-y-self-end
	| span-all
Ⓒ
	= block-start
	| center
	| block-end
	| span-block-start
	| span-block-end
	| self-block-start
	| self-block-end
	| span-self-block-start
	| span-self-block-end
	| span-all
Ⓓ
	= inline-start
	| center
	| inline-end
	| span-inline-start
	| span-inline-end
	| self-inline-start
	| self-inline-end
	| span-self-inline-start
	| span-self-inline-end
	| span-all
Ⓔ
	= start
	| center
	| end
	| span-start
	| span-end
	| span-all
Ⓕ
	= self-start
	| center
	| self-end
	| span-self-start
	| span-self-end
	| span-all
</pre>

<p class="trans-note">【
ⒶⒷⒸⒹⒺⒻ は、
簡明にするための，この訳による追加。
】</p>

<dl class="valdef">
	<dt>`none@vI</dt>
	<dd>
この~propによる効果は無い。
◎
The property has no effect.
</dd>

	<dt id="valdef-inset-area-inset-area">`inset-area$t</dt>
	<dd>
<p>
当の要素が ~OR↓ を満たす場合、
この値による効果は無い：
</p>
		<ul>
			<li>
その`既定の~anchor要素$ ~EQ ε
</li>
			<li>
`絶対的に位置され$ていない
</li>
		</ul>
◎
If the element does not have a default anchor element, or is not an absolutely-positioned element, this value has no effect.
</dd>
	<dd>
<p>
他の場合：
◎
Otherwise,＼
</p>
		<ul>
			<li>
<p>
この~propは、
`~inset区画$を指定する
— それが、
当の要素の`包含塊$になる。
◎
the property selects a region of the inset-area grid, and makes that the element’s containing block.
</p>

<div class="note">
<p>注記：
このことは、
次を意味する：
</p>
				<ul>
					<li>
`~inset~prop$は、
`~inset区画$からの~offsetを指定する。
</li>
					<li>
一部の~prop用の一部の値
— `max-height: 100%$p など —
は、
`~inset区画$に相対的になる
</li>
				</ul>
◎
Note: This means that the inset properties specify offsets from the inset-area, and some property values, like max-height: 100%, will be relative to the inset-area as well.
</div>
			</li>
			<li>
`自己-整列~prop$用の値 `normal$vS は、
当の有位置な要素~用に良い既定の整列を与えるため，［
`start$vS,
`end$vS,
`anchor-center$vS
］いずれかとして挙動する
（`~inset区画$が占める位置に依存する）。
詳細は、
<a href="#resolving-spans">§ `inset-area^t の解決-法</a>
を見よ。
◎
Additionally, the normal value for the self-alignment properties behaves as either start, end, or anchor-center, depending on the positioning of the region, to give a good default alignment for the positioned element.
◎
See § 3.1.1 Resolving &lt;inset-area&gt;s for details on both of these effects.
</li>
			<li>
`~inset~prop$用の値 `auto$v は `0^v に解決される。
◎
Also, any auto inset properties resolve to 0.
</li>
		</ul>
	</dd>
</dl>

			<section id="resolving-spans">
<h4 title="Resolving &lt;inset-area&gt;s">3.1.1. `inset-area^t の解決-法</h4>

<p>
所与の要素 %要素 の
`~inset区画~用の格子@
は、
縦横とも 3 分された格子である
— それは、
軸ごとに，次に挙げる 4 本の線から構成される：
◎
The inset-area grid is a 3x3 grid, composed of four grid lines in each axis. In order:
</p>

<ul>
	<li>
<p>
次のうち，より`始端$寄りにある方：
</p>
		<ul>
			<li>
%要素 の［
改変される前の`包含塊$
］の始端~辺
</li>
			<li>
%要素 の`既定の~anchor要素$の `anchor(start)^v【！`anchor-start()^v】 辺
</li>
		</ul>
◎
the start edge of the element’s pre-modification containing block, or the anchor-start() edge of the default anchor element if that is more start-ward
</li>
	<li>
%要素 の`既定の~anchor要素$の `anchor(start)^v 辺
◎
the anchor(start) edge of the default anchor element
</li>
	<li>
%要素 の`既定の~anchor要素$の `anchor(end)^v 辺
◎
the anchor(end) edge of the default anchor element
</li>
	<li>
<p>
次のうち，より`終端$寄りにある方：
</p>
		<ul>
			<li>
%要素 の［
改変される前の`包含塊$
］の終端~辺
</li>
			<li>
%要素 の`既定の~anchor要素$の `anchor(end)^v【！`anchor-start()^v】 辺
</li>
		</ul>
◎
the end edge of the element’s pre-modification containing block, or the anchor-start() edge fo the default anchor element if that is more end-ward.
</li>
</ul>

<p>
`inset-area$t は、
この格子を成すある領域
—
`~inset区画@
—
を［
それが占める［
~rowたち, ~colたち
］を指定する
］ことにより選定する
【区画は，それらの交差域になる】。
各~keywordは、［
~row（たち）, ~col（たち）
］どちらかを指定する：
◎
An &lt;inset-area&gt; selects a region of this grid by specifying the rows and columns the region occupies, with each of the two keywords specifying one of them:
</p>

<dl>
	<dt>`start@vI</dt>
	<dt>`end@vI</dt>
	<dt>`self-start@vI</dt>
	<dt>`self-end@vI</dt>

	<dt>`top@vI</dt>
	<dt>`bottom@vI</dt>
	<dt>`left@vI</dt>
	<dt>`right@vI</dt>

	<dt>`y-start@vI</dt>
	<dt>`y-end@vI</dt>
	<dt>`y-self-start@vI</dt>
	<dt>`y-self-end@vI</dt>

	<dt>`x-start@vI</dt>
	<dt>`x-end@vI</dt>
	<dt>`x-self-start@vI</dt>
	<dt>`x-self-end@vI</dt>

	<dt>`block-start@vI</dt>
	<dt>`block-end@vI</dt>
	<dt>`block-self-start@vI</dt>
	<dt>`block-self-end@vI</dt>

	<dt>`inline-start@vI</dt>
	<dt>`inline-end@vI</dt>
	<dt>`inline-self-start@vI</dt>
	<dt>`inline-self-end@vI</dt>

	<dt>`center@vI</dt>
	<dd>
<p>
1 個の［
~row／~col
］を占める：
</p>
		<ul>
			<li>
<p>
参照rする軸（［
~row, ~col
］どちらを占めるか）は：
</p>
				<ul>
					<li>
当の~keywordが ある軸を指定する場合、
それになる
（例： `block-start$vI は、
`塊-軸$を参照rする）。
</li>
					<li>
他の場合、
下に述べる。
</li>
				</ul>
			</li>
			<li>
3 個ある［
~row／~col
］のうち どれを占めるかは、
当の~keywordにより指示される
（例： ~keywordが `start^v を含むなら “始端”, 等々）。
</li>
			<li>
<p>
どの側が［
“始端” ／ “終端”
］とされるかは、
次に基づく：
</p>
				<ul>
					<li>
`self^v を含む~keyword用には、
当の要素の自前の`書字~mode$
</li>
					<li>
他~keyword用には、
当の要素の`包含塊$の`書字~mode$
</li>
				</ul>
			</li>
		</ul>
◎
The single corresponding row or column, depending on which axis this keyword is specifying.
◎
Like in anchor(), the plain logical keywords (start, end, etc) refer to the writing mode of the element’s containing block. The x-start/etc determine their direction in the same way, but in the specified physical axis.
◎
The "self" logical keywords (self-start, x-self-end, etc) are identical, but refer to the element’s own writing mode.
</dd>


	<dt>`span-start@vI</dt>
	<dt>`span-end@vI</dt>

	<dt>`span-top@vI</dt>
	<dt>`span-bottom@vI</dt>

	<dt>`span-y-start@vI</dt>
	<dt>`span-y-end@vI</dt>

	<dt>`span-x-start@vI</dt>
	<dt>`span-x-end@vI</dt>

	<dt>`span-block-start@vI</dt>
	<dt>`span-block-end@vI</dt>

	<dt>`span-inline-start@vI</dt>
	<dt>`span-inline-end@vI</dt>
	<dd>
中央にある［
~row／~col
］も占めることを除いて，［
当の~keywordから `span-^v を除去した~keyword
］と同じになる
（例： `span-top$vI は、［
中央, 上端
］を占める）。
◎
Two rows or columns, depending on which axis this keyword is specifying: the center row/column, and the row/column corresponding to the other half of the keyword as per the single-track keywords.
◎
(For example, span-top spans the first two rows—​the center row and the top row.)
</dd>

	<dt>`span-all@vI</dt>
	<dd>
3 個~すべての［
~row／~col
］を占める。
◎
All three rows or columns,＼
↓↓ depending on which axis this keyword is specifying.
</dd>
</dl>

<div class="p">
<p>
~keywordには、
どの軸を参照rするか多義的なものがある
（ `center$vI, `span-all$vI, `start$vI, 等々）
— それらが参照rする軸は：
</p>
<ul>
	<li>
他方の~keywordが ある軸を指定する場合
⇒
もう一方の軸になる
（例： `block-start center^v を成す~keyword `center^v は、
`行内-軸$を参照rする）。
</li>
	<li>
他の場合
⇒
順に，要素の`包含塊$の［
`塊-軸$, `行内-軸$
］を参照rする
（例：`span-all start^v は `span-all inline-start^v と等価になる）。
</li>
</ul>
◎
Some keywords are ambiguous about what axis they refer to: center, span-all, and the start/etc keywords that don’t specify the block or inline axis explicitly. If the other keyword is unambiguous about its axis, then the ambiguous keyword is referring to the opposite axis. (For example, in block-start center, the center keyword is referring to the inline axis.) If both keywords are ambiguous, however, then the first refers to the block axis of the element’s containing block, and the second to the inline axis. (For example, span-all start is equivalent to span-all inline-start.)
</div>

<div class="p">
<p>
~keywordが 1 個だけ与えられた場合：
</p>
<ul>
	<li>
所与の~keywordが ある軸を指定する場合
⇒
2 個目の~keywordは `span-all$vI であったかのように挙動する
（例： `top$vI は `top span-all^v と等価になる）。
</li>
	<li>
他の場合
⇒
所与の~keywordが繰返されたかのように挙動する
（例： `center$vI は `center center^v と等価になる）。
</li>
</ul>
◎
If only a single keyword is given, it behaves as if the second keyword is span-all if the given keyword is unambigous about its axis; otherwise, it behaves as if the given keyword was repeated. (For example, top is equivalent to top span-all, but center is equivalent to center center.)
</div>

<hr>

<p>
`inset-area$t は、
既定の`自己-整列$も含意する
— それは、
当の要素の`自己-整列~prop$が `normal$vS をとる場合に利用されることになる。
すなわち、
所与の軸 %軸 における既定の整列は：
◎
The &lt;inset-area&gt; also implies a default self-alignment, which will be used if the self-alignment property on the element is normal:
</p>
<ul>
	<li>
`~inset区画$が %軸 において “中央” 領域を含む場合
⇒
`anchor-center$vS になる。
◎
If the inset area includes the center region in an axis the default alignment in that axis is anchor-center.
</li>
	<li>
他の場合
⇒
`~inset区画$が指定する領域の反対-側になる
— %軸 において “始端” 領域が指定されたならば `end$vS になる，等々。
◎
Otherwise, it’s the opposite of the region it specifies: if it’s specifying the "start" region of its axis, the default alignment in that axis is end; etc.
</li>
</ul>

<div class="example">
<p>
例えば，`書字~mode$が英語と等価である（ `horizontal-tb^v, `ltr^v ）と見做すなら、
値 `span-x-start top^v は［
【 `top^v により指定される】縦~軸における “始端” 領域,
【 `span-x-start^v により指定される】横~軸における［
“始端”, “中央”
］領域
］に解決される。
なので、
既定の整列は，［
`align-self: end$p,
`justify-self: anchor-center$p
］になる。
◎
For example, assuming an English-equivalent writing mode (horizontal-tb, ltr), then the value span-x-start top resolves to the "start" region of the vertical axis, and the "start" and "center" regions of the horizontal axis, so the default alignments will be align-self: end; and justify-self: anchor-center;
</p>

<figure>
<figcaption id="_dgm-inset-area-example">
`inset-area:span-x-start top$p による位置決めの例。
◎
An example of inset-area: span-x-start top positioning. 
</figcaption></figure></div>


<p class="note">注記：
`既定の~anchor要素$が当の要素の［
改変される前の`包含塊$
］を はみ出るときは、
`~inset区画~用の格子$を成す一部の［
~row／~col
］の~sizeは， 0 になることもある。
◎
Note: When the default anchor element is partially or completely outside of the pre-modified containing block, some of the inset-area grid’s rows or columns can be zero-sized.
</p>

			</section>
		</section>
		<section id="anchor-pos">
<h3 title="The anchor() Function">3.2. `anchor^f 関数</h3>

<p>
`絶対的に位置され$る要素 %要素 は、
自身の`~inset~prop$内の値として
`anchor@f
関数を利用することにより，［
1 個以上の`~anchor要素$
］の位置を参照rできる。
`anchor$f 関数は、
`length$t に解決される。
◎
An absolutely-positioned element can use the anchor() function as a value in its inset properties to refer to the position of one or more anchor elements. The anchor() function resolves to a &lt;length&gt;.
</p>

<pre class="prod">
`anchor()^t
	= anchor( `anchor-element$t? `anchor-side$t, `length-percentage$t? )
`anchor-element@t
	= `dashed-ident$t
	| `implicit$vA
`anchor-side@t
	= `inside$vA
	| `outside$vA
	| `top$vA
	| `left$vA
	| `right$vA
	| `bottom$vA
	| `start$vA
	| `end$vA
	| `self-start$vA
	| `self-end$vA
	| `percentage$t
	| `center$vA
</pre>

<p>
`anchor$f 関数は、
3 個の引数をとる：
◎
The anchor() function has three arguments:
</p>
<ul>
	<li>
<p>
`anchor-element$t は、
`~anchor要素$を見出す方法を指定する
【すなわち、`~anchor指定子$を与える】。
%要素 の位置決め情報は、
それにより見出された`~anchor要素$
【すなわち，`~target~anchor要素$】
から引き出されることになる。
省略された場合、
【 ε と見なされ，】
%要素 の`既定の~anchor指定子$として挙動する。
◎
the &lt;anchor-element&gt; value specifies how to find the anchor element it will be drawing positioning information from. If omitted, it behaves as the element’s default anchor specifier.＼
</p>

<p>
アリな値は：
◎
Its possible values are:
</p>
		<dl>
			<dt id="valdef-anchor-dashed-ident">`dashed-ident$t</dt>
			<dd>
所与の識別子を`~anchor名$に伴う`~anchor要素$を探す。
この名前は、
`~tree視野な参照$になる。
◎
Specifies the anchor name it will look for. This name is a tree-scoped reference.
</dd>

			<dt>`implicit@vA</dt>
			<dd>
アリなら，
%要素 用に定義された`暗黙的な~anchor要素$を選定する。
◎
Selects the implicit anchor element defined for the element, if possible.
</dd>
		</dl>
<p>
詳細は、
`~target~anchor要素$を見よ。
◎
See target anchor element for details.
</p>
	</li>
	<li>
<p>
`anchor-side$t は、
`~target~anchor要素$の［
その値に対応している側
］を位置として参照rする。
以下における %~prop は、
この関数を利用している`~inset~prop$を指すとする。
アリな値は：
◎
the &lt;anchor-side&gt; value refers to the position of the corresponding side of the target anchor element. Its possible values are:
</p>
		<dl class="valdef">
			<dt>`inside@vA</dt>
			<dt>`outside@vA</dt>
			<dd>
`inside$vA は、
`~anchor要素$の各~側のうち，
%~prop と同じ側（ %要素 を当の~anchorの “内側” に付する）を参照rするよう解決される。
`outside$vA は、
その反対-側†を参照rするよう解決される。
◎
Resolves to one of the anchor element’s sides, depending on which inset property it’s used in. inside refers to the same side as the inset property (attaching the element to the "inside" of the anchor), while outside refers to the opposite.
</dd>
			<dd class="trans-note">【†
%~prop が指示する側と反対を表すのか（例： %~prop が `top^p なら下端），
“内側” の反対を表す “外側” なのかはっきりしない。
~keywordの意味は後者を示唆しているが。
】</dd>

			<dt>`top@vA</dt>
			<dt>`right@vA</dt>
			<dt>`bottom@vA</dt>
			<dt>`left@vA</dt>
			<dd>
`~anchor要素$の［
所与の~keywordにより指定された側
］を参照rする。
◎
Refers to the specified side of the anchor element.
</dd>
			<dd class="note">注記：
これらの~keywordが利用-可能になるのは、
~keywordが属する軸が %~prop が属する軸と合致している場合に限られる。
例えば， `left$vA を利用-可能な~propは、
横~軸に属する`~inset~prop$
— `left$p, `right$p, これらと同じ側に対応する~flow相対な~prop —
に限られる。
◎
Note: These are only usable in the inset properties in the matching axis. For example, left is usable in left, right, or the logical inset properties that refer to the horizontal axis.
</dd>
			<dd class="trans-note">【
これらは、
“物理-~keyword” とも総称される。
】</dd>

			<dt>`start@vA</dt>
			<dt>`end@vA</dt>
			<dt>`self-start@vA</dt>
			<dt>`self-end@vA</dt>
			<dd>
`~anchor要素$の各~側のうち，
%~prop と同じ軸に属するいずれかを参照rする
【例： %~prop が `top$p ならば上端か下端】
— 所与の~keywordに応じて，
⇒＃
［ `self-start$vA ／ `self-end$vA ］ならば，当の有位置な要素／
［ `start$vA ／ `end$vA ］ならば，当の有位置な要素の包含塊
◎終
の`書字~mode$を基準に解決することにより。
◎
Refers to one of the sides of the anchor element in the same axis as the inset property it’s used in, by resolving the keyword against the writing mode of either the positioned element (for self-start and self-end) or the positioned element’s containing block (for start and end).
</dd>
			<dd class="trans-note">【
これらは、
“論理-~keyword” とも総称される。
】</dd>

			<dt id="valdef-anchor-percentage">`percentage$t</dt>
			<dt>`center@vA</dt>
			<dd>
［
`start$vA 側, `end$vA 側
］の合間における所与の百分率に対応する位置を参照rする
— ［
`0%^v ／ `100%^v
］は［
`start^v ／ `end^v
］と等価になる。
◎
Refers to a position a corresponding percentage between the start and end sides, with 0% being equivalent to start and 100% being equivalent to end.
</dd>
			<dd>
`center$vA は、
`50%^v と等価になる。
◎
center is equivalent to 50%.
</dd>
		</dl>
	</li>
	<li>
省略可能な 3 個目の引数 `length-percentage$t は、
~fallback値を与える。
これは、
当の `anchor$f が`妥当な~anchor関数$でない場合に，何に解決するべきかを指定する。
◎
the optional &lt;length-percentage&gt; final argument is a fallback value, specifying what the function should resolve to if it’s an invalid anchor function.
</li>
</ul>

<p class="issue">
`anchor$f 関数の算出d値は、
おそらく，［
その`~target~anchor要素$を解決した結果の `anchor$f
］になる必要がある。
これは、
遷移が［
`~tree視野な名前$と伴に／~anchor要素が変化するときに
］適正に働くことを許容する。
`8180$issue を見よ。
◎
Computed value for anchor() probably needs to be the anchor() function, but with the target anchor element resolved. This allows for transitions to work properly with tree-scoped names, and with changing anchor elements. See Issue 8180.
</p>

<p>
`anchor$f 関数は、
`妥当な~anchor関数$を表現しているならば，
`使用~値$の時点で， `length$t に解決される
— ［
当の有位置な要素の`~insetで改変された包含塊$
］の［
当の関数が現れる~propに対応している辺
］を［
`~target~anchor要素$の指定された~border辺
］に整列するような。
そのときには、［
`~target~anchor要素$と当の有位置な要素の`包含塊$の合間にある`~scroll容器$
］は，どれも［
各自の初期~scroll位置に~scrollされている
］と見做される
（が、
`§ ~scrollの織り込み法＠#scroll$
を見よ）。
◎
An anchor() function representing a valid anchor function resolves at used value time to the &lt;length&gt; that would align the edge of the positioned elements' inset-modified containing block corresponding to the property the function appears in with the specified border edge of the target anchor element, assuming that all scroll containers between the target anchor element and the positioned element’s containing block are scrolled to their initial scroll position (but see § 3.4 Taking Scroll Into Account).
</p>

<p>
`~target~anchor要素$が`断片$化されている場合、［
各~断片の~border~box
］たちが成す限界~矩形
— それらの~boxと軸が揃えられた矩形 —
が代わりに利用される。
◎
If the target anchor element is fragmented, the axis-aligned bounding rectangle of the fragments' border boxes is used instead.
</p>

<p class="issue">
［
~padding辺／内容~辺
］にも整列できるよう，［
どの~boxを参照rするか
］も制御する必要はあるか？
◎
Do we need to control which box we’re referring to, so you can align to padding or content edge?
</p>

<p>
加えて，有位置な要素は、
その`~snapshot済み~scroll~offset$により視覚的にズラされる
— 追加的な `translate$f 変形によりズラされたかのように。
◎
The positioned element is additionally visually shifted by its snapshotted scroll offset, as if by an additional translate() transform.
</p>

<div class="example">
<p>
例えば，
`.bar { top: anchor(--foo top); }^css
においては、
`anchor$f は，［
`.bar^css 要素の上端~辺と`~anchor要素$ `--foo^v の上端~辺が揃うような長さ
］に解決されることになる。
◎
For example, in .bar { top: anchor(--foo top); }, the anchor() will resolve to the length that’ll line up the .bar element’s top edge with the --foo anchor’s top edge.
</p>

<p>
他方，
`.bar { bottom: anchor(--foo top); }^css
においては、［
`.bar^css 要素 の`下端^em辺と`~anchor要素$ `--foo^v の上端~辺が揃うような長さ
］に解決されることになる。
◎
On the other hand, in .bar { bottom: anchor(--foo top); }, it will instead resolve to the length that’ll line up the .bar element’s bottom edge with the --foo anchor’s top edge.
</p>

<p>
［
`top$p の値, `bottom$p の値
］は，異なる辺
（要素の`包含塊$の［
上端／下端
］辺）
からの~insetを指定するので、
双方の `anchor$f は同じでも，それらを解決した結果の長さは異なることになる。
◎
Since top and bottom values specify insets from different edges (the top and bottom of the element’s containing block, respectively), the same anchor() will usually resolve to different lengths in each.
</p>
</div>

<div class="example">
<p>
`anchor$f 関数は、
`length$t に解決されるので，他の長さと同様に`~math関数$内でも利用できる。
◎
Because the anchor() function resolves to a &lt;length&gt;, it can be used in math functions like any other length.
</p>

<p>
例えば，次は、［
要素の`~insetで改変された包含塊$
］が［
`~anchor要素$上で中央に寄せられ，
要素の`包含塊$を~overflowしない~~範囲でアリな限り幅広になる
］よう，要素を設定しておくことになる：
◎
For example, the following will set up the element so that its inset-modified containing block is centered on the anchor element and as wide as possible without overflowing the containing block:
</p>

<pre class="lang-css">
.centered-message {
  position: fixed;
  max-width: max-content;
  justify-self: center;

  --center: anchor(--x 50%);
  --half-distance: min(
    abs(0% - var(--center)),
    abs(100% - var(--center))
  );
  left: calc(var(--center) - var(--half-distance));
  right: calc(var(--center) - var(--half-distance));
  bottom: anchor(--x top);
}
</pre>

<p>
これは例えば、
`input$e 要素に対する~error~message用に適切になることもあろう
— 中央に寄せたことにより，当の~messageが どの入力を参照rしているか発見し易くなるので。
◎
This might be appropriate for an error message on an input element, for example, as the centering will make it easier to discover which input is being referred to.
</p>
</div>

		</section>
		<section id="anchor-center">
<h3 title="Centering on the Anchor: the anchor-center value">3.3. ~anchorの中央~寄せ： `anchor-center^v 値</h3>

◎名 `justify-self$p, `align-self$p, `justify-items$p, `align-items$p
◎新値 `anchor-center$vS
◎表終

<p>
`自己-整列~prop$は、
`絶対的に位置され$た要素が自身を`~insetで改変された包含塊$の中で整列することを許容する。
通例的には，［
既存の値に加えて，`~inset~prop$を注意深く選ぶこと
］で有用な整列~用には十分になるが、
~anchor先での位置決め用に共通的な事例
— ~anchor要素~上で中央に寄せること —
を達成するためには、
注意深い, いくぶん複階的な設定-法が要求される。
◎
The self-alignment properties allow an absolutely-positioned element to align itself within the inset-modified containing block. The existing values, plus carefully chosen inset properties, are usually enough for useful alignment, but a common case for anchored positioning—centering over the anchor element—requires careful and somewhat complex set-up to achieve.
</p>

<p>
新たな値
`anchor-center@vS
は、
この事例を極めて単純にする
— 当の要素 %要素 が［
`絶対的に位置され$た【！有位置な】要素である
］~AND［
その`既定の~anchor要素$ %~anchor要素 ~NEQ ε
］を満たす場合、
関連な軸
【この値を利用している~propが対象にする軸】
において：
◎
The new anchor-center value makes this case extremely simple: if the positioned element has a default anchor element,＼
</p>
<ul>
	<li>
%要素 が %~anchor要素 上で中央に整列されるようにする。
◎
then it is aligned so as to center itself over the default anchor element in the relevant axis.
</li>
	<li>
<p>
`~inset~prop$用の値 `auto$v は `0^v に解決される。
しかしながら，関連な軸において %要素 用に`可用な空間$は、［
~AND↓ を満たす最~大な矩形
］の~sizeに抑制される：
◎
Additionally, any auto inset properties resolve to 0. However, the available space for the positioned element in the relevant axis is reduced to the size of the largest rectangle that＼
</p>
		<ul>
			<li>
%~anchor要素 上で中央に寄せられる
【すなわち， %~anchor要素 の中心と矩形の中心は一致する】
◎
is centered on the default anchor element and＼
</li>
			<li>
【 %要素 の】`~insetで改変された包含塊$を~overflowしない
◎
doesn’t overflow the inset-modified containing block.＼
</li>
		</ul>
<p>
（ %~anchor要素 の中心が`~insetで改変された包含塊$の外にある場合、
矩形の~sizeは 0 になる。）
◎
(Possibly being zero-sized, if the anchor’s center is not within the inset-modified containing block.)
</p>
	</li>
</ul>

<p>
%要素 が上の条件を満たさない場合、
`anchor-center$vS は `center$vS として挙動する
— `~inset~prop$の解決-法に追加的な効果を及ぼすことは無い。
◎
If the element is not absolutely positioned, or does not have a default anchor element, this value behaves as center and has no additional effect on how inset properties resolve.
</p>

		</section>
		<section id="scroll">
<h3 title="Taking Scroll Into Account">3.4. ~scrollの織り込み法</h3>

<p>
~scrollingは，処理能の理由から［
実装においては、
~layoutとは別々な~threadで行われる
］ことが多いが、
`anchor$f は，［
位置決め変化, ~layout変化
］両者の結果に基づき得る
（前者は~scrolling~thread内で取扱われ得るが，後者はそうでない）。
このことから、
`anchor$f は，［
当の~anchor要素から当の有位置な要素の`包含塊$までの合間にある，`~scroll容器$
］は［
どれも，各自の初期~scroll位置にある
］ものと見做すよう定義される。
このことは、
有位置な要素は，［
いずれかの`~scroll容器$が，その初期~位置`でない場合^em
］には［
その`~anchor先$【！~its ~anchor】と`整列されなくなる^em
］ことを意味する。
◎
Because scrolling is often done in a separate thread from layout in implementations for performance reasons, but anchor() can result in both positioning changes (which can be handled in the scrolling thread) and layout changes (which cannot), anchor() is defined to assume all the scroll containers between the anchor element and the positioned element’s containing block are at their initial scroll position. This means a positioned element will not be aligned with its anchor if any of the scrollers are not at their initial positions.
</p>

<p>
これを［
~scrollingを別々な~threadで行うことによる処理能の便益を失う
］ことなく補償するため、
次が定義される：
◎
To compensate for this without losing the performance benefits of the separate scrolling thread, we define:
</p>

<div class="algo">
<p>
`絶対的に位置され$た要素 %~query要素 は，所与の［
横~軸／縦~軸
］ %軸 において
`~scroll調整が必要@
であるとは、
次を遂行した結果が ~T になることをいう：
◎
An absolutely-positioned element query el needs scroll adjustment in the horizontal or vertical axis if both of the following conditions are true:
</p>
<ol>
	<li>
%既定の~anchor先 ~LET %~query要素 の`既定の~anchor要素$
◎
↓</li>
	<li>
~IF［
%既定の~anchor先 ~EQ ε
］
⇒
~RET ~F
◎
query el has a default anchor element.
</li>
	<li>
<p>
%~query要素 の
~EACH( %軸 に属する`~inset~prop$ %~prop )
に対し：
</p>
		<ol>
			<li>
%関数 ~LET ［
%~prop の使用~値は `anchor$f 関数を利用しているならば それ ／
~ELSE_ ε
］
</li>
			<li>
~IF［
%関数 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
%~anchor先 ~LET `~target~anchor要素$( %~query要素, %関数 内に指定された `anchor-element$t ) ~NEQ ε
</li>
			<li>
~IF［
%~anchor先 ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%~anchor先 の先祖である`~scroll容器$のうち %~anchor先 に最も近いもの ~EQ %既定の~anchor先 の先祖である`~scroll容器$のうち %既定の~anchor先 に最も近いもの
］
⇒
~RET ~T
</li>
		</ol>
◎
At least one anchor() function on query el’s used inset properties in the axis refers to a target anchor element with the same nearest scroll container ancestor as query el’s default anchor element,＼
</li>
	<li>
~IF［
%~query要素 の %軸 に属する`自己-整列~prop$の使用~値 ~EQ `anchor-center$vS
］
⇒
~RET ~T
◎
or query el’s used self-alignment property value in the axis is anchor-center.
</li>
	<li>
~RET ~F
◎
↑</li>
</ol>

<p class="note">注記：
%~query要素 に`位置~option~list$がある場合、
それにより適用された~fallback~styleも，
ある軸において`~scroll調整が必要$かどうかに影響する。
◎
Note: If query el has a position options list, then whether it needs scroll adjustment in an axis is also affected by the applied fallback style.
</p>
</div>

<div class="algo">
<p>
%~query要素 の
`~snapshot済み~scroll~offset@
は、［
縦~軸, 横~軸
］用の長さが成す~pairである
— これらの各~長さは、
所与の軸 %軸 に対し，次に従って計算される：
◎
query el’s snapshotted scroll offset is a pair of lengths for the horizontal and vertical axises, respectively. Each length is calculated as:
</p>
<ol>
	<li>
~IF［
%~query要素 は %軸 において`~scroll調整が必要$である
］
⇒
~RET ［
次を満たす各`~scroll容器$
］の %軸 における`~scroll~offset$の総和
⇒
［
%~query要素 の`既定の~anchor要素$の先祖である
］~AND［
%~query要素 の`包含塊$の子孫である
］
【この先祖, 子孫は、`~box~tree$に基づくであろう。】
◎
If query el needs scroll adjustment in the axis, then the length is the sum of the scroll offsets of all scroll container ancestors of the default anchor element in the same axis, up to but not including query el’s containing block;
</li>
	<li>
~RET 0
◎
Otherwise, the length is 0.
</li>
</ol>

<p class="issue">
~snapshotを得る精確な時機を定義する必要がある
— それは、
各【描画】~frameごとに，~styleを計算し直す前に更新される。
◎
Define the precise timing of the snapshot: updated each frame, before style recalc.
</p>
</div>

		</section>
		<section id="anchor-valid">
<h3 title="Validity">3.5. 妥当性</h3>

<p>
`anchor$f 関数 %関数 は、
~AND↓ を満たす場合に限り，
`妥当な~anchor関数@
になる：
◎
An anchor() function is a valid anchor function only if all the following conditions are true:
</p>
<ul>
	<li>
%関数 は、
`絶対的に位置され$た要素 %要素 の ある`~inset~prop$ %~prop にて利用されている。
◎
It’s being used in an inset property on an absolutely-positioned element.
</li>
	<li>
%関数 の `anchor-side$t が物理-~keywordを指定している場合、
それは， %~prop が属する軸に属する。
（例えば， `left$vA を利用し得る~propは、
横~軸に属する`~inset~prop$
— `left$p, `right$p, これらと同じ側に対応する~flow相対な~prop —
に限られる。）
◎
If its &lt;anchor-side&gt; specifies a physical keyword, it’s being used in an inset property in that axis. (For example, left can only be used in left, right, or a logical inset property in the horizontal axis.)
</li>
	<li>
`~target~anchor要素$( %要素, %関数 内に指定された `anchor-element$t ) ~NEQ ε
◎
The result of determining the target anchor element is not nothing when given the querying element as the element it’s used on, and the anchor specifier as the &lt;anchor-element&gt; value specified in the function.
</li>
</ul>

<p>
これらいずれかの条件が満たされない場合、
%関数 は次に解決される
⇒＃
~fallback値（ 3 個目の引数）が指定されていた場合は，それ／
~ELSE_ `0px^v
◎
If any of these conditions are false, the anchor() function resolves to its specified fallback value. If no fallback value is specified, it resolves to 0px.
</p>

		</section>
	</section>
	<section id="sizing">
<h2 title="Anchor-Based Sizing">4. ~anchorに基づく~sizing</h2>

<p>
`絶対的に位置され$る要素は、
自身の`~sizing~prop$において
`anchor-size@f
関数を利用することにより，［
1 個以上の`~anchor要素$の~size
］を参照rできる。
`anchor-size$f 関数は、
`length$t に解決される。
◎
An absolutely-positioned element can use the anchor-size() function in its sizing properties to refer to the size of one or more anchor elements. The anchor-size() function resolves to a &lt;length&gt;.
</p>

		<section id="anchor-size-fn">
<h3 title="The anchor-size() Function">4.1. `anchor-size^f 関数</h3>

<pre class="prod">
anchor-size()
	= anchor-size( `anchor-element$t? `anchor-size$t, `length-percentage$t? )
`anchor-size@t
	= `width$v
	| `height$v
	| `block$v
	| `inline$v
	| `self-block$v
	| `self-inline$v
</pre>

<p>
`anchor-size$f 関数は、
`anchor$f と類似する
— それは、［
`anchor-side$t が `anchor-size$t に置換される
］ことを除いて，同じ引数をとる。
◎
The anchor-size() function is similar to anchor(), and takes the same arguments, save that the &lt;anchor-side&gt; keywords are replaced with &lt;anchor-size&gt;,＼
</p>

<p>
`anchor-size$t は、
反対-側にある 2 辺の距離を参照rする：
◎
referring to the distance between two opposing sides.
</p>
<dl>
	<dt>`width@v</dt>
	<dt>`height@v</dt>
	<dd>
これらの物理-~keywordは、
順に，`~target~anchor要素$の［
横幅, 縦幅
］を参照rする。
`anchor$f と違って、
軸が合致しなければならない制約は無い
— 例えば、
`width: anchor-size(--foo height)$p は妥当になる。
◎
The physical &lt;anchor-size&gt; keywords (width and height) refer to the width and height, respectively, of the target anchor element. Unlike anchor(), there is no restriction on having to match axises; for example, width: anchor-size(--foo height); is valid.
</dd>

	<dt>`block@v</dt>
	<dt>`inline@v</dt>
	<dt>`self-block@v</dt>
	<dt>`self-inline@v</dt>
	<dd>
<p>
これらの論理-~keywordは、
次に依存して，いずれかの物理-~keywordに対応付けられる：
</p>
		<ul>
			<li>
［
`self-block$v ／ `self-inline$v
］用には，当の要素の`書字~mode$
</li>
			<li>
［
`block$v ／ `inline$v
］用には，当の要素の`包含塊$の`書字~mode$
</li>
		</ul>
◎
The logical &lt;anchor-size&gt; keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).
</dd>
</dl>

<p>
`anchor-size$f 関数は、
`妥当な~anchor~size関数$を表現しているならば，
`~target~anchor要素$の関連な 2 つの~border辺
— 横幅を参照するならば左端と右端／
縦幅を参照するならば上端と下端 —
の距離を成す `length$t に解決される。
◎
An anchor-size() function representing a valid anchor-size function resolves to the &lt;length&gt; separating the relevant border edges (either left and right, or top and bottom, whichever is in the specified axis) of the target anchor element.
</p>

		</section>
		<section id="anchor-size-valid">
<h3 title="Validity">4.2. 妥当性</h3>

<p>
`anchor-size$f 関数 %関数 は、
~AND↓ を満たす場合に限り，
`妥当な~anchor~size関数@
になる：
◎
An anchor-size() function is a valid anchor-size function only if all the following conditions are true:
</p>
<ul>
	<li>
%関数 は、
`絶対的に位置され$た要素 %要素 の ある`~sizing~prop$にて利用されている。
◎
It’s being used in a sizing property on an absolutely-positioned element.
</li>
	<li>
`~target~anchor要素$( %要素, %関数 内に指定された `anchor-element$t ) ~NEQ ε
◎
There is a target anchor element for the element it’s used on, and the &lt;anchor-element&gt; value specified in the function.
</li>
</ul>

<p>
これらいずれかの条件が満たされない場合、
%関数 は次に解決される
⇒＃
~fallback値（ 3 個目の引数）が指定されていた場合は，それ／
~ELSE_ `0px^v
◎
If any of these conditions are false, the anchor-size() function resolves to its specified fallback value. If no fallback value is specified, it resolves to 0px.
</p>

		</section>
	</section>
	<section id="fallback">
<h2 title="Overflow Management">5. ~overflowの管理</h2>

<p>
~anchor位置決めは、
強力ではあるが，予測-不能にもなり得る。
`~anchor要素$は，~page上のどこにでも~~現れ得るので、
ある有位置な要素を特定0の流儀（当の~anchorの上や右端など）で位置した結果、
当の要素は，［
自身の`包含塊$を~overflowする／
部分的に~screen外に位置される
］かもしれない。
◎
Anchor positioning, while powerful, can also be unpredictable. The anchor element might be anywhere on the page, so positioning an element in any particular fashion (such as above the anchor, or the right of the anchor) might result in the positioned element overflowing its containing block or being positioned partially off screen.
</p>

<p>
これを~~改善するため、
`絶対的に位置され$る要素は，
`position-try-options$p ~propを利用して，［
要素が初期~位置を~overflowする場合に，~UAが試行できる~option
］たちを参照rできる。
各~optionは、［
位置決め／整列
］~prop【宣言】たち
（当の要素の既存の~styleから生成されるもの／
`position-try$at 規則~内に指定されたもの）
が成す集合を与える。
各~optionは、
順に 1 つずつ当の要素に適用され，［
その結果，要素が自身の`包含塊$を~overflowしない最初のもの
］が~~採用されることになる。
◎
To ameliorate this, an absolutely positioned element can use the position-try-options property to refer to several variant sets of positioning/alignment properties (generated from the element’s existing styles, or specified in @position-try rules) that the UA can try if the element overflows its initial position. Each is applied to the element, one by one, and the first that doesn’t cause the element to overflow its containing block is taken as the winner.
</p>

<p>
`position-try-order$p は、［
何らかの宣言された順序に厳密に従うより，当の要素~用の空間をアリな限り広くとる方が重要な場合
］に，追加的に［
それが定義する可用な空間に基づいて，~optionたちを~sortする
］ことを許容する。
◎
position-try-order allows these options to additional be sorted by the available space they define, if it’s more important for the element to have as much space as possible rather than strictly follow some declared order.
</p>

		<section id="position-try-options">
<h3 title="Giving Fallback Options: the position-try-options property">5.1. ~fallback~optionの与え方： `position-try-options^p ~prop</h3>

◎名 `position-try-options@p
◎値 `none^v | [ [`dashed-ident$t || `try-tactic$t] | inset-area( `inset-area$tp ) ]# 
◎初 `none^v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
この~propは、
`位置~option~list@
を供する
— それは、［
`絶対的に位置され$た~boxが その`~insetで改変された包含塊$を~overflowするときに試行する代替-位置決め~style
］たちからなり、
初期~時は，空とする。
◎
This property provides a list of alternate positioning styles to try when the absolutely positioned box overflows its inset-modified containing block. This position options list is initially empty.
</p>

<p>
当の~listを成す（~commaで分離された）各~itemは、
別々な~optionを次に挙げるいずれかとして与える：
◎
Each comma-separated entry in the list is a separate option: either＼
</p>
<ul>
	<li>
ある `position-try$at ~blockの名前
◎
the name of a @position-try block,＼
</li>
	<li>
ある `try-tactic$t
— それは、
当の要素の既存の算出d~styleに対する自動的な変形nを表現する
◎
or a &lt;try-tactic&gt; representing an automatic transformation of the element’s existing computed style.
</li>
</ul>

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt>`none@vOp</dt>
	<dd>
この~propによる効果は無い。
当の要素の`位置~option~list$は空になる。
◎
The property has no effect; the element’s position options list is empty.
</dd>

	<dt id="valdef-position-try-options-dashed-ident">`dashed-ident$t</dt>
	<dd>
所与の名前を伴う `position-try$at 規則が在る場合、
それに結付けられた`位置~option$が`位置~option~list$に追加される。
◎
If there is a @position-try rule with the given name, its associated position option is added to the position options list.
</dd>
	<dd>
そのような規則は無い場合、
この値による効果は無い。
◎
Otherwise, this value has no effect.
</dd>

	<dt id="valdef-position-try-options-try-tactic">`try-tactic$t</dt>
	<dd>
<p>
当の要素の算出d~styleから`位置~option$を自動的に作成する
— 各種［
`~margin~prop$,
`~sizing~prop$,
`~inset~prop$,
`自己-整列~prop$
］の値たちを［
当の要素の各~側で入れ替えた結果
］を当の`位置~option~list$に追加することにより。
◎
Automatically creates a position option from the element’s computed style, by swapping the margin, sizing, inset, and self-alignment property values among the element’s sides, and adds it to the position options list.
</p>

<pre class="prod">
`try-tactic@t
	= flip-block
	|| flip-inline
	|| flip-start
</pre>

		<dl class="valdef">
			<dt>`flip-block@vOp</dt>
			<dd>
`塊-軸$に関する~propたち
（例： `margin-block-start$p と `margin-block-end$p ）
の値どうしを入れ替える
— 本質的に，`行内-軸$を挟んで鏡写しになるよう。
◎
swaps the values in the block axis (between, for example, margin-block-start and margin-block-end), essentially mirroring across an inline-axis line.
</dd>

			<dt>`flip-inline@vOp</dt>
			<dd>
`行内-軸$に関する~propたちの値どうしを入れ替える
— 本質的に，`塊-軸$を挟んで鏡写しになるよう。
◎
swaps the values in the inline axis, essentially mirroring across a block-axis line.
</dd>

			<dt>`flip-start@vOp</dt>
			<dd>
［
`始端$に関する~prop, `終端$に関する~prop
］
（例： `margin-block-start$p と `margin-inline-start$p ）
の値どうしを互いに入れ替える
— 本質的に，［
`塊-始端$, `行内-始端$
］にある隅から［
`塊-終端$, `行内-終端$
］にある隅へ描かれる対角線を挟んで鏡写しになるよう。
◎
swaps the values of the start properties with each other, and the end properties with each other (between, for example, margin-block-start and margin-inline-start), essentially mirroring across a diagonal drawn from the start-start corner to the end-end corner.
</dd>
		</dl>
	</dd>
	<dd>
複数個の~keywordが与えられた場合、
それらによる変形nは，単独の`位置~option$を生産するよう構成される。
◎
If multiple keywords are given, the transformations are composed in order to produce a single position option.
</dd>
	<dd class="issue">
各~値が，入れ替わる際に どう変化するかを定義する必要がある：
`anchor(top)^v は `anchor(bottom)^v になり,
`start^v は `end^v になる，等々。
◎
Define how the values themselves are changed upon flipping: anchor(top) becomes anchor(bottom); start becomes end; etc.
</dd>

	<dt id="valdef-position-try-options-dashed-ident--try-tactic">`dashed-ident$t || `try-tactic$t</dt>
	<dd>
<p>
所与の 2 つの~optionによる効果を組合せる：
◎
Combines the effects of the previous two options:＼
</p>
		<ul>
			<li>
所与の `dashed-ident^t を名前に伴う `position-try$at 規則は在る場合、［
その`位置~option$を当の要素の基底~styleに適用した結果
］を［
指定された `try-tactic$t に則って変形した結果
］を当の要素の`位置~option~list$に追加する。
◎
if there is a @position-try rule with the given name, then applies its position option to the element’s base style, transforms it according to the specified &lt;try-tactic&gt;, and then adds the result to the element’s position options list.
</li>
			<li>
他の場合、
何もしない。
◎
Otherwise, does nothing.
</li>
		</ul>
	</dd>

	<dt id="valdef-position-try-options-inset-area-inset-area">inset-area( `inset-area$tp )</dt>
	<dd>
もっぱら，所与の値を伴う `inset-area$p ~propで構成される`位置~option$を自動的に作成する。
◎
Automatically creates a position option composed solely of an inset-area property with the given value.
</dd>
</dl>

		</section>
		<section id="position-try-order-property">
<h3 title="Determining Fallback Order: the position-try-order property">5.2. ~fallback順序の決定-法： `position-try-order^p ~prop</h3>

◎名 `position-try-order@p
◎値 `normal^v | `try-size$t
◎初 `normal^v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
この~propは、
`位置~option~list$を成す`位置~option$たちが試行されることになる順序を指定する。
◎
This property specifies the order in which the position options list will be tried.
</p>


<pre class="prod">
`try-size@t
	= most-width
	| most-height
	| most-block-size
	| most-inline-size
</pre>

<dl class="valdef">
	<dt>`normal@vOd</dt>
	<dd>
`position-try-options$p により指定された順序で`位置~option$を試行する。
◎
Try the position options in the order specified by position-try-options.
</dd>

	<dt>`most-width@vOd</dt>
	<dt>`most-height@vOd</dt>
	<dt>`most-block-size@vOd</dt>
	<dt>`most-inline-size@vOd</dt>
	<dd>
まず、
`位置~option~list$を成す各`位置~option$に対し，
当の要素に その`位置~optionを適用する$
— その結果を成す~style群により指定される`~insetで改変された包含塊$の~sizeを見出す。
次に、
`位置~option~list$を これらの~size†に則って
— 最~大なものが最初に来るよう —
安定に††~sortする。
◎
For each entry in the position options list, apply a position option using that option to the element, and find the specified inset-modified containing block size that results from those styles. Stably sort the position options list according to this size, with the largest coming first.
</dd>
	<dd class="trans-note">【†
縦横どちらの寸法かは、
当の~keywordの名前により指示される
— `most-width^v なら横幅, 等々。
】【††
すなわち，~sizeが同じものどうしは元の順序に従う。
】</dd>
</dl>

<div class="example">
<p>
例えば，次の~styleは、
初期~時は，
~popup~list【 `.list^css 】を その~anchor先【 `.anchor^css 】の下に位置させるが、
~overflowする場合には，［
どの~optionが最も空間を与えるかに依存して，
当の~popup~listを~anchorの下に保つか上へ移動するか裁定する
］ことになる。
◎
For example, the following styles will initially position the popup list below its anchoring button, but if that overflows, will decide whether to keep the popup list below the anchor or move it above, depending on which option gives it the most space.
</p>

<pre class="lang-css">
.anchor { anchor-name: --foo; }
.list {
  position: fixed;
  anchor-default: --foo;
  top: anchor(bottom);
  left: anchor(left);
  align-self: start;
  position-try-options: --bottom-scrollable, flip-block, --top-scrollable;
  position-try-order: most-height;
}
@position-try --bottom-scrollable {
  align-self: stretch;
}
@position-try --top-scrollable {
  top: 0;
  bottom: anchor(top);
  align-self: stretch;
}
</pre>

<p>
【 `position-try-options$p に指定された各~optionのうち】［
`flip-block$vOp
（これは，【`位置~option$を】自動-生成する）,
`--top-scrollable^v
］は、
常に，同じ可用な縦幅を見出すことになる
— どちらも `top:0$p （表示域の上端~辺）から `bottom:anchor(top)$p （~anchorの上端）へ縦方向に伸張するので。
なので、
それらは，指定された順序を維持することになる
【 `--bottom-scrollable^v は、それらより後になる】。
【初期~時の~styleが~overflowする場合，】
これは、
まず，要素を
— その生来な縦幅を~~保ったまま —
~anchorに対し整列するよう【 `flip-block^v を】試行させるが
（基底~style【 `align-self:start^p 】から自動-逆転された `align-self: end$p を利用して）、
それも~overflowする場合には，代わりに［
空間を埋めるだけになり，
~scroll可能になる【各 `*-scrollable^v を試行する】よう~fall-backする
］ことになる。
◎
The flip-block auto-generated option and the --top-scrollable option will always find the same available height, since both of them stretch vertically from top: 0 (the top edge of the viewport) to bottom: anchor(top) (the top of the anchor), so they’ll retain their specified order. This causes the element to first try to align against the anchor at its natural height (using align-self: end, auto-reversed from the base styles), but if that also causes overflow, it’ll fall back to just filling the space and being scrollable instead.
</p>
</div>

		</section>
		<section id="position-try-prop">
<h3 title="The position-try Shorthand">5.3. `position-try^p 略式~prop</h3>

◎名 `position-try@p
◎値 `position-try-order$tp? `position-try-options$tp
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 個々の~propを見よ
◎表終

<p>
この略式~propは、
その下位prop［
`position-try-options$p, `position-try-order$p
］を設定する。
`position-try-order$tp が省略された場合、
`position-try-options$p ~propは，その初期~値に設定される。
◎
This shorthand sets both position-try-options and position-try-order. If &lt;'position-try-order'&gt; is omitted, it’s set to the property’s initial value.
</p>

		</section>
		<section id="fallback-rule">
<h3 title="The @position-try Rule">5.4. `position-try^at 規則</h3>

<p>
`position-try@at
規則は、
所与の名前を伴う
`位置~option@
を定義する。
各`位置~option$は、
ある［
位置決め~propたちが成す集合
］を指定する。
`位置~option$たちは、
`position-try-options$p を介して要素に適用されることになる。
◎
The @position-try rule defines a position option with a given name, specifying one or more sets of positioning properties that will be applied to an element via position-try-options,
</p>

<p>
`position-try$at 規則の構文は：
◎
The syntax of the @position-try rule is:
</p>

<pre class="prod">
@position-try `dashed-ident$t {
  `declaration-list$t
}
</pre>

<p>
導入部にて指定された `dashed-ident$t が，当の規則の名前になる。
同じ名前を伴う複数個の `position-try$at 規則が宣言された場合、
文書~順序で最後のものが優先される。
◎
The &lt;dashed-ident&gt; specified in the prelude is the rule’s name. If multiple @position-try rules are declared with the same name, the last one in document order "wins".
</p>

<p class="issue">
あるいは、
それらは，一緒に~cascadeするべきか？
◎
Or should they cascade together?
</p>

<p>
`position-try$at 規則に
`受容される~prop@
は、
次に挙げる`~prop$に限られる：
◎
The @position-try rule only accepts the following properties:
</p>

<ul>
	<li>
`~inset~prop$
◎
inset properties
</li>
	<li>
`~margin~prop$
◎
margin properties
</li>
	<li>
`~sizing~prop$
◎
sizing properties
</li>
	<li>
`自己-整列~prop$
◎
self-alignment properties
</li>
	<li>
`anchor-default$p
</li>
	<li>
`inset-area$p
</li>
</ul>

<p class="issue">
ここに何が許容されるかを決定する拘束は、
正確には何か？
現在の~listは、
Chrome の試験的な実装からの適度なものに基づく。
少なくとも［
子孫~用に，より一般的な~style法を許容する
］ために，
どの~fallbackが利用されたかに基づいて `make a CQ^en 【？】できよう。
◎
What exactly are the constraints that determine what’s allowed here? Current list is based off of what’s reasonable from Chrome’s experimental impl. We can make a CQ that keys off of which fallback was used to allow more general styling, at least for descendants.
</p>

<p class="issue">
ある有位置な要素の~anchor（たち）が，
~scrollされて全部的に~screen外にあるとき、
そのことが検出-可能になり，当の要素の表示をまるごと抑止できれば有用になろう。
例えば、
要素が~anchor用の~tooltipを成す~textを保持していて，当の`~scroll容器$の外側に住まう場合。
【！don’t want to just hover...】
◎
Would be useful to be able to detect when your anchor(s) are fully off-screen and suppress your display entirely. For example, tooltips living outside the scroller holding the text they’re anchored to don’t want to just hover over arbitrary parts of the page because their anchor happens to have that position relative to the scrollport.
</p>

<p class="note">注記：
異なる~anchorを利用している複数の要素が，同じ［
各自の~anchor要素に相対的な~fallback位置決め
］を利用したいと求めるなら、
`anchor$f 内の `anchor-element$t を省略して，
代わりに `anchor-default$p 内に各~要素の~anchorを指定する。
◎
Note: If multiple elements using different anchors want to use the same fallback positioning, just relative to their own anchor elements, omit the &lt;anchor-element&gt; in anchor() and specify each element’s anchor in anchor-default instead.
</p>

<p class="note">注記：
最も共通的な~fallback位置決め
（有位置な要素を通常は~anchorの一方の側に置くが，必要なら反対-側へ移転する）
は、
`position-try-options$p 内の~keywordを利用して
— `position-try$at をまったく利用することなく —
自動的に行える。
◎
Note: The most common types of fallback positioning (putting the positioned element on one side of the anchor normally, but flipping to the opposite side if needed) can be done automatically with keywords in position-try-options, without using @position-try at all.
</p>

		</section>
		<section id="fallback-apply">
<h3 title="Applying Position Fallback">5.5. 位置~fallbackの適用-法</h3>

<p>
有位置な要素は、［
自身の`~insetで改変された包含塊$を~overflowする
］かつ［
その`位置~option~list$は空でない
］ときは，
要素~用の`位置~fallback~style群を決定する$ことにより，
~overflowを避ける~optionを見出すよう試みる。
◎
When a positioned element overflows its inset-modified containing block, and has a non-empty position options list, it determines the position fallback styles for the element to attempt to find an option that avoids overflow.
</p>

<p>
これらの改変された~style群は：
◎
↓</p>

<ul>
	<li>
`~styleと~layoutの差挟み$を介して要素に適用されるので、
~layoutや`使用~値$に依存するとしても，`算出d値$に影響する
（その結果，遷移, 等々を誘発し得る）。
◎
These modified styles are applied to the element via interleaving, so they affect computed values (and can trigger transitions/etc) even tho they depend on layout and used values.
</li>
	<li>
`位置~fallback出自$に属するものとして適用される。
◎
They are applied as position fallback origin,＼
</li>
</ul>

<p>
`位置~fallback出自@
は、
`作者~出自$と`~animation出自$の合間に位置する，新たな`出自$である。
◎
a new cascade origin positioned between the author origin and the animation origin.
</p>

<div class="algo">
<p>
`位置~optionを適用する@
ときは、
所与の
( 要素 %要素, `位置~option$ %新たな~style群 )
に対し：
◎
To apply a position option to an element el, given a position option new styles:
</p>
<ol>
	<li>
%新たな~style群 を~cascadeの中へ，`位置~fallback出自$内に挿入する下で，~cascadeを解決する
— その結果を利用して，［
%要素 の各~styleの`使用~値$を決定するに十分な~layout
］を遂行する
◎
With new styles inserted into the cascade in the position fallback origin, resolve the cascade, and perform enough layout to determine el’s used styles.
</li>
	<li>
~RET %要素 の［
`使用~値$を伴う~style群
］
◎
Return el’s used styles.
</li>
</ol>
</div>

<div class="algo">
<p>
要素 %要素 の
`位置~fallback~style群を決定する@
ときは：
◎
To determine the position fallback styles of an element el:
</p>
<ol>
	<li>
%基底~style群 ~LET %要素 にて利用されている現在の~style
◎
Let base styles be the current used styles of el.
</li>
	<li>
<p>
`位置~option~list$を成す
~EACH( %~option )
に対し：
◎
For each option in the position options list:
</p>
		<ol>
			<li>
%調整-済み~style群 ~LET `位置~optionを適用する$( %要素, %~option )
◎
Let adjusted styles be the result of applying a position option option to el.
</li>
			<li>
%要素~矩形 ~LET ~sizeと位置が次に一致する矩形
⇒
%調整-済み~style群 で~lay-outされたときの %要素 の`~margin~box$
◎
Let el rect be the size and position of el’s margin box, when laid out with adjusted styles.＼
</li>
			<li>
%包含塊~矩形 ~LET ~sizeと位置が次に一致する矩形
⇒
%要素 の`~insetで改変された包含塊$
◎
Let cb rect be the size and position of el’s inset-modified containing block.
</li>
			<li>
« %要素~矩形, %包含塊~矩形 »
を成す
~EACH( %矩形 )
に対し
⇒
%矩形 の位置から %要素 の`~snapshot済み~scroll~offset$を減算する
◎
If el has a snapshotted scroll offset, subtract it from the position of both el rect and cb rect.
</li>
			<li>
~IF［
%要素~矩形 は %包含塊~矩形 の中に全部的に包含されていない
］
⇒
~CONTINUE
◎
If el rect is not fully contained within cb rect, continue.
</li>
			<li>
%要素 の`最後の成功裡な位置~option$ ~SET %~option
◎
Set option as el’s last successful position option.＼
</li>
			<li>
~RET %調整-済み~style群
◎
Return adjusted styles.
</li>
		</ol>
	</li>
	<li>
~Assert：
前~段は~overflowを避ける`位置~option$を見出すことなく完遂した。
◎
Assert: The previous step finished without finding a position option that avoids overflow.
</li>
	<li>
%~option ~LET %要素 の`最後の成功裡な位置~option$
◎
↓</li>
	<li>
~IF［
%~option ~NEQ ε
］
⇒
~RET `位置~optionを適用する$( %要素, %~option )
◎
If el has a last successful position option, return the result of applying a position option, using that option, to el.
</li>
	<li>
~RET %基底~style群
◎
Return base styles.
</li>
</ol>

<p>
上の~algoの目的においては、
各 有位置な要素は
`最後の成功裡な位置~option@
を有する
— それは、［
ある`位置~option$ ／ ε
］であり，初期~時は ε とする。
◎
↑</p>

<p class="note">注記：
%要素 を~overflowしている子孫は、
この計算には影響しない
— 影響するのは %要素 の`~margin~box$に限られる。
◎
Note: Descendants overflowing el don’t affect this calculation, only el’s own margin box.
</p>
</div>

<p>
全部的な~layoutを経る間に，
ある要素の~fallback~styleを決定したなら
（あるいは、
それを利用しないものと決定したなら）、
この裁定は，~~後続の要素を~lay-outする際に変更されることはない。
◎
During a full layout pass, once an element has determined its fallback styles (or determined it’s not using any), laying out later elements cannot change this decision.
</p>

<div class="example">
<p>
例えば、
2 個の有位置な要素 %A, %B があって，
%A は %B より前に~lay-outされるとする。
%B が~overflowして，
%A の包含塊に~scrollbarを生じさせる結果になったとしても、
%A を~overflowさせない試みを やり直して，
%A の~fallback~styleを決定し直す`ことはない^em。
（さもなければ、
~~最善でも，~layoutの~costは指数関数的になり、
~~最悪，循環依存になり，~layoutは決して決着しなくなる。）
◎
For example, say you have two positioned elements, A and B, with A laid out before B. If B overflows and causes A’s containing block to gain scrollbars, this does not cause A to go back and re-determine its fallback styles in an attempt to avoid overflowing. (At best, this can result in exponential layout costs; at worst, it’s cyclic and will never settle.)
</p>

<p>
言い換えれば、
~layoutは “後戻りしない” 。
◎
Layout does not "go backward", in other words.
</p>
</div>

<p>
`ResizeObserver$I ~eventが決定され, 送達された時点で，ある要素が［
`最後の成功裡な位置~option$を有するが，`絶対的に位置され$てはいない
］場合、
当の要素の`最後の成功裡な位置~option$は，除去される【 ε になる】。
（これは、
`最後に記憶した~size$の扱いと意図的に一致するようにしてある。）
◎
At the time that ResizeObserver events are determined and delivered, if an element has a last successful position option but is not an absolutely positioned element, remove its last successful position option. (This is intentionally identical to the treatment of last remembered sizes.)
</p>

<p class="issue">
`~styleと~layoutの差挟み$が与えられた今でも、
`~snapshot済み~scroll~offset$に関して正しくなることを~~確かめる必要がある。
◎
Make sure the snapshotted scroll offset stuff is correct now, given interleaving.
</p>

<p>
実装は、［
~layout作業に要求され得る量が過度なとき，それを制限する
］ためとして，［
`位置~option~list$の長さに対し，実装定義な上限を課す
］ことを選んでもヨイ。
この上限は、
5 `以上^emにするモノトスル。
◎
Implementations may choose to impose an implementation-defined limit on the length of position options lists, to limit the amount of excess layout work that may be required. This limit must be at least five.
</p>

<div class="example">
<p>
例えば，次の~CSSは、
ある “~popover”† を，まずは［
~buttonの下に位置させ, 
左端と~buttonの左端を整列する
］ようと試みるが、
~screenに収まらない場合には，順に［
上, 左端
］, ［
下, 右端
］, ［
上, 右端
］を試みるよう切替えることになる。
【† 何らかの動作（この例では、~button上の~hoverなど）に呼応して，他のものの上層に表示される様な~UI。】
◎
For example, the following CSS will first attempt to position a "popover" below the element, but if it doesn’t fit on-screen will switch to being above; it defaults to left-aligning, but will switch to right-aligning if that doesn’t fit.
</p>

<pre class="lang-css">
#myPopover {
  position: fixed;
  top: anchor(--button bottom);
  left: anchor(--button left);
  position-try-options: flip-inline, flip-block, flip-block flip-inline;

  /* <span class="comment">
~popoverの横幅を~buttonの横幅~以上にする
◎
The popover is at least as wide as the button
</span> */
  min-width: anchor-size(--button width);

  /* <span class="comment">
~popoverの縦幅を［
~menu~item 2 個分
］以上にする
◎
The popover is at least as tall as 2 menu items
</span> */
  min-height: 6em;
}
</pre>
</div>

		</section>
	</section>
	<section id="interfaces">
<h2 title="DOM Interfaces">6. ~DOM~interface</h2>

		<section id="position-fallback-rule">
<h3 title="The CSSPositionTryRule interface">6.1. `CSSPositionTryRule^I ~interface</h3>

<p>
`CSSPositionTryRule$I ~interfaceは、
`position-try$at 規則を表現する：
◎
The CSSPositionTryRule interface represents the @position-try rule:
</p>

<pre class="idl">[`Exposed$=Window]
interface `CSSPositionTryRule@I : `CSSRule$I {
  readonly attribute `CSSOMString$ `name$m;
  [`SameObject$, `PutForwards$=`cssText$m] readonly attribute `CSSStyleDeclaration$I `style$m;
};
</pre>

<p>
`name@m
属性は、
当の~at-規則の導入部にて宣言された名前を表現する。
◎
Its name attribute represents the name declared in the rule’s prelude.
</p>

<p>
`style@m
属性は、
当の~at-規則の本体~内で宣言された~styleたちを指定された順序で表現する。
この規則において妥当な~propは、
`position-try$at に`受容される~prop$に限られる。
◎
Its style attribute represents the styles declared in the rule’s body, in the specified order. Only the accepted @position-try properties are valid in this rule.
</p>

<p class="issue">
妥当性の概念を［
類似な状況において行われるもの
］に合致させる必要がある。
◎
match the concept of validity to whatever we do in similar situations.
</p>

		</section>
	</section>
	<section id="interleaving">
<h2 title="Appendix: Style &amp; Layout Interleaving">~styleと~layoutの差挟み</h2>

<p>
`~styleと~layoutの差挟み@
は、
~layout処理nの間に下位tree上で~style更新が生じ得るようにして，
要素の`算出d値$を遡及的に更新するための技法である。
◎
Style &amp; layout interleaving is a technique where a style update can occur on a subtree during the layout process, resulting in retroactive updates to elements’ computed styles.
</p>

<p class="issue">
この概念は、
この仕様ではなく，おそらく `CSS-CASCADE-5$r にて定義されるべきだが、
その素描を参照rするために，ここにある。
◎
This is not the correct spec for this concept, it should probably go in Cascade, but I need a sketch of it to refer to.
</p>

<p class="note">注記：
`~styleと~layoutの差挟み$は、
すでに［
`容器~query$, `容器~query長さ単位$
］で利用されている。
`10cqw^v の様な長さは、
`~query容器$の~sizeについての~layout情報を利用して`算出d長さ$へ解決される
— したがって、
~layoutが変化するに伴い当の容器の~sizeが変化するとき，`遷移＠~TRANSITION$を誘発し得る。
◎
Note: Style &amp; layout interleaving is already used with container queries and container query lengths. A length like 10cqw is resolved into a computed length using layout information about the query container’s size, which can thus trigger transitions when the container changes size between layouts.
</p>

<p>
`position-try$at に`受容される~prop$も，~fallbackを解決するときに差挟まれる
（ `position-try$p を見よ）。
◎
The accepted @position-try properties are also interleaved when resolving fallback (see position-try).
</p>

<p class="issue">
これは，明らかに もっと詳細を詰める必要があるが、
今の所は， “容器~query用にすでに行われている様に動作する” ことで足りる。
その挙動も未定義だが、
少なくとも，その挙動と（ある程度までは？）相互運用可能である。
◎
Obviously this needs way more details filled in, but for now "act like you already do for container queries" suffices. That behavior is also undefined, but at least it’s interoperable (to some extent?).
</p>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この文書に対し提起された~securityの課題は無い。
◎
No Security issues have been raised against this document.
</p>

	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この文書に対し提起された~privacyの課題は無い。
◎
No Privacy issues have been raised against this document.
</p>

	</section>
</main></div>
