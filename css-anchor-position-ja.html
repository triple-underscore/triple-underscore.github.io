<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Anchor Positioning （日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<script src="common0.js"></script>
<script src="common1.js" async></script>

<script >

Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if(i > 0) {
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i + 1)}</code>`;
		}
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">
●●options

spec_title:CSS Anchor Positioning
spec_date:2023-05-17
trans_update:2023-05-17
source_checked:230221
page_state_key:CSS
original_url:https://drafts.csswg.org/css-anchor-position-1/
	abbr_url:CSSANCHOR
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:layouts,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2023-03-06

●●class_map
p:property
at:at-rule
t:type
v:value
vA:value
f:func
pe:pseudo
css:css
e:element

●●tag_map
p:code
t:var
v:code
vA:code
css:code
at:code
pe:code
e:code
c:code
f:code
cite:cite
em:em

●●original_id_map

●●mdn_urls
	propdef-anchor-default:CSS/anchor-default
	propdef-anchor-name:CSS/anchor-name
	propdef-anchor-scroll:CSS/anchor-scroll
	propdef-position-fallback:CSS/position-fallback

●●link_map

at.position-fallback:#at-ruledef-position-fallback
at.try:#at-ruledef-try

p.anchor-default:#propdef-anchor-default
p.anchor-name:#propdef-anchor-name
p.anchor-scroll:#propdef-anchor-scroll
p.position-fallback:#propdef-position-fallback
p.right:~CSSPOS#propdef-right
p.inset-inline-start:~CSSPOS#propdef-inset-inline-start
p.bottom:~CSSPOS#propdef-bottom
p.left:~CSSPOS#propdef-left
p.top:~CSSPOS#propdef-top
p.width:~SIZING#propdef-width

f.anchor-size:#funcdef-anchor-size
f.anchor:#funcdef-anchor
f.translate:~TRANSFORM#funcdef-transform-translate

t.anchor-element:#typedef-anchor-element
t.anchor-side:#typedef-anchor-side
t.anchor-size:#typedef-anchor-size
t.dashed-ident:~CSSVAL#typedef-dashed-ident
	t.dashed-ident:#valdef-anchor-dashed-ident
	t.dashed-ident:#valdef-anchor-name-dashed-ident
	t.dashed-ident:#valdef-position-fallback-dashed-ident
t.declaration-list:~CSSSYN#typedef-declaration-list
t.length-percentage:~CSSVAL#typedef-length-percentage
t.percentage:~CSSVAL#percentage-value
t.rule-list:~CSSSYN#typedef-rule-list
t.length:~CSSVAL#length-value

v.block:#valdef-anchor-size-block
v.height:#valdef-anchor-size-height
v.inline:#valdef-anchor-size-inline
v.self-block:#valdef-anchor-size-self-block
v.self-inline:#valdef-anchor-size-self-inline
v.width:#valdef-anchor-size-width

v.default:#valdef-anchor-scroll-default
v.none:#valdef-anchor-name-none
v.~noneN:#valdef-anchor-name-none
v.~noneF:#valdef-position-fallback-none
v.~noneS:#valdef-anchor-scroll-none

v.auto:~CSSPOS#valdef-top-auto

vA.auto:#valdef-anchor-auto
vA.auto-same:#valdef-anchor-auto-same
vA.bottom:#valdef-anchor-bottom
vA.center:#valdef-anchor-center
vA.end:#valdef-anchor-end
vA.implicit:#valdef-anchor-implicit
vA.left:#valdef-anchor-left
vA.right:#valdef-anchor-right
vA.self-end:#valdef-anchor-self-end
vA.self-start:#valdef-anchor-self-start
vA.start:#valdef-anchor-start
vA.top:#valdef-anchor-top

pe.part():~CSSSHADOWPARTS#selectordef-part

e.input:~HEinput#the-input-element

	●用語
~anchor要素:#anchor-element
~anchor関数:#anchor-function
~anchor名:#anchor-name
~anchor~query:#anchor-query
妥当な~anchor~query:#valid-anchor-query
無効な~anchor~query:#valid-anchor-query
暗黙的な~anchor要素:#implicit-anchor-element
位置~fallback~list:#position-fallback-list
位置~fallback~style群を決定する:#determine-the-position-fallback-styles
~target~anchor要素:#target-anchor-element
~anchor先:#target-anchor-element
自動的な~anchor位置決め:#automatic-anchor-positioning
~anchor指定子:#_anchor-specifier
既定の~anchor指定子:#default-anchor-specifier
受容-可能な~anchor要素:#acceptable-anchor-element
~snapshot済み~scroll~offset:#snapshotted-scroll-offset
~snapshotした~scroll~offset:#snapshotted-scroll-offset

	●用語（ CSS
断片:~CSSBREAK#fragment
~box整列~prop:~CSSALIGN#box-alignment-properties
包含塊~連鎖:~CSSDISP#containing-block-chain
包含塊:~CSSDISP#containing-block
要素:~CSSDISP#elements
首要~box:~CSSDISP#principal-box
初期~包含塊:~CSSDISP#initial-containing-block
~box~tree:~CSSDISP#box-tree
~inset~prop:~CSSPOS#inset-properties
	~inset~prop:~CSSLOGICAL#inset-properties
~insetで改変された包含塊:~CSSPOS#inset-modified-containing-block
~margin~box:~CSSBOX#margin-box
~math関数:~CSSVAL#math-function
~prop:~CASCADE#css-property
使用~値:~CASCADE#used-value
書字~mode:~CSSWM#writing-mode
~sizing~prop:~SIZING#sizing-property
絶対~位置決め:~CSSPOS#absolute-position
絶対的に位置され:~CSSPOS#absolute-position
有位置:~CSSPOS#positioned-box

行内-軸:~CSSWM#inline-axis
~tree視野な参照:~CSSSCOPING#css-tree-scoped-reference
~tree視野な名前:~CSSSCOPING#css-tree-scoped-name

~scroll容器:~CSSOVERFLOW3#scroll-container
~scrollport:~CSSOVERFLOW3#scrollport
初期~scroll位置:~CSSOVERFLOW3#initial-scroll-position

	●用語（他

	~listを反復する:~INFRA#list-iterate
根:~DOM4#concept-tree-root
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order
~shadow~tree:~DOM4#concept-shadow-tree

●●words_table1
CSSSHADOWPARTS:css-shadow-parts-ja.html

noneN:none
noneF:none
noneS:none

●●words_table


	●幾何
限界:bounding::~
矩形:rectangle:~
中央寄せに:center:~
中央寄せ:centering:~
ズラす:shiftする:ずらす
ズラされ:shiftされ:ずらされ
ズラして:shiftして:ずらして
縦方向:vertical:~
横方向:horizontal:~
側:side:~
反対-:opposite:~
	反対-側の:opposing

	縦幅:tall
	幅広:wide
	横幅:wide
	の距離を成す:separating

	●layout
首要:principal::主要
収まる:fitする:~
収まら:fitし:~
滑らす:slideする:~
scrollport::::スクロール域
	揃う:line up
scrolling::::スクロール処理
	`~scroll容器$:scroller
	`~insetで改変された包含塊$:IMCB
	〜へ整列するよう:-aligning
	軸が揃えられた:axis-aligned
	移転-:flip

	●CSS
視野な:scopedな::~
	~tree視野な:tree-scoped
導入部:prelude:~
書字:writing::~
捕捉-:capture:~
変形:transform::~
積層:stacking::~
	~anchor先:anchored
	~anchor法:anchoring

	●UI
tooltip::::ツールチップ
hover:
popover:


	●処理
累積-:accumulate:~
積:product:~
深さ:depth:~
	そうなること:exploding
	総量:budget
	分岐数:branching factor
	回数が指数関数的:exponential blow-up
	この上限:total product
	深過ぎる:get too deep
	-:stuck
	巨大:large

	%~query要素:query el
	%要素:el
	%調整-済み~style群:adjusted styles
	%指定子:anchor spec
	%基底~style群:base styles
	%~fallback~style群:fallback styles
	%改変された包含塊:scroll-adjusted IMCB

	●仕様
冗漫:verbose:~
策:strategy:~
柔軟性:flexibility:~
表出能:expressivity:~
	表出能に劣る:not very expressive
普通の:ordinaryな:~
力:power:~
弱体化-:compromise:~
流儀:fashion:~
encapsulation::::カプセル化
提起-:raise:~
確証:assurance:~
循環依存に:circularに:~
循環依存:circularity:~
思慮:thought:~
切替える:switchする:切り替える
過度:excess:~
適度:reasonable:~

	にも~costがかかる:not without costs of their own
	問題になり得る:problematic
	極めて〜ある:provides extreme
	極めて:extreme
	引き換えに:in return
	ようになった:end up with
	そうなるかどうかは:vary
	仮に〜とする:say
	させたい:would like
	し易く:make it easier
	当の:in question
	生じ得ない:there is no possibly
	他では:otherwise
	およそ:more or less
	さらには〜もっと〜までも:even more
	どう転んでも:*at a minimum*
	見合わない:not worth
	実装:impl
	取り戻す:give back
	ほとんど〜ない:barely
	編集者:I
	ほぼ間違いなく:almost certainly
	考えて:think
	〜を除いて:save that
	必要とされない:not necessarily
	課す~impose:#2
	~~改善:ameliorate
	~~採用:taken as the winner
	~~採用:take
	紛らわしく:confusing
	に基づくように:in terms of
	単に:merely
	優先される:"wins"
	込み入った:weird
	選ぶ:choice
	選んで:chooseして
	に基づいて:keys off
	ちょうど:exactly
	無闇に:unduly
	そもそも、:in the first place
	言い直:rephrase
	〜に基づく:key off
	に関する:around
	これらの:extra
	伴うようになる:gain

	●未分類
参照r:refer:参照
math:
補償-:compensate:~
最終-:final:~
時機:timing:~
超過-:exceed:~
	超過した場合:Get too deep
上限:limit:~
総和:sum:~
付され:attachされ:~
先行-:precede:~

	引き出す:draw
	の距離を成す:separating
	一群の:sets of
	~library:libs
	~tree視野な:tree-scoped
	同時に:at once
	1000:1k
	識別子:ident
	直前の~blockを適用した結果:the previous 〜 successive one
	住まう:living
	作動化され:active
	現れる:appearする
	一部でも:partially or fully
	無い:none
	以上:at least
	次に，Next,
	来ている:come form
	計算し直す:recalc
	最も近い:closest
	順に 1 つずつ:one by one
	時点:point
	多数の:bunch of
	順番に:sequentially
	最後の:final
	最後に:Finally,
	過ぎ去った:past
	に~~達する前まで:up to but not including
	-:in turn
	-:grandchild
	~screen外:off-screen
	~screen外:off screen
	~screen上:on-screen
	-:stuff
	失うこと:losing
	逆にした:reverse
	入れ替えて:swap
	置く:putting
	Chrome
	^en:make a CQ
	量:amount
	-:exit
	探す:look for
	要素~自身:your own
	上層:over the top
	どの~entryも~overflowする場合:if none succeeded
	~layoutの最中に適用される:in the middle of layout right now


●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-DISPLAY-4]
    CSS Display Module Level 4 URL: https://drafts.csswg.org/css-display-4/
[CSS-LOGICAL-1]
    Rossen Atanassov; Elika Etemad. ＜CSS Logical Properties and Values Level 1＞. URL: https://drafts.csswg.org/css-logical-1/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[FULLSCREEN]
    Philip Jägenstedt. ＜Fullscreen API Standard＞. Living Standard. URL: https://fullscreen.spec.whatwg.org/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119

●●ref_informative

[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Anchor Positioning</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-anchor-position-1">CSSWG Issues Repository</a>
編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="https://twitter.com/jh3yy">Jhey Tompkins</a> (Google)
	Ian Kilpatrick (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-anchor-position-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-anchor-position-1
</script>

</head><body>

<header>
	<hgroup>
<h1 title="CSS Anchor Positioning">CSS アンカー位置決め</h1>
<p>CSS Anchor Positioning</p>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は “~anchor位置決め” を定義する。
そこでは、
有位置な要素†が［
~page上の他所にある 1 個以上の “~anchor要素”
］に相対的に，自身を~sizeして位置できる。
◎
This specification defines 'anchor positioning', where a positioned element can size and position itself relative to one or more "anchor elements" elsewhere on the page.
</p>

<p class="trans-note">【†
この仕様における`有位置$な要素は、
実際には，（より限定的な）`絶対的に位置され$た要素の略称である。
】</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSにおいては、
一般に，要素の［
~size, 位置
］は要素の先祖たちに則って決定されるが、
`絶対的に位置され$た要素は，先祖の~layoutには ほとんど関与しない
— 代わりに、
当の要素の`包含塊$の最終-［
~size, 位置
］のみを参照して，［
`~inset~prop$, `~box整列~prop$
］により明示的に［
~sizeされ, 位置される
］。
これには，
極めて柔軟性がある
— すなわち、
要素を およそ任意に位置させることを
— 他の~layout~methodが許容しない仕方で，他の要素の上層に位置することまでも —
許容する。
が、
その引き換えに，表出能は劣る
— すなわち、
当の要素の［
~size, 位置
］を~page上の他の要素【包含塊~以外】の［
~sizeや位置
］に基づくように表出することは，容易でない。
◎
While CSS generally determines the position and size of elements according to their parents or other ancestors, absolutely positioned elements barely participate in their ancestors' layout. Instead, they’re sized and positioned explicitly by the inset properties and box alignment properties, only referencing the final size and position of their containing block. This provides extreme flexibility, allowing elements to be positioned more or less arbitrarily, including over the top of other elements in ways that the layout methods don’t otherwise allow, but in return it’s not very expressive—the element cannot easily express its size and position in terms of other elements on the page.
</p>

	</section>
	<section id="anchoring">
<h2 title="Anchoring">2. ~anchor法</h2>

<p>
以下に定義される
`~anchor関数@
— `anchor$f, `anchor-size$f —
は、
`絶対~位置決め$の柔軟性と力を弱体化することなく，
普通の~layoutの表出能のうち一部を取り戻す。
これらの関数を利用すれば、
`絶対的に位置され$た要素を［
同じ~page内の 1 個以上の`~anchor要素$
］から相対的に［
~sizeでき, 位置できる
］。
さらには， `position-fallback$at 【！`position-set^at 】規則は、
もっと柔軟性を与える
— それは、
複数の異なる［
~size／位置
］を［
`包含塊$の中に収まるものが見出されるまで，順番に試行する
］ことまでも許容する。
◎
The anchor functions anchor() and anchor-size(), defined below, give back some of the expressivity of ordinary layout without compromising on the flexibility and power of absolute positioning. Using these functions, one can size and position an absolutely positioned element relative to one or more anchor elements on the page. The @position-set rule allows even more flexibility, allowing multiple different sizes/positions to be tried out sequentially until one is found that fits within the containing block.
</p>

		<section id="anchor-pos">
<h3 title="Anchor-based Positioning: the anchor() function">2.1. ~anchorに基づく位置決め： `anchor^f 関数</h3>

<p>
`絶対的に位置され$る要素 %要素 は、
自身の`~inset~prop$に
`anchor@f
関数を利用することにより，［
1 個以上の`~anchor要素$
］の位置を参照rできる。
`anchor$f 関数は、
`length$t に解決される。
◎
An absolutely-positioned element can use the anchor() function as a value in its inset properties to refer to the position of one or more anchor elements. The anchor() function resolves to a &lt;length&gt;.
</p>

<pre class="prod">
`anchor()^t
	= anchor( `anchor-element$t? `anchor-side$t, `length-percentage$t? )
`anchor-element@t
	= `dashed-ident$t
	| `implicit$vA
`anchor-side@t
	= `auto$vA
	| `auto-same$vA
	| `top$vA
	| `left$vA
	| `right$vA
	| `bottom$vA
	| `start$vA
	| `end$vA
	| `self-start$vA
	| `self-end$vA
	| `percentage$t
	| `center$vA
</pre>

<p>
`anchor$f 関数は、
3 個の引数をとる：
◎
The anchor() function has three arguments:
</p>
<ul>
	<li>
<p>
`anchor-element$t は、
`~anchor指定子@
を与える
— それは、
`~anchor要素$を見出す方法を指定する。
%要素 の位置決め情報は、
それにより見出された`~anchor要素$
【すなわち，`~target~anchor要素$】
から引き出されることになる。
省略された場合、
%要素 の`既定の~anchor指定子$として挙動する。
◎
the &lt;anchor-element&gt; value specifies how to find the anchor element it will be drawing positioning information from. If omitted, it behaves as the element’s default anchor specifier.
</p>

<p>
アリな値は：
◎
Its possible values are:
</p>
		<dl>
			<dt id="valdef-anchor-dashed-ident">`dashed-ident$t</dt>
			<dd>
`~anchor要素$のうち`~anchor名$として所与の識別子を伴うものを探す。
この名前は、
`~tree視野な参照$になる。
◎
Specifies the anchor name it will look for. This name is a tree-scoped reference.
</dd>

			<dt>`implicit@vA</dt>
			<dd>
アリなら，
%要素 用に定義された`暗黙的な~anchor要素$を選定する。
◎
Selects the implicit anchor element defined for the element, if possible.
</dd>
		</dl>
<p>
詳細は、
`~target~anchor要素$を見よ。
◎
See target anchor element for details.
</p>
	</li>
	<li>
<p>
`anchor-side$t は、
`~target~anchor要素$の［
その値に対応している側
］の位置を参照rする：
◎
the &lt;anchor-side&gt; value refers to the position of the corresponding side of the target anchor element.
</p>

		<dl class="valdef">
			<dt>`auto@vA</dt>
			<dt>`auto-same@vA</dt>
			<dd>
`自動的な~anchor位置決め$を指示する。
詳細は、
`§ 自動的な~anchor位置決め＠#anchor-auto$を見よ。
◎
The auto and auto-same keywords indicate automatic anchor positioning. See § 2.1.1 Automatic Anchor Positioning for details.
</dd>

			<dt>`left@vA</dt>
			<dt>`right@vA</dt>
			<dt>`top@vA</dt>
			<dt>`bottom@vA</dt>
			<dd>
これらの物理-~keywordは、
順に［
左端, 右端, 上端, 下端
］を参照rする。
これらが有用になるのは、
それを利用している`~inset~prop$が同じ軸に対応する場合に限られる。
例えば，［
`left$p ／ `right$p
］~prop
（あるいは、
`行内-軸$が横方向ならば `inset-inline-start$p ~prop, 等々）
において， `top$vA や `bottom$vA を利用した場合、
結果は，`無効な~anchor~query$になる。
◎
The physical &lt;anchor-side&gt; keywords (left, right, top, and bottom) are only useful in inset properties corresponding to their corresponding axis: for example, using top and bottom in left or right (or in inset-inline-start if the inline axis is horizontal, etc) results in an invalid anchor query.
</dd>

			<dt>`start@vA</dt>
			<dt>`end@vA</dt>
			<dt>`self-start@vA</dt>
			<dt>`self-end@vA</dt>
			<dd>
<p>
これらの論理-~keywordは、
次に依存して，いずれかの物理-~keywordに対応付けられる：
</p>
				<ul>
					<li>
当の関数を利用している~prop【が適用される軸】
（例： `top$p ならば `top$vA か `bottom$vA に対応付けられる）
</li>
					<li>
［
`self-start$vA ／ `self-end$vA
］の場合、
%要素 の`書字~mode$
</li>
					<li>
［
`start$vA ／ `end$vA
］の場合、
%要素 の`包含塊$の`書字~mode$
</li>
				</ul>
◎
The logical &lt;anchor-side&gt; keywords (start, end, self-start, and self-end) map to one of the physical keywords depending on the property the function is being used in (top or bottom in the top or bottom properties, etc) and the writing mode of either the element (for self-start and self-end) or the writing mode of the element’s containing block (for start and end).
</dd>
			<dd class="issue">
~anchor要素の`書字~mode$を参照rする必要はあるか？
編集者は、［
実際に何か有用なことを行うには予測-不能になり過ぎる
］と考えている。
作者が `inset-inline-start$p ~propに指定している場合、
ほぼ間違いなく［
~anchor要素に基づく予測-不能な辺ではなく，
要素~自身の方向【`書字~mode$】に相対的な~anchor辺を参照rしたい
］と求めるであろう。
◎
Do we need to refer to the anchor element’s writing mode? I think that’s too unpredictable to actually do anything useful. If you’re specifying your inset-inline-start property, you almost certainly want to refer to an anchor edge relative to your own directions, not an unpredictable edge based on the anchor.
</dd>

			<dt>`percentage$t</dt>
			<dd>
［
`start$vA 側, `end$vA 側
］の合間における百分率に対応する位置を参照rする
— ［
`0%^v は `start^v ／ `100%^v は `end^v
］に等価になる。
◎
A &lt;percentage&gt; value refers to a position a corresponding percentage between the start and end sides, with 0% being equivalent to start and 100% being equivalent to end.＼
</dd>

			<dt>`center@vA</dt>
			<dd>
`percentage$t 値 `50%^v と等価になる。
◎
The center keyword is equivalent to 50%.
</dd>
		</dl>
	</li>
	<li>
<p>
省略可能な最後の引数 `length-percentage$t は、
~fallback値を与える。
当の `anchor$f が`無効な~anchor~query$を表現する場合、
この値に解決される
— 以下の詳細に従って値を決定するのではなく。
◎
the optional &lt;length-percentage&gt; final argument is a fallback value. If the anchor() represents an invalid anchor query, it resolves to this value rather that determining its value as detailed below.
</p>

<p>
省略された場合は、
`0px^v を既定とする。
◎
If omitted, it defaults to 0px.
</p>
	</li>
</ul>

<p class="issue">
`anchor$f 関数の算出d値は、
おそらく，［
その`~target~anchor要素$を解決した結果の `anchor$f
］になる必要がある。
これは、
遷移が［
`~tree視野な名前$と伴に／~anchor要素が変化するときに
］適正に働くことを許容する。
`8180$issue を見よ。
◎
Computed value for anchor() probably needs to be the anchor() function, but with the target anchor element resolved. This allows for transitions to work properly with tree-scoped names, and with changing anchor elements. See Issue 8180.
</p>

<p>
`anchor$f 関数は、
`妥当な~anchor~query$を表現しているならば，
`使用~値$の時点で， `length$t に解決される
— ［
当の有位置な要素の`~insetで改変された包含塊$
］の［
当の関数が現れる~propに対応している辺
］を［
`~target~anchor要素$の指定された~border辺
］に整列するような。
そのときには、［
`~target~anchor要素$と当の有位置な要素の`包含塊$の合間にある`~scroll容器$
］は，どれも［
各自の初期~scroll位置に~scrollされている
］と見做される
（が、 `anchor-scroll$p を見よ）。
◎
An anchor() function representing a valid anchor query resolves at used value time to the &lt;length&gt; that would align the edge of the positioned elements' inset-modified containing block corresponding to the property the function appears in with the specified border edge of the target anchor element, assuming that all scroll containers between the target anchor element and the positioned element’s containing block are scrolled to their initial scroll position (but see anchor-scroll).
</p>

<p>
`~target~anchor要素$が`断片$化されている場合、［
各~断片の~border~box
］たちが成す限界~矩形
— それらの~boxと軸が揃えられた矩形 —
が代わりに利用される。
◎
If the target anchor element is fragmented, the axis-aligned bounding rectangle of the fragments' border boxes is used instead.
</p>

<p class="issue">
［
~padding辺／内容~辺
］にも整列できるよう，［
どの~boxを参照rするか
］も制御する必要はあるか？
◎
Do we need to control which box we’re referring to, so you can align to padding or content edge?
</p>

<p>
加えて，有位置な要素が`~snapshot済み~scroll~offset$を有する場合、
その~offsetにより視覚的にズラされる
— 追加的な `translate$f 変形によりズラされたかのように。
◎
If the positioned element has a snapshotted scroll offset, then it is additionally visually shifted by those offsets, as if by an additional translate() transform.
</p>

<div class="example">
<p>
例えば，
`.bar { top: anchor(--foo top); }^css
においては、
`anchor$f は，［
`.bar^css 要素の上端~辺と`~anchor要素$ `--foo^v の上端~辺が揃うような長さ
］に解決されることになる。
◎
For example, in .bar { top: anchor(--foo top); }, the anchor() will resolve to the length that’ll line up the .bar element’s top edge with the --foo anchor’s top edge.
</p>

<p>
他方，
`.bar { bottom: anchor(--foo top); }^css
においては、［
`.bar^css 要素 の`下端^em辺と`~anchor要素$ `--foo^v の上端~辺が揃うような長さ
］に解決されることになる。
◎
On the other hand, in .bar { bottom: anchor(--foo top); }, it will instead resolve to the length that’ll line up the .bar element’s bottom edge with the --foo anchor’s top edge.
</p>

<p>
［
`top$p の値, `bottom$p の値
］は，異なる辺
（要素の`包含塊$の［
上端／下端
］辺）
からの~insetを指定するので、
双方の `anchor$f は同じでも，それらを解決した結果の長さは異なることになる。
◎
Since top and bottom values specify insets from different edges (the top and bottom of the element’s containing block, respectively), the same anchor() will usually resolve to different lengths in each.
</p>
</div>

<div class="example">
<p>
`anchor$f 関数は、
`length$t に解決されるので，他の長さと同様に`~math関数$内でも利用できる。
◎
Because the anchor() function resolves to a &lt;length&gt;, it can be used in math functions like any other length.
</p>

<p>
例えば，次は、［
要素の`~insetで改変された包含塊$
］が［
`~anchor要素$上で中央寄せにされ，
要素の`包含塊$を~overflowしない~~範囲でアリな限り幅広になる
］よう，要素を設定しておくことになる：
◎
For example, the following will set up the element so that its inset-modified containing block is centered on the anchor element and as wide as possible without overflowing the containing block:
</p>

<pre class="lang-css">
.centered-message {
  position: fixed;
  max-width: max-content;
  justify-content: center;

  --center: anchor(--x 50%);
  --half-distance: min(
    abs(0% - var(--center)),
    abs(100% - var(--center))
  );
  left: calc(var(--center) - var(--half-distance));
  right: calc(var(--center) - var(--half-distance));
  bottom: anchor(--x top);
}
</pre>

<p>
これは例えば、
`input$e 要素に対する~error~message用に適切になることもあろう
— 中央寄せ~により，当の~messageが どの入力を参照rしているか発見し易くなるので。
◎
This might be appropriate for an error message on an input element, for example, as the centering will make it easier to discover which input is being referred to.
</p>
</div>

			<section id="anchor-auto">
<h4 title="Automatic Anchor Positioning">2.1.1. 自動的な~anchor位置決め</h4>

<p>
有位置な要素 %要素 が，
そのいずれかの`~inset~prop$ %~prop において `anchor$f 関数を利用していて，
その `anchor-side$t として~keyword［
`auto$vA ／ `auto-same$vA
］を伴う場合：
◎
If a positioned element uses the anchor() function with the auto or auto-same keywords in one of its inset properties,＼
</p>
<ul>
	<li>
%~prop と反対-側の`~inset~prop$が `auto$v の場合、
%要素 は， %~prop の軸において
`自動的な~anchor位置決め@
を利用しているとされる。
【！This will resolve the 略】
◎
and the opposing inset property is auto, then the element is using automatic anchor positioning in that property’s axis. This will resolve the anchor() function’s &lt;anchor-side&gt; to the correct side of the anchor element, and automatically create entries in the position fallback list to flip the positioned element to the opposite side if necessary.
</li>
	<li>
他の場合，`自動的な~anchor位置決め$は作動化されず、
当の `anchor$f 関数は，`無効な~anchor~query$を表現する
（例えば、
%要素 が `top:anchor(auto)$p を伴う場合，
%要素 は `bottom:auto$p も伴う必要がある）。


◎
Automatic anchor positioning is only active if the opposite inset property is auto. (For example, if an element had top: anchor(auto);, it would have to also have bottom: auto;.) If this is not the case, the anchor() function represents an invalid anchor query, and the element does not use automatic anchor positioning in that axis.
</li>
</ul>

<p>
`自動的な~anchor位置決め$を利用しているときは：
</p>
<ul>
	<li>
(A)
`anchor-side$t 用の~keyword［
`auto$vA ／ `auto-same$vA
］は、
%~prop ［
の反対-側／と同じ側
］として挙動する
— すなわち、
【！when used in】
`top:anchor(auto)$p は `top:anchor(bottom)$p と等価になり，
`top:anchor(auto-same)$p は `top:anchor(top)$p と等価になる，等々。
◎
When using automatic anchor positioning, the auto &lt;anchor-side&gt; behaves as the opposite side of the property it’s used in. That is, when used in top: anchor(auto);, it’s equivalent to top: anchor(bottom);; when used in bottom: anchor(auto);, it’s equivalent to bottom: anchor(top);; etc. The auto-same &lt;anchor-side&gt; behaves as the property it’s used in: top: anchor(auto-same); is equivalent to top: anchor(top);, etc.
</li>
	<li>
<p>
%要素 の `position-fallback$p が `~noneF$v の場合、
%要素 は，［
次に挙げる 2 個の~entryからなる`位置~fallback~list$
］を伴うようになる：
◎
Additionally, if the element has position-fallback: none, automatic anchor positioning causes the element to gain a position fallback list consisting of two entries:
</p>
		<ol>
			<li>
%要素 上の基底~styleを成す~prop
【 `try$at 規則の外で宣言された， %要素 に適用される~prop】
のうち［
`try$at 規則~内で利用しても妥当になるもの
］すべてを包含するもの
— 【それらの~propにて利用された `anchor$f 関数~内の】［
`auto$vA ／ `auto-same$vA
］~keywordは，各自の適切な側に【上述 (A) と同様に】解決される。
◎
one containing all the base-style properties on the element that are valid to use in @try rules, with auto/auto-same keywords resolved to their appropriate side.
</li>
			<li>
<p>
前項の~entryを “逆にした” もの
— すなわち、
次のように改変したもの
⇒
各`~inset~prop$を反対-側の~propと入れ替えて、［
`auto$vA ／ `auto-same$vA
］は反対-側に解決する。
</p>

<p class="trans-note">【
例えば、
`top: 1em^p は `bottom: 1em^p に置換する
— ［
`auto$vA ／ `auto-same$vA
］は、
`その結果として^em，反対-側に解決されることになる。
】</p>
◎
one containing the same, but with the inset properties in each axis swapped, and the auto/auto-same keywords resolved to the opposite sides as well.
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
%要素 の `position-fallback$p が `~noneF$v 以外の場合、
これらの~entryは，追加されない。
この場合，
`位置~fallback~list$を成す~styleが “基底~style” を即時に上書きすることになるので、
“基底~style” における `anchor$f 関数~内の［
`auto$vA ／ `auto-same$vA
］による最終-~styleに対する効果は、
`位置~fallback~list$内に それを上書きするものが［
在る場合は，まったくない／
無い場合は，適切な `anchor-side$t【！side】 ~keywordに解決されることに限られる
］。
◎
Note: If the element has a non-none position-fallback, these extra entries aren’t added. Since the position fallback list styles override the "base" styles immediately, this will usually mean you wouldn’t see a "base" anchor(auto) show up in the final styles at all, but if that does happen (it’s specified in a property that isn’t overriden by anything in the position fallback list), the only effect of the auto/auto-same is to resolve to the appropriate side keyword.
</p>

<div class="example">
<p>
例えば，次の~codeは、
`自動的な~anchor位置決め$を利用している：
◎
For example, the following code using automatic anchor positioning:
</p>
<pre class="lang-css">.foo {
  position: absolute;
  top: calc(.5em + anchor(--foo auto));
}
</pre>

<p>
これは、
もっと冗漫かつ明示的な，次の~codeと等価になる：
◎
is equivalent to the following more verbose and explicit code:
</p>

<pre class="lang-css">
.foo {
  position: absolute;
  position-fallback: --flip;
}
@position-fallback --flip {
  @try {
    top: calc(.5em + anchor(--foo bottom));
    bottom: auto;
  }
  @try {
    top: auto;
    bottom: calc(.5em + anchor(--foo top));
  }
}
</pre>
</div>

<p>
%要素 が両~軸とも`自動的な~anchor位置決め$を利用する場合、
前述の`位置~fallback~list$には，さらに［
塊~軸だけ “逆にした” ~entry,
行内~軸だけ “逆にした” ~entry
］も追加される。
◎
If the element uses automatic anchor positioning in both axises, it instead adds three entries to the position fallback list: one reversing just the block axis, one reversing just the inline axis, and finally one reversing both axises at once.
</p>

<p>
`try$at 規則`内^emで利用される［
`auto$vA ／ `auto-same$vA
］も、
上に指定したとおり，
`位置~fallback~list$の中へ複数個の（ 2 個 ／ 4 個）の~entryを挿入させる
— それらが`自動的な~anchor位置決め$を妥当に誘発するならば。
◎
auto and auto-same used in a @try rule cause the rule to insert multiple (2 or 4) sets of entries into the position fallback list, as specified above, if they would validly trigger automatic anchor positioning.
</p>

			</section>
		</section>
		<section id="anchor-size">
<h3 title="Anchor-based Sizing: the anchor-size() function">2.2. ~anchorに基づく~sizing： `anchor-size^f 関数</h3>

<p>
`絶対的に位置され$る要素は、
自身の`~sizing~prop$において
`anchor-size@f
関数を利用することにより，［
1 個以上の`~anchor要素$の~size
］を参照rできる。
`anchor-size$f 関数は、
`length$t に解決される。
◎
An absolutely-positioned element can use the anchor-size() function in its sizing properties to refer to the size of one or more anchor elements. The anchor-size() function resolves to a &lt;length&gt;.
</p>

<pre class="prod">
anchor-size()
	= anchor( `anchor-element$t? `anchor-size$t, `length-percentage$t? )
`anchor-size@t
	= `width$v
	| `height$v
	| `block$v
	| `inline$v
	| `self-block$v
	| `self-inline$v
</pre>

<p>
`anchor-size$f 関数は、
`anchor$f と類似する
— それは、［
`anchor-side$t が `anchor-size$t に置換される
］ことを除いて，同じ引数をとる。
◎
The anchor-size() function is similar to anchor(), and takes the same arguments, save that the &lt;anchor-side&gt; keywords are replaced with &lt;anchor-size&gt;,＼
</p>

<p>
`anchor-size$t は、
反対-側にある 2 辺の距離を参照rする：
◎
referring to the distance between two opposing sides.
</p>
<dl>
	<dt>`width@v</dt>
	<dt>`height@v</dt>
	<dd>
これらの物理-~keywordは、
順に，`~target~anchor要素$の［
横幅, 縦幅
］を参照rする。
`anchor$f と違って、
軸が合致しなければならない制約は無い
— 例えば、
`width: anchor-size(--foo height)$p は妥当になる。
◎
The physical &lt;anchor-size&gt; keywords (width and height) refer to the width and height, respectively, of the target anchor element. Unlike anchor(), there is no restriction on having to match axises; for example, width: anchor-size(--foo height); is valid.
</dd>

	<dt>`block@v</dt>
	<dt>`inline@v</dt>
	<dt>`self-block@v</dt>
	<dt>`self-inline@v</dt>
	<dd>
<p>
これらの論理-~keywordは、
次に依存して，いずれかの物理的~keywordに対応付けられる：
</p>
		<ul>
			<li>
［
`self-block$v ／ `self-inline$v
］用には，当の要素の`書字~mode$
</li>
			<li>
［
`block$v ／ `inline$v
］用には，当の要素の`包含塊$の`書字~mode$
</li>
		</ul>
◎
The logical &lt;anchor-size&gt; keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).
</dd>
</dl>

<p>
`anchor-size$f 関数のうち`妥当な~anchor~query$を表現しているものは、
`~target~anchor要素$の関連な 2 つの~border辺
— 横幅を参照するならば左端と右端／
縦幅を参照するならば上端と下端 —
の距離を成す `length$t に解決される。
◎
An anchor-size() function representing a valid anchor query resolves to the &lt;length&gt; separating the relevant border edges (either left and right, or top and bottom, whichever is in the specified axis) of the target anchor element.
</p>

		</section>
		<section id="scroll">
<h3 title="Taking Scroll Into Account: the anchor-scroll property">2.3. ~scrollの織り込み法： `anchor-scroll^p ~prop</h3>

◎名 `anchor-scroll@p
◎値 `~noneS$v | `default$v | `anchor-element$t
◎初 `default$v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~scrollingは，処理能の理由から［
実装においては、
~layoutとは別々な~threadで行われる
］ことが多いが、
`anchor$f は，［
位置決め変化, ~layout変化
］両者の結果に基づき得る
（前者は~scrolling~thread内で取扱われ得るが，後者はそうでない）。
このことから、
`anchor$f は，［
当の~anchor要素から当の有位置な要素の`包含塊$までの合間にある，`~scroll容器$
］は［
どれも，各自の初期~scroll位置にある
］ものと見做すよう定義される。
このことは、
有位置な要素は，［
いずれかの`~scroll容器$が，その初期~位置`でない場合^em
］には［
その`~anchor先$【！~its ~anchor】と`整列されなくなる^em
］ことを意味する。
◎
Because scrolling is often done in a separate thread from layout in implementations for performance reasons, but anchor() can result in both positioning changes (which can be handled in the scrolling thread) and layout changes (which cannot), anchor() is defined to assume all the scroll containers between the anchor element and the positioned element’s containing block are at their initial scroll position. This means a positioned element will not be aligned with its anchor if any of the scrollers are not at their initial positions.
</p>

<p>
`anchor-scroll$p ~propは、
当の有位置な要素が単独の`~anchor要素$に~anchorしているときに限り
【実際には、`~snapshot済み~scroll~offset$を有するときに限り】，
これを
— ~scrollingを別々な~threadで行うことによる処理能の便益を失うことなく —
補償することを作者に許容する。
とり得る値は：
◎
The anchor-scroll property allows an author to compensate for this, without losing the performance benefits of the separate scrolling thread, so long as the positioned element is only anchoring to a single anchor element. Its values are:
</p>

<dl>
	<dt>`~noneS@v</dt>
	<dd>
効果なし。
◎
No effect.
</dd>

	<dt>`default@v</dt>
	<dd>
`anchor-element$t と同じに挙動するが、
その値を当の要素の `anchor-default$p の値から引き出す
◎
Behaves identically to &lt;anchor-element&gt;, but draws its value from anchor-default on the element.
</dd>

	<dt id="valdef-anchor-scroll-anchor-element">`anchor-element$t</dt>
	<dd>
`anchor$f と同じように`~target~anchor要素$を選定する
— それが［
位置決め, ~fallback
］において補償されることになる。
◎
Selects a target anchor element the same as anchor(), which will be compensated for in positioning and fallback.
</dd>
</dl>

<p class="note">注記：
当の要素が［
`anchor-default$p を利用する／
`暗黙的な~anchor要素$を伴う
］ときは、
作者は， `anchor-scroll$p に明示的に値を設定することを避けれることが多い
— その初期~値は `default$v なので。
◎
Note: When the element uses anchor-default or has an implicit anchor element, authors can often avoid explicitly setting an anchor-scroll value because the initial value is default.
</p>

<div class="p">
<p>
`絶対的に位置され$た要素 %~query要素 は、
次をいずれも満たすならば，
`~snapshot済み~scroll~offset@
を有する：
</p>
<ul>
	<li>
%~query要素 の `anchor-scroll$p ~propの値 %値 は `~noneS$v でない
</li>
	<li>
`~target~anchor要素$( %~query要素, %値 ) の結果 %~anchor要素 ~NEQ ε
</li>
	<li>
%~query要素 の ある`~inset~prop$は `anchor$f 関数を利用していて，
それは %~anchor要素 を参照rしている
</li>
</ul>
◎
If anchor-scroll is not none on an absolutely-positioned element query el,＼
and there is a target anchor element for query el given the anchor-scroll value,＼
and at least one anchor() function on query el refers to the same target anchor element,＼
then query el has a snapshotted scroll offset,＼
</div>

<p>
`~snapshot済み~scroll~offset$は、［
縦方向~offset, 横方向~offset
］を表現している 2 個の長さが成す~pairである
— 各~offsetは、［
次を満たす各`~scroll容器$
］の`初期~scroll位置$からの~offsetの総和になる
⇒
［
`~target~anchor要素$の先祖である
］~AND［
%~query要素 の`包含塊$の子孫である
］
【この先祖, 子孫は、`~box~tree$に基づくであろう。】
◎
which is a pair of lengths representing a vertical and horizontal offset.
◎
The snapshotted scroll offset is the sum of the offsets from the initial scroll position of all scroll container ancestors of the target anchor element, up to but not including query el’s containing block.
</p>

<p class="issue">
~snapshotを得る精確な時機を定義する必要がある
— それは、
各【描画】~frameごとに，~styleを計算し直す前に更新される。
◎
Define the precise timing of the snapshot: updated each frame, before style recalc.
</p>

		</section>
		<section id="determining">
<h3 title="Determining The Anchor: the anchor-name property">2.4. ~anchorの決定-法： `anchor-name^p ~prop</h3>

◎名 `anchor-name@p
◎値 `~noneN$v | `dashed-ident$t
◎初 `~noneN$v
◎適 `首要~box$を生成するすべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
各種 値は、
次に従って定義される：
◎
Values are defined as follows:
</p>

<dl class="valdef">
	<dt>`~noneN@v</dt>
	<dd>
この~propによる効果は無い。
◎
The property has no effect.
</dd>

	<dt id="valdef-anchor-name-dashed-ident">`dashed-ident$t</dt>
	<dd>
当の要素は、
`首要~box$を生成するならば，
`~anchor要素@
になる。
所与の `dashed-ident^t は、
その
`~anchor名@
を与える
— これは、
`~tree視野な名前$になる。
◎
If the element generates a principal box, the element is an anchor element, with an anchor name equal to the &lt;dashed-ident&gt;. The anchor name is a tree-scoped name.
</dd>
	<dd>
他の場合、
この~propの効果は無い。
◎
Otherwise, the property has no effect.
</dd>
</dl>

<p>
`~anchor関数$は、
名前により，ある`~anchor要素$を参照rする。
この名前は，~page内で一意になることは必要とされないが、
その場合でも，この名前を伴う`~anchor要素$は有位置な要素から~anchorされる能力を有さないかもしれない。
◎
The anchor functions refer to an anchor element by name. That name is not necessarily unique on the page, however; even if it is, the anchor element in question might not be capable of anchoring the positioned element.
</p>

<div class="algo">
<p>
`~target~anchor要素@
【略して、 “~anchor先（ `anchored^en ）” とも称される】
を決定するときは、
所与の
( ~queryしている要素 %~query要素, `~anchor指定子$ %指定子【！anchor spec】 )
に対し：
◎
To determine the target anchor element given a querying element query el and an anchor specifier anchor spec:
</p>
<ol>
	<li>
<p>
~IF［
%指定子 ~EQ `implicit$vA
］：
</p>
		<ol>
			<li>
~IF［
`Popover API^cite †は、
%~query要素 用に`暗黙的な~anchor要素$ %~anchor要素 を定義している
］~AND［
%~anchor要素 は %~query要素 用に`受容-可能な~anchor要素$である
］
⇒
~RET %~anchor要素
</li>
			<li>
~RET ε（該当する要素は無い）
</li>
		</ol>

<p class="trans-note">【†
なぜ `Popover API^cite （この節の末尾にある注記）に限っているのか（限る必要があるのか）は、
よくわからない。
】</p>

◎
If anchor spec is implicit, and the Popover API defines an implicit anchor element for query el which is an acceptable anchor element for query el, return that element.
◎
Otherwise, return nothing.
</li>
	<li>
~Assert：
%指定子 は `dashed-ident$t である。
◎
Otherwise, anchor spec is a &lt;dashed-ident&gt;.＼
</li>
	<li>
%~anchor要素~群 ~LET `~anchor名$に %指定子【！name】 を伴う`~anchor要素$からなる集合
◎
↓</li>
	<li>
<p>
%~anchor要素~群 を成す
~EACH( %要素 )
に対し，`~tree順序$の逆順で：
◎
Return the last element el in tree order that satisfies the following conditions:
• el is an anchor element with an anchor name of name.
</p>
		<ul>
			<li>
<p>
~IF［
%要素 の`~anchor名$に結付けられている`~tree$【！の`根$】
~NEQ
 %指定子【！name】 に結付けられている`~tree$【！の`根$】
］
⇒
~CONTINUE
◎
el’s anchor name and name are both associated with the same tree root.
</p>

<p class="note">注記：
`~anchor名$は`~tree視野な名前$である一方、
%指定子【！name】 は`~tree視野な参照$である。
◎
Note: The anchor name is a tree-scoped name, while name is a tree-scoped reference.
</p>
			</li>
			<li>
~IF［
%要素 は %~query要素 用の`受容-可能な~anchor要素$である
］
⇒
~RET %要素
◎
el is an acceptable anchor element for query el.
</li>
		</ul>
	<li>
~RET ε
（該当する要素は無い）
◎
If no element satisfies these conditions, return nothing.
</li>
</ol>

<p class="note">注記：
これらの条件【どれ？】により捕捉される一般~規則は、［
【結果の？】
%要素 は %~query要素 が~lay-outされる前に全部的に~lay-outされなければならない
【~lay-outする必要が生じるようになる？】
］ことである。
~CSSにおける［
積層~文脈の~layout順序
］用の規則は、
このことについて確証を与える
— 上に挙げた条件たちは、［
~anchor位置決めにおいて，循環依存が生じ得ない
］ことを確保するよう，ちょうど［
積層~文脈~用の規則のうち，この目的に関連なもの
］だけを言い直したものである。
◎
Note: The general rule captured by these conditions is that el must be fully laid out before query el is laid out. CSS’s rules about the layout order of stacking contexts give us assurances about this, and the list of conditions above exactly rephrases the stacking context rules into just what’s relevant for this purpose, ensuring there is no possibly circularity in anchor positioning.
</p>
</div>

<p class="note">注記：
ある`~shadow~tree$内の~style内の `anchor-name$p により定義された`~anchor名$は、
異なる`~shadow~tree$内の~style内の`~anchor関数$からは見えない
（~encapsulationを保全するため）。
しかしながら，異なる`~shadow~tree$内にある`要素どうし^emであっても、［
`~anchor名$, `~anchor関数$
］どちらも
— ある~shadowの内側にある要素を `part()$pe を利用して~styleするなどにより —
同じ~tree内の~styleから来ているならば，互いに他を~anchorできる。
（`暗黙的な~anchor要素$は，内在的には単独の~treeに制限されないが、
その詳細は，それをアテガっている~APIに依存することになる。）
◎
Note: An anchor-name defined by styles in one shadow tree won’t be seen by anchor functions in styles in a different shadow tree, preserving encapsulation. However, elements in different shadow trees can still anchor to each other, so long as both the anchor-name and anchor function come from styles in the same tree, such as by using ::part() to style an element inside a shadow. (Implicit anchor elements also aren’t intrinsically limited to a single tree, but the details of that will depend on the API assigning them.)
</p>

<div class="algo">
<p>
所与の
( 要素 %要素, `絶対的に位置され$た要素 %~query要素 )
に対し，
%要素 は %~query要素 用の
`受容-可能な~anchor要素@
であるとは、
次がすべて満たされることをいう
— 以下における %包含塊 は、
%~query要素 の`包含塊$とする：
◎
An element el is a acceptable anchor element for an absolutely positioned element query el if all of the following are true:
</p>
<ul>
	<li>
［
%要素 【の`首要~box$】は %包含塊 【を確立した~box】の子孫である
］~OR［
%包含塊 は`初期~包含塊$である
］
◎
Either el is a descendant of query el’s containing block, or query el’s containing block is the initial containing block.
</li>
	<li>
［
%要素 の`包含塊$ ~EQ %包含塊
］~AND［
%要素 は次を満たす
］
⇒
［
`絶対的に位置され$ていない
］~OR［
~tree順序において %~query要素 に先行する
］
◎
If el has the same containing block as query el, then either el is not absolutely positioned, or el precedes query el in the tree order.
</li>
	<li>
［
%要素 の`包含塊$ ~NEQ %包含塊
］~AND［
%要素 の`包含塊~連鎖$を成す`包含塊$のうち，
%包含塊 に達する前の最後のもの【を確立した~box】は次を満たす
］
⇒
［
`絶対的に位置され$ていない
］~OR［
~tree順序において %~query要素 に先行する
］
◎
If el has a different containing block from query el, then the last containing block in el’s containing block chain before reaching query el’s containing block is either not absolutely positioned or precedes query el in the tree order.
</li>
</ul>
</div>

<p>
要素は、
ある
`暗黙的な~anchor要素@
を伴い得る
— それは、
`~anchor関数$に明示的な`~anchor名$が指定されなかったとき，利用される。
◎
An element can also have an implicit anchor element, used when an anchor function doesn’t specify an explicit anchor name.
</p>

<p class="note">注記：
例えば `Popover API^cite は、
ある~popover用に，
当の~popoverが付された要素を`暗黙的な~anchor要素$として定義する。
◎
Note: The Popover API, for example, defines an implicit anchor element for a popover—the element that the popover is attached to.
</p>

<p class="trans-note">【
~popover
— （作動化-時に） “他の上層に飛び出すもの” 。
】【
`Popover API^cite が何を指すのか不明だが、
該当しそうな仕様は，［
~HTMLに定義される`~popover＠~HTMLpopover$か，
`その前身＠https://developer.chrome.com/docs/web-platform/popover-api/$
］の他に見当たらない。
しかしながら、
それらの仕様は，`暗黙的な~anchor要素$について何も述べていない。
】</p>

		</section>
		<section id="anchor-default">
<h3 title="Default Anchors: the anchor-default property">2.5. 既定の~anchor： `anchor-default^p ~prop</h3>

◎名 `anchor-default@p
◎値 `anchor-element$t
◎初 `implicit^v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`anchor-default$p ~propは、
当の要素~上のすべての`~anchor関数$用の
`既定の~anchor指定子@
を定義する
— それは、
次を許容する
⇒
複数の要素が，同じ［
`~anchor関数$たちが成す集合,
`位置~fallback~list$
］を利用しながら，
各自が参照rしている`~anchor要素$を変更する。
◎
The anchor-default property defines the default anchor specifier for all anchor functions on the element, allowing multiple elements to use the same set of anchor functions (and position fallback lists!) while changing which anchor element each is referring to.
</p>

<p>
とり得る値は、［
`anchor$f ／ `anchor-size$f
］における `anchor-element$t と一致する。
◎
Its values are identical to the &lt;anchor-element&gt; term in anchor() and anchor-size().
</p>

<div class="example">
<p>
例えば，次の~codeにおける［
`.foo^css, `.bar^css
］要素は、
各自が参照rしている~anchor要素だけを変更しながら，どちらも同じ［
位置決め~propたち, ~fallback
］を利用できる：
◎
For example, in the following code both .foo and .bar elements can use the same positioning properties and fallback, just changing the anchor element they’re referring to:
</p>

<pre class="lang-css">
.anchored {
  position: absolute;
  position-fallback: --under-then-over;
}

@position-fallback --under-then-over {
  @try {
    /* <span class="comment">
`anchor-element$t は指定されてないので、
`anchor-default$p からとる。
◎
No `anchor-element^t specified, so it takes from 'anchor-default'.
</span> */
    top: calc(.5em + anchor(auto));
    bottom: auto;
  }
}

.foo.anchored {
  anchor-default: --foo;
}
.bar.anchored {
  anchor-default: --bar;
}
</pre>
</div>

		</section>
		<section id="queries">
<h3 title="Anchor Queries">2.6. ~anchor~query</h3>

<p>
［
`anchor$f ／ `anchor-size$f
］関数は、
ある
`~anchor~query@
— 1 個以上の`~anchor要素$の 1 個以上の側の位置に対する要請 —
を表現する：
◎
The anchor() and anchor-size() functions represent an anchor query: a request for the position of one or more sides of one or more anchor elements.
</p>

<p>
`~anchor~query$は、
それを表現している［
`anchor$f ／ `anchor-size$f
］関数が次に挙げる条件~すべてを満たす場合に限り，
`妥当な~anchor~query@
とされる
— 以下の記述における［
%関数 は当の関数,
%~prop は %関数 を利用している~prop,
%要素 は %~prop が適用されている要素
］を指すとする：
◎
Anchor queries are valid only if all of the following conditions are true:
</p>
<ul>
	<li>
%要素 は、
`絶対的に位置され$ている。
◎
Their function is used on an element that is absolutely-positioned.
</li>
	<li>
<p>
%関数 は `anchor$f 関数であるならば、
次のいずれかが満たされる：
</p>
		<ul>
			<li>
<p>
［
%関数 内の `anchor-side$t は物理-~keywordでない†
］~AND［
%~prop は、
`~inset~prop$である
］
</p>

<p class="trans-note">【†
この条件は、
この訳による補完
— 無い場合、
次項の条件は不要になってしまうので。
】</p>
</li>
			<li>
［
%関数 内の `anchor-side$t は物理-~keywordである
］~AND［
%~prop は、
~keywordに対応している軸における`~inset~prop$である
］
</li>
		</ul>
◎
If representing an anchor() function, the function is being used in an inset property.
◎
If representing an anchor() function and the &lt;anchor-side&gt; keyword is a physical keyword, it’s used in an inset property in the corresponding axis.
</li>
	<li>
%関数 は `anchor-size$f 関数であるならば、
次が満たされる
⇒
%~prop は、
`~sizing~prop$である
◎
If representing an anchor-size() function, the function is being used in a sizing property.
</li>
	<li>
`~target~anchor要素$( %要素, %関数 内に指定された`~anchor指定子$ ) ~NEQ ε
◎
There is a target anchor element for the element and the anchor name specified in the function.
</li>
</ul>

<p class="note">注記：
`anchor$f 関数の場合，その定義にて指定されたとおり、
`無効な~anchor~query$になる場合，当の関数の~fallback値に解決される。
◎
Note: As specified in the definition of anchor(), an invalid anchor query causes the function to resolve to its fallback value instead.
</p>

		</section>
	</section>
	<section id="fallback">
<h2 title="Fallback Sizing/Positioning">3. ~fallback［~sizing／位置決め］</h2>

<p>
~anchor位置決めは、
強力ではあるが，予測-不能にもなり得る。
`~anchor要素$は，~page上のどこにでも~~現れ得るので、
ある有位置な要素を特定0の流儀（当の~anchorの上や右端など）で位置した結果、
当の要素は，［
自身の`包含塊$を~overflowする／
部分的に~screen外に位置される
］かもしれない。
◎
Anchor positioning, while powerful, can also be unpredictable. The anchor element might be anywhere on the page, so positioning an element in any particular fashion (such as above the anchor, or the right of the anchor) might result in the positioned element overflowing its containing block or being positioned partially off screen.
</p>

<p>
これを~~改善するため、
`絶対的に位置され$る要素は，
`position-fallback$p ~propを利用して ある `position-fallback$at 規則を参照rできる。
この規則を成す~blockは、［
試行される~style規則~群としてアリなもの
］たちが成す~listを与える。
この~listを成す各~規則~群は、
順に 1 つずつ当の要素に適用され，［
その結果，要素が自身の`包含塊$を~overflowしない最初のもの
］が~~採用されることになる。
◎
To ameliorate this, an absolutely positioned element can use the position-fallback property to refer to a @position-fallback block, giving a list of possible style rules to try out. Each is applied to the element, one by one, and the first that doesn’t cause the element to overflow its containing block is taken as the winner.
</p>

		<section id="fallback-property">
<h3 title="The position-fallback Property">3.1. `position-fallback^p ~prop</h3>

◎名 `position-fallback@p
◎値 `~noneF$v | `dashed-ident$t
◎初 `~noneF$v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt>`~noneF@v</dt>
	<dd>
この~propによる効果は無い
— 当の要素は、
`位置~fallback~list$を利用しない。
【`自動的な~anchor位置決め$により生成されるものを除けば。】
◎
The property has no effect; the element does not use a position fallback list.
</dd>

	<dt id="valdef-position-fallback-dashed-ident">`dashed-ident$t</dt>
	<dd>
［
指定された識別子に合致している名前
］を伴う `position-fallback$at 規則が在る場合、
当の要素は，それが定義する`位置~fallback~list$を利用する。
◎
If there is a @position-fallback rule with a name matching the specified ident, then the element uses that position fallback list.
</dd>
	<dd>
他の場合，この値の効果は無い。
◎
Otherwise, this value has no effect.
</dd>
</dl>

		</section>
		<section id="fallback-rule">
<h3 title="The @position-fallback Rule">3.2. `position-fallback^at 規則</h3>

<p>
`position-fallback@at
規則は、
所与の名前を伴う`位置~fallback~list$を定義する
— それは、
1 個以上の
`try@at
~blockからなる。
各 `try$at ~blockの内側には、
要素に適用され得る一群の位置決め~propを指定する。
各 `try$at ~blockは、
直前の `try$at ~blockの~fallbackとして~serveする
— すなわち、［
ある~blockを適用した結果、
当の要素が自身の`包含塊$を一部でも~overflowする
］場合には，直後の~blockを適用しようと試行する。
◎
The @position-fallback rule defines a position fallback list with a given name, specifying one or more sets of positioning properties inside of @try blocks that will be applied to an element, with each successive one serving as fallback if the previous would cause the element to partially or fully overflow its containing block.
</p>

<p>
`position-fallback$at 規則の文法は：
◎
The grammar of the @position-fallback rule is:
</p>

<pre class="prod">
@position-fallback `dashed-ident$t {
	`rule-list$t
}

@try { `declaration-list$t }
</pre>

<p>
`position-fallback$at 規則 %規則 が `rule-list$t にて受容する規則は、
`try$at に限られる。
%規則 の導入部にて指定される `dashed-ident$t が， %規則 の名前になる。
同じ名前を伴う複数個の `position-fallback^at 規則が宣言された場合、
文書~順序で最後のものが優先される。
◎
The @position-fallback rule only accepts @try rules. The &lt;dashed-ident&gt; specified in the prelude is the rule’s name. If multiple @position-fallback rules are declared with the same name, the last one in document order "wins".
</p>

<p>
`try$at 規則が受容する`~prop$は、
次に挙げるものに限られる：
◎
The @try rule only accepts the following properties:
</p>
<ul>
	<li>
`~inset~prop$
◎
inset properties
</li>
	<li>
`~sizing~prop$
◎
sizing properties
</li>
	<li>
`~box整列~prop$
◎
box alignment properties
</li>
</ul>

<p class="issue">
ここに何が許容されるかを決定する拘束は、
正確には何か？
現在の~listは、
Chrome の試験的な実装からの適度なものに基づく。
少なくとも［
子孫~用に，より一般的な~style法を許容する
］ために，
どの~fallbackが利用されたかに基づいて `make a CQ^en 【？】できよう。
◎
What exactly are the constraints that determine what’s allowed here? Current list is based off of what’s reasonable from Chrome’s experimental impl. We can make a CQ that keys off of which fallback was used to allow more general styling, at least for descendants.
</p>

<p>
`position-fallback$at 規則は、
`位置~fallback~list@
を指定する
— この~listを成す各~entryは、
順に，規則の内側にある各 `try$at 規則に指定された一群の~propからなる。
◎
The @try rules inside a @position-fallback specify a position fallback list, where each entry consists of the properties specified by each @try, in order.
</p>

<p class="issue">
ある有位置な要素の~anchor（たち）が，
~scrollされて全部的に~screen外にあるとき、
そのことが検出-可能になり，当の要素の表示をまるごと抑止できれば有用になろう。
例えば、
要素が~anchor用の~tooltipを成す~textを保持していて，当の`~scroll容器$の外側に住まう場合。
【！don’t want to just hover...】
◎
Would be useful to be able to detect when your anchor(s) are fully off-screen and suppress your display entirely. For example, tooltips living outside the scroller holding the text they’re anchored to don’t want to just hover over arbitrary parts of the page because their anchor happens to have that position relative to the scrollport.
</p>

<p class="note">注記：
異なる~anchorを利用している複数の要素が，同じ［
各自の~anchor要素に相対的な~fallback位置決め
］を利用したいと求めるなら、
`anchor$f 内の `anchor-element$t を省略して，
代わりに `anchor-default$p 内に各~要素の~anchorを指定する。
◎
Note: If multiple elements using different anchors want to use the same fallback positioning, just relative to their own anchor elements, omit the &lt;anchor-element&gt; in anchor() and specify each element’s anchor in anchor-default instead.
</p>

<p class="note">注記：
最も共通的な~fallback位置決め
（有位置な要素を通常は~anchorの一方の側に置くが，必要なら反対-側に移転するよう）
は、
`anchor$f 関数~内に［
`auto$vA ／ `auto-same$vA【！auto-side】
］値を利用することにより，自動的に行える
— `position-fallback$at をまったく利用することなく。
◎
Note: The most common types of fallback positioning (putting the positioned element on one side of the anchor normally, but flipping to the opposite side if needed) can be done automatically, without using @position-fallback at all, by using auto or auto-side side values in the anchor() function.
</p>

		</section>
		<section id="fallback-apply">
<h3 title="Applying Position Fallback">3.3. 位置~fallbackの適用-法</h3>

<p>
`位置~fallback~list$を利用する要素は、［
以下に定義されるとおり，この~listから一つに選定された~entry
］を成す各~propを，`使用~値$として自身に適用する。
◎
When an element uses a position fallback list, it selects one entry from the list as defined below, and applies those properties to itself as used values.
</p>

<p class="note">注記：
これらを使用~値として適用する必要があるのは、
~layoutの最中に適用されるからである
— それらが どう相互作用するかを~cascadeで定義することは、
どう転んでも極めて紛らわしくなり，たぶん実際に循環依存になる。
そうすることは、
どの事例でも［
仕様~化／実装
］の~costに見合わない。
◎
Note: These have to be applied as used values because we’re in the middle of layout right now; defining how they’d interact with the cascade would be extremely confusing *at a minimum*, and perhaps actually circular. In any case, not worth the cost in spec or impl.
</p>

<p class="issue">
このことは、
当の値たちは，通例的な流儀では遷移し得ないことを含意する
— 遷移は算出d値に基づくが、
その時点は過ぎ去ったので。
しかしながら、
~popoverを他の位置へ滑らすことは，
~UI~libraryにおいて共通的な効果である。
おそらく、
`position-fallback$p には，［
~fallbackされた~propの “自動的な~animation” を誘発する
］ための `smooth^v ~keywordを導入するべきである。
◎
This implies that the values can’t be transitioned in the usual fashion, since transitions key off of computed values and we’re past that point. However, popovers sliding between positions is a common effect in UI libs. Probably should introduce a smooth keyword to position-fallback to trigger automatic "animation" of the fallback’d properties.
</p>

<div class="algo">
<p>
要素 %要素 の
`位置~fallback~style群を決定する@
ときは：
◎
To determine the position fallback styles of an element el:
</p>
<ol>
	<li>
%基底~style群 ~LET %要素 にて利用されている現在の~style
◎
Let base styles be the current used styles of el.
</li>
	<li>
%調整-済み~style群 ~LET ε
◎
↓</li>
	<li>
<p>
`位置~fallback~list$を成す
~EACH( %~fallback~style群 )
に対し：
◎
For each fallback styles in the position fallback list:
</p>
		<ol>
			<li>
<p>
%~fallback~style群 を成す各~styleを %要素 に適用する
— %基底~style群 を成す対応する~propを上書きするよう：
</p>
				<ul>
					<li>
%調整-済み~style群 ~SET ［
指定d値／算出d値／使用~値
］の時点における［
上書きした~styleの`使用~値$を得るために要求される正規化
］（`~math関数$を解決するなど）を遂行した結果の %要素 の~style群
</li>
					<li>
%~margin~box ~LET ~styleを %要素 に適用した結果の %要素 の`~margin~box$
</li>
					<li>
%改変された包含塊 ~LET %要素 の`~insetで改変された包含塊$
</li>
				</ul>
◎
Apply the styles in fallback styles to el, overriding the corresponding properties in base styles.
◎
Perform any specified/computed/used-value time normalizations that are required to make the overridden styles into used values (such as resolving math functions, etc).
◎
Let adjusted styles be el’s styles after these adjustments.
◎
↓</li>
			<li>
<p>
~IF［
%要素 は`~snapshot済み~scroll~offset$ %~offset を有する
］：
</p>
				<ol>
					<li>
%~margin~box ~SET %~margin~box の位置から %~offset を減算した結果
◎
If el has a snapshotted scroll offset, then subtract the offsets from el’s margin box’s position.
</li>
					<li>
%要素 の
~EACH( `~inset~prop$ %~prop )
に対し
⇒
~IF［
%~prop の値 ~NEQ `auto$v
］
⇒
%~prop の値から対応する軸における %~offset を減算する
◎
Also, if any of el’s inset properties are non-auto, subtract the snapshotted scroll offset for the appropriate axis from their values.＼
</li>
					<li>
%改変された包含塊 ~SET 前~段によりズラされた［
%要素 の各`~inset~prop$の値
］を利用して，
%要素 の`~insetで改変された包含塊$を計算し直した結果
◎
Recalculate el’s inset-modified containing block using these shifted values to obtain the scroll-adjusted IMCB.
</li>
				</ol>
			</li>
			<li>
~IF［
%~margin~box は， %改変された包含塊 の中に全部的に包含されている
］
⇒
~BREAK
◎
If el’s margin box is fully contained within the scroll-adjusted IMCB,＼
</li>
		</ol>
	</li>
	<li>
~RET %調整-済み~style群
◎
or fallback styles is the final entry in the position fallback list, then use adjusted styles for el and exit this algorithm.
</li>
</ol>

<p class="note">注記：
%要素 を~overflowしている子孫は、
この計算には影響しない
— 影響するのは %要素 の`~margin~box$に限られる。
◎
Note: Descendants overflowing el don’t affect this calculation, only el’s own margin box.
</p>

<p>
この~algoから返された~style群が，
%要素 に指定された~prop用の最終-値を与える。
◎
The styles returned by determining the position fallback styles are taken as the final values for the specified properties.
</p>
</div>

<p>
実装は、［
~layout作業に要求され得る量が過度なとき，それを制限する
］ためとして，［
`位置~fallback~list$の長さに対し，実装定義な上限を課す
］ことを選んでもヨイ。
この上限は、
5 `以上^emにするモノトスル。
◎
Implementations may choose to impose an implementation-defined limit on the length of position fallback lists, to limit the amount of excess layout work that may be required. This limit must be at least five.
</p>

<div class="issue">
<p>
入子な~anchorが在る場合
— ある~anchorされた要素 A が、
別の~anchorされた要素 B の内側に在る場合 —
~fallbackを行うとき，~layout回数が指数関数的になり得る
— 要素 A が，先祖に~scrollbarを生じさせ得る結果、
要素 B 用の`~insetで改変された包含塊$を変化させ，
場合によっては，それ【どれ？】用に選ぶ~fallbackを変化させるので。
◎
Nested anchors (an anchored element inside of another anchored element) present the potential for exponential blow-up of layouts when doing fallback, since the grandchild anchored element can cause scrollbars on an ancestor, changing the IMCB for the child anchored element, thus possibly causing the fallback choice to change for it.
</p>

<p>
これを避ける策はあるが、
それらにも~costがかかる。
これを避けるためには、
`おそらく^em，【~layout回数の】<strong>最大</strong>な上限も課すべきである。
◎
There are strategies to avoid this, but they’re not without costs of their own. We should probably impose a maximum limit as well, to avoid this.
</p>

<p>
しかしながら、
そもそも，ほとんどの用法では問題になり得ることはないので、
込み入った状況で そうなることを防止するためだけに，
それらを無闇に制約することは求まれない。
たぶん，［
各~levelにおける分岐数
］に基づくような複階性の総量にするか？
— 各~先祖の~fallback~listの長さの積を累積していって、
この総量が最大な上限を超過して以降は，最初のものしか選ばれなくなる様な
【！Get too deep and you’re stuck with your first choice only】。
これは、
何らかの適度な入子ngでも，
~top-level用に巨大で複階的な~fallback~listを許容することになる
（例えば，この上限を 1000 にしたなら、
各~listの長さが 5 のときは，深さ 4 まで入子にすることもできる）。
◎
However, since *most* usages won’t be problematic in the first place, we don’t want to restrict them unduly just to prevent weird situations from exploding. Perhaps a complexity budget based on the branching factor at each level? Like, accumulate the product of the fallback list lengths from ancestors, and your fallback list gets limited to not exceed a total product of, say, 1k. Get too deep and you’re stuck with your first choice only! But this would allow large, complex fallback lists for top-level stuff, and even some reasonable nesting. (Length-five lists could be nested to depth of 4, for example, if we did go with 1k.)
</p>

<p>
もっと思慮が必要である。
◎
More thought is needed.
</p>
</div>

<div class="example">
<p>
例えば，次の~CSSは、
ある “~popover”† を，まずは［
~buttonの下に位置させ, 
左端と~buttonの左端を整列する
］ようと試みるが、
~screenに収まらない場合には，順に［
上, 左端
］, ［
下, 右端
］, ［
上, 右端
］を試みるよう切替えることになる。
【† 何らかの動作（この例では、~button上の~hoverなど）に呼応して，他のものの上層に表示される様な~UI。】
◎
For example, the following CSS will first attempt to position a "popover" below the element, but if it doesn’t fit on-screen will switch to being above; it defaults to left-aligning, but will switch to right-aligning if that doesn’t fit.
</p>

<pre class="lang-css">
#myPopover {
  position: fixed;
  position-fallback: --button-popover;
  overflow: auto;

  /* <span class="comment">
~popoverの横幅を~buttonの横幅~以上にする
◎
The popover is at least as wide as the button
</span> */
  min-width: anchor-size(--button width);

  /* <span class="comment">
~popoverの縦幅を［
~menu~item 2 個分
］以上にする
◎
The popover is at least as tall as 2 menu items
</span> */
  min-height: 6em;
}

@position-fallback --button-popover {
  /* <span class="comment">
まず，
~popoverの［
上端／左端
］辺と~buttonの［
下端／左端
］辺を整列するよう試行する。
◎
First try to align the top, left edge of the popover with the bottom, left edge of the button.
</span> */
  @try {
    top: anchor(--button bottom);
    left: anchor(--button left);
  }

  /* <span class="comment">
次に，~popoverの［
下端／左端
］辺と~buttonの［
上端／左端
］辺を整列するよう試行する。
◎
Next try to align the bottom, left edge of the popover with the top, left edge of the button.
</span> */
  @try {
    bottom: anchor(--button top);
    left: anchor(--button left);
  }

  /* <span class="comment">
次に，~popoverの［
上端／右端
］辺と~buttonの［
下端／右端
］辺を整列するよう試行する。
◎
Next try to align the top, right edge of the popover with the bottom, right edge of the button.
</span> */
  @try {
    top: anchor(--button bottom);
    right: anchor(--button right);
  }

  /* <span class="comment">
最後に，~popoverの［
下端／右端
］辺と~buttonの［
上端／右端
］辺を整列するよう試行する。
他の位置もアリだが、
これが，作者が描画~engineに試行させたい最終-~optionになる。
◎
Finally, try to align the bottom, right edge of the popover with the top, right edge of the button. Other positions are possible, but this is the final option the author would like the rendering engine to try.
</span> */
  @try {
    bottom: anchor(--button top);
    right: anchor(--button right);
  }
}
</pre>
</div>

		</section>
	</section>
	<section id="sec">
<h2 title="Security Considerations">4. ~securityの考慮点</h2>

<p>
この文書に対し提起された~securityの課題は無い。
◎
No Security issues have been raised against this document.
</p>

	</section>
	<section id="priv">
<h2 title="Privacy Considerations">5. ~privacyの考慮点</h2>

<p>
この文書に対し提起された~privacyの課題は無い。
◎
No Privacy issues have been raised against this document.
</p>

	</section>
</main></div>
