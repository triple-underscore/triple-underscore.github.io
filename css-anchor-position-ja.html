<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Anchor Positioning （日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<script src="common0.js"></script>
<script src="common1.js" async></script>

<script >

Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if(i > 0) {
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i + 1)}</code>`;
		}
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">
●●options

spec_title:CSS Anchor Positioning
spec_date:2023-06-13
trans_update:2023-06-14
source_checked:230606
page_state_key:CSS
original_url:https://drafts.csswg.org/css-anchor-position-1/
	abbr_url:CSSANCHOR
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:layouts,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2023-03-06

●●class_map
p:property
at:at-rule
t:type
v:value
vA:value
f:func
pe:pseudo
css:css
e:element

●●tag_map
p:code
t:var
v:code
vA:code
css:code
at:code
pe:code
e:code
c:code
f:code
cite:cite
em:em

●●original_id_map

●●mdn_urls
	propdef-anchor-default:CSS/anchor-default
	propdef-anchor-name:CSS/anchor-name
	propdef-anchor-scroll:CSS/anchor-scroll
	propdef-position-fallback:CSS/position-fallback

●●link_map

at.position-fallback:#at-ruledef-position-fallback
at.try:#at-ruledef-try

p.anchor-default:#propdef-anchor-default
p.anchor-name:#propdef-anchor-name
p.anchor-scroll:#propdef-anchor-scroll
p.position:~CSSPOS#propdef-position
p.position-fallback:#propdef-position-fallback
p.position-fallback-bounds:#propdef-position-fallback-bounds
p.right:~CSSPOS#propdef-right
p.bottom:~CSSPOS#propdef-bottom
p.left:~CSSPOS#propdef-left
p.top:~CSSPOS#propdef-top
p.width:~SIZING#propdef-width

f.anchor-size:#funcdef-anchor-size
f.anchor:#funcdef-anchor
f.translate:~TRANSFORM#funcdef-transform-translate

t.anchor-element:#typedef-anchor-element
t.anchor-side:#typedef-anchor-side
t.anchor-size:#typedef-anchor-size
t.dashed-ident:~CSSVAL#typedef-dashed-ident
	t.dashed-ident:#valdef-anchor-dashed-ident
	t.dashed-ident:#valdef-anchor-name-dashed-ident
	t.dashed-ident:#valdef-position-fallback-dashed-ident
t.declaration-list:~CSSSYN#typedef-declaration-list
t.length-percentage:~CSSVAL#typedef-length-percentage
t.percentage:~CSSVAL#percentage-value
	t.percentage:#valdef-anchor-percentage
t.rule-list:~CSSSYN#typedef-rule-list
t.length:~CSSVAL#length-value

v.block:#valdef-anchor-size-block
v.height:#valdef-anchor-size-height
v.inline:#valdef-anchor-size-inline
v.self-block:#valdef-anchor-size-self-block
v.self-inline:#valdef-anchor-size-self-inline
v.width:#valdef-anchor-size-width

v.default:#valdef-anchor-scroll-default
v.none:#valdef-anchor-name-none
v.~noneN:#valdef-anchor-name-none
v.~noneF:#valdef-position-fallback-none
v.~noneS:#valdef-anchor-scroll-none
v.normal:#valdef-position-fallback-bounds-normal

v.auto:~CSSPOS#valdef-top-auto

vA.auto:#valdef-anchor-auto
vA.auto-same:#valdef-anchor-auto-same
vA.bottom:#valdef-anchor-bottom
vA.center:#valdef-anchor-center
vA.end:#valdef-anchor-end
vA.implicit:#valdef-anchor-implicit
vA.left:#valdef-anchor-left
vA.right:#valdef-anchor-right
vA.self-end:#valdef-anchor-self-end
vA.self-start:#valdef-anchor-self-start
vA.start:#valdef-anchor-start
vA.top:#valdef-anchor-top

pe.part():~CSSSHADOWPARTS#selectordef-part

e.input:~HEinput#the-input-element

	●用語
~anchor要素:#anchor-element
~anchor関数:#anchor-functions
~anchor名:#anchor-name
~anchor位置決め:#anchor-positioning
~anchor指定子:#anchor-specifier
妥当な~anchor関数:#valid-anchor-function
妥当な~anchor~size関数:#valid-anchor-size-function
自動的な~anchor~fallback:#automatic-anchor-fallbacks
暗黙的な~anchor要素:#implicit-anchor-element
位置~fallback~list:#position-fallback-list
位置~fallback~style群を決定する:#determine-the-position-fallback-styles
追加的な~fallback限界域~矩形:#additional-fallback-bounds-rect
~target~anchor要素:#target-anchor-element
~anchor先:#target-anchor-element
自動的な~anchor位置決め:#automatic-anchor-positioning
既定の~anchor指定子:#default-anchor-specifier
受容-可能な~anchor要素:#acceptable-anchor-element
~snapshot済み~scroll~offset:#snapshotted-scroll-offset

	●用語（ CSS
断片:~CSSBREAK#fragment
~box整列~prop:~CSSALIGN#box-alignment-properties
包含塊~連鎖:~CSSDISP#containing-block-chain
包含塊:~CSSDISP#containing-block
要素:~CSSDISP#elements
首要~box:~CSSDISP#principal-box
初期~包含塊:~CSSDISP#initial-containing-block
~box~tree:~CSSDISP#box-tree
~inset~prop:~CSSPOS#inset-properties
	~inset~prop:~CSSLOGICAL#inset-properties
~insetで改変された包含塊:~CSSPOS#inset-modified-containing-block
~margin~box:~CSSBOX#margin-box
~padding~box:~CSSBOX#padding-box
~math関数:~CSSVAL#math-function
~prop:~CASCADE#css-property
使用~値:~CASCADE#used-value
書字~mode:~CSSWM#writing-mode
~sizing~prop:~SIZING#sizing-property
絶対~位置決め:~CSSPOS#absolute-position
固定d位置決め:~CSSPOS#fixed-position
絶対的に位置され:~CSSPOS#absolute-position
有位置:~CSSPOS#positioned-box
上端~層:~CSSPOS4#document-top-layer

行内-軸:~CSSWM#inline-axis
~tree視野な参照:~CSSSCOPING#css-tree-scoped-reference
~tree視野な名前:~CSSSCOPING#css-tree-scoped-name

~scroll容器:~CSSOVERFLOW3#scroll-container
~scrollport:~CSSOVERFLOW3#scrollport
初期~scroll位置:~CSSOVERFLOW3#initial-scroll-position

	●用語（他

cite.Popover API:#_popover-api

	~listを反復する:~INFRA#list-iterate
根:~DOM4#concept-tree-root
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order
~shadow~tree:~DOM4#concept-shadow-tree

●●words_table1
CSSSHADOWPARTS:css-shadow-parts-ja.html

noneN:none
noneF:none
noneS:none

●●words_table


	●幾何
限界:bounding::~
限界域:bounds::~
矩形:rectangle:~
	矩形:rect
中央:center:~
	中央に寄せ:center
ズラす:shiftする:ずらす
ズラされ:shiftされ:ずらされ
ズラして:shiftして:ずらして
縦方向:vertical:~
横方向:horizontal:~
横:horizontal:~
側:side:~
反対-:opposite:~
	反対-側の:opposing
	反対-側の:opposite

	縦幅:tall
	幅広:wide
	横幅:wide
	幅:wide
	の距離を成す:separating

	●layout
首要:principal::主要
収まる:fitする:~
収まら:fitし:~
滑らす:slideする:~
scrollport::::スクロール域
	揃う:line up
scrolling::::スクロール処理
重合する:overlapする:重なり合う
固定d:fixed::固定

	`~scroll容器$:scroller
	`~insetで改変された包含塊$:IMCB
	〜へ整列するよう:-aligning
	軸が揃えられた:axis-aligned
	移転-:flip
	固定d位置決め:fixpos
	覆う:coverする:~
	少し上へ離して:slightly away from 〜 hovering just above it
	~padding~box:padding-box
	内容~box:content-box

	●CSS
視野な:scopedな::~
	~tree視野な:tree-scoped
導入部:prelude:~
書字:writing::~
捕捉-:capture:~
変形:transform::~
積層:stacking::~
	~anchor先:anchored
	~anchor法:anchoring

	●UI
tooltip::::ツールチップ
hover:
popover:


	●処理
累積-:accumulate:~
積:product:~
深さ:depth:~
切詰める:clampする:切り詰める

	そうなること:exploding
	総量:budget
	分岐数:branching factor
	回数が指数関数的:exponential blow-up
	この上限:total product
	深過ぎる:get too deep
	-:stuck
	巨大:large
	切り替わる:swap
	入れ替える:swapped
	調べる:looking at
	-:exit

	%~query要素:query el
	%要素:el
	%調整-済み~style群:adjusted styles
	%指定子:anchor spec
	%基底~style群:base styles
	%~fallback~style群:fallback styles
	%改変-済み包含塊:scroll-adjusted IMCB

	●仕様
策:strategy:~
柔軟性:flexibility:~
普通の:ordinaryな:~
流儀:fashion:~
encapsulation::::カプセル化
提起-:raise:~
確証:assurance:~
循環依存に:circularに:~
循環依存:circularity:~
思慮:thought:~
切替える:switchする:切り替える
過度:excess:~
適度:reasonable:~
見出法:finding:見出し方
各利用:usage:~
協調:coordination:~
復旧-:restore:~

	にも~costがかかる:not without costs of their own
	問題になり得る:problematic
	極めて:extremely
	ようになった:end up with
	そうなるかどうかは:vary
	仮に〜とする:say
	させたい:would like
	し易く:make it easier
	当の:in question
	生じ得ない:there is no possibly
	他では:otherwise
	およそ:more or less
	さらには〜もっと〜までも:even more
	どう転んでも:*at a minimum*
	見合わない:not worth
	実装:impl
	編集者:I
	考えて:think
	〜を除いて:save that
	必要とされない:not necessarily
	課す~impose:#2
	~~改善:ameliorate
	~~採用:taken as the winner
	~~採用:take
	紛らわしく:confusing
	に基づくように:in terms of
	単に:merely
	優先される:"wins"
	込み入った:weird
	選ぶ:choice
	選んで:chooseして
	選ばれ:chosen
	選べる:chooseでき
	に基づいて:keys off
	ちょうど:exactly
	無闇に:unduly
	そもそも、:in the first place
	言い直:rephrase
	〜に基づく:key off
	に関する:around
	これらの:extra
	伴うようになる:gain
	関わることなく:without regard to
	別として:beside
	気にする:worry
	より強い:stronger
	ちょうど:exactly
	少し:slightly
	-:aka
	満たす:satisfy
	失うこと:losing
	失われ:lose

	●未分類
参照r:refer:参照
math:
補償-:compensate:~
最終-:final:~
時機:timing:~
超過-:exceed:~
	超過した場合:Get too deep
上限:limit:~
総和:sum:~
付され:attachされ:~
先行-:precede:~

	引き出す:draw
	の距離を成す:separating
	一群の:sets of
	~library:libs
	~tree視野な:tree-scoped
	同時に:at once
	1000:1k
	識別子:ident
	直前の~blockを適用した結果:the previous 〜 successive one
	住まう:living
	現れる:appearする
	一部でも:partially or fully
	無い:none
	以上:at least
	次に，Next,
	来ている:come form
	計算し直す:recalc
	最も近い:closest
	順に 1 つずつ:one by one
	時点:point
	多数の:bunch of
	3 個目の:final
	最後に:Finally,
	過ぎ去った:past
	に~~達する前まで:up to but not including
	-:in turn
	-:grandchild
	~screen外:off-screen
	~screenからはみ出る:put part of it off-screen
	~screen外:offscreen
	~screen外:off screen
	~screen内に収まる:remain on-screen
	~screen内に収まる:fit on-screen
	-:stuff
	逆にした:reverse
	入れ替えて:swap
	置く:putting
	Chrome
	^en:make a CQ
	量:amount
	探す:look for
	~layoutの最中に適用される:in the middle of layout right now
	~entry列:consecutive entries
	箇所:place
	どこに在ってもよい:can live anywhere
	住まう:live
	~entry列:consecutive entries
	~EQ ε:was not passed
	ε:nothing
	基準に:against
	逆にした:reverse
	来ている:comes from
	より長く:longer
	~~生成-:gain
	~anchor~size:anchor-size
	~scroll調整-済み:~scroll-adjusted


●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-DISPLAY-4]
    CSS Display Module Level 4 URL: https://drafts.csswg.org/css-display-4/
[CSS-LOGICAL-1]
    Rossen Atanassov; Elika Etemad. ＜CSS Logical Properties and Values Level 1＞. URL: https://drafts.csswg.org/css-logical-1/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-POSITION-4]
    CSS Positioned Layout Module Level 4 URL: https://drafts.csswg.org/css-position-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[FULLSCREEN]
    Philip Jägenstedt. ＜Fullscreen API Standard＞. Living Standard. URL: https://fullscreen.spec.whatwg.org/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119

●●ref_informative

[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Anchor Positioning</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-anchor-position-1">CSSWG Issues Repository</a>
編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="https://twitter.com/jh3yy">Jhey Tompkins</a> (Google)
	Ian Kilpatrick (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-anchor-position-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-anchor-position-1
</script>

</head><body>

<header>
	<hgroup>
<h1 title="CSS Anchor Positioning">CSS アンカー位置決め</h1>
<p>CSS Anchor Positioning</p>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この仕様は “~anchor位置決め” を定義する。
そこでは、
有位置な要素†が［
~page上の他所にある 1 個以上の “~anchor要素”
］に相対的に，自身を~sizeして位置できる。
◎
This specification defines 'anchor positioning', where a positioned element can size and position itself relative to one or more "anchor elements" elsewhere on the page.
</p>

<p class="trans-note">【†
この仕様における`有位置$な要素は、
実際には，（より限定的な）`絶対的に位置され$た要素の略称である。
】</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSの`絶対~位置決め$は、
要素を~page上のどこにでも
— 要素の包含塊は別として，他の要素の~layoutに関わることなく —
配置することを作者に許容する。
この柔軟性は、
ごく有用になり得るが，ごく制限されてもいる
— 要素を他の`何らかの^em要素に相対的に位置するよう求まれることは多い。
`~anchor位置決め@
は、
`~anchor関数@
— `anchor$f, `anchor-size$f の総称 —
を介して，これを達成することを作者に許容する
— それは、
ある`絶対的に位置され$た要素を［
~page上の他の 1 個以上の要素
］を “~anchor先に” しながら，［
他と重合する／~overflowする
］ことを避ける “最良な” ものを見出すよう［
いくつかのアリな位置を試行する
］ことを許容する。
◎
CSS absolute positioning allows authors to place elements anywhere on the page, without regard to the layout of other elements besides their containing block. This flexibility can be very useful, but also very limiting—often you want to position relative to some other element. Anchor positioning (via the anchor functions anchor() and anchor-size()) allows authors to achieve this, "anchoring" an absolutely-positioned element to one or more other elements on the page, while also allowing them to try several possible positions to find the "best" one that avoids overlap/overflow.
</p>

<div class="example">
<p>
作者は、
ある~tooltip【 `.tooltip^css 】を ~targetにされた要素【 `.anchor^css 】の中央かつ上に
— ただし、
そうすると~screen外に配置される事例では，下に —
位置するよう求めることもあろう。
これは、
次の~CSSで行える：
◎
For example, an author might want to position a tooltip centered and above the targeted element, unless that would place the tooltip offscreen, in which case it should be below the targeted element. This can be done with the following CSS:
</p>

<pre class="lang-css">
.anchor {
  /* <span class="comment">
【`--tooltip^v と命名された`~anchor要素$。】
</span> */
  anchor-name: --tooltip;
}
.tooltip {
  /* <span class="comment">
`固定d位置決め$は、
包含塊の関係性を気にする必要は無いことを意味する
— 当の~tooltipは、
~DOM内のどこに在ってもよい。
◎
Fixpos means we don’t need to worry about containing block relationships; the tooltip can live anywhere in the DOM.
</span> */
  position: fixed;

  /* <span class="comment">
~anchor法の挙動は、
すべて，既定では `--tooltip^v と命名された~anchorを参照rすることになる。
◎
All the anchoring behavior will default to referring to the --tooltip anchor.
</span> */
  anchor-default: --tooltip;

  /* <span class="comment">
［
~tooltipの下端を~anchorの上端に整列する
］が、
~UIwindowを~overflowする場合は，代わりに［
~tooltipの上端が~anchorの下端に整列する
］よう自動的に切り替わる。
◎
Align the tooltip’s bottom to the top of the anchor, but automatically swap if this overflows the window to the tooltip’s top aligns to the anchor’s bottom instead.
</span> */
  bottom: anchor(auto);

  /* <span class="comment">
幅 `300px^v の区画を当の~anchor上で中央に寄せるよう設定しておく。
中央に寄せた結果，~screenからはみ出る場合、
~screen内に収まるよう切詰める。
◎
Set up a 300px-wide area, centered on the anchor. If centering would put part of it off-screen, instead clamp it to remain on-screen.
</span> */
  left: clamp(0px, anchor(center) - 150px, 100% - 300px);
  right: clamp(0px, anchor(center) - 150px, 100% - 300px);
  max-width: 300px;

  /* <span class="comment">
当の~tooltipを上の区画~内で中央に寄せる
◎
Center the tooltip in that area.
</span> */
  justify-self: center;
}
</pre>
</div>

	</section>
	<section id="determining">
<h2 title="Determining The Anchor">2. ~anchorの決定-法</h2>

		<section id="name">
<h3 title="Creating An Anchor: the anchor-name property">2.1. ~anchorの作成-法： `anchor-name^p ~prop</h3>

◎名 `anchor-name@p
◎値 `~noneN$v | `dashed-ident$t
◎初 `~noneN$v
◎適 `首要~box$を生成するすべての要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`anchor-name$p ~propは、
要素が
`~anchor要素@
になるものと宣言する。
要素は、
この~propに与えた
`~anchor名@
により~targetにされる。
各種 値は、
次に従って定義される：
◎
The anchor-name property declares that an element is an anchor element, and gives it an anchor name to be targeted by. Values are defined as follows:
</p>

<dl class="valdef">
	<dt>`~noneN@v</dt>
	<dd>
この~propによる効果は無い。
◎
The property has no effect.
</dd>

	<dt id="valdef-anchor-name-dashed-ident">`dashed-ident$t</dt>
	<dd>
当の要素は、
`首要~box$を生成するならば，`~anchor要素$になる。
所与の `dashed-ident^t が，その`~anchor名$を与える
— これは、
`~tree視野な名前$になる。
◎
If the element generates a principal box, the element is an anchor element, with an anchor name equal to the &lt;dashed-ident&gt;. The anchor name is a tree-scoped name.
</dd>
	<dd>
他の場合、
この~propによる効果は無い。
◎
Otherwise, the property has no effect.
</dd>
</dl>

<p>
`~anchor名$は、
一意になる必要はない。
すべての要素が［
所与の有位置な要素~用の`~anchor要素$になる能力
］を有するとは限らないので、
各利用に対する視野が適切に絞られていれば，同じ名前を複数の箇所で再利用できる。
それでも，［
所与の`~anchor名$を伴う妥当な`~anchor要素$
］が複数個ある場合、
【`~tree順序$で】最後のものが選ばれる。
◎
Anchor names do not need to be unique. Not all elements are capable of being anchor elements for a given positioned element, so a name can be reused in multiple places if the usages are scoped appropriately. If there are still multiple valid anchor elements with the given anchor name, the last one is chosen.
</p>

			<section id="implicit">
<h4 title="Implicit Anchor Elements">2.1.1. 暗黙的な~anchor要素</h4>

<p>
一部の仕様は、
ある種の状況下で［
特定0の要素が，所与の有位置な要素~用の
`暗黙的な~anchor要素@
になる
］ものと定義し得る。
◎
Some specifications can define that, in certain circumstances, a particular element is an implicit anchor element for a given positioned element.
</p>

<p class="example">
例えば， `Popover API$cite は、
~popoverが［
どの要素に~anchorしているか宣言する
］ことを許容する。
これは、［
当の宣言された要素
］が［
当の~popover用の`暗黙的な~anchor要素$
］になるようにする。
◎
For example, the Popover API allows a popover to declare what element is anchoring it. This makes the declared element the implicit anchor element for the popover.
</p>

<p class="trans-note">【
~popover
— （作動化-時に） “他の上層に飛び出すもの” 。
】【
`Popover API@cite
が何を指すのか不明だが、
該当しそうな仕様は，［
~HTMLに定義される`~popover＠~HTMLpopover$か，
`その前身＠https://developer.chrome.com/docs/web-platform/popover-api/$
］の他に見当たらない。
しかしながら、
それらの仕様は，`暗黙的な~anchor要素$について何も述べていない。
】</p>

<p>
`暗黙的な~anchor要素$は、
何らかの `anchor-name$p 値ではなく，
`implicit$vA ~keywordで参照できる。
◎
Implicit anchor elements can be referenced with the implicit keyword, rather than referring to some anchor-name value.
</p>

			</section>
		</section>
		<section id="target">
<h3 title="Finding An Anchor">2.2. ~anchorの見出法</h3>

<p>
この仕様~内のいくつかのものは、
所与の`~anchor指定子$から`~target~anchor要素$を見出す。
`~anchor指定子@
は、
次に挙げるいずれかである
⇒＃
`dashed-ident$t ／
~keyword `implicit$vA ／
ε （指定子は欠落である）
◎終
`dashed-ident$t は、
~page上の他所における `anchor-name$p 値に合致するべき名前であり，
`~tree視野な参照$である。
◎
Several things in this specification find a target anchor element, given an anchor specifier, which is either a &lt;dashed-ident&gt; (and a tree-scoped reference) that should match an anchor-name value elsewhere on the page, or the keyword implicit, or nothing (a missing specifier).
</p>

<div class="algo">
<p>
`~target~anchor要素@
【略して、 “~anchor先（ `anchored^en ）” とも称される】
を決定するときは、
所与の
( ~queryしている要素 %~query要素, `~anchor指定子$ %指定子 （省略時は ε） )
に対し：
◎
To determine the target anchor element given a querying element query el and an optional anchor specifier anchor spec:
</p>
<ol>
	<li>
~IF［
%指定子 ~EQ ε
］
⇒
~RET `~target~anchor要素$( %~query要素, %~query要素 の`既定の~anchor指定子$ )
◎
If anchor spec was not passed, return the target anchor element for query el given the query el’s default anchor specifier.
</li>
	<li>
<p>
~IF［
%指定子 ~EQ `implicit$vA
］：
◎
If anchor spec is implicit,＼
</p>
		<ol>
			<li>
~IF［
`Popover API$cite は、
%~query要素 用に`暗黙的な~anchor要素$ %~anchor要素 を定義している
］~AND［
%~anchor要素 は %~query要素 用に`受容-可能な~anchor要素$である
］
⇒
~RET %~anchor要素
◎
and the Popover API defines an implicit anchor element for query el which is an acceptable anchor element for query el, return that element.
</li>
			<li>
~RET ε（該当する要素は無い）
◎
Otherwise, return nothing.
</li>
		</ol>

<p class="note">注記：
【上では `Popover API$cite に限って取扱っているが、】
将来の~APIは、暗黙的な~anchor要素を定義するかもしれない。
そうなったときは、
他との協調を確保するよう，
この~algo内で明示的に取扱われることになる。
◎
Note: Future APIs might also define implicit anchor elements. When they do, they’ll be explicitly handled in this algorithm, to ensure coordination.
</p>

	</li>
	<li>
~Assert：
%指定子 は `dashed-ident$t である。
◎
Otherwise, anchor spec is a &lt;dashed-ident&gt;.＼
</li>
	<li>
%~anchor要素~群 ~LET `~anchor名$に %指定子 を伴う`~anchor要素$たちが成す集合
◎
↓</li>
	<li>
<p>
%~anchor要素~群 を成す
~EACH( %要素 )
に対し，`~tree順序$の逆順で：
◎
Return the last element el in tree order that satisfies the following conditions:
• el is an anchor element with an anchor name of anchor spec.
</p>
		<ul>
			<li>
<p>
~IF［
%要素 の`~anchor名$に結付けられている`~tree$【！の`根$】
~NEQ
%指定子 に結付けられている`~tree$【！の`根$】
］
⇒
~CONTINUE
◎
el’s anchor name and anchor spec are both associated with the same tree root.
</p>

<p class="note">注記：
`~anchor名$は`~tree視野な名前$である一方、
%指定子 は`~tree視野な参照$である。
◎
Note: The anchor name is a tree-scoped name, while anchor spec is a tree-scoped reference.
</p>
			</li>
			<li>
~IF［
%要素 は %~query要素 用の`受容-可能な~anchor要素$である
］
⇒
~RET %要素
◎
el is an acceptable anchor element for query el.
</li>
		</ul>
	<li>
~RET ε
（該当する要素は無い）
◎
If no element satisfies these conditions, return nothing.
</li>
</ol>

<p class="note">注記：
これらの条件【どれ？】により捕捉される一般~規則は、［
【結果の？】
%要素 は %~query要素 が~lay-outされる前に全部的に~lay-outされなければならない
【~lay-outする必要が生じるようになる？】
］ことである。
~CSSにおける［
積層~文脈の~layout順序
］用の規則は、
このことについて確証を与える
— 上に挙げた条件たちは、［
~anchor位置決めにおいて，循環依存が生じ得ない
］ことを確保するよう，ちょうど［
積層~文脈~用の規則のうち，この目的に関連なもの
］だけを言い直したものである。
◎
Note: The general rule captured by these conditions is that el must be fully laid out before query el is laid out. CSS’s rules about the layout order of stacking contexts give us assurances about this, and the list of conditions above exactly rephrases the stacking context rules into just what’s relevant for this purpose, ensuring there is no possibly circularity in anchor positioning.
</p>
</div>

<p class="note">注記：
ある`~shadow~tree$内の~style内の `anchor-name$p により定義された`~anchor名$は、
異なる`~shadow~tree$内の~style内の`~anchor関数$からは見えない
（~encapsulationを保全するため）。
しかしながら，異なる`~shadow~tree$内にある`要素どうし^emであっても、［
`~anchor名$, `~anchor関数$
］どちらも
— ある~shadowの内側にある要素を `part()$pe を利用して~styleするなどにより —
同じ~tree内の~styleから来ているならば，互いに他を~anchorできる。
（`暗黙的な~anchor要素$は，内在的には単独の~treeに制限されないが、
その詳細は，それをアテガっている~APIに依存することになる。）
◎
Note: An anchor-name defined by styles in one shadow tree won’t be seen by anchor functions in styles in a different shadow tree, preserving encapsulation. However, elements in different shadow trees can still anchor to each other, so long as both the anchor-name and anchor function come from styles in the same tree, such as by using ::part() to style an element inside a shadow. (Implicit anchor elements also aren’t intrinsically limited to a single tree, but the details of that will depend on the API assigning them.)
</p>

<div class="algo">
<p>
所与の
( 要素 %要素, `絶対的に位置され$た要素 %~query要素 )
に対し，
%要素 は %~query要素 用の
`受容-可能な~anchor要素@
であるとは、
~AND↓ が満たされることをいう
— 以下における %包含塊 は、
%~query要素 の`包含塊$とする：
◎
An element el is a acceptable anchor element for an absolutely positioned element query el if all of the following are true:
</p>
<ul>
	<li>
［
%要素 【の`首要~box$】は %包含塊 【を確立した~box】の子孫である
］~OR［
%包含塊 は`初期~包含塊$である
］
◎
Either el is a descendant of query el’s containing block, or query el’s containing block is the initial containing block.
</li>
	<li>
［
%要素 の`包含塊$ ~EQ %包含塊
］~AND［
%要素 は ~OR↓ を満たす
］
⇒＃
`絶対的に位置され$ていない／
~tree順序において %~query要素 に先行する
◎
If el has the same containing block as query el, then either el is not absolutely positioned, or el precedes query el in the tree order.
</li>
	<li>
［
%要素 の`包含塊$ ~NEQ %包含塊
］~AND［
%要素 の`包含塊~連鎖$を成す`包含塊$のうち，
%包含塊 に達する前の最後のもの【を確立した~box】は ~OR↓ を満たす
］
⇒＃
`絶対的に位置され$ていない／
~tree順序において %~query要素 に先行する
◎
If el has a different containing block from query el, then the last containing block in el’s containing block chain before reaching query el’s containing block is either not absolutely positioned or precedes query el in the tree order.
</li>
</ul>
</div>

		</section>
		<section id="anchor-default">
<h3 title="Default Anchors: the anchor-default property">2.3. 既定の~anchor： `anchor-default^p ~prop</h3>

◎名 `anchor-default@p
◎値 `anchor-element$t
◎初 `implicit^v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`anchor-default$p ~propは、
当の要素~上のすべての`~anchor関数$用の
`既定の~anchor指定子@
を定義する
— それは、
次を許容する
⇒
複数の要素が，同じ［
`~anchor関数$たちが成す集合,
`位置~fallback~list$
］を利用しながら，
各自が参照rしている`~anchor要素$を変更する。
◎
The anchor-default property defines the default anchor specifier for all anchor functions on the element, allowing multiple elements to use the same set of anchor functions (and position fallback lists!) while changing which anchor element each is referring to.
</p>

<p>
とり得る値は、［
`anchor$f ／ `anchor-size$f
］における `anchor-element$t と一致する。
◎
Its values are identical to the &lt;anchor-element&gt; term in anchor() and anchor-size().
</p>

<div class="example">
<p>
例えば，次の~codeにおける［
`.foo^css, `.bar^css
］要素は、
各自が参照rしている~anchor要素だけを変更しながら，どちらも同じ［
位置決め~propたち, ~fallback
］を利用できる：
◎
For example, in the following code both .foo and .bar elements can use the same positioning properties and fallback, just changing the anchor element they’re referring to:
</p>

<pre class="lang-css">
.anchored {
  position: absolute;
  position-fallback: --under-then-over;
}

@position-fallback --under-then-over {
  @try {
    /* <span class="comment">
`anchor-element$t は指定されてないので、
`anchor-default$p からとる。
◎
No &lt;anchor-element&gt; specified, so it takes from 'anchor-default'.
</span> */
    top: calc(.5em + anchor(auto));
    bottom: auto;
  }
}

.foo.anchored {
  anchor-default: --foo;
}
.bar.anchored {
  anchor-default: --bar;
}
</pre>
</div>

		</section>
	</section>
	<section id="positioning">
<h2 title="Anchor-Based Positioning">3. ~anchorに基づく位置決め</h2>

<p>
`絶対的に位置され$る要素 %要素 は、
自身の`~inset~prop$に
`anchor@f
関数を利用することにより，［
1 個以上の`~anchor要素$
］の位置を参照rできる。
`anchor$f 関数は、
次を与える `length$t に解決される
⇒
所与の~inset辺を［
当の`~anchor要素$の指定された位置
］に位置するためにちょうど必要になる長さ
◎
An absolutely-positioned element can use the anchor() function in its inset properties to refer to the position of one or more anchor elements. The anchor() function resolves to a &lt;length&gt;, exactly what is needed to position the given inset edge to the specified position on the anchor element.
</p>

		<section id="anchor-pos">
<h3 title="The anchor() Function">3.1. `anchor^f 関数</h3>

<p>
`絶対的に位置され$る要素 %要素 は、
自身の`~inset~prop$内の値として
`anchor@f
関数を利用することにより，［
1 個以上の`~anchor要素$
］の位置を参照rできる。
`anchor$f 関数は、
`length$t に解決される。
◎
An absolutely-positioned element can use the anchor() function as a value in its inset properties to refer to the position of one or more anchor elements. The anchor() function resolves to a &lt;length&gt;.
</p>

<pre class="prod">
`anchor()^t
	= anchor( `anchor-element$t? `anchor-side$t, `length-percentage$t? )
`anchor-element@t
	= `dashed-ident$t
	| `implicit$vA
`anchor-side@t
	= `auto$vA
	| `auto-same$vA
	| `top$vA
	| `left$vA
	| `right$vA
	| `bottom$vA
	| `start$vA
	| `end$vA
	| `self-start$vA
	| `self-end$vA
	| `percentage$t
	| `center$vA
</pre>

<p>
`anchor$f 関数は、
3 個の引数をとる：
◎
The anchor() function has three arguments:
</p>
<ul>
	<li>
<p>
`anchor-element$t は、
`~anchor要素$を見出す方法を指定する
【すなわち、`~anchor指定子$を与える】。
%要素 の位置決め情報は、
それにより見出された`~anchor要素$
【すなわち，`~target~anchor要素$】
から引き出されることになる。
省略された場合、
【 ε と見なされ，】
%要素 の`既定の~anchor指定子$として挙動する。
◎
the &lt;anchor-element&gt; value specifies how to find the anchor element it will be drawing positioning information from. If omitted, it behaves as the element’s default anchor specifier.＼
</p>

<p>
アリな値は：
◎
Its possible values are:
</p>
		<dl>
			<dt id="valdef-anchor-dashed-ident">`dashed-ident$t</dt>
			<dd>
所与の識別子を`~anchor名$に伴う`~anchor要素$を探す。
この名前は、
`~tree視野な参照$になる。
◎
Specifies the anchor name it will look for. This name is a tree-scoped reference.
</dd>

			<dt>`implicit@vA</dt>
			<dd>
アリなら，
%要素 用に定義された`暗黙的な~anchor要素$を選定する。
◎
Selects the implicit anchor element defined for the element, if possible.
</dd>
		</dl>
<p>
詳細は、
`~target~anchor要素$を見よ。
◎
See target anchor element for details.
</p>
	</li>
	<li>
<p>
`anchor-side$t は、
`~target~anchor要素$の［
その値に対応している側
］を位置として参照rする。
以下における %~prop は、
この関数を利用している`~inset~prop$を指すとする。
アリな値は：
◎
the &lt;anchor-side&gt; value refers to the position of the corresponding side of the target anchor element. Its possible values are:
</p>
		<dl class="valdef">
			<dt>`auto@vA</dt>
			<dt>`auto-same@vA</dt>
			<dd>
`~anchor要素$の各~側のうち いずれかを参照rするが、
どれを参照rするよう解決されるかは， %~prop に依存する。
加えて、
自動的な~fallback用の挙動も誘発する。
◎
Resolves to one of the anchor element’s sides, depending on which inset property it’s used in. Also triggers automatic fallback behavior.
</dd>
			<dd>
詳細は、
`§ 自動的な~anchor位置決め＠#anchor-auto$を見よ。
◎
See § 3.1.1 Automatic Anchor Positioning for more details.
</dd>

			<dt>`top@vA</dt>
			<dt>`right@vA</dt>
			<dt>`bottom@vA</dt>
			<dt>`left@vA</dt>
			<dd>
`~anchor要素$の［
所与の~keywordにより指定された側
］を参照rする。
◎
Refers to the specified side of the anchor element.
</dd>
			<dd class="note">注記：
これらの~keywordが利用-可能になるのは、
~keywordが属する軸が %~prop が属する軸と合致している場合に限られる。
例えば， `left$vA を利用-可能な~propは、
横~軸に属する`~inset~prop$
— `left$p, `right$p, これらと同じ側に対応する~flow相対な~prop —
に限られる。
◎
Note: These are only usable in the inset properties in the matching axis. For example, left is usable in left, right, or the logical inset properties that refer to the horizontal axis.
</dd>
			<dd class="trans-note">【
これらは、
“物理-~keyword” とも総称される。
】</dd>

			<dt>`start@vA</dt>
			<dt>`end@vA</dt>
			<dt>`self-start@vA</dt>
			<dt>`self-end@vA</dt>
			<dd>
`~anchor要素$の各~側のうち，
%~prop と同じ軸に属するいずれかを参照rする
【例： %~prop が `top$p ならば上端か下端】
— 所与の~keywordに応じて，
⇒＃
［ `self-start$vA ／ `self-end$vA ］ならば，当の有位置な要素／
［ `start$vA ／ `end$vA ］ならば，当の有位置な要素の包含塊
◎終
の`書字~mode$を基準に解決することにより。
◎
Refers to one of the sides of the anchor element in the same axis as the inset property it’s used in, by resolving the keyword against the writing mode of either the positioned element (for self-start and self-end) or the positioned element’s containing block (for start and end).
</dd>
			<dd class="trans-note">【
これらは、
“論理-~keyword” とも総称される。
】</dd>

			<dt id="valdef-anchor-percentage">`percentage$t</dt>
			<dt>`center@vA</dt>
			<dd>
［
`start$vA 側, `end$vA 側
］の合間における所与の百分率に対応する位置を参照rする
— ［
`0%^v ／ `100%^v
］は［
`start^v ／ `end^v
］と等価になる。
◎
Refers to a position a corresponding percentage between the start and end sides, with 0% being equivalent to start and 100% being equivalent to end.
</dd>
			<dd>
`center$vA は、
`50%^v と等価になる。
◎
center is equivalent to 50%.
</dd>
		</dl>
	</li>
	<li>
省略可能な 3 個目の引数 `length-percentage$t は、
~fallback値を与える。
これは、
当の `anchor$f が`妥当な~anchor関数$でない場合に，何に解決するべきかを指定する。
◎
the optional &lt;length-percentage&gt; final argument is a fallback value, specifying what the function should resolve to if it’s an invalid anchor function.
</li>
</ul>

<p class="issue">
`anchor$f 関数の算出d値は、
おそらく，［
その`~target~anchor要素$を解決した結果の `anchor$f
］になる必要がある。
これは、
遷移が［
`~tree視野な名前$と伴に／~anchor要素が変化するときに
］適正に働くことを許容する。
`8180$issue を見よ。
◎
Computed value for anchor() probably needs to be the anchor() function, but with the target anchor element resolved. This allows for transitions to work properly with tree-scoped names, and with changing anchor elements. See Issue 8180.
</p>

<p>
`anchor$f 関数は、
`妥当な~anchor関数$を表現しているならば，
`使用~値$の時点で， `length$t に解決される
— ［
当の有位置な要素の`~insetで改変された包含塊$
］の［
当の関数が現れる~propに対応している辺
］を［
`~target~anchor要素$の指定された~border辺
］に整列するような。
そのときには、［
`~target~anchor要素$と当の有位置な要素の`包含塊$の合間にある`~scroll容器$
］は，どれも［
各自の初期~scroll位置に~scrollされている
］と見做される
（が、 `anchor-scroll$p を見よ）。
◎
An anchor() function representing a valid anchor function resolves at used value time to the &lt;length&gt; that would align the edge of the positioned elements' inset-modified containing block corresponding to the property the function appears in with the specified border edge of the target anchor element, assuming that all scroll containers between the target anchor element and the positioned element’s containing block are scrolled to their initial scroll position (but see anchor-scroll).
</p>

<p>
`~target~anchor要素$が`断片$化されている場合、［
各~断片の~border~box
］たちが成す限界~矩形
— それらの~boxと軸が揃えられた矩形 —
が代わりに利用される。
◎
If the target anchor element is fragmented, the axis-aligned bounding rectangle of the fragments' border boxes is used instead.
</p>

<p class="issue">
［
~padding辺／内容~辺
］にも整列できるよう，［
どの~boxを参照rするか
］も制御する必要はあるか？
◎
Do we need to control which box we’re referring to, so you can align to padding or content edge?
</p>

<p>
加えて，有位置な要素が`~snapshot済み~scroll~offset$を有する場合、
その~offsetにより視覚的にズラされる
— 追加的な `translate$f 変形によりズラされたかのように。
◎
If the positioned element has a snapshotted scroll offset, then it is additionally visually shifted by those offsets, as if by an additional translate() transform.
</p>

<div class="example">
<p>
例えば，
`.bar { top: anchor(--foo top); }^css
においては、
`anchor$f は，［
`.bar^css 要素の上端~辺と`~anchor要素$ `--foo^v の上端~辺が揃うような長さ
］に解決されることになる。
◎
For example, in .bar { top: anchor(--foo top); }, the anchor() will resolve to the length that’ll line up the .bar element’s top edge with the --foo anchor’s top edge.
</p>

<p>
他方，
`.bar { bottom: anchor(--foo top); }^css
においては、［
`.bar^css 要素 の`下端^em辺と`~anchor要素$ `--foo^v の上端~辺が揃うような長さ
］に解決されることになる。
◎
On the other hand, in .bar { bottom: anchor(--foo top); }, it will instead resolve to the length that’ll line up the .bar element’s bottom edge with the --foo anchor’s top edge.
</p>

<p>
［
`top$p の値, `bottom$p の値
］は，異なる辺
（要素の`包含塊$の［
上端／下端
］辺）
からの~insetを指定するので、
双方の `anchor$f は同じでも，それらを解決した結果の長さは異なることになる。
◎
Since top and bottom values specify insets from different edges (the top and bottom of the element’s containing block, respectively), the same anchor() will usually resolve to different lengths in each.
</p>
</div>

<div class="example">
<p>
`anchor$f 関数は、
`length$t に解決されるので，他の長さと同様に`~math関数$内でも利用できる。
◎
Because the anchor() function resolves to a &lt;length&gt;, it can be used in math functions like any other length.
</p>

<p>
例えば，次は、［
要素の`~insetで改変された包含塊$
］が［
`~anchor要素$上で中央に寄せられ，
要素の`包含塊$を~overflowしない~~範囲でアリな限り幅広になる
］よう，要素を設定しておくことになる：
◎
For example, the following will set up the element so that its inset-modified containing block is centered on the anchor element and as wide as possible without overflowing the containing block:
</p>

<pre class="lang-css">
.centered-message {
  position: fixed;
  max-width: max-content;
  justify-self: center;

  --center: anchor(--x 50%);
  --half-distance: min(
    abs(0% - var(--center)),
    abs(100% - var(--center))
  );
  left: calc(var(--center) - var(--half-distance));
  right: calc(var(--center) - var(--half-distance));
  bottom: anchor(--x top);
}
</pre>

<p>
これは例えば、
`input$e 要素に対する~error~message用に適切になることもあろう
— 中央に寄せたことにより，当の~messageが どの入力を参照rしているか発見し易くなるので。
◎
This might be appropriate for an error message on an input element, for example, as the centering will make it easier to discover which input is being referred to.
</p>
</div>


			<section id="anchor-auto">
<h4 title="Automatic Anchor Positioning">3.1.1. 自動的な~anchor位置決め</h4>

<p>
`anchor-side$t を成す~keyword［
`auto$vA ／ `auto-same$vA
］は、
次が求まれることを指示する
⇒
当の要素は、
当の関数を利用した`~inset~prop$が属する軸において，
`自動的な~anchor位置決め$を利用する。
◎
The auto and auto-same &lt;anchor-side&gt; keywords indicate the element wants to use automatic anchor positioning in that property’s axis.＼
</p>

<p>
`自動的な~anchor位置決め@
には、
次に挙げる効果がある：
◎
This has two effects:
</p>
<ul>
	<li>
<p>
`anchor$f 関数は、
`~anchor要素$の期待された側
— `auto-same$vA 用には，当の関数を利用した`~inset~prop$と同じ側／
`auto$vA 用には反対-側 —
を自動的に参照rすることになる。
◎
The anchor() function will automatically refer to the expected side of the anchor element (the same side as the inset property it’s used in, for auto-same, or the opposite side, for auto).
</p>

<p>
すなわち、
`top:anchor(auto)$p は `top:anchor(bottom)$p と等価になり，
`left: anchor(auto-same)$p は `left: anchor(left)$p と等価になる，等々。
◎
That is, top: anchor(auto); is equivalent to top: anchor(bottom);, while left: anchor(auto-same); is equivalent to left: anchor(left);, etc.
</p>
	</li>
	<li>
当の要素が［
`position-fallback$p は `~noneF$v,
反対-側の`~inset~prop$は `auto$v
］をとる場合、
要素は［
必要とされるなら，当の`~anchor要素$の反対-側へ移転する
］ような`位置~fallback~list$を自動的に~~生成することになる。
詳細は、
`§ ~fallbackと自動的な位置決め＠#fallback-automatic$
を見よ。
◎
If the element has position-fallback: none, and the opposite inset property is auto, it automatically gains a position fallback list that will flip it to the opposite side of the anchor element if necessary. See § 5.5 Fallback and Automatic Positioning for details.
</li>
</ul>

<div class="example">
<p>
ある要素を~target要素をちょうど覆うように［
位置する, ~sizeする
］ようにする例：
◎
For example, to position and size an element to exactly cover the target element:
</p>

<pre class="lang-css">
.cover {
  inset: anchor(auto-same);
}
</pre>

<p>
これは、
次と等価になる：
◎
is equivalent to
</p>

<pre class="lang-css">
.cover {
  top: anchor(top);
  right: anchor(right);
  bottom: anchor(bottom);
  left: anchor(left);
}
</pre>
</div>

<div class="example">
<p>
反対-側【！軸】は `auto$v のときは、
当の要素は，~fallback用の挙動を自動的に~~生成する。
例えば：
◎
When the opposite axis is auto, the element automatically gains fallback behavior. For example:
</p>

<pre class="lang-css">
.tooltip {
  position: fixed;
  anchor-default: --target;
  top: auto; /* <span class="comment">
初期~値
◎
initial value
</span> */
  bottom: calc(anchor(auto) + .3em);
}
</pre>

<p>
上の~codeでは、
既定では，
`.tooltip^css の下端~辺を`~anchor要素$の上端~辺から少し上へ離して位置することになるが、
そうすると~screenの上端~辺
（`~insetで改変された包含塊$の上端
— この事例では表示域）
を~overflowする場合には，自動的に反対-側へ移転することになる
— 代わりに，次が指定されていたかのように：
◎
With the above code, the tooltip will default to positioning its bottom edge slightly away from the top edge of its anchor element, hovering just above it; but if that would make it overflow the top edge of the screen (aka the top of its inset-modified containing block, which is the viewport in this case), it will automatically flip to the opposite side, as if you’d instead specified:
</p>

<pre class="lang-css">
.tooltip {
  position: fixed;
  position-fallback: --top-then-bottom;
  anchor-default: --target;
}
@position-fallback --top-then-bottom {
  @try {
    top: auto;
    bottom: calc(anchor(top) + .3em);
  }
  @try {
    top: calc(anchor(bottom) + .3em);
    bottom: auto;
  }
}
</pre>

<p>
両~軸ともこの挙動を誘発する場合、
実質的に 4 個の~fallbackを~~生成する
— ~anchorの［
指定された側, 反対-側
］に対する各~組合nを試行して，
~overflowを誘発しないものを見出すよう。
◎
If both axises trigger this behavior, it effectively gains four fallbacks, trying each combination of specified and opposing anchors to find one that won’t trigger overflow.
</p>
</div>

			</section>
		</section>
		<section id="scroll">
<h3 title="Taking Scroll Into Account: the anchor-scroll property">3.2. ~scrollの織り込み法： `anchor-scroll^p ~prop</h3>

◎名 `anchor-scroll@p
◎値 `~noneS$v | `default$v | `anchor-element$t
◎初 `default$v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~scrollingは，処理能の理由から［
実装においては、
~layoutとは別々な~threadで行われる
］ことが多いが、
`anchor$f は，［
位置決め変化, ~layout変化
］両者の結果に基づき得る
（前者は~scrolling~thread内で取扱われ得るが，後者はそうでない）。
このことから、
`anchor$f は，［
当の~anchor要素から当の有位置な要素の`包含塊$までの合間にある，`~scroll容器$
］は［
どれも，各自の初期~scroll位置にある
］ものと見做すよう定義される。
このことは、
有位置な要素は，［
いずれかの`~scroll容器$が，その初期~位置`でない場合^em
］には［
その`~anchor先$【！~its ~anchor】と`整列されなくなる^em
］ことを意味する。
◎
Because scrolling is often done in a separate thread from layout in implementations for performance reasons, but anchor() can result in both positioning changes (which can be handled in the scrolling thread) and layout changes (which cannot), anchor() is defined to assume all the scroll containers between the anchor element and the positioned element’s containing block are at their initial scroll position. This means a positioned element will not be aligned with its anchor if any of the scrollers are not at their initial positions.
</p>

<p>
`anchor-scroll$p ~propは、
当の有位置な要素が単独の`~anchor要素$に~anchorしているときに限り
【実際には、`~snapshot済み~scroll~offset$を有するときに限り】，
これを
— ~scrollingを別々な~threadで行うことによる処理能の便益を失うことなく —
補償することを作者に許容する。
とり得る値は：
◎
The anchor-scroll property allows an author to compensate for this, without losing the performance benefits of the separate scrolling thread, so long as the positioned element is only anchoring to a single anchor element. Its values are:
</p>

<dl>
	<dt>`~noneS@v</dt>
	<dd>
効果なし。
◎
No effect.
</dd>

	<dt>`default@v</dt>
	<dd>
`anchor-element$t と同じに挙動するが、
その値を当の要素の `anchor-default$p の値から引き出す。
◎
Behaves identically to &lt;anchor-element&gt;, but draws its value from anchor-default on the element.
</dd>

	<dt id="valdef-anchor-scroll-anchor-element">`anchor-element$t</dt>
	<dd>
`anchor$f と同じように`~target~anchor要素$を選定する
— それが［
位置決め, ~fallback
］において補償されることになる。
◎
Selects a target anchor element the same as anchor(), which will be compensated for in positioning and fallback.
</dd>
</dl>

<p class="note">注記：
当の要素が［
`anchor-default$p を利用する／
`暗黙的な~anchor要素$を伴う
］ときは、
作者は， `anchor-scroll$p に明示的に値を設定することを避けれることが多い
— その初期~値は `default$v なので。
◎
Note: When the element uses anchor-default or has an implicit anchor element, authors can often avoid explicitly setting an anchor-scroll value because the initial value is default.
</p>

<div class="algo">
<div class="p">
<p>
`絶対的に位置され$た要素 %~query要素 は、
~AND↓ を満たすならば，
`~snapshot済み~scroll~offset@
を有する：
</p>
<ul>
	<li>
%値 ~EQ %~query要素 の `anchor-scroll$p ~propの値 ~NEQ `~noneS$v
</li>
	<li>
%~anchor要素 ~EQ `~target~anchor要素$( %~query要素, %値 ) ~NEQ ε
</li>
	<li>
%~query要素 の ある`~inset~prop$は、
`anchor$f 関数を利用していて，それは %~anchor要素 を参照rしている
</li>
</ul>
◎
If anchor-scroll is not none on an absolutely-positioned element query el,＼
and there is a target anchor element for query el given the anchor-scroll value,＼
and at least one anchor() function on query el refers to the same target anchor element,＼
then query el has a snapshotted scroll offset,＼
</div>

<p>
`~snapshot済み~scroll~offset$は、［
縦方向~offset, 横方向~offset
］を表現している 2 個の長さが成す~pairである
— これらの各~offsetは：
◎
which is a pair of lengths representing a vertical and horizontal offset.
◎
The snapshotted scroll offset is＼
</p>
<ul>
	<li>
<p>
［
次を満たす各`~scroll容器$
］の`初期~scroll位置$からの~offsetの総和になる
⇒
［
%~anchor要素 の先祖である
］~AND［
%~query要素 の`包含塊$の子孫である
］
【この先祖, 子孫は、`~box~tree$に基づくであろう。】
◎
the sum of the offsets from the initial scroll position of all scroll container ancestors of the target anchor element, up to but not including query el’s containing block.
</p>

<p class="issue">
~snapshotを得る精確な時機を定義する必要がある
— それは、
各【描画】~frameごとに，~styleを計算し直す前に更新される。
◎
Define the precise timing of the snapshot: updated each frame, before style recalc.
</p>
	</li>
	<li>
%~query要素 は`追加的な~fallback限界域~矩形$ %矩形 を有する場合、
上の結果から，さらに［
%矩形 （すなわち， %~anchor要素 の`~padding~box$）の位置
］を減算した結果になる。
【！the element generating the additional fallback-bounds rect = %~anchor要素 】
◎
If query el has an additional fallback-bounds rect, similarly calculate the sum of the offsets from the initial scroll position of all scroll container ancestors of the element generating the additional fallback-bounds rect, and subtract that summed offset from the additional fallback-bounds rect’s position.
</li>
</ul>
</div>

		</section>
		<section id="anchor-valid">
<h3 title="Validity">3.3. 妥当性</h3>

<p>
`anchor$f 関数 %関数 は、
~AND↓ を満たす場合に限り，
`妥当な~anchor関数@
になる：
◎
An anchor() function is a valid anchor function only if all the following conditions are true:
</p>
<ul>
	<li>
%関数 は、
`絶対的に位置され$た要素 %要素 の ある`~inset~prop$ %~prop にて利用されている。
◎
It’s being used in an inset property on an absolutely-positioned element.
</li>
	<li>
%関数 の `anchor-side$t が物理-~keywordを指定している場合、
それは， %~prop が属する軸に属する。
（例えば， `left$vA を利用し得る~propは、
横~軸に属する`~inset~prop$
— `left$p, `right$p, これらと同じ側に対応する~flow相対な~prop —
に限られる。）
◎
If its &lt;anchor-side&gt; specifies a physical keyword, it’s being used in an inset property in that axis. (For example, left can only be used in left, right, or a logical inset property in the horizontal axis.)
</li>
	<li>
`~target~anchor要素$( %要素, %関数 内に指定された `anchor-element$t ) ~NEQ ε
◎
There is a target anchor element for the element it’s used on, and the &lt;anchor-element&gt; value specified in the function.
</li>
</ul>

<p>
これらいずれかの条件が満たされない場合、
%関数 は次に解決される
⇒＃
~fallback値（ 3 個目の引数）が指定されていた場合は，それ／
~ELSE_ `0px^v
◎
If any of these conditions are false, the anchor() function resolves to its specified fallback value. If no fallback value is specified, it resolves to 0px.
</p>

		</section>
	</section>
	<section id="sizing">
<h2 title="Anchor-based Sizing">4. ~anchorに基づく~sizing</h2>

<p>
`絶対的に位置され$る要素は、
自身の`~sizing~prop$において
`anchor-size@f
関数を利用することにより，［
1 個以上の`~anchor要素$の~size
］を参照rできる。
`anchor-size$f 関数は、
`length$t に解決される。
◎
An absolutely-positioned element can use the anchor-size() function in its sizing properties to refer to the size of one or more anchor elements. The anchor-size() function resolves to a &lt;length&gt;.
</p>

		<section id="anchor-size-fn">
<h3 title="The anchor-size() function">4.1. `anchor-size^f 関数</h3>

<pre class="prod">
anchor-size()
	= anchor( `anchor-element$t? `anchor-size$t, `length-percentage$t? )
`anchor-size@t
	= `width$v
	| `height$v
	| `block$v
	| `inline$v
	| `self-block$v
	| `self-inline$v
</pre>

<p>
`anchor-size$f 関数は、
`anchor$f と類似する
— それは、［
`anchor-side$t が `anchor-size$t に置換される
］ことを除いて，同じ引数をとる。
◎
The anchor-size() function is similar to anchor(), and takes the same arguments, save that the &lt;anchor-side&gt; keywords are replaced with &lt;anchor-size&gt;,＼
</p>

<p>
`anchor-size$t は、
反対-側にある 2 辺の距離を参照rする：
◎
referring to the distance between two opposing sides.
</p>
<dl>
	<dt>`width@v</dt>
	<dt>`height@v</dt>
	<dd>
これらの物理-~keywordは、
順に，`~target~anchor要素$の［
横幅, 縦幅
］を参照rする。
`anchor$f と違って、
軸が合致しなければならない制約は無い
— 例えば、
`width: anchor-size(--foo height)$p は妥当になる。
◎
The physical &lt;anchor-size&gt; keywords (width and height) refer to the width and height, respectively, of the target anchor element. Unlike anchor(), there is no restriction on having to match axises; for example, width: anchor-size(--foo height); is valid.
</dd>

	<dt>`block@v</dt>
	<dt>`inline@v</dt>
	<dt>`self-block@v</dt>
	<dt>`self-inline@v</dt>
	<dd>
<p>
これらの論理-~keywordは、
次に依存して，いずれかの物理-~keywordに対応付けられる：
</p>
		<ul>
			<li>
［
`self-block$v ／ `self-inline$v
］用には，当の要素の`書字~mode$
</li>
			<li>
［
`block$v ／ `inline$v
］用には，当の要素の`包含塊$の`書字~mode$
</li>
		</ul>
◎
The logical &lt;anchor-size&gt; keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).
</dd>
</dl>

<p>
`anchor-size$f 関数は、
`妥当な~anchor~size関数$を表現しているならば，
`~target~anchor要素$の関連な 2 つの~border辺
— 横幅を参照するならば左端と右端／
縦幅を参照するならば上端と下端 —
の距離を成す `length$t に解決される。
◎
An anchor-size() function representing a valid anchor-size function resolves to the &lt;length&gt; separating the relevant border edges (either left and right, or top and bottom, whichever is in the specified axis) of the target anchor element.
</p>

		</section>
		<section id="anchor-size-valid">
<h3 title="Validity">4.2. 妥当性</h3>

<p>
`anchor-size$f 関数 %関数 は、
~AND↓ を満たす場合に限り，
`妥当な~anchor~size関数@
になる：
◎
An anchor-size() function is a valid anchor-size function only if all the following conditions are true:
</p>
<ul>
	<li>
%関数 は、
`絶対的に位置され$た要素 %要素 の ある`~sizing~prop$にて利用されている。
◎
It’s being used in a sizing property on an absolutely-positioned element.
</li>
	<li>
`~target~anchor要素$( %要素, %関数 内に指定された `anchor-element$t ) ~NEQ ε
◎
There is a target anchor element for the element it’s used on, and the &lt;anchor-element&gt; value specified in the function.
</li>
</ul>

<p>
これらいずれかの条件が満たされない場合、
%関数 は次に解決される
⇒＃
~fallback値（ 3 個目の引数）が指定されていた場合は，それ／
~ELSE_ `0px^v
◎
If any of these conditions are false, the anchor-size() function resolves to its specified fallback value. If no fallback value is specified, it resolves to 0px.
</p>

		</section>
	</section>
	<section id="fallback">
<h2 title="Fallback Sizing/Positioning">5. ~fallback［~sizing／位置決め］</h2>

<p>
~anchor位置決めは、
強力ではあるが，予測-不能にもなり得る。
`~anchor要素$は，~page上のどこにでも~~現れ得るので、
ある有位置な要素を特定0の流儀（当の~anchorの上や右端など）で位置した結果、
当の要素は，［
自身の`包含塊$を~overflowする／
部分的に~screen外に位置される
］かもしれない。
◎
Anchor positioning, while powerful, can also be unpredictable. The anchor element might be anywhere on the page, so positioning an element in any particular fashion (such as above the anchor, or the right of the anchor) might result in the positioned element overflowing its containing block or being positioned partially off screen.
</p>

<p>
これを~~改善するため、
`絶対的に位置され$る要素は，
`position-fallback$p ~propを利用して ある `position-fallback$at 規則を参照rできる。
この規則を成す~blockは、［
試行される~style規則~群としてアリなもの
］たちが成す~listを与える。
この~listを成す各~規則~群は、
順に 1 つずつ当の要素に適用され，［
その結果，要素が自身の`包含塊$を~overflowしない最初のもの
］が~~採用されることになる。
◎
To ameliorate this, an absolutely positioned element can use the position-fallback property to refer to a @position-fallback block, giving a list of possible style rules to try out. Each is applied to the element, one by one, and the first that doesn’t cause the element to overflow its containing block is taken as the winner.
</p>

		<section id="fallback-property">
<h3 title="The position-fallback Property">5.1. `position-fallback^p ~prop</h3>

◎名 `position-fallback@p
◎値 `~noneF$v | `dashed-ident$t
◎初 `~noneF$v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<p>
各種 値の意味は：
◎
Values have the following meanings:
</p>

<dl class="valdef">
	<dt>`~noneF@v</dt>
	<dd>
この~propによる効果は無い
— 当の要素は、
`位置~fallback~list$を利用しない。
【`自動的な~anchor~fallback$により生成されるものを除けば。】
◎
The property has no effect; the element does not use a position fallback list.
</dd>

	<dt id="valdef-position-fallback-dashed-ident">`dashed-ident$t</dt>
	<dd>
［
指定された識別子に合致している名前
］を伴う `position-fallback$at 規則が在る場合、
当の要素は，それが定義する`位置~fallback~list$を利用する。
◎
If there is a @position-fallback rule with a name matching the specified ident, then the element uses that position fallback list.
</dd>
	<dd>
他の場合，この値の効果は無い。
◎
Otherwise, this value has no effect.
</dd>
</dl>

		</section>
		<section id="fallback-rule">
<h3 title="The @position-fallback Rule">5.2. `position-fallback^at 規則</h3>

<p>
`position-fallback@at
規則は、
所与の名前を伴う`位置~fallback~list$を定義する
— それは、
1 個以上の
`try@at
~blockからなる。
各 `try$at ~blockの内側には、
要素に適用され得る一群の位置決め~propを指定する。
各 `try$at ~blockは、
直前の `try$at ~blockの~fallbackとして~serveする
— すなわち、［
ある~blockを適用した結果、
当の要素が自身の`包含塊$を一部でも~overflowする
］場合には，直後の~blockを適用しようと試行する。
◎
The @position-fallback rule defines a position fallback list with a given name, specifying one or more sets of positioning properties inside of @try blocks that will be applied to an element, with each successive one serving as fallback if the previous would cause the element to partially or fully overflow its containing block.
</p>

<p>
`position-fallback$at 規則の文法は：
◎
The grammar of the @position-fallback rule is:
</p>

<pre class="prod">
@position-fallback `dashed-ident$t {
	`rule-list$t
}

@try { `declaration-list$t }
</pre>

<p>
`position-fallback$at 規則 %規則 が `rule-list$t にて受容する規則は、
`try$at に限られる。
%規則 の導入部にて指定される `dashed-ident$t が， %規則 の名前になる。
同じ名前を伴う複数個の `position-fallback^at 規則が宣言された場合、
文書~順序で最後のものが優先される。
◎
The @position-fallback rule only accepts @try rules. The &lt;dashed-ident&gt; specified in the prelude is the rule’s name. If multiple @position-fallback rules are declared with the same name, the last one in document order "wins".
</p>

<p>
`try$at 規則が受容する`~prop$は、
次に挙げるものに限られる：
◎
The @try rule only accepts the following properties:
</p>
<ul>
	<li>
`~inset~prop$
◎
inset properties
</li>
	<li>
`~sizing~prop$
◎
sizing properties
</li>
	<li>
`~box整列~prop$
◎
box alignment properties
</li>
</ul>

<p class="issue">
ここに何が許容されるかを決定する拘束は、
正確には何か？
現在の~listは、
Chrome の試験的な実装からの適度なものに基づく。
少なくとも［
子孫~用に，より一般的な~style法を許容する
］ために，
どの~fallbackが利用されたかに基づいて `make a CQ^en 【？】できよう。
◎
What exactly are the constraints that determine what’s allowed here? Current list is based off of what’s reasonable from Chrome’s experimental impl. We can make a CQ that keys off of which fallback was used to allow more general styling, at least for descendants.
</p>

<p>
`position-fallback$at 規則は、
`位置~fallback~list@
を指定する
— この~listを成す各~entryは、
順に，規則の内側にある各 `try$at 規則に指定された一群の~propからなる。
◎
The @try rules inside a @position-fallback specify a position fallback list, where each entry consists of the properties specified by each @try, in order.
</p>

<p class="issue">
ある有位置な要素の~anchor（たち）が，
~scrollされて全部的に~screen外にあるとき、
そのことが検出-可能になり，当の要素の表示をまるごと抑止できれば有用になろう。
例えば、
要素が~anchor用の~tooltipを成す~textを保持していて，当の`~scroll容器$の外側に住まう場合。
【！don’t want to just hover...】
◎
Would be useful to be able to detect when your anchor(s) are fully off-screen and suppress your display entirely. For example, tooltips living outside the scroller holding the text they’re anchored to don’t want to just hover over arbitrary parts of the page because their anchor happens to have that position relative to the scrollport.
</p>

<p class="note">注記：
異なる~anchorを利用している複数の要素が，同じ［
各自の~anchor要素に相対的な~fallback位置決め
］を利用したいと求めるなら、
`anchor$f 内の `anchor-element$t を省略して，
代わりに `anchor-default$p 内に各~要素の~anchorを指定する。
◎
Note: If multiple elements using different anchors want to use the same fallback positioning, just relative to their own anchor elements, omit the &lt;anchor-element&gt; in anchor() and specify each element’s anchor in anchor-default instead.
</p>

<p class="note">注記：
最も共通的な~fallback位置決め
（有位置な要素を通常は~anchorの一方の側に置くが，必要なら反対-側に移転するよう）
は、
`anchor$f 関数~内に［
`auto$vA ／ `auto-same$vA【！auto-side】
］値を利用することにより，自動的に行える
— `position-fallback$at をまったく利用することなく。
◎
Note: The most common types of fallback positioning (putting the positioned element on one side of the anchor normally, but flipping to the opposite side if needed) can be done automatically, without using @position-fallback at all, by using auto or auto-side side values in the anchor() function.
</p>

		</section>
		<section id="fallback-bounds">
<h3 title="Applying Stronger Fallback Bounds: the position-fallback-bounds property">5.3. より強い~fallback限界域の適用-法： `position-fallback-bounds$p ~prop</h3>

<p>
有位置な要素 %要素 が［
`~anchor位置決め$に加えて，
`position: absolute$p を利用している
］ときには、［
%要素 が~overflowしているか否か
］は，［
%要素 の（~scroll調整-済みな）`~insetで改変された包含塊$を調べる
］ことにより決定される
（~overflowしている場合、
異なる~fallback位置を試行するべきである）。
［
%要素 が~DOM内のどこに住まうか
］および［
どの要素が %要素 の包含塊を確立するか
］を注意深く選定することにより、
%要素 の~overflow限界域~用に利用するために有用になる要素を選べる。
◎
When an element using anchor positioning is using position: absolute, it determines whether or not it’s overflowing (and thus should try a different fallback position) by looking at its (scroll-adjusted) inset-modified containing block. By carefully selecting where in the DOM the positioned element lives, and what element establishes its containing block, you can choose a useful element to use for its overflow bounds.
</p>

<p>
この能は、
%要素 が［
`position: fixed$p を利用している／
`Popover API$cite の様に`上端~層$を利用している
］ときには，失われる
— その場合、
%要素 の包含塊は，常に［
表示域, 根~要素の包含塊
］どちらかになるので。
`position-fallback-bounds$p ~propは、
この能を復旧する
— それは、
%要素 が［
どの要素に対し，~overflowを検査するよう求めるか
］を明示的に選定することを許容する。
◎
When using position: fixed, or things like the Popover API that use the top layer, you lose this ability; their containing block is always the viewport or the root element’s containing block. The position-fallback-bounds property restores this ability, allowing an element to explicitly select what element it wants to use for checking overflow against.
</p>

◎名 `position-fallback-bounds@p
◎値 `normal^v | `dashed-ident$t
◎初 `normal^v
◎適 `絶対的に位置され$た要素
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア 離散的
◎表終

<dl>
	<dt>`normal@v</dt>
	<dd>
当の要素は、［
`位置~fallback~list$から~entryを選定する
【`位置~fallback~style群を決定する$】
目的
］において，
通常の包含塊
— （~scroll調整-済みな）`~insetで改変された包含塊$ —
を利用して［
自身が~overflowしているか否か
］を決定する。
◎
The element uses its normal (scroll-adjusted, inset-modified) containing block to determine if it’s overflowing for the purpose of selecting a position fallback list entry.
</dd>

	<dt>`dashed-ident$t</dt>
	<dd>
当の要素は、
その包含塊に対し
— `normal$v のときと同じく —
自身が~overflowしているか否かを検査することに加えて、
`追加的な~fallback限界域~矩形$が有るならば，
それに対し自身が~overflowしているか否かを検査する。
◎
In addition to checking overflow against its containing block, as per normal, the element checks against its additional fallback-bounds rect.
</dd>
	<dd>
<p>
`追加的な~fallback限界域~矩形@
は、
次の結果 ~NEQ ε ならば結果の`~padding~box$になり，
他の場合は無い
⇒
`~target~anchor要素$( 当の要素, 所与の `dashed-ident$t )
◎
The additional fallback-bounds rect is the padding box of the target anchor element given this element and the specified &lt;dashed-ident&gt;. If there is no such target anchor element, there is no additional fallback-bounds rect.
</p>

<p class="issue">
~padding~box, 内容~boxどちらにするか？
どちらになるかを制御-可能にするべきか？
◎
padding-box? Or content-box? Should it be controllable?
</p>
	</dd>
</dl>

		</section>
		<section id="fallback-apply">
<h3 title="Applying Position Fallback">5.4. 位置~fallbackの適用-法</h3>

<p>
`位置~fallback~list$を利用する要素は、［
以下に定義されるとおり，この~listから一つに選定された~entry
］を成す各~propを，`使用~値$として自身に適用する。
◎
When an element uses a position fallback list, it selects one entry from the list as defined below, and applies those properties to itself as used values.
</p>

<p class="note">注記：
これらを使用~値として適用する必要があるのは、
~layoutの最中に適用されるからである
— それらが どう相互作用するかを~cascadeで定義することは、
どう転んでも極めて紛らわしくなり，たぶん実際に循環依存になる。
そうすることは、
どの事例でも［
仕様~化／実装
］の~costに見合わない。
◎
Note: These have to be applied as used values because we’re in the middle of layout right now; defining how they’d interact with the cascade would be extremely confusing *at a minimum*, and perhaps actually circular. In any case, not worth the cost in spec or impl.
</p>

<p class="issue">
このことは、
当の値たちは，通例的な流儀では遷移し得ないことを含意する
— 遷移は算出d値に基づくが、
その時点は過ぎ去ったので。
しかしながら、
~popoverを他の位置へ滑らすことは，
~UI~libraryにおいて共通的な効果である。
おそらく、
`position-fallback$p には，［
~fallbackされた~propの “自動的な~animation” を誘発する
］ための `smooth^v ~keywordを導入するべきである。
◎
This implies that the values can’t be transitioned in the usual fashion, since transitions key off of computed values and we’re past that point. However, popovers sliding between positions is a common effect in UI libs. Probably should introduce a smooth keyword to position-fallback to trigger automatic "animation" of the fallback’d properties.
</p>

<div class="algo">
<p>
要素 %要素 の
`位置~fallback~style群を決定する@
ときは：
◎
To determine the position fallback styles of an element el:
</p>
<ol>
	<li>
%基底~style群 ~LET %要素 にて利用されている現在の~style
◎
Let base styles be the current used styles of el.
</li>
	<li>
%調整-済み~style群 ~LET ε
◎
↓</li>
	<li>
<p>
`位置~fallback~list$を成す
~EACH( %~fallback~style群 )
に対し：
◎
For each fallback styles in the position fallback list:
</p>
		<ol>
			<li>
<p>
%~fallback~style群 を成す各~styleを %要素 に適用する
— %基底~style群 を成す対応する~propを上書きするよう：
</p>
				<ul>
					<li>
%調整-済み~style群 ~SET ［
指定d値／算出d値／使用~値
］の時点における［
上書きした~styleの`使用~値$を得るために要求される正規化
］（`~math関数$を解決するなど）を遂行した結果の %要素 の~style群
</li>
					<li>
%~margin~box ~LET ~styleを %要素 に適用した結果の %要素 の`~margin~box$
</li>
					<li>
%改変-済み包含塊 ~LET %要素 の`~insetで改変された包含塊$
</li>
				</ul>
◎
Apply the styles in fallback styles to el, overriding the corresponding properties in base styles.
◎
Perform any specified/computed/used-value time normalizations that are required to make the overridden styles into used values (such as resolving math functions, etc).
◎
Let adjusted styles be el’s styles after these adjustments.
◎
↓</li>
			<li>
<p>
~IF［
%要素 は`~snapshot済み~scroll~offset$ %~offset を有する
］：
◎
If el has a snapshotted scroll offset,＼
</p>
				<ol>
					<li>
%~margin~box ~SET %~margin~box の位置から %~offset を減算した結果
◎
then subtract the offsets from el’s margin box’s position.
</li>
					<li>
%要素 の
~EACH( `~inset~prop$ %~prop )
に対し
⇒
~IF［
%~prop の値 ~NEQ `auto$v
］
⇒
%~prop の値から対応する軸における %~offset を減算する
◎
Also, if any of el’s inset properties are non-auto, subtract the snapshotted scroll offset for the appropriate axis from their values.＼
</li>
					<li>
%改変-済み包含塊 ~SET 前~段によりズラされた［
%要素 の各`~inset~prop$の値
］を利用して，
%要素 の`~insetで改変された包含塊$を計算し直した結果
◎
Recalculate el’s inset-modified containing block using these shifted values to obtain the scroll-adjusted IMCB.
</li>
				</ol>
			</li>
			<li>
~IF［
%~margin~box は， %改変-済み包含塊 の中に全部的に包含されていない
］
⇒
~CONTINUE
◎
If el’s margin box is not fully contained within the scroll-adjusted IMCB, continue.
</li>
			<li>
~IF［
%要素 は`追加的な~fallback限界域~矩形$を有する
］~AND［
%~margin~box は，その矩形の中に全部的に包含されていない
］
⇒
~CONTINUE
◎
If el has an additional fallback-bounds rect, and el’s margin box is not fully contained within it, continue.
</li>
			<li>
~BREAK
◎
Use adjusted styles for el and exit this algorithm.
</li>
		</ol>
	</li>
	<li>
~RET %調整-済み~style群
◎
If the previous step finished without selecting a set of styles, use the adjusted styles corresponding to the final entry in the position fallback list.
</li>
</ol>

<p class="note">注記：
%要素 を~overflowしている子孫は、
この計算には影響しない
— 影響するのは %要素 の`~margin~box$に限られる。
◎
Note: Descendants overflowing el don’t affect this calculation, only el’s own margin box.
</p>

<p>
この~algoから返された~style群が，
%要素 に指定された~prop用の最終-値を与える。
◎
The styles returned by determining the position fallback styles are taken as the final values for the specified properties.
</p>
</div>

<p>
実装は、［
~layout作業に要求され得る量が過度なとき，それを制限する
］ためとして，［
`位置~fallback~list$の長さに対し，実装定義な上限を課す
］ことを選んでもヨイ。
この上限は、
5 `以上^emにするモノトスル。
◎
Implementations may choose to impose an implementation-defined limit on the length of position fallback lists, to limit the amount of excess layout work that may be required. This limit must be at least five.
</p>

<div class="issue">
<p>
入子な~anchorが在る場合
— ある~anchorされた要素 A が、
別の~anchorされた要素 B の内側に在る場合 —
~fallbackを行うとき，~layout回数が指数関数的になり得る
— 要素 A が，先祖に~scrollbarを生じさせ得る結果、
要素 B 用の`~insetで改変された包含塊$を変化させ，
場合によっては，それ【どれ？】用に選ぶ~fallbackを変化させるので。
◎
Nested anchors (an anchored element inside of another anchored element) present the potential for exponential blow-up of layouts when doing fallback, since the grandchild anchored element can cause scrollbars on an ancestor, changing the IMCB for the child anchored element, thus possibly causing the fallback choice to change for it.
</p>

<p>
これを避ける策はあるが、
それらにも~costがかかる。
これを避けるためには、
`おそらく^em，【~layout回数の】<strong>最大</strong>な上限も課すべきである。
◎
There are strategies to avoid this, but they’re not without costs of their own. We should probably impose a maximum limit as well, to avoid this.
</p>

<p>
しかしながら、
そもそも，ほとんどの用法では問題になり得ることはないので、
込み入った状況で そうなることを防止するためだけに，
それらを無闇に制約することは求まれない。
たぶん，［
各~levelにおける分岐数
］に基づくような複階性の総量にするか？
— 各~先祖の~fallback~listの長さの積を累積していって、
この総量が最大な上限を超過して以降は，最初のものしか選ばれなくなる様な
【！Get too deep and you’re stuck with your first choice only】。
これは、
何らかの適度な入子ngでも，
~top-level用に巨大で複階的な~fallback~listを許容することになる
（例えば，この上限を 1000 にしたなら、
各~listの長さが 5 のときは，深さ 4 まで入子にすることもできる）。
◎
However, since *most* usages won’t be problematic in the first place, we don’t want to restrict them unduly just to prevent weird situations from exploding. Perhaps a complexity budget based on the branching factor at each level? Like, accumulate the product of the fallback list lengths from ancestors, and your fallback list gets limited to not exceed a total product of, say, 1k. Get too deep and you’re stuck with your first choice only! But this would allow large, complex fallback lists for top-level stuff, and even some reasonable nesting. (Length-five lists could be nested to depth of 4, for example, if we did go with 1k.)
</p>

<p>
もっと思慮が必要である。
◎
More thought is needed.
</p>
</div>

<div class="example">
<p>
例えば，次の~CSSは、
ある “~popover”† を，まずは［
~buttonの下に位置させ, 
左端と~buttonの左端を整列する
］ようと試みるが、
~screenに収まらない場合には，順に［
上, 左端
］, ［
下, 右端
］, ［
上, 右端
］を試みるよう切替えることになる。
【† 何らかの動作（この例では、~button上の~hoverなど）に呼応して，他のものの上層に表示される様な~UI。】
◎
For example, the following CSS will first attempt to position a "popover" below the element, but if it doesn’t fit on-screen will switch to being above; it defaults to left-aligning, but will switch to right-aligning if that doesn’t fit.
</p>

<pre class="lang-css">
#myPopover {
  position: fixed;
  position-fallback: --button-popover;
  overflow: auto;

  /* <span class="comment">
~popoverの横幅を~buttonの横幅~以上にする
◎
The popover is at least as wide as the button
</span> */
  min-width: anchor-size(--button width);

  /* <span class="comment">
~popoverの縦幅を［
~menu~item 2 個分
］以上にする
◎
The popover is at least as tall as 2 menu items
</span> */
  min-height: 6em;
}

@position-fallback --button-popover {
  /* <span class="comment">
まず，
~popoverの［
上端／左端
］辺と~buttonの［
下端／左端
］辺を整列するよう試行する。
◎
First try to align the top, left edge of the popover with the bottom, left edge of the button.
</span> */
  @try {
    top: anchor(--button bottom);
    left: anchor(--button left);
  }

  /* <span class="comment">
次に，~popoverの［
下端／左端
］辺と~buttonの［
上端／左端
］辺を整列するよう試行する。
◎
Next try to align the bottom, left edge of the popover with the top, left edge of the button.
</span> */
  @try {
    bottom: anchor(--button top);
    left: anchor(--button left);
  }

  /* <span class="comment">
次に，~popoverの［
上端／右端
］辺と~buttonの［
下端／右端
］辺を整列するよう試行する。
◎
Next try to align the top, right edge of the popover with the bottom, right edge of the button.
</span> */
  @try {
    top: anchor(--button bottom);
    right: anchor(--button right);
  }

  /* <span class="comment">
最後に，~popoverの［
下端／右端
］辺と~buttonの［
上端／右端
］辺を整列するよう試行する。
他の位置もアリだが、
これが，作者が描画~engineに試行させたい最終-~optionになる。
◎
Finally, try to align the bottom, right edge of the popover with the top, right edge of the button. Other positions are possible, but this is the final option the author would like the rendering engine to try.
</span> */
  @try {
    bottom: anchor(--button top);
    right: anchor(--button right);
  }
}
</pre>
</div>

		</section>
		<section id="fallback-automatic">
<h3 title="Fallback and Automatic Positioning">5.5. ~fallbackと自動的な位置決め</h3>

<div>
<p>
ある要素 %要素 が，所与の軸 %軸 において
`自動的な~anchor~fallback@
を利用するよう試行しているとは、
~AND↓ を満たしていることをいう：
</p>
<ul>
	<li>
%要素 の［
%軸 に属する`~inset~prop$
］のうち、
一方は `anchor$f 関数を利用していて，
もう一方（反対-側）は `auto$v をとる。
</li>
	<li>
前項の関数の `anchor-side$t 引数は［
`auto$vA ／ `auto-same$vA
］をとる。
</li>
</ul>
◎
When an element uses an anchor() function with an auto or auto-same &lt;anchor-side&gt; argument in an inset property, and the opposite inset property is auto, the element is said to be trying to use automatic anchor fallbacks in that axis.
</div>

<p>
%要素 の `position-fallback$p が `~noneF$v をとる下で，
%要素 は ある軸 %軸 において`自動的な~anchor~fallback$を利用するよう試行している場合、
%要素 は，次に挙げる 2 個の~entryからなる`位置~fallback~list$を自動的に生成する：
◎
If the element has position-fallback: none, and is trying to use automatic anchor fallbacks in one axis, it automatically generates a position fallback list consisting of two entries:
</p>

<ol>
	<li>
1 個目の~entryは、
%要素 上の基底~styleを成す~prop
【 `try$at 規則の外で宣言された， %要素 に適用される~prop】
のうち［
`try$at 規則~内で利用しても妥当になるもの
］すべてを包含する
— 【それらの~propにて利用された `anchor$f 関数~内の】［
`auto$vA ／ `auto-same$vA
］~keywordは，各自の適切な側に解決される。
◎
the first entry contains all the base-style properties on the element that are valid to use in @try rules, with auto/auto-same keywords resolved to their appropriate side.
</li>
	<li>
<p>
2 個目の~entryは、
前項の~entryを “逆にした” もの
— すなわち、
次のように改変したものを包含する
⇒
%軸 に属する各`~inset~prop$を反対-側の~propと入れ替える
（［
`auto$vA ／ `auto-same$vA
］~keywordは，それに則って反対-側に解決する）。
</p>

<p class="trans-note">【
例えば、
`top: 1em^p は `bottom: 1em^p に置換する
— ［
`auto$vA ／ `auto-same$vA
］は、
`その結果として^em，反対-側に解決されることになる。
】</p>
◎
one containing the same, but with the inset properties in the affected axis swapped (resolving the auto/auto-same keywords accordingly).
</li>
</ol>

<p>
%要素 が両~軸とも`自動的な~anchor位置決め$を利用する場合、
代わりに，`位置~fallback~list$には次に挙げる 4 個の~entryが順に追加される
⇒＃
上と同じく基底~styleを指定しているもの,
塊~軸だけ逆にしたもの,
行内~軸だけ逆にしたもの,
両~軸とも逆にしたもの
◎
If the element uses automatic anchor positioning in both axises, it instead adds four entries to the position fallback list: one specifying the base styles, as above, then one reversing just the block axis, followed by one reversing just the inline axis, followed by one reversing both axises at once.
</p>

<p class="note">注記：
%要素 の `position-fallback$p が `~noneF$v 以外の場合、
これらの自動的な~fallbackは生成されない。
この場合，
`位置~fallback~list$を成す~styleが “基底~style” を即時に上書きすることになるので、
“基底~style” における `anchor$f 関数~内の［
`auto$vA ／ `auto-same$vA
］による最終-~styleに対する効果は、
`位置~fallback~list$内に それを上書きするものが［
在る場合は，まったくない／
無い場合は，適切な `anchor-side$t【！side】 ~keywordに解決されることに限られる
］。
◎
Note: If the element has a non-none position-fallback, these automatic fallbacks aren’t generated. Since the position fallback list styles override the "base" styles immediately, this will usually mean you wouldn’t see a "base" anchor(auto) show up in the final styles at all, but if that does happen (it’s specified in a property that isn’t overriden by anything in the position fallback list), the only effect of the auto/auto-same is to resolve to the appropriate side keyword.
</p>

<p>
`自動的な~anchor~fallback$は、
`try$at ~block内でも，略式として利用できる
— すなわち、
要素の`位置~fallback~list$内のある~entry %~entry に関して，
~AND↓ が満たされる場合…：
◎
Automatic anchor fallback can also be used as a shorthand in @try blocks.
◎
If＼
</p>

<ul>
	<li>
%~entry を適用した結果の~styleは、
`自動的な~anchor~fallback$を利用するための条件を満たしている
◎
applying an entry in the element’s position fallback list would cause the resulting styles to satisfy the conditions of automatic anchor fallbacks,＼
</li>
	<li>
前項に関連な `anchor$f 関数は、
（基底~styleからではなく） `try$at ~blockから来ている
◎
and the relevant anchor() function comes from a @try block (rather than from the base styles),＼
</li>
</ul>

<p>
… %~entry は、
代わりに，上と同じく生成された［
2 個／ 4 個
］の~entry列として扱うモノトスル。
◎
then that entry of the position fallback list must instead be treated as 2 or 4 consecutive entries, generated as above.
</p>

<p>
（他の場合、［
`auto$vA ／ `auto-same$vA
］~keywordは、
追加的な効果を伴うことなく，単に適切な側に解決される。）
◎
(Otherwise, the auto or auto-same keywords just resolve to the appropriate side, with no additional effects.)
</p>

<div class="example">
<p>
例えば、
次の `position-fallback$at 規則は：
◎
For example, the following @position-fallback rule:
</p>

<pre class="lang-css">
@position-fallback --compact {
  @try {
    top: anchor(auto);
    bottom: auto;
  }
}
</pre>

<p>
より長く明示的な，次の規則と等価になる：
◎
is equivalent to the following longer, more explicit rule:
</p>

<pre class="lang-css">
@position-fallback --expanded {
  @try {
    top: anchor(bottom);
    bottom: auto;
  }
  @try {
    top: auto;
    bottom: anchor(top);
  }
}
</pre>
</div>

		</section>
	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この文書に対し提起された~securityの課題は無い。
◎
No Security issues have been raised against this document.
</p>

	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この文書に対し提起された~privacyの課題は無い。
◎
No Privacy issues have been raised against this document.
</p>

	</section>
</main></div>
