<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web Platform Design Principles （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
.xattr {
	font-family: monospace0, monospace;
	color: var(--K-color);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'p':
	{
		const i = text.indexOf(':');
		if( i > 0 ){
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i+1)}</code>`;
		}
	}
	break;
case 'xA': // xattr
	text = `[${key}]`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href || link_map[ klass ? `${klass}.${key}` : key ];
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Web Platform Design Principles
spec_date:2023-09-08
trans_update:2023-09-09
source_checked:230406
original_url:https://w3ctag.github.io/design-principles/
	abbr_url:DESIGN-PRINCIPLES
spec_status:ED
site_nav:tag-finding
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:2023,permissive
trans_1st_pub:2021-08-11

●●class_map
E:error
xA:xattr
et:event-type
at:at-rule
e:element
p:property
a:attr
t:type
et:event-type
u:unit
v:value
sl:js-slot
A:abstract
jT:js-type
jv:js-value
h:header

●●tag_map
E:code
et:code
I:code
c:code
et:code
xA:code
at:code
e:code
a:code
p:code
t:var
u:code
v:code
jT:code
jv:code
sl:span
A:span
h:code
i:i
em:em
strong:strong
cite:cite

●●original_id_map
	prefer-dictionaries:prefer-dict-to-bool

●●link_map


xA.Clamp:~WEBIDLjs#Clamp
xA.EnforceRange:~WEBIDLjs#EnforceRange
xA.SecureContext:~WEBIDLjs#SecureContext

E.Error:~TC39#sec-error-objects
E.TypeError:~WEBIDL#exceptiondef-typeerror

jT.BigInt:~TC39#sec-bigint-objects
jT.Date:~TC39#sec-date-objects
jT.Number:~TC39#sec-number-objects
jT.WeakRef:~TC39#sec-weak-ref-objects
jT.FinalizationRegistry:~TC39#sec-finalization-registry-objects

c.double:~WEBIDL#idl-double
c.bigint:~WEBIDL#idl-bigint
c.byte:~WEBIDL#idl-byte
c.long long:~WEBIDL#idl-long-long
c.long:~WEBIDL#idl-long
c.octet:~WEBIDL#idl-octet
c.short:~WEBIDL#idl-short
c.undefined:~WEBIDL#idl-undefined
c.unrestricted double:~WEBIDL#idl-unrestricted-double
c.unsigned long long:~WEBIDL#idl-unsigned-long-long

I.ByteString:~WEBIDL#idl-ByteString
I.DOMException:~WEBIDL#idl-DOMException
I.DOMString:~WEBIDL#idl-DOMString
I.Element:~DOM4#element
I.Promise:~WEBIDL#idl-promise
I.USVString:~WEBIDL#idl-USVString
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.SharedArrayBuffer:~WEBIDL#idl-SharedArrayBuffer

I.AbortController:~DOM4#abortcontroller
I.AbortSignal:~DOM4#abortsignal
I.AudioWorklet:https://webaudio.github.io/web-audio-api/#AudioWorklet
I.Body:~FETCH#body
I.Crypto:https://w3c.github.io/webcrypto/#dfn-Crypto
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.Document:~DOM4#document
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.DOMTokenList:~DOM4#domtokenlist
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.HTMLCanvasElement:~HEcanvas#htmlcanvaselement
I.HTMLCollection:~DOM4#htmlcollection
I.HTMLHtmlElement:~HEmetadata#htmlhtmlelement
I.HTMLImageElement:~HEimages#htmlimageelement
I.History:~WINDOW#history-3
I.IDBDatabase:~INDEXEDDB#idbdatabase
I.IDBObserver:https://github.com/WICG/indexed-db-observers
I.ImageBitmap:~HTMLGAPI#imagebitmap
I.IntersectionObserver:~INTERSECTIONOBSERVER#intersectionobserver
	交差~観測器:~INTERSECTIONOBSERVER
I.KeyboardEvent:~UIEVENTS#keyboardevent
I.MouseEvent:~UIEVENTS#mouseevent
I.MutationEvent:~UIEVENTS-A#mutationevent
	#legacy-mutationevent-events
I.MutationObserver:~DOM4#mutationobserver
I.Navigator:~HTMLnavigator#navigator
I.Node:~DOM4#node
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest
I.ProgressEvent:~XHR#progressevent
I.ReadableStream:~STREAMS#readablestream
I.RemotePlayback:https://w3c.github.io/remote-playback/#remoteplayback-interface
I.ResizeObserver:~CSSWG/resize-observer/#resize-observer-interface
	I.SecureContext:https://w3c.github.io/webappsec-secure-contexts/#integration-idl
I.RTCDTMFSender:https://w3c.github.io/webrtc-pc/#dom-rtcdtmfsender
I.ScriptProcessorNode:https://webaudio.github.io/web-audio-api/#ScriptProcessorNode
I.URLSearchParams:~URL1#urlsearchparams
I.Window:~WINDOW#window
	~window~obj:~WINDOW#window
I.WindowEventHandlers:~WAPI#windoweventhandlers
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XMLHttpRequestEventTarget:~XHR#xmlhttprequesteventtarget
I.HTMLHRElement:~HEgrouping#htmlhrelement
I.NamedNodeMap:~DOM4#namednodemap
I.NonElementParentNode:~DOM4#nonelementparentnode
I.WritableStream:~STREAMS#writablestream


c.addEventListener():~DOM4#dom-eventtarget-addeventlistener
c.getElementsByTagName():~DOM4#dom-document-getelementsbytagname


e.a:~HEtextlevel#the-a-element
e.audio:~HEmedia#the-audio-element
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.figcaption:~HEgrouping#the-figcaption-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.label:~HEforms#the-label-element
e.link:~HEmetadata#the-link-element
e.option:~HEforms#the-option-element
e.output:~HEforms#the-output-element
e.q:~HEtextlevel#the-q-element
e.script:~HEscripting#the-script-element
e.select:~HEforms#the-select-element
e.source:~HEimages#the-source-element
e.style:~HEmetadata#the-style-element
e.table:~HEtables#the-table-element
e.video:~HEmedia#the-video-element


p.backdrop-filter:https://drafts.fxtf.org/filter-effects-2/#propdef-backdrop-filter
p.background-image:~CSSBG#propdef-background-image
p.display:~CSSDISP#propdef-display
p.font-size:~CSSFONT4#propdef-font-size
p.font-size-adjust:~CSSFONT4#propdef-font-size-adjust
p.initial-letter-align:~CSSINLINE#propdef-initial-letter-align
p.initial-letter:~CSSINLINE#propdef-initial-letter
p.line-height:~CSS2J#propdef-line-height
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.left:~CSSPOS#propdef-left
p.position:~CSSPOS#propdef-position

t.length:~CSSVAL#length-value
t.number:~CSSVAL#number-value
t.ident:~CSSVAL#typedef-ident

at.supports:~CSSCOND#at-ruledef-supports

u.lh:~CSSVAL#lh

	●用語
~live~obj:#live-object
静的~obj:#static-object
~monkey~patchする:#monkey-patch

	●用語（外部
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
小task:~WAPI#microtask
~task~queue:~WAPI#task-queue
~taskを~queueする:~WAPI#queue-a-task
反映-:~HTMLcdom#reflect
全部的に作動中:~HTMLds#fully-active
~BF~cache:~HTMLnav#_bf-cache

初期~値:~CASCADE#initial-value
使用~値:~CASCADE#used-value
実際の値:~CASCADE#actual-value
算出d値:~CASCADE#computed-value
継承d値:~CASCADE#inherited-value
継承-:~CASCADE#css-inheritance

解決d値:~CSSOM1#resolved-value

~scalar値:~INFRA#scalar-value
~scalar値~文字列:~INFRA#scalar-value-string
~surrogate:~INFRA#surrogate
実装定義:~INFRA#implementation-defined
文字列:~INFRA#string
符号単位:~INFRA#code-unit
~ASCII範囲:~INFRA#ascii-code-point

~maplike:~WEBIDL#dfn-maplike
~setlike:~WEBIDL#dfn-setlike
名前空間:~WEBIDL#dfn-namespace
構築子~演算:~WEBIDL#idl-constructors
~IDL数量-型:~WEBIDL#dfn-numeric-type
辞書:~WEBIDL#dfn-dictionary
部分的な~interface定義:~WEBIDL#dfn-partial-interface
部分的な辞書~定義:~WEBIDL#dfn-partial-dictionary
単純~例外:~WEBIDL#dfn-simple-exception
共用体~型:~WEBIDL#dfn-union-type
多重定義-:~WEBIDL#idl-overloading

~URL:~URL1#concept-url

aC.中止-を通達する:~DOM4#abortcontroller-signal-abort
通達から~algoを除去する:~DOM4#abortsignal-remove
通達に~algoを追加する:~DOM4#abortsignal-add
aB.中止-済み:~DOM4#abortsignal-aborted
aB.中止する~algo群:~DOM4#abortsignal-abort-algorithms
~eventを発火する:~DOM4#concept-event-fire

連列~型:~WEBIDL#sequence-type
観測-可能な配列~型:~WEBIDL#dfn-observable-array-type


●●words_table1

ETHICAL-PRINCIPLES:ethical-web-principles-ja.html
APPMANIFEST:appmanifest-ja.html
PROMISES:promises-guide-ja.html
UIEVENTS-A:uievents-appendix-ja.html
	~UIEVENTS-A:TR/DOM-Level-3-Events
REQUESTIDLECALLBACK:requestidlecallback-ja.html
HTMLsanitizer:html-sanitizer-api-ja.html
BFCACHE:bfcache-guide-ja.html
HTTPch:http-client-hints-ja.html
GEOLOCATION:geolocation-api-ja.html

Promise: <code>Promise</code> 
Observer: <code>Observer</code> 

●●words_table

	●略語／名称
AOM:
米国:US:~
TAG:
	~TAG:Technical Architecture Group
NFC:
ES:ECMAScript
USB:
Bluetooth:
IEEE:
	ADB
	PS/2
	C++
	Rust
QA:
WASM:
BF:
	~BF~cacheされた:bfcached
	~BF~cacheされた:BFCached
	~BF~cache法:BFcaching
	~BF~cache:BFCache
	~ID:id
	^en:Cascading Style Sheets
	^en:Web App Manifest
	^en:Payment Method Manifest
	^en:Publication Manifest
	^en:Origin Policy
	^en:Content Security Policy
	^en:Chromecast
	^en:AirPlay
	^en:DOM Mutation Events
	^en:Hall of API Shame:Boolean Trap
	^I:DedicatedWorker
	^I:Event
	^I:Node
	^cite:IndexedDB
	^cite:Geolocation API
	^cite:Font Enumeration API
	^cite:Web Audio API
	^en:es-discus
	^en:Bugzilla
	PrototypeJS
	Sass
	IDBObserver$I:IndexedDB Observer
	観測器:Observer
	有構造~field値:Structured Field Values
	~remote再生~API:Remote Playback API
	~web~animation:Web Animations
	~web~page:Web page／web page
	構築子~method:Constructor Method
	$r:Fetch
	真偽値の罠:Boolean Trap
	設計~原則:The Design Principle
	$I:Document
	MutationEvent$I:DOM Mutation Events
	MutationObserver$I:Mutation Observers
	~Promise
	~Promiseを利用する:Promise-Using
	~Web~IDL:WebIDL


	●処理
素早く:quickに:~
入口:entry point:~
小task:microtask:小 task:小タスク
際限ない:endlessな:~
process::::プロセス
符号化器:encoder::~::エンコーダ
繰返n:repetition:繰り返し
	〜の繰返n:repeated
繰返さな:repeatしな:繰り返さな
lifecycle:
	交差:Intersection::~
	防護-法:guarding::~
	再帰的:recursive::~
	時間がかかる:time-consuming
	し終えた:finish
浮動小数点:floating point::~
倍精度:double-precision::~
早期-:early::~
再帰:recursion::~
横取り:intercept::~
factory::::ファクトリー
相:phase::~
高頻度:frequent::~
捕捉:capture::~
batch::::バッチ
	~batchしておく:batch up
	~batch法:batching
遊休:idle::~
高分解能:high-resolution::~
milli::::ミリ
	~milli秒:millisecond
nano::::ナノ
	~nano秒:nanosecond
	秒:seconds
時機:timing::~
accessor::::アクセス子:アクセサ
maplike:
setlike:
消費器:consumer::~
存続期間:lifetime::~
bitmap::::ビットマップ
bitmask::::ビットマスク
切詰める:clampする:切り詰める
丸めら:roundさ:~
	小数を伴う:fractional
剰余:modulo:~
処理待ち:pending:~
覗見る:peekする:覗き見る
排他的:exclusive:~
周期的:periodical:~
復旧-:restore::~
静止-:pause::~
書込める:writeできる::書き込める
書込n:write::書き込み
切離され:detachされ::切り離され
投機的:speculative::~
投入-:feed:~
候補:candidate:~
main::::メイン
保存-:save:~
カクつく:jankになる:~
冪等性:idempotence::~
累積:accumulation::~
timer::::タイマー

	遅過ぎる:too slow
	遅い／遅く:slow
	完了まで走る:run-to-completion
	二回以上:repeatedly
	構築-可能でない:non-constructible
	構築-可能:constructible
	行く:go through
	行く:going
	設定しておく:set up
	先送りすること:deferral
	~process間の:inter-process
	短く:short
	短い:short
	より長い:longer
	すでに起きて完遂された:already finished happening
	観測されたが まだ送達されていない:observed-but-not-yet-delivered
	取消-可能でない:non-cancelable
	一度限りの:one-time
	それ以降:rest
	長く走る:long-running
	投出すること:throwing:#1
	渡-:pass
	受け渡-:passed around
	〜をそのまま〜渡す:pass 〜 through
	取消すよう要請された:presses "cancel"
	生じた事象:occurrence
	後続して~queueされる〜:follow-up 〜
	終了~時:ending
	~cache法:caching
	他を阻む:blocking
	他を阻まない:non-blocking
	具現化を阻む:render-blocking
	同じ結果を生産する:something that 〜 produces itself

	●保安
本物:genuine:~
騙そう:trickしよう:~
危険:dangerous:~
危険性:danger:~
認証:authentication::~
機密性:confidentiality::~
特権的:privileged::~
脆弱:vulnerable::~
安全性:safety::~
乗取られ:hijackされ:乗っ取られ
真似る:resembleする:~
詐欺:scam:~
害:harm:~
害そう:harmしよう:~
害-:harm:~
私的:private::~
露呈-:reveal::露わに
形跡:trace::~
脅威:threat::~
	より~riskが高い:riskier
表口:surface::口
表面:surface::~
相関-:correlate:~
相関:correlation:~
noise::::ノイズ
野放図な:unsanctioned:~
sniff:
	~sniff法:sniffing
親権者:parent:~
partner::::パートナー
国家権力:state actor::~
製造元:make:~
銘柄:brand:~
	銘柄:branding
弱める:weakenする:~
晒し:exposeし:~
暗号:crypto:~
暗号用の:cryptographic:~
side-channel::::サイドチャネル
XSS:
無毒化-:sanitize::~
侵害的:invasive:~
Spectre:

	抗-:against
	信用-済み:trusted
	信用に価する:trustworthy
	信用-済みでない:untrusted
	~secureでない:insecure
	~secureでない:non-secure
	安全な形式とみなされる:they are safelisted
	安全でない:unsafe
	~~入口:ingress point
	~~出口:egress point
	公開され:exposure
	~filter法:filtering

	●UI
bar::::バー
touch::::タッチ
tap::::タップ
picker:::選択 UI
選定器:selector::~::セレクタ
	選び取られ:pick
非可視:hidden:~
clipboard::::クリップボード
押付け:intrusive:押し付け

	●呈示／CSS
紙:paper:~
先頭字:initial letter::~
埋没:drop::~
沈込み:sunken::沈み込み
沈込する:sinkする::沈み込む
持上げ:raised::持ち上げ
頭字:cap::~
高さ:height:~
見かけ:look:~
視られ:viewされ:~
視れる:viewできる:~
	~view可能:viewable
flex:
格子:grid::~::グリッド
筋:track::~::トラック
見出し:heading:~
隠す:hideする:~
隠せる:hideできる:~
塗り:paint:~
	塗り用に準備済み:ready to paint
Lab:
	~Lab色＠:L*a*b* color
色彩科学:Color Science:~
明滅-:flash:~
	~CSS選択子:selector
	未~styleな:unstyled

	●環境／hardware
internet:
mobile::::モバイル
online::::オンライン
off-line::::オフライン
filesystem::::ファイルシステム
camera::::カメラ
microphone::::マイク
sensor::::センサー
gyroscope::::ジャイロスコープ
加速度計:accelerometer::~
周辺機器:peripheral:~
計算機:computing device:~
disk::::ディスク
bus::::バス
遮断:disruption:~
低性能:low-powered:~
	とり外され:unplugged

	●命名
専門用語:technical term:~
代名詞:pronoun:~
形容詞:adjective:~
成句的用語:term of art:~
略語:abbreviation:~
語根:root form:~
動詞:verb:~
名詞:noun:~
品詞:part of speech:~
文字大小規則:casing rule:~
	文字大小~法:casing
camel-case:
	~camel-case化:camel-cased
pascal-case:
頭字語:initialism:~
大字:capital:大文字
	大字:caps
	大字~化:capitalize
接頭-:prefix::~
underscore::::アンダースコア
dash::::ダッシュ

	^en:signposting
	^en:blocklist
	^en:allowlist
	^en:blacklist
	^en:whitelist
	^en:replica
	^en:master
	^en:slave

	●仕様
設計者:designer:~
trade-off::::トレードオフ
助言:advice:~
目指す:aimする:~
目指して:aimして:~
拒否-:refuse:~
兆候:signal:~
正当化-:justify:~
独立性:independence:~
上品:graceful:~
総意:consensus:~
活動:activity:~
機能-:function:~
機能:function:~
機能上は:functionalには:~
機能上の:functionalな:~
策:strategy:~
防護-:guard:~
複雑な:complicatedな:~
念頭:mind:~
稀:rare:~
文言:language:~
必要性:needs:~
正せる:correctできる:~
協調-:coordinate:~
働けな:workできな:~
多彩:rich:~
自立的:standalone:~
理想的:ideal:~
proprietary::::プロプライエタリ
ecosystem::::エコシステム
発展:evolution:~
発展-:evolve:~
進化-:evolve:~
施行:enforcement:~
申請-:file:~
質問票:questionnaire:~
考案-:invent:~
背後:behind:~
理論的:theoretical:~
社会:society:~
現実:reality:~
相補的:complementary:~
補う:complementする:~
土台:foundation:~
比較検討-:weigh:~
同意:consent:~
同意-:consent:~
確証:confidence:~
	高まる:reinforce
負担:burden:~
柔軟:flexible:~
柔軟性:flexibility:~
解く:solveする:~
解決策:solution:~
実現可能:feasible:~
利点:advantage:~
個人的:personal:~
雇用者:employer:~
動作者:actor:~
消費者:consumer:~
翻訳-:translate:~
障害:disabilities:~
堅牢:robust:~
拙く:poorに:~
	拙く:poorly-
調和-:harmonize:~
想像-:imagine:~
事実調査:research:~
有益:beneficial:~
知見:finding:~
厳格:rigorous:~
説明書き:explainer:~
通過制御-:gate:~
決定的:deterministic:~
満足-:satisfy:~
	~~満足:happy
一様:uniform:~
本当:real:~
学習曲線:learning curve:~
冗長:redundant:~
周知:well-known:~
警告-:warn:~
支援技術:assistive technologies:~
英語:English:~
話者:speaker:~
命令的:imperative:~
読する:readする:読む
読して:readして:読んで
読され:readされ:読まれ
書法:writing:書き方
書者:writer:書き手
書する:writeする:書く
書せる:writeできる:書ける
書され:writeされ:書かれ
書した:writeした:書いた
選択:choice:~
	選ぶこと:choice
選ばれ:chooseされ:~
選ぶ:chooseする:~
選んだ:chooseした:~
選べる:chooseできる:~
能性:potential:~
	アリ性:possibility
考して:thinkして:考えて
考する:thinkする:考える
	よく考して:thoughtfully
考出され:thought-outされ:考え出され
明白:obvious:~
過ち:mistake:~
critical:
monkey:
patch::::パッチ
親切:friendly:~
	親切さ:friendliness
究明-:investigate:~
自己完結的:self-contained:~
自己記述的:self-describing:~
模擬-:mock:~
種類:kind:~
自由:free:~
	自由に:freely
倫理上の:ethicalな:~
	倫理上の:Ethical
完璧:perfect:~
順応-:adapt:~
転用-:adapt:~
確証:confidence:~
	確証は高まる:reinforcing their confidence
責務:responsibilities:~
適理:reasonable:~
今日:today:~
余分:extra:~
加的な:extraな:追加の
価値:value:~
	価値をもたらす:valuable
個人:person:~
判明-:emerge:~
利用元:user:~
合理性:rationale:~
多方面で:extensiveに:~
大多数:majority:~
必然的に:naturalに:~
悪名高い:infamousな:~
感じる:feelする:~
指名-:designate:~
推測-:guess:~
根深い:profoundな:~
比較的:relativeに:~
活発:vibrant:~
現実的:realistic:~
生活:life:~
破って:breakして:~
簡潔:concise:~
解明-:figure out:~
適理:reasonable:~
探求-:seek:~
open:
	~openでない:closed
	~openでない:non-open
為され:makeされ:~
為す:makeする:~
人物:persona:~
公表物:publication::~
包括的:inclusive:~
編集-:edit:~
訊いて:askして:~
続行-:proceed:~
合意-:agree:~
否定法:negation:~
否定的:negative:~
対処-:workaround:~
	対処-:work-around:~
領分:domain:~
分野:area:~
優先度:priority:~
優先-:prioritize:~
優先順位付ける:prioritizeする:~
	優先度を下げる:prioritize
engineering:
語法:terminology:~
臭:smell:~
	~code臭:code smell
関心事:interesting thing:~
	何か関心事:something interesting
各個人:individuals:~
増強-:enhance:~
力:power:~
	力を持つ:power over
努める:tryする:~
先例:precedent:~
齢:age:~
馴染み:familiar:~
寄与-:contribute:~
相反な:mutual に exclusiveな:相反する
利便性:usability:~
拙い:poorな:~
競合-:conflict:~
競合:conflict:~
衝突:clash:~
普及度:prevalence:~
	普及している:popularな
	普及度合い:popularity
人間工学:ergonomics:~
論争:heated debate:~
antipattern::::アンチパタン
顕在化-:materialize:~
世界:world:~
	外の世界:the world
公平:impartial:~
立証-:prove:~
防御的:defensive:~
正しさ:correctness:~
専門家:expert:~
必要十分:adequate:~
介入-:intervene:~
急速:quick:~
持込む:bringする:持ち込む
持込まれ:bringされ:持ち込まれ
アル:possibleである:ある
構築部品:building block:~
類似しな:similarでな:~
可読:readable:~
	〜として可読:-readable
妥協-:compromise:~
	妥協-法:compromising
tradeoff::::トレードオフ
dilemma::::ジレンマ
手助け:facilitate:~
原型:prototype::~::プロトタイプ
広範:extensive:~
近道:shortcut:~
複階度:complexity:~
共通度:commonality:~
妨害-:disrupt:~
難題:challenge:~
欠陥:defect:~
品質:quality:~
許諾:license:~
最悪:worst:~
	最悪な場合:at worst
不作為:inadvertent:~
陥穽:pitfall:落とし穴
一時的:temporary:~
地点:point:~
復帰-:revert:~
冗漫さ:verbosity:~
真実:truth:~
請合う:warrantする:請け合う
惑わす:confuseする:~
	〜を惑わす:confusion
模倣-:emulate:~
補助的:auxiliary:~
人々:people:~
義務的:mandatory:~
社会的弱者:disadvantaged or marginalized users:~
義務的:mandatory:~
欠いて:lackして:~
変種:variant:~
規範:norm:~
追求-:pursue:~
保つ:keepする:~
保たれ:keepされ:~
併合-:merge:~
paste::::ペースト
上流:upstream:~
真剣:serious:~
保守者:maintainer:~
末端-:end:~
引用-:quote:~
収束-:converge:~
深刻:serious:~
支配的:dominant:~
出荷-:ship:~
	出荷しなく:un-ship
	出荷しなく:unship
難点:downside:~
定着-:entrench:~
普段は:regularに:~
不定期:indefinite:~
尊重-:respect:~

	~~経験則:rules of thumb
	〜向けの:oriented
	ある下:given
	かなり~~増す必要があろう:would have had to create a good bit of
	きちんと:well-
	こと自体が〜抵触する:which would fail if
	されたし:please
	したい:would like to
	しようとすることになる:would go on
	すなわち:This means that
	すべての方々に:who everyone
	その成果は〜のおかげ:indebted to
	それでも:still
	たぶん:perhaps
	つきまとう:come with
	ついて来る:come with
	とってもっと良くなる:would be better-off
	とは限らない:won’t necessarily
	なくとも済む:can avoid
	ほどには:quite as safe as
	もっと多彩:richer
	一様でない:non-uniform
	一部の文脈〜ない:n't 〜 every possible context
	下せる:make
	主な:main
	予期せず:unexpectedly
	期待されない:unexpected
	促す:help encourage
	助けになる:help
	助けに:helpful
	傾向にある:tends to
	内での活動, 外での活動:activity both in and out
	難しい:hard
	難しく:hard
	方が難しい／難しく:harder
	努力を怠らない:hard
	単-目的:single-purpose
	原因:cause
	原因になる:causing
	厳密に:strictly
	反して:go against
	可用でない:unavailable
	同様に:likewise
	呼ばれ／称され:called
	呼応して:in response to
	在る:present
	堅持する:sticking
	失う:losing
	容易さ:ease
	対:vs.
	対照的に:in contrast
	当然のことと~~見なす:take for granted
	必要:need
	感謝:thank
	手続き全体を読するか飛ばすか:read the steps or skip over them
	抽象-化:abstraction
	指して／指す:refer
	指定されたとおり:as-specified
	採る:take
	探す:look for
	推測-可能:guessable
	損なう:undermineする:~
	敷居:barrier to entry
	文法~上の:grammatical
	方が明瞭／もっと明瞭:clearer
	普及させる:roll out
	最も容易:easiest
	有無:presence
	有無:presence or absence
	極めて:extremely
	残念なことだが:sadly
	~~比して過不足がある:does more or less
	気付いた:notice
	注意点:Use care
	注意点:caution
	特に注意する:be cautious
	に注意:beware
	注意を払う:pay attention
	注記-:note
	満たす:meet
	無い:not present
	無為にする:defeat
	特に:notably
	用立てる:make use
	真っ先に挙がる:Most prominent
	知る:know
	突きつける:pose
	純粋さ:purity
	総じて:overall
	織り込む:account
	考慮し直す:re-consider
	考慮し直す:reconsider
	至る:lead
	導く:lead
	良い:good
	行える:do able
	およそ:likely
	見込まれる:likely
	見込みが高く:likely
	見込みは高まる:more likely to
	の視点で:points from 〜 perspective
	謝意:thanks
	足りる:suffice
	避けれない:unavoidable
	~~全般に:across
	場として当を得ている:right place
	~~普及:enough
	十分:enough
	~~特定すること:pinpointing
	~~省略:left out
	〜に過ぎる:overly
	その発想元:inspired
	ひらめき:inspiration
	より~~緩やか:shallower
	思いがけない:surprising
	挙動が〜異なる:behave differently
	異なった／違える／異なるように:differently
	違える:had a different
	~~短さ:brevity
	~UAが供した:User-Agent-provided
	将来にも通用する:future-proof
	将来にも通用する命名:future-proofing
	手続きの詳細に入る:going into detail
	ことに加え、〜してしまう:or even worse
	多様な:virtually any
	~~都合良く:better
	~~時期もあった:There have been times
	ある種の:certain types of
	縁遠い:less directly connected
	選好する:preference 〜 towards
	このことから:because of this
	次第に逸れる:^en:scope creep
	調べる／調べて:look-at
	であった頃から:back then
	~~未熟な~~段階:not ready for prime time
	当の:said
	言った:said
	勧告候補~後:post-CR
	取り込む:ingest
	当の:your
	当の仕様の:your
	対象者:audience
	~~対象者:constituencies
	将来にも通用する:future-proof
	満たせない／満たされ:hold
	そのことが目立つよう:more noticeable
	~~理解し難くなる:harm comprehension
	必要なら:presumably
	そのこと:this omission
	一致する:agree
	事実／:fact
	考慮に入れる:for consideration
	何も告げない:gives no sign
	一定期間は:certain times
	不可能:impossible
	~~影響:inform
	伝えられ:inform
	どちらにするか，~~情報を得た下で:informed
	もっと判り易くする:make 〜 less confusing
	そのこと:this omission
	あろう仕方とは逆に:instead of a hypothetical algorithm which would ...
	仮に〜あったとするとき:hypothetical
	作成できなくなって:prevents the creation of
	むしろ:What is more 〜 is
	作る:make
	きちんとした意図nがある:well intentioned
	もっと単純に:less complex
	余地もある:there might be scope for
	〜~mode下にある:〜mode is engaged
	その~modeから離れた:disengage
	〜よう希望される:hopefully
	~~十分な~~根拠になる:warrant
	信じた:believe
	~~確信できる:can be sure
	必ず:making sure
	〜すること。:be sure to 〜
	〜すること。:make sure 〜
	確かめる:make sure
	ようになる:can make sure
	因んで命名され:named for
	記載-:set out
	〜であった既存の:pre-existing
	収まった:fit
	〜するようにする:mark
	含まない:excluding
	各種~言語にわたる:cross-language
	またぐ:cross
	〜間の:cross-
	複数~文書にわたる:span multiple documents／document-spanning／:cross-document-spanning
	~careする:take care
	意に反する:surprising
	関わり合う:engage with
	~debug能:debuggability
	者たち:someone who
	〜方が無難:err on the side of 〜
	支持する:favoring
	支持する方に:in favor of
	支持を受けて:in favor of
	対立する:tension between
	対立:tension
	次第に:gradually
	最終的に:eventually
	どれに該当するか:what 〜 will be
	再利用-:re-use
	損なう:undermine
	満たす:meet
	事前に備えておく:proactive
	〜していなかった:have missed
	ようにする:let
	大部分の:bulk of
	目の前の:at hand
	道:path
	逃げ道:escape hatch
	進むべき道:a way forward
	道:route
	略して:for short
	与えるゆとりがある:afford
	形作れ:emerge
	無い:free from
	低~levelな:low level／:low-level／:lower-level
	高~levelな:high level／:high-level／:higher-level
	存在しないもの:non-existent
	その力に比して，利用の難易度がひどく上がることはない:continuity of the ease-of-use vs power tradeoff curve
	-:sharp cliff
	層~化され:layered
	層を重ねる:layer 〜 on top of
	~~上層:on top of
	組込みの~accessibility:accessibility built-in
	前者と後者どちらか:one of these groups of
	逆:inverse
	必要が生じる:necessitating
	設計し直す:redesign
	互換でない:incompatible
	著しさ:severity
	著しく:severely
	簡便でないものほど:inconvenience 〜 the least
	~tool群:tooling
	〜よりも:secondary
	残る:last
	価する:worth
	もちろん:of course
	さもなければ:The alternative 〜 is
	判明-:turn out
	明瞭でない:unclear
	そのままで:out of the box
	そのまま:verbatim
	劣化-:further decrease
	~~版:iteration
	重ねて持ち込む:duplicate
	~module化:modularization
	決して変更されない:cannot, and will not, be changed
	ときには:sometimes
	間違って:wrongly
	決めつける:presuppose
	失われる:miss
	悪化しかねない:Or worse, 〜 worse
	相互に関係する:interrelated
	~~許容される:ok
	~~強く勧める:highly advisable
	~web~platform:the Web Platform／:the web platform
	名前を付ける:Carving out 〜 naming
	相応するもの:counterpart
	反する~pattern:counterpattern
	この逆も成立するわけではない:This does not hold the other way around
	〜のみが:single
	後の祭りだが、:In hindsight，
	留意-:remember
	覚え易く:easier to remember
	〜と命名すること:call
	〜に従って:after
	非~一貫性:~inconsistencies
	顕著に:pronounce
	非推奨にされる:deprecation of
	分類:categories
	該当する:falls into
	~~不正に機能-:malfunction
	現時点で:at the moment
	現今においては:as of today
	難が生じる:suffer
	賢く:wisely
	邪魔-:hinder
	~~述べ:say
	に対し:against
	受け取る:take
	より早く:sooner
	~~区間:section
	伝える:tell
	拘束され過ぎ:over-constrained
	拘束され過ぎ:over-constraint
	実装:implementor
	仕様~化-:specify
	相互運用可能にする~cost:the interoperability costs
	~~関係者すべて:all involved
	〜に従って:guide
	〜に従事-:operate
	標準でない:non-standard
	最小~化:minimize
	最小~化:minimizing
	他の:the rest of
	実装-能:implementability
	実装-可能:implementable
	~~現時点では:present-time
	勝る:outweigh
	好ましい:preferable
	用意がない:unwilling
	用意がある:willing
	標準~化の場:standards venues
	関心がある:interested
	非~標準:nonstandard
	知りながら:knowing
	一つしかない:single-
	その結果は:outcome
	~bug含み:buggy
	~~気付かない:unaware

	●未分類

void:
polyfill:
manifest::::マニフェスト
schedule::::スケジュール
schema::::スキーマ
component::::コンポーネント
singleton:
signature:
asset::::アセット
多形態性:polymorphism::~
共用体:union::~
多重定義-:overload::~
多重定義:overloading::~
用字系:script:~
Latin:
Cyrillic:::キリル文字
Arabic:::アラビア語
支払い:payment::~
店:store:~
持続-:persist:~
合成な:syntheticな:~
近過去:recent:~
機械:machine:~
数量-:numeric:~
数値化-:quantify:~
付番-:number:~
番号:number:~
実数:number:~
十進数:decimal:~
surrogate::::サロゲート
遭遇-:encounter:~
連結-:concatenate:~
出荷先:shipping:~
請求先:billing:~
区切られ:delimitされ:~
疑似-:pseudo-:~
再生:playback::~
再生-:play::~
	持続-可能:persistable
percent-:%-
日付:date::~
日時:date-time::~
派生:derived::~
弱い:weakな::~
切取られ:clipされ::切り取られ
束ねる:tieする::~
重合しな:overlapしな:重なり合わな
重合する:overlapする:重なり合う
食品注文:food ordering:~
言語束縛:binding::~::バインディング
絞込まれ:filterされ:絞り込まれ
交換:exchange:~
先行-:precede:~
量:amount:~
居残な:stickyな::居残る
一過:transient::~
組織的:organical:~
付随-:accompany:~
実験n:experimentation:実験
部屋:room:~
丸括弧:parentheses:~
角括弧:square brackets:~
前処理器:preprocessor::~::プリプロセッサ
空欄:blank:~
共有:sharing::~
頻繁:frequent:~
計量:metric::~
側:side:~

	`infinity^jv, `-infinity^jv:infinities
	`infinity^jv, `-infinity^jv:±Infinity
	`0^jv, `-0^jv:±0
	jv:NaN
	`number^jT:number

	~~自動化:automobile
	~style上の:stylistic
	前置された:left-hand
	列挙d値:enums
	〜を包装する〜:wrapper
	包装するもの:wrapper around
	し始める:beginning
	し始める:begin
	始める:begin
	始まる:begin
	型を伴う:typed
	し続ける:continues to
	遡って:walking up
	真偽値を返す:boolean-returning
	膨大な:vast
	継承されない:non-inherited
	到達-不能:unreachable
	され続ける:keep
	-:keep things
	近づける:keep 〜 as close as
	単-~page:single-page
	戻る:back
	〜片:piece of
	~~過去および~~現在:past and present
	~~過去:the past
	~styleを伴わない:unstyled
	所属-:belong
	置く:put
	低くする:lower
	残さな:leave
	残す:leave
	ままに:leave
	様々な~sizeの:very wide range of 〜 sizes
	指定が不十分:isn’t specific enough
	何かについて問う~API引数:API arguments which are asking a question about their argument
	地図:mapping
	単位が無い:unitless
	全部的に作動中になったとき, なくなったとき:full activity is lost or not
	増やす:increaseする
	増える:increaseする
	少し増すだけで:small amount of incremental
	速い:fast
	より速い:faster
	生きた:live
	~~言葉:word
	Wikipedia
	~void要素:empty element
	~feedback:feeding it back to
	いくつもの:more than a couple of
	一連の:collection of
	一連の:series of
	連列／一連の:sequence
	~algo群:collection
	同時:simultaneous
	同時:at the same time
	非:non
	非-:non
	〜以外:non-〜
	重ねて:twice
	一群の:set of
	項:term
	〜に劣る:~less 〜
	最も近い:nearest
	何倍になるか:multiple
	次回の:next:
	途中で:in the middle
	いつの時点でも:at all times
	回ごとに／毎回:each time
	回:time
	ようになった頃:at the time
	時点では:at the time
	一回に:at a time
	周り:around
	数:number
	数がより少ない:fewer
	もっと短い:shorter
	小さく:small
	より小さ:smaller
	少なく:smaller
	少なく:small
	少なく:less
	~~増す:larger
	より大きな:larger
	大きく:large
	少量な:small amount
	必要最小限:smallest
	少量:least
	のほとんど:mostly
	旧い:older
	第一に:first
	複数回:more than once
	一回:once
	一度に／まとめて:at once
	だけ:just
	それ自体で:on its own
	だけでは足らない:’t sufficient by themselves
	の多く:a lot of
	〜以下の:at most
	ほぼ:almost
	唯一の:the only
	多くの:many
	後で:later
	入らない:outside
	結果の:resulting
	ただ〜だけ:merely
	より高／もっと高ければ:higher
	高-:high-
	向かう:toward
	最も／ほとんどの:most
	誰か:someone
	〜のときも／ときには，:sometime
	より広い:wider
	広くから:widely
	幅広い:wide
	多様な:wide variety of
	いくつかの:a number of
	数多くの:a large number of
	除いて:except
	他所:elsewhere
	他所すべて:the rest
	一人の:single
	一部の者:some
	他の者:Others
	各部:pieces
	各部:parts
	先に:earlier
	まず，:firstly
	最後に:finally
	より新たな:newer
	近く:closely
	全体を通して:throughout
	〜に~~後続する:subsequent
	〜に~~後続する:given
	関する:regard
	箇所／点:point
	指す:point
	一方〜他方:vice versa
	上述した:the earlier
	多大に:hugely
	大部分は:mostly
	-:micro-
	先頭から順に:left to right
	末尾から順に:right to left
	ずっと:much more
	とても:very
	もの:thing
	一片の／〜片:bit of
	場所:place
	箇所:place
	幾度となく:a lot of
	最も近い:closest
	前者より広い:broader
	他所へ:away
	前者:the-first-part
	何回か:repeatedly
	最後に:final
	最新:up-to-date
	よりずっと長く:a lot longer than
	あまりに多くの:a large number of
	幾度となく:A lot of the time
	何百万もの:millions
	今後、:upcoming
	〜の他にも，いくつもある:several 〜 and many more
	順番に:in series
	当の:in question
	とは限らない:not always
	他者／他所:others

●●ref_key_map
HIGHRESTIME:HRTIME

●●ref_data
INTERSECTIONOBSERVER=副     ~/IntersectionObserver-ja.html
ETHICALWEB=副               ~/ethical-web-principles-ja.html
WEBAUDIO=主                 g200kg.github.io/web-audio-api-ja/
WEBAUDIO=・                 webaudio.github.io/web-audio-api/

●●ref_normative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[FINGERPRINTING-GUIDANCE]
    Nick Doty. ＜Mitigating Browser Fingerprinting in Web Specifications＞. URL: https://w3c.github.io/fingerprinting-guidance/
[HIGHRES-TIME]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[IndexedDB-3]
    Joshua Bell. ＜Indexed Database API 3.0＞. URL: https://w3c.github.io/IndexedDB/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[PAYMENT-REQUEST]
    Marcos Caceres; Rouslan Solomakhin; Ian Jacobs. ＜Payment Request API＞. URL: https://w3c.github.io/payment-request/
[PAYMENT-REQUEST-1.1]
    Marcos Caceres; Rouslan Solomakhin; Ian Jacobs. ＜Payment Request API 1.1＞. URL: https://w3c.github.io/payment-request/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[XHR]
    Anne van Kesteren. ＜XMLHttpRequest Standard＞. Living Standard. URL: https://xhr.spec.whatwg.org/

●●ref_informative

[APPMANIFEST]
    Marcos Caceres; et al. ＜Web Application Manifest＞. URL: https://w3c.github.io/manifest/
[CREDENTIAL-MANAGEMENT-1]
    Mike West. ＜Credential Management Level 1＞. URL: https://w3c.github.io/webappsec-credential-management/
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-FONTS-5]
    Myles Maxfield; Chris Lilley. ＜CSS Fonts Module Level 5＞. URL: https://drafts.csswg.org/css-fonts-5/
[CSS-GRID-1]
    Tab Atkins Jr.; et al. ＜CSS Grid Layout Module Level 1＞. URL: https://drafts.csswg.org/css-grid/
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad. ＜CSS Inline Layout Module Level 3＞. URL: https://drafts.csswg.org/css-inline-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[CSSOM-VIEW-1]
    Simon Pieters. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[DOM-Parsing]
    Travis Leithead. ＜DOM Parsing and Serialization＞. URL: https://w3c.github.io/DOM-Parsing/
[ENCRYPTED-MEDIA]
    David Dorwin; et al. ＜Encrypted Media Extensions＞. URL: https://w3c.github.io/encrypted-media/
[ETHICAL-WEB]
    Daniel Appelquist; Hadley Beeman. ＜W3C TAG Ethical Web Principles＞. 27 October 2020. TAG Finding. URL: https://www.w3.org/2001/tag/doc/ethical-web-principles/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[FILTER-EFFECTS-2]
    ＜Filter Effects Module Level 2＞. Editor's Draft. URL: https://drafts.fxtf.org/filter-effects-2/
[INTERSECTION-OBSERVER]
    Stefan Zager; Emilio Cobos Álvarez. ＜Intersection Observer＞. URL: https://w3c.github.io/IntersectionObserver/
[LEAST-POWER]
    Tim Berners-Lee; Noah Mendelsohn. ＜The Rule of Least Power＞. 23 February 2006. TAG Finding. URL: https://www.w3.org/2001/tag/doc/leastPower
[POINTEREVENTS3]
    Patrick Lauke; Navid Zolghadr. ＜Pointer Events＞. URL: https://w3c.github.io/pointerevents/
[REFERRER-POLICY]
    Jochen Eisinger; Emily Stark. ＜Referrer Policy＞. URL: https://w3c.github.io/webappsec-referrer-policy/
[REMOTE-PLAYBACK]
    Mark Foltz. ＜Remote Playback API＞. URL: https://w3c.github.io/remote-playback/
[RFC8890]
    M. Nottingham. ＜The Internet is for End Users＞. August 2020. Informational. URL: https://www.rfc-editor.org/rfc/rfc8890
[RFC8941]
    M. Nottingham; P-H. Kamp. ＜Structured Field Values for HTTP＞. February 2021. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8941
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. URL: https://w3c.github.io/uievents/
[UNSANCTIONED-TRACKING]
    Mark Nottingham. ＜Unsanctioned Web Tracking＞. 17 July 2015. TAG Finding. URL: http://www.w3.org/2001/tag/doc/unsanctioned-tracking/
[WebAudio]
    Paul Adenot; Hongchan Choi. ＜Web Audio API＞. URL: https://webaudio.github.io/web-audio-api/
[WebCryptoAPI]
    Mark Watson. ＜Web Cryptography API＞. URL: https://w3c.github.io/webcrypto/
[WEBRTC]
    Cullen Jennings; et al. ＜WebRTC: Real-Time Communication in Browsers＞. URL: https://w3c.github.io/webrtc-pc/

●●ref_additional
[RFC8942]
    I. Grigorik; Y. Weiss. ＜Client Hints＞. February 2021. Experimental. URL: https://www.rfc-editor.org/rfc/rfc8942

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Web Platform Design Principles</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/design-principles/
公表履歴
	https://www.w3.org/standards/history/design-principles/
フィードバック
	https://github.com/w3ctag/design-principles/issues/
編集
	<a href="https://sangwhan.com">Sangwhan Moon</a> (Google)
前任編集者
	<a href="https://domenic.me/">Domenic Denicola</a> (Google) <a href="mailto:d@domenic.me">d@domenic.me</a>
	<a href="mailto:travil@microsoft.com">Travis Leithead</a> (Microsoft)

By:
	<a href="https://www.w3.org/2001/tag/">Members of the TAG</a>, past and present
Participate:
	<a href="https://github.com/w3ctag/design-principles">GitHub w3ctag/design-principles</a> (<a href="https://github.com/w3ctag/design-principles/issues/new">file an issue</a>; <a href="https://github.com/w3ctag/design-principles/issues?state=open">open issues</a>)

commit 履歴
	https://github.com/w3ctag/design-principles/commits/main

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Web プラットフォーム設計原則 — Web Platform Design Principles</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、
~web~platform技術を設計するときに利用される，一群の設計~原則を包含する。
これらの原則は、
開発-中にある仕様を`考査する＠https://github.com/w3ctag/design-reviews/$ときにおける，
技術-~architecture~group
（ `Technical Architecture Group^en, 略称 ~TAG）
【以下，この訳では、~TAG と略記する】
による論点から収集されたものであり，
`倫理上の~Web原則^cite
（ `Ethical Web Principles^en ） `ETHICAL-WEB$r
の上に築かれた。
仕様~設計者には、
この文書を読して，設計~裁定を為すときの資源として利用することが奨励される。
◎
This document contains a set of design principles to be used when designing web platform technologies. These principles have been collected during the Technical Architecture Group’s discussions in reviewing developing specifications, and build upon the Ethical Web Principles [ETHICAL-WEB]. We encourage specification designers to read this document and use it as a resource when making design decisions.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
~TAGにより公表された編集者草案です…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="basic-principles">
<h2 title="Principles behind design of Web APIs">1. ~Web~API設計の背後にある原則</h2>

<p>
この設計~原則（ `The Design Principles^en ）は、
`倫理上の~Web原則^cite `ETHICAL-WEB$r 内に記載された倫理上の~frameworkから直に~~影響される。
これらの原則は、［
~web~platformを開発することにつきまとう，より高~levelな倫理上の責務
］に呼応して，具象的かつ実用的な助言を供する。
◎
The Design Principles are directly informed by the ethical framework set out in the Ethical Web Principles [ETHICAL-WEB]. These principles provide concrete practical advice in response to the higher level ethical responsibilities that come with developing the web platform.
</p>

		<section id="priority-of-constituencies">
<h3 title="Put user needs first (Priority of Constituencies)">1.1. 利用者の必要性を第一に置くこと（~~対象者の優先度）</h3>

<p>
~trade-offを為す必要がある場合、
常に，利用者の必要性を他のすべてより上に置くこと。
◎
If a trade-off needs to be made, always put user needs above all.
</p>

<p>
類似に，~APIを設計し始めるときは、
当の~APIが取組もうと目指す利用者の必要を理解して，それを文書化すること。
◎
Similarly, when beginning to design an API, be sure to understand and document the user need that the API aims to address.
</p>

<p>
`~internetは末端-利用者のためにある＠~RFCx/rfc8890$：
~web~platformに為される どの変更も，
`膨大な数の人々に影響する＠~ETHICAL-PRINCIPLES#allpeople$能性があり、
どの個人の生活にも根深い影響iがあり得る。
`RFC8890$r
◎
The internet is for end users: any change made to the web platform has the potential to affect vast numbers of people, and may have a profound impact on any person’s life. [RFC8890]
</p>

<div class="p">
<p>
必要性の優先順は、
次に挙げる順になる：
</p>
<ol>
<li>利用者の必要性
<li>~web~page作者の必要性
<li>~UA実装者の必要性
<li>仕様の書者の必要性
<li>理論的な純粋さ
</ol>
◎
User needs come before the needs of web page authors, which come before the needs of user agent implementors, which come before the needs of specification writers, which come before theoretical purity.
</div>

<div class="p">
<p>
他のすべての原則と同様に，これは絶対的ではない：
</p>
<ul>
	<li>
著作の容易さは、
内容が利用者へどう到達するかに影響する。
</li>
	<li>
~UAは、
有限な~engineering資源を優先順位付ける必要がある
— それは、
特能が作者へどう到達するかに影響する。
</li>
	<li>
仕様の書者も資源は有限である。
</li>
	<li>
理論的な懸念は、
これらの~groupの下層の必要性~すべてを反映する。
</li>
</ul>
◎
Like all principles, this isn’t absolute. Ease of authoring affects how content reaches users. User agents have to prioritize finite engineering resources, which affects how features reach authors. Specification writers also have finite resources, and theoretical concerns reflect underlying needs of all of these groups.
</div>
<p>
次も見よ
⇒＃
`~webは社会に害をもたらすべきでない＠~ETHICAL-PRINCIPLES#noharm$ ／
`~webは各個人による制御と力を増強しなければならない＠~ETHICAL-PRINCIPLES#control$ ／
`RFC8890$r
◎
See also:
• The web should not cause harm to society
• The web must enhance individuals' control and power
• [RFC8890]
</p>

		</section>
		<section id="safe-to-browse">
<h3 title="It should be safe to visit a web page">1.2. ~web~pageは安全に訪問できるべきである</h3>

<p>
新たな特能を追加するときは、
利用者の期待
— ~web~pageを訪問することは、
一般に安全であること —
を保全するように設計すること。
◎
When adding new features, design them to preserve the user expectation that visiting a web page is generally safe.
</p>

<p>
~Webは、
その~hyperlinkされた構造に因んで命名された。
~webが活発であり続けるためには、
利用者が次を期待-可能になる必要がある
⇒
所与の どの~linkに対しても、
それをただ訪問しただけでは，［
利用者の~computer~security／
利用者の`~privacy＠~ETHICAL-PRINCIPLES#privacy$の本質的な側面
］に対する含意は無い。
◎
The Web is named for its hyperlinked structure. In order for the web to remain vibrant, users need to be able to expect that merely visiting any given link won’t have implications for the security of their computer, or for any essential aspects of their privacy.
</p>

<p>
例えば、
ある~APIが，どの~web~siteにも
`支援技術の利用を検出する＠#do-not-expose-use-of-assistive-tech$ことを許容すると、［
どの~web~pageも，この私的な情報を検出し得る
］ようになるので，これらの技術の利用者は［
未知な~web~pageを訪問するのは安全でない
］と感じるようになる。
◎
For example, an API which allows any website to detect the use of assistive technologies may make users of these technologies feel unsafe visiting unknown web pages, since any web page may detect this private information.
</p>

<p>
利用者が安全性に現実的な期待を持てるならば、
彼らは［
~Webに基づく技術, 他の技術
］どちらにするか，~~情報を得た下で裁定を下せるようになる。
例えば，利用者は、
~appを~installするより，~webに基づく食品注文~pageを利用する方を選ぶであろう
— ~native~appを~installするのは、
~web~pageを訪問するより~riskが高いので。
◎
If users have a realistic expectation of safety, they can make informed decisions between Web-based technologies and other technologies. For example, users may choose to use a web-based food ordering page, rather than installing an app, since installing a native app is riskier than visiting a web page.
</p>

<p>
~web上の安全性の現実が利用者の期待に合致する方へ必ず向かうよう作業するため、
新たな特能を追加するときは，相補的な~approachをとれる：
◎
To work towards making sure the reality of safety on the web matches users' expectations, we can take complementary approaches when adding new features:
</p>
<ul>
	<li>
利用者は~UIを通して~Webを利用する
— ~UIは、［
利用者が期待するもの（および，しないもの）は何であるべきか
］が より明瞭になるよう，改善できる。
◎
We can improve the user interfaces through which the Web is used to make it clearer what users of the Web should (and should not) expect;
</li>
	<li>
~Webの技術的な土台は、
~privacyに関する利用者の期待に合致するよう，変更できる。
◎
We can change the technical foundations of the Web so that they match user expectations of privacy;
</li>
	<li>
期待が もっと高かったなら，利用者にとって より良くなる事例を考慮できる。
そのような事例では、
技術的な［
土台, 期待
］どちらも変更しようと試行できる。
◎
We can consider the cases where users would be better off if expectations were higher, and in those cases try to change both technical foundations and expectations.
</li>
</ul>

<p>
新たな特能が安全性の~riskを導入する場合でも、
それが［
利用者にとって、
同じ~taskを~web~page上で遂行する方が，
~native~appを~installするより安全になる
］ことを許容するならば，
利用者の安全性は総じて改善され得る。
しかしながら，この便益は、［
~web~pageの安全性に適理な期待を有している利用者たち
］の共通な目標と比較検討される必要がある。
◎
A new feature which introduces safety risks may still improve user safety overall, if it allows users to perform a task more safely on a web page than it would be for them to install a native app to do the same thing. However, this benefit needs to be weighed against the common goal of users having a reasonable expectation of safety on web pages.
</p>

<p>
次も見よ
⇒
`~securityと~privacyに関する自己-考査＠~SECQ$cite
◎
See also:
• Security and Privacy Self-Review
</p>

		</section>
		<section id="trusted-ui">
<h3 title="Trusted user interface should be trustworthy">1.3. 信用-済み~UIは信用に価するべきである</h3>

<p>
新たな特能が信用-済み~UIに影響iするかどうかを考慮すること。
◎
Consider whether new features impact trusted user interfaces.
</p>

<p>
利用者は、［
~address~bar／~security指示子／許可~prompt
］などの信用-済み~UIに依存して，自身が誰とどうヤリトリしているかを理解する。
これらの信用-済み~UIは、
それらが供する情報が［
本物であって，当の~web~siteにより［
偽装されていない／乗取られていない
］こと
］を利用者が［
信用する, `検証yする＠~ETHICAL-PRINCIPLES#verify$
］ことを可能化するような仕方で，設計-可能でなければナラナイ。
◎
Users depend on trusted user interfaces such as the address bar, security indicators and permission prompts, to understand who they are interacting with and how. These trusted user interfaces must be able to be designed in a way that enables users to trust and verify that the information they provide is genuine, and hasn’t been spoofed or hijacked by the website.
</p>

<p>
新たな特能が，信用-済み~UIを真似ることを信用-済みでない~UIに許容する場合、
利用者にとって，どの情報が信用に価するか理解するのは より困難になる。
◎
If a new feature allows untrusted user interfaces to resemble trusted user interfaces, this makes it more difficult for users to understand what information is trustworthy.
</p>

<div class="example">
例えば，~JSの
`alert()＠~HTMLGAPI#dom-window-alert-noargs$c
は、［
~browserの一部を成す様な見かけの~modal~dialog
］を示すことを~pageに許容する。
これは、
詐欺~web~siteの中へ訪問するよう利用者を騙そうと試みるために利用されることが多い。
この特能が今日に提案されたなら、
おそらく続行されなかったであろう。
◎
For example, JavaScript alert() allows a page to show a modal dialog which looks like part of the browser. This is often used to attempt to trick users into visiting scam websites. If this feature was proposed today, it would probably not proceed.
</div>

		</section>
		<section id="consent">
<h3 title="Ask users for meaningful consent">1.4. 有意義な同意を利用者に依頼すること</h3>

<p>
有用な特能が利用者に害を及ぼす能性がある場合、
その特能の利用に対する`有意義な同意＠~ETHICAL-PRINCIPLES#control$emを利用者から得ること,
および同意を利用者が効果的に拒否できるようにすること。
◎
If a useful feature has the potential to cause harm to users, make sure that the user can give meaningful consent for that feature to be used, and that they can refuse consent effectively.
</p>

<p>
利用者から`有意義な同意^emを得るためには、
利用者にとって，次が可能にならなければナラナイ：
◎
In order to give meaningful consent, the user must:
</p>
<ul>
	<li>
何を~web~pageに許可する（しない）のか`理解する^strong。
◎
understand what permission they may choose whether to grant the web page
</li>
	<li>
その許可を［
是認する／拒否する
］ことを`効果的^strongに選ぶ。
◎
be able to choose to give or refuse that permission effectively.
</li>
</ul>

<p>
ある特能が利用者からの同意を要求するほど十分に強力であるが，
典型的な利用者に何を同意しているのか説明するのは不可能な場合、
それは，当の特能の設計を考慮し直す必要があろう兆候である。
◎
If a feature is powerful enough to require user consent, but it’s impossible to explain to a typical user what they are consenting to, that’s a signal that you may need to reconsider the design of the feature.
</p>

<p>
ある許可~promptが示され，利用者が許可を是認しなかった場合、
~web~pageは，利用者が同意を拒否したと信じたものを行えるようになるべきでない。
◎
If a permission prompt is shown, and the user doesn’t grant permission, the Web page should not be able to do anything that the user believes they have refused consent for.
</p>

<p>
同意を依頼することにより，~web~pageが何の能力を［
有するか／有さないか
］を利用者に伝えられれば、
利用者にとって`~webは安全である＠#safe-to-browse$確証は高まる。
しかしながら，新たな特能による`利用者の便益＠#priority-of-constituencies$は、
利用者に対する追加的な負担
— 各~特能に対し，~web~pageから要請される度に許可を是認するかどうか裁定する —
を正当化しなければナラナイ。
◎
By asking for consent, we can inform the user of what capabilities the web page does or doesn’t have, reinforcing their confidence that the web is safe. However, the user benefit of a new feature must justify the additional burden on users to decide whether to grant permission for each feature whenever it’s requested by a Web page.
</p>

<div class="example">
例えば，
`Geolocation API＠~GEOLOCATION$cite は、
利用者の所在に対する~accessを是認する。
これは，地図~appの様な一部の文脈において利用者の助けになり得るが、
他の文脈においては，一部の利用者にとっては
— とりわけ利用者の知識を伴わずに利用される場合 —
危険にもなり得る。
利用者が［
ある~web~pageが利用者の所在を利用してもよいかどうか
］を裁定できるよう，［
所在への~accessを是認するかどうか，利用者に依頼する許可~prompt
］が示されるべきである。
利用者が許可を拒否した場合、
所在~情報は~web~pageに可用にならない。
◎
For example, the Geolocation API grants access to a user’s location. This can help users in some contexts, like a mapping application, but may be dangerous to some users in other contexts - especially if used without the user’s knowledge. So that the user may decide whether their location may be used by a Web page, a permission prompt should be shown to the user asking whether to grant location access. If the user refuses permission, no location information is available to the Web page.
</div>

<p>
次も見よ
⇒＃
`§ ~webは、~secureでなければならず，人々の~privacyを尊重しなければならない＠~ETHICAL-PRINCIPLES#privacy$
◎
See also:
• Security and privacy are essential
</p>

		</section>
		<section id="devices-platforms">
<h3 title="Support the full range of devices and platforms (Media Independence)">1.5. 全部的な範囲の装置と~platformを~supportすること（媒体からの独立性）</h3>

<p>
~web上の特能は、
アリな限り`多くの異なる＠~ETHICAL-PRINCIPLES#multi$［
入力~装置／出力~装置／~screen~size／対話~mode／~platform／媒体
］にまたがって働くことを確保すること。
◎
As much as possible, ensure that features on the web work across different input and output [devices, screen sizes, interaction modes, platforms, and media] (https://www.w3.org/2001/tag/doc/ethical-web-principles/#multi).
</p>

<p>
~Webの主な価値の一つは、
極めて柔軟なことにある：
ある~web~pageは、［
多様な消費者~計算機で様々な~sizeの~screenで視られる／
印刷される媒体を生成するために利用される／
数多くの異なる仕方でヤリトリされる
］こともある。
新たな特能は、
~web~platformの`既存の柔軟性＠~ETHICAL-PRINCIPLES#render$に合致するべきである。
◎
One of the main values of the Web is that it’s extremely flexible: a Web page may be viewed on virtually any consumer computing device at a very wide range of screen sizes, may be used to generate printed media, and may be interacted with in a large number of different ways. New features should match the existing flexibility of the web platform.
</p>

<div class="note">

<p>注記：
これは、［
一部の文脈では働かない特能を除外するべきである
］ことは含意しない。
例えば
⇒＃
~hyperlinkは、紙に印刷されたときは訪問し得ない。
`click^et ~eventは、~touch入力~装置により~pointerが同じ~gestureで位置され, ~clickされる所（ “~tap” ）では，完璧には翻訳されない。
◎
This doesn’t imply that features which don’t work in every possible context should be excluded. For example, hyperlinks can’t be visited when printed on paper, and the click event doesn’t translate perfectly to touch input devices where positioning and clicking the pointer occur in the same gesture (a "tap").
</p>

<p>
それでも，当の特能は、
多様な文脈にまたがって働くことに加え，その元の意図を~supportしない装置に順応できる
— 例えば，ある~mobile装置~上の~tapは、
~fallbackとして `click^et ~eventを発火することになる。
◎
These features still work across a wide variety of contexts, and can be adapted to devices that don’t support their original intent - for example, a tap on a mobile device will fire a click event as a fallback.
</p>
</div>

<p>
特能はまた、［
それを利用する最も容易な仕方は，柔軟性を保守する
］ように設計されるべきである。
◎
Features should also be designed so that the easiest way to use them maintains flexibility.
</p>

<div class="example">
<p>
~CSSの［
`塊~layout＠~CSSDISP#block-layout$／
`格子~layout＠~CSSGRID#grid-layout$／
`~flex~layout＠~CSSFLEX#flex-layout$
【！`display$p に対する `block^v／`flex^v／`grid^v 】
］~modelは、
既定では，内容を可用な空間の中で重合しないよう配置する
— それにより，様々な~screen~sizeにまたがって働くことに加え、
~textを~overflowさせずに自前の［
~font, ~font~size
］を選ぶことを利用者に許容する。
◎
The 'display: block', 'display: flex', and 'display: grid' layout models in CSS all default to placing content within the available space and without overlap, so that it works across screen sizes, and allows users to choose their own font and font size without causing text to overflow.
</div>

<p>
特能は、
ときには，一部の［
実装／~platform
］では まだ可用でないこともある
— 他では働くにもかかわらず。
そのような事例では、
当の特能は，［
上品に失敗する, あるいは~polyfillするための~codeがアリになる
］ように設計されるベキである。
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$
を見よ。
◎
Sometimes features aren’t yet available on some implementations or platforms despite working on others. In these cases, features should be designed such that it is possible for code to gracefully fail or be polyfilled. See § 2.5 New features should be detectable.
</p>

		</section>
		<section id="leave-the-web-better">
<h3 title="Leave the web better than you found it">1.6. ~webをより良いものにして残すこと</h3>

<p>
~web~platformに新たな能力を追加するときは、
~platformが総じて改善される仕方で行うこと
— 例えば、［
~security／~privacy
］の脆弱性や~accessibilityの特性。
~platformの一部に存在する欠陥を，新たな能力の中に［
追加する／拡張する
］ための許諾として利用してはナラナイ
— そうすると，~platformの品質は総じて劣化するので。
新たな~web能力は、
アリな所では，~platformの品質が総じて改善されるように築くこと。
◎
As you add new capabilities to the web platform, do so in a way that improves the overall platform, for example its security or privacy vulnerabilities, or accessibility characteristics. The existence of a defect in one part of the platform must not be used as a license for adding or extending such defect into new capabilities and thereby further decreasing the overall platform quality. Where possible, build new web capabilities that improve the overall platform quality.
</p>

<p>
~web~platformの各部は、
独立に発展する。
ある種の~web技術に今在る課題は、
後続な~~版において修正され得る。
これらの課題を重ねて持ち込むと、
修正するのは，さらに困難になる。
この原則を固守することで、
~platformの品質は，時を経るに伴い総じて改善されるようになる。
◎
Parts of the web platform evolve independently. Issues that are present with a certain web technology now may be fixed in a subsequent iteration. Duplicating these issues makes fixing them more difficult. By adhering to this principle we can make sure overall platform quality improves over time.
</p>

		</section>
	</section>
	<section id="api-across-languages">
<h2 title="API Design Across Languages">2. 言語にまたがる~API設計</h2>

		<section id="simplicity">
<h3 title="Prefer simple solutions">2.1. 単純な解決策を選好すること</h3>

<p>
取組もうと意図する`利用者の必要性＠#priority-of-constituencies$に対し，
単純な解決策を探す努力を怠らないこと。
◎
Look hard for simple solutions to the user needs you intend to address.
</p>

<p>
一般に、
複階的な解決策より単純な解決策の方が良い
— それを見出す方が難しいこともあろうが。
特能は単純な方が
⇒＃
~UAにとって実装して~testするのは容易になる／
相互運用可能になる見込みが高い／
作者が理解するのは容易になる
◎
Simple solutions are generally better than complex solutions, although they may be harder to find. Simpler features are easier for user agents to implement and test, more likely to be interoperable, and easier for authors to understand.＼
</p>

<p>
とりわけ、
当の特能を［
最も共通な利用事例を容易に成遂げる
］よう設計することが重要である。
◎
It is especially important to design your feature so that the most common use cases are easy to accomplish.
</p>

<p>
`利用者の必要性＠#priority-of-constituencies$をきちんと定義すること
— そうすれば、
視野が次第に逸れていくこと（ `scope creep^en ）は避けれるようになる。
また、
当の~APIが，すべての利用者の必要性を実際に満たすようにすること。
もちろん［
複階的／稀
］な利用事例も解くに価するが、
それらの解決策は利用するのが複雑なこともある。
`Alan Kay^en 氏が言ったとおり，
“`simple things should be simple, complex things should be possible^en”
（ “単純なものは単純にしつつ，複階的なものもアリになるべきである” ）。
◎
Make sure that your user needs are well-defined. This allows you to avoid scope creep, and make sure that your API does actually meet the needs of all users. Of course, complex or rare use cases are also worth solving, though their solutions may be more complicated to use. As Alan Kay said, "simple things should be simple, complex things should be possible."
</p>

<p>
共通な事例は単純なことが多いが、
共通度と複階度は，常に相関するとは限らないことに注意。
◎
Do note however that while common cases are often simple, commonality and complexity are not always correlated.
</p>

<div class="example">
~XSS攻撃を防止するよう~HTMLを無毒化することは、
複階的な処理nであり，広範な~securityの知識が要求されるが、
`Sanitizer API＠~HTMLsanitizer$cite
は，この共通な利用事例~用の近道を供する。
それはまた、
より環境設定を伴いつつ，より単純な型の~filter法も許可する。
◎
Sanitizing HTML to prevent XSS attacks is a complex process that requires extensive security knowledge, however the Sanitizer API provides a shortcut for this common use case. It also permits simpler types of filtering, but with more configuration.
</div>

<p>
次も見よ
⇒
`LEAST-POWER$r
◎
See also:
• [LEAST-POWER]
</p>

		</section>
		<section id="high-level-low-level">
<h3 title="Consider tradeoffs between high level and low level APIs">2.2. 高~levelな~APIと低~levelな~APIの~tradeoffを考慮すること</h3>

<p>
高~levelな~APIは、
`利用者に利する＠#priority-of-constituencies$ために
— ［
~accessibility／~privacy／利便性
］を確保するためなど —
様々な仕方で介入する能を より多く~UAに許容する。
◎
High-level APIs allow user agents more ability to intervene in various ways on behalf of the user, such as to ensure accessibility, privacy, or usability.
</p>

<div class="example" id="font-enumeration">
~font~picker（高~levelな~API）は、
`Font Enumeration API^cite（低~levelな~API）に対し，
`~TAGにより推奨された＠https://github.com/w3ctag/design-reviews/issues/399$
— それは、［
利用者~privacyを保全しながら，大部分の利用事例に取組む
］こと加え，［
`Font Enumeration API^cite に付随する，一般的な指紋収集の懸念
］は無いので。
~nativeな~font~pickerには、
組込みの~accessibilityもついて来るので，末端-利用者にとっての一貫性を供する。
◎
A font picker (high level API) was recommended by the TAG over a Font Enumeration API (low level API) as it addresses the bulk of use cases, while preserving user privacy, as it is free from the the fingerprinting concerns that accompany a general Font Enumeration API. A native font picker also comes with accessibility built-in, and provides consistency for end users.
</div>

<p>
低~levelな~APIには、［
高~levelな~APIが，時を経て得られた用法~patternから組織的に形作れる
］よう，作者に実験n用の部屋を与えるゆとりがある。
それはまた、［
より高~levelな~APIでは必要十分でない，目の前の利用事例
］のための逃げ道を供する。
◎
Low-level APIs afford authors room for experimentation so that high level APIs can organically emerge from usage patterns over time. They also provide an escape hatch when the higher-level API is not adequate for the use case at hand.
</p>

<p>
より低~levelな構築部品は、
~Web~APIとして公開できないこともある。
アリな理由として，［
利用者の~securityと~privacyを保全する／
~Web~APIを特定の~hardware実装に束ねるのを避ける
］ことが挙げられる。
しかしながら，高~levelな~APIは、［
アリなときは，より低~levelな~APIに基づく構築部品の用語
］で設計されるべきである。
これは、［
高~levelな~APIは，どうなる必要があるか
］に関する裁定を手引きするものになろう。
◎
Lower level building blocks cannot always be exposed as Web APIs. A few possible reasons for this are to preserve the user’s security and privacy, or to avoid tying Web APIs to specific hardware implementations. However, high level APIs should be designed in terms of building blocks over lower level APIs whenever possible. This may guide decisions on how high level the API needs to be.
</p>

<p>
きちんと層~化された解決策は、［
その力に比して，利用の難易度がひどく上がることはない
］ことを確保するべきである
— 利用-事例の複階性が少し増すだけで~codeの複階性が大きく増えないよう。
◎
A well-layered solution should ensure continuity of the ease-of-use vs power tradeoff curve and avoid sharp cliffs where a small amount of incremental use case complexity results in a large increase of code complexity.
</p>

		</section>
		<section id="name-thoughtfully">
<h3 title="Name things thoughtfully">2.3. よく考して命名すること</h3>

<p>
【！Name APIs with care.】
~APIをきちんと命名しておけば、
作者が それを正しく利用するのは，ずっと容易になる。
◎
Name APIs with care. Naming APIs well makes it much easier for authors to use them correctly.
</p>

<p>
命名に特有な，より詳細な指導は、
`§ 命名~原則＠#naming-is-hard$を見よ。
◎
See the more detailed Naming principles section for specific guidance on naming.
</p>

		</section>
		<section id="consistency">
<h3 title="Be consistent">2.4. 他所と一貫すること</h3>

<p>
~APIの設計における先例を考慮して，それと一貫するよう努めることは、
良い実施である。
◎
It is good practice to consider precedent in the design of your API and to try to be consistent with it.
</p>

<p>
既存の先例の利便性が拙い場合、
~APIの［
人間工学, 一貫性
］両面は対立することが多い。
一部の事例では，一貫性を破ってでも利便性を改善することがイミを成すが、
その改善は，そうすることを有意に正当化するものであるべきである。
◎
There is often a tension between API ergonomics and consistency, when existing precedent is of poor usability. In some cases it makes sense to break consistency to improve usability, but the improvement should be very significant to justify this.
</p>

<p>
~web~platformは、
時を経て次第に発展してきたので，
相反な複数の競合している先例があることも多い。
どの先例に従うかは、
次を織り込む下で比較検討できる：
◎
Since the web platform has gradually evolved over time, there are often multiple conflicting precedents which are mutually exclusive. You can weigh which precedent to follow by taking into account＼
</p>
<ul>
	<li>
普及度（他がすべて等しいなら，より普及している先例に従う）
◎
prevalence (all else being equal, follow the more popular precedent),＼
</li>
	<li>
人間工学（他がすべて等しいなら，より利用-可能な先例に従う）
◎
API ergonomics (all else being equal, follow the more usable precedent),＼
</li>
	<li>
~APIの齢（他がすべて等しいなら，より新たな先例に従う）
◎
and API age (all else being equal, follow the newer precedent).
</li>
</ul>

<p>
［
`内部~一貫性^em,
`外部~一貫性^em
］も対立することが多い。
前者は，当の~systemの他所すべてとの一貫性であり、
後者は，外の世界の他所すべてとの一貫性である。
それは、
~web~platformにおいては，次に挙げる 3 つの層で顕在化されよう：
◎
There is often a tension between internal and external consistency. Internal consistency is consistency with the rest of the system, whereas external consistency is consistency with the rest of the world. In the web platform, that might materialize in three layers:＼
</p>
<ul>
	<li>
当の~APIが所属する技術（例：~CSS）との一貫性
◎
consistency within the technology the API belongs to (e.g. CSS),＼
</li>
	<li>
~web~platformの他所すべてとの一貫性
◎
consistency with the rest of the web platform,＼
</li>
	<li>
一部の事例
— 当の~APIが［
特定0の特化された外側の領分
］に関係する事例 —
では、
外部な先例との一貫性
◎
and in some cases external precedent, when the API relates to a particular specialized outside domain.＼
</li>
</ul>

<p>
これらの事例では、［
大多数の利用者は，どれに該当するか
］を考慮することが有用になる。
ほとんどの~APIは、
それが ある技術の下で定義されるならば，~target利用者は その技術に馴染みな者たちなので、
その技術との一貫性を支持する方が無難になる。
◎
In those cases, it is useful to consider what the majority of users will be. Since for most APIs the target user is someone who is familiar with the technology they are defined in, err on the side of favoring consistency with that.
</p>

<div class="example">
例として，`~Lab色＠~CSSCOLOR#funcdef-lab$がある。
それは L 成分~用には百分率（ 0% 〜 100% ）を利用する方が，~CSSの他所すべてと一貫するが、
単位が無い数（ 0 〜 100【 0 〜 1 ？】）を利用する方が，色彩科学の他所すべてと一貫する。
論争は幾度となくあったが、
百分率
— すなわち~CSSとの一貫性 —
を支持する方に解決された。
◎
One example is CIE L*a*b* colors: It would be more consistent with the rest of CSS to use percentages for L (0%-100%), but more consistent with the rest of Color Science to use a unitless number (0-100). There was a lot of heated debate, which resolved in favor of percentages, i.e. consistency within CSS.
</div>

<p>
別々な節として，
`§ 一貫するよう命名すること＠#naming-consistency$もある。
◎
There is also a separate section on naming consistency.
</p>

		</section>
		<section id="feature-detect">
<h3 title="New features should be detectable">2.5. 新たな特能は検出-可能になるべきである</h3>

<p>
当の特能が可用でないときも，~web内容が それを上品に取扱えるよう、
可用かどうかを作者が~program的に検出する仕方を供すること。
◎
Provide a way for authors to programmatically detect whether your feature is available, so that web content may gracefully handle the feature not being present.
</p>

<p>
既存の特能は、
いくつかの理由から，~pageにて可用でないこともある。
共通的な理由には、
次の 2 つが挙げられる
⇒＃
まだ実装されていない ／
`~secureな文脈＠#secure-context$内でしか可用でない
◎
An existing feature may not be available on a page for a number of reasons. Two of the more common reasons are because it hasn’t been implemented yet, or because it’s only available in secure contexts.
</p>

<p>
作者にとって［
各~局面を取扱うために異なる~codeを書する必要
］は生じるべきでない。
この仕方により、
作者が一つの局面しか［
知らない／~careしない
］場合でも，~codeは それらすべてを取扱うことになる。
◎
Authors shouldn’t need to write different code to handle each scenario. That way, even if an author only knows or cares about one scenario, the code will handle all of them.
</p>

<p class="note">注記：
ある特能が［
可用ではあるが、
要求される装置が無いため，その利用は実現可能でない
］ときは、
特能が可用であることを公開することに加え，
装置は可用でないことも検出する別々な仕方もある方が良い。
これは、［
装置が可用でないとき, 特能が可用でないとき
］の取扱いを違えることを作者に許容する
— 例えば、
装置を［
前者のときは接続する／後者のときは可能化する
］よう利用者に示唆するなど。
◎
When a feature is available but isn’t feasible to use because a required device isn’t present, it’s better to expose that the feature is available and have a separate way to detect that the device isn’t. This allows authors to handle a device not being available differently from the feature not being available, for example by suggesting the user connect or enable the device.
</p>

<p>
`§ 装置を［選定する／列挙する］~APIを公開するときの注意点＠#device-enumeration$
を見よ。
◎
See § 9.2 Use care when exposing APIs for selecting or enumerating devices.
</p>

<p>
特能は、
常に，作者が~JSから検出-可能にするべきである。
一部の事例では、
特能は，それが利用される言語で検出-可能になるべきである
（~CSSにおける `supports$at など）。
◎
Authors should always be able to detect a feature from JavaScript, and in some cases the feature should also be detectable in the language where it’s used (such as @supports in CSS).
</p>

<p>
一部の事例では、
特能~検出を許容するのは`適切でないこともある^strong。
特能が検出-可能になるべきかどうかは、
当の特能に対する
`利用者の必要性＠#priority-of-constituencies$
に基づく
— 特能~検出が可用であること自体が［
利用者の必要／設計~原則
］に抵触する場合、
特能~検出は~supportされるべきでない。
◎
In some cases, it may not be appropriate to allow feature detection. Whether the feature should be detectable or not should be based on the user need for the feature: if there is a user need or design principle which would fail if feature detection were available for the feature, then you should not support feature detection.
</p>

<p>
また，ある特能が一般に開発者に公開されない場合、
特能~検出を~supportするのは適切にならない。
例えば，私的~閲覧~modeは、
~web仕様において認識される概念であるが，作者には公開されない。
私的~閲覧~modeに対する特能~検出は、
それ自体が利用者の必要性に反するので，~supportされてはナラナイ。
◎
Also, if a feature is generally not exposed to developers, it is not appropriate to support feature detection. For example, private browsing mode is a concept which is recognised in web specifications, but not exposed to authors. For private browsing mode to support the user’s needs, it must not be feature detected.
</p>

<p>
次も見よ
⇒＃
`§ 私的~閲覧~mode下にあることを露呈しないこと＠#do-not-expose-use-of-private-browsing-mode$／
`§ 支援技術が利用-中にあることを露呈しないこと＠#do-not-expose-use-of-assistive-tech$／
`§ 新たな特能は~secureな文脈に制限することを考慮すること＠#secure-context$
◎
See also:
• § 2.7 Don’t reveal that private browsing mode is engaged
• § 2.9 Don’t reveal that assistive technologies are being used
• § 2.6 Consider limiting new features to secure contexts
</p>

		</section>
		<section id="secure-context">
<h3 title="Consider limiting new features to secure contexts">2.6. 新たな特能は~secureな文脈に制限することを考慮すること</h3>

<p>
当の特能が［
~secureな文脈にしか無い［
認証／完全性／機密性
］を伴わない限り，利用者に~riskを突きつける
］ことになる場合、
常に~secureな文脈に制限すること。
◎
Always limit your feature to secure contexts if it would pose a risk to the user without the authentication, integrity, or confidentiality that’s present only in secure contexts.
</p>

<div class="example">
~secureな文脈に制限されるべき特能の例として、
`Geolocation＠~TR/geolocation-API/$cite（ “~~地理所在” ）
がある
— 利用者の所在を~secureでない仕方で伝送することには、
利用者の~privacyに対する~riskがあるので。
◎
One example of a feature that should be limited to secure contexts is Geolocation, since it would be a risk to users' privacy to transmit their location in an insecure way.
</div>

<p>
他の特能に対しては、
~~過去および~~現在の~TAG~memberたちは，一般的な助言について総意には達しなかった：
◎
For other features, TAG members past and present haven’t reached consensus on general advice.＼
</p>
<ul>
	<li>
一部の者は、
新たな特能（既存の特能に対する追加~以外の特能）は，［
すべて，~secureな文脈に制限されるべきである
］と予見する。
これは，~HTTPSの利用を促すことになり、
一般に，利用者にとって より~secureになる助けになる。
◎
Some believe that all new features (other than features which are additions to existing features) should be limited to secure contexts. This would help encourage the use of HTTPS, helping users be more secure in general.
</li>
	<li>
他の者は、
特能は，［［
~security／~privacy
］に既知な影響iがある場合に限り，~secureな文脈に制限されるべきである
］と予見する。
これは、［［
利用者の［
~security／~privacy
］に影響iしない新たな特能
］の利点を採るような~web~page
］を作成するときの敷居を低くする。
◎
Others believe that features should only be limited to secure contexts if they have a known security or privacy impact. This lowers the barrier to entry for creating web pages that take advantage of new features which don’t impact user security or privacy.
</li>
</ul>

<div class="note">

<p>注記：
仕様~策定者は、
`~Web~IDL＠~WEBIDL$
で定義される ほとんどの特能を~secureな文脈に制限できる
— ［
~interface／名前空間／それらの各~member（~methodや属性など）
］に `SecureContext$xA 拡張d属性を利用することにより。
◎
Specification authors can limit most features defined in Web IDL, to secure contexts by using the [SecureContext] extended attribute on interfaces, namespaces, or their members (such as methods and attributes).
</p>

<p>
しかしながら，一部の~APIにおいては、
~secureな文脈への制限は，当の仕様~内の規範的な注釈文だけで定義されるべきである
（例： ~eventの配送-法
【当の~APIにより誘発される，ある種の~eventは、~secureな文脈に限り発火するなど（~eventを発火する仕組み~自体は、一律に~secureな文脈に制限し得ないので）】
）。
この事例に該当する場合、
将来の~API開発者にとって この~processを もっと容易にするため，
`SecureContext$xA に類似な仕組みを追加する余地もあるかどうかを考慮すること。
◎
However, for some types of API (e.g., dispatching an event), limitation to secure contexts should just be defined in normative prose in the specification. If this is the case, consider whether there might be scope for adding a similar mechanism to [SecureContext] to make this process easier for future API developers.
</p>
</div>

<div class="note">

<p>注記：
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$
にて述べたとおり，［
ある特能が可用かどうかを~program的に検出する仕方
］を供するべきである
— 当の文脈が~secureでない故に当の特能が可用でない事例も含めて。
◎
As described in § 2.5 New features should be detectable, you should provide a way to programmatically detect whether a feature is available, including cases where the feature is unavailable because the context isn’t secure.
</p>

<p>
しかしながら、［
何らかの理由で、
特能が無いとき，~codeがそれを上品に取扱う仕方が無い
］場合、
当の特能を~secureな文脈に制限すると，［
~secureな文脈, ~secureでない文脈
］どちらにも利用され得る~code（~libraryなど）にとって問題の原因になるかもしれない。
◎
However, if, for some reason there is no way for code to gracefully handle the feature not being present, limiting the feature to secure contexts might cause problems for code (such as libraries) that may be used in either secure or non-secure contexts.
</p>
</div>

		</section>
		<section id="do-not-expose-use-of-private-browsing-mode">
<h3 title="Don’t reveal that private browsing mode is engaged">2.7. 私的~閲覧~mode下にあることを露呈しないこと</h3>

<p>
当の特能は、
私的~閲覧~modeを検出する仕方を作者に与えないこと。
◎
Make sure that your feature doesn’t give authors a way to detect private browsing mode.
</p>

<p>
一部の人々は、
`私的~閲覧~mode＠https://www.w3.org/2001/tag/doc/private-browsing-modes/$
を利用して，自前の個人的な安全性を保護する。
このことから，誰かが私的~閲覧~modeを利用している事実は、
その者についての
`敏感な情報＠~SECQ#sensitive-data$になり得る。
この情報は、
その者に力を持つ他者
（雇用者, 親権者, ~partner, `国家権力＠~ETHICAL-PRINCIPLES#expression$（ `state actor^en ）
など）
が制御している~web~siteに露呈された場合には，
`人々を害する＠~ETHICAL-PRINCIPLES#noharm$こともある。
◎
Some people use private browsing mode to protect their own personal safety. Because of this, the fact that someone is using private browsing mode may be sensitive information about them. This information may harm people if it is revealed to a web site controlled by others who have power over them (such as employers, parents, partners, or state actors).
</p>

<p>
そのような危険性がある下では、
~web~siteは，私的~閲覧~mode下にあることを検出-可能になるべきでない。
◎
Given such dangers, websites should not be able to detect that private browsing mode is engaged.
</p>

<div class="example">
`IndexedDB＠~INDEXEDDB$cite
を~supportする~UAは、
私的~閲覧~modeにおいて，それを不能化するべきでない
— そうすると、
私的~閲覧~mode下にあることを露呈することになるので。
◎
User Agents which support IndexedDB should not disable it in private browsing mode, because that would reveal that private browsing mode is engaged
</div>

<div class="example">
<p>
`支払い要請~API＠https://w3c.github.io/payment-request/$cite
（ `Payment Request API^en ）
の
`show()＠https://w3c.github.io/payment-request/#dom-paymentrequest-show$c
~methodは、
~callされたとき，次を~UAに許容する
⇒
<q cite="https://w3c.github.io/payment-request/#show-method">［
利用者が即時に`支払い要請を中止した＠https://w3c.github.io/payment-request/#dfn-user-aborts-the-payment-request$
］かのように動作する
</q>
◎
The Payment Request API's show() method, when called, allows User Agents to act as if the user had immediately aborted the payment request.
</p>

<p>
これは，私的~閲覧~modeにおいては、
~UAがその~mode下にあることを露呈することなく，
支払い要請を自動的に中止することを可能化する
（したがって、［
出荷先~addressや請求先~address
］など，利用者の`敏感な情報＠~SECQ#sensitive-data$を保護する）。
◎
This enables User Agents to automatically abort payment requests in private browsing mode (thus protecting sensitive information such as the user’s shipping or billing address) without revealing that private browsing mode is engaged.
</p>
</div>

<p>
次も見よ
⇒＃
`§ ~webは、~secureでなければならず，人々の~privacyを尊重しなければならない＠~ETHICAL-PRINCIPLES#privacy$／
`§ 当の特能は、下層の~platformについての情報を生成元に公開するか？＠~SECQ#underlying-platform-data$／
`§ 私的~閲覧~modeにおいて，~APIがどう挙動するべきか考慮すること＠#private-browsing-mode$
◎
See also:
• Security and privacy are essential
• What data does this specification expose to an origin?
• § 2.8 Consider how your API should behave in private browsing mode
</p>

		</section>
		<section id="private-browsing-mode">
<h3 title="Consider how your API should behave in private browsing mode">2.8. 私的~閲覧~modeにおいて，~APIがどう挙動するべきか考慮すること</h3>

<p>
必要yなら、
当の~APIの挙動は，私的~閲覧~modeにおいて どう異なるべきかを指定すること。
◎
If necessary, specify how your API should behave differently in private browsing mode.
</p>

<p>
例えば，当の~APIが［
一人の利用者による［
私的~閲覧~mode内での活動, その外での活動
］を相関することを誰かに許容することになる情報
］を露呈することになる場合、
アリな`軽減策＠~SECQ#mitigations$を考慮すること
— 次に挙げるものなど：
◎
For example, if your API would reveal information that would allow someone to correlate a single user’s activity both in and out of private browsing mode, consider possible mitigations such as＼
</p>
<ul>
	<li>
【相関を妨げるような】~noiseを導入する。
◎
introducing noise,＼
</li>
	<li>
許可~promptを利用して，当の利用者に加的な情報を与える
— 利用者が，この追跡に有意義に同意する助けになるよう
（`§ 有意義な同意を利用者に依頼すること＠#consent$を見よ）。
◎
or using permission prompts to give the user extra information to help them meaningfully consent to this tracking (see § 1.4 Ask users for meaningful consent).
</li>
</ul>

<p>
私的~閲覧~modeは、［
利用者による私的~閲覧の形跡を利用者の機器に残さない
］ように~webを閲覧することを，利用者に可能化する。
したがって，
~client側~storageを供する~APIは、［
私的~閲覧~mode下にある間に格納された~data
］を その~modeから離れた後にも持続するべきでない。
これは、［
検出-可能な~APIにおける いかなる相違も，当の~siteに露呈しない
］ように行えるし，行うべきである。
◎
Private browsing modes enable users to browse the web without leaving any trace of their private browsing on their device. Therefore, APIs which provide client-side storage should not persist data stored while private browsing mode is engaged after it’s disengaged. This can and should be done without revealing any detectable API differences to the site.
</p>

<div class="example">
<p>
`localStorage＠~WEBSTORAGE#dom-localstorage$c
を~supportする~UAは、
私的~閲覧~mode下にある間に，
~storage区画に為された変更を持続するべきでない。
◎
User Agents which support localStorage should not persist storage area changes made while private browsing mode is engaged.
</p>

<p>
~UAに 同じ~site用の 2 つの閲覧~session
— 私的~閲覧~mode内の~session, もう一方は そうでない~session —
が同時にある場合、
一方の~sessionにおいて~storage区画に為される変更は，他方の~sessionに露呈されるべきでない
（ `storage＠~HTMLindex#event-storage$et ~eventは、
他方の~sessionの `Window$I ~objに向けて発火されるべきでない）。
◎
If the User Agent has two simultaneous sessions with a site, one in private browsing mode and one not, storage area changes made in the private browsing mode session should not be revealed to the other browsing session, and vice versa. (The storage event should not be fired at the other session’s window object.)
</p>
</div>

<p>
次も見よ
⇒＃
`§ 私的~閲覧~mode下にあることを露呈しないこと＠#do-not-expose-use-of-private-browsing-mode$／
`§ 当の特能は、複数の閲覧~sessionにわたって持続する新たな状態を生成元~用に導入するか？＠~SECQ#persistent-origin-specific-state$／
`§ 当の特能は、~browserの私的~閲覧~modeの文脈においてどう働くか？＠~SECQ#private-browsing$
◎
See also:
• § 2.7 Don’t reveal that private browsing mode is engaged
• Does this specification introduce new state for an origin that persists across browsing sessions?
• Security and privacy self review: Private Browsing
</p>

		</section>
		<section id="do-not-expose-use-of-assistive-tech">
<h3 title="Don’t reveal that assistive technologies are being used">2.9. 支援技術が利用-中にあることを露呈しないこと</h3>

<p>
当の~APIは、
利用者が支援技術を利用していることを［
利用者の同意を経ることなく検出する仕方
］を作者に供さないこと。
◎
Make sure that your API doesn’t provide a way for authors to detect that a user is using assistive technology without the user’s consent.
</p>

<p>
`~web~platformは障害を伴う人々からも~access可能にしなければナラナイ＠~ETHICAL-PRINCIPLES#allpeople$。
ある~siteが利用者が支援技術を利用していることを検出できた場合、
その~siteは，自身が供する~serviceへの利用者による~accessを［
否認-／制約-
］し得ることになる。
◎
The web platform must be accessible to people with disabilities. If a site can detect that a user is using an assistive technology, that site can deny or restrict the user’s access to the services it provides.
</p>

<p>
支援技術を用立てる人々は、
`社会の脆弱な~member＠~ETHICAL-PRINCIPLES#noharm$
であることが多い。
彼らによる支援技術の利用は、
彼らについての`敏感な情報＠~SECQ#sensitive-data$である。
ある~APIが，この情報への~accessを`利用者の同意＠#consent$を経ることなく供する場合、
この敏感な情報は，彼らを害そうと望むかもしれない他者
（`国家権力＠~ETHICAL-PRINCIPLES#expression$も含む）
に露呈され得る。
◎
People who make use of assistive technologies are often vulnerable members of society; their use of assistive technologies is sensitive information about them. If an API provides access to this information without the user’s consent, this sensitive information may be revealed to others (including state actors) who may wish them harm.
</p>

<p>
ときには、
人々は［
支援技術の利用者~用に利用者~体験を改善しようと目指す特能
］を提案するが，それは［
副作用として利用者の支援技術の利用を露呈する
］ことになろう。
これらには，きちんとした意図nがあるが、
`§ ~web~pageは安全に訪問できるべきである＠#safe-to-browse$
に違反するので，代替な解決策を見出さなければナラナイ。
◎
Sometimes people propose features which aim to improve the user experience for users of assistive technology, but which would reveal the user’s use of assistive technology as a side effect. While these are well intentioned, they violate § 1.2 It should be safe to visit a web page, so alternative solutions must be found.
</p>

<div class="example">
<p>
`~accessibility~obj~model＠https://wicg.github.io/aom/$（略称 ~AOM）は、［
`支援技術の利用が露呈される＠https://github.com/WICG/aom/issues/81$とき発火される~event
］たちが成す集合を定義するために利用されていた。
◎
The Accessibility Object Model (AOM) used to define a set of events which, when fired, revealed the use of assistive technology.
</p>

<p>
その後，~AOMは、
これらの~eventを除去して，［
支援技術の利用を露呈しない合成な~DOM~event
］で`それらを置換した＠https://github.com/WICG/aom/blob/gh-pages/explainer.md#user-action-events-from-assistive-technology$。
◎
AOM has since removed these events and replaced them with synthetic DOM events which don’t reveal the use of assistive technology.
</p>
</div>

<p>
次も見よ
⇒＃
`~Web技術~accessibility指針＠https://w3c.github.io/apa/fast/$
`§ ~webは、~secureでなければならず，人々の~privacyを尊重しなければならない＠~ETHICAL-PRINCIPLES#privacy$／
`§ 当の特能は、下層の~platformについての情報を生成元に公開するか？＠~SECQ#underlying-platform-data$
◎
See also:
• Web Technology Accessibility Guidelines
• Security and privacy are essential
• What data does this specification expose to an origin?
</p>

		</section>
		<section id="require-user-activation">
<h3 title="Require user activation for powerful APIs">2.10. 強力な~APIには、利用者-作動化を要求すること</h3>

<p>
一部の強力~APIは、
次に挙げる いずれかを行い得る：
◎
Some powerful APIs can＼
</p>
<ul>
	<li>
押付けな~UIを生産する
（例：音声を自動-再生する）
◎
produce intrusive UI (eg. auto-playing audio),＼
</li>
	<li>
利用者~dataを【~web~pageに】公開する
（例：~clipboardとヤリトリする）
◎
expose user data (eg. interacting with the clipboard),＼
</li>
	<li>
利用者に対する明白な指示子を伴わずに背景~活動を遂行する
（例：局所~storageへ~accessする）
◎
perform a background activity without an obvious indicator to the user (eg. accessing local storage),＼
</li>
	<li>
`信用-済み~UI＠#trusted-ui$とヤリトリするよう利用者に~promptする
（例：許可~prompt, 機器~hardware特能）
◎
or prompt the user to interact with trusted UI (eg. permission prompts, device hardware features).＼
</li>
</ul>

<p>
これらの~APIが機能するためには、
利用者の意図nを成す何らかの指示
（`利用者-作動化^strongなど）
を要求するよう設計されるベキである。
これは、
利用者が当の~web~pageに対し意図的にヤリトリしていることを指示する。
◎
These APIs should be designed to require some indication of user intention (such as user activation) in order to function. This indicates that the user is intentionally interacting with the web page in question.
</p>

<p>
利用者-作動化は、
~HTML標準にて，`詳細に定義される＠~HTMLinteraction#tracking-user-activation$。
利用者-作動化が生じる必要があるのは，次のうちどれになるか裁定するときは、
当の~APIによる［
利用者~体験に対する効果，利用者に呈示される~risk
］について考するベキである
⇒＃
総じて一回~限り（`居残な＠~HTMLinteraction#sticky-activation-gated-api$）／
周期的（`一過な＠~HTMLinteraction#transient-activation-gated-api$）／
各~API~callにつき一回（`一過に消費する＠~HTMLinteraction#activation-consuming-api$）
◎
User activation is defined in detail in the HTML standard. You should think about the effect your API has on the user experience, as well as any risks presented to the user, when deciding whether user activation needs to only occur once overall (sticky), periodically (transient) or once per API call (transient consuming).
</p>

<p>
利用者-作動化は、
多くの事例で必要yであるが，
侵害的な挙動から利用者を保護するに`足るとは限らない^em
— `有意義な同意＠#consent$を探求することもまた重要であることに注意。
◎
Note that while user activation is in many cases necessary, it is not always sufficient to protect users from invasive behaviours, and seeking meaningful consent is also important.
</p>

		</section>

		<section id="support-non-fully-active">
<h3 title="Support non-fully active BFCached documents">2.11. 全部的に作動中でない~BF~cacheされた文書を~supportすること</h3>

<p>
アリなら、
当の特能が
~BF~cacheされた【`~BF~cache$に格納された】`全部的に作動中$でない文書において，どう挙動するかを指定すること。
◎
Specify how your feature behaves in non-fully active BFCached (Back/forward cached) documents if possible.
</p>

<p>
当の特能が，次に挙げるいずれかの分類に該当する`何か^strongを行う場合：
◎
If your feature does anything that falls into the following categories:
</p>
<ul>
	<li>
“外側” から文書とヤリトリする
（例：ある文書へ情報を送信する）
◎
Interacts with a document from the "outside" (e.g. sends information to a document)
</li>
	<li>
文書~間での［
ヤリトリ／資源の共有
］をアリにする
（例：~lockを保持する）
◎
Makes cross-document interaction/resource sharing possible (e.g. holding locks)
</li>
	<li>
文書が［
利用者により他所へ~navigateされた／
【利用者が履歴を辿った結果】復旧された
］後に［
`全部的に作動中$でない~BF~cacheされた状態
］に保たれたとき，
当の文書は（破壊される代わりに）~~不正に機能し得る
（例：当の文書~内に保存された状態は、
複数回の~naviにわたらないものと期待されている）
◎
May malfunction when a document is kept in a non-fully active BFCached state (instead of getting destroyed) after the user navigates away from it or gets restored (e.g. expects that a state saved in the document won’t span multiple navigations)
</li>
</ul>

<p>
当の特能が~BF~cacheされた`全部的に作動中$でない文書でどう働くかを［
`~BF~cacheされた文書の~support法＠~BFCACHE$cite
手引きにおける指針
］に従って指定すること。
◎
Specify how your feature works with non-fully active BFCached documents, following the guidelines in the Supporting BFCached Documents guide.
</p>

<p class="note">注記：
文書は、
~BF~cache法に関係しない他の理由で`全部的に作動中$でなくなることもアル
— 当の文書を保持している `iframe$e が切離されたときなど。
この指導は、
`~BF~cache$が孕まれている事例に限られ，
そのような事例には関連しない。
◎
Note: It is possible for a document to become non-fully active for other reasons not related to BFcaching, such as when the iframe holding the document gets detached. This guidance only focuses on the case where BFCache is involved, and not other cases that might cause a document to become non-fully active.
</p>

		</section>
		<section id="third-party-tools">
<h3 title="Prioritize usability over compatibility with third-party tools">2.12. 第三者-主体~toolとの互換性より利便性を優先すること</h3>

<p>
新たな特能を設計するときは、
第三者-主体~tool群との互換性よりも，利便性を首な目標とすること。
◎
Design new features with usability as the primary goal, and compatibility with third-party tooling as a secondary goal.
</p>

<p>
~web~platformは、
幅広い~tool群が成す~ecosystemから，より容易かつ速い開発を手助けする便益を得ている。
今後、［
~web~platform特能の構文が第三者-主体~toolのそれと競合して，非互換化の原因になる
］ことは，幾度となくあろう。
第三者-主体~toolは，新たな~web~platform特能の原型に利用されることが多いので、
このことは，とりわけ共通的にある。
◎
The web platform benefits from a wide ecosystem of tooling to facilitate easier and faster development. A lot of the time, the syntax of an upcoming web platform feature may conflict with that of a third-party tool causing breakage. This is especially common as third-party tools are often used to prototype new web platform features.
</p>

<p>
~web~platform特能は、
一般に，ほとんどの第三者-主体~toolよりずっと長く残る。
なので、
それらに最適な［
構文と機能性
］を与える優先度は高くするべきである。
◎
In general, web platform features last a lot longer than most third-party tools, and thus giving them the optimal syntax and functionality should be of high priority.
</p>

<p>
一部の事例では、
そのような競合は，あまりに多くの~web~siteに問題を導入する結果、
衝突を避けるため，特能の構文を設計し直す必要が生じる。
◎
In some cases, the conflict will introduce problems across a large number of web sites, necessitating the feature’s syntax to be redesigned to avoid clashes.
</p>

<div class="example">
`Array.prototype.contains()^c は、［
何百万もの~web~siteにて利用されていた~library PrototypeJS に在った，
名前は一致するが互換でない~method
］との衝突を避けるため，
`Array.prototype.includes()^c に改称される必要があった。
◎
Array.prototype.contains() had to be renamed to Array.prototype.includes() to avoid clashes with the identically named but incompatible method from PrototypeJS, a library that was in use in millions of websites.
</div>

<p>
しかしながら、
これらの事例は，例外とされるべきである。
◎
However, these cases should be exceptions.
</p>

<p>
新たな構文で第三者-主体~toolを非互換化するかどうか裁定するにあたって考慮する要因は、
非互換化の著しさ, 第三者-主体~toolの普及度合いの他にも，いくつもある。
◎
When deciding whether to break third party tools with new syntax, there are several factors to consider, such as severity of the breakage, popularity of the third party tool, and many more.
</p>

<p>
場合によっては、［
第三者-主体~toolを非互換化するのを避けるために，当の特能の構文が変更された
］とする場合に［
~web~platform特能の利便性は，どう著しく妥協されることになるか
］が，最も重要な要因になる。
類似な利便性を成すいくつかの代替が考慮されている場合、
通例的には，第三者-主体~toolのうち簡便でないものほど優先度を下げることが好ましい。
◎
Possibly the most important factor is how severely would the usability of the web platform feature be compromised if its syntax was changed to avoid breaking the third party tool? If several alternatives of similar usability are being considered, it is usually preferable to prioritize the ones that inconvenience third party tools the least.
</p>

<div class="example">
~CSS~WGが `CSS-GRID-1$r を設計しているとき、
普及している前処理器である Sass を非互換化するのを避けるため，
`格子~筋＠~CSSGRID#grid-track$の命名-法には丸括弧に代えて角括弧が選ばれた。
◎
When the CSS WG was designing CSS Grid Layout, square brackets were chosen instead of parentheses for naming grid tracks to avoid breaking Sass, a popular preprocessor.
</div>

<p>
しかしながら、
第三者-主体~toolを非互換化するのを避けることが，特能の利便性に`有意^emな負な影響iへ導く場合、
それが受容-可能な~tradeoffになることは稀にしかない
— 生きた~web~siteに有意な非互換化をもたらす場合を除けば。
◎
However, if avoiding breaking the third party tool would lead to a significant negative impact on of the feature’s usability, that is rarely an acceptable tradeoff, unless it causes significant breakage of live websites.
</p>

<p>
言語は、
将来における そのような~dilemmaを抑制するよう，作者が［
将来の~native機能性を非互換化することなく，言語を拡張する
］ために利用できる拡張能のための仕組みも供するべきである。
◎
Languages should also provide mechanisms for extensibility that authors can use to extend the language without breaking future native functionality, to reduce such dilemmas in the future.
</p>

		</section>
	</section>
	<section id="html">
<h2 title="HTML">3. ~HTML</h2>

<p>
この節は、
~HTMLを介して公開される特能~用の設計~原則を詳細する。
◎
This section details design principles for features which are exposed via HTML.
</p>

		<section id="attribute-reuse">
<h3 title="Re-use attribute names (only) for similar functionality">3.1. 類似な機能性（のみ）を備える属性の名前を再利用すること</h3>

<p>
~HTML属性を通して指定される特能を追加している場合、
別の要素に［
類似な機能性を指定する既存の属性~名
］が在るかどうか検査すること。
既存の属性~名を再利用することは、
次を意味する
⇒＃
作者は既存の知識を用立てれる／
複数の言語にわたって`一貫性＠#consistency$を保守する／
語彙を少なく保つ
◎
If you are adding a feature that is specified through an HTML attribute, check if there is an existing attribute name on another element that specifies similar functionality. Re-using an existing attribute name means authors can utilize existing knowledge, maintains consistency across the language, and keeps its vocabulary small.
</p>

<div class="example">
同じ属性~名 `multiple＠~HEforms#attr-select-multiple$a が［
`select$e, `input$e
］どちらにも利用される
— ［
前者は複数個の値たちが成す選定／
後者は複数個の値たちが成す~entry
］を許容する。
◎
The same attribute name, multiple, is used on both select to allow selection of multiple values, as well as on input to allow entry of multiple values.
</div>

<div class="example">
`open＠~HEinteractive#attr-details-open$a 属性は、
`details$e 要素に導入されてから， `dialog$e に再利用された。
◎
The open attribute was introduced on the details element, and then re-used by dialog.
</div>

<p>
既存の属性を再利用する場合、
その構文は，既存の属性の構文にアリな限り近づけるよう努めること。
◎
If you do re-use an existing attribute, try to keep its syntax as close as possible to the syntax of the existing attribute.
</p>

<div class="example">
`label$e 要素に導入された `for＠~HEforms#attr-label-for$a 属性は、
それが どの~form要素に結付けられるべきかを指定する。
それは後で `output$e に再利用された
— どの要素が［
入力~値に寄与したか, あるいは その計算に影響したか
］を指定するため。
後者の構文は，前者より広い［
~space等で分離された~IDたちが成す~list
］を受容する一方で、
前者は~IDを 1 個しか受容しない。
しかしながら，どちらも依然として同じ構文【前者を包摂する後者の構文】に適合する。
一方で、
例えば，一方は~IDたちが成す~list, 他方は~CSS選択子を受容するようにした場合、
~antipatternになる。
◎
The for attribute was introduced on the label element, for specifying which form element it should be associated with. It was later re-used by output, for specifying which elements contributed input values to or otherwise affected the calculation. The syntax of the latter is broader: it accepts a space-separated list of ids, whereas the former only accepts one id. However, they both still conform to the same syntax, whereas e.g. if one of them accepted a list of ids, and the other one a selector, that would be an antipattern.
</div>

<p>
逆も適用される
⇒
追加している機能性が既存の属性と`類似しない^strong場合には、
既存の属性~名を`再利用しない^strongこと。
◎
The inverse also applies: do not re-use an existing attribute name if the functionality you are adding is not similar to that of the existing attribute.
</p>

<div class="example">
［
`input$e ／ `button$e
］要素に利用される `type^a 属性は，要素~型をさらに特化する一方で、
他の要素（例： `link$e, `script$e, `style$e ）は，どれも~MIME型を指定する。
これは、
~antipatternである
— 前者と後者どちらかの属性は、
名前を違えるべきであった。
◎
The type attribute is used on the input and button elements to further specialize the element type, whereas on every other element (e.g. link, script, style) it specifies MIME type. This is an antipattern; one of these groups of attributes should have had a different name.
</div>

		</section>
		<section id="html-lists">
<h3 title="Use space-separated attributes for short lists of values, separate elements for longer lists">3.2. 短い~list用には~spaceで分離された値たちをとる属性を, より長い~list用には別々な要素からなる~listを利用すること</h3>

<p>
ある要素についての~metadataを［
値たちが成す~list
］として指定するときの共通な実施は、
~spaceで分離された~listを利用した上で，
それを `DOMTokenList$I として公開することである。
◎
When specifying metadata about an element that can be a list of values, common practice is to use a space-separated list and expose it as a DOMTokenList.
</p>

<div class="example">
要素の `class＠~HTMLdom#classes$a 内容~属性は、
~spaceで分離された一群の~class名たちが成す~listをとる。
対応する `classList＠~DOM4#dom-element-classlist$c ~IDL属性は、
作者が各~class名を［
追加する／除去する
］ことを許容する `DOMTokenList$I を返す。
◎
The class attribute on elements takes a space-separated list of class names. classList is a DOMTokenList that allows authors to add and remove class names.
</div>

<div class="example">
`iframe$e 要素の `sandbox＠~HEembed#attr-iframe-sandbox$a 内容~属性は、
~spaceで分離された~sandbox~flagたちが成す~listをとる。
対応する `sandbox＠~HEembed#dom-iframe-sandbox$c ~IDL属性は、
作者が各~sandbox~flagを［
追加する／除去する
］ことを許容する `DOMTokenList$I を返す。
◎
The sandbox attribute takes a space-separated list of sandbox flags. iframe.sandbox is a DOMTokenList that allows authors to add and remove sandbox flags.
</div>

<p>
~web~platformの他の各部との一貫性は重要である
— これが，［
値どうしを別の文字を利用して分離する
］ことを意味する場合でも。
◎
Consistency with other parts of the Web Platform is important, even if this means using another character to separate values.
</p>

<div class="example">
`accept＠~HEinput#attr-input-accept$a 内容~属性がとる値~listは
~commaで分離される
— それは、
`Accept＠~HTTPsem#field.accept$h
~HTTP~headerの構文に合致する必要があるので
（`~HTTP~headerに対する指導＠#new-http-header-syntax$を見よ）。
◎
The accept attribute is a comma-separated list of values, because it needs to match the syntax of the Accept HTTP header. (See guidance on HTTP headers)
</div>

<p>
構文に関わらず、
属性は，値たちが成す~listが短い場合に限り利用するベキである。
より長い~list用には、
ある属性~内に~list全体を埋込むことは忌避される。
代わりに，現在の実施は、
各~list~item（および それについての~metadata）を別々な要素を利用して表現することである。
これらの要素は、
当の要素の子~群を成すようにすることも，属性を通して~linkすることもできる。
◎
Regardless of syntax, attributes should only be used for short lists of values. For longer lists, embedding the entire list in an attribute is discouraged. Instead, current practice is to use separate elements to represent the list items (and any metadata about them). These elements could either be children of the element in question, or linked through an attribute.
</p>

<div class="example">
`select$e 要素~用の値たちが成す~listは、
その子~群を成す一連の `option$e 要素として供される。
しかしながら，
`input$e 要素~用に推奨される値たちが成す~listを供するときは、
別々な要素（ `datalist$e ）が利用され，
`list＠~HEinput#attr-input-list$a 属性を通して~linkされる。
◎
The list of values for the select element is provided as a series of option element children. However, when providing a list of recommended values for an input element, a separate element is used (datalist), linked through a list attribute.
</div>

<div class="example">
［
`video$e ／`audio$e
］要素~用の~media~sourceたちが成す~listは、
その子~群を成す一連の `source$e 要素として供される。
◎
The list of media sources for a video or audio element is provided as a series of source element children.
</div>

<p>
稀な~instanceにおいては、
他の~tradeoffが必要yである。
◎
In rare instances, other tradeoffs are necessary.
</p>

<div class="example">
`img$e 要素の `srcset＠~HEimages#attr-img-srcset$a 属性は、
一群の`画像~候補~文字列＠~HEimages#image-candidate-string$用に~commaで分離された~listを許容する。
子~要素たちが成す~listよりも この構文が選ばれたのは、
冗漫さを避けるため, および［
`img$e 要素は`~void要素＠~HTMLwriting#void-elements$であり，子~要素を許可しない
］からである。
~spaceで分離された構文は、
各~list~itemが複数個の値を含むので，アリでなかった。
◎
The srcset attribute allows for a comma-separated list of image candidate strings. This syntax was chosen over a list of child elements to avoid verbosity and because the img element is an empty element that does not permit child elements. A space-separated syntax would not have been possible, as each list item includes multiple values.
</div>

		</section>
		<section id="avoid-html-parser-blocking">
<h3 title="Do not pause the HTML parser">3.3. ~HTML構文解析器を静止させないこと</h3>

<p>
当の設計は、
次を確保すること
⇒
~HTML構文解析器に［
外部~資源を取扱うために静止する
］よう要求しない。
◎
Ensure that your design does not require HTML parser to pause to handle external resources.
</p>

<p>
~browserは，~pageを構文解析するに伴い、
当の~pageに必要な~assetを発見して，各~assetに対し［
並列的に読込むべきかどうか，優先度を解明する
］ことになる。
そのような構文解析は、
ある資源が後続な資源の発見を阻む場合に妨害され得る。
このことは：
最悪な場合、
~browserは［
各~itemを並列的ではなく順番に~downloadする
］ことを意味する。
最善な場合、
~browserは［
投機的な構文解析に基づいて~downloadを~queueする
］ことを意味する
— それは、
不正であると判明することもある。
◎
As a page parses, the browser discovers assets that the page needs, and figures out a priority in which they should be loaded in parallel. Such parsing can be disrupted by a resource which blocks the discovery of subsequent resources. At worst, it means the browser downloads items in series rather than parallel. At best, it means the browser queues downloads based on speculative parsing, which may turn out to be incorrect.
</p>

<p>
ある特能が構文解析器を阻むのは、
一般に［
追加的な内容を後続な内容より前に構文解析器の中へ投入したい
］と求めるからである。
旧来の `&lt;script src="…"&gt;^c 要素の事例は、
これに該当し，
`document.write(…)^c を利用して構文解析器の中へ何かを注入し得る。
上述した処理能の課題に因り、
新たな特能は，これを行なってはナラナイ。
◎
Features that block the parser generally do so because they want to feed additional content into the parser before subsequent content. This is the case of legacy &lt;script src="…"&gt; elements, which can inject into the parser using document.write(…). Due to the performance issues above, new features must not do this.
</p>

		</section>
		<section id="avoid-render-blocking">
<h3 title="Avoid features that block rendering">3.4. 具現化を阻む特能は避けること</h3>

<p>
~pageを具現化する前に資源の読込ngや他の演算を要求する特能は、
それまで~pageが空欄に（または以前の~pageのままに）なる結果，
利用者~体験が拙くなることが多い。
◎
Features that require resource loading or other operations before rendering the page, often result in blank page (or the previous page). The result is a poor user experience.
</p>

<p>
そのような特能の追加を考慮するのは、
利用者~体験が総じて改善される事例に限ること。
これの正準的な例は、［
~stylesheetを~downloadして処理するために具現化を阻む
］ことである
— さもなければ、
未~styleな内容が明滅して，望ましくない利用者~体験になる。
◎
Consider adding such features only in cases when the overall user experience is improved. A canonical example of this is blocking rendering in order to download and process a stylesheet. The alternative user experience is a flash of unstyled content, which is undesirable.
</p>

<p>
次も見よ
⇒＃
`§ 一部の~APIは専用~workerに限り公開するベキである＠#worker-only$
◎
See also § 10.2.1 Some APIs should only be exposed to dedicated workers.
</p>

		</section>
		<section id="html-idl-must-by-synced">
<h3 title="Keep attributes in sync">3.5. 内容~属性と~IDL属性の同期cを保つこと</h3>

<p>
新たな内容~属性には、［
同じ名前を伴う対応する~IDL属性
］があって，この 2 つの状態は同期するよう保たれるベキである。
同期される~IDL属性には一貫した名前を付けるベキである
— さもないと作者を惑わすことになるので。
◎
New content attributes should have a corresponding IDL attribute with the same name, and the state between the two should be kept synchronized. Carving out a synchronized IDL attribute with inconsistent naming results in confusion, and should be avoided.
</p>

<p class="note">注記：
この逆も成立するわけではない。
新たな~IDL属性は、
常に ある内容~属性に相応するものを請合うとは限らない。
◎
This does not hold the other way around. A new IDL attribute does not always warrant a content attribute counterpart.
</p>

<div class="example">
この指導に反する~patternは、［
`input$e の `value＠~HEinput#attr-input-value$a ／
`option$e の `selected＠~HEforms#attr-option-selected$a ／
`input$e の `checked＠~HEinput#attr-input-checked$a
］にて見出せる
— これらの内容~属性は，決して更新されず、
~IDL属性のみが真実を成す~sourceであった。
◎
A counterpattern to this guidance can be found in input's value, option's selected, and input's checked where the HTML attributes were never updated and the IDL attribute was the single source of truth.
</div>

		</section>
		<section id="naming-of-url-attributes">
<h3 title="Name URL-containing attributes based on their primary purpose">3.6.  ~URLを包含している属性は、首な目的に基づいて命名すること</h3>

<p>
新たな内容~属性は、［
当の要素が，当の属性に包含される~URLへ~navigateすること
］を利用者に可能化する場合には，
`href^a と命名すること
— `a$e 要素の `href＠~HEmetadata#attr-link-href$a 属性の様に。
◎
If the element enables the user to navigate to the URL contained in the attribute, call the attribute href, like the a element’s href attribute.
</p>

<p class="note">注記：
後の祭りだが、
`form$e の `action＠~HTMLforms#attr-fs-action$a 属性は，
`href^a と命名されるベキであった。
◎
Note: In hindsight, form's action attribute should have been named href.
</p>

<p>
所与の~URLにある資源を当の要素に読込ませる場合には、
当の属性を `src^a と命名すること
— ［
`img$e 要素の `src＠~HEimages#attr-img-src$a 属性 ／
`script$e 要素の `src＠~HEscripting#attr-script-src$a 属性
］の様に。
◎
If the element causes the resource at the given URL to be loaded, call the attribute src, like the img element’s src attribute or the script element’s src attribute.
</p>

<p class="note">注記：
~HTMLには、
旧来の，模倣されるベキでない非~一貫性がいくつかある
— 例えば，
`link$e 要素の `href＠~HEmetadata#attr-link-href$a 属性は、
当の要素の `rel＠~HEmetadata#attr-link-rel$a 属性の値に依存して，
~naviを許容することも, 資源の読込ngを許容することもある。
◎
Note: HTML has a number of legacy inconsistencies that should not be emulated, like the way link's href attribute might allow for navigation or for resource loading, depending on the value of the element’s rel attribute.
</p>

<p>
当の属性が識別する~URLが，当の要素の目的には補助的【！auxilliary】な場合、
当の属性を その意味論に従って命名すること
— ［
`video$e の `poster＠~HEmedia#attr-video-poster$a ／
`q$e の `cite＠~HEtextlevel#attr-q-cite$a ／
`a$e の `ping＠~HTMLlinks#ping$a
］の様に。
◎
If the attribute identifies a URL that is auxilliary to the element’s purpose, like video's poster, q's cite, or a’s ping, name the attribute after its semantics.
</p>

<p class="note">注記：
~URLを包含している属性は、
~IDLにおいては `USVString$I として表現するベキであることにも留意すること
— `§ 文字列を適切に表現すること＠#idl-string-types$を見よ。
◎
Note: remember that attributes containing URLs should be represented in IDL as USVString; see § 8.2 Represent strings appropriately.
</p>

		</section>
	</section>
	<section id="css">
<h2 title="Cascading Style Sheets (CSS)">4. ~CSS</h2>

<p>
この節は、
~CSS（ `Cascading Style Sheets^en ）を介して公開される特能~用の設計~原則について詳細する。
◎
This section details design principles for features which are exposed via CSS.
</p>

		<section id="css-property-separation">
<h3 title="Separate CSS properties based on what should cascade separately">4.1. ~CSS~propは、何が別々に~cascadeされるべきかに基づいて分離すること</h3>

<p>
~CSS~propの値として，どれを一緒に~group化して どれを分離するべきかは、
何を独立に設定すればイミを成すかに基づいて裁定すること。
◎
Decide which values should be grouped together as CSS properties and which should be separate properties based on what makes sense to set independently.
</p>

<p>
`~CSS~cascade法＠~CASCADE#cascading$【！~TR/2011/REC-CSS2-20110607/cascade.html#cascade】は、
~CSS［
規則／~stylesheet
］に属する`~CSS宣言＠~CSSOM1#css-declaration$【！~TR/2011/REC-CSS2-20110607/syndata.html#declaration】が別のそれを上書きすることを許容する。
一緒に上書きされるべき値たちが成す集合は、
一緒に~cascadeするよう，単独の~prop内に一緒に~group化されるべきである。
同様に，独立に上書き可能になるべき各~値は、
別々な~propに分けられるべきである。
◎
CSS cascading allows declarations from different rules or different style sheets to override one another. A set of values that should all be overridden together should be grouped together in a single property so that they cascade together. Likewise, values that should be able to be overridden independently should be separate properties.
</p>

<div class="example">
<p>
例えば， `initial-letter$p ~propの［
`占める行l数＠~CSSINLINE#initial-letter-initial-letter-size$,
`沈込する行l数＠~CSSINLINE#initial-letter-initial-letter-sink$
］は、
単独の~propに所属する
— それらは、
単独の`先頭字＠~CSSINLINE#initial-letter$による効果
（例：
`埋没~頭字＠~CSSINLINE#dropped-initial$,
`沈込み頭字＠~CSSINLINE#sunken-initial$,
`持上げ頭字＠~CSSINLINE#raised-initial$）
の一部を成すので。
◎
For example, the "size" and "sink" aspects of the initial-letter property belong in a single property because they are part of a single initial letter effect (e.g., a drop cap, sunken cap, or raised cap).
</p>

<p>
しかしながら， `initial-letter-align$p ~propは、
分離されるべきである。
それは、
これらのすべての効果~用に文書~全体にわたる整列~施策を設定する
— それは、
一般的な~style上の選択であり，
当の文書~内で利用されている用字系（例： ~Latin, ~Cyrillic, ~Arabic）の機能である。
◎
However, the initial-letter-align property should be separate because it sets an alignment policy for all of these effects across the document which is a general stylistic choice and a function of the script (e.g., Latin, Cyrillic, Arabic) used in the document.
</p>
</div>

		</section>
		<section id="css-inherited-or-not">
<h3 title="Make appropriate choices for whether CSS properties are inherited">4.2. ~CSS~propが継承されるかどうかについて適切な選択を為すこと</h3>

<p>
ある~propが`継承-$されるべきかどうかは、
次に基づいて裁定すること
⇒
~propによる効果は、
同じ~propが当の要素の ある先祖や子孫に設定された場合に［
上書きされる／追加される
］どちらになるべきか。
◎
Decide whether a property should be inherited based on whether the effect of the property should be overridden or added to if set on an ancestor as well as a descendant.
</p>

<p>
~propを要素に設定することによる効果が，要素の先祖に設定することによる効果
⇒＃
を上書きする必要がある場合、当の~propは，おそらく継承されるべきである／
とは別々な効果を追加する場合、当の~propは，おそらく`継承されない^strongべきである
◎
If setting the property on a descendant element needs to override (rather than add to) the effect of setting it on an ancestor, then the property should probably be inherited.
◎
If setting the property on a descendant element is a separate effect that adds to setting it on an ancestor, then the property should probably not be inherited.
</p>

<p>
継承されない~propの仕様が，要素に対し［
先祖の同じ~propの値を調べる取扱い
］を要求している場合（それは、遅くもなり得る）、［
当の~propは，およそ継承されるべきであった
］ことを示唆する “~code臭（ `code smell^en, ~~兆候）” である。
継承される~propの仕様が，要素に対し［
~propの値が要素の親の同じ~propの値と同じになる場合には，~propを無視する取扱い
］を要求している場合、［
当の~propは，およそ継承されるべきでなかった
］ことを示唆する “~code臭” である。
◎
A specification of an non-inherited property requiring that the handling of an element look at the value of that property on its ancestors (which may also be slow) is a "code smell" that suggests that the property likely should have been inherited. A specification of an inherited property requiring that the handling of an element ignore the value of a property if it’s the same as the value on the parent element is a "code smell" that suggests that the property likely should not have been inherited.
</p>

<p class="note">注記：
~textに対し効果がある~propは、
ほぼ常に［
要素に設定することによる効果は、
要素の先祖に設定することによる効果を（追加するのではなく）上書きする必要がある
］ので，継承されるべきである。
これはまた、
次の設計~原則を保守するためにも必要になる
⇒
~text片の周りに~styleを伴わない行内~要素を挿入しても
【`行内~box＠~CSSDISP#inline-box$を生成する要素で包装しても】，
その~textの外観は変化しない。
◎
If a property has an effect on text, then it’s almost always true that a descendant element needs to override (rather than add to) the effect of setting it on an ancestor, and the property should be inherited. This is also needed to maintain the design principle that inserting an unstyled inline element around a piece of text doesn’t change the appearance of that text.
</p>

<div class="example">
<p>
例えば，
`background-image$p ~propは、
`継承されない^strong。
◎
For example, the background-image property is not inherited.
</p>

<p>
`background-image$p ~propが継承されるとした場合、
当の仕様は［
各~子孫において，部分的に透明な画像が可視に繰返される
］のを避けるため，複階性をかなり~~増す必要があろう。
この複階性は，おそらく、［
当の~propが親~要素に同じ値を有する場合，異なる挙動になる
］ことを孕むことになろう
— それは、
上で言及した，［
当の~propは，およそ継承されるべきでなかった
］ことを示唆する “~code臭” である。
◎
If the background-image property had been inherited, then the specification would have had to create a good bit of complexity to avoid a partially-transparent image being visibly repeated for each descendant element. This complexity probably would have involved behaving differently if the property had the same value on the parent element, which is the "code smell" mentioned above that suggests that a property likely should not have been inherited.
</p>
</div>

<div class="example">
<p>
別の例として，
`font-size$p ~propは、
`継承される^strong。
それは、
当の要素~内の~text用に利用される~fontの~sizeを設定し，
`font-size$p を異なる値に設定する宣言が無い子孫にも，適用され続ける。
◎
Another example is the font-size property, which is inherited. It sets the size of the font used for the text in the element, and continues to apply to any descendants that don’t have a declaration setting font-size to a different value.
</p>

<p>
`font-size$p ~propが継承されなかった場合，おそらく、
先祖~連鎖を遡って，［
その値を有さない最も近い先祖から その`初期~値$を見出す
］ことを要求することになろう
— それは、
上で言及した，［
当の~propは，およそ継承されるべきであった
］ことを示唆する “~code臭” である。
◎
If the font-size property were not inherited, then it would probably have to have an initial value that requires walking up the ancestor chain to find the nearest ancestor that doesn’t have that value. This is the "code smell" mentioned above that suggests that a property likely should have been inherited.
</p>
</div>

		</section>
		<section id="css-computed-value">
<h3 title="Choose the computed value type based on how the property should inherit">4.3. 算出d値の型は、~propがどう継承されるべきかに基づいて選ぶこと</h3>

<p>
~CSS~propの`算出d値$は、［
当の~propは、
値をどう`継承-$することになるか
］に基づいて選ぶこと
— ［
値が他の~propに依存する所では、
どう継承されるべきか
］も含めて。
◎
Choose the computed value of a CSS property based on how it will inherit, including how values where it depends on other properties should inherit.
</p>

<p>
所与の~propの継承は、
次を意味する
⇒
要素の［
当の~prop
］の`算出d値$は、
要素の親の［
当の~prop
］の`算出d値$から取得される
— このことは、
次を意味する
⇒
処理~手続きのうち，`算出d値$に到達するより
⇒＃
前に起こるものは、`継承d値$に影響する／
後に起こるもの（`使用~値$用のものなど）は、`継承d値$に影響しない
◎
Inheritance means that an element gets the same computed value for a property that its parent has. This means that processing steps that happen before reaching the computed value affect the value that is inherited, and those that happen after (such as for the used value) do not.
</p>

<p class="note">注記：
`算出d値$と`解決d値$を混同するべきでない
— 後者は、
`getComputedStyle()＠~CSSOM1#dom-window-getcomputedstyle$c
~methodが返す値である。
◎
Note: the computed value should not be confused with the resolved value which is returned from the getComputedStyle() method.
</p>

<div class="example">
<p>
例えば `line-height$p ~propは、
`number$t 値も受容する
— `line-height:1.4^p —
など。
この値は `font-size$p の何倍になるかを表現するので、
`font-size^p が `20px^v なら，
`line-height^p の`使用~値$【！`実際の値$】は `length$t 値 `28px^v になるが、
`算出d値$は `number$t 値 `1.4^v になる【！（`使用~値$は `28px^v になる）】。
◎
For example, the line-height property may accept a &lt;number&gt; value, such as line-height: 1.4. This value represents a multiple of the font-size, so if the font-size is 20px, the actual value for the line height is 28px.
◎
However, the computed value in this case is the &lt;number&gt; 1.4, not the &lt;length&gt; 28px. (The used value is 28px.)
</p>

<p>
`line-height$p ~propは、
先祖とは `font-size$p が異なる要素の中へ継承され得る
— そのような要素において，［
その~propのうち， `line-height$p に依存するもの
］は、
当の先祖の `font-size$p ではなく，自身の `font-size$p を織り込まなければナラナイ。
◎
The line-height property can be inherited into elements that have a different font-size, and any property on those elements which depends on line-height must take the relevant font-size into account, rather than the font-size for the element from which the line-height value was inherited.
</p>

<pre class="lang-html">
&lt;body style="font-size: 20px; line-height: 1.4"&gt;

  &lt;p&gt;<span class="comment">
`body^e 内の この~textの行l高さは、
`28px^v になる。
◎
This body text has a line height of 28px.
</span>&lt;/p&gt;

  &lt;h2 style="font-size: 200%"&gt;
<span class="comment">
`line-height^p は `body^e に宣言されているが、
この見出しの `line-height^p の使用~値は，
`28px^v ではなく `56px^v になる。
すなわち、
~font~sizeが `40px^v になろうが，行l高さを~overflowしない。
◎
This heading has a line-height of 56px, not 28px, even though the line-height was declared on the body. This means that the 40px font won’t overflow the line height.
</span>
  &lt;/h2&gt;
&lt;/body&gt;
</pre>

<!-- 
This heading has a line-height of 56px,
not 28px, even though the line-height was declared on the body.
This means that the 40px font won’t overflow the line height.
-->

<p>
これらの `number^t 値は， `length^t 値より~~都合良く継承するので、
`line-height$p 用の値として，一般に選好される。
◎
These number values are generally the preferred values to use for line-height because they inherit better than length values.
</p>
</div>

<p>
次も見よ
⇒
`算出d値の~pattern＠https://wiki.csswg.org/spec/computed-values$
◎
See also:
• Computed Values Patterns
</p>

		</section>
		<section id="css-naming">
<h3 title="Name CSS properties and values appropriately">4.4. ~CSS~propとその値を適切に命名すること</h3>

<p>
~CSS~propの名前は，通例的に名詞であり、
それらの値の名前は，通例的に形容詞である（名詞のときもあるが）。
◎
The names of CSS properties are usually nouns, and the names of their values are usually adjectives (although sometimes nouns).
</p>

<p>
［
~prop／その値
］を成す各~単語は、
~hyphenで分離される。
一般に，略語は避けられる。
◎
Words in properties and values are separated by hyphens. Abbreviations are generally avoided.
</p>

<p>
アリなときは単語の語根を利用すること
— 文法~上の［
接頭辞や接尾辞
］を伴う形ではなく（例えば， `sizing^l ではなく `size^l ）。
◎
Use the root form of words when possible rather than a form with a grammatical prefix or suffix (for example, "size" rather than "sizing").
</p>

<p>
~prop用の値たちが成す~listは、
一般に，新たな値を追加できるように選ぶべきである
— 次に挙げる様な値は、
避けること
⇒
［
`yes^v, `no^v, `true^v, `false^v
］, あるいは、
基本的にこれらと等価な，より複階的な名前を伴うもの
◎
The list of values of a property should generally be chosen so that new values can be added. Avoid values like yes, no, true, false, or things with more complex names that are basically equivalent to them.
</p>

<p>
~propの名前においては、［
"`mode^en"（~mode）, "`state^en"（状態）
］の様な単語は避けること
— ~propは、
一般に［
~mode／状態
］を設定するものなので。
◎
Avoid words like "mode" or "state" in the names of properties, since properties are generally setting a mode or state.
</p>

<p>
命名に対する一般的な（各種~言語にわたる）助言は、
`§ 命名~原則＠#naming-is-hard$
を見よ。
◎
See § 12 Naming principles for general (cross-language) advice on naming.
</p>

		</section>
		<section id="css-content-should-be-visible">
<h3 title="Content should be viewable and accessible by default">4.5. 内容は既定で~view可能かつ~access可能になるべきである</h3>

<p>
~CSS~prop, および~CSS~layout~systemは
（それらは概して， `display$p ~propの値【で指定される】）、
次を保全するように設計すること
⇒
内容は、
既定では［
~view可能, ~access可能, 利用-可能
］になる
◎
Design CSS properties or CSS layout systems (which are typically values of the display property), to preserve the content as viewable, accessible and usable by default.
</p>

<div class="example">
例えば，~CSSにおける どの~layout~systemも、
その既定の挙動は［
内容が切取られる／
内容が他の内容と重合する／
~scrollしても内容に到達-不能
］に至ることはない。
これらが起こるのは、［
当の~CSS特能が，そのような挙動を明示的に選ぶように利用された場合
］に限るべきである（例：
`overflow:hidden$p ／
`left:-40em$p ／
`overflow:clip$p
）。
それらは、［
`display:flex$p や `position:relative$p
］の様な何かの結果として，既定で起こるべきでない
◎
For example, the default behavior of all layout systems in CSS will not lead to content being clipped, content overlapping other content, or content being unreachable by scrolling. These things should only happen if CSS features are used that are more explicitly choosing such a behavior (for example, overflow: hidden or left: -40em). They should not happen by default as a result of something like display: flex or position: relative.
</div>

		</section>
	</section>
	<section id="js">
<h2 title="JavaScript Language">5. ~JS言語</h2>

		<section id="js-only">
<h3 title="Use JavaScript for Web APIs">5.1. ~Web~APIには~JSを利用すること</h3>

<p>
~Web用に命令的な~APIを設計するときは、
~JSを利用すること。
特に、
【多数の言語に】一般~化する必要はなく，【~JS】言語に特有な［
意味論／規約
］に自由に依拠できる。
◎
When designing imperative APIs for the Web, use JavaScript. In particular, you can freely rely upon language-specific semantics and conventions, with no need to keep things generalized.
</p>

<div class="example">
<p>
例えば，
`CustomElementRegistry.define()＠~HEcustom#dom-customelementregistry-define$c
~methodは、
`構築子~method＠~TC39#sec-static-semantics-constructormethod$
への参照をとる。
◎
For example, the CustomElementRegistry.define() method takes a reference to a Constructor Method.
</p>

<p>
これには，比較的~近過去な［
~JSに対する~classの追加
］による利点がある
— 事実、
~JSにおいて~method参照を利用するのは，とても容易である。
◎
This takes advantage of the relatively recent addition of classes to JavaScript, and the fact that method references are very easy to use in JavaScript.
</p>
</div>

<p class="note">注記：
~JSは、
名前 `ECMASCRIPT$r の下で標準~化されている。
◎
JavaScript is standardized under the name [ECMASCRIPT].
</p>

<p class="note">注記：
`WEBIDL$r は，別々な “§ ~ES言語束縛” を定義するが、
それは［
~Web~IDLは、
他の~programming言語における言語束縛も備えることを意図する
］ことは含意しない。
◎
[WEBIDL] defines a separate "ECMAScript binding" section, but this doesn’t imply that Web IDL is intended to have bindings in other programming languages.
</p>

		</section>
		<section id="js-rtc">
<h3 title="Preserve run-to-completion semantics">5.2. 完了まで走る（ `run-to-completion^en ）意味論を保全すること</h3>

<p>
~JS`~event~loop$が走っている間は、
~JS~APIを介して~accessされた~dataを改変しないこと。
◎
Don’t modify data accessed via JavaScript APIs while a JavaScript event loop is running.
</p>

<p>
~JS~Web~APIは、
一般に，
C++ や Rust などの低~levelな言語にて実装された特能を包装するものである。
それらの言語と違って，~JSを利用しているときは、
開発者は［
ある~code片が実行し始めたなら，完了するまで実行し続けることになる
］ものと期待できる。
◎
A JavaScript Web API is generally a wrapper around a feature implemented in a lower-level language, such as C++ or Rust. Unlike those languages, when using JavaScript developers can expect that once a piece of code begins executing, it will continue executing until it has completed.
</p>

<p>
そのため、
~JS作者は次を当然のことと~~見なす
⇒
ある関数にて可用にされた~dataは、
当の関数が走っている間に予期せず変化することはない。
◎
Because of that, JavaScript authors take for granted that the data available to a function won’t change unexpectedly while the function is running.
</p>

<p>
なので、
ある~JS~Web~APIが，何らかの~data片（~obj~propなど）を公開する場合、
~UAは，~JS~taskが走っている間は その~dataを更新してはナラナイ。
下層の~dataが変化した場合には、
代わりに，［
当の~dataの公開される~versionを改変する
］ための`~taskを~queueする$こと。
◎
So if a JavaScript Web API exposes some piece of data, such as an object property, the user agent must not update that data while a JavaScript task is running. Instead, if the underlying data changes, queue a task to modify the exposed version of the data.
</p>

<div class="example">
ある~JS~taskが
`navigator.onLine＠~HTMLnavigator#dom-navigator-online$c
~propに~accessしたが，
~browserの~online状態が変化した場合、
当の~propは，次回の~taskが走るまで更新されないことになる。
◎
If a JavaScript task has accessed the navigator.onLine property, and browser’s online status changes, the property won’t be updated until the next task runs.
</div>

		</section>
		<section id="js-gc">
<h3 title="Don’t expose garbage collection">5.3. ~garbage収集を公開しないこと</h3>

<p>
当の~JS~Web~APIは、
次を確保すること
⇒
~garbage収集の時機を知る仕方を作者に供さない
◎
Ensure your JavaScript Web APIs don’t provide a way for an author to know the timing of garbage collection.
</p>

<p>
~garbage収集の時機は，~UAごとに異なることに加え、
~UAが処理能を改善する作業に伴い，時を経て変化することもある。
ある~APIが~garbage収集の時機を公開した場合、
~programの挙動が文脈に応じて異なる原因になり得る。
これは、
作者が これらの相違点を取扱うために加的な~codeを書する必要があることを意味する。
また，時機に依存するような特定0の仕方で働く~codeが~~普及すると、
~UAは異なる~garbage収集~策を実装するのが困難になり得る。
◎
The timing of garbage collection is different in different user agents, and may change over time as user agents work on improving performance. If an API exposes the timing of garbage collection, it can cause programs to behave differently in different contexts. This means that authors need to write extra code to handle these differences. It may also make it more difficult for user agents to implement different garbage collection strategies, if there is enough code which depends on timing working a particular way.
</p>

<p>
このことは、
弱い参照として動作する~API
— 例： ~garbage収集が走ったなら ~NULL になるような~prop —
は，公開するべきでないことを意味する。
~JS~codeにおける［
~obj／~data
］の存続期間は予測-可能になるべきである。
◎
This means that you shouldn’t expose any API that acts as a weak reference, e.g. with a property that becomes null once garbage collection runs. Object and data lifetimes in JavaScript code should be predictable.
</p>

<div class="example">
<p>
`getElementsByTagName()$c は `HTMLCollection$I ~objを返す。
この~objは、
同じ `Document$I ~objに対し，この~methodが同じ~tag名を伴って重ねて~callされた場合には再利用され得る。
これは，実施においては、
~garbage収集されなかった場合に限り，同じ~objが返されることを意味する。
これは、
~garbage収集の時機に依存して，挙動が異なることを意味する。
◎
getElementsByTagName returns an HTMLCollection object, which may be re-used if the method is called twice on the same Document object, with the same tag name. In practice, this means that the same object will be returned if and only if it has not been garbage collected. This means that the behaviour is different depending on the timing of garbage collection.
</p>

<p>
`getElementsByTagName()$c を今日に設計するなら、［
出力を依拠-可能に再利用するか，呼出される回ごとに新たな `HTMLCollection$I を生産する
］よう，その設計者に助言することになろう。
◎
If getElementsByTagName were designed today, the advice to the designers would be to either reliably reuse the output, or to produce a new HTMLCollection each time it’s invoked.
</p>
</div>

<p>
`getElementsByTagName()$c は、
~garbage収集の時機に依存し得ることについて何も告げない。
対照的に［
`WeakRef$jT ／ `FinalizationRegistry$jT
］の様な，~garbage収集に依存するよう明示的に設計された~APIは、［
~garbage収集との相互作用についての作者の期待
］に正確aに沿うよう設定されている。
◎
getElementsByTagName gives no sign that it may depend on the timing of garbage collection. In contrast, APIs which are explicitly designed to depend on garbage collection, like WeakRef or FinalizationRegistry, set accurate author expectations about the interaction with garbage collection.
</p>

		</section>
	</section>
	<section id="api-surface">
<h2 title="JavaScript API Surface Concerns">6. ~JS~API表面に対する懸念</h2>

		<section id="attributes-like-data">
<h3 title="Attributes should behave like data properties">6.1. 属性は~data~propの様に挙動するべきである</h3>

<p>
~IDL属性 `WEBIDL$r は、
単純な~JS~obj~propの様に動作するべきである。
◎
[WEBIDL] attributes should act like simple JavaScript object properties.
</p>

<p>
現実においては、
~IDL属性は，別々な［
取得子, 設定子
］~methodを伴う，~accessor~propとして実装される。
それらが~JS~obj~prop様に動作するためには：
◎
In reality, IDL attributes are implemented as accessor properties with separate getter and setter methods. To make them act like JavaScript object properties:
</p>
<ul>
	<li>
取得子は、
観測-可能な副作用を伴ってはナラナイ。
◎
Getters must not have any observable side effects.
</li>
	<li>
取得子は、
複階的な演算を遂行するべきでない。
◎
Getters should not perform any complex operations.
</li>
	<li>
`obj.attribute === obj.attribute^c
が常に ~T になることを確保すること。
取得子が~callされる回ごとに新たな値を作成しないこと。
◎
Ensure that obj.attribute === obj.attribute is always true. Don’t create a new value each time the getter is called.
</li>
	<li>
アリなら、
<code>obj.attribute = %x</code>
に~~後続する
<code>obj.attribute === %x</code>
は， ~T に評価されることを確保すること。
（ %x に対し何らかの種類の変換が必要yな場合、
これはアリでないこともある。）
◎
If possible, ensure that given obj.attribute = x, obj.attribute === x is true. (This may not be possible if some kind of conversion is necessary for x.)
</li>
</ul>

<p>
ある属性を利用していて，この仕方で挙動しないことについて考している場合、
おそらく，代わりに~methodを利用するべきである。
◎
If you were thinking about using an attribute, but it doesn’t behave this way, you should probably use a method instead.
</p>

<div class="example">
例えば、
`offsetTop＠~CSSOMVIEW#dom-htmlelement-offsettop$c
は，~layoutを遂行する
— それは、
複階的であり，時間がかかり得る。
これは、
`getBoundingClientRect()＠~CSSOMVIEW#dom-element-getboundingclientrect$c
の様に，~methodであった方が良かったであろう。
◎
For example, offsetTop performs layout, which can be complex and time-consuming. It would have been better if this had been a method like getBoundingClientRect().
</div>

		</section>
		<section id="live-vs-static">
<h3 title="Consider whether objects should be live or static">6.2. ~objは~liveか静的どちらになるべきか考慮すること</h3>

<p>
~APIが何らかの内部~状態を表現している~objへの~accessを与える場合、［
当の~objは，当の状態が変化するに伴い更新され続けるべきである
］かどうかを裁定すること。
◎
If an API gives access to an object representing some internal state, decide whether that object should continue to be updated as the state changes.
</p>

<p>
~objのうち，いつの時点でも現在の状態を表現するものは
`~live~obj@
である一方、
作成された時点の状態を表現するものは
`静的~obj@
である。
◎
An object which represents the current state at all times is a live object, while an object which represents the state at the time it was created is a static object.
</p>

			<section id="live-objects">
<h4 title="Live objects">~live~obj</h4>

<p>
ある~objの内部~状態を変更することを作者に許容する場合、
その~objは~liveになるべきである。
例えば，~DOM `Node$I は~live~objであり、
現在の状態を理解する下で，文書に対し変更を為すことを作者に許容する。
◎
If an object allows the author to change the internal state, that object should be live. For example, DOM Nodes are live objects, to allow the author to make changes to the document with an understanding of the current state.
</p>

<p>
~live~objの~propは、
~objの作成-時でなく，~objが~accessされる回ごとに算出され得る。
必要な~dataを算出するのが複階的な場合、
ときには，~live~objの方が良い選択になる
— ~objを返す前に，すべての~dataを算出する必要が無いので。
◎
Properties of live objects may be computed as they are accessed, instead of when the object is created. This makes live objects sometimes a better choice if the data needed is complex to compute, since there is no need to compute all the data before the object is returned.
</p>

<p>
静的な~objと違って，~live~objは、
~dataを複製する必要も無いので，~memoryの利用も少なく済み得る。
◎
A live object may also use less memory, since there is no need to copy data to a static version.
</p>

			</section>
			<section id="static-objects">
<h4 title="Static objects">静的~obj</h4>

<p>
ある~objが［
変化するかもしれない~list
］を表現する場合、［
当の~listを反復している~codeが，その途中で~listが変化するアリ性を取扱う必要
］を無くすよう，静的~objにするべきであることが最も多い。
◎
If an object represents a list that might change, most often the object should be static. This is so that code iterating over the list doesn’t need to handle the possibility of the list changing in the middle.
</p>

<div class="example">
<p>
`getElementsByTagName()$c は、
~listを表現する~live~objを返す。
作者は、
それを成す各~itemを反復するときに，~careする必要があることを意味する：
◎
getElementsByTagName returns a live object which represents a list, meaning that authors need to take care when iterating over its items:
</p>

<pre class="lang-js">
let %list = document.getElementsByTagName("td");

for (let %i = 0; %i &lt; %list.length; %i++) {
    let %td = %list[%i];
    let %tr = document.createElement("tr");
    %tr.innerHTML = %td.outerHTML;

    /* <span class="comment">
これには %list から `td^e 除去する副作用があり、
反復を予測-不能にする。
◎
This has the side-effect of removing td from the list, causing the iteration to become unpredictable.
</span> */
    %td.parentNode.replaceChild(%tr, %td);
}
</pre>

<p>
`querySelectorAll()＠~DOM4#dom-parentnode-queryselectorall$c
が静的~objを返すようにした選択は、
仕様~策定者が `getElementsByTagName()$c が問題の原因になることに気付いた後に為された。
◎
The choice to have querySelectorAll() return static objects was made after spec authors noticed that getElementsByTagName was causing problems.
</p>

<p>
`URLSearchParams$I は、
~listを表現するが，静的ではない
— それが、
作者が~URLの~query文字列を変更する仕方なので。
◎
URLSearchParams isn’t static, even though it represents a list, because it’s the way for authors to change the query string of a URL.
</p>
</div>

<p class="note">注記：
［
`~maplike$ ／ `~setlike$
］型に対しては、
この助言は適用されないであろう【！may not】
— これらの型は、
反復している間に変更されても，きちんと挙動するよう設計されているので。
◎
Note: For maplike and setlike types, this advice may not apply, since these types were designed to behave well when they change while being iterated.
</p>

<p>
当の~propが［
~accessされた時点で算出するのはアリでない
］場合、
静的~objが［
利用されていない間も，~garbage収集されるまで当の~objを更新し続ける
］必要を避ける。
◎
If it would not be possible to compute properties at the time they are accessed, a static object avoids having to keep the object updated until it’s garbage collected, even if it isn’t being used.
</p>

<p>
静的~objが高頻度に変化し得る状態を表現する場合、
属性として可用にするのではなく，~methodから返すようにするべきである。
◎
If a static object represents some state which may change frequently, it should be returned from a method, rather than available as an attribute.
</p>

<p>
次も見よ
⇒
`§ 属性は~data~propの様に挙動するべきである＠#attributes-like-data$
◎
See also:
• § 6.1 Attributes should behave like data properties
</p>

			</section>
		</section>
		<section id="attributes-vs-methods">
<h3 title="Use attributes or methods appropriately">6.3. 属性か~methodか適切な方を利用すること</h3>

<p>
ときには、［
属性, ~method
］どちらを利用するか明瞭でないこともある。
◎
Sometimes it is unclear whether to use an attribute or a method.
</p>
<ul>
	<li>
属性~取得子は、
（観測-可能な）副作用を伴ってはナラナイ。
副作用が予期される場合、
~methodを利用すること。
◎
Attribute getters must not have any (observable) side effects. If you have expected side effects, use a method.
</li>
	<li>
<p>
属性~取得子は、
例外を投出するベキでない：
◎
Attribute getters should not throw exceptions.＼
</p>
		<ul>
			<li>
取得子は，`~data~propの様に挙動するべき＠#attributes-like-data$であり、
定例の~data~propが読取られるときは，例外を投出するべきでない。
◎
Getters should behave like regular data properties, and regular data properties do not throw exceptions when read.＼
</li>
			<li>
妥当でない状態は、
一般に~dataの書込nを却下することにより，避けるベキである
— `読取られる^emときではなく。
◎
Furthermore, invalid state should generally be avoided by rejecting writes, not when data is read.＼
</li>
			<li>
既存の取得子を例外を投出するよう更新することは、
避けるベキである。
既存の~APIの利用者は、
当の~API【の各~取得子の結果】を［
列挙する／包装する
］こともあり，新たな例外を予期しないので、
そうすると，後方-互換性を非互換化することになる。
◎
Updating existing getters to throw exceptions should be avoided as existing API users may enumerate or wrap the API and not expect the new exception, breaking backwards compatibility.
</li>
		</ul>
	</li>
	<li>
属性~取得子は、
他を阻む演算を遂行するベキでない。
ある取得子が，他を阻む演算を遂行することを要求する場合、
~methodにするベキである。
◎
Attribute getters should not perform any blocking operations. If a getter requires performing a blocking operation, it should be a method.
</li>
	<li>
属性~取得子は、
下層の~objが変化するまでの間は，
~callされる回ごとに同じ~objを返すべきである。
すなわち、
常に
`obj.attribute === obj.attribute^c
が満たされなければならない。
属性~取得子から毎回~新たな値を返すのは許容されない。
これを満たせない取得子は、
~methodにするべきである。
◎
If the underlying object has not changed, attribute getters should return the same object each time it is called. This means obj.attribute === obj.attribute must always hold. Returning a new value from an attribute getter each time is not allowed. If this does not hold, the getter should be a method.
</li>
</ul>

<p class="note">注記：
他を阻む演算を伴う~antipatternの例は、
`offsetTop＠~CSSOMVIEW#dom-htmlelement-offsettop$c
の様な~layoutを遂行する取得子である。
◎
Note: An antipattern example of a blocking operation is with getters like offsetTop performing layout.
</p>

<p>
属性は，アリなときは、
その設定子に与えられた値を取得子から返すために保全すること。
すなわち、
<code>obj.attribute = %x</code>
に~~後続する
<code>obj.attribute === %x</code>
は，
~T に評価されるべきである
（このことは
— 例えば，正規化や型~変換の段が必要yな場合など —
常に該当するとは限らないが、
通常の~code~path用には，
目標として保持されるべきである。）
◎
For attributes, whenever possible, preserve values given to the setter for return from the getter. That is, given obj.attribute = x, a subsequent obj.attribute === x should be true. (This will not always be the case, e.g., if a normalization or type conversion step is necessary, but should be held as a goal for normal code paths.)
</p>

<p>
`~liveな~obj, 静的な~obj＠#live-vs-static$
どちらを返すことも求まれ得る。
このことは、
次を意味する：
◎
The object you want to return may be live or static. This means:
</p>
<ul>
	<li>
~liveである場合、
毎回~同じ~objを返すこと
— ある状態~変化により，異なる~objを返すよう要求されるまでは。
属性, ~methodどちらも，これを返し得る。
◎
If live, then return the same object each time, until a state change requires a different object to be returned. This can be returned from either an attribute or a method.
</li>
	<li>
静的な場合、
毎回~新たな~objを返すこと。
この事例は、
~methodに限られるべきである。
◎
If static, then return a new object each time. In which case, this should be be a method.
</li>
</ul>

		</section>
		<section id="prefer-dictionaries">
<h3 title="Accept optional and/or primitive arguments through dictionaries">6.4. 省略可能な／~primitiveな引数は辞書を通して受容すること</h3>

<p>
~API~methodは、
一般に，一連の省略可能な引数の代わりに`辞書$引数を利用するべきである。
◎
API methods should generally use dictionary arguments instead of a series of optional arguments.
</p>

<p>
そうすれば、
当の~methodを~callする~codeは より可読になり，
~methodの~signatureも覚え易くなる。
また、
将来に当の~APIを より拡張-可能にする
— 特に，同じ型を伴う複数個の引数が必要になる場合に。
◎
This makes the code that calls the method more readable, and the method signature easier to remember. It also makes the API more extensible in the future, particularly if multiple arguments with the same type are needed.
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-js">
new Event("example", { bubbles: true, cancelable: false})
</pre>

<p>
は、
次よりずっと可読になる：
◎
is much more readable than
</p>

<pre class="lang-js">
new Event("example", true, false)
</pre>
</div>

<p>
義務的な~parameterを辞書を通して受容することも
— そうした方が，当の~APIが可読になるなら —
考慮するベキである
— とりわけ、
それらが~primitive型であるときは。
◎
You should also consider accepting mandatory parameters through a dictionary, if it would make the API more readable, especially when they are of primitive types.
</p>

<div class="example">
<pre class="lang-js">
window.scrollBy({ left: 50, top: 0 })
</pre>

<p>
は、
次より可読になる：
◎
is more readable than
</p>

<pre class="lang-js">
window.scrollBy(50, 0)
</pre>
</div>

<p>
当の`辞書$自身は、
省略可能な引数にするべきである
— 作者が すべて既定の~optionで~~満足な場合、
余分な引数を渡さなくとも済むよう。
◎
The dictionary itself should be an optional argument, so that if the author is happy with all of the default options, they can avoid passing an extra argument.
</p>

<div class="example">
<p>
例えば次は：
◎
For example,
</p>
<pre class="lang-js">
%element.scrollIntoView(false, {});
</pre>

<p>
次と等価になる：
◎
is equivalent to
</p>

<pre class="lang-js">
%element.scrollIntoView(false);
</pre>
</div>

<p>
次も見よ
⇒＃
`Hall of API Shame:Boolean Trap＠https://ariya.io/2011/08/hall-of-api-shame-boolean-trap$en（ “真偽値の罠” ）／
`真偽値~引数が既定で ~T になる~API＠https://lists.w3.org/Archives/Public/public-script-coord/2013OctDec/0302.html$
`§ ~methodの引数は、アリなら省略可能にすること＠#optional-parameters$／
`§ 省略可能な引数を適切に命名すること＠#naming-optional-parameters$／
◎
See also:
• Hall of API Shame: Boolean Trap.
• APIs that have boolean arguments defaulting to true
• § 6.5 Make method arguments optional if possible
• § 6.6 Name optional arguments appropriately
</p>

		</section>
		<section id="optional-parameters">
<h3 title="Make method arguments optional if possible">6.5. ~methodの引数は、アリなら省略可能にすること</h3>

<p>
~API~method用の ある引数に適理な既定の値がある場合、
その引数を省略可能にして，既定の値を指定すること。
◎
If an argument for an API method has a reasonable default value, make that argument optional and specify the default value.
</p>

<div class="example">
<p>
`addEventListener()$c は、
省略可能な真偽値 %useCapture 引数をとる†。
これは、
既定では ~F になり，次を意味する
⇒
~eventは浮上~相において当の~listenerに配送されるべきである
◎
addEventListener() takes an optional boolean useCapture argument. Thie defaults to false, meaning that the event should be dispatched to the listener in the bubbling phase by default.
</p>

<p class="trans-note">【†
3 個目の引数。
これは，`辞書$もとれるよう拡張されたため、
現在の仕様では %options に改称され，既定では空な辞書になるが、
省略時の結果は ~F を渡したときと同じになる。
】</p>
</div>

<p class="note">注記：
旧来の相互運用能の理由から，これには例外もあるが（ `XMLHttpRequest$I など）、
それは推奨される実施ではなく，設計の過ちと見なされるべきである。
◎
Note: Exceptions have been made for legacy interoperability reasons (such as XMLHttpRequest), but this should be considered a design mistake rather than recommended practice.
</p>

<p>
~APIは、［
引数が~~省略された場合に利用される既定の値は、
`undefined$c を当の引数の型に変換した結果と同じになる
］ように設計されなければナラナイ。
例えば，真偽値~引数が設定されない場合の既定は ~F でなければナラナイ。
◎
The API must be designed so that if an argument is left out, the default value used is the same as converting undefined to the type of the argument. For example, if a boolean argument isn’t set, it must default to false.
</p>

<p>
当の~APIに用いる~list~data型を裁定するときは、
他が要求されない限り，次に挙げる~list型を利用すること：
◎
When deciding between different list data types for your API, unless otherwise required, use the following list types:
</p>
<ul>
	<li>
~methodの~list引数は、
`連列~型$になるべきである。
◎
Method list arguments should be of type sequence&lt;T&gt;
</li>
	<li>
~methodの返り値は、
`連列~型$になるべきである。
◎
Method return values should be of type sequence&lt;T&gt;
</li>
	<li>
属性は、
`観測-可能な配列~型$になるべきである。
◎
Attributes should be of type ObservableArray&lt;T&gt;
</li>
</ul>

<p>
次も見よ
⇒
`§ 省略可能な／~primitiveな引数は辞書を通して受容すること＠#prefer-dictionaries$
◎
See also:
• § 6.4 Accept optional and/or primitive arguments through dictionaries
</p>

		</section>
		<section id="naming-optional-parameters">
<h3 title="Name optional arguments appropriately">6.6. 省略可能な引数を適切に命名すること</h3>

<p>
省略可能な引数は、
否定的な名前にしないで，既定の挙動が明白になるよう命名すること。
◎
Name optional arguments to make the default behavior obvious without being named negatively.
</p>

<p>
これは、
`辞書~内に供される＠#prefer-dictionaries$ときも,
`単独の引数として供される＠#optional-parameters$ときも適用される。
◎
This applies whether they are provided in a dictionary or as single arguments.
</p>

<div class="example">
<p>
`addEventListener()$c がとる %options ~objは、
`once＠~DOM4#dom-addeventlisteneroptions-once$c
と命名される~optionを含む。
これは、
当の~event~listenerは，二回以上~呼出される`べきでない^strongことを指示する。
◎
addEventListener() takes an options object which includes an option named once. This indicates that the listener should not be invoked repeatedly.
</p>

<p>
この~optionは
`repeat^c と命名することもできたが、
そうすると，既定の挙動を反映するためには
`既定では ~T になる＠#optional-parameters$
ことを要求することになる。
~API策定者は、
それを否定的な `noRepeat^c と命名せずに `once^c と命名した。
◎
This option could have been named repeat, but that would require the default to be true. Instead of naming it noRepeat, the API authors named it once, to reflect the default behaviour without using a negative.
</p>

<p>
他の例
⇒＃
`passive^c ではなく `active^c ／
`isolate^c ではなく `connect^c ／
`private^c ではなく `public^c
◎
Other examples:
• passive rather than active, or
• isolate rather than connect, or
• private rather than public
</p>
</div>

<p>
次も見よ
⇒
`§ 命名~原則＠#naming-is-hard$
◎
See also:
• § 12 Naming principles
</p>

		</section>
		<section id="overloading">
<h3 title="Use overloading wisely">6.7. 多重定義を賢く利用すること</h3>

<p>
ある~methodの挙動が，渡された引数に依存して有意に異なることになる場合、
通例的には，別々な~methodを定義するベキである
— 単独の~methodを`多重定義-$するのでなく。
◎
If the behaviour of a method will be significantly different depending on the arguments passed you should usually define a separate method rather than overload a single method.
</p>

<p>
~methodの多重定義は、
いずれかの引数が［
1 個の値, 値たちが成す配列
］どちらもとり得るときなどに有用になる。
類似に，~optionたちが成す辞書を渡すことは、
より柔軟性を許容するので，良い~patternである。
◎
Overloading a method such that one of its arguments can be either a single value or an array of values is useful. Similarly, passing a dictionary of options is a good pattern because it allows for more flexibility.
</p>

<p>
しかしながら，ある~methodにおいて［
渡された最初の引数に応じて後続な引数を変更する必要がある場合
］や［
各~入力の型に依存して挙動が異なる場合
］には、
多重定義を避けるベキである
— ~codeの可読性を邪魔して，
作者が~APIの機能性を発見するのが困難になり得るので。
◎
However, if subsequent arguments for a method have to change because of the first argument passed, or if a method has different behaviour depending on the types of inputs, this can hinder code readability, and make discovering API functionality more difficult for authors, and should be avoided.
</p>

		</section>
		<section id="constructors">
<h3 title="Classes should have constructors when possible">6.8. ~classは、アリなときは，構築子を備えるべきである</h3>

<p>
当の~APIの一部を成す~classは、
適切になるなら，構築子を備えるようにすること。
◎
Make sure that any class that’s part of your API has a constructor, if appropriate.
</p>

<p>
`WEBIDL$r ~interfaceは，既定では “構築-可能でない” ~classを生成するので、
それらの~instanceを `new X()^c を利用して作成しようと試行すると，
`TypeError$E を投出することになる。
それらは、
次により構築-可能にできる
⇒
当の~interfaceに適切な`構築子~演算$を追加して，
当の~classの新たな~instanceを作成する~algoを定義する
◎
By default, [WEBIDL] interfaces generate "non-constructible" classes: trying to create instances of them using new X() will throw a TypeError. To make them constructible, you can add appropriate constructor operations to your interface, and defining the algorithm for creating new instances of your class.
</p>

<p>
これは、［［
当の~classの~instanceを受容する第三者-主体~library
］とともに［
~testする／模擬する／~interfaceする
］などの目的で，~classの~instanceを作成すること
］を，~JS開発者に許容する。
それは、
当の~classの下位classを作成する能も作者に与える
— 無い場合、
そのような能は，~JSが下位classを取扱う仕方により防止される。
◎
This allows JavaScript developers to create instances of the class for purposes such as testing, mocking, or interfacing with third-party libraries which accept instances of that class. It also gives authors the ability to create a subclass of the class, which is otherwise prevented, because of the way JavaScript handles subclasses.
</p>

<p>
これが適切にならない事例もある
— 例えば：
◎
This won’t be appropriate in all cases. For example:
</p>
<ul>
	<li>
一部の~objは，特権的な資源への~accessを表現するので、
そのような資源へ~accessできる~factory~methodにより構築される必要がある。
◎
Some objects represent access to privileged resources, so they need to be constructed by factory methods which can access those resources.
</li>
	<li>
一部の~objは，その~lifecycleがとても注意深く制御されるので、
特定の~methodを通して作成され, ~accessされる必要がある。
◎
Some objects have very carefully controlled lifecycles, so they need to be created and accessed through specific methods.
</li>
	<li>
一部の~objは，抽象-基底~classを表現するので、
構築されるべきでなく，作者は それ用の下位classを定義-可能になるべきでない。
◎
Some objects represent an abstract base class, which shouldn’t be constructed, and which authors should not be able to define subclasses for.
</li>
</ul>

<div class="example">
`Event$I ~class, および その派生~interfaceは、
すべて構築-可能である。
これは、
~eventを取扱う~codeを~testするときに有用になる。
作者は、
`Event$I を構築して，その型の~eventを取扱う~methodに渡せる。
◎
The Event class, and all its derived interfaces, are constructible. This is useful when testing code which handles events: an author can construct an Event to pass to a method which handles that type of event.
</div>

<div class="example">
`Window$I ~classは構築-可能でない
— 新たな~windowを作成することは、
有意な副作用を伴う特権的な演算なので。
新たな~windowを作成するときは、
代わりに，
`window.open()＠~WINDOW#dom-window-open$c
~methodが利用される。
◎
The Window class isn’t constructible, because creating a new window is a privileged operation with significant side effects. Instead, the window.open() method is used to create new windows.
</div>

<div class="example">
`ImageBitmap$I ~classは構築-可能でない
— それは変異-不能な, 塗り用に準備済みな~bitmap画像を表現するが、
塗り用に準備済みになる処理nは，非同期的に行わなければナラナイので。
それを作成するときには、
代わりに
`createImageBitmap()＠~HTMLGAPI#dom-createimagebitmap$c
~factory~methodが利用される。
◎
The ImageBitmap class isn’t constructible, as it represents an immutable, ready-to-paint bitmap image, and the process of getting it ready to paint must be done asynchronously. Instead, the createImageBitmap() factory method is used to create it.
</div>

<div class="example">
`DOMTokenList$I ~classは、
残念なことだが，
`構築-可能でない＠https://www.w3.org/Bugs/Public/show_bug.cgi?id=27114$。
そのため，`~custom要素＠~HEcustom#custom-element$は、［
自身の~token~list属性を `DOMTokenList$I として公開する
］ように作成できなくなっている。
◎
The DOMTokenList class is, sadly, not constructible. This prevents the creation of custom elements that expose their token list attributes as DOMTokenLists.
</div>

<div class="example">
<p>
構築-可能でない~class
— 例： `Navigator$I, `History$I, `Crypto$I —
が構築-可能でないのは、
それらが，各~windowごとに その情報への~accessを表現している~singletonだからである
【すなわち，~windowごとに 1 個しかない】。
これらの特能は、
~Web~IDLの`名前空間$の様な特能の方が，もっと良く収まったかもしれないが、
名前空間より前に設計されたものであり，現在では名前空間でアリになるものを超えている。
◎
Several non-constructible classes, like Navigator, History, or Crypto, are non-constructible because they are singletons representing access to per-window information. In these cases, something like the Web IDL namespace feature might have been a better fit, but these features were designed before namespaces, and go beyond what is currently possible with namespaces.
</p>

<p>
当の~APIが この型の~singletonを要求する場合、
`名前空間$の利用を考慮すること
— そうすると何か問題がある場合は、
`~Web~IDLに課題を申請すること＠https://github.com/whatwg/webidl/issues/new$。
◎
If your API requires this type of singleton, consider using a namespace, and File an issue on Web IDL if there is some problem with using them.
</p>
</div>

<p>
~factory~methodは，構築子を補うものになり得るが、
一般に，構築子の`代わり^emとして利用されるべきでない。
それでも，構築子に加えて~factory~methodを含めることは、
追加的な便益を供するなら価値をもたらし得る。
そのような共通的な事例は、
~APIが ある基底~class, 複数個の特化された下位classを含んでいて，［
渡された~parameterに基づいて適切な下位classを作成する
］ための~factory~methodを伴うときである。
~factory~methodは、［
返される結果に共通かつ最も近い基底~下位class
］上の静的~methodになることが多い。
◎
Factory methods can complement constructors, but generally should not be used instead of them. It may still be valuable to include factory methods in addition to constructors, when they provide additional benefits. A common such case is when an API includes base classes and multiple specialized subclasses, with a factory method for creating the appropriate subclass based on the parameters passed. Often the factory method is a static method on the closest common base subclass of the returned result.
</p>

<div class="example">
`createElement()＠~DOM4#dom-document-createelement$c
~methodは、
構築子として実装し得なかった~factory~methodの例である
— その結果は、
いくつかある `Element$I の下位classのどれもあり得るので。
◎
The createElement method is an example of a factory method that could not have been implemented as a constructor, as its result can be any of a number of subclasses of Element.
</div>

<div class="example">
非推奨にされた
`MouseEvent.initMouseEvent()＠~UIEVENTS-A#dom-mouseevent-initmouseevent$c
~factory~methodは `MouseEvent$I ~objのみを作成する。
それは、
元々は
— 技術的な理由は無かったにもかかわらず —
構築-可能でなかった。
この~methodは，最終的には非推奨にされ、
`MouseEvent$I ~objは単純に構築-可能にされた。
◎
The deprecated MouseEvent.initMouseEvent() factory method only creates MouseEvent objects, which were originally not constructible, even though there was no technical reason against that. Eventually it was deprecated, and the MouseEvent object was simply made constructible.
</div>

		</section>
		<section id="synchronous">
<h3 title="Be synchronous when appropriate">6.9. 適切なときは同期的にすること</h3>

<p>
新たな~APIを設計するときは、
アリな所では，同期的な~APIを選好すること。
同期的な~APIを利用する方が単純であり、
設定しておく必要な基盤（関数を `async^c にするなど）も少なくなる。
◎
Where possible, prefer synchronous APIs when designing a new API. Synchronous APIs are simpler to use, and need less infrastructure set-up (such as making functions async).
</p>

<p>
一般に~APIは、
次に挙げる~~経験則が適用される場合には，同期的にするべきである：
◎
An API should generally be synchronous if the following rules of thumb apply:
</p>
<ul>
	<li>
~APIは、
許可~promptや装置~選定器などの~dialogの背後で通過制御されるものと期待されてはいない。
◎
The API is not expected to ever be gated behind a permission prompt, or another dialog such as a device selector.
</li>
	<li>
~APIの実装は、［
~lock／~filesystem／~network~access
］
— 例えば，~process間の通信 —
により阻止されない。
◎
The API implementation will not be blocked by a lock, filesystem or network access, for example, inter-process communication.
</li>
	<li>
実行~時間は、
短くかつ決定的である。
◎
The execution time is short and deterministic.
</li>
</ul>

		</section>
		<section id="promises">
<h3 title="Design asynchronous APIs using Promises">6.10. 非同期的な~APIは~Promiseを利用して設計すること</h3>

<p>
~API~methodを非同期的にする必要がある場合、
~callback関数ではなく，~Promiseを利用すること。
◎
If an API method needs to be asynchronous, use Promises, not callback functions.
</p>

<p>
~web~platform~~全般に一貫して~Promiseを利用することは、
~promiseを連鎖するなど，~APIを他と一緒に利用するのも より容易になることを意味する。
また，~promiseを利用している~codeの方が、
~callback関数を利用している~codeより容易に理解できる傾向にある。
◎
Using Promises consistently across the web platform means that APIs are easier to use together, such as by chaining promises. Promise-using code also tends to be easier to understand than code using callback functions.
</p>

<p>
次のいずれかに該当する場合、
~APIは非同期的にする必要があるかもしれない：
◎
An API might need to be asynchronous if:
</p>
<ul>
	<li>
~UAは利用者に
`許可＠#consent$
を~promptする必要があるとき。
◎
the user agent needs to prompt the user for permission,
</li>
	<li>
何らかの情報を［
~diskから読取る／~networkへ要請する
］必要があるかもしれないとき。
◎
some information might need to be read from disk, or requested from the network,
</li>
	<li>
~UAは、
結果を返す前に別の［
~thread上で／~process内で
］有意な量の作業を行う必要もあるとき。
◎
the user agent may need to do a significant amount of work on another thread, or in another process, before returning the result.
</li>
</ul>

<p>
次も見よ
⇒
`~Promiseを利用する仕様の書法＠~PROMISES$
◎
See also:
• Writing Promise-Using Specifications
</p>

		</section>
		<section id="aborting">
<h3 title="Cancel asynchronous APIs/operations using AbortSignal">6.11. 非同期的な~APIや演算を取消すときは `AbortSignal^I を利用すること</h3>

<p>
非同期的な~methodが取消され得る場合、［
~option群を成す`辞書$の一部として `AbortSignal$I を渡す
］ことを作者に許容すること。
◎
If an asynchronous method can be cancelled, allow authors to pass in an AbortSignal as part of an options dictionary.
</p>

<div class="example">
<pre class="lang-js">
const %controller = new AbortController();
const %signal = %controller.signal;
geolocation.read({ %signal });
</pre>
</div>

<p>
非同期的な演算を取消す仕方として， `AbortSignal^I を一貫して利用すれば、
作者は，~codeをもっと単純に書せるようになる。
◎
Using AbortSignal consistently as the way to cancel an asychronous operation means that authors can write less complex code.
</p>

<p>
例えば，次のような~patternがある
⇒
同じ `AbortSignal^I を何個かの進行中な演算に利用した上で，必要yな場合は
（利用者から取消すよう要請されたときや，単-~page~appにおいて~naviが生じたときなど）、
対応する `AbortController$I を利用して，すべての演算を まとめて取消すなど。
◎
For example, there’s a pattern of using a single AbortSignal for several ongoing operations, and then using the corresponding AbortController to cancel all of the operations at once if necessary (such as if the user presses "cancel", or a single-page app navigation occurs.)
</p>

<p>
`AbortController$I は、
取消nが保証できない場合でも利用できる
— その `abort()＠~DOM4#dom-abortcontroller-abort$c ~methodの~callは、
保証ではなく要請なので。
◎
Even if cancellation can’t be guaranteed, you can still use an AbortController, because a call to abort() on AbortController is a request, rather than a guarantee.
</p>

		</section>
		<section id="string-constants">
<h3 title="Use strings for constants and enums">6.12. 定数や列挙d値には文字列を利用すること</h3>

<p>
当の~APIに［
定数／列挙d値たちが成す集合
］が必要な場合、
文字列~値を利用すること。
◎
If your API needs a constant, or a set of enumerated values, use string values.
</p>

<p>
文字列の方が開発者にとって検分するのが容易であり、
~JS~engineにおいても，文字列に代えて整数を利用することで得られる処理能の便益は無い。
◎
Strings are easier for developers to inspect, and in JavaScript engines there is no performance benefit from using integers instead of strings.
</p>

<p>
状態を~propの組合nで表出する必要がある場合、
代わりに辞書~objを利用すること
— 別の言語では、
~bitmaskとして表出されることもあろうが。
この~objは、
単独の~bitmask値と同じくらい容易に受け渡せる。
◎
If you need to express a state which is a combination of properties, which might be expressed as a bitmask in another language, use a dictionary object instead. This object can be passed around as easily as a single bitmask value.
</p>

		</section>
		<section id="async-by-default">
<h3 title="If you need both asynchronous and synchronous methods, synchronous is the exception">6.13. 非同期的, 同期的どちらの~methodも必要な場合、同期的な方を例外とすること</h3>

<p>
稀な事例では、
同じ目的に［
同期的, 非同期的
］どちらの~methodも必要になる
— その場合、
非同期的な方を既定として，同期的な方は例外とすること。
◎
In the rare case where you need to have both synchronous and asynchronous methods for the same purpose, default to asynchronous and make synchronous the exception.
</p>

<p>
~web~platformの一部を成す特定の分野は、
現在の制限に因り，非同期的な~supportを欠いている。
したがって、［
非同期的な~methodに加えて，同期的な~method用の~supportを備える
］ことは，利便性に有益になり得る。
これらの事例は例外であり、
同期的な~methodは，~web~platformの能力が発展するに伴って非推奨にされる明瞭な道があると見なすこと。
◎
Due to current limitations, some specific areas of the web platform lack asynchronous support. Therefore having support for synchronous methods in addition to asynchronous methods can be beneficial for usability. Consider these cases an exception, and have a clear path for deprecation of the synchronous methods as web platform capabilities evolve.
</p>

<p>
ほとんどの事例では、
同期的な変種は，
`Sync()^c 接尾辞を伴うよう命名することにより判別されるベキである。
◎
For most cases, the synchronous variant should be distinguished by naming it with a Sync() suffix.
</p>


<div class="example">
<p>
例えば，
`Web Neural Network API＠https://github.com/w3ctag/design-reviews/issues/771$cite
は、
~platform制限に対処するため，
`両~事例とも＠https://github.com/webmachinelearning/webnn/issues/272$
~supportする必要があった
— それは、
非同期的な方を規範にする一方で，同期的な方を例外にした。
◎
For example, the Web Neural Network API needed to support both cases to work around a platform limitation, and made asynchronous the norm while making synchronous the exception.
</p>
</div>

<p class="note">注記：
現時点で，これが適用-可能な周知な事例として，
~JSと~WASMの境界をまたぐ設計が挙げられる
— 現今では、
`Promise integration＠https://github.com/WebAssembly/js-promise-integration/blob/main/proposals/js-promise-integration/Overview.md$cite
（~promiseの統合）は，依然として開発~下にあるので。
◎
At the moment, one well-known case where this is applicable is when a design has to cross boundaries between JavaScript and WASM, as the Promise integration is still under development as of today.
</p>

		</section>
		<section id="properties-vs-methods">
<h3 title="Use properties and methods appropriately">6.14. ~propか~methodか適切な方を利用すること</h3>

<p class="trans-note">【
この節の内容は、
`§ 属性か~methodか適切な方を利用すること＠#attributes-vs-methods$
の内容と
（ “属性” に代えて “~prop” と称されていることを除いて）
ほぼ同じなので，和訳は省略する
（ “~prop” は~JS側から~IDL属性を指すときの呼称）。
】</p>

		</section>
	</section>
	<section id="event-design">
<h2 title="Event Design">7. ~eventの設計</h2>

		<section id="one-time-events">
<h3 title="Use promises for one time events">7.1. 一度限りの~event用には~promiseを利用すること</h3>

<p>
<strong>
`~promiseを利用している仕様の書法＠~PROMISES$
</strong>
指針における`助言＠~PROMISES#one-time-events$に従うこと。
◎
Follow the advice in the Writing Promise-Using Specifications guideline.
</p>

		</section>
		<section id="promises-and-events">
<h3 title="Events should fire before Promises resolve">7.2. ~eventは~promiseを解決する前に発火するべきである</h3>

<p>
~promiseに基づく非同期的な~algoが~eventを配送する場合、
当の~Promiseを解決した後ではなく，解決する前に配送するべきである。
◎
If a Promise-based asynchronous algorithm dispatches events, it should dispatch them before the Promise resolves, rather than after.
</p>

<p>
これは、［
当の~algoによる効果は、
当の~Promiseが解決された時点で，すべて適用-済みになる
］ことを保証する。
例えば，作者が［
当の~Promiseが配送した~eventに対する反応において，何らかの状態を変更する場合
］、
作者は［
当の~Promiseが解決された時点で，すべての状態は一貫である
］ことを~~確信できる。
◎
This guarantees that once the Promise resolves, all effects of the algorithm have been applied. For example, if an author changes some state in reaction to an event which the Promise dispatches, they can be sure that all of the state is consistent if the Promise is resolved.
</p>

		</section>
		<section id="dont-invent-event-like">
<h3 title="Don’t invent your own event listener-like infrastructure">7.3. 自前の~event~listenerの様な基盤を考案しないこと</h3>

<p>
通知を生成することで，ある処理nを［
開始する／停止する
］ことを作者に許容する~APIを作成しているときは、
既存の~event基盤を利用して，通知を~listenするのを許容すること。
下層の処理nを［
開始する／停止する
］ための制御~用には、
別々な~APIを作成すること。
◎
When creating an API which allows authors to start and stop a process which generates notifications, use the existing event infrastructure to allow listening for the notifications. Create separate API controls to start/stop the underlying process.
</p>

<div class="example">
<p>
例えば，~Web~Bluetooth~APIは、
`BluetoothRemoteGATTCharacteristic^I 大域~obj上に `startNotifications()^c ~methodを供する
— それは、
“作動中な通知~文脈~集合” に当の~objを追加する。
◎
For example, the Web Bluetooth API provides a startNotifications() method on the BluetoothRemoteGATTCharacteristic global object, which adds the object to the "active notification context set".
</p>

<p>
~UAは、
~Bluetooth装置からある通知を受信したとき，
“作動中な通知~文脈~集合” を成す各 `BluetoothRemoteGATTCharacteristic^I ~objに向けて~eventを発火することになる。
◎
When the User Agent receives a notification from the Bluetooth device, it fires an event at the BluetoothRemoteGATTCharacteristic objects in the active notification context set.
</p>
</div>

<p>
次も見よ
⇒＃
`§ 通知~用には~eventを利用すること＠#events-are-for-notification$／
`§ ~eventか観測器か適切な方を利用すること＠#events-vs-observers$／
<a href="#state-and-subclassing">§ 状態~用には素な `Event^I を利用すること</a>
◎
See:
• § 7.5 Use events for notification
• § 7.8 Use Events and Observers appropriately
• § 7.7 Use plain Events for state
</p>

		</section>
		<section id="always-add-event-handlers">
<h3 title="Always add event handler attributes">7.4. 常に~event~handler属性を追加すること</h3>

<p>
当の~APIが新たな~event型を追加する場合、
それを取扱うであろう各 `EventHandler$I の~interfaceにも，
対応する`~event~handler~IDL属性$を
— 当の~event型が `foo^et ならば `onfoo^c を —
追加すること。
◎
If your API adds a new event type, add a corresponding onyourevent event handler IDL attribute to the interface of any EventHandler which may handle the new event.
</p>

<p>
~event~handler~IDL属性を定義し続けることは、
次に挙げることから重要になる：
◎
it’s important to continue to define event handler IDL attributes because:
</p>
<ul>
	<li>
~platformにおける一貫性を保全する。
◎
they preserve consistency in the platform
</li>
	<li>
~supportされる~event用の特能~検出を可能化する
（`§ 新たな特能は検出-可能になるべきである＠#feature-detect$ を見よ）。
◎
they enable feature-detection for the supported events (see § 2.5 New features should be detectable)
</li>
</ul>

<p class="note">注記：
一貫性を得るため、
当の~eventが［
~HTML／~SVG
］要素により取扱われる必要がある場合には，
当の`~event~handler~IDL属性$を
`GlobalEventHandlers$I ~interface~mixinに追加すること
— 関連な要素~interface（たち）に直に追加するのではなく。
類似に，
`Window$I により取扱われる必要がある場合には，
当の`~event~handler~IDL属性$を
`WindowEventHandlers$I に追加すること。
◎
For consistency, if the event needs to be handled by HTML and SVG elements, add the event handler IDL attributes on the GlobalEventHandlers interface mixin, instead of directly on the relevant element interface(s). Similarly, add event handler IDL attributes to WindowEventHandlers rather than Window.
</p>

		</section>
		<section id="events-are-for-notification">
<h3 title="Use events for notification">7.5. 通知~用には~eventを利用すること</h3>

<p>
~eventは、
変更を誘発するために利用されるべきでない。
~eventは、［
変化が起きたことは，すでに完遂したこと
］の通知を送達するために限られる。
◎
Events shouldn’t be used to trigger changes, only to deliver a notification that a change has already finished happening.
</p>

<div class="example">
<p>
~UIwindowが~resizeされたとき，当の `Window^I ~objに向けて名前 `resize＠~CSSOMVIEW#eventdef-window-resize$et の~eventが発火される。
◎
When a window is resized, an event named resize is fired at the Window object.
</p>

<p>
当の~eventを横取りしても，~resizeが起こるのを停止するのはアリでない。
当の~UIwindowの~sizeを変更するよう構築された `resize^et ~eventを発火するのもアリでない。
この~eventは、
~resizeがすでに起きたことを作者に通知することしかできない。
◎
It’s not possible to stop the resize from happening by intercepting the event. Nor is it possible to fire a constructed resize event to cause the window to change size. The event can only notify the author that the resize has already happened.
</p>
</div>

		</section>
		<section id="guard-against-recursion">
<h3 title="Guard against potential recursion">7.6. 再帰の能性に抗して防護すること</h3>

<p>
当の~APIが［
長く走る／複雑な
］~algoを含む場合、
それが走っている間は，当の~algoの中へ~callするのを防止すること。
◎
If your API includes a long-running or complicated algorithm, prevent calling into the algorithm if it’s already running.
</p>

<p>
ある~API~methodが，長く走る~algoを始める原因になる場合、
`通知~用の~event＠#events-are-for-notification$を利用して，
当の~algoの進捗を利用元~codeに通知するべきである。
しかしながら、
当の~eventを取扱う利用元~codeは，同じ~API~methodを~callし得るので、
複階的な~algoを再帰的に走らす原因になる
— それは、
同じ~eventを再び発火し得るので，同じ~event~handlerを発火する原因になり, 以下同様に続く。
◎
If an API method causes a long-running algorithm to begin, you should use events to notify user code of the progress of the algorithm. However, the user code which handles the event may call the same API method, causing the complex algorithm to run recursively. The same event may be fired again, causing the same event handler to be fired, and so on.
</p>

<p>
これを防止するため、
当の~API~methodの中への “再帰的な” ~callは，
単純に即時に【すなわち，何もせずに】返るようにすること。
この技法は、
~algoの “防護-法（ `guarding^en ）” と称される。
◎
To prevent this, make sure that any "recursive" call into the API method simply returns immediately. This technique is "guarding" the algorithm.
</p>

<div class="example">
<p>
`AbortSignal$I 用の［
`通達に~algoを追加する$／
`通達から~algoを除去する$／
`中止-を通達する$aC
］手続きは、
どれも，当の通達は`中止-済み$aBか否か検査する所から始まる。
中止されていた場合、
当の~algoは，それ以降を走らすことなく終える。
◎
AbortSignal's add, remove and signal abort each begin with a check to see if the signal is aborted. If the signal is aborted, the rest of the algorithm doesn’t run.
</p>

<p>
この事例では、
重要な複階性の多くは，`中止-を通達する$aC間に走らす~algo内にある。
この手続きは、
【！collection of algorithms】`中止する~algo群$aBを反復する
— それらは、［
`通達に~algoを追加する$,
`通達から~algoを除去する$
］~algo【！add and remove method】により管理される。
◎
In this case, a lot of the important complexity is in the algorithms run during the signal abort steps. These steps iterate through a collection of algorithms which are managed by the add and remove methods.
</p>

<p>
例えば，
`ReadableStreamPipeTo＠~STREAMS#readable-stream-pipe-to$A
の定義は、
当の~algoを `AbortSignal$I の`中止する~algo群$aBに`追加する＠~DOM4#abortsignal-add$
— それが走るのは、
当の通達を結付けている `AbortController$I の
`abort()＠~DOM4#dom-abortcontroller-abort$c
を~callすることにより，
`中止-を通達する$aC手続きが誘発されるときである。
◎
For example, the ReadableStreamPipeTo definition adds an algorithm into the AbortSignal's set of algorithms to be run when the signal abort steps are triggered, by calling abort() on the AbortController associated with the signal.
</p>

<p>
この~algoは、
~promiseを解決して，~codeを走らす原因になる見込みが高い
— その~codeは、
`AbortSignal$I の~methodを~callしようと試みる何かを含み得る。
`中止-を通達する$aC手続きは，【！collection of algorithms】`中止する~algo群$aBを反復することを孕むので、
それが走っている間に，その~algo群を改変するのはアリになるべきでない。
◎
This algorithm is likely to resolve promises causing code to run, which may include attempting to call any of the methods on AbortSignal. Since signal abort involves iterating through the collection of algorithms, it should not be possible to modify that collection while it’s running.
</p>

<p>
加えて、
`中止-を通達する$aC手続きは，
当の通達がすでに この手続きの処理nに入っている場合には、［
この手続きの中へ戻るよう再帰的に~callさせる~code
］を誘発したとしても［
再帰を避けるよう，この手続きを再び走らすのを避ける
］ことが重要になる。
◎
And since signal abort would have triggered the code which caused the recursive call back in to signal abort, it’s important to avoid running these steps again if the signal is already in the process of the signal abort steps, to avoid recursion.
</p>
</div>

<div class="note">
<p>注記：
早期-終了nに際しての注意点：
◎
Note: A caution about early termination:＼
</p>
<ul>
	<li>
終了されている当の~algoが，
何らかの~criticalな状態の一貫性を確保しようとするものである場合、
当の~algoの早期-終了nより前に，状態において関連な調整を為すこと。
そうしないと，状態が一貫しなくなり、
指定したとおり実装されると，末端-利用者に可視な~bugに至りかねないので。
◎
if the algorithm being terminated would go on to ensure some critical state consistency, be sure to also make the relevant adjustments in state before early termination of the algorithm. Not doing so can lead to inconsistent state and end-user-visible bugs when implemented as-specified.
</li>
	<li>
<p>
早期-終了nの際に例外を投出するときは、
次について念頭に置くよう特に注意すること：
</p>
		<ul>
			<li>
開発者が当の~algoを呼出すことになる局面
</li>
			<li>
この（たぶん稀な）事例において，開発者が例外を取扱うことを適理に期待することになるかどうか
— 例えば、
これは当の~algo内の唯一の例外になるか？
</li>
		</ul>
◎
Note: Be cautious about throwing exceptions in early termination. Keep in mind the scenario in which developers will be invoking the algorithm, and whether they would reasonably expect to handle an exception in this [perhaps rare] case. For example, will this be the only exception in the algorithm?
</li>
</ul>
</div>

<p>
この仕方で常に “防護-可能” になるとは限らない。
例えば，ある~algoは、
それらすべてを依拠-可能に検査するには，入口【すなわち，当の~algoを呼出している箇所】が多過ぎることもある。
これに該当する事例における別の~optionは、
作者~codeを~callするのを［
`~task$／`小task$
］へ先送りすることである。
これは，再帰の~stackを避けるが、
後続して~queueされる~taskたちにより際限ない~loopが生じる~riskは避けれない。
◎
You won’t always be able to "guard" in this way. For example, an algorithm may have too many entry-points to reliably check all of them. If that’s the case, another option is to defer calling the author code to a later task or microtask. This avoids a stack of recursion, but can’t avoid the risk of an endless loop of follow-up tasks.
</p>

<p>
~eventを先送りするときは、
“… `~eventを発火する$ための`~taskを~queueする$ …”
として指定されることが多い。
◎
Deferring an event is often specified as "queue a task to fire an event...".
</p>

<p>
~eventは、
それを誘発する~algoが異なる［
~thread／~process
］上で走ることもある場合には，常に先送りするべきである。
この事例で先送りすることは、［
当の~eventが`~task~queue$内の正しい`~task$で処理できる
］ことを確保する。
◎
You should always defer events if the algorithm that triggers the event could be running on a different thread or process. In this case, deferral ensures the events can be processed on the correct task in the task queue.
</p>

<p>
［
“防護-法”, “先送り法”
］どちらの~approachにも，~trade-offがある：
◎
Both the "guarding" and the "deferring" approach have trade-offs.
</p>

<p>
~algoの “防護-法” は次を保証する：
◎
"Guarding" an algorithm guarantees:
</p>
<ul>
	<li>
［
防護された~algoの終了~時から，~eventが発火される時点まで
］の間，状態が変化し得る機会cは無い。
◎
at the time events are fired, there is no chance that the state may have changed between the guarded algorithm ending and the event firing.
</li>
	<li>
~algoの間に発火された~event
— 当の~algoの一部として為された状態~変更を利用元~codeに通知する~eventなど —
は、
次回の`~task$まで待機する必要なく，即時に発火でき、
当の変化を~codeに通知することになる。
◎
events fired during the algorithm, such as events to notify user code of a state change made as part of the algorithm, can be fired immediately, notifying code of the change without needing to wait for the next task.
</li>
	<li>
~event~handler内で走っている利用元~codeは、
その発火-先の~instance~obj上で，関連な状態を直に観測できる
— 当の~eventに関連な状態の複製を【利用元~codeに】与える必要はない。
◎
user code running in the event handler can observe relevant state directly on the instance object they were fired on, rather than needing to be given a copy of the relevant state with the event.
</li>
</ul>

<p>
当の~eventが代わりに先送りされた場合：
◎
If the events are deferred instead:
</p>
<ul>
	<li>
当の~algoが完了した時点で，それ【~eventを発火する~task】が`~task~queue$内で最初の`~task$になる保証は無い。
◎
there is no guarantee that they will be first in the task queue once the algorithm completes.
</li>
	<li>
<p>
当の~objの状態を変更し得る他の`~task$は、
先送りされた~eventに当の~eventに関連な状態がある場合には，それを伴うよう含めるべきである。
◎
any other task may change the object’s state you should include any state relevant to the event with the deferred event.
</p>

<p class="note">注記：【！class="informative】
これは通例的に、
状態を保持するための新たな属性を伴う，新たな［
`Event$I の下位class
］を孕む。
例えば， `ProgressEvent$I は、
状態を保持する属性として［
`loaded＠~XHR#dom-progressevent-loaded$c,
`total＠~XHR#dom-progressevent-total$c,
等々
］を追加する。
◎
This usually involves a new subclass of Event, with new attributes to hold the state.
◎
For example, the ProgressEvent adds loaded, total, etc. attributes to hold the state.
</p>
	</li>
	<li>
<p>
ある~algoを成す異なる各部が協調する必要がある場合、［
先送りされた~eventを発火するとき，状態を［
検分する／変更する
］挙動がきちんと定義されるようになる
］ことを確保するため，
明示的な状態~機械（きちんと定義された状態~遷移）を定義する必要もあろう。
◎
if different parts of an algorithm need to coordinate, you may need to define an explicit state machine (well-defined state transitions) to ensure that when a deferred event fires, the behavior of inspecting or changing state is well-defined.
</p>

<div class="example">【！class="informative】
<p>
例えば，
`payment-request$r における
`PaymentRequest$I の `state＠https://w3c.github.io/payment-request/#dfn-state$sl 内部~slotは、
きちんと定義された遷移を通して，当の~objの状態を明示的に追跡する：
◎
For example, in [payment-request], the PaymentRequest's [[state]] internal slot explicitly tracks the object’s state through its well-defined transitions.
</p>

<p>
これらの状態~遷移は、
状態~遷移が適切に起こるのを確保するため，防護-法の技法を利用することが多い。
例えば，
`payment-request$r は、
`show()＠https://w3c.github.io/payment-request/#dom-paymentrequest-show$c
など用の~algo内で `state＠https://w3c.github.io/payment-request/#dfn-state$sl 内部~slotの周りで利用される防護-を注記する。
◎
These state transitions often use the guarding technique themselves, to ensure the state transitions happen appropriately.
◎
For example, in [payment-request] note the guards used around the [[state]] internal slot, such as in the show() algorithm.
</p>
</div>

	</li>
	<li>
先送りされた~eventに［
加的な状態／状態~機械
］は必要ない場合、
これは おそらく，［
当の~eventは当の~algoの完了を通達するだけである
］ことを意味する。
これに該当する場合、
当の~APIは，おそらく
当の~eventを発火する代わりに `Promise$I を返すべきである。
`§ 一度限りの~event用には，~promiseを利用すること＠#one-time-events$
を見よ。
◎
if the deferred event doesn’t need extra state, or a state machine, this probably means that the event is just signalling the completion of the algorithm. If this is true, the API should probably return a Promise instead of firing the event. See § 7.1 Use promises for one time events.
</li>
</ul>

<p class="note">注記：
この節に述べたような再帰のアリ性を公開する~eventは，
“同期的な~event” と称されることもあるが、
この語法は忌避される
— それは、
~eventは非同期的に配送されることもアリなことを含意するので。
すべての~eventは、
同期的に配送される。
“非同期的な~event” は、
むしろ，~eventの発火を先送りすることを含意することが多い。
◎
Note: events that expose the possibility of recursion as described in this section were sometimes called "synchronous events". This terminology is discouraged as it implies that it’s possible to dispatch an event asynchronously. All events are dispatched synchronously. What is more often implied by "asynchronous event" is to defer firing an event.
</p>

		</section>
		<section id="state-and-subclassing">
<h3 title="Use plain Events for state">7.7. 状態~用には素な `Event^I を利用すること</h3>

<p>
アリな所では、
指定された~event型
（ `type＠~DOM4#dom-event-type$c ）
を伴う素な `Event$I を利用した上で，
状態~情報を `target＠~DOM4#dom-event-target$c ~obj内に捕捉すること。
◎
Where possible, use a plain Event with a specified type, and capture any state information in the target object.
</p>

<p>
`Event$I の新たな下位classを作成することは、
通例的には，必要yでない。
◎
It’s usually not necessary to create new subclasses of Event.
</p>

		</section>
		<section id="events-vs-observers">
<h3 title="Use Events and Observers appropriately">7.8. ~eventか観測器か適切な方を利用すること</h3>

<p>
一般に、
観測器【 `Observer^en 】~patternよりも［
`EventTarget$I と通知 `Event$I
］を利用すること
— `EventTarget$I では，当の特能~用にきちんと働けない場合を除いて。
◎
In general, use EventTarget and notification Events, rather than an Observer pattern, unless an EventTarget can’t work well for your feature.
</p>

<p>
`EventTarget$I を利用すれば、
当の特能は，共有される基底~classに対する改善
— `once＠~DOM4#dom-addeventlisteneroptions-once$c の追加など —
から便益を得ることも確保される。
◎
Using an EventTarget ensures your feature benefits from improvements to the shared base class, such as the addition of the once.
</p>

<p>
~eventを利用すると問題
— `再帰＠#guard-against-recursion$を避けれないなど —
の原因になる場合、
代わりに観測器~patternを利用することを考慮すること。
◎
If using events causes problems, such as unavoidable recursion, consider using an Observer pattern instead.
</p>

<p>
観測器~patternの例には、
次が挙げられる
⇒＃
`MutationObserver$I,
`IntersectionObserver$I,
`ResizeObserver$I,
`IDBObserver$I
◎
MutationObserver, Intersection Observer, Resize Observers, and IndexedDB Observers are all examples of an Observer pattern.
</p>

<div class="example">
<p>
`MutationObserver$I （変異~観測器）は、
`MutationEvent$I （~DOM変異~event）を置換して，それを非推奨にした
— 開発者が次について`気付いた＠https://lists.w3.org/Archives/Public/public-webapps/2011JulSep/0779.html$後に：
◎
MutationObserver replaced the deprecated DOM Mutation Events after developers noticed that DOM Mutation Events
</p>
<ul>
	<li>
発火される回数が多過ぎる。
◎
fire too often
</li>
	<li>
~event伝播からの便益が無く、
有用になるには遅過ぎる。
◎
don’t benefit from event propagation, which makes them too slow to be useful
</li>
	<li>
`再帰に抗して防護する＠#guard-against-recursion$のが困難~過ぎる。
◎
cause recursion which is too difficult to guard against.
</li>
</ul>

<p>
`MutationObserver$I は：
◎
Mutation Observers:
</p>
<ul>
	<li>
適用し終えた後に観測器へ送信するよう，一連の変異を~batchしておける。
◎
can batch up mutations to be sent to observers after mutations have finished being applied;
</li>
	<li>
~eventの［
捕捉~相／浮上~相
］を通って行く必要は無い。
◎
don’t need to go through event capture and bubbling phases;
</li>
	<li>
どんな変異が生じたか表出するためとして，もっと多彩な~APIを供する。
◎
provide a richer API for expressing what mutations have occurred.
</li>
</ul>

<p class="note">注記：
~eventも通知を~batchしておけるが、
`MutationEvent$I は，これを行うよう設計されなかった。
~eventは，~event伝播に常に関与する必要はないが、
~DOM `Node$I に対する~eventは，通例的にそうなる必要がある。
◎
Note: Events can also batch up notifications, but DOM Mutation Events were not designed to do this. Events don’t always need to participate in event propagation, but events on DOM Nodes usually do.
</p>
</div>

<p>
観測器~patternは、
次の様に働く：
◎
The Observer pattern works like this:
</p>
<ul>
	<li>
観測器~classの各~instanceは、
~callback, および任意選択で［
何が観測されるべきか~custom化するための，何らかの~option群
］を伴って構築される。
◎
Each instance of the Observer class is constructed with a callback, and optionally with some options to customize what should be observed.
</li>
	<li>
各~instanceは、
`observe()^c と命名された~methodを利用して，特定の~targetを観測し始める
— ~methodは、
観測される~targetへの参照をとる。
何が観測されるべきか~custom化するための~option群も，
構築子の代わりに ここで供され得る。
構築子に供された~callbackは、
その~targetに何か関心事が起きたとき，呼出される。
◎
Instances begin observing specific targets, using a method named observe(), which takes a reference to the target to be observed. The options to customize what should be observed may be provided here instead of to the constructor. The callback provided in the constructor is invoked when something interesting happens to those targets.
</li>
	<li>
~callbackは、
引数として `変更~記録^em を受取る。
これらの記録は、
それを起こした関心事についての詳細を包含する。
一度に複数個の記録が送達され得る。
◎
Callbacks receive change records as arguments. These records contain the details about the interesting thing that happened. Multiple records can be delivered at once.
</li>
	<li>
作者は、
観測器~instanceの［
`unobserve()^c ／ `disconnect()^c
］と称される~methodを~callすることにより，観測するのを停止できる。
◎
The author may stop observing by calling a method called unobserve() or disconnect() on the Observer instance.
</li>
	<li>
生じた事象のうち［
観測されたが まだ送達されていないものすべて
］の記録を即時に返すための~methodも、
任意選択で供され得る。
◎
Optionally, a method may be provided to immediately return records for all observed-but-not-yet-delivered occurrences.
</li>
</ul>

<div class="example">
<p>
`IntersectionObserver$I は、
次の様に利用されよう：
◎
IntersectionObserver may be used like this:
</p>

<pre class="lang-js">
function checkElementStillVisible(%element, %observer) {
    delete %element.visibleTimeout;

    /* <span class="comment">
まだ`~task~queue$に残っている観測nがあれば，それらを処理する
◎
Process any observations which may still be on the task queue
</span> */
    processChanges(%observer.takeRecords());

    if ('isVisible' in %element) {
        delete %element.isVisible;
        logAdImpressionToServer();

        /* <span class="comment">
%element の観測を停止する
◎
Stop observing this element
</span> */
        %observer.unobserve(%element);
    }
}

function processChanges(%changes) {
    %changes.forEach(function(%changeRecord) {
        var %element = %changeRecord.target;
        %element.isVisible = isVisible(%changeRecord.boundingClientRect,
                                      %changeRecord.intersectionRect);
        if ('isVisible' in %element) {
            /* <span class="comment">
%element は可視になった
◎
Element became visible
</span> */
            %element.visibleTimeout = setTimeout(() =&gt; {
                checkElementStillVisible(%element, %observer);
            }, 1000);
        } else {
            /* <span class="comment">
%element は非可視になった
◎
Element became hidden
</span> */
            if ('visibleTimeout' in %element) {
                clearTimeout(%element.visibleTimeout);
                delete %element.visibleTimeout;
            }
        }
    });
}

/* <span class="comment">
~callbackと~option群で
`IntersectionObserver$I を作成する
◎
Create IntersectionObserver with callback and options
</span> */
var %observer = new IntersectionObserver(processChanges, { threshold: [0.5] });

/* <span class="comment">
"ad" 要素を観測し始める
◎
Begin observing "ad" element
</span> */
var %ad = document.querySelector('#ad');
%observer.observe(%ad);
</pre>

<p>
（ `IntersectionObserver$I の`説明書き＠https://github.com/w3c/IntersectionObserver/blob/master/explainer.md$から転用された~code例。）
◎
(Example code adapted from the IntersectionObserver explainer.)
</p>
</div>

<p>
観測器~patternを利用するためには、
次を表現するための~obj型を定義する必要がある
⇒＃
新たな観測器（以下では “~Observer” と総称される）,
観測n~option群,
観測された記録
◎
To use the Observer pattern, you need to define:
• the new Observer object type,
• an object type for observation options, and
• an object type for the records to be observed.
</p>

<p>
この加的な作業には、
~trade-offとして，次に挙げる利点がある：
◎
The trade-off for this extra work is the following advantages:
</p>
<ul>
	<li>
各~instanceは、［
作成~時点／観測し始める時点
］に~custom化できる。
~Observer の［
構築子 ／ `observe()^c ~method
］は、［
各~callback用に，何が観測されるかを~custom化すること
］を作者に許容するためとして，~option群をとれる。
これは `addEventListener()$c ではアリでない。
◎
Instances can be customized at observation time, or at creation time. The constructor for an Observer, or its observe() method, can take options allowing authors to customize what is observed for each callback. This isn’t possible with addEventListener().
</li>
	<li>
複数個の~callbackを~listenしているときでも、
~Observer ~objの［
`disconnect()^c ／ `unobserve()^c
］~methodを利用すれば，容易に停止できる。
◎
It’s easy to stop listening on multiple callbacks using the disconnect() or unobserve() method on the Observer object.
</li>
	<li>
`takeRecords()^c の様な
— ~eventが発火されるまで待機する代わりに，関連な~dataを即時に~fetchするような —
~methodを供する~optionもある。
◎
You have the option to provide a method like takeRecords(), which immediately fetches the relevant data, instead of waiting for an event to fire.
</li>
	<li>
観測器は単-目的なので、
~event型を指定する必要は無い。
◎
Because Observers are single-purpose, you don’t need to specify an event type.
</li>
</ul>

<p>
~Observer と `EventTarget$I
の共通~~点は：
◎
Observers and EventTargets have these things in common:
</p>
<ul>
	<li>
どちらも，作成~時に~custom化できる。
◎
Both can be customized at creation time.
</li>
	<li>
どちらも，一連の生じた事象を~batchでき, どの時点でも送達できる。
`EventTarget$I は、
同期的になる必要はない
— 送達する時機には［
`小task$,
`遊休~期間＠~REQUESTIDLECALLBACK#dfn-idle-period$,
`~animation~frame＠~HTMLGAPI#animation-frames$,
等々
］を利用できる。
~Observer は、
特別な［
時機／~batch法
］を取得する必要はない。
◎
Both can batch occurrences and deliver them at any time. EventTargets don’t need to be synchronous; they can use microtask timing, idle timing, animation-frame timing, etc. You don’t need an Observer to get special timing or batching.
</li>
	<li>
どちらも，~DOM~tree（［
浮上／捕捉
］と取消n）に関与する必要はない。
`EventTarget$I として真っ先に挙がるものは，~DOM~tree内の `Node$I であるが、
他の多くの~eventも自立的である
— 例： `IDBDatabase$I, `XMLHttpRequestEventTarget$I
。
`Node$I を利用しているときでも，~eventは［
浮上しない／取消-可能でない
］ものに設計し得る。
◎
Neither EventTargets nor Observers need to participate in a DOM tree (bubbling/capture and cancellation). Most prominent EventTargets are Nodes in the DOM tree, but many other events are standalone; for example, IDBDatabase and XMLHttpRequestEventTarget. Even when using Nodes, your events may be designed to be non-bubbling and non-cancelable.
</li>
</ul>

<div class="example">
<p>
仮に，
`IntersectionObserver$I の［
`EventTarget$I の下位class~version
］があったとするとき、
それを利用する例：
◎
Here is an example of using a hypothetical version of IntersectionObserver that’s an EventTarget subclass:
</p>

<pre class="lang-js">
const %io = new ETIntersectionObserver(%element, { %root, %rootMargin, %threshold });

function listener(%e) {
    for (const %change of %e.changes) {
        // ...
    }
}

%io.addEventListener("intersect", %listener);
%io.removeEventListener("intersect", %listener);
</pre>

<p>
~Observer ~versionに比較して：
◎
Compared to the Observer version:
</p>
<ul>
	<li>
複数の要素を同じ~option群で観測するのは、
より困難になる。
◎
it’s more difficult to observe multiple elements with the same options;
</li>
	<li>
~dataを即時に要請する仕方は無い。
◎
there is no way to request data immediately;
</li>
	<li>
同じ~event用に複数の~event~listenerを除去するために，より作業を要する。
◎
it’s more work to remove multiple event listeners for the same event;
</li>
	<li>
作者は、
冗長な "`intersect^et" ~event型を供する必要がある。
◎
the author has to provide a redundant "intersect" event type.
</li>
</ul>

<p>
~Observer ~versionとの共通~~点は：
◎
In common with the Observer version:
</p>
<ul>
	<li>
依然として~batch法を行える
◎
it can still do batching;
</li>
	<li>
時機は同じ
（~JS~event~queueに基づく）
◎
it has the same timing (based on the JavaScript event queue);
</li>
	<li>
作者は、
依然として，何を~listenするか~custom化できる。
◎
authors can still customize what to listen for; and
</li>
	<li>
~eventは、［
捕捉~相／浮上~相
］を通って行くことはない。
◎
events don’t go through capture or bubbling.
</li>
</ul>

<p>
これらの側面は、
どちらの設計でも達成できる。
◎
These aspects can be achieved with either design.
</p>
</div>

<p>
次も見よ
⇒＃
`§ 通知~用には~eventを利用すること＠#events-are-for-notification$／
<a href="#state-and-subclassing">§ 状態~用には素な `Event^I を利用すること</a>
◎
See also:
• § 7.5 Use events for notification
• § 7.7 Use plain Events for state
</p>

		</section>
	</section>
	<section id="types-and-units">
<h2 title="Web IDL, Types, and Units">8. ~Web~IDL, 型, 単位</h2>

		<section id="numeric-types">
<h3 title="Use numeric types appropriately">8.1. 数量-型を適切に利用すること</h3>

<p>
設計している~APIが~JS `number^jT
【~JS `Number$jT 型の値。以下、単に `number^jT と略記する】
を利用する場合、
次に挙げるいずれかの`~IDL数量-型$ `WEBIDL$r を利用すること
— そうしない特有な理由がない限り：
◎
If an API you’re designing uses numbers, use one of the following [WEBIDL] numeric types, unless there is a specific reason not to:
</p>
<dl>
	<dt>`unrestricted double$c</dt>
	<dd>
任意の `number^jT
— ［
`infinity^jv, `-infinity^jv, `NaN^jv
］も含む
◎
Any JavaScript number, including infinities and NaN
</dd>

	<dt>`double$c</dt>
	<dd>
任意の `number^jT
— ［
`infinity^jv, `-infinity^jv, `NaN^jv
］は含まない
◎
Any JavaScript number, excluding infinities and NaN
</dd>

	<dt>`EnforceRange$xA `long long$c</dt>
	<dd>
任意の `number^jT のうち［
−2<sup>63</sup> 以上 2<sup>63</sup> 以下
］のもの
— 最も近い整数に丸められる。
この範囲に入らない `number^jT が与えられた場合、
生成される言語束縛は `TypeError$E を投出することになる。
◎
Any JavaScript number from -263 to 263, rounded to the nearest integer. If a number outside this range is given, the generated bindings will throw a TypeError.
</dd>

	<dt>`EnforceRange$xA `unsigned long long$c</dt>
	<dd>
任意の `number^jT のうち［
0 以上 2<sup>64</sup> 以下
］のもの
— 最も近い整数に丸められる。
この範囲に入らない `number^jT が与えられた場合、
生成される言語束縛は `TypeError$E を投出することになる。
◎
Any JavaScript number from 0 to 264, rounded to the nearest integer. If a number outside this range is given, the generated bindings will throw a TypeError.
</dd>
</dl>

<p>
~JSの数量-型は、
`Number$jT しかなく，それは［
~IEEE 754 倍精度~浮動小数点~数,
`0^jv,
`-0^jv,
`infinity^jv,
`-infinity^jv,
`NaN^jv
］を含む。
`~IDL数量-型$は、
任意の `number^jT を，ある［
特定0の~propを伴う下位集合
］に所属するよう改変するための規則を表現する。
これらの規則は、
`number^jT が~IDLにて定義される~interfaceの［
~method／~prop設定子
］に渡されたとき，走る。
◎
JavaScript has only one numeric type, Number: IEEE 754 double-precision floating point, including ±0, ±Infinity, and NaN. [WEBIDL] numeric types represent rules for modifying any JavaScript number to belong to a subset with particular properties. These rules are run when a number is passed to the interface defined in IDL, whether a method or a property setter.
</p>

<p>
`number^jT に適用される必要がある加的な規則がある場合、
当の仕様の~algo内で指定できる。
◎
If you have extra rules which need to be applied to the number, you can specify those in your algorithm.
</p>

<div class="note">

<p>注記：
`number^jT を~bit数がより少ない`~IDL数量-型$
（ `octet$c （ 8~bit, 範囲 { 0 〜 255 } ）など）
に変換するための
`~Web~IDL規則＠~WEBIDLjs#es-integer-types$は、
`number^jT の剰余をとることを孕む。
例えば， `number^jT 値 `300^jv を `octet$c に変換するとき、
言語束縛は最初に `300^jv に対し 255 による剰余を算出することになるので，結果は 45 になる
— それは、
意に反するかもしれない。
◎
The WEBIDL rules for converting a JavaScript number to a number with fewer bits, such as an octet (8 bits, in the range [0, 255]), involves taking the modulo of the JavaScript number. For example, to convert a JavaScript number value of 300 to an octet, the bindings will first compute 300 modulo 255, so the resulting number will be 45, which might be surprising.
</p>

<p>
代わりに次のいずれかを利用できる：
◎
Instead, you can use＼
</p>
<ul>
	<li>

<code>`EnforceRange$xA octet</code>
を利用して， `octet$c 範囲に入らない値に対し `TypeError$E を投出する
◎
[EnforceRange] octet to throw a TypeError for values outside of the octet range,＼
</li>
	<li>
<code>`Clamp$xA `octet$c</code> を利用して，値を~octet範囲に切詰める（例えば 300 を 255 に変換する）
◎
or [Clamp] octet to clamp values to the octet range (for example, converting 300 to 255).
</li>
</ul>

<p>
これは、［
`short$c や `long$c
］などの他の より短い型に対しても働く。
◎
This also works for the other shorter types, such as short or long.
</p>
</div>

<p>
`bigint$c の利用は、
~~絶対値が 2<sup>53</sup> を超える値が予期されるときに限るべきである。
◎
bigint should be used only when values greater than 253 or less than -253 are expected.
</p>

<p>
~APIは、［
`BigInt$jT, `Number$jT
］の両方を
— ［
多形態性【すなわち，`共用体~型$】を介して両~型を~supportする／
別々な，他は一致するが［
`BigInt$jT をとる~API, `Number$jT をとる~API
］を追加する【すなわち，`多重定義-$する】
］ことにより —
同時に~supportするべきでない。
これには、
暗黙的な変換を通して精度を失う~riskがあり，
`BigInt$jT の目的を無為にする。
◎
An API should not support both BigInt and Number simultaneously, either by supporting both types via polymorphism, or by adding separate, otherwise identical APIs which take BigInt and Number. This risks losing precision through implicit conversions, which defeats the purpose of BigInt.
</p>

		</section>
		<section id="idl-string-types">
<h3 title="Represent strings appropriately">8.2. 文字列を適切に表現すること</h3>

<p>
`文字列$に対し演算する~web~platform特能を設計するときは、
特有な理由がある場合を除き，
`DOMString$I を利用すること。
◎
When designing a web platform feature which operates on strings, use DOMString unless you have a specific reason not to.
</p>

<p>
ほとんどの文字列~演算は、
文字列の内側の`符号単位$を解釈する必要はないので，
`DOMString$I が最善な選択になる。
下に説明される特定の事例では、
代わりに［
`USVString$I ／ `ByteString$I
］を利用する方が適切になるかもしれない。
`INFRA$r
`WEBIDL$r
◎
Most string operations don’t need to interpret the code units inside of the string, so DOMString is the best choice. In the specific cases explained below, it might be appropriate to use either USVString or ByteString instead. [INFRA] [WEBIDL]
</p>

<p>
`USVString$I は、
`~scalar値~文字列$を表現する~Web~IDL型である。
［
文字列のうち，最も共通的な~algoは`~scalar値$に対し演算するもの
（`~percent-符号化法＠~URL1#percent-encode$など）／
入力~内の`~surrogate$を取扱えない演算
（文字列を~nativeな~platform~APIに そのまま渡す~APIなど）
］用には、
`USVString$I を利用するべきである。
◎
USVString is the Web IDL type that represents scalar value strings. For strings whose most common algorithms operate on scalar values (such as percent-encoding), or for operations which can’t handle surrogates in input (such as APIs that pass strings through to native platform APIs), USVString should be used.
</p>

<div class="example">
~IDL属性のうち，［
`~URL$を包含するよう定義される内容~属性
（ `href＠~HTMLlinks#attr-hyperlink-href$a `HTML$r など）
］を`反映-$するものには、
`USVString$I を利用するべきである。
◎
Reflecting IDL attributes whose content attribute is defined to contain a URL (such as href) should use USVString. [HTML]
</div>

<p>
`ByteString$I は、［
~HTTPの様な，~byte列と文字列を判別しない~protocol
］からの~dataを表現するために限り，利用するべきである。
それは、
一般~目的な文字列~型ではない。
`byte$c たちが成す`連列~型$を表現する必要がある場合、
`Uint8Array$I を利用すること。
◎
ByteString should only be used for representing data from protocols like HTTP which don’t distinguish between bytes and strings. It isn’t a general-purpose string type. If you need to represent a sequence of bytes, use Uint8Array.
</p>

		</section>
		<section id="milliseconds">
<h3 title="Use milliseconds for time measurement">8.3. 時間~測定には~milli秒を利用すること</h3>

<p>
設計している~APIが時間~測定を受容する場合、
時間~測定を~milli秒で表出すること。
◎
If you are designing an API that accepts a time measurement, express the time measurement in milliseconds.
</p>

<p>
当の~APIの分野においては秒（または他の何らかの時間~単位）の方が自然であっても、
~milli秒を堅持することは，当の~APIが別の~APIと相互運用可能になることを確保する。
これは、
作者にとって［
ある~APIで利用される値を別の~APIに利用するために変換する／
どこで, どの時間~単位が必要になるか追跡し続ける
］必要がなくなることを意味する。
◎
Even if seconds (or some other time unit) are more natural in the domain of an API, sticking with milliseconds ensures that APIs are interoperable with one another. This means that authors don’t need to convert values used in one API to be used in another API, or keep track of which time unit is needed where.
</p>

<p>
この規約は、［
`setTimeout()＠~HTMGAPI#dom-settimeout$c ／
`Date$jT
］~APIから始まり，その頃から利用されている。
◎
This convention began with setTimeout() and the Date API, and has been used since then.
</p>

<p class="note">注記：
高分解能な時刻は、
通例的に小数を伴う~milli秒として表現され，浮動小数点~値を利用している
— ~nano秒の様な より小さな時間~単位による整数~値としてではなく。
◎
Note: high-resolution time is usually represented as fractional milliseconds using a floating point value, not as an integer value of a smaller time unit like nanoseconds.
</p>

		</section>
		<section id="times-and-dates">
<h3 title="Use the appropriate type to represent times and dates">8.4. 時刻と日付を表現するときは適切な型を利用すること</h3>

<p>
~platformで日時を表現するときは、
`DOMHighResTimeStamp$I 型を利用すること。
`DOMHighResTimeStamp$I は、
利用者の時刻~設定に関わらず，時刻印を比較することを許容する。
◎
When representing date-times on the platform, use the DOMHighResTimeStamp type. DOMHighResTimeStamp allows comparison of timestamps, regardless of the user’s time settings.
</p>

<p>
`DOMHighResTimeStamp$I 値は、
時刻~値を~milli秒で表現する。
詳細は `HIGHRES-TIME$r を見よ。
◎
DOMHighResTimeStamp values represent a time value in milliseconds. See [HIGHRES-TIME] for more details.
</p>

<p>
~JS `Date$jT ~classは、
特定の日時~値を表現するためとして，利用しないこと。
`Date$jT ~objは変異-可能であり（それらの値は、変更され得る），
それを変異-不能にする仕方は無い。
◎
Don’t use the JavaScript Date class for representing specific date-time values. Date objects are mutable (may have their value changed), and there is no way to make them immutable.
</p>

<p class="note">注記：
なぜ `Date$jT を利用してはナラナイかの背景0は、
次を見よ
⇒＃
`es-discuss^en における `Frozen date objects?＠https://esdiscuss.org/topic/frozen-date-objects$en ／
~Web~IDL `Bugzilla^en における`~Web~IDLから Date を除去する＠https://www.w3.org/Bugs/Public/show_bug.cgi?id=22824$
◎
For more background on why Date must not be used, see the following:
• Frozen date objects? on es-discuss
• Remove Date from Web IDL on the Web IDL Bugzilla
</p>

		</section>
		<section id="error-types">
<h3 title="Use Error or DOMException for errors">8.5. ~error用には `Error^I ／ `DOMException^I を利用すること</h3>

<p>
~web~APIにおける~errorは、［
例外, ~promise用の却下~値, ~prop
］いずれにせよ，［
~ES~error~obj【`単純~例外$】（例：`Error$E ）／
`DOMException$I
］として表現すること。
◎
Represent errors in web APIs as ECMAScript error objects (e.g., Error) or as DOMException. whether they are exceptions, promise rejection values, or properties.
</p>

		</section>
	</section>
	<section id="device-apis">
<h2 title="OS and Device Wrapper APIs">9. ~OSや装置を包装する~API</h2>

<p>
~web~platformでは、
装置とヤリトリするための新たな~APIが今や開発されている。
例えば作者は、［
次に挙げるもの等々を接続するために，~webを利用する
］ことも可能にしたいと望む
⇒＃
`~microphoneや~camera＠~TR/mediacapture-streams/$／
`汎用~sensor＠~SENSORS$（~gyroscopeや加速度計など）／
`~Bluetooth＠https://www.w3.org/community/web-bluetooth/$／
`~USB＠https://wicg.github.io/webusb/$に接続される周辺機器／
`~~自動化＠https://www.w3.org/community/autowebplatform/$（ `automobile^en 【 `automotive^en 】 ）
◎
New APIs are now being developed in the web platform for interacting with devices. For example, authors wish to be able to use the web to connect with their microphones and cameras, generic sensors (such as gyroscope and accelerometer), Bluetooth and USB-connected peripherals, automobiles, etc.
</p>

<p>
これらの機能性は、
下層の~OSから供されることも，［
装置とヤリトリする~nativeな第三者-主体~library
］から供されることもある。
これらは、
有意な複階性を導入することなく，~nativeな機能性を［
~browserへの~API表面を~secure化する
］よう “包装する” 抽象-化であり、
“（何かを）包装する~API（ `wrapper API^en ）” と呼ばれる。
◎
These can be functionality provided by the underlying operating system, or provided by a native third-party library to interact with a device. These are an abstraction which "wrap" the native functionality without introducing significant complexity, while securing the API surface to the browser. So, these are called wrapper APIs.
</p>

<p>
この節では、
装置~用の~APIを設計するとき考慮に入れる原則を述べる。
◎
This section contains principles for consideration when designing APIs for devices.
</p>

		<section id="device-ids">
<h3 title="Use care when exposing identifying information about devices">9.1. 装置について識別する情報を公開するときの注意点</h3>

<p>
装置についての情報への~accessを~web~siteに与える必要がある場合、
情報として何を公開するかを裁定する際に，以下に与える指針を利用すること。
◎
If you need to give web sites access to information about a device, use the guidelines below to decide what information to expose.
</p>

<p>
まず，［
装置について識別する情報をすべて公開することは，本当に必要yであるかどうか
］を注意深く考すること。
`利用者の必要性＠#priority-of-constituencies$は，
強力さに劣る~APIでも満足されるかどうか考慮すること。
◎
Firstly, think carefully about whether it is really necessary to expose identifying information about the device at all. Consider whether your user needs could be satisfied by a less powerful API.
</p>

<p>
装置の有無や［
装置／装置~識別子
］についての情報を追加的に公開することは、
各~利用者の~privacyを害する~riskを増やす。
◎
Exposing the presence of a device, additional information about a device, or device identifiers, each increase the risk of harming the user’s privacy.
</p>

<p>
特有な情報が共有されるほど，
~siteに可用になる`指紋収集~data＠~TR/fingerprinting-guidance/$が成す集合が~~増す~riskがある。
利用者の~privacyには、
`他の~riskの能性＠https://w3cping.github.io/privacy-threat-model/$
もある。
◎
One risk is that as more specific information is shared, the set of fingerprinting data available to sites gets larger. There are also other potential risks to user privacy.
</p>

<p class="issue">
~privacyの脅威~modelは、
まだ~~未熟な~~段階である。
◎
Privacy Threat Model is not ready for prime time.
</p>

<p>
強力さに劣る~APIを設計する仕方は無い場合、
装置~情報を公開するときは，次に挙げる指針を利用すること：
◎
If there is no way to design a less powerful API, use these guidelines when exposing device information:
</p>
<dl>
	<dt>
当の~ID内の情報は制限すること：
◎
Limit information in the id
</dt>
	<dd>
~web~platformに公開される装置~ID内に含める識別-可能な情報は、
アリな限り抑えること。
識別-可能な情報として、
銘柄, 製造元, ~model番号, 等々が挙げられる。
通例的には、
代わりに［
~randomな数／一意な~ID
］を利用できる。
~IDは、
推測-不能かつ再利用されないようにすること。
◎
Include as little identifiable information as possible in device ids exposed to the web plaform. Identifiable information includes branding, make and model numbers, etc You can usually use a random number or a unique id instead. Make sure that your ids aren’t guessable, and aren’t re-used.
</dd>

	<dt>
利用者の制御~下に保つこと：
◎
Keep the user in control
</dt>
	<dd>
利用者が閲覧~dataを~clearするよう選んだときは、
格納された装置~IDも~clearすること。
◎
When the user chooses to clear browsing data, make sure any stored device ids are cleared.
</dd>

	<dt>
敏感な~IDは利用者~許可の背後に隠すこと：
◎
Hide sensitive ids behind a user permission
</dt>
	<dd>
匿名な仕方で装置~IDを作成できない場合、
それへの~accessを制限すること。
この情報に~accessしている~web~pageに対し，
利用者が`有意義な同意＠#consent$を供せるようにすること。
◎
If you can’t create a device id in an anonymous way, limit access to it. Make sure the user can provide meaningful consent to a Web page accessing this information.
</dd>

	<dt>
~IDを同一-生成元~modelに束ねること：
◎
Tie ids to the same-origin model
</dt>
	<dd>
同じ物理-装置に対し、
各~生成元ごとに，それへの~accessを有する別個な一意な~IDを作成すること。
◎
Create distinct unique ids for the same physical device for each origin that has has access to it.
</dd>
	<dd>
同じ装置が同じ生成元により複数回 要請された場合、
それ用には同じ~IDを返すこと
（利用者が自身の閲覧~dataを~clearした場合は除く）。
これは、
同じ装置をいくつも複製するのを避けることを作者に許容する。
◎
If the same device is requested more than once by the same origin, return the same id for it (unless the user has cleared their browsing data). This allows authors to avoid having several copies of the same device.
</dd>

	<dt>
必要yなら、
持続-可能にすること：
◎
Persistable when necessary
</dt>
	<dd>
装置~IDを得するのに時間がかかる場合、
作者が［
ある~sessionで生成された~IDを後の~sessionにおける利用~用に格納できる
］ようにすること。
これは、
次のようにすることにより行える
⇒
当の~IDを生成する手続-は、［
同じ生成元，同じ装置
］に対しては，一貫して同じ~IDを生産する
◎
If a device id is time consuming to obtain, make sure authors can store an id generated in one session for use in a later session. You can do this by making sure that the procedure to generate the id consistently produces the same id for the same device, for each origin.
</dd>
</dl>

<p>
次も見よ
⇒＃
`LEAST-POWER$r／
`FINGERPRINTING-GUIDANCE$r／
`UNSANCTIONED-TRACKING$r
◎
See also:
• [LEAST-POWER]
• [FINGERPRINTING-GUIDANCE]
• [UNSANCTIONED-TRACKING]
</p>

		</section>
		<section id="device-enumeration">
<h3 title="Use care when exposing APIs for selecting or enumerating devices">9.2. 装置を［選定する／列挙する］~APIを公開するときの注意点</h3>

<p>
各~装置を列挙するのは避ける仕方を探すこと。
避けれない場合でも、
公開される情報はアリな限り少量にすること。
◎
Look for ways to avoid enumerating devices. If you can’t avoid it, expose the least information possible.
</p>

<p>
ある~APIが複数個の装置の［
存在／能力／識別子
］を公開する場合、
`§ 装置について識別する情報を公開するときの注意点＠#device-ids$
におけるすべての~riskが，装置の個数だけ乗算される。
同じ理由で、［
`利用者の必要性＠#priority-of-constituencies$が強力さに劣る~APIでも満足できるかどうか
］を考慮すること。
`LEAST-POWER$r
◎
If an API exposes the the existence, capabilities, or identifiers of more than one device, all of the risks in § 9.1 Use care when exposing identifying information about devices are multiplied by the number of devices. For the same reasons, consider whether your user needs could be satisfied by a less powerful API. [LEAST-POWER]
</p>

<p>
~APIの目的が［
特定0の種類の可用な装置たちが成す集合から`装置を選定する^strongこと
］を利用者に可能化することにある場合、
その~listを~scriptに公開する必要はまったくなく，
~UAが供した装置~pickerを呼出す~APIで足り得るであろう。
そのような~APIは：
◎
If the purpose of the API is to enable the user to select a device from the set of available devices of a particular kind, you may not need to expose a list to script at all. An API which invokes a User-Agent-provided device picker could suffice. Such an API:
</p>
<ul>
	<li>
利用者の制御~下に保つこと。
◎
keeps the user in control,
</li>
	<li>
装置~情報は、
`利用者の同意＠#consent$を経ない限り，公開しないこと,
◎
doesn’t expose any device information without the user’s consent,
</li>
	<li>
既定では、
利用者の環境についての指紋収集~dataを公開しないこと。
◎
doesn’t expose any fingerprinting data about the user’s environment by default, and
</li>
	<li>
一回に情報を公開する装置の個数は 1 個に限ること。
◎
only exposes information about one device at a time.
</li>
</ul>

<p>
［
装置を選定することを利用者に許容する~API
］を設計するとき，［
選び取られた装置が可用である事実
］も公開することが必要yあり得る。
これは、［
利用者の環境についての一片の指紋収集~data
］を~web~siteに公開するので、
そのような特能を備えない~APIほどには安全でない。
◎
When designing API which allows users to select a device, it may be necessary to also expose the fact that there are devices are available to be picked. This does expose one bit of fingerprinting data about the user’s environment to websites, so it isn’t quite as safe as an API which doesn’t have such a feature.
</p>

<div class="example">
<p>
`RemotePlayback$I ~interfaceは、
可用な`~remote再生~装置＠https://w3c.github.io/remote-playback/#dfn-remote-playback-devices$たちが成す~listを公開しない。
代わりに，［
~UAが供する装置~pickerから 1 つの装置を選ぶ
］ことを利用者に許容する。
◎
The RemotePlayback interface doesn’t expose a list of available remote playback devices. Instead, it allows the user to choose one device from a device picker provided by the User Agent.
</p>

<p>
それは，［
`~remote再生~装置＠https://w3c.github.io/remote-playback/#dfn-remote-playback-devices$は可用かどうか検出する
］ことを~web~siteに可能化するので、
当の~web~siteは，［
利用者が装置~pickerを示すために利用できる~control
］を［
示せる／隠せる
］。
◎
It does enable websites to detect whether or not any remote playback device is available, so the website can show or hide a control the user can use to show the device picker.
</p>

<p>
この加的な情報~片を~web~siteに許容する~trade-offとして、
この~APIは，作者が次を選べるようにする
⇒
可用な装置がある場合に限り，~pickerを誘発する~buttonを示すことにより、
自身の~UIを もっと判り易くする
◎
The trade-off is that by allowing websites this extra bit of information, the API lets authors make their user interface less confusing. They can choose to show a button to trigger the picker only if at least one device is available.
</p>
</div>

<p>
装置たちが成す~listを公開しなければナラナイ場合、［
利用者の必要性を満足するのに`必要最小限な下位集合^strongを公開する
］よう努めること。
◎
If you must expose a list of devices, try to expose the smallest subset that satisfies your user needs.
</p>

<p>
例えば［
`絞込まれ, 拘束された^strong装置~listを要請する
］ことを~web~siteに許容する~APIは、
装置の個数をより少なく保つ~optionの一つを成す。
しかしながら，［
異なる拘束を伴う，複数個の要請
］を為すことが作者に許容された場合、
それにより，全部的な~listに~access可能になり得る。
◎
For example, an API which allows the website to request a filtered or constrained list of devices is one option to keep the number of devices smaller. However, if authors are allowed to make multiple requests with different constraints, they may still be able to access the full list.
</p>

<p>
最後に，特定0の種類に属する装置~群の全部的な~listを公開しなければナラナイ場合、
それら装置が~listされる順序を`厳格に定義する^strongこと。
これは、
相互運用能の課題を抑制し得ることに加え，指紋収集を軽減する助けにもなる。
（~sort順序は、
他の情報を露呈することもある
— `~web仕様における~browser指紋収集の軽減-法^cite `§ 標準~化＠https://w3c.github.io/fingerprinting-guidance/#standardization$
を見よ。）
◎
Finally, if you must expose the full list of devices of a particular kind, please rigorously define the order in which devices will be listed. This can reduce interoperability issues, and helps to mitigate fingerprinting. (Sort order could reveal other information: see Mitigating Browser Fingerprinting in Web Specifications § 6.2 Standardization for more.)
</p>

<p class="note">注記：
~APIは、
装置の全部的な~listを`実装定義$な順序で公開するべきではないが，~web互換性の理由からそれが必要になることもある。
◎
Note: While APIs should not expose a full list of devices in an implementation-defined order, they may need to for web compatibility reasons.
</p>

		</section>
		<section id="usecase-oriented-apis">
<h3 title="Design based on user needs, not the underlying API or hardware">9.3. 下層の~APIや~hardwareではなく利用者の必要性に基づいて設計すること</h3>

<p>
~webに持込まれる新たな~native能力は、
利用者の必要性に基づいて公開すること。
◎
Expose new native capabilities being brought to the web based on user needs.
</p>

<p>
既存の~native~APIを~webへ直に翻訳するのは避けること。
◎
Avoid directly translating an existing native API to the web.
</p>

<p>
代わりに，［
当の~native~APIにて可用な機能性, それが取組む利用者の必要性
］を考慮して、
実装が既存の~native~APIに依存する場合でも，
利用者の必要性を満たす~APIを設計すること。
◎
Instead, consider the functionality available from the native API, and the user needs it addresses, and design an API that meets those user needs, even if the implementation depends on the existing native API.
</p>

<p>
下層の~native~APIの正確な［
~lifecycle／~data構造
］を公開することについて、
特に気を付けること。
アリなときは、
新たな~hardware用の柔軟性を考慮すること。
◎
Be particularly careful about exposing the exact lifecycle and data structures of the underlying native APIs. When possible, consider flexibility for new hardware.
</p>

<p>
このことは、
新たに提案される~APIは，［
それが，どう利用されるものと意図されるか
］を注意深く考慮する下で設計されるべきであることを意味する
— 下層の［
~hardware／装置／~native~API
］が今日にて どう可用かではなく。
◎
This means newly proposed APIs should be designed with careful consideration on how they are intended to be used rather than how the underlying hardware, device, or native API available today.
</p>
		</section>
		<section id="hardware-is-scary">
<h3 title="Be proactive about safety">9.4. 安全性について事前に備えておくこと</h3>

<p>
~web~platformに~native能力を持込むときは、
防御的に設計するよう努めること。
◎
When bringing native capabilities to the web platform, try to design defensively.
</p>

<p>
~native能力を~web~platformに持込むことには、
多くの含意がつきまとう。
利用者は、
自身の~computerが特有な能力を備えることを~web~siteに知らせたいとは求めないであろう。
したがって，論理的な生成元~境界の外側にある何かへの~accessは、
許可を介して通過制御されるべきである。
◎
Bringing a native capability to the web platform comes with many implications. Users may not want websites to know that their computers have specific capabilities. Therefore, access to anything outside of the logical origin boundary should be permission gated.
</p>

<p>
例えば，［
状態を格納し得る装置があって，その状態は複数の生成元から同時に読取n可能である
］場合、
その状態を一群の~APIから［
読取れる／書込める
］ようにすることは，実質的に［
~webの生成元~modelを損なう~side-channel【〜攻撃の余地を与えるもの】
］になる。
◎
For example, if a device can store state, and that state is readable at the same time by multiple origins, a set of APIs that lets you read and write that state is effectively a side-channel that undermines the origin model of the web.
</p>

<p>
これらの理由から、
当の装置が排他的でない~accessを許容する場合でも，［
生成元ごとに排他的な~accessを施行するか、
更には，現在~作動中な~UItabに限るよう制約する
］ことを考慮することになろう。
◎
For these reasons, even if the device allows non-exclusive access, you may want to consider enforcing exclusive access per-origin, or even restricting it further to only the current active tab.
</p>

<p>
加えて，~APIは、
物理的な遮断
— 当の装置がとり外されているなど —
を~appが上品に取扱えるよう，設計されるべきである。
◎
Additionally, APIs should be designed so that the applications can gracefully handle physical disruption, such as a device being unplugged.
</p>

		</section>
		<section id="wrapper-apis">
<h3 title="Adapt native APIs using web platform principles">9.5. ~native~APIに順応するときは、~web~platform原則を利用すること</h3>

<p>
~OSに~nativeな~APIを~web用に順応するときは、
~web~platform原則を念頭に置いて，新たな~web~APIを設計すること：
◎
When adapting native operating system APIs for the web, make sure the new web APIs are designed with web platform principles in mind.
</p>
<dl>
	<dt>
~web~APIは、
複数の~platformで実装できるようにすること。
◎
Make sure the web API can be implemented on more than one platform
</dt>
	<dd>
何かを包装する~APIを設計するときは、
各種~platformが その機能性をどう供するか考慮すること。
◎
When designing a wrapper API, consider how different platforms provide its functionality.
</dd>
	<dd>
理想的には，すべての実装が正確に同じに働くべきであるが、
一部の事例では，一部の~platformでしか働かない~optionを公開する理由もあろう。
それに該当する場合、［
作者は、
すべての~platformで働く~codeを どう書するべきか
］を説明すること。
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$を見よ。
◎
Ideally, all implementations should work exactly the same, but in some cases you may have a reason to expose options which only work on some platforms. If this happens, be sure to explain how authors should write code which works on all platforms. See § 2.5 New features should be detectable.
</dd>

	<dt>
下層の~protocolは、
~openになるべきである
◎
Underlying protocols should be open
</dt>
	<dd>
外部［
~hardware／~service
］との交換を要求する~APIは、［
~openでない／~proprietaryな
］~protocolに依存するべきでない。
~openでない~protocolに依存することは、
~webの~openな資質を損なう。
◎
APIs which require exchange with external hardware or services should not depend on closed or proprietary protocols. Depending on non-open protocols undermines the open nature of the web.
</dd>

	<dt>
利用者が~off-lineであるときも取扱うよう，~APIを設計すること
◎
Design APIs to handle the user being off-line
</dt>
	<dd>
~APIが［
~remote~serverにより供される何らかの~service
］に依存する場合、［
利用者が何らかの理由で~remote~serverに~accessできないとき
］でも，~APIがきちんと機能するようにすること。
◎
If an API depends on some service which is provided by a remote server, make sure that the API functions well when the user can’t access the remote server for any reason.
</dd>

	<dt>
追加的な指紋収集~表口を避けること
◎
Avoid additional fingerprinting surfaces
</dt>
	<dd>
何かを包装する~APIは、
意図的でなくとも，より広い指紋収集~表口に利用者を晒し得る。
追加的な詳細は、
~TAGによる知見
`野放図な追跡＠https://www.w3.org/2001/tag/doc/unsanctioned-tracking/$cite
を読されたし。
◎
Wrapper APIs can unintentionally expose the user to a wider fingerprinting surface. Please read the TAG’s finding on unsanctioned tracking for additional details.
</dd>
</dl>

		</section>
	</section>
	<section id="other-considerations">
<h2 title="Other API Design Considerations">10. ~API設計における他の考慮点</h2>

		<section id="polyfills">
<h3 title="Enable polyfills for new features">10.1. 新たな特能~用には~polyfillを可能化すること</h3>

<p>
~polyfillは、
新たな特能が~web~platformに普及する助けになるものとして，多大に有益になり得る。
~TAGによる
`~polyfillと~webの発展に対する知見＠https://www.w3.org/2001/tag/doc/polyfills/$cite
は、
新たな特能の開発において考慮されるべき指導を提供する
— 特に：
◎
Polyfills can be hugely beneficial in helping to roll out new features to the web platform. The Technical Architecture Group finding on Polyfills and the Evolution of the Web offers guidance that should be considered in the development of new features, notably:
</p>
<ul>
	<li>
“~polyfill可能” であることは、
本質的ではないが，`有益である^strong。
◎
Being "polyfillable" isn’t essential but is beneficial
</li>
	<li>
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$。
◎
§ 2.5 New features should be detectable
</li>
	<li>
~polyfillの開発は、
奨励されるべきである。
◎
Polyfill development should be encouraged
</li>
</ul>

		</section>
		<section id="consider-dedicatedworker-support">
<h3 title="Where possible APIs should be made available to dedicated workers">10.2. ~APIはアリな所では専用~workerにも可用にされるベキである</h3>

<p>
特能を公開するときは、［
当の特能を専用~workerにも
（ `DedicatedWorkerGlobalScope$I ~interfaceを介して）
公開することはイミを成すかどうか
］について考慮されたし。
◎
When exposing a feature, please consider whether it makes sense to expose the feature to dedicated workers (via the DedicatedWorkerGlobalScope interface).
</p>

<p>
多くの特能は、
専用~worker上でも，そのままで働ける
— 当の特能をそこで可能化しないことは、［
その利用者が，自身の~codeを他を阻まない方式で走らす能
］を制限することにもなり得る。
◎
Many features could work out of the box on dedicated workers and not enabling the feature there could limit the ability for users to run their code in a non-blocking manner.
</p>

<p>
ある特能を専用~workerでも公開しようと試行するとき，ある種の難題が存在し得る
— とりわけ、
当の特能が［
許可を依頼する／
~pickerや選定器を示す
］ような利用者~入力を要求する場合に。
これは［
仕様~策定者が専用~workerを~supportするのを忌避させる
］かもしれないが，それでも、［
専用~worker用の~supportを念頭に，当の特能を設計する
］ことが推奨される
— ［
後で，当の~APIを専用~workerに公開する
］ことが［
不必要に難しくなるような前提
］を追加しないために。
◎
Certain challenges can exist when trying to expose a feature to dedicated workers, especially if the feature requires user input by asking for permission, or showing a picker or selector. Even though this might discourage spec authors to support dedicated workers, we still recommend designing the feature with dedicated worker support in mind, in order to not add assumptions that will later make it unnecessarily hard to expose these APIs to dedicated workers.
</p>

			<section id="worker-only">
<h4 title="Some APIs should only be exposed to dedicated workers">10.2.1. 一部の~APIは専用~workerに限り公開するベキである</h4>

<p>
開発者たちは、
複階的な~codeより単純な~codeを選好する。
彼らは、
所与の~APIにて許容される仕方のうち最も単純なものを利用する見込みが高い。
◎
Developers prefer simple code to complex code. They are more likely to use an API in the simplest way the API allows.
</p>

<p>
重要なのは、
具現化を阻む特能を追加するのは，避けることである。
`§ 具現化を阻む特能は避けること＠#avoid-render-blocking$を見よ。
◎
It’s important to avoid adding features that block rendering. § 3.4 Avoid features that block rendering
</p>

<p>
~APIを最も容易な仕方で利用すると［
具現化を阻む／
“`カクつく＠https://developer.mozilla.org/en-US/docs/Glossary/Jank$”
］結果になる見込みが高い場合、
利用者~体験に難が生じることなる。
（この問題は、
低性能な
— 社会的弱者ほど利用する見込みが高い —
機器ほど顕著になる。
`~webは、すべての人々のためにある＠~ETHICAL-PRINCIPLES#allpeople$ことに留意すること。）
◎
If the easiest way to use an API is likely to result in render blocking or “jank,” the user experience will suffer. (This problem is even more pronounced on low-powered devices, which are more likely to be used by disadvantaged or marginalized users. Remember, the web is for all people.)
</p>

<p>
したがって、
意図されたとおり利用すると~main~threadを阻むことが多くなる~APIは，
`Window$I ~interfaceに公開されるベキでない。
そのような~APIを `DedicatedWorkerGlobalScope$I ~interfaceに制約すれば、
~web開発者にとって “容易な” 道は，最良な利用者~体験を与える道にもなる。
◎
Therefore, APIs which would often block the main thread if used as intended should not be exposed on the Window interface. By restricting such APIs to the DedicatedWorkerGlobalScope interface, the “easy” path for web developers is the path with the best experience for users.
</p>

<div class="example">
`Web Audio API^cite における `ScriptProcessorNode$I は、
`AudioWorklet$I に置換された
— ~main~threadから `ScriptProcessorNode^I を利用すると，
利用者~体験は頻繁に拙くなるので。
`WebAudio$r
◎
ScriptProcessorNodes were replaced by AudioWorklets in the Web Audio API because use of ScriptProcessorNode from the main thread frequently resulted in a poor user experience. [WebAudio]
</div>

			</section>
		</section>
		<section id="new-data-formats">
<h3 title="Add new data formats properly">10.3. 新たな~data形式を適正に追加すること</h3>

<p>
新たな~data形式に対しては、
常に
⇒＃
対応する~MIME型を定義すること／
この型を~supportするよう既存の~APIを拡張すること
◎
Always define a corresponding MIME type and extend existing APIs to support this type for any new data format.
</p>

<p>
~web上の新たな能力が［
新たな~data形式を追加すること
］も孕む事例がある。
これには、
~browserが取り込むものと期待される［
画像／動画／音声／他の型の~data
］も該当し得る。
新たな形式には、［
厳密に検証されるよう，標準~化された~MIME型
］があるべきである。
◎
There are cases when a new capability on the web involves adding a new data format. This can be an image, video, audio, or any other type of data that a browser is expected to ingest. New formats should have a standardized MIME type, which is strictly validated.
</p>

<p>
旧来の~media形式は，~MIME型に対する厳密な施行を常に行ってはいなかったが
（これに対処するため、
ときには，【~media~dataの】~headerを覗見ることに依拠している）、
その理由のほとんどは旧来との互換性を得るためであり，新たな形式には［
期待される／実装される
］べきでない。
◎
While legacy media formats do not always have strict enforcement for MIME types (and sometimes rely on peeking at headers, to workaround this), this is mostly for legacy compatibility reasons and should not be expected or implemented for new formats.
</p>

<p>
仕様~策定者は、
新たな形式を既存の~APIにも統合することが期待される
— ~browserの視点で［
~~入口（例： `ReadableStream$I から復号するとき）,
~~出口（例： `WritableStream$I【！WriteableStream】 へ符号化するとき）
］どちらにおいても，安全な形式とみなされるよう。
◎
It is expected that spec authors also integrate the new format to existing APIs, so that they are safelisted in both ingress (e.g. decoding from a ReadableStream) and egress (e.g. encoding to a WriteableStream) points from a browser’s perspective.
</p>

<p>
例えば，~web~platformに【新たな】画像~形式を追加する場合、
まず，当の形式~用に新たな~MIME型を追加してから、
`HTMLImageElement$I における復号-法を~supportするため必然的に，
当の画像~形式~用の復号器を（および，必要なら符号化器も）追加することになろう。
この~~上層には、
さらに，
`HTMLCanvasElement$I の［
`toBlob()＠~HEcanvas#dom-canvas-toblob$c,
`toDataURL()＠~HEcanvas#dom-canvas-todataurl$c
］などの~~出口に対する~supportを追加することも期待される。
◎
For example. if you are to add an image format to the web platform, first add a new MIME type for the format. After this, you would naturally add a decoder (and presumably an encoder) for said image format to support decoding in HTMLImageElements. On top of this, you are also expected to add support to egress points such as HTMLCanvasElement.toBlob() and HTMLCanvasElement.toDataURL().
</p>

<p>
旧来の理由から，~browserは~MIME型の~sniff法を~supportするが、
その`~pattern照合~algo＠~MIMESNIFF#image-type-pattern-matching-algorithm$を拡張することは，~securityの含意に因り推奨されない
— より新たな形式~用には、
代わりに，厳密な~MIME型を施行することが推奨される。
◎
For legacy reasons browsers support MIME type sniffing, but we do not recommend extending the pattern matching algorithm, due to security implications, and instead recommend enforcing strict MIME types for newer formats.
</p>

<p>
新たな~MIME型には、
それ用の仕様があるべきであり，
~IANA（ `Internet Assigned Numbers Authority^en ）に登録されるべきである。
◎
New MIME types should have a specification and should be registered with the Internet Assigned Numbers Authority (IANA).
</p>

		</section>
		<section id="new-http-header-syntax">
<h3 title="Conform new HTTP headers to standards">10.4. 新たな~HTTP~headerは、標準に適合すること</h3>

<p>
新たな~HTTP~headerを定義している場合、
その構文は，
`~HTTP仕様＠~HTTPinfra#fields$
【！`~HTTP仕様＠~RFCx/rfc7230#section-3.2$】
に反してはナラナイ。
◎
If you are defining a new HTTP header, its syntax mustn’t go against the HTTP specification.
</p>

<p>
新たな~headerが有構造~data
— ［
~list／辞書／十進数／文字列／真偽値
］の様な型を伴う値など —
を伝達しなければならない場合、
当の~headerは
`~HTTP用の有構造~field値＠~STRUCTURED-FIELDS$
`RFC8941$r
に定義される構文を利用するべきである。
これは、
当の~headerの消費器~用に特有な構文解析器を［
書する, 保守する
］必要を避けることに加え，消費器が既存の構文解析器を非互換化してしまうことも避ける。
新たな~headerが`有構造~field値＠~STRUCTURED-FIELDS#structured-field-name-value$で表現できない~dataを要求する場合、
有構造~field値の構文を拡張することについて~IETFと関わり合うか，
新たな構文を考案する前に［
~HTTP~headerは~dataを公開する場として当を得ている
］のか考慮し直すこと。
◎
If the new header must convey structured data, such as lists, dictionaries, or typed values like decimals, strings, or booleans, then the header should use the syntax defined in Structured Field Values for HTTP. This avoids consumers of the header having to write and maintain specific micro-parsers, or even worse, something that would break those existing parsers. If the new header requires data that can’t be represented by Structured Field Values, then either engage with IETF about extending the Structured Field Values syntax, or re-consider if an HTTP header is a right place to expose the data before inventing a new syntax. [RFC8941]
</p>

		</section>
		<section id="extend-manifests">
<h3 title="Extend existing manifest files rather than creating new ones">10.5. 既存の~manifest~fileを拡張すること — 新たなそれを作成することなく</h3>

<p>
当の特能が~manifestを要求する場合、
既存の~manifest~schemaを拡張できるかどうか究明すること。
◎
If your feature requires a manifest, investigate whether you can extend an existing manifest schema.
</p>

<p>
新たな~web特能は［
自己完結的かつ自己記述的
］になるべきであり、
理想的には，追加的な~manifest~fileを要求するべきでない。
既存の~manifest~fileには、
次に挙げるものが含まれる：
◎
New web features should be self-contained and self-describing and ideally should not require an additional manifest file. Some of the existing manifest files include
</p>
<ul>
	<li>
`~web~app~manifest＠~APPMANIFEST$
（ `Web App Manifest^en ）
⇒
~web~appに関係する特能を包含する。
◎
Web App Manifest which contains features related to web applications.
</li>
	<li>
`支払い~method~manifest＠~TR/payment-method-manifest/$
（ `Payment Method Manifest^en ）
⇒
~web支払い~APIの文脈における支払い~method用に利用される。
◎
Payment Method Manifest which is used for payment methods in the context of the web payment API
</li>
	<li>
`公表物~manifest＠~TR/pub-manifest/$
（ `Publication Manifest^en ）
⇒
~web公表物~WGによる一部の標準で利用される。
◎
Publication Manifest which is used by some web publications working group standards
</li>
	<li>
`生成元~施策＠https://wicg.github.io/origin-policy/$
（ `Origin Policy^en ）
⇒
~security施策を設定するために利用される。
◎
Origin Policy which is used to set security policies.
</li>
</ul>

<p>
既存の各種~manifest~fileを拡張することが奨励される。
常に、
元の仕様の中に変更を加えるよう試行するか，
少なくとも当の仕様~編集者と拡張について論じること。
この論点があれば、［
結果の設計は もっと良くなる／
~platformに もっと良く統合される何かへ至る
］見込みは高まる。
◎
We encourage people to extend existing manifest files. Always try to get the changes into the original spec, or at least discuss the extension with the spec editors. Having this discussion is more likely to result in a better design and lead to something that better integrates with the platform.
</p>

<p>
~manifest用に新たな［
~key, 値
］を設計するときは、
それらが必要であること
（すなわち、
きちんと考出された利用事例を可能化するものであること）
を確かめること。
また、
類似な~keyが存在するか検査されたし。
既存の ( ~key / 値 ) ~pairでは，必要なものに~~比して過不足がある場合、
アリなら，既存の仕様と作業して それを当の利用事例へ拡張すること。
◎
When designing new keys and values for a manifest, make sure they are needed (that is, they enable well-thought-out use-cases). Also, please check if a similar key exists. If an existing key/value pair does more or less what is needed, work with the existing spec to extend it to your use-case if possible.
</p>

<p class="note">注記：
元の仕様~策定者は、
一定期間は，当の変更を彼らの~manifest形式に即時に統合したいと求めないかもしれない。
これは、［
（勧告候補へ向けて進む様な）~process／
当の追加は異なる視野に入ること
］に因ることもある
— 例えば，［
`~web~app~manifest^citeに対する拡張に影響される利用事例は、［
店／支払い
］に限られる
］の様に。
その事例では、
元の仕様の編集者と合意される限り，`~monkey~patchする$ことも受容-可能である。
◎
There are certain times the original spec authors might not want to integrate changes to their manifest format immediately. This may be due to process (like going to CR), or due to the addition having a different scope, like extensions to Web App Manifest only affecting store or payment use-cases. In that case, it is acceptable to monkey patch as long as that is agreed with the original spec editors.
</p>


<p>
しかしながら，当の特能に［
機能上の領分に特有な~metadata
］が成す複階的な集合が要求される場合、
新たな~manifestの作成も正当化されよう。
◎
However, if your feature requires a complex set of metadata specific to a functional domain, the creation of a new manifest may be justified.
</p>

<p>
~manifest~fileの領分が既存の~manifest~fileと異なる場合、
新たな~manifest~fileを作る必要もあろう
— 例：~fileを~fetchする時機が異なる場合や，
~manifestの複階性が，そうする必要の~~十分な~~根拠を成す場合。
~app~metadataは、［
`~web~app~manifest^cite, または その拡張
］に追加されるべきである。
~manifestのうち［
特定の~app／
~browser以外との相互運用能を要求するもの
］用に利用されるものと指名されるものは、
異なる~approachをとる必要もあろう。
これらに該当する事例の例として［
`支払い~method~manifest^cite,
`公表物~manifest^cite,
`生成元~施策^cite
］がある。
◎
You may need to make a new manifest file if the domain of the manifest file is different from the existing manifest files. For example, if the fetch timing is different, or if the complexity of the manifest warrants it. Application metadata should be added to the Web App Manifest or be an extension of it. Manifests designated to be used for specific applications or which require interoperability with non-browsers may need to take a different approach. Payment Method Manifest, Publication Manifest, and Origin Policy are examples of these cases.
</p>

<p>
例えば，~metadata片が一つだけならば
— ~fetch時機が既存の~manifestと異なっていても —
おそらく，既存の~manifestを利用する
（あるいは，理想的には、
~manifestは要求されない仕方で，当の特能を設計する）
のが最善である。
しかしながら，当の特能に［
その機能上の領分に特有な~metadata
］が成す複階的な集合が要求される場合、
新たな~manifestの作成も正当化され得る。
◎
For example, if you have a single piece of metadata, even if the fetch timing is different than an existing manifest, it is probably best to use an existing manifest (or ideally design the feature in such a way that a manifest is not required). However, if your feature requires a complex set of metadata specific to a functional domain, the creation of a new manifest may be justified.
</p>

<p>
どの事例でも、
命名~規約と調和するべきであることに注意
（ `§ 命名~原則＠#naming-is-hard$を見よ）。
◎
Note that in all cases, the naming conventions should be harmonized (see § 12 Naming principles).
</p>

<p class="note">注記：
既存の~manifestは、
原則により，~underscoreで区切られた小文字による名前を利用する。
~DOM~API内の~manifestから辞書を再利用するのが有用であった~~時期もあった
— そこでの各~名前は、
~camel-case化した~versionに変換することが意味されていた。
そのような例には
`画像~資源＠https://w3c.github.io/image-resource/$
がある。
この理由から、
~keyを 1 個の単語で明瞭に表出できるなら，そうすることが推奨される。
◎
Note: By principle, existing manifests use lowercase, underscore-delimited names. There have been times where it was useful to re-use dictionaries from a manifest in DOM APIs as well, which meant converting the names to camel-cased version. One such example is the image resource. For this reason, if a key can clearly be expressed as a single word, that is recommended.
</p>

		</section>
		<section id="serialization">
<h3 title="Consider consumers when serializing">10.6. 直列化するときは消費者を考慮すること</h3>

<p>
構文解析器や直列化器を孕む特能を［
追加する／拡張する
］ときは、
それによる直列化に対する効果を考慮するベキである。
直列化の結果の~~対象者として，次に挙げるものを考慮しなければナラナイ：
◎
When adding or extending features that involve a parser or a serializer you should consider their effect on serialization. The following are constituencies of serialization results that must be considered:
</p>
<ul>
	<li>
利用者
⇒
直列化の結果は、
末端-利用者に呈示されることもあるので。
◎
Users - because the result of serialization may be presented to the end user
</li>
	<li>
~tool
⇒
いくつかの仕方で，出力を成す直列化に依拠することもあるので
（一例として、
構文解析器が入力~内の~errorを正す必要があるか否か検出するために）。
◎
Tools - which may rely on the output of serialization in a number of ways (for instance, to detect if the parser need to correct for errors in the input)
</li>
	<li>
~Web~API
⇒
直列化は、
~web~platformの他の~APIへ渡されることもあるので。
◎
Web APIs - because serializations may be passed into other APIs of the web platform
</li>
</ul>

<p>
言語に特有な期待を考慮すること
— 一例として、
空白の有無が有意になり得る言語もある。
各~言語が受容する浮動小数点~数の精度は，言語に応じて相違し得る。
直列化の結果は：
◎
Consider language specific expectations - for instance, in some languages, the presence or absence of whitespace may be significant. Languages may differ in the precision of floating point numbers they accept. The results of serialization:
</p>

<ul>
	<li>
開発者の期待に合致するベキである
（一例として、
~CSS~propを直列化-法した結果の出力は，
~CSS作者が書したものと大きく異なるベキでない）。
◎
Should match developer expectations (for instance, serializing CSS properties should not result in output that is very different from what a CSS author would have written)
</li>
	<li>
`冪等性＠https://en.wikipedia.org/wiki/Idempotence$
⇒
構文解析器からの出力を直列化した結果は、
再び構文解析して直列化されたとき，同じ結果を生産するベキである。
◎
Idempotence - the result of serializing the output of a parser should be something that, when parsed and serialized, produces itself.
</li>
	<li>
~error累積に追加するベキでない
⇒
ある~APIから直列化された出力をとって，ある~loop内で同じ~APIへ~feedbackしても、
結果の内部~状態は同じになるベキである。
◎
Should not add to error accumulation - taking the serialized output of an API and feeding it back to the same API in a loop should result in the same internal state
</li>
</ul>

		</section>
		<section id="debuggability">
<h3 title="Ensure features are developer-friendly">10.7. 特能が開発者に親切になることを確保すること</h3>

<p>
新たな特能は、
どれも，開発者に親切になるべきである。
親切さを数値化することは難しいが、
少なくとも次に挙げる点を考慮すること。
◎
Any new feature should be developer-friendly. While it is hard to quantify friendliness, at least consider the following points.
</p>
<ul>
	<li>
例外に伴われる~error~textは，汎用であるべきだが、
開発者~向けの~error~message（開発者~consoleに示されるものなど）は，
開発者に有意義でなければならない。
開発者が~errorに遭遇したとき、
当の~messageは，［
汎用に過ぎないよう，当の~error事例に特有なもの
］にするべきである。
◎
While error text in exceptions should be generic, developer-oriented error messages (such as those from a developer console) must be meaningful. When a developer encounters an error, the message should be specific to that error case, and not overly generic.
</li>
	<li>
開発者~向けの~error~messageは、
理想的には，［
開発者が問題がある箇所を~~特定すること
］を手引きするに十分な情報を伴うべきである。
◎
Ideally, developer-oriented error messages should have enough information to guide the developer in pinpointing where the problem is.
</li>
	<li>
~CSSなどの宣言的な特能は、
~debug能を得るために，実装において加的な作業が要求され得る。
当の仕様において これを定義することは、
当の特能が より開発者に親切になるのみならず，利用者にとって一貫した開発~体験も確保する。
◎
Declarative features such as CSS, may require extra work in the implementation for debuggability. Defining this in the specification not only makes the feature more developer-friendly, it also ensures a consistent development experience for the users.
</li>
</ul>

<p>
~debug能を仕様の一部として定義した良い例として，次が挙げられる
⇒
~web~animation（ `Web Animations^cite ）の `§ 利用事例＠~WANIM#use-cases$。
◎
A good example where debuggability was defined as part of the specification is Web Animations.
</p>

<p class="trans-note">【
とは言え、
~error~messageの詳細~などは，利用者が直に面する挙動には影響しないので、
この節の内容は，（この文書が対象にする）仕様~策定者~向けよりは実装~向けの指針になるであろう。
】</p>

		</section>
		<section id="crypto">
<h3 title="Use the best crypto, and expect it to evolve">10.8. 最良な暗号を利用すること，暗号は進化するものと予期すること</h3>

<p>
暗号用の~algoには、
~security専門家により公平に考査されたものに限り利用すること
— 【~~強度が】立証された, 最新なものを選ぶこと。
暗号用の［
~protocol／~algo
］は、
廃用にされたり，~secureでなくなるのみならず，急速に進化する。
◎
Use only cryptographic algorithms that have been impartially reviewed by security experts, and make sure your choice of algorithm is proven, and up-to-date. Not only do they become obsolete or insecure, cryptographic protocols and algorithms also evolve quickly.
</p>

		</section>
		<section id="client-hints">
<h3 title="Do not expose new information through Client Hints">10.9. ~client~hintを通して新たな情報を公開しないこと</h3>

<p>
`~client~hint^cite `RFC8942$r を利用して公開する情報は、
~web~pageが すでに~accessを有しているものに限ること。
◎
When using Client Hints, don’t expose information that the web page does not already have access to.
</p>

<p>
~client~hintは重要な最適化ではあるが、
~siteに情報を公開する唯一の手段には，なり得ない
— それを定義した `RFC8942$r `§ 情報~公開＠~HTTPch#information-exposure$にて~~述べられたとおり：
◎
Client hints are an important optimization, but cannot be the sole means by which information is exposed to sites. As it says in RFC 8942 §4.1 where client hints are defined:
</p>

<blockquote cite="https://datatracker.ietf.org/doc/html/rfc8942#section-4.1-5">
<p>
したがって，この文書に依拠する下で~client~hint~headerを定義している特能は、
さもなければ［
~UAが応用
— 既存の［
要請~header／~HTML／~CSS／~JS
］など —
には可用にしないような，新たな情報
］を供してはナラナイ。
◎
Therefore, features relying on this document to define Client Hint headers MUST NOT provide new information that is otherwise not made available to the application by the user agent, such as existing request headers, HTML, CSS, or JavaScript.
</p>
</blockquote>

<p>
追加しようと試行している新たな~client~hintが［
他の手段では，~web~pageに可用にならない情報
］を公開するものである場合、
まずは［
そのような情報を~APIを通して公開する
］ことを追求されたし。
◎
If you are trying to add a new client hint that exposes information that is not available to the web page through other means, please pursue exposing this information through an API first.
</p>
		</section>
	</section>
	<section id="spec-writing">
<h2 title="Writing good specifications">11. 良い仕様の書法</h2>

<p>
この文書の大部分は，~Web用の~API設計を受持つが、
~APIを設計する者は，当の~API用の仕様も書するよう希望される。
◎
This document mostly covers API design for the Web, but those who design APIs are hopefully also writing specifications for the APIs that they design.
</p>

		<section id="requirements-on-authors-and-implementers">
<h3 title="Identify the audience of each requirement in your specification">11.1. 当の仕様~内の各~要件の対象者を識別すること</h3>

<p>
次の両者を文書化すること
⇒＃
当の~APIを利用している作者が良い~codeをどう書するべきか／
当の~APIの実装者が拙く書された~codeをどう取扱うべきか
◎
Document both how authors should write good code using your API, and how implementers of your API should handle poorly-written code.
</p>

<p>
~webは
— とりわけ他の~platformとの比較において —
拙く形成された~markupを受容することにおいて堅牢に設計されている。
このことは、
次を意味する
⇒＃
~web~pageが~web標準の旧い~version利用していても，新たな~UAで視れる／
作者にとって，学習曲線は より~~緩やか（ `shallow^en ）になる【 習得に~~時間がかかる？易しくなる？】
◎
The web, especially in comparison to other platforms, is designed to be robust in accepting poorly-formed markup. This means that web pages which use older versions of web standards can still be viewed in newer user agents, and also that authors have a shallower learning curve.
</p>

<p>
これを~supportするため，~web仕様の書者は、
きちんと形成された~markupのみならず，拙く形成された~markupを解釈する方法を述べる必要がある。
◎
To support this, web specification writers need to describe how to interpret poorly-formed markup, as well as well-formed markup.
</p>

<p>
実装者は、［
作者が利用しようと目指しているはずの “適合な言語”
］より複階的な，
“~supportされる言語”
を理解-可能になる必要がある。
◎
Implementers need to be able to understand the "supported language", which is more complex than the "conforming language" which authors should be aiming to use.
</p>

<div class="example">
例えば，
`table$e 要素~用の`処理~model＠~HEtables#table-processing-model$は、
要素の内容が要素の内容~model【！#the-table-element:concept-element-content-model】に適合しない事例も含めて，
`table^e 要素の内容を処理する方法を説明する。
◎
For example, the Processing model for the &lt;table&gt; element explains how to process the contents of a &lt;table&gt; element, including cases where the contents do not conform to the Content model.
</div>

		</section>
		<section id="avoid-ambiguity">
<h3 title="Specify completely and avoid ambiguity">11.2. 完全に指定して多義性を避けること</h3>

<p>
特能が，どう働くべきか指定するときは、［
作者が異なる実装ごとに異なる~codeで作業するよう書する必要がない
］ほど十分な情報を与えること。
◎
When specifying how a feature should work, make sure that there is enough information so that authors don’t have to write different code to work with different implementations.
</p>

<p>
仕様による指定が不十分な場合、
実装者は他と異なる選択を為すかもしれず，その場合［
その相違点を取扱うために加的な~codeを書する
］ことを作者に強制することになる。
◎
If a specification isn’t specific enough, implementers might make different choices which force authors to write extra code to handle the differences.
</p>

<p>
実装者が［
この状況を避けるために，他の実装の詳細を検査する必要
］は、
生じるべきでない。
代わりに，仕様は、
それ自体で十分に［
完全かつ明瞭
］になるべきである。
◎
Implementers shouldn’t need to check details of other implementations to avoid this situation. Instead, the specification should be complete and clear enough on its own.
</p>

<p class="note">注記：
このことは、
実装が許可~promptの様なものを他と［
異なるように具現化できない ／異なる~UIを示せない
］ことを意味するわけではない。
◎
Note: This doesn’t mean that implementations can’t render things differently, or show different user interfaces for things like permission prompts.
</p>

<p class="note">注記：
実装者は、
仕様が［
実装を書するための十分に明瞭な情報
］を与えていない場合には，そのことについて~bugを申請するべきである。
◎
Note: Implementers should file bugs against specifications which don’t give them clear enough information to write the implementation.
</p>

			<section id="algorithms">
<h4 title="Define algorithms clearly">11.2.1. ~algoを明瞭に定義すること</h4>

<p>
~algoは、
明瞭かつ簡潔な仕方で書すること。
◎
Write algorithms in a way that is clear and concise.
</p>

<p>
~algoを書する最も共通な仕方は、
明示的な一連の段で書することである。
これは、
疑似-~codeの様な見かけになることが多い。
◎
The most common way to write algorithms is to write an explicit sequence of steps. This often looks like pseudo-code.
</p>

<div class="example">
`showModal()＠~HEinteractive#dom-dialog-showmodal$c
~methodは、
付番された一連の段として述べられ，［
例外をいつ投出して，~HTML仕様の他の各部にて定義される~algoをいつ走らすか
］を明瞭に説明する。
◎
The showModal() method is described as a numbered sequence of steps which clearly explains when to throw exceptions and when to run algorithms defined in other parts of the HTML spec.
</div>

<p>
一連の段を書するときは、
それが機能上は~code片であると想像すること。
◎
When writing a sequence of steps, imagine that it is a piece of functional code.
</p>
<ul>
	<li>
入力と出力を明瞭に指定すること。
◎
Clearly specify the inputs and outputs,＼
</li>
	<li>
それが利用する~algoと変数をきちんと命名すること。
◎
name the algorithm and the variables it uses well,＼
</li>
	<li>
当の~algo内で［
結果を返す／~errorになる
］箇所を明示的に注記すること。
◎
and explicitly note the points in the algorithm where the algorithm may return a result or error.
</li>
	<li>
副作用がある~algoを書するのは、
アリな限り避けること。
◎
As much as possible, avoid writing algorithms which have side effects.
</li>
</ul>

<p>
手続きの詳細~に入る前に
— 読者が当の手続き全体を読するか飛ばすか裁定できるよう —
当の~algoの目的を要約すること。
例えば
⇒
“この手続きは、
各`~top-level閲覧~文脈＠~HTMLds#top-level-browsing-context$に在る処理待ち X ~callbackは 1 個までに限られることを確保する。”
◎
Summarize the purpose of the algorithm before going into detail, so that readers can decide whether to read the steps or skip over them. For example take the following steps, which ensure that there is at most one pending X callback per top-level browsing context.
</p>

<p>
素な手続き（一連の段）は、
常に~algoを書する最善な仕方になるとは限らない。
例えば、
正式な［
構文や文法
］を定義したり再利用して繰返nを避ける，
あるいは［
利用される特定の状態を状態~機械~内で定義する
］方がイミを成すかもしれない。
その様な加的な構成子を利用するときでも、
上述した助言は適用される。
◎
A plain sequence of steps is not always the best way to write an algorithm. For example, it might make sense to define or re-use a formal syntax or grammar to avoid repetition, or define specific states to be used in a state machine. When using extra constructs like these, the earlier advice still applies.
</p>

<p>
~algoは、
それがどう実装されるかにアリな限り近くなるよう述べること。
これは，仕様を書するのを難しくし得るが、
その実装は［
仕様にて書されたものを，実際にどう実装するべきか翻訳する方法
］を解明する必要がなくなることを意味する。
特に，そうしないことは、
実装ごとに異なる裁定が下される結果，後の特能が［
ある実装では実現可能な一方で，別の実装では そうならないもの
］に至り得ることを意味し得る。
◎
As much as possible, describe algorithms as closely as possible to how they would be implemented. This may make the spec harder to write, but it means that implementations don’t need to figure out how to translate what’s written in the specification to how it should actually be implemented. In particular, that may mean that different implementations make different decisions that may lead to later features being feasible in one implementation but not another.
</p>

<div class="example">
~CSS選択子は、
先頭から順に読され, 解されるが、
実施においては，実装は末尾から順に照合する。
これは、
最も特定な項を素早く［
照合する／照合しない
］ことにより，不必要な作業を避けることを許容する。
~CSS選択子~照合~algoは、
この仕方で書される
— 多くの~CSS作者が~CSS選択子を読するであろう仕方とは逆に。
◎
CSS selectors are read and understood from left to right, but in practice are matched from right to left in implementations. This allows the most specific term to be matched or not matched quickly, avoiding unnecessary work. The CSS selector matching algorithm is written this way, instead of a hypothetical algorithm which would more closely match how CSS selectors are often read by CSS authors.
</div>

<p class="trans-note">【
とは言え、
一般に，［
実装は、
観測される結果が判別できない限り，どう実装してもよい
］原則があるので、
字義通り解釈するなら，これは施行し得ないことになる。
これは，実質的には、
要件を［
結果が満たすべき条件~群としてではなく，算出-可能な~algoとして~~形にする
］よう指定することと解釈すべきに思われる。
】</p>

<p>
次も見よ
⇒
`INFRA$r `§ ~algo＠~INFRA#algorithms$
◎
See also:
• some useful definitions and terminology from [INFRA]
</p>

			</section>
			<section id="use-flags-for-states">
<h4 title="Use explicit flags for state">11.2.2. 状態~用には明示的な~flagを利用すること</h4>

<p>
~algoを書するときは、
各~状態を~~言葉で述べる代わりに，明示的な~flagを利用すること。
◎
Instead of describing state with words, use explicit flags for state when writing algorithms.
</p>

<p class="trans-note">【
すなわち、
“〜である” や “〜している”
などのように述べる代わりに，
“〜~flag ~EQ X”
のように記すこと。
】【
実際の仕様で語 “~flag（ `flag^en ）” が利用されるのは、
とり得る状態が 2 つしかないときに限られる
— 状態が もっと多い場合、
他の語（ “〜~mode（ `mode^en ）” など）が利用される
（この節の “~flag” は、
これら状態を表現するものの総称を意味することになる）。
この~siteの和訳では、
ほとんどの真偽-~flagは
`“〜か” と記される＠index.html#dfn-flag$。
】</p>

<p>
明示的な~flagを利用すれば、［
各種~error条件において，状態が変化したかどうか／
当の~flagが述べる状態がいつ設定し直されたか
］が明瞭になる。
◎
Using explicit flags makes it clear whether or not the state changes in different error conditions, and makes it clear when the state described by the flags is reset.
</p>

			</section>
		</section>
		<section id="implementability">
<h3 title="Resolving tension between interoperability and implementability">11.3. 相互運用能と実装-能の対立に対する解決-法</h3>

<p>
ある特能を指定することには、
すべての~engineering作業と同様に，各種［
~tradeoffや妥協-法
］を比較検討することが要求される。
◎
Specifying a feature, like all engineering work, requires weighing tradeoffs and compromising.
</p>

<p>
ある特能が，各~実装者~すべてから各自の~engineにおいて実装-可能であると合意されたとしても、
当の特能を相互運用可能に仕様~化する仕方を見出すことに
— ~~関係者すべてが最善な労を尽くしても —
失敗するときもある。
◎
Sometimes, despite the best efforts of all involved, we fail to find a way to interoperably specify a feature that every implementor agrees is implementable in their engine.
</p>

<p>
進むべき道は、
`末端-利用者にとって何が最良か＠#priority-of-constituencies$に従って選ばれるベキである。
◎
Choosing a way forward should be guided by what is best for the end user.
</p>

<p>
まず，実装-能の懸念を成す資質を精査すること。
実装者が，当の特能を実装するベキではないものと
— たぶん、
それは末端-利用者にとって害になり得るものと識別した結果 —
裁定した状況においては、
当の特能を仕様~化しないことが
— それに伴い、
それを出荷した実装者は，出荷しなくすることが —
最善かもしれない。
特能を出荷しなくすることは、
利用者や作者を惑わす結果を伴い得ることを念頭に置くこと。
◎
First, examine the nature of the implementability concerns. Perhaps the implementor identified potential end-user harm and decided that the feature should not be implemented. In this situation, it may be best to not specify the feature, and for any implementors who have shipped the feature to un-ship it. Keep in mind that un-shipping features may result in user and author confusion.
</p>

<div class="example" id="sharedarraybuffer">
<p>
~Spectre攻撃が発見されたとき、
`SharedArrayBuffer$I は，どの実装においても出荷しなくされた
— それは［
~Spectre攻撃~用にも利用され得る高-精度な~timer
］を作成するためにも利用できたので。
◎
When the Spectre attack was discovered, SharedArrayBuffer was unshipped in every implementation because it can be used to create a high-precision timer that could be used for a Spectre attack.
</p>
</div>

<p>
同じ~APIが，どの~engineにおいても実装-可能であっても、
その挙動を全部的に相互運用可能にすることは，できないときもある。
各~実装~間で挙動が相違するときは、
末端-利用者への影響iを考慮しなければナラナイ。
この~approachには、
挙動における相違が`特能~検出-可能＠#feature-detect$でなくなる難点がある。
他方，将来において［
すべての実装が同じ挙動に収束することを可能化する
］よう何かを変更した場合でも、
各~siteは，その利点を採るために更新する必要はなくなる。
◎
Sometimes the same API is implementable in every engine, but its behavior cannot be made to be fully interoperable. Whenever behavior differs between implementations, the end-user impact must be considered. One downside to this approach is that the difference in behavior is not feature detectable. On the other hand, if something changes in the future that enables all implementations to converge on the same behavior, sites will not need to be updated to take advantage of this.
</p>

<p class="note">注記：
作者たちは、
支配的な実装の挙動が正しいもので，他の挙動は~bug含みであると見做すようになることもある
— それは、
支配的な実装を更に定着させ得る。
◎
Note: Authors may assume the behavior of the dominant implementation is correct and any other behavior is buggy, which may further entrench the dominant implementaiton.
</p>

<div class="example" id="backdrop-filter">
<p>
`backdrop-filter$p ~propの挙動は、
各~実装~間で いくつか可視な相違があることが既知である。
それに対し作業している者たちは、
~~現時点では，［
~APIを共有する便益の方が，これらの相違を相互運用可能にする~costより勝る
］ものと予見している。
◎
The backdrop-filter property is known to have a number of visible behavior differences between implementations. At the present time, those working on it believe the benefits of sharing an API outweigh the interoperability costs of the differences.
</p>
</div>

<p>
挙動の相違点が十分に深刻で，それ以上~収束し得ない場合、
異なる~APIを指定して，各~実装者が そのような実装-可能な代替と伴に行く方が好ましいこともある。
◎
If behavior differences are serious enough, and cannot be converged further, it may be preferable to specify different APIs, with each implementor going with the alternative that they are able to implement.
</p>

<p>
この~approachには、
次を伴い得る~riskがある
⇒
実装が最終的に同じ挙動に収束-可能な場合でも，
複数の代替な~APIを不定期に~supportする必要がある結果、
開発者にとって，複階性と実装を保守する~costが増える。
◎
One risk of this approach comes about if implementations are eventually able to converge on the same behavior. In this case, multiple alternative APIs may need to be supported indefinitely, which can increase developer complexity and implementation maintenance costs.
</p>

<p>
同じ利用事例に取組むことが意図される 2 つの異なる~APIを公開すると、
作者は，［
`特能~検出＠#feature-detect$を利用して，各~browser用に異なる~codeを書する
］よう強制される。
◎
Exposing two different APIs that are intended to address the same use cases forces authors to use feature detection to write different code for different browsers.
</p>

<p class="note">注記：
そこには、
作者たちが［
支配的な実装が~supportする~API変種を “正しいもの” であると見做すようになる／
単純に，普段は利用しない実装が~supportする~API変種に~~気付かない
］かもしれない~riskがある
— それは、
支配的な実装を更に定着させ得る。
◎
Note: There is a risk that authors may assume the API variant supported by the dominant implementation is the "correct" one, or they may simply be unaware of the API variants supported in implementations they do not use regularly, which may further entrench the dominant implementaiton.
</p>

<p>
この道へ行く場合、
各~API~間の相違点を最小~化することにより，
作者の~costを抑制するよう試行すること。
標準でない部分を［
小さくして，より大きな標準~化された~frameworkから隔離された~componentにする
］よう設計することがアリな場合もあろう。
◎
If you do go this route, try to reduce the cost to authors by minimizing the differences between the APIs. It may be possible to design things such that the non-standard part is a small, isolated component of a larger, standardized framework.
</p>

<div class="example" id="eme-and-payment-request">
<p>
非-標準な~componentを他の（共有された）~API表面から隔離することにより，
~API相違点を最小~化した仕様の例として，次が挙げられる
⇒＃
`ENCRYPTED-MEDIA$r （の `Content Decryption Module^en ）,
`payment-request$r （の`支払い~method＠https://w3c.github.io/payment-request/#dfn-payment-method$）
◎
[ENCRYPTED-MEDIA] and [payment-request] are both examples of specifications which minimize API differences by isolating a non-standard component (Content Decryption Modules and payment methods, respectively) from the rest of the (shared) API surface.
</p>
</div>

<p>
ある~groupが、
ある~APIを仕様~化することを［
一部の実装は，それを実装する用意がない
］ことを知りながら，選ぶときもある。
作者は［
特能~検出を利用して，そのような~APIを可用なときに限り利用する
］ようになり，利用者は［
そのような特能が~supportされ，利用されるときに便益を得られる
］ようになることもあろう。
が、
その結果は，常に問題になり得る
— 実装する用意がある実装が 1 つしかないときは、
最悪になる。
一部の標準~化の場には、［
ある特能に関心がある実装が一つしかない場合，その標準~化を許容しない
］とする明示的な規則がある。
そのような~groupに従事していようが、
実装が一つしかない特能を標準~化することは，強く忌避される。
◎
Groups sometimes choose to specify APIs knowing that some implementations are unwilling to implement it. Authors may use feature detection to only use APIs when they are available, and users may benefit where such features are supported and used. This is always a problematic outcome, though it is worst when there is only one willing implementor. Some standards venues have rules explicitly disallowing the standardization of features which only have a single interested implementor. Even if you are not operating in such a group, standardization of single-implementation features is strongly discouraged.
</p>

<p>
ある~groupは、
これらの~optionが どれも受容-可能でないことを見出す場合もあろう。
当の特能を仕様~化しないことを選ぶのが最善な道になる場合もあろうが、
一部の実装が当の特能を非-標準な~APIとして出荷し得る~riskもある。
◎
You may also find that none of these options is acceptable to your group. While the best path forward may be to choose not to specify the feature, there is the risk that some implementations may ship the feature as a nonstandard API.
</p>

		</section>
		<section id="monkey-patching">
<h3 title="Avoid monkey patching">11.4. ~monkey~patchすることは避けること</h3>

<p>
`~monkey~patchする@
とは、
既存の仕様の挙動を［
拡張するか上書きする, あるいは改変する
］仕方で，
既存の仕様の上に新たな機能性の層を重ねることである。
`~monkey~patchすること＠https://en.wikipedia.org/wiki/Monkey_patch$は、
以下に挙げる理由により，
`一般に不良な実施であり，避けるベキもの^strongと見なされる
— ときには、
避けれないこともあるが
（`§ ~monkey~patchする必要がある場合＠#cant-avoid-monkey-patching$の指導を見よ）。
◎
A monkey patch layers new functionality on top of an existing specification in a way that extends, overrides, or otherwise modifies the existing specification’s behavior. Monkey patching is generally considered bad practice and should be avoided for the reasons listed below; but is sometimes unavoidable (see our guidance if you need to monkey patch).
</p>

<p>
~monkey~patchする例として、
次が挙げられる
⇒
ある仕様が自身の能力の一部を成す内部的な~algoを定義していて、
別の仕様が公に定義された拡張~地点を利用することなく，
新たな機能性で直に当の~algoを［
上書きする／改変する
］。
◎
An example of monkey patching would be: specification A defines an internal algorithm part of its capability, then specification B overrides or modifies said algorithm with functionality directly, not using publicly defined extension points.
</p>

<p>
そのように~monkey~patchすることは、
当の下層の機能性が決して変更されないものと（間違って）決めつけることに等しい。
これは、
次に挙げる問題に至らせ得る：
◎
As such, monkey patching (wrongly!) presupposes that underlying functionality cannot, and will not, be changed. This can lead to several problems:
</p>
<ul>
	<li>
既存の仕様が変更された場合、
当の~monkey~patchした~textは，もはや適用されなくなり得る
— その結果、［
非互換化する／混同へ至らす
］原因になる。
◎
If the existing specification changes, the monkey patched text may no longer apply thus causing it to break or lead to confusion.
</li>
	<li>
いくつかの仕様が別の仕様の一部を~monkey~patchした場合、
それらの~patchが適用された順序により，挙動が一貫しなくなり得る。
【例：どれか一つの~patchしか適用されなくなるなど。】
◎
If several specifications monkey patch part of another spec, the order in which the patches are applied can lead to inconsistent behavior.
</li>
	<li>
既存の仕様の策定者は、
当の仕様~内の~monkey~patchした~textについて自覚しないこともあろう。
その結果、
修正-について総意へ達するための指導を受取る機会も失われる。
さらには、
~patchされた挙動が他の課題や挙動にも相互に関係している場合，状況は総じて悪化しかねない。
◎
The existing specification authors may not be aware of the monkey patched text in your spec. This misses an opportunity to receive guidance on reaching consensus on a fix. Or worse, the behavior that is being patched is interrelated to so other issue or behavior, making the overall situation worse.
</li>
	<li>
~codeの保守を行っている実装者は，下層の仕様しか読してない結果、
~monkey~patchされた挙動を~bugと見做して，不作為に元へ復帰することもあろう。
◎
An implementer doing code maintenance may read underlying specification and inadvertently revert the monkey patched behavior assuming it is a bug.
</li>
</ul>

<p>
Wikipedia は、
`~monkey~patchすることによる追加的な陥穽＠https://en.wikipedia.org/wiki/Monkey_patch#Pitfalls$についても述べている。
◎
Wikipedia also describes some additional pitfalls of monkey patching.
</p>

			<section id="cant-avoid-monkey-patching">
<h4 title="If you need to monkey patch">11.4.1. ~monkey~patchする必要がある場合</h4>

<p>
ときには、
~monkey~patchすることを避けれないこともある
（例：ある新たな仕様の早期-設計~相）。
既存の仕様を~monkey~patchする必要があることを見出した場合、
次に従うこと：
◎
Sometimes monkey patching is unavoidable (e.g., early in the design phase of a new specification). If you find yourself needing to monkey patch an existing specification, make sure you:
</p>
<ol>
	<li>
<p>
当の~monkey~patchは［
別の仕様に対し提案された変更であり，当の仕様において一時的に限られる
］ことが明瞭になるよう，当の仕様~内の該当する箇所を明瞭に~markすること
— 次の様な文言を利用して：
◎
In your spec, clearly mark the monkey patch as a proposed change to another specification that is only temporarily in this specification, using language like:
</p>

<div class="example">
【！ class="language-markdown"】
<pre>
# ~HTTP~fetchを改変する

&lt;p class="issue"&gt;十分な総意を得たなら，これを `Fetch^r の中へ併合する。&lt;/p&gt;
◎
Merge this into [[Fetch]] once it has enough consensus.

</pre>
◎
# Modify HTTP fetch

&lt;p class="issue"&gt;Merge this into [[Fetch]] once it has enough consensus.&lt;/p&gt;
</div>

	</li>
	<li>
<p>
変更したいと求める箇所を識別すること
— 該当する箇所の~textを引用するか、
用語の定義を置換している場合には，当の用語へ~linkすることにより。
~algo内のある段など，付番された何かを変更している場合、
その番号を含めること。
ただし、
番号だけでは足らないことに留意すること
— 番号は他の段が［
追加される／除去される
］と変化するので。
ある定義の中のいくつかの箇所を変更している場合、［
`&lt;blockquote&gt;^c の中へ当の定義~全体を~pasteした上で，
`&lt;ins&gt;^c や `&lt;del&gt;^c を利用する
］ことにより，何を変更しているか述べる方が助けになり得る。
◎
Identify the place you want to change using a quote from its text or by linking to a defined term if you’re replacing that term’s whole definition. Include the current step numbers if you’re changing something that’s numbered, but remember that numbers aren’t sufficient by themselves because they change when other steps are added or removed. If you’re changing several places within a definition, it can be helpful to paste the entire definition into a &lt;blockquote&gt; and use &lt;ins&gt; and &lt;del&gt; to describe what’s changing.
</p>

<div class="example">
<p>
`~HTTP~fetch＠~FETCH#concept-http-fetch$を成す段 4.2
⇒
~IF［
要請の~redirect~mode ~EQ `follow^l
］
⇒
要請の~sw~mode ~SET `none^l
◎終
の前に，次の段たちを挿入する
⇒
1 個目の新たな段…
◎
Before step 4.2 of HTTP fetch, "If request’s redirect mode is "follow", then set request’s service-workers mode to "none".", insert the following steps:
• The first new step.
</p>
</div>

<div class="example">
<p>
`CSS2$r `§ 通常~flow内にある塊~levelの置換されない要素＠~CSS2J#blockwidth$
における “拘束され過ぎ” なときの算出~用の規則は、
ここに指定される整列への支持を受けて，無視される
— したがって、
各種~margin~propの使用~値は，拘束され過ぎを正すよう調整されない。
◎
In terms of CSS2.1 block-level formatting [CSS2], the rules for “over-constrained” computations in CSS 2.1 § 10.3.3 Block-level, non-replaced elements in normal flow are ignored in favor of alignment as specified here and the used value of the margin properties are therefore not adjusted to correct for the over-constraint.
</p>
</div>

<div class="example">
<p>
`URLSearchParams$I の［
`delete()＠~URL1#dom-urlsearchparams-delete$c,
`has()＠~URL1#dom-urlsearchparams-has$c
］の定義に，
~parameterとして
<code>optional USVString %value</code>
を付加する：
◎
Append optional USVString value parameters to the definitions of URLSearchParams.delete() and URLSearchParams.has():
</p>

<pre class="idl">
partial interface URLSearchParams {
  undefined delete(USVString name<ins>, optional USVString value</ins>);
  boolean has(USVString name<ins>, optional USVString value</ins>);
};
</pre>
</div>

<div class="example">
<p>
`font-size-adjust$p の定義を次に従って改変すること：
</p>

◎名 `font-size-adjust＠#propdef-font-size-adjust@p
◎値
`none^v | <ins>[ `ex-height^v | `cap-height^v | `ch-width^v | `ic-width^v | `ic-height^v ]? [ `from-font^v | </ins> `number$t <ins>]</ins>
◎初 `none^v
◎適 すべての要素／~text
◎継 される
◎百 受容しない
◎算
<del>
実数／~keyword `none^v
</del>
<ins>
~keyword `none^v ／
( 計量~keyword, `number$t ) が成す~pair
</ins>
◎
a number or the keyword none
◎順 文法に従う
◎ア 
<ins>
互いの~keywordが相違する場合は離散的／
他の場合は</ins>算出d値の型による
◎表終

◎
Modify the definition of font-size-adjust as follows:
◎
Name: 	font-size-adjust
Value: 	none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | &lt;number&gt; ]
Initial: 	none
Applies to: 	all elements and text
Inherited: 	yes
Percentages: 	N/A
Computed value: 	a number or the keyword none the keyword none, or a pair of a metric keyword and a &lt;number&gt;
Canonical order: 	per grammar
Animation type: 	discrete if the keywords differ, otherwise by computed value type
</div>
	</li>
	<li>
~monkey~patchは短く保つこと。
いくつもの段を追加することにより，ある~algoを改変している場合、
当の仕様~内に別々な自己完結的な~algoを定義して，
当の~monkey~patchが新たな~algoを~callするようにすること。
◎
Keep monkey patches short. If you’re modifying an algorithm by adding more than a couple of steps, define a separate, self-contained algorithm in your specification, and have the monkey patch call the new algorithm.
</li>
	<li>
ある~algoにおいて段たちを［
置換して／追加して
］いる場合、
新たな段を書すること
— 編集者が上流~algoの中へ そのまま~pasteできるよう。
このことは、
“返る” や “中止する” 【~RET】の様な制御~flowは
— 当の~monkey~patchされた~~区間のみならず —
上流~algoそれ自体［
から返る／を中止する
］ことを含意する。
◎
If you’re replacing or adding steps in an algorithm, write the new steps so an editor can paste them verbatim into the upstream algorithm. This implies that control flow like "return" or "abort" will return or abort from the whole upstream algorithm, not just the monkey patched section.
</li>
	<li>
当の特能が自前の~communityの中で考査され，
それは良い案である総意が得られたと見受けられたなら、
既存の仕様に対し課題を申請して，
~monkey~patchを考査するよう上流~communityに依頼すること。
上流~communityは、
当の目標を成遂げるための もっと良い仕方を示唆することもある
— それらを真剣に受け取ること。
彼らは、［
既存の拡張~地点の中へ~hookする／
拡張~地点を素早く作成する
］方法を伝えることもあろう
— 当の~monkey~patchを期待されるより早く除去できるよう。
◎
Once your feature has been reviewed within your own community, and there seems to be consensus that it’s a good idea, file an issue against the existing specification that asks the upstream community to review your monkey patch. This community may suggest better ways to accomplish your goals. Take them seriously. They might also be able to tell you how to hook into an existing extension point or quickly create one so that you can remove your monkey patch sooner than you expected.
</li>
	<li>
上で言及した
`&lt;p class="issue"&gt;^c ~blockを［
上流~仕様に対し申請した課題
］を指すように更新すること。
◎
Update the &lt;p class="issue"&gt; block mentioned above to point to the issue you filed against the upstream specification.
</li>
	<li>
当の作業を上流~仕様の中へ併合するための十分な~supportを得たときは、
その仕様の保守者たちと作業して，それを行うこと。
◎
When your work has enough support to merge into the upstream specification, work with that specification’s maintainers to do so.
</li>
	<li>
当の~monkey~patchが既存の仕様に統合されたなら、
当の仕様から それを除去すること。
◎
Once the existing specification has integrated your monkey patch, remove the monkey patch from your specification.
</li>
</ol>

<p>
`~monkey~patchする$ことは、
“~module化” とは異なることに注意
— ~module化は、
既存の技術を［
自己完結的かつ 他の下層の仕様には副作用が生じない仕方
］で拡張する（例：各種~CSS~module）。
~module化は、
良い実施と見なされる。
◎
Note that monkey patching is different from "modularization", which extends existing technology in a way that is self-contained and doesn’t cause side-effects to other underlying specifications (e.g., the CSS Modules). Modularization is considered a good practice.
</p>

<p>
~Web~IDLの`部分的な~interface定義$や`部分的な辞書~定義$, 等々を利用して仕様を拡張することも、
通例的に~~許容される。
が、
そのような事例でも，拡張されている仕様の策定者たちと協調することを~~強く勧める。
【例えば、他の仕様の策定者も，同じ~interfaceに属する別の部分的な~interface定義~内に同じ名前の~memberを定義しているかもしれない。】
◎
It’s also usually ok to extend a specification using WebIDL’s partial interfaces, partial dictionaries, and so on. But even in those cases, it’s highly advisable to coordinate with the authors of the specification being extended.
</p>

			</section>
		</section>
	</section>
	<section id="naming-is-hard">
<h2 title="Naming principles">12. 命名~原則</h2>

<p>
名前は、
次に挙げるものから意味をとること：
◎
Names take meaning from:
</p>
<ul>
	<li>
`signposting^en（ “標識” — 名前~それ自体）
◎
signposting (the name itself)
</li>
	<li>
利用（人々が当の名前を どう時間~越しに理解していくか）
◎
use (how people come to understand the name over time)
</li>
	<li>
文脈
（例えば、当の名前に前置される~obj）
◎
context (the object on the left-hand side, for example)
</li>
</ul>

		<section id="naming-common-words">
<h3 title="Use common words">12.1. 共通的な単語を利用すること</h3>

<p>
~APIは、
容易に可読な米国~英語で命名されなければ`ナラナイ^em
【例： `colour^en （英）ではなく `color^en （米）】。
ほとんどの~web開発者は、
~nativeな英語~話者でないことを念頭に置くこと。
アリなときは、
名前は，共通的な語彙
— 英語~話者の大多数が，当の名前に最初に遭遇したときでも理解すると見込まれる語彙 —
を利用するように選ぶべきである。
◎
API naming must be done in easily readable US English. Keep in mind that most web developers aren’t native English speakers. Whenever possible, names should be chosen that use common vocabulary a majority of English speakers are likely to understand when first encountering the name.
</p>

<div class="example">
例えば、
`cardinality^en 【 “（集合の）~~濃度” 】より `setSize^en 【 “集合の~size” 】の方が，
英語として可読な名前である。
◎
For example setSize is a more English-readable name than cardinality.
</div>

<p>
~~短さより可読性に価値をおくこと。
しかしながら、
ときには，名前は短くした方が明瞭になる場合もあることを念頭に置くこと。
一例として、
当の仕様~内で当の~APIが定義される所では，［
専門用語／周知な成句的用語
］を利用する方が適切になる場合もある。
◎
Value readability over brevity. Keep in mind, however, that sometimes the shorter name is the clearer one. For instance, it may be appropriate to use technical language or well-known terms of art in the specification where the API is defined.
</p>

<div class="example">
例えば， `FETCH$r ~APIの `Body$I ~mixinの
`json()＠~FETCH#dom-body-json$c
~methodは、
それが返す【~Promiseの~parameterを成す】~objの種類に基づいて命名された。
“JSON” は、
この~APIを利用する~web開発者たちには周知と見込まれる成句的用語である。
この~methodの名前を，その返り値~型と縁遠いものにすると、
~~理解し難くなろう。
◎
For example, the Fetch API’s Body mixin’s json() method is named for the kind of object it returns. JSON is a well-known term of art among web developers likely to use the Fetch API. It would harm comprehension to name this API less directly connected to its return type. [FETCH]
</div>

		</section>
		<section id="naming-charset">
<h3 title="Use ASCII names">12.2. ~ASCII名を利用すること</h3>

<p>
名前は、
当の言語に局所的な制約を固守しなければナラナイ
— 例えば，~CSSの `ident$t 規則, 等々。
名前は、
`~ASCII範囲$内にする`べきである^em。
◎
Names must adhere to the local language restrictions, for example CSS ident rules etc. and should be in the ASCII range.
</p>

		</section>
		<section id="naming-consultation">
<h3 title="Consult others on naming">12.3. 命名-時には他者／他所に諮ること</h3>

<p>
当の~APIにおける名前を広く諮ること
— 思いがけない場所で，良い名前や ひらめきを見出すこともあろう：
◎
Consult widely on names in your APIs.
◎
You may find good names or inspiration in surprising places.
</p>
<ul>
	<li>
他の~platformの類似な~APIや，様々な~programming言語に普及している~libraryでは、
何と命名されているか？
◎
What are similar APIs named on other platforms, or in popular libraries in various programming languages?
</li>
	<li>
当の~APIで［
作業する／操作する
］ものを何と呼んでいるか，末端-利用者や開発者に訊いてみること。
◎
Ask end users and developers what they call things that your API works with or manipulates.
</li>
	<li>
他の~web~platform仕様を調べて，
~platformに関係する分野で作業している他者からの助言を探求すること。
◎
Look at other web platform specifications, and seek advice from others working in related areas of the platform.
</li>
	<li>
利用される名前は包括的かどうかも諮ること。
◎
Also, consult if the names used are inclusive.
</li>
</ul>

<p>
［
下層の原則に基づいて明瞭に言明された合理性
］を伴う助言を受取ったときは、
特に注意を払うこと。
◎
Pay particular attention to advice you receive with clearly-stated rationale based on underlying principles.
</p>

<div class="example">
`Tantek Çelik^en 氏は、
~URLを成す様々な各部がどう命名されているか
`多方面で事実調査した＠https://tantek.com/2011/238/b1/many-ways-slice-url-name-pieces$
。
`~URL仕様＠~URL1$ `URL$r
の編集者は、
その文書を編集するときに，この事実調査に依拠した。
◎
Tantek Çelik extensively researched how to name the various pieces of a URL. The editors of the URL spec have relied on this research when editing that document. [URL]
</div>

			<section id="naming-web-consistency">
<h4 title="Use Web consistent names">~webと一貫した名前を利用すること</h4>

<p>
他の技術~stackに公開される［
特能／~API
］用に名前を選ぶときであっても、
他の~communityではなく，~Web~ecosystemの命名~規約を選好するべきである。
◎
When choosing a name for feature or API that has exposure in other technology stacks, the preference should be towards the Web ecosystem naming convention rather than other communities.
</p>

<div class="example">
~NFC標準は、
~Webが`~MIME型＠~MIMESNIFF#mime-type-representation$（ `MIME type^en ）と呼ぶものを指して，
用語 `media^en を利用する。
【 `NFC^en は、 `Near Field Communication^en （近距離無線通信）の略語。】
そのような事例では，~Web~NFCの目的においては、
特能や~APIの命名は “~MIME型” と一貫する名前を選好しなければナラナイ。
◎
The NFC standard uses the term media to refer to what the Web calls MIME type. In such cases, the naming of features or API for the purposes of Web NFC must prefer naming consistent with MIME type.
</div>

			</section>
			<section id="naming-inclusive">
<h4 title="Use Inclusive Language">包括的な文言を利用すること</h4>

<p>
アリなときは、
包括的な文言（ `inclusive language^en ）を利用すること。
◎
Use inclusive language whenever possible.
</p>

<p>
例えば、［
`blacklist^en ／ `whitelist^en
］†に代えて［
`blocklist^en 【 “阻止-~list” 】／ `allowlist^en 【 “許容-~list” 】
］を利用するべきであり，［
`master^en ／ `slave^en
］†に代えて［
`source^en ／ `replica^en
］を利用するべきである。
◎
For example, you should use blocklist and allowlist instead of blacklist and whitelist, and source and replica instead of master and slave.
</p>

<p class="trans-note">【†
これらは、
`差別用語を連想させるので＠https://whatwg.org/style-guide#tone$。
挙げられた例からは、
“`inclusive language^en” は，
この意味合い
— “人に対し，［排他的／差別的］でない” —
を特に指していると見受けられるが、
より広い意味合いもあるかもしれない。
】</p>

<p>
汎用な人物
— 作者, 利用者など —
を指す必要がある場合、
汎用な代名詞 "`they^en", "`their^en", 等々を利用すること。
例えば
⇒
“利用者は、
自身の（ `their^en ）選好を調整したいと望むこともある”
◎
If you need to refer to a generic persona, such as an author or user, use the generic pronoun "they", "their", etc. For example, "A user may wish to adjust their preferences".
</p>

<p class="trans-note">【
この規約は、
性別を示唆する人称~代名詞
— “`he^en” や “`she^en” など —
の利用は避けるべきであることを意図しているようにも思われる。
和訳では、
上の例文のように “`their^en” の対訳に（複数形でない） “自身の” を利用したり，
代名詞ではなく同じ語
— “利用者” など —
を繰返すことが多い。
ときには “彼ら” としか訳しようがないこともあるが
（仕様に現れる “彼ら” が性別も含意することは、ほぼ決してない）。
】</p>

			</section>
		</section>
		<section id="naming-future-proofing">
<h3 title="Use future-proof names">12.4. 将来にも通用する名前を利用すること</h3>

<p>
アリなときは、
汎用かつ将来にも通用するよう命名するべきである。
◎
Naming should be generic and future-proof whenever possible.
</p>

<p>
名前は、
アリなときは，［
銘柄や下層の技術に特有な改訂
］に直に結付けられるべきでない
— 技術は廃用にされることもある一方で、
~webから~APIを除去するのは困難なので。
◎
The name should not be directly associated with a brand or specific revision of the underlying technology whenever possible; technology becomes obsolete, and removing APIs from the web is difficult.
</p>

<div class="example">
`~remote再生~API^cite `REMOTE-PLAYBACK$r は、
その発想元であった既存の~proprietaryな~system
（ `Chromecast^en や `AirPlay^en など）
より後に命名されたが，当の~APIが行うものを述べる一般~用語が選ばれた。
◎
The Remote Playback API was not named after one of the pre-existing, proprietary systems it was inspired by (such as Chromecast or AirPlay). Instead, general terms that describe what the API does were chosen. [REMOTE-PLAYBACK]
</div>

<div class="example">
［
`keydown^et ／ `keyup^et
］ `KeyboardEvent$I は、
~keyboardが利用され始めた頃の特定の~hardware~bus用に命名されてはいない。
代わりに，汎用な名前
— ［
PS/2 や ADB
］~keyboardであった頃から今日の［
~Bluetoothや~USB
］~keyboardにも適用-可能な名前 —
が選ばれた。
`UIEVENTS$r
◎
The keydown and keyup KeyboardEvents were not named for the specific hardware bus that keyboards used at the time. Instead, generic names were chosen that are as applicable to today’s Bluetooth and USB keyboards as they were to PS/2 and ADB keyboards back then. [UIEVENTS]
</div>

		</section>
		<section id="naming-consistency">
<h3 title="Name things consistently">12.5. 一貫するよう命名すること</h3>

<p>
命名~schemeは、
混同を避けるため，一貫性を目指すべきである。
◎
Naming schemes should aim for consistency, to avoid confusion.
</p>

<p>
関係する名前たちが成す集合は、
次について，互いに一致するべきである：
◎
Sets of related names should agree with each other in:
</p>
<ul>
	<li>
品詞
— 名詞, 動詞, 等々。
◎
part of speech - noun, verb, etc.
</li>
	<li>
否定法
— 例えば，集合を成す各~名前は、
次のどちらかにするべきである
⇒＃
すべてが，何が許容されるかを述べる／
すべてが，何が否認されるかを述べる
◎
negation, for example all of the names in a set should either describe what is allowed or they should all describe what is denied
</li>
</ul>

			<section id="naming-booleans">
<h4 title="Boolean properties vs. boolean-returning methods">真偽値をとる~prop 対 真偽値を返す~method</h4>

<p>
真偽値をとる［
~prop【~IDL属性】／~option【通例的には辞書~member】／何かについて問う~API引数
］には、
`is^c は接頭される`べきでない^em。
一方で，同じ目的を~serveする~methodは、
それに副作用は無いならば
— ~platformの他所すべてと一貫するよう —
`is^c が接頭される`べきである^em。
◎
Boolean properties, options, or API arguments which are asking a question about their argument should not be prefixed with is, while methods that serve the same purpose, given that it has no side effects, should be prefixed with is to be consistent with the rest of the platform.
</p>

			</section>
			<section id="casing-rules">
<h4 title="Use casing rules consistent with existing APIs">既存の~APIと一貫した文字大小規則を利用すること</h4>

<p>
~web~platform~API設計の歴史を通して，常に一様に従われてはなかったが、
次に挙げる文字大小規則が判明している：
◎
Although they haven’t always been uniformly followed, through the history of web platform API design, the following rules have emerged:
</p>

<div>
<dl>
	<dt>
~method／~prop
（~Web~IDLの属性, 演算, 辞書~key）
【／~methodの引数】
</dt>
	<dd>
~camel-case
</dd>
	<dd>例：
`createAttribute()＠~DOM4#dom-document-createattribute$c,
`compatMode＠~DOM4#dom-document-compatmode$c
</dd>

	<dt>
~class／~mixin（~Web~IDL~interface）
</dt>
	<dd>
~pascal-case
</dd>
	<dd>例：
`NamedNodeMap$I,
`NonElementParentNode$I
</dd>

	<dt>
~APIにおける頭字語（ `initialism^en ）
</dt>
	<dd>
~method／~prop内の最初の単語になる場合を除いて，すべて大字
</dd>
	<dd>例：
`HTMLCollection$I,
`innerHTML＠~DOM-Parsing#dom-innerhtml-innerhtml$c,
`bgColor＠~HTMLLS/obsolete.html#dom-document-bgcolor$c
</dd>

	<dt>
~APIにおける頭字語の繰返n
</dt>
	<dd>
同じ規則に従う
</dd>
	<dd>例：
`HTMLHRElement$I,
`RTCDTMFSender$I
</dd>

	<dt>
“`of "identity"/"identifier"^en （〜の~~識別情報／~~識別子）” の略語
</dt>
	<dd>
~method／~prop内の最初の単語になる場合を除いて， `Id^en
</dd>
	<dd>例：
`getElementById()＠~DOM4#dom-nonelementparentnode-getelementbyid$c,
`pointerId＠~POINTEREVENTS#dom-pointerevent-pointerid$c,
`id＠https://w3c.github.io/webappsec-credential-management/#dom-credential-id$c
</dd>

	<dt>
列挙~値
</dt>
	<dd>
小文字, ~dashで区切られる
</dd>
	<dd>例：
`no-referrer-when-downgrade＠~REFERRER-POLICY#dom-referrerpolicy-no-referrer-when-downgrade$l
</dd>

	<dt>
~event
</dt>
	<dd>
小文字, 連結される
</dd>
	<dd>例：
`canplaythrough＠~HEmedia#event-media-canplaythrough$et,
`languagechange＠~HTMLindex#event-languagechange$et
</dd>

	<dt>
~HTML要素／属性
</dt>
	<dd>
小文字, 連結される
</dd>
	<dd>例：
`figcaption$e,
`maxlength＠~HTMLforms#attr-fe-maxlength$a
</dd>

	<dt>
~JSON~key
</dt>
	<dd>
小文字, ~underscoreで区切られる
</dd>
	<dd>例：
`short_name＠~APPMANIFEST#dfn-short_name$c
</dd>
</dl>

◎
｜Casing rule｜Examples
Methods and properties
(Web IDL attributes, operations, and dictionary keys)｜Camel case｜createAttribute()
compatMode
Classes and mixins
(Web IDL interfaces)｜Pascal case｜NamedNodeMap
NonElementParentNode
Initialisms in APIs｜All caps, except when the first word in a method or property｜HTMLCollection
innerHTML
bgColor
Repeated initialisms in APIs｜Follow the same rule｜HTMLHRElement
RTCDTMFSender
The abbreviation of "identity"/"identifier"｜Id, except when the first word in a method or property｜getElementById()
pointerId
id
Enumeration values｜Lowercase, dash-delimited｜"no-referrer-when-downgrade"
Events｜Lowercase, concatenated｜canplaythrough
languagechange
HTML elements and attributes｜Lowercase, concatenated｜figcaption
maxlength
JSON keys｜Lowercase, underscore-delimited｜short_name
</div>

<div class="non-normative">

<p>
特に，~HTMLの内容~属性【！属性】が~propとして`反映-$されるとき、［
属性, ~prop
］の文字大小~法は合致するとは限らないことに注意。
例えば，
~HTML `img$e 要素の `ismap＠~HEimages#attr-img-ismap$a 属性は、
`HTMLImageElement$I の
`isMap＠~HTMLimages#dom-img-ismap$c
~propとして`反映-$される。
◎
Note that in particular, when a HTML attribute is reflected as a property, the attribute and property’s casings won’t necessarily match. For example, the HTML attribute ismap on img elements is reflected as the isMap property on HTMLImageElement.
</p>

<p>
~JSON~key用の規則は、［
~HTTP越しに送信された／~diskに格納された
］特定の~JSON~file形式に適用することが意味され，~JS~obj~keyの一般~観念には適用されない。
◎
The rules for JSON keys are meant to apply to specific JSON file formats sent over HTTP or stored on disk, and don’t apply to the general notion of JavaScript object keys.
</p>

<p>
特に，頭字語の繰返nは、
~platform全体を通して一様ではない。
上の規則に違反する，歴史的な悪名高い例は［
`XMLHttpRequest$I ／ `HTMLHtmlElement$I
］である。
これらの例には従わないこと
— 頭字語が繰返される場合、
代わりに，常に大字~化すること。
◎
Repeated initialisms are particularly non-uniform throughout the platform. Infamous historical examples that violate the above rules are XMLHttpRequest and HTMLHtmlElement. Don’t follow their example; instead always capitalize your initialisms, even if they are repeated.
</p>
</div>

			</section>
		</section>
		<section id="naming-unsafe">
<h3 title="Warn about dangerous features">12.6. 危険な特能について警告すること</h3>

<p>
開発者に供される保証を弱める特能は、
アリな所では
— そのことが目立つよう —
その名前を【 “安全でない” ことを意味する】 `unsafe^l から開始するようにすること。
◎
Where possible, mark features that weaken the guarantees provided to developers by making their names start with "unsafe" so that this is more noticeable.
</p>

<p>
例えば
`~CSP＠~CSP3$（ `Content Security Policy^en ）は、
ある種の内容~注入~脆弱性に抗する保護を供する。
~CSPは、
~keyword `unsafe-inline^v など，この保証を弱める特能も供する
— それは、
~inline~scriptを許容することにより，~CSPの自前の保護を抑制する。
◎
For example, Content Security Policy (CSP) provides protection against certain types of content injection vulnerabilities. CSP also provides features that weaken this guarantee, such as the unsafe-inline keyword, which reduces CSP’s own protections by allowing inline scripts.
</p>

		</section>
	</section>
	<section id="writing-resources">
<h2 title="Other resources">13. その他の資源</h2>

<p>
仕様を書する方法に対する いくつかの有用な助言は、
他所でも可用である：
◎
Some useful advice on how to write specifications is available elsewhere:
</p>
<ul>
	<li>
`仕様の書法：言明の種類＠https://ln.hixie.ch/?start=1140242962&amp;count=1$
（ `Writing specifications: Kinds of statements^en ）
（ `Ian Hickson^en, 2006年 ）
◎
Writing specifications: Kinds of statements (Ian Hickson, 2006)
</li>
	<li>
`~QA~framework：仕様~指針＠~TR/qaframe-spec/$cite
（ `QA Framework: Specification Guidelines^en ）
（ ~W3C ~QA ~WG, 2005年)
◎
QA Framework: Specification Guidelines (W3C QA Working Group, 2005)
</li>
	<li>
`~web~protocolにおける~privacyの考慮点＠https://w3c.github.io/privacy-considerations/$cite
（ `Privacy Considerations for Web Protocols^en ）
◎
Privacy Considerations for Web Protocols
</li>
	<li>
`~securityと~privacyに関する自己-考査~質問票＠~SECQ$cite
（ `Self-Review Questionnaire: Security and Privacy^en ）
◎
Self-Review Questionnaire: Security and Privacy
</li>
	<li>
`~web技術~accessibility指針＠https://w3c.github.io/apa/fast/$cite
（ `Web Technology Accessibility Guidelines^en ）
◎
Web Technology Accessibility Guidelines
</li>
	<li>
`仕様~開発者~向けの国際-化における最善な実施＠https://w3c.github.io/bp-i18n-specdev/$cite
（ `Internationalization Best Practices for Spec Developers^en ）
◎
Internationalization Best Practices for Spec Developers
</li>
</ul>

	</section>
	<section id="acks">
<h2 class="no-num heading settled" title="Acknowledgments">謝辞</h2>

<p>
この文書は、
~TAGによる
`設計~考査＠https://github.com/w3ctag/design-reviews/$
の間に，~TAG~memberより［
~~過去／~~現在
］に収集された原則からなる。
その~~成果は、
~TAGから設計~考査の要請を受けた すべての方々のおかげである。
◎
This document consists of principles which have been collected by TAG members past and present during TAG design reviews. We are indebted to everyone who has requested a design review from us.
</p>

<p>
~TAGは、
次に挙げる方々による，この文書, および［
それに先行する文書である
`~HTML設計~原則＠~TR/html-design-principles/$
（ `HTML Design Principles^en ）
］への貢献に感謝したい。
◎
The TAG would like to thank＼
↓...
for their contributions to this &amp; the HTML Design Principles document which preceded it.
</p>

<div lang="en">
The TAG would like to thank
Adrian Hope-Bailie,
Alan Stearns,
Aleksandar Totic,
Alex Russell,
Andreas Stöckel,
Andrew Betts,
Anne van Kesteren,
Benjamin C. Wiley Sittler,
Boris Zbarsky,
Brian Kardell,
Charles McCathieNevile,
Chris Wilson,
Dan Connolly,
Daniel Ehrenberg,
Daniel Murphy,
Domenic Denicola,
Eiji Kitamura,
Eric Shepherd,
Ethan Resnick,
fantasai,
François Daoust,
Henri Sivonen,
HE Shi-Jun,
Ian Hickson,
Irene Knapp,
Jake Archibald,
Jeffrey Yasskin,
Jeremy Roman,
Jirka Kosek,
Kevin Marks,
Lachlan Hunt,
Léonie Watson,
L. Le Meur,
Lukasz Olejnik,
Maciej Stachowiak,
Marcos Cáceres,
Mark Nottingham,
Martin Thomson,
Matt Giuca,
Matt Wolenetz,
Michael[tm] Smith,
Mike West,
Nick Doty,
Nigel Megitt,
Nik Thierry,
Ojan Vafai,
Olli Pettay,
Pete Snyder,
Philip Jägenstedt,
Philip Taylor,
Reilly Grant,
Richard Ishida,
Rick Byers,
Ryan Sleevi,
Sergey Konstantinov,
Stefan Zager,
Stephen Stewart,
Steven Faulkner,
Surma,
Tab Atkins-Bittner,
Tantek Çelik,
Tobie Langel,
Travis Leithead,
and
Yoav Weiss
</div>

<p>
`~HTML設計~原則＠~TR/html-design-principles/$を編集された，次に挙げる各氏に特別な謝意を
⇒
`Anne van Kesteren^en,
`Maciej Stachowiak^en
◎
Special thanks to Anne van Kesteren and Maciej Stachowiak, who edited the HTML Design Principles document.
</p>

<p>
この文書に貢献したが，上に名前が挙げられていない方は、
そのことを正せるよう，編集者に知らしめたし。
◎
If you contributed to this document but your name is not listed above, please let the editors know so they can correct this omission.
</p>

	</section>
</main></div>
