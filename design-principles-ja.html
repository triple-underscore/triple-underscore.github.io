<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web Platform Design Principles （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
.xattr {
	font-family: monospace0, monospace;
	color: var(--K-color);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'p':
	{
		const i = text.indexOf(':');
		if( i > 0 ){
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i+1)}</code>`;
		}
	}
	break;
case 'xA': // xattr
	text = `[${key}]`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href || link_map[ klass ? `${klass}.${key}` : key ];
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Web Platform Design Principles
spec_date:2025-12-09
trans_update:2025-10-31
source_checked:250918
original_url:https://w3ctag.github.io/design-principles/
	abbr_url:DESIGN-PRINCIPLES
spec_status:ED
site_nav:tag-finding
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:2025,permissive
trans_1st_pub:2021-08-11

●●class_map
E:error
xA:xattr
et:event-type
at:at-rule
e:element
p:property
a:attr
t:type
et:event-type
u:unit
v:value
sl:js-slot
A:abstract
jT:js-type
jv:js-value
h:header

●●tag_map
E:code
et:code
I:code
c:code
et:code
xA:code
at:code
e:code
a:code
p:code
t:var
u:code
v:code
jT:code
jv:code
sl:span
A:span
h:code
i:i
em:em
strong:strong
cite:cite

●●original_id_map
	prefer-dictionaries:prefer-dict-to-bool
	user-intent:consent

●●link_map


xA.Clamp:~WEBIDLjs#Clamp
xA.EnforceRange:~WEBIDLjs#EnforceRange
xA.Exposed:~WEBIDLjs#Exposed
xA.SecureContext:~WEBIDLjs#SecureContext

E.TypeError:~WEBIDL#exceptiondef-typeerror

jT.BigInt:~TC39M/numbers-and-dates.html#sec-bigint-objects
jT.Date:~TC39M/numbers-and-dates.html#sec-date-objects
jT.Number:~TC39M/numbers-and-dates.html#sec-number-objects
	＠~TC39M/fundamental-objects.html#sec-error-objects
	＠~TC39M/managing-memory.html#sec-weak-ref-objects
	＠~TC39M/managing-memory.html#sec-finalization-registry-objects

c.double:~WEBIDL#idl-double
c.float:~WEBIDL#idl-float
c.bigint:~WEBIDL#idl-bigint
c.byte:~WEBIDL#idl-byte
c.long long:~WEBIDL#idl-long-long
c.long:~WEBIDL#idl-long
c.octet:~WEBIDL#idl-octet
c.short:~WEBIDL#idl-short
c.undefined:~WEBIDL#idl-undefined
c.unrestricted double:~WEBIDL#idl-unrestricted-double
c.unsigned long long:~WEBIDL#idl-unsigned-long-long
c.DOMString:~WEBIDL#idl-DOMString
c.USVString:~WEBIDL#idl-USVString
c.ByteString:~WEBIDL#idl-ByteString
c.Promise:~WEBIDL#idl-promise
c.Uint8Array:~WEBIDL#idl-Uint8Array
c.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
c.SharedArrayBuffer:~WEBIDL#idl-SharedArrayBuffer
c.Float32Array:~WEBIDL#idl-Float32Array

I.AbortController:~DOM4#abortcontroller
I.AbortSignal:~DOM4#abortsignal
I.AudioWorklet:https://webaudio.github.io/web-audio-api/#AudioWorklet
	I.Blob:~FILEAPI#dfn-Blob
I.Blob:~FILEAPI#blob
I.Body:~FETCH#body
I.CaptureController:~MCSS#dom-capturecontroller
I.console:~CONSOLE#namespacedef-console
I.CredentialsContainer:https://w3c.github.io/webappsec-credential-management/#credentialscontainer
I.Crypto:https://w3c.github.io/webcrypto/#dfn-Crypto
I.CustomElementRegistry:~HEcustom#customelementregistry
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.Document:~DOM4#document
I.DOMException:~WEBIDL#idl-DOMException
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.DOMImplementation:~DOM4#domimplementation
I.DOMParser:~HTMLdynamic#domparser
I.DOMTokenList:~DOM4#domtokenlist
I.Element:~DOM4#element
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.FetchEvent:~SW1#fetchevent
I.Gamepad:~GAMEPAD#dom-gamepad
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.HTMLCanvasElement:~HEcanvas#htmlcanvaselement
I.HTMLCollection:~DOM4#htmlcollection
I.HTMLHtmlElement:~HEmetadata#htmlhtmlelement
I.HTMLHRElement:~HEgrouping#htmlhrelement
I.HTMLImageElement:~HEimages#htmlimageelement
I.HTMLInputElement:~HEinput#htmlinputelement
I.HTMLMediaElement:~HEmedia#htmlmediaelement
I.History:~WINDOW#history-3
I.IDBDatabase:~INDEXEDDB#idbdatabase
I.IDBObserver:https://github.com/WICG/indexed-db-observers
I.IdleDeadline:~REQUESTIDLECALLBACK#dom-idledeadline
I.ImageBitmap:~HTMLGAPI#imagebitmap
I.InputEvent:~UIEVENTS#inputevent
I.IntersectionObserver:~INTERSECTIONOBSERVER#intersectionobserver
	交差~観測器:~INTERSECTIONOBSERVER
I.KeyboardEvent:~UIEVENTS#keyboardevent
I.LockManager:https://w3c.github.io/web-locks/#lockmanager
I.Geolocation:~GEOLOCATION#dom-geolocation
I.GeolocationPosition:~GEOLOCATION#dom-geolocationposition
I.MouseEvent:~UIEVENTS#mouseevent
	廃）I.MutationEvent:~UIEVENTS-A#mutationevent
	#legacy-mutationevent-events
I.MutationObserver:~DOM4#mutationobserver
I.NamedNodeMap:~DOM4#namednodemap
I.Navigator:~HTMLnavigator#navigator
I.Node:~DOM4#node
I.NonElementParentNode:~DOM4#nonelementparentnode
I.PaymentRequest:~PAYMENT-REQUEST#dom-paymentrequest
I.Permissions:~PERMISSIONS#dom-permissions
I.PointerEvent:~POINTEREVENTS#dom-pointerevent
I.ProgressEvent:~XHR#progressevent
I.ReadableStream:~STREAMS#readablestream
I.RemotePlayback:https://w3c.github.io/remote-playback/#dom-remoteplayback
I.ResizeObserver:~CSSWG/resize-observer/#resize-observer-interface
	I.SecureContext:https://w3c.github.io/webappsec-secure-contexts/#integration-idl
I.RTCDTMFSender:https://w3c.github.io/webrtc-pc/#dom-rtcdtmfsender
I.ScriptProcessorNode:https://webaudio.github.io/web-audio-api/#ScriptProcessorNode
I.ShareData:~WEBSHARRE#dom-sharedata
I.TextEncoder:~ENCODING#textencoder
I.URL:~URL1#url
I.URLSearchParams:~URL1#urlsearchparams
I.Window:~WINDOW#window
	~window~obj:~WINDOW#window
I.WindowEventHandlers:~WAPI#windoweventhandlers
I.Worker:~WORKERS#worker
I.WorkerType:~WORKERS#workertype
I.WritableStream:~STREAMS#writablestream
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XMLHttpRequestEventTarget:~XHR#xmlhttprequesteventtarget


c.addEventListener():~DOM4#dom-eventtarget-addeventlistener
c.getElementsByTagName():~DOM4#dom-document-getelementsbytagname
c.target:~DOM4#dom-event-target

e.a:~HEtextlevel#the-a-element
e.abbr:~HEtextlevel#the-abbr-element
e.acronym:~HTMLobs#acronym
e.audio:~HEmedia#the-audio-element
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.figcaption:~HEgrouping#the-figcaption-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.label:~HEforms#the-label-element
e.link:~HEmetadata#the-link-element
e.option:~HEforms#the-option-element
e.output:~HEforms#the-output-element
e.q:~HEtextlevel#the-q-element
e.script:~HEscripting#the-script-element
e.select:~HEforms#the-select-element
e.source:~HEimages#the-source-element
e.style:~HEmetadata#the-style-element
e.table:~HEtables#the-table-element
e.textarea:~HEforms#the-textarea-element
e.video:~HEmedia#the-video-element
e.source:~HEimages#the-source-element


p.backdrop-filter:~CSSWG/filter-effects-2/#propdef-backdrop-filter
p.background-image:~CSSBG#propdef-background-image
p.display:~CSSDISP#propdef-display
p.font-size:~CSSFONT#propdef-font-size
p.font-size-adjust:~CSSFONT#propdef-font-size-adjust
p.initial-letter-align:~CSSINLINE#propdef-initial-letter-align
p.initial-letter:~CSSINLINE#propdef-initial-letter
p.line-height:~CSS2J#propdef-line-height
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.left:~CSSPOS#propdef-left
p.position:~CSSPOS#propdef-position

t.length:~CSSVAL#length-value
t.number:~CSSVAL#number-value
t.ident:~CSSVAL#typedef-ident

at.supports:~CSSCOND#at-ruledef-supports

u.lh:~CSSVAL#lh

	●用語
~live~obj:#live-object
静的~obj:#static-object
~monkey~patchする:#monkey-patch

	●用語（外部
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
小task:~WAPI#microtask
~task~queue:~WAPI#task-queue
	~task~queue:~SW1#dfn-service-worker-registration-task-queue
~taskを~queueする:~WAPI#queue-a-task
~task~source:~WAPI#task-source
大域~taskを~queueする:~WAPI#queue-a-global-task
要素~taskを~queueする:~WAPI#queue-an-element-task

反映-:~HTMLcdom#reflect
全部的に作動中:~HTMLds#fully-active
~BF~cache:~HTMLnav#_bf-cache

初期~値:~CASCADE#initial-value
使用~値:~CASCADE#used-value
実際の値:~CASCADE#actual-value
算出d値:~CASCADE#computed-value
継承d値:~CASCADE#inherited-value
継承-:~CASCADE#css-inheritance

解決d値:~CSSOM1#resolved-value

~scalar値:~INFRA#scalar-value
~scalar値~文字列:~INFRA#scalar-value-string
~surrogate:~INFRA#surrogate
実装定義:~INFRA#implementation-defined
文字列:~INFRA#string
符号単位:~INFRA#code-unit
~ASCII範囲:~INFRA#ascii-code-point

~maplike:~WEBIDL#dfn-maplike
~setlike:~WEBIDL#dfn-setlike
~interface:~WEBIDL#dfn-interface
名前空間:~WEBIDL#dfn-namespace
構築子~演算:~WEBIDL#idl-constructors
~IDL数量-型:~WEBIDL#dfn-numeric-type
辞書:~WEBIDL#dfn-dictionary
列挙~型:~WEBIDL#idl-enumeration
部分的な~interface定義:~WEBIDL#dfn-partial-interface
部分的な辞書~定義:~WEBIDL#dfn-partial-dictionary
単純~例外:~WEBIDL#dfn-simple-exception
共用体~型:~WEBIDL#dfn-union-type
有型~配列~型:~WEBIDL#dfn-typed-array-type
多重定義-:~WEBIDL#idl-overloading
内包-:~WEBIDL#include

~URL:~URL1#concept-url

aC.中止-を通達する:~DOM4#abortcontroller-signal-abort
通達から~algoを除去する:~DOM4#abortsignal-remove
通達に~algoを追加する:~DOM4#abortsignal-add
aB.中止-済み:~DOM4#abortsignal-aborted
aB.中止する~algo群:~DOM4#abortsignal-abort-algorithms
~eventを発火する:~DOM4#concept-event-fire

連列~型:~WEBIDL#sequence-type
観測-可能な配列~型:~WEBIDL#dfn-observable-array-type

~formに所有され得る~custom要素:~HEcustom#form-associated-custom-element

利用する許可を要請する:~PERMISSIONS#dfn-request-permission-to-use
選ぶよう利用者に~promptする:~PERMISSIONS#dfn-prompt-the-user-to-choose

●●words_table1
TC39M:https://tc39.es/ecma262/multipage
ETHICAL-PRINCIPLES:ethical-web-principles-ja.html
PRIVACY-PRINCIPLES:https://www.w3.org/TR/privacy-principles/
PAYMENT-REQUEST:https://w3c.github.io/payment-request/
PROMISES:promises-guide-ja.html
UIEVENTS-A:uievents-appendix-ja.html
	~UIEVENTS-A:TR/DOM-Level-3-Events
HTMLintroduction:HTML-introduction-ja.html
HTMLsanitizer:html-sanitizer-api-ja.html
BFCACHE:bfcache-guide-ja.html
HTTPch:http-client-hints-ja.html
HTTPbcp:http-app-bcp-ja.html
CONSOLE:console-ja.html
GAMEPAD:gamepad-ja.html
WEBSHARRE:web-share-ja.html
MCSS:https://w3c.github.io/mediacapture-screen-share/

Promise: <code>Promise</code> 
Observer: <code>Observer</code> 

●●words_table

	●略語／名称
AOM:
米国:US:~
TAG:
	~TAG:Technical Architecture Group
NFC:
ES:ECMAScript
USB:
Bluetooth:
IEEE:
	C++
	Rust
QA:
WASM:
BF:
	~BF~cacheされた:bfcached
	~BF~cacheされた:BFCached
	~BF~cache法:BFcaching
	~BF~cache:BFCache
WebTransport:
QUIC:
SSL:
TLS:

	`IndexedDB-3$r:IndexedDB
	`GEOLOCATION$r:Geolocation API
	`WebAudio$r:Web Audio API
	`RFC9110$r:https://datatracker.ietf.org/doc/html/rfc9110
	`FETCH$r:https://fetch.spec.whatwg.org/
	`FETCH$r:Fetch
	`CREDENTIAL-MANAGEMENT-1$r:Credentials Management API
	`GEOLOCATION$r:Geolocation specification
	`PERMISSIONS$r:Permissions specification
	`WEB-SHARE$r:Web Share
	font列挙~API:Font Enumeration API

	~ID:id
	^en:Cascading Style Sheets
	^en:Web App Manifest
	^en:Payment Method Manifest
	^en:Publication Manifest
	^en:Origin Policy
	^en:Content Security Policy
	^en:Chromecast
	^en:AirPlay
	^en:DOM Mutation Events
	^en:Hall of API Shame:Boolean Trap
	^I:DedicatedWorker
	^I:Event
	^I:Node

	^en:es-discus
	^en:Bugzilla
	PrototypeJS
	Sass
	IDBObserver$I:IndexedDB Observer
	観測器:Observer
	有構造~field値:Structured Field Values
	~remote再生~API:Remote Playback API
	~web~animation:Web Animations
	~web~page:Web page／web page
	構築子~method:Constructor Method
	真偽値の罠:Boolean Trap
	設計~原則:The Design Principle
	$I:Document
	MutationEvent^I:DOM Mutation Events
	MutationObserver$I:Mutation Observers
	~Promise
	~Promiseを利用する:Promise-Using
	~Web~IDL:WebIDL
	Wikipedia

	●処理
素早く:quickに:~
入口:entry point:~
小task:microtask:小 task:小タスク
際限ない:endlessな:~
process::::プロセス
繰返n:repetition:繰り返し
	〜の繰返n:repeated
繰返さな:repeatしな:繰り返さな
lifecycle:
	交差:Intersection::~
	防護-法:guarding::~
	再帰的:recursive::~
	時間がかかる:time-consuming
	し終えた:finish
浮動小数点:floating point::~
倍精度:double-precision::~
早期-:early::~
再帰:recursion::~
横取り:intercept::~
factory::::ファクトリー
相:phase::~
高頻度:frequent::~
捕捉:capture::~
捕捉-:capture::~
	~screenを捕捉する:screen-capture
batch::::バッチ
	~batchしておく:batch up
	~batch法:batching
遊休:idle::~
高分解能:high-resolution::~
milli::::ミリ
	~milli秒:millisecond
nano::::ナノ
	~nano秒:nanosecond
	秒:seconds
時機:timing::~
accessor::::アクセス子:アクセサ
maplike:
setlike:
存続期間:lifetime::~
bitmap::::ビットマップ
bitmask::::ビットマスク
切詰める:clampする:切り詰める
丸めら:roundさ:~
	小数を伴う:fractional
剰余:modulo:~
処理待ち:pending:~
覗見る:peekする:覗き見る
排他的:exclusive:~
周期的:periodical:~
復旧-:restore::~
静止-:pause::~
書込める:writeできる::書き込める
書込n:write::書き込み
書込む:writeする::書き込む
切離され:detachされ::切り離され
投機的:speculative::~
投入-:feed:~
候補:candidate:~
main::::メイン
保存-:save:~
カクつく:jankになる:~
冪等性:idempotence::~
累積:accumulation::~
timer::::タイマー
差挟まれ:interleaveされ:差し挟まれ
切替える:switchする:切り替える
分岐:branch:~
制限時間:timeout::~
剥ぐ:stripする:~
形式変換-:transform::~
高価:expensive:~

	遅過ぎる:too slow
	遅い／遅く:slow
	完了まで走る:run-to-completion
	二回以上:repeatedly
	構築-可能でない:non-constructible
	構築-可能:constructible
	行く:go through
	行く:going
	設定しておく:set up
	先送りすること:deferral
	~process間の:inter-process
	短く:short
	短い:short
	より長い:longer
	すでに起きて完遂された:already finished happening
	観測されたが まだ送達されていない:observed-but-not-yet-delivered
	取消-可能でない:non-cancelable
	一度限りの:one-time
	それ以降:rest
	長く走る:long-running
	投出すること:throwing:#1
	渡-:pass
	受け渡-:passed around
	〜をそのまま〜渡す:pass 〜 through
	取消すよう要請された:presses "cancel"
	生じた事象:occurrence
	後続して~queueされる〜:follow-up 〜
	終了~時:ending
	~cache法:caching
	他を阻む:blocking
	他を阻まない:non-blocking
	具現化を阻む:render-blocking
	同じ結果を生産する:something that 〜 produces itself
	途中:in the middle

	●security／privacy
本物:genuine:~
騙そう:trickしよう:~
危険:dangerous:~
危険性:danger:~
認証:authentication::~
機密性:confidentiality::~
特権的:privileged::~
脆弱:vulnerable::~
安全性:safety::~
乗取られ:hijackされ:乗っ取られ
真似る:resembleする:~
詐欺:scam:~
害:harm:~
害そう:harmしよう:~
害-:harm:~
私的:private::~
露呈-:reveal::露わに
形跡:trace::~
脅威:threat::~
	より~riskが高い:riskier
表口:surface::口
表面:surface::~
相関-:correlate:~
相関:correlation:~
noise::::ノイズ
野放図な:unsanctioned:~
sniff:
	~sniff法:sniffing
親権者:parent:~
partner::::パートナー
国家権力:state actor::~
製造元:make:~
銘柄:brand:~
	銘柄:branding
弱める:weakenする:~
晒し:exposeし:~
暗号:crypto:~
暗号用の:cryptographic:~
side-channel::::サイドチャネル
XSS:
無毒化-:sanitize::~
無毒化器:sanitizer::~
侵害:breach:~
侵害的:invasive:~
Spectre:
開示-:disclose:~
受動的:passive:~
能動的:active:~
持続的:persistent:~
識別用の:identifying:~
識別情報:identity:~
権限付与-:authorize::~
乗取り:jacking:乗っ取り
濫用-:abuse:~
疲れ:fatigue:~
弱体化-:compromise:~
欺瞞:deception:~
騙り:trickery:~
後悔-:regret:~
	悔やまれる:regrettable
確認:confirmation:~
惰性:habitual:~
喚起-:remind:~
撤回-:retract:~
煩しさ:annoyance:煩わしさ
煩しい:annoying:煩わしい
関与iする:involveされる:関与する
信じた:believeした:~

	抗-:against
	信用-済み:trusted
	信用に価する:trustworthy
	信用-済みでない:untrusted
	~secureでない:insecure
	~secureでない:non-secure
	安全な形式とみなされる:they are safelisted
	安全でない:unsafe
	~~入口:ingress point
	~~出口:egress point
	公開され:exposure
	~filter法:filtering
	誤って利用される:misuse
	迫る:pressure
	超えて残り続ける:last longer than

	●UI
touch::::タッチ
tap::::タップ
picker:::選択 UI
選定器:selector::~::セレクタ
	~~選ばれ:pick
非可視:hidden:~
clipboard::::クリップボード
押付け:intrusive:押し付け
前面:front:~

	●呈示／CSS
紙:paper:~
先頭字:initial letter::~
埋没:drop::~
沈込み:sunken::沈み込み
沈込する:sinkする::沈み込む
持上げ:raised::持ち上げ
頭字:cap::~
高さ:height:~
見かけ:look:~
視られ:viewされ:~
視れる:viewできる:~
	~view可能:viewable
flex:
格子:grid::~::グリッド
筋:track::~::トラック
見出し:heading:~
隠す:hideする:~
隠せる:hideできる:~
塗り:paint:~
	塗り用に準備済み:ready to paint
Lab:
	~Lab色＠:L*a*b* color
色彩科学:Color Science:~
明滅-:flash:~
	~CSS選択子:selector
	未~styleな:unstyled

	●環境／hardware
internet:
mobile::::モバイル
online::::オンライン
off-line::::オフライン
filesystem::::ファイルシステム
camera::::カメラ
microphone::::マイク
sensor::::センサー
gyroscope::::ジャイロスコープ
加速度計:accelerometer::~
周辺機器:peripheral:~
計算機:computing device:~
disk::::ディスク
遮断:disruption:~
低性能:low-powered:~
	とり外され:unplugged

	●命名
専門用語:technical term:~
代名詞:pronoun:~
形容詞:adjective:~
成句的用語:term of art:~
略語:abbreviation:~
語根:root form:~
動詞:verb:~
名詞:noun:~
品詞:part of speech:~
文字大小規則:casing rule:~
	文字大小~法:casing
camel-case:
	~camel-case化:camel-cased
pascal-case:
頭字語:initialism:~
大字:capital:大文字
	大字:caps
	大字~化:capitalize
underscore::::アンダースコア
dash::::ダッシュ
後続-:follow:~

	^en:signposting
	^en:blocklist
	^en:allowlist
	^en:blacklist
	^en:whitelist
	^en:replica
	^en:master
	^en:slave

	●仕様
設計者:designer:~
trade-off::::トレードオフ
助言:advice:~
目指す:aimする:~
目指して:aimして:~
拒否-:refuse:~
拒否:refusal:~
正当化-:justify:~
独立性:independence:~
上品:graceful:~
総意:consensus:~
活動:activity:~
機能-:function:~
機能:function:~
機能上は:functionalには:~
機能上の:functionalな:~
策:strategy:~
防護-:guard:~
複雑な:complicatedな:~
念頭:mind:~
稀:rare:~
文言:language:~
必要性:needs:~
正せる:correctできる:~
協調-:coordinate:~
働けな:workできな:~
多彩:rich:~
自立的:standalone:~
理想的:ideal:~
proprietary::::プロプライエタリ
ecosystem::::エコシステム
発展:evolution:~
発展-:evolve:~
進化-:evolve:~
施行:enforcement:~
申請-:file:~
質問:question:~
質問票:questionnaire:~
考案-:invent:~
背後:behind:~
理論的:theoretical:~
社会:society:~
現実:reality:~
相補的:complementary:~
補う:complementする:~
土台:foundation:~
比較検討-:weigh:~
同意:consent:~
同意-:consent:~
柔軟:flexible:~
柔軟性:flexibility:~
解く:solveする:~
解決策:solution:~
実現可能:feasible:~
利点:advantage:~
個人的:personal:~
雇用者:employer:~
動作者:actor:~
消費者:consumer:~
翻訳-:translate:~
障害:disabilities:~
堅牢:robust:~
	堅牢~性:robustness
拙く:poorに:~
	拙く:poorly-
調和-:harmonize:~
想像-:imagine:~
事実調査:research:~
有益:beneficial:~
知見:finding:~
厳格:rigorous:~
説明書き:explainer:~
通過制御-:gate:~
決定的:deterministic:~
満足-:satisfy:~
	~~満足:happy
一様:uniform:~
本当:real:~
察知-:learn:~
学習曲線:learning curve:~
冗長:redundant:~
周知:well-known:~
警告-:warn:~
支援技術:assistive technologies:~
英語:English:~
話者:speaker:~
命令的:imperative:~
読する:readする:読む
読して:readして:読んで
読した:readした:読んだ
読され:readされ:読まれ
書法:writing:書き方
書者:writer:書き手
書する:writeする:書く
書せる:writeできる:書ける
書され:writeされ:書かれ
書した:writeした:書いた
選択:choice:~
	選ぶこと:choice
選ばれ:chooseされ:~
選ぶ:chooseする:~
選んだ:chooseした:~
選べる:chooseできる:~
	選べる:able to choose
能性:potential:~
	になり得るもの:potential
	能性がある:potentially
	アリ性:possibility
考して:thinkして:考えて
考する:thinkする:考える
	よく考して:thoughtfully
考出され:thought-outされ:考え出され
明白:obvious:~
critical:
monkey:
patch::::パッチ
親切:friendly:~
	親切さ:friendliness
究明-:investigate:~
自己完結的:self-contained:~
自己記述的:self-describing:~
模擬-:mock:~
種類:kind:~
自由:free:~
	自由に:freely
倫理上の:ethicalな:~
	倫理上の:Ethical
完璧:perfect:~
順応-:adapt:~
転用-:adapt:~
責務:responsibility:~
	責務がある:responsible
今日:today:~
余分:extra:~
加的な:extraな:追加の
価値:value:~
	価値をもたらす:valuable
個人:person:~
判明-:emerge:~
利用元:user:~
合理性:rationale:~
多方面で:extensiveに:~
大多数:majority:~
必然的に:naturalに:~
悪名高い:infamousな:~
感じる:feelする:~
指名-:designate:~
推測-:guess:~
根深い:profoundな:~
比較的:relativeに:~
活発:vibrant:~
現実的:realistic:~
生活:life:~
破って:breakして:~
簡潔:concise:~
解明-:figure out:~
探求-:seek:~
open:
	~openでない:closed
	~openでない:non-open
為され:makeされ:~
為す:makeする:~
為し:makeし:~
為せ:makeでき:~
人物:persona:~
公表物:publication::~
包括的:inclusive:~
編集-:edit:~
編集s:edits:編集
editor::::エディタ
訊いて:askして:~
続行-:proceed:~
合意-:agree:~
否定法:negation:~
否定的:negative:~
対処-:workaround:~
	対処-:work-around:~
領分:domain:~
分野:area:~
優先度:priority:~
優先-:prioritize:~
優先順位付ける:prioritizeする:~
	優先度を下げる:prioritize
engineering:
語法:terminology:~
臭:smell:~
	~code臭:code smell
関心事:interesting thing:~
	何か関心事:something interesting
関心:interest:~
	関心がある:interested
各個人:individuals:~
増強-:enhance:~
力:power:~
	力を持つ:power over
	力を与える:empower
努める:tryする:~
先例:precedent:~
齢:age:~
馴染み:familiar:~
寄与-:contribute:~
相反な:mutual に exclusiveな:相反する
利便性:usability:~
	利便性:usability amenities
拙い:poorな:~
競合-:conflict:~
競合:conflict:~
衝突:clash:~
普及度:prevalence:~
普及度合い:popularity:~
普及な:popularな:普及している
	普及させる:roll out
	~~普及-:enough
人間工学:ergonomics:~
	使い易く:ergonomic
論争:heated debate:~
antipattern::::アンチパタン
重大:material:~
顕在化-:materialize:~
世界:world:~
	外の世界:the world
公平:impartial:~
立証-:prove:~
防御的:defensive:~
正しさ:correctness:~
専門家:expert:~
必要十分:adequate:~
介入-:intervene:~
急速:quick:~
持込む:bringする:持ち込む
持込まれ:bringされ:持ち込まれ
アル:possibleである:ある
構築部品:building block:~
類似しな:similarでな:~
可読:readable:~
	〜として可読:-readable
妥協-:compromise:~
	妥協-法:compromising
tradeoff::::トレードオフ
dilemma::::ジレンマ
手助け:facilitate:~
原型:prototype::~::プロトタイプ
広範:extensive:~
近道:shortcut:~
	総称:shortcut
複階度:complexity:~
共通度:commonality:~
妨害-:disrupt:~
難題:challenge:~
欠陥:defect:~
	~~欠陥:flaw
品質:quality:~
最悪:worst:~
	最悪な場合:at worst
不作為:inadvertent:~
陥穽:pitfall:落とし穴
一時的:temporary:~
短期的:short-lived:~
地点:point:~
復帰-:revert:~
冗漫さ:verbosity:~
請合う:warrantする:請け合う
惑わす:confuseする:~
	〜を惑わす:confusion
模倣-:emulate:~
補助:helper:~
補助的:auxiliary:~
人々:people:~
義務:obligation:~
義務的:mandatory:~
社会的弱者:disadvantaged or marginalized users:~
欠如-:lack:~
変種:variant:~
規範:norm:~
追求-:pursue:~
保つ:keepする:~
保たれ:keepされ:~
併合-:merge:~
paste::::ペースト
上流:upstream:~
真剣:serious:~
深刻:serious:~
保守者:maintainer:~
末端-:end:~
引用-:quote:~
収束-:converge:~
支配的:dominant:~
出荷-:ship:~
	出荷しなく:un-ship
	出荷しなく:unship
難点:downside:~
定着-:entrench:~
普段は:regularに:~
不定期:indefinite:~
尊重-:respect:~
遂げる:carry outする:~
規範:norm:~
	規範:the norm
団体:institution:~
	可用か否か:availability
保守的:conservative:~
元々は:originalには:~
減衰-:decline:~
誤記:typo:~
理論:theory:~
複雑化:complication:~
処-:deal:~
取引-:deal:~
根本的:fundamental:~
重大:material:~
反例:counterexample:~
重複物:duplicative:~
不一致:discrepancy:~
不利:disadvantage:~
苦労-:struggle:~
運用-:operate:~
	運用されて:happens to operate
長持ち:outlast:~
成句的:idiomatic:~
特質:property:~
組織化-:organize:~
	もっと良く組織化する:better organization
捏造:fake:~
大袈裟:overkill:~
無意味:meaningless:~
utility:
創出-:mint:~
例外的:exceptional:~
仮想の:imaginaryな:~
支払う:payする:~
明確さ:clarity:~
的確:right:~
認可:approval:~
不可避:unavoidable:~
微妙:subtle:~
伝える:communicateする:~
	伝わり:inform
	~~伝える:tell
不可欠:crucial:~
利用度:usage:~

	避けれない:can’t avoid
	~~経験則:rules of thumb
	きちんと:well-
	されたし:please
	したい:would like to
	しようとするもので:would go on to
	すなわち:This means that
	すべての方々に:who everyone
	その成果は〜のおかげ:indebted to
	それでも:still
	たぶん:perhaps
	つきまとう:come with
	ついて来る:come with
	とってもっと良くなる:would be better-off
	とは限らない:won’t necessarily
	かなり:quite
	ほどには:quite as safe as
	もっと多彩:richer
	一様でない:non-uniform
	主な:main
	予期せず:unexpectedly
	期待されない:unexpected
	促す:help encourage
	助けになる:help
	助けに:helpful
	よう助ける:help 〜
	傾向にある:tends to
	内での活動, 外での活動:activity both in and out
	難しい:hard
	難しく:hard
	方が難しい／難しく:harder
	単-目的:single-purpose
	原因:cause
	原因になる:causing
	厳密に:strictly
	可用でない:unavailable
	同様に:likewise
	呼ばれ／称され:called
	呼応して:in response to
	在る:present
	堅持する:sticking
	失う:losing
	容易さ:ease
	対:vs.
	対照的に:in contrast
	必要:need
	感謝:thank
	手続き全体を読するか飛ばすか:read the steps or skip over them
	抽象-化:abstraction
	指して／指す:refer
	指定されたとおり:as-specified
	採る:take
	探す:look for
	推測-可能:guessable
	損なう:undermineする
	敷居:barrier to entry
	文法~上の:grammatical
	方が明瞭／もっと明瞭:clearer
	最も容易:easiest
	有無:presence
	有無:presence or absence
	極めて:extremely
	残念なことだが:sadly
	気付いた:notice
	注意点:Use care
	注意点:caution
	特に注意する:be cautious
	に注意:beware
	注意を払う:pay attention
	注記-:note
	満たす:meet
	無い:not present
	無為にする:defeat
	特に:notably
	用立てる:make use
	真っ先に挙がる:Most prominent
	知る:know
	突きつける:pose
	突きつける:being confronted with
	純粋さ:purity
	総合的に:overall
	合計で:overall
	織り込む:account
	考慮し直す:re-consider
	考慮し直す:reconsider
	に至る:lead
	へ至らす:lead
	良い:good
	行える:do able
	およそ:likely
	見込まれる:likely
	見込みが高く:likely
	見込みは高まる:more likely to
	見込みが高い:likely
	ほぼ見込まれない:unlikely
	およそ〜ないと見込まれる:unlikely
	の視点で:points from 〜 perspective
	謝意:thanks
	足りる:suffice
	~~全般に:across
	またがって:across
	場:place
	十分:enough
	〜に過ぎる:overly
	その発想元:inspired
	ひらめき:inspiration
	より~~緩やか:shallower
	思いがけない:surprising
	意に反する:surprising
	挙動が〜異なる:behave differently
	異なった／違える／異なるように:differently
	違える:had a different
	~~短さ:brevity
	~UAが供した:User-Agent-provided
	将来にも通用する:future-proof
	将来にも通用する命名:future-proofing
	手続きの詳細に入る:going into detail
	多様な:virtually any
	~~時期もあった:There have been times
	ある種の:certain types of
	このことから:because of this
	次第に逸れる:^en:scope creep
	調べる／調べて:look-at
	であった頃から:back then
	当の:said
	言った:said
	勧告候補~後:post-CR
	取り込む:ingest
	当の:your
	当の仕様の:your
	対象者:audience
	~~対象者:constituencies
	満たせない／満たされ:hold
	そのことが目立つよう:more noticeable
	事実／:fact
	考慮に入れる:for consideration
	何も告げない:gives no sign
	一定期間は:certain times
	アリでない:impossible
	作る:make
	必ず:making sure
	〜すること。:be sure to 〜
	〜すること。:make sure 〜
	確かめる:make sure
	ようになる:can make sure
	因んで命名され:named for
	記載-:set out
	〜であった既存の:pre-existing
	収まった:fit
	各種~言語にわたる:cross-language
	またぐ:cross
	〜間の:cross-
	複数~文書にわたる:span multiple documents／document-spanning／:cross-document-spanning
	~careする:take care
	~debug能:debuggability
	者たち:someone who
	支持する:favoring
	支持する:favor
	支持する方に:in favor of
	支持を受けて:in favor of
	対立する:tension between
	対立:tension
	次第に:gradually
	最終的に:eventually
	どれに該当するか:what 〜 will be
	再利用-:re-use
	損なう:undermine
	ようにする:let
	大部分の:bulk of
	目の前の:at hand
	道:path
	逃げ道:escape hatch
	進むべき道:a way forward
	道:route
	略して:for short
	与えるゆとりがある:afford
	形作れ:emerge
	無い:free from
	低~levelな:low level／:low-level／:lower-level
	高~levelな:high level／:high-level／:higher-level
	存在しないもの:non-existent
	その力に比して，利用の難易度がひどく上がることはない:continuity of the ease-of-use vs power tradeoff curve
	-:sharp cliff
	層~化され:layered
	層を重ねる:layer 〜 on top of
	~~上層:on top of
	逆:inverse
	設計し直す:redesign
	互換でない:incompatible
	著しい:severe
	著しさ:severity
	著しく:severely
	簡便でないものほど:inconvenience 〜 the least
	~tool群:tooling
	残る:last
	価する:worth
	もちろん:of course
	判明-:turn out
	明瞭でない:unclear
	そのままで:out of the box
	そのまま:verbatim
	劣化-:further decrease
	~module化:modularization
	間違って:wrongly
	決めつける:presuppose
	失われ:miss
	悪化しかねない:Or worse, 〜 worse
	相互に関係する:interrelated
	~~許容される:ok
	~~強く勧める:highly advisable
	ごく:highly
	~web~platform:the Web Platform／:the web platform
	相応するもの:counterpart
	反する~pattern:counterpattern
	この逆も成立するわけではない:This does not hold the other way around
	〜のみが:single
	後の祭りだが:In hindsight
	留意-:remember
	覚え易く:easier to remember
	〜と命名すること:call
	〜に従って:after
	非~一貫性:~inconsistencies
	顕著に:pronounce
	非推奨にされる:deprecation of
	分類:categories
	該当する:falls into
	~~不正に機能-:malfunction
	現時点で:at the moment
	現今においては:as of today
	難が生じる:suffer
	賢く:wisely
	邪魔-:hinder
	~~述べ:say
	に対し:against
	受け取る:take
	より早く:sooner
	~~区間:section
	拘束され過ぎ:over-constrained
	拘束され過ぎ:over-constraint
	実装:implementor
	~~関係者すべて:all involved
	〜に従事-:operate
	標準でない:non-standard
	最小~化:minimize
	最小~化:minimizing
	最小~化:minimization
	実装-能:implementability
	実装-可能:implementable
	~~現時点では:present-time
	勝る:outweigh
	好ましい:preferable
	用意がない:unwilling
	用意がある:willing
	標準~化の場:standards venues
	非~標準:nonstandard
	知りながら:knowing
	一つしかない:single-
	その結果は:outcome
	最終的な:outcome
	結果として〜なる:outcome
	~bug含み:buggy
	~~気付かない:unaware
	考慮-:consideration
	何か:item
	のみならず:not solely
	に倣って:in line with
	言える:can be said
	現れない:appear
	現れさせ:appear
	にも見える:appear
	生じ易く:prone
	様々な:range of
	代わりとして:in place
	言い訳として:excuse
	透明~性:transparency
	~~起因-:originate
	無いに等しく:nothing
	そうすることで:This way,
	抱える:has
	問題になり得る:problematic
	~model化:modeled
	概ね:roughly
	仕様:spec
	適した:suited
	逆に:conversely
	そもそも:at all
	~~合理的に:sensibly
	予測-能:predictability
	倣う:align
	略称を成す:stands for
	~~既存の:preexisting
	~~用途:utility
	直結して:directly connected to
	不足なく:sufficient
	無縁:have nothing to do with
	与える:afford
	行うに価するほど:to be worth doing
	標準~化されてない:non-standardized
	にもかかわらず:despite

	●言い換え
	~~比して過不足がある:does more or less
	当然のことと~~見なす:take for granted
	努力を怠らない:hard
	一部の文脈〜ない:n't 〜 every possible context
	なくとも済む:can avoid
	〜向けの:oriented
	ある下:given
	かなり~~増す必要があろう:would have had to create a good bit of
	こと自体が〜抵触する:which would fail if
	~~特定すること:pinpointing
	~~都合良く:better
	縁遠い:less directly connected
	選好する:preference 〜 towards
	~~理解し難くなる:harm comprehension
	良く理解する:Gaining a good understanding
	必要なら:presumably
	そのこと:this omission
	一致する:agree
	~~影響:inform
	どちらにするか，~~情報を得た上で:informed
	もっと判り易くする:make 〜 less confusing
	そのこと:this omission
	あろう仕方とは逆に:instead of a hypothetical algorithm which would ...
	仮に〜あったとするとき:hypothetical
	作成できなくなって:prevents the creation of
	むしろ:What is more 〜 is
	きちんとした意図nがある:well intentioned
	もっと単純に:less complex
	余地もある:there might be scope for
	〜~mode下にある:〜mode is engaged
	その~modeから離れた:disengage
	〜よう希望される:hopefully
	~~十分な~~根拠になる:warrant
	組込みの~accessibility:accessibility built-in
	〜するようにする:mark
	含まない:excluding
	〜方が無難:err on the side of 〜
	事前に備えておく:proactive
	〜していなかった:have missed
	前者と後者どちらか:one of these groups of
	必要が生じる:necessitating
	〜よりも:secondary
	実用的に:practicality of having
	仕様~化-:specify
	さもなければ:The alternative 〜 is
	~~版:iteration
	重ねて持ち込む:duplicate
	決して変更されない:cannot, and will not, be changed
	名前を付ける:Carving out 〜 naming
	相互運用可能にする~cost:the interoperability costs
	〜に従って:guide
	特化するためには:specialization
	特化され過ぎ:overspecialization
	目的が副作用にある:side-effect-causing
	により〜無効になること:cause be lost

	~~言葉:word
	~void要素:empty element
	~~自動化:automobile
	前置された:left-hand
	〜を包装する〜:wrapper
	包装するもの:wrapper around
	され続ける:keep
	何かについて問う~API引数:API arguments which are asking a question about their argument
	全部的に作動中になったとき, なくなったとき:full activity is lost or not
	~feedback:feeding it back to
	~algo群:collection
	一群の:set of
	引用符 〜 の入れ方:quoting
	~labelを伴わない:unlabeled
	一文字の:single-letter
	~commandと~query:Command–query
	~MIME型:media type
	多くは 〜 占める:most often
	~~省く必要がある:cannot have
	各〜間で:〜-wide
	動作は〜異なる:act 〜 differently
	直後:after 〜ing
	（機会が）与えられる:create
	成す例として，次が挙げられる:An incomplete list of
	~worker:Worker
	真偽値:Boolean
	が挙げられる:include
	何か行う:do stuff
	行えるもの以外は何もしない:do nothing that 〜 couldn’t do
	値がアテガわれる際に:assignment
	状態を伴う:statefull
	何か:thing
	makes 〜 to:できるようにする
	2 つほどしかない:With one or two
	その他:but is not limited to

	●未分類

void:
polyfill:
manifest::::マニフェスト
schedule::::スケジュール
schema::::スキーマ
component::::コンポーネント
singleton:
signature:
prototype:
asset::::アセット
多形態性:polymorphism::~
共用体:union::~
多重定義-:overload::~
多重定義:overloading::~
用字系:script:~
Latin:
Cyrillic:::キリル文字
Arabic:::アラビア語
支払い:payment::~
店:store:~
持続-:persist:~
合成な:syntheticな:~
近過去:recent:~
機械:machine:~
数量-:numeric:~
数値化-:quantify:~
付番-:number:~
番号:number:~
実数:number:~
surrogate::::サロゲート
遭遇-:encounter:~
連結-:concatenate:~
出荷先:shipping:~
請求先:billing:~
区切られ:delimitされ:~
疑似-:pseudo-:~
再生:playback::~
再生-:play::~
percent-:%-
日付:date::~
日時:date-time::~
派生:derived::~
弱い:weakな::~
切取られ:clipされ::切り取られ
束ねる:tieする::~
束する:bundleする::束ねる
重合しな:overlapしな:重なり合わな
重合する:overlapする:重なり合う
食品注文:food ordering:~
言語束縛:binding::~::バインディング
絞込まれ:filterされ:絞り込まれ
交換:exchange:~
先行-:precede:~
量:amount:~
居残な:stickyな::居残る
一過:transient::~
組織的:organical:~
付随-:accompany:~
実験n:experimentation:実験
部屋:room:~
丸括弧:parentheses:~
角括弧:square brackets:~
前処理器:preprocessor::~::プリプロセッサ
空欄:blank:~
共有:sharing::~
頻繁:frequent:~
計量:metric::~
側:side:~
細やか:granular:~
	細やかさ:granularity
bulkな::かさばった
付-:attach:~
	付され:attachment
運ぶ:carryする:~
埋めた:fillした:~
解読:decryption::~
上位型:supertype::~
	上位型:the parent
	上位型:super-type
下位型:subtype::~
	下位型:the child
代用:substitution::~
算出的:computational:~
内包-:include::~
入出力:I/O:~
密集:compact:~
	密集~度:compactness
構成-:compose:~
構成:composition:~
給した:supplyした:~
給する:supplyする:~
区分:partition:~
呈-:exhibit:~
最終-:final:~
定期的:constant:~
恒久的:permanent:~
中断:interruption::~
音響:sound:~
archive::::アーカイブ

	`infinity^jv, `-infinity^jv:infinities
	`infinity^jv, `-infinity^jv:±Infinity
	`0^jv, `-0^jv:±0
	jv:NaN
	`number^jT:number

	持続-可能:persistable
	~style上の:stylistic
	列挙d値:enums
	し始める:beginning
	し始める:begin
	始める:begin
	始まる:begin
	型を伴う:typed
	し続ける:continues to
	遡って:walking up
	真偽値を返す:boolean-returning
	膨大な:vast
	継承されない:non-inherited
	到達-不能:unreachable
	-:keep things
	近づける:keep 〜 as close as
	単-~page:single-page
	戻る:back
	〜片:piece of
	~~過去および~~現在:past and present
	~~過去:the past
	過去の:past
	たった今:just
	~styleを伴わない:unstyled
	所属-:belong
	置く:put
	低くする:lower
	低下する:lower
	残さな:leave
	残す:leave
	ままに:leave
	様々な~sizeの:very wide range of 〜 sizes
	指定が不十分:isn’t specific enough
	単位が無い:unitless
	増やす:increaseする
	増える:increaseする
	増やさ:increase
	少し増すだけで:small amount of incremental
	いくぶんの:some amount of
	速い:fast
	より速い:faster
	生きた:live

	いくつもの:more than a couple of
	一連の:collection of
	一連の:series of
	連列／一連の:sequence
	同時:simultaneous
	同時:at the same time
	非:non
	非-:non
	〜以外:non-〜
	重ねて:twice
	項:term
	〜に劣る:~less 〜
	最も近い:nearest
	何倍になるか:multiple
	次回に:next
	次回の:the next
	途中で:in the middle
	いつの時点でも:at all times
	回ごとに／毎回:each time
	回:time
	ようになった頃:at the time
	その頃は:at the time
	時点では:at the time
	一回に:at a time
	周り:around
	数:number
	数がより少ない:fewer
	もっと短い:shorter
	小さく:small
	小さな:small
	より小さ:smaller
	少なく:smaller
	少なく:small
	少ない:small
	少量な:small amount
	~~最小限:smallest
	~~最小限:minimal
	少量:least
	ごく少数:tiny
	僅かな:tiny
	少なく:less
	~~増す:larger
	より大きな:larger
	大きく:large
	多数の:large number
	多大な:very large
	のほとんど:mostly
	旧い:older
	旧い:old
	第一に:first
	複数回:more than once
	一回:once
	一度に／まとめて:at once
	だけ:just
	それ自体で:on its own
	だけでは足らない:’t sufficient by themselves
	の多く:a lot of
	〜以下の:at most
	ほぼ:almost
	唯一の:the only
	多くの:many
	後で:later
	入らない:outside
	結果の:resulting
	ただ〜だけ:merely
	より高／もっと高ければ:higher
	高-:high-
	向かう:toward
	誰か:someone
	〜のときも／ときには，:sometimes
	より広い:wider
	広くから:widely
	広く:widely-
	幅広い:wide
	多様な:wide variety of
	いくつかの:a number of
	数多くの:a large number of
	除いて:except
	他所:elsewhere
	他の:the rest of
	他所すべて:the rest
	残り:the rest
	一人の:single
	一部の者:some
	他の者:Others
	各部:pieces
	各部:parts
	先に:earlier
	まず，:firstly
	最後に:finally
	より新たな:newer
	近く:closely
	全体を通して:throughout
	〜に~~後続する:subsequent
	〜に~~後続する:given
	関する:regard
	に基づいてを:with regard to
	箇所／点:point
	指す:point
	一方〜他方:vice versa
	上述した:the earlier
	多大に:hugely
	大部分は:mostly
	-:micro-
	先頭から順に:left to right
	末尾から順に:right to left
	ずっと:much more
	とても:very
	もの:thing
	一片の／〜片:bit of
	場所:place
	箇所:place
	幾度となく:a lot of
	最も近い:closest
	前者より広い:broader
	広過ぎる:too broad
	［巨大に／広く］なり過ぎた:grows too large or too broad
	広く再利用するため:for broad reuse
	他所へ:away
	前者:the-first-part
	何回か:repeatedly
	最後に:final
	最新:up-to-date
	よりずっと長く:a lot longer than
	あまりに多くの:a large number of
	幾度となく:A lot of the time
	何百万もの:millions
	今後、:upcoming
	〜の他にも，いくつもある:several 〜 and many more
	順番に:in series
	当の:in question
	とは限らない:not always
	他者:others
	他所:others
	するようになった:has come to
	~~並行:alongside
	身代わり:stand in
	相互に:mutually
	対価を払って:paying
	あらゆる:every
	あらゆるもの:everything
	どこにでも:everywhere
	末尾の:trailing
	~comment用の:commenting
	~formに所有され得る:form-associated
	及ぼす:cause
	もの:thing
	~~狭める:containする
	を伴わない:non-
	直後:immediately after
	決まった個数以内の 〜 行う:within a fixed number of
	~group化:group
	~~軽い:mild
	のうちいずれか:all of
	~~否と~~答えた:say no
	〜片:piece of
	残された:remaining


●●ref_key_map
HIGHRESTIME:HRTIME
INDEXEDDB3:INDEXEDDB
ETHICALWEBPRINCIPLES:ETHICALWEB

●●ref_data
ETHICALWEB=副               ~/ethical-web-principles-ja.html
REQUESTIDLECALLBACK=副      ~/requestidlecallback-ja.html
WEBAUDIO=主                 g200kg.github.io/web-audio-api-ja/
WEBAUDIO=・                 webaudio.github.io/web-audio-api/
WEBTRANSPORT=副             ~/webtransport-ja.html
RFC9205=副                  ~/http-app-bcp-ja.html
CONSOLE=副                  ~/console-ja.html
WEBANIMATIONS2=副           ~/web-animations-ja.html●Level 1 日本語訳
FILTEREFFECTS2=副           ~/filter-effects-ja.html●Level 1 日本語訳
GAMEPAD=副                  ~/gamepad-ja.html
WEBSHARE=副                 ~/web-share-ja.html

●●ref_normative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONDITIONAL-3]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[FINGERPRINTING-GUIDANCE]
    Nick Doty; Tom Ritter. ＜Mitigating Browser Fingerprinting in Web Specifications＞. URL: https://w3c.github.io/fingerprinting-guidance/
[HIGHRES-TIME]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[I18N-GLOSSARY]
    Richard Ishida; Addison Phillips. ＜Internationalization Glossary＞. URL: https://w3c.github.io/i18n-glossary/
[IndexedDB-3]
    Steven Becker. ＜Indexed Database API 3.0＞. URL: https://w3c.github.io/IndexedDB/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[PAYMENT-REQUEST]
    Marcos Caceres; Ian Jacobs; Stephen McGruer. ＜Payment Request API＞. URL: https://w3c.github.io/payment-request/
[PERMISSIONS]
    Marcos Caceres; Mike Taylor. ＜Permissions＞. URL: https://w3c.github.io/permissions/
[PRIVACY-PRINCIPLES]
    Robin Berjon; Jeffrey Yasskin. ＜Privacy Principles＞. URL: https://w3ctag.github.io/privacy-principles/
[REQUESTIDLECALLBACK]
    Scott Haseley. ＜requestIdleCallback()＞. URL: https://w3c.github.io/requestidlecallback/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[RFC9205]
    M. Nottingham. ＜Building Protocols with HTTP＞. June 2022. Best Current Practice. URL: https://httpwg.org/specs/rfc9205.html
[SERVICE-WORKERS]
    Monica CHINTALA; Yoshisato Yanagisawa. ＜Service Workers Nightly＞. URL: https://w3c.github.io/ServiceWorker/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEB-ANIMATIONS-2]
    Brian Birtles; Robert Flack. ＜Web Animations Module Level 2＞. URL: https://drafts.csswg.org/web-animations-2/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[XHR]
    Anne van Kesteren. ＜XMLHttpRequest Standard＞. Living Standard. URL: https://xhr.spec.whatwg.org/

●●ref_informative

[APPMANIFEST]
    Marcos Caceres; et al. ＜Web Application Manifest＞. URL: https://w3c.github.io/manifest/
[CONSOLE]
    Dominic Farolino; Robert Kowalski; Terin Stock. ＜Console Standard＞. Living Standard. URL: https://console.spec.whatwg.org/
[CREDENTIAL-MANAGEMENT-1]
    Nina Satragno; Marcos Caceres. ＜Credential Management Level 1＞. URL: https://w3c.github.io/webappsec-credential-management/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-FONTS-4]
    Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-FONTS-5]
    Chris Lilley. ＜CSS Fonts Module Level 5＞. URL: https://drafts.csswg.org/css-fonts-5/
[CSS-GRID-1]
    Tab Atkins Jr.; et al. ＜CSS Grid Layout Module Level 1＞. URL: https://drafts.csswg.org/css-grid-1/
[CSS-INLINE-3]
    Elika Etemad. ＜CSS Inline Layout Module Level 3＞. URL: https://drafts.csswg.org/css-inline-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[CSSOM-VIEW-1]
    Simon Fraser; Emilio Cobos Álvarez. ＜CSSOM View Module＞. URL: https://drafts.csswg.org/cssom-view/
[ENCRYPTED-MEDIA]
    Joey Parrish; Greg Freedman. ＜Encrypted Media Extensions＞. URL: https://w3c.github.io/encrypted-media/
[ETHICAL-WEB-PRINCIPLES]
    Daniel Appelquist; Hadley Beeman; Amy Guy. ＜Ethical Web Principles＞. URL: https://w3ctag.github.io/ethical-web-principles/
[FileAPI]
    Marijn Kruisselbrink. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[FILTER-EFFECTS-2]
    ＜Filter Effects Module Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/filter-effects-2/
[GAMEPAD]
    Steve Agoston; Matthew Reynolds. ＜Gamepad＞. URL: https://w3c.github.io/gamepad/
[INTERNATIONAL-SPECS]
    Richard Ishida; Addison Phillips. ＜Internationalization Best Practices for Spec Developers＞. URL: https://w3c.github.io/bp-i18n-specdev/
[INTERSECTION-OBSERVER]
    Stefan Zager; Emilio Cobos Álvarez; Traian Captan. ＜Intersection Observer＞. URL: https://w3c.github.io/IntersectionObserver/
[LEAST-POWER]
    Tim Berners-Lee; Noah Mendelsohn. ＜The Rule of Least Power＞. 23 February 2006. TAG Finding. URL: https://www.w3.org/2001/tag/doc/leastPower
[POINTEREVENTS3]
    Patrick Lauke; Robert Flack. ＜Pointer Events＞. URL: https://w3c.github.io/pointerevents/
[REFERRER-POLICY]
    Jochen Eisinger; Emily Stark. ＜Referrer Policy＞. URL: https://w3c.github.io/webappsec-referrer-policy/
[REMOTE-PLAYBACK]
    Mark Foltz. ＜Remote Playback API＞. URL: https://w3c.github.io/remote-playback/
[RFC8890]
    M. Nottingham. ＜The Internet is for End Users＞. August 2020. Informational. URL: https://www.rfc-editor.org/rfc/rfc8890
[RFC9000]
    J. Iyengar, Ed.; M. Thomson, Ed.. ＜QUIC: A UDP-Based Multiplexed and Secure Transport＞. May 2021. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9000
[RFC9110]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. ＜HTTP Semantics＞. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9110.html
[SCREEN-CAPTURE]
    Jan-Ivar Bruaroey; Elad Alon. ＜Screen Capture＞. URL: https://w3c.github.io/mediacapture-screen-share/
[THE-WEB-IS-UNVERSIONED]
    Sangwhan Moon; Amy Guy. ＜The web is unversioned＞. 27 March 2025. TAG Finding. URL: https://www.w3.org/2001/tag/doc/the-web-is-unversioned/
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. ＜UI Events＞. URL: https://w3c.github.io/uievents/
[UNSANCTIONED-TRACKING]
    Mark Nottingham. ＜Unsanctioned Web Tracking＞. 17 July 2015. TAG Finding. URL: http://www.w3.org/2001/tag/doc/unsanctioned-tracking/
[WEB-LOCKS]
    Kagami Rosylight. ＜Web Locks API＞. URL: https://w3c.github.io/web-locks/
[WEB-SHARE]
    Marcos Caceres; Eric Willigers; Matt Giuca. ＜Web Share API＞. URL: https://w3c.github.io/web-share/
[WebAudio]
    Paul Adenot; Hongchan Choi. ＜Web Audio API＞. URL: https://webaudio.github.io/web-audio-api/
[WEBCRYPTO-2]
    Daniel Huigens. ＜Web Cryptography Level 2＞. URL: https://w3c.github.io/webcrypto/
[WEBRTC]
    Cullen Jennings; et al. ＜WebRTC: Real-Time Communication in Browsers＞. URL: https://w3c.github.io/webrtc-pc/
[WebTransport]
    Nidhi Jaju; Victor Vasiliev; Jan-Ivar Bruaroey. ＜WebTransport＞. URL: https://w3c.github.io/webtransport/

●●ref_additional

[RFC8942]
    I. Grigorik; Y. Weiss. ＜Client Hints＞. February 2021. Experimental. URL: https://www.rfc-editor.org/rfc/rfc8942
[GEOLOCATION]
    Marcos Caceres; Reilly Grant. ＜Geolocation＞. URL: https://w3c.github.io/geolocation/

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Web Platform Design Principles</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/design-principles/
公表履歴
	https://www.w3.org/standards/history/design-principles/
フィードバック
	https://github.com/w3ctag/design-principles/issues/
編集
	<a href="https://lowentropy.net/">Martin Thomson</a> (Mozilla)
	Jeffrey Yasskin (Google)
前任編集者
	<a href="https://lea.verou.me">Lea Verou</a> (Invited Expert)
	<a href="https://sangwhan.com">Sangwhan Moon</a> (Google)
	<a href="https://domenic.me/">Domenic Denicola</a> (Google) <a href="mailto:d@domenic.me">d@domenic.me</a>
	<a href="mailto:travil@microsoft.com">Travis Leithead</a> (Microsoft)
By
	<a href="https://www.w3.org/2001/tag/">Members of the TAG</a>, past and present
Participate
	<a href="https://github.com/w3ctag/design-principles">GitHub w3ctag/design-principles</a> (<a href="https://github.com/w3ctag/design-principles/issues/new">file an issue</a>; <a href="https://github.com/w3ctag/design-principles/issues?state=open">open issues</a>)

commit 履歴
	https://github.com/w3ctag/design-principles/commits/main

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Web プラットフォーム設計原則 — Web Platform Design Principles</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、
~web~platform技術を設計するときに利用される，一群の設計~原則を包含する。
これらの原則は、
開発-中にある仕様を`考査する＠https://github.com/w3ctag/design-reviews/$ときにおける，
技術-~architecture~group
（ `Technical Architecture Group^en, 略称 ~TAG）
【以下，この訳では、~TAG と略記する】
による論点から収集されたものであり，
`倫理上の~Web原則^cite （ `Ethical Web Principles^en ） `ETHICAL-WEB-PRINCIPLES$r
の上に築かれた。
仕様~設計者には、
この文書を読して，設計~裁定を為すときの資源として利用することが奨励される。
◎
This document contains a set of design principles to be used when designing web platform technologies. These principles have been collected during the Technical Architecture Group’s discussions in reviewing developing specifications, and build upon the Ethical Web Principles [ethical-web-principles]. We encourage specification designers to read this document and use it as a resource when making design decisions.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
~TAGにより公表された編集者草案です…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="basic-principles">
<h2 title="Principles behind design of Web APIs">1. ~Web~API設計の背後にある原則</h2>

<p>
この設計~原則（ `The Design Principles^en ）は、
`倫理上の~Web原則^cite `ETHICAL-WEB-PRINCIPLES$r 内に記載された倫理上の~frameworkから直に~~影響される。
これらの原則は、［
~web~platformを開発することにつきまとう，より高~levelな倫理上の責務
］に呼応して，具象的かつ実用的な助言を供する。
◎
The Design Principles are directly informed by the ethical framework set out in the Ethical Web Principles [ethical-web-principles]. These principles provide concrete practical advice in response to the higher level ethical responsibilities that come with developing the web platform.
</p>

		<section id="priority-of-constituencies">
<h3 title="Put user needs first (Priority of Constituencies)">1.1. 利用者の必要性を第一に置くこと（~~対象者の優先度）</h3>

<p>
~trade-offを為す必要がある場合、
常に，利用者の必要性を他のすべてより上に置くこと。
◎
If a trade-off needs to be made, always put user needs above all.
</p>

<p>
類似に，~APIを設計し始めるときは、
当の~APIが取組もうと目指す利用者の必要性【！need】を理解して，それを文書化すること。
◎
Similarly, when beginning to design an API, be sure to understand and document the user need that the API aims to address.
</p>

<p>
`~internetは末端-利用者のためにある＠~RFCx/rfc8890$：
~web~platformに為される どの変更も，
`膨大な数の人々に影響する＠~ETHICAL-PRINCIPLES#allpeople$能性があり、
どの個人の生活にも根深い影響iがあり得る。
`RFC8890$r
◎
The internet is for end users: any change made to the web platform has the potential to affect vast numbers of people, and may have a profound impact on any person’s life. [RFC8890]
</p>

<div class="p">
<p>
必要性の優先順は、
次に挙げる順になる：
</p>
<ol>
<li>利用者の必要性
<li>~web~page作者の必要性
<li>~UA実装者の必要性
<li>仕様の書者の必要性
<li>理論的な純粋さ
</ol>
◎
User needs come before the needs of web page authors, which come before the needs of user agent implementors, which come before the needs of specification writers, which come before theoretical purity.
</div>

<div class="p">
<p>
他のすべての原則と同様に，これは絶対的ではない：
</p>
<ul>
	<li>
著作の容易さは、
内容が利用者へどう到達するかに影響する。
</li>
	<li>
~UAは、
有限な~engineering資源を優先順位付ける必要がある
— それは、
特能が作者へどう到達するかに影響する。
</li>
	<li>
仕様の書者も資源は有限である。
</li>
	<li>
理論的な懸念は、
これらの~groupの下層の必要性~すべてを反映する。
</li>
</ul>
◎
Like all principles, this isn’t absolute. Ease of authoring affects how content reaches users. User agents have to prioritize finite engineering resources, which affects how features reach authors. Specification writers also have finite resources, and theoretical concerns reflect underlying needs of all of these groups.
</div>

<p>
次も見よ
⇒＃
`§ ~webは、社会に害をもたらさない＠~ETHICAL-PRINCIPLES#noharm$ ／
`§ ~webは、各個人による制御と力を増強する＠~ETHICAL-PRINCIPLES#control$ ／
`RFC8890$r
◎
See also:
• The web should not cause harm to society
• The web must enhance individuals' control and power
• [RFC8890]
</p>

		</section>
		<section id="safe-to-browse">
<h3 title="It should be safe to visit a web page">1.2. ~web~pageは安全に訪問できるべきである</h3>

<p>
新たな特能を追加するときは、
利用者の期待
— ~web~pageを訪問することは、
一般に安全であること —
を保全するように設計すること。
◎
When adding new features, design them to preserve the user expectation that visiting a web page is generally safe.
</p>

<p>
~Webは、
その~hyperlinkされた構造に因んで命名された。
~webが活発であり続けるためには、
利用者が次を期待-可能になる必要がある
⇒
所与の どの~linkに対しても、
それをただ訪問しただけでは，［
利用者の~computer~security／
利用者の`~privacy＠~ETHICAL-PRINCIPLES#privacy$の本質的な側面
］に対する含意は無い。
◎
The Web is named for its hyperlinked structure. In order for the web to remain vibrant, users need to be able to expect that merely visiting any given link won’t have implications for the security of their computer, or for any essential aspects of their privacy.
</p>

<p>
例えば、
ある~APIが，どの~web~siteにも
`支援技術の利用を検出する＠#do-not-expose-use-of-assistive-tech$ことを許容すると、［
どの~web~pageも，この私的な情報を検出し得る
］ようになるので，これらの技術の利用者は［
未知な~web~pageを訪問するのは安全でない
］と感じるようになる。
◎
For example, an API that allows any website to detect the use of assistive technologies may make users of these technologies feel unsafe visiting unknown web pages, since any web page may detect this private information.
</p>

<p>
利用者が安全性に現実的な期待を持てるならば、
彼らは［
~Webに基づく技術, 他の技術
］どちらにするか，~~情報を得た上で裁定を為せるようになる。
例えば，利用者は、
~appを~installするより，~webに基づく食品注文~pageを利用する方を選ぶであろう
— ~native~appを~installするのは、
~web~pageを訪問するより~riskが高いので。
◎
If users have a realistic expectation of safety, they can make informed decisions between Web-based technologies and other technologies. For example, users may choose to use a web-based food ordering page, rather than installing an app, since installing a native app is riskier than visiting a web page.
</p>

<p>
~web上の安全性の現実が利用者の期待に合致する方へ必ず向かうよう作業するため、
新たな特能を追加するときは，相補的な~approachをとれる：
◎
To work towards making sure the reality of safety on the web matches users' expectations, we can take complementary approaches when adding new features:
</p>
<ul>
	<li>
利用者は~UIを通して~Webを利用する
— ~UIは、［
利用者が期待するもの（および，しないもの）は何であるべきか
］が より明瞭になるよう，改善できる。
◎
We can improve the user interfaces through which the Web is used to make it clearer what users of the Web should (and should not) expect;
</li>
	<li>
~Webの技術的な土台は、
~privacyに関する利用者の期待に合致するよう，変更できる。
◎
We can change the technical foundations of the Web so that they match user expectations of privacy;
</li>
	<li>
期待が もっと高かったなら，利用者にとって より良くなる事例を考慮できる。
そのような事例では、
技術的な［
土台, 期待
］どちらも変更するよう試行できる。
◎
We can consider the cases where users would be better off if expectations were higher, and in those cases try to change both technical foundations and expectations.
</li>
</ul>

<p>
新たな特能が安全性の~riskを導入する場合でも、
それが［
利用者にとって、
同じ~taskを~web~page上で遂行する方が，
~native~appを~installするより安全になる
］ことを許容するならば，
利用者の安全性は総合的に改善され得る。
しかしながら，この便益は、［
~web~pageの安全性に適理な期待を有している利用者たち
］の共通な目標と比較検討される必要がある。
◎
A new feature which introduces safety risks may still improve user safety overall, if it allows users to perform a task more safely on a web page than it would be for them to install a native app to do the same thing. However, this benefit needs to be weighed against the common goal of users having a reasonable expectation of safety on web pages.
</p>

<p>
次も見よ
⇒
`~securityと~privacyに関する自己-考査＠~SECQ$cite
◎
See also:
• Security and Privacy Self-Review
</p>

		</section>
		<section id="trusted-ui">
<h3 title="Trusted user interface should be trustworthy">1.3. 信用-済み~UIは信用に価するべきである</h3>

<p>
新たな特能が信用-済み~UIに影響iするかどうかを考慮すること。
◎
Consider whether new features impact trusted user interfaces.
</p>

<p>
利用者は、［
~URL~bar／~security指示子／許可~prompt
］などの信用-済み~UIに依存して，自身が誰とどうヤリトリしているかを理解する。
これらの信用-済み~UIは、
それらが供する情報が［
本物であって，当の~web~siteにより［
偽装されていない／乗取られていない
］こと
］を利用者が［
信用する, `検証yする＠~ETHICAL-PRINCIPLES#verify$
］ことを可能化するような仕方で，設計-可能でなければナラナイ。
◎
Users depend on trusted user interfaces such as the address bar, security indicators and permission prompts, to understand who they are interacting with and how. These trusted user interfaces must be able to be designed in a way that enables users to trust and verify that the information they provide is genuine, and hasn’t been spoofed or hijacked by the website.
</p>

<p>
新たな特能が，信用-済み~UIを真似ることを信用-済みでない~UIに許容する場合、
利用者にとって，どの情報が信用に価するか理解するのは より困難になる。
◎
If a new feature allows untrusted user interfaces to resemble trusted user interfaces, this makes it more difficult for users to understand what information is trustworthy.
</p>

<div class="example">
例えば，~JSの
`alert()＠~HTMLGAPI#dom-window-alert-noargs$c
は、［
~browserの一部を成す様な見かけの~modal~dialog
］を示すことを~pageに許容する。
これは、
詐欺~web~siteの中へ訪問するよう利用者を騙そうと試みるために利用されることが多い。
この特能が今日に提案されたなら、
おそらく続行されなかったであろう。
◎
For example, JavaScript alert() allows a page to show a modal dialog which looks like part of the browser. This is often used to attempt to trick users into visiting scam websites. If this feature was proposed today, it would probably not proceed.
</div>

		</section>
		<section id="user-intent">
<h3 title="Design for user intent">1.4. 利用者の意図~用の設計</h3>

<p>
当の~APIは、［
安全でない能性がある能力に~accessするときには，利用者-期待を満たす
］ことを［
それを利用する~web~siteに奨励する
］よう設計すること。
◎
Use your API design to encourage websites to meet user expectations when accessing potentially unsafe capabilities.
</p>

<p>
~web~pageは、
利用者の必要性を充足している文脈において，
害を及ぼす能性を有する特能を用立てるよう求めることもある。
そのような特能を利用することは、
当の特能による帰結
（例：それが露呈する個人的な情報や, それが変更する状態）
が利用者の期待に合致する場合に限り，アリになるべきである。
◎
In the context of fulfilling a user need, a web page may want to make use of a feature that has the potential to cause harm. Using such a feature should only be possible if the user’s expectation matches the feature’s consequences (e.g., the personal information it reveals or the state it changes).
</p>

<p>
当の~APIを［
その挙動が，人々が何を［
意図するか, 期待するか
］に合致する
］よう設計すること。
最善な事例では、
人々が~APIによる~accessを許容することに関与iする必要はなくなるので，
後で後悔する裁定も為し得なくなる。
利用者に確認を依頼することは、
例外的な状況下に限ること。
ある能力が［
恒久的に害を及ぼす機会c
］を伴うことなく［
容易に復帰できる／
それによる煩しさは~~軽いものに限られる
］場合、
代わりに，能力への~accessを停止する~optionを利用者に与えること。
◎
Design your API so its behavior matches what people intend and expect. Then, in the best case, people don’t need to get involved in allowing API access and thus can’t make decisions they regret later. Only ask the user for confirmation in exceptional circumstances. If a capability can be easily reverted or causes only mild annoyance without the chance for permanent harm, afford users an option to stop capability access instead.
</p>

<p class="example">
例えば、
~web~pageが音響を再生する許可を利用者に依頼する必要はない。
ある~siteが音声~出力を濫用していることが見出された場合，
それを停止することは容易であり、
~browserは，
それだけを行うための仕組みを いくつか有する。
◎
For example, web pages don’t need to ask for permission to play sounds. It is easy to stop audio output if a site is found to be abusing it, and browsers have a number of mechanisms for doing just that.
</p>

			<section id="user-decisions">
<h4 title="Help users make good decisions">1.4.1. 利用者が良い裁定を為すよう助けること</h4>

<p>
~API~levelの~riskを制限すること, および［
明確さ, 文脈, 利用者-制御
］を供することにより，
利用者に良い裁定を為す力を与えること。
◎
Empower good decision-making by limiting risk at the API level and providing clarity, context, and user control.
</p>

<p>
利用者に認可を依頼することは、
残された~riskを取扱うための共通的な仕方であった。
しかしながら、
人々は，不可欠な［
文脈, 情報
］を欠如する下では［
依頼された質問に対し，良い裁定を為せない
］ことが多い。
［
困難な／煩しい
］質問を突きつけることは、［
裁定~疲れ,
惰性な応答,
頻繁な中断による煩しさ,
悔やまれる裁定
］へ至らす。
◎
Asking for user approval has been a common way to handle the remaining risk. However, people often can’t make good decisions on the questions they’re asked because they lack crucial context and information. Being confronted with difficult or annoying questions leads to decision fatigue, habitual responses, annoyance from frequent interruptions, and regrettable decisions.
</p>

<p>
利用者-関与iが不可避なときは、
利用者に良い裁定を為す力を与えること。
以下に挙げる原則を利用すること：
◎
When user involvement is unavoidable, empower users to make good decisions. Use these principles:
</p>
<dl>
	<dt>
`まずは、~API~levelにおける~riskに取組むことにより，不良な裁定による帰結を制限すること。^strong
◎
Limit the consequences from a bad decision by addressing risk at the API level first.＼
</dt>
	<dd>
“不良な” 裁定が［
装置が弱体化される／個人的~dataの深刻な開示
］の様な著しい帰結へ至らせ得る所では、
利用者に質問を依頼しないこと。
◎
Do not ask users questions where a "bad" decision can lead to severe consequences, like a compromised device or serious personal data disclosure.
</dd>

	<dt>
`持続的な裁定について定期的な~feedbackを供すること。^strong
◎
Provide constant feedback about persistent decisions.＼
</dt>
	<dd>
利用者の裁定が現在の~sessionを超えて残り続ける場合、
~UAは，
過去の裁定が依然として適用されることを利用者に喚起するべきである。
進行中な許可があるときは、
それを撤回する仕方を供すること。
~APIは、
~site用に，状態sにおける変化を察知する仕方を含めるべきである。
◎
If users' decisions last longer than the current session, user agents should remind users that their past decision still applies. Provide a way to retract any ongoing permission. APIs should include a way for sites to learn of the change in status.
</dd>

	<dt id="ask-understandable-questions">
`人々が理解できる質問を依頼すること。^strong
◎
Ask questions people can understand.＼
</dt>
	<dd>
特能についての質問は、［
典型的な利用者がそれを読したとき，
当の特能に伴われる~riskを即時に考する
］ようになるべきである。
また、
そのような~riskは，当の［
特能／~API
］の~~用途に~~直結しているべきである。
このことは、
例えば，［
指紋収集~riskを受容する許可は、
通例的には依頼できない
］ことを意味する
— それらは、
微妙であり,
技術的であり,
共通して当の能力~自体とは無縁なので。
◎
When a typical user reads the question about a feature, they should immediately think of the associated risks. The risks should also be directly connected to the feature’s or API’s utility. For example, this usually means we can’t ask permission to accept fingerprinting risks, as they are subtle, technical, and commonly have nothing to do with the capability itself.
</dd>

	<dt>
`文脈を不足なく供すること。^strong
◎
Provide sufficient context.＼
</dt>
	<dd>
人々が次について容易に理解する必要がある
⇒＃
自身が誰と取引しているか／
何についての裁定か／
当の~web~siteは，彼らと共有するかもしれない情報を どう利用することになるか
◎
People need to easily understand who they’re dealing with, what the decision is about, and how the website will use any information they might share.
</dd>
</dl>

<p>
上に挙げた原則のうちいずれかを固守できない場合、
それは，利用者に依頼することは的確な~approachではない指示である見込みが高い。
代わりに、
残された~riskに取組むよう，当の［
特能／~API
］を変更すること。
◎
If you can’t adhere to all of the above principles, that is likely an indication that asking the user isn’t the right approach. Instead, change the feature or API to address any remaining risk.
</p>

<div class="note">
<p>注記：
~browserには、
許可~要請を管理する責務がある。
~browserが［
利用者と~siteのヤリトリによる結果が，許可~要請に対する適理な期待に どう沿うか
］を精確に理解することは，可能にならない。
~web~platformは，多くの［
目的と意図を伝えるための仕方
］を~siteに供するが、
それらは，［
欺瞞や騙りを使役するための仕方
］にもなる。
◎
A browser is responsible for managing requests for permission. Browsers will not be able to understand precisely how a user’s interaction with a site might result in a reasonable expectation of a permission request. The web platform provides sites with many ways either to communicate purpose and intent, or to employ deception and trickery.
</p>

<p>
したがって、
意図を明瞭に伝える責務は，［
~APIの設計,
~browserにおける~UI設計,
~web~siteが どう構築されるか
］の間で共有される。
~API用の［
単純な／明白な／既定の
］用法~patternに従ったなら、
結果として，利用者の意図が自然に尊重されるようになることが好ましい。
この原則は、［
利用者の意図を尊重する~siteを構築すること
］を奨励するよう［
~API設計に依頼すること
］までに限られる。
◎
The responsibility for clearly communicating intent is therefore shared between the design of APIs, user interface design in browsers, and how websites are constructed. It is preferable if respect for user intent is a natural outcome of following the simple, obvious, or default usage pattern for the API. This principle only asks that API designs encourage to construct sites that respect user intent.
</p>
</div>

<p>
当の仕様において同意を依頼するための良い仕方として、［
`利用する許可を要請する$,
`選ぶよう利用者に~promptする$
］~algo `permissions$r が挙げられる。
◎
In your specification, the request permission to use and prompt the user to choose algorithms from [permissions] are good ways to ask for consent.
</p>

<p>
利用者に裁定を為すよう依頼したとき，利用者は~~否と~~答えた場合、
当の~web~siteは，［
利用者が，たった今~accessを拒否したと信じたもの
］を行えるようになるべきでない。
例えば，
~UAが ある~APIを介して［
ある情報~片を露呈する許可
］を依頼した場合、
許可を伴わない限り，
同じ情報が異なる~APIを介して可用になるべきではない。
◎
If you ask a user to make a decision and they say no, the website shouldn’t be able to do anything the user believes they just refused access to. For example, if the user agent asks permission to reveal a piece of information via one API, the same information shouldn’t be available with no permission via a different API.
</p>

<p>
拒否と他の共通的な状況を~siteが判別できない場合、
拒否が最も効果的である。
そうすれば、
~siteが［
利用者に対し同意を是認するよう迫る
］ことは，より困難になり得る。
◎
Refusal is most effective if the site cannot distinguish refusal from other, common situations. This can make it more difficult for a site to pressure users to grant consent.
</p>

<p>
次も見よ
⇒＃
`§ ~webは、~secureであり，人々の~privacyを尊重する＠~ETHICAL-PRINCIPLES#privacy$／
`§ 同意~原則＠~PRIVACY-PRINCIPLES#consent-principles$／
`PERMISSIONS$r
◎
See also:
• The web is secure, and respects people’s privacy
• Consent Principles
• Permissions
</p>

			</section>
		</section>
		<section id="identity">
<h3 title="Use identity appropriately in context">1.5. 識別情報を文脈において適切に利用すること</h3>

<p>
人々が［
様々な文脈の下で，~webに対し呈示している自身についての識別用の情報
］に対する`制御＠~ETHICAL-PRINCIPLES#control$を彼らに与えること
— それついて透明であること。
◎
Give people control over the identifying information about themselves they are presenting in different contexts on the web, and be transparent about it.
</p>

<p>
“識別情報（ `identity^en ）” は、
多くの異なる仕方で理解され得る，複階的な概念である。
それは、
誰かが自身を［
どう呈示するか／どう見ているか
］を指すことも，自身が［
他の人々／~group／団体
］（順不同）とどう関係するかを指すこともあり、
その者が［
どう挙動するか／他者によりどう扱われるか
］（順不同）を決定し得る。
~web~architectureにおける “識別情報” は、［
識別子や, それに付された情報
］を指す総称として利用されることが多い。
◎
"Identity" is a complex concept that can be understood in many different ways. It can refer to how someone presents or sees themselves, how they relate to other people, groups, or institutions, and can determine how they behave or how they are treated by others. In web architecture, "identity" is often used as a shortcut to refer to identifiers, and the information attached to them.
</p>

<p>
［
識別子や，それに付された ある個人についての~data
］を［
利用する, あるいは それに依存する
］特能は、［
単独の［
~API／~system
］を超えて到達することが多い~privacy~risk
］を運ぶ。
これには、
受動的に生成された~data
（例：~web上での彼らの挙動について）も，
能動的に収集された~data
（例：彼らが ある~form内で埋めたもの）も含まれる。
◎
Features that use or depend on identifiers and the attachment of data about a person to that identifier carry privacy risks which often reach beyond a single API or system. This includes data that has been passively generated (for example, about their behaviour on the web) as well as that which has been actively collected (for example, they have filled in a form).
</p>

<p>
そのような特能に対しては：
◎
For such features,＼
</p>
<ul>
	<li>
それが利用されることになる`文脈を理解する＠~PRIVACY-PRINCIPLES#identity$ベキである
— それが［
~webを成す他の特能と~~並行して，どう利用されることになるか
］も含めて。
◎
you should understand the context in which it will be used, including how it will be used alongside other features of the web.＼
</li>
	<li>
`利用者の意図~用に設計して＠#user-intent$，
`利用者が良い裁定を為すよう助ける＠#user-decisions$こと。
◎
Make sure to design for user intent and help users make good decisions.
</li>
	<li>
~APIが収集する~dataの量は`必要yな~~最小限になる＠~PRIVACY-PRINCIPLES#data-minimization$よう設計すること。
◎
Design APIs to collect the smallest amount of data necessary.＼
</li>
	<li>
持続的な識別子が絶対的に必要yでない限り、
短期的かつ一時的な識別子を利用すること。
◎
Use short-lived, temporary identifiers unless a persistent identifier is absolutely necessary.
</li>
</ul>

		</section>
		<section id="devices-platforms">
<h3 title="Support the full range of devices and platforms (Media Independence)">1.6. 全部的な範囲の装置と~platformを~supportすること（媒体からの独立性）</h3>

<p>
~web上の特能は、
アリな限り`多くの異なる＠~ETHICAL-PRINCIPLES#multi$［
入力~装置／出力~装置／~screen~size／ヤリトリ~mode／~platform／媒体
］にまたがって働くことを確保すること。
◎
As much as possible, ensure that features on the web work across different input and output devices, screen sizes, interaction modes, platforms, and media.
</p>

<p>
~Webの主な価値の一つは、
極めて柔軟なことにある：
ある~web~pageは、［
多様な消費者~計算機で様々な~sizeの~screenで視られる／
印刷される媒体を生成するために利用される／
数多くの異なる仕方でヤリトリされる
］こともある。
新たな特能は、
~web~platformの`既存の柔軟性＠~ETHICAL-PRINCIPLES#render$に合致するべきである。
◎
One of the main values of the Web is that it’s extremely flexible: a Web page may be viewed on virtually any consumer computing device at a very wide range of screen sizes, may be used to generate printed media, and may be interacted with in a large number of different ways. New features should match the existing flexibility of the web platform.
</p>

<div class="note">
<p>注記：
これは、［
一部の文脈では働かない特能を除外するべきである
］ことは含意しない。
例えば
⇒＃
~hyperlinkは、紙に印刷されたときは訪問し得ない。
`click^et ~eventは、~touch入力~装置により~pointerが同じ~gestureで位置され, ~clickされる所（ “~tap” ）では，完璧には翻訳されない。
◎
This doesn’t imply that features which don’t work in every possible context should be excluded. For example, hyperlinks can’t be visited when printed on paper, and the click event doesn’t translate perfectly to touch input devices where positioning and clicking the pointer occur in the same gesture (a "tap").
</p>

<p>
それでも，当の特能は、
多様な文脈にまたがって働くことに加え，その元の意図を~supportしない装置に順応できる
— 例えば，ある~mobile装置~上の~tapは、
~fallbackとして `click^et ~eventを発火することになる。
◎
These features still work across a wide variety of contexts, and can be adapted to devices that don’t support their original intent - for example, a tap on a mobile device will fire a click event as a fallback.
</p>
</div>

<p>
特能はまた、［
それを利用する最も容易な仕方は，柔軟性を保守する
］ように設計されるべきである。
◎
Features should also be designed so that the easiest way to use them maintains flexibility.
</p>

<div class="example">
<p>
~CSSの［
`塊~layout＠~CSSDISP#block-layout$／
`格子~layout＠~CSSGRID#grid-layout$／
`~flex~layout＠~CSSFLEX#flex-layout$
【！`display$p に対する `block^v／`flex^v／`grid^v 】
］~modelは、
既定では，内容を可用な空間の中で重合しないよう配置する
— それにより，様々な~screen~sizeにまたがって働くことに加え、
~textを~overflowさせずに自前の［
~font, ~font~size
］を選ぶことを利用者に許容する。
◎
The 'display: block', 'display: flex', and 'display: grid' layout models in CSS all default to placing content within the available space and without overlap, so that it works across screen sizes, and allows users to choose their own font and font size without causing text to overflow.
</div>

<p>
特能は、
ときには，一部の［
実装／~platform
］では まだ可用でないこともある
— 他では働くにもかかわらず。
そのような事例では、
当の特能は，［
上品に失敗する, あるいは~polyfillするための~codeがアリになる
］ように設計されるベキである。
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$
を見よ。
◎
Sometimes features aren’t yet available on some implementations or platforms despite working on others. In these cases, features should be designed such that it is possible for code to gracefully fail or be polyfilled. See § 2.6 New features should be detectable.
</p>

		</section>
		<section id="new-features">
<h3 title="Add new capabilities with care">1.7. 新たな能力は~careの下で追加すること</h3>

<p>
~webに新たな能力を追加するときは、
既存の［
機能性／内容
］を考慮すること。
◎
Add new capabilities to the web with consideration of existing functionality and content.
</p>

<p>
~Webには、
追加を許容する拡張~地点が数多くある
— 例えば、
`HTML$r `§ 拡張能＠~HTMLintroduction#extensibility$
を見よ。
◎
The Web includes many extension points that allow for additions; see for example HTML § 1.7.2 Extensibility.
</p>

<p>
何かを追加する前に，既存の［
類似な能力
］との統合を考慮すること。
その結果，選好される設計~approachが［
何かを追加するだけでは実装し得ないもの
］へ至らす場合でも、
それはアリかもしれない
— `§ 能力を［除去する／変更する］前に既存の用法を理解すること＠#removing-features$
を見よ。
◎
Before adding items, consider integration with existing, similar capabilities. If this leads to a preferred design approach that cannot be implemented by only adding items, it might still be possible; see § 1.8 Remove or change capabilities only once you understand existing usage.
</p>

<p>
最初に検査することなく，［
変更／除去
］はアリでないとは見做さないこと。
◎
Do not assume that a change or removal is impossible without first checking.
</p>

		</section>
		<section id="removing-features">
<h3 title="Prioritize compatibility when changing or removing features">1.8. 特能を変更する／除去するときは、互換性を優先すること</h3>

<p>
ある特能が どう挙動するかを変更する前に，
~web~siteが現在~それをどう利用しているか理解すること。
◎
Before changing how a feature behaves, understand how websites are currently using it.
</p>

<p>
良く理解するためには、
事実調査が要求されるかもしれない
— 例えば，［
広く利用される~UAに【当の特能の利用度に関する】計量を追加する／
`~HTTP~archiveを探索する＠https://har.fyi/guides/getting-started/$
］ことにより。
内容を非互換化することは、
利用者を害する
— 変更による便益は、
その害を行うに価するほど有意に勝る必要がある。
`the-web-is-unversioned$r
◎
Gaining a good understanding might require research, for example by adding metrics to a widely-used user agent or by searching the HTTP Archive. Breaking content harms users, and the benefit of a change has to significantly outweigh that harm to be worth doing [the-web-is-unversioned].
</p>

<p>
既存の用法を理解する義務は、
内容が依拠している［
標準~化されてない特能／未指定な特能
］にも適用される。
これには、
~vendorに~proprietaryな特能や実装~bugも含まれる。
◎
The obligation to understand existing usage also applies to non-standardized or unspecified features that content relies upon. This includes vendor-proprietary features and implementation bugs.
</p>

<p>
にもかかわらず、
多数の~web利用者の体験を改善するために，
一部の既存の内容を非互換化することが受容-可能になるときもある。
非互換化は、
当の［
特能／挙動
］に依存する既存の内容が次に挙げるいずれかに該当する場合には，
もっと受容-可能になる見込みが高い：
◎
Despite this, it is sometimes acceptable to break some existing content in order to improve the experience for a large number of web users. Breakage is more likely to be acceptable if:
</p>
<ul>
	<li>
それらは、
僅かな量に限られる。
◎
Only a tiny amount of existing content depend on the feature or behavior.
</li>
	<li>
それらを見る人々は、
ごく少数しかいない。
◎
Only a tiny number of people see that content.
</li>
	<li>
それらは、
~test【当の特能や挙動を~testするための】［
事例／例
］にしか現れない。
◎
The content appears only in test cases or examples.
</li>
	<li>
それらは、
広く利用される一部の~UAにおいて，すでに非互換化されていて、［
当の~UAは、
そのことについて多数の~bug報告を受取っていない
］か［
当の変更には、
相互運用能を改善することが期待されている
］。
◎
The content is already broken in some widely-used user agents, and either they have not received many bug reports about it, or the change is expected to improve interoperability.
</li>
	<li>
それらを非互換化することには、
多大な便益がある。
例えば、
旧い［
~SSL／~TLS
］~versionを除去すると，いくつかの~siteは到達-不能になるが、
より多くの~security侵害を防止する。
◎
The benefit of breaking content is very large. For example, removing old SSL and TLS versions caused a number of sites to become unreachable but prevents more security breaches.
</li>
</ul>

		</section>
		<section id="leave-the-web-better">
<h3 title="Leave the web better than you found it">1.9. ~webをより良いものにして残すこと</h3>

<p>
~web~platformに新たな能力を追加するときは、
~platformが総合的に改善される仕方で行うこと。
◎
As you add new capabilities to the web platform, do so in a way that improves the overall platform.
</p>

<p>
~platformの一部に存在する欠陥を当の欠陥に対する［
追加／拡張
］の言い訳として利用してはナラナイ
— そうすると，~platformの品質は総合的に劣化するので。
◎
The existence of a defect in one part of the platform must not be used to excuse an addition or extension to the defect, which would further decrease the overall platform quality.
</p>

<p>
既存の問題になり得る設計~patternとの一貫性は、
そのような~patternを新たに指定される［
~Web~API／~platform特能
］へ伝播する良い理由にはならない。
新たな~web能力は、
~platformの品質が総合的に改善されるよう，
アリな所では既存の欠陥を軽減することにより築くこと。
◎
Consistency with existing problematic design patterns is not a good reason to propagate those patterns in newly specified Web APIs or platform features. Where possible, build new web capabilities that improve the overall platform quality by mitigating existing defects.
</p>

<p>
既知な欠陥を抱える~platform特能を拡張する際には、
当の欠陥に取組む方法を考慮すること。
既存の問題を完全に修正することは必要yでないが、
既知な課題を伴う特能を拡張するときには，~~欠陥に取組む何らかの試みが期待される。
そうすることで、［
新たな／増やされた
］用法は，当の欠陥が原因かもしれない害を増やさないようになる。
◎
Do not extend a platform feature that has known defects, without considering how to address those defects. It is not necessary to completely fix existing problems, but some attempt to address flaws is expected when extending a feature with known issues. This way, new or increased usage does not result in increasing the harm that the defect might cause.
</p>

<p>
~web~platformを成す各部は、
独立に発展する。
ある種の~web技術に今在る課題は、
後続な~~版において修正され得る。
これらの課題を重ねて持ち込むと、
修正するのは，さらに困難になる。
この原則を固守することで、
~platformの品質は，時を経るに伴い総合的に改善されるようになる。
◎
Parts of the web platform evolve independently. Issues that are present with a certain web technology now may be fixed in a subsequent iteration. Duplicating these issues makes fixing them more difficult. By adhering to this principle we can make sure overall platform quality improves over time.
</p>

		</section>
		<section id="data-minimization">
<h3 title="Minimize user data">1.10. 利用者~dataを最小~化すること</h3>

<p>
特能は、［
その利用者の目標を遂げるために必要yな最小な量の~data
］で働くように設計すること。
◎
Design features to work with the minimum amount of data necessary to carry out their users' goals.
</p>

<p>
`~dataの最小~化＠~PRIVACY-PRINCIPLES#data-minimization$は、
~dataが不適切に［
開示される／誤って利用される
］~riskを制限する。
◎
Data minimization limits the risks of data being inappropriately disclosed or misused.
</p>

<p>
~Web~APIは、
~siteにとって，［
少ない量の~data
— あるいは，より［
細やかな／特定な
］【言い換えれば、当の~API用に最適化された】~data —
を［
要請する／収集する／伝送する
］（順不同）
］方が［
より［
汎用な／~bulkな
］~dataで作業する
］よりも容易になるように設計すること。
~APIは、
~siteへ通信される~data
— 特に，`個人-~data＠~PRIVACY-PRINCIPLES#dfn-data$ —
に対する［
細やかさ, 利用者-制御
］も供するベキである。
追加的な機能性に追加的な~dataが要求されるときは、［
当の~APIを`利用者の意図~用に設計して＠#user-intent$，
必要yなときは`利用者が良い裁定を為すよう助ける＠#user-decisions$
］ことで可能化できる。
◎
Design Web APIs to make it easier for sites to request, collect, and/or transmit a small amount of data, or more granular or specific data, than it is to work with more generic or bulk data. APIs should also provide granularity and user controls, in particular over personal data, that is communicated to sites. When additional functionality requires additional data, APIs can enable this if they design for user intent and help users make good decisions when necessary.
</p>

<div class="example">
<p>
`~font列挙~API^citeは，`一度は提案された＠#font-enumeration$が、
その利用事例は，公開される利用者~dataとの~tradeoffを正当化するものではなかった。
代わりに，［
利用者が実際に選定した~fontに限り公開される
］ようにする代替な解決策が提案された。
◎
A Font Enumeration API API was once proposed, but the tradeoff of user data exposed was not justified by the use cases. Instead, an alternative solution was proposed, which only exposed the font the user actually selected.
</p>
</div>

		</section>
	</section>
	<section id="api-across-languages">
<h2 title="API Design Across Languages">2. 言語たちにまたがる~API設計</h2>

		<section id="simplicity">
<h3 title="Prefer simple solutions">2.1. 単純な解決策を選好すること</h3>

<p>
取組もうと意図する`利用者の必要性＠#priority-of-constituencies$に対し，
単純な解決策を探す努力を怠らないこと。
◎
Look hard for simple solutions to the user needs you intend to address.
</p>

<p>
一般に、
複階的な解決策より単純な解決策の方が良い
— それを見出す方が難しいこともあろうが。
特能は単純な方が
⇒＃
~UAにとって実装して~testするのは容易になる／
相互運用可能になる見込みが高い／
作者が理解するのは容易になる
◎
Simple solutions are generally better than complex solutions, although they may be harder to find. Simpler features are easier for user agents to implement and test, more likely to be interoperable, and easier for authors to understand.＼
</p>

<p>
とりわけ、
当の特能を［
最も共通な利用事例を容易に成遂げる
］よう設計することが重要である。
◎
It is especially important to design your feature so that the most common use cases are easy to accomplish.
</p>

<p>
`利用者の必要性＠#priority-of-constituencies$をきちんと定義すること
— そうすれば、
視野が次第に逸れていくこと（ `scope creep^en ）は避けれるようになる。
また、
当の~APIが，すべての利用者の必要性を実際に満たすようにすること。
もちろん［
複階的／稀
］な利用事例も解くに価するが、
それらの解決策は利用するのが複雑なこともある。
`Alan Kay^en 氏が言ったとおり，
“`simple things should be simple, complex things should be possible^en”
【 “単純なものは単純にしつつ，複階的なものもアリになるべきである” 】。
◎
Make sure that your user needs are well-defined. This allows you to avoid scope creep, and make sure that your API does actually meet the needs of all users. Of course, complex or rare use cases are also worth solving, though their solutions may be more complicated to use. As Alan Kay said, "simple things should be simple, complex things should be possible."
</p>

<p>
共通な事例は単純なことが多いが、
共通度と複階度は，常に相関するとは限らないことに注意。
◎
Do note however that while common cases are often simple, commonality and complexity are not always correlated.
</p>

<div class="example">
~XSS攻撃を防止するよう~HTMLを無毒化することは、
複階的な処理nであり，広範な~securityの知識が要求されるが、
`無毒化器~API＠~HTMLsanitizer$cite
は，この共通的な利用事例~用の近道を供する。
それはまた、
より環境設定を伴いつつ，より単純な型の~filter法も許可する。
◎
Sanitizing HTML to prevent XSS attacks is a complex process that requires extensive security knowledge, however the Sanitizer API provides a shortcut for this common use case. It also permits simpler types of filtering, but with more configuration.
</div>

<p>
次も見よ
⇒
`LEAST-POWER$r
◎
See also:
• [LEAST-POWER]
</p>

		</section>
		<section id="high-level-low-level">
<h3 title="Consider tradeoffs between high level and low level APIs">2.2. 高~levelな~APIと低~levelな~APIの~tradeoffを考慮すること</h3>

<p>
高~levelな~APIは、
`利用者に利する＠#priority-of-constituencies$ために
— ［
~accessibility／~privacy／利便性
］を確保するためなど —
様々な仕方で介入する能を より多く~UAに許容する。
◎
High-level APIs allow user agents more ability to intervene in various ways on behalf of the user, such as to ensure accessibility, privacy, or usability.
</p>

<div class="example" id="font-enumeration">
~font~picker（高~levelな~API）は、
`~font列挙~API＠https://wicg.github.io/local-font-access/$cite（低~levelな~API）よりも，
`~TAGにより推奨された＠https://github.com/w3ctag/design-reviews/issues/399$
— それは、［
利用者~privacyを保全しながら，大部分の利用事例に取組む
］こと加え，［
`~font列挙~API^cite に付随する，一般的な指紋収集の懸念
］は無いので。
~nativeな~font~pickerには、
組込みの~accessibilityもついて来るので，末端-利用者にとっての一貫性を供する。
◎
A font picker (high level API) was recommended by the TAG over a Font Enumeration API (low level API) as it addresses the bulk of use cases, while preserving user privacy, as it is free from the fingerprinting concerns that accompany a general Font Enumeration API. A native font picker also comes with accessibility built-in, and provides consistency for end users.
</div>

<p>
低~levelな~APIには、［
高~levelな~APIが，時を経て得られた用法~patternから組織的に形作れる
］よう，作者に実験n用の部屋を与えるゆとりがある。
それはまた、［
より高~levelな~APIでは必要十分でない，目の前の利用事例
］のための逃げ道を供する。
◎
Low-level APIs afford authors room for experimentation so that high level APIs can organically emerge from usage patterns over time. They also provide an escape hatch when the higher-level API is not adequate for the use case at hand.
</p>

<p>
より低~levelな構築部品は、
~Web~APIとして公開できないこともある。
アリな理由として，［
利用者の~securityと~privacyを保全する／
~Web~APIを特定の~hardware実装に束ねることを避ける
］ことが挙げられる。
しかしながら，高~levelな~APIは、［
アリなときは，より低~levelな~APIに基づく構築部品の用語
］で設計されるべきである。
これは、［
高~levelな~APIは，どうなる必要があるか
］に関する裁定を手引きするものになろう。
◎
Lower level building blocks cannot always be exposed as Web APIs. A few possible reasons for this are to preserve the user’s security and privacy, or to avoid tying Web APIs to specific hardware implementations. However, high level APIs should be designed in terms of building blocks over lower level APIs whenever possible. This may guide decisions on how high level the API needs to be.
</p>

<p>
きちんと層~化された解決策は、［
その力に比して，利用の難易度がひどく上がることはない
］ことを確保するべきである
— 利用事例の複階性が少し増すだけで~codeの複階性が大きく増えないよう。
◎
A well-layered solution should ensure continuity of the ease-of-use vs power tradeoff curve and avoid sharp cliffs where a small amount of incremental use case complexity results in a large increase of code complexity.
</p>

		</section>
		<section id="name-thoughtfully">
<h3 title="Name things thoughtfully">2.3. よく考して命名すること</h3>

<p>
【！Name APIs with care.】
~APIをきちんと命名しておけば、
作者が それを正しく利用するのは，ずっと容易になる。
◎
Name APIs with care. Naming APIs well makes it much easier for authors to use them correctly.
</p>

<p>
命名に特有な，より詳細な指導は、
`§ 命名~原則＠#naming-is-hard$を見よ。
◎
See the more detailed Naming principles section for specific guidance on naming.
</p>

		</section>
		<section id="consistency">
<h3 title="Be consistent">2.4. 他所と一貫すること</h3>

<p>
~APIの設計における先例を考慮して，それと一貫するよう努めることは、
良い実施である。
◎
It is good practice to consider precedent in the design of your API and to try to be consistent with it.
</p>

<p>
既存の先例の利便性が拙い場合、
~APIの［
人間工学, 一貫性
］両面は対立することが多い。
一部の事例では，一貫性を破ってでも利便性を改善することがイミを成すが、
その改善は，そうすることを有意に正当化するものであるべきである。
◎
There is often a tension between API ergonomics and consistency, when existing precedent is of poor usability. In some cases it makes sense to break consistency to improve usability, but the improvement should be very significant to justify this.
</p>

<p>
~web~platformは、
時を経て次第に発展してきたので，
相反な複数の競合している先例があることも多い。
どの先例に従うかは、
次を織り込む下で比較検討できる：
◎
Since the web platform has gradually evolved over time, there are often multiple conflicting precedents which are mutually exclusive. You can weigh which precedent to follow by taking into account＼
</p>
<ul>
	<li>
普及度（他がすべて等しいなら，より普及な先例に従う）
◎
prevalence (all else being equal, follow the more popular precedent),＼
</li>
	<li>
人間工学（他がすべて等しいなら，より利用-可能な先例に従う）
◎
API ergonomics (all else being equal, follow the more usable precedent),＼
</li>
	<li>
~APIの齢（他がすべて等しいなら，より新たな先例に従う）
◎
and API age (all else being equal, follow the newer precedent).
</li>
</ul>

<p>
［
`内部~一貫性^em,
`外部~一貫性^em
］も対立することが多い。
前者は，当の~systemの他所すべてとの一貫性であり、
後者は，外の世界の他所すべてとの一貫性である。
それは、
~web~platformにおいては，次に挙げる 3 つの層で顕在化されよう：
◎
There is often a tension between internal and external consistency. Internal consistency is consistency with the rest of the system, whereas external consistency is consistency with the rest of the world. In the web platform, that might materialize in three layers:＼
</p>
<ul>
	<li>
当の~APIが所属する技術（例：~CSS）との一貫性
◎
consistency within the technology the API belongs to (e.g. CSS),＼
</li>
	<li>
~web~platformの他所すべてとの一貫性
◎
consistency with the rest of the web platform,＼
</li>
	<li>
一部の事例
— 当の~APIが［
特定0の特化された外側の領分
］に関係する事例 —
では、
外部な先例との一貫性
◎
and in some cases external precedent, when the API relates to a particular specialized outside domain.＼
</li>
</ul>

<p>
これらの事例では、［
大多数の利用者は，どれに該当するか
］を考慮することが有用になる。
ほとんどの~APIは、
それが ある技術の下で定義されるならば，~target利用者は その技術に馴染みな者たちなので、
その技術との一貫性を支持する方が無難になる。
◎
In those cases, it is useful to consider what the majority of users will be. Since for most APIs the target user is someone who is familiar with the technology they are defined in, err on the side of favoring consistency with that.
</p>

<div class="example">
例として，`~Lab色＠~CSSCOLOR#funcdef-lab$がある。
それは L 成分~用には百分率（ 0% 〜 100% ）を利用する方が，~CSSの他所すべてと一貫するが、
単位が無い数（ 0 〜 100 ）を利用する方が，色彩科学の他所すべてと一貫する。
論争は幾度となくあったが、
百分率
— すなわち~CSSとの一貫性 —
を支持する方に解決された。
◎
One example is CIE L*a*b* colors: It would be more consistent with the rest of CSS to use percentages for L (0%-100%), but more consistent with the rest of Color Science to use a unitless number (0-100). There was a lot of heated debate, which resolved in favor of percentages, i.e. consistency within CSS.
</div>

<p>
別々な節として，
`§ 一貫するよう命名すること＠#naming-consistency$もある。
◎
There is also a separate section on naming consistency.
</p>

		</section>
		<section id="specs-include-guidance">
<h3 title="Follow guidance from feature specifications">2.5. 特能~仕様からの指導に従うこと</h3>

<p>
ある特能を利用しているときは、
その特能~用の仕様による指導に従うこと。
◎
When using a feature, follow guidance in the specification for that feature.
</p>

<p>
他の仕様により利用されることになる特能~用の仕様は、
当の特能を利用するための指導を含めるベキである。
これは、
当の特能が~platform全体を通して正しくかつ一貫するよう利用されることを確保する。
◎
Specifications for features that will be used by other specifications should include guidance for using those features. This ensures that the feature is used correctly and consistently throughout the platform.
</p>

<p>
そのような指導を成す例として，次が挙げられる
⇒＃
`ENCODING$r `§ 他の標準~用の~hook＠~ENCODING#specification-hooks$,
`FETCH$r `§ 他の標準における~fetchの利用-法＠~FETCH#fetch-elsewhere$,
`RFC9205$r — とりわけ `§ ~HTTP~headerの指定-法＠~HTTPbcp#headers$,
`他の~HTTP~RFC群＠https://datatracker.ietf.org/doc/search?name=HTTP&amp;sort=&amp;rfcs=on&amp;by=group&amp;group=httpbis$,
`~HTTP~WGによる編集上の~style手引き＠https://httpwg.org/admin/editors/style-guide$,
`HIGHRES-TIME$r `§ 仕様~策定者~用の~tool＠~HRTIME#sec-tools$,
`URL$r `§ 他の仕様における~URL~API＠~URL1#url-apis-elsewhere$,
◎
An incomplete list of such guidance follows:
• Encoding
• Fetch
• Building Protocols with HTTP, especially on defining header fields, other HTTP RFCs, and the HTTP Working Group style guide
• Time
• URLs
</p>

<p>
そのような仕様を利用しているときは、
関連な~communityに諮ること。
そうすることで、
新たな用法について当の~communityに伝わり，
利用している仕様, 利用された仕様どちらにも改善~用の機会が与えられる。
◎
Consult with the relevant community when using their specification. This informs that community about new usage and creates opportunities for improvements to both the using and used specifications.
</p>

		</section>
		<section id="feature-detect">
<h3 title="New features should be detectable">2.6. 新たな特能は検出-可能になるべきである</h3>

<p>
当の特能が可用でないときでも，~web内容が それを上品に取扱えるよう、
可用かどうかを作者が~program的に検出する仕方を供すること。
◎
Provide a way for authors to programmatically detect whether your feature is available, so that web content may gracefully handle the feature not being present.
</p>

<p>
既存の特能は、
いくつかの理由から，~pageにて可用でないこともある。
共通的な理由として、
次が挙げられる
⇒＃
まだ実装されていない／
`~secureな文脈＠#secure-context$内でしか可用でない
◎
An existing feature may not be available on a page for a number of reasons. Two of the more common reasons are because it hasn’t been implemented yet, or because it’s only available in secure contexts.
</p>

<p>
作者にとって［
各~局面を取扱うために異なる~codeを書する必要
］は、
生じるべきでない。
この仕方により、
作者が一つの局面しか［
知らない／~careしない
］場合でも，~codeは それらすべてを取扱うことになる。
◎
Authors shouldn’t need to write different code to handle each scenario. That way, even if an author only knows or cares about one scenario, the code will handle all of them.
</p>

<p class="note">注記：
ある特能が［
可用ではあるが、
要求される装置が無いため，その利用は実現可能でない
］ときは、
特能が可用であることを公開することに加え，
装置は可用でないことも検出する別々な仕方もある方が良い。
これは、［
装置が可用でないとき, 特能が可用でないとき
］の取扱いを違えることを作者に許容する
— 例えば、
装置を［
前者のときは接続する／後者のときは可能化する
］よう利用者に示唆するなど。
◎
When a feature is available but isn’t feasible to use because a required device isn’t present, it’s better to expose that the feature is available and have a separate way to detect that the device isn’t. This allows authors to handle a device not being available differently from the feature not being available, for example by suggesting the user connect or enable the device.
</p>

<p>
`§ 装置を［選定する／列挙する］~APIを公開するときの注意点＠#device-enumeration$
を見よ。
◎
See § 9.2 Use care when exposing APIs for selecting or enumerating devices.
</p>

<p>
特能は、
常に，作者が~JSから検出-可能にするべきである。
一部の事例では、
特能は，それが利用される言語で検出-可能になるべきである
（~CSSにおける `supports$at など）。
◎
Authors should always be able to detect a feature from JavaScript, and in some cases the feature should also be detectable in the language where it’s used (such as @supports in CSS).
</p>

<p>
一部の事例では、
特能~検出を許容するのは`適切でないこともある^strong。
特能が検出-可能になるべきかどうかは、
当の特能に対する`利用者の必要性＠#priority-of-constituencies$に基づく
— 特能~検出が可用であること自体が［
利用者の必要／設計~原則
］に抵触する場合、
特能~検出は~supportされるべきでない。
◎
In some cases, it may not be appropriate to allow feature detection. Whether the feature should be detectable or not should be based on the user need for the feature. If there is a user need or design principle which would fail if feature detection were available for the feature, then you should not support feature detection.
</p>

<p>
ある特能が可用か否か検出することは、
当の特能を利用する許可が`利用者に依頼された＠#user-decisions$か否か検出することを含意しない。
一般に、［
当の特能が実装されたかどうか検出する
］ことは［
当の特能の利用について権限付与-済みかどうか決定する
］こととは別々に行える。
一部の事例では、［
当の特能を利用する要請を否認する
］ことを可能化するためには，特能~検出を不能化することが必要yあるかもしれない。
◎
Detecting the availability of a feature does not imply detecting whether the user has been asked to use the feature. Generally, detecting whether the feature is implemented can be done separately from determining whether use of the feature has been authorized. In some cases, it might be necessary to disable feature detection in order to enable denying requests to use the feature.
</p>

<p>
また，ある特能が一般に開発者に公開されない場合、
特能~検出を~supportするのは適切にならない。
例えば，私的~閲覧~modeは、
~web仕様において認識される概念であるが，作者には公開されない。
私的~閲覧~modeに対する特能~検出は、
それ自体が利用者の必要性に反するので，~supportされてはナラナイ。
◎
Also, if a feature is generally not exposed to developers, it is not appropriate to support feature detection. For example, private browsing mode is a concept which is recognised in web specifications, but not exposed to authors. For private browsing mode to support the user’s needs, it must not be feature detected.
</p>

<p>
次も見よ
⇒＃
`§ 私的~閲覧~mode下にあることを露呈しないこと＠#do-not-expose-use-of-private-browsing-mode$／
`§ 支援技術が利用-中にあることを露呈しないこと＠#do-not-expose-use-of-assistive-tech$／
`§ 新たな特能は~secureな文脈に制限することを考慮すること＠#secure-context$／
`§ 利用者が良い裁定を為すよう助けること＠#user-decisions$
◎
See also:
• § 2.9 Don’t reveal that private browsing mode is engaged
• § 2.11 Don’t reveal that assistive technologies are being used
• § 2.8 Consider limiting new features to secure contexts
• § 1.4.1 Help users make good decisions
</p>

		</section>
		<section id="text-formats">
<h3 title="Design textual formats for humans">2.7. ~textな形式はヒトのために設計すること</h3>

<p>
~textな形式は、
人々が容易に生産でき, 消費できるよう，設計すること。
~textな形式は、
`透明~性＠~ETHICAL-PRINCIPLES#transparent$も改善する。
◎
Design textual formats that can be easily produced and consumed by people. Textual formats also improve transparency.
</p>

<p>
密集~度よりも可読性を支持すること。
~file~sizeは、
~tool群により最適化し得ることに加え，その優先度は時間~越しに低下する傾向にある。
~file~sizeの優先度が他より有意に高いときは、
~textな形式は，たぶん適切でない。
◎
Favor readability over compactness. File size can be optimized by tooling, and tends to become a lower priority over time. When file size is a significantly higher priority, perhaps a textual format is not appropriate.
</p>

<div class="example">
<p>
~SVGの~path構文は、
密集になるよう設計された
— 一文字の~commandと~~後続する［
~labelを伴わない，一連の座標
］からなるよう。
~file~sizeは，その頃は首な懸念であったが、
~size効率の重要度は時間~越しに減衰した一方で，
可読性の~costは同じであり続けた。
◎
SVG path syntax was designed to be compact, with single-letter commands and unlabeled series of coordinates after them. At the time, file size was a primary concern, but while the importance of size efficiency has declined over time, the cost to human readability has remained the same.
</p>
</div>

<p>
~textな形式で呈示されるなら、
人々は，~text~editorを利用して内容を容易に［
生産-／改変-
］可能になるはずである。
人々は、
~textを編集する際に様々な~errorを導入することになるが，
それらの~errorを識別して修正することにも苦労し得る。
◎
People who are presented with a textual format should be able to use a text editor to easily produce or modify content. People who edit text will introduce a range of errors, but could struggle to identify and fix those errors.
</p>

<p>
人々は、
各自の編集sがどう処理されるかに関して，いくぶんの柔軟性を期待する。
構文上の柔軟性を
— 空白, 引用符, 区切子などの入れ方に関して —
`明瞭に定義すること＠#avoid-ambiguity$により，［
内容が編集し易くなること,
【柔軟性の下で等価なものどうしで】一貫した結果を生産すること
］どちらも確保され得る。
◎
People expect some amount of flexibility in terms of how their edits are processed. Clearly defining syntactic flexibility—​such as in whitespace, quoting, or delimiters—​could ensure that content is both easy to edit and produces consistent results.
</p>

<div class="example">
<p>
~JSON形式は、
柔軟にも見える形式を成す例であるが，
これら基本的な利便性の多くを欠如している。
~JSONにおいては、
~comment用の能力は無く,
~objや配列においては末尾の~commaを~~省く必要があり,
~obj~keyにおける引用符は義務的である。
その結果、
~JSONにおいては，手動な編集sによる構文-~errorが生じ易くなっている。
◎
The JSON format is an example of a format that appears to be flexible, but it lacks many of these basic usability amenities. In JSON there is: no commenting capability, objects and arrays cannot have trailing commas, and quotes are mandatory for object keys. This makes JSON prone to syntactic errors as a result of manual edits.
</p>
</div>

<p>
ある形式を成す［
構文~errorにより影響される視野
］を~~狭めることは、
堅牢~性もヒトにとっての利便性も改善し得る。
これには、
各~仕様が，その処理と~errorの取扱いを［
すべての入力に対する最終的な結果が一貫するよう，全部的に定義する
］ことが要求される。
◎
Containing the scope of a format that is affected by a syntax error could improve robustness and human usability. This requires that specifications fully define processing and error handling so that all inputs result in consistent outcomes.
</p>

<div class="example">
<p>
~CSS~propにおける誤記は、
当の~propに限り無視させる。
~propにおける~errorにより，~style規則~全体が無効になることは、
稀にしかない。
◎
Typos in CSS properties only cause that property to be ignored. Errors in properties rarely cause an entire rule to be lost.
</p>
</div>

<p>
当の形式が機械にしか利用されないものと意図される場合、
~binary形式の方が効率的になる見込みが高い
— 人々が内容を直に［
著作する／編集する
］ことは忌避されることに加えて。
◎
If your format is intended to be used only by machines, a binary format is likely to be more efficient, in addition to discouraging people from authoring or editing content directly.
</p>

		</section>
		<section id="secure-context">
<h3 title="Consider limiting new features to secure contexts">2.8. 新たな特能は~secureな文脈に制限することを考慮すること</h3>

<p>
当の特能が［
~secureな文脈にしか無い［
認証／完全性／機密性
］を伴わない限り，利用者に~riskを突きつける
］ことになる場合、
常に~secureな文脈に制限すること。
◎
Always limit your feature to secure contexts if it would pose a risk to the user without the authentication, integrity, or confidentiality that’s present only in secure contexts.
</p>

<div class="example">
~secureな文脈に制限されるべき特能を成す例として、
`GEOLOCATION$r（ “~~地理所在” ）がある
— 利用者の所在を~secureでない仕方で伝送することには、
利用者の~privacyに対する~riskがあるので。
◎
One example of a feature that should be limited to secure contexts is Geolocation, since it would be a risk to users' privacy to transmit their location in an insecure way.
</div>

<p>
他の特能に対しては、
~~過去および~~現在の~TAG~memberたちは，一般的な助言について総意には達しなかった：
◎
For other features, TAG members past and present haven’t reached consensus on general advice.＼
</p>
<ul>
	<li>
一部の者は、
新たな特能（既存の特能に対する追加~以外の特能）は，［
すべて，~secureな文脈に制限されるべきである
］と予見する。
これは，~HTTPSの利用を促すことになり、
一般に，利用者にとって より~secureになる助けになる。
◎
Some believe that all new features (other than features which are additions to existing features) should be limited to secure contexts. This would help encourage the use of HTTPS, helping users be more secure in general.
</li>
	<li>
他の者は、
特能は，［［
~security／~privacy
］に既知な影響iがある場合に限り，~secureな文脈に制限されるべきである
］と予見する。
これは、［［
利用者の［
~security／~privacy
］に影響iしない新たな特能
］の利点を採るような~web~page
］を作成するときの敷居を低くする。
◎
Others believe that features should only be limited to secure contexts if they have a known security or privacy impact. This lowers the barrier to entry for creating web pages that take advantage of new features which don’t impact user security or privacy.
</li>
</ul>

<div class="note">
<p>注記：
仕様~策定者は、
`WEBIDL$r にて定義される ほとんどの特能を~secureな文脈に制限できる
— ［
`~interface$／`名前空間$／それらの各~member（~methodや属性など）
］に `SecureContext$xA 拡張d属性を利用することにより。
◎
Specification authors can limit most features defined in Web IDL [WEBIDL], to secure contexts by using the [SecureContext] extended attribute on interfaces, namespaces, or their members (such as methods and attributes).
</p>

<p>
しかしながら，一部の~APIにおいては、
~secureな文脈への制限は，当の仕様~内の規範的な注釈文だけで定義されるべきである
（例： ~eventの配送-法
【当の~APIにより誘発される，ある種の~eventは、~secureな文脈に限り発火するなど（~eventを発火する仕組み~自体は、一律に~secureな文脈に制限し得ないので）】
）。
この事例に該当する場合、
将来の~API開発者にとって この~processを もっと容易にするため，
`SecureContext$xA に類似な仕組みを追加する余地もあるかどうかを考慮すること。
◎
However, for some types of API (e.g., dispatching an event), limitation to secure contexts should just be defined in normative prose in the specification. If this is the case, consider whether there might be scope for adding a similar mechanism to [SecureContext] to make this process easier for future API developers.
</p>
</div>

<div class="note">
<p>注記：
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$
にて述べたとおり，［
ある特能が可用かどうかを~program的に検出する仕方
］を供するべきである
— 当の文脈が~secureでない故に当の特能が可用でない事例も含めて。
◎
As described in § 2.6 New features should be detectable, you should provide a way to programmatically detect whether a feature is available, including cases where the feature is unavailable because the context isn’t secure.
</p>

<p>
しかしながら、［
何らかの理由で、
特能が無いとき，~codeがそれを上品に取扱う仕方が無い
］場合、
当の特能を~secureな文脈に制限すると，［
~secureな文脈, ~secureでない文脈
］どちらにも利用され得る~code（~libraryなど）にとって問題の原因になるかもしれない。
◎
However, if, for some reason there is no way for code to gracefully handle the feature not being present, limiting the feature to secure contexts might cause problems for code (such as libraries) that may be used in either secure or non-secure contexts.
</p>
</div>

		</section>
		<section id="do-not-expose-use-of-private-browsing-mode">
<h3 title="Don’t reveal that private browsing mode is engaged">2.9. 私的~閲覧~mode下にあることを露呈しないこと</h3>

<p>
当の特能は、
私的~閲覧~modeを検出する仕方を作者に与えないこと。
◎
Make sure that your feature doesn’t give authors a way to detect private browsing mode.
</p>

<p>
一部の人々は、
`私的~閲覧~mode＠https://www.w3.org/2001/tag/doc/private-browsing-modes/$を利用して，自前の個人的な安全性を保護する。
このことから，誰かが私的~閲覧~modeを利用している事実は、
その者についての
`敏感な情報＠~SECQ#sensitive-data$になり得る。
この情報は、
その者に力を持つ他者
（雇用者, 親権者, ~partner, `国家権力＠~ETHICAL-PRINCIPLES#expression$（ `state actor^en ）
など）
が制御している~web~siteに露呈された場合には，
`人々を害する＠~ETHICAL-PRINCIPLES#noharm$こともある。
◎
Some people use private browsing mode to protect their own personal safety. Because of this, the fact that someone is using private browsing mode may be sensitive information about them. This information may harm people if it is revealed to a web site controlled by others who have power over them (such as employers, parents, partners, or state actors).
</p>

<p>
そのような危険性がある下では、
~web~siteは，私的~閲覧~mode下にあることを検出-可能になるべきでない。
◎
Given such dangers, websites should not be able to detect that private browsing mode is engaged.
</p>

<div class="example">
`IndexedDB-3$r を~supportする~UAは、
私的~閲覧~modeにおいて，それを不能化するべきでない
— そうすると、
私的~閲覧~mode下にあることを露呈することになるので。
◎
User Agents which support IndexedDB should not disable it in private browsing mode, because that would reveal that private browsing mode is engaged
</div>

<div class="example">
<p>
`支払い要請~API＠~PAYMENT-REQUEST$cite
（ `Payment Request API^en ）
の
`show()＠~PAYMENT-REQUEST#dom-paymentrequest-show$c
~methodは、
~callされたとき，次を~UAに許容する
⇒
<q cite="~PAYMENT-REQUEST#show-method">［
利用者が即時に`支払い要請を中止した＠~PAYMENT-REQUEST#dfn-user-aborts-the-payment-request$
］かのように動作する
</q>
◎
The Payment Request API’s show() method, when called, allows User Agents to act as if the user had immediately aborted the payment request.
</p>

<p>
これは，私的~閲覧~modeにおいては、
~UAがその~mode下にあることを露呈することなく，
支払い要請を自動的に中止することを可能化する
（したがって、［
出荷先~addressや請求先~address
］など，利用者の`敏感な情報＠~SECQ#sensitive-data$を保護する）。
◎
This enables User Agents to automatically abort payment requests in private browsing mode (thus protecting sensitive information such as the user’s shipping or billing address) without revealing that private browsing mode is engaged.
</p>
</div>

<p>
次も見よ
⇒＃
`§ ~webは、~secureであり，人々の~privacyを尊重する＠~ETHICAL-PRINCIPLES#privacy$／
`§ 当の特能は、下層の~platformについての情報を生成元に公開するか？＠~SECQ#underlying-platform-data$／
`§ 私的~閲覧~modeにおいて，~APIがどう挙動するべきか考慮すること＠#private-browsing-mode$
◎
See also:
• Security and privacy are essential
• What data does this specification expose to an origin?
• § 2.10 Consider how your API should behave in private browsing mode
</p>

		</section>
		<section id="private-browsing-mode">
<h3 title="Consider how your API should behave in private browsing mode">2.10. 私的~閲覧~modeにおいて，~APIがどう挙動するべきか考慮すること</h3>

<p>
必要yなら、
当の~APIの挙動は，私的~閲覧~modeにおいて どう異なるべきかを指定すること。
◎
If necessary, specify how your API should behave differently in private browsing mode.
</p>

<p>
例えば，当の~APIが［
一人の利用者による［
私的~閲覧~mode内での活動, その外での活動
］を相関することを誰かに許容することになる情報
］を露呈することになる場合、
アリな`軽減策＠~SECQ#mitigations$を考慮すること
— 次に挙げるものなど：
◎
For example, if your API would reveal information that would allow someone to correlate a single user’s activity both in and out of private browsing mode, consider possible mitigations such as＼
</p>
<ul>
	<li>
【相関を妨げるような】~noiseを導入する。
◎
introducing noise,＼
</li>
	<li>
必要yなら、
この追跡について，`利用者が良い裁定を為すよう助ける＠#user-decisions$こと。
◎
or helping users make good decisions about this tracking, if necessary.
</li>
</ul>

<p>
私的~閲覧~modeは、［
利用者による私的~閲覧の形跡を利用者の機器に残さない
］ように~webを閲覧することを，利用者に可能化する。
したがって，
~client側~storageを供する~APIは、［
私的~閲覧~mode下にある間に格納された~data
］を その~modeから離れた後にも持続するべきでない。
これは、［
検出-可能な~APIにおける いかなる相違も，当の~siteに露呈しない
］ように行えるし，行うべきである。
◎
Private browsing modes enable users to browse the web without leaving any trace of their private browsing on their device. Therefore, APIs which provide client-side storage should not persist data stored while private browsing mode is engaged after it’s disengaged. This can and should be done without revealing any detectable API differences to the site.
</p>

<div class="example">
<p>
`localStorage＠~WEBSTORAGE#dom-localstorage$c
を~supportする~UAは、
私的~閲覧~mode下にある間に，
~storage区画に為された変更を持続するべきでない。
◎
User Agents which support localStorage should not persist storage area changes made while private browsing mode is engaged.
</p>

<p>
~UAに 同じ~site用の 2 つの閲覧~session
— 私的~閲覧~mode内の~session, もう一方は そうでない~session —
が同時にある場合、
一方の~sessionにおいて~storage区画に為される変更は，他方の~sessionに露呈されるべきでない
（ `storage＠~HTMLindex#event-storage$et ~eventは、
他方の~sessionの `Window$I ~objに向けて発火されるべきでない）。
◎
If the User Agent has two simultaneous sessions with a site, one in private browsing mode and one not, storage area changes made in the private browsing mode session should not be revealed to the other browsing session, and vice versa. (The storage event should not be fired at the other session’s window object.)
</p>
</div>

<p>
次も見よ
⇒＃
`§ 私的~閲覧~mode下にあることを露呈しないこと＠#do-not-expose-use-of-private-browsing-mode$／
`§ 当の特能は、複数の閲覧~sessionにわたって持続する新たな状態を生成元~用に導入するか？＠~SECQ#persistent-origin-specific-state$／
`§ 当の特能は、~browserの私的~閲覧~modeの文脈においてどう働くか？＠~SECQ#private-browsing$
◎
See also:
• § 2.9 Don’t reveal that private browsing mode is engaged
• Does this specification introduce new state for an origin that persists across browsing sessions?
• Security and privacy self review: Private Browsing
</p>

		</section>
		<section id="do-not-expose-use-of-assistive-tech">
<h3 title="Don’t reveal that assistive technologies are being used">2.11. 支援技術が利用-中にあることを露呈しないこと</h3>

<p>
当の~APIは、［
利用者が支援技術を利用していることを検出する仕方
］を作者に供さないこと。
◎
Make sure that your API doesn’t provide a way for authors to detect that a user is using assistive technology.
</p>

<p>
`~web~platformは障害を伴う人々からも~access可能にしなければナラナイ＠~ETHICAL-PRINCIPLES#allpeople$。
ある~siteが利用者が支援技術を利用していることを検出できた場合、
その~siteは，自身が供する~serviceへの利用者による~accessを［
否認-／制約-
］し得ることになる。
◎
The web platform must be accessible to people with disabilities. If a site can detect that a user is using an assistive technology, that site can deny or restrict the user’s access to the services it provides.
</p>

<p>
支援技術を用立てる人々は、
`社会の脆弱な~member＠~ETHICAL-PRINCIPLES#noharm$
であることが多い。
彼らによる支援技術の利用は、
彼らについての`敏感な情報＠~SECQ#sensitive-data$である。
ある~APIが，この情報への~accessを供する場合、
この敏感な情報は，彼らを害そうと望むかもしれない他者
（`国家権力＠~ETHICAL-PRINCIPLES#expression$も含む）
に露呈され得る。
◎
People who make use of assistive technologies are often vulnerable members of society; their use of assistive technologies is sensitive information about them. If an API provides access to this information, this sensitive information may be revealed to others (including state actors) who may wish them harm.
</p>

<p>
ときには、
人々は［
支援技術の利用者~用に利用者~体験を改善するよう目指す特能
］を提案するが，それは［
副作用として利用者の支援技術の利用を露呈する
］ことになろう。
これらには，きちんとした意図nがあるが、
`§ ~web~pageは安全に訪問できるべきである＠#safe-to-browse$
に違反するので，代替な解決策を見出さなければナラナイ。
◎
Sometimes people propose features which aim to improve the user experience for users of assistive technology, but which would reveal the user’s use of assistive technology as a side effect. While these are well intentioned, they violate § 1.2 It should be safe to visit a web page, so alternative solutions must be found.
</p>

<div class="example">
<p>
`~accessibility~obj~model＠https://wicg.github.io/aom/$cite（略称 ~AOM）は、［
`支援技術の利用が露呈される＠https://github.com/WICG/aom/issues/81$とき発火される~event
］たちが成す集合を定義するために利用されていた。
◎
The Accessibility Object Model (AOM) used to define a set of events which, when fired, revealed the use of assistive technology.
</p>

<p>
その後，~AOMは、
これらの~eventを除去して，［
支援技術の利用を露呈しない合成な~DOM~event
］で`それらを置換した＠https://github.com/WICG/aom/blob/gh-pages/explainer.md#user-action-events-from-assistive-technology$。
◎
AOM has since removed these events and replaced them with synthetic DOM events which don’t reveal the use of assistive technology.
</p>
</div>

<p>
次も見よ
⇒＃
`~Web技術~accessibility指針＠https://w3c.github.io/apa/fast/$cite
`§ ~webは、~secureであり，人々の~privacyを尊重する＠~ETHICAL-PRINCIPLES#privacy$／
`§ 当の特能は、下層の~platformについての情報を生成元に公開するか？＠~SECQ#underlying-platform-data$
◎
See also:
• Web Technology Accessibility Guidelines
• Security and privacy are essential
• What data does this specification expose to an origin?
</p>

		</section>
		<section id="require-user-activation">
<h3 title="Require user activation for powerful APIs">2.12. 強力な~APIには、利用者-作動化を要求すること</h3>

<p>
一部の強力~APIは、
次に挙げる いずれかを行い得る：
◎
Some powerful APIs can＼
</p>
<ul>
	<li>
押付けな~UIを生産する
（例：音声を自動-再生する）
◎
produce intrusive UI (eg. auto-playing audio),＼
</li>
	<li>
利用者~dataを【~web~pageに】公開する
（例：~clipboardとヤリトリする）
◎
expose user data (eg. interacting with the clipboard),＼
</li>
	<li>
利用者に対する明白な指示子を伴わずに背景~活動を遂行する
（例：局所~storageへ~accessする）
◎
perform a background activity without an obvious indicator to the user (eg. accessing local storage),＼
</li>
	<li>
`信用-済み~UI＠#trusted-ui$とヤリトリするよう利用者に~promptする
（例：許可~prompt, 機器~hardware特能）
◎
or prompt the user to interact with trusted UI (eg. permission prompts, device hardware features).＼
</li>
</ul>

<p>
これらの~APIが機能するためには、
利用者の意図nを成す何らかの指示
（`利用者-作動化^strongなど）
を要求するよう設計されるベキである。
これは、
利用者が当の~web~pageに対し意図的にヤリトリしていることを指示する。
◎
These APIs should be designed to require some indication of user intention (such as user activation) in order to function. This indicates that the user is intentionally interacting with the web page in question.
</p>

<p>
利用者-作動化は、
~HTML標準にて，`詳細に定義される＠~HTMLinteraction#tracking-user-activation$。
利用者-作動化が生じる必要があるのは，次のうちどれになるか裁定するときは、
当の~APIによる［
利用者~体験に対する効果，利用者に呈示される~risk
］について考するベキである
⇒＃
合計で一回~限り（`居残な＠~HTMLinteraction#sticky-activation-gated-api$）／
周期的（`一過な＠~HTMLinteraction#transient-activation-gated-api$）／
各~API~callにつき一回（`一過に消費する＠~HTMLinteraction#activation-consuming-api$）
◎
User activation is defined in detail in the HTML standard. You should think about the effect your API has on the user experience, as well as any risks presented to the user, when deciding whether user activation needs to only occur once overall (sticky), periodically (transient) or once per API call (transient consuming).
</p>

<p>
利用者-作動化は、
多くの事例で必要yであるが，
侵害的な挙動から利用者を保護するに`足るとは限らない^emことに注意。
`利用者の意図~用に設計して＠#user-intent$，`利用者が良い裁定を為すよう助ける＠#user-decisions$ことも重要である。
◎
Note that while user activation is in many cases necessary, it is not always sufficient to protect users from invasive behaviours. Designing for user intent and helping users to make good decisions is also important.
</p>

		</section>
		<section id="support-non-fully-active">
<h3 title="Support non-fully active BFCached documents">2.13. 全部的に作動中でない~BF~cacheされた文書を~supportすること</h3>

<p>
アリなら、
当の特能が
~BF~cacheされた【`~BF~cache$に格納された】`全部的に作動中$でない文書において，どう挙動するかを指定すること。
◎
Specify how your feature behaves in non-fully active BFCached (Back/forward cached) documents if possible.
</p>

<p>
当の特能が，次に挙げるいずれかの分類に該当する`何か^strongを行う場合：
◎
If your feature does anything that falls into the following categories:
</p>
<ul>
	<li>
“外側” から文書とヤリトリする
（例：ある文書へ情報を送信する）
◎
Interacts with a document from the "outside" (e.g. sends information to a document)
</li>
	<li>
文書~間での［
ヤリトリ／資源の共有
］をアリにする
（例：~lockを保持する）
◎
Makes cross-document interaction/resource sharing possible (e.g. holding locks)
</li>
	<li>
文書が［
利用者により他所へ~navigateされた／
【利用者が履歴を辿った結果】復旧された
］後に［
`全部的に作動中$でない~BF~cacheされた状態
］に保たれたとき，
当の文書は（破壊される代わりに）~~不正に機能し得る
（例：当の文書~内に保存された状態は、
複数回の~naviにわたらないものと期待されている）
◎
May malfunction when a document is kept in a non-fully active BFCached state (instead of getting destroyed) after the user navigates away from it or gets restored (e.g. expects that a state saved in the document won’t span multiple navigations)
</li>
</ul>

<p>
当の特能が~BF~cacheされた`全部的に作動中$でない文書でどう働くかを［
`~BF~cacheされた文書の~support法＠~BFCACHE$cite
手引きにおける指針
］に従って指定すること。
◎
Specify how your feature works with non-fully active BFCached documents, following the guidelines in the Supporting BFCached Documents guide.
</p>

<p class="note">注記：
文書は、
~BF~cache法に関係しない他の理由で`全部的に作動中$でなくなることもアル
— 当の文書を保持している `iframe$e が切離されたときなど。
この指導は、
`~BF~cache$が孕まれている事例に限られ，
そのような事例には関連しない。
◎
Note: It is possible for a document to become non-fully active for other reasons not related to BFcaching, such as when the iframe holding the document gets detached. This guidance only focuses on the case where BFCache is involved, and not other cases that might cause a document to become non-fully active.
</p>

		</section>
		<section id="third-party-tools">
<h3 title="Prioritize usability over compatibility with third-party tools">2.14. 第三者-主体~toolとの互換性より利便性を優先すること</h3>

<p>
新たな特能を設計するときは、
第三者-主体~tool群との互換性よりも，利便性を首な目標とすること。
◎
Design new features with usability as the primary goal, and compatibility with third-party tooling as a secondary goal.
</p>

<p>
~web~platformは、
幅広い~tool群が成す~ecosystemから，より容易かつ速い開発を手助けする便益を得ている。
今後、［
~web~platform特能の構文が第三者-主体~toolのそれと競合して，非互換化の原因になる
］ことは，幾度となくあろう。
第三者-主体~toolは，新たな~web~platform特能の原型に利用されることが多いので、
このことは，とりわけ共通的にある。
◎
The web platform benefits from a wide ecosystem of tooling to facilitate easier and faster development. A lot of the time, the syntax of an upcoming web platform feature may conflict with that of a third-party tool causing breakage. This is especially common as third-party tools are often used to prototype new web platform features.
</p>

<p>
~web~platform特能は、
一般に，ほとんどの第三者-主体~toolよりずっと長く残る。
なので、
それらに最適な［
構文と機能性
］を与える優先度は高くするべきである。
◎
In general, web platform features last a lot longer than most third-party tools, and thus giving them the optimal syntax and functionality should be of high priority.
</p>

<p>
一部の事例では、
そのような競合は，あまりに多くの~web~siteに問題を導入する結果、
衝突を避けるため，特能の構文を設計し直す必要が生じる。
◎
In some cases, the conflict will introduce problems across a large number of web sites, necessitating the feature’s syntax to be redesigned to avoid clashes.
</p>

<div class="example">
`Array.prototype.contains()^c は、［
何百万もの~web~siteにて利用されていた~library PrototypeJS に在った，
名前は一致するが互換でない~method
］との衝突を避けるため，
`Array.prototype.includes()^c に改称される必要があった。
◎
Array.prototype.contains() had to be renamed to Array.prototype.includes() to avoid clashes with the identically named but incompatible method from PrototypeJS, a library that was in use in millions of websites.
</div>

<p>
しかしながら、
これらの事例は，例外とされるべきである。
◎
However, these cases should be exceptions.
</p>

<p>
新たな構文で第三者-主体~toolを非互換化するかどうか裁定するにあたって考慮する要因は、
非互換化の著しさ, 第三者-主体~toolの普及度合いの他にも，いくつもある。
◎
When deciding whether to break third party tools with new syntax, there are several factors to consider, such as severity of the breakage, popularity of the third party tool, and many more.
</p>

<p>
場合によっては、［
第三者-主体~toolを非互換化するのを避けるために，当の特能の構文が変更された
］とする場合に［
~web~platform特能の利便性は，どう著しく妥協されることになるか
］が，最も重要な要因になる。
類似な利便性を成すいくつかの代替が考慮されている場合、
通例的には，第三者-主体~toolのうち簡便でないものほど優先度を下げることが好ましい。
◎
Possibly the most important factor is how severely would the usability of the web platform feature be compromised if its syntax was changed to avoid breaking the third party tool? If several alternatives of similar usability are being considered, it is usually preferable to prioritize the ones that inconvenience third party tools the least.
</p>

<div class="example">
~CSS~WGが `CSS-GRID-1$r を設計しているとき、
普及な前処理器である Sass を非互換化するのを避けるため，
`格子~筋＠~CSSGRID#grid-track$の命名-法には丸括弧に代えて角括弧が選ばれた。
◎
When the CSS WG was designing CSS Grid Layout, square brackets were chosen instead of parentheses for naming grid tracks to avoid breaking Sass, a popular preprocessor.
</div>

<p>
しかしながら、
第三者-主体~toolを非互換化するのを避けることが，特能の利便性に`有意^emな負な影響iへ至らす場合、
それが受容-可能な~tradeoffになることは稀にしかない
— 生きた~web~siteに有意な非互換化をもたらす場合を除けば。
◎
However, if avoiding breaking the third party tool would lead to a significant negative impact on of the feature’s usability, that is rarely an acceptable tradeoff, unless it causes significant breakage of live websites.
</p>

<p>
言語は、
将来における そのような~dilemmaを抑制するよう，作者が［
将来の~native機能性を非互換化することなく，言語を拡張する
］ために利用できる拡張能のための仕組みも供するべきである。
◎
Languages should also provide mechanisms for extensibility that authors can use to extend the language without breaking future native functionality, to reduce such dilemmas in the future.
</p>

		</section>
		<section id="prefer-composition">
<h3 title="Build complex types by composing simpler types">2.15. 複階的な型は、より単純な型から構成することにより築くこと</h3>

<p>
下位型は、
常に，上位型の代わりとして利用できるよう定義すること。
継承を利用する`~interface$は、［
上位型【！the parent】の~instanceについて言えるあらゆるもの
］が［
常に下位型【！the child】にも適用される場合
］を除いて，避けること。
◎
Define subtypes that can always be used in place of a supertype. Avoid interfaces that use inheritance unless everything that can be said about an instance of the parent always applies to the child as well.
</p>

<p>
継承を伴う下位型は、
上位型の~item用の身代わりになれる型を作成する。
下位型は、
上位型と同じ［
属性, ~method
］たちを供する必要がある。
下位型は、
上位型と一貫した挙動を保守する必要もある。
当の下位型が，ある~itemが働く仕方を変更する場合、
上位型を取扱う何かが適正に働かなくなるかもしれない。
◎
With inheritance, a subtype creates a type of item that can stand in for its supertype. A subtype needs to provide the same attributes and methods as its supertype. The subtype also needs to maintain consistent behavior. If the subtype changes the way that an item works, something that handles the supertype might not work properly.
</p>

<p>
このことは、
型~systemの理論においては
`Liskov の代用~原則＠https://en.wikipedia.org/wiki/Liskov_substitution_principle$
として知られる。
◎
In the theory of type systems, this is known as the Liskov Substitution Principle.
</p>

<div class="example">
<p>
`Event$I 型は、［
`KeyboardEvent$I, `PointerEvent$I
］の上位型である。
どの~eventも，常に同じ基本的な［
~prop, それに適用される動作
］たちが成す集合を有する
— 当の~eventが浮上する（ `bubbles＠~DOM4#dom-event-bubbles$c ~EQ ~T ）か否かの様な。
下位型は，新たな［
~prop／動作
］を追加するが、
それら下位型の各~instanceは，
依然としてあらゆる仕方で `Event$I として動作する。
◎
The Event type is a super-type of KeyboardEvent and PointerEvent. Events always have the same basic set of properties and actions that apply, like whether the event bubbles. The subtypes add new properties and actions, but instances of those subtypes still act in every way as an Event.
</p>
</div>

<p>
もっと単純な~approachでは、
継承を避けて，
既存の能力を構成により再利用することが多い。
新たな~itemは、
必要な既存の成分を保持する~propを定義できる。
◎
A simpler approach is often to avoid inheritance and reuse existing capabilities by composition. New items can define properties that hold any existing components that are needed.
</p>

<div class="example">
<p>
`~formに所有され得る~custom要素$は、
~form提出とヤリトリすることを~custom要素に許容する。
`HTMLInputElement$I を特化することは困難になろう
— `input$e 要素は かなり複階的であり、
特化するためには，その複階性も保守する必要があるので。
~custom要素は、
`HTMLInputElement$I の複雑化を処する必要なく，
~formとヤリトリするため必要yな~itemを付せる
（すなわち，構成できる）。
◎
Form-associated custom elements allow custom elements to interact with form submission. Specializing HTMLInputElement would be difficult, because an input element is quite complex and a specialization of HTMLInputElement would need to maintain that complexity. Custom elements can attach (i.e., compose) items that are necessary to interact with a form without having to deal with the complications of HTMLInputElement.
</p>
</div>

		</section>
	</section>
	<section id="html">
<h2 title="HTML">3. ~HTML</h2>

<p>
この節は、
~HTMLを介して公開される特能~用の設計~原則を詳細する。
◎
This section details design principles for features which are exposed via HTML.
</p>

		<section id="attribute-reuse">
<h3 title="Re-use HTML attribute names (only) for similar functionality">3.1. 類似な機能性（のみ）を備える~HTML属性の名前を再利用すること</h3>

<p>
~HTML属性を通して指定される特能を追加している場合、
別の要素に［
類似な機能性を指定する既存の属性~名
］が在るかどうか検査すること。
既存の~HTML属性~名を再利用することは、
次を意味する
⇒＃
作者は既存の知識を用立てれる／
複数の言語にわたって`一貫性＠#consistency$を保守する／
語彙を少なく保つ
◎
If you are adding a feature that is specified through an HTML attribute, check if there is an existing attribute name on another element that specifies similar functionality. Re-using an existing HTML attribute name means authors can utilize existing knowledge, maintains consistency across the language, and keeps its vocabulary small.
</p>

<div class="example">
同じ属性~名 `multiple＠~HEforms#attr-select-multiple$a が［
`select$e, `input$e
］どちらにも利用される
— ［
前者は複数個の値たちが成す選定／
後者は複数個の値たちが成す~entry
］を許容する。
◎
The same attribute name, multiple, is used on both select to allow selection of multiple values, as well as on input to allow entry of multiple values.
</div>

<div class="example">
`open＠~HEinteractive#attr-details-open$a 属性は、
`details$e 要素に導入されてから， `dialog$e に再利用された。
◎
The open attribute was introduced on the details element, and then re-used by dialog.
</div>

<p>
既存の~HTML属性を再利用する場合、
その構文は，当の属性の構文にアリな限り近づけるよう努めること。
◎
If you do re-use an existing HTML attribute, try to keep its syntax as close as possible to the syntax of the existing attribute.
</p>

<div class="example">
`label$e 要素に導入された `for＠~HEforms#attr-label-for$a 属性は、
それが どの~form要素に結付けられるべきかを指定する。
それは後で `output$e に再利用された
— どの要素が［
入力~値に寄与したか, あるいは その計算に影響したか
］を指定するため。
後者の構文は，前者より広い［
~space等で分離された~IDたちが成す~list
］を受容する一方で、
前者は~IDを 1 個しか受容しない。
しかしながら，どちらも依然として同じ構文【前者を包摂する後者の構文】に適合する。
一方で、
例えば，一方は~IDたちが成す~list, 他方は~CSS選択子を受容するようにした場合、
~antipatternになる。
◎
The for attribute was introduced on the label element, for specifying which form element it should be associated with. It was later re-used by output, for specifying which elements contributed input values to or otherwise affected the calculation. The syntax of the latter is broader: it accepts a space-separated list of ids, whereas the former only accepts one id. However, they both still conform to the same syntax, whereas e.g. if one of them accepted a list of ids, and the other one a selector, that would be an antipattern.
</div>

<p>
逆も適用される
⇒
追加している機能性が既存の~HTML属性と`類似しない^strong場合には、
既存の~HTML属性~名を`再利用しない^strongこと。
◎
The inverse also applies: do not re-use an existing HTML attribute name if the functionality you are adding is not similar to that of the existing attribute.
</p>

<div class="example">
［
`input$e ／ `button$e
］要素に利用される `type^a 属性は，要素~型をさらに特化する一方で、
他の要素（例： `link$e, `script$e, `style$e ）は，どれも~MIME型を指定する。
これは、
~antipatternである
— 前者と後者どちらかの属性は、
名前を違えるべきであった。
◎
The type attribute is used on the input and button elements to further specialize the element type, whereas on every other element (e.g. link, script, style) it specifies MIME type. This is an antipattern; one of these groups of attributes should have had a different name.
</div>

		</section>
		<section id="html-lists">
<h3 title="Use space-separated attributes for short lists of values, separate elements for longer lists">3.2. 短い~list用には~spaceで分離された値たちをとる属性を, より長い~list用には別々な要素からなる~listを利用すること</h3>

<p>
ある要素についての~metadataを［
値たちが成す~list
］として指定するときの共通な実施は、
~spaceで分離された~listを利用した上で，
それを `DOMTokenList$I として公開することである。
◎
When specifying metadata about an element that can be a list of values, common practice is to use a space-separated list and expose it as a DOMTokenList.
</p>

<div class="example">
要素の `class＠~HTMLdom#classes$a 内容~属性は、
~spaceで分離された一群の~class名たちが成す~listをとる。
対応する `classList＠~DOM4#dom-element-classlist$c ~IDL属性は、
作者が各~class名を［
追加する／除去する
］ことを許容する `DOMTokenList$I を返す。
◎
The class attribute on elements takes a space-separated list of class names. classList is a DOMTokenList that allows authors to add and remove class names.
</div>

<div class="example">
`iframe$e 要素の `sandbox＠~HEembed#attr-iframe-sandbox$a 内容~属性は、
~spaceで分離された~sandbox~flagたちが成す~listをとる。
対応する `sandbox＠~HEembed#dom-iframe-sandbox$c ~IDL属性は、
作者が各~sandbox~flagを［
追加する／除去する
］ことを許容する `DOMTokenList$I を返す。
◎
The sandbox attribute takes a space-separated list of sandbox flags. iframe.sandbox is a DOMTokenList that allows authors to add and remove sandbox flags.
</div>

<p>
~web~platformを成す他の各部との一貫性は重要である
— これが，［
値どうしを別の文字を利用して分離する
］ことを意味する場合でも。
◎
Consistency with other parts of the Web Platform is important, even if this means using another character to separate values.
</p>

<div class="example">
`accept＠~HEinput#attr-input-accept$a 内容~属性がとる値~listは
~commaで分離される
— それは、
`Accept＠~HTTPsem#field.accept$h ~HTTP~headerの構文に合致する必要があるので。
◎
The accept attribute is a comma-separated list of values, because it needs to match the syntax of the `Accept` HTTP header.
</div>

<p>
構文に関わらず、
属性は，値たちが成す~listが短い場合に限り利用するベキである。
より長い~list用には、
ある属性~内に~list全体を埋込むことは忌避される。
代わりに，現在の実施は、
各~list~item（および それについての~metadata）を別々な要素を利用して表現することである。
これらの要素は、
当の要素の子~群を成すようにすることも，属性を通して~linkすることもできる。
◎
Regardless of syntax, attributes should only be used for short lists of values. For longer lists, embedding the entire list in an attribute is discouraged. Instead, current practice is to use separate elements to represent the list items (and any metadata about them). These elements could either be children of the element in question, or linked through an attribute.
</p>

<div class="example">
`select$e 要素~用の値たちが成す~listは、
その子~群を成す一連の `option$e 要素として供される。
しかしながら，
`input$e 要素~用に推奨される値たちが成す~listを供するときは、
別々な要素（ `datalist$e ）が利用され，
`list＠~HEinput#attr-input-list$a 属性を通して~linkされる。
◎
The list of values for the select element is provided as a series of option element children. However, when providing a list of recommended values for an input element, a separate element is used (datalist), linked through a list attribute.
</div>

<div class="example">
［
`video$e ／`audio$e
］要素~用の~media~sourceたちが成す~listは、
その子~群を成す一連の `source$e 要素として供される。
◎
The list of media sources for a video or audio element is provided as a series of source element children.
</div>

<p>
稀な~instanceにおいては、
他の~tradeoffが必要yである。
◎
In rare instances, other tradeoffs are necessary.
</p>

<div class="example">
`img$e 要素の `srcset＠~HEimages#attr-img-srcset$a 属性は、
一群の`画像~候補~文字列＠~HEimages#image-candidate-string$用に~commaで分離された~listを許容する。
子~要素たちが成す~listよりも この構文が選ばれたのは、
冗漫さを避けるため, および［
`img$e 要素は`~void要素＠~HTMLwriting#void-elements$であり，子~要素を許可しない
］からである。
~spaceで分離された構文は、
各~list~itemが複数個の値を含むので，アリでなかった。
◎
The srcset attribute allows for a comma-separated list of image candidate strings. This syntax was chosen over a list of child elements to avoid verbosity and because the img element is an empty element that does not permit child elements. A space-separated syntax would not have been possible, as each list item includes multiple values.
</div>

		</section>
		<section id="avoid-html-parser-blocking">
<h3 title="Do not pause the HTML parser">3.3. ~HTML構文解析器を静止させないこと</h3>

<p>
当の設計は、
次を確保すること
⇒
~HTML構文解析器に［
外部~資源を取扱うために静止する
］よう要求しない。
◎
Ensure that your design does not require HTML parser to pause to handle external resources.
</p>

<p>
~browserは，~pageを構文解析するに伴い、
当の~pageに必要な~assetを発見して，各~assetに対し［
並列的に読込むべきかどうか，優先度を解明する
］ことになる。
そのような構文解析は、
ある資源が後続な資源の発見を阻む場合に妨害され得る。
このことは：
最悪な場合、
~browserは［
各~itemを並列的ではなく順番に~downloadする
］ことを意味する。
最善な場合、
~browserは［
投機的な構文解析に基づいて~downloadを~queueする
］ことを意味する
— それは、
不正であると判明することもある。
◎
As a page parses, the browser discovers assets that the page needs, and figures out a priority in which they should be loaded in parallel. Such parsing can be disrupted by a resource which blocks the discovery of subsequent resources. At worst, it means the browser downloads items in series rather than parallel. At best, it means the browser queues downloads based on speculative parsing, which may turn out to be incorrect.
</p>

<p>
ある特能が構文解析器を阻むのは、
一般に［
追加的な内容を後続な内容より前に構文解析器の中へ投入したい
］と求めるからである。
旧来の `&lt;script src="…"&gt;^c 要素の事例は、
これに該当し，
`document.write(…)^c を利用して構文解析器の中へ何かを注入し得る。
上述した処理能の課題に因り、
新たな特能は，これを行なってはナラナイ。
◎
Features that block the parser generally do so because they want to feed additional content into the parser before subsequent content. This is the case of legacy &lt;script src="…"&gt; elements, which can inject into the parser using document.write(…). Due to the performance issues above, new features must not do this.
</p>

		</section>
		<section id="avoid-render-blocking">
<h3 title="Avoid features that block rendering">3.4. 具現化を阻む特能は避けること</h3>

<p>
~pageを具現化する前に資源の読込ngや他の演算を要求する特能は、
それまで~pageが空欄に（または以前の~pageのままに）なる結果，
利用者~体験が拙くなることが多い。
◎
Features that require resource loading or other operations before rendering the page, often result in blank page (or the previous page). The result is a poor user experience.
</p>

<p>
そのような特能の追加を考慮するのは、
利用者~体験が総合的に改善される事例に限ること。
これの正準的な例は、［
~stylesheetを~downloadして処理するために具現化を阻む
］ことである
— さもなければ、
未~styleな内容が明滅して，望ましくない利用者~体験になる。
◎
Consider adding such features only in cases when the overall user experience is improved. A canonical example of this is blocking rendering in order to download and process a stylesheet. The alternative user experience is a flash of unstyled content, which is undesirable.
</p>

<p>
次も見よ
⇒＃
`§ 一部の~APIは専用~workerに限り公開するベキである＠#worker-only$
◎
See also § 10.2.1 Some APIs should only be exposed to dedicated workers.
</p>

		</section>
		<section id="html-idl-must-by-synced">
<h3 title="Keep attributes in sync">3.5. 内容~属性と~IDL属性の同期cを保つこと</h3>

<p>
新たな内容~属性には、［
同じ名前を伴う対応する~IDL属性
］があって，この 2 つの状態は同期するよう保たれるベキである。
同期される~IDL属性には一貫した名前を付けるベキである
— さもないと作者を惑わすことになるので。
◎
New content attributes should have a corresponding IDL attribute with the same name, and the state between the two should be kept synchronized. Carving out a synchronized IDL attribute with inconsistent naming results in confusion, and should be avoided.
</p>

<p class="note">注記：
この逆も成立するわけではない。
新たな~IDL属性は、
常に ある内容~属性に相応するものを請合うとは限らない。
◎
This does not hold the other way around. A new IDL attribute does not always warrant a content attribute counterpart.
</p>

<div class="example">
この指導に反する~patternは、［
`input$e の `value＠~HEinput#attr-input-value$a ／
`option$e の `selected＠~HEforms#attr-option-selected$a ／
`input$e の `checked＠~HEinput#attr-input-checked$a
］にて見出せる
— これらの内容~属性は、
同じ名前を伴わない~IDL属性［
`defaultValue＠~HEinput#dom-input-defaultvalue$c ／
`defaultSelected＠~HEforms#dom-option-defaultselected$c ／
`defaultChecked＠~HEinput#dom-input-defaultchecked$c
］に反映される。
◎
A counterpattern to this guidance can be found in input’s value, option’s selected, and input’s checked where the content attributes are not reflected to IDL attributes with the same names. Their IDL attributes are defaultValue, defaultSelected and defaultChecked respectively.
</div>

		</section>
		<section id="naming-of-url-attributes">
<h3 title="Name URL-containing attributes based on their primary purpose">3.6.  ~URLを包含している属性は、首な目的に基づいて命名すること</h3>

<p>
新たな内容~属性は、［
当の要素が，当の属性に包含される~URLへ~navigateすること
］を利用者に可能化する場合には，
`href^a と命名すること
— `a$e 要素の `href＠~HEmetadata#attr-link-href$a 属性の様に。
◎
If the element enables the user to navigate to the URL contained in the attribute, call the attribute href, like the a element’s href attribute.
</p>

<p class="note">注記：
後の祭りだが、
`form$e の `action＠~HTMLforms#attr-fs-action$a 属性は，
`href^a と命名されるベキであった。
◎
Note: In hindsight, form’s action attribute should have been named href.
</p>

<p>
所与の~URLにある資源を当の要素に読込ませる場合には、
当の属性を `src^a と命名すること
— ［
`img$e 要素の `src＠~HEimages#attr-img-src$a 属性 ／
`script$e 要素の `src＠~HEscripting#attr-script-src$a 属性
］の様に。
◎
If the element causes the resource at the given URL to be loaded, call the attribute src, like the img element’s src attribute or the script element’s src attribute.
</p>

<p class="note">注記：
~HTMLには、
旧来の，模倣されるベキでない非~一貫性がいくつかある
— 例えば，
`link$e 要素の `href＠~HEmetadata#attr-link-href$a 属性は、
当の要素の `rel＠~HEmetadata#attr-link-rel$a 属性の値に依存して，
~naviを許容することも, 資源の読込ngを許容することもある。
◎
Note: HTML has a number of legacy inconsistencies that should not be emulated, like the way link’s href attribute might allow for navigation or for resource loading, depending on the value of the element’s rel attribute.
</p>

<p>
当の属性が識別する~URLが，当の要素の目的には補助的【！auxilliary】な場合、
当の属性を その意味論に従って命名すること
— ［
`video$e の `poster＠~HEmedia#attr-video-poster$a ／
`q$e の `cite＠~HEtextlevel#attr-q-cite$a ／
`a$e の `ping＠~HTMLlinks#ping$a
］の様に。
◎
If the attribute identifies a URL that is auxilliary to the element’s purpose, like video’s poster, q’s cite, or a’s ping, name the attribute after its semantics.
</p>

<p class="note">注記：
~URLを包含している属性は、
~IDLにおいては `USVString$c として表現するベキであることにも留意すること
— `§ 文字列を適切に表現すること＠#idl-string-types$を見よ。
◎
Note: remember that attributes containing URLs should be represented in IDL as USVString; see § 8.2 Represent strings appropriately.
</p>

		</section>
		<section id="html-overloading">
<h3 title="Give each HTML element a single purpose">3.7. 各~HTML要素に与える目的は一つに限ること</h3>

<p>
各~HTML要素には、
明瞭な目的を有するべきである。
要素の意味論は，各種~HTML属性を利用して改変できるが、
属性は，要素の目的を根本的に改めるべきではない。
◎
Each HTML element should have a clear purpose. Using HTML attributes can modify the semantics of an element, but attributes should not fundamentally alter that purpose.
</p>

<p class="trans-note">【
この節における “要素” は、
要素~型を意味する
— 個々の要素ではなく。
】</p>

<p>
要素を各種~modeで演算できるよう定義するよりも，
各~mode用に別々な要素がある方が好ましい。
このことは、
作者にとっても用法を単純~化する。
◎
Rather than defining elements that can operate in different modes, having a separate element for each mode is preferable. This simplifies usage for authors.
</p>

<div class="example">
<p>
`input$e 要素は、
`type＠~HEinput#attr-input-type$a 属性を利用して，
ごく異なる~modeたちを切替える。
これら各~modeは，
利用者~入力をとるという共通な目標を共有するが、
一つの目的には広過ぎる。
これらの~modeの意味論は、
別個な要素~名の利用を通して，
もっと明瞭に表出することもできた。
◎
The input element uses a type attribute to switch between very different modes. Though each of these modes share a common goal of taking user input, that is too broad a purpose. The semantics of these modes could have been more clearly expressed through the use of distinct element names.
</p>
</div>

<p>
同じ要素に対し，属性たちの利用を通して意味論を多重定義することは、
各種~挙動から一つを選定するためにも利用できる。
これは、［
当の属性たちの値が何であれ，目的は同じであり続ける所
］に限り，イミを成す。
◎
Overloading of semantics on the same element through the use of attributes could be used to select between different behavior. This only makes sense where the purpose remains the same for any value of the attributes.
</p>

<div class="example">
<p>
`textarea$e 要素と［
`type＠~HEinput#attr-input-type$a 属性に `text^l を伴う `input$e 要素
］には、
同じ要素を利用することもできた
— これらの相違は、
重大ではないので。
◎
The textarea element and an input element with a type of "text" could have used the same element as the differences between these is not material.
</p>
</div>

<p>
反例になり得るものとして、［
特化され過ぎた要素,
文脈に依拠して自身の意味論を確立する要素
］が挙げられる。
◎
Potential counterexamples include overspecialization and elements that rely on context to establish their semantics.
</p>

<div class="example">
<p>
今や非推奨にされた `acronym$e 要素は、
`abbr$e 要素の重複物なので，特化され過ぎである。
◎
The now-deprecated acronym element is duplicative of the abbr element and therefore overspecialization.
</p>
</div>

<div class="example">
<p>
`source$e 要素の目的は、
文脈に依存して別個になり得る。
`source$e 要素は、
自立的ではない
— その意味論は、
親により決定される。
◎
The source element can have distinct purposes depending on context. A source element is not standalone; it’s semantics are determined by its parent.
</p>
</div>

		</section>
	</section>
	<section id="css">
<h2 title="Cascading Style Sheets (CSS)">4. ~CSS</h2>

<p>
この節は、
~CSS（ `Cascading Style Sheets^en ）を介して公開される特能~用の設計~原則について詳細する。
◎
This section details design principles for features which are exposed via CSS.
</p>

		<section id="css-property-separation">
<h3 title="Separate CSS properties based on what should cascade separately">4.1. ~CSS~propは、何が別々に~cascadeされるべきかに基づいて分離すること</h3>

<p>
~CSS~propの値として，どれを一緒に~group化して どれを分離するべきかは、
何を独立に設定すればイミを成すかに基づいて裁定すること。
◎
Decide which values should be grouped together as CSS properties and which should be separate properties based on what makes sense to set independently.
</p>

<p>
`~CSS~cascade法＠~CASCADE#cascading$【！~TR/2011/REC-CSS2-20110607/cascade.html#cascade】は、
~CSS［
規則／~stylesheet
］に属する`~CSS宣言＠~CSSOM1#css-declaration$【！~TR/2011/REC-CSS2-20110607/syndata.html#declaration】が別のそれを上書きすることを許容する。
一緒に上書きされるべき値たちが成す集合は、
一緒に~cascadeするよう，単独の~prop内に一緒に~group化されるべきである。
同様に，独立に上書き可能になるべき各~値は、
別々な~propに分けられるべきである。
◎
CSS cascading allows declarations from different rules or different style sheets to override one another. A set of values that should all be overridden together should be grouped together in a single property so that they cascade together. Likewise, values that should be able to be overridden independently should be separate properties.
</p>

<div class="example">
<p>
例えば， `initial-letter$p ~propの［
`占める行l数＠~CSSINLINE#initial-letter-initial-letter-size$,
`沈込する行l数＠~CSSINLINE#initial-letter-initial-letter-sink$
］は、
単独の~propに所属する
— それらは、
`先頭字＠~CSSINLINE#initial-letter$による単独の効果
（例：
`埋没~頭字＠~CSSINLINE#dropped-initial$,
`沈込み頭字＠~CSSINLINE#sunken-initial$,
`持上げ頭字＠~CSSINLINE#raised-initial$†）
の一部を成すので。
【† これらは、より一般な当の効果を成す いくつかの共通的な事例~用に命名された変種である。】
◎
For example, the "size" and "sink" aspects of the initial-letter property belong in a single property because they are part of a single initial letter effect (e.g., a drop cap, sunken cap, or raised cap).
</p>

<p>
しかしながら， `initial-letter-align$p ~propは、
分離されるべきである。
それは、
これらすべての効果~用に文書~全体にわたる整列~施策を設定する
— それは、
一般的な~style上の選択であり，
当の文書~内で利用されている用字系（例： ~Latin, ~Cyrillic, ~Arabic）の機能である。
◎
However, the initial-letter-align property should be separate because it sets an alignment policy for all of these effects across the document which is a general stylistic choice and a function of the script (e.g., Latin, Cyrillic, Arabic) used in the document.
</p>
</div>

		</section>
		<section id="css-inherited-or-not">
<h3 title="Make appropriate choices for whether CSS properties are inherited">4.2. ~CSS~propが継承されるかどうかについて適切な選択を為すこと</h3>

<p>
ある~propが`継承-$されるべきかどうかは、
次に基づいて裁定すること
⇒
~propによる効果は、
同じ~propが当の要素の ある先祖や子孫に設定された場合に［
上書きされる／追加される
］どちらになるべきか。
◎
Decide whether a property should be inherited based on whether the effect of the property should be overridden or added to if set on an ancestor as well as a descendant.
</p>

<p>
~propを要素に設定することによる効果が，要素の先祖に設定することによる効果
⇒＃
を上書きする必要がある場合、当の~propは，おそらく継承されるべきである／
とは別々な効果を追加する場合、当の~propは，おそらく`継承されない^strongべきである
◎
If setting the property on a descendant element needs to override (rather than add to) the effect of setting it on an ancestor, then the property should probably be inherited.
◎
If setting the property on a descendant element is a separate effect that adds to setting it on an ancestor, then the property should probably not be inherited.
</p>

<p>
継承されない~propの仕様が，要素に対し［
先祖の同じ~propの値を調べる取扱い
］を要求している場合（それは、遅くもなり得る）、［
当の~propは，およそ継承されるべきであった
］ことを示唆する “~code臭（ `code smell^en, ~~兆候）” である。
継承される~propの仕様が，要素に対し［
~propの値が要素の親の同じ~propの値と同じになる場合には，~propを無視する取扱い
］を要求している場合、［
当の~propは，およそ継承されるべきでなかった
］ことを示唆する “~code臭” である。
◎
A specification of an non-inherited property requiring that the handling of an element look at the value of that property on its ancestors (which may also be slow) is a "code smell" that suggests that the property likely should have been inherited. A specification of an inherited property requiring that the handling of an element ignore the value of a property if it’s the same as the value on the parent element is a "code smell" that suggests that the property likely should not have been inherited.
</p>

<p class="note">注記：
~textに対し効果がある~propは、
ほぼ常に［
要素に設定することによる効果は、
要素の先祖に設定することによる効果を（追加するのではなく）上書きする必要がある
］ので，継承されるべきである。
これはまた、
次の設計~原則を保守するためにも必要になる
⇒
~text片の周りに~styleを伴わない行内~要素を挿入しても
【~text片を`行内~box＠~CSSDISP#inline-box$を生成する要素で包装しても】，
その~textの外観は変化しない。
◎
If a property has an effect on text, then it’s almost always true that a descendant element needs to override (rather than add to) the effect of setting it on an ancestor, and the property should be inherited. This is also needed to maintain the design principle that inserting an unstyled inline element around a piece of text doesn’t change the appearance of that text.
</p>

<div class="example">
<p>
例えば，
`background-image$p ~propは、
`継承されない^strong。
◎
For example, the background-image property is not inherited.
</p>

<p>
`background-image$p ~propが継承されるとした場合、
当の仕様は［
各~子孫において，部分的に透明な画像が可視に繰返される
］のを避けるため，複階性をかなり~~増す必要があろう。
この複階性は，おそらく、［
当の~propが親~要素に同じ値を有する場合，異なる挙動になる
］ことを孕むことになろう
— それは、
上で言及した，［
当の~propは，およそ継承されるべきでなかった
］ことを示唆する “~code臭” である。
◎
If the background-image property had been inherited, then the specification would have had to create a good bit of complexity to avoid a partially-transparent image being visibly repeated for each descendant element. This complexity probably would have involved behaving differently if the property had the same value on the parent element, which is the "code smell" mentioned above that suggests that a property likely should not have been inherited.
</p>
</div>

<div class="example">
<p>
別の例として，
`font-size$p ~propは、
`継承される^strong。
それは、
当の要素~内の~text用に利用される~fontの~sizeを設定し，
`font-size$p を異なる値に設定する宣言が無い子孫にも，適用され続ける。
◎
Another example is the font-size property, which is inherited. It sets the size of the font used for the text in the element, and continues to apply to any descendants that don’t have a declaration setting font-size to a different value.
</p>

<p>
`font-size$p ~propが継承されなかった場合，おそらく、
先祖~連鎖を遡って，［
その値を有さない最も近い先祖から その`初期~値$を見出す
］ことを要求することになろう
— それは、
上で言及した，［
当の~propは，およそ継承されるべきであった
］ことを示唆する “~code臭” である。
◎
If the font-size property were not inherited, then it would probably have to have an initial value that requires walking up the ancestor chain to find the nearest ancestor that doesn’t have that value. This is the "code smell" mentioned above that suggests that a property likely should have been inherited.
</p>
</div>

		</section>
		<section id="css-computed-value">
<h3 title="Choose the computed value type based on how the property should inherit">4.3. 算出d値の型は、~propがどう継承されるべきかに基づいて選ぶこと</h3>

<p>
~CSS~propの`算出d値$は、［
当の~propは、
値をどう`継承-$することになるか
］に基づいて選ぶこと
— ［
値が他の~propに依存する所では、
どう継承されるべきか
］も含めて。
◎
Choose the computed value of a CSS property based on how it will inherit, including how values where it depends on other properties should inherit.
</p>

<p>
所与の~propの継承は、
次を意味する
⇒
要素の［
当の~prop
］の`算出d値$は、
要素の親の［
当の~prop
］の`算出d値$から取得される
— このことは、
次を意味する
⇒
処理~手続きのうち，`算出d値$に到達するより
⇒＃
前に起こるものは、`継承d値$に影響する／
後に起こるもの（`使用~値$用のものなど）は、`継承d値$に影響しない
◎
Inheritance means that an element gets the same computed value for a property that its parent has. This means that processing steps that happen before reaching the computed value affect the value that is inherited, and those that happen after (such as for the used value) do not.
</p>

<p class="note">注記：
`算出d値$と`解決d値$を混同するべきでない
— 後者は、
`getComputedStyle()＠~CSSOM1#dom-window-getcomputedstyle$c
~methodが返す値である。
◎
Note: the computed value should not be confused with the resolved value which is returned from the getComputedStyle() method.
</p>

<div class="example">
<p>
例えば `line-height$p ~propは、
`number$t 値も受容する
— `line-height:1.4^p —
など。
この値は `font-size$p の何倍になるかを表現するので、
`font-size^p が `20px^v なら，
`line-height^p の`使用~値$【！`実際の値$】は `length$t 値 `28px^v になるが、
`算出d値$は `number$t 値 `1.4^v になる【！（`使用~値$は `28px^v になる）】。
◎
For example, the line-height property may accept a &lt;number&gt; value, such as line-height: 1.4. This value represents a multiple of the font-size, so if the font-size is 20px, the actual value for the line height is 28px.
◎
However, the computed value in this case is the &lt;number&gt; 1.4, not the &lt;length&gt; 28px. (The used value is 28px.)
</p>

<p>
`line-height$p ~propは、
先祖とは `font-size$p が異なる要素の中へ継承され得る
— そのような要素において，［
その~propのうち， `line-height$p に依存するもの
］は、
当の先祖の `font-size$p ではなく，自身の `font-size$p を織り込まなければナラナイ。
◎
The line-height property can be inherited into elements that have a different font-size, and any property on those elements which depends on line-height must take the relevant font-size into account, rather than the font-size for the element from which the line-height value was inherited.
</p>

<pre class="lang-html">
&lt;body style="font-size: 20px; line-height: 1.4"&gt;

  &lt;p&gt;<span class="comment">
`body^e 内の この~textの行l高さは、
`28px^v になる。
◎
This body text has a line height of 28px.
</span>&lt;/p&gt;

  &lt;h2 style="font-size: 200%"&gt;
<span class="comment">
`line-height^p は `body^e に宣言されているが、
この見出しの `line-height^p の使用~値は，
`28px^v ではなく `56px^v になる。
すなわち、
~font~sizeが `40px^v になろうが，行l高さを~overflowしない。
◎
This heading has a line-height of 56px, not 28px, even though the line-height was declared on the body. This means that the 40px font won’t overflow the line height.
</span>
  &lt;/h2&gt;
&lt;/body&gt;
</pre>

<!-- 
This heading has a line-height of 56px,
not 28px, even though the line-height was declared on the body.
This means that the 40px font won’t overflow the line height.
-->

<p>
これらの `number^t 値は， `length^t 値より~~都合良く継承するので、
`line-height$p 用の値として，一般に選好される。
◎
These number values are generally the preferred values to use for line-height because they inherit better than length values.
</p>
</div>

<p>
次も見よ
⇒
`算出d値の~pattern＠https://wiki.csswg.org/spec/computed-values$
◎
See also:
• Computed Values Patterns
</p>

		</section>
		<section id="css-naming">
<h3 title="Name CSS properties and values appropriately">4.4. ~CSS~propとその値を適切に命名すること</h3>

<p>
~CSS~propの名前は，通例的に名詞であり、
それらの値の名前は，通例的に形容詞である（名詞のときもあるが）。
◎
The names of CSS properties are usually nouns, and the names of their values are usually adjectives (although sometimes nouns).
</p>

<p>
［
~prop／その値
］を成す各~単語は、
~hyphenで分離される。
一般に，略語は避けられる。
◎
Words in properties and values are separated by hyphens. Abbreviations are generally avoided.
</p>

<p>
アリなときは単語の語根を利用すること
— 文法~上の［
接頭辞や接尾辞
］を伴う形ではなく（例えば， `sizing^l ではなく `size^l ）。
◎
Use the root form of words when possible rather than a form with a grammatical prefix or suffix (for example, "size" rather than "sizing").
</p>

<p>
~prop用の値たちが成す~listは、
一般に，新たな値を追加できるように選ぶべきである
— 次に挙げる様な値は、
避けること
⇒
［
`yes^v, `no^v, `true^v, `false^v
］, あるいは、
基本的にこれらと等価な，より複階的な名前を伴うもの
◎
The list of values of a property should generally be chosen so that new values can be added. Avoid values like yes, no, true, false, or things with more complex names that are basically equivalent to them.
</p>

<p>
~propの名前においては、［
"`mode^en"（~mode）, "`state^en"（状態）
］の様な単語は避けること
— ~propは、
一般に［
~mode／状態
］を設定するものなので。
◎
Avoid words like "mode" or "state" in the names of properties, since properties are generally setting a mode or state.
</p>

<p>
命名に対する一般的な（各種~言語にわたる）助言は、
`§ 命名~原則＠#naming-is-hard$
を見よ。
◎
See § 12 Naming principles for general (cross-language) advice on naming.
</p>

		</section>
		<section id="css-content-should-be-visible">
<h3 title="Content should be viewable and accessible by default">4.5. 内容は既定で~view可能かつ~access可能になるべきである</h3>

<p>
~CSS~prop, および~CSS~layout~systemは
（それらは概して， `display$p ~propの値【で指定される】）、
次を保全するように設計すること
⇒
内容は、
既定では［
~view可能, ~access可能, 利用-可能
］になる
◎
Design CSS properties or CSS layout systems (which are typically values of the display property), to preserve the content as viewable, accessible and usable by default.
</p>

<div class="example">
例えば，~CSSにおける どの~layout~systemも、
その既定の挙動は［
内容が切取られる／
内容が他の内容と重合する／
~scrollしても内容に到達-不能
］に至ることはない。
これらが起こるのは、［
当の~CSS特能が，そのような挙動を明示的に選ぶように利用された場合
］に限るべきである（例：
`overflow:hidden$p ／
`left:-40em$p ／
`overflow:clip$p
）。
それらは、［
`display:flex$p や `position:relative$p
］の様な何かの結果として，既定で起こるべきでない
◎
For example, the default behavior of all layout systems in CSS will not lead to content being clipped, content overlapping other content, or content being unreachable by scrolling. These things should only happen if CSS features are used that are more explicitly choosing such a behavior (for example, overflow: hidden or left: -40em). They should not happen by default as a result of something like display: flex or position: relative.
</div>

		</section>
	</section>
	<section id="js">
<h2 title="JavaScript Language">5. ~JS言語</h2>

		<section id="js-only">
<h3 title="Use JavaScript for Web APIs">5.1. ~Web~APIには~JSを利用すること</h3>

<p>
~Web用に命令的な~APIを設計するときは、
~JSを利用すること。
特に、
【多数の言語に】一般~化する必要はなく，【~JS】言語に特有な［
意味論／規約
］に自由に依拠できる。
◎
When designing imperative APIs for the Web, use JavaScript. In particular, you can freely rely upon language-specific semantics and conventions, with no need to keep things generalized.
</p>

<div class="example">
<p>
例えば， `CustomElementRegistry$I の `define()＠~HEcustom#dom-customelementregistry-define$c ~methodは、
`構築子~method＠~TC39#sec-static-semantics-constructormethod$
への参照をとる。
◎
For example, the CustomElementRegistry.define() method takes a reference to a Constructor Method.
</p>

<p>
これには，比較的~近過去な［
~JSに対する~classの追加
］による利点がある
— 事実、
~JSにおいて~method参照を利用するのは，とても容易である。
◎
This takes advantage of the relatively recent addition of classes to JavaScript, and the fact that method references are very easy to use in JavaScript.
</p>
</div>

<p class="note">注記：
~JSは、
名前 `ECMASCRIPT$r の下で標準~化されている。
◎
JavaScript is standardized under the name [ECMASCRIPT].
</p>

<p class="note">注記：
`WEBIDL$r は，別々な “§ ~ES言語束縛” を定義するが、
それは［
~Web~IDLは、
他の~programming言語における言語束縛も備えることを意図する
］ことは含意しない。
◎
[WEBIDL] defines a separate "ECMAScript binding" section, but this doesn’t imply that Web IDL is intended to have bindings in other programming languages.
</p>

		</section>
		<section id="js-rtc">
<h3 title="Preserve run-to-completion semantics">5.2. 完了まで走る（ `run-to-completion^en ）意味論を保全すること</h3>

<p>
状態に対する変更が，~JS実行~文脈の外側に~~起因する場合、
その変化は，各~taskの合間に~JSへ伝播する
— 例えば、
`~taskを~queueする＠~WAPI#queuing-tasks$ことにより／
`描画の更新＠~WAPI#update-the-rendering$を成す一部として。
◎
If a change to state originates outside of the JavaScript execution context, propagate that change to JavaScript between tasks, for example by queuing a task, or as part of update the rendering.
</p>

<p>
C++ や Rust などの低~levelな言語と違って，~JSは、
歴史的に，一度に一つの~code片しか実行し得ないかのように動作してきた。
そのことから、
~JS作者は，次を当然のことと~~見なす
⇒
ある関数にて可用にされた~dataは、
当の関数が走っている間に予期せず変化することはない。
◎
Unlike lower-level languages such as C++ or Rust, JavaScript has historically acted as if only one piece of code can execute at once. Because of that, JavaScript authors take for granted that the data available to a function won’t change unexpectedly while the function is running.
</p>

<p>
［
開発者による動作の結果でない変化／
非同期に送達される変化
］は、
他の~JSの途中
— `小task$たちの合間も含む —
で起こるベキでない。
◎
Changes that are not the result of developer action and changes that are asynchronously delivered should not happen in the middle of other JavaScript, including between microtasks.
</p>

<div class="example">
<p>
開発者は，［
同期的な実行の間（ `while^c ~loopなど）
］および［
すでに解決された `Promise^c を `await^c している直後
］には、
次に挙げる様なものを`およそ期待しない^emものと見込まれる：
◎
During synchronous execution (such as a while loop), and after awaiting an already-resolved Promise, developers are unlikely to expect things like:
</p>
<ul>
	<li>
~HTML構文解析器が~networkから新たな内容を読込んでいる結果として、
~DOMが更新される。
◎
The DOM to update as a result of the HTML parser loading new content from the network
</li>
	<li>
~networkから画像~dataを読込んでいる結果として、
`img^e の `width＠~HEimages#dom-img-width$c が変化する。
◎
img.width to change as a result of loading image data from the network
</li>
	<li>
`Gamepad$I の各~buttonの状態が変化する。
◎
Buttons of a Gamepad to change state
</li>
	<li>
`scrollTop＠~CSSOMVIEW#dom-element-scrolltop$c が変化する
— 視覚的に~scrollされる場合でも。
◎
scrollTop to change, even if scrolling can visually occur
</li>
	<li>
同期的な~methodの動作が非同期的な状態~変化に依存して異なる。
例えば， `LockManager$I が同期的な~methodを有していた場合、
その挙動は，他の~windowにおける同時並行な~callに依存することになろう。
◎
A synchronous method to act differently depending on asynchronous state changes. For example, if LockManager had synchronous methods, their behavior would depend on concurrent calls in other windows.
</li>
</ul>

<p>
これらは、
現在~走っている~scriptにより更新されるものではないので，
現在の~taskの間に変化するベキではない。
◎
These things aren’t updated by the currently running script, so they shouldn’t change during the current task.
</p>
</div>

<p>
~dataは、
開発者による動作の結果としては，同期的に更新できる。
◎
Data can update synchronously from the result of developer action.
</p>

<div class="example">
<p>
~nodeに対する `remove()＠~DOM4#dom-childnode-remove$c は、
~DOMを同期的に変更し，即時に観測-可能になる。
◎
node.remove() changes the DOM synchronously and is immediately observable.
</p>
</div>

<p>
少数ながら，この規則に違反することを正当化する状況もある：
◎
A few kinds of situations justify violating this rule:
</p>
<ul>
	<li>
現在の時刻を観測すること
— `Date.now()＠~TC39M/numbers-and-dates.html#sec-date.now$c や `performance.now()＠~HRTIME#dom-performance-now$c のように。
が、
各~task間で一貫した時刻を呈示することも，有用になることに注意
— `document.timeline.currentTime＠~WANIMapi#dom-animationtimeline-currenttime$c のように。
◎
Observing the current time, as in Date.now() and performance.now(), although note that it’s also useful to present a consistent task-wide time as in document.timeline.currentTime.
</li>
	<li>
開発者が【自身による】同期的な作業を中断する助けになることが意味される関数
— `IdleDeadline$I の `timeRemaining()＠~REQUESTIDLECALLBACK#dom-idledeadline-timeremaining$c のように。
◎
Functions meant to help developers interrupt synchronous work, as in the case of IdleDeadline.timeRemaining().
</li>
	<li>
利用者を思いがけない~UI変化から保護することが意味される状態
— `一過な作動化＠~HTMLinteraction#transient-activation$の様な。
`navigator.userActivation.isActive＠~HTMLinteraction#dom-useractivation-isactive$c は、
`この事例には~methodを推奨する指導＠#attributes-like-data$に違反することに注意。
◎
States meant to protect users from surprising UI changes, like transient activation. Note that navigator.userActivation.isActive violates the guidance that recommends a method for this case.
</li>
</ul>

		</section>
		<section id="js-gc">
<h3 title="Don’t expose garbage collection">5.3. ~garbage収集を公開しないこと</h3>

<p>
当の~JS~Web~APIは、
次を確保すること
⇒
~garbage収集の時機を知る仕方を作者に供さない
◎
Ensure your JavaScript Web APIs don’t provide a way for an author to know the timing of garbage collection.
</p>

<p>
~garbage収集の時機は，~UAごとに異なることに加え、
~UAが処理能を改善する作業に伴い，時を経て変化することもある。
ある~APIが~garbage収集の時機を公開した場合、
~programの挙動が文脈に応じて異なる原因になり得る。
これは、
作者が これらの相違点を取扱うために加的な~codeを書する必要があることを意味する。
また，時機に依存するような特定0の仕方で働く~codeが~~普及すると、
~UAは異なる~garbage収集~策を実装するのが困難になり得る。
◎
The timing of garbage collection is different in different user agents, and may change over time as user agents work on improving performance. If an API exposes the timing of garbage collection, it can cause programs to behave differently in different contexts. This means that authors need to write extra code to handle these differences. It may also make it more difficult for user agents to implement different garbage collection strategies, if there is enough code which depends on timing working a particular way.
</p>

<p>
このことは、
弱い参照として動作する~API
— 例： ~garbage収集が走ったなら ~NULL になるような~prop —
は，公開するべきでないことを意味する。
~JS~codeにおける［
~obj／~data
］の存続期間は予測-可能になるべきである。
◎
This means that you shouldn’t expose any API that acts as a weak reference, e.g. with a property that becomes null once garbage collection runs. Object and data lifetimes in JavaScript code should be predictable.
</p>

<div class="example">
<p>
`getElementsByTagName()$c は `HTMLCollection$I ~objを返す。
この~objは、
同じ `Document$I ~objに対し，この~methodが同じ~tag名を伴って重ねて~callされた場合には再利用され得る。
これは，実施においては、
~garbage収集されなかった場合に限り，同じ~objが返されることを意味する。
これは、
~garbage収集の時機に依存して，挙動が異なることを意味する。
◎
getElementsByTagName returns an HTMLCollection object, which may be re-used if the method is called twice on the same Document object, with the same tag name. In practice, this means that the same object will be returned if and only if it has not been garbage collected. This means that the behaviour is different depending on the timing of garbage collection.
</p>

<p>
`getElementsByTagName()$c を今日に設計するなら、［
出力を依拠-可能に再利用するか，呼出される回ごとに新たな `HTMLCollection$I を生産する
］よう，その設計者に助言することになろう。
◎
If getElementsByTagName were designed today, the advice to the designers would be to either reliably reuse the output, or to produce a new HTMLCollection each time it’s invoked.
</p>
</div>

<p>
`getElementsByTagName()$c は、
~garbage収集の時機に依存し得ることについて何も告げない。
対照的に［
`WeakRef＠~TC39M/managing-memory.html#sec-weak-ref-objects$jT ／ `FinalizationRegistry＠~TC39M/managing-memory.html#sec-finalization-registry-objects$jT
］の様な，~garbage収集に依存するよう明示的に設計された~APIは、［
~garbage収集との相互作用についての作者の期待
］に正確aに沿うよう設定されている。
◎
getElementsByTagName gives no sign that it may depend on the timing of garbage collection. In contrast, APIs which are explicitly designed to depend on garbage collection, like WeakRef or FinalizationRegistry, set accurate author expectations about the interaction with garbage collection.
</p>

		</section>
	</section>
	<section id="api-surface">
<h2 title="Designing JavaScript APIs">6. ~JS~APIの設計-法</h2>

		<section id="webidl-dictionaries-interfaces-namespaces">
<h3 title="Use WebIDL dictionaries, interfaces, and namespaces appropriately">6.1. ~Web~IDLの辞書, ~interface, 名前空間を適切に利用すること</h3>

<p>
新たな~API用には、
適切な~Web~IDLの仕組みを利用すること。
◎
Use the appropriate WebIDL mechanisms for new APIs.
</p>

<p>
~Web~IDLは、
~Web~APIを定義するための構成子を定義する。
［
`辞書$, `~interface$, `名前空間$
］には、
それぞれ異なる目的に適した異なる特質がある。
◎
WebIDL defines multiple constructs for defining Web APIs. Dictionaries, interfaces, and namespaces each have different properties suited to different purposes.
</p>

<p>
目標は、［
~Web開発者たちが自然に感じるような，使い易く, 一貫した~API
］を確保する一方で，［
“捏造~class” や機能性を何も供さない~class
］の様な陥穽を避けることにある。
◎
The goal is to ensure ergonomic, consistent APIs that feel natural to Web developers while avoiding pitfalls like "fake classes" or classes that provide no functionality.
</p>

			<section id="dictionaries-for-configuration">
<h4 title="Use Dictionaries for “Configuration” or “Input-Only” Data">“環境設定” や “入力に限られる” ~data用には辞書を利用すること</h4>

<p>
~APIを成す一過な~dataを表現する部分
— とりわけ，~APIが一群の［
~parameter／環境設定／~option
］を受容する所では —
`辞書$を選ぶこと。
◎
Choose a dictionary when the part of the API represents data that is transient, especially when an API accepts a set of parameters, configuration, or options.
</p>

<p>
`辞書$は、
当の~dataが［
格納されることも, 変異されることもなく，~call時にしか利用されない
］ときに理想的になる。
◎
Dictionaries are ideal for when the data doesn’t get stored or mutated; it’s just used it at the time of the call.
</p>

<div class="example">
<p>
例えば， `WEB-SHARE$r の `ShareData$I ：
◎
For example, the ShareData member from Web Share [WEB-SHARE]:
</p>

<pre class="idl">
dictionary ShareData {
  USVString title;
  USVString text;
  USVString url;
};
</pre>

<p>
を成す~memberは、
次の様に共通的に利用される：
◎
And how it’s commonly used:
</p>

<pre class="lang-js">
await navigator.share({text: "Text being shared" });
</pre>
</div>

<p>
`辞書$は、
容易に拡張-可能であり，
後で［
必要に応じて，省略可能な~fieldを追加する
］ことを容易にする。
辞書を成す各~memberは，既定では省略可能であるが、
必要なら，
`required^c ~keywordにより`要求される~member＠~WEBIDL#required-dictionary-member$として~markできる。
◎
Dictionaries are easily extensible and makes it easy to add optional fields later as needed. Members of a dictionary are optional by default, but can be marked as required if needed.
</p>

<p>
`辞書$は、
ごく成句的でもある
（すなわち，~JSにおいて自然に利用される）。
`{ ... }^c を~inlineに渡すことは、
~JSにおいて環境設定を給するための最も自然な仕方になる。
◎
Dictionaries are also highly idiomatic (i.e., natural to use in JavaScript). Passing { ... } inline is the most natural way to supply configuration in JavaScript.
</p>

<p>
辞書は、
その~UAによる扱われ方から，比較的~将来にも通用する。
実装が解さない辞書~memberは無視されるので、
旧い~codeを非互換化することなく，新たな~memberを追加できる。
◎
Dictionaries, because of how they are treated by user agents, are also relatively future-proof. Dictionary members that are not understood by an implementation are ignored. New members therefore can be added without breaking older code.
</p>

<p>
辞書は、［
~lifecycleにおいて型により判別する必要がない~obj
］用に利用するのが最善である
（すなわち， `instanceof^c による検査は、
常に `Object^jT になるので，ほとんど無意味である）。
◎
Dictionaries are best used for objects that don’t need to be distinguished by type in their lifecycle (i.e., instanceof checks are mostly meaningless because it’s always Object).
</p>

<p>
辞書は、
~methodへは “値により渡される”
（すなわち，複製される）。
~browser~engineは、
~JS~objから~Web~IDL表現へ変換するときに，未知な~memberを剥ぐ。
このことは、
それを~APIの中へ渡した後に当の値を変更しても，効果は無いことを意味する。
◎
Dictionaries are "passed by value" to methods (i.e., they are copied). Browsers engines strip unknown members when converting from JavaScript objects to a WebIDL representation. This means that changing the value after it is passed into an API has no effect.
</p>

<div class="example">
<p>
再び，例として `ShareData$I 辞書をとり挙げる：
◎
Again, taking the ShareData dictionary as an example:
</p>
<pre class="lang-js">
const %data = {
    "text": "Text being shared",
    /* <span class="comment">
"`whatever^c" ~parameterは、
~browserにより無視され，含まれない：
◎
Ignored by a browser that does not include a "whatever" parameter.
</span> */
    "whatever": 123,
};
let %p = navigator.share(%data);

/* <span class="comment">
`.share()^c を~callした後に `.text^c を変更しても，効果は無い：
◎
Changing this after calling .share() has no effect
</span> */
%data.text = "New text";
</pre>
</div>

			</section>
			<section id="interface-for-functionality-state-identity">
<h4 title="Choose an Interface for Functionality, State, and Identity">機能性, 状態, 識別情報~用には~interfaceを選ぶこと</h4>

<p>
`~interface$は、
~JSにおける~classと概ね等価である。
仕様は、
状態を
— それに対する演算（すなわち，~method）と伴に —
束する必要があるときは，~interfaceを利用すること
— 当の状態が【~scriptから】可視な~prop, 内部的な “~slot” ​どちらであれ。
◎
Interfaces are roughly equivalent to classes in JavaScript. Use an interface when a specification needs to bundle state—​both visible properties and internal "slots"—​with operations on that state (i.e., methods).
</p>

<p>
`辞書$とは違って、
`~interface$は，次に挙げるものを行える：
◎
Unlike dictionaries, interfaces:
</p>
<ul>
	<li>
各~instanceに状態を伴わせる
◎
can have instances with state,
</li>
	<li>
必要なら読専な~propを有する
◎
can have need read-only properties,
</li>
	<li>
値がアテガわれる際に副作用を呈する
◎
can exhibit side-effects on assignment, and
</li>
	<li>
~objの識別情報を検査する能を供する
（すなわち、
`instanceof^c により，大域~scopeを成す特定0の~classの~instanceか否かを検査できる）
◎
provide the ability to check object’s identity (i.e., one can check if it is an instanceof a particular class on the global scope),
</li>
</ul>

<p>
`~interface$を定義することは、
それを大域~scope上にも公開して，静的~method用の指定も許容する。
◎
Defining an interface also exposes it on the global scope, allowing for the specification of static methods.＼
</p>

<div class="example">
<p>
例えば，
`URL$I ~interfaceの `canParse()＠~URL1#dom-url-canparse$c 静的~method：
◎
For example, the canParse() static method of the URL interface.
</p>

<pre class="lang-js">
if (URL.canParse(%someURL)) {
    /* <span class="comment">
何か行う…
◎
Do stuff...
</span> */
}
</pre>
</div>

<p>
状態を伴う~interfaceには、
アリなら構築子を与えること。
状態を伴わない~classには構築子を追加しないこと。
そうすることは、
実質的に "捏造~class" を作成する
— すなわち、
当の~interfaceの~instanceは，静的~methodが行えるもの以外は何もしない —
ことになるので，
`不良な実施^emと見なされる。
捏造~classを成す例として，
`DOMParser$I や `DOMImplementation$I が挙げられる。
◎
Give stateful interfaces a constructor, if possible. Do not add a constructor if a class has no state. Doing so is considered bad practice, as it is effectively creating a "fake class": that is, instances of the interface do nothing that a static method couldn’t do. DOMParser or DOMImplementation are examples of fake classes.
</p>

			</section>
			<section id="interface-serializer">
<h4 title="Provide a serializer to make interface data more accessible">~interface~dataをより~access可能にするためには，直列化子を供すること</h4>

<p>
`~interface$の各~instanceを［
多くの応用により利用されるようになるものと期待される形
］へ形式変換するためには、
当の~interfaceに直列化子を追加すること。
◎
Add serializers to transform instances of an interface into a form that is expected to be used by many applications.
</p>

<p>
`toJSON()＠~WEBIDL#idl-tojson-operation$c ~methodは、［
各種~interfaceの~instanceが有用な~JSON直列化を生産する
］ことを許容する。
`toBlob()^c ~methodは、
~interfaceの~binary表現を抽出するために利用できる。
◎
A .toJSON() method allows an instance of an interface to produce a useful JSON serialization. A .toBlob() method can be used to extract a binary representation of an interface.
</p>

<p class="trans-note">【
`toJSON()^c と命名される~methodには，汎用な仕組みが定義されているが、
`toBlob()^c には そのような仕組みは無い
（汎用に利用-可能ではないので、
例として挙げるには，いくぶん不適切に思われる
— そのように命名された~methodは、
 `HTMLCanvasElement$I の `toBlob()＠~HEcanvas#dom-canvas-toblob$c しか見当たらない）。
】</p>

<p>
これは、
~APIで~objを自然に利用できるようにする。
例えば， `GeolocationPosition$I は、
`toJSON()^c ~methodを供する：
◎
This makes object natural to use with APIs. For example, GeolocationPosition provides a toJSON() method:
</p>

<pre class="lang-js">
const %position = await new Promise((%resolve, %reject) =&gt; {
    navigator.geolocation.getCurrentPosition(%resolve, %reject);
});

const %message = JSON.stringify({
    user: userId,
    time: Date.now(),
    %position, /* <span class="comment">
`.stringify()^c は、
自動的に `.toJSON()^c を~callする
◎
.stringify() calls .toJSON() automatically
</span> */
});
</pre>

			</section>
			<section id="namespace-to-avoid-fake-classes">
<h4 title="Choose a namespace to Avoid “Fake Classes” for Behavior-Only Utilities">挙動に限られる~utility用には “捏造~class” を避けるため，名前空間を選ぶこと</h4>

<p>
`名前空間$は、
一群の静的な［
~prop, ~method
］たちを~group化するために存在する。
`名前空間$には~prototypeは無い。
~JSにおける例として［
`Math^jT, `Intl^jT, `Atomics^jT, `Console^jT
］~objが挙げられる。
◎
A namespace exists to group a set of static properties and methods. A namespace does not have a prototype. Examples include the Math, Intl, Atomics, and Console objects in JS.
</p>

<p>
小さな静的~関数が 2 つほどしかないときは、
新たな`名前空間$は，大袈裟にもなり得る
— それらは、
既存の~objに付する方が適切かもしれない。
◎
With one or two small static functions, a whole new namespace may be overkill. Attaching them to an existing object might be more appropriate.
</p>

<p>
逆に，［
巨大に／広く
］なり過ぎた名前空間は、［
もっと良く組織化する／
いくつかの論理-区分へ分離する
］ことも必要になり得る。
◎
Conversely, a namespace that grows too large or too broad may need better organization or separate logical partitions.
</p>

			</section>
			<section id="pseudo-namespaces">
<h4 title="&quot;Pseudo-namespaces&quot;">“疑似-名前空間”</h4>

<p>
`~interface$は，属性を有せるので、
構築-不能な~interfaceを属性【が返す値】として定義することにより，
“疑似-名前空間” を作成することもアリになる。
◎
As WebIDL interfaces can have attributes, it is possible to create "pseudo-namespaces" by defining non-constructable interfaces as attributes.
</p>

<p>
共通的な例として、
`navigator＠~HTMLnavigator#dom-window-navigator$c ~objに付される属性†すべてが挙げられる。
`navigator^c ~objが有する~interface定義は `Navigator$I であり、
それが包含する各~属性†は，
それが返す~interface~instanceを通して更なる機能性への~accessを与える。
【† `Navigator^I が`内包-$する~interface~mixinたちの属性は別として。】
◎
A common example are all the attributes attaches to the navigator object. The navigator object has an interface definition (Navigator), which itself contains other attributes that gives access to further functionality through interface instances.
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>
<ul>
	<li>
`navigator.credentials＠https://w3c.github.io/webappsec-credential-management/#dom-navigator-credentials$c
— `CredentialsContainer$I ~interface
`CREDENTIAL-MANAGEMENT-1$r
◎
navigator.credentials - The CredentialsContainer interface of the Credentials Management API.
</li>
	<li>
`navigator.geolocation＠~GEOLOCATION#dom-navigator-geolocation$c
— `Geolocation$I ~interface
`GEOLOCATION$r
◎
navigator.geolocation - The Geolocation interface of the Geolocation specification.
</li>
	<li>
`navigator.permissions＠~PERMISSIONS#dom-navigator-permissions$c
— `Permissions$I ~interface
`PERMISSIONS$r
◎
navigator.permissions - The Permissions interface of the Permissions specification.
</li>
</ul>
</div>

<p>
疑似-名前空間は、
仕様~策定者が何かに特有な~instanceを指す必要があるとき，有用になる
— その何かが~pageへ公開される可視な状態を有さない場合でも
（ `navigator.permissions^c 用には、
特定の閲覧~文脈へ適用する許可など）。
◎
Pseudo-namespaces are useful for when, as a spec author, you need to refer to a specific instance of a thing (such as the permissions that apply to a specific browsing context, for navigator.permissions) even if that thing does not have any visible state exposed to the page.
</p>

			</section>
		</section>
		<section id="attributes-like-data">
<h3 title="Attributes should behave like data properties">6.2. 属性は~data~propの様に挙動するべきである</h3>

<p>
~IDL属性 `WEBIDL$r は、
単純な~JS~obj~propの様に動作するべきである。
◎
[WEBIDL] attributes should act like simple JavaScript object properties.
</p>

<p>
現実においては、
~IDL属性は，別々な［
取得子, 設定子
］~methodを伴う，~accessor~propとして実装される。
それらが~JS~obj~prop様に動作するためには：
◎
In reality, IDL attributes are implemented as accessor properties with separate getter and setter methods. To make them act like JavaScript object properties:
</p>
<ul>
	<li>
取得子は、
観測-可能な副作用を伴ってはナラナイ。
◎
Getters must not have any observable side effects.
</li>
	<li>
取得子は、
複階的な演算を遂行するべきでない。
◎
Getters should not perform any complex operations.
</li>
	<li>
`obj.attribute === obj.attribute^c
が常に ~T になることを確保すること。
取得子が~callされる回ごとに新たな値を作成しないこと。
◎
Ensure that obj.attribute === obj.attribute is always true. Don’t create a new value each time the getter is called.
</li>
	<li>
アリなら、
<code>obj.attribute = %x</code>
に~~後続する
<code>obj.attribute === %x</code>
は， ~T に評価されることを確保すること。
（ %x に対し何らかの種類の変換が必要yな場合、
これはアリでないこともある。）
◎
If possible, ensure that given obj.attribute = x, obj.attribute === x is true. (This may not be possible if some kind of conversion is necessary for x.)
</li>
</ul>

<p>
ある属性を利用していて，この仕方で挙動しないことについて考している場合、
おそらく，代わりに~methodを利用するべきである。
◎
If you were thinking about using an attribute, but it doesn’t behave this way, you should probably use a method instead.
</p>

<div class="example">
`offsetTop＠~CSSOMVIEW#dom-htmlelement-offsettop$c
は，~layoutを遂行する
— それは、
複階的であり，時間がかかり得る。
これは、
`getBoundingClientRect()＠~CSSOMVIEW#dom-element-getboundingclientrect$c
の様に，~methodであった方が良かったであろう。
◎
For example, offsetTop performs layout, which can be complex and time-consuming. It would have been better if this had been a method like getBoundingClientRect().
</div>

		</section>
		<section id="live-vs-static">
<h3 title="Consider whether objects should be live or static">6.3. ~objは~liveか静的どちらになるべきか考慮すること</h3>

<p>
~APIが何らかの内部~状態を表現している~objへの~accessを与える場合、［
当の~objは，当の状態が変化するに伴い更新され続けるべきである
］かどうかを裁定すること。
◎
If an API gives access to an object representing some internal state, decide whether that object should continue to be updated as the state changes.
</p>

<p>
~objのうち，いつの時点でも現在の状態を表現するものは
`~live~obj@
である一方、
作成された時点の状態を表現するものは
`静的~obj@
である。
◎
An object which represents the current state at all times is a live object, while an object which represents the state at the time it was created is a static object.
</p>

			<section id="live-objects">
<h4 title="Live objects">~live~obj</h4>

<p>
ある~objの内部~状態を変更することを作者に許容する場合、
その~objは~liveになるべきである。
例えば，~DOM `Node$I は~live~objであり、
現在の状態を理解する下で，文書に対し変更を為すことを作者に許容する。
◎
If an object allows the author to change the internal state, that object should be live. For example, DOM Nodes are live objects, to allow the author to make changes to the document with an understanding of the current state.
</p>

<p>
~live~objの~propは、
~objの作成-時でなく，~objが~accessされる回ごとに算出され得る。
必要な~dataを算出するのが複階的な場合、
ときには，~live~objの方が良い選択になる
— ~objを返す前に，すべての~dataを算出する必要が無いので。
◎
Properties of live objects may be computed as they are accessed, instead of when the object is created. This makes live objects sometimes a better choice if the data needed is complex to compute, since there is no need to compute all the data before the object is returned.
</p>

<p>
静的な~objと違って，~live~objは、
~dataを複製する必要も無いので，~memoryの利用も少なく済み得る。
◎
A live object may also use less memory, since there is no need to copy data to a static version.
</p>

			</section>
			<section id="static-objects">
<h4 title="Static objects">静的~obj</h4>

<p>
ある~objが［
変化するかもしれない~list
］を表現する場合、［
当の~listを反復している~codeが，その途中で~listが変化するアリ性を取扱う必要
］を無くすよう，静的~objにするべきであることが最も多い。
◎
If an object represents a list that might change, most often the object should be static. This is so that code iterating over the list doesn’t need to handle the possibility of the list changing in the middle.
</p>

<div class="example">
<p>
`getElementsByTagName()$c は、
~listを表現する~live~objを返す。
作者は、
それを成す各~itemを反復するときに，~careする必要があることを意味する：
◎
getElementsByTagName returns a live object which represents a list, meaning that authors need to take care when iterating over its items:
</p>

<pre class="lang-js">
let %list = document.getElementsByTagName("td");

for (let %i = 0; %i &lt; %list.length; %i++) {
    let %td = %list[%i];
    let %tr = document.createElement("tr");
    %tr.innerHTML = %td.outerHTML;

    /* <span class="comment">
これには %list から `td^e 除去する副作用があり、
反復を予測-不能にする。
◎
This has the side-effect of removing td from the list, causing the iteration to become unpredictable.
</span> */
    %td.parentNode.replaceChild(%tr, %td);
}
</pre>

<p>
`querySelectorAll()＠~DOM4#dom-parentnode-queryselectorall$c
が静的~objを返すようにした選択は、
仕様~策定者が `getElementsByTagName()$c が問題の原因になることに気付いた後に為された。
◎
The choice to have querySelectorAll() return static objects was made after spec authors noticed that getElementsByTagName was causing problems.
</p>

<p>
`URLSearchParams$I は、
~listを表現するが，静的ではない
— それが、
作者が~URLの~query文字列を変更する仕方なので。
◎
URLSearchParams isn’t static, even though it represents a list, because it’s the way for authors to change the query string of a URL.
</p>
</div>

<p class="note">注記：
［
`~maplike$ ／ `~setlike$
］型に対しては、
この助言は適用されないであろう【！may not】
— これらの型は、
反復している間に変更されても，きちんと挙動するよう設計されているので。
◎
Note: For maplike and setlike types, this advice may not apply, since these types were designed to behave well when they change while being iterated.
</p>

<p>
当の~propが［
~accessされた時点で算出するのはアリでない
］場合、
静的~objが［
利用されていない間も，~garbage収集されるまで当の~objを更新し続ける
］必要を避ける。
◎
If it would not be possible to compute properties at the time they are accessed, a static object avoids having to keep the object updated until it’s garbage collected, even if it isn’t being used.
</p>

<p>
静的~objが高頻度に変化し得る状態を表現する場合、
属性として可用にするのではなく，~methodから返すようにするべきである。
◎
If a static object represents some state which may change frequently, it should be returned from a method, rather than available as an attribute.
</p>

<p>
次も見よ
⇒
`§ 属性は~data~propの様に挙動するべきである＠#attributes-like-data$
◎
See also:
• § 6.2 Attributes should behave like data properties
</p>

			</section>
		</section>
		<section id="attributes-vs-methods">
<h3 title="Accessors should behave like properties, not methods">6.4. ~accessorは、~methodではなく~propの様に挙動するべきである</h3>

<p>
~objの［
~prop／取得子
］を述べる~IDL属性は、
~objの状態について情報を生産する。
◎
IDL attributes that describe object properties or getters produce information about the state of an object.
</p>
<ul>
	<li>
取得子は、
（観測-可能な）副作用を伴ってはナラナイ。
副作用が予期される場合、
~methodを利用すること。
◎
A getter must not have any (observable) side effects. If you have expected side effects, use a method.
</li>
	<li>
<p>
取得子は、
例外を投出するベキでない：
◎
Getters should not throw exceptions.＼
</p>
		<ul>
			<li>
取得子は、
`~data~propの様に挙動するべきである＠#attributes-like-data$
— 定例の~data~propが読取られるときは、
例外を投出するべきでない。
◎
Getters should behave like regular data properties, and regular data properties do not throw exceptions when read.＼
</li>
			<li>
妥当でない状態は、
一般に~dataの書込nを却下することにより，避けるベキである
— `読取られる^emときではなく。
◎
Furthermore, invalid state should generally be avoided by rejecting writes, not when data is read.＼
</li>
			<li>
既存の取得子を例外を投出するよう更新することは、
避けるベキである。
既存の~APIの利用者は、
当の~API【の各~取得子の結果】を［
列挙する／包装する
］こともあり，新たな例外を予期しないので、
そうすると，後方-互換性を非互換化することになる。
◎
Updating existing getters to throw exceptions should be avoided as existing API users may enumerate or wrap the API and not expect the new exception, breaking backwards compatibility.
</li>
		</ul>
	</li>
	<li>
取得子は、
他を阻む演算を遂行するベキでない。
ある取得子が，他を阻む演算を遂行することを要求する場合、
~methodにするベキである。
◎
Getters should not perform any blocking operations. If a getter requires performing a blocking operation, it should be a method.
</li>
	<li>
取得子は、
下層の~objが変化するまでの間は，~callされる回ごとに同じ~objを返すべきである。
すなわち、
常に `obj.property === obj.property^c が満たされなければならない。
取得子から毎回~新たな値を返すのは許容されない。
これを満たせない取得子は、
~methodにするべきである。
◎
If the underlying object has not changed, getters should return the same object each time it is called. This means obj.property === obj.property must always hold. Returning a new value from an getter each time is not allowed. If this does not hold, the getter should be a method.
</li>
</ul>

<p class="note">注記：
他を阻む演算を伴う~antipatternを成す例は、
`offsetTop＠~CSSOMVIEW#dom-htmlelement-offsettop$c の様な，
~layoutを遂行する取得子である。
◎
Note: An antipattern example of a blocking operation is with getters like offsetTop performing layout.
</p>

<p>
~IDL属性を定義するときは、
アリなときは，その設定子に与えられた値を取得子から返すために保全すること。
すなわち、
<code>obj.property = %x</code>
に~~後続する
<code>obj.property === %x</code>
は，
~T に評価されるべきである
（このことは
— 例えば，正規化や型~変換の段が必要yな場合など —
常に該当するとは限らないが、
通常の~code~path用には，
目標として保持されるべきである。）
◎
When defining IDL attributes, whenever possible, preserve values given to the setter for return from the getter. That is, given obj.property = x, a subsequent obj.property === x should be true. (This will not always be the case, e.g., if a normalization or type conversion step is necessary, but should be held as a goal for normal code paths.)
</p>

<p>
`~liveな~obj, 静的な~obj＠#live-vs-static$
どちらを返すことも求まれ得る。
このことは、
次を意味する：
◎
The object you want to return may be live or static. This means:
</p>
<ul>
	<li>
~liveである場合、
毎回~同じ~objを返すこと
— ある状態~変化により，異なる~objを返すよう要求されるまでは。
［
~prop, 取得子, ~method
］は、
いずれも，これを返し得る。
◎
If live, then return the same object each time, until a state change requires a different object to be returned. This can be returned from either a property, getter, or method.
</li>
	<li>
静的な場合、
毎回~新たな~objを返すこと。
この事例は、
~methodに限られるべきである。
◎
If static, then return a new object each time. In which case, this should be be a method.
</li>
</ul>

		</section>
		<section id="prefer-dictionaries">
<h3 title="Accept optional and/or primitive arguments through dictionaries">6.5. 省略可能な／~primitiveな引数は辞書を通して受容すること</h3>

<p>
~API~methodは、
一般に，一連の省略可能な引数の代わりに`辞書$引数を利用するべきである。
◎
API methods should generally use dictionary arguments instead of a series of optional arguments.
</p>

<p>
そうすれば、
当の~methodを~callする~codeは より可読になり，
~methodの~signatureも覚え易くなる。
また、
将来に当の~APIを より拡張-可能にする
— 特に，同じ型を伴う複数個の引数が必要になる場合に。
◎
This makes the code that calls the method more readable, and the method signature easier to remember. It also makes the API more extensible in the future, particularly if multiple arguments with the same type are needed.
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-js">
new Event("example", { bubbles: true, cancelable: false})
</pre>

<p>
は、
次よりずっと可読になる：
◎
is much more readable than
</p>

<pre class="lang-js">
new Event("example", true, false)
</pre>
</div>

<p>
義務的な~parameterを辞書を通して受容することも
— そうした方が，当の~APIが可読になるなら —
考慮するベキである
— とりわけ、
それらが~primitive型であるときは。
◎
You should also consider accepting mandatory parameters through a dictionary, if it would make the API more readable, especially when they are of primitive types.
</p>

<div class="example">
<pre class="lang-js">
window.scrollBy({ left: 50, top: 0 })
</pre>

<p>
は、
次より可読になる：
◎
is more readable than
</p>

<pre class="lang-js">
window.scrollBy(50, 0)
</pre>
</div>

<p>
当の`辞書$自身は、
省略可能な引数にするべきである
— 作者が すべて既定の~optionで~~満足な場合、
余分な引数を渡さなくとも済むよう。
◎
The dictionary itself should be an optional argument, so that if the author is happy with all of the default options, they can avoid passing an extra argument.
</p>

<div class="example">
<p>
例えば次は：
◎
For example,
</p>
<pre class="lang-js">
%element.scrollIntoView(false, {});
</pre>

<p>
次と等価になる：
◎
is equivalent to
</p>

<pre class="lang-js">
%element.scrollIntoView(false);
</pre>
</div>

<p>
次も見よ
⇒＃
`Hall of API Shame:Boolean Trap＠https://ariya.io/2011/08/hall-of-api-shame-boolean-trap$en（ “真偽値の罠” ）／
`§ ~methodの引数は、アリなら省略可能にすること＠#optional-parameters$／
`§ 省略可能な引数を適切に命名すること＠#naming-optional-parameters$
◎
See also:
• Hall of API Shame: Boolean Trap.
• § 6.6 Make method arguments optional if possible
• § 6.7 Name optional arguments appropriately
</p>

		</section>
		<section id="optional-parameters">
<h3 title="Make method arguments optional if possible">6.6. ~methodの引数は、アリなら省略可能にすること</h3>

<p>
~API~method用の ある引数に適理な既定の値がある場合、
その引数を省略可能にして，既定の値を指定すること。
◎
If an argument for an API method has a reasonable default value, make that argument optional and specify the default value.
</p>

<div class="example">
<p>
`addEventListener()$c は、
省略可能な真偽値 %useCapture 引数をとる†。
これは、
既定では ~F になり，次を意味する
⇒
~eventは浮上~相において当の~listenerに配送されるべきである
◎
addEventListener() takes an optional boolean useCapture argument. This defaults to false, meaning that the event should be dispatched to the listener in the bubbling phase by default.
</p>

<p class="trans-note">【†
3 個目の引数。
これは，`辞書$もとれるよう拡張されたため、
現在の仕様では %options に改称され，既定では空な辞書になるが、
省略時の結果は ~F を渡したときと同じになる。
】</p>
</div>

<p>
真偽値をとる引数~用には、
既定の値は ~F になることが強く選好される。
◎
For boolean arguments, a default value of false is strongly preferred.
</p>

<div class="example">
<p>
この規則に対する例外として、
`XMLHttpRequest$I 
【の `open()＠~XHR#dom-xmlhttprequest-open-method-url-async-username-password$c ~method 】
に対する 3 個目の省略可能な引数が挙げられる
— それは、
既定では ~T をとる。
その理由は、
旧来との相互運用能にある
— これは、
良い設計を成す例ではない。
◎
The third, optional argument to XMLHttpRequest defaults to true as an exception to this rule. This is for legacy interoperability reasons, not as an example of good design.
</p>
</div>

<p>
既定の値は、
ほとんどの作者が選ぶことになる値が明白ならば，それになるべきである。
真偽-属性~用には、［
当の属性の名前は，共通的な選択が ~F になるよう選ばれる必要がある
］ことを意味するかもしれない。
◎
The default value should be the value that most authors will choose, if that choice is obvious. For boolean attributes, that might mean that the attribute name needs to be chosen so that false is the common choice.
</p>

<p>
当の~APIに用いる~list~data型を裁定するときは、
他が要求されない限り，次に挙げる~list型を利用すること：
◎
When deciding between different list data types for your API, unless otherwise required, use the following list types:
</p>
<ul>
	<li>
~methodの~list引数は、
`連列~型$になるべきである。
◎
Method list arguments should be of type sequence&lt;T&gt;
</li>
	<li>
~methodの返り値は、
`連列~型$になるべきである。
◎
Method return values should be of type sequence&lt;T&gt;
</li>
	<li>
属性は、
`観測-可能な配列~型$になるべきである。
◎
Attributes should be of type ObservableArray&lt;T&gt;
</li>
</ul>

<p>
次も見よ
⇒＃
`§ 省略可能な／~primitiveな引数は辞書を通して受容すること＠#prefer-dictionaries$／
`§ 省略可能な引数を適切に命名すること＠#naming-optional-parameters$／
`真偽値~引数が既定で ~T になる~API＠https://lists.w3.org/Archives/Public/public-script-coord/2013OctDec/0302.html$
◎
See also:
• § 6.5 Accept optional and/or primitive arguments through dictionaries
• § 6.7 Name optional arguments appropriately
• APIs that have boolean arguments defaulting to true
</p>

		</section>
		<section id="naming-optional-parameters">
<h3 title="Name optional arguments appropriately">6.7. 省略可能な引数を適切に命名すること</h3>

<p>
省略可能な引数は、
否定的な名前にしないで，既定の挙動が明白になるよう命名すること。
◎
Name optional arguments to make the default behavior obvious without being named negatively.
</p>

<p>
これは、
`辞書~内に供される＠#prefer-dictionaries$ときも,
`単独の引数として供される＠#optional-parameters$ときも適用される。
◎
This applies whether they are provided in a dictionary or as single arguments.
</p>

<div class="example">
<p>
`addEventListener()$c がとる %options ~objは、
`once＠~DOM4#dom-addeventlisteneroptions-once$c
と命名される~optionを含む。
これは、
当の~event~listenerは，二回以上~呼出される`べきでない^strongことを指示する。
◎
addEventListener() takes an options object which includes an option named once. This indicates that the listener should not be invoked repeatedly.
</p>

<p>
この~optionは
`repeat^c と命名することもできたが、
そうすると，既定の挙動を反映するためには
`既定では ~T になる＠#optional-parameters$
ことを要求することになる。
~API策定者は、
それを否定的な `noRepeat^c と命名せずに `once^c と命名した。
◎
This option could have been named repeat, but that would require the default to be true. Instead of naming it noRepeat, the API authors named it once, to reflect the default behaviour without using a negative.
</p>

<p>
他の例
⇒＃
`passive^c ではなく `active^c ／
`isolate^c ではなく `connect^c ／
`private^c ではなく `public^c
◎
Other examples:
• passive rather than active, or
• isolate rather than connect, or
• private rather than public
</p>
</div>

<p>
次も見よ
⇒
`§ 命名~原則＠#naming-is-hard$
◎
See also:
• § 12 Naming principles
</p>

		</section>
		<section id="overloading">
<h3 title="Use overloading wisely">6.8. 多重定義を賢く利用すること</h3>

<p>
ある~methodの挙動が，渡された引数に依存して有意に異なることになる場合、
通例的には，別々な~methodを定義するベキである
— 単独の~methodを`多重定義-$するのでなく。
◎
If the behaviour of a method will be significantly different depending on the arguments passed you should usually define a separate method rather than overload a single method.
</p>

<p>
~methodの多重定義は、
いずれかの引数が［
1 個の値, 値たちが成す配列
］どちらもとり得るときなどに有用になる。
類似に，~optionたちが成す辞書を渡すことは、
より柔軟性を許容するので，良い~patternである。
◎
Overloading a method such that one of its arguments can be either a single value or an array of values is useful. Similarly, passing a dictionary of options is a good pattern because it allows for more flexibility.
</p>

<p>
しかしながら，ある~methodにおいて［
渡された最初の引数に応じて後続な引数を変更する必要がある場合
］や［
各~入力の型に依存して挙動が異なる場合
］には、
多重定義を避けるベキである
— ~codeの可読性を邪魔して，
作者が~APIの機能性を発見するのが困難になり得るので。
◎
However, if subsequent arguments for a method have to change because of the first argument passed, or if a method has different behaviour depending on the types of inputs, this can hinder code readability, and make discovering API functionality more difficult for authors, and should be avoided.
</p>

		</section>
		<section id="constructors">
<h3 title="Classes should have constructors when possible">6.9. ~classは、アリなときは，構築子を備えるべきである</h3>

<p>
当の~APIの一部を成す~classは、
適切になるなら，構築子を備えるようにすること。
◎
Make sure that any class that’s part of your API has a constructor, if appropriate.
</p>

<p>
`WEBIDL$r `~interface$は，既定では “構築-可能でない” ~classを生成するので、
それらの~instanceを `new X()^c を利用して作成するよう試行すると，
`TypeError$E を投出することになる。
それらは、
次により構築-可能にできる
⇒
当の~interfaceに適切な`構築子~演算$を追加して，
当の~classの新たな~instanceを作成する~algoを定義する
◎
By default, [WEBIDL] interfaces generate "non-constructible" classes: trying to create instances of them using new X() will throw a TypeError. To make them constructible, you can add appropriate constructor operations to your interface, and defining the algorithm for creating new instances of your class.
</p>

<p>
これは、［［
当の~classの~instanceを受容する第三者-主体~library
］とともに［
~testする／模擬する／~interfaceする
］などの目的で，~classの~instanceを作成すること
］を，~JS開発者に許容する。
それは、
当の~classの下位classを作成する能も作者に与える
— 無い場合、
そのような能は，~JSが下位classを取扱う仕方により防止される。
◎
This allows JavaScript developers to create instances of the class for purposes such as testing, mocking, or interfacing with third-party libraries which accept instances of that class. It also gives authors the ability to create a subclass of the class, which is otherwise prevented, because of the way JavaScript handles subclasses.
</p>

<p>
これが適切にならない事例もある
— 例えば：
◎
This won’t be appropriate in all cases. For example:
</p>
<ul>
	<li>
一部の~objは，特権的な資源への~accessを表現するので、
そのような資源へ~accessできる~factory~methodにより構築される必要がある。
◎
Some objects represent access to privileged resources, so they need to be constructed by factory methods which can access those resources.
</li>
	<li>
一部の~objは，その~lifecycleがとても注意深く制御されるので、
特定の~methodを通して作成され, ~accessされる必要がある。
◎
Some objects have very carefully controlled lifecycles, so they need to be created and accessed through specific methods.
</li>
	<li>
一部の~objは，抽象-基底~classを表現するので、
構築されるべきでなく，作者は それ用の下位classを定義-可能になるべきでない。
◎
Some objects represent an abstract base class, which shouldn’t be constructed, and which authors should not be able to define subclasses for.
</li>
</ul>

<div class="example">
`Event$I ~class, および その派生~interfaceは、
すべて構築-可能である。
これは、
~eventを取扱う~codeを~testするときに有用になる。
作者は、
`Event$I を構築して，その型の~eventを取扱う~methodに渡せる。
◎
The Event class, and all its derived interfaces, are constructible. This is useful when testing code which handles events: an author can construct an Event to pass to a method which handles that type of event.
</div>

<div class="example">
`Window$I ~classは構築-可能でない
— 新たな~windowを作成することは、
有意な副作用を伴う特権的な演算なので。
新たな~windowを作成するときは、
代わりに，
`window.open()＠~WINDOW#dom-window-open$c
~methodが利用される。
◎
The Window class isn’t constructible, because creating a new window is a privileged operation with significant side effects. Instead, the window.open() method is used to create new windows.
</div>

<div class="example">
`ImageBitmap$I ~classは構築-可能でない
— それは変異-不能な, 塗り用に準備済みな~bitmap画像を表現するが、
塗り用に準備済みになる処理nは，非同期的に行わなければナラナイので。
それを作成するときには、
代わりに
`createImageBitmap()＠~HTMLGAPI#dom-createimagebitmap$c
~factory~methodが利用される。
◎
The ImageBitmap class isn’t constructible, as it represents an immutable, ready-to-paint bitmap image, and the process of getting it ready to paint must be done asynchronously. Instead, the createImageBitmap() factory method is used to create it.
</div>

<div class="example">
`DOMTokenList$I ~classは、
残念なことだが，
`構築-可能でない＠https://www.w3.org/Bugs/Public/show_bug.cgi?id=27114$。
そのため，`~custom要素＠~HEcustom#custom-element$は、［
自身の~token~list属性を `DOMTokenList$I として公開する
］ように作成できなくなっている。
◎
The DOMTokenList class is, sadly, not constructible. This prevents the creation of custom elements that expose their token list attributes as DOMTokenLists.
</div>

<div class="example">
<p>
構築-可能でない~class
— 例： `Navigator$I, `History$I, `Crypto$I —
が構築-可能でないのは、
それらが，各~windowごとに その情報への~accessを表現している~singletonだからである
【すなわち，~windowごとに 1 個しかない】。
これらの特能は、
~Web~IDLの`名前空間$の様な特能の方が，もっと良く収まったかもしれないが、
名前空間より前に設計されたものであり，現在では名前空間でアリになるものを超えている。
◎
Several non-constructible classes, like Navigator, History, or Crypto, are non-constructible because they are singletons representing access to per-window information. In these cases, something like the Web IDL namespace feature might have been a better fit, but these features were designed before namespaces, and go beyond what is currently possible with namespaces.
</p>

<p>
当の~APIが この型の~singletonを要求する場合、
`名前空間$の利用を考慮すること
— そうすると何か問題がある場合は、
`~Web~IDLに課題を申請すること＠https://github.com/whatwg/webidl/issues/new$。
◎
If your API requires this type of singleton, consider using a namespace, and File an issue on Web IDL if there is some problem with using them.
</p>
</div>

<p>
~factory~methodは，構築子を補うものになり得るが、
一般に，構築子の`代わり^emとして利用されるべきでない。
それでも，構築子に加えて~factory~methodを含めることは、
追加的な便益を供するなら価値をもたらし得る。
そのような共通的な事例は、
~APIが ある基底~class, 複数個の特化された下位classを含んでいて，［
渡された~parameterに基づいて適切な下位classを作成する
］ための~factory~methodを伴うときである。
~factory~methodは、［
返される結果に共通かつ最も近い基底~下位class
］上の静的~methodになることが多い。
◎
Factory methods can complement constructors, but generally should not be used instead of them. It may still be valuable to include factory methods in addition to constructors, when they provide additional benefits. A common such case is when an API includes base classes and multiple specialized subclasses, with a factory method for creating the appropriate subclass based on the parameters passed. Often the factory method is a static method on the closest common base subclass of the returned result.
</p>

<div class="example">
`createElement()＠~DOM4#dom-document-createelement$c
~methodは、
構築子として実装し得なかった~factory~methodを成す例である
— その結果は、
いくつかある `Element$I の下位classのどれもあり得るので。
◎
The createElement method is an example of a factory method that could not have been implemented as a constructor, as its result can be any of a number of subclasses of Element.
</div>

<div class="example">
`MouseEvent$I の非推奨にされた~factory~method `initMouseEvent()＠~UIEVENTS-A#dom-mouseevent-initmouseevent$c は、
`MouseEvent$I ~objのみを作成する。
それは、
元々は
— 技術的な理由は無かったにもかかわらず —
構築-可能でなかった。
この~methodは，最終的には非推奨にされ、
`MouseEvent$I ~objは単純に構築-可能にされた。
◎
The deprecated MouseEvent.initMouseEvent() factory method only creates MouseEvent objects, which were originally not constructible, even though there was no technical reason against that. Eventually it was deprecated, and the MouseEvent object was simply made constructible.
</div>

		</section>
		<section id="synchronous">
<h3 title="Be synchronous when appropriate">6.10. 適切なときは同期的にすること</h3>

<p>
新たな~APIを設計するときは、
アリな所では，同期的な~APIを選好すること。
同期的な~APIを利用する方が単純であり、
設定しておく必要な基盤（関数を `async^c にするなど）も少なくなる。
◎
Where possible, prefer synchronous APIs when designing a new API. Synchronous APIs are simpler to use, and need less infrastructure set-up (such as making functions async).
</p>

<p>
一般に~APIは、
次に挙げる~~経験則が適用される場合には，同期的にするべきである：
◎
An API should generally be synchronous if the following rules of thumb apply:
</p>
<ul>
	<li>
~APIは、
許可~promptや装置~選定器などの~dialogの背後で通過制御されるものと期待されてはいない。
◎
The API is not expected to ever be gated behind a permission prompt, or another dialog such as a device selector.
</li>
	<li>
~APIの実装は、［
~lock／~filesystem／~network~access
］
— 例えば，~process間の通信 —
により阻止されない。
◎
The API implementation will not be blocked by a lock, filesystem or network access, for example, inter-process communication.
</li>
	<li>
実行~時間は、
短くかつ決定的である。
◎
The execution time is short and deterministic.
</li>
</ul>

		</section>
		<section id="promises">
<h3 title="Design asynchronous APIs using Promises">6.11. 非同期的な~APIは~Promiseを利用して設計すること</h3>

<p>
~API~methodを非同期的にする必要がある場合、
~callback関数ではなく，~Promiseを利用すること。
◎
If an API method needs to be asynchronous, use Promises, not callback functions.
</p>

<p>
~web~platform~~全般に一貫して~Promiseを利用することは、
~promiseを連鎖するなど，~APIを他と一緒に利用するのも より容易になることを意味する。
また，~promiseを利用している~codeの方が、
~callback関数を利用している~codeより容易に理解できる傾向にある。
◎
Using Promises consistently across the web platform means that APIs are easier to use together, such as by chaining promises. Promise-using code also tends to be easier to understand than code using callback functions.
</p>

<p>
次に挙げるいずれかに該当する場合、
~APIは非同期的になる必要があるかもしれない：
◎
An API might need to be asynchronous if:
</p>
<ul>
	<li>
~UAが利用者に`許可＠#user-decisions$を~promptする必要があるとき。
◎
the user agent needs to prompt the user for permission,
</li>
	<li>
何らかの情報を［
~diskから読取る／~networkへ要請する
］必要があるかもしれないとき。
◎
some information might need to be read from disk, or requested from the network,
</li>
	<li>
~UAは、
結果を返す前に別の［
~thread上で／~process内で
］有意な量の作業を行う必要もあるとき。
◎
the user agent may need to do a significant amount of work on another thread, or in another process, before returning the result.
</li>
</ul>

<p>
次も見よ
⇒
`~Promiseを利用する仕様の書法＠~PROMISES$
◎
See also:
• Writing Promise-Using Specifications
</p>

			<section id="sync-callbacks">
<h4 title="When to use callback functions">~callback関数をいつ利用するか</h4>

<p>
同期的な~callbackは、
即時な応答が必要なときに限り，利用すること。
◎
Use synchronous callbacks only when an immediate response is needed.
</p>

<p>
ときには，~APIにおいて同期的な動作が必要になる
— 特に，待時間に敏感な動作を孕む所では。
例えば、
~browserは，~event浮上が完遂した直後に続行する方法を知る必要がある一方で、
~media処理は，次回の~task境界まで常に待機するとは限らない。
同期的な動作は、
~Promiseでは~model化し得ない。
代わりに，明示的な［
~callback／~event
］を利用すること。
◎
Synchronous actions are sometimes needed in APIs, particularly where there are latency-sensitive actions involved. For example, browsers need to know how to proceed immediately after an event finishes bubbling, and media processing can’t always wait for the next task boundary. Synchronous actions cannot be modeled with a Promise. Instead, use an explicit callback or event.
</p>

<p>
`~Promise反応~callback＠~TC39M/control-abstraction-objects.html#sec-promisereaction-records$においては、
動作を決まった個数以内の小taskの中で行うよう要求できない。
これは、
~promise構成を保護する：
［
補助~関数／何かを~logすること／ `Promise.race()^c ／複数個の `.then()^c 分岐
］を包装している `await^c の様な~patternは、
すべて，加的な小taskを~queueする
— それらが包装する~codeの挙動を有意に変更してはナラナイ。
◎
In Promise reaction callbacks, you may not require action within a fixed number of microtasks.
◎
This protects Promise composition: patterns like await, wrapping helper functions, logging, Promise.race(), or multiple .then() branches all queue an extra microtask and must not significantly change the behavior of the code they wrap.
</p>

<div class="example">
~event~handlerは、
同期的に呼出され, 取消される。
開発者が給した~codeが［
`Event$I の `preventDefault()＠~DOM4#dom-event-preventdefault$c を~call可能にする／
`FetchEvent$I の `respondWith()＠~SW1#dom-fetchevent-respondwith$c で応答~objを選べるようにする
］必要がある場合、
~callbackが必要になる
— `Promise.then()＠~TC39M/control-abstraction-objects.html#sec-promise.prototype.then$c へ渡された反応ではなく。
◎
Event handlers are invoked and cancelled synchronously. If developer-supplied code needs to be able to call event.preventDefault() or choose a response object with fetchEvent.respondWith(), it needs to be a callback rather than a reaction passed to Promise.then().
</div>

<div class="example">
<p>
`CaptureController$I の `setFocusBehavior()＠~MCSS#dom-capturecontroller-setfocusbehavior$c ~methodは、
~eventを伴わない例であり，
利用者が~screenを捕捉するために選んだ~windowを前面へ~pushする。
~appは、
これ【~focusの挙動？】を選ばれた~windowに基づいて裁定できる。
難題は、
遅延を許容すると，~siteによる~click乗取り攻撃の機会を作成することである。
◎
A non-event example is the captureController.setFocusBehavior() method, which pushes a window the user has chosen to screen-capture to the front. Applications can decide this based on the window chosen. The challenge is that allowing delay creates an opportunity for click-jacking attacks from sites.
</p>

<p>
その解決策は、
当の~methodが［
`getDisplayMedia()＠~MCSS#dom-mediadevices-getdisplaymedia$c からの~promiseを成す反応~小task上で同期的に~callされる
］よう要求する代わりに［
同じ~promise反応~task上で
— 制限時間 1 秒を伴って —
~callされる
］よう要求することであった。
◎
Instead of requiring the method be called synchronously on the reaction microtask of the promise from getDisplayMedia(), the solution was to instead require the method be called on the same promise reaction task, with a one second timeout.
</p>
</div>

			</section>
		</section>
		<section id="aborting">
<h3 title="Cancel asynchronous APIs/operations using AbortSignal">6.12. 非同期的な~APIや演算を取消すときは `AbortSignal^I を利用すること</h3>

<p>
非同期的な~methodが取消され得る場合、［
~option群を成す`辞書$の一部として `AbortSignal$I を渡す
］ことを作者に許容すること。
◎
If an asynchronous method can be cancelled, allow authors to pass in an AbortSignal as part of an options dictionary.
</p>

<div class="example">
<pre class="lang-js">
const %controller = new AbortController();
const %signal = %controller.signal;
geolocation.read({ %signal });
</pre>
</div>

<p>
非同期的な演算を取消す仕方として， `AbortSignal^I を一貫して利用すれば、
作者は，~codeをもっと単純に書せるようになる。
◎
Using AbortSignal consistently as the way to cancel an asynchronous operation means that authors can write less complex code.
</p>

<p>
例えば，次のような~patternがある
⇒
同じ `AbortSignal^I を何個かの進行中な演算に利用した上で，必要yな場合は
（利用者から取消すよう要請されたときや，単-~page~appにおいて~naviが生じたときなど）、
対応する `AbortController$I を利用して，すべての演算を まとめて取消すなど。
◎
For example, there’s a pattern of using a single AbortSignal for several ongoing operations, and then using the corresponding AbortController to cancel all of the operations at once if necessary (such as if the user presses "cancel", or a single-page app navigation occurs.)
</p>

<p>
`AbortController$I は、
取消nが保証できない場合でも利用できる
— その `abort()＠~DOM4#dom-abortcontroller-abort$c ~methodの~callは、
保証ではなく要請なので。
◎
Even if cancellation can’t be guaranteed, you can still use an AbortController, because a call to abort() on AbortController is a request, rather than a guarantee.
</p>

		</section>
		<section id="string-constants">
<h3 title="Use strings for constants and enums">6.13. 定数や列挙d値には文字列を利用すること</h3>

<p>
［
定数／列挙d値たちが成す集合
］には、
文字列~値を利用すること
— 文字列を選ぶ際には、
`§ 命名~原則＠#naming-is-hard$を見よ。
◎
Use strings as the values for constants or sets of enumerated values. See § 12 Naming principles when choosing strings.
</p>

<p>
文字列の方が，開発者にとって検分するのは容易になる。
~JS~engineにおいても，文字列の代わりに整数を利用しても処理能の便益は無い。
~Web~IDL`列挙~型$は、
この原則に従うため，文字列を値にとる。
◎
Strings make it easier for developers to inspect values and read code that uses those values. In JavaScript engines there is no performance benefit to using integers instead of strings. The values of a WebIDL enum type are strings in order to follow this principle.
</p>

<p>
状態を~propの組合nで表出する必要がある場合、
代わりに辞書~objを利用すること
— 別の言語では、
~bitmaskとして表出されることもあろうが。
この~objは、
単独の~bitmask値と同じくらい容易に受け渡せる。
◎
If you need to express a state which is a combination of properties, which might be expressed as a bitmask in another language, use a dictionary object instead. This object can be passed around as easily as a single bitmask value.
</p>

<div class="example">
専用~worker（ `Worker$I ）の種別は、
`WorkerType$I 型の列挙d引数を利用して設定される。
これがとり得る値は 2 個あり（ `classic^l, `module^l ）、
代わりに，真偽値が利用されたかもしれない。
が、
文字列を利用する~costは無いに等しく，そうする方が~codeは明瞭になる。
◎
The type of a dedicated Worker is set using an enumerated WorkerType argument. This has two values ("classic" and "module") and might have used a Boolean type instead. The use of strings costs nothing and makes code clearer.
</div>

<div class="example">
`XMLHttpRequest$I の `readyState＠~XHR#dom-xmlhttprequest-readystate$c 取得子は、
整数をとる列挙d値を返す。
したがって、
この~APIを利用する~codeを読者が理解するためには，
当の~APIに馴染みであることが要求される。
◎
The XMLHttpRequest readyState getter returns an enumerated integer value. Code that uses this API therefore requires that readers are familiar with the API to understand it.
</div>

		</section>
		<section id="async-by-default">
<h3 title="If you need both asynchronous and synchronous methods, synchronous is the exception">6.14. 非同期的, 同期的どちらの~methodも必要な場合、同期的な方を例外とすること</h3>

<p>
稀な事例では、
同じ目的に［
同期的, 非同期的
］どちらの~methodも必要になる
— その場合、
非同期的な方を既定として，同期的な方は例外とすること。
◎
In the rare case where you need to have both synchronous and asynchronous methods for the same purpose, default to asynchronous and make synchronous the exception.
</p>

<p>
~web~platformの一部を成す特定の分野は、
現在の制限に因り，非同期的な~supportを欠如している。
したがって、［
非同期的な~methodに加えて，同期的な~method用の~supportを備える
］ことは，利便性に有益になり得る。
これらの事例は例外であり、
同期的な~methodは，~web~platformの能力が発展するに伴って非推奨にされる明瞭な道があると見なすこと。
◎
Due to current limitations, some specific areas of the web platform lack asynchronous support. Therefore having support for synchronous methods in addition to asynchronous methods can be beneficial for usability. Consider these cases an exception, and have a clear path for deprecation of the synchronous methods as web platform capabilities evolve.
</p>

<p>
ほとんどの事例では、
同期的な変種は，
`Sync()^c 接尾辞を伴うよう命名することにより判別されるベキである。
◎
For most cases, the synchronous variant should be distinguished by naming it with a Sync() suffix.
</p>


<div class="example">
<p>
例えば，
`Web Neural Network API＠https://github.com/w3ctag/design-reviews/issues/771$cite
は、
~platform制限に対処するため，
`両~事例とも＠https://github.com/webmachinelearning/webnn/issues/272$
~supportする必要があった
— それは、
非同期的な方を規範にする一方で，同期的な方を例外にした。
◎
For example, the Web Neural Network API needed to support both cases to work around a platform limitation, and made asynchronous the norm while making synchronous the exception.
</p>
</div>

<p class="note">注記：
現時点で，これが適用-可能な周知な事例として，
~JSと~WASMの境界をまたぐ設計が挙げられる
— 現今では、
`Promise integration＠https://github.com/WebAssembly/js-promise-integration/blob/main/proposals/js-promise-integration/Overview.md$cite
（~promiseの統合）は，依然として開発~下にあるので。
◎
At the moment, one well-known case where this is applicable is when a design has to cross boundaries between JavaScript and WASM, as the Promise integration is still under development as of today.
</p>

		</section>
		<section id="uint8array">
<h3 title="Output an array of bytes with Uint8Array">6.15. ~byteたちが成す配列は `Uint8Array^c で出力すること</h3>

<p>
~APIが~byte配列を返す場合、
それを `ArrayBuffer$c ではなく `Uint8Array$c にすること。
◎
If an API returns a byte array, make it a Uint8Array, not an ArrayBuffer.
</p>

<p>
`ArrayBuffer^c からは直に読取れないので、
開発者は，~dataを読取るために `Uint8Array^c などの~viewを作成する必要がある。
`Uint8Array^c を供すれば，そのような追加的な労は避けられる。
◎
ArrayBuffers cannot be read from directly; the developer would have to create a view such as a Uint8Array to read data. Providing a Uint8Array avoids that additional effort.
</p>

<p>
~buffer内の~byte列には，他の いずれかの`有型~配列~型$【！ `TypedArray^jT 型】として自然な解釈【！intepretation】がある場合、
代わりに，それを供すること。
例えば，~byte列が `float$c【！`Float32^c】 値たちを表現する場合、
`Float32Array$c を利用すること。
◎
If the bytes in the buffer have a natural intepretation as one of the other TypedArray types, provide that instead. For example, if the bytes represent Float32 values, use a Float32Array.
</p>

		</section>
		<section id="void-functions">
<h3 title="Return undefined from side-effect-causing functions">6.16. 目的が副作用にある関数からは `undefined^c を返すこと</h3>

<p>
ある関数の目的が，値を算出することではなく副作用にあるときは、
当の関数は， `undefined$c を返すよう指定するべきである。
◎
When the purpose of a function is to cause side effects and not to compute a value, the function should be specified to return undefined.
</p>

<p>
各~siteが［
そのような返り値に依存するようになる
］ことは，ほぼ見込まれないので、
将来に［
ある返り値~用の利用事例が発見された
］とき［
当の関数が有意義な値を返すよう変更を為す
］ことは，より容易になる。
◎
Sites are unlikely to come to depend on such a return value, which makes it easier to change the function to return a meaningful value in the future should a use case for one be discovered.
</p>

<div class="example">
<p>
`HTMLMediaElement$I の `play()＠~HEmedia#dom-media-play$c ~methodは、
元々は `undefined$c を返すものと定義された
— その目的は、
当の~media要素の状態を変更することであったので。
◎
HTMLMediaElement’s play() method was originally defined to return undefined, since its purpose was to change the state of the media element.
</p>

<p>
~mediaを再生する要請は、
いくつかの仕方で失敗し得る
— なので、
`play()^c は `Promise$c を返すよう`変更された＠~HTMLissue/505$。
この~APIが，元々は `undefined$c 以外の何かを返すよう定義されていたならば
（例えば、
当の~media要素を返すものと
— ~APIを【 `foo().bar().baz()^c の様に】 “連鎖する” 普及な~patternを可能にするために —
定義された場合）、
この~APIの利便性をこの方式で増強すると，後方-互換にならなくなったであろう。
◎
Requests to play media can fail in a number of ways, so play() was changed to return a Promise. If the API had originally been defined to return something other than undefined (for example, if it had been defined to return the media element, a popular pattern in “chaining” APIs), it would not have been backwards compatible to enhance the usability of this API in this manner.
</p>
</div>

<p>
次も見よ
⇒＃
`~commandと~queryの分離（ Wikipedia ）＠https://en.wikipedia.org/wiki/Command–query_separation$
◎
See also:
• Command–query separation on Wikipedia
</p>

		</section>
		<section id="prefer-existing-task-sources">
<h3 title="Prefer existing task sources">6.17. 既存の~task~sourceを選好すること</h3>

<p>
何かを配送している作業~用には、
アリな所では，既存の`~task~source$を利用すること。
◎
Use existing task sources for dispatching work where possible.
</p>

<p>
新たな`~task~source$を作成することは、
明瞭な理由があるときに限ること。
各~仕様は，
互いに関係する作業（または “`~task$” ）を`~task~source$を利用して~group化するので、
~UAは，それらを~~合理的に~scheduleできる。
~taskは，ある~task~source上に~queueされ、
各~task~sourceは，`~event~loop$用の ある~task~queueに結付けられる。
同じ~task~sourceの中では、
~UAが次回にどの~queueを~serviceするか選ぶ間も，
順序は保証される。
◎
Only create a new task source when there is a clear reason to do so. Specs use task sources to group related work (or "tasks") so UAs can schedule them sensibly. A task is queued on a task source, and each task source is associated with a task queue for an event loop. Order is guaranteed within a source, while the UA chooses which queue to service next.
</p>

<p>
アリなときは、［
汎用な／~~既存の
］~task~sourceを利用すること。
~HTMLは、
`各種 汎用な~task~source＠~WAPI#generic-task-sources$を定義する
— それらは、
各~仕様に またがって広く再利用するために意味され，［
`~DOM操作~task~source＠~WAPI#dom-manipulation-task-source$,
`利用者ヤリトリ~task~source＠~WAPI#user-interaction-task-source$,
`~network用~task~source＠~WAPI#networking-task-source$,
その他
］を含む。
当の特能が，これらの分類を成すいずれかに合致する場合、
新たなものを作成することなく，
その~task~source上に~queueすること。
そうすることは、
~platformにまたがる［
相互運用能, 予測-能, 処理能の~schedule法
］を改善する。
◎
Use the generic or preexisting task sources whenever possible. HTML defines generic task sources meant for broad reuse across specs. This includes, but is not limited to: the DOM manipulation task source, the user interaction task source, and the networking task source. If your feature matches one of these categories, queue on that source rather than creating a new one. Doing so improves interoperability, predictability, and performance scheduling across the platform.
</p>

<p>
~task~sourceを追加することには、
すべての~browser実装が支払う［
処理能, 複階性
］の~costがかかる。
新たな~task~sourceを創出することは，
具象的かつ~test可能な必要があるときに限ること。
例えば，当の特能の［
計時／実行
］~modelが汎用な~task~sourceからは隔離されなければならないとき
（例：
`~media要素＠~HEmedia#media-element$は、［
復号器／時列線
］の意味論に倣うため，自前の`~media要素~event~task~source＠~HEmedia#media-element-event-task-source$を取得する）。
◎
Adding a task source has performance and complexity costs that all browser implementations pay. Only mint a new task source when you have a concrete, testable need. For example, when the feature’s timing/execution model must be isolated from the generic task sources (e.g., media elements get their own media element event task source to align with decoder/timeline semantics).
</p>

<p>
仕様を書するときは：
◎
When writing a spec,＼
</p>
<ul>
	<li>
~HTMLの【~taskを~queueする~algoを】包装する~algo
（`大域~taskを~queueする$, `要素~taskを~queueする$）
を選好すること。
◎
prefer HTML’s wrapper algorithms (queue a global task, queue an element task)＼
</li>
	<li>
特定0の`~event~loop$に依拠することは、
避けること。
◎
and avoid relying on a particular event loop.＼
</li>
	<li>
~event~loopについて明示的になるのは、
適切なときに限ること
（ `§ ~eventの設計＠#event-design$ も見よ）。
◎
And only be explicit about the event loop when appropriate (see also § 7 Event Design).
</li>
</ul>

		</section>
	</section>
	<section id="event-design">
<h2 title="Event Design">7. ~eventの設計</h2>

		<section id="one-time-events">
<h3 title="Use promises for one time events">7.1. 一度限りの~event用には~promiseを利用すること</h3>

<p>
<strong>
`~promiseを利用している仕様の書法＠~PROMISES$
</strong>
指針における`助言＠~PROMISES#one-time-events$に従うこと。
◎
Follow the advice in the Writing Promise-Using Specifications guideline.
</p>

		</section>
		<section id="promises-and-reaction">
<h3 title="Don’t use promises for cancelable events">7.2. 取消~可能な~event用には~promiseを利用しないこと</h3>

<p>
`§ ~callback関数をいつ利用するか＠#sync-callbacks$
を見よ。
◎
See when to use callback functions instead.
</p>
		</section>
		<section id="promises-and-events">
<h3 title="Events should fire before related Promises resolve">7.3. ~eventは関係する~promiseを解決する前に発火するべきである</h3>

<p>
~Promiseに基づく非同期的な~algoが ある~event %~event を配送する場合、
当の~Promise %~promise を解決した後ではなく，解決する前に配送するべきである：
◎
If a Promise-based asynchronous algorithm dispatches events, it should dispatch them before the Promise resolves, rather than after.
</p>

<p>
%~promise が解決されるときは、
その反応~callback %~callback を走らすための`小task$ %小task が~queueされる。
%小task は、
~JS~stackを空にするとき処理される。
`~eventの配送-法＠~DOM4#dispatching-events$は、
同期的であり，各~listener【に対する~call】の合間に~JS~stackを空にすることを孕む。
よって、
%~event を配送する前に %~promise を解決した場合，
%小task は %~event 用の 1 個目の~listenerと 2 個目の~listenerの合間に呼出されることになる。
◎
When a promise is resolved, a microtask is queued to run its reaction callbacks. Microtasks are processed when the JavaScript stack empties. Dispatching an event is synchronous, which involves the JavaScript stack emptying between each listener. As a result, if a promise is resolved before dispatching a related event, any microtasks that are scheduled in reaction to a promise will be invoked between the first and second listeners of the event.
</p>

<p>
初めに %~event を配送するようにしておけば、
%小task が そのように差挟まれることは防止され，
すべての~event~listenerは， %~callback より前に呼出されるようになる。
◎
Dispatching the event first prevents this interleaving. All event listeners are then invoked before any promise reaction callbacks.
</p>

		</section>
		<section id="dont-invent-event-like">
<h3 title="Don’t invent your own event listener-like infrastructure">7.4. 自前の~event~listenerの様な基盤を考案しないこと</h3>

<p>
通知を生成することで，ある処理nを［
開始する／停止する
］ことを作者に許容する~APIを作成しているときは、
既存の~event基盤を利用して，通知を~listenするのを許容すること。
下層の処理nを［
開始する／停止する
］ための制御~用には、
別々な~APIを作成すること。
◎
When creating an API which allows authors to start and stop a process which generates notifications, use the existing event infrastructure to allow listening for the notifications. Create separate API controls to start/stop the underlying process.
</p>

<div class="example">
<p>
例えば，~Web~Bluetooth~APIは、
`BluetoothRemoteGATTCharacteristic^I 大域~obj上に `startNotifications()^c ~methodを供する
— それは、
“作動中な通知~文脈~集合” に当の~objを追加する。
◎
For example, the Web Bluetooth API provides a startNotifications() method on the BluetoothRemoteGATTCharacteristic global object, which adds the object to the "active notification context set".
</p>

<p>
~UAは、
~Bluetooth装置からある通知を受信したとき，
“作動中な通知~文脈~集合” を成す各 `BluetoothRemoteGATTCharacteristic^I ~objに向けて~eventを発火することになる。
◎
When the User Agent receives a notification from the Bluetooth device, it fires an event at the BluetoothRemoteGATTCharacteristic objects in the active notification context set.
</p>
</div>

<p>
次も見よ
⇒＃
`§ 通知~用には~eventを利用すること＠#events-are-for-notification$／
`§ ~eventか観測器か適切な方を利用すること＠#events-vs-observers$／
<a href="#state-and-subclassing">§ 状態は `Event^I ~objではなく `target^c ~objに置くこと</a>
◎
See:
• § 7.6 Use events for notification
• § 7.9 Use Events and Observers appropriately
• § 7.8 Put state on target objects rather than Events
</p>

		</section>
		<section id="always-add-event-handlers">
<h3 title="Always add event handler attributes">7.5. 常に~event~handler属性を追加すること</h3>

<p>
当の~APIが新たな~event型を追加する場合、
それを取扱うであろう各 `EventHandler$I の~interfaceにも，
対応する`~event~handler~IDL属性$を
— 当の~event型が `foo^et ならば `onfoo^c を —
追加すること。
◎
If your API adds a new event type, add a corresponding onyourevent event handler IDL attribute to the interface of any EventHandler which may handle the new event.
</p>

<p>
~event~handler~IDL属性を定義し続けることは、
次に挙げることから重要になる：
◎
it’s important to continue to define event handler IDL attributes because:
</p>
<ul>
	<li>
~platformにおける一貫性を保全する。
◎
they preserve consistency in the platform
</li>
	<li>
~supportされる~event用の特能~検出を可能化する
（`§ 新たな特能は検出-可能になるべきである＠#feature-detect$ を見よ）。
◎
they enable feature-detection for the supported events (see § 2.6 New features should be detectable)
</li>
</ul>

<p class="note">注記：
一貫性を得るため、
当の~eventが［
~HTML／~SVG
］要素により取扱われる必要がある場合には，
当の`~event~handler~IDL属性$を
`GlobalEventHandlers$I ~interface~mixinに追加すること
— 関連な要素~interface（たち）に直に追加するのではなく。
類似に，
`Window$I により取扱われる必要がある場合には，
当の`~event~handler~IDL属性$を
`WindowEventHandlers$I に追加すること。
◎
For consistency, if the event needs to be handled by HTML and SVG elements, add the event handler IDL attributes on the GlobalEventHandlers interface mixin, instead of directly on the relevant element interface(s). Similarly, add event handler IDL attributes to WindowEventHandlers rather than Window.
</p>

		</section>
		<section id="events-are-for-notification">
<h3 title="Use events for notification">7.6. 通知~用には~eventを利用すること</h3>

<p>
~eventは、
変更を誘発するために利用されるべきでない。
~eventは、［
変化が起きたことは，すでに完遂したこと
］の通知を送達するために限られる。
◎
Events shouldn’t be used to trigger changes, only to deliver a notification that a change has already finished happening.
</p>

<div class="example">
<p>
~UIwindowが~resizeされたとき，当の `Window^I ~objに向けて名前 `resize＠~CSSOMVIEW#eventdef-window-resize$et の~eventが発火される。
◎
When a window is resized, an event named resize is fired at the Window object.
</p>

<p>
当の~eventを横取りしても，~resizeが起こるのを停止するのはアリでない。
当の~UIwindowの~sizeを変更するよう構築された `resize^et ~eventを発火するのもアリでない。
この~eventは、
~resizeがすでに起きたことを作者に通知することしかできない。
◎
It’s not possible to stop the resize from happening by intercepting the event. Nor is it possible to fire a constructed resize event to cause the window to change size. The event can only notify the author that the resize has already happened.
</p>
</div>

		</section>
		<section id="guard-against-recursion">
<h3 title="Guard against potential recursion">7.7. 再帰の能性に抗して防護すること</h3>

<p>
当の~APIが［
長く走る／複雑な
］~algoを含む場合、
それが走っている間は，当の~algoの中へ~callするのを防止すること。
◎
If your API includes a long-running or complicated algorithm, prevent calling into the algorithm if it’s already running.
</p>

<p>
ある~API~methodが，長く走る~algoを始める原因になる場合、
`通知~用の~event＠#events-are-for-notification$を利用して，
当の~algoの進捗を利用元~codeに通知するべきである。
しかしながら、
当の~eventを取扱う利用元~codeは，同じ~API~methodを~callし得るので、
複階的な~algoを再帰的に走らす原因になる
— それは、
同じ~eventを再び発火し得るので，同じ~event~handlerを発火する原因になり, 以下同様に続く。
◎
If an API method causes a long-running algorithm to begin, you should use events to notify user code of the progress of the algorithm. However, the user code which handles the event may call the same API method, causing the complex algorithm to run recursively. The same event may be fired again, causing the same event handler to be fired, and so on.
</p>

<p>
これを防止するため、
当の~API~methodの中への “再帰的な” ~callは，
単純に即時に【すなわち，何もせずに】返るようにすること。
この技法は、
~algoの “防護-法（ `guarding^en ）” と称される。
◎
To prevent this, make sure that any "recursive" call into the API method simply returns immediately. This technique is "guarding" the algorithm.
</p>

<div class="example">
<p>
`AbortSignal$I 用の［
`通達に~algoを追加する$／
`通達から~algoを除去する$／
`中止-を通達する$aC
］手続きは、
どれも，当の通達は`中止-済み$aBか否か検査する所から始まる。
中止されていた場合、
当の~algoは，それ以降を走らすことなく終える。
◎
AbortSignal’s add, remove and signal abort each begin with a check to see if the signal is aborted. If the signal is aborted, the rest of the algorithm doesn’t run.
</p>

<p>
この事例では、
重要な複階性の多くは，`中止-を通達する$aC間に走らす~algo内にある。
この手続きは、
【！collection of algorithms】`中止する~algo群$aBを反復する
— それらは、［
`通達に~algoを追加する$,
`通達から~algoを除去する$
］~algo【！add and remove method】により管理される。
◎
In this case, a lot of the important complexity is in the algorithms run during the signal abort steps. These steps iterate through a collection of algorithms which are managed by the add and remove methods.
</p>

<p>
例えば，
`ReadableStreamPipeTo＠~STREAMS#readable-stream-pipe-to$A
の定義は、
当の~algoを `AbortSignal$I の`中止する~algo群$aBに`追加する＠~DOM4#abortsignal-add$
— それが走るのは、
当の通達を結付けている `AbortController$I の
`abort()＠~DOM4#dom-abortcontroller-abort$c
を~callすることにより，
`中止-を通達する$aC手続きが誘発されるときである。
◎
For example, the ReadableStreamPipeTo definition adds an algorithm into the AbortSignal’s set of algorithms to be run when the signal abort steps are triggered, by calling abort() on the AbortController associated with the signal.
</p>

<p>
この~algoは、
~promiseを解決して，~codeを走らす原因になる見込みが高い
— その~codeは、
`AbortSignal$I の~methodを~callするよう試みる何かを含み得る。
`中止-を通達する$aC手続きは，【！collection of algorithms】`中止する~algo群$aBを反復することを孕むので、
それが走っている間に，その~algo群を改変するのはアリになるべきでない。
◎
This algorithm is likely to resolve promises causing code to run, which may include attempting to call any of the methods on AbortSignal. Since signal abort involves iterating through the collection of algorithms, it should not be possible to modify that collection while it’s running.
</p>

<p>
加えて、
`中止-を通達する$aC手続きは，
当の通達がすでに この手続きの処理nに入っている場合には、［
この手続きの中へ戻るよう再帰的に~callさせる~code
］を誘発したとしても［
再帰を避けるよう，この手続きを再び走らすのを避ける
］ことが重要になる。
◎
And since signal abort would have triggered the code which caused the recursive call back in to signal abort, it’s important to avoid running these steps again if the signal is already in the process of the signal abort steps, to avoid recursion.
</p>
</div>

<div class="note">
<p>注記：
早期-終了nに際しての注意点：
◎
Note: A caution about early termination:＼
</p>
<ul>
	<li>
終了されている当の~algoが，
何らかの~criticalな状態の一貫性を確保しようとするものである場合、
当の~algoの早期-終了nより前に，状態において関連な調整を為すこと。
そうしないと，状態が一貫しなくなり、
指定したとおり実装されると，末端-利用者に可視な~bugに至りかねないので。
◎
if the algorithm being terminated would go on to ensure some critical state consistency, be sure to also make the relevant adjustments in state before early termination of the algorithm. Not doing so can lead to inconsistent state and end-user-visible bugs when implemented as-specified.
</li>
	<li>
<p>
早期-終了nの際に例外を投出するときは、
次について念頭に置くよう特に注意すること：
</p>
		<ul>
			<li>
開発者が当の~algoを呼出すことになる局面
</li>
			<li>
この（たぶん稀な）事例において，開発者が例外を取扱うことを適理に期待することになるかどうか
— 例えば、
これは当の~algo内の唯一の例外になるか？
</li>
		</ul>
◎
Note: Be cautious about throwing exceptions in early termination. Keep in mind the scenario in which developers will be invoking the algorithm, and whether they would reasonably expect to handle an exception in this [perhaps rare] case. For example, will this be the only exception in the algorithm?
</li>
</ul>
</div>

<p>
この仕方で常に “防護-可能” になるとは限らない。
例えば，ある~algoは、
それらすべてを依拠-可能に検査するには，入口【すなわち，当の~algoを呼出している箇所】が多過ぎることもある。
これに該当する事例における別の~optionは、
作者~codeを~callするのを［
`~task$／`小task$
］へ先送りすることである。
これは，再帰の~stackを避けるが、
後続して~queueされる~taskたちにより際限ない~loopが生じる~riskは避けれない。
◎
You won’t always be able to "guard" in this way. For example, an algorithm may have too many entry-points to reliably check all of them. If that’s the case, another option is to defer calling the author code to a later task or microtask. This avoids a stack of recursion, but can’t avoid the risk of an endless loop of follow-up tasks.
</p>

<p>
~eventを先送りするときは、
“… `~eventを発火する$ための`~taskを~queueする$ …”
として指定されることが多い。
◎
Deferring an event is often specified as "queue a task to fire an event...".
</p>

<p>
~eventは、
それを誘発する~algoが異なる［
~thread／~process
］上で走ることもある場合には，常に先送りするべきである。
この事例で先送りすることは、［
当の~eventが`~task~queue$内の正しい`~task$で処理できる
］ことを確保する。
◎
You should always defer events if the algorithm that triggers the event could be running on a different thread or process. In this case, deferral ensures the events can be processed on the correct task in the task queue.
</p>

<p>
［
“防護-法”, “先送り法”
］どちらの~approachにも，~trade-offがある：
◎
Both the "guarding" and the "deferring" approach have trade-offs.
</p>

<p>
~algoの “防護-法” は次を保証する：
◎
"Guarding" an algorithm guarantees:
</p>
<ul>
	<li>
［
防護された~algoの終了~時から，~eventが発火される時点まで
］の間，状態が変化し得る機会cは無い。
◎
at the time events are fired, there is no chance that the state may have changed between the guarded algorithm ending and the event firing.
</li>
	<li>
~algoの間に発火された~event
— 当の~algoの一部として為された状態~変更を利用元~codeに通知する~eventなど —
は、
次回の`~task$まで待機する必要なく，即時に発火でき、
当の変化を~codeに通知することになる。
◎
events fired during the algorithm, such as events to notify user code of a state change made as part of the algorithm, can be fired immediately, notifying code of the change without needing to wait for the next task.
</li>
	<li>
~event~handler内で走っている利用元~codeは、
その発火-先の~instance~obj上で，関連な状態を直に観測できる
— 当の~eventに関連な状態の複製を【利用元~codeに】与える必要はない。
◎
user code running in the event handler can observe relevant state directly on the instance object they were fired on, rather than needing to be given a copy of the relevant state with the event.
</li>
</ul>

<p>
当の~eventが代わりに先送りされた場合：
◎
If the events are deferred instead:
</p>
<ul>
	<li>
当の~algoが完了した時点で，それ【~eventを発火する~task】が`~task~queue$内で最初の`~task$になる保証は無い。
◎
there is no guarantee that they will be first in the task queue once the algorithm completes.
</li>
	<li>
<p>
当の~objの状態を変更し得る他の`~task$は、
先送りされた~eventに当の~eventに関連な状態がある場合には，それを伴うよう含めるべきである。
◎
any other task may change the object’s state you should include any state relevant to the event with the deferred event.
</p>

<p class="note">注記：【！class="informative】
これは通例的に、
状態を保持するための新たな属性を伴う，新たな［
`Event$I の下位class
］を孕む。
例えば， `ProgressEvent$I は、
状態を保持する属性として［
`loaded＠~XHR#dom-progressevent-loaded$c,
`total＠~XHR#dom-progressevent-total$c,
等々
］を追加する。
◎
This usually involves a new subclass of Event, with new attributes to hold the state.
◎
For example, the ProgressEvent adds loaded, total, etc. attributes to hold the state.
</p>
	</li>
	<li>
<p>
ある~algoを成す異なる各部が協調する必要がある場合、［
先送りされた~eventを発火するとき，状態を［
検分する／変更する
］挙動がきちんと定義されるようになる
］ことを確保するため，
明示的な状態~機械（きちんと定義された状態~遷移）を定義する必要もあろう。
◎
if different parts of an algorithm need to coordinate, you may need to define an explicit state machine (well-defined state transitions) to ensure that when a deferred event fires, the behavior of inspecting or changing state is well-defined.
</p>

<div class="example">【！class="informative】
<p>
例えば，
`payment-request$r における
`PaymentRequest$I の `state＠~PAYMENT-REQUEST#dfn-state$sl 内部~slotは、
きちんと定義された遷移を通して，当の~objの状態を明示的に追跡する：
◎
For example, in [payment-request], the PaymentRequest’s [[state]] internal slot explicitly tracks the object’s state through its well-defined transitions.
</p>

<p>
これらの状態~遷移は、
状態~遷移が適切に起こるのを確保するため，防護-法の技法を利用することが多い。
例えば，
`payment-request$r は、
`show()＠~PAYMENT-REQUEST#dom-paymentrequest-show$c
など用の~algo内で `state＠~PAYMENT-REQUEST#dfn-state$sl 内部~slotの周りで利用される防護-を注記する。
◎
These state transitions often use the guarding technique themselves, to ensure the state transitions happen appropriately.
◎
For example, in [payment-request] note the guards used around the [[state]] internal slot, such as in the show() algorithm.
</p>
</div>

	</li>
	<li>
先送りされた~eventに［
加的な状態／状態~機械
］は必要ない場合、
これは おそらく，［
当の~eventは当の~algoの完了を通達するだけである
］ことを意味する。
これに該当する場合、
当の~APIは，おそらく
当の~eventを発火する代わりに `Promise$c を返すべきである。
`§ 一度限りの~event用には，~promiseを利用すること＠#one-time-events$
を見よ。
◎
if the deferred event doesn’t need extra state, or a state machine, this probably means that the event is just signalling the completion of the algorithm. If this is true, the API should probably return a Promise instead of firing the event. See § 7.1 Use promises for one time events.
</li>
</ul>

<p class="note">注記：
この節に述べたような再帰のアリ性を公開する~eventは，
“同期的な~event” と称されることもあるが、
この語法は忌避される
— それは、
~eventは非同期的に配送されることもアリなことを含意するので。
すべての~eventは、
同期的に配送される。
“非同期的な~event” は、
むしろ，~eventの発火を先送りすることを含意することが多い。
◎
Note: events that expose the possibility of recursion as described in this section were sometimes called "synchronous events". This terminology is discouraged as it implies that it’s possible to dispatch an event asynchronously. All events are dispatched synchronously. What is more often implied by "asynchronous event" is to defer firing an event.
</p>

		</section>
		<section id="state-and-subclassing">
<h3 title="Put state on target objects rather than Events">7.8. 状態は `Event^I ~objではなく `target^c ~objに置くこと</h3>

<p>
状態は， `target$c に置くようにして、
`Event$I ~objは，状態を有さない代わりに［
当の状態に対する更新を通達する
］ために利用すること。
◎
Put state on the target and use events to signal updates to that state, rather than having state on Event objects.
</p>

<p>
`target$c ~objが状態を有していれば、
次回の~eventを待機することなく，現在の状態を決定するために利用できる。
これは、
特に［
更なる~eventは無く，最終-状態がある場合
］に有用になる。
◎
Having state on the target object can used to determine the current state, without waiting for the next event. This is particularly useful if there’s a final state, where there will be no further events.
</p>

<p>
`Event$I の新たな下位classを作成することは，通例的には必要yでないが、
それらは，［
状態~変化が どう生じたかに関係している情報
］を供するために利用できる。
◎
It’s usually not necessary to create new subclasses of Event, but they can be used to provide information relating to how the state change occurred.
</p>

<div class="example">
<p>
`HTMLInputElement$I の~prop
— `value＠~HEinput#dom-input-value$c など —
は、
入力の状態を供する。
`InputEvent$I の~prop
— `inputType＠~UIEVENTS#dom-inputevent-inputtype$c など —
は、
状態に対する更新の資質を述べる。
◎
Properties on HTMLInputElement, such as value, provide the state of the input. Properties on InputEvent, such as inputType, describe the nature of an update to the state.
</p>
</div>

<p>
一部の例外的な事例
— ある~obj上で状態を保守することが高価になる事例 —
では、
他の~patternも考慮できる：
ある関数~callから `EventTarget$I を返すなど
— そこでは、
当の~callが関心の通達を成す。
◎
In some exceptional cases, where maintaining state on an object is expensive, other patterns may be considered, such as returning an EventTarget from a function call, where the function call is a signal of interest.
</p>

<div class="example">
<p>
ある環境が利用した~dataの量を報告する仮想の~API `dataUsage^c を利用しているとき，
推奨される~patternは：
◎
Using an imaginary dataUsage API that reports the amount of data an environment has used, the recommended pattern is:
</p>

<pre class="lang-js">
self.dataUsage.addEventListener('change', () =&gt; {
  console.log(self.dataUsage.bytesReceived);
});
</pre>

<p>
ここで `bytesReceived^c は、
`Event$I ではなく，
`dataUsage^c が返す `EventTarget$I に存在する。
◎
Where bytesReceived exists on the dataUsage EventTarget, rather than the Event.
</p>

<p>
この~obj上に状態を保守することが高価~過ぎな場合、
次の~patternも考慮できる：
◎
If maintaining the state on this object is too expensive, this pattern may be considered:
</p>

<pre class="lang-js">
const %dataUsage = await self.monitorDataUsage();

dataUsage.addEventListener('change', () =&gt; {
  console.log(%dataUsage.bytesReceived);
});
</pre>

<p>
この~patternにおいては、
`monitorDataUsage()^c の~callが，
当の~dataに対する関心を通達する
— 当の状態を更新する必要は、
`monitorDataUsage()^c が~callされるまでは，ない。
◎
In this pattern, the call to monitorDataUsage signals interest in the data, and the state does not need to be updated until monitorDataUsage is called.
</p>
</div>

		</section>
		<section id="events-vs-observers">
<h3 title="Use Events and Observers appropriately">7.9. ~eventか観測器か適切な方を利用すること</h3>

<p>
一般に、
観測器【 `Observer^en 】~patternよりも［
`EventTarget$I と通知 `Event$I
］を利用すること
— `EventTarget$I では，当の特能~用にきちんと働けない場合を除いて。
◎
In general, use EventTarget and notification Events, rather than an Observer pattern, unless an EventTarget can’t work well for your feature.
</p>

<p>
`EventTarget$I を利用すれば、
当の特能は，共有される基底~classに対する改善
— `once＠~DOM4#dom-addeventlisteneroptions-once$c の追加など —
から便益を得ることも確保される。
◎
Using an EventTarget ensures your feature benefits from improvements to the shared base class, such as the addition of the once.
</p>

<p>
~eventを利用すると問題
— `再帰＠#guard-against-recursion$が不可避になるなど —
の原因になる場合、
代わりに観測器~patternを利用することを考慮すること。
◎
If using events causes problems, such as unavoidable recursion, consider using an Observer pattern instead.
</p>

<p>
観測器~patternを成す例には、
次が挙げられる
⇒＃
`MutationObserver$I,
`IntersectionObserver$I,
`ResizeObserver$I,
`IDBObserver$I
◎
MutationObserver, Intersection Observer, Resize Observers, and IndexedDB Observers are all examples of an Observer pattern.
</p>

<div class="example">
<p>
`MutationObserver$I （変異~観測器）は、
`MutationEvent^I （~DOM変異~event）を置換して，それを非推奨にした
【今や，仕様からも除去された】
— 開発者が次について`気付いた＠https://lists.w3.org/Archives/Public/public-webapps/2011JulSep/0779.html$後に：
◎
MutationObserver replaced the deprecated DOM Mutation Events after developers noticed that DOM Mutation Events
</p>
<ul>
	<li>
発火される回数が多過ぎる。
◎
fire too often
</li>
	<li>
~event伝播からの便益が無く、
有用になるには遅過ぎる。
◎
don’t benefit from event propagation, which makes them too slow to be useful
</li>
	<li>
`再帰に抗して防護する＠#guard-against-recursion$のが困難~過ぎる。
◎
cause recursion which is too difficult to guard against.
</li>
</ul>

<p>
`MutationObserver$I は：
◎
Mutation Observers:
</p>
<ul>
	<li>
適用し終えた後に観測器へ送信するよう，一連の変異を~batchしておける。
◎
can batch up mutations to be sent to observers after mutations have finished being applied;
</li>
	<li>
~eventの［
捕捉~相／浮上~相
］を通って行く必要は無い。
◎
don’t need to go through event capture and bubbling phases;
</li>
	<li>
どんな変異が生じたか表出するためとして，もっと多彩な~APIを供する。
◎
provide a richer API for expressing what mutations have occurred.
</li>
</ul>

<p class="note">注記：
~eventも通知を~batchしておけるが、
`MutationEvent^I は，これを行うよう設計されなかった。
~eventは，~event伝播に常に関与する必要はないが、
~DOM `Node$I に対する~eventは，通例的にそうなる必要がある。
◎
Note: Events can also batch up notifications, but DOM Mutation Events were not designed to do this. Events don’t always need to participate in event propagation, but events on DOM Nodes usually do.
</p>
</div>

<p>
観測器~patternは、
次の様に働く：
◎
The Observer pattern works like this:
</p>
<ul>
	<li>
観測器~classの各~instanceは、
~callback, および任意選択で［
何が観測されるべきか~custom化するための，何らかの~option群
］を伴って構築される。
◎
Each instance of the Observer class is constructed with a callback, and optionally with some options to customize what should be observed.
</li>
	<li>
各~instanceは、
`observe()^c と命名された~methodを利用して，特定の~targetを観測し始める
— ~methodは、
観測される~targetへの参照をとる。
何が観測されるべきか~custom化するための~option群も，
構築子の代わりに ここで供され得る。
構築子に供された~callbackは、
その~targetに何か関心事が起きたとき，呼出される。
◎
Instances begin observing specific targets, using a method named observe(), which takes a reference to the target to be observed. The options to customize what should be observed may be provided here instead of to the constructor. The callback provided in the constructor is invoked when something interesting happens to those targets.
</li>
	<li>
~callbackは、
引数として `変更~記録^em を受取る。
これらの記録は、
それを起こした関心事についての詳細を包含する。
一度に複数個の記録が送達され得る。
◎
Callbacks receive change records as arguments. These records contain the details about the interesting thing that happened. Multiple records can be delivered at once.
</li>
	<li>
作者は、
観測器~instanceの［
`unobserve()^c ／ `disconnect()^c
］と称される~methodを~callすることにより，観測するのを停止できる。
◎
The author may stop observing by calling a method called unobserve() or disconnect() on the Observer instance.
</li>
	<li>
生じた事象のうち［
観測されたが まだ送達されていないものすべて
］の記録を即時に返すための~methodも、
任意選択で供され得る。
◎
Optionally, a method may be provided to immediately return records for all observed-but-not-yet-delivered occurrences.
</li>
</ul>

<div class="example">
<p>
`IntersectionObserver$I は、
次の様に利用されよう：
◎
IntersectionObserver may be used like this:
</p>

<pre class="lang-js">
function checkElementStillVisible(%element, %observer) {
    delete %element.visibleTimeout;

    /* <span class="comment">
まだ`~task~queue$に残っている観測nがあれば，それらを処理する
◎
Process any observations which may still be on the task queue
</span> */
    processChanges(%observer.takeRecords());

    if ('isVisible' in %element) {
        delete %element.isVisible;
        logAdImpressionToServer();

        /* <span class="comment">
%element の観測を停止する
◎
Stop observing this element
</span> */
        %observer.unobserve(%element);
    }
}

function processChanges(%changes) {
    %changes.forEach(function(%changeRecord) {
        var %element = %changeRecord.target;
        %element.isVisible = isVisible(%changeRecord.boundingClientRect,
                                      %changeRecord.intersectionRect);
        if ('isVisible' in %element) {
            /* <span class="comment">
%element は可視になった
◎
Element became visible
</span> */
            %element.visibleTimeout = setTimeout(() =&gt; {
                checkElementStillVisible(%element, %observer);
            }, 1000);
        } else {
            /* <span class="comment">
%element は非可視になった
◎
Element became hidden
</span> */
            if ('visibleTimeout' in %element) {
                clearTimeout(%element.visibleTimeout);
                delete %element.visibleTimeout;
            }
        }
    });
}

/* <span class="comment">
~callbackと~option群で
`IntersectionObserver$I を作成する
◎
Create IntersectionObserver with callback and options
</span> */
var %observer = new IntersectionObserver(processChanges, { threshold: [0.5] });

/* <span class="comment">
"ad" 要素を観測し始める
◎
Begin observing "ad" element
</span> */
var %ad = document.querySelector('#ad');
%observer.observe(%ad);
</pre>

<p>
（ `IntersectionObserver$I の`説明書き＠https://github.com/w3c/IntersectionObserver/blob/master/explainer.md$から転用された~code例。）
◎
(Example code adapted from the IntersectionObserver explainer.)
</p>
</div>

<p>
観測器~patternを利用するためには、
次を表現するための~obj型を定義する必要がある
⇒＃
新たな観測器（以下では “~Observer” と総称される）,
観測n~option群,
観測された記録
◎
To use the Observer pattern, you need to define:
• the new Observer object type,
• an object type for observation options, and
• an object type for the records to be observed.
</p>

<p>
この加的な作業には、
~trade-offとして，次に挙げる利点がある：
◎
The trade-off for this extra work is the following advantages:
</p>
<ul>
	<li>
各~instanceは、［
作成~時点／観測し始める時点
］に~custom化できる。
~Observer の［
構築子 ／ `observe()^c ~method
］は、［
各~callback用に，何が観測されるかを~custom化すること
］を作者に許容するためとして，~option群をとれる。
これは `addEventListener()$c ではアリでない。
◎
Instances can be customized at observation time, or at creation time. The constructor for an Observer, or its observe() method, can take options allowing authors to customize what is observed for each callback. This isn’t possible with addEventListener().
</li>
	<li>
複数個の~callbackを~listenしているときでも、
~Observer ~objの［
`disconnect()^c ／ `unobserve()^c
］~methodを利用すれば，容易に停止できる。
◎
It’s easy to stop listening on multiple callbacks using the disconnect() or unobserve() method on the Observer object.
</li>
	<li>
`takeRecords()^c の様な
— ~eventが発火されるまで待機する代わりに，関連な~dataを即時に~fetchするような —
~methodを供する~optionもある。
◎
You have the option to provide a method like takeRecords(), which immediately fetches the relevant data, instead of waiting for an event to fire.
</li>
	<li>
観測器は単-目的なので、
~event型を指定する必要は無い。
◎
Because Observers are single-purpose, you don’t need to specify an event type.
</li>
</ul>

<p>
~Observer と `EventTarget$I
の共通~~点は：
◎
Observers and EventTargets have these things in common:
</p>
<ul>
	<li>
どちらも，作成~時に~custom化できる。
◎
Both can be customized at creation time.
</li>
	<li>
どちらも，一連の生じた事象を~batchでき, どの時点でも送達できる。
`EventTarget$I は、
同期的になる必要はない
— 送達する時機には［
`小task$,
`遊休~期間＠~REQUESTIDLECALLBACK#dfn-idle-period$,
`~animation~frame＠~HTMLGAPI#animation-frames$,
等々
］を利用できる。
~Observer は、
特別な［
時機／~batch法
］を取得する必要はない。
◎
Both can batch occurrences and deliver them at any time. EventTargets don’t need to be synchronous; they can use microtask timing, idle timing, animation-frame timing, etc. You don’t need an Observer to get special timing or batching.
</li>
	<li>
どちらも，~DOM~tree（［
浮上／捕捉
］と取消n）に関与する必要はない。
`EventTarget$I として真っ先に挙がるものは，~DOM~tree内の `Node$I であるが、
他の多くの~eventも自立的である
— 例： `IDBDatabase$I, `XMLHttpRequestEventTarget$I
。
`Node$I を利用しているときでも，~eventは［
浮上しない／取消-可能でない
］ものに設計し得る。
◎
Neither EventTargets nor Observers need to participate in a DOM tree (bubbling/capture and cancellation). Most prominent EventTargets are Nodes in the DOM tree, but many other events are standalone; for example, IDBDatabase and XMLHttpRequestEventTarget. Even when using Nodes, your events may be designed to be non-bubbling and non-cancelable.
</li>
</ul>

<div class="example">
<p>
仮に，
`IntersectionObserver$I の［
`EventTarget$I の下位class~version
］があったとするとき、
それを利用する例：
◎
Here is an example of using a hypothetical version of IntersectionObserver that’s an EventTarget subclass:
</p>

<pre class="lang-js">
const %io = new ETIntersectionObserver(%element, { %root, %rootMargin, %threshold });

function listener(%e) {
    for (const %change of %e.changes) {
        // ...
    }
}

%io.addEventListener("intersect", %listener);
%io.removeEventListener("intersect", %listener);
</pre>

<p>
~Observer ~versionに比較して：
◎
Compared to the Observer version:
</p>
<ul>
	<li>
複数の要素を同じ~option群で観測するのは、
より困難になる。
◎
it’s more difficult to observe multiple elements with the same options;
</li>
	<li>
~dataを即時に要請する仕方は無い。
◎
there is no way to request data immediately;
</li>
	<li>
同じ~event用に複数の~event~listenerを除去するために，より作業を要する。
◎
it’s more work to remove multiple event listeners for the same event;
</li>
	<li>
作者は、
冗長な "`intersect^et" ~event型を供する必要がある。
◎
the author has to provide a redundant "intersect" event type.
</li>
</ul>

<p>
~Observer ~versionとの共通~~点は：
◎
In common with the Observer version:
</p>
<ul>
	<li>
依然として~batch法を行える
◎
it can still do batching;
</li>
	<li>
時機は同じ
（~JS~event~queueに基づく）
◎
it has the same timing (based on the JavaScript event queue);
</li>
	<li>
作者は、
依然として，何を~listenするか~custom化できる。
◎
authors can still customize what to listen for; and
</li>
	<li>
~eventは、［
捕捉~相／浮上~相
］を通って行くことはない。
◎
events don’t go through capture or bubbling.
</li>
</ul>

<p>
これらの側面は、
どちらの設計でも達成できる。
◎
These aspects can be achieved with either design.
</p>
</div>

<p>
次も見よ
⇒＃
`§ 通知~用には~eventを利用すること＠#events-are-for-notification$／
<a href="#state-and-subclassing">§ 状態は `Event^I ~objではなく `target^c ~objに置くこと</a>
◎
See also:
• § 7.6 Use events for notification
• § 7.8 Put state on target objects rather than Events
</p>

		</section>
	</section>
	<section id="types-and-units">
<h2 title="Web IDL, Types, and Units">8. ~Web~IDL, 型, 単位</h2>

		<section id="numeric-types">
<h3 title="Use numeric types appropriately">8.1. 数量-型を適切に利用すること</h3>

<p>
設計している~APIが~JS `number^jT
【~JS `Number$jT 型の値。以下、単に `number^jT と略記する】
を利用する場合、
次に挙げるいずれかの`~IDL数量-型$ `WEBIDL$r を利用すること
— そうしない特有な理由がない限り：
◎
If an API you’re designing uses numbers, use one of the following [WEBIDL] numeric types, unless there is a specific reason not to:
</p>
<dl>
	<dt>`unrestricted double$c</dt>
	<dd>
任意の `number^jT
— ［
`infinity^jv, `-infinity^jv, `NaN^jv
］も含む
◎
Any JavaScript number, including infinities and NaN
</dd>

	<dt>`double$c</dt>
	<dd>
任意の `number^jT
— ［
`infinity^jv, `-infinity^jv, `NaN^jv
］は含まない
◎
Any JavaScript number, excluding infinities and NaN
</dd>

	<dt>`EnforceRange$xA `long long$c</dt>
	<dd>
任意の `number^jT のうち［
−2<sup>63</sup> 以上 2<sup>63</sup> 以下
］のもの
— 最も近い整数に丸められる。
この範囲に入らない `number^jT が与えられた場合、
生成される言語束縛は `TypeError$E を投出することになる。
◎
Any JavaScript number from -263 to 263, rounded to the nearest integer. If a number outside this range is given, the generated bindings will throw a TypeError.
</dd>

	<dt>`EnforceRange$xA `unsigned long long$c</dt>
	<dd>
任意の `number^jT のうち［
0 以上 2<sup>64</sup> 以下
］のもの
— 最も近い整数に丸められる。
この範囲に入らない `number^jT が与えられた場合、
生成される言語束縛は `TypeError$E を投出することになる。
◎
Any JavaScript number from 0 to 264, rounded to the nearest integer. If a number outside this range is given, the generated bindings will throw a TypeError.
</dd>
</dl>

<p>
~JSの数量-型は、
`Number$jT しかなく，それは［
~IEEE 754 倍精度~浮動小数点~数,
`0^jv,
`-0^jv,
`infinity^jv,
`-infinity^jv,
`NaN^jv
］を含む。
`~IDL数量-型$は、
任意の `number^jT を，ある［
特定0の~propを伴う下位集合
］に所属するよう改変するための規則を表現する。
これらの規則は、
`number^jT が~IDLにて定義される~interfaceの［
~method／~prop設定子
］に渡されたとき，走る。
◎
JavaScript has only one numeric type, Number: IEEE 754 double-precision floating point, including ±0, ±Infinity, and NaN. [WEBIDL] numeric types represent rules for modifying any JavaScript number to belong to a subset with particular properties. These rules are run when a number is passed to the interface defined in IDL, whether a method or a property setter.
</p>

<p>
`number^jT に適用される必要がある加的な規則がある場合、
当の仕様の~algo内で指定できる。
◎
If you have extra rules which need to be applied to the number, you can specify those in your algorithm.
</p>

<div class="note">
<p>注記：
`number^jT を~bit数がより少ない`~IDL数量-型$
（ `octet$c （ 8~bit, 範囲 { 0 〜 255 } ）など）
に変換するための
`~Web~IDL規則＠~WEBIDLjs#js-integer-types$は、
`number^jT の剰余をとることを孕む。
例えば， `number^jT 値 `300^jv を `octet$c に変換するとき、
言語束縛は最初に `300^jv に対し 255 による剰余を算出することになるので，結果は 45 になる
— それは、
意に反するかもしれない。
◎
The WEBIDL rules for converting a JavaScript number to a number with fewer bits, such as an octet (8 bits, in the range [0, 255]), involves taking the modulo of the JavaScript number. For example, to convert a JavaScript number value of 300 to an octet, the bindings will first compute 300 modulo 255, so the resulting number will be 45, which might be surprising.
</p>

<p>
代わりに次のいずれかを利用できる：
◎
Instead, you can use＼
</p>
<ul>
	<li>
<code>`EnforceRange$xA octet</code>
を利用して， `octet$c 範囲に入らない値に対し `TypeError$E を投出する
◎
[EnforceRange] octet to throw a TypeError for values outside of the octet range,＼
</li>
	<li>
<code>`Clamp$xA `octet$c</code> を利用して，値を~octet範囲に切詰める（例えば 300 を 255 に変換する）
◎
or [Clamp] octet to clamp values to the octet range (for example, converting 300 to 255).
</li>
</ul>

<p>
これは、［
`short$c や `long$c
］などの他の より短い型に対しても働く。
◎
This also works for the other shorter types, such as short or long.
</p>
</div>

<p>
`bigint$c の利用は、
~~絶対値が 2<sup>53</sup> を超える値が予期されるときに限るべきである。
◎
bigint should be used only when values greater than 253 or less than -253 are expected.
</p>

<p>
~APIは、［
`BigInt$jT, `Number$jT
］の両方を
— ［
多形態性【すなわち，`共用体~型$】を介して両~型を~supportする／
別々な，他は一致するが［
`BigInt$jT をとる~API, `Number$jT をとる~API
］を追加する【すなわち，`多重定義-$する】
］ことにより —
同時に~supportするべきでない。
これには、
暗黙的な変換を通して精度を失う~riskがあり，
`BigInt$jT の目的を無為にする。
◎
An API should not support both BigInt and Number simultaneously, either by supporting both types via polymorphism, or by adding separate, otherwise identical APIs which take BigInt and Number. This risks losing precision through implicit conversions, which defeats the purpose of BigInt.
</p>

		</section>
		<section id="idl-string-types">
<h3 title="Represent strings appropriately">8.2. 文字列を適切に表現すること</h3>

<p class="note">注記：
この節は、
`international-specs$r `§ 文字列の定義-法＠https://w3c.github.io/bp-i18n-specdev/#char_string$と相互に一貫することが意味される。
双方の文書が発展するに伴い，不一致が生じたときは、
報告されたし。
◎
This section is meant to be mutually consistent with the Defining string section of [international-specs]. Please report any discrepancies that may happen as the documents evolve.
</p>

<p>
`文字列$に対し演算する~web~platform特能を設計するときは、
特有な理由がある場合を除き，
`DOMString$c を利用すること。
◎
When designing a web platform feature which operates on strings, use DOMString unless you have a specific reason not to.
</p>

<p>
ほとんどの文字列~演算は、
文字列の内側の`符号単位$を解釈する必要はないので，
`DOMString$c が最善な選択になる。
下に説明される特定の事例では、
代わりに［
`USVString$c ／ `ByteString$c
］を利用する方が適切になるかもしれない。
`INFRA$r
`WEBIDL$r
◎
Most string operations don’t need to interpret the code units inside of the string, so DOMString is the best choice. In the specific cases explained below, it might be appropriate to use either USVString or ByteString instead. [INFRA] [WEBIDL]
</p>

<p>
`USVString$c は、
`~scalar値~文字列$を表現する~Web~IDL型である。
次に挙げるもの用には、
`USVString$c を利用するべきである：
◎
USVString is the Web IDL type that represents scalar value strings.＼
</p>
<ul>
	<li>
文字列のうち，最も共通的な~algoは`~scalar値$に対し演算するもの
（`~percent-符号化法＠~URL1#percent-encode$【！https://w3c.github.io/i18n-glossary/#dfn-percent-encoding】など）
◎
For strings whose most common algorithms operate on scalar values (such as percent-encoding),＼
</li>
	<li>
入力~内の`~surrogate$を取扱えない演算
（文字列を~nativeな~platform~APIに そのまま渡す~APIなど）
◎
or for operations which can’t handle surrogates in input (such as APIs that pass strings through to native platform APIs),＼
↑ USVString should be used.
</li>
</ul>

<div class="example">
~IDL属性のうち，［
`~URL$を包含するよう定義される内容~属性
（ `href＠~HTMLlinks#attr-hyperlink-href$a `HTML$r など）
］を`反映-$するものには、
`USVString$c を利用するべきである。
◎
Reflecting IDL attributes whose content attribute is defined to contain a URL (such as href) should use USVString. [HTML]
</div>

<p>
`ByteString$c は、［
~HTTPの様な，~byte列と文字列を判別しない~protocol
］からの~dataを表現するために限り，利用するべきである。
それは、
一般~目的な文字列~型ではない。
`byte$c たちが成す`連列~型$を表現する必要がある場合、
`Uint8Array$c を利用すること。
◎
ByteString should only be used for representing data from protocols like HTTP which don’t distinguish between bytes and strings. It isn’t a general-purpose string type. If you need to represent a sequence of bytes, use Uint8Array.
</p>

		</section>
		<section id="milliseconds">
<h3 title="Use milliseconds for time measurement">8.3. 時間~測定には~milli秒を利用すること</h3>

<p>
設計している~APIが時間~測定を受容する場合、
時間~測定を~milli秒で表出すること。
◎
If you are designing an API that accepts a time measurement, express the time measurement in milliseconds.
</p>

<p>
当の~APIの分野においては秒（または他の何らかの時間~単位）の方が自然であっても、
~milli秒を堅持することは，当の~APIが別の~APIと相互運用可能になることを確保する。
これは、
作者にとって［
ある~APIで利用される値を別の~APIに利用するために変換する／
どこで, どの時間~単位が必要になるか追跡し続ける
］必要がなくなることを意味する。
◎
Even if seconds (or some other time unit) are more natural in the domain of an API, sticking with milliseconds ensures that APIs are interoperable with one another. This means that authors don’t need to convert values used in one API to be used in another API, or keep track of which time unit is needed where.
</p>

<p>
この規約は、［
`setTimeout()＠~HTMGAPI#dom-settimeout$c ／
`Date$jT
］~APIから始まり，その頃から利用されている。
◎
This convention began with setTimeout() and the Date API, and has been used since then.
</p>

<p class="note">注記：
高分解能な時刻は、
通例的に小数を伴う~milli秒として表現され，浮動小数点~値を利用している
— ~nano秒の様な より小さな時間~単位による整数~値としてではなく。
◎
Note: high-resolution time is usually represented as fractional milliseconds using a floating point value, not as an integer value of a smaller time unit like nanoseconds.
</p>

		</section>
		<section id="times-and-dates">
<h3 title="Use the appropriate type to represent times and dates">8.4. 時刻と日付を表現するときは適切な型を利用すること</h3>

<p>
~platformで日時を表現するときは、
`DOMHighResTimeStamp$I 型を利用すること。
`DOMHighResTimeStamp$I は、
利用者の時刻~設定に関わらず，時刻印を比較することを許容する。
◎
When representing date-times on the platform, use the DOMHighResTimeStamp type. DOMHighResTimeStamp allows comparison of timestamps, regardless of the user’s time settings.
</p>

<p>
`DOMHighResTimeStamp$I 値は、
時刻~値を~milli秒で表現する。
詳細は `HIGHRES-TIME$r を見よ。
◎
DOMHighResTimeStamp values represent a time value in milliseconds. See [HIGHRES-TIME] for more details.
</p>

<p>
~JS `Date$jT ~classは、
特定の日時~値を表現するためとして，利用しないこと。
`Date$jT ~objは変異-可能であり（それらの値は、変更され得る），
それを変異-不能にする仕方は無い。
◎
Don’t use the JavaScript Date class for representing specific date-time values. Date objects are mutable (may have their value changed), and there is no way to make them immutable.
</p>

<p class="note">注記：
なぜ `Date$jT を利用してはナラナイかの背景0は、
次を見よ
⇒＃
`es-discuss^en における `Frozen date objects?＠https://esdiscuss.org/topic/frozen-date-objects$en ／
~Web~IDL `Bugzilla^en における`~Web~IDLから Date を除去する＠https://www.w3.org/Bugs/Public/show_bug.cgi?id=22824$
◎
For more background on why Date must not be used, see the following:
• Frozen date objects? on es-discuss
• Remove Date from Web IDL on the Web IDL Bugzilla
</p>

		</section>
		<section id="error-types">
<h3 title="Use Error or DOMException for errors">8.5. ~error用には `Error^jT か `DOMException^I を利用すること</h3>

<p>
~web~APIにおける~errorは、［
例外, ~promise用の却下~値, ~prop
］いずれにせよ，［
~ES~error~obj【`単純~例外$】（例： `Error＠~TC39M/fundamental-objects.html#sec-error-objects$jT ）／
`DOMException$I
］として表現すること。
◎
Represent errors in web APIs as ECMAScript error objects (e.g., Error) or as DOMException. whether they are exceptions, promise rejection values, or properties.
</p>

		</section>
	</section>
	<section id="device-apis">
<h2 title="APIs that wrap access to device or browser capabilities">9. 装置や~browserの能力への~accessを包装する~API</h2>

<p>
~web~platformでは、
装置とヤリトリするための新たな~APIが今や開発されている。
例えば作者は、［
次に挙げるもの等々を接続するために，~webを利用する
］ことも可能にしたいと望む
⇒＃
`~microphoneや~camera＠~TR/mediacapture-streams/$／
`汎用~sensor＠~SENSORS$（~gyroscopeや加速度計など）／
`~Bluetooth＠https://www.w3.org/community/web-bluetooth/$／
`~USB＠https://wicg.github.io/webusb/$に接続される周辺機器／
`~~自動化＠https://www.w3.org/community/autowebplatform/$（ `automobile^en 【 `automotive^en 】 ）
◎
New APIs are now being developed in the web platform for interacting with devices. For example, authors wish to be able to use the web to connect with their microphones and cameras, generic sensors (such as gyroscope and accelerometer), Bluetooth and USB-connected peripherals, automobiles, etc.
</p>

<p>
同じことは、［
~host~system／外部~service
］が任意選択で供するかもしれない能力にも適用される。
これは、
当の能力が［
それに~accessするために対価を払っている利用者
］に依存する場合も含む。
◎
The same applies to capabilities that might be optionally provided by either the host system or an external service. This includes capabilities that depend on users paying for access to the capability.
</p>

<p>
これらの能力は、
下層の~OSから機能性として供されることも，
~nativeな第三者-主体~libraryから供されることもある。
各種~APIは、
有意な複階性を導入することなく，~nativeな機能性を［
~browserへの~API表面を~secure化する
］よう “包装する” 抽象-化を供せる。
なので、
これらは， “（何かを）包装する~API（ `wrapper API^en ）” と呼ばれる。
◎
These capabilities can be functionality provided by the underlying operating system, or provided by a native third-party library. APIs can provide an abstraction which "wraps" the native functionality without introducing significant complexity, while securing the API surface to the browser. So, these are called wrapper APIs.
</p>

<p>
この節では、
これらの能力~用の~APIを設計するとき考慮に入れる原則を述べる。
◎
This section contains principles for consideration when designing APIs for these capabilities.
</p>

		<section id="device-ids">
<h3 title="Don’t expose unnecessary information about capabilities">9.1. 能力についての情報を不必要に公開しないこと</h3>

<p>
能力についての情報への~accessを~web~siteに与える必要がある場合には、
`利用者~dataを最小~化する原則＠#data-minimization$に倣って，
公開する~dataの量を必要yな~~最小限に抑えること。
◎
In line with the Data Minimization principle, if you need to give web sites access to information about capabilities, only expose the minimal amount of data necessary.
</p>

<p>
まず，［
情報を公開することは，そもそも本当に必要yであるかどうか
］を注意深く考すること。
`利用者の必要性＠#priority-of-constituencies$は，
強力さに劣る~APIでも満足されるかどうか考慮すること。
◎
Firstly, think carefully about whether it is really necessary to expose information at all. Consider whether your user needs could be satisfied by a less powerful API.
</p>

<p>
装置の有無や［
装置／装置~識別子
］についての情報を追加的に公開することは、
各~利用者の~privacyを害する~riskを増やす。
◎
Exposing the presence of a device, additional information about a device, or device identifiers, each increase the risk of harming the user’s privacy.
</p>

<p>
利用者が ある［
装置／能力
］への~accessを否認する選択を為したときでも、
当の能力が存在するか否かを露呈するべきではない。
その局面において情報~漏洩eを抑制することは、
能力が是認されたときよりも重要である。
◎
When a user makes a choice to deny access to a device or capability, that should not reveal whether the capability exists. Reducing information leakage in that scenario is more important than when the capability is granted.
</p>

<p>
特有な情報が共有されるほど，~siteに可用になる`指紋収集~data＠~TR/fingerprinting-guidance/$は~~増す
— それに伴い，
一部の情報が`特定0の利用者にとって敏感になる＠~PRIVACY-PRINCIPLES#sensitive-information$機会cも~~増す。
◎
As more specific information is shared, the fingerprinting data available to sites gets larger, as does the chance that some of the information will be sensitive to the particular user.
</p>

<p>
強力さに劣る~APIを設計する仕方は無い場合、
装置~情報を公開するときは，次に挙げる指針を利用すること：
◎
If there is no way to design a less powerful API, use these guidelines when exposing device information:
</p>
<dl>
	<dt>
識別子~内の情報は制限すること：
◎
Limit information in any identifier
</dt>
	<dd>
~web~platformに公開される装置~識別子~内に含める識別-可能な情報は、
アリな限り抑えること。
識別-可能な情報として、
銘柄, 製造元, ~model番号, 等々が挙げられる。
通例的には、
代わりに，~randomに生成される識別子を利用できる。
識別子は、
推測-不能かつ再利用されないようにすること。
◎
Include as little identifiable information as possible in device identifiers exposed to the web plaform. Identifiable information includes branding, make and model numbers, etc You can usually use a randomly generated identifier instead. Make sure that your identifiers aren’t guessable, and aren’t re-used.
</dd>

	<dt>
利用者の制御~下に保つこと：
◎
Keep the user in control
</dt>
	<dd>
利用者が閲覧~dataを~clearするよう選んだときは、
格納された装置~識別子も~clearすること。
◎
When the user chooses to clear browsing data, make sure any stored device identifiers are cleared.
</dd>

	<dt>
敏感な情報は利用者~許可の背後に隠すこと：
◎
Hide sensitive information behind a user permission
</dt>
	<dd>
装置~識別子を匿名な仕方で作成できない場合、
当の装置への~accessを制限すること。
◎
If you can’t create a device identifier in an anonymous way, limit access to it.＼
</dd>
	<dd>
この情報に~accessしている~web~pageについて，
`利用者が良い裁定を為すよう助ける＠#user-decisions$こと。
◎
Make sure you help the user make good decisions about a Web page accessing this information.
</dd>

	<dt>
識別子を同一-生成元~modelに束ねること：
◎
Tie identifiers to the same-origin model
</dt>
	<dd>
同じ物理-装置に対し、
それへの~accessを有する各~生成元ごとに，別個な識別子を作成すること。
◎
Create distinct identifiers for the same physical device for each origin that has has access to it.
</dd>
	<dd>
同じ装置が同じ生成元により複数回 要請された場合、
それ用には同じ識別子を返すこと
（利用者が自身の閲覧~dataを~clearした場合は除く）。
これは、［
同じ装置【を表現する~data】をいくつも複製することを避ける
］ことを作者に許容する。
◎
If the same device is requested more than once by the same origin, return the same identifier for it (unless the user has cleared their browsing data). This allows authors to avoid having several copies of the same device.
</dd>

	<dt>
必要yなら、
持続-可能にすること：
◎
Persistable when necessary
</dt>
	<dd>
装置~識別子を得するのに時間がかかる場合、
作者が［
ある~sessionで生成された識別子を後の~sessionにおける利用~用に格納できる
］ようにすること。
これは、
次により行える
⇒
当の識別子を生成する手続-は、［
同じ生成元，同じ装置
］用には，一貫して同じ値を生産する
◎
If a device identifier is time consuming to obtain, make sure authors can store an identifier generated in one session for use in a later session. You can do this by making sure that the procedure to generate the identifier consistently produces the same value for the same device, for each origin.
</dd>
</dl>

<p>
次も見よ
⇒＃
`§ 利用者が良い裁定を為すよう助けること＠#user-decisions$／
`LEAST-POWER$r／
`FINGERPRINTING-GUIDANCE$r／
`UNSANCTIONED-TRACKING$r
◎
See also:
• § 1.4.1 Help users make good decision
• [LEAST-POWER]
• [FINGERPRINTING-GUIDANCE]
• [UNSANCTIONED-TRACKING]
</p>

		</section>
		<section id="device-enumeration">
<h3 title="Use care when exposing APIs for selecting or enumerating devices">9.2. 装置を［選定する／列挙する］~APIを公開するときの注意点</h3>

<p>
各~装置を列挙するのは避ける仕方を探すこと。
避けれない場合でも、
公開される情報はアリな限り少量にすること。
◎
Look for ways to avoid enumerating devices. If you can’t avoid it, expose the least information possible.
</p>

<p>
ある~APIが複数個の装置の［
存在／能力／識別子
］を公開する場合、
`§ 能力についての情報を不必要に公開しないこと＠#device-ids$
におけるすべての~riskが，能力の個数だけ乗算される。
同じ理由で、［
`利用者の必要性＠#priority-of-constituencies$が強力さに劣る~APIでも満足できるかどうか
］を考慮すること。
`LEAST-POWER$r
◎
If an API exposes the existence, capabilities, or identifiers of more than one device, all of the risks in § 9.1 Don’t expose unnecessary information about capabilities are multiplied by the number of devices. For the same reasons, consider whether your user needs could be satisfied by a less powerful API. [LEAST-POWER]
</p>

<p>
~APIの目的が［
特定0の種類の可用な装置たちが成す集合から`装置を選定する^strongこと
］を利用者に可能化することにある場合、
その~listを~scriptに公開する必要はまったくなく，
~UAが供した装置~pickerを呼出す~APIで足り得るであろう。
そのような~APIは：
◎
If the purpose of the API is to enable the user to select a device from the set of available devices of a particular kind, you may not need to expose a list to script at all. An API which invokes a User-Agent-provided device picker could suffice. Such an API:
</p>
<ul>
	<li>
利用者の制御~下に保つこと。
◎
keeps the user in control,
</li>
	<li>
`利用者が自身の裁定を理解するよう助ける＠#user-decisions$こと。
◎
helps users understand their decisions,
</li>
	<li>
既定では、
利用者の環境についての指紋収集~dataを公開しないこと。
◎
doesn’t expose any fingerprinting data about the user’s environment by default, and
</li>
	<li>
一回に情報を公開する装置の個数は 1 個に限ること。
◎
only exposes information about one device at a time.
</li>
</ul>

<p>
［
装置を選定することを利用者に許容する~API
］を設計するときは、［
~~選ばれた装置が可用である事実
］も公開することが必要yあり得る。
これは、［
利用者の環境についての一片の指紋収集~data
］を~web~siteに公開するので、
そのような特能を備えない~APIほどには安全でない。
［［
そのような~APIは、
次がアリになることを確保する
］ようになる
］ことを確保すること
⇒
［
`利用者が良い裁定を為せる＠#user-decisions$に足る情報
］を~UIに呈示する
◎
When designing API which allows users to select a device, it may be necessary to also expose the fact that there are devices are available to be picked. This does expose one bit of fingerprinting data about the user’s environment to websites, so it isn’t quite as safe as an API which doesn’t have such a feature. Ensure that such an API ensures that it is possible to present sufficient information on user interfaces that users are able to make good decisions.
</p>

<div class="example">
<p>
`RemotePlayback$I ~interfaceは、
可用な`~remote再生~装置＠https://w3c.github.io/remote-playback/#dfn-remote-playback-devices$たちが成す~listを公開しない。
代わりに，［
~UAが供する装置~pickerから 1 つの装置を選ぶ
］ことを利用者に許容する。
◎
The RemotePlayback interface doesn’t expose a list of available remote playback devices. Instead, it allows the user to choose one device from a device picker provided by the User Agent.
</p>

<p>
それは，［
`~remote再生~装置＠https://w3c.github.io/remote-playback/#dfn-remote-playback-devices$は可用かどうか検出する
］ことを~web~siteに可能化するので、
当の~web~siteは，［
利用者が装置~pickerを示すために利用できる~control
］を［
示せる／隠せる
］。
◎
It does enable websites to detect whether or not any remote playback device is available, so the website can show or hide a control the user can use to show the device picker.
</p>

<p>
この加的な情報~片を~web~siteに許容する~trade-offとして、
この~APIは，作者が次を選べるようにする
⇒
可用な装置がある場合に限り，~pickerを誘発する~buttonを示すことにより、
自身の~UIを もっと判り易くする
◎
The trade-off is that by allowing websites this extra bit of information, the API lets authors make their user interface less confusing. They can choose to show a button to trigger the picker only if at least one device is available.
</p>
</div>

<p>
装置たちが成す~listを公開しなければナラナイ場合、［
利用者の必要性を満足するために`~~最小限な下位集合^strongを公開する
］よう努めること。
◎
If you must expose a list of devices, try to expose the smallest subset that satisfies your user needs.
</p>

<p>
例えば［
`絞込まれ, 拘束された^strong装置~listを要請する
］ことを~web~siteに許容する~APIは、
装置の個数をより少なく保つ~optionの一つを成す。
しかしながら，［
異なる拘束を伴う，複数個の要請
］を為すことが作者に許容された場合、
それにより，全部的な~listに~access可能になり得る。
◎
For example, an API which allows the website to request a filtered or constrained list of devices is one option to keep the number of devices smaller. However, if authors are allowed to make multiple requests with different constraints, they may still be able to access the full list.
</p>

<p>
最後に，特定0の種類に属する装置~群の全部的な~listを公開しなければナラナイ場合、
それら装置が~listされる順序を`厳格に定義する^strongこと。
これは、
相互運用能の課題を抑制し得ることに加え，指紋収集を軽減する助けにもなる。
（~sort順序は、
他の情報を露呈することもある
— `~web仕様における~browser指紋収集の軽減-法^cite `§ 標準~化＠https://w3c.github.io/fingerprinting-guidance/#standardization$
を見よ。）
◎
Finally, if you must expose the full list of devices of a particular kind, please rigorously define the order in which devices will be listed. This can reduce interoperability issues, and helps to mitigate fingerprinting. (Sort order could reveal other information: see Mitigating Browser Fingerprinting in Web Specifications § 6.2 Standardization for more.)
</p>

<p class="note">注記：
~APIは、
装置の全部的な~listを`実装定義$な順序で公開するべきではないが，~web互換性の理由からそれが必要になることもある。
◎
Note: While APIs should not expose a full list of devices in an implementation-defined order, they may need to for web compatibility reasons.
</p>

		</section>
		<section id="usecase-oriented-apis">
<h3 title="Design based on user needs, not the underlying capability">9.3. 下層の能力ではなく利用者の必要性に基づいて設計すること</h3>

<p>
~webに持込まれる新たな~native能力は、
利用者の必要性に基づいて公開すること。
◎
Expose new native capabilities being brought to the web based on user needs.
</p>

<p>
既存の~native~APIを~webへ直に翻訳するのは避けること。
◎
Avoid directly translating an existing native API to the web.
</p>

<p>
代わりに，［
当の~native~APIにて可用な機能性, それが取組む利用者の必要性
］を考慮して、
実装が既存の~native~APIに依存する場合でも，
利用者の必要性を満たす~APIを設計すること。
◎
Instead, consider the functionality available from the native API, and the user needs it addresses, and design an API that meets those user needs, even if the implementation depends on the existing native API.
</p>

<p>
下層の~native~APIの正確な［
~lifecycle／~data構造
］を公開することについて、
特に気を付けること。
アリなときは、
新たな~hardware用の柔軟性を考慮すること。
◎
Be particularly careful about exposing the exact lifecycle and data structures of the underlying native APIs. When possible, consider flexibility for new hardware.
</p>

<p>
このことは、
新たに提案される~APIは，［
それが，どう利用されるものと意図されるか
］に基づいて設計されるべきであることを意味する
— 下層の［
~hardware／装置／~native~API
］が今日にて どう運用されているかではなく。
◎
This means newly proposed APIs should be designed with regard to how they are intended to be used rather than how the underlying hardware, device, or native API happens to operate today.
</p>
		</section>
		<section id="hardware-is-scary">
<h3 title="Be proactive about safety">9.4. 安全性について事前に備えておくこと</h3>

<p>
~web~platformに~native能力を持込むときは、
防御的に設計するよう努めること。
◎
When bringing native capabilities to the web platform, try to design defensively.
</p>

<p>
~native能力を~web~platformに持込むことには、
多くの含意がつきまとう。
利用者は、
自身の~computerが特有な能力を備えることを~web~siteに知らせたいとは求めないであろう。
したがって，論理的な生成元~境界の外側にある何かへの~accessは、
許可を介して通過制御されるべきである。
◎
Bringing a native capability to the web platform comes with many implications. Users may not want websites to know that their computers have specific capabilities. Therefore, access to anything outside of the logical origin boundary should be permission gated.
</p>

<p>
例えば，［
状態を格納し得る装置があって，その状態は複数の生成元から同時に読取n可能である
］場合、
その状態を一群の~APIから［
読取れる／書込める
］ようにすることは，実質的に［
~webの生成元~modelを損なう~side-channel【〜攻撃の余地を与えるもの】
］になる。
◎
For example, if a device can store state, and that state is readable at the same time by multiple origins, a set of APIs that lets you read and write that state is effectively a side-channel that undermines the origin model of the web.
</p>

<p>
これらの理由から、
当の装置が排他的でない~accessを許容する場合でも，［
生成元ごとに排他的な~accessを施行するか、
更には，現在~作動中な~UItabに限るよう制約する
］ことを考慮することになろう。
◎
For these reasons, even if the device allows non-exclusive access, you may want to consider enforcing exclusive access per-origin, or even restricting it further to only the current active tab.
</p>

<p>
加えて，~APIは、
物理的な遮断
— 当の装置がとり外されているなど —
を~appが上品に取扱えるよう，設計されるべきである。
◎
Additionally, APIs should be designed so that the applications can gracefully handle physical disruption, such as a device being unplugged.
</p>

		</section>
		<section id="wrapper-apis">
<h3 title="Adapt native APIs using web platform principles">9.5. ~native~APIに順応するときは、~web~platform原則を利用すること</h3>

<p>
~OSに~nativeな~APIを~web用に順応するときは、
~web~platform原則を念頭に置いて，新たな~web~APIを設計すること：
◎
When adapting native operating system APIs for the web, make sure the new web APIs are designed with web platform principles in mind.
</p>
<dl>
	<dt>
~web~APIは、
複数の~platformで実装できるようにすること。
◎
Make sure the web API can be implemented on more than one platform
</dt>
	<dd>
何かを包装する~APIを設計するときは、
各種~platformが その機能性をどう供するか考慮すること。
◎
When designing a wrapper API, consider how different platforms provide its functionality.
</dd>
	<dd>
理想的には，すべての実装が正確に同じに働くべきであるが、
一部の事例では，一部の~platformでしか働かない~optionを公開する理由もあろう。
それに該当する場合、［
作者は、
すべての~platformで働く~codeを どう書するべきか
］を説明すること。
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$を見よ。
◎
Ideally, all implementations should work exactly the same, but in some cases you may have a reason to expose options which only work on some platforms. If this happens, be sure to explain how authors should write code which works on all platforms. See § 2.6 New features should be detectable.
</dd>

	<dt>
下層の~protocolは、
~openになるべきである
◎
Underlying protocols should be open
</dt>
	<dd>
外部［
~hardware／~service
］との交換を要求する~APIは、［
~openでない／~proprietaryな
］~protocolに依存するべきでない。
~openでない~protocolに依存することは、
~webの~openな資質を損なう。
◎
APIs which require exchange with external hardware or services should not depend on closed or proprietary protocols. Depending on non-open protocols undermines the open nature of the web.
</dd>

	<dt>
利用者が~off-lineであるときも取扱うよう，~APIを設計すること
◎
Design APIs to handle the user being off-line
</dt>
	<dd>
~APIが［
~remote~serverにより供される何らかの~service
］に依存する場合、［
利用者が何らかの理由で~remote~serverに~accessできないとき
］でも，~APIがきちんと機能するようにすること。
◎
If an API depends on some service which is provided by a remote server, make sure that the API functions well when the user can’t access the remote server for any reason.
</dd>

	<dt>
追加的な指紋収集~表口を避けること
◎
Avoid additional fingerprinting surfaces
</dt>
	<dd>
何かを包装する~APIは、
意図的でなくとも，より広い指紋収集~表口に利用者を晒し得る。
追加的な詳細は、
~TAGによる知見
`野放図な追跡＠https://www.w3.org/2001/tag/doc/unsanctioned-tracking/$cite
を読されたし。
◎
Wrapper APIs can unintentionally expose the user to a wider fingerprinting surface. Please read the TAG’s finding on unsanctioned tracking for additional details.
</dd>
</dl>

		</section>
	</section>
	<section id="other-considerations">
<h2 title="Other API Design Considerations">10. ~API設計における他の考慮点</h2>

		<section id="polyfills">
<h3 title="Enable polyfills for new features">10.1. 新たな特能~用には~polyfillを可能化すること</h3>

<p>
~polyfillは、
新たな特能が~web~platformに普及する助けになるものとして，多大に有益になり得る。
~TAGによる
`~polyfillと~webの発展に対する知見＠https://www.w3.org/2001/tag/doc/polyfills/$cite
は、
新たな特能の開発において考慮されるべき指導を提供する
— 特に：
◎
Polyfills can be hugely beneficial in helping to roll out new features to the web platform. The Technical Architecture Group finding on Polyfills and the Evolution of the Web offers guidance that should be considered in the development of new features, notably:
</p>
<ul>
	<li>
“~polyfill可能” であることは、
本質的ではないが，`有益である^strong。
◎
Being "polyfillable" isn’t essential but is beneficial
</li>
	<li>
`§ 新たな特能は検出-可能になるべきである＠#feature-detect$。
◎
§ 2.6 New features should be detectable
</li>
	<li>
~polyfillの開発は、
奨励されるべきである。
◎
Polyfill development should be encouraged
</li>
</ul>

		</section>
		<section id="consider-dedicatedworker-support">
<h3 title="Where possible APIs should be made available to dedicated workers">10.2. ~APIはアリな所では専用~workerにも可用にされるベキである</h3>

<p>
特能を公開するときは、［
当の特能を専用~workerにも
（ `DedicatedWorkerGlobalScope$I ~interfaceを介して）
公開することはイミを成すかどうか
］について考慮されたし。
◎
When exposing a feature, please consider whether it makes sense to expose the feature to dedicated workers (via the DedicatedWorkerGlobalScope interface).
</p>

<p>
多くの特能は、
専用~worker上でも，そのままで働ける
— 当の特能をそこで可能化しないことは、［
その利用者が，自身の~codeを他を阻まない方式で走らす能
］を制限することにもなり得る。
◎
Many features could work out of the box on dedicated workers and not enabling the feature there could limit the ability for users to run their code in a non-blocking manner.
</p>

<p>
ある特能を専用~workerでも公開するよう試行するとき，ある種の難題が存在し得る
— とりわけ、
当の特能が［
許可を依頼する／
~pickerや選定器を示す
］ような利用者~入力を要求する場合に。
これは［
仕様~策定者が専用~workerを~supportするのを忌避させる
］かもしれないが，それでも、［
専用~worker用の~supportを念頭に，当の特能を設計する
］ことが推奨される
— ［
後で，当の~APIを専用~workerに公開する
］ことが［
不必要に難しくなるような前提
］を追加しないために。
◎
Certain challenges can exist when trying to expose a feature to dedicated workers, especially if the feature requires user input by asking for permission, or showing a picker or selector. Even though this might discourage spec authors to support dedicated workers, we still recommend designing the feature with dedicated worker support in mind, in order to not add assumptions that will later make it unnecessarily hard to expose these APIs to dedicated workers.
</p>

			<section id="worker-only">
<h4 title="Some APIs should only be exposed to dedicated workers">10.2.1. 一部の~APIは専用~workerに限り公開するベキである</h4>

<p>
開発者たちは、
複階的な~codeより単純な~codeを選好する。
彼らは、
所与の~APIにて許容される仕方のうち最も単純なものを利用する見込みが高い。
◎
Developers prefer simple code to complex code. They are more likely to use an API in the simplest way the API allows.
</p>

<p>
重要なのは、
具現化を阻む特能を追加するのは，避けることである。
`§ 具現化を阻む特能は避けること＠#avoid-render-blocking$を見よ。
◎
It’s important to avoid adding features that block rendering. § 3.4 Avoid features that block rendering
</p>

<p>
~APIを最も容易な仕方で利用すると［
具現化を阻む／
“`カクつく＠https://developer.mozilla.org/en-US/docs/Glossary/Jank$”
］結果になる見込みが高い場合、
利用者~体験に難が生じることなる。
（この問題は、
低性能な
— 社会的弱者ほど利用する見込みが高い —
機器ほど顕著になる。
`~webは、すべての人々のためにある＠~ETHICAL-PRINCIPLES#allpeople$ことに留意すること。）
◎
If the easiest way to use an API is likely to result in render blocking or “jank,” the user experience will suffer. (This problem is even more pronounced on low-powered devices, which are more likely to be used by disadvantaged or marginalized users. Remember, the web is for all people.)
</p>

<p>
したがって、
意図されたとおり利用すると~main~threadを阻むことが多くなる~APIは，
`Window$I ~interfaceに公開されるベキでない。
そのような~APIを `DedicatedWorkerGlobalScope$I ~interfaceに制約すれば、
~web開発者にとって “容易な” 道は，最良な利用者~体験を与える道にもなる。
◎
Therefore, APIs which would often block the main thread if used as intended should not be exposed on the Window interface. By restricting such APIs to the DedicatedWorkerGlobalScope interface, the “easy” path for web developers is the path with the best experience for users.
</p>

<div class="example">
`WebAudio$r における `ScriptProcessorNode$I は、
`AudioWorklet$I に置換された
— ~main~threadから `ScriptProcessorNode^I を利用すると，
利用者~体験は頻繁に拙くなるので。
`WebAudio$r
◎
ScriptProcessorNodes were replaced by AudioWorklets in the Web Audio API because use of ScriptProcessorNode from the main thread frequently resulted in a poor user experience. [WebAudio]
</div>

			</section>
		</section>
		<section id="expose-everywhere">
<h3 title="Only purely computational features should be exposed everywhere">10.3. 純粋に算出的な特能は，どこにでも公開されるべきである</h3>

<p>
ある特能を公開するときは、
当の特能をアリなすべての環境に
（［
`Exposed$xA 注釈 ／
すべての大域~scope~interfaceにそれを含める【`内包-$する】こと
］を介して）
公開することがイミを成すかどうか，考慮されたし。
◎
When exposing a feature, please consider whether it makes sense to expose the feature to all possible environments (via the [Exposed=*] annotation or including it on all global scope interfaces).
</p>

<p>
純粋に算出的な特能
— すなわち［
【外部との】入出力を遂行する
］ことも［
~UAや利用者の装置の状態に影響する
］こともないもの —
は、
どこにでも公開されるべきである。
◎
Only purely computational features should be exposed everywhere. That is, they do not perform I/O and do not affect the state of the user agent or the user’s device.
</p>

<p class="example">
`TextEncoder$I ~interfaceは、
文字列を~UTF-8に符号化された~byte列へ変換する。
これは、
純粋に算出的な~interfaceであり，~JS言語の便宜性として一般に有用なので、
どこにでも公開されるべきである。
◎
The TextEncoder interface converts a string to UTF-8 encoded bytes. This is a purely computational interface, generally useful as a JavaScript language facility, so it should be exposed everywhere.
</p>

<p class="example">
`localStorage＠~WEBSTORAGE#dom-localstorage$c は、
~UAの状態に影響するので，どこにでも公開されるべきではない。
◎
localStorage affects the state of the user agent, so it should not be exposed everywhere.
</p>

<p class="example">
`console$I は、
形上では，［
~UAの状態／利用者の装置
］に影響することもある
（［
開発者~tool内に~log~messageを現れさせる／
ある~log~fileへ書込む
］ことにより）。
が，これらのものは、
走っている~codeからは観測-可能でない
— `console$I がどこにでもあることは、
実用的に，そのような不利に勝る。
◎
Technically, console could affect the state of the user agent (by causing log messages to appear in the developer tools) or the user’s device (by writing to a log file.) But these things are not observable from the running code, and the practicality of having console everywhere outweighs the disadvantages.
</p>

<p>
加えて，~event~loopに依拠しているものは、
どこにでも公開されるべきではない。
大域~scopeには、
~event~loopを有さないものもあるので。
◎
Additionally, anything relying on an event loop should not be exposed everywhere. Not all global scopes have an event loop.
</p>

<p class="example">
`AbortSignal$I の `timeout()＠~DOM4#dom-abortsignal-timeout$c ~methodは、
~event~loopに依拠するので，
どこにでも公開されるべきではない。
`AbortSignal$I を成す残りは、
純粋に算出的なので，
どこにでも公開されるべきである。
◎
The timeout method of AbortSignal relies on an event loop and should not be exposed everywhere. The rest of AbortSignal is purely computational, and should be exposed everywhere.
</p>

<p>
また， `Exposed$xA 注釈は、
保守的に適用するべきである。
ある特能が［
どこにでも公開されることはない他の特能
］を伴わない限り有用にならない場合、
当の特能も，既定では公開されないよう。
◎
The [Exposed=*] annotation should also be applied conservatively. If a feature is not that useful without other features that are not exposed everywhere, default to not exposing that feature as well.
</p>

<p class="example">
`Blob$I ~interfaceは，純粋に算出的であるが、
`Blob$I ~objは，首に［
入出力~用に利用される／
入出力の結果として得される
］。
保守的に公開する原則により、
`Blob$I は，どこにでも公開されるべきではない。
◎
The Blob interface is purely computational, but Blob objects are primarily used for, or obtained as a result of, I/O. By the principle of exposing conservatively, Blob should not be exposed everywhere.
</p>

		</section>
		<section id="new-data-formats">
<h3 title="Add new data formats properly">10.4. 新たな~data形式を適正に追加すること</h3>

<p>
新たな~data形式に対しては、
常に
⇒＃
対応する~MIME型を定義すること／
この型を~supportするよう既存の~APIを拡張すること
◎
Always define a corresponding MIME type and extend existing APIs to support this type for any new data format.
</p>

<p>
~web上の新たな能力が［
新たな~data形式を追加すること
］も孕む事例がある。
これには、
~browserが取り込むものと期待される［
画像／動画／音声／~text／他の型の~data
］も該当し得る。
新たな形式~用には、［
厳密に検証された，標準~化された~MIME型
］を利用すること。
新たな形式が~textを包含する場合、
~UTF-8に符号化された~textに限り，~supportするべきである。
◎
There are cases when a new capability on the web involves adding a new data format. This can be an image, video, audio, text, or any other type of data that a browser is expected to ingest. Use a strictly validated standardized MIME type for new formats. New formats containing text should only support UTF-8 encoded text.
</p>

<p>
旧来の~media形式は，~MIME型に対する厳密な施行を常に行ってはいなかったが
（これに対処するため、
ときには，【~media~dataの】~headerを覗見ることに依拠している）、
その理由のほとんどは旧来との互換性を得るためであり，新たな形式には［
期待される／実装される
］べきでない。
◎
While legacy media formats do not always have strict enforcement for MIME types (and sometimes rely on peeking at headers, to workaround this), this is mostly for legacy compatibility reasons and should not be expected or implemented for new formats.
</p>

<p>
仕様~策定者には、
新たな形式を既存の~APIに統合することも期待される
— ~browserの視点からは、［
~~入口（例： `ReadableStream$I から復号するとき）,
~~出口（例： `WritableStream$I【！WriteableStream】 へ符号化するとき）
］どちらにおいても，安全な形式とみなされるよう。
◎
It is expected that spec authors also integrate the new format to existing APIs, so that they are safelisted in both ingress (e.g. decoding from a ReadableStream) and egress (e.g. encoding to a WriteableStream) points from a browser’s perspective.
</p>

<p>
例えば，~web~platformに【新たな】画像~形式を追加する場合、
まず，当の形式~用に新たな~MIME型を追加してから、
`HTMLImageElement$I における復号-法を~supportするため必然的に，
当の画像~形式~用の復号器を（および，必要なら符号化器も）追加することになろう。
この~~上層には、
さらに，
`HTMLCanvasElement$I の［
`toBlob()＠~HEcanvas#dom-canvas-toblob$c,
`toDataURL()＠~HEcanvas#dom-canvas-todataurl$c
］などの~~出口に対する~supportを追加することも期待される。
◎
For example. if you are to add an image format to the web platform, first add a new MIME type for the format. After this, you would naturally add a decoder (and presumably an encoder) for said image format to support decoding in HTMLImageElements. On top of this, you are also expected to add support to egress points such as HTMLCanvasElement.toBlob() and HTMLCanvasElement.toDataURL().
</p>

<p>
旧来の理由から，~browserは~MIME型の~sniff法を~supportするが、
その`~pattern照合~algo＠~MIMESNIFF#image-type-pattern-matching-algorithm$を拡張することは，~securityの含意に因り推奨されない
— より新たな形式~用には、
代わりに，厳密な~MIME型を施行することが推奨される。
◎
For legacy reasons browsers support MIME type sniffing, but we do not recommend extending the pattern matching algorithm, due to security implications, and instead recommend enforcing strict MIME types for newer formats.
</p>

<p>
新たな~MIME型には、
それ用の仕様があるべきであり，
~IANA（ `Internet Assigned Numbers Authority^en ）に登録されるべきである。
◎
New MIME types should have a specification and should be registered with the Internet Assigned Numbers Authority (IANA).
</p>

		</section>
		<section id="extend-manifests">
<h3 title="Extend existing manifest files rather than creating new ones">10.5. 既存の~manifest~fileを拡張すること — 新たなそれを作成することなく</h3>

<p>
当の特能が~manifestを要求する場合、
既存の~manifest~schemaを拡張できるかどうか究明すること。
◎
If your feature requires a manifest, investigate whether you can extend an existing manifest schema.
</p>

<p>
新たな~web特能は［
自己完結的かつ自己記述的
］になるべきであり、
理想的には，追加的な~manifest~fileを要求するべきでない。
既存の~manifest~fileには、
次に挙げるものが含まれる：
◎
New web features should be self-contained and self-describing and ideally should not require an additional manifest file. Some of the existing manifest files include
</p>
<ul>
	<li>
`~web~app~manifest＠~APPMANIFEST$cite
（ `Web App Manifest^en ）
⇒
~web~appに関係する特能を包含する。
◎
Web App Manifest which contains features related to web applications.
</li>
	<li>
`支払い~method~manifest＠~TR/payment-method-manifest/$cite
（ `Payment Method Manifest^en ）
⇒
~web支払い~APIの文脈における支払い~method用に利用される。
◎
Payment Method Manifest which is used for payment methods in the context of the web payment API
</li>
	<li>
`公表物~manifest＠~TR/pub-manifest/$cite
（ `Publication Manifest^en ）
⇒
~web公表物~WGによる一部の標準で利用される。
◎
Publication Manifest which is used by some web publications working group standards
</li>
	<li>
`生成元~施策＠https://wicg.github.io/origin-policy/$cite
（ `Origin Policy^en ）
⇒
~security施策を設定するために利用される。
◎
Origin Policy which is used to set security policies.
</li>
</ul>

<p>
既存の各種~manifest~fileを拡張することが奨励される。
常に、
元の仕様の中に変更を加えるよう試行するか，
少なくとも当の仕様~編集者と拡張について論じること。
この論点があれば、［
結果の設計は もっと良くなる／
~platformに もっと良く統合される何かへ至らす
］見込みは高まる。
◎
We encourage people to extend existing manifest files. Always try to get the changes into the original spec, or at least discuss the extension with the spec editors. Having this discussion is more likely to result in a better design and lead to something that better integrates with the platform.
</p>

<p>
~manifest用に新たな［
~key, 値
］を設計するときは、
それらが必要であること
（すなわち、
きちんと考出された利用事例を可能化するものであること）
を確かめること。
また、
類似な~keyが存在するか検査されたし。
既存の ( ~key / 値 ) ~pairでは，必要なものに~~比して過不足がある場合、
アリなら，既存の仕様と作業して それを当の利用事例へ拡張すること。
◎
When designing new keys and values for a manifest, make sure they are needed (that is, they enable well-thought-out use-cases). Also, please check if a similar key exists. If an existing key/value pair does more or less what is needed, work with the existing spec to extend it to your use-case if possible.
</p>

<p class="note">注記：
元の仕様~策定者は、
一定期間は，当の変更を彼らの~manifest形式に即時に統合したいと求めないかもしれない。
これは、［
（勧告候補へ向けて進む様な）~process／
当の追加は異なる視野に入ること
］に因ることもある
— 例えば，［
`支払い~method~manifest^cite【！`~web~app~manifest^cite】
に対する拡張に影響される利用事例は、［
店／支払い
］に限られる
］の様に。
その事例では、
元の仕様の編集者と合意される限り，`~monkey~patchする$ことも受容-可能である。
◎
There are certain times the original spec authors might not want to integrate changes to their manifest format immediately. This may be due to process (like going to CR), or due to the addition having a different scope, like extensions to Web App Manifest only affecting store or payment use-cases. In that case, it is acceptable to monkey patch as long as that is agreed with the original spec editors.
</p>


<p>
しかしながら，当の特能に［
機能上の領分に特有な~metadata
］が成す複階的な集合が要求される場合、
新たな~manifestの作成も正当化されよう。
◎
However, if your feature requires a complex set of metadata specific to a functional domain, the creation of a new manifest may be justified.
</p>

<p>
~manifest~fileの領分が既存の~manifest~fileと異なる場合、
新たな~manifest~fileを作る必要もあろう
— 例：~fileを~fetchする時機が異なる場合や，
~manifestの複階性が，そうする必要の~~十分な~~根拠を成す場合。
~app~metadataは、［
`~web~app~manifest^cite, または その拡張
］に追加されるべきである。
~manifestのうち［
特定の~app／
~browser以外との相互運用能を要求するもの
］用に利用されるものと指名されるものは、
異なる~approachをとる必要もあろう。
これらに該当する事例を成す例として［
`支払い~method~manifest^cite,
`公表物~manifest^cite,
`生成元~施策^cite
］がある。
◎
You may need to make a new manifest file if the domain of the manifest file is different from the existing manifest files. For example, if the fetch timing is different, or if the complexity of the manifest warrants it. Application metadata should be added to the Web App Manifest or be an extension of it. Manifests designated to be used for specific applications or which require interoperability with non-browsers may need to take a different approach. Payment Method Manifest, Publication Manifest, and Origin Policy are examples of these cases.
</p>

<p>
例えば，~metadata片が一つだけならば
— ~fetch時機が既存の~manifestと異なっていても —
おそらく，既存の~manifestを利用する
（あるいは，理想的には、
~manifestは要求されない仕方で，当の特能を設計する）
のが最善である。
しかしながら，当の特能に［
その機能上の領分に特有な~metadata
］が成す複階的な集合が要求される場合、
新たな~manifestの作成も正当化され得る。
◎
For example, if you have a single piece of metadata, even if the fetch timing is different than an existing manifest, it is probably best to use an existing manifest (or ideally design the feature in such a way that a manifest is not required). However, if your feature requires a complex set of metadata specific to a functional domain, the creation of a new manifest may be justified.
</p>

<p>
どの事例でも、
命名~規約と調和するべきであることに注意
（ `§ 命名~原則＠#naming-is-hard$を見よ）。
◎
Note that in all cases, the naming conventions should be harmonized (see § 12 Naming principles).
</p>

<p class="note">注記：
既存の~manifestは、
原則により，~underscoreで区切られた小文字による名前を利用する。
~DOM~API内の~manifestから辞書を再利用するのが有用であった~~時期もあった
— そこでの各~名前は、
~camel-case化した~versionに変換することが意味されていた。
そのような例には、
`画像~資源＠https://w3c.github.io/image-resource/$
がある。
この理由から、
~keyを 1 個の単語で明瞭に表出できるなら，そうすることが推奨される。
◎
Note: By principle, existing manifests use lowercase, underscore-delimited names. There have been times where it was useful to re-use dictionaries from a manifest in DOM APIs as well, which meant converting the names to camel-cased version. One such example is the image resource. For this reason, if a key can clearly be expressed as a single word, that is recommended.
</p>

		</section>
		<section id="serialization">
<h3 title="Consider consumers when serializing">10.6. 直列化するときは消費者を考慮すること</h3>

<p>
構文解析器や直列化器を孕む特能を［
追加する／拡張する
］ときは、
それによる直列化に対する効果を考慮するベキである。
直列化の結果の~~対象者として，次に挙げるものを考慮しなければナラナイ：
◎
When adding or extending features that involve a parser or a serializer you should consider their effect on serialization. The following are constituencies of serialization results that must be considered:
</p>
<ul>
	<li>
利用者
⇒
直列化の結果は、
末端-利用者に呈示されることもあるので。
◎
Users - because the result of serialization may be presented to the end user
</li>
	<li>
~tool
⇒
いくつかの仕方で，出力を成す直列化に依拠することもあるので
（一例として、
構文解析器が入力~内の~errorを正す必要があるか否か検出するために）。
◎
Tools - which may rely on the output of serialization in a number of ways (for instance, to detect if the parser need to correct for errors in the input)
</li>
	<li>
~Web~API
⇒
直列化は、
~web~platformの他の~APIへ渡されることもあるので。
◎
Web APIs - because serializations may be passed into other APIs of the web platform
</li>
</ul>

<p>
言語に特有な期待を考慮すること
— 一例として、
空白の有無が有意になり得る言語もある。
各~言語が受容する浮動小数点~数の精度は，言語に応じて相違し得る。
直列化の結果は：
◎
Consider language specific expectations - for instance, in some languages, the presence or absence of whitespace may be significant. Languages may differ in the precision of floating point numbers they accept. The results of serialization:
</p>

<ul>
	<li>
開発者の期待に合致するベキである
（一例として、
~CSS~propを直列化-法した結果の出力は，
~CSS作者が書したものと大きく異なるベキでない）。
◎
Should match developer expectations (for instance, serializing CSS properties should not result in output that is very different from what a CSS author would have written)
</li>
	<li>
`冪等性＠https://en.wikipedia.org/wiki/Idempotence$
⇒
構文解析器からの出力を直列化した結果は、
再び構文解析して直列化されたとき，同じ結果を生産するベキである。
◎
Idempotence - the result of serializing the output of a parser should be something that, when parsed and serialized, produces itself.
</li>
	<li>
~error累積に追加するベキでない
⇒
ある~APIから直列化された出力をとって，ある~loop内で同じ~APIへ~feedbackしても、
結果の内部~状態は同じになるベキである。
◎
Should not add to error accumulation - taking the serialized output of an API and feeding it back to the same API in a loop should result in the same internal state
</li>
</ul>

		</section>
		<section id="debuggability">
<h3 title="Ensure features are developer-friendly">10.7. 特能が開発者に親切になることを確保すること</h3>

<p>
新たな特能は、
どれも，開発者に親切になるべきである。
親切さを数値化することは難しいが、
少なくとも次に挙げる点を考慮すること。
◎
Any new feature should be developer-friendly. While it is hard to quantify friendliness, at least consider the following points.
</p>
<ul>
	<li>
例外に伴われる~error~textは，汎用であるべきだが、
開発者~向けの~error~message（開発者~consoleに示されるものなど）は，
開発者に有意義でなければならない。
開発者が~errorに遭遇したとき、
当の~messageは，［
汎用に過ぎないよう，当の~error事例に特有なもの
］にするべきである。
◎
While error text in exceptions should be generic, developer-oriented error messages (such as those from a developer console) must be meaningful. When a developer encounters an error, the message should be specific to that error case, and not overly generic.
</li>
	<li>
開発者~向けの~error~messageは、
理想的には，［
開発者が問題がある箇所を~~特定すること
］を手引きするに十分な情報を伴うべきである。
◎
Ideally, developer-oriented error messages should have enough information to guide the developer in pinpointing where the problem is.
</li>
	<li>
~CSSなどの宣言的な特能は、
~debug能を得るために，実装において加的な作業が要求され得る。
当の仕様において これを定義することは、
当の特能が より開発者に親切になるのみならず，利用者にとって一貫した開発~体験も確保する。
◎
Declarative features such as CSS, may require extra work in the implementation for debuggability. Defining this in the specification not only makes the feature more developer-friendly, it also ensures a consistent development experience for the users.
</li>
</ul>

<p>
~debug能を仕様の一部として定義した良い例として，次が挙げられる
⇒
`~web~animation^cite（ `Web Animations^en ）の `§ 利用事例＠~WANIM#use-cases$。
◎
A good example where debuggability was defined as part of the specification is Web Animations.
</p>

		</section>
		<section id="crypto">
<h3 title="Use the best crypto, and expect it to evolve">10.8. 最良な暗号を利用すること，暗号は進化するものと予期すること</h3>

<p>
暗号用の~algoには、
~security専門家により公平に考査されたものに限り利用すること
— 【~~強度が】立証された, 最新なものを選ぶこと。
暗号用の［
~protocol／~algo
］は、
廃用にされたり，~secureでなくなるのみならず，急速に進化する。
◎
Use only cryptographic algorithms that have been impartially reviewed by security experts, and make sure your choice of algorithm is proven, and up-to-date. Not only do they become obsolete or insecure, cryptographic protocols and algorithms also evolve quickly.
</p>

		</section>
		<section id="client-hints">
<h3 title="Do not expose new information through Client Hints">10.9. ~client~hintを通して新たな情報を公開しないこと</h3>

<p>
`~client~hint^cite `RFC8942$r を利用して公開する情報は、
~web~pageが すでに~accessを有しているものに限ること。
◎
When using Client Hints, don’t expose information that the web page does not already have access to.
</p>

<p>
~client~hintは重要な最適化ではあるが、
~siteに情報を公開する唯一の手段には，なり得ない
— それを定義した `RFC8942$r `§ 情報~公開＠~HTTPch#information-exposure$にて~~述べられたとおり：
◎
Client hints are an important optimization, but cannot be the sole means by which information is exposed to sites. As it says in RFC 8942 §4.1 where client hints are defined:
</p>

<blockquote cite="https://datatracker.ietf.org/doc/html/rfc8942#section-4.1-5">
<p>
したがって，この文書に依拠する下で~client~hint~headerを定義している特能は、
さもなければ［
~UAが応用
— 既存の［
要請~header／~HTML／~CSS／~JS
］など —
には可用にしないような，新たな情報
］を供してはナラナイ。
◎
Therefore, features relying on this document to define Client Hint headers MUST NOT provide new information that is otherwise not made available to the application by the user agent, such as existing request headers, HTML, CSS, or JavaScript.
</p>
</blockquote>

<p>
追加するよう試行している新たな~client~hintが［
他の手段では，~web~pageに可用にならない情報
］を公開するものである場合、
まずは［
そのような情報を~APIを通して公開する
］ことを追求されたし。
◎
If you are trying to add a new client hint that exposes information that is not available to the web page through other means, please pursue exposing this information through an API first.
</p>
		</section>
	</section>
	<section id="spec-writing">
<h2 title="Writing good specifications">11. 良い仕様の書法</h2>

<p>
この文書の大部分は，~Web用の~API設計を受持つが、
~APIを設計する者は，当の~API用の仕様も書するよう希望される。
◎
This document mostly covers API design for the Web, but those who design APIs are hopefully also writing specifications for the APIs that they design.
</p>

		<section id="requirements-on-authors-and-implementers">
<h3 title="Identify the audience of each requirement in your specification">11.1. 当の仕様~内の各~要件の対象者を識別すること</h3>

<p>
次の両者を文書化すること
⇒＃
当の~APIを利用している作者が良い~codeをどう書するべきか／
当の~APIの実装者が拙く書された~codeをどう取扱うべきか
◎
Document both how authors should write good code using your API, and how implementers of your API should handle poorly-written code.
</p>

<p>
~webは
— とりわけ他の~platformとの比較において —
拙く形成された~markupを受容することにおいて堅牢に設計されている。
このことは、
次を意味する
⇒＃
~web~pageが~web標準の旧い~version利用していても，新たな~UAで視れる／
作者にとって，学習曲線は より~~緩やか（ `shallow^en ）になる【 習得に~~時間がかかる？易しくなる？】
◎
The web, especially in comparison to other platforms, is designed to be robust in accepting poorly-formed markup. This means that web pages which use older versions of web standards can still be viewed in newer user agents, and also that authors have a shallower learning curve.
</p>

<p>
これを~supportするため，~web仕様の書者は、
きちんと形成された~markupのみならず，拙く形成された~markupを解釈する方法を述べる必要がある。
◎
To support this, web specification writers need to describe how to interpret poorly-formed markup, as well as well-formed markup.
</p>

<p>
実装者は、［
作者が利用するよう目指しているはずの “適合な言語”
］より複階的な，
“~supportされる言語”
を理解-可能になる必要がある。
◎
Implementers need to be able to understand the "supported language", which is more complex than the "conforming language" which authors should be aiming to use.
</p>

<div class="example">
例えば，
`table$e 要素~用の`処理~model＠~HEtables#table-processing-model$は、
要素の内容が要素の内容~model【！#the-table-element:concept-element-content-model】に適合しない事例も含めて，
`table^e 要素の内容を処理する方法を説明する。
◎
For example, the Processing model for the &lt;table&gt; element explains how to process the contents of a &lt;table&gt; element, including cases where the contents do not conform to the Content model.
</div>

		</section>
		<section id="avoid-ambiguity">
<h3 title="Specify completely and avoid ambiguity">11.2. 完全に指定して多義性を避けること</h3>

<p>
特能が，どう働くべきか指定するときは、［
作者が異なる実装ごとに異なる~codeで作業するよう書する必要がない
］ほど十分な情報を与えること。
◎
When specifying how a feature should work, make sure that there is enough information so that authors don’t have to write different code to work with different implementations.
</p>

<p>
仕様による指定が不十分な場合、
実装者は他と異なる選択を為すかもしれず，その場合［
その相違点を取扱うために加的な~codeを書する
］ことを作者に強制することになる。
◎
If a specification isn’t specific enough, implementers might make different choices which force authors to write extra code to handle the differences.
</p>

<p>
実装者が［
この状況を避けるために，他の実装の詳細を検査する必要
］は、
生じるべきでない。
代わりに，仕様は、
それ自体で十分に［
完全かつ明瞭
］になるべきである。
◎
Implementers shouldn’t need to check details of other implementations to avoid this situation. Instead, the specification should be complete and clear enough on its own.
</p>

<p class="note">注記：
このことは、
実装が許可~promptの様なものを他と［
異なるように具現化できない ／異なる~UIを示せない
］ことを意味するわけではない。
◎
Note: This doesn’t mean that implementations can’t render things differently, or show different user interfaces for things like permission prompts.
</p>

<p class="note">注記：
実装者は、
仕様が［
実装を書するための十分に明瞭な情報
］を与えていない場合には，そのことについて~bugを申請するべきである。
◎
Note: Implementers should file bugs against specifications which don’t give them clear enough information to write the implementation.
</p>

			<section id="algorithms">
<h4 title="Define algorithms clearly">11.2.1. ~algoを明瞭に定義すること</h4>

<p>
~algoは、
明瞭かつ簡潔な仕方で書すること。
◎
Write algorithms in a way that is clear and concise.
</p>

<p>
~algoを書する最も共通な仕方は、
明示的な一連の段で書することである。
これは、
疑似-~codeの様な見かけになることが多い。
◎
The most common way to write algorithms is to write an explicit sequence of steps. This often looks like pseudo-code.
</p>

<div class="example">
`showModal()＠~HEinteractive#dom-dialog-showmodal$c
~methodは、
付番された一連の段として述べられ，［
例外をいつ投出して，~HTML仕様を成す他の各部にて定義される~algoをいつ走らすか
］を明瞭に説明する。
◎
The showModal() method is described as a numbered sequence of steps which clearly explains when to throw exceptions and when to run algorithms defined in other parts of the HTML spec.
</div>

<p>
一連の段を書するときは、
それが機能上は~code片であると想像すること。
◎
When writing a sequence of steps, imagine that it is a piece of functional code.
</p>
<ul>
	<li>
入力と出力を明瞭に指定すること。
◎
Clearly specify the inputs and outputs,＼
</li>
	<li>
それが利用する~algoと変数をきちんと命名すること。
◎
name the algorithm and the variables it uses well,＼
</li>
	<li>
当の~algo内で［
結果を返す／~errorになる
］箇所を明示的に注記すること。
◎
and explicitly note the points in the algorithm where the algorithm may return a result or error.
</li>
	<li>
副作用がある~algoを書するのは、
アリな限り避けること。
◎
As much as possible, avoid writing algorithms which have side effects.
</li>
</ul>

<p>
手続きの詳細~に入る前に
— 読者が当の手続き全体を読するか飛ばすか裁定できるよう —
当の~algoの目的を要約すること。
例えば
⇒
“この手続きは、
各`~top-level閲覧~文脈＠~HTMLds#top-level-browsing-context$に在る処理待ち X ~callbackは 1 個までに限られることを確保する。”
◎
Summarize the purpose of the algorithm before going into detail, so that readers can decide whether to read the steps or skip over them. For example take the following steps, which ensure that there is at most one pending X callback per top-level browsing context.
</p>

<p>
素な手続き（一連の段）は、
常に~algoを書する最善な仕方になるとは限らない。
例えば、
正式な［
構文や文法
］を定義したり再利用して繰返nを避ける，
あるいは［
利用される特定の状態を状態~機械~内で定義する
］方がイミを成すかもしれない。
その様な加的な構成子を利用するときでも、
上述した助言は適用される。
◎
A plain sequence of steps is not always the best way to write an algorithm. For example, it might make sense to define or re-use a formal syntax or grammar to avoid repetition, or define specific states to be used in a state machine. When using extra constructs like these, the earlier advice still applies.
</p>

<p>
~algoは、
それがどう実装されるかにアリな限り近くなるよう述べること。
これは，仕様を書するのを難しくし得るが、
その実装は［
仕様にて書されたものを，実際にどう実装するべきか翻訳する方法
］を解明する必要がなくなることを意味する。
特に，そうしないことは、
実装ごとに異なる裁定が下される結果，後の特能が［
ある実装では実現可能な一方で，別の実装では そうならないもの
］に至り得ることを意味し得る。
◎
As much as possible, describe algorithms as closely as possible to how they would be implemented. This may make the spec harder to write, but it means that implementations don’t need to figure out how to translate what’s written in the specification to how it should actually be implemented. In particular, that may mean that different implementations make different decisions that may lead to later features being feasible in one implementation but not another.
</p>

<div class="example">
~CSS選択子は、
先頭から順に読され, 解されるが、
実施においては，実装は末尾から順に照合する。
これは、
最も特定な項を素早く［
照合する／照合しない
］ことにより，不必要な作業を避けることを許容する。
~CSS選択子~照合~algoは、
この仕方で書される
— 多くの~CSS作者が~CSS選択子を読するであろう仕方とは逆に。
◎
CSS selectors are read and understood from left to right, but in practice are matched from right to left in implementations. This allows the most specific term to be matched or not matched quickly, avoiding unnecessary work. The CSS selector matching algorithm is written this way, instead of a hypothetical algorithm which would more closely match how CSS selectors are often read by CSS authors.
</div>

<p class="trans-note">【
とは言え、
一般に，［
実装は、
観測される結果が判別できない限り，どう実装してもよい
］原則があるので、
字義通り解釈するなら，これは施行し得ないことになる。
これは，実質的には、
要件を［
結果が満たすべき条件~群としてではなく，算出-可能な~algoとして~~形にする
］よう指定することと解釈すべきに思われる。
】</p>

<p>
次も見よ
⇒
`INFRA$r `§ ~algo＠~INFRA#algorithms$
◎
See also:
• some useful definitions and terminology from [INFRA]
</p>

			</section>
			<section id="use-flags-for-states">
<h4 title="Use explicit flags for state">11.2.2. 状態~用には明示的な~flagを利用すること</h4>

<p>
~algoを書するときは、
各~状態を~~言葉で述べる代わりに，明示的な~flagを利用すること。
◎
Instead of describing state with words, use explicit flags for state when writing algorithms.
</p>

<p class="trans-note">【
すなわち、
“〜である” や “〜している”
などのように述べる代わりに，
“〜~flag ~EQ X”
のように記すこと。
】【
実際の仕様で語 “~flag（ `flag^en ）” が利用されるのは、
とり得る状態が 2 つしかないときに限られる
— 状態が もっと多い場合、
他の語（ “〜~mode（ `mode^en ）” など）が利用される
（この節の “~flag” は、
これら状態を表現するものの総称を意味することになる）。
この~siteの和訳では、
ほとんどの真偽-~flagは
`“〜か” と記される＠index.html#dfn-flag$。
】</p>

<p>
明示的な~flagを利用すれば、［
各種~error条件において，状態が変化したかどうか／
当の~flagが述べる状態がいつ設定し直されたか
］が明瞭になる。
◎
Using explicit flags makes it clear whether or not the state changes in different error conditions, and makes it clear when the state described by the flags is reset.
</p>

			</section>
		</section>
		<section id="implementability">
<h3 title="Resolving tension between interoperability and implementability">11.3. 相互運用能と実装-能の対立に対する解決-法</h3>

<p>
ある特能を指定することには、
すべての~engineering作業と同様に，各種［
~tradeoffや妥協-法
］を比較検討することが要求される。
◎
Specifying a feature, like all engineering work, requires weighing tradeoffs and compromising.
</p>

<p>
ある特能が，各~実装者~すべてから各自の~engineにおいて実装-可能であると合意されたとしても、
当の特能を相互運用可能に仕様~化する仕方を見出すことに
— ~~関係者すべてが最善な労を尽くしても —
失敗するときもある。
◎
Sometimes, despite the best efforts of all involved, we fail to find a way to interoperably specify a feature that every implementor agrees is implementable in their engine.
</p>

<p>
進むべき道は、
`末端-利用者にとって何が最良か＠#priority-of-constituencies$に従って選ばれるベキである。
◎
Choosing a way forward should be guided by what is best for the end user.
</p>

<p>
まず，実装-能の懸念を成す資質を精査すること。
実装者が，当の特能を実装するベキではないものと
— たぶん、
それは末端-利用者にとって害になり得るものと識別した結果 —
裁定した状況においては、
当の特能を仕様~化しないことが
— それに伴い、
それを出荷した実装者は，出荷しなくすることが —
最善かもしれない。
特能を出荷しなくすることは、
利用者や作者を惑わす結果を伴い得ることを念頭に置くこと。
◎
First, examine the nature of the implementability concerns. Perhaps the implementor identified potential end-user harm and decided that the feature should not be implemented. In this situation, it may be best to not specify the feature, and for any implementors who have shipped the feature to un-ship it. Keep in mind that un-shipping features may result in user and author confusion.
</p>

<div class="example" id="sharedarraybuffer">
<p>
~Spectre攻撃が発見されたとき、
`SharedArrayBuffer$c は，どの実装においても出荷しなくされた
— それは［
~Spectre攻撃~用にも利用され得る高-精度な~timer
］を作成するためにも利用できたので。
◎
When the Spectre attack was discovered, SharedArrayBuffer was unshipped in every implementation because it can be used to create a high-precision timer that could be used for a Spectre attack.
</p>
</div>

<p>
同じ~APIが，どの~engineにおいても実装-可能であっても、
その挙動を全部的に相互運用可能にすることは，できないときもある。
各~実装~間で挙動が相違するときは、
末端-利用者への影響iを考慮しなければナラナイ。
この~approachには、
挙動における相違が`特能~検出-可能＠#feature-detect$でなくなる難点がある。
他方，将来において［
すべての実装が同じ挙動に収束することを可能化する
］よう何かを変更した場合でも、
各~siteは，その利点を採るために更新する必要はなくなる。
◎
Sometimes the same API is implementable in every engine, but its behavior cannot be made to be fully interoperable. Whenever behavior differs between implementations, the end-user impact must be considered. One downside to this approach is that the difference in behavior is not feature detectable. On the other hand, if something changes in the future that enables all implementations to converge on the same behavior, sites will not need to be updated to take advantage of this.
</p>

<p class="note">注記：
作者たちは、
支配的な実装の挙動が正しいもので，他の挙動は~bug含みであると見做すようになることもある
— それは、
支配的な実装を更に定着させ得る。
◎
Note: Authors may assume the behavior of the dominant implementation is correct and any other behavior is buggy, which may further entrench the dominant implementaiton.
</p>

<div class="example" id="backdrop-filter">
<p>
`backdrop-filter$p ~propの挙動は、
各~実装~間で いくつか可視な相違があることが既知である。
それに対し作業している者たちは、
~~現時点では，［
~APIを共有する便益の方が，これらの相違を相互運用可能にする~costより勝る
］ものと予見している。
◎
The backdrop-filter property is known to have a number of visible behavior differences between implementations. At the present time, those working on it believe the benefits of sharing an API outweigh the interoperability costs of the differences.
</p>
</div>

<p>
挙動の相違点が十分に深刻で，それ以上~収束し得ない場合、
異なる~APIを指定して，各~実装者が そのような実装-可能な代替と伴に行く方が好ましいこともある。
◎
If behavior differences are serious enough, and cannot be converged further, it may be preferable to specify different APIs, with each implementor going with the alternative that they are able to implement.
</p>

<p>
この~approachには、
次を伴い得る~riskがある
⇒
実装が最終的に同じ挙動に収束-可能な場合でも，
複数の代替な~APIを不定期に~supportする必要がある結果、
開発者にとって，複階性と実装を保守する~costが増える。
◎
One risk of this approach comes about if implementations are eventually able to converge on the same behavior. In this case, multiple alternative APIs may need to be supported indefinitely, which can increase developer complexity and implementation maintenance costs.
</p>

<p>
同じ利用事例に取組むことが意図される 2 つの異なる~APIを公開すると、
作者は，［
`特能~検出＠#feature-detect$を利用して，各~browser用に異なる~codeを書する
］よう強制される。
◎
Exposing two different APIs that are intended to address the same use cases forces authors to use feature detection to write different code for different browsers.
</p>

<p class="note">注記：
そこには、
作者たちが［
支配的な実装が~supportする~API変種を “正しいもの” であると見做すようになる／
単純に，普段は利用しない実装が~supportする~API変種に~~気付かない
］かもしれない~riskがある
— それは、
支配的な実装を更に定着させ得る。
◎
Note: There is a risk that authors may assume the API variant supported by the dominant implementation is the "correct" one, or they may simply be unaware of the API variants supported in implementations they do not use regularly, which may further entrench the dominant implementaiton.
</p>

<p>
この道へ行く場合、
各~API~間の相違点を最小~化することにより，
作者の~costを抑制するよう試行すること。
標準でない部分を［
小さくして，より大きな標準~化された~frameworkから隔離された~componentにする
］よう設計することがアリな場合もあろう。
◎
If you do go this route, try to reduce the cost to authors by minimizing the differences between the APIs. It may be possible to design things such that the non-standard part is a small, isolated component of a larger, standardized framework.
</p>

<div class="example" id="eme-and-payment-request">
<p>
非-標準な~componentを他の（共有された）~API表面から隔離することにより，
~API相違点を最小~化した仕様を成す例には，次が挙げられる
⇒＃
`ENCRYPTED-MEDIA$r （の`内容~解読~module＠https://w3c.github.io/encrypted-media/#dfn-cdm$）,
`payment-request$r （の`支払い~method~manifest＠~TR/payment-method-manifest/$cite）
◎
[ENCRYPTED-MEDIA] and [payment-request] are both examples of specifications which minimize API differences by isolating a non-standard component (Content Decryption Modules and payment methods, respectively) from the rest of the (shared) API surface.
</p>
</div>

<p>
ある~groupが、
ある~APIを仕様~化することを［
一部の実装は，それを実装する用意がない
］ことを知りながら，選ぶときもある。
作者は［
特能~検出を利用して，そのような~APIを可用なときに限り利用する
］ようになり，利用者は［
そのような特能が~supportされ，利用されるときに便益を得られる
］ようになることもあろう。
が、
その結果は，常に問題になり得る
— 実装する用意がある実装が 1 つしかないときは、
最悪になる。
一部の標準~化の場には、［
ある特能に関心がある実装が一つしかない場合，その標準~化を許容しない
］とする明示的な規則がある。
そのような~groupに従事していようが、
実装が一つしかない特能を標準~化することは，強く忌避される。
◎
Groups sometimes choose to specify APIs knowing that some implementations are unwilling to implement it. Authors may use feature detection to only use APIs when they are available, and users may benefit where such features are supported and used. This is always a problematic outcome, though it is worst when there is only one willing implementor. Some standards venues have rules explicitly disallowing the standardization of features which only have a single interested implementor. Even if you are not operating in such a group, standardization of single-implementation features is strongly discouraged.
</p>

<p>
ある~groupは、
これらの~optionが どれも受容-可能でないことを見出す場合もあろう。
当の特能を仕様~化しないことを選ぶのが最善な道になる場合もあろうが、
一部の実装が当の特能を非-標準な~APIとして出荷し得る~riskもある。
◎
You may also find that none of these options is acceptable to your group. While the best path forward may be to choose not to specify the feature, there is the risk that some implementations may ship the feature as a nonstandard API.
</p>

		</section>
		<section id="monkey-patching">
<h3 title="Avoid monkey patching">11.4. ~monkey~patchすることは避けること</h3>

<p>
`~monkey~patchする@
とは、
既存の仕様の挙動を［
拡張するか上書きする, あるいは改変する
］仕方で，
既存の仕様の上に新たな機能性の層を重ねることである。
`~monkey~patchすること＠https://en.wikipedia.org/wiki/Monkey_patch$は、
以下に挙げる理由により，
`一般に不良な実施であり，避けるベキもの^strongと見なされる
— ときには、
不可避なこともあるが
（`§ ~monkey~patchする必要がある場合＠#cant-avoid-monkey-patching$の指導を見よ）。
◎
A monkey patch layers new functionality on top of an existing specification in a way that extends, overrides, or otherwise modifies the existing specification’s behavior. Monkey patching is generally considered bad practice and should be avoided for the reasons listed below; but is sometimes unavoidable (see our guidance if you need to monkey patch).
</p>

<p>
~monkey~patchする例として、
次が挙げられる
⇒
ある仕様が自身の能力の一部を成す内部的な~algoを定義していて、
別の仕様が新たな機能性で当の~algoを
— 前者の仕様が公に定義した拡張~地点を利用することなく —
直に［
上書きする／改変する
］。
◎
An example of monkey patching would be: specification A defines an internal algorithm part of its capability, then specification B overrides or modifies said algorithm with functionality directly, not using publicly defined extension points.
</p>

<p>
そのように~monkey~patchすることは、
当の下層の機能性が決して変更されないものと（間違って）決めつけることに等しい。
これは、
次に挙げる問題に至らせ得る：
◎
As such, monkey patching (wrongly!) presupposes that underlying functionality cannot, and will not, be changed. This can lead to several problems:
</p>
<ul>
	<li>
既存の仕様が変更された場合、
当の~monkey~patchした~textは，もはや適用されなくなり得る
— その結果、［
非互換化する／混同へ至らす
］原因になる。
◎
If the existing specification changes, the monkey patched text may no longer apply thus causing it to break or lead to confusion.
</li>
	<li>
いくつかの仕様が既存の【！別の】仕様を成す一部を~monkey~patchした場合、
それらの~patchが適用される順序により，挙動が一貫しなくなり得る。
【例：どれか一つの~patchしか適用されなくなるなど。】
◎
If several specifications monkey patch part of another spec, the order in which the patches are applied can lead to inconsistent behavior.
</li>
	<li>
既存の仕様の策定者は、
別の【！your】仕様において~monkey~patchされた~textについて自覚しないこともあろう。
その結果、
修正-について総意へ達するための指導を受取る機会も失われる。
さらには、
~patchされた挙動が他の課題や挙動にも相互に関係している場合，状況は総合的に悪化しかねない。
◎
The existing specification authors may not be aware of the monkey patched text in your spec. This misses an opportunity to receive guidance on reaching consensus on a fix. Or worse, the behavior that is being patched is interrelated to so other issue or behavior, making the overall situation worse.
</li>
	<li>
~codeの保守を行っている実装者は，下層の仕様しか読してない結果、
~monkey~patchされた挙動を~bugと見做して，不作為に元へ復帰することもあろう。
◎
An implementer doing code maintenance may read underlying specification and inadvertently revert the monkey patched behavior assuming it is a bug.
</li>
</ul>

<p>
Wikipedia は、
`~monkey~patchすることによる追加的な陥穽＠https://en.wikipedia.org/wiki/Monkey_patch#Pitfalls$についても述べている。
◎
Wikipedia also describes some additional pitfalls of monkey patching.
</p>

			<section id="cant-avoid-monkey-patching">
<h4 title="If you need to monkey patch">11.4.1. ~monkey~patchする必要がある場合</h4>

<p>
ときには、
~monkey~patchすることが不可避なこともある
（例：ある新たな仕様の早期-設計~相）。
既存の仕様を~monkey~patchする必要があることを見出した場合、
次に従うこと：
◎
Sometimes monkey patching is unavoidable (e.g., early in the design phase of a new specification). If you find yourself needing to monkey patch an existing specification, make sure you:
</p>
<ol>
	<li>
<p>
当の~monkey~patchは［
別の仕様に対し提案された変更であり，当の仕様において一時的に限られる
］ことが明瞭になるよう，当の仕様~内の該当する箇所を明瞭に~markすること
— 次の様な文言を利用して：
◎
In your spec, clearly mark the monkey patch as a proposed change to another specification that is only temporarily in this specification, using language like:
</p>

<div class="example">
【！ class="language-markdown"】
<pre>
# ~HTTP~fetchを改変する

&lt;p class="issue"&gt;十分な総意を得たなら，これを `Fetch^r の中へ併合する。&lt;/p&gt;
◎
Merge this into [[Fetch]] once it has enough consensus.

</pre>
◎
# Modify HTTP fetch

&lt;p class="issue"&gt;Merge this into [[Fetch]] once it has enough consensus.&lt;/p&gt;
</div>

	</li>
	<li>
<p>
変更したいと求める箇所を識別すること
— 該当する箇所の~textを引用するか、
用語の定義を置換している場合には，当の用語へ~linkすることにより。
~algo内のある段など，付番された何かを変更している場合、
その番号を含めること。
ただし、
番号だけでは足らないことに留意すること
— 番号は他の段が［
追加される／除去される
］と変化するので。
ある定義の中のいくつかの箇所を変更している場合、［
`&lt;blockquote&gt;^c の中へ当の定義~全体を~pasteした上で，
`&lt;ins&gt;^c や `&lt;del&gt;^c を利用する
］ことにより，何を変更しているか述べる方が助けになり得る。
◎
Identify the place you want to change using a quote from its text or by linking to a defined term if you’re replacing that term’s whole definition. Include the current step numbers if you’re changing something that’s numbered, but remember that numbers aren’t sufficient by themselves because they change when other steps are added or removed. If you’re changing several places within a definition, it can be helpful to paste the entire definition into a &lt;blockquote&gt; and use &lt;ins&gt; and &lt;del&gt; to describe what’s changing.
</p>

<div class="example">
<p>
`~HTTP~fetch＠~FETCH#concept-http-fetch$を成す段 4.2
⇒
~IF［
要請の~redirect~mode ~EQ `follow^l
］
⇒
要請の~sw~mode ~SET `none^l
◎終
の前に，次の段たちを挿入する
⇒
1 個目の新たな段…
◎
Before step 4.2 of HTTP fetch, "If request’s redirect mode is "follow", then set request’s service-workers mode to "none".", insert the following steps:
• The first new step.
</p>
</div>

<div class="example">
<p>
`CSS2$r `§ 通常~flow内にある塊~levelの置換されない要素＠~CSS2J#blockwidth$
における “拘束され過ぎ” なときの算出~用の規則は、
ここに指定される整列への支持を受けて，無視される
— したがって、
各種~margin~propの使用~値は，拘束され過ぎを正すよう調整されない。
◎
In terms of CSS2.1 block-level formatting [CSS2], the rules for “over-constrained” computations in CSS 2 § 10.3.3 Block-level, non-replaced elements in normal flow are ignored in favor of alignment as specified here and the used value of the margin properties are therefore not adjusted to correct for the over-constraint.
</p>
</div>

<div class="example">
<p>
`URLSearchParams$I の［
`delete()＠~URL1#dom-urlsearchparams-delete$c,
`has()＠~URL1#dom-urlsearchparams-has$c
］の定義に，
~parameterとして
<code>optional USVString %value</code>
を付加する：
◎
Append optional USVString value parameters to the definitions of URLSearchParams.delete() and URLSearchParams.has():
</p>

<pre class="idl">
partial interface URLSearchParams {
  undefined delete(USVString name<ins>, optional USVString value</ins>);
  boolean has(USVString name<ins>, optional USVString value</ins>);
};
</pre>
</div>

<div class="example">
<p>
`font-size-adjust$p の定義を次に従って改変すること：
</p>

◎名 `font-size-adjust＠#propdef-font-size-adjust@p
◎値
`none^v | <ins>[ `ex-height^v | `cap-height^v | `ch-width^v | `ic-width^v | `ic-height^v ]? [ `from-font^v | </ins> `number$t <ins>]</ins>
◎初 `none^v
◎適 すべての要素／~text
◎継 される
◎百 受容しない
◎算
<del>
実数／~keyword `none^v
</del>
<ins>
~keyword `none^v ／
( 計量~keyword, `number$t ) が成す~pair
</ins>
◎
a number or the keyword none
◎順 文法に従う
◎ア 
<ins>
互いの~keywordが相違する場合は離散的／
他の場合は</ins>算出d値の型による
◎表終

◎
Modify the definition of font-size-adjust as follows:
◎
Name: 	font-size-adjust
Value: 	none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | &lt;number&gt; ]
Initial: 	none
Applies to: 	all elements and text
Inherited: 	yes
Percentages: 	N/A
Computed value: 	a number or the keyword none the keyword none, or a pair of a metric keyword and a &lt;number&gt;
Canonical order: 	per grammar
Animation type: 	discrete if the keywords differ, otherwise by computed value type
</div>
	</li>
	<li>
~monkey~patchは短く保つこと。
いくつもの段を追加することにより，ある~algoを改変している場合、
当の仕様~内に別々な自己完結的な~algoを定義して，
当の~monkey~patchが新たな~algoを~callするようにすること。
◎
Keep monkey patches short. If you’re modifying an algorithm by adding more than a couple of steps, define a separate, self-contained algorithm in your specification, and have the monkey patch call the new algorithm.
</li>
	<li>
ある~algoにおいて段たちを［
置換して／追加して
］いる場合、
新たな段を書すること
— 編集者が上流~algoの中へ そのまま~pasteできるよう。
このことは、
“返る” や “中止する” 【~RET】の様な制御~flowは
— 当の~monkey~patchされた~~区間のみならず —
上流~algoそれ自体［
から返る／を中止する
］ことを含意する。
◎
If you’re replacing or adding steps in an algorithm, write the new steps so an editor can paste them verbatim into the upstream algorithm. This implies that control flow like "return" or "abort" will return or abort from the whole upstream algorithm, not just the monkey patched section.
</li>
	<li>
当の特能が自前の~communityの中で考査され，
それは良い案である総意が得られたと見受けられたなら、
既存の仕様に対し課題を申請して，
~monkey~patchを考査するよう上流~communityに依頼すること。
上流~communityは、
当の目標を成遂げるための もっと良い仕方を示唆することもある
— それらを真剣に受け取ること。
彼らは、［
既存の拡張~地点の中へ~hookする／
拡張~地点を素早く作成する
］方法を~~伝えることもあろう
— 当の~monkey~patchを期待されるより早く除去できるよう。
◎
Once your feature has been reviewed within your own community, and there seems to be consensus that it’s a good idea, file an issue against the existing specification that asks the upstream community to review your monkey patch. This community may suggest better ways to accomplish your goals. Take them seriously. They might also be able to tell you how to hook into an existing extension point or quickly create one so that you can remove your monkey patch sooner than you expected.
</li>
	<li>
上で言及した
`&lt;p class="issue"&gt;^c ~blockを［
上流~仕様に対し申請した課題
］を指すように更新すること。
◎
Update the &lt;p class="issue"&gt; block mentioned above to point to the issue you filed against the upstream specification.
</li>
	<li>
当の作業を上流~仕様の中へ併合するための十分な~supportを得たときは、
その仕様の保守者たちと作業して，それを行うこと。
◎
When your work has enough support to merge into the upstream specification, work with that specification’s maintainers to do so.
</li>
	<li>
当の~monkey~patchが既存の仕様に統合されたなら、
当の仕様から それを除去すること。
◎
Once the existing specification has integrated your monkey patch, remove the monkey patch from your specification.
</li>
</ol>

<p>
`~monkey~patchする$ことは、
“~module化” とは異なることに注意
— ~module化は、
既存の技術を［
自己完結的かつ 他の下層の仕様には副作用が生じない仕方
］で拡張する（例：各種~CSS~module）。
~module化は、
良い実施と見なされる。
◎
Note that monkey patching is different from "modularization", which extends existing technology in a way that is self-contained and doesn’t cause side-effects to other underlying specifications (e.g., the CSS Modules). Modularization is considered a good practice.
</p>

<p>
~Web~IDLの`部分的な~interface定義$や`部分的な辞書~定義$, 等々を利用して仕様を拡張することも、
通例的に~~許容される。
が、
そのような事例でも，拡張されている仕様の策定者たちと協調することを~~強く勧める。
【例えば、他の仕様の策定者も，同じ~interfaceに属する別の部分的な~interface定義~内に同じ名前の~memberを定義しているかもしれない。】
◎
It’s also usually ok to extend a specification using WebIDL’s partial interfaces, partial dictionaries, and so on. But even in those cases, it’s highly advisable to coordinate with the authors of the specification being extended.
</p>

			</section>
		</section>
	</section>
	<section id="naming-is-hard">
<h2 title="Naming principles">12. 命名~原則</h2>

<p>
名前は、
次に挙げるものから意味をとること：
◎
Names take meaning from:
</p>
<ul>
	<li>
`signposting^en（ “標識” — 名前~それ自体）
◎
signposting (the name itself)
</li>
	<li>
利用（人々が当の名前を どう時間~越しに理解していくか）
◎
use (how people come to understand the name over time)
</li>
	<li>
文脈
（例えば、当の名前に前置される~obj）
◎
context (the object on the left-hand side, for example)
</li>
</ul>

		<section id="naming-common-words">
<h3 title="Use common words">12.1. 共通的な単語を利用すること</h3>

<p>
~APIは、
容易に可読な米国~英語で命名されなければ`ナラナイ^em
【例： `colour^en （英）ではなく `color^en （米）】。
ほとんどの~web開発者は、
~nativeな英語~話者でないことを念頭に置くこと。
アリなときは、
名前は，共通的な語彙
— 英語~話者の大多数が，当の名前に最初に遭遇したときでも理解すると見込まれる語彙 —
を利用するように選ぶべきである。
◎
API naming must be done in easily readable US English. Keep in mind that most web developers aren’t native English speakers. Whenever possible, names should be chosen that use common vocabulary a majority of English speakers are likely to understand when first encountering the name.
</p>

<div class="example">
例えば、
`cardinality^en 【 “（集合の）~~濃度” 】より `setSize^en 【 “集合の~size” 】の方が，
英語として可読な名前である。
◎
For example setSize is a more English-readable name than cardinality.
</div>

<p>
~~短さより可読性に価値をおくこと。
略語は、
それが極めて共通的にある, かつ容易に理解される事例を除いて，避けること
— 例えば、
`UIEvent^c の "`UI^c" は，
`user interface^en【利用者~interface】の略称を成す。
しかしながら、
名前は短くした方が明瞭になることが多いことを念頭に置くこと。
一例として、
当の仕様~内で当の~APIが定義される所では，［
専門用語／周知な成句的用語
］を利用する方が適切になる場合もある。
◎
Value readability over brevity. Avoid abbreviations, except in cases where an abbreviation is extremely common and easy to understand. For example UIEvent, where "UI" stands for user interface. Keep in mind, however, that the shorter name is often the clearer one. For instance, it may be appropriate to use technical language or well-known terms of art in the specification where the API is defined.
</p>

<div class="example">
例えば， `FETCH$r ~APIの `Body$I ~mixinの
`json()＠~FETCH#dom-body-json$c
~methodは、
それが返す【~Promiseの~parameterを成す】~objの種類に基づいて命名された。
“JSON” は、
この~APIを利用する~web開発者たちには周知と見込まれる成句的用語である。
この~methodの名前を，その返り値~型と縁遠いものにすると、
~~理解し難くなろう。
◎
For example, the Fetch API’s Body mixin’s json() method is named for the kind of object it returns. JSON is a well-known term of art among web developers likely to use the Fetch API. It would harm comprehension to name this API less directly connected to its return type. [FETCH]
</div>

		</section>
		<section id="naming-charset">
<h3 title="Use ASCII names">12.2. ~ASCII名を利用すること</h3>

<p>
名前は、
当の言語に局所的な制約を固守しなければナラナイ
— 例えば，~CSSの `ident$t 規則, 等々。
名前は、
`~ASCII範囲$内にする`べきである^em。
◎
Names must adhere to the local language restrictions, for example CSS ident rules etc. and should be in the ASCII range.
</p>

		</section>
		<section id="naming-consultation">
<h3 title="Consult others on naming">12.3. 命名-時には他者／他所に諮ること</h3>

<p>
当の~APIにおける名前を広く諮ること
— 思いがけない場所で，良い名前や ひらめきを見出すこともあろう：
◎
Consult widely on names in your APIs.
◎
You may find good names or inspiration in surprising places.
</p>
<ul>
	<li>
他の~platformの類似な~APIや，様々な~programming言語に普及な~libraryでは、
何と命名されているか？
◎
What are similar APIs named on other platforms, or in popular libraries in various programming languages?
</li>
	<li>
当の~APIで［
作業する／操作する
］ものを何と呼んでいるか，末端-利用者や開発者に訊いてみること。
◎
Ask end users and developers what they call things that your API works with or manipulates.
</li>
	<li>
他の~web~platform仕様を調べて，
~platformに関係する分野で作業している他者からの助言を探求すること。
◎
Look at other web platform specifications, and seek advice from others working in related areas of the platform.
</li>
	<li>
利用される名前は包括的かどうかも諮ること。
◎
Also, consult if the names used are inclusive.
</li>
</ul>

<p>
［
下層の原則に基づいて明瞭に言明された合理性
］を伴う助言を受取ったときは、
特に注意を払うこと。
◎
Pay particular attention to advice you receive with clearly-stated rationale based on underlying principles.
</p>

<div class="example">
`Tantek Çelik^en 氏は、
~URLを成す様々な各部がどう命名されているか
`多方面で事実調査した＠https://tantek.com/2011/238/b1/many-ways-slice-url-name-pieces$
。
`~URL仕様＠~URL1$ `URL$r
の編集者は、
その文書を編集するときに，この事実調査に依拠した。
◎
Tantek Çelik extensively researched how to name the various pieces of a URL. The editors of the URL spec have relied on this research when editing that document. [URL]
</div>

			<section id="naming-web-consistency">
<h4 title="Use Web consistent names">~webと一貫した名前を利用すること</h4>

<p>
他の技術~stackに公開される［
特能／~API
］用に名前を選ぶときであっても、
他の~communityではなく，~Web~ecosystemの命名~規約を選好するべきである。
◎
When choosing a name for feature or API that has exposure in other technology stacks, the preference should be towards the Web ecosystem naming convention rather than other communities.
</p>

<div class="example">
~NFC標準は、
~Webが`~MIME型＠~MIMESNIFF#mime-type-representation$（ `MIME type^en ）と呼ぶものを指して，
用語 `media^en を利用する。
【 `NFC^en は、 `Near Field Communication^en （近距離無線通信）の略語。】
そのような事例では，~Web~NFCの目的においては、
特能や~APIの命名は “~MIME型” と一貫する名前を選好しなければナラナイ。
◎
The NFC standard uses the term media to refer to what the Web calls MIME type. In such cases, the naming of features or API for the purposes of Web NFC must prefer naming consistent with MIME type.
</div>

			</section>
			<section id="naming-inclusive">
<h4 title="Use Inclusive Language">包括的な文言を利用すること</h4>

<p>
アリなときは、
包括的な文言（ `inclusive language^en ）を利用すること。
◎
Use inclusive language whenever possible.
</p>

<p>
例えば、［
`blacklist^en ／ `whitelist^en
］†に代えて［
`blocklist^en 【 “阻止-~list” 】／ `allowlist^en 【 “許容-~list” 】
］を利用するべきであり，［
`master^en ／ `slave^en
］†に代えて［
`source^en ／ `replica^en
］を利用するべきである。
◎
For example, you should use blocklist and allowlist instead of blacklist and whitelist, and source and replica instead of master and slave.
</p>

<p class="trans-note">【†
これらは、
`差別語を連想させるので＠https://whatwg.org/style-guide#tone$。
挙げられた例からは、
“`inclusive language^en” は，
この意味合い
— “人に対し，［排他的／差別的］でない” —
を特に指していると見受けられるが、
より広い意味合いもあるかもしれない。
】</p>

<p>
汎用な人物
— 作者, 利用者など —
を指す必要がある場合、
汎用な代名詞 "`they^en", "`their^en", 等々を利用すること。
例えば
⇒
“利用者は、
自身の（ `their^en ）選好を調整したいと望むこともある”
◎
If you need to refer to a generic persona, such as an author or user, use the generic pronoun "they", "their", etc. For example, "A user may wish to adjust their preferences".
</p>

<p class="trans-note">【
この規約は、
性別を示唆する人称~代名詞
— “`he^en” や “`she^en” など —
の利用は避けるべきであることを意図しているようにも思われる。
和訳では、
上の例文のように “`their^en” の対訳に（複数形でない） “自身の” を利用したり，
代名詞ではなく同じ語
— “利用者” など —
を繰返すことが多い。
ときには “彼ら” としか訳しようがないこともあるが
（仕様に現れる “彼ら” が性別も含意することは、ほぼ決してない）。
】</p>

			</section>
		</section>
		<section id="naming-future-proofing">
<h3 title="Use names that describe a purpose">12.4. 名前には目的を述べるものを利用すること</h3>

<p>
どう行うかではなく，何を行うかを表すよう命名すること。
◎
Name things for what they do, not how they do it.
</p>

<p>
目的を反映する名前の方が，
将来にも通用する見込みは高い。
`~webから~APIを除去することは困難＠#removing-features$なので、
名前は，実装の詳細よりも長持ちする必要がある。
◎
Names that reflect a purpose are more likely to be future-proof. Removing APIs from the web is difficult, so names need to outlast any implementation detail.
</p>

<p>
特に、
名前には［
~code名／銘柄／能力を実装するために利用された技術の詳細
］の利用を避けるべきである。
これらは、
廃用にされ得るので，
将来には置換される必要が生じるかもしれない。
◎
In particular, names should avoid the use of code names, branding, or details of the technology used to implement capabilities. These can become obsolete and might need to be replaced in the future.
</p>

<div class="example">
`~remote再生~API^cite `REMOTE-PLAYBACK$r は、
その発想元であった既存の~proprietaryな~system
（ `Chromecast^en や `AirPlay^en など）
より後に命名されたが，当の~APIが行うものを述べる一般~用語が選ばれた。
◎
The Remote Playback API was not named after one of the pre-existing, proprietary systems it was inspired by (such as Chromecast or AirPlay). Instead, general terms that describe what the API does were chosen. [REMOTE-PLAYBACK]
</div>

<div class="example">
`~WebTransport~API^cite `WebTransport$r は、
`~QUIC~protocol^cite `RFC9000$r により供される~networking能力を可能化する。
しかしながら，この名前は、
より一般な，~dataを~transportする目的を反映する。
◎
The WebTransport API enables the networking capabilities provided by the QUIC protocol. However, the name reflects the more general purpose of transporting data. [WebTransport][RFC9000]
</div>

		</section>
		<section id="naming-consistency">
<h3 title="Name things consistently">12.5. 一貫するよう命名すること</h3>

<p>
命名~schemeは、
混同を避けるため，一貫性を目指すべきである。
◎
Naming schemes should aim for consistency, to avoid confusion.
</p>

<p>
関係する名前たちが成す集合は、
次について，互いに一致するべきである：
◎
Sets of related names should agree with each other in:
</p>
<ul>
	<li>
品詞
— 名詞, 動詞, 等々。
◎
part of speech - noun, verb, etc.
</li>
	<li>
否定法
— 例えば，集合を成す各~名前は、
次のどちらかにするべきである
⇒＃
すべてが，何が許容されるかを述べる／
すべてが，何が否認されるかを述べる
◎
negation, for example all of the names in a set should either describe what is allowed or they should all describe what is denied
</li>
</ul>

			<section id="naming-booleans">
<h4 title="Boolean properties vs. boolean-returning methods">真偽値をとる~prop 対 真偽値を返す~method</h4>

<p>
真偽値をとる［
~prop【~IDL属性】／~option【通例的には辞書~member】／何かについて問う~API引数
］には、
`is^c は接頭される`べきでない^em。
一方で，同じ目的を~serveする~methodは、
それに副作用は無いならば
— ~platformの他所すべてと一貫するよう —
`is^c が接頭される`べきである^em。
◎
Boolean properties, options, or API arguments which are asking a question about their argument should not be prefixed with is, while methods that serve the same purpose, given that it has no side effects, should be prefixed with is to be consistent with the rest of the platform.
</p>

			</section>
			<section id="casing-rules">
<h4 title="Use casing rules consistent with existing APIs">既存の~APIと一貫した文字大小規則を利用すること</h4>

<p>
~web~platform~API設計の歴史を通して，常に一様に従われてはなかったが、
次に挙げる文字大小規則が判明している：
◎
Although they haven’t always been uniformly followed, through the history of web platform API design, the following rules have emerged:
</p>

<div>
<dl>
	<dt>
~method／~prop
（~Web~IDLの属性, 演算, 辞書~key）
【／~methodの引数】
</dt>
	<dd>
~camel-case
</dd>
	<dd>例：
`createAttribute()＠~DOM4#dom-document-createattribute$c,
`compatMode＠~DOM4#dom-document-compatmode$c
</dd>

	<dt>
~class／~mixin（~Web~IDL~interface）
</dt>
	<dd>
~pascal-case
</dd>
	<dd>例：
`NamedNodeMap$I,
`NonElementParentNode$I
</dd>

	<dt>
~APIにおける頭字語（ `initialism^en ）
</dt>
	<dd>
~method／~prop内の最初の単語になる場合を除いて，すべて大字
</dd>
	<dd>例：
`HTMLCollection$I,
`innerHTML＠~HTMLdynamic#dom-element-innerhtml$c,
`bgColor＠~HTMLLS/obsolete.html#dom-document-bgcolor$c
</dd>

	<dt>
~APIにおける頭字語の繰返n
</dt>
	<dd>
同じ規則に従う
</dd>
	<dd>例：
`HTMLHRElement$I,
`RTCDTMFSender$I
</dd>

	<dt>
“`of "identity"/"identifier"^en （〜の~~識別情報／~~識別子）” の略語
</dt>
	<dd>
~method／~prop内の最初の単語になる場合を除いて， `Id^en
</dd>
	<dd>例：
`getElementById()＠~DOM4#dom-nonelementparentnode-getelementbyid$c,
`pointerId＠~POINTEREVENTS#dom-pointerevent-pointerid$c,
`id＠https://w3c.github.io/webappsec-credential-management/#dom-credential-id$c
</dd>

	<dt>
列挙~値
</dt>
	<dd>
小文字, ~dashで区切られる
</dd>
	<dd>例：
`no-referrer-when-downgrade＠~REFERRER-POLICY#dom-referrerpolicy-no-referrer-when-downgrade$l
</dd>

	<dt>
~event
</dt>
	<dd>
小文字, 連結される
</dd>
	<dd>例：
`canplaythrough＠~HEmedia#event-media-canplaythrough$et,
`languagechange＠~HTMLindex#event-languagechange$et
</dd>

	<dt>
~HTML要素／属性
</dt>
	<dd>
小文字, 連結される
</dd>
	<dd>例：
`figcaption$e,
`maxlength＠~HTMLforms#attr-fe-maxlength$a
</dd>

	<dt>
~JSON~key
</dt>
	<dd>
小文字, ~underscoreで区切られる
</dd>
	<dd>例：
`short_name＠~APPMANIFEST#dfn-short_name$c
</dd>
</dl>

◎
｜Casing rule｜Examples
Methods and properties
(Web IDL attributes, operations, and dictionary keys)｜Camel case｜createAttribute()
compatMode
Classes and mixins
(Web IDL interfaces)｜Pascal case｜NamedNodeMap
NonElementParentNode
Initialisms in APIs｜All caps, except when the first word in a method or property｜HTMLCollection
innerHTML
bgColor
Repeated initialisms in APIs｜Follow the same rule｜HTMLHRElement
RTCDTMFSender
The abbreviation of "identity"/"identifier"｜Id, except when the first word in a method or property｜getElementById()
pointerId
id
Enumeration values｜Lowercase, dash-delimited｜"no-referrer-when-downgrade"
Events｜Lowercase, concatenated｜canplaythrough
languagechange
HTML elements and attributes｜Lowercase, concatenated｜figcaption
maxlength
JSON keys｜Lowercase, underscore-delimited｜short_name
</div>

<div class="non-normative">

<p>
特に，~HTMLの内容~属性【！属性】が~propとして`反映-$されるとき、［
属性, ~prop
］の文字大小~法は合致するとは限らないことに注意。
例えば，
~HTML `img$e 要素の `ismap＠~HEimages#attr-img-ismap$a 属性は、
`HTMLImageElement$I の
`isMap＠~HTMLimages#dom-img-ismap$c
~propとして`反映-$される。
◎
Note that in particular, when a HTML attribute is reflected as a property, the attribute and property’s casings won’t necessarily match. For example, the HTML attribute ismap on img elements is reflected as the isMap property on HTMLImageElement.
</p>

<p>
~JSON~key用の規則は、［
~HTTP越しに送信された／~diskに格納された
］特定の~JSON~file形式に適用することが意味され，~JS~obj~keyの一般~観念には適用されない。
◎
The rules for JSON keys are meant to apply to specific JSON file formats sent over HTTP or stored on disk, and don’t apply to the general notion of JavaScript object keys.
</p>

<p>
特に，頭字語の繰返nは、
~platform全体を通して一様ではない。
歴史的な悪名高い例は、［
`XMLHttpRequest$I ／ `HTMLHtmlElement$I
］であり，上の規則に違反している。
これらの例には従わないこと
— 頭字語が繰返される場合、
代わりに，常に大字~化すること。
◎
Repeated initialisms are particularly non-uniform throughout the platform. Infamous historical examples that violate the above rules are XMLHttpRequest and HTMLHtmlElement. Don’t follow their example; instead always capitalize your initialisms, even if they are repeated.
</p>
</div>

			</section>
			<section id="factory-naming">
<h4 title="Start factory method names with create or from">~factory~methodの名前は［ `create^c ／ `from^c ］から開始すること</h4>

<p>
~factory~methodの名前は［
`create^c ／ `from^c
］から開始するベキである
— 任意選択で，より特定な名詞も後続させて。
◎
Factory method names should start with create or from, optionally followed by a more specific noun.
</p>

<p>
ある~factory~methodが新たな空な~objを構築する場合、
当の~methodの名前には `create^c を接頭すること。
しかしながら，
当の~factory~methodが既存の~dataから~objを作成する場合には、
`from^c を接頭すること。
◎
If a factory method constructs a new empty object, prefix the method name with create. However, if your factory method creates an object from existing data, prefix the method name with from.
</p>

<p>
~factory~methodは、
規範ではなく例外に類するベキであり，
`妥当な理由＠#constructors$があるとき以外は利用するベキでない。
~factory~methodの妥当な用法を成す例として、［
作成される~objには親~objとの結付けも要求される
］ときが挙げられる
（例： `document.createXXX()^c ）。
◎
Factory methods should be an exception, not the norm, and only used for valid reasons. An example of valid usage of a factory method is when an object is being created also requires association with the parent object (e.g. document.createXXX()).
</p>

<p>
［
~target~objへ変換されるものと期待される~source~obj
］が在るときは、
接頭辞 `from^c を利用すること。
例えば， `Foo.fromBar()^c は、［
`Foo^c ~objは `Bar^c ~objを利用して作成される
］ことを含意することになろう。
◎
Use the prefix from when there is a source object expected to be converted to a target object. For example, Foo.fromBar() would imply that a Foo object will be created using a Bar object.
</p>

<p>
共通的な~patternは、
汎用な~factory~methodを［
`create()^c ／ `from()^c
］と命名することである。
◎
A common pattern is to name generic factory methods create() or from().
</p>

<p>
［
他の接頭辞を考案する／旧来の接頭辞を利用する
］ことは、
そうするための強い理由が無い限り，避けること。
そのような例外を為す理由として、［
同じ~objの下で，既存の~factory~methodとの一貫性を保守する
］ことが挙げられよう
— `document.initXXX()^c など。
新たな~factory~methodは、
この規約に従うベキでない。
◎
Avoid inventing other prefixes and using of legacy prefixes unless there is a strong reason to do so. A reason to make an exception would be to maintain consistency with existing factory methods under the same object, such as document.initXXX(). New factory methods should not follow this convention.
</p>

			</section>
		</section>
		<section id="naming-unsafe">
<h3 title="Warn about dangerous features">12.6. 危険な特能について警告すること</h3>

<p>
開発者に供される保証を弱める特能は、
アリな所では
— そのことが目立つよう —
その名前を【 “安全でない” ことを意味する】 `unsafe^l から開始するようにすること。
◎
Where possible, mark features that weaken the guarantees provided to developers by making their names start with "unsafe" so that this is more noticeable.
</p>

<p>
例えば
`~CSP＠~CSP3$（ `Content Security Policy^en ）は、
ある種の内容~注入~脆弱性に抗する保護を供する。
~CSPは、
~keyword `unsafe-inline^v など，この保証を弱める特能も供する
— それは、
~inline~scriptを許容することにより，~CSPの自前の保護を抑制する。
◎
For example, Content Security Policy (CSP) provides protection against certain types of content injection vulnerabilities. CSP also provides features that weaken this guarantee, such as the unsafe-inline keyword, which reduces CSP’s own protections by allowing inline scripts.
</p>

		</section>
	</section>
	<section id="writing-resources">
<h2 title="Other resources">13. その他の資源</h2>

<p>
仕様を書する方法に対する いくつかの有用な助言は、
他所でも可用である：
◎
Some useful advice on how to write specifications is available elsewhere:
</p>
<ul>
	<li>
`仕様の書法：言明の種類＠https://ln.hixie.ch/?start=1140242962&amp;count=1$cite
（ `Writing specifications: Kinds of statements^en ）
（ `Ian Hickson^en, 2006年 ）
◎
Writing specifications: Kinds of statements (Ian Hickson, 2006)
</li>
	<li>
`~QA~framework：仕様~指針＠~TR/qaframe-spec/$cite
（ `QA Framework: Specification Guidelines^en ）
（ ~W3C ~QA ~WG, 2005年)
◎
QA Framework: Specification Guidelines (W3C QA Working Group, 2005)
</li>
	<li>
`~privacy原則＠https://w3ctag.github.io/privacy-principles/$cite
（ `Privacy Considerations for Web Protocols^en ）
◎
Privacy Principles
</li>
	<li>
`~securityと~privacyに関する自己-考査~質問票＠~SECQ$cite
（ `Self-Review Questionnaire: Security and Privacy^en ）
◎
Self-Review Questionnaire: Security and Privacy
</li>
	<li>
`~web技術~accessibility指針＠https://w3c.github.io/apa/fast/$cite
（ `Web Technology Accessibility Guidelines^en ）
◎
Web Technology Accessibility Guidelines
</li>
	<li>
`仕様~開発者~向けの国際-化における最善な実施＠https://w3c.github.io/bp-i18n-specdev/$cite
（ `Internationalization Best Practices for Spec Developers^en ）
◎
Internationalization Best Practices for Spec Developers
</li>
</ul>

	</section>
	<section id="acks">
<h2 class="no-num heading settled" title="Acknowledgments">謝辞</h2>

<p>
この文書は、
~TAGによる`設計~考査＠https://github.com/w3ctag/design-reviews/$の間に，
~TAG~memberより［
~~過去／~~現在
］に収集された原則からなる。
その~~成果は、
~TAGから設計~考査の要請を受けた すべての方々のおかげである。
◎
This document consists of principles which have been collected by TAG members past and present during TAG design reviews. We are indebted to everyone who has requested a design review from us.
</p>

<p>
~TAGは、
次に挙げる方々による，この文書, および［
それに先行する文書である
`~HTML設計~原則＠~TR/html-design-principles/$cite
（ `HTML Design Principles^en ）
］への貢献に感謝したい。
◎
The TAG would like to thank＼
↓...
for their contributions to this &amp; the HTML Design Principles document which preceded it.
</p>

<div lang="en">
Adrian Hope-Bailie,
Alan Stearns,
Aleksandar Totic,
Alex Russell,
Alice Boxhall,
Andreas Stöckel,
Andrew Betts,
Anne van Kesteren,
Benjamin C. Wiley Sittler,
Boris Zbarsky,
Brian Kardell,
Charles McCathieNevile,
Chris Wilson,
Dan Connolly,
Daniel Ehrenberg,
Daniel Murphy,
David Baron,
Domenic Denicola,
Eiji Kitamura,
Eric Shepherd,
Ethan Resnick,
fantasai,
François Daoust,
Henri Sivonen,
HE Shi-Jun,
Ian Hickson,
Irene Knapp,
Jake Archibald,
Jeffrey Yasskin,
Jeremy Roman,
Jirka Kosek,
Kenneth Rohde Christiansen,
Kevin Marks,
Lachlan Hunt,
Léonie Watson,
L. Le Meur,
Lukasz Olejnik,
Maciej Stachowiak,
Marcos Cáceres,
Mark Nottingham,
Martin Thomson,
Matt Giuca,
Matt Wolenetz,
Michael[tm] Smith,
Mike West,
Nick Doty,
Nigel Megitt,
Nik Thierry,
Ojan Vafai,
Olli Pettay,
Pete Snyder,
Philip Jägenstedt,
Philip Taylor,
Reilly Grant,
Richard Ishida,
Rick Byers,
Rossen Atanassov,
Ryan Sleevi,
Sangwhan Moon,
Sergey Konstantinov,
Stefan Zager,
Stephen Stewart,
Steven Faulkner,
Surma,
Tab Atkins-Bittner,
Tantek Çelik,
Tobie Langel,
Travis Leithead,
and Yoav Weiss
</div>

<p>
`~HTML設計~原則＠~TR/html-design-principles/$cite
を編集された，次に挙げる各氏に特別な謝意を
⇒
`Anne van Kesteren^en,
`Maciej Stachowiak^en
◎
Special thanks to Anne van Kesteren and Maciej Stachowiak, who edited the HTML Design Principles document.
</p>

<p>
この文書に貢献したが，上に名前が挙げられていない方は、
そのことを正せるよう，編集者に知らしめたし。
◎
If you contributed to this document but your name is not listed above, please let the editors know so they can correct this omission.
</p>

	</section>
</main></div>
