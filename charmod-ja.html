<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Character Model for the World Wide Web 1.0: Fundamentals （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<style>

samp,
.qchar {
	color: var(--text-color-1);
}

span.qchar::before,
span.qchar::after {
	content: '"';
	color: var(--K-color);
}

kbd > kbd {
	padding:0 0.2em;
	border-radius: 3px;
	border-style: outset;
	font-family: sans-serif0, sans-serif;
}

.encoding {
	font-family: sans-serif0, sans-serif;
}

.cp-name {
	color: var(--dim-color);
}


/* 適合性要件 */

.req {
	background: var(--advisement-bg-color);
}
.req-label {
	color: var(--heading-color);
}
dfn .req-label {
	display: block;
}

	/* 表 */
table {
	margin-left: auto;
	margin-right: auto;
	min-width: 35em;
	border: thin solid var(--N-color);
}
td, th {
	text-align: center;
	border: thin solid var(--N-color);
}

td > .alt {
	max-width: 300px;
}

caption {
	caption-side: bottom;
	padding: 0;
}

</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;
let classname = class_map[klass];

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#ref-${key}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'cf':
	const m = key.match(/(\d*)-?([SIC]*)/);
	if(!m) break;
	text = '';
	if(m[1]){
		href= `#C${m[1]}`;
		text = `C${m[1]}`;
	}
	if(m[2]) {
		key = m[2];
		classname += key.replace(/./g, ' req-$&');
		text += ' ';
		if(key.indexOf('S') >= 0) text += '[仕様]';
		if(key.indexOf('I') >= 0) text += '[実装]';
		if(key.indexOf('C') >= 0) text += '[内容]';
	}
	key = '---';
	break;
case 'UT': // unicode terms
	href = link_map[`UT.${key}`];
	if(!href) return match;
	return `<a href="${href}" lang="en">${key}</a>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2005-02-15
trans_update:2018-12-11
source_checked:050215
original_url:https://www.w3.org/TR/2005/REC-charmod-20050215/
spec_status:REC
	no_original_dfn:true
	copyright:2005,use
ref_id_prefix:ref-
trans_1st_pub:2013-05-20

●●original_id_map

●●class_map
ch:qchar
ec:encoding
U:code-point
P:production
cf:req-label
cn:cp-name
e:element

●●tag_map
ch:code
q:q
c:code
e:code
i:i
cf:b
ch:span
U:span
ec:span
P:code
cite:cite
em:em
q:q
s:samp
kbd:kbd
cn:span
abbr:abbr

●●link_map

~Unicode標準:#ref-Unicode
	q.~Unicode:#Unicode
~text:#def-text
~textな~data~obj:#textual-data-object

q.文字:#sec-PerceptionsIntro
q.文字列:#sec-Strings
q.符号化法:#sec-Digital

UT.character:~UTERMS#character
文字:#_character
文字列:#_string
~byte文字列:#def-byte-string
符号単位~文字列:#def-physical-string
文字~文字列:#def-character-string
~repertoire:#def-repertoire
UT.repertoire:~UTERMS#character_repertoire

文字~符号化法:#_encoding
有符号~文字~集合:#def-CCS
UT.coded character set:~UTERMS#coded_character_set
	UT.CCS:~UTERMS#ccs
符号位置:#_code-point
UT.code point:~UTERMS#code_point
符号単位:#_code-units
UT.code unit:~UTERMS#code_unit
文字~符号化~scheme:#def-CES
UT.character encoding scheme:~UTERMS#character_encoding_scheme
	UT.CES:~UTERMS#ces
	直列化~scheme
符号化~形0:#def-CEF
文字~符号化~形0:#def-CEF
UT.character encoding form:~UTERMS#character_encoding_form
	UT.CEF:~UTERMS#cef
~Unicode符号化~形0:#Unicode_Encoding_Form
UT.Unicode encoding form:~UTERMS#unicode_encoding_form

符号変換:#def-transcoding
符号変換-:#def-transcoding
UT.transcoding:~UTERMS#transcoding

基準~処理~model:#def-ref-proc-model

~charset:#def-charset
	~charset名
	~charset識別子
	符号化の単位

~markup言語:#def-char-data
~markup:#def-char-data
構文文字:#def-syntax-significant
文字~escape:#def-char-escape
	~escapeする
	~escape法
	文字~escapeの展開
	数的な文字~参照

書記素~cluster:#def-grapheme-string
UT.grapheme cluster:~UTERMS#grapheme_cluster
~glyph:#def-glyph
UT.glyph:~UTERMS#glyph
~font:#font
UT.font:~UTERMS#font

	論理的な選択
	視覚的な選択
	照合c単位
	~index
	~IME
	~romaji~IME
	~dead-key

§ 文字~escape法:#sec-Escaping
§ 文字列の概念:#sec-Strings
§ 文字~符号化法:#sec-Digital
§ 文字~符号化法の識別:#sec-EncodingIdent
§ 文字の知覚:#sec-Perceptions
§ 基準~処理~model:#sec-RefProcModel
§ 文字~符号化法の選定と識別:#sec-Encodings
§ 文字列の付番:#sec-stringIndexing
	§ 文字, ~keystroke, ~glyphの例:#sec-CharExamples
	§ 文字~符号化法:#sec-Digital
	§ 格納~単位:#sec-Storage
	§ 識別:#sec-EncodingIdent

~CDATA~section:~TR/REC-xml/#sec-cdata-sect
~XML宣言:~TR/REC-xml/#dt-xmldecl
~text宣言:~TR/REC-xml/#sec-TextDecl
	~XML~text
	`encoding^c 疑似属性


	:#def-legacyEnc
	:#def-char-data
	ex:#sec-CharExamplesA5
	ex:#exampleA6
	ex:#arabic-select
	ex:#arabicLigature
	ex:#stumpOfTree
	ex:#nihongo
	ex:#tamil
	§ 3.3:#sec-VisualRenderingUnits
	§ 6.1:#sec-Strings
	~Persianの例:#arabicLigature-0
	§ 10.14:~SVG11/text.html#AlternateGlyphs
	§ 2.4:~TR/REC-xml/#syntax
	§ 3.2.9:~TR/2003/REC-MathML2-20031021/chapter3.html#presm.mglyph
	§ 4:~TR/WD-charreq#4
	Appendix F:~TR/REC-xml/#sec-guessing
	Unicode Consortium:https://www.unicode.org/
	シャクル:https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%A3%E3%82%AF%E3%83%AB
	ニクダー:https://ja.wikipedia.org/wiki/%E3%83%8B%E3%82%AF%E3%83%BC%E3%83%89


	●Unicode 用語集
字l:~UTERMS#letter
結合~文字:~UTERMS#combining_character
結合~符:~UTERMS#combining_mark
抽象-文字:~UTERMS#abstract_character
符号化された文字:~UTERMS#encoded_character
~surrogate符号位置:~UTERMS#surrogate_code_point
非文字:~UTERMS#noncharacter
文字~名:~UTERMS#character_name
基底~文字:~UTERMS#base_character
互換y文字:~UTERMS#compatibility_character
書式~文字:~UTERMS#format_character
発音区別符:~UTERMS#diacritic
~cedilla:~UTERMS#cedilla
~accent:~UTERMS#accent_mark
異体字:~UTERMS#y_variant
	異体字:~UTERMS#z_variant

~byte:~UTERMS#byte

音素:~UTERMS#phoneme
音節:~UTERMS#syllable

基本多言語面:~UTERMS#basic_multilingual_plane

互換y等価:~UTERMS#compatibility_equivalent
合字:~UTERMS#ligature
私用:~UTERMS#private_use
私用領域:~UTERMS#private_use_area
	UT.Private Use Area
	UT.PUA:~UTERMS#pua
私用~符号位置:~UTERMS#private_use_code_point
視覚-順序:~UTERMS#visual_order

子音:~UTERMS#consonant
母音:~UTERMS#vowel

~Unicode照合c~algo:~UTERMS#unicode_collation_algorithm
照合c:~UTERMS#collation
正規化:~UTERMS#normalization
等価性:~UTERMS#equivalence

素な~text:~UTERMS#plain_text
論理-順序:~UTERMS#logical_order

書記体系:~UTERMS#writing_system
用字系:~UTERMS#script
文脈に応じた異体字:~UTERMS#contextual_variant
平仮名:~UTERMS#hiragana
片仮名:~UTERMS#katakana
~Hangul:~UTERMS#hangul
~virama:~UTERMS#virama
文字~集合:~UTERMS#character_set
双方向性:~UTERMS#BIDI
双方向-~text:~UTERMS#BIDI
分解-可能:~UTERMS#decomposable_character
分解-済み:~UTERMS#decomposable_character
文字大小:~UTERMS#case
UT.bicameral:~UTERMS#bicameral
対称交換:~UTERMS#symmetric_swapping
具現化:~UTERMS#rendering
	描画:~UTERMS#rendering
~big-endian:~UTERMS#big_endian
~alphabet:~UTERMS#alphabet
~HTML:~UTERMS#HTML
~XML:~UTERMS#XML
	~protocol:~UTERMS#higher_level_protocol
漢字:~UTERMS#kanji
UCS:~UTERMS#UCS
	~byte順:~UTERMS#byte_order_mark

ec.UTF-16:~UTERMS#UTF_16
ec.UTF-8:~UTERMS#UTF_8
ec.UTF-32:~UTERMS#UTF_32
ec.US-ASCII:~UTERMS#ASCII
	iso-8859-1
	Latin-1
	ISO 8859-5
	IBM CP864
	CP864
	Shift_JIS


	UT.子音~cluster:~UTERMS#consonant_cluster
	UT.~cluster
	UT.符号化法:~UTERMS#encoding
	UT.書記素:~UTERMS#grapheme
	UT.IANA:~UTERMS#IANA
	UT.Unicode技術報告:~UTERMS#unicode_technical_report
	endian
	UT.大文字:~UTERMS#uppercase
	UT.小文字:~UTERMS#lowercase

●●words_table1
UTERMS:https://www.unicode.org/glossary/


●●words_table


	●言語／用字系

Latin:
Cyrillic:
Greek:
Hangul::::ハングル
virama::::ヴィラーマ
Spanish:::スペイン語
広東語:Cantonese:~
Slovak:::スロヴァキア語
Thai:::タイ語
German:::ドイツ語
Arabic:::アラビア語
Indic:::インド語群
French-Canadian:::カナダ・フランス語
English:::英語
French:::フランス語
Hebrew:::ヘブライ語
Russian:::ロシア語
Korean:::韓国語
Chinese:::中国語
古代中国:Archaic Chinese:~
Japanese:::日本語
Persian:::ペルシャ語
Tamil:::タミル語
Swedish:::スウェーデン語

語源:word root:~

音節:syllable::~
	音節:syllabic
音素:phoneme::~
合字:ligature::~
母音:vowel::~
子音:consonant::~
発音体系:phonetics::~
音声言語:spoken language::~
響き:sound::~
	結合~符:combining mark

書記素:grapheme::~
書記体系:writing system::~
用字系:script::~
双方向-:bidirectional::~
双方向性:bidirectionality::~
表示異体:display variant::~

筆記:writing::~

自然言語:human language::~
多言語:multilingual::~
子音的:consonantal::~
修飾-:modify::~
locale::::ロケール

	●文字／text
	文字~並び:sequence of characters
字l:letter:::字°
部分文字列:substring::~
非文字:noncharacter::~
記号:symbol::~
	^en:unescaping
	~escapeされてない:unescaped
	~escape法:escaping
accent::::アクセント符
cedilla::::セディーユ
alphabet::::アルファベット
	~alphabet類:alphabetic approach
二重引用符:double quote::~
発音区別符:diacritic::~
異体字:variant::~
漢字:Kanji:~
仮名:kana::~
平仮名:hiragana::~
片仮名:katakana::~
大字:capital::大文字
	大文字化
	文字大小の区別:upper and lower case letters
頭字:initial::~
中字:median::~
中字形:medial form::~
尾字形:final form::~
尾字:final::~

表意的:ideographic:~
補足的:supplementary:~

	●Unicode／符号化／照合
repertoire::::レパートリ
	基底~文字
基本多言語面:Basic Multilingual Plane::~
	互換y等価
	互換y文字
私用領域:private use area::~
書式:formatting::~
	書式~文字
照合c:collation::照合°
	照合:matching
fuzzy:::曖昧
	~fuzzy照合

surrogate::::サロゲート
等価性:equivalence::~

形0:form::形式
	符号化~形0:encoding form
有符号:coded::~::有コード
符号変換-:transcode::~::トランスコード
符号変換:transcoding::~::トランスコード
符号変換器:transcoder::~::トランスコーダ
分解-:decompose::~
	分解-済み:decomposed
	分解-可能:precomposed
	組成済み:composed
	結合~文字:combining character
対称交換:symmetric swapping::~
多重的な:duplicated:~

	~labelを付与する:label
charset:
	~charset名
	~charset識別子

	文字~文字列:character string
	~collation単位:collation unit
区切る:delimitする::~
	~sort法／~sort時:sorting::~
構文文字:syntax-significant::~
素子:device::~

	●データ／構造
	複数~byte:multibyte
	複数~byte:multibyte quantities
big-endian::::ビッグエンディアン
section::::セクション
付番:indexing::~
	並び:sequence
	並べ方:sequencing
	列:sequence
	~data型:datatype

一対一:one-to-one::~
一対多:one-to-many::~
多対一:many-to-one::~
多対多:many-to-many::~
構造的な:structured::~
	〜順:order
	両端:end-points
対応関係:mapping::~
	全-:full
所在-:locate:位置
起点:origin:~

	文脈~付け:contextualize
	文脈に応じた異体字:contextual variant
	含む／含め:contain


	●UI／呈示
IME:
cut::::カット
paste::::ペースト
romaji:::ローマ字
打込まれ:typeされ:打ち込まれ:::タイプされ
打込む:typeする:打ち込む:::タイプする
打込んで:typeして:打ち込んで:::タイプして
打込んだ:typeした:打ち込んだ:::タイプした
話され:speakされ:~
	spoken

keystroke::::キーストローク
修飾key:modifier key::修飾 key:修飾キー
caret::::キャレット
dead-key:dead key:::デッドキー
改行:line-break::~
強調-:highlight:~

選択-:select::~
選択:selection::~
選択範囲:selection::~

聴覚的:aural::~
知覚:perception::~
知覚-:perceive::~

押下:press::押し下げ
押下げた:pressした::押し下げた
押下げて:pressして::押し下げて
	~UIkey押下:keypress
折返され:wrapされ:折り返され
	単語が折り返され::word-wrapping
動き:movement:~

不連続性:discontinuity::~
不連続:discontiguous::~
連続的:continuous::~
	連続する:consecutive な
	右から左:right to left
	右から左へ:right-to-left
	納まり切らない:far too many 〜 to fit on
	~~配置-:laid out

	●仕様
	Web:WWW
programmer::::プログラマ
driver::::ドライバ
	~version付け:versioning
component::::コンポーネント
	~computer利用:computing
processor::::プロセッサ
digital::::デジタル
design::::デザイン
国際標準:International Standard::~
慣行:convention:~
規範:reference material:~
国際化:Internationalization:~
根本原則:Fundamentals:~
合法的:legitimate:~
実利的:pragmatical:~
堅牢:robust:~
適格:admissible:~
適性:suitability:~
統計的解析:statistical analysis:~
論題:topic:~
重大:crucial:~
自明:trivial:~
柔軟:flexible:~
技術委員会:technical committees:~
姉妹:companion:~
機能:function:~
同調的:synchrony:~
日常:everyday:~
本質:essence:~
原理的:in principle:~
根本的:radical:~
実在:reality:~
柔軟性:flexibility:~
創造性:creativity:~
冗長:redundant:~
成果:work:~
素直:straightforward:~
伝統:tradition:~
特徴的:interesting:~
同義語:synonym:~
背景情報:background reading:~
文化:culture:~
文化継承:cultural heritage:~
文化的慣習:cultural conventions:~
様相:phenomena:~
	世界中の:around the world／:over the world
必要性:needs:~
可能性:possibility:~
時代:age:~
互換y:compatibility:互換
上位互換:upwards-compatible:~
総称的:generic:~
多段階:multi-level:~
競合:conflict:~
定式化:formulation:~
普遍的:universal:~
不一致:inconsistencies:~
	~architecture上の:architectural
決定的:vitally:~
絵図:picture:~
	基づくとする:basis:~
見方:view:~
各個人:individuals:~
産業界:industry:~
思考:mind:~
関心:interest:~
	関心を持つ:interested
多様性:variation:~
優先順位:priorities:~
私的:private:~
必要条件:prerequisite:~
有意性:significance:~
実効な:effectiveな:実効性のある
内来的:inherent:~
活動的:active:~
理想的:ideal:~
早見表:quick reference:~
半規則的:semi-regular:~
不規則:irregular:~
用語集:glossary:~
特質:property:~:::プロパティ

製作者:producer:~
企業:corporation:~
各国政府:national governments:~
研究機関:research institutions:~
国際的機関:international agencies:~
	国際電気標準会議:International Electrotechnical Commission
	国際標準化機構:International Organization for Standardization
非規範的:non-normative:参考
参考の:informativeな:~
	参考:Non-Normative

助言:advice:~
誤用-:misuse:~
	設計し直す:redesign
参照r:refer:参照
適応-:accommodate:~
混成:intermingled:~
衝突-:collide:~
捕捉-:capture:~
合意-:agree:~
	合意しておく:agreed-upon
合意:agreement:~
誤用-:misuse:~
誤認-:mistake:~
誤解:misunderstanding:~
理解:understanding:~
醸成-:create:~
発展-:evolve:~
逸脱-:deviate:~
	許容する:NOT disallow／:not disallow
禁制-:prohibit:~
指名-:designate:~
採択-:adopt:~
成長-:grow:~
完成-:complete:~
翻訳:translation:~
	適合性の判定基準:conformance criteria
誤利用:misuse:~
末端利用者:end user:~:::エンドユーザ
過程:process:~
基準:reference::~
前処理:pre-processing::~
編集:edit:~
	編集~時:editor
義務化:mandating:義務付け
義務付けて:mandateして:~
	義務付けて:mandatory
考案-:invent:~
	~~考案-:devise
誂えら:tailorさ:あつらえら
誂える:tailorする:あつらえる
誂え:tailoring:あつらえ
例外的:exceptional:~
改正-:amend:~
公に:publicに:~
指示書き:instructions:~
集成-:aggregate:~
割振られ:allocateされ:割り振られ
発生-:arise:~
組織化-:organize:~
組織:organization:~
問い:question:~
答え:answer:~
歴史上の:historicな:~
稀:rare:~
破損-:corrupt:~
対象読者:audience:~

	有利:advantages 〜 are greater
	加える:obtain 〜 in addition to
	必要に応じて:as appropriate
	重要でない:unimportant
	明らか:clearly
	豊富:wealth of
	特に:notably
	~~情報:reading
	参照文献:bibliography／:reference
	~~目的の:target
	見込まれ:likely
	その場で:on the fly
	例示:example
	反例:counter-example
	好例:good example
	多大:great
	ゆるく:loosely
	第一歩:first step
	人々:people
	~~相当な:good
	誤って:erroneous
	ありがちな誤り:frequent error
	~~全体像の~~把握に役立つ:help make sense all this
	~~仕分けに:break ties
	協同:together
	共同により:jointly
	~~裁量に委ね:matter
	手短に言えば:In short
	都合の良い:favorable
	馴染んで:familiar
	疎く:less familiar
	高次:higher
	有益な:helpful
	足りて／足る:sufficient
	起因する／したがって／そのため／:consequence of
	長い苦しみの:long and tortured
	~~問題になり始める:start to matter
	問題になり得る:may be problematic
	念頭に置かれ:kept in mind
	急速に:quickly
	既定として定められた:default
	情報交換:liaison
	易い:well-／
	易くなる:easier
	強い:-
	注目される点:interesting aspect／interesting things are happening
	特記すべき:noteworthy
	草創期の頃:early days
	比して:more／:compared to the use of
	ようが〜まいが:whether or not
	則って:-
	必要yな所まで:extent necessary to
	~~割合が更に高まっている::more and more places
	かなり:quite
	多少なりとも:more or less
	限り:as long as
	単に:only as／merely
	過ぎない:only／:just
	いろいろな仕方:in one way or another
	概ね:loosely
	様子:-
	段階:stage
	主な:main
	見え／見られ:see
	見られ:-
	見る:view
	踏まえ:taking into account
	用をなす:Use
	仮に:-
	時と伴に:time to time
	似ている:like
	本文:body／:main body
	あるわけではない:There is not a
	区別:distinction／:distinct／-
	納まらない:outside
	メンバの重なり合い:overlapping membership
	早期:early
	登録-済み:-registered
	登録-済みでない:unregistered
	~~用法:use
	用途:use
	併用:used in conjunction with
	きちんと定義された:well-defined
	どちらを〜しようが:independent of whether
	結果を表出する:expression
	何かをアテガう:assignment
	関連な:relevance of
	向上:improvement
	対処-:deal with 
	~~扱う:deal with 
	統一され:be in a single
	課す／課され:place／
	課-:-
	選ばれ:chosen
	~~選択:choose
	触れるだけにとどめている:barely touched
	取り込まれた:embrace
	できなくなる:prevent
	に基づく:-oriented
	かなりの助力をいただいた:provided significant help
	抜き出され:drawn
	この文書から すぐに探し出せるよう:allow 〜 quickly locate 〜 by searching through this document
	無くす:eliminate
	ふるまいが一貫しない:not work consistently
	相当する:comparable
	立ち~~位置:in standing to
	規定する:prescribe
	規定:provision
	解り難い:obscure
	~~説明-:illustrating
	踏襲-:later used
	判って:shows
	助け:help
	失えなくする:lose 〜 preclude
	持ち込まれ:impose
	捉えた／捉えられ:viewed as
	~~呈する:show
	失わせ:disregarding
	満たされ:satisfied
	強まった:strengthen
	抱えて:carry
	採用する:adopt／adoption／approach is not taken
	採用:choose
	支持は得ている:favoured
	易くする:facilitate
	~~望むだけ:request
	由来する:derives from
	よく知られ:well-known
	策定-:-
	-:保たれ
	導く:lead
	道を開く:open
	~~正常に~~働き続ける:not break down
	増えて:increase して
	作り上げ:resulting in
	担う:-
	定める:-
	~~引用:citing
	記され:denoted／...
	逆に:contrary to
	書かれ:written
	書き記され:written
	書く:write
	読まれている時点:at the time of reading
	読んだ:read
	読んで:read
	使う:equipped with
	備わ／備え:have／
	呼ばれ:／
	寄せる:sending
	一覧:table
	を呼ぶ:result in
	できるだけ:maximizes the opportunity
	要し:has to
	失われ:lost
	-:took place
	~~検知:get
	行う／行え／行われ
	済ませ
	満たす
	示す:denote
	成り立たない

	●一般処理
復元-:recover:~
交換i-:interchange::交換
交換i:interchange::交換
交換-:exchange:~
格納:storage::~
展開-:expand::~
処理回:pass:~
	復元-:recovery of
	~~元の〜に~~復号:converted back
	格納~単位:units of storage
	格納~域:storage area
	数える:count
	数え方:counting

	●未分類（動詞
前置-:precede:~
拡大-:scale::~
脱落:eliminate:~
内包:inclusion:~
現れな:appearしな:~
現れる:appearする:~
逆さに:reverse:~
綴られ:spellされ:~

	受信-側:receiving／receiver
	保たれ:keep
	付与-:-
	張られ:-
	振り方:-
	流れ:run
	続いて／続き／し続け
	経て
	置かれ:placed／
	置く:place
	起こり:-
	~~写像:-
	変わり:vary
	短縮
	indices

	●未分類
選定:choice:選定
Internet:
URI:
CDATA:
pass::::パス
解析対象実体:parsed entity::~
実体:entity::~
疑似属性:pseudo-attribute::~
同一性:identity::~
形状:shape:~
	層の積み重ね:layered
不可分:atomic::~
切替:switching::~
	略称:marker
分割0:divide:分割
数学-:mathematical:~
数学的:mathematical:~
	同等性比較:equating
表引き:lookup::~
一定量:certain amount:~
可変:variable:~
	可変~個数:variable number
	長さが可変:variable-length
数値:number::~
	符号値:numbers
数的:numeric:~
	数的でない:non-numeric
片:piece:~
候補:candidate:~
単方向:unidirectional::~
非電子的に:non-electronicに:非電子媒体を通して

頻度:frequency:~
集合体:collection:~
正方形:square:~
電話帳:telephone book:~
顧客:customers:~
database::::データベース
必要最小限:minimal:~
	最~小:smallest
	長い:long
	~tag法:tagging
	10 進:decimal
	16 進:hexadecimal
	不死鳥:phoenix
	切り株:stump of tree
	~~枠内:block
	平和:peace
	年号:year number
	符号値:numbers

	●指示語
	次節
	前節
	三者:three groups
	一定個数の:fixed number of
	一定層の:set of
	一段:single step
	ある一点:point
	種類:-
	一種類:one
	一緒に:together with
	一致:overlap
	主な:main
	~~主要な:major
	点:points
	いくつでも:as many
	当の:instance of
	前掲の:preceding
	合間／挟まれ／狭間:between
	囲って:surround
	囲んで:surround
	大きく:significant
	始まり:Starting with
	続々と:More and more
	多様な:variety of
	多種多様な:large variety of
	巨大:large
	幅広い:wide な
	広く:widely
	広範:wide base／:widespread
	手前の:next to
	次／-:next
	様々に:vary
	様々な:different
	あらゆる所:at all times and places
	ある~~範囲の:some extent
	一定範囲の:certain ranges
	一部:some／
	一部分:parts
	一部分は
	成す
	部分:part
	まったく:very
	全体:whole／entirely
	下され:-
	並べ
	中略:-
	互いに
	ほとんど:most／:mostly
	先頭に:beginning
	唯一:only
	各位置:-
	各行:-
	〜向け:for
	~~元の:source
	小さい／小さく／小さな:small
	少しばかり:few
	わずかな:very low
	少数:few／:small
	左右両:both
	対象:target／in question／-
	に入る:in
	初めて:first
	後
	後続する:followed by
	彼ら:their／:they
	更なる:further／
	更に:Furthermore
	ごく:very
	最低でも:as a minimum
	有無:-
	末尾:end
	数多の:large amount of
	途中:in the middle of
	や否や:as soon as
	上層:on top of
	越える:above
	通さず:ways
	通して:throughout／:by
	深い／深く／近い:close／:closely
	同じ様に:just as／
	残りの:remainder
	桁目:-
	段目:-
	いくぶん:somewhat
	句
	宛
	〜日:date of
	編:part of
	単に:only as／merely
	法
	方
	様に
	し合う
	列
	化
	場合
	外
	対し
	対する
	属する
	一つ
	上
	下
	回
	所
	用
	種
	章
	第
	等
	組
	中
	伴
	何
	側
	先
	内
	両者
	他
	別
	前
	各
	各種
	点
	自体
	自身
	面
	第
	間
	際
	頃
	付
	図
	無い／無く
	表
	長
	数
	以上
	以下
	以前
	以外
	一方
	一連の

	●訳注
	訳
	逐語訳的
	対訳
	対訳表
	訳語
	不自然
	注釈-
	語自体
	原文
	読み~~仮名
	語
	語句
	横書き
	縦書き
	未表示
	文章内
	固定的
	固定-
	倣い
	画数／偏／旁
	ページ
	シャクル
	ニクダー
	エンコーディング
	拡張可能
	拡張
	拡張-
	捉えれば
	同種のもの
	定着-
	句読点
	冒頭
	大部分
	類する
	用い
	現今の
	致し方ない
	名称
	同義
	要する
	符号点
	長音
	重複

●●images
＠charmod/
logSelScreen｜height:32px;｜｜.gif
logSelMemory｜height:27px;｜｜.gif
visSelScreen｜height:33px;｜｜.gif
visSelMemory｜height:27px;｜｜.gif
chineseSurrogate｜height:25px;｜｜.gif
not_equal｜height:26px;｜NOT EQUAL TO｜.gif
Q｜height:21px;｜LATIN SMALL LETTER Q｜.gif
caron｜height:21px;｜COMBINING CARON｜.gif 
fa-lam｜height:23px;｜ARABIC LETTER LAM｜.gif
fa-alif｜height:23px;｜ARABIC LETTER ALEF｜.gif
fa-lamalif｜height:23px;｜Arabic ligature 'lam-alef'.｜.gif
fa-yeh｜height:23px;｜ARABIC LETTER FARSI YEH｜.gif
fa-yeh1｜height:23px;｜ARABIC LETTER FARSI YEH｜fa-yeh.gif
fa-laalaayee｜height:23px;｜｜.gif
ta-tm｜height:14px;｜TAMIL LETTER TTA｜.gif 
a-tm｜height:15px;｜TAMIL VOWEL SIGN AA｜.gif
nga-tm｜height:14px;｜TAMIL LETTER NGA｜.gif
virama-tm｜height:16px;｜TAMIL SIGN VIRAMA｜.gif
ka-tm｜height:14px;｜TAMIL LETTER KA｜.gif
o-tm｜height:17px;｜TAMIL VOWEL SIGN OO｜.gif
tango｜height:17px; ｜｜.gif

●●ref_data
CHARNORM=副   www.asahi-net.or.jp/~ax2s-kmtn/internet/character/NOTE-charmod-norm-20190204.html●2019 年版 日本語訳
XPATH=副      ~/XML/xpath10-ja.html

●●ref_key_map
SVG:SVG11

●●ref_normative

[IANA]
    Internet Assigned Numbers Authority, Official Names for Character Sets.
    URL: http://www.iana.org/assignments/character-sets
[ISO/IEC-10646]
    ISO/IEC 10646:2003, Information technology -- Universal Multiple-Octet Coded Character Set (UCS), as, from time to time, amended, replaced by a new edition or expanded by the addition of new parts.
    URL: http://www.iso.org/iso/en/ISOOnline.openerpage
[MIME-entity]
    N. Freed, N. Borenstein, Multipurpose Internet Mail Extensions (MIME). Part One: Format of Internet Message Bodies, RFC 2045, November 1996,
    URL: https://www.rfc-editor.org/rfc/rfc2045
[MIME-charset]
    Multipurpose Internet Mail Extensions (MIME). Part Two: Media Types, N. Freed, N. Borenstein, RFC 2046, November 1996,
    URL: https://www.rfc-editor.org/rfc/rfc2046
[RFC2119]
    S. Bradner, Key words for use in RFCs to Indicate Requirement Levels, IETF RFC 2119.
    URL: https://www.rfc-editor.org/rfc/rfc2119
[Unicode]
    The Unicode Consortium, <a href="http://www.unicode.org/unicode/standard/versions/enumeratedversions.html#Unicode_3_2_0"><cite>The Unicode Standard, Version 3.2.0</cite></a> is defined by <a href="http://www.unicode.org/unicode/standard/versions/enumeratedversions.html#Unicode_3_0_0"><cite>The Unicode Standard, Version 3.0</cite></a> (Reading, MA, Addison-Wesley, 2000. ISBN 0-201-61633-5), as amended by the <a href="http://www.unicode.org/reports/tr27/"><cite>Unicode Standard Annex #27: Unicode 3.1</cite></a> (see <a href="http://www.unicode.org/reports/tr27/">http://www.unicode.org/reports/tr27</a>) and by the <a href="http://www.unicode.org/reports/tr28/"><cite>Unicode Standard Annex #28: Unicode 3.2</cite></a> (see <a href="http://www.unicode.org/reports/tr28/">http://www.unicode.org/reports/tr28</a>).
[Unicode40]
    The Unicode Consortium. The Unicode Standard, Version 4.0, Reading, MA, Addison-Wesley, 2003. ISBN 0-321-18578-1.
    URL: http://www.unicode.org/versions/Unicode4.0.0/

●●ref_informative

[CharNorm]
    Martin J. Dürst, François Yergeau, Richard Ishida, Misha Wolf, Tex Texin, Addison Phillips Character Model for the World Wide Web 1.0: Normalization, W3C Working Draft.
    URL: http://www.w3.org/TR/charmod-norm
[CharIRI]
    Martin J. Dürst, François Yergeau, Richard Ishida, Misha Wolf, Tex Texin, Character Model for the World Wide Web 1.0: Resource Identifiers, W3C Candidate Recommendation.
    URL: http://www.w3.org/TR/charmod-resid
[CharReq]
    Martin J. Dürst, Requirements for String Identity Matching and String Indexing, W3C Working Draft.
    URL: http://www.w3.org/TR/WD-charreq
[Connolly]
    D. Connolly, Character Set Considered Harmful, W3C Note.
    URL: http://www.w3.org/MarkUp/html-spec/charset-harmful
[CSS21]
    Bert Bos, Håkon Wium Lie, Chris Lilley, Ian Jacobs, Eds., Cascading Style Sheets, level 2 (CSS2 Specification), W3C Recommendation.
    URL: http://www.w3.org/TR/REC-CSS2
[DOM1]
    Vidur Apparao et al., Document Object Model (DOM) Level 1 Specification, W3C Recommendation.
    URL: http://www.w3.org/TR/REC-DOM-Level-1
[HTML40]
    Dave Raggett, Arnaud Le Hors, Ian Jacobs, Eds., HTML 4.0 Specification, W3C Recommendation, 18-Dec-1997
    URL: http://www.w3.org/TR/REC-html40-971218
[HTML401]
    Dave Raggett, Arnaud Le Hors, Ian Jacobs, Eds., HTML 4.01 Specification, W3C Recommendation.
    URL: http://www.w3.org/TR/html401
[ISO/IEC-646]
    ISO/IEC 646:1991, Information technology -- ISO 7-bit coded character set for information interchange. This standard defines an International Reference Version (IRV) which corresponds exactly to what is widely known as ASCII or US-ASCII. ISO/IEC 646 was based on the earlier standard ECMA-6. ECMA has maintained its standard up to date with respect to ISO/IEC 646
    URL: http://www.ecma-international.org/publications/standards/Ecma-006.htm
[ISO/IEC-9541-1]
    ISO/IEC 9541-1:1991, Information technology -- Font information interchange -- Part 1: Architecture.
    URL: http://www.iso.ch/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=17277
[ISO/IEC-14651]
    ISO/IEC 14651:2000, Information technology -- International string ordering and comparison -- Method for comparing character strings and description of the common template tailorable ordering as, from time to time, amended, replaced by a new edition or expanded by the addition of new parts.
    URL: http://www.iso.org/iso/en/ISOOnline.openerpage
[MathML2]
    David Carlisle, Patrick Ion, Robert Miner, Nico Poppelier, Eds., Mathematical Markup Language (MathML) Version 2.0, W3C Recommendation.
    URL: http://www.w3.org/TR/MathML2
[Nicol]
    Gavin Nicol, The Multilingual World Wide Web, Chapter 2: The WWW As A Multilingual Application.
    URL: http://www.mind-to-mind.com/library/papers/multilingual/multilingual-www.html
[RFC2070]
    F. Yergeau, G. Nicol, G. Adams, M. Dürst, Internationalization of the Hypertext Markup Language, IETF RFC 2070, January 1997.
    URL: https://www.rfc-editor.org/rfc/rfc2070
[RFC2277]
    H. Alvestrand, IETF Policy on Character Sets and Languages, IETF RFC 2277, BCP 18, January 1998.
    URL: https://www.rfc-editor.org/rfc/rfc2277
[RFC2978]
    N. Freed, J. Postel, IANA Charset Registration Procedures, IETF RFC 2978, BCP 19, October 2000.
    URL: https://www.rfc-editor.org/rfc/rfc2978
[RFC3629]
    F. Yergeau, UTF-8, a transformation format of ISO 10646, IETF RFC 3629, STD 63, November 2003.
    URL:https://www.rfc-editor.org/rfc/rfc3629
[RFC2781]
    P. Hoffman, F. Yergeau, UTF-16, an encoding of ISO 10646, IETF RFC 2781, February 2000.
    URL: https://www.rfc-editor.org/rfc/rfc2781
[SPREAD]
    SPREAD - Standardization Project for East Asian Documents Universal Public Entity Set.
    URL: http://www.ascc.net/xml/resource/entities/index.html
[SVG]
    Jon Ferraiolo, 藤沢 淳 (FUJISAWA Jun), Dean Jackson, Ed., Scalable Vector Graphics (SVG) 1.1 Specification, W3C Recommendation.
    URL: http://www.w3.org/TR/SVG
[UTR10]
    Mark Davis, Ken Whistler, Unicode Collation Algorithm, Unicode Technical Report #10.
    URL: http://www.unicode.org/unicode/reports/tr10
[UTR17]
    Ken Whistler, Mark Davis, Character Encoding Model, Unicode Technical Report #17.
    URL: http://www.unicode.org/unicode/reports/tr17
[UTR29]
    Mark Davis, Text Boundaries, Unicode Standard Annex #29.
    URL: http://www.unicode.org/unicode/reports/tr29
[UXML]
    Martin Dürst and Asmus Freytag, Unicode in XML and other Markup Languages, Unicode Technical Report #20 and W3C Note.
    URL: http://www.w3.org/TR/unicode-xml
[XML10]
    Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, Eds., Extensible Markup Language (XML) 1.0, W3C Recommendation.
    URL: http://www.w3.org/TR/REC-xml
[XML-Japanese-Profile]
    MURATA Makoto Ed., XML Japanese Profile, W3C Note.
    URL: http://www.w3.org/TR/japanese-xml
[XPath]
    James Clark, Steve DeRose, Eds, XML Path Language (XPath) Version 1.0, W3C Recommendation.
    URL: http://www.w3.org/TR/xpath

●●trans_metadata
<p>
~THIS_PAGEは、 W3C により勧告として公開された
Character Model for the World Wide Web 1.0: Fundamentals
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/charmod/
公表履歴
	https://www.w3.org/standards/history/charmod/
編集
	Martin J. Dürst, W3C <a href="mailto:duerst@w3.org">&lt;duerst@w3.org&gt;</a>
	François Yergeau (Invited Expert)
	Richard Ishida, W3C <a href="mailto:ishida@w3.org">&lt;ishida@w3.org&gt;</a>
	Misha Wolf (until Dec 2002), Reuters Ltd. <a href="mailto:misha.wolf@reuters.com">&lt;misha.wolf@reuters.com&gt;</a>
	Tex Texin (Invited Expert), XenCraft <a href="mailto:tex@XenCraft.com">&lt;tex@XenCraft.com&gt;</a>
正誤表
	https://www.w3.org/2005/02/charmod-fundamentals-errata.html
	規範的な修正が含まれることもあります。
各国語翻訳
	https://www.w3.org/2003/03/Translations/byTechnology?technology=charmod
	英語版のみがこの仕様の規範的バージョンです。
メーリングリスト
	<a href="mailto:www-i18n-comments@w3.org">www-i18n-comments@w3.org</a>
	<a href="https://lists.w3.org/Archives/Public/www-i18n-comments/">アーカイブ</a>
実装報告
	https://www.w3.org/2004/11/charmod-implementation/

</script>

<body>

<header class="head">

	<hgroup>
<h1>Web のための文字モデル 1.0：根本原則</h1>
<p>Character Model for the World Wide Web 1.0: Fundamentals</p>
	</hgroup>


<details><summary>©</summary><small class="copyright">
<a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2005&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.org/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small></details>

</header>

<div id="MAIN">

	<section id="abstract">
◎要約

<p>
この~architecture上の仕様は、［
仕様の作者／~software開発者／内容~開発者
］向けに、
~Web上の［
相互運用可能な~text操作
］用の共通な基準を供する
— それは、［
`~Unicode標準$（ `Unicode Standard^en ）と `ISO/IEC-10646$r
］の共同により定義された普遍的な文字~集合（ `Universal Character Set^en ）の上に築かれる。
この文書は、
次の論題について取組む
⇒＃
用語［ `文字$q, `符号化法$q, `文字列$q ］の~~用法,
`§ 基準~処理~model$,
`§ 文字~符号化法の選定と識別$,
`§ 文字~escape法$,
`§ 文字列の付番$（ `indexing^en ）
◎
This Architectural Specification provides authors of specifications, software developers, and content developers with a common reference for interoperable text manipulation on the World Wide Web, building on the Universal Character Set, defined jointly by the Unicode Standard and ISO/IEC 10646. Topics addressed include use of the terms 'character', 'encoding' and 'string', a reference processing model, choice and identification of character encodings, character escaping, and string indexing.
</p>

<p>
文字列の正規化と同一性~照合については、
姉妹~文書 `CharNorm$r
（ `~Webのための文字~model 1.0 ：正規化^cite ）を見よ。
資源~識別子については、
姉妹~文書 `CharIRI$r
（ `~Webのための文字~model 1.0 ：資源~識別子^cite ）を見よ。
◎
For normalization and string identity matching, see the companion document Character Model for the World Wide Web 1.0: Normalization [CharNorm]. For resource identifiers, see the companion document Character Model for the World Wide Web 1.0: Resource Identifiers [CharIRI].
</p>

	</section>
	<section id="status">
◎位置付け

【この節の和訳は省略する。】

	</section>


<main id="MAIN0">

	<section id="sec-Intro">
<h2 title="Introduction">1. 序論</h2>

		<section id="sec-GoalsScope">
<h3 title="Goals and Scope">1.1. 目標と視野</h3>

<p>
“~Webのための文字~model” の目標は、
`~W3Cが目標とする普遍的な~access＠https://www.w3.org/Consortium/mission.html$cite
に則って，
すべての人々から
— 彼らの［
言語／`用字系$（ `script^en ）／`書記体系$／文化的慣習
］に関わらず —
~Web（ `World Wide Web^en ）を利用し易くすることである。
この目標を達成するための基本的な必要条件は、
世界中で利用されている文字を，［
きちんと定義され, きちんと理解される
］仕方により［
伝送-可能かつ処理-可能
］にすることである。
◎
The goal of the Character Model for the World Wide Web is to facilitate use of the Web by all people, regardless of their language, script, writing system, and cultural conventions, in accordance with the W3C goal of universal access. One basic prerequisite to achieve this goal is to be able to transmit and process the characters used around the world in a well-defined and well-understood way.
</p>

<p>
この仕様の主な対象読者は、
~W3C仕様の開発者である。
この仕様あるいはその一部分は、
他の~W3C仕様から参照され得る。
これは、
他の仕様ととともに，~W3C仕様に対する適合性の判定基準を定義する。
◎
The main target audience of this specification is W3C specification developers. This specification and parts of it can be referenced from other W3C specifications. It defines conformance criteria for W3C specifications as well as other specifications.
</p>

<p>
この仕様の対象読者には、
他にも［
~software開発者／内容~開発者／~W3Cの外側で策定される仕様の作者
］が含まれる。
［
~software開発者／内容~開発者
］は~W3C仕様を［
実装する／利用する
］。
この仕様は、
~W3C仕様を［
実装する実装（~software）／利用する内容（作者）
］に対し，適合性の判定基準をいくつか定義する。
これはまた、［
~software開発者／内容~開発者
］たちが，~W3C仕様に含まれる文字に関係する規定を理解するための助けにもなる。
◎
Other audiences of this specification include software developers, content developers, and authors of specifications outside the W3C. Software developers and content developers implement and use W3C specifications. This specification defines some conformance criteria for implementations (software) and content that implement and use W3C specifications. It also helps software developers and content developers to understand the character-related provisions in W3C specifications.
</p>

<p>
この仕様に述べられる文字~modelは、
~Web上の~text操作を［
一貫させる, かつ相互運用可能にする
］ための共通な基準を［
仕様の作者／~software開発者／内容~開発者
］に供する。
これら三者の協同により，より国際的な~Webを築くことが可能になる。
◎
The character model described in this specification provides authors of specifications, software developers, and content developers with a common reference for consistent, interoperable text manipulation on the World Wide Web. Working together, these three groups can build a more international Web.
</p>

<p>
“~Webのための文字~model”
の一部を成す，この文書は、
次に挙げる論題に取組む
⇒＃
用語［ `文字$q, `符号化法$q, `文字列$q ］の~~用法,
`§ 基準~処理~model$,
`§ 文字~符号化法の選定と識別$,
`§ 文字~escape法$,
`§ 文字列の付番$
◎
Topics addressed in this part of the Character Model for the World Wide Web include use of the terms 'character', 'encoding' and 'string', a reference processing model, choice and identification of character encodings, character escaping, and string indexing.
</p>

<p>
“~Webのための文字~model”
の他の部分は、
次に取組む
⇒＃
正規化と文字列の同一性~照合（ `CharNorm$r ）／
IRI（ `Internationalized Resource Identifiers^en, “国際-化された資源~識別子” ）の変換（ `CharIRI$r ）
◎
Other parts of the Character Model address normalization and string identity matching ([CharNorm]) and Internationalized Resource Identifiers (IRI) conventions ([CharIRI]).
</p>

<p>
まだ［
取組まれてない／触れるだけにとどめている
］論題には、［
~fuzzy照合, 言語~tag法
］などがある。
これらの論題のうち一部は、
この仕様の将来~versionにて取組まれるであろう。
◎
Topics as yet not addressed or barely touched include fuzzy matching, and language tagging. Some of these topics may be addressed in a future version of this specification.
</p>

<p>
~modelの中核を担うのは、
`~Unicode標準$と `ISO/IEC-10646$r
の共同により定義された，普遍的な文字~集合（ `Universal Character Set^en, `UCS$ ）である。
この文書は、
この普遍的な文字~集合の同義語として，語 `~Unicode^q を利用する。
この~modelは、［
世界中の`用字系$（および様々な~platform）で著作された~Web文書
］を世界中の~Web利用者が［
交換して, 読取って, 探索する
］ことを許容する。
◎
At the core of the model is the Universal Character Set (UCS), defined jointly by the Unicode Standard [Unicode] and ISO/IEC 10646 [ISO/IEC 10646]. In this document, Unicode is used as a synonym for the Universal Character Set. The model will allow Web documents authored in the world's scripts (and on different platforms) to be exchanged, read, and searched by Web users around the world.
</p>

		</section>
		<section id="sec-Background">
<h3 title="Background">1.2. 背景0</h3>

<p>
この節では、
この仕様が取組む論題についての歴史的な背景0をいくつか述べる。
◎
This section provides some historical background on the topics addressed in this specification.
</p>

<p>
`~HTML$の国際化 `RFC2070$r から始まり、
~Webのための文字~modelの必要性が，~Webの~communityから認識されるようになった。
この~modelを築く第一歩は、
~HTML文書~用の`文字~集合$として~Unicodeを採用したことであった。
◎
Starting with Internationalization of the Hypertext Markup Language [RFC 2070], the Web community has recognized the need for a character model for the World Wide Web. The first step towards building this model was the adoption of Unicode as the document character set for HTML.
</p>

<p>
~Unicodeが選ばれたのは、
次を備えていたからである：
◎
The choice of Unicode was motivated by the fact that Unicode:
</p>

<ul>
	<li>
普遍的な文字~repertoireとして，唯一~可用であった
◎
is the only universal character repertoire available,
</li>
	<li>
~textの符号化法に依存しない，文字を参照する仕方を供している
◎
provides a way of referencing characters independent of the encoding of the text,
</li>
	<li>
注意深く更新され, 完成されてきた
◎
is being updated/completed carefully,
</li>
	<li>
広く受容され，産業界により実装されていた
◎
is widely accepted and implemented by industry.
</li>
</ul>
<hr>

<p>
~W3Cは `HTML40$r において，~HTML文書~用の`文字~集合$に~Unicodeを採用した。
後に，同じ~approachが［
`XML10$r, `CSS21$r
］などの仕様にも踏襲された。
~W3C仕様と応用は，今や、
共通な基準を成す`文字~集合$として，~Unicodeを利用している。
◎
W3C adopted Unicode as the document character set for HTML in [HTML 4.0]. The same approach was later used for specifications such as XML 1.0 [XML 1.0] and CSS2 [CSS2]. W3C specifications and applications now use Unicode as the common reference character set.
</p>

<p>
~Web上での~data転送が，まだ［
（~serverから~browserへの）単方向がほとんどで，主な目的が文書の`具現化$であった頃
］は、
~Unicodeの利用は，追加的な詳細を指定しなくとも足りていた。
しかしながら、
~Webは成長した：
◎
When data transfer on the Web remained mostly unidirectional (from server to browser), and where the main purpose was to render documents, the use of Unicode without specifying additional details was sufficient. However, the Web has grown:
</p>

<ul>
 	<li>
［
~server, ~proxy, ~client
］間で、
どの方向にも互いに~dataを転送し合う利用が増えている。
◎
Data transfers among servers, proxies, and clients, in all directions, have increased.
</li>
	<li>
US-ASCII
`ISO/IEC-646$r `MIME-charset$r
`~repertoire$に納まらない文字が利用される~~割合が更に高まっている。
◎
Characters outside the US-ASCII [ISO/IEC 646][MIME-charset] repertoire are being used in more and more places.
</li>
	<li>
異なる［
~protocol／形式
］を成す要素（要素や属性の名前, URI の各種~成分, ~textな内容など）による~data転送が増えている。
◎
Data transfers between different protocol/format elements (such as element/attribute names, URI components, and textual content) have increased.
</li>
	<li>
~protocolや形式のみならず，~APIも続々と定義されてきている。
◎
More and more APIs are defined, not just protocols and formats.
</li>
</ul>

<hr>

<p>
手短に言えば、
~Webは 互いに独立な小さな応用の集合体ではなく，一つのとても巨大な応用のように見えてきている（ `Nicol$r を見よ）。
◎
In short, the Web may be seen as a single, very large application (see [Nicol]), rather than as a collection of small independent applications.
</p>

<p>
これらの開発により、［
~Webのための文字~modelは~Unicodeに基づく
］とする要件が強まったことに加え，［
~Webに対する~Unicodeの適用に対する，追加的な仕様
］も必要になってきている。
~Unicodeの側面のうち［
~Web用に追加的な仕様を要求するもの
］には、
次が含まれる：
◎
While these developments strengthen the requirement that Unicode be the basis of a character model for the Web, they also create the need for additional specifications on the application of Unicode to the Web. Some aspects of Unicode that require additional specification for the Web include:
</p>
<ul>
 	<li>
`~Unicode符号化~形0$（ `UTF-8$ec ／ `UTF-16$ec ／ `UTF-32$ec ）を選ぶこと。
◎
Choice of Unicode encoding forms (UTF-8, UTF-16, UTF-32).
</li>
	<li>
長さが可変な`文字~符号化法$や, `結合~文字$の下での、
文字~数や, 文字列の長さの測定-法。
◎
Counting characters, measuring string length in the presence of variable-length character encodings and combining characters.
</li>
	<li>
文字の多重的な符号化法（例：`分解-可能$か分解-済みか）。
◎
Duplicate encodings of characters (e.g. precomposed vs decomposed).
</li>
	<li>
様々な目的での制御~codeの利用（例：`双方向性$の制御, `対称交換$, 等々）。
◎
Use of control codes for various purposes (e.g. bidirectionality control, symmetric swapping, etc.).
</li>
</ul>
<!-- symmetric swapping
http://en.wiktionary.org/wiki/Appendix:Control_characters
Enables or disables the mirroring of specific glyphs, such as the parentheses, in a bidirectional context. Deprecated.
 -->
<hr>

<p id="def-legacyEnc">
この種の側面は，様々な符号化法にも存在し、
多くの事例で，いろいろな仕方で~Unicodeに継承されていることも挙げておくべきであろう。
◎
It should be noted that such aspects also exist in various encodings, and in many cases have been inherited by Unicode in one way or another from these encodings.
</p>

<p>
この仕様の残りの部分では、
（ ~W3C, ISO, IETF による）以前の成果も踏まえ，
~Webのための文字~modelが相互運用能を確保するための追加的な要件を示す。
◎
The remainder of this specification presents additional requirements to ensure an interoperable character model for the Web, taking into account earlier work (from W3C, ISO and IETF).
</p>

<p>
`~Unicode標準$の最初の少数の章に，とても有用な背景情報が見られる。
また， `RFC2277$r には、
IETF により，~Internet上の`文字~集合$の利用~用に採択された施策が文書化されている。
◎
The first few chapters of the Unicode Standard [Unicode] provide very useful background reading. The policies adopted by the IETF for on the use of character sets on the Internet are documented in [RFC 2277].
</p>

		</section>
		<section id="sec-Notation">
<h3 title="Terminology and Notation">1.3. 記法</h3>

<p>
~Unicode符号位置は
<span class="code-point">U+<var>hhhh</var></span>
のように記される。
ここで “<var>hhhh</var>” は、
4 〜 6 個の 16 進~数字が成す並びである。
◎
Unicode code points are denoted as U+hhhh, where "hhhh" is a sequence of at least four, and at most six hexadecimal digits.
</p>

<p>
各 例の中では、
読者が~cut＆~pasteできるよう，~textが利用されている。
読者の環境に適切な`~font$が備わっていないと，
これらに利用される文字が意図されたとおりに現れないので、
そのような場合でも理解-可能になるよう~careされている。
一部の事例では，例示の結果が見えることが重要になるので、
画像も併用されている。
◎
Text has been used for examples to allow them to be cut and pasted by the reader. Characters used will not appear as intended unless you have the appropriate font, but care has been taken to annotate the examples so that they remain understandable even if you do not. In some cases it is important to see the result of an example, so images have been used; by clicking on the image it is possible to link to the text for these examples in C Example text.
</p>

<p class="trans-note">【
用語の対訳について：
~Unicode用のものは、
`Unicode Terminology English - Japanese＠https://www.unicode.org/terminology/term_en_ja.html$
から採用している。
】</p>

		</section>
	</section>
	<section id="sec-Conformance">
<h2 title="Conformance">2. 適合性</h2>

<p>
この節では、［［
仕様 ／ ~software ／ ~Web内容
］が，この仕様に適合すると主張-可能になる
］ために充足する必要がある条件が，どう記されるかについて説明する。
◎
This section explains the conditions that specifications, software, and Web content have to fulfill to be able to claim conformance to this specification.
</p>

<p>
この文書の中で利用される句［
`“MUST”, “MUST NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”^en
］は、
`RFC2119$r に則って解釈するものとする
【これらが日本語訳にてどう表記されるかについては、 `RFC 2119 が規定する句に利用される対訳＠index.html#rfc2119-phrase$を参照されたし。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 [RFC 2119].
</p>

<p class="note">注記：
【この段落の内容（ `SHOULD^en の意味の説明）の和訳は、省略する。】
◎
NOTE: RFC 2119 makes it clear that requirements that use SHOULD are not optional and must be complied with unless there are specific reasons not to: "This word, or the adjective "RECOMMENDED", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course."
</p>

<p>
この仕様は、［
仕様, ~software実装, ~Web内容
］向けに適合性の判定基準を定義する。
各 適合性の判定基準には、
これらのうち，どれに関連するかに応じて
— `-S^cf ／ `-I^cf ／ `-C^cf —
が前置される†。
これは、
読者が［
自身に関連な適合性の判定基準
］を この文書から すぐに探し出せるようにする††。
◎
This specification defines conformance criteria for specifications, for software, and for Web content. To aid the reader, all conformance criteria are preceded by '[X]' where 'X' is one of 'S' for specifications, 'I' for software implementations, and 'C' for Web content. These markers indicate the relevance of the conformance criteria and allow the reader to quickly locate relevant conformance criteria by searching through this document.
</p>

<p class="trans-note">【†
これらは、
原文では，略称［
<abbr title="Specification">[S]</abbr> ／
<abbr title="Implementation">[I]</abbr> ／
<abbr title="Content">[C]</abbr>
］で表記されている。
】【††
<a id="_list-of-req">下の各 ~~見出しをクリックすると巡回できる。</a>
】</p>

<dl>
	<dt id="_conform-spec" data-cycling=".req-S">`-S^cf</dt>
	<dd>
<p>
仕様は、
次をすべて満たすならば，この文書に適合する：
◎
A specification conforms to this document if it:
</p>
		<ul>
			<li>
`-S^cf が前置された適合性の判定基準に違反していない。
◎
does not violate any conformance criteria preceded by [S],
</li>
			<li>
［
“〜するベキ”,
“推奨される”
］と記された判定基準から逸脱する所では、
その理由が文書化されている。
◎
documents the reason for any deviation from criteria where the imperative is SHOULD, SHOULD NOT, or RECOMMENDED,
</li>
			<li>
適用-可能な所では、
当の仕様に適合する［
実装／内容
］に対し，この文書にも適合することを要求している。
◎
where applicable, requires implementations conforming to the specification to conform to this document,
◎
where applicable, requires content conforming to the specification to conform to this document.
</li>
		</ul>
	</dd>

	<dt id="_conform-impl" data-cycling=".req-I">`-I^cf</dt>
	<dd>
<p>
実装（~software）は、
次を満たすならば，この文書に適合する
⇒
`-I^cf が前置された適合性の判定基準に違反していない。
◎
An implementation (software) conforms to this document if it does not violate any conformance criteria preceded by [I].
</dd>

	<dt id="_conform-content" data-cycling=".req-C">`-C^cf</dt>
	<dd>
内容は、
次を満たすならば，この文書に適合する
⇒
`-C^cf が前置された適合性の判定基準に違反していない。
◎
Content conforms to this document if it does not violate any conformance criteria preceded by [C].
</dd>
</dl>

<p class="note">注記：
各~仕様により課される要件は、
当の仕様に適合するものと主張する［
実装／内容
］に対し，間接的に要件を課すこともある。
同様に，内容に課される要件は、
そのような内容を生産するよう設計された実装にも影響し得る，等々。
◎
NOTE: Requirements placed on specifications might indirectly cause requirements to be placed on implementations or content that claim to conform to those specifications. Likewise, requirements placed on content may affect implementations designed to produce such content, and so on.
</p>

<p>
この仕様において処理に対し要件を課す所では、
外部から見える挙動を指定しているものと解すること。
実装は、
観測され得る挙動が影響されない限り，同じ結果を達成する他の手段を利用できる。
◎
Where this specification places requirements on processing, it is to be understood as a way to specify the desired external behavior. Implementations can use other means of achieving the same results, as long as observable behavior is not affected.
</p>

	</section>
	<section id="sec-Perceptions">
<h2 title="Perceptions of Characters">3. 文字の知覚</h2>

		<section id="sec-PerceptionsIntro">
<h3 title="Introduction">3.1. 序論</h3>

<p>
`~Unicode標準$の `Unicode40$r の用語集には、
次のように記されている：
◎
The glossary entry in the Unicode Standard [Unicode 4.0] gives:
</p>

<blockquote>
文字（ `character$UT ）
— (1) 言語が記されるときの，意味論上の値を成す最~小な成分であって、
抽象的な意味や形状を参照rするもの…
◎
"Character. (1) The smallest component of written language that has semantic value; refers to the abstract meaning and/or shape ..."
</blockquote>

<p>
語 `文字^q は、
多くの文脈において，互いに異なる意味で利用されている。
ヒトの様々な文化における`書記体系$は，根本的に相違するため、
文字の概念も根本的に相違している。
そのような幅広い多様性の下では、
末端利用者は，誤解を［
経験する／呼ぶ
］ことが多い。
この多様性は，~~不完全な技術に起因するものと誤認されがちであるが、［
ヒトの思考の多大な柔軟性と創造性
］や［
ヒトの文化継承の中で重要な部分を成す筆記の長い伝統
］から導出されたものである。
［
~Latin, ~Cyrillic, ~Greek
］などの`用字系$に利用されている`~alphabet$類は、
そういった可能性の一つに過ぎない。
◎
The word 'character' is used in many contexts, with different meanings. Human cultures have radically differing writing systems, leading to radically differing concepts of a character. Such wide variation in end user experience can, and often does, result in misunderstanding. This variation is sometimes mistakenly seen as the consequence of imperfect technology. Instead, it derives from the great flexibility and creativity of the human mind and the long tradition of writing as an important part of the human cultural heritage. The alphabetic approach used by scripts such as Latin, Cyrillic and Greek is only one of several possibilities.
</p>

<div class="example">

<p>
~Japaneseの［
`平仮名$／`片仮名$
］`用字系$の文字は、
`音節$（通例的に`子音$と`母音$の組合n）に対応する。
◎
EXAMPLE: A character in Japanese hiragana and katakana scripts corresponds to a syllable (usually a combination of consonant plus vowel).
</p>

<p>
~Koreanの`~Hangul$は、
言語の個々の響きに対応する記号を正方形な~~枠内に組合せる
— それを成す それぞれが 1 個の`音節$を表現する。
利用者と応用に依存して、［
個々の記号, 音節~cluster
］どちらかが文字と見なされ得る。
◎
EXAMPLE: Korean Hangul combines symbols for individual sounds of the language into square blocks, each of which represents a syllable. Depending on the user and the application, either the individual symbols or the syllabic clusters can be considered to be characters.
</p>

<p>
~Indicの`用字系$は、
`子音$を成す各`字l$が内来的な`母音$を抱えている
— それは、［
`子音$と`母音$を~clusterの中で組合わす
］ために，半規則的または不規則な仕方を利用して脱落されたり置換される。
利用者や応用に依存して、［
個々の［
`子音$, `母音$
］,
`子音$や子音-母音が成す~cluster
］どちらかが文字として知覚され得る。
◎
EXAMPLE: In Indic scripts each consonant letter carries an inherent vowel that is eliminated or replaced using semi-regular or irregular ways to combine consonants and vowels into clusters. Depending on the user and the application, either individual consonants or vowels, or the consonant or consonant-vowel clusters can be perceived as characters.
</p>

<p>
~Arabicや~Hebrewでは、
`母音$の響きは，概して まったく書き記されない。
それらが書き記されるときは、
子音的な`字l$の［
上／下
］に置かれる`結合~符$
【`シャクル＠https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%A3%E3%82%AF%E3%83%AB$, `ニクダー＠https://ja.wikipedia.org/wiki/%E3%83%8B%E3%82%AF%E3%83%BC%E3%83%89$】
の利用により指示される。
◎
EXAMPLE: In Arabic and Hebrew vowel sounds are typically not written at all. When they are written they are indicated by the use of combining marks placed above and below the consonantal letters.
</p>
</div>

<p>
それらの仕様に基づく仕様や~softwareの開発者は、
彼らが経験してきた用語 `文字$q の用法に，より馴染んでいて、
国際的な文脈の下での多様な用法には疎くなりがちである。
更に，~computer利用の文脈の中では、
文字は関係する概念と混同され，［
不完全／不適切
］な仕様や~softwareが作り上げられることが多い。
◎
The developers of specifications, and the developers of software based on those specifications, are likely to be more familiar with usages of the term 'character' they have experienced and less familiar with the wide variety of usages in an international context. Furthermore, within a computing context, characters are often confused with related concepts, resulting in incomplete or inappropriate specifications and software.
</p>

<p>
この節では、
これらのうちいくつかの［
文脈, 意味, 混同
］について精査する。
◎
This section examines some of these contexts, meanings and confusions.
</p>

		</section>
		<section id="sec-WritingSystem">
<h3 title="Units of aural rendering">3.2. 聴覚的な具現化の単位</h3>

<p>
`用字系$には、
文字と音素の関係性が深いものもあれば，文字が意味と深く関係しているものもある。
（`音素$（ `phoneme^en ）とは、
特定0の音声言語の文脈において区別し得る必要最小限な響きである）。
文字が音素に（ゆるく）対応する場合でも、
この関係性は単純でないことが多く，文字と音素が一対一に対応することは稀である。
◎
In some scripts, characters have a close relationship to phonemes (a phoneme is a minimally distinct sound in the context of a particular spoken language), while in others they are closely related to meanings. Even when characters (loosely) correspond to phonemes, this relationship may not be simple, and there is rarely a one-to-one correspondence between character and phoneme.
</p>

<div class="example">
<p>
英文の
“`They were too close to the door to close it.^s”
では、
/s/, /z/ 両 `音素$とも，その表現に同じ文字 `s^ch が利用される。
◎
EXAMPLE: In the English sentence, "They were too close to the door to close it." the same character 's' is used to represent both /s/ and /z/ phonemes.
</p>

<p>
~Englishの “`cool^s” の音素 /k/ は、
“`keel^s” の音素 /k/ と似ている。
◎
EXAMPLE: In the English language the phoneme /k/ of "cool" is like the phoneme /k/ of "keel".
</p>

<p>
多くの`用字系$で、
例えば~Japaneseの`平仮名$の音節~文字のように， 1 個の文字が一連の`音素$の並びを表現し得る。
◎
EXAMPLE: In many scripts a single character may represent a sequence of phonemes, such as the syllabic characters of Japanese hiragana.
</p>

<p>
多くの`書記体系$は、
例えば［
“`thing^s” の `th^ch や `ng^ch
］のように，
複数個の文字が成す並びが 1 個の`音素$を表現し得る。
◎
EXAMPLE: In many writing systems a sequence of characters may represent a single phoneme, for example 'th' and 'ng' in "thing".
</p>
</div>

<p class="req">`001-SIC@cf
［
仕様／~software／内容
］は、
言語を成す［
文字と響き
］の一対一な対応関係に依存したり，それを要求してはナラナイ。
◎
C001 [S] [I] [C] Specifications, software and content MUST NOT require or depend on a one-to-one correspondence between characters and the sounds of a language.
</p>

		</section>
		<section id="sec-VisualRenderingUnits">
<h3 title="Units of visual rendering">3.3. 視覚的な具現化の単位</h3>

<p>
文字の描画（視覚的な`具現化$）は、
`~glyph$の観念（ `notion^en ）を導入する。
`ISO/IEC-9541-1$r によれば、
`~glyph@
（ `glyph$UT ）とは，
<q>認識-可能な抽象的な~graphic記号であって，特定の~designに依存しないもの</q>
として定義されている。
文字と~glyphとの間には、
一対一な対応関係が`あるとは限らない^em：
◎
Visual rendering introduces the notion of a glyph. Glyphs are defined by ISO/IEC 9541-1 [ISO/IEC 9541-1] as "a recognizable abstract graphic symbol which is independent of a specific design". There is not a one-to-one correspondence between characters and glyphs:
</p>

<ul>
	<li>
1 個の文字が複数個の`~glyph$で表現されることもある
（各~glyphは、その文字の表現の一部を成す）。
これらの~glyphは、
物理的に分離され得る。
◎
A single character can be represented by multiple glyphs (each glyph is then part of the representation of that character). These glyphs may be physically separated from one another.
</li>
	<li>
1 個の`~glyph$が複数個の文字が成す並びを表現することもある（例えば`合字$
— 他にもある）。
◎
A single glyph may represent a sequence of characters (this is the case with ligatures, among others).
</li>
	<li>
<p>
同じ文字が、
文脈に依存して，まったく異なる`~glyph$で描画されることもある。
◎
A character may be rendered with very different glyphs depending on the context.
</p>

<p class="trans-note">【
例えば，~Japaneseの一部の文字（句読点や長音など）は、
縦書きと横書きで異なる~glyphが利用されよう。
記号~類のみならず、
この仕様の`~Persianの例＠#arabicLigature-0$には，
単語~内の位置に応じて利用される~glyphが変化する例が挙げられている。
】</p>
	</li>
	<li>
同じ`~glyph$が，異なる文字を表現することもある（例：
~Latin大字 A （ `0041^U ）,
~Greek大字 Α （ `0391^U ）,
~Cyrillic大字 А （ `0410^U ）
）
◎
A single glyph may represent different characters (e.g. capital Latin A, capital Greek A and capital Cyrillic A).
</li>
</ul>
<hr>

<p>
`~glyph$の集合は
`~font@
（ `font$UT ）を成す。
文字が［
符号化された~textを組織化するための基本的な単位
］を成すのと同じ様に、
一連の~glyphも［
~textの視覚的な描画を組織化するための基本的な単位
］を成すように構築され得る。
◎
A set of glyphs makes up a font. Glyphs can be construed as the basic units of organization of the visual rendering of text, just as characters are the basic unit of organization of encoded text.
</p>

<p class="req">`002-SIC@cf
［
仕様／~software／内容
］は、
文字と［
~textの表示~単位
］の一対一な対応関係に依存したり，それを要求してはナラナイ。
◎
C002 [S] [I] [C] Specifications, software and content MUST NOT require or depend on a one-to-one mapping between characters and units of displayed text.
</p>

<p>
`付録 B. 文字, ~keystroke, ~glyphの例＠#sec-CharExamples$に，
文字から`~glyph$への対応関係の複階性を示す例が挙げられている。
◎
See the appendix B Examples of Characters, Keystrokes and Glyphs for examples of the complexities of character to glyph mapping.
</p>

			<section id="sec-LogicalOrder">
<h4 title="Visual Rendering and Logical Order">3.3.1. 視覚的な具現化と論理-順序</h4>

<p>
一部の`用字系$, 特に~Arabicと~Hebrewは、
右から左へ書かれる。
これらの`用字系$の文字が含まれた~textは、
左右両~方向に流れ得るので，`双方向-~text$と呼ばれる。
`~Unicode標準$では、
文字が
`論理-順序$（ `logical order^en ）で［
格納する／交換iする
］ことが要求される。
すなわち、
ほぼ，~textが［
~keyboardで打込まれた／話された
］順序に対応する（詳細な定義は `Unicode40$r, § 2.2 を見よ）。
`論理-順序$による順序付けは、
~dataの相互運用能を確保するため, および［
~accessibility, 探索処理, `照合c$（ `collation^en 【言語や文脈に依存する~sort順序法】）
］の便益を得るためにも重要になる。
◎
Some scripts, in particular Arabic and Hebrew, are written from right to left. Text including characters from these scripts can run in both directions and is therefore called bidirectional text. The Unicode Standard [Unicode] requires that characters be stored and interchanged in logical order, i.e. roughly corresponding to the order in which text is typed in via the keyboard or spoken (for a more detailed definition see [Unicode 4.0], Section 2.2). Logical ordering is important to ensure interoperability of data, and also benefits accessibility, searching, and collation.
</p>

<p class="req">`003-SIC@cf
［
~protocol／形式／~API
］は、
~text~dataを`論理-順序$で［
格納-, 交換i-, 処理-
］しなければナラナイ。
◎
C003 [S] [I] [C] Protocols, data formats and APIs MUST store, interchange or process text data in logical order.
</p>

<p>
`双方向-~text$の下では、
アリな~text選択~modeが 2 つある。
先ず，論理的な選択~modeは、
利用者の~mouse~gestureの両端の合間に`論理的^emに所在するすべての文字を選択する。
◎
In the presence of bidirectional text, two possible selection modes can be considered. The first is logical selection mode, which selects all the characters logically located between the end-points of the user's mouse gesture.＼
</p>

<p>
次の図に，利用者が~Arabicの~text［
`&#x0639;&#x062F;&#x062F; &#x0645;&#x0627;&#x0631;&#x0633; &#x0661;&#x0669;&#x0669;&#x0668;^s
］を成す［
2 個目の単語の 1 個目と 2 個目の`字l$の合間から,
年号（ 3 個目の単語）の 2 桁目まで
］を選択した場合の，論理的な選択を視覚-表示とともに示す：
◎
Here the user selects from between the first and second letters of the second word to the middle of the number. Logical selection looks like this:
</p>

<table>
<caption>
論理的な選択により視覚的な範囲が不連続になる
<small>（
`双方向-~text$の文脈~下における，~memory内の単独の論理的な選択と,
その結果~得られる~screen上の 2 個の選択範囲を示す， 2 つの画像
）</small>
◎
Logical selection resulting in discontiguous visual ranges
(Two images contrasting a single logical selection in memory and the resulting two selections on screen, in a bidi context)
</caption>
<thead>
<tr><td><th>視覚-表示
<th>`論理-順序$
<tbody>

<tr><th>画像
<td>
<p class="alt" hidden id="_dgm-logSelScreen">
同じ例で，選択~textが強調されたときの~screen上での表示を示す画像。
2 個の分離された文字~blockが強調される。
◎
The same example, showing how the text would look on-screen when highlighted, showing two separate highlighted character ranges.
</p>

<td>
<p class="alt" hidden id="_dgm-logSelMemory">
2 個の~Arabicの単語に年号が後続する文字列における論理-順序による文字~並び。
2 個目の単語の途中から年号の途中までの範囲に入る文字が選択されたとするとき、
論理-選択~modeでは，強調される範囲が 1 個の連続的な文字~並びになる。
◎
An example showing the logical order of characters in a string containing two Arabic words followed by a year number. In logical selection mode, the range of characters selected by starting the selection in the middle of the second word and ending in the middle of the year number is depicted using highlighting. The highlighting covers a single block of contiguous characters."
</p>

<tr><th>【~text】
<td>
`&#x0639;&#x062F;&#x062F; &#x0645;<span style="background: black; color:white">&#x0627;&#x0631;&#x0633; &#x0661;&#x0669;</span>&#x0669;&#x0668;^s

<td>
<bdo dir="ltr">&#x0639; &#x062F; &#x062F; &lt;space&gt; &#x0645; <span style="background: black; color:white">&#x0627; &#x0631; &#x0633; &lt;space&gt; &#x0661; &#x0669;</span> &#x0669; &#x0668;</bdo>

<!-- 

عدد مارس ١٩٩٨

-->
</table>

<p>
したがって，`双方向-~text$の下では、
~memory内における連続的な論理的な選択が，`~screen上では不連続に現れる^emことになる。
この不連続性があるため、
一部の利用者からは，~mouse~gestureの両端に挟まれる中の`視覚的^emに所在するすべての文字を選択する，視覚的な選択~modeも選好される。
◎
It is a consequence of the bidirectionality of the text that a single, continuous logical selection in memory results in a discontinuous selection appearing on the screen. This discontinuity makes some users prefer a visual selection mode, which selects all the characters visually located between the end-points of the user's mouse gesture.＼
</p>

<p>
前の例と同じ~mouse~gestureによる結果は、
次の図の様になる：
◎
With the same mouse gesture as before, we now obtain:
</p>

<table>
<caption>
視覚的な選択により論理-範囲が不連続になる
<small>（
`双方向-~text$の文脈~下における，~screen上の単独の視覚的な選択とその結果~得られる, ~memory内の 2 個の選択範囲を示す， 2 つの画像
）</small>
◎
Visual selection resulting in discontiguous logical ranges
(Two images contrasting a single visual selection on screen and the resulting two selections in memory, in a bidi context)
</caption>
<thead>
<tr><td><th>視覚-表示
<th>`論理-順序$
<tbody>

<tr><th>画像
<td>
<p class="alt" hidden id="_dgm-visSelScreen">
同じ例で，選択~textが強調されたときの~screen上での表示を示す画像。単独の連続する文字~blockが強調される。
◎
same example, showing how the text would look on-screen when highlighted, showing a single highlighted block of contiguous characters.
</p>
<td>
<p class="alt" hidden id="_dgm-visSelMemory">
2 個の~Arabicの単語に年号が後続する文字列における論理-順序による文字~並び。
2 個目の単語の途中から年号の途中までの範囲に入る文字が選択されたとするとき、
視覚的な選択~modeでは，強調される範囲が 2 個の分離された文字~blockになる。
◎
An example showing the logical order of characters in a string containing two Arabic words followed by a year number. In visual selection mode, the range of characters selected by starting the selection in the middle of the second word and ending in the middle of the year number is depicted using highlighting. The highlighting covers two separate blocks of characters.
</p>
<tr><th>【~text】
<td>
`&#x0639;&#x062F;&#x062F; &#x0645;<span style="background: black; color:white">&#x0627;&#x0631;&#x0633; </span>&#x0661;&#x0669;<span style="background: black; color:white">&#x0669;&#x0668;</span>^s

<td>
<bdo dir="ltr">&#x0639; &#x062F; &#x062F; &lt;space&gt; &#x0645; <span style="background: black; color:white">&#x0627; &#x0631; &#x0633;</span> &lt;space&gt; &#x0661; &#x0669; <span style="background: black; color:white">&#x0669; &#x0668;</span></bdo>
</table>

<p>
視覚的な選択~modeにおいては
— 上の例に見られるように —
1 個の視覚的な選択から`複数個^emの論理-範囲が得られ得るので、［
~protocol, ~API, 実装
］による適応の必要が生じ得る。
他の［
`双方向-~text$用の~UIに関係する側面
］としては、
~caretの動き, ［
<kbd>`backspace^kbd</kbd>／<kbd>`delete^kbd</kbd>
］~UIkeyの挙動などがある。
◎
In visual selection mode, as seen in the example above, a single visual selection range may result in two or more logical ranges, which may have to be accommodated by protocols, APIs and implementations. Other, related aspects of a user interface for bidirectional text include caret movement, behavior of backspace/delete keys, and so on.
</p>

<p>
現時点では、
ほとんどの実装が論理的な選択を供している
— 視覚的な選択を供している実装は、
ごく限られている。
◎
Currently, most implementations provide logical selection, while only very few provide visual selection.
</p>

<p class="req">`075-I@cf
選択された文字は、
実装の一部が［
論理的な選択, 視覚的な選択
］どちらを利用しようが，格納~域においては`論理-順序$を保つモノトスル。
◎
C075 [I]Independent of whether some implementation uses logical selection or visual selection, characters selected MUST be kept in logical order in storage.
</p>

<p class="req">`004-S@cf
範囲の選択を孕む［
~protocol／~API
］の仕様は、［
少なくとも，~screen上の視覚的な選択の実装を~supportするために必要yな所まで
］は，不連続な論理的な選択を当の［
~protocol／~API
］の上層に供するベキである。
◎
C004 [S] Specifications of protocols and APIs that involve selection of ranges SHOULD provide for discontiguous logical selections, at least to the extent necessary to support implementation of visual selection on screen on top of those protocols and APIs.
</p>

			</section>
		</section>
		<section id="sec-InputUnits">
<h3 title="Units of input">3.4. 入力の単位</h3>

<p>
~keyboard入力においては，~keystrokeと入力される文字に一対一な対応関係があるとは`限らない^em。
~keyboardの~UIkeyの個数は限られている。
一部の~keyboardは、
1 回の~UIkey押下から複数個の文字を生成する。
~UIkeyが文字を生成する代わりに，後続な~UIkey押下の結果に影響する事例もある（~dead-key）。
多くの`書記体系$は，~keyboardに納まり切らない多数の文字を備えるので、
~keystroke並びを文字~並びに変換する，より複階的な~IME（ `input-method^en ）に依拠しなければならない。
一部の文字の入力には特殊な修飾keyが必要yな言語もある。
自明でない入力の例については
`付録 B. 文字, ~keystroke, ~glyphの例＠#sec-CharExamples$
を見よ。
◎
In keyboard input, it is not always the case that keystrokes and input characters correspond one-to-one. A limited number of keys can fit on a keyboard. Some keyboards will generate multiple characters from a single keypress. In other cases ('dead keys') a key will generate no characters, but affect the results of subsequent keypresses. Many writing systems have far too many characters to fit on a keyboard and must rely on more complex input methods, which transform keystroke sequences into character sequences. Other languages may make it necessary to input some characters with special modifier keys. See B Examples of Characters, Keystrokes and Glyphs for examples of non-trivial input.
</p>

<p class="req">`005-SI@cf
［
仕様／~software
］は、
次を要求したり, それに依存してはナラナイ
⇒＃
1 回の~keystrokeから 1 個の文字が得られる ／
1 個の文字は 1 回の~keystroke（修飾keyを伴うものも含む）で入力される ／
世界中のどの~keyboardも同じである
◎
C005 [S] [I] Specifications and software MUST NOT require nor depend on a single keystroke resulting in a single character, nor that a single character be input with a single keystroke (even with modifiers), nor that keyboards are the same all over the world.
</p>

		</section>
		<section id="sec-CollationUnits">
<h3 title="Units of collation">3.5. 照合cの単位</h3>

<p>
［
~sortする／探索する
］ときに利用される文字列の比較は、
一般に，符号化された文字と一対一に対応しない単位に基づいている。
そのような文字列~比較においては、
次が生じることもある
⇒＃
文字~並びが ~sort時の順序において自前の位置を持つような 1 個の照合c単位（ `collation unit^en ）に集成される／
1 個の文字が複数個の照合c単位に分離される／
文字の様々な側面（`文字大小$, `発音区別符$の有無, 等々）が判別され，別々に~sortされる（多段階な~sort法）
◎
String comparison as used in sorting and searching is based on units which do not in general have a one-to-one relationship to encoded characters. Such string comparison can aggregate a character sequence into a single collation unit with its own position in the sorting order, can separate a single character into multiple collation units, and can distinguish various aspects of a character (case, presence of diacritics, etc.) to be sorted separately (multi-level sorting).
</p>

<p>
加えて、
一定量の前処理が要求される場合もある。
また，一部の言語（~Japaneseや~Arabicなど）では、
~sort順序が，より高次な順序付け要因
— 発音体系や語源など —
により統治され得る。
`照合c$（ `collation^en ）の手法は、
応用に応じて変わることもある。
◎
In addition, a certain amount of pre-processing may also be required, and in some languages (such as Japanese and Arabic) sort order may be governed by higher order factors such as phonetics or word roots. Collation methods may also vary by application.
</p>

<div class="example">

<ul>
	<li>
【~Japaneseでは、`漢字$がその画数／偏／旁に基づいて~sortされたり, 語句がその読み~~仮名の順で~sortされる場合もある。】
</li>
	<li>
~Spanishの伝統的な~sort法では、
文字~並び `ch^ch, および `ll^ch は不可分な照合c単位として扱われる。
~Spanishにおける `ch^ch は、［
~sort法／ある~~範囲の日常~利用
］においては 1 個の単位と扱われる一方で、
現在の~digital符号化法では 2 個の文字として扱われ，~keyboardも同じに扱う（利用者は［
<kbd>`c^kbd</kbd>, <kbd>`h^kbd</kbd>
］を順に打込む）。
◎
EXAMPLE: In traditional Spanish sorting, the character sequences 'ch' and 'll' are treated as atomic collation units. Although Spanish sorting, and to some extent Spanish everyday use, treat 'ch' as a single unit, current digital encodings treat it as two characters, and keyboards do the same (the user types 'c', then 'h').
</li>
	<li>
一部の言語では、
`字l$ `æ^ch が， 2 個の連続する照合c単位［
`a^ch, `e^ch
］として~sortされる。
◎
EXAMPLE: In some languages, the letter 'æ' is sorted as two consecutive collation units: 'a' and 'e'.
</li>
	<li>
大文字・小文字の区別がある（ `bicameral$UT な）`用字系$で書かれた~textを~sortするときは、
通例的に，最初の処理回では`文字大小$を無視することが要求され，後の処理回の中で文字大小が~~仕分けに利用される。
◎
EXAMPLE: The sorting of text written in a bicameral script (i.e. a script which has distinct upper and lower case letters) is usually required to ignore case differences in a first pass; case is then used to break ties in a later pass.
</li>
	<li>
~sort時における`~accent$を伴う`字l$の扱いは、
対象の`用字系$や言語に依存する。
`字l$ `ö^ch は、
~Frenchでは修飾された `o^ch として扱われる一方，~Swedishでは `o^ch と完全に独立な`字l$として扱われる（加えて， `z^ch の後に~sortされる）。
~Germanでは、
一部の応用は `ö^ch を `oe^ch の並びであるかのように扱う。
◎
EXAMPLE: Treatment of accented letters in sorting is dependent on the script or language in question. The letter 'ö' is treated as a modified 'o' in French, but as a letter completely independent from 'o' (and sorting after 'z') in Swedish. In German certain applications treat the letter 'ö' as if it were the sequence 'oe'.
</li>
	<li>
~Thaiでは、
`ไก^ch (`0E44^U `0E01^U) 並びが `กไ^ch (`0E01^U `0E44^U) と記されているかのように~sortされなければならない。
この種の並替ngは、
概して，前処理の段階で行われる。
◎
EXAMPLE: In Thai the sequence 'ไก' (U+0E44 U+0E01) must be sorted as if it were written 'กไ' (U+0E01 U+0E44). Reordering is typically done during an initial pre-processing stage.
</li>
	<li>
~Germanの辞書では、
概して，［
`ä^ch ／ 
`ö^ch ／
`ü^ch
］が［
`a^ch ／
`o^ch ／
`u^ch
］と一緒にされて~sortされる。
一方で，~Germanの電話帳では、
概して，［
`ä^ch ／
`ö^ch ／
`ü^ch
］が［
`ae^ch ／
`oe^ch ／
`ue^ch
］と綴られているかのように~sortされる。
このように、
利用される照合c~algoは，応用に依存する。
◎
EXAMPLE: German dictionaries typically sort 'ä', 'ö' and 'ü' together with 'a', 'o' and 'u' respectively. On the other hand, German telephone books typically sort 'ä', 'ö' and 'ü' as if they were spelled 'ae', 'oe' and 'ue'. Here the application is affecting the collation algorithm used.
</li>
</ul>
</div>

<p class="req">`006-SI@cf
利用者のために~textを［
~sortする／探索する
］~softwareは、
関連な［
言語や応用
］に適切な［
照合c単位と順序付け規則
］に基づいて，それを行うベキである。
◎
C006 [S] [I] Software that sorts or searches text for users SHOULD do so on the basis of appropriate collation units and ordering rules for the relevant language and/or application.
</p>

<p class="req">`007-SI@cf
動的に［
探索する／~sortする
］所では、
特に多言語~環境においては， “関連な言語” が現在の利用者のそれになるように（したがって利用者ごとに相違し得るように）決定するベキである
◎
C007 [S] [I] Where searching or sorting is done dynamically, particularly in a multilingual environment, the 'relevant language' SHOULD be determined to be that of the current user, and may thus differ from user to user.
</p>

<p class="req">`066-SI@cf
~textを［
~sortする／探索する
］ことを利用者に許容する~softwareは、［
照合c単位と順序付け
］用に，代替な規則を選択することも利用者に許容するベキである。
◎
C066 [S] [I] Software that allows users to sort or search text SHOULD allow the user to select alternative rules for collation units and ordering.
</p>

<p class="req">`008-SI@cf
［
~sortする／探索する
］~algoの［
仕様や実装
］は、
~textが~Unicodeのどの文字を含んでいても，適応するベキである。
◎
C008 [S] [I] Specifications and implementations of sorting and searching algorithms SHOULD accommodate text that contains any character in Unicode.
</p>

<p>
したがって，~textに当の規則が受持たない~Unicode文字が含まれている場合でも、
最低でも，照合c~algoが~~正常に~~働き続けることが要求されることに注意。
これは、［
すべての`用字系$に対応できる，複階的な~algo
］の全部的な実装を要求するものではない。
この要件を満たす有用な仕方として、［
すべての~Unicode文字を受持つ，既定の照合c~algo
］を適用することが挙げられる。
◎
Note that this requires, as a minimum, that a collation algorithm does not break down if the text contains Unicode characters that are not covered by its rules. It does not necessarily require full implementation of complex algorithms for all scripts. One useful way of satisfying the requirement is to apply a default collation algorithm that covers all Unicode characters.
</p>

<p>
`ISO/IEC-14651$r, および［
`UTR10$r による`~Unicode照合c~algo$
］は、
ほとんどの言語に適応する`照合c$用の~modelを述べて，既定の照合c順序を供している。
それらは、［
`照合c$とその実装
］の指針を供する，適切な基準になる。
いかなる文字が含まれようとも，文字列の［
順序付けと比較
］が予測-可能になることを確保するために、
既定の照合c順序を［
特定0の~locale用に誂えられた規則
］と併用できる。
◎
ISO/IEC 14651 [ISO/IEC 14651] and Unicode Technical Report #10, the Unicode Collation Algorithm [UTR #10], describe a model for collation that accommodates most languages and provide a default collation order. They are appropriate references for collation and provide implementation guidelines. The default collation order can be used in conjunction with rules tailored for a particular locale to ensure a predictable ordering and comparison of strings, whatever characters they include.
</p>

		</section>
		<section id="sec-Storage">
<h3 title="Units of storage">3.6. 格納~単位</h3>

<p>
~computerにおける~dataの格納と通信は、
情報の物理的な［
格納／交換i
］単位
— ~bitや`~byte$（~octetとも呼ばれる 8-bit 単位）など —
に依拠する。
仕様や実装にありがちな誤りは、
物理的な格納~単位による文字の同等性比較である。
文字とそのような格納~単位との間の対応関係は、
実際にはかなり複階的であり，
`§ 文字~符号化法$にて論じられる。
◎
Computer storage and communication rely on units of physical storage and information interchange, such as bits and bytes (8-bit units, also called octets). A frequent error in specifications and implementations is the equating of characters with units of physical storage. The mapping between characters and such units of storage is actually quite complex, and is discussed in the next section, 4.1 Character Encoding.
</p>

<p class="req">`009-SI@cf
［
仕様／~software／内容
］は、
文字と物理的な格納~単位との一対一な対応関係に依存したり，それを要求してはナラナイ。
◎
C009 [S] [I] Specifications, software and content MUST NOT require or depend on a one-to-one relationship between characters and units of physical storage.
</p>

		</section>
		<section id="sec-PerceptionsOutro">
<h3 title="Summary">3.7. 要約</h3>

<p>
用語 文字は，様々な文脈の下で異なる仕方で利用されるので、
それらの文脈の外で利用された際に，混同を導くことが多い。
~textの~digital表現の文脈においては、
`文字@
は，~textの小さな論理-単位として定義できる。
その上で、
`~text@
が文字たちが成す並びとして定義される。
そのような非正式な定義は、
多くの事例で，共通な理解を［
醸成する／捕捉する
］に足るものではあるが、
詳細が~~問題になり始めるや否や，誤解を醸成する道を開くに足るものにもなる。
実効な［
仕様／~protocol実装／末端利用者~向け~software
］を書くためには、
これらの誤解が生じ得ることを理解しておくことがとても重要である。
◎
The term character is used differently in a variety of contexts and often leads to confusion when used outside of these contexts. In the context of the digital representations of text, a character can be defined as a small logical unit of text. Text is then defined as sequences of characters. While such an informal definition is sufficient to create or capture a common understanding in many cases, it is also sufficiently open to create misunderstandings as soon as details start to matter. In order to write effective specifications, protocol implementations, and software for end users, it is very important to understand that these misunderstandings can occur.
</p>

<p>
この `§ 文字の知覚$では、
用語 `文字$q とは必ずしも一致しない単位~用の用語
— `音素$, `~glyph$, `照合c$など —
について論じた。
次節 `§ 文字~符号化法$では、
符号化の単位（`符号位置$, `符号単位$, `~byte$）を精確に定義するために，`文字$qに代えて利用されるべき用語について述べる。
◎
This section, 3 Perceptions of Characters, has discussed terms for units that do not necessarily overlap with the term 'character', such as phoneme, glyph, and collation unit. The next section, 4.1 Character Encoding, lists terms that should be used rather than 'character' to precisely define units of encoding (code point, code unit, and byte).
</p>

<p class="req">`010-S@cf
用語 `文字$qを利用する仕様は、
それが意図する意味を定義しなければナラナイ。
◎
C010 [S] When specifications use the term 'character' the specifications MUST define which meaning they intend.
</p>

<p class="req">`067-S@cf
仕様は、
可用なときは，一般~用語 “文字” に代えて，特定の用語を利用するベキである。
◎
C067 [S] Specifications SHOULD use specific terms, when available, instead of the general term 'character'.
</p>

		</section>
	</section>
	<section id="sec-Characters">
<h2 title="Digital Encoding of Characters">4. 文字の~digital符号化法</h2>

		<section id="sec-Digital">
<h3 title="Character Encoding">4.1. 文字~符号化法</h3>

<p>
~Webにおいては、
文字は，~computer利用~環境と同じく，どう利用するにしても符号化されなければならない。
~textを符号化するために、
多種多様な`文字~符号化法$が~~考案されている。
`文字~符号化法$とは、
概ね，利用者が操作する文字~並びと~computerが操作する~bit列の間の対応関係として説明される。
◎
On the WWW, as in any computing environment, characters must be encoded to be of any use. To achieve text encoding, a large variety of character encodings have been devised. Character encodings can loosely be explained as mappings between the character sequences that users manipulate and the sequences of bits that computers manipulate.
</p>

<p>
~text符号化法の複階性と，~computerの時代を通して考案されてきた `文字~符号化法$用の多種多様な仕組みが与えられた下では、
より正式な符号化~処理-の記述が有用になる。
~textの符号化~処理-を定義する過程は、
次のように述べられる（より詳細な記述は `UTR17$r を見よ）：
◎
Given the complexity of text encoding and the large variety of mechanisms for character encoding invented throughout the computer age, a more formal description of the encoding process is useful. The process of defining a text encoding can be described as follows (see Unicode Technical Report #17: Character Encoding Model [UTR #17] for a more detailed description):
</p>

<ol>
	<li>
<p>
まず、
`~repertoire@
（ `repertoire$UT ）
— 符号化される文字【`抽象-文字$】が成す集合 —
が識別される。
それらの文字は、
いくつかの対象~言語の下で［
~textを表出して，様々な~text処理を効率的に行える
］よう，実利的に選ばれる。
それらは、
利用者が`字l$その他の文字として知覚しているものとは，精確に対応していないかもしれない。
◎
A set of characters to be encoded is identified. The characters are pragmatically chosen to express text and to efficiently allow various text processes in one or more target languages. They may not correspond precisely to what users perceive as letters and other characters. The set of characters is called a repertoire.
</p>

<p class="trans-note">【
~repertoireは、
通例的には固定的（ “`closed^en” ）にされるが，一般には拡張可能（ “`open^en” ）なものもあり得る。
】</p>

	</li>
	<li>
<p>
次に，`~repertoire$を成す各~文字は、
`符号位置@
（ `code point$UT ）
— （数学的, 抽象的な）負でない整数 —
に結付けられる。
その結果、
`有符号~文字~集合@
（ `coded character set$UT, 略称 `CCS^abbr ）
— ~repertoireから負でない整数が成す集合への対応関係 —
が得られる。
（符号位置は、
`character number^en あるいは `code position^en と呼ばれることもある。）
◎
Each character in the repertoire is then associated with a (mathematical, abstract) non-negative integer, the code point (also known as a character number or code position). The result, a mapping from the repertoire to the set of non-negative integers, is called a coded character set (CCS).
</p>

<p class="trans-note">【
逐語訳的には、
“`code position^en” の対訳が “~~符号位置” になり，
“`code point^en” の対訳は “~~符号点” になる所だが、
~Unicodeの公式的な対訳表に倣い，
“`code point^en” の対訳には “~~符号位置” を採用している。
】</p>

	</li>
	<li>
~computerにおける利用に相応しい，ある基底~data型（`~byte$や 16-bit などの格納~単位）が識別された上で、
`文字~符号化~形0@
（ `character encoding form$UT, 略称 `CEF^abbr ）†
が利用される
— それは、
`有符号~文字~集合$（ `CCS^abbr ）を成す抽象的な整数を［
`符号単位@
（ `code unit$UT ）と呼ばれる，基底~data型の値
］たちが成す並びへ符号化するための~~写像である。
`文字~符号化~形0$は、
ごく単純なもの
（一例として， `CCS^abbr の整数を~computer~platformで選ばれた~data型による，整数の自然な表現に符号化するもの）
から，いくらでも複階的なもの
（ 1 個の抽象的~整数を符号化した結果が，可変~個数の［
整数から自明でない関数で得られる符号単位
］からなるもの）
にもなり得る。
◎
To enable use in computers, a suitable base datatype is identified (such as a byte, a 16-bit unit of storage or other) and a character encoding form (CEF) is used, which encodes the abstract integers of a coded character set (CCS) into sequences of the code units of the base datatype. The character encoding form can be extremely simple (for instance, one which encodes the integers of the CCS into the natural representation of integers of the chosen datatype of the computing platform) or arbitrarily complex (a variable number of code units, where the value of each unit is a non-trivial function of the encoded integer).
</li>
	<li>
<p>
最後に，~byte単位の伝送／格納を可能化するために、
`文字~符号化~scheme@
（ `character encoding scheme$UT, 略称 `CES^abbr ）が利用される（直列化~scheme（ `serialization scheme^en ）とも呼ばれる）。
`文字~符号化~scheme$とは，`文字~符号化~形0$の`符号単位$から~byte列へのきちんと定義された対応関係であり、
~data型が複数~byteに基づく場合に必要yな~byte順の指定や，一部の事例では，複数の文字~符号化~schemeの下での`符号単位$ごとの~schemeの切替も含まれる（例： ISO 2022 ）。
◎
To enable transmission or storage using byte-oriented devices, a serialization scheme or character encoding scheme (CES) is next used. A character encoding scheme is a mapping of the code units of a character encoding form (CEF) into well-defined sequences of bytes, taking into account the necessary specification of byte-order for multi-byte base datatypes and including in some cases switching schemes between the code units of multiple character encoding schemes (an example is ISO 2022).＼
</p>

<p class="trans-note">【
“きちんと定義された（ `well-defined^en ）”
— この語の~~解釈は注意を要する：
例えば対応関係が一対多で結果が一意でなくとも，元~dataを常に一意に復元-可能ならば、
きちんと定義されたと見なされるかもしれない。
逆に、
対応関係が一対一であっても，全体として元~dataを一意に復元できない事例はあり得るので，その種のものは きちんと定義されたとは見なされないかもしれない（`~repertoire$の拡張が許容されている場合は、
拡張されても きちんと定義され続ける必要がある）。
】</p>

<p>
`文字~符号化~scheme$と, それに伴って利用される`有符号~文字~集合$の組は，
`文字~符号化法@
（ `character encoding^en ）と呼ばれ、
<abbr title="Internet Assigned Numbers Authority">~IANA</abbr>
~charset識別子などの，一意な識別子により識別される。
~textを表現する~byte列と~charset識別子により識別される文字~符号化法が与えられれば、
原理的には，~textを成す文字~並びを一義的に復元できるようになる。
◎
A character encoding scheme, together with the coded character sets it is used with, is called a character encoding, and is identified by a unique identifier, such as an IANA charset identifier. Given a sequence of bytes representing text and a character encoding identified by a charset identifier, one can in principle unambiguously recover the sequence of characters of the text.
</p>

<p class="trans-note">【
すなわち， CCS, CEF, CES をひっくるめた概念と捉えればよいであろう
（文脈によっては，これらのうち一つを指すこともある）。
対訳としての “~~符号化法” には， “エンコーディング” が広く用いられているが、
“~~符号化~形0” など この語を一部に含む対訳と揃えるため，この訳ではこの対訳を用いる。
`有符号~文字~集合$, `文字~符号化~形0$どちらも一つに固定された文脈~下では
（現今の~Web~platformは、
すべて，~Unicode, `UTF-16$ec （ 16-bit `符号単位$）に基づくよう統一されている）、
`文字~符号化~scheme$を指すことが多い。
】</p>

	</li>
</ol>
<hr>

<p class="note">注記：
用語`~charset$, および文字~符号化法についての更なる詳細~についての論は、
`§ 文字~符号化法の識別$を見よ。
◎
NOTE: See 4.4.2 Character encoding identification for a discussion of the term 'charset' and further details on character encodings.
</p>

<p class="note">注記：
用語 文字~符号化法（ `character encoding^en ）は、
文字を符号化する実際の処理を述べることもあれば，その処理を遂行するための特定0の仕方を指すときにも利用されることもあり，いくぶん多義的である（例えば “この~fileは X encoding である”
【“この~fileは， X という名で識別される符号化法に定義される符号化-法により符号化した結果を内容とする”】）。
その多義性を自覚しておけば、
これらの利用は，通常は文脈から区別できる。
◎
NOTE: The term 'character encoding' is somewhat ambiguous, as it is sometimes used to describe the actual process of encoding characters and sometimes to denote a particular way to perform that process (as in "this file is in the X character encoding"). Context normally allows the distinction of those uses, once one is aware of the ambiguity.
</p>

<p class="note">注記：
所与の［
文字~並び, `文字~符号化法$
］から，常に同じ並びの~byteが生産されるとは限らない。
特に， ISO 2022 に基づく符号化法では、
符号化~処理-の過程でいくつかの選択肢が可用になり得る。
◎
NOTE: Given a sequence of characters, a given 'character encoding' may not always produce the same sequence of bytes. In particular for encodings based on ISO 2022, there may be choices available during the encoding process.
</p>

<p>
ごく単純な事例では、
符号化~処理- 全体を文字から`~byte$への自明な一対一な対応関係として，一段で済ませられる。
一例として、
`US-ASCII$ec `ISO/IEC-646$r や `iso-8859-1^ec が該当する。
◎
In very simple cases, the whole encoding process can be collapsed to a single step, a trivial one-to-one mapping from characters to bytes; this is the case, for instance, for US-ASCII [ISO/IEC 646] and ISO-8859-1.
</p>

<p>
［
`UTF-8$ec ／ `UTF-16$ec ／ `UTF-32$ec
］に符号化された~textは
`~Unicode符号化~形0@
（ `Unicode encoding form$UT ）と呼ばれる。
◎
Text is said to be in a Unicode encoding form if it is encoded in UTF-8, UTF-16 or UTF-32.
</p>

		</section>
		<section id="sec-Transcoding">
<h3 title="Transcoding">4.2. 符号変換</h3>

<p>
ある文字~符号化法（`文字~符号化~scheme$）で符号化された~textを別の文字~符号化法へ変換する処理は
`符号変換@
（ `transcoding$UT ）と呼ばれる。
符号変換器は、
~textを構文解析することなく，文字~符号化法の~levelでのみ働く。
したがって、
数的な文字~参照などの`文字~escape$に対処することも，埋込まれた文字~符号化法の情報（一例として、
`~XML宣言$や`~HTML$の `meta^e 要素による情報）を調整することもない。
◎
Transcoding is the process of converting text from one character encoding to another. Transcoders work only at the level of character encoding and do not parse the text; consequently, they do not deal with character escapes such as numeric character references (see 4.6 Character Escaping) and do not adjust embedded character encoding information (for instance in an XML declaration or in an HTML meta element).
</p>

<p class="note">注記：
`符号変換$は、［
一対一, 多対一, 一対多, 多対多
］いずれの対応関係も孕み得る。
加えて，文字の格納~順序も符号化法の間で変わり得る。
`~Unicode符号化~形0$のような一部のものは，`論理-順序$と規定しているが、
`視覚-順序$を利用するものもある。
符号化法には、
`発音区別符$を`基底~文字$の前に置くよう規定しているものもあれば，後に置くよう規定しているものもある。
これらの文字の並べ方の相違があるため、
`符号変換$は， XYZ から ZYX へのような並替ngも孕む：
◎
NOTE: Transcoding may involve one-to-one, many-to-one, one-to-many or many-to-many mappings. In addition, the storage order of characters varies between encodings: some, such as the Unicode encoding forms, prescribe logical ordering, while others use visual ordering; among encodings that have separate diacritics, some prescribe that they be placed before the base character, some after. Because of these differences in sequencing characters, transcoding may involve reordering: thus XYZ may map to yxz.
</p>

<div class="example">

<p>
最初の例は “~Russian” を意味する~Russianの単語
“`Русский^s”
を~Unicodeの `UTF-16$ec 符号化法から `ISO 8859-5^ec 符号化法へ`符号変換-$した場合を示している：
◎
EXAMPLE: This first example shows the transcoding of the Russian word 'Русский' meaning 'Russian' (language), from the UTF-16 encoding of Unicode to the ISO 8859-5 encoding:
</p>

<table>
<caption>
`ISO 8859-5^ec から `UTF-16$ec への対応関係
◎
table displaying the mapping from ISO 8859-5 to UTF-16
</caption>
<thead>
<tr><th colspan="2">`UTF-16$ec
<th colspan="2">`ISO 8859-5^ec

<tr><th>符号単位
<th>（短縮）`文字~名$
<th>符号単位
<th>（短縮）`文字~名$
<tbody>

<tr><td>0420
<td>`CAPITAL ER^cn
<td>C0
<td>`CAPITAL ER^cn

<tr><td>0443
<td>`SMALL U^cn
<td>E3
<td>`SMALL U^cn

<tr><td>0441
<td>`SMALL ES^cn
<td>E1
<td>`SMALL ES^cn

<tr><td>0441
<td>`SMALL ES^cn
<td>E1
<td>`SMALL ES^cn

<tr><td>043A
<td>`SMALL KA^cn
<td>DA
<td>`SMALL KA^cn

<tr><td>0438
<td>`SMALL I^cn
<td>D8
<td>`SMALL I^cn

<tr><td>0439
<td>`SMALL SHORT I^cn
<td>D9
<td>`SMALL SHORT I^cn
</table>

</div>

<div class="example"><p>
次の例はずっと複階的で、
“平和” を意味する~Arabicの単語
“`&#x0627;&#x0644;&#x0633;&#x0644;&#x0627;&#x0645;^s”
<!--

السلام

-->
が、
IBM CP864 符号化法により視覚的に順序付けられ, 文脈~付けられた状態から，~Unicodeの `UTF-16$ec 符号化法への`符号変換$を示す：
◎
EXAMPLE: This second example shows a much more complex case, where the Arabic word '&#x0627;&#x0644;&#x0633;&#x0644;&#x0627;&#x0645;', meaning 'peace', is transcoded from the visually-ordered, contextualized encoding IBM CP864 to the UTF-16 encoding of Unicode:
</p>

<table>
<caption>
`UTF-16$ec から `IBM CP864^ec への対応関係
◎
table displaying the mapping from UTF-16 to IBM CP864
</caption>
<thead>
<tr><th colspan="2">`IBM CP864^ec
<th colspan="2">`UTF-16$ec

<tr><th>符号単位
<th>（短縮）`文字~名$
<th>符号単位
<th>（短縮）`文字~名$
<tbody>

<tr><td>EF
<td>`FINAL MEEM^cn
<td>0627
<td>`ALEF^cn

<tr><td>9E
<td>`MEDIAN LAM-ALEF^cn
<td>0644
<td>`LAM^cn

<tr><td>D3
<td>`MEDIAN SEEN^cn
<td>0633
<td>`SEEN^cn

<tr><td>E4
<td>`MEDIAN LAM^cn
<td>0644
<td>`LAM^cn

<tr><td>C7
<td>`INITIAL ALEF^cn
<td>0627
<td>`ALEF^cn

<tr><td>
<td>
<td>0645
<td>`MEEM^cn
</table>

<p>
文字の順序が逆さにされていることに注意。
`CP864^ec の 1 個の `LAM-ALEF^cn が `UTF-16$ec においては
`LAM^cn, `ALEF^cn の並びに変換され, また
~~元の符号化法の，`文脈に応じた異体字$（頭字／中字／尾字（ `initial^en ／ `median^en ／ `final^en ））は、
~~目的の符号化法においては，総称的な文字に変換されている。
◎
Notice that the order of the characters has been reversed, that the single LAM-ALEF in CP864 has been converted to a LAM ALEF sequence in UTF-16, and that the contextual variants (initial, median or final) in the source encoding have been converted to generic characters in the target encoding.
</p>

</div>

		</section>
		<section id="sec-RefProcModel">
<h3 title="Reference Processing Model">4.3. 基準~処理~model</h3>

<p id="def-char-data">
~Internet上の多くの~protocolや形式，特に，最も重要な~Web形式［
`~HTML$, ~CSS, `~XML$
］は、
~textに基づいている。
それらの形式は，~textのみからなるが、
`素な~text$（ `plain text^en, ~markupや~programming言語の文脈~下にない~text）自体が供するものに新たな機能性を加えるため、
関連な仕様により，~textに構造が持ち込まれ, 一定の構成子に意味が与えられる。
`~HTML$と`~XML$は
`~markup言語@
である。
すなわち、
文書は全体が~textのみからなるものと規定されつつ，この~textを
~markupと文字~data
に分離するための規約も伴なわれる。
`XML10$r `§ 2.4＠~TR/REC-xml/#syntax$
からの~~引用：
◎
Many Internet protocols and data formats, most notably the very important Web formats HTML, CSS and XML, are based on text. In those formats, everything is text but the relevant specifications impose a structure on the text, giving meaning to certain constructs so as to obtain functionality in addition to that provided by plain text (text that is not in the context of markup or a programming language). HTML and XML are markup languages, defining documents entirely composed of text but with conventions allowing the separation of this text into markup and character data. Citing from the XML 1.0 specification [XML 1.0], section 2.4:
</p>

<blockquote cite="#xml10">
~textな内容は文字~dataと~markupの混成である…（中略）~markupでないすべての~textは、
文書の文字~dataを成す。
◎
"Text consists of intermingled character data and markup. [...] All text that is not markup constitutes the character data of the document."
</blockquote>

<p>
この節の目的における重要な側面は、
もっぱら`~text$（すなわち，文字~並び）である。
◎
For the purposes of this section, the important aspect is that everything is text, that is, a sequence of characters.
</p>

<p>
`~textな~data~obj@
（ `textual data object^en ）とは、
全体が~textからなる［
~protocol~message／文書
］であるか, その一部を成す~textのうち［
格納や検索取得など，外部とやりとりする目的
］で別々に扱われるものである。
例えば，次が挙げられる
⇒＃
`~XML$の外部~解析対象実体／
~textな~MIME `entity body^en `MIME-entity$r
◎
A textual data object is a whole text protocol message or a whole text document, or a part of it that is treated separately for purposes of external storage and retrieval. Examples include external parsed entities in XML and textual MIME entity bodies [MIME-entity].
</p>

<p class="req">`013-SC@cf
［
~protocol／形式
］の仕様に定義される`~textな~data~obj$は、
`単独の^em`文字~符号化法$に~~統一されなければナラナイ。
◎
C013 [S] [C] Textual data objects defined by protocol or format specifications MUST be in a single character encoding.
</p>

<p>
これは， ISO 2022 などの文字~集合 切替~schemeは利用できないことを含意するわけではないことに注意。
そのような~schemeでは、
1 つの`文字~符号化法$の下で`文字~集合$の切替が遂行される。
◎
Note that this does not imply that character set switching schemes such as ISO 2022 cannot be used, since such schemes perform character set switching within a single character encoding.
</p>

<p>
~Webにおける
`基準~処理~model@
（ `Reference Processing Model^en ）の開発は、
草創期の頃から見られる。
初めて述べられたのは，`~HTML$を対象にした `RFC2070$r である。
この~modelは後に，`~XML$と~CSSに取り込まれた。
上で述べたように，それは~textに基づく どの［
形式／~protocol
］にも適用-可能になる。
基準~処理~modelの本質は、
~Unicodeを共通な基準に利用する所にある。
しかしながら，仕様における基準~処理~modelの利用は、
その実装に実際に~Unicodeを利用することを要求するものではない
— 実装に課される要件は、
その処理が この~modelが述べるように挙動することに限られる。
また，この文書は、
用語 `基準~処理~model$を利用して，その特質を処理の用語で述べるが、
明示的に処理~modelを定義しない仕様にも，この~modelは適用される。
◎
Since its early days, the Web has seen the development of a Reference Processing Model, first described for HTML in RFC 2070 [RFC 2070]. This model was later embraced by XML and CSS. It is applicable to any data format or protocol that is text-based as described above. The essence of the Reference Processing Model is the use of Unicode as a common reference. Use of the Reference Processing Model by a specification does not, however, require that implementations actually use Unicode. The requirement is only that the implementations behave as if the processing took place as described by the Model. Also, while this document uses the term Reference Processing Model and describes its properties in terms of processing, the model also applies to specifications that do not explicitly define a processing model.
</p>

<div class="req">`014-S@cf

<p>
~text処理を孕むすべての仕様は、
その処理を次に示す`基準~処理~model$に則って指定しなければナラナイ：
◎
C014 [S]All specifications that involve processing of text MUST specify the processing of text according to the Reference Processing Model, namely:
</p>

<ol>
	<li>
`~byte$や`~glyph$ではなく，~Unicode文字の用語で~textを定義しなければナラナイ。
◎
Specifications MUST define text in terms of Unicode characters, not bytes or glyphs.
</li>
	<li>
当の仕様の`~textな~data~obj$に利用する`文字~符号化法$は、
`~Unicode符号化~形0$に`符号変換-$できるならば，どれを許容してもヨイ。
◎
For their textual data objects specifications MAY allow use of any character encoding which can be transcoded to a Unicode encoding form.
</li>
	<li>
<p>
一部の`文字~符号化法$を許容しないか非推奨にして，他のものを義務付けてもヨイ。
その挙動は、
当の仕様を実装する応用が
— 実際に用いる文字~符号化法に依存することなく —
次に与える処理を`行ったのと同じになる^emように，指定しなければナラナイ：
◎
Specifications MAY choose to disallow or deprecate some character encodings and to make others mandatory. Independent of the actual character encoding, the specified behavior MUST be the same as if the processing happened as follows:
</p>
		<ul>
			<li>
応用は、
受信した`~textな~data~obj$の【！character encoding】`文字~符号化~形0$を決定した上で，~Unicode文字~並びとして解釈するモノトスル。
これは、
その~data~objを何らかの`~Unicode符号化~形0$に`符号変換-$して
— 必要yなら文字~符号化法~labelも調整して —
その`~Unicode符号化~形0$で受信することに等価になるモノトスル。
◎
The character encoding of any textual data object received by the application implementing the specification MUST be determined and the data object MUST be interpreted as a sequence of Unicode characters - this MUST be equivalent to transcoding the data object to some Unicode encoding form, adjusting any character encoding label if necessary, and receiving it in that Unicode encoding form.
</li>
			<li>
すべての処理は、
この~Unicode文字~並びの下で行うモノトスル。
◎
All processing MUST take place on this sequence of Unicode characters.
</li>
			<li>
応用が~textを出力する場合、
それを成す~Unicode文字~並びは，［
当の仕様にて許容されている，いずれかの`文字~符号化法$
］を利用して符号化するモノトスル。
◎
If text is output by the application, the sequence of Unicode characters MUST be encoded using a character encoding chosen among those allowed by the specification.
</li>
		</ul>
	</li>
	<li>
当の仕様が複数の`~textな~data~obj$を孕んでいる場合（外部~解析対象実体を参照rしている~XML文書など）、
これらの各~data~objごとに異なる`文字~符号化法$を選んでもヨイ。
いずれにせよ、
どの`~textな~data~obj$にも，`基準~処理~model$を適用しなければナラナイ。
◎
If a specification is such that multiple textual data objects are involved (such as an XML document referring to external parsed entities), it MAY choose to allow these data objects to be in different character encodings. In all cases, the Reference Processing Model MUST be applied to all textual data objects.
</li>
</ol>

</div>

<p class="note">注記：
`XML10$r の応用を定義するすべての仕様は、
自動的に，この基準~処理~modelを継承する。
`~XML$では、
仕様~全体が~Unicode文字の用語で定義されており，解析対象実体には他の`文字~符号化法$も許容される一方で，【処理~modelにおいては】［
`UTF-8$ec ／ `UTF-16$ec
］文字~符号化法の利用が要求されている。
◎
NOTE: All specifications which define applications of the XML 1.0 specification [XML 1.0] automatically inherit this Reference Processing Model. XML is entirely defined in terms of Unicode characters and requires the UTF-8 and UTF-16 character encodings while allowing any other character encoding for parsed entities.
</p>

<p class="note">注記：
仕様において`~Unicode符号化~形0$でない`文字~符号化法$が許容される場合、
実装者は，そのような符号化法の文字と~Unicode文字との対応関係が［
実施においては、
`符号変換$に利用される~softwareに依存する
］ことを自覚するべきである。
そのような不一致については、
例えば `XML-Japanese-Profile$r を見よ。
◎
NOTE: When specifications choose to allow character encodings other than Unicode encoding forms, implementers should be aware that the correspondence between the characters of such encodings and Unicode characters may in practice depend on the software used for transcoding. See the Japanese XML Profile [XML Japanese Profile] for examples of such inconsistencies.
</p>

<p class="req">`070-S@cf
仕様は、
全-範囲（すなわち， `0000^U 〜 `10FFFF^U ）の `いかなる^em~Unicode`符号位置$も，除外するベキでない
◎
C070 [S] Specifications SHOULD NOT arbitrarily exclude code points from the full range of Unicode code points from U+0000 to U+10FFFF inclusive.
</p>

<p class="req">`077-S@cf
仕様は、
`10FFFF^U を越える符号位置を許容してはナラナイ。
◎
C077 [S] Specifications MUST NOT allow code points above U+10FFFF.
</p>

<p>
~Unicodeには、［
内部~利用~用（`非文字$など）／特殊な機能~用（`~surrogate符号位置$など）
］の符号位置も含まれている。
◎
Unicode contains some code points for internal use (such as noncharacters) or special functions (such as surrogate code points).
</p>

<p class="req">`079-S@cf
仕様は、
~Unicodeにより内部~利用~用に予約されている符号位置の利用を許容するベキでない。
◎
C079 [S]Specifications SHOULD NOT allow the use of codepoints reserved by Unicode for internal use.
</p>

<p class="req">`078-S@cf
仕様は、
`~surrogate符号位置$の利用を許容してはナラナイ。
◎
C078 [S] Specifications MUST NOT allow the use of surrogate code points.
</p>

<p>
~~相当な理由も無く，一部の符号位置を除外することは、
~W3Cの普遍的な~accessibilityの目標と競合する。
符号位置を除外すると、［
利用者その他の~communityにとって重要になり得る，一部の`用字系$
］を利用できなくする。
例えば、
強い理由も無く［
`基本多言語面$より先の符号位置を除外するものと裁定すること／
符号位置を［
US-ASCII ／ Latin-1
］`~repertoire$に制限すること
］は適切でない。
また，`~Unicode標準$では、
~softwareは［
どの符号位置に対しても破損しない
］ことが要求されていることにも注意。
◎
Excluding code points without good reason conflicts with the W3C goal of universal accessibility. Excluding code points would prevent some scripts from being used which may be important to a user community or communities. For example, without strong reasons to do so, decisions to exclude code points above the Basic Multilingual Plane or to limit code points to the US-ASCII or Latin-1 repertoire are inappropriate. Also, please note that the Unicode Standard requires software to not corrupt any code points.
</p>

<p>
文字を除外する理由として，合法的かつ恣意的でない例としては、
`UXML$r （`~XML$その他の`~markup言語$における~Unicode）が挙げられる。
そこでは、
次のような理由で，一部の文字を利用しないことが奨励されている
⇒＃
`~Unicode標準$により非推奨にされた。
追加的な~dataなしに~supportし得ない。
`~markup$の方がより良く取扱える。
等価な`~markup$と競合する。
◎
Other examples of legitimate and non-arbitrary reasons to exclude characters can be seen in Unicode in XML and other Markup Languages [UXML], where the use of certain characters is discouraged for reasons such as:
• They are deprecated in the Unicode Standard.
• They cannot be supported without additional data.
• They are better handled by markup.
• They conflict with equivalent markup.
</p>

		</section>
		<section id="sec-Encodings">
<h3 title="Choice and Identification of Character Encodings">4.4. 文字~符号化法の選定と識別</h3>

<p>
符号化された~textは，その符号化法を知ることなしに解釈や処理を`行えない^emので、
`文字~符号化法$は、
~textが［
交換される／格納される／処理される
］ような既知なあらゆる所で，決定的に重要になる。
以下では、
利用する`文字~符号化法$は，文脈に依存して［
`文字~符号化~形0$（ CEF ）, `文字~符号化~scheme$（ CES ）
］のいずれかを意味する。
~textが~byte~streamとして［
伝送される／格納される
］ときは（一例として、~protocolや~file~systemの中で）、
適正に解釈されることを確保するため， CES の指定が要求される。
~APIなどの文脈においては、
複数~byteの~byte順は，環境（概して，~processor~architecture）から指定されるので， CEF の指定で足る。
◎
Because encoded text cannot be interpreted and processed without knowing the encoding, it is vitally important that the character encoding (see 4.1 Character Encoding) is known at all times and places where text is exchanged, stored or processed. In what follows we use 'character encoding' to mean either character encoding form (CEF) or character encoding scheme (CES) depending on the context. When text is transmitted or stored as a byte stream, for instance in a protocol or file system, specification of a CES is required to ensure proper interpretation. In contexts such as an API, where the environment (typically the processor architecture) specifies the byte order of multibyte quantities, specification of a CEF suffices.
</p>

<p class="req">`015-S@cf
仕様は、［
一意な`文字~符号化法$
］を指定するか, または［
~textの`文字~符号化法$を依拠-可能に識別するための仕組み
］を供さなければナラナイ。
◎
C015 [S] Specifications MUST either specify a unique character encoding, or provide character encoding identification mechanisms such that the encoding of text can be reliably identified.
</p>

<p class="req">`016-S@cf
新たな［
~protocol／形式／~API／仕様
］を設計する際には、
一意な`文字~符号化法$を要求するベキである。
◎
C016 [S] When designing a new protocol, format or API, specifications SHOULD require a unique character encoding.
</p>

<p class="req">`017-S@cf
`文字~符号化法$用の規則をすでに備えている［
~protocol／形式／~API
］に基づく仕様, そのような［
~protocol／形式
］に基づく~APIの仕様は、
それらの規則を変更せずに，そのまま利用するベキである。
◎
C017 [S] When basing a protocol, format, or API on a protocol, format, or API that already has rules for character encoding, specifications SHOULD use rather than change these rules.
</p>

<p class="example">
`~XML$に基づく形式~用に外部~実体の`文字~符号化法$を［
選ぶ／決定する
］際には、
新たなものを考案せずに，既存の`~XML$規則を利用するべきである。
◎
EXAMPLE: An XML-based format should use the existing XML rules for choosing and determining the character encoding of external entities, rather than invent new ones.
</p>

			</section>
			<section id="sec-UniqueEncoding">
<h4 title="Mandating a unique character encoding">4.4.1. 一意な文字~符号化法の義務化</h4>

<p>
一意な`文字~符号化法$の義務化は［
単純かつ効率的かつ堅牢
］になる。
符号化法~tagを［
指定-／生産-／伝送-／解釈-
］する必要もなくなり、
受信-側からは，文字~符号化法が常に解されることになる。
~dataが非電子的に転送された後で，~~元の~digital表現に~~復号する必要が生じた場合でも、
利用された文字~符号化法の多義性は生じない。
既存の［
~data／~system／~protocol／応用
］との互換性を得るために 複数の`文字~符号化法$が必要になる場合でも、
それらは，［
~protocol／形式／~API
］の境界や外側で対処されることが多い。
`DOM1$r は、
これが行われている一例になる。
一意な`文字~符号化法$を選ぶ方が、［
~text~sizeが小さいとき／仕様が実際の処理に近いとき
］には，有利になる。
◎
Mandating a unique character encoding is simple, efficient, and robust. There is no need for specifying, producing, transmitting, and interpreting encoding tags. At the receiver, the character encoding will always be understood. There is also no ambiguity as to which character encoding to use if data is transferred non-electronically and later has to be converted back to a digital representation. Even when there is a need for compatibility with existing data, systems, protocols and applications, multiple character encodings can often be dealt with at the boundaries or outside a protocol, format, or API. The DOM [DOM Level 1] is an example of where this was done. The advantages of choosing a unique character encoding are greater when text sizes are small or the specification is close to the actual processing.
</p>

<p class="req">`018-S@cf
一意な`文字~符号化法$が要求される場合、
その文字~符号化法は［
`UTF-8$ec, `UTF-16$ec, `UTF-32$ec
］のうちいずれかでなければナラナイ。
◎
C018 [S] When a unique character encoding is required, the character encoding MUST be UTF-8, UTF-16 or UTF-32.
</p>

<p>
`UTF-8$ec は `US-ASCII$ec の上位互換なので（ `US-ASCII$ec 文字列は `UTF-8$ec 文字列でもある
— `RFC3629$r を見よ）、
`US-ASCII$ec との互換性が欲される場合には `UTF-8$ec が適切になる。
他の状況
— 例えば ~APIなど —
では、［
`UTF-16$ec ／ `UTF-32$ec
］の方が適切になり得る。
これらを選ぶ理由には、
内部~処理の効率や, 他の処理との相互運用能などが挙げられる。
◎
US-ASCII is upwards-compatible with UTF-8 (an US-ASCII string is also a UTF-8 string, see [RFC 3629]), and UTF-8 is therefore appropriate if compatibility with US-ASCII is desired. In other situations, such as for APIs, UTF-16 or UTF-32 may be more appropriate. Possible reasons for choosing one of these include efficiency of internal processing and interoperability with other processes.
</p>

<p class="note">注記：
`RFC2277$r には、
<q cite="#rfc2277">~protocolは `UTF-8$ec `~charset$を利用できなければナラナイ</q>
と指定されている。
◎
NOTE: The IETF Charset Policy [RFC 2277] specifies that on the Internet "Protocols MUST be able to use the UTF-8 charset".
</p>

<p class="note">注記：
`XML10$r では、
すべての適合~XML処理器に対し，［
`UTF-16$ec, `UTF-8$ec
］とも受容することを要求している。
◎
NOTE: The XML 1.0 specification [XML 1.0] requires all conforming XML processors to accept both UTF-16 and UTF-8.
</p>

			</section>
			<section id="sec-EncodingIdent">
<h4 title="Character encoding identification">4.4.2. 文字~符号化法の識別</h4>

<p>
~MIME~Internet仕様は、
`文字~符号化法$を識別するための仕組み
`MIME-charset$r `RFC2978$r
の好例である。
~MIME `charset^c ~parameterは、［
受信した~dataの~byte列を文字~並びに一意に復号するに足る情報
］を供するものとして，定義されている。
その値は~IANA~charset~registry `IANA$r から抜き出されている。
◎
The MIME Internet specification provides a good example of a mechanism for character encoding identification [MIME-charset][RFC 2978]. The MIME charset parameter definition is intended to supply sufficient information to uniquely decode the sequence of bytes of the received data into a sequence of characters. The values are drawn from the IANA charset registry [IANA].
</p>

<p class="note">注記：
あいにく，一部の~charset識別子は、
単独の一意な文字~符号化法を表現しておらず，小さな多様性を示す。
小さくても，その相違は重大になり得るし, 時を経れば変わり得る。
これらの識別子の下では、
~byte並びから文字~並びへ復元する際に多義的になる。
例えば `Shift_JIS^ec では， 0x5C に符号化された文字は多義的になる。
この符号位置は `YEN SIGN^cn を表現することもあれば， `REVERSE SOLIDUS^cn を表現することもある。
この例についての詳細および，他の そのような多義的な~charset識別子については `XML-Japanese-Profile$r を見よ。
◎
NOTE: Unfortunately, some charset identifiers do not represent a single, unique character encoding. Instead, these identifiers denote a number of small variations. Even though small, the differences may be crucial and may vary over time. For these identifiers, recovery of the character sequence from a byte sequence is ambiguous. For example, the character encoded as 0x5C in Shift_JIS is ambiguous. This code point sometimes represents a YEN SIGN and sometimes represents a REVERSE SOLIDUS. See the [XML Japanese Profile] for more detail on this example and for additional examples of such ambiguous charset identifiers.
</p>

<p class="note">注記：
用語
`~charset@
は、
`文字~集合$（ `character set^en ）に由来するもので，長い苦しみの歴史による結果を表出する（更なる論は `Connolly$r を見よ）。
◎
NOTE: The term charset derives from 'character set', an expression with a long and tortured history (see [Connolly] for a discussion).
</p>

<p class="req">`020-S@cf
仕様は、
用語［
`文字~集合$／`~charset$
］を利用して`文字~符号化法$を参照rするのを避けるベキである。
ただし、
後者については，
~MIME `charset^c ~parameter, あるいは その~IANAに登録-済みな値を参照rする際に利用される場合は除く。
用語
`文字~符号化法$，または特定の事例には用語［
`文字~符号化~形0$／`文字~符号化~scheme$
］の利用が推奨される。
◎
C020 [S] Specifications SHOULD avoid using the terms 'character set' and 'charset' to refer to a character encoding, except when the latter is used to refer to the MIME charset parameter or its IANA-registered values. The term 'character encoding', or in specific cases the terms 'character encoding form' or 'character encoding scheme', are RECOMMENDED.
</p>

<p class="note">注記：
`~XML$においては、［
`~XML宣言$／`~text宣言$
］に含められた `encoding^c 疑似属性から，~IANA~charsetを利用する文字~符号化法が識別される。
◎
NOTE: In XML, the XML declaration or the text declaration contains the encoding pseudo-attribute which identifies the character encoding using the IANA charset.
</p>

<p>
~IANA~charset~registryは、
~Internet上の文字~符号化~scheme名とそれらの別名が含められている，公式的なリストである。
◎
The IANA charset registry is the official list of names and aliases for character encoding schemes on the Internet.
</p>

<p class="req">`021-S@cf
仕様は、
一意な符号化法を採用しない場合には，
~IANA~charset~registryに含まれる名前の利用を
— 特に，［
~protocol／形式／~API
］の`文字~符号化法$として指名する際には、
その~registryの中の
`~MIMEに選好される名前^q
（ `MIME preferred names^en ）として識別される名前の利用を —
要求するベキである。
◎
C021 [S] If the unique encoding approach is not taken, specifications SHOULD require the use of the IANA charset registry names, and in particular the names identified in the registry as 'MIME preferred names', to designate character encodings in protocols, data formats and APIs.
</p>

<p class="req">`022-SIC@cf
~IANA~registryに含まれていない`文字~符号化法$は、
私的な合意が無い限り，利用されるベキでない。
◎
C022 [S] [I] [C] Character encodings that are not in the IANA registry SHOULD NOT be used, except by private agreement.
</p>

<p class="req">`023-SIC@cf
登録-済みでない`文字~符号化法$を利用する場合、
名前の先頭に `x-^l を付与する慣行に従わなければナラナイ。
◎
C023 [S] [I] [C] If an unregistered character encoding is used, the convention of using 'x-' at the beginning of the name MUST be followed.
</p>

<p class="req">`049-IC@cf
内容の`文字~符号化法$は、
できるだけ直に文字を表現できる（すなわち，`文字~escape$などの`~markup$により文字を表現する必要を最小限にする）, かつ
受信者からは解されそうにない解り難い符号化法は避けるように選ばれるベキである。
◎
C049 [I] [C] The character encoding of content SHOULD be chosen so that it maximizes the opportunity to directly represent characters (ie. minimizes the need to represent characters by markup means such as character escapes) while avoiding obscure encodings that are unlikely to be understood by recipients.
</p>

<p class="note">注記：
~Unicodeに基づく`文字~符号化法$は、
巨大な`~repertoire$を備え, 広範からの~supportもあるので，文書の符号化として良い選択肢である。
◎
NOTE: Due to Unicode's large repertoire and wide base of support, a character encoding based on Unicode is a good choice to encode a document.
</p>

<p class="req">`034-C@cf
`文字~符号化法$を識別するための便宜性が提供されている場合、
内容は，それを用立てなければナラナイ。
“提供されている” には、
既定として定められたもの（例： `XML10$r によるもの）も含まれる。
そのような既定に依拠することでも、
この識別~用の要件を満たすに足る。
◎
C034 [C] If facilities are offered for identifying character encoding, content MUST make use of them; where the facilities offered for character encoding identification include defaults (e.g. in XML 1.0 [XML 1.0]), relying on such defaults is sufficient to satisfy this identification requirement.
</p>

<p class="req">`024-IC@cf
［
内容／~software
］は、
~text~dataに~labelを付与するときは，［
適切な仕様（例：~XML~textを編集する場合は~XML仕様）にて要求されている，いずれかの名前
］を利用しなければナラナイ。
また、［
その~dataの`文字~符号化法$に結び付けられている，~MIMEに選好される名前
］を利用するベキである。
◎
C024 [I] [C] Content and software that label text data MUST use one of the names required by the appropriate specification (e.g. the XML specification when editing XML text) and SHOULD use the MIME preferred name of a character encoding to label data in that character encoding.
</p>

<p class="req">`025-IC@cf
~IANAに登録されたどの名前にも対応しない`文字~符号化法$を伴う~text~dataには、
その~labelとして~IANAに登録-済みな~charset名を利用してはナラナイ。
◎
C025 [I] [C] An IANA-registered charset name MUST NOT be used to label text data in a character encoding other than the one identified in the IANA registration of that name.
</p>

<p class="req">`026-S@cf
一意な符号化法を採用しない仕様は、
少なくとも~Unicodeの［
`UTF-8$ec, `UTF-16$ec
］`符号化~形0$いずれかを，適格な`文字~符号化法$として指名しなければナラナイ。
また、［
`UTF-8$ec, `UTF-16$ec
］いずれかを，要求される`符号化~形0$（仕様の実装が~supportするモノトスル`符号化~形0$）として採用するベキである。
◎
C026 [S] If the unique encoding approach is not chosen, specifications MUST designate at least one of the UTF-8 and UTF-16 encoding forms of Unicode as admissible character encodings and SHOULD choose at least one of UTF-8 or UTF-16 as required encoding forms (encoding forms that MUST be supported by implementations of the specification).
</p>

<p class="req">`027-S@cf
既定の符号化法を要求する仕様は、［
`UTF-8$ec, `UTF-16$ec
］のうち一方を, あるいは それらの判別-用に相応しい手段を定義する場合は両者を，既定のそれとして定義しなければナラナイ。
◎
C027 [S] Specifications that require a default encoding MUST define either UTF-8 or UTF-16 as the default, or both if they define suitable means of distinguishing them.
</p>

<p class="req">`028-S@cf
仕様は、
~dataの符号化法を決定する方法に経験則の利用を提案してはナラナイ。
◎
C028 [S] Specifications MUST NOT propose the use of heuristics to determine the encoding of data.
</p>

<p>
経験則の例としては、
~byte（~pattern）や文字（~pattern）の頻度に対する統計的解析の利用が挙げられる。
経験則は，実装~間でふるまいが一貫しないので良くない。
`XML10$r, `付録 F＠~TR/REC-xml/#sec-guessing$
にて与えられるものなど、
きちんと定義された指示書きにより，`文字~符号化法$を一義的に決定する方法は、
経験則とは見なされない。
【~~参考：~HTMLにおける`符号化法の決定-法＠~HTMLparsing#determining-the-character-encoding$】
◎
Examples of heuristics include the use of statistical analysis of byte (pattern) frequencies or character (pattern) frequencies. Heuristics are bad because they will not work consistently across different implementations. Well-defined instructions of how to unambiguously determine a character encoding, such as those given in XML 1.0 [XML 1.0], Appendix F, are not considered heuristics.
</p>

<p class="req">`029-I@cf
`受信-側^emの~softwareは、
~dataの符号化法を，可用な情報から適切な仕様に則って決定するモノトスル。
◎
C029 [I] Receiving software MUST determine the encoding of data from available information according to appropriate specifications.
</p>

<p class="req">`030-I@cf
~IANAに登録-済みな~charset名を認識したときは、
受信-側~softwareは、
受信した~dataを~IANA~registryの中の その名前に結付けられた符号化法に則って，解釈するモノトスル。
◎
C030 [I] When an IANA-registered charset name is recognized, receiving software MUST interpret the received data according to the encoding associated with the name in the IANA registry.
</p>

<p class="req">`031-I@cf
~charsetが供されていないときは、
受信-側の~softwareは、
仕様に指定されている既定の`文字~符号化法$を固守するモノトスル。
◎
C031 [I] When no charset is provided receiving software MUST adhere to the default character encoding(s) specified in the specification.
</p>

<p>
受信-側の~softwareは、
必要に応じて，いくつでも［
`文字~符号化法$, および~charset名とその別名
］を認識してよい。
◎
Receiving software may recognize as many character encodings and as many charset names and aliases for them as appropriate.
</p>

<p>
`field-upgradeable^en 【？】の仕組みは、
この目的に適切なものになる。
一部の`文字~符号化法$は、
多少なりとも一定の言語に結付けられる
（例： `Shift_JIS^ec と~Japanese）。
所与の言語や一定層の顧客の~supportは、
一定の`文字~符号化法$の~supportの必要を意味することもある。
しかしながら，支持は得ていても要求されてはいない符号化法には、
普遍的な~supportがあるとは見做せない。
~supportが必要な`文字~符号化法$は，時を経れば変わり得る。
この文書は、［
所与の言語の~supportに，どの文字~符号化法が 適切あるいは必要yであるか
］については，助言を供さない。
◎
A field-upgradeable mechanism may be appropriate for this purpose. Certain character encodings are more or less associated with certain languages (e.g. Shift_JIS with Japanese). Trying to support a given language or set of customers may mean that certain character encodings have to be supported. However, one cannot assume universal support for a favoured but non-required encoding. The character encodings that need to be supported may change over time. This document does not give any advice on which character encoding may be appropriate or necessary for the support of any given language.
</p>

<p>
~Web~architectureは層の積み重ねであるので（例：~protocol越しに利用される形式）、
`文字~符号化法$についての情報が複数あったり競合することが起こり得る。
◎
Because of the layered Web architecture (e.g. formats used over protocols), there may be multiple and at times conflicting information about character encoding.
</p>

<p class="req">`035-S@cf
仕様は、
`文字~符号化法$についての情報が複数あるか競合する場合には，それを解決する仕組み（例：優先順位）を定義しなければナラナイ。
◎
C035 [S] Specifications MUST define conflict-resolution mechanisms (e.g. priorities) for cases where there is multiple or conflicting information about character encoding.
</p>

<p class="req">`033-I@cf
~softwareは、
`文字~符号化法$の識別と競合の解決~用の仕組みを，完全に実装するモノトスル。
◎
C033 [I] Software MUST completely implement the mechanisms for character encoding identification and conflict resolution.
</p>

			</section>
		</section>
		<section id="sec-PrivateUse">
<h3 title="Private use code points">4.5. 私用~符号位置</h3>

<p>
~Unicodeの中の一定範囲の`符号位置$
— `私用領域$（ `Private Use Area^en, 略称 `PUA^abbr, 範囲 `E000-F8FF^U ）,
第 15 面（ `F0000-FFFFD^U ）,
第 16 面（ `100000-10FFFD^U ） —
は、
`私用$用途として指名されている。
これらの符号位置は，標準な文字には決して割振られないことが保証されており、
私的~合意の下での利用~用に可用にされている。
しかしながら，私的~合意は、
異なるそれらの間で符号位置が衝突し得るので，~Web上まで拡大されることはない。
また、
私的~合意であるがため，その符号位置の意味は急速に失われ易い。
◎
Certain ranges of Unicode code points are designated for private use: the Private Use Area (PUA) (U+E000-F8FF) and planes 15 and 16 (U+F0000-FFFFD and U+100000-10FFFD). These code points are guaranteed to never be allocated to standard characters, and are available for use by private agreement. However, private agreements do not scale on the Web. Code points from different private agreements may collide. Also, a private agreement, and therefore the meaning of the code points, can quickly become lost.
</p>

<p class="req">`073-C@cf
公に交換iされる内容は、
`私用領域$の符号位置を利用するベキでない。
◎
C073 [C] Publicly interchanged content SHOULD NOT use codepoints in the private use area.
</p>

<p class="note">注記：
`私用領域$の例外的な利用として代表的なものには、
符号化されたことのない`用字系$（例：歴史上の, あるいは稀なもの）に対する符号化法の設計や~testが挙げられる。
◎
NOTE: A typical exception would be the use of the PUA to design and test the encoding of not yet encoded (e.g. historic or rare) scripts.
</p>

<p class="req">`076-C@cf
内容は、
符号位置を，その`有符号~文字~集合$に定義されている目的~以外に利用してはナラナイ。
◎
C076 [C]Content MUST NOT use a code point for any purpose other than that defined by its coded character set.
</p>

<p>
したがって、
例えば，［
`iso-8859-1^ec に符号化されるものとは実際には異なる［
`用字系$／文字／記号
］を表現するために， ISO Latin 1 文字~集合の符号位置を誤用する
］ような`~font$の構築は、
禁制される。
◎
This prohibits, for example, the construction of fonts that misuse the codepoints in the ISO Latin 1 character set to represent different scripts, characters, or symbols than those actually encoded in iso-8859-1.
</p>

<p class="req">`038-S@cf
仕様は、［
`私用領域$の文字に，特定0の何かをアテガうような利用
］を要求してはナラナイ。
◎
C038 [S] Specifications MUST NOT require the use of private use area characters with particular assignments.
</p>

<p class="req">`039-S@cf
仕様は、［
`私用~符号位置$についての合意を定義する仕組みの利用
］を要求してはナラナイ。
◎
C039 [S] Specifications MUST NOT require the use of mechanisms for defining agreements of private use code points.
</p>

<p class="req">`040-SI@cf
［
仕様／実装
］は、［
私的~合意による`私用~符号位置$の利用
］を許容するベキである。
◎
C040 [S] [I] Specifications and implementations SHOULD NOT disallow the use of private use code points by private agreement.
</p>

<p>
例えば`~XML$は、
`私用~符号位置$の利用を許容している。
◎
As an example, XML does not disallow the use of private use code points.
</p>

<p class="req">`041-S@cf
仕様は、［
~Unicodeに無い記号の伝送／~Unicode文字の特定の`異体字$の識別
］を許容するための`~markup$を定義してもヨイ。
◎
C041 [S] Specifications MAY define markup to allow the transmission of symbols not in Unicode or to identify specific variants of Unicode characters.
</p>

<p class="example">
MathML は、
~Unicodeには無い数学-記号~用に `mglyph^e 要素を定義している
（ `MathML2$r `§ 3.2.9＠~TR/2003/REC-MathML2-20031021/chapter3.html#presm.mglyph$
を見よ）。
◎
EXAMPLE: MathML (see [MathML2] section 3.2.9) defines an element mglyph for mathematical symbols not in Unicode.
</p>

<p class="example">
~SVGは、
`altglyph^e 要素を定義して，~Unicode文字の特定の表示異体の識別を許容している
（ `SVG$r `§ 10.14＠~SVG11/text.html#AlternateGlyphs$
を見よ）。
◎
EXAMPLE: SVG (see [SVG] section 10.14) defines an element altglyph which allows the identification of specific display variants of Unicode characters.
</p>

<p class="req">`068-S@cf
仕様は、
絵図や~graphic用に文字に基づく仕組みを利用-（または誤利用）する必要を無くすため、
適切な所では，絵図や~graphicの内包や参照を許容するベキである。
◎
C068 [S]Specifications SHOULD allow the inclusion of or reference to pictures and graphics where appropriate, to eliminate the need to (mis)use character-oriented mechanisms for pictures or graphics.
</p>

		</section>
		<section id="sec-Escaping">
<h3 title="Character Escaping">4.6. 文字~escape法</h3>

<p>
`~markup言語$や~programming言語では、
ある種の文字が
`構文文字@
（ `syntax-significant character^en, 略して `syntax-significant^en ）として指名され，言語の中で特定の機能が与えられることが多い（例： `~HTML$, `~XML$では `&lt;^ch と `&amp;^ch が~markup区切子になる）。
そのため、
これらの構文文字には
— ~textの中では、
他の文字と同じように自身を自身の表現に利用できないので —
“~escapeする” 仕組みが必要になる。
また，これと同じか類似な仕組みで満たされることが多いが、［
特定0の［
文書（`~markup$の~instance）／~program（~programming言語の~instance）
］用に選ばれた`文字~符号化法$の中では，直に表現できない文字
］も表出できる必要がある。
◎
Markup languages or programming languages often designate certain characters as syntax-significant, giving them specific functions within the language (e.g. '&lt;' and '&amp;' serve as markup delimiters in HTML and XML). As a consequence, these syntax-significant characters cannot be used to represent themselves in text in the same way as all other characters do, creating the need for a mechanism to "escape" their syntax-significance. There is also a need, often satisfied by the same or similar mechanisms, to express characters not directly representable in the character encoding chosen for a particular document or program (an instance of the markup or programming language).
</p>

<p>
正式に述べるなら，
`文字~escape@
とは、［
`~markup$／~programming言語
］により定義される構文-素子であって，次に挙げるいずれかを許容するものである：
◎
Formally, a character escape is a syntactic device defined in a markup or programming language that allows one or more of:
</p>
<ul>
	<li>
言語の構文における有意性を失わせつつ，構文文字を表出する。
◎
expressing syntax-significant characters while disregarding their significance in the syntax of the language, or
</li>
	<li>
当の言語~用に選ばれた`文字~符号化法$では表現できない文字を表出する。
◎
expressing characters not representable in the character encoding chosen for an instance of the language, or
</li>
	<li>
一般の文字を，対応する`符号化された文字$を利用せずに表出する。
◎
expressing characters in general, without use of the corresponding encoded characters.
</li>
</ul>

<hr>

<p>
文字を~escapeするとは、
当の文字が現れる［
形式／~protocol
］に適切な構文-素子を利用して，当の文字を表出することを意味する。
`文字~escapeを展開する^q（あるいは `unescaping^en ）とは、
それが表現する文字に置換することを意味する。
◎
Escaping a character means expressing it using such a syntactic device, appropriate to the format or protocol in which the character appears; expanding a character escape (or unescaping) means replacing it with the character that it represents.
</p>

<p class="example">
［
`~HTML$／`~XML$
］では、［
構文文字, 任意な~Unicode文字
］どちらにも~escape法を許容するためとして，数的な文字~参照（ `Numeric Character References^en ）が定義されている。
文字 `&lt;^ch は、［
`&amp;#x3C;^s ／ `&amp;#60;^s
］として表出されたときは，~markup区切子として構文解析されないようになる。
◎
EXAMPLE: HTML and XML define 'Numeric Character References' which allow both the escaping of syntax-significance and the expression of arbitrary Unicode characters. Expressed as &amp;#x3C; or &amp;#60; the character '&lt;' will not be parsed as a markup delimiter.
</p>

<p class="example">
~programming言語 Java は、
文字列を区切るために二重引用符 `"^ch を利用している。
文字列~内で二重引用符を表出するときは、
`\"^ch のように~escapeできる。
◎
EXAMPLE: The programming language Java uses '"' to delimit strings. To express '"' within a string, one may escape it as '\"'.
</p>

<p class="example">
`~XML$が定義する`~CDATA~section$では、
その区切子で括られたすべての構文文字が~escapeされる。
~CDATA~sectionの中では、
数的な文字~参照を利用して文字を表出することは，できなくなる。
◎
EXAMPLE: XML defines 'CDATA sections' which allow escaping the syntax-significance of all characters between the CDATA section delimiters. CDATA sections prevent the expression of characters using numeric character references.
</p>

<p>
仕様が`文字~escape$を定義する仕方には、
次に挙げる指針が適用される：
◎
The following guidelines apply to the way specifications define character escapes.
</p>

<ul>
	<li>
【！p id="C0000"】
<p class="req">`042-S@cf
仕様は、
適切なものがすでにあるならば，新たな~escape法の仕組みを考案するベキでない。
◎
C042 [S] Specifications SHOULD NOT invent a new escaping mechanism if an appropriate one already exists.
</p>
</li>
	<li>
<p class="req">`043-S@cf
文字を~escapeする仕方は、
最小限にするベキである（理想的には一種類に）。
◎
C043 [S] The number of different ways to escape a character SHOULD be minimized (ideally to one).
</p>

<p>
よく知られた反例として、
`~HTML$も`~XML$も，歴史的な理由から冗長な 2 種類の`文字~escape$
— 10 進（ `&amp;#ddddd;^s ）によるもの, 16 進（ `&amp;#xhhhh;^s ）によるもの —
を備えている。
◎
A well-known counter-example is that for historical reasons, both HTML and XML have redundant decimal (&amp;#ddddd;) and hexadecimal (&amp;#xhhhh;) character escapes.
</p>
	</li>
	<li>
<p class="req">`044-S@cf
~escape構文は、
各 `文字~escape$に対し，明示的な終端~区切子か一定個数の文字を要求するベキである。
`文字~escape$の終端が［
~escapeの中では適格でない文字
］により決定されるような~escape構文は、
避けられるベキである。
◎
C044 [S] Escape syntax SHOULD require either explicit end delimiters or a fixed number of characters in each character escape. Escape syntaxes where the end is determined by any character outside the set of characters admissible in the character escape itself SHOULD be avoided.
</p>

<p>
そのような`文字~escape$は、
視覚的に明瞭でないので，編集~時に［
~spaceで単語が折返される所
］に誤って改行を挿入し易くなる。
`SPREAD$r の `&amp;UABCD;^s 形や`~XML$の `&amp;#xhhhh;^s 形のように，`文字~escape$が明示的に~semicolonで終了される方が、
ずっと良い。
◎
These character escapes are not clear visually, and can cause an editor to insert spurious line-breaks when word-wrapping on spaces. Forms like SPREAD's &amp;UABCD; [SPREAD] or XML's &amp;#xhhhh;, where the character escape is explicitly terminated by a semicolon, are much better.
</p>

	</li>
	<li>

<p class="req">`045-S@cf
仕様は、
`文字~escape$を［
数値を利用して文字を表現することも許容する
］ように定義するときは，その数値は
⇒＃
当の文字の~Unicode符号位置を表現しなければナラナイ。
また、
16 進~記法にされるベキである。
◎
C045 [S] Whenever specifications define character escapes that allow the representation of characters using a number, the number MUST represent the Unicode code point of the character and SHOULD be in hexadecimal notation.
</p>
	</li>
	<li>

<p class="req">`046-S@cf
~escapeされた文字は、
その~escapeされてない形が受容-可能な所なら どこでも受容-可能になるベキである
— これは、
~escapeされた`構文文字$が構文における有意性を失えなくするものではない。
特に，ある文字が識別子や~comment内で受容-可能な場合、
その文字の~escapeされた形も受容-可能になるべきである。
◎
C046 [S] Escaped characters SHOULD be acceptable wherever their unescaped forms are; this does not preclude that syntax-significant characters, when escaped, lose their significance in the syntax. In particular, if a character is acceptable in identifiers and comments, then its escaped form should also be acceptable.
</p>

	</li>
</ul>

<p>
内容~開発者, およびその内容を生成する~softwareには、
次に挙げる指針が適用される：
◎
The following guidelines apply to content developers, as well as to software that generates content:
</p>

<ul>
	<li>
<p class="req">`047-IC@cf
~escapeは、
それが表出する文字が［
文書の［
形式／`文字~符号化法$
］の下では直に表現できないとき ／
その視覚的な表現が不明瞭な所
］に限って，利用するベキである。
◎
C047 [I] [C] Escapes SHOULD only be used when the characters to be expressed are not directly representable in the format or the character encoding of the document, or when the visual representation of the character is unclear.
</p>

<p class="note">注記：
文字の視覚的な表現が不明瞭な例としては、
`00A0^U `NO-BREAK SPACE^cn を通常の~spaceと判別するための，
`&amp;nbsp;^s の利用が挙げられる。
◎
NOTE: An example of when the visual representation of the character is unclear is the use of &amp;nbsp; to distinguish a non-breaking space from a normal space.
</p>
	</li>
	<li>
<p class="req">`048-IC@cf
内容は、
`文字~escape$に 16 進, 10 進どちらの形も利用できるときは，
16 進~形を利用するベキである。
◎
C048 [I] [C] Content SHOULD use the hexadecimal form of character escapes rather than the decimal form when there are both.
</p>

<p class="note">注記：
文字~符号化法の標準（特に~Unicode）は、
通例的に，文字の符号値を 16 進~形として~listするので、
16 進~形の方が表引きが容易であり，選好される。
◎
NOTE: The hexadecimal form is preferred because character encoding standards (in particular Unicode) usually list character numbers as hexadecimal, making lookup easier.
</p>
	</li>
</ul>

		</section>

	<section id="sec-Compatibility">
<h2 title="Compatibility and Formatting Characters">5. 互換y文字と書式~文字</h2>

<p>
この仕様は、
`~markup言語$の利用における特定0の文字の適性については取組まない。
特に、
`書式~文字$および`互換y等価$
— これらの文字の利用についての詳細な推奨は、
`UXML$r （ “`~XML$その他の~markup言語における~Unicode” ）を見よ。
◎
This specification does not address the suitability of particular characters for use in markup languages, in particular formatting characters and compatibility equivalents. For detailed recommendations about the use of compatibility and formatting characters, see Unicode in XML and other Markup Languages [UXML].
</p>

<p class="req">`050-S@cf
仕様は、
それが定義する形式の構文-要素（`~markup$, 区切子, 識別子）から，`互換y文字$を除外するベキである。
◎
C050 [S] Specifications SHOULD exclude compatibility characters in the syntactic elements (markup, delimiters, identifiers) of the formats they define.
</p>

	</section>
	<section id="sec-Indexing">
<h2 title="Strings">6. 文字列</h2>

		<section id="sec-Strings">
<h3 title="String concepts">6.1. 文字列の概念（ `concept^en ）</h3>

<p>
様々な仕様が
`文字列^q
（ `string^en ）の観念（ `notion^en ）を利用するが、
何を意味するか精確に定義されなかったり，他の仕様と異なるように定義されることもある。
実際、
文字列には その観念に意図される利用に依存して，適理な定義が複数ある。
これらは、
実際には同じ実在
— ~computer内に格納される~text片 —
に対し，異なる見方を与えるものに過ぎないので、
これら異なる観念のどれにも，用語 `文字列^q が利用されるのである。
◎
Various specifications use the notion of a 'string', sometimes without defining precisely what is meant and sometimes defining it differently from other specifications. The reason for this variability is that there are in fact multiple reasonable definitions for a string, depending on one's intended use of the notion; the term 'string' is used for all these different notions because these are actually just different views of the same reality: a piece of text stored inside a computer.
</p>

<p class="trans-note">【
“~~文字列”
— 訳語としては，この語が定着しているが、
英語として より一般には
“`同種のもの^emが成す並び”
を意味し，
“`文字^emが成す列”
よりも抽象的な概念を表す。
】</p>

<dl class="def-list">
	<dt>
`~byte文字列@
◎
Byte string:＼
</dt>
	<dd>
特定0の`文字~符号化法$の下で、
文字~並びを［
それを表現する`~byte$並び
］として捉えたときの文字列。
これは`文字~符号化~scheme$（ CES ）に対応する。
`~byte文字列$の~text処理は、
それに利用されている特定0の符号化法に依存する。
符号化法が変更された場合，その処理も，新たな符号化法の構造が反映されるように変更されなければならなくなる。
そのような変更は、
その`~byte文字列$が~textとして処理される際に利用される関数や~APIを，大きく設計し直すことを要求し得る。
したがって この定義が仕様において有用になるのは、
文字列の~textな資質が重要ではない，文字列が単に~byte列の長さを伴う “不透明な” ~data片と見なされるときに限られる（~bufferを複製するときなど）。
◎
A string viewed as a sequence of bytes representing characters in a particular character encoding. This corresponds to a character encoding scheme (CES). Text processing of a byte string is dependent on the particular encoding used. When the encoding changes the processing must also be changed to reflect the stucture of the new encoding. Such a change could require significant redesign of the functions or API used to process the byte strings as text. Therefore, this definition is only useful in specifications when the textual nature of a string is unimportant and the string is considered only as a piece of opaque data with a length in bytes (such as when copying a buffer).
</dd>
	<dd class="req">`011-S@cf
仕様は、
文字列を`~byte文字列$として定義するベキでない。
◎
C011 [S] Specifications SHOULD NOT define a string as a 'byte string'.
</dd>
	<dd class="example">
次の例は、
文字列を`~byte文字列$と見なすと問題になり得る理由の一つを~~説明するものである：
`~big-endian$による~byte順で `UTF-16$ec に符号化された（ `UTF-16BE^ec ）文字
【！𣎴】 `233B4^U （“切り株” を意味する，~Chineseの文字）を含む~textを考える。
この~textは，~byte列 D8 4C DF B4 を含むことになる。
この~textが`~byte文字列$と見なされた場合、
文字 `4CDF^U 【！䳟】（ “不死鳥” を意味する別の~Chineseの文字）が探索される際に， `4CDF^U の `UTF-16BE^ec 表現である~byte列 4C DF に誤って合致することになる。
◎
EXAMPLE: This is a counter-example, illustrating one reason why considering strings as byte strings may be problematic. Consider text containing the character U+233B4 (a Chinese character meaning 'stump of tree') encoded as UTF-16 in big-endian byte order (UTF-16BE). The text will contain the bytes D8 4C DF B4. If one searches this text, considered as a byte string, for the character U+4CDF (another Chinese character meaning 'phoenix'), an erroneous match will be found on the bytes 4C DF that are the UTF-16BE representation of U+4CDF.
</dd>

	<dt>
`符号単位~文字列@
◎
Code unit string:＼
</dt>
	<dd>
特定0の`文字~符号化法$の下で、
文字~並びを［
それを表現する`符号単位$並び
］として捉えたときの文字列。
これは、
`文字~符号化~形0$に対応する。
符号単位~文字列の定義には、
符号単位の~size（例： 16 ~bit）, および
利用する文字~符号化法（例： `UTF-16$ec ）を含める必要がある。
符号単位~文字列は、
実装の候補になると見込まれる符号化~形0について依拠-可能な知識に基づいた，文字列~dataの物理的な表現を公開する~APIにおいて有用になる。
例えば `DOM1$r では、
広範な実装の実施に基づいて， `UTF-16$ec が選ばれている。
一般に， “符号単位~文字列” は、
当の実装の候補が `UTF-16$ec または `UTF-32$ec である場合に限り有用になる。
◎
Code unit string: A string viewed as a sequence of code units representing characters in a particular character encoding. This corresponds to a character encoding form (CEF). A definition of a code unit string needs to include the size of the code units (e.g. 16 bits) and the character encoding used (e.g. UTF-16). Code unit strings are useful in APIs that expose a physical representation of string data based on reliable knowledge of the encoding forms that are likely candidates for implementation. Example: For the DOM [DOM Level 1], UTF-16 was chosen based on widespread implementation practice. In general, 'code unit string' is only useful if the implementation candidates are likely to be either UTF-16 or UTF-32.
</dd>

	<dt>
`文字~文字列@
◎
Character string:
</dt>
	<dd>
各~文字が~Unicode `Unicode$r の`符号位置$で表現される，文字~並びとして捉えたときの文字列。
これは、
~programmerたちが通例的に文字列と見なしているものである
— ほとんどの利用者から知覚される文字とは、
正確に合致しないかもしれないが。
これが、
わずかな実装の労で相互運用能を確保できるような，最も高次な抽象-化を成す層である。
“文字~文字列” の定義による文字列が、
一般に最も有用になる。
この定義を利用する好例には、
次が挙げられる
⇒＃
`XML10$r の生成規則 “[2]” ／
`HTML401$r の SGML 宣言 ／
`RFC2070$r の文字~model
◎
A string viewed as a sequence of characters, each represented by a code point in Unicode [Unicode]. This is usually what programmers consider to be a string, although it may not match exactly what most users perceive as characters. This is the highest layer of abstraction that ensures interoperability with very low implementation effort. The 'character string' definition of a string is generally the most useful. Good examples using this definition include the Production [2] of XML 1.0 [XML 1.0], the SGML declaration of HTML 4.0 [HTML 4.01], and the character model of RFC 2070 [RFC 2070].
</dd>
	<dd class="trans-note">【
~~文字文字列（ `character string^en ）
— 訳語としては不自然な重複になってしまうが、
この節の冒頭で注釈した様に
“文字列” という語自体が訳語として定着しているため，致し方ない所でも。
】</dd>
	<dd class="req">`012-S@cf
ほとんどの仕様には、
`文字~文字列$の定義が利用されるベキである。
◎
C012 [S] The 'character string' definition SHOULD be used by most specifications.
</dd>
</dl>

<div class="example">

<p>
次の表tの各行に、
文字［
`233B4^U （“切り株” を意味する，~Chineseの文字）,
`2260^U `NOT EQUAL TO^cn,
`0071^U `LATIN SMALL LETTER Q^cn,
`030C^U `COMBINING CARON^cn
］からなる，~big-endian ~byte順で `UTF-16$ec に符号化された文字列に対し，［
`文字~文字列$,
`符号単位~文字列$,
`~byte文字列$
］で捉えた様子を順に示す：
◎
EXAMPLE: Consider the string comprising the characters U+233B4 (a Chinese character meaning 'stump of tree'), U+2260 NOT EQUAL TO, U+0071 LATIN SMALL LETTER Q and U+030C COMBINING CARON, encoded in UTF-16 in big-endian byte order. The rows of the following table show the string viewed as a character string, code unit string and byte string, respectively:
</p>

<table>
<caption>
［
文字／`符号単位$／~byte
］並びとしての，文字列
◎
table displaying a string viewed as characters, code units and bytes
</caption>
<tbody>

<tr><th>~glyph（画像）
<td colspan="4">
<p class="alt" hidden id="_dgm-chineseSurrogate">
表意的かつ補足的な文字： “切り株” を意味する古代中国~文字（広東語では現在も利用されている）。
◎
Ideographic supplementary character: Archaic Chinese character meaning &quot;the stump of a tree&quot; (still in current use in Cantonese)
</p>
<td colspan="2">`not_equal^dgm
<td colspan="2">`Q^dgm
<td colspan="2">`caron^dgm

<tr><th>【~glyph（~text）】
<td colspan="4">&#x233B4;
<td colspan="2">&#x2260;
<td colspan="2">&#x0071;
<td colspan="2">&#x030C;

<tr><th>`文字~文字列$
<td colspan="4">`233B4^U
<td colspan="2">`2260^U
<td colspan="2">`0071^U
<td colspan="2">`030C^U

<tr><th>`符号単位~文字列$
<td colspan="2">D84C
<td colspan="2">DFB4
<td colspan="2">2260
<td colspan="2">0071
<td colspan="2">030C

<tr><th>`~byte文字列$
<td>D8
<td>4C
<td>DF
<td>B4
<td>22
<td>60
<td>00
<td>71
<td>03
<td>0C
</table>
</div>

<p class="note">注記：
文字列は、
`書記素~cluster@
（ `grapheme cluster$UT ）の並びとして見ることアリである。
`書記素~cluster$は、
`文字~文字列$よりも，［
【！視覚的に】描画された~textにおいて 利用者から知覚される文字の境界
］に近い単位に~textを分割0する。
書記素~clusterについての論は `Unicode40$r の § 2.10 の末尾に与えられている。
正式な定義は `UTR29$r にて与えられる。
`~Unicode標準$は、
`既定の^em書記素~clusterを定義する。
一部の言語では、
この既定を`もっと誂える^emことが要求される。
例えば，~Slovakの利用者は、
既定では書記素~clusterの~pairを成す `ch^ch を，単独の書記素~clusterとして扱うよう望むであろう。
文字列~内容の言語と末端利用者の選好との間の相互作用は、
複階的なものになり得ることに注意。
◎
NOTE: It is also possible to view a string as a sequence of grapheme clusters. Grapheme clusters divide the text into units that correspond more closely than character strings to the user's perception of where character boundaries occur in a visually rendered text. A discussion of grapheme clusters is given at the end of Section 2.10 of the Unicode Standard, Version 4 [Unicode 4.0]; a formal definition is given in Unicode Standard Annex #29 [UTR #29]. The Unicode Standard defines default grapheme clustering. Some languages require tailoring to this default. For example, a Slovak user might wish to treat the default pair of grapheme clusters "ch" as a single grapheme cluster. Note that the interaction between the language of string content and the end-user's preferences may be complex.
</p>

		</section>
		<section id="sec-stringIndexing">
<h3 title="String indexing">6.2. 文字列の付番</h3>

<p>
~softwareの処理が［
部分文字列／文字列の中のある一点
］への~accessを必要とし，~index
— すなわち，文字列の中の数的な “位置” —
を利用してそれを行う状況は数多くある。
そのような~indexが~Web上の~component間で交換されても，挙動の一貫性が保たれるためには、
文字列の付番（文字列の中の各位置への~indexの振り方）について合意しておく必要がある。
文字列の付番~用の要件は
`CharReq$r, `§ 4＠~TR/WD-charreq#4$
（文字列の同一性~照合~用の要件）にて論じられる。
主な問いは 2 つある：
(1) “どのような単位に基づいて数えるか？”
(2) “0 か 1 どちらを起点にするか？”
◎
There are many situations where a software process needs to access a substring or to point within a string and does so by the use of indices, i.e. numeric "positions" within a string. Where such indices are exchanged between components of the Web, there is a need for an agreed-upon definition of string indexing in order to ensure consistent behavior. The requirements for string indexing are discussed in Requirements for String Identity Matching [CharReq], section 4. The two main questions that arise are: "What is the unit of counting?" and "Do we start counting at 0 or 1?".
</p>

<p>
前節
`§ 文字列の概念$では、
文字列が［
`文字~文字列$／
`符号単位~文字列$／
`~byte文字列$
］として捉えられることを示した。
そのそれぞれが異なる単位に基づく付番を孕んでいる。
◎
The example in the previous section, 6.1 String concepts, shows a string viewed as a character string, code unit string and byte string, respectively, each of which involves different units for indexing.
</p>

<p>
処理の特定0の要件に依存して、
数え方の単位は
`§ 文字列の概念$にて与えた，文字列の様々な定義に対応し得る。
特に：
◎
Depending on the particular requirements of a process, the unit of counting may correspond to definitions of a string provided in section 6.1 String concepts. In particular:
</p>

<ul>
	<li>
<p class="req">`051-SI@cf
文字列の付番は、
`文字~文字列$に基づくものが推奨される。
◎
C051 [S] [I] The character string is RECOMMENDED as a basis for string indexing.
</p>

<p>
（例： `XPath$r）。
◎
(Example: the XML Path Language [XPath]).
</p>

	</li>
	<li>
<p class="req">`052-SI@cf
内部~演算の効率が`文字~文字列$に基づく付番に比して有意に向上する場合は、
`符号単位~文字列$に基づく文字列の付番が利用されてもヨイ。
◎
C052 [S] [I] A code unit string MAY be used as a basis for string indexing if this results in a significant improvement in the efficiency of internal operations when compared to the use of character string.
</p>

<p>
（例： `DOM1$r における `UTF-16$ec の利用）。
◎
(Example: the use of UTF-16 in [DOM Level 1]).
</p>
	</li>
	<li>

<p class="req">`071-SI@cf
利用者-ヤリトリが首に懸念される応用においては、
`書記素~cluster$に基づく文字列の付番が利用されてもヨイ。
◎
C071 [S] [I] Grapheme clusters MAY be used as a basis for string indexing in applications where user interaction is the primary concern.
</p>

<p>
`UTR29$r, Text Boundaries を見よ。
◎
See Unicode Standard Annex #29, Text Boundaries [UTR #29].
</p>

<p class="req">`074-S@cf
`書記素~cluster$の用語で付番を定義する仕様は、
次のいずれかにより定義しなければナラナイ
⇒＃
(a) `UTR29$r, Text Boundaries にて定義される既定の書記素~clusterの用語で，書記素~clusterを定義する／
(b) 付番~演算に対する`誂え^emをどう適用するかを特定的に定義する。
◎
C074 [S]Specifications that define indexing in terms of grapheme clusters MUST either: a) define grapheme clusters in terms of default grapheme clusters as defined in Unicode Standard Annex #29, Text Boundaries [UTR #29], or b) define specifically how tailoring is applied to the indexing operation.
</p>

	</li>
	<li>
<p class="req">`072-SI@cf
`~byte文字列$に基づく付番は推奨されない。
◎
C072 [S] [I] The use of byte strings for indexing is NOT RECOMMENDED.
</p>
	</li>
</ul>
<hr>

<p>
数的でない仕方で部分文字列を識別しつつ，都合の良い特質を備えるような、
特記すべき仕方もある。
一例として、
文字列~照合に基づく部分文字列は，小さな編集に対してはかなり堅牢であり、
文書~構造に基づく部分文字列（`~XML$などの構造的な形式）は，編集に対し, あるいは別の自然言語への翻訳においてすらも，より堅牢である。
◎
It is noteworthy that there exist other, non-numeric ways of identifying substrings which have favorable properties. For instance, substrings based on string matching are quite robust against small edits; substrings based on document structure (in structured formats such as XML) are even more robust against edits and even against translation of a document from one human language to another.
</p>

<p class="req">`053-S@cf
部分文字列や 文字列の中のある一点を識別する仕方を必要とする仕様は、
この演算を遂行するためとして，文字列の付番 以外による仕方も供するベキである。
◎
C053 [S] Specifications that need a way to identify substrings or point within a string SHOULD provide ways other than string indexing to perform this operation.
</p>

<p class="req">`054-IC@cf
仕様の利用者（~software開発者, 内容~開発者）は、
部分文字列や文字列の中のある一点を識別するときは，アリな所では 文字列の付番~以外の仕方を選ぶベキである。

◎
C054 [I] [C] Users of specifications (software developers, content developers) SHOULD whenever possible prefer ways other than string indexing to identify substrings or point within a string.
</p>

<p>
経験から、
個々の文字は，部分文字列の［
前／後
］の位置から識別される部分文字列として解する下で処理した方が、
より［
一般的, 柔軟, 堅牢
］な仕様になることが判っている。
~indexを［
数え方の単位
］の`狭間^emを指す位置と解することで、
他の文字列~定義による~indexに関係させ易くなる。
◎
Experience shows that more general, flexible and robust specifications result when individual characters are understood and processed as substrings, identified by a position before and a position after the substring. Understanding indices as boundary positions between the counting units also makes it easier to relate the indices resulting from the different string definitions.
</p>

<p class="req">`055-S@cf
仕様は、
1 個の文字を部分文字列として解する下で処理して，選ばれた数え方の単位に関わらず，~indexをその単位の`狭間^emを指す位置として扱うベキである。
◎
C055 [S] Specifications SHOULD understand and process single characters as substrings, and treat indices as boundary positions between counting units, regardless of the choice of counting units.
</p>

<p class="req">`056-S@cf
~APIの仕様は、
引数や返り値の型として， 1 個の［
文字／符号化
］が成す単位を指定するベキでない。
◎
C056 [S] Specifications of APIs SHOULD NOT specify single characters or single 'units of encoding' as argument or return types.
</p>

<p class="example">
仮に “大文字化” 関数 `uppercase()^c の返り値~型が 1 個の文字として定義された場合、
`uppercase("ß")^c は，適正な結果（ 2 文字からなる`文字~文字列$ `SS^ch ）を返せなくなる。
【現在の~Unicodeには "ß" の大字 （ "ẞ" ）もあるので，この例は文脈によっては適切でないかもしれない。】
また， `§ 文字の知覚$にて述べたように、
文字と［
響き, 入力, 等々を成す単位
］の間に一対一な対応関係があるとは限らないことにも注意。
◎
EXAMPLE: The function uppercase("ß") cannot return the proper result (the two-character string 'SS') if the return type of the uppercase function is defined to be a single character. Note, also, that there is not necessarily a one-to-one mapping between characters and units of sound, input, etc. as described in 3 Perceptions of Characters.
</p>

<p>
~indexの起点，すなわち 0, 1 のいずれから数えるかについて
—
この課題は、
実際には，［
単位それ自身を数えるか, 単位の狭間を指す位置を数えるか
］の裁定が下された後に限り発生する。
◎
The issue of index origin, i.e. whether we count from 0 or 1, actually arises only after a decision has been made on whether it is the units themselves that are counted or the positions between the units.
</p>

<p class="req">`057-S@cf
文字列の付番において単位の狭間を指す位置が数えられる場合、
文字列の始端を~index 0 と定めることが推奨される。
その場合、
最後の~indexは，文字列に含まれる単位の個数になる。
◎
C057 [S] When the positions between the units are counted for string indexing, starting with an index of 0 for the position at the start of the string is the RECOMMENDED solution, with the last index then being equal to the number of counting units in the string.
</p>

		</section>
	</section>
	<section id="sec-RefUnicode">
<h2 title="Referencing the Unicode Standard and ISO/IEC 10646">7. ~Unicode標準や ISO/IEC 10646 を参照するとき</h2>

<p>
仕様は，`~Unicode標準$や国際標準 `ISO/IEC-10646$r を参照する必要が生じることが多い。
とりわけ，規範として参照するときは、
注意深く行われなければならない。
考慮されるべき問いは：
◎
Specifications often need to make references to the Unicode Standard or International Standard ISO/IEC 10646. Such references must be made with care, especially when normative. The questions to be considered are:
</p>

<ul>
	<li>
どの標準が参照されるべきか？
◎
Which standard should be referenced?
</li>
	<li>
特定0の~versionはどのように参照するのか？
◎
How to reference a particular version?
</li>
	<li>
どのようなときに，~version付きのものそうでないものを利用するのか？
◎
When to use versioned vs. unversioned references?
</li>
</ul>

<hr>

<p>
`ISO/IEC-10646$r は
<abbr title="International Organization for Standardization">`ISO＠http://www.iso.org/iso/en/ISOOnline.openerpage$</abbr>
（国際標準化機構）と
<abbr title="International Electrotechnical Commission">`IEC＠http://www.iec.ch/$</abbr>
（国際電気標準会議）の共同により，開発され, 公表された。
`~Unicode標準$は
`Unicode Consortium＠https://www.unicode.org/$en
（~~主要な~computer企業, ~software製作者, ~database~vendor, 各国政府, 研究機関, 国際的機関, 様々な利用者~groupや関心を持つ各個人, … からなる組織）により開発され，公表された。
`~Unicode標準$の立ち~~位置は、
~W3C勧告に相当する。
◎
ISO/IEC 10646 is developed and published jointly by ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commission). The Unicode Standard is developed and published by the Unicode Consortium, an organization of major computer corporations, software producers, database vendors, national governments, research institutions, international agencies, various user groups, and interested individuals. The Unicode Standard is comparable in standing to W3C Recommendations.
</p>

<p>
`ISO/IEC-10646$r と`~Unicode標準$は、
正確に同じ［
`有符号~文字~集合$（ CCS ）（同じ`~repertoire$, 同じ`符号位置$）と符号化~形0
］を定義する。
それらは、
各 技術委員会どうしの情報交換やメンバの重なり合いの中で活動的に保守されている。
共同により定義された `CCS^abbr と符号化~形0に加えて、
`~Unicode標準$では［
各種 文字~propの規範的な（および参考の）~list,
文字の［
`等価性$／`正規化$
］についての規範的な仕様,
`双方向-~text$用の規範的な~algo,
実装に有用な数多の情報
］も追加している。
手短に言えば、
`~Unicode標準$は `ISO/IEC-10646$r が単に列挙している文字に意味論を追加している。
`~Unicode標準$への適合性は `ISO/IEC-10646$r への適合性も含意する。
`Unicode40$r Appendix C を見よ。
◎
ISO/IEC 10646 and the Unicode Standard define exactly the same coded character set (CCS) (same repertoire, same code points) and encoding forms. They are actively maintained in synchrony by liaisons and overlapping membership between the respective technical committees. In addition to the jointly defined CCS and encoding forms, the Unicode Standard adds normative and informative lists of character properties, normative character equivalence and normalization specifications, a normative algorithm for bidirectional text and a large amount of useful implementation information. In short, the Unicode Standard adds semantics to the characters that ISO/IEC 10646 merely enumerates. Conformance to the Unicode Standard implies conformance to ISO/IEC 10646, see [Unicode 4.0] Appendix C.
</p>

<p class="req">`062-S@cf
一般に，仕様は、［
利用する文字, それに結付けられる意味論
］を定義する必要があるので
— `ISO/IEC-10646$r への参照を含めようが含めまいが —
`~Unicode標準$への参照を含めるベキである。
◎
C062 [S] Since specifications in general need both a definition for their characters and the semantics associated with these characters, specifications SHOULD include a reference to the Unicode Standard, whether or not they include a reference to ISO/IEC 10646.
</p>

<p>
`~Unicode標準$への参照を供することにより、
実装者は，その標準, および
`Unicode Consortium^en の~Web~siteが供する豊富な情報による便益を得られる。
◎
By providing a reference to the Unicode Standard implementers can benefit from the wealth of information provided in the standard and on the Unicode Consortium Web site.
</p>

<p>
`ISO/IEC-10646$r と`~Unicode標準$は（同調的に）発展し続けているので、
~version付けの課題も生じる：
仕様は、
標準な特定の~versionを参照rすべきか？
それとも，規範的な参照が［
当の仕様が`読まれている時点^emの~version
］を指すようにするために，総称的な参照にすべきか？
—
一般に、
その答えは`両者^emである。
◎
The fact that both ISO/IEC 10646 and the Unicode Standard are evolving (in synchrony) raises the issue of versioning: should a specification refer to a specific version of the standard, or should it make a generic reference, so that the normative reference is to the version current at the time of reading the specification? In general the answer is both.
</p>

<p class="req">`063-S@cf
仕様の公表-後に割振られた文字が，当の仕様で利用-可能になることが欲される場合、
`~Unicode標準$への総称的な参照を含めなければナラナイ。
特定0の~versionに依存する機能性が［
いつでも可用, かつ時を経ても変化しない
］ことを確保するときは、
特定の`~Unicode標準$への参照を含めてもヨイ。
◎
C063 [S] A generic reference to the Unicode Standard MUST be made if it is desired that characters allocated after a specification is published are usable with that specification. A specific reference to the Unicode Standard MAY be included to ensure that functionality depending on a particular version is available and will not change over time.
</p>

<p>
例えば、
 `XML10$r における，
`Name^P 文字として受容-可能な文字の集合
— それは、［
構文解析器が名前を検証するために実装しなければならない文字
］を列挙した~listである。
◎
An example would be the set of characters acceptable as Name characters in XML 1.0 [XML 1.0], which is an enumerated list that parsers must implement to validate names.
</p>

<p class="note">注記：
`~Unicode標準$の特定の~versionを参照するための指針については、
`https://www.unicode.org/unicode/standard/versions/#Citations＠https://www.unicode.org/unicode/standard/versions/#Citations$
を見よ。
◎
NOTE: See http://www.unicode.org/unicode/standard/versions/#Citations for guidance on referring to specific versions of the Unicode Standard.
</p>

<p>
正式な総称的な参照の仕方には、
次の 2 つがある：
◎
A generic reference can be formulated in two ways:
</p>
<ol>
	<li>
仕様の “§ 参照文献” に “`総称的^emな” ~entryを明示的に含めた上で、
単純に仕様の本文から，その~entryを参照する。
そのような総称的な~entryには、
次のような~textを含める
⇒
“…これは、
時と伴に改訂-または改正され得る”
◎
By explicitly including a generic entry in the bibliography section of a specification and simply referring to that entry in the body of the specification. Such a generic entry contains text such as "... as it may from time to time be revised or amended".
</li>
	<li>
参照文献に “`特定の^em” ~entryを含めた場合、
仕様の本文の中で参照を与える所に，次のような~textを含める
⇒
“…これは時と伴に改訂-または改正され得るので…”
◎
By including a specific entry in the bibliography and adding text such as "... as it may from time to time be revised or amended" at the point of reference in the body of the specification.
</li>
</ol>

<hr>

<p>
これら 2 つの定式化のどちらを利用するかは、
各~仕様の編集上の~~裁量に委ねられる。
前者の定式化の例は、
この仕様の参照文献に見出せる（ `ISO/IEC-10646$r, `Unicode$r を見よ）。
後者の例, および［
`UCS$ 符号化法~用の~MIME `charset^c ~parameterに対する~version付けの課題
］に関する論は、
`RFC3629$r, `RFC2781$r
に見出せる。
◎
It is an editorial matter, best left to each specification, which of these two formulations is used. Examples of the first formulation can be found in the bibliography of this specification (see the entries for [ISO/IEC 10646] and [Unicode]). Examples of the latter, as well as a discussion of the versioning issue with respect to MIME charset parameters for UCS encodings, can be found in [RFC 3629] and [RFC 2781].
</p>

<p class="req">`064-S@cf
`~Unicode標準$へのすべての`総称的^emな参照は、
仕様の公表~日に可用な~Unicode標準の最新の~versionを参照rしなければナラナイ。
◎
C064 [S] All generic references to the Unicode Standard [Unicode] MUST refer to the latest version of the Unicode Standard available at the date of publication of the containing specification.
</p>

<p class="req">`065-S@cf
`ISO/IEC-10646$r へのすべての`総称的^emな参照は、
仕様の公表~日に可用な ISO/IEC 10646 の最新の~versionを参照rしなければナラナイ。
◎
C065 [S] All generic references to ISO/IEC 10646 [ISO/IEC 10646] MUST refer to the latest version of ISO/IEC 10646 available at the date of publication of the containing specification.
</p>

	</section>
	<section id="sec-CharExamples">
<h2 title="Examples of Characters, Keystrokes and Glyphs (Non-Normative)">B. 文字, ~keystroke, ~glyphの例（非規範的）</h2>

<p id="exampleA6">
この節では、
~computerにおける このような~textの複階性（そのほとんどは、
ヒトの`書記体系$の複階性を反映する）の~~全体像の~~把握に役立つであろう，少数の例を挙げる。
◎
A few examples will help make sense all this complexity of text in computers (which is mostly a reflection of the complexity of human writing systems). Let us start with a very simple example:＼
</p>

<p>
最初はごく単純な例から：
US-English ~keyboardを使う利用者が
“<kbd>`F^kbd`o^kbd`o^kbd</kbd>”
と打込んだとする。
~computerでは 16-bit 値として符号化され（ ~Unicodeの `UTF-16$ec 符号化法）, ~screenに表示される。
◎
a user, equipped with a US-English keyboard, types "Foo", which the computer encodes as 16-bit values (the UTF-16 encoding of Unicode) and displays on the screen.
</p>

<table>
<caption>
Basic Latin の例
<small>（
 U.S. ~keyboardで
<kbd>`F^kbd`o^kbd`o^kbd</kbd>
が打込まれたときの~keystroke, 入力~文字, 符号化された文字, その表示の一覧
）</small>
◎
Example: Basic Latin
(Table showing keystrokes, input characters, encoded characters and display for user typing Foo on a U.S. keyboard)
</caption>

<tbody>

<tr class="kbd"><th>~keystroke
<td>Shift-f
<td>o
<td>o

<tr><th>入力~文字
<td>F
<td>o
<td>o

<tr><th>`符号化された文字$（16 進~byte値）
<td>0046
<td>006F
<td>006F

<tr><th>~text
<td colspan="3">`Foo^kbd
</table>

<p>
唯一，大字の `F^ch を入力するために修飾key（ <kbd>`Shift^kbd</kbd> ）を利用する所だけ、
単純でない。
◎
The only complexity here is the use of a modifier (Shift) to input the capital 'F'.
</p>

<p>
もう少し複階的な例を示す。
利用者が伝統的~French-Canadian~keyboardで
`çé^kbd
（ <kbd>`¸^kbd`c^kbd`é^kbd</kbd> ）と打込んだとする（ここでも，~computer上では `UTF-16$ec に符号化されて表示されると見做す）。
ここでは、
この~computerが `UTF-16$ec による全部的に組成済みな【`分解-可能$な】形（ `composed form^en ）を利用していると見做す。
◎
A slightly more complex example is a user typing 'çé' on a traditional French-Canadian keyboard, which the computer again encodes in UTF-16 and displays. We assume that this particular computer uses a fully composed form of UTF-16.
</p>

<table>
<caption>
`発音区別符$を伴う~Latinの例
<small>（
~French-Canadian~keyboardで
`çé^kbd
が打込まれたときの~keystroke, 入力~文字, 符号化された文字, その表示の一覧
）</small>
◎
Example: Latin with diacritics
(Table showing keystrokes, input characters, encoded characters and display for user typing çé on a French-Canadian keyboard)
</caption>

<tbody>

<tr class="kbd"><th>~keystroke
<td>¸
<td>c
<td>é

<tr><th>入力~文字
<td colspan="2">ç
<td>é

<tr><th>`符号化された文字$（16 進~byte値）
<td colspan="2">00E7
<td>00E9

<tr><th>~text
<td colspan="3">`çé^kbd
</table>

<p>
注目される点が少しばかりある：
まず，利用者が`~cedilla$（ <kbd>`¸^kbd</kbd> ）を打込んでも、
~keyboard~driverの状態が変化することを除いて，何も起きない
—
`~cedilla$は~dead-keyである。
続いて，~driverにて~keystroke <kbd>`c^kbd</kbd> が~~検知されると、
 1 個の 16-bit `符号単位$として表現される完全な文字 `ç^ch が~systemに供され，`~glyph$ `ç^ch が表示される。
次に，利用者が専用の
<kbd>`é^kbd</kbd>
~UIkeyを押下げた場合も、
 2 個の~byteで表現される 1 個の文字になる。
ほとんどの~systemは，これを 1 個の~glyphで表示するが、
2 個の~glyph（基底 `字l$と`~accent$）を組合せて同じ描画を得することもアリである。
◎
A few interesting things are happening here: when the user types the cedilla ('¸'), nothing happens except for a change of state of the keyboard driver; the cedilla is a dead key. When the driver gets the c keystroke, it provides a complete 'ç' character to the system, which represents it as a single 16-bit code unit and displays a 'ç' glyph. The user then presses the dedicated 'é' key, which results in, again, a character represented by two bytes. Most systems will display this as one glyph, but it is also possible to combine two glyphs (the base letter and the accent) to obtain the same rendering.
</p>

<p>
~Japaneseの例：
利用者が~romaji~IMEを利用して “`~~日本語^kbd” （ `65E5^U, `672C^U, `8A9E^U ）と打込んで，~computer上では、
 `UTF-16$ec に符号化されて表示されるとする。
◎
On to a Japanese example: our user employs a romaji input method to type '日本語' (U+65E5, U+672C, U+8A9E), which the computer encodes in UTF-16 and displays.
</p>

<table>
<caption>
~Japaneseの例
<small>（
~Japanese ~romaji~IMEで
<kbd>`n^kbd`i^kbd`h^kbd`o^kbd`n^kbd`g^kbd`o^kbd</kbd>
が打込まれたときの~keystroke, 入力~文字, 符号化された文字, その表示の一覧
）</small>
◎
Example: Japanese
(Table showing keystrokes, input characters, encoded characters and display for user typing nihongo in a Japanese Romaji input method)
</caption>

<tbody>

<tr class="kbd"><th>~keystroke
<td colspan="3">n i h o n g o &lt;space&gt; &lt;return&gt;

<tr><th>入力~文字
<td>~~日
<td>~~本
<td>~~語

<tr><th>`符号化された文字$（16 進~byte値）
<td>65E5
<td>672C
<td>8A9E

<tr><th>表示（~text）
<td colspan="3">`~~日本語^s
</table>

<p>
ここで注目される点は入力である：
利用者が打込んだ~Latin文字は、
まず（ここには示されないが）その場で仮名に変換される。
利用者は~~望むだけ <kbd>`space^kbd</kbd> ~UIkeyを押下げて，それを変換する。
最終的に 利用者が <kbd>`return^kbd</kbd> ~UIkeyを押下げたとき，その`漢字$が応用に送信される。
この 3 文字は自明には生産されず、
それまでに 9 回の~keystrokeを要し，それらが符号化された上で表示される。
◎
The interesting aspect here is input: the user types Latin characters, which are converted on the fly to kana (not shown here), and then to kanji when the user requests conversion by pressing &lt;space&gt;; the kanji characters are finally sent to the application when the user presses &lt;return&gt;. The user has to type a total of nine keystrokes before the three characters are produced, which are then encoded and displayed rather trivially.
</p>

<p id="arabicLigature-0">
~Arabic`用字系$の下での~Persianでは，また異なる様相を~~呈する：
◎
A Persian example, using Arabic script, will show different phenomena:
</p>

<table>
<caption>
~Persianの例
<small>（
~Arabic~keyboardで打込まれたときの［
~keystroke, 入力~文字, 符号化された文字, それらの表示
］を示している表t
）</small>
◎
Example: Persian
(Table showing keystrokes, input characters, encoded characters and display for user typing on an Arabic keyboard)
</caption>

<tbody>
<tr><th>~keystroke（画像）
<td>`fa-lam^dgm
<td>`fa-alif^dgm
<td colspan="2">`fa-lamalif^dgm
<td>`fa-yeh^dgm
<td>`fa-yeh1^dgm
<tr class="kbd"><th>【~keystroke（~text）】

<td>&#x0644;
<td>&#x0627;
<td colspan="2">&#xFEFB;
<td>&#x06CC;
<td>&#x06CC;

<!-- 
<tr><th>入力~文字
<td>ل
<td>ا
<td>ل
<td>ا
<td>ی
<td>ی
 -->

<tr><th>入力~文字

<td>&#x0644;
<td>&#x0627;
<td>&#x0644;
<td>&#x0627;
<td>&#x06CC;
<td>&#x06CC;

<tr><th>`符号化された文字$（16 進~byte値）
<td>0644
<td>0627
<td>0644
<td>0627
<td>06CC
<td>06CC

<tr><th>表示（画像）
<td colspan="6">
<p class="alt" hidden id="_dgm-fa-laalaayee">
表示される出力は右から左の順に現れる：
2 個の lam-alef 合字に続き，farsi yeh ~glyphと尾字形の farsi yeh ~glyph。
◎
The displayed output appears, from right to left, as: two lam-alef ligatures, and initial farsi yeh glyph attached to a final farsi yeh glyph.
</p>
<tr><th>【表示（~text）】
<td colspan="6">`&#x0644;&#x0627;&#x0644;&#x0627;&#x06CC;&#x06CC;^s
<!-- 

لالایی

 -->
</table>

<p>
ここでは最初の 2 回の~keystrokeそれぞれが 1 個の入力~文字を経て 1 個の符号化された文字を生産するが、
その~pairは 1 個の`~glyph$として表示される（
`&#x0644;&#x0627;^ch — `合字$ `lam-alef^en
）。
次の~keystrokeは，一部の~Arabic用字系~keyboardに備わる <kbd>`lam-alef^kbd</kbd> であり， 1 回の~keystrokeで同じ 2 個の文字を生産し，前と同じように表示される。
この 2 個目の lam-alef は、
表示においては， 1 個目のそれの`左^emに置かれる。
最後の 2 回の~keystrokeは 2 個の一致する文字を生産するが， 2 個の異なる~glyphで描画される（中字形（ `medial form^en ）に後続して，その左に尾字形（ `final form^en ））。
したがって、
 5 回の~keystrokeから 6 個の文字が生産され， 4 個の~glyphが右から左へ~~配置される。
◎
Here the first two keystrokes each produce an input character and an encoded character, but the pair is displayed as a single glyph ('', a lam-alef ligature). The next keystroke is a lam-alef, which some Arabic script keyboards have; it produces the same two characters which are displayed similarly, but this second lam-alef is placed to the left of the first one when displayed. The last two keystrokes produce two identical characters which are rendered by two different glyphs (a medial form followed to its left by a final form). We thus have 5 keystrokes producing 6 characters and 4 glyphs laid out right-to-left.
</p>

<p id="sec-CharExamplesA5">
最後に~Tamilの例。
ISCII ~keyboardで打込まれ，追加的な様相が見られる：
◎
A final example in Tamil, typed with an ISCII keyboard, will illustrate some additional phenomena:
</p>

<table>
<caption>
~Tamilの例
<small>（
Tamil ISCII ~keyboardで打込まれたときの［
~keystroke, 入力~文字, 符号化された文字, それらの表示
］を示している表t
）</small>
◎
Example: Tamil
(Table showing keystrokes, input characters, encoded characters and display for user typing on a Tamil ISCII keyboard)
</caption>

<tbody>

<tr><th>~keystroke（画像）
<td>`ta-tm^dgm
<td>`a-tm^dgm
<td>`nga-tm^dgm
<td>`virama-tm^dgm
<td>`ka-tm^dgm
<td>`o-tm^dgm

<tr><th>入力~文字
<td>&#x0B9F;
<td>&#x0BBE;
<td>&#x0B99;
<td> &#x0BCD;
<td>&#x0B95;
<td>&#x0BCB;
<!-- ட／ா／ங／ ்／க／ோ -->

<tr><th>`符号化された文字$（16 進~byte値）
<td>0B9F
<td>0BBE
<td>0B99
<td>0BCD
<td>0B95
<td>0BCB

<tr><th>表示（画像）
<td colspan="6">
<p class="alt" hidden id="_dgm-tango">
~Tamilの字lによる 'Tango'
◎
'Tango' in Tamil letters.
</p>
<tr><th>【表示（~text）】
<td colspan="6">`&#x0B9F;&#x0BBE;&#x0B99;&#x0BCD;&#x0B95;&#x0BCB;^s
<!-- டாங்கோ -->
</table>

<p>
ここでは入力~自体は素直であるが、
前掲の`~accent$を伴う~Latinの例とは逆に，`~virama$の`発音区別符$
`&#x0BCD;^ch (`0BCD^U)
が，その適用-対象の
`&#x0B99;^ch (`0B99^U)
の`後に^em入力される。
また、
最後の 2 個の文字の描画が特徴的である：
最後のもの
`&#x0BCB;^ch (`0BCB^U)
は明らかに 2 個の`~glyph$からなり，最後の手前の文字
`&#x0B95;^ch (`0B95^U)
の`~glyph$を`囲っている^em。
◎
Here input is straightforward, but note that contrary to the preceding accented Latin example, the virama diacritic '&#x0BCD;' (U+0BCD) is entered after the '&#x0B99;' (U+0B99) to which it applies. Rendering is interesting for the last two characters. The last one '&#x0BCB;' (U+0BCB) clearly consists of two glyphs which surround the glyph of the next to last character '&#x0B95;' (U+0B95).
</p>

	</section>
	<section id="sec-ExampleText">
<h2 title="Example text (Non-Normative)">C. ~textの例（非規範的）</h2>

<p>
以下に、
この文書で画像により例示された［
文字列／文字
］の~textな~versionを挙げる
…
【この訳では、それらを各例に含めているので，以下は省略する。】
◎
The following are textual versions of strings or characters used in image-based examples in this document. …
</p>

	</section>
	<section id="sec-Checklist">
<h2 title="List of conformance criteria (Non-Normative)">D. 適合性の判定基準の一覧（非規範的）</h2>

<p>
以下に、
文書~順に並べられたこの仕様の適合性の判定基準を挙げる
【が、この訳では`省略する＠#_list-of-req$】
。
［
仕様／実装／内容
］は、
この仕様への適合性を検査する際に，この~listを利用できる。
◎
This is a list of the conformance criteria in this specification, in document order. This list can be used to check specifications, implementations, and content for conformance to this specification.
</p>

<p>
その際には，次に挙げる点が念頭に置かれるべきである：
◎
When doing so, the following points should be kept in mind:
</p>

<ul>
	<li>
最初にこの文書~全体をよく読んで意味を理解しておくこと。
この~listは、
~textの本文の文脈の下で これらの適合性の判定基準を読んだ上で初めて，早見表の用をなす。
◎
To ensure that you understand the meaning, read the whole document first. Use this list as a quick reference only after having first read the conformance criteria in context in the main body of the text.
</li>
	<li>
この~listにおける適合性の判定基準の意味が、
それを囲んでいる，この文書の本文~textを読んだ上でも不明瞭ならば、
メーリングリスト（冒頭のメタデータ内）に~commentを寄せることも考慮されたし。
◎
If the meaning of a conformance criterion in this list is still unclear after referring back to the surrounding text in the main body of the document, consider sending a comment to www-i18n-comments@w3.org (publicly archived).
</li>
	<li>
すべての適合性の判定基準が，すべての［
仕様／実装／内容
］に適用されるわけではない。
実際の適合性を検査する前に，適用-可能かどうか検査されるべきである。
例えば `010-$cf は，仕様に対してのみ適用される。
別の例として， `002-$cf は［
仕様, 実装, 内容
］いずれにも適用されるが、
それは 文字と表示される~textの単位との対応関係を~~扱う場合に限られる。
◎
Not all conformance criteria apply to all specifications, implementations, or content. Before checking for actual conformance, applicability should be checked. As an example, C010 only applies to specifications. As another example, C002 applies to specifications, implementations, and content, but only if it deals with mapping between characters and units of displayed text.
</li>
</ul>

<div id="_checklist_"></div>

<!-- 
table id="req-checklist"
 -->

	</section>
	<section id="sec-Changes">
<h2 title="Changes since the Proposed Recommendation (Non-Normative)">E. 勧告案からの変更点（非規範的）</h2>

<ul>
	<li>
§ 参照文献の少数の~linkと参照を更新した。
◎
A small number of links and references were updated in the references section.
</li>
	<li>
`076-$cf の直後の段落を明確化するための編集上の変更
⇒
“<del>`iso-8859-1^ec で符号化される~repertoire</del>”
→
“<ins>ISO Latin 1 文字~集合の符号位置</ins>”
◎
Minor editorial change to paragraph after C076 to clarify: "This prohibits, for example, the construction of fonts that misuse the repertoire encoded by iso-8859-1 to represent different scripts, characters, or symbols than what is actually encoded in iso-8859-1." changed to "This prohibits, for example, the construction of fonts that misuse the codepoints in the ISO Latin 1 character set to represent different scripts, characters, or symbols than those actually encoded in iso-8859-1.".
</li>
</ul>

	</section>
	<section id="sec-Acknowledgements">
<h2 title="Acknowledgements (Non-Normative)">F. 謝辞（非規範的）</h2>

<p>
`Tim Berners-Lee^en と `James Clark^en 氏からは、
~URIに関する節に重要な詳細を供していただいた。
`Asmus Freytag^en, `Addison Phillips^en 氏, および早期~段階での `Ian Jacobs^en 氏からは、
著作と編集~過程にかなりの助力をいただいた。
多くの方々や~W3C の I18N WG と IG から、
有益な~commentと示唆を供していただいた。
◎
Tim Berners-Lee and James Clark provided important details in the section on URIs. Asmus Freytag , Addison Phillips, and in early stages Ian Jacobs, provided significant help in the authoring and editing process. The W3C I18N WG and IG, as well as many others, provided many helpful comments and suggestions.
</p>

	</section>
</main></div>
